{"buggy_code": ["\" Tests for autocommands\n\nsource shared.vim\nsource check.vim\nsource term_util.vim\n\nfunc s:cleanup_buffers() abort\n  for bnr in range(1, bufnr('$'))\n    if bufloaded(bnr) && bufnr('%') != bnr\n      execute 'bd! ' . bnr\n    endif\n  endfor\nendfunc\n\nfunc Test_vim_did_enter()\n  call assert_false(v:vim_did_enter)\n\n  \" This script will never reach the main loop, can't check if v:vim_did_enter\n  \" becomes one.\nendfunc\n\nif has('timers')\n\n  func ExitInsertMode(id)\n    call feedkeys(\"\\<Esc>\")\n  endfunc\n\n  func Test_cursorhold_insert()\n    \" Need to move the cursor.\n    call feedkeys(\"ggG\", \"xt\")\n\n    let g:triggered = 0\n    au CursorHoldI * let g:triggered += 1\n    set updatetime=20\n    call timer_start(100, 'ExitInsertMode')\n    call feedkeys('a', 'x!')\n    call assert_equal(1, g:triggered)\n    unlet g:triggered\n    au! CursorHoldI\n    set updatetime&\n  endfunc\n\n  func Test_cursorhold_insert_with_timer_interrupt()\n    if !has('job')\n      return\n    endif\n    \" Need to move the cursor.\n    call feedkeys(\"ggG\", \"xt\")\n\n    \" Confirm the timer invoked in exit_cb of the job doesn't disturb\n    \" CursorHoldI event.\n    let g:triggered = 0\n    au CursorHoldI * let g:triggered += 1\n    set updatetime=500\n    call job_start(has('win32') ? 'cmd /c echo:' : 'echo',\n          \\ {'exit_cb': {-> timer_start(1000, 'ExitInsertMode')}})\n    call feedkeys('a', 'x!')\n    call assert_equal(1, g:triggered)\n    unlet g:triggered\n    au! CursorHoldI\n    set updatetime&\n  endfunc\n\n  func Test_cursorhold_insert_ctrl_x()\n    let g:triggered = 0\n    au CursorHoldI * let g:triggered += 1\n    set updatetime=20\n    call timer_start(100, 'ExitInsertMode')\n    \" CursorHoldI does not trigger after CTRL-X\n    call feedkeys(\"a\\<C-X>\", 'x!')\n    call assert_equal(0, g:triggered)\n    unlet g:triggered\n    au! CursorHoldI\n    set updatetime&\n  endfunc\n\n  func Test_OptionSet_modeline()\n    call test_override('starting', 1)\n    au! OptionSet\n    augroup set_tabstop\n      au OptionSet tabstop call timer_start(1, {-> execute(\"echo 'Handler called'\", \"\")})\n    augroup END\n    call writefile(['vim: set ts=7 sw=5 :', 'something'], 'XoptionsetModeline')\n    set modeline\n    let v:errmsg = ''\n    call assert_fails('split XoptionsetModeline', 'E12:')\n    call assert_equal(7, &ts)\n    call assert_equal('', v:errmsg)\n\n    augroup set_tabstop\n      au!\n    augroup END\n    bwipe!\n    set ts&\n    call delete('XoptionsetModeline')\n    call test_override('starting', 0)\n  endfunc\n\nendif \"has('timers')\n\nfunc Test_bufunload()\n  augroup test_bufunload_group\n    autocmd!\n    autocmd BufUnload * call add(s:li, \"bufunload\")\n    autocmd BufDelete * call add(s:li, \"bufdelete\")\n    autocmd BufWipeout * call add(s:li, \"bufwipeout\")\n  augroup END\n\n  let s:li=[]\n  new\n  setlocal bufhidden=\n  bunload\n  call assert_equal([\"bufunload\", \"bufdelete\"], s:li)\n\n  let s:li=[]\n  new\n  setlocal bufhidden=delete\n  bunload\n  call assert_equal([\"bufunload\", \"bufdelete\"], s:li)\n\n  let s:li=[]\n  new\n  setlocal bufhidden=unload\n  bwipeout\n  call assert_equal([\"bufunload\", \"bufdelete\", \"bufwipeout\"], s:li)\n\n  au! test_bufunload_group\n  augroup! test_bufunload_group\nendfunc\n\n\" SEGV occurs in older versions.  (At least 7.4.2005 or older)\nfunc Test_autocmd_bufunload_with_tabnext()\n  tabedit\n  tabfirst\n\n  augroup test_autocmd_bufunload_with_tabnext_group\n    autocmd!\n    autocmd BufUnload <buffer> tabnext\n  augroup END\n\n  quit\n  call assert_equal(2, tabpagenr('$'))\n\n  autocmd! test_autocmd_bufunload_with_tabnext_group\n  augroup! test_autocmd_bufunload_with_tabnext_group\n  tablast\n  quit\nendfunc\n\nfunc Test_autocmd_bufwinleave_with_tabfirst()\n  tabedit\n  augroup sample\n    autocmd!\n    autocmd BufWinLeave <buffer> tabfirst\n  augroup END\n  call setline(1, ['a', 'b', 'c'])\n  edit! a.txt\n  tabclose\nendfunc\n\n\" SEGV occurs in older versions.  (At least 7.4.2321 or older)\nfunc Test_autocmd_bufunload_avoiding_SEGV_01()\n  split aa.txt\n  let lastbuf = bufnr('$')\n\n  augroup test_autocmd_bufunload\n    autocmd!\n    exe 'autocmd BufUnload <buffer> ' . (lastbuf + 1) . 'bwipeout!'\n  augroup END\n\n  \" Todo: check for E937 generated first\n  \" call assert_fails('edit bb.txt', 'E937:')\n  call assert_fails('edit bb.txt', 'E517:')\n\n  autocmd! test_autocmd_bufunload\n  augroup! test_autocmd_bufunload\n  bwipe! aa.txt\n  bwipe! bb.txt\nendfunc\n\n\" SEGV occurs in older versions.  (At least 7.4.2321 or older)\nfunc Test_autocmd_bufunload_avoiding_SEGV_02()\n  setlocal buftype=nowrite\n  let lastbuf = bufnr('$')\n\n  augroup test_autocmd_bufunload\n    autocmd!\n    exe 'autocmd BufUnload <buffer> ' . (lastbuf + 1) . 'bwipeout!'\n  augroup END\n\n  normal! i1\n  call assert_fails('edit a.txt', 'E517:')\n  call feedkeys(\"\\<CR>\")\n\n  autocmd! test_autocmd_bufunload\n  augroup! test_autocmd_bufunload\n  bwipe! a.txt\nendfunc\n\nfunc Test_win_tab_autocmd()\n  let g:record = []\n\n  augroup testing\n    au WinNew * call add(g:record, 'WinNew')\n    au WinEnter * call add(g:record, 'WinEnter') \n    au WinLeave * call add(g:record, 'WinLeave') \n    au TabNew * call add(g:record, 'TabNew')\n    au TabClosed * call add(g:record, 'TabClosed')\n    au TabEnter * call add(g:record, 'TabEnter')\n    au TabLeave * call add(g:record, 'TabLeave')\n  augroup END\n\n  split\n  tabnew\n  close\n  close\n\n  call assert_equal([\n\t\\ 'WinLeave', 'WinNew', 'WinEnter',\n\t\\ 'WinLeave', 'TabLeave', 'WinNew', 'WinEnter', 'TabNew', 'TabEnter',\n\t\\ 'WinLeave', 'TabLeave', 'TabClosed', 'WinEnter', 'TabEnter',\n\t\\ 'WinLeave', 'WinEnter'\n\t\\ ], g:record)\n\n  let g:record = []\n  tabnew somefile\n  tabnext\n  bwipe somefile\n\n  call assert_equal([\n\t\\ 'WinLeave', 'TabLeave', 'WinNew', 'WinEnter', 'TabNew', 'TabEnter',\n\t\\ 'WinLeave', 'TabLeave', 'WinEnter', 'TabEnter',\n\t\\ 'TabClosed'\n\t\\ ], g:record)\n\n  augroup testing\n    au!\n  augroup END\n  unlet g:record\nendfunc\n\nfunc s:AddAnAutocmd()\n  augroup vimBarTest\n    au BufReadCmd * echo 'hello'\n  augroup END\n  call assert_equal(3, len(split(execute('au vimBarTest'), \"\\n\")))\nendfunc\n\nfunc Test_early_bar()\n  \" test that a bar is recognized before the {event}\n  call s:AddAnAutocmd()\n  augroup vimBarTest | au! | augroup END\n  call assert_equal(1, len(split(execute('au vimBarTest'), \"\\n\")))\n\n  call s:AddAnAutocmd()\n  augroup vimBarTest| au!| augroup END\n  call assert_equal(1, len(split(execute('au vimBarTest'), \"\\n\")))\n\n  \" test that a bar is recognized after the {event}\n  call s:AddAnAutocmd()\n  augroup vimBarTest| au!BufReadCmd| augroup END\n  call assert_equal(1, len(split(execute('au vimBarTest'), \"\\n\")))\n\n  \" test that a bar is recognized after the {group}\n  call s:AddAnAutocmd()\n  au! vimBarTest|echo 'hello'\n  call assert_equal(1, len(split(execute('au vimBarTest'), \"\\n\")))\nendfunc\n\nfunc RemoveGroup()\n  autocmd! StartOK\n  augroup! StartOK\nendfunc\n\nfunc Test_augroup_warning()\n  augroup TheWarning\n    au VimEnter * echo 'entering'\n  augroup END\n  call assert_true(match(execute('au VimEnter'), \"TheWarning.*VimEnter\") >= 0)\n  redir => res\n  augroup! TheWarning\n  redir END\n  call assert_true(match(res, \"W19:\") >= 0)\n  call assert_true(match(execute('au VimEnter'), \"-Deleted-.*VimEnter\") >= 0)\n\n  \" check \"Another\" does not take the pace of the deleted entry\n  augroup Another\n  augroup END\n  call assert_true(match(execute('au VimEnter'), \"-Deleted-.*VimEnter\") >= 0)\n  augroup! Another\n\n  \" no warning for postpone aucmd delete\n  augroup StartOK\n    au VimEnter * call RemoveGroup()\n  augroup END\n  call assert_true(match(execute('au VimEnter'), \"StartOK.*VimEnter\") >= 0)\n  redir => res\n  doautocmd VimEnter\n  redir END\n  call assert_true(match(res, \"W19:\") < 0)\n  au! VimEnter\nendfunc\n\nfunc Test_BufReadCmdHelp()\n  \" This used to cause access to free memory\n  au BufReadCmd * e +h\n  help\n\n  au! BufReadCmd\nendfunc\n\nfunc Test_BufReadCmdHelpJump()\n  \" This used to cause access to free memory\n  au BufReadCmd * e +h{\n  \" } to fix highlighting\n  call assert_fails('help', 'E434:')\n\n  au! BufReadCmd\nendfunc\n\nfunc Test_augroup_deleted()\n  \" This caused a crash before E936 was introduced\n  augroup x\n    call assert_fails('augroup! x', 'E936:')\n    au VimEnter * echo\n  augroup end\n  augroup! x\n  call assert_true(match(execute('au VimEnter'), \"-Deleted-.*VimEnter\") >= 0)\n  au! VimEnter\nendfunc\n\n\" Tests for autocommands on :close command.\n\" This used to be in test13.\nfunc Test_three_windows()\n  \" Clean up buffers, because in some cases this function fails.\n  call s:cleanup_buffers()\n\n  \" Write three files and open them, each in a window.\n  \" Then go to next window, with autocommand that deletes the previous one.\n  \" Do this twice, writing the file.\n  e! Xtestje1\n  call setline(1, 'testje1')\n  w\n  sp Xtestje2\n  call setline(1, 'testje2')\n  w\n  sp Xtestje3\n  call setline(1, 'testje3')\n  w\n  wincmd w\n  au WinLeave Xtestje2 bwipe\n  wincmd w\n  call assert_equal('Xtestje1', expand('%'))\n\n  au WinLeave Xtestje1 bwipe Xtestje3\n  close\n  call assert_equal('Xtestje1', expand('%'))\n\n  \" Test deleting the buffer on a Unload event.  If this goes wrong there\n  \" will be the ATTENTION prompt.\n  e Xtestje1\n  au!\n  au! BufUnload Xtestje1 bwipe\n  call assert_fails('e Xtestje3', 'E937:')\n  call assert_equal('Xtestje3', expand('%'))\n\n  e Xtestje2\n  sp Xtestje1\n  call assert_fails('e', 'E937:')\n  call assert_equal('Xtestje1', expand('%'))\n\n  \" Test changing buffers in a BufWipeout autocommand.  If this goes wrong\n  \" there are ml_line errors and/or a Crash.\n  au!\n  only\n  e Xanother\n  e Xtestje1\n  bwipe Xtestje2\n  bwipe Xtestje3\n  au BufWipeout Xtestje1 buf Xtestje1\n  bwipe\n  call assert_equal('Xanother', expand('%'))\n\n  only\n  help\n  wincmd w\n  1quit\n  call assert_equal('Xanother', expand('%'))\n\n  au!\n  enew\n  call delete('Xtestje1')\n  call delete('Xtestje2')\n  call delete('Xtestje3')\nendfunc\n\nfunc Test_BufEnter()\n  au! BufEnter\n  au Bufenter * let val = val . '+'\n  let g:val = ''\n  split NewFile\n  call assert_equal('+', g:val)\n  bwipe!\n  call assert_equal('++', g:val)\n\n  \" Also get BufEnter when editing a directory\n  call mkdir('Xdir')\n  split Xdir\n  call assert_equal('+++', g:val)\n\n  \" On MS-Windows we can't edit the directory, make sure we wipe the right\n  \" buffer.\n  bwipe! Xdir\n\n  call delete('Xdir', 'd')\n  au! BufEnter\nendfunc\n\n\" Closing a window might cause an endless loop\n\" E814 for older Vims\nfunc Test_autocmd_bufwipe_in_SessLoadPost()\n  edit Xtest\n  tabnew\n  file Xsomething\n  set noswapfile\n  mksession!\n\n  let content =<< trim [CODE]\n    set nocp noswapfile\n    let v:swapchoice=\"e\"\n    augroup test_autocmd_sessionload\n    autocmd!\n    autocmd SessionLoadPost * exe bufnr(\"Xsomething\") . \"bw!\"\n    augroup END\n\n    func WriteErrors()\n      call writefile([execute(\"messages\")], \"Xerrors\")\n    endfunc\n    au VimLeave * call WriteErrors()\n  [CODE]\n\n  call writefile(content, 'Xvimrc')\n  call system(GetVimCommand('Xvimrc') .. ' --not-a-term --noplugins -S Session.vim -c cq')\n  let errors = join(readfile('Xerrors'))\n  call assert_match('E814', errors)\n\n  set swapfile\n  for file in ['Session.vim', 'Xvimrc', 'Xerrors']\n    call delete(file)\n  endfor\nendfunc\n\n\" SEGV occurs in older versions.\nfunc Test_autocmd_bufwipe_in_SessLoadPost2()\n  tabnew\n  set noswapfile\n  mksession!\n\n  let content =<< trim [CODE]\n    set nocp noswapfile\n    function! DeleteInactiveBufs()\n      tabfirst\n      let tabblist = []\n      for i in range(1, tabpagenr(''$''))\n        call extend(tabblist, tabpagebuflist(i))\n      endfor\n      for b in range(1, bufnr(''$''))\n        if bufexists(b) && buflisted(b) && (index(tabblist, b) == -1 || bufname(b) =~# ''^$'')\n          exec ''bwipeout '' . b\n        endif\n      endfor\n      echomsg \"SessionLoadPost DONE\"\n    endfunction\n    au SessionLoadPost * call DeleteInactiveBufs()\n\n    func WriteErrors()\n      call writefile([execute(\"messages\")], \"Xerrors\")\n    endfunc\n    au VimLeave * call WriteErrors()\n  [CODE]\n\n  call writefile(content, 'Xvimrc')\n  call system(GetVimCommand('Xvimrc') .. ' --not-a-term --noplugins -S Session.vim -c cq')\n  let errors = join(readfile('Xerrors'))\n  \" This probably only ever matches on unix.\n  call assert_notmatch('Caught deadly signal SEGV', errors)\n  call assert_match('SessionLoadPost DONE', errors)\n\n  set swapfile\n  for file in ['Session.vim', 'Xvimrc', 'Xerrors']\n    call delete(file)\n  endfor\nendfunc\n\nfunc Test_empty_doau()\n  doau \\|\nendfunc\n\nfunc s:AutoCommandOptionSet(match)\n  let template = \"Option: <%s>, OldVal: <%s>, OldValLocal: <%s>, OldValGlobal: <%s>, NewVal: <%s>, Scope: <%s>, Command: <%s>\\n\"\n  let item     = remove(g:options, 0)\n  let expected = printf(template, item[0], item[1], item[2], item[3], item[4], item[5], item[6])\n  let actual   = printf(template, a:match, v:option_old, v:option_oldlocal, v:option_oldglobal, v:option_new, v:option_type, v:option_command)\n  let g:opt    = [expected, actual]\n  \"call assert_equal(expected, actual)\nendfunc\n\nfunc Test_OptionSet()\n  if !has(\"eval\") || !exists(\"+autochdir\")\n    return\n  endif\n\n  badd test_autocmd.vim\n\n  call test_override('starting', 1)\n  set nocp\n  au OptionSet * :call s:AutoCommandOptionSet(expand(\"<amatch>\"))\n\n  \" 1: Setting number option\"\n  let g:options=[['number', 0, 0, 0, 1, 'global', 'set']]\n  set nu\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 2: Setting local number option\"\n  let g:options=[['number', 1, 1, '', 0, 'local', 'setlocal']]\n  setlocal nonu\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 3: Setting global number option\"\n  let g:options=[['number', 1, '', 1, 0, 'global', 'setglobal']]\n  setglobal nonu\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 4: Setting local autoindent option\"\n  let g:options=[['autoindent', 0, 0, '', 1, 'local', 'setlocal']]\n  setlocal ai\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 5: Setting global autoindent option\"\n  let g:options=[['autoindent', 0, '', 0, 1, 'global', 'setglobal']]\n  setglobal ai\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 6: Setting global autoindent option\"\n  let g:options=[['autoindent', 1, 1, 1, 0, 'global', 'set']]\n  set ai!\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 6a: Setting global autoindent option\"\n  let g:options=[['autoindent', 1, 1, 0, 0, 'global', 'set']]\n  noa setlocal ai\n  noa setglobal noai\n  set ai!\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" Should not print anything, use :noa\n  \" 7: don't trigger OptionSet\"\n  let g:options=[['invalid', 'invalid', 'invalid', 'invalid', 'invalid', 'invalid', 'invalid']]\n  noa set nonu\n  call assert_equal([['invalid', 'invalid', 'invalid', 'invalid', 'invalid', 'invalid', 'invalid']], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 8: Setting several global list and number option\"\n  let g:options=[['list', 0, 0, 0, 1, 'global', 'set'], ['number', 0, 0, 0, 1, 'global', 'set']]\n  set list nu\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 9: don't trigger OptionSet\"\n  let g:options=[['invalid', 'invalid', 'invalid', 'invalid', 'invalid', 'invalid', 'invalid'], ['invalid', 'invalid', 'invalid', 'invalid', 'invalid', 'invalid', 'invalid']]\n  noa set nolist nonu\n  call assert_equal([['invalid', 'invalid', 'invalid', 'invalid', 'invalid', 'invalid', 'invalid'], ['invalid', 'invalid', 'invalid', 'invalid', 'invalid', 'invalid', 'invalid']], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 10: Setting global acd\"\n  let g:options=[['autochdir', 0, 0, '', 1, 'local', 'setlocal']]\n  setlocal acd\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 11: Setting global autoread (also sets local value)\"\n  let g:options=[['autoread', 0, 0, 0, 1, 'global', 'set']]\n  set ar\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 12: Setting local autoread\"\n  let g:options=[['autoread', 1, 1, '', 1, 'local', 'setlocal']]\n  setlocal ar\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 13: Setting global autoread\"\n  let g:options=[['autoread', 1, '', 1, 0, 'global', 'setglobal']]\n  setglobal invar\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 14: Setting option backspace through :let\"\n  let g:options=[['backspace', '', '', '', 'eol,indent,start', 'global', 'set']]\n  let &bs=\"eol,indent,start\"\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 15: Setting option backspace through setbufvar()\"\n  let g:options=[['backup', 0, 0, '', 1, 'local', 'setlocal']]\n  \" try twice, first time, shouldn't trigger because option name is invalid,\n  \" second time, it should trigger\n  let bnum = bufnr('%')\n  call assert_fails(\"call setbufvar(bnum, '&l:bk', 1)\", \"E355\")\n  \" should trigger, use correct option name\n  call setbufvar(bnum, '&backup', 1)\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 16: Setting number option using setwinvar\"\n  let g:options=[['number', 0, 0, '', 1, 'local', 'setlocal']]\n  call setwinvar(0, '&number', 1)\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 17: Setting key option, shouldn't trigger\"\n  let g:options=[['key', 'invalid', 'invalid1', 'invalid2', 'invalid3', 'invalid4', 'invalid5']]\n  setlocal key=blah\n  setlocal key=\n  call assert_equal([['key', 'invalid', 'invalid1', 'invalid2', 'invalid3', 'invalid4', 'invalid5']], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n\n  \" 18a: Setting string global option\"\n  let oldval = &backupext\n  let g:options=[['backupext', oldval, oldval, oldval, 'foo', 'global', 'set']]\n  set backupext=foo\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 18b: Resetting string global option\"\n  let g:options=[['backupext', 'foo', 'foo', 'foo', oldval, 'global', 'set']]\n  set backupext&\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 18c: Setting global string global option\"\n  let g:options=[['backupext', oldval, '', oldval, 'bar', 'global', 'setglobal']]\n  setglobal backupext=bar\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 18d: Setting local string global option\"\n  \" As this is a global option this sets the global value even though\n  \" :setlocal is used!\n  noa set backupext& \" Reset global and local value (without triggering autocmd)\n  let g:options=[['backupext', oldval, oldval, '', 'baz', 'local', 'setlocal']]\n  setlocal backupext=baz\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 18e: Setting again string global option\"\n  noa setglobal backupext=ext_global \" Reset global and local value (without triggering autocmd)\n  noa setlocal backupext=ext_local \" Sets the global(!) value!\n  let g:options=[['backupext', 'ext_local', 'ext_local', 'ext_local', 'fuu', 'global', 'set']]\n  set backupext=fuu\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n\n  \" 19a: Setting string local-global (to buffer) option\"\n  let oldval = &tags\n  let g:options=[['tags', oldval, oldval, oldval, 'tagpath', 'global', 'set']]\n  set tags=tagpath\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 19b: Resetting string local-global (to buffer) option\"\n  let g:options=[['tags', 'tagpath', 'tagpath', 'tagpath', oldval, 'global', 'set']]\n  set tags&\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 19c: Setting global string local-global (to buffer) option \"\n  let g:options=[['tags', oldval, '', oldval, 'tagpath1', 'global', 'setglobal']]\n  setglobal tags=tagpath1\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 19d: Setting local string local-global (to buffer) option\"\n  let g:options=[['tags', 'tagpath1', 'tagpath1', '', 'tagpath2', 'local', 'setlocal']]\n  setlocal tags=tagpath2\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 19e: Setting again string local-global (to buffer) option\"\n  \" Note: v:option_old is the old global value for local-global string options\n  \" but the old local value for all other kinds of options.\n  noa setglobal tags=tag_global \" Reset global and local value (without triggering autocmd)\n  noa setlocal tags=tag_local\n  let g:options=[['tags', 'tag_global', 'tag_local', 'tag_global', 'tagpath', 'global', 'set']]\n  set tags=tagpath\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 19f: Setting string local-global (to buffer) option to an empty string\"\n  \" Note: v:option_old is the old global value for local-global string options\n  \" but the old local value for all other kinds of options.\n  noa set tags=tag_global \" Reset global and local value (without triggering autocmd)\n  noa setlocal tags= \" empty string\n  let g:options=[['tags', 'tag_global', '', 'tag_global', 'tagpath', 'global', 'set']]\n  set tags=tagpath\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n\n  \" 20a: Setting string local (to buffer) option\"\n  let oldval = &spelllang\n  let g:options=[['spelllang', oldval, oldval, oldval, 'elvish,klingon', 'global', 'set']]\n  set spelllang=elvish,klingon\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 20b: Resetting string local (to buffer) option\"\n  let g:options=[['spelllang', 'elvish,klingon', 'elvish,klingon', 'elvish,klingon', oldval, 'global', 'set']]\n  set spelllang&\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 20c: Setting global string local (to buffer) option\"\n  let g:options=[['spelllang', oldval, '', oldval, 'elvish', 'global', 'setglobal']]\n  setglobal spelllang=elvish\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 20d: Setting local string local (to buffer) option\"\n  noa set spelllang& \" Reset global and local value (without triggering autocmd)\n  let g:options=[['spelllang', oldval, oldval, '', 'klingon', 'local', 'setlocal']]\n  setlocal spelllang=klingon\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 20e: Setting again string local (to buffer) option\"\n  \" Note: v:option_old is the old global value for local-global string options\n  \" but the old local value for all other kinds of options.\n  noa setglobal spelllang=spellglobal \" Reset global and local value (without triggering autocmd)\n  noa setlocal spelllang=spelllocal\n  let g:options=[['spelllang', 'spelllocal', 'spelllocal', 'spellglobal', 'foo', 'global', 'set']]\n  set spelllang=foo\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n\n  \" 21a: Setting string local-global (to window) option\"\n  let oldval = &statusline\n  let g:options=[['statusline', oldval, oldval, oldval, 'foo', 'global', 'set']]\n  set statusline=foo\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 21b: Resetting string local-global (to window) option\"\n  \" Note: v:option_old is the old global value for local-global string options\n  \" but the old local value for all other kinds of options.\n  let g:options=[['statusline', 'foo', 'foo', 'foo', oldval, 'global', 'set']]\n  set statusline&\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 21c: Setting global string local-global (to window) option\"\n  let g:options=[['statusline', oldval, '', oldval, 'bar', 'global', 'setglobal']]\n  setglobal statusline=bar\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 21d: Setting local string local-global (to window) option\"\n  noa set statusline& \" Reset global and local value (without triggering autocmd)\n  let g:options=[['statusline', oldval, oldval, '', 'baz', 'local', 'setlocal']]\n  setlocal statusline=baz\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 21e: Setting again string local-global (to window) option\"\n  \" Note: v:option_old is the old global value for local-global string options\n  \" but the old local value for all other kinds of options.\n  noa setglobal statusline=bar \" Reset global and local value (without triggering autocmd)\n  noa setlocal statusline=baz\n  let g:options=[['statusline', 'bar', 'baz', 'bar', 'foo', 'global', 'set']]\n  set statusline=foo\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n\n  \" 22a: Setting string local (to window) option\"\n  let oldval = &foldignore\n  let g:options=[['foldignore', oldval, oldval, oldval, 'fo', 'global', 'set']]\n  set foldignore=fo\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 22b: Resetting string local (to window) option\"\n  let g:options=[['foldignore', 'fo', 'fo', 'fo', oldval, 'global', 'set']]\n  set foldignore&\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 22c: Setting global string local (to window) option\"\n  let g:options=[['foldignore', oldval, '', oldval, 'bar', 'global', 'setglobal']]\n  setglobal foldignore=bar\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 22d: Setting local string local (to window) option\"\n  noa set foldignore& \" Reset global and local value (without triggering autocmd)\n  let g:options=[['foldignore', oldval, oldval, '', 'baz', 'local', 'setlocal']]\n  setlocal foldignore=baz\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 22e: Setting again string local (to window) option\"\n  noa setglobal foldignore=glob \" Reset global and local value (without triggering autocmd)\n  noa setlocal foldignore=loc\n  let g:options=[['foldignore', 'loc', 'loc', 'glob', 'fo', 'global', 'set']]\n  set foldignore=fo\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n\n  \" 23a: Setting global number local option\"\n  noa setglobal cmdheight=8 \" Reset global and local value (without triggering autocmd)\n  noa setlocal cmdheight=1 \" Sets the global(!) value!\n  let g:options=[['cmdheight', '1', '', '1', '2', 'global', 'setglobal']]\n  setglobal cmdheight=2\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 23b: Setting local number global option\"\n  noa setglobal cmdheight=8 \" Reset global and local value (without triggering autocmd)\n  noa setlocal cmdheight=1 \" Sets the global(!) value!\n  let g:options=[['cmdheight', '1', '1', '', '2', 'local', 'setlocal']]\n  setlocal cmdheight=2\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 23c: Setting again number global option\"\n  noa setglobal cmdheight=8 \" Reset global and local value (without triggering autocmd)\n  noa setlocal cmdheight=1 \" Sets the global(!) value!\n  let g:options=[['cmdheight', '1', '1', '1', '2', 'global', 'set']]\n  set cmdheight=2\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 23d: Setting again number global option\"\n  noa set cmdheight=8 \" Reset global and local value (without triggering autocmd)\n  let g:options=[['cmdheight', '8', '8', '8', '2', 'global', 'set']]\n  set cmdheight=2\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n\n  \" 24a: Setting global number global-local (to buffer) option\"\n  noa setglobal undolevels=8 \" Reset global and local value (without triggering autocmd)\n  noa setlocal undolevels=1\n  let g:options=[['undolevels', '8', '', '8', '2', 'global', 'setglobal']]\n  setglobal undolevels=2\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 24b: Setting local number global-local (to buffer) option\"\n  noa setglobal undolevels=8 \" Reset global and local value (without triggering autocmd)\n  noa setlocal undolevels=1\n  let g:options=[['undolevels', '1', '1', '', '2', 'local', 'setlocal']]\n  setlocal undolevels=2\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 24c: Setting again number global-local (to buffer) option\"\n  noa setglobal undolevels=8 \" Reset global and local value (without triggering autocmd)\n  noa setlocal undolevels=1\n  let g:options=[['undolevels', '1', '1', '8', '2', 'global', 'set']]\n  set undolevels=2\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 24d: Setting again global number global-local (to buffer) option\"\n  noa set undolevels=8 \" Reset global and local value (without triggering autocmd)\n  let g:options=[['undolevels', '8', '8', '8', '2', 'global', 'set']]\n  set undolevels=2\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n\n  \" 25a: Setting global number local (to buffer) option\"\n  noa setglobal wrapmargin=8 \" Reset global and local value (without triggering autocmd)\n  noa setlocal wrapmargin=1\n  let g:options=[['wrapmargin', '8', '', '8', '2', 'global', 'setglobal']]\n  setglobal wrapmargin=2\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 25b: Setting local number local (to buffer) option\"\n  noa setglobal wrapmargin=8 \" Reset global and local value (without triggering autocmd)\n  noa setlocal wrapmargin=1\n  let g:options=[['wrapmargin', '1', '1', '', '2', 'local', 'setlocal']]\n  setlocal wrapmargin=2\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 25c: Setting again number local (to buffer) option\"\n  noa setglobal wrapmargin=8 \" Reset global and local value (without triggering autocmd)\n  noa setlocal wrapmargin=1\n  let g:options=[['wrapmargin', '1', '1', '8', '2', 'global', 'set']]\n  set wrapmargin=2\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 25d: Setting again global number local (to buffer) option\"\n  noa set wrapmargin=8 \" Reset global and local value (without triggering autocmd)\n  let g:options=[['wrapmargin', '8', '8', '8', '2', 'global', 'set']]\n  set wrapmargin=2\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n\n  \" 26: Setting number global-local (to window) option.\n  \" Such option does currently not exist.\n\n\n  \" 27a: Setting global number local (to window) option\"\n  noa setglobal foldcolumn=8 \" Reset global and local value (without triggering autocmd)\n  noa setlocal foldcolumn=1\n  let g:options=[['foldcolumn', '8', '', '8', '2', 'global', 'setglobal']]\n  setglobal foldcolumn=2\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 27b: Setting local number local (to window) option\"\n  noa setglobal foldcolumn=8 \" Reset global and local value (without triggering autocmd)\n  noa setlocal foldcolumn=1\n  let g:options=[['foldcolumn', '1', '1', '', '2', 'local', 'setlocal']]\n  setlocal foldcolumn=2\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 27c: Setting again number local (to window) option\"\n  noa setglobal foldcolumn=8 \" Reset global and local value (without triggering autocmd)\n  noa setlocal foldcolumn=1\n  let g:options=[['foldcolumn', '1', '1', '8', '2', 'global', 'set']]\n  set foldcolumn=2\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 27d: Ssettin again global number local (to window) option\"\n  noa set foldcolumn=8 \" Reset global and local value (without triggering autocmd)\n  let g:options=[['foldcolumn', '8', '8', '8', '2', 'global', 'set']]\n  set foldcolumn=2\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n\n  \" 28a: Setting global boolean global option\"\n  noa setglobal nowrapscan \" Reset global and local value (without triggering autocmd)\n  noa setlocal wrapscan \" Sets the global(!) value!\n  let g:options=[['wrapscan', '1', '', '1', '0', 'global', 'setglobal']]\n  setglobal nowrapscan\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 28b: Setting local boolean global option\"\n  noa setglobal nowrapscan \" Reset global and local value (without triggering autocmd)\n  noa setlocal wrapscan \" Sets the global(!) value!\n  let g:options=[['wrapscan', '1', '1', '', '0', 'local', 'setlocal']]\n  setlocal nowrapscan\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 28c: Setting again boolean global option\"\n  noa setglobal nowrapscan \" Reset global and local value (without triggering autocmd)\n  noa setlocal wrapscan \" Sets the global(!) value!\n  let g:options=[['wrapscan', '1', '1', '1', '0', 'global', 'set']]\n  set nowrapscan\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 28d: Setting again global boolean global option\"\n  noa set nowrapscan \" Reset global and local value (without triggering autocmd)\n  let g:options=[['wrapscan', '0', '0', '0', '1', 'global', 'set']]\n  set wrapscan\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n\n  \" 29a: Setting global boolean global-local (to buffer) option\"\n  noa setglobal noautoread \" Reset global and local value (without triggering autocmd)\n  noa setlocal autoread\n  let g:options=[['autoread', '0', '', '0', '1', 'global', 'setglobal']]\n  setglobal autoread\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 29b: Setting local boolean global-local (to buffer) option\"\n  noa setglobal noautoread \" Reset global and local value (without triggering autocmd)\n  noa setlocal autoread\n  let g:options=[['autoread', '1', '1', '', '0', 'local', 'setlocal']]\n  setlocal noautoread\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 29c: Setting again boolean global-local (to buffer) option\"\n  noa setglobal noautoread \" Reset global and local value (without triggering autocmd)\n  noa setlocal autoread\n  let g:options=[['autoread', '1', '1', '0', '1', 'global', 'set']]\n  set autoread\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 29d: Setting again global boolean global-local (to buffer) option\"\n  noa set noautoread \" Reset global and local value (without triggering autocmd)\n  let g:options=[['autoread', '0', '0', '0', '1', 'global', 'set']]\n  set autoread\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n\n  \" 30a: Setting global boolean local (to buffer) option\"\n  noa setglobal nocindent \" Reset global and local value (without triggering autocmd)\n  noa setlocal cindent\n  let g:options=[['cindent', '0', '', '0', '1', 'global', 'setglobal']]\n  setglobal cindent\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 30b: Setting local boolean local (to buffer) option\"\n  noa setglobal nocindent \" Reset global and local value (without triggering autocmd)\n  noa setlocal cindent\n  let g:options=[['cindent', '1', '1', '', '0', 'local', 'setlocal']]\n  setlocal nocindent\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 30c: Setting again boolean local (to buffer) option\"\n  noa setglobal nocindent \" Reset global and local value (without triggering autocmd)\n  noa setlocal cindent\n  let g:options=[['cindent', '1', '1', '0', '1', 'global', 'set']]\n  set cindent\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 30d: Setting again global boolean local (to buffer) option\"\n  noa set nocindent \" Reset global and local value (without triggering autocmd)\n  let g:options=[['cindent', '0', '0', '0', '1', 'global', 'set']]\n  set cindent\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n\n  \" 31: Setting boolean global-local (to window) option\n  \" Currently no such option exists.\n\n\n  \" 32a: Setting global boolean local (to window) option\"\n  noa setglobal nocursorcolumn \" Reset global and local value (without triggering autocmd)\n  noa setlocal cursorcolumn\n  let g:options=[['cursorcolumn', '0', '', '0', '1', 'global', 'setglobal']]\n  setglobal cursorcolumn\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 32b: Setting local boolean local (to window) option\"\n  noa setglobal nocursorcolumn \" Reset global and local value (without triggering autocmd)\n  noa setlocal cursorcolumn\n  let g:options=[['cursorcolumn', '1', '1', '', '0', 'local', 'setlocal']]\n  setlocal nocursorcolumn\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 32c: Setting again boolean local (to window) option\"\n  noa setglobal nocursorcolumn \" Reset global and local value (without triggering autocmd)\n  noa setlocal cursorcolumn\n  let g:options=[['cursorcolumn', '1', '1', '0', '1', 'global', 'set']]\n  set cursorcolumn\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 32d: Setting again global boolean local (to window) option\"\n  noa set nocursorcolumn \" Reset global and local value (without triggering autocmd)\n  let g:options=[['cursorcolumn', '0', '0', '0', '1', 'global', 'set']]\n  set cursorcolumn\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n\n  \" 33: Test autocommands when an option value is converted internally.\n  noa set backspace=1 \" Reset global and local value (without triggering autocmd)\n  let g:options=[['backspace', 'indent,eol', 'indent,eol', 'indent,eol', '2', 'global', 'set']]\n  set backspace=2\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n\n  \" Cleanup\n  au! OptionSet\n  \" set tags&\n  for opt in ['nu', 'ai', 'acd', 'ar', 'bs', 'backup', 'cul', 'cp', 'backupext', 'tags', 'spelllang', 'statusline', 'foldignore', 'cmdheight', 'undolevels', 'wrapmargin', 'foldcolumn', 'wrapscan', 'autoread', 'cindent', 'cursorcolumn']\n    exe printf(\":set %s&vim\", opt)\n  endfor\n  call test_override('starting', 0)\n  delfunc! AutoCommandOptionSet\nendfunc\n\nfunc Test_OptionSet_diffmode()\n  call test_override('starting', 1)\n  \" 18: Changing an option when entering diff mode\n  new\n  au OptionSet diff :let &l:cul=v:option_new\n\n  call setline(1, ['buffer 1', 'line2', 'line3', 'line4'])\n  call assert_equal(0, &l:cul)\n  diffthis\n  call assert_equal(1, &l:cul)\n\n  vnew\n  call setline(1, ['buffer 2', 'line 2', 'line 3', 'line4'])\n  call assert_equal(0, &l:cul)\n  diffthis\n  call assert_equal(1, &l:cul)\n\n  diffoff\n  call assert_equal(0, &l:cul)\n  call assert_equal(1, getwinvar(2, '&l:cul'))\n  bw!\n\n  call assert_equal(1, &l:cul)\n  diffoff!\n  call assert_equal(0, &l:cul)\n  call assert_equal(0, getwinvar(1, '&l:cul'))\n  bw!\n\n  \" Cleanup\n  au! OptionSet\n  call test_override('starting', 0)\nendfunc\n\nfunc Test_OptionSet_diffmode_close()\n  call test_override('starting', 1)\n  \" 19: Try to close the current window when entering diff mode\n  \" should not segfault\n  new\n  au OptionSet diff close\n\n  call setline(1, ['buffer 1', 'line2', 'line3', 'line4'])\n  call assert_fails(':diffthis', 'E788')\n  call assert_equal(1, &diff)\n  vnew\n  call setline(1, ['buffer 2', 'line 2', 'line 3', 'line4'])\n  call assert_fails(':diffthis', 'E788')\n  call assert_equal(1, &diff)\n  bw!\n  call assert_fails(':diffoff!', 'E788')\n  bw!\n\n  \" Cleanup\n  au! OptionSet\n  call test_override('starting', 0)\n  \"delfunc! AutoCommandOptionSet\nendfunc\n\n\" Test for Bufleave autocommand that deletes the buffer we are about to edit.\nfunc Test_BufleaveWithDelete()\n  new | edit Xfile1\n\n  augroup test_bufleavewithdelete\n      autocmd!\n      autocmd BufLeave Xfile1 bwipe Xfile2\n  augroup END\n\n  call assert_fails('edit Xfile2', 'E143:')\n  call assert_equal('Xfile1', bufname('%'))\n\n  autocmd! test_bufleavewithdelete BufLeave Xfile1\n  augroup! test_bufleavewithdelete\n\n  new\n  bwipe! Xfile1\nendfunc\n\n\" Test for autocommand that changes the buffer list, when doing \":ball\".\nfunc Test_Acmd_BufAll()\n  enew!\n  %bwipe!\n  call writefile(['Test file Xxx1'], 'Xxx1')\n  call writefile(['Test file Xxx2'], 'Xxx2')\n  call writefile(['Test file Xxx3'], 'Xxx3')\n\n  \" Add three files to the buffer list\n  split Xxx1\n  close\n  split Xxx2\n  close\n  split Xxx3\n  close\n\n  \" Wipe the buffer when the buffer is opened\n  au BufReadPost Xxx2 bwipe\n\n  call append(0, 'Test file Xxx4')\n  ball\n\n  call assert_equal(2, winnr('$'))\n  call assert_equal('Xxx1', bufname(winbufnr(winnr('$'))))\n  wincmd t\n\n  au! BufReadPost\n  %bwipe!\n  call delete('Xxx1')\n  call delete('Xxx2')\n  call delete('Xxx3')\n  enew! | only\nendfunc\n\n\" Test for autocommand that changes current buffer on BufEnter event.\n\" Check if modelines are interpreted for the correct buffer.\nfunc Test_Acmd_BufEnter()\n  %bwipe!\n  call writefile(['start of test file Xxx1',\n\t      \\ \"\\<Tab>this is a test\",\n\t      \\ 'end of test file Xxx1'], 'Xxx1')\n  call writefile(['start of test file Xxx2',\n\t      \\ 'vim: set noai :',\n\t      \\ \"\\<Tab>this is a test\",\n\t      \\ 'end of test file Xxx2'], 'Xxx2')\n\n  au BufEnter Xxx2 brew\n  set ai modeline modelines=3\n  edit Xxx1\n  \" edit Xxx2, autocmd will do :brew\n  edit Xxx2\n  exe \"normal G?this is a\\<CR>\"\n  \" Append text with autoindent to this file\n  normal othis should be auto-indented\n  call assert_equal(\"\\<Tab>this should be auto-indented\", getline('.'))\n  call assert_equal(3, line('.'))\n  \" Remove autocmd and edit Xxx2 again\n  au! BufEnter Xxx2\n  buf! Xxx2\n  exe \"normal G?this is a\\<CR>\"\n  \" append text without autoindent to Xxx\n  normal othis should be in column 1\n  call assert_equal(\"this should be in column 1\", getline('.'))\n  call assert_equal(4, line('.'))\n\n  %bwipe!\n  call delete('Xxx1')\n  call delete('Xxx2')\n  set ai&vim modeline&vim modelines&vim\nendfunc\n\n\" Test for issue #57\n\" do not move cursor on <c-o> when autoindent is set\nfunc Test_ai_CTRL_O()\n  enew!\n  set ai\n  let save_fo = &fo\n  set fo+=r\n  exe \"normal o# abcdef\\<Esc>2hi\\<CR>\\<C-O>d0\\<Esc>\"\n  exe \"normal o# abcdef\\<Esc>2hi\\<C-O>d0\\<Esc>\"\n  call assert_equal(['# abc', 'def', 'def'], getline(2, 4))\n\n  set ai&vim\n  let &fo = save_fo\n  enew!\nendfunc\n\n\" Test for autocommand that deletes the current buffer on BufLeave event.\n\" Also test deleting the last buffer, should give a new, empty buffer.\nfunc Test_BufLeave_Wipe()\n  %bwipe!\n  let content = ['start of test file Xxx',\n\t      \\ 'this is a test',\n\t      \\ 'end of test file Xxx']\n  call writefile(content, 'Xxx1')\n  call writefile(content, 'Xxx2')\n\n  au BufLeave Xxx2 bwipe\n  edit Xxx1\n  split Xxx2\n  \" delete buffer Xxx2, we should be back to Xxx1\n  bwipe\n  call assert_equal('Xxx1', bufname('%'))\n  call assert_equal(1, winnr('$'))\n\n  \" Create an alternate buffer\n  %write! test.out\n  call assert_equal('test.out', bufname('#'))\n  \" delete alternate buffer\n  bwipe test.out\n  call assert_equal('Xxx1', bufname('%'))\n  call assert_equal('', bufname('#'))\n\n  au BufLeave Xxx1 bwipe\n  \" delete current buffer, get an empty one\n  bwipe!\n  call assert_equal(1, line('$'))\n  call assert_equal('', bufname('%'))\n  let g:bufinfo = getbufinfo()\n  call assert_equal(1, len(g:bufinfo))\n\n  call delete('Xxx1')\n  call delete('Xxx2')\n  call delete('test.out')\n  %bwipe\n  au! BufLeave\n\n  \" check that bufinfo doesn't contain a pointer to freed memory\n  call test_garbagecollect_now()\nendfunc\n\nfunc Test_QuitPre()\n  edit Xfoo\n  let winid = win_getid(winnr())\n  split Xbar\n  au! QuitPre * let g:afile = expand('<afile>')\n  \" Close the other window, <afile> should be correct.\n  exe win_id2win(winid) . 'q'\n  call assert_equal('Xfoo', g:afile)\n \n  unlet g:afile\n  bwipe Xfoo\n  bwipe Xbar\nendfunc\n\nfunc Test_Cmdline()\n  au! CmdlineChanged : let g:text = getcmdline()\n  let g:text = 0\n  call feedkeys(\":echom 'hello'\\<CR>\", 'xt')\n  call assert_equal(\"echom 'hello'\", g:text)\n  au! CmdlineChanged\n\n  au! CmdlineChanged : let g:entered = expand('<afile>')\n  let g:entered = 0\n  call feedkeys(\":echom 'hello'\\<CR>\", 'xt')\n  call assert_equal(':', g:entered)\n  au! CmdlineChanged\n\n  au! CmdlineEnter : let g:entered = expand('<afile>')\n  au! CmdlineLeave : let g:left = expand('<afile>')\n  let g:entered = 0\n  let g:left = 0\n  call feedkeys(\":echo 'hello'\\<CR>\", 'xt')\n  call assert_equal(':', g:entered)\n  call assert_equal(':', g:left)\n  au! CmdlineEnter\n  au! CmdlineLeave\n\n  let save_shellslash = &shellslash\n  set noshellslash\n  au! CmdlineEnter / let g:entered = expand('<afile>')\n  au! CmdlineLeave / let g:left = expand('<afile>')\n  let g:entered = 0\n  let g:left = 0\n  new\n  call setline(1, 'hello')\n  call feedkeys(\"/hello\\<CR>\", 'xt')\n  call assert_equal('/', g:entered)\n  call assert_equal('/', g:left)\n  bwipe!\n  au! CmdlineEnter\n  au! CmdlineLeave\n  let &shellslash = save_shellslash\nendfunc\n\n\" Test for BufWritePre autocommand that deletes or unloads the buffer.\nfunc Test_BufWritePre()\n  %bwipe\n  au BufWritePre Xxx1 bunload\n  au BufWritePre Xxx2 bwipe\n\n  call writefile(['start of Xxx1', 'test', 'end of Xxx1'], 'Xxx1')\n  call writefile(['start of Xxx2', 'test', 'end of Xxx2'], 'Xxx2')\n\n  edit Xtest\n  e! Xxx2\n  bdel Xtest\n  e Xxx1\n  \" write it, will unload it and give an error msg\n  call assert_fails('w', 'E203')\n  call assert_equal('Xxx2', bufname('%'))\n  edit Xtest\n  e! Xxx2\n  bwipe Xtest\n  \" write it, will delete the buffer and give an error msg\n  call assert_fails('w', 'E203')\n  call assert_equal('Xxx1', bufname('%'))\n  au! BufWritePre\n  call delete('Xxx1')\n  call delete('Xxx2')\nendfunc\n\n\" Test for BufUnload autocommand that unloads all the other buffers\nfunc Test_bufunload_all()\n  call writefile(['Test file Xxx1'], 'Xxx1')\"\n  call writefile(['Test file Xxx2'], 'Xxx2')\"\n\n  let content =<< trim [CODE]\n    func UnloadAllBufs()\n      let i = 1\n      while i <= bufnr('$')\n        if i != bufnr('%') && bufloaded(i)\n          exe  i . 'bunload'\n        endif\n        let i += 1\n      endwhile\n    endfunc\n    au BufUnload * call UnloadAllBufs()\n    au VimLeave * call writefile(['Test Finished'], 'Xout')\n    edit Xxx1\n    split Xxx2\n    q\n  [CODE]\n\n  call writefile(content, 'Xtest')\n\n  call delete('Xout')\n  call system(GetVimCommandClean() .. ' -N --not-a-term -S Xtest')\n  call assert_true(filereadable('Xout'))\n\n  call delete('Xxx1')\n  call delete('Xxx2')\n  call delete('Xtest')\n  call delete('Xout')\nendfunc\n\n\" Some tests for buffer-local autocommands\nfunc Test_buflocal_autocmd()\n  let g:bname = ''\n  edit xx\n  au BufLeave <buffer> let g:bname = expand(\"%\")\n  \" here, autocommand for xx should trigger.\n  \" but autocommand shall not apply to buffer named <buffer>.\n  edit somefile\n  call assert_equal('xx', g:bname)\n  let g:bname = ''\n  \" here, autocommand shall be auto-deleted\n  bwipe xx\n  \" autocmd should not trigger\n  edit xx\n  call assert_equal('', g:bname)\n  \" autocmd should not trigger\n  edit somefile\n  call assert_equal('', g:bname)\n  enew\n  unlet g:bname\nendfunc\n\n\" Test for \"*Cmd\" autocommands\nfunc Test_Cmd_Autocmds()\n  call writefile(['start of Xxx', \"\\tabc2\", 'end of Xxx'], 'Xxx')\n\n  enew!\n  au BufReadCmd XtestA 0r Xxx|$del\n  edit XtestA\t\t\t\" will read text of Xxd instead\n  call assert_equal('start of Xxx', getline(1))\n\n  au BufWriteCmd XtestA call append(line(\"$\"), \"write\")\n  write\t\t\t\t\" will append a line to the file\n  call assert_equal('write', getline('$'))\n  call assert_fails('read XtestA', 'E484')\t\" should not read anything\n  call assert_equal('write', getline(4))\n\n  \" now we have:\n  \" 1\tstart of Xxx\n  \" 2\t\tabc2\n  \" 3\tend of Xxx\n  \" 4\twrite\n\n  au FileReadCmd XtestB '[r Xxx\n  2r XtestB\t\t\t\" will read Xxx below line 2 instead\n  call assert_equal('start of Xxx', getline(3))\n\n  \" now we have:\n  \" 1\tstart of Xxx\n  \" 2\t\tabc2\n  \" 3\tstart of Xxx\n  \" 4\t\tabc2\n  \" 5\tend of Xxx\n  \" 6\tend of Xxx\n  \" 7\twrite\n\n  au FileWriteCmd XtestC '[,']copy $\n  normal 4GA1\n  4,5w XtestC\t\t\t\" will copy lines 4 and 5 to the end\n  call assert_equal(\"\\tabc21\", getline(8))\n  call assert_fails('r XtestC', 'E484')\t\" should not read anything\n  call assert_equal(\"end of Xxx\", getline(9))\n\n  \" now we have:\n  \" 1\tstart of Xxx\n  \" 2\t\tabc2\n  \" 3\tstart of Xxx\n  \" 4\t\tabc21\n  \" 5\tend of Xxx\n  \" 6\tend of Xxx\n  \" 7\twrite\n  \" 8\t\tabc21\n  \" 9\tend of Xxx\n\n  let g:lines = []\n  au FileAppendCmd XtestD call extend(g:lines, getline(line(\"'[\"), line(\"']\")))\n  w >>XtestD\t\t\t\" will add lines to 'lines'\n  call assert_equal(9, len(g:lines))\n  call assert_fails('$r XtestD', 'E484')\t\" should not read anything\n  call assert_equal(9, line('$'))\n  call assert_equal('end of Xxx', getline('$'))\n\n  au BufReadCmd XtestE 0r Xxx|$del\n  sp XtestE\t\t\t\" split window with test.out\n  call assert_equal('end of Xxx', getline(3))\n\n  let g:lines = []\n  exe \"normal 2Goasdf\\<Esc>\\<C-W>\\<C-W>\"\n  au BufWriteCmd XtestE call extend(g:lines, getline(0, '$'))\n  wall\t\t\t\t\" will write other window to 'lines'\n  call assert_equal(4, len(g:lines), g:lines)\n  call assert_equal('asdf', g:lines[2])\n\n  au! BufReadCmd\n  au! BufWriteCmd\n  au! FileReadCmd\n  au! FileWriteCmd\n  au! FileAppendCmd\n  %bwipe!\n  call delete('Xxx')\n  enew!\nendfunc\n\nfunc SetChangeMarks(start, end)\n  exe a:start. 'mark ['\n  exe a:end. 'mark ]'\nendfunc\n\n\" Verify the effects of autocmds on '[ and ']\nfunc Test_change_mark_in_autocmds()\n  edit! Xtest\n  call feedkeys(\"ia\\<CR>b\\<CR>c\\<CR>d\\<C-g>u\", 'xtn')\n\n  call SetChangeMarks(2, 3)\n  write\n  call assert_equal([1, 4], [line(\"'[\"), line(\"']\")])\n\n  call SetChangeMarks(2, 3)\n  au BufWritePre * call assert_equal([1, 4], [line(\"'[\"), line(\"']\")])\n  write\n  au! BufWritePre\n\n  if executable('cat')\n    write XtestFilter\n    write >> XtestFilter\n\n    call SetChangeMarks(2, 3)\n    \" Marks are set to the entire range of the write\n    au FilterWritePre * call assert_equal([1, 4], [line(\"'[\"), line(\"']\")])\n    \" '[ is adjusted to just before the line that will receive the filtered\n    \" data\n    au FilterReadPre * call assert_equal([4, 4], [line(\"'[\"), line(\"']\")])\n    \" The filtered data is read into the buffer, and the source lines are\n    \" still present, so the range is after the source lines\n    au FilterReadPost * call assert_equal([5, 12], [line(\"'[\"), line(\"']\")])\n    %!cat XtestFilter\n    \" After the filtered data is read, the original lines are deleted\n    call assert_equal([1, 8], [line(\"'[\"), line(\"']\")])\n    au! FilterWritePre,FilterReadPre,FilterReadPost\n    undo\n\n    call SetChangeMarks(1, 4)\n    au FilterWritePre * call assert_equal([2, 3], [line(\"'[\"), line(\"']\")])\n    au FilterReadPre * call assert_equal([3, 3], [line(\"'[\"), line(\"']\")])\n    au FilterReadPost * call assert_equal([4, 11], [line(\"'[\"), line(\"']\")])\n    2,3!cat XtestFilter\n    call assert_equal([2, 9], [line(\"'[\"), line(\"']\")])\n    au! FilterWritePre,FilterReadPre,FilterReadPost\n    undo\n\n    call delete('XtestFilter')\n  endif\n\n  call SetChangeMarks(1, 4)\n  au FileWritePre * call assert_equal([2, 3], [line(\"'[\"), line(\"']\")])\n  2,3write Xtest2\n  au! FileWritePre\n\n  call SetChangeMarks(2, 3)\n  au FileAppendPre * call assert_equal([1, 4], [line(\"'[\"), line(\"']\")])\n  write >> Xtest2\n  au! FileAppendPre\n\n  call SetChangeMarks(1, 4)\n  au FileAppendPre * call assert_equal([2, 3], [line(\"'[\"), line(\"']\")])\n  2,3write >> Xtest2\n  au! FileAppendPre\n\n  call SetChangeMarks(1, 1)\n  au FileReadPre * call assert_equal([3, 1], [line(\"'[\"), line(\"']\")])\n  au FileReadPost * call assert_equal([4, 11], [line(\"'[\"), line(\"']\")])\n  3read Xtest2\n  au! FileReadPre,FileReadPost\n  undo\n\n  call SetChangeMarks(4, 4)\n  \" When the line is 0, it's adjusted to 1\n  au FileReadPre * call assert_equal([1, 4], [line(\"'[\"), line(\"']\")])\n  au FileReadPost * call assert_equal([1, 8], [line(\"'[\"), line(\"']\")])\n  0read Xtest2\n  au! FileReadPre,FileReadPost\n  undo\n\n  call SetChangeMarks(4, 4)\n  \" When the line is 0, it's adjusted to 1\n  au FileReadPre * call assert_equal([1, 4], [line(\"'[\"), line(\"']\")])\n  au FileReadPost * call assert_equal([2, 9], [line(\"'[\"), line(\"']\")])\n  1read Xtest2\n  au! FileReadPre,FileReadPost\n  undo\n\n  bwipe!\n  call delete('Xtest')\n  call delete('Xtest2')\nendfunc\n\nfunc Test_Filter_noshelltemp()\n  if !executable('cat')\n    return\n  endif\n\n  enew!\n  call setline(1, ['a', 'b', 'c', 'd'])\n\n  let shelltemp = &shelltemp\n  set shelltemp\n\n  let g:filter_au = 0\n  au FilterWritePre * let g:filter_au += 1\n  au FilterReadPre * let g:filter_au += 1\n  au FilterReadPost * let g:filter_au += 1\n  %!cat\n  call assert_equal(3, g:filter_au)\n\n  if has('filterpipe')\n    set noshelltemp\n\n    let g:filter_au = 0\n    au FilterWritePre * let g:filter_au += 1\n    au FilterReadPre * let g:filter_au += 1\n    au FilterReadPost * let g:filter_au += 1\n    %!cat\n    call assert_equal(0, g:filter_au)\n  endif\n\n  au! FilterWritePre,FilterReadPre,FilterReadPost\n  let &shelltemp = shelltemp\n  bwipe!\nendfunc\n\nfunc Test_TextYankPost()\n  enew!\n  call setline(1, ['foo'])\n\n  let g:event = []\n  au TextYankPost * let g:event = copy(v:event)\n\n  call assert_equal({}, v:event)\n  call assert_fails('let v:event = {}', 'E46:')\n  call assert_fails('let v:event.mykey = 0', 'E742:')\n\n  norm \"ayiw\n  call assert_equal(\n    \\{'regcontents': ['foo'], 'regname': 'a', 'operator': 'y', 'regtype': 'v'},\n    \\g:event)\n  norm y_\n  call assert_equal(\n    \\{'regcontents': ['foo'], 'regname': '',  'operator': 'y', 'regtype': 'V'},\n    \\g:event)\n  call feedkeys(\"\\<C-V>y\", 'x')\n  call assert_equal(\n    \\{'regcontents': ['f'], 'regname': '',  'operator': 'y', 'regtype': \"\\x161\"},\n    \\g:event)\n  norm \"xciwbar\n  call assert_equal(\n    \\{'regcontents': ['foo'], 'regname': 'x', 'operator': 'c', 'regtype': 'v'},\n    \\g:event)\n  norm \"bdiw\n  call assert_equal(\n    \\{'regcontents': ['bar'], 'regname': 'b', 'operator': 'd', 'regtype': 'v'},\n    \\g:event)\n\n  call assert_equal({}, v:event)\n\n  au! TextYankPost\n  unlet g:event\n  bwipe!\nendfunc\n\nfunc Test_nocatch_wipe_all_buffers()\n  \" Real nasty autocommand: wipe all buffers on any event.\n  au * * bwipe *\n  \" Get E93 first?\n  \" call assert_fails('next x', 'E93:')\n  call assert_fails('next x', 'E517:')\n  bwipe\n  au!\nendfunc\n\nfunc Test_nocatch_wipe_dummy_buffer()\n  \" Nasty autocommand: wipe buffer on any event.\n  au * x bwipe\n  call assert_fails('lv\u00bd /x', 'E480')\n  au!\nendfunc\n\nfunction s:Before_test_dirchanged()\n  augroup test_dirchanged\n    autocmd!\n  augroup END\n  let s:li = []\n  let s:dir_this = getcwd()\n  let s:dir_foo = s:dir_this . '/foo'\n  call mkdir(s:dir_foo)\n  let s:dir_bar = s:dir_this . '/bar'\n  call mkdir(s:dir_bar)\nendfunc\n\nfunction s:After_test_dirchanged()\n  exe 'cd' s:dir_this\n  call delete(s:dir_foo, 'd')\n  call delete(s:dir_bar, 'd')\n  augroup test_dirchanged\n    autocmd!\n  augroup END\nendfunc\n\nfunction Test_dirchanged_global()\n  call s:Before_test_dirchanged()\n  autocmd test_dirchanged DirChanged global call add(s:li, \"cd:\")\n  autocmd test_dirchanged DirChanged global call add(s:li, expand(\"<afile>\"))\n  exe 'cd' s:dir_foo\n  call assert_equal([\"cd:\", s:dir_foo], s:li)\n  exe 'cd' s:dir_foo\n  call assert_equal([\"cd:\", s:dir_foo], s:li)\n  exe 'lcd' s:dir_bar\n  call assert_equal([\"cd:\", s:dir_foo], s:li)\n  call s:After_test_dirchanged()\nendfunc\n\nfunction Test_dirchanged_local()\n  call s:Before_test_dirchanged()\n  autocmd test_dirchanged DirChanged window call add(s:li, \"lcd:\")\n  autocmd test_dirchanged DirChanged window call add(s:li, expand(\"<afile>\"))\n  exe 'cd' s:dir_foo\n  call assert_equal([], s:li)\n  exe 'lcd' s:dir_bar\n  call assert_equal([\"lcd:\", s:dir_bar], s:li)\n  exe 'lcd' s:dir_bar\n  call assert_equal([\"lcd:\", s:dir_bar], s:li)\n  call s:After_test_dirchanged()\nendfunc\n\nfunction Test_dirchanged_auto()\n  if !exists('+autochdir')\n    return\n  endif\n  call s:Before_test_dirchanged()\n  call test_autochdir()\n  autocmd test_dirchanged DirChanged auto call add(s:li, \"auto:\")\n  autocmd test_dirchanged DirChanged auto call add(s:li, expand(\"<afile>\"))\n  set acd\n  exe 'cd ..'\n  call assert_equal([], s:li)\n  exe 'edit ' . s:dir_foo . '/Xfile'\n  call assert_equal(s:dir_foo, getcwd())\n  call assert_equal([\"auto:\", s:dir_foo], s:li)\n  set noacd\n  bwipe!\n  call s:After_test_dirchanged()\nendfunc\n\n\" Test TextChangedI and TextChangedP\nfunc Test_ChangedP()\n  new\n  call setline(1, ['foo', 'bar', 'foobar'])\n  call test_override(\"char_avail\", 1)\n  set complete=. completeopt=menuone\n\n  func! TextChangedAutocmd(char)\n    let g:autocmd .= a:char\n  endfunc\n\n  au! TextChanged <buffer> :call TextChangedAutocmd('N')\n  au! TextChangedI <buffer> :call TextChangedAutocmd('I')\n  au! TextChangedP <buffer> :call TextChangedAutocmd('P')\n\n  call cursor(3, 1)\n  let g:autocmd = ''\n  call feedkeys(\"o\\<esc>\", 'tnix')\n  call assert_equal('I', g:autocmd)\n\n  let g:autocmd = ''\n  call feedkeys(\"Sf\", 'tnix')\n  call assert_equal('II', g:autocmd)\n\n  let g:autocmd = ''\n  call feedkeys(\"Sf\\<C-N>\", 'tnix')\n  call assert_equal('IIP', g:autocmd)\n\n  let g:autocmd = ''\n  call feedkeys(\"Sf\\<C-N>\\<C-N>\", 'tnix')\n  call assert_equal('IIPP', g:autocmd)\n\n  let g:autocmd = ''\n  call feedkeys(\"Sf\\<C-N>\\<C-N>\\<C-N>\", 'tnix')\n  call assert_equal('IIPPP', g:autocmd)\n\n  let g:autocmd = ''\n  call feedkeys(\"Sf\\<C-N>\\<C-N>\\<C-N>\\<C-N>\", 'tnix')\n  call assert_equal('IIPPPP', g:autocmd)\n\n  call assert_equal(['foo', 'bar', 'foobar', 'foo'], getline(1, '$'))\n  \" TODO: how should it handle completeopt=noinsert,noselect?\n\n  \" CleanUp\n  call test_override(\"char_avail\", 0)\n  au! TextChanged\n  au! TextChangedI\n  au! TextChangedP\n  delfu TextChangedAutocmd\n  unlet! g:autocmd\n  set complete&vim completeopt&vim\n\n  bw!\nendfunc\n\nlet g:setline_handled = v:false\nfunc SetLineOne()\n  if !g:setline_handled\n    call setline(1, \"(x)\")\n    let g:setline_handled = v:true\n  endif\nendfunc\n\nfunc Test_TextChangedI_with_setline()\n  new\n  call test_override('char_avail', 1)\n  autocmd TextChangedI <buffer> call SetLineOne()\n  call feedkeys(\"i(\\<CR>\\<Esc>\", 'tx')\n  call assert_equal('(', getline(1))\n  call assert_equal('x)', getline(2))\n  undo\n  call assert_equal('', getline(1))\n  call assert_equal('', getline(2))\n\n  call test_override('starting', 0)\n  bwipe!\nendfunc\n\nfunc Test_Changed_FirstTime()\n  CheckFeature terminal\n  CheckNotGui\n\n  \" Prepare file for TextChanged event.\n  call writefile([''], 'Xchanged.txt')\n  let buf = term_start([GetVimProg(), '--clean', '-c', 'set noswapfile'], {'term_rows': 3})\n  call assert_equal('running', term_getstatus(buf))\n  \" Wait for the ruler (in the status line) to be shown.\n  \" In ConPTY, there is additional character which is drawn up to the width of\n  \" the screen.\n  if has('conpty')\n    call WaitForAssert({-> assert_match('\\<All.*$', term_getline(buf, 3))})\n  else\n    call WaitForAssert({-> assert_match('\\<All$', term_getline(buf, 3))})\n  endif\n  \" It's only adding autocmd, so that no event occurs.\n  call term_sendkeys(buf, \":au! TextChanged <buffer> call writefile(['No'], 'Xchanged.txt')\\<cr>\")\n  call term_sendkeys(buf, \"\\<C-\\\\>\\<C-N>:qa!\\<cr>\")\n  call WaitForAssert({-> assert_equal('finished', term_getstatus(buf))})\n  call assert_equal([''], readfile('Xchanged.txt'))\n\n  \" clean up\n  call delete('Xchanged.txt')\n  bwipe!\nendfunc\n\nfunc Test_autocmd_nested()\n  let g:did_nested = 0\n  augroup Testing\n    au WinNew * edit somefile\n    au BufNew * let g:did_nested = 1\n  augroup END\n  split\n  call assert_equal(0, g:did_nested)\n  close\n  bwipe! somefile\n\n  \" old nested argument still works\n  augroup Testing\n    au!\n    au WinNew * nested edit somefile\n    au BufNew * let g:did_nested = 1\n  augroup END\n  split\n  call assert_equal(1, g:did_nested)\n  close\n  bwipe! somefile\n\n  \" New ++nested argument works\n  augroup Testing\n    au!\n    au WinNew * ++nested edit somefile\n    au BufNew * let g:did_nested = 1\n  augroup END\n  split\n  call assert_equal(1, g:did_nested)\n  close\n  bwipe! somefile\n\n  augroup Testing\n    au!\n  augroup END\n\n  call assert_fails('au WinNew * ++nested ++nested echo bad', 'E983:')\n  call assert_fails('au WinNew * nested nested echo bad', 'E983:')\nendfunc\n\nfunc Test_autocmd_once()\n  \" Without ++once WinNew triggers twice\n  let g:did_split = 0\n  augroup Testing\n    au WinNew * let g:did_split += 1\n  augroup END\n  split\n  split\n  call assert_equal(2, g:did_split)\n  call assert_true(exists('#WinNew'))\n  close\n  close\n\n  \" With ++once WinNew triggers once\n  let g:did_split = 0\n  augroup Testing\n    au!\n    au WinNew * ++once let g:did_split += 1\n  augroup END\n  split\n  split\n  call assert_equal(1, g:did_split)\n  call assert_false(exists('#WinNew'))\n  close\n  close\n\n  call assert_fails('au WinNew * ++once ++once echo bad', 'E983:')\nendfunc\n\nfunc Test_autocmd_bufreadpre()\n  new\n  let b:bufreadpre = 1\n  call append(0, range(100))\n  w! XAutocmdBufReadPre.txt\n  autocmd BufReadPre <buffer> :let b:bufreadpre += 1\n  norm! 50gg\n  sp\n  norm! 100gg\n  wincmd p\n  let g:wsv1 = winsaveview()\n  wincmd p\n  let g:wsv2 = winsaveview()\n  \" triggers BufReadPre, should not move the cursor in either window\n  \" The topline may change one line in a large window.\n  edit\n  call assert_inrange(g:wsv2.topline - 1, g:wsv2.topline + 1, winsaveview().topline)\n  call assert_equal(g:wsv2.lnum, winsaveview().lnum)\n  call assert_equal(2, b:bufreadpre)\n  wincmd p\n  call assert_equal(g:wsv1.topline, winsaveview().topline)\n  call assert_equal(g:wsv1.lnum, winsaveview().lnum)\n  call assert_equal(2, b:bufreadpre)\n  \" Now set the cursor position in an BufReadPre autocommand\n  \" (even though the position will be invalid, this should make Vim reset the\n  \" cursor position in the other window.\n  wincmd p\n  set cpo+=g\n  \" won't do anything, but try to set the cursor on an invalid lnum\n  autocmd BufReadPre <buffer> :norm! 70gg\n  \" triggers BufReadPre, should not move the cursor in either window\n  e\n  call assert_equal(1, winsaveview().topline)\n  call assert_equal(1, winsaveview().lnum)\n  call assert_equal(3, b:bufreadpre)\n  wincmd p\n  call assert_equal(g:wsv1.topline, winsaveview().topline)\n  call assert_equal(g:wsv1.lnum, winsaveview().lnum)\n  call assert_equal(3, b:bufreadpre)\n  close\n  close\n  call delete('XAutocmdBufReadPre.txt')\n  set cpo-=g\nendfunc\n\n\" FileChangedShell tested in test_filechanged.vim\n\n\" Tests for the following autocommands:\n\" - FileWritePre\twriting a compressed file\n\" - FileReadPost\treading a compressed file\n\" - BufNewFile\t\treading a file template\n\" - BufReadPre\t\tdecompressing the file to be read\n\" - FilterReadPre\tsubstituting characters in the temp file\n\" - FilterReadPost\tsubstituting characters after filtering\n\" - FileReadPre\t\tset options for decompression\n\" - FileReadPost\tdecompress the file\nfunc Test_ReadWrite_Autocmds()\n  \" Run this test only on Unix-like systems and if gzip is available\n  if !has('unix') || !executable(\"gzip\")\n    return\n  endif\n\n  \" Make $GZIP empty, \"-v\" would cause trouble.\n  let $GZIP = \"\"\n\n  \" Use a FileChangedShell autocommand to avoid a prompt for 'Xtestfile.gz'\n  \" being modified outside of Vim (noticed on Solaris).\n  au FileChangedShell * echo 'caught FileChangedShell'\n\n  \" Test for the FileReadPost, FileWritePre and FileWritePost autocmds\n  augroup Test1\n    au!\n    au FileWritePre    *.gz   '[,']!gzip\n    au FileWritePost   *.gz   undo\n    au FileReadPost    *.gz   '[,']!gzip -d\n  augroup END\n\n  new\n  set bin\n  call append(0, [\n\t      \\ 'line 2\tAbcdefghijklmnopqrstuvwxyz',\n\t      \\ 'line 3\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',\n\t      \\ 'line 4\tAbcdefghijklmnopqrstuvwxyz',\n\t      \\ 'line 5\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',\n\t      \\ 'line 6\tAbcdefghijklmnopqrstuvwxyz',\n\t      \\ 'line 7\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',\n\t      \\ 'line 8\tAbcdefghijklmnopqrstuvwxyz',\n\t      \\ 'line 9\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',\n\t      \\ 'line 10 Abcdefghijklmnopqrstuvwxyz'\n\t      \\ ])\n  1,9write! Xtestfile.gz\n  enew! | close\n\n  new\n  \" Read and decompress the testfile\n  0read Xtestfile.gz\n  call assert_equal([\n\t      \\ 'line 2\tAbcdefghijklmnopqrstuvwxyz',\n\t      \\ 'line 3\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',\n\t      \\ 'line 4\tAbcdefghijklmnopqrstuvwxyz',\n\t      \\ 'line 5\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',\n\t      \\ 'line 6\tAbcdefghijklmnopqrstuvwxyz',\n\t      \\ 'line 7\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',\n\t      \\ 'line 8\tAbcdefghijklmnopqrstuvwxyz',\n\t      \\ 'line 9\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',\n\t      \\ 'line 10 Abcdefghijklmnopqrstuvwxyz'\n\t      \\ ], getline(1, 9))\n  enew! | close\n\n  augroup Test1\n    au!\n  augroup END\n\n  \" Test for the FileAppendPre and FileAppendPost autocmds\n  augroup Test2\n    au!\n    au BufNewFile      *.c    read Xtest.c\n    au FileAppendPre   *.out  '[,']s/new/NEW/\n    au FileAppendPost  *.out  !cat Xtest.c >> test.out\n  augroup END\n\n  call writefile(['/*', ' * Here is a new .c file', ' */'], 'Xtest.c')\n  new foo.c\t\t\t\" should load Xtest.c\n  call assert_equal(['/*', ' * Here is a new .c file', ' */'], getline(2, 4))\n  w! >> test.out\t\t\" append it to the output file\n\n  let contents = readfile('test.out')\n  call assert_equal(' * Here is a NEW .c file', contents[2])\n  call assert_equal(' * Here is a new .c file', contents[5])\n\n  call delete('test.out')\n  enew! | close\n  augroup Test2\n    au!\n  augroup END\n\n  \" Test for the BufReadPre and BufReadPost autocmds\n  augroup Test3\n    au!\n    \" setup autocommands to decompress before reading and re-compress\n    \" afterwards\n    au BufReadPre  *.gz  exe '!gzip -d ' . shellescape(expand(\"<afile>\"))\n    au BufReadPre  *.gz  call rename(expand(\"<afile>:r\"), expand(\"<afile>\"))\n    au BufReadPost *.gz  call rename(expand(\"<afile>\"), expand(\"<afile>:r\"))\n    au BufReadPost *.gz  exe '!gzip ' . shellescape(expand(\"<afile>:r\"))\n  augroup END\n\n  e! Xtestfile.gz\t\t\" Edit compressed file\n  call assert_equal([\n\t      \\ 'line 2\tAbcdefghijklmnopqrstuvwxyz',\n\t      \\ 'line 3\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',\n\t      \\ 'line 4\tAbcdefghijklmnopqrstuvwxyz',\n\t      \\ 'line 5\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',\n\t      \\ 'line 6\tAbcdefghijklmnopqrstuvwxyz',\n\t      \\ 'line 7\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',\n\t      \\ 'line 8\tAbcdefghijklmnopqrstuvwxyz',\n\t      \\ 'line 9\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',\n\t      \\ 'line 10 Abcdefghijklmnopqrstuvwxyz'\n\t      \\ ], getline(1, 9))\n\n  w! >> test.out\t\t\" Append it to the output file\n\n  augroup Test3\n    au!\n  augroup END\n\n  \" Test for the FilterReadPre and FilterReadPost autocmds.\n  set shelltemp\t\t\t\" need temp files here\n  augroup Test4\n    au!\n    au FilterReadPre   *.out  call rename(expand(\"<afile>\"), expand(\"<afile>\") . \".t\")\n    au FilterReadPre   *.out  exe 'silent !sed s/e/E/ ' . shellescape(expand(\"<afile>\")) . \".t >\" . shellescape(expand(\"<afile>\"))\n    au FilterReadPre   *.out  exe 'silent !rm ' . shellescape(expand(\"<afile>\")) . '.t'\n    au FilterReadPost  *.out  '[,']s/x/X/g\n  augroup END\n\n  e! test.out\t\t\t\" Edit the output file\n  1,$!cat\n  call assert_equal([\n\t      \\ 'linE 2\tAbcdefghijklmnopqrstuvwXyz',\n\t      \\ 'linE 3\tXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX',\n\t      \\ 'linE 4\tAbcdefghijklmnopqrstuvwXyz',\n\t      \\ 'linE 5\tXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX',\n\t      \\ 'linE 6\tAbcdefghijklmnopqrstuvwXyz',\n\t      \\ 'linE 7\tXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX',\n\t      \\ 'linE 8\tAbcdefghijklmnopqrstuvwXyz',\n\t      \\ 'linE 9\tXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX',\n\t      \\ 'linE 10 AbcdefghijklmnopqrstuvwXyz'\n\t      \\ ], getline(1, 9))\n  call assert_equal([\n\t      \\ 'line 2\tAbcdefghijklmnopqrstuvwxyz',\n\t      \\ 'line 3\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',\n\t      \\ 'line 4\tAbcdefghijklmnopqrstuvwxyz',\n\t      \\ 'line 5\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',\n\t      \\ 'line 6\tAbcdefghijklmnopqrstuvwxyz',\n\t      \\ 'line 7\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',\n\t      \\ 'line 8\tAbcdefghijklmnopqrstuvwxyz',\n\t      \\ 'line 9\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',\n\t      \\ 'line 10 Abcdefghijklmnopqrstuvwxyz'\n\t      \\ ], readfile('test.out'))\n\n  augroup Test4\n    au!\n  augroup END\n  set shelltemp&vim\n\n  \" Test for the FileReadPre and FileReadPost autocmds.\n  augroup Test5\n    au!\n    au FileReadPre *.gz exe 'silent !gzip -d ' . shellescape(expand(\"<afile>\"))\n    au FileReadPre *.gz call rename(expand(\"<afile>:r\"), expand(\"<afile>\"))\n    au FileReadPost *.gz '[,']s/l/L/\n  augroup END\n\n  new\n  0r Xtestfile.gz\t\t\" Read compressed file\n  call assert_equal([\n\t      \\ 'Line 2\tAbcdefghijklmnopqrstuvwxyz',\n\t      \\ 'Line 3\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',\n\t      \\ 'Line 4\tAbcdefghijklmnopqrstuvwxyz',\n\t      \\ 'Line 5\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',\n\t      \\ 'Line 6\tAbcdefghijklmnopqrstuvwxyz',\n\t      \\ 'Line 7\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',\n\t      \\ 'Line 8\tAbcdefghijklmnopqrstuvwxyz',\n\t      \\ 'Line 9\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',\n\t      \\ 'Line 10 Abcdefghijklmnopqrstuvwxyz'\n\t      \\ ], getline(1, 9))\n  call assert_equal([\n\t      \\ 'line 2\tAbcdefghijklmnopqrstuvwxyz',\n\t      \\ 'line 3\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',\n\t      \\ 'line 4\tAbcdefghijklmnopqrstuvwxyz',\n\t      \\ 'line 5\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',\n\t      \\ 'line 6\tAbcdefghijklmnopqrstuvwxyz',\n\t      \\ 'line 7\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',\n\t      \\ 'line 8\tAbcdefghijklmnopqrstuvwxyz',\n\t      \\ 'line 9\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',\n\t      \\ 'line 10 Abcdefghijklmnopqrstuvwxyz'\n\t      \\ ], readfile('Xtestfile.gz'))\n\n  augroup Test5\n    au!\n  augroup END\n\n  au! FileChangedShell\n  call delete('Xtestfile.gz')\n  call delete('Xtest.c')\n  call delete('test.out')\nendfunc\n\nfunc Test_throw_in_BufWritePre()\n  new\n  call setline(1, ['one', 'two', 'three'])\n  call assert_false(filereadable('Xthefile'))\n  augroup throwing\n    au BufWritePre X* throw 'do not write'\n  augroup END\n  try\n    w Xthefile\n  catch\n    let caught = 1\n  endtry\n  call assert_equal(1, caught)\n  call assert_false(filereadable('Xthefile'))\n\n  bwipe!\n  au! throwing\nendfunc\n\nfunc Test_autocmd_SafeState()\n  CheckRunVimInTerminal\n\n  let lines =<< trim END\n\tlet g:safe = 0\n\tlet g:again = ''\n\tau SafeState * let g:safe += 1\n\tau SafeStateAgain * let g:again ..= 'x'\n\tfunc CallTimer()\n\t  call timer_start(10, {id -> execute('let g:again ..= \"t\"')})\n\tendfunc\n  END\n  call writefile(lines, 'XSafeState')\n  let buf = RunVimInTerminal('-S XSafeState', #{rows: 6})\n\n  \" Sometimes we loop to handle an K_IGNORE\n  call term_sendkeys(buf, \":echo g:safe\\<CR>\")\n  call WaitForAssert({-> assert_match('^[12] ', term_getline(buf, 6))}, 1000)\n\n  call term_sendkeys(buf, \":echo g:again\\<CR>\")\n  call WaitForAssert({-> assert_match('^xxxx', term_getline(buf, 6))}, 1000)\n\n  call term_sendkeys(buf, \":let g:again = ''\\<CR>:call CallTimer()\\<CR>\")\n  call term_wait(buf)\n  call term_sendkeys(buf, \":\\<CR>\")\n  call term_wait(buf)\n  call term_sendkeys(buf, \":echo g:again\\<CR>\")\n  call WaitForAssert({-> assert_match('xtx', term_getline(buf, 6))}, 1000)\n\n  call StopVimInTerminal(buf)\n  call delete('XSafeState')\nendfunc\n\nfunc Test_autocmd_CmdWinEnter()\n  CheckRunVimInTerminal\n  \" There is not cmdwin switch, so\n  \" test for cmdline_hist\n  \" (both are available with small builds)\n  CheckFeature cmdline_hist\n  let lines =<< trim END\n    let b:dummy_var = 'This is a dummy'\n    autocmd CmdWinEnter * quit\n    let winnr = winnr('$')\n  END\n  let filename='XCmdWinEnter'\n  call writefile(lines, filename)\n  let buf = RunVimInTerminal('-S '.filename, #{rows: 6})\n\n  call term_sendkeys(buf, \"q:\")\n  call term_wait(buf)\n  call term_sendkeys(buf, \":echo b:dummy_var\\<cr>\")\n  call WaitForAssert({-> assert_match('^This is a dummy', term_getline(buf, 6))}, 1000)\n  call term_sendkeys(buf, \":echo &buftype\\<cr>\")\n  call WaitForAssert({-> assert_notmatch('^nofile', term_getline(buf, 6))}, 1000)\n  call term_sendkeys(buf, \":echo winnr\\<cr>\")\n  call WaitForAssert({-> assert_match('^1', term_getline(buf, 6))}, 1000)\n\n  \" clean up\n  call StopVimInTerminal(buf)\n  call delete(filename)\nendfunc\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n#ifdef AMIGA\n# include <time.h>\t/* for time() */\n#endif\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n    strcat(longVersion, \")\");\n}\n\n# else\n    void\ninit_longVersion(void)\n{\n    char *date_time = __DATE__ \" \" __TIME__;\n    char *msg = _(\"%s (%s, compiled %s)\");\n    size_t len = strlen(msg)\n\t\t+ strlen(VIM_VERSION_LONG_ONLY)\n\t\t+ strlen(VIM_VERSION_DATE_ONLY)\n\t\t+ strlen(date_time);\n\n    longVersion = alloc(len);\n    if (longVersion == NULL)\n\tlongVersion = VIM_VERSION_LONG;\n    else\n\tvim_snprintf(longVersion, len, msg,\n\t\t      VIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t/* only for Amiga systems */\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n#ifdef NO_BUILTIN_TCAPS\n\t\"-builtin_terms\",\n#endif\n#ifdef SOME_BUILTIN_TCAPS\n\t\"+builtin_terms\",\n#endif\n#ifdef ALL_BUILTIN_TCAPS\n\t\"++builtin_terms\",\n#endif\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n#ifdef FEAT_CINDENT\n\t\"+cindent\",\n#else\n\t\"-cindent\",\n#endif\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n#ifdef FEAT_CMDL_INFO\n\t\"+cmdline_info\",\n#else\n\t\"-cmdline_info\",\n#endif\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n#ifdef EBCDIC\n\t\"+ebcdic\",\n#else\n\t\"-ebcdic\",\n#endif\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n#ifdef FEAT_SEARCHPATH\n\t\"+file_in_path\",\n#else\n\t\"-file_in_path\",\n#endif\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n#ifdef FEAT_FLOAT\n\t\"+float\",\n#else\n\t\"-float\",\n#endif\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n#ifdef FEAT_FOOTER\n\t\"+footer\",\n#else\n\t\"-footer\",\n#endif\n\t    /* only interesting on Unix systems */\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n#ifdef FEAT_HANGULIN\n\t\"+hangul_input\",\n#else\n\t\"-hangul_input\",\n#endif\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n#ifdef FEAT_JUMPLIST\n\t\"+jumplist\",\n#else\n\t\"-jumplist\",\n#endif\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n#ifdef FEAT_LISP\n\t\"+lispindent\",\n#else\n\t\"-lispindent\",\n#endif\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n#ifdef FEAT_MOUSE\n\t\"+mouse\",\n#  ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#  else\n\t\"-mouseshape\",\n#  endif\n# else\n\t\"-mouse\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n\t\"+mouse_gpm\",\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_XTERM\n\t\"+mouse_sgr\",\n# else\n\t\"-mouse_sgr\",\n# endif\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n# ifdef FEAT_MOUSE_XTERM\n\t\"+mouse_xterm\",\n# else\n\t\"-mouse_xterm\",\n# endif\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n#ifdef FEAT_NUM64\n\t\"+num64\",\n#else\n\t\"-num64\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n#ifdef FEAT_PATH_EXTRA\n\t\"+path_extra\",\n#else\n\t\"-path_extra\",\n#endif\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n\t\"+python3/dyn\",\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n#ifdef FEAT_SMARTINDENT\n\t\"+smartindent\",\n#else\n\t\"-smartindent\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    /* only interesting on Unix systems */\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n#ifdef FEAT_TAG_BINS\n\t\"+tag_binary\",\n#else\n\t\"-tag_binary\",\n#endif\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n/* only Unix can have terminfo instead of termcap */\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n#ifdef FEAT_TEXTOBJ\n\t\"+textobjects\",\n#else\n\t\"-textobjects\",\n#endif\n#ifdef FEAT_TEXT_PROP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n/* unix always includes termcap support */\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n#ifdef FEAT_TITLE\n\t\"+title\",\n#else\n\t\"-title\",\n#endif\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n#ifdef FEAT_WILDIGN\n\t\"+wildignore\",\n#else\n\t\"-wildignore\",\n#endif\n#ifdef FEAT_WILDMENU\n\t\"+wildmenu\",\n#else\n\t\"-wildmenu\",\n#endif\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#ifdef MSWIN\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#else\n# ifdef HAVE_XPM\n\t\"+xpm\",\n# else\n\t\"-xpm\",\n# endif\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef USE_XSMP_INTERACT\n\t\"+xsmp_interact\",\n# else\n#  ifdef USE_XSMP\n\t\"+xsmp\",\n#  else\n\t\"-xsmp\",\n#  endif\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    2135,\n/**/\n    2134,\n/**/\n    2133,\n/**/\n    2132,\n/**/\n    2131,\n/**/\n    2130,\n/**/\n    2129,\n/**/\n    2128,\n/**/\n    2127,\n/**/\n    2126,\n/**/\n    2125,\n/**/\n    2124,\n/**/\n    2123,\n/**/\n    2122,\n/**/\n    2121,\n/**/\n    2120,\n/**/\n    2119,\n/**/\n    2118,\n/**/\n    2117,\n/**/\n    2116,\n/**/\n    2115,\n/**/\n    2114,\n/**/\n    2113,\n/**/\n    2112,\n/**/\n    2111,\n/**/\n    2110,\n/**/\n    2109,\n/**/\n    2108,\n/**/\n    2107,\n/**/\n    2106,\n/**/\n    2105,\n/**/\n    2104,\n/**/\n    2103,\n/**/\n    2102,\n/**/\n    2101,\n/**/\n    2100,\n/**/\n    2099,\n/**/\n    2098,\n/**/\n    2097,\n/**/\n    2096,\n/**/\n    2095,\n/**/\n    2094,\n/**/\n    2093,\n/**/\n    2092,\n/**/\n    2091,\n/**/\n    2090,\n/**/\n    2089,\n/**/\n    2088,\n/**/\n    2087,\n/**/\n    2086,\n/**/\n    2085,\n/**/\n    2084,\n/**/\n    2083,\n/**/\n    2082,\n/**/\n    2081,\n/**/\n    2080,\n/**/\n    2079,\n/**/\n    2078,\n/**/\n    2077,\n/**/\n    2076,\n/**/\n    2075,\n/**/\n    2074,\n/**/\n    2073,\n/**/\n    2072,\n/**/\n    2071,\n/**/\n    2070,\n/**/\n    2069,\n/**/\n    2068,\n/**/\n    2067,\n/**/\n    2066,\n/**/\n    2065,\n/**/\n    2064,\n/**/\n    2063,\n/**/\n    2062,\n/**/\n    2061,\n/**/\n    2060,\n/**/\n    2059,\n/**/\n    2058,\n/**/\n    2057,\n/**/\n    2056,\n/**/\n    2055,\n/**/\n    2054,\n/**/\n    2053,\n/**/\n    2052,\n/**/\n    2051,\n/**/\n    2050,\n/**/\n    2049,\n/**/\n    2048,\n/**/\n    2047,\n/**/\n    2046,\n/**/\n    2045,\n/**/\n    2044,\n/**/\n    2043,\n/**/\n    2042,\n/**/\n    2041,\n/**/\n    2040,\n/**/\n    2039,\n/**/\n    2038,\n/**/\n    2037,\n/**/\n    2036,\n/**/\n    2035,\n/**/\n    2034,\n/**/\n    2033,\n/**/\n    2032,\n/**/\n    2031,\n/**/\n    2030,\n/**/\n    2029,\n/**/\n    2028,\n/**/\n    2027,\n/**/\n    2026,\n/**/\n    2025,\n/**/\n    2024,\n/**/\n    2023,\n/**/\n    2022,\n/**/\n    2021,\n/**/\n    2020,\n/**/\n    2019,\n/**/\n    2018,\n/**/\n    2017,\n/**/\n    2016,\n/**/\n    2015,\n/**/\n    2014,\n/**/\n    2013,\n/**/\n    2012,\n/**/\n    2011,\n/**/\n    2010,\n/**/\n    2009,\n/**/\n    2008,\n/**/\n    2007,\n/**/\n    2006,\n/**/\n    2005,\n/**/\n    2004,\n/**/\n    2003,\n/**/\n    2002,\n/**/\n    2001,\n/**/\n    2000,\n/**/\n    1999,\n/**/\n    1998,\n/**/\n    1997,\n/**/\n    1996,\n/**/\n    1995,\n/**/\n    1994,\n/**/\n    1993,\n/**/\n    1992,\n/**/\n    1991,\n/**/\n    1990,\n/**/\n    1989,\n/**/\n    1988,\n/**/\n    1987,\n/**/\n    1986,\n/**/\n    1985,\n/**/\n    1984,\n/**/\n    1983,\n/**/\n    1982,\n/**/\n    1981,\n/**/\n    1980,\n/**/\n    1979,\n/**/\n    1978,\n/**/\n    1977,\n/**/\n    1976,\n/**/\n    1975,\n/**/\n    1974,\n/**/\n    1973,\n/**/\n    1972,\n/**/\n    1971,\n/**/\n    1970,\n/**/\n    1969,\n/**/\n    1968,\n/**/\n    1967,\n/**/\n    1966,\n/**/\n    1965,\n/**/\n    1964,\n/**/\n    1963,\n/**/\n    1962,\n/**/\n    1961,\n/**/\n    1960,\n/**/\n    1959,\n/**/\n    1958,\n/**/\n    1957,\n/**/\n    1956,\n/**/\n    1955,\n/**/\n    1954,\n/**/\n    1953,\n/**/\n    1952,\n/**/\n    1951,\n/**/\n    1950,\n/**/\n    1949,\n/**/\n    1948,\n/**/\n    1947,\n/**/\n    1946,\n/**/\n    1945,\n/**/\n    1944,\n/**/\n    1943,\n/**/\n    1942,\n/**/\n    1941,\n/**/\n    1940,\n/**/\n    1939,\n/**/\n    1938,\n/**/\n    1937,\n/**/\n    1936,\n/**/\n    1935,\n/**/\n    1934,\n/**/\n    1933,\n/**/\n    1932,\n/**/\n    1931,\n/**/\n    1930,\n/**/\n    1929,\n/**/\n    1928,\n/**/\n    1927,\n/**/\n    1926,\n/**/\n    1925,\n/**/\n    1924,\n/**/\n    1923,\n/**/\n    1922,\n/**/\n    1921,\n/**/\n    1920,\n/**/\n    1919,\n/**/\n    1918,\n/**/\n    1917,\n/**/\n    1916,\n/**/\n    1915,\n/**/\n    1914,\n/**/\n    1913,\n/**/\n    1912,\n/**/\n    1911,\n/**/\n    1910,\n/**/\n    1909,\n/**/\n    1908,\n/**/\n    1907,\n/**/\n    1906,\n/**/\n    1905,\n/**/\n    1904,\n/**/\n    1903,\n/**/\n    1902,\n/**/\n    1901,\n/**/\n    1900,\n/**/\n    1899,\n/**/\n    1898,\n/**/\n    1897,\n/**/\n    1896,\n/**/\n    1895,\n/**/\n    1894,\n/**/\n    1893,\n/**/\n    1892,\n/**/\n    1891,\n/**/\n    1890,\n/**/\n    1889,\n/**/\n    1888,\n/**/\n    1887,\n/**/\n    1886,\n/**/\n    1885,\n/**/\n    1884,\n/**/\n    1883,\n/**/\n    1882,\n/**/\n    1881,\n/**/\n    1880,\n/**/\n    1879,\n/**/\n    1878,\n/**/\n    1877,\n/**/\n    1876,\n/**/\n    1875,\n/**/\n    1874,\n/**/\n    1873,\n/**/\n    1872,\n/**/\n    1871,\n/**/\n    1870,\n/**/\n    1869,\n/**/\n    1868,\n/**/\n    1867,\n/**/\n    1866,\n/**/\n    1865,\n/**/\n    1864,\n/**/\n    1863,\n/**/\n    1862,\n/**/\n    1861,\n/**/\n    1860,\n/**/\n    1859,\n/**/\n    1858,\n/**/\n    1857,\n/**/\n    1856,\n/**/\n    1855,\n/**/\n    1854,\n/**/\n    1853,\n/**/\n    1852,\n/**/\n    1851,\n/**/\n    1850,\n/**/\n    1849,\n/**/\n    1848,\n/**/\n    1847,\n/**/\n    1846,\n/**/\n    1845,\n/**/\n    1844,\n/**/\n    1843,\n/**/\n    1842,\n/**/\n    1841,\n/**/\n    1840,\n/**/\n    1839,\n/**/\n    1838,\n/**/\n    1837,\n/**/\n    1836,\n/**/\n    1835,\n/**/\n    1834,\n/**/\n    1833,\n/**/\n    1832,\n/**/\n    1831,\n/**/\n    1830,\n/**/\n    1829,\n/**/\n    1828,\n/**/\n    1827,\n/**/\n    1826,\n/**/\n    1825,\n/**/\n    1824,\n/**/\n    1823,\n/**/\n    1822,\n/**/\n    1821,\n/**/\n    1820,\n/**/\n    1819,\n/**/\n    1818,\n/**/\n    1817,\n/**/\n    1816,\n/**/\n    1815,\n/**/\n    1814,\n/**/\n    1813,\n/**/\n    1812,\n/**/\n    1811,\n/**/\n    1810,\n/**/\n    1809,\n/**/\n    1808,\n/**/\n    1807,\n/**/\n    1806,\n/**/\n    1805,\n/**/\n    1804,\n/**/\n    1803,\n/**/\n    1802,\n/**/\n    1801,\n/**/\n    1800,\n/**/\n    1799,\n/**/\n    1798,\n/**/\n    1797,\n/**/\n    1796,\n/**/\n    1795,\n/**/\n    1794,\n/**/\n    1793,\n/**/\n    1792,\n/**/\n    1791,\n/**/\n    1790,\n/**/\n    1789,\n/**/\n    1788,\n/**/\n    1787,\n/**/\n    1786,\n/**/\n    1785,\n/**/\n    1784,\n/**/\n    1783,\n/**/\n    1782,\n/**/\n    1781,\n/**/\n    1780,\n/**/\n    1779,\n/**/\n    1778,\n/**/\n    1777,\n/**/\n    1776,\n/**/\n    1775,\n/**/\n    1774,\n/**/\n    1773,\n/**/\n    1772,\n/**/\n    1771,\n/**/\n    1770,\n/**/\n    1769,\n/**/\n    1768,\n/**/\n    1767,\n/**/\n    1766,\n/**/\n    1765,\n/**/\n    1764,\n/**/\n    1763,\n/**/\n    1762,\n/**/\n    1761,\n/**/\n    1760,\n/**/\n    1759,\n/**/\n    1758,\n/**/\n    1757,\n/**/\n    1756,\n/**/\n    1755,\n/**/\n    1754,\n/**/\n    1753,\n/**/\n    1752,\n/**/\n    1751,\n/**/\n    1750,\n/**/\n    1749,\n/**/\n    1748,\n/**/\n    1747,\n/**/\n    1746,\n/**/\n    1745,\n/**/\n    1744,\n/**/\n    1743,\n/**/\n    1742,\n/**/\n    1741,\n/**/\n    1740,\n/**/\n    1739,\n/**/\n    1738,\n/**/\n    1737,\n/**/\n    1736,\n/**/\n    1735,\n/**/\n    1734,\n/**/\n    1733,\n/**/\n    1732,\n/**/\n    1731,\n/**/\n    1730,\n/**/\n    1729,\n/**/\n    1728,\n/**/\n    1727,\n/**/\n    1726,\n/**/\n    1725,\n/**/\n    1724,\n/**/\n    1723,\n/**/\n    1722,\n/**/\n    1721,\n/**/\n    1720,\n/**/\n    1719,\n/**/\n    1718,\n/**/\n    1717,\n/**/\n    1716,\n/**/\n    1715,\n/**/\n    1714,\n/**/\n    1713,\n/**/\n    1712,\n/**/\n    1711,\n/**/\n    1710,\n/**/\n    1709,\n/**/\n    1708,\n/**/\n    1707,\n/**/\n    1706,\n/**/\n    1705,\n/**/\n    1704,\n/**/\n    1703,\n/**/\n    1702,\n/**/\n    1701,\n/**/\n    1700,\n/**/\n    1699,\n/**/\n    1698,\n/**/\n    1697,\n/**/\n    1696,\n/**/\n    1695,\n/**/\n    1694,\n/**/\n    1693,\n/**/\n    1692,\n/**/\n    1691,\n/**/\n    1690,\n/**/\n    1689,\n/**/\n    1688,\n/**/\n    1687,\n/**/\n    1686,\n/**/\n    1685,\n/**/\n    1684,\n/**/\n    1683,\n/**/\n    1682,\n/**/\n    1681,\n/**/\n    1680,\n/**/\n    1679,\n/**/\n    1678,\n/**/\n    1677,\n/**/\n    1676,\n/**/\n    1675,\n/**/\n    1674,\n/**/\n    1673,\n/**/\n    1672,\n/**/\n    1671,\n/**/\n    1670,\n/**/\n    1669,\n/**/\n    1668,\n/**/\n    1667,\n/**/\n    1666,\n/**/\n    1665,\n/**/\n    1664,\n/**/\n    1663,\n/**/\n    1662,\n/**/\n    1661,\n/**/\n    1660,\n/**/\n    1659,\n/**/\n    1658,\n/**/\n    1657,\n/**/\n    1656,\n/**/\n    1655,\n/**/\n    1654,\n/**/\n    1653,\n/**/\n    1652,\n/**/\n    1651,\n/**/\n    1650,\n/**/\n    1649,\n/**/\n    1648,\n/**/\n    1647,\n/**/\n    1646,\n/**/\n    1645,\n/**/\n    1644,\n/**/\n    1643,\n/**/\n    1642,\n/**/\n    1641,\n/**/\n    1640,\n/**/\n    1639,\n/**/\n    1638,\n/**/\n    1637,\n/**/\n    1636,\n/**/\n    1635,\n/**/\n    1634,\n/**/\n    1633,\n/**/\n    1632,\n/**/\n    1631,\n/**/\n    1630,\n/**/\n    1629,\n/**/\n    1628,\n/**/\n    1627,\n/**/\n    1626,\n/**/\n    1625,\n/**/\n    1624,\n/**/\n    1623,\n/**/\n    1622,\n/**/\n    1621,\n/**/\n    1620,\n/**/\n    1619,\n/**/\n    1618,\n/**/\n    1617,\n/**/\n    1616,\n/**/\n    1615,\n/**/\n    1614,\n/**/\n    1613,\n/**/\n    1612,\n/**/\n    1611,\n/**/\n    1610,\n/**/\n    1609,\n/**/\n    1608,\n/**/\n    1607,\n/**/\n    1606,\n/**/\n    1605,\n/**/\n    1604,\n/**/\n    1603,\n/**/\n    1602,\n/**/\n    1601,\n/**/\n    1600,\n/**/\n    1599,\n/**/\n    1598,\n/**/\n    1597,\n/**/\n    1596,\n/**/\n    1595,\n/**/\n    1594,\n/**/\n    1593,\n/**/\n    1592,\n/**/\n    1591,\n/**/\n    1590,\n/**/\n    1589,\n/**/\n    1588,\n/**/\n    1587,\n/**/\n    1586,\n/**/\n    1585,\n/**/\n    1584,\n/**/\n    1583,\n/**/\n    1582,\n/**/\n    1581,\n/**/\n    1580,\n/**/\n    1579,\n/**/\n    1578,\n/**/\n    1577,\n/**/\n    1576,\n/**/\n    1575,\n/**/\n    1574,\n/**/\n    1573,\n/**/\n    1572,\n/**/\n    1571,\n/**/\n    1570,\n/**/\n    1569,\n/**/\n    1568,\n/**/\n    1567,\n/**/\n    1566,\n/**/\n    1565,\n/**/\n    1564,\n/**/\n    1563,\n/**/\n    1562,\n/**/\n    1561,\n/**/\n    1560,\n/**/\n    1559,\n/**/\n    1558,\n/**/\n    1557,\n/**/\n    1556,\n/**/\n    1555,\n/**/\n    1554,\n/**/\n    1553,\n/**/\n    1552,\n/**/\n    1551,\n/**/\n    1550,\n/**/\n    1549,\n/**/\n    1548,\n/**/\n    1547,\n/**/\n    1546,\n/**/\n    1545,\n/**/\n    1544,\n/**/\n    1543,\n/**/\n    1542,\n/**/\n    1541,\n/**/\n    1540,\n/**/\n    1539,\n/**/\n    1538,\n/**/\n    1537,\n/**/\n    1536,\n/**/\n    1535,\n/**/\n    1534,\n/**/\n    1533,\n/**/\n    1532,\n/**/\n    1531,\n/**/\n    1530,\n/**/\n    1529,\n/**/\n    1528,\n/**/\n    1527,\n/**/\n    1526,\n/**/\n    1525,\n/**/\n    1524,\n/**/\n    1523,\n/**/\n    1522,\n/**/\n    1521,\n/**/\n    1520,\n/**/\n    1519,\n/**/\n    1518,\n/**/\n    1517,\n/**/\n    1516,\n/**/\n    1515,\n/**/\n    1514,\n/**/\n    1513,\n/**/\n    1512,\n/**/\n    1511,\n/**/\n    1510,\n/**/\n    1509,\n/**/\n    1508,\n/**/\n    1507,\n/**/\n    1506,\n/**/\n    1505,\n/**/\n    1504,\n/**/\n    1503,\n/**/\n    1502,\n/**/\n    1501,\n/**/\n    1500,\n/**/\n    1499,\n/**/\n    1498,\n/**/\n    1497,\n/**/\n    1496,\n/**/\n    1495,\n/**/\n    1494,\n/**/\n    1493,\n/**/\n    1492,\n/**/\n    1491,\n/**/\n    1490,\n/**/\n    1489,\n/**/\n    1488,\n/**/\n    1487,\n/**/\n    1486,\n/**/\n    1485,\n/**/\n    1484,\n/**/\n    1483,\n/**/\n    1482,\n/**/\n    1481,\n/**/\n    1480,\n/**/\n    1479,\n/**/\n    1478,\n/**/\n    1477,\n/**/\n    1476,\n/**/\n    1475,\n/**/\n    1474,\n/**/\n    1473,\n/**/\n    1472,\n/**/\n    1471,\n/**/\n    1470,\n/**/\n    1469,\n/**/\n    1468,\n/**/\n    1467,\n/**/\n    1466,\n/**/\n    1465,\n/**/\n    1464,\n/**/\n    1463,\n/**/\n    1462,\n/**/\n    1461,\n/**/\n    1460,\n/**/\n    1459,\n/**/\n    1458,\n/**/\n    1457,\n/**/\n    1456,\n/**/\n    1455,\n/**/\n    1454,\n/**/\n    1453,\n/**/\n    1452,\n/**/\n    1451,\n/**/\n    1450,\n/**/\n    1449,\n/**/\n    1448,\n/**/\n    1447,\n/**/\n    1446,\n/**/\n    1445,\n/**/\n    1444,\n/**/\n    1443,\n/**/\n    1442,\n/**/\n    1441,\n/**/\n    1440,\n/**/\n    1439,\n/**/\n    1438,\n/**/\n    1437,\n/**/\n    1436,\n/**/\n    1435,\n/**/\n    1434,\n/**/\n    1433,\n/**/\n    1432,\n/**/\n    1431,\n/**/\n    1430,\n/**/\n    1429,\n/**/\n    1428,\n/**/\n    1427,\n/**/\n    1426,\n/**/\n    1425,\n/**/\n    1424,\n/**/\n    1423,\n/**/\n    1422,\n/**/\n    1421,\n/**/\n    1420,\n/**/\n    1419,\n/**/\n    1418,\n/**/\n    1417,\n/**/\n    1416,\n/**/\n    1415,\n/**/\n    1414,\n/**/\n    1413,\n/**/\n    1412,\n/**/\n    1411,\n/**/\n    1410,\n/**/\n    1409,\n/**/\n    1408,\n/**/\n    1407,\n/**/\n    1406,\n/**/\n    1405,\n/**/\n    1404,\n/**/\n    1403,\n/**/\n    1402,\n/**/\n    1401,\n/**/\n    1400,\n/**/\n    1399,\n/**/\n    1398,\n/**/\n    1397,\n/**/\n    1396,\n/**/\n    1395,\n/**/\n    1394,\n/**/\n    1393,\n/**/\n    1392,\n/**/\n    1391,\n/**/\n    1390,\n/**/\n    1389,\n/**/\n    1388,\n/**/\n    1387,\n/**/\n    1386,\n/**/\n    1385,\n/**/\n    1384,\n/**/\n    1383,\n/**/\n    1382,\n/**/\n    1381,\n/**/\n    1380,\n/**/\n    1379,\n/**/\n    1378,\n/**/\n    1377,\n/**/\n    1376,\n/**/\n    1375,\n/**/\n    1374,\n/**/\n    1373,\n/**/\n    1372,\n/**/\n    1371,\n/**/\n    1370,\n/**/\n    1369,\n/**/\n    1368,\n/**/\n    1367,\n/**/\n    1366,\n/**/\n    1365,\n/**/\n    1364,\n/**/\n    1363,\n/**/\n    1362,\n/**/\n    1361,\n/**/\n    1360,\n/**/\n    1359,\n/**/\n    1358,\n/**/\n    1357,\n/**/\n    1356,\n/**/\n    1355,\n/**/\n    1354,\n/**/\n    1353,\n/**/\n    1352,\n/**/\n    1351,\n/**/\n    1350,\n/**/\n    1349,\n/**/\n    1348,\n/**/\n    1347,\n/**/\n    1346,\n/**/\n    1345,\n/**/\n    1344,\n/**/\n    1343,\n/**/\n    1342,\n/**/\n    1341,\n/**/\n    1340,\n/**/\n    1339,\n/**/\n    1338,\n/**/\n    1337,\n/**/\n    1336,\n/**/\n    1335,\n/**/\n    1334,\n/**/\n    1333,\n/**/\n    1332,\n/**/\n    1331,\n/**/\n    1330,\n/**/\n    1329,\n/**/\n    1328,\n/**/\n    1327,\n/**/\n    1326,\n/**/\n    1325,\n/**/\n    1324,\n/**/\n    1323,\n/**/\n    1322,\n/**/\n    1321,\n/**/\n    1320,\n/**/\n    1319,\n/**/\n    1318,\n/**/\n    1317,\n/**/\n    1316,\n/**/\n    1315,\n/**/\n    1314,\n/**/\n    1313,\n/**/\n    1312,\n/**/\n    1311,\n/**/\n    1310,\n/**/\n    1309,\n/**/\n    1308,\n/**/\n    1307,\n/**/\n    1306,\n/**/\n    1305,\n/**/\n    1304,\n/**/\n    1303,\n/**/\n    1302,\n/**/\n    1301,\n/**/\n    1300,\n/**/\n    1299,\n/**/\n    1298,\n/**/\n    1297,\n/**/\n    1296,\n/**/\n    1295,\n/**/\n    1294,\n/**/\n    1293,\n/**/\n    1292,\n/**/\n    1291,\n/**/\n    1290,\n/**/\n    1289,\n/**/\n    1288,\n/**/\n    1287,\n/**/\n    1286,\n/**/\n    1285,\n/**/\n    1284,\n/**/\n    1283,\n/**/\n    1282,\n/**/\n    1281,\n/**/\n    1280,\n/**/\n    1279,\n/**/\n    1278,\n/**/\n    1277,\n/**/\n    1276,\n/**/\n    1275,\n/**/\n    1274,\n/**/\n    1273,\n/**/\n    1272,\n/**/\n    1271,\n/**/\n    1270,\n/**/\n    1269,\n/**/\n    1268,\n/**/\n    1267,\n/**/\n    1266,\n/**/\n    1265,\n/**/\n    1264,\n/**/\n    1263,\n/**/\n    1262,\n/**/\n    1261,\n/**/\n    1260,\n/**/\n    1259,\n/**/\n    1258,\n/**/\n    1257,\n/**/\n    1256,\n/**/\n    1255,\n/**/\n    1254,\n/**/\n    1253,\n/**/\n    1252,\n/**/\n    1251,\n/**/\n    1250,\n/**/\n    1249,\n/**/\n    1248,\n/**/\n    1247,\n/**/\n    1246,\n/**/\n    1245,\n/**/\n    1244,\n/**/\n    1243,\n/**/\n    1242,\n/**/\n    1241,\n/**/\n    1240,\n/**/\n    1239,\n/**/\n    1238,\n/**/\n    1237,\n/**/\n    1236,\n/**/\n    1235,\n/**/\n    1234,\n/**/\n    1233,\n/**/\n    1232,\n/**/\n    1231,\n/**/\n    1230,\n/**/\n    1229,\n/**/\n    1228,\n/**/\n    1227,\n/**/\n    1226,\n/**/\n    1225,\n/**/\n    1224,\n/**/\n    1223,\n/**/\n    1222,\n/**/\n    1221,\n/**/\n    1220,\n/**/\n    1219,\n/**/\n    1218,\n/**/\n    1217,\n/**/\n    1216,\n/**/\n    1215,\n/**/\n    1214,\n/**/\n    1213,\n/**/\n    1212,\n/**/\n    1211,\n/**/\n    1210,\n/**/\n    1209,\n/**/\n    1208,\n/**/\n    1207,\n/**/\n    1206,\n/**/\n    1205,\n/**/\n    1204,\n/**/\n    1203,\n/**/\n    1202,\n/**/\n    1201,\n/**/\n    1200,\n/**/\n    1199,\n/**/\n    1198,\n/**/\n    1197,\n/**/\n    1196,\n/**/\n    1195,\n/**/\n    1194,\n/**/\n    1193,\n/**/\n    1192,\n/**/\n    1191,\n/**/\n    1190,\n/**/\n    1189,\n/**/\n    1188,\n/**/\n    1187,\n/**/\n    1186,\n/**/\n    1185,\n/**/\n    1184,\n/**/\n    1183,\n/**/\n    1182,\n/**/\n    1181,\n/**/\n    1180,\n/**/\n    1179,\n/**/\n    1178,\n/**/\n    1177,\n/**/\n    1176,\n/**/\n    1175,\n/**/\n    1174,\n/**/\n    1173,\n/**/\n    1172,\n/**/\n    1171,\n/**/\n    1170,\n/**/\n    1169,\n/**/\n    1168,\n/**/\n    1167,\n/**/\n    1166,\n/**/\n    1165,\n/**/\n    1164,\n/**/\n    1163,\n/**/\n    1162,\n/**/\n    1161,\n/**/\n    1160,\n/**/\n    1159,\n/**/\n    1158,\n/**/\n    1157,\n/**/\n    1156,\n/**/\n    1155,\n/**/\n    1154,\n/**/\n    1153,\n/**/\n    1152,\n/**/\n    1151,\n/**/\n    1150,\n/**/\n    1149,\n/**/\n    1148,\n/**/\n    1147,\n/**/\n    1146,\n/**/\n    1145,\n/**/\n    1144,\n/**/\n    1143,\n/**/\n    1142,\n/**/\n    1141,\n/**/\n    1140,\n/**/\n    1139,\n/**/\n    1138,\n/**/\n    1137,\n/**/\n    1136,\n/**/\n    1135,\n/**/\n    1134,\n/**/\n    1133,\n/**/\n    1132,\n/**/\n    1131,\n/**/\n    1130,\n/**/\n    1129,\n/**/\n    1128,\n/**/\n    1127,\n/**/\n    1126,\n/**/\n    1125,\n/**/\n    1124,\n/**/\n    1123,\n/**/\n    1122,\n/**/\n    1121,\n/**/\n    1120,\n/**/\n    1119,\n/**/\n    1118,\n/**/\n    1117,\n/**/\n    1116,\n/**/\n    1115,\n/**/\n    1114,\n/**/\n    1113,\n/**/\n    1112,\n/**/\n    1111,\n/**/\n    1110,\n/**/\n    1109,\n/**/\n    1108,\n/**/\n    1107,\n/**/\n    1106,\n/**/\n    1105,\n/**/\n    1104,\n/**/\n    1103,\n/**/\n    1102,\n/**/\n    1101,\n/**/\n    1100,\n/**/\n    1099,\n/**/\n    1098,\n/**/\n    1097,\n/**/\n    1096,\n/**/\n    1095,\n/**/\n    1094,\n/**/\n    1093,\n/**/\n    1092,\n/**/\n    1091,\n/**/\n    1090,\n/**/\n    1089,\n/**/\n    1088,\n/**/\n    1087,\n/**/\n    1086,\n/**/\n    1085,\n/**/\n    1084,\n/**/\n    1083,\n/**/\n    1082,\n/**/\n    1081,\n/**/\n    1080,\n/**/\n    1079,\n/**/\n    1078,\n/**/\n    1077,\n/**/\n    1076,\n/**/\n    1075,\n/**/\n    1074,\n/**/\n    1073,\n/**/\n    1072,\n/**/\n    1071,\n/**/\n    1070,\n/**/\n    1069,\n/**/\n    1068,\n/**/\n    1067,\n/**/\n    1066,\n/**/\n    1065,\n/**/\n    1064,\n/**/\n    1063,\n/**/\n    1062,\n/**/\n    1061,\n/**/\n    1060,\n/**/\n    1059,\n/**/\n    1058,\n/**/\n    1057,\n/**/\n    1056,\n/**/\n    1055,\n/**/\n    1054,\n/**/\n    1053,\n/**/\n    1052,\n/**/\n    1051,\n/**/\n    1050,\n/**/\n    1049,\n/**/\n    1048,\n/**/\n    1047,\n/**/\n    1046,\n/**/\n    1045,\n/**/\n    1044,\n/**/\n    1043,\n/**/\n    1042,\n/**/\n    1041,\n/**/\n    1040,\n/**/\n    1039,\n/**/\n    1038,\n/**/\n    1037,\n/**/\n    1036,\n/**/\n    1035,\n/**/\n    1034,\n/**/\n    1033,\n/**/\n    1032,\n/**/\n    1031,\n/**/\n    1030,\n/**/\n    1029,\n/**/\n    1028,\n/**/\n    1027,\n/**/\n    1026,\n/**/\n    1025,\n/**/\n    1024,\n/**/\n    1023,\n/**/\n    1022,\n/**/\n    1021,\n/**/\n    1020,\n/**/\n    1019,\n/**/\n    1018,\n/**/\n    1017,\n/**/\n    1016,\n/**/\n    1015,\n/**/\n    1014,\n/**/\n    1013,\n/**/\n    1012,\n/**/\n    1011,\n/**/\n    1010,\n/**/\n    1009,\n/**/\n    1008,\n/**/\n    1007,\n/**/\n    1006,\n/**/\n    1005,\n/**/\n    1004,\n/**/\n    1003,\n/**/\n    1002,\n/**/\n    1001,\n/**/\n    1000,\n/**/\n    999,\n/**/\n    998,\n/**/\n    997,\n/**/\n    996,\n/**/\n    995,\n/**/\n    994,\n/**/\n    993,\n/**/\n    992,\n/**/\n    991,\n/**/\n    990,\n/**/\n    989,\n/**/\n    988,\n/**/\n    987,\n/**/\n    986,\n/**/\n    985,\n/**/\n    984,\n/**/\n    983,\n/**/\n    982,\n/**/\n    981,\n/**/\n    980,\n/**/\n    979,\n/**/\n    978,\n/**/\n    977,\n/**/\n    976,\n/**/\n    975,\n/**/\n    974,\n/**/\n    973,\n/**/\n    972,\n/**/\n    971,\n/**/\n    970,\n/**/\n    969,\n/**/\n    968,\n/**/\n    967,\n/**/\n    966,\n/**/\n    965,\n/**/\n    964,\n/**/\n    963,\n/**/\n    962,\n/**/\n    961,\n/**/\n    960,\n/**/\n    959,\n/**/\n    958,\n/**/\n    957,\n/**/\n    956,\n/**/\n    955,\n/**/\n    954,\n/**/\n    953,\n/**/\n    952,\n/**/\n    951,\n/**/\n    950,\n/**/\n    949,\n/**/\n    948,\n/**/\n    947,\n/**/\n    946,\n/**/\n    945,\n/**/\n    944,\n/**/\n    943,\n/**/\n    942,\n/**/\n    941,\n/**/\n    940,\n/**/\n    939,\n/**/\n    938,\n/**/\n    937,\n/**/\n    936,\n/**/\n    935,\n/**/\n    934,\n/**/\n    933,\n/**/\n    932,\n/**/\n    931,\n/**/\n    930,\n/**/\n    929,\n/**/\n    928,\n/**/\n    927,\n/**/\n    926,\n/**/\n    925,\n/**/\n    924,\n/**/\n    923,\n/**/\n    922,\n/**/\n    921,\n/**/\n    920,\n/**/\n    919,\n/**/\n    918,\n/**/\n    917,\n/**/\n    916,\n/**/\n    915,\n/**/\n    914,\n/**/\n    913,\n/**/\n    912,\n/**/\n    911,\n/**/\n    910,\n/**/\n    909,\n/**/\n    908,\n/**/\n    907,\n/**/\n    906,\n/**/\n    905,\n/**/\n    904,\n/**/\n    903,\n/**/\n    902,\n/**/\n    901,\n/**/\n    900,\n/**/\n    899,\n/**/\n    898,\n/**/\n    897,\n/**/\n    896,\n/**/\n    895,\n/**/\n    894,\n/**/\n    893,\n/**/\n    892,\n/**/\n    891,\n/**/\n    890,\n/**/\n    889,\n/**/\n    888,\n/**/\n    887,\n/**/\n    886,\n/**/\n    885,\n/**/\n    884,\n/**/\n    883,\n/**/\n    882,\n/**/\n    881,\n/**/\n    880,\n/**/\n    879,\n/**/\n    878,\n/**/\n    877,\n/**/\n    876,\n/**/\n    875,\n/**/\n    874,\n/**/\n    873,\n/**/\n    872,\n/**/\n    871,\n/**/\n    870,\n/**/\n    869,\n/**/\n    868,\n/**/\n    867,\n/**/\n    866,\n/**/\n    865,\n/**/\n    864,\n/**/\n    863,\n/**/\n    862,\n/**/\n    861,\n/**/\n    860,\n/**/\n    859,\n/**/\n    858,\n/**/\n    857,\n/**/\n    856,\n/**/\n    855,\n/**/\n    854,\n/**/\n    853,\n/**/\n    852,\n/**/\n    851,\n/**/\n    850,\n/**/\n    849,\n/**/\n    848,\n/**/\n    847,\n/**/\n    846,\n/**/\n    845,\n/**/\n    844,\n/**/\n    843,\n/**/\n    842,\n/**/\n    841,\n/**/\n    840,\n/**/\n    839,\n/**/\n    838,\n/**/\n    837,\n/**/\n    836,\n/**/\n    835,\n/**/\n    834,\n/**/\n    833,\n/**/\n    832,\n/**/\n    831,\n/**/\n    830,\n/**/\n    829,\n/**/\n    828,\n/**/\n    827,\n/**/\n    826,\n/**/\n    825,\n/**/\n    824,\n/**/\n    823,\n/**/\n    822,\n/**/\n    821,\n/**/\n    820,\n/**/\n    819,\n/**/\n    818,\n/**/\n    817,\n/**/\n    816,\n/**/\n    815,\n/**/\n    814,\n/**/\n    813,\n/**/\n    812,\n/**/\n    811,\n/**/\n    810,\n/**/\n    809,\n/**/\n    808,\n/**/\n    807,\n/**/\n    806,\n/**/\n    805,\n/**/\n    804,\n/**/\n    803,\n/**/\n    802,\n/**/\n    801,\n/**/\n    800,\n/**/\n    799,\n/**/\n    798,\n/**/\n    797,\n/**/\n    796,\n/**/\n    795,\n/**/\n    794,\n/**/\n    793,\n/**/\n    792,\n/**/\n    791,\n/**/\n    790,\n/**/\n    789,\n/**/\n    788,\n/**/\n    787,\n/**/\n    786,\n/**/\n    785,\n/**/\n    784,\n/**/\n    783,\n/**/\n    782,\n/**/\n    781,\n/**/\n    780,\n/**/\n    779,\n/**/\n    778,\n/**/\n    777,\n/**/\n    776,\n/**/\n    775,\n/**/\n    774,\n/**/\n    773,\n/**/\n    772,\n/**/\n    771,\n/**/\n    770,\n/**/\n    769,\n/**/\n    768,\n/**/\n    767,\n/**/\n    766,\n/**/\n    765,\n/**/\n    764,\n/**/\n    763,\n/**/\n    762,\n/**/\n    761,\n/**/\n    760,\n/**/\n    759,\n/**/\n    758,\n/**/\n    757,\n/**/\n    756,\n/**/\n    755,\n/**/\n    754,\n/**/\n    753,\n/**/\n    752,\n/**/\n    751,\n/**/\n    750,\n/**/\n    749,\n/**/\n    748,\n/**/\n    747,\n/**/\n    746,\n/**/\n    745,\n/**/\n    744,\n/**/\n    743,\n/**/\n    742,\n/**/\n    741,\n/**/\n    740,\n/**/\n    739,\n/**/\n    738,\n/**/\n    737,\n/**/\n    736,\n/**/\n    735,\n/**/\n    734,\n/**/\n    733,\n/**/\n    732,\n/**/\n    731,\n/**/\n    730,\n/**/\n    729,\n/**/\n    728,\n/**/\n    727,\n/**/\n    726,\n/**/\n    725,\n/**/\n    724,\n/**/\n    723,\n/**/\n    722,\n/**/\n    721,\n/**/\n    720,\n/**/\n    719,\n/**/\n    718,\n/**/\n    717,\n/**/\n    716,\n/**/\n    715,\n/**/\n    714,\n/**/\n    713,\n/**/\n    712,\n/**/\n    711,\n/**/\n    710,\n/**/\n    709,\n/**/\n    708,\n/**/\n    707,\n/**/\n    706,\n/**/\n    705,\n/**/\n    704,\n/**/\n    703,\n/**/\n    702,\n/**/\n    701,\n/**/\n    700,\n/**/\n    699,\n/**/\n    698,\n/**/\n    697,\n/**/\n    696,\n/**/\n    695,\n/**/\n    694,\n/**/\n    693,\n/**/\n    692,\n/**/\n    691,\n/**/\n    690,\n/**/\n    689,\n/**/\n    688,\n/**/\n    687,\n/**/\n    686,\n/**/\n    685,\n/**/\n    684,\n/**/\n    683,\n/**/\n    682,\n/**/\n    681,\n/**/\n    680,\n/**/\n    679,\n/**/\n    678,\n/**/\n    677,\n/**/\n    676,\n/**/\n    675,\n/**/\n    674,\n/**/\n    673,\n/**/\n    672,\n/**/\n    671,\n/**/\n    670,\n/**/\n    669,\n/**/\n    668,\n/**/\n    667,\n/**/\n    666,\n/**/\n    665,\n/**/\n    664,\n/**/\n    663,\n/**/\n    662,\n/**/\n    661,\n/**/\n    660,\n/**/\n    659,\n/**/\n    658,\n/**/\n    657,\n/**/\n    656,\n/**/\n    655,\n/**/\n    654,\n/**/\n    653,\n/**/\n    652,\n/**/\n    651,\n/**/\n    650,\n/**/\n    649,\n/**/\n    648,\n/**/\n    647,\n/**/\n    646,\n/**/\n    645,\n/**/\n    644,\n/**/\n    643,\n/**/\n    642,\n/**/\n    641,\n/**/\n    640,\n/**/\n    639,\n/**/\n    638,\n/**/\n    637,\n/**/\n    636,\n/**/\n    635,\n/**/\n    634,\n/**/\n    633,\n/**/\n    632,\n/**/\n    631,\n/**/\n    630,\n/**/\n    629,\n/**/\n    628,\n/**/\n    627,\n/**/\n    626,\n/**/\n    625,\n/**/\n    624,\n/**/\n    623,\n/**/\n    622,\n/**/\n    621,\n/**/\n    620,\n/**/\n    619,\n/**/\n    618,\n/**/\n    617,\n/**/\n    616,\n/**/\n    615,\n/**/\n    614,\n/**/\n    613,\n/**/\n    612,\n/**/\n    611,\n/**/\n    610,\n/**/\n    609,\n/**/\n    608,\n/**/\n    607,\n/**/\n    606,\n/**/\n    605,\n/**/\n    604,\n/**/\n    603,\n/**/\n    602,\n/**/\n    601,\n/**/\n    600,\n/**/\n    599,\n/**/\n    598,\n/**/\n    597,\n/**/\n    596,\n/**/\n    595,\n/**/\n    594,\n/**/\n    593,\n/**/\n    592,\n/**/\n    591,\n/**/\n    590,\n/**/\n    589,\n/**/\n    588,\n/**/\n    587,\n/**/\n    586,\n/**/\n    585,\n/**/\n    584,\n/**/\n    583,\n/**/\n    582,\n/**/\n    581,\n/**/\n    580,\n/**/\n    579,\n/**/\n    578,\n/**/\n    577,\n/**/\n    576,\n/**/\n    575,\n/**/\n    574,\n/**/\n    573,\n/**/\n    572,\n/**/\n    571,\n/**/\n    570,\n/**/\n    569,\n/**/\n    568,\n/**/\n    567,\n/**/\n    566,\n/**/\n    565,\n/**/\n    564,\n/**/\n    563,\n/**/\n    562,\n/**/\n    561,\n/**/\n    560,\n/**/\n    559,\n/**/\n    558,\n/**/\n    557,\n/**/\n    556,\n/**/\n    555,\n/**/\n    554,\n/**/\n    553,\n/**/\n    552,\n/**/\n    551,\n/**/\n    550,\n/**/\n    549,\n/**/\n    548,\n/**/\n    547,\n/**/\n    546,\n/**/\n    545,\n/**/\n    544,\n/**/\n    543,\n/**/\n    542,\n/**/\n    541,\n/**/\n    540,\n/**/\n    539,\n/**/\n    538,\n/**/\n    537,\n/**/\n    536,\n/**/\n    535,\n/**/\n    534,\n/**/\n    533,\n/**/\n    532,\n/**/\n    531,\n/**/\n    530,\n/**/\n    529,\n/**/\n    528,\n/**/\n    527,\n/**/\n    526,\n/**/\n    525,\n/**/\n    524,\n/**/\n    523,\n/**/\n    522,\n/**/\n    521,\n/**/\n    520,\n/**/\n    519,\n/**/\n    518,\n/**/\n    517,\n/**/\n    516,\n/**/\n    515,\n/**/\n    514,\n/**/\n    513,\n/**/\n    512,\n/**/\n    511,\n/**/\n    510,\n/**/\n    509,\n/**/\n    508,\n/**/\n    507,\n/**/\n    506,\n/**/\n    505,\n/**/\n    504,\n/**/\n    503,\n/**/\n    502,\n/**/\n    501,\n/**/\n    500,\n/**/\n    499,\n/**/\n    498,\n/**/\n    497,\n/**/\n    496,\n/**/\n    495,\n/**/\n    494,\n/**/\n    493,\n/**/\n    492,\n/**/\n    491,\n/**/\n    490,\n/**/\n    489,\n/**/\n    488,\n/**/\n    487,\n/**/\n    486,\n/**/\n    485,\n/**/\n    484,\n/**/\n    483,\n/**/\n    482,\n/**/\n    481,\n/**/\n    480,\n/**/\n    479,\n/**/\n    478,\n/**/\n    477,\n/**/\n    476,\n/**/\n    475,\n/**/\n    474,\n/**/\n    473,\n/**/\n    472,\n/**/\n    471,\n/**/\n    470,\n/**/\n    469,\n/**/\n    468,\n/**/\n    467,\n/**/\n    466,\n/**/\n    465,\n/**/\n    464,\n/**/\n    463,\n/**/\n    462,\n/**/\n    461,\n/**/\n    460,\n/**/\n    459,\n/**/\n    458,\n/**/\n    457,\n/**/\n    456,\n/**/\n    455,\n/**/\n    454,\n/**/\n    453,\n/**/\n    452,\n/**/\n    451,\n/**/\n    450,\n/**/\n    449,\n/**/\n    448,\n/**/\n    447,\n/**/\n    446,\n/**/\n    445,\n/**/\n    444,\n/**/\n    443,\n/**/\n    442,\n/**/\n    441,\n/**/\n    440,\n/**/\n    439,\n/**/\n    438,\n/**/\n    437,\n/**/\n    436,\n/**/\n    435,\n/**/\n    434,\n/**/\n    433,\n/**/\n    432,\n/**/\n    431,\n/**/\n    430,\n/**/\n    429,\n/**/\n    428,\n/**/\n    427,\n/**/\n    426,\n/**/\n    425,\n/**/\n    424,\n/**/\n    423,\n/**/\n    422,\n/**/\n    421,\n/**/\n    420,\n/**/\n    419,\n/**/\n    418,\n/**/\n    417,\n/**/\n    416,\n/**/\n    415,\n/**/\n    414,\n/**/\n    413,\n/**/\n    412,\n/**/\n    411,\n/**/\n    410,\n/**/\n    409,\n/**/\n    408,\n/**/\n    407,\n/**/\n    406,\n/**/\n    405,\n/**/\n    404,\n/**/\n    403,\n/**/\n    402,\n/**/\n    401,\n/**/\n    400,\n/**/\n    399,\n/**/\n    398,\n/**/\n    397,\n/**/\n    396,\n/**/\n    395,\n/**/\n    394,\n/**/\n    393,\n/**/\n    392,\n/**/\n    391,\n/**/\n    390,\n/**/\n    389,\n/**/\n    388,\n/**/\n    387,\n/**/\n    386,\n/**/\n    385,\n/**/\n    384,\n/**/\n    383,\n/**/\n    382,\n/**/\n    381,\n/**/\n    380,\n/**/\n    379,\n/**/\n    378,\n/**/\n    377,\n/**/\n    376,\n/**/\n    375,\n/**/\n    374,\n/**/\n    373,\n/**/\n    372,\n/**/\n    371,\n/**/\n    370,\n/**/\n    369,\n/**/\n    368,\n/**/\n    367,\n/**/\n    366,\n/**/\n    365,\n/**/\n    364,\n/**/\n    363,\n/**/\n    362,\n/**/\n    361,\n/**/\n    360,\n/**/\n    359,\n/**/\n    358,\n/**/\n    357,\n/**/\n    356,\n/**/\n    355,\n/**/\n    354,\n/**/\n    353,\n/**/\n    352,\n/**/\n    351,\n/**/\n    350,\n/**/\n    349,\n/**/\n    348,\n/**/\n    347,\n/**/\n    346,\n/**/\n    345,\n/**/\n    344,\n/**/\n    343,\n/**/\n    342,\n/**/\n    341,\n/**/\n    340,\n/**/\n    339,\n/**/\n    338,\n/**/\n    337,\n/**/\n    336,\n/**/\n    335,\n/**/\n    334,\n/**/\n    333,\n/**/\n    332,\n/**/\n    331,\n/**/\n    330,\n/**/\n    329,\n/**/\n    328,\n/**/\n    327,\n/**/\n    326,\n/**/\n    325,\n/**/\n    324,\n/**/\n    323,\n/**/\n    322,\n/**/\n    321,\n/**/\n    320,\n/**/\n    319,\n/**/\n    318,\n/**/\n    317,\n/**/\n    316,\n/**/\n    315,\n/**/\n    314,\n/**/\n    313,\n/**/\n    312,\n/**/\n    311,\n/**/\n    310,\n/**/\n    309,\n/**/\n    308,\n/**/\n    307,\n/**/\n    306,\n/**/\n    305,\n/**/\n    304,\n/**/\n    303,\n/**/\n    302,\n/**/\n    301,\n/**/\n    300,\n/**/\n    299,\n/**/\n    298,\n/**/\n    297,\n/**/\n    296,\n/**/\n    295,\n/**/\n    294,\n/**/\n    293,\n/**/\n    292,\n/**/\n    291,\n/**/\n    290,\n/**/\n    289,\n/**/\n    288,\n/**/\n    287,\n/**/\n    286,\n/**/\n    285,\n/**/\n    284,\n/**/\n    283,\n/**/\n    282,\n/**/\n    281,\n/**/\n    280,\n/**/\n    279,\n/**/\n    278,\n/**/\n    277,\n/**/\n    276,\n/**/\n    275,\n/**/\n    274,\n/**/\n    273,\n/**/\n    272,\n/**/\n    271,\n/**/\n    270,\n/**/\n    269,\n/**/\n    268,\n/**/\n    267,\n/**/\n    266,\n/**/\n    265,\n/**/\n    264,\n/**/\n    263,\n/**/\n    262,\n/**/\n    261,\n/**/\n    260,\n/**/\n    259,\n/**/\n    258,\n/**/\n    257,\n/**/\n    256,\n/**/\n    255,\n/**/\n    254,\n/**/\n    253,\n/**/\n    252,\n/**/\n    251,\n/**/\n    250,\n/**/\n    249,\n/**/\n    248,\n/**/\n    247,\n/**/\n    246,\n/**/\n    245,\n/**/\n    244,\n/**/\n    243,\n/**/\n    242,\n/**/\n    241,\n/**/\n    240,\n/**/\n    239,\n/**/\n    238,\n/**/\n    237,\n/**/\n    236,\n/**/\n    235,\n/**/\n    234,\n/**/\n    233,\n/**/\n    232,\n/**/\n    231,\n/**/\n    230,\n/**/\n    229,\n/**/\n    228,\n/**/\n    227,\n/**/\n    226,\n/**/\n    225,\n/**/\n    224,\n/**/\n    223,\n/**/\n    222,\n/**/\n    221,\n/**/\n    220,\n/**/\n    219,\n/**/\n    218,\n/**/\n    217,\n/**/\n    216,\n/**/\n    215,\n/**/\n    214,\n/**/\n    213,\n/**/\n    212,\n/**/\n    211,\n/**/\n    210,\n/**/\n    209,\n/**/\n    208,\n/**/\n    207,\n/**/\n    206,\n/**/\n    205,\n/**/\n    204,\n/**/\n    203,\n/**/\n    202,\n/**/\n    201,\n/**/\n    200,\n/**/\n    199,\n/**/\n    198,\n/**/\n    197,\n/**/\n    196,\n/**/\n    195,\n/**/\n    194,\n/**/\n    193,\n/**/\n    192,\n/**/\n    191,\n/**/\n    190,\n/**/\n    189,\n/**/\n    188,\n/**/\n    187,\n/**/\n    186,\n/**/\n    185,\n/**/\n    184,\n/**/\n    183,\n/**/\n    182,\n/**/\n    181,\n/**/\n    180,\n/**/\n    179,\n/**/\n    178,\n/**/\n    177,\n/**/\n    176,\n/**/\n    175,\n/**/\n    174,\n/**/\n    173,\n/**/\n    172,\n/**/\n    171,\n/**/\n    170,\n/**/\n    169,\n/**/\n    168,\n/**/\n    167,\n/**/\n    166,\n/**/\n    165,\n/**/\n    164,\n/**/\n    163,\n/**/\n    162,\n/**/\n    161,\n/**/\n    160,\n/**/\n    159,\n/**/\n    158,\n/**/\n    157,\n/**/\n    156,\n/**/\n    155,\n/**/\n    154,\n/**/\n    153,\n/**/\n    152,\n/**/\n    151,\n/**/\n    150,\n/**/\n    149,\n/**/\n    148,\n/**/\n    147,\n/**/\n    146,\n/**/\n    145,\n/**/\n    144,\n/**/\n    143,\n/**/\n    142,\n/**/\n    141,\n/**/\n    140,\n/**/\n    139,\n/**/\n    138,\n/**/\n    137,\n/**/\n    136,\n/**/\n    135,\n/**/\n    134,\n/**/\n    133,\n/**/\n    132,\n/**/\n    131,\n/**/\n    130,\n/**/\n    129,\n/**/\n    128,\n/**/\n    127,\n/**/\n    126,\n/**/\n    125,\n/**/\n    124,\n/**/\n    123,\n/**/\n    122,\n/**/\n    121,\n/**/\n    120,\n/**/\n    119,\n/**/\n    118,\n/**/\n    117,\n/**/\n    116,\n/**/\n    115,\n/**/\n    114,\n/**/\n    113,\n/**/\n    112,\n/**/\n    111,\n/**/\n    110,\n/**/\n    109,\n/**/\n    108,\n/**/\n    107,\n/**/\n    106,\n/**/\n    105,\n/**/\n    104,\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\ti;\n\n    for (i = 0; included_patches[i] != 0; ++i)\n\tif (included_patches[i] == n)\n\t    return TRUE;\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = (int)vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    /* Find the length of the longest item, use that + 1 as the column\n     * width. */\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = (int)vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + (item_count % ncol ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    /* Print the list of patch numbers if there is at least one. */\n    /* Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\" */\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\t/* find last one */\n\tfor (i = 0; included_patches[i] != 0; ++i)\n\t    ;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    /* Print the list of extra patch descriptions if there is at least one. */\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#ifdef FEAT_HUGE\n    msg_puts(_(\"\\nHuge version \"));\n#else\n# ifdef FEAT_BIG\n    msg_puts(_(\"\\nBig version \"));\n# else\n#  ifdef FEAT_NORMAL\n    msg_puts(_(\"\\nNormal version \"));\n#  else\n#   ifdef FEAT_SMALL\n    msg_puts(_(\"\\nSmall version \"));\n#   else\n    msg_puts(_(\"\\nTiny version \"));\n#   endif\n#  endif\n# endif\n#endif\n#ifndef FEAT_GUI\n    msg_puts(_(\"without GUI.\"));\n#else\n# ifdef FEAT_GUI_GTK\n#  ifdef USE_GTK3\n    msg_puts(_(\"with GTK3 GUI.\"));\n#  else\n#   ifdef FEAT_GUI_GNOME\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n#   else\n     msg_puts(_(\"with GTK2 GUI.\"));\n#   endif\n# endif\n# else\n#  ifdef FEAT_GUI_MOTIF\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#  else\n#   ifdef FEAT_GUI_ATHENA\n#    ifdef FEAT_GUI_NEXTAW\n    msg_puts(_(\"with X11-neXtaw GUI.\"));\n#    else\n    msg_puts(_(\"with X11-Athena GUI.\"));\n#    endif\n#   else\n#     ifdef FEAT_GUI_PHOTON\n    msg_puts(_(\"with Photon GUI.\"));\n#     else\n#      if defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#      else\n#\tif defined(TARGET_API_MAC_CARBON) && TARGET_API_MAC_CARBON\n    msg_puts(_(\"with Carbon GUI.\"));\n#\telse\n#\t if defined(TARGET_API_MAC_OSX) && TARGET_API_MAC_OSX\n    msg_puts(_(\"with Cocoa GUI.\"));\n#\t else\n#\t endif\n#\tendif\n#      endif\n#    endif\n#   endif\n#  endif\n# endif\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    void\nintro_message(\n    int\t\tcolon)\t\t/* TRUE for \":intro\" */\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version8<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    /* blanklines = screen height - # message lines */\n    blanklines = (int)Rows - ((sizeof(lines) / sizeof(char *)) - 1);\n    if (!p_cp)\n\tblanklines += 4;  /* add 4 for not showing \"Vi compatible\" message */\n\n    /* Don't overwrite a statusline.  Depends on 'cmdheight'. */\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    /* Show the sponsor and register message one out of four times, the Uganda\n     * message two out of four times. */\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    /* start displaying the message lines after half of the blank lines */\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)(sizeof(lines) / sizeof(char *)); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    /* Make the wait-return message appear just below the text. */\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    /* Center the message horizontally. */\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    /* Check for 9.9x or 9.9xx, alpha/beta version */\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    /* Split up in parts to highlight <> items differently. */\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    /* Add the version number to the version line. */\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read a list of people who contributed.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\nstatic void cmd_with_count(char *cmd, char_u *bufp, size_t bufsize, long Prenum);\nstatic void win_init(win_T *newp, win_T *oldp, int flags);\nstatic void win_init_some(win_T *newp, win_T *oldp);\nstatic void frame_comp_pos(frame_T *topfrp, int *row, int *col);\nstatic void frame_setheight(frame_T *curfrp, int height);\nstatic void frame_setwidth(frame_T *curfrp, int width);\nstatic void win_exchange(long);\nstatic void win_rotate(int, int);\nstatic void win_totop(int size, int flags);\nstatic void win_equal_rec(win_T *next_curwin, int current, frame_T *topfr, int dir, int col, int row, int width, int height);\nstatic win_T *win_free_mem(win_T *win, int *dirp, tabpage_T *tp);\nstatic frame_T *win_altframe(win_T *win, tabpage_T *tp);\nstatic tabpage_T *alt_tabpage(void);\nstatic win_T *frame2win(frame_T *frp);\nstatic int frame_has_win(frame_T *frp, win_T *wp);\nstatic void frame_new_height(frame_T *topfrp, int height, int topfirst, int wfh);\nstatic int frame_fixed_height(frame_T *frp);\nstatic int frame_fixed_width(frame_T *frp);\nstatic void frame_add_statusline(frame_T *frp);\nstatic void frame_new_width(frame_T *topfrp, int width, int leftfirst, int wfw);\nstatic void frame_add_vsep(frame_T *frp);\nstatic int frame_minwidth(frame_T *topfrp, win_T *next_curwin);\nstatic void frame_fix_width(win_T *wp);\nstatic int win_alloc_firstwin(win_T *oldwin);\nstatic void new_frame(win_T *wp);\nstatic tabpage_T *alloc_tabpage(void);\nstatic int leave_tabpage(buf_T *new_curbuf, int trigger_leave_autocmds);\nstatic void enter_tabpage(tabpage_T *tp, buf_T *old_curbuf, int trigger_enter_autocmds, int trigger_leave_autocmds);\nstatic void frame_fix_height(win_T *wp);\nstatic int frame_minheight(frame_T *topfrp, win_T *next_curwin);\nstatic int may_open_tabpage(void);\nstatic void win_enter_ext(win_T *wp, int undo_sync, int no_curwin, int trigger_new_autocmds, int trigger_enter_autocmds, int trigger_leave_autocmds);\nstatic void win_free(win_T *wp, tabpage_T *tp);\nstatic int win_unlisted(win_T *wp);\nstatic void win_append(win_T *after, win_T *wp);\nstatic void frame_append(frame_T *after, frame_T *frp);\nstatic void frame_insert(frame_T *before, frame_T *frp);\nstatic void frame_remove(frame_T *frp);\nstatic void win_goto_ver(int up, long count);\nstatic void win_goto_hor(int left, long count);\nstatic void frame_add_height(frame_T *frp, int n);\nstatic void last_status_rec(frame_T *fr, int statusline);\n\nstatic void make_snapshot_rec(frame_T *fr, frame_T **frp);\nstatic void clear_snapshot(tabpage_T *tp, int idx);\nstatic void clear_snapshot_rec(frame_T *fr);\nstatic int check_snapshot_rec(frame_T *sn, frame_T *fr);\nstatic win_T *restore_snapshot_rec(frame_T *sn, frame_T *fr);\n\nstatic int frame_check_height(frame_T *topfrp, int height);\nstatic int frame_check_width(frame_T *topfrp, int width);\n\nstatic win_T *win_alloc(win_T *after, int hidden);\n\n#define NOWIN\t\t(win_T *)-1\t/* non-existing window */\n\n#define ROWS_AVAIL (Rows - p_ch - tabline_height())\n\nstatic char *m_onlyone = N_(\"Already only one window\");\n\n// When non-zero splitting a window is forbidden.  Used to avoid that nasty\n// autocommands mess up the window structure.\nstatic int split_disallowed = 0;\n\n// #define WIN_DEBUG\n#ifdef WIN_DEBUG\n/*\n * Call this method to log the current window layout.\n */\n    static void\nlog_frame_layout(frame_T *frame)\n{\n    ch_log(NULL, \"layout %s, wi: %d, he: %d, wwi: %d, whe: %d, id: %d\",\n\t    frame->fr_layout == FR_LEAF ? \"LEAF\"\n\t\t\t\t  : frame->fr_layout == FR_ROW ? \"ROW\" : \"COL\",\n\t    frame->fr_width,\n\t    frame->fr_height,\n\t    frame->fr_win == NULL ? -1 : frame->fr_win->w_width,\n\t    frame->fr_win == NULL ? -1 : frame->fr_win->w_height,\n\t    frame->fr_win == NULL ? -1 : frame->fr_win->w_id);\n    if (frame->fr_child != NULL)\n    {\n\tch_log(NULL, \"children\");\n\tlog_frame_layout(frame->fr_child);\n\tif (frame->fr_next != NULL)\n\t    ch_log(NULL, \"END of children\");\n    }\n    if (frame->fr_next != NULL)\n\tlog_frame_layout(frame->fr_next);\n}\n#endif\n\n/*\n * All CTRL-W window commands are handled here, called from normal_cmd().\n */\n    void\ndo_window(\n    int\t\tnchar,\n    long\tPrenum,\n    int\t\txchar)\t    /* extra char from \":wincmd gx\" or NUL */\n{\n    long\tPrenum1;\n    win_T\t*wp;\n#if defined(FEAT_SEARCHPATH) || defined(FEAT_FIND_ID)\n    char_u\t*ptr;\n    linenr_T    lnum = -1;\n#endif\n#ifdef FEAT_FIND_ID\n    int\t\ttype = FIND_DEFINE;\n    int\t\tlen;\n#endif\n    char_u\tcbuf[40];\n\n    if (ERROR_IF_POPUP_WINDOW)\n\treturn;\n\n#ifdef FEAT_CMDWIN\n# define CHECK_CMDWIN \\\n    do { \\\n\tif (cmdwin_type != 0) \\\n\t{ \\\n\t    emsg(_(e_cmdwin)); \\\n\t    return; \\\n\t} \\\n    } while (0)\n#else\n# define CHECK_CMDWIN do { /**/ } while (0)\n#endif\n\n    Prenum1 = Prenum == 0 ? 1 : Prenum;\n\n    switch (nchar)\n    {\n/* split current window in two parts, horizontally */\n    case 'S':\n    case Ctrl_S:\n    case 's':\n\t\tCHECK_CMDWIN;\n\t\treset_VIsual_and_resel();\t/* stop Visual mode */\n#ifdef FEAT_QUICKFIX\n\t\t/* When splitting the quickfix window open a new buffer in it,\n\t\t * don't replicate the quickfix buffer. */\n\t\tif (bt_quickfix(curbuf))\n\t\t    goto newwindow;\n#endif\n#ifdef FEAT_GUI\n\t\tneed_mouse_correct = TRUE;\n#endif\n\t\t(void)win_split((int)Prenum, 0);\n\t\tbreak;\n\n/* split current window in two parts, vertically */\n    case Ctrl_V:\n    case 'v':\n\t\tCHECK_CMDWIN;\n\t\treset_VIsual_and_resel();\t/* stop Visual mode */\n#ifdef FEAT_QUICKFIX\n\t\t/* When splitting the quickfix window open a new buffer in it,\n\t\t * don't replicate the quickfix buffer. */\n\t\tif (bt_quickfix(curbuf))\n\t\t    goto newwindow;\n#endif\n#ifdef FEAT_GUI\n\t\tneed_mouse_correct = TRUE;\n#endif\n\t\t(void)win_split((int)Prenum, WSP_VERT);\n\t\tbreak;\n\n/* split current window and edit alternate file */\n    case Ctrl_HAT:\n    case '^':\n\t\tCHECK_CMDWIN;\n\t\treset_VIsual_and_resel();\t/* stop Visual mode */\n\n\t\tif (buflist_findnr(Prenum == 0\n\t\t\t\t\t? curwin->w_alt_fnum : Prenum) == NULL)\n\t\t{\n\t\t    if (Prenum == 0)\n\t\t\temsg(_(e_noalt));\n\t\t    else\n\t\t\tsemsg(_(\"E92: Buffer %ld not found\"), Prenum);\n\t\t    break;\n\t\t}\n\n\t\tif (!curbuf_locked() && win_split(0, 0) == OK)\n\t\t    (void)buflist_getfile(\n\t\t\t    Prenum == 0 ? curwin->w_alt_fnum : Prenum,\n\t\t\t    (linenr_T)0, GETF_ALT, FALSE);\n\t\tbreak;\n\n/* open new window */\n    case Ctrl_N:\n    case 'n':\n\t\tCHECK_CMDWIN;\n\t\treset_VIsual_and_resel();\t/* stop Visual mode */\n#ifdef FEAT_QUICKFIX\nnewwindow:\n#endif\n\t\tif (Prenum)\n\t\t    /* window height */\n\t\t    vim_snprintf((char *)cbuf, sizeof(cbuf) - 5, \"%ld\", Prenum);\n\t\telse\n\t\t    cbuf[0] = NUL;\n#if defined(FEAT_QUICKFIX)\n\t\tif (nchar == 'v' || nchar == Ctrl_V)\n\t\t    STRCAT(cbuf, \"v\");\n#endif\n\t\tSTRCAT(cbuf, \"new\");\n\t\tdo_cmdline_cmd(cbuf);\n\t\tbreak;\n\n/* quit current window */\n    case Ctrl_Q:\n    case 'q':\n\t\treset_VIsual_and_resel();\t/* stop Visual mode */\n\t\tcmd_with_count(\"quit\", cbuf, sizeof(cbuf), Prenum);\n\t\tdo_cmdline_cmd(cbuf);\n\t\tbreak;\n\n/* close current window */\n    case Ctrl_C:\n    case 'c':\n\t\treset_VIsual_and_resel();\t/* stop Visual mode */\n\t\tcmd_with_count(\"close\", cbuf, sizeof(cbuf), Prenum);\n\t\tdo_cmdline_cmd(cbuf);\n\t\tbreak;\n\n#if defined(FEAT_QUICKFIX)\n/* close preview window */\n    case Ctrl_Z:\n    case 'z':\n\t\tCHECK_CMDWIN;\n\t\treset_VIsual_and_resel();\t/* stop Visual mode */\n\t\tdo_cmdline_cmd((char_u *)\"pclose\");\n\t\tbreak;\n\n/* cursor to preview window */\n    case 'P':\n\t\tFOR_ALL_WINDOWS(wp)\n\t\t    if (wp->w_p_pvw)\n\t\t\tbreak;\n\t\tif (wp == NULL)\n\t\t    emsg(_(\"E441: There is no preview window\"));\n\t\telse\n\t\t    win_goto(wp);\n\t\tbreak;\n#endif\n\n/* close all but current window */\n    case Ctrl_O:\n    case 'o':\n\t\tCHECK_CMDWIN;\n\t\treset_VIsual_and_resel();\t/* stop Visual mode */\n\t\tcmd_with_count(\"only\", cbuf, sizeof(cbuf), Prenum);\n\t\tdo_cmdline_cmd(cbuf);\n\t\tbreak;\n\n/* cursor to next window with wrap around */\n    case Ctrl_W:\n    case 'w':\n/* cursor to previous window with wrap around */\n    case 'W':\n\t\tCHECK_CMDWIN;\n\t\tif (ONE_WINDOW && Prenum != 1)\t/* just one window */\n\t\t    beep_flush();\n\t\telse\n\t\t{\n\t\t    if (Prenum)\t\t\t/* go to specified window */\n\t\t    {\n\t\t\tfor (wp = firstwin; --Prenum > 0; )\n\t\t\t{\n\t\t\t    if (wp->w_next == NULL)\n\t\t\t\tbreak;\n\t\t\t    else\n\t\t\t\twp = wp->w_next;\n\t\t\t}\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tif (nchar == 'W')\t    /* go to previous window */\n\t\t\t{\n\t\t\t    wp = curwin->w_prev;\n\t\t\t    if (wp == NULL)\n\t\t\t\twp = lastwin;\t    /* wrap around */\n\t\t\t}\n\t\t\telse\t\t\t    /* go to next window */\n\t\t\t{\n\t\t\t    wp = curwin->w_next;\n\t\t\t    if (wp == NULL)\n\t\t\t\twp = firstwin;\t    /* wrap around */\n\t\t\t}\n\t\t    }\n\t\t    win_goto(wp);\n\t\t}\n\t\tbreak;\n\n/* cursor to window below */\n    case 'j':\n    case K_DOWN:\n    case Ctrl_J:\n\t\tCHECK_CMDWIN;\n\t\twin_goto_ver(FALSE, Prenum1);\n\t\tbreak;\n\n/* cursor to window above */\n    case 'k':\n    case K_UP:\n    case Ctrl_K:\n\t\tCHECK_CMDWIN;\n\t\twin_goto_ver(TRUE, Prenum1);\n\t\tbreak;\n\n/* cursor to left window */\n    case 'h':\n    case K_LEFT:\n    case Ctrl_H:\n    case K_BS:\n\t\tCHECK_CMDWIN;\n\t\twin_goto_hor(TRUE, Prenum1);\n\t\tbreak;\n\n/* cursor to right window */\n    case 'l':\n    case K_RIGHT:\n    case Ctrl_L:\n\t\tCHECK_CMDWIN;\n\t\twin_goto_hor(FALSE, Prenum1);\n\t\tbreak;\n\n/* move window to new tab page */\n    case 'T':\n\t\tif (one_window())\n\t\t    msg(_(m_onlyone));\n\t\telse\n\t\t{\n\t\t    tabpage_T\t*oldtab = curtab;\n\t\t    tabpage_T\t*newtab;\n\n\t\t    /* First create a new tab with the window, then go back to\n\t\t     * the old tab and close the window there. */\n\t\t    wp = curwin;\n\t\t    if (win_new_tabpage((int)Prenum) == OK\n\t\t\t\t\t\t     && valid_tabpage(oldtab))\n\t\t    {\n\t\t\tnewtab = curtab;\n\t\t\tgoto_tabpage_tp(oldtab, TRUE, TRUE);\n\t\t\tif (curwin == wp)\n\t\t\t    win_close(curwin, FALSE);\n\t\t\tif (valid_tabpage(newtab))\n\t\t\t    goto_tabpage_tp(newtab, TRUE, TRUE);\n\t\t    }\n\t\t}\n\t\tbreak;\n\n/* cursor to top-left window */\n    case 't':\n    case Ctrl_T:\n\t\twin_goto(firstwin);\n\t\tbreak;\n\n/* cursor to bottom-right window */\n    case 'b':\n    case Ctrl_B:\n\t\twin_goto(lastwin);\n\t\tbreak;\n\n/* cursor to last accessed (previous) window */\n    case 'p':\n    case Ctrl_P:\n\t\tif (!win_valid(prevwin))\n\t\t    beep_flush();\n\t\telse\n\t\t    win_goto(prevwin);\n\t\tbreak;\n\n/* exchange current and next window */\n    case 'x':\n    case Ctrl_X:\n\t\tCHECK_CMDWIN;\n\t\twin_exchange(Prenum);\n\t\tbreak;\n\n/* rotate windows downwards */\n    case Ctrl_R:\n    case 'r':\n\t\tCHECK_CMDWIN;\n\t\treset_VIsual_and_resel();\t/* stop Visual mode */\n\t\twin_rotate(FALSE, (int)Prenum1);    /* downwards */\n\t\tbreak;\n\n/* rotate windows upwards */\n    case 'R':\n\t\tCHECK_CMDWIN;\n\t\treset_VIsual_and_resel();\t/* stop Visual mode */\n\t\twin_rotate(TRUE, (int)Prenum1);\t    /* upwards */\n\t\tbreak;\n\n/* move window to the very top/bottom/left/right */\n    case 'K':\n    case 'J':\n    case 'H':\n    case 'L':\n\t\tCHECK_CMDWIN;\n\t\twin_totop((int)Prenum,\n\t\t\t((nchar == 'H' || nchar == 'L') ? WSP_VERT : 0)\n\t\t\t| ((nchar == 'H' || nchar == 'K') ? WSP_TOP : WSP_BOT));\n\t\tbreak;\n\n/* make all windows the same height */\n    case '=':\n#ifdef FEAT_GUI\n\t\tneed_mouse_correct = TRUE;\n#endif\n\t\twin_equal(NULL, FALSE, 'b');\n\t\tbreak;\n\n/* increase current window height */\n    case '+':\n#ifdef FEAT_GUI\n\t\tneed_mouse_correct = TRUE;\n#endif\n\t\twin_setheight(curwin->w_height + (int)Prenum1);\n\t\tbreak;\n\n/* decrease current window height */\n    case '-':\n#ifdef FEAT_GUI\n\t\tneed_mouse_correct = TRUE;\n#endif\n\t\twin_setheight(curwin->w_height - (int)Prenum1);\n\t\tbreak;\n\n/* set current window height */\n    case Ctrl__:\n    case '_':\n#ifdef FEAT_GUI\n\t\tneed_mouse_correct = TRUE;\n#endif\n\t\twin_setheight(Prenum ? (int)Prenum : 9999);\n\t\tbreak;\n\n/* increase current window width */\n    case '>':\n#ifdef FEAT_GUI\n\t\tneed_mouse_correct = TRUE;\n#endif\n\t\twin_setwidth(curwin->w_width + (int)Prenum1);\n\t\tbreak;\n\n/* decrease current window width */\n    case '<':\n#ifdef FEAT_GUI\n\t\tneed_mouse_correct = TRUE;\n#endif\n\t\twin_setwidth(curwin->w_width - (int)Prenum1);\n\t\tbreak;\n\n/* set current window width */\n    case '|':\n#ifdef FEAT_GUI\n\t\tneed_mouse_correct = TRUE;\n#endif\n\t\twin_setwidth(Prenum != 0 ? (int)Prenum : 9999);\n\t\tbreak;\n\n/* jump to tag and split window if tag exists (in preview window) */\n#if defined(FEAT_QUICKFIX)\n    case '}':\n\t\tCHECK_CMDWIN;\n\t\tif (Prenum)\n\t\t    g_do_tagpreview = Prenum;\n\t\telse\n\t\t    g_do_tagpreview = p_pvh;\n#endif\n\t\t/* FALLTHROUGH */\n    case ']':\n    case Ctrl_RSB:\n\t\tCHECK_CMDWIN;\n\t\t/* keep Visual mode, can select words to use as a tag */\n\t\tif (Prenum)\n\t\t    postponed_split = Prenum;\n\t\telse\n\t\t    postponed_split = -1;\n#ifdef FEAT_QUICKFIX\n\t\tif (nchar != '}')\n\t\t    g_do_tagpreview = 0;\n#endif\n\n\t\t/* Execute the command right here, required when \"wincmd ]\"\n\t\t * was used in a function. */\n\t\tdo_nv_ident(Ctrl_RSB, NUL);\n\t\tbreak;\n\n#ifdef FEAT_SEARCHPATH\n/* edit file name under cursor in a new window */\n    case 'f':\n    case 'F':\n    case Ctrl_F:\nwingotofile:\n\t\tCHECK_CMDWIN;\n\n\t\tptr = grab_file_name(Prenum1, &lnum);\n\t\tif (ptr != NULL)\n\t\t{\n\t\t    tabpage_T\t*oldtab = curtab;\n\t\t    win_T\t*oldwin = curwin;\n# ifdef FEAT_GUI\n\t\t    need_mouse_correct = TRUE;\n# endif\n\t\t    setpcmark();\n\t\t    if (win_split(0, 0) == OK)\n\t\t    {\n\t\t\tRESET_BINDING(curwin);\n\t\t\tif (do_ecmd(0, ptr, NULL, NULL, ECMD_LASTL,\n\t\t\t\t\t\t   ECMD_HIDE, NULL) == FAIL)\n\t\t\t{\n\t\t\t    /* Failed to open the file, close the window\n\t\t\t     * opened for it. */\n\t\t\t    win_close(curwin, FALSE);\n\t\t\t    goto_tabpage_win(oldtab, oldwin);\n\t\t\t}\n\t\t\telse if (nchar == 'F' && lnum >= 0)\n\t\t\t{\n\t\t\t    curwin->w_cursor.lnum = lnum;\n\t\t\t    check_cursor_lnum();\n\t\t\t    beginline(BL_SOL | BL_FIX);\n\t\t\t}\n\t\t    }\n\t\t    vim_free(ptr);\n\t\t}\n\t\tbreak;\n#endif\n\n#ifdef FEAT_FIND_ID\n/* Go to the first occurrence of the identifier under cursor along path in a\n * new window -- webb\n */\n    case 'i':\t\t\t    /* Go to any match */\n    case Ctrl_I:\n\t\ttype = FIND_ANY;\n\t\t/* FALLTHROUGH */\n    case 'd':\t\t\t    /* Go to definition, using 'define' */\n    case Ctrl_D:\n\t\tCHECK_CMDWIN;\n\t\tif ((len = find_ident_under_cursor(&ptr, FIND_IDENT)) == 0)\n\t\t    break;\n\t\tfind_pattern_in_path(ptr, 0, len, TRUE,\n\t\t\tPrenum == 0 ? TRUE : FALSE, type,\n\t\t\tPrenum1, ACTION_SPLIT, (linenr_T)1, (linenr_T)MAXLNUM);\n\t\tcurwin->w_set_curswant = TRUE;\n\t\tbreak;\n#endif\n\n/* Quickfix window only: view the result under the cursor in a new split. */\n#if defined(FEAT_QUICKFIX)\n    case K_KENTER:\n    case CAR:\n\t\tif (bt_quickfix(curbuf))\n\t\t    qf_view_result(TRUE);\n\t\tbreak;\n#endif\n\n/* CTRL-W g  extended commands */\n    case 'g':\n    case Ctrl_G:\n\t\tCHECK_CMDWIN;\n#ifdef USE_ON_FLY_SCROLL\n\t\tdont_scroll = TRUE;\t\t/* disallow scrolling here */\n#endif\n\t\t++no_mapping;\n\t\t++allow_keys;   /* no mapping for xchar, but allow key codes */\n\t\tif (xchar == NUL)\n\t\t    xchar = plain_vgetc();\n\t\tLANGMAP_ADJUST(xchar, TRUE);\n\t\t--no_mapping;\n\t\t--allow_keys;\n#ifdef FEAT_CMDL_INFO\n\t\t(void)add_to_showcmd(xchar);\n#endif\n\t\tswitch (xchar)\n\t\t{\n#if defined(FEAT_QUICKFIX)\n\t\t    case '}':\n\t\t\txchar = Ctrl_RSB;\n\t\t\tif (Prenum)\n\t\t\t    g_do_tagpreview = Prenum;\n\t\t\telse\n\t\t\t    g_do_tagpreview = p_pvh;\n#endif\n\t\t\t/* FALLTHROUGH */\n\t\t    case ']':\n\t\t    case Ctrl_RSB:\n\t\t\t/* keep Visual mode, can select words to use as a tag */\n\t\t\tif (Prenum)\n\t\t\t    postponed_split = Prenum;\n\t\t\telse\n\t\t\t    postponed_split = -1;\n\n\t\t\t/* Execute the command right here, required when\n\t\t\t * \"wincmd g}\" was used in a function. */\n\t\t\tdo_nv_ident('g', xchar);\n\t\t\tbreak;\n\n#ifdef FEAT_SEARCHPATH\n\t\t    case 'f':\t    /* CTRL-W gf: \"gf\" in a new tab page */\n\t\t    case 'F':\t    /* CTRL-W gF: \"gF\" in a new tab page */\n\t\t\tcmdmod.tab = tabpage_index(curtab) + 1;\n\t\t\tnchar = xchar;\n\t\t\tgoto wingotofile;\n#endif\n\t\t    case 't':\t    // CTRL-W gt: go to next tab page\n\t\t\tgoto_tabpage((int)Prenum);\n\t\t\tbreak;\n\n\t\t    case 'T':\t    // CTRL-W gT: go to previous tab page\n\t\t\tgoto_tabpage(-(int)Prenum1);\n\t\t\tbreak;\n\n\t\t    default:\n\t\t\tbeep_flush();\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n    default:\tbeep_flush();\n\t\tbreak;\n    }\n}\n\n/*\n * Figure out the address type for \":wincmd\".\n */\n    void\nget_wincmd_addr_type(char_u *arg, exarg_T *eap)\n{\n    switch (*arg)\n    {\n    case 'S':\n    case Ctrl_S:\n    case 's':\n    case Ctrl_N:\n    case 'n':\n    case 'j':\n    case Ctrl_J:\n    case 'k':\n    case Ctrl_K:\n    case 'T':\n    case Ctrl_R:\n    case 'r':\n    case 'R':\n    case 'K':\n    case 'J':\n    case '+':\n    case '-':\n    case Ctrl__:\n    case '_':\n    case '|':\n    case ']':\n    case Ctrl_RSB:\n    case 'g':\n    case Ctrl_G:\n    case Ctrl_V:\n    case 'v':\n    case 'h':\n    case Ctrl_H:\n    case 'l':\n    case Ctrl_L:\n    case 'H':\n    case 'L':\n    case '>':\n    case '<':\n#if defined(FEAT_QUICKFIX)\n    case '}':\n#endif\n#ifdef FEAT_SEARCHPATH\n    case 'f':\n    case 'F':\n    case Ctrl_F:\n#endif\n#ifdef FEAT_FIND_ID\n    case 'i':\n    case Ctrl_I:\n    case 'd':\n    case Ctrl_D:\n#endif\n\t\t// window size or any count\n\t\teap->addr_type = ADDR_OTHER;\n\t\tbreak;\n\n    case Ctrl_HAT:\n    case '^':\n\t\t// buffer number\n\t\teap->addr_type = ADDR_BUFFERS;\n\t\tbreak;\n\n    case Ctrl_Q:\n    case 'q':\n    case Ctrl_C:\n    case 'c':\n    case Ctrl_O:\n    case 'o':\n    case Ctrl_W:\n    case 'w':\n    case 'W':\n    case 'x':\n    case Ctrl_X:\n\t\t// window number\n\t\teap->addr_type = ADDR_WINDOWS;\n\t\tbreak;\n\n#if defined(FEAT_QUICKFIX)\n    case Ctrl_Z:\n    case 'z':\n    case 'P':\n#endif\n    case 't':\n    case Ctrl_T:\n    case 'b':\n    case Ctrl_B:\n    case 'p':\n    case Ctrl_P:\n    case '=':\n    case CAR:\n\t\t// no count\n\t\teap->addr_type = ADDR_NONE;\n\t\tbreak;\n    }\n}\n\n    static void\ncmd_with_count(\n    char\t*cmd,\n    char_u\t*bufp,\n    size_t\tbufsize,\n    long\tPrenum)\n{\n    size_t\tlen = STRLEN(cmd);\n\n    STRCPY(bufp, cmd);\n    if (Prenum > 0)\n\tvim_snprintf((char *)bufp + len, bufsize - len, \"%ld\", Prenum);\n}\n\n/*\n * If \"split_disallowed\" is set given an error and return FAIL.\n * Otherwise return OK.\n */\n    static int\ncheck_split_disallowed()\n{\n    if (split_disallowed > 0)\n    {\n\temsg(_(\"E242: Can't split a window while closing another\"));\n\treturn FAIL;\n    }\n    return OK;\n}\n\n/*\n * split the current window, implements CTRL-W s and :split\n *\n * \"size\" is the height or width for the new window, 0 to use half of current\n * height or width.\n *\n * \"flags\":\n * WSP_ROOM: require enough room for new window\n * WSP_VERT: vertical split.\n * WSP_TOP:  open window at the top-left of the shell (help window).\n * WSP_BOT:  open window at the bottom-right of the shell (quickfix window).\n * WSP_HELP: creating the help window, keep layout snapshot\n *\n * return FAIL for failure, OK otherwise\n */\n    int\nwin_split(int size, int flags)\n{\n    if (ERROR_IF_POPUP_WINDOW)\n\treturn FAIL;\n\n    /* When the \":tab\" modifier was used open a new tab page instead. */\n    if (may_open_tabpage() == OK)\n\treturn OK;\n\n    /* Add flags from \":vertical\", \":topleft\" and \":botright\". */\n    flags |= cmdmod.split;\n    if ((flags & WSP_TOP) && (flags & WSP_BOT))\n    {\n\temsg(_(\"E442: Can't split topleft and botright at the same time\"));\n\treturn FAIL;\n    }\n    if (check_split_disallowed() == FAIL)\n\treturn FAIL;\n\n    /* When creating the help window make a snapshot of the window layout.\n     * Otherwise clear the snapshot, it's now invalid. */\n    if (flags & WSP_HELP)\n\tmake_snapshot(SNAP_HELP_IDX);\n    else\n\tclear_snapshot(curtab, SNAP_HELP_IDX);\n\n    return win_split_ins(size, flags, NULL, 0);\n}\n\n/*\n * When \"new_wp\" is NULL: split the current window in two.\n * When \"new_wp\" is not NULL: insert this window at the far\n * top/left/right/bottom.\n * return FAIL for failure, OK otherwise\n */\n    int\nwin_split_ins(\n    int\t\tsize,\n    int\t\tflags,\n    win_T\t*new_wp,\n    int\t\tdir)\n{\n    win_T\t*wp = new_wp;\n    win_T\t*oldwin;\n    int\t\tnew_size = size;\n    int\t\ti;\n    int\t\tneed_status = 0;\n    int\t\tdo_equal = FALSE;\n    int\t\tneeded;\n    int\t\tavailable;\n    int\t\toldwin_height = 0;\n    int\t\tlayout;\n    frame_T\t*frp, *curfrp, *frp2, *prevfrp;\n    int\t\tbefore;\n    int\t\tminheight;\n    int\t\twmh1;\n    int\t\tdid_set_fraction = FALSE;\n\n    if (flags & WSP_TOP)\n\toldwin = firstwin;\n    else if (flags & WSP_BOT)\n\toldwin = lastwin;\n    else\n\toldwin = curwin;\n\n    /* add a status line when p_ls == 1 and splitting the first window */\n    if (ONE_WINDOW && p_ls == 1 && oldwin->w_status_height == 0)\n    {\n\tif (VISIBLE_HEIGHT(oldwin) <= p_wmh && new_wp == NULL)\n\t{\n\t    emsg(_(e_noroom));\n\t    return FAIL;\n\t}\n\tneed_status = STATUS_HEIGHT;\n    }\n\n#ifdef FEAT_GUI\n    /* May be needed for the scrollbars that are going to change. */\n    if (gui.in_use)\n\tout_flush();\n#endif\n\n    if (flags & WSP_VERT)\n    {\n\tint\twmw1;\n\tint\tminwidth;\n\n\tlayout = FR_ROW;\n\n\t/*\n\t * Check if we are able to split the current window and compute its\n\t * width.\n\t */\n\t/* Current window requires at least 1 space. */\n\twmw1 = (p_wmw == 0 ? 1 : p_wmw);\n\tneeded = wmw1 + 1;\n\tif (flags & WSP_ROOM)\n\t    needed += p_wiw - wmw1;\n\tif (flags & (WSP_BOT | WSP_TOP))\n\t{\n\t    minwidth = frame_minwidth(topframe, NOWIN);\n\t    available = topframe->fr_width;\n\t    needed += minwidth;\n\t}\n\telse if (p_ea)\n\t{\n\t    minwidth = frame_minwidth(oldwin->w_frame, NOWIN);\n\t    prevfrp = oldwin->w_frame;\n\t    for (frp = oldwin->w_frame->fr_parent; frp != NULL;\n\t\t\t\t\t\t\tfrp = frp->fr_parent)\n\t    {\n\t\tif (frp->fr_layout == FR_ROW)\n\t\t    FOR_ALL_FRAMES(frp2, frp->fr_child)\n\t\t\tif (frp2 != prevfrp)\n\t\t\t    minwidth += frame_minwidth(frp2, NOWIN);\n\t\tprevfrp = frp;\n\t    }\n\t    available = topframe->fr_width;\n\t    needed += minwidth;\n\t}\n\telse\n\t{\n\t    minwidth = frame_minwidth(oldwin->w_frame, NOWIN);\n\t    available = oldwin->w_frame->fr_width;\n\t    needed += minwidth;\n\t}\n\tif (available < needed && new_wp == NULL)\n\t{\n\t    emsg(_(e_noroom));\n\t    return FAIL;\n\t}\n\tif (new_size == 0)\n\t    new_size = oldwin->w_width / 2;\n\tif (new_size > available - minwidth - 1)\n\t    new_size = available - minwidth - 1;\n\tif (new_size < wmw1)\n\t    new_size = wmw1;\n\n\t/* if it doesn't fit in the current window, need win_equal() */\n\tif (oldwin->w_width - new_size - 1 < p_wmw)\n\t    do_equal = TRUE;\n\n\t/* We don't like to take lines for the new window from a\n\t * 'winfixwidth' window.  Take them from a window to the left or right\n\t * instead, if possible. Add one for the separator. */\n\tif (oldwin->w_p_wfw)\n\t    win_setwidth_win(oldwin->w_width + new_size + 1, oldwin);\n\n\t/* Only make all windows the same width if one of them (except oldwin)\n\t * is wider than one of the split windows. */\n\tif (!do_equal && p_ea && size == 0 && *p_ead != 'v'\n\t\t\t\t\t && oldwin->w_frame->fr_parent != NULL)\n\t{\n\t    frp = oldwin->w_frame->fr_parent->fr_child;\n\t    while (frp != NULL)\n\t    {\n\t\tif (frp->fr_win != oldwin && frp->fr_win != NULL\n\t\t\t&& (frp->fr_win->w_width > new_size\n\t\t\t    || frp->fr_win->w_width > oldwin->w_width\n\t\t\t\t\t\t\t      - new_size - 1))\n\t\t{\n\t\t    do_equal = TRUE;\n\t\t    break;\n\t\t}\n\t\tfrp = frp->fr_next;\n\t    }\n\t}\n    }\n    else\n    {\n\tlayout = FR_COL;\n\n\t/*\n\t * Check if we are able to split the current window and compute its\n\t * height.\n\t */\n\t/* Current window requires at least 1 space. */\n\twmh1 = (p_wmh == 0 ? 1 : p_wmh) + WINBAR_HEIGHT(curwin);\n\tneeded = wmh1 + STATUS_HEIGHT;\n\tif (flags & WSP_ROOM)\n\t    needed += p_wh - wmh1;\n\tif (flags & (WSP_BOT | WSP_TOP))\n\t{\n\t    minheight = frame_minheight(topframe, NOWIN) + need_status;\n\t    available = topframe->fr_height;\n\t    needed += minheight;\n\t}\n\telse if (p_ea)\n\t{\n\t    minheight = frame_minheight(oldwin->w_frame, NOWIN) + need_status;\n\t    prevfrp = oldwin->w_frame;\n\t    for (frp = oldwin->w_frame->fr_parent; frp != NULL;\n\t\t\t\t\t\t\tfrp = frp->fr_parent)\n\t    {\n\t\tif (frp->fr_layout == FR_COL)\n\t\t    FOR_ALL_FRAMES(frp2, frp->fr_child)\n\t\t\tif (frp2 != prevfrp)\n\t\t\t    minheight += frame_minheight(frp2, NOWIN);\n\t\tprevfrp = frp;\n\t    }\n\t    available = topframe->fr_height;\n\t    needed += minheight;\n\t}\n\telse\n\t{\n\t    minheight = frame_minheight(oldwin->w_frame, NOWIN) + need_status;\n\t    available = oldwin->w_frame->fr_height;\n\t    needed += minheight;\n\t}\n\tif (available < needed && new_wp == NULL)\n\t{\n\t    emsg(_(e_noroom));\n\t    return FAIL;\n\t}\n\toldwin_height = oldwin->w_height;\n\tif (need_status)\n\t{\n\t    oldwin->w_status_height = STATUS_HEIGHT;\n\t    oldwin_height -= STATUS_HEIGHT;\n\t}\n\tif (new_size == 0)\n\t    new_size = oldwin_height / 2;\n\tif (new_size > available - minheight - STATUS_HEIGHT)\n\t    new_size = available - minheight - STATUS_HEIGHT;\n\tif (new_size < wmh1)\n\t    new_size = wmh1;\n\n\t/* if it doesn't fit in the current window, need win_equal() */\n\tif (oldwin_height - new_size - STATUS_HEIGHT < p_wmh)\n\t    do_equal = TRUE;\n\n\t/* We don't like to take lines for the new window from a\n\t * 'winfixheight' window.  Take them from a window above or below\n\t * instead, if possible. */\n\tif (oldwin->w_p_wfh)\n\t{\n\t    /* Set w_fraction now so that the cursor keeps the same relative\n\t     * vertical position using the old height. */\n\t    set_fraction(oldwin);\n\t    did_set_fraction = TRUE;\n\n\t    win_setheight_win(oldwin->w_height + new_size + STATUS_HEIGHT,\n\t\t\t\t\t\t\t\t      oldwin);\n\t    oldwin_height = oldwin->w_height;\n\t    if (need_status)\n\t\toldwin_height -= STATUS_HEIGHT;\n\t}\n\n\t/* Only make all windows the same height if one of them (except oldwin)\n\t * is higher than one of the split windows. */\n\tif (!do_equal && p_ea && size == 0 && *p_ead != 'h'\n\t   && oldwin->w_frame->fr_parent != NULL)\n\t{\n\t    frp = oldwin->w_frame->fr_parent->fr_child;\n\t    while (frp != NULL)\n\t    {\n\t\tif (frp->fr_win != oldwin && frp->fr_win != NULL\n\t\t\t&& (frp->fr_win->w_height > new_size\n\t\t\t    || frp->fr_win->w_height > oldwin_height - new_size\n\t\t\t\t\t\t\t      - STATUS_HEIGHT))\n\t\t{\n\t\t    do_equal = TRUE;\n\t\t    break;\n\t\t}\n\t\tfrp = frp->fr_next;\n\t    }\n\t}\n    }\n\n    /*\n     * allocate new window structure and link it in the window list\n     */\n    if ((flags & WSP_TOP) == 0\n\t    && ((flags & WSP_BOT)\n\t\t|| (flags & WSP_BELOW)\n\t\t|| (!(flags & WSP_ABOVE)\n\t\t    && ( (flags & WSP_VERT) ? p_spr : p_sb))))\n    {\n\t/* new window below/right of current one */\n\tif (new_wp == NULL)\n\t    wp = win_alloc(oldwin, FALSE);\n\telse\n\t    win_append(oldwin, wp);\n    }\n    else\n    {\n\tif (new_wp == NULL)\n\t    wp = win_alloc(oldwin->w_prev, FALSE);\n\telse\n\t    win_append(oldwin->w_prev, wp);\n    }\n\n    if (new_wp == NULL)\n    {\n\tif (wp == NULL)\n\t    return FAIL;\n\n\tnew_frame(wp);\n\tif (wp->w_frame == NULL)\n\t{\n\t    win_free(wp, NULL);\n\t    return FAIL;\n\t}\n\n\t/* make the contents of the new window the same as the current one */\n\twin_init(wp, curwin, flags);\n    }\n\n    /*\n     * Reorganise the tree of frames to insert the new window.\n     */\n    if (flags & (WSP_TOP | WSP_BOT))\n    {\n\tif ((topframe->fr_layout == FR_COL && (flags & WSP_VERT) == 0)\n\t    || (topframe->fr_layout == FR_ROW && (flags & WSP_VERT) != 0))\n\t{\n\t    curfrp = topframe->fr_child;\n\t    if (flags & WSP_BOT)\n\t\twhile (curfrp->fr_next != NULL)\n\t\t    curfrp = curfrp->fr_next;\n\t}\n\telse\n\t    curfrp = topframe;\n\tbefore = (flags & WSP_TOP);\n    }\n    else\n    {\n\tcurfrp = oldwin->w_frame;\n\tif (flags & WSP_BELOW)\n\t    before = FALSE;\n\telse if (flags & WSP_ABOVE)\n\t    before = TRUE;\n\telse if (flags & WSP_VERT)\n\t    before = !p_spr;\n\telse\n\t    before = !p_sb;\n    }\n    if (curfrp->fr_parent == NULL || curfrp->fr_parent->fr_layout != layout)\n    {\n\t/* Need to create a new frame in the tree to make a branch. */\n\tfrp = ALLOC_CLEAR_ONE(frame_T);\n\t*frp = *curfrp;\n\tcurfrp->fr_layout = layout;\n\tfrp->fr_parent = curfrp;\n\tfrp->fr_next = NULL;\n\tfrp->fr_prev = NULL;\n\tcurfrp->fr_child = frp;\n\tcurfrp->fr_win = NULL;\n\tcurfrp = frp;\n\tif (frp->fr_win != NULL)\n\t    oldwin->w_frame = frp;\n\telse\n\t    FOR_ALL_FRAMES(frp, frp->fr_child)\n\t\tfrp->fr_parent = curfrp;\n    }\n\n    if (new_wp == NULL)\n\tfrp = wp->w_frame;\n    else\n\tfrp = new_wp->w_frame;\n    frp->fr_parent = curfrp->fr_parent;\n\n    /* Insert the new frame at the right place in the frame list. */\n    if (before)\n\tframe_insert(curfrp, frp);\n    else\n\tframe_append(curfrp, frp);\n\n    /* Set w_fraction now so that the cursor keeps the same relative\n     * vertical position. */\n    if (!did_set_fraction)\n\tset_fraction(oldwin);\n    wp->w_fraction = oldwin->w_fraction;\n\n    if (flags & WSP_VERT)\n    {\n\twp->w_p_scr = curwin->w_p_scr;\n\n\tif (need_status)\n\t{\n\t    win_new_height(oldwin, oldwin->w_height - 1);\n\t    oldwin->w_status_height = need_status;\n\t}\n\tif (flags & (WSP_TOP | WSP_BOT))\n\t{\n\t    /* set height and row of new window to full height */\n\t    wp->w_winrow = tabline_height();\n\t    win_new_height(wp, curfrp->fr_height - (p_ls > 0)\n\t\t\t\t\t\t\t  - WINBAR_HEIGHT(wp));\n\t    wp->w_status_height = (p_ls > 0);\n\t}\n\telse\n\t{\n\t    /* height and row of new window is same as current window */\n\t    wp->w_winrow = oldwin->w_winrow;\n\t    win_new_height(wp, VISIBLE_HEIGHT(oldwin));\n\t    wp->w_status_height = oldwin->w_status_height;\n\t}\n\tfrp->fr_height = curfrp->fr_height;\n\n\t/* \"new_size\" of the current window goes to the new window, use\n\t * one column for the vertical separator */\n\twin_new_width(wp, new_size);\n\tif (before)\n\t    wp->w_vsep_width = 1;\n\telse\n\t{\n\t    wp->w_vsep_width = oldwin->w_vsep_width;\n\t    oldwin->w_vsep_width = 1;\n\t}\n\tif (flags & (WSP_TOP | WSP_BOT))\n\t{\n\t    if (flags & WSP_BOT)\n\t\tframe_add_vsep(curfrp);\n\t    /* Set width of neighbor frame */\n\t    frame_new_width(curfrp, curfrp->fr_width\n\t\t     - (new_size + ((flags & WSP_TOP) != 0)), flags & WSP_TOP,\n\t\t\t\t\t\t\t\t       FALSE);\n\t}\n\telse\n\t    win_new_width(oldwin, oldwin->w_width - (new_size + 1));\n\tif (before)\t/* new window left of current one */\n\t{\n\t    wp->w_wincol = oldwin->w_wincol;\n\t    oldwin->w_wincol += new_size + 1;\n\t}\n\telse\t\t/* new window right of current one */\n\t    wp->w_wincol = oldwin->w_wincol + oldwin->w_width + 1;\n\tframe_fix_width(oldwin);\n\tframe_fix_width(wp);\n    }\n    else\n    {\n\t/* width and column of new window is same as current window */\n\tif (flags & (WSP_TOP | WSP_BOT))\n\t{\n\t    wp->w_wincol = 0;\n\t    win_new_width(wp, Columns);\n\t    wp->w_vsep_width = 0;\n\t}\n\telse\n\t{\n\t    wp->w_wincol = oldwin->w_wincol;\n\t    win_new_width(wp, oldwin->w_width);\n\t    wp->w_vsep_width = oldwin->w_vsep_width;\n\t}\n\tfrp->fr_width = curfrp->fr_width;\n\n\t/* \"new_size\" of the current window goes to the new window, use\n\t * one row for the status line */\n\twin_new_height(wp, new_size);\n\tif (flags & (WSP_TOP | WSP_BOT))\n\t{\n\t    int new_fr_height = curfrp->fr_height - new_size\n\t\t\t\t\t\t\t  + WINBAR_HEIGHT(wp) ;\n\n\t    if (!((flags & WSP_BOT) && p_ls == 0))\n\t\tnew_fr_height -= STATUS_HEIGHT;\n\t    frame_new_height(curfrp, new_fr_height, flags & WSP_TOP, FALSE);\n\t}\n\telse\n\t    win_new_height(oldwin, oldwin_height - (new_size + STATUS_HEIGHT));\n\tif (before)\t/* new window above current one */\n\t{\n\t    wp->w_winrow = oldwin->w_winrow;\n\t    wp->w_status_height = STATUS_HEIGHT;\n\t    oldwin->w_winrow += wp->w_height + STATUS_HEIGHT;\n\t}\n\telse\t\t/* new window below current one */\n\t{\n\t    wp->w_winrow = oldwin->w_winrow + VISIBLE_HEIGHT(oldwin)\n\t\t\t\t\t\t\t       + STATUS_HEIGHT;\n\t    wp->w_status_height = oldwin->w_status_height;\n\t    if (!(flags & WSP_BOT))\n\t\toldwin->w_status_height = STATUS_HEIGHT;\n\t}\n\tif (flags & WSP_BOT)\n\t    frame_add_statusline(curfrp);\n\tframe_fix_height(wp);\n\tframe_fix_height(oldwin);\n    }\n\n    if (flags & (WSP_TOP | WSP_BOT))\n\t(void)win_comp_pos();\n\n    /*\n     * Both windows need redrawing\n     */\n    redraw_win_later(wp, NOT_VALID);\n    wp->w_redr_status = TRUE;\n    redraw_win_later(oldwin, NOT_VALID);\n    oldwin->w_redr_status = TRUE;\n\n    if (need_status)\n    {\n\tmsg_row = Rows - 1;\n\tmsg_col = sc_col;\n\tmsg_clr_eos_force();\t/* Old command/ruler may still be there */\n\tcomp_col();\n\tmsg_row = Rows - 1;\n\tmsg_col = 0;\t/* put position back at start of line */\n    }\n\n    /*\n     * equalize the window sizes.\n     */\n    if (do_equal || dir != 0)\n\twin_equal(wp, TRUE,\n\t\t(flags & WSP_VERT) ? (dir == 'v' ? 'b' : 'h')\n\t\t: dir == 'h' ? 'b' : 'v');\n\n    /* Don't change the window height/width to 'winheight' / 'winwidth' if a\n     * size was given. */\n    if (flags & WSP_VERT)\n    {\n\ti = p_wiw;\n\tif (size != 0)\n\t    p_wiw = size;\n\n# ifdef FEAT_GUI\n\t/* When 'guioptions' includes 'L' or 'R' may have to add scrollbars. */\n\tif (gui.in_use)\n\t    gui_init_which_components(NULL);\n# endif\n    }\n    else\n    {\n\ti = p_wh;\n\tif (size != 0)\n\t    p_wh = size;\n    }\n\n#ifdef FEAT_JUMPLIST\n    /* Keep same changelist position in new window. */\n    wp->w_changelistidx = oldwin->w_changelistidx;\n#endif\n\n    /*\n     * make the new window the current window\n     */\n    win_enter_ext(wp, FALSE, FALSE, TRUE, TRUE, TRUE);\n    if (flags & WSP_VERT)\n\tp_wiw = i;\n    else\n\tp_wh = i;\n\n    return OK;\n}\n\n\n/*\n * Initialize window \"newp\" from window \"oldp\".\n * Used when splitting a window and when creating a new tab page.\n * The windows will both edit the same buffer.\n * WSP_NEWLOC may be specified in flags to prevent the location list from\n * being copied.\n */\n    static void\nwin_init(win_T *newp, win_T *oldp, int flags UNUSED)\n{\n    int\t\ti;\n\n    newp->w_buffer = oldp->w_buffer;\n#ifdef FEAT_SYN_HL\n    newp->w_s = &(oldp->w_buffer->b_s);\n#endif\n    oldp->w_buffer->b_nwindows++;\n    newp->w_cursor = oldp->w_cursor;\n    newp->w_valid = 0;\n    newp->w_curswant = oldp->w_curswant;\n    newp->w_set_curswant = oldp->w_set_curswant;\n    newp->w_topline = oldp->w_topline;\n#ifdef FEAT_DIFF\n    newp->w_topfill = oldp->w_topfill;\n#endif\n    newp->w_leftcol = oldp->w_leftcol;\n    newp->w_pcmark = oldp->w_pcmark;\n    newp->w_prev_pcmark = oldp->w_prev_pcmark;\n    newp->w_alt_fnum = oldp->w_alt_fnum;\n    newp->w_wrow = oldp->w_wrow;\n    newp->w_fraction = oldp->w_fraction;\n    newp->w_prev_fraction_row = oldp->w_prev_fraction_row;\n#ifdef FEAT_JUMPLIST\n    copy_jumplist(oldp, newp);\n#endif\n#ifdef FEAT_QUICKFIX\n    if (flags & WSP_NEWLOC)\n    {\n\t/* Don't copy the location list.  */\n\tnewp->w_llist = NULL;\n\tnewp->w_llist_ref = NULL;\n    }\n    else\n\tcopy_loclist_stack(oldp, newp);\n#endif\n    newp->w_localdir = (oldp->w_localdir == NULL)\n\t\t\t\t    ? NULL : vim_strsave(oldp->w_localdir);\n\n    /* copy tagstack and folds */\n    for (i = 0; i < oldp->w_tagstacklen; i++)\n    {\n\ttaggy_T\t*tag = &newp->w_tagstack[i];\n\t*tag = oldp->w_tagstack[i];\n\tif (tag->tagname != NULL)\n\t    tag->tagname = vim_strsave(tag->tagname);\n\tif (tag->user_data != NULL)\n\t    tag->user_data = vim_strsave(tag->user_data);\n    }\n    newp->w_tagstackidx = oldp->w_tagstackidx;\n    newp->w_tagstacklen = oldp->w_tagstacklen;\n#ifdef FEAT_FOLDING\n    copyFoldingState(oldp, newp);\n#endif\n\n    win_init_some(newp, oldp);\n\n#ifdef FEAT_SYN_HL\n    check_colorcolumn(newp);\n#endif\n}\n\n/*\n * Initialize window \"newp\" from window \"old\".\n * Only the essential things are copied.\n */\n    static void\nwin_init_some(win_T *newp, win_T *oldp)\n{\n    /* Use the same argument list. */\n    newp->w_alist = oldp->w_alist;\n    ++newp->w_alist->al_refcount;\n    newp->w_arg_idx = oldp->w_arg_idx;\n\n    /* copy options from existing window */\n    win_copy_options(oldp, newp);\n}\n\n/*\n * Return TRUE if \"win\" is a global popup or a popup in the current tab page.\n */\n    int\nwin_valid_popup(win_T *win UNUSED)\n{\n#ifdef FEAT_TEXT_PROP\n    win_T\t*wp;\n\n    for (wp = first_popupwin; wp != NULL; wp = wp->w_next)\n\tif (wp == win)\n\t    return TRUE;\n    for (wp = curtab->tp_first_popupwin; wp != NULL; wp = wp->w_next)\n\tif (wp == win)\n\t    return TRUE;\n#endif\n    return FALSE;\n}\n\n/*\n * Check if \"win\" is a pointer to an existing window in the current tab page.\n */\n    int\nwin_valid(win_T *win)\n{\n    win_T\t*wp;\n\n    if (win == NULL)\n\treturn FALSE;\n    FOR_ALL_WINDOWS(wp)\n\tif (wp == win)\n\t    return TRUE;\n    return win_valid_popup(win);\n}\n\n/*\n * Check if \"win\" is a pointer to an existing window in any tab page.\n */\n    int\nwin_valid_any_tab(win_T *win)\n{\n    win_T\t*wp;\n    tabpage_T\t*tp;\n\n    if (win == NULL)\n\treturn FALSE;\n    FOR_ALL_TABPAGES(tp)\n    {\n\tFOR_ALL_WINDOWS_IN_TAB(tp, wp)\n\t{\n\t    if (wp == win)\n\t\treturn TRUE;\n\t}\n#ifdef FEAT_TEXT_PROP\n\tfor (wp = tp->tp_first_popupwin; wp != NULL; wp = wp->w_next)\n\t    if (wp == win)\n\t\treturn TRUE;\n#endif\n    }\n    return win_valid_popup(win);\n}\n\n/*\n * Return the number of windows.\n */\n    int\nwin_count(void)\n{\n    win_T\t*wp;\n    int\t\tcount = 0;\n\n    FOR_ALL_WINDOWS(wp)\n\t++count;\n    return count;\n}\n\n/*\n * Make \"count\" windows on the screen.\n * Return actual number of windows on the screen.\n * Must be called when there is just one window, filling the whole screen\n * (excluding the command line).\n */\n    int\nmake_windows(\n    int\t\tcount,\n    int\t\tvertical UNUSED)  /* split windows vertically if TRUE */\n{\n    int\t\tmaxcount;\n    int\t\ttodo;\n\n    if (vertical)\n    {\n\t/* Each windows needs at least 'winminwidth' lines and a separator\n\t * column. */\n\tmaxcount = (curwin->w_width + curwin->w_vsep_width\n\t\t\t\t\t     - (p_wiw - p_wmw)) / (p_wmw + 1);\n    }\n    else\n    {\n\t/* Each window needs at least 'winminheight' lines and a status line. */\n\tmaxcount = (VISIBLE_HEIGHT(curwin) + curwin->w_status_height\n\t\t\t\t  - (p_wh - p_wmh)) / (p_wmh + STATUS_HEIGHT);\n    }\n\n    if (maxcount < 2)\n\tmaxcount = 2;\n    if (count > maxcount)\n\tcount = maxcount;\n\n    /*\n     * add status line now, otherwise first window will be too big\n     */\n    if (count > 1)\n\tlast_status(TRUE);\n\n    /*\n     * Don't execute autocommands while creating the windows.  Must do that\n     * when putting the buffers in the windows.\n     */\n    block_autocmds();\n\n    /* todo is number of windows left to create */\n    for (todo = count - 1; todo > 0; --todo)\n\tif (vertical)\n\t{\n\t    if (win_split(curwin->w_width - (curwin->w_width - todo)\n\t\t\t/ (todo + 1) - 1, WSP_VERT | WSP_ABOVE) == FAIL)\n\t\tbreak;\n\t}\n\telse\n\t{\n\t    if (win_split(curwin->w_height - (curwin->w_height - todo\n\t\t\t    * STATUS_HEIGHT) / (todo + 1)\n\t\t\t- STATUS_HEIGHT, WSP_ABOVE) == FAIL)\n\t\tbreak;\n\t}\n\n    unblock_autocmds();\n\n    /* return actual number of windows */\n    return (count - todo);\n}\n\n/*\n * Exchange current and next window\n */\n    static void\nwin_exchange(long Prenum)\n{\n    frame_T\t*frp;\n    frame_T\t*frp2;\n    win_T\t*wp;\n    win_T\t*wp2;\n    int\t\ttemp;\n\n    if (ERROR_IF_POPUP_WINDOW)\n\treturn;\n    if (ONE_WINDOW)\t    // just one window\n    {\n\tbeep_flush();\n\treturn;\n    }\n\n#ifdef FEAT_GUI\n    need_mouse_correct = TRUE;\n#endif\n\n    /*\n     * find window to exchange with\n     */\n    if (Prenum)\n    {\n\tfrp = curwin->w_frame->fr_parent->fr_child;\n\twhile (frp != NULL && --Prenum > 0)\n\t    frp = frp->fr_next;\n    }\n    else if (curwin->w_frame->fr_next != NULL)\t/* Swap with next */\n\tfrp = curwin->w_frame->fr_next;\n    else    /* Swap last window in row/col with previous */\n\tfrp = curwin->w_frame->fr_prev;\n\n    /* We can only exchange a window with another window, not with a frame\n     * containing windows. */\n    if (frp == NULL || frp->fr_win == NULL || frp->fr_win == curwin)\n\treturn;\n    wp = frp->fr_win;\n\n/*\n * 1. remove curwin from the list. Remember after which window it was in wp2\n * 2. insert curwin before wp in the list\n * if wp != wp2\n *    3. remove wp from the list\n *    4. insert wp after wp2\n * 5. exchange the status line height and vsep width.\n */\n    wp2 = curwin->w_prev;\n    frp2 = curwin->w_frame->fr_prev;\n    if (wp->w_prev != curwin)\n    {\n\twin_remove(curwin, NULL);\n\tframe_remove(curwin->w_frame);\n\twin_append(wp->w_prev, curwin);\n\tframe_insert(frp, curwin->w_frame);\n    }\n    if (wp != wp2)\n    {\n\twin_remove(wp, NULL);\n\tframe_remove(wp->w_frame);\n\twin_append(wp2, wp);\n\tif (frp2 == NULL)\n\t    frame_insert(wp->w_frame->fr_parent->fr_child, wp->w_frame);\n\telse\n\t    frame_append(frp2, wp->w_frame);\n    }\n    temp = curwin->w_status_height;\n    curwin->w_status_height = wp->w_status_height;\n    wp->w_status_height = temp;\n    temp = curwin->w_vsep_width;\n    curwin->w_vsep_width = wp->w_vsep_width;\n    wp->w_vsep_width = temp;\n\n    /* If the windows are not in the same frame, exchange the sizes to avoid\n     * messing up the window layout.  Otherwise fix the frame sizes. */\n    if (curwin->w_frame->fr_parent != wp->w_frame->fr_parent)\n    {\n\ttemp = curwin->w_height;\n\tcurwin->w_height = wp->w_height;\n\twp->w_height = temp;\n\ttemp = curwin->w_width;\n\tcurwin->w_width = wp->w_width;\n\twp->w_width = temp;\n    }\n    else\n    {\n\tframe_fix_height(curwin);\n\tframe_fix_height(wp);\n\tframe_fix_width(curwin);\n\tframe_fix_width(wp);\n    }\n\n    (void)win_comp_pos();\t\t/* recompute window positions */\n\n    win_enter(wp, TRUE);\n    redraw_all_later(NOT_VALID);\n}\n\n/*\n * rotate windows: if upwards TRUE the second window becomes the first one\n *\t\t   if upwards FALSE the first window becomes the second one\n */\n    static void\nwin_rotate(int upwards, int count)\n{\n    win_T\t*wp1;\n    win_T\t*wp2;\n    frame_T\t*frp;\n    int\t\tn;\n\n    if (ONE_WINDOW)\t\t/* nothing to do */\n    {\n\tbeep_flush();\n\treturn;\n    }\n\n#ifdef FEAT_GUI\n    need_mouse_correct = TRUE;\n#endif\n\n    /* Check if all frames in this row/col have one window. */\n    FOR_ALL_FRAMES(frp, curwin->w_frame->fr_parent->fr_child)\n\tif (frp->fr_win == NULL)\n\t{\n\t    emsg(_(\"E443: Cannot rotate when another window is split\"));\n\t    return;\n\t}\n\n    while (count--)\n    {\n\tif (upwards)\t\t/* first window becomes last window */\n\t{\n\t    /* remove first window/frame from the list */\n\t    frp = curwin->w_frame->fr_parent->fr_child;\n\t    wp1 = frp->fr_win;\n\t    win_remove(wp1, NULL);\n\t    frame_remove(frp);\n\n\t    /* find last frame and append removed window/frame after it */\n\t    for ( ; frp->fr_next != NULL; frp = frp->fr_next)\n\t\t;\n\t    win_append(frp->fr_win, wp1);\n\t    frame_append(frp, wp1->w_frame);\n\n\t    wp2 = frp->fr_win;\t\t/* previously last window */\n\t}\n\telse\t\t\t/* last window becomes first window */\n\t{\n\t    /* find last window/frame in the list and remove it */\n\t    for (frp = curwin->w_frame; frp->fr_next != NULL;\n\t\t\t\t\t\t\t   frp = frp->fr_next)\n\t\t;\n\t    wp1 = frp->fr_win;\n\t    wp2 = wp1->w_prev;\t\t    /* will become last window */\n\t    win_remove(wp1, NULL);\n\t    frame_remove(frp);\n\n\t    /* append the removed window/frame before the first in the list */\n\t    win_append(frp->fr_parent->fr_child->fr_win->w_prev, wp1);\n\t    frame_insert(frp->fr_parent->fr_child, frp);\n\t}\n\n\t/* exchange status height and vsep width of old and new last window */\n\tn = wp2->w_status_height;\n\twp2->w_status_height = wp1->w_status_height;\n\twp1->w_status_height = n;\n\tframe_fix_height(wp1);\n\tframe_fix_height(wp2);\n\tn = wp2->w_vsep_width;\n\twp2->w_vsep_width = wp1->w_vsep_width;\n\twp1->w_vsep_width = n;\n\tframe_fix_width(wp1);\n\tframe_fix_width(wp2);\n\n\t/* recompute w_winrow and w_wincol for all windows */\n\t(void)win_comp_pos();\n    }\n\n    redraw_all_later(NOT_VALID);\n}\n\n/*\n * Move the current window to the very top/bottom/left/right of the screen.\n */\n    static void\nwin_totop(int size, int flags)\n{\n    int\t\tdir;\n    int\t\theight = curwin->w_height;\n\n    if (ONE_WINDOW)\n    {\n\tbeep_flush();\n\treturn;\n    }\n    if (check_split_disallowed() == FAIL)\n\treturn;\n\n    /* Remove the window and frame from the tree of frames. */\n    (void)winframe_remove(curwin, &dir, NULL);\n    win_remove(curwin, NULL);\n    last_status(FALSE);\t    /* may need to remove last status line */\n    (void)win_comp_pos();   /* recompute window positions */\n\n    /* Split a window on the desired side and put the window there. */\n    (void)win_split_ins(size, flags, curwin, dir);\n    if (!(flags & WSP_VERT))\n    {\n\twin_setheight(height);\n\tif (p_ea)\n\t    win_equal(curwin, TRUE, 'v');\n    }\n\n#if defined(FEAT_GUI)\n    /* When 'guioptions' includes 'L' or 'R' may have to remove or add\n     * scrollbars.  Have to update them anyway. */\n    gui_may_update_scrollbars();\n#endif\n}\n\n/*\n * Move window \"win1\" to below/right of \"win2\" and make \"win1\" the current\n * window.  Only works within the same frame!\n */\n    void\nwin_move_after(win_T *win1, win_T *win2)\n{\n    int\t\theight;\n\n    /* check if the arguments are reasonable */\n    if (win1 == win2)\n\treturn;\n\n    /* check if there is something to do */\n    if (win2->w_next != win1)\n    {\n\tif (win1->w_frame->fr_parent != win2->w_frame->fr_parent)\n\t{\n\t    iemsg(\"INTERNAL: trying to move a window into another frame\");\n\t    return;\n\t}\n\n\t/* may need move the status line/vertical separator of the last window\n\t * */\n\tif (win1 == lastwin)\n\t{\n\t    height = win1->w_prev->w_status_height;\n\t    win1->w_prev->w_status_height = win1->w_status_height;\n\t    win1->w_status_height = height;\n\t    if (win1->w_prev->w_vsep_width == 1)\n\t    {\n\t\t/* Remove the vertical separator from the last-but-one window,\n\t\t * add it to the last window.  Adjust the frame widths. */\n\t\twin1->w_prev->w_vsep_width = 0;\n\t\twin1->w_prev->w_frame->fr_width -= 1;\n\t\twin1->w_vsep_width = 1;\n\t\twin1->w_frame->fr_width += 1;\n\t    }\n\t}\n\telse if (win2 == lastwin)\n\t{\n\t    height = win1->w_status_height;\n\t    win1->w_status_height = win2->w_status_height;\n\t    win2->w_status_height = height;\n\t    if (win1->w_vsep_width == 1)\n\t    {\n\t\t/* Remove the vertical separator from win1, add it to the last\n\t\t * window, win2.  Adjust the frame widths. */\n\t\twin2->w_vsep_width = 1;\n\t\twin2->w_frame->fr_width += 1;\n\t\twin1->w_vsep_width = 0;\n\t\twin1->w_frame->fr_width -= 1;\n\t    }\n\t}\n\twin_remove(win1, NULL);\n\tframe_remove(win1->w_frame);\n\twin_append(win2, win1);\n\tframe_append(win2->w_frame, win1->w_frame);\n\n\t(void)win_comp_pos();\t/* recompute w_winrow for all windows */\n\tredraw_later(NOT_VALID);\n    }\n    win_enter(win1, FALSE);\n}\n\n/*\n * Make all windows the same height.\n * 'next_curwin' will soon be the current window, make sure it has enough\n * rows.\n */\n    void\nwin_equal(\n    win_T\t*next_curwin,\t/* pointer to current window to be or NULL */\n    int\t\tcurrent,\t/* do only frame with current window */\n    int\t\tdir)\t\t/* 'v' for vertically, 'h' for horizontally,\n\t\t\t\t   'b' for both, 0 for using p_ead */\n{\n    if (dir == 0)\n\tdir = *p_ead;\n    win_equal_rec(next_curwin == NULL ? curwin : next_curwin, current,\n\t\t      topframe, dir, 0, tabline_height(),\n\t\t\t\t\t   (int)Columns, topframe->fr_height);\n}\n\n/*\n * Set a frame to a new position and height, spreading the available room\n * equally over contained frames.\n * The window \"next_curwin\" (if not NULL) should at least get the size from\n * 'winheight' and 'winwidth' if possible.\n */\n    static void\nwin_equal_rec(\n    win_T\t*next_curwin,\t/* pointer to current window to be or NULL */\n    int\t\tcurrent,\t/* do only frame with current window */\n    frame_T\t*topfr,\t\t/* frame to set size off */\n    int\t\tdir,\t\t/* 'v', 'h' or 'b', see win_equal() */\n    int\t\tcol,\t\t/* horizontal position for frame */\n    int\t\trow,\t\t/* vertical position for frame */\n    int\t\twidth,\t\t/* new width of frame */\n    int\t\theight)\t\t/* new height of frame */\n{\n    int\t\tn, m;\n    int\t\textra_sep = 0;\n    int\t\twincount, totwincount = 0;\n    frame_T\t*fr;\n    int\t\tnext_curwin_size = 0;\n    int\t\troom = 0;\n    int\t\tnew_size;\n    int\t\thas_next_curwin = 0;\n    int\t\thnc;\n\n    if (topfr->fr_layout == FR_LEAF)\n    {\n\t/* Set the width/height of this frame.\n\t * Redraw when size or position changes */\n\tif (topfr->fr_height != height || topfr->fr_win->w_winrow != row\n\t\t|| topfr->fr_width != width || topfr->fr_win->w_wincol != col\n\t   )\n\t{\n\t    topfr->fr_win->w_winrow = row;\n\t    frame_new_height(topfr, height, FALSE, FALSE);\n\t    topfr->fr_win->w_wincol = col;\n\t    frame_new_width(topfr, width, FALSE, FALSE);\n\t    redraw_all_later(NOT_VALID);\n\t}\n    }\n    else if (topfr->fr_layout == FR_ROW)\n    {\n\ttopfr->fr_width = width;\n\ttopfr->fr_height = height;\n\n\tif (dir != 'v')\t\t\t/* equalize frame widths */\n\t{\n\t    /* Compute the maximum number of windows horizontally in this\n\t     * frame. */\n\t    n = frame_minwidth(topfr, NOWIN);\n\t    /* add one for the rightmost window, it doesn't have a separator */\n\t    if (col + width == Columns)\n\t\textra_sep = 1;\n\t    else\n\t\textra_sep = 0;\n\t    totwincount = (n + extra_sep) / (p_wmw + 1);\n\t    has_next_curwin = frame_has_win(topfr, next_curwin);\n\n\t    /*\n\t     * Compute width for \"next_curwin\" window and room available for\n\t     * other windows.\n\t     * \"m\" is the minimal width when counting p_wiw for \"next_curwin\".\n\t     */\n\t    m = frame_minwidth(topfr, next_curwin);\n\t    room = width - m;\n\t    if (room < 0)\n\t    {\n\t\tnext_curwin_size = p_wiw + room;\n\t\troom = 0;\n\t    }\n\t    else\n\t    {\n\t\tnext_curwin_size = -1;\n\t\tFOR_ALL_FRAMES(fr, topfr->fr_child)\n\t\t{\n\t\t    /* If 'winfixwidth' set keep the window width if\n\t\t     * possible.\n\t\t     * Watch out for this window being the next_curwin. */\n\t\t    if (frame_fixed_width(fr))\n\t\t    {\n\t\t\tn = frame_minwidth(fr, NOWIN);\n\t\t\tnew_size = fr->fr_width;\n\t\t\tif (frame_has_win(fr, next_curwin))\n\t\t\t{\n\t\t\t    room += p_wiw - p_wmw;\n\t\t\t    next_curwin_size = 0;\n\t\t\t    if (new_size < p_wiw)\n\t\t\t\tnew_size = p_wiw;\n\t\t\t}\n\t\t\telse\n\t\t\t    /* These windows don't use up room. */\n\t\t\t    totwincount -= (n + (fr->fr_next == NULL\n\t\t\t\t\t      ? extra_sep : 0)) / (p_wmw + 1);\n\t\t\troom -= new_size - n;\n\t\t\tif (room < 0)\n\t\t\t{\n\t\t\t    new_size += room;\n\t\t\t    room = 0;\n\t\t\t}\n\t\t\tfr->fr_newwidth = new_size;\n\t\t    }\n\t\t}\n\t\tif (next_curwin_size == -1)\n\t\t{\n\t\t    if (!has_next_curwin)\n\t\t\tnext_curwin_size = 0;\n\t\t    else if (totwincount > 1\n\t\t\t    && (room + (totwincount - 2))\n\t\t\t\t\t\t  / (totwincount - 1) > p_wiw)\n\t\t    {\n\t\t\t/* Can make all windows wider than 'winwidth', spread\n\t\t\t * the room equally. */\n\t\t\tnext_curwin_size = (room + p_wiw\n\t\t\t\t\t    + (totwincount - 1) * p_wmw\n\t\t\t\t\t    + (totwincount - 1)) / totwincount;\n\t\t\troom -= next_curwin_size - p_wiw;\n\t\t    }\n\t\t    else\n\t\t\tnext_curwin_size = p_wiw;\n\t\t}\n\t    }\n\n\t    if (has_next_curwin)\n\t\t--totwincount;\t\t/* don't count curwin */\n\t}\n\n\tFOR_ALL_FRAMES(fr, topfr->fr_child)\n\t{\n\t    wincount = 1;\n\t    if (fr->fr_next == NULL)\n\t\t/* last frame gets all that remains (avoid roundoff error) */\n\t\tnew_size = width;\n\t    else if (dir == 'v')\n\t\tnew_size = fr->fr_width;\n\t    else if (frame_fixed_width(fr))\n\t    {\n\t\tnew_size = fr->fr_newwidth;\n\t\twincount = 0;\t    /* doesn't count as a sizeable window */\n\t    }\n\t    else\n\t    {\n\t\t/* Compute the maximum number of windows horiz. in \"fr\". */\n\t\tn = frame_minwidth(fr, NOWIN);\n\t\twincount = (n + (fr->fr_next == NULL ? extra_sep : 0))\n\t\t\t\t\t\t\t\t/ (p_wmw + 1);\n\t\tm = frame_minwidth(fr, next_curwin);\n\t\tif (has_next_curwin)\n\t\t    hnc = frame_has_win(fr, next_curwin);\n\t\telse\n\t\t    hnc = FALSE;\n\t\tif (hnc)\t    /* don't count next_curwin */\n\t\t    --wincount;\n\t\tif (totwincount == 0)\n\t\t    new_size = room;\n\t\telse\n\t\t    new_size = (wincount * room + ((unsigned)totwincount >> 1))\n\t\t\t\t\t\t\t\t/ totwincount;\n\t\tif (hnc)\t    /* add next_curwin size */\n\t\t{\n\t\t    next_curwin_size -= p_wiw - (m - n);\n\t\t    new_size += next_curwin_size;\n\t\t    room -= new_size - next_curwin_size;\n\t\t}\n\t\telse\n\t\t    room -= new_size;\n\t\tnew_size += n;\n\t    }\n\n\t    /* Skip frame that is full width when splitting or closing a\n\t     * window, unless equalizing all frames. */\n\t    if (!current || dir != 'v' || topfr->fr_parent != NULL\n\t\t    || (new_size != fr->fr_width)\n\t\t    || frame_has_win(fr, next_curwin))\n\t\twin_equal_rec(next_curwin, current, fr, dir, col, row,\n\t\t\t\t\t\t\t    new_size, height);\n\t    col += new_size;\n\t    width -= new_size;\n\t    totwincount -= wincount;\n\t}\n    }\n    else /* topfr->fr_layout == FR_COL */\n    {\n\ttopfr->fr_width = width;\n\ttopfr->fr_height = height;\n\n\tif (dir != 'h')\t\t\t/* equalize frame heights */\n\t{\n\t    /* Compute maximum number of windows vertically in this frame. */\n\t    n = frame_minheight(topfr, NOWIN);\n\t    /* add one for the bottom window if it doesn't have a statusline */\n\t    if (row + height == cmdline_row && p_ls == 0)\n\t\textra_sep = 1;\n\t    else\n\t\textra_sep = 0;\n\t    totwincount = (n + extra_sep) / (p_wmh + 1);\n\t    has_next_curwin = frame_has_win(topfr, next_curwin);\n\n\t    /*\n\t     * Compute height for \"next_curwin\" window and room available for\n\t     * other windows.\n\t     * \"m\" is the minimal height when counting p_wh for \"next_curwin\".\n\t     */\n\t    m = frame_minheight(topfr, next_curwin);\n\t    room = height - m;\n\t    if (room < 0)\n\t    {\n\t\t/* The room is less then 'winheight', use all space for the\n\t\t * current window. */\n\t\tnext_curwin_size = p_wh + room;\n\t\troom = 0;\n\t    }\n\t    else\n\t    {\n\t\tnext_curwin_size = -1;\n\t\tFOR_ALL_FRAMES(fr, topfr->fr_child)\n\t\t{\n\t\t    /* If 'winfixheight' set keep the window height if\n\t\t     * possible.\n\t\t     * Watch out for this window being the next_curwin. */\n\t\t    if (frame_fixed_height(fr))\n\t\t    {\n\t\t\tn = frame_minheight(fr, NOWIN);\n\t\t\tnew_size = fr->fr_height;\n\t\t\tif (frame_has_win(fr, next_curwin))\n\t\t\t{\n\t\t\t    room += p_wh - p_wmh;\n\t\t\t    next_curwin_size = 0;\n\t\t\t    if (new_size < p_wh)\n\t\t\t\tnew_size = p_wh;\n\t\t\t}\n\t\t\telse\n\t\t\t    /* These windows don't use up room. */\n\t\t\t    totwincount -= (n + (fr->fr_next == NULL\n\t\t\t\t\t      ? extra_sep : 0)) / (p_wmh + 1);\n\t\t\troom -= new_size - n;\n\t\t\tif (room < 0)\n\t\t\t{\n\t\t\t    new_size += room;\n\t\t\t    room = 0;\n\t\t\t}\n\t\t\tfr->fr_newheight = new_size;\n\t\t    }\n\t\t}\n\t\tif (next_curwin_size == -1)\n\t\t{\n\t\t    if (!has_next_curwin)\n\t\t\tnext_curwin_size = 0;\n\t\t    else if (totwincount > 1\n\t\t\t    && (room + (totwincount - 2))\n\t\t\t\t\t\t   / (totwincount - 1) > p_wh)\n\t\t    {\n\t\t\t/* can make all windows higher than 'winheight',\n\t\t\t * spread the room equally. */\n\t\t\tnext_curwin_size = (room + p_wh\n\t\t\t\t\t   + (totwincount - 1) * p_wmh\n\t\t\t\t\t   + (totwincount - 1)) / totwincount;\n\t\t\troom -= next_curwin_size - p_wh;\n\t\t    }\n\t\t    else\n\t\t\tnext_curwin_size = p_wh;\n\t\t}\n\t    }\n\n\t    if (has_next_curwin)\n\t\t--totwincount;\t\t/* don't count curwin */\n\t}\n\n\tFOR_ALL_FRAMES(fr, topfr->fr_child)\n\t{\n\t    wincount = 1;\n\t    if (fr->fr_next == NULL)\n\t\t/* last frame gets all that remains (avoid roundoff error) */\n\t\tnew_size = height;\n\t    else if (dir == 'h')\n\t\tnew_size = fr->fr_height;\n\t    else if (frame_fixed_height(fr))\n\t    {\n\t\tnew_size = fr->fr_newheight;\n\t\twincount = 0;\t    /* doesn't count as a sizeable window */\n\t    }\n\t    else\n\t    {\n\t\t/* Compute the maximum number of windows vert. in \"fr\". */\n\t\tn = frame_minheight(fr, NOWIN);\n\t\twincount = (n + (fr->fr_next == NULL ? extra_sep : 0))\n\t\t\t\t\t\t\t\t/ (p_wmh + 1);\n\t\tm = frame_minheight(fr, next_curwin);\n\t\tif (has_next_curwin)\n\t\t    hnc = frame_has_win(fr, next_curwin);\n\t\telse\n\t\t    hnc = FALSE;\n\t\tif (hnc)\t    /* don't count next_curwin */\n\t\t    --wincount;\n\t\tif (totwincount == 0)\n\t\t    new_size = room;\n\t\telse\n\t\t    new_size = (wincount * room + ((unsigned)totwincount >> 1))\n\t\t\t\t\t\t\t\t/ totwincount;\n\t\tif (hnc)\t    /* add next_curwin size */\n\t\t{\n\t\t    next_curwin_size -= p_wh - (m - n);\n\t\t    new_size += next_curwin_size;\n\t\t    room -= new_size - next_curwin_size;\n\t\t}\n\t\telse\n\t\t    room -= new_size;\n\t\tnew_size += n;\n\t    }\n\t    /* Skip frame that is full width when splitting or closing a\n\t     * window, unless equalizing all frames. */\n\t    if (!current || dir != 'h' || topfr->fr_parent != NULL\n\t\t    || (new_size != fr->fr_height)\n\t\t    || frame_has_win(fr, next_curwin))\n\t\twin_equal_rec(next_curwin, current, fr, dir, col, row,\n\t\t\t\t\t\t\t     width, new_size);\n\t    row += new_size;\n\t    height -= new_size;\n\t    totwincount -= wincount;\n\t}\n    }\n}\n\n#ifdef FEAT_JOB_CHANNEL\n    static void\nleaving_window(win_T *win)\n{\n    // Only matters for a prompt window.\n    if (!bt_prompt(win->w_buffer))\n\treturn;\n\n    // When leaving a prompt window stop Insert mode and perhaps restart\n    // it when entering that window again.\n    win->w_buffer->b_prompt_insert = restart_edit;\n    if (restart_edit != 0 && mode_displayed)\n\tclear_cmdline = TRUE;\t\t/* unshow mode later */\n    restart_edit = NUL;\n\n    // When leaving the window (or closing the window) was done from a\n    // callback we need to break out of the Insert mode loop and restart Insert\n    // mode when entering the window again.\n    if (State & INSERT)\n    {\n\tstop_insert_mode = TRUE;\n\tif (win->w_buffer->b_prompt_insert == NUL)\n\t    win->w_buffer->b_prompt_insert = 'A';\n    }\n}\n\n    static void\nentering_window(win_T *win)\n{\n    // Only matters for a prompt window.\n    if (!bt_prompt(win->w_buffer))\n\treturn;\n\n    // When switching to a prompt buffer that was in Insert mode, don't stop\n    // Insert mode, it may have been set in leaving_window().\n    if (win->w_buffer->b_prompt_insert != NUL)\n\tstop_insert_mode = FALSE;\n\n    // When entering the prompt window restart Insert mode if we were in Insert\n    // mode when we left it.\n    restart_edit = win->w_buffer->b_prompt_insert;\n}\n#endif\n\n/*\n * Close all windows for buffer \"buf\".\n */\n    void\nclose_windows(\n    buf_T\t*buf,\n    int\t\tkeep_curwin)\t    /* don't close \"curwin\" */\n{\n    win_T\t*wp;\n    tabpage_T   *tp, *nexttp;\n    int\t\th = tabline_height();\n    int\t\tcount = tabpage_index(NULL);\n\n    ++RedrawingDisabled;\n\n    for (wp = firstwin; wp != NULL && !ONE_WINDOW; )\n    {\n\tif (wp->w_buffer == buf && (!keep_curwin || wp != curwin)\n\t\t&& !(wp->w_closing || wp->w_buffer->b_locked > 0))\n\t{\n\t    if (win_close(wp, FALSE) == FAIL)\n\t\t/* If closing the window fails give up, to avoid looping\n\t\t * forever. */\n\t\tbreak;\n\n\t    /* Start all over, autocommands may change the window layout. */\n\t    wp = firstwin;\n\t}\n\telse\n\t    wp = wp->w_next;\n    }\n\n    /* Also check windows in other tab pages. */\n    for (tp = first_tabpage; tp != NULL; tp = nexttp)\n    {\n\tnexttp = tp->tp_next;\n\tif (tp != curtab)\n\t    for (wp = tp->tp_firstwin; wp != NULL; wp = wp->w_next)\n\t\tif (wp->w_buffer == buf\n\t\t    && !(wp->w_closing || wp->w_buffer->b_locked > 0))\n\t\t{\n\t\t    win_close_othertab(wp, FALSE, tp);\n\n\t\t    /* Start all over, the tab page may be closed and\n\t\t     * autocommands may change the window layout. */\n\t\t    nexttp = first_tabpage;\n\t\t    break;\n\t\t}\n    }\n\n    --RedrawingDisabled;\n\n    if (count != tabpage_index(NULL))\n\tapply_autocmds(EVENT_TABCLOSED, NULL, NULL, FALSE, curbuf);\n\n    redraw_tabline = TRUE;\n    if (h != tabline_height())\n\tshell_new_rows();\n}\n\n/*\n * Return TRUE if the current window is the only window that exists (ignoring\n * \"aucmd_win\").\n * Returns FALSE if there is a window, possibly in another tab page.\n */\n    static int\nlast_window(void)\n{\n    return (one_window() && first_tabpage->tp_next == NULL);\n}\n\n/*\n * Return TRUE if there is only one window other than \"aucmd_win\" in the\n * current tab page.\n */\n    int\none_window(void)\n{\n    win_T\t*wp;\n    int\t\tseen_one = FALSE;\n\n    FOR_ALL_WINDOWS(wp)\n    {\n\tif (wp != aucmd_win)\n\t{\n\t    if (seen_one)\n\t\treturn FALSE;\n\t    seen_one = TRUE;\n\t}\n    }\n    return TRUE;\n}\n\n/*\n * Close the possibly last window in a tab page.\n * Returns TRUE when the window was closed already.\n */\n    static int\nclose_last_window_tabpage(\n    win_T\t*win,\n    int\t\tfree_buf,\n    tabpage_T   *prev_curtab)\n{\n    if (ONE_WINDOW)\n    {\n\tbuf_T\t*old_curbuf = curbuf;\n\n\t/*\n\t * Closing the last window in a tab page.  First go to another tab\n\t * page and then close the window and the tab page.  This avoids that\n\t * curwin and curtab are invalid while we are freeing memory, they may\n\t * be used in GUI events.\n\t * Don't trigger autocommands yet, they may use wrong values, so do\n\t * that below.\n\t */\n\tgoto_tabpage_tp(alt_tabpage(), FALSE, TRUE);\n\tredraw_tabline = TRUE;\n\n\t/* Safety check: Autocommands may have closed the window when jumping\n\t * to the other tab page. */\n\tif (valid_tabpage(prev_curtab) && prev_curtab->tp_firstwin == win)\n\t{\n\t    int\t    h = tabline_height();\n\n\t    win_close_othertab(win, free_buf, prev_curtab);\n\t    if (h != tabline_height())\n\t\tshell_new_rows();\n\t}\n#ifdef FEAT_JOB_CHANNEL\n\tentering_window(curwin);\n#endif\n\t/* Since goto_tabpage_tp above did not trigger *Enter autocommands, do\n\t * that now. */\n\tapply_autocmds(EVENT_TABCLOSED, NULL, NULL, FALSE, curbuf);\n\tapply_autocmds(EVENT_WINENTER, NULL, NULL, FALSE, curbuf);\n\tapply_autocmds(EVENT_TABENTER, NULL, NULL, FALSE, curbuf);\n\tif (old_curbuf != curbuf)\n\t    apply_autocmds(EVENT_BUFENTER, NULL, NULL, FALSE, curbuf);\n\treturn TRUE;\n    }\n    return FALSE;\n}\n\n/*\n * Close the buffer of \"win\" and unload it if \"action\" is DOBUF_UNLOAD.\n * \"action\" can also be zero (do nothing) or DOBUF_WIPE.\n * \"abort_if_last\" is passed to close_buffer(): abort closing if all other\n * windows are closed.\n */\n    static void\nwin_close_buffer(win_T *win, int action, int abort_if_last)\n{\n#ifdef FEAT_SYN_HL\n    // Free independent synblock before the buffer is freed.\n    if (win->w_buffer != NULL)\n\treset_synblock(win);\n#endif\n\n#ifdef FEAT_QUICKFIX\n    // When the quickfix/location list window is closed, unlist the buffer.\n    if (win->w_buffer != NULL && bt_quickfix(win->w_buffer))\n\twin->w_buffer->b_p_bl = FALSE;\n#endif\n\n    // Close the link to the buffer.\n    if (win->w_buffer != NULL)\n    {\n\tbufref_T    bufref;\n\n\tset_bufref(&bufref, curbuf);\n\twin->w_closing = TRUE;\n\tclose_buffer(win, win->w_buffer, action, abort_if_last);\n\tif (win_valid_any_tab(win))\n\t    win->w_closing = FALSE;\n\t// Make sure curbuf is valid. It can become invalid if 'bufhidden' is\n\t// \"wipe\".\n\tif (!bufref_valid(&bufref))\n\t    curbuf = firstbuf;\n    }\n}\n\n/*\n * Close window \"win\".  Only works for the current tab page.\n * If \"free_buf\" is TRUE related buffer may be unloaded.\n *\n * Called by :quit, :close, :xit, :wq and findtag().\n * Returns FAIL when the window was not closed.\n */\n    int\nwin_close(win_T *win, int free_buf)\n{\n    win_T\t*wp;\n    int\t\tother_buffer = FALSE;\n    int\t\tclose_curwin = FALSE;\n    int\t\tdir;\n    int\t\thelp_window = FALSE;\n    tabpage_T   *prev_curtab = curtab;\n    frame_T\t*win_frame = win->w_frame->fr_parent;\n\n    if (ERROR_IF_POPUP_WINDOW)\n\treturn FAIL;\n\n    if (last_window())\n    {\n\temsg(_(\"E444: Cannot close last window\"));\n\treturn FAIL;\n    }\n\n    if (win->w_closing || (win->w_buffer != NULL\n\t\t\t\t\t       && win->w_buffer->b_locked > 0))\n\treturn FAIL; /* window is already being closed */\n    if (win_unlisted(win))\n    {\n\temsg(_(\"E813: Cannot close autocmd or popup window\"));\n\treturn FAIL;\n    }\n    if ((firstwin == aucmd_win || lastwin == aucmd_win) && one_window())\n    {\n\temsg(_(\"E814: Cannot close window, only autocmd window would remain\"));\n\treturn FAIL;\n    }\n\n    /* When closing the last window in a tab page first go to another tab page\n     * and then close the window and the tab page to avoid that curwin and\n     * curtab are invalid while we are freeing memory. */\n    if (close_last_window_tabpage(win, free_buf, prev_curtab))\n      return FAIL;\n\n    /* When closing the help window, try restoring a snapshot after closing\n     * the window.  Otherwise clear the snapshot, it's now invalid. */\n    if (bt_help(win->w_buffer))\n\thelp_window = TRUE;\n    else\n\tclear_snapshot(curtab, SNAP_HELP_IDX);\n\n    if (win == curwin)\n    {\n#ifdef FEAT_JOB_CHANNEL\n\tleaving_window(curwin);\n#endif\n\t/*\n\t * Guess which window is going to be the new current window.\n\t * This may change because of the autocommands (sigh).\n\t */\n\twp = frame2win(win_altframe(win, NULL));\n\n\t/*\n\t * Be careful: If autocommands delete the window or cause this window\n\t * to be the last one left, return now.\n\t */\n\tif (wp->w_buffer != curbuf)\n\t{\n\t    other_buffer = TRUE;\n\t    win->w_closing = TRUE;\n\t    apply_autocmds(EVENT_BUFLEAVE, NULL, NULL, FALSE, curbuf);\n\t    if (!win_valid(win))\n\t\treturn FAIL;\n\t    win->w_closing = FALSE;\n\t    if (last_window())\n\t\treturn FAIL;\n\t}\n\twin->w_closing = TRUE;\n\tapply_autocmds(EVENT_WINLEAVE, NULL, NULL, FALSE, curbuf);\n\tif (!win_valid(win))\n\t    return FAIL;\n\twin->w_closing = FALSE;\n\tif (last_window())\n\t    return FAIL;\n#ifdef FEAT_EVAL\n\t/* autocmds may abort script processing */\n\tif (aborting())\n\t    return FAIL;\n#endif\n    }\n\n#ifdef FEAT_GUI\n    // Avoid trouble with scrollbars that are going to be deleted in\n    // win_free().\n    if (gui.in_use)\n\tout_flush();\n#endif\n\n#ifdef FEAT_TEXT_PROP\n    if (popup_win_closed(win) && !win_valid(win))\n\treturn FAIL;\n#endif\n    win_close_buffer(win, free_buf ? DOBUF_UNLOAD : 0, TRUE);\n\n    if (only_one_window() && win_valid(win) && win->w_buffer == NULL\n\t    && (last_window() || curtab != prev_curtab\n\t\t|| close_last_window_tabpage(win, free_buf, prev_curtab)))\n    {\n\t/* Autocommands have closed all windows, quit now.  Restore\n\t * curwin->w_buffer, otherwise writing viminfo may fail. */\n\tif (curwin->w_buffer == NULL)\n\t    curwin->w_buffer = curbuf;\n\tgetout(0);\n    }\n\n    /* Autocommands may have moved to another tab page. */\n    if (curtab != prev_curtab && win_valid_any_tab(win)\n\t\t\t\t\t\t      && win->w_buffer == NULL)\n    {\n\t/* Need to close the window anyway, since the buffer is NULL. */\n\twin_close_othertab(win, FALSE, prev_curtab);\n\treturn FAIL;\n    }\n\n    /* Autocommands may have closed the window already or closed the only\n     * other window. */\n    if (!win_valid(win) || last_window()\n\t    || close_last_window_tabpage(win, free_buf, prev_curtab))\n\treturn FAIL;\n\n    // Now we are really going to close the window.  Disallow any autocommand\n    // to split a window to avoid trouble.\n    ++split_disallowed;\n\n    /* Free the memory used for the window and get the window that received\n     * the screen space. */\n    wp = win_free_mem(win, &dir, NULL);\n\n    /* Make sure curwin isn't invalid.  It can cause severe trouble when\n     * printing an error message.  For win_equal() curbuf needs to be valid\n     * too. */\n    if (win == curwin)\n    {\n\tcurwin = wp;\n#ifdef FEAT_QUICKFIX\n\tif (wp->w_p_pvw || bt_quickfix(wp->w_buffer))\n\t{\n\t    /*\n\t     * If the cursor goes to the preview or the quickfix window, try\n\t     * finding another window to go to.\n\t     */\n\t    for (;;)\n\t    {\n\t\tif (wp->w_next == NULL)\n\t\t    wp = firstwin;\n\t\telse\n\t\t    wp = wp->w_next;\n\t\tif (wp == curwin)\n\t\t    break;\n\t\tif (!wp->w_p_pvw && !bt_quickfix(wp->w_buffer))\n\t\t{\n\t\t    curwin = wp;\n\t\t    break;\n\t\t}\n\t    }\n\t}\n#endif\n\tcurbuf = curwin->w_buffer;\n\tclose_curwin = TRUE;\n\n\t/* The cursor position may be invalid if the buffer changed after last\n\t * using the window. */\n\tcheck_cursor();\n    }\n    if (p_ea && (*p_ead == 'b' || *p_ead == dir))\n\t/* If the frame of the closed window contains the new current window,\n\t * only resize that frame.  Otherwise resize all windows. */\n\twin_equal(curwin, curwin->w_frame->fr_parent == win_frame, dir);\n    else\n\twin_comp_pos();\n    if (close_curwin)\n    {\n\twin_enter_ext(wp, FALSE, TRUE, FALSE, TRUE, TRUE);\n\tif (other_buffer)\n\t    /* careful: after this wp and win may be invalid! */\n\t    apply_autocmds(EVENT_BUFENTER, NULL, NULL, FALSE, curbuf);\n    }\n\n    --split_disallowed;\n\n    /*\n     * If last window has a status line now and we don't want one,\n     * remove the status line.\n     */\n    last_status(FALSE);\n\n    /* After closing the help window, try restoring the window layout from\n     * before it was opened. */\n    if (help_window)\n\trestore_snapshot(SNAP_HELP_IDX, close_curwin);\n\n#if defined(FEAT_GUI)\n    /* When 'guioptions' includes 'L' or 'R' may have to remove scrollbars. */\n    if (gui.in_use && !win_hasvertsplit())\n\tgui_init_which_components(NULL);\n#endif\n\n    redraw_all_later(NOT_VALID);\n    return OK;\n}\n\n/*\n * Close window \"win\" in tab page \"tp\", which is not the current tab page.\n * This may be the last window in that tab page and result in closing the tab,\n * thus \"tp\" may become invalid!\n * Caller must check if buffer is hidden and whether the tabline needs to be\n * updated.\n */\n    void\nwin_close_othertab(win_T *win, int free_buf, tabpage_T *tp)\n{\n    win_T\t*wp;\n    int\t\tdir;\n    tabpage_T   *ptp = NULL;\n    int\t\tfree_tp = FALSE;\n\n    /* Get here with win->w_buffer == NULL when win_close() detects the tab\n     * page changed. */\n    if (win->w_closing || (win->w_buffer != NULL\n\t\t\t\t\t       && win->w_buffer->b_locked > 0))\n\treturn; /* window is already being closed */\n\n    if (win->w_buffer != NULL)\n\t/* Close the link to the buffer. */\n\tclose_buffer(win, win->w_buffer, free_buf ? DOBUF_UNLOAD : 0, FALSE);\n\n    /* Careful: Autocommands may have closed the tab page or made it the\n     * current tab page.  */\n    for (ptp = first_tabpage; ptp != NULL && ptp != tp; ptp = ptp->tp_next)\n\t;\n    if (ptp == NULL || tp == curtab)\n\treturn;\n\n    /* Autocommands may have closed the window already. */\n    for (wp = tp->tp_firstwin; wp != NULL && wp != win; wp = wp->w_next)\n\t;\n    if (wp == NULL)\n\treturn;\n\n    /* When closing the last window in a tab page remove the tab page. */\n    if (tp->tp_firstwin == tp->tp_lastwin)\n    {\n\tif (tp == first_tabpage)\n\t    first_tabpage = tp->tp_next;\n\telse\n\t{\n\t    for (ptp = first_tabpage; ptp != NULL && ptp->tp_next != tp;\n\t\t\t\t\t\t\t   ptp = ptp->tp_next)\n\t\t;\n\t    if (ptp == NULL)\n\t    {\n\t\tinternal_error(\"win_close_othertab()\");\n\t\treturn;\n\t    }\n\t    ptp->tp_next = tp->tp_next;\n\t}\n\tfree_tp = TRUE;\n    }\n\n    /* Free the memory used for the window. */\n    win_free_mem(win, &dir, tp);\n\n    if (free_tp)\n\tfree_tabpage(tp);\n}\n\n/*\n * Free the memory used for a window.\n * Returns a pointer to the window that got the freed up space.\n */\n    static win_T *\nwin_free_mem(\n    win_T\t*win,\n    int\t\t*dirp,\t\t/* set to 'v' or 'h' for direction if 'ea' */\n    tabpage_T\t*tp)\t\t/* tab page \"win\" is in, NULL for current */\n{\n    frame_T\t*frp;\n    win_T\t*wp;\n\n    /* Remove the window and its frame from the tree of frames. */\n    frp = win->w_frame;\n    wp = winframe_remove(win, dirp, tp);\n    vim_free(frp);\n    win_free(win, tp);\n\n    /* When deleting the current window of another tab page select a new\n     * current window. */\n    if (tp != NULL && win == tp->tp_curwin)\n\ttp->tp_curwin = wp;\n\n    return wp;\n}\n\n#if defined(EXITFREE) || defined(PROTO)\n    void\nwin_free_all(void)\n{\n    int\t\tdummy;\n\n    while (first_tabpage->tp_next != NULL)\n\ttabpage_close(TRUE);\n\n    if (aucmd_win != NULL)\n    {\n\t(void)win_free_mem(aucmd_win, &dummy, NULL);\n\taucmd_win = NULL;\n    }\n# ifdef FEAT_TEXT_PROP\n    close_all_popups();\n# endif\n\n    while (firstwin != NULL)\n\t(void)win_free_mem(firstwin, &dummy, NULL);\n\n    /* No window should be used after this. Set curwin to NULL to crash\n     * instead of using freed memory. */\n    curwin = NULL;\n}\n#endif\n\n/*\n * Remove a window and its frame from the tree of frames.\n * Returns a pointer to the window that got the freed up space.\n */\n    win_T *\nwinframe_remove(\n    win_T\t*win,\n    int\t\t*dirp UNUSED,\t/* set to 'v' or 'h' for direction if 'ea' */\n    tabpage_T\t*tp)\t\t/* tab page \"win\" is in, NULL for current */\n{\n    frame_T\t*frp, *frp2, *frp3;\n    frame_T\t*frp_close = win->w_frame;\n    win_T\t*wp;\n\n    /*\n     * If there is only one window there is nothing to remove.\n     */\n    if (tp == NULL ? ONE_WINDOW : tp->tp_firstwin == tp->tp_lastwin)\n\treturn NULL;\n\n    /*\n     * Remove the window from its frame.\n     */\n    frp2 = win_altframe(win, tp);\n    wp = frame2win(frp2);\n\n    /* Remove this frame from the list of frames. */\n    frame_remove(frp_close);\n\n    if (frp_close->fr_parent->fr_layout == FR_COL)\n    {\n\t/* When 'winfixheight' is set, try to find another frame in the column\n\t * (as close to the closed frame as possible) to distribute the height\n\t * to. */\n\tif (frp2->fr_win != NULL && frp2->fr_win->w_p_wfh)\n\t{\n\t    frp = frp_close->fr_prev;\n\t    frp3 = frp_close->fr_next;\n\t    while (frp != NULL || frp3 != NULL)\n\t    {\n\t\tif (frp != NULL)\n\t\t{\n\t\t    if (!frame_fixed_height(frp))\n\t\t    {\n\t\t\tfrp2 = frp;\n\t\t\twp = frame2win(frp2);\n\t\t\tbreak;\n\t\t    }\n\t\t    frp = frp->fr_prev;\n\t\t}\n\t\tif (frp3 != NULL)\n\t\t{\n\t\t    if (frp3->fr_win != NULL && !frp3->fr_win->w_p_wfh)\n\t\t    {\n\t\t\tfrp2 = frp3;\n\t\t\twp = frp3->fr_win;\n\t\t\tbreak;\n\t\t    }\n\t\t    frp3 = frp3->fr_next;\n\t\t}\n\t    }\n\t}\n\tframe_new_height(frp2, frp2->fr_height + frp_close->fr_height,\n\t\t\t    frp2 == frp_close->fr_next ? TRUE : FALSE, FALSE);\n\t*dirp = 'v';\n    }\n    else\n    {\n\t/* When 'winfixwidth' is set, try to find another frame in the column\n\t * (as close to the closed frame as possible) to distribute the width\n\t * to. */\n\tif (frp2->fr_win != NULL && frp2->fr_win->w_p_wfw)\n\t{\n\t    frp = frp_close->fr_prev;\n\t    frp3 = frp_close->fr_next;\n\t    while (frp != NULL || frp3 != NULL)\n\t    {\n\t\tif (frp != NULL)\n\t\t{\n\t\t    if (!frame_fixed_width(frp))\n\t\t    {\n\t\t\tfrp2 = frp;\n\t\t\twp = frame2win(frp2);\n\t\t\tbreak;\n\t\t    }\n\t\t    frp = frp->fr_prev;\n\t\t}\n\t\tif (frp3 != NULL)\n\t\t{\n\t\t    if (frp3->fr_win != NULL && !frp3->fr_win->w_p_wfw)\n\t\t    {\n\t\t\tfrp2 = frp3;\n\t\t\twp = frp3->fr_win;\n\t\t\tbreak;\n\t\t    }\n\t\t    frp3 = frp3->fr_next;\n\t\t}\n\t    }\n\t}\n\tframe_new_width(frp2, frp2->fr_width + frp_close->fr_width,\n\t\t\t    frp2 == frp_close->fr_next ? TRUE : FALSE, FALSE);\n\t*dirp = 'h';\n    }\n\n    /* If rows/columns go to a window below/right its positions need to be\n     * updated.  Can only be done after the sizes have been updated. */\n    if (frp2 == frp_close->fr_next)\n    {\n\tint row = win->w_winrow;\n\tint col = win->w_wincol;\n\n\tframe_comp_pos(frp2, &row, &col);\n    }\n\n    if (frp2->fr_next == NULL && frp2->fr_prev == NULL)\n    {\n\t/* There is no other frame in this list, move its info to the parent\n\t * and remove it. */\n\tfrp2->fr_parent->fr_layout = frp2->fr_layout;\n\tfrp2->fr_parent->fr_child = frp2->fr_child;\n\tFOR_ALL_FRAMES(frp, frp2->fr_child)\n\t    frp->fr_parent = frp2->fr_parent;\n\tfrp2->fr_parent->fr_win = frp2->fr_win;\n\tif (frp2->fr_win != NULL)\n\t    frp2->fr_win->w_frame = frp2->fr_parent;\n\tfrp = frp2->fr_parent;\n\tif (topframe->fr_child == frp2)\n\t    topframe->fr_child = frp;\n\tvim_free(frp2);\n\n\tfrp2 = frp->fr_parent;\n\tif (frp2 != NULL && frp2->fr_layout == frp->fr_layout)\n\t{\n\t    /* The frame above the parent has the same layout, have to merge\n\t     * the frames into this list. */\n\t    if (frp2->fr_child == frp)\n\t\tfrp2->fr_child = frp->fr_child;\n\t    frp->fr_child->fr_prev = frp->fr_prev;\n\t    if (frp->fr_prev != NULL)\n\t\tfrp->fr_prev->fr_next = frp->fr_child;\n\t    for (frp3 = frp->fr_child; ; frp3 = frp3->fr_next)\n\t    {\n\t\tfrp3->fr_parent = frp2;\n\t\tif (frp3->fr_next == NULL)\n\t\t{\n\t\t    frp3->fr_next = frp->fr_next;\n\t\t    if (frp->fr_next != NULL)\n\t\t\tfrp->fr_next->fr_prev = frp3;\n\t\t    break;\n\t\t}\n\t    }\n\t    if (topframe->fr_child == frp)\n\t\ttopframe->fr_child = frp2;\n\t    vim_free(frp);\n\t}\n    }\n\n    return wp;\n}\n\n/*\n * Return a pointer to the frame that will receive the empty screen space that\n * is left over after \"win\" is closed.\n *\n * If 'splitbelow' or 'splitright' is set, the space goes above or to the left\n * by default.  Otherwise, the free space goes below or to the right.  The\n * result is that opening a window and then immediately closing it will\n * preserve the initial window layout.  The 'wfh' and 'wfw' settings are\n * respected when possible.\n */\n    static frame_T *\nwin_altframe(\n    win_T\t*win,\n    tabpage_T\t*tp)\t\t/* tab page \"win\" is in, NULL for current */\n{\n    frame_T\t*frp;\n    frame_T\t*other_fr, *target_fr;\n\n    if (tp == NULL ? ONE_WINDOW : tp->tp_firstwin == tp->tp_lastwin)\n\treturn alt_tabpage()->tp_curwin->w_frame;\n\n    frp = win->w_frame;\n\n    if (frp->fr_prev == NULL)\n\treturn frp->fr_next;\n    if (frp->fr_next == NULL)\n\treturn frp->fr_prev;\n\n    target_fr = frp->fr_next;\n    other_fr  = frp->fr_prev;\n    if (p_spr || p_sb)\n    {\n\ttarget_fr = frp->fr_prev;\n\tother_fr  = frp->fr_next;\n    }\n\n    /* If 'wfh' or 'wfw' is set for the target and not for the alternate\n     * window, reverse the selection. */\n    if (frp->fr_parent != NULL && frp->fr_parent->fr_layout == FR_ROW)\n    {\n\tif (frame_fixed_width(target_fr) && !frame_fixed_width(other_fr))\n\t    target_fr = other_fr;\n    }\n    else\n    {\n\tif (frame_fixed_height(target_fr) && !frame_fixed_height(other_fr))\n\t    target_fr = other_fr;\n    }\n\n    return target_fr;\n}\n\n/*\n * Return the tabpage that will be used if the current one is closed.\n */\n    static tabpage_T *\nalt_tabpage(void)\n{\n    tabpage_T\t*tp;\n\n    /* Use the next tab page if possible. */\n    if (curtab->tp_next != NULL)\n\treturn curtab->tp_next;\n\n    /* Find the last but one tab page. */\n    for (tp = first_tabpage; tp->tp_next != curtab; tp = tp->tp_next)\n\t;\n    return tp;\n}\n\n/*\n * Find the left-upper window in frame \"frp\".\n */\n    static win_T *\nframe2win(frame_T *frp)\n{\n    while (frp->fr_win == NULL)\n\tfrp = frp->fr_child;\n    return frp->fr_win;\n}\n\n/*\n * Return TRUE if frame \"frp\" contains window \"wp\".\n */\n    static int\nframe_has_win(frame_T *frp, win_T *wp)\n{\n    frame_T\t*p;\n\n    if (frp->fr_layout == FR_LEAF)\n\treturn frp->fr_win == wp;\n\n    FOR_ALL_FRAMES(p, frp->fr_child)\n\tif (frame_has_win(p, wp))\n\t    return TRUE;\n    return FALSE;\n}\n\n/*\n * Set a new height for a frame.  Recursively sets the height for contained\n * frames and windows.  Caller must take care of positions.\n */\n    static void\nframe_new_height(\n    frame_T\t*topfrp,\n    int\t\theight,\n    int\t\ttopfirst,\t/* resize topmost contained frame first */\n    int\t\twfh)\t\t/* obey 'winfixheight' when there is a choice;\n\t\t\t\t   may cause the height not to be set */\n{\n    frame_T\t*frp;\n    int\t\textra_lines;\n    int\t\th;\n\n    if (topfrp->fr_win != NULL)\n    {\n\t/* Simple case: just one window. */\n\twin_new_height(topfrp->fr_win,\n\t\t\t\t    height - topfrp->fr_win->w_status_height\n\t\t\t\t\t      - WINBAR_HEIGHT(topfrp->fr_win));\n    }\n    else if (topfrp->fr_layout == FR_ROW)\n    {\n\tdo\n\t{\n\t    /* All frames in this row get the same new height. */\n\t    FOR_ALL_FRAMES(frp, topfrp->fr_child)\n\t    {\n\t\tframe_new_height(frp, height, topfirst, wfh);\n\t\tif (frp->fr_height > height)\n\t\t{\n\t\t    /* Could not fit the windows, make the whole row higher. */\n\t\t    height = frp->fr_height;\n\t\t    break;\n\t\t}\n\t    }\n\t}\n\twhile (frp != NULL);\n    }\n    else    /* fr_layout == FR_COL */\n    {\n\t/* Complicated case: Resize a column of frames.  Resize the bottom\n\t * frame first, frames above that when needed. */\n\n\tfrp = topfrp->fr_child;\n\tif (wfh)\n\t    /* Advance past frames with one window with 'wfh' set. */\n\t    while (frame_fixed_height(frp))\n\t    {\n\t\tfrp = frp->fr_next;\n\t\tif (frp == NULL)\n\t\t    return;\t    /* no frame without 'wfh', give up */\n\t    }\n\tif (!topfirst)\n\t{\n\t    /* Find the bottom frame of this column */\n\t    while (frp->fr_next != NULL)\n\t\tfrp = frp->fr_next;\n\t    if (wfh)\n\t\t/* Advance back for frames with one window with 'wfh' set. */\n\t\twhile (frame_fixed_height(frp))\n\t\t    frp = frp->fr_prev;\n\t}\n\n\textra_lines = height - topfrp->fr_height;\n\tif (extra_lines < 0)\n\t{\n\t    /* reduce height of contained frames, bottom or top frame first */\n\t    while (frp != NULL)\n\t    {\n\t\th = frame_minheight(frp, NULL);\n\t\tif (frp->fr_height + extra_lines < h)\n\t\t{\n\t\t    extra_lines += frp->fr_height - h;\n\t\t    frame_new_height(frp, h, topfirst, wfh);\n\t\t}\n\t\telse\n\t\t{\n\t\t    frame_new_height(frp, frp->fr_height + extra_lines,\n\t\t\t\t\t\t\t       topfirst, wfh);\n\t\t    break;\n\t\t}\n\t\tif (topfirst)\n\t\t{\n\t\t    do\n\t\t\tfrp = frp->fr_next;\n\t\t    while (wfh && frp != NULL && frame_fixed_height(frp));\n\t\t}\n\t\telse\n\t\t{\n\t\t    do\n\t\t\tfrp = frp->fr_prev;\n\t\t    while (wfh && frp != NULL && frame_fixed_height(frp));\n\t\t}\n\t\t/* Increase \"height\" if we could not reduce enough frames. */\n\t\tif (frp == NULL)\n\t\t    height -= extra_lines;\n\t    }\n\t}\n\telse if (extra_lines > 0)\n\t{\n\t    /* increase height of bottom or top frame */\n\t    frame_new_height(frp, frp->fr_height + extra_lines, topfirst, wfh);\n\t}\n    }\n    topfrp->fr_height = height;\n}\n\n/*\n * Return TRUE if height of frame \"frp\" should not be changed because of\n * the 'winfixheight' option.\n */\n    static int\nframe_fixed_height(frame_T *frp)\n{\n    /* frame with one window: fixed height if 'winfixheight' set. */\n    if (frp->fr_win != NULL)\n\treturn frp->fr_win->w_p_wfh;\n\n    if (frp->fr_layout == FR_ROW)\n    {\n\t/* The frame is fixed height if one of the frames in the row is fixed\n\t * height. */\n\tFOR_ALL_FRAMES(frp, frp->fr_child)\n\t    if (frame_fixed_height(frp))\n\t\treturn TRUE;\n\treturn FALSE;\n    }\n\n    /* frp->fr_layout == FR_COL: The frame is fixed height if all of the\n     * frames in the row are fixed height. */\n    FOR_ALL_FRAMES(frp, frp->fr_child)\n\tif (!frame_fixed_height(frp))\n\t    return FALSE;\n    return TRUE;\n}\n\n/*\n * Return TRUE if width of frame \"frp\" should not be changed because of\n * the 'winfixwidth' option.\n */\n    static int\nframe_fixed_width(frame_T *frp)\n{\n    /* frame with one window: fixed width if 'winfixwidth' set. */\n    if (frp->fr_win != NULL)\n\treturn frp->fr_win->w_p_wfw;\n\n    if (frp->fr_layout == FR_COL)\n    {\n\t/* The frame is fixed width if one of the frames in the row is fixed\n\t * width. */\n\tFOR_ALL_FRAMES(frp, frp->fr_child)\n\t    if (frame_fixed_width(frp))\n\t\treturn TRUE;\n\treturn FALSE;\n    }\n\n    /* frp->fr_layout == FR_ROW: The frame is fixed width if all of the\n     * frames in the row are fixed width. */\n    FOR_ALL_FRAMES(frp, frp->fr_child)\n\tif (!frame_fixed_width(frp))\n\t    return FALSE;\n    return TRUE;\n}\n\n/*\n * Add a status line to windows at the bottom of \"frp\".\n * Note: Does not check if there is room!\n */\n    static void\nframe_add_statusline(frame_T *frp)\n{\n    win_T\t*wp;\n\n    if (frp->fr_layout == FR_LEAF)\n    {\n\twp = frp->fr_win;\n\tif (wp->w_status_height == 0)\n\t{\n\t    if (wp->w_height > 0)\t/* don't make it negative */\n\t\t--wp->w_height;\n\t    wp->w_status_height = STATUS_HEIGHT;\n\t}\n    }\n    else if (frp->fr_layout == FR_ROW)\n    {\n\t/* Handle all the frames in the row. */\n\tFOR_ALL_FRAMES(frp, frp->fr_child)\n\t    frame_add_statusline(frp);\n    }\n    else /* frp->fr_layout == FR_COL */\n    {\n\t/* Only need to handle the last frame in the column. */\n\tfor (frp = frp->fr_child; frp->fr_next != NULL; frp = frp->fr_next)\n\t    ;\n\tframe_add_statusline(frp);\n    }\n}\n\n/*\n * Set width of a frame.  Handles recursively going through contained frames.\n * May remove separator line for windows at the right side (for win_close()).\n */\n    static void\nframe_new_width(\n    frame_T\t*topfrp,\n    int\t\twidth,\n    int\t\tleftfirst,\t/* resize leftmost contained frame first */\n    int\t\twfw)\t\t/* obey 'winfixwidth' when there is a choice;\n\t\t\t\t   may cause the width not to be set */\n{\n    frame_T\t*frp;\n    int\t\textra_cols;\n    int\t\tw;\n    win_T\t*wp;\n\n    if (topfrp->fr_layout == FR_LEAF)\n    {\n\t/* Simple case: just one window. */\n\twp = topfrp->fr_win;\n\t/* Find out if there are any windows right of this one. */\n\tfor (frp = topfrp; frp->fr_parent != NULL; frp = frp->fr_parent)\n\t    if (frp->fr_parent->fr_layout == FR_ROW && frp->fr_next != NULL)\n\t\tbreak;\n\tif (frp->fr_parent == NULL)\n\t    wp->w_vsep_width = 0;\n\twin_new_width(wp, width - wp->w_vsep_width);\n    }\n    else if (topfrp->fr_layout == FR_COL)\n    {\n\tdo\n\t{\n\t    /* All frames in this column get the same new width. */\n\t    FOR_ALL_FRAMES(frp, topfrp->fr_child)\n\t    {\n\t\tframe_new_width(frp, width, leftfirst, wfw);\n\t\tif (frp->fr_width > width)\n\t\t{\n\t\t    /* Could not fit the windows, make whole column wider. */\n\t\t    width = frp->fr_width;\n\t\t    break;\n\t\t}\n\t    }\n\t} while (frp != NULL);\n    }\n    else    /* fr_layout == FR_ROW */\n    {\n\t/* Complicated case: Resize a row of frames.  Resize the rightmost\n\t * frame first, frames left of it when needed. */\n\n\tfrp = topfrp->fr_child;\n\tif (wfw)\n\t    /* Advance past frames with one window with 'wfw' set. */\n\t    while (frame_fixed_width(frp))\n\t    {\n\t\tfrp = frp->fr_next;\n\t\tif (frp == NULL)\n\t\t    return;\t    /* no frame without 'wfw', give up */\n\t    }\n\tif (!leftfirst)\n\t{\n\t    /* Find the rightmost frame of this row */\n\t    while (frp->fr_next != NULL)\n\t\tfrp = frp->fr_next;\n\t    if (wfw)\n\t\t/* Advance back for frames with one window with 'wfw' set. */\n\t\twhile (frame_fixed_width(frp))\n\t\t    frp = frp->fr_prev;\n\t}\n\n\textra_cols = width - topfrp->fr_width;\n\tif (extra_cols < 0)\n\t{\n\t    /* reduce frame width, rightmost frame first */\n\t    while (frp != NULL)\n\t    {\n\t\tw = frame_minwidth(frp, NULL);\n\t\tif (frp->fr_width + extra_cols < w)\n\t\t{\n\t\t    extra_cols += frp->fr_width - w;\n\t\t    frame_new_width(frp, w, leftfirst, wfw);\n\t\t}\n\t\telse\n\t\t{\n\t\t    frame_new_width(frp, frp->fr_width + extra_cols,\n\t\t\t\t\t\t\t      leftfirst, wfw);\n\t\t    break;\n\t\t}\n\t\tif (leftfirst)\n\t\t{\n\t\t    do\n\t\t\tfrp = frp->fr_next;\n\t\t    while (wfw && frp != NULL && frame_fixed_width(frp));\n\t\t}\n\t\telse\n\t\t{\n\t\t    do\n\t\t\tfrp = frp->fr_prev;\n\t\t    while (wfw && frp != NULL && frame_fixed_width(frp));\n\t\t}\n\t\t/* Increase \"width\" if we could not reduce enough frames. */\n\t\tif (frp == NULL)\n\t\t    width -= extra_cols;\n\t    }\n\t}\n\telse if (extra_cols > 0)\n\t{\n\t    /* increase width of rightmost frame */\n\t    frame_new_width(frp, frp->fr_width + extra_cols, leftfirst, wfw);\n\t}\n    }\n    topfrp->fr_width = width;\n}\n\n/*\n * Add the vertical separator to windows at the right side of \"frp\".\n * Note: Does not check if there is room!\n */\n    static void\nframe_add_vsep(frame_T *frp)\n{\n    win_T\t*wp;\n\n    if (frp->fr_layout == FR_LEAF)\n    {\n\twp = frp->fr_win;\n\tif (wp->w_vsep_width == 0)\n\t{\n\t    if (wp->w_width > 0)\t/* don't make it negative */\n\t\t--wp->w_width;\n\t    wp->w_vsep_width = 1;\n\t}\n    }\n    else if (frp->fr_layout == FR_COL)\n    {\n\t/* Handle all the frames in the column. */\n\tFOR_ALL_FRAMES(frp, frp->fr_child)\n\t    frame_add_vsep(frp);\n    }\n    else /* frp->fr_layout == FR_ROW */\n    {\n\t/* Only need to handle the last frame in the row. */\n\tfrp = frp->fr_child;\n\twhile (frp->fr_next != NULL)\n\t    frp = frp->fr_next;\n\tframe_add_vsep(frp);\n    }\n}\n\n/*\n * Set frame width from the window it contains.\n */\n    static void\nframe_fix_width(win_T *wp)\n{\n    wp->w_frame->fr_width = wp->w_width + wp->w_vsep_width;\n}\n\n/*\n * Set frame height from the window it contains.\n */\n    static void\nframe_fix_height(win_T *wp)\n{\n    wp->w_frame->fr_height = VISIBLE_HEIGHT(wp) + wp->w_status_height;\n}\n\n/*\n * Compute the minimal height for frame \"topfrp\".\n * Uses the 'winminheight' option.\n * When \"next_curwin\" isn't NULL, use p_wh for this window.\n * When \"next_curwin\" is NOWIN, don't use at least one line for the current\n * window.\n */\n    static int\nframe_minheight(frame_T *topfrp, win_T *next_curwin)\n{\n    frame_T\t*frp;\n    int\t\tm;\n    int\t\tn;\n\n    if (topfrp->fr_win != NULL)\n    {\n\tif (topfrp->fr_win == next_curwin)\n\t    m = p_wh + topfrp->fr_win->w_status_height;\n\telse\n\t{\n\t    /* window: minimal height of the window plus status line */\n\t    m = p_wmh + topfrp->fr_win->w_status_height;\n\t    if (topfrp->fr_win == curwin && next_curwin == NULL)\n\t    {\n\t\t/* Current window is minimal one line high and WinBar is\n\t\t * visible. */\n\t\tif (p_wmh == 0)\n\t\t    ++m;\n\t\tm += WINBAR_HEIGHT(curwin);\n\t    }\n\t}\n    }\n    else if (topfrp->fr_layout == FR_ROW)\n    {\n\t/* get the minimal height from each frame in this row */\n\tm = 0;\n\tFOR_ALL_FRAMES(frp, topfrp->fr_child)\n\t{\n\t    n = frame_minheight(frp, next_curwin);\n\t    if (n > m)\n\t\tm = n;\n\t}\n    }\n    else\n    {\n\t/* Add up the minimal heights for all frames in this column. */\n\tm = 0;\n\tFOR_ALL_FRAMES(frp, topfrp->fr_child)\n\t    m += frame_minheight(frp, next_curwin);\n    }\n\n    return m;\n}\n\n/*\n * Compute the minimal width for frame \"topfrp\".\n * When \"next_curwin\" isn't NULL, use p_wiw for this window.\n * When \"next_curwin\" is NOWIN, don't use at least one column for the current\n * window.\n */\n    static int\nframe_minwidth(\n    frame_T\t*topfrp,\n    win_T\t*next_curwin)\t/* use p_wh and p_wiw for next_curwin */\n{\n    frame_T\t*frp;\n    int\t\tm, n;\n\n    if (topfrp->fr_win != NULL)\n    {\n\tif (topfrp->fr_win == next_curwin)\n\t    m = p_wiw + topfrp->fr_win->w_vsep_width;\n\telse\n\t{\n\t    /* window: minimal width of the window plus separator column */\n\t    m = p_wmw + topfrp->fr_win->w_vsep_width;\n\t    /* Current window is minimal one column wide */\n\t    if (p_wmw == 0 && topfrp->fr_win == curwin && next_curwin == NULL)\n\t\t++m;\n\t}\n    }\n    else if (topfrp->fr_layout == FR_COL)\n    {\n\t/* get the minimal width from each frame in this column */\n\tm = 0;\n\tFOR_ALL_FRAMES(frp, topfrp->fr_child)\n\t{\n\t    n = frame_minwidth(frp, next_curwin);\n\t    if (n > m)\n\t\tm = n;\n\t}\n    }\n    else\n    {\n\t/* Add up the minimal widths for all frames in this row. */\n\tm = 0;\n\tFOR_ALL_FRAMES(frp, topfrp->fr_child)\n\t    m += frame_minwidth(frp, next_curwin);\n    }\n\n    return m;\n}\n\n\n/*\n * Try to close all windows except current one.\n * Buffers in the other windows become hidden if 'hidden' is set, or '!' is\n * used and the buffer was modified.\n *\n * Used by \":bdel\" and \":only\".\n */\n    void\nclose_others(\n    int\t\tmessage,\n    int\t\tforceit)\t    /* always hide all other windows */\n{\n    win_T\t*wp;\n    win_T\t*nextwp;\n    int\t\tr;\n\n    if (one_window())\n    {\n\tif (message && !autocmd_busy)\n\t    msg(_(m_onlyone));\n\treturn;\n    }\n\n    /* Be very careful here: autocommands may change the window layout. */\n    for (wp = firstwin; win_valid(wp); wp = nextwp)\n    {\n\tnextwp = wp->w_next;\n\tif (wp != curwin)\t\t/* don't close current window */\n\t{\n\n\t    /* Check if it's allowed to abandon this window */\n\t    r = can_abandon(wp->w_buffer, forceit);\n\t    if (!win_valid(wp))\t\t/* autocommands messed wp up */\n\t    {\n\t\tnextwp = firstwin;\n\t\tcontinue;\n\t    }\n\t    if (!r)\n\t    {\n#if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)\n\t\tif (message && (p_confirm || cmdmod.confirm) && p_write)\n\t\t{\n\t\t    dialog_changed(wp->w_buffer, FALSE);\n\t\t    if (!win_valid(wp))\t\t/* autocommands messed wp up */\n\t\t    {\n\t\t\tnextwp = firstwin;\n\t\t\tcontinue;\n\t\t    }\n\t\t}\n\t\tif (bufIsChanged(wp->w_buffer))\n#endif\n\t\t    continue;\n\t    }\n\t    win_close(wp, !buf_hide(wp->w_buffer)\n\t\t\t\t\t       && !bufIsChanged(wp->w_buffer));\n\t}\n    }\n\n    if (message && !ONE_WINDOW)\n\temsg(_(\"E445: Other window contains changes\"));\n}\n\n    static void\nwin_init_empty(win_T *wp)\n{\n    redraw_win_later(wp, NOT_VALID);\n    wp->w_lines_valid = 0;\n    wp->w_cursor.lnum = 1;\n    wp->w_curswant = wp->w_cursor.col = 0;\n    wp->w_cursor.coladd = 0;\n    wp->w_pcmark.lnum = 1;\t/* pcmark not cleared but set to line 1 */\n    wp->w_pcmark.col = 0;\n    wp->w_prev_pcmark.lnum = 0;\n    wp->w_prev_pcmark.col = 0;\n    wp->w_topline = 1;\n#ifdef FEAT_DIFF\n    wp->w_topfill = 0;\n#endif\n    wp->w_botline = 2;\n#if defined(FEAT_SYN_HL) || defined(FEAT_SPELL)\n    wp->w_s = &wp->w_buffer->b_s;\n#endif\n}\n\n/*\n * Init the current window \"curwin\".\n * Called when a new file is being edited.\n */\n    void\ncurwin_init(void)\n{\n    win_init_empty(curwin);\n}\n\n/*\n * Allocate the first window and put an empty buffer in it.\n * Called from main().\n * Return FAIL when something goes wrong (out of memory).\n */\n    int\nwin_alloc_first(void)\n{\n    if (win_alloc_firstwin(NULL) == FAIL)\n\treturn FAIL;\n\n    first_tabpage = alloc_tabpage();\n    if (first_tabpage == NULL)\n\treturn FAIL;\n    first_tabpage->tp_topframe = topframe;\n    curtab = first_tabpage;\n\n    return OK;\n}\n\n/*\n * Allocate and init a window that is not a regular window.\n * This can only be done after the first window is fully initialized, thus it\n * can't be in win_alloc_first().\n */\n    win_T *\nwin_alloc_popup_win(void)\n{\n    win_T *wp;\n\n    wp = win_alloc(NULL, TRUE);\n    if (wp != NULL)\n    {\n\t// We need to initialize options with something, using the current\n\t// window makes most sense.\n\twin_init_some(wp, curwin);\n\n\tRESET_BINDING(wp);\n\tnew_frame(wp);\n    }\n    return wp;\n}\n\n/*\n * Initialize window \"wp\" to display buffer \"buf\".\n */\n    void\nwin_init_popup_win(win_T *wp, buf_T *buf)\n{\n    wp->w_buffer = buf;\n    ++buf->b_nwindows;\n    win_init_empty(wp); // set cursor and topline to safe values\n\n    // Make sure w_localdir and globaldir are NULL to avoid a chdir() in\n    // win_enter_ext().\n    VIM_CLEAR(wp->w_localdir);\n}\n\n/*\n * Allocate the first window or the first window in a new tab page.\n * When \"oldwin\" is NULL create an empty buffer for it.\n * When \"oldwin\" is not NULL copy info from it to the new window.\n * Return FAIL when something goes wrong (out of memory).\n */\n    static int\nwin_alloc_firstwin(win_T *oldwin)\n{\n    curwin = win_alloc(NULL, FALSE);\n    if (oldwin == NULL)\n    {\n\t/* Very first window, need to create an empty buffer for it and\n\t * initialize from scratch. */\n\tcurbuf = buflist_new(NULL, NULL, 1L, BLN_LISTED);\n\tif (curwin == NULL || curbuf == NULL)\n\t    return FAIL;\n\tcurwin->w_buffer = curbuf;\n#ifdef FEAT_SYN_HL\n\tcurwin->w_s = &(curbuf->b_s);\n#endif\n\tcurbuf->b_nwindows = 1;\t/* there is one window */\n\tcurwin->w_alist = &global_alist;\n\tcurwin_init();\t\t/* init current window */\n    }\n    else\n    {\n\t/* First window in new tab page, initialize it from \"oldwin\". */\n\twin_init(curwin, oldwin, 0);\n\n\t/* We don't want cursor- and scroll-binding in the first window. */\n\tRESET_BINDING(curwin);\n    }\n\n    new_frame(curwin);\n    if (curwin->w_frame == NULL)\n\treturn FAIL;\n    topframe = curwin->w_frame;\n    topframe->fr_width = Columns;\n    topframe->fr_height = Rows - p_ch;\n\n    return OK;\n}\n\n/*\n * Create a frame for window \"wp\".\n */\n    static void\nnew_frame(win_T *wp)\n{\n    frame_T *frp = ALLOC_CLEAR_ONE(frame_T);\n\n    wp->w_frame = frp;\n    if (frp != NULL)\n    {\n\tfrp->fr_layout = FR_LEAF;\n\tfrp->fr_win = wp;\n    }\n}\n\n/*\n * Initialize the window and frame size to the maximum.\n */\n    void\nwin_init_size(void)\n{\n    firstwin->w_height = ROWS_AVAIL;\n    topframe->fr_height = ROWS_AVAIL;\n    firstwin->w_width = Columns;\n    topframe->fr_width = Columns;\n}\n\n/*\n * Allocate a new tabpage_T and init the values.\n * Returns NULL when out of memory.\n */\n    static tabpage_T *\nalloc_tabpage(void)\n{\n    tabpage_T\t*tp;\n# ifdef FEAT_GUI\n    int\t\ti;\n# endif\n\n\n    tp = ALLOC_CLEAR_ONE(tabpage_T);\n    if (tp == NULL)\n\treturn NULL;\n\n# ifdef FEAT_EVAL\n    /* init t: variables */\n    tp->tp_vars = dict_alloc();\n    if (tp->tp_vars == NULL)\n    {\n\tvim_free(tp);\n\treturn NULL;\n    }\n    init_var_dict(tp->tp_vars, &tp->tp_winvar, VAR_SCOPE);\n# endif\n\n# ifdef FEAT_GUI\n    for (i = 0; i < 3; i++)\n\ttp->tp_prev_which_scrollbars[i] = -1;\n# endif\n# ifdef FEAT_DIFF\n    tp->tp_diff_invalid = TRUE;\n# endif\n    tp->tp_ch_used = p_ch;\n\n    return tp;\n}\n\n    void\nfree_tabpage(tabpage_T *tp)\n{\n    int idx;\n\n# ifdef FEAT_DIFF\n    diff_clear(tp);\n# endif\n# ifdef FEAT_TEXT_PROP\n    while (tp->tp_first_popupwin != NULL)\n\tpopup_close_tabpage(tp, tp->tp_first_popupwin->w_id);\n#endif\n    for (idx = 0; idx < SNAP_COUNT; ++idx)\n\tclear_snapshot(tp, idx);\n#ifdef FEAT_EVAL\n    vars_clear(&tp->tp_vars->dv_hashtab);\t/* free all t: variables */\n    hash_init(&tp->tp_vars->dv_hashtab);\n    unref_var_dict(tp->tp_vars);\n#endif\n\n    vim_free(tp->tp_localdir);\n\n#ifdef FEAT_PYTHON\n    python_tabpage_free(tp);\n#endif\n\n#ifdef FEAT_PYTHON3\n    python3_tabpage_free(tp);\n#endif\n\n    vim_free(tp);\n}\n\n/*\n * Create a new Tab page with one window.\n * It will edit the current buffer, like after \":split\".\n * When \"after\" is 0 put it just after the current Tab page.\n * Otherwise put it just before tab page \"after\".\n * Return FAIL or OK.\n */\n    int\nwin_new_tabpage(int after)\n{\n    tabpage_T\t*tp = curtab;\n    tabpage_T\t*newtp;\n    int\t\tn;\n\n    newtp = alloc_tabpage();\n    if (newtp == NULL)\n\treturn FAIL;\n\n    /* Remember the current windows in this Tab page. */\n    if (leave_tabpage(curbuf, TRUE) == FAIL)\n    {\n\tvim_free(newtp);\n\treturn FAIL;\n    }\n    curtab = newtp;\n\n    newtp->tp_localdir = (tp->tp_localdir == NULL)\n\t\t\t\t    ? NULL : vim_strsave(tp->tp_localdir);\n    /* Create a new empty window. */\n    if (win_alloc_firstwin(tp->tp_curwin) == OK)\n    {\n\t/* Make the new Tab page the new topframe. */\n\tif (after == 1)\n\t{\n\t    /* New tab page becomes the first one. */\n\t    newtp->tp_next = first_tabpage;\n\t    first_tabpage = newtp;\n\t}\n\telse\n\t{\n\t    if (after > 0)\n\t    {\n\t\t/* Put new tab page before tab page \"after\". */\n\t\tn = 2;\n\t\tfor (tp = first_tabpage; tp->tp_next != NULL\n\t\t\t\t\t       && n < after; tp = tp->tp_next)\n\t\t    ++n;\n\t    }\n\t    newtp->tp_next = tp->tp_next;\n\t    tp->tp_next = newtp;\n\t}\n\twin_init_size();\n\tfirstwin->w_winrow = tabline_height();\n\twin_comp_scroll(curwin);\n\n\tnewtp->tp_topframe = topframe;\n\tlast_status(FALSE);\n\n#if defined(FEAT_GUI)\n\t/* When 'guioptions' includes 'L' or 'R' may have to remove or add\n\t * scrollbars.  Have to update them anyway. */\n\tgui_may_update_scrollbars();\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\tentering_window(curwin);\n#endif\n\n\tredraw_all_later(NOT_VALID);\n\tapply_autocmds(EVENT_WINNEW, NULL, NULL, FALSE, curbuf);\n\tapply_autocmds(EVENT_WINENTER, NULL, NULL, FALSE, curbuf);\n\tapply_autocmds(EVENT_TABNEW, NULL, NULL, FALSE, curbuf);\n\tapply_autocmds(EVENT_TABENTER, NULL, NULL, FALSE, curbuf);\n\treturn OK;\n    }\n\n    /* Failed, get back the previous Tab page */\n    enter_tabpage(curtab, curbuf, TRUE, TRUE);\n    return FAIL;\n}\n\n/*\n * Open a new tab page if \":tab cmd\" was used.  It will edit the same buffer,\n * like with \":split\".\n * Returns OK if a new tab page was created, FAIL otherwise.\n */\n    static int\nmay_open_tabpage(void)\n{\n    int\t\tn = (cmdmod.tab == 0) ? postponed_split_tab : cmdmod.tab;\n\n    if (n != 0)\n    {\n\tcmdmod.tab = 0;\t    /* reset it to avoid doing it twice */\n\tpostponed_split_tab = 0;\n\treturn win_new_tabpage(n);\n    }\n    return FAIL;\n}\n\n/*\n * Create up to \"maxcount\" tabpages with empty windows.\n * Returns the number of resulting tab pages.\n */\n    int\nmake_tabpages(int maxcount)\n{\n    int\t\tcount = maxcount;\n    int\t\ttodo;\n\n    /* Limit to 'tabpagemax' tabs. */\n    if (count > p_tpm)\n\tcount = p_tpm;\n\n    /*\n     * Don't execute autocommands while creating the tab pages.  Must do that\n     * when putting the buffers in the windows.\n     */\n    block_autocmds();\n\n    for (todo = count - 1; todo > 0; --todo)\n\tif (win_new_tabpage(0) == FAIL)\n\t    break;\n\n    unblock_autocmds();\n\n    /* return actual number of tab pages */\n    return (count - todo);\n}\n\n/*\n * Return TRUE when \"tpc\" points to a valid tab page.\n */\n    int\nvalid_tabpage(tabpage_T *tpc)\n{\n    tabpage_T\t*tp;\n\n    FOR_ALL_TABPAGES(tp)\n\tif (tp == tpc)\n\t    return TRUE;\n    return FALSE;\n}\n\n/*\n * Return TRUE when \"tpc\" points to a valid tab page and at least one window is\n * valid.\n */\n    int\nvalid_tabpage_win(tabpage_T *tpc)\n{\n    tabpage_T\t*tp;\n    win_T\t*wp;\n\n    FOR_ALL_TABPAGES(tp)\n    {\n\tif (tp == tpc)\n\t{\n\t    FOR_ALL_WINDOWS_IN_TAB(tp, wp)\n\t    {\n\t\tif (win_valid_any_tab(wp))\n\t\t    return TRUE;\n\t    }\n\t    return FALSE;\n\t}\n    }\n    /* shouldn't happen */\n    return FALSE;\n}\n\n/*\n * Close tabpage \"tab\", assuming it has no windows in it.\n * There must be another tabpage or this will crash.\n */\n    void\nclose_tabpage(tabpage_T *tab)\n{\n    tabpage_T\t*ptp;\n\n    if (tab == first_tabpage)\n    {\n\tfirst_tabpage = tab->tp_next;\n\tptp = first_tabpage;\n    }\n    else\n    {\n\tfor (ptp = first_tabpage; ptp != NULL && ptp->tp_next != tab;\n\t\t\t\t\t\t\t    ptp = ptp->tp_next)\n\t    ;\n\tassert(ptp != NULL);\n\tptp->tp_next = tab->tp_next;\n    }\n\n    goto_tabpage_tp(ptp, FALSE, FALSE);\n    free_tabpage(tab);\n}\n\n/*\n * Find tab page \"n\" (first one is 1).  Returns NULL when not found.\n */\n    tabpage_T *\nfind_tabpage(int n)\n{\n    tabpage_T\t*tp;\n    int\t\ti = 1;\n\n    if (n == 0)\n\treturn curtab;\n\n    for (tp = first_tabpage; tp != NULL && i != n; tp = tp->tp_next)\n\t++i;\n    return tp;\n}\n\n/*\n * Get index of tab page \"tp\".  First one has index 1.\n * When not found returns number of tab pages plus one.\n */\n    int\ntabpage_index(tabpage_T *ftp)\n{\n    int\t\ti = 1;\n    tabpage_T\t*tp;\n\n    for (tp = first_tabpage; tp != NULL && tp != ftp; tp = tp->tp_next)\n\t++i;\n    return i;\n}\n\n/*\n * Prepare for leaving the current tab page.\n * When autocommands change \"curtab\" we don't leave the tab page and return\n * FAIL.\n * Careful: When OK is returned need to get a new tab page very very soon!\n */\n    static int\nleave_tabpage(\n    buf_T\t*new_curbuf UNUSED,    /* what is going to be the new curbuf,\n\t\t\t\t       NULL if unknown */\n    int\t\ttrigger_leave_autocmds UNUSED)\n{\n    tabpage_T\t*tp = curtab;\n\n#ifdef FEAT_JOB_CHANNEL\n    leaving_window(curwin);\n#endif\n    reset_VIsual_and_resel();\t/* stop Visual mode */\n    if (trigger_leave_autocmds)\n    {\n\tif (new_curbuf != curbuf)\n\t{\n\t    apply_autocmds(EVENT_BUFLEAVE, NULL, NULL, FALSE, curbuf);\n\t    if (curtab != tp)\n\t\treturn FAIL;\n\t}\n\tapply_autocmds(EVENT_WINLEAVE, NULL, NULL, FALSE, curbuf);\n\tif (curtab != tp)\n\t    return FAIL;\n\tapply_autocmds(EVENT_TABLEAVE, NULL, NULL, FALSE, curbuf);\n\tif (curtab != tp)\n\t    return FAIL;\n    }\n#if defined(FEAT_GUI)\n    /* Remove the scrollbars.  They may be added back later. */\n    if (gui.in_use)\n\tgui_remove_scrollbars();\n#endif\n    tp->tp_curwin = curwin;\n    tp->tp_prevwin = prevwin;\n    tp->tp_firstwin = firstwin;\n    tp->tp_lastwin = lastwin;\n    tp->tp_old_Rows = Rows;\n    tp->tp_old_Columns = Columns;\n    firstwin = NULL;\n    lastwin = NULL;\n    return OK;\n}\n\n/*\n * Start using tab page \"tp\".\n * Only to be used after leave_tabpage() or freeing the current tab page.\n * Only trigger *Enter autocommands when trigger_enter_autocmds is TRUE.\n * Only trigger *Leave autocommands when trigger_leave_autocmds is TRUE.\n */\n    static void\nenter_tabpage(\n    tabpage_T\t*tp,\n    buf_T\t*old_curbuf UNUSED,\n    int\t\ttrigger_enter_autocmds,\n    int\t\ttrigger_leave_autocmds)\n{\n    int\t\told_off = tp->tp_firstwin->w_winrow;\n    win_T\t*next_prevwin = tp->tp_prevwin;\n\n    curtab = tp;\n    firstwin = tp->tp_firstwin;\n    lastwin = tp->tp_lastwin;\n    topframe = tp->tp_topframe;\n\n    /* We would like doing the TabEnter event first, but we don't have a\n     * valid current window yet, which may break some commands.\n     * This triggers autocommands, thus may make \"tp\" invalid. */\n    win_enter_ext(tp->tp_curwin, FALSE, TRUE, FALSE,\n\t\t\t      trigger_enter_autocmds, trigger_leave_autocmds);\n    prevwin = next_prevwin;\n\n    last_status(FALSE);\t\t/* status line may appear or disappear */\n    (void)win_comp_pos();\t/* recompute w_winrow for all windows */\n#ifdef FEAT_DIFF\n    diff_need_scrollbind = TRUE;\n#endif\n\n    /* The tabpage line may have appeared or disappeared, may need to resize\n     * the frames for that.  When the Vim window was resized need to update\n     * frame sizes too.  Use the stored value of p_ch, so that it can be\n     * different for each tab page. */\n    if (p_ch != curtab->tp_ch_used)\n\tclear_cmdline = TRUE;\n    p_ch = curtab->tp_ch_used;\n    if (curtab->tp_old_Rows != Rows || (old_off != firstwin->w_winrow\n#ifdef FEAT_GUI_TABLINE\n\t\t\t    && !gui_use_tabline()\n#endif\n\t\t))\n\tshell_new_rows();\n    if (curtab->tp_old_Columns != Columns && starting == 0)\n\tshell_new_columns();\t/* update window widths */\n\n#if defined(FEAT_GUI)\n    /* When 'guioptions' includes 'L' or 'R' may have to remove or add\n     * scrollbars.  Have to update them anyway. */\n    gui_may_update_scrollbars();\n#endif\n\n    /* Apply autocommands after updating the display, when 'rows' and\n     * 'columns' have been set correctly. */\n    if (trigger_enter_autocmds)\n    {\n\tapply_autocmds(EVENT_TABENTER, NULL, NULL, FALSE, curbuf);\n\tif (old_curbuf != curbuf)\n\t    apply_autocmds(EVENT_BUFENTER, NULL, NULL, FALSE, curbuf);\n    }\n\n    redraw_all_later(NOT_VALID);\n}\n\n/*\n * Go to tab page \"n\".  For \":tab N\" and \"Ngt\".\n * When \"n\" is 9999 go to the last tab page.\n */\n    void\ngoto_tabpage(int n)\n{\n    tabpage_T\t*tp = NULL;  // shut up compiler\n    tabpage_T\t*ttp;\n    int\t\ti;\n\n    if (text_locked())\n    {\n\t/* Not allowed when editing the command line. */\n\ttext_locked_msg();\n\treturn;\n    }\n\n    /* If there is only one it can't work. */\n    if (first_tabpage->tp_next == NULL)\n    {\n\tif (n > 1)\n\t    beep_flush();\n\treturn;\n    }\n\n    if (n == 0)\n    {\n\t/* No count, go to next tab page, wrap around end. */\n\tif (curtab->tp_next == NULL)\n\t    tp = first_tabpage;\n\telse\n\t    tp = curtab->tp_next;\n    }\n    else if (n < 0)\n    {\n\t/* \"gT\": go to previous tab page, wrap around end.  \"N gT\" repeats\n\t * this N times. */\n\tttp = curtab;\n\tfor (i = n; i < 0; ++i)\n\t{\n\t    for (tp = first_tabpage; tp->tp_next != ttp && tp->tp_next != NULL;\n\t\t    tp = tp->tp_next)\n\t\t;\n\t    ttp = tp;\n\t}\n    }\n    else if (n == 9999)\n    {\n\t/* Go to last tab page. */\n\tfor (tp = first_tabpage; tp->tp_next != NULL; tp = tp->tp_next)\n\t    ;\n    }\n    else\n    {\n\t/* Go to tab page \"n\". */\n\ttp = find_tabpage(n);\n\tif (tp == NULL)\n\t{\n\t    beep_flush();\n\t    return;\n\t}\n    }\n\n    goto_tabpage_tp(tp, TRUE, TRUE);\n\n#ifdef FEAT_GUI_TABLINE\n    if (gui_use_tabline())\n\tgui_mch_set_curtab(tabpage_index(curtab));\n#endif\n}\n\n/*\n * Go to tabpage \"tp\".\n * Only trigger *Enter autocommands when trigger_enter_autocmds is TRUE.\n * Only trigger *Leave autocommands when trigger_leave_autocmds is TRUE.\n * Note: doesn't update the GUI tab.\n */\n    void\ngoto_tabpage_tp(\n    tabpage_T\t*tp,\n    int\t\ttrigger_enter_autocmds,\n    int\t\ttrigger_leave_autocmds)\n{\n    /* Don't repeat a message in another tab page. */\n    set_keep_msg(NULL, 0);\n\n    if (tp != curtab && leave_tabpage(tp->tp_curwin->w_buffer,\n\t\t\t\t\ttrigger_leave_autocmds) == OK)\n    {\n\tif (valid_tabpage(tp))\n\t    enter_tabpage(tp, curbuf, trigger_enter_autocmds,\n\t\t    trigger_leave_autocmds);\n\telse\n\t    enter_tabpage(curtab, curbuf, trigger_enter_autocmds,\n\t\t    trigger_leave_autocmds);\n    }\n}\n\n/*\n * Enter window \"wp\" in tab page \"tp\".\n * Also updates the GUI tab.\n */\n    void\ngoto_tabpage_win(tabpage_T *tp, win_T *wp)\n{\n    goto_tabpage_tp(tp, TRUE, TRUE);\n    if (curtab == tp && win_valid(wp))\n    {\n\twin_enter(wp, TRUE);\n# ifdef FEAT_GUI_TABLINE\n\tif (gui_use_tabline())\n\t    gui_mch_set_curtab(tabpage_index(curtab));\n# endif\n    }\n}\n\n/*\n * Move the current tab page to after tab page \"nr\".\n */\n    void\ntabpage_move(int nr)\n{\n    int\t\tn = 1;\n    tabpage_T\t*tp, *tp_dst;\n\n    if (first_tabpage->tp_next == NULL)\n\treturn;\n\n    for (tp = first_tabpage; tp->tp_next != NULL && n < nr; tp = tp->tp_next)\n\t++n;\n\n    if (tp == curtab || (nr > 0 && tp->tp_next != NULL\n\t\t\t\t\t\t    && tp->tp_next == curtab))\n\treturn;\n\n    tp_dst = tp;\n\n    /* Remove the current tab page from the list of tab pages. */\n    if (curtab == first_tabpage)\n\tfirst_tabpage = curtab->tp_next;\n    else\n    {\n\tFOR_ALL_TABPAGES(tp)\n\t    if (tp->tp_next == curtab)\n\t\tbreak;\n\tif (tp == NULL)\t/* \"cannot happen\" */\n\t    return;\n\ttp->tp_next = curtab->tp_next;\n    }\n\n    /* Re-insert it at the specified position. */\n    if (nr <= 0)\n    {\n\tcurtab->tp_next = first_tabpage;\n\tfirst_tabpage = curtab;\n    }\n    else\n    {\n\tcurtab->tp_next = tp_dst->tp_next;\n\ttp_dst->tp_next = curtab;\n    }\n\n    /* Need to redraw the tabline.  Tab page contents doesn't change. */\n    redraw_tabline = TRUE;\n}\n\n\n/*\n * Go to another window.\n * When jumping to another buffer, stop Visual mode.  Do this before\n * changing windows so we can yank the selection into the '*' register.\n * When jumping to another window on the same buffer, adjust its cursor\n * position to keep the same Visual area.\n */\n    void\nwin_goto(win_T *wp)\n{\n#ifdef FEAT_CONCEAL\n    win_T\t*owp = curwin;\n#endif\n\n    if (ERROR_IF_POPUP_WINDOW)\n\treturn;\n    if (text_locked())\n    {\n\tbeep_flush();\n\ttext_locked_msg();\n\treturn;\n    }\n    if (curbuf_locked())\n\treturn;\n\n    if (wp->w_buffer != curbuf)\n\treset_VIsual_and_resel();\n    else if (VIsual_active)\n\twp->w_cursor = curwin->w_cursor;\n\n#ifdef FEAT_GUI\n    need_mouse_correct = TRUE;\n#endif\n    win_enter(wp, TRUE);\n\n#ifdef FEAT_CONCEAL\n    // Conceal cursor line in previous window, unconceal in current window.\n    if (win_valid(owp) && owp->w_p_cole > 0 && !msg_scrolled)\n\tredrawWinline(owp, owp->w_cursor.lnum);\n    if (curwin->w_p_cole > 0 && !msg_scrolled)\n\tneed_cursor_line_redraw = TRUE;\n#endif\n}\n\n#if defined(FEAT_PERL) || defined(PROTO)\n/*\n * Find window number \"winnr\" (counting top to bottom).\n */\n    win_T *\nwin_find_nr(int winnr)\n{\n    win_T\t*wp;\n\n    FOR_ALL_WINDOWS(wp)\n\tif (--winnr == 0)\n\t    break;\n    return wp;\n}\n#endif\n\n#if ((defined(FEAT_PYTHON) || defined(FEAT_PYTHON3))) || defined(PROTO)\n/*\n * Find the tabpage for window \"win\".\n */\n    tabpage_T *\nwin_find_tabpage(win_T *win)\n{\n    win_T\t*wp;\n    tabpage_T\t*tp;\n\n    FOR_ALL_TAB_WINDOWS(tp, wp)\n\t    if (wp == win)\n\t\treturn tp;\n    return NULL;\n}\n#endif\n\n/*\n * Get the above or below neighbor window of the specified window.\n *   up - TRUE for the above neighbor\n *   count - nth neighbor window\n * Returns the specified window if the neighbor is not found.\n */\n    win_T *\nwin_vert_neighbor(tabpage_T *tp, win_T *wp, int up, long count)\n{\n    frame_T\t*fr;\n    frame_T\t*nfr;\n    frame_T\t*foundfr;\n\n    foundfr = wp->w_frame;\n    while (count--)\n    {\n\t/*\n\t * First go upwards in the tree of frames until we find a upwards or\n\t * downwards neighbor.\n\t */\n\tfr = foundfr;\n\tfor (;;)\n\t{\n\t    if (fr == tp->tp_topframe)\n\t\tgoto end;\n\t    if (up)\n\t\tnfr = fr->fr_prev;\n\t    else\n\t\tnfr = fr->fr_next;\n\t    if (fr->fr_parent->fr_layout == FR_COL && nfr != NULL)\n\t\tbreak;\n\t    fr = fr->fr_parent;\n\t}\n\n\t/*\n\t * Now go downwards to find the bottom or top frame in it.\n\t */\n\tfor (;;)\n\t{\n\t    if (nfr->fr_layout == FR_LEAF)\n\t    {\n\t\tfoundfr = nfr;\n\t\tbreak;\n\t    }\n\t    fr = nfr->fr_child;\n\t    if (nfr->fr_layout == FR_ROW)\n\t    {\n\t\t/* Find the frame at the cursor row. */\n\t\twhile (fr->fr_next != NULL\n\t\t\t&& frame2win(fr)->w_wincol + fr->fr_width\n\t\t\t\t\t <= wp->w_wincol + wp->w_wcol)\n\t\t    fr = fr->fr_next;\n\t    }\n\t    if (nfr->fr_layout == FR_COL && up)\n\t\twhile (fr->fr_next != NULL)\n\t\t    fr = fr->fr_next;\n\t    nfr = fr;\n\t}\n    }\nend:\n    return foundfr != NULL ? foundfr->fr_win : NULL;\n}\n\n/*\n * Move to window above or below \"count\" times.\n */\n    static void\nwin_goto_ver(\n    int\t\tup,\t\t// TRUE to go to win above\n    long\tcount)\n{\n    win_T\t*win;\n\n    win = win_vert_neighbor(curtab, curwin, up, count);\n    if (win != NULL)\n\twin_goto(win);\n}\n\n/*\n * Get the left or right neighbor window of the specified window.\n *   left - TRUE for the left neighbor\n *   count - nth neighbor window\n * Returns the specified window if the neighbor is not found.\n */\n    win_T *\nwin_horz_neighbor(tabpage_T *tp, win_T *wp, int left, long count)\n{\n    frame_T\t*fr;\n    frame_T\t*nfr;\n    frame_T\t*foundfr;\n\n    foundfr = wp->w_frame;\n    while (count--)\n    {\n\t/*\n\t * First go upwards in the tree of frames until we find a left or\n\t * right neighbor.\n\t */\n\tfr = foundfr;\n\tfor (;;)\n\t{\n\t    if (fr == tp->tp_topframe)\n\t\tgoto end;\n\t    if (left)\n\t\tnfr = fr->fr_prev;\n\t    else\n\t\tnfr = fr->fr_next;\n\t    if (fr->fr_parent->fr_layout == FR_ROW && nfr != NULL)\n\t\tbreak;\n\t    fr = fr->fr_parent;\n\t}\n\n\t/*\n\t * Now go downwards to find the leftmost or rightmost frame in it.\n\t */\n\tfor (;;)\n\t{\n\t    if (nfr->fr_layout == FR_LEAF)\n\t    {\n\t\tfoundfr = nfr;\n\t\tbreak;\n\t    }\n\t    fr = nfr->fr_child;\n\t    if (nfr->fr_layout == FR_COL)\n\t    {\n\t\t/* Find the frame at the cursor row. */\n\t\twhile (fr->fr_next != NULL\n\t\t\t&& frame2win(fr)->w_winrow + fr->fr_height\n\t\t\t\t\t <= wp->w_winrow + wp->w_wrow)\n\t\t    fr = fr->fr_next;\n\t    }\n\t    if (nfr->fr_layout == FR_ROW && left)\n\t\twhile (fr->fr_next != NULL)\n\t\t    fr = fr->fr_next;\n\t    nfr = fr;\n\t}\n    }\nend:\n    return foundfr != NULL ? foundfr->fr_win : NULL;\n}\n\n/*\n * Move to left or right window.\n */\n    static void\nwin_goto_hor(\n    int\t\tleft,\t\t// TRUE to go to left win\n    long\tcount)\n{\n    win_T\t*win;\n\n    win = win_horz_neighbor(curtab, curwin, left, count);\n    if (win != NULL)\n\twin_goto(win);\n}\n\n/*\n * Make window \"wp\" the current window.\n */\n    void\nwin_enter(win_T *wp, int undo_sync)\n{\n    win_enter_ext(wp, undo_sync, FALSE, FALSE, TRUE, TRUE);\n}\n\n/*\n * Make window wp the current window.\n * Can be called with \"curwin_invalid\" TRUE, which means that curwin has just\n * been closed and isn't valid.\n */\n    static void\nwin_enter_ext(\n    win_T\t*wp,\n    int\t\tundo_sync,\n    int\t\tcurwin_invalid,\n    int\t\ttrigger_new_autocmds,\n    int\t\ttrigger_enter_autocmds,\n    int\t\ttrigger_leave_autocmds)\n{\n    int\t\tother_buffer = FALSE;\n\n    if (wp == curwin && !curwin_invalid)\t/* nothing to do */\n\treturn;\n\n#ifdef FEAT_JOB_CHANNEL\n    if (!curwin_invalid)\n\tleaving_window(curwin);\n#endif\n\n    if (!curwin_invalid && trigger_leave_autocmds)\n    {\n\t/*\n\t * Be careful: If autocommands delete the window, return now.\n\t */\n\tif (wp->w_buffer != curbuf)\n\t{\n\t    apply_autocmds(EVENT_BUFLEAVE, NULL, NULL, FALSE, curbuf);\n\t    other_buffer = TRUE;\n\t    if (!win_valid(wp))\n\t\treturn;\n\t}\n\tapply_autocmds(EVENT_WINLEAVE, NULL, NULL, FALSE, curbuf);\n\tif (!win_valid(wp))\n\t    return;\n#ifdef FEAT_EVAL\n\t/* autocmds may abort script processing */\n\tif (aborting())\n\t    return;\n#endif\n    }\n\n    /* sync undo before leaving the current buffer */\n    if (undo_sync && curbuf != wp->w_buffer)\n\tu_sync(FALSE);\n\n    /* Might need to scroll the old window before switching, e.g., when the\n     * cursor was moved. */\n    update_topline();\n\n    /* may have to copy the buffer options when 'cpo' contains 'S' */\n    if (wp->w_buffer != curbuf)\n\tbuf_copy_options(wp->w_buffer, BCO_ENTER | BCO_NOHELP);\n    if (!curwin_invalid)\n    {\n\tprevwin = curwin;\t/* remember for CTRL-W p */\n\tcurwin->w_redr_status = TRUE;\n    }\n    curwin = wp;\n    curbuf = wp->w_buffer;\n    check_cursor();\n    if (!virtual_active())\n\tcurwin->w_cursor.coladd = 0;\n    changed_line_abv_curs();\t/* assume cursor position needs updating */\n\n    if (curwin->w_localdir != NULL || curtab->tp_localdir != NULL)\n    {\n\tchar_u\t*dirname;\n\n\t// Window or tab has a local directory: Save current directory as\n\t// global directory (unless that was done already) and change to the\n\t// local directory.\n\tif (globaldir == NULL)\n\t{\n\t    char_u\tcwd[MAXPATHL];\n\n\t    if (mch_dirname(cwd, MAXPATHL) == OK)\n\t\tglobaldir = vim_strsave(cwd);\n\t}\n\tif (curwin->w_localdir != NULL)\n\t    dirname = curwin->w_localdir;\n\telse\n\t    dirname = curtab->tp_localdir;\n\n\tif (mch_chdir((char *)dirname) == 0)\n\t    shorten_fnames(TRUE);\n    }\n    else if (globaldir != NULL)\n    {\n\t/* Window doesn't have a local directory and we are not in the global\n\t * directory: Change to the global directory. */\n\tvim_ignored = mch_chdir((char *)globaldir);\n\tVIM_CLEAR(globaldir);\n\tshorten_fnames(TRUE);\n    }\n\n#ifdef FEAT_JOB_CHANNEL\n    entering_window(curwin);\n#endif\n    if (trigger_new_autocmds)\n\tapply_autocmds(EVENT_WINNEW, NULL, NULL, FALSE, curbuf);\n    if (trigger_enter_autocmds)\n    {\n\tapply_autocmds(EVENT_WINENTER, NULL, NULL, FALSE, curbuf);\n\tif (other_buffer)\n\t    apply_autocmds(EVENT_BUFENTER, NULL, NULL, FALSE, curbuf);\n    }\n\n#ifdef FEAT_TITLE\n    maketitle();\n#endif\n    curwin->w_redr_status = TRUE;\n#ifdef FEAT_TERMINAL\n    if (bt_terminal(wp->w_buffer))\n\t// terminal is likely in another mode\n\tredraw_mode = TRUE;\n#endif\n    redraw_tabline = TRUE;\n    if (restart_edit)\n\tredraw_later(VALID);\t/* causes status line redraw */\n\n    /* set window height to desired minimal value */\n    if (curwin->w_height < p_wh && !curwin->w_p_wfh\n#ifdef FEAT_TEXT_PROP\n\t    && !popup_is_popup(curwin)\n#endif\n\t    )\n\twin_setheight((int)p_wh);\n    else if (curwin->w_height == 0)\n\twin_setheight(1);\n\n    /* set window width to desired minimal value */\n    if (curwin->w_width < p_wiw && !curwin->w_p_wfw)\n\twin_setwidth((int)p_wiw);\n\n    setmouse();\t\t\t// in case jumped to/from help buffer\n\n    /* Change directories when the 'acd' option is set. */\n    DO_AUTOCHDIR;\n}\n\n\n/*\n * Jump to the first open window that contains buffer \"buf\", if one exists.\n * Returns a pointer to the window found, otherwise NULL.\n */\n    win_T *\nbuf_jump_open_win(buf_T *buf)\n{\n    win_T\t*wp = NULL;\n\n    if (curwin->w_buffer == buf)\n\twp = curwin;\n    else\n\tFOR_ALL_WINDOWS(wp)\n\t    if (wp->w_buffer == buf)\n\t\tbreak;\n    if (wp != NULL)\n\twin_enter(wp, FALSE);\n    return wp;\n}\n\n/*\n * Jump to the first open window in any tab page that contains buffer \"buf\",\n * if one exists.\n * Returns a pointer to the window found, otherwise NULL.\n */\n    win_T *\nbuf_jump_open_tab(buf_T *buf)\n{\n    win_T\t*wp = buf_jump_open_win(buf);\n    tabpage_T\t*tp;\n\n    if (wp != NULL)\n\treturn wp;\n\n    FOR_ALL_TABPAGES(tp)\n\tif (tp != curtab)\n\t{\n\t    for (wp = tp->tp_firstwin; wp != NULL; wp = wp->w_next)\n\t\tif (wp->w_buffer == buf)\n\t\t    break;\n\t    if (wp != NULL)\n\t    {\n\t\tgoto_tabpage_win(tp, wp);\n\t\tif (curwin != wp)\n\t\t    wp = NULL;\t/* something went wrong */\n\t\tbreak;\n\t    }\n\t}\n    return wp;\n}\n\nstatic int last_win_id = LOWEST_WIN_ID - 1;\n\n/*\n * Allocate a window structure and link it in the window list when \"hidden\" is\n * FALSE.\n */\n    static win_T *\nwin_alloc(win_T *after UNUSED, int hidden UNUSED)\n{\n    win_T\t*new_wp;\n\n    /*\n     * allocate window structure and linesizes arrays\n     */\n    new_wp = ALLOC_CLEAR_ONE(win_T);\n    if (new_wp == NULL)\n\treturn NULL;\n\n    if (win_alloc_lines(new_wp) == FAIL)\n    {\n\tvim_free(new_wp);\n\treturn NULL;\n    }\n\n    new_wp->w_id = ++last_win_id;\n\n#ifdef FEAT_EVAL\n    /* init w: variables */\n    new_wp->w_vars = dict_alloc();\n    if (new_wp->w_vars == NULL)\n    {\n\twin_free_lsize(new_wp);\n\tvim_free(new_wp);\n\treturn NULL;\n    }\n    init_var_dict(new_wp->w_vars, &new_wp->w_winvar, VAR_SCOPE);\n#endif\n\n    /* Don't execute autocommands while the window is not properly\n     * initialized yet.  gui_create_scrollbar() may trigger a FocusGained\n     * event. */\n    block_autocmds();\n\n    /*\n     * link the window in the window list\n     */\n    if (!hidden)\n\twin_append(after, new_wp);\n    new_wp->w_wincol = 0;\n    new_wp->w_width = Columns;\n\n    /* position the display and the cursor at the top of the file. */\n    new_wp->w_topline = 1;\n#ifdef FEAT_DIFF\n    new_wp->w_topfill = 0;\n#endif\n    new_wp->w_botline = 2;\n    new_wp->w_cursor.lnum = 1;\n    new_wp->w_scbind_pos = 1;\n\n    // use global option value for global-local options\n    new_wp->w_p_so = -1;\n    new_wp->w_p_siso = -1;\n\n    /* We won't calculate w_fraction until resizing the window */\n    new_wp->w_fraction = 0;\n    new_wp->w_prev_fraction_row = -1;\n\n#ifdef FEAT_GUI\n    if (gui.in_use)\n    {\n\tgui_create_scrollbar(&new_wp->w_scrollbars[SBAR_LEFT],\n\t\tSBAR_LEFT, new_wp);\n\tgui_create_scrollbar(&new_wp->w_scrollbars[SBAR_RIGHT],\n\t\tSBAR_RIGHT, new_wp);\n    }\n#endif\n#ifdef FEAT_FOLDING\n    foldInitWin(new_wp);\n#endif\n    unblock_autocmds();\n#ifdef FEAT_SEARCH_EXTRA\n    new_wp->w_match_head = NULL;\n    new_wp->w_next_match_id = 4;\n#endif\n    return new_wp;\n}\n\n/*\n * Remove window 'wp' from the window list and free the structure.\n */\n    static void\nwin_free(\n    win_T\t*wp,\n    tabpage_T\t*tp)\t\t/* tab page \"win\" is in, NULL for current */\n{\n    int\t\ti;\n    buf_T\t*buf;\n    wininfo_T\t*wip;\n\n#ifdef FEAT_FOLDING\n    clearFolding(wp);\n#endif\n\n    /* reduce the reference count to the argument list. */\n    alist_unlink(wp->w_alist);\n\n    /* Don't execute autocommands while the window is halfway being deleted.\n     * gui_mch_destroy_scrollbar() may trigger a FocusGained event. */\n    block_autocmds();\n\n#ifdef FEAT_LUA\n    lua_window_free(wp);\n#endif\n\n#ifdef FEAT_MZSCHEME\n    mzscheme_window_free(wp);\n#endif\n\n#ifdef FEAT_PERL\n    perl_win_free(wp);\n#endif\n\n#ifdef FEAT_PYTHON\n    python_window_free(wp);\n#endif\n\n#ifdef FEAT_PYTHON3\n    python3_window_free(wp);\n#endif\n\n#ifdef FEAT_TCL\n    tcl_window_free(wp);\n#endif\n\n#ifdef FEAT_RUBY\n    ruby_window_free(wp);\n#endif\n\n    clear_winopt(&wp->w_onebuf_opt);\n    clear_winopt(&wp->w_allbuf_opt);\n\n#ifdef FEAT_EVAL\n    vars_clear(&wp->w_vars->dv_hashtab);\t/* free all w: variables */\n    hash_init(&wp->w_vars->dv_hashtab);\n    unref_var_dict(wp->w_vars);\n#endif\n\n    {\n\ttabpage_T\t*ttp;\n\n\tif (prevwin == wp)\n\t    prevwin = NULL;\n\tFOR_ALL_TABPAGES(ttp)\n\t    if (ttp->tp_prevwin == wp)\n\t\tttp->tp_prevwin = NULL;\n    }\n    win_free_lsize(wp);\n\n    for (i = 0; i < wp->w_tagstacklen; ++i)\n    {\n\tvim_free(wp->w_tagstack[i].tagname);\n\tvim_free(wp->w_tagstack[i].user_data);\n    }\n    vim_free(wp->w_localdir);\n\n    /* Remove the window from the b_wininfo lists, it may happen that the\n     * freed memory is re-used for another window. */\n    FOR_ALL_BUFFERS(buf)\n\tfor (wip = buf->b_wininfo; wip != NULL; wip = wip->wi_next)\n\t    if (wip->wi_win == wp)\n\t\twip->wi_win = NULL;\n\n#ifdef FEAT_SEARCH_EXTRA\n    clear_matches(wp);\n#endif\n\n#ifdef FEAT_JUMPLIST\n    free_jumplist(wp);\n#endif\n\n#ifdef FEAT_QUICKFIX\n    qf_free_all(wp);\n#endif\n\n#ifdef FEAT_GUI\n    if (gui.in_use)\n    {\n\tgui_mch_destroy_scrollbar(&wp->w_scrollbars[SBAR_LEFT]);\n\tgui_mch_destroy_scrollbar(&wp->w_scrollbars[SBAR_RIGHT]);\n    }\n#endif /* FEAT_GUI */\n\n#ifdef FEAT_MENU\n    remove_winbar(wp);\n#endif\n#ifdef FEAT_TEXT_PROP\n    free_callback(&wp->w_close_cb);\n    free_callback(&wp->w_filter_cb);\n    for (i = 0; i < 4; ++i)\n\tVIM_CLEAR(wp->w_border_highlight[i]);\n    vim_free(wp->w_scrollbar_highlight);\n    vim_free(wp->w_thumb_highlight);\n    vim_free(wp->w_popup_title);\n    list_unref(wp->w_popup_mask);\n    vim_free(wp->w_popup_mask_cells);\n#endif\n\n#ifdef FEAT_SYN_HL\n    vim_free(wp->w_p_cc_cols);\n#endif\n\n    if (win_valid_any_tab(wp))\n\twin_remove(wp, tp);\n    if (autocmd_busy)\n    {\n\twp->w_next = au_pending_free_win;\n\tau_pending_free_win = wp;\n    }\n    else\n\tvim_free(wp);\n\n    unblock_autocmds();\n}\n\n/*\n * Return TRUE if \"wp\" is not in the list of windows: the autocmd window or a\n * popup window.\n */\n    static int\nwin_unlisted(win_T *wp)\n{\n    return wp == aucmd_win || WIN_IS_POPUP(wp);\n}\n\n#if defined(FEAT_TEXT_PROP) || defined(PROTO)\n/*\n * Free a popup window.  This does not take the window out of the window list\n * and assumes there is only one toplevel frame, no split.\n */\n    void\nwin_free_popup(win_T *win)\n{\n    if (bt_popup(win->w_buffer))\n\twin_close_buffer(win, DOBUF_WIPE_REUSE, FALSE);\n    else\n\tclose_buffer(win, win->w_buffer, 0, FALSE);\n# if defined(FEAT_TIMERS)\n    if (win->w_popup_timer != NULL)\n\tstop_timer(win->w_popup_timer);\n# endif\n    vim_free(win->w_frame);\n    win_free(win, NULL);\n}\n#endif\n\n/*\n * Append window \"wp\" in the window list after window \"after\".\n */\n    static void\nwin_append(win_T *after, win_T *wp)\n{\n    win_T\t*before;\n\n    if (after == NULL)\t    /* after NULL is in front of the first */\n\tbefore = firstwin;\n    else\n\tbefore = after->w_next;\n\n    wp->w_next = before;\n    wp->w_prev = after;\n    if (after == NULL)\n\tfirstwin = wp;\n    else\n\tafter->w_next = wp;\n    if (before == NULL)\n\tlastwin = wp;\n    else\n\tbefore->w_prev = wp;\n}\n\n/*\n * Remove a window from the window list.\n */\n    void\nwin_remove(\n    win_T\t*wp,\n    tabpage_T\t*tp)\t\t/* tab page \"win\" is in, NULL for current */\n{\n    if (wp->w_prev != NULL)\n\twp->w_prev->w_next = wp->w_next;\n    else if (tp == NULL)\n\tfirstwin = curtab->tp_firstwin = wp->w_next;\n    else\n\ttp->tp_firstwin = wp->w_next;\n\n    if (wp->w_next != NULL)\n\twp->w_next->w_prev = wp->w_prev;\n    else if (tp == NULL)\n\tlastwin = curtab->tp_lastwin = wp->w_prev;\n    else\n\ttp->tp_lastwin = wp->w_prev;\n}\n\n/*\n * Append frame \"frp\" in a frame list after frame \"after\".\n */\n    static void\nframe_append(frame_T *after, frame_T *frp)\n{\n    frp->fr_next = after->fr_next;\n    after->fr_next = frp;\n    if (frp->fr_next != NULL)\n\tfrp->fr_next->fr_prev = frp;\n    frp->fr_prev = after;\n}\n\n/*\n * Insert frame \"frp\" in a frame list before frame \"before\".\n */\n    static void\nframe_insert(frame_T *before, frame_T *frp)\n{\n    frp->fr_next = before;\n    frp->fr_prev = before->fr_prev;\n    before->fr_prev = frp;\n    if (frp->fr_prev != NULL)\n\tfrp->fr_prev->fr_next = frp;\n    else\n\tfrp->fr_parent->fr_child = frp;\n}\n\n/*\n * Remove a frame from a frame list.\n */\n    static void\nframe_remove(frame_T *frp)\n{\n    if (frp->fr_prev != NULL)\n\tfrp->fr_prev->fr_next = frp->fr_next;\n    else\n    {\n\tfrp->fr_parent->fr_child = frp->fr_next;\n\t/* special case: topframe->fr_child == frp */\n\tif (topframe->fr_child == frp)\n\t    topframe->fr_child = frp->fr_next;\n    }\n    if (frp->fr_next != NULL)\n\tfrp->fr_next->fr_prev = frp->fr_prev;\n}\n\n/*\n * Allocate w_lines[] for window \"wp\".\n * Return FAIL for failure, OK for success.\n */\n    int\nwin_alloc_lines(win_T *wp)\n{\n    wp->w_lines_valid = 0;\n    wp->w_lines = ALLOC_CLEAR_MULT(wline_T, Rows );\n    if (wp->w_lines == NULL)\n\treturn FAIL;\n    return OK;\n}\n\n/*\n * free lsize arrays for a window\n */\n    void\nwin_free_lsize(win_T *wp)\n{\n    /* TODO: why would wp be NULL here? */\n    if (wp != NULL)\n\tVIM_CLEAR(wp->w_lines);\n}\n\n/*\n * Called from win_new_shellsize() after Rows changed.\n * This only does the current tab page, others must be done when made active.\n */\n    void\nshell_new_rows(void)\n{\n    int\t\th = (int)ROWS_AVAIL;\n\n    if (firstwin == NULL)\t/* not initialized yet */\n\treturn;\n    if (h < frame_minheight(topframe, NULL))\n\th = frame_minheight(topframe, NULL);\n\n    /* First try setting the heights of windows with 'winfixheight'.  If\n     * that doesn't result in the right height, forget about that option. */\n    frame_new_height(topframe, h, FALSE, TRUE);\n    if (!frame_check_height(topframe, h))\n\tframe_new_height(topframe, h, FALSE, FALSE);\n\n    (void)win_comp_pos();\t\t/* recompute w_winrow and w_wincol */\n    compute_cmdrow();\n    curtab->tp_ch_used = p_ch;\n\n#if 0\n    /* Disabled: don't want making the screen smaller make a window larger. */\n    if (p_ea)\n\twin_equal(curwin, FALSE, 'v');\n#endif\n}\n\n/*\n * Called from win_new_shellsize() after Columns changed.\n */\n    void\nshell_new_columns(void)\n{\n    if (firstwin == NULL)\t/* not initialized yet */\n\treturn;\n\n    /* First try setting the widths of windows with 'winfixwidth'.  If that\n     * doesn't result in the right width, forget about that option. */\n    frame_new_width(topframe, (int)Columns, FALSE, TRUE);\n    if (!frame_check_width(topframe, Columns))\n\tframe_new_width(topframe, (int)Columns, FALSE, FALSE);\n\n    (void)win_comp_pos();\t\t/* recompute w_winrow and w_wincol */\n#if 0\n    /* Disabled: don't want making the screen smaller make a window larger. */\n    if (p_ea)\n\twin_equal(curwin, FALSE, 'h');\n#endif\n}\n\n#if defined(FEAT_CMDWIN) || defined(PROTO)\n/*\n * Save the size of all windows in \"gap\".\n */\n    void\nwin_size_save(garray_T *gap)\n\n{\n    win_T\t*wp;\n\n    ga_init2(gap, (int)sizeof(int), 1);\n    if (ga_grow(gap, win_count() * 2) == OK)\n\tFOR_ALL_WINDOWS(wp)\n\t{\n\t    ((int *)gap->ga_data)[gap->ga_len++] =\n\t\t\t\t\t       wp->w_width + wp->w_vsep_width;\n\t    ((int *)gap->ga_data)[gap->ga_len++] = wp->w_height;\n\t}\n}\n\n/*\n * Restore window sizes, but only if the number of windows is still the same.\n * Does not free the growarray.\n */\n    void\nwin_size_restore(garray_T *gap)\n{\n    win_T\t*wp;\n    int\t\ti, j;\n\n    if (win_count() * 2 == gap->ga_len)\n    {\n\t/* The order matters, because frames contain other frames, but it's\n\t * difficult to get right. The easy way out is to do it twice. */\n\tfor (j = 0; j < 2; ++j)\n\t{\n\t    i = 0;\n\t    FOR_ALL_WINDOWS(wp)\n\t    {\n\t\tframe_setwidth(wp->w_frame, ((int *)gap->ga_data)[i++]);\n\t\twin_setheight_win(((int *)gap->ga_data)[i++], wp);\n\t    }\n\t}\n\t/* recompute the window positions */\n\t(void)win_comp_pos();\n    }\n}\n#endif /* FEAT_CMDWIN */\n\n/*\n * Update the position for all windows, using the width and height of the\n * frames.\n * Returns the row just after the last window.\n */\n    int\nwin_comp_pos(void)\n{\n    int\t\trow = tabline_height();\n    int\t\tcol = 0;\n\n    frame_comp_pos(topframe, &row, &col);\n    return row;\n}\n\n/*\n * Update the position of the windows in frame \"topfrp\", using the width and\n * height of the frames.\n * \"*row\" and \"*col\" are the top-left position of the frame.  They are updated\n * to the bottom-right position plus one.\n */\n    static void\nframe_comp_pos(frame_T *topfrp, int *row, int *col)\n{\n    win_T\t*wp;\n    frame_T\t*frp;\n    int\t\tstartcol;\n    int\t\tstartrow;\n    int\t\th;\n\n    wp = topfrp->fr_win;\n    if (wp != NULL)\n    {\n\tif (wp->w_winrow != *row || wp->w_wincol != *col)\n\t{\n\t    /* position changed, redraw */\n\t    wp->w_winrow = *row;\n\t    wp->w_wincol = *col;\n\t    redraw_win_later(wp, NOT_VALID);\n\t    wp->w_redr_status = TRUE;\n\t}\n\t/* WinBar will not show if the window height is zero */\n\th = VISIBLE_HEIGHT(wp) + wp->w_status_height;\n\t*row += h > topfrp->fr_height ? topfrp->fr_height : h;\n\t*col += wp->w_width + wp->w_vsep_width;\n    }\n    else\n    {\n\tstartrow = *row;\n\tstartcol = *col;\n\tFOR_ALL_FRAMES(frp, topfrp->fr_child)\n\t{\n\t    if (topfrp->fr_layout == FR_ROW)\n\t\t*row = startrow;\t/* all frames are at the same row */\n\t    else\n\t\t*col = startcol;\t/* all frames are at the same col */\n\t    frame_comp_pos(frp, row, col);\n\t}\n    }\n}\n\n/*\n * Set current window height and take care of repositioning other windows to\n * fit around it.\n */\n    void\nwin_setheight(int height)\n{\n    win_setheight_win(height, curwin);\n}\n\n/*\n * Set the window height of window \"win\" and take care of repositioning other\n * windows to fit around it.\n */\n    void\nwin_setheight_win(int height, win_T *win)\n{\n    int\t\trow;\n\n    if (win == curwin)\n    {\n\t/* Always keep current window at least one line high, even when\n\t * 'winminheight' is zero. */\n\tif (height < p_wmh)\n\t    height = p_wmh;\n\tif (height == 0)\n\t    height = 1;\n\theight += WINBAR_HEIGHT(curwin);\n    }\n\n    frame_setheight(win->w_frame, height + win->w_status_height);\n\n    /* recompute the window positions */\n    row = win_comp_pos();\n\n    /*\n     * If there is extra space created between the last window and the command\n     * line, clear it.\n     */\n    if (full_screen && msg_scrolled == 0 && row < cmdline_row)\n\tscreen_fill(row, cmdline_row, 0, (int)Columns, ' ', ' ', 0);\n    cmdline_row = row;\n    msg_row = row;\n    msg_col = 0;\n\n    redraw_all_later(NOT_VALID);\n}\n\n/*\n * Set the height of a frame to \"height\" and take care that all frames and\n * windows inside it are resized.  Also resize frames on the left and right if\n * the are in the same FR_ROW frame.\n *\n * Strategy:\n * If the frame is part of a FR_COL frame, try fitting the frame in that\n * frame.  If that doesn't work (the FR_COL frame is too small), recursively\n * go to containing frames to resize them and make room.\n * If the frame is part of a FR_ROW frame, all frames must be resized as well.\n * Check for the minimal height of the FR_ROW frame.\n * At the top level we can also use change the command line height.\n */\n    static void\nframe_setheight(frame_T *curfrp, int height)\n{\n    int\t\troom;\t\t/* total number of lines available */\n    int\t\ttake;\t\t/* number of lines taken from other windows */\n    int\t\troom_cmdline;\t/* lines available from cmdline */\n    int\t\trun;\n    frame_T\t*frp;\n    int\t\th;\n    int\t\troom_reserved;\n\n    /* If the height already is the desired value, nothing to do. */\n    if (curfrp->fr_height == height)\n\treturn;\n\n    if (curfrp->fr_parent == NULL)\n    {\n\t/* topframe: can only change the command line */\n\tif (height > ROWS_AVAIL)\n\t    height = ROWS_AVAIL;\n\tif (height > 0)\n\t    frame_new_height(curfrp, height, FALSE, FALSE);\n    }\n    else if (curfrp->fr_parent->fr_layout == FR_ROW)\n    {\n\t/* Row of frames: Also need to resize frames left and right of this\n\t * one.  First check for the minimal height of these. */\n\th = frame_minheight(curfrp->fr_parent, NULL);\n\tif (height < h)\n\t    height = h;\n\tframe_setheight(curfrp->fr_parent, height);\n    }\n    else\n    {\n\t/*\n\t * Column of frames: try to change only frames in this column.\n\t */\n\t/*\n\t * Do this twice:\n\t * 1: compute room available, if it's not enough try resizing the\n\t *    containing frame.\n\t * 2: compute the room available and adjust the height to it.\n\t * Try not to reduce the height of a window with 'winfixheight' set.\n\t */\n\tfor (run = 1; run <= 2; ++run)\n\t{\n\t    room = 0;\n\t    room_reserved = 0;\n\t    FOR_ALL_FRAMES(frp, curfrp->fr_parent->fr_child)\n\t    {\n\t\tif (frp != curfrp\n\t\t\t&& frp->fr_win != NULL\n\t\t\t&& frp->fr_win->w_p_wfh)\n\t\t    room_reserved += frp->fr_height;\n\t\troom += frp->fr_height;\n\t\tif (frp != curfrp)\n\t\t    room -= frame_minheight(frp, NULL);\n\t    }\n\t    if (curfrp->fr_width != Columns)\n\t\troom_cmdline = 0;\n\t    else\n\t    {\n\t\troom_cmdline = Rows - p_ch - (lastwin->w_winrow\n\t\t\t\t\t\t+ VISIBLE_HEIGHT(lastwin)\n\t\t\t\t\t\t+ lastwin->w_status_height);\n\t\tif (room_cmdline < 0)\n\t\t    room_cmdline = 0;\n\t    }\n\n\t    if (height <= room + room_cmdline)\n\t\tbreak;\n\t    if (run == 2 || curfrp->fr_width == Columns)\n\t    {\n\t\tif (height > room + room_cmdline)\n\t\t    height = room + room_cmdline;\n\t\tbreak;\n\t    }\n\t    frame_setheight(curfrp->fr_parent, height\n\t\t+ frame_minheight(curfrp->fr_parent, NOWIN) - (int)p_wmh - 1);\n\t}\n\n\t/*\n\t * Compute the number of lines we will take from others frames (can be\n\t * negative!).\n\t */\n\ttake = height - curfrp->fr_height;\n\n\t/* If there is not enough room, also reduce the height of a window\n\t * with 'winfixheight' set. */\n\tif (height > room + room_cmdline - room_reserved)\n\t    room_reserved = room + room_cmdline - height;\n\t/* If there is only a 'winfixheight' window and making the\n\t * window smaller, need to make the other window taller. */\n\tif (take < 0 && room - curfrp->fr_height < room_reserved)\n\t    room_reserved = 0;\n\n\tif (take > 0 && room_cmdline > 0)\n\t{\n\t    /* use lines from cmdline first */\n\t    if (take < room_cmdline)\n\t\troom_cmdline = take;\n\t    take -= room_cmdline;\n\t    topframe->fr_height += room_cmdline;\n\t}\n\n\t/*\n\t * set the current frame to the new height\n\t */\n\tframe_new_height(curfrp, height, FALSE, FALSE);\n\n\t/*\n\t * First take lines from the frames after the current frame.  If\n\t * that is not enough, takes lines from frames above the current\n\t * frame.\n\t */\n\tfor (run = 0; run < 2; ++run)\n\t{\n\t    if (run == 0)\n\t\tfrp = curfrp->fr_next;\t/* 1st run: start with next window */\n\t    else\n\t\tfrp = curfrp->fr_prev;\t/* 2nd run: start with prev window */\n\t    while (frp != NULL && take != 0)\n\t    {\n\t\th = frame_minheight(frp, NULL);\n\t\tif (room_reserved > 0\n\t\t\t&& frp->fr_win != NULL\n\t\t\t&& frp->fr_win->w_p_wfh)\n\t\t{\n\t\t    if (room_reserved >= frp->fr_height)\n\t\t\troom_reserved -= frp->fr_height;\n\t\t    else\n\t\t    {\n\t\t\tif (frp->fr_height - room_reserved > take)\n\t\t\t    room_reserved = frp->fr_height - take;\n\t\t\ttake -= frp->fr_height - room_reserved;\n\t\t\tframe_new_height(frp, room_reserved, FALSE, FALSE);\n\t\t\troom_reserved = 0;\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    if (frp->fr_height - take < h)\n\t\t    {\n\t\t\ttake -= frp->fr_height - h;\n\t\t\tframe_new_height(frp, h, FALSE, FALSE);\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tframe_new_height(frp, frp->fr_height - take,\n\t\t\t\t\t\t\t\tFALSE, FALSE);\n\t\t\ttake = 0;\n\t\t    }\n\t\t}\n\t\tif (run == 0)\n\t\t    frp = frp->fr_next;\n\t\telse\n\t\t    frp = frp->fr_prev;\n\t    }\n\t}\n    }\n}\n\n/*\n * Set current window width and take care of repositioning other windows to\n * fit around it.\n */\n    void\nwin_setwidth(int width)\n{\n    win_setwidth_win(width, curwin);\n}\n\n    void\nwin_setwidth_win(int width, win_T *wp)\n{\n    /* Always keep current window at least one column wide, even when\n     * 'winminwidth' is zero. */\n    if (wp == curwin)\n    {\n\tif (width < p_wmw)\n\t    width = p_wmw;\n\tif (width == 0)\n\t    width = 1;\n    }\n\n    frame_setwidth(wp->w_frame, width + wp->w_vsep_width);\n\n    /* recompute the window positions */\n    (void)win_comp_pos();\n\n    redraw_all_later(NOT_VALID);\n}\n\n/*\n * Set the width of a frame to \"width\" and take care that all frames and\n * windows inside it are resized.  Also resize frames above and below if the\n * are in the same FR_ROW frame.\n *\n * Strategy is similar to frame_setheight().\n */\n    static void\nframe_setwidth(frame_T *curfrp, int width)\n{\n    int\t\troom;\t\t/* total number of lines available */\n    int\t\ttake;\t\t/* number of lines taken from other windows */\n    int\t\trun;\n    frame_T\t*frp;\n    int\t\tw;\n    int\t\troom_reserved;\n\n    /* If the width already is the desired value, nothing to do. */\n    if (curfrp->fr_width == width)\n\treturn;\n\n    if (curfrp->fr_parent == NULL)\n\t/* topframe: can't change width */\n\treturn;\n\n    if (curfrp->fr_parent->fr_layout == FR_COL)\n    {\n\t/* Column of frames: Also need to resize frames above and below of\n\t * this one.  First check for the minimal width of these. */\n\tw = frame_minwidth(curfrp->fr_parent, NULL);\n\tif (width < w)\n\t    width = w;\n\tframe_setwidth(curfrp->fr_parent, width);\n    }\n    else\n    {\n\t/*\n\t * Row of frames: try to change only frames in this row.\n\t *\n\t * Do this twice:\n\t * 1: compute room available, if it's not enough try resizing the\n\t *    containing frame.\n\t * 2: compute the room available and adjust the width to it.\n\t */\n\tfor (run = 1; run <= 2; ++run)\n\t{\n\t    room = 0;\n\t    room_reserved = 0;\n\t    FOR_ALL_FRAMES(frp, curfrp->fr_parent->fr_child)\n\t    {\n\t\tif (frp != curfrp\n\t\t\t&& frp->fr_win != NULL\n\t\t\t&& frp->fr_win->w_p_wfw)\n\t\t    room_reserved += frp->fr_width;\n\t\troom += frp->fr_width;\n\t\tif (frp != curfrp)\n\t\t    room -= frame_minwidth(frp, NULL);\n\t    }\n\n\t    if (width <= room)\n\t\tbreak;\n\t    if (run == 2 || curfrp->fr_height >= ROWS_AVAIL)\n\t    {\n\t\tif (width > room)\n\t\t    width = room;\n\t\tbreak;\n\t    }\n\t    frame_setwidth(curfrp->fr_parent, width\n\t\t + frame_minwidth(curfrp->fr_parent, NOWIN) - (int)p_wmw - 1);\n\t}\n\n\t/*\n\t * Compute the number of lines we will take from others frames (can be\n\t * negative!).\n\t */\n\ttake = width - curfrp->fr_width;\n\n\t/* If there is not enough room, also reduce the width of a window\n\t * with 'winfixwidth' set. */\n\tif (width > room - room_reserved)\n\t    room_reserved = room - width;\n\t/* If there is only a 'winfixwidth' window and making the\n\t * window smaller, need to make the other window narrower. */\n\tif (take < 0 && room - curfrp->fr_width < room_reserved)\n\t    room_reserved = 0;\n\n\t/*\n\t * set the current frame to the new width\n\t */\n\tframe_new_width(curfrp, width, FALSE, FALSE);\n\n\t/*\n\t * First take lines from the frames right of the current frame.  If\n\t * that is not enough, takes lines from frames left of the current\n\t * frame.\n\t */\n\tfor (run = 0; run < 2; ++run)\n\t{\n\t    if (run == 0)\n\t\tfrp = curfrp->fr_next;\t/* 1st run: start with next window */\n\t    else\n\t\tfrp = curfrp->fr_prev;\t/* 2nd run: start with prev window */\n\t    while (frp != NULL && take != 0)\n\t    {\n\t\tw = frame_minwidth(frp, NULL);\n\t\tif (room_reserved > 0\n\t\t\t&& frp->fr_win != NULL\n\t\t\t&& frp->fr_win->w_p_wfw)\n\t\t{\n\t\t    if (room_reserved >= frp->fr_width)\n\t\t\troom_reserved -= frp->fr_width;\n\t\t    else\n\t\t    {\n\t\t\tif (frp->fr_width - room_reserved > take)\n\t\t\t    room_reserved = frp->fr_width - take;\n\t\t\ttake -= frp->fr_width - room_reserved;\n\t\t\tframe_new_width(frp, room_reserved, FALSE, FALSE);\n\t\t\troom_reserved = 0;\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    if (frp->fr_width - take < w)\n\t\t    {\n\t\t\ttake -= frp->fr_width - w;\n\t\t\tframe_new_width(frp, w, FALSE, FALSE);\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tframe_new_width(frp, frp->fr_width - take,\n\t\t\t\t\t\t\t\tFALSE, FALSE);\n\t\t\ttake = 0;\n\t\t    }\n\t\t}\n\t\tif (run == 0)\n\t\t    frp = frp->fr_next;\n\t\telse\n\t\t    frp = frp->fr_prev;\n\t    }\n\t}\n    }\n}\n\n/*\n * Check 'winminheight' for a valid value and reduce it if needed.\n */\n    void\nwin_setminheight(void)\n{\n    int\t\troom;\n    int\t\tneeded;\n    int\t\tfirst = TRUE;\n\n    // loop until there is a 'winminheight' that is possible\n    while (p_wmh > 0)\n    {\n\troom = Rows - p_ch;\n\tneeded = frame_minheight(topframe, NULL);\n\tif (room >= needed)\n\t    break;\n\t--p_wmh;\n\tif (first)\n\t{\n\t    emsg(_(e_noroom));\n\t    first = FALSE;\n\t}\n    }\n}\n\n/*\n * Check 'winminwidth' for a valid value and reduce it if needed.\n */\n    void\nwin_setminwidth(void)\n{\n    int\t\troom;\n    int\t\tneeded;\n    int\t\tfirst = TRUE;\n\n    // loop until there is a 'winminheight' that is possible\n    while (p_wmw > 0)\n    {\n\troom = Columns;\n\tneeded = frame_minwidth(topframe, NULL);\n\tif (room >= needed)\n\t    break;\n\t--p_wmw;\n\tif (first)\n\t{\n\t    emsg(_(e_noroom));\n\t    first = FALSE;\n\t}\n    }\n}\n\n#if defined(FEAT_MOUSE) || defined(PROTO)\n\n/*\n * Status line of dragwin is dragged \"offset\" lines down (negative is up).\n */\n    void\nwin_drag_status_line(win_T *dragwin, int offset)\n{\n    frame_T\t*curfr;\n    frame_T\t*fr;\n    int\t\troom;\n    int\t\trow;\n    int\t\tup;\t/* if TRUE, drag status line up, otherwise down */\n    int\t\tn;\n\n    fr = dragwin->w_frame;\n    curfr = fr;\n    if (fr != topframe)\t\t/* more than one window */\n    {\n\tfr = fr->fr_parent;\n\t/* When the parent frame is not a column of frames, its parent should\n\t * be. */\n\tif (fr->fr_layout != FR_COL)\n\t{\n\t    curfr = fr;\n\t    if (fr != topframe)\t/* only a row of windows, may drag statusline */\n\t\tfr = fr->fr_parent;\n\t}\n    }\n\n    /* If this is the last frame in a column, may want to resize the parent\n     * frame instead (go two up to skip a row of frames). */\n    while (curfr != topframe && curfr->fr_next == NULL)\n    {\n\tif (fr != topframe)\n\t    fr = fr->fr_parent;\n\tcurfr = fr;\n\tif (fr != topframe)\n\t    fr = fr->fr_parent;\n    }\n\n    if (offset < 0) /* drag up */\n    {\n\tup = TRUE;\n\toffset = -offset;\n\t/* sum up the room of the current frame and above it */\n\tif (fr == curfr)\n\t{\n\t    /* only one window */\n\t    room = fr->fr_height - frame_minheight(fr, NULL);\n\t}\n\telse\n\t{\n\t    room = 0;\n\t    for (fr = fr->fr_child; ; fr = fr->fr_next)\n\t    {\n\t\troom += fr->fr_height - frame_minheight(fr, NULL);\n\t\tif (fr == curfr)\n\t\t    break;\n\t    }\n\t}\n\tfr = curfr->fr_next;\t\t/* put fr at frame that grows */\n    }\n    else    /* drag down */\n    {\n\tup = FALSE;\n\t/*\n\t * Only dragging the last status line can reduce p_ch.\n\t */\n\troom = Rows - cmdline_row;\n\tif (curfr->fr_next == NULL)\n\t    room -= 1;\n\telse\n\t    room -= p_ch;\n\tif (room < 0)\n\t    room = 0;\n\t/* sum up the room of frames below of the current one */\n\tFOR_ALL_FRAMES(fr, curfr->fr_next)\n\t    room += fr->fr_height - frame_minheight(fr, NULL);\n\tfr = curfr;\t\t\t/* put fr at window that grows */\n    }\n\n    if (room < offset)\t\t/* Not enough room */\n\toffset = room;\t\t/* Move as far as we can */\n    if (offset <= 0)\n\treturn;\n\n    /*\n     * Grow frame fr by \"offset\" lines.\n     * Doesn't happen when dragging the last status line up.\n     */\n    if (fr != NULL)\n\tframe_new_height(fr, fr->fr_height + offset, up, FALSE);\n\n    if (up)\n\tfr = curfr;\t\t/* current frame gets smaller */\n    else\n\tfr = curfr->fr_next;\t/* next frame gets smaller */\n\n    /*\n     * Now make the other frames smaller.\n     */\n    while (fr != NULL && offset > 0)\n    {\n\tn = frame_minheight(fr, NULL);\n\tif (fr->fr_height - offset <= n)\n\t{\n\t    offset -= fr->fr_height - n;\n\t    frame_new_height(fr, n, !up, FALSE);\n\t}\n\telse\n\t{\n\t    frame_new_height(fr, fr->fr_height - offset, !up, FALSE);\n\t    break;\n\t}\n\tif (up)\n\t    fr = fr->fr_prev;\n\telse\n\t    fr = fr->fr_next;\n    }\n    row = win_comp_pos();\n    screen_fill(row, cmdline_row, 0, (int)Columns, ' ', ' ', 0);\n    cmdline_row = row;\n    p_ch = Rows - cmdline_row;\n    if (p_ch < 1)\n\tp_ch = 1;\n    curtab->tp_ch_used = p_ch;\n    redraw_all_later(SOME_VALID);\n    showmode();\n}\n\n/*\n * Separator line of dragwin is dragged \"offset\" lines right (negative is left).\n */\n    void\nwin_drag_vsep_line(win_T *dragwin, int offset)\n{\n    frame_T\t*curfr;\n    frame_T\t*fr;\n    int\t\troom;\n    int\t\tleft;\t/* if TRUE, drag separator line left, otherwise right */\n    int\t\tn;\n\n    fr = dragwin->w_frame;\n    if (fr == topframe)\t\t/* only one window (cannot happen?) */\n\treturn;\n    curfr = fr;\n    fr = fr->fr_parent;\n    /* When the parent frame is not a row of frames, its parent should be. */\n    if (fr->fr_layout != FR_ROW)\n    {\n\tif (fr == topframe)\t/* only a column of windows (cannot happen?) */\n\t    return;\n\tcurfr = fr;\n\tfr = fr->fr_parent;\n    }\n\n    /* If this is the last frame in a row, may want to resize a parent\n     * frame instead. */\n    while (curfr->fr_next == NULL)\n    {\n\tif (fr == topframe)\n\t    break;\n\tcurfr = fr;\n\tfr = fr->fr_parent;\n\tif (fr != topframe)\n\t{\n\t    curfr = fr;\n\t    fr = fr->fr_parent;\n\t}\n    }\n\n    if (offset < 0) /* drag left */\n    {\n\tleft = TRUE;\n\toffset = -offset;\n\t/* sum up the room of the current frame and left of it */\n\troom = 0;\n\tfor (fr = fr->fr_child; ; fr = fr->fr_next)\n\t{\n\t    room += fr->fr_width - frame_minwidth(fr, NULL);\n\t    if (fr == curfr)\n\t\tbreak;\n\t}\n\tfr = curfr->fr_next;\t\t/* put fr at frame that grows */\n    }\n    else    /* drag right */\n    {\n\tleft = FALSE;\n\t/* sum up the room of frames right of the current one */\n\troom = 0;\n\tFOR_ALL_FRAMES(fr, curfr->fr_next)\n\t    room += fr->fr_width - frame_minwidth(fr, NULL);\n\tfr = curfr;\t\t\t/* put fr at window that grows */\n    }\n\n    if (room < offset)\t\t/* Not enough room */\n\toffset = room;\t\t/* Move as far as we can */\n    if (offset <= 0)\t\t/* No room at all, quit. */\n\treturn;\n    if (fr == NULL)\n\treturn;\t\t\t/* Safety check, should not happen. */\n\n    /* grow frame fr by offset lines */\n    frame_new_width(fr, fr->fr_width + offset, left, FALSE);\n\n    /* shrink other frames: current and at the left or at the right */\n    if (left)\n\tfr = curfr;\t\t/* current frame gets smaller */\n    else\n\tfr = curfr->fr_next;\t/* next frame gets smaller */\n\n    while (fr != NULL && offset > 0)\n    {\n\tn = frame_minwidth(fr, NULL);\n\tif (fr->fr_width - offset <= n)\n\t{\n\t    offset -= fr->fr_width - n;\n\t    frame_new_width(fr, n, !left, FALSE);\n\t}\n\telse\n\t{\n\t    frame_new_width(fr, fr->fr_width - offset, !left, FALSE);\n\t    break;\n\t}\n\tif (left)\n\t    fr = fr->fr_prev;\n\telse\n\t    fr = fr->fr_next;\n    }\n    (void)win_comp_pos();\n    redraw_all_later(NOT_VALID);\n}\n#endif /* FEAT_MOUSE */\n\n#define FRACTION_MULT\t16384L\n\n/*\n * Set wp->w_fraction for the current w_wrow and w_height.\n * Has no effect when the window is less than two lines.\n */\n    void\nset_fraction(win_T *wp)\n{\n    if (wp->w_height > 1)\n\t// When cursor is in the first line the percentage is computed as if\n\t// it's halfway that line.  Thus with two lines it is 25%, with three\n\t// lines 17%, etc.  Similarly for the last line: 75%, 83%, etc.\n\twp->w_fraction = ((long)wp->w_wrow * FRACTION_MULT\n\t\t\t\t     + FRACTION_MULT / 2) / (long)wp->w_height;\n}\n\n/*\n * Set the height of a window.\n * \"height\" excludes any window toolbar.\n * This takes care of the things inside the window, not what happens to the\n * window position, the frame or to other windows.\n */\n    void\nwin_new_height(win_T *wp, int height)\n{\n    int\t\tprev_height = wp->w_height;\n\n    /* Don't want a negative height.  Happens when splitting a tiny window.\n     * Will equalize heights soon to fix it. */\n    if (height < 0)\n\theight = 0;\n    if (wp->w_height == height)\n\treturn;\t    /* nothing to do */\n\n    if (wp->w_height > 0)\n    {\n\tif (wp == curwin)\n\t    /* w_wrow needs to be valid. When setting 'laststatus' this may\n\t     * call win_new_height() recursively. */\n\t    validate_cursor();\n\tif (wp->w_height != prev_height)\n\t    return;  /* Recursive call already changed the size, bail out here\n\t\t\tto avoid the following to mess things up. */\n\tif (wp->w_wrow != wp->w_prev_fraction_row)\n\t    set_fraction(wp);\n    }\n\n    wp->w_height = height;\n    wp->w_skipcol = 0;\n\n    /* There is no point in adjusting the scroll position when exiting.  Some\n     * values might be invalid. */\n    if (!exiting)\n\tscroll_to_fraction(wp, prev_height);\n}\n\n    void\nscroll_to_fraction(win_T *wp, int prev_height)\n{\n    linenr_T\tlnum;\n    int\t\tsline, line_size;\n    int\t\theight = wp->w_height;\n\n    // Don't change w_topline in any of these cases:\n    // - window height is 0\n    // - 'scrollbind' is set and this isn't the current window\n    // - window height is sufficient to display the whole buffer and first line\n    //   is visible.\n    if (height > 0\n        && (!wp->w_p_scb || wp == curwin)\n        && (height < wp->w_buffer->b_ml.ml_line_count || wp->w_topline > 1))\n    {\n\t/*\n\t * Find a value for w_topline that shows the cursor at the same\n\t * relative position in the window as before (more or less).\n\t */\n\tlnum = wp->w_cursor.lnum;\n\tif (lnum < 1)\t\t/* can happen when starting up */\n\t    lnum = 1;\n\twp->w_wrow = ((long)wp->w_fraction * (long)height - 1L)\n\t\t\t\t\t\t\t       / FRACTION_MULT;\n\tline_size = plines_win_col(wp, lnum, (long)(wp->w_cursor.col)) - 1;\n\tsline = wp->w_wrow - line_size;\n\n\tif (sline >= 0)\n\t{\n\t    /* Make sure the whole cursor line is visible, if possible. */\n\t    int rows = plines_win(wp, lnum, FALSE);\n\n\t    if (sline > wp->w_height - rows)\n\t    {\n\t\tsline = wp->w_height - rows;\n\t\twp->w_wrow -= rows - line_size;\n\t    }\n\t}\n\n\tif (sline < 0)\n\t{\n\t    /*\n\t     * Cursor line would go off top of screen if w_wrow was this high.\n\t     * Make cursor line the first line in the window.  If not enough\n\t     * room use w_skipcol;\n\t     */\n\t    wp->w_wrow = line_size;\n\t    if (wp->w_wrow >= wp->w_height\n\t\t\t\t       && (wp->w_width - win_col_off(wp)) > 0)\n\t    {\n\t\twp->w_skipcol += wp->w_width - win_col_off(wp);\n\t\t--wp->w_wrow;\n\t\twhile (wp->w_wrow >= wp->w_height)\n\t\t{\n\t\t    wp->w_skipcol += wp->w_width - win_col_off(wp)\n\t\t\t\t\t\t\t   + win_col_off2(wp);\n\t\t    --wp->w_wrow;\n\t\t}\n\t    }\n\t}\n\telse if (sline > 0)\n\t{\n\t    while (sline > 0 && lnum > 1)\n\t    {\n#ifdef FEAT_FOLDING\n\t\thasFoldingWin(wp, lnum, &lnum, NULL, TRUE, NULL);\n\t\tif (lnum == 1)\n\t\t{\n\t\t    /* first line in buffer is folded */\n\t\t    line_size = 1;\n\t\t    --sline;\n\t\t    break;\n\t\t}\n#endif\n\t\t--lnum;\n#ifdef FEAT_DIFF\n\t\tif (lnum == wp->w_topline)\n\t\t    line_size = plines_win_nofill(wp, lnum, TRUE)\n\t\t\t\t\t\t\t      + wp->w_topfill;\n\t\telse\n#endif\n\t\t    line_size = plines_win(wp, lnum, TRUE);\n\t\tsline -= line_size;\n\t    }\n\n\t    if (sline < 0)\n\t    {\n\t\t/*\n\t\t * Line we want at top would go off top of screen.  Use next\n\t\t * line instead.\n\t\t */\n#ifdef FEAT_FOLDING\n\t\thasFoldingWin(wp, lnum, NULL, &lnum, TRUE, NULL);\n#endif\n\t\tlnum++;\n\t\twp->w_wrow -= line_size + sline;\n\t    }\n\t    else if (sline > 0)\n\t    {\n\t\t// First line of file reached, use that as topline.\n\t\tlnum = 1;\n\t\twp->w_wrow -= sline;\n\t    }\n\t}\n\tset_topline(wp, lnum);\n    }\n\n    if (wp == curwin)\n    {\n\tif (get_scrolloff_value())\n\t    update_topline();\n\tcurs_columns(FALSE);\t/* validate w_wrow */\n    }\n    if (prev_height > 0)\n\twp->w_prev_fraction_row = wp->w_wrow;\n\n    win_comp_scroll(wp);\n    redraw_win_later(wp, SOME_VALID);\n    wp->w_redr_status = TRUE;\n    invalidate_botline_win(wp);\n}\n\n/*\n * Set the width of a window.\n */\n    void\nwin_new_width(win_T *wp, int width)\n{\n    wp->w_width = width;\n    wp->w_lines_valid = 0;\n    changed_line_abv_curs_win(wp);\n    invalidate_botline_win(wp);\n    if (wp == curwin)\n    {\n\tupdate_topline();\n\tcurs_columns(TRUE);\t/* validate w_wrow */\n    }\n    redraw_win_later(wp, NOT_VALID);\n    wp->w_redr_status = TRUE;\n}\n\n    void\nwin_comp_scroll(win_T *wp)\n{\n    wp->w_p_scr = ((unsigned)wp->w_height >> 1);\n    if (wp->w_p_scr == 0)\n\twp->w_p_scr = 1;\n}\n\n/*\n * command_height: called whenever p_ch has been changed\n */\n    void\ncommand_height(void)\n{\n    int\t\th;\n    frame_T\t*frp;\n    int\t\told_p_ch = curtab->tp_ch_used;\n\n    /* Use the value of p_ch that we remembered.  This is needed for when the\n     * GUI starts up, we can't be sure in what order things happen.  And when\n     * p_ch was changed in another tab page. */\n    curtab->tp_ch_used = p_ch;\n\n    /* Find bottom frame with width of screen. */\n    frp = lastwin->w_frame;\n    while (frp->fr_width != Columns && frp->fr_parent != NULL)\n\tfrp = frp->fr_parent;\n\n    /* Avoid changing the height of a window with 'winfixheight' set. */\n    while (frp->fr_prev != NULL && frp->fr_layout == FR_LEAF\n\t\t\t\t\t\t      && frp->fr_win->w_p_wfh)\n\tfrp = frp->fr_prev;\n\n    if (starting != NO_SCREEN)\n    {\n\tcmdline_row = Rows - p_ch;\n\n\tif (p_ch > old_p_ch)\t\t    /* p_ch got bigger */\n\t{\n\t    while (p_ch > old_p_ch)\n\t    {\n\t\tif (frp == NULL)\n\t\t{\n\t\t    emsg(_(e_noroom));\n\t\t    p_ch = old_p_ch;\n\t\t    curtab->tp_ch_used = p_ch;\n\t\t    cmdline_row = Rows - p_ch;\n\t\t    break;\n\t\t}\n\t\th = frp->fr_height - frame_minheight(frp, NULL);\n\t\tif (h > p_ch - old_p_ch)\n\t\t    h = p_ch - old_p_ch;\n\t\told_p_ch += h;\n\t\tframe_add_height(frp, -h);\n\t\tfrp = frp->fr_prev;\n\t    }\n\n\t    /* Recompute window positions. */\n\t    (void)win_comp_pos();\n\n\t    /* clear the lines added to cmdline */\n\t    if (full_screen)\n\t\tscreen_fill((int)(cmdline_row), (int)Rows, 0,\n\t\t\t\t\t\t   (int)Columns, ' ', ' ', 0);\n\t    msg_row = cmdline_row;\n\t    redraw_cmdline = TRUE;\n\t    return;\n\t}\n\n\tif (msg_row < cmdline_row)\n\t    msg_row = cmdline_row;\n\tredraw_cmdline = TRUE;\n    }\n    frame_add_height(frp, (int)(old_p_ch - p_ch));\n\n    /* Recompute window positions. */\n    if (frp != lastwin->w_frame)\n\t(void)win_comp_pos();\n}\n\n/*\n * Resize frame \"frp\" to be \"n\" lines higher (negative for less high).\n * Also resize the frames it is contained in.\n */\n    static void\nframe_add_height(frame_T *frp, int n)\n{\n    frame_new_height(frp, frp->fr_height + n, FALSE, FALSE);\n    for (;;)\n    {\n\tfrp = frp->fr_parent;\n\tif (frp == NULL)\n\t    break;\n\tfrp->fr_height += n;\n    }\n}\n\n/*\n * Add or remove a status line for the bottom window(s), according to the\n * value of 'laststatus'.\n */\n    void\nlast_status(\n    int\t\tmorewin)\t/* pretend there are two or more windows */\n{\n    /* Don't make a difference between horizontal or vertical split. */\n    last_status_rec(topframe, (p_ls == 2\n\t\t\t  || (p_ls == 1 && (morewin || !ONE_WINDOW))));\n}\n\n    static void\nlast_status_rec(frame_T *fr, int statusline)\n{\n    frame_T\t*fp;\n    win_T\t*wp;\n\n    if (fr->fr_layout == FR_LEAF)\n    {\n\twp = fr->fr_win;\n\tif (wp->w_status_height != 0 && !statusline)\n\t{\n\t    /* remove status line */\n\t    win_new_height(wp, wp->w_height + 1);\n\t    wp->w_status_height = 0;\n\t    comp_col();\n\t}\n\telse if (wp->w_status_height == 0 && statusline)\n\t{\n\t    /* Find a frame to take a line from. */\n\t    fp = fr;\n\t    while (fp->fr_height <= frame_minheight(fp, NULL))\n\t    {\n\t\tif (fp == topframe)\n\t\t{\n\t\t    emsg(_(e_noroom));\n\t\t    return;\n\t\t}\n\t\t/* In a column of frames: go to frame above.  If already at\n\t\t * the top or in a row of frames: go to parent. */\n\t\tif (fp->fr_parent->fr_layout == FR_COL && fp->fr_prev != NULL)\n\t\t    fp = fp->fr_prev;\n\t\telse\n\t\t    fp = fp->fr_parent;\n\t    }\n\t    wp->w_status_height = 1;\n\t    if (fp != fr)\n\t    {\n\t\tframe_new_height(fp, fp->fr_height - 1, FALSE, FALSE);\n\t\tframe_fix_height(wp);\n\t\t(void)win_comp_pos();\n\t    }\n\t    else\n\t\twin_new_height(wp, wp->w_height - 1);\n\t    comp_col();\n\t    redraw_all_later(SOME_VALID);\n\t}\n    }\n    else if (fr->fr_layout == FR_ROW)\n    {\n\t/* vertically split windows, set status line for each one */\n\tFOR_ALL_FRAMES(fp, fr->fr_child)\n\t    last_status_rec(fp, statusline);\n    }\n    else\n    {\n\t/* horizontally split window, set status line for last one */\n\tfor (fp = fr->fr_child; fp->fr_next != NULL; fp = fp->fr_next)\n\t    ;\n\tlast_status_rec(fp, statusline);\n    }\n}\n\n/*\n * Return the number of lines used by the tab page line.\n */\n    int\ntabline_height(void)\n{\n#ifdef FEAT_GUI_TABLINE\n    /* When the GUI has the tabline then this always returns zero. */\n    if (gui_use_tabline())\n\treturn 0;\n#endif\n    switch (p_stal)\n    {\n\tcase 0: return 0;\n\tcase 1: return (first_tabpage->tp_next == NULL) ? 0 : 1;\n    }\n    return 1;\n}\n\n/*\n * Return the minimal number of rows that is needed on the screen to display\n * the current number of windows.\n */\n    int\nmin_rows(void)\n{\n    int\t\ttotal;\n    tabpage_T\t*tp;\n    int\t\tn;\n\n    if (firstwin == NULL)\t/* not initialized yet */\n\treturn MIN_LINES;\n\n    total = 0;\n    FOR_ALL_TABPAGES(tp)\n    {\n\tn = frame_minheight(tp->tp_topframe, NULL);\n\tif (total < n)\n\t    total = n;\n    }\n    total += tabline_height();\n    total += 1;\t\t/* count the room for the command line */\n    return total;\n}\n\n/*\n * Return TRUE if there is only one window (in the current tab page), not\n * counting a help or preview window, unless it is the current window.\n * Does not count unlisted windows.\n */\n    int\nonly_one_window(void)\n{\n    int\t\tcount = 0;\n    win_T\t*wp;\n\n    /* If there is another tab page there always is another window. */\n    if (first_tabpage->tp_next != NULL)\n\treturn FALSE;\n\n    FOR_ALL_WINDOWS(wp)\n\tif (wp->w_buffer != NULL\n\t\t&& (!((bt_help(wp->w_buffer) && !bt_help(curbuf))\n# ifdef FEAT_QUICKFIX\n\t\t    || wp->w_p_pvw\n# endif\n\t     ) || wp == curwin) && wp != aucmd_win)\n\t    ++count;\n    return (count <= 1);\n}\n\n/*\n * Correct the cursor line number in other windows.  Used after changing the\n * current buffer, and before applying autocommands.\n * When \"do_curwin\" is TRUE, also check current window.\n */\n    void\ncheck_lnums(int do_curwin)\n{\n    win_T\t*wp;\n    tabpage_T\t*tp;\n\n    FOR_ALL_TAB_WINDOWS(tp, wp)\n\tif ((do_curwin || wp != curwin) && wp->w_buffer == curbuf)\n\t{\n\t    // save the original cursor position and topline\n\t    wp->w_save_cursor.w_cursor_save = wp->w_cursor;\n\t    wp->w_save_cursor.w_topline_save = wp->w_topline;\n\n\t    if (wp->w_cursor.lnum > curbuf->b_ml.ml_line_count)\n\t\twp->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n\t    if (wp->w_topline > curbuf->b_ml.ml_line_count)\n\t\twp->w_topline = curbuf->b_ml.ml_line_count;\n\n\t    // save the corrected cursor position and topline\n\t    wp->w_save_cursor.w_cursor_corr = wp->w_cursor;\n\t    wp->w_save_cursor.w_topline_corr = wp->w_topline;\n\t}\n}\n\n/*\n * Reset cursor and topline to its stored values from check_lnums().\n * check_lnums() must have been called first!\n */\n    void\nreset_lnums()\n{\n    win_T\t*wp;\n    tabpage_T\t*tp;\n\n    FOR_ALL_TAB_WINDOWS(tp, wp)\n\tif (wp->w_buffer == curbuf)\n\t{\n\t    // Restore the value if the autocommand didn't change it.\n\t    if (EQUAL_POS(wp->w_save_cursor.w_cursor_corr, wp->w_cursor))\n\t\twp->w_cursor = wp->w_save_cursor.w_cursor_save;\n\t    if (wp->w_save_cursor.w_topline_corr == wp->w_topline)\n\t\twp->w_topline = wp->w_save_cursor.w_topline_save;\n\t}\n}\n\n/*\n * A snapshot of the window sizes, to restore them after closing the help\n * window.\n * Only these fields are used:\n * fr_layout\n * fr_width\n * fr_height\n * fr_next\n * fr_child\n * fr_win (only valid for the old curwin, NULL otherwise)\n */\n\n/*\n * Create a snapshot of the current frame sizes.\n */\n    void\nmake_snapshot(int idx)\n{\n    clear_snapshot(curtab, idx);\n    make_snapshot_rec(topframe, &curtab->tp_snapshot[idx]);\n}\n\n    static void\nmake_snapshot_rec(frame_T *fr, frame_T **frp)\n{\n    *frp = ALLOC_CLEAR_ONE(frame_T);\n    if (*frp == NULL)\n\treturn;\n    (*frp)->fr_layout = fr->fr_layout;\n    (*frp)->fr_width = fr->fr_width;\n    (*frp)->fr_height = fr->fr_height;\n    if (fr->fr_next != NULL)\n\tmake_snapshot_rec(fr->fr_next, &((*frp)->fr_next));\n    if (fr->fr_child != NULL)\n\tmake_snapshot_rec(fr->fr_child, &((*frp)->fr_child));\n    if (fr->fr_layout == FR_LEAF && fr->fr_win == curwin)\n\t(*frp)->fr_win = curwin;\n}\n\n/*\n * Remove any existing snapshot.\n */\n    static void\nclear_snapshot(tabpage_T *tp, int idx)\n{\n    clear_snapshot_rec(tp->tp_snapshot[idx]);\n    tp->tp_snapshot[idx] = NULL;\n}\n\n    static void\nclear_snapshot_rec(frame_T *fr)\n{\n    if (fr != NULL)\n    {\n\tclear_snapshot_rec(fr->fr_next);\n\tclear_snapshot_rec(fr->fr_child);\n\tvim_free(fr);\n    }\n}\n\n/*\n * Restore a previously created snapshot, if there is any.\n * This is only done if the screen size didn't change and the window layout is\n * still the same.\n */\n    void\nrestore_snapshot(\n    int\t\tidx,\n    int\t\tclose_curwin)\t    /* closing current window */\n{\n    win_T\t*wp;\n\n    if (curtab->tp_snapshot[idx] != NULL\n\t    && curtab->tp_snapshot[idx]->fr_width == topframe->fr_width\n\t    && curtab->tp_snapshot[idx]->fr_height == topframe->fr_height\n\t    && check_snapshot_rec(curtab->tp_snapshot[idx], topframe) == OK)\n    {\n\twp = restore_snapshot_rec(curtab->tp_snapshot[idx], topframe);\n\twin_comp_pos();\n\tif (wp != NULL && close_curwin)\n\t    win_goto(wp);\n\tredraw_all_later(NOT_VALID);\n    }\n    clear_snapshot(curtab, idx);\n}\n\n/*\n * Check if frames \"sn\" and \"fr\" have the same layout, same following frames\n * and same children.  And the window pointer is valid.\n */\n    static int\ncheck_snapshot_rec(frame_T *sn, frame_T *fr)\n{\n    if (sn->fr_layout != fr->fr_layout\n\t    || (sn->fr_next == NULL) != (fr->fr_next == NULL)\n\t    || (sn->fr_child == NULL) != (fr->fr_child == NULL)\n\t    || (sn->fr_next != NULL\n\t\t&& check_snapshot_rec(sn->fr_next, fr->fr_next) == FAIL)\n\t    || (sn->fr_child != NULL\n\t\t&& check_snapshot_rec(sn->fr_child, fr->fr_child) == FAIL)\n\t    || (sn->fr_win != NULL && !win_valid(sn->fr_win)))\n\treturn FAIL;\n    return OK;\n}\n\n/*\n * Copy the size of snapshot frame \"sn\" to frame \"fr\".  Do the same for all\n * following frames and children.\n * Returns a pointer to the old current window, or NULL.\n */\n    static win_T *\nrestore_snapshot_rec(frame_T *sn, frame_T *fr)\n{\n    win_T\t*wp = NULL;\n    win_T\t*wp2;\n\n    fr->fr_height = sn->fr_height;\n    fr->fr_width = sn->fr_width;\n    if (fr->fr_layout == FR_LEAF)\n    {\n\tframe_new_height(fr, fr->fr_height, FALSE, FALSE);\n\tframe_new_width(fr, fr->fr_width, FALSE, FALSE);\n\twp = sn->fr_win;\n    }\n    if (sn->fr_next != NULL)\n    {\n\twp2 = restore_snapshot_rec(sn->fr_next, fr->fr_next);\n\tif (wp2 != NULL)\n\t    wp = wp2;\n    }\n    if (sn->fr_child != NULL)\n    {\n\twp2 = restore_snapshot_rec(sn->fr_child, fr->fr_child);\n\tif (wp2 != NULL)\n\t    wp = wp2;\n    }\n    return wp;\n}\n\n#if defined(FEAT_GUI) || defined(PROTO)\n/*\n * Return TRUE if there is any vertically split window.\n */\n    int\nwin_hasvertsplit(void)\n{\n    frame_T\t*fr;\n\n    if (topframe->fr_layout == FR_ROW)\n\treturn TRUE;\n\n    if (topframe->fr_layout == FR_COL)\n\tFOR_ALL_FRAMES(fr, topframe->fr_child)\n\t    if (fr->fr_layout == FR_ROW)\n\t\treturn TRUE;\n\n    return FALSE;\n}\n#endif\n\n#if defined(FEAT_PYTHON) || defined(FEAT_PYTHON3) || defined(PROTO)\n    int\nget_win_number(win_T *wp, win_T *first_win)\n{\n    int\t\ti = 1;\n    win_T\t*w;\n\n    for (w = first_win; w != NULL && w != wp; w = W_NEXT(w))\n\t++i;\n\n    if (w == NULL)\n\treturn 0;\n    else\n\treturn i;\n}\n\n    int\nget_tab_number(tabpage_T *tp UNUSED)\n{\n    int\t\ti = 1;\n    tabpage_T\t*t;\n\n    for (t = first_tabpage; t != NULL && t != tp; t = t->tp_next)\n\t++i;\n\n    if (t == NULL)\n\treturn 0;\n    else\n\treturn i;\n}\n#endif\n\n/*\n * Return TRUE if \"topfrp\" and its children are at the right height.\n */\n    static int\nframe_check_height(frame_T *topfrp, int height)\n{\n    frame_T *frp;\n\n    if (topfrp->fr_height != height)\n\treturn FALSE;\n\n    if (topfrp->fr_layout == FR_ROW)\n\tFOR_ALL_FRAMES(frp, topfrp->fr_child)\n\t    if (frp->fr_height != height)\n\t\treturn FALSE;\n\n    return TRUE;\n}\n\n/*\n * Return TRUE if \"topfrp\" and its children are at the right width.\n */\n    static int\nframe_check_width(frame_T *topfrp, int width)\n{\n    frame_T *frp;\n\n    if (topfrp->fr_width != width)\n\treturn FALSE;\n\n    if (topfrp->fr_layout == FR_COL)\n\tFOR_ALL_FRAMES(frp, topfrp->fr_child)\n\t    if (frp->fr_width != width)\n\t\treturn FALSE;\n\n    return TRUE;\n}\n\n#if defined(FEAT_SYN_HL) || defined(PROTO)\n/*\n * Simple int comparison function for use with qsort()\n */\n    static int\nint_cmp(const void *a, const void *b)\n{\n    return *(const int *)a - *(const int *)b;\n}\n\n/*\n * Handle setting 'colorcolumn' or 'textwidth' in window \"wp\".\n * Returns error message, NULL if it's OK.\n */\n    char *\ncheck_colorcolumn(win_T *wp)\n{\n    char_u\t*s;\n    int\t\tcol;\n    int\t\tcount = 0;\n    int\t\tcolor_cols[256];\n    int\t\ti;\n    int\t\tj = 0;\n\n    if (wp->w_buffer == NULL)\n\treturn NULL;  // buffer was closed\n\n    for (s = wp->w_p_cc; *s != NUL && count < 255;)\n    {\n\tif (*s == '-' || *s == '+')\n\t{\n\t    // -N and +N: add to 'textwidth'\n\t    col = (*s == '-') ? -1 : 1;\n\t    ++s;\n\t    if (!VIM_ISDIGIT(*s))\n\t\treturn e_invarg;\n\t    col = col * getdigits(&s);\n\t    if (wp->w_buffer->b_p_tw == 0)\n\t\tgoto skip;  // 'textwidth' not set, skip this item\n\t    col += wp->w_buffer->b_p_tw;\n\t    if (col < 0)\n\t\tgoto skip;\n\t}\n\telse if (VIM_ISDIGIT(*s))\n\t    col = getdigits(&s);\n\telse\n\t    return e_invarg;\n\tcolor_cols[count++] = col - 1;  // 1-based to 0-based\nskip:\n\tif (*s == NUL)\n\t    break;\n\tif (*s != ',')\n\t    return e_invarg;\n\tif (*++s == NUL)\n\t    return e_invarg;  // illegal trailing comma as in \"set cc=80,\"\n    }\n\n    vim_free(wp->w_p_cc_cols);\n    if (count == 0)\n\twp->w_p_cc_cols = NULL;\n    else\n    {\n\twp->w_p_cc_cols = ALLOC_MULT(int, count + 1);\n\tif (wp->w_p_cc_cols != NULL)\n\t{\n\t    // sort the columns for faster usage on screen redraw inside\n\t    // win_line()\n\t    qsort(color_cols, count, sizeof(int), int_cmp);\n\n\t    for (i = 0; i < count; ++i)\n\t\t// skip duplicates\n\t\tif (j == 0 || wp->w_p_cc_cols[j - 1] != color_cols[i])\n\t\t    wp->w_p_cc_cols[j++] = color_cols[i];\n\t    wp->w_p_cc_cols[j] = -1;  // end marker\n\t}\n    }\n\n    return NULL;  // no error\n}\n#endif\n"], "fixing_code": ["\" Tests for autocommands\n\nsource shared.vim\nsource check.vim\nsource term_util.vim\n\nfunc s:cleanup_buffers() abort\n  for bnr in range(1, bufnr('$'))\n    if bufloaded(bnr) && bufnr('%') != bnr\n      execute 'bd! ' . bnr\n    endif\n  endfor\nendfunc\n\nfunc Test_vim_did_enter()\n  call assert_false(v:vim_did_enter)\n\n  \" This script will never reach the main loop, can't check if v:vim_did_enter\n  \" becomes one.\nendfunc\n\nif has('timers')\n\n  func ExitInsertMode(id)\n    call feedkeys(\"\\<Esc>\")\n  endfunc\n\n  func Test_cursorhold_insert()\n    \" Need to move the cursor.\n    call feedkeys(\"ggG\", \"xt\")\n\n    let g:triggered = 0\n    au CursorHoldI * let g:triggered += 1\n    set updatetime=20\n    call timer_start(100, 'ExitInsertMode')\n    call feedkeys('a', 'x!')\n    call assert_equal(1, g:triggered)\n    unlet g:triggered\n    au! CursorHoldI\n    set updatetime&\n  endfunc\n\n  func Test_cursorhold_insert_with_timer_interrupt()\n    if !has('job')\n      return\n    endif\n    \" Need to move the cursor.\n    call feedkeys(\"ggG\", \"xt\")\n\n    \" Confirm the timer invoked in exit_cb of the job doesn't disturb\n    \" CursorHoldI event.\n    let g:triggered = 0\n    au CursorHoldI * let g:triggered += 1\n    set updatetime=500\n    call job_start(has('win32') ? 'cmd /c echo:' : 'echo',\n          \\ {'exit_cb': {-> timer_start(1000, 'ExitInsertMode')}})\n    call feedkeys('a', 'x!')\n    call assert_equal(1, g:triggered)\n    unlet g:triggered\n    au! CursorHoldI\n    set updatetime&\n  endfunc\n\n  func Test_cursorhold_insert_ctrl_x()\n    let g:triggered = 0\n    au CursorHoldI * let g:triggered += 1\n    set updatetime=20\n    call timer_start(100, 'ExitInsertMode')\n    \" CursorHoldI does not trigger after CTRL-X\n    call feedkeys(\"a\\<C-X>\", 'x!')\n    call assert_equal(0, g:triggered)\n    unlet g:triggered\n    au! CursorHoldI\n    set updatetime&\n  endfunc\n\n  func Test_OptionSet_modeline()\n    call test_override('starting', 1)\n    au! OptionSet\n    augroup set_tabstop\n      au OptionSet tabstop call timer_start(1, {-> execute(\"echo 'Handler called'\", \"\")})\n    augroup END\n    call writefile(['vim: set ts=7 sw=5 :', 'something'], 'XoptionsetModeline')\n    set modeline\n    let v:errmsg = ''\n    call assert_fails('split XoptionsetModeline', 'E12:')\n    call assert_equal(7, &ts)\n    call assert_equal('', v:errmsg)\n\n    augroup set_tabstop\n      au!\n    augroup END\n    bwipe!\n    set ts&\n    call delete('XoptionsetModeline')\n    call test_override('starting', 0)\n  endfunc\n\nendif \"has('timers')\n\nfunc Test_bufunload()\n  augroup test_bufunload_group\n    autocmd!\n    autocmd BufUnload * call add(s:li, \"bufunload\")\n    autocmd BufDelete * call add(s:li, \"bufdelete\")\n    autocmd BufWipeout * call add(s:li, \"bufwipeout\")\n  augroup END\n\n  let s:li=[]\n  new\n  setlocal bufhidden=\n  bunload\n  call assert_equal([\"bufunload\", \"bufdelete\"], s:li)\n\n  let s:li=[]\n  new\n  setlocal bufhidden=delete\n  bunload\n  call assert_equal([\"bufunload\", \"bufdelete\"], s:li)\n\n  let s:li=[]\n  new\n  setlocal bufhidden=unload\n  bwipeout\n  call assert_equal([\"bufunload\", \"bufdelete\", \"bufwipeout\"], s:li)\n\n  au! test_bufunload_group\n  augroup! test_bufunload_group\nendfunc\n\n\" SEGV occurs in older versions.  (At least 7.4.2005 or older)\nfunc Test_autocmd_bufunload_with_tabnext()\n  tabedit\n  tabfirst\n\n  augroup test_autocmd_bufunload_with_tabnext_group\n    autocmd!\n    autocmd BufUnload <buffer> tabnext\n  augroup END\n\n  quit\n  call assert_equal(2, tabpagenr('$'))\n\n  autocmd! test_autocmd_bufunload_with_tabnext_group\n  augroup! test_autocmd_bufunload_with_tabnext_group\n  tablast\n  quit\nendfunc\n\nfunc Test_autocmd_bufwinleave_with_tabfirst()\n  tabedit\n  augroup sample\n    autocmd!\n    autocmd BufWinLeave <buffer> tabfirst\n  augroup END\n  call setline(1, ['a', 'b', 'c'])\n  edit! a.txt\n  tabclose\nendfunc\n\n\" SEGV occurs in older versions.  (At least 7.4.2321 or older)\nfunc Test_autocmd_bufunload_avoiding_SEGV_01()\n  split aa.txt\n  let lastbuf = bufnr('$')\n\n  augroup test_autocmd_bufunload\n    autocmd!\n    exe 'autocmd BufUnload <buffer> ' . (lastbuf + 1) . 'bwipeout!'\n  augroup END\n\n  \" Todo: check for E937 generated first\n  \" call assert_fails('edit bb.txt', 'E937:')\n  call assert_fails('edit bb.txt', 'E517:')\n\n  autocmd! test_autocmd_bufunload\n  augroup! test_autocmd_bufunload\n  bwipe! aa.txt\n  bwipe! bb.txt\nendfunc\n\n\" SEGV occurs in older versions.  (At least 7.4.2321 or older)\nfunc Test_autocmd_bufunload_avoiding_SEGV_02()\n  setlocal buftype=nowrite\n  let lastbuf = bufnr('$')\n\n  augroup test_autocmd_bufunload\n    autocmd!\n    exe 'autocmd BufUnload <buffer> ' . (lastbuf + 1) . 'bwipeout!'\n  augroup END\n\n  normal! i1\n  call assert_fails('edit a.txt', 'E517:')\n  call feedkeys(\"\\<CR>\")\n\n  autocmd! test_autocmd_bufunload\n  augroup! test_autocmd_bufunload\n  bwipe! a.txt\nendfunc\n\nfunc Test_win_tab_autocmd()\n  let g:record = []\n\n  augroup testing\n    au WinNew * call add(g:record, 'WinNew')\n    au WinEnter * call add(g:record, 'WinEnter') \n    au WinLeave * call add(g:record, 'WinLeave') \n    au TabNew * call add(g:record, 'TabNew')\n    au TabClosed * call add(g:record, 'TabClosed')\n    au TabEnter * call add(g:record, 'TabEnter')\n    au TabLeave * call add(g:record, 'TabLeave')\n  augroup END\n\n  split\n  tabnew\n  close\n  close\n\n  call assert_equal([\n\t\\ 'WinLeave', 'WinNew', 'WinEnter',\n\t\\ 'WinLeave', 'TabLeave', 'WinNew', 'WinEnter', 'TabNew', 'TabEnter',\n\t\\ 'WinLeave', 'TabLeave', 'TabClosed', 'WinEnter', 'TabEnter',\n\t\\ 'WinLeave', 'WinEnter'\n\t\\ ], g:record)\n\n  let g:record = []\n  tabnew somefile\n  tabnext\n  bwipe somefile\n\n  call assert_equal([\n\t\\ 'WinLeave', 'TabLeave', 'WinNew', 'WinEnter', 'TabNew', 'TabEnter',\n\t\\ 'WinLeave', 'TabLeave', 'WinEnter', 'TabEnter',\n\t\\ 'TabClosed'\n\t\\ ], g:record)\n\n  augroup testing\n    au!\n  augroup END\n  unlet g:record\nendfunc\n\nfunc s:AddAnAutocmd()\n  augroup vimBarTest\n    au BufReadCmd * echo 'hello'\n  augroup END\n  call assert_equal(3, len(split(execute('au vimBarTest'), \"\\n\")))\nendfunc\n\nfunc Test_early_bar()\n  \" test that a bar is recognized before the {event}\n  call s:AddAnAutocmd()\n  augroup vimBarTest | au! | augroup END\n  call assert_equal(1, len(split(execute('au vimBarTest'), \"\\n\")))\n\n  call s:AddAnAutocmd()\n  augroup vimBarTest| au!| augroup END\n  call assert_equal(1, len(split(execute('au vimBarTest'), \"\\n\")))\n\n  \" test that a bar is recognized after the {event}\n  call s:AddAnAutocmd()\n  augroup vimBarTest| au!BufReadCmd| augroup END\n  call assert_equal(1, len(split(execute('au vimBarTest'), \"\\n\")))\n\n  \" test that a bar is recognized after the {group}\n  call s:AddAnAutocmd()\n  au! vimBarTest|echo 'hello'\n  call assert_equal(1, len(split(execute('au vimBarTest'), \"\\n\")))\nendfunc\n\nfunc RemoveGroup()\n  autocmd! StartOK\n  augroup! StartOK\nendfunc\n\nfunc Test_augroup_warning()\n  augroup TheWarning\n    au VimEnter * echo 'entering'\n  augroup END\n  call assert_true(match(execute('au VimEnter'), \"TheWarning.*VimEnter\") >= 0)\n  redir => res\n  augroup! TheWarning\n  redir END\n  call assert_true(match(res, \"W19:\") >= 0)\n  call assert_true(match(execute('au VimEnter'), \"-Deleted-.*VimEnter\") >= 0)\n\n  \" check \"Another\" does not take the pace of the deleted entry\n  augroup Another\n  augroup END\n  call assert_true(match(execute('au VimEnter'), \"-Deleted-.*VimEnter\") >= 0)\n  augroup! Another\n\n  \" no warning for postpone aucmd delete\n  augroup StartOK\n    au VimEnter * call RemoveGroup()\n  augroup END\n  call assert_true(match(execute('au VimEnter'), \"StartOK.*VimEnter\") >= 0)\n  redir => res\n  doautocmd VimEnter\n  redir END\n  call assert_true(match(res, \"W19:\") < 0)\n  au! VimEnter\nendfunc\n\nfunc Test_BufReadCmdHelp()\n  \" This used to cause access to free memory\n  au BufReadCmd * e +h\n  help\n\n  au! BufReadCmd\nendfunc\n\nfunc Test_BufReadCmdHelpJump()\n  \" This used to cause access to free memory\n  au BufReadCmd * e +h{\n  \" } to fix highlighting\n  call assert_fails('help', 'E434:')\n\n  au! BufReadCmd\nendfunc\n\nfunc Test_augroup_deleted()\n  \" This caused a crash before E936 was introduced\n  augroup x\n    call assert_fails('augroup! x', 'E936:')\n    au VimEnter * echo\n  augroup end\n  augroup! x\n  call assert_true(match(execute('au VimEnter'), \"-Deleted-.*VimEnter\") >= 0)\n  au! VimEnter\nendfunc\n\n\" Tests for autocommands on :close command.\n\" This used to be in test13.\nfunc Test_three_windows()\n  \" Clean up buffers, because in some cases this function fails.\n  call s:cleanup_buffers()\n\n  \" Write three files and open them, each in a window.\n  \" Then go to next window, with autocommand that deletes the previous one.\n  \" Do this twice, writing the file.\n  e! Xtestje1\n  call setline(1, 'testje1')\n  w\n  sp Xtestje2\n  call setline(1, 'testje2')\n  w\n  sp Xtestje3\n  call setline(1, 'testje3')\n  w\n  wincmd w\n  au WinLeave Xtestje2 bwipe\n  wincmd w\n  call assert_equal('Xtestje1', expand('%'))\n\n  au WinLeave Xtestje1 bwipe Xtestje3\n  close\n  call assert_equal('Xtestje1', expand('%'))\n\n  \" Test deleting the buffer on a Unload event.  If this goes wrong there\n  \" will be the ATTENTION prompt.\n  e Xtestje1\n  au!\n  au! BufUnload Xtestje1 bwipe\n  call assert_fails('e Xtestje3', 'E937:')\n  call assert_equal('Xtestje3', expand('%'))\n\n  e Xtestje2\n  sp Xtestje1\n  call assert_fails('e', 'E937:')\n  call assert_equal('Xtestje1', expand('%'))\n\n  \" Test changing buffers in a BufWipeout autocommand.  If this goes wrong\n  \" there are ml_line errors and/or a Crash.\n  au!\n  only\n  e Xanother\n  e Xtestje1\n  bwipe Xtestje2\n  bwipe Xtestje3\n  au BufWipeout Xtestje1 buf Xtestje1\n  bwipe\n  call assert_equal('Xanother', expand('%'))\n\n  only\n  help\n  wincmd w\n  1quit\n  call assert_equal('Xanother', expand('%'))\n\n  au!\n  enew\n  call delete('Xtestje1')\n  call delete('Xtestje2')\n  call delete('Xtestje3')\nendfunc\n\nfunc Test_BufEnter()\n  au! BufEnter\n  au Bufenter * let val = val . '+'\n  let g:val = ''\n  split NewFile\n  call assert_equal('+', g:val)\n  bwipe!\n  call assert_equal('++', g:val)\n\n  \" Also get BufEnter when editing a directory\n  call mkdir('Xdir')\n  split Xdir\n  call assert_equal('+++', g:val)\n\n  \" On MS-Windows we can't edit the directory, make sure we wipe the right\n  \" buffer.\n  bwipe! Xdir\n\n  call delete('Xdir', 'd')\n  au! BufEnter\nendfunc\n\n\" Closing a window might cause an endless loop\n\" E814 for older Vims\nfunc Test_autocmd_bufwipe_in_SessLoadPost()\n  edit Xtest\n  tabnew\n  file Xsomething\n  set noswapfile\n  mksession!\n\n  let content =<< trim [CODE]\n    set nocp noswapfile\n    let v:swapchoice=\"e\"\n    augroup test_autocmd_sessionload\n    autocmd!\n    autocmd SessionLoadPost * exe bufnr(\"Xsomething\") . \"bw!\"\n    augroup END\n\n    func WriteErrors()\n      call writefile([execute(\"messages\")], \"Xerrors\")\n    endfunc\n    au VimLeave * call WriteErrors()\n  [CODE]\n\n  call writefile(content, 'Xvimrc')\n  call system(GetVimCommand('Xvimrc') .. ' --not-a-term --noplugins -S Session.vim -c cq')\n  let errors = join(readfile('Xerrors'))\n  call assert_match('E814', errors)\n\n  set swapfile\n  for file in ['Session.vim', 'Xvimrc', 'Xerrors']\n    call delete(file)\n  endfor\nendfunc\n\n\" SEGV occurs in older versions.\nfunc Test_autocmd_bufwipe_in_SessLoadPost2()\n  tabnew\n  set noswapfile\n  mksession!\n\n  let content =<< trim [CODE]\n    set nocp noswapfile\n    function! DeleteInactiveBufs()\n      tabfirst\n      let tabblist = []\n      for i in range(1, tabpagenr(''$''))\n        call extend(tabblist, tabpagebuflist(i))\n      endfor\n      for b in range(1, bufnr(''$''))\n        if bufexists(b) && buflisted(b) && (index(tabblist, b) == -1 || bufname(b) =~# ''^$'')\n          exec ''bwipeout '' . b\n        endif\n      endfor\n      echomsg \"SessionLoadPost DONE\"\n    endfunction\n    au SessionLoadPost * call DeleteInactiveBufs()\n\n    func WriteErrors()\n      call writefile([execute(\"messages\")], \"Xerrors\")\n    endfunc\n    au VimLeave * call WriteErrors()\n  [CODE]\n\n  call writefile(content, 'Xvimrc')\n  call system(GetVimCommand('Xvimrc') .. ' --not-a-term --noplugins -S Session.vim -c cq')\n  let errors = join(readfile('Xerrors'))\n  \" This probably only ever matches on unix.\n  call assert_notmatch('Caught deadly signal SEGV', errors)\n  call assert_match('SessionLoadPost DONE', errors)\n\n  set swapfile\n  for file in ['Session.vim', 'Xvimrc', 'Xerrors']\n    call delete(file)\n  endfor\nendfunc\n\nfunc Test_empty_doau()\n  doau \\|\nendfunc\n\nfunc s:AutoCommandOptionSet(match)\n  let template = \"Option: <%s>, OldVal: <%s>, OldValLocal: <%s>, OldValGlobal: <%s>, NewVal: <%s>, Scope: <%s>, Command: <%s>\\n\"\n  let item     = remove(g:options, 0)\n  let expected = printf(template, item[0], item[1], item[2], item[3], item[4], item[5], item[6])\n  let actual   = printf(template, a:match, v:option_old, v:option_oldlocal, v:option_oldglobal, v:option_new, v:option_type, v:option_command)\n  let g:opt    = [expected, actual]\n  \"call assert_equal(expected, actual)\nendfunc\n\nfunc Test_OptionSet()\n  if !has(\"eval\") || !exists(\"+autochdir\")\n    return\n  endif\n\n  badd test_autocmd.vim\n\n  call test_override('starting', 1)\n  set nocp\n  au OptionSet * :call s:AutoCommandOptionSet(expand(\"<amatch>\"))\n\n  \" 1: Setting number option\"\n  let g:options=[['number', 0, 0, 0, 1, 'global', 'set']]\n  set nu\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 2: Setting local number option\"\n  let g:options=[['number', 1, 1, '', 0, 'local', 'setlocal']]\n  setlocal nonu\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 3: Setting global number option\"\n  let g:options=[['number', 1, '', 1, 0, 'global', 'setglobal']]\n  setglobal nonu\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 4: Setting local autoindent option\"\n  let g:options=[['autoindent', 0, 0, '', 1, 'local', 'setlocal']]\n  setlocal ai\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 5: Setting global autoindent option\"\n  let g:options=[['autoindent', 0, '', 0, 1, 'global', 'setglobal']]\n  setglobal ai\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 6: Setting global autoindent option\"\n  let g:options=[['autoindent', 1, 1, 1, 0, 'global', 'set']]\n  set ai!\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 6a: Setting global autoindent option\"\n  let g:options=[['autoindent', 1, 1, 0, 0, 'global', 'set']]\n  noa setlocal ai\n  noa setglobal noai\n  set ai!\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" Should not print anything, use :noa\n  \" 7: don't trigger OptionSet\"\n  let g:options=[['invalid', 'invalid', 'invalid', 'invalid', 'invalid', 'invalid', 'invalid']]\n  noa set nonu\n  call assert_equal([['invalid', 'invalid', 'invalid', 'invalid', 'invalid', 'invalid', 'invalid']], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 8: Setting several global list and number option\"\n  let g:options=[['list', 0, 0, 0, 1, 'global', 'set'], ['number', 0, 0, 0, 1, 'global', 'set']]\n  set list nu\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 9: don't trigger OptionSet\"\n  let g:options=[['invalid', 'invalid', 'invalid', 'invalid', 'invalid', 'invalid', 'invalid'], ['invalid', 'invalid', 'invalid', 'invalid', 'invalid', 'invalid', 'invalid']]\n  noa set nolist nonu\n  call assert_equal([['invalid', 'invalid', 'invalid', 'invalid', 'invalid', 'invalid', 'invalid'], ['invalid', 'invalid', 'invalid', 'invalid', 'invalid', 'invalid', 'invalid']], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 10: Setting global acd\"\n  let g:options=[['autochdir', 0, 0, '', 1, 'local', 'setlocal']]\n  setlocal acd\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 11: Setting global autoread (also sets local value)\"\n  let g:options=[['autoread', 0, 0, 0, 1, 'global', 'set']]\n  set ar\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 12: Setting local autoread\"\n  let g:options=[['autoread', 1, 1, '', 1, 'local', 'setlocal']]\n  setlocal ar\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 13: Setting global autoread\"\n  let g:options=[['autoread', 1, '', 1, 0, 'global', 'setglobal']]\n  setglobal invar\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 14: Setting option backspace through :let\"\n  let g:options=[['backspace', '', '', '', 'eol,indent,start', 'global', 'set']]\n  let &bs=\"eol,indent,start\"\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 15: Setting option backspace through setbufvar()\"\n  let g:options=[['backup', 0, 0, '', 1, 'local', 'setlocal']]\n  \" try twice, first time, shouldn't trigger because option name is invalid,\n  \" second time, it should trigger\n  let bnum = bufnr('%')\n  call assert_fails(\"call setbufvar(bnum, '&l:bk', 1)\", \"E355\")\n  \" should trigger, use correct option name\n  call setbufvar(bnum, '&backup', 1)\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 16: Setting number option using setwinvar\"\n  let g:options=[['number', 0, 0, '', 1, 'local', 'setlocal']]\n  call setwinvar(0, '&number', 1)\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 17: Setting key option, shouldn't trigger\"\n  let g:options=[['key', 'invalid', 'invalid1', 'invalid2', 'invalid3', 'invalid4', 'invalid5']]\n  setlocal key=blah\n  setlocal key=\n  call assert_equal([['key', 'invalid', 'invalid1', 'invalid2', 'invalid3', 'invalid4', 'invalid5']], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n\n  \" 18a: Setting string global option\"\n  let oldval = &backupext\n  let g:options=[['backupext', oldval, oldval, oldval, 'foo', 'global', 'set']]\n  set backupext=foo\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 18b: Resetting string global option\"\n  let g:options=[['backupext', 'foo', 'foo', 'foo', oldval, 'global', 'set']]\n  set backupext&\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 18c: Setting global string global option\"\n  let g:options=[['backupext', oldval, '', oldval, 'bar', 'global', 'setglobal']]\n  setglobal backupext=bar\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 18d: Setting local string global option\"\n  \" As this is a global option this sets the global value even though\n  \" :setlocal is used!\n  noa set backupext& \" Reset global and local value (without triggering autocmd)\n  let g:options=[['backupext', oldval, oldval, '', 'baz', 'local', 'setlocal']]\n  setlocal backupext=baz\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 18e: Setting again string global option\"\n  noa setglobal backupext=ext_global \" Reset global and local value (without triggering autocmd)\n  noa setlocal backupext=ext_local \" Sets the global(!) value!\n  let g:options=[['backupext', 'ext_local', 'ext_local', 'ext_local', 'fuu', 'global', 'set']]\n  set backupext=fuu\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n\n  \" 19a: Setting string local-global (to buffer) option\"\n  let oldval = &tags\n  let g:options=[['tags', oldval, oldval, oldval, 'tagpath', 'global', 'set']]\n  set tags=tagpath\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 19b: Resetting string local-global (to buffer) option\"\n  let g:options=[['tags', 'tagpath', 'tagpath', 'tagpath', oldval, 'global', 'set']]\n  set tags&\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 19c: Setting global string local-global (to buffer) option \"\n  let g:options=[['tags', oldval, '', oldval, 'tagpath1', 'global', 'setglobal']]\n  setglobal tags=tagpath1\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 19d: Setting local string local-global (to buffer) option\"\n  let g:options=[['tags', 'tagpath1', 'tagpath1', '', 'tagpath2', 'local', 'setlocal']]\n  setlocal tags=tagpath2\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 19e: Setting again string local-global (to buffer) option\"\n  \" Note: v:option_old is the old global value for local-global string options\n  \" but the old local value for all other kinds of options.\n  noa setglobal tags=tag_global \" Reset global and local value (without triggering autocmd)\n  noa setlocal tags=tag_local\n  let g:options=[['tags', 'tag_global', 'tag_local', 'tag_global', 'tagpath', 'global', 'set']]\n  set tags=tagpath\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 19f: Setting string local-global (to buffer) option to an empty string\"\n  \" Note: v:option_old is the old global value for local-global string options\n  \" but the old local value for all other kinds of options.\n  noa set tags=tag_global \" Reset global and local value (without triggering autocmd)\n  noa setlocal tags= \" empty string\n  let g:options=[['tags', 'tag_global', '', 'tag_global', 'tagpath', 'global', 'set']]\n  set tags=tagpath\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n\n  \" 20a: Setting string local (to buffer) option\"\n  let oldval = &spelllang\n  let g:options=[['spelllang', oldval, oldval, oldval, 'elvish,klingon', 'global', 'set']]\n  set spelllang=elvish,klingon\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 20b: Resetting string local (to buffer) option\"\n  let g:options=[['spelllang', 'elvish,klingon', 'elvish,klingon', 'elvish,klingon', oldval, 'global', 'set']]\n  set spelllang&\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 20c: Setting global string local (to buffer) option\"\n  let g:options=[['spelllang', oldval, '', oldval, 'elvish', 'global', 'setglobal']]\n  setglobal spelllang=elvish\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 20d: Setting local string local (to buffer) option\"\n  noa set spelllang& \" Reset global and local value (without triggering autocmd)\n  let g:options=[['spelllang', oldval, oldval, '', 'klingon', 'local', 'setlocal']]\n  setlocal spelllang=klingon\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 20e: Setting again string local (to buffer) option\"\n  \" Note: v:option_old is the old global value for local-global string options\n  \" but the old local value for all other kinds of options.\n  noa setglobal spelllang=spellglobal \" Reset global and local value (without triggering autocmd)\n  noa setlocal spelllang=spelllocal\n  let g:options=[['spelllang', 'spelllocal', 'spelllocal', 'spellglobal', 'foo', 'global', 'set']]\n  set spelllang=foo\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n\n  \" 21a: Setting string local-global (to window) option\"\n  let oldval = &statusline\n  let g:options=[['statusline', oldval, oldval, oldval, 'foo', 'global', 'set']]\n  set statusline=foo\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 21b: Resetting string local-global (to window) option\"\n  \" Note: v:option_old is the old global value for local-global string options\n  \" but the old local value for all other kinds of options.\n  let g:options=[['statusline', 'foo', 'foo', 'foo', oldval, 'global', 'set']]\n  set statusline&\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 21c: Setting global string local-global (to window) option\"\n  let g:options=[['statusline', oldval, '', oldval, 'bar', 'global', 'setglobal']]\n  setglobal statusline=bar\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 21d: Setting local string local-global (to window) option\"\n  noa set statusline& \" Reset global and local value (without triggering autocmd)\n  let g:options=[['statusline', oldval, oldval, '', 'baz', 'local', 'setlocal']]\n  setlocal statusline=baz\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 21e: Setting again string local-global (to window) option\"\n  \" Note: v:option_old is the old global value for local-global string options\n  \" but the old local value for all other kinds of options.\n  noa setglobal statusline=bar \" Reset global and local value (without triggering autocmd)\n  noa setlocal statusline=baz\n  let g:options=[['statusline', 'bar', 'baz', 'bar', 'foo', 'global', 'set']]\n  set statusline=foo\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n\n  \" 22a: Setting string local (to window) option\"\n  let oldval = &foldignore\n  let g:options=[['foldignore', oldval, oldval, oldval, 'fo', 'global', 'set']]\n  set foldignore=fo\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 22b: Resetting string local (to window) option\"\n  let g:options=[['foldignore', 'fo', 'fo', 'fo', oldval, 'global', 'set']]\n  set foldignore&\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 22c: Setting global string local (to window) option\"\n  let g:options=[['foldignore', oldval, '', oldval, 'bar', 'global', 'setglobal']]\n  setglobal foldignore=bar\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 22d: Setting local string local (to window) option\"\n  noa set foldignore& \" Reset global and local value (without triggering autocmd)\n  let g:options=[['foldignore', oldval, oldval, '', 'baz', 'local', 'setlocal']]\n  setlocal foldignore=baz\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 22e: Setting again string local (to window) option\"\n  noa setglobal foldignore=glob \" Reset global and local value (without triggering autocmd)\n  noa setlocal foldignore=loc\n  let g:options=[['foldignore', 'loc', 'loc', 'glob', 'fo', 'global', 'set']]\n  set foldignore=fo\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n\n  \" 23a: Setting global number local option\"\n  noa setglobal cmdheight=8 \" Reset global and local value (without triggering autocmd)\n  noa setlocal cmdheight=1 \" Sets the global(!) value!\n  let g:options=[['cmdheight', '1', '', '1', '2', 'global', 'setglobal']]\n  setglobal cmdheight=2\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 23b: Setting local number global option\"\n  noa setglobal cmdheight=8 \" Reset global and local value (without triggering autocmd)\n  noa setlocal cmdheight=1 \" Sets the global(!) value!\n  let g:options=[['cmdheight', '1', '1', '', '2', 'local', 'setlocal']]\n  setlocal cmdheight=2\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 23c: Setting again number global option\"\n  noa setglobal cmdheight=8 \" Reset global and local value (without triggering autocmd)\n  noa setlocal cmdheight=1 \" Sets the global(!) value!\n  let g:options=[['cmdheight', '1', '1', '1', '2', 'global', 'set']]\n  set cmdheight=2\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 23d: Setting again number global option\"\n  noa set cmdheight=8 \" Reset global and local value (without triggering autocmd)\n  let g:options=[['cmdheight', '8', '8', '8', '2', 'global', 'set']]\n  set cmdheight=2\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n\n  \" 24a: Setting global number global-local (to buffer) option\"\n  noa setglobal undolevels=8 \" Reset global and local value (without triggering autocmd)\n  noa setlocal undolevels=1\n  let g:options=[['undolevels', '8', '', '8', '2', 'global', 'setglobal']]\n  setglobal undolevels=2\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 24b: Setting local number global-local (to buffer) option\"\n  noa setglobal undolevels=8 \" Reset global and local value (without triggering autocmd)\n  noa setlocal undolevels=1\n  let g:options=[['undolevels', '1', '1', '', '2', 'local', 'setlocal']]\n  setlocal undolevels=2\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 24c: Setting again number global-local (to buffer) option\"\n  noa setglobal undolevels=8 \" Reset global and local value (without triggering autocmd)\n  noa setlocal undolevels=1\n  let g:options=[['undolevels', '1', '1', '8', '2', 'global', 'set']]\n  set undolevels=2\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 24d: Setting again global number global-local (to buffer) option\"\n  noa set undolevels=8 \" Reset global and local value (without triggering autocmd)\n  let g:options=[['undolevels', '8', '8', '8', '2', 'global', 'set']]\n  set undolevels=2\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n\n  \" 25a: Setting global number local (to buffer) option\"\n  noa setglobal wrapmargin=8 \" Reset global and local value (without triggering autocmd)\n  noa setlocal wrapmargin=1\n  let g:options=[['wrapmargin', '8', '', '8', '2', 'global', 'setglobal']]\n  setglobal wrapmargin=2\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 25b: Setting local number local (to buffer) option\"\n  noa setglobal wrapmargin=8 \" Reset global and local value (without triggering autocmd)\n  noa setlocal wrapmargin=1\n  let g:options=[['wrapmargin', '1', '1', '', '2', 'local', 'setlocal']]\n  setlocal wrapmargin=2\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 25c: Setting again number local (to buffer) option\"\n  noa setglobal wrapmargin=8 \" Reset global and local value (without triggering autocmd)\n  noa setlocal wrapmargin=1\n  let g:options=[['wrapmargin', '1', '1', '8', '2', 'global', 'set']]\n  set wrapmargin=2\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 25d: Setting again global number local (to buffer) option\"\n  noa set wrapmargin=8 \" Reset global and local value (without triggering autocmd)\n  let g:options=[['wrapmargin', '8', '8', '8', '2', 'global', 'set']]\n  set wrapmargin=2\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n\n  \" 26: Setting number global-local (to window) option.\n  \" Such option does currently not exist.\n\n\n  \" 27a: Setting global number local (to window) option\"\n  noa setglobal foldcolumn=8 \" Reset global and local value (without triggering autocmd)\n  noa setlocal foldcolumn=1\n  let g:options=[['foldcolumn', '8', '', '8', '2', 'global', 'setglobal']]\n  setglobal foldcolumn=2\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 27b: Setting local number local (to window) option\"\n  noa setglobal foldcolumn=8 \" Reset global and local value (without triggering autocmd)\n  noa setlocal foldcolumn=1\n  let g:options=[['foldcolumn', '1', '1', '', '2', 'local', 'setlocal']]\n  setlocal foldcolumn=2\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 27c: Setting again number local (to window) option\"\n  noa setglobal foldcolumn=8 \" Reset global and local value (without triggering autocmd)\n  noa setlocal foldcolumn=1\n  let g:options=[['foldcolumn', '1', '1', '8', '2', 'global', 'set']]\n  set foldcolumn=2\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 27d: Ssettin again global number local (to window) option\"\n  noa set foldcolumn=8 \" Reset global and local value (without triggering autocmd)\n  let g:options=[['foldcolumn', '8', '8', '8', '2', 'global', 'set']]\n  set foldcolumn=2\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n\n  \" 28a: Setting global boolean global option\"\n  noa setglobal nowrapscan \" Reset global and local value (without triggering autocmd)\n  noa setlocal wrapscan \" Sets the global(!) value!\n  let g:options=[['wrapscan', '1', '', '1', '0', 'global', 'setglobal']]\n  setglobal nowrapscan\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 28b: Setting local boolean global option\"\n  noa setglobal nowrapscan \" Reset global and local value (without triggering autocmd)\n  noa setlocal wrapscan \" Sets the global(!) value!\n  let g:options=[['wrapscan', '1', '1', '', '0', 'local', 'setlocal']]\n  setlocal nowrapscan\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 28c: Setting again boolean global option\"\n  noa setglobal nowrapscan \" Reset global and local value (without triggering autocmd)\n  noa setlocal wrapscan \" Sets the global(!) value!\n  let g:options=[['wrapscan', '1', '1', '1', '0', 'global', 'set']]\n  set nowrapscan\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 28d: Setting again global boolean global option\"\n  noa set nowrapscan \" Reset global and local value (without triggering autocmd)\n  let g:options=[['wrapscan', '0', '0', '0', '1', 'global', 'set']]\n  set wrapscan\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n\n  \" 29a: Setting global boolean global-local (to buffer) option\"\n  noa setglobal noautoread \" Reset global and local value (without triggering autocmd)\n  noa setlocal autoread\n  let g:options=[['autoread', '0', '', '0', '1', 'global', 'setglobal']]\n  setglobal autoread\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 29b: Setting local boolean global-local (to buffer) option\"\n  noa setglobal noautoread \" Reset global and local value (without triggering autocmd)\n  noa setlocal autoread\n  let g:options=[['autoread', '1', '1', '', '0', 'local', 'setlocal']]\n  setlocal noautoread\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 29c: Setting again boolean global-local (to buffer) option\"\n  noa setglobal noautoread \" Reset global and local value (without triggering autocmd)\n  noa setlocal autoread\n  let g:options=[['autoread', '1', '1', '0', '1', 'global', 'set']]\n  set autoread\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 29d: Setting again global boolean global-local (to buffer) option\"\n  noa set noautoread \" Reset global and local value (without triggering autocmd)\n  let g:options=[['autoread', '0', '0', '0', '1', 'global', 'set']]\n  set autoread\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n\n  \" 30a: Setting global boolean local (to buffer) option\"\n  noa setglobal nocindent \" Reset global and local value (without triggering autocmd)\n  noa setlocal cindent\n  let g:options=[['cindent', '0', '', '0', '1', 'global', 'setglobal']]\n  setglobal cindent\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 30b: Setting local boolean local (to buffer) option\"\n  noa setglobal nocindent \" Reset global and local value (without triggering autocmd)\n  noa setlocal cindent\n  let g:options=[['cindent', '1', '1', '', '0', 'local', 'setlocal']]\n  setlocal nocindent\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 30c: Setting again boolean local (to buffer) option\"\n  noa setglobal nocindent \" Reset global and local value (without triggering autocmd)\n  noa setlocal cindent\n  let g:options=[['cindent', '1', '1', '0', '1', 'global', 'set']]\n  set cindent\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 30d: Setting again global boolean local (to buffer) option\"\n  noa set nocindent \" Reset global and local value (without triggering autocmd)\n  let g:options=[['cindent', '0', '0', '0', '1', 'global', 'set']]\n  set cindent\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n\n  \" 31: Setting boolean global-local (to window) option\n  \" Currently no such option exists.\n\n\n  \" 32a: Setting global boolean local (to window) option\"\n  noa setglobal nocursorcolumn \" Reset global and local value (without triggering autocmd)\n  noa setlocal cursorcolumn\n  let g:options=[['cursorcolumn', '0', '', '0', '1', 'global', 'setglobal']]\n  setglobal cursorcolumn\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 32b: Setting local boolean local (to window) option\"\n  noa setglobal nocursorcolumn \" Reset global and local value (without triggering autocmd)\n  noa setlocal cursorcolumn\n  let g:options=[['cursorcolumn', '1', '1', '', '0', 'local', 'setlocal']]\n  setlocal nocursorcolumn\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 32c: Setting again boolean local (to window) option\"\n  noa setglobal nocursorcolumn \" Reset global and local value (without triggering autocmd)\n  noa setlocal cursorcolumn\n  let g:options=[['cursorcolumn', '1', '1', '0', '1', 'global', 'set']]\n  set cursorcolumn\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 32d: Setting again global boolean local (to window) option\"\n  noa set nocursorcolumn \" Reset global and local value (without triggering autocmd)\n  let g:options=[['cursorcolumn', '0', '0', '0', '1', 'global', 'set']]\n  set cursorcolumn\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n\n  \" 33: Test autocommands when an option value is converted internally.\n  noa set backspace=1 \" Reset global and local value (without triggering autocmd)\n  let g:options=[['backspace', 'indent,eol', 'indent,eol', 'indent,eol', '2', 'global', 'set']]\n  set backspace=2\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n\n  \" Cleanup\n  au! OptionSet\n  \" set tags&\n  for opt in ['nu', 'ai', 'acd', 'ar', 'bs', 'backup', 'cul', 'cp', 'backupext', 'tags', 'spelllang', 'statusline', 'foldignore', 'cmdheight', 'undolevels', 'wrapmargin', 'foldcolumn', 'wrapscan', 'autoread', 'cindent', 'cursorcolumn']\n    exe printf(\":set %s&vim\", opt)\n  endfor\n  call test_override('starting', 0)\n  delfunc! AutoCommandOptionSet\nendfunc\n\nfunc Test_OptionSet_diffmode()\n  call test_override('starting', 1)\n  \" 18: Changing an option when entering diff mode\n  new\n  au OptionSet diff :let &l:cul=v:option_new\n\n  call setline(1, ['buffer 1', 'line2', 'line3', 'line4'])\n  call assert_equal(0, &l:cul)\n  diffthis\n  call assert_equal(1, &l:cul)\n\n  vnew\n  call setline(1, ['buffer 2', 'line 2', 'line 3', 'line4'])\n  call assert_equal(0, &l:cul)\n  diffthis\n  call assert_equal(1, &l:cul)\n\n  diffoff\n  call assert_equal(0, &l:cul)\n  call assert_equal(1, getwinvar(2, '&l:cul'))\n  bw!\n\n  call assert_equal(1, &l:cul)\n  diffoff!\n  call assert_equal(0, &l:cul)\n  call assert_equal(0, getwinvar(1, '&l:cul'))\n  bw!\n\n  \" Cleanup\n  au! OptionSet\n  call test_override('starting', 0)\nendfunc\n\nfunc Test_OptionSet_diffmode_close()\n  call test_override('starting', 1)\n  \" 19: Try to close the current window when entering diff mode\n  \" should not segfault\n  new\n  au OptionSet diff close\n\n  call setline(1, ['buffer 1', 'line2', 'line3', 'line4'])\n  call assert_fails(':diffthis', 'E788')\n  call assert_equal(1, &diff)\n  vnew\n  call setline(1, ['buffer 2', 'line 2', 'line 3', 'line4'])\n  call assert_fails(':diffthis', 'E788')\n  call assert_equal(1, &diff)\n  bw!\n  call assert_fails(':diffoff!', 'E788')\n  bw!\n\n  \" Cleanup\n  au! OptionSet\n  call test_override('starting', 0)\n  \"delfunc! AutoCommandOptionSet\nendfunc\n\n\" Test for Bufleave autocommand that deletes the buffer we are about to edit.\nfunc Test_BufleaveWithDelete()\n  new | edit Xfile1\n\n  augroup test_bufleavewithdelete\n      autocmd!\n      autocmd BufLeave Xfile1 bwipe Xfile2\n  augroup END\n\n  call assert_fails('edit Xfile2', 'E143:')\n  call assert_equal('Xfile1', bufname('%'))\n\n  autocmd! test_bufleavewithdelete BufLeave Xfile1\n  augroup! test_bufleavewithdelete\n\n  new\n  bwipe! Xfile1\nendfunc\n\n\" Test for autocommand that changes the buffer list, when doing \":ball\".\nfunc Test_Acmd_BufAll()\n  enew!\n  %bwipe!\n  call writefile(['Test file Xxx1'], 'Xxx1')\n  call writefile(['Test file Xxx2'], 'Xxx2')\n  call writefile(['Test file Xxx3'], 'Xxx3')\n\n  \" Add three files to the buffer list\n  split Xxx1\n  close\n  split Xxx2\n  close\n  split Xxx3\n  close\n\n  \" Wipe the buffer when the buffer is opened\n  au BufReadPost Xxx2 bwipe\n\n  call append(0, 'Test file Xxx4')\n  ball\n\n  call assert_equal(2, winnr('$'))\n  call assert_equal('Xxx1', bufname(winbufnr(winnr('$'))))\n  wincmd t\n\n  au! BufReadPost\n  %bwipe!\n  call delete('Xxx1')\n  call delete('Xxx2')\n  call delete('Xxx3')\n  enew! | only\nendfunc\n\n\" Test for autocommand that changes current buffer on BufEnter event.\n\" Check if modelines are interpreted for the correct buffer.\nfunc Test_Acmd_BufEnter()\n  %bwipe!\n  call writefile(['start of test file Xxx1',\n\t      \\ \"\\<Tab>this is a test\",\n\t      \\ 'end of test file Xxx1'], 'Xxx1')\n  call writefile(['start of test file Xxx2',\n\t      \\ 'vim: set noai :',\n\t      \\ \"\\<Tab>this is a test\",\n\t      \\ 'end of test file Xxx2'], 'Xxx2')\n\n  au BufEnter Xxx2 brew\n  set ai modeline modelines=3\n  edit Xxx1\n  \" edit Xxx2, autocmd will do :brew\n  edit Xxx2\n  exe \"normal G?this is a\\<CR>\"\n  \" Append text with autoindent to this file\n  normal othis should be auto-indented\n  call assert_equal(\"\\<Tab>this should be auto-indented\", getline('.'))\n  call assert_equal(3, line('.'))\n  \" Remove autocmd and edit Xxx2 again\n  au! BufEnter Xxx2\n  buf! Xxx2\n  exe \"normal G?this is a\\<CR>\"\n  \" append text without autoindent to Xxx\n  normal othis should be in column 1\n  call assert_equal(\"this should be in column 1\", getline('.'))\n  call assert_equal(4, line('.'))\n\n  %bwipe!\n  call delete('Xxx1')\n  call delete('Xxx2')\n  set ai&vim modeline&vim modelines&vim\nendfunc\n\n\" Test for issue #57\n\" do not move cursor on <c-o> when autoindent is set\nfunc Test_ai_CTRL_O()\n  enew!\n  set ai\n  let save_fo = &fo\n  set fo+=r\n  exe \"normal o# abcdef\\<Esc>2hi\\<CR>\\<C-O>d0\\<Esc>\"\n  exe \"normal o# abcdef\\<Esc>2hi\\<C-O>d0\\<Esc>\"\n  call assert_equal(['# abc', 'def', 'def'], getline(2, 4))\n\n  set ai&vim\n  let &fo = save_fo\n  enew!\nendfunc\n\n\" Test for autocommand that deletes the current buffer on BufLeave event.\n\" Also test deleting the last buffer, should give a new, empty buffer.\nfunc Test_BufLeave_Wipe()\n  %bwipe!\n  let content = ['start of test file Xxx',\n\t      \\ 'this is a test',\n\t      \\ 'end of test file Xxx']\n  call writefile(content, 'Xxx1')\n  call writefile(content, 'Xxx2')\n\n  au BufLeave Xxx2 bwipe\n  edit Xxx1\n  split Xxx2\n  \" delete buffer Xxx2, we should be back to Xxx1\n  bwipe\n  call assert_equal('Xxx1', bufname('%'))\n  call assert_equal(1, winnr('$'))\n\n  \" Create an alternate buffer\n  %write! test.out\n  call assert_equal('test.out', bufname('#'))\n  \" delete alternate buffer\n  bwipe test.out\n  call assert_equal('Xxx1', bufname('%'))\n  call assert_equal('', bufname('#'))\n\n  au BufLeave Xxx1 bwipe\n  \" delete current buffer, get an empty one\n  bwipe!\n  call assert_equal(1, line('$'))\n  call assert_equal('', bufname('%'))\n  let g:bufinfo = getbufinfo()\n  call assert_equal(1, len(g:bufinfo))\n\n  call delete('Xxx1')\n  call delete('Xxx2')\n  call delete('test.out')\n  %bwipe\n  au! BufLeave\n\n  \" check that bufinfo doesn't contain a pointer to freed memory\n  call test_garbagecollect_now()\nendfunc\n\nfunc Test_QuitPre()\n  edit Xfoo\n  let winid = win_getid(winnr())\n  split Xbar\n  au! QuitPre * let g:afile = expand('<afile>')\n  \" Close the other window, <afile> should be correct.\n  exe win_id2win(winid) . 'q'\n  call assert_equal('Xfoo', g:afile)\n \n  unlet g:afile\n  bwipe Xfoo\n  bwipe Xbar\nendfunc\n\nfunc Test_Cmdline()\n  au! CmdlineChanged : let g:text = getcmdline()\n  let g:text = 0\n  call feedkeys(\":echom 'hello'\\<CR>\", 'xt')\n  call assert_equal(\"echom 'hello'\", g:text)\n  au! CmdlineChanged\n\n  au! CmdlineChanged : let g:entered = expand('<afile>')\n  let g:entered = 0\n  call feedkeys(\":echom 'hello'\\<CR>\", 'xt')\n  call assert_equal(':', g:entered)\n  au! CmdlineChanged\n\n  au! CmdlineEnter : let g:entered = expand('<afile>')\n  au! CmdlineLeave : let g:left = expand('<afile>')\n  let g:entered = 0\n  let g:left = 0\n  call feedkeys(\":echo 'hello'\\<CR>\", 'xt')\n  call assert_equal(':', g:entered)\n  call assert_equal(':', g:left)\n  au! CmdlineEnter\n  au! CmdlineLeave\n\n  let save_shellslash = &shellslash\n  set noshellslash\n  au! CmdlineEnter / let g:entered = expand('<afile>')\n  au! CmdlineLeave / let g:left = expand('<afile>')\n  let g:entered = 0\n  let g:left = 0\n  new\n  call setline(1, 'hello')\n  call feedkeys(\"/hello\\<CR>\", 'xt')\n  call assert_equal('/', g:entered)\n  call assert_equal('/', g:left)\n  bwipe!\n  au! CmdlineEnter\n  au! CmdlineLeave\n  let &shellslash = save_shellslash\nendfunc\n\n\" Test for BufWritePre autocommand that deletes or unloads the buffer.\nfunc Test_BufWritePre()\n  %bwipe\n  au BufWritePre Xxx1 bunload\n  au BufWritePre Xxx2 bwipe\n\n  call writefile(['start of Xxx1', 'test', 'end of Xxx1'], 'Xxx1')\n  call writefile(['start of Xxx2', 'test', 'end of Xxx2'], 'Xxx2')\n\n  edit Xtest\n  e! Xxx2\n  bdel Xtest\n  e Xxx1\n  \" write it, will unload it and give an error msg\n  call assert_fails('w', 'E203')\n  call assert_equal('Xxx2', bufname('%'))\n  edit Xtest\n  e! Xxx2\n  bwipe Xtest\n  \" write it, will delete the buffer and give an error msg\n  call assert_fails('w', 'E203')\n  call assert_equal('Xxx1', bufname('%'))\n  au! BufWritePre\n  call delete('Xxx1')\n  call delete('Xxx2')\nendfunc\n\n\" Test for BufUnload autocommand that unloads all the other buffers\nfunc Test_bufunload_all()\n  call writefile(['Test file Xxx1'], 'Xxx1')\"\n  call writefile(['Test file Xxx2'], 'Xxx2')\"\n\n  let content =<< trim [CODE]\n    func UnloadAllBufs()\n      let i = 1\n      while i <= bufnr('$')\n        if i != bufnr('%') && bufloaded(i)\n          exe  i . 'bunload'\n        endif\n        let i += 1\n      endwhile\n    endfunc\n    au BufUnload * call UnloadAllBufs()\n    au VimLeave * call writefile(['Test Finished'], 'Xout')\n    edit Xxx1\n    split Xxx2\n    q\n  [CODE]\n\n  call writefile(content, 'Xtest')\n\n  call delete('Xout')\n  call system(GetVimCommandClean() .. ' -N --not-a-term -S Xtest')\n  call assert_true(filereadable('Xout'))\n\n  call delete('Xxx1')\n  call delete('Xxx2')\n  call delete('Xtest')\n  call delete('Xout')\nendfunc\n\n\" Some tests for buffer-local autocommands\nfunc Test_buflocal_autocmd()\n  let g:bname = ''\n  edit xx\n  au BufLeave <buffer> let g:bname = expand(\"%\")\n  \" here, autocommand for xx should trigger.\n  \" but autocommand shall not apply to buffer named <buffer>.\n  edit somefile\n  call assert_equal('xx', g:bname)\n  let g:bname = ''\n  \" here, autocommand shall be auto-deleted\n  bwipe xx\n  \" autocmd should not trigger\n  edit xx\n  call assert_equal('', g:bname)\n  \" autocmd should not trigger\n  edit somefile\n  call assert_equal('', g:bname)\n  enew\n  unlet g:bname\nendfunc\n\n\" Test for \"*Cmd\" autocommands\nfunc Test_Cmd_Autocmds()\n  call writefile(['start of Xxx', \"\\tabc2\", 'end of Xxx'], 'Xxx')\n\n  enew!\n  au BufReadCmd XtestA 0r Xxx|$del\n  edit XtestA\t\t\t\" will read text of Xxd instead\n  call assert_equal('start of Xxx', getline(1))\n\n  au BufWriteCmd XtestA call append(line(\"$\"), \"write\")\n  write\t\t\t\t\" will append a line to the file\n  call assert_equal('write', getline('$'))\n  call assert_fails('read XtestA', 'E484')\t\" should not read anything\n  call assert_equal('write', getline(4))\n\n  \" now we have:\n  \" 1\tstart of Xxx\n  \" 2\t\tabc2\n  \" 3\tend of Xxx\n  \" 4\twrite\n\n  au FileReadCmd XtestB '[r Xxx\n  2r XtestB\t\t\t\" will read Xxx below line 2 instead\n  call assert_equal('start of Xxx', getline(3))\n\n  \" now we have:\n  \" 1\tstart of Xxx\n  \" 2\t\tabc2\n  \" 3\tstart of Xxx\n  \" 4\t\tabc2\n  \" 5\tend of Xxx\n  \" 6\tend of Xxx\n  \" 7\twrite\n\n  au FileWriteCmd XtestC '[,']copy $\n  normal 4GA1\n  4,5w XtestC\t\t\t\" will copy lines 4 and 5 to the end\n  call assert_equal(\"\\tabc21\", getline(8))\n  call assert_fails('r XtestC', 'E484')\t\" should not read anything\n  call assert_equal(\"end of Xxx\", getline(9))\n\n  \" now we have:\n  \" 1\tstart of Xxx\n  \" 2\t\tabc2\n  \" 3\tstart of Xxx\n  \" 4\t\tabc21\n  \" 5\tend of Xxx\n  \" 6\tend of Xxx\n  \" 7\twrite\n  \" 8\t\tabc21\n  \" 9\tend of Xxx\n\n  let g:lines = []\n  au FileAppendCmd XtestD call extend(g:lines, getline(line(\"'[\"), line(\"']\")))\n  w >>XtestD\t\t\t\" will add lines to 'lines'\n  call assert_equal(9, len(g:lines))\n  call assert_fails('$r XtestD', 'E484')\t\" should not read anything\n  call assert_equal(9, line('$'))\n  call assert_equal('end of Xxx', getline('$'))\n\n  au BufReadCmd XtestE 0r Xxx|$del\n  sp XtestE\t\t\t\" split window with test.out\n  call assert_equal('end of Xxx', getline(3))\n\n  let g:lines = []\n  exe \"normal 2Goasdf\\<Esc>\\<C-W>\\<C-W>\"\n  au BufWriteCmd XtestE call extend(g:lines, getline(0, '$'))\n  wall\t\t\t\t\" will write other window to 'lines'\n  call assert_equal(4, len(g:lines), g:lines)\n  call assert_equal('asdf', g:lines[2])\n\n  au! BufReadCmd\n  au! BufWriteCmd\n  au! FileReadCmd\n  au! FileWriteCmd\n  au! FileAppendCmd\n  %bwipe!\n  call delete('Xxx')\n  enew!\nendfunc\n\nfunc SetChangeMarks(start, end)\n  exe a:start. 'mark ['\n  exe a:end. 'mark ]'\nendfunc\n\n\" Verify the effects of autocmds on '[ and ']\nfunc Test_change_mark_in_autocmds()\n  edit! Xtest\n  call feedkeys(\"ia\\<CR>b\\<CR>c\\<CR>d\\<C-g>u\", 'xtn')\n\n  call SetChangeMarks(2, 3)\n  write\n  call assert_equal([1, 4], [line(\"'[\"), line(\"']\")])\n\n  call SetChangeMarks(2, 3)\n  au BufWritePre * call assert_equal([1, 4], [line(\"'[\"), line(\"']\")])\n  write\n  au! BufWritePre\n\n  if executable('cat')\n    write XtestFilter\n    write >> XtestFilter\n\n    call SetChangeMarks(2, 3)\n    \" Marks are set to the entire range of the write\n    au FilterWritePre * call assert_equal([1, 4], [line(\"'[\"), line(\"']\")])\n    \" '[ is adjusted to just before the line that will receive the filtered\n    \" data\n    au FilterReadPre * call assert_equal([4, 4], [line(\"'[\"), line(\"']\")])\n    \" The filtered data is read into the buffer, and the source lines are\n    \" still present, so the range is after the source lines\n    au FilterReadPost * call assert_equal([5, 12], [line(\"'[\"), line(\"']\")])\n    %!cat XtestFilter\n    \" After the filtered data is read, the original lines are deleted\n    call assert_equal([1, 8], [line(\"'[\"), line(\"']\")])\n    au! FilterWritePre,FilterReadPre,FilterReadPost\n    undo\n\n    call SetChangeMarks(1, 4)\n    au FilterWritePre * call assert_equal([2, 3], [line(\"'[\"), line(\"']\")])\n    au FilterReadPre * call assert_equal([3, 3], [line(\"'[\"), line(\"']\")])\n    au FilterReadPost * call assert_equal([4, 11], [line(\"'[\"), line(\"']\")])\n    2,3!cat XtestFilter\n    call assert_equal([2, 9], [line(\"'[\"), line(\"']\")])\n    au! FilterWritePre,FilterReadPre,FilterReadPost\n    undo\n\n    call delete('XtestFilter')\n  endif\n\n  call SetChangeMarks(1, 4)\n  au FileWritePre * call assert_equal([2, 3], [line(\"'[\"), line(\"']\")])\n  2,3write Xtest2\n  au! FileWritePre\n\n  call SetChangeMarks(2, 3)\n  au FileAppendPre * call assert_equal([1, 4], [line(\"'[\"), line(\"']\")])\n  write >> Xtest2\n  au! FileAppendPre\n\n  call SetChangeMarks(1, 4)\n  au FileAppendPre * call assert_equal([2, 3], [line(\"'[\"), line(\"']\")])\n  2,3write >> Xtest2\n  au! FileAppendPre\n\n  call SetChangeMarks(1, 1)\n  au FileReadPre * call assert_equal([3, 1], [line(\"'[\"), line(\"']\")])\n  au FileReadPost * call assert_equal([4, 11], [line(\"'[\"), line(\"']\")])\n  3read Xtest2\n  au! FileReadPre,FileReadPost\n  undo\n\n  call SetChangeMarks(4, 4)\n  \" When the line is 0, it's adjusted to 1\n  au FileReadPre * call assert_equal([1, 4], [line(\"'[\"), line(\"']\")])\n  au FileReadPost * call assert_equal([1, 8], [line(\"'[\"), line(\"']\")])\n  0read Xtest2\n  au! FileReadPre,FileReadPost\n  undo\n\n  call SetChangeMarks(4, 4)\n  \" When the line is 0, it's adjusted to 1\n  au FileReadPre * call assert_equal([1, 4], [line(\"'[\"), line(\"']\")])\n  au FileReadPost * call assert_equal([2, 9], [line(\"'[\"), line(\"']\")])\n  1read Xtest2\n  au! FileReadPre,FileReadPost\n  undo\n\n  bwipe!\n  call delete('Xtest')\n  call delete('Xtest2')\nendfunc\n\nfunc Test_Filter_noshelltemp()\n  if !executable('cat')\n    return\n  endif\n\n  enew!\n  call setline(1, ['a', 'b', 'c', 'd'])\n\n  let shelltemp = &shelltemp\n  set shelltemp\n\n  let g:filter_au = 0\n  au FilterWritePre * let g:filter_au += 1\n  au FilterReadPre * let g:filter_au += 1\n  au FilterReadPost * let g:filter_au += 1\n  %!cat\n  call assert_equal(3, g:filter_au)\n\n  if has('filterpipe')\n    set noshelltemp\n\n    let g:filter_au = 0\n    au FilterWritePre * let g:filter_au += 1\n    au FilterReadPre * let g:filter_au += 1\n    au FilterReadPost * let g:filter_au += 1\n    %!cat\n    call assert_equal(0, g:filter_au)\n  endif\n\n  au! FilterWritePre,FilterReadPre,FilterReadPost\n  let &shelltemp = shelltemp\n  bwipe!\nendfunc\n\nfunc Test_TextYankPost()\n  enew!\n  call setline(1, ['foo'])\n\n  let g:event = []\n  au TextYankPost * let g:event = copy(v:event)\n\n  call assert_equal({}, v:event)\n  call assert_fails('let v:event = {}', 'E46:')\n  call assert_fails('let v:event.mykey = 0', 'E742:')\n\n  norm \"ayiw\n  call assert_equal(\n    \\{'regcontents': ['foo'], 'regname': 'a', 'operator': 'y', 'regtype': 'v'},\n    \\g:event)\n  norm y_\n  call assert_equal(\n    \\{'regcontents': ['foo'], 'regname': '',  'operator': 'y', 'regtype': 'V'},\n    \\g:event)\n  call feedkeys(\"\\<C-V>y\", 'x')\n  call assert_equal(\n    \\{'regcontents': ['f'], 'regname': '',  'operator': 'y', 'regtype': \"\\x161\"},\n    \\g:event)\n  norm \"xciwbar\n  call assert_equal(\n    \\{'regcontents': ['foo'], 'regname': 'x', 'operator': 'c', 'regtype': 'v'},\n    \\g:event)\n  norm \"bdiw\n  call assert_equal(\n    \\{'regcontents': ['bar'], 'regname': 'b', 'operator': 'd', 'regtype': 'v'},\n    \\g:event)\n\n  call assert_equal({}, v:event)\n\n  au! TextYankPost\n  unlet g:event\n  bwipe!\nendfunc\n\nfunc Test_nocatch_wipe_all_buffers()\n  \" Real nasty autocommand: wipe all buffers on any event.\n  au * * bwipe *\n  \" Get E93 first?\n  \" call assert_fails('next x', 'E93:')\n  call assert_fails('next x', 'E517:')\n  bwipe\n  au!\nendfunc\n\nfunc Test_nocatch_wipe_dummy_buffer()\n  \" Nasty autocommand: wipe buffer on any event.\n  au * x bwipe\n  call assert_fails('lv\u00bd /x', 'E480')\n  au!\nendfunc\n\nfunction s:Before_test_dirchanged()\n  augroup test_dirchanged\n    autocmd!\n  augroup END\n  let s:li = []\n  let s:dir_this = getcwd()\n  let s:dir_foo = s:dir_this . '/foo'\n  call mkdir(s:dir_foo)\n  let s:dir_bar = s:dir_this . '/bar'\n  call mkdir(s:dir_bar)\nendfunc\n\nfunction s:After_test_dirchanged()\n  exe 'cd' s:dir_this\n  call delete(s:dir_foo, 'd')\n  call delete(s:dir_bar, 'd')\n  augroup test_dirchanged\n    autocmd!\n  augroup END\nendfunc\n\nfunction Test_dirchanged_global()\n  call s:Before_test_dirchanged()\n  autocmd test_dirchanged DirChanged global call add(s:li, \"cd:\")\n  autocmd test_dirchanged DirChanged global call add(s:li, expand(\"<afile>\"))\n  exe 'cd' s:dir_foo\n  call assert_equal([\"cd:\", s:dir_foo], s:li)\n  exe 'cd' s:dir_foo\n  call assert_equal([\"cd:\", s:dir_foo], s:li)\n  exe 'lcd' s:dir_bar\n  call assert_equal([\"cd:\", s:dir_foo], s:li)\n  call s:After_test_dirchanged()\nendfunc\n\nfunction Test_dirchanged_local()\n  call s:Before_test_dirchanged()\n  autocmd test_dirchanged DirChanged window call add(s:li, \"lcd:\")\n  autocmd test_dirchanged DirChanged window call add(s:li, expand(\"<afile>\"))\n  exe 'cd' s:dir_foo\n  call assert_equal([], s:li)\n  exe 'lcd' s:dir_bar\n  call assert_equal([\"lcd:\", s:dir_bar], s:li)\n  exe 'lcd' s:dir_bar\n  call assert_equal([\"lcd:\", s:dir_bar], s:li)\n  call s:After_test_dirchanged()\nendfunc\n\nfunction Test_dirchanged_auto()\n  if !exists('+autochdir')\n    return\n  endif\n  call s:Before_test_dirchanged()\n  call test_autochdir()\n  autocmd test_dirchanged DirChanged auto call add(s:li, \"auto:\")\n  autocmd test_dirchanged DirChanged auto call add(s:li, expand(\"<afile>\"))\n  set acd\n  exe 'cd ..'\n  call assert_equal([], s:li)\n  exe 'edit ' . s:dir_foo . '/Xfile'\n  call assert_equal(s:dir_foo, getcwd())\n  call assert_equal([\"auto:\", s:dir_foo], s:li)\n  set noacd\n  bwipe!\n  call s:After_test_dirchanged()\nendfunc\n\n\" Test TextChangedI and TextChangedP\nfunc Test_ChangedP()\n  new\n  call setline(1, ['foo', 'bar', 'foobar'])\n  call test_override(\"char_avail\", 1)\n  set complete=. completeopt=menuone\n\n  func! TextChangedAutocmd(char)\n    let g:autocmd .= a:char\n  endfunc\n\n  au! TextChanged <buffer> :call TextChangedAutocmd('N')\n  au! TextChangedI <buffer> :call TextChangedAutocmd('I')\n  au! TextChangedP <buffer> :call TextChangedAutocmd('P')\n\n  call cursor(3, 1)\n  let g:autocmd = ''\n  call feedkeys(\"o\\<esc>\", 'tnix')\n  call assert_equal('I', g:autocmd)\n\n  let g:autocmd = ''\n  call feedkeys(\"Sf\", 'tnix')\n  call assert_equal('II', g:autocmd)\n\n  let g:autocmd = ''\n  call feedkeys(\"Sf\\<C-N>\", 'tnix')\n  call assert_equal('IIP', g:autocmd)\n\n  let g:autocmd = ''\n  call feedkeys(\"Sf\\<C-N>\\<C-N>\", 'tnix')\n  call assert_equal('IIPP', g:autocmd)\n\n  let g:autocmd = ''\n  call feedkeys(\"Sf\\<C-N>\\<C-N>\\<C-N>\", 'tnix')\n  call assert_equal('IIPPP', g:autocmd)\n\n  let g:autocmd = ''\n  call feedkeys(\"Sf\\<C-N>\\<C-N>\\<C-N>\\<C-N>\", 'tnix')\n  call assert_equal('IIPPPP', g:autocmd)\n\n  call assert_equal(['foo', 'bar', 'foobar', 'foo'], getline(1, '$'))\n  \" TODO: how should it handle completeopt=noinsert,noselect?\n\n  \" CleanUp\n  call test_override(\"char_avail\", 0)\n  au! TextChanged\n  au! TextChangedI\n  au! TextChangedP\n  delfu TextChangedAutocmd\n  unlet! g:autocmd\n  set complete&vim completeopt&vim\n\n  bw!\nendfunc\n\nlet g:setline_handled = v:false\nfunc SetLineOne()\n  if !g:setline_handled\n    call setline(1, \"(x)\")\n    let g:setline_handled = v:true\n  endif\nendfunc\n\nfunc Test_TextChangedI_with_setline()\n  new\n  call test_override('char_avail', 1)\n  autocmd TextChangedI <buffer> call SetLineOne()\n  call feedkeys(\"i(\\<CR>\\<Esc>\", 'tx')\n  call assert_equal('(', getline(1))\n  call assert_equal('x)', getline(2))\n  undo\n  call assert_equal('', getline(1))\n  call assert_equal('', getline(2))\n\n  call test_override('starting', 0)\n  bwipe!\nendfunc\n\nfunc Test_Changed_FirstTime()\n  CheckFeature terminal\n  CheckNotGui\n\n  \" Prepare file for TextChanged event.\n  call writefile([''], 'Xchanged.txt')\n  let buf = term_start([GetVimProg(), '--clean', '-c', 'set noswapfile'], {'term_rows': 3})\n  call assert_equal('running', term_getstatus(buf))\n  \" Wait for the ruler (in the status line) to be shown.\n  \" In ConPTY, there is additional character which is drawn up to the width of\n  \" the screen.\n  if has('conpty')\n    call WaitForAssert({-> assert_match('\\<All.*$', term_getline(buf, 3))})\n  else\n    call WaitForAssert({-> assert_match('\\<All$', term_getline(buf, 3))})\n  endif\n  \" It's only adding autocmd, so that no event occurs.\n  call term_sendkeys(buf, \":au! TextChanged <buffer> call writefile(['No'], 'Xchanged.txt')\\<cr>\")\n  call term_sendkeys(buf, \"\\<C-\\\\>\\<C-N>:qa!\\<cr>\")\n  call WaitForAssert({-> assert_equal('finished', term_getstatus(buf))})\n  call assert_equal([''], readfile('Xchanged.txt'))\n\n  \" clean up\n  call delete('Xchanged.txt')\n  bwipe!\nendfunc\n\nfunc Test_autocmd_nested()\n  let g:did_nested = 0\n  augroup Testing\n    au WinNew * edit somefile\n    au BufNew * let g:did_nested = 1\n  augroup END\n  split\n  call assert_equal(0, g:did_nested)\n  close\n  bwipe! somefile\n\n  \" old nested argument still works\n  augroup Testing\n    au!\n    au WinNew * nested edit somefile\n    au BufNew * let g:did_nested = 1\n  augroup END\n  split\n  call assert_equal(1, g:did_nested)\n  close\n  bwipe! somefile\n\n  \" New ++nested argument works\n  augroup Testing\n    au!\n    au WinNew * ++nested edit somefile\n    au BufNew * let g:did_nested = 1\n  augroup END\n  split\n  call assert_equal(1, g:did_nested)\n  close\n  bwipe! somefile\n\n  augroup Testing\n    au!\n  augroup END\n\n  call assert_fails('au WinNew * ++nested ++nested echo bad', 'E983:')\n  call assert_fails('au WinNew * nested nested echo bad', 'E983:')\nendfunc\n\nfunc Test_autocmd_once()\n  \" Without ++once WinNew triggers twice\n  let g:did_split = 0\n  augroup Testing\n    au WinNew * let g:did_split += 1\n  augroup END\n  split\n  split\n  call assert_equal(2, g:did_split)\n  call assert_true(exists('#WinNew'))\n  close\n  close\n\n  \" With ++once WinNew triggers once\n  let g:did_split = 0\n  augroup Testing\n    au!\n    au WinNew * ++once let g:did_split += 1\n  augroup END\n  split\n  split\n  call assert_equal(1, g:did_split)\n  call assert_false(exists('#WinNew'))\n  close\n  close\n\n  call assert_fails('au WinNew * ++once ++once echo bad', 'E983:')\nendfunc\n\nfunc Test_autocmd_bufreadpre()\n  new\n  let b:bufreadpre = 1\n  call append(0, range(100))\n  w! XAutocmdBufReadPre.txt\n  autocmd BufReadPre <buffer> :let b:bufreadpre += 1\n  norm! 50gg\n  sp\n  norm! 100gg\n  wincmd p\n  let g:wsv1 = winsaveview()\n  wincmd p\n  let g:wsv2 = winsaveview()\n  \" triggers BufReadPre, should not move the cursor in either window\n  \" The topline may change one line in a large window.\n  edit\n  call assert_inrange(g:wsv2.topline - 1, g:wsv2.topline + 1, winsaveview().topline)\n  call assert_equal(g:wsv2.lnum, winsaveview().lnum)\n  call assert_equal(2, b:bufreadpre)\n  wincmd p\n  call assert_equal(g:wsv1.topline, winsaveview().topline)\n  call assert_equal(g:wsv1.lnum, winsaveview().lnum)\n  call assert_equal(2, b:bufreadpre)\n  \" Now set the cursor position in an BufReadPre autocommand\n  \" (even though the position will be invalid, this should make Vim reset the\n  \" cursor position in the other window.\n  wincmd p\n  set cpo+=g\n  \" won't do anything, but try to set the cursor on an invalid lnum\n  autocmd BufReadPre <buffer> :norm! 70gg\n  \" triggers BufReadPre, should not move the cursor in either window\n  e\n  call assert_equal(1, winsaveview().topline)\n  call assert_equal(1, winsaveview().lnum)\n  call assert_equal(3, b:bufreadpre)\n  wincmd p\n  call assert_equal(g:wsv1.topline, winsaveview().topline)\n  call assert_equal(g:wsv1.lnum, winsaveview().lnum)\n  call assert_equal(3, b:bufreadpre)\n  close\n  close\n  call delete('XAutocmdBufReadPre.txt')\n  set cpo-=g\nendfunc\n\n\" FileChangedShell tested in test_filechanged.vim\n\n\" Tests for the following autocommands:\n\" - FileWritePre\twriting a compressed file\n\" - FileReadPost\treading a compressed file\n\" - BufNewFile\t\treading a file template\n\" - BufReadPre\t\tdecompressing the file to be read\n\" - FilterReadPre\tsubstituting characters in the temp file\n\" - FilterReadPost\tsubstituting characters after filtering\n\" - FileReadPre\t\tset options for decompression\n\" - FileReadPost\tdecompress the file\nfunc Test_ReadWrite_Autocmds()\n  \" Run this test only on Unix-like systems and if gzip is available\n  if !has('unix') || !executable(\"gzip\")\n    return\n  endif\n\n  \" Make $GZIP empty, \"-v\" would cause trouble.\n  let $GZIP = \"\"\n\n  \" Use a FileChangedShell autocommand to avoid a prompt for 'Xtestfile.gz'\n  \" being modified outside of Vim (noticed on Solaris).\n  au FileChangedShell * echo 'caught FileChangedShell'\n\n  \" Test for the FileReadPost, FileWritePre and FileWritePost autocmds\n  augroup Test1\n    au!\n    au FileWritePre    *.gz   '[,']!gzip\n    au FileWritePost   *.gz   undo\n    au FileReadPost    *.gz   '[,']!gzip -d\n  augroup END\n\n  new\n  set bin\n  call append(0, [\n\t      \\ 'line 2\tAbcdefghijklmnopqrstuvwxyz',\n\t      \\ 'line 3\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',\n\t      \\ 'line 4\tAbcdefghijklmnopqrstuvwxyz',\n\t      \\ 'line 5\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',\n\t      \\ 'line 6\tAbcdefghijklmnopqrstuvwxyz',\n\t      \\ 'line 7\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',\n\t      \\ 'line 8\tAbcdefghijklmnopqrstuvwxyz',\n\t      \\ 'line 9\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',\n\t      \\ 'line 10 Abcdefghijklmnopqrstuvwxyz'\n\t      \\ ])\n  1,9write! Xtestfile.gz\n  enew! | close\n\n  new\n  \" Read and decompress the testfile\n  0read Xtestfile.gz\n  call assert_equal([\n\t      \\ 'line 2\tAbcdefghijklmnopqrstuvwxyz',\n\t      \\ 'line 3\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',\n\t      \\ 'line 4\tAbcdefghijklmnopqrstuvwxyz',\n\t      \\ 'line 5\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',\n\t      \\ 'line 6\tAbcdefghijklmnopqrstuvwxyz',\n\t      \\ 'line 7\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',\n\t      \\ 'line 8\tAbcdefghijklmnopqrstuvwxyz',\n\t      \\ 'line 9\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',\n\t      \\ 'line 10 Abcdefghijklmnopqrstuvwxyz'\n\t      \\ ], getline(1, 9))\n  enew! | close\n\n  augroup Test1\n    au!\n  augroup END\n\n  \" Test for the FileAppendPre and FileAppendPost autocmds\n  augroup Test2\n    au!\n    au BufNewFile      *.c    read Xtest.c\n    au FileAppendPre   *.out  '[,']s/new/NEW/\n    au FileAppendPost  *.out  !cat Xtest.c >> test.out\n  augroup END\n\n  call writefile(['/*', ' * Here is a new .c file', ' */'], 'Xtest.c')\n  new foo.c\t\t\t\" should load Xtest.c\n  call assert_equal(['/*', ' * Here is a new .c file', ' */'], getline(2, 4))\n  w! >> test.out\t\t\" append it to the output file\n\n  let contents = readfile('test.out')\n  call assert_equal(' * Here is a NEW .c file', contents[2])\n  call assert_equal(' * Here is a new .c file', contents[5])\n\n  call delete('test.out')\n  enew! | close\n  augroup Test2\n    au!\n  augroup END\n\n  \" Test for the BufReadPre and BufReadPost autocmds\n  augroup Test3\n    au!\n    \" setup autocommands to decompress before reading and re-compress\n    \" afterwards\n    au BufReadPre  *.gz  exe '!gzip -d ' . shellescape(expand(\"<afile>\"))\n    au BufReadPre  *.gz  call rename(expand(\"<afile>:r\"), expand(\"<afile>\"))\n    au BufReadPost *.gz  call rename(expand(\"<afile>\"), expand(\"<afile>:r\"))\n    au BufReadPost *.gz  exe '!gzip ' . shellescape(expand(\"<afile>:r\"))\n  augroup END\n\n  e! Xtestfile.gz\t\t\" Edit compressed file\n  call assert_equal([\n\t      \\ 'line 2\tAbcdefghijklmnopqrstuvwxyz',\n\t      \\ 'line 3\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',\n\t      \\ 'line 4\tAbcdefghijklmnopqrstuvwxyz',\n\t      \\ 'line 5\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',\n\t      \\ 'line 6\tAbcdefghijklmnopqrstuvwxyz',\n\t      \\ 'line 7\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',\n\t      \\ 'line 8\tAbcdefghijklmnopqrstuvwxyz',\n\t      \\ 'line 9\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',\n\t      \\ 'line 10 Abcdefghijklmnopqrstuvwxyz'\n\t      \\ ], getline(1, 9))\n\n  w! >> test.out\t\t\" Append it to the output file\n\n  augroup Test3\n    au!\n  augroup END\n\n  \" Test for the FilterReadPre and FilterReadPost autocmds.\n  set shelltemp\t\t\t\" need temp files here\n  augroup Test4\n    au!\n    au FilterReadPre   *.out  call rename(expand(\"<afile>\"), expand(\"<afile>\") . \".t\")\n    au FilterReadPre   *.out  exe 'silent !sed s/e/E/ ' . shellescape(expand(\"<afile>\")) . \".t >\" . shellescape(expand(\"<afile>\"))\n    au FilterReadPre   *.out  exe 'silent !rm ' . shellescape(expand(\"<afile>\")) . '.t'\n    au FilterReadPost  *.out  '[,']s/x/X/g\n  augroup END\n\n  e! test.out\t\t\t\" Edit the output file\n  1,$!cat\n  call assert_equal([\n\t      \\ 'linE 2\tAbcdefghijklmnopqrstuvwXyz',\n\t      \\ 'linE 3\tXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX',\n\t      \\ 'linE 4\tAbcdefghijklmnopqrstuvwXyz',\n\t      \\ 'linE 5\tXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX',\n\t      \\ 'linE 6\tAbcdefghijklmnopqrstuvwXyz',\n\t      \\ 'linE 7\tXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX',\n\t      \\ 'linE 8\tAbcdefghijklmnopqrstuvwXyz',\n\t      \\ 'linE 9\tXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX',\n\t      \\ 'linE 10 AbcdefghijklmnopqrstuvwXyz'\n\t      \\ ], getline(1, 9))\n  call assert_equal([\n\t      \\ 'line 2\tAbcdefghijklmnopqrstuvwxyz',\n\t      \\ 'line 3\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',\n\t      \\ 'line 4\tAbcdefghijklmnopqrstuvwxyz',\n\t      \\ 'line 5\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',\n\t      \\ 'line 6\tAbcdefghijklmnopqrstuvwxyz',\n\t      \\ 'line 7\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',\n\t      \\ 'line 8\tAbcdefghijklmnopqrstuvwxyz',\n\t      \\ 'line 9\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',\n\t      \\ 'line 10 Abcdefghijklmnopqrstuvwxyz'\n\t      \\ ], readfile('test.out'))\n\n  augroup Test4\n    au!\n  augroup END\n  set shelltemp&vim\n\n  \" Test for the FileReadPre and FileReadPost autocmds.\n  augroup Test5\n    au!\n    au FileReadPre *.gz exe 'silent !gzip -d ' . shellescape(expand(\"<afile>\"))\n    au FileReadPre *.gz call rename(expand(\"<afile>:r\"), expand(\"<afile>\"))\n    au FileReadPost *.gz '[,']s/l/L/\n  augroup END\n\n  new\n  0r Xtestfile.gz\t\t\" Read compressed file\n  call assert_equal([\n\t      \\ 'Line 2\tAbcdefghijklmnopqrstuvwxyz',\n\t      \\ 'Line 3\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',\n\t      \\ 'Line 4\tAbcdefghijklmnopqrstuvwxyz',\n\t      \\ 'Line 5\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',\n\t      \\ 'Line 6\tAbcdefghijklmnopqrstuvwxyz',\n\t      \\ 'Line 7\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',\n\t      \\ 'Line 8\tAbcdefghijklmnopqrstuvwxyz',\n\t      \\ 'Line 9\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',\n\t      \\ 'Line 10 Abcdefghijklmnopqrstuvwxyz'\n\t      \\ ], getline(1, 9))\n  call assert_equal([\n\t      \\ 'line 2\tAbcdefghijklmnopqrstuvwxyz',\n\t      \\ 'line 3\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',\n\t      \\ 'line 4\tAbcdefghijklmnopqrstuvwxyz',\n\t      \\ 'line 5\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',\n\t      \\ 'line 6\tAbcdefghijklmnopqrstuvwxyz',\n\t      \\ 'line 7\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',\n\t      \\ 'line 8\tAbcdefghijklmnopqrstuvwxyz',\n\t      \\ 'line 9\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',\n\t      \\ 'line 10 Abcdefghijklmnopqrstuvwxyz'\n\t      \\ ], readfile('Xtestfile.gz'))\n\n  augroup Test5\n    au!\n  augroup END\n\n  au! FileChangedShell\n  call delete('Xtestfile.gz')\n  call delete('Xtest.c')\n  call delete('test.out')\nendfunc\n\nfunc Test_throw_in_BufWritePre()\n  new\n  call setline(1, ['one', 'two', 'three'])\n  call assert_false(filereadable('Xthefile'))\n  augroup throwing\n    au BufWritePre X* throw 'do not write'\n  augroup END\n  try\n    w Xthefile\n  catch\n    let caught = 1\n  endtry\n  call assert_equal(1, caught)\n  call assert_false(filereadable('Xthefile'))\n\n  bwipe!\n  au! throwing\nendfunc\n\nfunc Test_autocmd_SafeState()\n  CheckRunVimInTerminal\n\n  let lines =<< trim END\n\tlet g:safe = 0\n\tlet g:again = ''\n\tau SafeState * let g:safe += 1\n\tau SafeStateAgain * let g:again ..= 'x'\n\tfunc CallTimer()\n\t  call timer_start(10, {id -> execute('let g:again ..= \"t\"')})\n\tendfunc\n  END\n  call writefile(lines, 'XSafeState')\n  let buf = RunVimInTerminal('-S XSafeState', #{rows: 6})\n\n  \" Sometimes we loop to handle an K_IGNORE\n  call term_sendkeys(buf, \":echo g:safe\\<CR>\")\n  call WaitForAssert({-> assert_match('^[12] ', term_getline(buf, 6))}, 1000)\n\n  call term_sendkeys(buf, \":echo g:again\\<CR>\")\n  call WaitForAssert({-> assert_match('^xxxx', term_getline(buf, 6))}, 1000)\n\n  call term_sendkeys(buf, \":let g:again = ''\\<CR>:call CallTimer()\\<CR>\")\n  call term_wait(buf)\n  call term_sendkeys(buf, \":\\<CR>\")\n  call term_wait(buf)\n  call term_sendkeys(buf, \":echo g:again\\<CR>\")\n  call WaitForAssert({-> assert_match('xtx', term_getline(buf, 6))}, 1000)\n\n  call StopVimInTerminal(buf)\n  call delete('XSafeState')\nendfunc\n\nfunc Test_autocmd_CmdWinEnter()\n  CheckRunVimInTerminal\n  \" There is not cmdwin switch, so\n  \" test for cmdline_hist\n  \" (both are available with small builds)\n  CheckFeature cmdline_hist\n  let lines =<< trim END\n    let b:dummy_var = 'This is a dummy'\n    autocmd CmdWinEnter * quit\n    let winnr = winnr('$')\n  END\n  let filename='XCmdWinEnter'\n  call writefile(lines, filename)\n  let buf = RunVimInTerminal('-S '.filename, #{rows: 6})\n\n  call term_sendkeys(buf, \"q:\")\n  call term_wait(buf)\n  call term_sendkeys(buf, \":echo b:dummy_var\\<cr>\")\n  call WaitForAssert({-> assert_match('^This is a dummy', term_getline(buf, 6))}, 1000)\n  call term_sendkeys(buf, \":echo &buftype\\<cr>\")\n  call WaitForAssert({-> assert_notmatch('^nofile', term_getline(buf, 6))}, 1000)\n  call term_sendkeys(buf, \":echo winnr\\<cr>\")\n  call WaitForAssert({-> assert_match('^1', term_getline(buf, 6))}, 1000)\n\n  \" clean up\n  call StopVimInTerminal(buf)\n  call delete(filename)\nendfunc\n\nfunc Test_autocmd_was_using_freed_memory()\n  pedit xx\n  n x\n  au WinEnter * quit\n  split\n  au! WinEnter\nendfunc\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n#ifdef AMIGA\n# include <time.h>\t/* for time() */\n#endif\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n    strcat(longVersion, \")\");\n}\n\n# else\n    void\ninit_longVersion(void)\n{\n    char *date_time = __DATE__ \" \" __TIME__;\n    char *msg = _(\"%s (%s, compiled %s)\");\n    size_t len = strlen(msg)\n\t\t+ strlen(VIM_VERSION_LONG_ONLY)\n\t\t+ strlen(VIM_VERSION_DATE_ONLY)\n\t\t+ strlen(date_time);\n\n    longVersion = alloc(len);\n    if (longVersion == NULL)\n\tlongVersion = VIM_VERSION_LONG;\n    else\n\tvim_snprintf(longVersion, len, msg,\n\t\t      VIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t/* only for Amiga systems */\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n#ifdef NO_BUILTIN_TCAPS\n\t\"-builtin_terms\",\n#endif\n#ifdef SOME_BUILTIN_TCAPS\n\t\"+builtin_terms\",\n#endif\n#ifdef ALL_BUILTIN_TCAPS\n\t\"++builtin_terms\",\n#endif\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n#ifdef FEAT_CINDENT\n\t\"+cindent\",\n#else\n\t\"-cindent\",\n#endif\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n#ifdef FEAT_CMDL_INFO\n\t\"+cmdline_info\",\n#else\n\t\"-cmdline_info\",\n#endif\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n#ifdef EBCDIC\n\t\"+ebcdic\",\n#else\n\t\"-ebcdic\",\n#endif\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n#ifdef FEAT_SEARCHPATH\n\t\"+file_in_path\",\n#else\n\t\"-file_in_path\",\n#endif\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n#ifdef FEAT_FLOAT\n\t\"+float\",\n#else\n\t\"-float\",\n#endif\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n#ifdef FEAT_FOOTER\n\t\"+footer\",\n#else\n\t\"-footer\",\n#endif\n\t    /* only interesting on Unix systems */\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n#ifdef FEAT_HANGULIN\n\t\"+hangul_input\",\n#else\n\t\"-hangul_input\",\n#endif\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n#ifdef FEAT_JUMPLIST\n\t\"+jumplist\",\n#else\n\t\"-jumplist\",\n#endif\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n#ifdef FEAT_LISP\n\t\"+lispindent\",\n#else\n\t\"-lispindent\",\n#endif\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n#ifdef FEAT_MOUSE\n\t\"+mouse\",\n#  ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#  else\n\t\"-mouseshape\",\n#  endif\n# else\n\t\"-mouse\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n\t\"+mouse_gpm\",\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_XTERM\n\t\"+mouse_sgr\",\n# else\n\t\"-mouse_sgr\",\n# endif\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n# ifdef FEAT_MOUSE_XTERM\n\t\"+mouse_xterm\",\n# else\n\t\"-mouse_xterm\",\n# endif\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n#ifdef FEAT_NUM64\n\t\"+num64\",\n#else\n\t\"-num64\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n#ifdef FEAT_PATH_EXTRA\n\t\"+path_extra\",\n#else\n\t\"-path_extra\",\n#endif\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n\t\"+python3/dyn\",\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n#ifdef FEAT_SMARTINDENT\n\t\"+smartindent\",\n#else\n\t\"-smartindent\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    /* only interesting on Unix systems */\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n#ifdef FEAT_TAG_BINS\n\t\"+tag_binary\",\n#else\n\t\"-tag_binary\",\n#endif\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n/* only Unix can have terminfo instead of termcap */\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n#ifdef FEAT_TEXTOBJ\n\t\"+textobjects\",\n#else\n\t\"-textobjects\",\n#endif\n#ifdef FEAT_TEXT_PROP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n/* unix always includes termcap support */\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n#ifdef FEAT_TITLE\n\t\"+title\",\n#else\n\t\"-title\",\n#endif\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n#ifdef FEAT_WILDIGN\n\t\"+wildignore\",\n#else\n\t\"-wildignore\",\n#endif\n#ifdef FEAT_WILDMENU\n\t\"+wildmenu\",\n#else\n\t\"-wildmenu\",\n#endif\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#ifdef MSWIN\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#else\n# ifdef HAVE_XPM\n\t\"+xpm\",\n# else\n\t\"-xpm\",\n# endif\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef USE_XSMP_INTERACT\n\t\"+xsmp_interact\",\n# else\n#  ifdef USE_XSMP\n\t\"+xsmp\",\n#  else\n\t\"-xsmp\",\n#  endif\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    2136,\n/**/\n    2135,\n/**/\n    2134,\n/**/\n    2133,\n/**/\n    2132,\n/**/\n    2131,\n/**/\n    2130,\n/**/\n    2129,\n/**/\n    2128,\n/**/\n    2127,\n/**/\n    2126,\n/**/\n    2125,\n/**/\n    2124,\n/**/\n    2123,\n/**/\n    2122,\n/**/\n    2121,\n/**/\n    2120,\n/**/\n    2119,\n/**/\n    2118,\n/**/\n    2117,\n/**/\n    2116,\n/**/\n    2115,\n/**/\n    2114,\n/**/\n    2113,\n/**/\n    2112,\n/**/\n    2111,\n/**/\n    2110,\n/**/\n    2109,\n/**/\n    2108,\n/**/\n    2107,\n/**/\n    2106,\n/**/\n    2105,\n/**/\n    2104,\n/**/\n    2103,\n/**/\n    2102,\n/**/\n    2101,\n/**/\n    2100,\n/**/\n    2099,\n/**/\n    2098,\n/**/\n    2097,\n/**/\n    2096,\n/**/\n    2095,\n/**/\n    2094,\n/**/\n    2093,\n/**/\n    2092,\n/**/\n    2091,\n/**/\n    2090,\n/**/\n    2089,\n/**/\n    2088,\n/**/\n    2087,\n/**/\n    2086,\n/**/\n    2085,\n/**/\n    2084,\n/**/\n    2083,\n/**/\n    2082,\n/**/\n    2081,\n/**/\n    2080,\n/**/\n    2079,\n/**/\n    2078,\n/**/\n    2077,\n/**/\n    2076,\n/**/\n    2075,\n/**/\n    2074,\n/**/\n    2073,\n/**/\n    2072,\n/**/\n    2071,\n/**/\n    2070,\n/**/\n    2069,\n/**/\n    2068,\n/**/\n    2067,\n/**/\n    2066,\n/**/\n    2065,\n/**/\n    2064,\n/**/\n    2063,\n/**/\n    2062,\n/**/\n    2061,\n/**/\n    2060,\n/**/\n    2059,\n/**/\n    2058,\n/**/\n    2057,\n/**/\n    2056,\n/**/\n    2055,\n/**/\n    2054,\n/**/\n    2053,\n/**/\n    2052,\n/**/\n    2051,\n/**/\n    2050,\n/**/\n    2049,\n/**/\n    2048,\n/**/\n    2047,\n/**/\n    2046,\n/**/\n    2045,\n/**/\n    2044,\n/**/\n    2043,\n/**/\n    2042,\n/**/\n    2041,\n/**/\n    2040,\n/**/\n    2039,\n/**/\n    2038,\n/**/\n    2037,\n/**/\n    2036,\n/**/\n    2035,\n/**/\n    2034,\n/**/\n    2033,\n/**/\n    2032,\n/**/\n    2031,\n/**/\n    2030,\n/**/\n    2029,\n/**/\n    2028,\n/**/\n    2027,\n/**/\n    2026,\n/**/\n    2025,\n/**/\n    2024,\n/**/\n    2023,\n/**/\n    2022,\n/**/\n    2021,\n/**/\n    2020,\n/**/\n    2019,\n/**/\n    2018,\n/**/\n    2017,\n/**/\n    2016,\n/**/\n    2015,\n/**/\n    2014,\n/**/\n    2013,\n/**/\n    2012,\n/**/\n    2011,\n/**/\n    2010,\n/**/\n    2009,\n/**/\n    2008,\n/**/\n    2007,\n/**/\n    2006,\n/**/\n    2005,\n/**/\n    2004,\n/**/\n    2003,\n/**/\n    2002,\n/**/\n    2001,\n/**/\n    2000,\n/**/\n    1999,\n/**/\n    1998,\n/**/\n    1997,\n/**/\n    1996,\n/**/\n    1995,\n/**/\n    1994,\n/**/\n    1993,\n/**/\n    1992,\n/**/\n    1991,\n/**/\n    1990,\n/**/\n    1989,\n/**/\n    1988,\n/**/\n    1987,\n/**/\n    1986,\n/**/\n    1985,\n/**/\n    1984,\n/**/\n    1983,\n/**/\n    1982,\n/**/\n    1981,\n/**/\n    1980,\n/**/\n    1979,\n/**/\n    1978,\n/**/\n    1977,\n/**/\n    1976,\n/**/\n    1975,\n/**/\n    1974,\n/**/\n    1973,\n/**/\n    1972,\n/**/\n    1971,\n/**/\n    1970,\n/**/\n    1969,\n/**/\n    1968,\n/**/\n    1967,\n/**/\n    1966,\n/**/\n    1965,\n/**/\n    1964,\n/**/\n    1963,\n/**/\n    1962,\n/**/\n    1961,\n/**/\n    1960,\n/**/\n    1959,\n/**/\n    1958,\n/**/\n    1957,\n/**/\n    1956,\n/**/\n    1955,\n/**/\n    1954,\n/**/\n    1953,\n/**/\n    1952,\n/**/\n    1951,\n/**/\n    1950,\n/**/\n    1949,\n/**/\n    1948,\n/**/\n    1947,\n/**/\n    1946,\n/**/\n    1945,\n/**/\n    1944,\n/**/\n    1943,\n/**/\n    1942,\n/**/\n    1941,\n/**/\n    1940,\n/**/\n    1939,\n/**/\n    1938,\n/**/\n    1937,\n/**/\n    1936,\n/**/\n    1935,\n/**/\n    1934,\n/**/\n    1933,\n/**/\n    1932,\n/**/\n    1931,\n/**/\n    1930,\n/**/\n    1929,\n/**/\n    1928,\n/**/\n    1927,\n/**/\n    1926,\n/**/\n    1925,\n/**/\n    1924,\n/**/\n    1923,\n/**/\n    1922,\n/**/\n    1921,\n/**/\n    1920,\n/**/\n    1919,\n/**/\n    1918,\n/**/\n    1917,\n/**/\n    1916,\n/**/\n    1915,\n/**/\n    1914,\n/**/\n    1913,\n/**/\n    1912,\n/**/\n    1911,\n/**/\n    1910,\n/**/\n    1909,\n/**/\n    1908,\n/**/\n    1907,\n/**/\n    1906,\n/**/\n    1905,\n/**/\n    1904,\n/**/\n    1903,\n/**/\n    1902,\n/**/\n    1901,\n/**/\n    1900,\n/**/\n    1899,\n/**/\n    1898,\n/**/\n    1897,\n/**/\n    1896,\n/**/\n    1895,\n/**/\n    1894,\n/**/\n    1893,\n/**/\n    1892,\n/**/\n    1891,\n/**/\n    1890,\n/**/\n    1889,\n/**/\n    1888,\n/**/\n    1887,\n/**/\n    1886,\n/**/\n    1885,\n/**/\n    1884,\n/**/\n    1883,\n/**/\n    1882,\n/**/\n    1881,\n/**/\n    1880,\n/**/\n    1879,\n/**/\n    1878,\n/**/\n    1877,\n/**/\n    1876,\n/**/\n    1875,\n/**/\n    1874,\n/**/\n    1873,\n/**/\n    1872,\n/**/\n    1871,\n/**/\n    1870,\n/**/\n    1869,\n/**/\n    1868,\n/**/\n    1867,\n/**/\n    1866,\n/**/\n    1865,\n/**/\n    1864,\n/**/\n    1863,\n/**/\n    1862,\n/**/\n    1861,\n/**/\n    1860,\n/**/\n    1859,\n/**/\n    1858,\n/**/\n    1857,\n/**/\n    1856,\n/**/\n    1855,\n/**/\n    1854,\n/**/\n    1853,\n/**/\n    1852,\n/**/\n    1851,\n/**/\n    1850,\n/**/\n    1849,\n/**/\n    1848,\n/**/\n    1847,\n/**/\n    1846,\n/**/\n    1845,\n/**/\n    1844,\n/**/\n    1843,\n/**/\n    1842,\n/**/\n    1841,\n/**/\n    1840,\n/**/\n    1839,\n/**/\n    1838,\n/**/\n    1837,\n/**/\n    1836,\n/**/\n    1835,\n/**/\n    1834,\n/**/\n    1833,\n/**/\n    1832,\n/**/\n    1831,\n/**/\n    1830,\n/**/\n    1829,\n/**/\n    1828,\n/**/\n    1827,\n/**/\n    1826,\n/**/\n    1825,\n/**/\n    1824,\n/**/\n    1823,\n/**/\n    1822,\n/**/\n    1821,\n/**/\n    1820,\n/**/\n    1819,\n/**/\n    1818,\n/**/\n    1817,\n/**/\n    1816,\n/**/\n    1815,\n/**/\n    1814,\n/**/\n    1813,\n/**/\n    1812,\n/**/\n    1811,\n/**/\n    1810,\n/**/\n    1809,\n/**/\n    1808,\n/**/\n    1807,\n/**/\n    1806,\n/**/\n    1805,\n/**/\n    1804,\n/**/\n    1803,\n/**/\n    1802,\n/**/\n    1801,\n/**/\n    1800,\n/**/\n    1799,\n/**/\n    1798,\n/**/\n    1797,\n/**/\n    1796,\n/**/\n    1795,\n/**/\n    1794,\n/**/\n    1793,\n/**/\n    1792,\n/**/\n    1791,\n/**/\n    1790,\n/**/\n    1789,\n/**/\n    1788,\n/**/\n    1787,\n/**/\n    1786,\n/**/\n    1785,\n/**/\n    1784,\n/**/\n    1783,\n/**/\n    1782,\n/**/\n    1781,\n/**/\n    1780,\n/**/\n    1779,\n/**/\n    1778,\n/**/\n    1777,\n/**/\n    1776,\n/**/\n    1775,\n/**/\n    1774,\n/**/\n    1773,\n/**/\n    1772,\n/**/\n    1771,\n/**/\n    1770,\n/**/\n    1769,\n/**/\n    1768,\n/**/\n    1767,\n/**/\n    1766,\n/**/\n    1765,\n/**/\n    1764,\n/**/\n    1763,\n/**/\n    1762,\n/**/\n    1761,\n/**/\n    1760,\n/**/\n    1759,\n/**/\n    1758,\n/**/\n    1757,\n/**/\n    1756,\n/**/\n    1755,\n/**/\n    1754,\n/**/\n    1753,\n/**/\n    1752,\n/**/\n    1751,\n/**/\n    1750,\n/**/\n    1749,\n/**/\n    1748,\n/**/\n    1747,\n/**/\n    1746,\n/**/\n    1745,\n/**/\n    1744,\n/**/\n    1743,\n/**/\n    1742,\n/**/\n    1741,\n/**/\n    1740,\n/**/\n    1739,\n/**/\n    1738,\n/**/\n    1737,\n/**/\n    1736,\n/**/\n    1735,\n/**/\n    1734,\n/**/\n    1733,\n/**/\n    1732,\n/**/\n    1731,\n/**/\n    1730,\n/**/\n    1729,\n/**/\n    1728,\n/**/\n    1727,\n/**/\n    1726,\n/**/\n    1725,\n/**/\n    1724,\n/**/\n    1723,\n/**/\n    1722,\n/**/\n    1721,\n/**/\n    1720,\n/**/\n    1719,\n/**/\n    1718,\n/**/\n    1717,\n/**/\n    1716,\n/**/\n    1715,\n/**/\n    1714,\n/**/\n    1713,\n/**/\n    1712,\n/**/\n    1711,\n/**/\n    1710,\n/**/\n    1709,\n/**/\n    1708,\n/**/\n    1707,\n/**/\n    1706,\n/**/\n    1705,\n/**/\n    1704,\n/**/\n    1703,\n/**/\n    1702,\n/**/\n    1701,\n/**/\n    1700,\n/**/\n    1699,\n/**/\n    1698,\n/**/\n    1697,\n/**/\n    1696,\n/**/\n    1695,\n/**/\n    1694,\n/**/\n    1693,\n/**/\n    1692,\n/**/\n    1691,\n/**/\n    1690,\n/**/\n    1689,\n/**/\n    1688,\n/**/\n    1687,\n/**/\n    1686,\n/**/\n    1685,\n/**/\n    1684,\n/**/\n    1683,\n/**/\n    1682,\n/**/\n    1681,\n/**/\n    1680,\n/**/\n    1679,\n/**/\n    1678,\n/**/\n    1677,\n/**/\n    1676,\n/**/\n    1675,\n/**/\n    1674,\n/**/\n    1673,\n/**/\n    1672,\n/**/\n    1671,\n/**/\n    1670,\n/**/\n    1669,\n/**/\n    1668,\n/**/\n    1667,\n/**/\n    1666,\n/**/\n    1665,\n/**/\n    1664,\n/**/\n    1663,\n/**/\n    1662,\n/**/\n    1661,\n/**/\n    1660,\n/**/\n    1659,\n/**/\n    1658,\n/**/\n    1657,\n/**/\n    1656,\n/**/\n    1655,\n/**/\n    1654,\n/**/\n    1653,\n/**/\n    1652,\n/**/\n    1651,\n/**/\n    1650,\n/**/\n    1649,\n/**/\n    1648,\n/**/\n    1647,\n/**/\n    1646,\n/**/\n    1645,\n/**/\n    1644,\n/**/\n    1643,\n/**/\n    1642,\n/**/\n    1641,\n/**/\n    1640,\n/**/\n    1639,\n/**/\n    1638,\n/**/\n    1637,\n/**/\n    1636,\n/**/\n    1635,\n/**/\n    1634,\n/**/\n    1633,\n/**/\n    1632,\n/**/\n    1631,\n/**/\n    1630,\n/**/\n    1629,\n/**/\n    1628,\n/**/\n    1627,\n/**/\n    1626,\n/**/\n    1625,\n/**/\n    1624,\n/**/\n    1623,\n/**/\n    1622,\n/**/\n    1621,\n/**/\n    1620,\n/**/\n    1619,\n/**/\n    1618,\n/**/\n    1617,\n/**/\n    1616,\n/**/\n    1615,\n/**/\n    1614,\n/**/\n    1613,\n/**/\n    1612,\n/**/\n    1611,\n/**/\n    1610,\n/**/\n    1609,\n/**/\n    1608,\n/**/\n    1607,\n/**/\n    1606,\n/**/\n    1605,\n/**/\n    1604,\n/**/\n    1603,\n/**/\n    1602,\n/**/\n    1601,\n/**/\n    1600,\n/**/\n    1599,\n/**/\n    1598,\n/**/\n    1597,\n/**/\n    1596,\n/**/\n    1595,\n/**/\n    1594,\n/**/\n    1593,\n/**/\n    1592,\n/**/\n    1591,\n/**/\n    1590,\n/**/\n    1589,\n/**/\n    1588,\n/**/\n    1587,\n/**/\n    1586,\n/**/\n    1585,\n/**/\n    1584,\n/**/\n    1583,\n/**/\n    1582,\n/**/\n    1581,\n/**/\n    1580,\n/**/\n    1579,\n/**/\n    1578,\n/**/\n    1577,\n/**/\n    1576,\n/**/\n    1575,\n/**/\n    1574,\n/**/\n    1573,\n/**/\n    1572,\n/**/\n    1571,\n/**/\n    1570,\n/**/\n    1569,\n/**/\n    1568,\n/**/\n    1567,\n/**/\n    1566,\n/**/\n    1565,\n/**/\n    1564,\n/**/\n    1563,\n/**/\n    1562,\n/**/\n    1561,\n/**/\n    1560,\n/**/\n    1559,\n/**/\n    1558,\n/**/\n    1557,\n/**/\n    1556,\n/**/\n    1555,\n/**/\n    1554,\n/**/\n    1553,\n/**/\n    1552,\n/**/\n    1551,\n/**/\n    1550,\n/**/\n    1549,\n/**/\n    1548,\n/**/\n    1547,\n/**/\n    1546,\n/**/\n    1545,\n/**/\n    1544,\n/**/\n    1543,\n/**/\n    1542,\n/**/\n    1541,\n/**/\n    1540,\n/**/\n    1539,\n/**/\n    1538,\n/**/\n    1537,\n/**/\n    1536,\n/**/\n    1535,\n/**/\n    1534,\n/**/\n    1533,\n/**/\n    1532,\n/**/\n    1531,\n/**/\n    1530,\n/**/\n    1529,\n/**/\n    1528,\n/**/\n    1527,\n/**/\n    1526,\n/**/\n    1525,\n/**/\n    1524,\n/**/\n    1523,\n/**/\n    1522,\n/**/\n    1521,\n/**/\n    1520,\n/**/\n    1519,\n/**/\n    1518,\n/**/\n    1517,\n/**/\n    1516,\n/**/\n    1515,\n/**/\n    1514,\n/**/\n    1513,\n/**/\n    1512,\n/**/\n    1511,\n/**/\n    1510,\n/**/\n    1509,\n/**/\n    1508,\n/**/\n    1507,\n/**/\n    1506,\n/**/\n    1505,\n/**/\n    1504,\n/**/\n    1503,\n/**/\n    1502,\n/**/\n    1501,\n/**/\n    1500,\n/**/\n    1499,\n/**/\n    1498,\n/**/\n    1497,\n/**/\n    1496,\n/**/\n    1495,\n/**/\n    1494,\n/**/\n    1493,\n/**/\n    1492,\n/**/\n    1491,\n/**/\n    1490,\n/**/\n    1489,\n/**/\n    1488,\n/**/\n    1487,\n/**/\n    1486,\n/**/\n    1485,\n/**/\n    1484,\n/**/\n    1483,\n/**/\n    1482,\n/**/\n    1481,\n/**/\n    1480,\n/**/\n    1479,\n/**/\n    1478,\n/**/\n    1477,\n/**/\n    1476,\n/**/\n    1475,\n/**/\n    1474,\n/**/\n    1473,\n/**/\n    1472,\n/**/\n    1471,\n/**/\n    1470,\n/**/\n    1469,\n/**/\n    1468,\n/**/\n    1467,\n/**/\n    1466,\n/**/\n    1465,\n/**/\n    1464,\n/**/\n    1463,\n/**/\n    1462,\n/**/\n    1461,\n/**/\n    1460,\n/**/\n    1459,\n/**/\n    1458,\n/**/\n    1457,\n/**/\n    1456,\n/**/\n    1455,\n/**/\n    1454,\n/**/\n    1453,\n/**/\n    1452,\n/**/\n    1451,\n/**/\n    1450,\n/**/\n    1449,\n/**/\n    1448,\n/**/\n    1447,\n/**/\n    1446,\n/**/\n    1445,\n/**/\n    1444,\n/**/\n    1443,\n/**/\n    1442,\n/**/\n    1441,\n/**/\n    1440,\n/**/\n    1439,\n/**/\n    1438,\n/**/\n    1437,\n/**/\n    1436,\n/**/\n    1435,\n/**/\n    1434,\n/**/\n    1433,\n/**/\n    1432,\n/**/\n    1431,\n/**/\n    1430,\n/**/\n    1429,\n/**/\n    1428,\n/**/\n    1427,\n/**/\n    1426,\n/**/\n    1425,\n/**/\n    1424,\n/**/\n    1423,\n/**/\n    1422,\n/**/\n    1421,\n/**/\n    1420,\n/**/\n    1419,\n/**/\n    1418,\n/**/\n    1417,\n/**/\n    1416,\n/**/\n    1415,\n/**/\n    1414,\n/**/\n    1413,\n/**/\n    1412,\n/**/\n    1411,\n/**/\n    1410,\n/**/\n    1409,\n/**/\n    1408,\n/**/\n    1407,\n/**/\n    1406,\n/**/\n    1405,\n/**/\n    1404,\n/**/\n    1403,\n/**/\n    1402,\n/**/\n    1401,\n/**/\n    1400,\n/**/\n    1399,\n/**/\n    1398,\n/**/\n    1397,\n/**/\n    1396,\n/**/\n    1395,\n/**/\n    1394,\n/**/\n    1393,\n/**/\n    1392,\n/**/\n    1391,\n/**/\n    1390,\n/**/\n    1389,\n/**/\n    1388,\n/**/\n    1387,\n/**/\n    1386,\n/**/\n    1385,\n/**/\n    1384,\n/**/\n    1383,\n/**/\n    1382,\n/**/\n    1381,\n/**/\n    1380,\n/**/\n    1379,\n/**/\n    1378,\n/**/\n    1377,\n/**/\n    1376,\n/**/\n    1375,\n/**/\n    1374,\n/**/\n    1373,\n/**/\n    1372,\n/**/\n    1371,\n/**/\n    1370,\n/**/\n    1369,\n/**/\n    1368,\n/**/\n    1367,\n/**/\n    1366,\n/**/\n    1365,\n/**/\n    1364,\n/**/\n    1363,\n/**/\n    1362,\n/**/\n    1361,\n/**/\n    1360,\n/**/\n    1359,\n/**/\n    1358,\n/**/\n    1357,\n/**/\n    1356,\n/**/\n    1355,\n/**/\n    1354,\n/**/\n    1353,\n/**/\n    1352,\n/**/\n    1351,\n/**/\n    1350,\n/**/\n    1349,\n/**/\n    1348,\n/**/\n    1347,\n/**/\n    1346,\n/**/\n    1345,\n/**/\n    1344,\n/**/\n    1343,\n/**/\n    1342,\n/**/\n    1341,\n/**/\n    1340,\n/**/\n    1339,\n/**/\n    1338,\n/**/\n    1337,\n/**/\n    1336,\n/**/\n    1335,\n/**/\n    1334,\n/**/\n    1333,\n/**/\n    1332,\n/**/\n    1331,\n/**/\n    1330,\n/**/\n    1329,\n/**/\n    1328,\n/**/\n    1327,\n/**/\n    1326,\n/**/\n    1325,\n/**/\n    1324,\n/**/\n    1323,\n/**/\n    1322,\n/**/\n    1321,\n/**/\n    1320,\n/**/\n    1319,\n/**/\n    1318,\n/**/\n    1317,\n/**/\n    1316,\n/**/\n    1315,\n/**/\n    1314,\n/**/\n    1313,\n/**/\n    1312,\n/**/\n    1311,\n/**/\n    1310,\n/**/\n    1309,\n/**/\n    1308,\n/**/\n    1307,\n/**/\n    1306,\n/**/\n    1305,\n/**/\n    1304,\n/**/\n    1303,\n/**/\n    1302,\n/**/\n    1301,\n/**/\n    1300,\n/**/\n    1299,\n/**/\n    1298,\n/**/\n    1297,\n/**/\n    1296,\n/**/\n    1295,\n/**/\n    1294,\n/**/\n    1293,\n/**/\n    1292,\n/**/\n    1291,\n/**/\n    1290,\n/**/\n    1289,\n/**/\n    1288,\n/**/\n    1287,\n/**/\n    1286,\n/**/\n    1285,\n/**/\n    1284,\n/**/\n    1283,\n/**/\n    1282,\n/**/\n    1281,\n/**/\n    1280,\n/**/\n    1279,\n/**/\n    1278,\n/**/\n    1277,\n/**/\n    1276,\n/**/\n    1275,\n/**/\n    1274,\n/**/\n    1273,\n/**/\n    1272,\n/**/\n    1271,\n/**/\n    1270,\n/**/\n    1269,\n/**/\n    1268,\n/**/\n    1267,\n/**/\n    1266,\n/**/\n    1265,\n/**/\n    1264,\n/**/\n    1263,\n/**/\n    1262,\n/**/\n    1261,\n/**/\n    1260,\n/**/\n    1259,\n/**/\n    1258,\n/**/\n    1257,\n/**/\n    1256,\n/**/\n    1255,\n/**/\n    1254,\n/**/\n    1253,\n/**/\n    1252,\n/**/\n    1251,\n/**/\n    1250,\n/**/\n    1249,\n/**/\n    1248,\n/**/\n    1247,\n/**/\n    1246,\n/**/\n    1245,\n/**/\n    1244,\n/**/\n    1243,\n/**/\n    1242,\n/**/\n    1241,\n/**/\n    1240,\n/**/\n    1239,\n/**/\n    1238,\n/**/\n    1237,\n/**/\n    1236,\n/**/\n    1235,\n/**/\n    1234,\n/**/\n    1233,\n/**/\n    1232,\n/**/\n    1231,\n/**/\n    1230,\n/**/\n    1229,\n/**/\n    1228,\n/**/\n    1227,\n/**/\n    1226,\n/**/\n    1225,\n/**/\n    1224,\n/**/\n    1223,\n/**/\n    1222,\n/**/\n    1221,\n/**/\n    1220,\n/**/\n    1219,\n/**/\n    1218,\n/**/\n    1217,\n/**/\n    1216,\n/**/\n    1215,\n/**/\n    1214,\n/**/\n    1213,\n/**/\n    1212,\n/**/\n    1211,\n/**/\n    1210,\n/**/\n    1209,\n/**/\n    1208,\n/**/\n    1207,\n/**/\n    1206,\n/**/\n    1205,\n/**/\n    1204,\n/**/\n    1203,\n/**/\n    1202,\n/**/\n    1201,\n/**/\n    1200,\n/**/\n    1199,\n/**/\n    1198,\n/**/\n    1197,\n/**/\n    1196,\n/**/\n    1195,\n/**/\n    1194,\n/**/\n    1193,\n/**/\n    1192,\n/**/\n    1191,\n/**/\n    1190,\n/**/\n    1189,\n/**/\n    1188,\n/**/\n    1187,\n/**/\n    1186,\n/**/\n    1185,\n/**/\n    1184,\n/**/\n    1183,\n/**/\n    1182,\n/**/\n    1181,\n/**/\n    1180,\n/**/\n    1179,\n/**/\n    1178,\n/**/\n    1177,\n/**/\n    1176,\n/**/\n    1175,\n/**/\n    1174,\n/**/\n    1173,\n/**/\n    1172,\n/**/\n    1171,\n/**/\n    1170,\n/**/\n    1169,\n/**/\n    1168,\n/**/\n    1167,\n/**/\n    1166,\n/**/\n    1165,\n/**/\n    1164,\n/**/\n    1163,\n/**/\n    1162,\n/**/\n    1161,\n/**/\n    1160,\n/**/\n    1159,\n/**/\n    1158,\n/**/\n    1157,\n/**/\n    1156,\n/**/\n    1155,\n/**/\n    1154,\n/**/\n    1153,\n/**/\n    1152,\n/**/\n    1151,\n/**/\n    1150,\n/**/\n    1149,\n/**/\n    1148,\n/**/\n    1147,\n/**/\n    1146,\n/**/\n    1145,\n/**/\n    1144,\n/**/\n    1143,\n/**/\n    1142,\n/**/\n    1141,\n/**/\n    1140,\n/**/\n    1139,\n/**/\n    1138,\n/**/\n    1137,\n/**/\n    1136,\n/**/\n    1135,\n/**/\n    1134,\n/**/\n    1133,\n/**/\n    1132,\n/**/\n    1131,\n/**/\n    1130,\n/**/\n    1129,\n/**/\n    1128,\n/**/\n    1127,\n/**/\n    1126,\n/**/\n    1125,\n/**/\n    1124,\n/**/\n    1123,\n/**/\n    1122,\n/**/\n    1121,\n/**/\n    1120,\n/**/\n    1119,\n/**/\n    1118,\n/**/\n    1117,\n/**/\n    1116,\n/**/\n    1115,\n/**/\n    1114,\n/**/\n    1113,\n/**/\n    1112,\n/**/\n    1111,\n/**/\n    1110,\n/**/\n    1109,\n/**/\n    1108,\n/**/\n    1107,\n/**/\n    1106,\n/**/\n    1105,\n/**/\n    1104,\n/**/\n    1103,\n/**/\n    1102,\n/**/\n    1101,\n/**/\n    1100,\n/**/\n    1099,\n/**/\n    1098,\n/**/\n    1097,\n/**/\n    1096,\n/**/\n    1095,\n/**/\n    1094,\n/**/\n    1093,\n/**/\n    1092,\n/**/\n    1091,\n/**/\n    1090,\n/**/\n    1089,\n/**/\n    1088,\n/**/\n    1087,\n/**/\n    1086,\n/**/\n    1085,\n/**/\n    1084,\n/**/\n    1083,\n/**/\n    1082,\n/**/\n    1081,\n/**/\n    1080,\n/**/\n    1079,\n/**/\n    1078,\n/**/\n    1077,\n/**/\n    1076,\n/**/\n    1075,\n/**/\n    1074,\n/**/\n    1073,\n/**/\n    1072,\n/**/\n    1071,\n/**/\n    1070,\n/**/\n    1069,\n/**/\n    1068,\n/**/\n    1067,\n/**/\n    1066,\n/**/\n    1065,\n/**/\n    1064,\n/**/\n    1063,\n/**/\n    1062,\n/**/\n    1061,\n/**/\n    1060,\n/**/\n    1059,\n/**/\n    1058,\n/**/\n    1057,\n/**/\n    1056,\n/**/\n    1055,\n/**/\n    1054,\n/**/\n    1053,\n/**/\n    1052,\n/**/\n    1051,\n/**/\n    1050,\n/**/\n    1049,\n/**/\n    1048,\n/**/\n    1047,\n/**/\n    1046,\n/**/\n    1045,\n/**/\n    1044,\n/**/\n    1043,\n/**/\n    1042,\n/**/\n    1041,\n/**/\n    1040,\n/**/\n    1039,\n/**/\n    1038,\n/**/\n    1037,\n/**/\n    1036,\n/**/\n    1035,\n/**/\n    1034,\n/**/\n    1033,\n/**/\n    1032,\n/**/\n    1031,\n/**/\n    1030,\n/**/\n    1029,\n/**/\n    1028,\n/**/\n    1027,\n/**/\n    1026,\n/**/\n    1025,\n/**/\n    1024,\n/**/\n    1023,\n/**/\n    1022,\n/**/\n    1021,\n/**/\n    1020,\n/**/\n    1019,\n/**/\n    1018,\n/**/\n    1017,\n/**/\n    1016,\n/**/\n    1015,\n/**/\n    1014,\n/**/\n    1013,\n/**/\n    1012,\n/**/\n    1011,\n/**/\n    1010,\n/**/\n    1009,\n/**/\n    1008,\n/**/\n    1007,\n/**/\n    1006,\n/**/\n    1005,\n/**/\n    1004,\n/**/\n    1003,\n/**/\n    1002,\n/**/\n    1001,\n/**/\n    1000,\n/**/\n    999,\n/**/\n    998,\n/**/\n    997,\n/**/\n    996,\n/**/\n    995,\n/**/\n    994,\n/**/\n    993,\n/**/\n    992,\n/**/\n    991,\n/**/\n    990,\n/**/\n    989,\n/**/\n    988,\n/**/\n    987,\n/**/\n    986,\n/**/\n    985,\n/**/\n    984,\n/**/\n    983,\n/**/\n    982,\n/**/\n    981,\n/**/\n    980,\n/**/\n    979,\n/**/\n    978,\n/**/\n    977,\n/**/\n    976,\n/**/\n    975,\n/**/\n    974,\n/**/\n    973,\n/**/\n    972,\n/**/\n    971,\n/**/\n    970,\n/**/\n    969,\n/**/\n    968,\n/**/\n    967,\n/**/\n    966,\n/**/\n    965,\n/**/\n    964,\n/**/\n    963,\n/**/\n    962,\n/**/\n    961,\n/**/\n    960,\n/**/\n    959,\n/**/\n    958,\n/**/\n    957,\n/**/\n    956,\n/**/\n    955,\n/**/\n    954,\n/**/\n    953,\n/**/\n    952,\n/**/\n    951,\n/**/\n    950,\n/**/\n    949,\n/**/\n    948,\n/**/\n    947,\n/**/\n    946,\n/**/\n    945,\n/**/\n    944,\n/**/\n    943,\n/**/\n    942,\n/**/\n    941,\n/**/\n    940,\n/**/\n    939,\n/**/\n    938,\n/**/\n    937,\n/**/\n    936,\n/**/\n    935,\n/**/\n    934,\n/**/\n    933,\n/**/\n    932,\n/**/\n    931,\n/**/\n    930,\n/**/\n    929,\n/**/\n    928,\n/**/\n    927,\n/**/\n    926,\n/**/\n    925,\n/**/\n    924,\n/**/\n    923,\n/**/\n    922,\n/**/\n    921,\n/**/\n    920,\n/**/\n    919,\n/**/\n    918,\n/**/\n    917,\n/**/\n    916,\n/**/\n    915,\n/**/\n    914,\n/**/\n    913,\n/**/\n    912,\n/**/\n    911,\n/**/\n    910,\n/**/\n    909,\n/**/\n    908,\n/**/\n    907,\n/**/\n    906,\n/**/\n    905,\n/**/\n    904,\n/**/\n    903,\n/**/\n    902,\n/**/\n    901,\n/**/\n    900,\n/**/\n    899,\n/**/\n    898,\n/**/\n    897,\n/**/\n    896,\n/**/\n    895,\n/**/\n    894,\n/**/\n    893,\n/**/\n    892,\n/**/\n    891,\n/**/\n    890,\n/**/\n    889,\n/**/\n    888,\n/**/\n    887,\n/**/\n    886,\n/**/\n    885,\n/**/\n    884,\n/**/\n    883,\n/**/\n    882,\n/**/\n    881,\n/**/\n    880,\n/**/\n    879,\n/**/\n    878,\n/**/\n    877,\n/**/\n    876,\n/**/\n    875,\n/**/\n    874,\n/**/\n    873,\n/**/\n    872,\n/**/\n    871,\n/**/\n    870,\n/**/\n    869,\n/**/\n    868,\n/**/\n    867,\n/**/\n    866,\n/**/\n    865,\n/**/\n    864,\n/**/\n    863,\n/**/\n    862,\n/**/\n    861,\n/**/\n    860,\n/**/\n    859,\n/**/\n    858,\n/**/\n    857,\n/**/\n    856,\n/**/\n    855,\n/**/\n    854,\n/**/\n    853,\n/**/\n    852,\n/**/\n    851,\n/**/\n    850,\n/**/\n    849,\n/**/\n    848,\n/**/\n    847,\n/**/\n    846,\n/**/\n    845,\n/**/\n    844,\n/**/\n    843,\n/**/\n    842,\n/**/\n    841,\n/**/\n    840,\n/**/\n    839,\n/**/\n    838,\n/**/\n    837,\n/**/\n    836,\n/**/\n    835,\n/**/\n    834,\n/**/\n    833,\n/**/\n    832,\n/**/\n    831,\n/**/\n    830,\n/**/\n    829,\n/**/\n    828,\n/**/\n    827,\n/**/\n    826,\n/**/\n    825,\n/**/\n    824,\n/**/\n    823,\n/**/\n    822,\n/**/\n    821,\n/**/\n    820,\n/**/\n    819,\n/**/\n    818,\n/**/\n    817,\n/**/\n    816,\n/**/\n    815,\n/**/\n    814,\n/**/\n    813,\n/**/\n    812,\n/**/\n    811,\n/**/\n    810,\n/**/\n    809,\n/**/\n    808,\n/**/\n    807,\n/**/\n    806,\n/**/\n    805,\n/**/\n    804,\n/**/\n    803,\n/**/\n    802,\n/**/\n    801,\n/**/\n    800,\n/**/\n    799,\n/**/\n    798,\n/**/\n    797,\n/**/\n    796,\n/**/\n    795,\n/**/\n    794,\n/**/\n    793,\n/**/\n    792,\n/**/\n    791,\n/**/\n    790,\n/**/\n    789,\n/**/\n    788,\n/**/\n    787,\n/**/\n    786,\n/**/\n    785,\n/**/\n    784,\n/**/\n    783,\n/**/\n    782,\n/**/\n    781,\n/**/\n    780,\n/**/\n    779,\n/**/\n    778,\n/**/\n    777,\n/**/\n    776,\n/**/\n    775,\n/**/\n    774,\n/**/\n    773,\n/**/\n    772,\n/**/\n    771,\n/**/\n    770,\n/**/\n    769,\n/**/\n    768,\n/**/\n    767,\n/**/\n    766,\n/**/\n    765,\n/**/\n    764,\n/**/\n    763,\n/**/\n    762,\n/**/\n    761,\n/**/\n    760,\n/**/\n    759,\n/**/\n    758,\n/**/\n    757,\n/**/\n    756,\n/**/\n    755,\n/**/\n    754,\n/**/\n    753,\n/**/\n    752,\n/**/\n    751,\n/**/\n    750,\n/**/\n    749,\n/**/\n    748,\n/**/\n    747,\n/**/\n    746,\n/**/\n    745,\n/**/\n    744,\n/**/\n    743,\n/**/\n    742,\n/**/\n    741,\n/**/\n    740,\n/**/\n    739,\n/**/\n    738,\n/**/\n    737,\n/**/\n    736,\n/**/\n    735,\n/**/\n    734,\n/**/\n    733,\n/**/\n    732,\n/**/\n    731,\n/**/\n    730,\n/**/\n    729,\n/**/\n    728,\n/**/\n    727,\n/**/\n    726,\n/**/\n    725,\n/**/\n    724,\n/**/\n    723,\n/**/\n    722,\n/**/\n    721,\n/**/\n    720,\n/**/\n    719,\n/**/\n    718,\n/**/\n    717,\n/**/\n    716,\n/**/\n    715,\n/**/\n    714,\n/**/\n    713,\n/**/\n    712,\n/**/\n    711,\n/**/\n    710,\n/**/\n    709,\n/**/\n    708,\n/**/\n    707,\n/**/\n    706,\n/**/\n    705,\n/**/\n    704,\n/**/\n    703,\n/**/\n    702,\n/**/\n    701,\n/**/\n    700,\n/**/\n    699,\n/**/\n    698,\n/**/\n    697,\n/**/\n    696,\n/**/\n    695,\n/**/\n    694,\n/**/\n    693,\n/**/\n    692,\n/**/\n    691,\n/**/\n    690,\n/**/\n    689,\n/**/\n    688,\n/**/\n    687,\n/**/\n    686,\n/**/\n    685,\n/**/\n    684,\n/**/\n    683,\n/**/\n    682,\n/**/\n    681,\n/**/\n    680,\n/**/\n    679,\n/**/\n    678,\n/**/\n    677,\n/**/\n    676,\n/**/\n    675,\n/**/\n    674,\n/**/\n    673,\n/**/\n    672,\n/**/\n    671,\n/**/\n    670,\n/**/\n    669,\n/**/\n    668,\n/**/\n    667,\n/**/\n    666,\n/**/\n    665,\n/**/\n    664,\n/**/\n    663,\n/**/\n    662,\n/**/\n    661,\n/**/\n    660,\n/**/\n    659,\n/**/\n    658,\n/**/\n    657,\n/**/\n    656,\n/**/\n    655,\n/**/\n    654,\n/**/\n    653,\n/**/\n    652,\n/**/\n    651,\n/**/\n    650,\n/**/\n    649,\n/**/\n    648,\n/**/\n    647,\n/**/\n    646,\n/**/\n    645,\n/**/\n    644,\n/**/\n    643,\n/**/\n    642,\n/**/\n    641,\n/**/\n    640,\n/**/\n    639,\n/**/\n    638,\n/**/\n    637,\n/**/\n    636,\n/**/\n    635,\n/**/\n    634,\n/**/\n    633,\n/**/\n    632,\n/**/\n    631,\n/**/\n    630,\n/**/\n    629,\n/**/\n    628,\n/**/\n    627,\n/**/\n    626,\n/**/\n    625,\n/**/\n    624,\n/**/\n    623,\n/**/\n    622,\n/**/\n    621,\n/**/\n    620,\n/**/\n    619,\n/**/\n    618,\n/**/\n    617,\n/**/\n    616,\n/**/\n    615,\n/**/\n    614,\n/**/\n    613,\n/**/\n    612,\n/**/\n    611,\n/**/\n    610,\n/**/\n    609,\n/**/\n    608,\n/**/\n    607,\n/**/\n    606,\n/**/\n    605,\n/**/\n    604,\n/**/\n    603,\n/**/\n    602,\n/**/\n    601,\n/**/\n    600,\n/**/\n    599,\n/**/\n    598,\n/**/\n    597,\n/**/\n    596,\n/**/\n    595,\n/**/\n    594,\n/**/\n    593,\n/**/\n    592,\n/**/\n    591,\n/**/\n    590,\n/**/\n    589,\n/**/\n    588,\n/**/\n    587,\n/**/\n    586,\n/**/\n    585,\n/**/\n    584,\n/**/\n    583,\n/**/\n    582,\n/**/\n    581,\n/**/\n    580,\n/**/\n    579,\n/**/\n    578,\n/**/\n    577,\n/**/\n    576,\n/**/\n    575,\n/**/\n    574,\n/**/\n    573,\n/**/\n    572,\n/**/\n    571,\n/**/\n    570,\n/**/\n    569,\n/**/\n    568,\n/**/\n    567,\n/**/\n    566,\n/**/\n    565,\n/**/\n    564,\n/**/\n    563,\n/**/\n    562,\n/**/\n    561,\n/**/\n    560,\n/**/\n    559,\n/**/\n    558,\n/**/\n    557,\n/**/\n    556,\n/**/\n    555,\n/**/\n    554,\n/**/\n    553,\n/**/\n    552,\n/**/\n    551,\n/**/\n    550,\n/**/\n    549,\n/**/\n    548,\n/**/\n    547,\n/**/\n    546,\n/**/\n    545,\n/**/\n    544,\n/**/\n    543,\n/**/\n    542,\n/**/\n    541,\n/**/\n    540,\n/**/\n    539,\n/**/\n    538,\n/**/\n    537,\n/**/\n    536,\n/**/\n    535,\n/**/\n    534,\n/**/\n    533,\n/**/\n    532,\n/**/\n    531,\n/**/\n    530,\n/**/\n    529,\n/**/\n    528,\n/**/\n    527,\n/**/\n    526,\n/**/\n    525,\n/**/\n    524,\n/**/\n    523,\n/**/\n    522,\n/**/\n    521,\n/**/\n    520,\n/**/\n    519,\n/**/\n    518,\n/**/\n    517,\n/**/\n    516,\n/**/\n    515,\n/**/\n    514,\n/**/\n    513,\n/**/\n    512,\n/**/\n    511,\n/**/\n    510,\n/**/\n    509,\n/**/\n    508,\n/**/\n    507,\n/**/\n    506,\n/**/\n    505,\n/**/\n    504,\n/**/\n    503,\n/**/\n    502,\n/**/\n    501,\n/**/\n    500,\n/**/\n    499,\n/**/\n    498,\n/**/\n    497,\n/**/\n    496,\n/**/\n    495,\n/**/\n    494,\n/**/\n    493,\n/**/\n    492,\n/**/\n    491,\n/**/\n    490,\n/**/\n    489,\n/**/\n    488,\n/**/\n    487,\n/**/\n    486,\n/**/\n    485,\n/**/\n    484,\n/**/\n    483,\n/**/\n    482,\n/**/\n    481,\n/**/\n    480,\n/**/\n    479,\n/**/\n    478,\n/**/\n    477,\n/**/\n    476,\n/**/\n    475,\n/**/\n    474,\n/**/\n    473,\n/**/\n    472,\n/**/\n    471,\n/**/\n    470,\n/**/\n    469,\n/**/\n    468,\n/**/\n    467,\n/**/\n    466,\n/**/\n    465,\n/**/\n    464,\n/**/\n    463,\n/**/\n    462,\n/**/\n    461,\n/**/\n    460,\n/**/\n    459,\n/**/\n    458,\n/**/\n    457,\n/**/\n    456,\n/**/\n    455,\n/**/\n    454,\n/**/\n    453,\n/**/\n    452,\n/**/\n    451,\n/**/\n    450,\n/**/\n    449,\n/**/\n    448,\n/**/\n    447,\n/**/\n    446,\n/**/\n    445,\n/**/\n    444,\n/**/\n    443,\n/**/\n    442,\n/**/\n    441,\n/**/\n    440,\n/**/\n    439,\n/**/\n    438,\n/**/\n    437,\n/**/\n    436,\n/**/\n    435,\n/**/\n    434,\n/**/\n    433,\n/**/\n    432,\n/**/\n    431,\n/**/\n    430,\n/**/\n    429,\n/**/\n    428,\n/**/\n    427,\n/**/\n    426,\n/**/\n    425,\n/**/\n    424,\n/**/\n    423,\n/**/\n    422,\n/**/\n    421,\n/**/\n    420,\n/**/\n    419,\n/**/\n    418,\n/**/\n    417,\n/**/\n    416,\n/**/\n    415,\n/**/\n    414,\n/**/\n    413,\n/**/\n    412,\n/**/\n    411,\n/**/\n    410,\n/**/\n    409,\n/**/\n    408,\n/**/\n    407,\n/**/\n    406,\n/**/\n    405,\n/**/\n    404,\n/**/\n    403,\n/**/\n    402,\n/**/\n    401,\n/**/\n    400,\n/**/\n    399,\n/**/\n    398,\n/**/\n    397,\n/**/\n    396,\n/**/\n    395,\n/**/\n    394,\n/**/\n    393,\n/**/\n    392,\n/**/\n    391,\n/**/\n    390,\n/**/\n    389,\n/**/\n    388,\n/**/\n    387,\n/**/\n    386,\n/**/\n    385,\n/**/\n    384,\n/**/\n    383,\n/**/\n    382,\n/**/\n    381,\n/**/\n    380,\n/**/\n    379,\n/**/\n    378,\n/**/\n    377,\n/**/\n    376,\n/**/\n    375,\n/**/\n    374,\n/**/\n    373,\n/**/\n    372,\n/**/\n    371,\n/**/\n    370,\n/**/\n    369,\n/**/\n    368,\n/**/\n    367,\n/**/\n    366,\n/**/\n    365,\n/**/\n    364,\n/**/\n    363,\n/**/\n    362,\n/**/\n    361,\n/**/\n    360,\n/**/\n    359,\n/**/\n    358,\n/**/\n    357,\n/**/\n    356,\n/**/\n    355,\n/**/\n    354,\n/**/\n    353,\n/**/\n    352,\n/**/\n    351,\n/**/\n    350,\n/**/\n    349,\n/**/\n    348,\n/**/\n    347,\n/**/\n    346,\n/**/\n    345,\n/**/\n    344,\n/**/\n    343,\n/**/\n    342,\n/**/\n    341,\n/**/\n    340,\n/**/\n    339,\n/**/\n    338,\n/**/\n    337,\n/**/\n    336,\n/**/\n    335,\n/**/\n    334,\n/**/\n    333,\n/**/\n    332,\n/**/\n    331,\n/**/\n    330,\n/**/\n    329,\n/**/\n    328,\n/**/\n    327,\n/**/\n    326,\n/**/\n    325,\n/**/\n    324,\n/**/\n    323,\n/**/\n    322,\n/**/\n    321,\n/**/\n    320,\n/**/\n    319,\n/**/\n    318,\n/**/\n    317,\n/**/\n    316,\n/**/\n    315,\n/**/\n    314,\n/**/\n    313,\n/**/\n    312,\n/**/\n    311,\n/**/\n    310,\n/**/\n    309,\n/**/\n    308,\n/**/\n    307,\n/**/\n    306,\n/**/\n    305,\n/**/\n    304,\n/**/\n    303,\n/**/\n    302,\n/**/\n    301,\n/**/\n    300,\n/**/\n    299,\n/**/\n    298,\n/**/\n    297,\n/**/\n    296,\n/**/\n    295,\n/**/\n    294,\n/**/\n    293,\n/**/\n    292,\n/**/\n    291,\n/**/\n    290,\n/**/\n    289,\n/**/\n    288,\n/**/\n    287,\n/**/\n    286,\n/**/\n    285,\n/**/\n    284,\n/**/\n    283,\n/**/\n    282,\n/**/\n    281,\n/**/\n    280,\n/**/\n    279,\n/**/\n    278,\n/**/\n    277,\n/**/\n    276,\n/**/\n    275,\n/**/\n    274,\n/**/\n    273,\n/**/\n    272,\n/**/\n    271,\n/**/\n    270,\n/**/\n    269,\n/**/\n    268,\n/**/\n    267,\n/**/\n    266,\n/**/\n    265,\n/**/\n    264,\n/**/\n    263,\n/**/\n    262,\n/**/\n    261,\n/**/\n    260,\n/**/\n    259,\n/**/\n    258,\n/**/\n    257,\n/**/\n    256,\n/**/\n    255,\n/**/\n    254,\n/**/\n    253,\n/**/\n    252,\n/**/\n    251,\n/**/\n    250,\n/**/\n    249,\n/**/\n    248,\n/**/\n    247,\n/**/\n    246,\n/**/\n    245,\n/**/\n    244,\n/**/\n    243,\n/**/\n    242,\n/**/\n    241,\n/**/\n    240,\n/**/\n    239,\n/**/\n    238,\n/**/\n    237,\n/**/\n    236,\n/**/\n    235,\n/**/\n    234,\n/**/\n    233,\n/**/\n    232,\n/**/\n    231,\n/**/\n    230,\n/**/\n    229,\n/**/\n    228,\n/**/\n    227,\n/**/\n    226,\n/**/\n    225,\n/**/\n    224,\n/**/\n    223,\n/**/\n    222,\n/**/\n    221,\n/**/\n    220,\n/**/\n    219,\n/**/\n    218,\n/**/\n    217,\n/**/\n    216,\n/**/\n    215,\n/**/\n    214,\n/**/\n    213,\n/**/\n    212,\n/**/\n    211,\n/**/\n    210,\n/**/\n    209,\n/**/\n    208,\n/**/\n    207,\n/**/\n    206,\n/**/\n    205,\n/**/\n    204,\n/**/\n    203,\n/**/\n    202,\n/**/\n    201,\n/**/\n    200,\n/**/\n    199,\n/**/\n    198,\n/**/\n    197,\n/**/\n    196,\n/**/\n    195,\n/**/\n    194,\n/**/\n    193,\n/**/\n    192,\n/**/\n    191,\n/**/\n    190,\n/**/\n    189,\n/**/\n    188,\n/**/\n    187,\n/**/\n    186,\n/**/\n    185,\n/**/\n    184,\n/**/\n    183,\n/**/\n    182,\n/**/\n    181,\n/**/\n    180,\n/**/\n    179,\n/**/\n    178,\n/**/\n    177,\n/**/\n    176,\n/**/\n    175,\n/**/\n    174,\n/**/\n    173,\n/**/\n    172,\n/**/\n    171,\n/**/\n    170,\n/**/\n    169,\n/**/\n    168,\n/**/\n    167,\n/**/\n    166,\n/**/\n    165,\n/**/\n    164,\n/**/\n    163,\n/**/\n    162,\n/**/\n    161,\n/**/\n    160,\n/**/\n    159,\n/**/\n    158,\n/**/\n    157,\n/**/\n    156,\n/**/\n    155,\n/**/\n    154,\n/**/\n    153,\n/**/\n    152,\n/**/\n    151,\n/**/\n    150,\n/**/\n    149,\n/**/\n    148,\n/**/\n    147,\n/**/\n    146,\n/**/\n    145,\n/**/\n    144,\n/**/\n    143,\n/**/\n    142,\n/**/\n    141,\n/**/\n    140,\n/**/\n    139,\n/**/\n    138,\n/**/\n    137,\n/**/\n    136,\n/**/\n    135,\n/**/\n    134,\n/**/\n    133,\n/**/\n    132,\n/**/\n    131,\n/**/\n    130,\n/**/\n    129,\n/**/\n    128,\n/**/\n    127,\n/**/\n    126,\n/**/\n    125,\n/**/\n    124,\n/**/\n    123,\n/**/\n    122,\n/**/\n    121,\n/**/\n    120,\n/**/\n    119,\n/**/\n    118,\n/**/\n    117,\n/**/\n    116,\n/**/\n    115,\n/**/\n    114,\n/**/\n    113,\n/**/\n    112,\n/**/\n    111,\n/**/\n    110,\n/**/\n    109,\n/**/\n    108,\n/**/\n    107,\n/**/\n    106,\n/**/\n    105,\n/**/\n    104,\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\ti;\n\n    for (i = 0; included_patches[i] != 0; ++i)\n\tif (included_patches[i] == n)\n\t    return TRUE;\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = (int)vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    /* Find the length of the longest item, use that + 1 as the column\n     * width. */\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = (int)vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + (item_count % ncol ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    /* Print the list of patch numbers if there is at least one. */\n    /* Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\" */\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\t/* find last one */\n\tfor (i = 0; included_patches[i] != 0; ++i)\n\t    ;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    /* Print the list of extra patch descriptions if there is at least one. */\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#ifdef FEAT_HUGE\n    msg_puts(_(\"\\nHuge version \"));\n#else\n# ifdef FEAT_BIG\n    msg_puts(_(\"\\nBig version \"));\n# else\n#  ifdef FEAT_NORMAL\n    msg_puts(_(\"\\nNormal version \"));\n#  else\n#   ifdef FEAT_SMALL\n    msg_puts(_(\"\\nSmall version \"));\n#   else\n    msg_puts(_(\"\\nTiny version \"));\n#   endif\n#  endif\n# endif\n#endif\n#ifndef FEAT_GUI\n    msg_puts(_(\"without GUI.\"));\n#else\n# ifdef FEAT_GUI_GTK\n#  ifdef USE_GTK3\n    msg_puts(_(\"with GTK3 GUI.\"));\n#  else\n#   ifdef FEAT_GUI_GNOME\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n#   else\n     msg_puts(_(\"with GTK2 GUI.\"));\n#   endif\n# endif\n# else\n#  ifdef FEAT_GUI_MOTIF\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#  else\n#   ifdef FEAT_GUI_ATHENA\n#    ifdef FEAT_GUI_NEXTAW\n    msg_puts(_(\"with X11-neXtaw GUI.\"));\n#    else\n    msg_puts(_(\"with X11-Athena GUI.\"));\n#    endif\n#   else\n#     ifdef FEAT_GUI_PHOTON\n    msg_puts(_(\"with Photon GUI.\"));\n#     else\n#      if defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#      else\n#\tif defined(TARGET_API_MAC_CARBON) && TARGET_API_MAC_CARBON\n    msg_puts(_(\"with Carbon GUI.\"));\n#\telse\n#\t if defined(TARGET_API_MAC_OSX) && TARGET_API_MAC_OSX\n    msg_puts(_(\"with Cocoa GUI.\"));\n#\t else\n#\t endif\n#\tendif\n#      endif\n#    endif\n#   endif\n#  endif\n# endif\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    void\nintro_message(\n    int\t\tcolon)\t\t/* TRUE for \":intro\" */\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version8<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    /* blanklines = screen height - # message lines */\n    blanklines = (int)Rows - ((sizeof(lines) / sizeof(char *)) - 1);\n    if (!p_cp)\n\tblanklines += 4;  /* add 4 for not showing \"Vi compatible\" message */\n\n    /* Don't overwrite a statusline.  Depends on 'cmdheight'. */\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    /* Show the sponsor and register message one out of four times, the Uganda\n     * message two out of four times. */\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    /* start displaying the message lines after half of the blank lines */\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)(sizeof(lines) / sizeof(char *)); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    /* Make the wait-return message appear just below the text. */\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    /* Center the message horizontally. */\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    /* Check for 9.9x or 9.9xx, alpha/beta version */\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    /* Split up in parts to highlight <> items differently. */\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    /* Add the version number to the version line. */\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read a list of people who contributed.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\nstatic void cmd_with_count(char *cmd, char_u *bufp, size_t bufsize, long Prenum);\nstatic void win_init(win_T *newp, win_T *oldp, int flags);\nstatic void win_init_some(win_T *newp, win_T *oldp);\nstatic void frame_comp_pos(frame_T *topfrp, int *row, int *col);\nstatic void frame_setheight(frame_T *curfrp, int height);\nstatic void frame_setwidth(frame_T *curfrp, int width);\nstatic void win_exchange(long);\nstatic void win_rotate(int, int);\nstatic void win_totop(int size, int flags);\nstatic void win_equal_rec(win_T *next_curwin, int current, frame_T *topfr, int dir, int col, int row, int width, int height);\nstatic win_T *win_free_mem(win_T *win, int *dirp, tabpage_T *tp);\nstatic frame_T *win_altframe(win_T *win, tabpage_T *tp);\nstatic tabpage_T *alt_tabpage(void);\nstatic win_T *frame2win(frame_T *frp);\nstatic int frame_has_win(frame_T *frp, win_T *wp);\nstatic void frame_new_height(frame_T *topfrp, int height, int topfirst, int wfh);\nstatic int frame_fixed_height(frame_T *frp);\nstatic int frame_fixed_width(frame_T *frp);\nstatic void frame_add_statusline(frame_T *frp);\nstatic void frame_new_width(frame_T *topfrp, int width, int leftfirst, int wfw);\nstatic void frame_add_vsep(frame_T *frp);\nstatic int frame_minwidth(frame_T *topfrp, win_T *next_curwin);\nstatic void frame_fix_width(win_T *wp);\nstatic int win_alloc_firstwin(win_T *oldwin);\nstatic void new_frame(win_T *wp);\nstatic tabpage_T *alloc_tabpage(void);\nstatic int leave_tabpage(buf_T *new_curbuf, int trigger_leave_autocmds);\nstatic void enter_tabpage(tabpage_T *tp, buf_T *old_curbuf, int trigger_enter_autocmds, int trigger_leave_autocmds);\nstatic void frame_fix_height(win_T *wp);\nstatic int frame_minheight(frame_T *topfrp, win_T *next_curwin);\nstatic int may_open_tabpage(void);\nstatic void win_enter_ext(win_T *wp, int undo_sync, int no_curwin, int trigger_new_autocmds, int trigger_enter_autocmds, int trigger_leave_autocmds);\nstatic void win_free(win_T *wp, tabpage_T *tp);\nstatic int win_unlisted(win_T *wp);\nstatic void win_append(win_T *after, win_T *wp);\nstatic void frame_append(frame_T *after, frame_T *frp);\nstatic void frame_insert(frame_T *before, frame_T *frp);\nstatic void frame_remove(frame_T *frp);\nstatic void win_goto_ver(int up, long count);\nstatic void win_goto_hor(int left, long count);\nstatic void frame_add_height(frame_T *frp, int n);\nstatic void last_status_rec(frame_T *fr, int statusline);\n\nstatic void make_snapshot_rec(frame_T *fr, frame_T **frp);\nstatic void clear_snapshot(tabpage_T *tp, int idx);\nstatic void clear_snapshot_rec(frame_T *fr);\nstatic int check_snapshot_rec(frame_T *sn, frame_T *fr);\nstatic win_T *restore_snapshot_rec(frame_T *sn, frame_T *fr);\n\nstatic int frame_check_height(frame_T *topfrp, int height);\nstatic int frame_check_width(frame_T *topfrp, int width);\n\nstatic win_T *win_alloc(win_T *after, int hidden);\n\n#define NOWIN\t\t(win_T *)-1\t/* non-existing window */\n\n#define ROWS_AVAIL (Rows - p_ch - tabline_height())\n\nstatic char *m_onlyone = N_(\"Already only one window\");\n\n// When non-zero splitting a window is forbidden.  Used to avoid that nasty\n// autocommands mess up the window structure.\nstatic int split_disallowed = 0;\n\n// #define WIN_DEBUG\n#ifdef WIN_DEBUG\n/*\n * Call this method to log the current window layout.\n */\n    static void\nlog_frame_layout(frame_T *frame)\n{\n    ch_log(NULL, \"layout %s, wi: %d, he: %d, wwi: %d, whe: %d, id: %d\",\n\t    frame->fr_layout == FR_LEAF ? \"LEAF\"\n\t\t\t\t  : frame->fr_layout == FR_ROW ? \"ROW\" : \"COL\",\n\t    frame->fr_width,\n\t    frame->fr_height,\n\t    frame->fr_win == NULL ? -1 : frame->fr_win->w_width,\n\t    frame->fr_win == NULL ? -1 : frame->fr_win->w_height,\n\t    frame->fr_win == NULL ? -1 : frame->fr_win->w_id);\n    if (frame->fr_child != NULL)\n    {\n\tch_log(NULL, \"children\");\n\tlog_frame_layout(frame->fr_child);\n\tif (frame->fr_next != NULL)\n\t    ch_log(NULL, \"END of children\");\n    }\n    if (frame->fr_next != NULL)\n\tlog_frame_layout(frame->fr_next);\n}\n#endif\n\n/*\n * All CTRL-W window commands are handled here, called from normal_cmd().\n */\n    void\ndo_window(\n    int\t\tnchar,\n    long\tPrenum,\n    int\t\txchar)\t    /* extra char from \":wincmd gx\" or NUL */\n{\n    long\tPrenum1;\n    win_T\t*wp;\n#if defined(FEAT_SEARCHPATH) || defined(FEAT_FIND_ID)\n    char_u\t*ptr;\n    linenr_T    lnum = -1;\n#endif\n#ifdef FEAT_FIND_ID\n    int\t\ttype = FIND_DEFINE;\n    int\t\tlen;\n#endif\n    char_u\tcbuf[40];\n\n    if (ERROR_IF_POPUP_WINDOW)\n\treturn;\n\n#ifdef FEAT_CMDWIN\n# define CHECK_CMDWIN \\\n    do { \\\n\tif (cmdwin_type != 0) \\\n\t{ \\\n\t    emsg(_(e_cmdwin)); \\\n\t    return; \\\n\t} \\\n    } while (0)\n#else\n# define CHECK_CMDWIN do { /**/ } while (0)\n#endif\n\n    Prenum1 = Prenum == 0 ? 1 : Prenum;\n\n    switch (nchar)\n    {\n/* split current window in two parts, horizontally */\n    case 'S':\n    case Ctrl_S:\n    case 's':\n\t\tCHECK_CMDWIN;\n\t\treset_VIsual_and_resel();\t/* stop Visual mode */\n#ifdef FEAT_QUICKFIX\n\t\t/* When splitting the quickfix window open a new buffer in it,\n\t\t * don't replicate the quickfix buffer. */\n\t\tif (bt_quickfix(curbuf))\n\t\t    goto newwindow;\n#endif\n#ifdef FEAT_GUI\n\t\tneed_mouse_correct = TRUE;\n#endif\n\t\t(void)win_split((int)Prenum, 0);\n\t\tbreak;\n\n/* split current window in two parts, vertically */\n    case Ctrl_V:\n    case 'v':\n\t\tCHECK_CMDWIN;\n\t\treset_VIsual_and_resel();\t/* stop Visual mode */\n#ifdef FEAT_QUICKFIX\n\t\t/* When splitting the quickfix window open a new buffer in it,\n\t\t * don't replicate the quickfix buffer. */\n\t\tif (bt_quickfix(curbuf))\n\t\t    goto newwindow;\n#endif\n#ifdef FEAT_GUI\n\t\tneed_mouse_correct = TRUE;\n#endif\n\t\t(void)win_split((int)Prenum, WSP_VERT);\n\t\tbreak;\n\n/* split current window and edit alternate file */\n    case Ctrl_HAT:\n    case '^':\n\t\tCHECK_CMDWIN;\n\t\treset_VIsual_and_resel();\t/* stop Visual mode */\n\n\t\tif (buflist_findnr(Prenum == 0\n\t\t\t\t\t? curwin->w_alt_fnum : Prenum) == NULL)\n\t\t{\n\t\t    if (Prenum == 0)\n\t\t\temsg(_(e_noalt));\n\t\t    else\n\t\t\tsemsg(_(\"E92: Buffer %ld not found\"), Prenum);\n\t\t    break;\n\t\t}\n\n\t\tif (!curbuf_locked() && win_split(0, 0) == OK)\n\t\t    (void)buflist_getfile(\n\t\t\t    Prenum == 0 ? curwin->w_alt_fnum : Prenum,\n\t\t\t    (linenr_T)0, GETF_ALT, FALSE);\n\t\tbreak;\n\n/* open new window */\n    case Ctrl_N:\n    case 'n':\n\t\tCHECK_CMDWIN;\n\t\treset_VIsual_and_resel();\t/* stop Visual mode */\n#ifdef FEAT_QUICKFIX\nnewwindow:\n#endif\n\t\tif (Prenum)\n\t\t    /* window height */\n\t\t    vim_snprintf((char *)cbuf, sizeof(cbuf) - 5, \"%ld\", Prenum);\n\t\telse\n\t\t    cbuf[0] = NUL;\n#if defined(FEAT_QUICKFIX)\n\t\tif (nchar == 'v' || nchar == Ctrl_V)\n\t\t    STRCAT(cbuf, \"v\");\n#endif\n\t\tSTRCAT(cbuf, \"new\");\n\t\tdo_cmdline_cmd(cbuf);\n\t\tbreak;\n\n/* quit current window */\n    case Ctrl_Q:\n    case 'q':\n\t\treset_VIsual_and_resel();\t/* stop Visual mode */\n\t\tcmd_with_count(\"quit\", cbuf, sizeof(cbuf), Prenum);\n\t\tdo_cmdline_cmd(cbuf);\n\t\tbreak;\n\n/* close current window */\n    case Ctrl_C:\n    case 'c':\n\t\treset_VIsual_and_resel();\t/* stop Visual mode */\n\t\tcmd_with_count(\"close\", cbuf, sizeof(cbuf), Prenum);\n\t\tdo_cmdline_cmd(cbuf);\n\t\tbreak;\n\n#if defined(FEAT_QUICKFIX)\n/* close preview window */\n    case Ctrl_Z:\n    case 'z':\n\t\tCHECK_CMDWIN;\n\t\treset_VIsual_and_resel();\t/* stop Visual mode */\n\t\tdo_cmdline_cmd((char_u *)\"pclose\");\n\t\tbreak;\n\n/* cursor to preview window */\n    case 'P':\n\t\tFOR_ALL_WINDOWS(wp)\n\t\t    if (wp->w_p_pvw)\n\t\t\tbreak;\n\t\tif (wp == NULL)\n\t\t    emsg(_(\"E441: There is no preview window\"));\n\t\telse\n\t\t    win_goto(wp);\n\t\tbreak;\n#endif\n\n/* close all but current window */\n    case Ctrl_O:\n    case 'o':\n\t\tCHECK_CMDWIN;\n\t\treset_VIsual_and_resel();\t/* stop Visual mode */\n\t\tcmd_with_count(\"only\", cbuf, sizeof(cbuf), Prenum);\n\t\tdo_cmdline_cmd(cbuf);\n\t\tbreak;\n\n/* cursor to next window with wrap around */\n    case Ctrl_W:\n    case 'w':\n/* cursor to previous window with wrap around */\n    case 'W':\n\t\tCHECK_CMDWIN;\n\t\tif (ONE_WINDOW && Prenum != 1)\t/* just one window */\n\t\t    beep_flush();\n\t\telse\n\t\t{\n\t\t    if (Prenum)\t\t\t/* go to specified window */\n\t\t    {\n\t\t\tfor (wp = firstwin; --Prenum > 0; )\n\t\t\t{\n\t\t\t    if (wp->w_next == NULL)\n\t\t\t\tbreak;\n\t\t\t    else\n\t\t\t\twp = wp->w_next;\n\t\t\t}\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tif (nchar == 'W')\t    /* go to previous window */\n\t\t\t{\n\t\t\t    wp = curwin->w_prev;\n\t\t\t    if (wp == NULL)\n\t\t\t\twp = lastwin;\t    /* wrap around */\n\t\t\t}\n\t\t\telse\t\t\t    /* go to next window */\n\t\t\t{\n\t\t\t    wp = curwin->w_next;\n\t\t\t    if (wp == NULL)\n\t\t\t\twp = firstwin;\t    /* wrap around */\n\t\t\t}\n\t\t    }\n\t\t    win_goto(wp);\n\t\t}\n\t\tbreak;\n\n/* cursor to window below */\n    case 'j':\n    case K_DOWN:\n    case Ctrl_J:\n\t\tCHECK_CMDWIN;\n\t\twin_goto_ver(FALSE, Prenum1);\n\t\tbreak;\n\n/* cursor to window above */\n    case 'k':\n    case K_UP:\n    case Ctrl_K:\n\t\tCHECK_CMDWIN;\n\t\twin_goto_ver(TRUE, Prenum1);\n\t\tbreak;\n\n/* cursor to left window */\n    case 'h':\n    case K_LEFT:\n    case Ctrl_H:\n    case K_BS:\n\t\tCHECK_CMDWIN;\n\t\twin_goto_hor(TRUE, Prenum1);\n\t\tbreak;\n\n/* cursor to right window */\n    case 'l':\n    case K_RIGHT:\n    case Ctrl_L:\n\t\tCHECK_CMDWIN;\n\t\twin_goto_hor(FALSE, Prenum1);\n\t\tbreak;\n\n/* move window to new tab page */\n    case 'T':\n\t\tif (one_window())\n\t\t    msg(_(m_onlyone));\n\t\telse\n\t\t{\n\t\t    tabpage_T\t*oldtab = curtab;\n\t\t    tabpage_T\t*newtab;\n\n\t\t    /* First create a new tab with the window, then go back to\n\t\t     * the old tab and close the window there. */\n\t\t    wp = curwin;\n\t\t    if (win_new_tabpage((int)Prenum) == OK\n\t\t\t\t\t\t     && valid_tabpage(oldtab))\n\t\t    {\n\t\t\tnewtab = curtab;\n\t\t\tgoto_tabpage_tp(oldtab, TRUE, TRUE);\n\t\t\tif (curwin == wp)\n\t\t\t    win_close(curwin, FALSE);\n\t\t\tif (valid_tabpage(newtab))\n\t\t\t    goto_tabpage_tp(newtab, TRUE, TRUE);\n\t\t    }\n\t\t}\n\t\tbreak;\n\n/* cursor to top-left window */\n    case 't':\n    case Ctrl_T:\n\t\twin_goto(firstwin);\n\t\tbreak;\n\n/* cursor to bottom-right window */\n    case 'b':\n    case Ctrl_B:\n\t\twin_goto(lastwin);\n\t\tbreak;\n\n/* cursor to last accessed (previous) window */\n    case 'p':\n    case Ctrl_P:\n\t\tif (!win_valid(prevwin))\n\t\t    beep_flush();\n\t\telse\n\t\t    win_goto(prevwin);\n\t\tbreak;\n\n/* exchange current and next window */\n    case 'x':\n    case Ctrl_X:\n\t\tCHECK_CMDWIN;\n\t\twin_exchange(Prenum);\n\t\tbreak;\n\n/* rotate windows downwards */\n    case Ctrl_R:\n    case 'r':\n\t\tCHECK_CMDWIN;\n\t\treset_VIsual_and_resel();\t/* stop Visual mode */\n\t\twin_rotate(FALSE, (int)Prenum1);    /* downwards */\n\t\tbreak;\n\n/* rotate windows upwards */\n    case 'R':\n\t\tCHECK_CMDWIN;\n\t\treset_VIsual_and_resel();\t/* stop Visual mode */\n\t\twin_rotate(TRUE, (int)Prenum1);\t    /* upwards */\n\t\tbreak;\n\n/* move window to the very top/bottom/left/right */\n    case 'K':\n    case 'J':\n    case 'H':\n    case 'L':\n\t\tCHECK_CMDWIN;\n\t\twin_totop((int)Prenum,\n\t\t\t((nchar == 'H' || nchar == 'L') ? WSP_VERT : 0)\n\t\t\t| ((nchar == 'H' || nchar == 'K') ? WSP_TOP : WSP_BOT));\n\t\tbreak;\n\n/* make all windows the same height */\n    case '=':\n#ifdef FEAT_GUI\n\t\tneed_mouse_correct = TRUE;\n#endif\n\t\twin_equal(NULL, FALSE, 'b');\n\t\tbreak;\n\n/* increase current window height */\n    case '+':\n#ifdef FEAT_GUI\n\t\tneed_mouse_correct = TRUE;\n#endif\n\t\twin_setheight(curwin->w_height + (int)Prenum1);\n\t\tbreak;\n\n/* decrease current window height */\n    case '-':\n#ifdef FEAT_GUI\n\t\tneed_mouse_correct = TRUE;\n#endif\n\t\twin_setheight(curwin->w_height - (int)Prenum1);\n\t\tbreak;\n\n/* set current window height */\n    case Ctrl__:\n    case '_':\n#ifdef FEAT_GUI\n\t\tneed_mouse_correct = TRUE;\n#endif\n\t\twin_setheight(Prenum ? (int)Prenum : 9999);\n\t\tbreak;\n\n/* increase current window width */\n    case '>':\n#ifdef FEAT_GUI\n\t\tneed_mouse_correct = TRUE;\n#endif\n\t\twin_setwidth(curwin->w_width + (int)Prenum1);\n\t\tbreak;\n\n/* decrease current window width */\n    case '<':\n#ifdef FEAT_GUI\n\t\tneed_mouse_correct = TRUE;\n#endif\n\t\twin_setwidth(curwin->w_width - (int)Prenum1);\n\t\tbreak;\n\n/* set current window width */\n    case '|':\n#ifdef FEAT_GUI\n\t\tneed_mouse_correct = TRUE;\n#endif\n\t\twin_setwidth(Prenum != 0 ? (int)Prenum : 9999);\n\t\tbreak;\n\n/* jump to tag and split window if tag exists (in preview window) */\n#if defined(FEAT_QUICKFIX)\n    case '}':\n\t\tCHECK_CMDWIN;\n\t\tif (Prenum)\n\t\t    g_do_tagpreview = Prenum;\n\t\telse\n\t\t    g_do_tagpreview = p_pvh;\n#endif\n\t\t/* FALLTHROUGH */\n    case ']':\n    case Ctrl_RSB:\n\t\tCHECK_CMDWIN;\n\t\t/* keep Visual mode, can select words to use as a tag */\n\t\tif (Prenum)\n\t\t    postponed_split = Prenum;\n\t\telse\n\t\t    postponed_split = -1;\n#ifdef FEAT_QUICKFIX\n\t\tif (nchar != '}')\n\t\t    g_do_tagpreview = 0;\n#endif\n\n\t\t/* Execute the command right here, required when \"wincmd ]\"\n\t\t * was used in a function. */\n\t\tdo_nv_ident(Ctrl_RSB, NUL);\n\t\tbreak;\n\n#ifdef FEAT_SEARCHPATH\n/* edit file name under cursor in a new window */\n    case 'f':\n    case 'F':\n    case Ctrl_F:\nwingotofile:\n\t\tCHECK_CMDWIN;\n\n\t\tptr = grab_file_name(Prenum1, &lnum);\n\t\tif (ptr != NULL)\n\t\t{\n\t\t    tabpage_T\t*oldtab = curtab;\n\t\t    win_T\t*oldwin = curwin;\n# ifdef FEAT_GUI\n\t\t    need_mouse_correct = TRUE;\n# endif\n\t\t    setpcmark();\n\t\t    if (win_split(0, 0) == OK)\n\t\t    {\n\t\t\tRESET_BINDING(curwin);\n\t\t\tif (do_ecmd(0, ptr, NULL, NULL, ECMD_LASTL,\n\t\t\t\t\t\t   ECMD_HIDE, NULL) == FAIL)\n\t\t\t{\n\t\t\t    /* Failed to open the file, close the window\n\t\t\t     * opened for it. */\n\t\t\t    win_close(curwin, FALSE);\n\t\t\t    goto_tabpage_win(oldtab, oldwin);\n\t\t\t}\n\t\t\telse if (nchar == 'F' && lnum >= 0)\n\t\t\t{\n\t\t\t    curwin->w_cursor.lnum = lnum;\n\t\t\t    check_cursor_lnum();\n\t\t\t    beginline(BL_SOL | BL_FIX);\n\t\t\t}\n\t\t    }\n\t\t    vim_free(ptr);\n\t\t}\n\t\tbreak;\n#endif\n\n#ifdef FEAT_FIND_ID\n/* Go to the first occurrence of the identifier under cursor along path in a\n * new window -- webb\n */\n    case 'i':\t\t\t    /* Go to any match */\n    case Ctrl_I:\n\t\ttype = FIND_ANY;\n\t\t/* FALLTHROUGH */\n    case 'd':\t\t\t    /* Go to definition, using 'define' */\n    case Ctrl_D:\n\t\tCHECK_CMDWIN;\n\t\tif ((len = find_ident_under_cursor(&ptr, FIND_IDENT)) == 0)\n\t\t    break;\n\t\tfind_pattern_in_path(ptr, 0, len, TRUE,\n\t\t\tPrenum == 0 ? TRUE : FALSE, type,\n\t\t\tPrenum1, ACTION_SPLIT, (linenr_T)1, (linenr_T)MAXLNUM);\n\t\tcurwin->w_set_curswant = TRUE;\n\t\tbreak;\n#endif\n\n/* Quickfix window only: view the result under the cursor in a new split. */\n#if defined(FEAT_QUICKFIX)\n    case K_KENTER:\n    case CAR:\n\t\tif (bt_quickfix(curbuf))\n\t\t    qf_view_result(TRUE);\n\t\tbreak;\n#endif\n\n/* CTRL-W g  extended commands */\n    case 'g':\n    case Ctrl_G:\n\t\tCHECK_CMDWIN;\n#ifdef USE_ON_FLY_SCROLL\n\t\tdont_scroll = TRUE;\t\t/* disallow scrolling here */\n#endif\n\t\t++no_mapping;\n\t\t++allow_keys;   /* no mapping for xchar, but allow key codes */\n\t\tif (xchar == NUL)\n\t\t    xchar = plain_vgetc();\n\t\tLANGMAP_ADJUST(xchar, TRUE);\n\t\t--no_mapping;\n\t\t--allow_keys;\n#ifdef FEAT_CMDL_INFO\n\t\t(void)add_to_showcmd(xchar);\n#endif\n\t\tswitch (xchar)\n\t\t{\n#if defined(FEAT_QUICKFIX)\n\t\t    case '}':\n\t\t\txchar = Ctrl_RSB;\n\t\t\tif (Prenum)\n\t\t\t    g_do_tagpreview = Prenum;\n\t\t\telse\n\t\t\t    g_do_tagpreview = p_pvh;\n#endif\n\t\t\t/* FALLTHROUGH */\n\t\t    case ']':\n\t\t    case Ctrl_RSB:\n\t\t\t/* keep Visual mode, can select words to use as a tag */\n\t\t\tif (Prenum)\n\t\t\t    postponed_split = Prenum;\n\t\t\telse\n\t\t\t    postponed_split = -1;\n\n\t\t\t/* Execute the command right here, required when\n\t\t\t * \"wincmd g}\" was used in a function. */\n\t\t\tdo_nv_ident('g', xchar);\n\t\t\tbreak;\n\n#ifdef FEAT_SEARCHPATH\n\t\t    case 'f':\t    /* CTRL-W gf: \"gf\" in a new tab page */\n\t\t    case 'F':\t    /* CTRL-W gF: \"gF\" in a new tab page */\n\t\t\tcmdmod.tab = tabpage_index(curtab) + 1;\n\t\t\tnchar = xchar;\n\t\t\tgoto wingotofile;\n#endif\n\t\t    case 't':\t    // CTRL-W gt: go to next tab page\n\t\t\tgoto_tabpage((int)Prenum);\n\t\t\tbreak;\n\n\t\t    case 'T':\t    // CTRL-W gT: go to previous tab page\n\t\t\tgoto_tabpage(-(int)Prenum1);\n\t\t\tbreak;\n\n\t\t    default:\n\t\t\tbeep_flush();\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n    default:\tbeep_flush();\n\t\tbreak;\n    }\n}\n\n/*\n * Figure out the address type for \":wincmd\".\n */\n    void\nget_wincmd_addr_type(char_u *arg, exarg_T *eap)\n{\n    switch (*arg)\n    {\n    case 'S':\n    case Ctrl_S:\n    case 's':\n    case Ctrl_N:\n    case 'n':\n    case 'j':\n    case Ctrl_J:\n    case 'k':\n    case Ctrl_K:\n    case 'T':\n    case Ctrl_R:\n    case 'r':\n    case 'R':\n    case 'K':\n    case 'J':\n    case '+':\n    case '-':\n    case Ctrl__:\n    case '_':\n    case '|':\n    case ']':\n    case Ctrl_RSB:\n    case 'g':\n    case Ctrl_G:\n    case Ctrl_V:\n    case 'v':\n    case 'h':\n    case Ctrl_H:\n    case 'l':\n    case Ctrl_L:\n    case 'H':\n    case 'L':\n    case '>':\n    case '<':\n#if defined(FEAT_QUICKFIX)\n    case '}':\n#endif\n#ifdef FEAT_SEARCHPATH\n    case 'f':\n    case 'F':\n    case Ctrl_F:\n#endif\n#ifdef FEAT_FIND_ID\n    case 'i':\n    case Ctrl_I:\n    case 'd':\n    case Ctrl_D:\n#endif\n\t\t// window size or any count\n\t\teap->addr_type = ADDR_OTHER;\n\t\tbreak;\n\n    case Ctrl_HAT:\n    case '^':\n\t\t// buffer number\n\t\teap->addr_type = ADDR_BUFFERS;\n\t\tbreak;\n\n    case Ctrl_Q:\n    case 'q':\n    case Ctrl_C:\n    case 'c':\n    case Ctrl_O:\n    case 'o':\n    case Ctrl_W:\n    case 'w':\n    case 'W':\n    case 'x':\n    case Ctrl_X:\n\t\t// window number\n\t\teap->addr_type = ADDR_WINDOWS;\n\t\tbreak;\n\n#if defined(FEAT_QUICKFIX)\n    case Ctrl_Z:\n    case 'z':\n    case 'P':\n#endif\n    case 't':\n    case Ctrl_T:\n    case 'b':\n    case Ctrl_B:\n    case 'p':\n    case Ctrl_P:\n    case '=':\n    case CAR:\n\t\t// no count\n\t\teap->addr_type = ADDR_NONE;\n\t\tbreak;\n    }\n}\n\n    static void\ncmd_with_count(\n    char\t*cmd,\n    char_u\t*bufp,\n    size_t\tbufsize,\n    long\tPrenum)\n{\n    size_t\tlen = STRLEN(cmd);\n\n    STRCPY(bufp, cmd);\n    if (Prenum > 0)\n\tvim_snprintf((char *)bufp + len, bufsize - len, \"%ld\", Prenum);\n}\n\n/*\n * If \"split_disallowed\" is set given an error and return FAIL.\n * Otherwise return OK.\n */\n    static int\ncheck_split_disallowed()\n{\n    if (split_disallowed > 0)\n    {\n\temsg(_(\"E242: Can't split a window while closing another\"));\n\treturn FAIL;\n    }\n    return OK;\n}\n\n/*\n * split the current window, implements CTRL-W s and :split\n *\n * \"size\" is the height or width for the new window, 0 to use half of current\n * height or width.\n *\n * \"flags\":\n * WSP_ROOM: require enough room for new window\n * WSP_VERT: vertical split.\n * WSP_TOP:  open window at the top-left of the shell (help window).\n * WSP_BOT:  open window at the bottom-right of the shell (quickfix window).\n * WSP_HELP: creating the help window, keep layout snapshot\n *\n * return FAIL for failure, OK otherwise\n */\n    int\nwin_split(int size, int flags)\n{\n    if (ERROR_IF_POPUP_WINDOW)\n\treturn FAIL;\n\n    /* When the \":tab\" modifier was used open a new tab page instead. */\n    if (may_open_tabpage() == OK)\n\treturn OK;\n\n    /* Add flags from \":vertical\", \":topleft\" and \":botright\". */\n    flags |= cmdmod.split;\n    if ((flags & WSP_TOP) && (flags & WSP_BOT))\n    {\n\temsg(_(\"E442: Can't split topleft and botright at the same time\"));\n\treturn FAIL;\n    }\n    if (check_split_disallowed() == FAIL)\n\treturn FAIL;\n\n    /* When creating the help window make a snapshot of the window layout.\n     * Otherwise clear the snapshot, it's now invalid. */\n    if (flags & WSP_HELP)\n\tmake_snapshot(SNAP_HELP_IDX);\n    else\n\tclear_snapshot(curtab, SNAP_HELP_IDX);\n\n    return win_split_ins(size, flags, NULL, 0);\n}\n\n/*\n * When \"new_wp\" is NULL: split the current window in two.\n * When \"new_wp\" is not NULL: insert this window at the far\n * top/left/right/bottom.\n * return FAIL for failure, OK otherwise\n */\n    int\nwin_split_ins(\n    int\t\tsize,\n    int\t\tflags,\n    win_T\t*new_wp,\n    int\t\tdir)\n{\n    win_T\t*wp = new_wp;\n    win_T\t*oldwin;\n    int\t\tnew_size = size;\n    int\t\ti;\n    int\t\tneed_status = 0;\n    int\t\tdo_equal = FALSE;\n    int\t\tneeded;\n    int\t\tavailable;\n    int\t\toldwin_height = 0;\n    int\t\tlayout;\n    frame_T\t*frp, *curfrp, *frp2, *prevfrp;\n    int\t\tbefore;\n    int\t\tminheight;\n    int\t\twmh1;\n    int\t\tdid_set_fraction = FALSE;\n\n    if (flags & WSP_TOP)\n\toldwin = firstwin;\n    else if (flags & WSP_BOT)\n\toldwin = lastwin;\n    else\n\toldwin = curwin;\n\n    /* add a status line when p_ls == 1 and splitting the first window */\n    if (ONE_WINDOW && p_ls == 1 && oldwin->w_status_height == 0)\n    {\n\tif (VISIBLE_HEIGHT(oldwin) <= p_wmh && new_wp == NULL)\n\t{\n\t    emsg(_(e_noroom));\n\t    return FAIL;\n\t}\n\tneed_status = STATUS_HEIGHT;\n    }\n\n#ifdef FEAT_GUI\n    /* May be needed for the scrollbars that are going to change. */\n    if (gui.in_use)\n\tout_flush();\n#endif\n\n    if (flags & WSP_VERT)\n    {\n\tint\twmw1;\n\tint\tminwidth;\n\n\tlayout = FR_ROW;\n\n\t/*\n\t * Check if we are able to split the current window and compute its\n\t * width.\n\t */\n\t/* Current window requires at least 1 space. */\n\twmw1 = (p_wmw == 0 ? 1 : p_wmw);\n\tneeded = wmw1 + 1;\n\tif (flags & WSP_ROOM)\n\t    needed += p_wiw - wmw1;\n\tif (flags & (WSP_BOT | WSP_TOP))\n\t{\n\t    minwidth = frame_minwidth(topframe, NOWIN);\n\t    available = topframe->fr_width;\n\t    needed += minwidth;\n\t}\n\telse if (p_ea)\n\t{\n\t    minwidth = frame_minwidth(oldwin->w_frame, NOWIN);\n\t    prevfrp = oldwin->w_frame;\n\t    for (frp = oldwin->w_frame->fr_parent; frp != NULL;\n\t\t\t\t\t\t\tfrp = frp->fr_parent)\n\t    {\n\t\tif (frp->fr_layout == FR_ROW)\n\t\t    FOR_ALL_FRAMES(frp2, frp->fr_child)\n\t\t\tif (frp2 != prevfrp)\n\t\t\t    minwidth += frame_minwidth(frp2, NOWIN);\n\t\tprevfrp = frp;\n\t    }\n\t    available = topframe->fr_width;\n\t    needed += minwidth;\n\t}\n\telse\n\t{\n\t    minwidth = frame_minwidth(oldwin->w_frame, NOWIN);\n\t    available = oldwin->w_frame->fr_width;\n\t    needed += minwidth;\n\t}\n\tif (available < needed && new_wp == NULL)\n\t{\n\t    emsg(_(e_noroom));\n\t    return FAIL;\n\t}\n\tif (new_size == 0)\n\t    new_size = oldwin->w_width / 2;\n\tif (new_size > available - minwidth - 1)\n\t    new_size = available - minwidth - 1;\n\tif (new_size < wmw1)\n\t    new_size = wmw1;\n\n\t/* if it doesn't fit in the current window, need win_equal() */\n\tif (oldwin->w_width - new_size - 1 < p_wmw)\n\t    do_equal = TRUE;\n\n\t/* We don't like to take lines for the new window from a\n\t * 'winfixwidth' window.  Take them from a window to the left or right\n\t * instead, if possible. Add one for the separator. */\n\tif (oldwin->w_p_wfw)\n\t    win_setwidth_win(oldwin->w_width + new_size + 1, oldwin);\n\n\t/* Only make all windows the same width if one of them (except oldwin)\n\t * is wider than one of the split windows. */\n\tif (!do_equal && p_ea && size == 0 && *p_ead != 'v'\n\t\t\t\t\t && oldwin->w_frame->fr_parent != NULL)\n\t{\n\t    frp = oldwin->w_frame->fr_parent->fr_child;\n\t    while (frp != NULL)\n\t    {\n\t\tif (frp->fr_win != oldwin && frp->fr_win != NULL\n\t\t\t&& (frp->fr_win->w_width > new_size\n\t\t\t    || frp->fr_win->w_width > oldwin->w_width\n\t\t\t\t\t\t\t      - new_size - 1))\n\t\t{\n\t\t    do_equal = TRUE;\n\t\t    break;\n\t\t}\n\t\tfrp = frp->fr_next;\n\t    }\n\t}\n    }\n    else\n    {\n\tlayout = FR_COL;\n\n\t/*\n\t * Check if we are able to split the current window and compute its\n\t * height.\n\t */\n\t/* Current window requires at least 1 space. */\n\twmh1 = (p_wmh == 0 ? 1 : p_wmh) + WINBAR_HEIGHT(curwin);\n\tneeded = wmh1 + STATUS_HEIGHT;\n\tif (flags & WSP_ROOM)\n\t    needed += p_wh - wmh1;\n\tif (flags & (WSP_BOT | WSP_TOP))\n\t{\n\t    minheight = frame_minheight(topframe, NOWIN) + need_status;\n\t    available = topframe->fr_height;\n\t    needed += minheight;\n\t}\n\telse if (p_ea)\n\t{\n\t    minheight = frame_minheight(oldwin->w_frame, NOWIN) + need_status;\n\t    prevfrp = oldwin->w_frame;\n\t    for (frp = oldwin->w_frame->fr_parent; frp != NULL;\n\t\t\t\t\t\t\tfrp = frp->fr_parent)\n\t    {\n\t\tif (frp->fr_layout == FR_COL)\n\t\t    FOR_ALL_FRAMES(frp2, frp->fr_child)\n\t\t\tif (frp2 != prevfrp)\n\t\t\t    minheight += frame_minheight(frp2, NOWIN);\n\t\tprevfrp = frp;\n\t    }\n\t    available = topframe->fr_height;\n\t    needed += minheight;\n\t}\n\telse\n\t{\n\t    minheight = frame_minheight(oldwin->w_frame, NOWIN) + need_status;\n\t    available = oldwin->w_frame->fr_height;\n\t    needed += minheight;\n\t}\n\tif (available < needed && new_wp == NULL)\n\t{\n\t    emsg(_(e_noroom));\n\t    return FAIL;\n\t}\n\toldwin_height = oldwin->w_height;\n\tif (need_status)\n\t{\n\t    oldwin->w_status_height = STATUS_HEIGHT;\n\t    oldwin_height -= STATUS_HEIGHT;\n\t}\n\tif (new_size == 0)\n\t    new_size = oldwin_height / 2;\n\tif (new_size > available - minheight - STATUS_HEIGHT)\n\t    new_size = available - minheight - STATUS_HEIGHT;\n\tif (new_size < wmh1)\n\t    new_size = wmh1;\n\n\t/* if it doesn't fit in the current window, need win_equal() */\n\tif (oldwin_height - new_size - STATUS_HEIGHT < p_wmh)\n\t    do_equal = TRUE;\n\n\t/* We don't like to take lines for the new window from a\n\t * 'winfixheight' window.  Take them from a window above or below\n\t * instead, if possible. */\n\tif (oldwin->w_p_wfh)\n\t{\n\t    /* Set w_fraction now so that the cursor keeps the same relative\n\t     * vertical position using the old height. */\n\t    set_fraction(oldwin);\n\t    did_set_fraction = TRUE;\n\n\t    win_setheight_win(oldwin->w_height + new_size + STATUS_HEIGHT,\n\t\t\t\t\t\t\t\t      oldwin);\n\t    oldwin_height = oldwin->w_height;\n\t    if (need_status)\n\t\toldwin_height -= STATUS_HEIGHT;\n\t}\n\n\t/* Only make all windows the same height if one of them (except oldwin)\n\t * is higher than one of the split windows. */\n\tif (!do_equal && p_ea && size == 0 && *p_ead != 'h'\n\t   && oldwin->w_frame->fr_parent != NULL)\n\t{\n\t    frp = oldwin->w_frame->fr_parent->fr_child;\n\t    while (frp != NULL)\n\t    {\n\t\tif (frp->fr_win != oldwin && frp->fr_win != NULL\n\t\t\t&& (frp->fr_win->w_height > new_size\n\t\t\t    || frp->fr_win->w_height > oldwin_height - new_size\n\t\t\t\t\t\t\t      - STATUS_HEIGHT))\n\t\t{\n\t\t    do_equal = TRUE;\n\t\t    break;\n\t\t}\n\t\tfrp = frp->fr_next;\n\t    }\n\t}\n    }\n\n    /*\n     * allocate new window structure and link it in the window list\n     */\n    if ((flags & WSP_TOP) == 0\n\t    && ((flags & WSP_BOT)\n\t\t|| (flags & WSP_BELOW)\n\t\t|| (!(flags & WSP_ABOVE)\n\t\t    && ( (flags & WSP_VERT) ? p_spr : p_sb))))\n    {\n\t/* new window below/right of current one */\n\tif (new_wp == NULL)\n\t    wp = win_alloc(oldwin, FALSE);\n\telse\n\t    win_append(oldwin, wp);\n    }\n    else\n    {\n\tif (new_wp == NULL)\n\t    wp = win_alloc(oldwin->w_prev, FALSE);\n\telse\n\t    win_append(oldwin->w_prev, wp);\n    }\n\n    if (new_wp == NULL)\n    {\n\tif (wp == NULL)\n\t    return FAIL;\n\n\tnew_frame(wp);\n\tif (wp->w_frame == NULL)\n\t{\n\t    win_free(wp, NULL);\n\t    return FAIL;\n\t}\n\n\t/* make the contents of the new window the same as the current one */\n\twin_init(wp, curwin, flags);\n    }\n\n    /*\n     * Reorganise the tree of frames to insert the new window.\n     */\n    if (flags & (WSP_TOP | WSP_BOT))\n    {\n\tif ((topframe->fr_layout == FR_COL && (flags & WSP_VERT) == 0)\n\t    || (topframe->fr_layout == FR_ROW && (flags & WSP_VERT) != 0))\n\t{\n\t    curfrp = topframe->fr_child;\n\t    if (flags & WSP_BOT)\n\t\twhile (curfrp->fr_next != NULL)\n\t\t    curfrp = curfrp->fr_next;\n\t}\n\telse\n\t    curfrp = topframe;\n\tbefore = (flags & WSP_TOP);\n    }\n    else\n    {\n\tcurfrp = oldwin->w_frame;\n\tif (flags & WSP_BELOW)\n\t    before = FALSE;\n\telse if (flags & WSP_ABOVE)\n\t    before = TRUE;\n\telse if (flags & WSP_VERT)\n\t    before = !p_spr;\n\telse\n\t    before = !p_sb;\n    }\n    if (curfrp->fr_parent == NULL || curfrp->fr_parent->fr_layout != layout)\n    {\n\t/* Need to create a new frame in the tree to make a branch. */\n\tfrp = ALLOC_CLEAR_ONE(frame_T);\n\t*frp = *curfrp;\n\tcurfrp->fr_layout = layout;\n\tfrp->fr_parent = curfrp;\n\tfrp->fr_next = NULL;\n\tfrp->fr_prev = NULL;\n\tcurfrp->fr_child = frp;\n\tcurfrp->fr_win = NULL;\n\tcurfrp = frp;\n\tif (frp->fr_win != NULL)\n\t    oldwin->w_frame = frp;\n\telse\n\t    FOR_ALL_FRAMES(frp, frp->fr_child)\n\t\tfrp->fr_parent = curfrp;\n    }\n\n    if (new_wp == NULL)\n\tfrp = wp->w_frame;\n    else\n\tfrp = new_wp->w_frame;\n    frp->fr_parent = curfrp->fr_parent;\n\n    /* Insert the new frame at the right place in the frame list. */\n    if (before)\n\tframe_insert(curfrp, frp);\n    else\n\tframe_append(curfrp, frp);\n\n    /* Set w_fraction now so that the cursor keeps the same relative\n     * vertical position. */\n    if (!did_set_fraction)\n\tset_fraction(oldwin);\n    wp->w_fraction = oldwin->w_fraction;\n\n    if (flags & WSP_VERT)\n    {\n\twp->w_p_scr = curwin->w_p_scr;\n\n\tif (need_status)\n\t{\n\t    win_new_height(oldwin, oldwin->w_height - 1);\n\t    oldwin->w_status_height = need_status;\n\t}\n\tif (flags & (WSP_TOP | WSP_BOT))\n\t{\n\t    /* set height and row of new window to full height */\n\t    wp->w_winrow = tabline_height();\n\t    win_new_height(wp, curfrp->fr_height - (p_ls > 0)\n\t\t\t\t\t\t\t  - WINBAR_HEIGHT(wp));\n\t    wp->w_status_height = (p_ls > 0);\n\t}\n\telse\n\t{\n\t    /* height and row of new window is same as current window */\n\t    wp->w_winrow = oldwin->w_winrow;\n\t    win_new_height(wp, VISIBLE_HEIGHT(oldwin));\n\t    wp->w_status_height = oldwin->w_status_height;\n\t}\n\tfrp->fr_height = curfrp->fr_height;\n\n\t/* \"new_size\" of the current window goes to the new window, use\n\t * one column for the vertical separator */\n\twin_new_width(wp, new_size);\n\tif (before)\n\t    wp->w_vsep_width = 1;\n\telse\n\t{\n\t    wp->w_vsep_width = oldwin->w_vsep_width;\n\t    oldwin->w_vsep_width = 1;\n\t}\n\tif (flags & (WSP_TOP | WSP_BOT))\n\t{\n\t    if (flags & WSP_BOT)\n\t\tframe_add_vsep(curfrp);\n\t    /* Set width of neighbor frame */\n\t    frame_new_width(curfrp, curfrp->fr_width\n\t\t     - (new_size + ((flags & WSP_TOP) != 0)), flags & WSP_TOP,\n\t\t\t\t\t\t\t\t       FALSE);\n\t}\n\telse\n\t    win_new_width(oldwin, oldwin->w_width - (new_size + 1));\n\tif (before)\t/* new window left of current one */\n\t{\n\t    wp->w_wincol = oldwin->w_wincol;\n\t    oldwin->w_wincol += new_size + 1;\n\t}\n\telse\t\t/* new window right of current one */\n\t    wp->w_wincol = oldwin->w_wincol + oldwin->w_width + 1;\n\tframe_fix_width(oldwin);\n\tframe_fix_width(wp);\n    }\n    else\n    {\n\t/* width and column of new window is same as current window */\n\tif (flags & (WSP_TOP | WSP_BOT))\n\t{\n\t    wp->w_wincol = 0;\n\t    win_new_width(wp, Columns);\n\t    wp->w_vsep_width = 0;\n\t}\n\telse\n\t{\n\t    wp->w_wincol = oldwin->w_wincol;\n\t    win_new_width(wp, oldwin->w_width);\n\t    wp->w_vsep_width = oldwin->w_vsep_width;\n\t}\n\tfrp->fr_width = curfrp->fr_width;\n\n\t/* \"new_size\" of the current window goes to the new window, use\n\t * one row for the status line */\n\twin_new_height(wp, new_size);\n\tif (flags & (WSP_TOP | WSP_BOT))\n\t{\n\t    int new_fr_height = curfrp->fr_height - new_size\n\t\t\t\t\t\t\t  + WINBAR_HEIGHT(wp) ;\n\n\t    if (!((flags & WSP_BOT) && p_ls == 0))\n\t\tnew_fr_height -= STATUS_HEIGHT;\n\t    frame_new_height(curfrp, new_fr_height, flags & WSP_TOP, FALSE);\n\t}\n\telse\n\t    win_new_height(oldwin, oldwin_height - (new_size + STATUS_HEIGHT));\n\tif (before)\t/* new window above current one */\n\t{\n\t    wp->w_winrow = oldwin->w_winrow;\n\t    wp->w_status_height = STATUS_HEIGHT;\n\t    oldwin->w_winrow += wp->w_height + STATUS_HEIGHT;\n\t}\n\telse\t\t/* new window below current one */\n\t{\n\t    wp->w_winrow = oldwin->w_winrow + VISIBLE_HEIGHT(oldwin)\n\t\t\t\t\t\t\t       + STATUS_HEIGHT;\n\t    wp->w_status_height = oldwin->w_status_height;\n\t    if (!(flags & WSP_BOT))\n\t\toldwin->w_status_height = STATUS_HEIGHT;\n\t}\n\tif (flags & WSP_BOT)\n\t    frame_add_statusline(curfrp);\n\tframe_fix_height(wp);\n\tframe_fix_height(oldwin);\n    }\n\n    if (flags & (WSP_TOP | WSP_BOT))\n\t(void)win_comp_pos();\n\n    /*\n     * Both windows need redrawing\n     */\n    redraw_win_later(wp, NOT_VALID);\n    wp->w_redr_status = TRUE;\n    redraw_win_later(oldwin, NOT_VALID);\n    oldwin->w_redr_status = TRUE;\n\n    if (need_status)\n    {\n\tmsg_row = Rows - 1;\n\tmsg_col = sc_col;\n\tmsg_clr_eos_force();\t/* Old command/ruler may still be there */\n\tcomp_col();\n\tmsg_row = Rows - 1;\n\tmsg_col = 0;\t/* put position back at start of line */\n    }\n\n    /*\n     * equalize the window sizes.\n     */\n    if (do_equal || dir != 0)\n\twin_equal(wp, TRUE,\n\t\t(flags & WSP_VERT) ? (dir == 'v' ? 'b' : 'h')\n\t\t: dir == 'h' ? 'b' : 'v');\n\n    /* Don't change the window height/width to 'winheight' / 'winwidth' if a\n     * size was given. */\n    if (flags & WSP_VERT)\n    {\n\ti = p_wiw;\n\tif (size != 0)\n\t    p_wiw = size;\n\n# ifdef FEAT_GUI\n\t/* When 'guioptions' includes 'L' or 'R' may have to add scrollbars. */\n\tif (gui.in_use)\n\t    gui_init_which_components(NULL);\n# endif\n    }\n    else\n    {\n\ti = p_wh;\n\tif (size != 0)\n\t    p_wh = size;\n    }\n\n#ifdef FEAT_JUMPLIST\n    /* Keep same changelist position in new window. */\n    wp->w_changelistidx = oldwin->w_changelistidx;\n#endif\n\n    /*\n     * make the new window the current window\n     */\n    win_enter_ext(wp, FALSE, FALSE, TRUE, TRUE, TRUE);\n    if (flags & WSP_VERT)\n\tp_wiw = i;\n    else\n\tp_wh = i;\n\n    return OK;\n}\n\n\n/*\n * Initialize window \"newp\" from window \"oldp\".\n * Used when splitting a window and when creating a new tab page.\n * The windows will both edit the same buffer.\n * WSP_NEWLOC may be specified in flags to prevent the location list from\n * being copied.\n */\n    static void\nwin_init(win_T *newp, win_T *oldp, int flags UNUSED)\n{\n    int\t\ti;\n\n    newp->w_buffer = oldp->w_buffer;\n#ifdef FEAT_SYN_HL\n    newp->w_s = &(oldp->w_buffer->b_s);\n#endif\n    oldp->w_buffer->b_nwindows++;\n    newp->w_cursor = oldp->w_cursor;\n    newp->w_valid = 0;\n    newp->w_curswant = oldp->w_curswant;\n    newp->w_set_curswant = oldp->w_set_curswant;\n    newp->w_topline = oldp->w_topline;\n#ifdef FEAT_DIFF\n    newp->w_topfill = oldp->w_topfill;\n#endif\n    newp->w_leftcol = oldp->w_leftcol;\n    newp->w_pcmark = oldp->w_pcmark;\n    newp->w_prev_pcmark = oldp->w_prev_pcmark;\n    newp->w_alt_fnum = oldp->w_alt_fnum;\n    newp->w_wrow = oldp->w_wrow;\n    newp->w_fraction = oldp->w_fraction;\n    newp->w_prev_fraction_row = oldp->w_prev_fraction_row;\n#ifdef FEAT_JUMPLIST\n    copy_jumplist(oldp, newp);\n#endif\n#ifdef FEAT_QUICKFIX\n    if (flags & WSP_NEWLOC)\n    {\n\t/* Don't copy the location list.  */\n\tnewp->w_llist = NULL;\n\tnewp->w_llist_ref = NULL;\n    }\n    else\n\tcopy_loclist_stack(oldp, newp);\n#endif\n    newp->w_localdir = (oldp->w_localdir == NULL)\n\t\t\t\t    ? NULL : vim_strsave(oldp->w_localdir);\n\n    /* copy tagstack and folds */\n    for (i = 0; i < oldp->w_tagstacklen; i++)\n    {\n\ttaggy_T\t*tag = &newp->w_tagstack[i];\n\t*tag = oldp->w_tagstack[i];\n\tif (tag->tagname != NULL)\n\t    tag->tagname = vim_strsave(tag->tagname);\n\tif (tag->user_data != NULL)\n\t    tag->user_data = vim_strsave(tag->user_data);\n    }\n    newp->w_tagstackidx = oldp->w_tagstackidx;\n    newp->w_tagstacklen = oldp->w_tagstacklen;\n#ifdef FEAT_FOLDING\n    copyFoldingState(oldp, newp);\n#endif\n\n    win_init_some(newp, oldp);\n\n#ifdef FEAT_SYN_HL\n    check_colorcolumn(newp);\n#endif\n}\n\n/*\n * Initialize window \"newp\" from window \"old\".\n * Only the essential things are copied.\n */\n    static void\nwin_init_some(win_T *newp, win_T *oldp)\n{\n    /* Use the same argument list. */\n    newp->w_alist = oldp->w_alist;\n    ++newp->w_alist->al_refcount;\n    newp->w_arg_idx = oldp->w_arg_idx;\n\n    /* copy options from existing window */\n    win_copy_options(oldp, newp);\n}\n\n/*\n * Return TRUE if \"win\" is a global popup or a popup in the current tab page.\n */\n    int\nwin_valid_popup(win_T *win UNUSED)\n{\n#ifdef FEAT_TEXT_PROP\n    win_T\t*wp;\n\n    for (wp = first_popupwin; wp != NULL; wp = wp->w_next)\n\tif (wp == win)\n\t    return TRUE;\n    for (wp = curtab->tp_first_popupwin; wp != NULL; wp = wp->w_next)\n\tif (wp == win)\n\t    return TRUE;\n#endif\n    return FALSE;\n}\n\n/*\n * Check if \"win\" is a pointer to an existing window in the current tab page.\n */\n    int\nwin_valid(win_T *win)\n{\n    win_T\t*wp;\n\n    if (win == NULL)\n\treturn FALSE;\n    FOR_ALL_WINDOWS(wp)\n\tif (wp == win)\n\t    return TRUE;\n    return win_valid_popup(win);\n}\n\n/*\n * Check if \"win\" is a pointer to an existing window in any tab page.\n */\n    int\nwin_valid_any_tab(win_T *win)\n{\n    win_T\t*wp;\n    tabpage_T\t*tp;\n\n    if (win == NULL)\n\treturn FALSE;\n    FOR_ALL_TABPAGES(tp)\n    {\n\tFOR_ALL_WINDOWS_IN_TAB(tp, wp)\n\t{\n\t    if (wp == win)\n\t\treturn TRUE;\n\t}\n#ifdef FEAT_TEXT_PROP\n\tfor (wp = tp->tp_first_popupwin; wp != NULL; wp = wp->w_next)\n\t    if (wp == win)\n\t\treturn TRUE;\n#endif\n    }\n    return win_valid_popup(win);\n}\n\n/*\n * Return the number of windows.\n */\n    int\nwin_count(void)\n{\n    win_T\t*wp;\n    int\t\tcount = 0;\n\n    FOR_ALL_WINDOWS(wp)\n\t++count;\n    return count;\n}\n\n/*\n * Make \"count\" windows on the screen.\n * Return actual number of windows on the screen.\n * Must be called when there is just one window, filling the whole screen\n * (excluding the command line).\n */\n    int\nmake_windows(\n    int\t\tcount,\n    int\t\tvertical UNUSED)  /* split windows vertically if TRUE */\n{\n    int\t\tmaxcount;\n    int\t\ttodo;\n\n    if (vertical)\n    {\n\t/* Each windows needs at least 'winminwidth' lines and a separator\n\t * column. */\n\tmaxcount = (curwin->w_width + curwin->w_vsep_width\n\t\t\t\t\t     - (p_wiw - p_wmw)) / (p_wmw + 1);\n    }\n    else\n    {\n\t/* Each window needs at least 'winminheight' lines and a status line. */\n\tmaxcount = (VISIBLE_HEIGHT(curwin) + curwin->w_status_height\n\t\t\t\t  - (p_wh - p_wmh)) / (p_wmh + STATUS_HEIGHT);\n    }\n\n    if (maxcount < 2)\n\tmaxcount = 2;\n    if (count > maxcount)\n\tcount = maxcount;\n\n    /*\n     * add status line now, otherwise first window will be too big\n     */\n    if (count > 1)\n\tlast_status(TRUE);\n\n    /*\n     * Don't execute autocommands while creating the windows.  Must do that\n     * when putting the buffers in the windows.\n     */\n    block_autocmds();\n\n    /* todo is number of windows left to create */\n    for (todo = count - 1; todo > 0; --todo)\n\tif (vertical)\n\t{\n\t    if (win_split(curwin->w_width - (curwin->w_width - todo)\n\t\t\t/ (todo + 1) - 1, WSP_VERT | WSP_ABOVE) == FAIL)\n\t\tbreak;\n\t}\n\telse\n\t{\n\t    if (win_split(curwin->w_height - (curwin->w_height - todo\n\t\t\t    * STATUS_HEIGHT) / (todo + 1)\n\t\t\t- STATUS_HEIGHT, WSP_ABOVE) == FAIL)\n\t\tbreak;\n\t}\n\n    unblock_autocmds();\n\n    /* return actual number of windows */\n    return (count - todo);\n}\n\n/*\n * Exchange current and next window\n */\n    static void\nwin_exchange(long Prenum)\n{\n    frame_T\t*frp;\n    frame_T\t*frp2;\n    win_T\t*wp;\n    win_T\t*wp2;\n    int\t\ttemp;\n\n    if (ERROR_IF_POPUP_WINDOW)\n\treturn;\n    if (ONE_WINDOW)\t    // just one window\n    {\n\tbeep_flush();\n\treturn;\n    }\n\n#ifdef FEAT_GUI\n    need_mouse_correct = TRUE;\n#endif\n\n    /*\n     * find window to exchange with\n     */\n    if (Prenum)\n    {\n\tfrp = curwin->w_frame->fr_parent->fr_child;\n\twhile (frp != NULL && --Prenum > 0)\n\t    frp = frp->fr_next;\n    }\n    else if (curwin->w_frame->fr_next != NULL)\t/* Swap with next */\n\tfrp = curwin->w_frame->fr_next;\n    else    /* Swap last window in row/col with previous */\n\tfrp = curwin->w_frame->fr_prev;\n\n    /* We can only exchange a window with another window, not with a frame\n     * containing windows. */\n    if (frp == NULL || frp->fr_win == NULL || frp->fr_win == curwin)\n\treturn;\n    wp = frp->fr_win;\n\n/*\n * 1. remove curwin from the list. Remember after which window it was in wp2\n * 2. insert curwin before wp in the list\n * if wp != wp2\n *    3. remove wp from the list\n *    4. insert wp after wp2\n * 5. exchange the status line height and vsep width.\n */\n    wp2 = curwin->w_prev;\n    frp2 = curwin->w_frame->fr_prev;\n    if (wp->w_prev != curwin)\n    {\n\twin_remove(curwin, NULL);\n\tframe_remove(curwin->w_frame);\n\twin_append(wp->w_prev, curwin);\n\tframe_insert(frp, curwin->w_frame);\n    }\n    if (wp != wp2)\n    {\n\twin_remove(wp, NULL);\n\tframe_remove(wp->w_frame);\n\twin_append(wp2, wp);\n\tif (frp2 == NULL)\n\t    frame_insert(wp->w_frame->fr_parent->fr_child, wp->w_frame);\n\telse\n\t    frame_append(frp2, wp->w_frame);\n    }\n    temp = curwin->w_status_height;\n    curwin->w_status_height = wp->w_status_height;\n    wp->w_status_height = temp;\n    temp = curwin->w_vsep_width;\n    curwin->w_vsep_width = wp->w_vsep_width;\n    wp->w_vsep_width = temp;\n\n    /* If the windows are not in the same frame, exchange the sizes to avoid\n     * messing up the window layout.  Otherwise fix the frame sizes. */\n    if (curwin->w_frame->fr_parent != wp->w_frame->fr_parent)\n    {\n\ttemp = curwin->w_height;\n\tcurwin->w_height = wp->w_height;\n\twp->w_height = temp;\n\ttemp = curwin->w_width;\n\tcurwin->w_width = wp->w_width;\n\twp->w_width = temp;\n    }\n    else\n    {\n\tframe_fix_height(curwin);\n\tframe_fix_height(wp);\n\tframe_fix_width(curwin);\n\tframe_fix_width(wp);\n    }\n\n    (void)win_comp_pos();\t\t/* recompute window positions */\n\n    win_enter(wp, TRUE);\n    redraw_all_later(NOT_VALID);\n}\n\n/*\n * rotate windows: if upwards TRUE the second window becomes the first one\n *\t\t   if upwards FALSE the first window becomes the second one\n */\n    static void\nwin_rotate(int upwards, int count)\n{\n    win_T\t*wp1;\n    win_T\t*wp2;\n    frame_T\t*frp;\n    int\t\tn;\n\n    if (ONE_WINDOW)\t\t/* nothing to do */\n    {\n\tbeep_flush();\n\treturn;\n    }\n\n#ifdef FEAT_GUI\n    need_mouse_correct = TRUE;\n#endif\n\n    /* Check if all frames in this row/col have one window. */\n    FOR_ALL_FRAMES(frp, curwin->w_frame->fr_parent->fr_child)\n\tif (frp->fr_win == NULL)\n\t{\n\t    emsg(_(\"E443: Cannot rotate when another window is split\"));\n\t    return;\n\t}\n\n    while (count--)\n    {\n\tif (upwards)\t\t/* first window becomes last window */\n\t{\n\t    /* remove first window/frame from the list */\n\t    frp = curwin->w_frame->fr_parent->fr_child;\n\t    wp1 = frp->fr_win;\n\t    win_remove(wp1, NULL);\n\t    frame_remove(frp);\n\n\t    /* find last frame and append removed window/frame after it */\n\t    for ( ; frp->fr_next != NULL; frp = frp->fr_next)\n\t\t;\n\t    win_append(frp->fr_win, wp1);\n\t    frame_append(frp, wp1->w_frame);\n\n\t    wp2 = frp->fr_win;\t\t/* previously last window */\n\t}\n\telse\t\t\t/* last window becomes first window */\n\t{\n\t    /* find last window/frame in the list and remove it */\n\t    for (frp = curwin->w_frame; frp->fr_next != NULL;\n\t\t\t\t\t\t\t   frp = frp->fr_next)\n\t\t;\n\t    wp1 = frp->fr_win;\n\t    wp2 = wp1->w_prev;\t\t    /* will become last window */\n\t    win_remove(wp1, NULL);\n\t    frame_remove(frp);\n\n\t    /* append the removed window/frame before the first in the list */\n\t    win_append(frp->fr_parent->fr_child->fr_win->w_prev, wp1);\n\t    frame_insert(frp->fr_parent->fr_child, frp);\n\t}\n\n\t/* exchange status height and vsep width of old and new last window */\n\tn = wp2->w_status_height;\n\twp2->w_status_height = wp1->w_status_height;\n\twp1->w_status_height = n;\n\tframe_fix_height(wp1);\n\tframe_fix_height(wp2);\n\tn = wp2->w_vsep_width;\n\twp2->w_vsep_width = wp1->w_vsep_width;\n\twp1->w_vsep_width = n;\n\tframe_fix_width(wp1);\n\tframe_fix_width(wp2);\n\n\t/* recompute w_winrow and w_wincol for all windows */\n\t(void)win_comp_pos();\n    }\n\n    redraw_all_later(NOT_VALID);\n}\n\n/*\n * Move the current window to the very top/bottom/left/right of the screen.\n */\n    static void\nwin_totop(int size, int flags)\n{\n    int\t\tdir;\n    int\t\theight = curwin->w_height;\n\n    if (ONE_WINDOW)\n    {\n\tbeep_flush();\n\treturn;\n    }\n    if (check_split_disallowed() == FAIL)\n\treturn;\n\n    /* Remove the window and frame from the tree of frames. */\n    (void)winframe_remove(curwin, &dir, NULL);\n    win_remove(curwin, NULL);\n    last_status(FALSE);\t    /* may need to remove last status line */\n    (void)win_comp_pos();   /* recompute window positions */\n\n    /* Split a window on the desired side and put the window there. */\n    (void)win_split_ins(size, flags, curwin, dir);\n    if (!(flags & WSP_VERT))\n    {\n\twin_setheight(height);\n\tif (p_ea)\n\t    win_equal(curwin, TRUE, 'v');\n    }\n\n#if defined(FEAT_GUI)\n    /* When 'guioptions' includes 'L' or 'R' may have to remove or add\n     * scrollbars.  Have to update them anyway. */\n    gui_may_update_scrollbars();\n#endif\n}\n\n/*\n * Move window \"win1\" to below/right of \"win2\" and make \"win1\" the current\n * window.  Only works within the same frame!\n */\n    void\nwin_move_after(win_T *win1, win_T *win2)\n{\n    int\t\theight;\n\n    /* check if the arguments are reasonable */\n    if (win1 == win2)\n\treturn;\n\n    /* check if there is something to do */\n    if (win2->w_next != win1)\n    {\n\tif (win1->w_frame->fr_parent != win2->w_frame->fr_parent)\n\t{\n\t    iemsg(\"INTERNAL: trying to move a window into another frame\");\n\t    return;\n\t}\n\n\t/* may need move the status line/vertical separator of the last window\n\t * */\n\tif (win1 == lastwin)\n\t{\n\t    height = win1->w_prev->w_status_height;\n\t    win1->w_prev->w_status_height = win1->w_status_height;\n\t    win1->w_status_height = height;\n\t    if (win1->w_prev->w_vsep_width == 1)\n\t    {\n\t\t/* Remove the vertical separator from the last-but-one window,\n\t\t * add it to the last window.  Adjust the frame widths. */\n\t\twin1->w_prev->w_vsep_width = 0;\n\t\twin1->w_prev->w_frame->fr_width -= 1;\n\t\twin1->w_vsep_width = 1;\n\t\twin1->w_frame->fr_width += 1;\n\t    }\n\t}\n\telse if (win2 == lastwin)\n\t{\n\t    height = win1->w_status_height;\n\t    win1->w_status_height = win2->w_status_height;\n\t    win2->w_status_height = height;\n\t    if (win1->w_vsep_width == 1)\n\t    {\n\t\t/* Remove the vertical separator from win1, add it to the last\n\t\t * window, win2.  Adjust the frame widths. */\n\t\twin2->w_vsep_width = 1;\n\t\twin2->w_frame->fr_width += 1;\n\t\twin1->w_vsep_width = 0;\n\t\twin1->w_frame->fr_width -= 1;\n\t    }\n\t}\n\twin_remove(win1, NULL);\n\tframe_remove(win1->w_frame);\n\twin_append(win2, win1);\n\tframe_append(win2->w_frame, win1->w_frame);\n\n\t(void)win_comp_pos();\t/* recompute w_winrow for all windows */\n\tredraw_later(NOT_VALID);\n    }\n    win_enter(win1, FALSE);\n}\n\n/*\n * Make all windows the same height.\n * 'next_curwin' will soon be the current window, make sure it has enough\n * rows.\n */\n    void\nwin_equal(\n    win_T\t*next_curwin,\t/* pointer to current window to be or NULL */\n    int\t\tcurrent,\t/* do only frame with current window */\n    int\t\tdir)\t\t/* 'v' for vertically, 'h' for horizontally,\n\t\t\t\t   'b' for both, 0 for using p_ead */\n{\n    if (dir == 0)\n\tdir = *p_ead;\n    win_equal_rec(next_curwin == NULL ? curwin : next_curwin, current,\n\t\t      topframe, dir, 0, tabline_height(),\n\t\t\t\t\t   (int)Columns, topframe->fr_height);\n}\n\n/*\n * Set a frame to a new position and height, spreading the available room\n * equally over contained frames.\n * The window \"next_curwin\" (if not NULL) should at least get the size from\n * 'winheight' and 'winwidth' if possible.\n */\n    static void\nwin_equal_rec(\n    win_T\t*next_curwin,\t/* pointer to current window to be or NULL */\n    int\t\tcurrent,\t/* do only frame with current window */\n    frame_T\t*topfr,\t\t/* frame to set size off */\n    int\t\tdir,\t\t/* 'v', 'h' or 'b', see win_equal() */\n    int\t\tcol,\t\t/* horizontal position for frame */\n    int\t\trow,\t\t/* vertical position for frame */\n    int\t\twidth,\t\t/* new width of frame */\n    int\t\theight)\t\t/* new height of frame */\n{\n    int\t\tn, m;\n    int\t\textra_sep = 0;\n    int\t\twincount, totwincount = 0;\n    frame_T\t*fr;\n    int\t\tnext_curwin_size = 0;\n    int\t\troom = 0;\n    int\t\tnew_size;\n    int\t\thas_next_curwin = 0;\n    int\t\thnc;\n\n    if (topfr->fr_layout == FR_LEAF)\n    {\n\t/* Set the width/height of this frame.\n\t * Redraw when size or position changes */\n\tif (topfr->fr_height != height || topfr->fr_win->w_winrow != row\n\t\t|| topfr->fr_width != width || topfr->fr_win->w_wincol != col\n\t   )\n\t{\n\t    topfr->fr_win->w_winrow = row;\n\t    frame_new_height(topfr, height, FALSE, FALSE);\n\t    topfr->fr_win->w_wincol = col;\n\t    frame_new_width(topfr, width, FALSE, FALSE);\n\t    redraw_all_later(NOT_VALID);\n\t}\n    }\n    else if (topfr->fr_layout == FR_ROW)\n    {\n\ttopfr->fr_width = width;\n\ttopfr->fr_height = height;\n\n\tif (dir != 'v')\t\t\t/* equalize frame widths */\n\t{\n\t    /* Compute the maximum number of windows horizontally in this\n\t     * frame. */\n\t    n = frame_minwidth(topfr, NOWIN);\n\t    /* add one for the rightmost window, it doesn't have a separator */\n\t    if (col + width == Columns)\n\t\textra_sep = 1;\n\t    else\n\t\textra_sep = 0;\n\t    totwincount = (n + extra_sep) / (p_wmw + 1);\n\t    has_next_curwin = frame_has_win(topfr, next_curwin);\n\n\t    /*\n\t     * Compute width for \"next_curwin\" window and room available for\n\t     * other windows.\n\t     * \"m\" is the minimal width when counting p_wiw for \"next_curwin\".\n\t     */\n\t    m = frame_minwidth(topfr, next_curwin);\n\t    room = width - m;\n\t    if (room < 0)\n\t    {\n\t\tnext_curwin_size = p_wiw + room;\n\t\troom = 0;\n\t    }\n\t    else\n\t    {\n\t\tnext_curwin_size = -1;\n\t\tFOR_ALL_FRAMES(fr, topfr->fr_child)\n\t\t{\n\t\t    /* If 'winfixwidth' set keep the window width if\n\t\t     * possible.\n\t\t     * Watch out for this window being the next_curwin. */\n\t\t    if (frame_fixed_width(fr))\n\t\t    {\n\t\t\tn = frame_minwidth(fr, NOWIN);\n\t\t\tnew_size = fr->fr_width;\n\t\t\tif (frame_has_win(fr, next_curwin))\n\t\t\t{\n\t\t\t    room += p_wiw - p_wmw;\n\t\t\t    next_curwin_size = 0;\n\t\t\t    if (new_size < p_wiw)\n\t\t\t\tnew_size = p_wiw;\n\t\t\t}\n\t\t\telse\n\t\t\t    /* These windows don't use up room. */\n\t\t\t    totwincount -= (n + (fr->fr_next == NULL\n\t\t\t\t\t      ? extra_sep : 0)) / (p_wmw + 1);\n\t\t\troom -= new_size - n;\n\t\t\tif (room < 0)\n\t\t\t{\n\t\t\t    new_size += room;\n\t\t\t    room = 0;\n\t\t\t}\n\t\t\tfr->fr_newwidth = new_size;\n\t\t    }\n\t\t}\n\t\tif (next_curwin_size == -1)\n\t\t{\n\t\t    if (!has_next_curwin)\n\t\t\tnext_curwin_size = 0;\n\t\t    else if (totwincount > 1\n\t\t\t    && (room + (totwincount - 2))\n\t\t\t\t\t\t  / (totwincount - 1) > p_wiw)\n\t\t    {\n\t\t\t/* Can make all windows wider than 'winwidth', spread\n\t\t\t * the room equally. */\n\t\t\tnext_curwin_size = (room + p_wiw\n\t\t\t\t\t    + (totwincount - 1) * p_wmw\n\t\t\t\t\t    + (totwincount - 1)) / totwincount;\n\t\t\troom -= next_curwin_size - p_wiw;\n\t\t    }\n\t\t    else\n\t\t\tnext_curwin_size = p_wiw;\n\t\t}\n\t    }\n\n\t    if (has_next_curwin)\n\t\t--totwincount;\t\t/* don't count curwin */\n\t}\n\n\tFOR_ALL_FRAMES(fr, topfr->fr_child)\n\t{\n\t    wincount = 1;\n\t    if (fr->fr_next == NULL)\n\t\t/* last frame gets all that remains (avoid roundoff error) */\n\t\tnew_size = width;\n\t    else if (dir == 'v')\n\t\tnew_size = fr->fr_width;\n\t    else if (frame_fixed_width(fr))\n\t    {\n\t\tnew_size = fr->fr_newwidth;\n\t\twincount = 0;\t    /* doesn't count as a sizeable window */\n\t    }\n\t    else\n\t    {\n\t\t/* Compute the maximum number of windows horiz. in \"fr\". */\n\t\tn = frame_minwidth(fr, NOWIN);\n\t\twincount = (n + (fr->fr_next == NULL ? extra_sep : 0))\n\t\t\t\t\t\t\t\t/ (p_wmw + 1);\n\t\tm = frame_minwidth(fr, next_curwin);\n\t\tif (has_next_curwin)\n\t\t    hnc = frame_has_win(fr, next_curwin);\n\t\telse\n\t\t    hnc = FALSE;\n\t\tif (hnc)\t    /* don't count next_curwin */\n\t\t    --wincount;\n\t\tif (totwincount == 0)\n\t\t    new_size = room;\n\t\telse\n\t\t    new_size = (wincount * room + ((unsigned)totwincount >> 1))\n\t\t\t\t\t\t\t\t/ totwincount;\n\t\tif (hnc)\t    /* add next_curwin size */\n\t\t{\n\t\t    next_curwin_size -= p_wiw - (m - n);\n\t\t    new_size += next_curwin_size;\n\t\t    room -= new_size - next_curwin_size;\n\t\t}\n\t\telse\n\t\t    room -= new_size;\n\t\tnew_size += n;\n\t    }\n\n\t    /* Skip frame that is full width when splitting or closing a\n\t     * window, unless equalizing all frames. */\n\t    if (!current || dir != 'v' || topfr->fr_parent != NULL\n\t\t    || (new_size != fr->fr_width)\n\t\t    || frame_has_win(fr, next_curwin))\n\t\twin_equal_rec(next_curwin, current, fr, dir, col, row,\n\t\t\t\t\t\t\t    new_size, height);\n\t    col += new_size;\n\t    width -= new_size;\n\t    totwincount -= wincount;\n\t}\n    }\n    else /* topfr->fr_layout == FR_COL */\n    {\n\ttopfr->fr_width = width;\n\ttopfr->fr_height = height;\n\n\tif (dir != 'h')\t\t\t/* equalize frame heights */\n\t{\n\t    /* Compute maximum number of windows vertically in this frame. */\n\t    n = frame_minheight(topfr, NOWIN);\n\t    /* add one for the bottom window if it doesn't have a statusline */\n\t    if (row + height == cmdline_row && p_ls == 0)\n\t\textra_sep = 1;\n\t    else\n\t\textra_sep = 0;\n\t    totwincount = (n + extra_sep) / (p_wmh + 1);\n\t    has_next_curwin = frame_has_win(topfr, next_curwin);\n\n\t    /*\n\t     * Compute height for \"next_curwin\" window and room available for\n\t     * other windows.\n\t     * \"m\" is the minimal height when counting p_wh for \"next_curwin\".\n\t     */\n\t    m = frame_minheight(topfr, next_curwin);\n\t    room = height - m;\n\t    if (room < 0)\n\t    {\n\t\t/* The room is less then 'winheight', use all space for the\n\t\t * current window. */\n\t\tnext_curwin_size = p_wh + room;\n\t\troom = 0;\n\t    }\n\t    else\n\t    {\n\t\tnext_curwin_size = -1;\n\t\tFOR_ALL_FRAMES(fr, topfr->fr_child)\n\t\t{\n\t\t    /* If 'winfixheight' set keep the window height if\n\t\t     * possible.\n\t\t     * Watch out for this window being the next_curwin. */\n\t\t    if (frame_fixed_height(fr))\n\t\t    {\n\t\t\tn = frame_minheight(fr, NOWIN);\n\t\t\tnew_size = fr->fr_height;\n\t\t\tif (frame_has_win(fr, next_curwin))\n\t\t\t{\n\t\t\t    room += p_wh - p_wmh;\n\t\t\t    next_curwin_size = 0;\n\t\t\t    if (new_size < p_wh)\n\t\t\t\tnew_size = p_wh;\n\t\t\t}\n\t\t\telse\n\t\t\t    /* These windows don't use up room. */\n\t\t\t    totwincount -= (n + (fr->fr_next == NULL\n\t\t\t\t\t      ? extra_sep : 0)) / (p_wmh + 1);\n\t\t\troom -= new_size - n;\n\t\t\tif (room < 0)\n\t\t\t{\n\t\t\t    new_size += room;\n\t\t\t    room = 0;\n\t\t\t}\n\t\t\tfr->fr_newheight = new_size;\n\t\t    }\n\t\t}\n\t\tif (next_curwin_size == -1)\n\t\t{\n\t\t    if (!has_next_curwin)\n\t\t\tnext_curwin_size = 0;\n\t\t    else if (totwincount > 1\n\t\t\t    && (room + (totwincount - 2))\n\t\t\t\t\t\t   / (totwincount - 1) > p_wh)\n\t\t    {\n\t\t\t/* can make all windows higher than 'winheight',\n\t\t\t * spread the room equally. */\n\t\t\tnext_curwin_size = (room + p_wh\n\t\t\t\t\t   + (totwincount - 1) * p_wmh\n\t\t\t\t\t   + (totwincount - 1)) / totwincount;\n\t\t\troom -= next_curwin_size - p_wh;\n\t\t    }\n\t\t    else\n\t\t\tnext_curwin_size = p_wh;\n\t\t}\n\t    }\n\n\t    if (has_next_curwin)\n\t\t--totwincount;\t\t/* don't count curwin */\n\t}\n\n\tFOR_ALL_FRAMES(fr, topfr->fr_child)\n\t{\n\t    wincount = 1;\n\t    if (fr->fr_next == NULL)\n\t\t/* last frame gets all that remains (avoid roundoff error) */\n\t\tnew_size = height;\n\t    else if (dir == 'h')\n\t\tnew_size = fr->fr_height;\n\t    else if (frame_fixed_height(fr))\n\t    {\n\t\tnew_size = fr->fr_newheight;\n\t\twincount = 0;\t    /* doesn't count as a sizeable window */\n\t    }\n\t    else\n\t    {\n\t\t/* Compute the maximum number of windows vert. in \"fr\". */\n\t\tn = frame_minheight(fr, NOWIN);\n\t\twincount = (n + (fr->fr_next == NULL ? extra_sep : 0))\n\t\t\t\t\t\t\t\t/ (p_wmh + 1);\n\t\tm = frame_minheight(fr, next_curwin);\n\t\tif (has_next_curwin)\n\t\t    hnc = frame_has_win(fr, next_curwin);\n\t\telse\n\t\t    hnc = FALSE;\n\t\tif (hnc)\t    /* don't count next_curwin */\n\t\t    --wincount;\n\t\tif (totwincount == 0)\n\t\t    new_size = room;\n\t\telse\n\t\t    new_size = (wincount * room + ((unsigned)totwincount >> 1))\n\t\t\t\t\t\t\t\t/ totwincount;\n\t\tif (hnc)\t    /* add next_curwin size */\n\t\t{\n\t\t    next_curwin_size -= p_wh - (m - n);\n\t\t    new_size += next_curwin_size;\n\t\t    room -= new_size - next_curwin_size;\n\t\t}\n\t\telse\n\t\t    room -= new_size;\n\t\tnew_size += n;\n\t    }\n\t    /* Skip frame that is full width when splitting or closing a\n\t     * window, unless equalizing all frames. */\n\t    if (!current || dir != 'h' || topfr->fr_parent != NULL\n\t\t    || (new_size != fr->fr_height)\n\t\t    || frame_has_win(fr, next_curwin))\n\t\twin_equal_rec(next_curwin, current, fr, dir, col, row,\n\t\t\t\t\t\t\t     width, new_size);\n\t    row += new_size;\n\t    height -= new_size;\n\t    totwincount -= wincount;\n\t}\n    }\n}\n\n#ifdef FEAT_JOB_CHANNEL\n    static void\nleaving_window(win_T *win)\n{\n    // Only matters for a prompt window.\n    if (!bt_prompt(win->w_buffer))\n\treturn;\n\n    // When leaving a prompt window stop Insert mode and perhaps restart\n    // it when entering that window again.\n    win->w_buffer->b_prompt_insert = restart_edit;\n    if (restart_edit != 0 && mode_displayed)\n\tclear_cmdline = TRUE;\t\t/* unshow mode later */\n    restart_edit = NUL;\n\n    // When leaving the window (or closing the window) was done from a\n    // callback we need to break out of the Insert mode loop and restart Insert\n    // mode when entering the window again.\n    if (State & INSERT)\n    {\n\tstop_insert_mode = TRUE;\n\tif (win->w_buffer->b_prompt_insert == NUL)\n\t    win->w_buffer->b_prompt_insert = 'A';\n    }\n}\n\n    static void\nentering_window(win_T *win)\n{\n    // Only matters for a prompt window.\n    if (!bt_prompt(win->w_buffer))\n\treturn;\n\n    // When switching to a prompt buffer that was in Insert mode, don't stop\n    // Insert mode, it may have been set in leaving_window().\n    if (win->w_buffer->b_prompt_insert != NUL)\n\tstop_insert_mode = FALSE;\n\n    // When entering the prompt window restart Insert mode if we were in Insert\n    // mode when we left it.\n    restart_edit = win->w_buffer->b_prompt_insert;\n}\n#endif\n\n/*\n * Close all windows for buffer \"buf\".\n */\n    void\nclose_windows(\n    buf_T\t*buf,\n    int\t\tkeep_curwin)\t    /* don't close \"curwin\" */\n{\n    win_T\t*wp;\n    tabpage_T   *tp, *nexttp;\n    int\t\th = tabline_height();\n    int\t\tcount = tabpage_index(NULL);\n\n    ++RedrawingDisabled;\n\n    for (wp = firstwin; wp != NULL && !ONE_WINDOW; )\n    {\n\tif (wp->w_buffer == buf && (!keep_curwin || wp != curwin)\n\t\t&& !(wp->w_closing || wp->w_buffer->b_locked > 0))\n\t{\n\t    if (win_close(wp, FALSE) == FAIL)\n\t\t/* If closing the window fails give up, to avoid looping\n\t\t * forever. */\n\t\tbreak;\n\n\t    /* Start all over, autocommands may change the window layout. */\n\t    wp = firstwin;\n\t}\n\telse\n\t    wp = wp->w_next;\n    }\n\n    /* Also check windows in other tab pages. */\n    for (tp = first_tabpage; tp != NULL; tp = nexttp)\n    {\n\tnexttp = tp->tp_next;\n\tif (tp != curtab)\n\t    for (wp = tp->tp_firstwin; wp != NULL; wp = wp->w_next)\n\t\tif (wp->w_buffer == buf\n\t\t    && !(wp->w_closing || wp->w_buffer->b_locked > 0))\n\t\t{\n\t\t    win_close_othertab(wp, FALSE, tp);\n\n\t\t    /* Start all over, the tab page may be closed and\n\t\t     * autocommands may change the window layout. */\n\t\t    nexttp = first_tabpage;\n\t\t    break;\n\t\t}\n    }\n\n    --RedrawingDisabled;\n\n    if (count != tabpage_index(NULL))\n\tapply_autocmds(EVENT_TABCLOSED, NULL, NULL, FALSE, curbuf);\n\n    redraw_tabline = TRUE;\n    if (h != tabline_height())\n\tshell_new_rows();\n}\n\n/*\n * Return TRUE if the current window is the only window that exists (ignoring\n * \"aucmd_win\").\n * Returns FALSE if there is a window, possibly in another tab page.\n */\n    static int\nlast_window(void)\n{\n    return (one_window() && first_tabpage->tp_next == NULL);\n}\n\n/*\n * Return TRUE if there is only one window other than \"aucmd_win\" in the\n * current tab page.\n */\n    int\none_window(void)\n{\n    win_T\t*wp;\n    int\t\tseen_one = FALSE;\n\n    FOR_ALL_WINDOWS(wp)\n    {\n\tif (wp != aucmd_win)\n\t{\n\t    if (seen_one)\n\t\treturn FALSE;\n\t    seen_one = TRUE;\n\t}\n    }\n    return TRUE;\n}\n\n/*\n * Close the possibly last window in a tab page.\n * Returns TRUE when the window was closed already.\n */\n    static int\nclose_last_window_tabpage(\n    win_T\t*win,\n    int\t\tfree_buf,\n    tabpage_T   *prev_curtab)\n{\n    if (ONE_WINDOW)\n    {\n\tbuf_T\t*old_curbuf = curbuf;\n\n\t/*\n\t * Closing the last window in a tab page.  First go to another tab\n\t * page and then close the window and the tab page.  This avoids that\n\t * curwin and curtab are invalid while we are freeing memory, they may\n\t * be used in GUI events.\n\t * Don't trigger autocommands yet, they may use wrong values, so do\n\t * that below.\n\t */\n\tgoto_tabpage_tp(alt_tabpage(), FALSE, TRUE);\n\tredraw_tabline = TRUE;\n\n\t/* Safety check: Autocommands may have closed the window when jumping\n\t * to the other tab page. */\n\tif (valid_tabpage(prev_curtab) && prev_curtab->tp_firstwin == win)\n\t{\n\t    int\t    h = tabline_height();\n\n\t    win_close_othertab(win, free_buf, prev_curtab);\n\t    if (h != tabline_height())\n\t\tshell_new_rows();\n\t}\n#ifdef FEAT_JOB_CHANNEL\n\tentering_window(curwin);\n#endif\n\t/* Since goto_tabpage_tp above did not trigger *Enter autocommands, do\n\t * that now. */\n\tapply_autocmds(EVENT_TABCLOSED, NULL, NULL, FALSE, curbuf);\n\tapply_autocmds(EVENT_WINENTER, NULL, NULL, FALSE, curbuf);\n\tapply_autocmds(EVENT_TABENTER, NULL, NULL, FALSE, curbuf);\n\tif (old_curbuf != curbuf)\n\t    apply_autocmds(EVENT_BUFENTER, NULL, NULL, FALSE, curbuf);\n\treturn TRUE;\n    }\n    return FALSE;\n}\n\n/*\n * Close the buffer of \"win\" and unload it if \"action\" is DOBUF_UNLOAD.\n * \"action\" can also be zero (do nothing) or DOBUF_WIPE.\n * \"abort_if_last\" is passed to close_buffer(): abort closing if all other\n * windows are closed.\n */\n    static void\nwin_close_buffer(win_T *win, int action, int abort_if_last)\n{\n#ifdef FEAT_SYN_HL\n    // Free independent synblock before the buffer is freed.\n    if (win->w_buffer != NULL)\n\treset_synblock(win);\n#endif\n\n#ifdef FEAT_QUICKFIX\n    // When the quickfix/location list window is closed, unlist the buffer.\n    if (win->w_buffer != NULL && bt_quickfix(win->w_buffer))\n\twin->w_buffer->b_p_bl = FALSE;\n#endif\n\n    // Close the link to the buffer.\n    if (win->w_buffer != NULL)\n    {\n\tbufref_T    bufref;\n\n\tset_bufref(&bufref, curbuf);\n\twin->w_closing = TRUE;\n\tclose_buffer(win, win->w_buffer, action, abort_if_last);\n\tif (win_valid_any_tab(win))\n\t    win->w_closing = FALSE;\n\t// Make sure curbuf is valid. It can become invalid if 'bufhidden' is\n\t// \"wipe\".\n\tif (!bufref_valid(&bufref))\n\t    curbuf = firstbuf;\n    }\n}\n\n/*\n * Close window \"win\".  Only works for the current tab page.\n * If \"free_buf\" is TRUE related buffer may be unloaded.\n *\n * Called by :quit, :close, :xit, :wq and findtag().\n * Returns FAIL when the window was not closed.\n */\n    int\nwin_close(win_T *win, int free_buf)\n{\n    win_T\t*wp;\n    int\t\tother_buffer = FALSE;\n    int\t\tclose_curwin = FALSE;\n    int\t\tdir;\n    int\t\thelp_window = FALSE;\n    tabpage_T   *prev_curtab = curtab;\n    frame_T\t*win_frame = win->w_frame->fr_parent;\n\n    if (ERROR_IF_POPUP_WINDOW)\n\treturn FAIL;\n\n    if (last_window())\n    {\n\temsg(_(\"E444: Cannot close last window\"));\n\treturn FAIL;\n    }\n\n    if (win->w_closing || (win->w_buffer != NULL\n\t\t\t\t\t       && win->w_buffer->b_locked > 0))\n\treturn FAIL; /* window is already being closed */\n    if (win_unlisted(win))\n    {\n\temsg(_(\"E813: Cannot close autocmd or popup window\"));\n\treturn FAIL;\n    }\n    if ((firstwin == aucmd_win || lastwin == aucmd_win) && one_window())\n    {\n\temsg(_(\"E814: Cannot close window, only autocmd window would remain\"));\n\treturn FAIL;\n    }\n\n    /* When closing the last window in a tab page first go to another tab page\n     * and then close the window and the tab page to avoid that curwin and\n     * curtab are invalid while we are freeing memory. */\n    if (close_last_window_tabpage(win, free_buf, prev_curtab))\n      return FAIL;\n\n    /* When closing the help window, try restoring a snapshot after closing\n     * the window.  Otherwise clear the snapshot, it's now invalid. */\n    if (bt_help(win->w_buffer))\n\thelp_window = TRUE;\n    else\n\tclear_snapshot(curtab, SNAP_HELP_IDX);\n\n    if (win == curwin)\n    {\n#ifdef FEAT_JOB_CHANNEL\n\tleaving_window(curwin);\n#endif\n\t/*\n\t * Guess which window is going to be the new current window.\n\t * This may change because of the autocommands (sigh).\n\t */\n\twp = frame2win(win_altframe(win, NULL));\n\n\t/*\n\t * Be careful: If autocommands delete the window or cause this window\n\t * to be the last one left, return now.\n\t */\n\tif (wp->w_buffer != curbuf)\n\t{\n\t    other_buffer = TRUE;\n\t    win->w_closing = TRUE;\n\t    apply_autocmds(EVENT_BUFLEAVE, NULL, NULL, FALSE, curbuf);\n\t    if (!win_valid(win))\n\t\treturn FAIL;\n\t    win->w_closing = FALSE;\n\t    if (last_window())\n\t\treturn FAIL;\n\t}\n\twin->w_closing = TRUE;\n\tapply_autocmds(EVENT_WINLEAVE, NULL, NULL, FALSE, curbuf);\n\tif (!win_valid(win))\n\t    return FAIL;\n\twin->w_closing = FALSE;\n\tif (last_window())\n\t    return FAIL;\n#ifdef FEAT_EVAL\n\t/* autocmds may abort script processing */\n\tif (aborting())\n\t    return FAIL;\n#endif\n    }\n\n#ifdef FEAT_GUI\n    // Avoid trouble with scrollbars that are going to be deleted in\n    // win_free().\n    if (gui.in_use)\n\tout_flush();\n#endif\n\n#ifdef FEAT_TEXT_PROP\n    if (popup_win_closed(win) && !win_valid(win))\n\treturn FAIL;\n#endif\n    win_close_buffer(win, free_buf ? DOBUF_UNLOAD : 0, TRUE);\n\n    if (only_one_window() && win_valid(win) && win->w_buffer == NULL\n\t    && (last_window() || curtab != prev_curtab\n\t\t|| close_last_window_tabpage(win, free_buf, prev_curtab)))\n    {\n\t/* Autocommands have closed all windows, quit now.  Restore\n\t * curwin->w_buffer, otherwise writing viminfo may fail. */\n\tif (curwin->w_buffer == NULL)\n\t    curwin->w_buffer = curbuf;\n\tgetout(0);\n    }\n\n    /* Autocommands may have moved to another tab page. */\n    if (curtab != prev_curtab && win_valid_any_tab(win)\n\t\t\t\t\t\t      && win->w_buffer == NULL)\n    {\n\t/* Need to close the window anyway, since the buffer is NULL. */\n\twin_close_othertab(win, FALSE, prev_curtab);\n\treturn FAIL;\n    }\n\n    /* Autocommands may have closed the window already or closed the only\n     * other window. */\n    if (!win_valid(win) || last_window()\n\t    || close_last_window_tabpage(win, free_buf, prev_curtab))\n\treturn FAIL;\n\n    // Now we are really going to close the window.  Disallow any autocommand\n    // to split a window to avoid trouble.\n    ++split_disallowed;\n\n    /* Free the memory used for the window and get the window that received\n     * the screen space. */\n    wp = win_free_mem(win, &dir, NULL);\n\n    /* Make sure curwin isn't invalid.  It can cause severe trouble when\n     * printing an error message.  For win_equal() curbuf needs to be valid\n     * too. */\n    if (win == curwin)\n    {\n\tcurwin = wp;\n#ifdef FEAT_QUICKFIX\n\tif (wp->w_p_pvw || bt_quickfix(wp->w_buffer))\n\t{\n\t    /*\n\t     * If the cursor goes to the preview or the quickfix window, try\n\t     * finding another window to go to.\n\t     */\n\t    for (;;)\n\t    {\n\t\tif (wp->w_next == NULL)\n\t\t    wp = firstwin;\n\t\telse\n\t\t    wp = wp->w_next;\n\t\tif (wp == curwin)\n\t\t    break;\n\t\tif (!wp->w_p_pvw && !bt_quickfix(wp->w_buffer))\n\t\t{\n\t\t    curwin = wp;\n\t\t    break;\n\t\t}\n\t    }\n\t}\n#endif\n\tcurbuf = curwin->w_buffer;\n\tclose_curwin = TRUE;\n\n\t/* The cursor position may be invalid if the buffer changed after last\n\t * using the window. */\n\tcheck_cursor();\n    }\n    if (p_ea && (*p_ead == 'b' || *p_ead == dir))\n\t/* If the frame of the closed window contains the new current window,\n\t * only resize that frame.  Otherwise resize all windows. */\n\twin_equal(curwin, curwin->w_frame->fr_parent == win_frame, dir);\n    else\n\twin_comp_pos();\n    if (close_curwin)\n    {\n\twin_enter_ext(wp, FALSE, TRUE, FALSE, TRUE, TRUE);\n\tif (other_buffer)\n\t    /* careful: after this wp and win may be invalid! */\n\t    apply_autocmds(EVENT_BUFENTER, NULL, NULL, FALSE, curbuf);\n    }\n\n    --split_disallowed;\n\n    /*\n     * If last window has a status line now and we don't want one,\n     * remove the status line.\n     */\n    last_status(FALSE);\n\n    /* After closing the help window, try restoring the window layout from\n     * before it was opened. */\n    if (help_window)\n\trestore_snapshot(SNAP_HELP_IDX, close_curwin);\n\n#if defined(FEAT_GUI)\n    /* When 'guioptions' includes 'L' or 'R' may have to remove scrollbars. */\n    if (gui.in_use && !win_hasvertsplit())\n\tgui_init_which_components(NULL);\n#endif\n\n    redraw_all_later(NOT_VALID);\n    return OK;\n}\n\n/*\n * Close window \"win\" in tab page \"tp\", which is not the current tab page.\n * This may be the last window in that tab page and result in closing the tab,\n * thus \"tp\" may become invalid!\n * Caller must check if buffer is hidden and whether the tabline needs to be\n * updated.\n */\n    void\nwin_close_othertab(win_T *win, int free_buf, tabpage_T *tp)\n{\n    win_T\t*wp;\n    int\t\tdir;\n    tabpage_T   *ptp = NULL;\n    int\t\tfree_tp = FALSE;\n\n    /* Get here with win->w_buffer == NULL when win_close() detects the tab\n     * page changed. */\n    if (win->w_closing || (win->w_buffer != NULL\n\t\t\t\t\t       && win->w_buffer->b_locked > 0))\n\treturn; /* window is already being closed */\n\n    if (win->w_buffer != NULL)\n\t/* Close the link to the buffer. */\n\tclose_buffer(win, win->w_buffer, free_buf ? DOBUF_UNLOAD : 0, FALSE);\n\n    /* Careful: Autocommands may have closed the tab page or made it the\n     * current tab page.  */\n    for (ptp = first_tabpage; ptp != NULL && ptp != tp; ptp = ptp->tp_next)\n\t;\n    if (ptp == NULL || tp == curtab)\n\treturn;\n\n    /* Autocommands may have closed the window already. */\n    for (wp = tp->tp_firstwin; wp != NULL && wp != win; wp = wp->w_next)\n\t;\n    if (wp == NULL)\n\treturn;\n\n    /* When closing the last window in a tab page remove the tab page. */\n    if (tp->tp_firstwin == tp->tp_lastwin)\n    {\n\tif (tp == first_tabpage)\n\t    first_tabpage = tp->tp_next;\n\telse\n\t{\n\t    for (ptp = first_tabpage; ptp != NULL && ptp->tp_next != tp;\n\t\t\t\t\t\t\t   ptp = ptp->tp_next)\n\t\t;\n\t    if (ptp == NULL)\n\t    {\n\t\tinternal_error(\"win_close_othertab()\");\n\t\treturn;\n\t    }\n\t    ptp->tp_next = tp->tp_next;\n\t}\n\tfree_tp = TRUE;\n    }\n\n    /* Free the memory used for the window. */\n    win_free_mem(win, &dir, tp);\n\n    if (free_tp)\n\tfree_tabpage(tp);\n}\n\n/*\n * Free the memory used for a window.\n * Returns a pointer to the window that got the freed up space.\n */\n    static win_T *\nwin_free_mem(\n    win_T\t*win,\n    int\t\t*dirp,\t\t/* set to 'v' or 'h' for direction if 'ea' */\n    tabpage_T\t*tp)\t\t/* tab page \"win\" is in, NULL for current */\n{\n    frame_T\t*frp;\n    win_T\t*wp;\n\n    /* Remove the window and its frame from the tree of frames. */\n    frp = win->w_frame;\n    wp = winframe_remove(win, dirp, tp);\n    vim_free(frp);\n    win_free(win, tp);\n\n    /* When deleting the current window of another tab page select a new\n     * current window. */\n    if (tp != NULL && win == tp->tp_curwin)\n\ttp->tp_curwin = wp;\n\n    return wp;\n}\n\n#if defined(EXITFREE) || defined(PROTO)\n    void\nwin_free_all(void)\n{\n    int\t\tdummy;\n\n    while (first_tabpage->tp_next != NULL)\n\ttabpage_close(TRUE);\n\n    if (aucmd_win != NULL)\n    {\n\t(void)win_free_mem(aucmd_win, &dummy, NULL);\n\taucmd_win = NULL;\n    }\n# ifdef FEAT_TEXT_PROP\n    close_all_popups();\n# endif\n\n    while (firstwin != NULL)\n\t(void)win_free_mem(firstwin, &dummy, NULL);\n\n    /* No window should be used after this. Set curwin to NULL to crash\n     * instead of using freed memory. */\n    curwin = NULL;\n}\n#endif\n\n/*\n * Remove a window and its frame from the tree of frames.\n * Returns a pointer to the window that got the freed up space.\n */\n    win_T *\nwinframe_remove(\n    win_T\t*win,\n    int\t\t*dirp UNUSED,\t/* set to 'v' or 'h' for direction if 'ea' */\n    tabpage_T\t*tp)\t\t/* tab page \"win\" is in, NULL for current */\n{\n    frame_T\t*frp, *frp2, *frp3;\n    frame_T\t*frp_close = win->w_frame;\n    win_T\t*wp;\n\n    /*\n     * If there is only one window there is nothing to remove.\n     */\n    if (tp == NULL ? ONE_WINDOW : tp->tp_firstwin == tp->tp_lastwin)\n\treturn NULL;\n\n    /*\n     * Remove the window from its frame.\n     */\n    frp2 = win_altframe(win, tp);\n    wp = frame2win(frp2);\n\n    /* Remove this frame from the list of frames. */\n    frame_remove(frp_close);\n\n    if (frp_close->fr_parent->fr_layout == FR_COL)\n    {\n\t/* When 'winfixheight' is set, try to find another frame in the column\n\t * (as close to the closed frame as possible) to distribute the height\n\t * to. */\n\tif (frp2->fr_win != NULL && frp2->fr_win->w_p_wfh)\n\t{\n\t    frp = frp_close->fr_prev;\n\t    frp3 = frp_close->fr_next;\n\t    while (frp != NULL || frp3 != NULL)\n\t    {\n\t\tif (frp != NULL)\n\t\t{\n\t\t    if (!frame_fixed_height(frp))\n\t\t    {\n\t\t\tfrp2 = frp;\n\t\t\twp = frame2win(frp2);\n\t\t\tbreak;\n\t\t    }\n\t\t    frp = frp->fr_prev;\n\t\t}\n\t\tif (frp3 != NULL)\n\t\t{\n\t\t    if (frp3->fr_win != NULL && !frp3->fr_win->w_p_wfh)\n\t\t    {\n\t\t\tfrp2 = frp3;\n\t\t\twp = frp3->fr_win;\n\t\t\tbreak;\n\t\t    }\n\t\t    frp3 = frp3->fr_next;\n\t\t}\n\t    }\n\t}\n\tframe_new_height(frp2, frp2->fr_height + frp_close->fr_height,\n\t\t\t    frp2 == frp_close->fr_next ? TRUE : FALSE, FALSE);\n\t*dirp = 'v';\n    }\n    else\n    {\n\t/* When 'winfixwidth' is set, try to find another frame in the column\n\t * (as close to the closed frame as possible) to distribute the width\n\t * to. */\n\tif (frp2->fr_win != NULL && frp2->fr_win->w_p_wfw)\n\t{\n\t    frp = frp_close->fr_prev;\n\t    frp3 = frp_close->fr_next;\n\t    while (frp != NULL || frp3 != NULL)\n\t    {\n\t\tif (frp != NULL)\n\t\t{\n\t\t    if (!frame_fixed_width(frp))\n\t\t    {\n\t\t\tfrp2 = frp;\n\t\t\twp = frame2win(frp2);\n\t\t\tbreak;\n\t\t    }\n\t\t    frp = frp->fr_prev;\n\t\t}\n\t\tif (frp3 != NULL)\n\t\t{\n\t\t    if (frp3->fr_win != NULL && !frp3->fr_win->w_p_wfw)\n\t\t    {\n\t\t\tfrp2 = frp3;\n\t\t\twp = frp3->fr_win;\n\t\t\tbreak;\n\t\t    }\n\t\t    frp3 = frp3->fr_next;\n\t\t}\n\t    }\n\t}\n\tframe_new_width(frp2, frp2->fr_width + frp_close->fr_width,\n\t\t\t    frp2 == frp_close->fr_next ? TRUE : FALSE, FALSE);\n\t*dirp = 'h';\n    }\n\n    /* If rows/columns go to a window below/right its positions need to be\n     * updated.  Can only be done after the sizes have been updated. */\n    if (frp2 == frp_close->fr_next)\n    {\n\tint row = win->w_winrow;\n\tint col = win->w_wincol;\n\n\tframe_comp_pos(frp2, &row, &col);\n    }\n\n    if (frp2->fr_next == NULL && frp2->fr_prev == NULL)\n    {\n\t/* There is no other frame in this list, move its info to the parent\n\t * and remove it. */\n\tfrp2->fr_parent->fr_layout = frp2->fr_layout;\n\tfrp2->fr_parent->fr_child = frp2->fr_child;\n\tFOR_ALL_FRAMES(frp, frp2->fr_child)\n\t    frp->fr_parent = frp2->fr_parent;\n\tfrp2->fr_parent->fr_win = frp2->fr_win;\n\tif (frp2->fr_win != NULL)\n\t    frp2->fr_win->w_frame = frp2->fr_parent;\n\tfrp = frp2->fr_parent;\n\tif (topframe->fr_child == frp2)\n\t    topframe->fr_child = frp;\n\tvim_free(frp2);\n\n\tfrp2 = frp->fr_parent;\n\tif (frp2 != NULL && frp2->fr_layout == frp->fr_layout)\n\t{\n\t    /* The frame above the parent has the same layout, have to merge\n\t     * the frames into this list. */\n\t    if (frp2->fr_child == frp)\n\t\tfrp2->fr_child = frp->fr_child;\n\t    frp->fr_child->fr_prev = frp->fr_prev;\n\t    if (frp->fr_prev != NULL)\n\t\tfrp->fr_prev->fr_next = frp->fr_child;\n\t    for (frp3 = frp->fr_child; ; frp3 = frp3->fr_next)\n\t    {\n\t\tfrp3->fr_parent = frp2;\n\t\tif (frp3->fr_next == NULL)\n\t\t{\n\t\t    frp3->fr_next = frp->fr_next;\n\t\t    if (frp->fr_next != NULL)\n\t\t\tfrp->fr_next->fr_prev = frp3;\n\t\t    break;\n\t\t}\n\t    }\n\t    if (topframe->fr_child == frp)\n\t\ttopframe->fr_child = frp2;\n\t    vim_free(frp);\n\t}\n    }\n\n    return wp;\n}\n\n/*\n * Return a pointer to the frame that will receive the empty screen space that\n * is left over after \"win\" is closed.\n *\n * If 'splitbelow' or 'splitright' is set, the space goes above or to the left\n * by default.  Otherwise, the free space goes below or to the right.  The\n * result is that opening a window and then immediately closing it will\n * preserve the initial window layout.  The 'wfh' and 'wfw' settings are\n * respected when possible.\n */\n    static frame_T *\nwin_altframe(\n    win_T\t*win,\n    tabpage_T\t*tp)\t\t/* tab page \"win\" is in, NULL for current */\n{\n    frame_T\t*frp;\n    frame_T\t*other_fr, *target_fr;\n\n    if (tp == NULL ? ONE_WINDOW : tp->tp_firstwin == tp->tp_lastwin)\n\treturn alt_tabpage()->tp_curwin->w_frame;\n\n    frp = win->w_frame;\n\n    if (frp->fr_prev == NULL)\n\treturn frp->fr_next;\n    if (frp->fr_next == NULL)\n\treturn frp->fr_prev;\n\n    target_fr = frp->fr_next;\n    other_fr  = frp->fr_prev;\n    if (p_spr || p_sb)\n    {\n\ttarget_fr = frp->fr_prev;\n\tother_fr  = frp->fr_next;\n    }\n\n    /* If 'wfh' or 'wfw' is set for the target and not for the alternate\n     * window, reverse the selection. */\n    if (frp->fr_parent != NULL && frp->fr_parent->fr_layout == FR_ROW)\n    {\n\tif (frame_fixed_width(target_fr) && !frame_fixed_width(other_fr))\n\t    target_fr = other_fr;\n    }\n    else\n    {\n\tif (frame_fixed_height(target_fr) && !frame_fixed_height(other_fr))\n\t    target_fr = other_fr;\n    }\n\n    return target_fr;\n}\n\n/*\n * Return the tabpage that will be used if the current one is closed.\n */\n    static tabpage_T *\nalt_tabpage(void)\n{\n    tabpage_T\t*tp;\n\n    /* Use the next tab page if possible. */\n    if (curtab->tp_next != NULL)\n\treturn curtab->tp_next;\n\n    /* Find the last but one tab page. */\n    for (tp = first_tabpage; tp->tp_next != curtab; tp = tp->tp_next)\n\t;\n    return tp;\n}\n\n/*\n * Find the left-upper window in frame \"frp\".\n */\n    static win_T *\nframe2win(frame_T *frp)\n{\n    while (frp->fr_win == NULL)\n\tfrp = frp->fr_child;\n    return frp->fr_win;\n}\n\n/*\n * Return TRUE if frame \"frp\" contains window \"wp\".\n */\n    static int\nframe_has_win(frame_T *frp, win_T *wp)\n{\n    frame_T\t*p;\n\n    if (frp->fr_layout == FR_LEAF)\n\treturn frp->fr_win == wp;\n\n    FOR_ALL_FRAMES(p, frp->fr_child)\n\tif (frame_has_win(p, wp))\n\t    return TRUE;\n    return FALSE;\n}\n\n/*\n * Set a new height for a frame.  Recursively sets the height for contained\n * frames and windows.  Caller must take care of positions.\n */\n    static void\nframe_new_height(\n    frame_T\t*topfrp,\n    int\t\theight,\n    int\t\ttopfirst,\t/* resize topmost contained frame first */\n    int\t\twfh)\t\t/* obey 'winfixheight' when there is a choice;\n\t\t\t\t   may cause the height not to be set */\n{\n    frame_T\t*frp;\n    int\t\textra_lines;\n    int\t\th;\n\n    if (topfrp->fr_win != NULL)\n    {\n\t/* Simple case: just one window. */\n\twin_new_height(topfrp->fr_win,\n\t\t\t\t    height - topfrp->fr_win->w_status_height\n\t\t\t\t\t      - WINBAR_HEIGHT(topfrp->fr_win));\n    }\n    else if (topfrp->fr_layout == FR_ROW)\n    {\n\tdo\n\t{\n\t    /* All frames in this row get the same new height. */\n\t    FOR_ALL_FRAMES(frp, topfrp->fr_child)\n\t    {\n\t\tframe_new_height(frp, height, topfirst, wfh);\n\t\tif (frp->fr_height > height)\n\t\t{\n\t\t    /* Could not fit the windows, make the whole row higher. */\n\t\t    height = frp->fr_height;\n\t\t    break;\n\t\t}\n\t    }\n\t}\n\twhile (frp != NULL);\n    }\n    else    /* fr_layout == FR_COL */\n    {\n\t/* Complicated case: Resize a column of frames.  Resize the bottom\n\t * frame first, frames above that when needed. */\n\n\tfrp = topfrp->fr_child;\n\tif (wfh)\n\t    /* Advance past frames with one window with 'wfh' set. */\n\t    while (frame_fixed_height(frp))\n\t    {\n\t\tfrp = frp->fr_next;\n\t\tif (frp == NULL)\n\t\t    return;\t    /* no frame without 'wfh', give up */\n\t    }\n\tif (!topfirst)\n\t{\n\t    /* Find the bottom frame of this column */\n\t    while (frp->fr_next != NULL)\n\t\tfrp = frp->fr_next;\n\t    if (wfh)\n\t\t/* Advance back for frames with one window with 'wfh' set. */\n\t\twhile (frame_fixed_height(frp))\n\t\t    frp = frp->fr_prev;\n\t}\n\n\textra_lines = height - topfrp->fr_height;\n\tif (extra_lines < 0)\n\t{\n\t    /* reduce height of contained frames, bottom or top frame first */\n\t    while (frp != NULL)\n\t    {\n\t\th = frame_minheight(frp, NULL);\n\t\tif (frp->fr_height + extra_lines < h)\n\t\t{\n\t\t    extra_lines += frp->fr_height - h;\n\t\t    frame_new_height(frp, h, topfirst, wfh);\n\t\t}\n\t\telse\n\t\t{\n\t\t    frame_new_height(frp, frp->fr_height + extra_lines,\n\t\t\t\t\t\t\t       topfirst, wfh);\n\t\t    break;\n\t\t}\n\t\tif (topfirst)\n\t\t{\n\t\t    do\n\t\t\tfrp = frp->fr_next;\n\t\t    while (wfh && frp != NULL && frame_fixed_height(frp));\n\t\t}\n\t\telse\n\t\t{\n\t\t    do\n\t\t\tfrp = frp->fr_prev;\n\t\t    while (wfh && frp != NULL && frame_fixed_height(frp));\n\t\t}\n\t\t/* Increase \"height\" if we could not reduce enough frames. */\n\t\tif (frp == NULL)\n\t\t    height -= extra_lines;\n\t    }\n\t}\n\telse if (extra_lines > 0)\n\t{\n\t    /* increase height of bottom or top frame */\n\t    frame_new_height(frp, frp->fr_height + extra_lines, topfirst, wfh);\n\t}\n    }\n    topfrp->fr_height = height;\n}\n\n/*\n * Return TRUE if height of frame \"frp\" should not be changed because of\n * the 'winfixheight' option.\n */\n    static int\nframe_fixed_height(frame_T *frp)\n{\n    /* frame with one window: fixed height if 'winfixheight' set. */\n    if (frp->fr_win != NULL)\n\treturn frp->fr_win->w_p_wfh;\n\n    if (frp->fr_layout == FR_ROW)\n    {\n\t/* The frame is fixed height if one of the frames in the row is fixed\n\t * height. */\n\tFOR_ALL_FRAMES(frp, frp->fr_child)\n\t    if (frame_fixed_height(frp))\n\t\treturn TRUE;\n\treturn FALSE;\n    }\n\n    /* frp->fr_layout == FR_COL: The frame is fixed height if all of the\n     * frames in the row are fixed height. */\n    FOR_ALL_FRAMES(frp, frp->fr_child)\n\tif (!frame_fixed_height(frp))\n\t    return FALSE;\n    return TRUE;\n}\n\n/*\n * Return TRUE if width of frame \"frp\" should not be changed because of\n * the 'winfixwidth' option.\n */\n    static int\nframe_fixed_width(frame_T *frp)\n{\n    /* frame with one window: fixed width if 'winfixwidth' set. */\n    if (frp->fr_win != NULL)\n\treturn frp->fr_win->w_p_wfw;\n\n    if (frp->fr_layout == FR_COL)\n    {\n\t/* The frame is fixed width if one of the frames in the row is fixed\n\t * width. */\n\tFOR_ALL_FRAMES(frp, frp->fr_child)\n\t    if (frame_fixed_width(frp))\n\t\treturn TRUE;\n\treturn FALSE;\n    }\n\n    /* frp->fr_layout == FR_ROW: The frame is fixed width if all of the\n     * frames in the row are fixed width. */\n    FOR_ALL_FRAMES(frp, frp->fr_child)\n\tif (!frame_fixed_width(frp))\n\t    return FALSE;\n    return TRUE;\n}\n\n/*\n * Add a status line to windows at the bottom of \"frp\".\n * Note: Does not check if there is room!\n */\n    static void\nframe_add_statusline(frame_T *frp)\n{\n    win_T\t*wp;\n\n    if (frp->fr_layout == FR_LEAF)\n    {\n\twp = frp->fr_win;\n\tif (wp->w_status_height == 0)\n\t{\n\t    if (wp->w_height > 0)\t/* don't make it negative */\n\t\t--wp->w_height;\n\t    wp->w_status_height = STATUS_HEIGHT;\n\t}\n    }\n    else if (frp->fr_layout == FR_ROW)\n    {\n\t/* Handle all the frames in the row. */\n\tFOR_ALL_FRAMES(frp, frp->fr_child)\n\t    frame_add_statusline(frp);\n    }\n    else /* frp->fr_layout == FR_COL */\n    {\n\t/* Only need to handle the last frame in the column. */\n\tfor (frp = frp->fr_child; frp->fr_next != NULL; frp = frp->fr_next)\n\t    ;\n\tframe_add_statusline(frp);\n    }\n}\n\n/*\n * Set width of a frame.  Handles recursively going through contained frames.\n * May remove separator line for windows at the right side (for win_close()).\n */\n    static void\nframe_new_width(\n    frame_T\t*topfrp,\n    int\t\twidth,\n    int\t\tleftfirst,\t/* resize leftmost contained frame first */\n    int\t\twfw)\t\t/* obey 'winfixwidth' when there is a choice;\n\t\t\t\t   may cause the width not to be set */\n{\n    frame_T\t*frp;\n    int\t\textra_cols;\n    int\t\tw;\n    win_T\t*wp;\n\n    if (topfrp->fr_layout == FR_LEAF)\n    {\n\t/* Simple case: just one window. */\n\twp = topfrp->fr_win;\n\t/* Find out if there are any windows right of this one. */\n\tfor (frp = topfrp; frp->fr_parent != NULL; frp = frp->fr_parent)\n\t    if (frp->fr_parent->fr_layout == FR_ROW && frp->fr_next != NULL)\n\t\tbreak;\n\tif (frp->fr_parent == NULL)\n\t    wp->w_vsep_width = 0;\n\twin_new_width(wp, width - wp->w_vsep_width);\n    }\n    else if (topfrp->fr_layout == FR_COL)\n    {\n\tdo\n\t{\n\t    /* All frames in this column get the same new width. */\n\t    FOR_ALL_FRAMES(frp, topfrp->fr_child)\n\t    {\n\t\tframe_new_width(frp, width, leftfirst, wfw);\n\t\tif (frp->fr_width > width)\n\t\t{\n\t\t    /* Could not fit the windows, make whole column wider. */\n\t\t    width = frp->fr_width;\n\t\t    break;\n\t\t}\n\t    }\n\t} while (frp != NULL);\n    }\n    else    /* fr_layout == FR_ROW */\n    {\n\t/* Complicated case: Resize a row of frames.  Resize the rightmost\n\t * frame first, frames left of it when needed. */\n\n\tfrp = topfrp->fr_child;\n\tif (wfw)\n\t    /* Advance past frames with one window with 'wfw' set. */\n\t    while (frame_fixed_width(frp))\n\t    {\n\t\tfrp = frp->fr_next;\n\t\tif (frp == NULL)\n\t\t    return;\t    /* no frame without 'wfw', give up */\n\t    }\n\tif (!leftfirst)\n\t{\n\t    /* Find the rightmost frame of this row */\n\t    while (frp->fr_next != NULL)\n\t\tfrp = frp->fr_next;\n\t    if (wfw)\n\t\t/* Advance back for frames with one window with 'wfw' set. */\n\t\twhile (frame_fixed_width(frp))\n\t\t    frp = frp->fr_prev;\n\t}\n\n\textra_cols = width - topfrp->fr_width;\n\tif (extra_cols < 0)\n\t{\n\t    /* reduce frame width, rightmost frame first */\n\t    while (frp != NULL)\n\t    {\n\t\tw = frame_minwidth(frp, NULL);\n\t\tif (frp->fr_width + extra_cols < w)\n\t\t{\n\t\t    extra_cols += frp->fr_width - w;\n\t\t    frame_new_width(frp, w, leftfirst, wfw);\n\t\t}\n\t\telse\n\t\t{\n\t\t    frame_new_width(frp, frp->fr_width + extra_cols,\n\t\t\t\t\t\t\t      leftfirst, wfw);\n\t\t    break;\n\t\t}\n\t\tif (leftfirst)\n\t\t{\n\t\t    do\n\t\t\tfrp = frp->fr_next;\n\t\t    while (wfw && frp != NULL && frame_fixed_width(frp));\n\t\t}\n\t\telse\n\t\t{\n\t\t    do\n\t\t\tfrp = frp->fr_prev;\n\t\t    while (wfw && frp != NULL && frame_fixed_width(frp));\n\t\t}\n\t\t/* Increase \"width\" if we could not reduce enough frames. */\n\t\tif (frp == NULL)\n\t\t    width -= extra_cols;\n\t    }\n\t}\n\telse if (extra_cols > 0)\n\t{\n\t    /* increase width of rightmost frame */\n\t    frame_new_width(frp, frp->fr_width + extra_cols, leftfirst, wfw);\n\t}\n    }\n    topfrp->fr_width = width;\n}\n\n/*\n * Add the vertical separator to windows at the right side of \"frp\".\n * Note: Does not check if there is room!\n */\n    static void\nframe_add_vsep(frame_T *frp)\n{\n    win_T\t*wp;\n\n    if (frp->fr_layout == FR_LEAF)\n    {\n\twp = frp->fr_win;\n\tif (wp->w_vsep_width == 0)\n\t{\n\t    if (wp->w_width > 0)\t/* don't make it negative */\n\t\t--wp->w_width;\n\t    wp->w_vsep_width = 1;\n\t}\n    }\n    else if (frp->fr_layout == FR_COL)\n    {\n\t/* Handle all the frames in the column. */\n\tFOR_ALL_FRAMES(frp, frp->fr_child)\n\t    frame_add_vsep(frp);\n    }\n    else /* frp->fr_layout == FR_ROW */\n    {\n\t/* Only need to handle the last frame in the row. */\n\tfrp = frp->fr_child;\n\twhile (frp->fr_next != NULL)\n\t    frp = frp->fr_next;\n\tframe_add_vsep(frp);\n    }\n}\n\n/*\n * Set frame width from the window it contains.\n */\n    static void\nframe_fix_width(win_T *wp)\n{\n    wp->w_frame->fr_width = wp->w_width + wp->w_vsep_width;\n}\n\n/*\n * Set frame height from the window it contains.\n */\n    static void\nframe_fix_height(win_T *wp)\n{\n    wp->w_frame->fr_height = VISIBLE_HEIGHT(wp) + wp->w_status_height;\n}\n\n/*\n * Compute the minimal height for frame \"topfrp\".\n * Uses the 'winminheight' option.\n * When \"next_curwin\" isn't NULL, use p_wh for this window.\n * When \"next_curwin\" is NOWIN, don't use at least one line for the current\n * window.\n */\n    static int\nframe_minheight(frame_T *topfrp, win_T *next_curwin)\n{\n    frame_T\t*frp;\n    int\t\tm;\n    int\t\tn;\n\n    if (topfrp->fr_win != NULL)\n    {\n\tif (topfrp->fr_win == next_curwin)\n\t    m = p_wh + topfrp->fr_win->w_status_height;\n\telse\n\t{\n\t    /* window: minimal height of the window plus status line */\n\t    m = p_wmh + topfrp->fr_win->w_status_height;\n\t    if (topfrp->fr_win == curwin && next_curwin == NULL)\n\t    {\n\t\t/* Current window is minimal one line high and WinBar is\n\t\t * visible. */\n\t\tif (p_wmh == 0)\n\t\t    ++m;\n\t\tm += WINBAR_HEIGHT(curwin);\n\t    }\n\t}\n    }\n    else if (topfrp->fr_layout == FR_ROW)\n    {\n\t/* get the minimal height from each frame in this row */\n\tm = 0;\n\tFOR_ALL_FRAMES(frp, topfrp->fr_child)\n\t{\n\t    n = frame_minheight(frp, next_curwin);\n\t    if (n > m)\n\t\tm = n;\n\t}\n    }\n    else\n    {\n\t/* Add up the minimal heights for all frames in this column. */\n\tm = 0;\n\tFOR_ALL_FRAMES(frp, topfrp->fr_child)\n\t    m += frame_minheight(frp, next_curwin);\n    }\n\n    return m;\n}\n\n/*\n * Compute the minimal width for frame \"topfrp\".\n * When \"next_curwin\" isn't NULL, use p_wiw for this window.\n * When \"next_curwin\" is NOWIN, don't use at least one column for the current\n * window.\n */\n    static int\nframe_minwidth(\n    frame_T\t*topfrp,\n    win_T\t*next_curwin)\t/* use p_wh and p_wiw for next_curwin */\n{\n    frame_T\t*frp;\n    int\t\tm, n;\n\n    if (topfrp->fr_win != NULL)\n    {\n\tif (topfrp->fr_win == next_curwin)\n\t    m = p_wiw + topfrp->fr_win->w_vsep_width;\n\telse\n\t{\n\t    /* window: minimal width of the window plus separator column */\n\t    m = p_wmw + topfrp->fr_win->w_vsep_width;\n\t    /* Current window is minimal one column wide */\n\t    if (p_wmw == 0 && topfrp->fr_win == curwin && next_curwin == NULL)\n\t\t++m;\n\t}\n    }\n    else if (topfrp->fr_layout == FR_COL)\n    {\n\t/* get the minimal width from each frame in this column */\n\tm = 0;\n\tFOR_ALL_FRAMES(frp, topfrp->fr_child)\n\t{\n\t    n = frame_minwidth(frp, next_curwin);\n\t    if (n > m)\n\t\tm = n;\n\t}\n    }\n    else\n    {\n\t/* Add up the minimal widths for all frames in this row. */\n\tm = 0;\n\tFOR_ALL_FRAMES(frp, topfrp->fr_child)\n\t    m += frame_minwidth(frp, next_curwin);\n    }\n\n    return m;\n}\n\n\n/*\n * Try to close all windows except current one.\n * Buffers in the other windows become hidden if 'hidden' is set, or '!' is\n * used and the buffer was modified.\n *\n * Used by \":bdel\" and \":only\".\n */\n    void\nclose_others(\n    int\t\tmessage,\n    int\t\tforceit)\t    /* always hide all other windows */\n{\n    win_T\t*wp;\n    win_T\t*nextwp;\n    int\t\tr;\n\n    if (one_window())\n    {\n\tif (message && !autocmd_busy)\n\t    msg(_(m_onlyone));\n\treturn;\n    }\n\n    /* Be very careful here: autocommands may change the window layout. */\n    for (wp = firstwin; win_valid(wp); wp = nextwp)\n    {\n\tnextwp = wp->w_next;\n\tif (wp != curwin)\t\t/* don't close current window */\n\t{\n\n\t    /* Check if it's allowed to abandon this window */\n\t    r = can_abandon(wp->w_buffer, forceit);\n\t    if (!win_valid(wp))\t\t/* autocommands messed wp up */\n\t    {\n\t\tnextwp = firstwin;\n\t\tcontinue;\n\t    }\n\t    if (!r)\n\t    {\n#if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)\n\t\tif (message && (p_confirm || cmdmod.confirm) && p_write)\n\t\t{\n\t\t    dialog_changed(wp->w_buffer, FALSE);\n\t\t    if (!win_valid(wp))\t\t/* autocommands messed wp up */\n\t\t    {\n\t\t\tnextwp = firstwin;\n\t\t\tcontinue;\n\t\t    }\n\t\t}\n\t\tif (bufIsChanged(wp->w_buffer))\n#endif\n\t\t    continue;\n\t    }\n\t    win_close(wp, !buf_hide(wp->w_buffer)\n\t\t\t\t\t       && !bufIsChanged(wp->w_buffer));\n\t}\n    }\n\n    if (message && !ONE_WINDOW)\n\temsg(_(\"E445: Other window contains changes\"));\n}\n\n    static void\nwin_init_empty(win_T *wp)\n{\n    redraw_win_later(wp, NOT_VALID);\n    wp->w_lines_valid = 0;\n    wp->w_cursor.lnum = 1;\n    wp->w_curswant = wp->w_cursor.col = 0;\n    wp->w_cursor.coladd = 0;\n    wp->w_pcmark.lnum = 1;\t/* pcmark not cleared but set to line 1 */\n    wp->w_pcmark.col = 0;\n    wp->w_prev_pcmark.lnum = 0;\n    wp->w_prev_pcmark.col = 0;\n    wp->w_topline = 1;\n#ifdef FEAT_DIFF\n    wp->w_topfill = 0;\n#endif\n    wp->w_botline = 2;\n#if defined(FEAT_SYN_HL) || defined(FEAT_SPELL)\n    wp->w_s = &wp->w_buffer->b_s;\n#endif\n}\n\n/*\n * Init the current window \"curwin\".\n * Called when a new file is being edited.\n */\n    void\ncurwin_init(void)\n{\n    win_init_empty(curwin);\n}\n\n/*\n * Allocate the first window and put an empty buffer in it.\n * Called from main().\n * Return FAIL when something goes wrong (out of memory).\n */\n    int\nwin_alloc_first(void)\n{\n    if (win_alloc_firstwin(NULL) == FAIL)\n\treturn FAIL;\n\n    first_tabpage = alloc_tabpage();\n    if (first_tabpage == NULL)\n\treturn FAIL;\n    first_tabpage->tp_topframe = topframe;\n    curtab = first_tabpage;\n\n    return OK;\n}\n\n/*\n * Allocate and init a window that is not a regular window.\n * This can only be done after the first window is fully initialized, thus it\n * can't be in win_alloc_first().\n */\n    win_T *\nwin_alloc_popup_win(void)\n{\n    win_T *wp;\n\n    wp = win_alloc(NULL, TRUE);\n    if (wp != NULL)\n    {\n\t// We need to initialize options with something, using the current\n\t// window makes most sense.\n\twin_init_some(wp, curwin);\n\n\tRESET_BINDING(wp);\n\tnew_frame(wp);\n    }\n    return wp;\n}\n\n/*\n * Initialize window \"wp\" to display buffer \"buf\".\n */\n    void\nwin_init_popup_win(win_T *wp, buf_T *buf)\n{\n    wp->w_buffer = buf;\n    ++buf->b_nwindows;\n    win_init_empty(wp); // set cursor and topline to safe values\n\n    // Make sure w_localdir and globaldir are NULL to avoid a chdir() in\n    // win_enter_ext().\n    VIM_CLEAR(wp->w_localdir);\n}\n\n/*\n * Allocate the first window or the first window in a new tab page.\n * When \"oldwin\" is NULL create an empty buffer for it.\n * When \"oldwin\" is not NULL copy info from it to the new window.\n * Return FAIL when something goes wrong (out of memory).\n */\n    static int\nwin_alloc_firstwin(win_T *oldwin)\n{\n    curwin = win_alloc(NULL, FALSE);\n    if (oldwin == NULL)\n    {\n\t/* Very first window, need to create an empty buffer for it and\n\t * initialize from scratch. */\n\tcurbuf = buflist_new(NULL, NULL, 1L, BLN_LISTED);\n\tif (curwin == NULL || curbuf == NULL)\n\t    return FAIL;\n\tcurwin->w_buffer = curbuf;\n#ifdef FEAT_SYN_HL\n\tcurwin->w_s = &(curbuf->b_s);\n#endif\n\tcurbuf->b_nwindows = 1;\t/* there is one window */\n\tcurwin->w_alist = &global_alist;\n\tcurwin_init();\t\t/* init current window */\n    }\n    else\n    {\n\t/* First window in new tab page, initialize it from \"oldwin\". */\n\twin_init(curwin, oldwin, 0);\n\n\t/* We don't want cursor- and scroll-binding in the first window. */\n\tRESET_BINDING(curwin);\n    }\n\n    new_frame(curwin);\n    if (curwin->w_frame == NULL)\n\treturn FAIL;\n    topframe = curwin->w_frame;\n    topframe->fr_width = Columns;\n    topframe->fr_height = Rows - p_ch;\n\n    return OK;\n}\n\n/*\n * Create a frame for window \"wp\".\n */\n    static void\nnew_frame(win_T *wp)\n{\n    frame_T *frp = ALLOC_CLEAR_ONE(frame_T);\n\n    wp->w_frame = frp;\n    if (frp != NULL)\n    {\n\tfrp->fr_layout = FR_LEAF;\n\tfrp->fr_win = wp;\n    }\n}\n\n/*\n * Initialize the window and frame size to the maximum.\n */\n    void\nwin_init_size(void)\n{\n    firstwin->w_height = ROWS_AVAIL;\n    topframe->fr_height = ROWS_AVAIL;\n    firstwin->w_width = Columns;\n    topframe->fr_width = Columns;\n}\n\n/*\n * Allocate a new tabpage_T and init the values.\n * Returns NULL when out of memory.\n */\n    static tabpage_T *\nalloc_tabpage(void)\n{\n    tabpage_T\t*tp;\n# ifdef FEAT_GUI\n    int\t\ti;\n# endif\n\n\n    tp = ALLOC_CLEAR_ONE(tabpage_T);\n    if (tp == NULL)\n\treturn NULL;\n\n# ifdef FEAT_EVAL\n    /* init t: variables */\n    tp->tp_vars = dict_alloc();\n    if (tp->tp_vars == NULL)\n    {\n\tvim_free(tp);\n\treturn NULL;\n    }\n    init_var_dict(tp->tp_vars, &tp->tp_winvar, VAR_SCOPE);\n# endif\n\n# ifdef FEAT_GUI\n    for (i = 0; i < 3; i++)\n\ttp->tp_prev_which_scrollbars[i] = -1;\n# endif\n# ifdef FEAT_DIFF\n    tp->tp_diff_invalid = TRUE;\n# endif\n    tp->tp_ch_used = p_ch;\n\n    return tp;\n}\n\n    void\nfree_tabpage(tabpage_T *tp)\n{\n    int idx;\n\n# ifdef FEAT_DIFF\n    diff_clear(tp);\n# endif\n# ifdef FEAT_TEXT_PROP\n    while (tp->tp_first_popupwin != NULL)\n\tpopup_close_tabpage(tp, tp->tp_first_popupwin->w_id);\n#endif\n    for (idx = 0; idx < SNAP_COUNT; ++idx)\n\tclear_snapshot(tp, idx);\n#ifdef FEAT_EVAL\n    vars_clear(&tp->tp_vars->dv_hashtab);\t/* free all t: variables */\n    hash_init(&tp->tp_vars->dv_hashtab);\n    unref_var_dict(tp->tp_vars);\n#endif\n\n    vim_free(tp->tp_localdir);\n\n#ifdef FEAT_PYTHON\n    python_tabpage_free(tp);\n#endif\n\n#ifdef FEAT_PYTHON3\n    python3_tabpage_free(tp);\n#endif\n\n    vim_free(tp);\n}\n\n/*\n * Create a new Tab page with one window.\n * It will edit the current buffer, like after \":split\".\n * When \"after\" is 0 put it just after the current Tab page.\n * Otherwise put it just before tab page \"after\".\n * Return FAIL or OK.\n */\n    int\nwin_new_tabpage(int after)\n{\n    tabpage_T\t*tp = curtab;\n    tabpage_T\t*newtp;\n    int\t\tn;\n\n    newtp = alloc_tabpage();\n    if (newtp == NULL)\n\treturn FAIL;\n\n    /* Remember the current windows in this Tab page. */\n    if (leave_tabpage(curbuf, TRUE) == FAIL)\n    {\n\tvim_free(newtp);\n\treturn FAIL;\n    }\n    curtab = newtp;\n\n    newtp->tp_localdir = (tp->tp_localdir == NULL)\n\t\t\t\t    ? NULL : vim_strsave(tp->tp_localdir);\n    /* Create a new empty window. */\n    if (win_alloc_firstwin(tp->tp_curwin) == OK)\n    {\n\t/* Make the new Tab page the new topframe. */\n\tif (after == 1)\n\t{\n\t    /* New tab page becomes the first one. */\n\t    newtp->tp_next = first_tabpage;\n\t    first_tabpage = newtp;\n\t}\n\telse\n\t{\n\t    if (after > 0)\n\t    {\n\t\t/* Put new tab page before tab page \"after\". */\n\t\tn = 2;\n\t\tfor (tp = first_tabpage; tp->tp_next != NULL\n\t\t\t\t\t       && n < after; tp = tp->tp_next)\n\t\t    ++n;\n\t    }\n\t    newtp->tp_next = tp->tp_next;\n\t    tp->tp_next = newtp;\n\t}\n\twin_init_size();\n\tfirstwin->w_winrow = tabline_height();\n\twin_comp_scroll(curwin);\n\n\tnewtp->tp_topframe = topframe;\n\tlast_status(FALSE);\n\n#if defined(FEAT_GUI)\n\t/* When 'guioptions' includes 'L' or 'R' may have to remove or add\n\t * scrollbars.  Have to update them anyway. */\n\tgui_may_update_scrollbars();\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\tentering_window(curwin);\n#endif\n\n\tredraw_all_later(NOT_VALID);\n\tapply_autocmds(EVENT_WINNEW, NULL, NULL, FALSE, curbuf);\n\tapply_autocmds(EVENT_WINENTER, NULL, NULL, FALSE, curbuf);\n\tapply_autocmds(EVENT_TABNEW, NULL, NULL, FALSE, curbuf);\n\tapply_autocmds(EVENT_TABENTER, NULL, NULL, FALSE, curbuf);\n\treturn OK;\n    }\n\n    /* Failed, get back the previous Tab page */\n    enter_tabpage(curtab, curbuf, TRUE, TRUE);\n    return FAIL;\n}\n\n/*\n * Open a new tab page if \":tab cmd\" was used.  It will edit the same buffer,\n * like with \":split\".\n * Returns OK if a new tab page was created, FAIL otherwise.\n */\n    static int\nmay_open_tabpage(void)\n{\n    int\t\tn = (cmdmod.tab == 0) ? postponed_split_tab : cmdmod.tab;\n\n    if (n != 0)\n    {\n\tcmdmod.tab = 0;\t    /* reset it to avoid doing it twice */\n\tpostponed_split_tab = 0;\n\treturn win_new_tabpage(n);\n    }\n    return FAIL;\n}\n\n/*\n * Create up to \"maxcount\" tabpages with empty windows.\n * Returns the number of resulting tab pages.\n */\n    int\nmake_tabpages(int maxcount)\n{\n    int\t\tcount = maxcount;\n    int\t\ttodo;\n\n    /* Limit to 'tabpagemax' tabs. */\n    if (count > p_tpm)\n\tcount = p_tpm;\n\n    /*\n     * Don't execute autocommands while creating the tab pages.  Must do that\n     * when putting the buffers in the windows.\n     */\n    block_autocmds();\n\n    for (todo = count - 1; todo > 0; --todo)\n\tif (win_new_tabpage(0) == FAIL)\n\t    break;\n\n    unblock_autocmds();\n\n    /* return actual number of tab pages */\n    return (count - todo);\n}\n\n/*\n * Return TRUE when \"tpc\" points to a valid tab page.\n */\n    int\nvalid_tabpage(tabpage_T *tpc)\n{\n    tabpage_T\t*tp;\n\n    FOR_ALL_TABPAGES(tp)\n\tif (tp == tpc)\n\t    return TRUE;\n    return FALSE;\n}\n\n/*\n * Return TRUE when \"tpc\" points to a valid tab page and at least one window is\n * valid.\n */\n    int\nvalid_tabpage_win(tabpage_T *tpc)\n{\n    tabpage_T\t*tp;\n    win_T\t*wp;\n\n    FOR_ALL_TABPAGES(tp)\n    {\n\tif (tp == tpc)\n\t{\n\t    FOR_ALL_WINDOWS_IN_TAB(tp, wp)\n\t    {\n\t\tif (win_valid_any_tab(wp))\n\t\t    return TRUE;\n\t    }\n\t    return FALSE;\n\t}\n    }\n    /* shouldn't happen */\n    return FALSE;\n}\n\n/*\n * Close tabpage \"tab\", assuming it has no windows in it.\n * There must be another tabpage or this will crash.\n */\n    void\nclose_tabpage(tabpage_T *tab)\n{\n    tabpage_T\t*ptp;\n\n    if (tab == first_tabpage)\n    {\n\tfirst_tabpage = tab->tp_next;\n\tptp = first_tabpage;\n    }\n    else\n    {\n\tfor (ptp = first_tabpage; ptp != NULL && ptp->tp_next != tab;\n\t\t\t\t\t\t\t    ptp = ptp->tp_next)\n\t    ;\n\tassert(ptp != NULL);\n\tptp->tp_next = tab->tp_next;\n    }\n\n    goto_tabpage_tp(ptp, FALSE, FALSE);\n    free_tabpage(tab);\n}\n\n/*\n * Find tab page \"n\" (first one is 1).  Returns NULL when not found.\n */\n    tabpage_T *\nfind_tabpage(int n)\n{\n    tabpage_T\t*tp;\n    int\t\ti = 1;\n\n    if (n == 0)\n\treturn curtab;\n\n    for (tp = first_tabpage; tp != NULL && i != n; tp = tp->tp_next)\n\t++i;\n    return tp;\n}\n\n/*\n * Get index of tab page \"tp\".  First one has index 1.\n * When not found returns number of tab pages plus one.\n */\n    int\ntabpage_index(tabpage_T *ftp)\n{\n    int\t\ti = 1;\n    tabpage_T\t*tp;\n\n    for (tp = first_tabpage; tp != NULL && tp != ftp; tp = tp->tp_next)\n\t++i;\n    return i;\n}\n\n/*\n * Prepare for leaving the current tab page.\n * When autocommands change \"curtab\" we don't leave the tab page and return\n * FAIL.\n * Careful: When OK is returned need to get a new tab page very very soon!\n */\n    static int\nleave_tabpage(\n    buf_T\t*new_curbuf UNUSED,    /* what is going to be the new curbuf,\n\t\t\t\t       NULL if unknown */\n    int\t\ttrigger_leave_autocmds UNUSED)\n{\n    tabpage_T\t*tp = curtab;\n\n#ifdef FEAT_JOB_CHANNEL\n    leaving_window(curwin);\n#endif\n    reset_VIsual_and_resel();\t/* stop Visual mode */\n    if (trigger_leave_autocmds)\n    {\n\tif (new_curbuf != curbuf)\n\t{\n\t    apply_autocmds(EVENT_BUFLEAVE, NULL, NULL, FALSE, curbuf);\n\t    if (curtab != tp)\n\t\treturn FAIL;\n\t}\n\tapply_autocmds(EVENT_WINLEAVE, NULL, NULL, FALSE, curbuf);\n\tif (curtab != tp)\n\t    return FAIL;\n\tapply_autocmds(EVENT_TABLEAVE, NULL, NULL, FALSE, curbuf);\n\tif (curtab != tp)\n\t    return FAIL;\n    }\n#if defined(FEAT_GUI)\n    /* Remove the scrollbars.  They may be added back later. */\n    if (gui.in_use)\n\tgui_remove_scrollbars();\n#endif\n    tp->tp_curwin = curwin;\n    tp->tp_prevwin = prevwin;\n    tp->tp_firstwin = firstwin;\n    tp->tp_lastwin = lastwin;\n    tp->tp_old_Rows = Rows;\n    tp->tp_old_Columns = Columns;\n    firstwin = NULL;\n    lastwin = NULL;\n    return OK;\n}\n\n/*\n * Start using tab page \"tp\".\n * Only to be used after leave_tabpage() or freeing the current tab page.\n * Only trigger *Enter autocommands when trigger_enter_autocmds is TRUE.\n * Only trigger *Leave autocommands when trigger_leave_autocmds is TRUE.\n */\n    static void\nenter_tabpage(\n    tabpage_T\t*tp,\n    buf_T\t*old_curbuf UNUSED,\n    int\t\ttrigger_enter_autocmds,\n    int\t\ttrigger_leave_autocmds)\n{\n    int\t\told_off = tp->tp_firstwin->w_winrow;\n    win_T\t*next_prevwin = tp->tp_prevwin;\n\n    curtab = tp;\n    firstwin = tp->tp_firstwin;\n    lastwin = tp->tp_lastwin;\n    topframe = tp->tp_topframe;\n\n    /* We would like doing the TabEnter event first, but we don't have a\n     * valid current window yet, which may break some commands.\n     * This triggers autocommands, thus may make \"tp\" invalid. */\n    win_enter_ext(tp->tp_curwin, FALSE, TRUE, FALSE,\n\t\t\t      trigger_enter_autocmds, trigger_leave_autocmds);\n    prevwin = next_prevwin;\n\n    last_status(FALSE);\t\t/* status line may appear or disappear */\n    (void)win_comp_pos();\t/* recompute w_winrow for all windows */\n#ifdef FEAT_DIFF\n    diff_need_scrollbind = TRUE;\n#endif\n\n    /* The tabpage line may have appeared or disappeared, may need to resize\n     * the frames for that.  When the Vim window was resized need to update\n     * frame sizes too.  Use the stored value of p_ch, so that it can be\n     * different for each tab page. */\n    if (p_ch != curtab->tp_ch_used)\n\tclear_cmdline = TRUE;\n    p_ch = curtab->tp_ch_used;\n    if (curtab->tp_old_Rows != Rows || (old_off != firstwin->w_winrow\n#ifdef FEAT_GUI_TABLINE\n\t\t\t    && !gui_use_tabline()\n#endif\n\t\t))\n\tshell_new_rows();\n    if (curtab->tp_old_Columns != Columns && starting == 0)\n\tshell_new_columns();\t/* update window widths */\n\n#if defined(FEAT_GUI)\n    /* When 'guioptions' includes 'L' or 'R' may have to remove or add\n     * scrollbars.  Have to update them anyway. */\n    gui_may_update_scrollbars();\n#endif\n\n    /* Apply autocommands after updating the display, when 'rows' and\n     * 'columns' have been set correctly. */\n    if (trigger_enter_autocmds)\n    {\n\tapply_autocmds(EVENT_TABENTER, NULL, NULL, FALSE, curbuf);\n\tif (old_curbuf != curbuf)\n\t    apply_autocmds(EVENT_BUFENTER, NULL, NULL, FALSE, curbuf);\n    }\n\n    redraw_all_later(NOT_VALID);\n}\n\n/*\n * Go to tab page \"n\".  For \":tab N\" and \"Ngt\".\n * When \"n\" is 9999 go to the last tab page.\n */\n    void\ngoto_tabpage(int n)\n{\n    tabpage_T\t*tp = NULL;  // shut up compiler\n    tabpage_T\t*ttp;\n    int\t\ti;\n\n    if (text_locked())\n    {\n\t/* Not allowed when editing the command line. */\n\ttext_locked_msg();\n\treturn;\n    }\n\n    /* If there is only one it can't work. */\n    if (first_tabpage->tp_next == NULL)\n    {\n\tif (n > 1)\n\t    beep_flush();\n\treturn;\n    }\n\n    if (n == 0)\n    {\n\t/* No count, go to next tab page, wrap around end. */\n\tif (curtab->tp_next == NULL)\n\t    tp = first_tabpage;\n\telse\n\t    tp = curtab->tp_next;\n    }\n    else if (n < 0)\n    {\n\t/* \"gT\": go to previous tab page, wrap around end.  \"N gT\" repeats\n\t * this N times. */\n\tttp = curtab;\n\tfor (i = n; i < 0; ++i)\n\t{\n\t    for (tp = first_tabpage; tp->tp_next != ttp && tp->tp_next != NULL;\n\t\t    tp = tp->tp_next)\n\t\t;\n\t    ttp = tp;\n\t}\n    }\n    else if (n == 9999)\n    {\n\t/* Go to last tab page. */\n\tfor (tp = first_tabpage; tp->tp_next != NULL; tp = tp->tp_next)\n\t    ;\n    }\n    else\n    {\n\t/* Go to tab page \"n\". */\n\ttp = find_tabpage(n);\n\tif (tp == NULL)\n\t{\n\t    beep_flush();\n\t    return;\n\t}\n    }\n\n    goto_tabpage_tp(tp, TRUE, TRUE);\n\n#ifdef FEAT_GUI_TABLINE\n    if (gui_use_tabline())\n\tgui_mch_set_curtab(tabpage_index(curtab));\n#endif\n}\n\n/*\n * Go to tabpage \"tp\".\n * Only trigger *Enter autocommands when trigger_enter_autocmds is TRUE.\n * Only trigger *Leave autocommands when trigger_leave_autocmds is TRUE.\n * Note: doesn't update the GUI tab.\n */\n    void\ngoto_tabpage_tp(\n    tabpage_T\t*tp,\n    int\t\ttrigger_enter_autocmds,\n    int\t\ttrigger_leave_autocmds)\n{\n    /* Don't repeat a message in another tab page. */\n    set_keep_msg(NULL, 0);\n\n    if (tp != curtab && leave_tabpage(tp->tp_curwin->w_buffer,\n\t\t\t\t\ttrigger_leave_autocmds) == OK)\n    {\n\tif (valid_tabpage(tp))\n\t    enter_tabpage(tp, curbuf, trigger_enter_autocmds,\n\t\t    trigger_leave_autocmds);\n\telse\n\t    enter_tabpage(curtab, curbuf, trigger_enter_autocmds,\n\t\t    trigger_leave_autocmds);\n    }\n}\n\n/*\n * Enter window \"wp\" in tab page \"tp\".\n * Also updates the GUI tab.\n */\n    void\ngoto_tabpage_win(tabpage_T *tp, win_T *wp)\n{\n    goto_tabpage_tp(tp, TRUE, TRUE);\n    if (curtab == tp && win_valid(wp))\n    {\n\twin_enter(wp, TRUE);\n# ifdef FEAT_GUI_TABLINE\n\tif (gui_use_tabline())\n\t    gui_mch_set_curtab(tabpage_index(curtab));\n# endif\n    }\n}\n\n/*\n * Move the current tab page to after tab page \"nr\".\n */\n    void\ntabpage_move(int nr)\n{\n    int\t\tn = 1;\n    tabpage_T\t*tp, *tp_dst;\n\n    if (first_tabpage->tp_next == NULL)\n\treturn;\n\n    for (tp = first_tabpage; tp->tp_next != NULL && n < nr; tp = tp->tp_next)\n\t++n;\n\n    if (tp == curtab || (nr > 0 && tp->tp_next != NULL\n\t\t\t\t\t\t    && tp->tp_next == curtab))\n\treturn;\n\n    tp_dst = tp;\n\n    /* Remove the current tab page from the list of tab pages. */\n    if (curtab == first_tabpage)\n\tfirst_tabpage = curtab->tp_next;\n    else\n    {\n\tFOR_ALL_TABPAGES(tp)\n\t    if (tp->tp_next == curtab)\n\t\tbreak;\n\tif (tp == NULL)\t/* \"cannot happen\" */\n\t    return;\n\ttp->tp_next = curtab->tp_next;\n    }\n\n    /* Re-insert it at the specified position. */\n    if (nr <= 0)\n    {\n\tcurtab->tp_next = first_tabpage;\n\tfirst_tabpage = curtab;\n    }\n    else\n    {\n\tcurtab->tp_next = tp_dst->tp_next;\n\ttp_dst->tp_next = curtab;\n    }\n\n    /* Need to redraw the tabline.  Tab page contents doesn't change. */\n    redraw_tabline = TRUE;\n}\n\n\n/*\n * Go to another window.\n * When jumping to another buffer, stop Visual mode.  Do this before\n * changing windows so we can yank the selection into the '*' register.\n * When jumping to another window on the same buffer, adjust its cursor\n * position to keep the same Visual area.\n */\n    void\nwin_goto(win_T *wp)\n{\n#ifdef FEAT_CONCEAL\n    win_T\t*owp = curwin;\n#endif\n\n    if (ERROR_IF_POPUP_WINDOW)\n\treturn;\n    if (text_locked())\n    {\n\tbeep_flush();\n\ttext_locked_msg();\n\treturn;\n    }\n    if (curbuf_locked())\n\treturn;\n\n    if (wp->w_buffer != curbuf)\n\treset_VIsual_and_resel();\n    else if (VIsual_active)\n\twp->w_cursor = curwin->w_cursor;\n\n#ifdef FEAT_GUI\n    need_mouse_correct = TRUE;\n#endif\n    win_enter(wp, TRUE);\n\n#ifdef FEAT_CONCEAL\n    // Conceal cursor line in previous window, unconceal in current window.\n    if (win_valid(owp) && owp->w_p_cole > 0 && !msg_scrolled)\n\tredrawWinline(owp, owp->w_cursor.lnum);\n    if (curwin->w_p_cole > 0 && !msg_scrolled)\n\tneed_cursor_line_redraw = TRUE;\n#endif\n}\n\n#if defined(FEAT_PERL) || defined(PROTO)\n/*\n * Find window number \"winnr\" (counting top to bottom).\n */\n    win_T *\nwin_find_nr(int winnr)\n{\n    win_T\t*wp;\n\n    FOR_ALL_WINDOWS(wp)\n\tif (--winnr == 0)\n\t    break;\n    return wp;\n}\n#endif\n\n#if ((defined(FEAT_PYTHON) || defined(FEAT_PYTHON3))) || defined(PROTO)\n/*\n * Find the tabpage for window \"win\".\n */\n    tabpage_T *\nwin_find_tabpage(win_T *win)\n{\n    win_T\t*wp;\n    tabpage_T\t*tp;\n\n    FOR_ALL_TAB_WINDOWS(tp, wp)\n\t    if (wp == win)\n\t\treturn tp;\n    return NULL;\n}\n#endif\n\n/*\n * Get the above or below neighbor window of the specified window.\n *   up - TRUE for the above neighbor\n *   count - nth neighbor window\n * Returns the specified window if the neighbor is not found.\n */\n    win_T *\nwin_vert_neighbor(tabpage_T *tp, win_T *wp, int up, long count)\n{\n    frame_T\t*fr;\n    frame_T\t*nfr;\n    frame_T\t*foundfr;\n\n    foundfr = wp->w_frame;\n    while (count--)\n    {\n\t/*\n\t * First go upwards in the tree of frames until we find a upwards or\n\t * downwards neighbor.\n\t */\n\tfr = foundfr;\n\tfor (;;)\n\t{\n\t    if (fr == tp->tp_topframe)\n\t\tgoto end;\n\t    if (up)\n\t\tnfr = fr->fr_prev;\n\t    else\n\t\tnfr = fr->fr_next;\n\t    if (fr->fr_parent->fr_layout == FR_COL && nfr != NULL)\n\t\tbreak;\n\t    fr = fr->fr_parent;\n\t}\n\n\t/*\n\t * Now go downwards to find the bottom or top frame in it.\n\t */\n\tfor (;;)\n\t{\n\t    if (nfr->fr_layout == FR_LEAF)\n\t    {\n\t\tfoundfr = nfr;\n\t\tbreak;\n\t    }\n\t    fr = nfr->fr_child;\n\t    if (nfr->fr_layout == FR_ROW)\n\t    {\n\t\t/* Find the frame at the cursor row. */\n\t\twhile (fr->fr_next != NULL\n\t\t\t&& frame2win(fr)->w_wincol + fr->fr_width\n\t\t\t\t\t <= wp->w_wincol + wp->w_wcol)\n\t\t    fr = fr->fr_next;\n\t    }\n\t    if (nfr->fr_layout == FR_COL && up)\n\t\twhile (fr->fr_next != NULL)\n\t\t    fr = fr->fr_next;\n\t    nfr = fr;\n\t}\n    }\nend:\n    return foundfr != NULL ? foundfr->fr_win : NULL;\n}\n\n/*\n * Move to window above or below \"count\" times.\n */\n    static void\nwin_goto_ver(\n    int\t\tup,\t\t// TRUE to go to win above\n    long\tcount)\n{\n    win_T\t*win;\n\n    win = win_vert_neighbor(curtab, curwin, up, count);\n    if (win != NULL)\n\twin_goto(win);\n}\n\n/*\n * Get the left or right neighbor window of the specified window.\n *   left - TRUE for the left neighbor\n *   count - nth neighbor window\n * Returns the specified window if the neighbor is not found.\n */\n    win_T *\nwin_horz_neighbor(tabpage_T *tp, win_T *wp, int left, long count)\n{\n    frame_T\t*fr;\n    frame_T\t*nfr;\n    frame_T\t*foundfr;\n\n    foundfr = wp->w_frame;\n    while (count--)\n    {\n\t/*\n\t * First go upwards in the tree of frames until we find a left or\n\t * right neighbor.\n\t */\n\tfr = foundfr;\n\tfor (;;)\n\t{\n\t    if (fr == tp->tp_topframe)\n\t\tgoto end;\n\t    if (left)\n\t\tnfr = fr->fr_prev;\n\t    else\n\t\tnfr = fr->fr_next;\n\t    if (fr->fr_parent->fr_layout == FR_ROW && nfr != NULL)\n\t\tbreak;\n\t    fr = fr->fr_parent;\n\t}\n\n\t/*\n\t * Now go downwards to find the leftmost or rightmost frame in it.\n\t */\n\tfor (;;)\n\t{\n\t    if (nfr->fr_layout == FR_LEAF)\n\t    {\n\t\tfoundfr = nfr;\n\t\tbreak;\n\t    }\n\t    fr = nfr->fr_child;\n\t    if (nfr->fr_layout == FR_COL)\n\t    {\n\t\t/* Find the frame at the cursor row. */\n\t\twhile (fr->fr_next != NULL\n\t\t\t&& frame2win(fr)->w_winrow + fr->fr_height\n\t\t\t\t\t <= wp->w_winrow + wp->w_wrow)\n\t\t    fr = fr->fr_next;\n\t    }\n\t    if (nfr->fr_layout == FR_ROW && left)\n\t\twhile (fr->fr_next != NULL)\n\t\t    fr = fr->fr_next;\n\t    nfr = fr;\n\t}\n    }\nend:\n    return foundfr != NULL ? foundfr->fr_win : NULL;\n}\n\n/*\n * Move to left or right window.\n */\n    static void\nwin_goto_hor(\n    int\t\tleft,\t\t// TRUE to go to left win\n    long\tcount)\n{\n    win_T\t*win;\n\n    win = win_horz_neighbor(curtab, curwin, left, count);\n    if (win != NULL)\n\twin_goto(win);\n}\n\n/*\n * Make window \"wp\" the current window.\n */\n    void\nwin_enter(win_T *wp, int undo_sync)\n{\n    win_enter_ext(wp, undo_sync, FALSE, FALSE, TRUE, TRUE);\n}\n\n/*\n * Make window wp the current window.\n * Can be called with \"curwin_invalid\" TRUE, which means that curwin has just\n * been closed and isn't valid.\n */\n    static void\nwin_enter_ext(\n    win_T\t*wp,\n    int\t\tundo_sync,\n    int\t\tcurwin_invalid,\n    int\t\ttrigger_new_autocmds,\n    int\t\ttrigger_enter_autocmds,\n    int\t\ttrigger_leave_autocmds)\n{\n    int\t\tother_buffer = FALSE;\n\n    if (wp == curwin && !curwin_invalid)\t/* nothing to do */\n\treturn;\n\n#ifdef FEAT_JOB_CHANNEL\n    if (!curwin_invalid)\n\tleaving_window(curwin);\n#endif\n\n    if (!curwin_invalid && trigger_leave_autocmds)\n    {\n\t/*\n\t * Be careful: If autocommands delete the window, return now.\n\t */\n\tif (wp->w_buffer != curbuf)\n\t{\n\t    apply_autocmds(EVENT_BUFLEAVE, NULL, NULL, FALSE, curbuf);\n\t    other_buffer = TRUE;\n\t    if (!win_valid(wp))\n\t\treturn;\n\t}\n\tapply_autocmds(EVENT_WINLEAVE, NULL, NULL, FALSE, curbuf);\n\tif (!win_valid(wp))\n\t    return;\n#ifdef FEAT_EVAL\n\t/* autocmds may abort script processing */\n\tif (aborting())\n\t    return;\n#endif\n    }\n\n    /* sync undo before leaving the current buffer */\n    if (undo_sync && curbuf != wp->w_buffer)\n\tu_sync(FALSE);\n\n    /* Might need to scroll the old window before switching, e.g., when the\n     * cursor was moved. */\n    update_topline();\n\n    /* may have to copy the buffer options when 'cpo' contains 'S' */\n    if (wp->w_buffer != curbuf)\n\tbuf_copy_options(wp->w_buffer, BCO_ENTER | BCO_NOHELP);\n    if (!curwin_invalid)\n    {\n\tprevwin = curwin;\t/* remember for CTRL-W p */\n\tcurwin->w_redr_status = TRUE;\n    }\n    curwin = wp;\n    curbuf = wp->w_buffer;\n    check_cursor();\n    if (!virtual_active())\n\tcurwin->w_cursor.coladd = 0;\n    changed_line_abv_curs();\t/* assume cursor position needs updating */\n\n    if (curwin->w_localdir != NULL || curtab->tp_localdir != NULL)\n    {\n\tchar_u\t*dirname;\n\n\t// Window or tab has a local directory: Save current directory as\n\t// global directory (unless that was done already) and change to the\n\t// local directory.\n\tif (globaldir == NULL)\n\t{\n\t    char_u\tcwd[MAXPATHL];\n\n\t    if (mch_dirname(cwd, MAXPATHL) == OK)\n\t\tglobaldir = vim_strsave(cwd);\n\t}\n\tif (curwin->w_localdir != NULL)\n\t    dirname = curwin->w_localdir;\n\telse\n\t    dirname = curtab->tp_localdir;\n\n\tif (mch_chdir((char *)dirname) == 0)\n\t    shorten_fnames(TRUE);\n    }\n    else if (globaldir != NULL)\n    {\n\t/* Window doesn't have a local directory and we are not in the global\n\t * directory: Change to the global directory. */\n\tvim_ignored = mch_chdir((char *)globaldir);\n\tVIM_CLEAR(globaldir);\n\tshorten_fnames(TRUE);\n    }\n\n#ifdef FEAT_JOB_CHANNEL\n    entering_window(curwin);\n#endif\n    // Careful: autocommands may close the window and make \"wp\" invalid\n    if (trigger_new_autocmds)\n\tapply_autocmds(EVENT_WINNEW, NULL, NULL, FALSE, curbuf);\n    if (trigger_enter_autocmds)\n    {\n\tapply_autocmds(EVENT_WINENTER, NULL, NULL, FALSE, curbuf);\n\tif (other_buffer)\n\t    apply_autocmds(EVENT_BUFENTER, NULL, NULL, FALSE, curbuf);\n    }\n\n#ifdef FEAT_TITLE\n    maketitle();\n#endif\n    curwin->w_redr_status = TRUE;\n#ifdef FEAT_TERMINAL\n    if (bt_terminal(curwin->w_buffer))\n\t// terminal is likely in another mode\n\tredraw_mode = TRUE;\n#endif\n    redraw_tabline = TRUE;\n    if (restart_edit)\n\tredraw_later(VALID);\t/* causes status line redraw */\n\n    /* set window height to desired minimal value */\n    if (curwin->w_height < p_wh && !curwin->w_p_wfh\n#ifdef FEAT_TEXT_PROP\n\t    && !popup_is_popup(curwin)\n#endif\n\t    )\n\twin_setheight((int)p_wh);\n    else if (curwin->w_height == 0)\n\twin_setheight(1);\n\n    /* set window width to desired minimal value */\n    if (curwin->w_width < p_wiw && !curwin->w_p_wfw)\n\twin_setwidth((int)p_wiw);\n\n    setmouse();\t\t\t// in case jumped to/from help buffer\n\n    /* Change directories when the 'acd' option is set. */\n    DO_AUTOCHDIR;\n}\n\n\n/*\n * Jump to the first open window that contains buffer \"buf\", if one exists.\n * Returns a pointer to the window found, otherwise NULL.\n */\n    win_T *\nbuf_jump_open_win(buf_T *buf)\n{\n    win_T\t*wp = NULL;\n\n    if (curwin->w_buffer == buf)\n\twp = curwin;\n    else\n\tFOR_ALL_WINDOWS(wp)\n\t    if (wp->w_buffer == buf)\n\t\tbreak;\n    if (wp != NULL)\n\twin_enter(wp, FALSE);\n    return wp;\n}\n\n/*\n * Jump to the first open window in any tab page that contains buffer \"buf\",\n * if one exists.\n * Returns a pointer to the window found, otherwise NULL.\n */\n    win_T *\nbuf_jump_open_tab(buf_T *buf)\n{\n    win_T\t*wp = buf_jump_open_win(buf);\n    tabpage_T\t*tp;\n\n    if (wp != NULL)\n\treturn wp;\n\n    FOR_ALL_TABPAGES(tp)\n\tif (tp != curtab)\n\t{\n\t    for (wp = tp->tp_firstwin; wp != NULL; wp = wp->w_next)\n\t\tif (wp->w_buffer == buf)\n\t\t    break;\n\t    if (wp != NULL)\n\t    {\n\t\tgoto_tabpage_win(tp, wp);\n\t\tif (curwin != wp)\n\t\t    wp = NULL;\t/* something went wrong */\n\t\tbreak;\n\t    }\n\t}\n    return wp;\n}\n\nstatic int last_win_id = LOWEST_WIN_ID - 1;\n\n/*\n * Allocate a window structure and link it in the window list when \"hidden\" is\n * FALSE.\n */\n    static win_T *\nwin_alloc(win_T *after UNUSED, int hidden UNUSED)\n{\n    win_T\t*new_wp;\n\n    /*\n     * allocate window structure and linesizes arrays\n     */\n    new_wp = ALLOC_CLEAR_ONE(win_T);\n    if (new_wp == NULL)\n\treturn NULL;\n\n    if (win_alloc_lines(new_wp) == FAIL)\n    {\n\tvim_free(new_wp);\n\treturn NULL;\n    }\n\n    new_wp->w_id = ++last_win_id;\n\n#ifdef FEAT_EVAL\n    /* init w: variables */\n    new_wp->w_vars = dict_alloc();\n    if (new_wp->w_vars == NULL)\n    {\n\twin_free_lsize(new_wp);\n\tvim_free(new_wp);\n\treturn NULL;\n    }\n    init_var_dict(new_wp->w_vars, &new_wp->w_winvar, VAR_SCOPE);\n#endif\n\n    /* Don't execute autocommands while the window is not properly\n     * initialized yet.  gui_create_scrollbar() may trigger a FocusGained\n     * event. */\n    block_autocmds();\n\n    /*\n     * link the window in the window list\n     */\n    if (!hidden)\n\twin_append(after, new_wp);\n    new_wp->w_wincol = 0;\n    new_wp->w_width = Columns;\n\n    /* position the display and the cursor at the top of the file. */\n    new_wp->w_topline = 1;\n#ifdef FEAT_DIFF\n    new_wp->w_topfill = 0;\n#endif\n    new_wp->w_botline = 2;\n    new_wp->w_cursor.lnum = 1;\n    new_wp->w_scbind_pos = 1;\n\n    // use global option value for global-local options\n    new_wp->w_p_so = -1;\n    new_wp->w_p_siso = -1;\n\n    /* We won't calculate w_fraction until resizing the window */\n    new_wp->w_fraction = 0;\n    new_wp->w_prev_fraction_row = -1;\n\n#ifdef FEAT_GUI\n    if (gui.in_use)\n    {\n\tgui_create_scrollbar(&new_wp->w_scrollbars[SBAR_LEFT],\n\t\tSBAR_LEFT, new_wp);\n\tgui_create_scrollbar(&new_wp->w_scrollbars[SBAR_RIGHT],\n\t\tSBAR_RIGHT, new_wp);\n    }\n#endif\n#ifdef FEAT_FOLDING\n    foldInitWin(new_wp);\n#endif\n    unblock_autocmds();\n#ifdef FEAT_SEARCH_EXTRA\n    new_wp->w_match_head = NULL;\n    new_wp->w_next_match_id = 4;\n#endif\n    return new_wp;\n}\n\n/*\n * Remove window 'wp' from the window list and free the structure.\n */\n    static void\nwin_free(\n    win_T\t*wp,\n    tabpage_T\t*tp)\t\t/* tab page \"win\" is in, NULL for current */\n{\n    int\t\ti;\n    buf_T\t*buf;\n    wininfo_T\t*wip;\n\n#ifdef FEAT_FOLDING\n    clearFolding(wp);\n#endif\n\n    /* reduce the reference count to the argument list. */\n    alist_unlink(wp->w_alist);\n\n    /* Don't execute autocommands while the window is halfway being deleted.\n     * gui_mch_destroy_scrollbar() may trigger a FocusGained event. */\n    block_autocmds();\n\n#ifdef FEAT_LUA\n    lua_window_free(wp);\n#endif\n\n#ifdef FEAT_MZSCHEME\n    mzscheme_window_free(wp);\n#endif\n\n#ifdef FEAT_PERL\n    perl_win_free(wp);\n#endif\n\n#ifdef FEAT_PYTHON\n    python_window_free(wp);\n#endif\n\n#ifdef FEAT_PYTHON3\n    python3_window_free(wp);\n#endif\n\n#ifdef FEAT_TCL\n    tcl_window_free(wp);\n#endif\n\n#ifdef FEAT_RUBY\n    ruby_window_free(wp);\n#endif\n\n    clear_winopt(&wp->w_onebuf_opt);\n    clear_winopt(&wp->w_allbuf_opt);\n\n#ifdef FEAT_EVAL\n    vars_clear(&wp->w_vars->dv_hashtab);\t/* free all w: variables */\n    hash_init(&wp->w_vars->dv_hashtab);\n    unref_var_dict(wp->w_vars);\n#endif\n\n    {\n\ttabpage_T\t*ttp;\n\n\tif (prevwin == wp)\n\t    prevwin = NULL;\n\tFOR_ALL_TABPAGES(ttp)\n\t    if (ttp->tp_prevwin == wp)\n\t\tttp->tp_prevwin = NULL;\n    }\n    win_free_lsize(wp);\n\n    for (i = 0; i < wp->w_tagstacklen; ++i)\n    {\n\tvim_free(wp->w_tagstack[i].tagname);\n\tvim_free(wp->w_tagstack[i].user_data);\n    }\n    vim_free(wp->w_localdir);\n\n    /* Remove the window from the b_wininfo lists, it may happen that the\n     * freed memory is re-used for another window. */\n    FOR_ALL_BUFFERS(buf)\n\tfor (wip = buf->b_wininfo; wip != NULL; wip = wip->wi_next)\n\t    if (wip->wi_win == wp)\n\t\twip->wi_win = NULL;\n\n#ifdef FEAT_SEARCH_EXTRA\n    clear_matches(wp);\n#endif\n\n#ifdef FEAT_JUMPLIST\n    free_jumplist(wp);\n#endif\n\n#ifdef FEAT_QUICKFIX\n    qf_free_all(wp);\n#endif\n\n#ifdef FEAT_GUI\n    if (gui.in_use)\n    {\n\tgui_mch_destroy_scrollbar(&wp->w_scrollbars[SBAR_LEFT]);\n\tgui_mch_destroy_scrollbar(&wp->w_scrollbars[SBAR_RIGHT]);\n    }\n#endif /* FEAT_GUI */\n\n#ifdef FEAT_MENU\n    remove_winbar(wp);\n#endif\n#ifdef FEAT_TEXT_PROP\n    free_callback(&wp->w_close_cb);\n    free_callback(&wp->w_filter_cb);\n    for (i = 0; i < 4; ++i)\n\tVIM_CLEAR(wp->w_border_highlight[i]);\n    vim_free(wp->w_scrollbar_highlight);\n    vim_free(wp->w_thumb_highlight);\n    vim_free(wp->w_popup_title);\n    list_unref(wp->w_popup_mask);\n    vim_free(wp->w_popup_mask_cells);\n#endif\n\n#ifdef FEAT_SYN_HL\n    vim_free(wp->w_p_cc_cols);\n#endif\n\n    if (win_valid_any_tab(wp))\n\twin_remove(wp, tp);\n    if (autocmd_busy)\n    {\n\twp->w_next = au_pending_free_win;\n\tau_pending_free_win = wp;\n    }\n    else\n\tvim_free(wp);\n\n    unblock_autocmds();\n}\n\n/*\n * Return TRUE if \"wp\" is not in the list of windows: the autocmd window or a\n * popup window.\n */\n    static int\nwin_unlisted(win_T *wp)\n{\n    return wp == aucmd_win || WIN_IS_POPUP(wp);\n}\n\n#if defined(FEAT_TEXT_PROP) || defined(PROTO)\n/*\n * Free a popup window.  This does not take the window out of the window list\n * and assumes there is only one toplevel frame, no split.\n */\n    void\nwin_free_popup(win_T *win)\n{\n    if (bt_popup(win->w_buffer))\n\twin_close_buffer(win, DOBUF_WIPE_REUSE, FALSE);\n    else\n\tclose_buffer(win, win->w_buffer, 0, FALSE);\n# if defined(FEAT_TIMERS)\n    if (win->w_popup_timer != NULL)\n\tstop_timer(win->w_popup_timer);\n# endif\n    vim_free(win->w_frame);\n    win_free(win, NULL);\n}\n#endif\n\n/*\n * Append window \"wp\" in the window list after window \"after\".\n */\n    static void\nwin_append(win_T *after, win_T *wp)\n{\n    win_T\t*before;\n\n    if (after == NULL)\t    /* after NULL is in front of the first */\n\tbefore = firstwin;\n    else\n\tbefore = after->w_next;\n\n    wp->w_next = before;\n    wp->w_prev = after;\n    if (after == NULL)\n\tfirstwin = wp;\n    else\n\tafter->w_next = wp;\n    if (before == NULL)\n\tlastwin = wp;\n    else\n\tbefore->w_prev = wp;\n}\n\n/*\n * Remove a window from the window list.\n */\n    void\nwin_remove(\n    win_T\t*wp,\n    tabpage_T\t*tp)\t\t/* tab page \"win\" is in, NULL for current */\n{\n    if (wp->w_prev != NULL)\n\twp->w_prev->w_next = wp->w_next;\n    else if (tp == NULL)\n\tfirstwin = curtab->tp_firstwin = wp->w_next;\n    else\n\ttp->tp_firstwin = wp->w_next;\n\n    if (wp->w_next != NULL)\n\twp->w_next->w_prev = wp->w_prev;\n    else if (tp == NULL)\n\tlastwin = curtab->tp_lastwin = wp->w_prev;\n    else\n\ttp->tp_lastwin = wp->w_prev;\n}\n\n/*\n * Append frame \"frp\" in a frame list after frame \"after\".\n */\n    static void\nframe_append(frame_T *after, frame_T *frp)\n{\n    frp->fr_next = after->fr_next;\n    after->fr_next = frp;\n    if (frp->fr_next != NULL)\n\tfrp->fr_next->fr_prev = frp;\n    frp->fr_prev = after;\n}\n\n/*\n * Insert frame \"frp\" in a frame list before frame \"before\".\n */\n    static void\nframe_insert(frame_T *before, frame_T *frp)\n{\n    frp->fr_next = before;\n    frp->fr_prev = before->fr_prev;\n    before->fr_prev = frp;\n    if (frp->fr_prev != NULL)\n\tfrp->fr_prev->fr_next = frp;\n    else\n\tfrp->fr_parent->fr_child = frp;\n}\n\n/*\n * Remove a frame from a frame list.\n */\n    static void\nframe_remove(frame_T *frp)\n{\n    if (frp->fr_prev != NULL)\n\tfrp->fr_prev->fr_next = frp->fr_next;\n    else\n    {\n\tfrp->fr_parent->fr_child = frp->fr_next;\n\t/* special case: topframe->fr_child == frp */\n\tif (topframe->fr_child == frp)\n\t    topframe->fr_child = frp->fr_next;\n    }\n    if (frp->fr_next != NULL)\n\tfrp->fr_next->fr_prev = frp->fr_prev;\n}\n\n/*\n * Allocate w_lines[] for window \"wp\".\n * Return FAIL for failure, OK for success.\n */\n    int\nwin_alloc_lines(win_T *wp)\n{\n    wp->w_lines_valid = 0;\n    wp->w_lines = ALLOC_CLEAR_MULT(wline_T, Rows );\n    if (wp->w_lines == NULL)\n\treturn FAIL;\n    return OK;\n}\n\n/*\n * free lsize arrays for a window\n */\n    void\nwin_free_lsize(win_T *wp)\n{\n    /* TODO: why would wp be NULL here? */\n    if (wp != NULL)\n\tVIM_CLEAR(wp->w_lines);\n}\n\n/*\n * Called from win_new_shellsize() after Rows changed.\n * This only does the current tab page, others must be done when made active.\n */\n    void\nshell_new_rows(void)\n{\n    int\t\th = (int)ROWS_AVAIL;\n\n    if (firstwin == NULL)\t/* not initialized yet */\n\treturn;\n    if (h < frame_minheight(topframe, NULL))\n\th = frame_minheight(topframe, NULL);\n\n    /* First try setting the heights of windows with 'winfixheight'.  If\n     * that doesn't result in the right height, forget about that option. */\n    frame_new_height(topframe, h, FALSE, TRUE);\n    if (!frame_check_height(topframe, h))\n\tframe_new_height(topframe, h, FALSE, FALSE);\n\n    (void)win_comp_pos();\t\t/* recompute w_winrow and w_wincol */\n    compute_cmdrow();\n    curtab->tp_ch_used = p_ch;\n\n#if 0\n    /* Disabled: don't want making the screen smaller make a window larger. */\n    if (p_ea)\n\twin_equal(curwin, FALSE, 'v');\n#endif\n}\n\n/*\n * Called from win_new_shellsize() after Columns changed.\n */\n    void\nshell_new_columns(void)\n{\n    if (firstwin == NULL)\t/* not initialized yet */\n\treturn;\n\n    /* First try setting the widths of windows with 'winfixwidth'.  If that\n     * doesn't result in the right width, forget about that option. */\n    frame_new_width(topframe, (int)Columns, FALSE, TRUE);\n    if (!frame_check_width(topframe, Columns))\n\tframe_new_width(topframe, (int)Columns, FALSE, FALSE);\n\n    (void)win_comp_pos();\t\t/* recompute w_winrow and w_wincol */\n#if 0\n    /* Disabled: don't want making the screen smaller make a window larger. */\n    if (p_ea)\n\twin_equal(curwin, FALSE, 'h');\n#endif\n}\n\n#if defined(FEAT_CMDWIN) || defined(PROTO)\n/*\n * Save the size of all windows in \"gap\".\n */\n    void\nwin_size_save(garray_T *gap)\n\n{\n    win_T\t*wp;\n\n    ga_init2(gap, (int)sizeof(int), 1);\n    if (ga_grow(gap, win_count() * 2) == OK)\n\tFOR_ALL_WINDOWS(wp)\n\t{\n\t    ((int *)gap->ga_data)[gap->ga_len++] =\n\t\t\t\t\t       wp->w_width + wp->w_vsep_width;\n\t    ((int *)gap->ga_data)[gap->ga_len++] = wp->w_height;\n\t}\n}\n\n/*\n * Restore window sizes, but only if the number of windows is still the same.\n * Does not free the growarray.\n */\n    void\nwin_size_restore(garray_T *gap)\n{\n    win_T\t*wp;\n    int\t\ti, j;\n\n    if (win_count() * 2 == gap->ga_len)\n    {\n\t/* The order matters, because frames contain other frames, but it's\n\t * difficult to get right. The easy way out is to do it twice. */\n\tfor (j = 0; j < 2; ++j)\n\t{\n\t    i = 0;\n\t    FOR_ALL_WINDOWS(wp)\n\t    {\n\t\tframe_setwidth(wp->w_frame, ((int *)gap->ga_data)[i++]);\n\t\twin_setheight_win(((int *)gap->ga_data)[i++], wp);\n\t    }\n\t}\n\t/* recompute the window positions */\n\t(void)win_comp_pos();\n    }\n}\n#endif /* FEAT_CMDWIN */\n\n/*\n * Update the position for all windows, using the width and height of the\n * frames.\n * Returns the row just after the last window.\n */\n    int\nwin_comp_pos(void)\n{\n    int\t\trow = tabline_height();\n    int\t\tcol = 0;\n\n    frame_comp_pos(topframe, &row, &col);\n    return row;\n}\n\n/*\n * Update the position of the windows in frame \"topfrp\", using the width and\n * height of the frames.\n * \"*row\" and \"*col\" are the top-left position of the frame.  They are updated\n * to the bottom-right position plus one.\n */\n    static void\nframe_comp_pos(frame_T *topfrp, int *row, int *col)\n{\n    win_T\t*wp;\n    frame_T\t*frp;\n    int\t\tstartcol;\n    int\t\tstartrow;\n    int\t\th;\n\n    wp = topfrp->fr_win;\n    if (wp != NULL)\n    {\n\tif (wp->w_winrow != *row || wp->w_wincol != *col)\n\t{\n\t    /* position changed, redraw */\n\t    wp->w_winrow = *row;\n\t    wp->w_wincol = *col;\n\t    redraw_win_later(wp, NOT_VALID);\n\t    wp->w_redr_status = TRUE;\n\t}\n\t/* WinBar will not show if the window height is zero */\n\th = VISIBLE_HEIGHT(wp) + wp->w_status_height;\n\t*row += h > topfrp->fr_height ? topfrp->fr_height : h;\n\t*col += wp->w_width + wp->w_vsep_width;\n    }\n    else\n    {\n\tstartrow = *row;\n\tstartcol = *col;\n\tFOR_ALL_FRAMES(frp, topfrp->fr_child)\n\t{\n\t    if (topfrp->fr_layout == FR_ROW)\n\t\t*row = startrow;\t/* all frames are at the same row */\n\t    else\n\t\t*col = startcol;\t/* all frames are at the same col */\n\t    frame_comp_pos(frp, row, col);\n\t}\n    }\n}\n\n/*\n * Set current window height and take care of repositioning other windows to\n * fit around it.\n */\n    void\nwin_setheight(int height)\n{\n    win_setheight_win(height, curwin);\n}\n\n/*\n * Set the window height of window \"win\" and take care of repositioning other\n * windows to fit around it.\n */\n    void\nwin_setheight_win(int height, win_T *win)\n{\n    int\t\trow;\n\n    if (win == curwin)\n    {\n\t/* Always keep current window at least one line high, even when\n\t * 'winminheight' is zero. */\n\tif (height < p_wmh)\n\t    height = p_wmh;\n\tif (height == 0)\n\t    height = 1;\n\theight += WINBAR_HEIGHT(curwin);\n    }\n\n    frame_setheight(win->w_frame, height + win->w_status_height);\n\n    /* recompute the window positions */\n    row = win_comp_pos();\n\n    /*\n     * If there is extra space created between the last window and the command\n     * line, clear it.\n     */\n    if (full_screen && msg_scrolled == 0 && row < cmdline_row)\n\tscreen_fill(row, cmdline_row, 0, (int)Columns, ' ', ' ', 0);\n    cmdline_row = row;\n    msg_row = row;\n    msg_col = 0;\n\n    redraw_all_later(NOT_VALID);\n}\n\n/*\n * Set the height of a frame to \"height\" and take care that all frames and\n * windows inside it are resized.  Also resize frames on the left and right if\n * the are in the same FR_ROW frame.\n *\n * Strategy:\n * If the frame is part of a FR_COL frame, try fitting the frame in that\n * frame.  If that doesn't work (the FR_COL frame is too small), recursively\n * go to containing frames to resize them and make room.\n * If the frame is part of a FR_ROW frame, all frames must be resized as well.\n * Check for the minimal height of the FR_ROW frame.\n * At the top level we can also use change the command line height.\n */\n    static void\nframe_setheight(frame_T *curfrp, int height)\n{\n    int\t\troom;\t\t/* total number of lines available */\n    int\t\ttake;\t\t/* number of lines taken from other windows */\n    int\t\troom_cmdline;\t/* lines available from cmdline */\n    int\t\trun;\n    frame_T\t*frp;\n    int\t\th;\n    int\t\troom_reserved;\n\n    /* If the height already is the desired value, nothing to do. */\n    if (curfrp->fr_height == height)\n\treturn;\n\n    if (curfrp->fr_parent == NULL)\n    {\n\t/* topframe: can only change the command line */\n\tif (height > ROWS_AVAIL)\n\t    height = ROWS_AVAIL;\n\tif (height > 0)\n\t    frame_new_height(curfrp, height, FALSE, FALSE);\n    }\n    else if (curfrp->fr_parent->fr_layout == FR_ROW)\n    {\n\t/* Row of frames: Also need to resize frames left and right of this\n\t * one.  First check for the minimal height of these. */\n\th = frame_minheight(curfrp->fr_parent, NULL);\n\tif (height < h)\n\t    height = h;\n\tframe_setheight(curfrp->fr_parent, height);\n    }\n    else\n    {\n\t/*\n\t * Column of frames: try to change only frames in this column.\n\t */\n\t/*\n\t * Do this twice:\n\t * 1: compute room available, if it's not enough try resizing the\n\t *    containing frame.\n\t * 2: compute the room available and adjust the height to it.\n\t * Try not to reduce the height of a window with 'winfixheight' set.\n\t */\n\tfor (run = 1; run <= 2; ++run)\n\t{\n\t    room = 0;\n\t    room_reserved = 0;\n\t    FOR_ALL_FRAMES(frp, curfrp->fr_parent->fr_child)\n\t    {\n\t\tif (frp != curfrp\n\t\t\t&& frp->fr_win != NULL\n\t\t\t&& frp->fr_win->w_p_wfh)\n\t\t    room_reserved += frp->fr_height;\n\t\troom += frp->fr_height;\n\t\tif (frp != curfrp)\n\t\t    room -= frame_minheight(frp, NULL);\n\t    }\n\t    if (curfrp->fr_width != Columns)\n\t\troom_cmdline = 0;\n\t    else\n\t    {\n\t\troom_cmdline = Rows - p_ch - (lastwin->w_winrow\n\t\t\t\t\t\t+ VISIBLE_HEIGHT(lastwin)\n\t\t\t\t\t\t+ lastwin->w_status_height);\n\t\tif (room_cmdline < 0)\n\t\t    room_cmdline = 0;\n\t    }\n\n\t    if (height <= room + room_cmdline)\n\t\tbreak;\n\t    if (run == 2 || curfrp->fr_width == Columns)\n\t    {\n\t\tif (height > room + room_cmdline)\n\t\t    height = room + room_cmdline;\n\t\tbreak;\n\t    }\n\t    frame_setheight(curfrp->fr_parent, height\n\t\t+ frame_minheight(curfrp->fr_parent, NOWIN) - (int)p_wmh - 1);\n\t}\n\n\t/*\n\t * Compute the number of lines we will take from others frames (can be\n\t * negative!).\n\t */\n\ttake = height - curfrp->fr_height;\n\n\t/* If there is not enough room, also reduce the height of a window\n\t * with 'winfixheight' set. */\n\tif (height > room + room_cmdline - room_reserved)\n\t    room_reserved = room + room_cmdline - height;\n\t/* If there is only a 'winfixheight' window and making the\n\t * window smaller, need to make the other window taller. */\n\tif (take < 0 && room - curfrp->fr_height < room_reserved)\n\t    room_reserved = 0;\n\n\tif (take > 0 && room_cmdline > 0)\n\t{\n\t    /* use lines from cmdline first */\n\t    if (take < room_cmdline)\n\t\troom_cmdline = take;\n\t    take -= room_cmdline;\n\t    topframe->fr_height += room_cmdline;\n\t}\n\n\t/*\n\t * set the current frame to the new height\n\t */\n\tframe_new_height(curfrp, height, FALSE, FALSE);\n\n\t/*\n\t * First take lines from the frames after the current frame.  If\n\t * that is not enough, takes lines from frames above the current\n\t * frame.\n\t */\n\tfor (run = 0; run < 2; ++run)\n\t{\n\t    if (run == 0)\n\t\tfrp = curfrp->fr_next;\t/* 1st run: start with next window */\n\t    else\n\t\tfrp = curfrp->fr_prev;\t/* 2nd run: start with prev window */\n\t    while (frp != NULL && take != 0)\n\t    {\n\t\th = frame_minheight(frp, NULL);\n\t\tif (room_reserved > 0\n\t\t\t&& frp->fr_win != NULL\n\t\t\t&& frp->fr_win->w_p_wfh)\n\t\t{\n\t\t    if (room_reserved >= frp->fr_height)\n\t\t\troom_reserved -= frp->fr_height;\n\t\t    else\n\t\t    {\n\t\t\tif (frp->fr_height - room_reserved > take)\n\t\t\t    room_reserved = frp->fr_height - take;\n\t\t\ttake -= frp->fr_height - room_reserved;\n\t\t\tframe_new_height(frp, room_reserved, FALSE, FALSE);\n\t\t\troom_reserved = 0;\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    if (frp->fr_height - take < h)\n\t\t    {\n\t\t\ttake -= frp->fr_height - h;\n\t\t\tframe_new_height(frp, h, FALSE, FALSE);\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tframe_new_height(frp, frp->fr_height - take,\n\t\t\t\t\t\t\t\tFALSE, FALSE);\n\t\t\ttake = 0;\n\t\t    }\n\t\t}\n\t\tif (run == 0)\n\t\t    frp = frp->fr_next;\n\t\telse\n\t\t    frp = frp->fr_prev;\n\t    }\n\t}\n    }\n}\n\n/*\n * Set current window width and take care of repositioning other windows to\n * fit around it.\n */\n    void\nwin_setwidth(int width)\n{\n    win_setwidth_win(width, curwin);\n}\n\n    void\nwin_setwidth_win(int width, win_T *wp)\n{\n    /* Always keep current window at least one column wide, even when\n     * 'winminwidth' is zero. */\n    if (wp == curwin)\n    {\n\tif (width < p_wmw)\n\t    width = p_wmw;\n\tif (width == 0)\n\t    width = 1;\n    }\n\n    frame_setwidth(wp->w_frame, width + wp->w_vsep_width);\n\n    /* recompute the window positions */\n    (void)win_comp_pos();\n\n    redraw_all_later(NOT_VALID);\n}\n\n/*\n * Set the width of a frame to \"width\" and take care that all frames and\n * windows inside it are resized.  Also resize frames above and below if the\n * are in the same FR_ROW frame.\n *\n * Strategy is similar to frame_setheight().\n */\n    static void\nframe_setwidth(frame_T *curfrp, int width)\n{\n    int\t\troom;\t\t/* total number of lines available */\n    int\t\ttake;\t\t/* number of lines taken from other windows */\n    int\t\trun;\n    frame_T\t*frp;\n    int\t\tw;\n    int\t\troom_reserved;\n\n    /* If the width already is the desired value, nothing to do. */\n    if (curfrp->fr_width == width)\n\treturn;\n\n    if (curfrp->fr_parent == NULL)\n\t/* topframe: can't change width */\n\treturn;\n\n    if (curfrp->fr_parent->fr_layout == FR_COL)\n    {\n\t/* Column of frames: Also need to resize frames above and below of\n\t * this one.  First check for the minimal width of these. */\n\tw = frame_minwidth(curfrp->fr_parent, NULL);\n\tif (width < w)\n\t    width = w;\n\tframe_setwidth(curfrp->fr_parent, width);\n    }\n    else\n    {\n\t/*\n\t * Row of frames: try to change only frames in this row.\n\t *\n\t * Do this twice:\n\t * 1: compute room available, if it's not enough try resizing the\n\t *    containing frame.\n\t * 2: compute the room available and adjust the width to it.\n\t */\n\tfor (run = 1; run <= 2; ++run)\n\t{\n\t    room = 0;\n\t    room_reserved = 0;\n\t    FOR_ALL_FRAMES(frp, curfrp->fr_parent->fr_child)\n\t    {\n\t\tif (frp != curfrp\n\t\t\t&& frp->fr_win != NULL\n\t\t\t&& frp->fr_win->w_p_wfw)\n\t\t    room_reserved += frp->fr_width;\n\t\troom += frp->fr_width;\n\t\tif (frp != curfrp)\n\t\t    room -= frame_minwidth(frp, NULL);\n\t    }\n\n\t    if (width <= room)\n\t\tbreak;\n\t    if (run == 2 || curfrp->fr_height >= ROWS_AVAIL)\n\t    {\n\t\tif (width > room)\n\t\t    width = room;\n\t\tbreak;\n\t    }\n\t    frame_setwidth(curfrp->fr_parent, width\n\t\t + frame_minwidth(curfrp->fr_parent, NOWIN) - (int)p_wmw - 1);\n\t}\n\n\t/*\n\t * Compute the number of lines we will take from others frames (can be\n\t * negative!).\n\t */\n\ttake = width - curfrp->fr_width;\n\n\t/* If there is not enough room, also reduce the width of a window\n\t * with 'winfixwidth' set. */\n\tif (width > room - room_reserved)\n\t    room_reserved = room - width;\n\t/* If there is only a 'winfixwidth' window and making the\n\t * window smaller, need to make the other window narrower. */\n\tif (take < 0 && room - curfrp->fr_width < room_reserved)\n\t    room_reserved = 0;\n\n\t/*\n\t * set the current frame to the new width\n\t */\n\tframe_new_width(curfrp, width, FALSE, FALSE);\n\n\t/*\n\t * First take lines from the frames right of the current frame.  If\n\t * that is not enough, takes lines from frames left of the current\n\t * frame.\n\t */\n\tfor (run = 0; run < 2; ++run)\n\t{\n\t    if (run == 0)\n\t\tfrp = curfrp->fr_next;\t/* 1st run: start with next window */\n\t    else\n\t\tfrp = curfrp->fr_prev;\t/* 2nd run: start with prev window */\n\t    while (frp != NULL && take != 0)\n\t    {\n\t\tw = frame_minwidth(frp, NULL);\n\t\tif (room_reserved > 0\n\t\t\t&& frp->fr_win != NULL\n\t\t\t&& frp->fr_win->w_p_wfw)\n\t\t{\n\t\t    if (room_reserved >= frp->fr_width)\n\t\t\troom_reserved -= frp->fr_width;\n\t\t    else\n\t\t    {\n\t\t\tif (frp->fr_width - room_reserved > take)\n\t\t\t    room_reserved = frp->fr_width - take;\n\t\t\ttake -= frp->fr_width - room_reserved;\n\t\t\tframe_new_width(frp, room_reserved, FALSE, FALSE);\n\t\t\troom_reserved = 0;\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    if (frp->fr_width - take < w)\n\t\t    {\n\t\t\ttake -= frp->fr_width - w;\n\t\t\tframe_new_width(frp, w, FALSE, FALSE);\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tframe_new_width(frp, frp->fr_width - take,\n\t\t\t\t\t\t\t\tFALSE, FALSE);\n\t\t\ttake = 0;\n\t\t    }\n\t\t}\n\t\tif (run == 0)\n\t\t    frp = frp->fr_next;\n\t\telse\n\t\t    frp = frp->fr_prev;\n\t    }\n\t}\n    }\n}\n\n/*\n * Check 'winminheight' for a valid value and reduce it if needed.\n */\n    void\nwin_setminheight(void)\n{\n    int\t\troom;\n    int\t\tneeded;\n    int\t\tfirst = TRUE;\n\n    // loop until there is a 'winminheight' that is possible\n    while (p_wmh > 0)\n    {\n\troom = Rows - p_ch;\n\tneeded = frame_minheight(topframe, NULL);\n\tif (room >= needed)\n\t    break;\n\t--p_wmh;\n\tif (first)\n\t{\n\t    emsg(_(e_noroom));\n\t    first = FALSE;\n\t}\n    }\n}\n\n/*\n * Check 'winminwidth' for a valid value and reduce it if needed.\n */\n    void\nwin_setminwidth(void)\n{\n    int\t\troom;\n    int\t\tneeded;\n    int\t\tfirst = TRUE;\n\n    // loop until there is a 'winminheight' that is possible\n    while (p_wmw > 0)\n    {\n\troom = Columns;\n\tneeded = frame_minwidth(topframe, NULL);\n\tif (room >= needed)\n\t    break;\n\t--p_wmw;\n\tif (first)\n\t{\n\t    emsg(_(e_noroom));\n\t    first = FALSE;\n\t}\n    }\n}\n\n#if defined(FEAT_MOUSE) || defined(PROTO)\n\n/*\n * Status line of dragwin is dragged \"offset\" lines down (negative is up).\n */\n    void\nwin_drag_status_line(win_T *dragwin, int offset)\n{\n    frame_T\t*curfr;\n    frame_T\t*fr;\n    int\t\troom;\n    int\t\trow;\n    int\t\tup;\t/* if TRUE, drag status line up, otherwise down */\n    int\t\tn;\n\n    fr = dragwin->w_frame;\n    curfr = fr;\n    if (fr != topframe)\t\t/* more than one window */\n    {\n\tfr = fr->fr_parent;\n\t/* When the parent frame is not a column of frames, its parent should\n\t * be. */\n\tif (fr->fr_layout != FR_COL)\n\t{\n\t    curfr = fr;\n\t    if (fr != topframe)\t/* only a row of windows, may drag statusline */\n\t\tfr = fr->fr_parent;\n\t}\n    }\n\n    /* If this is the last frame in a column, may want to resize the parent\n     * frame instead (go two up to skip a row of frames). */\n    while (curfr != topframe && curfr->fr_next == NULL)\n    {\n\tif (fr != topframe)\n\t    fr = fr->fr_parent;\n\tcurfr = fr;\n\tif (fr != topframe)\n\t    fr = fr->fr_parent;\n    }\n\n    if (offset < 0) /* drag up */\n    {\n\tup = TRUE;\n\toffset = -offset;\n\t/* sum up the room of the current frame and above it */\n\tif (fr == curfr)\n\t{\n\t    /* only one window */\n\t    room = fr->fr_height - frame_minheight(fr, NULL);\n\t}\n\telse\n\t{\n\t    room = 0;\n\t    for (fr = fr->fr_child; ; fr = fr->fr_next)\n\t    {\n\t\troom += fr->fr_height - frame_minheight(fr, NULL);\n\t\tif (fr == curfr)\n\t\t    break;\n\t    }\n\t}\n\tfr = curfr->fr_next;\t\t/* put fr at frame that grows */\n    }\n    else    /* drag down */\n    {\n\tup = FALSE;\n\t/*\n\t * Only dragging the last status line can reduce p_ch.\n\t */\n\troom = Rows - cmdline_row;\n\tif (curfr->fr_next == NULL)\n\t    room -= 1;\n\telse\n\t    room -= p_ch;\n\tif (room < 0)\n\t    room = 0;\n\t/* sum up the room of frames below of the current one */\n\tFOR_ALL_FRAMES(fr, curfr->fr_next)\n\t    room += fr->fr_height - frame_minheight(fr, NULL);\n\tfr = curfr;\t\t\t/* put fr at window that grows */\n    }\n\n    if (room < offset)\t\t/* Not enough room */\n\toffset = room;\t\t/* Move as far as we can */\n    if (offset <= 0)\n\treturn;\n\n    /*\n     * Grow frame fr by \"offset\" lines.\n     * Doesn't happen when dragging the last status line up.\n     */\n    if (fr != NULL)\n\tframe_new_height(fr, fr->fr_height + offset, up, FALSE);\n\n    if (up)\n\tfr = curfr;\t\t/* current frame gets smaller */\n    else\n\tfr = curfr->fr_next;\t/* next frame gets smaller */\n\n    /*\n     * Now make the other frames smaller.\n     */\n    while (fr != NULL && offset > 0)\n    {\n\tn = frame_minheight(fr, NULL);\n\tif (fr->fr_height - offset <= n)\n\t{\n\t    offset -= fr->fr_height - n;\n\t    frame_new_height(fr, n, !up, FALSE);\n\t}\n\telse\n\t{\n\t    frame_new_height(fr, fr->fr_height - offset, !up, FALSE);\n\t    break;\n\t}\n\tif (up)\n\t    fr = fr->fr_prev;\n\telse\n\t    fr = fr->fr_next;\n    }\n    row = win_comp_pos();\n    screen_fill(row, cmdline_row, 0, (int)Columns, ' ', ' ', 0);\n    cmdline_row = row;\n    p_ch = Rows - cmdline_row;\n    if (p_ch < 1)\n\tp_ch = 1;\n    curtab->tp_ch_used = p_ch;\n    redraw_all_later(SOME_VALID);\n    showmode();\n}\n\n/*\n * Separator line of dragwin is dragged \"offset\" lines right (negative is left).\n */\n    void\nwin_drag_vsep_line(win_T *dragwin, int offset)\n{\n    frame_T\t*curfr;\n    frame_T\t*fr;\n    int\t\troom;\n    int\t\tleft;\t/* if TRUE, drag separator line left, otherwise right */\n    int\t\tn;\n\n    fr = dragwin->w_frame;\n    if (fr == topframe)\t\t/* only one window (cannot happen?) */\n\treturn;\n    curfr = fr;\n    fr = fr->fr_parent;\n    /* When the parent frame is not a row of frames, its parent should be. */\n    if (fr->fr_layout != FR_ROW)\n    {\n\tif (fr == topframe)\t/* only a column of windows (cannot happen?) */\n\t    return;\n\tcurfr = fr;\n\tfr = fr->fr_parent;\n    }\n\n    /* If this is the last frame in a row, may want to resize a parent\n     * frame instead. */\n    while (curfr->fr_next == NULL)\n    {\n\tif (fr == topframe)\n\t    break;\n\tcurfr = fr;\n\tfr = fr->fr_parent;\n\tif (fr != topframe)\n\t{\n\t    curfr = fr;\n\t    fr = fr->fr_parent;\n\t}\n    }\n\n    if (offset < 0) /* drag left */\n    {\n\tleft = TRUE;\n\toffset = -offset;\n\t/* sum up the room of the current frame and left of it */\n\troom = 0;\n\tfor (fr = fr->fr_child; ; fr = fr->fr_next)\n\t{\n\t    room += fr->fr_width - frame_minwidth(fr, NULL);\n\t    if (fr == curfr)\n\t\tbreak;\n\t}\n\tfr = curfr->fr_next;\t\t/* put fr at frame that grows */\n    }\n    else    /* drag right */\n    {\n\tleft = FALSE;\n\t/* sum up the room of frames right of the current one */\n\troom = 0;\n\tFOR_ALL_FRAMES(fr, curfr->fr_next)\n\t    room += fr->fr_width - frame_minwidth(fr, NULL);\n\tfr = curfr;\t\t\t/* put fr at window that grows */\n    }\n\n    if (room < offset)\t\t/* Not enough room */\n\toffset = room;\t\t/* Move as far as we can */\n    if (offset <= 0)\t\t/* No room at all, quit. */\n\treturn;\n    if (fr == NULL)\n\treturn;\t\t\t/* Safety check, should not happen. */\n\n    /* grow frame fr by offset lines */\n    frame_new_width(fr, fr->fr_width + offset, left, FALSE);\n\n    /* shrink other frames: current and at the left or at the right */\n    if (left)\n\tfr = curfr;\t\t/* current frame gets smaller */\n    else\n\tfr = curfr->fr_next;\t/* next frame gets smaller */\n\n    while (fr != NULL && offset > 0)\n    {\n\tn = frame_minwidth(fr, NULL);\n\tif (fr->fr_width - offset <= n)\n\t{\n\t    offset -= fr->fr_width - n;\n\t    frame_new_width(fr, n, !left, FALSE);\n\t}\n\telse\n\t{\n\t    frame_new_width(fr, fr->fr_width - offset, !left, FALSE);\n\t    break;\n\t}\n\tif (left)\n\t    fr = fr->fr_prev;\n\telse\n\t    fr = fr->fr_next;\n    }\n    (void)win_comp_pos();\n    redraw_all_later(NOT_VALID);\n}\n#endif /* FEAT_MOUSE */\n\n#define FRACTION_MULT\t16384L\n\n/*\n * Set wp->w_fraction for the current w_wrow and w_height.\n * Has no effect when the window is less than two lines.\n */\n    void\nset_fraction(win_T *wp)\n{\n    if (wp->w_height > 1)\n\t// When cursor is in the first line the percentage is computed as if\n\t// it's halfway that line.  Thus with two lines it is 25%, with three\n\t// lines 17%, etc.  Similarly for the last line: 75%, 83%, etc.\n\twp->w_fraction = ((long)wp->w_wrow * FRACTION_MULT\n\t\t\t\t     + FRACTION_MULT / 2) / (long)wp->w_height;\n}\n\n/*\n * Set the height of a window.\n * \"height\" excludes any window toolbar.\n * This takes care of the things inside the window, not what happens to the\n * window position, the frame or to other windows.\n */\n    void\nwin_new_height(win_T *wp, int height)\n{\n    int\t\tprev_height = wp->w_height;\n\n    /* Don't want a negative height.  Happens when splitting a tiny window.\n     * Will equalize heights soon to fix it. */\n    if (height < 0)\n\theight = 0;\n    if (wp->w_height == height)\n\treturn;\t    /* nothing to do */\n\n    if (wp->w_height > 0)\n    {\n\tif (wp == curwin)\n\t    /* w_wrow needs to be valid. When setting 'laststatus' this may\n\t     * call win_new_height() recursively. */\n\t    validate_cursor();\n\tif (wp->w_height != prev_height)\n\t    return;  /* Recursive call already changed the size, bail out here\n\t\t\tto avoid the following to mess things up. */\n\tif (wp->w_wrow != wp->w_prev_fraction_row)\n\t    set_fraction(wp);\n    }\n\n    wp->w_height = height;\n    wp->w_skipcol = 0;\n\n    /* There is no point in adjusting the scroll position when exiting.  Some\n     * values might be invalid. */\n    if (!exiting)\n\tscroll_to_fraction(wp, prev_height);\n}\n\n    void\nscroll_to_fraction(win_T *wp, int prev_height)\n{\n    linenr_T\tlnum;\n    int\t\tsline, line_size;\n    int\t\theight = wp->w_height;\n\n    // Don't change w_topline in any of these cases:\n    // - window height is 0\n    // - 'scrollbind' is set and this isn't the current window\n    // - window height is sufficient to display the whole buffer and first line\n    //   is visible.\n    if (height > 0\n        && (!wp->w_p_scb || wp == curwin)\n        && (height < wp->w_buffer->b_ml.ml_line_count || wp->w_topline > 1))\n    {\n\t/*\n\t * Find a value for w_topline that shows the cursor at the same\n\t * relative position in the window as before (more or less).\n\t */\n\tlnum = wp->w_cursor.lnum;\n\tif (lnum < 1)\t\t/* can happen when starting up */\n\t    lnum = 1;\n\twp->w_wrow = ((long)wp->w_fraction * (long)height - 1L)\n\t\t\t\t\t\t\t       / FRACTION_MULT;\n\tline_size = plines_win_col(wp, lnum, (long)(wp->w_cursor.col)) - 1;\n\tsline = wp->w_wrow - line_size;\n\n\tif (sline >= 0)\n\t{\n\t    /* Make sure the whole cursor line is visible, if possible. */\n\t    int rows = plines_win(wp, lnum, FALSE);\n\n\t    if (sline > wp->w_height - rows)\n\t    {\n\t\tsline = wp->w_height - rows;\n\t\twp->w_wrow -= rows - line_size;\n\t    }\n\t}\n\n\tif (sline < 0)\n\t{\n\t    /*\n\t     * Cursor line would go off top of screen if w_wrow was this high.\n\t     * Make cursor line the first line in the window.  If not enough\n\t     * room use w_skipcol;\n\t     */\n\t    wp->w_wrow = line_size;\n\t    if (wp->w_wrow >= wp->w_height\n\t\t\t\t       && (wp->w_width - win_col_off(wp)) > 0)\n\t    {\n\t\twp->w_skipcol += wp->w_width - win_col_off(wp);\n\t\t--wp->w_wrow;\n\t\twhile (wp->w_wrow >= wp->w_height)\n\t\t{\n\t\t    wp->w_skipcol += wp->w_width - win_col_off(wp)\n\t\t\t\t\t\t\t   + win_col_off2(wp);\n\t\t    --wp->w_wrow;\n\t\t}\n\t    }\n\t}\n\telse if (sline > 0)\n\t{\n\t    while (sline > 0 && lnum > 1)\n\t    {\n#ifdef FEAT_FOLDING\n\t\thasFoldingWin(wp, lnum, &lnum, NULL, TRUE, NULL);\n\t\tif (lnum == 1)\n\t\t{\n\t\t    /* first line in buffer is folded */\n\t\t    line_size = 1;\n\t\t    --sline;\n\t\t    break;\n\t\t}\n#endif\n\t\t--lnum;\n#ifdef FEAT_DIFF\n\t\tif (lnum == wp->w_topline)\n\t\t    line_size = plines_win_nofill(wp, lnum, TRUE)\n\t\t\t\t\t\t\t      + wp->w_topfill;\n\t\telse\n#endif\n\t\t    line_size = plines_win(wp, lnum, TRUE);\n\t\tsline -= line_size;\n\t    }\n\n\t    if (sline < 0)\n\t    {\n\t\t/*\n\t\t * Line we want at top would go off top of screen.  Use next\n\t\t * line instead.\n\t\t */\n#ifdef FEAT_FOLDING\n\t\thasFoldingWin(wp, lnum, NULL, &lnum, TRUE, NULL);\n#endif\n\t\tlnum++;\n\t\twp->w_wrow -= line_size + sline;\n\t    }\n\t    else if (sline > 0)\n\t    {\n\t\t// First line of file reached, use that as topline.\n\t\tlnum = 1;\n\t\twp->w_wrow -= sline;\n\t    }\n\t}\n\tset_topline(wp, lnum);\n    }\n\n    if (wp == curwin)\n    {\n\tif (get_scrolloff_value())\n\t    update_topline();\n\tcurs_columns(FALSE);\t/* validate w_wrow */\n    }\n    if (prev_height > 0)\n\twp->w_prev_fraction_row = wp->w_wrow;\n\n    win_comp_scroll(wp);\n    redraw_win_later(wp, SOME_VALID);\n    wp->w_redr_status = TRUE;\n    invalidate_botline_win(wp);\n}\n\n/*\n * Set the width of a window.\n */\n    void\nwin_new_width(win_T *wp, int width)\n{\n    wp->w_width = width;\n    wp->w_lines_valid = 0;\n    changed_line_abv_curs_win(wp);\n    invalidate_botline_win(wp);\n    if (wp == curwin)\n    {\n\tupdate_topline();\n\tcurs_columns(TRUE);\t/* validate w_wrow */\n    }\n    redraw_win_later(wp, NOT_VALID);\n    wp->w_redr_status = TRUE;\n}\n\n    void\nwin_comp_scroll(win_T *wp)\n{\n    wp->w_p_scr = ((unsigned)wp->w_height >> 1);\n    if (wp->w_p_scr == 0)\n\twp->w_p_scr = 1;\n}\n\n/*\n * command_height: called whenever p_ch has been changed\n */\n    void\ncommand_height(void)\n{\n    int\t\th;\n    frame_T\t*frp;\n    int\t\told_p_ch = curtab->tp_ch_used;\n\n    /* Use the value of p_ch that we remembered.  This is needed for when the\n     * GUI starts up, we can't be sure in what order things happen.  And when\n     * p_ch was changed in another tab page. */\n    curtab->tp_ch_used = p_ch;\n\n    /* Find bottom frame with width of screen. */\n    frp = lastwin->w_frame;\n    while (frp->fr_width != Columns && frp->fr_parent != NULL)\n\tfrp = frp->fr_parent;\n\n    /* Avoid changing the height of a window with 'winfixheight' set. */\n    while (frp->fr_prev != NULL && frp->fr_layout == FR_LEAF\n\t\t\t\t\t\t      && frp->fr_win->w_p_wfh)\n\tfrp = frp->fr_prev;\n\n    if (starting != NO_SCREEN)\n    {\n\tcmdline_row = Rows - p_ch;\n\n\tif (p_ch > old_p_ch)\t\t    /* p_ch got bigger */\n\t{\n\t    while (p_ch > old_p_ch)\n\t    {\n\t\tif (frp == NULL)\n\t\t{\n\t\t    emsg(_(e_noroom));\n\t\t    p_ch = old_p_ch;\n\t\t    curtab->tp_ch_used = p_ch;\n\t\t    cmdline_row = Rows - p_ch;\n\t\t    break;\n\t\t}\n\t\th = frp->fr_height - frame_minheight(frp, NULL);\n\t\tif (h > p_ch - old_p_ch)\n\t\t    h = p_ch - old_p_ch;\n\t\told_p_ch += h;\n\t\tframe_add_height(frp, -h);\n\t\tfrp = frp->fr_prev;\n\t    }\n\n\t    /* Recompute window positions. */\n\t    (void)win_comp_pos();\n\n\t    /* clear the lines added to cmdline */\n\t    if (full_screen)\n\t\tscreen_fill((int)(cmdline_row), (int)Rows, 0,\n\t\t\t\t\t\t   (int)Columns, ' ', ' ', 0);\n\t    msg_row = cmdline_row;\n\t    redraw_cmdline = TRUE;\n\t    return;\n\t}\n\n\tif (msg_row < cmdline_row)\n\t    msg_row = cmdline_row;\n\tredraw_cmdline = TRUE;\n    }\n    frame_add_height(frp, (int)(old_p_ch - p_ch));\n\n    /* Recompute window positions. */\n    if (frp != lastwin->w_frame)\n\t(void)win_comp_pos();\n}\n\n/*\n * Resize frame \"frp\" to be \"n\" lines higher (negative for less high).\n * Also resize the frames it is contained in.\n */\n    static void\nframe_add_height(frame_T *frp, int n)\n{\n    frame_new_height(frp, frp->fr_height + n, FALSE, FALSE);\n    for (;;)\n    {\n\tfrp = frp->fr_parent;\n\tif (frp == NULL)\n\t    break;\n\tfrp->fr_height += n;\n    }\n}\n\n/*\n * Add or remove a status line for the bottom window(s), according to the\n * value of 'laststatus'.\n */\n    void\nlast_status(\n    int\t\tmorewin)\t/* pretend there are two or more windows */\n{\n    /* Don't make a difference between horizontal or vertical split. */\n    last_status_rec(topframe, (p_ls == 2\n\t\t\t  || (p_ls == 1 && (morewin || !ONE_WINDOW))));\n}\n\n    static void\nlast_status_rec(frame_T *fr, int statusline)\n{\n    frame_T\t*fp;\n    win_T\t*wp;\n\n    if (fr->fr_layout == FR_LEAF)\n    {\n\twp = fr->fr_win;\n\tif (wp->w_status_height != 0 && !statusline)\n\t{\n\t    /* remove status line */\n\t    win_new_height(wp, wp->w_height + 1);\n\t    wp->w_status_height = 0;\n\t    comp_col();\n\t}\n\telse if (wp->w_status_height == 0 && statusline)\n\t{\n\t    /* Find a frame to take a line from. */\n\t    fp = fr;\n\t    while (fp->fr_height <= frame_minheight(fp, NULL))\n\t    {\n\t\tif (fp == topframe)\n\t\t{\n\t\t    emsg(_(e_noroom));\n\t\t    return;\n\t\t}\n\t\t/* In a column of frames: go to frame above.  If already at\n\t\t * the top or in a row of frames: go to parent. */\n\t\tif (fp->fr_parent->fr_layout == FR_COL && fp->fr_prev != NULL)\n\t\t    fp = fp->fr_prev;\n\t\telse\n\t\t    fp = fp->fr_parent;\n\t    }\n\t    wp->w_status_height = 1;\n\t    if (fp != fr)\n\t    {\n\t\tframe_new_height(fp, fp->fr_height - 1, FALSE, FALSE);\n\t\tframe_fix_height(wp);\n\t\t(void)win_comp_pos();\n\t    }\n\t    else\n\t\twin_new_height(wp, wp->w_height - 1);\n\t    comp_col();\n\t    redraw_all_later(SOME_VALID);\n\t}\n    }\n    else if (fr->fr_layout == FR_ROW)\n    {\n\t/* vertically split windows, set status line for each one */\n\tFOR_ALL_FRAMES(fp, fr->fr_child)\n\t    last_status_rec(fp, statusline);\n    }\n    else\n    {\n\t/* horizontally split window, set status line for last one */\n\tfor (fp = fr->fr_child; fp->fr_next != NULL; fp = fp->fr_next)\n\t    ;\n\tlast_status_rec(fp, statusline);\n    }\n}\n\n/*\n * Return the number of lines used by the tab page line.\n */\n    int\ntabline_height(void)\n{\n#ifdef FEAT_GUI_TABLINE\n    /* When the GUI has the tabline then this always returns zero. */\n    if (gui_use_tabline())\n\treturn 0;\n#endif\n    switch (p_stal)\n    {\n\tcase 0: return 0;\n\tcase 1: return (first_tabpage->tp_next == NULL) ? 0 : 1;\n    }\n    return 1;\n}\n\n/*\n * Return the minimal number of rows that is needed on the screen to display\n * the current number of windows.\n */\n    int\nmin_rows(void)\n{\n    int\t\ttotal;\n    tabpage_T\t*tp;\n    int\t\tn;\n\n    if (firstwin == NULL)\t/* not initialized yet */\n\treturn MIN_LINES;\n\n    total = 0;\n    FOR_ALL_TABPAGES(tp)\n    {\n\tn = frame_minheight(tp->tp_topframe, NULL);\n\tif (total < n)\n\t    total = n;\n    }\n    total += tabline_height();\n    total += 1;\t\t/* count the room for the command line */\n    return total;\n}\n\n/*\n * Return TRUE if there is only one window (in the current tab page), not\n * counting a help or preview window, unless it is the current window.\n * Does not count unlisted windows.\n */\n    int\nonly_one_window(void)\n{\n    int\t\tcount = 0;\n    win_T\t*wp;\n\n    /* If there is another tab page there always is another window. */\n    if (first_tabpage->tp_next != NULL)\n\treturn FALSE;\n\n    FOR_ALL_WINDOWS(wp)\n\tif (wp->w_buffer != NULL\n\t\t&& (!((bt_help(wp->w_buffer) && !bt_help(curbuf))\n# ifdef FEAT_QUICKFIX\n\t\t    || wp->w_p_pvw\n# endif\n\t     ) || wp == curwin) && wp != aucmd_win)\n\t    ++count;\n    return (count <= 1);\n}\n\n/*\n * Correct the cursor line number in other windows.  Used after changing the\n * current buffer, and before applying autocommands.\n * When \"do_curwin\" is TRUE, also check current window.\n */\n    void\ncheck_lnums(int do_curwin)\n{\n    win_T\t*wp;\n    tabpage_T\t*tp;\n\n    FOR_ALL_TAB_WINDOWS(tp, wp)\n\tif ((do_curwin || wp != curwin) && wp->w_buffer == curbuf)\n\t{\n\t    // save the original cursor position and topline\n\t    wp->w_save_cursor.w_cursor_save = wp->w_cursor;\n\t    wp->w_save_cursor.w_topline_save = wp->w_topline;\n\n\t    if (wp->w_cursor.lnum > curbuf->b_ml.ml_line_count)\n\t\twp->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n\t    if (wp->w_topline > curbuf->b_ml.ml_line_count)\n\t\twp->w_topline = curbuf->b_ml.ml_line_count;\n\n\t    // save the corrected cursor position and topline\n\t    wp->w_save_cursor.w_cursor_corr = wp->w_cursor;\n\t    wp->w_save_cursor.w_topline_corr = wp->w_topline;\n\t}\n}\n\n/*\n * Reset cursor and topline to its stored values from check_lnums().\n * check_lnums() must have been called first!\n */\n    void\nreset_lnums()\n{\n    win_T\t*wp;\n    tabpage_T\t*tp;\n\n    FOR_ALL_TAB_WINDOWS(tp, wp)\n\tif (wp->w_buffer == curbuf)\n\t{\n\t    // Restore the value if the autocommand didn't change it.\n\t    if (EQUAL_POS(wp->w_save_cursor.w_cursor_corr, wp->w_cursor))\n\t\twp->w_cursor = wp->w_save_cursor.w_cursor_save;\n\t    if (wp->w_save_cursor.w_topline_corr == wp->w_topline)\n\t\twp->w_topline = wp->w_save_cursor.w_topline_save;\n\t}\n}\n\n/*\n * A snapshot of the window sizes, to restore them after closing the help\n * window.\n * Only these fields are used:\n * fr_layout\n * fr_width\n * fr_height\n * fr_next\n * fr_child\n * fr_win (only valid for the old curwin, NULL otherwise)\n */\n\n/*\n * Create a snapshot of the current frame sizes.\n */\n    void\nmake_snapshot(int idx)\n{\n    clear_snapshot(curtab, idx);\n    make_snapshot_rec(topframe, &curtab->tp_snapshot[idx]);\n}\n\n    static void\nmake_snapshot_rec(frame_T *fr, frame_T **frp)\n{\n    *frp = ALLOC_CLEAR_ONE(frame_T);\n    if (*frp == NULL)\n\treturn;\n    (*frp)->fr_layout = fr->fr_layout;\n    (*frp)->fr_width = fr->fr_width;\n    (*frp)->fr_height = fr->fr_height;\n    if (fr->fr_next != NULL)\n\tmake_snapshot_rec(fr->fr_next, &((*frp)->fr_next));\n    if (fr->fr_child != NULL)\n\tmake_snapshot_rec(fr->fr_child, &((*frp)->fr_child));\n    if (fr->fr_layout == FR_LEAF && fr->fr_win == curwin)\n\t(*frp)->fr_win = curwin;\n}\n\n/*\n * Remove any existing snapshot.\n */\n    static void\nclear_snapshot(tabpage_T *tp, int idx)\n{\n    clear_snapshot_rec(tp->tp_snapshot[idx]);\n    tp->tp_snapshot[idx] = NULL;\n}\n\n    static void\nclear_snapshot_rec(frame_T *fr)\n{\n    if (fr != NULL)\n    {\n\tclear_snapshot_rec(fr->fr_next);\n\tclear_snapshot_rec(fr->fr_child);\n\tvim_free(fr);\n    }\n}\n\n/*\n * Restore a previously created snapshot, if there is any.\n * This is only done if the screen size didn't change and the window layout is\n * still the same.\n */\n    void\nrestore_snapshot(\n    int\t\tidx,\n    int\t\tclose_curwin)\t    /* closing current window */\n{\n    win_T\t*wp;\n\n    if (curtab->tp_snapshot[idx] != NULL\n\t    && curtab->tp_snapshot[idx]->fr_width == topframe->fr_width\n\t    && curtab->tp_snapshot[idx]->fr_height == topframe->fr_height\n\t    && check_snapshot_rec(curtab->tp_snapshot[idx], topframe) == OK)\n    {\n\twp = restore_snapshot_rec(curtab->tp_snapshot[idx], topframe);\n\twin_comp_pos();\n\tif (wp != NULL && close_curwin)\n\t    win_goto(wp);\n\tredraw_all_later(NOT_VALID);\n    }\n    clear_snapshot(curtab, idx);\n}\n\n/*\n * Check if frames \"sn\" and \"fr\" have the same layout, same following frames\n * and same children.  And the window pointer is valid.\n */\n    static int\ncheck_snapshot_rec(frame_T *sn, frame_T *fr)\n{\n    if (sn->fr_layout != fr->fr_layout\n\t    || (sn->fr_next == NULL) != (fr->fr_next == NULL)\n\t    || (sn->fr_child == NULL) != (fr->fr_child == NULL)\n\t    || (sn->fr_next != NULL\n\t\t&& check_snapshot_rec(sn->fr_next, fr->fr_next) == FAIL)\n\t    || (sn->fr_child != NULL\n\t\t&& check_snapshot_rec(sn->fr_child, fr->fr_child) == FAIL)\n\t    || (sn->fr_win != NULL && !win_valid(sn->fr_win)))\n\treturn FAIL;\n    return OK;\n}\n\n/*\n * Copy the size of snapshot frame \"sn\" to frame \"fr\".  Do the same for all\n * following frames and children.\n * Returns a pointer to the old current window, or NULL.\n */\n    static win_T *\nrestore_snapshot_rec(frame_T *sn, frame_T *fr)\n{\n    win_T\t*wp = NULL;\n    win_T\t*wp2;\n\n    fr->fr_height = sn->fr_height;\n    fr->fr_width = sn->fr_width;\n    if (fr->fr_layout == FR_LEAF)\n    {\n\tframe_new_height(fr, fr->fr_height, FALSE, FALSE);\n\tframe_new_width(fr, fr->fr_width, FALSE, FALSE);\n\twp = sn->fr_win;\n    }\n    if (sn->fr_next != NULL)\n    {\n\twp2 = restore_snapshot_rec(sn->fr_next, fr->fr_next);\n\tif (wp2 != NULL)\n\t    wp = wp2;\n    }\n    if (sn->fr_child != NULL)\n    {\n\twp2 = restore_snapshot_rec(sn->fr_child, fr->fr_child);\n\tif (wp2 != NULL)\n\t    wp = wp2;\n    }\n    return wp;\n}\n\n#if defined(FEAT_GUI) || defined(PROTO)\n/*\n * Return TRUE if there is any vertically split window.\n */\n    int\nwin_hasvertsplit(void)\n{\n    frame_T\t*fr;\n\n    if (topframe->fr_layout == FR_ROW)\n\treturn TRUE;\n\n    if (topframe->fr_layout == FR_COL)\n\tFOR_ALL_FRAMES(fr, topframe->fr_child)\n\t    if (fr->fr_layout == FR_ROW)\n\t\treturn TRUE;\n\n    return FALSE;\n}\n#endif\n\n#if defined(FEAT_PYTHON) || defined(FEAT_PYTHON3) || defined(PROTO)\n    int\nget_win_number(win_T *wp, win_T *first_win)\n{\n    int\t\ti = 1;\n    win_T\t*w;\n\n    for (w = first_win; w != NULL && w != wp; w = W_NEXT(w))\n\t++i;\n\n    if (w == NULL)\n\treturn 0;\n    else\n\treturn i;\n}\n\n    int\nget_tab_number(tabpage_T *tp UNUSED)\n{\n    int\t\ti = 1;\n    tabpage_T\t*t;\n\n    for (t = first_tabpage; t != NULL && t != tp; t = t->tp_next)\n\t++i;\n\n    if (t == NULL)\n\treturn 0;\n    else\n\treturn i;\n}\n#endif\n\n/*\n * Return TRUE if \"topfrp\" and its children are at the right height.\n */\n    static int\nframe_check_height(frame_T *topfrp, int height)\n{\n    frame_T *frp;\n\n    if (topfrp->fr_height != height)\n\treturn FALSE;\n\n    if (topfrp->fr_layout == FR_ROW)\n\tFOR_ALL_FRAMES(frp, topfrp->fr_child)\n\t    if (frp->fr_height != height)\n\t\treturn FALSE;\n\n    return TRUE;\n}\n\n/*\n * Return TRUE if \"topfrp\" and its children are at the right width.\n */\n    static int\nframe_check_width(frame_T *topfrp, int width)\n{\n    frame_T *frp;\n\n    if (topfrp->fr_width != width)\n\treturn FALSE;\n\n    if (topfrp->fr_layout == FR_COL)\n\tFOR_ALL_FRAMES(frp, topfrp->fr_child)\n\t    if (frp->fr_width != width)\n\t\treturn FALSE;\n\n    return TRUE;\n}\n\n#if defined(FEAT_SYN_HL) || defined(PROTO)\n/*\n * Simple int comparison function for use with qsort()\n */\n    static int\nint_cmp(const void *a, const void *b)\n{\n    return *(const int *)a - *(const int *)b;\n}\n\n/*\n * Handle setting 'colorcolumn' or 'textwidth' in window \"wp\".\n * Returns error message, NULL if it's OK.\n */\n    char *\ncheck_colorcolumn(win_T *wp)\n{\n    char_u\t*s;\n    int\t\tcol;\n    int\t\tcount = 0;\n    int\t\tcolor_cols[256];\n    int\t\ti;\n    int\t\tj = 0;\n\n    if (wp->w_buffer == NULL)\n\treturn NULL;  // buffer was closed\n\n    for (s = wp->w_p_cc; *s != NUL && count < 255;)\n    {\n\tif (*s == '-' || *s == '+')\n\t{\n\t    // -N and +N: add to 'textwidth'\n\t    col = (*s == '-') ? -1 : 1;\n\t    ++s;\n\t    if (!VIM_ISDIGIT(*s))\n\t\treturn e_invarg;\n\t    col = col * getdigits(&s);\n\t    if (wp->w_buffer->b_p_tw == 0)\n\t\tgoto skip;  // 'textwidth' not set, skip this item\n\t    col += wp->w_buffer->b_p_tw;\n\t    if (col < 0)\n\t\tgoto skip;\n\t}\n\telse if (VIM_ISDIGIT(*s))\n\t    col = getdigits(&s);\n\telse\n\t    return e_invarg;\n\tcolor_cols[count++] = col - 1;  // 1-based to 0-based\nskip:\n\tif (*s == NUL)\n\t    break;\n\tif (*s != ',')\n\t    return e_invarg;\n\tif (*++s == NUL)\n\t    return e_invarg;  // illegal trailing comma as in \"set cc=80,\"\n    }\n\n    vim_free(wp->w_p_cc_cols);\n    if (count == 0)\n\twp->w_p_cc_cols = NULL;\n    else\n    {\n\twp->w_p_cc_cols = ALLOC_MULT(int, count + 1);\n\tif (wp->w_p_cc_cols != NULL)\n\t{\n\t    // sort the columns for faster usage on screen redraw inside\n\t    // win_line()\n\t    qsort(color_cols, count, sizeof(int), int_cmp);\n\n\t    for (i = 0; i < count; ++i)\n\t\t// skip duplicates\n\t\tif (j == 0 || wp->w_p_cc_cols[j - 1] != color_cols[i])\n\t\t    wp->w_p_cc_cols[j++] = color_cols[i];\n\t    wp->w_p_cc_cols[j] = -1;  // end marker\n\t}\n    }\n\n    return NULL;  // no error\n}\n#endif\n"], "filenames": ["src/testdir/test_autocmd.vim", "src/version.c", "src/window.c"], "buggy_code_start_loc": [2290, 755, 4643], "buggy_code_end_loc": [2290, 755, 4659], "fixing_code_start_loc": [2291, 756, 4644], "fixing_code_end_loc": [2299, 758, 4660], "type": "CWE-416", "message": "The autocmd feature in window.c in Vim before 8.1.2136 accesses freed memory.", "other": {"cve": {"id": "CVE-2019-20079", "sourceIdentifier": "cve@mitre.org", "published": "2019-12-30T01:15:12.290", "lastModified": "2020-10-20T16:04:08.370", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The autocmd feature in window.c in Vim before 8.1.2136 accesses freed memory."}, {"lang": "es", "value": "La funcionalidad autocmd en el archivo window.c en Vim versiones anteriores a la versi\u00f3n 8.1.2136, accede a la memoria liberada."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-416"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:vim:vim:*:*:*:*:*:*:*:*", "versionStartIncluding": "8.1.2121", "versionEndExcluding": "8.1.2136", "matchCriteriaId": "8BA1A77F-AC6C-4A51-A1C0-873DE3A2BF19"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:12.04:*:*:*:esm:*:*:*", "matchCriteriaId": "8D305F7A-D159-4716-AB26-5E38BB5CD991"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.04:*:*:*:esm:*:*:*", "matchCriteriaId": "815D70A8-47D3-459C-A32C-9FEACA0659D1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:lts:*:*:*", "matchCriteriaId": "F7016A2A-8365-4F1A-89A2-7A19F2BCAE5B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:19.10:*:*:*:*:*:*:*", "matchCriteriaId": "A31C8344-3E02-4EB8-8BD8-4C84B7959624"}]}]}], "references": [{"url": "https://github.com/vim/vim/commit/ec66c41d84e574baf8009dbc0bd088d2bc5b2421", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/vim/vim/compare/v8.1.2135...v8.1.2136", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://packetstormsecurity.com/files/154898", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://usn.ubuntu.com/4309-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/vim/vim/commit/ec66c41d84e574baf8009dbc0bd088d2bc5b2421"}}