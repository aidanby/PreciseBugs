{"buggy_code": ["/************************************************************************\n * Copyright (c) 2019, Gil Treibush\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License, version 2, as\n * published by the Free Software Foundation.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * General Public License for more details.\n *\n * A copy of the full GNU General Public License is included in this\n * distribution in a file called \"COPYING\" or \"LICENSE\".\n ***********************************************************************/\n\n#include <unistd.h>\n#include <string.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n#include \"src_parser.h\"\n\n#define TMP_FILE_NAME           \".gilcc-tmpfile-XXXXXX\"\n#define TMP_FILE_NAME_SIZE      22\n\n/* Parse states: */\n#define P_STATE_CODE        0\n#define P_STATE_COMMENT_C   1\n\n/* Parser buffer */\n\n#define SRC_PARSER_F_BUF_SIZE   200\n#define SRC_PARSER_TMP_BUF_SIZE 5\n\nstruct parser_buf {\n    char f_buf[SRC_PARSER_F_BUF_SIZE];\n    char tmp_buf[SRC_PARSER_TMP_BUF_SIZE];\n\n    int f_indx;\n    int tmp_indx;\n    int f_read_size;\n};\n\n#define PBUF_F_CHAR(BUF) (BUF.f_buf[BUF.f_indx])\n#define PBUF_F_REMD(BUF) (BUF.f_read_size - BUF.f_indx)\n\n#define PBUF_TMP_PREV_CHAR(BUF) (BUF.tmp_buf[BUF.tmp_indx-1])\n\nstatic inline int p_buf_refill(struct parser_buf *buf, const int input_fd)\n{\n    int read_size;\n\n    read_size = read(input_fd, buf->f_buf, SRC_PARSER_F_BUF_SIZE);\n    buf->f_indx = 0;\n    buf->f_read_size = read_size;\n    return read_size;\n}\n\nstatic inline int p_buf_push_tmp_char(struct parser_buf *buf, const char c)\n{\n    buf->tmp_buf[buf->tmp_indx++] = c;\n    buf->f_indx++;\n    return buf->tmp_indx;\n}\n\nstatic inline int p_buf_write_tmp(struct parser_buf *buf, const int output_fd)\n{\n    int write_size;\n\n    if (!buf->tmp_indx)\n        return 0;\n\n    write_size = write(output_fd, buf->tmp_buf, buf->tmp_indx);\n    buf->tmp_indx = 0;\n\n    return write_size;\n}\n\nstatic inline int p_buf_write_f_char(struct parser_buf *buf, const int output_fd)\n{\n    return write(output_fd, &buf->f_buf[buf->f_indx++], 1);\n}\n\n/* Parser impl. */\n\nstatic void print_file_full(int fd)\n{\n    char f_buf[SRC_PARSER_F_BUF_SIZE];\n    int read_size;\n\n    if (lseek(fd, 0, SEEK_SET)) {\n        fprintf(stderr, \"**Error: Could not set offset.\\n\");\n        return;\n    }\n\n    while ((read_size = read(fd, f_buf, SRC_PARSER_F_BUF_SIZE)) > 0) {\n        int read_indx = 0;\n\n        while (read_indx < read_size)\n            putchar(f_buf[read_indx++]);\n    }\n}\n\nstatic int src_parser_trans_stage_1_2_3(const int tmp_fd, const char *src, const struct trans_config cfg)\n{\n    struct parser_buf pbuf = {\n        .f_indx = 0,\n        .tmp_indx = 0,\n        .f_read_size = 0\n    };\n\n    int write_count = 0;\n    int src_fd;\n    int p_state = P_STATE_CODE;\n\n    src_fd = open(src, O_RDONLY);\n    if (src_fd == -1) {\n        fprintf(stderr, \"**Error: Could not open source file: %s.\\n\", src);\n        return -1;\n    }\n\n    while (p_buf_refill(&pbuf, src_fd) > 0) {\n\n        while (PBUF_F_REMD(pbuf)) {\n\n            switch (p_state) {\n            case P_STATE_COMMENT_C:\n\n                switch (PBUF_F_CHAR(pbuf)) {\n                case '*':\n                    p_buf_push_tmp_char(&pbuf, '*');\n                    continue;\n\n                case '/':\n                    if (pbuf.tmp_indx && (PBUF_TMP_PREV_CHAR(pbuf) == '*')) {\n                        pbuf.tmp_indx--;\n                        p_state = P_STATE_CODE;\n                    }\n                    break;\n\n                default:\n                    if (pbuf.tmp_indx && (PBUF_TMP_PREV_CHAR(pbuf) == '*'))\n                        pbuf.tmp_indx--;\n                    break;\n                }\n\n                pbuf.f_indx++;\n\n            case P_STATE_CODE:\n            default:\n\n                /* TODO: add trigraph support */\n\n                switch (PBUF_F_CHAR(pbuf)) {\n                case ' ':\n                case '\\t':\n                    if (pbuf.tmp_indx &&\n                            (PBUF_TMP_PREV_CHAR(pbuf) == ' ' || PBUF_TMP_PREV_CHAR(pbuf) == '\\t' ||\n                             PBUF_TMP_PREV_CHAR(pbuf) == '\\n'))\n                        pbuf.f_indx++;\n                    else\n                        p_buf_push_tmp_char(&pbuf, ' ');\n\n                    continue;\n\n                case '\\r':\n                case '\\n':\n                    if (pbuf.tmp_indx &&\n                            (PBUF_TMP_PREV_CHAR(pbuf) == ' ' || PBUF_TMP_PREV_CHAR(pbuf) == '\\t' ||\n                             PBUF_TMP_PREV_CHAR(pbuf) == '\\n')) {\n                        pbuf.f_indx++;\n                    } else if (pbuf.tmp_indx && \n                            (PBUF_TMP_PREV_CHAR(pbuf) == '\\\\')) {\n                        pbuf.tmp_indx--;\n                        pbuf.f_indx++;\n                    } else {\n                        p_buf_push_tmp_char(&pbuf, '\\n');\n                    }\n\n                    continue;\n\n                case '\\\\':\n                    p_buf_push_tmp_char(&pbuf, '\\\\');\n                    continue;\n\n                case '/':\n                    p_buf_push_tmp_char(&pbuf, '/');\n                    continue;\n\n                case '*':\n                    if (pbuf.tmp_indx &&\n                            (PBUF_TMP_PREV_CHAR(pbuf) == '/')) {\n                        pbuf.tmp_indx--;\n                        pbuf.f_indx++;\n                        p_state = P_STATE_COMMENT_C;\n                        continue;\n                    }\n\n                default:\n                    break;\n                }\n\n                /* TODO: check return values */\n                p_buf_write_tmp(&pbuf, tmp_fd);\n                p_buf_write_f_char(&pbuf, tmp_fd);\n            }\n        }\n    }\n\n    p_buf_write_tmp(&pbuf, tmp_fd);\n    return 0;\n}\n\nint src_parser_cpp(const char *src, const struct trans_config cfg)\n{\n    int tmp_fd;\n    char fname[TMP_FILE_NAME_SIZE];\n\n    strncpy(fname, TMP_FILE_NAME, TMP_FILE_NAME_SIZE);\n    tmp_fd = mkstemp(fname);\n    if (tmp_fd == -1) {\n        fprintf(stderr, \"**Error: could not create a working file.\\n\");\n        return -1;\n    }\n\n    src_parser_trans_stage_1_2_3(tmp_fd, src, cfg);\n\n    print_file_full(tmp_fd);\n\n    unlink(fname);\n}\n\n"], "fixing_code": ["/************************************************************************\n * Copyright (c) 2019, Gil Treibush\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License, version 2, as\n * published by the Free Software Foundation.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * General Public License for more details.\n *\n * A copy of the full GNU General Public License is included in this\n * distribution in a file called \"COPYING\" or \"LICENSE\".\n ***********************************************************************/\n\n#include <unistd.h>\n#include <string.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n#include \"src_parser.h\"\n\n#define TMP_FILE_NAME           \".gilcc-tmpfile-XXXXXX\"\n#define TMP_FILE_NAME_SIZE      22\n\n/* Parse states: */\n#define P_STATE_CODE        0\n#define P_STATE_COMMENT_C   1\n\n/* Parser buffer */\n\n#define SRC_PARSER_F_BUF_SIZE   200\n#define SRC_PARSER_TMP_BUF_SIZE 5\n\nstruct parser_buf {\n    char f_buf[SRC_PARSER_F_BUF_SIZE];\n    char tmp_buf[SRC_PARSER_TMP_BUF_SIZE];\n\n    int f_indx;\n    int tmp_indx;\n    int f_read_size;\n};\n\n#define PBUF_F_CHAR(BUF) (BUF.f_buf[BUF.f_indx])\n#define PBUF_F_REMD(BUF) (BUF.f_read_size - BUF.f_indx)\n\n#define PBUF_TMP_PREV_CHAR(BUF) (BUF.tmp_buf[BUF.tmp_indx-1])\n\nstatic inline int p_buf_refill(struct parser_buf *buf, const int input_fd)\n{\n    int read_size;\n\n    read_size = read(input_fd, buf->f_buf, SRC_PARSER_F_BUF_SIZE);\n    buf->f_indx = 0;\n    buf->f_read_size = read_size;\n    return read_size;\n}\n\nstatic inline int p_buf_push_tmp_char(struct parser_buf *buf, const char c)\n{\n    buf->tmp_buf[buf->tmp_indx++] = c;\n    buf->f_indx++;\n    return buf->tmp_indx;\n}\n\nstatic inline int p_buf_write_tmp(struct parser_buf *buf, const int output_fd)\n{\n    int write_size;\n\n    if (!buf->tmp_indx)\n        return 0;\n\n    write_size = write(output_fd, buf->tmp_buf, buf->tmp_indx);\n    buf->tmp_indx = 0;\n\n    return write_size;\n}\n\nstatic inline int p_buf_write_f_char(struct parser_buf *buf, const int output_fd)\n{\n    return write(output_fd, &buf->f_buf[buf->f_indx++], 1);\n}\n\n/* Parser impl. */\n\nstatic void print_file_full(int fd)\n{\n    char f_buf[SRC_PARSER_F_BUF_SIZE];\n    int read_size;\n\n    if (lseek(fd, 0, SEEK_SET)) {\n        fprintf(stderr, \"**Error: Could not set offset.\\n\");\n        return;\n    }\n\n    while ((read_size = read(fd, f_buf, SRC_PARSER_F_BUF_SIZE)) > 0) {\n        int read_indx = 0;\n\n        while (read_indx < read_size)\n            putchar(f_buf[read_indx++]);\n    }\n}\n\nstatic int src_parser_trans_stage_1_2_3(const int tmp_fd, const char *src, const struct trans_config cfg)\n{\n    struct parser_buf pbuf = {\n        .f_indx = 0,\n        .tmp_indx = 0,\n        .f_read_size = 0\n    };\n\n    int write_count = 0;\n    int src_fd;\n    int p_state = P_STATE_CODE;\n\n    src_fd = open(src, O_RDONLY);\n    if (src_fd == -1) {\n        fprintf(stderr, \"**Error: Could not open source file: %s.\\n\", src);\n        return -1;\n    }\n\n    while (p_buf_refill(&pbuf, src_fd) > 0) {\n\n        while (PBUF_F_REMD(pbuf)) {\n\n            switch (p_state) {\n            case P_STATE_COMMENT_C:\n\n                switch (PBUF_F_CHAR(pbuf)) {\n                case '*':\n                    p_buf_push_tmp_char(&pbuf, '*');\n                    continue;\n\n                case '/':\n                    if (pbuf.tmp_indx && (PBUF_TMP_PREV_CHAR(pbuf) == '*')) {\n                        pbuf.tmp_indx--;\n                        p_state = P_STATE_CODE;\n                    }\n                    break;\n\n                default:\n                    if (pbuf.tmp_indx && (PBUF_TMP_PREV_CHAR(pbuf) == '*'))\n                        pbuf.tmp_indx--;\n                    break;\n                }\n\n                pbuf.f_indx++;\n\n            case P_STATE_CODE:\n            default:\n\n                /* TODO: add trigraph support */\n\n                switch (PBUF_F_CHAR(pbuf)) {\n                case ' ':\n                case '\\t':\n                    if (pbuf.tmp_indx &&\n                            (PBUF_TMP_PREV_CHAR(pbuf) == ' ' || PBUF_TMP_PREV_CHAR(pbuf) == '\\t' ||\n                             PBUF_TMP_PREV_CHAR(pbuf) == '\\n'))\n                        pbuf.f_indx++;\n                    else\n                        p_buf_push_tmp_char(&pbuf, ' ');\n\n                    continue;\n\n                case '\\r':\n                case '\\n':\n                    if (pbuf.tmp_indx &&\n                            (PBUF_TMP_PREV_CHAR(pbuf) == ' ' || PBUF_TMP_PREV_CHAR(pbuf) == '\\t' ||\n                             PBUF_TMP_PREV_CHAR(pbuf) == '\\n')) {\n                        pbuf.f_indx++;\n                    } else if (pbuf.tmp_indx &&\n                            (PBUF_TMP_PREV_CHAR(pbuf) == '\\\\')) {\n                        pbuf.tmp_indx--;\n                        pbuf.f_indx++;\n                    } else {\n                        p_buf_push_tmp_char(&pbuf, '\\n');\n                    }\n\n                    continue;\n\n                case '\\\\':\n                    p_buf_write_tmp(&pbuf, tmp_fd);\n                    p_buf_push_tmp_char(&pbuf, '\\\\');\n                    continue;\n\n                case '/':\n                    p_buf_write_tmp(&pbuf, tmp_fd);\n                    p_buf_push_tmp_char(&pbuf, '/');\n                    continue;\n\n                case '*':\n                    if (pbuf.tmp_indx &&\n                            (PBUF_TMP_PREV_CHAR(pbuf) == '/')) {\n                        pbuf.tmp_indx--;\n                        pbuf.f_indx++;\n                        p_state = P_STATE_COMMENT_C;\n                        continue;\n                    }\n\n                default:\n                    break;\n                }\n\n                /* TODO: check return values */\n                p_buf_write_tmp(&pbuf, tmp_fd);\n                p_buf_write_f_char(&pbuf, tmp_fd);\n            }\n        }\n    }\n\n    p_buf_write_tmp(&pbuf, tmp_fd);\n    return 0;\n}\n\nint src_parser_cpp(const char *src, const struct trans_config cfg)\n{\n    int tmp_fd;\n    char fname[TMP_FILE_NAME_SIZE];\n\n    strncpy(fname, TMP_FILE_NAME, TMP_FILE_NAME_SIZE);\n    tmp_fd = mkstemp(fname);\n    if (tmp_fd == -1) {\n        fprintf(stderr, \"**Error: could not create a working file.\\n\");\n        return -1;\n    }\n\n    src_parser_trans_stage_1_2_3(tmp_fd, src, cfg);\n\n    print_file_full(tmp_fd);\n\n    unlink(fname);\n}\n\n"], "filenames": ["src/src_parser.c"], "buggy_code_start_loc": [174], "buggy_code_end_loc": [188], "fixing_code_start_loc": [174], "fixing_code_end_loc": [191], "type": "CWE-120", "message": "Buffer overflow vulnerability in function src_parser_trans_stage_1_2_3 trgil gilcc before commit 803969389ca9c06237075a7f8eeb1a19e6651759, allows attackers to cause a denial of service.", "other": {"cve": {"id": "CVE-2020-21572", "sourceIdentifier": "cve@mitre.org", "published": "2021-11-02T18:15:08.037", "lastModified": "2021-11-04T14:00:37.100", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Buffer overflow vulnerability in function src_parser_trans_stage_1_2_3 trgil gilcc before commit 803969389ca9c06237075a7f8eeb1a19e6651759, allows attackers to cause a denial of service."}, {"lang": "es", "value": "Una vulnerabilidad de desbordamiento de b\u00fafer en la funci\u00f3n src_parser_trans_stage_1_2_3 trgil gilcc versiones anteriores al commit 803969389ca9c06237075a7f8eeb1a19e6651759, permite a atacantes causar una denegaci\u00f3n de servicio"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-120"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:gilcc_project:gilcc:*:*:*:*:*:*:*:*", "versionEndExcluding": "2019-12-22", "matchCriteriaId": "BBB8171A-9F3D-46B6-B948-F89F365D61FD"}]}]}], "references": [{"url": "https://github.com/trgil/gilcc/commit/803969389ca9c06237075a7f8eeb1a19e6651759", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/trgil/gilcc/issues/1", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/trgil/gilcc/commit/803969389ca9c06237075a7f8eeb1a19e6651759"}}