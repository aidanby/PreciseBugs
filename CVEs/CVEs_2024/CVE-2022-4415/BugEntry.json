{"buggy_code": ["/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include <poll.h>\n#include <stdbool.h>\n#include <stddef.h>\n#include <stdint.h>\n#include <sys/types.h>\n#include <sys/uio.h>\n\n#include \"macro.h\"\n#include \"time-util.h\"\n\nint flush_fd(int fd);\n\nssize_t loop_read(int fd, void *buf, size_t nbytes, bool do_poll);\nint loop_read_exact(int fd, void *buf, size_t nbytes, bool do_poll);\nint loop_write(int fd, const void *buf, size_t nbytes, bool do_poll);\n\nint pipe_eof(int fd);\n\nint ppoll_usec(struct pollfd *fds, size_t nfds, usec_t timeout);\nint fd_wait_for_event(int fd, int event, usec_t timeout);\n\nssize_t sparse_write(int fd, const void *p, size_t sz, size_t run_length);\n\nstatic inline size_t IOVEC_TOTAL_SIZE(const struct iovec *i, size_t n) {\n        size_t r = 0;\n\n        for (size_t j = 0; j < n; j++)\n                r += i[j].iov_len;\n\n        return r;\n}\n\nstatic inline bool IOVEC_INCREMENT(struct iovec *i, size_t n, size_t k) {\n        /* Returns true if there is nothing else to send (bytes written cover all of the iovec),\n         * false if there's still work to do. */\n\n        for (size_t j = 0; j < n; j++) {\n                size_t sub;\n\n                if (i[j].iov_len == 0)\n                        continue;\n                if (k == 0)\n                        return false;\n\n                sub = MIN(i[j].iov_len, k);\n                i[j].iov_len -= sub;\n                i[j].iov_base = (uint8_t*) i[j].iov_base + sub;\n                k -= sub;\n        }\n\n        assert(k == 0); /* Anything else would mean that we wrote more bytes than available,\n                         * or the kernel reported writing more bytes than sent. */\n        return true;\n}\n\nstatic inline bool FILE_SIZE_VALID(uint64_t l) {\n        /* ftruncate() and friends take an unsigned file size, but actually cannot deal with file sizes larger than\n         * 2^63 since the kernel internally handles it as signed value. This call allows checking for this early. */\n\n        return (l >> 63) == 0;\n}\n\nstatic inline bool FILE_SIZE_VALID_OR_INFINITY(uint64_t l) {\n\n        /* Same as above, but allows one extra value: -1 as indication for infinity. */\n\n        if (l == UINT64_MAX)\n                return true;\n\n        return FILE_SIZE_VALID(l);\n\n}\n\n#define IOVEC_INIT(base, len) { .iov_base = (base), .iov_len = (len) }\n#define IOVEC_MAKE(base, len) (struct iovec) IOVEC_INIT(base, len)\n#define IOVEC_INIT_STRING(string) IOVEC_INIT((char*) string, strlen(string))\n#define IOVEC_MAKE_STRING(string) (struct iovec) IOVEC_INIT_STRING(string)\n\nchar* set_iovec_string_field(struct iovec *iovec, size_t *n_iovec, const char *field, const char *value);\nchar* set_iovec_string_field_free(struct iovec *iovec, size_t *n_iovec, const char *field, char *value);\n\nstruct iovec_wrapper {\n        struct iovec *iovec;\n        size_t count;\n};\n\nstruct iovec_wrapper *iovw_new(void);\nstruct iovec_wrapper *iovw_free(struct iovec_wrapper *iovw);\nstruct iovec_wrapper *iovw_free_free(struct iovec_wrapper *iovw);\nvoid iovw_free_contents(struct iovec_wrapper *iovw, bool free_vectors);\nint iovw_put(struct iovec_wrapper *iovw, void *data, size_t len);\nint iovw_put_string_field(struct iovec_wrapper *iovw, const char *field, const char *value);\nint iovw_put_string_field_free(struct iovec_wrapper *iovw, const char *field, char *value);\nvoid iovw_rebase(struct iovec_wrapper *iovw, char *old, char *new);\nsize_t iovw_size(struct iovec_wrapper *iovw);\n", "/* SPDX-License-Identifier: LGPL-2.1-or-later */\n\n#include <errno.h>\n#include <stdio.h>\n#include <sys/prctl.h>\n#include <sys/statvfs.h>\n#include <sys/xattr.h>\n#include <unistd.h>\n\n#include \"sd-daemon.h\"\n#include \"sd-journal.h\"\n#include \"sd-login.h\"\n#include \"sd-messages.h\"\n\n#include \"acl-util.h\"\n#include \"alloc-util.h\"\n#include \"bus-error.h\"\n#include \"capability-util.h\"\n#include \"cgroup-util.h\"\n#include \"compress.h\"\n#include \"conf-parser.h\"\n#include \"copy.h\"\n#include \"coredump-util.h\"\n#include \"coredump-vacuum.h\"\n#include \"dirent-util.h\"\n#include \"elf-util.h\"\n#include \"escape.h\"\n#include \"fd-util.h\"\n#include \"fileio.h\"\n#include \"fs-util.h\"\n#include \"io-util.h\"\n#include \"journal-importer.h\"\n#include \"journal-send.h\"\n#include \"log.h\"\n#include \"macro.h\"\n#include \"main-func.h\"\n#include \"memory-util.h\"\n#include \"mkdir-label.h\"\n#include \"parse-util.h\"\n#include \"process-util.h\"\n#include \"signal-util.h\"\n#include \"socket-util.h\"\n#include \"special.h\"\n#include \"stat-util.h\"\n#include \"string-table.h\"\n#include \"string-util.h\"\n#include \"strv.h\"\n#include \"sync-util.h\"\n#include \"tmpfile-util.h\"\n#include \"uid-alloc-range.h\"\n#include \"user-util.h\"\n\n/* The maximum size up to which we process coredumps. We use 1G on 32bit systems, and 32G on 64bit systems */\n#if __SIZEOF_POINTER__ == 4\n#define PROCESS_SIZE_MAX ((uint64_t) (1LLU*1024LLU*1024LLU*1024LLU))\n#elif __SIZEOF_POINTER__ == 8\n#define PROCESS_SIZE_MAX ((uint64_t) (32LLU*1024LLU*1024LLU*1024LLU))\n#else\n#error \"Unexpected pointer size\"\n#endif\n\n/* The maximum size up to which we leave the coredump around on disk */\n#define EXTERNAL_SIZE_MAX PROCESS_SIZE_MAX\n\n/* The maximum size up to which we store the coredump in the journal */\n#ifndef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION\n#define JOURNAL_SIZE_MAX ((size_t) (767LU*1024LU*1024LU))\n#else\n/* oss-fuzz limits memory usage. */\n#define JOURNAL_SIZE_MAX ((size_t) (10LU*1024LU*1024LU))\n#endif\n\n/* When checking for available memory and setting lower limits, don't\n * go below 4MB for writing core files to storage. */\n#define PROCESS_SIZE_MIN (4U*1024U*1024U)\n\n/* Make sure to not make this larger than the maximum journal entry\n * size. See DATA_SIZE_MAX in journal-importer.h. */\nassert_cc(JOURNAL_SIZE_MAX <= DATA_SIZE_MAX);\n\nenum {\n        /* We use these as array indexes for our process metadata cache.\n         *\n         * The first indices of the cache stores the same metadata as the ones passed by\n         * the kernel via argv[], ie the strings array passed by the kernel according to\n         * our pattern defined in /proc/sys/kernel/core_pattern (see man:core(5)). */\n\n        META_ARGV_PID,          /* %P: as seen in the initial pid namespace */\n        META_ARGV_UID,          /* %u: as seen in the initial user namespace */\n        META_ARGV_GID,          /* %g: as seen in the initial user namespace */\n        META_ARGV_SIGNAL,       /* %s: number of signal causing dump */\n        META_ARGV_TIMESTAMP,    /* %t: time of dump, expressed as seconds since the Epoch (we expand this to \u00b5s granularity) */\n        META_ARGV_RLIMIT,       /* %c: core file size soft resource limit */\n        META_ARGV_HOSTNAME,     /* %h: hostname */\n        _META_ARGV_MAX,\n\n        /* The following indexes are cached for a couple of special fields we use (and\n         * thereby need to be retrieved quickly) for naming coredump files, and attaching\n         * xattrs. Unlike the previous ones they are retrieved from the runtime\n         * environment. */\n\n        META_COMM = _META_ARGV_MAX,\n        _META_MANDATORY_MAX,\n\n        /* The rest are similar to the previous ones except that we won't fail if one of\n         * them is missing. */\n\n        META_EXE = _META_MANDATORY_MAX,\n        META_UNIT,\n        _META_MAX\n};\n\nstatic const char * const meta_field_names[_META_MAX] = {\n        [META_ARGV_PID]          = \"COREDUMP_PID=\",\n        [META_ARGV_UID]          = \"COREDUMP_UID=\",\n        [META_ARGV_GID]          = \"COREDUMP_GID=\",\n        [META_ARGV_SIGNAL]       = \"COREDUMP_SIGNAL=\",\n        [META_ARGV_TIMESTAMP]    = \"COREDUMP_TIMESTAMP=\",\n        [META_ARGV_RLIMIT]       = \"COREDUMP_RLIMIT=\",\n        [META_ARGV_HOSTNAME]     = \"COREDUMP_HOSTNAME=\",\n        [META_COMM]              = \"COREDUMP_COMM=\",\n        [META_EXE]               = \"COREDUMP_EXE=\",\n        [META_UNIT]              = \"COREDUMP_UNIT=\",\n};\n\ntypedef struct Context {\n        const char *meta[_META_MAX];\n        pid_t pid;\n        bool is_pid1;\n        bool is_journald;\n} Context;\n\ntypedef enum CoredumpStorage {\n        COREDUMP_STORAGE_NONE,\n        COREDUMP_STORAGE_EXTERNAL,\n        COREDUMP_STORAGE_JOURNAL,\n        _COREDUMP_STORAGE_MAX,\n        _COREDUMP_STORAGE_INVALID = -EINVAL,\n} CoredumpStorage;\n\nstatic const char* const coredump_storage_table[_COREDUMP_STORAGE_MAX] = {\n        [COREDUMP_STORAGE_NONE] = \"none\",\n        [COREDUMP_STORAGE_EXTERNAL] = \"external\",\n        [COREDUMP_STORAGE_JOURNAL] = \"journal\",\n};\n\nDEFINE_PRIVATE_STRING_TABLE_LOOKUP(coredump_storage, CoredumpStorage);\nstatic DEFINE_CONFIG_PARSE_ENUM(config_parse_coredump_storage, coredump_storage, CoredumpStorage, \"Failed to parse storage setting\");\n\nstatic CoredumpStorage arg_storage = COREDUMP_STORAGE_EXTERNAL;\nstatic bool arg_compress = true;\nstatic uint64_t arg_process_size_max = PROCESS_SIZE_MAX;\nstatic uint64_t arg_external_size_max = EXTERNAL_SIZE_MAX;\nstatic uint64_t arg_journal_size_max = JOURNAL_SIZE_MAX;\nstatic uint64_t arg_keep_free = UINT64_MAX;\nstatic uint64_t arg_max_use = UINT64_MAX;\n\nstatic int parse_config(void) {\n        static const ConfigTableItem items[] = {\n                { \"Coredump\", \"Storage\",          config_parse_coredump_storage,           0, &arg_storage           },\n                { \"Coredump\", \"Compress\",         config_parse_bool,                       0, &arg_compress          },\n                { \"Coredump\", \"ProcessSizeMax\",   config_parse_iec_uint64,                 0, &arg_process_size_max  },\n                { \"Coredump\", \"ExternalSizeMax\",  config_parse_iec_uint64_infinity,        0, &arg_external_size_max },\n                { \"Coredump\", \"JournalSizeMax\",   config_parse_iec_size,                   0, &arg_journal_size_max  },\n                { \"Coredump\", \"KeepFree\",         config_parse_iec_uint64,                 0, &arg_keep_free         },\n                { \"Coredump\", \"MaxUse\",           config_parse_iec_uint64,                 0, &arg_max_use           },\n                {}\n        };\n\n        return config_parse_many_nulstr(\n                        PKGSYSCONFDIR \"/coredump.conf\",\n                        CONF_PATHS_NULSTR(\"systemd/coredump.conf.d\"),\n                        \"Coredump\\0\",\n                        config_item_table_lookup, items,\n                        CONFIG_PARSE_WARN,\n                        NULL,\n                        NULL);\n}\n\nstatic uint64_t storage_size_max(void) {\n        if (arg_storage == COREDUMP_STORAGE_EXTERNAL)\n                return arg_external_size_max;\n        if (arg_storage == COREDUMP_STORAGE_JOURNAL)\n                return arg_journal_size_max;\n        assert(arg_storage == COREDUMP_STORAGE_NONE);\n        return 0;\n}\n\nstatic int fix_acl(int fd, uid_t uid) {\n\n#if HAVE_ACL\n        int r;\n\n        assert(fd >= 0);\n        assert(uid_is_valid(uid));\n\n        if (uid_is_system(uid) || uid_is_dynamic(uid) || uid == UID_NOBODY)\n                return 0;\n\n        /* Make sure normal users can read (but not write or delete) their own coredumps */\n        r = fd_add_uid_acl_permission(fd, uid, ACL_READ);\n        if (r < 0)\n                return log_error_errno(r, \"Failed to adjust ACL of the coredump: %m\");\n#endif\n\n        return 0;\n}\n\nstatic int fix_xattr(int fd, const Context *context) {\n\n        static const char * const xattrs[_META_MAX] = {\n                [META_ARGV_PID]          = \"user.coredump.pid\",\n                [META_ARGV_UID]          = \"user.coredump.uid\",\n                [META_ARGV_GID]          = \"user.coredump.gid\",\n                [META_ARGV_SIGNAL]       = \"user.coredump.signal\",\n                [META_ARGV_TIMESTAMP]    = \"user.coredump.timestamp\",\n                [META_ARGV_RLIMIT]       = \"user.coredump.rlimit\",\n                [META_ARGV_HOSTNAME]     = \"user.coredump.hostname\",\n                [META_COMM]              = \"user.coredump.comm\",\n                [META_EXE]               = \"user.coredump.exe\",\n        };\n\n        int r = 0;\n\n        assert(fd >= 0);\n\n        /* Attach some metadata to coredumps via extended\n         * attributes. Just because we can. */\n\n        for (unsigned i = 0; i < _META_MAX; i++) {\n                int k;\n\n                if (isempty(context->meta[i]) || !xattrs[i])\n                        continue;\n\n                k = fsetxattr(fd, xattrs[i], context->meta[i], strlen(context->meta[i]), XATTR_CREATE);\n                if (k < 0 && r == 0)\n                        r = -errno;\n        }\n\n        return r;\n}\n\n#define filename_escape(s) xescape((s), \"./ \")\n\nstatic const char *coredump_tmpfile_name(const char *s) {\n        return s ? s : \"(unnamed temporary file)\";\n}\n\nstatic int fix_permissions(\n                int fd,\n                const char *filename,\n                const char *target,\n                const Context *context,\n                uid_t uid) {\n\n        int r;\n\n        assert(fd >= 0);\n        assert(target);\n        assert(context);\n\n        /* Ignore errors on these */\n        (void) fchmod(fd, 0640);\n        (void) fix_acl(fd, uid);\n        (void) fix_xattr(fd, context);\n\n        r = fsync_full(fd);\n        if (r < 0)\n                return log_error_errno(r, \"Failed to sync coredump %s: %m\", coredump_tmpfile_name(filename));\n\n        r = link_tmpfile(fd, filename, target);\n        if (r < 0)\n                return log_error_errno(r, \"Failed to move coredump %s into place: %m\", target);\n\n        return 0;\n}\n\nstatic int maybe_remove_external_coredump(const char *filename, uint64_t size) {\n\n        /* Returns 1 if might remove, 0 if will not remove, < 0 on error. */\n\n        if (arg_storage == COREDUMP_STORAGE_EXTERNAL &&\n            size <= arg_external_size_max)\n                return 0;\n\n        if (!filename)\n                return 1;\n\n        if (unlink(filename) < 0 && errno != ENOENT)\n                return log_error_errno(errno, \"Failed to unlink %s: %m\", filename);\n\n        return 1;\n}\n\nstatic int make_filename(const Context *context, char **ret) {\n        _cleanup_free_ char *c = NULL, *u = NULL, *p = NULL, *t = NULL;\n        sd_id128_t boot = {};\n        int r;\n\n        assert(context);\n\n        c = filename_escape(context->meta[META_COMM]);\n        if (!c)\n                return -ENOMEM;\n\n        u = filename_escape(context->meta[META_ARGV_UID]);\n        if (!u)\n                return -ENOMEM;\n\n        r = sd_id128_get_boot(&boot);\n        if (r < 0)\n                return r;\n\n        p = filename_escape(context->meta[META_ARGV_PID]);\n        if (!p)\n                return -ENOMEM;\n\n        t = filename_escape(context->meta[META_ARGV_TIMESTAMP]);\n        if (!t)\n                return -ENOMEM;\n\n        if (asprintf(ret,\n                     \"/var/lib/systemd/coredump/core.%s.%s.\" SD_ID128_FORMAT_STR \".%s.%s\",\n                     c,\n                     u,\n                     SD_ID128_FORMAT_VAL(boot),\n                     p,\n                     t) < 0)\n                return -ENOMEM;\n\n        return 0;\n}\n\nstatic int save_external_coredump(\n                const Context *context,\n                int input_fd,\n                char **ret_filename,\n                int *ret_node_fd,\n                int *ret_data_fd,\n                uint64_t *ret_size,\n                uint64_t *ret_compressed_size,\n                bool *ret_truncated) {\n\n        _cleanup_(unlink_and_freep) char *tmp = NULL;\n        _cleanup_free_ char *fn = NULL;\n        _cleanup_close_ int fd = -EBADF;\n        uint64_t rlimit, process_limit, max_size;\n        bool truncated, storage_on_tmpfs;\n        struct stat st;\n        uid_t uid;\n        int r;\n\n        assert(context);\n        assert(ret_filename);\n        assert(ret_node_fd);\n        assert(ret_data_fd);\n        assert(ret_size);\n        assert(ret_compressed_size);\n        assert(ret_truncated);\n\n        r = parse_uid(context->meta[META_ARGV_UID], &uid);\n        if (r < 0)\n                return log_error_errno(r, \"Failed to parse UID: %m\");\n\n        r = safe_atou64(context->meta[META_ARGV_RLIMIT], &rlimit);\n        if (r < 0)\n                return log_error_errno(r, \"Failed to parse resource limit '%s': %m\",\n                                       context->meta[META_ARGV_RLIMIT]);\n        if (rlimit < page_size())\n                /* Is coredumping disabled? Then don't bother saving/processing the\n                 * coredump. Anything below PAGE_SIZE cannot give a readable coredump\n                 * (the kernel uses ELF_EXEC_PAGESIZE which is not easily accessible, but\n                 * is usually the same as PAGE_SIZE. */\n                return log_info_errno(SYNTHETIC_ERRNO(EBADSLT),\n                                      \"Resource limits disable core dumping for process %s (%s).\",\n                                      context->meta[META_ARGV_PID], context->meta[META_COMM]);\n\n        process_limit = MAX(arg_process_size_max, storage_size_max());\n        if (process_limit == 0)\n                return log_debug_errno(SYNTHETIC_ERRNO(EBADSLT),\n                                       \"Limits for coredump processing and storage are both 0, not dumping core.\");\n\n        /* Never store more than the process configured, or than we actually shall keep or process */\n        max_size = MIN(rlimit, process_limit);\n\n        r = make_filename(context, &fn);\n        if (r < 0)\n                return log_error_errno(r, \"Failed to determine coredump file name: %m\");\n\n        (void) mkdir_parents_label(fn, 0755);\n\n        fd = open_tmpfile_linkable(fn, O_RDWR|O_CLOEXEC, &tmp);\n        if (fd < 0)\n                return log_error_errno(fd, \"Failed to create temporary file for coredump %s: %m\", fn);\n\n        /* If storage is on tmpfs, the kernel oomd might kill us if there's MemoryMax set on\n         * the service or the slice it belongs to. This is common on low-resources systems,\n         * to avoid crashing processes to take away too many system resources.\n         * Check the cgroup settings, and set max_size to a bit less than half of the\n         * available memory left to the process.\n         * Then, attempt to write the core file uncompressed first - if the write gets\n         * interrupted, we know we won't be able to write it all, so instead compress what\n         * was written so far, delete the uncompressed truncated core, and then continue\n         * compressing from STDIN. Given the compressed core cannot be larger than the\n         * uncompressed one, and 1KB for metadata is accounted for in the calculation, we\n         * should be able to at least store the full compressed core file. */\n\n        storage_on_tmpfs = fd_is_temporary_fs(fd) > 0;\n        if (storage_on_tmpfs && arg_compress) {\n                _cleanup_(sd_bus_flush_close_unrefp) sd_bus *bus = NULL;\n                uint64_t cgroup_limit = UINT64_MAX;\n                struct statvfs sv;\n\n                /* If we can't get the cgroup limit, just ignore it, but don't fail,\n                 * try anyway with the config settings. */\n                r = sd_bus_default_system(&bus);\n                if (r < 0)\n                        log_info_errno(r, \"Failed to connect to system bus, skipping MemoryAvailable check: %m\");\n                else {\n                        _cleanup_(sd_bus_error_free) sd_bus_error error = SD_BUS_ERROR_NULL;\n\n                        r = sd_bus_get_property_trivial(\n                                        bus,\n                                        \"org.freedesktop.systemd1\",\n                                        \"/org/freedesktop/systemd1/unit/self\",\n                                        \"org.freedesktop.systemd1.Service\",\n                                        \"MemoryAvailable\",\n                                        &error,\n                                        't', &cgroup_limit);\n                        if (r < 0)\n                                log_warning_errno(r,\n                                                  \"Failed to query MemoryAvailable for current unit, \"\n                                                  \"falling back to static config settings: %s\",\n                                                  bus_error_message(&error, r));\n                }\n\n                max_size = MIN(cgroup_limit, max_size);\n                max_size = LESS_BY(max_size, 1024U) / 2; /* Account for 1KB metadata overhead for compressing */\n                max_size = MAX(PROCESS_SIZE_MIN, max_size); /* Impose a lower minimum */\n\n                /* tmpfs might get full quickly, so check the available space too.\n                 * But don't worry about errors here, failing to access the storage\n                 * location will be better logged when writing to it. */\n                if (statvfs(\"/var/lib/systemd/coredump/\", &sv) >= 0)\n                        max_size = MIN((uint64_t)sv.f_frsize * (uint64_t)sv.f_bfree, max_size);\n\n                log_debug(\"Limiting core file size to %\" PRIu64 \" bytes due to cgroup memory limits.\", max_size);\n        }\n\n        r = copy_bytes(input_fd, fd, max_size, 0);\n        if (r < 0)\n                return log_error_errno(r, \"Cannot store coredump of %s (%s): %m\",\n                                context->meta[META_ARGV_PID], context->meta[META_COMM]);\n        truncated = r == 1;\n\n#if HAVE_COMPRESSION\n        if (arg_compress) {\n                _cleanup_(unlink_and_freep) char *tmp_compressed = NULL;\n                _cleanup_free_ char *fn_compressed = NULL;\n                _cleanup_close_ int fd_compressed = -EBADF;\n                uint64_t uncompressed_size = 0;\n\n                if (lseek(fd, 0, SEEK_SET) == (off_t) -1)\n                        return log_error_errno(errno, \"Failed to seek on coredump %s: %m\", fn);\n\n                fn_compressed = strjoin(fn, default_compression_extension());\n                if (!fn_compressed)\n                        return log_oom();\n\n                fd_compressed = open_tmpfile_linkable(fn_compressed, O_RDWR|O_CLOEXEC, &tmp_compressed);\n                if (fd_compressed < 0)\n                        return log_error_errno(fd_compressed, \"Failed to create temporary file for coredump %s: %m\", fn_compressed);\n\n                r = compress_stream(fd, fd_compressed, max_size, &uncompressed_size);\n                if (r < 0)\n                        return log_error_errno(r, \"Failed to compress %s: %m\", coredump_tmpfile_name(tmp_compressed));\n\n                if (truncated && storage_on_tmpfs) {\n                        uint64_t partial_uncompressed_size = 0;\n\n                        /* Uncompressed write was truncated and we are writing to tmpfs: delete\n                         * the uncompressed core, and compress the remaining part from STDIN. */\n\n                        tmp = unlink_and_free(tmp);\n                        fd = safe_close(fd);\n\n                        r = compress_stream(input_fd, fd_compressed, max_size, &partial_uncompressed_size);\n                        if (r < 0)\n                                return log_error_errno(r, \"Failed to compress %s: %m\", coredump_tmpfile_name(tmp_compressed));\n                        uncompressed_size += partial_uncompressed_size;\n                }\n\n                r = fix_permissions(fd_compressed, tmp_compressed, fn_compressed, context, uid);\n                if (r < 0)\n                        return r;\n\n                if (fstat(fd_compressed, &st) < 0)\n                        return log_error_errno(errno,\n                                        \"Failed to fstat core file %s: %m\",\n                                        coredump_tmpfile_name(tmp_compressed));\n\n                *ret_filename = TAKE_PTR(fn_compressed);       /* compressed */\n                *ret_node_fd = TAKE_FD(fd_compressed);         /* compressed */\n                *ret_compressed_size = (uint64_t) st.st_size;  /* compressed */\n                *ret_data_fd = TAKE_FD(fd);\n                *ret_size = uncompressed_size;\n                *ret_truncated = truncated;\n                tmp_compressed = mfree(tmp_compressed);\n\n                return 0;\n        }\n#endif\n\n        if (truncated)\n                log_struct(LOG_INFO,\n                           LOG_MESSAGE(\"Core file was truncated to %\"PRIu64\" bytes.\", max_size),\n                           \"SIZE_LIMIT=%\"PRIu64, max_size,\n                           \"MESSAGE_ID=\" SD_MESSAGE_TRUNCATED_CORE_STR);\n\n        r = fix_permissions(fd, tmp, fn, context, uid);\n        if (r < 0)\n                return log_error_errno(r, \"Failed to fix permissions and finalize coredump %s into %s: %m\", coredump_tmpfile_name(tmp), fn);\n\n        if (fstat(fd, &st) < 0)\n                return log_error_errno(errno, \"Failed to fstat core file %s: %m\", coredump_tmpfile_name(tmp));\n\n        if (lseek(fd, 0, SEEK_SET) == (off_t) -1)\n                return log_error_errno(errno, \"Failed to seek on coredump %s: %m\", fn);\n\n        *ret_filename = TAKE_PTR(fn);\n        *ret_data_fd = TAKE_FD(fd);\n        *ret_size = (uint64_t) st.st_size;\n        *ret_truncated = truncated;\n\n        return 0;\n}\n\nstatic int allocate_journal_field(int fd, size_t size, char **ret, size_t *ret_size) {\n        _cleanup_free_ char *field = NULL;\n        ssize_t n;\n\n        assert(fd >= 0);\n        assert(ret);\n        assert(ret_size);\n\n        if (lseek(fd, 0, SEEK_SET) == (off_t) -1)\n                return log_warning_errno(errno, \"Failed to seek: %m\");\n\n        field = malloc(9 + size);\n        if (!field) {\n                log_warning(\"Failed to allocate memory for coredump, coredump will not be stored.\");\n                return -ENOMEM;\n        }\n\n        memcpy(field, \"COREDUMP=\", 9);\n\n        n = read(fd, field + 9, size);\n        if (n < 0)\n                return log_error_errno((int) n, \"Failed to read core data: %m\");\n        if ((size_t) n < size)\n                return log_error_errno(SYNTHETIC_ERRNO(EIO),\n                                       \"Core data too short.\");\n\n        *ret = TAKE_PTR(field);\n        *ret_size = size + 9;\n\n        return 0;\n}\n\n/* Joins /proc/[pid]/fd/ and /proc/[pid]/fdinfo/ into the following lines:\n * 0:/dev/pts/23\n * pos:    0\n * flags:  0100002\n *\n * 1:/dev/pts/23\n * pos:    0\n * flags:  0100002\n *\n * 2:/dev/pts/23\n * pos:    0\n * flags:  0100002\n * EOF\n */\nstatic int compose_open_fds(pid_t pid, char **open_fds) {\n        _cleanup_closedir_ DIR *proc_fd_dir = NULL;\n        _cleanup_close_ int proc_fdinfo_fd = -EBADF;\n        _cleanup_free_ char *buffer = NULL;\n        _cleanup_fclose_ FILE *stream = NULL;\n        const char *fddelim = \"\", *path;\n        size_t size = 0;\n        int r;\n\n        assert(pid >= 0);\n        assert(open_fds != NULL);\n\n        path = procfs_file_alloca(pid, \"fd\");\n        proc_fd_dir = opendir(path);\n        if (!proc_fd_dir)\n                return -errno;\n\n        proc_fdinfo_fd = openat(dirfd(proc_fd_dir), \"../fdinfo\", O_DIRECTORY|O_NOFOLLOW|O_CLOEXEC|O_PATH);\n        if (proc_fdinfo_fd < 0)\n                return -errno;\n\n        stream = open_memstream_unlocked(&buffer, &size);\n        if (!stream)\n                return -ENOMEM;\n\n        FOREACH_DIRENT(de, proc_fd_dir, return -errno) {\n                _cleanup_fclose_ FILE *fdinfo = NULL;\n                _cleanup_free_ char *fdname = NULL;\n                _cleanup_close_ int fd = -EBADF;\n\n                r = readlinkat_malloc(dirfd(proc_fd_dir), de->d_name, &fdname);\n                if (r < 0)\n                        return r;\n\n                fprintf(stream, \"%s%s:%s\\n\", fddelim, de->d_name, fdname);\n                fddelim = \"\\n\";\n\n                /* Use the directory entry from /proc/[pid]/fd with /proc/[pid]/fdinfo */\n                fd = openat(proc_fdinfo_fd, de->d_name, O_NOFOLLOW|O_CLOEXEC|O_RDONLY);\n                if (fd < 0)\n                        continue;\n\n                fdinfo = take_fdopen(&fd, \"r\");\n                if (!fdinfo)\n                        continue;\n\n                for (;;) {\n                        _cleanup_free_ char *line = NULL;\n\n                        r = read_line(fdinfo, LONG_LINE_MAX, &line);\n                        if (r < 0)\n                                return r;\n                        if (r == 0)\n                                break;\n\n                        fputs(line, stream);\n                        fputc('\\n', stream);\n                }\n        }\n\n        errno = 0;\n        stream = safe_fclose(stream);\n\n        if (errno > 0)\n                return -errno;\n\n        *open_fds = TAKE_PTR(buffer);\n\n        return 0;\n}\n\nstatic int get_process_ns(pid_t pid, const char *namespace, ino_t *ns) {\n        const char *p;\n        struct stat stbuf;\n        _cleanup_close_ int proc_ns_dir_fd = -EBADF;\n\n        p = procfs_file_alloca(pid, \"ns\");\n\n        proc_ns_dir_fd = open(p, O_DIRECTORY | O_CLOEXEC | O_RDONLY);\n        if (proc_ns_dir_fd < 0)\n                return -errno;\n\n        if (fstatat(proc_ns_dir_fd, namespace, &stbuf, /* flags */0) < 0)\n                return -errno;\n\n        *ns = stbuf.st_ino;\n        return 0;\n}\n\nstatic int get_mount_namespace_leader(pid_t pid, pid_t *ret) {\n        ino_t proc_mntns;\n        int r;\n\n        r = get_process_ns(pid, \"mnt\", &proc_mntns);\n        if (r < 0)\n                return r;\n\n        for (;;) {\n                ino_t parent_mntns;\n                pid_t ppid;\n\n                r = get_process_ppid(pid, &ppid);\n                if (r == -EADDRNOTAVAIL) /* Reached the top (i.e. typically PID 1, but could also be a process\n                                          * whose parent is not in our pidns) */\n                        return -ENOENT;\n                if (r < 0)\n                        return r;\n\n                r = get_process_ns(ppid, \"mnt\", &parent_mntns);\n                if (r < 0)\n                        return r;\n\n                if (proc_mntns != parent_mntns) {\n                        *ret = ppid;\n                        return 0;\n                }\n\n                pid = ppid;\n        }\n}\n\n/* Returns 1 if the parent was found.\n * Returns 0 if there is not a process we can call the pid's\n * container parent (the pid's process isn't 'containerized').\n * Returns a negative number on errors.\n */\nstatic int get_process_container_parent_cmdline(pid_t pid, char** cmdline) {\n        pid_t container_pid;\n        const char *proc_root_path;\n        struct stat root_stat, proc_root_stat;\n        int r;\n\n        /* To compare inodes of / and /proc/[pid]/root */\n        if (stat(\"/\", &root_stat) < 0)\n                return -errno;\n\n        proc_root_path = procfs_file_alloca(pid, \"root\");\n        if (stat(proc_root_path, &proc_root_stat) < 0)\n                return -errno;\n\n        /* The process uses system root. */\n        if (stat_inode_same(&proc_root_stat, &root_stat)) {\n                *cmdline = NULL;\n                return 0;\n        }\n\n        r = get_mount_namespace_leader(pid, &container_pid);\n        if (r < 0)\n                return r;\n\n        r = get_process_cmdline(container_pid, SIZE_MAX, PROCESS_CMDLINE_QUOTE_POSIX, cmdline);\n        if (r < 0)\n                return r;\n\n        return 1;\n}\n\nstatic int change_uid_gid(const Context *context) {\n        uid_t uid;\n        gid_t gid;\n        int r;\n\n        r = parse_uid(context->meta[META_ARGV_UID], &uid);\n        if (r < 0)\n                return r;\n\n        if (uid_is_system(uid)) {\n                const char *user = \"systemd-coredump\";\n\n                r = get_user_creds(&user, &uid, &gid, NULL, NULL, 0);\n                if (r < 0) {\n                        log_warning_errno(r, \"Cannot resolve %s user. Proceeding to dump core as root: %m\", user);\n                        uid = gid = 0;\n                }\n        } else {\n                r = parse_gid(context->meta[META_ARGV_GID], &gid);\n                if (r < 0)\n                        return r;\n        }\n\n        return drop_privileges(uid, gid, 0);\n}\n\nstatic int submit_coredump(\n                Context *context,\n                struct iovec_wrapper *iovw,\n                int input_fd) {\n\n        _cleanup_(json_variant_unrefp) JsonVariant *json_metadata = NULL;\n        _cleanup_close_ int coredump_fd = -EBADF, coredump_node_fd = -EBADF;\n        _cleanup_free_ char *filename = NULL, *coredump_data = NULL;\n        _cleanup_free_ char *stacktrace = NULL;\n        char *core_message;\n        const char *module_name;\n        uint64_t coredump_size = UINT64_MAX, coredump_compressed_size = UINT64_MAX;\n        bool truncated = false;\n        JsonVariant *module_json;\n        int r;\n\n        assert(context);\n        assert(iovw);\n        assert(input_fd >= 0);\n\n        /* Vacuum before we write anything again */\n        (void) coredump_vacuum(-1, arg_keep_free, arg_max_use);\n\n        /* Always stream the coredump to disk, if that's possible */\n        r = save_external_coredump(context, input_fd,\n                                   &filename, &coredump_node_fd, &coredump_fd,\n                                   &coredump_size, &coredump_compressed_size, &truncated);\n        if (r < 0)\n                /* Skip whole core dumping part */\n                goto log;\n\n        /* If we don't want to keep the coredump on disk, remove it now, as later on we\n         * will lack the privileges for it. However, we keep the fd to it, so that we can\n         * still process it and log it. */\n        r = maybe_remove_external_coredump(filename, coredump_node_fd >= 0 ? coredump_compressed_size : coredump_size);\n        if (r < 0)\n                return r;\n        if (r == 0)\n                (void) iovw_put_string_field(iovw, \"COREDUMP_FILENAME=\", filename);\n        else if (arg_storage == COREDUMP_STORAGE_EXTERNAL)\n                log_info(\"The core will not be stored: size %\"PRIu64\" is greater than %\"PRIu64\" (the configured maximum)\",\n                         coredump_node_fd >= 0 ? coredump_compressed_size : coredump_size, arg_external_size_max);\n\n        /* Vacuum again, but exclude the coredump we just created */\n        (void) coredump_vacuum(coredump_node_fd >= 0 ? coredump_node_fd : coredump_fd, arg_keep_free, arg_max_use);\n\n        /* Now, let's drop privileges to become the user who owns the segfaulted process\n         * and allocate the coredump memory under the user's uid. This also ensures that\n         * the credentials journald will see are the ones of the coredumping user, thus\n         * making sure the user gets access to the core dump. Let's also get rid of all\n         * capabilities, if we run as root, we won't need them anymore. */\n        r = change_uid_gid(context);\n        if (r < 0)\n                return log_error_errno(r, \"Failed to drop privileges: %m\");\n\n        /* Try to get a stack trace if we can */\n        if (coredump_size > arg_process_size_max)\n                log_debug(\"Not generating stack trace: core size %\"PRIu64\" is greater \"\n                          \"than %\"PRIu64\" (the configured maximum)\",\n                          coredump_size, arg_process_size_max);\n        else if (coredump_fd >= 0) {\n                bool skip = startswith(context->meta[META_COMM], \"systemd-coredum\"); /* COMM is 16 bytes usually */\n\n                (void) parse_elf_object(coredump_fd,\n                                        context->meta[META_EXE],\n                                        /* fork_disable_dump= */ skip, /* avoid loops */\n                                        &stacktrace,\n                                        &json_metadata);\n        }\n\nlog:\n        core_message = strjoina(\"Process \", context->meta[META_ARGV_PID],\n                                \" (\", context->meta[META_COMM], \") of user \",\n                                context->meta[META_ARGV_UID], \" dumped core.\",\n                                context->is_journald && filename ? \"\\nCoredump diverted to \" : NULL,\n                                context->is_journald && filename ? filename : NULL);\n\n        core_message = strjoina(core_message, stacktrace ? \"\\n\\n\" : NULL, stacktrace);\n\n        if (context->is_journald)\n                /* We might not be able to log to the journal, so let's always print the message to another\n                 * log target. The target was set previously to something safe. */\n                log_dispatch(LOG_ERR, 0, core_message);\n\n        (void) iovw_put_string_field(iovw, \"MESSAGE=\", core_message);\n\n        if (truncated)\n                (void) iovw_put_string_field(iovw, \"COREDUMP_TRUNCATED=\", \"1\");\n\n        /* If we managed to parse any ELF metadata (build-id, ELF package meta),\n         * attach it as journal metadata. */\n        if (json_metadata) {\n                _cleanup_free_ char *formatted_json = NULL;\n\n                r = json_variant_format(json_metadata, 0, &formatted_json);\n                if (r < 0)\n                        return log_error_errno(r, \"Failed to format JSON package metadata: %m\");\n\n                (void) iovw_put_string_field(iovw, \"COREDUMP_PACKAGE_JSON=\", formatted_json);\n        }\n\n        /* In the unlikely scenario that context->meta[META_EXE] is not available,\n         * let's avoid guessing the module name and skip the loop. */\n        if (context->meta[META_EXE])\n                JSON_VARIANT_OBJECT_FOREACH(module_name, module_json, json_metadata) {\n                        JsonVariant *t;\n\n                        /* We only add structured fields for the 'main' ELF module, and only if we can identify it. */\n                        if (!path_equal_filename(module_name, context->meta[META_EXE]))\n                                continue;\n\n                        t = json_variant_by_key(module_json, \"name\");\n                        if (t)\n                                (void) iovw_put_string_field(iovw, \"COREDUMP_PACKAGE_NAME=\", json_variant_string(t));\n\n                        t = json_variant_by_key(module_json, \"version\");\n                        if (t)\n                                (void) iovw_put_string_field(iovw, \"COREDUMP_PACKAGE_VERSION=\", json_variant_string(t));\n                }\n\n        /* Optionally store the entire coredump in the journal */\n        if (arg_storage == COREDUMP_STORAGE_JOURNAL && coredump_fd >= 0) {\n                if (coredump_size <= arg_journal_size_max) {\n                        size_t sz = 0;\n\n                        /* Store the coredump itself in the journal */\n\n                        r = allocate_journal_field(coredump_fd, (size_t) coredump_size, &coredump_data, &sz);\n                        if (r >= 0) {\n                                if (iovw_put(iovw, coredump_data, sz) >= 0)\n                                        TAKE_PTR(coredump_data);\n                        } else\n                                log_warning_errno(r, \"Failed to attach the core to the journal entry: %m\");\n                } else\n                        log_info(\"The core will not be stored: size %\"PRIu64\" is greater than %\"PRIu64\" (the configured maximum)\",\n                                 coredump_size, arg_journal_size_max);\n        }\n\n        /* If journald is coredumping, we have to be careful that we don't deadlock when trying to write the\n         * coredump to the journal, so we put the journal socket in nonblocking mode before trying to write\n         * the coredump to the socket. */\n\n        if (context->is_journald) {\n                r = journal_fd_nonblock(true);\n                if (r < 0)\n                        return log_error_errno(r, \"Failed to make journal socket non-blocking: %m\");\n        }\n\n        r = sd_journal_sendv(iovw->iovec, iovw->count);\n\n        if (context->is_journald) {\n                int k;\n\n                k = journal_fd_nonblock(false);\n                if (k < 0)\n                        return log_error_errno(k, \"Failed to make journal socket blocking: %m\");\n        }\n\n        if (r == -EAGAIN && context->is_journald)\n                log_warning_errno(r, \"Failed to log journal coredump, ignoring: %m\");\n        else if (r < 0)\n                return log_error_errno(r, \"Failed to log coredump: %m\");\n\n        return 0;\n}\n\nstatic int save_context(Context *context, const struct iovec_wrapper *iovw) {\n        const char *unit;\n        int r;\n\n        assert(context);\n        assert(iovw);\n        assert(iovw->count >= _META_ARGV_MAX);\n\n        /* The context does not allocate any memory on its own */\n\n        for (size_t n = 0; n < iovw->count; n++) {\n                struct iovec *iovec = iovw->iovec + n;\n\n                for (size_t i = 0; i < ELEMENTSOF(meta_field_names); i++) {\n                        char *p;\n\n                        /* Note that these strings are NUL terminated, because we made sure that a\n                         * trailing NUL byte is in the buffer, though not included in the iov_len\n                         * count (see process_socket() and gather_pid_metadata_*()) */\n                        assert(((char*) iovec->iov_base)[iovec->iov_len] == 0);\n\n                        p = startswith(iovec->iov_base, meta_field_names[i]);\n                        if (p) {\n                                context->meta[i] = p;\n                                break;\n                        }\n                }\n        }\n\n        if (!context->meta[META_ARGV_PID])\n                return log_error_errno(SYNTHETIC_ERRNO(EINVAL),\n                                       \"Failed to find the PID of crashing process\");\n\n        r = parse_pid(context->meta[META_ARGV_PID], &context->pid);\n        if (r < 0)\n                return log_error_errno(r, \"Failed to parse PID \\\"%s\\\": %m\", context->meta[META_ARGV_PID]);\n\n        unit = context->meta[META_UNIT];\n        context->is_pid1 = streq(context->meta[META_ARGV_PID], \"1\") || streq_ptr(unit, SPECIAL_INIT_SCOPE);\n        context->is_journald = streq_ptr(unit, SPECIAL_JOURNALD_SERVICE);\n\n        return 0;\n}\n\nstatic int process_socket(int fd) {\n        _cleanup_close_ int input_fd = -EBADF;\n        Context context = {};\n        struct iovec_wrapper iovw = {};\n        struct iovec iovec;\n        int r;\n\n        assert(fd >= 0);\n\n        log_setup();\n\n        log_debug(\"Processing coredump received on stdin...\");\n\n        for (;;) {\n                CMSG_BUFFER_TYPE(CMSG_SPACE(sizeof(int))) control;\n                struct msghdr mh = {\n                        .msg_control = &control,\n                        .msg_controllen = sizeof(control),\n                        .msg_iovlen = 1,\n                };\n                ssize_t n;\n                ssize_t l;\n\n                l = next_datagram_size_fd(fd);\n                if (l < 0) {\n                        r = log_error_errno(l, \"Failed to determine datagram size to read: %m\");\n                        goto finish;\n                }\n\n                iovec.iov_len = l;\n                iovec.iov_base = malloc(l + 1);\n                if (!iovec.iov_base) {\n                        r = log_oom();\n                        goto finish;\n                }\n\n                mh.msg_iov = &iovec;\n\n                n = recvmsg_safe(fd, &mh, MSG_CMSG_CLOEXEC);\n                if (n < 0)  {\n                        free(iovec.iov_base);\n                        r = log_error_errno(n, \"Failed to receive datagram: %m\");\n                        goto finish;\n                }\n\n                /* The final zero-length datagram carries the file descriptor and tells us\n                 * that we're done. */\n                if (n == 0) {\n                        struct cmsghdr *found;\n\n                        free(iovec.iov_base);\n\n                        found = cmsg_find(&mh, SOL_SOCKET, SCM_RIGHTS, CMSG_LEN(sizeof(int)));\n                        if (!found) {\n                                cmsg_close_all(&mh);\n                                r = log_error_errno(SYNTHETIC_ERRNO(EBADMSG),\n                                                    \"Coredump file descriptor missing.\");\n                                goto finish;\n                        }\n\n                        assert(input_fd < 0);\n                        input_fd = *(int*) CMSG_DATA(found);\n                        break;\n                } else\n                        cmsg_close_all(&mh);\n\n                /* Add trailing NUL byte, in case these are strings */\n                ((char*) iovec.iov_base)[n] = 0;\n                iovec.iov_len = (size_t) n;\n\n                r = iovw_put(&iovw, iovec.iov_base, iovec.iov_len);\n                if (r < 0)\n                        goto finish;\n        }\n\n        /* Make sure we got all data we really need */\n        assert(input_fd >= 0);\n\n        r = save_context(&context, &iovw);\n        if (r < 0)\n                goto finish;\n\n        /* Make sure we received at least all fields we need. */\n        for (int i = 0; i < _META_MANDATORY_MAX; i++)\n                if (!context.meta[i]) {\n                        r = log_error_errno(SYNTHETIC_ERRNO(EINVAL),\n                                            \"A mandatory argument (%i) has not been sent, aborting.\",\n                                            i);\n                        goto finish;\n                }\n\n        r = submit_coredump(&context, &iovw, input_fd);\n\nfinish:\n        iovw_free_contents(&iovw, true);\n        return r;\n}\n\nstatic int send_iovec(const struct iovec_wrapper *iovw, int input_fd) {\n        _cleanup_close_ int fd = -EBADF;\n        int r;\n\n        assert(iovw);\n        assert(input_fd >= 0);\n\n        fd = socket(AF_UNIX, SOCK_SEQPACKET|SOCK_CLOEXEC, 0);\n        if (fd < 0)\n                return log_error_errno(errno, \"Failed to create coredump socket: %m\");\n\n        r = connect_unix_path(fd, AT_FDCWD, \"/run/systemd/coredump\");\n        if (r < 0)\n                return log_error_errno(r, \"Failed to connect to coredump service: %m\");\n\n        for (size_t i = 0; i < iovw->count; i++) {\n                struct msghdr mh = {\n                        .msg_iov = iovw->iovec + i,\n                        .msg_iovlen = 1,\n                };\n                struct iovec copy[2];\n\n                for (;;) {\n                        if (sendmsg(fd, &mh, MSG_NOSIGNAL) >= 0)\n                                break;\n\n                        if (errno == EMSGSIZE && mh.msg_iov[0].iov_len > 0) {\n                                /* This field didn't fit? That's a pity. Given that this is\n                                 * just metadata, let's truncate the field at half, and try\n                                 * again. We append three dots, in order to show that this is\n                                 * truncated. */\n\n                                if (mh.msg_iov != copy) {\n                                        /* We don't want to modify the caller's iovec, hence\n                                         * let's create our own array, consisting of two new\n                                         * iovecs, where the first is a (truncated) copy of\n                                         * what we want to send, and the second one contains\n                                         * the trailing dots. */\n                                        copy[0] = iovw->iovec[i];\n                                        copy[1] = IOVEC_MAKE(((char[]){'.', '.', '.'}), 3);\n\n                                        mh.msg_iov = copy;\n                                        mh.msg_iovlen = 2;\n                                }\n\n                                copy[0].iov_len /= 2; /* halve it, and try again */\n                                continue;\n                        }\n\n                        return log_error_errno(errno, \"Failed to send coredump datagram: %m\");\n                }\n        }\n\n        r = send_one_fd(fd, input_fd, 0);\n        if (r < 0)\n                return log_error_errno(r, \"Failed to send coredump fd: %m\");\n\n        return 0;\n}\n\nstatic int gather_pid_metadata_from_argv(\n                struct iovec_wrapper *iovw,\n                Context *context,\n                int argc, char **argv) {\n\n        _cleanup_free_ char *free_timestamp = NULL;\n        int r, signo;\n        char *t;\n\n        /* We gather all metadata that were passed via argv[] into an array of iovecs that\n         * we'll forward to the socket unit */\n\n        if (argc < _META_ARGV_MAX)\n                return log_error_errno(SYNTHETIC_ERRNO(EINVAL),\n                                       \"Not enough arguments passed by the kernel (%i, expected %i).\",\n                                       argc, _META_ARGV_MAX);\n\n        for (int i = 0; i < _META_ARGV_MAX; i++) {\n\n                t = argv[i];\n\n                switch (i) {\n\n                case META_ARGV_TIMESTAMP:\n                        /* The journal fields contain the timestamp padded with six\n                         * zeroes, so that the kernel-supplied 1s granularity timestamps\n                         * becomes 1\u00b5s granularity, i.e. the granularity systemd usually\n                         * operates in. */\n                        t = free_timestamp = strjoin(argv[i], \"000000\");\n                        if (!t)\n                                return log_oom();\n                        break;\n\n                case META_ARGV_SIGNAL:\n                        /* For signal, record its pretty name too */\n                        if (safe_atoi(argv[i], &signo) >= 0 && SIGNAL_VALID(signo))\n                                (void) iovw_put_string_field(iovw, \"COREDUMP_SIGNAL_NAME=SIG\",\n                                                             signal_to_string(signo));\n                        break;\n\n                default:\n                        break;\n                }\n\n                r = iovw_put_string_field(iovw, meta_field_names[i], t);\n                if (r < 0)\n                        return r;\n        }\n\n        /* Cache some of the process metadata we collected so far and that we'll need to\n         * access soon */\n        return save_context(context, iovw);\n}\n\nstatic int gather_pid_metadata(struct iovec_wrapper *iovw, Context *context) {\n        uid_t owner_uid;\n        pid_t pid;\n        char *t;\n        const char *p;\n        int r;\n\n        /* Note that if we fail on oom later on, we do not roll-back changes to the iovec\n         * structure. (It remains valid, with the first iovec fields initialized.) */\n\n        pid = context->pid;\n\n        /* The following is mandatory */\n        r = get_process_comm(pid, &t);\n        if (r < 0)\n                return log_error_errno(r, \"Failed to get COMM: %m\");\n\n        r = iovw_put_string_field_free(iovw, \"COREDUMP_COMM=\", t);\n        if (r < 0)\n                return r;\n\n        /* The following are optional, but we use them if present. */\n        r = get_process_exe(pid, &t);\n        if (r >= 0)\n                r = iovw_put_string_field_free(iovw, \"COREDUMP_EXE=\", t);\n        if (r < 0)\n                log_warning_errno(r, \"Failed to get EXE, ignoring: %m\");\n\n        if (cg_pid_get_unit(pid, &t) >= 0)\n                (void) iovw_put_string_field_free(iovw, \"COREDUMP_UNIT=\", t);\n\n        if (cg_pid_get_user_unit(pid, &t) >= 0)\n                (void) iovw_put_string_field_free(iovw, \"COREDUMP_USER_UNIT=\", t);\n\n        if (sd_pid_get_session(pid, &t) >= 0)\n                (void) iovw_put_string_field_free(iovw, \"COREDUMP_SESSION=\", t);\n\n        if (sd_pid_get_owner_uid(pid, &owner_uid) >= 0) {\n                r = asprintf(&t, UID_FMT, owner_uid);\n                if (r > 0)\n                        (void) iovw_put_string_field_free(iovw, \"COREDUMP_OWNER_UID=\", t);\n        }\n\n        if (sd_pid_get_slice(pid, &t) >= 0)\n                (void) iovw_put_string_field_free(iovw, \"COREDUMP_SLICE=\", t);\n\n        if (get_process_cmdline(pid, SIZE_MAX, PROCESS_CMDLINE_QUOTE_POSIX, &t) >= 0)\n                (void) iovw_put_string_field_free(iovw, \"COREDUMP_CMDLINE=\", t);\n\n        if (cg_pid_get_path_shifted(pid, NULL, &t) >= 0)\n                (void) iovw_put_string_field_free(iovw, \"COREDUMP_CGROUP=\", t);\n\n        if (compose_open_fds(pid, &t) >= 0)\n                (void) iovw_put_string_field_free(iovw, \"COREDUMP_OPEN_FDS=\", t);\n\n        p = procfs_file_alloca(pid, \"status\");\n        if (read_full_virtual_file(p, &t, NULL) >= 0)\n                (void) iovw_put_string_field_free(iovw, \"COREDUMP_PROC_STATUS=\", t);\n\n        p = procfs_file_alloca(pid, \"maps\");\n        if (read_full_virtual_file(p, &t, NULL) >= 0)\n                (void) iovw_put_string_field_free(iovw, \"COREDUMP_PROC_MAPS=\", t);\n\n        p = procfs_file_alloca(pid, \"limits\");\n        if (read_full_virtual_file(p, &t, NULL) >= 0)\n                (void) iovw_put_string_field_free(iovw, \"COREDUMP_PROC_LIMITS=\", t);\n\n        p = procfs_file_alloca(pid, \"cgroup\");\n        if (read_full_virtual_file(p, &t, NULL) >=0)\n                (void) iovw_put_string_field_free(iovw, \"COREDUMP_PROC_CGROUP=\", t);\n\n        p = procfs_file_alloca(pid, \"mountinfo\");\n        if (read_full_virtual_file(p, &t, NULL) >=0)\n                (void) iovw_put_string_field_free(iovw, \"COREDUMP_PROC_MOUNTINFO=\", t);\n\n        if (get_process_cwd(pid, &t) >= 0)\n                (void) iovw_put_string_field_free(iovw, \"COREDUMP_CWD=\", t);\n\n        if (get_process_root(pid, &t) >= 0) {\n                bool proc_self_root_is_slash;\n\n                proc_self_root_is_slash = strcmp(t, \"/\") == 0;\n\n                (void) iovw_put_string_field_free(iovw, \"COREDUMP_ROOT=\", t);\n\n                /* If the process' root is \"/\", then there is a chance it has\n                 * mounted own root and hence being containerized. */\n                if (proc_self_root_is_slash && get_process_container_parent_cmdline(pid, &t) > 0)\n                        (void) iovw_put_string_field_free(iovw, \"COREDUMP_CONTAINER_CMDLINE=\", t);\n        }\n\n        if (get_process_environ(pid, &t) >= 0)\n                (void) iovw_put_string_field_free(iovw, \"COREDUMP_ENVIRON=\", t);\n\n        /* we successfully acquired all metadata */\n        return save_context(context, iovw);\n}\n\nstatic int process_kernel(int argc, char* argv[]) {\n        Context context = {};\n        struct iovec_wrapper *iovw;\n        int r;\n\n        /* When we're invoked by the kernel, stdout/stderr are closed which is dangerous because the fds\n         * could get reallocated. To avoid hard to debug issues, let's instead bind stdout/stderr to\n         * /dev/null. */\n        r = rearrange_stdio(STDIN_FILENO, -1, -1);\n        if (r < 0)\n                return log_error_errno(r, \"Failed to connect stdout/stderr to /dev/null: %m\");\n\n        log_debug(\"Processing coredump received from the kernel...\");\n\n        iovw = iovw_new();\n        if (!iovw)\n                return log_oom();\n\n        (void) iovw_put_string_field(iovw, \"MESSAGE_ID=\", SD_MESSAGE_COREDUMP_STR);\n        (void) iovw_put_string_field(iovw, \"PRIORITY=\", STRINGIFY(LOG_CRIT));\n\n        /* Collect all process metadata passed by the kernel through argv[] */\n        r = gather_pid_metadata_from_argv(iovw, &context, argc - 1, argv + 1);\n        if (r < 0)\n                goto finish;\n\n        /* Collect the rest of the process metadata retrieved from the runtime */\n        r = gather_pid_metadata(iovw, &context);\n        if (r < 0)\n                goto finish;\n\n        if (!context.is_journald) {\n                /* OK, now we know it's not the journal, hence we can make use of it now. */\n                log_set_target(LOG_TARGET_JOURNAL_OR_KMSG);\n                log_open();\n        }\n\n        /* If this is PID 1 disable coredump collection, we'll unlikely be able to process\n         * it later on.\n         *\n         * FIXME: maybe we should disable coredumps generation from the beginning and\n         * re-enable it only when we know it's either safe (ie we're not running OOM) or\n         * it's not pid1 ? */\n        if (context.is_pid1) {\n                log_notice(\"Due to PID 1 having crashed coredump collection will now be turned off.\");\n                disable_coredumps();\n        }\n\n        if (context.is_journald || context.is_pid1)\n                r = submit_coredump(&context, iovw, STDIN_FILENO);\n        else\n                r = send_iovec(iovw, STDIN_FILENO);\n\n finish:\n        iovw = iovw_free_free(iovw);\n        return r;\n}\n\nstatic int process_backtrace(int argc, char *argv[]) {\n        Context context = {};\n        struct iovec_wrapper *iovw;\n        char *message;\n        int r;\n         _cleanup_(journal_importer_cleanup) JournalImporter importer = JOURNAL_IMPORTER_INIT(STDIN_FILENO);\n\n        log_debug(\"Processing backtrace on stdin...\");\n\n        iovw = iovw_new();\n        if (!iovw)\n                return log_oom();\n\n        (void) iovw_put_string_field(iovw, \"MESSAGE_ID=\", SD_MESSAGE_BACKTRACE_STR);\n        (void) iovw_put_string_field(iovw, \"PRIORITY=\", STRINGIFY(LOG_CRIT));\n\n        /* Collect all process metadata from argv[] by making sure to skip the\n         * '--backtrace' option */\n        r = gather_pid_metadata_from_argv(iovw, &context, argc - 2, argv + 2);\n        if (r < 0)\n                goto finish;\n\n        /* Collect the rest of the process metadata retrieved from the runtime */\n        r = gather_pid_metadata(iovw, &context);\n        if (r < 0)\n                goto finish;\n\n        for (;;) {\n                r = journal_importer_process_data(&importer);\n                if (r < 0) {\n                        log_error_errno(r, \"Failed to parse journal entry on stdin: %m\");\n                        goto finish;\n                }\n                if (r == 1 ||                        /* complete entry */\n                    journal_importer_eof(&importer)) /* end of data */\n                        break;\n        }\n\n        if (journal_importer_eof(&importer)) {\n                log_warning(\"Did not receive a full journal entry on stdin, ignoring message sent by reporter\");\n\n                message = strjoina(\"Process \", context.meta[META_ARGV_PID],\n                                  \" (\", context.meta[META_COMM], \")\"\n                                  \" of user \", context.meta[META_ARGV_UID],\n                                  \" failed with \", context.meta[META_ARGV_SIGNAL]);\n\n                r = iovw_put_string_field(iovw, \"MESSAGE=\", message);\n                if (r < 0)\n                        return r;\n        } else {\n                /* The imported iovecs are not supposed to be freed by us so let's store\n                 * them at the end of the array so we can skip them while freeing the\n                 * rest. */\n                for (size_t i = 0; i < importer.iovw.count; i++) {\n                        struct iovec *iovec = importer.iovw.iovec + i;\n\n                        iovw_put(iovw, iovec->iov_base, iovec->iov_len);\n                }\n        }\n\n        r = sd_journal_sendv(iovw->iovec, iovw->count);\n        if (r < 0)\n                log_error_errno(r, \"Failed to log backtrace: %m\");\n\n finish:\n        iovw->count -= importer.iovw.count;\n        iovw = iovw_free_free(iovw);\n        return r;\n}\n\nstatic int run(int argc, char *argv[]) {\n        int r;\n\n        /* First, log to a safe place, since we don't know what crashed and it might\n         * be journald which we'd rather not log to then. */\n\n        log_set_target(LOG_TARGET_KMSG);\n        log_open();\n\n        /* Make sure we never enter a loop */\n        (void) prctl(PR_SET_DUMPABLE, 0);\n\n        /* Ignore all parse errors */\n        (void) parse_config();\n\n        log_debug(\"Selected storage '%s'.\", coredump_storage_to_string(arg_storage));\n        log_debug(\"Selected compression %s.\", yes_no(arg_compress));\n\n        r = sd_listen_fds(false);\n        if (r < 0)\n                return log_error_errno(r, \"Failed to determine the number of file descriptors: %m\");\n\n        /* If we got an fd passed, we are running in coredumpd mode. Otherwise we\n         * are invoked from the kernel as coredump handler. */\n        if (r == 0) {\n                if (streq_ptr(argv[1], \"--backtrace\"))\n                        return process_backtrace(argc, argv);\n                else\n                        return process_kernel(argc, argv);\n        } else if (r == 1)\n                return process_socket(SD_LISTEN_FDS_START);\n\n        return log_error_errno(SYNTHETIC_ERRNO(EINVAL),\n                               \"Received unexpected number of file descriptors.\");\n}\n\nDEFINE_MAIN_FUNCTION(run);\n"], "fixing_code": ["/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include <poll.h>\n#include <stdbool.h>\n#include <stddef.h>\n#include <stdint.h>\n#include <sys/types.h>\n#include <sys/uio.h>\n\n#include \"macro.h\"\n#include \"time-util.h\"\n\nint flush_fd(int fd);\n\nssize_t loop_read(int fd, void *buf, size_t nbytes, bool do_poll);\nint loop_read_exact(int fd, void *buf, size_t nbytes, bool do_poll);\nint loop_write(int fd, const void *buf, size_t nbytes, bool do_poll);\n\nint pipe_eof(int fd);\n\nint ppoll_usec(struct pollfd *fds, size_t nfds, usec_t timeout);\nint fd_wait_for_event(int fd, int event, usec_t timeout);\n\nssize_t sparse_write(int fd, const void *p, size_t sz, size_t run_length);\n\nstatic inline size_t IOVEC_TOTAL_SIZE(const struct iovec *i, size_t n) {\n        size_t r = 0;\n\n        for (size_t j = 0; j < n; j++)\n                r += i[j].iov_len;\n\n        return r;\n}\n\nstatic inline bool IOVEC_INCREMENT(struct iovec *i, size_t n, size_t k) {\n        /* Returns true if there is nothing else to send (bytes written cover all of the iovec),\n         * false if there's still work to do. */\n\n        for (size_t j = 0; j < n; j++) {\n                size_t sub;\n\n                if (i[j].iov_len == 0)\n                        continue;\n                if (k == 0)\n                        return false;\n\n                sub = MIN(i[j].iov_len, k);\n                i[j].iov_len -= sub;\n                i[j].iov_base = (uint8_t*) i[j].iov_base + sub;\n                k -= sub;\n        }\n\n        assert(k == 0); /* Anything else would mean that we wrote more bytes than available,\n                         * or the kernel reported writing more bytes than sent. */\n        return true;\n}\n\nstatic inline bool FILE_SIZE_VALID(uint64_t l) {\n        /* ftruncate() and friends take an unsigned file size, but actually cannot deal with file sizes larger than\n         * 2^63 since the kernel internally handles it as signed value. This call allows checking for this early. */\n\n        return (l >> 63) == 0;\n}\n\nstatic inline bool FILE_SIZE_VALID_OR_INFINITY(uint64_t l) {\n\n        /* Same as above, but allows one extra value: -1 as indication for infinity. */\n\n        if (l == UINT64_MAX)\n                return true;\n\n        return FILE_SIZE_VALID(l);\n\n}\n\n#define IOVEC_INIT(base, len) { .iov_base = (base), .iov_len = (len) }\n#define IOVEC_MAKE(base, len) (struct iovec) IOVEC_INIT(base, len)\n#define IOVEC_INIT_STRING(string) IOVEC_INIT((char*) string, strlen(string))\n#define IOVEC_MAKE_STRING(string) (struct iovec) IOVEC_INIT_STRING(string)\n\nchar* set_iovec_string_field(struct iovec *iovec, size_t *n_iovec, const char *field, const char *value);\nchar* set_iovec_string_field_free(struct iovec *iovec, size_t *n_iovec, const char *field, char *value);\n\nstruct iovec_wrapper {\n        struct iovec *iovec;\n        size_t count;\n};\n\nstruct iovec_wrapper *iovw_new(void);\nstruct iovec_wrapper *iovw_free(struct iovec_wrapper *iovw);\nstruct iovec_wrapper *iovw_free_free(struct iovec_wrapper *iovw);\nvoid iovw_free_contents(struct iovec_wrapper *iovw, bool free_vectors);\n\nint iovw_put(struct iovec_wrapper *iovw, void *data, size_t len);\nstatic inline int iovw_consume(struct iovec_wrapper *iovw, void *data, size_t len) {\n        /* Move data into iovw or free on error */\n        int r = iovw_put(iovw, data, len);\n        if (r < 0)\n                free(data);\n        return r;\n}\n\nint iovw_put_string_field(struct iovec_wrapper *iovw, const char *field, const char *value);\nint iovw_put_string_field_free(struct iovec_wrapper *iovw, const char *field, char *value);\nvoid iovw_rebase(struct iovec_wrapper *iovw, char *old, char *new);\nsize_t iovw_size(struct iovec_wrapper *iovw);\n", "/* SPDX-License-Identifier: LGPL-2.1-or-later */\n\n#include <errno.h>\n#include <stdio.h>\n#include <sys/prctl.h>\n#include <sys/statvfs.h>\n#include <sys/auxv.h>\n#include <sys/xattr.h>\n#include <unistd.h>\n\n#include \"sd-daemon.h\"\n#include \"sd-journal.h\"\n#include \"sd-login.h\"\n#include \"sd-messages.h\"\n\n#include \"acl-util.h\"\n#include \"alloc-util.h\"\n#include \"bus-error.h\"\n#include \"capability-util.h\"\n#include \"cgroup-util.h\"\n#include \"compress.h\"\n#include \"conf-parser.h\"\n#include \"copy.h\"\n#include \"coredump-util.h\"\n#include \"coredump-vacuum.h\"\n#include \"dirent-util.h\"\n#include \"elf-util.h\"\n#include \"escape.h\"\n#include \"fd-util.h\"\n#include \"fileio.h\"\n#include \"fs-util.h\"\n#include \"io-util.h\"\n#include \"journal-importer.h\"\n#include \"journal-send.h\"\n#include \"log.h\"\n#include \"macro.h\"\n#include \"main-func.h\"\n#include \"memory-util.h\"\n#include \"mkdir-label.h\"\n#include \"parse-util.h\"\n#include \"process-util.h\"\n#include \"signal-util.h\"\n#include \"socket-util.h\"\n#include \"special.h\"\n#include \"stat-util.h\"\n#include \"string-table.h\"\n#include \"string-util.h\"\n#include \"strv.h\"\n#include \"sync-util.h\"\n#include \"tmpfile-util.h\"\n#include \"uid-alloc-range.h\"\n#include \"user-util.h\"\n\n/* The maximum size up to which we process coredumps. We use 1G on 32bit systems, and 32G on 64bit systems */\n#if __SIZEOF_POINTER__ == 4\n#define PROCESS_SIZE_MAX ((uint64_t) (1LLU*1024LLU*1024LLU*1024LLU))\n#elif __SIZEOF_POINTER__ == 8\n#define PROCESS_SIZE_MAX ((uint64_t) (32LLU*1024LLU*1024LLU*1024LLU))\n#else\n#error \"Unexpected pointer size\"\n#endif\n\n/* The maximum size up to which we leave the coredump around on disk */\n#define EXTERNAL_SIZE_MAX PROCESS_SIZE_MAX\n\n/* The maximum size up to which we store the coredump in the journal */\n#ifndef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION\n#define JOURNAL_SIZE_MAX ((size_t) (767LU*1024LU*1024LU))\n#else\n/* oss-fuzz limits memory usage. */\n#define JOURNAL_SIZE_MAX ((size_t) (10LU*1024LU*1024LU))\n#endif\n\n/* When checking for available memory and setting lower limits, don't\n * go below 4MB for writing core files to storage. */\n#define PROCESS_SIZE_MIN (4U*1024U*1024U)\n\n/* Make sure to not make this larger than the maximum journal entry\n * size. See DATA_SIZE_MAX in journal-importer.h. */\nassert_cc(JOURNAL_SIZE_MAX <= DATA_SIZE_MAX);\n\nenum {\n        /* We use these as array indexes for our process metadata cache.\n         *\n         * The first indices of the cache stores the same metadata as the ones passed by\n         * the kernel via argv[], ie the strings array passed by the kernel according to\n         * our pattern defined in /proc/sys/kernel/core_pattern (see man:core(5)). */\n\n        META_ARGV_PID,          /* %P: as seen in the initial pid namespace */\n        META_ARGV_UID,          /* %u: as seen in the initial user namespace */\n        META_ARGV_GID,          /* %g: as seen in the initial user namespace */\n        META_ARGV_SIGNAL,       /* %s: number of signal causing dump */\n        META_ARGV_TIMESTAMP,    /* %t: time of dump, expressed as seconds since the Epoch (we expand this to \u00b5s granularity) */\n        META_ARGV_RLIMIT,       /* %c: core file size soft resource limit */\n        META_ARGV_HOSTNAME,     /* %h: hostname */\n        _META_ARGV_MAX,\n\n        /* The following indexes are cached for a couple of special fields we use (and\n         * thereby need to be retrieved quickly) for naming coredump files, and attaching\n         * xattrs. Unlike the previous ones they are retrieved from the runtime\n         * environment. */\n\n        META_COMM = _META_ARGV_MAX,\n        _META_MANDATORY_MAX,\n\n        /* The rest are similar to the previous ones except that we won't fail if one of\n         * them is missing. */\n\n        META_EXE = _META_MANDATORY_MAX,\n        META_UNIT,\n        META_PROC_AUXV,\n        _META_MAX\n};\n\nstatic const char * const meta_field_names[_META_MAX] = {\n        [META_ARGV_PID]       = \"COREDUMP_PID=\",\n        [META_ARGV_UID]       = \"COREDUMP_UID=\",\n        [META_ARGV_GID]       = \"COREDUMP_GID=\",\n        [META_ARGV_SIGNAL]    = \"COREDUMP_SIGNAL=\",\n        [META_ARGV_TIMESTAMP] = \"COREDUMP_TIMESTAMP=\",\n        [META_ARGV_RLIMIT]    = \"COREDUMP_RLIMIT=\",\n        [META_ARGV_HOSTNAME]  = \"COREDUMP_HOSTNAME=\",\n        [META_COMM]           = \"COREDUMP_COMM=\",\n        [META_EXE]            = \"COREDUMP_EXE=\",\n        [META_UNIT]           = \"COREDUMP_UNIT=\",\n        [META_PROC_AUXV]      = \"COREDUMP_PROC_AUXV=\",\n};\n\ntypedef struct Context {\n        const char *meta[_META_MAX];\n        size_t meta_size[_META_MAX];\n        pid_t pid;\n        bool is_pid1;\n        bool is_journald;\n} Context;\n\ntypedef enum CoredumpStorage {\n        COREDUMP_STORAGE_NONE,\n        COREDUMP_STORAGE_EXTERNAL,\n        COREDUMP_STORAGE_JOURNAL,\n        _COREDUMP_STORAGE_MAX,\n        _COREDUMP_STORAGE_INVALID = -EINVAL,\n} CoredumpStorage;\n\nstatic const char* const coredump_storage_table[_COREDUMP_STORAGE_MAX] = {\n        [COREDUMP_STORAGE_NONE]     = \"none\",\n        [COREDUMP_STORAGE_EXTERNAL] = \"external\",\n        [COREDUMP_STORAGE_JOURNAL]  = \"journal\",\n};\n\nDEFINE_PRIVATE_STRING_TABLE_LOOKUP(coredump_storage, CoredumpStorage);\nstatic DEFINE_CONFIG_PARSE_ENUM(config_parse_coredump_storage, coredump_storage, CoredumpStorage, \"Failed to parse storage setting\");\n\nstatic CoredumpStorage arg_storage = COREDUMP_STORAGE_EXTERNAL;\nstatic bool arg_compress = true;\nstatic uint64_t arg_process_size_max = PROCESS_SIZE_MAX;\nstatic uint64_t arg_external_size_max = EXTERNAL_SIZE_MAX;\nstatic uint64_t arg_journal_size_max = JOURNAL_SIZE_MAX;\nstatic uint64_t arg_keep_free = UINT64_MAX;\nstatic uint64_t arg_max_use = UINT64_MAX;\n\nstatic int parse_config(void) {\n        static const ConfigTableItem items[] = {\n                { \"Coredump\", \"Storage\",          config_parse_coredump_storage,     0, &arg_storage           },\n                { \"Coredump\", \"Compress\",         config_parse_bool,                 0, &arg_compress          },\n                { \"Coredump\", \"ProcessSizeMax\",   config_parse_iec_uint64,           0, &arg_process_size_max  },\n                { \"Coredump\", \"ExternalSizeMax\",  config_parse_iec_uint64_infinity,  0, &arg_external_size_max },\n                { \"Coredump\", \"JournalSizeMax\",   config_parse_iec_size,             0, &arg_journal_size_max  },\n                { \"Coredump\", \"KeepFree\",         config_parse_iec_uint64,           0, &arg_keep_free         },\n                { \"Coredump\", \"MaxUse\",           config_parse_iec_uint64,           0, &arg_max_use           },\n                {}\n        };\n\n        return config_parse_many_nulstr(\n                        PKGSYSCONFDIR \"/coredump.conf\",\n                        CONF_PATHS_NULSTR(\"systemd/coredump.conf.d\"),\n                        \"Coredump\\0\",\n                        config_item_table_lookup, items,\n                        CONFIG_PARSE_WARN,\n                        NULL,\n                        NULL);\n}\n\nstatic uint64_t storage_size_max(void) {\n        if (arg_storage == COREDUMP_STORAGE_EXTERNAL)\n                return arg_external_size_max;\n        if (arg_storage == COREDUMP_STORAGE_JOURNAL)\n                return arg_journal_size_max;\n        assert(arg_storage == COREDUMP_STORAGE_NONE);\n        return 0;\n}\n\nstatic int fix_acl(int fd, uid_t uid, bool allow_user) {\n        assert(fd >= 0);\n        assert(uid_is_valid(uid));\n\n#if HAVE_ACL\n        int r;\n\n        /* We don't allow users to read coredumps if the uid or capabilities were changed. */\n        if (!allow_user)\n                return 0;\n\n        if (uid_is_system(uid) || uid_is_dynamic(uid) || uid == UID_NOBODY)\n                return 0;\n\n        /* Make sure normal users can read (but not write or delete) their own coredumps */\n        r = fd_add_uid_acl_permission(fd, uid, ACL_READ);\n        if (r < 0)\n                return log_error_errno(r, \"Failed to adjust ACL of the coredump: %m\");\n#endif\n\n        return 0;\n}\n\nstatic int fix_xattr(int fd, const Context *context) {\n\n        static const char * const xattrs[_META_MAX] = {\n                [META_ARGV_PID]       = \"user.coredump.pid\",\n                [META_ARGV_UID]       = \"user.coredump.uid\",\n                [META_ARGV_GID]       = \"user.coredump.gid\",\n                [META_ARGV_SIGNAL]    = \"user.coredump.signal\",\n                [META_ARGV_TIMESTAMP] = \"user.coredump.timestamp\",\n                [META_ARGV_RLIMIT]    = \"user.coredump.rlimit\",\n                [META_ARGV_HOSTNAME]  = \"user.coredump.hostname\",\n                [META_COMM]           = \"user.coredump.comm\",\n                [META_EXE]            = \"user.coredump.exe\",\n        };\n\n        int r = 0;\n\n        assert(fd >= 0);\n\n        /* Attach some metadata to coredumps via extended\n         * attributes. Just because we can. */\n\n        for (unsigned i = 0; i < _META_MAX; i++) {\n                int k;\n\n                if (isempty(context->meta[i]) || !xattrs[i])\n                        continue;\n\n                k = fsetxattr(fd, xattrs[i], context->meta[i], strlen(context->meta[i]), XATTR_CREATE);\n                if (k < 0 && r == 0)\n                        r = -errno;\n        }\n\n        return r;\n}\n\n#define filename_escape(s) xescape((s), \"./ \")\n\nstatic const char *coredump_tmpfile_name(const char *s) {\n        return s ? s : \"(unnamed temporary file)\";\n}\n\nstatic int fix_permissions(\n                int fd,\n                const char *filename,\n                const char *target,\n                const Context *context,\n                uid_t uid,\n                bool allow_user) {\n\n        int r;\n\n        assert(fd >= 0);\n        assert(target);\n        assert(context);\n\n        /* Ignore errors on these */\n        (void) fchmod(fd, 0640);\n        (void) fix_acl(fd, uid, allow_user);\n        (void) fix_xattr(fd, context);\n\n        r = fsync_full(fd);\n        if (r < 0)\n                return log_error_errno(r, \"Failed to sync coredump %s: %m\", coredump_tmpfile_name(filename));\n\n        r = link_tmpfile(fd, filename, target);\n        if (r < 0)\n                return log_error_errno(r, \"Failed to move coredump %s into place: %m\", target);\n\n        return 0;\n}\n\nstatic int maybe_remove_external_coredump(const char *filename, uint64_t size) {\n\n        /* Returns 1 if might remove, 0 if will not remove, < 0 on error. */\n\n        if (arg_storage == COREDUMP_STORAGE_EXTERNAL &&\n            size <= arg_external_size_max)\n                return 0;\n\n        if (!filename)\n                return 1;\n\n        if (unlink(filename) < 0 && errno != ENOENT)\n                return log_error_errno(errno, \"Failed to unlink %s: %m\", filename);\n\n        return 1;\n}\n\nstatic int make_filename(const Context *context, char **ret) {\n        _cleanup_free_ char *c = NULL, *u = NULL, *p = NULL, *t = NULL;\n        sd_id128_t boot = {};\n        int r;\n\n        assert(context);\n\n        c = filename_escape(context->meta[META_COMM]);\n        if (!c)\n                return -ENOMEM;\n\n        u = filename_escape(context->meta[META_ARGV_UID]);\n        if (!u)\n                return -ENOMEM;\n\n        r = sd_id128_get_boot(&boot);\n        if (r < 0)\n                return r;\n\n        p = filename_escape(context->meta[META_ARGV_PID]);\n        if (!p)\n                return -ENOMEM;\n\n        t = filename_escape(context->meta[META_ARGV_TIMESTAMP]);\n        if (!t)\n                return -ENOMEM;\n\n        if (asprintf(ret,\n                     \"/var/lib/systemd/coredump/core.%s.%s.\" SD_ID128_FORMAT_STR \".%s.%s\",\n                     c,\n                     u,\n                     SD_ID128_FORMAT_VAL(boot),\n                     p,\n                     t) < 0)\n                return -ENOMEM;\n\n        return 0;\n}\n\nstatic int parse_auxv64(\n                const uint64_t *auxv,\n                size_t size_bytes,\n                int *at_secure,\n                uid_t *uid,\n                uid_t *euid,\n                gid_t *gid,\n                gid_t *egid) {\n\n        assert(auxv || size_bytes == 0);\n\n        if (size_bytes % (2 * sizeof(uint64_t)) != 0)\n                return log_warning_errno(SYNTHETIC_ERRNO(EIO), \"Incomplete auxv structure (%zu bytes).\", size_bytes);\n\n        size_t words = size_bytes / sizeof(uint64_t);\n\n        /* Note that we set output variables even on error. */\n\n        for (size_t i = 0; i + 1 < words; i += 2)\n                switch (auxv[i]) {\n                case AT_SECURE:\n                        *at_secure = auxv[i + 1] != 0;\n                        break;\n                case AT_UID:\n                        *uid = auxv[i + 1];\n                        break;\n                case AT_EUID:\n                        *euid = auxv[i + 1];\n                        break;\n                case AT_GID:\n                        *gid = auxv[i + 1];\n                        break;\n                case AT_EGID:\n                        *egid = auxv[i + 1];\n                        break;\n                case AT_NULL:\n                        if (auxv[i + 1] != 0)\n                                goto error;\n                        return 0;\n                }\n error:\n        return log_warning_errno(SYNTHETIC_ERRNO(ENODATA),\n                                 \"AT_NULL terminator not found, cannot parse auxv structure.\");\n}\n\nstatic int parse_auxv32(\n                const uint32_t *auxv,\n                size_t size_bytes,\n                int *at_secure,\n                uid_t *uid,\n                uid_t *euid,\n                gid_t *gid,\n                gid_t *egid) {\n\n        assert(auxv || size_bytes == 0);\n\n        size_t words = size_bytes / sizeof(uint32_t);\n\n        if (size_bytes % (2 * sizeof(uint32_t)) != 0)\n                return log_warning_errno(SYNTHETIC_ERRNO(EIO), \"Incomplete auxv structure (%zu bytes).\", size_bytes);\n\n        /* Note that we set output variables even on error. */\n\n        for (size_t i = 0; i + 1 < words; i += 2)\n                switch (auxv[i]) {\n                case AT_SECURE:\n                        *at_secure = auxv[i + 1] != 0;\n                        break;\n                case AT_UID:\n                        *uid = auxv[i + 1];\n                        break;\n                case AT_EUID:\n                        *euid = auxv[i + 1];\n                        break;\n                case AT_GID:\n                        *gid = auxv[i + 1];\n                        break;\n                case AT_EGID:\n                        *egid = auxv[i + 1];\n                        break;\n                case AT_NULL:\n                        if (auxv[i + 1] != 0)\n                                goto error;\n                        return 0;\n                }\n error:\n        return log_warning_errno(SYNTHETIC_ERRNO(ENODATA),\n                                 \"AT_NULL terminator not found, cannot parse auxv structure.\");\n}\n\nstatic int grant_user_access(int core_fd, const Context *context) {\n        int at_secure = -1;\n        uid_t uid = UID_INVALID, euid = UID_INVALID;\n        uid_t gid = GID_INVALID, egid = GID_INVALID;\n        int r;\n\n        assert(core_fd >= 0);\n        assert(context);\n\n        if (!context->meta[META_PROC_AUXV])\n                return log_warning_errno(SYNTHETIC_ERRNO(ENODATA), \"No auxv data, not adjusting permissions.\");\n\n        uint8_t elf[EI_NIDENT];\n        errno = 0;\n        if (pread(core_fd, &elf, sizeof(elf), 0) != sizeof(elf))\n                return log_warning_errno(errno_or_else(EIO),\n                                         \"Failed to pread from coredump fd: %s\", STRERROR_OR_EOF(errno));\n\n        if (elf[EI_MAG0] != ELFMAG0 ||\n            elf[EI_MAG1] != ELFMAG1 ||\n            elf[EI_MAG2] != ELFMAG2 ||\n            elf[EI_MAG3] != ELFMAG3 ||\n            elf[EI_VERSION] != EV_CURRENT)\n                return log_info_errno(SYNTHETIC_ERRNO(EUCLEAN),\n                                      \"Core file does not have ELF header, not adjusting permissions.\");\n        if (!IN_SET(elf[EI_CLASS], ELFCLASS32, ELFCLASS64) ||\n            !IN_SET(elf[EI_DATA], ELFDATA2LSB, ELFDATA2MSB))\n                return log_info_errno(SYNTHETIC_ERRNO(EUCLEAN),\n                                      \"Core file has strange ELF class, not adjusting permissions.\");\n\n        if ((elf[EI_DATA] == ELFDATA2LSB) != (__BYTE_ORDER == __LITTLE_ENDIAN))\n                return log_info_errno(SYNTHETIC_ERRNO(EUCLEAN),\n                                      \"Core file has non-native endianness, not adjusting permissions.\");\n\n        if (elf[EI_CLASS] == ELFCLASS64)\n                r = parse_auxv64((const uint64_t*) context->meta[META_PROC_AUXV],\n                                 context->meta_size[META_PROC_AUXV],\n                                 &at_secure, &uid, &euid, &gid, &egid);\n        else\n                r = parse_auxv32((const uint32_t*) context->meta[META_PROC_AUXV],\n                                 context->meta_size[META_PROC_AUXV],\n                                 &at_secure, &uid, &euid, &gid, &egid);\n        if (r < 0)\n                return r;\n\n        /* We allow access if we got all the data and at_secure is not set and\n         * the uid/gid matches euid/egid. */\n        bool ret =\n                at_secure == 0 &&\n                uid != UID_INVALID && euid != UID_INVALID && uid == euid &&\n                gid != GID_INVALID && egid != GID_INVALID && gid == egid;\n        log_debug(\"Will %s access (uid=\"UID_FMT \" euid=\"UID_FMT \" gid=\"GID_FMT \" egid=\"GID_FMT \" at_secure=%s)\",\n                  ret ? \"permit\" : \"restrict\",\n                  uid, euid, gid, egid, yes_no(at_secure));\n        return ret;\n}\n\nstatic int save_external_coredump(\n                const Context *context,\n                int input_fd,\n                char **ret_filename,\n                int *ret_node_fd,\n                int *ret_data_fd,\n                uint64_t *ret_size,\n                uint64_t *ret_compressed_size,\n                bool *ret_truncated) {\n\n        _cleanup_(unlink_and_freep) char *tmp = NULL;\n        _cleanup_free_ char *fn = NULL;\n        _cleanup_close_ int fd = -EBADF;\n        uint64_t rlimit, process_limit, max_size;\n        bool truncated, storage_on_tmpfs;\n        struct stat st;\n        uid_t uid;\n        int r;\n\n        assert(context);\n        assert(ret_filename);\n        assert(ret_node_fd);\n        assert(ret_data_fd);\n        assert(ret_size);\n        assert(ret_compressed_size);\n        assert(ret_truncated);\n\n        r = parse_uid(context->meta[META_ARGV_UID], &uid);\n        if (r < 0)\n                return log_error_errno(r, \"Failed to parse UID: %m\");\n\n        r = safe_atou64(context->meta[META_ARGV_RLIMIT], &rlimit);\n        if (r < 0)\n                return log_error_errno(r, \"Failed to parse resource limit '%s': %m\",\n                                       context->meta[META_ARGV_RLIMIT]);\n        if (rlimit < page_size())\n                /* Is coredumping disabled? Then don't bother saving/processing the\n                 * coredump. Anything below PAGE_SIZE cannot give a readable coredump\n                 * (the kernel uses ELF_EXEC_PAGESIZE which is not easily accessible, but\n                 * is usually the same as PAGE_SIZE. */\n                return log_info_errno(SYNTHETIC_ERRNO(EBADSLT),\n                                      \"Resource limits disable core dumping for process %s (%s).\",\n                                      context->meta[META_ARGV_PID], context->meta[META_COMM]);\n\n        process_limit = MAX(arg_process_size_max, storage_size_max());\n        if (process_limit == 0)\n                return log_debug_errno(SYNTHETIC_ERRNO(EBADSLT),\n                                       \"Limits for coredump processing and storage are both 0, not dumping core.\");\n\n        /* Never store more than the process configured, or than we actually shall keep or process */\n        max_size = MIN(rlimit, process_limit);\n\n        r = make_filename(context, &fn);\n        if (r < 0)\n                return log_error_errno(r, \"Failed to determine coredump file name: %m\");\n\n        (void) mkdir_parents_label(fn, 0755);\n\n        fd = open_tmpfile_linkable(fn, O_RDWR|O_CLOEXEC, &tmp);\n        if (fd < 0)\n                return log_error_errno(fd, \"Failed to create temporary file for coredump %s: %m\", fn);\n\n        /* If storage is on tmpfs, the kernel oomd might kill us if there's MemoryMax set on\n         * the service or the slice it belongs to. This is common on low-resources systems,\n         * to avoid crashing processes to take away too many system resources.\n         * Check the cgroup settings, and set max_size to a bit less than half of the\n         * available memory left to the process.\n         * Then, attempt to write the core file uncompressed first - if the write gets\n         * interrupted, we know we won't be able to write it all, so instead compress what\n         * was written so far, delete the uncompressed truncated core, and then continue\n         * compressing from STDIN. Given the compressed core cannot be larger than the\n         * uncompressed one, and 1KB for metadata is accounted for in the calculation, we\n         * should be able to at least store the full compressed core file. */\n\n        storage_on_tmpfs = fd_is_temporary_fs(fd) > 0;\n        if (storage_on_tmpfs && arg_compress) {\n                _cleanup_(sd_bus_flush_close_unrefp) sd_bus *bus = NULL;\n                uint64_t cgroup_limit = UINT64_MAX;\n                struct statvfs sv;\n\n                /* If we can't get the cgroup limit, just ignore it, but don't fail,\n                 * try anyway with the config settings. */\n                r = sd_bus_default_system(&bus);\n                if (r < 0)\n                        log_info_errno(r, \"Failed to connect to system bus, skipping MemoryAvailable check: %m\");\n                else {\n                        _cleanup_(sd_bus_error_free) sd_bus_error error = SD_BUS_ERROR_NULL;\n\n                        r = sd_bus_get_property_trivial(\n                                        bus,\n                                        \"org.freedesktop.systemd1\",\n                                        \"/org/freedesktop/systemd1/unit/self\",\n                                        \"org.freedesktop.systemd1.Service\",\n                                        \"MemoryAvailable\",\n                                        &error,\n                                        't', &cgroup_limit);\n                        if (r < 0)\n                                log_warning_errno(r,\n                                                  \"Failed to query MemoryAvailable for current unit, \"\n                                                  \"falling back to static config settings: %s\",\n                                                  bus_error_message(&error, r));\n                }\n\n                max_size = MIN(cgroup_limit, max_size);\n                max_size = LESS_BY(max_size, 1024U) / 2; /* Account for 1KB metadata overhead for compressing */\n                max_size = MAX(PROCESS_SIZE_MIN, max_size); /* Impose a lower minimum */\n\n                /* tmpfs might get full quickly, so check the available space too.\n                 * But don't worry about errors here, failing to access the storage\n                 * location will be better logged when writing to it. */\n                if (statvfs(\"/var/lib/systemd/coredump/\", &sv) >= 0)\n                        max_size = MIN((uint64_t)sv.f_frsize * (uint64_t)sv.f_bfree, max_size);\n\n                log_debug(\"Limiting core file size to %\" PRIu64 \" bytes due to cgroup memory limits.\", max_size);\n        }\n\n        r = copy_bytes(input_fd, fd, max_size, 0);\n        if (r < 0)\n                return log_error_errno(r, \"Cannot store coredump of %s (%s): %m\",\n                                context->meta[META_ARGV_PID], context->meta[META_COMM]);\n        truncated = r == 1;\n\n        bool allow_user = grant_user_access(fd, context) > 0;\n\n#if HAVE_COMPRESSION\n        if (arg_compress) {\n                _cleanup_(unlink_and_freep) char *tmp_compressed = NULL;\n                _cleanup_free_ char *fn_compressed = NULL;\n                _cleanup_close_ int fd_compressed = -EBADF;\n                uint64_t uncompressed_size = 0;\n\n                if (lseek(fd, 0, SEEK_SET) == (off_t) -1)\n                        return log_error_errno(errno, \"Failed to seek on coredump %s: %m\", fn);\n\n                fn_compressed = strjoin(fn, default_compression_extension());\n                if (!fn_compressed)\n                        return log_oom();\n\n                fd_compressed = open_tmpfile_linkable(fn_compressed, O_RDWR|O_CLOEXEC, &tmp_compressed);\n                if (fd_compressed < 0)\n                        return log_error_errno(fd_compressed, \"Failed to create temporary file for coredump %s: %m\", fn_compressed);\n\n                r = compress_stream(fd, fd_compressed, max_size, &uncompressed_size);\n                if (r < 0)\n                        return log_error_errno(r, \"Failed to compress %s: %m\", coredump_tmpfile_name(tmp_compressed));\n\n                if (truncated && storage_on_tmpfs) {\n                        uint64_t partial_uncompressed_size = 0;\n\n                        /* Uncompressed write was truncated and we are writing to tmpfs: delete\n                         * the uncompressed core, and compress the remaining part from STDIN. */\n\n                        tmp = unlink_and_free(tmp);\n                        fd = safe_close(fd);\n\n                        r = compress_stream(input_fd, fd_compressed, max_size, &partial_uncompressed_size);\n                        if (r < 0)\n                                return log_error_errno(r, \"Failed to compress %s: %m\", coredump_tmpfile_name(tmp_compressed));\n                        uncompressed_size += partial_uncompressed_size;\n                }\n\n                r = fix_permissions(fd_compressed, tmp_compressed, fn_compressed, context, uid, allow_user);\n                if (r < 0)\n                        return r;\n\n                if (fstat(fd_compressed, &st) < 0)\n                        return log_error_errno(errno,\n                                        \"Failed to fstat core file %s: %m\",\n                                        coredump_tmpfile_name(tmp_compressed));\n\n                *ret_filename = TAKE_PTR(fn_compressed);       /* compressed */\n                *ret_node_fd = TAKE_FD(fd_compressed);         /* compressed */\n                *ret_compressed_size = (uint64_t) st.st_size;  /* compressed */\n                *ret_data_fd = TAKE_FD(fd);\n                *ret_size = uncompressed_size;\n                *ret_truncated = truncated;\n                tmp_compressed = mfree(tmp_compressed);\n\n                return 0;\n        }\n#endif\n\n        if (truncated)\n                log_struct(LOG_INFO,\n                           LOG_MESSAGE(\"Core file was truncated to %\"PRIu64\" bytes.\", max_size),\n                           \"SIZE_LIMIT=%\"PRIu64, max_size,\n                           \"MESSAGE_ID=\" SD_MESSAGE_TRUNCATED_CORE_STR);\n\n        r = fix_permissions(fd, tmp, fn, context, uid, allow_user);\n        if (r < 0)\n                return log_error_errno(r, \"Failed to fix permissions and finalize coredump %s into %s: %m\", coredump_tmpfile_name(tmp), fn);\n\n        if (fstat(fd, &st) < 0)\n                return log_error_errno(errno, \"Failed to fstat core file %s: %m\", coredump_tmpfile_name(tmp));\n\n        if (lseek(fd, 0, SEEK_SET) == (off_t) -1)\n                return log_error_errno(errno, \"Failed to seek on coredump %s: %m\", fn);\n\n        *ret_filename = TAKE_PTR(fn);\n        *ret_data_fd = TAKE_FD(fd);\n        *ret_size = (uint64_t) st.st_size;\n        *ret_truncated = truncated;\n\n        return 0;\n}\n\nstatic int allocate_journal_field(int fd, size_t size, char **ret, size_t *ret_size) {\n        _cleanup_free_ char *field = NULL;\n        ssize_t n;\n\n        assert(fd >= 0);\n        assert(ret);\n        assert(ret_size);\n\n        if (lseek(fd, 0, SEEK_SET) == (off_t) -1)\n                return log_warning_errno(errno, \"Failed to seek: %m\");\n\n        field = malloc(9 + size);\n        if (!field) {\n                log_warning(\"Failed to allocate memory for coredump, coredump will not be stored.\");\n                return -ENOMEM;\n        }\n\n        memcpy(field, \"COREDUMP=\", 9);\n\n        n = read(fd, field + 9, size);\n        if (n < 0)\n                return log_error_errno((int) n, \"Failed to read core data: %m\");\n        if ((size_t) n < size)\n                return log_error_errno(SYNTHETIC_ERRNO(EIO),\n                                       \"Core data too short.\");\n\n        *ret = TAKE_PTR(field);\n        *ret_size = size + 9;\n\n        return 0;\n}\n\n/* Joins /proc/[pid]/fd/ and /proc/[pid]/fdinfo/ into the following lines:\n * 0:/dev/pts/23\n * pos:    0\n * flags:  0100002\n *\n * 1:/dev/pts/23\n * pos:    0\n * flags:  0100002\n *\n * 2:/dev/pts/23\n * pos:    0\n * flags:  0100002\n * EOF\n */\nstatic int compose_open_fds(pid_t pid, char **open_fds) {\n        _cleanup_closedir_ DIR *proc_fd_dir = NULL;\n        _cleanup_close_ int proc_fdinfo_fd = -EBADF;\n        _cleanup_free_ char *buffer = NULL;\n        _cleanup_fclose_ FILE *stream = NULL;\n        const char *fddelim = \"\", *path;\n        size_t size = 0;\n        int r;\n\n        assert(pid >= 0);\n        assert(open_fds != NULL);\n\n        path = procfs_file_alloca(pid, \"fd\");\n        proc_fd_dir = opendir(path);\n        if (!proc_fd_dir)\n                return -errno;\n\n        proc_fdinfo_fd = openat(dirfd(proc_fd_dir), \"../fdinfo\", O_DIRECTORY|O_NOFOLLOW|O_CLOEXEC|O_PATH);\n        if (proc_fdinfo_fd < 0)\n                return -errno;\n\n        stream = open_memstream_unlocked(&buffer, &size);\n        if (!stream)\n                return -ENOMEM;\n\n        FOREACH_DIRENT(de, proc_fd_dir, return -errno) {\n                _cleanup_fclose_ FILE *fdinfo = NULL;\n                _cleanup_free_ char *fdname = NULL;\n                _cleanup_close_ int fd = -EBADF;\n\n                r = readlinkat_malloc(dirfd(proc_fd_dir), de->d_name, &fdname);\n                if (r < 0)\n                        return r;\n\n                fprintf(stream, \"%s%s:%s\\n\", fddelim, de->d_name, fdname);\n                fddelim = \"\\n\";\n\n                /* Use the directory entry from /proc/[pid]/fd with /proc/[pid]/fdinfo */\n                fd = openat(proc_fdinfo_fd, de->d_name, O_NOFOLLOW|O_CLOEXEC|O_RDONLY);\n                if (fd < 0)\n                        continue;\n\n                fdinfo = take_fdopen(&fd, \"r\");\n                if (!fdinfo)\n                        continue;\n\n                for (;;) {\n                        _cleanup_free_ char *line = NULL;\n\n                        r = read_line(fdinfo, LONG_LINE_MAX, &line);\n                        if (r < 0)\n                                return r;\n                        if (r == 0)\n                                break;\n\n                        fputs(line, stream);\n                        fputc('\\n', stream);\n                }\n        }\n\n        errno = 0;\n        stream = safe_fclose(stream);\n\n        if (errno > 0)\n                return -errno;\n\n        *open_fds = TAKE_PTR(buffer);\n\n        return 0;\n}\n\nstatic int get_process_ns(pid_t pid, const char *namespace, ino_t *ns) {\n        const char *p;\n        struct stat stbuf;\n        _cleanup_close_ int proc_ns_dir_fd = -EBADF;\n\n        p = procfs_file_alloca(pid, \"ns\");\n\n        proc_ns_dir_fd = open(p, O_DIRECTORY | O_CLOEXEC | O_RDONLY);\n        if (proc_ns_dir_fd < 0)\n                return -errno;\n\n        if (fstatat(proc_ns_dir_fd, namespace, &stbuf, /* flags */0) < 0)\n                return -errno;\n\n        *ns = stbuf.st_ino;\n        return 0;\n}\n\nstatic int get_mount_namespace_leader(pid_t pid, pid_t *ret) {\n        ino_t proc_mntns;\n        int r;\n\n        r = get_process_ns(pid, \"mnt\", &proc_mntns);\n        if (r < 0)\n                return r;\n\n        for (;;) {\n                ino_t parent_mntns;\n                pid_t ppid;\n\n                r = get_process_ppid(pid, &ppid);\n                if (r == -EADDRNOTAVAIL) /* Reached the top (i.e. typically PID 1, but could also be a process\n                                          * whose parent is not in our pidns) */\n                        return -ENOENT;\n                if (r < 0)\n                        return r;\n\n                r = get_process_ns(ppid, \"mnt\", &parent_mntns);\n                if (r < 0)\n                        return r;\n\n                if (proc_mntns != parent_mntns) {\n                        *ret = ppid;\n                        return 0;\n                }\n\n                pid = ppid;\n        }\n}\n\n/* Returns 1 if the parent was found.\n * Returns 0 if there is not a process we can call the pid's\n * container parent (the pid's process isn't 'containerized').\n * Returns a negative number on errors.\n */\nstatic int get_process_container_parent_cmdline(pid_t pid, char** cmdline) {\n        pid_t container_pid;\n        const char *proc_root_path;\n        struct stat root_stat, proc_root_stat;\n        int r;\n\n        /* To compare inodes of / and /proc/[pid]/root */\n        if (stat(\"/\", &root_stat) < 0)\n                return -errno;\n\n        proc_root_path = procfs_file_alloca(pid, \"root\");\n        if (stat(proc_root_path, &proc_root_stat) < 0)\n                return -errno;\n\n        /* The process uses system root. */\n        if (stat_inode_same(&proc_root_stat, &root_stat)) {\n                *cmdline = NULL;\n                return 0;\n        }\n\n        r = get_mount_namespace_leader(pid, &container_pid);\n        if (r < 0)\n                return r;\n\n        r = get_process_cmdline(container_pid, SIZE_MAX, PROCESS_CMDLINE_QUOTE_POSIX, cmdline);\n        if (r < 0)\n                return r;\n\n        return 1;\n}\n\nstatic int change_uid_gid(const Context *context) {\n        uid_t uid;\n        gid_t gid;\n        int r;\n\n        r = parse_uid(context->meta[META_ARGV_UID], &uid);\n        if (r < 0)\n                return r;\n\n        if (uid_is_system(uid)) {\n                const char *user = \"systemd-coredump\";\n\n                r = get_user_creds(&user, &uid, &gid, NULL, NULL, 0);\n                if (r < 0) {\n                        log_warning_errno(r, \"Cannot resolve %s user. Proceeding to dump core as root: %m\", user);\n                        uid = gid = 0;\n                }\n        } else {\n                r = parse_gid(context->meta[META_ARGV_GID], &gid);\n                if (r < 0)\n                        return r;\n        }\n\n        return drop_privileges(uid, gid, 0);\n}\n\nstatic int submit_coredump(\n                const Context *context,\n                struct iovec_wrapper *iovw,\n                int input_fd) {\n\n        _cleanup_(json_variant_unrefp) JsonVariant *json_metadata = NULL;\n        _cleanup_close_ int coredump_fd = -EBADF, coredump_node_fd = -EBADF;\n        _cleanup_free_ char *filename = NULL, *coredump_data = NULL;\n        _cleanup_free_ char *stacktrace = NULL;\n        char *core_message;\n        const char *module_name;\n        uint64_t coredump_size = UINT64_MAX, coredump_compressed_size = UINT64_MAX;\n        bool truncated = false;\n        JsonVariant *module_json;\n        int r;\n\n        assert(context);\n        assert(iovw);\n        assert(input_fd >= 0);\n\n        /* Vacuum before we write anything again */\n        (void) coredump_vacuum(-1, arg_keep_free, arg_max_use);\n\n        /* Always stream the coredump to disk, if that's possible */\n        r = save_external_coredump(context, input_fd,\n                                   &filename, &coredump_node_fd, &coredump_fd,\n                                   &coredump_size, &coredump_compressed_size, &truncated);\n        if (r < 0)\n                /* Skip whole core dumping part */\n                goto log;\n\n        /* If we don't want to keep the coredump on disk, remove it now, as later on we\n         * will lack the privileges for it. However, we keep the fd to it, so that we can\n         * still process it and log it. */\n        r = maybe_remove_external_coredump(filename, coredump_node_fd >= 0 ? coredump_compressed_size : coredump_size);\n        if (r < 0)\n                return r;\n        if (r == 0)\n                (void) iovw_put_string_field(iovw, \"COREDUMP_FILENAME=\", filename);\n        else if (arg_storage == COREDUMP_STORAGE_EXTERNAL)\n                log_info(\"The core will not be stored: size %\"PRIu64\" is greater than %\"PRIu64\" (the configured maximum)\",\n                         coredump_node_fd >= 0 ? coredump_compressed_size : coredump_size, arg_external_size_max);\n\n        /* Vacuum again, but exclude the coredump we just created */\n        (void) coredump_vacuum(coredump_node_fd >= 0 ? coredump_node_fd : coredump_fd, arg_keep_free, arg_max_use);\n\n        /* Now, let's drop privileges to become the user who owns the segfaulted process\n         * and allocate the coredump memory under the user's uid. This also ensures that\n         * the credentials journald will see are the ones of the coredumping user, thus\n         * making sure the user gets access to the core dump. Let's also get rid of all\n         * capabilities, if we run as root, we won't need them anymore. */\n        r = change_uid_gid(context);\n        if (r < 0)\n                return log_error_errno(r, \"Failed to drop privileges: %m\");\n\n        /* Try to get a stack trace if we can */\n        if (coredump_size > arg_process_size_max)\n                log_debug(\"Not generating stack trace: core size %\"PRIu64\" is greater \"\n                          \"than %\"PRIu64\" (the configured maximum)\",\n                          coredump_size, arg_process_size_max);\n        else if (coredump_fd >= 0) {\n                bool skip = startswith(context->meta[META_COMM], \"systemd-coredum\"); /* COMM is 16 bytes usually */\n\n                (void) parse_elf_object(coredump_fd,\n                                        context->meta[META_EXE],\n                                        /* fork_disable_dump= */ skip, /* avoid loops */\n                                        &stacktrace,\n                                        &json_metadata);\n        }\n\nlog:\n        core_message = strjoina(\"Process \", context->meta[META_ARGV_PID],\n                                \" (\", context->meta[META_COMM], \") of user \",\n                                context->meta[META_ARGV_UID], \" dumped core.\",\n                                context->is_journald && filename ? \"\\nCoredump diverted to \" : NULL,\n                                context->is_journald && filename ? filename : NULL);\n\n        core_message = strjoina(core_message, stacktrace ? \"\\n\\n\" : NULL, stacktrace);\n\n        if (context->is_journald)\n                /* We might not be able to log to the journal, so let's always print the message to another\n                 * log target. The target was set previously to something safe. */\n                log_dispatch(LOG_ERR, 0, core_message);\n\n        (void) iovw_put_string_field(iovw, \"MESSAGE=\", core_message);\n\n        if (truncated)\n                (void) iovw_put_string_field(iovw, \"COREDUMP_TRUNCATED=\", \"1\");\n\n        /* If we managed to parse any ELF metadata (build-id, ELF package meta),\n         * attach it as journal metadata. */\n        if (json_metadata) {\n                _cleanup_free_ char *formatted_json = NULL;\n\n                r = json_variant_format(json_metadata, 0, &formatted_json);\n                if (r < 0)\n                        return log_error_errno(r, \"Failed to format JSON package metadata: %m\");\n\n                (void) iovw_put_string_field(iovw, \"COREDUMP_PACKAGE_JSON=\", formatted_json);\n        }\n\n        /* In the unlikely scenario that context->meta[META_EXE] is not available,\n         * let's avoid guessing the module name and skip the loop. */\n        if (context->meta[META_EXE])\n                JSON_VARIANT_OBJECT_FOREACH(module_name, module_json, json_metadata) {\n                        JsonVariant *t;\n\n                        /* We only add structured fields for the 'main' ELF module, and only if we can identify it. */\n                        if (!path_equal_filename(module_name, context->meta[META_EXE]))\n                                continue;\n\n                        t = json_variant_by_key(module_json, \"name\");\n                        if (t)\n                                (void) iovw_put_string_field(iovw, \"COREDUMP_PACKAGE_NAME=\", json_variant_string(t));\n\n                        t = json_variant_by_key(module_json, \"version\");\n                        if (t)\n                                (void) iovw_put_string_field(iovw, \"COREDUMP_PACKAGE_VERSION=\", json_variant_string(t));\n                }\n\n        /* Optionally store the entire coredump in the journal */\n        if (arg_storage == COREDUMP_STORAGE_JOURNAL && coredump_fd >= 0) {\n                if (coredump_size <= arg_journal_size_max) {\n                        size_t sz = 0;\n\n                        /* Store the coredump itself in the journal */\n\n                        r = allocate_journal_field(coredump_fd, (size_t) coredump_size, &coredump_data, &sz);\n                        if (r >= 0) {\n                                if (iovw_put(iovw, coredump_data, sz) >= 0)\n                                        TAKE_PTR(coredump_data);\n                        } else\n                                log_warning_errno(r, \"Failed to attach the core to the journal entry: %m\");\n                } else\n                        log_info(\"The core will not be stored: size %\"PRIu64\" is greater than %\"PRIu64\" (the configured maximum)\",\n                                 coredump_size, arg_journal_size_max);\n        }\n\n        /* If journald is coredumping, we have to be careful that we don't deadlock when trying to write the\n         * coredump to the journal, so we put the journal socket in nonblocking mode before trying to write\n         * the coredump to the socket. */\n\n        if (context->is_journald) {\n                r = journal_fd_nonblock(true);\n                if (r < 0)\n                        return log_error_errno(r, \"Failed to make journal socket non-blocking: %m\");\n        }\n\n        r = sd_journal_sendv(iovw->iovec, iovw->count);\n\n        if (context->is_journald) {\n                int k;\n\n                k = journal_fd_nonblock(false);\n                if (k < 0)\n                        return log_error_errno(k, \"Failed to make journal socket blocking: %m\");\n        }\n\n        if (r == -EAGAIN && context->is_journald)\n                log_warning_errno(r, \"Failed to log journal coredump, ignoring: %m\");\n        else if (r < 0)\n                return log_error_errno(r, \"Failed to log coredump: %m\");\n\n        return 0;\n}\n\nstatic int save_context(Context *context, const struct iovec_wrapper *iovw) {\n        const char *unit;\n        int r;\n\n        assert(context);\n        assert(iovw);\n        assert(iovw->count >= _META_ARGV_MAX);\n\n        /* The context does not allocate any memory on its own */\n\n        for (size_t n = 0; n < iovw->count; n++) {\n                struct iovec *iovec = iovw->iovec + n;\n\n                for (size_t i = 0; i < ELEMENTSOF(meta_field_names); i++) {\n                        /* Note that these strings are NUL terminated, because we made sure that a\n                         * trailing NUL byte is in the buffer, though not included in the iov_len\n                         * count (see process_socket() and gather_pid_metadata_*()) */\n                        assert(((char*) iovec->iov_base)[iovec->iov_len] == 0);\n\n                        const char *p = startswith(iovec->iov_base, meta_field_names[i]);\n                        if (p) {\n                                context->meta[i] = p;\n                                context->meta_size[i] = iovec->iov_len - strlen(meta_field_names[i]);\n                                break;\n                        }\n                }\n        }\n\n        if (!context->meta[META_ARGV_PID])\n                return log_error_errno(SYNTHETIC_ERRNO(EINVAL),\n                                       \"Failed to find the PID of crashing process\");\n\n        r = parse_pid(context->meta[META_ARGV_PID], &context->pid);\n        if (r < 0)\n                return log_error_errno(r, \"Failed to parse PID \\\"%s\\\": %m\", context->meta[META_ARGV_PID]);\n\n        unit = context->meta[META_UNIT];\n        context->is_pid1 = streq(context->meta[META_ARGV_PID], \"1\") || streq_ptr(unit, SPECIAL_INIT_SCOPE);\n        context->is_journald = streq_ptr(unit, SPECIAL_JOURNALD_SERVICE);\n\n        return 0;\n}\n\nstatic int process_socket(int fd) {\n        _cleanup_close_ int input_fd = -EBADF;\n        Context context = {};\n        struct iovec_wrapper iovw = {};\n        struct iovec iovec;\n        int r;\n\n        assert(fd >= 0);\n\n        log_setup();\n\n        log_debug(\"Processing coredump received on stdin...\");\n\n        for (;;) {\n                CMSG_BUFFER_TYPE(CMSG_SPACE(sizeof(int))) control;\n                struct msghdr mh = {\n                        .msg_control = &control,\n                        .msg_controllen = sizeof(control),\n                        .msg_iovlen = 1,\n                };\n                ssize_t n;\n                ssize_t l;\n\n                l = next_datagram_size_fd(fd);\n                if (l < 0) {\n                        r = log_error_errno(l, \"Failed to determine datagram size to read: %m\");\n                        goto finish;\n                }\n\n                iovec.iov_len = l;\n                iovec.iov_base = malloc(l + 1);\n                if (!iovec.iov_base) {\n                        r = log_oom();\n                        goto finish;\n                }\n\n                mh.msg_iov = &iovec;\n\n                n = recvmsg_safe(fd, &mh, MSG_CMSG_CLOEXEC);\n                if (n < 0)  {\n                        free(iovec.iov_base);\n                        r = log_error_errno(n, \"Failed to receive datagram: %m\");\n                        goto finish;\n                }\n\n                /* The final zero-length datagram carries the file descriptor and tells us\n                 * that we're done. */\n                if (n == 0) {\n                        struct cmsghdr *found;\n\n                        free(iovec.iov_base);\n\n                        found = cmsg_find(&mh, SOL_SOCKET, SCM_RIGHTS, CMSG_LEN(sizeof(int)));\n                        if (!found) {\n                                cmsg_close_all(&mh);\n                                r = log_error_errno(SYNTHETIC_ERRNO(EBADMSG),\n                                                    \"Coredump file descriptor missing.\");\n                                goto finish;\n                        }\n\n                        assert(input_fd < 0);\n                        input_fd = *(int*) CMSG_DATA(found);\n                        break;\n                } else\n                        cmsg_close_all(&mh);\n\n                /* Add trailing NUL byte, in case these are strings */\n                ((char*) iovec.iov_base)[n] = 0;\n                iovec.iov_len = (size_t) n;\n\n                r = iovw_put(&iovw, iovec.iov_base, iovec.iov_len);\n                if (r < 0)\n                        goto finish;\n        }\n\n        /* Make sure we got all data we really need */\n        assert(input_fd >= 0);\n\n        r = save_context(&context, &iovw);\n        if (r < 0)\n                goto finish;\n\n        /* Make sure we received at least all fields we need. */\n        for (int i = 0; i < _META_MANDATORY_MAX; i++)\n                if (!context.meta[i]) {\n                        r = log_error_errno(SYNTHETIC_ERRNO(EINVAL),\n                                            \"A mandatory argument (%i) has not been sent, aborting.\",\n                                            i);\n                        goto finish;\n                }\n\n        r = submit_coredump(&context, &iovw, input_fd);\n\nfinish:\n        iovw_free_contents(&iovw, true);\n        return r;\n}\n\nstatic int send_iovec(const struct iovec_wrapper *iovw, int input_fd) {\n        _cleanup_close_ int fd = -EBADF;\n        int r;\n\n        assert(iovw);\n        assert(input_fd >= 0);\n\n        fd = socket(AF_UNIX, SOCK_SEQPACKET|SOCK_CLOEXEC, 0);\n        if (fd < 0)\n                return log_error_errno(errno, \"Failed to create coredump socket: %m\");\n\n        r = connect_unix_path(fd, AT_FDCWD, \"/run/systemd/coredump\");\n        if (r < 0)\n                return log_error_errno(r, \"Failed to connect to coredump service: %m\");\n\n        for (size_t i = 0; i < iovw->count; i++) {\n                struct msghdr mh = {\n                        .msg_iov = iovw->iovec + i,\n                        .msg_iovlen = 1,\n                };\n                struct iovec copy[2];\n\n                for (;;) {\n                        if (sendmsg(fd, &mh, MSG_NOSIGNAL) >= 0)\n                                break;\n\n                        if (errno == EMSGSIZE && mh.msg_iov[0].iov_len > 0) {\n                                /* This field didn't fit? That's a pity. Given that this is\n                                 * just metadata, let's truncate the field at half, and try\n                                 * again. We append three dots, in order to show that this is\n                                 * truncated. */\n\n                                if (mh.msg_iov != copy) {\n                                        /* We don't want to modify the caller's iovec, hence\n                                         * let's create our own array, consisting of two new\n                                         * iovecs, where the first is a (truncated) copy of\n                                         * what we want to send, and the second one contains\n                                         * the trailing dots. */\n                                        copy[0] = iovw->iovec[i];\n                                        copy[1] = IOVEC_MAKE(((char[]){'.', '.', '.'}), 3);\n\n                                        mh.msg_iov = copy;\n                                        mh.msg_iovlen = 2;\n                                }\n\n                                copy[0].iov_len /= 2; /* halve it, and try again */\n                                continue;\n                        }\n\n                        return log_error_errno(errno, \"Failed to send coredump datagram: %m\");\n                }\n        }\n\n        r = send_one_fd(fd, input_fd, 0);\n        if (r < 0)\n                return log_error_errno(r, \"Failed to send coredump fd: %m\");\n\n        return 0;\n}\n\nstatic int gather_pid_metadata_from_argv(\n                struct iovec_wrapper *iovw,\n                Context *context,\n                int argc, char **argv) {\n\n        _cleanup_free_ char *free_timestamp = NULL;\n        int r, signo;\n        char *t;\n\n        /* We gather all metadata that were passed via argv[] into an array of iovecs that\n         * we'll forward to the socket unit */\n\n        if (argc < _META_ARGV_MAX)\n                return log_error_errno(SYNTHETIC_ERRNO(EINVAL),\n                                       \"Not enough arguments passed by the kernel (%i, expected %i).\",\n                                       argc, _META_ARGV_MAX);\n\n        for (int i = 0; i < _META_ARGV_MAX; i++) {\n\n                t = argv[i];\n\n                switch (i) {\n\n                case META_ARGV_TIMESTAMP:\n                        /* The journal fields contain the timestamp padded with six\n                         * zeroes, so that the kernel-supplied 1s granularity timestamps\n                         * becomes 1\u00b5s granularity, i.e. the granularity systemd usually\n                         * operates in. */\n                        t = free_timestamp = strjoin(argv[i], \"000000\");\n                        if (!t)\n                                return log_oom();\n                        break;\n\n                case META_ARGV_SIGNAL:\n                        /* For signal, record its pretty name too */\n                        if (safe_atoi(argv[i], &signo) >= 0 && SIGNAL_VALID(signo))\n                                (void) iovw_put_string_field(iovw, \"COREDUMP_SIGNAL_NAME=SIG\",\n                                                             signal_to_string(signo));\n                        break;\n\n                default:\n                        break;\n                }\n\n                r = iovw_put_string_field(iovw, meta_field_names[i], t);\n                if (r < 0)\n                        return r;\n        }\n\n        /* Cache some of the process metadata we collected so far and that we'll need to\n         * access soon */\n        return save_context(context, iovw);\n}\n\nstatic int gather_pid_metadata(struct iovec_wrapper *iovw, Context *context) {\n        uid_t owner_uid;\n        pid_t pid;\n        char *t;\n        size_t size;\n        const char *p;\n        int r;\n\n        /* Note that if we fail on oom later on, we do not roll-back changes to the iovec\n         * structure. (It remains valid, with the first iovec fields initialized.) */\n\n        pid = context->pid;\n\n        /* The following is mandatory */\n        r = get_process_comm(pid, &t);\n        if (r < 0)\n                return log_error_errno(r, \"Failed to get COMM: %m\");\n\n        r = iovw_put_string_field_free(iovw, \"COREDUMP_COMM=\", t);\n        if (r < 0)\n                return r;\n\n        /* The following are optional, but we use them if present. */\n        r = get_process_exe(pid, &t);\n        if (r >= 0)\n                r = iovw_put_string_field_free(iovw, \"COREDUMP_EXE=\", t);\n        if (r < 0)\n                log_warning_errno(r, \"Failed to get EXE, ignoring: %m\");\n\n        if (cg_pid_get_unit(pid, &t) >= 0)\n                (void) iovw_put_string_field_free(iovw, \"COREDUMP_UNIT=\", t);\n\n        if (cg_pid_get_user_unit(pid, &t) >= 0)\n                (void) iovw_put_string_field_free(iovw, \"COREDUMP_USER_UNIT=\", t);\n\n        if (sd_pid_get_session(pid, &t) >= 0)\n                (void) iovw_put_string_field_free(iovw, \"COREDUMP_SESSION=\", t);\n\n        if (sd_pid_get_owner_uid(pid, &owner_uid) >= 0) {\n                r = asprintf(&t, UID_FMT, owner_uid);\n                if (r > 0)\n                        (void) iovw_put_string_field_free(iovw, \"COREDUMP_OWNER_UID=\", t);\n        }\n\n        if (sd_pid_get_slice(pid, &t) >= 0)\n                (void) iovw_put_string_field_free(iovw, \"COREDUMP_SLICE=\", t);\n\n        if (get_process_cmdline(pid, SIZE_MAX, PROCESS_CMDLINE_QUOTE_POSIX, &t) >= 0)\n                (void) iovw_put_string_field_free(iovw, \"COREDUMP_CMDLINE=\", t);\n\n        if (cg_pid_get_path_shifted(pid, NULL, &t) >= 0)\n                (void) iovw_put_string_field_free(iovw, \"COREDUMP_CGROUP=\", t);\n\n        if (compose_open_fds(pid, &t) >= 0)\n                (void) iovw_put_string_field_free(iovw, \"COREDUMP_OPEN_FDS=\", t);\n\n        p = procfs_file_alloca(pid, \"status\");\n        if (read_full_virtual_file(p, &t, NULL) >= 0)\n                (void) iovw_put_string_field_free(iovw, \"COREDUMP_PROC_STATUS=\", t);\n\n        p = procfs_file_alloca(pid, \"maps\");\n        if (read_full_virtual_file(p, &t, NULL) >= 0)\n                (void) iovw_put_string_field_free(iovw, \"COREDUMP_PROC_MAPS=\", t);\n\n        p = procfs_file_alloca(pid, \"limits\");\n        if (read_full_virtual_file(p, &t, NULL) >= 0)\n                (void) iovw_put_string_field_free(iovw, \"COREDUMP_PROC_LIMITS=\", t);\n\n        p = procfs_file_alloca(pid, \"cgroup\");\n        if (read_full_virtual_file(p, &t, NULL) >= 0)\n                (void) iovw_put_string_field_free(iovw, \"COREDUMP_PROC_CGROUP=\", t);\n\n        p = procfs_file_alloca(pid, \"mountinfo\");\n        if (read_full_virtual_file(p, &t, NULL) >= 0)\n                (void) iovw_put_string_field_free(iovw, \"COREDUMP_PROC_MOUNTINFO=\", t);\n\n        /* We attach /proc/auxv here. ELF coredumps also contain a note for this (NT_AUXV), see elf(5). */\n        p = procfs_file_alloca(pid, \"auxv\");\n        if (read_full_virtual_file(p, &t, &size) >= 0) {\n                char *buf = malloc(strlen(\"COREDUMP_PROC_AUXV=\") + size + 1);\n                if (buf) {\n                        /* Add a dummy terminator to make save_context() happy. */\n                        *((uint8_t*) mempcpy(stpcpy(buf, \"COREDUMP_PROC_AUXV=\"), t, size)) = '\\0';\n                        (void) iovw_consume(iovw, buf, size + strlen(\"COREDUMP_PROC_AUXV=\"));\n                }\n\n                free(t);\n        }\n\n        if (get_process_cwd(pid, &t) >= 0)\n                (void) iovw_put_string_field_free(iovw, \"COREDUMP_CWD=\", t);\n\n        if (get_process_root(pid, &t) >= 0) {\n                bool proc_self_root_is_slash;\n\n                proc_self_root_is_slash = strcmp(t, \"/\") == 0;\n\n                (void) iovw_put_string_field_free(iovw, \"COREDUMP_ROOT=\", t);\n\n                /* If the process' root is \"/\", then there is a chance it has\n                 * mounted own root and hence being containerized. */\n                if (proc_self_root_is_slash && get_process_container_parent_cmdline(pid, &t) > 0)\n                        (void) iovw_put_string_field_free(iovw, \"COREDUMP_CONTAINER_CMDLINE=\", t);\n        }\n\n        if (get_process_environ(pid, &t) >= 0)\n                (void) iovw_put_string_field_free(iovw, \"COREDUMP_ENVIRON=\", t);\n\n        /* we successfully acquired all metadata */\n        return save_context(context, iovw);\n}\n\nstatic int process_kernel(int argc, char* argv[]) {\n        Context context = {};\n        struct iovec_wrapper *iovw;\n        int r;\n\n        /* When we're invoked by the kernel, stdout/stderr are closed which is dangerous because the fds\n         * could get reallocated. To avoid hard to debug issues, let's instead bind stdout/stderr to\n         * /dev/null. */\n        r = rearrange_stdio(STDIN_FILENO, -1, -1);\n        if (r < 0)\n                return log_error_errno(r, \"Failed to connect stdout/stderr to /dev/null: %m\");\n\n        log_debug(\"Processing coredump received from the kernel...\");\n\n        iovw = iovw_new();\n        if (!iovw)\n                return log_oom();\n\n        (void) iovw_put_string_field(iovw, \"MESSAGE_ID=\", SD_MESSAGE_COREDUMP_STR);\n        (void) iovw_put_string_field(iovw, \"PRIORITY=\", STRINGIFY(LOG_CRIT));\n\n        /* Collect all process metadata passed by the kernel through argv[] */\n        r = gather_pid_metadata_from_argv(iovw, &context, argc - 1, argv + 1);\n        if (r < 0)\n                goto finish;\n\n        /* Collect the rest of the process metadata retrieved from the runtime */\n        r = gather_pid_metadata(iovw, &context);\n        if (r < 0)\n                goto finish;\n\n        if (!context.is_journald) {\n                /* OK, now we know it's not the journal, hence we can make use of it now. */\n                log_set_target(LOG_TARGET_JOURNAL_OR_KMSG);\n                log_open();\n        }\n\n        /* If this is PID 1 disable coredump collection, we'll unlikely be able to process\n         * it later on.\n         *\n         * FIXME: maybe we should disable coredumps generation from the beginning and\n         * re-enable it only when we know it's either safe (ie we're not running OOM) or\n         * it's not pid1 ? */\n        if (context.is_pid1) {\n                log_notice(\"Due to PID 1 having crashed coredump collection will now be turned off.\");\n                disable_coredumps();\n        }\n\n        if (context.is_journald || context.is_pid1)\n                r = submit_coredump(&context, iovw, STDIN_FILENO);\n        else\n                r = send_iovec(iovw, STDIN_FILENO);\n\n finish:\n        iovw = iovw_free_free(iovw);\n        return r;\n}\n\nstatic int process_backtrace(int argc, char *argv[]) {\n        Context context = {};\n        struct iovec_wrapper *iovw;\n        char *message;\n        int r;\n         _cleanup_(journal_importer_cleanup) JournalImporter importer = JOURNAL_IMPORTER_INIT(STDIN_FILENO);\n\n        log_debug(\"Processing backtrace on stdin...\");\n\n        iovw = iovw_new();\n        if (!iovw)\n                return log_oom();\n\n        (void) iovw_put_string_field(iovw, \"MESSAGE_ID=\", SD_MESSAGE_BACKTRACE_STR);\n        (void) iovw_put_string_field(iovw, \"PRIORITY=\", STRINGIFY(LOG_CRIT));\n\n        /* Collect all process metadata from argv[] by making sure to skip the\n         * '--backtrace' option */\n        r = gather_pid_metadata_from_argv(iovw, &context, argc - 2, argv + 2);\n        if (r < 0)\n                goto finish;\n\n        /* Collect the rest of the process metadata retrieved from the runtime */\n        r = gather_pid_metadata(iovw, &context);\n        if (r < 0)\n                goto finish;\n\n        for (;;) {\n                r = journal_importer_process_data(&importer);\n                if (r < 0) {\n                        log_error_errno(r, \"Failed to parse journal entry on stdin: %m\");\n                        goto finish;\n                }\n                if (r == 1 ||                        /* complete entry */\n                    journal_importer_eof(&importer)) /* end of data */\n                        break;\n        }\n\n        if (journal_importer_eof(&importer)) {\n                log_warning(\"Did not receive a full journal entry on stdin, ignoring message sent by reporter\");\n\n                message = strjoina(\"Process \", context.meta[META_ARGV_PID],\n                                  \" (\", context.meta[META_COMM], \")\"\n                                  \" of user \", context.meta[META_ARGV_UID],\n                                  \" failed with \", context.meta[META_ARGV_SIGNAL]);\n\n                r = iovw_put_string_field(iovw, \"MESSAGE=\", message);\n                if (r < 0)\n                        return r;\n        } else {\n                /* The imported iovecs are not supposed to be freed by us so let's store\n                 * them at the end of the array so we can skip them while freeing the\n                 * rest. */\n                for (size_t i = 0; i < importer.iovw.count; i++) {\n                        struct iovec *iovec = importer.iovw.iovec + i;\n\n                        iovw_put(iovw, iovec->iov_base, iovec->iov_len);\n                }\n        }\n\n        r = sd_journal_sendv(iovw->iovec, iovw->count);\n        if (r < 0)\n                log_error_errno(r, \"Failed to log backtrace: %m\");\n\n finish:\n        iovw->count -= importer.iovw.count;\n        iovw = iovw_free_free(iovw);\n        return r;\n}\n\nstatic int run(int argc, char *argv[]) {\n        int r;\n\n        /* First, log to a safe place, since we don't know what crashed and it might\n         * be journald which we'd rather not log to then. */\n\n        log_set_target(LOG_TARGET_KMSG);\n        log_open();\n\n        /* Make sure we never enter a loop */\n        (void) prctl(PR_SET_DUMPABLE, 0);\n\n        /* Ignore all parse errors */\n        (void) parse_config();\n\n        log_debug(\"Selected storage '%s'.\", coredump_storage_to_string(arg_storage));\n        log_debug(\"Selected compression %s.\", yes_no(arg_compress));\n\n        r = sd_listen_fds(false);\n        if (r < 0)\n                return log_error_errno(r, \"Failed to determine the number of file descriptors: %m\");\n\n        /* If we got an fd passed, we are running in coredumpd mode. Otherwise we\n         * are invoked from the kernel as coredump handler. */\n        if (r == 0) {\n                if (streq_ptr(argv[1], \"--backtrace\"))\n                        return process_backtrace(argc, argv);\n                else\n                        return process_kernel(argc, argv);\n        } else if (r == 1)\n                return process_socket(SD_LISTEN_FDS_START);\n\n        return log_error_errno(SYNTHETIC_ERRNO(EINVAL),\n                               \"Received unexpected number of file descriptors.\");\n}\n\nDEFINE_MAIN_FUNCTION(run);\n"], "filenames": ["src/basic/io-util.h", "src/coredump/coredump.c"], "buggy_code_start_loc": [93, 6], "buggy_code_end_loc": [94, 1263], "fixing_code_start_loc": [94, 7], "fixing_code_end_loc": [104, 1434], "type": "NVD-CWE-noinfo", "message": "A vulnerability was found in systemd. This security flaw can cause a local information leak due to systemd-coredump not respecting the fs.suid_dumpable kernel setting.", "other": {"cve": {"id": "CVE-2022-4415", "sourceIdentifier": "secalert@redhat.com", "published": "2023-01-11T15:15:09.590", "lastModified": "2023-02-02T16:19:28.633", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A vulnerability was found in systemd. This security flaw can cause a local information leak due to systemd-coredump not respecting the fs.suid_dumpable kernel setting."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}, {"source": "secalert@redhat.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-200"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:systemd_project:systemd:*:*:*:*:*:*:*:*", "versionStartIncluding": "246", "versionEndExcluding": "253", "matchCriteriaId": "7B98D853-84AB-4D2C-99A3-C7ED5FD44B2C"}]}]}], "references": [{"url": "https://github.com/systemd/systemd/commit/b7641425659243c09473cd8fb3aef2c0d4a3eb9c", "source": "secalert@redhat.com", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://www.openwall.com/lists/oss-security/2022/12/21/3", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/systemd/systemd/commit/b7641425659243c09473cd8fb3aef2c0d4a3eb9c"}}