{"buggy_code": ["package server\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/pkg/errors\"\n\t\"github.com/usememos/memos/api\"\n\t\"github.com/usememos/memos/common\"\n\tmetric \"github.com/usememos/memos/plugin/metrics\"\n\n\t\"github.com/labstack/echo/v4\"\n)\n\nconst (\n\t// The max file size is 32MB.\n\tmaxFileSize = 32 << 20\n)\n\nfunc (s *Server) registerResourceRoutes(g *echo.Group) {\n\tg.POST(\"/resource\", func(c echo.Context) error {\n\t\tctx := c.Request().Context()\n\t\tuserID, ok := c.Get(getUserIDContextKey()).(int)\n\t\tif !ok {\n\t\t\treturn echo.NewHTTPError(http.StatusUnauthorized, \"Missing user in session\")\n\t\t}\n\n\t\tresourceCreate := &api.ResourceCreate{}\n\t\tif err := json.NewDecoder(c.Request().Body).Decode(resourceCreate); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, \"Malformatted post resource request\").SetInternal(err)\n\t\t}\n\n\t\tresourceCreate.CreatorID = userID\n\t\tresource, err := s.Store.CreateResource(ctx, resourceCreate)\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to create resource\").SetInternal(err)\n\t\t}\n\t\tif err := s.createResourceCreateActivity(c, resource); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to create activity\").SetInternal(err)\n\t\t}\n\n\t\tc.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)\n\t\tif err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(resource)); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to encode resource response\").SetInternal(err)\n\t\t}\n\t\treturn nil\n\t})\n\n\tg.POST(\"/resource/blob\", func(c echo.Context) error {\n\t\tctx := c.Request().Context()\n\t\tuserID, ok := c.Get(getUserIDContextKey()).(int)\n\t\tif !ok {\n\t\t\treturn echo.NewHTTPError(http.StatusUnauthorized, \"Missing user in session\")\n\t\t}\n\n\t\tif err := c.Request().ParseMultipartForm(maxFileSize); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, \"Upload file overload max size\").SetInternal(err)\n\t\t}\n\n\t\tfile, err := c.FormFile(\"file\")\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to get uploading file\").SetInternal(err)\n\t\t}\n\t\tif file == nil {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, \"Upload file not found\").SetInternal(err)\n\t\t}\n\n\t\tfilename := file.Filename\n\t\tfiletype := file.Header.Get(\"Content-Type\")\n\t\tsize := file.Size\n\t\tsrc, err := file.Open()\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to open file\").SetInternal(err)\n\t\t}\n\t\tdefer src.Close()\n\n\t\tfileBytes, err := io.ReadAll(src)\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to read file\").SetInternal(err)\n\t\t}\n\n\t\tresourceCreate := &api.ResourceCreate{\n\t\t\tCreatorID: userID,\n\t\t\tFilename:  filename,\n\t\t\tType:      filetype,\n\t\t\tSize:      size,\n\t\t\tBlob:      fileBytes,\n\t\t}\n\t\tresource, err := s.Store.CreateResource(ctx, resourceCreate)\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to create resource\").SetInternal(err)\n\t\t}\n\t\tif err := s.createResourceCreateActivity(c, resource); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to create activity\").SetInternal(err)\n\t\t}\n\n\t\tc.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)\n\t\tif err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(resource)); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to encode resource response\").SetInternal(err)\n\t\t}\n\t\treturn nil\n\t})\n\n\tg.GET(\"/resource\", func(c echo.Context) error {\n\t\tctx := c.Request().Context()\n\t\tuserID, ok := c.Get(getUserIDContextKey()).(int)\n\t\tif !ok {\n\t\t\treturn echo.NewHTTPError(http.StatusUnauthorized, \"Missing user in session\")\n\t\t}\n\t\tresourceFind := &api.ResourceFind{\n\t\t\tCreatorID: &userID,\n\t\t}\n\t\tlist, err := s.Store.FindResourceList(ctx, resourceFind)\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to fetch resource list\").SetInternal(err)\n\t\t}\n\n\t\tfor _, resource := range list {\n\t\t\tmemoResourceList, err := s.Store.FindMemoResourceList(ctx, &api.MemoResourceFind{\n\t\t\t\tResourceID: &resource.ID,\n\t\t\t})\n\t\t\tif err != nil {\n\t\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to find memo resource list\").SetInternal(err)\n\t\t\t}\n\t\t\tresource.LinkedMemoAmount = len(memoResourceList)\n\t\t}\n\n\t\tc.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)\n\t\tif err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(list)); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to encode resource list response\").SetInternal(err)\n\t\t}\n\t\treturn nil\n\t})\n\n\tg.GET(\"/resource/:resourceId\", func(c echo.Context) error {\n\t\tctx := c.Request().Context()\n\t\tresourceID, err := strconv.Atoi(c.Param(\"resourceId\"))\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf(\"ID is not a number: %s\", c.Param(\"resourceId\"))).SetInternal(err)\n\t\t}\n\n\t\tuserID, ok := c.Get(getUserIDContextKey()).(int)\n\t\tif !ok {\n\t\t\treturn echo.NewHTTPError(http.StatusUnauthorized, \"Missing user in session\")\n\t\t}\n\t\tresourceFind := &api.ResourceFind{\n\t\t\tID:        &resourceID,\n\t\t\tCreatorID: &userID,\n\t\t\tGetBlob:   true,\n\t\t}\n\t\tresource, err := s.Store.FindResource(ctx, resourceFind)\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to fetch resource\").SetInternal(err)\n\t\t}\n\n\t\tc.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)\n\t\tif err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(resource)); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to encode resource response\").SetInternal(err)\n\t\t}\n\t\treturn nil\n\t})\n\n\tg.GET(\"/resource/:resourceId/blob\", func(c echo.Context) error {\n\t\tctx := c.Request().Context()\n\t\tresourceID, err := strconv.Atoi(c.Param(\"resourceId\"))\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf(\"ID is not a number: %s\", c.Param(\"resourceId\"))).SetInternal(err)\n\t\t}\n\n\t\tuserID, ok := c.Get(getUserIDContextKey()).(int)\n\t\tif !ok {\n\t\t\treturn echo.NewHTTPError(http.StatusUnauthorized, \"Missing user in session\")\n\t\t}\n\t\tresourceFind := &api.ResourceFind{\n\t\t\tID:        &resourceID,\n\t\t\tCreatorID: &userID,\n\t\t\tGetBlob:   true,\n\t\t}\n\t\tresource, err := s.Store.FindResource(ctx, resourceFind)\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to fetch resource\").SetInternal(err)\n\t\t}\n\n\t\tc.Response().Writer.WriteHeader(http.StatusOK)\n\t\tc.Response().Writer.Header().Set(\"Content-Type\", resource.Type)\n\t\tc.Response().Writer.Header().Set(echo.HeaderContentSecurityPolicy, \"default-src 'self'\")\n\t\tif _, err := c.Response().Writer.Write(resource.Blob); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to write resource blob\").SetInternal(err)\n\t\t}\n\t\treturn nil\n\t})\n\n\tg.PATCH(\"/resource/:resourceId\", func(c echo.Context) error {\n\t\tctx := c.Request().Context()\n\t\tuserID, ok := c.Get(getUserIDContextKey()).(int)\n\t\tif !ok {\n\t\t\treturn echo.NewHTTPError(http.StatusUnauthorized, \"Missing user in session\")\n\t\t}\n\n\t\tresourceID, err := strconv.Atoi(c.Param(\"resourceId\"))\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf(\"ID is not a number: %s\", c.Param(\"resourceId\"))).SetInternal(err)\n\t\t}\n\n\t\tresourceFind := &api.ResourceFind{\n\t\t\tID: &resourceID,\n\t\t}\n\t\tresource, err := s.Store.FindResource(ctx, resourceFind)\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to find resource\").SetInternal(err)\n\t\t}\n\t\tif resource.CreatorID != userID {\n\t\t\treturn echo.NewHTTPError(http.StatusUnauthorized, \"Unauthorized\")\n\t\t}\n\n\t\tcurrentTs := time.Now().Unix()\n\t\tresourcePatch := &api.ResourcePatch{\n\t\t\tUpdatedTs: &currentTs,\n\t\t}\n\t\tif err := json.NewDecoder(c.Request().Body).Decode(resourcePatch); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, \"Malformatted patch resource request\").SetInternal(err)\n\t\t}\n\n\t\tresourcePatch.ID = resourceID\n\t\tresource, err = s.Store.PatchResource(ctx, resourcePatch)\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to patch resource\").SetInternal(err)\n\t\t}\n\n\t\tc.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)\n\t\tif err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(resource)); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to encode resource response\").SetInternal(err)\n\t\t}\n\t\treturn nil\n\t})\n\n\tg.DELETE(\"/resource/:resourceId\", func(c echo.Context) error {\n\t\tctx := c.Request().Context()\n\t\tuserID, ok := c.Get(getUserIDContextKey()).(int)\n\t\tif !ok {\n\t\t\treturn echo.NewHTTPError(http.StatusUnauthorized, \"Missing user in session\")\n\t\t}\n\n\t\tresourceID, err := strconv.Atoi(c.Param(\"resourceId\"))\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf(\"ID is not a number: %s\", c.Param(\"resourceId\"))).SetInternal(err)\n\t\t}\n\n\t\tresource, err := s.Store.FindResource(ctx, &api.ResourceFind{\n\t\t\tID:        &resourceID,\n\t\t\tCreatorID: &userID,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to find resource\").SetInternal(err)\n\t\t}\n\t\tif resource.CreatorID != userID {\n\t\t\treturn echo.NewHTTPError(http.StatusUnauthorized, \"Unauthorized\")\n\t\t}\n\n\t\tresourceDelete := &api.ResourceDelete{\n\t\t\tID: resourceID,\n\t\t}\n\t\tif err := s.Store.DeleteResource(ctx, resourceDelete); err != nil {\n\t\t\tif common.ErrorCode(err) == common.NotFound {\n\t\t\t\treturn echo.NewHTTPError(http.StatusNotFound, fmt.Sprintf(\"Resource ID not found: %d\", resourceID))\n\t\t\t}\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to delete resource\").SetInternal(err)\n\t\t}\n\n\t\treturn c.JSON(http.StatusOK, true)\n\t})\n}\n\nfunc (s *Server) registerResourcePublicRoutes(g *echo.Group) {\n\tg.GET(\"/r/:resourceId/:filename\", func(c echo.Context) error {\n\t\tctx := c.Request().Context()\n\t\tresourceID, err := strconv.Atoi(c.Param(\"resourceId\"))\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf(\"ID is not a number: %s\", c.Param(\"resourceId\"))).SetInternal(err)\n\t\t}\n\t\tfilename, err := url.QueryUnescape(c.Param(\"filename\"))\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf(\"filename is invalid: %s\", c.Param(\"filename\"))).SetInternal(err)\n\t\t}\n\t\tresourceFind := &api.ResourceFind{\n\t\t\tID:       &resourceID,\n\t\t\tFilename: &filename,\n\t\t\tGetBlob:  true,\n\t\t}\n\t\tresource, err := s.Store.FindResource(ctx, resourceFind)\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, fmt.Sprintf(\"Failed to fetch resource ID: %v\", resourceID)).SetInternal(err)\n\t\t}\n\n\t\tresourceType := strings.ToLower(resource.Type)\n\t\tif strings.HasPrefix(resourceType, \"text\") || (strings.HasPrefix(resourceType, \"application\") && resourceType != \"application/pdf\") {\n\t\t\tresourceType = echo.MIMETextPlain\n\t\t}\n\t\tc.Response().Writer.Header().Set(echo.HeaderCacheControl, \"max-age=31536000, immutable\")\n\t\tc.Response().Writer.Header().Set(echo.HeaderContentSecurityPolicy, \"default-src 'self'\")\n\t\tif strings.HasPrefix(resourceType, \"video\") || strings.HasPrefix(resourceType, \"audio\") {\n\t\t\thttp.ServeContent(c.Response(), c.Request(), resource.Filename, time.Unix(resource.UpdatedTs, 0), bytes.NewReader(resource.Blob))\n\t\t\treturn nil\n\t\t}\n\t\treturn c.Stream(http.StatusOK, resourceType, bytes.NewReader(resource.Blob))\n\t})\n}\n\nfunc (s *Server) createResourceCreateActivity(c echo.Context, resource *api.Resource) error {\n\tctx := c.Request().Context()\n\tpayload := api.ActivityResourceCreatePayload{\n\t\tFilename: resource.Filename,\n\t\tType:     resource.Type,\n\t\tSize:     resource.Size,\n\t}\n\tpayloadStr, err := json.Marshal(payload)\n\tif err != nil {\n\t\treturn errors.Wrap(err, \"failed to marshal activity payload\")\n\t}\n\tactivity, err := s.Store.CreateActivity(ctx, &api.ActivityCreate{\n\t\tCreatorID: resource.CreatorID,\n\t\tType:      api.ActivityResourceCreate,\n\t\tLevel:     api.ActivityInfo,\n\t\tPayload:   string(payloadStr),\n\t})\n\tif err != nil || activity == nil {\n\t\treturn errors.Wrap(err, \"failed to create activity\")\n\t}\n\ts.Collector.Collect(ctx, &metric.Metric{\n\t\tName: string(activity.Type),\n\t})\n\treturn err\n}\n", "import { Button, Input, Select, Option, Typography, List, ListItem, Autocomplete } from \"@mui/joy\";\r\nimport React, { useRef, useState } from \"react\";\r\nimport { useResourceStore } from \"../store/module\";\r\nimport Icon from \"./Icon\";\r\nimport toastHelper from \"./Toast\";\r\nimport { generateDialog } from \"./Dialog\";\r\n\r\nconst fileTypeAutocompleteOptions = [\"image/*\", \"text/*\", \"audio/*\", \"video/*\", \"application/*\"];\r\n\r\ninterface Props extends DialogProps {\r\n  onCancel?: () => void;\r\n  onConfirm?: (resourceList: Resource[]) => void;\r\n}\r\n\r\ntype SelectedMode = \"local-file\" | \"external-link\";\r\n\r\ninterface State {\r\n  selectedMode: SelectedMode;\r\n  uploadingFlag: boolean;\r\n}\r\n\r\nconst CreateResourceDialog: React.FC<Props> = (props: Props) => {\r\n  const { destroy, onCancel, onConfirm } = props;\r\n  const resourceStore = useResourceStore();\r\n  const [state, setState] = useState<State>({\r\n    selectedMode: \"local-file\",\r\n    uploadingFlag: false,\r\n  });\r\n  const [resourceCreate, setResourceCreate] = useState<ResourceCreate>({\r\n    filename: \"\",\r\n    externalLink: \"\",\r\n    type: \"\",\r\n  });\r\n  const [fileList, setFileList] = useState<File[]>([]);\r\n  const fileInputRef = useRef<HTMLInputElement>(null);\r\n\r\n  const handleCloseDialog = () => {\r\n    if (onCancel) {\r\n      onCancel();\r\n    }\r\n    destroy();\r\n  };\r\n\r\n  const handleSelectedModeChanged = (mode: \"local-file\" | \"external-link\") => {\r\n    setState((state) => {\r\n      return {\r\n        ...state,\r\n        selectedMode: mode,\r\n      };\r\n    });\r\n  };\r\n\r\n  const handleExternalLinkChanged = (event: React.ChangeEvent<HTMLInputElement>) => {\r\n    const externalLink = event.target.value;\r\n    setResourceCreate((state) => {\r\n      return {\r\n        ...state,\r\n        externalLink,\r\n      };\r\n    });\r\n  };\r\n\r\n  const handleFileNameChanged = (event: React.ChangeEvent<HTMLInputElement>) => {\r\n    const filename = event.target.value;\r\n    setResourceCreate((state) => {\r\n      return {\r\n        ...state,\r\n        filename,\r\n      };\r\n    });\r\n  };\r\n\r\n  const handleFileTypeChanged = (fileType: string) => {\r\n    setResourceCreate((state) => {\r\n      return {\r\n        ...state,\r\n        type: fileType,\r\n      };\r\n    });\r\n  };\r\n\r\n  const handleFileInputChange = async () => {\r\n    if (!fileInputRef.current || !fileInputRef.current.files) {\r\n      return;\r\n    }\r\n\r\n    const files: File[] = [];\r\n    for (const file of fileInputRef.current.files) {\r\n      files.push(file);\r\n    }\r\n    setFileList(files);\r\n  };\r\n\r\n  const allowConfirmAction = () => {\r\n    if (state.selectedMode === \"local-file\") {\r\n      if (!fileInputRef.current || !fileInputRef.current.files || fileInputRef.current.files.length === 0) {\r\n        return false;\r\n      }\r\n    } else if (state.selectedMode === \"external-link\") {\r\n      if (resourceCreate.filename === \"\" || resourceCreate.externalLink === \"\" || resourceCreate.type === \"\") {\r\n        return false;\r\n      }\r\n    }\r\n    return true;\r\n  };\r\n\r\n  const handleConfirmBtnClick = async () => {\r\n    if (state.uploadingFlag) {\r\n      return;\r\n    }\r\n\r\n    setState((state) => {\r\n      return {\r\n        ...state,\r\n        uploadingFlag: true,\r\n      };\r\n    });\r\n\r\n    const createdResourceList: Resource[] = [];\r\n    try {\r\n      if (state.selectedMode === \"local-file\") {\r\n        if (!fileInputRef.current || !fileInputRef.current.files) {\r\n          return;\r\n        }\r\n        for (const file of fileInputRef.current.files) {\r\n          const resource = await resourceStore.createResourceWithBlob(file);\r\n          createdResourceList.push(resource);\r\n        }\r\n      } else {\r\n        const resource = await resourceStore.createResource(resourceCreate);\r\n        createdResourceList.push(resource);\r\n      }\r\n    } catch (error: any) {\r\n      console.error(error);\r\n      toastHelper.error(error.response.data.message);\r\n    }\r\n\r\n    if (onConfirm) {\r\n      onConfirm(createdResourceList);\r\n    }\r\n    destroy();\r\n  };\r\n\r\n  return (\r\n    <>\r\n      <div className=\"dialog-header-container\">\r\n        <p className=\"title-text\">Create Resource</p>\r\n        <button className=\"btn close-btn\" onClick={handleCloseDialog}>\r\n          <Icon.X />\r\n        </button>\r\n      </div>\r\n      <div className=\"dialog-content-container !w-80\">\r\n        <Typography className=\"!mb-1\" level=\"body2\">\r\n          Upload method\r\n        </Typography>\r\n        <Select\r\n          className=\"w-full mb-2\"\r\n          onChange={(_, value) => handleSelectedModeChanged(value as SelectedMode)}\r\n          value={state.selectedMode}\r\n          startDecorator={<Icon.File className=\"w-4 h-auto\" />}\r\n        >\r\n          <Option value=\"local-file\">Local file</Option>\r\n          <Option value=\"external-link\">External link</Option>\r\n        </Select>\r\n\r\n        {state.selectedMode === \"local-file\" && (\r\n          <>\r\n            <div className=\"w-full relative bg-blue-50 rounded-md flex flex-row justify-center items-center py-8\">\r\n              <label htmlFor=\"files\" className=\"p-2 px-4 text-sm text-white cursor-pointer bg-blue-500 block rounded hover:opacity-80\">\r\n                Choose a file...\r\n              </label>\r\n              <input\r\n                className=\"absolute inset-0 hidden\"\r\n                ref={fileInputRef}\r\n                onChange={handleFileInputChange}\r\n                type=\"file\"\r\n                id=\"files\"\r\n                multiple={true}\r\n                accept=\"*\"\r\n              />\r\n            </div>\r\n            <List size=\"sm\">\r\n              {fileList.map((file) => (\r\n                <ListItem key={file.name}>{file.name}</ListItem>\r\n              ))}\r\n            </List>\r\n          </>\r\n        )}\r\n\r\n        {state.selectedMode === \"external-link\" && (\r\n          <>\r\n            <Typography className=\"!mb-1\" level=\"body2\">\r\n              Link\r\n            </Typography>\r\n            <Input\r\n              className=\"mb-2\"\r\n              placeholder=\"File link\"\r\n              value={resourceCreate.externalLink}\r\n              onChange={handleExternalLinkChanged}\r\n              fullWidth\r\n            />\r\n            <Typography className=\"!mb-1\" level=\"body2\">\r\n              File name\r\n            </Typography>\r\n            <Input className=\"mb-2\" placeholder=\"File name\" value={resourceCreate.filename} onChange={handleFileNameChanged} fullWidth />\r\n            <Typography className=\"!mb-1\" level=\"body2\">\r\n              Type\r\n            </Typography>\r\n            <Autocomplete\r\n              className=\"w-full\"\r\n              size=\"sm\"\r\n              placeholder=\"File type\"\r\n              freeSolo={true}\r\n              options={fileTypeAutocompleteOptions}\r\n              onChange={(_, value) => handleFileTypeChanged(value || \"\")}\r\n            />\r\n          </>\r\n        )}\r\n\r\n        <div className=\"mt-2 w-full flex flex-row justify-end items-center space-x-1\">\r\n          <Button variant=\"plain\" color=\"neutral\" onClick={handleCloseDialog}>\r\n            Cancel\r\n          </Button>\r\n          <Button onClick={handleConfirmBtnClick} loading={state.uploadingFlag} disabled={!allowConfirmAction()}>\r\n            Create\r\n          </Button>\r\n        </div>\r\n      </div>\r\n    </>\r\n  );\r\n};\r\n\r\nfunction showCreateResourceDialog(props: Omit<Props, \"destroy\">) {\r\n  generateDialog<Props>(\r\n    {\r\n      dialogName: \"create-resource-dialog\",\r\n    },\r\n    CreateResourceDialog,\r\n    props\r\n  );\r\n}\r\n\r\nexport default showCreateResourceDialog;\r\n"], "fixing_code": ["package server\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/pkg/errors\"\n\t\"github.com/usememos/memos/api\"\n\t\"github.com/usememos/memos/common\"\n\tmetric \"github.com/usememos/memos/plugin/metrics\"\n\n\t\"github.com/labstack/echo/v4\"\n)\n\nconst (\n\t// The max file size is 32MB.\n\tmaxFileSize = 32 << 20\n)\n\nfunc (s *Server) registerResourceRoutes(g *echo.Group) {\n\tg.POST(\"/resource\", func(c echo.Context) error {\n\t\tctx := c.Request().Context()\n\t\tuserID, ok := c.Get(getUserIDContextKey()).(int)\n\t\tif !ok {\n\t\t\treturn echo.NewHTTPError(http.StatusUnauthorized, \"Missing user in session\")\n\t\t}\n\n\t\tresourceCreate := &api.ResourceCreate{}\n\t\tif err := json.NewDecoder(c.Request().Body).Decode(resourceCreate); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, \"Malformatted post resource request\").SetInternal(err)\n\t\t}\n\n\t\tresourceCreate.CreatorID = userID\n\t\t// Only allow those external links with http prefix.\n\t\tif resourceCreate.ExternalLink != \"\" && !strings.HasPrefix(resourceCreate.ExternalLink, \"http\") {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, \"Invalid external link\")\n\t\t}\n\t\tresource, err := s.Store.CreateResource(ctx, resourceCreate)\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to create resource\").SetInternal(err)\n\t\t}\n\t\tif err := s.createResourceCreateActivity(c, resource); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to create activity\").SetInternal(err)\n\t\t}\n\n\t\tc.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)\n\t\tif err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(resource)); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to encode resource response\").SetInternal(err)\n\t\t}\n\t\treturn nil\n\t})\n\n\tg.POST(\"/resource/blob\", func(c echo.Context) error {\n\t\tctx := c.Request().Context()\n\t\tuserID, ok := c.Get(getUserIDContextKey()).(int)\n\t\tif !ok {\n\t\t\treturn echo.NewHTTPError(http.StatusUnauthorized, \"Missing user in session\")\n\t\t}\n\n\t\tif err := c.Request().ParseMultipartForm(maxFileSize); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, \"Upload file overload max size\").SetInternal(err)\n\t\t}\n\n\t\tfile, err := c.FormFile(\"file\")\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to get uploading file\").SetInternal(err)\n\t\t}\n\t\tif file == nil {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, \"Upload file not found\").SetInternal(err)\n\t\t}\n\n\t\tfilename := file.Filename\n\t\tfiletype := file.Header.Get(\"Content-Type\")\n\t\tsize := file.Size\n\t\tsrc, err := file.Open()\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to open file\").SetInternal(err)\n\t\t}\n\t\tdefer src.Close()\n\n\t\tfileBytes, err := io.ReadAll(src)\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to read file\").SetInternal(err)\n\t\t}\n\n\t\tresourceCreate := &api.ResourceCreate{\n\t\t\tCreatorID: userID,\n\t\t\tFilename:  filename,\n\t\t\tType:      filetype,\n\t\t\tSize:      size,\n\t\t\tBlob:      fileBytes,\n\t\t}\n\t\tresource, err := s.Store.CreateResource(ctx, resourceCreate)\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to create resource\").SetInternal(err)\n\t\t}\n\t\tif err := s.createResourceCreateActivity(c, resource); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to create activity\").SetInternal(err)\n\t\t}\n\n\t\tc.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)\n\t\tif err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(resource)); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to encode resource response\").SetInternal(err)\n\t\t}\n\t\treturn nil\n\t})\n\n\tg.GET(\"/resource\", func(c echo.Context) error {\n\t\tctx := c.Request().Context()\n\t\tuserID, ok := c.Get(getUserIDContextKey()).(int)\n\t\tif !ok {\n\t\t\treturn echo.NewHTTPError(http.StatusUnauthorized, \"Missing user in session\")\n\t\t}\n\t\tresourceFind := &api.ResourceFind{\n\t\t\tCreatorID: &userID,\n\t\t}\n\t\tlist, err := s.Store.FindResourceList(ctx, resourceFind)\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to fetch resource list\").SetInternal(err)\n\t\t}\n\n\t\tfor _, resource := range list {\n\t\t\tmemoResourceList, err := s.Store.FindMemoResourceList(ctx, &api.MemoResourceFind{\n\t\t\t\tResourceID: &resource.ID,\n\t\t\t})\n\t\t\tif err != nil {\n\t\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to find memo resource list\").SetInternal(err)\n\t\t\t}\n\t\t\tresource.LinkedMemoAmount = len(memoResourceList)\n\t\t}\n\n\t\tc.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)\n\t\tif err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(list)); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to encode resource list response\").SetInternal(err)\n\t\t}\n\t\treturn nil\n\t})\n\n\tg.GET(\"/resource/:resourceId\", func(c echo.Context) error {\n\t\tctx := c.Request().Context()\n\t\tresourceID, err := strconv.Atoi(c.Param(\"resourceId\"))\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf(\"ID is not a number: %s\", c.Param(\"resourceId\"))).SetInternal(err)\n\t\t}\n\n\t\tuserID, ok := c.Get(getUserIDContextKey()).(int)\n\t\tif !ok {\n\t\t\treturn echo.NewHTTPError(http.StatusUnauthorized, \"Missing user in session\")\n\t\t}\n\t\tresourceFind := &api.ResourceFind{\n\t\t\tID:        &resourceID,\n\t\t\tCreatorID: &userID,\n\t\t\tGetBlob:   true,\n\t\t}\n\t\tresource, err := s.Store.FindResource(ctx, resourceFind)\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to fetch resource\").SetInternal(err)\n\t\t}\n\n\t\tc.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)\n\t\tif err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(resource)); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to encode resource response\").SetInternal(err)\n\t\t}\n\t\treturn nil\n\t})\n\n\tg.GET(\"/resource/:resourceId/blob\", func(c echo.Context) error {\n\t\tctx := c.Request().Context()\n\t\tresourceID, err := strconv.Atoi(c.Param(\"resourceId\"))\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf(\"ID is not a number: %s\", c.Param(\"resourceId\"))).SetInternal(err)\n\t\t}\n\n\t\tuserID, ok := c.Get(getUserIDContextKey()).(int)\n\t\tif !ok {\n\t\t\treturn echo.NewHTTPError(http.StatusUnauthorized, \"Missing user in session\")\n\t\t}\n\t\tresourceFind := &api.ResourceFind{\n\t\t\tID:        &resourceID,\n\t\t\tCreatorID: &userID,\n\t\t\tGetBlob:   true,\n\t\t}\n\t\tresource, err := s.Store.FindResource(ctx, resourceFind)\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to fetch resource\").SetInternal(err)\n\t\t}\n\n\t\treturn c.Stream(http.StatusOK, resource.Type, bytes.NewReader(resource.Blob))\n\t})\n\n\tg.PATCH(\"/resource/:resourceId\", func(c echo.Context) error {\n\t\tctx := c.Request().Context()\n\t\tuserID, ok := c.Get(getUserIDContextKey()).(int)\n\t\tif !ok {\n\t\t\treturn echo.NewHTTPError(http.StatusUnauthorized, \"Missing user in session\")\n\t\t}\n\n\t\tresourceID, err := strconv.Atoi(c.Param(\"resourceId\"))\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf(\"ID is not a number: %s\", c.Param(\"resourceId\"))).SetInternal(err)\n\t\t}\n\n\t\tresourceFind := &api.ResourceFind{\n\t\t\tID: &resourceID,\n\t\t}\n\t\tresource, err := s.Store.FindResource(ctx, resourceFind)\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to find resource\").SetInternal(err)\n\t\t}\n\t\tif resource.CreatorID != userID {\n\t\t\treturn echo.NewHTTPError(http.StatusUnauthorized, \"Unauthorized\")\n\t\t}\n\n\t\tcurrentTs := time.Now().Unix()\n\t\tresourcePatch := &api.ResourcePatch{\n\t\t\tUpdatedTs: &currentTs,\n\t\t}\n\t\tif err := json.NewDecoder(c.Request().Body).Decode(resourcePatch); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, \"Malformatted patch resource request\").SetInternal(err)\n\t\t}\n\n\t\tresourcePatch.ID = resourceID\n\t\tresource, err = s.Store.PatchResource(ctx, resourcePatch)\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to patch resource\").SetInternal(err)\n\t\t}\n\n\t\tc.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)\n\t\tif err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(resource)); err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to encode resource response\").SetInternal(err)\n\t\t}\n\t\treturn nil\n\t})\n\n\tg.DELETE(\"/resource/:resourceId\", func(c echo.Context) error {\n\t\tctx := c.Request().Context()\n\t\tuserID, ok := c.Get(getUserIDContextKey()).(int)\n\t\tif !ok {\n\t\t\treturn echo.NewHTTPError(http.StatusUnauthorized, \"Missing user in session\")\n\t\t}\n\n\t\tresourceID, err := strconv.Atoi(c.Param(\"resourceId\"))\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf(\"ID is not a number: %s\", c.Param(\"resourceId\"))).SetInternal(err)\n\t\t}\n\n\t\tresource, err := s.Store.FindResource(ctx, &api.ResourceFind{\n\t\t\tID:        &resourceID,\n\t\t\tCreatorID: &userID,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to find resource\").SetInternal(err)\n\t\t}\n\t\tif resource.CreatorID != userID {\n\t\t\treturn echo.NewHTTPError(http.StatusUnauthorized, \"Unauthorized\")\n\t\t}\n\n\t\tresourceDelete := &api.ResourceDelete{\n\t\t\tID: resourceID,\n\t\t}\n\t\tif err := s.Store.DeleteResource(ctx, resourceDelete); err != nil {\n\t\t\tif common.ErrorCode(err) == common.NotFound {\n\t\t\t\treturn echo.NewHTTPError(http.StatusNotFound, fmt.Sprintf(\"Resource ID not found: %d\", resourceID))\n\t\t\t}\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to delete resource\").SetInternal(err)\n\t\t}\n\n\t\treturn c.JSON(http.StatusOK, true)\n\t})\n}\n\nfunc (s *Server) registerResourcePublicRoutes(g *echo.Group) {\n\tg.GET(\"/r/:resourceId/:filename\", func(c echo.Context) error {\n\t\tctx := c.Request().Context()\n\t\tresourceID, err := strconv.Atoi(c.Param(\"resourceId\"))\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf(\"ID is not a number: %s\", c.Param(\"resourceId\"))).SetInternal(err)\n\t\t}\n\t\tfilename, err := url.QueryUnescape(c.Param(\"filename\"))\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf(\"filename is invalid: %s\", c.Param(\"filename\"))).SetInternal(err)\n\t\t}\n\t\tresourceFind := &api.ResourceFind{\n\t\t\tID:       &resourceID,\n\t\t\tFilename: &filename,\n\t\t\tGetBlob:  true,\n\t\t}\n\t\tresource, err := s.Store.FindResource(ctx, resourceFind)\n\t\tif err != nil {\n\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, fmt.Sprintf(\"Failed to find resource by ID: %v\", resourceID)).SetInternal(err)\n\t\t}\n\n\t\tc.Response().Writer.Header().Set(echo.HeaderCacheControl, \"max-age=31536000, immutable\")\n\t\tc.Response().Writer.Header().Set(echo.HeaderContentSecurityPolicy, \"default-src 'self'\")\n\t\tresourceType := strings.ToLower(resource.Type)\n\t\tif strings.HasPrefix(resourceType, \"text\") {\n\t\t\tresourceType = echo.MIMETextPlainCharsetUTF8\n\t\t} else if strings.HasPrefix(resourceType, \"video\") || strings.HasPrefix(resourceType, \"audio\") {\n\t\t\thttp.ServeContent(c.Response(), c.Request(), resource.Filename, time.Unix(resource.UpdatedTs, 0), bytes.NewReader(resource.Blob))\n\t\t\treturn nil\n\t\t}\n\t\treturn c.Stream(http.StatusOK, resourceType, bytes.NewReader(resource.Blob))\n\t})\n}\n\nfunc (s *Server) createResourceCreateActivity(c echo.Context, resource *api.Resource) error {\n\tctx := c.Request().Context()\n\tpayload := api.ActivityResourceCreatePayload{\n\t\tFilename: resource.Filename,\n\t\tType:     resource.Type,\n\t\tSize:     resource.Size,\n\t}\n\tpayloadStr, err := json.Marshal(payload)\n\tif err != nil {\n\t\treturn errors.Wrap(err, \"failed to marshal activity payload\")\n\t}\n\tactivity, err := s.Store.CreateActivity(ctx, &api.ActivityCreate{\n\t\tCreatorID: resource.CreatorID,\n\t\tType:      api.ActivityResourceCreate,\n\t\tLevel:     api.ActivityInfo,\n\t\tPayload:   string(payloadStr),\n\t})\n\tif err != nil || activity == nil {\n\t\treturn errors.Wrap(err, \"failed to create activity\")\n\t}\n\ts.Collector.Collect(ctx, &metric.Metric{\n\t\tName: string(activity.Type),\n\t})\n\treturn err\n}\n", "import { Button, Input, Select, Option, Typography, List, ListItem, Autocomplete } from \"@mui/joy\";\r\nimport React, { useRef, useState } from \"react\";\r\nimport { useResourceStore } from \"../store/module\";\r\nimport Icon from \"./Icon\";\r\nimport toastHelper from \"./Toast\";\r\nimport { generateDialog } from \"./Dialog\";\r\n\r\nconst fileTypeAutocompleteOptions = [\"image/*\", \"text/*\", \"audio/*\", \"video/*\", \"application/*\"];\r\n\r\ninterface Props extends DialogProps {\r\n  onCancel?: () => void;\r\n  onConfirm?: (resourceList: Resource[]) => void;\r\n}\r\n\r\ntype SelectedMode = \"local-file\" | \"external-link\";\r\n\r\ninterface State {\r\n  selectedMode: SelectedMode;\r\n  uploadingFlag: boolean;\r\n}\r\n\r\nconst CreateResourceDialog: React.FC<Props> = (props: Props) => {\r\n  const { destroy, onCancel, onConfirm } = props;\r\n  const resourceStore = useResourceStore();\r\n  const [state, setState] = useState<State>({\r\n    selectedMode: \"local-file\",\r\n    uploadingFlag: false,\r\n  });\r\n  const [resourceCreate, setResourceCreate] = useState<ResourceCreate>({\r\n    filename: \"\",\r\n    externalLink: \"\",\r\n    type: \"\",\r\n  });\r\n  const [fileList, setFileList] = useState<File[]>([]);\r\n  const fileInputRef = useRef<HTMLInputElement>(null);\r\n\r\n  const handleCloseDialog = () => {\r\n    if (onCancel) {\r\n      onCancel();\r\n    }\r\n    destroy();\r\n  };\r\n\r\n  const handleSelectedModeChanged = (mode: \"local-file\" | \"external-link\") => {\r\n    setState((state) => {\r\n      return {\r\n        ...state,\r\n        selectedMode: mode,\r\n      };\r\n    });\r\n  };\r\n\r\n  const handleExternalLinkChanged = (event: React.ChangeEvent<HTMLInputElement>) => {\r\n    const externalLink = event.target.value;\r\n    setResourceCreate((state) => {\r\n      return {\r\n        ...state,\r\n        externalLink,\r\n      };\r\n    });\r\n  };\r\n\r\n  const handleFileNameChanged = (event: React.ChangeEvent<HTMLInputElement>) => {\r\n    const filename = event.target.value;\r\n    setResourceCreate((state) => {\r\n      return {\r\n        ...state,\r\n        filename,\r\n      };\r\n    });\r\n  };\r\n\r\n  const handleFileTypeChanged = (fileType: string) => {\r\n    setResourceCreate((state) => {\r\n      return {\r\n        ...state,\r\n        type: fileType,\r\n      };\r\n    });\r\n  };\r\n\r\n  const handleFileInputChange = async () => {\r\n    if (!fileInputRef.current || !fileInputRef.current.files) {\r\n      return;\r\n    }\r\n\r\n    const files: File[] = [];\r\n    for (const file of fileInputRef.current.files) {\r\n      files.push(file);\r\n    }\r\n    setFileList(files);\r\n  };\r\n\r\n  const allowConfirmAction = () => {\r\n    if (state.selectedMode === \"local-file\") {\r\n      if (!fileInputRef.current || !fileInputRef.current.files || fileInputRef.current.files.length === 0) {\r\n        return false;\r\n      }\r\n    } else if (state.selectedMode === \"external-link\") {\r\n      if (resourceCreate.filename === \"\" || resourceCreate.externalLink === \"\" || resourceCreate.type === \"\") {\r\n        return false;\r\n      }\r\n    }\r\n    return true;\r\n  };\r\n\r\n  const handleConfirmBtnClick = async () => {\r\n    if (state.uploadingFlag) {\r\n      return;\r\n    }\r\n\r\n    setState((state) => {\r\n      return {\r\n        ...state,\r\n        uploadingFlag: true,\r\n      };\r\n    });\r\n\r\n    const createdResourceList: Resource[] = [];\r\n    try {\r\n      if (state.selectedMode === \"local-file\") {\r\n        if (!fileInputRef.current || !fileInputRef.current.files) {\r\n          return;\r\n        }\r\n        for (const file of fileInputRef.current.files) {\r\n          const resource = await resourceStore.createResourceWithBlob(file);\r\n          createdResourceList.push(resource);\r\n        }\r\n      } else {\r\n        const resource = await resourceStore.createResource(resourceCreate);\r\n        createdResourceList.push(resource);\r\n      }\r\n    } catch (error: any) {\r\n      console.error(error);\r\n      toastHelper.error(error.response.data.message);\r\n    }\r\n\r\n    if (onConfirm) {\r\n      onConfirm(createdResourceList);\r\n    }\r\n    destroy();\r\n  };\r\n\r\n  return (\r\n    <>\r\n      <div className=\"dialog-header-container\">\r\n        <p className=\"title-text\">Create Resource</p>\r\n        <button className=\"btn close-btn\" onClick={handleCloseDialog}>\r\n          <Icon.X />\r\n        </button>\r\n      </div>\r\n      <div className=\"dialog-content-container !w-80\">\r\n        <Typography className=\"!mb-1\" level=\"body2\">\r\n          Upload method\r\n        </Typography>\r\n        <Select\r\n          className=\"w-full mb-2\"\r\n          onChange={(_, value) => handleSelectedModeChanged(value as SelectedMode)}\r\n          value={state.selectedMode}\r\n          startDecorator={<Icon.File className=\"w-4 h-auto\" />}\r\n        >\r\n          <Option value=\"local-file\">Local file</Option>\r\n          <Option value=\"external-link\">External link</Option>\r\n        </Select>\r\n\r\n        {state.selectedMode === \"local-file\" && (\r\n          <>\r\n            <div className=\"w-full relative bg-blue-50 rounded-md flex flex-row justify-center items-center py-8\">\r\n              <label htmlFor=\"files\" className=\"p-2 px-4 text-sm text-white cursor-pointer bg-blue-500 block rounded hover:opacity-80\">\r\n                Choose a file...\r\n              </label>\r\n              <input\r\n                className=\"absolute inset-0 hidden\"\r\n                ref={fileInputRef}\r\n                onChange={handleFileInputChange}\r\n                type=\"file\"\r\n                id=\"files\"\r\n                multiple={true}\r\n                accept=\"*\"\r\n              />\r\n            </div>\r\n            <List size=\"sm\">\r\n              {fileList.map((file) => (\r\n                <ListItem key={file.name}>{file.name}</ListItem>\r\n              ))}\r\n            </List>\r\n          </>\r\n        )}\r\n\r\n        {state.selectedMode === \"external-link\" && (\r\n          <>\r\n            <Typography className=\"!mb-1\" level=\"body2\">\r\n              Link\r\n            </Typography>\r\n            <Input\r\n              className=\"mb-2\"\r\n              placeholder=\"https://the.link.to/your/resource\"\r\n              value={resourceCreate.externalLink}\r\n              onChange={handleExternalLinkChanged}\r\n              fullWidth\r\n            />\r\n            <Typography className=\"!mb-1\" level=\"body2\">\r\n              File name\r\n            </Typography>\r\n            <Input className=\"mb-2\" placeholder=\"File name\" value={resourceCreate.filename} onChange={handleFileNameChanged} fullWidth />\r\n            <Typography className=\"!mb-1\" level=\"body2\">\r\n              Type\r\n            </Typography>\r\n            <Autocomplete\r\n              className=\"w-full\"\r\n              size=\"sm\"\r\n              placeholder=\"File type\"\r\n              freeSolo={true}\r\n              options={fileTypeAutocompleteOptions}\r\n              onChange={(_, value) => handleFileTypeChanged(value || \"\")}\r\n            />\r\n          </>\r\n        )}\r\n\r\n        <div className=\"mt-2 w-full flex flex-row justify-end items-center space-x-1\">\r\n          <Button variant=\"plain\" color=\"neutral\" onClick={handleCloseDialog}>\r\n            Cancel\r\n          </Button>\r\n          <Button onClick={handleConfirmBtnClick} loading={state.uploadingFlag} disabled={!allowConfirmAction()}>\r\n            Create\r\n          </Button>\r\n        </div>\r\n      </div>\r\n    </>\r\n  );\r\n};\r\n\r\nfunction showCreateResourceDialog(props: Omit<Props, \"destroy\">) {\r\n  generateDialog<Props>(\r\n    {\r\n      dialogName: \"create-resource-dialog\",\r\n    },\r\n    CreateResourceDialog,\r\n    props\r\n  );\r\n}\r\n\r\nexport default showCreateResourceDialog;\r\n"], "filenames": ["server/resource.go", "web/src/components/CreateResourceDialog.tsx"], "buggy_code_start_loc": [40, 197], "buggy_code_end_loc": [309, 198], "fixing_code_start_loc": [41, 197], "fixing_code_end_loc": [306, 198], "type": "CWE-79", "message": "All versions of the package github.com/usememos/memos/server are vulnerable to Cross-site Scripting (XSS) due to insufficient checks on external resources, which allows malicious actors to introduce links starting with a javascript: scheme.", "other": {"cve": {"id": "CVE-2022-25978", "sourceIdentifier": "report@snyk.io", "published": "2023-02-15T05:15:11.540", "lastModified": "2023-02-23T21:44:34.277", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "All versions of the package github.com/usememos/memos/server are vulnerable to Cross-site Scripting (XSS) due to insufficient checks on external resources, which allows malicious actors to introduce links starting with a javascript: scheme."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}, {"source": "report@snyk.io", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.5}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:usememos:memos:*:*:*:*:*:*:*:*", "matchCriteriaId": "22F12AF0-BE09-45E5-B310-D7D4DD5DD4DD"}]}]}], "references": [{"url": "https://github.com/usememos/memos/commit/b11d2130a084385eb65c3761a3c841ebe9f81ae8", "source": "report@snyk.io", "tags": ["Patch"]}, {"url": "https://github.com/usememos/memos/issues/1026", "source": "report@snyk.io", "tags": ["Exploit"]}, {"url": "https://security.snyk.io/vuln/SNYK-GOLANG-GITHUBCOMUSEMEMOSMEMOSSERVER-3319070", "source": "report@snyk.io", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/usememos/memos/commit/b11d2130a084385eb65c3761a3c841ebe9f81ae8"}}