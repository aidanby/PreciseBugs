{"buggy_code": ["<?php\n/**\n * Class Hotlinking_Controller\n *\n * @link      https://github.com/googleforcreators/web-stories-wp\n *\n * @copyright 2021 Google LLC\n * @license   https://www.apache.org/licenses/LICENSE-2.0 Apache License 2.0\n */\n\n/**\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nnamespace Google\\Web_Stories\\REST_API;\n\nuse Google\\Web_Stories\\Infrastructure\\HasRequirements;\nuse Google\\Web_Stories\\Media\\Types;\nuse Google\\Web_Stories\\Story_Post_Type;\nuse WP_Error;\nuse WP_Http;\nuse WP_REST_Request;\nuse WP_REST_Response;\nuse WP_REST_Server;\n\n/**\n * Hotlinking_Controller class.\n *\n * API endpoint for pinging and hotlinking media URLs.\n *\n * @SuppressWarnings(PHPMD.ExcessiveClassComplexity)\n *\n * @phpstan-type LinkData array{\n *   ext?: string,\n *   file_name?: string,\n *   file_size?: int,\n *   mime_type?: string,\n *   type?: string\n * }\n *\n * @phpstan-type SchemaEntry array{\n *   description: string,\n *   type: string,\n *   context: string[],\n *   default?: mixed,\n * }\n *\n * @phpstan-type Schema array{\n *   properties: array{\n *     ext?: SchemaEntry,\n *     file_name?: SchemaEntry,\n *     file_size?: SchemaEntry,\n *     mime_type?: SchemaEntry,\n *     type?: SchemaEntry\n *   }\n * }\n * @phpstan-type URLParts array{\n *   scheme?: string,\n *   user?: string,\n *   pass?: string,\n *   host?: string,\n *   port?: int,\n *   path?: string,\n *   query?: string\n * }\n */\nclass Hotlinking_Controller extends REST_Controller implements HasRequirements {\n\tpublic const PROXY_HEADERS_ALLOWLIST = [\n\t\t'Content-Type',\n\t\t'Cache-Control',\n\t\t'Etag',\n\t\t'Last-Modified',\n\t\t'Content-Range',\n\t];\n\n\t/**\n\t * Story_Post_Type instance.\n\t *\n\t * @var Story_Post_Type Story_Post_Type instance.\n\t */\n\tprivate $story_post_type;\n\n\t/**\n\t * Types instance.\n\t *\n\t * @var Types Types instance.\n\t */\n\tprivate $types;\n\n\t/**\n\t * File pointer resource.\n\t *\n\t * @var resource\n\t */\n\tprotected $stream_handle;\n\n\t/**\n\t * Constructor.\n\t *\n\t * @param Story_Post_Type $story_post_type Story_Post_Type instance.\n\t * @param Types           $types Types instance.\n\t * @return void\n\t */\n\tpublic function __construct( Story_Post_Type $story_post_type, Types $types ) {\n\t\t$this->story_post_type = $story_post_type;\n\t\t$this->types           = $types;\n\n\t\t$this->namespace = 'web-stories/v1';\n\t\t$this->rest_base = 'hotlink';\n\t}\n\n\t/**\n\t * Get the list of service IDs required for this service to be registered.\n\t *\n\t * Needed because the story post type needs to be registered first.\n\t *\n\t * @since 1.13.0\n\t *\n\t * @return string[] List of required services.\n\t */\n\tpublic static function get_requirements(): array {\n\t\treturn [ 'story_post_type' ];\n\t}\n\n\t/**\n\t * Registers routes for urls.\n\t *\n\t * @since 1.11.0\n\t *\n\t * @see register_rest_route()\n\t */\n\tpublic function register_routes(): void {\n\t\tregister_rest_route(\n\t\t\t$this->namespace,\n\t\t\t'/' . $this->rest_base . '/validate',\n\t\t\t[\n\t\t\t\t[\n\t\t\t\t\t'methods'             => WP_REST_Server::READABLE,\n\t\t\t\t\t'callback'            => [ $this, 'parse_url' ],\n\t\t\t\t\t'permission_callback' => [ $this, 'parse_url_permissions_check' ],\n\t\t\t\t\t'args'                => [\n\t\t\t\t\t\t'url' => [\n\t\t\t\t\t\t\t'description'       => __( 'The URL to process.', 'web-stories' ),\n\t\t\t\t\t\t\t'required'          => true,\n\t\t\t\t\t\t\t'type'              => 'string',\n\t\t\t\t\t\t\t'format'            => 'uri',\n\t\t\t\t\t\t\t'validate_callback' => [ $this, 'validate_callback' ],\n\t\t\t\t\t\t\t'sanitize_callback' => 'esc_url_raw',\n\t\t\t\t\t\t],\n\t\t\t\t\t],\n\t\t\t\t],\n\t\t\t]\n\t\t);\n\n\t\tregister_rest_route(\n\t\t\t$this->namespace,\n\t\t\t'/' . $this->rest_base . '/proxy',\n\t\t\t[\n\t\t\t\t[\n\t\t\t\t\t'methods'             => WP_REST_Server::READABLE,\n\t\t\t\t\t'callback'            => [ $this, 'proxy_url' ],\n\t\t\t\t\t'permission_callback' => [ $this, 'parse_url_permissions_check' ],\n\t\t\t\t\t'args'                => [\n\t\t\t\t\t\t'url' => [\n\t\t\t\t\t\t\t'description'       => __( 'The URL to process.', 'web-stories' ),\n\t\t\t\t\t\t\t'required'          => true,\n\t\t\t\t\t\t\t'type'              => 'string',\n\t\t\t\t\t\t\t'format'            => 'uri',\n\t\t\t\t\t\t\t'validate_callback' => [ $this, 'validate_callback' ],\n\t\t\t\t\t\t\t'sanitize_callback' => 'esc_url_raw',\n\t\t\t\t\t\t],\n\t\t\t\t\t],\n\t\t\t\t],\n\t\t\t]\n\t\t);\n\t}\n\n\t/**\n\t * Parses a URL to return some metadata for inserting external media.\n\t *\n\t * @SuppressWarnings(PHPMD.NPathComplexity)\n\t * @SuppressWarnings(PHPMD.ExcessiveMethodLength)\n\t *\n\t * @since 1.11.0\n\t *\n\t * @param WP_REST_Request $request Full data about the request.\n\t * @return WP_REST_Response|WP_Error Response object on success, or WP_Error object on failure.\n\t */\n\tpublic function parse_url( WP_REST_Request $request ) {\n\t\t/**\n\t\t * Requested URL.\n\t\t *\n\t\t * @var string $raw_url\n\t\t */\n\t\t$raw_url = $request['url'];\n\t\t$raw_url = untrailingslashit( $raw_url );\n\n\t\t$url_or_ip = $this->validate_url( $raw_url );\n\n\t\t$host = wp_parse_url( $raw_url, PHP_URL_HOST );\n\n\t\tif ( ! $url_or_ip || ! $host ) {\n\t\t\treturn new WP_Error( 'rest_invalid_url', __( 'Invalid URL', 'web-stories' ), [ 'status' => 400 ] );\n\t\t}\n\n\t\t/**\n\t\t * Filters the hotlinking data TTL value.\n\t\t *\n\t\t * @since 1.11.0\n\t\t *\n\t\t * @param int    $time Time to live (in seconds). Default is 1 day.\n\t\t * @param string $url  The attempted URL.\n\t\t */\n\t\t$cache_ttl = apply_filters( 'web_stories_hotlinking_url_data_cache_ttl', DAY_IN_SECONDS, $raw_url );\n\t\t$cache_key = 'web_stories_url_data_' . md5( $raw_url );\n\n\t\t$data = get_transient( $cache_key );\n\t\tif ( \\is_string( $data ) && ! empty( $data ) ) {\n\t\t\t/**\n\t\t\t * Decoded cached link data.\n\t\t\t *\n\t\t\t * @var array|null $link\n\t\t\t * @phpstan-var LinkData|null $link\n\t\t\t */\n\t\t\t$link = json_decode( $data, true );\n\n\t\t\tif ( $link ) {\n\t\t\t\t$response = $this->prepare_item_for_response( $link, $request );\n\t\t\t\treturn rest_ensure_response( $response );\n\t\t\t}\n\t\t}\n\n\t\t$callback = $this->get_curl_resolve_callback( $raw_url, $url_or_ip );\n\t\tadd_action( 'http_api_curl', $callback );\n\n\t\t$response = wp_safe_remote_head(\n\t\t\t$raw_url,\n\t\t\t[\n\t\t\t\t'redirection' => 0, // No redirects allowed.\n\t\t\t\t'headers'     => [\n\t\t\t\t\t'Host' => $host,\n\t\t\t\t],\n\t\t\t]\n\t\t);\n\n\t\tremove_action( 'http_api_curl', $callback );\n\n\t\tif ( is_wp_error( $response ) && 'http_request_failed' === $response->get_error_code() ) {\n\t\t\treturn new WP_Error( 'rest_invalid_url', __( 'Invalid URL', 'web-stories' ), [ 'status' => 404 ] );\n\t\t}\n\n\t\tif ( WP_Http::OK !== wp_remote_retrieve_response_code( $response ) ) {\n\t\t\treturn new WP_Error( 'rest_invalid_url', __( 'Invalid URL', 'web-stories' ), [ 'status' => 404 ] );\n\t\t}\n\n\t\t$headers   = wp_remote_retrieve_headers( $response );\n\t\t$mime_type = $headers['content-type'];\n\t\tif ( $mime_type && false !== strpos( $mime_type, ';' ) ) {\n\t\t\t$pieces    = explode( ';', $mime_type );\n\t\t\t$mime_type = array_shift( $pieces );\n\t\t}\n\t\t$file_size = (int) $headers['content-length'];\n\n\t\t$path = wp_parse_url( $raw_url, PHP_URL_PATH );\n\n\t\tif ( ! \\is_string( $path ) ) {\n\t\t\treturn new WP_Error( 'rest_invalid_url', __( 'Invalid URL', 'web-stories' ), [ 'status' => 404 ] );\n\t\t}\n\n\t\t$file_name = basename( $path );\n\n\t\t$exts = $this->types->get_file_type_exts( [ $mime_type ] );\n\t\t$ext  = '';\n\t\tif ( $exts ) {\n\t\t\t$ext = end( $exts );\n\t\t}\n\n\t\t$allowed_mime_types = $this->get_allowed_mime_types();\n\t\t$type               = '';\n\t\tforeach ( $allowed_mime_types as $key => $mime_types ) {\n\t\t\tif ( \\in_array( $mime_type, $mime_types, true ) ) {\n\t\t\t\t$type = $key;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t$data = [\n\t\t\t'ext'       => $ext,\n\t\t\t'file_name' => $file_name,\n\t\t\t'file_size' => $file_size,\n\t\t\t'mime_type' => $mime_type,\n\t\t\t'type'      => $type,\n\t\t];\n\n\t\tset_transient( $cache_key, wp_json_encode( $data ), $cache_ttl );\n\n\t\t$response = $this->prepare_item_for_response( $data, $request );\n\n\t\treturn rest_ensure_response( $response );\n\t}\n\n\t/**\n\t * Parses a URL to return proxied file.\n\t *\n\t * @SuppressWarnings(PHPMD.ErrorControlOperator)\n\t *\n\t * @since 1.13.0\n\t *\n\t * @param WP_REST_Request $request Full data about the request.\n\t * @return WP_Error|void Proxied data on success, error otherwise.\n\t */\n\tpublic function proxy_url( WP_REST_Request $request ) {\n\t\t/**\n\t\t * Requested URL.\n\t\t *\n\t\t * @var string $raw_url\n\t\t */\n\t\t$raw_url = $request['url'];\n\t\t$raw_url = untrailingslashit( $raw_url );\n\n\t\t$url_or_ip = $this->validate_url( $raw_url );\n\n\t\t$host = wp_parse_url( $raw_url, PHP_URL_HOST );\n\n\t\tif ( ! $url_or_ip || ! $host ) {\n\t\t\treturn new WP_Error( 'rest_invalid_url', __( 'Invalid URL', 'web-stories' ), [ 'status' => 400 ] );\n\t\t}\n\n\t\t// Remove any relevant headers already set by WP_REST_Server::serve_request() // wp_get_nocache_headers().\n\t\tif ( ! headers_sent() ) {\n\t\t\theader_remove( 'Cache-Control' );\n\t\t\theader_remove( 'Content-Type' );\n\t\t\theader_remove( 'Expires' );\n\t\t\theader_remove( 'Last Modified' );\n\t\t}\n\n\t\theader( 'Cache-Control: max-age=3600' );\n\t\theader( 'Accept-Ranges: bytes' );\n\n\t\t$args = [\n\t\t\t'timeout'     => 60, // phpcs:ignore WordPressVIPMinimum.Performance.RemoteRequestTimeout.timeout_timeout\n\t\t\t'blocking'    => false,\n\t\t\t'headers'     => [\n\t\t\t\t'Range' => $request->get_header( 'Range' ),\n\t\t\t\t'Host'  => $host,\n\t\t\t],\n\t\t\t'redirection' => 0, // No redirects allowed.\n\t\t];\n\n\t\t$callback = $this->get_curl_resolve_callback( $raw_url, $url_or_ip );\n\t\tadd_action( 'http_api_curl', $callback );\n\n\t\t$http      = _wp_http_get_object();\n\t\t$transport = $http->_get_first_available_transport( $args, $raw_url );\n\n\t\t// When cURL is available, we might be able to use it together with fopen().\n\t\tif ( 'WP_Http_Curl' === $transport ) {\n\t\t\t// php://temp is a read-write streams that allows temporary data to be stored in a file-like wrapper.\n\t\t\t// Other than php://memory, php://temp will use a temporary file once the amount of data stored hits a predefined limit (the default is 2 MB).\n\t\t\t// The location of this temporary file is determined in the same way as the {@see sys_get_temp_dir()} function.\n\t\t\tif ( WP_DEBUG ) {\n\t\t\t\t$stream_handle = fopen( 'php://memory', 'wb' ); // phpcs:ignore WordPress.WP.AlternativeFunctions.file_system_read_fopen\n\t\t\t} else {\n\t\t\t\t$stream_handle = @fopen( 'php://memory', 'wb' ); // phpcs:ignore WordPress.WP.AlternativeFunctions.file_system_read_fopen, WordPress.PHP.NoSilencedErrors.Discouraged, Generic.PHP.NoSilencedErrors.Forbidden\n\t\t\t}\n\n\t\t\tif ( $stream_handle ) {\n\t\t\t\t$this->stream_handle = $stream_handle;\n\t\t\t\t$this->proxy_url_curl( $raw_url, $args );\n\t\t\t\texit;\n\t\t\t}\n\t\t}\n\n\t\t// If either cURL is not available or fopen() did not succeed,\n\t\t// fall back to using whatever else is set up on the site,\n\t\t// presumably WP_Http_Streams or still WP_Http_Curl but without streams.\n\t\tunset( $args['blocking'] );\n\t\t$this->proxy_url_fallback( $raw_url, $args );\n\n\t\texit;\n\t}\n\n\t/**\n\t * Proxy a given URL via a PHP read-write stream.\n\t *\n\t * @since 1.15.0\n\t *\n\t * @param string               $url  Request URL.\n\t * @param array<string, mixed> $args Request args.\n\t */\n\tprivate function proxy_url_curl( string $url, array $args ): void {\n\t\tadd_action( 'http_api_curl', [ $this, 'modify_curl_configuration' ] );\n\t\twp_safe_remote_get( $url, $args );\n\t\tremove_action( 'http_api_curl', [ $this, 'modify_curl_configuration' ] );\n\n\t\trewind( $this->stream_handle );\n\t\twhile ( ! feof( $this->stream_handle ) ) {\n\t\t\techo fread( $this->stream_handle, 1024 * 1024 ); // phpcs:ignore WordPress.Security.EscapeOutput.OutputNotEscaped, WordPress.WP.AlternativeFunctions.file_system_read_fread\n\t\t}\n\n\t\tfclose( $this->stream_handle );\n\t}\n\n\t/**\n\t * Proxy a given URL by storing in memory.\n\t *\n\t * @since 1.15.0\n\t *\n\t * @param string               $url  Request URL.\n\t * @param array<string, mixed> $args Request args.\n\t */\n\tprivate function proxy_url_fallback( string $url, array $args ): void {\n\t\t$response = wp_safe_remote_get( $url, $args );\n\t\t$status   = wp_remote_retrieve_response_code( $response );\n\n\t\tif ( ! $status ) {\n\t\t\thttp_response_code( 404 );\n\t\t\treturn;\n\t\t}\n\n\t\thttp_response_code( (int) $status );\n\n\t\t$headers = wp_remote_retrieve_headers( $response );\n\n\t\tforeach ( self::PROXY_HEADERS_ALLOWLIST as $_header ) {\n\t\t\tif ( isset( $headers[ $_header ] ) ) {\n\t\t\t\theader( $_header . ': ' . $headers[ $_header ] );\n\t\t\t}\n\t\t}\n\n\t\techo wp_remote_retrieve_body( $response ); // phpcs:ignore WordPress.Security.EscapeOutput.OutputNotEscaped\n\t}\n\n\t/**\n\t * Prepares response asset response.\n\t *\n\t * @since 1.11.0\n\t *\n\t * @param LinkData|false  $link    URL data value, default to false is not set.\n\t * @param WP_REST_Request $request Request object.\n\t * @return WP_REST_Response|WP_Error Response object.\n\t *\n\t * @phpstan-param LinkData $link\n\t */\n\tpublic function prepare_item_for_response( $link, $request ) {\n\t\t$fields = $this->get_fields_for_response( $request );\n\t\t$schema = $this->get_item_schema();\n\n\t\t$data = [];\n\n\t\t$error = new WP_Error();\n\t\tforeach ( $schema['properties'] as $field => $args ) {\n\t\t\tif ( ! isset( $link[ $field ] ) || ! rest_is_field_included( $field, $fields ) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t$check = rest_validate_value_from_schema( $link[ $field ], $args, $field );\n\t\t\tif ( is_wp_error( $check ) ) {\n\t\t\t\t$error->add( 'rest_invalid_' . $field, $check->get_error_message(), [ 'status' => 400 ] );\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t$data[ $field ] = rest_sanitize_value_from_schema( $link[ $field ], $args, $field );\n\t\t}\n\n\t\tif ( $error->get_error_codes() ) {\n\t\t\treturn $error;\n\t\t}\n\n\t\t/**\n\t\t * Request context.\n\t\t *\n\t\t * @var string $context\n\t\t */\n\t\t$context = ! empty( $request['context'] ) ? $request['context'] : 'view';\n\t\t$data    = $this->add_additional_fields_to_object( $data, $request );\n\t\t$data    = $this->filter_response_by_context( $data, $context );\n\n\t\treturn rest_ensure_response( $data );\n\t}\n\n\t/**\n\t * Retrieves the link's schema, conforming to JSON Schema.\n\t *\n\t * @since 1.11.0\n\t *\n\t * @return array Item schema data.\n\t *\n\t * @phpstan-return Schema\n\t */\n\tpublic function get_item_schema(): array {\n\t\tif ( $this->schema ) {\n\t\t\t/**\n\t\t\t * Schema.\n\t\t\t *\n\t\t\t * @phpstan-var Schema $schema\n\t\t\t */\n\t\t\t$schema = $this->add_additional_fields_schema( $this->schema );\n\t\t\treturn $schema;\n\t\t}\n\n\t\t$allowed_mime_types = $this->get_allowed_mime_types();\n\t\t$types              = array_keys( $allowed_mime_types );\n\t\t$allowed_mime_types = array_merge( ...array_values( $allowed_mime_types ) );\n\t\t$exts               = $this->types->get_file_type_exts( $allowed_mime_types );\n\n\t\t$schema = [\n\t\t\t'$schema'    => 'http://json-schema.org/draft-04/schema#',\n\t\t\t'title'      => 'link',\n\t\t\t'type'       => 'object',\n\t\t\t'properties' => [\n\t\t\t\t'ext'       => [\n\t\t\t\t\t'description' => __( 'File extension', 'web-stories' ),\n\t\t\t\t\t'type'        => 'string',\n\t\t\t\t\t'context'     => [ 'view', 'edit', 'embed' ],\n\t\t\t\t\t'enum'        => $exts,\n\t\t\t\t],\n\t\t\t\t'file_name' => [\n\t\t\t\t\t'description' => __( 'File name', 'web-stories' ),\n\t\t\t\t\t'type'        => 'string',\n\t\t\t\t\t'context'     => [ 'view', 'edit', 'embed' ],\n\t\t\t\t],\n\t\t\t\t'file_size' => [\n\t\t\t\t\t'description' => __( 'File size', 'web-stories' ),\n\t\t\t\t\t'type'        => 'integer',\n\t\t\t\t\t'context'     => [ 'view', 'edit', 'embed' ],\n\t\t\t\t],\n\t\t\t\t'mime_type' => [\n\t\t\t\t\t'description' => __( 'Mime type', 'web-stories' ),\n\t\t\t\t\t'type'        => 'string',\n\t\t\t\t\t'context'     => [ 'view', 'edit', 'embed' ],\n\t\t\t\t\t'enum'        => $allowed_mime_types,\n\t\t\t\t],\n\t\t\t\t'type'      => [\n\t\t\t\t\t'description' => __( 'Type', 'web-stories' ),\n\t\t\t\t\t'type'        => 'string',\n\t\t\t\t\t'context'     => [ 'view', 'edit', 'embed' ],\n\t\t\t\t\t'enum'        => $types,\n\t\t\t\t],\n\t\t\t],\n\t\t];\n\n\t\t$this->schema = $schema;\n\n\t\t/**\n\t\t * Schema.\n\t\t *\n\t\t * @phpstan-var Schema $schema\n\t\t */\n\t\t$schema = $this->add_additional_fields_schema( $this->schema );\n\t\treturn $schema;\n\t}\n\n\t/**\n\t * Checks if current user can process urls.\n\t *\n\t * @since 1.11.0\n\t *\n\t * @return true|WP_Error True if the request has read access, WP_Error object otherwise.\n\t */\n\tpublic function parse_url_permissions_check() {\n\t\tif ( ! $this->story_post_type->has_cap( 'edit_posts' ) ) {\n\t\t\treturn new WP_Error(\n\t\t\t\t'rest_forbidden',\n\t\t\t\t__( 'Sorry, you are not allowed to insert external media.', 'web-stories' ),\n\t\t\t\t[ 'status' => rest_authorization_required_code() ]\n\t\t\t);\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Callback to validate urls.\n\t *\n\t * @since 1.11.0\n\t *\n\t * @param string $value Value to be validated.\n\t * @return true|WP_Error\n\t */\n\tpublic function validate_callback( $value ) {\n\t\t$url = untrailingslashit( $value );\n\n\t\tif ( empty( $url ) || ! $this->validate_url( $url ) ) {\n\t\t\treturn new WP_Error( 'rest_invalid_url', __( 'Invalid URL', 'web-stories' ), [ 'status' => 400 ] );\n\t\t}\n\n\t\t$path = wp_parse_url( $url, PHP_URL_PATH );\n\n\t\tif ( ! $path ) {\n\t\t\treturn new WP_Error( 'rest_invalid_url', __( 'Invalid URL', 'web-stories' ), [ 'status' => 400 ] );\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Validate a URL for safe use in the HTTP API.\n\t *\n\t * Like {@see wp_http_validate_url} in core, but with extra hardening\n\t * to avoid DNS rebinding issues.\n\t *\n\t * @SuppressWarnings(PHPMD.NPathComplexity)\n\t * @SuppressWarnings(PHPMD.CyclomaticComplexity)\n\t *\n\t * @since 1.22.0\n\t *\n\t * @param string $url Request URL.\n\t * @return string|false Original URL, resolved IP address, or false on failure.\n\t */\n\tprivate function validate_url( string $url ) {\n\t\tif ( '' === $url || is_numeric( $url ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t$original_url = $url;\n\t\t$url          = wp_kses_bad_protocol( $url, [ 'http', 'https' ] );\n\t\tif ( ! $url || strtolower( $url ) !== strtolower( $original_url ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t$parsed_url = wp_parse_url( $url );\n\t\tif ( ! $parsed_url || ! isset( $parsed_url['host'], $parsed_url['scheme'] ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( isset( $parsed_url['user'] ) || isset( $parsed_url['pass'] ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( false !== strpbrk( $parsed_url['host'], ':#?[]' ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t/**\n\t\t * Home URL.\n\t\t *\n\t\t * @var string\n\t\t */\n\t\t$home_url = get_option( 'home' );\n\n\t\t$parsed_home = wp_parse_url( $home_url );\n\n\t\tif ( ! $parsed_home ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t$same_host = isset( $parsed_home['host'] ) && strtolower( $parsed_home['host'] ) === strtolower( $parsed_url['host'] );\n\t\t$host      = trim( $parsed_url['host'], '.' );\n\n\t\t$validated_url = $url;\n\n\t\tif ( ! $same_host ) {\n\t\t\tif ( preg_match( '#^(([1-9]?\\d|1\\d\\d|25[0-5]|2[0-4]\\d)\\.){3}([1-9]?\\d|1\\d\\d|25[0-5]|2[0-4]\\d)$#', $host ) ) {\n\t\t\t\t$ip = $host;\n\t\t\t} else {\n\t\t\t\t$ip = gethostbyname( $host );\n\t\t\t\tif ( $ip === $host ) { // Error condition for gethostbyname().\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t$parts = array_map( 'intval', explode( '.', $ip ) );\n\t\t\tif ( 127 === $parts[0] || 10 === $parts[0] || 0 === $parts[0]\n\t\t\t\t|| ( 172 === $parts[0] && 16 <= $parts[1] && 31 >= $parts[1] )\n\t\t\t\t|| ( 192 === $parts[0] && 168 === $parts[1] )\n\t\t\t) {\n\t\t\t\t// If host appears local, reject.\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// Use resolved IP address to avoid DNS rebinding issues.\n\t\t\t$validated_url = $ip;\n\t\t}\n\n\t\t/** This filter is documented in wp-includes/http.php */\n\t\t$allowed_ports = apply_filters( 'http_allowed_safe_ports', [ 80, 443, 8080 ], $host, $url );\n\t\tif (\n\t\t\t! isset( $parsed_url['port'] ) ||\n\t\t\t( \\is_array( $allowed_ports ) && \\in_array( $parsed_url['port'], $allowed_ports, true ) )\n\t\t) {\n\t\t\treturn $validated_url;\n\t\t}\n\n\t\tif ( $same_host && isset( $parsed_home['port'] ) && $parsed_home['port'] === $parsed_url['port'] ) {\n\t\t\treturn $validated_url;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Returns a callback to modify the cURL configuration before the request is executed.\n\t *\n\t * @since 1.22.1\n\t *\n\t * @param string $url       URL.\n\t * @param string $url_or_ip URL or IP address.\n\t */\n\tpublic function get_curl_resolve_callback( string $url, string $url_or_ip ): callable {\n\t\t/**\n\t\t * CURL configuration callback.\n\t\t *\n\t\t * @param resource $handle The cURL handle returned by curl_init() (passed by reference).\n\t\t */\n\t\treturn static function( $handle ) use ( $url, $url_or_ip ): void {\n\t\t\t// Just some safeguard in case cURL is not really available,\n\t\t\t// despite this method being run in the context of WP_Http_Curl.\n\t\t\tif ( ! function_exists( 'curl_setopt' ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( $url === $url_or_ip ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t$host   = wp_parse_url( $url, PHP_URL_HOST );\n\t\t\t$scheme = wp_parse_url( $url, PHP_URL_SCHEME ) ?? 'http';\n\t\t\t$port   = wp_parse_url( $url, PHP_URL_PORT ) ?? 'http' === $scheme ? 80 : 443;\n\n\t\t\t// phpcs:disable WordPress.WP.AlternativeFunctions.curl_curl_setopt\n\n\t\t\tcurl_setopt(\n\t\t\t\t$handle,\n\t\t\t\tCURLOPT_RESOLVE,\n\t\t\t\t[\n\t\t\t\t\t\"$host:$port:$url_or_ip\",\n\t\t\t\t]\n\t\t\t);\n\n\t\t\t// phpcs:enable WordPress.WP.AlternativeFunctions.curl_curl_setopt\n\t\t};\n\t}\n\n\t/**\n\t * Modifies the cURL configuration before the request is executed.\n\t *\n\t * @since 1.15.0\n\t *\n\t * @param resource $handle The cURL handle returned by {@see curl_init()} (passed by reference).\n\t */\n\tpublic function modify_curl_configuration( $handle ): void {\n\t\t// Just some safeguard in case cURL is not really available,\n\t\t// despite this method being run in the context of WP_Http_Curl.\n\t\tif ( ! function_exists( 'curl_setopt' ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// phpcs:disable WordPress.WP.AlternativeFunctions.curl_curl_setopt\n\n\t\tcurl_setopt(\n\t\t\t$handle,\n\t\t\tCURLOPT_FILE,\n\t\t\t$this->stream_handle\n\t\t);\n\n\t\tcurl_setopt( $handle, CURLOPT_HEADERFUNCTION, [ $this, 'stream_headers' ] );\n\n\t\t// phpcs:enable WordPress.WP.AlternativeFunctions.curl_curl_setopt\n\t}\n\n\t/**\n\t * Grabs the headers of the cURL request.\n\t *\n\t * Each header is sent individually to this callback,\n\t * so we take a look at each one to see if we should \"forward\" it.\n\t *\n\t * @since 1.15.0\n\t *\n\t * @param resource $handle  cURL handle.\n\t * @param string   $header cURL header.\n\t * @return int Header length.\n\t */\n\tpublic function stream_headers( $handle, $header ): int {\n\t\t// Parse Status-Line, the first component in the HTTP response, e.g. HTTP/1.1 200 OK.\n\t\t// Extract the status code to re-send that here.\n\t\tif ( 0 === strpos( $header, 'HTTP/' ) ) {\n\t\t\t$status = explode( ' ', $header );\n\t\t\thttp_response_code( (int) $status[1] );\n\t\t\treturn \\strlen( $header );\n\t\t}\n\n\t\tforeach ( self::PROXY_HEADERS_ALLOWLIST as $_header ) {\n\t\t\tif ( 0 === stripos( $header, strtolower( $_header ) . ': ' ) ) {\n\t\t\t\theader( $header, true );\n\t\t\t}\n\t\t}\n\n\t\treturn \\strlen( $header );\n\t}\n\n\t/**\n\t * Returns a list of allowed mime types per media type (image, audio, video).\n\t *\n\t * @since 1.19.0\n\t *\n\t * @return array<string, string[]> List of allowed mime types.\n\t */\n\tprotected function get_allowed_mime_types(): array {\n\t\t$mime_type = $this->types->get_allowed_mime_types();\n\n\t\t// Do not support hotlinking SVGs for security reasons.\n\t\tunset( $mime_type['vector'] );\n\n\t\treturn $mime_type;\n\t}\n}\n", "<?php\n/**\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nnamespace Google\\Web_Stories\\Tests\\Integration\\REST_API;\n\nuse Google\\Web_Stories\\Tests\\Integration\\DependencyInjectedRestTestCase;\nuse WP_Error;\nuse WP_REST_Request;\nuse WP_REST_Server;\n\n/**\n * Class Hotlinking_Controller\n *\n * @coversDefaultClass \\Google\\Web_Stories\\REST_API\\Hotlinking_Controller\n */\nclass Hotlinking_Controller extends DependencyInjectedRestTestCase {\n\tprotected static $subscriber;\n\tprotected static $editor;\n\n\tpublic const URL_INVALID      = 'https://https://invalid.commmm';\n\tpublic const URL_404          = 'https://example.com/404/test.jpg';\n\tpublic const URL_500          = 'https://example.com/500/test.jpg';\n\tpublic const URL_SVG          = 'https://example.com/test.svg';\n\tpublic const URL_VALID        = 'http://example.com/test.jpg';\n\tpublic const URL_DOMAIN       = 'http://google.com';\n\tpublic const URL_WITH_CHARSET = 'https://example.com/test.png';\n\tpublic const URL_PATH         = '/test.jpg';\n\n\tpublic const REST_URL = '/web-stories/v1/hotlink/validate';\n\n\t/**\n\t * Count of the number of requests attempted.\n\t *\n\t * @var int\n\t */\n\tprotected $request_count = 0;\n\n\t/**\n\t * Test instance.\n\t *\n\t * @var \\Google\\Web_Stories\\REST_API\\Hotlinking_Controller\n\t */\n\tprivate $controller;\n\n\tpublic static function wpSetUpBeforeClass( $factory ): void {\n\t\tself::$subscriber = $factory->user->create(\n\t\t\t[\n\t\t\t\t'role' => 'subscriber',\n\t\t\t]\n\t\t);\n\t\tself::$editor     = $factory->user->create(\n\t\t\t[\n\t\t\t\t'role'       => 'editor',\n\t\t\t\t'user_email' => 'editor@example.com',\n\t\t\t]\n\t\t);\n\t}\n\n\tpublic function set_up(): void {\n\t\tparent::set_up();\n\n\t\tadd_filter( 'pre_http_request', [ $this, 'mock_http_request' ], 10, 3 );\n\t\t$this->request_count = 0;\n\n\t\t$this->controller = $this->injector->make( \\Google\\Web_Stories\\REST_API\\Hotlinking_Controller::class );\n\t}\n\n\tpublic function tear_down(): void {\n\t\tremove_filter( 'pre_http_request', [ $this, 'mock_http_request' ] );\n\n\t\tparent::tear_down();\n\t}\n\n\t/**\n\t * Intercept link processing requests and mock responses.\n\t *\n\t * @param mixed  $preempt Whether to preempt an HTTP request's return value. Default false.\n\t * @param mixed  $r       HTTP request arguments.\n\t * @param string $url     The request URL.\n\t * @return array|WP_Error Response data.\n\t */\n\tpublic function mock_http_request( $preempt, $r, string $url ) {\n\t\t++ $this->request_count;\n\n\t\tif ( false !== strpos( $url, self::URL_INVALID ) ) {\n\t\t\treturn $preempt;\n\t\t}\n\n\t\t// URL_VALID\n\t\tif ( self::URL_VALID === $url ) {\n\t\t\treturn [\n\t\t\t\t'headers'  => [\n\t\t\t\t\t'content-type'   => 'image/jpeg',\n\t\t\t\t\t'content-length' => 5000,\n\t\t\t\t],\n\t\t\t\t'response' => [ 'code' => 200 ],\n\t\t\t];\n\t\t}\n\n\t\tif ( self::URL_SVG === $url ) {\n\t\t\treturn [\n\t\t\t\t'headers'  => [\n\t\t\t\t\t'content-type'   => 'image/svg+xml',\n\t\t\t\t\t'content-length' => 5000,\n\t\t\t\t],\n\t\t\t\t'response' => [ 'code' => 200 ],\n\t\t\t];\n\t\t}\n\n\t\tif ( self::URL_WITH_CHARSET === $url ) {\n\t\t\treturn [\n\t\t\t\t'headers'  => [\n\t\t\t\t\t'content-type'   => 'image/png; charset=utf-8',\n\t\t\t\t\t'content-length' => 1000,\n\t\t\t\t],\n\t\t\t\t'response' => [ 'code' => 200 ],\n\t\t\t];\n\t\t}\n\n\t\tif ( self::URL_404 === $url ) {\n\t\t\treturn [\n\t\t\t\t'headers'  => [\n\t\t\t\t\t'content-type'   => 'image/jpeg',\n\t\t\t\t\t'content-length' => 5000,\n\t\t\t\t],\n\t\t\t\t'response' => [ 'code' => 404 ],\n\t\t\t];\n\t\t}\n\n\t\t// URL_500\n\t\tif ( 'https://93.184.216.34.com/500/test.jpg' === $url ) {\n\t\t\treturn [\n\t\t\t\t'headers'  => [\n\t\t\t\t\t'content-type'   => 'image/jpeg',\n\t\t\t\t\t'content-length' => 5000,\n\t\t\t\t],\n\t\t\t\t'response' => [ 'code' => 500 ],\n\t\t\t];\n\t\t}\n\n\t\treturn $preempt;\n\t}\n\n\t/**\n\t * @covers ::register\n\t */\n\tpublic function test_register(): void {\n\t\t$this->controller->register();\n\n\t\t$routes = rest_get_server()->get_routes();\n\n\t\t$this->assertArrayHasKey( self::REST_URL, $routes );\n\t}\n\n\t/**\n\t * @covers ::validate_callback\n\t */\n\tpublic function test_validate_url(): void {\n\t\t$result = $this->controller->validate_callback( self::URL_VALID );\n\t\t$this->assertTrue( $result );\n\t}\n\n\t/**\n\t * @covers ::validate_callback\n\t */\n\tpublic function test_validate_url_empty(): void {\n\t\t$result = $this->controller->validate_callback( '' );\n\t\t$this->assertErrorResponse( 'rest_invalid_url', $result, 400 );\n\t}\n\n\t/**\n\t * @covers ::validate_callback\n\t */\n\tpublic function test_validate_url_domain(): void {\n\t\t$result = $this->controller->validate_callback( self::URL_DOMAIN );\n\t\t$this->assertErrorResponse( 'rest_invalid_url', $result, 400 );\n\t}\n\n\t/**\n\t * @covers ::validate_callback\n\t */\n\tpublic function test_validate_url_path(): void {\n\t\t$result = $this->controller->validate_callback( self::URL_PATH );\n\t\t$this->assertErrorResponse( 'rest_invalid_url', $result, 400 );\n\t}\n\n\t/**\n\t * @covers ::validate_callback\n\t */\n\tpublic function test_validate_url_invalid(): void {\n\t\t$result = $this->controller->validate_callback( '-1' );\n\t\t$this->assertErrorResponse( 'rest_invalid_url', $result, 400 );\n\t}\n\n\t/**\n\t * @covers ::validate_callback\n\t */\n\tpublic function test_validate_url_invalid2(): void {\n\t\t$result = $this->controller->validate_callback( 'wibble' );\n\t\t$this->assertErrorResponse( 'rest_invalid_url', $result, 400 );\n\t}\n\n\t/**\n\t * @covers ::get_item_schema\n\t */\n\tpublic function test_get_item_schema(): void {\n\t\t$data = $this->controller->get_item_schema();\n\n\t\t$properties = $data['properties'];\n\t\t$this->assertArrayHasKey( 'ext', $properties );\n\t\t$this->assertArrayHasKey( 'file_name', $properties );\n\t\t$this->assertArrayHasKey( 'file_size', $properties );\n\t\t$this->assertArrayHasKey( 'mime_type', $properties );\n\t\t$this->assertArrayHasKey( 'type', $properties );\n\t\t$this->assertArrayHasKey( 'enum', $properties['type'] );\n\t\t$this->assertEqualSets( [ 'audio', 'image', 'video', 'caption' ], $properties['type']['enum'] );\n\t}\n\n\t/**\n\t * @covers ::parse_url\n\t * @covers ::parse_url_permissions_check\n\t */\n\tpublic function test_parse_url_without_permission(): void {\n\t\t$this->controller->register();\n\n\t\t// Test without a login.\n\t\t$request = new WP_REST_Request( WP_REST_Server::READABLE, self::REST_URL );\n\t\t$request->set_param( 'url', self::URL_VALID );\n\t\t$response = rest_get_server()->dispatch( $request );\n\n\t\t$this->assertEquals( 401, $response->get_status() );\n\n\t\t// Test with a user that does not have edit_posts capability.\n\t\twp_set_current_user( self::$subscriber );\n\t\t$request = new WP_REST_Request( WP_REST_Server::READABLE, self::REST_URL );\n\t\t$request->set_param( 'url', self::URL_VALID );\n\t\t$response = rest_get_server()->dispatch( $request );\n\n\t\t$this->assertEquals( 403, $response->get_status() );\n\t\t$data = $response->get_data();\n\t\t$this->assertEquals( 'rest_forbidden', $data['code'] );\n\t}\n\n\tpublic function test_url_invalid_url(): void {\n\t\t$this->controller->register();\n\n\t\twp_set_current_user( self::$editor );\n\t\t$request = new WP_REST_Request( WP_REST_Server::READABLE, self::REST_URL );\n\t\t$request->set_param( 'url', self::URL_INVALID );\n\t\t$response = rest_get_server()->dispatch( $request );\n\t\t$data     = $response->get_data();\n\n\t\t$this->assertEquals( 0, $this->request_count );\n\t\t$this->assertEquals( 400, $response->get_status() );\n\t\t$this->assertEquals( 'rest_invalid_param', $data['code'] );\n\t}\n\n\t/**\n\t * @covers ::parse_url\n\t * @covers ::parse_url_permissions_check\n\t */\n\tpublic function test_parse_url_empty_string(): void {\n\t\t$this->controller->register();\n\n\t\twp_set_current_user( self::$editor );\n\t\t$request = new WP_REST_Request( WP_REST_Server::READABLE, self::REST_URL );\n\t\t$request->set_param( 'url', '' );\n\t\t$response = rest_get_server()->dispatch( $request );\n\t\t$data     = $response->get_data();\n\n\t\t$this->assertEquals( 0, $this->request_count );\n\t\t$this->assertTrue( $response->is_error() );\n\t\t$this->assertEquals( 400, $response->get_status() );\n\t\t$this->assertEquals( 'rest_invalid_param', $data['code'] );\n\t}\n\n\t/**\n\t * @covers ::parse_url\n\t * @covers ::parse_url_permissions_check\n\t */\n\tpublic function test_parse_url(): void {\n\t\t$this->controller->register();\n\n\t\twp_set_current_user( self::$editor );\n\t\t$request = new WP_REST_Request( WP_REST_Server::READABLE, self::REST_URL );\n\t\t$request->set_param( 'url', self::URL_VALID );\n\t\t$response = rest_get_server()->dispatch( $request );\n\t\t$data     = $response->get_data();\n\n\t\t$this->assertFalse( $response->is_error() );\n\t\t$this->assertEqualSets(\n\t\t\t[\n\t\t\t\t'ext'       => 'jpg',\n\t\t\t\t'file_name' => 'test.jpg',\n\t\t\t\t'file_size' => 5000,\n\t\t\t\t'mime_type' => 'image/jpeg',\n\t\t\t\t'type'      => 'image',\n\t\t\t],\n\t\t\t$data\n\t\t);\n\t}\n\n\t/**\n\t * @covers ::parse_url\n\t * @covers ::parse_url_permissions_check\n\t */\n\tpublic function test_parse_url_cache(): void {\n\t\t$this->controller->register();\n\n\t\twp_set_current_user( self::$editor );\n\t\t$request = new WP_REST_Request( WP_REST_Server::READABLE, self::REST_URL );\n\t\t$request->set_param( 'url', self::URL_VALID );\n\t\t$response = rest_get_server()->dispatch( $request );\n\n\t\t$this->assertFalse( $response->is_error() );\n\t\t$this->assertEquals( 1, $this->request_count );\n\n\t\t$data = $response->get_data();\n\t\t$this->assertEqualSets(\n\t\t\t[\n\t\t\t\t'ext'       => 'jpg',\n\t\t\t\t'file_name' => 'test.jpg',\n\t\t\t\t'file_size' => 5000,\n\t\t\t\t'mime_type' => 'image/jpeg',\n\t\t\t\t'type'      => 'image',\n\t\t\t],\n\t\t\t$data\n\t\t);\n\n\t\t$response = rest_get_server()->dispatch( $request );\n\n\t\t$this->assertFalse( $response->is_error() );\n\t\t$this->assertEquals( 1, $this->request_count );\n\n\t\t$data = $response->get_data();\n\t\t$this->assertEqualSets(\n\t\t\t[\n\t\t\t\t'ext'       => 'jpg',\n\t\t\t\t'file_name' => 'test.jpg',\n\t\t\t\t'file_size' => 5000,\n\t\t\t\t'mime_type' => 'image/jpeg',\n\t\t\t\t'type'      => 'image',\n\t\t\t],\n\t\t\t$data\n\t\t);\n\t}\n\n\t/**\n\t * @covers ::parse_url\n\t * @covers ::parse_url_permissions_check\n\t */\n\tpublic function test_parse_url_404(): void {\n\t\t$this->controller->register();\n\n\t\twp_set_current_user( self::$editor );\n\t\t$request = new WP_REST_Request( WP_REST_Server::READABLE, self::REST_URL );\n\t\t$request->set_param( 'url', self::URL_404 );\n\t\t$response = rest_get_server()->dispatch( $request );\n\t\t$this->assertErrorResponse( 'rest_invalid_url', $response, 404 );\n\t}\n\n\t/**\n\t * @covers ::parse_url\n\t * @covers ::parse_url_permissions_check\n\t */\n\tpublic function test_parse_url_500(): void {\n\t\t$this->controller->register();\n\n\t\twp_set_current_user( self::$editor );\n\t\t$request = new WP_REST_Request( WP_REST_Server::READABLE, self::REST_URL );\n\t\t$request->set_param( 'url', self::URL_500 );\n\t\t$response = rest_get_server()->dispatch( $request );\n\t\t$this->assertErrorResponse( 'rest_invalid_url', $response, 404 );\n\t}\n\n\n\t/**\n\t * @covers ::parse_url\n\t * @covers ::parse_url_permissions_check\n\t * @covers ::prepare_item_for_response\n\t */\n\tpublic function test_parse_url_svg(): void {\n\t\t$this->controller->register();\n\n\t\twp_set_current_user( self::$editor );\n\t\t$request = new WP_REST_Request( WP_REST_Server::READABLE, self::REST_URL );\n\t\t$request->set_param( 'url', self::URL_SVG );\n\t\t$response = rest_get_server()->dispatch( $request );\n\t\t$this->assertErrorResponse( 'rest_invalid_ext', $response, 400 );\n\t}\n\n\t/**\n\t * @covers ::parse_url\n\t * @covers ::parse_url_permissions_check\n\t */\n\tpublic function test_parse_url_with_charset_in_content_type_header(): void {\n\t\t$this->controller->register();\n\n\t\twp_set_current_user( self::$editor );\n\t\t$request = new WP_REST_Request( WP_REST_Server::READABLE, self::REST_URL );\n\t\t$request->set_param( 'url', self::URL_WITH_CHARSET );\n\t\t$response = rest_get_server()->dispatch( $request );\n\t\t$data     = $response->get_data();\n\n\t\t$this->assertFalse( $response->is_error() );\n\t\t$this->assertEqualSets(\n\t\t\t[\n\t\t\t\t'ext'       => 'png',\n\t\t\t\t'file_name' => 'test.png',\n\t\t\t\t'file_size' => 1000,\n\t\t\t\t'mime_type' => 'image/png',\n\t\t\t\t'type'      => 'image',\n\t\t\t],\n\t\t\t$data\n\t\t);\n\t}\n\n\t/**\n\t * @covers ::get_allowed_mime_types\n\t */\n\tpublic function test_get_allowed_mime_types(): void {\n\t\t$story_post_type = $this->injector->make( \\Google\\Web_Stories\\Story_Post_Type::class );\n\t\t$types           = $this->injector->make( \\Google\\Web_Stories\\Media\\Types::class );\n\t\t$experiments     = $this->createMock( \\Google\\Web_Stories\\Experiments::class );\n\t\t$experiments->method( 'is_experiment_enabled' )\n\t\t\t\t\t->willReturn( true );\n\t\t$controller = new \\Google\\Web_Stories\\REST_API\\Hotlinking_Controller( $story_post_type, $types, $experiments );\n\t\t$mime_types = $this->call_private_method( $controller, 'get_allowed_mime_types' );\n\t\t$this->assertArrayHasKey( 'audio', $mime_types );\n\t\t$this->assertArrayHasKey( 'video', $mime_types );\n\t\t$this->assertArrayHasKey( 'caption', $mime_types );\n\t\t$this->assertArrayHasKey( 'video', $mime_types );\n\t\t$this->assertSame( 'text/vtt', $mime_types['caption'][0] );\n\t}\n\n\t/**\n\t * Test that validate_url validates URLs.\n\t *\n\t * @param string       $url            The URL to validate.\n\t * @param string       $expected       Expected result.\n\t * @param false|string $cb_safe_ports  The name of the callback to http_allowed_safe_ports or false if none.\n\t *                                     Default false.\n\t *\n\t * @dataProvider data_validate_url_should_validate\n\t * @covers ::validate_url\n\t */\n\tpublic function test_validate_url_should_validate( string $url, string $expected, $cb_safe_ports = false ): void {\n\t\tif ( $cb_safe_ports ) {\n\t\t\tadd_filter( 'http_allowed_safe_ports', [ $this, $cb_safe_ports ] );\n\t\t}\n\n\t\t$this->assertSame( $expected, $this->call_private_method( $this->controller, 'validate_url', [ $url ] ) );\n\t}\n\n\t/**\n\t * Data provider.\n\t *\n\t * @return array\n\t */\n\tpublic function data_validate_url_should_validate(): array {\n\t\treturn [\n\t\t\t'no port specified'                 => [\n\t\t\t\t'url'      => 'http://example.com/caniload.php',\n\t\t\t\t'expected' => '93.184.216.34',\n\t\t\t],\n\t\t\t'a port considered safe by default' => [\n\t\t\t\t'url'      => 'https://example.com:8080/caniload.php',\n\t\t\t\t'expected' => '93.184.216.34',\n\t\t\t],\n\t\t\t'a port considered safe by filter'  => [\n\t\t\t\t'url'           => 'https://example.com:81/caniload.php',\n\t\t\t\t'expected'      => '93.184.216.34',\n\t\t\t\t'cb_safe_ports' => 'callback_custom_safe_ports',\n\t\t\t],\n\t\t];\n\t}\n\n\t/**\n\t * Tests that validate_url validates a url that uses an unsafe port\n\t * but which matches the host and port used by the site's home url.\n\t *\n\t * @covers ::validate_url\n\t */\n\tpublic function test_validate_url_should_validate_with_an_unsafe_port_when_the_host_and_port_match_the_home_url(): void {\n\t\t$original_home    = get_option( 'home' );\n\t\t$home_parsed      = wp_parse_url( $original_home );\n\t\t$home_scheme_host = implode( '://', \\array_slice( $home_parsed, 0, 2 ) );\n\t\t$home_modified    = $home_scheme_host . ':83';\n\n\t\tupdate_option( 'home', $home_modified );\n\n\t\t$url = $home_modified . '/caniload.php';\n\n\t\t$actual = $this->call_private_method( $this->controller, 'validate_url', [ $url ] );\n\n\t\tupdate_option( 'home', $original_home );\n\n\t\t$this->assertSame( $url, $actual );\n\t}\n\n\t/**\n\t * Test that validate_url does not validate invalid URLs.\n\t *\n\t * @param string       $url            The URL to validate.\n\t * @param false|string $cb_safe_ports  The name of the callback to http_allowed_safe_ports or false if none.\n\t *                                     Default false.\n\t * @param bool         $external_host  Whether or not the host is external.\n\t *                                     Default false.\n\t *\n\t * @dataProvider data_validate_url_should_not_validate\n\t * @covers ::validate_url\n\t */\n\tpublic function test_validate_url_should_not_validate( string $url, $cb_safe_ports = false, bool $external_host = false ): void {\n\t\tif ( $external_host ) {\n\t\t\tadd_filter( 'http_request_host_is_external', '__return_true' );\n\t\t}\n\n\t\tif ( $cb_safe_ports ) {\n\t\t\tadd_filter( 'http_allowed_safe_ports', [ $this, $cb_safe_ports ] );\n\t\t}\n\n\t\t$this->assertFalse( $this->call_private_method( $this->controller, 'validate_url', [ $url ] ) );\n\t}\n\n\t/**\n\t * Data provider.\n\t *\n\t * @return array\n\t */\n\tpublic function data_validate_url_should_not_validate(): array {\n\t\treturn [\n\t\t\t'url as string 0'                              => [\n\t\t\t\t'url' => '0',\n\t\t\t],\n\t\t\t'url as string 1'                              => [\n\t\t\t\t'url' => '1',\n\t\t\t],\n\t\t\t'an empty url'                                 => [\n\t\t\t\t'url' => '',\n\t\t\t],\n\t\t\t'a url with a non-http/https protocol'         => [\n\t\t\t\t'url' => 'ftp://example.com:81/caniload.php',\n\t\t\t],\n\t\t\t'a malformed url'                              => [\n\t\t\t\t'url' => 'http:///example.com:81/caniload.php',\n\t\t\t],\n\t\t\t'a host that cannot be parsed'                 => [\n\t\t\t\t'url' => 'http:example.com/caniload.php',\n\t\t\t],\n\t\t\t'login information'                            => [\n\t\t\t\t'url' => 'http://user:pass@example.com/caniload.php',\n\t\t\t],\n\t\t\t'a host with invalid characters'               => [\n\t\t\t\t'url' => 'http://[exam]ple.com/caniload.php',\n\t\t\t],\n\t\t\t'a host whose IPv4 address cannot be resolved' => [\n\t\t\t\t'url' => 'http://exampleeeee.com/caniload.php',\n\t\t\t],\n\t\t\t'an external request when not allowed'         => [\n\t\t\t\t'url' => 'http://192.168.0.1/caniload.php',\n\t\t\t],\n\t\t\t'a port not considered safe by default'        => [\n\t\t\t\t'url' => 'https://example.com:81/caniload.php',\n\t\t\t],\n\t\t\t'a port not considered safe by filter'         => [\n\t\t\t\t'url'           => 'https://example.com:82/caniload.php',\n\t\t\t\t'cb_safe_ports' => 'callback_custom_safe_ports',\n\t\t\t],\n\t\t\t'all safe ports removed by filter'             => [\n\t\t\t\t'url'           => 'https://example.com:81/caniload.php',\n\t\t\t\t'cb_safe_ports' => 'callback_remove_safe_ports',\n\t\t\t],\n\t\t];\n\t}\n\n\tpublic function callback_custom_safe_ports(): array {\n\t\treturn [ 81, 444, 8081 ];\n\t}\n\n\tpublic function callback_remove_safe_ports(): array {\n\t\treturn [];\n\t}\n}\n"], "fixing_code": ["<?php\n/**\n * Class Hotlinking_Controller\n *\n * @link      https://github.com/googleforcreators/web-stories-wp\n *\n * @copyright 2021 Google LLC\n * @license   https://www.apache.org/licenses/LICENSE-2.0 Apache License 2.0\n */\n\n/**\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nnamespace Google\\Web_Stories\\REST_API;\n\nuse Google\\Web_Stories\\Infrastructure\\HasRequirements;\nuse Google\\Web_Stories\\Media\\Types;\nuse Google\\Web_Stories\\Story_Post_Type;\nuse WP_Error;\nuse WP_Http;\nuse WP_REST_Request;\nuse WP_REST_Response;\nuse WP_REST_Server;\n\n/**\n * Hotlinking_Controller class.\n *\n * API endpoint for pinging and hotlinking media URLs.\n *\n * @SuppressWarnings(PHPMD.ExcessiveClassComplexity)\n *\n * @phpstan-type LinkData array{\n *   ext?: string,\n *   file_name?: string,\n *   file_size?: int,\n *   mime_type?: string,\n *   type?: string\n * }\n *\n * @phpstan-type SchemaEntry array{\n *   description: string,\n *   type: string,\n *   context: string[],\n *   default?: mixed,\n * }\n *\n * @phpstan-type Schema array{\n *   properties: array{\n *     ext?: SchemaEntry,\n *     file_name?: SchemaEntry,\n *     file_size?: SchemaEntry,\n *     mime_type?: SchemaEntry,\n *     type?: SchemaEntry\n *   }\n * }\n * @phpstan-type URLParts array{\n *   scheme?: string,\n *   user?: string,\n *   pass?: string,\n *   host?: string,\n *   port?: int,\n *   path?: string,\n *   query?: string\n * }\n */\nclass Hotlinking_Controller extends REST_Controller implements HasRequirements {\n\tpublic const PROXY_HEADERS_ALLOWLIST = [\n\t\t'Content-Type',\n\t\t'Cache-Control',\n\t\t'Etag',\n\t\t'Last-Modified',\n\t\t'Content-Range',\n\t];\n\n\t/**\n\t * Story_Post_Type instance.\n\t *\n\t * @var Story_Post_Type Story_Post_Type instance.\n\t */\n\tprivate $story_post_type;\n\n\t/**\n\t * Types instance.\n\t *\n\t * @var Types Types instance.\n\t */\n\tprivate $types;\n\n\t/**\n\t * File pointer resource.\n\t *\n\t * @var resource\n\t */\n\tprotected $stream_handle;\n\n\t/**\n\t * Constructor.\n\t *\n\t * @param Story_Post_Type $story_post_type Story_Post_Type instance.\n\t * @param Types           $types Types instance.\n\t * @return void\n\t */\n\tpublic function __construct( Story_Post_Type $story_post_type, Types $types ) {\n\t\t$this->story_post_type = $story_post_type;\n\t\t$this->types           = $types;\n\n\t\t$this->namespace = 'web-stories/v1';\n\t\t$this->rest_base = 'hotlink';\n\t}\n\n\t/**\n\t * Get the list of service IDs required for this service to be registered.\n\t *\n\t * Needed because the story post type needs to be registered first.\n\t *\n\t * @since 1.13.0\n\t *\n\t * @return string[] List of required services.\n\t */\n\tpublic static function get_requirements(): array {\n\t\treturn [ 'story_post_type' ];\n\t}\n\n\t/**\n\t * Registers routes for urls.\n\t *\n\t * @since 1.11.0\n\t *\n\t * @see register_rest_route()\n\t */\n\tpublic function register_routes(): void {\n\t\tregister_rest_route(\n\t\t\t$this->namespace,\n\t\t\t'/' . $this->rest_base . '/validate',\n\t\t\t[\n\t\t\t\t[\n\t\t\t\t\t'methods'             => WP_REST_Server::READABLE,\n\t\t\t\t\t'callback'            => [ $this, 'parse_url' ],\n\t\t\t\t\t'permission_callback' => [ $this, 'parse_url_permissions_check' ],\n\t\t\t\t\t'args'                => [\n\t\t\t\t\t\t'url' => [\n\t\t\t\t\t\t\t'description'       => __( 'The URL to process.', 'web-stories' ),\n\t\t\t\t\t\t\t'required'          => true,\n\t\t\t\t\t\t\t'type'              => 'string',\n\t\t\t\t\t\t\t'format'            => 'uri',\n\t\t\t\t\t\t\t'validate_callback' => [ $this, 'validate_callback' ],\n\t\t\t\t\t\t\t'sanitize_callback' => 'esc_url_raw',\n\t\t\t\t\t\t],\n\t\t\t\t\t],\n\t\t\t\t],\n\t\t\t]\n\t\t);\n\n\t\tregister_rest_route(\n\t\t\t$this->namespace,\n\t\t\t'/' . $this->rest_base . '/proxy',\n\t\t\t[\n\t\t\t\t[\n\t\t\t\t\t'methods'             => WP_REST_Server::READABLE,\n\t\t\t\t\t'callback'            => [ $this, 'proxy_url' ],\n\t\t\t\t\t'permission_callback' => [ $this, 'parse_url_permissions_check' ],\n\t\t\t\t\t'args'                => [\n\t\t\t\t\t\t'url' => [\n\t\t\t\t\t\t\t'description'       => __( 'The URL to process.', 'web-stories' ),\n\t\t\t\t\t\t\t'required'          => true,\n\t\t\t\t\t\t\t'type'              => 'string',\n\t\t\t\t\t\t\t'format'            => 'uri',\n\t\t\t\t\t\t\t'validate_callback' => [ $this, 'validate_callback' ],\n\t\t\t\t\t\t\t'sanitize_callback' => 'esc_url_raw',\n\t\t\t\t\t\t],\n\t\t\t\t\t],\n\t\t\t\t],\n\t\t\t]\n\t\t);\n\t}\n\n\t/**\n\t * Parses a URL to return some metadata for inserting external media.\n\t *\n\t * @SuppressWarnings(PHPMD.NPathComplexity)\n\t * @SuppressWarnings(PHPMD.ExcessiveMethodLength)\n\t *\n\t * @since 1.11.0\n\t *\n\t * @param WP_REST_Request $request Full data about the request.\n\t * @return WP_REST_Response|WP_Error Response object on success, or WP_Error object on failure.\n\t */\n\tpublic function parse_url( WP_REST_Request $request ) {\n\t\t/**\n\t\t * Requested URL.\n\t\t *\n\t\t * @var string $raw_url\n\t\t */\n\t\t$raw_url = $request['url'];\n\t\t$raw_url = untrailingslashit( $raw_url );\n\n\t\t$url_or_ip = $this->validate_url( $raw_url );\n\n\t\t$host = wp_parse_url( $raw_url, PHP_URL_HOST );\n\n\t\tif ( ! $url_or_ip || ! $host ) {\n\t\t\treturn new WP_Error( 'rest_invalid_url', __( 'Invalid URL', 'web-stories' ), [ 'status' => 400 ] );\n\t\t}\n\n\t\t/**\n\t\t * Filters the hotlinking data TTL value.\n\t\t *\n\t\t * @since 1.11.0\n\t\t *\n\t\t * @param int    $time Time to live (in seconds). Default is 1 day.\n\t\t * @param string $url  The attempted URL.\n\t\t */\n\t\t$cache_ttl = apply_filters( 'web_stories_hotlinking_url_data_cache_ttl', DAY_IN_SECONDS, $raw_url );\n\t\t$cache_key = 'web_stories_url_data_' . md5( $raw_url );\n\n\t\t$data = get_transient( $cache_key );\n\t\tif ( \\is_string( $data ) && ! empty( $data ) ) {\n\t\t\t/**\n\t\t\t * Decoded cached link data.\n\t\t\t *\n\t\t\t * @var array|null $link\n\t\t\t * @phpstan-var LinkData|null $link\n\t\t\t */\n\t\t\t$link = json_decode( $data, true );\n\n\t\t\tif ( $link ) {\n\t\t\t\t$response = $this->prepare_item_for_response( $link, $request );\n\t\t\t\treturn rest_ensure_response( $response );\n\t\t\t}\n\t\t}\n\n\t\t$callback = $this->get_curl_resolve_callback( $raw_url, $url_or_ip );\n\t\tadd_action( 'http_api_curl', $callback );\n\n\t\t$response = wp_safe_remote_head(\n\t\t\t$raw_url,\n\t\t\t[\n\t\t\t\t'redirection' => 0, // No redirects allowed.\n\t\t\t\t'headers'     => [\n\t\t\t\t\t'Host' => $host,\n\t\t\t\t],\n\t\t\t]\n\t\t);\n\n\t\tremove_action( 'http_api_curl', $callback );\n\n\t\tif ( is_wp_error( $response ) && 'http_request_failed' === $response->get_error_code() ) {\n\t\t\treturn new WP_Error( 'rest_invalid_url', __( 'Invalid URL', 'web-stories' ), [ 'status' => 404 ] );\n\t\t}\n\n\t\tif ( WP_Http::OK !== wp_remote_retrieve_response_code( $response ) ) {\n\t\t\treturn new WP_Error( 'rest_invalid_url', __( 'Invalid URL', 'web-stories' ), [ 'status' => 404 ] );\n\t\t}\n\n\t\t$headers   = wp_remote_retrieve_headers( $response );\n\t\t$mime_type = $headers['content-type'];\n\t\tif ( $mime_type && false !== strpos( $mime_type, ';' ) ) {\n\t\t\t$pieces    = explode( ';', $mime_type );\n\t\t\t$mime_type = array_shift( $pieces );\n\t\t}\n\t\t$file_size = (int) $headers['content-length'];\n\n\t\t$path = wp_parse_url( $raw_url, PHP_URL_PATH );\n\n\t\tif ( ! \\is_string( $path ) ) {\n\t\t\treturn new WP_Error( 'rest_invalid_url', __( 'Invalid URL', 'web-stories' ), [ 'status' => 404 ] );\n\t\t}\n\n\t\t$file_name = basename( $path );\n\n\t\t$exts = $this->types->get_file_type_exts( [ $mime_type ] );\n\t\t$ext  = '';\n\t\tif ( $exts ) {\n\t\t\t$ext = end( $exts );\n\t\t}\n\n\t\t$allowed_mime_types = $this->get_allowed_mime_types();\n\t\t$type               = '';\n\t\tforeach ( $allowed_mime_types as $key => $mime_types ) {\n\t\t\tif ( \\in_array( $mime_type, $mime_types, true ) ) {\n\t\t\t\t$type = $key;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t$data = [\n\t\t\t'ext'       => $ext,\n\t\t\t'file_name' => $file_name,\n\t\t\t'file_size' => $file_size,\n\t\t\t'mime_type' => $mime_type,\n\t\t\t'type'      => $type,\n\t\t];\n\n\t\tset_transient( $cache_key, wp_json_encode( $data ), $cache_ttl );\n\n\t\t$response = $this->prepare_item_for_response( $data, $request );\n\n\t\treturn rest_ensure_response( $response );\n\t}\n\n\t/**\n\t * Parses a URL to return proxied file.\n\t *\n\t * @SuppressWarnings(PHPMD.ErrorControlOperator)\n\t *\n\t * @since 1.13.0\n\t *\n\t * @param WP_REST_Request $request Full data about the request.\n\t * @return WP_Error|void Proxied data on success, error otherwise.\n\t */\n\tpublic function proxy_url( WP_REST_Request $request ) {\n\t\t/**\n\t\t * Requested URL.\n\t\t *\n\t\t * @var string $raw_url\n\t\t */\n\t\t$raw_url = $request['url'];\n\t\t$raw_url = untrailingslashit( $raw_url );\n\n\t\t$url_or_ip = $this->validate_url( $raw_url );\n\n\t\t$host = wp_parse_url( $raw_url, PHP_URL_HOST );\n\n\t\tif ( ! $url_or_ip || ! $host ) {\n\t\t\treturn new WP_Error( 'rest_invalid_url', __( 'Invalid URL', 'web-stories' ), [ 'status' => 400 ] );\n\t\t}\n\n\t\t// Remove any relevant headers already set by WP_REST_Server::serve_request() // wp_get_nocache_headers().\n\t\tif ( ! headers_sent() ) {\n\t\t\theader_remove( 'Cache-Control' );\n\t\t\theader_remove( 'Content-Type' );\n\t\t\theader_remove( 'Expires' );\n\t\t\theader_remove( 'Last Modified' );\n\t\t}\n\n\t\theader( 'Cache-Control: max-age=3600' );\n\t\theader( 'Accept-Ranges: bytes' );\n\n\t\t$args = [\n\t\t\t'timeout'     => 60, // phpcs:ignore WordPressVIPMinimum.Performance.RemoteRequestTimeout.timeout_timeout\n\t\t\t'blocking'    => false,\n\t\t\t'headers'     => [\n\t\t\t\t'Range' => $request->get_header( 'Range' ),\n\t\t\t\t'Host'  => $host,\n\t\t\t],\n\t\t\t'redirection' => 0, // No redirects allowed.\n\t\t];\n\n\t\t$callback = $this->get_curl_resolve_callback( $raw_url, $url_or_ip );\n\t\tadd_action( 'http_api_curl', $callback );\n\n\t\t$http      = _wp_http_get_object();\n\t\t$transport = $http->_get_first_available_transport( $args, $raw_url );\n\n\t\t// When cURL is available, we might be able to use it together with fopen().\n\t\tif ( 'WP_Http_Curl' === $transport ) {\n\t\t\t// php://temp is a read-write streams that allows temporary data to be stored in a file-like wrapper.\n\t\t\t// Other than php://memory, php://temp will use a temporary file once the amount of data stored hits a predefined limit (the default is 2 MB).\n\t\t\t// The location of this temporary file is determined in the same way as the {@see sys_get_temp_dir()} function.\n\t\t\tif ( WP_DEBUG ) {\n\t\t\t\t$stream_handle = fopen( 'php://memory', 'wb' ); // phpcs:ignore WordPress.WP.AlternativeFunctions.file_system_read_fopen\n\t\t\t} else {\n\t\t\t\t$stream_handle = @fopen( 'php://memory', 'wb' ); // phpcs:ignore WordPress.WP.AlternativeFunctions.file_system_read_fopen, WordPress.PHP.NoSilencedErrors.Discouraged, Generic.PHP.NoSilencedErrors.Forbidden\n\t\t\t}\n\n\t\t\tif ( $stream_handle ) {\n\t\t\t\t$this->stream_handle = $stream_handle;\n\t\t\t\t$this->proxy_url_curl( $raw_url, $args );\n\t\t\t\texit;\n\t\t\t}\n\t\t}\n\n\t\t// If either cURL is not available or fopen() did not succeed,\n\t\t// fall back to using whatever else is set up on the site,\n\t\t// presumably WP_Http_Streams or still WP_Http_Curl but without streams.\n\t\tunset( $args['blocking'] );\n\t\t$this->proxy_url_fallback( $raw_url, $args );\n\n\t\texit;\n\t}\n\n\t/**\n\t * Proxy a given URL via a PHP read-write stream.\n\t *\n\t * @since 1.15.0\n\t *\n\t * @param string               $url  Request URL.\n\t * @param array<string, mixed> $args Request args.\n\t */\n\tprivate function proxy_url_curl( string $url, array $args ): void {\n\t\tadd_action( 'http_api_curl', [ $this, 'modify_curl_configuration' ] );\n\t\twp_safe_remote_get( $url, $args );\n\t\tremove_action( 'http_api_curl', [ $this, 'modify_curl_configuration' ] );\n\n\t\trewind( $this->stream_handle );\n\t\twhile ( ! feof( $this->stream_handle ) ) {\n\t\t\techo fread( $this->stream_handle, 1024 * 1024 ); // phpcs:ignore WordPress.Security.EscapeOutput.OutputNotEscaped, WordPress.WP.AlternativeFunctions.file_system_read_fread\n\t\t}\n\n\t\tfclose( $this->stream_handle );\n\t}\n\n\t/**\n\t * Proxy a given URL by storing in memory.\n\t *\n\t * @since 1.15.0\n\t *\n\t * @param string               $url  Request URL.\n\t * @param array<string, mixed> $args Request args.\n\t */\n\tprivate function proxy_url_fallback( string $url, array $args ): void {\n\t\t$response = wp_safe_remote_get( $url, $args );\n\t\t$status   = wp_remote_retrieve_response_code( $response );\n\n\t\tif ( ! $status ) {\n\t\t\thttp_response_code( 404 );\n\t\t\treturn;\n\t\t}\n\n\t\thttp_response_code( (int) $status );\n\n\t\t$headers = wp_remote_retrieve_headers( $response );\n\n\t\tforeach ( self::PROXY_HEADERS_ALLOWLIST as $_header ) {\n\t\t\tif ( isset( $headers[ $_header ] ) ) {\n\t\t\t\theader( $_header . ': ' . $headers[ $_header ] );\n\t\t\t}\n\t\t}\n\n\t\techo wp_remote_retrieve_body( $response ); // phpcs:ignore WordPress.Security.EscapeOutput.OutputNotEscaped\n\t}\n\n\t/**\n\t * Prepares response asset response.\n\t *\n\t * @since 1.11.0\n\t *\n\t * @param LinkData|false  $link    URL data value, default to false is not set.\n\t * @param WP_REST_Request $request Request object.\n\t * @return WP_REST_Response|WP_Error Response object.\n\t *\n\t * @phpstan-param LinkData $link\n\t */\n\tpublic function prepare_item_for_response( $link, $request ) {\n\t\t$fields = $this->get_fields_for_response( $request );\n\t\t$schema = $this->get_item_schema();\n\n\t\t$data = [];\n\n\t\t$error = new WP_Error();\n\t\tforeach ( $schema['properties'] as $field => $args ) {\n\t\t\tif ( ! isset( $link[ $field ] ) || ! rest_is_field_included( $field, $fields ) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t$check = rest_validate_value_from_schema( $link[ $field ], $args, $field );\n\t\t\tif ( is_wp_error( $check ) ) {\n\t\t\t\t$error->add( 'rest_invalid_' . $field, $check->get_error_message(), [ 'status' => 400 ] );\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t$data[ $field ] = rest_sanitize_value_from_schema( $link[ $field ], $args, $field );\n\t\t}\n\n\t\tif ( $error->get_error_codes() ) {\n\t\t\treturn $error;\n\t\t}\n\n\t\t/**\n\t\t * Request context.\n\t\t *\n\t\t * @var string $context\n\t\t */\n\t\t$context = ! empty( $request['context'] ) ? $request['context'] : 'view';\n\t\t$data    = $this->add_additional_fields_to_object( $data, $request );\n\t\t$data    = $this->filter_response_by_context( $data, $context );\n\n\t\treturn rest_ensure_response( $data );\n\t}\n\n\t/**\n\t * Retrieves the link's schema, conforming to JSON Schema.\n\t *\n\t * @since 1.11.0\n\t *\n\t * @return array Item schema data.\n\t *\n\t * @phpstan-return Schema\n\t */\n\tpublic function get_item_schema(): array {\n\t\tif ( $this->schema ) {\n\t\t\t/**\n\t\t\t * Schema.\n\t\t\t *\n\t\t\t * @phpstan-var Schema $schema\n\t\t\t */\n\t\t\t$schema = $this->add_additional_fields_schema( $this->schema );\n\t\t\treturn $schema;\n\t\t}\n\n\t\t$allowed_mime_types = $this->get_allowed_mime_types();\n\t\t$types              = array_keys( $allowed_mime_types );\n\t\t$allowed_mime_types = array_merge( ...array_values( $allowed_mime_types ) );\n\t\t$exts               = $this->types->get_file_type_exts( $allowed_mime_types );\n\n\t\t$schema = [\n\t\t\t'$schema'    => 'http://json-schema.org/draft-04/schema#',\n\t\t\t'title'      => 'link',\n\t\t\t'type'       => 'object',\n\t\t\t'properties' => [\n\t\t\t\t'ext'       => [\n\t\t\t\t\t'description' => __( 'File extension', 'web-stories' ),\n\t\t\t\t\t'type'        => 'string',\n\t\t\t\t\t'context'     => [ 'view', 'edit', 'embed' ],\n\t\t\t\t\t'enum'        => $exts,\n\t\t\t\t],\n\t\t\t\t'file_name' => [\n\t\t\t\t\t'description' => __( 'File name', 'web-stories' ),\n\t\t\t\t\t'type'        => 'string',\n\t\t\t\t\t'context'     => [ 'view', 'edit', 'embed' ],\n\t\t\t\t],\n\t\t\t\t'file_size' => [\n\t\t\t\t\t'description' => __( 'File size', 'web-stories' ),\n\t\t\t\t\t'type'        => 'integer',\n\t\t\t\t\t'context'     => [ 'view', 'edit', 'embed' ],\n\t\t\t\t],\n\t\t\t\t'mime_type' => [\n\t\t\t\t\t'description' => __( 'Mime type', 'web-stories' ),\n\t\t\t\t\t'type'        => 'string',\n\t\t\t\t\t'context'     => [ 'view', 'edit', 'embed' ],\n\t\t\t\t\t'enum'        => $allowed_mime_types,\n\t\t\t\t],\n\t\t\t\t'type'      => [\n\t\t\t\t\t'description' => __( 'Type', 'web-stories' ),\n\t\t\t\t\t'type'        => 'string',\n\t\t\t\t\t'context'     => [ 'view', 'edit', 'embed' ],\n\t\t\t\t\t'enum'        => $types,\n\t\t\t\t],\n\t\t\t],\n\t\t];\n\n\t\t$this->schema = $schema;\n\n\t\t/**\n\t\t * Schema.\n\t\t *\n\t\t * @phpstan-var Schema $schema\n\t\t */\n\t\t$schema = $this->add_additional_fields_schema( $this->schema );\n\t\treturn $schema;\n\t}\n\n\t/**\n\t * Checks if current user can process urls.\n\t *\n\t * @since 1.11.0\n\t *\n\t * @return true|WP_Error True if the request has read access, WP_Error object otherwise.\n\t */\n\tpublic function parse_url_permissions_check() {\n\t\tif ( ! $this->story_post_type->has_cap( 'edit_posts' ) ) {\n\t\t\treturn new WP_Error(\n\t\t\t\t'rest_forbidden',\n\t\t\t\t__( 'Sorry, you are not allowed to insert external media.', 'web-stories' ),\n\t\t\t\t[ 'status' => rest_authorization_required_code() ]\n\t\t\t);\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Callback to validate urls.\n\t *\n\t * @since 1.11.0\n\t *\n\t * @param string $value Value to be validated.\n\t * @return true|WP_Error\n\t */\n\tpublic function validate_callback( $value ) {\n\t\t$url = untrailingslashit( $value );\n\n\t\tif ( empty( $url ) || ! $this->validate_url( $url ) ) {\n\t\t\treturn new WP_Error( 'rest_invalid_url', __( 'Invalid URL', 'web-stories' ), [ 'status' => 400 ] );\n\t\t}\n\n\t\t$path = wp_parse_url( $url, PHP_URL_PATH );\n\n\t\tif ( ! $path ) {\n\t\t\treturn new WP_Error( 'rest_invalid_url', __( 'Invalid URL', 'web-stories' ), [ 'status' => 400 ] );\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Validate a URL for safe use in the HTTP API.\n\t *\n\t * Like {@see wp_http_validate_url} in core, but with extra hardening\n\t * to avoid DNS rebinding issues.\n\t *\n\t * @SuppressWarnings(PHPMD.NPathComplexity)\n\t * @SuppressWarnings(PHPMD.CyclomaticComplexity)\n\t *\n\t * @since 1.22.0\n\t *\n\t * @param string $url Request URL.\n\t * @return string|false Original URL, resolved IP address, or false on failure.\n\t */\n\tprivate function validate_url( string $url ) {\n\t\tif ( '' === $url || is_numeric( $url ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t$original_url = $url;\n\t\t$url          = wp_kses_bad_protocol( $url, [ 'http', 'https' ] );\n\t\tif ( ! $url || strtolower( $url ) !== strtolower( $original_url ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t$parsed_url = wp_parse_url( $url );\n\t\tif ( ! $parsed_url || ! isset( $parsed_url['host'], $parsed_url['scheme'] ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( isset( $parsed_url['user'] ) || isset( $parsed_url['pass'] ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( false !== strpbrk( $parsed_url['host'], ':#?[]' ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t/**\n\t\t * Home URL.\n\t\t *\n\t\t * @var string\n\t\t */\n\t\t$home_url = get_option( 'home' );\n\n\t\t$parsed_home = wp_parse_url( $home_url );\n\n\t\tif ( ! $parsed_home ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t$same_host = isset( $parsed_home['host'] ) && strtolower( $parsed_home['host'] ) === strtolower( $parsed_url['host'] );\n\t\t$host      = trim( $parsed_url['host'], '.' );\n\n\t\t$validated_url = $url;\n\n\t\tif ( ! $same_host ) {\n\t\t\tif ( preg_match( '#^(([1-9]?\\d|1\\d\\d|25[0-5]|2[0-4]\\d)\\.){3}([1-9]?\\d|1\\d\\d|25[0-5]|2[0-4]\\d)$#', $host ) ) {\n\t\t\t\t$ip = $host;\n\t\t\t} else {\n\t\t\t\t$ip = gethostbyname( $host );\n\t\t\t\tif ( $ip === $host ) { // Error condition for gethostbyname().\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t$parts = array_map( 'intval', explode( '.', $ip ) );\n\t\t\tif (\n\t\t\t\t0 === $parts[0] // 0.0.0.0/8.\n\t\t\t\t||\n\t\t\t\t127 === $parts[0] // 127.0.0.0/8.\n\t\t\t\t||\n\t\t\t\t10 === $parts[0] // 10.0.0.0/8.\n\t\t\t\t||\n\t\t\t\t( 172 === $parts[0] && 16 <= $parts[1] && 31 >= $parts[1] ) // 172.16.0.0/12.\n\t\t\t\t||\n\t\t\t\t( 192 === $parts[0] && 168 === $parts[1] ) // 192.168.0.0/16.\n\t\t\t\t||\n\t\t\t\t( 169 === $parts[0] && 254 === $parts[1] ) // 169.254.0.0/16.\n\t\t\t\t||\n\t\t\t\t// phpcs:ignore Squiz.PHP.CommentedOutCode.Found\n\t\t\t\t( 100 === $parts[0] && 64 <= $parts[1] && 127 >= $parts[1] ) // Private: 100.64.0.0/10.\n\t\t\t) {\n\t\t\t\t// If host appears local, reject.\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// Use resolved IP address to avoid DNS rebinding issues.\n\t\t\t$validated_url = $ip;\n\t\t}\n\n\t\t/** This filter is documented in wp-includes/http.php */\n\t\t$allowed_ports = apply_filters( 'http_allowed_safe_ports', [ 80, 443, 8080 ], $host, $url );\n\t\tif (\n\t\t\t! isset( $parsed_url['port'] ) ||\n\t\t\t( \\is_array( $allowed_ports ) && \\in_array( $parsed_url['port'], $allowed_ports, true ) )\n\t\t) {\n\t\t\treturn $validated_url;\n\t\t}\n\n\t\tif ( $same_host && isset( $parsed_home['port'] ) && $parsed_home['port'] === $parsed_url['port'] ) {\n\t\t\treturn $validated_url;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Returns a callback to modify the cURL configuration before the request is executed.\n\t *\n\t * @since 1.22.1\n\t *\n\t * @param string $url       URL.\n\t * @param string $url_or_ip URL or IP address.\n\t */\n\tpublic function get_curl_resolve_callback( string $url, string $url_or_ip ): callable {\n\t\t/**\n\t\t * CURL configuration callback.\n\t\t *\n\t\t * @param resource $handle The cURL handle returned by curl_init() (passed by reference).\n\t\t */\n\t\treturn static function( $handle ) use ( $url, $url_or_ip ): void {\n\t\t\t// Just some safeguard in case cURL is not really available,\n\t\t\t// despite this method being run in the context of WP_Http_Curl.\n\t\t\tif ( ! function_exists( 'curl_setopt' ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( $url === $url_or_ip ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t$host   = wp_parse_url( $url, PHP_URL_HOST );\n\t\t\t$scheme = wp_parse_url( $url, PHP_URL_SCHEME ) ?? 'http';\n\t\t\t$port   = wp_parse_url( $url, PHP_URL_PORT ) ?? 'http' === $scheme ? 80 : 443;\n\n\t\t\t// phpcs:disable WordPress.WP.AlternativeFunctions.curl_curl_setopt\n\n\t\t\tcurl_setopt(\n\t\t\t\t$handle,\n\t\t\t\tCURLOPT_RESOLVE,\n\t\t\t\t[\n\t\t\t\t\t\"$host:$port:$url_or_ip\",\n\t\t\t\t]\n\t\t\t);\n\n\t\t\t// phpcs:enable WordPress.WP.AlternativeFunctions.curl_curl_setopt\n\t\t};\n\t}\n\n\t/**\n\t * Modifies the cURL configuration before the request is executed.\n\t *\n\t * @since 1.15.0\n\t *\n\t * @param resource $handle The cURL handle returned by {@see curl_init()} (passed by reference).\n\t */\n\tpublic function modify_curl_configuration( $handle ): void {\n\t\t// Just some safeguard in case cURL is not really available,\n\t\t// despite this method being run in the context of WP_Http_Curl.\n\t\tif ( ! function_exists( 'curl_setopt' ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// phpcs:disable WordPress.WP.AlternativeFunctions.curl_curl_setopt\n\n\t\tcurl_setopt(\n\t\t\t$handle,\n\t\t\tCURLOPT_FILE,\n\t\t\t$this->stream_handle\n\t\t);\n\n\t\tcurl_setopt( $handle, CURLOPT_HEADERFUNCTION, [ $this, 'stream_headers' ] );\n\n\t\t// phpcs:enable WordPress.WP.AlternativeFunctions.curl_curl_setopt\n\t}\n\n\t/**\n\t * Grabs the headers of the cURL request.\n\t *\n\t * Each header is sent individually to this callback,\n\t * so we take a look at each one to see if we should \"forward\" it.\n\t *\n\t * @since 1.15.0\n\t *\n\t * @param resource $handle  cURL handle.\n\t * @param string   $header cURL header.\n\t * @return int Header length.\n\t */\n\tpublic function stream_headers( $handle, $header ): int {\n\t\t// Parse Status-Line, the first component in the HTTP response, e.g. HTTP/1.1 200 OK.\n\t\t// Extract the status code to re-send that here.\n\t\tif ( 0 === strpos( $header, 'HTTP/' ) ) {\n\t\t\t$status = explode( ' ', $header );\n\t\t\thttp_response_code( (int) $status[1] );\n\t\t\treturn \\strlen( $header );\n\t\t}\n\n\t\tforeach ( self::PROXY_HEADERS_ALLOWLIST as $_header ) {\n\t\t\tif ( 0 === stripos( $header, strtolower( $_header ) . ': ' ) ) {\n\t\t\t\theader( $header, true );\n\t\t\t}\n\t\t}\n\n\t\treturn \\strlen( $header );\n\t}\n\n\t/**\n\t * Returns a list of allowed mime types per media type (image, audio, video).\n\t *\n\t * @since 1.19.0\n\t *\n\t * @return array<string, string[]> List of allowed mime types.\n\t */\n\tprotected function get_allowed_mime_types(): array {\n\t\t$mime_type = $this->types->get_allowed_mime_types();\n\n\t\t// Do not support hotlinking SVGs for security reasons.\n\t\tunset( $mime_type['vector'] );\n\n\t\treturn $mime_type;\n\t}\n}\n", "<?php\n/**\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nnamespace Google\\Web_Stories\\Tests\\Integration\\REST_API;\n\nuse Google\\Web_Stories\\Tests\\Integration\\DependencyInjectedRestTestCase;\nuse WP_Error;\nuse WP_REST_Request;\nuse WP_REST_Server;\n\n/**\n * Class Hotlinking_Controller\n *\n * @coversDefaultClass \\Google\\Web_Stories\\REST_API\\Hotlinking_Controller\n */\nclass Hotlinking_Controller extends DependencyInjectedRestTestCase {\n\tprotected static $subscriber;\n\tprotected static $editor;\n\n\tpublic const URL_INVALID      = 'https://https://invalid.commmm';\n\tpublic const URL_404          = 'https://example.com/404/test.jpg';\n\tpublic const URL_500          = 'https://example.com/500/test.jpg';\n\tpublic const URL_SVG          = 'https://example.com/test.svg';\n\tpublic const URL_VALID        = 'http://example.com/test.jpg';\n\tpublic const URL_DOMAIN       = 'http://google.com';\n\tpublic const URL_WITH_CHARSET = 'https://example.com/test.png';\n\tpublic const URL_PATH         = '/test.jpg';\n\n\tpublic const REST_URL = '/web-stories/v1/hotlink/validate';\n\n\t/**\n\t * Count of the number of requests attempted.\n\t *\n\t * @var int\n\t */\n\tprotected $request_count = 0;\n\n\t/**\n\t * Test instance.\n\t *\n\t * @var \\Google\\Web_Stories\\REST_API\\Hotlinking_Controller\n\t */\n\tprivate $controller;\n\n\tpublic static function wpSetUpBeforeClass( $factory ): void {\n\t\tself::$subscriber = $factory->user->create(\n\t\t\t[\n\t\t\t\t'role' => 'subscriber',\n\t\t\t]\n\t\t);\n\t\tself::$editor     = $factory->user->create(\n\t\t\t[\n\t\t\t\t'role'       => 'editor',\n\t\t\t\t'user_email' => 'editor@example.com',\n\t\t\t]\n\t\t);\n\t}\n\n\tpublic function set_up(): void {\n\t\tparent::set_up();\n\n\t\tadd_filter( 'pre_http_request', [ $this, 'mock_http_request' ], 10, 3 );\n\t\t$this->request_count = 0;\n\n\t\t$this->controller = $this->injector->make( \\Google\\Web_Stories\\REST_API\\Hotlinking_Controller::class );\n\t}\n\n\tpublic function tear_down(): void {\n\t\tremove_filter( 'pre_http_request', [ $this, 'mock_http_request' ] );\n\n\t\tparent::tear_down();\n\t}\n\n\t/**\n\t * Intercept link processing requests and mock responses.\n\t *\n\t * @param mixed  $preempt Whether to preempt an HTTP request's return value. Default false.\n\t * @param mixed  $r       HTTP request arguments.\n\t * @param string $url     The request URL.\n\t * @return array|WP_Error Response data.\n\t */\n\tpublic function mock_http_request( $preempt, $r, string $url ) {\n\t\t++ $this->request_count;\n\n\t\tif ( false !== strpos( $url, self::URL_INVALID ) ) {\n\t\t\treturn $preempt;\n\t\t}\n\n\t\t// URL_VALID\n\t\tif ( self::URL_VALID === $url ) {\n\t\t\treturn [\n\t\t\t\t'headers'  => [\n\t\t\t\t\t'content-type'   => 'image/jpeg',\n\t\t\t\t\t'content-length' => 5000,\n\t\t\t\t],\n\t\t\t\t'response' => [ 'code' => 200 ],\n\t\t\t];\n\t\t}\n\n\t\tif ( self::URL_SVG === $url ) {\n\t\t\treturn [\n\t\t\t\t'headers'  => [\n\t\t\t\t\t'content-type'   => 'image/svg+xml',\n\t\t\t\t\t'content-length' => 5000,\n\t\t\t\t],\n\t\t\t\t'response' => [ 'code' => 200 ],\n\t\t\t];\n\t\t}\n\n\t\tif ( self::URL_WITH_CHARSET === $url ) {\n\t\t\treturn [\n\t\t\t\t'headers'  => [\n\t\t\t\t\t'content-type'   => 'image/png; charset=utf-8',\n\t\t\t\t\t'content-length' => 1000,\n\t\t\t\t],\n\t\t\t\t'response' => [ 'code' => 200 ],\n\t\t\t];\n\t\t}\n\n\t\tif ( self::URL_404 === $url ) {\n\t\t\treturn [\n\t\t\t\t'headers'  => [\n\t\t\t\t\t'content-type'   => 'image/jpeg',\n\t\t\t\t\t'content-length' => 5000,\n\t\t\t\t],\n\t\t\t\t'response' => [ 'code' => 404 ],\n\t\t\t];\n\t\t}\n\n\t\t// URL_500\n\t\tif ( 'https://93.184.216.34.com/500/test.jpg' === $url ) {\n\t\t\treturn [\n\t\t\t\t'headers'  => [\n\t\t\t\t\t'content-type'   => 'image/jpeg',\n\t\t\t\t\t'content-length' => 5000,\n\t\t\t\t],\n\t\t\t\t'response' => [ 'code' => 500 ],\n\t\t\t];\n\t\t}\n\n\t\treturn $preempt;\n\t}\n\n\t/**\n\t * @covers ::register\n\t */\n\tpublic function test_register(): void {\n\t\t$this->controller->register();\n\n\t\t$routes = rest_get_server()->get_routes();\n\n\t\t$this->assertArrayHasKey( self::REST_URL, $routes );\n\t}\n\n\t/**\n\t * @covers ::validate_callback\n\t */\n\tpublic function test_validate_url(): void {\n\t\t$result = $this->controller->validate_callback( self::URL_VALID );\n\t\t$this->assertTrue( $result );\n\t}\n\n\t/**\n\t * @covers ::validate_callback\n\t */\n\tpublic function test_validate_url_empty(): void {\n\t\t$result = $this->controller->validate_callback( '' );\n\t\t$this->assertErrorResponse( 'rest_invalid_url', $result, 400 );\n\t}\n\n\t/**\n\t * @covers ::validate_callback\n\t */\n\tpublic function test_validate_url_domain(): void {\n\t\t$result = $this->controller->validate_callback( self::URL_DOMAIN );\n\t\t$this->assertErrorResponse( 'rest_invalid_url', $result, 400 );\n\t}\n\n\t/**\n\t * @covers ::validate_callback\n\t */\n\tpublic function test_validate_url_path(): void {\n\t\t$result = $this->controller->validate_callback( self::URL_PATH );\n\t\t$this->assertErrorResponse( 'rest_invalid_url', $result, 400 );\n\t}\n\n\t/**\n\t * @covers ::validate_callback\n\t */\n\tpublic function test_validate_url_invalid(): void {\n\t\t$result = $this->controller->validate_callback( '-1' );\n\t\t$this->assertErrorResponse( 'rest_invalid_url', $result, 400 );\n\t}\n\n\t/**\n\t * @covers ::validate_callback\n\t */\n\tpublic function test_validate_url_invalid2(): void {\n\t\t$result = $this->controller->validate_callback( 'wibble' );\n\t\t$this->assertErrorResponse( 'rest_invalid_url', $result, 400 );\n\t}\n\n\t/**\n\t * @covers ::get_item_schema\n\t */\n\tpublic function test_get_item_schema(): void {\n\t\t$data = $this->controller->get_item_schema();\n\n\t\t$properties = $data['properties'];\n\t\t$this->assertArrayHasKey( 'ext', $properties );\n\t\t$this->assertArrayHasKey( 'file_name', $properties );\n\t\t$this->assertArrayHasKey( 'file_size', $properties );\n\t\t$this->assertArrayHasKey( 'mime_type', $properties );\n\t\t$this->assertArrayHasKey( 'type', $properties );\n\t\t$this->assertArrayHasKey( 'enum', $properties['type'] );\n\t\t$this->assertEqualSets( [ 'audio', 'image', 'video', 'caption' ], $properties['type']['enum'] );\n\t}\n\n\t/**\n\t * @covers ::parse_url\n\t * @covers ::parse_url_permissions_check\n\t */\n\tpublic function test_parse_url_without_permission(): void {\n\t\t$this->controller->register();\n\n\t\t// Test without a login.\n\t\t$request = new WP_REST_Request( WP_REST_Server::READABLE, self::REST_URL );\n\t\t$request->set_param( 'url', self::URL_VALID );\n\t\t$response = rest_get_server()->dispatch( $request );\n\n\t\t$this->assertEquals( 401, $response->get_status() );\n\n\t\t// Test with a user that does not have edit_posts capability.\n\t\twp_set_current_user( self::$subscriber );\n\t\t$request = new WP_REST_Request( WP_REST_Server::READABLE, self::REST_URL );\n\t\t$request->set_param( 'url', self::URL_VALID );\n\t\t$response = rest_get_server()->dispatch( $request );\n\n\t\t$this->assertEquals( 403, $response->get_status() );\n\t\t$data = $response->get_data();\n\t\t$this->assertEquals( 'rest_forbidden', $data['code'] );\n\t}\n\n\tpublic function test_url_invalid_url(): void {\n\t\t$this->controller->register();\n\n\t\twp_set_current_user( self::$editor );\n\t\t$request = new WP_REST_Request( WP_REST_Server::READABLE, self::REST_URL );\n\t\t$request->set_param( 'url', self::URL_INVALID );\n\t\t$response = rest_get_server()->dispatch( $request );\n\t\t$data     = $response->get_data();\n\n\t\t$this->assertEquals( 0, $this->request_count );\n\t\t$this->assertEquals( 400, $response->get_status() );\n\t\t$this->assertEquals( 'rest_invalid_param', $data['code'] );\n\t}\n\n\t/**\n\t * @covers ::parse_url\n\t * @covers ::parse_url_permissions_check\n\t */\n\tpublic function test_parse_url_empty_string(): void {\n\t\t$this->controller->register();\n\n\t\twp_set_current_user( self::$editor );\n\t\t$request = new WP_REST_Request( WP_REST_Server::READABLE, self::REST_URL );\n\t\t$request->set_param( 'url', '' );\n\t\t$response = rest_get_server()->dispatch( $request );\n\t\t$data     = $response->get_data();\n\n\t\t$this->assertEquals( 0, $this->request_count );\n\t\t$this->assertTrue( $response->is_error() );\n\t\t$this->assertEquals( 400, $response->get_status() );\n\t\t$this->assertEquals( 'rest_invalid_param', $data['code'] );\n\t}\n\n\t/**\n\t * @covers ::parse_url\n\t * @covers ::parse_url_permissions_check\n\t */\n\tpublic function test_parse_url(): void {\n\t\t$this->controller->register();\n\n\t\twp_set_current_user( self::$editor );\n\t\t$request = new WP_REST_Request( WP_REST_Server::READABLE, self::REST_URL );\n\t\t$request->set_param( 'url', self::URL_VALID );\n\t\t$response = rest_get_server()->dispatch( $request );\n\t\t$data     = $response->get_data();\n\n\t\t$this->assertFalse( $response->is_error() );\n\t\t$this->assertEqualSets(\n\t\t\t[\n\t\t\t\t'ext'       => 'jpg',\n\t\t\t\t'file_name' => 'test.jpg',\n\t\t\t\t'file_size' => 5000,\n\t\t\t\t'mime_type' => 'image/jpeg',\n\t\t\t\t'type'      => 'image',\n\t\t\t],\n\t\t\t$data\n\t\t);\n\t}\n\n\t/**\n\t * @covers ::parse_url\n\t * @covers ::parse_url_permissions_check\n\t */\n\tpublic function test_parse_url_cache(): void {\n\t\t$this->controller->register();\n\n\t\twp_set_current_user( self::$editor );\n\t\t$request = new WP_REST_Request( WP_REST_Server::READABLE, self::REST_URL );\n\t\t$request->set_param( 'url', self::URL_VALID );\n\t\t$response = rest_get_server()->dispatch( $request );\n\n\t\t$this->assertFalse( $response->is_error() );\n\t\t$this->assertEquals( 1, $this->request_count );\n\n\t\t$data = $response->get_data();\n\t\t$this->assertEqualSets(\n\t\t\t[\n\t\t\t\t'ext'       => 'jpg',\n\t\t\t\t'file_name' => 'test.jpg',\n\t\t\t\t'file_size' => 5000,\n\t\t\t\t'mime_type' => 'image/jpeg',\n\t\t\t\t'type'      => 'image',\n\t\t\t],\n\t\t\t$data\n\t\t);\n\n\t\t$response = rest_get_server()->dispatch( $request );\n\n\t\t$this->assertFalse( $response->is_error() );\n\t\t$this->assertEquals( 1, $this->request_count );\n\n\t\t$data = $response->get_data();\n\t\t$this->assertEqualSets(\n\t\t\t[\n\t\t\t\t'ext'       => 'jpg',\n\t\t\t\t'file_name' => 'test.jpg',\n\t\t\t\t'file_size' => 5000,\n\t\t\t\t'mime_type' => 'image/jpeg',\n\t\t\t\t'type'      => 'image',\n\t\t\t],\n\t\t\t$data\n\t\t);\n\t}\n\n\t/**\n\t * @covers ::parse_url\n\t * @covers ::parse_url_permissions_check\n\t */\n\tpublic function test_parse_url_404(): void {\n\t\t$this->controller->register();\n\n\t\twp_set_current_user( self::$editor );\n\t\t$request = new WP_REST_Request( WP_REST_Server::READABLE, self::REST_URL );\n\t\t$request->set_param( 'url', self::URL_404 );\n\t\t$response = rest_get_server()->dispatch( $request );\n\t\t$this->assertErrorResponse( 'rest_invalid_url', $response, 404 );\n\t}\n\n\t/**\n\t * @covers ::parse_url\n\t * @covers ::parse_url_permissions_check\n\t */\n\tpublic function test_parse_url_500(): void {\n\t\t$this->controller->register();\n\n\t\twp_set_current_user( self::$editor );\n\t\t$request = new WP_REST_Request( WP_REST_Server::READABLE, self::REST_URL );\n\t\t$request->set_param( 'url', self::URL_500 );\n\t\t$response = rest_get_server()->dispatch( $request );\n\t\t$this->assertErrorResponse( 'rest_invalid_url', $response, 404 );\n\t}\n\n\n\t/**\n\t * @covers ::parse_url\n\t * @covers ::parse_url_permissions_check\n\t * @covers ::prepare_item_for_response\n\t */\n\tpublic function test_parse_url_svg(): void {\n\t\t$this->controller->register();\n\n\t\twp_set_current_user( self::$editor );\n\t\t$request = new WP_REST_Request( WP_REST_Server::READABLE, self::REST_URL );\n\t\t$request->set_param( 'url', self::URL_SVG );\n\t\t$response = rest_get_server()->dispatch( $request );\n\t\t$this->assertErrorResponse( 'rest_invalid_ext', $response, 400 );\n\t}\n\n\t/**\n\t * @covers ::parse_url\n\t * @covers ::parse_url_permissions_check\n\t */\n\tpublic function test_parse_url_with_charset_in_content_type_header(): void {\n\t\t$this->controller->register();\n\n\t\twp_set_current_user( self::$editor );\n\t\t$request = new WP_REST_Request( WP_REST_Server::READABLE, self::REST_URL );\n\t\t$request->set_param( 'url', self::URL_WITH_CHARSET );\n\t\t$response = rest_get_server()->dispatch( $request );\n\t\t$data     = $response->get_data();\n\n\t\t$this->assertFalse( $response->is_error() );\n\t\t$this->assertEqualSets(\n\t\t\t[\n\t\t\t\t'ext'       => 'png',\n\t\t\t\t'file_name' => 'test.png',\n\t\t\t\t'file_size' => 1000,\n\t\t\t\t'mime_type' => 'image/png',\n\t\t\t\t'type'      => 'image',\n\t\t\t],\n\t\t\t$data\n\t\t);\n\t}\n\n\t/**\n\t * @covers ::get_allowed_mime_types\n\t */\n\tpublic function test_get_allowed_mime_types(): void {\n\t\t$story_post_type = $this->injector->make( \\Google\\Web_Stories\\Story_Post_Type::class );\n\t\t$types           = $this->injector->make( \\Google\\Web_Stories\\Media\\Types::class );\n\t\t$experiments     = $this->createMock( \\Google\\Web_Stories\\Experiments::class );\n\t\t$experiments->method( 'is_experiment_enabled' )\n\t\t\t\t\t->willReturn( true );\n\t\t$controller = new \\Google\\Web_Stories\\REST_API\\Hotlinking_Controller( $story_post_type, $types, $experiments );\n\t\t$mime_types = $this->call_private_method( $controller, 'get_allowed_mime_types' );\n\t\t$this->assertArrayHasKey( 'audio', $mime_types );\n\t\t$this->assertArrayHasKey( 'video', $mime_types );\n\t\t$this->assertArrayHasKey( 'caption', $mime_types );\n\t\t$this->assertArrayHasKey( 'video', $mime_types );\n\t\t$this->assertSame( 'text/vtt', $mime_types['caption'][0] );\n\t}\n\n\t/**\n\t * Test that validate_url validates URLs.\n\t *\n\t * @param string       $url            The URL to validate.\n\t * @param string       $expected       Expected result.\n\t * @param false|string $cb_safe_ports  The name of the callback to http_allowed_safe_ports or false if none.\n\t *                                     Default false.\n\t *\n\t * @dataProvider data_validate_url_should_validate\n\t * @covers ::validate_url\n\t */\n\tpublic function test_validate_url_should_validate( string $url, string $expected, $cb_safe_ports = false ): void {\n\t\tif ( $cb_safe_ports ) {\n\t\t\tadd_filter( 'http_allowed_safe_ports', [ $this, $cb_safe_ports ] );\n\t\t}\n\n\t\t$this->assertSame( $expected, $this->call_private_method( $this->controller, 'validate_url', [ $url ] ) );\n\t}\n\n\t/**\n\t * Data provider.\n\t *\n\t * @return array\n\t */\n\tpublic function data_validate_url_should_validate(): array {\n\t\treturn [\n\t\t\t'no port specified'                 => [\n\t\t\t\t'url'      => 'http://example.com/caniload.php',\n\t\t\t\t'expected' => '93.184.216.34',\n\t\t\t],\n\t\t\t'a port considered safe by default' => [\n\t\t\t\t'url'      => 'https://example.com:8080/caniload.php',\n\t\t\t\t'expected' => '93.184.216.34',\n\t\t\t],\n\t\t\t'a port considered safe by filter'  => [\n\t\t\t\t'url'           => 'https://example.com:81/caniload.php',\n\t\t\t\t'expected'      => '93.184.216.34',\n\t\t\t\t'cb_safe_ports' => 'callback_custom_safe_ports',\n\t\t\t],\n\t\t];\n\t}\n\n\t/**\n\t * Tests that validate_url validates a url that uses an unsafe port\n\t * but which matches the host and port used by the site's home url.\n\t *\n\t * @covers ::validate_url\n\t */\n\tpublic function test_validate_url_should_validate_with_an_unsafe_port_when_the_host_and_port_match_the_home_url(): void {\n\t\t$original_home    = get_option( 'home' );\n\t\t$home_parsed      = wp_parse_url( $original_home );\n\t\t$home_scheme_host = implode( '://', \\array_slice( $home_parsed, 0, 2 ) );\n\t\t$home_modified    = $home_scheme_host . ':83';\n\n\t\tupdate_option( 'home', $home_modified );\n\n\t\t$url = $home_modified . '/caniload.php';\n\n\t\t$actual = $this->call_private_method( $this->controller, 'validate_url', [ $url ] );\n\n\t\tupdate_option( 'home', $original_home );\n\n\t\t$this->assertSame( $url, $actual );\n\t}\n\n\t/**\n\t * Test that validate_url does not validate invalid URLs.\n\t *\n\t * @param string       $url            The URL to validate.\n\t * @param false|string $cb_safe_ports  The name of the callback to http_allowed_safe_ports or false if none.\n\t *                                     Default false.\n\t * @param bool         $external_host  Whether or not the host is external.\n\t *                                     Default false.\n\t *\n\t * @dataProvider data_validate_url_should_not_validate\n\t * @covers ::validate_url\n\t */\n\tpublic function test_validate_url_should_not_validate( string $url, $cb_safe_ports = false, bool $external_host = false ): void {\n\t\tif ( $external_host ) {\n\t\t\tadd_filter( 'http_request_host_is_external', '__return_true' );\n\t\t}\n\n\t\tif ( $cb_safe_ports ) {\n\t\t\tadd_filter( 'http_allowed_safe_ports', [ $this, $cb_safe_ports ] );\n\t\t}\n\n\t\t$this->assertFalse( $this->call_private_method( $this->controller, 'validate_url', [ $url ] ) );\n\t}\n\n\t/**\n\t * Data provider.\n\t *\n\t * @return array\n\t */\n\tpublic function data_validate_url_should_not_validate(): array {\n\t\treturn [\n\t\t\t'url as string 0'                              => [\n\t\t\t\t'url' => '0',\n\t\t\t],\n\t\t\t'url as string 1'                              => [\n\t\t\t\t'url' => '1',\n\t\t\t],\n\t\t\t'an empty url'                                 => [\n\t\t\t\t'url' => '',\n\t\t\t],\n\t\t\t'a url with a non-http/https protocol'         => [\n\t\t\t\t'url' => 'ftp://example.com:81/caniload.php',\n\t\t\t],\n\t\t\t'a malformed url'                              => [\n\t\t\t\t'url' => 'http:///example.com:81/caniload.php',\n\t\t\t],\n\t\t\t'a host that cannot be parsed'                 => [\n\t\t\t\t'url' => 'http:example.com/caniload.php',\n\t\t\t],\n\t\t\t'login information'                            => [\n\t\t\t\t'url' => 'http://user:pass@example.com/caniload.php',\n\t\t\t],\n\t\t\t'a host with invalid characters'               => [\n\t\t\t\t'url' => 'http://[exam]ple.com/caniload.php',\n\t\t\t],\n\t\t\t'a host whose IPv4 address cannot be resolved' => [\n\t\t\t\t'url' => 'http://exampleeeee.com/caniload.php',\n\t\t\t],\n\t\t\t'an external request when not allowed'         => [\n\t\t\t\t'url' => 'http://192.168.0.1/caniload.php',\n\t\t\t],\n\t\t\t'a request with disallowed link-local ip'      => [\n\t\t\t\t'url' => 'http://169.254.0.0/caniload.php',\n\t\t\t],\n\t\t\t'a port not considered safe by default'        => [\n\t\t\t\t'url' => 'https://example.com:81/caniload.php',\n\t\t\t],\n\t\t\t'a port not considered safe by filter'         => [\n\t\t\t\t'url'           => 'https://example.com:82/caniload.php',\n\t\t\t\t'cb_safe_ports' => 'callback_custom_safe_ports',\n\t\t\t],\n\t\t\t'all safe ports removed by filter'             => [\n\t\t\t\t'url'           => 'https://example.com:81/caniload.php',\n\t\t\t\t'cb_safe_ports' => 'callback_remove_safe_ports',\n\t\t\t],\n\t\t];\n\t}\n\n\tpublic function callback_custom_safe_ports(): array {\n\t\treturn [ 81, 444, 8081 ];\n\t}\n\n\tpublic function callback_remove_safe_ports(): array {\n\t\treturn [];\n\t}\n}\n"], "filenames": ["includes/REST_API/Hotlinking_Controller.php", "tests/phpunit/integration/tests/REST_API/Hotlinking_Controller.php"], "buggy_code_start_loc": [675, 575], "buggy_code_end_loc": [678, 575], "fixing_code_start_loc": [675, 576], "fixing_code_end_loc": [690, 579], "type": "CWE-918", "message": "The Web Stories plugin for WordPress is vulnerable to Server-Side Request Forgery in versions up to, and including 1.24.0 due to insufficient validation of URLs supplied via the 'url' parameter found via the /v1/hotlink/proxy REST API Endpoint. This made it possible for authenticated users to make web requests to arbitrary locations originating from the web application and can be used to query and modify information from internal services.", "other": {"cve": {"id": "CVE-2022-3708", "sourceIdentifier": "security@wordfence.com", "published": "2022-10-28T19:15:10.140", "lastModified": "2022-11-03T14:28:02.023", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The Web Stories plugin for WordPress is vulnerable to Server-Side Request Forgery in versions up to, and including 1.24.0 due to insufficient validation of URLs supplied via the 'url' parameter found via the /v1/hotlink/proxy REST API Endpoint. This made it possible for authenticated users to make web requests to arbitrary locations originating from the web application and can be used to query and modify information from internal services."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 8.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.2}, {"source": "security@wordfence.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:C/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 9.6, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.1, "impactScore": 5.8}]}, "weaknesses": [{"source": "security@wordfence.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-918"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:google:web_stories:*:*:*:*:*:wordpress:*:*", "versionEndExcluding": "1.25.0", "matchCriteriaId": "FB0F387A-0C9F-4AD0-B364-A6DE2817BB85"}]}]}], "references": [{"url": "https://github.com/GoogleForCreators/web-stories-wp/commit/3ad2099f95155d658624ffac2e34ce0da739e34b", "source": "security@wordfence.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/GoogleForCreators/web-stories-wp/compare/v1.24.0...v1.25.0", "source": "security@wordfence.com", "tags": ["Patch", "Release Notes", "Third Party Advisory"]}, {"url": "https://wordpress.org/plugins/web-stories", "source": "security@wordfence.com", "tags": ["Product", "Release Notes", "Third Party Advisory"]}, {"url": "https://www.wordfence.com/vulnerability-advisories-continued/#CVE-2022-3708", "source": "security@wordfence.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/GoogleForCreators/web-stories-wp/commit/3ad2099f95155d658624ffac2e34ce0da739e34b"}}