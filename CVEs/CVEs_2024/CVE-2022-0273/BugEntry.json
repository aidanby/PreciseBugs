{"buggy_code": ["# -*- coding: utf-8 -*-\n\n#  This file is part of the Calibre-Web (https://github.com/janeczku/calibre-web)\n#    Copyright (C) 2018-2019 OzzieIsaacs, cervinko, jkrehm, bodybybuddha, ok11,\n#                            andy29485, idalin, Kyosfonica, wuqi, Kennyl, lemmsh,\n#                            falgh1, grunjol, csitko, ytils, xybydy, trasba, vrabe,\n#                            ruben-herold, marblepebble, JackED42, SiphonSquirrel,\n#                            apetresc, nanu-c, mutschler\n#\n#  This program is free software: you can redistribute it and/or modify\n#  it under the terms of the GNU General Public License as published by\n#  the Free Software Foundation, either version 3 of the License, or\n#  (at your option) any later version.\n#\n#  This program is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#  GNU General Public License for more details.\n#\n#  You should have received a copy of the GNU General Public License\n#  along with this program. If not, see <http://www.gnu.org/licenses/>.\n\nimport sys\nfrom datetime import datetime\n\nfrom flask import Blueprint, flash, redirect, request, url_for\nfrom flask_babel import gettext as _\nfrom flask_login import current_user, login_required\nfrom sqlalchemy.exc import InvalidRequestError, OperationalError\nfrom sqlalchemy.sql.expression import func, true\n\nfrom . import calibre_db, config, db, logger, ub\nfrom .render_template import render_title_template\nfrom .usermanagement import login_required_if_no_ano\n\nshelf = Blueprint('shelf', __name__)\nlog = logger.create()\n\n\ndef check_shelf_edit_permissions(cur_shelf):\n    if not cur_shelf.is_public and not cur_shelf.user_id == int(current_user.id):\n        log.error(\"User %s not allowed to edit shelf %s\", current_user, cur_shelf)\n        return False\n    if cur_shelf.is_public and not current_user.role_edit_shelfs():\n        log.info(\"User %s not allowed to edit public shelves\", current_user)\n        return False\n    return True\n\n\ndef check_shelf_view_permissions(cur_shelf):\n    if cur_shelf.is_public:\n        return True\n    if current_user.is_anonymous or cur_shelf.user_id != current_user.id:\n        log.error(\"User is unauthorized to view non-public shelf: %s\", cur_shelf)\n        return False\n    return True\n\n\n@shelf.route(\"/shelf/add/<int:shelf_id>/<int:book_id>\", methods=[\"POST\"])\n@login_required\ndef add_to_shelf(shelf_id, book_id):\n    xhr = request.headers.get('X-Requested-With') == 'XMLHttpRequest'\n    shelf = ub.session.query(ub.Shelf).filter(ub.Shelf.id == shelf_id).first()\n    if shelf is None:\n        log.error(\"Invalid shelf specified: %s\", shelf_id)\n        if not xhr:\n            flash(_(u\"Invalid shelf specified\"), category=\"error\")\n            return redirect(url_for('web.index'))\n        return \"Invalid shelf specified\", 400\n\n    if not check_shelf_edit_permissions(shelf):\n        if not xhr:\n            flash(_(u\"Sorry you are not allowed to add a book to that shelf\"), category=\"error\")\n            return redirect(url_for('web.index'))\n        return \"Sorry you are not allowed to add a book to the that shelf\", 403\n\n    book_in_shelf = ub.session.query(ub.BookShelf).filter(ub.BookShelf.shelf == shelf_id,\n                                                          ub.BookShelf.book_id == book_id).first()\n    if book_in_shelf:\n        log.error(\"Book %s is already part of %s\", book_id, shelf)\n        if not xhr:\n            flash(_(u\"Book is already part of the shelf: %(shelfname)s\", shelfname=shelf.name), category=\"error\")\n            return redirect(url_for('web.index'))\n        return \"Book is already part of the shelf: %s\" % shelf.name, 400\n\n    maxOrder = ub.session.query(func.max(ub.BookShelf.order)).filter(ub.BookShelf.shelf == shelf_id).first()\n    if maxOrder[0] is None:\n        maxOrder = 0\n    else:\n        maxOrder = maxOrder[0]\n\n    shelf.books.append(ub.BookShelf(shelf=shelf.id, book_id=book_id, order=maxOrder + 1))\n    shelf.last_modified = datetime.utcnow()\n    try:\n        ub.session.merge(shelf)\n        ub.session.commit()\n    except (OperationalError, InvalidRequestError):\n        ub.session.rollback()\n        log.error(\"Settings DB is not Writeable\")\n        flash(_(u\"Settings DB is not Writeable\"), category=\"error\")\n        if \"HTTP_REFERER\" in request.environ:\n            return redirect(request.environ[\"HTTP_REFERER\"])\n        else:\n            return redirect(url_for('web.index'))\n    if not xhr:\n        log.debug(\"Book has been added to shelf: {}\".format(shelf.name))\n        flash(_(u\"Book has been added to shelf: %(sname)s\", sname=shelf.name), category=\"success\")\n        if \"HTTP_REFERER\" in request.environ:\n            return redirect(request.environ[\"HTTP_REFERER\"])\n        else:\n            return redirect(url_for('web.index'))\n    return \"\", 204\n\n\n@shelf.route(\"/shelf/massadd/<int:shelf_id>\", methods=[\"POST\"])\n@login_required\ndef search_to_shelf(shelf_id):\n    shelf = ub.session.query(ub.Shelf).filter(ub.Shelf.id == shelf_id).first()\n    if shelf is None:\n        log.error(\"Invalid shelf specified: %s\", shelf_id)\n        flash(_(u\"Invalid shelf specified\"), category=\"error\")\n        return redirect(url_for('web.index'))\n\n    if not check_shelf_edit_permissions(shelf):\n        log.warning(\"You are not allowed to add a book to the shelf\".format(shelf.name))\n        flash(_(u\"You are not allowed to add a book to the shelf\"), category=\"error\")\n        return redirect(url_for('web.index'))\n\n    if current_user.id in ub.searched_ids and ub.searched_ids[current_user.id]:\n        books_for_shelf = list()\n        books_in_shelf = ub.session.query(ub.BookShelf).filter(ub.BookShelf.shelf == shelf_id).all()\n        if books_in_shelf:\n            book_ids = list()\n            for book_id in books_in_shelf:\n                book_ids.append(book_id.book_id)\n            for searchid in ub.searched_ids[current_user.id]:\n                if searchid not in book_ids:\n                    books_for_shelf.append(searchid)\n        else:\n            books_for_shelf = ub.searched_ids[current_user.id]\n\n        if not books_for_shelf:\n            log.error(\"Books are already part of {}\".format(shelf.name))\n            flash(_(u\"Books are already part of the shelf: %(name)s\", name=shelf.name), category=\"error\")\n            return redirect(url_for('web.index'))\n\n        maxOrder = ub.session.query(func.max(ub.BookShelf.order)).filter(ub.BookShelf.shelf == shelf_id).first()[0] or 0\n\n        for book in books_for_shelf:\n            maxOrder += 1\n            shelf.books.append(ub.BookShelf(shelf=shelf.id, book_id=book, order=maxOrder))\n        shelf.last_modified = datetime.utcnow()\n        try:\n            ub.session.merge(shelf)\n            ub.session.commit()\n            flash(_(u\"Books have been added to shelf: %(sname)s\", sname=shelf.name), category=\"success\")\n        except (OperationalError, InvalidRequestError):\n            ub.session.rollback()\n            log.error(\"Settings DB is not Writeable\")\n            flash(_(\"Settings DB is not Writeable\"), category=\"error\")\n    else:\n        log.error(\"Could not add books to shelf: {}\".format(shelf.name))\n        flash(_(u\"Could not add books to shelf: %(sname)s\", sname=shelf.name), category=\"error\")\n    return redirect(url_for('web.index'))\n\n\n@shelf.route(\"/shelf/remove/<int:shelf_id>/<int:book_id>\", methods=[\"POST\"])\n@login_required\ndef remove_from_shelf(shelf_id, book_id):\n    xhr = request.headers.get('X-Requested-With') == 'XMLHttpRequest'\n    shelf = ub.session.query(ub.Shelf).filter(ub.Shelf.id == shelf_id).first()\n    if shelf is None:\n        log.error(\"Invalid shelf specified: {}\".format(shelf_id))\n        if not xhr:\n            return redirect(url_for('web.index'))\n        return \"Invalid shelf specified\", 400\n\n    # if shelf is public and use is allowed to edit shelfs, or if shelf is private and user is owner\n    # allow editing shelfs\n    # result   shelf public   user allowed    user owner\n    #   false        1             0             x\n    #   true         1             1             x\n    #   true         0             x             1\n    #   false        0             x             0\n\n    if check_shelf_edit_permissions(shelf):\n        book_shelf = ub.session.query(ub.BookShelf).filter(ub.BookShelf.shelf == shelf_id,\n                                                           ub.BookShelf.book_id == book_id).first()\n\n        if book_shelf is None:\n            log.error(\"Book %s already removed from %s\", book_id, shelf)\n            if not xhr:\n                return redirect(url_for('web.index'))\n            return \"Book already removed from shelf\", 410\n\n        try:\n            ub.session.delete(book_shelf)\n            shelf.last_modified = datetime.utcnow()\n            ub.session.commit()\n        except (OperationalError, InvalidRequestError):\n            ub.session.rollback()\n            log.error(\"Settings DB is not Writeable\")\n            flash(_(\"Settings DB is not Writeable\"), category=\"error\")\n            if \"HTTP_REFERER\" in request.environ:\n                return redirect(request.environ[\"HTTP_REFERER\"])\n            else:\n                return redirect(url_for('web.index'))\n        if not xhr:\n            flash(_(u\"Book has been removed from shelf: %(sname)s\", sname=shelf.name), category=\"success\")\n            if \"HTTP_REFERER\" in request.environ:\n                return redirect(request.environ[\"HTTP_REFERER\"])\n            else:\n                return redirect(url_for('web.index'))\n        return \"\", 204\n    else:\n        if not xhr:\n            log.warning(\"You are not allowed to remove a book from shelf: {}\".format(shelf.name))\n            flash(_(u\"Sorry you are not allowed to remove a book from this shelf\"),\n                  category=\"error\")\n            return redirect(url_for('web.index'))\n        return \"Sorry you are not allowed to remove a book from this shelf\", 403\n\n\n@shelf.route(\"/shelf/create\", methods=[\"GET\", \"POST\"])\n@login_required\ndef create_shelf():\n    shelf = ub.Shelf()\n    return create_edit_shelf(shelf, page_title=_(u\"Create a Shelf\"), page=\"shelfcreate\")\n\n\n\n@shelf.route(\"/shelf/edit/<int:shelf_id>\", methods=[\"GET\", \"POST\"])\n@login_required\ndef edit_shelf(shelf_id):\n    shelf = ub.session.query(ub.Shelf).filter(ub.Shelf.id == shelf_id).first()\n    if not check_shelf_edit_permissions(shelf):\n        flash(_(u\"Sorry you are not allowed to edit this shelf\"), category=\"error\")\n        return redirect(url_for('web.index'))\n    return create_edit_shelf(shelf, page_title=_(u\"Edit a shelf\"), page=\"shelfedit\", shelf_id=shelf_id)\n\n\n# if shelf ID is set, we are editing a shelf\ndef create_edit_shelf(shelf, page_title, page, shelf_id=False):\n    sync_only_selected_shelves = current_user.kobo_only_shelves_sync\n    # calibre_db.session.query(ub.Shelf).filter(ub.Shelf.user_id == current_user.id).filter(ub.Shelf.kobo_sync).count()\n    if request.method == \"POST\":\n        to_save = request.form.to_dict()\n        if not current_user.role_edit_shelfs() and to_save.get(\"is_public\") == \"on\":\n            flash(_(u\"Sorry you are not allowed to create a public shelf\"), category=\"error\")\n            return redirect(url_for('web.index'))\n        is_public = 1 if to_save.get(\"is_public\") else 0\n        if config.config_kobo_sync:\n            shelf.kobo_sync = True if to_save.get(\"kobo_sync\") else False\n            if shelf.kobo_sync:\n                ub.session.query(ub.ShelfArchive).filter(ub.ShelfArchive.user_id == current_user.id).filter(\n                    ub.ShelfArchive.uuid == shelf.uuid).delete()\n                ub.session_commit()\n        shelf_title = to_save.get(\"title\", \"\")\n        if check_shelf_is_unique(shelf, shelf_title, is_public, shelf_id):\n            shelf.name = shelf_title\n            shelf.is_public = is_public\n            if not shelf_id:\n                shelf.user_id = int(current_user.id)\n                ub.session.add(shelf)\n                shelf_action = \"created\"\n                flash_text = _(u\"Shelf %(title)s created\", title=shelf_title)\n            else:\n                shelf_action = \"changed\"\n                flash_text = _(u\"Shelf %(title)s changed\", title=shelf_title)\n            try:\n                ub.session.commit()\n                log.info(u\"Shelf {} {}\".format(shelf_title, shelf_action))\n                flash(flash_text, category=\"success\")\n                return redirect(url_for('shelf.show_shelf', shelf_id=shelf.id))\n            except (OperationalError, InvalidRequestError) as ex:\n                ub.session.rollback()\n                log.debug_or_exception(ex)\n                log.error(\"Settings DB is not Writeable\")\n                flash(_(\"Settings DB is not Writeable\"), category=\"error\")\n            except Exception as ex:\n                ub.session.rollback()\n                log.debug_or_exception(ex)\n                flash(_(u\"There was an error\"), category=\"error\")\n    return render_title_template('shelf_edit.html',\n                                 shelf=shelf,\n                                 title=page_title,\n                                 page=page,\n                                 kobo_sync_enabled=config.config_kobo_sync,\n                                 sync_only_selected_shelves=sync_only_selected_shelves)\n\n\ndef check_shelf_is_unique(shelf, title, is_public, shelf_id=False):\n    if shelf_id:\n        ident = ub.Shelf.id != shelf_id\n    else:\n        ident = true()\n    if is_public == 1:\n        is_shelf_name_unique = ub.session.query(ub.Shelf) \\\n                                   .filter((ub.Shelf.name == title) & (ub.Shelf.is_public == 1)) \\\n                                   .filter(ident) \\\n                                   .first() is None\n\n        if not is_shelf_name_unique:\n            log.error(\"A public shelf with the name '{}' already exists.\".format(title))\n            flash(_(u\"A public shelf with the name '%(title)s' already exists.\", title=title),\n                  category=\"error\")\n    else:\n        is_shelf_name_unique = ub.session.query(ub.Shelf) \\\n                                   .filter((ub.Shelf.name == title) & (ub.Shelf.is_public == 0) &\n                                           (ub.Shelf.user_id == int(current_user.id))) \\\n                                   .filter(ident) \\\n                                   .first() is None\n\n        if not is_shelf_name_unique:\n            log.error(\"A private shelf with the name '{}' already exists.\".format(title))\n            flash(_(u\"A private shelf with the name '%(title)s' already exists.\", title=title),\n                  category=\"error\")\n    return is_shelf_name_unique\n\n\ndef delete_shelf_helper(cur_shelf):\n    if not cur_shelf or not check_shelf_edit_permissions(cur_shelf):\n        return\n    shelf_id = cur_shelf.id\n    ub.session.delete(cur_shelf)\n    ub.session.query(ub.BookShelf).filter(ub.BookShelf.shelf == shelf_id).delete()\n    ub.session.add(ub.ShelfArchive(uuid=cur_shelf.uuid, user_id=cur_shelf.user_id))\n    ub.session_commit(\"successfully deleted Shelf {}\".format(cur_shelf.name))\n\n\n@shelf.route(\"/shelf/delete/<int:shelf_id>\", methods=[\"POST\"])\n@login_required\ndef delete_shelf(shelf_id):\n    cur_shelf = ub.session.query(ub.Shelf).filter(ub.Shelf.id == shelf_id).first()\n    try:\n        delete_shelf_helper(cur_shelf)\n        flash(_(\"Shelf successfully deleted\"), category=\"success\")\n    except InvalidRequestError:\n        ub.session.rollback()\n        log.error(\"Settings DB is not Writeable\")\n        flash(_(\"Settings DB is not Writeable\"), category=\"error\")\n    return redirect(url_for('web.index'))\n\n\n@shelf.route(\"/simpleshelf/<int:shelf_id>\")\n@login_required_if_no_ano\ndef show_simpleshelf(shelf_id):\n    return render_show_shelf(2, shelf_id, 1, None)\n\n\n@shelf.route(\"/shelf/<int:shelf_id>\", defaults={\"sort_param\": \"order\", 'page': 1})\n@shelf.route(\"/shelf/<int:shelf_id>/<sort_param>\", defaults={'page': 1})\n@shelf.route(\"/shelf/<int:shelf_id>/<sort_param>/<int:page>\")\n@login_required_if_no_ano\ndef show_shelf(shelf_id, sort_param, page):\n    return render_show_shelf(1, shelf_id, page, sort_param)\n\n\n@shelf.route(\"/shelf/order/<int:shelf_id>\", methods=[\"GET\", \"POST\"])\n@login_required\ndef order_shelf(shelf_id):\n    if request.method == \"POST\":\n        to_save = request.form.to_dict()\n        books_in_shelf = ub.session.query(ub.BookShelf).filter(ub.BookShelf.shelf == shelf_id).order_by(\n            ub.BookShelf.order.asc()).all()\n        counter = 0\n        for book in books_in_shelf:\n            setattr(book, 'order', to_save[str(book.book_id)])\n            counter += 1\n            # if order diffrent from before -> shelf.last_modified = datetime.utcnow()\n        try:\n            ub.session.commit()\n        except (OperationalError, InvalidRequestError):\n            ub.session.rollback()\n            log.error(\"Settings DB is not Writeable\")\n            flash(_(\"Settings DB is not Writeable\"), category=\"error\")\n\n    shelf = ub.session.query(ub.Shelf).filter(ub.Shelf.id == shelf_id).first()\n    result = list()\n    if shelf and check_shelf_view_permissions(shelf):\n        result = calibre_db.session.query(db.Books) \\\n            .join(ub.BookShelf, ub.BookShelf.book_id == db.Books.id, isouter=True) \\\n            .add_columns(calibre_db.common_filters().label(\"visible\")) \\\n            .filter(ub.BookShelf.shelf == shelf_id).order_by(ub.BookShelf.order.asc()).all()\n    return render_title_template('shelf_order.html', entries=result,\n                                 title=_(u\"Change order of Shelf: '%(name)s'\", name=shelf.name),\n                                 shelf=shelf, page=\"shelforder\")\n\n\ndef change_shelf_order(shelf_id, order):\n    result = calibre_db.session.query(db.Books).outerjoin(db.books_series_link,\n                                                          db.Books.id == db.books_series_link.c.book)\\\n        .outerjoin(db.Series).join(ub.BookShelf, ub.BookShelf.book_id == db.Books.id) \\\n        .filter(ub.BookShelf.shelf == shelf_id).order_by(*order).all()\n    for index, entry in enumerate(result):\n        book = ub.session.query(ub.BookShelf).filter(ub.BookShelf.shelf == shelf_id) \\\n            .filter(ub.BookShelf.book_id == entry.id).first()\n        book.order = index\n    ub.session_commit(\"Shelf-id:{} - Order changed\".format(shelf_id))\n\n\ndef render_show_shelf(shelf_type, shelf_id, page_no, sort_param):\n    shelf = ub.session.query(ub.Shelf).filter(ub.Shelf.id == shelf_id).first()\n\n    # check user is allowed to access shelf\n    if shelf and check_shelf_view_permissions(shelf):\n\n        if shelf_type == 1:\n            # order = [ub.BookShelf.order.asc()]\n            if sort_param == 'pubnew':\n                change_shelf_order(shelf_id, [db.Books.pubdate.desc()])\n            if sort_param == 'pubold':\n                change_shelf_order(shelf_id, [db.Books.pubdate])\n            if sort_param == 'abc':\n                change_shelf_order(shelf_id, [db.Books.sort])\n            if sort_param == 'zyx':\n                change_shelf_order(shelf_id, [db.Books.sort.desc()])\n            if sort_param == 'new':\n                change_shelf_order(shelf_id, [db.Books.timestamp.desc()])\n            if sort_param == 'old':\n                change_shelf_order(shelf_id, [db.Books.timestamp])\n            if sort_param == 'authaz':\n                change_shelf_order(shelf_id, [db.Books.author_sort.asc(), db.Series.name, db.Books.series_index])\n            if sort_param == 'authza':\n                change_shelf_order(shelf_id, [db.Books.author_sort.desc(),\n                                              db.Series.name.desc(),\n                                              db.Books.series_index.desc()])\n            page = \"shelf.html\"\n            pagesize = 0\n        else:\n            pagesize = sys.maxsize\n            page = 'shelfdown.html'\n\n        result, __, pagination = calibre_db.fill_indexpage(page_no, pagesize,\n                                                           db.Books,\n                                                           ub.BookShelf.shelf == shelf_id,\n                                                           [ub.BookShelf.order.asc()],\n                                                           ub.BookShelf, ub.BookShelf.book_id == db.Books.id)\n        # delete chelf entries where book is not existent anymore, can happen if book is deleted outside calibre-web\n        wrong_entries = calibre_db.session.query(ub.BookShelf) \\\n            .join(db.Books, ub.BookShelf.book_id == db.Books.id, isouter=True) \\\n            .filter(db.Books.id == None).all()\n        for entry in wrong_entries:\n            log.info('Not existing book {} in {} deleted'.format(entry.book_id, shelf))\n            try:\n                ub.session.query(ub.BookShelf).filter(ub.BookShelf.book_id == entry.book_id).delete()\n                ub.session.commit()\n            except (OperationalError, InvalidRequestError):\n                ub.session.rollback()\n                log.error(\"Settings DB is not Writeable\")\n                flash(_(\"Settings DB is not Writeable\"), category=\"error\")\n\n        return render_title_template(page,\n                                     entries=result,\n                                     pagination=pagination,\n                                     title=_(u\"Shelf: '%(name)s'\", name=shelf.name),\n                                     shelf=shelf,\n                                     page=\"shelf\")\n    else:\n        flash(_(u\"Error opening shelf. Shelf does not exist or is not accessible\"), category=\"error\")\n        return redirect(url_for(\"web.index\"))\n"], "fixing_code": ["# -*- coding: utf-8 -*-\n\n#  This file is part of the Calibre-Web (https://github.com/janeczku/calibre-web)\n#    Copyright (C) 2018-2019 OzzieIsaacs, cervinko, jkrehm, bodybybuddha, ok11,\n#                            andy29485, idalin, Kyosfonica, wuqi, Kennyl, lemmsh,\n#                            falgh1, grunjol, csitko, ytils, xybydy, trasba, vrabe,\n#                            ruben-herold, marblepebble, JackED42, SiphonSquirrel,\n#                            apetresc, nanu-c, mutschler\n#\n#  This program is free software: you can redistribute it and/or modify\n#  it under the terms of the GNU General Public License as published by\n#  the Free Software Foundation, either version 3 of the License, or\n#  (at your option) any later version.\n#\n#  This program is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#  GNU General Public License for more details.\n#\n#  You should have received a copy of the GNU General Public License\n#  along with this program. If not, see <http://www.gnu.org/licenses/>.\n\nimport sys\nfrom datetime import datetime\n\nfrom flask import Blueprint, flash, redirect, request, url_for\nfrom flask_babel import gettext as _\nfrom flask_login import current_user, login_required\nfrom sqlalchemy.exc import InvalidRequestError, OperationalError\nfrom sqlalchemy.sql.expression import func, true\n\nfrom . import calibre_db, config, db, logger, ub\nfrom .render_template import render_title_template\nfrom .usermanagement import login_required_if_no_ano\n\nshelf = Blueprint('shelf', __name__)\nlog = logger.create()\n\n\ndef check_shelf_edit_permissions(cur_shelf):\n    if not cur_shelf.is_public and not cur_shelf.user_id == int(current_user.id):\n        log.error(\"User %s not allowed to edit shelf %s\", current_user, cur_shelf)\n        return False\n    if cur_shelf.is_public and not current_user.role_edit_shelfs():\n        log.info(\"User %s not allowed to edit public shelves\", current_user)\n        return False\n    return True\n\n\ndef check_shelf_view_permissions(cur_shelf):\n    if cur_shelf.is_public:\n        return True\n    if current_user.is_anonymous or cur_shelf.user_id != current_user.id:\n        log.error(\"User is unauthorized to view non-public shelf: %s\", cur_shelf)\n        return False\n    return True\n\n\n@shelf.route(\"/shelf/add/<int:shelf_id>/<int:book_id>\", methods=[\"POST\"])\n@login_required\ndef add_to_shelf(shelf_id, book_id):\n    xhr = request.headers.get('X-Requested-With') == 'XMLHttpRequest'\n    shelf = ub.session.query(ub.Shelf).filter(ub.Shelf.id == shelf_id).first()\n    if shelf is None:\n        log.error(\"Invalid shelf specified: %s\", shelf_id)\n        if not xhr:\n            flash(_(u\"Invalid shelf specified\"), category=\"error\")\n            return redirect(url_for('web.index'))\n        return \"Invalid shelf specified\", 400\n\n    if not check_shelf_edit_permissions(shelf):\n        if not xhr:\n            flash(_(u\"Sorry you are not allowed to add a book to that shelf\"), category=\"error\")\n            return redirect(url_for('web.index'))\n        return \"Sorry you are not allowed to add a book to the that shelf\", 403\n\n    book_in_shelf = ub.session.query(ub.BookShelf).filter(ub.BookShelf.shelf == shelf_id,\n                                                          ub.BookShelf.book_id == book_id).first()\n    if book_in_shelf:\n        log.error(\"Book %s is already part of %s\", book_id, shelf)\n        if not xhr:\n            flash(_(u\"Book is already part of the shelf: %(shelfname)s\", shelfname=shelf.name), category=\"error\")\n            return redirect(url_for('web.index'))\n        return \"Book is already part of the shelf: %s\" % shelf.name, 400\n\n    maxOrder = ub.session.query(func.max(ub.BookShelf.order)).filter(ub.BookShelf.shelf == shelf_id).first()\n    if maxOrder[0] is None:\n        maxOrder = 0\n    else:\n        maxOrder = maxOrder[0]\n\n    shelf.books.append(ub.BookShelf(shelf=shelf.id, book_id=book_id, order=maxOrder + 1))\n    shelf.last_modified = datetime.utcnow()\n    try:\n        ub.session.merge(shelf)\n        ub.session.commit()\n    except (OperationalError, InvalidRequestError):\n        ub.session.rollback()\n        log.error(\"Settings DB is not Writeable\")\n        flash(_(u\"Settings DB is not Writeable\"), category=\"error\")\n        if \"HTTP_REFERER\" in request.environ:\n            return redirect(request.environ[\"HTTP_REFERER\"])\n        else:\n            return redirect(url_for('web.index'))\n    if not xhr:\n        log.debug(\"Book has been added to shelf: {}\".format(shelf.name))\n        flash(_(u\"Book has been added to shelf: %(sname)s\", sname=shelf.name), category=\"success\")\n        if \"HTTP_REFERER\" in request.environ:\n            return redirect(request.environ[\"HTTP_REFERER\"])\n        else:\n            return redirect(url_for('web.index'))\n    return \"\", 204\n\n\n@shelf.route(\"/shelf/massadd/<int:shelf_id>\", methods=[\"POST\"])\n@login_required\ndef search_to_shelf(shelf_id):\n    shelf = ub.session.query(ub.Shelf).filter(ub.Shelf.id == shelf_id).first()\n    if shelf is None:\n        log.error(\"Invalid shelf specified: %s\", shelf_id)\n        flash(_(u\"Invalid shelf specified\"), category=\"error\")\n        return redirect(url_for('web.index'))\n\n    if not check_shelf_edit_permissions(shelf):\n        log.warning(\"You are not allowed to add a book to the shelf\".format(shelf.name))\n        flash(_(u\"You are not allowed to add a book to the shelf\"), category=\"error\")\n        return redirect(url_for('web.index'))\n\n    if current_user.id in ub.searched_ids and ub.searched_ids[current_user.id]:\n        books_for_shelf = list()\n        books_in_shelf = ub.session.query(ub.BookShelf).filter(ub.BookShelf.shelf == shelf_id).all()\n        if books_in_shelf:\n            book_ids = list()\n            for book_id in books_in_shelf:\n                book_ids.append(book_id.book_id)\n            for searchid in ub.searched_ids[current_user.id]:\n                if searchid not in book_ids:\n                    books_for_shelf.append(searchid)\n        else:\n            books_for_shelf = ub.searched_ids[current_user.id]\n\n        if not books_for_shelf:\n            log.error(\"Books are already part of {}\".format(shelf.name))\n            flash(_(u\"Books are already part of the shelf: %(name)s\", name=shelf.name), category=\"error\")\n            return redirect(url_for('web.index'))\n\n        maxOrder = ub.session.query(func.max(ub.BookShelf.order)).filter(ub.BookShelf.shelf == shelf_id).first()[0] or 0\n\n        for book in books_for_shelf:\n            maxOrder += 1\n            shelf.books.append(ub.BookShelf(shelf=shelf.id, book_id=book, order=maxOrder))\n        shelf.last_modified = datetime.utcnow()\n        try:\n            ub.session.merge(shelf)\n            ub.session.commit()\n            flash(_(u\"Books have been added to shelf: %(sname)s\", sname=shelf.name), category=\"success\")\n        except (OperationalError, InvalidRequestError):\n            ub.session.rollback()\n            log.error(\"Settings DB is not Writeable\")\n            flash(_(\"Settings DB is not Writeable\"), category=\"error\")\n    else:\n        log.error(\"Could not add books to shelf: {}\".format(shelf.name))\n        flash(_(u\"Could not add books to shelf: %(sname)s\", sname=shelf.name), category=\"error\")\n    return redirect(url_for('web.index'))\n\n\n@shelf.route(\"/shelf/remove/<int:shelf_id>/<int:book_id>\", methods=[\"POST\"])\n@login_required\ndef remove_from_shelf(shelf_id, book_id):\n    xhr = request.headers.get('X-Requested-With') == 'XMLHttpRequest'\n    shelf = ub.session.query(ub.Shelf).filter(ub.Shelf.id == shelf_id).first()\n    if shelf is None:\n        log.error(\"Invalid shelf specified: {}\".format(shelf_id))\n        if not xhr:\n            return redirect(url_for('web.index'))\n        return \"Invalid shelf specified\", 400\n\n    # if shelf is public and use is allowed to edit shelfs, or if shelf is private and user is owner\n    # allow editing shelfs\n    # result   shelf public   user allowed    user owner\n    #   false        1             0             x\n    #   true         1             1             x\n    #   true         0             x             1\n    #   false        0             x             0\n\n    if check_shelf_edit_permissions(shelf):\n        book_shelf = ub.session.query(ub.BookShelf).filter(ub.BookShelf.shelf == shelf_id,\n                                                           ub.BookShelf.book_id == book_id).first()\n\n        if book_shelf is None:\n            log.error(\"Book %s already removed from %s\", book_id, shelf)\n            if not xhr:\n                return redirect(url_for('web.index'))\n            return \"Book already removed from shelf\", 410\n\n        try:\n            ub.session.delete(book_shelf)\n            shelf.last_modified = datetime.utcnow()\n            ub.session.commit()\n        except (OperationalError, InvalidRequestError):\n            ub.session.rollback()\n            log.error(\"Settings DB is not Writeable\")\n            flash(_(\"Settings DB is not Writeable\"), category=\"error\")\n            if \"HTTP_REFERER\" in request.environ:\n                return redirect(request.environ[\"HTTP_REFERER\"])\n            else:\n                return redirect(url_for('web.index'))\n        if not xhr:\n            flash(_(u\"Book has been removed from shelf: %(sname)s\", sname=shelf.name), category=\"success\")\n            if \"HTTP_REFERER\" in request.environ:\n                return redirect(request.environ[\"HTTP_REFERER\"])\n            else:\n                return redirect(url_for('web.index'))\n        return \"\", 204\n    else:\n        if not xhr:\n            log.warning(\"You are not allowed to remove a book from shelf: {}\".format(shelf.name))\n            flash(_(u\"Sorry you are not allowed to remove a book from this shelf\"),\n                  category=\"error\")\n            return redirect(url_for('web.index'))\n        return \"Sorry you are not allowed to remove a book from this shelf\", 403\n\n\n@shelf.route(\"/shelf/create\", methods=[\"GET\", \"POST\"])\n@login_required\ndef create_shelf():\n    shelf = ub.Shelf()\n    return create_edit_shelf(shelf, page_title=_(u\"Create a Shelf\"), page=\"shelfcreate\")\n\n\n\n@shelf.route(\"/shelf/edit/<int:shelf_id>\", methods=[\"GET\", \"POST\"])\n@login_required\ndef edit_shelf(shelf_id):\n    shelf = ub.session.query(ub.Shelf).filter(ub.Shelf.id == shelf_id).first()\n    if not check_shelf_edit_permissions(shelf):\n        flash(_(u\"Sorry you are not allowed to edit this shelf\"), category=\"error\")\n        return redirect(url_for('web.index'))\n    return create_edit_shelf(shelf, page_title=_(u\"Edit a shelf\"), page=\"shelfedit\", shelf_id=shelf_id)\n\n\n# if shelf ID is set, we are editing a shelf\ndef create_edit_shelf(shelf, page_title, page, shelf_id=False):\n    sync_only_selected_shelves = current_user.kobo_only_shelves_sync\n    # calibre_db.session.query(ub.Shelf).filter(ub.Shelf.user_id == current_user.id).filter(ub.Shelf.kobo_sync).count()\n    if request.method == \"POST\":\n        to_save = request.form.to_dict()\n        if not current_user.role_edit_shelfs() and to_save.get(\"is_public\") == \"on\":\n            flash(_(u\"Sorry you are not allowed to create a public shelf\"), category=\"error\")\n            return redirect(url_for('web.index'))\n        is_public = 1 if to_save.get(\"is_public\") == \"on\" else 0\n        if config.config_kobo_sync:\n            shelf.kobo_sync = True if to_save.get(\"kobo_sync\") else False\n            if shelf.kobo_sync:\n                ub.session.query(ub.ShelfArchive).filter(ub.ShelfArchive.user_id == current_user.id).filter(\n                    ub.ShelfArchive.uuid == shelf.uuid).delete()\n                ub.session_commit()\n        shelf_title = to_save.get(\"title\", \"\")\n        if check_shelf_is_unique(shelf, shelf_title, is_public, shelf_id):\n            shelf.name = shelf_title\n            shelf.is_public = is_public\n            if not shelf_id:\n                shelf.user_id = int(current_user.id)\n                ub.session.add(shelf)\n                shelf_action = \"created\"\n                flash_text = _(u\"Shelf %(title)s created\", title=shelf_title)\n            else:\n                shelf_action = \"changed\"\n                flash_text = _(u\"Shelf %(title)s changed\", title=shelf_title)\n            try:\n                ub.session.commit()\n                log.info(u\"Shelf {} {}\".format(shelf_title, shelf_action))\n                flash(flash_text, category=\"success\")\n                return redirect(url_for('shelf.show_shelf', shelf_id=shelf.id))\n            except (OperationalError, InvalidRequestError) as ex:\n                ub.session.rollback()\n                log.debug_or_exception(ex)\n                log.error(\"Settings DB is not Writeable\")\n                flash(_(\"Settings DB is not Writeable\"), category=\"error\")\n            except Exception as ex:\n                ub.session.rollback()\n                log.debug_or_exception(ex)\n                flash(_(u\"There was an error\"), category=\"error\")\n    return render_title_template('shelf_edit.html',\n                                 shelf=shelf,\n                                 title=page_title,\n                                 page=page,\n                                 kobo_sync_enabled=config.config_kobo_sync,\n                                 sync_only_selected_shelves=sync_only_selected_shelves)\n\n\ndef check_shelf_is_unique(shelf, title, is_public, shelf_id=False):\n    if shelf_id:\n        ident = ub.Shelf.id != shelf_id\n    else:\n        ident = true()\n    if is_public == 1:\n        is_shelf_name_unique = ub.session.query(ub.Shelf) \\\n                                   .filter((ub.Shelf.name == title) & (ub.Shelf.is_public == 1)) \\\n                                   .filter(ident) \\\n                                   .first() is None\n\n        if not is_shelf_name_unique:\n            log.error(\"A public shelf with the name '{}' already exists.\".format(title))\n            flash(_(u\"A public shelf with the name '%(title)s' already exists.\", title=title),\n                  category=\"error\")\n    else:\n        is_shelf_name_unique = ub.session.query(ub.Shelf) \\\n                                   .filter((ub.Shelf.name == title) & (ub.Shelf.is_public == 0) &\n                                           (ub.Shelf.user_id == int(current_user.id))) \\\n                                   .filter(ident) \\\n                                   .first() is None\n\n        if not is_shelf_name_unique:\n            log.error(\"A private shelf with the name '{}' already exists.\".format(title))\n            flash(_(u\"A private shelf with the name '%(title)s' already exists.\", title=title),\n                  category=\"error\")\n    return is_shelf_name_unique\n\n\ndef delete_shelf_helper(cur_shelf):\n    if not cur_shelf or not check_shelf_edit_permissions(cur_shelf):\n        return\n    shelf_id = cur_shelf.id\n    ub.session.delete(cur_shelf)\n    ub.session.query(ub.BookShelf).filter(ub.BookShelf.shelf == shelf_id).delete()\n    ub.session.add(ub.ShelfArchive(uuid=cur_shelf.uuid, user_id=cur_shelf.user_id))\n    ub.session_commit(\"successfully deleted Shelf {}\".format(cur_shelf.name))\n\n\n@shelf.route(\"/shelf/delete/<int:shelf_id>\", methods=[\"POST\"])\n@login_required\ndef delete_shelf(shelf_id):\n    cur_shelf = ub.session.query(ub.Shelf).filter(ub.Shelf.id == shelf_id).first()\n    try:\n        delete_shelf_helper(cur_shelf)\n        flash(_(\"Shelf successfully deleted\"), category=\"success\")\n    except InvalidRequestError:\n        ub.session.rollback()\n        log.error(\"Settings DB is not Writeable\")\n        flash(_(\"Settings DB is not Writeable\"), category=\"error\")\n    return redirect(url_for('web.index'))\n\n\n@shelf.route(\"/simpleshelf/<int:shelf_id>\")\n@login_required_if_no_ano\ndef show_simpleshelf(shelf_id):\n    return render_show_shelf(2, shelf_id, 1, None)\n\n\n@shelf.route(\"/shelf/<int:shelf_id>\", defaults={\"sort_param\": \"order\", 'page': 1})\n@shelf.route(\"/shelf/<int:shelf_id>/<sort_param>\", defaults={'page': 1})\n@shelf.route(\"/shelf/<int:shelf_id>/<sort_param>/<int:page>\")\n@login_required_if_no_ano\ndef show_shelf(shelf_id, sort_param, page):\n    return render_show_shelf(1, shelf_id, page, sort_param)\n\n\n@shelf.route(\"/shelf/order/<int:shelf_id>\", methods=[\"GET\", \"POST\"])\n@login_required\ndef order_shelf(shelf_id):\n    if request.method == \"POST\":\n        to_save = request.form.to_dict()\n        books_in_shelf = ub.session.query(ub.BookShelf).filter(ub.BookShelf.shelf == shelf_id).order_by(\n            ub.BookShelf.order.asc()).all()\n        counter = 0\n        for book in books_in_shelf:\n            setattr(book, 'order', to_save[str(book.book_id)])\n            counter += 1\n            # if order diffrent from before -> shelf.last_modified = datetime.utcnow()\n        try:\n            ub.session.commit()\n        except (OperationalError, InvalidRequestError):\n            ub.session.rollback()\n            log.error(\"Settings DB is not Writeable\")\n            flash(_(\"Settings DB is not Writeable\"), category=\"error\")\n\n    shelf = ub.session.query(ub.Shelf).filter(ub.Shelf.id == shelf_id).first()\n    result = list()\n    if shelf and check_shelf_view_permissions(shelf):\n        result = calibre_db.session.query(db.Books) \\\n            .join(ub.BookShelf, ub.BookShelf.book_id == db.Books.id, isouter=True) \\\n            .add_columns(calibre_db.common_filters().label(\"visible\")) \\\n            .filter(ub.BookShelf.shelf == shelf_id).order_by(ub.BookShelf.order.asc()).all()\n    return render_title_template('shelf_order.html', entries=result,\n                                 title=_(u\"Change order of Shelf: '%(name)s'\", name=shelf.name),\n                                 shelf=shelf, page=\"shelforder\")\n\n\ndef change_shelf_order(shelf_id, order):\n    result = calibre_db.session.query(db.Books).outerjoin(db.books_series_link,\n                                                          db.Books.id == db.books_series_link.c.book)\\\n        .outerjoin(db.Series).join(ub.BookShelf, ub.BookShelf.book_id == db.Books.id) \\\n        .filter(ub.BookShelf.shelf == shelf_id).order_by(*order).all()\n    for index, entry in enumerate(result):\n        book = ub.session.query(ub.BookShelf).filter(ub.BookShelf.shelf == shelf_id) \\\n            .filter(ub.BookShelf.book_id == entry.id).first()\n        book.order = index\n    ub.session_commit(\"Shelf-id:{} - Order changed\".format(shelf_id))\n\n\ndef render_show_shelf(shelf_type, shelf_id, page_no, sort_param):\n    shelf = ub.session.query(ub.Shelf).filter(ub.Shelf.id == shelf_id).first()\n\n    # check user is allowed to access shelf\n    if shelf and check_shelf_view_permissions(shelf):\n\n        if shelf_type == 1:\n            # order = [ub.BookShelf.order.asc()]\n            if sort_param == 'pubnew':\n                change_shelf_order(shelf_id, [db.Books.pubdate.desc()])\n            if sort_param == 'pubold':\n                change_shelf_order(shelf_id, [db.Books.pubdate])\n            if sort_param == 'abc':\n                change_shelf_order(shelf_id, [db.Books.sort])\n            if sort_param == 'zyx':\n                change_shelf_order(shelf_id, [db.Books.sort.desc()])\n            if sort_param == 'new':\n                change_shelf_order(shelf_id, [db.Books.timestamp.desc()])\n            if sort_param == 'old':\n                change_shelf_order(shelf_id, [db.Books.timestamp])\n            if sort_param == 'authaz':\n                change_shelf_order(shelf_id, [db.Books.author_sort.asc(), db.Series.name, db.Books.series_index])\n            if sort_param == 'authza':\n                change_shelf_order(shelf_id, [db.Books.author_sort.desc(),\n                                              db.Series.name.desc(),\n                                              db.Books.series_index.desc()])\n            page = \"shelf.html\"\n            pagesize = 0\n        else:\n            pagesize = sys.maxsize\n            page = 'shelfdown.html'\n\n        result, __, pagination = calibre_db.fill_indexpage(page_no, pagesize,\n                                                           db.Books,\n                                                           ub.BookShelf.shelf == shelf_id,\n                                                           [ub.BookShelf.order.asc()],\n                                                           ub.BookShelf, ub.BookShelf.book_id == db.Books.id)\n        # delete chelf entries where book is not existent anymore, can happen if book is deleted outside calibre-web\n        wrong_entries = calibre_db.session.query(ub.BookShelf) \\\n            .join(db.Books, ub.BookShelf.book_id == db.Books.id, isouter=True) \\\n            .filter(db.Books.id == None).all()\n        for entry in wrong_entries:\n            log.info('Not existing book {} in {} deleted'.format(entry.book_id, shelf))\n            try:\n                ub.session.query(ub.BookShelf).filter(ub.BookShelf.book_id == entry.book_id).delete()\n                ub.session.commit()\n            except (OperationalError, InvalidRequestError):\n                ub.session.rollback()\n                log.error(\"Settings DB is not Writeable\")\n                flash(_(\"Settings DB is not Writeable\"), category=\"error\")\n\n        return render_title_template(page,\n                                     entries=result,\n                                     pagination=pagination,\n                                     title=_(u\"Shelf: '%(name)s'\", name=shelf.name),\n                                     shelf=shelf,\n                                     page=\"shelf\")\n    else:\n        flash(_(u\"Error opening shelf. Shelf does not exist or is not accessible\"), category=\"error\")\n        return redirect(url_for(\"web.index\"))\n"], "filenames": ["cps/shelf.py"], "buggy_code_start_loc": [251], "buggy_code_end_loc": [252], "fixing_code_start_loc": [251], "fixing_code_end_loc": [252], "type": "CWE-284", "message": "Improper Access Control in Pypi calibreweb prior to 0.6.16.", "other": {"cve": {"id": "CVE-2022-0273", "sourceIdentifier": "security@huntr.dev", "published": "2022-01-30T14:15:07.597", "lastModified": "2022-03-17T16:11:35.453", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Improper Access Control in Pypi calibreweb prior to 0.6.16."}, {"lang": "es", "value": "Un Control de Acceso Inapropiado en Pypi calibreweb versiones anteriores a 0.6.16"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-284"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-863"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:calibre-web_project:calibre-web:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.6.16", "matchCriteriaId": "617B843B-6C45-4C15-B38C-03A1E9052D91"}]}]}], "references": [{"url": "https://github.com/janeczku/calibre-web/commit/0c0313f375bed7b035c8c0482bbb09599e16bfcf", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/8f27686f-d698-4ab6-8ef0-899125792f13", "source": "security@huntr.dev", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/janeczku/calibre-web/commit/0c0313f375bed7b035c8c0482bbb09599e16bfcf"}}