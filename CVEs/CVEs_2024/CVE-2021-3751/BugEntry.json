{"buggy_code": ["/** @file buffer.c\n *  @brief Functions to read/write raw big endian data\n *\n * Copyright (c) 2014 Bartek Fabiszewski\n * http://www.fabiszewski.net\n *\n * This file is part of libmobi.\n * Licensed under LGPL, either version 3, or any later.\n * See <http://www.gnu.org/licenses/>\n */\n\n#include <stdlib.h>\n#include <string.h>\n#include \"buffer.h\"\n#include \"debug.h\"\n\n/**\n @brief Initializer for MOBIBuffer structure\n \n It allocates memory for structure and for data.\n Memory should be freed with mobi_buffer_free().\n \n @param[in] len Size of data to be allocated for the buffer\n @return MOBIBuffer on success, NULL otherwise\n */\nMOBIBuffer * mobi_buffer_init(const size_t len) {\n    unsigned char *data = malloc(len);\n    if (data == NULL) {\n        debug_print(\"%s\", \"Buffer data allocation failed\\n\");\n        return NULL;\n    }\n    MOBIBuffer *buf = mobi_buffer_init_null(data, len);\n    if (buf == NULL) {\n        free(data);\n    }\n    return buf;\n}\n\n/**\n @brief Initializer for MOBIBuffer structure\n \n It allocates memory for structure but, unlike mobi_buffer_init(), it does not allocate memory for data.\n Instead it works on external data.\n Memory should be freed with mobi_buffer_free_null() (buf->data will not be deallocated).\n \n @param[in,out] data Set data as buffer data\n @param[in] len Size of data held by the buffer\n @return MOBIBuffer on success, NULL otherwise\n */\nMOBIBuffer * mobi_buffer_init_null(unsigned char *data, const size_t len) {\n    MOBIBuffer *buf = malloc(sizeof(MOBIBuffer));\n\tif (buf == NULL) {\n        debug_print(\"%s\", \"Buffer allocation failed\\n\");\n        return NULL;\n    }\n    buf->data = data;\n\tbuf->offset = 0;\n\tbuf->maxlen = len;\n    buf->error = MOBI_SUCCESS;\n\treturn buf;\n}\n\n/**\n @brief Resize buffer\n \n Smaller size than offset will cause data truncation.\n \n @param[in,out] buf MOBIBuffer structure to be filled with data\n @param[in] newlen New buffer size\n */\nvoid mobi_buffer_resize(MOBIBuffer *buf, const size_t newlen) {\n    unsigned char *tmp = realloc(buf->data, newlen);\n    if (tmp == NULL) {\n        debug_print(\"%s\", \"Buffer allocation failed\\n\");\n        buf->error = MOBI_MALLOC_FAILED;\n        return;\n    }\n    buf->data = tmp;\n    buf->maxlen = newlen;\n    if (buf->offset >= newlen) {\n        buf->offset = newlen - 1;\n    }\n    debug_print(\"Buffer successfully resized to %zu\\n\", newlen);\n    buf->error = MOBI_SUCCESS;\n}\n\n/**\n @brief Adds 8-bit value to MOBIBuffer\n \n @param[in,out] buf MOBIBuffer structure to be filled with data\n @param[in] data Integer to be put into the buffer\n */\nvoid mobi_buffer_add8(MOBIBuffer *buf, const uint8_t data) {\n    if (buf->offset + 1 > buf->maxlen) {\n        debug_print(\"%s\", \"Buffer full\\n\");\n        buf->error = MOBI_BUFFER_END;\n        return;\n    }\n    buf->data[buf->offset++] = data;\n}\n\n/**\n @brief Adds 16-bit value to MOBIBuffer\n \n @param[in,out] buf MOBIBuffer structure to be filled with data\n @param[in] data Integer to be put into the buffer\n */\nvoid mobi_buffer_add16(MOBIBuffer *buf, const uint16_t data) {\n    if (buf->offset + 2 > buf->maxlen) {\n        debug_print(\"%s\", \"Buffer full\\n\");\n        buf->error = MOBI_BUFFER_END;\n        return;\n    }\n    unsigned char *buftr = buf->data + buf->offset;\n    *buftr++ = (uint8_t)((uint32_t)(data & 0xff00U) >> 8);\n    *buftr = (uint8_t)((uint32_t)(data & 0xffU));\n    buf->offset += 2;\n}\n\n/**\n @brief Adds 32-bit value to MOBIBuffer\n \n @param[in,out] buf MOBIBuffer structure to be filled with data\n @param[in] data Integer to be put into the buffer\n */\nvoid mobi_buffer_add32(MOBIBuffer *buf, const uint32_t data) {\n    if (buf->offset + 4 > buf->maxlen) {\n        debug_print(\"%s\", \"Buffer full\\n\");\n        buf->error = MOBI_BUFFER_END;\n        return;\n    }\n    unsigned char *buftr = buf->data + buf->offset;\n    *buftr++ = (uint8_t)((uint32_t)(data & 0xff000000U) >> 24);\n    *buftr++ = (uint8_t)((uint32_t)(data & 0xff0000U) >> 16);\n    *buftr++ = (uint8_t)((uint32_t)(data & 0xff00U) >> 8);\n    *buftr = (uint8_t)((uint32_t)(data & 0xffU));\n    buf->offset += 4;\n}\n\n/**\n @brief Adds raw data to MOBIBuffer\n \n @param[in,out] buf MOBIBuffer structure to be filled with data\n @param[in] data Pointer to read data\n @param[in] len Size of the read data\n */\nvoid mobi_buffer_addraw(MOBIBuffer *buf, const unsigned char* data, const size_t len) {\n    if (buf->offset + len > buf->maxlen) {\n        debug_print(\"%s\", \"Buffer full\\n\");\n        buf->error = MOBI_BUFFER_END;\n        return;\n    }\n    memcpy(buf->data + buf->offset, data, len);\n    buf->offset += len;\n}\n\n/**\n @brief Adds string to MOBIBuffer without null terminator\n \n @param[in,out] buf MOBIBuffer structure to be filled with data\n @param[in] str Pointer to string\n */\nvoid mobi_buffer_addstring(MOBIBuffer *buf, const char *str) {\n    const size_t len = strlen(str);\n    mobi_buffer_addraw(buf, (const unsigned char *) str, len);\n}\n\n/**\n @brief Adds count of zeroes to MOBIBuffer\n \n @param[in,out] buf MOBIBuffer structure to be filled with data\n @param[in] count Number of zeroes to be put into the buffer\n */\nvoid mobi_buffer_addzeros(MOBIBuffer *buf, const size_t count) {\n    if (buf->offset + count > buf->maxlen) {\n        debug_print(\"%s\", \"Buffer full\\n\");\n        buf->error = MOBI_BUFFER_END;\n        return;\n    }\n    memset(buf->data + buf->offset, 0, count);\n    buf->offset += count;\n}\n\n/**\n @brief Reads 8-bit value from MOBIBuffer\n \n @param[in] buf MOBIBuffer structure containing data\n @return Read value, 0 if end of buffer is encountered\n */\nuint8_t mobi_buffer_get8(MOBIBuffer *buf) {\n    if (buf->offset + 1 > buf->maxlen) {\n        debug_print(\"%s\", \"End of buffer\\n\");\n        buf->error = MOBI_BUFFER_END;\n        return 0;\n    }\n    return buf->data[buf->offset++];\n}\n\n/**\n @brief Reads 16-bit value from MOBIBuffer\n \n @param[in] buf MOBIBuffer structure containing data\n @return Read value, 0 if end of buffer is encountered\n */\nuint16_t mobi_buffer_get16(MOBIBuffer *buf) {\n    if (buf->offset + 2 > buf->maxlen) {\n        debug_print(\"%s\", \"End of buffer\\n\");\n        buf->error = MOBI_BUFFER_END;\n        return 0;\n    }\n    uint16_t val;\n    val = (uint16_t)((uint16_t) buf->data[buf->offset] << 8 | (uint16_t) buf->data[buf->offset + 1]);\n    buf->offset += 2;\n    return val;\n}\n\n/**\n @brief Reads 32-bit value from MOBIBuffer\n \n @param[in] buf MOBIBuffer structure containing data\n @return Read value, 0 if end of buffer is encountered\n */\nuint32_t mobi_buffer_get32(MOBIBuffer *buf) {\n    if (buf->offset + 4 > buf->maxlen) {\n        debug_print(\"%s\", \"End of buffer\\n\");\n        buf->error = MOBI_BUFFER_END;\n        return 0;\n    }\n    uint32_t val;\n    val = (uint32_t) buf->data[buf->offset] << 24 | (uint32_t) buf->data[buf->offset + 1] << 16 | (uint32_t) buf->data[buf->offset + 2] << 8 | (uint32_t) buf->data[buf->offset + 3];\n    buf->offset += 4;\n    return val;\n}\n\n/**\n @brief Reads variable length value from MOBIBuffer\n \n Internal function for wrappers: \n mobi_buffer_get_varlen();\n mobi_buffer_get_varlen_dec();\n \n Reads maximum 4 bytes from the buffer. Stops when byte has bit 7 set.\n \n @param[in] buf MOBIBuffer structure containing data\n @param[out] len Value will be increased by number of bytes read\n @param[in] direction 1 - read buffer forward, -1 - read buffer backwards\n @return Read value, 0 if end of buffer is encountered\n */\nstatic uint32_t _buffer_get_varlen(MOBIBuffer *buf, size_t *len, const int direction) {\n    uint32_t val = 0;\n    uint8_t byte_count = 0;\n    uint8_t byte;\n    const uint8_t stop_flag = 0x80;\n    const uint8_t mask = 0x7f;\n    uint32_t shift = 0;\n    do {\n        if (direction == 1) {\n            if (buf->offset + 1 > buf->maxlen) {\n                debug_print(\"%s\", \"End of buffer\\n\");\n                buf->error = MOBI_BUFFER_END;\n                return val;\n            }\n            byte = buf->data[buf->offset++];\n            val <<= 7;\n            val |= (byte & mask);\n        } else {\n            if (buf->offset < 1) {\n                debug_print(\"%s\", \"End of buffer\\n\");\n                buf->error = MOBI_BUFFER_END;\n                return val;\n            }\n            byte = buf->data[buf->offset--];\n            val = val | (uint32_t)(byte & mask) << shift;\n            shift += 7;\n        }        \n        (*len)++;\n        byte_count++;\n    } while (!(byte & stop_flag) && (byte_count < 4));\n    return val;\n}\n\n/**\n @brief Reads variable length value from MOBIBuffer\n \n Reads maximum 4 bytes from the buffer. Stops when byte has bit 7 set.\n \n @param[in] buf MOBIBuffer structure containing data\n @param[out] len Value will be increased by number of bytes read\n @return Read value, 0 if end of buffer is encountered\n */\nuint32_t mobi_buffer_get_varlen(MOBIBuffer *buf, size_t *len) {\n    return _buffer_get_varlen(buf, len, 1);\n}\n\n/**\n @brief Reads variable length value from MOBIBuffer going backwards\n \n Reads maximum 4 bytes from the buffer. Stops when byte has bit 7 set.\n \n @param[in] buf MOBIBuffer structure containing data\n @param[out] len Value will be increased by number of bytes read\n @return Read value, 0 if end of buffer is encountered\n */\nuint32_t mobi_buffer_get_varlen_dec(MOBIBuffer *buf, size_t *len) {\n    return _buffer_get_varlen(buf, len, -1);\n}\n\n/**\n @brief Reads raw data from MOBIBuffer and pads it with zero character\n \n @param[out] str Destination for string read from buffer. Length must be (len + 1)\n @param[in] buf MOBIBuffer structure containing data\n @param[in] len Length of the data to be read from buffer\n */\nvoid mobi_buffer_getstring(char *str, MOBIBuffer *buf, const size_t len) {\n    if (!str) {\n        buf->error = MOBI_PARAM_ERR;\n        return;\n    }\n    if (buf->offset + len > buf->maxlen) {\n        debug_print(\"%s\", \"End of buffer\\n\");\n        buf->error = MOBI_BUFFER_END;\n        str[0] = '\\0';\n        return;\n    }\n    memcpy(str, buf->data + buf->offset, len);\n    str[len] = '\\0';\n    buf->offset += len;\n}\n\n/**\n @brief Reads raw data from MOBIBuffer, appends it to a string and pads it with zero character\n \n @param[in,out] str A string to which data will be appended\n @param[in] buf MOBIBuffer structure containing data\n @param[in] len Length of the data to be read from buffer\n */\nvoid mobi_buffer_appendstring(char *str, MOBIBuffer *buf, const size_t len) {\n    if (!str) {\n        buf->error = MOBI_PARAM_ERR;\n        return;\n    }\n    if (buf->offset + len > buf->maxlen) {\n        debug_print(\"%s\", \"End of buffer\\n\");\n        buf->error = MOBI_BUFFER_END;\n        return;\n    }\n    size_t str_len = strlen(str);\n    memcpy(str + str_len, buf->data + buf->offset, len);\n    str[str_len + len] = '\\0';\n    buf->offset += len;\n}\n\n/**\n @brief Reads raw data from MOBIBuffer\n \n @param[out] data Destination to which data will be appended\n @param[in] buf MOBIBuffer structure containing data\n @param[in] len Length of the data to be read from buffer\n */\nvoid mobi_buffer_getraw(void *data, MOBIBuffer *buf, const size_t len) {\n    if (!data) {\n        buf->error = MOBI_PARAM_ERR;\n        return;\n    }\n    if (buf->offset + len > buf->maxlen) {\n        debug_print(\"%s\", \"End of buffer\\n\");\n        buf->error = MOBI_BUFFER_END;\n        return;\n    }\n    memcpy(data, buf->data + buf->offset, len);\n    buf->offset += len;\n}\n\n/**\n @brief Get pointer to MOBIBuffer data at offset\n \n @param[in] buf MOBIBuffer structure containing data\n @param[in] len Check if requested length is available in buffer\n @return Pointer to offset, or NULL on failure\n */\nunsigned char * mobi_buffer_getpointer(MOBIBuffer *buf, const size_t len) {\n    if (buf->offset + len > buf->maxlen) {\n        debug_print(\"%s\", \"End of buffer\\n\");\n        buf->error = MOBI_BUFFER_END;\n        return NULL;\n    }\n    buf->offset += len;\n    return buf->data + buf->offset - len;\n}\n\n/**\n @brief Read 8-bit value from MOBIBuffer into allocated memory\n \n Read 8-bit value from buffer into memory allocated by the function.\n Returns pointer to the value, which must be freed later.\n If the data is not accessible function will return null pointer.\n \n @param[out] val Pointer to value or null pointer on failure\n @param[in] buf MOBIBuffer structure containing data\n */\nvoid mobi_buffer_dup8(uint8_t **val, MOBIBuffer *buf) {\n    *val = NULL;\n    if (buf->offset + 1 > buf->maxlen) {\n        return;\n    }\n    *val = malloc(sizeof(uint8_t));\n    if (*val == NULL) {\n        return;\n    }\n    **val = mobi_buffer_get8(buf);\n}\n\n/**\n @brief Read 16-bit value from MOBIBuffer into allocated memory\n \n Read 16-bit value from buffer into allocated memory.\n Returns pointer to the value, which must be freed later.\n If the data is not accessible function will return null pointer.\n \n @param[out] val Pointer to value or null pointer on failure\n @param[in] buf MOBIBuffer structure containing data\n */\nvoid mobi_buffer_dup16(uint16_t **val, MOBIBuffer *buf) {\n    *val = NULL;\n    if (buf->offset + 2 > buf->maxlen) {\n        return;\n    }\n    *val = malloc(sizeof(uint16_t));\n    if (*val == NULL) {\n        return;\n    }\n    **val = mobi_buffer_get16(buf);\n}\n\n/**\n @brief Read 32-bit value from MOBIBuffer into allocated memory\n \n Read 32-bit value from buffer into allocated memory.\n Returns pointer to the value, which must be freed later.\n If the data is not accessible function will return null pointer.\n \n @param[out] val Pointer to value\n @param[in] buf MOBIBuffer structure containing data\n */\nvoid mobi_buffer_dup32(uint32_t **val, MOBIBuffer *buf) {\n    *val = NULL;\n    if (buf->offset + 4 > buf->maxlen) {\n        return;\n    }\n    *val = malloc(sizeof(uint32_t));\n    if (*val == NULL) {\n        return;\n    }\n    **val = mobi_buffer_get32(buf);\n}\n\n/**\n @brief Copy 8-bit value from one MOBIBuffer into another\n \n @param[out] dest Destination buffer\n @param[in] source Source buffer\n */\nvoid mobi_buffer_copy8(MOBIBuffer *dest, MOBIBuffer *source) {\n    mobi_buffer_add8(dest, mobi_buffer_get8(source));\n}\n\n/**\n @brief Copy raw value from one MOBIBuffer into another\n \n @param[out] dest Destination buffer\n @param[in] source Source buffer\n @param[in] len Number of bytes to copy\n */\nvoid mobi_buffer_copy(MOBIBuffer *dest, MOBIBuffer *source, const size_t len) {\n    if (source->offset + len > source->maxlen) {\n        debug_print(\"%s\", \"End of buffer\\n\");\n        source->error = MOBI_BUFFER_END;\n        return;\n    }\n    if (dest->offset + len > dest->maxlen) {\n        debug_print(\"%s\", \"End of buffer\\n\");\n        dest->error = MOBI_BUFFER_END;\n        return;\n    }\n    memcpy(dest->data + dest->offset, source->data + source->offset, len);\n    dest->offset += len;\n    source->offset += len;\n}\n\n/**\n @brief Copy raw value within one MOBIBuffer\n \n Memmove len bytes from offset (relative to current position)\n to current position in buffer and advance buffer position.\n Data may overlap.\n \n @param[out] buf Buffer\n @param[in] offset Offset to read from\n @param[in] len Number of bytes to copy\n */\nvoid mobi_buffer_move(MOBIBuffer *buf, const int offset, const size_t len) {\n    size_t aoffset = (size_t) abs(offset);\n    unsigned char *source = buf->data + buf->offset;\n    if (offset >= 0) {\n        if (buf->offset + aoffset + len > buf->maxlen) {\n            debug_print(\"%s\", \"End of buffer\\n\");\n            buf->error = MOBI_BUFFER_END;\n            return;\n        }\n        source += aoffset;\n    } else {\n        if (buf->offset < aoffset) {\n            debug_print(\"%s\", \"End of buffer\\n\");\n            buf->error = MOBI_BUFFER_END;\n            return;\n        }\n        source -= aoffset;\n    }\n    memmove(buf->data + buf->offset, source, len);\n    buf->offset += len;\n}\n\n/**\n @brief Check if buffer data header contains magic signature\n \n @param[in] buf MOBIBuffer buffer containing data\n @param[in] magic Magic signature\n @return boolean true on match, false otherwise\n */\nbool mobi_buffer_match_magic(MOBIBuffer *buf, const char *magic) {\n    const size_t magic_length = strlen(magic);\n    if (buf->offset + magic_length > buf->maxlen) {\n        return false;\n    }\n    if (memcmp(buf->data + buf->offset, magic, magic_length) == 0) {\n        return true;\n    }\n    return false;\n}\n\n/**\n @brief Check if buffer contains magic signature at given offset\n \n @param[in] buf MOBIBuffer buffer containing data\n @param[in] magic Magic signature\n @param[in] offset Offset\n @return boolean true on match, false otherwise\n */\nbool mobi_buffer_match_magic_offset(MOBIBuffer *buf, const char *magic, const size_t offset) {\n    bool match = false;\n    if (offset <= buf->maxlen) {\n        const size_t save_offset = buf->offset;\n        buf->offset = offset;\n        match = mobi_buffer_match_magic(buf, magic);\n        buf->offset = save_offset;\n    }\n    return match;\n}\n\n/**\n @brief Move current buffer offset by diff bytes\n \n @param[in,out] buf MOBIBuffer buffer containing data\n @param[in] diff Number of bytes by which the offset is adjusted\n */\nvoid mobi_buffer_seek(MOBIBuffer *buf, const int diff) {\n    size_t adiff = (size_t) abs(diff);\n    if (diff >= 0) {\n        if (buf->offset + adiff <= buf->maxlen) {\n            buf->offset += adiff;\n            return;\n        }\n    } else {\n        if (buf->offset >= adiff) {\n            buf->offset -= adiff;\n            return;\n        }\n    }\n    buf->error = MOBI_BUFFER_END;\n    debug_print(\"%s\", \"End of buffer\\n\");\n}\n\n/**\n @brief Set buffer offset to pos position\n \n @param[in,out] buf MOBIBuffer buffer containing data\n @param[in] pos New position\n */\nvoid mobi_buffer_setpos(MOBIBuffer *buf, const size_t pos) {\n    if (pos <= buf->maxlen) {\n        buf->offset = pos;\n        return;\n    }\n    buf->error = MOBI_BUFFER_END;\n    debug_print(\"%s\", \"End of buffer\\n\");\n}\n\n/**\n @brief Free pointer to MOBIBuffer structure and pointer to data\n \n Free data initialized with mobi_buffer_init();\n \n @param[in] buf MOBIBuffer structure\n */\nvoid mobi_buffer_free(MOBIBuffer *buf) {\n\tif (buf == NULL) { return; }\n\tif (buf->data != NULL) {\n\t\tfree(buf->data);\n\t}\n\tfree(buf);\n}\n\n/**\n @brief Free pointer to MOBIBuffer structure\n \n Free data initialized with mobi_buffer_init_null();\n Unlike mobi_buffer_free() it will not free pointer to buf->data\n \n @param[in] buf MOBIBuffer structure\n */\nvoid mobi_buffer_free_null(MOBIBuffer *buf) {\n\tif (buf == NULL) { return; }\n\tfree(buf);\n}\n"], "fixing_code": ["/** @file buffer.c\n *  @brief Functions to read/write raw big endian data\n *\n * Copyright (c) 2014 Bartek Fabiszewski\n * http://www.fabiszewski.net\n *\n * This file is part of libmobi.\n * Licensed under LGPL, either version 3, or any later.\n * See <http://www.gnu.org/licenses/>\n */\n\n#include <stdlib.h>\n#include <string.h>\n#include \"buffer.h\"\n#include \"debug.h\"\n\n/**\n @brief Initializer for MOBIBuffer structure\n \n It allocates memory for structure and for data.\n Memory should be freed with mobi_buffer_free().\n \n @param[in] len Size of data to be allocated for the buffer\n @return MOBIBuffer on success, NULL otherwise\n */\nMOBIBuffer * mobi_buffer_init(const size_t len) {\n    unsigned char *data = malloc(len);\n    if (data == NULL) {\n        debug_print(\"%s\", \"Buffer data allocation failed\\n\");\n        return NULL;\n    }\n    MOBIBuffer *buf = mobi_buffer_init_null(data, len);\n    if (buf == NULL) {\n        free(data);\n    }\n    return buf;\n}\n\n/**\n @brief Initializer for MOBIBuffer structure\n \n It allocates memory for structure but, unlike mobi_buffer_init(), it does not allocate memory for data.\n Instead it works on external data.\n Memory should be freed with mobi_buffer_free_null() (buf->data will not be deallocated).\n \n @param[in,out] data Set data as buffer data\n @param[in] len Size of data held by the buffer\n @return MOBIBuffer on success, NULL otherwise\n */\nMOBIBuffer * mobi_buffer_init_null(unsigned char *data, const size_t len) {\n    MOBIBuffer *buf = malloc(sizeof(MOBIBuffer));\n\tif (buf == NULL) {\n        debug_print(\"%s\", \"Buffer allocation failed\\n\");\n        return NULL;\n    }\n    buf->data = data;\n\tbuf->offset = 0;\n\tbuf->maxlen = len;\n    buf->error = MOBI_SUCCESS;\n\treturn buf;\n}\n\n/**\n @brief Resize buffer\n \n Smaller size than offset will cause data truncation.\n \n @param[in,out] buf MOBIBuffer structure to be filled with data\n @param[in] newlen New buffer size\n */\nvoid mobi_buffer_resize(MOBIBuffer *buf, const size_t newlen) {\n    unsigned char *tmp = realloc(buf->data, newlen);\n    if (tmp == NULL) {\n        debug_print(\"%s\", \"Buffer allocation failed\\n\");\n        buf->error = MOBI_MALLOC_FAILED;\n        return;\n    }\n    buf->data = tmp;\n    buf->maxlen = newlen;\n    if (buf->offset >= newlen) {\n        buf->offset = newlen - 1;\n    }\n    debug_print(\"Buffer successfully resized to %zu\\n\", newlen);\n    buf->error = MOBI_SUCCESS;\n}\n\n/**\n @brief Adds 8-bit value to MOBIBuffer\n \n @param[in,out] buf MOBIBuffer structure to be filled with data\n @param[in] data Integer to be put into the buffer\n */\nvoid mobi_buffer_add8(MOBIBuffer *buf, const uint8_t data) {\n    if (buf->offset + 1 > buf->maxlen) {\n        debug_print(\"%s\", \"Buffer full\\n\");\n        buf->error = MOBI_BUFFER_END;\n        return;\n    }\n    buf->data[buf->offset++] = data;\n}\n\n/**\n @brief Adds 16-bit value to MOBIBuffer\n \n @param[in,out] buf MOBIBuffer structure to be filled with data\n @param[in] data Integer to be put into the buffer\n */\nvoid mobi_buffer_add16(MOBIBuffer *buf, const uint16_t data) {\n    if (buf->offset + 2 > buf->maxlen) {\n        debug_print(\"%s\", \"Buffer full\\n\");\n        buf->error = MOBI_BUFFER_END;\n        return;\n    }\n    unsigned char *buftr = buf->data + buf->offset;\n    *buftr++ = (uint8_t)((uint32_t)(data & 0xff00U) >> 8);\n    *buftr = (uint8_t)((uint32_t)(data & 0xffU));\n    buf->offset += 2;\n}\n\n/**\n @brief Adds 32-bit value to MOBIBuffer\n \n @param[in,out] buf MOBIBuffer structure to be filled with data\n @param[in] data Integer to be put into the buffer\n */\nvoid mobi_buffer_add32(MOBIBuffer *buf, const uint32_t data) {\n    if (buf->offset + 4 > buf->maxlen) {\n        debug_print(\"%s\", \"Buffer full\\n\");\n        buf->error = MOBI_BUFFER_END;\n        return;\n    }\n    unsigned char *buftr = buf->data + buf->offset;\n    *buftr++ = (uint8_t)((uint32_t)(data & 0xff000000U) >> 24);\n    *buftr++ = (uint8_t)((uint32_t)(data & 0xff0000U) >> 16);\n    *buftr++ = (uint8_t)((uint32_t)(data & 0xff00U) >> 8);\n    *buftr = (uint8_t)((uint32_t)(data & 0xffU));\n    buf->offset += 4;\n}\n\n/**\n @brief Adds raw data to MOBIBuffer\n \n @param[in,out] buf MOBIBuffer structure to be filled with data\n @param[in] data Pointer to read data\n @param[in] len Size of the read data\n */\nvoid mobi_buffer_addraw(MOBIBuffer *buf, const unsigned char* data, const size_t len) {\n    if (buf->offset + len > buf->maxlen) {\n        debug_print(\"%s\", \"Buffer full\\n\");\n        buf->error = MOBI_BUFFER_END;\n        return;\n    }\n    memcpy(buf->data + buf->offset, data, len);\n    buf->offset += len;\n}\n\n/**\n @brief Adds string to MOBIBuffer without null terminator\n \n @param[in,out] buf MOBIBuffer structure to be filled with data\n @param[in] str Pointer to string\n */\nvoid mobi_buffer_addstring(MOBIBuffer *buf, const char *str) {\n    const size_t len = strlen(str);\n    mobi_buffer_addraw(buf, (const unsigned char *) str, len);\n}\n\n/**\n @brief Adds count of zeroes to MOBIBuffer\n \n @param[in,out] buf MOBIBuffer structure to be filled with data\n @param[in] count Number of zeroes to be put into the buffer\n */\nvoid mobi_buffer_addzeros(MOBIBuffer *buf, const size_t count) {\n    if (buf->offset + count > buf->maxlen) {\n        debug_print(\"%s\", \"Buffer full\\n\");\n        buf->error = MOBI_BUFFER_END;\n        return;\n    }\n    memset(buf->data + buf->offset, 0, count);\n    buf->offset += count;\n}\n\n/**\n @brief Reads 8-bit value from MOBIBuffer\n \n @param[in] buf MOBIBuffer structure containing data\n @return Read value, 0 if end of buffer is encountered\n */\nuint8_t mobi_buffer_get8(MOBIBuffer *buf) {\n    if (buf->offset + 1 > buf->maxlen) {\n        debug_print(\"%s\", \"End of buffer\\n\");\n        buf->error = MOBI_BUFFER_END;\n        return 0;\n    }\n    return buf->data[buf->offset++];\n}\n\n/**\n @brief Reads 16-bit value from MOBIBuffer\n \n @param[in] buf MOBIBuffer structure containing data\n @return Read value, 0 if end of buffer is encountered\n */\nuint16_t mobi_buffer_get16(MOBIBuffer *buf) {\n    if (buf->offset + 2 > buf->maxlen) {\n        debug_print(\"%s\", \"End of buffer\\n\");\n        buf->error = MOBI_BUFFER_END;\n        return 0;\n    }\n    uint16_t val;\n    val = (uint16_t)((uint16_t) buf->data[buf->offset] << 8 | (uint16_t) buf->data[buf->offset + 1]);\n    buf->offset += 2;\n    return val;\n}\n\n/**\n @brief Reads 32-bit value from MOBIBuffer\n \n @param[in] buf MOBIBuffer structure containing data\n @return Read value, 0 if end of buffer is encountered\n */\nuint32_t mobi_buffer_get32(MOBIBuffer *buf) {\n    if (buf->offset + 4 > buf->maxlen) {\n        debug_print(\"%s\", \"End of buffer\\n\");\n        buf->error = MOBI_BUFFER_END;\n        return 0;\n    }\n    uint32_t val;\n    val = (uint32_t) buf->data[buf->offset] << 24 | (uint32_t) buf->data[buf->offset + 1] << 16 | (uint32_t) buf->data[buf->offset + 2] << 8 | (uint32_t) buf->data[buf->offset + 3];\n    buf->offset += 4;\n    return val;\n}\n\n/**\n @brief Reads variable length value from MOBIBuffer\n \n Internal function for wrappers: \n mobi_buffer_get_varlen();\n mobi_buffer_get_varlen_dec();\n \n Reads maximum 4 bytes from the buffer. Stops when byte has bit 7 set.\n \n @param[in] buf MOBIBuffer structure containing data\n @param[out] len Value will be increased by number of bytes read\n @param[in] direction 1 - read buffer forward, -1 - read buffer backwards\n @return Read value, 0 if end of buffer is encountered\n */\nstatic uint32_t _buffer_get_varlen(MOBIBuffer *buf, size_t *len, const int direction) {\n    uint32_t val = 0;\n    uint8_t byte_count = 0;\n    uint8_t byte;\n    const uint8_t stop_flag = 0x80;\n    const uint8_t mask = 0x7f;\n    uint32_t shift = 0;\n    do {\n        if (direction == 1) {\n            if (buf->offset + 1 > buf->maxlen) {\n                debug_print(\"%s\", \"End of buffer\\n\");\n                buf->error = MOBI_BUFFER_END;\n                return val;\n            }\n            byte = buf->data[buf->offset++];\n            val <<= 7;\n            val |= (byte & mask);\n        } else {\n            if (buf->offset < 1) {\n                debug_print(\"%s\", \"End of buffer\\n\");\n                buf->error = MOBI_BUFFER_END;\n                return val;\n            }\n            byte = buf->data[buf->offset--];\n            val = val | (uint32_t)(byte & mask) << shift;\n            shift += 7;\n        }        \n        (*len)++;\n        byte_count++;\n    } while (!(byte & stop_flag) && (byte_count < 4));\n    return val;\n}\n\n/**\n @brief Reads variable length value from MOBIBuffer\n \n Reads maximum 4 bytes from the buffer. Stops when byte has bit 7 set.\n \n @param[in] buf MOBIBuffer structure containing data\n @param[out] len Value will be increased by number of bytes read\n @return Read value, 0 if end of buffer is encountered\n */\nuint32_t mobi_buffer_get_varlen(MOBIBuffer *buf, size_t *len) {\n    return _buffer_get_varlen(buf, len, 1);\n}\n\n/**\n @brief Reads variable length value from MOBIBuffer going backwards\n \n Reads maximum 4 bytes from the buffer. Stops when byte has bit 7 set.\n \n @param[in] buf MOBIBuffer structure containing data\n @param[out] len Value will be increased by number of bytes read\n @return Read value, 0 if end of buffer is encountered\n */\nuint32_t mobi_buffer_get_varlen_dec(MOBIBuffer *buf, size_t *len) {\n    return _buffer_get_varlen(buf, len, -1);\n}\n\n/**\n @brief Reads raw data from MOBIBuffer and pads it with zero character\n \n @param[out] str Destination for string read from buffer. Length must be (len + 1)\n @param[in] buf MOBIBuffer structure containing data\n @param[in] len Length of the data to be read from buffer\n */\nvoid mobi_buffer_getstring(char *str, MOBIBuffer *buf, const size_t len) {\n    if (!str) {\n        buf->error = MOBI_PARAM_ERR;\n        return;\n    }\n    if (buf->offset + len > buf->maxlen) {\n        debug_print(\"%s\", \"End of buffer\\n\");\n        buf->error = MOBI_BUFFER_END;\n        str[0] = '\\0';\n        return;\n    }\n    memcpy(str, buf->data + buf->offset, len);\n    str[len] = '\\0';\n    buf->offset += len;\n}\n\n/**\n @brief Reads raw data from MOBIBuffer, appends it to a string and pads it with zero character\n \n @param[in,out] str A string to which data will be appended\n @param[in] buf MOBIBuffer structure containing data\n @param[in] len Length of the data to be read from buffer\n */\nvoid mobi_buffer_appendstring(char *str, MOBIBuffer *buf, const size_t len) {\n    if (!str) {\n        buf->error = MOBI_PARAM_ERR;\n        return;\n    }\n    if (buf->offset + len > buf->maxlen) {\n        debug_print(\"%s\", \"End of buffer\\n\");\n        buf->error = MOBI_BUFFER_END;\n        return;\n    }\n    size_t str_len = strlen(str);\n    memcpy(str + str_len, buf->data + buf->offset, len);\n    str[str_len + len] = '\\0';\n    buf->offset += len;\n}\n\n/**\n @brief Reads raw data from MOBIBuffer\n \n @param[out] data Destination to which data will be appended\n @param[in] buf MOBIBuffer structure containing data\n @param[in] len Length of the data to be read from buffer\n */\nvoid mobi_buffer_getraw(void *data, MOBIBuffer *buf, const size_t len) {\n    if (!data) {\n        buf->error = MOBI_PARAM_ERR;\n        return;\n    }\n    if (buf->offset + len > buf->maxlen) {\n        debug_print(\"%s\", \"End of buffer\\n\");\n        buf->error = MOBI_BUFFER_END;\n        return;\n    }\n    memcpy(data, buf->data + buf->offset, len);\n    buf->offset += len;\n}\n\n/**\n @brief Get pointer to MOBIBuffer data at offset\n \n @param[in] buf MOBIBuffer structure containing data\n @param[in] len Check if requested length is available in buffer\n @return Pointer to offset, or NULL on failure\n */\nunsigned char * mobi_buffer_getpointer(MOBIBuffer *buf, const size_t len) {\n    if (buf->offset + len > buf->maxlen) {\n        debug_print(\"%s\", \"End of buffer\\n\");\n        buf->error = MOBI_BUFFER_END;\n        return NULL;\n    }\n    buf->offset += len;\n    return buf->data + buf->offset - len;\n}\n\n/**\n @brief Read 8-bit value from MOBIBuffer into allocated memory\n \n Read 8-bit value from buffer into memory allocated by the function.\n Returns pointer to the value, which must be freed later.\n If the data is not accessible function will return null pointer.\n \n @param[out] val Pointer to value or null pointer on failure\n @param[in] buf MOBIBuffer structure containing data\n */\nvoid mobi_buffer_dup8(uint8_t **val, MOBIBuffer *buf) {\n    *val = NULL;\n    if (buf->offset + 1 > buf->maxlen) {\n        return;\n    }\n    *val = malloc(sizeof(uint8_t));\n    if (*val == NULL) {\n        return;\n    }\n    **val = mobi_buffer_get8(buf);\n}\n\n/**\n @brief Read 16-bit value from MOBIBuffer into allocated memory\n \n Read 16-bit value from buffer into allocated memory.\n Returns pointer to the value, which must be freed later.\n If the data is not accessible function will return null pointer.\n \n @param[out] val Pointer to value or null pointer on failure\n @param[in] buf MOBIBuffer structure containing data\n */\nvoid mobi_buffer_dup16(uint16_t **val, MOBIBuffer *buf) {\n    *val = NULL;\n    if (buf->offset + 2 > buf->maxlen) {\n        return;\n    }\n    *val = malloc(sizeof(uint16_t));\n    if (*val == NULL) {\n        return;\n    }\n    **val = mobi_buffer_get16(buf);\n}\n\n/**\n @brief Read 32-bit value from MOBIBuffer into allocated memory\n \n Read 32-bit value from buffer into allocated memory.\n Returns pointer to the value, which must be freed later.\n If the data is not accessible function will return null pointer.\n \n @param[out] val Pointer to value\n @param[in] buf MOBIBuffer structure containing data\n */\nvoid mobi_buffer_dup32(uint32_t **val, MOBIBuffer *buf) {\n    *val = NULL;\n    if (buf->offset + 4 > buf->maxlen) {\n        return;\n    }\n    *val = malloc(sizeof(uint32_t));\n    if (*val == NULL) {\n        return;\n    }\n    **val = mobi_buffer_get32(buf);\n}\n\n/**\n @brief Copy 8-bit value from one MOBIBuffer into another\n \n @param[out] dest Destination buffer\n @param[in] source Source buffer\n */\nvoid mobi_buffer_copy8(MOBIBuffer *dest, MOBIBuffer *source) {\n    mobi_buffer_add8(dest, mobi_buffer_get8(source));\n}\n\n/**\n @brief Copy raw value from one MOBIBuffer into another\n \n @param[out] dest Destination buffer\n @param[in] source Source buffer\n @param[in] len Number of bytes to copy\n */\nvoid mobi_buffer_copy(MOBIBuffer *dest, MOBIBuffer *source, const size_t len) {\n    if (source->offset + len > source->maxlen) {\n        debug_print(\"%s\", \"End of buffer\\n\");\n        source->error = MOBI_BUFFER_END;\n        return;\n    }\n    if (dest->offset + len > dest->maxlen) {\n        debug_print(\"%s\", \"End of buffer\\n\");\n        dest->error = MOBI_BUFFER_END;\n        return;\n    }\n    memcpy(dest->data + dest->offset, source->data + source->offset, len);\n    dest->offset += len;\n    source->offset += len;\n}\n\n/**\n @brief Copy raw value within one MOBIBuffer\n \n Memmove len bytes from offset (relative to current position)\n to current position in buffer and advance buffer position.\n Data may overlap.\n \n @param[out] buf Buffer\n @param[in] offset Offset to read from\n @param[in] len Number of bytes to copy\n */\nvoid mobi_buffer_move(MOBIBuffer *buf, const int offset, const size_t len) {\n    size_t aoffset = (size_t) abs(offset);\n    unsigned char *source = buf->data + buf->offset;\n    if (offset >= 0) {\n        if (buf->offset + aoffset + len > buf->maxlen) {\n            debug_print(\"%s\", \"End of buffer\\n\");\n            buf->error = MOBI_BUFFER_END;\n            return;\n        }\n        source += aoffset;\n    } else {\n        if ( (buf->offset < aoffset) || (buf->offset + len > buf->maxlen) ) {\n            debug_print(\"%s\", \"Beyond start/end of buffer\\n\");\n            buf->error = MOBI_BUFFER_END;\n            return;\n        }\n        source -= aoffset;\n    }\n    memmove(buf->data + buf->offset, source, len);\n    buf->offset += len;\n}\n\n/**\n @brief Check if buffer data header contains magic signature\n \n @param[in] buf MOBIBuffer buffer containing data\n @param[in] magic Magic signature\n @return boolean true on match, false otherwise\n */\nbool mobi_buffer_match_magic(MOBIBuffer *buf, const char *magic) {\n    const size_t magic_length = strlen(magic);\n    if (buf->offset + magic_length > buf->maxlen) {\n        return false;\n    }\n    if (memcmp(buf->data + buf->offset, magic, magic_length) == 0) {\n        return true;\n    }\n    return false;\n}\n\n/**\n @brief Check if buffer contains magic signature at given offset\n \n @param[in] buf MOBIBuffer buffer containing data\n @param[in] magic Magic signature\n @param[in] offset Offset\n @return boolean true on match, false otherwise\n */\nbool mobi_buffer_match_magic_offset(MOBIBuffer *buf, const char *magic, const size_t offset) {\n    bool match = false;\n    if (offset <= buf->maxlen) {\n        const size_t save_offset = buf->offset;\n        buf->offset = offset;\n        match = mobi_buffer_match_magic(buf, magic);\n        buf->offset = save_offset;\n    }\n    return match;\n}\n\n/**\n @brief Move current buffer offset by diff bytes\n \n @param[in,out] buf MOBIBuffer buffer containing data\n @param[in] diff Number of bytes by which the offset is adjusted\n */\nvoid mobi_buffer_seek(MOBIBuffer *buf, const int diff) {\n    size_t adiff = (size_t) abs(diff);\n    if (diff >= 0) {\n        if (buf->offset + adiff <= buf->maxlen) {\n            buf->offset += adiff;\n            return;\n        }\n    } else {\n        if (buf->offset >= adiff) {\n            buf->offset -= adiff;\n            return;\n        }\n    }\n    buf->error = MOBI_BUFFER_END;\n    debug_print(\"%s\", \"End of buffer\\n\");\n}\n\n/**\n @brief Set buffer offset to pos position\n \n @param[in,out] buf MOBIBuffer buffer containing data\n @param[in] pos New position\n */\nvoid mobi_buffer_setpos(MOBIBuffer *buf, const size_t pos) {\n    if (pos <= buf->maxlen) {\n        buf->offset = pos;\n        return;\n    }\n    buf->error = MOBI_BUFFER_END;\n    debug_print(\"%s\", \"End of buffer\\n\");\n}\n\n/**\n @brief Free pointer to MOBIBuffer structure and pointer to data\n \n Free data initialized with mobi_buffer_init();\n \n @param[in] buf MOBIBuffer structure\n */\nvoid mobi_buffer_free(MOBIBuffer *buf) {\n\tif (buf == NULL) { return; }\n\tif (buf->data != NULL) {\n\t\tfree(buf->data);\n\t}\n\tfree(buf);\n}\n\n/**\n @brief Free pointer to MOBIBuffer structure\n \n Free data initialized with mobi_buffer_init_null();\n Unlike mobi_buffer_free() it will not free pointer to buf->data\n \n @param[in] buf MOBIBuffer structure\n */\nvoid mobi_buffer_free_null(MOBIBuffer *buf) {\n\tif (buf == NULL) { return; }\n\tfree(buf);\n}\n"], "filenames": ["src/buffer.c"], "buggy_code_start_loc": [513], "buggy_code_end_loc": [515], "fixing_code_start_loc": [513], "fixing_code_end_loc": [515], "type": "CWE-787", "message": "libmobi is vulnerable to Out-of-bounds Write", "other": {"cve": {"id": "CVE-2021-3751", "sourceIdentifier": "security@huntr.dev", "published": "2021-09-15T07:15:06.980", "lastModified": "2021-09-24T19:15:50.867", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "libmobi is vulnerable to Out-of-bounds Write"}, {"lang": "es", "value": "libmobi es vulnerable a una escritura fuera de l\u00edmites"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:C/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.6, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 2.8, "impactScore": 6.0}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}, {"source": "security@huntr.dev", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:libmobi_project:libmobi:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.7", "matchCriteriaId": "6558B4C9-1261-4014-B227-D9506EA200B6"}]}]}], "references": [{"url": "https://github.com/bfabiszewski/libmobi/commit/ab5bf0e37e540eac682a14e628853b918626e72b", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/fcb4383c-bc27-4b89-bfce-6b041f0cb769", "source": "security@huntr.dev", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/bfabiszewski/libmobi/commit/ab5bf0e37e540eac682a14e628853b918626e72b"}}