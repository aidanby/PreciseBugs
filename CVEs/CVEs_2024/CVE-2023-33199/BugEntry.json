{"buggy_code": ["// Code generated by go-swagger; DO NOT EDIT.\n\n//\n// Copyright 2021 The Sigstore Authors.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage models\n\n// This file was generated by the swagger tool.\n// Editing this file might prove futile when you re-run the swagger generate command\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"strconv\"\n\n\t\"github.com/go-openapi/errors\"\n\t\"github.com/go-openapi/strfmt\"\n\t\"github.com/go-openapi/swag\"\n\t\"github.com/go-openapi/validate\"\n)\n\n// IntotoV002Schema intoto v0.0.2 Schema\n//\n// # Schema for intoto object\n//\n// swagger:model intotoV002Schema\ntype IntotoV002Schema struct {\n\n\t// content\n\t// Required: true\n\tContent *IntotoV002SchemaContent `json:\"content\"`\n}\n\n// Validate validates this intoto v002 schema\nfunc (m *IntotoV002Schema) Validate(formats strfmt.Registry) error {\n\tvar res []error\n\n\tif err := m.validateContent(formats); err != nil {\n\t\tres = append(res, err)\n\t}\n\n\tif len(res) > 0 {\n\t\treturn errors.CompositeValidationError(res...)\n\t}\n\treturn nil\n}\n\nfunc (m *IntotoV002Schema) validateContent(formats strfmt.Registry) error {\n\n\tif err := validate.Required(\"content\", \"body\", m.Content); err != nil {\n\t\treturn err\n\t}\n\n\tif m.Content != nil {\n\t\tif err := m.Content.Validate(formats); err != nil {\n\t\t\tif ve, ok := err.(*errors.Validation); ok {\n\t\t\t\treturn ve.ValidateName(\"content\")\n\t\t\t} else if ce, ok := err.(*errors.CompositeError); ok {\n\t\t\t\treturn ce.ValidateName(\"content\")\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// ContextValidate validate this intoto v002 schema based on the context it is used\nfunc (m *IntotoV002Schema) ContextValidate(ctx context.Context, formats strfmt.Registry) error {\n\tvar res []error\n\n\tif err := m.contextValidateContent(ctx, formats); err != nil {\n\t\tres = append(res, err)\n\t}\n\n\tif len(res) > 0 {\n\t\treturn errors.CompositeValidationError(res...)\n\t}\n\treturn nil\n}\n\nfunc (m *IntotoV002Schema) contextValidateContent(ctx context.Context, formats strfmt.Registry) error {\n\n\tif m.Content != nil {\n\t\tif err := m.Content.ContextValidate(ctx, formats); err != nil {\n\t\t\tif ve, ok := err.(*errors.Validation); ok {\n\t\t\t\treturn ve.ValidateName(\"content\")\n\t\t\t} else if ce, ok := err.(*errors.CompositeError); ok {\n\t\t\t\treturn ce.ValidateName(\"content\")\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// MarshalBinary interface implementation\nfunc (m *IntotoV002Schema) MarshalBinary() ([]byte, error) {\n\tif m == nil {\n\t\treturn nil, nil\n\t}\n\treturn swag.WriteJSON(m)\n}\n\n// UnmarshalBinary interface implementation\nfunc (m *IntotoV002Schema) UnmarshalBinary(b []byte) error {\n\tvar res IntotoV002Schema\n\tif err := swag.ReadJSON(b, &res); err != nil {\n\t\treturn err\n\t}\n\t*m = res\n\treturn nil\n}\n\n// IntotoV002SchemaContent intoto v002 schema content\n//\n// swagger:model IntotoV002SchemaContent\ntype IntotoV002SchemaContent struct {\n\n\t// envelope\n\t// Required: true\n\tEnvelope *IntotoV002SchemaContentEnvelope `json:\"envelope\"`\n\n\t// hash\n\tHash *IntotoV002SchemaContentHash `json:\"hash,omitempty\"`\n\n\t// payload hash\n\tPayloadHash *IntotoV002SchemaContentPayloadHash `json:\"payloadHash,omitempty\"`\n}\n\n// Validate validates this intoto v002 schema content\nfunc (m *IntotoV002SchemaContent) Validate(formats strfmt.Registry) error {\n\tvar res []error\n\n\tif err := m.validateEnvelope(formats); err != nil {\n\t\tres = append(res, err)\n\t}\n\n\tif err := m.validateHash(formats); err != nil {\n\t\tres = append(res, err)\n\t}\n\n\tif err := m.validatePayloadHash(formats); err != nil {\n\t\tres = append(res, err)\n\t}\n\n\tif len(res) > 0 {\n\t\treturn errors.CompositeValidationError(res...)\n\t}\n\treturn nil\n}\n\nfunc (m *IntotoV002SchemaContent) validateEnvelope(formats strfmt.Registry) error {\n\n\tif err := validate.Required(\"content\"+\".\"+\"envelope\", \"body\", m.Envelope); err != nil {\n\t\treturn err\n\t}\n\n\tif m.Envelope != nil {\n\t\tif err := m.Envelope.Validate(formats); err != nil {\n\t\t\tif ve, ok := err.(*errors.Validation); ok {\n\t\t\t\treturn ve.ValidateName(\"content\" + \".\" + \"envelope\")\n\t\t\t} else if ce, ok := err.(*errors.CompositeError); ok {\n\t\t\t\treturn ce.ValidateName(\"content\" + \".\" + \"envelope\")\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc (m *IntotoV002SchemaContent) validateHash(formats strfmt.Registry) error {\n\tif swag.IsZero(m.Hash) { // not required\n\t\treturn nil\n\t}\n\n\tif m.Hash != nil {\n\t\tif err := m.Hash.Validate(formats); err != nil {\n\t\t\tif ve, ok := err.(*errors.Validation); ok {\n\t\t\t\treturn ve.ValidateName(\"content\" + \".\" + \"hash\")\n\t\t\t} else if ce, ok := err.(*errors.CompositeError); ok {\n\t\t\t\treturn ce.ValidateName(\"content\" + \".\" + \"hash\")\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc (m *IntotoV002SchemaContent) validatePayloadHash(formats strfmt.Registry) error {\n\tif swag.IsZero(m.PayloadHash) { // not required\n\t\treturn nil\n\t}\n\n\tif m.PayloadHash != nil {\n\t\tif err := m.PayloadHash.Validate(formats); err != nil {\n\t\t\tif ve, ok := err.(*errors.Validation); ok {\n\t\t\t\treturn ve.ValidateName(\"content\" + \".\" + \"payloadHash\")\n\t\t\t} else if ce, ok := err.(*errors.CompositeError); ok {\n\t\t\t\treturn ce.ValidateName(\"content\" + \".\" + \"payloadHash\")\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// ContextValidate validate this intoto v002 schema content based on the context it is used\nfunc (m *IntotoV002SchemaContent) ContextValidate(ctx context.Context, formats strfmt.Registry) error {\n\tvar res []error\n\n\tif err := m.contextValidateEnvelope(ctx, formats); err != nil {\n\t\tres = append(res, err)\n\t}\n\n\tif err := m.contextValidateHash(ctx, formats); err != nil {\n\t\tres = append(res, err)\n\t}\n\n\tif err := m.contextValidatePayloadHash(ctx, formats); err != nil {\n\t\tres = append(res, err)\n\t}\n\n\tif len(res) > 0 {\n\t\treturn errors.CompositeValidationError(res...)\n\t}\n\treturn nil\n}\n\nfunc (m *IntotoV002SchemaContent) contextValidateEnvelope(ctx context.Context, formats strfmt.Registry) error {\n\n\tif m.Envelope != nil {\n\t\tif err := m.Envelope.ContextValidate(ctx, formats); err != nil {\n\t\t\tif ve, ok := err.(*errors.Validation); ok {\n\t\t\t\treturn ve.ValidateName(\"content\" + \".\" + \"envelope\")\n\t\t\t} else if ce, ok := err.(*errors.CompositeError); ok {\n\t\t\t\treturn ce.ValidateName(\"content\" + \".\" + \"envelope\")\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc (m *IntotoV002SchemaContent) contextValidateHash(ctx context.Context, formats strfmt.Registry) error {\n\n\tif m.Hash != nil {\n\t\tif err := m.Hash.ContextValidate(ctx, formats); err != nil {\n\t\t\tif ve, ok := err.(*errors.Validation); ok {\n\t\t\t\treturn ve.ValidateName(\"content\" + \".\" + \"hash\")\n\t\t\t} else if ce, ok := err.(*errors.CompositeError); ok {\n\t\t\t\treturn ce.ValidateName(\"content\" + \".\" + \"hash\")\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc (m *IntotoV002SchemaContent) contextValidatePayloadHash(ctx context.Context, formats strfmt.Registry) error {\n\n\tif m.PayloadHash != nil {\n\t\tif err := m.PayloadHash.ContextValidate(ctx, formats); err != nil {\n\t\t\tif ve, ok := err.(*errors.Validation); ok {\n\t\t\t\treturn ve.ValidateName(\"content\" + \".\" + \"payloadHash\")\n\t\t\t} else if ce, ok := err.(*errors.CompositeError); ok {\n\t\t\t\treturn ce.ValidateName(\"content\" + \".\" + \"payloadHash\")\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// MarshalBinary interface implementation\nfunc (m *IntotoV002SchemaContent) MarshalBinary() ([]byte, error) {\n\tif m == nil {\n\t\treturn nil, nil\n\t}\n\treturn swag.WriteJSON(m)\n}\n\n// UnmarshalBinary interface implementation\nfunc (m *IntotoV002SchemaContent) UnmarshalBinary(b []byte) error {\n\tvar res IntotoV002SchemaContent\n\tif err := swag.ReadJSON(b, &res); err != nil {\n\t\treturn err\n\t}\n\t*m = res\n\treturn nil\n}\n\n// IntotoV002SchemaContentEnvelope dsse envelope\n//\n// swagger:model IntotoV002SchemaContentEnvelope\ntype IntotoV002SchemaContentEnvelope struct {\n\n\t// payload of the envelope\n\t// Format: byte\n\tPayload strfmt.Base64 `json:\"payload,omitempty\"`\n\n\t// type describing the payload\n\t// Required: true\n\tPayloadType *string `json:\"payloadType\"`\n\n\t// collection of all signatures of the envelope's payload\n\t// Required: true\n\t// Min Items: 1\n\tSignatures []*IntotoV002SchemaContentEnvelopeSignaturesItems0 `json:\"signatures\"`\n}\n\n// Validate validates this intoto v002 schema content envelope\nfunc (m *IntotoV002SchemaContentEnvelope) Validate(formats strfmt.Registry) error {\n\tvar res []error\n\n\tif err := m.validatePayloadType(formats); err != nil {\n\t\tres = append(res, err)\n\t}\n\n\tif err := m.validateSignatures(formats); err != nil {\n\t\tres = append(res, err)\n\t}\n\n\tif len(res) > 0 {\n\t\treturn errors.CompositeValidationError(res...)\n\t}\n\treturn nil\n}\n\nfunc (m *IntotoV002SchemaContentEnvelope) validatePayloadType(formats strfmt.Registry) error {\n\n\tif err := validate.Required(\"content\"+\".\"+\"envelope\"+\".\"+\"payloadType\", \"body\", m.PayloadType); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc (m *IntotoV002SchemaContentEnvelope) validateSignatures(formats strfmt.Registry) error {\n\n\tif err := validate.Required(\"content\"+\".\"+\"envelope\"+\".\"+\"signatures\", \"body\", m.Signatures); err != nil {\n\t\treturn err\n\t}\n\n\tiSignaturesSize := int64(len(m.Signatures))\n\n\tif err := validate.MinItems(\"content\"+\".\"+\"envelope\"+\".\"+\"signatures\", \"body\", iSignaturesSize, 1); err != nil {\n\t\treturn err\n\t}\n\n\tfor i := 0; i < len(m.Signatures); i++ {\n\t\tif swag.IsZero(m.Signatures[i]) { // not required\n\t\t\tcontinue\n\t\t}\n\n\t\tif m.Signatures[i] != nil {\n\t\t\tif err := m.Signatures[i].Validate(formats); err != nil {\n\t\t\t\tif ve, ok := err.(*errors.Validation); ok {\n\t\t\t\t\treturn ve.ValidateName(\"content\" + \".\" + \"envelope\" + \".\" + \"signatures\" + \".\" + strconv.Itoa(i))\n\t\t\t\t} else if ce, ok := err.(*errors.CompositeError); ok {\n\t\t\t\t\treturn ce.ValidateName(\"content\" + \".\" + \"envelope\" + \".\" + \"signatures\" + \".\" + strconv.Itoa(i))\n\t\t\t\t}\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\n\t}\n\n\treturn nil\n}\n\n// ContextValidate validate this intoto v002 schema content envelope based on the context it is used\nfunc (m *IntotoV002SchemaContentEnvelope) ContextValidate(ctx context.Context, formats strfmt.Registry) error {\n\tvar res []error\n\n\tif err := m.contextValidateSignatures(ctx, formats); err != nil {\n\t\tres = append(res, err)\n\t}\n\n\tif len(res) > 0 {\n\t\treturn errors.CompositeValidationError(res...)\n\t}\n\treturn nil\n}\n\nfunc (m *IntotoV002SchemaContentEnvelope) contextValidateSignatures(ctx context.Context, formats strfmt.Registry) error {\n\n\tfor i := 0; i < len(m.Signatures); i++ {\n\n\t\tif m.Signatures[i] != nil {\n\t\t\tif err := m.Signatures[i].ContextValidate(ctx, formats); err != nil {\n\t\t\t\tif ve, ok := err.(*errors.Validation); ok {\n\t\t\t\t\treturn ve.ValidateName(\"content\" + \".\" + \"envelope\" + \".\" + \"signatures\" + \".\" + strconv.Itoa(i))\n\t\t\t\t} else if ce, ok := err.(*errors.CompositeError); ok {\n\t\t\t\t\treturn ce.ValidateName(\"content\" + \".\" + \"envelope\" + \".\" + \"signatures\" + \".\" + strconv.Itoa(i))\n\t\t\t\t}\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\n\t}\n\n\treturn nil\n}\n\n// MarshalBinary interface implementation\nfunc (m *IntotoV002SchemaContentEnvelope) MarshalBinary() ([]byte, error) {\n\tif m == nil {\n\t\treturn nil, nil\n\t}\n\treturn swag.WriteJSON(m)\n}\n\n// UnmarshalBinary interface implementation\nfunc (m *IntotoV002SchemaContentEnvelope) UnmarshalBinary(b []byte) error {\n\tvar res IntotoV002SchemaContentEnvelope\n\tif err := swag.ReadJSON(b, &res); err != nil {\n\t\treturn err\n\t}\n\t*m = res\n\treturn nil\n}\n\n// IntotoV002SchemaContentEnvelopeSignaturesItems0 a signature of the envelope's payload along with the public key for the signature\n//\n// swagger:model IntotoV002SchemaContentEnvelopeSignaturesItems0\ntype IntotoV002SchemaContentEnvelopeSignaturesItems0 struct {\n\n\t// optional id of the key used to create the signature\n\tKeyid string `json:\"keyid,omitempty\"`\n\n\t// public key that corresponds to this signature\n\t// Format: byte\n\tPublicKey strfmt.Base64 `json:\"publicKey,omitempty\"`\n\n\t// signature of the payload\n\t// Format: byte\n\tSig strfmt.Base64 `json:\"sig,omitempty\"`\n}\n\n// Validate validates this intoto v002 schema content envelope signatures items0\nfunc (m *IntotoV002SchemaContentEnvelopeSignaturesItems0) Validate(formats strfmt.Registry) error {\n\treturn nil\n}\n\n// ContextValidate validates this intoto v002 schema content envelope signatures items0 based on context it is used\nfunc (m *IntotoV002SchemaContentEnvelopeSignaturesItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {\n\treturn nil\n}\n\n// MarshalBinary interface implementation\nfunc (m *IntotoV002SchemaContentEnvelopeSignaturesItems0) MarshalBinary() ([]byte, error) {\n\tif m == nil {\n\t\treturn nil, nil\n\t}\n\treturn swag.WriteJSON(m)\n}\n\n// UnmarshalBinary interface implementation\nfunc (m *IntotoV002SchemaContentEnvelopeSignaturesItems0) UnmarshalBinary(b []byte) error {\n\tvar res IntotoV002SchemaContentEnvelopeSignaturesItems0\n\tif err := swag.ReadJSON(b, &res); err != nil {\n\t\treturn err\n\t}\n\t*m = res\n\treturn nil\n}\n\n// IntotoV002SchemaContentHash Specifies the hash algorithm and value encompassing the entire signed envelope\n//\n// swagger:model IntotoV002SchemaContentHash\ntype IntotoV002SchemaContentHash struct {\n\n\t// The hashing function used to compute the hash value\n\t// Required: true\n\t// Enum: [sha256]\n\tAlgorithm *string `json:\"algorithm\"`\n\n\t// The hash value for the archive\n\t// Required: true\n\tValue *string `json:\"value\"`\n}\n\n// Validate validates this intoto v002 schema content hash\nfunc (m *IntotoV002SchemaContentHash) Validate(formats strfmt.Registry) error {\n\tvar res []error\n\n\tif err := m.validateAlgorithm(formats); err != nil {\n\t\tres = append(res, err)\n\t}\n\n\tif err := m.validateValue(formats); err != nil {\n\t\tres = append(res, err)\n\t}\n\n\tif len(res) > 0 {\n\t\treturn errors.CompositeValidationError(res...)\n\t}\n\treturn nil\n}\n\nvar intotoV002SchemaContentHashTypeAlgorithmPropEnum []interface{}\n\nfunc init() {\n\tvar res []string\n\tif err := json.Unmarshal([]byte(`[\"sha256\"]`), &res); err != nil {\n\t\tpanic(err)\n\t}\n\tfor _, v := range res {\n\t\tintotoV002SchemaContentHashTypeAlgorithmPropEnum = append(intotoV002SchemaContentHashTypeAlgorithmPropEnum, v)\n\t}\n}\n\nconst (\n\n\t// IntotoV002SchemaContentHashAlgorithmSha256 captures enum value \"sha256\"\n\tIntotoV002SchemaContentHashAlgorithmSha256 string = \"sha256\"\n)\n\n// prop value enum\nfunc (m *IntotoV002SchemaContentHash) validateAlgorithmEnum(path, location string, value string) error {\n\tif err := validate.EnumCase(path, location, value, intotoV002SchemaContentHashTypeAlgorithmPropEnum, true); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (m *IntotoV002SchemaContentHash) validateAlgorithm(formats strfmt.Registry) error {\n\n\tif err := validate.Required(\"content\"+\".\"+\"hash\"+\".\"+\"algorithm\", \"body\", m.Algorithm); err != nil {\n\t\treturn err\n\t}\n\n\t// value enum\n\tif err := m.validateAlgorithmEnum(\"content\"+\".\"+\"hash\"+\".\"+\"algorithm\", \"body\", *m.Algorithm); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc (m *IntotoV002SchemaContentHash) validateValue(formats strfmt.Registry) error {\n\n\tif err := validate.Required(\"content\"+\".\"+\"hash\"+\".\"+\"value\", \"body\", m.Value); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n// ContextValidate validate this intoto v002 schema content hash based on the context it is used\nfunc (m *IntotoV002SchemaContentHash) ContextValidate(ctx context.Context, formats strfmt.Registry) error {\n\tvar res []error\n\n\tif len(res) > 0 {\n\t\treturn errors.CompositeValidationError(res...)\n\t}\n\treturn nil\n}\n\n// MarshalBinary interface implementation\nfunc (m *IntotoV002SchemaContentHash) MarshalBinary() ([]byte, error) {\n\tif m == nil {\n\t\treturn nil, nil\n\t}\n\treturn swag.WriteJSON(m)\n}\n\n// UnmarshalBinary interface implementation\nfunc (m *IntotoV002SchemaContentHash) UnmarshalBinary(b []byte) error {\n\tvar res IntotoV002SchemaContentHash\n\tif err := swag.ReadJSON(b, &res); err != nil {\n\t\treturn err\n\t}\n\t*m = res\n\treturn nil\n}\n\n// IntotoV002SchemaContentPayloadHash Specifies the hash algorithm and value covering the payload within the DSSE envelope\n//\n// swagger:model IntotoV002SchemaContentPayloadHash\ntype IntotoV002SchemaContentPayloadHash struct {\n\n\t// The hashing function used to compute the hash value\n\t// Required: true\n\t// Enum: [sha256]\n\tAlgorithm *string `json:\"algorithm\"`\n\n\t// The hash value of the payload\n\t// Required: true\n\tValue *string `json:\"value\"`\n}\n\n// Validate validates this intoto v002 schema content payload hash\nfunc (m *IntotoV002SchemaContentPayloadHash) Validate(formats strfmt.Registry) error {\n\tvar res []error\n\n\tif err := m.validateAlgorithm(formats); err != nil {\n\t\tres = append(res, err)\n\t}\n\n\tif err := m.validateValue(formats); err != nil {\n\t\tres = append(res, err)\n\t}\n\n\tif len(res) > 0 {\n\t\treturn errors.CompositeValidationError(res...)\n\t}\n\treturn nil\n}\n\nvar intotoV002SchemaContentPayloadHashTypeAlgorithmPropEnum []interface{}\n\nfunc init() {\n\tvar res []string\n\tif err := json.Unmarshal([]byte(`[\"sha256\"]`), &res); err != nil {\n\t\tpanic(err)\n\t}\n\tfor _, v := range res {\n\t\tintotoV002SchemaContentPayloadHashTypeAlgorithmPropEnum = append(intotoV002SchemaContentPayloadHashTypeAlgorithmPropEnum, v)\n\t}\n}\n\nconst (\n\n\t// IntotoV002SchemaContentPayloadHashAlgorithmSha256 captures enum value \"sha256\"\n\tIntotoV002SchemaContentPayloadHashAlgorithmSha256 string = \"sha256\"\n)\n\n// prop value enum\nfunc (m *IntotoV002SchemaContentPayloadHash) validateAlgorithmEnum(path, location string, value string) error {\n\tif err := validate.EnumCase(path, location, value, intotoV002SchemaContentPayloadHashTypeAlgorithmPropEnum, true); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (m *IntotoV002SchemaContentPayloadHash) validateAlgorithm(formats strfmt.Registry) error {\n\n\tif err := validate.Required(\"content\"+\".\"+\"payloadHash\"+\".\"+\"algorithm\", \"body\", m.Algorithm); err != nil {\n\t\treturn err\n\t}\n\n\t// value enum\n\tif err := m.validateAlgorithmEnum(\"content\"+\".\"+\"payloadHash\"+\".\"+\"algorithm\", \"body\", *m.Algorithm); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc (m *IntotoV002SchemaContentPayloadHash) validateValue(formats strfmt.Registry) error {\n\n\tif err := validate.Required(\"content\"+\".\"+\"payloadHash\"+\".\"+\"value\", \"body\", m.Value); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n// ContextValidate validate this intoto v002 schema content payload hash based on the context it is used\nfunc (m *IntotoV002SchemaContentPayloadHash) ContextValidate(ctx context.Context, formats strfmt.Registry) error {\n\tvar res []error\n\n\tif len(res) > 0 {\n\t\treturn errors.CompositeValidationError(res...)\n\t}\n\treturn nil\n}\n\n// MarshalBinary interface implementation\nfunc (m *IntotoV002SchemaContentPayloadHash) MarshalBinary() ([]byte, error) {\n\tif m == nil {\n\t\treturn nil, nil\n\t}\n\treturn swag.WriteJSON(m)\n}\n\n// UnmarshalBinary interface implementation\nfunc (m *IntotoV002SchemaContentPayloadHash) UnmarshalBinary(b []byte) error {\n\tvar res IntotoV002SchemaContentPayloadHash\n\tif err := swag.ReadJSON(b, &res); err != nil {\n\t\treturn err\n\t}\n\t*m = res\n\treturn nil\n}\n", "// Code generated by go-swagger; DO NOT EDIT.\n\n//\n// Copyright 2021 The Sigstore Authors.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage restapi\n\n// This file was generated by the swagger tool.\n// Editing this file might prove futile when you re-run the swagger generate command\n\nimport (\n\t\"encoding/json\"\n)\n\nvar (\n\t// SwaggerJSON embedded version of the swagger document used at generation time\n\tSwaggerJSON json.RawMessage\n\t// FlatSwaggerJSON embedded flattened version of the swagger document used at generation time\n\tFlatSwaggerJSON json.RawMessage\n)\n\nfunc init() {\n\tSwaggerJSON = json.RawMessage([]byte(`{\n  \"consumes\": [\n    \"application/json\"\n  ],\n  \"produces\": [\n    \"application/json\"\n  ],\n  \"schemes\": [\n    \"http\"\n  ],\n  \"swagger\": \"2.0\",\n  \"info\": {\n    \"description\": \"Rekor is a cryptographically secure, immutable transparency log for signed software releases.\",\n    \"title\": \"Rekor\",\n    \"version\": \"1.0.0\"\n  },\n  \"host\": \"rekor.sigstore.dev\",\n  \"paths\": {\n    \"/api/v1/index/retrieve\": {\n      \"post\": {\n        \"description\": \"EXPERIMENTAL - this endpoint is offered as best effort only and may be changed or removed in future releases.\\nThe results returned from this endpoint may be incomplete.\\n\",\n        \"tags\": [\n          \"index\"\n        ],\n        \"summary\": \"Searches index by entry metadata\",\n        \"operationId\": \"searchIndex\",\n        \"deprecated\": true,\n        \"parameters\": [\n          {\n            \"name\": \"query\",\n            \"in\": \"body\",\n            \"required\": true,\n            \"schema\": {\n              \"$ref\": \"#/definitions/SearchIndex\"\n            }\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"description\": \"Returns zero or more entry UUIDs from the transparency log based on search query\",\n            \"schema\": {\n              \"type\": \"array\",\n              \"items\": {\n                \"description\": \"Entry UUID in transparency log\",\n                \"type\": \"string\",\n                \"pattern\": \"^([0-9a-fA-F]{64}|[0-9a-fA-F]{80})$\"\n              }\n            }\n          },\n          \"400\": {\n            \"$ref\": \"#/responses/BadContent\"\n          },\n          \"default\": {\n            \"$ref\": \"#/responses/InternalServerError\"\n          }\n        }\n      }\n    },\n    \"/api/v1/log\": {\n      \"get\": {\n        \"description\": \"Returns the current root hash and size of the merkle tree used to store the log entries.\",\n        \"tags\": [\n          \"tlog\"\n        ],\n        \"summary\": \"Get information about the current state of the transparency log\",\n        \"operationId\": \"getLogInfo\",\n        \"parameters\": [\n          {\n            \"type\": \"boolean\",\n            \"default\": false,\n            \"description\": \"Whether to return a stable checkpoint for the active shard\",\n            \"name\": \"stable\",\n            \"in\": \"query\"\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"description\": \"A JSON object with the root hash and tree size as properties\",\n            \"schema\": {\n              \"$ref\": \"#/definitions/LogInfo\"\n            }\n          },\n          \"default\": {\n            \"$ref\": \"#/responses/InternalServerError\"\n          }\n        }\n      }\n    },\n    \"/api/v1/log/entries\": {\n      \"get\": {\n        \"tags\": [\n          \"entries\"\n        ],\n        \"summary\": \"Retrieves an entry and inclusion proof from the transparency log (if it exists) by index\",\n        \"operationId\": \"getLogEntryByIndex\",\n        \"parameters\": [\n          {\n            \"type\": \"integer\",\n            \"description\": \"specifies the index of the entry in the transparency log to be retrieved\",\n            \"name\": \"logIndex\",\n            \"in\": \"query\",\n            \"required\": true\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"description\": \"the entry in the transparency log requested along with an inclusion proof\",\n            \"schema\": {\n              \"$ref\": \"#/definitions/LogEntry\"\n            }\n          },\n          \"404\": {\n            \"$ref\": \"#/responses/NotFound\"\n          },\n          \"default\": {\n            \"$ref\": \"#/responses/InternalServerError\"\n          }\n        }\n      },\n      \"post\": {\n        \"description\": \"Creates an entry in the transparency log for a detached signature, public key, and content. Items can be included in the request or fetched by the server when URLs are specified.\\n\",\n        \"tags\": [\n          \"entries\"\n        ],\n        \"summary\": \"Creates an entry in the transparency log\",\n        \"operationId\": \"createLogEntry\",\n        \"parameters\": [\n          {\n            \"name\": \"proposedEntry\",\n            \"in\": \"body\",\n            \"required\": true,\n            \"schema\": {\n              \"$ref\": \"#/definitions/ProposedEntry\"\n            }\n          }\n        ],\n        \"responses\": {\n          \"201\": {\n            \"description\": \"Returns the entry created in the transparency log\",\n            \"schema\": {\n              \"$ref\": \"#/definitions/LogEntry\"\n            },\n            \"headers\": {\n              \"ETag\": {\n                \"type\": \"string\",\n                \"description\": \"UUID of log entry\"\n              },\n              \"Location\": {\n                \"type\": \"string\",\n                \"format\": \"uri\",\n                \"description\": \"URI location of log entry\"\n              }\n            }\n          },\n          \"400\": {\n            \"$ref\": \"#/responses/BadContent\"\n          },\n          \"409\": {\n            \"$ref\": \"#/responses/Conflict\"\n          },\n          \"default\": {\n            \"$ref\": \"#/responses/InternalServerError\"\n          }\n        }\n      }\n    },\n    \"/api/v1/log/entries/retrieve\": {\n      \"post\": {\n        \"tags\": [\n          \"entries\"\n        ],\n        \"summary\": \"Searches transparency log for one or more log entries\",\n        \"operationId\": \"searchLogQuery\",\n        \"parameters\": [\n          {\n            \"name\": \"entry\",\n            \"in\": \"body\",\n            \"required\": true,\n            \"schema\": {\n              \"$ref\": \"#/definitions/SearchLogQuery\"\n            }\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"description\": \"Returns zero or more entries from the transparency log, according to how many were included in request query\",\n            \"schema\": {\n              \"type\": \"array\",\n              \"items\": {\n                \"$ref\": \"#/definitions/LogEntry\"\n              }\n            }\n          },\n          \"400\": {\n            \"$ref\": \"#/responses/BadContent\"\n          },\n          \"422\": {\n            \"$ref\": \"#/responses/UnprocessableEntity\"\n          },\n          \"default\": {\n            \"$ref\": \"#/responses/InternalServerError\"\n          }\n        }\n      }\n    },\n    \"/api/v1/log/entries/{entryUUID}\": {\n      \"get\": {\n        \"description\": \"Returns the entry, root hash, tree size, and a list of hashes that can be used to calculate proof of an entry being included in the transparency log\",\n        \"tags\": [\n          \"entries\"\n        ],\n        \"summary\": \"Get log entry and information required to generate an inclusion proof for the entry in the transparency log\",\n        \"operationId\": \"getLogEntryByUUID\",\n        \"parameters\": [\n          {\n            \"pattern\": \"^([0-9a-fA-F]{64}|[0-9a-fA-F]{80})$\",\n            \"type\": \"string\",\n            \"description\": \"the UUID of the entry for which the inclusion proof information should be returned\",\n            \"name\": \"entryUUID\",\n            \"in\": \"path\",\n            \"required\": true\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"description\": \"Information needed for a client to compute the inclusion proof\",\n            \"schema\": {\n              \"$ref\": \"#/definitions/LogEntry\"\n            }\n          },\n          \"404\": {\n            \"$ref\": \"#/responses/NotFound\"\n          },\n          \"default\": {\n            \"$ref\": \"#/responses/InternalServerError\"\n          }\n        }\n      }\n    },\n    \"/api/v1/log/proof\": {\n      \"get\": {\n        \"description\": \"Returns a list of hashes for specified tree sizes that can be used to confirm the consistency of the transparency log\",\n        \"tags\": [\n          \"tlog\"\n        ],\n        \"summary\": \"Get information required to generate a consistency proof for the transparency log\",\n        \"operationId\": \"getLogProof\",\n        \"parameters\": [\n          {\n            \"minimum\": 1,\n            \"type\": \"integer\",\n            \"default\": 1,\n            \"description\": \"The size of the tree that you wish to prove consistency from (1 means the beginning of the log) Defaults to 1 if not specified\\n\",\n            \"name\": \"firstSize\",\n            \"in\": \"query\"\n          },\n          {\n            \"minimum\": 1,\n            \"type\": \"integer\",\n            \"description\": \"The size of the tree that you wish to prove consistency to\",\n            \"name\": \"lastSize\",\n            \"in\": \"query\",\n            \"required\": true\n          },\n          {\n            \"pattern\": \"^[0-9]+$\",\n            \"type\": \"string\",\n            \"description\": \"The tree ID of the tree that you wish to prove consistency for\",\n            \"name\": \"treeID\",\n            \"in\": \"query\"\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"description\": \"All hashes required to compute the consistency proof\",\n            \"schema\": {\n              \"$ref\": \"#/definitions/ConsistencyProof\"\n            }\n          },\n          \"400\": {\n            \"$ref\": \"#/responses/BadContent\"\n          },\n          \"default\": {\n            \"$ref\": \"#/responses/InternalServerError\"\n          }\n        }\n      }\n    },\n    \"/api/v1/log/publicKey\": {\n      \"get\": {\n        \"description\": \"Returns the public key that can be used to validate the signed tree head\",\n        \"produces\": [\n          \"application/x-pem-file\"\n        ],\n        \"tags\": [\n          \"pubkey\"\n        ],\n        \"summary\": \"Retrieve the public key that can be used to validate the signed tree head\",\n        \"operationId\": \"getPublicKey\",\n        \"parameters\": [\n          {\n            \"pattern\": \"^[0-9]+$\",\n            \"type\": \"string\",\n            \"description\": \"The tree ID of the tree you wish to get a public key for\",\n            \"name\": \"treeID\",\n            \"in\": \"query\"\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"description\": \"The public key\",\n            \"schema\": {\n              \"type\": \"string\"\n            }\n          },\n          \"default\": {\n            \"$ref\": \"#/responses/InternalServerError\"\n          }\n        }\n      }\n    }\n  },\n  \"definitions\": {\n    \"ConsistencyProof\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"rootHash\",\n        \"hashes\"\n      ],\n      \"properties\": {\n        \"hashes\": {\n          \"type\": \"array\",\n          \"items\": {\n            \"description\": \"SHA256 hash value expressed in hexadecimal format\",\n            \"type\": \"string\",\n            \"pattern\": \"^[0-9a-fA-F]{64}$\"\n          }\n        },\n        \"rootHash\": {\n          \"description\": \"The hash value stored at the root of the merkle tree at the time the proof was generated\",\n          \"type\": \"string\",\n          \"pattern\": \"^[0-9a-fA-F]{64}$\"\n        }\n      }\n    },\n    \"Error\": {\n      \"type\": \"object\",\n      \"properties\": {\n        \"code\": {\n          \"type\": \"integer\"\n        },\n        \"message\": {\n          \"type\": \"string\"\n        }\n      }\n    },\n    \"InactiveShardLogInfo\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"rootHash\",\n        \"treeSize\",\n        \"signedTreeHead\",\n        \"treeID\"\n      ],\n      \"properties\": {\n        \"rootHash\": {\n          \"description\": \"The current hash value stored at the root of the merkle tree\",\n          \"type\": \"string\",\n          \"pattern\": \"^[0-9a-fA-F]{64}$\"\n        },\n        \"signedTreeHead\": {\n          \"description\": \"The current signed tree head\",\n          \"type\": \"string\",\n          \"format\": \"signedCheckpoint\"\n        },\n        \"treeID\": {\n          \"description\": \"The current treeID\",\n          \"type\": \"string\",\n          \"pattern\": \"^[0-9]+$\"\n        },\n        \"treeSize\": {\n          \"description\": \"The current number of nodes in the merkle tree\",\n          \"type\": \"integer\",\n          \"minimum\": 1\n        }\n      }\n    },\n    \"InclusionProof\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"logIndex\",\n        \"rootHash\",\n        \"treeSize\",\n        \"hashes\",\n        \"checkpoint\"\n      ],\n      \"properties\": {\n        \"checkpoint\": {\n          \"description\": \"The checkpoint (signed tree head) that the inclusion proof is based on\",\n          \"type\": \"string\",\n          \"format\": \"signedCheckpoint\"\n        },\n        \"hashes\": {\n          \"description\": \"A list of hashes required to compute the inclusion proof, sorted in order from leaf to root\",\n          \"type\": \"array\",\n          \"items\": {\n            \"description\": \"SHA256 hash value expressed in hexadecimal format\",\n            \"type\": \"string\",\n            \"pattern\": \"^[0-9a-fA-F]{64}$\"\n          }\n        },\n        \"logIndex\": {\n          \"description\": \"The index of the entry in the transparency log\",\n          \"type\": \"integer\"\n        },\n        \"rootHash\": {\n          \"description\": \"The hash value stored at the root of the merkle tree at the time the proof was generated\",\n          \"type\": \"string\",\n          \"pattern\": \"^[0-9a-fA-F]{64}$\"\n        },\n        \"treeSize\": {\n          \"description\": \"The size of the merkle tree at the time the inclusion proof was generated\",\n          \"type\": \"integer\",\n          \"minimum\": 1\n        }\n      }\n    },\n    \"LogEntry\": {\n      \"type\": \"object\",\n      \"additionalProperties\": {\n        \"type\": \"object\",\n        \"required\": [\n          \"logID\",\n          \"logIndex\",\n          \"body\",\n          \"integratedTime\"\n        ],\n        \"properties\": {\n          \"attestation\": {\n            \"type\": \"object\",\n            \"format\": \"byte\",\n            \"properties\": {\n              \"data\": {\n                \"format\": \"byte\"\n              }\n            }\n          },\n          \"body\": {\n            \"type\": \"object\",\n            \"additionalProperties\": true\n          },\n          \"integratedTime\": {\n            \"type\": \"integer\"\n          },\n          \"logID\": {\n            \"description\": \"This is the SHA256 hash of the DER-encoded public key for the log at the time the entry was included in the log\",\n            \"type\": \"string\",\n            \"pattern\": \"^[0-9a-fA-F]{64}$\"\n          },\n          \"logIndex\": {\n            \"type\": \"integer\"\n          },\n          \"verification\": {\n            \"type\": \"object\",\n            \"properties\": {\n              \"inclusionProof\": {\n                \"$ref\": \"#/definitions/InclusionProof\"\n              },\n              \"signedEntryTimestamp\": {\n                \"description\": \"Signature over the logID, logIndex, body and integratedTime.\",\n                \"type\": \"string\",\n                \"format\": \"byte\"\n              }\n            }\n          }\n        }\n      }\n    },\n    \"LogInfo\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"rootHash\",\n        \"treeSize\",\n        \"signedTreeHead\",\n        \"treeID\"\n      ],\n      \"properties\": {\n        \"inactiveShards\": {\n          \"type\": \"array\",\n          \"items\": {\n            \"$ref\": \"#/definitions/InactiveShardLogInfo\"\n          }\n        },\n        \"rootHash\": {\n          \"description\": \"The current hash value stored at the root of the merkle tree\",\n          \"type\": \"string\",\n          \"pattern\": \"^[0-9a-fA-F]{64}$\"\n        },\n        \"signedTreeHead\": {\n          \"description\": \"The current signed tree head\",\n          \"type\": \"string\",\n          \"format\": \"signedCheckpoint\"\n        },\n        \"treeID\": {\n          \"description\": \"The current treeID\",\n          \"type\": \"string\",\n          \"pattern\": \"^[0-9]+$\"\n        },\n        \"treeSize\": {\n          \"description\": \"The current number of nodes in the merkle tree\",\n          \"type\": \"integer\",\n          \"minimum\": 1\n        }\n      }\n    },\n    \"ProposedEntry\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"kind\"\n      ],\n      \"properties\": {\n        \"kind\": {\n          \"type\": \"string\"\n        }\n      },\n      \"discriminator\": \"kind\"\n    },\n    \"SearchIndex\": {\n      \"type\": \"object\",\n      \"properties\": {\n        \"email\": {\n          \"type\": \"string\",\n          \"format\": \"email\"\n        },\n        \"hash\": {\n          \"type\": \"string\",\n          \"pattern\": \"^(sha512:)?[0-9a-fA-F]{128}$|^(sha256:)?[0-9a-fA-F]{64}$|^(sha1:)?[0-9a-fA-F]{40}$\"\n        },\n        \"operator\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"and\",\n            \"or\"\n          ]\n        },\n        \"publicKey\": {\n          \"type\": \"object\",\n          \"required\": [\n            \"format\"\n          ],\n          \"properties\": {\n            \"content\": {\n              \"type\": \"string\",\n              \"format\": \"byte\"\n            },\n            \"format\": {\n              \"type\": \"string\",\n              \"enum\": [\n                \"pgp\",\n                \"x509\",\n                \"minisign\",\n                \"ssh\",\n                \"tuf\"\n              ]\n            },\n            \"url\": {\n              \"type\": \"string\",\n              \"format\": \"uri\"\n            }\n          }\n        }\n      }\n    },\n    \"SearchLogQuery\": {\n      \"type\": \"object\",\n      \"properties\": {\n        \"entries\": {\n          \"type\": \"array\",\n          \"maxItems\": 10,\n          \"minItems\": 1,\n          \"items\": {\n            \"$ref\": \"#/definitions/ProposedEntry\"\n          }\n        },\n        \"entryUUIDs\": {\n          \"type\": \"array\",\n          \"maxItems\": 10,\n          \"minItems\": 1,\n          \"items\": {\n            \"type\": \"string\",\n            \"pattern\": \"^([0-9a-fA-F]{64}|[0-9a-fA-F]{80})$\"\n          }\n        },\n        \"logIndexes\": {\n          \"type\": \"array\",\n          \"maxItems\": 10,\n          \"minItems\": 1,\n          \"items\": {\n            \"type\": \"integer\"\n          }\n        }\n      }\n    },\n    \"alpine\": {\n      \"description\": \"Alpine package\",\n      \"type\": \"object\",\n      \"allOf\": [\n        {\n          \"$ref\": \"#/definitions/ProposedEntry\"\n        },\n        {\n          \"required\": [\n            \"apiVersion\",\n            \"spec\"\n          ],\n          \"properties\": {\n            \"apiVersion\": {\n              \"type\": \"string\",\n              \"pattern\": \"^(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)(?:-((?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\\\.(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\\\+([0-9a-zA-Z-]+(?:\\\\.[0-9a-zA-Z-]+)*))?$\"\n            },\n            \"spec\": {\n              \"type\": \"object\",\n              \"$ref\": \"pkg/types/alpine/alpine_schema.json\"\n            }\n          },\n          \"additionalProperties\": false\n        }\n      ]\n    },\n    \"cose\": {\n      \"description\": \"COSE object\",\n      \"type\": \"object\",\n      \"allOf\": [\n        {\n          \"$ref\": \"#/definitions/ProposedEntry\"\n        },\n        {\n          \"required\": [\n            \"apiVersion\",\n            \"spec\"\n          ],\n          \"properties\": {\n            \"apiVersion\": {\n              \"type\": \"string\",\n              \"pattern\": \"^(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)(?:-((?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\\\.(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\\\+([0-9a-zA-Z-]+(?:\\\\.[0-9a-zA-Z-]+)*))?$\"\n            },\n            \"spec\": {\n              \"type\": \"object\",\n              \"$ref\": \"pkg/types/cose/cose_schema.json\"\n            }\n          },\n          \"additionalProperties\": false\n        }\n      ]\n    },\n    \"dsse\": {\n      \"description\": \"DSSE envelope\",\n      \"type\": \"object\",\n      \"allOf\": [\n        {\n          \"$ref\": \"#/definitions/ProposedEntry\"\n        },\n        {\n          \"required\": [\n            \"apiVersion\",\n            \"spec\"\n          ],\n          \"properties\": {\n            \"apiVersion\": {\n              \"type\": \"string\",\n              \"pattern\": \"^(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)(?:-((?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\\\.(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\\\+([0-9a-zA-Z-]+(?:\\\\.[0-9a-zA-Z-]+)*))?$\"\n            },\n            \"spec\": {\n              \"type\": \"object\",\n              \"$ref\": \"pkg/types/dsse/dsse_schema.json\"\n            }\n          },\n          \"additionalProperties\": false\n        }\n      ]\n    },\n    \"hashedrekord\": {\n      \"description\": \"Hashed Rekord object\",\n      \"type\": \"object\",\n      \"allOf\": [\n        {\n          \"$ref\": \"#/definitions/ProposedEntry\"\n        },\n        {\n          \"required\": [\n            \"apiVersion\",\n            \"spec\"\n          ],\n          \"properties\": {\n            \"apiVersion\": {\n              \"type\": \"string\",\n              \"pattern\": \"^(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)(?:-((?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\\\.(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\\\+([0-9a-zA-Z-]+(?:\\\\.[0-9a-zA-Z-]+)*))?$\"\n            },\n            \"spec\": {\n              \"type\": \"object\",\n              \"$ref\": \"pkg/types/hashedrekord/hashedrekord_schema.json\"\n            }\n          },\n          \"additionalProperties\": false\n        }\n      ]\n    },\n    \"helm\": {\n      \"description\": \"Helm chart\",\n      \"type\": \"object\",\n      \"allOf\": [\n        {\n          \"$ref\": \"#/definitions/ProposedEntry\"\n        },\n        {\n          \"required\": [\n            \"apiVersion\",\n            \"spec\"\n          ],\n          \"properties\": {\n            \"apiVersion\": {\n              \"type\": \"string\",\n              \"pattern\": \"^(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)(?:-((?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\\\.(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\\\+([0-9a-zA-Z-]+(?:\\\\.[0-9a-zA-Z-]+)*))?$\"\n            },\n            \"spec\": {\n              \"type\": \"object\",\n              \"$ref\": \"pkg/types/helm/helm_schema.json\"\n            }\n          }\n        }\n      ]\n    },\n    \"intoto\": {\n      \"description\": \"Intoto object\",\n      \"type\": \"object\",\n      \"allOf\": [\n        {\n          \"$ref\": \"#/definitions/ProposedEntry\"\n        },\n        {\n          \"required\": [\n            \"apiVersion\",\n            \"spec\"\n          ],\n          \"properties\": {\n            \"apiVersion\": {\n              \"type\": \"string\",\n              \"pattern\": \"^(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)(?:-((?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\\\.(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\\\+([0-9a-zA-Z-]+(?:\\\\.[0-9a-zA-Z-]+)*))?$\"\n            },\n            \"spec\": {\n              \"type\": \"object\",\n              \"$ref\": \"pkg/types/intoto/intoto_schema.json\"\n            }\n          },\n          \"additionalProperties\": false\n        }\n      ]\n    },\n    \"jar\": {\n      \"description\": \"Java Archive (JAR)\",\n      \"type\": \"object\",\n      \"allOf\": [\n        {\n          \"$ref\": \"#/definitions/ProposedEntry\"\n        },\n        {\n          \"required\": [\n            \"apiVersion\",\n            \"spec\"\n          ],\n          \"properties\": {\n            \"apiVersion\": {\n              \"type\": \"string\",\n              \"pattern\": \"^(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)(?:-((?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\\\.(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\\\+([0-9a-zA-Z-]+(?:\\\\.[0-9a-zA-Z-]+)*))?$\"\n            },\n            \"spec\": {\n              \"type\": \"object\",\n              \"$ref\": \"pkg/types/jar/jar_schema.json\"\n            }\n          },\n          \"additionalProperties\": false\n        }\n      ]\n    },\n    \"rekord\": {\n      \"description\": \"Rekord object\",\n      \"type\": \"object\",\n      \"allOf\": [\n        {\n          \"$ref\": \"#/definitions/ProposedEntry\"\n        },\n        {\n          \"required\": [\n            \"apiVersion\",\n            \"spec\"\n          ],\n          \"properties\": {\n            \"apiVersion\": {\n              \"type\": \"string\",\n              \"pattern\": \"^(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)(?:-((?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\\\.(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\\\+([0-9a-zA-Z-]+(?:\\\\.[0-9a-zA-Z-]+)*))?$\"\n            },\n            \"spec\": {\n              \"type\": \"object\",\n              \"$ref\": \"pkg/types/rekord/rekord_schema.json\"\n            }\n          },\n          \"additionalProperties\": false\n        }\n      ]\n    },\n    \"rfc3161\": {\n      \"description\": \"RFC3161 Timestamp\",\n      \"type\": \"object\",\n      \"allOf\": [\n        {\n          \"$ref\": \"#/definitions/ProposedEntry\"\n        },\n        {\n          \"required\": [\n            \"apiVersion\",\n            \"spec\"\n          ],\n          \"properties\": {\n            \"apiVersion\": {\n              \"type\": \"string\",\n              \"pattern\": \"^(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)(?:-((?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\\\.(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\\\+([0-9a-zA-Z-]+(?:\\\\.[0-9a-zA-Z-]+)*))?$\"\n            },\n            \"spec\": {\n              \"type\": \"object\",\n              \"$ref\": \"pkg/types/rfc3161/rfc3161_schema.json\"\n            }\n          },\n          \"additionalProperties\": false\n        }\n      ]\n    },\n    \"rpm\": {\n      \"description\": \"RPM package\",\n      \"type\": \"object\",\n      \"allOf\": [\n        {\n          \"$ref\": \"#/definitions/ProposedEntry\"\n        },\n        {\n          \"required\": [\n            \"apiVersion\",\n            \"spec\"\n          ],\n          \"properties\": {\n            \"apiVersion\": {\n              \"type\": \"string\",\n              \"pattern\": \"^(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)(?:-((?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\\\.(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\\\+([0-9a-zA-Z-]+(?:\\\\.[0-9a-zA-Z-]+)*))?$\"\n            },\n            \"spec\": {\n              \"type\": \"object\",\n              \"$ref\": \"pkg/types/rpm/rpm_schema.json\"\n            }\n          },\n          \"additionalProperties\": false\n        }\n      ]\n    },\n    \"tuf\": {\n      \"description\": \"TUF metadata\",\n      \"type\": \"object\",\n      \"allOf\": [\n        {\n          \"$ref\": \"#/definitions/ProposedEntry\"\n        },\n        {\n          \"required\": [\n            \"apiVersion\",\n            \"spec\"\n          ],\n          \"properties\": {\n            \"apiVersion\": {\n              \"type\": \"string\",\n              \"pattern\": \"^(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)(?:-((?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\\\.(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\\\+([0-9a-zA-Z-]+(?:\\\\.[0-9a-zA-Z-]+)*))?$\"\n            },\n            \"spec\": {\n              \"type\": \"object\",\n              \"$ref\": \"pkg/types/tuf/tuf_schema.json\"\n            }\n          },\n          \"additionalProperties\": false\n        }\n      ]\n    }\n  },\n  \"responses\": {\n    \"BadContent\": {\n      \"description\": \"The content supplied to the server was invalid\",\n      \"schema\": {\n        \"$ref\": \"#/definitions/Error\"\n      }\n    },\n    \"Conflict\": {\n      \"description\": \"The request conflicts with the current state of the transparency log\",\n      \"schema\": {\n        \"$ref\": \"#/definitions/Error\"\n      },\n      \"headers\": {\n        \"Location\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        }\n      }\n    },\n    \"InternalServerError\": {\n      \"description\": \"There was an internal error in the server while processing the request\",\n      \"schema\": {\n        \"$ref\": \"#/definitions/Error\"\n      }\n    },\n    \"NotFound\": {\n      \"description\": \"The content requested could not be found\"\n    },\n    \"UnprocessableEntity\": {\n      \"description\": \"The server understood the request but is unable to process the contained instructions\",\n      \"schema\": {\n        \"$ref\": \"#/definitions/Error\"\n      }\n    }\n  }\n}`))\n\tFlatSwaggerJSON = json.RawMessage([]byte(`{\n  \"consumes\": [\n    \"application/json\"\n  ],\n  \"produces\": [\n    \"application/json\"\n  ],\n  \"schemes\": [\n    \"http\"\n  ],\n  \"swagger\": \"2.0\",\n  \"info\": {\n    \"description\": \"Rekor is a cryptographically secure, immutable transparency log for signed software releases.\",\n    \"title\": \"Rekor\",\n    \"version\": \"1.0.0\"\n  },\n  \"host\": \"rekor.sigstore.dev\",\n  \"paths\": {\n    \"/api/v1/index/retrieve\": {\n      \"post\": {\n        \"description\": \"EXPERIMENTAL - this endpoint is offered as best effort only and may be changed or removed in future releases.\\nThe results returned from this endpoint may be incomplete.\\n\",\n        \"tags\": [\n          \"index\"\n        ],\n        \"summary\": \"Searches index by entry metadata\",\n        \"operationId\": \"searchIndex\",\n        \"deprecated\": true,\n        \"parameters\": [\n          {\n            \"name\": \"query\",\n            \"in\": \"body\",\n            \"required\": true,\n            \"schema\": {\n              \"$ref\": \"#/definitions/SearchIndex\"\n            }\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"description\": \"Returns zero or more entry UUIDs from the transparency log based on search query\",\n            \"schema\": {\n              \"type\": \"array\",\n              \"items\": {\n                \"description\": \"Entry UUID in transparency log\",\n                \"type\": \"string\",\n                \"pattern\": \"^([0-9a-fA-F]{64}|[0-9a-fA-F]{80})$\"\n              }\n            }\n          },\n          \"400\": {\n            \"description\": \"The content supplied to the server was invalid\",\n            \"schema\": {\n              \"$ref\": \"#/definitions/Error\"\n            }\n          },\n          \"default\": {\n            \"description\": \"There was an internal error in the server while processing the request\",\n            \"schema\": {\n              \"$ref\": \"#/definitions/Error\"\n            }\n          }\n        }\n      }\n    },\n    \"/api/v1/log\": {\n      \"get\": {\n        \"description\": \"Returns the current root hash and size of the merkle tree used to store the log entries.\",\n        \"tags\": [\n          \"tlog\"\n        ],\n        \"summary\": \"Get information about the current state of the transparency log\",\n        \"operationId\": \"getLogInfo\",\n        \"parameters\": [\n          {\n            \"type\": \"boolean\",\n            \"default\": false,\n            \"description\": \"Whether to return a stable checkpoint for the active shard\",\n            \"name\": \"stable\",\n            \"in\": \"query\"\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"description\": \"A JSON object with the root hash and tree size as properties\",\n            \"schema\": {\n              \"$ref\": \"#/definitions/LogInfo\"\n            }\n          },\n          \"default\": {\n            \"description\": \"There was an internal error in the server while processing the request\",\n            \"schema\": {\n              \"$ref\": \"#/definitions/Error\"\n            }\n          }\n        }\n      }\n    },\n    \"/api/v1/log/entries\": {\n      \"get\": {\n        \"tags\": [\n          \"entries\"\n        ],\n        \"summary\": \"Retrieves an entry and inclusion proof from the transparency log (if it exists) by index\",\n        \"operationId\": \"getLogEntryByIndex\",\n        \"parameters\": [\n          {\n            \"minimum\": 0,\n            \"type\": \"integer\",\n            \"description\": \"specifies the index of the entry in the transparency log to be retrieved\",\n            \"name\": \"logIndex\",\n            \"in\": \"query\",\n            \"required\": true\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"description\": \"the entry in the transparency log requested along with an inclusion proof\",\n            \"schema\": {\n              \"$ref\": \"#/definitions/LogEntry\"\n            }\n          },\n          \"404\": {\n            \"description\": \"The content requested could not be found\"\n          },\n          \"default\": {\n            \"description\": \"There was an internal error in the server while processing the request\",\n            \"schema\": {\n              \"$ref\": \"#/definitions/Error\"\n            }\n          }\n        }\n      },\n      \"post\": {\n        \"description\": \"Creates an entry in the transparency log for a detached signature, public key, and content. Items can be included in the request or fetched by the server when URLs are specified.\\n\",\n        \"tags\": [\n          \"entries\"\n        ],\n        \"summary\": \"Creates an entry in the transparency log\",\n        \"operationId\": \"createLogEntry\",\n        \"parameters\": [\n          {\n            \"name\": \"proposedEntry\",\n            \"in\": \"body\",\n            \"required\": true,\n            \"schema\": {\n              \"$ref\": \"#/definitions/ProposedEntry\"\n            }\n          }\n        ],\n        \"responses\": {\n          \"201\": {\n            \"description\": \"Returns the entry created in the transparency log\",\n            \"schema\": {\n              \"$ref\": \"#/definitions/LogEntry\"\n            },\n            \"headers\": {\n              \"ETag\": {\n                \"type\": \"string\",\n                \"description\": \"UUID of log entry\"\n              },\n              \"Location\": {\n                \"type\": \"string\",\n                \"format\": \"uri\",\n                \"description\": \"URI location of log entry\"\n              }\n            }\n          },\n          \"400\": {\n            \"description\": \"The content supplied to the server was invalid\",\n            \"schema\": {\n              \"$ref\": \"#/definitions/Error\"\n            }\n          },\n          \"409\": {\n            \"description\": \"The request conflicts with the current state of the transparency log\",\n            \"schema\": {\n              \"$ref\": \"#/definitions/Error\"\n            },\n            \"headers\": {\n              \"Location\": {\n                \"type\": \"string\",\n                \"format\": \"uri\"\n              }\n            }\n          },\n          \"default\": {\n            \"description\": \"There was an internal error in the server while processing the request\",\n            \"schema\": {\n              \"$ref\": \"#/definitions/Error\"\n            }\n          }\n        }\n      }\n    },\n    \"/api/v1/log/entries/retrieve\": {\n      \"post\": {\n        \"tags\": [\n          \"entries\"\n        ],\n        \"summary\": \"Searches transparency log for one or more log entries\",\n        \"operationId\": \"searchLogQuery\",\n        \"parameters\": [\n          {\n            \"name\": \"entry\",\n            \"in\": \"body\",\n            \"required\": true,\n            \"schema\": {\n              \"$ref\": \"#/definitions/SearchLogQuery\"\n            }\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"description\": \"Returns zero or more entries from the transparency log, according to how many were included in request query\",\n            \"schema\": {\n              \"type\": \"array\",\n              \"items\": {\n                \"$ref\": \"#/definitions/LogEntry\"\n              }\n            }\n          },\n          \"400\": {\n            \"description\": \"The content supplied to the server was invalid\",\n            \"schema\": {\n              \"$ref\": \"#/definitions/Error\"\n            }\n          },\n          \"422\": {\n            \"description\": \"The server understood the request but is unable to process the contained instructions\",\n            \"schema\": {\n              \"$ref\": \"#/definitions/Error\"\n            }\n          },\n          \"default\": {\n            \"description\": \"There was an internal error in the server while processing the request\",\n            \"schema\": {\n              \"$ref\": \"#/definitions/Error\"\n            }\n          }\n        }\n      }\n    },\n    \"/api/v1/log/entries/{entryUUID}\": {\n      \"get\": {\n        \"description\": \"Returns the entry, root hash, tree size, and a list of hashes that can be used to calculate proof of an entry being included in the transparency log\",\n        \"tags\": [\n          \"entries\"\n        ],\n        \"summary\": \"Get log entry and information required to generate an inclusion proof for the entry in the transparency log\",\n        \"operationId\": \"getLogEntryByUUID\",\n        \"parameters\": [\n          {\n            \"pattern\": \"^([0-9a-fA-F]{64}|[0-9a-fA-F]{80})$\",\n            \"type\": \"string\",\n            \"description\": \"the UUID of the entry for which the inclusion proof information should be returned\",\n            \"name\": \"entryUUID\",\n            \"in\": \"path\",\n            \"required\": true\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"description\": \"Information needed for a client to compute the inclusion proof\",\n            \"schema\": {\n              \"$ref\": \"#/definitions/LogEntry\"\n            }\n          },\n          \"404\": {\n            \"description\": \"The content requested could not be found\"\n          },\n          \"default\": {\n            \"description\": \"There was an internal error in the server while processing the request\",\n            \"schema\": {\n              \"$ref\": \"#/definitions/Error\"\n            }\n          }\n        }\n      }\n    },\n    \"/api/v1/log/proof\": {\n      \"get\": {\n        \"description\": \"Returns a list of hashes for specified tree sizes that can be used to confirm the consistency of the transparency log\",\n        \"tags\": [\n          \"tlog\"\n        ],\n        \"summary\": \"Get information required to generate a consistency proof for the transparency log\",\n        \"operationId\": \"getLogProof\",\n        \"parameters\": [\n          {\n            \"minimum\": 1,\n            \"type\": \"integer\",\n            \"default\": 1,\n            \"description\": \"The size of the tree that you wish to prove consistency from (1 means the beginning of the log) Defaults to 1 if not specified\\n\",\n            \"name\": \"firstSize\",\n            \"in\": \"query\"\n          },\n          {\n            \"minimum\": 1,\n            \"type\": \"integer\",\n            \"description\": \"The size of the tree that you wish to prove consistency to\",\n            \"name\": \"lastSize\",\n            \"in\": \"query\",\n            \"required\": true\n          },\n          {\n            \"pattern\": \"^[0-9]+$\",\n            \"type\": \"string\",\n            \"description\": \"The tree ID of the tree that you wish to prove consistency for\",\n            \"name\": \"treeID\",\n            \"in\": \"query\"\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"description\": \"All hashes required to compute the consistency proof\",\n            \"schema\": {\n              \"$ref\": \"#/definitions/ConsistencyProof\"\n            }\n          },\n          \"400\": {\n            \"description\": \"The content supplied to the server was invalid\",\n            \"schema\": {\n              \"$ref\": \"#/definitions/Error\"\n            }\n          },\n          \"default\": {\n            \"description\": \"There was an internal error in the server while processing the request\",\n            \"schema\": {\n              \"$ref\": \"#/definitions/Error\"\n            }\n          }\n        }\n      }\n    },\n    \"/api/v1/log/publicKey\": {\n      \"get\": {\n        \"description\": \"Returns the public key that can be used to validate the signed tree head\",\n        \"produces\": [\n          \"application/x-pem-file\"\n        ],\n        \"tags\": [\n          \"pubkey\"\n        ],\n        \"summary\": \"Retrieve the public key that can be used to validate the signed tree head\",\n        \"operationId\": \"getPublicKey\",\n        \"parameters\": [\n          {\n            \"pattern\": \"^[0-9]+$\",\n            \"type\": \"string\",\n            \"description\": \"The tree ID of the tree you wish to get a public key for\",\n            \"name\": \"treeID\",\n            \"in\": \"query\"\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"description\": \"The public key\",\n            \"schema\": {\n              \"type\": \"string\"\n            }\n          },\n          \"default\": {\n            \"description\": \"There was an internal error in the server while processing the request\",\n            \"schema\": {\n              \"$ref\": \"#/definitions/Error\"\n            }\n          }\n        }\n      }\n    }\n  },\n  \"definitions\": {\n    \"AlpineV001SchemaPackage\": {\n      \"description\": \"Information about the package associated with the entry\",\n      \"type\": \"object\",\n      \"oneOf\": [\n        {\n          \"required\": [\n            \"hash\"\n          ]\n        },\n        {\n          \"required\": [\n            \"content\"\n          ]\n        }\n      ],\n      \"properties\": {\n        \"content\": {\n          \"description\": \"Specifies the package inline within the document\",\n          \"type\": \"string\",\n          \"format\": \"byte\",\n          \"writeOnly\": true\n        },\n        \"hash\": {\n          \"description\": \"Specifies the hash algorithm and value for the package\",\n          \"type\": \"object\",\n          \"required\": [\n            \"algorithm\",\n            \"value\"\n          ],\n          \"properties\": {\n            \"algorithm\": {\n              \"description\": \"The hashing function used to compute the hash value\",\n              \"type\": \"string\",\n              \"enum\": [\n                \"sha256\"\n              ]\n            },\n            \"value\": {\n              \"description\": \"The hash value for the package\",\n              \"type\": \"string\"\n            }\n          },\n          \"readOnly\": true\n        },\n        \"pkginfo\": {\n          \"description\": \"Values of the .PKGINFO key / value pairs\",\n          \"type\": \"object\",\n          \"additionalProperties\": {\n            \"type\": \"string\"\n          },\n          \"readOnly\": true\n        }\n      }\n    },\n    \"AlpineV001SchemaPackageHash\": {\n      \"description\": \"Specifies the hash algorithm and value for the package\",\n      \"type\": \"object\",\n      \"required\": [\n        \"algorithm\",\n        \"value\"\n      ],\n      \"properties\": {\n        \"algorithm\": {\n          \"description\": \"The hashing function used to compute the hash value\",\n          \"type\": \"string\",\n          \"enum\": [\n            \"sha256\"\n          ]\n        },\n        \"value\": {\n          \"description\": \"The hash value for the package\",\n          \"type\": \"string\"\n        }\n      },\n      \"readOnly\": true\n    },\n    \"AlpineV001SchemaPublicKey\": {\n      \"description\": \"The public key that can verify the package signature\",\n      \"type\": \"object\",\n      \"required\": [\n        \"content\"\n      ],\n      \"properties\": {\n        \"content\": {\n          \"description\": \"Specifies the content of the public key inline within the document\",\n          \"type\": \"string\",\n          \"format\": \"byte\"\n        }\n      }\n    },\n    \"ConsistencyProof\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"rootHash\",\n        \"hashes\"\n      ],\n      \"properties\": {\n        \"hashes\": {\n          \"type\": \"array\",\n          \"items\": {\n            \"description\": \"SHA256 hash value expressed in hexadecimal format\",\n            \"type\": \"string\",\n            \"pattern\": \"^[0-9a-fA-F]{64}$\"\n          }\n        },\n        \"rootHash\": {\n          \"description\": \"The hash value stored at the root of the merkle tree at the time the proof was generated\",\n          \"type\": \"string\",\n          \"pattern\": \"^[0-9a-fA-F]{64}$\"\n        }\n      }\n    },\n    \"CoseV001SchemaData\": {\n      \"description\": \"Information about the content associated with the entry\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"aad\": {\n          \"description\": \"Specifies the additional authenticated data required to verify the signature\",\n          \"type\": \"string\",\n          \"format\": \"byte\",\n          \"writeOnly\": true\n        },\n        \"envelopeHash\": {\n          \"description\": \"Specifies the hash algorithm and value for the COSE envelope\",\n          \"type\": \"object\",\n          \"required\": [\n            \"algorithm\",\n            \"value\"\n          ],\n          \"properties\": {\n            \"algorithm\": {\n              \"description\": \"The hashing function used to compute the hash value\",\n              \"type\": \"string\",\n              \"enum\": [\n                \"sha256\"\n              ]\n            },\n            \"value\": {\n              \"description\": \"The hash value for the envelope\",\n              \"type\": \"string\"\n            }\n          },\n          \"readOnly\": true\n        },\n        \"payloadHash\": {\n          \"description\": \"Specifies the hash algorithm and value for the content\",\n          \"type\": \"object\",\n          \"required\": [\n            \"algorithm\",\n            \"value\"\n          ],\n          \"properties\": {\n            \"algorithm\": {\n              \"description\": \"The hashing function used to compute the hash value\",\n              \"type\": \"string\",\n              \"enum\": [\n                \"sha256\"\n              ]\n            },\n            \"value\": {\n              \"description\": \"The hash value for the content\",\n              \"type\": \"string\"\n            }\n          },\n          \"readOnly\": true\n        }\n      }\n    },\n    \"CoseV001SchemaDataEnvelopeHash\": {\n      \"description\": \"Specifies the hash algorithm and value for the COSE envelope\",\n      \"type\": \"object\",\n      \"required\": [\n        \"algorithm\",\n        \"value\"\n      ],\n      \"properties\": {\n        \"algorithm\": {\n          \"description\": \"The hashing function used to compute the hash value\",\n          \"type\": \"string\",\n          \"enum\": [\n            \"sha256\"\n          ]\n        },\n        \"value\": {\n          \"description\": \"The hash value for the envelope\",\n          \"type\": \"string\"\n        }\n      },\n      \"readOnly\": true\n    },\n    \"CoseV001SchemaDataPayloadHash\": {\n      \"description\": \"Specifies the hash algorithm and value for the content\",\n      \"type\": \"object\",\n      \"required\": [\n        \"algorithm\",\n        \"value\"\n      ],\n      \"properties\": {\n        \"algorithm\": {\n          \"description\": \"The hashing function used to compute the hash value\",\n          \"type\": \"string\",\n          \"enum\": [\n            \"sha256\"\n          ]\n        },\n        \"value\": {\n          \"description\": \"The hash value for the content\",\n          \"type\": \"string\"\n        }\n      },\n      \"readOnly\": true\n    },\n    \"DSSEV001SchemaEnvelopeHash\": {\n      \"description\": \"Specifies the hash algorithm and value encompassing the entire envelope sent to Rekor\",\n      \"type\": \"object\",\n      \"required\": [\n        \"algorithm\",\n        \"value\"\n      ],\n      \"properties\": {\n        \"algorithm\": {\n          \"description\": \"The hashing function used to compute the hash value\",\n          \"type\": \"string\",\n          \"enum\": [\n            \"sha256\"\n          ]\n        },\n        \"value\": {\n          \"description\": \"The value of the computed digest over the entire envelope\",\n          \"type\": \"string\"\n        }\n      },\n      \"readOnly\": true\n    },\n    \"DSSEV001SchemaPayloadHash\": {\n      \"description\": \"Specifies the hash algorithm and value covering the payload within the DSSE envelope\",\n      \"type\": \"object\",\n      \"required\": [\n        \"algorithm\",\n        \"value\"\n      ],\n      \"properties\": {\n        \"algorithm\": {\n          \"description\": \"The hashing function used to compute the hash value\",\n          \"type\": \"string\",\n          \"enum\": [\n            \"sha256\"\n          ]\n        },\n        \"value\": {\n          \"description\": \"The value of the computed digest over the payload within the envelope\",\n          \"type\": \"string\"\n        }\n      },\n      \"readOnly\": true\n    },\n    \"DSSEV001SchemaProposedContent\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"envelope\",\n        \"verifiers\"\n      ],\n      \"properties\": {\n        \"envelope\": {\n          \"description\": \"DSSE envelope specified as a stringified JSON object\",\n          \"type\": \"string\",\n          \"writeOnly\": true\n        },\n        \"verifiers\": {\n          \"description\": \"collection of all verification material (e.g. public keys or certificates) used to verify signatures over envelope's payload, specified as base64-encoded strings\",\n          \"type\": \"array\",\n          \"minItems\": 1,\n          \"items\": {\n            \"type\": \"string\",\n            \"format\": \"byte\"\n          },\n          \"writeOnly\": true\n        }\n      },\n      \"writeOnly\": true\n    },\n    \"DSSEV001SchemaSignaturesItems0\": {\n      \"description\": \"a signature of the envelope's payload along with the verification material for the signature\",\n      \"type\": \"object\",\n      \"required\": [\n        \"signature\",\n        \"verifier\"\n      ],\n      \"properties\": {\n        \"signature\": {\n          \"description\": \"base64 encoded signature of the payload\",\n          \"type\": \"string\",\n          \"pattern\": \"^(?:[A-Za-z0-9+\\\\/]{4})*(?:[A-Za-z0-9+\\\\/]{2}==|[A-Za-z0-9+\\\\/]{3}=|[A-Za-z0-9+\\\\/]{4})$\"\n        },\n        \"verifier\": {\n          \"description\": \"verification material that was used to verify the corresponding signature, specified as a base64 encoded string\",\n          \"type\": \"string\",\n          \"format\": \"byte\"\n        }\n      }\n    },\n    \"Error\": {\n      \"type\": \"object\",\n      \"properties\": {\n        \"code\": {\n          \"type\": \"integer\"\n        },\n        \"message\": {\n          \"type\": \"string\"\n        }\n      }\n    },\n    \"HashedrekordV001SchemaData\": {\n      \"description\": \"Information about the content associated with the entry\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"hash\": {\n          \"description\": \"Specifies the hash algorithm and value for the content\",\n          \"type\": \"object\",\n          \"required\": [\n            \"algorithm\",\n            \"value\"\n          ],\n          \"properties\": {\n            \"algorithm\": {\n              \"description\": \"The hashing function used to compute the hash value\",\n              \"type\": \"string\",\n              \"enum\": [\n                \"sha256\"\n              ]\n            },\n            \"value\": {\n              \"description\": \"The hash value for the content\",\n              \"type\": \"string\"\n            }\n          }\n        }\n      }\n    },\n    \"HashedrekordV001SchemaDataHash\": {\n      \"description\": \"Specifies the hash algorithm and value for the content\",\n      \"type\": \"object\",\n      \"required\": [\n        \"algorithm\",\n        \"value\"\n      ],\n      \"properties\": {\n        \"algorithm\": {\n          \"description\": \"The hashing function used to compute the hash value\",\n          \"type\": \"string\",\n          \"enum\": [\n            \"sha256\"\n          ]\n        },\n        \"value\": {\n          \"description\": \"The hash value for the content\",\n          \"type\": \"string\"\n        }\n      }\n    },\n    \"HashedrekordV001SchemaSignature\": {\n      \"description\": \"Information about the detached signature associated with the entry\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"content\": {\n          \"description\": \"Specifies the content of the signature inline within the document\",\n          \"type\": \"string\",\n          \"format\": \"byte\"\n        },\n        \"publicKey\": {\n          \"description\": \"The public key that can verify the signature; this can also be an X509 code signing certificate that contains the raw public key information\",\n          \"type\": \"object\",\n          \"properties\": {\n            \"content\": {\n              \"description\": \"Specifies the content of the public key or code signing certificate inline within the document\",\n              \"type\": \"string\",\n              \"format\": \"byte\"\n            }\n          }\n        }\n      }\n    },\n    \"HashedrekordV001SchemaSignaturePublicKey\": {\n      \"description\": \"The public key that can verify the signature; this can also be an X509 code signing certificate that contains the raw public key information\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"content\": {\n          \"description\": \"Specifies the content of the public key or code signing certificate inline within the document\",\n          \"type\": \"string\",\n          \"format\": \"byte\"\n        }\n      }\n    },\n    \"HelmV001SchemaChart\": {\n      \"description\": \"Information about the Helm chart associated with the entry\",\n      \"type\": \"object\",\n      \"required\": [\n        \"provenance\"\n      ],\n      \"properties\": {\n        \"hash\": {\n          \"description\": \"Specifies the hash algorithm and value for the chart\",\n          \"type\": \"object\",\n          \"required\": [\n            \"algorithm\",\n            \"value\"\n          ],\n          \"properties\": {\n            \"algorithm\": {\n              \"description\": \"The hashing function used to compute the hash value\",\n              \"type\": \"string\",\n              \"enum\": [\n                \"sha256\"\n              ]\n            },\n            \"value\": {\n              \"description\": \"The hash value for the chart\",\n              \"type\": \"string\"\n            }\n          },\n          \"readOnly\": true\n        },\n        \"provenance\": {\n          \"description\": \"The provenance entry associated with the signed Helm Chart\",\n          \"type\": \"object\",\n          \"oneOf\": [\n            {\n              \"required\": [\n                \"signature\"\n              ]\n            },\n            {\n              \"required\": [\n                \"content\"\n              ]\n            }\n          ],\n          \"properties\": {\n            \"content\": {\n              \"description\": \"Specifies the content of the provenance file inline within the document\",\n              \"type\": \"string\",\n              \"format\": \"byte\",\n              \"writeOnly\": true\n            },\n            \"signature\": {\n              \"description\": \"Information about the included signature in the provenance file\",\n              \"type\": \"object\",\n              \"required\": [\n                \"content\"\n              ],\n              \"properties\": {\n                \"content\": {\n                  \"description\": \"Specifies the signature embedded within the provenance file \",\n                  \"type\": \"string\",\n                  \"format\": \"byte\",\n                  \"readOnly\": true\n                }\n              },\n              \"readOnly\": true\n            }\n          }\n        }\n      }\n    },\n    \"HelmV001SchemaChartHash\": {\n      \"description\": \"Specifies the hash algorithm and value for the chart\",\n      \"type\": \"object\",\n      \"required\": [\n        \"algorithm\",\n        \"value\"\n      ],\n      \"properties\": {\n        \"algorithm\": {\n          \"description\": \"The hashing function used to compute the hash value\",\n          \"type\": \"string\",\n          \"enum\": [\n            \"sha256\"\n          ]\n        },\n        \"value\": {\n          \"description\": \"The hash value for the chart\",\n          \"type\": \"string\"\n        }\n      },\n      \"readOnly\": true\n    },\n    \"HelmV001SchemaChartProvenance\": {\n      \"description\": \"The provenance entry associated with the signed Helm Chart\",\n      \"type\": \"object\",\n      \"oneOf\": [\n        {\n          \"required\": [\n            \"signature\"\n          ]\n        },\n        {\n          \"required\": [\n            \"content\"\n          ]\n        }\n      ],\n      \"properties\": {\n        \"content\": {\n          \"description\": \"Specifies the content of the provenance file inline within the document\",\n          \"type\": \"string\",\n          \"format\": \"byte\",\n          \"writeOnly\": true\n        },\n        \"signature\": {\n          \"description\": \"Information about the included signature in the provenance file\",\n          \"type\": \"object\",\n          \"required\": [\n            \"content\"\n          ],\n          \"properties\": {\n            \"content\": {\n              \"description\": \"Specifies the signature embedded within the provenance file \",\n              \"type\": \"string\",\n              \"format\": \"byte\",\n              \"readOnly\": true\n            }\n          },\n          \"readOnly\": true\n        }\n      }\n    },\n    \"HelmV001SchemaChartProvenanceSignature\": {\n      \"description\": \"Information about the included signature in the provenance file\",\n      \"type\": \"object\",\n      \"required\": [\n        \"content\"\n      ],\n      \"properties\": {\n        \"content\": {\n          \"description\": \"Specifies the signature embedded within the provenance file \",\n          \"type\": \"string\",\n          \"format\": \"byte\",\n          \"readOnly\": true\n        }\n      },\n      \"readOnly\": true\n    },\n    \"HelmV001SchemaPublicKey\": {\n      \"description\": \"The public key that can verify the package signature\",\n      \"type\": \"object\",\n      \"required\": [\n        \"content\"\n      ],\n      \"properties\": {\n        \"content\": {\n          \"description\": \"Specifies the content of the public key inline within the document\",\n          \"type\": \"string\",\n          \"format\": \"byte\"\n        }\n      }\n    },\n    \"InactiveShardLogInfo\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"rootHash\",\n        \"treeSize\",\n        \"signedTreeHead\",\n        \"treeID\"\n      ],\n      \"properties\": {\n        \"rootHash\": {\n          \"description\": \"The current hash value stored at the root of the merkle tree\",\n          \"type\": \"string\",\n          \"pattern\": \"^[0-9a-fA-F]{64}$\"\n        },\n        \"signedTreeHead\": {\n          \"description\": \"The current signed tree head\",\n          \"type\": \"string\",\n          \"format\": \"signedCheckpoint\"\n        },\n        \"treeID\": {\n          \"description\": \"The current treeID\",\n          \"type\": \"string\",\n          \"pattern\": \"^[0-9]+$\"\n        },\n        \"treeSize\": {\n          \"description\": \"The current number of nodes in the merkle tree\",\n          \"type\": \"integer\",\n          \"minimum\": 1\n        }\n      }\n    },\n    \"InclusionProof\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"logIndex\",\n        \"rootHash\",\n        \"treeSize\",\n        \"hashes\",\n        \"checkpoint\"\n      ],\n      \"properties\": {\n        \"checkpoint\": {\n          \"description\": \"The checkpoint (signed tree head) that the inclusion proof is based on\",\n          \"type\": \"string\",\n          \"format\": \"signedCheckpoint\"\n        },\n        \"hashes\": {\n          \"description\": \"A list of hashes required to compute the inclusion proof, sorted in order from leaf to root\",\n          \"type\": \"array\",\n          \"items\": {\n            \"description\": \"SHA256 hash value expressed in hexadecimal format\",\n            \"type\": \"string\",\n            \"pattern\": \"^[0-9a-fA-F]{64}$\"\n          }\n        },\n        \"logIndex\": {\n          \"description\": \"The index of the entry in the transparency log\",\n          \"type\": \"integer\",\n          \"minimum\": 0\n        },\n        \"rootHash\": {\n          \"description\": \"The hash value stored at the root of the merkle tree at the time the proof was generated\",\n          \"type\": \"string\",\n          \"pattern\": \"^[0-9a-fA-F]{64}$\"\n        },\n        \"treeSize\": {\n          \"description\": \"The size of the merkle tree at the time the inclusion proof was generated\",\n          \"type\": \"integer\",\n          \"minimum\": 1\n        }\n      }\n    },\n    \"IntotoV001SchemaContent\": {\n      \"type\": \"object\",\n      \"properties\": {\n        \"envelope\": {\n          \"description\": \"envelope\",\n          \"type\": \"string\",\n          \"writeOnly\": true\n        },\n        \"hash\": {\n          \"description\": \"Specifies the hash algorithm and value encompassing the entire signed envelope; this is computed by the rekor server, client-provided values are ignored\",\n          \"type\": \"object\",\n          \"required\": [\n            \"algorithm\",\n            \"value\"\n          ],\n          \"properties\": {\n            \"algorithm\": {\n              \"description\": \"The hashing function used to compute the hash value\",\n              \"type\": \"string\",\n              \"enum\": [\n                \"sha256\"\n              ]\n            },\n            \"value\": {\n              \"description\": \"The hash value for the archive\",\n              \"type\": \"string\"\n            }\n          },\n          \"readOnly\": true\n        },\n        \"payloadHash\": {\n          \"description\": \"Specifies the hash algorithm and value covering the payload within the DSSE envelope; this is computed by the rekor server, client-provided values are ignored\",\n          \"type\": \"object\",\n          \"required\": [\n            \"algorithm\",\n            \"value\"\n          ],\n          \"properties\": {\n            \"algorithm\": {\n              \"description\": \"The hashing function used to compute the hash value\",\n              \"type\": \"string\",\n              \"enum\": [\n                \"sha256\"\n              ]\n            },\n            \"value\": {\n              \"description\": \"The hash value for the envelope's payload\",\n              \"type\": \"string\"\n            }\n          },\n          \"readOnly\": true\n        }\n      }\n    },\n    \"IntotoV001SchemaContentHash\": {\n      \"description\": \"Specifies the hash algorithm and value encompassing the entire signed envelope; this is computed by the rekor server, client-provided values are ignored\",\n      \"type\": \"object\",\n      \"required\": [\n        \"algorithm\",\n        \"value\"\n      ],\n      \"properties\": {\n        \"algorithm\": {\n          \"description\": \"The hashing function used to compute the hash value\",\n          \"type\": \"string\",\n          \"enum\": [\n            \"sha256\"\n          ]\n        },\n        \"value\": {\n          \"description\": \"The hash value for the archive\",\n          \"type\": \"string\"\n        }\n      },\n      \"readOnly\": true\n    },\n    \"IntotoV001SchemaContentPayloadHash\": {\n      \"description\": \"Specifies the hash algorithm and value covering the payload within the DSSE envelope; this is computed by the rekor server, client-provided values are ignored\",\n      \"type\": \"object\",\n      \"required\": [\n        \"algorithm\",\n        \"value\"\n      ],\n      \"properties\": {\n        \"algorithm\": {\n          \"description\": \"The hashing function used to compute the hash value\",\n          \"type\": \"string\",\n          \"enum\": [\n            \"sha256\"\n          ]\n        },\n        \"value\": {\n          \"description\": \"The hash value for the envelope's payload\",\n          \"type\": \"string\"\n        }\n      },\n      \"readOnly\": true\n    },\n    \"IntotoV002SchemaContent\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"envelope\"\n      ],\n      \"properties\": {\n        \"envelope\": {\n          \"description\": \"dsse envelope\",\n          \"type\": \"object\",\n          \"required\": [\n            \"payloadType\",\n            \"signatures\"\n          ],\n          \"properties\": {\n            \"payload\": {\n              \"description\": \"payload of the envelope\",\n              \"type\": \"string\",\n              \"format\": \"byte\",\n              \"writeOnly\": true\n            },\n            \"payloadType\": {\n              \"description\": \"type describing the payload\",\n              \"type\": \"string\"\n            },\n            \"signatures\": {\n              \"description\": \"collection of all signatures of the envelope's payload\",\n              \"type\": \"array\",\n              \"minItems\": 1,\n              \"items\": {\n                \"$ref\": \"#/definitions/IntotoV002SchemaContentEnvelopeSignaturesItems0\"\n              }\n            }\n          }\n        },\n        \"hash\": {\n          \"description\": \"Specifies the hash algorithm and value encompassing the entire signed envelope\",\n          \"type\": \"object\",\n          \"required\": [\n            \"algorithm\",\n            \"value\"\n          ],\n          \"properties\": {\n            \"algorithm\": {\n              \"description\": \"The hashing function used to compute the hash value\",\n              \"type\": \"string\",\n              \"enum\": [\n                \"sha256\"\n              ]\n            },\n            \"value\": {\n              \"description\": \"The hash value for the archive\",\n              \"type\": \"string\"\n            }\n          },\n          \"readOnly\": true\n        },\n        \"payloadHash\": {\n          \"description\": \"Specifies the hash algorithm and value covering the payload within the DSSE envelope\",\n          \"type\": \"object\",\n          \"required\": [\n            \"algorithm\",\n            \"value\"\n          ],\n          \"properties\": {\n            \"algorithm\": {\n              \"description\": \"The hashing function used to compute the hash value\",\n              \"type\": \"string\",\n              \"enum\": [\n                \"sha256\"\n              ]\n            },\n            \"value\": {\n              \"description\": \"The hash value of the payload\",\n              \"type\": \"string\"\n            }\n          },\n          \"readOnly\": true\n        }\n      }\n    },\n    \"IntotoV002SchemaContentEnvelope\": {\n      \"description\": \"dsse envelope\",\n      \"type\": \"object\",\n      \"required\": [\n        \"payloadType\",\n        \"signatures\"\n      ],\n      \"properties\": {\n        \"payload\": {\n          \"description\": \"payload of the envelope\",\n          \"type\": \"string\",\n          \"format\": \"byte\",\n          \"writeOnly\": true\n        },\n        \"payloadType\": {\n          \"description\": \"type describing the payload\",\n          \"type\": \"string\"\n        },\n        \"signatures\": {\n          \"description\": \"collection of all signatures of the envelope's payload\",\n          \"type\": \"array\",\n          \"minItems\": 1,\n          \"items\": {\n            \"$ref\": \"#/definitions/IntotoV002SchemaContentEnvelopeSignaturesItems0\"\n          }\n        }\n      }\n    },\n    \"IntotoV002SchemaContentEnvelopeSignaturesItems0\": {\n      \"description\": \"a signature of the envelope's payload along with the public key for the signature\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"keyid\": {\n          \"description\": \"optional id of the key used to create the signature\",\n          \"type\": \"string\"\n        },\n        \"publicKey\": {\n          \"description\": \"public key that corresponds to this signature\",\n          \"type\": \"string\",\n          \"format\": \"byte\"\n        },\n        \"sig\": {\n          \"description\": \"signature of the payload\",\n          \"type\": \"string\",\n          \"format\": \"byte\"\n        }\n      }\n    },\n    \"IntotoV002SchemaContentHash\": {\n      \"description\": \"Specifies the hash algorithm and value encompassing the entire signed envelope\",\n      \"type\": \"object\",\n      \"required\": [\n        \"algorithm\",\n        \"value\"\n      ],\n      \"properties\": {\n        \"algorithm\": {\n          \"description\": \"The hashing function used to compute the hash value\",\n          \"type\": \"string\",\n          \"enum\": [\n            \"sha256\"\n          ]\n        },\n        \"value\": {\n          \"description\": \"The hash value for the archive\",\n          \"type\": \"string\"\n        }\n      },\n      \"readOnly\": true\n    },\n    \"IntotoV002SchemaContentPayloadHash\": {\n      \"description\": \"Specifies the hash algorithm and value covering the payload within the DSSE envelope\",\n      \"type\": \"object\",\n      \"required\": [\n        \"algorithm\",\n        \"value\"\n      ],\n      \"properties\": {\n        \"algorithm\": {\n          \"description\": \"The hashing function used to compute the hash value\",\n          \"type\": \"string\",\n          \"enum\": [\n            \"sha256\"\n          ]\n        },\n        \"value\": {\n          \"description\": \"The hash value of the payload\",\n          \"type\": \"string\"\n        }\n      },\n      \"readOnly\": true\n    },\n    \"JarV001SchemaArchive\": {\n      \"description\": \"Information about the archive associated with the entry\",\n      \"type\": \"object\",\n      \"oneOf\": [\n        {\n          \"required\": [\n            \"hash\"\n          ]\n        },\n        {\n          \"required\": [\n            \"content\"\n          ]\n        }\n      ],\n      \"properties\": {\n        \"content\": {\n          \"description\": \"Specifies the archive inline within the document\",\n          \"type\": \"string\",\n          \"format\": \"byte\",\n          \"writeOnly\": true\n        },\n        \"hash\": {\n          \"description\": \"Specifies the hash algorithm and value encompassing the entire signed archive\",\n          \"type\": \"object\",\n          \"required\": [\n            \"algorithm\",\n            \"value\"\n          ],\n          \"properties\": {\n            \"algorithm\": {\n              \"description\": \"The hashing function used to compute the hash value\",\n              \"type\": \"string\",\n              \"enum\": [\n                \"sha256\"\n              ]\n            },\n            \"value\": {\n              \"description\": \"The hash value for the archive\",\n              \"type\": \"string\"\n            }\n          }\n        }\n      }\n    },\n    \"JarV001SchemaArchiveHash\": {\n      \"description\": \"Specifies the hash algorithm and value encompassing the entire signed archive\",\n      \"type\": \"object\",\n      \"required\": [\n        \"algorithm\",\n        \"value\"\n      ],\n      \"properties\": {\n        \"algorithm\": {\n          \"description\": \"The hashing function used to compute the hash value\",\n          \"type\": \"string\",\n          \"enum\": [\n            \"sha256\"\n          ]\n        },\n        \"value\": {\n          \"description\": \"The hash value for the archive\",\n          \"type\": \"string\"\n        }\n      }\n    },\n    \"JarV001SchemaSignature\": {\n      \"description\": \"Information about the included signature in the JAR file\",\n      \"type\": \"object\",\n      \"required\": [\n        \"publicKey\",\n        \"content\"\n      ],\n      \"properties\": {\n        \"content\": {\n          \"description\": \"Specifies the PKCS7 signature embedded within the JAR file \",\n          \"type\": \"string\",\n          \"format\": \"byte\",\n          \"readOnly\": true\n        },\n        \"publicKey\": {\n          \"description\": \"The X509 certificate containing the public key JAR which verifies the signature of the JAR\",\n          \"type\": \"object\",\n          \"required\": [\n            \"content\"\n          ],\n          \"properties\": {\n            \"content\": {\n              \"description\": \"Specifies the content of the X509 certificate containing the public key used to verify the signature\",\n              \"type\": \"string\",\n              \"format\": \"byte\"\n            }\n          },\n          \"readOnly\": true\n        }\n      }\n    },\n    \"JarV001SchemaSignaturePublicKey\": {\n      \"description\": \"The X509 certificate containing the public key JAR which verifies the signature of the JAR\",\n      \"type\": \"object\",\n      \"required\": [\n        \"content\"\n      ],\n      \"properties\": {\n        \"content\": {\n          \"description\": \"Specifies the content of the X509 certificate containing the public key used to verify the signature\",\n          \"type\": \"string\",\n          \"format\": \"byte\"\n        }\n      },\n      \"readOnly\": true\n    },\n    \"LogEntry\": {\n      \"type\": \"object\",\n      \"additionalProperties\": {\n        \"$ref\": \"#/definitions/LogEntryAnon\"\n      }\n    },\n    \"LogEntryAnon\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"logID\",\n        \"logIndex\",\n        \"body\",\n        \"integratedTime\"\n      ],\n      \"properties\": {\n        \"attestation\": {\n          \"type\": \"object\",\n          \"format\": \"byte\",\n          \"properties\": {\n            \"data\": {\n              \"format\": \"byte\"\n            }\n          }\n        },\n        \"body\": {\n          \"type\": \"object\",\n          \"additionalProperties\": true\n        },\n        \"integratedTime\": {\n          \"type\": \"integer\"\n        },\n        \"logID\": {\n          \"description\": \"This is the SHA256 hash of the DER-encoded public key for the log at the time the entry was included in the log\",\n          \"type\": \"string\",\n          \"pattern\": \"^[0-9a-fA-F]{64}$\"\n        },\n        \"logIndex\": {\n          \"type\": \"integer\",\n          \"minimum\": 0\n        },\n        \"verification\": {\n          \"type\": \"object\",\n          \"properties\": {\n            \"inclusionProof\": {\n              \"$ref\": \"#/definitions/InclusionProof\"\n            },\n            \"signedEntryTimestamp\": {\n              \"description\": \"Signature over the logID, logIndex, body and integratedTime.\",\n              \"type\": \"string\",\n              \"format\": \"byte\"\n            }\n          }\n        }\n      }\n    },\n    \"LogEntryAnonAttestation\": {\n      \"type\": \"object\",\n      \"format\": \"byte\",\n      \"properties\": {\n        \"data\": {\n          \"format\": \"byte\"\n        }\n      }\n    },\n    \"LogEntryAnonVerification\": {\n      \"type\": \"object\",\n      \"properties\": {\n        \"inclusionProof\": {\n          \"$ref\": \"#/definitions/InclusionProof\"\n        },\n        \"signedEntryTimestamp\": {\n          \"description\": \"Signature over the logID, logIndex, body and integratedTime.\",\n          \"type\": \"string\",\n          \"format\": \"byte\"\n        }\n      }\n    },\n    \"LogInfo\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"rootHash\",\n        \"treeSize\",\n        \"signedTreeHead\",\n        \"treeID\"\n      ],\n      \"properties\": {\n        \"inactiveShards\": {\n          \"type\": \"array\",\n          \"items\": {\n            \"$ref\": \"#/definitions/InactiveShardLogInfo\"\n          }\n        },\n        \"rootHash\": {\n          \"description\": \"The current hash value stored at the root of the merkle tree\",\n          \"type\": \"string\",\n          \"pattern\": \"^[0-9a-fA-F]{64}$\"\n        },\n        \"signedTreeHead\": {\n          \"description\": \"The current signed tree head\",\n          \"type\": \"string\",\n          \"format\": \"signedCheckpoint\"\n        },\n        \"treeID\": {\n          \"description\": \"The current treeID\",\n          \"type\": \"string\",\n          \"pattern\": \"^[0-9]+$\"\n        },\n        \"treeSize\": {\n          \"description\": \"The current number of nodes in the merkle tree\",\n          \"type\": \"integer\",\n          \"minimum\": 1\n        }\n      }\n    },\n    \"ProposedEntry\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"kind\"\n      ],\n      \"properties\": {\n        \"kind\": {\n          \"type\": \"string\"\n        }\n      },\n      \"discriminator\": \"kind\"\n    },\n    \"RekordV001SchemaData\": {\n      \"description\": \"Information about the content associated with the entry\",\n      \"type\": \"object\",\n      \"oneOf\": [\n        {\n          \"required\": [\n            \"hash\"\n          ]\n        },\n        {\n          \"required\": [\n            \"content\"\n          ]\n        }\n      ],\n      \"properties\": {\n        \"content\": {\n          \"description\": \"Specifies the content inline within the document\",\n          \"type\": \"string\",\n          \"format\": \"byte\",\n          \"writeOnly\": true\n        },\n        \"hash\": {\n          \"description\": \"Specifies the hash algorithm and value for the content\",\n          \"type\": \"object\",\n          \"required\": [\n            \"algorithm\",\n            \"value\"\n          ],\n          \"properties\": {\n            \"algorithm\": {\n              \"description\": \"The hashing function used to compute the hash value\",\n              \"type\": \"string\",\n              \"enum\": [\n                \"sha256\"\n              ]\n            },\n            \"value\": {\n              \"description\": \"The hash value for the content\",\n              \"type\": \"string\"\n            }\n          },\n          \"readOnly\": true\n        }\n      }\n    },\n    \"RekordV001SchemaDataHash\": {\n      \"description\": \"Specifies the hash algorithm and value for the content\",\n      \"type\": \"object\",\n      \"required\": [\n        \"algorithm\",\n        \"value\"\n      ],\n      \"properties\": {\n        \"algorithm\": {\n          \"description\": \"The hashing function used to compute the hash value\",\n          \"type\": \"string\",\n          \"enum\": [\n            \"sha256\"\n          ]\n        },\n        \"value\": {\n          \"description\": \"The hash value for the content\",\n          \"type\": \"string\"\n        }\n      },\n      \"readOnly\": true\n    },\n    \"RekordV001SchemaSignature\": {\n      \"description\": \"Information about the detached signature associated with the entry\",\n      \"type\": \"object\",\n      \"required\": [\n        \"format\",\n        \"publicKey\",\n        \"content\"\n      ],\n      \"properties\": {\n        \"content\": {\n          \"description\": \"Specifies the content of the signature inline within the document\",\n          \"type\": \"string\",\n          \"format\": \"byte\"\n        },\n        \"format\": {\n          \"description\": \"Specifies the format of the signature\",\n          \"type\": \"string\",\n          \"enum\": [\n            \"pgp\",\n            \"minisign\",\n            \"x509\",\n            \"ssh\"\n          ]\n        },\n        \"publicKey\": {\n          \"description\": \"The public key that can verify the signature\",\n          \"type\": \"object\",\n          \"required\": [\n            \"content\"\n          ],\n          \"properties\": {\n            \"content\": {\n              \"description\": \"Specifies the content of the public key inline within the document\",\n              \"type\": \"string\",\n              \"format\": \"byte\"\n            }\n          }\n        }\n      }\n    },\n    \"RekordV001SchemaSignaturePublicKey\": {\n      \"description\": \"The public key that can verify the signature\",\n      \"type\": \"object\",\n      \"required\": [\n        \"content\"\n      ],\n      \"properties\": {\n        \"content\": {\n          \"description\": \"Specifies the content of the public key inline within the document\",\n          \"type\": \"string\",\n          \"format\": \"byte\"\n        }\n      }\n    },\n    \"Rfc3161V001SchemaTsr\": {\n      \"description\": \"Information about the tsr file associated with the entry\",\n      \"type\": \"object\",\n      \"required\": [\n        \"content\"\n      ],\n      \"properties\": {\n        \"content\": {\n          \"description\": \"Specifies the tsr file content inline within the document\",\n          \"type\": \"string\",\n          \"format\": \"byte\"\n        }\n      }\n    },\n    \"RpmV001SchemaPackage\": {\n      \"description\": \"Information about the package associated with the entry\",\n      \"type\": \"object\",\n      \"oneOf\": [\n        {\n          \"required\": [\n            \"hash\"\n          ]\n        },\n        {\n          \"required\": [\n            \"content\"\n          ]\n        }\n      ],\n      \"properties\": {\n        \"content\": {\n          \"description\": \"Specifies the package inline within the document\",\n          \"type\": \"string\",\n          \"format\": \"byte\",\n          \"writeOnly\": true\n        },\n        \"hash\": {\n          \"description\": \"Specifies the hash algorithm and value for the package\",\n          \"type\": \"object\",\n          \"required\": [\n            \"algorithm\",\n            \"value\"\n          ],\n          \"properties\": {\n            \"algorithm\": {\n              \"description\": \"The hashing function used to compute the hash value\",\n              \"type\": \"string\",\n              \"enum\": [\n                \"sha256\"\n              ]\n            },\n            \"value\": {\n              \"description\": \"The hash value for the package\",\n              \"type\": \"string\"\n            }\n          }\n        },\n        \"headers\": {\n          \"description\": \"Values of the RPM headers\",\n          \"type\": \"object\",\n          \"additionalProperties\": {\n            \"type\": \"string\"\n          },\n          \"readOnly\": true\n        }\n      }\n    },\n    \"RpmV001SchemaPackageHash\": {\n      \"description\": \"Specifies the hash algorithm and value for the package\",\n      \"type\": \"object\",\n      \"required\": [\n        \"algorithm\",\n        \"value\"\n      ],\n      \"properties\": {\n        \"algorithm\": {\n          \"description\": \"The hashing function used to compute the hash value\",\n          \"type\": \"string\",\n          \"enum\": [\n            \"sha256\"\n          ]\n        },\n        \"value\": {\n          \"description\": \"The hash value for the package\",\n          \"type\": \"string\"\n        }\n      }\n    },\n    \"RpmV001SchemaPublicKey\": {\n      \"description\": \"The PGP public key that can verify the RPM signature\",\n      \"type\": \"object\",\n      \"required\": [\n        \"content\"\n      ],\n      \"properties\": {\n        \"content\": {\n          \"description\": \"Specifies the content of the public key inline within the document\",\n          \"type\": \"string\",\n          \"format\": \"byte\"\n        }\n      }\n    },\n    \"SearchIndex\": {\n      \"type\": \"object\",\n      \"properties\": {\n        \"email\": {\n          \"type\": \"string\",\n          \"format\": \"email\"\n        },\n        \"hash\": {\n          \"type\": \"string\",\n          \"pattern\": \"^(sha512:)?[0-9a-fA-F]{128}$|^(sha256:)?[0-9a-fA-F]{64}$|^(sha1:)?[0-9a-fA-F]{40}$\"\n        },\n        \"operator\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"and\",\n            \"or\"\n          ]\n        },\n        \"publicKey\": {\n          \"type\": \"object\",\n          \"required\": [\n            \"format\"\n          ],\n          \"properties\": {\n            \"content\": {\n              \"type\": \"string\",\n              \"format\": \"byte\"\n            },\n            \"format\": {\n              \"type\": \"string\",\n              \"enum\": [\n                \"pgp\",\n                \"x509\",\n                \"minisign\",\n                \"ssh\",\n                \"tuf\"\n              ]\n            },\n            \"url\": {\n              \"type\": \"string\",\n              \"format\": \"uri\"\n            }\n          }\n        }\n      }\n    },\n    \"SearchIndexPublicKey\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"format\"\n      ],\n      \"properties\": {\n        \"content\": {\n          \"type\": \"string\",\n          \"format\": \"byte\"\n        },\n        \"format\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"pgp\",\n            \"x509\",\n            \"minisign\",\n            \"ssh\",\n            \"tuf\"\n          ]\n        },\n        \"url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        }\n      }\n    },\n    \"SearchLogQuery\": {\n      \"type\": \"object\",\n      \"properties\": {\n        \"entries\": {\n          \"type\": \"array\",\n          \"maxItems\": 10,\n          \"minItems\": 1,\n          \"items\": {\n            \"$ref\": \"#/definitions/ProposedEntry\"\n          }\n        },\n        \"entryUUIDs\": {\n          \"type\": \"array\",\n          \"maxItems\": 10,\n          \"minItems\": 1,\n          \"items\": {\n            \"type\": \"string\",\n            \"pattern\": \"^([0-9a-fA-F]{64}|[0-9a-fA-F]{80})$\"\n          }\n        },\n        \"logIndexes\": {\n          \"type\": \"array\",\n          \"maxItems\": 10,\n          \"minItems\": 1,\n          \"items\": {\n            \"type\": \"integer\",\n            \"minimum\": 0\n          }\n        }\n      }\n    },\n    \"TUFV001SchemaMetadata\": {\n      \"description\": \"TUF metadata\",\n      \"type\": \"object\",\n      \"required\": [\n        \"content\"\n      ],\n      \"properties\": {\n        \"content\": {\n          \"description\": \"Specifies the metadata inline within the document\",\n          \"type\": \"object\",\n          \"additionalProperties\": true\n        }\n      }\n    },\n    \"TUFV001SchemaRoot\": {\n      \"description\": \"root metadata containing about the public keys used to sign the manifest\",\n      \"type\": \"object\",\n      \"required\": [\n        \"content\"\n      ],\n      \"properties\": {\n        \"content\": {\n          \"description\": \"Specifies the metadata inline within the document\",\n          \"type\": \"object\",\n          \"additionalProperties\": true\n        }\n      }\n    },\n    \"alpine\": {\n      \"description\": \"Alpine package\",\n      \"type\": \"object\",\n      \"allOf\": [\n        {\n          \"$ref\": \"#/definitions/ProposedEntry\"\n        },\n        {\n          \"required\": [\n            \"apiVersion\",\n            \"spec\"\n          ],\n          \"properties\": {\n            \"apiVersion\": {\n              \"type\": \"string\",\n              \"pattern\": \"^(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)(?:-((?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\\\.(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\\\+([0-9a-zA-Z-]+(?:\\\\.[0-9a-zA-Z-]+)*))?$\"\n            },\n            \"spec\": {\n              \"$ref\": \"#/definitions/alpineSchema\"\n            }\n          },\n          \"additionalProperties\": false\n        }\n      ]\n    },\n    \"alpineSchema\": {\n      \"description\": \"Schema for Alpine package objects\",\n      \"type\": \"object\",\n      \"title\": \"Alpine Package Schema\",\n      \"oneOf\": [\n        {\n          \"$ref\": \"#/definitions/alpineV001Schema\"\n        }\n      ],\n      \"$schema\": \"http://json-schema.org/draft-07/schema\",\n      \"$id\": \"http://rekor.sigstore.dev/types/alpine/alpine_schema.json\"\n    },\n    \"alpineV001Schema\": {\n      \"description\": \"Schema for Alpine Package entries\",\n      \"type\": \"object\",\n      \"title\": \"Alpine v0.0.1 Schema\",\n      \"required\": [\n        \"publicKey\",\n        \"package\"\n      ],\n      \"properties\": {\n        \"package\": {\n          \"description\": \"Information about the package associated with the entry\",\n          \"type\": \"object\",\n          \"oneOf\": [\n            {\n              \"required\": [\n                \"hash\"\n              ]\n            },\n            {\n              \"required\": [\n                \"content\"\n              ]\n            }\n          ],\n          \"properties\": {\n            \"content\": {\n              \"description\": \"Specifies the package inline within the document\",\n              \"type\": \"string\",\n              \"format\": \"byte\",\n              \"writeOnly\": true\n            },\n            \"hash\": {\n              \"description\": \"Specifies the hash algorithm and value for the package\",\n              \"type\": \"object\",\n              \"required\": [\n                \"algorithm\",\n                \"value\"\n              ],\n              \"properties\": {\n                \"algorithm\": {\n                  \"description\": \"The hashing function used to compute the hash value\",\n                  \"type\": \"string\",\n                  \"enum\": [\n                    \"sha256\"\n                  ]\n                },\n                \"value\": {\n                  \"description\": \"The hash value for the package\",\n                  \"type\": \"string\"\n                }\n              },\n              \"readOnly\": true\n            },\n            \"pkginfo\": {\n              \"description\": \"Values of the .PKGINFO key / value pairs\",\n              \"type\": \"object\",\n              \"additionalProperties\": {\n                \"type\": \"string\"\n              },\n              \"readOnly\": true\n            }\n          }\n        },\n        \"publicKey\": {\n          \"description\": \"The public key that can verify the package signature\",\n          \"type\": \"object\",\n          \"required\": [\n            \"content\"\n          ],\n          \"properties\": {\n            \"content\": {\n              \"description\": \"Specifies the content of the public key inline within the document\",\n              \"type\": \"string\",\n              \"format\": \"byte\"\n            }\n          }\n        }\n      },\n      \"$schema\": \"http://json-schema.org/draft-07/schema\",\n      \"$id\": \"http://rekor.sigstore.dev/types/alpine/alpine_v0_0_1_schema.json\"\n    },\n    \"cose\": {\n      \"description\": \"COSE object\",\n      \"type\": \"object\",\n      \"allOf\": [\n        {\n          \"$ref\": \"#/definitions/ProposedEntry\"\n        },\n        {\n          \"required\": [\n            \"apiVersion\",\n            \"spec\"\n          ],\n          \"properties\": {\n            \"apiVersion\": {\n              \"type\": \"string\",\n              \"pattern\": \"^(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)(?:-((?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\\\.(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\\\+([0-9a-zA-Z-]+(?:\\\\.[0-9a-zA-Z-]+)*))?$\"\n            },\n            \"spec\": {\n              \"$ref\": \"#/definitions/coseSchema\"\n            }\n          },\n          \"additionalProperties\": false\n        }\n      ]\n    },\n    \"coseSchema\": {\n      \"description\": \"COSE for Rekord objects\",\n      \"type\": \"object\",\n      \"title\": \"COSE Schema\",\n      \"oneOf\": [\n        {\n          \"$ref\": \"#/definitions/coseV001Schema\"\n        }\n      ],\n      \"$schema\": \"http://json-schema.org/draft-07/schema\",\n      \"$id\": \"http://rekor.sigstore.dev/types/cose/cose_schema.json\"\n    },\n    \"coseV001Schema\": {\n      \"description\": \"Schema for cose object\",\n      \"type\": \"object\",\n      \"title\": \"cose v0.0.1 Schema\",\n      \"required\": [\n        \"publicKey\",\n        \"data\"\n      ],\n      \"properties\": {\n        \"data\": {\n          \"description\": \"Information about the content associated with the entry\",\n          \"type\": \"object\",\n          \"properties\": {\n            \"aad\": {\n              \"description\": \"Specifies the additional authenticated data required to verify the signature\",\n              \"type\": \"string\",\n              \"format\": \"byte\",\n              \"writeOnly\": true\n            },\n            \"envelopeHash\": {\n              \"description\": \"Specifies the hash algorithm and value for the COSE envelope\",\n              \"type\": \"object\",\n              \"required\": [\n                \"algorithm\",\n                \"value\"\n              ],\n              \"properties\": {\n                \"algorithm\": {\n                  \"description\": \"The hashing function used to compute the hash value\",\n                  \"type\": \"string\",\n                  \"enum\": [\n                    \"sha256\"\n                  ]\n                },\n                \"value\": {\n                  \"description\": \"The hash value for the envelope\",\n                  \"type\": \"string\"\n                }\n              },\n              \"readOnly\": true\n            },\n            \"payloadHash\": {\n              \"description\": \"Specifies the hash algorithm and value for the content\",\n              \"type\": \"object\",\n              \"required\": [\n                \"algorithm\",\n                \"value\"\n              ],\n              \"properties\": {\n                \"algorithm\": {\n                  \"description\": \"The hashing function used to compute the hash value\",\n                  \"type\": \"string\",\n                  \"enum\": [\n                    \"sha256\"\n                  ]\n                },\n                \"value\": {\n                  \"description\": \"The hash value for the content\",\n                  \"type\": \"string\"\n                }\n              },\n              \"readOnly\": true\n            }\n          }\n        },\n        \"message\": {\n          \"description\": \"The COSE Sign1 Message\",\n          \"type\": \"string\",\n          \"format\": \"byte\",\n          \"writeOnly\": true\n        },\n        \"publicKey\": {\n          \"description\": \"The public key that can verify the signature\",\n          \"type\": \"string\",\n          \"format\": \"byte\"\n        }\n      },\n      \"$schema\": \"http://json-schema.org/draft-07/schema\",\n      \"$id\": \"http://rekor.sigstore.dev/types/cose/cose_v0_0_1_schema.json\"\n    },\n    \"dsse\": {\n      \"description\": \"DSSE envelope\",\n      \"type\": \"object\",\n      \"allOf\": [\n        {\n          \"$ref\": \"#/definitions/ProposedEntry\"\n        },\n        {\n          \"required\": [\n            \"apiVersion\",\n            \"spec\"\n          ],\n          \"properties\": {\n            \"apiVersion\": {\n              \"type\": \"string\",\n              \"pattern\": \"^(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)(?:-((?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\\\.(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\\\+([0-9a-zA-Z-]+(?:\\\\.[0-9a-zA-Z-]+)*))?$\"\n            },\n            \"spec\": {\n              \"$ref\": \"#/definitions/dsseSchema\"\n            }\n          },\n          \"additionalProperties\": false\n        }\n      ]\n    },\n    \"dsseSchema\": {\n      \"description\": \"log entry schema for dsse envelopes\",\n      \"type\": \"object\",\n      \"title\": \"DSSE Schema\",\n      \"oneOf\": [\n        {\n          \"$ref\": \"#/definitions/dsseV001Schema\"\n        }\n      ],\n      \"$schema\": \"http://json-schema.org/draft-07/schema\",\n      \"$id\": \"http://rekor.sigstore.dev/types/dsse/dsse_schema.json\"\n    },\n    \"dsseV001Schema\": {\n      \"description\": \"Schema for DSSE envelopes\",\n      \"type\": \"object\",\n      \"title\": \"DSSE v0.0.1 Schema\",\n      \"oneOf\": [\n        {\n          \"required\": [\n            \"proposedContent\"\n          ]\n        },\n        {\n          \"required\": [\n            \"signatures\",\n            \"envelopeHash\",\n            \"payloadHash\"\n          ]\n        }\n      ],\n      \"properties\": {\n        \"envelopeHash\": {\n          \"description\": \"Specifies the hash algorithm and value encompassing the entire envelope sent to Rekor\",\n          \"type\": \"object\",\n          \"required\": [\n            \"algorithm\",\n            \"value\"\n          ],\n          \"properties\": {\n            \"algorithm\": {\n              \"description\": \"The hashing function used to compute the hash value\",\n              \"type\": \"string\",\n              \"enum\": [\n                \"sha256\"\n              ]\n            },\n            \"value\": {\n              \"description\": \"The value of the computed digest over the entire envelope\",\n              \"type\": \"string\"\n            }\n          },\n          \"readOnly\": true\n        },\n        \"payloadHash\": {\n          \"description\": \"Specifies the hash algorithm and value covering the payload within the DSSE envelope\",\n          \"type\": \"object\",\n          \"required\": [\n            \"algorithm\",\n            \"value\"\n          ],\n          \"properties\": {\n            \"algorithm\": {\n              \"description\": \"The hashing function used to compute the hash value\",\n              \"type\": \"string\",\n              \"enum\": [\n                \"sha256\"\n              ]\n            },\n            \"value\": {\n              \"description\": \"The value of the computed digest over the payload within the envelope\",\n              \"type\": \"string\"\n            }\n          },\n          \"readOnly\": true\n        },\n        \"proposedContent\": {\n          \"type\": \"object\",\n          \"required\": [\n            \"envelope\",\n            \"verifiers\"\n          ],\n          \"properties\": {\n            \"envelope\": {\n              \"description\": \"DSSE envelope specified as a stringified JSON object\",\n              \"type\": \"string\",\n              \"writeOnly\": true\n            },\n            \"verifiers\": {\n              \"description\": \"collection of all verification material (e.g. public keys or certificates) used to verify signatures over envelope's payload, specified as base64-encoded strings\",\n              \"type\": \"array\",\n              \"minItems\": 1,\n              \"items\": {\n                \"type\": \"string\",\n                \"format\": \"byte\"\n              },\n              \"writeOnly\": true\n            }\n          },\n          \"writeOnly\": true\n        },\n        \"signatures\": {\n          \"description\": \"extracted collection of all signatures of the envelope's payload; elements will be sorted by lexicographical order of the base64 encoded signature strings\",\n          \"type\": \"array\",\n          \"minItems\": 1,\n          \"items\": {\n            \"$ref\": \"#/definitions/DSSEV001SchemaSignaturesItems0\"\n          },\n          \"readOnly\": true\n        }\n      },\n      \"$schema\": \"http://json-schema.org/draft-07/schema\",\n      \"$id\": \"http://rekor.sigstore.dev/types/dsse/dsse_v0_0_1_schema.json\"\n    },\n    \"hashedrekord\": {\n      \"description\": \"Hashed Rekord object\",\n      \"type\": \"object\",\n      \"allOf\": [\n        {\n          \"$ref\": \"#/definitions/ProposedEntry\"\n        },\n        {\n          \"required\": [\n            \"apiVersion\",\n            \"spec\"\n          ],\n          \"properties\": {\n            \"apiVersion\": {\n              \"type\": \"string\",\n              \"pattern\": \"^(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)(?:-((?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\\\.(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\\\+([0-9a-zA-Z-]+(?:\\\\.[0-9a-zA-Z-]+)*))?$\"\n            },\n            \"spec\": {\n              \"$ref\": \"#/definitions/hashedrekordSchema\"\n            }\n          },\n          \"additionalProperties\": false\n        }\n      ]\n    },\n    \"hashedrekordSchema\": {\n      \"description\": \"Schema for Rekord objects\",\n      \"type\": \"object\",\n      \"title\": \"Rekor Schema\",\n      \"oneOf\": [\n        {\n          \"$ref\": \"#/definitions/hashedrekordV001Schema\"\n        }\n      ],\n      \"$schema\": \"http://json-schema.org/draft-07/schema\",\n      \"$id\": \"http://rekor.sigstore.dev/types/hashedrekord/hasehedrekord_schema.json\"\n    },\n    \"hashedrekordV001Schema\": {\n      \"description\": \"Schema for Hashed Rekord object\",\n      \"type\": \"object\",\n      \"title\": \"Hashed Rekor v0.0.1 Schema\",\n      \"required\": [\n        \"signature\",\n        \"data\"\n      ],\n      \"properties\": {\n        \"data\": {\n          \"description\": \"Information about the content associated with the entry\",\n          \"type\": \"object\",\n          \"properties\": {\n            \"hash\": {\n              \"description\": \"Specifies the hash algorithm and value for the content\",\n              \"type\": \"object\",\n              \"required\": [\n                \"algorithm\",\n                \"value\"\n              ],\n              \"properties\": {\n                \"algorithm\": {\n                  \"description\": \"The hashing function used to compute the hash value\",\n                  \"type\": \"string\",\n                  \"enum\": [\n                    \"sha256\"\n                  ]\n                },\n                \"value\": {\n                  \"description\": \"The hash value for the content\",\n                  \"type\": \"string\"\n                }\n              }\n            }\n          }\n        },\n        \"signature\": {\n          \"description\": \"Information about the detached signature associated with the entry\",\n          \"type\": \"object\",\n          \"properties\": {\n            \"content\": {\n              \"description\": \"Specifies the content of the signature inline within the document\",\n              \"type\": \"string\",\n              \"format\": \"byte\"\n            },\n            \"publicKey\": {\n              \"description\": \"The public key that can verify the signature; this can also be an X509 code signing certificate that contains the raw public key information\",\n              \"type\": \"object\",\n              \"properties\": {\n                \"content\": {\n                  \"description\": \"Specifies the content of the public key or code signing certificate inline within the document\",\n                  \"type\": \"string\",\n                  \"format\": \"byte\"\n                }\n              }\n            }\n          }\n        }\n      },\n      \"$schema\": \"http://json-schema.org/draft-07/schema\",\n      \"$id\": \"http://rekor.sigstore.dev/types/rekord/rekord_v0_0_1_schema.json\"\n    },\n    \"helm\": {\n      \"description\": \"Helm chart\",\n      \"type\": \"object\",\n      \"allOf\": [\n        {\n          \"$ref\": \"#/definitions/ProposedEntry\"\n        },\n        {\n          \"required\": [\n            \"apiVersion\",\n            \"spec\"\n          ],\n          \"properties\": {\n            \"apiVersion\": {\n              \"type\": \"string\",\n              \"pattern\": \"^(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)(?:-((?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\\\.(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\\\+([0-9a-zA-Z-]+(?:\\\\.[0-9a-zA-Z-]+)*))?$\"\n            },\n            \"spec\": {\n              \"$ref\": \"#/definitions/helmSchema\"\n            }\n          }\n        }\n      ]\n    },\n    \"helmSchema\": {\n      \"description\": \"Schema for Helm objects\",\n      \"type\": \"object\",\n      \"title\": \"Helm Schema\",\n      \"oneOf\": [\n        {\n          \"$ref\": \"#/definitions/helmV001Schema\"\n        }\n      ],\n      \"$schema\": \"http://json-schema.org/draft-07/schema\",\n      \"$id\": \"http://rekor.sigstore.dev/types/helm/helm_schema.json\"\n    },\n    \"helmV001Schema\": {\n      \"description\": \"Schema for Helm object\",\n      \"type\": \"object\",\n      \"title\": \"Helm v0.0.1 Schema\",\n      \"required\": [\n        \"publicKey\",\n        \"chart\"\n      ],\n      \"properties\": {\n        \"chart\": {\n          \"description\": \"Information about the Helm chart associated with the entry\",\n          \"type\": \"object\",\n          \"required\": [\n            \"provenance\"\n          ],\n          \"properties\": {\n            \"hash\": {\n              \"description\": \"Specifies the hash algorithm and value for the chart\",\n              \"type\": \"object\",\n              \"required\": [\n                \"algorithm\",\n                \"value\"\n              ],\n              \"properties\": {\n                \"algorithm\": {\n                  \"description\": \"The hashing function used to compute the hash value\",\n                  \"type\": \"string\",\n                  \"enum\": [\n                    \"sha256\"\n                  ]\n                },\n                \"value\": {\n                  \"description\": \"The hash value for the chart\",\n                  \"type\": \"string\"\n                }\n              },\n              \"readOnly\": true\n            },\n            \"provenance\": {\n              \"description\": \"The provenance entry associated with the signed Helm Chart\",\n              \"type\": \"object\",\n              \"oneOf\": [\n                {\n                  \"required\": [\n                    \"signature\"\n                  ]\n                },\n                {\n                  \"required\": [\n                    \"content\"\n                  ]\n                }\n              ],\n              \"properties\": {\n                \"content\": {\n                  \"description\": \"Specifies the content of the provenance file inline within the document\",\n                  \"type\": \"string\",\n                  \"format\": \"byte\",\n                  \"writeOnly\": true\n                },\n                \"signature\": {\n                  \"description\": \"Information about the included signature in the provenance file\",\n                  \"type\": \"object\",\n                  \"required\": [\n                    \"content\"\n                  ],\n                  \"properties\": {\n                    \"content\": {\n                      \"description\": \"Specifies the signature embedded within the provenance file \",\n                      \"type\": \"string\",\n                      \"format\": \"byte\",\n                      \"readOnly\": true\n                    }\n                  },\n                  \"readOnly\": true\n                }\n              }\n            }\n          }\n        },\n        \"publicKey\": {\n          \"description\": \"The public key that can verify the package signature\",\n          \"type\": \"object\",\n          \"required\": [\n            \"content\"\n          ],\n          \"properties\": {\n            \"content\": {\n              \"description\": \"Specifies the content of the public key inline within the document\",\n              \"type\": \"string\",\n              \"format\": \"byte\"\n            }\n          }\n        }\n      },\n      \"$schema\": \"http://json-schema.org/draft-07/schema\",\n      \"$id\": \"http://rekor.sigstore.dev/types/helm/helm_v0_0_1_schema.json\"\n    },\n    \"intoto\": {\n      \"description\": \"Intoto object\",\n      \"type\": \"object\",\n      \"allOf\": [\n        {\n          \"$ref\": \"#/definitions/ProposedEntry\"\n        },\n        {\n          \"required\": [\n            \"apiVersion\",\n            \"spec\"\n          ],\n          \"properties\": {\n            \"apiVersion\": {\n              \"type\": \"string\",\n              \"pattern\": \"^(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)(?:-((?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\\\.(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\\\+([0-9a-zA-Z-]+(?:\\\\.[0-9a-zA-Z-]+)*))?$\"\n            },\n            \"spec\": {\n              \"$ref\": \"#/definitions/intotoSchema\"\n            }\n          },\n          \"additionalProperties\": false\n        }\n      ]\n    },\n    \"intotoSchema\": {\n      \"description\": \"Intoto for Rekord objects\",\n      \"type\": \"object\",\n      \"title\": \"Intoto Schema\",\n      \"oneOf\": [\n        {\n          \"$ref\": \"#/definitions/intotoV001Schema\"\n        },\n        {\n          \"$ref\": \"#/definitions/intotoV002Schema\"\n        }\n      ],\n      \"$schema\": \"http://json-schema.org/draft-07/schema\",\n      \"$id\": \"http://rekor.sigstore.dev/types/intoto/intoto_schema.json\"\n    },\n    \"intotoV001Schema\": {\n      \"description\": \"Schema for intoto object\",\n      \"type\": \"object\",\n      \"title\": \"intoto v0.0.1 Schema\",\n      \"required\": [\n        \"publicKey\",\n        \"content\"\n      ],\n      \"properties\": {\n        \"content\": {\n          \"type\": \"object\",\n          \"properties\": {\n            \"envelope\": {\n              \"description\": \"envelope\",\n              \"type\": \"string\",\n              \"writeOnly\": true\n            },\n            \"hash\": {\n              \"description\": \"Specifies the hash algorithm and value encompassing the entire signed envelope; this is computed by the rekor server, client-provided values are ignored\",\n              \"type\": \"object\",\n              \"required\": [\n                \"algorithm\",\n                \"value\"\n              ],\n              \"properties\": {\n                \"algorithm\": {\n                  \"description\": \"The hashing function used to compute the hash value\",\n                  \"type\": \"string\",\n                  \"enum\": [\n                    \"sha256\"\n                  ]\n                },\n                \"value\": {\n                  \"description\": \"The hash value for the archive\",\n                  \"type\": \"string\"\n                }\n              },\n              \"readOnly\": true\n            },\n            \"payloadHash\": {\n              \"description\": \"Specifies the hash algorithm and value covering the payload within the DSSE envelope; this is computed by the rekor server, client-provided values are ignored\",\n              \"type\": \"object\",\n              \"required\": [\n                \"algorithm\",\n                \"value\"\n              ],\n              \"properties\": {\n                \"algorithm\": {\n                  \"description\": \"The hashing function used to compute the hash value\",\n                  \"type\": \"string\",\n                  \"enum\": [\n                    \"sha256\"\n                  ]\n                },\n                \"value\": {\n                  \"description\": \"The hash value for the envelope's payload\",\n                  \"type\": \"string\"\n                }\n              },\n              \"readOnly\": true\n            }\n          }\n        },\n        \"publicKey\": {\n          \"description\": \"The public key that can verify the signature\",\n          \"type\": \"string\",\n          \"format\": \"byte\"\n        }\n      },\n      \"$schema\": \"http://json-schema.org/draft-07/schema\",\n      \"$id\": \"http://rekor.sigstore.dev/types/intoto/intoto_v0_0_1_schema.json\"\n    },\n    \"intotoV002Schema\": {\n      \"description\": \"Schema for intoto object\",\n      \"type\": \"object\",\n      \"title\": \"intoto v0.0.2 Schema\",\n      \"required\": [\n        \"content\"\n      ],\n      \"properties\": {\n        \"content\": {\n          \"type\": \"object\",\n          \"required\": [\n            \"envelope\"\n          ],\n          \"properties\": {\n            \"envelope\": {\n              \"description\": \"dsse envelope\",\n              \"type\": \"object\",\n              \"required\": [\n                \"payloadType\",\n                \"signatures\"\n              ],\n              \"properties\": {\n                \"payload\": {\n                  \"description\": \"payload of the envelope\",\n                  \"type\": \"string\",\n                  \"format\": \"byte\",\n                  \"writeOnly\": true\n                },\n                \"payloadType\": {\n                  \"description\": \"type describing the payload\",\n                  \"type\": \"string\"\n                },\n                \"signatures\": {\n                  \"description\": \"collection of all signatures of the envelope's payload\",\n                  \"type\": \"array\",\n                  \"minItems\": 1,\n                  \"items\": {\n                    \"$ref\": \"#/definitions/IntotoV002SchemaContentEnvelopeSignaturesItems0\"\n                  }\n                }\n              }\n            },\n            \"hash\": {\n              \"description\": \"Specifies the hash algorithm and value encompassing the entire signed envelope\",\n              \"type\": \"object\",\n              \"required\": [\n                \"algorithm\",\n                \"value\"\n              ],\n              \"properties\": {\n                \"algorithm\": {\n                  \"description\": \"The hashing function used to compute the hash value\",\n                  \"type\": \"string\",\n                  \"enum\": [\n                    \"sha256\"\n                  ]\n                },\n                \"value\": {\n                  \"description\": \"The hash value for the archive\",\n                  \"type\": \"string\"\n                }\n              },\n              \"readOnly\": true\n            },\n            \"payloadHash\": {\n              \"description\": \"Specifies the hash algorithm and value covering the payload within the DSSE envelope\",\n              \"type\": \"object\",\n              \"required\": [\n                \"algorithm\",\n                \"value\"\n              ],\n              \"properties\": {\n                \"algorithm\": {\n                  \"description\": \"The hashing function used to compute the hash value\",\n                  \"type\": \"string\",\n                  \"enum\": [\n                    \"sha256\"\n                  ]\n                },\n                \"value\": {\n                  \"description\": \"The hash value of the payload\",\n                  \"type\": \"string\"\n                }\n              },\n              \"readOnly\": true\n            }\n          }\n        }\n      },\n      \"$schema\": \"http://json-schema.org/draft-07/schema\",\n      \"$id\": \"http://rekor.sigstore.dev/types/intoto/intoto_v0_0_2_schema.json\"\n    },\n    \"jar\": {\n      \"description\": \"Java Archive (JAR)\",\n      \"type\": \"object\",\n      \"allOf\": [\n        {\n          \"$ref\": \"#/definitions/ProposedEntry\"\n        },\n        {\n          \"required\": [\n            \"apiVersion\",\n            \"spec\"\n          ],\n          \"properties\": {\n            \"apiVersion\": {\n              \"type\": \"string\",\n              \"pattern\": \"^(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)(?:-((?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\\\.(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\\\+([0-9a-zA-Z-]+(?:\\\\.[0-9a-zA-Z-]+)*))?$\"\n            },\n            \"spec\": {\n              \"$ref\": \"#/definitions/jarSchema\"\n            }\n          },\n          \"additionalProperties\": false\n        }\n      ]\n    },\n    \"jarSchema\": {\n      \"description\": \"Schema for JAR objects\",\n      \"type\": \"object\",\n      \"title\": \"JAR Schema\",\n      \"oneOf\": [\n        {\n          \"$ref\": \"#/definitions/jarV001Schema\"\n        }\n      ],\n      \"$schema\": \"http://json-schema.org/draft-07/schema\",\n      \"$id\": \"http://rekor.sigstore.dev/types/jar/jar_schema.json\"\n    },\n    \"jarV001Schema\": {\n      \"description\": \"Schema for JAR entries\",\n      \"type\": \"object\",\n      \"title\": \"JAR v0.0.1 Schema\",\n      \"required\": [\n        \"archive\"\n      ],\n      \"properties\": {\n        \"archive\": {\n          \"description\": \"Information about the archive associated with the entry\",\n          \"type\": \"object\",\n          \"oneOf\": [\n            {\n              \"required\": [\n                \"hash\"\n              ]\n            },\n            {\n              \"required\": [\n                \"content\"\n              ]\n            }\n          ],\n          \"properties\": {\n            \"content\": {\n              \"description\": \"Specifies the archive inline within the document\",\n              \"type\": \"string\",\n              \"format\": \"byte\",\n              \"writeOnly\": true\n            },\n            \"hash\": {\n              \"description\": \"Specifies the hash algorithm and value encompassing the entire signed archive\",\n              \"type\": \"object\",\n              \"required\": [\n                \"algorithm\",\n                \"value\"\n              ],\n              \"properties\": {\n                \"algorithm\": {\n                  \"description\": \"The hashing function used to compute the hash value\",\n                  \"type\": \"string\",\n                  \"enum\": [\n                    \"sha256\"\n                  ]\n                },\n                \"value\": {\n                  \"description\": \"The hash value for the archive\",\n                  \"type\": \"string\"\n                }\n              }\n            }\n          }\n        },\n        \"signature\": {\n          \"description\": \"Information about the included signature in the JAR file\",\n          \"type\": \"object\",\n          \"required\": [\n            \"publicKey\",\n            \"content\"\n          ],\n          \"properties\": {\n            \"content\": {\n              \"description\": \"Specifies the PKCS7 signature embedded within the JAR file \",\n              \"type\": \"string\",\n              \"format\": \"byte\",\n              \"readOnly\": true\n            },\n            \"publicKey\": {\n              \"description\": \"The X509 certificate containing the public key JAR which verifies the signature of the JAR\",\n              \"type\": \"object\",\n              \"required\": [\n                \"content\"\n              ],\n              \"properties\": {\n                \"content\": {\n                  \"description\": \"Specifies the content of the X509 certificate containing the public key used to verify the signature\",\n                  \"type\": \"string\",\n                  \"format\": \"byte\"\n                }\n              },\n              \"readOnly\": true\n            }\n          }\n        }\n      },\n      \"$schema\": \"http://json-schema.org/draft-07/schema\",\n      \"$id\": \"http://rekor.sigstore.dev/types/jar/jar_v0_0_1_schema.json\"\n    },\n    \"rekord\": {\n      \"description\": \"Rekord object\",\n      \"type\": \"object\",\n      \"allOf\": [\n        {\n          \"$ref\": \"#/definitions/ProposedEntry\"\n        },\n        {\n          \"required\": [\n            \"apiVersion\",\n            \"spec\"\n          ],\n          \"properties\": {\n            \"apiVersion\": {\n              \"type\": \"string\",\n              \"pattern\": \"^(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)(?:-((?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\\\.(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\\\+([0-9a-zA-Z-]+(?:\\\\.[0-9a-zA-Z-]+)*))?$\"\n            },\n            \"spec\": {\n              \"$ref\": \"#/definitions/rekordSchema\"\n            }\n          },\n          \"additionalProperties\": false\n        }\n      ]\n    },\n    \"rekordSchema\": {\n      \"description\": \"Schema for Rekord objects\",\n      \"type\": \"object\",\n      \"title\": \"Rekor Schema\",\n      \"oneOf\": [\n        {\n          \"$ref\": \"#/definitions/rekordV001Schema\"\n        }\n      ],\n      \"$schema\": \"http://json-schema.org/draft-07/schema\",\n      \"$id\": \"http://rekor.sigstore.dev/types/rekord/rekord_schema.json\"\n    },\n    \"rekordV001Schema\": {\n      \"description\": \"Schema for Rekord object\",\n      \"type\": \"object\",\n      \"title\": \"Rekor v0.0.1 Schema\",\n      \"required\": [\n        \"signature\",\n        \"data\"\n      ],\n      \"properties\": {\n        \"data\": {\n          \"description\": \"Information about the content associated with the entry\",\n          \"type\": \"object\",\n          \"oneOf\": [\n            {\n              \"required\": [\n                \"hash\"\n              ]\n            },\n            {\n              \"required\": [\n                \"content\"\n              ]\n            }\n          ],\n          \"properties\": {\n            \"content\": {\n              \"description\": \"Specifies the content inline within the document\",\n              \"type\": \"string\",\n              \"format\": \"byte\",\n              \"writeOnly\": true\n            },\n            \"hash\": {\n              \"description\": \"Specifies the hash algorithm and value for the content\",\n              \"type\": \"object\",\n              \"required\": [\n                \"algorithm\",\n                \"value\"\n              ],\n              \"properties\": {\n                \"algorithm\": {\n                  \"description\": \"The hashing function used to compute the hash value\",\n                  \"type\": \"string\",\n                  \"enum\": [\n                    \"sha256\"\n                  ]\n                },\n                \"value\": {\n                  \"description\": \"The hash value for the content\",\n                  \"type\": \"string\"\n                }\n              },\n              \"readOnly\": true\n            }\n          }\n        },\n        \"signature\": {\n          \"description\": \"Information about the detached signature associated with the entry\",\n          \"type\": \"object\",\n          \"required\": [\n            \"format\",\n            \"publicKey\",\n            \"content\"\n          ],\n          \"properties\": {\n            \"content\": {\n              \"description\": \"Specifies the content of the signature inline within the document\",\n              \"type\": \"string\",\n              \"format\": \"byte\"\n            },\n            \"format\": {\n              \"description\": \"Specifies the format of the signature\",\n              \"type\": \"string\",\n              \"enum\": [\n                \"pgp\",\n                \"minisign\",\n                \"x509\",\n                \"ssh\"\n              ]\n            },\n            \"publicKey\": {\n              \"description\": \"The public key that can verify the signature\",\n              \"type\": \"object\",\n              \"required\": [\n                \"content\"\n              ],\n              \"properties\": {\n                \"content\": {\n                  \"description\": \"Specifies the content of the public key inline within the document\",\n                  \"type\": \"string\",\n                  \"format\": \"byte\"\n                }\n              }\n            }\n          }\n        }\n      },\n      \"$schema\": \"http://json-schema.org/draft-07/schema\",\n      \"$id\": \"http://rekor.sigstore.dev/types/rekord/rekord_v0_0_1_schema.json\"\n    },\n    \"rfc3161\": {\n      \"description\": \"RFC3161 Timestamp\",\n      \"type\": \"object\",\n      \"allOf\": [\n        {\n          \"$ref\": \"#/definitions/ProposedEntry\"\n        },\n        {\n          \"required\": [\n            \"apiVersion\",\n            \"spec\"\n          ],\n          \"properties\": {\n            \"apiVersion\": {\n              \"type\": \"string\",\n              \"pattern\": \"^(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)(?:-((?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\\\.(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\\\+([0-9a-zA-Z-]+(?:\\\\.[0-9a-zA-Z-]+)*))?$\"\n            },\n            \"spec\": {\n              \"$ref\": \"#/definitions/rfc3161Schema\"\n            }\n          },\n          \"additionalProperties\": false\n        }\n      ]\n    },\n    \"rfc3161Schema\": {\n      \"description\": \"Schema for RFC 3161 timestamp objects\",\n      \"type\": \"object\",\n      \"title\": \"Timestamp Schema\",\n      \"oneOf\": [\n        {\n          \"$ref\": \"#/definitions/rfc3161V001Schema\"\n        }\n      ],\n      \"$schema\": \"http://json-schema.org/draft-07/schema\",\n      \"$id\": \"http://rekor.sigstore.dev/types/rfc3161/rfc3161_schema.json\"\n    },\n    \"rfc3161V001Schema\": {\n      \"description\": \"Schema for RFC3161 entries\",\n      \"type\": \"object\",\n      \"title\": \"Timestamp v0.0.1 Schema\",\n      \"required\": [\n        \"tsr\"\n      ],\n      \"properties\": {\n        \"tsr\": {\n          \"description\": \"Information about the tsr file associated with the entry\",\n          \"type\": \"object\",\n          \"required\": [\n            \"content\"\n          ],\n          \"properties\": {\n            \"content\": {\n              \"description\": \"Specifies the tsr file content inline within the document\",\n              \"type\": \"string\",\n              \"format\": \"byte\"\n            }\n          }\n        }\n      },\n      \"$schema\": \"http://json-schema.org/draft-07/schema\",\n      \"$id\": \"http://rekor.sigstore.dev/types/timestamp/timestamp_v0_0_1_schema.json\"\n    },\n    \"rpm\": {\n      \"description\": \"RPM package\",\n      \"type\": \"object\",\n      \"allOf\": [\n        {\n          \"$ref\": \"#/definitions/ProposedEntry\"\n        },\n        {\n          \"required\": [\n            \"apiVersion\",\n            \"spec\"\n          ],\n          \"properties\": {\n            \"apiVersion\": {\n              \"type\": \"string\",\n              \"pattern\": \"^(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)(?:-((?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\\\.(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\\\+([0-9a-zA-Z-]+(?:\\\\.[0-9a-zA-Z-]+)*))?$\"\n            },\n            \"spec\": {\n              \"$ref\": \"#/definitions/rpmSchema\"\n            }\n          },\n          \"additionalProperties\": false\n        }\n      ]\n    },\n    \"rpmSchema\": {\n      \"description\": \"Schema for RPM objects\",\n      \"type\": \"object\",\n      \"title\": \"RPM Schema\",\n      \"oneOf\": [\n        {\n          \"$ref\": \"#/definitions/rpmV001Schema\"\n        }\n      ],\n      \"$schema\": \"http://json-schema.org/draft-07/schema\",\n      \"$id\": \"http://rekor.sigstore.dev/types/rpm/rpm_schema.json\"\n    },\n    \"rpmV001Schema\": {\n      \"description\": \"Schema for RPM entries\",\n      \"type\": \"object\",\n      \"title\": \"RPM v0.0.1 Schema\",\n      \"required\": [\n        \"publicKey\",\n        \"package\"\n      ],\n      \"properties\": {\n        \"package\": {\n          \"description\": \"Information about the package associated with the entry\",\n          \"type\": \"object\",\n          \"oneOf\": [\n            {\n              \"required\": [\n                \"hash\"\n              ]\n            },\n            {\n              \"required\": [\n                \"content\"\n              ]\n            }\n          ],\n          \"properties\": {\n            \"content\": {\n              \"description\": \"Specifies the package inline within the document\",\n              \"type\": \"string\",\n              \"format\": \"byte\",\n              \"writeOnly\": true\n            },\n            \"hash\": {\n              \"description\": \"Specifies the hash algorithm and value for the package\",\n              \"type\": \"object\",\n              \"required\": [\n                \"algorithm\",\n                \"value\"\n              ],\n              \"properties\": {\n                \"algorithm\": {\n                  \"description\": \"The hashing function used to compute the hash value\",\n                  \"type\": \"string\",\n                  \"enum\": [\n                    \"sha256\"\n                  ]\n                },\n                \"value\": {\n                  \"description\": \"The hash value for the package\",\n                  \"type\": \"string\"\n                }\n              }\n            },\n            \"headers\": {\n              \"description\": \"Values of the RPM headers\",\n              \"type\": \"object\",\n              \"additionalProperties\": {\n                \"type\": \"string\"\n              },\n              \"readOnly\": true\n            }\n          }\n        },\n        \"publicKey\": {\n          \"description\": \"The PGP public key that can verify the RPM signature\",\n          \"type\": \"object\",\n          \"required\": [\n            \"content\"\n          ],\n          \"properties\": {\n            \"content\": {\n              \"description\": \"Specifies the content of the public key inline within the document\",\n              \"type\": \"string\",\n              \"format\": \"byte\"\n            }\n          }\n        }\n      },\n      \"$schema\": \"http://json-schema.org/draft-07/schema\",\n      \"$id\": \"http://rekor.sigstore.dev/types/rpm/rpm_v0_0_1_schema.json\"\n    },\n    \"tuf\": {\n      \"description\": \"TUF metadata\",\n      \"type\": \"object\",\n      \"allOf\": [\n        {\n          \"$ref\": \"#/definitions/ProposedEntry\"\n        },\n        {\n          \"required\": [\n            \"apiVersion\",\n            \"spec\"\n          ],\n          \"properties\": {\n            \"apiVersion\": {\n              \"type\": \"string\",\n              \"pattern\": \"^(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)(?:-((?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\\\.(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\\\+([0-9a-zA-Z-]+(?:\\\\.[0-9a-zA-Z-]+)*))?$\"\n            },\n            \"spec\": {\n              \"$ref\": \"#/definitions/tufSchema\"\n            }\n          },\n          \"additionalProperties\": false\n        }\n      ]\n    },\n    \"tufSchema\": {\n      \"description\": \"Schema for TUF metadata objects\",\n      \"type\": \"object\",\n      \"title\": \"TUF Schema\",\n      \"oneOf\": [\n        {\n          \"$ref\": \"#/definitions/tufV001Schema\"\n        }\n      ],\n      \"$schema\": \"http://json-schema.org/draft-07/schema\",\n      \"$id\": \"http://rekor.sigstore.dev/types/tuf/tuf_schema.json\"\n    },\n    \"tufV001Schema\": {\n      \"description\": \"Schema for TUF metadata entries\",\n      \"type\": \"object\",\n      \"title\": \"TUF v0.0.1 Schema\",\n      \"required\": [\n        \"metadata\",\n        \"root\"\n      ],\n      \"properties\": {\n        \"metadata\": {\n          \"description\": \"TUF metadata\",\n          \"type\": \"object\",\n          \"required\": [\n            \"content\"\n          ],\n          \"properties\": {\n            \"content\": {\n              \"description\": \"Specifies the metadata inline within the document\",\n              \"type\": \"object\",\n              \"additionalProperties\": true\n            }\n          }\n        },\n        \"root\": {\n          \"description\": \"root metadata containing about the public keys used to sign the manifest\",\n          \"type\": \"object\",\n          \"required\": [\n            \"content\"\n          ],\n          \"properties\": {\n            \"content\": {\n              \"description\": \"Specifies the metadata inline within the document\",\n              \"type\": \"object\",\n              \"additionalProperties\": true\n            }\n          }\n        },\n        \"spec_version\": {\n          \"description\": \"TUF specification version\",\n          \"type\": \"string\",\n          \"readOnly\": true\n        }\n      },\n      \"$schema\": \"http://json-schema.org/draft-07/schema\",\n      \"$id\": \"http://rekor.sigstore.dev/types/tuf/tuf_v0_0_1_schema.json\"\n    }\n  },\n  \"responses\": {\n    \"BadContent\": {\n      \"description\": \"The content supplied to the server was invalid\",\n      \"schema\": {\n        \"$ref\": \"#/definitions/Error\"\n      }\n    },\n    \"Conflict\": {\n      \"description\": \"The request conflicts with the current state of the transparency log\",\n      \"schema\": {\n        \"$ref\": \"#/definitions/Error\"\n      },\n      \"headers\": {\n        \"Location\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        }\n      }\n    },\n    \"InternalServerError\": {\n      \"description\": \"There was an internal error in the server while processing the request\",\n      \"schema\": {\n        \"$ref\": \"#/definitions/Error\"\n      }\n    },\n    \"NotFound\": {\n      \"description\": \"The content requested could not be found\"\n    },\n    \"UnprocessableEntity\": {\n      \"description\": \"The server understood the request but is unable to process the contained instructions\",\n      \"schema\": {\n        \"$ref\": \"#/definitions/Error\"\n      }\n    }\n  }\n}`))\n}\n", "//\n// Copyright 2023 The Sigstore Authors.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage dsse\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"crypto\"\n\t\"crypto/sha256\"\n\t\"encoding/hex\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"sort\"\n\t\"strings\"\n\n\t\"github.com/in-toto/in-toto-golang/in_toto\"\n\t\"github.com/secure-systems-lab/go-securesystemslib/dsse\"\n\n\t\"github.com/go-openapi/strfmt\"\n\t\"github.com/go-openapi/swag\"\n\n\t\"github.com/sigstore/rekor/pkg/generated/models\"\n\t\"github.com/sigstore/rekor/pkg/log\"\n\t\"github.com/sigstore/rekor/pkg/pki\"\n\t\"github.com/sigstore/rekor/pkg/pki/x509\"\n\t\"github.com/sigstore/rekor/pkg/types\"\n\tdsseType \"github.com/sigstore/rekor/pkg/types/dsse\"\n\t\"github.com/sigstore/sigstore/pkg/signature\"\n\tsigdsse \"github.com/sigstore/sigstore/pkg/signature/dsse\"\n)\n\nconst (\n\tAPIVERSION = \"0.0.1\"\n)\n\nfunc init() {\n\tif err := dsseType.VersionMap.SetEntryFactory(APIVERSION, NewEntry); err != nil {\n\t\tlog.Logger.Panic(err)\n\t}\n}\n\ntype V001Entry struct {\n\tDSSEObj models.DSSEV001Schema\n\tenv     *dsse.Envelope\n}\n\nfunc (v V001Entry) APIVersion() string {\n\treturn APIVERSION\n}\n\nfunc NewEntry() types.EntryImpl {\n\treturn &V001Entry{}\n}\n\n// IndexKeys computes the list of keys that should map back to this entry.\n// It should *never* reference v.DSSEObj.ProposedContent as those values would only\n// be present at the time of insertion\nfunc (v V001Entry) IndexKeys() ([]string, error) {\n\tvar result []string\n\n\tfor _, sig := range v.DSSEObj.Signatures {\n\t\tkeyObj, err := x509.NewPublicKey(bytes.NewReader(*sig.Verifier))\n\t\tif err != nil {\n\t\t\treturn result, err\n\t\t}\n\n\t\tcanonKey, err := keyObj.CanonicalValue()\n\t\tif err != nil {\n\t\t\treturn result, fmt.Errorf(\"could not canonicalize key: %w\", err)\n\t\t}\n\n\t\tkeyHash := sha256.Sum256(canonKey)\n\t\tresult = append(result, \"sha256:\"+hex.EncodeToString(keyHash[:]))\n\n\t\tresult = append(result, keyObj.Subjects()...)\n\t}\n\n\tif v.DSSEObj.PayloadHash != nil {\n\t\tpayloadHashKey := strings.ToLower(fmt.Sprintf(\"%s:%s\", *v.DSSEObj.PayloadHash.Algorithm, *v.DSSEObj.PayloadHash.Value))\n\t\tresult = append(result, payloadHashKey)\n\t}\n\n\tif v.DSSEObj.EnvelopeHash != nil {\n\t\tenvelopeHashKey := strings.ToLower(fmt.Sprintf(\"%s:%s\", *v.DSSEObj.EnvelopeHash.Algorithm, *v.DSSEObj.EnvelopeHash.Value))\n\t\tresult = append(result, envelopeHashKey)\n\t}\n\n\tif v.env == nil {\n\t\tlog.Logger.Info(\"DSSEObj content or DSSE envelope is nil, returning partial set of keys\")\n\t\treturn result, nil\n\t}\n\n\tswitch v.env.PayloadType {\n\tcase in_toto.PayloadType:\n\n\t\tif v.env.Payload == \"\" {\n\t\t\tlog.Logger.Info(\"DSSEObj DSSE payload is empty\")\n\t\t\treturn result, nil\n\t\t}\n\t\tdecodedPayload, err := v.env.DecodeB64Payload()\n\t\tif err != nil {\n\t\t\treturn result, fmt.Errorf(\"could not decode envelope payload: %w\", err)\n\t\t}\n\t\tstatement, err := parseStatement(decodedPayload)\n\t\tif err != nil {\n\t\t\treturn result, err\n\t\t}\n\t\tfor _, s := range statement.Subject {\n\t\t\tfor alg, ds := range s.Digest {\n\t\t\t\tresult = append(result, alg+\":\"+ds)\n\t\t\t}\n\t\t}\n\t\t// Not all in-toto statements will contain a SLSA provenance predicate.\n\t\t// See https://github.com/in-toto/attestation/blob/main/spec/README.md#predicate\n\t\t// for other predicates.\n\t\tif predicate, err := parseSlsaPredicate(decodedPayload); err == nil {\n\t\t\tif predicate.Predicate.Materials != nil {\n\t\t\t\tfor _, s := range predicate.Predicate.Materials {\n\t\t\t\t\tfor alg, ds := range s.Digest {\n\t\t\t\t\t\tresult = append(result, alg+\":\"+ds)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tdefault:\n\t\tlog.Logger.Infof(\"Unknown DSSE envelope payloadType: %s\", v.env.PayloadType)\n\t}\n\treturn result, nil\n}\n\nfunc parseStatement(p []byte) (*in_toto.Statement, error) {\n\tps := in_toto.Statement{}\n\tif err := json.Unmarshal(p, &ps); err != nil {\n\t\treturn nil, err\n\t}\n\treturn &ps, nil\n}\n\nfunc parseSlsaPredicate(p []byte) (*in_toto.ProvenanceStatement, error) {\n\tpredicate := in_toto.ProvenanceStatement{}\n\tif err := json.Unmarshal(p, &predicate); err != nil {\n\t\treturn nil, err\n\t}\n\treturn &predicate, nil\n}\n\nfunc (v *V001Entry) Unmarshal(pe models.ProposedEntry) error {\n\tit, ok := pe.(*models.DSSE)\n\tif !ok {\n\t\treturn errors.New(\"cannot unmarshal non DSSE v0.0.1 type\")\n\t}\n\n\tdsseObj := &models.DSSEV001Schema{}\n\n\tif err := types.DecodeEntry(it.Spec, dsseObj); err != nil {\n\t\treturn err\n\t}\n\n\t// field validation\n\tif err := dsseObj.Validate(strfmt.Default); err != nil {\n\t\treturn err\n\t}\n\n\t// either we have just proposed content or the canonicalized fields\n\tif dsseObj.ProposedContent == nil {\n\t\t// then we need canonicalized fields, and all must be present (if present, they would have been validated in the above call to Validate())\n\t\tif dsseObj.EnvelopeHash == nil || dsseObj.PayloadHash == nil || len(dsseObj.Signatures) == 0 {\n\t\t\treturn errors.New(\"either proposedContent or envelopeHash, payloadHash, and signatures must be present\")\n\t\t}\n\t\tv.DSSEObj = *dsseObj\n\t\treturn nil\n\t}\n\t// if we're here, then we're trying to propose a new entry so we check to ensure client's aren't setting server-side computed fields\n\tif dsseObj.EnvelopeHash != nil || dsseObj.PayloadHash != nil || len(dsseObj.Signatures) != 0 {\n\t\treturn errors.New(\"either proposedContent or envelopeHash, payloadHash, and signatures must be present but not both\")\n\t}\n\n\tenv := &dsse.Envelope{}\n\tif err := json.Unmarshal([]byte(*dsseObj.ProposedContent.Envelope), env); err != nil {\n\t\treturn err\n\t}\n\n\tif len(env.Signatures) == 0 {\n\t\treturn errors.New(\"DSSE envelope must contain 1 or more signatures\")\n\t}\n\n\tallPubKeyBytes := make([][]byte, 0)\n\tfor _, publicKey := range dsseObj.ProposedContent.Verifiers {\n\t\tallPubKeyBytes = append(allPubKeyBytes, publicKey)\n\t}\n\n\tsigToKeyMap, err := verifyEnvelope(allPubKeyBytes, env)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// we need to ensure we canonicalize the ordering of signatures\n\tsortedSigs := make([]string, 0, len(sigToKeyMap))\n\tfor sig := range sigToKeyMap {\n\t\tsortedSigs = append(sortedSigs, sig)\n\t}\n\tsort.Strings(sortedSigs)\n\n\tfor i, sig := range sortedSigs {\n\t\tkey := sigToKeyMap[sig]\n\t\tcanonicalizedKey, err := key.CanonicalValue()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tb64CanonicalizedKey := strfmt.Base64(canonicalizedKey)\n\n\t\tdsseObj.Signatures = append(dsseObj.Signatures, &models.DSSEV001SchemaSignaturesItems0{\n\t\t\tSignature: &sortedSigs[i],\n\t\t\tVerifier:  &b64CanonicalizedKey,\n\t\t})\n\t}\n\n\tdecodedPayload, err := env.DecodeB64Payload()\n\tif err != nil {\n\t\t// this shouldn't happen because failure would have occurred in verifyEnvelope call above\n\t\treturn err\n\t}\n\n\tpayloadHash := sha256.Sum256(decodedPayload)\n\tdsseObj.PayloadHash = &models.DSSEV001SchemaPayloadHash{\n\t\tAlgorithm: swag.String(models.DSSEV001SchemaPayloadHashAlgorithmSha256),\n\t\tValue:     swag.String(hex.EncodeToString(payloadHash[:])),\n\t}\n\n\tenvelopeHash := sha256.Sum256([]byte(*dsseObj.ProposedContent.Envelope))\n\tdsseObj.EnvelopeHash = &models.DSSEV001SchemaEnvelopeHash{\n\t\tAlgorithm: swag.String(models.DSSEV001SchemaEnvelopeHashAlgorithmSha256),\n\t\tValue:     swag.String(hex.EncodeToString(envelopeHash[:])),\n\t}\n\n\t// we've gotten through all processing without error, now update the object we're unmarshalling into\n\tv.DSSEObj = *dsseObj\n\tv.env = env\n\n\treturn nil\n}\n\n// Canonicalize returns a JSON representation of the entry to be persisted into the log. This\n// will be further canonicalized by JSON Canonicalization Scheme (JCS) before being written.\n//\n// This function should not use v.DSSEObj.ProposedContent fields as they are client provided and\n// should not be trusted; the other fields at the top level are only set server side.\nfunc (v *V001Entry) Canonicalize(_ context.Context) ([]byte, error) {\n\tcanonicalEntry := models.DSSEV001Schema{\n\t\tSignatures:      v.DSSEObj.Signatures,\n\t\tEnvelopeHash:    v.DSSEObj.EnvelopeHash,\n\t\tPayloadHash:     v.DSSEObj.PayloadHash,\n\t\tProposedContent: nil, // this is explicitly done as we don't want to canonicalize the envelope\n\t}\n\n\tsort.Slice(canonicalEntry.Signatures, func(i, j int) bool {\n\t\treturn *canonicalEntry.Signatures[i].Signature < *canonicalEntry.Signatures[j].Signature\n\t})\n\n\titObj := models.DSSE{}\n\titObj.APIVersion = swag.String(APIVERSION)\n\titObj.Spec = &canonicalEntry\n\n\treturn json.Marshal(&itObj)\n}\n\n// AttestationKey and AttestationKeyValue are not implemented so the envelopes will not be persisted in Rekor\n\nfunc (v V001Entry) CreateFromArtifactProperties(_ context.Context, props types.ArtifactProperties) (models.ProposedEntry, error) {\n\treturnVal := models.DSSE{}\n\tre := V001Entry{\n\t\tDSSEObj: models.DSSEV001Schema{\n\t\t\tProposedContent: &models.DSSEV001SchemaProposedContent{},\n\t\t},\n\t}\n\tvar err error\n\tartifactBytes := props.ArtifactBytes\n\tif artifactBytes == nil {\n\t\tif props.ArtifactPath == nil {\n\t\t\treturn nil, errors.New(\"path to artifact file must be specified\")\n\t\t}\n\t\tif props.ArtifactPath.IsAbs() {\n\t\t\treturn nil, errors.New(\"dsse envelopes cannot be fetched over HTTP(S)\")\n\t\t}\n\t\tartifactBytes, err = os.ReadFile(filepath.Clean(props.ArtifactPath.Path))\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\tenv := &dsse.Envelope{}\n\tif err := json.Unmarshal(artifactBytes, env); err != nil {\n\t\treturn nil, fmt.Errorf(\"payload must be a valid DSSE envelope: %w\", err)\n\t}\n\n\tallPubKeyBytes := make([][]byte, 0)\n\tif len(props.PublicKeyBytes) > 0 {\n\t\tallPubKeyBytes = append(allPubKeyBytes, props.PublicKeyBytes...)\n\t}\n\n\tif len(props.PublicKeyPaths) > 0 {\n\t\tfor _, path := range props.PublicKeyPaths {\n\t\t\tif path.IsAbs() {\n\t\t\t\treturn nil, errors.New(\"dsse public keys cannot be fetched over HTTP(S)\")\n\t\t\t}\n\n\t\t\tpublicKeyBytes, err := os.ReadFile(filepath.Clean(path.Path))\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"error reading public key file: %w\", err)\n\t\t\t}\n\n\t\t\tallPubKeyBytes = append(allPubKeyBytes, publicKeyBytes)\n\t\t}\n\t}\n\n\tkeysBySig, err := verifyEnvelope(allPubKeyBytes, env)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tfor _, key := range keysBySig {\n\t\tcanonicalKey, err := key.CanonicalValue()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tre.DSSEObj.ProposedContent.Verifiers = append(re.DSSEObj.ProposedContent.Verifiers, strfmt.Base64(canonicalKey))\n\t}\n\tre.DSSEObj.ProposedContent.Envelope = swag.String(string(artifactBytes))\n\n\treturnVal.Spec = re.DSSEObj\n\treturnVal.APIVersion = swag.String(re.APIVersion())\n\n\treturn &returnVal, nil\n}\n\n// verifyEnvelope takes in an array of possible key bytes and attempts to parse them as x509 public keys.\n// it then uses these to verify the envelope and makes sure that every signature on the envelope is verified.\n// it returns a map of verifiers indexed by the signature the verifier corresponds to.\nfunc verifyEnvelope(allPubKeyBytes [][]byte, env *dsse.Envelope) (map[string]*x509.PublicKey, error) {\n\t// generate a fake id for these keys so we can get back to the key bytes and match them to their corresponding signature\n\tverifierBySig := make(map[string]*x509.PublicKey)\n\tallSigs := make(map[string]struct{})\n\tfor _, sig := range env.Signatures {\n\t\tallSigs[sig.Sig] = struct{}{}\n\t}\n\n\tfor _, pubKeyBytes := range allPubKeyBytes {\n\t\tif len(allSigs) == 0 {\n\t\t\tbreak // if all signatures have been verified, do not attempt anymore\n\t\t}\n\t\tkey, err := x509.NewPublicKey(bytes.NewReader(pubKeyBytes))\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"could not parse public key as x509: %w\", err)\n\t\t}\n\n\t\tvfr, err := signature.LoadVerifier(key.CryptoPubKey(), crypto.SHA256)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"could not load verifier: %w\", err)\n\t\t}\n\n\t\tdsseVfr, err := dsse.NewEnvelopeVerifier(&sigdsse.VerifierAdapter{SignatureVerifier: vfr})\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"could not use public key as a dsse verifier: %w\", err)\n\t\t}\n\n\t\taccepted, err := dsseVfr.Verify(context.Background(), env)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"could not verify envelope: %w\", err)\n\t\t}\n\n\t\tfor _, accept := range accepted {\n\t\t\tdelete(allSigs, accept.Sig.Sig)\n\t\t\tverifierBySig[accept.Sig.Sig] = key\n\t\t}\n\t}\n\n\tif len(allSigs) > 0 {\n\t\treturn nil, errors.New(\"all signatures must have a key that verifies it\")\n\t}\n\n\treturn verifierBySig, nil\n}\n\nfunc (v V001Entry) Verifier() (pki.PublicKey, error) {\n\tif len(v.DSSEObj.Signatures) == 0 {\n\t\treturn nil, errors.New(\"dsse v0.0.1 entry not initialized\")\n\t}\n\n\t//TODO: return multiple pki.PublicKeys; sigstore/rekor issue #1278\n\treturn x509.NewPublicKey(bytes.NewReader(*v.DSSEObj.Signatures[0].Verifier))\n}\n\nfunc (v V001Entry) Insertable() (bool, error) {\n\tif v.DSSEObj.ProposedContent == nil {\n\t\treturn false, errors.New(\"missing proposed content\")\n\t}\n\tif v.DSSEObj.ProposedContent.Envelope == nil || len(*v.DSSEObj.ProposedContent.Envelope) == 0 {\n\t\treturn false, errors.New(\"missing proposed DSSE envelope\")\n\t}\n\tif len(v.DSSEObj.ProposedContent.Verifiers) == 0 {\n\t\treturn false, errors.New(\"missing proposed verifiers\")\n\t}\n\n\treturn true, nil\n}\n", "//\n// Copyright 2023 The Sigstore Authors.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage dsse\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"crypto\"\n\t\"crypto/ecdsa\"\n\t\"crypto/elliptic\"\n\t\"crypto/rand\"\n\t\"crypto/sha256\"\n\t\"crypto/x509\"\n\t\"encoding/base64\"\n\t\"encoding/hex\"\n\t\"encoding/json\"\n\t\"encoding/pem\"\n\t\"fmt\"\n\t\"math/big\"\n\t\"reflect\"\n\t\"sort\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/go-openapi/runtime\"\n\t\"github.com/go-openapi/strfmt\"\n\t\"github.com/go-openapi/swag\"\n\t\"github.com/google/go-cmp/cmp\"\n\t\"github.com/google/go-cmp/cmp/cmpopts\"\n\t\"github.com/in-toto/in-toto-golang/in_toto\"\n\tslsaCommon \"github.com/in-toto/in-toto-golang/in_toto/slsa_provenance/common\"\n\tslsa \"github.com/in-toto/in-toto-golang/in_toto/slsa_provenance/v0.2\"\n\t\"github.com/secure-systems-lab/go-securesystemslib/dsse\"\n\t\"github.com/sigstore/rekor/pkg/generated/models\"\n\t\"github.com/sigstore/rekor/pkg/types\"\n\t\"github.com/sigstore/sigstore/pkg/signature\"\n\tsigdsse \"github.com/sigstore/sigstore/pkg/signature/dsse\"\n\t\"go.uber.org/goleak\"\n)\n\nfunc TestMain(m *testing.M) {\n\tgoleak.VerifyTestMain(m)\n}\n\nfunc TestNewEntryReturnType(t *testing.T) {\n\tentry := NewEntry()\n\tif reflect.TypeOf(entry) != reflect.ValueOf(&V001Entry{}).Type() {\n\t\tt.Errorf(\"invalid type returned from NewEntry: %T\", entry)\n\t}\n}\n\nfunc envelope(t *testing.T, k *ecdsa.PrivateKey, payload []byte) *dsse.Envelope {\n\n\ts, err := signature.LoadECDSASigner(k, crypto.SHA256)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tsigner, err := dsse.NewEnvelopeSigner(&sigdsse.SignerAdapter{\n\t\tSignatureSigner: s,\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdsseEnv, err := signer.SignPayload(context.Background(), \"application/vnd.in-toto+json\", payload)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\treturn dsseEnv\n}\n\nfunc multiSignEnvelope(t *testing.T, k []*ecdsa.PrivateKey, payload []byte) *dsse.Envelope {\n\tevps := []*sigdsse.SignerAdapter{}\n\tfor _, key := range k {\n\t\ts, err := signature.LoadECDSASigner(key, crypto.SHA256)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tevps = append(evps, &sigdsse.SignerAdapter{\n\t\t\tSignatureSigner: s,\n\t\t})\n\t}\n\n\tsigner, err := dsse.NewMultiEnvelopeSigner(2, evps[0], evps[1])\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdsseEnv, err := signer.SignPayload(context.Background(), in_toto.PayloadType, payload)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\treturn dsseEnv\n}\n\nfunc createRekorEnvelope(dsseEnv *dsse.Envelope, pub [][]byte) *models.DSSEV001SchemaProposedContent {\n\n\tenvelopeBytes, _ := json.Marshal(dsseEnv)\n\tproposedContent := &models.DSSEV001SchemaProposedContent{\n\t\tEnvelope: swag.String(string(envelopeBytes)),\n\t}\n\tfor _, key := range pub {\n\t\tproposedContent.Verifiers = append(proposedContent.Verifiers, strfmt.Base64(key))\n\t}\n\treturn proposedContent\n}\n\nfunc TestV001Entry_Unmarshal(t *testing.T) {\n\tkey, err := ecdsa.GenerateKey(elliptic.P256(), rand.Reader)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tder, err := x509.MarshalPKIXPublicKey(&key.PublicKey)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tpub := pem.EncodeToMemory(&pem.Block{\n\t\tBytes: der,\n\t\tType:  \"PUBLIC KEY\",\n\t})\n\n\tpriv, err := ecdsa.GenerateKey(elliptic.P256(), rand.Reader)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tca := &x509.Certificate{\n\t\tSerialNumber: big.NewInt(1),\n\t}\n\tcaBytes, err := x509.CreateCertificate(rand.Reader, ca, ca, &priv.PublicKey, priv)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tpemBytes := pem.EncodeToMemory(&pem.Block{\n\t\tType:  \"CERTIFICATE\",\n\t\tBytes: caBytes,\n\t})\n\n\tinvalid := dsse.Envelope{\n\t\tPayload: \"hello\",\n\t\tSignatures: []dsse.Signature{\n\t\t\t{\n\t\t\t\tSig: string(strfmt.Base64(\"foobar\")),\n\t\t\t},\n\t\t},\n\t}\n\n\tvalidPayload := \"hellothispayloadisvalid\"\n\n\ttests := []struct {\n\t\tenv     *dsse.Envelope\n\t\tname    string\n\t\tit      *models.DSSEV001Schema\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:    \"empty\",\n\t\t\tit:      &models.DSSEV001Schema{},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"missing envelope\",\n\t\t\tit: &models.DSSEV001Schema{\n\t\t\t\tProposedContent: &models.DSSEV001SchemaProposedContent{},\n\t\t\t},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tenv:  envelope(t, key, []byte(validPayload)),\n\t\t\tname: \"valid\",\n\t\t\tit: &models.DSSEV001Schema{\n\t\t\t\tProposedContent: createRekorEnvelope(envelope(t, key, []byte(validPayload)), [][]byte{pub}),\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tenv:  envelope(t, priv, []byte(validPayload)),\n\t\t\tname: \"cert\",\n\t\t\tit: &models.DSSEV001Schema{\n\t\t\t\tProposedContent: createRekorEnvelope(envelope(t, priv, []byte(validPayload)), [][]byte{pemBytes}),\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tenv:  &invalid,\n\t\t\tname: \"invalid\",\n\t\t\tit: &models.DSSEV001Schema{\n\t\t\t\tProposedContent: createRekorEnvelope(&invalid, [][]byte{pub}),\n\t\t\t},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tenv:  envelope(t, key, []byte(validPayload)),\n\t\t\tname: \"invalid key\",\n\t\t\tit: &models.DSSEV001Schema{\n\t\t\t\tProposedContent: createRekorEnvelope(envelope(t, key, []byte(validPayload)), [][]byte{[]byte(\"notavalidkey\")}),\n\t\t\t},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tenv:  multiSignEnvelope(t, []*ecdsa.PrivateKey{key, priv}, []byte(validPayload)),\n\t\t\tname: \"multi-key\",\n\t\t\tit: &models.DSSEV001Schema{\n\t\t\t\tProposedContent: createRekorEnvelope(multiSignEnvelope(t, []*ecdsa.PrivateKey{key, priv}, []byte(validPayload)), [][]byte{pub, pemBytes}),\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tv := &V001Entry{}\n\n\t\t\tit := &models.DSSE{\n\t\t\t\tSpec: tt.it,\n\t\t\t}\n\n\t\t\tvar uv = func() error {\n\t\t\t\tif err := v.Unmarshal(it); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\n\t\t\t\tif !tt.wantErr {\n\t\t\t\t\tif ok, err := v.Insertable(); !ok || err != nil {\n\t\t\t\t\t\treturn fmt.Errorf(\"unexpected error calling Insertable: %w\", err)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\twant := []string{}\n\t\t\t\tfor _, sig := range v.DSSEObj.Signatures {\n\t\t\t\t\tkeyHash := sha256.Sum256(*sig.Verifier)\n\t\t\t\t\twant = append(want, \"sha256:\"+hex.EncodeToString(keyHash[:]))\n\t\t\t\t}\n\t\t\t\tdecodedPayload, err := base64.StdEncoding.DecodeString(tt.env.Payload)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn fmt.Errorf(\"could not decode envelope payload: %w\", err)\n\t\t\t\t}\n\t\t\t\th := sha256.Sum256(decodedPayload)\n\t\t\t\twant = append(want, \"sha256:\"+hex.EncodeToString(h[:]))\n\n\t\t\t\tenvHashBytes := sha256.Sum256([]byte(*tt.it.ProposedContent.Envelope))\n\t\t\t\tenvHash := hex.EncodeToString(envHashBytes[:])\n\n\t\t\t\thashkey := strings.ToLower(fmt.Sprintf(\"sha256:%s\", envHash))\n\t\t\t\twant = append(want, hashkey)\n\t\t\t\tgot, _ := v.IndexKeys()\n\t\t\t\tsort.Strings(got)\n\t\t\t\tsort.Strings(want)\n\t\t\t\tif !reflect.DeepEqual(got, want) {\n\t\t\t\t\tt.Errorf(\"V001Entry.IndexKeys() = %v, want %v\", got, want)\n\t\t\t\t}\n\t\t\t\tpayloadBytes, _ := v.env.DecodeB64Payload()\n\t\t\t\tpayloadSha := sha256.Sum256(payloadBytes)\n\t\t\t\tpayloadHash := hex.EncodeToString(payloadSha[:])\n\n\t\t\t\tcanonicalBytes, err := v.Canonicalize(context.Background())\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Errorf(\"error canonicalizing entry: %v\", err)\n\t\t\t\t}\n\n\t\t\t\tpe, err := models.UnmarshalProposedEntry(bytes.NewReader(canonicalBytes), runtime.JSONConsumer())\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Errorf(\"unexpected err from Unmarshalling canonicalized entry for '%v': %v\", tt.name, err)\n\t\t\t\t}\n\t\t\t\tcanonicalEntry, err := types.UnmarshalEntry(pe)\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Errorf(\"unexpected err from type-specific unmarshalling for '%v': %v\", tt.name, err)\n\t\t\t\t}\n\t\t\t\tcanonicalV001 := canonicalEntry.(*V001Entry)\n\t\t\t\tif ok, err := canonicalV001.Insertable(); ok || err == nil {\n\t\t\t\t\tt.Errorf(\"unexpected success testing Insertable against entry created from canonicalized content\")\n\t\t\t\t}\n\t\t\t\tif *canonicalV001.DSSEObj.EnvelopeHash.Value != envHash {\n\t\t\t\t\tt.Errorf(\"envelope hashes do not match post canonicalization: %v %v\", *canonicalV001.DSSEObj.EnvelopeHash.Value, envHash)\n\t\t\t\t}\n\t\t\t\tif *canonicalV001.DSSEObj.PayloadHash.Value != payloadHash {\n\t\t\t\t\tt.Errorf(\"payload hashes do not match post canonicalization: %v %v\", canonicalV001.DSSEObj.PayloadHash.Value, payloadHash)\n\t\t\t\t}\n\t\t\t\tcanonicalIndexKeys, _ := canonicalV001.IndexKeys()\n\t\t\t\tif !cmp.Equal(got, canonicalIndexKeys, cmpopts.SortSlices(func(x, y string) bool { return x < y })) {\n\t\t\t\t\tt.Errorf(\"index keys from hydrated object do not match those generated from canonicalized (and re-hydrated) object: %v %v\", got, canonicalIndexKeys)\n\t\t\t\t}\n\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\tif err := uv(); (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"V001Entry.Unmarshal() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestV001Entry_IndexKeys(t *testing.T) {\n\tkey, err := ecdsa.GenerateKey(elliptic.P256(), rand.Reader)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tder, err := x509.MarshalPKIXPublicKey(&key.PublicKey)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tpub := pem.EncodeToMemory(&pem.Block{\n\t\tBytes: der,\n\t\tType:  \"PUBLIC KEY\",\n\t})\n\n\ttests := []struct {\n\t\tname      string\n\t\tstatement in_toto.Statement\n\t\twant      []string\n\t}{\n\t\t{\n\t\t\tname: \"standard\",\n\t\t\twant: []string{},\n\t\t\tstatement: in_toto.Statement{\n\t\t\t\tPredicate: \"hello\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"subject\",\n\t\t\twant: []string{\"sha256:foo\"},\n\t\t\tstatement: in_toto.Statement{\n\t\t\t\tStatementHeader: in_toto.StatementHeader{\n\t\t\t\t\tSubject: []in_toto.Subject{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tName: \"foo\",\n\t\t\t\t\t\t\tDigest: map[string]string{\n\t\t\t\t\t\t\t\t\"sha256\": \"foo\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tPredicate: \"hello\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"slsa\",\n\t\t\twant: []string{\"sha256:bar\"},\n\t\t\tstatement: in_toto.Statement{\n\t\t\t\tPredicate: slsa.ProvenancePredicate{\n\t\t\t\t\tMaterials: []slsaCommon.ProvenanceMaterial{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tURI: \"foo\",\n\t\t\t\t\t\t\tDigest: map[string]string{\n\t\t\t\t\t\t\t\t\"sha256\": \"bar\",\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"slsa wit header\",\n\t\t\twant: []string{\"sha256:foo\", \"sha256:bar\"},\n\t\t\tstatement: in_toto.Statement{\n\t\t\t\tStatementHeader: in_toto.StatementHeader{\n\t\t\t\t\tSubject: []in_toto.Subject{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tName: \"foo\",\n\t\t\t\t\t\t\tDigest: map[string]string{\n\t\t\t\t\t\t\t\t\"sha256\": \"foo\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tPredicate: slsa.ProvenancePredicate{\n\t\t\t\t\tMaterials: []slsaCommon.ProvenanceMaterial{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tURI: \"foo\",\n\t\t\t\t\t\t\tDigest: map[string]string{\n\t\t\t\t\t\t\t\t\"sha256\": \"bar\",\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tb, err := json.Marshal(tt.statement)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tpe := &models.DSSE{\n\t\t\t\tAPIVersion: swag.String(APIVERSION),\n\t\t\t\tSpec: &models.DSSEV001Schema{\n\t\t\t\t\tProposedContent: createRekorEnvelope(envelope(t, key, b), [][]byte{pub}),\n\t\t\t\t},\n\t\t\t}\n\t\t\tv := V001Entry{}\n\t\t\tif err := v.Unmarshal(pe); err != nil {\n\t\t\t\tt.Error(err)\n\t\t\t}\n\t\t\twant := []string{}\n\t\t\tfor _, sig := range v.DSSEObj.Signatures {\n\t\t\t\tkeyHash := sha256.Sum256(*sig.Verifier)\n\t\t\t\twant = append(want, \"sha256:\"+hex.EncodeToString(keyHash[:]))\n\t\t\t}\n\t\t\tdecodedPayload, _ := base64.StdEncoding.DecodeString(v.env.Payload)\n\t\t\th := sha256.Sum256(decodedPayload)\n\t\t\twant = append(want, \"sha256:\"+hex.EncodeToString(h[:]))\n\n\t\t\tenvHashBytes := sha256.Sum256([]byte(*v.DSSEObj.ProposedContent.Envelope))\n\t\t\tenvHash := hex.EncodeToString(envHashBytes[:])\n\n\t\t\thashkey := strings.ToLower(fmt.Sprintf(\"sha256:%s\", envHash))\n\t\t\twant = append(want, hashkey)\n\t\t\twant = append(want, tt.want...)\n\t\t\tgot, err := v.IndexKeys()\n\t\t\tif err != nil {\n\t\t\t\tt.Error(err)\n\t\t\t}\n\t\t\tsort.Strings(got)\n\t\t\tsort.Strings(want)\n\t\t\tif !cmp.Equal(got, want, cmpopts.EquateEmpty()) {\n\t\t\t\tt.Errorf(\"V001Entry.IndexKeys() = %v, want %v\", got, want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestInsertable(t *testing.T) {\n\ttype TestCase struct {\n\t\tcaseDesc      string\n\t\tentry         V001Entry\n\t\texpectSuccess bool\n\t}\n\n\ttestCases := []TestCase{\n\t\t{\n\t\t\tcaseDesc: \"valid entry\",\n\t\t\tentry: V001Entry{\n\t\t\t\tDSSEObj: models.DSSEV001Schema{\n\t\t\t\t\tProposedContent: &models.DSSEV001SchemaProposedContent{\n\t\t\t\t\t\tEnvelope: swag.String(\"envelope\"),\n\t\t\t\t\t\tVerifiers: []strfmt.Base64{\n\t\t\t\t\t\t\t[]byte(\"keys\"),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectSuccess: true,\n\t\t},\n\t\t{\n\t\t\tcaseDesc: \"missing public keys\",\n\t\t\tentry: V001Entry{\n\t\t\t\tDSSEObj: models.DSSEV001Schema{\n\t\t\t\t\tProposedContent: &models.DSSEV001SchemaProposedContent{\n\t\t\t\t\t\tEnvelope: swag.String(\"envelope\"),\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t\tVerifiers: []strfmt.Base64{\n\t\t\t\t\t\t\t\t[]byte(\"keys\"),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t*/\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectSuccess: false,\n\t\t},\n\t\t{\n\t\t\tcaseDesc: \"missing envelope\",\n\t\t\tentry: V001Entry{\n\t\t\t\tDSSEObj: models.DSSEV001Schema{\n\t\t\t\t\tProposedContent: &models.DSSEV001SchemaProposedContent{\n\t\t\t\t\t\t//Envelope: swag.String(\"envelope\"),\n\t\t\t\t\t\tVerifiers: []strfmt.Base64{\n\t\t\t\t\t\t\t[]byte(\"keys\"),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectSuccess: false,\n\t\t},\n\t\t{\n\t\t\tcaseDesc: \"missing proposed content obj\",\n\t\t\tentry: V001Entry{\n\t\t\t\tDSSEObj: models.DSSEV001Schema{\n\t\t\t\t\t/*\n\t\t\t\t\t\tProposedContent: &models.DSSEV001SchemaProposedContent{\n\t\t\t\t\t\t\tEnvelope: swag.String(\"envelope\"),\n\t\t\t\t\t\t\tVerifiers: []strfmt.Base64{\n\t\t\t\t\t\t\t\t[]byte(\"keys\"),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t*/\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectSuccess: false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.caseDesc, func(t *testing.T) {\n\t\t\tif ok, err := tc.entry.Insertable(); ok != tc.expectSuccess {\n\t\t\t\tt.Errorf(\"unexpected result calling Insertable: %v\", err)\n\t\t\t}\n\t\t})\n\t}\n}\n", "//\n// Copyright 2022 The Sigstore Authors.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage intoto\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"crypto\"\n\t\"crypto/sha256\"\n\t\"encoding/base64\"\n\t\"encoding/hex\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\n\t\"github.com/in-toto/in-toto-golang/in_toto\"\n\t\"github.com/secure-systems-lab/go-securesystemslib/dsse\"\n\t\"github.com/spf13/viper\"\n\n\t\"github.com/go-openapi/strfmt\"\n\t\"github.com/go-openapi/swag\"\n\n\t\"github.com/sigstore/rekor/pkg/generated/models\"\n\t\"github.com/sigstore/rekor/pkg/log\"\n\t\"github.com/sigstore/rekor/pkg/pki\"\n\t\"github.com/sigstore/rekor/pkg/pki/x509\"\n\t\"github.com/sigstore/rekor/pkg/types\"\n\t\"github.com/sigstore/rekor/pkg/types/intoto\"\n\t\"github.com/sigstore/sigstore/pkg/signature\"\n\t\"github.com/sigstore/sigstore/pkg/signature/options\"\n)\n\nconst (\n\tAPIVERSION = \"0.0.2\"\n)\n\nfunc init() {\n\tif err := intoto.VersionMap.SetEntryFactory(APIVERSION, NewEntry); err != nil {\n\t\tlog.Logger.Panic(err)\n\t}\n}\n\ntype V002Entry struct {\n\tIntotoObj models.IntotoV002Schema\n\tenv       dsse.Envelope\n}\n\nfunc (v V002Entry) APIVersion() string {\n\treturn APIVERSION\n}\n\nfunc NewEntry() types.EntryImpl {\n\treturn &V002Entry{}\n}\n\nfunc (v V002Entry) IndexKeys() ([]string, error) {\n\tvar result []string\n\n\tif v.IntotoObj.Content == nil || v.IntotoObj.Content.Envelope == nil {\n\t\tlog.Logger.Info(\"IntotoObj content or dsse envelope is nil\")\n\t\treturn result, nil\n\t}\n\n\tfor _, sig := range v.IntotoObj.Content.Envelope.Signatures {\n\t\tkeyObj, err := x509.NewPublicKey(bytes.NewReader(sig.PublicKey))\n\t\tif err != nil {\n\t\t\treturn result, err\n\t\t}\n\n\t\tcanonKey, err := keyObj.CanonicalValue()\n\t\tif err != nil {\n\t\t\treturn result, fmt.Errorf(\"could not canonicize key: %w\", err)\n\t\t}\n\n\t\tkeyHash := sha256.Sum256(canonKey)\n\t\tresult = append(result, \"sha256:\"+hex.EncodeToString(keyHash[:]))\n\n\t\tresult = append(result, keyObj.Subjects()...)\n\t}\n\n\tpayloadKey := strings.ToLower(fmt.Sprintf(\"%s:%s\", *v.IntotoObj.Content.PayloadHash.Algorithm, *v.IntotoObj.Content.PayloadHash.Value))\n\tresult = append(result, payloadKey)\n\n\t// since we can't deterministically calculate this server-side (due to public keys being added inline, and also canonicalization being potentially different),\n\t// we'll just skip adding this index key\n\t// hashkey := strings.ToLower(fmt.Sprintf(\"%s:%s\", *v.IntotoObj.Content.Hash.Algorithm, *v.IntotoObj.Content.Hash.Value))\n\t// result = append(result, hashkey)\n\n\tswitch *v.IntotoObj.Content.Envelope.PayloadType {\n\tcase in_toto.PayloadType:\n\n\t\tif v.IntotoObj.Content.Envelope.Payload == nil {\n\t\t\tlog.Logger.Info(\"IntotoObj DSSE payload is empty\")\n\t\t\treturn result, nil\n\t\t}\n\t\tdecodedPayload, err := base64.StdEncoding.DecodeString(string(v.IntotoObj.Content.Envelope.Payload))\n\t\tif err != nil {\n\t\t\treturn result, fmt.Errorf(\"could not decode envelope payload: %w\", err)\n\t\t}\n\t\tstatement, err := parseStatement(decodedPayload)\n\t\tif err != nil {\n\t\t\treturn result, err\n\t\t}\n\t\tfor _, s := range statement.Subject {\n\t\t\tfor alg, ds := range s.Digest {\n\t\t\t\tresult = append(result, alg+\":\"+ds)\n\t\t\t}\n\t\t}\n\t\t// Not all in-toto statements will contain a SLSA provenance predicate.\n\t\t// See https://github.com/in-toto/attestation/blob/main/spec/README.md#predicate\n\t\t// for other predicates.\n\t\tif predicate, err := parseSlsaPredicate(decodedPayload); err == nil {\n\t\t\tif predicate.Predicate.Materials != nil {\n\t\t\t\tfor _, s := range predicate.Predicate.Materials {\n\t\t\t\t\tfor alg, ds := range s.Digest {\n\t\t\t\t\t\tresult = append(result, alg+\":\"+ds)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tdefault:\n\t\tlog.Logger.Infof(\"Unknown in_toto DSSE envelope Type: %s\", *v.IntotoObj.Content.Envelope.PayloadType)\n\t}\n\treturn result, nil\n}\n\nfunc parseStatement(p []byte) (*in_toto.Statement, error) {\n\tps := in_toto.Statement{}\n\tif err := json.Unmarshal(p, &ps); err != nil {\n\t\treturn nil, err\n\t}\n\treturn &ps, nil\n}\n\nfunc parseSlsaPredicate(p []byte) (*in_toto.ProvenanceStatement, error) {\n\tpredicate := in_toto.ProvenanceStatement{}\n\tif err := json.Unmarshal(p, &predicate); err != nil {\n\t\treturn nil, err\n\t}\n\treturn &predicate, nil\n}\n\nfunc (v *V002Entry) Unmarshal(pe models.ProposedEntry) error {\n\tit, ok := pe.(*models.Intoto)\n\tif !ok {\n\t\treturn errors.New(\"cannot unmarshal non Intoto v0.0.2 type\")\n\t}\n\n\tvar err error\n\tif err := types.DecodeEntry(it.Spec, &v.IntotoObj); err != nil {\n\t\treturn err\n\t}\n\n\t// field validation\n\tif err := v.IntotoObj.Validate(strfmt.Default); err != nil {\n\t\treturn err\n\t}\n\n\tif string(v.IntotoObj.Content.Envelope.Payload) == \"\" {\n\t\treturn nil\n\t}\n\n\tenv := &dsse.Envelope{\n\t\tPayload:     string(v.IntotoObj.Content.Envelope.Payload),\n\t\tPayloadType: *v.IntotoObj.Content.Envelope.PayloadType,\n\t}\n\n\tallPubKeyBytes := make([][]byte, 0)\n\tfor _, sig := range v.IntotoObj.Content.Envelope.Signatures {\n\t\tenv.Signatures = append(env.Signatures, dsse.Signature{\n\t\t\tKeyID: sig.Keyid,\n\t\t\tSig:   string(sig.Sig),\n\t\t})\n\n\t\tallPubKeyBytes = append(allPubKeyBytes, sig.PublicKey)\n\t}\n\n\tif _, err := verifyEnvelope(allPubKeyBytes, env); err != nil {\n\t\treturn err\n\t}\n\n\tv.env = *env\n\n\tdecodedPayload, err := base64.StdEncoding.DecodeString(string(v.IntotoObj.Content.Envelope.Payload))\n\tif err != nil {\n\t\treturn fmt.Errorf(\"could not decode envelope payload: %w\", err)\n\t}\n\n\th := sha256.Sum256(decodedPayload)\n\tv.IntotoObj.Content.PayloadHash = &models.IntotoV002SchemaContentPayloadHash{\n\t\tAlgorithm: swag.String(models.IntotoV002SchemaContentPayloadHashAlgorithmSha256),\n\t\tValue:     swag.String(hex.EncodeToString(h[:])),\n\t}\n\n\treturn nil\n}\n\nfunc (v *V002Entry) Canonicalize(_ context.Context) ([]byte, error) {\n\tif err := v.IntotoObj.Validate(strfmt.Default); err != nil {\n\t\treturn nil, err\n\t}\n\n\tif v.IntotoObj.Content.Hash == nil {\n\t\treturn nil, errors.New(\"missing envelope digest\")\n\t}\n\n\tif err := v.IntotoObj.Content.Hash.Validate(strfmt.Default); err != nil {\n\t\treturn nil, fmt.Errorf(\"error validating envelope digest: %w\", err)\n\t}\n\n\tif v.IntotoObj.Content.PayloadHash == nil {\n\t\treturn nil, errors.New(\"missing payload digest\")\n\t}\n\n\tif err := v.IntotoObj.Content.PayloadHash.Validate(strfmt.Default); err != nil {\n\t\treturn nil, fmt.Errorf(\"error validating payload digest: %w\", err)\n\t}\n\n\tif len(v.IntotoObj.Content.Envelope.Signatures) == 0 {\n\t\treturn nil, errors.New(\"missing signatures\")\n\t}\n\n\tcanonicalEntry := models.IntotoV002Schema{\n\t\tContent: &models.IntotoV002SchemaContent{\n\t\t\tEnvelope: &models.IntotoV002SchemaContentEnvelope{\n\t\t\t\tPayloadType: v.IntotoObj.Content.Envelope.PayloadType,\n\t\t\t\tSignatures:  v.IntotoObj.Content.Envelope.Signatures,\n\t\t\t},\n\t\t\tHash:        v.IntotoObj.Content.Hash,\n\t\t\tPayloadHash: v.IntotoObj.Content.PayloadHash,\n\t\t},\n\t}\n\titObj := models.Intoto{}\n\titObj.APIVersion = swag.String(APIVERSION)\n\titObj.Spec = &canonicalEntry\n\n\treturn json.Marshal(&itObj)\n}\n\n// AttestationKey returns the digest of the attestation that was uploaded, to be used to lookup the attestation from storage\nfunc (v *V002Entry) AttestationKey() string {\n\tif v.IntotoObj.Content != nil && v.IntotoObj.Content.PayloadHash != nil {\n\t\treturn fmt.Sprintf(\"%s:%s\", *v.IntotoObj.Content.PayloadHash.Algorithm, *v.IntotoObj.Content.PayloadHash.Value)\n\t}\n\treturn \"\"\n}\n\n// AttestationKeyValue returns both the key and value to be persisted into attestation storage\nfunc (v *V002Entry) AttestationKeyValue() (string, []byte) {\n\tstorageSize := base64.StdEncoding.DecodedLen(len(v.env.Payload))\n\tif storageSize > viper.GetInt(\"max_attestation_size\") {\n\t\tlog.Logger.Infof(\"Skipping attestation storage, size %d is greater than max %d\", storageSize, viper.GetInt(\"max_attestation_size\"))\n\t\treturn \"\", nil\n\t}\n\tattBytes, err := base64.StdEncoding.DecodeString(v.env.Payload)\n\tif err != nil {\n\t\tlog.Logger.Infof(\"could not decode envelope payload: %w\", err)\n\t\treturn \"\", nil\n\t}\n\treturn v.AttestationKey(), attBytes\n}\n\ntype verifier struct {\n\ts signature.Signer\n\tv signature.Verifier\n}\n\nfunc (v *verifier) KeyID() (string, error) {\n\treturn \"\", nil\n}\n\nfunc (v *verifier) Public() crypto.PublicKey {\n\t// the dsse library uses this to generate a key ID if the KeyID function returns an empty string\n\t// as well for the AcceptedKey return value.  Unfortunately since key ids can be arbitrary, we don't\n\t// know how to generate a matching id for the key id on the envelope's signature...\n\t// dsse verify will skip verifiers whose key id doesn't match the signature's key id, unless it fails\n\t// to generate one from the public key... so we trick it by returning nil \u00af\\_(\u30c4)_/\u00af\n\treturn nil\n}\n\nfunc (v *verifier) Sign(_ context.Context, data []byte) (sig []byte, err error) {\n\tif v.s == nil {\n\t\treturn nil, errors.New(\"nil signer\")\n\t}\n\tsig, err = v.s.SignMessage(bytes.NewReader(data), options.WithCryptoSignerOpts(crypto.SHA256))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn sig, nil\n}\n\nfunc (v *verifier) Verify(_ context.Context, data, sig []byte) error {\n\tif v.v == nil {\n\t\treturn errors.New(\"nil verifier\")\n\t}\n\treturn v.v.VerifySignature(bytes.NewReader(sig), bytes.NewReader(data))\n}\n\nfunc (v V002Entry) CreateFromArtifactProperties(_ context.Context, props types.ArtifactProperties) (models.ProposedEntry, error) {\n\treturnVal := models.Intoto{}\n\tre := V002Entry{\n\t\tIntotoObj: models.IntotoV002Schema{\n\t\t\tContent: &models.IntotoV002SchemaContent{\n\t\t\t\tEnvelope: &models.IntotoV002SchemaContentEnvelope{},\n\t\t\t},\n\t\t}}\n\tvar err error\n\tartifactBytes := props.ArtifactBytes\n\tif artifactBytes == nil {\n\t\tif props.ArtifactPath == nil {\n\t\t\treturn nil, errors.New(\"path to artifact file must be specified\")\n\t\t}\n\t\tif props.ArtifactPath.IsAbs() {\n\t\t\treturn nil, errors.New(\"intoto envelopes cannot be fetched over HTTP(S)\")\n\t\t}\n\t\tartifactBytes, err = os.ReadFile(filepath.Clean(props.ArtifactPath.Path))\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\tenv := dsse.Envelope{}\n\tif err := json.Unmarshal(artifactBytes, &env); err != nil {\n\t\treturn nil, fmt.Errorf(\"payload must be a valid dsse envelope: %w\", err)\n\t}\n\n\tallPubKeyBytes := make([][]byte, 0)\n\tif len(props.PublicKeyBytes) > 0 {\n\t\tallPubKeyBytes = append(allPubKeyBytes, props.PublicKeyBytes...)\n\t}\n\n\tif len(props.PublicKeyPaths) > 0 {\n\t\tfor _, path := range props.PublicKeyPaths {\n\t\t\tif path.IsAbs() {\n\t\t\t\treturn nil, errors.New(\"dsse public keys cannot be fetched over HTTP(S)\")\n\t\t\t}\n\n\t\t\tpublicKeyBytes, err := os.ReadFile(filepath.Clean(path.Path))\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"error reading public key file: %w\", err)\n\t\t\t}\n\n\t\t\tallPubKeyBytes = append(allPubKeyBytes, publicKeyBytes)\n\t\t}\n\t}\n\n\tkeysBySig, err := verifyEnvelope(allPubKeyBytes, &env)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tb64 := strfmt.Base64([]byte(env.Payload))\n\tre.IntotoObj.Content.Envelope.Payload = b64\n\tre.IntotoObj.Content.Envelope.PayloadType = &env.PayloadType\n\n\tfor _, sig := range env.Signatures {\n\t\tkey, ok := keysBySig[sig.Sig]\n\t\tif !ok {\n\t\t\treturn nil, errors.New(\"all signatures must have a key that verifies it\")\n\t\t}\n\n\t\tcanonKey, err := key.CanonicalValue()\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"could not canonicize key: %w\", err)\n\t\t}\n\n\t\tkeyBytes := strfmt.Base64(canonKey)\n\t\tre.IntotoObj.Content.Envelope.Signatures = append(re.IntotoObj.Content.Envelope.Signatures, &models.IntotoV002SchemaContentEnvelopeSignaturesItems0{\n\t\t\tKeyid:     sig.KeyID,\n\t\t\tSig:       strfmt.Base64([]byte(sig.Sig)),\n\t\t\tPublicKey: keyBytes,\n\t\t})\n\t}\n\n\th := sha256.Sum256([]byte(artifactBytes))\n\tre.IntotoObj.Content.Hash = &models.IntotoV002SchemaContentHash{\n\t\tAlgorithm: swag.String(models.IntotoV001SchemaContentHashAlgorithmSha256),\n\t\tValue:     swag.String(hex.EncodeToString(h[:])),\n\t}\n\n\treturnVal.Spec = re.IntotoObj\n\treturnVal.APIVersion = swag.String(re.APIVersion())\n\n\treturn &returnVal, nil\n}\n\n// verifyEnvelope takes in an array of possible key bytes and attempts to parse them as x509 public keys.\n// it then uses these to verify the envelope and makes sure that every signature on the envelope is verified.\n// it returns a map of verifiers indexed by the signature the verifier corresponds to.\nfunc verifyEnvelope(allPubKeyBytes [][]byte, env *dsse.Envelope) (map[string]*x509.PublicKey, error) {\n\t// generate a fake id for these keys so we can get back to the key bytes and match them to their corresponding signature\n\tverifierBySig := make(map[string]*x509.PublicKey)\n\tallSigs := make(map[string]struct{})\n\tfor _, sig := range env.Signatures {\n\t\tallSigs[sig.Sig] = struct{}{}\n\t}\n\n\tfor _, pubKeyBytes := range allPubKeyBytes {\n\t\tkey, err := x509.NewPublicKey(bytes.NewReader(pubKeyBytes))\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"could not parse public key as x509: %w\", err)\n\t\t}\n\n\t\tvfr, err := signature.LoadVerifier(key.CryptoPubKey(), crypto.SHA256)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"could not load verifier: %w\", err)\n\t\t}\n\n\t\tdsseVfr, err := dsse.NewEnvelopeVerifier(&verifier{\n\t\t\tv: vfr,\n\t\t})\n\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"could not use public key as a dsse verifier: %w\", err)\n\t\t}\n\n\t\taccepted, err := dsseVfr.Verify(context.Background(), env)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"could not verify envelope: %w\", err)\n\t\t}\n\n\t\tfor _, accept := range accepted {\n\t\t\tdelete(allSigs, accept.Sig.Sig)\n\t\t\tverifierBySig[accept.Sig.Sig] = key\n\t\t}\n\t}\n\n\tif len(allSigs) > 0 {\n\t\treturn nil, errors.New(\"all signatures must have a key that verifies it\")\n\t}\n\n\treturn verifierBySig, nil\n}\n\nfunc (v V002Entry) Verifier() (pki.PublicKey, error) {\n\tif v.IntotoObj.Content == nil || v.IntotoObj.Content.Envelope == nil {\n\t\treturn nil, errors.New(\"intoto v0.0.2 entry not initialized\")\n\t}\n\n\tsigs := v.IntotoObj.Content.Envelope.Signatures\n\tif len(sigs) == 0 {\n\t\treturn nil, errors.New(\"no signatures found on intoto entry\")\n\t}\n\n\treturn x509.NewPublicKey(bytes.NewReader(v.IntotoObj.Content.Envelope.Signatures[0].PublicKey))\n}\n\nfunc (v V002Entry) Insertable() (bool, error) {\n\tif v.IntotoObj.Content == nil {\n\t\treturn false, errors.New(\"missing content property\")\n\t}\n\tif v.IntotoObj.Content.Envelope == nil {\n\t\treturn false, errors.New(\"missing envelope property\")\n\t}\n\tif len(v.IntotoObj.Content.Envelope.Payload) == 0 {\n\t\treturn false, errors.New(\"missing envelope content\")\n\t}\n\n\tif v.IntotoObj.Content.Envelope.PayloadType == nil || len(*v.IntotoObj.Content.Envelope.PayloadType) == 0 {\n\t\treturn false, errors.New(\"missing payloadType content\")\n\t}\n\n\tif len(v.IntotoObj.Content.Envelope.Signatures) == 0 {\n\t\treturn false, errors.New(\"missing signatures content\")\n\t}\n\tfor _, sig := range v.IntotoObj.Content.Envelope.Signatures {\n\t\tif len(sig.Sig) == 0 {\n\t\t\treturn false, errors.New(\"missing signature content\")\n\t\t}\n\t\tif len(sig.PublicKey) == 0 {\n\t\t\treturn false, errors.New(\"missing publicKey content\")\n\t\t}\n\t}\n\n\tif v.env.Payload == \"\" || v.env.PayloadType == \"\" || len(v.env.Signatures) == 0 {\n\t\treturn false, errors.New(\"invalid DSSE envelope\")\n\t}\n\n\treturn true, nil\n}\n", "//\n// Copyright 2022 The Sigstore Authors.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage intoto\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"crypto\"\n\t\"crypto/ecdsa\"\n\t\"crypto/elliptic\"\n\t\"crypto/rand\"\n\t\"crypto/sha256\"\n\t\"crypto/x509\"\n\t\"encoding/base64\"\n\t\"encoding/hex\"\n\t\"encoding/json\"\n\t\"encoding/pem\"\n\t\"fmt\"\n\t\"math/big\"\n\t\"reflect\"\n\t\"sort\"\n\t\"testing\"\n\n\t\"github.com/go-openapi/runtime\"\n\t\"github.com/go-openapi/strfmt\"\n\t\"github.com/go-openapi/swag\"\n\t\"github.com/google/go-cmp/cmp\"\n\t\"github.com/google/go-cmp/cmp/cmpopts\"\n\t\"github.com/in-toto/in-toto-golang/in_toto\"\n\t\"github.com/in-toto/in-toto-golang/in_toto/slsa_provenance/common\"\n\tslsa \"github.com/in-toto/in-toto-golang/in_toto/slsa_provenance/v0.2\"\n\t\"github.com/secure-systems-lab/go-securesystemslib/dsse\"\n\t\"github.com/sigstore/rekor/pkg/generated/models\"\n\t\"github.com/sigstore/rekor/pkg/types\"\n\t\"github.com/sigstore/sigstore/pkg/signature\"\n\t\"go.uber.org/goleak\"\n)\n\nfunc TestMain(m *testing.M) {\n\tgoleak.VerifyTestMain(m)\n}\n\nfunc TestNewEntryReturnType(t *testing.T) {\n\tentry := NewEntry()\n\tif reflect.TypeOf(entry) != reflect.ValueOf(&V002Entry{}).Type() {\n\t\tt.Errorf(\"invalid type returned from NewEntry: %T\", entry)\n\t}\n}\n\nfunc envelope(t *testing.T, k *ecdsa.PrivateKey, payload []byte) *dsse.Envelope {\n\ts, err := signature.LoadECDSASigner(k, crypto.SHA256)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tsigner, err := dsse.NewEnvelopeSigner(\n\t\t&verifier{\n\t\t\ts: s,\n\t\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdsseEnv, err := signer.SignPayload(context.Background(), \"application/vnd.in-toto+json\", payload)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\treturn dsseEnv\n}\n\nfunc multiSignEnvelope(t *testing.T, k []*ecdsa.PrivateKey, payload []byte) *dsse.Envelope {\n\tevps := []*verifier{}\n\tfor _, key := range k {\n\t\ts, err := signature.LoadECDSASigner(key, crypto.SHA256)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tevps = append(evps, &verifier{\n\t\t\ts: s,\n\t\t})\n\t}\n\n\tsigner, err := dsse.NewMultiEnvelopeSigner(2, evps[0], evps[1])\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdsseEnv, err := signer.SignPayload(context.Background(), in_toto.PayloadType, payload)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\treturn dsseEnv\n}\n\nfunc createRekorEnvelope(dsseEnv *dsse.Envelope, pub [][]byte) *models.IntotoV002SchemaContentEnvelope {\n\tenv := &models.IntotoV002SchemaContentEnvelope{}\n\tb64 := strfmt.Base64([]byte(dsseEnv.Payload))\n\tenv.Payload = b64\n\tenv.PayloadType = &dsseEnv.PayloadType\n\n\tfor i, sig := range dsseEnv.Signatures {\n\t\tenv.Signatures = append(env.Signatures, &models.IntotoV002SchemaContentEnvelopeSignaturesItems0{\n\t\t\tKeyid:     sig.KeyID,\n\t\t\tSig:       strfmt.Base64([]byte(sig.Sig)),\n\t\t\tPublicKey: strfmt.Base64(pub[i]),\n\t\t})\n\t}\n\n\treturn env\n}\n\nfunc envelopeHash(t *testing.T, dsseEnv *dsse.Envelope) string {\n\tval, err := json.Marshal(dsseEnv)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\th := sha256.Sum256(val)\n\treturn hex.EncodeToString(h[:])\n}\n\nfunc TestV002Entry_Unmarshal(t *testing.T) {\n\tkey, err := ecdsa.GenerateKey(elliptic.P256(), rand.Reader)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tder, err := x509.MarshalPKIXPublicKey(&key.PublicKey)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tpub := pem.EncodeToMemory(&pem.Block{\n\t\tBytes: der,\n\t\tType:  \"PUBLIC KEY\",\n\t})\n\n\tpriv, err := ecdsa.GenerateKey(elliptic.P256(), rand.Reader)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tca := &x509.Certificate{\n\t\tSerialNumber: big.NewInt(1),\n\t}\n\tcaBytes, err := x509.CreateCertificate(rand.Reader, ca, ca, &priv.PublicKey, priv)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tpemBytes := pem.EncodeToMemory(&pem.Block{\n\t\tType:  \"CERTIFICATE\",\n\t\tBytes: caBytes,\n\t})\n\n\tinvalid := dsse.Envelope{\n\t\tPayload: \"hello\",\n\t\tSignatures: []dsse.Signature{\n\t\t\t{\n\t\t\t\tSig: string(strfmt.Base64(\"foobar\")),\n\t\t\t},\n\t\t},\n\t}\n\n\tvalidPayload := \"hellothispayloadisvalid\"\n\n\ttests := []struct {\n\t\tenv             *dsse.Envelope\n\t\tname            string\n\t\tit              *models.IntotoV002Schema\n\t\twantErr         bool\n\t\twantVerifierErr bool\n\t}{\n\t\t{\n\t\t\tname:            \"empty\",\n\t\t\tit:              &models.IntotoV002Schema{},\n\t\t\twantErr:         true,\n\t\t\twantVerifierErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"missing envelope\",\n\t\t\tit: &models.IntotoV002Schema{\n\t\t\t\tContent: &models.IntotoV002SchemaContent{\n\t\t\t\t\tHash: &models.IntotoV002SchemaContentHash{\n\t\t\t\t\t\tAlgorithm: swag.String(models.IntotoV002SchemaContentHashAlgorithmSha256),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr:         true,\n\t\t\twantVerifierErr: true,\n\t\t},\n\t\t{\n\t\t\tenv:  envelope(t, key, []byte(validPayload)),\n\t\t\tname: \"valid\",\n\t\t\tit: &models.IntotoV002Schema{\n\t\t\t\tContent: &models.IntotoV002SchemaContent{\n\t\t\t\t\tEnvelope: createRekorEnvelope(envelope(t, key, []byte(validPayload)), [][]byte{pub}),\n\t\t\t\t\tHash: &models.IntotoV002SchemaContentHash{\n\t\t\t\t\t\tAlgorithm: swag.String(models.IntotoV002SchemaContentHashAlgorithmSha256),\n\t\t\t\t\t\tValue:     swag.String(envelopeHash(t, envelope(t, key, []byte(validPayload)))),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr:         false,\n\t\t\twantVerifierErr: false,\n\t\t},\n\t\t{\n\t\t\tenv:  envelope(t, priv, []byte(validPayload)),\n\t\t\tname: \"cert\",\n\t\t\tit: &models.IntotoV002Schema{\n\t\t\t\tContent: &models.IntotoV002SchemaContent{\n\t\t\t\t\tEnvelope: createRekorEnvelope(envelope(t, priv, []byte(validPayload)), [][]byte{pemBytes}),\n\t\t\t\t\tHash: &models.IntotoV002SchemaContentHash{\n\t\t\t\t\t\tAlgorithm: swag.String(models.IntotoV002SchemaContentHashAlgorithmSha256),\n\t\t\t\t\t\tValue:     swag.String(envelopeHash(t, envelope(t, priv, []byte(validPayload)))),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr:         false,\n\t\t\twantVerifierErr: false,\n\t\t},\n\t\t{\n\t\t\tenv:  &invalid,\n\t\t\tname: \"invalid\",\n\t\t\tit: &models.IntotoV002Schema{\n\t\t\t\tContent: &models.IntotoV002SchemaContent{\n\t\t\t\t\tEnvelope: createRekorEnvelope(&invalid, [][]byte{pub}),\n\t\t\t\t\tHash: &models.IntotoV002SchemaContentHash{\n\t\t\t\t\t\tAlgorithm: swag.String(models.IntotoV002SchemaContentHashAlgorithmSha256),\n\t\t\t\t\t\tValue:     swag.String(envelopeHash(t, &invalid)),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr:         true,\n\t\t\twantVerifierErr: false,\n\t\t},\n\t\t{\n\t\t\tenv:  envelope(t, key, []byte(validPayload)),\n\t\t\tname: \"invalid key\",\n\t\t\tit: &models.IntotoV002Schema{\n\t\t\t\tContent: &models.IntotoV002SchemaContent{\n\t\t\t\t\tEnvelope: createRekorEnvelope(envelope(t, key, []byte(validPayload)), [][]byte{[]byte(\"notavalidkey\")}),\n\t\t\t\t\tHash: &models.IntotoV002SchemaContentHash{\n\t\t\t\t\t\tAlgorithm: swag.String(models.IntotoV002SchemaContentHashAlgorithmSha256),\n\t\t\t\t\t\tValue:     swag.String(envelopeHash(t, envelope(t, key, []byte(validPayload)))),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr:         true,\n\t\t\twantVerifierErr: true,\n\t\t},\n\t\t{\n\t\t\tenv:  multiSignEnvelope(t, []*ecdsa.PrivateKey{key, priv}, []byte(validPayload)),\n\t\t\tname: \"multi-key\",\n\t\t\tit: &models.IntotoV002Schema{\n\t\t\t\tContent: &models.IntotoV002SchemaContent{\n\t\t\t\t\tEnvelope: createRekorEnvelope(multiSignEnvelope(t, []*ecdsa.PrivateKey{key, priv}, []byte(validPayload)), [][]byte{pub, pemBytes}),\n\t\t\t\t\tHash: &models.IntotoV002SchemaContentHash{\n\t\t\t\t\t\tAlgorithm: swag.String(models.IntotoV002SchemaContentHashAlgorithmSha256),\n\t\t\t\t\t\tValue:     swag.String(envelopeHash(t, multiSignEnvelope(t, []*ecdsa.PrivateKey{key, priv}, []byte(validPayload)))),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr:         false,\n\t\t\twantVerifierErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tv := &V002Entry{}\n\n\t\t\tit := &models.Intoto{\n\t\t\t\tSpec: tt.it,\n\t\t\t}\n\n\t\t\tvar uv = func() error {\n\t\t\t\tif err := v.Unmarshal(it); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\n\t\t\t\tif !tt.wantErr {\n\t\t\t\t\tif ok, err := v.Insertable(); !ok || err != nil {\n\t\t\t\t\t\tt.Errorf(\"unexpected error calling insertable on valid proposed entry: %v\", err)\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\twant := []string{}\n\t\t\t\tfor _, sig := range v.IntotoObj.Content.Envelope.Signatures {\n\t\t\t\t\tkeyHash := sha256.Sum256(sig.PublicKey)\n\t\t\t\t\twant = append(want, \"sha256:\"+hex.EncodeToString(keyHash[:]))\n\t\t\t\t}\n\t\t\t\tdecodedPayload, err := base64.StdEncoding.DecodeString(tt.env.Payload)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn fmt.Errorf(\"could not decode envelope payload: %w\", err)\n\t\t\t\t}\n\t\t\t\th := sha256.Sum256(decodedPayload)\n\t\t\t\twant = append(want, \"sha256:\"+hex.EncodeToString(h[:]))\n\n\t\t\t\tif !reflect.DeepEqual(v.AttestationKey(), \"sha256:\"+hex.EncodeToString(h[:])) {\n\t\t\t\t\tt.Errorf(\"V002Entry.AttestationKey() = %v, want %v\", v.AttestationKey(), \"sha256:\"+hex.EncodeToString(h[:]))\n\t\t\t\t}\n\n\t\t\t\tgot, _ := v.IndexKeys()\n\t\t\t\tsort.Strings(got)\n\t\t\t\tsort.Strings(want)\n\t\t\t\tif !reflect.DeepEqual(got, want) {\n\t\t\t\t\tt.Errorf(\"V002Entry.IndexKeys() = %v, want %v\", got, want)\n\t\t\t\t}\n\t\t\t\tpayloadBytes, _ := v.env.DecodeB64Payload()\n\t\t\t\tpayloadSha := sha256.Sum256(payloadBytes)\n\t\t\t\tpayloadHash := hex.EncodeToString(payloadSha[:])\n\n\t\t\t\tcanonicalBytes, err := v.Canonicalize(context.Background())\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Errorf(\"error canonicalizing entry: %v\", err)\n\t\t\t\t}\n\n\t\t\t\tpe, err := models.UnmarshalProposedEntry(bytes.NewReader(canonicalBytes), runtime.JSONConsumer())\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Errorf(\"unexpected err from Unmarshalling canonicalized entry for '%v': %v\", tt.name, err)\n\t\t\t\t}\n\t\t\t\tcanonicalEntry, err := types.UnmarshalEntry(pe)\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Errorf(\"unexpected err from type-specific unmarshalling for '%v': %v\", tt.name, err)\n\t\t\t\t}\n\t\t\t\tif ok, err := canonicalEntry.Insertable(); ok || err == nil {\n\t\t\t\t\tt.Errorf(\"unexpected success calling Insertable on entry created from canonicalized content\")\n\t\t\t\t}\n\t\t\t\tcanonicalV002 := canonicalEntry.(*V002Entry)\n\t\t\t\tfmt.Printf(\"%v\", canonicalV002.IntotoObj.Content)\n\t\t\t\tif *canonicalV002.IntotoObj.Content.Hash.Value != *tt.it.Content.Hash.Value {\n\t\t\t\t\tt.Errorf(\"envelope hashes do not match post canonicalization: %v %v\", *canonicalV002.IntotoObj.Content.Hash.Value, *tt.it.Content.Hash.Value)\n\t\t\t\t}\n\t\t\t\tif canonicalV002.AttestationKey() != \"\" && *canonicalV002.IntotoObj.Content.PayloadHash.Value != payloadHash {\n\t\t\t\t\tt.Errorf(\"payload hashes do not match post canonicalization: %v %v\", canonicalV002.IntotoObj.Content.PayloadHash.Value, payloadHash)\n\t\t\t\t}\n\t\t\t\tcanonicalIndexKeys, _ := canonicalV002.IndexKeys()\n\t\t\t\tif !cmp.Equal(got, canonicalIndexKeys, cmpopts.SortSlices(func(x, y string) bool { return x < y })) {\n\t\t\t\t\tt.Errorf(\"index keys from hydrated object do not match those generated from canonicalized (and re-hydrated) object: %v %v\", got, canonicalIndexKeys)\n\t\t\t\t}\n\n\t\t\t\tverifier, err := v.Verifier()\n\t\t\t\tif !tt.wantVerifierErr {\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\tt.Errorf(\"%v: unexpected error, got %v\", tt.name, err)\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpubV, _ := verifier.CanonicalValue()\n\t\t\t\t\t\tif !reflect.DeepEqual(pubV, pub) && !reflect.DeepEqual(pubV, pemBytes) {\n\t\t\t\t\t\t\tt.Errorf(\"verifier and public keys do not match: %v, %v\", string(pubV), string(pub))\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif err == nil {\n\t\t\t\t\t\ts, _ := verifier.CanonicalValue()\n\t\t\t\t\t\tt.Errorf(\"%v: expected error for %v, got %v\", tt.name, string(s), err)\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\tif err := uv(); (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"V002Entry.Unmarshal() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestV002Entry_IndexKeys(t *testing.T) {\n\tkey, err := ecdsa.GenerateKey(elliptic.P256(), rand.Reader)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tder, err := x509.MarshalPKIXPublicKey(&key.PublicKey)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tpub := pem.EncodeToMemory(&pem.Block{\n\t\tBytes: der,\n\t\tType:  \"PUBLIC KEY\",\n\t})\n\n\ttests := []struct {\n\t\tname      string\n\t\tstatement in_toto.Statement\n\t\twant      []string\n\t}{\n\t\t{\n\t\t\tname: \"standard\",\n\t\t\twant: []string{},\n\t\t\tstatement: in_toto.Statement{\n\t\t\t\tPredicate: \"hello\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"subject\",\n\t\t\twant: []string{\"sha256:foo\"},\n\t\t\tstatement: in_toto.Statement{\n\t\t\t\tStatementHeader: in_toto.StatementHeader{\n\t\t\t\t\tSubject: []in_toto.Subject{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tName: \"foo\",\n\t\t\t\t\t\t\tDigest: map[string]string{\n\t\t\t\t\t\t\t\t\"sha256\": \"foo\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tPredicate: \"hello\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"slsa\",\n\t\t\twant: []string{\"sha256:bar\"},\n\t\t\tstatement: in_toto.Statement{\n\t\t\t\tPredicate: slsa.ProvenancePredicate{\n\t\t\t\t\tMaterials: []common.ProvenanceMaterial{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tURI: \"foo\",\n\t\t\t\t\t\t\tDigest: map[string]string{\n\t\t\t\t\t\t\t\t\"sha256\": \"bar\",\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"slsa wit header\",\n\t\t\twant: []string{\"sha256:foo\", \"sha256:bar\"},\n\t\t\tstatement: in_toto.Statement{\n\t\t\t\tStatementHeader: in_toto.StatementHeader{\n\t\t\t\t\tSubject: []in_toto.Subject{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tName: \"foo\",\n\t\t\t\t\t\t\tDigest: map[string]string{\n\t\t\t\t\t\t\t\t\"sha256\": \"foo\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tPredicate: slsa.ProvenancePredicate{\n\t\t\t\t\tMaterials: []common.ProvenanceMaterial{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tURI: \"foo\",\n\t\t\t\t\t\t\tDigest: map[string]string{\n\t\t\t\t\t\t\t\t\"sha256\": \"bar\",\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tb, err := json.Marshal(tt.statement)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tpayloadHash := sha256.Sum256(b)\n\t\t\tv := V002Entry{\n\t\t\t\tIntotoObj: models.IntotoV002Schema{\n\t\t\t\t\tContent: &models.IntotoV002SchemaContent{\n\t\t\t\t\t\tEnvelope: createRekorEnvelope(envelope(t, key, b), [][]byte{pub}),\n\t\t\t\t\t\tHash: &models.IntotoV002SchemaContentHash{\n\t\t\t\t\t\t\tAlgorithm: swag.String(models.IntotoV001SchemaContentHashAlgorithmSha256),\n\t\t\t\t\t\t\tValue:     swag.String(envelopeHash(t, envelope(t, key, b))),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tPayloadHash: &models.IntotoV002SchemaContentPayloadHash{\n\t\t\t\t\t\t\tAlgorithm: swag.String(models.IntotoV001SchemaContentHashAlgorithmSha256),\n\t\t\t\t\t\t\tValue:     swag.String(hex.EncodeToString(payloadHash[:])),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tenv: *envelope(t, key, b),\n\t\t\t}\n\t\t\twant := []string{}\n\t\t\tfor _, sig := range v.IntotoObj.Content.Envelope.Signatures {\n\t\t\t\tkeyHash := sha256.Sum256(sig.PublicKey)\n\t\t\t\twant = append(want, \"sha256:\"+hex.EncodeToString(keyHash[:]))\n\t\t\t}\n\n\t\t\twant = append(want, \"sha256:\"+hex.EncodeToString(payloadHash[:]))\n\n\t\t\twant = append(want, tt.want...)\n\t\t\tgot, _ := v.IndexKeys()\n\t\t\tsort.Strings(got)\n\t\t\tsort.Strings(want)\n\t\t\tif !cmp.Equal(got, want) {\n\t\t\t\tt.Errorf(\"V001Entry.IndexKeys() = %v, want %v\", got, want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestInsertable(t *testing.T) {\n\ttype TestCase struct {\n\t\tcaseDesc      string\n\t\tentry         V002Entry\n\t\texpectSuccess bool\n\t}\n\n\tkey, err := ecdsa.GenerateKey(elliptic.P256(), rand.Reader)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tenv := envelope(t, key, []byte(\"payload\"))\n\n\ttestCases := []TestCase{\n\t\t{\n\t\t\tcaseDesc: \"valid entry\",\n\t\t\tentry: V002Entry{\n\t\t\t\tIntotoObj: models.IntotoV002Schema{\n\t\t\t\t\tContent: &models.IntotoV002SchemaContent{\n\t\t\t\t\t\tEnvelope: &models.IntotoV002SchemaContentEnvelope{\n\t\t\t\t\t\t\tPayload:     strfmt.Base64(\"payload\"),\n\t\t\t\t\t\t\tPayloadType: swag.String(\"payloadType\"),\n\t\t\t\t\t\t\tSignatures: []*models.IntotoV002SchemaContentEnvelopeSignaturesItems0{\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tPublicKey: strfmt.Base64([]byte(\"key\")),\n\t\t\t\t\t\t\t\t\tSig:       strfmt.Base64([]byte(\"sig\")),\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tenv: *env,\n\t\t\t},\n\t\t\texpectSuccess: true,\n\t\t},\n\t\t{\n\t\t\tcaseDesc: \"valid entry but hasn't been parsed\",\n\t\t\tentry: V002Entry{\n\t\t\t\tIntotoObj: models.IntotoV002Schema{\n\t\t\t\t\tContent: &models.IntotoV002SchemaContent{\n\t\t\t\t\t\tEnvelope: &models.IntotoV002SchemaContentEnvelope{\n\t\t\t\t\t\t\tPayload:     strfmt.Base64(\"payload\"),\n\t\t\t\t\t\t\tPayloadType: swag.String(\"payloadType\"),\n\t\t\t\t\t\t\tSignatures: []*models.IntotoV002SchemaContentEnvelopeSignaturesItems0{\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tPublicKey: strfmt.Base64([]byte(\"key\")),\n\t\t\t\t\t\t\t\t\tSig:       strfmt.Base64([]byte(\"sig\")),\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tenv: dsse.Envelope{},\n\t\t\t},\n\t\t\texpectSuccess: false,\n\t\t},\n\t\t{\n\t\t\tcaseDesc: \"missing sig\",\n\t\t\tentry: V002Entry{\n\t\t\t\tIntotoObj: models.IntotoV002Schema{\n\t\t\t\t\tContent: &models.IntotoV002SchemaContent{\n\t\t\t\t\t\tEnvelope: &models.IntotoV002SchemaContentEnvelope{\n\t\t\t\t\t\t\tPayload:     strfmt.Base64(\"payload\"),\n\t\t\t\t\t\t\tPayloadType: swag.String(\"payloadType\"),\n\t\t\t\t\t\t\tSignatures: []*models.IntotoV002SchemaContentEnvelopeSignaturesItems0{\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tPublicKey: strfmt.Base64([]byte(\"key\")),\n\t\t\t\t\t\t\t\t\t//Sig:       strfmt.Base64([]byte(\"sig\")),\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tenv: *env,\n\t\t\t},\n\t\t\texpectSuccess: false,\n\t\t},\n\t\t{\n\t\t\tcaseDesc: \"missing key\",\n\t\t\tentry: V002Entry{\n\t\t\t\tIntotoObj: models.IntotoV002Schema{\n\t\t\t\t\tContent: &models.IntotoV002SchemaContent{\n\t\t\t\t\t\tEnvelope: &models.IntotoV002SchemaContentEnvelope{\n\t\t\t\t\t\t\tPayload:     strfmt.Base64(\"payload\"),\n\t\t\t\t\t\t\tPayloadType: swag.String(\"payloadType\"),\n\t\t\t\t\t\t\tSignatures: []*models.IntotoV002SchemaContentEnvelopeSignaturesItems0{\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t//PublicKey: strfmt.Base64([]byte(\"key\")),\n\t\t\t\t\t\t\t\t\tSig: strfmt.Base64([]byte(\"sig\")),\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tenv: *env,\n\t\t\t},\n\t\t\texpectSuccess: false,\n\t\t},\n\t\t{\n\t\t\tcaseDesc: \"empty signatures\",\n\t\t\tentry: V002Entry{\n\t\t\t\tIntotoObj: models.IntotoV002Schema{\n\t\t\t\t\tContent: &models.IntotoV002SchemaContent{\n\t\t\t\t\t\tEnvelope: &models.IntotoV002SchemaContentEnvelope{\n\t\t\t\t\t\t\tPayload:     strfmt.Base64(\"payload\"),\n\t\t\t\t\t\t\tPayloadType: swag.String(\"payloadType\"),\n\t\t\t\t\t\t\tSignatures:  []*models.IntotoV002SchemaContentEnvelopeSignaturesItems0{},\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t\tSignatures: []*models.IntotoV002SchemaContentEnvelopeSignaturesItems0{\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tPublicKey: strfmt.Base64([]byte(\"key\")),\n\t\t\t\t\t\t\t\t\t\tSig:       strfmt.Base64([]byte(\"sig\")),\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t*/\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tenv: *env,\n\t\t\t},\n\t\t\texpectSuccess: false,\n\t\t},\n\t\t{\n\t\t\tcaseDesc: \"missing payloadType\",\n\t\t\tentry: V002Entry{\n\t\t\t\tIntotoObj: models.IntotoV002Schema{\n\t\t\t\t\tContent: &models.IntotoV002SchemaContent{\n\t\t\t\t\t\tEnvelope: &models.IntotoV002SchemaContentEnvelope{\n\t\t\t\t\t\t\tPayload: strfmt.Base64(\"payload\"),\n\t\t\t\t\t\t\t//PayloadType: swag.String(\"payloadType\"),\n\t\t\t\t\t\t\tSignatures: []*models.IntotoV002SchemaContentEnvelopeSignaturesItems0{\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tPublicKey: strfmt.Base64([]byte(\"key\")),\n\t\t\t\t\t\t\t\t\tSig:       strfmt.Base64([]byte(\"sig\")),\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tenv: *env,\n\t\t\t},\n\t\t\texpectSuccess: false,\n\t\t},\n\t\t{\n\t\t\tcaseDesc: \"missing payload\",\n\t\t\tentry: V002Entry{\n\t\t\t\tIntotoObj: models.IntotoV002Schema{\n\t\t\t\t\tContent: &models.IntotoV002SchemaContent{\n\t\t\t\t\t\tEnvelope: &models.IntotoV002SchemaContentEnvelope{\n\t\t\t\t\t\t\t//Payload:     strfmt.Base64(\"payload\"),\n\t\t\t\t\t\t\tPayloadType: swag.String(\"payloadType\"),\n\t\t\t\t\t\t\tSignatures: []*models.IntotoV002SchemaContentEnvelopeSignaturesItems0{\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tPublicKey: strfmt.Base64([]byte(\"key\")),\n\t\t\t\t\t\t\t\t\tSig:       strfmt.Base64([]byte(\"sig\")),\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tenv: *env,\n\t\t\t},\n\t\t\texpectSuccess: false,\n\t\t},\n\t\t{\n\t\t\tcaseDesc: \"missing envelope\",\n\t\t\tentry: V002Entry{\n\t\t\t\tIntotoObj: models.IntotoV002Schema{\n\t\t\t\t\tContent: &models.IntotoV002SchemaContent{\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t\tEnvelope: &models.IntotoV002SchemaContentEnvelope{\n\t\t\t\t\t\t\t\tPayload:     strfmt.Base64(\"payload\"),\n\t\t\t\t\t\t\t\tPayloadType: swag.String(\"payloadType\"),\n\t\t\t\t\t\t\t\tSignatures: []*models.IntotoV002SchemaContentEnvelopeSignaturesItems0{\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tPublicKey: strfmt.Base64([]byte(\"key\")),\n\t\t\t\t\t\t\t\t\t\tSig:       strfmt.Base64([]byte(\"sig\")),\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t*/\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tenv: *env,\n\t\t\t},\n\t\t\texpectSuccess: false,\n\t\t},\n\t\t{\n\t\t\tcaseDesc: \"missing content\",\n\t\t\tentry: V002Entry{\n\t\t\t\tIntotoObj: models.IntotoV002Schema{\n\t\t\t\t\t/*\n\t\t\t\t\t\tContent: &models.IntotoV002SchemaContent{\n\t\t\t\t\t\t\tEnvelope: &models.IntotoV002SchemaContentEnvelope{\n\t\t\t\t\t\t\t\tPayload:     strfmt.Base64(\"payload\"),\n\t\t\t\t\t\t\t\tPayloadType: swag.String(\"payloadType\"),\n\t\t\t\t\t\t\t\tSignatures: []*models.IntotoV002SchemaContentEnvelopeSignaturesItems0{\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tPublicKey: strfmt.Base64([]byte(\"key\")),\n\t\t\t\t\t\t\t\t\t\tSig:       strfmt.Base64([]byte(\"sig\")),\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t*/\n\t\t\t\t},\n\t\t\t\tenv: *env,\n\t\t\t},\n\t\t\texpectSuccess: false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.caseDesc, func(t *testing.T) {\n\t\t\tif ok, err := tc.entry.Insertable(); ok != tc.expectSuccess {\n\t\t\t\tt.Errorf(\"unexpected result calling Insertable: %v\", err)\n\t\t\t}\n\t\t})\n\t}\n}\n", "{\n    \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n    \"$id\": \"http://rekor.sigstore.dev/types/intoto/intoto_v0_0_2_schema.json\",\n    \"title\": \"intoto v0.0.2 Schema\",\n    \"description\": \"Schema for intoto object\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"content\": {\n            \"type\": \"object\",\n            \"properties\": {\n                \"envelope\": {\n                    \"description\": \"dsse envelope\",\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"payload\": {\n                            \"description\": \"payload of the envelope\",\n                            \"type\": \"string\",\n                            \"format\": \"byte\",\n                            \"writeOnly\": true\n                        },\n                        \"payloadType\": {\n                            \"description\": \"type describing the payload\",\n                            \"type\": \"string\"\n                        },\n                        \"signatures\": {\n                            \"description\": \"collection of all signatures of the envelope's payload\",\n                            \"type\": \"array\",\n                            \"minItems\": 1,\n                            \"items\": {\n                                \"description\": \"a signature of the envelope's payload along with the public key for the signature\",\n                                \"type\": \"object\",\n                                \"properties\": {\n                                    \"keyid\": {\n                                        \"description\": \"optional id of the key used to create the signature\",\n                                        \"type\": \"string\"\n                                    },\n                                    \"sig\": {\n                                        \"description\": \"signature of the payload\",\n                                        \"type\": \"string\",\n                                        \"format\": \"byte\"\n                                    },\n                                    \"publicKey\": {\n                                        \"description\": \"public key that corresponds to this signature\",\n                                        \"type\": \"string\",\n                                        \"format\": \"byte\"\n                                    }\n                                }\n                            }\n                        }\n                    },\n                    \"required\": [\"payloadType\", \"signatures\"]\n                },\n                \"hash\": {\n                    \"description\": \"Specifies the hash algorithm and value encompassing the entire signed envelope\",\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"algorithm\": {\n                            \"description\": \"The hashing function used to compute the hash value\",\n                            \"type\": \"string\",\n                            \"enum\": [\n                                \"sha256\"\n                            ]\n                        },\n                        \"value\": {\n                            \"description\": \"The hash value for the archive\",\n                            \"type\": \"string\"\n                        }\n                    },\n                    \"required\": [\n                        \"algorithm\",\n                        \"value\"\n                    ],\n                    \"readOnly\": true\n                },\n                \"payloadHash\": {\n                    \"description\": \"Specifies the hash algorithm and value covering the payload within the DSSE envelope\",\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"algorithm\": {\n                            \"description\": \"The hashing function used to compute the hash value\",\n                            \"type\": \"string\",\n                            \"enum\": [ \"sha256\" ]\n                        },\n                        \"value\": {\n                            \"description\": \"The hash value of the payload\",\n                            \"type\": \"string\"\n                        }\n                    },\n                    \"required\": [\n                        \"algorithm\",\n                        \"value\"\n                    ],\n                    \"readOnly\": true\n                }\n            },\n            \"required\": [\n                \"envelope\"\n            ]\n        }\n    },\n    \"required\": [\n        \"content\"\n    ]\n}\n"], "fixing_code": ["// Code generated by go-swagger; DO NOT EDIT.\n\n//\n// Copyright 2021 The Sigstore Authors.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage models\n\n// This file was generated by the swagger tool.\n// Editing this file might prove futile when you re-run the swagger generate command\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"strconv\"\n\n\t\"github.com/go-openapi/errors\"\n\t\"github.com/go-openapi/strfmt\"\n\t\"github.com/go-openapi/swag\"\n\t\"github.com/go-openapi/validate\"\n)\n\n// IntotoV002Schema intoto v0.0.2 Schema\n//\n// # Schema for intoto object\n//\n// swagger:model intotoV002Schema\ntype IntotoV002Schema struct {\n\n\t// content\n\t// Required: true\n\tContent *IntotoV002SchemaContent `json:\"content\"`\n}\n\n// Validate validates this intoto v002 schema\nfunc (m *IntotoV002Schema) Validate(formats strfmt.Registry) error {\n\tvar res []error\n\n\tif err := m.validateContent(formats); err != nil {\n\t\tres = append(res, err)\n\t}\n\n\tif len(res) > 0 {\n\t\treturn errors.CompositeValidationError(res...)\n\t}\n\treturn nil\n}\n\nfunc (m *IntotoV002Schema) validateContent(formats strfmt.Registry) error {\n\n\tif err := validate.Required(\"content\", \"body\", m.Content); err != nil {\n\t\treturn err\n\t}\n\n\tif m.Content != nil {\n\t\tif err := m.Content.Validate(formats); err != nil {\n\t\t\tif ve, ok := err.(*errors.Validation); ok {\n\t\t\t\treturn ve.ValidateName(\"content\")\n\t\t\t} else if ce, ok := err.(*errors.CompositeError); ok {\n\t\t\t\treturn ce.ValidateName(\"content\")\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// ContextValidate validate this intoto v002 schema based on the context it is used\nfunc (m *IntotoV002Schema) ContextValidate(ctx context.Context, formats strfmt.Registry) error {\n\tvar res []error\n\n\tif err := m.contextValidateContent(ctx, formats); err != nil {\n\t\tres = append(res, err)\n\t}\n\n\tif len(res) > 0 {\n\t\treturn errors.CompositeValidationError(res...)\n\t}\n\treturn nil\n}\n\nfunc (m *IntotoV002Schema) contextValidateContent(ctx context.Context, formats strfmt.Registry) error {\n\n\tif m.Content != nil {\n\t\tif err := m.Content.ContextValidate(ctx, formats); err != nil {\n\t\t\tif ve, ok := err.(*errors.Validation); ok {\n\t\t\t\treturn ve.ValidateName(\"content\")\n\t\t\t} else if ce, ok := err.(*errors.CompositeError); ok {\n\t\t\t\treturn ce.ValidateName(\"content\")\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// MarshalBinary interface implementation\nfunc (m *IntotoV002Schema) MarshalBinary() ([]byte, error) {\n\tif m == nil {\n\t\treturn nil, nil\n\t}\n\treturn swag.WriteJSON(m)\n}\n\n// UnmarshalBinary interface implementation\nfunc (m *IntotoV002Schema) UnmarshalBinary(b []byte) error {\n\tvar res IntotoV002Schema\n\tif err := swag.ReadJSON(b, &res); err != nil {\n\t\treturn err\n\t}\n\t*m = res\n\treturn nil\n}\n\n// IntotoV002SchemaContent intoto v002 schema content\n//\n// swagger:model IntotoV002SchemaContent\ntype IntotoV002SchemaContent struct {\n\n\t// envelope\n\t// Required: true\n\tEnvelope *IntotoV002SchemaContentEnvelope `json:\"envelope\"`\n\n\t// hash\n\tHash *IntotoV002SchemaContentHash `json:\"hash,omitempty\"`\n\n\t// payload hash\n\tPayloadHash *IntotoV002SchemaContentPayloadHash `json:\"payloadHash,omitempty\"`\n}\n\n// Validate validates this intoto v002 schema content\nfunc (m *IntotoV002SchemaContent) Validate(formats strfmt.Registry) error {\n\tvar res []error\n\n\tif err := m.validateEnvelope(formats); err != nil {\n\t\tres = append(res, err)\n\t}\n\n\tif err := m.validateHash(formats); err != nil {\n\t\tres = append(res, err)\n\t}\n\n\tif err := m.validatePayloadHash(formats); err != nil {\n\t\tres = append(res, err)\n\t}\n\n\tif len(res) > 0 {\n\t\treturn errors.CompositeValidationError(res...)\n\t}\n\treturn nil\n}\n\nfunc (m *IntotoV002SchemaContent) validateEnvelope(formats strfmt.Registry) error {\n\n\tif err := validate.Required(\"content\"+\".\"+\"envelope\", \"body\", m.Envelope); err != nil {\n\t\treturn err\n\t}\n\n\tif m.Envelope != nil {\n\t\tif err := m.Envelope.Validate(formats); err != nil {\n\t\t\tif ve, ok := err.(*errors.Validation); ok {\n\t\t\t\treturn ve.ValidateName(\"content\" + \".\" + \"envelope\")\n\t\t\t} else if ce, ok := err.(*errors.CompositeError); ok {\n\t\t\t\treturn ce.ValidateName(\"content\" + \".\" + \"envelope\")\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc (m *IntotoV002SchemaContent) validateHash(formats strfmt.Registry) error {\n\tif swag.IsZero(m.Hash) { // not required\n\t\treturn nil\n\t}\n\n\tif m.Hash != nil {\n\t\tif err := m.Hash.Validate(formats); err != nil {\n\t\t\tif ve, ok := err.(*errors.Validation); ok {\n\t\t\t\treturn ve.ValidateName(\"content\" + \".\" + \"hash\")\n\t\t\t} else if ce, ok := err.(*errors.CompositeError); ok {\n\t\t\t\treturn ce.ValidateName(\"content\" + \".\" + \"hash\")\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc (m *IntotoV002SchemaContent) validatePayloadHash(formats strfmt.Registry) error {\n\tif swag.IsZero(m.PayloadHash) { // not required\n\t\treturn nil\n\t}\n\n\tif m.PayloadHash != nil {\n\t\tif err := m.PayloadHash.Validate(formats); err != nil {\n\t\t\tif ve, ok := err.(*errors.Validation); ok {\n\t\t\t\treturn ve.ValidateName(\"content\" + \".\" + \"payloadHash\")\n\t\t\t} else if ce, ok := err.(*errors.CompositeError); ok {\n\t\t\t\treturn ce.ValidateName(\"content\" + \".\" + \"payloadHash\")\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// ContextValidate validate this intoto v002 schema content based on the context it is used\nfunc (m *IntotoV002SchemaContent) ContextValidate(ctx context.Context, formats strfmt.Registry) error {\n\tvar res []error\n\n\tif err := m.contextValidateEnvelope(ctx, formats); err != nil {\n\t\tres = append(res, err)\n\t}\n\n\tif err := m.contextValidateHash(ctx, formats); err != nil {\n\t\tres = append(res, err)\n\t}\n\n\tif err := m.contextValidatePayloadHash(ctx, formats); err != nil {\n\t\tres = append(res, err)\n\t}\n\n\tif len(res) > 0 {\n\t\treturn errors.CompositeValidationError(res...)\n\t}\n\treturn nil\n}\n\nfunc (m *IntotoV002SchemaContent) contextValidateEnvelope(ctx context.Context, formats strfmt.Registry) error {\n\n\tif m.Envelope != nil {\n\t\tif err := m.Envelope.ContextValidate(ctx, formats); err != nil {\n\t\t\tif ve, ok := err.(*errors.Validation); ok {\n\t\t\t\treturn ve.ValidateName(\"content\" + \".\" + \"envelope\")\n\t\t\t} else if ce, ok := err.(*errors.CompositeError); ok {\n\t\t\t\treturn ce.ValidateName(\"content\" + \".\" + \"envelope\")\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc (m *IntotoV002SchemaContent) contextValidateHash(ctx context.Context, formats strfmt.Registry) error {\n\n\tif m.Hash != nil {\n\t\tif err := m.Hash.ContextValidate(ctx, formats); err != nil {\n\t\t\tif ve, ok := err.(*errors.Validation); ok {\n\t\t\t\treturn ve.ValidateName(\"content\" + \".\" + \"hash\")\n\t\t\t} else if ce, ok := err.(*errors.CompositeError); ok {\n\t\t\t\treturn ce.ValidateName(\"content\" + \".\" + \"hash\")\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc (m *IntotoV002SchemaContent) contextValidatePayloadHash(ctx context.Context, formats strfmt.Registry) error {\n\n\tif m.PayloadHash != nil {\n\t\tif err := m.PayloadHash.ContextValidate(ctx, formats); err != nil {\n\t\t\tif ve, ok := err.(*errors.Validation); ok {\n\t\t\t\treturn ve.ValidateName(\"content\" + \".\" + \"payloadHash\")\n\t\t\t} else if ce, ok := err.(*errors.CompositeError); ok {\n\t\t\t\treturn ce.ValidateName(\"content\" + \".\" + \"payloadHash\")\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// MarshalBinary interface implementation\nfunc (m *IntotoV002SchemaContent) MarshalBinary() ([]byte, error) {\n\tif m == nil {\n\t\treturn nil, nil\n\t}\n\treturn swag.WriteJSON(m)\n}\n\n// UnmarshalBinary interface implementation\nfunc (m *IntotoV002SchemaContent) UnmarshalBinary(b []byte) error {\n\tvar res IntotoV002SchemaContent\n\tif err := swag.ReadJSON(b, &res); err != nil {\n\t\treturn err\n\t}\n\t*m = res\n\treturn nil\n}\n\n// IntotoV002SchemaContentEnvelope dsse envelope\n//\n// swagger:model IntotoV002SchemaContentEnvelope\ntype IntotoV002SchemaContentEnvelope struct {\n\n\t// payload of the envelope\n\t// Format: byte\n\tPayload strfmt.Base64 `json:\"payload,omitempty\"`\n\n\t// type describing the payload\n\t// Required: true\n\tPayloadType *string `json:\"payloadType\"`\n\n\t// collection of all signatures of the envelope's payload\n\t// Required: true\n\t// Min Items: 1\n\tSignatures []*IntotoV002SchemaContentEnvelopeSignaturesItems0 `json:\"signatures\"`\n}\n\n// Validate validates this intoto v002 schema content envelope\nfunc (m *IntotoV002SchemaContentEnvelope) Validate(formats strfmt.Registry) error {\n\tvar res []error\n\n\tif err := m.validatePayloadType(formats); err != nil {\n\t\tres = append(res, err)\n\t}\n\n\tif err := m.validateSignatures(formats); err != nil {\n\t\tres = append(res, err)\n\t}\n\n\tif len(res) > 0 {\n\t\treturn errors.CompositeValidationError(res...)\n\t}\n\treturn nil\n}\n\nfunc (m *IntotoV002SchemaContentEnvelope) validatePayloadType(formats strfmt.Registry) error {\n\n\tif err := validate.Required(\"content\"+\".\"+\"envelope\"+\".\"+\"payloadType\", \"body\", m.PayloadType); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc (m *IntotoV002SchemaContentEnvelope) validateSignatures(formats strfmt.Registry) error {\n\n\tif err := validate.Required(\"content\"+\".\"+\"envelope\"+\".\"+\"signatures\", \"body\", m.Signatures); err != nil {\n\t\treturn err\n\t}\n\n\tiSignaturesSize := int64(len(m.Signatures))\n\n\tif err := validate.MinItems(\"content\"+\".\"+\"envelope\"+\".\"+\"signatures\", \"body\", iSignaturesSize, 1); err != nil {\n\t\treturn err\n\t}\n\n\tfor i := 0; i < len(m.Signatures); i++ {\n\t\tif swag.IsZero(m.Signatures[i]) { // not required\n\t\t\tcontinue\n\t\t}\n\n\t\tif m.Signatures[i] != nil {\n\t\t\tif err := m.Signatures[i].Validate(formats); err != nil {\n\t\t\t\tif ve, ok := err.(*errors.Validation); ok {\n\t\t\t\t\treturn ve.ValidateName(\"content\" + \".\" + \"envelope\" + \".\" + \"signatures\" + \".\" + strconv.Itoa(i))\n\t\t\t\t} else if ce, ok := err.(*errors.CompositeError); ok {\n\t\t\t\t\treturn ce.ValidateName(\"content\" + \".\" + \"envelope\" + \".\" + \"signatures\" + \".\" + strconv.Itoa(i))\n\t\t\t\t}\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\n\t}\n\n\treturn nil\n}\n\n// ContextValidate validate this intoto v002 schema content envelope based on the context it is used\nfunc (m *IntotoV002SchemaContentEnvelope) ContextValidate(ctx context.Context, formats strfmt.Registry) error {\n\tvar res []error\n\n\tif err := m.contextValidateSignatures(ctx, formats); err != nil {\n\t\tres = append(res, err)\n\t}\n\n\tif len(res) > 0 {\n\t\treturn errors.CompositeValidationError(res...)\n\t}\n\treturn nil\n}\n\nfunc (m *IntotoV002SchemaContentEnvelope) contextValidateSignatures(ctx context.Context, formats strfmt.Registry) error {\n\n\tfor i := 0; i < len(m.Signatures); i++ {\n\n\t\tif m.Signatures[i] != nil {\n\t\t\tif err := m.Signatures[i].ContextValidate(ctx, formats); err != nil {\n\t\t\t\tif ve, ok := err.(*errors.Validation); ok {\n\t\t\t\t\treturn ve.ValidateName(\"content\" + \".\" + \"envelope\" + \".\" + \"signatures\" + \".\" + strconv.Itoa(i))\n\t\t\t\t} else if ce, ok := err.(*errors.CompositeError); ok {\n\t\t\t\t\treturn ce.ValidateName(\"content\" + \".\" + \"envelope\" + \".\" + \"signatures\" + \".\" + strconv.Itoa(i))\n\t\t\t\t}\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\n\t}\n\n\treturn nil\n}\n\n// MarshalBinary interface implementation\nfunc (m *IntotoV002SchemaContentEnvelope) MarshalBinary() ([]byte, error) {\n\tif m == nil {\n\t\treturn nil, nil\n\t}\n\treturn swag.WriteJSON(m)\n}\n\n// UnmarshalBinary interface implementation\nfunc (m *IntotoV002SchemaContentEnvelope) UnmarshalBinary(b []byte) error {\n\tvar res IntotoV002SchemaContentEnvelope\n\tif err := swag.ReadJSON(b, &res); err != nil {\n\t\treturn err\n\t}\n\t*m = res\n\treturn nil\n}\n\n// IntotoV002SchemaContentEnvelopeSignaturesItems0 a signature of the envelope's payload along with the public key for the signature\n//\n// swagger:model IntotoV002SchemaContentEnvelopeSignaturesItems0\ntype IntotoV002SchemaContentEnvelopeSignaturesItems0 struct {\n\n\t// optional id of the key used to create the signature\n\tKeyid string `json:\"keyid,omitempty\"`\n\n\t// public key that corresponds to this signature\n\t// Required: true\n\t// Format: byte\n\tPublicKey *strfmt.Base64 `json:\"publicKey\"`\n\n\t// signature of the payload\n\t// Required: true\n\t// Format: byte\n\tSig *strfmt.Base64 `json:\"sig\"`\n}\n\n// Validate validates this intoto v002 schema content envelope signatures items0\nfunc (m *IntotoV002SchemaContentEnvelopeSignaturesItems0) Validate(formats strfmt.Registry) error {\n\tvar res []error\n\n\tif err := m.validatePublicKey(formats); err != nil {\n\t\tres = append(res, err)\n\t}\n\n\tif err := m.validateSig(formats); err != nil {\n\t\tres = append(res, err)\n\t}\n\n\tif len(res) > 0 {\n\t\treturn errors.CompositeValidationError(res...)\n\t}\n\treturn nil\n}\n\nfunc (m *IntotoV002SchemaContentEnvelopeSignaturesItems0) validatePublicKey(formats strfmt.Registry) error {\n\n\tif err := validate.Required(\"publicKey\", \"body\", m.PublicKey); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc (m *IntotoV002SchemaContentEnvelopeSignaturesItems0) validateSig(formats strfmt.Registry) error {\n\n\tif err := validate.Required(\"sig\", \"body\", m.Sig); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n// ContextValidate validates this intoto v002 schema content envelope signatures items0 based on context it is used\nfunc (m *IntotoV002SchemaContentEnvelopeSignaturesItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {\n\treturn nil\n}\n\n// MarshalBinary interface implementation\nfunc (m *IntotoV002SchemaContentEnvelopeSignaturesItems0) MarshalBinary() ([]byte, error) {\n\tif m == nil {\n\t\treturn nil, nil\n\t}\n\treturn swag.WriteJSON(m)\n}\n\n// UnmarshalBinary interface implementation\nfunc (m *IntotoV002SchemaContentEnvelopeSignaturesItems0) UnmarshalBinary(b []byte) error {\n\tvar res IntotoV002SchemaContentEnvelopeSignaturesItems0\n\tif err := swag.ReadJSON(b, &res); err != nil {\n\t\treturn err\n\t}\n\t*m = res\n\treturn nil\n}\n\n// IntotoV002SchemaContentHash Specifies the hash algorithm and value encompassing the entire signed envelope\n//\n// swagger:model IntotoV002SchemaContentHash\ntype IntotoV002SchemaContentHash struct {\n\n\t// The hashing function used to compute the hash value\n\t// Required: true\n\t// Enum: [sha256]\n\tAlgorithm *string `json:\"algorithm\"`\n\n\t// The hash value for the archive\n\t// Required: true\n\tValue *string `json:\"value\"`\n}\n\n// Validate validates this intoto v002 schema content hash\nfunc (m *IntotoV002SchemaContentHash) Validate(formats strfmt.Registry) error {\n\tvar res []error\n\n\tif err := m.validateAlgorithm(formats); err != nil {\n\t\tres = append(res, err)\n\t}\n\n\tif err := m.validateValue(formats); err != nil {\n\t\tres = append(res, err)\n\t}\n\n\tif len(res) > 0 {\n\t\treturn errors.CompositeValidationError(res...)\n\t}\n\treturn nil\n}\n\nvar intotoV002SchemaContentHashTypeAlgorithmPropEnum []interface{}\n\nfunc init() {\n\tvar res []string\n\tif err := json.Unmarshal([]byte(`[\"sha256\"]`), &res); err != nil {\n\t\tpanic(err)\n\t}\n\tfor _, v := range res {\n\t\tintotoV002SchemaContentHashTypeAlgorithmPropEnum = append(intotoV002SchemaContentHashTypeAlgorithmPropEnum, v)\n\t}\n}\n\nconst (\n\n\t// IntotoV002SchemaContentHashAlgorithmSha256 captures enum value \"sha256\"\n\tIntotoV002SchemaContentHashAlgorithmSha256 string = \"sha256\"\n)\n\n// prop value enum\nfunc (m *IntotoV002SchemaContentHash) validateAlgorithmEnum(path, location string, value string) error {\n\tif err := validate.EnumCase(path, location, value, intotoV002SchemaContentHashTypeAlgorithmPropEnum, true); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (m *IntotoV002SchemaContentHash) validateAlgorithm(formats strfmt.Registry) error {\n\n\tif err := validate.Required(\"content\"+\".\"+\"hash\"+\".\"+\"algorithm\", \"body\", m.Algorithm); err != nil {\n\t\treturn err\n\t}\n\n\t// value enum\n\tif err := m.validateAlgorithmEnum(\"content\"+\".\"+\"hash\"+\".\"+\"algorithm\", \"body\", *m.Algorithm); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc (m *IntotoV002SchemaContentHash) validateValue(formats strfmt.Registry) error {\n\n\tif err := validate.Required(\"content\"+\".\"+\"hash\"+\".\"+\"value\", \"body\", m.Value); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n// ContextValidate validate this intoto v002 schema content hash based on the context it is used\nfunc (m *IntotoV002SchemaContentHash) ContextValidate(ctx context.Context, formats strfmt.Registry) error {\n\tvar res []error\n\n\tif len(res) > 0 {\n\t\treturn errors.CompositeValidationError(res...)\n\t}\n\treturn nil\n}\n\n// MarshalBinary interface implementation\nfunc (m *IntotoV002SchemaContentHash) MarshalBinary() ([]byte, error) {\n\tif m == nil {\n\t\treturn nil, nil\n\t}\n\treturn swag.WriteJSON(m)\n}\n\n// UnmarshalBinary interface implementation\nfunc (m *IntotoV002SchemaContentHash) UnmarshalBinary(b []byte) error {\n\tvar res IntotoV002SchemaContentHash\n\tif err := swag.ReadJSON(b, &res); err != nil {\n\t\treturn err\n\t}\n\t*m = res\n\treturn nil\n}\n\n// IntotoV002SchemaContentPayloadHash Specifies the hash algorithm and value covering the payload within the DSSE envelope\n//\n// swagger:model IntotoV002SchemaContentPayloadHash\ntype IntotoV002SchemaContentPayloadHash struct {\n\n\t// The hashing function used to compute the hash value\n\t// Required: true\n\t// Enum: [sha256]\n\tAlgorithm *string `json:\"algorithm\"`\n\n\t// The hash value of the payload\n\t// Required: true\n\tValue *string `json:\"value\"`\n}\n\n// Validate validates this intoto v002 schema content payload hash\nfunc (m *IntotoV002SchemaContentPayloadHash) Validate(formats strfmt.Registry) error {\n\tvar res []error\n\n\tif err := m.validateAlgorithm(formats); err != nil {\n\t\tres = append(res, err)\n\t}\n\n\tif err := m.validateValue(formats); err != nil {\n\t\tres = append(res, err)\n\t}\n\n\tif len(res) > 0 {\n\t\treturn errors.CompositeValidationError(res...)\n\t}\n\treturn nil\n}\n\nvar intotoV002SchemaContentPayloadHashTypeAlgorithmPropEnum []interface{}\n\nfunc init() {\n\tvar res []string\n\tif err := json.Unmarshal([]byte(`[\"sha256\"]`), &res); err != nil {\n\t\tpanic(err)\n\t}\n\tfor _, v := range res {\n\t\tintotoV002SchemaContentPayloadHashTypeAlgorithmPropEnum = append(intotoV002SchemaContentPayloadHashTypeAlgorithmPropEnum, v)\n\t}\n}\n\nconst (\n\n\t// IntotoV002SchemaContentPayloadHashAlgorithmSha256 captures enum value \"sha256\"\n\tIntotoV002SchemaContentPayloadHashAlgorithmSha256 string = \"sha256\"\n)\n\n// prop value enum\nfunc (m *IntotoV002SchemaContentPayloadHash) validateAlgorithmEnum(path, location string, value string) error {\n\tif err := validate.EnumCase(path, location, value, intotoV002SchemaContentPayloadHashTypeAlgorithmPropEnum, true); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (m *IntotoV002SchemaContentPayloadHash) validateAlgorithm(formats strfmt.Registry) error {\n\n\tif err := validate.Required(\"content\"+\".\"+\"payloadHash\"+\".\"+\"algorithm\", \"body\", m.Algorithm); err != nil {\n\t\treturn err\n\t}\n\n\t// value enum\n\tif err := m.validateAlgorithmEnum(\"content\"+\".\"+\"payloadHash\"+\".\"+\"algorithm\", \"body\", *m.Algorithm); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc (m *IntotoV002SchemaContentPayloadHash) validateValue(formats strfmt.Registry) error {\n\n\tif err := validate.Required(\"content\"+\".\"+\"payloadHash\"+\".\"+\"value\", \"body\", m.Value); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n// ContextValidate validate this intoto v002 schema content payload hash based on the context it is used\nfunc (m *IntotoV002SchemaContentPayloadHash) ContextValidate(ctx context.Context, formats strfmt.Registry) error {\n\tvar res []error\n\n\tif len(res) > 0 {\n\t\treturn errors.CompositeValidationError(res...)\n\t}\n\treturn nil\n}\n\n// MarshalBinary interface implementation\nfunc (m *IntotoV002SchemaContentPayloadHash) MarshalBinary() ([]byte, error) {\n\tif m == nil {\n\t\treturn nil, nil\n\t}\n\treturn swag.WriteJSON(m)\n}\n\n// UnmarshalBinary interface implementation\nfunc (m *IntotoV002SchemaContentPayloadHash) UnmarshalBinary(b []byte) error {\n\tvar res IntotoV002SchemaContentPayloadHash\n\tif err := swag.ReadJSON(b, &res); err != nil {\n\t\treturn err\n\t}\n\t*m = res\n\treturn nil\n}\n", "// Code generated by go-swagger; DO NOT EDIT.\n\n//\n// Copyright 2021 The Sigstore Authors.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage restapi\n\n// This file was generated by the swagger tool.\n// Editing this file might prove futile when you re-run the swagger generate command\n\nimport (\n\t\"encoding/json\"\n)\n\nvar (\n\t// SwaggerJSON embedded version of the swagger document used at generation time\n\tSwaggerJSON json.RawMessage\n\t// FlatSwaggerJSON embedded flattened version of the swagger document used at generation time\n\tFlatSwaggerJSON json.RawMessage\n)\n\nfunc init() {\n\tSwaggerJSON = json.RawMessage([]byte(`{\n  \"consumes\": [\n    \"application/json\"\n  ],\n  \"produces\": [\n    \"application/json\"\n  ],\n  \"schemes\": [\n    \"http\"\n  ],\n  \"swagger\": \"2.0\",\n  \"info\": {\n    \"description\": \"Rekor is a cryptographically secure, immutable transparency log for signed software releases.\",\n    \"title\": \"Rekor\",\n    \"version\": \"1.0.0\"\n  },\n  \"host\": \"rekor.sigstore.dev\",\n  \"paths\": {\n    \"/api/v1/index/retrieve\": {\n      \"post\": {\n        \"description\": \"EXPERIMENTAL - this endpoint is offered as best effort only and may be changed or removed in future releases.\\nThe results returned from this endpoint may be incomplete.\\n\",\n        \"tags\": [\n          \"index\"\n        ],\n        \"summary\": \"Searches index by entry metadata\",\n        \"operationId\": \"searchIndex\",\n        \"deprecated\": true,\n        \"parameters\": [\n          {\n            \"name\": \"query\",\n            \"in\": \"body\",\n            \"required\": true,\n            \"schema\": {\n              \"$ref\": \"#/definitions/SearchIndex\"\n            }\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"description\": \"Returns zero or more entry UUIDs from the transparency log based on search query\",\n            \"schema\": {\n              \"type\": \"array\",\n              \"items\": {\n                \"description\": \"Entry UUID in transparency log\",\n                \"type\": \"string\",\n                \"pattern\": \"^([0-9a-fA-F]{64}|[0-9a-fA-F]{80})$\"\n              }\n            }\n          },\n          \"400\": {\n            \"$ref\": \"#/responses/BadContent\"\n          },\n          \"default\": {\n            \"$ref\": \"#/responses/InternalServerError\"\n          }\n        }\n      }\n    },\n    \"/api/v1/log\": {\n      \"get\": {\n        \"description\": \"Returns the current root hash and size of the merkle tree used to store the log entries.\",\n        \"tags\": [\n          \"tlog\"\n        ],\n        \"summary\": \"Get information about the current state of the transparency log\",\n        \"operationId\": \"getLogInfo\",\n        \"parameters\": [\n          {\n            \"type\": \"boolean\",\n            \"default\": false,\n            \"description\": \"Whether to return a stable checkpoint for the active shard\",\n            \"name\": \"stable\",\n            \"in\": \"query\"\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"description\": \"A JSON object with the root hash and tree size as properties\",\n            \"schema\": {\n              \"$ref\": \"#/definitions/LogInfo\"\n            }\n          },\n          \"default\": {\n            \"$ref\": \"#/responses/InternalServerError\"\n          }\n        }\n      }\n    },\n    \"/api/v1/log/entries\": {\n      \"get\": {\n        \"tags\": [\n          \"entries\"\n        ],\n        \"summary\": \"Retrieves an entry and inclusion proof from the transparency log (if it exists) by index\",\n        \"operationId\": \"getLogEntryByIndex\",\n        \"parameters\": [\n          {\n            \"type\": \"integer\",\n            \"description\": \"specifies the index of the entry in the transparency log to be retrieved\",\n            \"name\": \"logIndex\",\n            \"in\": \"query\",\n            \"required\": true\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"description\": \"the entry in the transparency log requested along with an inclusion proof\",\n            \"schema\": {\n              \"$ref\": \"#/definitions/LogEntry\"\n            }\n          },\n          \"404\": {\n            \"$ref\": \"#/responses/NotFound\"\n          },\n          \"default\": {\n            \"$ref\": \"#/responses/InternalServerError\"\n          }\n        }\n      },\n      \"post\": {\n        \"description\": \"Creates an entry in the transparency log for a detached signature, public key, and content. Items can be included in the request or fetched by the server when URLs are specified.\\n\",\n        \"tags\": [\n          \"entries\"\n        ],\n        \"summary\": \"Creates an entry in the transparency log\",\n        \"operationId\": \"createLogEntry\",\n        \"parameters\": [\n          {\n            \"name\": \"proposedEntry\",\n            \"in\": \"body\",\n            \"required\": true,\n            \"schema\": {\n              \"$ref\": \"#/definitions/ProposedEntry\"\n            }\n          }\n        ],\n        \"responses\": {\n          \"201\": {\n            \"description\": \"Returns the entry created in the transparency log\",\n            \"schema\": {\n              \"$ref\": \"#/definitions/LogEntry\"\n            },\n            \"headers\": {\n              \"ETag\": {\n                \"type\": \"string\",\n                \"description\": \"UUID of log entry\"\n              },\n              \"Location\": {\n                \"type\": \"string\",\n                \"format\": \"uri\",\n                \"description\": \"URI location of log entry\"\n              }\n            }\n          },\n          \"400\": {\n            \"$ref\": \"#/responses/BadContent\"\n          },\n          \"409\": {\n            \"$ref\": \"#/responses/Conflict\"\n          },\n          \"default\": {\n            \"$ref\": \"#/responses/InternalServerError\"\n          }\n        }\n      }\n    },\n    \"/api/v1/log/entries/retrieve\": {\n      \"post\": {\n        \"tags\": [\n          \"entries\"\n        ],\n        \"summary\": \"Searches transparency log for one or more log entries\",\n        \"operationId\": \"searchLogQuery\",\n        \"parameters\": [\n          {\n            \"name\": \"entry\",\n            \"in\": \"body\",\n            \"required\": true,\n            \"schema\": {\n              \"$ref\": \"#/definitions/SearchLogQuery\"\n            }\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"description\": \"Returns zero or more entries from the transparency log, according to how many were included in request query\",\n            \"schema\": {\n              \"type\": \"array\",\n              \"items\": {\n                \"$ref\": \"#/definitions/LogEntry\"\n              }\n            }\n          },\n          \"400\": {\n            \"$ref\": \"#/responses/BadContent\"\n          },\n          \"422\": {\n            \"$ref\": \"#/responses/UnprocessableEntity\"\n          },\n          \"default\": {\n            \"$ref\": \"#/responses/InternalServerError\"\n          }\n        }\n      }\n    },\n    \"/api/v1/log/entries/{entryUUID}\": {\n      \"get\": {\n        \"description\": \"Returns the entry, root hash, tree size, and a list of hashes that can be used to calculate proof of an entry being included in the transparency log\",\n        \"tags\": [\n          \"entries\"\n        ],\n        \"summary\": \"Get log entry and information required to generate an inclusion proof for the entry in the transparency log\",\n        \"operationId\": \"getLogEntryByUUID\",\n        \"parameters\": [\n          {\n            \"pattern\": \"^([0-9a-fA-F]{64}|[0-9a-fA-F]{80})$\",\n            \"type\": \"string\",\n            \"description\": \"the UUID of the entry for which the inclusion proof information should be returned\",\n            \"name\": \"entryUUID\",\n            \"in\": \"path\",\n            \"required\": true\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"description\": \"Information needed for a client to compute the inclusion proof\",\n            \"schema\": {\n              \"$ref\": \"#/definitions/LogEntry\"\n            }\n          },\n          \"404\": {\n            \"$ref\": \"#/responses/NotFound\"\n          },\n          \"default\": {\n            \"$ref\": \"#/responses/InternalServerError\"\n          }\n        }\n      }\n    },\n    \"/api/v1/log/proof\": {\n      \"get\": {\n        \"description\": \"Returns a list of hashes for specified tree sizes that can be used to confirm the consistency of the transparency log\",\n        \"tags\": [\n          \"tlog\"\n        ],\n        \"summary\": \"Get information required to generate a consistency proof for the transparency log\",\n        \"operationId\": \"getLogProof\",\n        \"parameters\": [\n          {\n            \"minimum\": 1,\n            \"type\": \"integer\",\n            \"default\": 1,\n            \"description\": \"The size of the tree that you wish to prove consistency from (1 means the beginning of the log) Defaults to 1 if not specified\\n\",\n            \"name\": \"firstSize\",\n            \"in\": \"query\"\n          },\n          {\n            \"minimum\": 1,\n            \"type\": \"integer\",\n            \"description\": \"The size of the tree that you wish to prove consistency to\",\n            \"name\": \"lastSize\",\n            \"in\": \"query\",\n            \"required\": true\n          },\n          {\n            \"pattern\": \"^[0-9]+$\",\n            \"type\": \"string\",\n            \"description\": \"The tree ID of the tree that you wish to prove consistency for\",\n            \"name\": \"treeID\",\n            \"in\": \"query\"\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"description\": \"All hashes required to compute the consistency proof\",\n            \"schema\": {\n              \"$ref\": \"#/definitions/ConsistencyProof\"\n            }\n          },\n          \"400\": {\n            \"$ref\": \"#/responses/BadContent\"\n          },\n          \"default\": {\n            \"$ref\": \"#/responses/InternalServerError\"\n          }\n        }\n      }\n    },\n    \"/api/v1/log/publicKey\": {\n      \"get\": {\n        \"description\": \"Returns the public key that can be used to validate the signed tree head\",\n        \"produces\": [\n          \"application/x-pem-file\"\n        ],\n        \"tags\": [\n          \"pubkey\"\n        ],\n        \"summary\": \"Retrieve the public key that can be used to validate the signed tree head\",\n        \"operationId\": \"getPublicKey\",\n        \"parameters\": [\n          {\n            \"pattern\": \"^[0-9]+$\",\n            \"type\": \"string\",\n            \"description\": \"The tree ID of the tree you wish to get a public key for\",\n            \"name\": \"treeID\",\n            \"in\": \"query\"\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"description\": \"The public key\",\n            \"schema\": {\n              \"type\": \"string\"\n            }\n          },\n          \"default\": {\n            \"$ref\": \"#/responses/InternalServerError\"\n          }\n        }\n      }\n    }\n  },\n  \"definitions\": {\n    \"ConsistencyProof\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"rootHash\",\n        \"hashes\"\n      ],\n      \"properties\": {\n        \"hashes\": {\n          \"type\": \"array\",\n          \"items\": {\n            \"description\": \"SHA256 hash value expressed in hexadecimal format\",\n            \"type\": \"string\",\n            \"pattern\": \"^[0-9a-fA-F]{64}$\"\n          }\n        },\n        \"rootHash\": {\n          \"description\": \"The hash value stored at the root of the merkle tree at the time the proof was generated\",\n          \"type\": \"string\",\n          \"pattern\": \"^[0-9a-fA-F]{64}$\"\n        }\n      }\n    },\n    \"Error\": {\n      \"type\": \"object\",\n      \"properties\": {\n        \"code\": {\n          \"type\": \"integer\"\n        },\n        \"message\": {\n          \"type\": \"string\"\n        }\n      }\n    },\n    \"InactiveShardLogInfo\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"rootHash\",\n        \"treeSize\",\n        \"signedTreeHead\",\n        \"treeID\"\n      ],\n      \"properties\": {\n        \"rootHash\": {\n          \"description\": \"The current hash value stored at the root of the merkle tree\",\n          \"type\": \"string\",\n          \"pattern\": \"^[0-9a-fA-F]{64}$\"\n        },\n        \"signedTreeHead\": {\n          \"description\": \"The current signed tree head\",\n          \"type\": \"string\",\n          \"format\": \"signedCheckpoint\"\n        },\n        \"treeID\": {\n          \"description\": \"The current treeID\",\n          \"type\": \"string\",\n          \"pattern\": \"^[0-9]+$\"\n        },\n        \"treeSize\": {\n          \"description\": \"The current number of nodes in the merkle tree\",\n          \"type\": \"integer\",\n          \"minimum\": 1\n        }\n      }\n    },\n    \"InclusionProof\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"logIndex\",\n        \"rootHash\",\n        \"treeSize\",\n        \"hashes\",\n        \"checkpoint\"\n      ],\n      \"properties\": {\n        \"checkpoint\": {\n          \"description\": \"The checkpoint (signed tree head) that the inclusion proof is based on\",\n          \"type\": \"string\",\n          \"format\": \"signedCheckpoint\"\n        },\n        \"hashes\": {\n          \"description\": \"A list of hashes required to compute the inclusion proof, sorted in order from leaf to root\",\n          \"type\": \"array\",\n          \"items\": {\n            \"description\": \"SHA256 hash value expressed in hexadecimal format\",\n            \"type\": \"string\",\n            \"pattern\": \"^[0-9a-fA-F]{64}$\"\n          }\n        },\n        \"logIndex\": {\n          \"description\": \"The index of the entry in the transparency log\",\n          \"type\": \"integer\"\n        },\n        \"rootHash\": {\n          \"description\": \"The hash value stored at the root of the merkle tree at the time the proof was generated\",\n          \"type\": \"string\",\n          \"pattern\": \"^[0-9a-fA-F]{64}$\"\n        },\n        \"treeSize\": {\n          \"description\": \"The size of the merkle tree at the time the inclusion proof was generated\",\n          \"type\": \"integer\",\n          \"minimum\": 1\n        }\n      }\n    },\n    \"LogEntry\": {\n      \"type\": \"object\",\n      \"additionalProperties\": {\n        \"type\": \"object\",\n        \"required\": [\n          \"logID\",\n          \"logIndex\",\n          \"body\",\n          \"integratedTime\"\n        ],\n        \"properties\": {\n          \"attestation\": {\n            \"type\": \"object\",\n            \"format\": \"byte\",\n            \"properties\": {\n              \"data\": {\n                \"format\": \"byte\"\n              }\n            }\n          },\n          \"body\": {\n            \"type\": \"object\",\n            \"additionalProperties\": true\n          },\n          \"integratedTime\": {\n            \"type\": \"integer\"\n          },\n          \"logID\": {\n            \"description\": \"This is the SHA256 hash of the DER-encoded public key for the log at the time the entry was included in the log\",\n            \"type\": \"string\",\n            \"pattern\": \"^[0-9a-fA-F]{64}$\"\n          },\n          \"logIndex\": {\n            \"type\": \"integer\"\n          },\n          \"verification\": {\n            \"type\": \"object\",\n            \"properties\": {\n              \"inclusionProof\": {\n                \"$ref\": \"#/definitions/InclusionProof\"\n              },\n              \"signedEntryTimestamp\": {\n                \"description\": \"Signature over the logID, logIndex, body and integratedTime.\",\n                \"type\": \"string\",\n                \"format\": \"byte\"\n              }\n            }\n          }\n        }\n      }\n    },\n    \"LogInfo\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"rootHash\",\n        \"treeSize\",\n        \"signedTreeHead\",\n        \"treeID\"\n      ],\n      \"properties\": {\n        \"inactiveShards\": {\n          \"type\": \"array\",\n          \"items\": {\n            \"$ref\": \"#/definitions/InactiveShardLogInfo\"\n          }\n        },\n        \"rootHash\": {\n          \"description\": \"The current hash value stored at the root of the merkle tree\",\n          \"type\": \"string\",\n          \"pattern\": \"^[0-9a-fA-F]{64}$\"\n        },\n        \"signedTreeHead\": {\n          \"description\": \"The current signed tree head\",\n          \"type\": \"string\",\n          \"format\": \"signedCheckpoint\"\n        },\n        \"treeID\": {\n          \"description\": \"The current treeID\",\n          \"type\": \"string\",\n          \"pattern\": \"^[0-9]+$\"\n        },\n        \"treeSize\": {\n          \"description\": \"The current number of nodes in the merkle tree\",\n          \"type\": \"integer\",\n          \"minimum\": 1\n        }\n      }\n    },\n    \"ProposedEntry\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"kind\"\n      ],\n      \"properties\": {\n        \"kind\": {\n          \"type\": \"string\"\n        }\n      },\n      \"discriminator\": \"kind\"\n    },\n    \"SearchIndex\": {\n      \"type\": \"object\",\n      \"properties\": {\n        \"email\": {\n          \"type\": \"string\",\n          \"format\": \"email\"\n        },\n        \"hash\": {\n          \"type\": \"string\",\n          \"pattern\": \"^(sha512:)?[0-9a-fA-F]{128}$|^(sha256:)?[0-9a-fA-F]{64}$|^(sha1:)?[0-9a-fA-F]{40}$\"\n        },\n        \"operator\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"and\",\n            \"or\"\n          ]\n        },\n        \"publicKey\": {\n          \"type\": \"object\",\n          \"required\": [\n            \"format\"\n          ],\n          \"properties\": {\n            \"content\": {\n              \"type\": \"string\",\n              \"format\": \"byte\"\n            },\n            \"format\": {\n              \"type\": \"string\",\n              \"enum\": [\n                \"pgp\",\n                \"x509\",\n                \"minisign\",\n                \"ssh\",\n                \"tuf\"\n              ]\n            },\n            \"url\": {\n              \"type\": \"string\",\n              \"format\": \"uri\"\n            }\n          }\n        }\n      }\n    },\n    \"SearchLogQuery\": {\n      \"type\": \"object\",\n      \"properties\": {\n        \"entries\": {\n          \"type\": \"array\",\n          \"maxItems\": 10,\n          \"minItems\": 1,\n          \"items\": {\n            \"$ref\": \"#/definitions/ProposedEntry\"\n          }\n        },\n        \"entryUUIDs\": {\n          \"type\": \"array\",\n          \"maxItems\": 10,\n          \"minItems\": 1,\n          \"items\": {\n            \"type\": \"string\",\n            \"pattern\": \"^([0-9a-fA-F]{64}|[0-9a-fA-F]{80})$\"\n          }\n        },\n        \"logIndexes\": {\n          \"type\": \"array\",\n          \"maxItems\": 10,\n          \"minItems\": 1,\n          \"items\": {\n            \"type\": \"integer\"\n          }\n        }\n      }\n    },\n    \"alpine\": {\n      \"description\": \"Alpine package\",\n      \"type\": \"object\",\n      \"allOf\": [\n        {\n          \"$ref\": \"#/definitions/ProposedEntry\"\n        },\n        {\n          \"required\": [\n            \"apiVersion\",\n            \"spec\"\n          ],\n          \"properties\": {\n            \"apiVersion\": {\n              \"type\": \"string\",\n              \"pattern\": \"^(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)(?:-((?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\\\.(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\\\+([0-9a-zA-Z-]+(?:\\\\.[0-9a-zA-Z-]+)*))?$\"\n            },\n            \"spec\": {\n              \"type\": \"object\",\n              \"$ref\": \"pkg/types/alpine/alpine_schema.json\"\n            }\n          },\n          \"additionalProperties\": false\n        }\n      ]\n    },\n    \"cose\": {\n      \"description\": \"COSE object\",\n      \"type\": \"object\",\n      \"allOf\": [\n        {\n          \"$ref\": \"#/definitions/ProposedEntry\"\n        },\n        {\n          \"required\": [\n            \"apiVersion\",\n            \"spec\"\n          ],\n          \"properties\": {\n            \"apiVersion\": {\n              \"type\": \"string\",\n              \"pattern\": \"^(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)(?:-((?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\\\.(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\\\+([0-9a-zA-Z-]+(?:\\\\.[0-9a-zA-Z-]+)*))?$\"\n            },\n            \"spec\": {\n              \"type\": \"object\",\n              \"$ref\": \"pkg/types/cose/cose_schema.json\"\n            }\n          },\n          \"additionalProperties\": false\n        }\n      ]\n    },\n    \"dsse\": {\n      \"description\": \"DSSE envelope\",\n      \"type\": \"object\",\n      \"allOf\": [\n        {\n          \"$ref\": \"#/definitions/ProposedEntry\"\n        },\n        {\n          \"required\": [\n            \"apiVersion\",\n            \"spec\"\n          ],\n          \"properties\": {\n            \"apiVersion\": {\n              \"type\": \"string\",\n              \"pattern\": \"^(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)(?:-((?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\\\.(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\\\+([0-9a-zA-Z-]+(?:\\\\.[0-9a-zA-Z-]+)*))?$\"\n            },\n            \"spec\": {\n              \"type\": \"object\",\n              \"$ref\": \"pkg/types/dsse/dsse_schema.json\"\n            }\n          },\n          \"additionalProperties\": false\n        }\n      ]\n    },\n    \"hashedrekord\": {\n      \"description\": \"Hashed Rekord object\",\n      \"type\": \"object\",\n      \"allOf\": [\n        {\n          \"$ref\": \"#/definitions/ProposedEntry\"\n        },\n        {\n          \"required\": [\n            \"apiVersion\",\n            \"spec\"\n          ],\n          \"properties\": {\n            \"apiVersion\": {\n              \"type\": \"string\",\n              \"pattern\": \"^(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)(?:-((?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\\\.(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\\\+([0-9a-zA-Z-]+(?:\\\\.[0-9a-zA-Z-]+)*))?$\"\n            },\n            \"spec\": {\n              \"type\": \"object\",\n              \"$ref\": \"pkg/types/hashedrekord/hashedrekord_schema.json\"\n            }\n          },\n          \"additionalProperties\": false\n        }\n      ]\n    },\n    \"helm\": {\n      \"description\": \"Helm chart\",\n      \"type\": \"object\",\n      \"allOf\": [\n        {\n          \"$ref\": \"#/definitions/ProposedEntry\"\n        },\n        {\n          \"required\": [\n            \"apiVersion\",\n            \"spec\"\n          ],\n          \"properties\": {\n            \"apiVersion\": {\n              \"type\": \"string\",\n              \"pattern\": \"^(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)(?:-((?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\\\.(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\\\+([0-9a-zA-Z-]+(?:\\\\.[0-9a-zA-Z-]+)*))?$\"\n            },\n            \"spec\": {\n              \"type\": \"object\",\n              \"$ref\": \"pkg/types/helm/helm_schema.json\"\n            }\n          }\n        }\n      ]\n    },\n    \"intoto\": {\n      \"description\": \"Intoto object\",\n      \"type\": \"object\",\n      \"allOf\": [\n        {\n          \"$ref\": \"#/definitions/ProposedEntry\"\n        },\n        {\n          \"required\": [\n            \"apiVersion\",\n            \"spec\"\n          ],\n          \"properties\": {\n            \"apiVersion\": {\n              \"type\": \"string\",\n              \"pattern\": \"^(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)(?:-((?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\\\.(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\\\+([0-9a-zA-Z-]+(?:\\\\.[0-9a-zA-Z-]+)*))?$\"\n            },\n            \"spec\": {\n              \"type\": \"object\",\n              \"$ref\": \"pkg/types/intoto/intoto_schema.json\"\n            }\n          },\n          \"additionalProperties\": false\n        }\n      ]\n    },\n    \"jar\": {\n      \"description\": \"Java Archive (JAR)\",\n      \"type\": \"object\",\n      \"allOf\": [\n        {\n          \"$ref\": \"#/definitions/ProposedEntry\"\n        },\n        {\n          \"required\": [\n            \"apiVersion\",\n            \"spec\"\n          ],\n          \"properties\": {\n            \"apiVersion\": {\n              \"type\": \"string\",\n              \"pattern\": \"^(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)(?:-((?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\\\.(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\\\+([0-9a-zA-Z-]+(?:\\\\.[0-9a-zA-Z-]+)*))?$\"\n            },\n            \"spec\": {\n              \"type\": \"object\",\n              \"$ref\": \"pkg/types/jar/jar_schema.json\"\n            }\n          },\n          \"additionalProperties\": false\n        }\n      ]\n    },\n    \"rekord\": {\n      \"description\": \"Rekord object\",\n      \"type\": \"object\",\n      \"allOf\": [\n        {\n          \"$ref\": \"#/definitions/ProposedEntry\"\n        },\n        {\n          \"required\": [\n            \"apiVersion\",\n            \"spec\"\n          ],\n          \"properties\": {\n            \"apiVersion\": {\n              \"type\": \"string\",\n              \"pattern\": \"^(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)(?:-((?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\\\.(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\\\+([0-9a-zA-Z-]+(?:\\\\.[0-9a-zA-Z-]+)*))?$\"\n            },\n            \"spec\": {\n              \"type\": \"object\",\n              \"$ref\": \"pkg/types/rekord/rekord_schema.json\"\n            }\n          },\n          \"additionalProperties\": false\n        }\n      ]\n    },\n    \"rfc3161\": {\n      \"description\": \"RFC3161 Timestamp\",\n      \"type\": \"object\",\n      \"allOf\": [\n        {\n          \"$ref\": \"#/definitions/ProposedEntry\"\n        },\n        {\n          \"required\": [\n            \"apiVersion\",\n            \"spec\"\n          ],\n          \"properties\": {\n            \"apiVersion\": {\n              \"type\": \"string\",\n              \"pattern\": \"^(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)(?:-((?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\\\.(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\\\+([0-9a-zA-Z-]+(?:\\\\.[0-9a-zA-Z-]+)*))?$\"\n            },\n            \"spec\": {\n              \"type\": \"object\",\n              \"$ref\": \"pkg/types/rfc3161/rfc3161_schema.json\"\n            }\n          },\n          \"additionalProperties\": false\n        }\n      ]\n    },\n    \"rpm\": {\n      \"description\": \"RPM package\",\n      \"type\": \"object\",\n      \"allOf\": [\n        {\n          \"$ref\": \"#/definitions/ProposedEntry\"\n        },\n        {\n          \"required\": [\n            \"apiVersion\",\n            \"spec\"\n          ],\n          \"properties\": {\n            \"apiVersion\": {\n              \"type\": \"string\",\n              \"pattern\": \"^(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)(?:-((?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\\\.(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\\\+([0-9a-zA-Z-]+(?:\\\\.[0-9a-zA-Z-]+)*))?$\"\n            },\n            \"spec\": {\n              \"type\": \"object\",\n              \"$ref\": \"pkg/types/rpm/rpm_schema.json\"\n            }\n          },\n          \"additionalProperties\": false\n        }\n      ]\n    },\n    \"tuf\": {\n      \"description\": \"TUF metadata\",\n      \"type\": \"object\",\n      \"allOf\": [\n        {\n          \"$ref\": \"#/definitions/ProposedEntry\"\n        },\n        {\n          \"required\": [\n            \"apiVersion\",\n            \"spec\"\n          ],\n          \"properties\": {\n            \"apiVersion\": {\n              \"type\": \"string\",\n              \"pattern\": \"^(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)(?:-((?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\\\.(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\\\+([0-9a-zA-Z-]+(?:\\\\.[0-9a-zA-Z-]+)*))?$\"\n            },\n            \"spec\": {\n              \"type\": \"object\",\n              \"$ref\": \"pkg/types/tuf/tuf_schema.json\"\n            }\n          },\n          \"additionalProperties\": false\n        }\n      ]\n    }\n  },\n  \"responses\": {\n    \"BadContent\": {\n      \"description\": \"The content supplied to the server was invalid\",\n      \"schema\": {\n        \"$ref\": \"#/definitions/Error\"\n      }\n    },\n    \"Conflict\": {\n      \"description\": \"The request conflicts with the current state of the transparency log\",\n      \"schema\": {\n        \"$ref\": \"#/definitions/Error\"\n      },\n      \"headers\": {\n        \"Location\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        }\n      }\n    },\n    \"InternalServerError\": {\n      \"description\": \"There was an internal error in the server while processing the request\",\n      \"schema\": {\n        \"$ref\": \"#/definitions/Error\"\n      }\n    },\n    \"NotFound\": {\n      \"description\": \"The content requested could not be found\"\n    },\n    \"UnprocessableEntity\": {\n      \"description\": \"The server understood the request but is unable to process the contained instructions\",\n      \"schema\": {\n        \"$ref\": \"#/definitions/Error\"\n      }\n    }\n  }\n}`))\n\tFlatSwaggerJSON = json.RawMessage([]byte(`{\n  \"consumes\": [\n    \"application/json\"\n  ],\n  \"produces\": [\n    \"application/json\"\n  ],\n  \"schemes\": [\n    \"http\"\n  ],\n  \"swagger\": \"2.0\",\n  \"info\": {\n    \"description\": \"Rekor is a cryptographically secure, immutable transparency log for signed software releases.\",\n    \"title\": \"Rekor\",\n    \"version\": \"1.0.0\"\n  },\n  \"host\": \"rekor.sigstore.dev\",\n  \"paths\": {\n    \"/api/v1/index/retrieve\": {\n      \"post\": {\n        \"description\": \"EXPERIMENTAL - this endpoint is offered as best effort only and may be changed or removed in future releases.\\nThe results returned from this endpoint may be incomplete.\\n\",\n        \"tags\": [\n          \"index\"\n        ],\n        \"summary\": \"Searches index by entry metadata\",\n        \"operationId\": \"searchIndex\",\n        \"deprecated\": true,\n        \"parameters\": [\n          {\n            \"name\": \"query\",\n            \"in\": \"body\",\n            \"required\": true,\n            \"schema\": {\n              \"$ref\": \"#/definitions/SearchIndex\"\n            }\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"description\": \"Returns zero or more entry UUIDs from the transparency log based on search query\",\n            \"schema\": {\n              \"type\": \"array\",\n              \"items\": {\n                \"description\": \"Entry UUID in transparency log\",\n                \"type\": \"string\",\n                \"pattern\": \"^([0-9a-fA-F]{64}|[0-9a-fA-F]{80})$\"\n              }\n            }\n          },\n          \"400\": {\n            \"description\": \"The content supplied to the server was invalid\",\n            \"schema\": {\n              \"$ref\": \"#/definitions/Error\"\n            }\n          },\n          \"default\": {\n            \"description\": \"There was an internal error in the server while processing the request\",\n            \"schema\": {\n              \"$ref\": \"#/definitions/Error\"\n            }\n          }\n        }\n      }\n    },\n    \"/api/v1/log\": {\n      \"get\": {\n        \"description\": \"Returns the current root hash and size of the merkle tree used to store the log entries.\",\n        \"tags\": [\n          \"tlog\"\n        ],\n        \"summary\": \"Get information about the current state of the transparency log\",\n        \"operationId\": \"getLogInfo\",\n        \"parameters\": [\n          {\n            \"type\": \"boolean\",\n            \"default\": false,\n            \"description\": \"Whether to return a stable checkpoint for the active shard\",\n            \"name\": \"stable\",\n            \"in\": \"query\"\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"description\": \"A JSON object with the root hash and tree size as properties\",\n            \"schema\": {\n              \"$ref\": \"#/definitions/LogInfo\"\n            }\n          },\n          \"default\": {\n            \"description\": \"There was an internal error in the server while processing the request\",\n            \"schema\": {\n              \"$ref\": \"#/definitions/Error\"\n            }\n          }\n        }\n      }\n    },\n    \"/api/v1/log/entries\": {\n      \"get\": {\n        \"tags\": [\n          \"entries\"\n        ],\n        \"summary\": \"Retrieves an entry and inclusion proof from the transparency log (if it exists) by index\",\n        \"operationId\": \"getLogEntryByIndex\",\n        \"parameters\": [\n          {\n            \"minimum\": 0,\n            \"type\": \"integer\",\n            \"description\": \"specifies the index of the entry in the transparency log to be retrieved\",\n            \"name\": \"logIndex\",\n            \"in\": \"query\",\n            \"required\": true\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"description\": \"the entry in the transparency log requested along with an inclusion proof\",\n            \"schema\": {\n              \"$ref\": \"#/definitions/LogEntry\"\n            }\n          },\n          \"404\": {\n            \"description\": \"The content requested could not be found\"\n          },\n          \"default\": {\n            \"description\": \"There was an internal error in the server while processing the request\",\n            \"schema\": {\n              \"$ref\": \"#/definitions/Error\"\n            }\n          }\n        }\n      },\n      \"post\": {\n        \"description\": \"Creates an entry in the transparency log for a detached signature, public key, and content. Items can be included in the request or fetched by the server when URLs are specified.\\n\",\n        \"tags\": [\n          \"entries\"\n        ],\n        \"summary\": \"Creates an entry in the transparency log\",\n        \"operationId\": \"createLogEntry\",\n        \"parameters\": [\n          {\n            \"name\": \"proposedEntry\",\n            \"in\": \"body\",\n            \"required\": true,\n            \"schema\": {\n              \"$ref\": \"#/definitions/ProposedEntry\"\n            }\n          }\n        ],\n        \"responses\": {\n          \"201\": {\n            \"description\": \"Returns the entry created in the transparency log\",\n            \"schema\": {\n              \"$ref\": \"#/definitions/LogEntry\"\n            },\n            \"headers\": {\n              \"ETag\": {\n                \"type\": \"string\",\n                \"description\": \"UUID of log entry\"\n              },\n              \"Location\": {\n                \"type\": \"string\",\n                \"format\": \"uri\",\n                \"description\": \"URI location of log entry\"\n              }\n            }\n          },\n          \"400\": {\n            \"description\": \"The content supplied to the server was invalid\",\n            \"schema\": {\n              \"$ref\": \"#/definitions/Error\"\n            }\n          },\n          \"409\": {\n            \"description\": \"The request conflicts with the current state of the transparency log\",\n            \"schema\": {\n              \"$ref\": \"#/definitions/Error\"\n            },\n            \"headers\": {\n              \"Location\": {\n                \"type\": \"string\",\n                \"format\": \"uri\"\n              }\n            }\n          },\n          \"default\": {\n            \"description\": \"There was an internal error in the server while processing the request\",\n            \"schema\": {\n              \"$ref\": \"#/definitions/Error\"\n            }\n          }\n        }\n      }\n    },\n    \"/api/v1/log/entries/retrieve\": {\n      \"post\": {\n        \"tags\": [\n          \"entries\"\n        ],\n        \"summary\": \"Searches transparency log for one or more log entries\",\n        \"operationId\": \"searchLogQuery\",\n        \"parameters\": [\n          {\n            \"name\": \"entry\",\n            \"in\": \"body\",\n            \"required\": true,\n            \"schema\": {\n              \"$ref\": \"#/definitions/SearchLogQuery\"\n            }\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"description\": \"Returns zero or more entries from the transparency log, according to how many were included in request query\",\n            \"schema\": {\n              \"type\": \"array\",\n              \"items\": {\n                \"$ref\": \"#/definitions/LogEntry\"\n              }\n            }\n          },\n          \"400\": {\n            \"description\": \"The content supplied to the server was invalid\",\n            \"schema\": {\n              \"$ref\": \"#/definitions/Error\"\n            }\n          },\n          \"422\": {\n            \"description\": \"The server understood the request but is unable to process the contained instructions\",\n            \"schema\": {\n              \"$ref\": \"#/definitions/Error\"\n            }\n          },\n          \"default\": {\n            \"description\": \"There was an internal error in the server while processing the request\",\n            \"schema\": {\n              \"$ref\": \"#/definitions/Error\"\n            }\n          }\n        }\n      }\n    },\n    \"/api/v1/log/entries/{entryUUID}\": {\n      \"get\": {\n        \"description\": \"Returns the entry, root hash, tree size, and a list of hashes that can be used to calculate proof of an entry being included in the transparency log\",\n        \"tags\": [\n          \"entries\"\n        ],\n        \"summary\": \"Get log entry and information required to generate an inclusion proof for the entry in the transparency log\",\n        \"operationId\": \"getLogEntryByUUID\",\n        \"parameters\": [\n          {\n            \"pattern\": \"^([0-9a-fA-F]{64}|[0-9a-fA-F]{80})$\",\n            \"type\": \"string\",\n            \"description\": \"the UUID of the entry for which the inclusion proof information should be returned\",\n            \"name\": \"entryUUID\",\n            \"in\": \"path\",\n            \"required\": true\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"description\": \"Information needed for a client to compute the inclusion proof\",\n            \"schema\": {\n              \"$ref\": \"#/definitions/LogEntry\"\n            }\n          },\n          \"404\": {\n            \"description\": \"The content requested could not be found\"\n          },\n          \"default\": {\n            \"description\": \"There was an internal error in the server while processing the request\",\n            \"schema\": {\n              \"$ref\": \"#/definitions/Error\"\n            }\n          }\n        }\n      }\n    },\n    \"/api/v1/log/proof\": {\n      \"get\": {\n        \"description\": \"Returns a list of hashes for specified tree sizes that can be used to confirm the consistency of the transparency log\",\n        \"tags\": [\n          \"tlog\"\n        ],\n        \"summary\": \"Get information required to generate a consistency proof for the transparency log\",\n        \"operationId\": \"getLogProof\",\n        \"parameters\": [\n          {\n            \"minimum\": 1,\n            \"type\": \"integer\",\n            \"default\": 1,\n            \"description\": \"The size of the tree that you wish to prove consistency from (1 means the beginning of the log) Defaults to 1 if not specified\\n\",\n            \"name\": \"firstSize\",\n            \"in\": \"query\"\n          },\n          {\n            \"minimum\": 1,\n            \"type\": \"integer\",\n            \"description\": \"The size of the tree that you wish to prove consistency to\",\n            \"name\": \"lastSize\",\n            \"in\": \"query\",\n            \"required\": true\n          },\n          {\n            \"pattern\": \"^[0-9]+$\",\n            \"type\": \"string\",\n            \"description\": \"The tree ID of the tree that you wish to prove consistency for\",\n            \"name\": \"treeID\",\n            \"in\": \"query\"\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"description\": \"All hashes required to compute the consistency proof\",\n            \"schema\": {\n              \"$ref\": \"#/definitions/ConsistencyProof\"\n            }\n          },\n          \"400\": {\n            \"description\": \"The content supplied to the server was invalid\",\n            \"schema\": {\n              \"$ref\": \"#/definitions/Error\"\n            }\n          },\n          \"default\": {\n            \"description\": \"There was an internal error in the server while processing the request\",\n            \"schema\": {\n              \"$ref\": \"#/definitions/Error\"\n            }\n          }\n        }\n      }\n    },\n    \"/api/v1/log/publicKey\": {\n      \"get\": {\n        \"description\": \"Returns the public key that can be used to validate the signed tree head\",\n        \"produces\": [\n          \"application/x-pem-file\"\n        ],\n        \"tags\": [\n          \"pubkey\"\n        ],\n        \"summary\": \"Retrieve the public key that can be used to validate the signed tree head\",\n        \"operationId\": \"getPublicKey\",\n        \"parameters\": [\n          {\n            \"pattern\": \"^[0-9]+$\",\n            \"type\": \"string\",\n            \"description\": \"The tree ID of the tree you wish to get a public key for\",\n            \"name\": \"treeID\",\n            \"in\": \"query\"\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"description\": \"The public key\",\n            \"schema\": {\n              \"type\": \"string\"\n            }\n          },\n          \"default\": {\n            \"description\": \"There was an internal error in the server while processing the request\",\n            \"schema\": {\n              \"$ref\": \"#/definitions/Error\"\n            }\n          }\n        }\n      }\n    }\n  },\n  \"definitions\": {\n    \"AlpineV001SchemaPackage\": {\n      \"description\": \"Information about the package associated with the entry\",\n      \"type\": \"object\",\n      \"oneOf\": [\n        {\n          \"required\": [\n            \"hash\"\n          ]\n        },\n        {\n          \"required\": [\n            \"content\"\n          ]\n        }\n      ],\n      \"properties\": {\n        \"content\": {\n          \"description\": \"Specifies the package inline within the document\",\n          \"type\": \"string\",\n          \"format\": \"byte\",\n          \"writeOnly\": true\n        },\n        \"hash\": {\n          \"description\": \"Specifies the hash algorithm and value for the package\",\n          \"type\": \"object\",\n          \"required\": [\n            \"algorithm\",\n            \"value\"\n          ],\n          \"properties\": {\n            \"algorithm\": {\n              \"description\": \"The hashing function used to compute the hash value\",\n              \"type\": \"string\",\n              \"enum\": [\n                \"sha256\"\n              ]\n            },\n            \"value\": {\n              \"description\": \"The hash value for the package\",\n              \"type\": \"string\"\n            }\n          },\n          \"readOnly\": true\n        },\n        \"pkginfo\": {\n          \"description\": \"Values of the .PKGINFO key / value pairs\",\n          \"type\": \"object\",\n          \"additionalProperties\": {\n            \"type\": \"string\"\n          },\n          \"readOnly\": true\n        }\n      }\n    },\n    \"AlpineV001SchemaPackageHash\": {\n      \"description\": \"Specifies the hash algorithm and value for the package\",\n      \"type\": \"object\",\n      \"required\": [\n        \"algorithm\",\n        \"value\"\n      ],\n      \"properties\": {\n        \"algorithm\": {\n          \"description\": \"The hashing function used to compute the hash value\",\n          \"type\": \"string\",\n          \"enum\": [\n            \"sha256\"\n          ]\n        },\n        \"value\": {\n          \"description\": \"The hash value for the package\",\n          \"type\": \"string\"\n        }\n      },\n      \"readOnly\": true\n    },\n    \"AlpineV001SchemaPublicKey\": {\n      \"description\": \"The public key that can verify the package signature\",\n      \"type\": \"object\",\n      \"required\": [\n        \"content\"\n      ],\n      \"properties\": {\n        \"content\": {\n          \"description\": \"Specifies the content of the public key inline within the document\",\n          \"type\": \"string\",\n          \"format\": \"byte\"\n        }\n      }\n    },\n    \"ConsistencyProof\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"rootHash\",\n        \"hashes\"\n      ],\n      \"properties\": {\n        \"hashes\": {\n          \"type\": \"array\",\n          \"items\": {\n            \"description\": \"SHA256 hash value expressed in hexadecimal format\",\n            \"type\": \"string\",\n            \"pattern\": \"^[0-9a-fA-F]{64}$\"\n          }\n        },\n        \"rootHash\": {\n          \"description\": \"The hash value stored at the root of the merkle tree at the time the proof was generated\",\n          \"type\": \"string\",\n          \"pattern\": \"^[0-9a-fA-F]{64}$\"\n        }\n      }\n    },\n    \"CoseV001SchemaData\": {\n      \"description\": \"Information about the content associated with the entry\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"aad\": {\n          \"description\": \"Specifies the additional authenticated data required to verify the signature\",\n          \"type\": \"string\",\n          \"format\": \"byte\",\n          \"writeOnly\": true\n        },\n        \"envelopeHash\": {\n          \"description\": \"Specifies the hash algorithm and value for the COSE envelope\",\n          \"type\": \"object\",\n          \"required\": [\n            \"algorithm\",\n            \"value\"\n          ],\n          \"properties\": {\n            \"algorithm\": {\n              \"description\": \"The hashing function used to compute the hash value\",\n              \"type\": \"string\",\n              \"enum\": [\n                \"sha256\"\n              ]\n            },\n            \"value\": {\n              \"description\": \"The hash value for the envelope\",\n              \"type\": \"string\"\n            }\n          },\n          \"readOnly\": true\n        },\n        \"payloadHash\": {\n          \"description\": \"Specifies the hash algorithm and value for the content\",\n          \"type\": \"object\",\n          \"required\": [\n            \"algorithm\",\n            \"value\"\n          ],\n          \"properties\": {\n            \"algorithm\": {\n              \"description\": \"The hashing function used to compute the hash value\",\n              \"type\": \"string\",\n              \"enum\": [\n                \"sha256\"\n              ]\n            },\n            \"value\": {\n              \"description\": \"The hash value for the content\",\n              \"type\": \"string\"\n            }\n          },\n          \"readOnly\": true\n        }\n      }\n    },\n    \"CoseV001SchemaDataEnvelopeHash\": {\n      \"description\": \"Specifies the hash algorithm and value for the COSE envelope\",\n      \"type\": \"object\",\n      \"required\": [\n        \"algorithm\",\n        \"value\"\n      ],\n      \"properties\": {\n        \"algorithm\": {\n          \"description\": \"The hashing function used to compute the hash value\",\n          \"type\": \"string\",\n          \"enum\": [\n            \"sha256\"\n          ]\n        },\n        \"value\": {\n          \"description\": \"The hash value for the envelope\",\n          \"type\": \"string\"\n        }\n      },\n      \"readOnly\": true\n    },\n    \"CoseV001SchemaDataPayloadHash\": {\n      \"description\": \"Specifies the hash algorithm and value for the content\",\n      \"type\": \"object\",\n      \"required\": [\n        \"algorithm\",\n        \"value\"\n      ],\n      \"properties\": {\n        \"algorithm\": {\n          \"description\": \"The hashing function used to compute the hash value\",\n          \"type\": \"string\",\n          \"enum\": [\n            \"sha256\"\n          ]\n        },\n        \"value\": {\n          \"description\": \"The hash value for the content\",\n          \"type\": \"string\"\n        }\n      },\n      \"readOnly\": true\n    },\n    \"DSSEV001SchemaEnvelopeHash\": {\n      \"description\": \"Specifies the hash algorithm and value encompassing the entire envelope sent to Rekor\",\n      \"type\": \"object\",\n      \"required\": [\n        \"algorithm\",\n        \"value\"\n      ],\n      \"properties\": {\n        \"algorithm\": {\n          \"description\": \"The hashing function used to compute the hash value\",\n          \"type\": \"string\",\n          \"enum\": [\n            \"sha256\"\n          ]\n        },\n        \"value\": {\n          \"description\": \"The value of the computed digest over the entire envelope\",\n          \"type\": \"string\"\n        }\n      },\n      \"readOnly\": true\n    },\n    \"DSSEV001SchemaPayloadHash\": {\n      \"description\": \"Specifies the hash algorithm and value covering the payload within the DSSE envelope\",\n      \"type\": \"object\",\n      \"required\": [\n        \"algorithm\",\n        \"value\"\n      ],\n      \"properties\": {\n        \"algorithm\": {\n          \"description\": \"The hashing function used to compute the hash value\",\n          \"type\": \"string\",\n          \"enum\": [\n            \"sha256\"\n          ]\n        },\n        \"value\": {\n          \"description\": \"The value of the computed digest over the payload within the envelope\",\n          \"type\": \"string\"\n        }\n      },\n      \"readOnly\": true\n    },\n    \"DSSEV001SchemaProposedContent\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"envelope\",\n        \"verifiers\"\n      ],\n      \"properties\": {\n        \"envelope\": {\n          \"description\": \"DSSE envelope specified as a stringified JSON object\",\n          \"type\": \"string\",\n          \"writeOnly\": true\n        },\n        \"verifiers\": {\n          \"description\": \"collection of all verification material (e.g. public keys or certificates) used to verify signatures over envelope's payload, specified as base64-encoded strings\",\n          \"type\": \"array\",\n          \"minItems\": 1,\n          \"items\": {\n            \"type\": \"string\",\n            \"format\": \"byte\"\n          },\n          \"writeOnly\": true\n        }\n      },\n      \"writeOnly\": true\n    },\n    \"DSSEV001SchemaSignaturesItems0\": {\n      \"description\": \"a signature of the envelope's payload along with the verification material for the signature\",\n      \"type\": \"object\",\n      \"required\": [\n        \"signature\",\n        \"verifier\"\n      ],\n      \"properties\": {\n        \"signature\": {\n          \"description\": \"base64 encoded signature of the payload\",\n          \"type\": \"string\",\n          \"pattern\": \"^(?:[A-Za-z0-9+\\\\/]{4})*(?:[A-Za-z0-9+\\\\/]{2}==|[A-Za-z0-9+\\\\/]{3}=|[A-Za-z0-9+\\\\/]{4})$\"\n        },\n        \"verifier\": {\n          \"description\": \"verification material that was used to verify the corresponding signature, specified as a base64 encoded string\",\n          \"type\": \"string\",\n          \"format\": \"byte\"\n        }\n      }\n    },\n    \"Error\": {\n      \"type\": \"object\",\n      \"properties\": {\n        \"code\": {\n          \"type\": \"integer\"\n        },\n        \"message\": {\n          \"type\": \"string\"\n        }\n      }\n    },\n    \"HashedrekordV001SchemaData\": {\n      \"description\": \"Information about the content associated with the entry\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"hash\": {\n          \"description\": \"Specifies the hash algorithm and value for the content\",\n          \"type\": \"object\",\n          \"required\": [\n            \"algorithm\",\n            \"value\"\n          ],\n          \"properties\": {\n            \"algorithm\": {\n              \"description\": \"The hashing function used to compute the hash value\",\n              \"type\": \"string\",\n              \"enum\": [\n                \"sha256\"\n              ]\n            },\n            \"value\": {\n              \"description\": \"The hash value for the content\",\n              \"type\": \"string\"\n            }\n          }\n        }\n      }\n    },\n    \"HashedrekordV001SchemaDataHash\": {\n      \"description\": \"Specifies the hash algorithm and value for the content\",\n      \"type\": \"object\",\n      \"required\": [\n        \"algorithm\",\n        \"value\"\n      ],\n      \"properties\": {\n        \"algorithm\": {\n          \"description\": \"The hashing function used to compute the hash value\",\n          \"type\": \"string\",\n          \"enum\": [\n            \"sha256\"\n          ]\n        },\n        \"value\": {\n          \"description\": \"The hash value for the content\",\n          \"type\": \"string\"\n        }\n      }\n    },\n    \"HashedrekordV001SchemaSignature\": {\n      \"description\": \"Information about the detached signature associated with the entry\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"content\": {\n          \"description\": \"Specifies the content of the signature inline within the document\",\n          \"type\": \"string\",\n          \"format\": \"byte\"\n        },\n        \"publicKey\": {\n          \"description\": \"The public key that can verify the signature; this can also be an X509 code signing certificate that contains the raw public key information\",\n          \"type\": \"object\",\n          \"properties\": {\n            \"content\": {\n              \"description\": \"Specifies the content of the public key or code signing certificate inline within the document\",\n              \"type\": \"string\",\n              \"format\": \"byte\"\n            }\n          }\n        }\n      }\n    },\n    \"HashedrekordV001SchemaSignaturePublicKey\": {\n      \"description\": \"The public key that can verify the signature; this can also be an X509 code signing certificate that contains the raw public key information\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"content\": {\n          \"description\": \"Specifies the content of the public key or code signing certificate inline within the document\",\n          \"type\": \"string\",\n          \"format\": \"byte\"\n        }\n      }\n    },\n    \"HelmV001SchemaChart\": {\n      \"description\": \"Information about the Helm chart associated with the entry\",\n      \"type\": \"object\",\n      \"required\": [\n        \"provenance\"\n      ],\n      \"properties\": {\n        \"hash\": {\n          \"description\": \"Specifies the hash algorithm and value for the chart\",\n          \"type\": \"object\",\n          \"required\": [\n            \"algorithm\",\n            \"value\"\n          ],\n          \"properties\": {\n            \"algorithm\": {\n              \"description\": \"The hashing function used to compute the hash value\",\n              \"type\": \"string\",\n              \"enum\": [\n                \"sha256\"\n              ]\n            },\n            \"value\": {\n              \"description\": \"The hash value for the chart\",\n              \"type\": \"string\"\n            }\n          },\n          \"readOnly\": true\n        },\n        \"provenance\": {\n          \"description\": \"The provenance entry associated with the signed Helm Chart\",\n          \"type\": \"object\",\n          \"oneOf\": [\n            {\n              \"required\": [\n                \"signature\"\n              ]\n            },\n            {\n              \"required\": [\n                \"content\"\n              ]\n            }\n          ],\n          \"properties\": {\n            \"content\": {\n              \"description\": \"Specifies the content of the provenance file inline within the document\",\n              \"type\": \"string\",\n              \"format\": \"byte\",\n              \"writeOnly\": true\n            },\n            \"signature\": {\n              \"description\": \"Information about the included signature in the provenance file\",\n              \"type\": \"object\",\n              \"required\": [\n                \"content\"\n              ],\n              \"properties\": {\n                \"content\": {\n                  \"description\": \"Specifies the signature embedded within the provenance file \",\n                  \"type\": \"string\",\n                  \"format\": \"byte\",\n                  \"readOnly\": true\n                }\n              },\n              \"readOnly\": true\n            }\n          }\n        }\n      }\n    },\n    \"HelmV001SchemaChartHash\": {\n      \"description\": \"Specifies the hash algorithm and value for the chart\",\n      \"type\": \"object\",\n      \"required\": [\n        \"algorithm\",\n        \"value\"\n      ],\n      \"properties\": {\n        \"algorithm\": {\n          \"description\": \"The hashing function used to compute the hash value\",\n          \"type\": \"string\",\n          \"enum\": [\n            \"sha256\"\n          ]\n        },\n        \"value\": {\n          \"description\": \"The hash value for the chart\",\n          \"type\": \"string\"\n        }\n      },\n      \"readOnly\": true\n    },\n    \"HelmV001SchemaChartProvenance\": {\n      \"description\": \"The provenance entry associated with the signed Helm Chart\",\n      \"type\": \"object\",\n      \"oneOf\": [\n        {\n          \"required\": [\n            \"signature\"\n          ]\n        },\n        {\n          \"required\": [\n            \"content\"\n          ]\n        }\n      ],\n      \"properties\": {\n        \"content\": {\n          \"description\": \"Specifies the content of the provenance file inline within the document\",\n          \"type\": \"string\",\n          \"format\": \"byte\",\n          \"writeOnly\": true\n        },\n        \"signature\": {\n          \"description\": \"Information about the included signature in the provenance file\",\n          \"type\": \"object\",\n          \"required\": [\n            \"content\"\n          ],\n          \"properties\": {\n            \"content\": {\n              \"description\": \"Specifies the signature embedded within the provenance file \",\n              \"type\": \"string\",\n              \"format\": \"byte\",\n              \"readOnly\": true\n            }\n          },\n          \"readOnly\": true\n        }\n      }\n    },\n    \"HelmV001SchemaChartProvenanceSignature\": {\n      \"description\": \"Information about the included signature in the provenance file\",\n      \"type\": \"object\",\n      \"required\": [\n        \"content\"\n      ],\n      \"properties\": {\n        \"content\": {\n          \"description\": \"Specifies the signature embedded within the provenance file \",\n          \"type\": \"string\",\n          \"format\": \"byte\",\n          \"readOnly\": true\n        }\n      },\n      \"readOnly\": true\n    },\n    \"HelmV001SchemaPublicKey\": {\n      \"description\": \"The public key that can verify the package signature\",\n      \"type\": \"object\",\n      \"required\": [\n        \"content\"\n      ],\n      \"properties\": {\n        \"content\": {\n          \"description\": \"Specifies the content of the public key inline within the document\",\n          \"type\": \"string\",\n          \"format\": \"byte\"\n        }\n      }\n    },\n    \"InactiveShardLogInfo\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"rootHash\",\n        \"treeSize\",\n        \"signedTreeHead\",\n        \"treeID\"\n      ],\n      \"properties\": {\n        \"rootHash\": {\n          \"description\": \"The current hash value stored at the root of the merkle tree\",\n          \"type\": \"string\",\n          \"pattern\": \"^[0-9a-fA-F]{64}$\"\n        },\n        \"signedTreeHead\": {\n          \"description\": \"The current signed tree head\",\n          \"type\": \"string\",\n          \"format\": \"signedCheckpoint\"\n        },\n        \"treeID\": {\n          \"description\": \"The current treeID\",\n          \"type\": \"string\",\n          \"pattern\": \"^[0-9]+$\"\n        },\n        \"treeSize\": {\n          \"description\": \"The current number of nodes in the merkle tree\",\n          \"type\": \"integer\",\n          \"minimum\": 1\n        }\n      }\n    },\n    \"InclusionProof\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"logIndex\",\n        \"rootHash\",\n        \"treeSize\",\n        \"hashes\",\n        \"checkpoint\"\n      ],\n      \"properties\": {\n        \"checkpoint\": {\n          \"description\": \"The checkpoint (signed tree head) that the inclusion proof is based on\",\n          \"type\": \"string\",\n          \"format\": \"signedCheckpoint\"\n        },\n        \"hashes\": {\n          \"description\": \"A list of hashes required to compute the inclusion proof, sorted in order from leaf to root\",\n          \"type\": \"array\",\n          \"items\": {\n            \"description\": \"SHA256 hash value expressed in hexadecimal format\",\n            \"type\": \"string\",\n            \"pattern\": \"^[0-9a-fA-F]{64}$\"\n          }\n        },\n        \"logIndex\": {\n          \"description\": \"The index of the entry in the transparency log\",\n          \"type\": \"integer\",\n          \"minimum\": 0\n        },\n        \"rootHash\": {\n          \"description\": \"The hash value stored at the root of the merkle tree at the time the proof was generated\",\n          \"type\": \"string\",\n          \"pattern\": \"^[0-9a-fA-F]{64}$\"\n        },\n        \"treeSize\": {\n          \"description\": \"The size of the merkle tree at the time the inclusion proof was generated\",\n          \"type\": \"integer\",\n          \"minimum\": 1\n        }\n      }\n    },\n    \"IntotoV001SchemaContent\": {\n      \"type\": \"object\",\n      \"properties\": {\n        \"envelope\": {\n          \"description\": \"envelope\",\n          \"type\": \"string\",\n          \"writeOnly\": true\n        },\n        \"hash\": {\n          \"description\": \"Specifies the hash algorithm and value encompassing the entire signed envelope; this is computed by the rekor server, client-provided values are ignored\",\n          \"type\": \"object\",\n          \"required\": [\n            \"algorithm\",\n            \"value\"\n          ],\n          \"properties\": {\n            \"algorithm\": {\n              \"description\": \"The hashing function used to compute the hash value\",\n              \"type\": \"string\",\n              \"enum\": [\n                \"sha256\"\n              ]\n            },\n            \"value\": {\n              \"description\": \"The hash value for the archive\",\n              \"type\": \"string\"\n            }\n          },\n          \"readOnly\": true\n        },\n        \"payloadHash\": {\n          \"description\": \"Specifies the hash algorithm and value covering the payload within the DSSE envelope; this is computed by the rekor server, client-provided values are ignored\",\n          \"type\": \"object\",\n          \"required\": [\n            \"algorithm\",\n            \"value\"\n          ],\n          \"properties\": {\n            \"algorithm\": {\n              \"description\": \"The hashing function used to compute the hash value\",\n              \"type\": \"string\",\n              \"enum\": [\n                \"sha256\"\n              ]\n            },\n            \"value\": {\n              \"description\": \"The hash value for the envelope's payload\",\n              \"type\": \"string\"\n            }\n          },\n          \"readOnly\": true\n        }\n      }\n    },\n    \"IntotoV001SchemaContentHash\": {\n      \"description\": \"Specifies the hash algorithm and value encompassing the entire signed envelope; this is computed by the rekor server, client-provided values are ignored\",\n      \"type\": \"object\",\n      \"required\": [\n        \"algorithm\",\n        \"value\"\n      ],\n      \"properties\": {\n        \"algorithm\": {\n          \"description\": \"The hashing function used to compute the hash value\",\n          \"type\": \"string\",\n          \"enum\": [\n            \"sha256\"\n          ]\n        },\n        \"value\": {\n          \"description\": \"The hash value for the archive\",\n          \"type\": \"string\"\n        }\n      },\n      \"readOnly\": true\n    },\n    \"IntotoV001SchemaContentPayloadHash\": {\n      \"description\": \"Specifies the hash algorithm and value covering the payload within the DSSE envelope; this is computed by the rekor server, client-provided values are ignored\",\n      \"type\": \"object\",\n      \"required\": [\n        \"algorithm\",\n        \"value\"\n      ],\n      \"properties\": {\n        \"algorithm\": {\n          \"description\": \"The hashing function used to compute the hash value\",\n          \"type\": \"string\",\n          \"enum\": [\n            \"sha256\"\n          ]\n        },\n        \"value\": {\n          \"description\": \"The hash value for the envelope's payload\",\n          \"type\": \"string\"\n        }\n      },\n      \"readOnly\": true\n    },\n    \"IntotoV002SchemaContent\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"envelope\"\n      ],\n      \"properties\": {\n        \"envelope\": {\n          \"description\": \"dsse envelope\",\n          \"type\": \"object\",\n          \"required\": [\n            \"payloadType\",\n            \"signatures\"\n          ],\n          \"properties\": {\n            \"payload\": {\n              \"description\": \"payload of the envelope\",\n              \"type\": \"string\",\n              \"format\": \"byte\",\n              \"writeOnly\": true\n            },\n            \"payloadType\": {\n              \"description\": \"type describing the payload\",\n              \"type\": \"string\"\n            },\n            \"signatures\": {\n              \"description\": \"collection of all signatures of the envelope's payload\",\n              \"type\": \"array\",\n              \"minItems\": 1,\n              \"items\": {\n                \"$ref\": \"#/definitions/IntotoV002SchemaContentEnvelopeSignaturesItems0\"\n              }\n            }\n          }\n        },\n        \"hash\": {\n          \"description\": \"Specifies the hash algorithm and value encompassing the entire signed envelope\",\n          \"type\": \"object\",\n          \"required\": [\n            \"algorithm\",\n            \"value\"\n          ],\n          \"properties\": {\n            \"algorithm\": {\n              \"description\": \"The hashing function used to compute the hash value\",\n              \"type\": \"string\",\n              \"enum\": [\n                \"sha256\"\n              ]\n            },\n            \"value\": {\n              \"description\": \"The hash value for the archive\",\n              \"type\": \"string\"\n            }\n          },\n          \"readOnly\": true\n        },\n        \"payloadHash\": {\n          \"description\": \"Specifies the hash algorithm and value covering the payload within the DSSE envelope\",\n          \"type\": \"object\",\n          \"required\": [\n            \"algorithm\",\n            \"value\"\n          ],\n          \"properties\": {\n            \"algorithm\": {\n              \"description\": \"The hashing function used to compute the hash value\",\n              \"type\": \"string\",\n              \"enum\": [\n                \"sha256\"\n              ]\n            },\n            \"value\": {\n              \"description\": \"The hash value of the payload\",\n              \"type\": \"string\"\n            }\n          },\n          \"readOnly\": true\n        }\n      }\n    },\n    \"IntotoV002SchemaContentEnvelope\": {\n      \"description\": \"dsse envelope\",\n      \"type\": \"object\",\n      \"required\": [\n        \"payloadType\",\n        \"signatures\"\n      ],\n      \"properties\": {\n        \"payload\": {\n          \"description\": \"payload of the envelope\",\n          \"type\": \"string\",\n          \"format\": \"byte\",\n          \"writeOnly\": true\n        },\n        \"payloadType\": {\n          \"description\": \"type describing the payload\",\n          \"type\": \"string\"\n        },\n        \"signatures\": {\n          \"description\": \"collection of all signatures of the envelope's payload\",\n          \"type\": \"array\",\n          \"minItems\": 1,\n          \"items\": {\n            \"$ref\": \"#/definitions/IntotoV002SchemaContentEnvelopeSignaturesItems0\"\n          }\n        }\n      }\n    },\n    \"IntotoV002SchemaContentEnvelopeSignaturesItems0\": {\n      \"description\": \"a signature of the envelope's payload along with the public key for the signature\",\n      \"type\": \"object\",\n      \"required\": [\n        \"sig\",\n        \"publicKey\"\n      ],\n      \"properties\": {\n        \"keyid\": {\n          \"description\": \"optional id of the key used to create the signature\",\n          \"type\": \"string\"\n        },\n        \"publicKey\": {\n          \"description\": \"public key that corresponds to this signature\",\n          \"type\": \"string\",\n          \"format\": \"byte\"\n        },\n        \"sig\": {\n          \"description\": \"signature of the payload\",\n          \"type\": \"string\",\n          \"format\": \"byte\"\n        }\n      }\n    },\n    \"IntotoV002SchemaContentHash\": {\n      \"description\": \"Specifies the hash algorithm and value encompassing the entire signed envelope\",\n      \"type\": \"object\",\n      \"required\": [\n        \"algorithm\",\n        \"value\"\n      ],\n      \"properties\": {\n        \"algorithm\": {\n          \"description\": \"The hashing function used to compute the hash value\",\n          \"type\": \"string\",\n          \"enum\": [\n            \"sha256\"\n          ]\n        },\n        \"value\": {\n          \"description\": \"The hash value for the archive\",\n          \"type\": \"string\"\n        }\n      },\n      \"readOnly\": true\n    },\n    \"IntotoV002SchemaContentPayloadHash\": {\n      \"description\": \"Specifies the hash algorithm and value covering the payload within the DSSE envelope\",\n      \"type\": \"object\",\n      \"required\": [\n        \"algorithm\",\n        \"value\"\n      ],\n      \"properties\": {\n        \"algorithm\": {\n          \"description\": \"The hashing function used to compute the hash value\",\n          \"type\": \"string\",\n          \"enum\": [\n            \"sha256\"\n          ]\n        },\n        \"value\": {\n          \"description\": \"The hash value of the payload\",\n          \"type\": \"string\"\n        }\n      },\n      \"readOnly\": true\n    },\n    \"JarV001SchemaArchive\": {\n      \"description\": \"Information about the archive associated with the entry\",\n      \"type\": \"object\",\n      \"oneOf\": [\n        {\n          \"required\": [\n            \"hash\"\n          ]\n        },\n        {\n          \"required\": [\n            \"content\"\n          ]\n        }\n      ],\n      \"properties\": {\n        \"content\": {\n          \"description\": \"Specifies the archive inline within the document\",\n          \"type\": \"string\",\n          \"format\": \"byte\",\n          \"writeOnly\": true\n        },\n        \"hash\": {\n          \"description\": \"Specifies the hash algorithm and value encompassing the entire signed archive\",\n          \"type\": \"object\",\n          \"required\": [\n            \"algorithm\",\n            \"value\"\n          ],\n          \"properties\": {\n            \"algorithm\": {\n              \"description\": \"The hashing function used to compute the hash value\",\n              \"type\": \"string\",\n              \"enum\": [\n                \"sha256\"\n              ]\n            },\n            \"value\": {\n              \"description\": \"The hash value for the archive\",\n              \"type\": \"string\"\n            }\n          }\n        }\n      }\n    },\n    \"JarV001SchemaArchiveHash\": {\n      \"description\": \"Specifies the hash algorithm and value encompassing the entire signed archive\",\n      \"type\": \"object\",\n      \"required\": [\n        \"algorithm\",\n        \"value\"\n      ],\n      \"properties\": {\n        \"algorithm\": {\n          \"description\": \"The hashing function used to compute the hash value\",\n          \"type\": \"string\",\n          \"enum\": [\n            \"sha256\"\n          ]\n        },\n        \"value\": {\n          \"description\": \"The hash value for the archive\",\n          \"type\": \"string\"\n        }\n      }\n    },\n    \"JarV001SchemaSignature\": {\n      \"description\": \"Information about the included signature in the JAR file\",\n      \"type\": \"object\",\n      \"required\": [\n        \"publicKey\",\n        \"content\"\n      ],\n      \"properties\": {\n        \"content\": {\n          \"description\": \"Specifies the PKCS7 signature embedded within the JAR file \",\n          \"type\": \"string\",\n          \"format\": \"byte\",\n          \"readOnly\": true\n        },\n        \"publicKey\": {\n          \"description\": \"The X509 certificate containing the public key JAR which verifies the signature of the JAR\",\n          \"type\": \"object\",\n          \"required\": [\n            \"content\"\n          ],\n          \"properties\": {\n            \"content\": {\n              \"description\": \"Specifies the content of the X509 certificate containing the public key used to verify the signature\",\n              \"type\": \"string\",\n              \"format\": \"byte\"\n            }\n          },\n          \"readOnly\": true\n        }\n      }\n    },\n    \"JarV001SchemaSignaturePublicKey\": {\n      \"description\": \"The X509 certificate containing the public key JAR which verifies the signature of the JAR\",\n      \"type\": \"object\",\n      \"required\": [\n        \"content\"\n      ],\n      \"properties\": {\n        \"content\": {\n          \"description\": \"Specifies the content of the X509 certificate containing the public key used to verify the signature\",\n          \"type\": \"string\",\n          \"format\": \"byte\"\n        }\n      },\n      \"readOnly\": true\n    },\n    \"LogEntry\": {\n      \"type\": \"object\",\n      \"additionalProperties\": {\n        \"$ref\": \"#/definitions/LogEntryAnon\"\n      }\n    },\n    \"LogEntryAnon\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"logID\",\n        \"logIndex\",\n        \"body\",\n        \"integratedTime\"\n      ],\n      \"properties\": {\n        \"attestation\": {\n          \"type\": \"object\",\n          \"format\": \"byte\",\n          \"properties\": {\n            \"data\": {\n              \"format\": \"byte\"\n            }\n          }\n        },\n        \"body\": {\n          \"type\": \"object\",\n          \"additionalProperties\": true\n        },\n        \"integratedTime\": {\n          \"type\": \"integer\"\n        },\n        \"logID\": {\n          \"description\": \"This is the SHA256 hash of the DER-encoded public key for the log at the time the entry was included in the log\",\n          \"type\": \"string\",\n          \"pattern\": \"^[0-9a-fA-F]{64}$\"\n        },\n        \"logIndex\": {\n          \"type\": \"integer\",\n          \"minimum\": 0\n        },\n        \"verification\": {\n          \"type\": \"object\",\n          \"properties\": {\n            \"inclusionProof\": {\n              \"$ref\": \"#/definitions/InclusionProof\"\n            },\n            \"signedEntryTimestamp\": {\n              \"description\": \"Signature over the logID, logIndex, body and integratedTime.\",\n              \"type\": \"string\",\n              \"format\": \"byte\"\n            }\n          }\n        }\n      }\n    },\n    \"LogEntryAnonAttestation\": {\n      \"type\": \"object\",\n      \"format\": \"byte\",\n      \"properties\": {\n        \"data\": {\n          \"format\": \"byte\"\n        }\n      }\n    },\n    \"LogEntryAnonVerification\": {\n      \"type\": \"object\",\n      \"properties\": {\n        \"inclusionProof\": {\n          \"$ref\": \"#/definitions/InclusionProof\"\n        },\n        \"signedEntryTimestamp\": {\n          \"description\": \"Signature over the logID, logIndex, body and integratedTime.\",\n          \"type\": \"string\",\n          \"format\": \"byte\"\n        }\n      }\n    },\n    \"LogInfo\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"rootHash\",\n        \"treeSize\",\n        \"signedTreeHead\",\n        \"treeID\"\n      ],\n      \"properties\": {\n        \"inactiveShards\": {\n          \"type\": \"array\",\n          \"items\": {\n            \"$ref\": \"#/definitions/InactiveShardLogInfo\"\n          }\n        },\n        \"rootHash\": {\n          \"description\": \"The current hash value stored at the root of the merkle tree\",\n          \"type\": \"string\",\n          \"pattern\": \"^[0-9a-fA-F]{64}$\"\n        },\n        \"signedTreeHead\": {\n          \"description\": \"The current signed tree head\",\n          \"type\": \"string\",\n          \"format\": \"signedCheckpoint\"\n        },\n        \"treeID\": {\n          \"description\": \"The current treeID\",\n          \"type\": \"string\",\n          \"pattern\": \"^[0-9]+$\"\n        },\n        \"treeSize\": {\n          \"description\": \"The current number of nodes in the merkle tree\",\n          \"type\": \"integer\",\n          \"minimum\": 1\n        }\n      }\n    },\n    \"ProposedEntry\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"kind\"\n      ],\n      \"properties\": {\n        \"kind\": {\n          \"type\": \"string\"\n        }\n      },\n      \"discriminator\": \"kind\"\n    },\n    \"RekordV001SchemaData\": {\n      \"description\": \"Information about the content associated with the entry\",\n      \"type\": \"object\",\n      \"oneOf\": [\n        {\n          \"required\": [\n            \"hash\"\n          ]\n        },\n        {\n          \"required\": [\n            \"content\"\n          ]\n        }\n      ],\n      \"properties\": {\n        \"content\": {\n          \"description\": \"Specifies the content inline within the document\",\n          \"type\": \"string\",\n          \"format\": \"byte\",\n          \"writeOnly\": true\n        },\n        \"hash\": {\n          \"description\": \"Specifies the hash algorithm and value for the content\",\n          \"type\": \"object\",\n          \"required\": [\n            \"algorithm\",\n            \"value\"\n          ],\n          \"properties\": {\n            \"algorithm\": {\n              \"description\": \"The hashing function used to compute the hash value\",\n              \"type\": \"string\",\n              \"enum\": [\n                \"sha256\"\n              ]\n            },\n            \"value\": {\n              \"description\": \"The hash value for the content\",\n              \"type\": \"string\"\n            }\n          },\n          \"readOnly\": true\n        }\n      }\n    },\n    \"RekordV001SchemaDataHash\": {\n      \"description\": \"Specifies the hash algorithm and value for the content\",\n      \"type\": \"object\",\n      \"required\": [\n        \"algorithm\",\n        \"value\"\n      ],\n      \"properties\": {\n        \"algorithm\": {\n          \"description\": \"The hashing function used to compute the hash value\",\n          \"type\": \"string\",\n          \"enum\": [\n            \"sha256\"\n          ]\n        },\n        \"value\": {\n          \"description\": \"The hash value for the content\",\n          \"type\": \"string\"\n        }\n      },\n      \"readOnly\": true\n    },\n    \"RekordV001SchemaSignature\": {\n      \"description\": \"Information about the detached signature associated with the entry\",\n      \"type\": \"object\",\n      \"required\": [\n        \"format\",\n        \"publicKey\",\n        \"content\"\n      ],\n      \"properties\": {\n        \"content\": {\n          \"description\": \"Specifies the content of the signature inline within the document\",\n          \"type\": \"string\",\n          \"format\": \"byte\"\n        },\n        \"format\": {\n          \"description\": \"Specifies the format of the signature\",\n          \"type\": \"string\",\n          \"enum\": [\n            \"pgp\",\n            \"minisign\",\n            \"x509\",\n            \"ssh\"\n          ]\n        },\n        \"publicKey\": {\n          \"description\": \"The public key that can verify the signature\",\n          \"type\": \"object\",\n          \"required\": [\n            \"content\"\n          ],\n          \"properties\": {\n            \"content\": {\n              \"description\": \"Specifies the content of the public key inline within the document\",\n              \"type\": \"string\",\n              \"format\": \"byte\"\n            }\n          }\n        }\n      }\n    },\n    \"RekordV001SchemaSignaturePublicKey\": {\n      \"description\": \"The public key that can verify the signature\",\n      \"type\": \"object\",\n      \"required\": [\n        \"content\"\n      ],\n      \"properties\": {\n        \"content\": {\n          \"description\": \"Specifies the content of the public key inline within the document\",\n          \"type\": \"string\",\n          \"format\": \"byte\"\n        }\n      }\n    },\n    \"Rfc3161V001SchemaTsr\": {\n      \"description\": \"Information about the tsr file associated with the entry\",\n      \"type\": \"object\",\n      \"required\": [\n        \"content\"\n      ],\n      \"properties\": {\n        \"content\": {\n          \"description\": \"Specifies the tsr file content inline within the document\",\n          \"type\": \"string\",\n          \"format\": \"byte\"\n        }\n      }\n    },\n    \"RpmV001SchemaPackage\": {\n      \"description\": \"Information about the package associated with the entry\",\n      \"type\": \"object\",\n      \"oneOf\": [\n        {\n          \"required\": [\n            \"hash\"\n          ]\n        },\n        {\n          \"required\": [\n            \"content\"\n          ]\n        }\n      ],\n      \"properties\": {\n        \"content\": {\n          \"description\": \"Specifies the package inline within the document\",\n          \"type\": \"string\",\n          \"format\": \"byte\",\n          \"writeOnly\": true\n        },\n        \"hash\": {\n          \"description\": \"Specifies the hash algorithm and value for the package\",\n          \"type\": \"object\",\n          \"required\": [\n            \"algorithm\",\n            \"value\"\n          ],\n          \"properties\": {\n            \"algorithm\": {\n              \"description\": \"The hashing function used to compute the hash value\",\n              \"type\": \"string\",\n              \"enum\": [\n                \"sha256\"\n              ]\n            },\n            \"value\": {\n              \"description\": \"The hash value for the package\",\n              \"type\": \"string\"\n            }\n          }\n        },\n        \"headers\": {\n          \"description\": \"Values of the RPM headers\",\n          \"type\": \"object\",\n          \"additionalProperties\": {\n            \"type\": \"string\"\n          },\n          \"readOnly\": true\n        }\n      }\n    },\n    \"RpmV001SchemaPackageHash\": {\n      \"description\": \"Specifies the hash algorithm and value for the package\",\n      \"type\": \"object\",\n      \"required\": [\n        \"algorithm\",\n        \"value\"\n      ],\n      \"properties\": {\n        \"algorithm\": {\n          \"description\": \"The hashing function used to compute the hash value\",\n          \"type\": \"string\",\n          \"enum\": [\n            \"sha256\"\n          ]\n        },\n        \"value\": {\n          \"description\": \"The hash value for the package\",\n          \"type\": \"string\"\n        }\n      }\n    },\n    \"RpmV001SchemaPublicKey\": {\n      \"description\": \"The PGP public key that can verify the RPM signature\",\n      \"type\": \"object\",\n      \"required\": [\n        \"content\"\n      ],\n      \"properties\": {\n        \"content\": {\n          \"description\": \"Specifies the content of the public key inline within the document\",\n          \"type\": \"string\",\n          \"format\": \"byte\"\n        }\n      }\n    },\n    \"SearchIndex\": {\n      \"type\": \"object\",\n      \"properties\": {\n        \"email\": {\n          \"type\": \"string\",\n          \"format\": \"email\"\n        },\n        \"hash\": {\n          \"type\": \"string\",\n          \"pattern\": \"^(sha512:)?[0-9a-fA-F]{128}$|^(sha256:)?[0-9a-fA-F]{64}$|^(sha1:)?[0-9a-fA-F]{40}$\"\n        },\n        \"operator\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"and\",\n            \"or\"\n          ]\n        },\n        \"publicKey\": {\n          \"type\": \"object\",\n          \"required\": [\n            \"format\"\n          ],\n          \"properties\": {\n            \"content\": {\n              \"type\": \"string\",\n              \"format\": \"byte\"\n            },\n            \"format\": {\n              \"type\": \"string\",\n              \"enum\": [\n                \"pgp\",\n                \"x509\",\n                \"minisign\",\n                \"ssh\",\n                \"tuf\"\n              ]\n            },\n            \"url\": {\n              \"type\": \"string\",\n              \"format\": \"uri\"\n            }\n          }\n        }\n      }\n    },\n    \"SearchIndexPublicKey\": {\n      \"type\": \"object\",\n      \"required\": [\n        \"format\"\n      ],\n      \"properties\": {\n        \"content\": {\n          \"type\": \"string\",\n          \"format\": \"byte\"\n        },\n        \"format\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"pgp\",\n            \"x509\",\n            \"minisign\",\n            \"ssh\",\n            \"tuf\"\n          ]\n        },\n        \"url\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        }\n      }\n    },\n    \"SearchLogQuery\": {\n      \"type\": \"object\",\n      \"properties\": {\n        \"entries\": {\n          \"type\": \"array\",\n          \"maxItems\": 10,\n          \"minItems\": 1,\n          \"items\": {\n            \"$ref\": \"#/definitions/ProposedEntry\"\n          }\n        },\n        \"entryUUIDs\": {\n          \"type\": \"array\",\n          \"maxItems\": 10,\n          \"minItems\": 1,\n          \"items\": {\n            \"type\": \"string\",\n            \"pattern\": \"^([0-9a-fA-F]{64}|[0-9a-fA-F]{80})$\"\n          }\n        },\n        \"logIndexes\": {\n          \"type\": \"array\",\n          \"maxItems\": 10,\n          \"minItems\": 1,\n          \"items\": {\n            \"type\": \"integer\",\n            \"minimum\": 0\n          }\n        }\n      }\n    },\n    \"TUFV001SchemaMetadata\": {\n      \"description\": \"TUF metadata\",\n      \"type\": \"object\",\n      \"required\": [\n        \"content\"\n      ],\n      \"properties\": {\n        \"content\": {\n          \"description\": \"Specifies the metadata inline within the document\",\n          \"type\": \"object\",\n          \"additionalProperties\": true\n        }\n      }\n    },\n    \"TUFV001SchemaRoot\": {\n      \"description\": \"root metadata containing about the public keys used to sign the manifest\",\n      \"type\": \"object\",\n      \"required\": [\n        \"content\"\n      ],\n      \"properties\": {\n        \"content\": {\n          \"description\": \"Specifies the metadata inline within the document\",\n          \"type\": \"object\",\n          \"additionalProperties\": true\n        }\n      }\n    },\n    \"alpine\": {\n      \"description\": \"Alpine package\",\n      \"type\": \"object\",\n      \"allOf\": [\n        {\n          \"$ref\": \"#/definitions/ProposedEntry\"\n        },\n        {\n          \"required\": [\n            \"apiVersion\",\n            \"spec\"\n          ],\n          \"properties\": {\n            \"apiVersion\": {\n              \"type\": \"string\",\n              \"pattern\": \"^(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)(?:-((?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\\\.(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\\\+([0-9a-zA-Z-]+(?:\\\\.[0-9a-zA-Z-]+)*))?$\"\n            },\n            \"spec\": {\n              \"$ref\": \"#/definitions/alpineSchema\"\n            }\n          },\n          \"additionalProperties\": false\n        }\n      ]\n    },\n    \"alpineSchema\": {\n      \"description\": \"Schema for Alpine package objects\",\n      \"type\": \"object\",\n      \"title\": \"Alpine Package Schema\",\n      \"oneOf\": [\n        {\n          \"$ref\": \"#/definitions/alpineV001Schema\"\n        }\n      ],\n      \"$schema\": \"http://json-schema.org/draft-07/schema\",\n      \"$id\": \"http://rekor.sigstore.dev/types/alpine/alpine_schema.json\"\n    },\n    \"alpineV001Schema\": {\n      \"description\": \"Schema for Alpine Package entries\",\n      \"type\": \"object\",\n      \"title\": \"Alpine v0.0.1 Schema\",\n      \"required\": [\n        \"publicKey\",\n        \"package\"\n      ],\n      \"properties\": {\n        \"package\": {\n          \"description\": \"Information about the package associated with the entry\",\n          \"type\": \"object\",\n          \"oneOf\": [\n            {\n              \"required\": [\n                \"hash\"\n              ]\n            },\n            {\n              \"required\": [\n                \"content\"\n              ]\n            }\n          ],\n          \"properties\": {\n            \"content\": {\n              \"description\": \"Specifies the package inline within the document\",\n              \"type\": \"string\",\n              \"format\": \"byte\",\n              \"writeOnly\": true\n            },\n            \"hash\": {\n              \"description\": \"Specifies the hash algorithm and value for the package\",\n              \"type\": \"object\",\n              \"required\": [\n                \"algorithm\",\n                \"value\"\n              ],\n              \"properties\": {\n                \"algorithm\": {\n                  \"description\": \"The hashing function used to compute the hash value\",\n                  \"type\": \"string\",\n                  \"enum\": [\n                    \"sha256\"\n                  ]\n                },\n                \"value\": {\n                  \"description\": \"The hash value for the package\",\n                  \"type\": \"string\"\n                }\n              },\n              \"readOnly\": true\n            },\n            \"pkginfo\": {\n              \"description\": \"Values of the .PKGINFO key / value pairs\",\n              \"type\": \"object\",\n              \"additionalProperties\": {\n                \"type\": \"string\"\n              },\n              \"readOnly\": true\n            }\n          }\n        },\n        \"publicKey\": {\n          \"description\": \"The public key that can verify the package signature\",\n          \"type\": \"object\",\n          \"required\": [\n            \"content\"\n          ],\n          \"properties\": {\n            \"content\": {\n              \"description\": \"Specifies the content of the public key inline within the document\",\n              \"type\": \"string\",\n              \"format\": \"byte\"\n            }\n          }\n        }\n      },\n      \"$schema\": \"http://json-schema.org/draft-07/schema\",\n      \"$id\": \"http://rekor.sigstore.dev/types/alpine/alpine_v0_0_1_schema.json\"\n    },\n    \"cose\": {\n      \"description\": \"COSE object\",\n      \"type\": \"object\",\n      \"allOf\": [\n        {\n          \"$ref\": \"#/definitions/ProposedEntry\"\n        },\n        {\n          \"required\": [\n            \"apiVersion\",\n            \"spec\"\n          ],\n          \"properties\": {\n            \"apiVersion\": {\n              \"type\": \"string\",\n              \"pattern\": \"^(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)(?:-((?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\\\.(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\\\+([0-9a-zA-Z-]+(?:\\\\.[0-9a-zA-Z-]+)*))?$\"\n            },\n            \"spec\": {\n              \"$ref\": \"#/definitions/coseSchema\"\n            }\n          },\n          \"additionalProperties\": false\n        }\n      ]\n    },\n    \"coseSchema\": {\n      \"description\": \"COSE for Rekord objects\",\n      \"type\": \"object\",\n      \"title\": \"COSE Schema\",\n      \"oneOf\": [\n        {\n          \"$ref\": \"#/definitions/coseV001Schema\"\n        }\n      ],\n      \"$schema\": \"http://json-schema.org/draft-07/schema\",\n      \"$id\": \"http://rekor.sigstore.dev/types/cose/cose_schema.json\"\n    },\n    \"coseV001Schema\": {\n      \"description\": \"Schema for cose object\",\n      \"type\": \"object\",\n      \"title\": \"cose v0.0.1 Schema\",\n      \"required\": [\n        \"publicKey\",\n        \"data\"\n      ],\n      \"properties\": {\n        \"data\": {\n          \"description\": \"Information about the content associated with the entry\",\n          \"type\": \"object\",\n          \"properties\": {\n            \"aad\": {\n              \"description\": \"Specifies the additional authenticated data required to verify the signature\",\n              \"type\": \"string\",\n              \"format\": \"byte\",\n              \"writeOnly\": true\n            },\n            \"envelopeHash\": {\n              \"description\": \"Specifies the hash algorithm and value for the COSE envelope\",\n              \"type\": \"object\",\n              \"required\": [\n                \"algorithm\",\n                \"value\"\n              ],\n              \"properties\": {\n                \"algorithm\": {\n                  \"description\": \"The hashing function used to compute the hash value\",\n                  \"type\": \"string\",\n                  \"enum\": [\n                    \"sha256\"\n                  ]\n                },\n                \"value\": {\n                  \"description\": \"The hash value for the envelope\",\n                  \"type\": \"string\"\n                }\n              },\n              \"readOnly\": true\n            },\n            \"payloadHash\": {\n              \"description\": \"Specifies the hash algorithm and value for the content\",\n              \"type\": \"object\",\n              \"required\": [\n                \"algorithm\",\n                \"value\"\n              ],\n              \"properties\": {\n                \"algorithm\": {\n                  \"description\": \"The hashing function used to compute the hash value\",\n                  \"type\": \"string\",\n                  \"enum\": [\n                    \"sha256\"\n                  ]\n                },\n                \"value\": {\n                  \"description\": \"The hash value for the content\",\n                  \"type\": \"string\"\n                }\n              },\n              \"readOnly\": true\n            }\n          }\n        },\n        \"message\": {\n          \"description\": \"The COSE Sign1 Message\",\n          \"type\": \"string\",\n          \"format\": \"byte\",\n          \"writeOnly\": true\n        },\n        \"publicKey\": {\n          \"description\": \"The public key that can verify the signature\",\n          \"type\": \"string\",\n          \"format\": \"byte\"\n        }\n      },\n      \"$schema\": \"http://json-schema.org/draft-07/schema\",\n      \"$id\": \"http://rekor.sigstore.dev/types/cose/cose_v0_0_1_schema.json\"\n    },\n    \"dsse\": {\n      \"description\": \"DSSE envelope\",\n      \"type\": \"object\",\n      \"allOf\": [\n        {\n          \"$ref\": \"#/definitions/ProposedEntry\"\n        },\n        {\n          \"required\": [\n            \"apiVersion\",\n            \"spec\"\n          ],\n          \"properties\": {\n            \"apiVersion\": {\n              \"type\": \"string\",\n              \"pattern\": \"^(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)(?:-((?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\\\.(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\\\+([0-9a-zA-Z-]+(?:\\\\.[0-9a-zA-Z-]+)*))?$\"\n            },\n            \"spec\": {\n              \"$ref\": \"#/definitions/dsseSchema\"\n            }\n          },\n          \"additionalProperties\": false\n        }\n      ]\n    },\n    \"dsseSchema\": {\n      \"description\": \"log entry schema for dsse envelopes\",\n      \"type\": \"object\",\n      \"title\": \"DSSE Schema\",\n      \"oneOf\": [\n        {\n          \"$ref\": \"#/definitions/dsseV001Schema\"\n        }\n      ],\n      \"$schema\": \"http://json-schema.org/draft-07/schema\",\n      \"$id\": \"http://rekor.sigstore.dev/types/dsse/dsse_schema.json\"\n    },\n    \"dsseV001Schema\": {\n      \"description\": \"Schema for DSSE envelopes\",\n      \"type\": \"object\",\n      \"title\": \"DSSE v0.0.1 Schema\",\n      \"oneOf\": [\n        {\n          \"required\": [\n            \"proposedContent\"\n          ]\n        },\n        {\n          \"required\": [\n            \"signatures\",\n            \"envelopeHash\",\n            \"payloadHash\"\n          ]\n        }\n      ],\n      \"properties\": {\n        \"envelopeHash\": {\n          \"description\": \"Specifies the hash algorithm and value encompassing the entire envelope sent to Rekor\",\n          \"type\": \"object\",\n          \"required\": [\n            \"algorithm\",\n            \"value\"\n          ],\n          \"properties\": {\n            \"algorithm\": {\n              \"description\": \"The hashing function used to compute the hash value\",\n              \"type\": \"string\",\n              \"enum\": [\n                \"sha256\"\n              ]\n            },\n            \"value\": {\n              \"description\": \"The value of the computed digest over the entire envelope\",\n              \"type\": \"string\"\n            }\n          },\n          \"readOnly\": true\n        },\n        \"payloadHash\": {\n          \"description\": \"Specifies the hash algorithm and value covering the payload within the DSSE envelope\",\n          \"type\": \"object\",\n          \"required\": [\n            \"algorithm\",\n            \"value\"\n          ],\n          \"properties\": {\n            \"algorithm\": {\n              \"description\": \"The hashing function used to compute the hash value\",\n              \"type\": \"string\",\n              \"enum\": [\n                \"sha256\"\n              ]\n            },\n            \"value\": {\n              \"description\": \"The value of the computed digest over the payload within the envelope\",\n              \"type\": \"string\"\n            }\n          },\n          \"readOnly\": true\n        },\n        \"proposedContent\": {\n          \"type\": \"object\",\n          \"required\": [\n            \"envelope\",\n            \"verifiers\"\n          ],\n          \"properties\": {\n            \"envelope\": {\n              \"description\": \"DSSE envelope specified as a stringified JSON object\",\n              \"type\": \"string\",\n              \"writeOnly\": true\n            },\n            \"verifiers\": {\n              \"description\": \"collection of all verification material (e.g. public keys or certificates) used to verify signatures over envelope's payload, specified as base64-encoded strings\",\n              \"type\": \"array\",\n              \"minItems\": 1,\n              \"items\": {\n                \"type\": \"string\",\n                \"format\": \"byte\"\n              },\n              \"writeOnly\": true\n            }\n          },\n          \"writeOnly\": true\n        },\n        \"signatures\": {\n          \"description\": \"extracted collection of all signatures of the envelope's payload; elements will be sorted by lexicographical order of the base64 encoded signature strings\",\n          \"type\": \"array\",\n          \"minItems\": 1,\n          \"items\": {\n            \"$ref\": \"#/definitions/DSSEV001SchemaSignaturesItems0\"\n          },\n          \"readOnly\": true\n        }\n      },\n      \"$schema\": \"http://json-schema.org/draft-07/schema\",\n      \"$id\": \"http://rekor.sigstore.dev/types/dsse/dsse_v0_0_1_schema.json\"\n    },\n    \"hashedrekord\": {\n      \"description\": \"Hashed Rekord object\",\n      \"type\": \"object\",\n      \"allOf\": [\n        {\n          \"$ref\": \"#/definitions/ProposedEntry\"\n        },\n        {\n          \"required\": [\n            \"apiVersion\",\n            \"spec\"\n          ],\n          \"properties\": {\n            \"apiVersion\": {\n              \"type\": \"string\",\n              \"pattern\": \"^(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)(?:-((?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\\\.(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\\\+([0-9a-zA-Z-]+(?:\\\\.[0-9a-zA-Z-]+)*))?$\"\n            },\n            \"spec\": {\n              \"$ref\": \"#/definitions/hashedrekordSchema\"\n            }\n          },\n          \"additionalProperties\": false\n        }\n      ]\n    },\n    \"hashedrekordSchema\": {\n      \"description\": \"Schema for Rekord objects\",\n      \"type\": \"object\",\n      \"title\": \"Rekor Schema\",\n      \"oneOf\": [\n        {\n          \"$ref\": \"#/definitions/hashedrekordV001Schema\"\n        }\n      ],\n      \"$schema\": \"http://json-schema.org/draft-07/schema\",\n      \"$id\": \"http://rekor.sigstore.dev/types/hashedrekord/hasehedrekord_schema.json\"\n    },\n    \"hashedrekordV001Schema\": {\n      \"description\": \"Schema for Hashed Rekord object\",\n      \"type\": \"object\",\n      \"title\": \"Hashed Rekor v0.0.1 Schema\",\n      \"required\": [\n        \"signature\",\n        \"data\"\n      ],\n      \"properties\": {\n        \"data\": {\n          \"description\": \"Information about the content associated with the entry\",\n          \"type\": \"object\",\n          \"properties\": {\n            \"hash\": {\n              \"description\": \"Specifies the hash algorithm and value for the content\",\n              \"type\": \"object\",\n              \"required\": [\n                \"algorithm\",\n                \"value\"\n              ],\n              \"properties\": {\n                \"algorithm\": {\n                  \"description\": \"The hashing function used to compute the hash value\",\n                  \"type\": \"string\",\n                  \"enum\": [\n                    \"sha256\"\n                  ]\n                },\n                \"value\": {\n                  \"description\": \"The hash value for the content\",\n                  \"type\": \"string\"\n                }\n              }\n            }\n          }\n        },\n        \"signature\": {\n          \"description\": \"Information about the detached signature associated with the entry\",\n          \"type\": \"object\",\n          \"properties\": {\n            \"content\": {\n              \"description\": \"Specifies the content of the signature inline within the document\",\n              \"type\": \"string\",\n              \"format\": \"byte\"\n            },\n            \"publicKey\": {\n              \"description\": \"The public key that can verify the signature; this can also be an X509 code signing certificate that contains the raw public key information\",\n              \"type\": \"object\",\n              \"properties\": {\n                \"content\": {\n                  \"description\": \"Specifies the content of the public key or code signing certificate inline within the document\",\n                  \"type\": \"string\",\n                  \"format\": \"byte\"\n                }\n              }\n            }\n          }\n        }\n      },\n      \"$schema\": \"http://json-schema.org/draft-07/schema\",\n      \"$id\": \"http://rekor.sigstore.dev/types/rekord/rekord_v0_0_1_schema.json\"\n    },\n    \"helm\": {\n      \"description\": \"Helm chart\",\n      \"type\": \"object\",\n      \"allOf\": [\n        {\n          \"$ref\": \"#/definitions/ProposedEntry\"\n        },\n        {\n          \"required\": [\n            \"apiVersion\",\n            \"spec\"\n          ],\n          \"properties\": {\n            \"apiVersion\": {\n              \"type\": \"string\",\n              \"pattern\": \"^(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)(?:-((?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\\\.(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\\\+([0-9a-zA-Z-]+(?:\\\\.[0-9a-zA-Z-]+)*))?$\"\n            },\n            \"spec\": {\n              \"$ref\": \"#/definitions/helmSchema\"\n            }\n          }\n        }\n      ]\n    },\n    \"helmSchema\": {\n      \"description\": \"Schema for Helm objects\",\n      \"type\": \"object\",\n      \"title\": \"Helm Schema\",\n      \"oneOf\": [\n        {\n          \"$ref\": \"#/definitions/helmV001Schema\"\n        }\n      ],\n      \"$schema\": \"http://json-schema.org/draft-07/schema\",\n      \"$id\": \"http://rekor.sigstore.dev/types/helm/helm_schema.json\"\n    },\n    \"helmV001Schema\": {\n      \"description\": \"Schema for Helm object\",\n      \"type\": \"object\",\n      \"title\": \"Helm v0.0.1 Schema\",\n      \"required\": [\n        \"publicKey\",\n        \"chart\"\n      ],\n      \"properties\": {\n        \"chart\": {\n          \"description\": \"Information about the Helm chart associated with the entry\",\n          \"type\": \"object\",\n          \"required\": [\n            \"provenance\"\n          ],\n          \"properties\": {\n            \"hash\": {\n              \"description\": \"Specifies the hash algorithm and value for the chart\",\n              \"type\": \"object\",\n              \"required\": [\n                \"algorithm\",\n                \"value\"\n              ],\n              \"properties\": {\n                \"algorithm\": {\n                  \"description\": \"The hashing function used to compute the hash value\",\n                  \"type\": \"string\",\n                  \"enum\": [\n                    \"sha256\"\n                  ]\n                },\n                \"value\": {\n                  \"description\": \"The hash value for the chart\",\n                  \"type\": \"string\"\n                }\n              },\n              \"readOnly\": true\n            },\n            \"provenance\": {\n              \"description\": \"The provenance entry associated with the signed Helm Chart\",\n              \"type\": \"object\",\n              \"oneOf\": [\n                {\n                  \"required\": [\n                    \"signature\"\n                  ]\n                },\n                {\n                  \"required\": [\n                    \"content\"\n                  ]\n                }\n              ],\n              \"properties\": {\n                \"content\": {\n                  \"description\": \"Specifies the content of the provenance file inline within the document\",\n                  \"type\": \"string\",\n                  \"format\": \"byte\",\n                  \"writeOnly\": true\n                },\n                \"signature\": {\n                  \"description\": \"Information about the included signature in the provenance file\",\n                  \"type\": \"object\",\n                  \"required\": [\n                    \"content\"\n                  ],\n                  \"properties\": {\n                    \"content\": {\n                      \"description\": \"Specifies the signature embedded within the provenance file \",\n                      \"type\": \"string\",\n                      \"format\": \"byte\",\n                      \"readOnly\": true\n                    }\n                  },\n                  \"readOnly\": true\n                }\n              }\n            }\n          }\n        },\n        \"publicKey\": {\n          \"description\": \"The public key that can verify the package signature\",\n          \"type\": \"object\",\n          \"required\": [\n            \"content\"\n          ],\n          \"properties\": {\n            \"content\": {\n              \"description\": \"Specifies the content of the public key inline within the document\",\n              \"type\": \"string\",\n              \"format\": \"byte\"\n            }\n          }\n        }\n      },\n      \"$schema\": \"http://json-schema.org/draft-07/schema\",\n      \"$id\": \"http://rekor.sigstore.dev/types/helm/helm_v0_0_1_schema.json\"\n    },\n    \"intoto\": {\n      \"description\": \"Intoto object\",\n      \"type\": \"object\",\n      \"allOf\": [\n        {\n          \"$ref\": \"#/definitions/ProposedEntry\"\n        },\n        {\n          \"required\": [\n            \"apiVersion\",\n            \"spec\"\n          ],\n          \"properties\": {\n            \"apiVersion\": {\n              \"type\": \"string\",\n              \"pattern\": \"^(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)(?:-((?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\\\.(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\\\+([0-9a-zA-Z-]+(?:\\\\.[0-9a-zA-Z-]+)*))?$\"\n            },\n            \"spec\": {\n              \"$ref\": \"#/definitions/intotoSchema\"\n            }\n          },\n          \"additionalProperties\": false\n        }\n      ]\n    },\n    \"intotoSchema\": {\n      \"description\": \"Intoto for Rekord objects\",\n      \"type\": \"object\",\n      \"title\": \"Intoto Schema\",\n      \"oneOf\": [\n        {\n          \"$ref\": \"#/definitions/intotoV001Schema\"\n        },\n        {\n          \"$ref\": \"#/definitions/intotoV002Schema\"\n        }\n      ],\n      \"$schema\": \"http://json-schema.org/draft-07/schema\",\n      \"$id\": \"http://rekor.sigstore.dev/types/intoto/intoto_schema.json\"\n    },\n    \"intotoV001Schema\": {\n      \"description\": \"Schema for intoto object\",\n      \"type\": \"object\",\n      \"title\": \"intoto v0.0.1 Schema\",\n      \"required\": [\n        \"publicKey\",\n        \"content\"\n      ],\n      \"properties\": {\n        \"content\": {\n          \"type\": \"object\",\n          \"properties\": {\n            \"envelope\": {\n              \"description\": \"envelope\",\n              \"type\": \"string\",\n              \"writeOnly\": true\n            },\n            \"hash\": {\n              \"description\": \"Specifies the hash algorithm and value encompassing the entire signed envelope; this is computed by the rekor server, client-provided values are ignored\",\n              \"type\": \"object\",\n              \"required\": [\n                \"algorithm\",\n                \"value\"\n              ],\n              \"properties\": {\n                \"algorithm\": {\n                  \"description\": \"The hashing function used to compute the hash value\",\n                  \"type\": \"string\",\n                  \"enum\": [\n                    \"sha256\"\n                  ]\n                },\n                \"value\": {\n                  \"description\": \"The hash value for the archive\",\n                  \"type\": \"string\"\n                }\n              },\n              \"readOnly\": true\n            },\n            \"payloadHash\": {\n              \"description\": \"Specifies the hash algorithm and value covering the payload within the DSSE envelope; this is computed by the rekor server, client-provided values are ignored\",\n              \"type\": \"object\",\n              \"required\": [\n                \"algorithm\",\n                \"value\"\n              ],\n              \"properties\": {\n                \"algorithm\": {\n                  \"description\": \"The hashing function used to compute the hash value\",\n                  \"type\": \"string\",\n                  \"enum\": [\n                    \"sha256\"\n                  ]\n                },\n                \"value\": {\n                  \"description\": \"The hash value for the envelope's payload\",\n                  \"type\": \"string\"\n                }\n              },\n              \"readOnly\": true\n            }\n          }\n        },\n        \"publicKey\": {\n          \"description\": \"The public key that can verify the signature\",\n          \"type\": \"string\",\n          \"format\": \"byte\"\n        }\n      },\n      \"$schema\": \"http://json-schema.org/draft-07/schema\",\n      \"$id\": \"http://rekor.sigstore.dev/types/intoto/intoto_v0_0_1_schema.json\"\n    },\n    \"intotoV002Schema\": {\n      \"description\": \"Schema for intoto object\",\n      \"type\": \"object\",\n      \"title\": \"intoto v0.0.2 Schema\",\n      \"required\": [\n        \"content\"\n      ],\n      \"properties\": {\n        \"content\": {\n          \"type\": \"object\",\n          \"required\": [\n            \"envelope\"\n          ],\n          \"properties\": {\n            \"envelope\": {\n              \"description\": \"dsse envelope\",\n              \"type\": \"object\",\n              \"required\": [\n                \"payloadType\",\n                \"signatures\"\n              ],\n              \"properties\": {\n                \"payload\": {\n                  \"description\": \"payload of the envelope\",\n                  \"type\": \"string\",\n                  \"format\": \"byte\",\n                  \"writeOnly\": true\n                },\n                \"payloadType\": {\n                  \"description\": \"type describing the payload\",\n                  \"type\": \"string\"\n                },\n                \"signatures\": {\n                  \"description\": \"collection of all signatures of the envelope's payload\",\n                  \"type\": \"array\",\n                  \"minItems\": 1,\n                  \"items\": {\n                    \"$ref\": \"#/definitions/IntotoV002SchemaContentEnvelopeSignaturesItems0\"\n                  }\n                }\n              }\n            },\n            \"hash\": {\n              \"description\": \"Specifies the hash algorithm and value encompassing the entire signed envelope\",\n              \"type\": \"object\",\n              \"required\": [\n                \"algorithm\",\n                \"value\"\n              ],\n              \"properties\": {\n                \"algorithm\": {\n                  \"description\": \"The hashing function used to compute the hash value\",\n                  \"type\": \"string\",\n                  \"enum\": [\n                    \"sha256\"\n                  ]\n                },\n                \"value\": {\n                  \"description\": \"The hash value for the archive\",\n                  \"type\": \"string\"\n                }\n              },\n              \"readOnly\": true\n            },\n            \"payloadHash\": {\n              \"description\": \"Specifies the hash algorithm and value covering the payload within the DSSE envelope\",\n              \"type\": \"object\",\n              \"required\": [\n                \"algorithm\",\n                \"value\"\n              ],\n              \"properties\": {\n                \"algorithm\": {\n                  \"description\": \"The hashing function used to compute the hash value\",\n                  \"type\": \"string\",\n                  \"enum\": [\n                    \"sha256\"\n                  ]\n                },\n                \"value\": {\n                  \"description\": \"The hash value of the payload\",\n                  \"type\": \"string\"\n                }\n              },\n              \"readOnly\": true\n            }\n          }\n        }\n      },\n      \"$schema\": \"http://json-schema.org/draft-07/schema\",\n      \"$id\": \"http://rekor.sigstore.dev/types/intoto/intoto_v0_0_2_schema.json\"\n    },\n    \"jar\": {\n      \"description\": \"Java Archive (JAR)\",\n      \"type\": \"object\",\n      \"allOf\": [\n        {\n          \"$ref\": \"#/definitions/ProposedEntry\"\n        },\n        {\n          \"required\": [\n            \"apiVersion\",\n            \"spec\"\n          ],\n          \"properties\": {\n            \"apiVersion\": {\n              \"type\": \"string\",\n              \"pattern\": \"^(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)(?:-((?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\\\.(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\\\+([0-9a-zA-Z-]+(?:\\\\.[0-9a-zA-Z-]+)*))?$\"\n            },\n            \"spec\": {\n              \"$ref\": \"#/definitions/jarSchema\"\n            }\n          },\n          \"additionalProperties\": false\n        }\n      ]\n    },\n    \"jarSchema\": {\n      \"description\": \"Schema for JAR objects\",\n      \"type\": \"object\",\n      \"title\": \"JAR Schema\",\n      \"oneOf\": [\n        {\n          \"$ref\": \"#/definitions/jarV001Schema\"\n        }\n      ],\n      \"$schema\": \"http://json-schema.org/draft-07/schema\",\n      \"$id\": \"http://rekor.sigstore.dev/types/jar/jar_schema.json\"\n    },\n    \"jarV001Schema\": {\n      \"description\": \"Schema for JAR entries\",\n      \"type\": \"object\",\n      \"title\": \"JAR v0.0.1 Schema\",\n      \"required\": [\n        \"archive\"\n      ],\n      \"properties\": {\n        \"archive\": {\n          \"description\": \"Information about the archive associated with the entry\",\n          \"type\": \"object\",\n          \"oneOf\": [\n            {\n              \"required\": [\n                \"hash\"\n              ]\n            },\n            {\n              \"required\": [\n                \"content\"\n              ]\n            }\n          ],\n          \"properties\": {\n            \"content\": {\n              \"description\": \"Specifies the archive inline within the document\",\n              \"type\": \"string\",\n              \"format\": \"byte\",\n              \"writeOnly\": true\n            },\n            \"hash\": {\n              \"description\": \"Specifies the hash algorithm and value encompassing the entire signed archive\",\n              \"type\": \"object\",\n              \"required\": [\n                \"algorithm\",\n                \"value\"\n              ],\n              \"properties\": {\n                \"algorithm\": {\n                  \"description\": \"The hashing function used to compute the hash value\",\n                  \"type\": \"string\",\n                  \"enum\": [\n                    \"sha256\"\n                  ]\n                },\n                \"value\": {\n                  \"description\": \"The hash value for the archive\",\n                  \"type\": \"string\"\n                }\n              }\n            }\n          }\n        },\n        \"signature\": {\n          \"description\": \"Information about the included signature in the JAR file\",\n          \"type\": \"object\",\n          \"required\": [\n            \"publicKey\",\n            \"content\"\n          ],\n          \"properties\": {\n            \"content\": {\n              \"description\": \"Specifies the PKCS7 signature embedded within the JAR file \",\n              \"type\": \"string\",\n              \"format\": \"byte\",\n              \"readOnly\": true\n            },\n            \"publicKey\": {\n              \"description\": \"The X509 certificate containing the public key JAR which verifies the signature of the JAR\",\n              \"type\": \"object\",\n              \"required\": [\n                \"content\"\n              ],\n              \"properties\": {\n                \"content\": {\n                  \"description\": \"Specifies the content of the X509 certificate containing the public key used to verify the signature\",\n                  \"type\": \"string\",\n                  \"format\": \"byte\"\n                }\n              },\n              \"readOnly\": true\n            }\n          }\n        }\n      },\n      \"$schema\": \"http://json-schema.org/draft-07/schema\",\n      \"$id\": \"http://rekor.sigstore.dev/types/jar/jar_v0_0_1_schema.json\"\n    },\n    \"rekord\": {\n      \"description\": \"Rekord object\",\n      \"type\": \"object\",\n      \"allOf\": [\n        {\n          \"$ref\": \"#/definitions/ProposedEntry\"\n        },\n        {\n          \"required\": [\n            \"apiVersion\",\n            \"spec\"\n          ],\n          \"properties\": {\n            \"apiVersion\": {\n              \"type\": \"string\",\n              \"pattern\": \"^(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)(?:-((?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\\\.(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\\\+([0-9a-zA-Z-]+(?:\\\\.[0-9a-zA-Z-]+)*))?$\"\n            },\n            \"spec\": {\n              \"$ref\": \"#/definitions/rekordSchema\"\n            }\n          },\n          \"additionalProperties\": false\n        }\n      ]\n    },\n    \"rekordSchema\": {\n      \"description\": \"Schema for Rekord objects\",\n      \"type\": \"object\",\n      \"title\": \"Rekor Schema\",\n      \"oneOf\": [\n        {\n          \"$ref\": \"#/definitions/rekordV001Schema\"\n        }\n      ],\n      \"$schema\": \"http://json-schema.org/draft-07/schema\",\n      \"$id\": \"http://rekor.sigstore.dev/types/rekord/rekord_schema.json\"\n    },\n    \"rekordV001Schema\": {\n      \"description\": \"Schema for Rekord object\",\n      \"type\": \"object\",\n      \"title\": \"Rekor v0.0.1 Schema\",\n      \"required\": [\n        \"signature\",\n        \"data\"\n      ],\n      \"properties\": {\n        \"data\": {\n          \"description\": \"Information about the content associated with the entry\",\n          \"type\": \"object\",\n          \"oneOf\": [\n            {\n              \"required\": [\n                \"hash\"\n              ]\n            },\n            {\n              \"required\": [\n                \"content\"\n              ]\n            }\n          ],\n          \"properties\": {\n            \"content\": {\n              \"description\": \"Specifies the content inline within the document\",\n              \"type\": \"string\",\n              \"format\": \"byte\",\n              \"writeOnly\": true\n            },\n            \"hash\": {\n              \"description\": \"Specifies the hash algorithm and value for the content\",\n              \"type\": \"object\",\n              \"required\": [\n                \"algorithm\",\n                \"value\"\n              ],\n              \"properties\": {\n                \"algorithm\": {\n                  \"description\": \"The hashing function used to compute the hash value\",\n                  \"type\": \"string\",\n                  \"enum\": [\n                    \"sha256\"\n                  ]\n                },\n                \"value\": {\n                  \"description\": \"The hash value for the content\",\n                  \"type\": \"string\"\n                }\n              },\n              \"readOnly\": true\n            }\n          }\n        },\n        \"signature\": {\n          \"description\": \"Information about the detached signature associated with the entry\",\n          \"type\": \"object\",\n          \"required\": [\n            \"format\",\n            \"publicKey\",\n            \"content\"\n          ],\n          \"properties\": {\n            \"content\": {\n              \"description\": \"Specifies the content of the signature inline within the document\",\n              \"type\": \"string\",\n              \"format\": \"byte\"\n            },\n            \"format\": {\n              \"description\": \"Specifies the format of the signature\",\n              \"type\": \"string\",\n              \"enum\": [\n                \"pgp\",\n                \"minisign\",\n                \"x509\",\n                \"ssh\"\n              ]\n            },\n            \"publicKey\": {\n              \"description\": \"The public key that can verify the signature\",\n              \"type\": \"object\",\n              \"required\": [\n                \"content\"\n              ],\n              \"properties\": {\n                \"content\": {\n                  \"description\": \"Specifies the content of the public key inline within the document\",\n                  \"type\": \"string\",\n                  \"format\": \"byte\"\n                }\n              }\n            }\n          }\n        }\n      },\n      \"$schema\": \"http://json-schema.org/draft-07/schema\",\n      \"$id\": \"http://rekor.sigstore.dev/types/rekord/rekord_v0_0_1_schema.json\"\n    },\n    \"rfc3161\": {\n      \"description\": \"RFC3161 Timestamp\",\n      \"type\": \"object\",\n      \"allOf\": [\n        {\n          \"$ref\": \"#/definitions/ProposedEntry\"\n        },\n        {\n          \"required\": [\n            \"apiVersion\",\n            \"spec\"\n          ],\n          \"properties\": {\n            \"apiVersion\": {\n              \"type\": \"string\",\n              \"pattern\": \"^(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)(?:-((?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\\\.(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\\\+([0-9a-zA-Z-]+(?:\\\\.[0-9a-zA-Z-]+)*))?$\"\n            },\n            \"spec\": {\n              \"$ref\": \"#/definitions/rfc3161Schema\"\n            }\n          },\n          \"additionalProperties\": false\n        }\n      ]\n    },\n    \"rfc3161Schema\": {\n      \"description\": \"Schema for RFC 3161 timestamp objects\",\n      \"type\": \"object\",\n      \"title\": \"Timestamp Schema\",\n      \"oneOf\": [\n        {\n          \"$ref\": \"#/definitions/rfc3161V001Schema\"\n        }\n      ],\n      \"$schema\": \"http://json-schema.org/draft-07/schema\",\n      \"$id\": \"http://rekor.sigstore.dev/types/rfc3161/rfc3161_schema.json\"\n    },\n    \"rfc3161V001Schema\": {\n      \"description\": \"Schema for RFC3161 entries\",\n      \"type\": \"object\",\n      \"title\": \"Timestamp v0.0.1 Schema\",\n      \"required\": [\n        \"tsr\"\n      ],\n      \"properties\": {\n        \"tsr\": {\n          \"description\": \"Information about the tsr file associated with the entry\",\n          \"type\": \"object\",\n          \"required\": [\n            \"content\"\n          ],\n          \"properties\": {\n            \"content\": {\n              \"description\": \"Specifies the tsr file content inline within the document\",\n              \"type\": \"string\",\n              \"format\": \"byte\"\n            }\n          }\n        }\n      },\n      \"$schema\": \"http://json-schema.org/draft-07/schema\",\n      \"$id\": \"http://rekor.sigstore.dev/types/timestamp/timestamp_v0_0_1_schema.json\"\n    },\n    \"rpm\": {\n      \"description\": \"RPM package\",\n      \"type\": \"object\",\n      \"allOf\": [\n        {\n          \"$ref\": \"#/definitions/ProposedEntry\"\n        },\n        {\n          \"required\": [\n            \"apiVersion\",\n            \"spec\"\n          ],\n          \"properties\": {\n            \"apiVersion\": {\n              \"type\": \"string\",\n              \"pattern\": \"^(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)(?:-((?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\\\.(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\\\+([0-9a-zA-Z-]+(?:\\\\.[0-9a-zA-Z-]+)*))?$\"\n            },\n            \"spec\": {\n              \"$ref\": \"#/definitions/rpmSchema\"\n            }\n          },\n          \"additionalProperties\": false\n        }\n      ]\n    },\n    \"rpmSchema\": {\n      \"description\": \"Schema for RPM objects\",\n      \"type\": \"object\",\n      \"title\": \"RPM Schema\",\n      \"oneOf\": [\n        {\n          \"$ref\": \"#/definitions/rpmV001Schema\"\n        }\n      ],\n      \"$schema\": \"http://json-schema.org/draft-07/schema\",\n      \"$id\": \"http://rekor.sigstore.dev/types/rpm/rpm_schema.json\"\n    },\n    \"rpmV001Schema\": {\n      \"description\": \"Schema for RPM entries\",\n      \"type\": \"object\",\n      \"title\": \"RPM v0.0.1 Schema\",\n      \"required\": [\n        \"publicKey\",\n        \"package\"\n      ],\n      \"properties\": {\n        \"package\": {\n          \"description\": \"Information about the package associated with the entry\",\n          \"type\": \"object\",\n          \"oneOf\": [\n            {\n              \"required\": [\n                \"hash\"\n              ]\n            },\n            {\n              \"required\": [\n                \"content\"\n              ]\n            }\n          ],\n          \"properties\": {\n            \"content\": {\n              \"description\": \"Specifies the package inline within the document\",\n              \"type\": \"string\",\n              \"format\": \"byte\",\n              \"writeOnly\": true\n            },\n            \"hash\": {\n              \"description\": \"Specifies the hash algorithm and value for the package\",\n              \"type\": \"object\",\n              \"required\": [\n                \"algorithm\",\n                \"value\"\n              ],\n              \"properties\": {\n                \"algorithm\": {\n                  \"description\": \"The hashing function used to compute the hash value\",\n                  \"type\": \"string\",\n                  \"enum\": [\n                    \"sha256\"\n                  ]\n                },\n                \"value\": {\n                  \"description\": \"The hash value for the package\",\n                  \"type\": \"string\"\n                }\n              }\n            },\n            \"headers\": {\n              \"description\": \"Values of the RPM headers\",\n              \"type\": \"object\",\n              \"additionalProperties\": {\n                \"type\": \"string\"\n              },\n              \"readOnly\": true\n            }\n          }\n        },\n        \"publicKey\": {\n          \"description\": \"The PGP public key that can verify the RPM signature\",\n          \"type\": \"object\",\n          \"required\": [\n            \"content\"\n          ],\n          \"properties\": {\n            \"content\": {\n              \"description\": \"Specifies the content of the public key inline within the document\",\n              \"type\": \"string\",\n              \"format\": \"byte\"\n            }\n          }\n        }\n      },\n      \"$schema\": \"http://json-schema.org/draft-07/schema\",\n      \"$id\": \"http://rekor.sigstore.dev/types/rpm/rpm_v0_0_1_schema.json\"\n    },\n    \"tuf\": {\n      \"description\": \"TUF metadata\",\n      \"type\": \"object\",\n      \"allOf\": [\n        {\n          \"$ref\": \"#/definitions/ProposedEntry\"\n        },\n        {\n          \"required\": [\n            \"apiVersion\",\n            \"spec\"\n          ],\n          \"properties\": {\n            \"apiVersion\": {\n              \"type\": \"string\",\n              \"pattern\": \"^(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)(?:-((?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\\\.(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\\\+([0-9a-zA-Z-]+(?:\\\\.[0-9a-zA-Z-]+)*))?$\"\n            },\n            \"spec\": {\n              \"$ref\": \"#/definitions/tufSchema\"\n            }\n          },\n          \"additionalProperties\": false\n        }\n      ]\n    },\n    \"tufSchema\": {\n      \"description\": \"Schema for TUF metadata objects\",\n      \"type\": \"object\",\n      \"title\": \"TUF Schema\",\n      \"oneOf\": [\n        {\n          \"$ref\": \"#/definitions/tufV001Schema\"\n        }\n      ],\n      \"$schema\": \"http://json-schema.org/draft-07/schema\",\n      \"$id\": \"http://rekor.sigstore.dev/types/tuf/tuf_schema.json\"\n    },\n    \"tufV001Schema\": {\n      \"description\": \"Schema for TUF metadata entries\",\n      \"type\": \"object\",\n      \"title\": \"TUF v0.0.1 Schema\",\n      \"required\": [\n        \"metadata\",\n        \"root\"\n      ],\n      \"properties\": {\n        \"metadata\": {\n          \"description\": \"TUF metadata\",\n          \"type\": \"object\",\n          \"required\": [\n            \"content\"\n          ],\n          \"properties\": {\n            \"content\": {\n              \"description\": \"Specifies the metadata inline within the document\",\n              \"type\": \"object\",\n              \"additionalProperties\": true\n            }\n          }\n        },\n        \"root\": {\n          \"description\": \"root metadata containing about the public keys used to sign the manifest\",\n          \"type\": \"object\",\n          \"required\": [\n            \"content\"\n          ],\n          \"properties\": {\n            \"content\": {\n              \"description\": \"Specifies the metadata inline within the document\",\n              \"type\": \"object\",\n              \"additionalProperties\": true\n            }\n          }\n        },\n        \"spec_version\": {\n          \"description\": \"TUF specification version\",\n          \"type\": \"string\",\n          \"readOnly\": true\n        }\n      },\n      \"$schema\": \"http://json-schema.org/draft-07/schema\",\n      \"$id\": \"http://rekor.sigstore.dev/types/tuf/tuf_v0_0_1_schema.json\"\n    }\n  },\n  \"responses\": {\n    \"BadContent\": {\n      \"description\": \"The content supplied to the server was invalid\",\n      \"schema\": {\n        \"$ref\": \"#/definitions/Error\"\n      }\n    },\n    \"Conflict\": {\n      \"description\": \"The request conflicts with the current state of the transparency log\",\n      \"schema\": {\n        \"$ref\": \"#/definitions/Error\"\n      },\n      \"headers\": {\n        \"Location\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        }\n      }\n    },\n    \"InternalServerError\": {\n      \"description\": \"There was an internal error in the server while processing the request\",\n      \"schema\": {\n        \"$ref\": \"#/definitions/Error\"\n      }\n    },\n    \"NotFound\": {\n      \"description\": \"The content requested could not be found\"\n    },\n    \"UnprocessableEntity\": {\n      \"description\": \"The server understood the request but is unable to process the contained instructions\",\n      \"schema\": {\n        \"$ref\": \"#/definitions/Error\"\n      }\n    }\n  }\n}`))\n}\n", "//\n// Copyright 2023 The Sigstore Authors.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage dsse\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"crypto\"\n\t\"crypto/sha256\"\n\t\"encoding/hex\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"sort\"\n\t\"strings\"\n\n\t\"github.com/in-toto/in-toto-golang/in_toto\"\n\t\"github.com/secure-systems-lab/go-securesystemslib/dsse\"\n\n\t\"github.com/go-openapi/strfmt\"\n\t\"github.com/go-openapi/swag\"\n\n\t\"github.com/sigstore/rekor/pkg/generated/models\"\n\t\"github.com/sigstore/rekor/pkg/log\"\n\t\"github.com/sigstore/rekor/pkg/pki\"\n\t\"github.com/sigstore/rekor/pkg/pki/x509\"\n\t\"github.com/sigstore/rekor/pkg/types\"\n\tdsseType \"github.com/sigstore/rekor/pkg/types/dsse\"\n\t\"github.com/sigstore/sigstore/pkg/signature\"\n\tsigdsse \"github.com/sigstore/sigstore/pkg/signature/dsse\"\n)\n\nconst (\n\tAPIVERSION = \"0.0.1\"\n)\n\nfunc init() {\n\tif err := dsseType.VersionMap.SetEntryFactory(APIVERSION, NewEntry); err != nil {\n\t\tlog.Logger.Panic(err)\n\t}\n}\n\ntype V001Entry struct {\n\tDSSEObj models.DSSEV001Schema\n\tenv     *dsse.Envelope\n}\n\nfunc (v V001Entry) APIVersion() string {\n\treturn APIVERSION\n}\n\nfunc NewEntry() types.EntryImpl {\n\treturn &V001Entry{}\n}\n\n// IndexKeys computes the list of keys that should map back to this entry.\n// It should *never* reference v.DSSEObj.ProposedContent as those values would only\n// be present at the time of insertion\nfunc (v V001Entry) IndexKeys() ([]string, error) {\n\tvar result []string\n\n\tfor _, sig := range v.DSSEObj.Signatures {\n\t\tif sig == nil || sig.Verifier == nil {\n\t\t\treturn result, errors.New(\"missing or malformed public key\")\n\t\t}\n\t\tkeyObj, err := x509.NewPublicKey(bytes.NewReader(*sig.Verifier))\n\t\tif err != nil {\n\t\t\treturn result, err\n\t\t}\n\n\t\tcanonKey, err := keyObj.CanonicalValue()\n\t\tif err != nil {\n\t\t\treturn result, fmt.Errorf(\"could not canonicalize key: %w\", err)\n\t\t}\n\n\t\tkeyHash := sha256.Sum256(canonKey)\n\t\tresult = append(result, \"sha256:\"+hex.EncodeToString(keyHash[:]))\n\n\t\tresult = append(result, keyObj.Subjects()...)\n\t}\n\n\tif v.DSSEObj.PayloadHash != nil {\n\t\tpayloadHashKey := strings.ToLower(fmt.Sprintf(\"%s:%s\", *v.DSSEObj.PayloadHash.Algorithm, *v.DSSEObj.PayloadHash.Value))\n\t\tresult = append(result, payloadHashKey)\n\t}\n\n\tif v.DSSEObj.EnvelopeHash != nil {\n\t\tenvelopeHashKey := strings.ToLower(fmt.Sprintf(\"%s:%s\", *v.DSSEObj.EnvelopeHash.Algorithm, *v.DSSEObj.EnvelopeHash.Value))\n\t\tresult = append(result, envelopeHashKey)\n\t}\n\n\tif v.env == nil {\n\t\tlog.Logger.Info(\"DSSEObj content or DSSE envelope is nil, returning partial set of keys\")\n\t\treturn result, nil\n\t}\n\n\tswitch v.env.PayloadType {\n\tcase in_toto.PayloadType:\n\n\t\tif v.env.Payload == \"\" {\n\t\t\tlog.Logger.Info(\"DSSEObj DSSE payload is empty\")\n\t\t\treturn result, nil\n\t\t}\n\t\tdecodedPayload, err := v.env.DecodeB64Payload()\n\t\tif err != nil {\n\t\t\treturn result, fmt.Errorf(\"could not decode envelope payload: %w\", err)\n\t\t}\n\t\tstatement, err := parseStatement(decodedPayload)\n\t\tif err != nil {\n\t\t\treturn result, err\n\t\t}\n\t\tfor _, s := range statement.Subject {\n\t\t\tfor alg, ds := range s.Digest {\n\t\t\t\tresult = append(result, alg+\":\"+ds)\n\t\t\t}\n\t\t}\n\t\t// Not all in-toto statements will contain a SLSA provenance predicate.\n\t\t// See https://github.com/in-toto/attestation/blob/main/spec/README.md#predicate\n\t\t// for other predicates.\n\t\tif predicate, err := parseSlsaPredicate(decodedPayload); err == nil {\n\t\t\tif predicate.Predicate.Materials != nil {\n\t\t\t\tfor _, s := range predicate.Predicate.Materials {\n\t\t\t\t\tfor alg, ds := range s.Digest {\n\t\t\t\t\t\tresult = append(result, alg+\":\"+ds)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tdefault:\n\t\tlog.Logger.Infof(\"Unknown DSSE envelope payloadType: %s\", v.env.PayloadType)\n\t}\n\treturn result, nil\n}\n\nfunc parseStatement(p []byte) (*in_toto.Statement, error) {\n\tps := in_toto.Statement{}\n\tif err := json.Unmarshal(p, &ps); err != nil {\n\t\treturn nil, err\n\t}\n\treturn &ps, nil\n}\n\nfunc parseSlsaPredicate(p []byte) (*in_toto.ProvenanceStatement, error) {\n\tpredicate := in_toto.ProvenanceStatement{}\n\tif err := json.Unmarshal(p, &predicate); err != nil {\n\t\treturn nil, err\n\t}\n\treturn &predicate, nil\n}\n\nfunc (v *V001Entry) Unmarshal(pe models.ProposedEntry) error {\n\tit, ok := pe.(*models.DSSE)\n\tif !ok {\n\t\treturn errors.New(\"cannot unmarshal non DSSE v0.0.1 type\")\n\t}\n\n\tdsseObj := &models.DSSEV001Schema{}\n\n\tif err := types.DecodeEntry(it.Spec, dsseObj); err != nil {\n\t\treturn err\n\t}\n\n\t// field validation\n\tif err := dsseObj.Validate(strfmt.Default); err != nil {\n\t\treturn err\n\t}\n\n\t// either we have just proposed content or the canonicalized fields\n\tif dsseObj.ProposedContent == nil {\n\t\t// then we need canonicalized fields, and all must be present (if present, they would have been validated in the above call to Validate())\n\t\tif dsseObj.EnvelopeHash == nil || dsseObj.PayloadHash == nil || len(dsseObj.Signatures) == 0 {\n\t\t\treturn errors.New(\"either proposedContent or envelopeHash, payloadHash, and signatures must be present\")\n\t\t}\n\t\tv.DSSEObj = *dsseObj\n\t\treturn nil\n\t}\n\t// if we're here, then we're trying to propose a new entry so we check to ensure client's aren't setting server-side computed fields\n\tif dsseObj.EnvelopeHash != nil || dsseObj.PayloadHash != nil || len(dsseObj.Signatures) != 0 {\n\t\treturn errors.New(\"either proposedContent or envelopeHash, payloadHash, and signatures must be present but not both\")\n\t}\n\n\tenv := &dsse.Envelope{}\n\tif err := json.Unmarshal([]byte(*dsseObj.ProposedContent.Envelope), env); err != nil {\n\t\treturn err\n\t}\n\n\tif len(env.Signatures) == 0 {\n\t\treturn errors.New(\"DSSE envelope must contain 1 or more signatures\")\n\t}\n\n\tallPubKeyBytes := make([][]byte, 0)\n\tfor _, publicKey := range dsseObj.ProposedContent.Verifiers {\n\t\tif publicKey == nil {\n\t\t\treturn errors.New(\"an invalid null verifier was provided in ProposedContent\")\n\t\t}\n\n\t\tallPubKeyBytes = append(allPubKeyBytes, publicKey)\n\t}\n\n\tsigToKeyMap, err := verifyEnvelope(allPubKeyBytes, env)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// we need to ensure we canonicalize the ordering of signatures\n\tsortedSigs := make([]string, 0, len(sigToKeyMap))\n\tfor sig := range sigToKeyMap {\n\t\tsortedSigs = append(sortedSigs, sig)\n\t}\n\tsort.Strings(sortedSigs)\n\n\tfor i, sig := range sortedSigs {\n\t\tkey := sigToKeyMap[sig]\n\t\tcanonicalizedKey, err := key.CanonicalValue()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tb64CanonicalizedKey := strfmt.Base64(canonicalizedKey)\n\n\t\tdsseObj.Signatures = append(dsseObj.Signatures, &models.DSSEV001SchemaSignaturesItems0{\n\t\t\tSignature: &sortedSigs[i],\n\t\t\tVerifier:  &b64CanonicalizedKey,\n\t\t})\n\t}\n\n\tdecodedPayload, err := env.DecodeB64Payload()\n\tif err != nil {\n\t\t// this shouldn't happen because failure would have occurred in verifyEnvelope call above\n\t\treturn err\n\t}\n\n\tpayloadHash := sha256.Sum256(decodedPayload)\n\tdsseObj.PayloadHash = &models.DSSEV001SchemaPayloadHash{\n\t\tAlgorithm: swag.String(models.DSSEV001SchemaPayloadHashAlgorithmSha256),\n\t\tValue:     swag.String(hex.EncodeToString(payloadHash[:])),\n\t}\n\n\tenvelopeHash := sha256.Sum256([]byte(*dsseObj.ProposedContent.Envelope))\n\tdsseObj.EnvelopeHash = &models.DSSEV001SchemaEnvelopeHash{\n\t\tAlgorithm: swag.String(models.DSSEV001SchemaEnvelopeHashAlgorithmSha256),\n\t\tValue:     swag.String(hex.EncodeToString(envelopeHash[:])),\n\t}\n\n\t// we've gotten through all processing without error, now update the object we're unmarshalling into\n\tv.DSSEObj = *dsseObj\n\tv.env = env\n\n\treturn nil\n}\n\n// Canonicalize returns a JSON representation of the entry to be persisted into the log. This\n// will be further canonicalized by JSON Canonicalization Scheme (JCS) before being written.\n//\n// This function should not use v.DSSEObj.ProposedContent fields as they are client provided and\n// should not be trusted; the other fields at the top level are only set server side.\nfunc (v *V001Entry) Canonicalize(_ context.Context) ([]byte, error) {\n\tcanonicalEntry := models.DSSEV001Schema{\n\t\tSignatures:      v.DSSEObj.Signatures,\n\t\tEnvelopeHash:    v.DSSEObj.EnvelopeHash,\n\t\tPayloadHash:     v.DSSEObj.PayloadHash,\n\t\tProposedContent: nil, // this is explicitly done as we don't want to canonicalize the envelope\n\t}\n\n\tsort.Slice(canonicalEntry.Signatures, func(i, j int) bool {\n\t\treturn *canonicalEntry.Signatures[i].Signature < *canonicalEntry.Signatures[j].Signature\n\t})\n\n\titObj := models.DSSE{}\n\titObj.APIVersion = swag.String(APIVERSION)\n\titObj.Spec = &canonicalEntry\n\n\treturn json.Marshal(&itObj)\n}\n\n// AttestationKey and AttestationKeyValue are not implemented so the envelopes will not be persisted in Rekor\n\nfunc (v V001Entry) CreateFromArtifactProperties(_ context.Context, props types.ArtifactProperties) (models.ProposedEntry, error) {\n\treturnVal := models.DSSE{}\n\tre := V001Entry{\n\t\tDSSEObj: models.DSSEV001Schema{\n\t\t\tProposedContent: &models.DSSEV001SchemaProposedContent{},\n\t\t},\n\t}\n\tvar err error\n\tartifactBytes := props.ArtifactBytes\n\tif artifactBytes == nil {\n\t\tif props.ArtifactPath == nil {\n\t\t\treturn nil, errors.New(\"path to artifact file must be specified\")\n\t\t}\n\t\tif props.ArtifactPath.IsAbs() {\n\t\t\treturn nil, errors.New(\"dsse envelopes cannot be fetched over HTTP(S)\")\n\t\t}\n\t\tartifactBytes, err = os.ReadFile(filepath.Clean(props.ArtifactPath.Path))\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\tenv := &dsse.Envelope{}\n\tif err := json.Unmarshal(artifactBytes, env); err != nil {\n\t\treturn nil, fmt.Errorf(\"payload must be a valid DSSE envelope: %w\", err)\n\t}\n\n\tallPubKeyBytes := make([][]byte, 0)\n\tif len(props.PublicKeyBytes) > 0 {\n\t\tallPubKeyBytes = append(allPubKeyBytes, props.PublicKeyBytes...)\n\t}\n\n\tif len(props.PublicKeyPaths) > 0 {\n\t\tfor _, path := range props.PublicKeyPaths {\n\t\t\tif path.IsAbs() {\n\t\t\t\treturn nil, errors.New(\"dsse public keys cannot be fetched over HTTP(S)\")\n\t\t\t}\n\n\t\t\tpublicKeyBytes, err := os.ReadFile(filepath.Clean(path.Path))\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"error reading public key file: %w\", err)\n\t\t\t}\n\n\t\t\tallPubKeyBytes = append(allPubKeyBytes, publicKeyBytes)\n\t\t}\n\t}\n\n\tkeysBySig, err := verifyEnvelope(allPubKeyBytes, env)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tfor _, key := range keysBySig {\n\t\tcanonicalKey, err := key.CanonicalValue()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tre.DSSEObj.ProposedContent.Verifiers = append(re.DSSEObj.ProposedContent.Verifiers, strfmt.Base64(canonicalKey))\n\t}\n\tre.DSSEObj.ProposedContent.Envelope = swag.String(string(artifactBytes))\n\n\treturnVal.Spec = re.DSSEObj\n\treturnVal.APIVersion = swag.String(re.APIVersion())\n\n\treturn &returnVal, nil\n}\n\n// verifyEnvelope takes in an array of possible key bytes and attempts to parse them as x509 public keys.\n// it then uses these to verify the envelope and makes sure that every signature on the envelope is verified.\n// it returns a map of verifiers indexed by the signature the verifier corresponds to.\nfunc verifyEnvelope(allPubKeyBytes [][]byte, env *dsse.Envelope) (map[string]*x509.PublicKey, error) {\n\t// generate a fake id for these keys so we can get back to the key bytes and match them to their corresponding signature\n\tverifierBySig := make(map[string]*x509.PublicKey)\n\tallSigs := make(map[string]struct{})\n\tfor _, sig := range env.Signatures {\n\t\tallSigs[sig.Sig] = struct{}{}\n\t}\n\n\tfor _, pubKeyBytes := range allPubKeyBytes {\n\t\tif len(allSigs) == 0 {\n\t\t\tbreak // if all signatures have been verified, do not attempt anymore\n\t\t}\n\t\tkey, err := x509.NewPublicKey(bytes.NewReader(pubKeyBytes))\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"could not parse public key as x509: %w\", err)\n\t\t}\n\n\t\tvfr, err := signature.LoadVerifier(key.CryptoPubKey(), crypto.SHA256)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"could not load verifier: %w\", err)\n\t\t}\n\n\t\tdsseVfr, err := dsse.NewEnvelopeVerifier(&sigdsse.VerifierAdapter{SignatureVerifier: vfr})\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"could not use public key as a dsse verifier: %w\", err)\n\t\t}\n\n\t\taccepted, err := dsseVfr.Verify(context.Background(), env)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"could not verify envelope: %w\", err)\n\t\t}\n\n\t\tfor _, accept := range accepted {\n\t\t\tdelete(allSigs, accept.Sig.Sig)\n\t\t\tverifierBySig[accept.Sig.Sig] = key\n\t\t}\n\t}\n\n\tif len(allSigs) > 0 {\n\t\treturn nil, errors.New(\"all signatures must have a key that verifies it\")\n\t}\n\n\treturn verifierBySig, nil\n}\n\nfunc (v V001Entry) Verifier() (pki.PublicKey, error) {\n\tif len(v.DSSEObj.Signatures) == 0 {\n\t\treturn nil, errors.New(\"dsse v0.0.1 entry not initialized\")\n\t}\n\n\t//TODO: return multiple pki.PublicKeys; sigstore/rekor issue #1278\n\treturn x509.NewPublicKey(bytes.NewReader(*v.DSSEObj.Signatures[0].Verifier))\n}\n\nfunc (v V001Entry) Insertable() (bool, error) {\n\tif v.DSSEObj.ProposedContent == nil {\n\t\treturn false, errors.New(\"missing proposed content\")\n\t}\n\tif v.DSSEObj.ProposedContent.Envelope == nil || len(*v.DSSEObj.ProposedContent.Envelope) == 0 {\n\t\treturn false, errors.New(\"missing proposed DSSE envelope\")\n\t}\n\tif len(v.DSSEObj.ProposedContent.Verifiers) == 0 {\n\t\treturn false, errors.New(\"missing proposed verifiers\")\n\t}\n\n\treturn true, nil\n}\n", "//\n// Copyright 2023 The Sigstore Authors.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage dsse\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"crypto\"\n\t\"crypto/ecdsa\"\n\t\"crypto/elliptic\"\n\t\"crypto/rand\"\n\t\"crypto/sha256\"\n\t\"crypto/x509\"\n\t\"encoding/base64\"\n\t\"encoding/hex\"\n\t\"encoding/json\"\n\t\"encoding/pem\"\n\t\"fmt\"\n\t\"math/big\"\n\t\"reflect\"\n\t\"sort\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/go-openapi/runtime\"\n\t\"github.com/go-openapi/strfmt\"\n\t\"github.com/go-openapi/swag\"\n\t\"github.com/google/go-cmp/cmp\"\n\t\"github.com/google/go-cmp/cmp/cmpopts\"\n\t\"github.com/in-toto/in-toto-golang/in_toto\"\n\tslsaCommon \"github.com/in-toto/in-toto-golang/in_toto/slsa_provenance/common\"\n\tslsa \"github.com/in-toto/in-toto-golang/in_toto/slsa_provenance/v0.2\"\n\t\"github.com/secure-systems-lab/go-securesystemslib/dsse\"\n\t\"github.com/sigstore/rekor/pkg/generated/models\"\n\t\"github.com/sigstore/rekor/pkg/types\"\n\t\"github.com/sigstore/sigstore/pkg/signature\"\n\tsigdsse \"github.com/sigstore/sigstore/pkg/signature/dsse\"\n\t\"go.uber.org/goleak\"\n)\n\nfunc TestMain(m *testing.M) {\n\tgoleak.VerifyTestMain(m)\n}\n\nfunc TestNewEntryReturnType(t *testing.T) {\n\tentry := NewEntry()\n\tif reflect.TypeOf(entry) != reflect.ValueOf(&V001Entry{}).Type() {\n\t\tt.Errorf(\"invalid type returned from NewEntry: %T\", entry)\n\t}\n}\n\nfunc envelope(t *testing.T, k *ecdsa.PrivateKey, payload []byte) *dsse.Envelope {\n\n\ts, err := signature.LoadECDSASigner(k, crypto.SHA256)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tsigner, err := dsse.NewEnvelopeSigner(&sigdsse.SignerAdapter{\n\t\tSignatureSigner: s,\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdsseEnv, err := signer.SignPayload(context.Background(), \"application/vnd.in-toto+json\", payload)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\treturn dsseEnv\n}\n\nfunc multiSignEnvelope(t *testing.T, k []*ecdsa.PrivateKey, payload []byte) *dsse.Envelope {\n\tevps := []*sigdsse.SignerAdapter{}\n\tfor _, key := range k {\n\t\ts, err := signature.LoadECDSASigner(key, crypto.SHA256)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tevps = append(evps, &sigdsse.SignerAdapter{\n\t\t\tSignatureSigner: s,\n\t\t})\n\t}\n\n\tsigner, err := dsse.NewMultiEnvelopeSigner(2, evps[0], evps[1])\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdsseEnv, err := signer.SignPayload(context.Background(), in_toto.PayloadType, payload)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\treturn dsseEnv\n}\n\nfunc createRekorEnvelope(dsseEnv *dsse.Envelope, pub [][]byte) *models.DSSEV001SchemaProposedContent {\n\n\tenvelopeBytes, _ := json.Marshal(dsseEnv)\n\tproposedContent := &models.DSSEV001SchemaProposedContent{\n\t\tEnvelope: swag.String(string(envelopeBytes)),\n\t}\n\tfor _, key := range pub {\n\t\tproposedContent.Verifiers = append(proposedContent.Verifiers, strfmt.Base64(key))\n\t}\n\treturn proposedContent\n}\n\nfunc TestV001Entry_Unmarshal(t *testing.T) {\n\tkey, err := ecdsa.GenerateKey(elliptic.P256(), rand.Reader)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tder, err := x509.MarshalPKIXPublicKey(&key.PublicKey)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tpub := pem.EncodeToMemory(&pem.Block{\n\t\tBytes: der,\n\t\tType:  \"PUBLIC KEY\",\n\t})\n\n\tpriv, err := ecdsa.GenerateKey(elliptic.P256(), rand.Reader)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tca := &x509.Certificate{\n\t\tSerialNumber: big.NewInt(1),\n\t}\n\tcaBytes, err := x509.CreateCertificate(rand.Reader, ca, ca, &priv.PublicKey, priv)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tpemBytes := pem.EncodeToMemory(&pem.Block{\n\t\tType:  \"CERTIFICATE\",\n\t\tBytes: caBytes,\n\t})\n\n\tinvalid := dsse.Envelope{\n\t\tPayload: \"hello\",\n\t\tSignatures: []dsse.Signature{\n\t\t\t{\n\t\t\t\tSig: string(strfmt.Base64(\"foobar\")),\n\t\t\t},\n\t\t},\n\t}\n\n\tvalidEnv := envelope(t, key, []byte(\"payload\"))\n\tvalidEnvBytes, _ := json.Marshal(validEnv)\n\n\tvalidPayload := \"hellothispayloadisvalid\"\n\n\ttests := []struct {\n\t\tenv     *dsse.Envelope\n\t\tname    string\n\t\tit      *models.DSSEV001Schema\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:    \"empty\",\n\t\t\tit:      &models.DSSEV001Schema{},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"missing envelope\",\n\t\t\tit: &models.DSSEV001Schema{\n\t\t\t\tProposedContent: &models.DSSEV001SchemaProposedContent{},\n\t\t\t},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tenv:  envelope(t, key, []byte(validPayload)),\n\t\t\tname: \"valid\",\n\t\t\tit: &models.DSSEV001Schema{\n\t\t\t\tProposedContent: createRekorEnvelope(envelope(t, key, []byte(validPayload)), [][]byte{pub}),\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tenv:  envelope(t, priv, []byte(validPayload)),\n\t\t\tname: \"cert\",\n\t\t\tit: &models.DSSEV001Schema{\n\t\t\t\tProposedContent: createRekorEnvelope(envelope(t, priv, []byte(validPayload)), [][]byte{pemBytes}),\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tenv:  &invalid,\n\t\t\tname: \"invalid\",\n\t\t\tit: &models.DSSEV001Schema{\n\t\t\t\tProposedContent: createRekorEnvelope(&invalid, [][]byte{pub}),\n\t\t\t},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tenv:  envelope(t, key, []byte(validPayload)),\n\t\t\tname: \"invalid key\",\n\t\t\tit: &models.DSSEV001Schema{\n\t\t\t\tProposedContent: createRekorEnvelope(envelope(t, key, []byte(validPayload)), [][]byte{[]byte(\"notavalidkey\")}),\n\t\t\t},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tenv:  multiSignEnvelope(t, []*ecdsa.PrivateKey{key, priv}, []byte(validPayload)),\n\t\t\tname: \"multi-key\",\n\t\t\tit: &models.DSSEV001Schema{\n\t\t\t\tProposedContent: createRekorEnvelope(multiSignEnvelope(t, []*ecdsa.PrivateKey{key, priv}, []byte(validPayload)), [][]byte{pub, pemBytes}),\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tenv:  validEnv,\n\t\t\tname: \"null verifier in array\",\n\t\t\tit: &models.DSSEV001Schema{\n\t\t\t\tProposedContent: &models.DSSEV001SchemaProposedContent{\n\t\t\t\t\tEnvelope:  swag.String(string(validEnvBytes)),\n\t\t\t\t\tVerifiers: []strfmt.Base64{pub, nil},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tv := &V001Entry{}\n\n\t\t\tit := &models.DSSE{\n\t\t\t\tSpec: tt.it,\n\t\t\t}\n\n\t\t\tvar uv = func() error {\n\t\t\t\tif err := v.Unmarshal(it); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\n\t\t\t\tif !tt.wantErr {\n\t\t\t\t\tif ok, err := v.Insertable(); !ok || err != nil {\n\t\t\t\t\t\treturn fmt.Errorf(\"unexpected error calling Insertable: %w\", err)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\twant := []string{}\n\t\t\t\tfor _, sig := range v.DSSEObj.Signatures {\n\t\t\t\t\tkeyHash := sha256.Sum256(*sig.Verifier)\n\t\t\t\t\twant = append(want, \"sha256:\"+hex.EncodeToString(keyHash[:]))\n\t\t\t\t}\n\t\t\t\tdecodedPayload, err := base64.StdEncoding.DecodeString(tt.env.Payload)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn fmt.Errorf(\"could not decode envelope payload: %w\", err)\n\t\t\t\t}\n\t\t\t\th := sha256.Sum256(decodedPayload)\n\t\t\t\twant = append(want, \"sha256:\"+hex.EncodeToString(h[:]))\n\n\t\t\t\tenvHashBytes := sha256.Sum256([]byte(*tt.it.ProposedContent.Envelope))\n\t\t\t\tenvHash := hex.EncodeToString(envHashBytes[:])\n\n\t\t\t\thashkey := strings.ToLower(fmt.Sprintf(\"sha256:%s\", envHash))\n\t\t\t\twant = append(want, hashkey)\n\t\t\t\tgot, _ := v.IndexKeys()\n\t\t\t\tsort.Strings(got)\n\t\t\t\tsort.Strings(want)\n\t\t\t\tif !reflect.DeepEqual(got, want) {\n\t\t\t\t\tt.Errorf(\"V001Entry.IndexKeys() = %v, want %v\", got, want)\n\t\t\t\t}\n\t\t\t\tpayloadBytes, _ := v.env.DecodeB64Payload()\n\t\t\t\tpayloadSha := sha256.Sum256(payloadBytes)\n\t\t\t\tpayloadHash := hex.EncodeToString(payloadSha[:])\n\n\t\t\t\tcanonicalBytes, err := v.Canonicalize(context.Background())\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Errorf(\"error canonicalizing entry: %v\", err)\n\t\t\t\t}\n\n\t\t\t\tpe, err := models.UnmarshalProposedEntry(bytes.NewReader(canonicalBytes), runtime.JSONConsumer())\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Errorf(\"unexpected err from Unmarshalling canonicalized entry for '%v': %v\", tt.name, err)\n\t\t\t\t}\n\t\t\t\tcanonicalEntry, err := types.UnmarshalEntry(pe)\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Errorf(\"unexpected err from type-specific unmarshalling for '%v': %v\", tt.name, err)\n\t\t\t\t}\n\t\t\t\tcanonicalV001 := canonicalEntry.(*V001Entry)\n\t\t\t\tif ok, err := canonicalV001.Insertable(); ok || err == nil {\n\t\t\t\t\tt.Errorf(\"unexpected success testing Insertable against entry created from canonicalized content\")\n\t\t\t\t}\n\t\t\t\tif *canonicalV001.DSSEObj.EnvelopeHash.Value != envHash {\n\t\t\t\t\tt.Errorf(\"envelope hashes do not match post canonicalization: %v %v\", *canonicalV001.DSSEObj.EnvelopeHash.Value, envHash)\n\t\t\t\t}\n\t\t\t\tif *canonicalV001.DSSEObj.PayloadHash.Value != payloadHash {\n\t\t\t\t\tt.Errorf(\"payload hashes do not match post canonicalization: %v %v\", canonicalV001.DSSEObj.PayloadHash.Value, payloadHash)\n\t\t\t\t}\n\t\t\t\tcanonicalIndexKeys, _ := canonicalV001.IndexKeys()\n\t\t\t\tif !cmp.Equal(got, canonicalIndexKeys, cmpopts.SortSlices(func(x, y string) bool { return x < y })) {\n\t\t\t\t\tt.Errorf(\"index keys from hydrated object do not match those generated from canonicalized (and re-hydrated) object: %v %v\", got, canonicalIndexKeys)\n\t\t\t\t}\n\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\tif err := uv(); (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"V001Entry.Unmarshal() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestV001Entry_IndexKeys(t *testing.T) {\n\tkey, err := ecdsa.GenerateKey(elliptic.P256(), rand.Reader)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tder, err := x509.MarshalPKIXPublicKey(&key.PublicKey)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tpub := pem.EncodeToMemory(&pem.Block{\n\t\tBytes: der,\n\t\tType:  \"PUBLIC KEY\",\n\t})\n\n\ttests := []struct {\n\t\tname      string\n\t\tstatement in_toto.Statement\n\t\twant      []string\n\t}{\n\t\t{\n\t\t\tname: \"standard\",\n\t\t\twant: []string{},\n\t\t\tstatement: in_toto.Statement{\n\t\t\t\tPredicate: \"hello\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"subject\",\n\t\t\twant: []string{\"sha256:foo\"},\n\t\t\tstatement: in_toto.Statement{\n\t\t\t\tStatementHeader: in_toto.StatementHeader{\n\t\t\t\t\tSubject: []in_toto.Subject{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tName: \"foo\",\n\t\t\t\t\t\t\tDigest: map[string]string{\n\t\t\t\t\t\t\t\t\"sha256\": \"foo\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tPredicate: \"hello\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"slsa\",\n\t\t\twant: []string{\"sha256:bar\"},\n\t\t\tstatement: in_toto.Statement{\n\t\t\t\tPredicate: slsa.ProvenancePredicate{\n\t\t\t\t\tMaterials: []slsaCommon.ProvenanceMaterial{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tURI: \"foo\",\n\t\t\t\t\t\t\tDigest: map[string]string{\n\t\t\t\t\t\t\t\t\"sha256\": \"bar\",\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"slsa wit header\",\n\t\t\twant: []string{\"sha256:foo\", \"sha256:bar\"},\n\t\t\tstatement: in_toto.Statement{\n\t\t\t\tStatementHeader: in_toto.StatementHeader{\n\t\t\t\t\tSubject: []in_toto.Subject{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tName: \"foo\",\n\t\t\t\t\t\t\tDigest: map[string]string{\n\t\t\t\t\t\t\t\t\"sha256\": \"foo\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tPredicate: slsa.ProvenancePredicate{\n\t\t\t\t\tMaterials: []slsaCommon.ProvenanceMaterial{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tURI: \"foo\",\n\t\t\t\t\t\t\tDigest: map[string]string{\n\t\t\t\t\t\t\t\t\"sha256\": \"bar\",\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tb, err := json.Marshal(tt.statement)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tpe := &models.DSSE{\n\t\t\t\tAPIVersion: swag.String(APIVERSION),\n\t\t\t\tSpec: &models.DSSEV001Schema{\n\t\t\t\t\tProposedContent: createRekorEnvelope(envelope(t, key, b), [][]byte{pub}),\n\t\t\t\t},\n\t\t\t}\n\t\t\tv := V001Entry{}\n\t\t\tif err := v.Unmarshal(pe); err != nil {\n\t\t\t\tt.Error(err)\n\t\t\t}\n\t\t\twant := []string{}\n\t\t\tfor _, sig := range v.DSSEObj.Signatures {\n\t\t\t\tkeyHash := sha256.Sum256(*sig.Verifier)\n\t\t\t\twant = append(want, \"sha256:\"+hex.EncodeToString(keyHash[:]))\n\t\t\t}\n\t\t\tdecodedPayload, _ := base64.StdEncoding.DecodeString(v.env.Payload)\n\t\t\th := sha256.Sum256(decodedPayload)\n\t\t\twant = append(want, \"sha256:\"+hex.EncodeToString(h[:]))\n\n\t\t\tenvHashBytes := sha256.Sum256([]byte(*v.DSSEObj.ProposedContent.Envelope))\n\t\t\tenvHash := hex.EncodeToString(envHashBytes[:])\n\n\t\t\thashkey := strings.ToLower(fmt.Sprintf(\"sha256:%s\", envHash))\n\t\t\twant = append(want, hashkey)\n\t\t\twant = append(want, tt.want...)\n\t\t\tgot, err := v.IndexKeys()\n\t\t\tif err != nil {\n\t\t\t\tt.Error(err)\n\t\t\t}\n\t\t\tsort.Strings(got)\n\t\t\tsort.Strings(want)\n\t\t\tif !cmp.Equal(got, want, cmpopts.EquateEmpty()) {\n\t\t\t\tt.Errorf(\"V001Entry.IndexKeys() = %v, want %v\", got, want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestInsertable(t *testing.T) {\n\ttype TestCase struct {\n\t\tcaseDesc      string\n\t\tentry         V001Entry\n\t\texpectSuccess bool\n\t}\n\n\ttestCases := []TestCase{\n\t\t{\n\t\t\tcaseDesc: \"valid entry\",\n\t\t\tentry: V001Entry{\n\t\t\t\tDSSEObj: models.DSSEV001Schema{\n\t\t\t\t\tProposedContent: &models.DSSEV001SchemaProposedContent{\n\t\t\t\t\t\tEnvelope: swag.String(\"envelope\"),\n\t\t\t\t\t\tVerifiers: []strfmt.Base64{\n\t\t\t\t\t\t\t[]byte(\"keys\"),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectSuccess: true,\n\t\t},\n\t\t{\n\t\t\tcaseDesc: \"missing public keys\",\n\t\t\tentry: V001Entry{\n\t\t\t\tDSSEObj: models.DSSEV001Schema{\n\t\t\t\t\tProposedContent: &models.DSSEV001SchemaProposedContent{\n\t\t\t\t\t\tEnvelope: swag.String(\"envelope\"),\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t\tVerifiers: []strfmt.Base64{\n\t\t\t\t\t\t\t\t[]byte(\"keys\"),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t*/\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectSuccess: false,\n\t\t},\n\t\t{\n\t\t\tcaseDesc: \"missing envelope\",\n\t\t\tentry: V001Entry{\n\t\t\t\tDSSEObj: models.DSSEV001Schema{\n\t\t\t\t\tProposedContent: &models.DSSEV001SchemaProposedContent{\n\t\t\t\t\t\t//Envelope: swag.String(\"envelope\"),\n\t\t\t\t\t\tVerifiers: []strfmt.Base64{\n\t\t\t\t\t\t\t[]byte(\"keys\"),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectSuccess: false,\n\t\t},\n\t\t{\n\t\t\tcaseDesc: \"missing proposed content obj\",\n\t\t\tentry: V001Entry{\n\t\t\t\tDSSEObj: models.DSSEV001Schema{\n\t\t\t\t\t/*\n\t\t\t\t\t\tProposedContent: &models.DSSEV001SchemaProposedContent{\n\t\t\t\t\t\t\tEnvelope: swag.String(\"envelope\"),\n\t\t\t\t\t\t\tVerifiers: []strfmt.Base64{\n\t\t\t\t\t\t\t\t[]byte(\"keys\"),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t*/\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectSuccess: false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.caseDesc, func(t *testing.T) {\n\t\t\tif ok, err := tc.entry.Insertable(); ok != tc.expectSuccess {\n\t\t\t\tt.Errorf(\"unexpected result calling Insertable: %v\", err)\n\t\t\t}\n\t\t})\n\t}\n}\n", "//\n// Copyright 2022 The Sigstore Authors.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage intoto\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"crypto\"\n\t\"crypto/sha256\"\n\t\"encoding/base64\"\n\t\"encoding/hex\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\n\t\"github.com/in-toto/in-toto-golang/in_toto\"\n\t\"github.com/secure-systems-lab/go-securesystemslib/dsse\"\n\t\"github.com/spf13/viper\"\n\t\"golang.org/x/exp/slices\"\n\n\t\"github.com/go-openapi/strfmt\"\n\t\"github.com/go-openapi/swag\"\n\n\t\"github.com/sigstore/rekor/pkg/generated/models\"\n\t\"github.com/sigstore/rekor/pkg/log\"\n\t\"github.com/sigstore/rekor/pkg/pki\"\n\t\"github.com/sigstore/rekor/pkg/pki/x509\"\n\t\"github.com/sigstore/rekor/pkg/types\"\n\t\"github.com/sigstore/rekor/pkg/types/intoto\"\n\t\"github.com/sigstore/sigstore/pkg/signature\"\n\t\"github.com/sigstore/sigstore/pkg/signature/options\"\n)\n\nconst (\n\tAPIVERSION = \"0.0.2\"\n)\n\nfunc init() {\n\tif err := intoto.VersionMap.SetEntryFactory(APIVERSION, NewEntry); err != nil {\n\t\tlog.Logger.Panic(err)\n\t}\n}\n\ntype V002Entry struct {\n\tIntotoObj models.IntotoV002Schema\n\tenv       dsse.Envelope\n}\n\nfunc (v V002Entry) APIVersion() string {\n\treturn APIVERSION\n}\n\nfunc NewEntry() types.EntryImpl {\n\treturn &V002Entry{}\n}\n\nfunc (v V002Entry) IndexKeys() ([]string, error) {\n\tvar result []string\n\n\tif v.IntotoObj.Content == nil || v.IntotoObj.Content.Envelope == nil {\n\t\tlog.Logger.Info(\"IntotoObj content or dsse envelope is nil\")\n\t\treturn result, nil\n\t}\n\n\tfor _, sig := range v.IntotoObj.Content.Envelope.Signatures {\n\t\tif sig == nil || sig.PublicKey == nil {\n\t\t\treturn result, errors.New(\"malformed or missing signature\")\n\t\t}\n\t\tkeyObj, err := x509.NewPublicKey(bytes.NewReader(*sig.PublicKey))\n\t\tif err != nil {\n\t\t\treturn result, err\n\t\t}\n\n\t\tcanonKey, err := keyObj.CanonicalValue()\n\t\tif err != nil {\n\t\t\treturn result, fmt.Errorf(\"could not canonicize key: %w\", err)\n\t\t}\n\n\t\tkeyHash := sha256.Sum256(canonKey)\n\t\tresult = append(result, \"sha256:\"+hex.EncodeToString(keyHash[:]))\n\n\t\tresult = append(result, keyObj.Subjects()...)\n\t}\n\n\tpayloadKey := strings.ToLower(fmt.Sprintf(\"%s:%s\", *v.IntotoObj.Content.PayloadHash.Algorithm, *v.IntotoObj.Content.PayloadHash.Value))\n\tresult = append(result, payloadKey)\n\n\t// since we can't deterministically calculate this server-side (due to public keys being added inline, and also canonicalization being potentially different),\n\t// we'll just skip adding this index key\n\t// hashkey := strings.ToLower(fmt.Sprintf(\"%s:%s\", *v.IntotoObj.Content.Hash.Algorithm, *v.IntotoObj.Content.Hash.Value))\n\t// result = append(result, hashkey)\n\n\tswitch *v.IntotoObj.Content.Envelope.PayloadType {\n\tcase in_toto.PayloadType:\n\n\t\tif v.IntotoObj.Content.Envelope.Payload == nil {\n\t\t\tlog.Logger.Info(\"IntotoObj DSSE payload is empty\")\n\t\t\treturn result, nil\n\t\t}\n\t\tdecodedPayload, err := base64.StdEncoding.DecodeString(string(v.IntotoObj.Content.Envelope.Payload))\n\t\tif err != nil {\n\t\t\treturn result, fmt.Errorf(\"could not decode envelope payload: %w\", err)\n\t\t}\n\t\tstatement, err := parseStatement(decodedPayload)\n\t\tif err != nil {\n\t\t\treturn result, err\n\t\t}\n\t\tfor _, s := range statement.Subject {\n\t\t\tfor alg, ds := range s.Digest {\n\t\t\t\tresult = append(result, alg+\":\"+ds)\n\t\t\t}\n\t\t}\n\t\t// Not all in-toto statements will contain a SLSA provenance predicate.\n\t\t// See https://github.com/in-toto/attestation/blob/main/spec/README.md#predicate\n\t\t// for other predicates.\n\t\tif predicate, err := parseSlsaPredicate(decodedPayload); err == nil {\n\t\t\tif predicate.Predicate.Materials != nil {\n\t\t\t\tfor _, s := range predicate.Predicate.Materials {\n\t\t\t\t\tfor alg, ds := range s.Digest {\n\t\t\t\t\t\tresult = append(result, alg+\":\"+ds)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tdefault:\n\t\tlog.Logger.Infof(\"Unknown in_toto DSSE envelope Type: %s\", *v.IntotoObj.Content.Envelope.PayloadType)\n\t}\n\treturn result, nil\n}\n\nfunc parseStatement(p []byte) (*in_toto.Statement, error) {\n\tps := in_toto.Statement{}\n\tif err := json.Unmarshal(p, &ps); err != nil {\n\t\treturn nil, err\n\t}\n\treturn &ps, nil\n}\n\nfunc parseSlsaPredicate(p []byte) (*in_toto.ProvenanceStatement, error) {\n\tpredicate := in_toto.ProvenanceStatement{}\n\tif err := json.Unmarshal(p, &predicate); err != nil {\n\t\treturn nil, err\n\t}\n\treturn &predicate, nil\n}\n\nfunc (v *V002Entry) Unmarshal(pe models.ProposedEntry) error {\n\tit, ok := pe.(*models.Intoto)\n\tif !ok {\n\t\treturn errors.New(\"cannot unmarshal non Intoto v0.0.2 type\")\n\t}\n\n\tvar err error\n\tif err := types.DecodeEntry(it.Spec, &v.IntotoObj); err != nil {\n\t\treturn err\n\t}\n\n\t// field validation\n\tif err := v.IntotoObj.Validate(strfmt.Default); err != nil {\n\t\treturn err\n\t}\n\n\tif string(v.IntotoObj.Content.Envelope.Payload) == \"\" {\n\t\treturn nil\n\t}\n\n\tenv := &dsse.Envelope{\n\t\tPayload:     string(v.IntotoObj.Content.Envelope.Payload),\n\t\tPayloadType: *v.IntotoObj.Content.Envelope.PayloadType,\n\t}\n\n\tallPubKeyBytes := make([][]byte, 0)\n\tfor i, sig := range v.IntotoObj.Content.Envelope.Signatures {\n\t\tif sig == nil {\n\t\t\tv.IntotoObj.Content.Envelope.Signatures = slices.Delete(v.IntotoObj.Content.Envelope.Signatures, i, i)\n\t\t\tcontinue\n\t\t}\n\t\tenv.Signatures = append(env.Signatures, dsse.Signature{\n\t\t\tKeyID: sig.Keyid,\n\t\t\tSig:   string(*sig.Sig),\n\t\t})\n\n\t\tallPubKeyBytes = append(allPubKeyBytes, *sig.PublicKey)\n\t}\n\n\tif _, err := verifyEnvelope(allPubKeyBytes, env); err != nil {\n\t\treturn err\n\t}\n\n\tv.env = *env\n\n\tdecodedPayload, err := base64.StdEncoding.DecodeString(string(v.IntotoObj.Content.Envelope.Payload))\n\tif err != nil {\n\t\treturn fmt.Errorf(\"could not decode envelope payload: %w\", err)\n\t}\n\n\th := sha256.Sum256(decodedPayload)\n\tv.IntotoObj.Content.PayloadHash = &models.IntotoV002SchemaContentPayloadHash{\n\t\tAlgorithm: swag.String(models.IntotoV002SchemaContentPayloadHashAlgorithmSha256),\n\t\tValue:     swag.String(hex.EncodeToString(h[:])),\n\t}\n\n\treturn nil\n}\n\nfunc (v *V002Entry) Canonicalize(_ context.Context) ([]byte, error) {\n\tif err := v.IntotoObj.Validate(strfmt.Default); err != nil {\n\t\treturn nil, err\n\t}\n\n\tif v.IntotoObj.Content.Hash == nil {\n\t\treturn nil, errors.New(\"missing envelope digest\")\n\t}\n\n\tif err := v.IntotoObj.Content.Hash.Validate(strfmt.Default); err != nil {\n\t\treturn nil, fmt.Errorf(\"error validating envelope digest: %w\", err)\n\t}\n\n\tif v.IntotoObj.Content.PayloadHash == nil {\n\t\treturn nil, errors.New(\"missing payload digest\")\n\t}\n\n\tif err := v.IntotoObj.Content.PayloadHash.Validate(strfmt.Default); err != nil {\n\t\treturn nil, fmt.Errorf(\"error validating payload digest: %w\", err)\n\t}\n\n\tif len(v.IntotoObj.Content.Envelope.Signatures) == 0 {\n\t\treturn nil, errors.New(\"missing signatures\")\n\t}\n\n\tcanonicalEntry := models.IntotoV002Schema{\n\t\tContent: &models.IntotoV002SchemaContent{\n\t\t\tEnvelope: &models.IntotoV002SchemaContentEnvelope{\n\t\t\t\tPayloadType: v.IntotoObj.Content.Envelope.PayloadType,\n\t\t\t\tSignatures:  v.IntotoObj.Content.Envelope.Signatures,\n\t\t\t},\n\t\t\tHash:        v.IntotoObj.Content.Hash,\n\t\t\tPayloadHash: v.IntotoObj.Content.PayloadHash,\n\t\t},\n\t}\n\titObj := models.Intoto{}\n\titObj.APIVersion = swag.String(APIVERSION)\n\titObj.Spec = &canonicalEntry\n\n\treturn json.Marshal(&itObj)\n}\n\n// AttestationKey returns the digest of the attestation that was uploaded, to be used to lookup the attestation from storage\nfunc (v *V002Entry) AttestationKey() string {\n\tif v.IntotoObj.Content != nil && v.IntotoObj.Content.PayloadHash != nil {\n\t\treturn fmt.Sprintf(\"%s:%s\", *v.IntotoObj.Content.PayloadHash.Algorithm, *v.IntotoObj.Content.PayloadHash.Value)\n\t}\n\treturn \"\"\n}\n\n// AttestationKeyValue returns both the key and value to be persisted into attestation storage\nfunc (v *V002Entry) AttestationKeyValue() (string, []byte) {\n\tstorageSize := base64.StdEncoding.DecodedLen(len(v.env.Payload))\n\tif storageSize > viper.GetInt(\"max_attestation_size\") {\n\t\tlog.Logger.Infof(\"Skipping attestation storage, size %d is greater than max %d\", storageSize, viper.GetInt(\"max_attestation_size\"))\n\t\treturn \"\", nil\n\t}\n\tattBytes, err := base64.StdEncoding.DecodeString(v.env.Payload)\n\tif err != nil {\n\t\tlog.Logger.Infof(\"could not decode envelope payload: %w\", err)\n\t\treturn \"\", nil\n\t}\n\treturn v.AttestationKey(), attBytes\n}\n\ntype verifier struct {\n\ts signature.Signer\n\tv signature.Verifier\n}\n\nfunc (v *verifier) KeyID() (string, error) {\n\treturn \"\", nil\n}\n\nfunc (v *verifier) Public() crypto.PublicKey {\n\t// the dsse library uses this to generate a key ID if the KeyID function returns an empty string\n\t// as well for the AcceptedKey return value.  Unfortunately since key ids can be arbitrary, we don't\n\t// know how to generate a matching id for the key id on the envelope's signature...\n\t// dsse verify will skip verifiers whose key id doesn't match the signature's key id, unless it fails\n\t// to generate one from the public key... so we trick it by returning nil \u00af\\_(\u30c4)_/\u00af\n\treturn nil\n}\n\nfunc (v *verifier) Sign(_ context.Context, data []byte) (sig []byte, err error) {\n\tif v.s == nil {\n\t\treturn nil, errors.New(\"nil signer\")\n\t}\n\tsig, err = v.s.SignMessage(bytes.NewReader(data), options.WithCryptoSignerOpts(crypto.SHA256))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn sig, nil\n}\n\nfunc (v *verifier) Verify(_ context.Context, data, sig []byte) error {\n\tif v.v == nil {\n\t\treturn errors.New(\"nil verifier\")\n\t}\n\treturn v.v.VerifySignature(bytes.NewReader(sig), bytes.NewReader(data))\n}\n\nfunc (v V002Entry) CreateFromArtifactProperties(_ context.Context, props types.ArtifactProperties) (models.ProposedEntry, error) {\n\treturnVal := models.Intoto{}\n\tre := V002Entry{\n\t\tIntotoObj: models.IntotoV002Schema{\n\t\t\tContent: &models.IntotoV002SchemaContent{\n\t\t\t\tEnvelope: &models.IntotoV002SchemaContentEnvelope{},\n\t\t\t},\n\t\t}}\n\tvar err error\n\tartifactBytes := props.ArtifactBytes\n\tif artifactBytes == nil {\n\t\tif props.ArtifactPath == nil {\n\t\t\treturn nil, errors.New(\"path to artifact file must be specified\")\n\t\t}\n\t\tif props.ArtifactPath.IsAbs() {\n\t\t\treturn nil, errors.New(\"intoto envelopes cannot be fetched over HTTP(S)\")\n\t\t}\n\t\tartifactBytes, err = os.ReadFile(filepath.Clean(props.ArtifactPath.Path))\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\tenv := dsse.Envelope{}\n\tif err := json.Unmarshal(artifactBytes, &env); err != nil {\n\t\treturn nil, fmt.Errorf(\"payload must be a valid dsse envelope: %w\", err)\n\t}\n\n\tallPubKeyBytes := make([][]byte, 0)\n\tif len(props.PublicKeyBytes) > 0 {\n\t\tallPubKeyBytes = append(allPubKeyBytes, props.PublicKeyBytes...)\n\t}\n\n\tif len(props.PublicKeyPaths) > 0 {\n\t\tfor _, path := range props.PublicKeyPaths {\n\t\t\tif path.IsAbs() {\n\t\t\t\treturn nil, errors.New(\"dsse public keys cannot be fetched over HTTP(S)\")\n\t\t\t}\n\n\t\t\tpublicKeyBytes, err := os.ReadFile(filepath.Clean(path.Path))\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"error reading public key file: %w\", err)\n\t\t\t}\n\n\t\t\tallPubKeyBytes = append(allPubKeyBytes, publicKeyBytes)\n\t\t}\n\t}\n\n\tkeysBySig, err := verifyEnvelope(allPubKeyBytes, &env)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tb64 := strfmt.Base64([]byte(env.Payload))\n\tre.IntotoObj.Content.Envelope.Payload = b64\n\tre.IntotoObj.Content.Envelope.PayloadType = &env.PayloadType\n\n\tfor _, sig := range env.Signatures {\n\t\tkey, ok := keysBySig[sig.Sig]\n\t\tif !ok {\n\t\t\treturn nil, errors.New(\"all signatures must have a key that verifies it\")\n\t\t}\n\n\t\tcanonKey, err := key.CanonicalValue()\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"could not canonicize key: %w\", err)\n\t\t}\n\n\t\tkeyBytes := strfmt.Base64(canonKey)\n\t\tsigBytes := strfmt.Base64([]byte(sig.Sig))\n\t\tre.IntotoObj.Content.Envelope.Signatures = append(re.IntotoObj.Content.Envelope.Signatures, &models.IntotoV002SchemaContentEnvelopeSignaturesItems0{\n\t\t\tKeyid:     sig.KeyID,\n\t\t\tSig:       &sigBytes,\n\t\t\tPublicKey: &keyBytes,\n\t\t})\n\t}\n\n\th := sha256.Sum256([]byte(artifactBytes))\n\tre.IntotoObj.Content.Hash = &models.IntotoV002SchemaContentHash{\n\t\tAlgorithm: swag.String(models.IntotoV001SchemaContentHashAlgorithmSha256),\n\t\tValue:     swag.String(hex.EncodeToString(h[:])),\n\t}\n\n\treturnVal.Spec = re.IntotoObj\n\treturnVal.APIVersion = swag.String(re.APIVersion())\n\n\treturn &returnVal, nil\n}\n\n// verifyEnvelope takes in an array of possible key bytes and attempts to parse them as x509 public keys.\n// it then uses these to verify the envelope and makes sure that every signature on the envelope is verified.\n// it returns a map of verifiers indexed by the signature the verifier corresponds to.\nfunc verifyEnvelope(allPubKeyBytes [][]byte, env *dsse.Envelope) (map[string]*x509.PublicKey, error) {\n\t// generate a fake id for these keys so we can get back to the key bytes and match them to their corresponding signature\n\tverifierBySig := make(map[string]*x509.PublicKey)\n\tallSigs := make(map[string]struct{})\n\tfor _, sig := range env.Signatures {\n\t\tallSigs[sig.Sig] = struct{}{}\n\t}\n\n\tfor _, pubKeyBytes := range allPubKeyBytes {\n\t\tkey, err := x509.NewPublicKey(bytes.NewReader(pubKeyBytes))\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"could not parse public key as x509: %w\", err)\n\t\t}\n\n\t\tvfr, err := signature.LoadVerifier(key.CryptoPubKey(), crypto.SHA256)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"could not load verifier: %w\", err)\n\t\t}\n\n\t\tdsseVfr, err := dsse.NewEnvelopeVerifier(&verifier{\n\t\t\tv: vfr,\n\t\t})\n\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"could not use public key as a dsse verifier: %w\", err)\n\t\t}\n\n\t\taccepted, err := dsseVfr.Verify(context.Background(), env)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"could not verify envelope: %w\", err)\n\t\t}\n\n\t\tfor _, accept := range accepted {\n\t\t\tdelete(allSigs, accept.Sig.Sig)\n\t\t\tverifierBySig[accept.Sig.Sig] = key\n\t\t}\n\t}\n\n\tif len(allSigs) > 0 {\n\t\treturn nil, errors.New(\"all signatures must have a key that verifies it\")\n\t}\n\n\treturn verifierBySig, nil\n}\n\nfunc (v V002Entry) Verifier() (pki.PublicKey, error) {\n\tif v.IntotoObj.Content == nil || v.IntotoObj.Content.Envelope == nil {\n\t\treturn nil, errors.New(\"intoto v0.0.2 entry not initialized\")\n\t}\n\n\tsigs := v.IntotoObj.Content.Envelope.Signatures\n\tif len(sigs) == 0 {\n\t\treturn nil, errors.New(\"no signatures found on intoto entry\")\n\t}\n\n\treturn x509.NewPublicKey(bytes.NewReader(*v.IntotoObj.Content.Envelope.Signatures[0].PublicKey))\n}\n\nfunc (v V002Entry) Insertable() (bool, error) {\n\tif v.IntotoObj.Content == nil {\n\t\treturn false, errors.New(\"missing content property\")\n\t}\n\tif v.IntotoObj.Content.Envelope == nil {\n\t\treturn false, errors.New(\"missing envelope property\")\n\t}\n\tif len(v.IntotoObj.Content.Envelope.Payload) == 0 {\n\t\treturn false, errors.New(\"missing envelope content\")\n\t}\n\n\tif v.IntotoObj.Content.Envelope.PayloadType == nil || len(*v.IntotoObj.Content.Envelope.PayloadType) == 0 {\n\t\treturn false, errors.New(\"missing payloadType content\")\n\t}\n\n\tif len(v.IntotoObj.Content.Envelope.Signatures) == 0 {\n\t\treturn false, errors.New(\"missing signatures content\")\n\t}\n\tfor _, sig := range v.IntotoObj.Content.Envelope.Signatures {\n\t\tif sig == nil {\n\t\t\treturn false, errors.New(\"missing signature entry\")\n\t\t}\n\t\tif sig.Sig == nil || len(*sig.Sig) == 0 {\n\t\t\treturn false, errors.New(\"missing signature content\")\n\t\t}\n\t\tif sig.PublicKey == nil || len(*sig.PublicKey) == 0 {\n\t\t\treturn false, errors.New(\"missing publicKey content\")\n\t\t}\n\t}\n\n\tif v.env.Payload == \"\" || v.env.PayloadType == \"\" || len(v.env.Signatures) == 0 {\n\t\treturn false, errors.New(\"invalid DSSE envelope\")\n\t}\n\n\treturn true, nil\n}\n", "//\n// Copyright 2022 The Sigstore Authors.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage intoto\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"crypto\"\n\t\"crypto/ecdsa\"\n\t\"crypto/elliptic\"\n\t\"crypto/rand\"\n\t\"crypto/sha256\"\n\t\"crypto/x509\"\n\t\"encoding/base64\"\n\t\"encoding/hex\"\n\t\"encoding/json\"\n\t\"encoding/pem\"\n\t\"fmt\"\n\t\"math/big\"\n\t\"reflect\"\n\t\"sort\"\n\t\"testing\"\n\n\t\"github.com/go-openapi/runtime\"\n\t\"github.com/go-openapi/strfmt\"\n\t\"github.com/go-openapi/swag\"\n\t\"github.com/google/go-cmp/cmp\"\n\t\"github.com/google/go-cmp/cmp/cmpopts\"\n\t\"github.com/in-toto/in-toto-golang/in_toto\"\n\t\"github.com/in-toto/in-toto-golang/in_toto/slsa_provenance/common\"\n\tslsa \"github.com/in-toto/in-toto-golang/in_toto/slsa_provenance/v0.2\"\n\t\"github.com/secure-systems-lab/go-securesystemslib/dsse\"\n\t\"github.com/sigstore/rekor/pkg/generated/models\"\n\t\"github.com/sigstore/rekor/pkg/types\"\n\t\"github.com/sigstore/sigstore/pkg/signature\"\n\t\"go.uber.org/goleak\"\n)\n\nfunc TestMain(m *testing.M) {\n\tgoleak.VerifyTestMain(m)\n}\n\nfunc TestNewEntryReturnType(t *testing.T) {\n\tentry := NewEntry()\n\tif reflect.TypeOf(entry) != reflect.ValueOf(&V002Entry{}).Type() {\n\t\tt.Errorf(\"invalid type returned from NewEntry: %T\", entry)\n\t}\n}\n\nfunc envelope(t *testing.T, k *ecdsa.PrivateKey, payload []byte) *dsse.Envelope {\n\ts, err := signature.LoadECDSASigner(k, crypto.SHA256)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tsigner, err := dsse.NewEnvelopeSigner(\n\t\t&verifier{\n\t\t\ts: s,\n\t\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdsseEnv, err := signer.SignPayload(context.Background(), \"application/vnd.in-toto+json\", payload)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\treturn dsseEnv\n}\n\nfunc multiSignEnvelope(t *testing.T, k []*ecdsa.PrivateKey, payload []byte) *dsse.Envelope {\n\tevps := []*verifier{}\n\tfor _, key := range k {\n\t\ts, err := signature.LoadECDSASigner(key, crypto.SHA256)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tevps = append(evps, &verifier{\n\t\t\ts: s,\n\t\t})\n\t}\n\n\tsigner, err := dsse.NewMultiEnvelopeSigner(2, evps[0], evps[1])\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdsseEnv, err := signer.SignPayload(context.Background(), in_toto.PayloadType, payload)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\treturn dsseEnv\n}\n\nfunc createRekorEnvelope(dsseEnv *dsse.Envelope, pub [][]byte) *models.IntotoV002SchemaContentEnvelope {\n\tenv := &models.IntotoV002SchemaContentEnvelope{}\n\tb64 := strfmt.Base64([]byte(dsseEnv.Payload))\n\tenv.Payload = b64\n\tenv.PayloadType = &dsseEnv.PayloadType\n\n\tfor i, sig := range dsseEnv.Signatures {\n\t\tkeyBytes := strfmt.Base64(pub[i])\n\t\tsigBytes := strfmt.Base64([]byte(sig.Sig))\n\t\tenv.Signatures = append(env.Signatures, &models.IntotoV002SchemaContentEnvelopeSignaturesItems0{\n\t\t\tKeyid:     sig.KeyID,\n\t\t\tSig:       &sigBytes,\n\t\t\tPublicKey: &keyBytes,\n\t\t})\n\t}\n\n\treturn env\n}\n\nfunc envelopeHash(t *testing.T, dsseEnv *dsse.Envelope) string {\n\tval, err := json.Marshal(dsseEnv)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\th := sha256.Sum256(val)\n\treturn hex.EncodeToString(h[:])\n}\n\nfunc TestV002Entry_Unmarshal(t *testing.T) {\n\tkey, err := ecdsa.GenerateKey(elliptic.P256(), rand.Reader)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tder, err := x509.MarshalPKIXPublicKey(&key.PublicKey)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tpub := pem.EncodeToMemory(&pem.Block{\n\t\tBytes: der,\n\t\tType:  \"PUBLIC KEY\",\n\t})\n\n\tpriv, err := ecdsa.GenerateKey(elliptic.P256(), rand.Reader)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tca := &x509.Certificate{\n\t\tSerialNumber: big.NewInt(1),\n\t}\n\tcaBytes, err := x509.CreateCertificate(rand.Reader, ca, ca, &priv.PublicKey, priv)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tpemBytes := pem.EncodeToMemory(&pem.Block{\n\t\tType:  \"CERTIFICATE\",\n\t\tBytes: caBytes,\n\t})\n\n\tinvalid := dsse.Envelope{\n\t\tPayload: \"hello\",\n\t\tSignatures: []dsse.Signature{\n\t\t\t{\n\t\t\t\tSig: string(strfmt.Base64(\"foobar\")),\n\t\t\t},\n\t\t},\n\t}\n\n\tvalidPayload := \"hellothispayloadisvalid\"\n\tkeyBytes := strfmt.Base64(\"key\")\n\tsigBytes := strfmt.Base64(\"sig\")\n\n\ttests := []struct {\n\t\tenv             *dsse.Envelope\n\t\tname            string\n\t\tit              *models.IntotoV002Schema\n\t\twantErr         bool\n\t\twantVerifierErr bool\n\t}{\n\t\t{\n\t\t\tname:            \"empty\",\n\t\t\tit:              &models.IntotoV002Schema{},\n\t\t\twantErr:         true,\n\t\t\twantVerifierErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"missing envelope\",\n\t\t\tit: &models.IntotoV002Schema{\n\t\t\t\tContent: &models.IntotoV002SchemaContent{\n\t\t\t\t\tHash: &models.IntotoV002SchemaContentHash{\n\t\t\t\t\t\tAlgorithm: swag.String(models.IntotoV002SchemaContentHashAlgorithmSha256),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr:         true,\n\t\t\twantVerifierErr: true,\n\t\t},\n\t\t{\n\t\t\tenv:  envelope(t, key, []byte(validPayload)),\n\t\t\tname: \"valid\",\n\t\t\tit: &models.IntotoV002Schema{\n\t\t\t\tContent: &models.IntotoV002SchemaContent{\n\t\t\t\t\tEnvelope: createRekorEnvelope(envelope(t, key, []byte(validPayload)), [][]byte{pub}),\n\t\t\t\t\tHash: &models.IntotoV002SchemaContentHash{\n\t\t\t\t\t\tAlgorithm: swag.String(models.IntotoV002SchemaContentHashAlgorithmSha256),\n\t\t\t\t\t\tValue:     swag.String(envelopeHash(t, envelope(t, key, []byte(validPayload)))),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr:         false,\n\t\t\twantVerifierErr: false,\n\t\t},\n\t\t{\n\t\t\tenv:  envelope(t, priv, []byte(validPayload)),\n\t\t\tname: \"cert\",\n\t\t\tit: &models.IntotoV002Schema{\n\t\t\t\tContent: &models.IntotoV002SchemaContent{\n\t\t\t\t\tEnvelope: createRekorEnvelope(envelope(t, priv, []byte(validPayload)), [][]byte{pemBytes}),\n\t\t\t\t\tHash: &models.IntotoV002SchemaContentHash{\n\t\t\t\t\t\tAlgorithm: swag.String(models.IntotoV002SchemaContentHashAlgorithmSha256),\n\t\t\t\t\t\tValue:     swag.String(envelopeHash(t, envelope(t, priv, []byte(validPayload)))),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr:         false,\n\t\t\twantVerifierErr: false,\n\t\t},\n\t\t{\n\t\t\tenv:  &invalid,\n\t\t\tname: \"invalid\",\n\t\t\tit: &models.IntotoV002Schema{\n\t\t\t\tContent: &models.IntotoV002SchemaContent{\n\t\t\t\t\tEnvelope: createRekorEnvelope(&invalid, [][]byte{pub}),\n\t\t\t\t\tHash: &models.IntotoV002SchemaContentHash{\n\t\t\t\t\t\tAlgorithm: swag.String(models.IntotoV002SchemaContentHashAlgorithmSha256),\n\t\t\t\t\t\tValue:     swag.String(envelopeHash(t, &invalid)),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr:         true,\n\t\t\twantVerifierErr: false,\n\t\t},\n\t\t{\n\t\t\tenv:  envelope(t, key, []byte(validPayload)),\n\t\t\tname: \"invalid key\",\n\t\t\tit: &models.IntotoV002Schema{\n\t\t\t\tContent: &models.IntotoV002SchemaContent{\n\t\t\t\t\tEnvelope: createRekorEnvelope(envelope(t, key, []byte(validPayload)), [][]byte{[]byte(\"notavalidkey\")}),\n\t\t\t\t\tHash: &models.IntotoV002SchemaContentHash{\n\t\t\t\t\t\tAlgorithm: swag.String(models.IntotoV002SchemaContentHashAlgorithmSha256),\n\t\t\t\t\t\tValue:     swag.String(envelopeHash(t, envelope(t, key, []byte(validPayload)))),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr:         true,\n\t\t\twantVerifierErr: true,\n\t\t},\n\t\t{\n\t\t\tenv:  multiSignEnvelope(t, []*ecdsa.PrivateKey{key, priv}, []byte(validPayload)),\n\t\t\tname: \"multi-key\",\n\t\t\tit: &models.IntotoV002Schema{\n\t\t\t\tContent: &models.IntotoV002SchemaContent{\n\t\t\t\t\tEnvelope: createRekorEnvelope(multiSignEnvelope(t, []*ecdsa.PrivateKey{key, priv}, []byte(validPayload)), [][]byte{pub, pemBytes}),\n\t\t\t\t\tHash: &models.IntotoV002SchemaContentHash{\n\t\t\t\t\t\tAlgorithm: swag.String(models.IntotoV002SchemaContentHashAlgorithmSha256),\n\t\t\t\t\t\tValue:     swag.String(envelopeHash(t, multiSignEnvelope(t, []*ecdsa.PrivateKey{key, priv}, []byte(validPayload)))),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr:         false,\n\t\t\twantVerifierErr: false,\n\t\t},\n\t\t{\n\t\t\tenv:  envelope(t, key, []byte(validPayload)),\n\t\t\tname: \"null array entry\",\n\t\t\tit: &models.IntotoV002Schema{\n\t\t\t\tContent: &models.IntotoV002SchemaContent{\n\t\t\t\t\tEnvelope: &models.IntotoV002SchemaContentEnvelope{\n\t\t\t\t\t\tPayload:     strfmt.Base64(\"cGF5bG9hZAo=\"),\n\t\t\t\t\t\tPayloadType: swag.String(\"payloadType\"),\n\t\t\t\t\t\tSignatures: []*models.IntotoV002SchemaContentEnvelopeSignaturesItems0{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tPublicKey: &keyBytes,\n\t\t\t\t\t\t\t\tSig:       &sigBytes,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tnil,\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tHash: &models.IntotoV002SchemaContentHash{\n\t\t\t\t\t\tAlgorithm: swag.String(models.IntotoV002SchemaContentHashAlgorithmSha256),\n\t\t\t\t\t\tValue:     swag.String(envelopeHash(t, envelope(t, key, []byte(validPayload)))),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr:         true,\n\t\t\twantVerifierErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tv := &V002Entry{}\n\n\t\t\tit := &models.Intoto{\n\t\t\t\tSpec: tt.it,\n\t\t\t}\n\n\t\t\tvar uv = func() error {\n\t\t\t\tif err := v.Unmarshal(it); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\n\t\t\t\tif !tt.wantErr {\n\t\t\t\t\tif ok, err := v.Insertable(); !ok || err != nil {\n\t\t\t\t\t\tt.Errorf(\"unexpected error calling insertable on valid proposed entry: %v\", err)\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\twant := []string{}\n\t\t\t\tfor _, sig := range v.IntotoObj.Content.Envelope.Signatures {\n\t\t\t\t\tkeyHash := sha256.Sum256(*sig.PublicKey)\n\t\t\t\t\twant = append(want, \"sha256:\"+hex.EncodeToString(keyHash[:]))\n\t\t\t\t}\n\t\t\t\tdecodedPayload, err := base64.StdEncoding.DecodeString(tt.env.Payload)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn fmt.Errorf(\"could not decode envelope payload: %w\", err)\n\t\t\t\t}\n\t\t\t\th := sha256.Sum256(decodedPayload)\n\t\t\t\twant = append(want, \"sha256:\"+hex.EncodeToString(h[:]))\n\n\t\t\t\tif !reflect.DeepEqual(v.AttestationKey(), \"sha256:\"+hex.EncodeToString(h[:])) {\n\t\t\t\t\tt.Errorf(\"V002Entry.AttestationKey() = %v, want %v\", v.AttestationKey(), \"sha256:\"+hex.EncodeToString(h[:]))\n\t\t\t\t}\n\n\t\t\t\tgot, _ := v.IndexKeys()\n\t\t\t\tsort.Strings(got)\n\t\t\t\tsort.Strings(want)\n\t\t\t\tif !reflect.DeepEqual(got, want) {\n\t\t\t\t\tt.Errorf(\"V002Entry.IndexKeys() = %v, want %v\", got, want)\n\t\t\t\t}\n\t\t\t\tpayloadBytes, _ := v.env.DecodeB64Payload()\n\t\t\t\tpayloadSha := sha256.Sum256(payloadBytes)\n\t\t\t\tpayloadHash := hex.EncodeToString(payloadSha[:])\n\n\t\t\t\tcanonicalBytes, err := v.Canonicalize(context.Background())\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Errorf(\"error canonicalizing entry: %v\", err)\n\t\t\t\t}\n\n\t\t\t\tpe, err := models.UnmarshalProposedEntry(bytes.NewReader(canonicalBytes), runtime.JSONConsumer())\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Errorf(\"unexpected err from Unmarshalling canonicalized entry for '%v': %v\", tt.name, err)\n\t\t\t\t}\n\t\t\t\tcanonicalEntry, err := types.UnmarshalEntry(pe)\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Errorf(\"unexpected err from type-specific unmarshalling for '%v': %v\", tt.name, err)\n\t\t\t\t}\n\t\t\t\tif ok, err := canonicalEntry.Insertable(); ok || err == nil {\n\t\t\t\t\tt.Errorf(\"unexpected success calling Insertable on entry created from canonicalized content\")\n\t\t\t\t}\n\t\t\t\tcanonicalV002 := canonicalEntry.(*V002Entry)\n\t\t\t\tfmt.Printf(\"%v\", canonicalV002.IntotoObj.Content)\n\t\t\t\tif *canonicalV002.IntotoObj.Content.Hash.Value != *tt.it.Content.Hash.Value {\n\t\t\t\t\tt.Errorf(\"envelope hashes do not match post canonicalization: %v %v\", *canonicalV002.IntotoObj.Content.Hash.Value, *tt.it.Content.Hash.Value)\n\t\t\t\t}\n\t\t\t\tif canonicalV002.AttestationKey() != \"\" && *canonicalV002.IntotoObj.Content.PayloadHash.Value != payloadHash {\n\t\t\t\t\tt.Errorf(\"payload hashes do not match post canonicalization: %v %v\", canonicalV002.IntotoObj.Content.PayloadHash.Value, payloadHash)\n\t\t\t\t}\n\t\t\t\tcanonicalIndexKeys, _ := canonicalV002.IndexKeys()\n\t\t\t\tif !cmp.Equal(got, canonicalIndexKeys, cmpopts.SortSlices(func(x, y string) bool { return x < y })) {\n\t\t\t\t\tt.Errorf(\"index keys from hydrated object do not match those generated from canonicalized (and re-hydrated) object: %v %v\", got, canonicalIndexKeys)\n\t\t\t\t}\n\n\t\t\t\tverifier, err := v.Verifier()\n\t\t\t\tif !tt.wantVerifierErr {\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\tt.Errorf(\"%v: unexpected error, got %v\", tt.name, err)\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpubV, _ := verifier.CanonicalValue()\n\t\t\t\t\t\tif !reflect.DeepEqual(pubV, pub) && !reflect.DeepEqual(pubV, pemBytes) {\n\t\t\t\t\t\t\tt.Errorf(\"verifier and public keys do not match: %v, %v\", string(pubV), string(pub))\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif err == nil {\n\t\t\t\t\t\ts, _ := verifier.CanonicalValue()\n\t\t\t\t\t\tt.Errorf(\"%v: expected error for %v, got %v\", tt.name, string(s), err)\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\tif err := uv(); (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"V002Entry.Unmarshal() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestV002Entry_IndexKeys(t *testing.T) {\n\tkey, err := ecdsa.GenerateKey(elliptic.P256(), rand.Reader)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tder, err := x509.MarshalPKIXPublicKey(&key.PublicKey)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tpub := pem.EncodeToMemory(&pem.Block{\n\t\tBytes: der,\n\t\tType:  \"PUBLIC KEY\",\n\t})\n\n\ttests := []struct {\n\t\tname      string\n\t\tstatement in_toto.Statement\n\t\twant      []string\n\t}{\n\t\t{\n\t\t\tname: \"standard\",\n\t\t\twant: []string{},\n\t\t\tstatement: in_toto.Statement{\n\t\t\t\tPredicate: \"hello\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"subject\",\n\t\t\twant: []string{\"sha256:foo\"},\n\t\t\tstatement: in_toto.Statement{\n\t\t\t\tStatementHeader: in_toto.StatementHeader{\n\t\t\t\t\tSubject: []in_toto.Subject{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tName: \"foo\",\n\t\t\t\t\t\t\tDigest: map[string]string{\n\t\t\t\t\t\t\t\t\"sha256\": \"foo\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tPredicate: \"hello\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"slsa\",\n\t\t\twant: []string{\"sha256:bar\"},\n\t\t\tstatement: in_toto.Statement{\n\t\t\t\tPredicate: slsa.ProvenancePredicate{\n\t\t\t\t\tMaterials: []common.ProvenanceMaterial{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tURI: \"foo\",\n\t\t\t\t\t\t\tDigest: map[string]string{\n\t\t\t\t\t\t\t\t\"sha256\": \"bar\",\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"slsa wit header\",\n\t\t\twant: []string{\"sha256:foo\", \"sha256:bar\"},\n\t\t\tstatement: in_toto.Statement{\n\t\t\t\tStatementHeader: in_toto.StatementHeader{\n\t\t\t\t\tSubject: []in_toto.Subject{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tName: \"foo\",\n\t\t\t\t\t\t\tDigest: map[string]string{\n\t\t\t\t\t\t\t\t\"sha256\": \"foo\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tPredicate: slsa.ProvenancePredicate{\n\t\t\t\t\tMaterials: []common.ProvenanceMaterial{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tURI: \"foo\",\n\t\t\t\t\t\t\tDigest: map[string]string{\n\t\t\t\t\t\t\t\t\"sha256\": \"bar\",\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tb, err := json.Marshal(tt.statement)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tpayloadHash := sha256.Sum256(b)\n\t\t\tv := V002Entry{\n\t\t\t\tIntotoObj: models.IntotoV002Schema{\n\t\t\t\t\tContent: &models.IntotoV002SchemaContent{\n\t\t\t\t\t\tEnvelope: createRekorEnvelope(envelope(t, key, b), [][]byte{pub}),\n\t\t\t\t\t\tHash: &models.IntotoV002SchemaContentHash{\n\t\t\t\t\t\t\tAlgorithm: swag.String(models.IntotoV001SchemaContentHashAlgorithmSha256),\n\t\t\t\t\t\t\tValue:     swag.String(envelopeHash(t, envelope(t, key, b))),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tPayloadHash: &models.IntotoV002SchemaContentPayloadHash{\n\t\t\t\t\t\t\tAlgorithm: swag.String(models.IntotoV001SchemaContentHashAlgorithmSha256),\n\t\t\t\t\t\t\tValue:     swag.String(hex.EncodeToString(payloadHash[:])),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tenv: *envelope(t, key, b),\n\t\t\t}\n\t\t\twant := []string{}\n\t\t\tfor _, sig := range v.IntotoObj.Content.Envelope.Signatures {\n\t\t\t\tkeyHash := sha256.Sum256(*sig.PublicKey)\n\t\t\t\twant = append(want, \"sha256:\"+hex.EncodeToString(keyHash[:]))\n\t\t\t}\n\n\t\t\twant = append(want, \"sha256:\"+hex.EncodeToString(payloadHash[:]))\n\n\t\t\twant = append(want, tt.want...)\n\t\t\tgot, _ := v.IndexKeys()\n\t\t\tsort.Strings(got)\n\t\t\tsort.Strings(want)\n\t\t\tif !cmp.Equal(got, want) {\n\t\t\t\tt.Errorf(\"V001Entry.IndexKeys() = %v, want %v\", got, want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestInsertable(t *testing.T) {\n\ttype TestCase struct {\n\t\tcaseDesc      string\n\t\tentry         V002Entry\n\t\texpectSuccess bool\n\t}\n\n\tkey, err := ecdsa.GenerateKey(elliptic.P256(), rand.Reader)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tenv := envelope(t, key, []byte(\"payload\"))\n\tkeyBytes := strfmt.Base64([]byte(\"key\"))\n\tsigBytes := strfmt.Base64([]byte(\"sig\"))\n\n\ttestCases := []TestCase{\n\t\t{\n\t\t\tcaseDesc: \"valid entry\",\n\t\t\tentry: V002Entry{\n\t\t\t\tIntotoObj: models.IntotoV002Schema{\n\t\t\t\t\tContent: &models.IntotoV002SchemaContent{\n\t\t\t\t\t\tEnvelope: &models.IntotoV002SchemaContentEnvelope{\n\t\t\t\t\t\t\tPayload:     strfmt.Base64(\"payload\"),\n\t\t\t\t\t\t\tPayloadType: swag.String(\"payloadType\"),\n\t\t\t\t\t\t\tSignatures: []*models.IntotoV002SchemaContentEnvelopeSignaturesItems0{\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tPublicKey: &keyBytes,\n\t\t\t\t\t\t\t\t\tSig:       &sigBytes,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tenv: *env,\n\t\t\t},\n\t\t\texpectSuccess: true,\n\t\t},\n\t\t{\n\t\t\tcaseDesc: \"valid entry but hasn't been parsed\",\n\t\t\tentry: V002Entry{\n\t\t\t\tIntotoObj: models.IntotoV002Schema{\n\t\t\t\t\tContent: &models.IntotoV002SchemaContent{\n\t\t\t\t\t\tEnvelope: &models.IntotoV002SchemaContentEnvelope{\n\t\t\t\t\t\t\tPayload:     strfmt.Base64(\"payload\"),\n\t\t\t\t\t\t\tPayloadType: swag.String(\"payloadType\"),\n\t\t\t\t\t\t\tSignatures: []*models.IntotoV002SchemaContentEnvelopeSignaturesItems0{\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tPublicKey: &keyBytes,\n\t\t\t\t\t\t\t\t\tSig:       &sigBytes,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tenv: dsse.Envelope{},\n\t\t\t},\n\t\t\texpectSuccess: false,\n\t\t},\n\t\t{\n\t\t\tcaseDesc: \"missing sig\",\n\t\t\tentry: V002Entry{\n\t\t\t\tIntotoObj: models.IntotoV002Schema{\n\t\t\t\t\tContent: &models.IntotoV002SchemaContent{\n\t\t\t\t\t\tEnvelope: &models.IntotoV002SchemaContentEnvelope{\n\t\t\t\t\t\t\tPayload:     strfmt.Base64(\"payload\"),\n\t\t\t\t\t\t\tPayloadType: swag.String(\"payloadType\"),\n\t\t\t\t\t\t\tSignatures: []*models.IntotoV002SchemaContentEnvelopeSignaturesItems0{\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tPublicKey: &keyBytes,\n\t\t\t\t\t\t\t\t\t//Sig:       strfmt.Base64([]byte(\"sig\")),\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tenv: *env,\n\t\t\t},\n\t\t\texpectSuccess: false,\n\t\t},\n\t\t{\n\t\t\tcaseDesc: \"missing key\",\n\t\t\tentry: V002Entry{\n\t\t\t\tIntotoObj: models.IntotoV002Schema{\n\t\t\t\t\tContent: &models.IntotoV002SchemaContent{\n\t\t\t\t\t\tEnvelope: &models.IntotoV002SchemaContentEnvelope{\n\t\t\t\t\t\t\tPayload:     strfmt.Base64(\"payload\"),\n\t\t\t\t\t\t\tPayloadType: swag.String(\"payloadType\"),\n\t\t\t\t\t\t\tSignatures: []*models.IntotoV002SchemaContentEnvelopeSignaturesItems0{\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t//PublicKey: strfmt.Base64([]byte(\"key\")),\n\t\t\t\t\t\t\t\t\tSig: &sigBytes,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tenv: *env,\n\t\t\t},\n\t\t\texpectSuccess: false,\n\t\t},\n\t\t{\n\t\t\tcaseDesc: \"empty signatures\",\n\t\t\tentry: V002Entry{\n\t\t\t\tIntotoObj: models.IntotoV002Schema{\n\t\t\t\t\tContent: &models.IntotoV002SchemaContent{\n\t\t\t\t\t\tEnvelope: &models.IntotoV002SchemaContentEnvelope{\n\t\t\t\t\t\t\tPayload:     strfmt.Base64(\"payload\"),\n\t\t\t\t\t\t\tPayloadType: swag.String(\"payloadType\"),\n\t\t\t\t\t\t\tSignatures:  []*models.IntotoV002SchemaContentEnvelopeSignaturesItems0{},\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t\tSignatures: []*models.IntotoV002SchemaContentEnvelopeSignaturesItems0{\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tPublicKey: strfmt.Base64([]byte(\"key\")),\n\t\t\t\t\t\t\t\t\t\tSig:       strfmt.Base64([]byte(\"sig\")),\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t*/\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tenv: *env,\n\t\t\t},\n\t\t\texpectSuccess: false,\n\t\t},\n\t\t{\n\t\t\tcaseDesc: \"missing payloadType\",\n\t\t\tentry: V002Entry{\n\t\t\t\tIntotoObj: models.IntotoV002Schema{\n\t\t\t\t\tContent: &models.IntotoV002SchemaContent{\n\t\t\t\t\t\tEnvelope: &models.IntotoV002SchemaContentEnvelope{\n\t\t\t\t\t\t\tPayload: strfmt.Base64(\"payload\"),\n\t\t\t\t\t\t\t//PayloadType: swag.String(\"payloadType\"),\n\t\t\t\t\t\t\tSignatures: []*models.IntotoV002SchemaContentEnvelopeSignaturesItems0{\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tPublicKey: &keyBytes,\n\t\t\t\t\t\t\t\t\tSig:       &sigBytes,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tenv: *env,\n\t\t\t},\n\t\t\texpectSuccess: false,\n\t\t},\n\t\t{\n\t\t\tcaseDesc: \"missing payload\",\n\t\t\tentry: V002Entry{\n\t\t\t\tIntotoObj: models.IntotoV002Schema{\n\t\t\t\t\tContent: &models.IntotoV002SchemaContent{\n\t\t\t\t\t\tEnvelope: &models.IntotoV002SchemaContentEnvelope{\n\t\t\t\t\t\t\t//Payload:     strfmt.Base64(\"payload\"),\n\t\t\t\t\t\t\tPayloadType: swag.String(\"payloadType\"),\n\t\t\t\t\t\t\tSignatures: []*models.IntotoV002SchemaContentEnvelopeSignaturesItems0{\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tPublicKey: &keyBytes,\n\t\t\t\t\t\t\t\t\tSig:       &sigBytes,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tenv: *env,\n\t\t\t},\n\t\t\texpectSuccess: false,\n\t\t},\n\t\t{\n\t\t\tcaseDesc: \"missing envelope\",\n\t\t\tentry: V002Entry{\n\t\t\t\tIntotoObj: models.IntotoV002Schema{\n\t\t\t\t\tContent: &models.IntotoV002SchemaContent{\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t\tEnvelope: &models.IntotoV002SchemaContentEnvelope{\n\t\t\t\t\t\t\t\tPayload:     strfmt.Base64(\"payload\"),\n\t\t\t\t\t\t\t\tPayloadType: swag.String(\"payloadType\"),\n\t\t\t\t\t\t\t\tSignatures: []*models.IntotoV002SchemaContentEnvelopeSignaturesItems0{\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tPublicKey: strfmt.Base64([]byte(\"key\")),\n\t\t\t\t\t\t\t\t\t\tSig:       strfmt.Base64([]byte(\"sig\")),\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t*/\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tenv: *env,\n\t\t\t},\n\t\t\texpectSuccess: false,\n\t\t},\n\t\t{\n\t\t\tcaseDesc: \"missing content\",\n\t\t\tentry: V002Entry{\n\t\t\t\tIntotoObj: models.IntotoV002Schema{\n\t\t\t\t\t/*\n\t\t\t\t\t\tContent: &models.IntotoV002SchemaContent{\n\t\t\t\t\t\t\tEnvelope: &models.IntotoV002SchemaContentEnvelope{\n\t\t\t\t\t\t\t\tPayload:     strfmt.Base64(\"payload\"),\n\t\t\t\t\t\t\t\tPayloadType: swag.String(\"payloadType\"),\n\t\t\t\t\t\t\t\tSignatures: []*models.IntotoV002SchemaContentEnvelopeSignaturesItems0{\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tPublicKey: strfmt.Base64([]byte(\"key\")),\n\t\t\t\t\t\t\t\t\t\tSig:       strfmt.Base64([]byte(\"sig\")),\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t*/\n\t\t\t\t},\n\t\t\t\tenv: *env,\n\t\t\t},\n\t\t\texpectSuccess: false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.caseDesc, func(t *testing.T) {\n\t\t\tif ok, err := tc.entry.Insertable(); ok != tc.expectSuccess {\n\t\t\t\tt.Errorf(\"unexpected result calling Insertable: %v\", err)\n\t\t\t}\n\t\t})\n\t}\n}\n", "{\n    \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n    \"$id\": \"http://rekor.sigstore.dev/types/intoto/intoto_v0_0_2_schema.json\",\n    \"title\": \"intoto v0.0.2 Schema\",\n    \"description\": \"Schema for intoto object\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"content\": {\n            \"type\": \"object\",\n            \"properties\": {\n                \"envelope\": {\n                    \"description\": \"dsse envelope\",\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"payload\": {\n                            \"description\": \"payload of the envelope\",\n                            \"type\": \"string\",\n                            \"format\": \"byte\",\n                            \"writeOnly\": true\n                        },\n                        \"payloadType\": {\n                            \"description\": \"type describing the payload\",\n                            \"type\": \"string\"\n                        },\n                        \"signatures\": {\n                            \"description\": \"collection of all signatures of the envelope's payload\",\n                            \"type\": \"array\",\n                            \"minItems\": 1,\n                            \"items\": {\n                                \"description\": \"a signature of the envelope's payload along with the public key for the signature\",\n                                \"type\": \"object\",\n                                \"properties\": {\n                                    \"keyid\": {\n                                        \"description\": \"optional id of the key used to create the signature\",\n                                        \"type\": \"string\"\n                                    },\n                                    \"sig\": {\n                                        \"description\": \"signature of the payload\",\n                                        \"type\": \"string\",\n                                        \"format\": \"byte\"\n                                    },\n                                    \"publicKey\": {\n                                        \"description\": \"public key that corresponds to this signature\",\n                                        \"type\": \"string\",\n                                        \"format\": \"byte\"\n                                    }\n                                },\n                                \"required\": [\"sig\", \"publicKey\"]\n                            }\n                        }\n                    },\n                    \"required\": [\"payloadType\", \"signatures\"]\n                },\n                \"hash\": {\n                    \"description\": \"Specifies the hash algorithm and value encompassing the entire signed envelope\",\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"algorithm\": {\n                            \"description\": \"The hashing function used to compute the hash value\",\n                            \"type\": \"string\",\n                            \"enum\": [\n                                \"sha256\"\n                            ]\n                        },\n                        \"value\": {\n                            \"description\": \"The hash value for the archive\",\n                            \"type\": \"string\"\n                        }\n                    },\n                    \"required\": [\n                        \"algorithm\",\n                        \"value\"\n                    ],\n                    \"readOnly\": true\n                },\n                \"payloadHash\": {\n                    \"description\": \"Specifies the hash algorithm and value covering the payload within the DSSE envelope\",\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"algorithm\": {\n                            \"description\": \"The hashing function used to compute the hash value\",\n                            \"type\": \"string\",\n                            \"enum\": [ \"sha256\" ]\n                        },\n                        \"value\": {\n                            \"description\": \"The hash value of the payload\",\n                            \"type\": \"string\"\n                        }\n                    },\n                    \"required\": [\n                        \"algorithm\",\n                        \"value\"\n                    ],\n                    \"readOnly\": true\n                }\n            },\n            \"required\": [\n                \"envelope\"\n            ]\n        }\n    },\n    \"required\": [\n        \"content\"\n    ]\n}\n"], "filenames": ["pkg/generated/models/intoto_v002_schema.go", "pkg/generated/restapi/embedded_spec.go", "pkg/types/dsse/v0.0.1/entry.go", "pkg/types/dsse/v0.0.1/entry_test.go", "pkg/types/intoto/v0.0.2/entry.go", "pkg/types/intoto/v0.0.2/entry_test.go", "pkg/types/intoto/v0.0.2/intoto_v0_0_2_schema.json"], "buggy_code_start_loc": [452, 2169, 77, 160, 34, 113, 47], "buggy_code_end_loc": [462, 2169, 204, 219, 487, 659, 48], "fixing_code_start_loc": [453, 2170, 78, 161, 35, 114, 47], "fixing_code_end_loc": [496, 2174, 212, 234, 499, 690, 49], "type": "CWE-617", "message": "Rekor's goals are to provide an immutable tamper resistant ledger of metadata generated within a software projects supply chain. A malformed proposed entry of the `intoto/v0.0.2` type can cause a panic on a thread within the Rekor process. The thread is recovered so the client receives a 500 error message and service still continues, so the availability impact of this is minimal. This has been fixed in v1.2.0 of Rekor. Users are advised to upgrade. There are no known workarounds for this vulnerability.", "other": {"cve": {"id": "CVE-2023-33199", "sourceIdentifier": "security-advisories@github.com", "published": "2023-05-26T23:15:18.960", "lastModified": "2023-06-05T14:21:25.877", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Rekor's goals are to provide an immutable tamper resistant ledger of metadata generated within a software projects supply chain. A malformed proposed entry of the `intoto/v0.0.2` type can cause a panic on a thread within the Rekor process. The thread is recovered so the client receives a 500 error message and service still continues, so the availability impact of this is minimal. This has been fixed in v1.2.0 of Rekor. Users are advised to upgrade. There are no known workarounds for this vulnerability."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-617"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-617"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:linuxfoundation:rekor:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.2.0", "matchCriteriaId": "1C1976D1-6EB8-47F7-B8B9-DBBA7223E2C4"}]}]}], "references": [{"url": "https://github.com/sigstore/rekor/commit/140c5add105179e5ffd9e3e114fd1b6b93aebbd4", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/sigstore/rekor/security/advisories/GHSA-frqx-jfcm-6jjr", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/sigstore/rekor/commit/140c5add105179e5ffd9e3e114fd1b6b93aebbd4"}}