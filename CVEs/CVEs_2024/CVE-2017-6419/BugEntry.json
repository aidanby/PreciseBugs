{"buggy_code": ["/* This file is part of libmspack.\n * (C) 2003-2013 Stuart Caie.\n *\n * The LZX method was created by Jonathan Forbes and Tomi Poutanen, adapted\n * by Microsoft Corporation.\n *\n * libmspack is free software; you can redistribute it and/or modify it under\n * the terms of the GNU Lesser General Public License (LGPL) version 2.1\n *\n * For further details, see the file COPYING.LIB distributed with libmspack\n */\n\n/* LZX decompression implementation */\n\n#include <system.h>\n#include <lzx.h>\n\n/* Microsoft's LZX document (in cab-sdk.exe) and their implementation\n * of the com.ms.util.cab Java package do not concur.\n *\n * In the LZX document, there is a table showing the correlation between\n * window size and the number of position slots. It states that the 1MB\n * window = 40 slots and the 2MB window = 42 slots. In the implementation,\n * 1MB = 42 slots, 2MB = 50 slots. The actual calculation is 'find the\n * first slot whose position base is equal to or more than the required\n * window size'. This would explain why other tables in the document refer\n * to 50 slots rather than 42.\n *\n * The constant NUM_PRIMARY_LENGTHS used in the decompression pseudocode\n * is not defined in the specification.\n *\n * The LZX document does not state the uncompressed block has an\n * uncompressed length field. Where does this length field come from, so\n * we can know how large the block is? The implementation has it as the 24\n * bits following after the 3 blocktype bits, before the alignment\n * padding.\n *\n * The LZX document states that aligned offset blocks have their aligned\n * offset huffman tree AFTER the main and length trees. The implementation\n * suggests that the aligned offset tree is BEFORE the main and length\n * trees.\n *\n * The LZX document decoding algorithm states that, in an aligned offset\n * block, if an extra_bits value is 1, 2 or 3, then that number of bits\n * should be read and the result added to the match offset. This is\n * correct for 1 and 2, but not 3, where just a huffman symbol (using the\n * aligned tree) should be read.\n *\n * Regarding the E8 preprocessing, the LZX document states 'No translation\n * may be performed on the last 6 bytes of the input block'. This is\n * correct.  However, the pseudocode provided checks for the *E8 leader*\n * up to the last 6 bytes. If the leader appears between -10 and -7 bytes\n * from the end, this would cause the next four bytes to be modified, at\n * least one of which would be in the last 6 bytes, which is not allowed\n * according to the spec.\n *\n * The specification states that the huffman trees must always contain at\n * least one element. However, many CAB files contain blocks where the\n * length tree is completely empty (because there are no matches), and\n * this is expected to succeed.\n *\n * The errors in LZX documentation appear have been corrected in the\n * new documentation for the LZX DELTA format.\n *\n *     http://msdn.microsoft.com/en-us/library/cc483133.aspx\n *\n * However, this is a different format, an extension of regular LZX.\n * I have noticed the following differences, there may be more:\n *\n * The maximum window size has increased from 2MB to 32MB. This also\n * increases the maximum number of position slots, etc.\n *\n * If the match length is 257 (the maximum possible), this signals\n * a further length decoding step, that allows for matches up to\n * 33024 bytes long.\n *\n * The format now allows for \"reference data\", supplied by the caller.\n * If match offsets go further back than the number of bytes\n * decompressed so far, that is them accessing the reference data.\n */\n\n/* import bit-reading macros and code */\n#define BITS_TYPE struct lzxd_stream\n#define BITS_VAR lzx\n#define BITS_ORDER_MSB\n#define READ_BYTES do {\t\t\t\\\n    unsigned char b0, b1;\t\t\\\n    READ_IF_NEEDED; b0 = *i_ptr++;\t\\\n    READ_IF_NEEDED; b1 = *i_ptr++;\t\\\n    INJECT_BITS((b1 << 8) | b0, 16);\t\\\n} while (0)\n#include <readbits.h>\n\n/* import huffman-reading macros and code */\n#define TABLEBITS(tbl)      LZX_##tbl##_TABLEBITS\n#define MAXSYMBOLS(tbl)     LZX_##tbl##_MAXSYMBOLS\n#define HUFF_TABLE(tbl,idx) lzx->tbl##_table[idx]\n#define HUFF_LEN(tbl,idx)   lzx->tbl##_len[idx]\n#define HUFF_ERROR          return lzx->error = MSPACK_ERR_DECRUNCH\n#include <readhuff.h>\n\n/* BUILD_TABLE(tbl) builds a huffman lookup table from code lengths */\n#define BUILD_TABLE(tbl)\t\t\t\t\t\t\\\n    if (make_decode_table(MAXSYMBOLS(tbl), TABLEBITS(tbl),\t\t\\\n\t\t\t  &HUFF_LEN(tbl,0), &HUFF_TABLE(tbl,0)))\t\\\n    {\t\t\t\t\t\t\t\t\t\\\n        D((\"failed to build %s table\", #tbl))\t\t\t\t\\\n\treturn lzx->error = MSPACK_ERR_DECRUNCH;\t\t\t\\\n    }\n\n#define BUILD_TABLE_MAYBE_EMPTY(tbl) do {\t\t\t\t\\\n    lzx->tbl##_empty = 0;\t\t\t\t\t\t\\\n    if (make_decode_table(MAXSYMBOLS(tbl), TABLEBITS(tbl),\t\t\\\n                          &HUFF_LEN(tbl,0), &HUFF_TABLE(tbl,0)))\t\\\n    {\t\t\t\t\t\t\t\t\t\\\n\tfor (i = 0; i < MAXSYMBOLS(tbl); i++) {\t\t\t\t\\\n\t    if (HUFF_LEN(tbl, i) > 0) {\t\t\t\t\t\\\n\t\tD((\"failed to build %s table\", #tbl))\t\t\t\\\n\t\treturn lzx->error = MSPACK_ERR_DECRUNCH;\t\t\\\n\t    }\t\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\t/* empty tree - allow it, but don't decode symbols with it */\t\\\n\tlzx->tbl##_empty = 1;\t\t\t\t\t\t\\\n    }\t\t\t\t\t\t\t\t\t\\\n} while (0)\n\n/* READ_LENGTHS(tablename, first, last) reads in code lengths for symbols\n * first to last in the given table. The code lengths are stored in their\n * own special LZX way.\n */\n#define READ_LENGTHS(tbl, first, last) do {\t\t\\\n  STORE_BITS;\t\t\t\t\t\t\\\n  if (lzxd_read_lens(lzx, &HUFF_LEN(tbl, 0), (first),\t\\\n    (unsigned int)(last))) return lzx->error;\t\t\\\n  RESTORE_BITS;\t\t\t\t\t\t\\\n} while (0)\n\nstatic int lzxd_read_lens(struct lzxd_stream *lzx, unsigned char *lens,\n\t\t\t  unsigned int first, unsigned int last)\n{\n  /* bit buffer and huffman symbol decode variables */\n  register unsigned int bit_buffer;\n  register int bits_left, i;\n  register unsigned short sym;\n  unsigned char *i_ptr, *i_end;\n\n  unsigned int x, y;\n  int z;\n\n  RESTORE_BITS;\n  \n  /* read lengths for pretree (20 symbols, lengths stored in fixed 4 bits) */\n  for (x = 0; x < 20; x++) {\n    READ_BITS(y, 4);\n    lzx->PRETREE_len[x] = y;\n  }\n  BUILD_TABLE(PRETREE);\n\n  for (x = first; x < last; ) {\n    READ_HUFFSYM(PRETREE, z);\n    if (z == 17) {\n      /* code = 17, run of ([read 4 bits]+4) zeros */\n      READ_BITS(y, 4); y += 4;\n      while (y--) lens[x++] = 0;\n    }\n    else if (z == 18) {\n      /* code = 18, run of ([read 5 bits]+20) zeros */\n      READ_BITS(y, 5); y += 20;\n      while (y--) lens[x++] = 0;\n    }\n    else if (z == 19) {\n      /* code = 19, run of ([read 1 bit]+4) [read huffman symbol] */\n      READ_BITS(y, 1); y += 4;\n      READ_HUFFSYM(PRETREE, z);\n      z = lens[x] - z; if (z < 0) z += 17;\n      while (y--) lens[x++] = z;\n    }\n    else {\n      /* code = 0 to 16, delta current length entry */\n      z = lens[x] - z; if (z < 0) z += 17;\n      lens[x++] = z;\n    }\n  }\n\n  STORE_BITS;\n\n  return MSPACK_ERR_OK;\n}\n\n/* LZX static data tables:\n *\n * LZX uses 'position slots' to represent match offsets.  For every match,\n * a small 'position slot' number and a small offset from that slot are\n * encoded instead of one large offset.\n *\n * The number of slots is decided by how many are needed to encode the\n * largest offset for a given window size. This is easy when the gap between\n * slots is less than 128Kb, it's a linear relationship. But when extra_bits\n * reaches its limit of 17 (because LZX can only ensure reading 17 bits of\n * data at a time), we can only jump 128Kb at a time and have to start\n * using more and more position slots as each window size doubles.\n *\n * position_base[] is an index to the position slot bases\n *\n * extra_bits[] states how many bits of offset-from-base data is needed.\n *\n * They are calculated as follows:\n * extra_bits[i] = 0 where i < 4\n * extra_bits[i] = floor(i/2)-1 where i >= 4 && i < 36\n * extra_bits[i] = 17 where i >= 36\n * position_base[0] = 0\n * position_base[i] = position_base[i-1] + (1 << extra_bits[i-1])\n */\nstatic const unsigned int position_slots[11] = {\n    30, 32, 34, 36, 38, 42, 50, 66, 98, 162, 290\n};\nstatic const unsigned char extra_bits[36] = {\n    0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8,\n    9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15, 16, 16\n};\nstatic const unsigned int position_base[290] = {\n    0, 1, 2, 3, 4, 6, 8, 12, 16, 24, 32, 48, 64, 96, 128, 192, 256, 384, 512,\n    768, 1024, 1536, 2048, 3072, 4096, 6144, 8192, 12288, 16384, 24576, 32768,\n    49152, 65536, 98304, 131072, 196608, 262144, 393216, 524288, 655360,\n    786432, 917504, 1048576, 1179648, 1310720, 1441792, 1572864, 1703936,\n    1835008, 1966080, 2097152, 2228224, 2359296, 2490368, 2621440, 2752512,\n    2883584, 3014656, 3145728, 3276800, 3407872, 3538944, 3670016, 3801088,\n    3932160, 4063232, 4194304, 4325376, 4456448, 4587520, 4718592, 4849664,\n    4980736, 5111808, 5242880, 5373952, 5505024, 5636096, 5767168, 5898240,\n    6029312, 6160384, 6291456, 6422528, 6553600, 6684672, 6815744, 6946816,\n    7077888, 7208960, 7340032, 7471104, 7602176, 7733248, 7864320, 7995392,\n    8126464, 8257536, 8388608, 8519680, 8650752, 8781824, 8912896, 9043968,\n    9175040, 9306112, 9437184, 9568256, 9699328, 9830400, 9961472, 10092544,\n    10223616, 10354688, 10485760, 10616832, 10747904, 10878976, 11010048,\n    11141120, 11272192, 11403264, 11534336, 11665408, 11796480, 11927552,\n    12058624, 12189696, 12320768, 12451840, 12582912, 12713984, 12845056,\n    12976128, 13107200, 13238272, 13369344, 13500416, 13631488, 13762560,\n    13893632, 14024704, 14155776, 14286848, 14417920, 14548992, 14680064,\n    14811136, 14942208, 15073280, 15204352, 15335424, 15466496, 15597568,\n    15728640, 15859712, 15990784, 16121856, 16252928, 16384000, 16515072,\n    16646144, 16777216, 16908288, 17039360, 17170432, 17301504, 17432576,\n    17563648, 17694720, 17825792, 17956864, 18087936, 18219008, 18350080,\n    18481152, 18612224, 18743296, 18874368, 19005440, 19136512, 19267584,\n    19398656, 19529728, 19660800, 19791872, 19922944, 20054016, 20185088,\n    20316160, 20447232, 20578304, 20709376, 20840448, 20971520, 21102592,\n    21233664, 21364736, 21495808, 21626880, 21757952, 21889024, 22020096,\n    22151168, 22282240, 22413312, 22544384, 22675456, 22806528, 22937600,\n    23068672, 23199744, 23330816, 23461888, 23592960, 23724032, 23855104,\n    23986176, 24117248, 24248320, 24379392, 24510464, 24641536, 24772608,\n    24903680, 25034752, 25165824, 25296896, 25427968, 25559040, 25690112,\n    25821184, 25952256, 26083328, 26214400, 26345472, 26476544, 26607616,\n    26738688, 26869760, 27000832, 27131904, 27262976, 27394048, 27525120,\n    27656192, 27787264, 27918336, 28049408, 28180480, 28311552, 28442624,\n    28573696, 28704768, 28835840, 28966912, 29097984, 29229056, 29360128,\n    29491200, 29622272, 29753344, 29884416, 30015488, 30146560, 30277632,\n    30408704, 30539776, 30670848, 30801920, 30932992, 31064064, 31195136,\n    31326208, 31457280, 31588352, 31719424, 31850496, 31981568, 32112640,\n    32243712, 32374784, 32505856, 32636928, 32768000, 32899072, 33030144,\n    33161216, 33292288, 33423360\n};\n\nstatic void lzxd_reset_state(struct lzxd_stream *lzx) {\n  int i;\n\n  lzx->R0              = 1;\n  lzx->R1              = 1;\n  lzx->R2              = 1;\n  lzx->header_read     = 0;\n  lzx->block_remaining = 0;\n  lzx->block_type      = LZX_BLOCKTYPE_INVALID;\n\n  /* initialise tables to 0 (because deltas will be applied to them) */\n  for (i = 0; i < LZX_MAINTREE_MAXSYMBOLS; i++) lzx->MAINTREE_len[i] = 0;\n  for (i = 0; i < LZX_LENGTH_MAXSYMBOLS; i++)   lzx->LENGTH_len[i]   = 0;\n}\n\n/*-------- main LZX code --------*/\n\nstruct lzxd_stream *lzxd_init(struct mspack_system *system,\n\t\t\t      struct mspack_file *input,\n\t\t\t      struct mspack_file *output,\n\t\t\t      int window_bits,\n\t\t\t      int reset_interval,\n\t\t\t      int input_buffer_size,\n\t\t\t      off_t output_length,\n\t\t\t      char is_delta)\n{\n  unsigned int window_size = 1 << window_bits;\n  struct lzxd_stream *lzx;\n\n  if (!system) return NULL;\n\n  /* LZX DELTA window sizes are between 2^17 (128KiB) and 2^25 (32MiB),\n   * regular LZX windows are between 2^15 (32KiB) and 2^21 (2MiB)\n   */\n  if (is_delta) {\n      if (window_bits < 17 || window_bits > 25) return NULL;\n  }\n  else {\n      if (window_bits < 15 || window_bits > 21) return NULL;\n  }\n\n  input_buffer_size = (input_buffer_size + 1) & -2;\n  if (!input_buffer_size) return NULL;\n\n  /* allocate decompression state */\n  if (!(lzx = (struct lzxd_stream *) system->alloc(system, sizeof(struct lzxd_stream)))) {\n    return NULL;\n  }\n\n  /* allocate decompression window and input buffer */\n  lzx->window = (unsigned char *) system->alloc(system, (size_t) window_size);\n  lzx->inbuf  = (unsigned char *) system->alloc(system, (size_t) input_buffer_size);\n  if (!lzx->window || !lzx->inbuf) {\n    system->free(lzx->window);\n    system->free(lzx->inbuf);\n    system->free(lzx);\n    return NULL;\n  }\n\n  /* initialise decompression state */\n  lzx->sys             = system;\n  lzx->input           = input;\n  lzx->output          = output;\n  lzx->offset          = 0;\n  lzx->length          = output_length;\n\n  lzx->inbuf_size      = input_buffer_size;\n  lzx->window_size     = 1 << window_bits;\n  lzx->ref_data_size   = 0;\n  lzx->window_posn     = 0;\n  lzx->frame_posn      = 0;\n  lzx->frame           = 0;\n  lzx->reset_interval  = reset_interval;\n  lzx->intel_filesize  = 0;\n  lzx->intel_curpos    = 0;\n  lzx->intel_started   = 0;\n  lzx->error           = MSPACK_ERR_OK;\n  lzx->num_offsets     = position_slots[window_bits - 15] << 3;\n  lzx->is_delta        = is_delta;\n\n  lzx->o_ptr = lzx->o_end = &lzx->e8_buf[0];\n  lzxd_reset_state(lzx);\n  INIT_BITS;\n  return lzx;\n}\n\nint lzxd_set_reference_data(struct lzxd_stream *lzx,\n\t\t\t    struct mspack_system *system,\n\t\t\t    struct mspack_file *input,\n\t\t\t    unsigned int length)\n{\n    if (!lzx) return MSPACK_ERR_ARGS;\n\n    if (!lzx->is_delta) {\n        D((\"only LZX DELTA streams support reference data\"))\n        return MSPACK_ERR_ARGS;\n    }\n    if (lzx->offset) {\n\tD((\"too late to set reference data after decoding starts\"))\n\treturn MSPACK_ERR_ARGS;\n    }\n    if (length > lzx->window_size) {\n\tD((\"reference length (%u) is longer than the window\", length))\n\treturn MSPACK_ERR_ARGS;\n    }\n    if (length > 0 && (!system || !input)) {\n        D((\"length > 0 but no system or input\"))\n        return MSPACK_ERR_ARGS;\n    }\n\n    lzx->ref_data_size = length;\n    if (length > 0) {\n        /* copy reference data */\n        unsigned char *pos = &lzx->window[lzx->window_size - length];\n\tint bytes = system->read(input, pos, length);\n        /* length can't be more than 2^25, so no signedness problem */\n\tif (bytes < (int)length) return MSPACK_ERR_READ;\n    }\n    lzx->ref_data_size = length;\n    return MSPACK_ERR_OK;\n}\n\nvoid lzxd_set_output_length(struct lzxd_stream *lzx, off_t out_bytes) {\n  if (lzx) lzx->length = out_bytes;\n}\n\nint lzxd_decompress(struct lzxd_stream *lzx, off_t out_bytes) {\n  /* bitstream and huffman reading variables */\n  register unsigned int bit_buffer;\n  register int bits_left, i=0;\n  unsigned char *i_ptr, *i_end;\n  register unsigned short sym;\n\n  int match_length, length_footer, extra, verbatim_bits, bytes_todo;\n  int this_run, main_element, aligned_bits, j;\n  unsigned char *window, *runsrc, *rundest, buf[12];\n  unsigned int frame_size=0, end_frame, match_offset, window_posn;\n  unsigned int R0, R1, R2;\n\n  /* easy answers */\n  if (!lzx || (out_bytes < 0)) return MSPACK_ERR_ARGS;\n  if (lzx->error) return lzx->error;\n\n  /* flush out any stored-up bytes before we begin */\n  i = lzx->o_end - lzx->o_ptr;\n  if ((off_t) i > out_bytes) i = (int) out_bytes;\n  if (i) {\n    if (lzx->sys->write(lzx->output, lzx->o_ptr, i) != i) {\n      return lzx->error = MSPACK_ERR_WRITE;\n    }\n    lzx->o_ptr  += i;\n    lzx->offset += i;\n    out_bytes   -= i;\n  }\n  if (out_bytes == 0) return MSPACK_ERR_OK;\n\n  /* restore local state */\n  RESTORE_BITS;\n  window = lzx->window;\n  window_posn = lzx->window_posn;\n  R0 = lzx->R0;\n  R1 = lzx->R1;\n  R2 = lzx->R2;\n\n  end_frame = (unsigned int)((lzx->offset + out_bytes) / LZX_FRAME_SIZE) + 1;\n\n  while (lzx->frame < end_frame) {\n    /* have we reached the reset interval? (if there is one?) */\n    if (lzx->reset_interval && ((lzx->frame % lzx->reset_interval) == 0)) {\n      if (lzx->block_remaining) {\n\tD((\"%d bytes remaining at reset interval\", lzx->block_remaining))\n\treturn lzx->error = MSPACK_ERR_DECRUNCH;\n      }\n\n      /* re-read the intel header and reset the huffman lengths */\n      lzxd_reset_state(lzx);\n      R0 = lzx->R0;\n      R1 = lzx->R1;\n      R2 = lzx->R2;\n    }\n\n    /* LZX DELTA format has chunk_size, not present in LZX format */\n    if (lzx->is_delta) {\n      ENSURE_BITS(16);\n      REMOVE_BITS(16);\n    }\n\n    /* read header if necessary */\n    if (!lzx->header_read) {\n      /* read 1 bit. if bit=0, intel filesize = 0.\n       * if bit=1, read intel filesize (32 bits) */\n      j = 0; READ_BITS(i, 1); if (i) { READ_BITS(i, 16); READ_BITS(j, 16); }\n      lzx->intel_filesize = (i << 16) | j;\n      lzx->header_read = 1;\n    } \n\n    /* calculate size of frame: all frames are 32k except the final frame\n     * which is 32kb or less. this can only be calculated when lzx->length\n     * has been filled in. */\n    frame_size = LZX_FRAME_SIZE;\n    if (lzx->length && (lzx->length - lzx->offset) < (off_t)frame_size) {\n      frame_size = lzx->length - lzx->offset;\n    }\n\n    /* decode until one more frame is available */\n    bytes_todo = lzx->frame_posn + frame_size - window_posn;\n    while (bytes_todo > 0) {\n      /* initialise new block, if one is needed */\n      if (lzx->block_remaining == 0) {\n\t/* realign if previous block was an odd-sized UNCOMPRESSED block */\n\tif ((lzx->block_type == LZX_BLOCKTYPE_UNCOMPRESSED) &&\n\t    (lzx->block_length & 1))\n\t{\n\t  READ_IF_NEEDED;\n\t  i_ptr++;\n\t}\n\n\t/* read block type (3 bits) and block length (24 bits) */\n\tREAD_BITS(lzx->block_type, 3);\n\tREAD_BITS(i, 16); READ_BITS(j, 8);\n\tlzx->block_remaining = lzx->block_length = (i << 8) | j;\n\t/*D((\"new block t%d len %u\", lzx->block_type, lzx->block_length))*/\n\n\t/* read individual block headers */\n\tswitch (lzx->block_type) {\n\tcase LZX_BLOCKTYPE_ALIGNED:\n\t  /* read lengths of and build aligned huffman decoding tree */\n\t  for (i = 0; i < 8; i++) { READ_BITS(j, 3); lzx->ALIGNED_len[i] = j; }\n\t  BUILD_TABLE(ALIGNED);\n\t  /* no break -- rest of aligned header is same as verbatim */\n\tcase LZX_BLOCKTYPE_VERBATIM:\n\t  /* read lengths of and build main huffman decoding tree */\n\t  READ_LENGTHS(MAINTREE, 0, 256);\n\t  READ_LENGTHS(MAINTREE, 256, LZX_NUM_CHARS + lzx->num_offsets);\n\t  BUILD_TABLE(MAINTREE);\n\t  /* if the literal 0xE8 is anywhere in the block... */\n\t  if (lzx->MAINTREE_len[0xE8] != 0) lzx->intel_started = 1;\n\t  /* read lengths of and build lengths huffman decoding tree */\n\t  READ_LENGTHS(LENGTH, 0, LZX_NUM_SECONDARY_LENGTHS);\n\t  BUILD_TABLE_MAYBE_EMPTY(LENGTH);\n\t  break;\n\n\tcase LZX_BLOCKTYPE_UNCOMPRESSED:\n\t  /* because we can't assume otherwise */\n\t  lzx->intel_started = 1;\n\n\t  /* read 1-16 (not 0-15) bits to align to bytes */\n\t  if (bits_left == 0) ENSURE_BITS(16);\n\t  bits_left = 0; bit_buffer = 0;\n\n\t  /* read 12 bytes of stored R0 / R1 / R2 values */\n\t  for (rundest = &buf[0], i = 0; i < 12; i++) {\n\t    READ_IF_NEEDED;\n\t    *rundest++ = *i_ptr++;\n\t  }\n\t  R0 = buf[0] | (buf[1] << 8) | (buf[2]  << 16) | (buf[3]  << 24);\n\t  R1 = buf[4] | (buf[5] << 8) | (buf[6]  << 16) | (buf[7]  << 24);\n\t  R2 = buf[8] | (buf[9] << 8) | (buf[10] << 16) | (buf[11] << 24);\n\t  break;\n\n\tdefault:\n\t  D((\"bad block type\"))\n\t  return lzx->error = MSPACK_ERR_DECRUNCH;\n\t}\n      }\n\n      /* decode more of the block:\n       * run = min(what's available, what's needed) */\n      this_run = lzx->block_remaining;\n      if (this_run > bytes_todo) this_run = bytes_todo;\n\n      /* assume we decode exactly this_run bytes, for now */\n      bytes_todo           -= this_run;\n      lzx->block_remaining -= this_run;\n\n      /* decode at least this_run bytes */\n      switch (lzx->block_type) {\n      case LZX_BLOCKTYPE_VERBATIM:\n\twhile (this_run > 0) {\n\t  READ_HUFFSYM(MAINTREE, main_element);\n\t  if (main_element < LZX_NUM_CHARS) {\n\t    /* literal: 0 to LZX_NUM_CHARS-1 */\n\t    window[window_posn++] = main_element;\n\t    this_run--;\n\t  }\n\t  else {\n\t    /* match: LZX_NUM_CHARS + ((slot<<3) | length_header (3 bits)) */\n\t    main_element -= LZX_NUM_CHARS;\n\n\t    /* get match length */\n\t    match_length = main_element & LZX_NUM_PRIMARY_LENGTHS;\n\t    if (match_length == LZX_NUM_PRIMARY_LENGTHS) {\n\t      if (lzx->LENGTH_empty) {\n                D((\"LENGTH symbol needed but tree is empty\"))\n                return lzx->error = MSPACK_ERR_DECRUNCH;\n              }\n\t      READ_HUFFSYM(LENGTH, length_footer);\n\t      match_length += length_footer;\n\t    }\n\t    match_length += LZX_MIN_MATCH;\n\n\t    /* get match offset */\n\t    switch ((match_offset = (main_element >> 3))) {\n\t    case 0: match_offset = R0;                                  break;\n\t    case 1: match_offset = R1; R1=R0;        R0 = match_offset; break;\n\t    case 2: match_offset = R2; R2=R0;        R0 = match_offset; break;\n\t    case 3: match_offset = 1;  R2=R1; R1=R0; R0 = match_offset; break;\n\t    default:\n\t      extra = (match_offset >= 36) ? 17 : extra_bits[match_offset];\n\t      READ_BITS(verbatim_bits, extra);\n\t      match_offset = position_base[match_offset] - 2 + verbatim_bits;\n\t      R2 = R1; R1 = R0; R0 = match_offset;\n\t    }\n\n\t    /* LZX DELTA uses max match length to signal even longer match */\n\t    if (match_length == LZX_MAX_MATCH && lzx->is_delta) {\n\t\tint extra_len = 0;\n\t\tENSURE_BITS(3); /* 4 entry huffman tree */\n\t\tif (PEEK_BITS(1) == 0) {\n\t\t    REMOVE_BITS(1); /* '0' -> 8 extra length bits */\n\t\t    READ_BITS(extra_len, 8);\n\t\t}\n\t\telse if (PEEK_BITS(2) == 2) {\n\t\t    REMOVE_BITS(2); /* '10' -> 10 extra length bits + 0x100 */\n\t\t    READ_BITS(extra_len, 10);\n\t\t    extra_len += 0x100;\n\t\t}\n\t\telse if (PEEK_BITS(3) == 6) {\n\t\t    REMOVE_BITS(3); /* '110' -> 12 extra length bits + 0x500 */\n\t\t    READ_BITS(extra_len, 12);\n\t\t    extra_len += 0x500;\n\t\t}\n\t\telse {\n\t\t    REMOVE_BITS(3); /* '111' -> 15 extra length bits */\n\t\t    READ_BITS(extra_len, 15);\n\t\t}\n\t\tmatch_length += extra_len;\n\t    }\n\n\t    if ((window_posn + match_length) > lzx->window_size) {\n\t      D((\"match ran over window wrap\"))\n\t      return lzx->error = MSPACK_ERR_DECRUNCH;\n\t    }\n\t    \n\t    /* copy match */\n\t    rundest = &window[window_posn];\n\t    i = match_length;\n\t    /* does match offset wrap the window? */\n\t    if (match_offset > window_posn) {\n\t      if (match_offset > lzx->offset &&\n\t\t  (match_offset - window_posn) > lzx->ref_data_size)\n\t      {\n\t\tD((\"match offset beyond LZX stream\"))\n\t\treturn lzx->error = MSPACK_ERR_DECRUNCH;\n\t      }\n\t      /* j = length from match offset to end of window */\n\t      j = match_offset - window_posn;\n\t      if (j > (int) lzx->window_size) {\n\t\tD((\"match offset beyond window boundaries\"))\n\t\treturn lzx->error = MSPACK_ERR_DECRUNCH;\n\t      }\n\t      runsrc = &window[lzx->window_size - j];\n\t      if (j < i) {\n\t\t/* if match goes over the window edge, do two copy runs */\n\t\ti -= j; while (j-- > 0) *rundest++ = *runsrc++;\n\t\trunsrc = window;\n\t      }\n\t      while (i-- > 0) *rundest++ = *runsrc++;\n\t    }\n\t    else {\n\t      runsrc = rundest - match_offset;\n\t      while (i-- > 0) *rundest++ = *runsrc++;\n\t    }\n\n\t    this_run    -= match_length;\n\t    window_posn += match_length;\n\t  }\n\t} /* while (this_run > 0) */\n\tbreak;\n\n      case LZX_BLOCKTYPE_ALIGNED:\n\twhile (this_run > 0) {\n\t  READ_HUFFSYM(MAINTREE, main_element);\n\t  if (main_element < LZX_NUM_CHARS) {\n\t    /* literal: 0 to LZX_NUM_CHARS-1 */\n\t    window[window_posn++] = main_element;\n\t    this_run--;\n\t  }\n\t  else {\n\t    /* match: LZX_NUM_CHARS + ((slot<<3) | length_header (3 bits)) */\n\t    main_element -= LZX_NUM_CHARS;\n\n\t    /* get match length */\n\t    match_length = main_element & LZX_NUM_PRIMARY_LENGTHS;\n\t    if (match_length == LZX_NUM_PRIMARY_LENGTHS) {\n              if (lzx->LENGTH_empty) {\n                D((\"LENGTH symbol needed but tree is empty\"))\n                return lzx->error = MSPACK_ERR_DECRUNCH;\n              } \n\t      READ_HUFFSYM(LENGTH, length_footer);\n\t      match_length += length_footer;\n\t    }\n\t    match_length += LZX_MIN_MATCH;\n\n\t    /* get match offset */\n\t    switch ((match_offset = (main_element >> 3))) {\n\t    case 0: match_offset = R0;                             break;\n\t    case 1: match_offset = R1; R1 = R0; R0 = match_offset; break;\n\t    case 2: match_offset = R2; R2 = R0; R0 = match_offset; break;\n\t    default:\n\t      extra = (match_offset >= 36) ? 17 : extra_bits[match_offset];\n\t      match_offset = position_base[match_offset] - 2;\n\t      if (extra > 3) {\n\t\t/* verbatim and aligned bits */\n\t\textra -= 3;\n\t\tREAD_BITS(verbatim_bits, extra);\n\t\tmatch_offset += (verbatim_bits << 3);\n\t\tREAD_HUFFSYM(ALIGNED, aligned_bits);\n\t\tmatch_offset += aligned_bits;\n\t      }\n\t      else if (extra == 3) {\n\t\t/* aligned bits only */\n\t\tREAD_HUFFSYM(ALIGNED, aligned_bits);\n\t\tmatch_offset += aligned_bits;\n\t      }\n\t      else if (extra > 0) { /* extra==1, extra==2 */\n\t\t/* verbatim bits only */\n\t\tREAD_BITS(verbatim_bits, extra);\n\t\tmatch_offset += verbatim_bits;\n\t      }\n\t      else /* extra == 0 */ {\n\t\t/* ??? not defined in LZX specification! */\n\t\tmatch_offset = 1;\n\t      }\n\t      /* update repeated offset LRU queue */\n\t      R2 = R1; R1 = R0; R0 = match_offset;\n\t    }\n\n\t    /* LZX DELTA uses max match length to signal even longer match */\n\t    if (match_length == LZX_MAX_MATCH && lzx->is_delta) {\n\t\tint extra_len = 0;\n\t\tENSURE_BITS(3); /* 4 entry huffman tree */\n\t\tif (PEEK_BITS(1) == 0) {\n\t\t    REMOVE_BITS(1); /* '0' -> 8 extra length bits */\n\t\t    READ_BITS(extra_len, 8);\n\t\t}\n\t\telse if (PEEK_BITS(2) == 2) {\n\t\t    REMOVE_BITS(2); /* '10' -> 10 extra length bits + 0x100 */\n\t\t    READ_BITS(extra_len, 10);\n\t\t    extra_len += 0x100;\n\t\t}\n\t\telse if (PEEK_BITS(3) == 6) {\n\t\t    REMOVE_BITS(3); /* '110' -> 12 extra length bits + 0x500 */\n\t\t    READ_BITS(extra_len, 12);\n\t\t    extra_len += 0x500;\n\t\t}\n\t\telse {\n\t\t    REMOVE_BITS(3); /* '111' -> 15 extra length bits */\n\t\t    READ_BITS(extra_len, 15);\n\t\t}\n\t\tmatch_length += extra_len;\n\t    }\n\n\t    if ((window_posn + match_length) > lzx->window_size) {\n\t      D((\"match ran over window wrap\"))\n\t      return lzx->error = MSPACK_ERR_DECRUNCH;\n\t    }\n\n\t    /* copy match */\n\t    rundest = &window[window_posn];\n\t    i = match_length;\n\t    /* does match offset wrap the window? */\n\t    if (match_offset > window_posn) {\n\t      if (match_offset > lzx->offset &&\n\t\t  (match_offset - window_posn) > lzx->ref_data_size)\n\t      {\n\t\tD((\"match offset beyond LZX stream\"))\n\t\treturn lzx->error = MSPACK_ERR_DECRUNCH;\n\t      }\n\t      /* j = length from match offset to end of window */\n\t      j = match_offset - window_posn;\n\t      if (j > (int) lzx->window_size) {\n\t\tD((\"match offset beyond window boundaries\"))\n\t\treturn lzx->error = MSPACK_ERR_DECRUNCH;\n\t      }\n\t      runsrc = &window[lzx->window_size - j];\n\t      if (j < i) {\n\t\t/* if match goes over the window edge, do two copy runs */\n\t\ti -= j; while (j-- > 0) *rundest++ = *runsrc++;\n\t\trunsrc = window;\n\t      }\n\t      while (i-- > 0) *rundest++ = *runsrc++;\n\t    }\n\t    else {\n\t      runsrc = rundest - match_offset;\n\t      while (i-- > 0) *rundest++ = *runsrc++;\n\t    }\n\n\t    this_run    -= match_length;\n\t    window_posn += match_length;\n\t  }\n\t} /* while (this_run > 0) */\n\tbreak;\n\n      case LZX_BLOCKTYPE_UNCOMPRESSED:\n\t/* as this_run is limited not to wrap a frame, this also means it\n\t * won't wrap the window (as the window is a multiple of 32k) */\n\trundest = &window[window_posn];\n\twindow_posn += this_run;\n\twhile (this_run > 0) {\n\t  if ((i = i_end - i_ptr) == 0) {\n\t    READ_IF_NEEDED;\n\t  }\n\t  else {\n\t    if (i > this_run) i = this_run;\n\t    lzx->sys->copy(i_ptr, rundest, (size_t) i);\n\t    rundest  += i;\n\t    i_ptr    += i;\n\t    this_run -= i;\n\t  }\n\t}\n\tbreak;\n\n      default:\n\treturn lzx->error = MSPACK_ERR_DECRUNCH; /* might as well */\n      }\n\n      /* did the final match overrun our desired this_run length? */\n      if (this_run < 0) {\n\tif ((unsigned int)(-this_run) > lzx->block_remaining) {\n\t  D((\"overrun went past end of block by %d (%d remaining)\",\n\t     -this_run, lzx->block_remaining ))\n\t  return lzx->error = MSPACK_ERR_DECRUNCH;\n\t}\n\tlzx->block_remaining -= -this_run;\n      }\n    } /* while (bytes_todo > 0) */\n\n    /* streams don't extend over frame boundaries */\n    if ((window_posn - lzx->frame_posn) != frame_size) {\n      D((\"decode beyond output frame limits! %d != %d\",\n\t window_posn - lzx->frame_posn, frame_size))\n      return lzx->error = MSPACK_ERR_DECRUNCH;\n    }\n\n    /* re-align input bitstream */\n    if (bits_left > 0) ENSURE_BITS(16);\n    if (bits_left & 15) REMOVE_BITS(bits_left & 15);\n\n    /* check that we've used all of the previous frame first */\n    if (lzx->o_ptr != lzx->o_end) {\n      D((\"%ld avail bytes, new %d frame\",\n          (long)(lzx->o_end - lzx->o_ptr), frame_size))\n      return lzx->error = MSPACK_ERR_DECRUNCH;\n    }\n\n    /* does this intel block _really_ need decoding? */\n    if (lzx->intel_started && lzx->intel_filesize &&\n\t(lzx->frame <= 32768) && (frame_size > 10))\n    {\n      unsigned char *data    = &lzx->e8_buf[0];\n      unsigned char *dataend = &lzx->e8_buf[frame_size - 10];\n      signed int curpos      = lzx->intel_curpos;\n      signed int filesize    = lzx->intel_filesize;\n      signed int abs_off, rel_off;\n\n      /* copy e8 block to the e8 buffer and tweak if needed */\n      lzx->o_ptr = data;\n      lzx->sys->copy(&lzx->window[lzx->frame_posn], data, frame_size);\n\n      while (data < dataend) {\n\tif (*data++ != 0xE8) { curpos++; continue; }\n\tabs_off = data[0] | (data[1]<<8) | (data[2]<<16) | (data[3]<<24);\n\tif ((abs_off >= -curpos) && (abs_off < filesize)) {\n\t  rel_off = (abs_off >= 0) ? abs_off - curpos : abs_off + filesize;\n\t  data[0] = (unsigned char) rel_off;\n\t  data[1] = (unsigned char) (rel_off >> 8);\n\t  data[2] = (unsigned char) (rel_off >> 16);\n\t  data[3] = (unsigned char) (rel_off >> 24);\n\t}\n\tdata += 4;\n\tcurpos += 5;\n      }\n      lzx->intel_curpos += frame_size;\n    }\n    else {\n      lzx->o_ptr = &lzx->window[lzx->frame_posn];\n      if (lzx->intel_filesize) lzx->intel_curpos += frame_size;\n    }\n    lzx->o_end = &lzx->o_ptr[frame_size];\n\n    /* write a frame */\n    i = (out_bytes < (off_t)frame_size) ? (unsigned int)out_bytes : frame_size;\n    if (lzx->sys->write(lzx->output, lzx->o_ptr, i) != i) {\n      return lzx->error = MSPACK_ERR_WRITE;\n    }\n    lzx->o_ptr  += i;\n    lzx->offset += i;\n    out_bytes   -= i;\n\n    /* advance frame start position */\n    lzx->frame_posn += frame_size;\n    lzx->frame++;\n\n    /* wrap window / frame position pointers */\n    if (window_posn == lzx->window_size)     window_posn = 0;\n    if (lzx->frame_posn == lzx->window_size) lzx->frame_posn = 0;\n\n  } /* while (lzx->frame < end_frame) */\n\n  if (out_bytes) {\n    D((\"bytes left to output\"))\n    return lzx->error = MSPACK_ERR_DECRUNCH;\n  }\n\n  /* store local state */\n  STORE_BITS;\n  lzx->window_posn = window_posn;\n  lzx->R0 = R0;\n  lzx->R1 = R1;\n  lzx->R2 = R2;\n\n  return MSPACK_ERR_OK;\n}\n\nvoid lzxd_free(struct lzxd_stream *lzx) {\n  struct mspack_system *sys;\n  if (lzx) {\n    sys = lzx->sys;\n    sys->free(lzx->inbuf);\n    sys->free(lzx->window);\n    sys->free(lzx);\n  }\n}\n", "/*\n * Glue code for libmspack handling.\n * Author: \uc6c3 Sebastian Andrzej Siewior\n * \u2709 sebastian @ breakpoint \u0323cc\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n\n#include <mspack.h>\n\n#include \"clamav.h\"\n#include \"fmap.h\"\n#include \"scanners.h\"\n#include \"others.h\"\n\nenum mspack_type {\n\tFILETYPE_DUNNO,\n\tFILETYPE_FMAP,\n\tFILETYPE_FILENAME,\n};\n\nstruct mspack_name {\n\tfmap_t *fmap;\n\toff_t org;\n};\n\nstruct mspack_system_ex {\n\tstruct mspack_system ops;\n\toff_t max_size;\n};\n\nstruct mspack_handle {\n\tenum mspack_type type;\n\n\tfmap_t *fmap;\n\toff_t org;\n\toff_t offset;\n\n\tFILE *f;\n\toff_t max_size;\n};\n\nstatic struct mspack_file *mspack_fmap_open(struct mspack_system *self,\n\t\tconst char *filename, int mode)\n{\n\tstruct mspack_name *mspack_name;\n\tstruct mspack_handle *mspack_handle;\n\tstruct mspack_system_ex *self_ex;\n\tconst char *fmode;\n        const struct mspack_system *mptr = self;\n\n\tif (!filename) {\n\t\tcli_dbgmsg(\"%s() failed at %d\\n\", __func__, __LINE__);\n\t\treturn NULL;\n\t}\n\tmspack_handle = malloc(sizeof(*mspack_handle));\n\tif (!mspack_handle) {\n\t\tcli_dbgmsg(\"%s() failed at %d\\n\", __func__, __LINE__);\n\t\treturn NULL;\n\t}\n\tswitch (mode) {\n\tcase MSPACK_SYS_OPEN_READ:\n\t\tmspack_handle->type = FILETYPE_FMAP;\n\n\t\tmspack_name = (struct mspack_name *)filename;\n\t\tmspack_handle->fmap = mspack_name->fmap;\n\t\tmspack_handle->org = mspack_name->org;\n\t\tmspack_handle->offset = 0;\n\n\t\treturn (struct mspack_file *)mspack_handle;\n\n\tcase MSPACK_SYS_OPEN_WRITE:\n\t\tfmode = \"wb\";\n\t\tbreak;\n\tcase MSPACK_SYS_OPEN_UPDATE:\n\t\tfmode = \"r+b\";\n\t\tbreak;\n\tcase MSPACK_SYS_OPEN_APPEND:\n\t\tfmode = \"ab\";\n\t\tbreak;\n\tdefault:\n\t\tcli_dbgmsg(\"%s() wrong mode\\n\", __func__);\n\t\tgoto out_err;\n\t}\n\n\tmspack_handle->type = FILETYPE_FILENAME;\n\n\tmspack_handle->f = fopen(filename, fmode);\n\tif (!mspack_handle->f) {\n\t\tcli_dbgmsg(\"%s() failed %d\\n\", __func__, __LINE__);\n\t\tgoto out_err;\n\t}\n\n\tself_ex = (struct mspack_system_ex *)((char *)mptr - offsetof(struct mspack_system_ex,ops));\n\tmspack_handle->max_size = self_ex->max_size;\n\treturn (struct mspack_file *)mspack_handle;\n\nout_err:\n\tfree(mspack_handle);\n\treturn NULL;\n}\n\nstatic void mspack_fmap_close(struct mspack_file *file)\n{\n\tstruct mspack_handle *mspack_handle = (struct mspack_handle *)file;\n\n\tif (!mspack_handle)\n\t\treturn;\n\n\tif (mspack_handle->type == FILETYPE_FILENAME)\n\t\tfclose(mspack_handle->f);\n\tfree(mspack_handle);\n}\n\nstatic int mspack_fmap_read(struct mspack_file *file, void *buffer, int bytes)\n{\n\tstruct mspack_handle *mspack_handle = (struct mspack_handle *)file;\n\toff_t offset;\n\tsize_t count;\n\tint ret;\n\n\tif (bytes < 0) {\n\t\tcli_dbgmsg(\"%s() %d\\n\", __func__, __LINE__);\n\t\treturn -1;\n\t}\n\tif (!mspack_handle) {\n\t\tcli_dbgmsg(\"%s() %d\\n\", __func__, __LINE__);\n\t\treturn -1;\n\t}\n\n\tif (mspack_handle->type == FILETYPE_FMAP) {\n\t\toffset = mspack_handle->offset + mspack_handle->org;\n\n\t\tret = fmap_readn(mspack_handle->fmap, buffer, offset, bytes);\n\t\tif (ret != bytes) {\n\t\t\tcli_dbgmsg(\"%s() %d %d, %d\\n\", __func__, __LINE__, bytes, ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tmspack_handle->offset += bytes;\n\t\treturn bytes;\n\t}\n\tcount = fread(buffer, bytes, 1, mspack_handle->f);\n\tif (count < 1) {\n\t\tcli_dbgmsg(\"%s() %d %d, %zd\\n\", __func__, __LINE__, bytes, count);\n\t\treturn -1;\n\t}\n\treturn bytes;\n}\n\nstatic int mspack_fmap_write(struct mspack_file *file, void *buffer, int bytes)\n{\n\tstruct mspack_handle *mspack_handle = (struct mspack_handle *)file;\n\tsize_t count;\n\toff_t max_size;\n\n\tif (bytes < 0 || !mspack_handle) {\n\t\tcli_dbgmsg(\"%s() err %d\\n\", __func__, __LINE__);\n\t\treturn -1;\n\t}\n\n\tif (mspack_handle->type == FILETYPE_FMAP) {\n\t\tcli_dbgmsg(\"%s() err %d\\n\", __func__, __LINE__);\n\t\treturn -1;\n\t}\n\n\tif (!bytes)\n\t\treturn 0;\n\n\tmax_size = mspack_handle->max_size;\n\tif (!max_size)\n\t\treturn bytes;\n\n\tmax_size = max_size < (off_t) bytes ? max_size : (off_t) bytes;\n \n\tmspack_handle->max_size -= max_size;\n\n\tcount = fwrite(buffer, max_size, 1, mspack_handle->f);\n\tif (count < 1) {\n\t\tcli_dbgmsg(\"%s() err %m <%zd %d>\\n\", __func__, count, bytes);\n\t\treturn -1;\n\t}\n\n\treturn bytes;\n}\n\nstatic int mspack_fmap_seek(struct mspack_file *file, off_t offset, int mode)\n{\n\tstruct mspack_handle *mspack_handle = (struct mspack_handle *)file;\n\n\tif (!mspack_handle) {\n\t\tcli_dbgmsg(\"%s() err %d\\n\", __func__, __LINE__);\n\t\treturn -1;\n\t}\n\n\tif (mspack_handle->type == FILETYPE_FMAP) {\n\t\toff_t new_pos;\n\n\t\tswitch (mode) {\n\t\tcase MSPACK_SYS_SEEK_START:\n\t\t\tnew_pos = offset;\n\t\t\tbreak;\n\t\tcase MSPACK_SYS_SEEK_CUR:\n\t\t\tnew_pos = mspack_handle->offset + offset;\n\t\t\tbreak;\n\t\tcase MSPACK_SYS_SEEK_END:\n\t\t\tnew_pos = mspack_handle->fmap->len + offset;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcli_dbgmsg(\"%s() err %d\\n\", __func__, __LINE__);\n\t\t\treturn -1;\n\t\t}\n\t\tif (new_pos < 0 || new_pos > mspack_handle->fmap->len) {\n\t\t\tcli_dbgmsg(\"%s() err %d\\n\", __func__, __LINE__);\n\t\t\treturn -1;\n\t\t}\n\n\t\tmspack_handle->offset = new_pos;\n\t\treturn 0;\n\t}\n\n\tswitch (mode) {\n\tcase MSPACK_SYS_SEEK_START:\n\t\tmode = SEEK_SET;\n\t\tbreak;\n\tcase MSPACK_SYS_SEEK_CUR:\n\t\tmode = SEEK_CUR;\n\t\tbreak;\n\tcase MSPACK_SYS_SEEK_END:\n\t\tmode = SEEK_END;\n\t\tbreak;\n\tdefault:\n\t\tcli_dbgmsg(\"%s() err %d\\n\", __func__, __LINE__);\n\t\treturn -1;\n\t}\n\n\treturn fseek(mspack_handle->f, offset, mode);\n}\n\nstatic off_t mspack_fmap_tell(struct mspack_file *file)\n{\n\tstruct mspack_handle *mspack_handle = (struct mspack_handle *)file;\n\n\tif (!mspack_handle)\n\t\treturn -1;\n\n\tif (mspack_handle->type == FILETYPE_FMAP)\n\t\treturn mspack_handle->offset;\n\n\treturn (off_t) ftell(mspack_handle->f);\n}\n\nstatic void mspack_fmap_message(struct mspack_file *file, const char *fmt, ...)\n{\n\tcli_dbgmsg(\"%s() %s\\n\", __func__, fmt);\n}\nstatic void *mspack_fmap_alloc(struct mspack_system *self, size_t num)\n{\n\treturn malloc(num);\n}\n\nstatic void mspack_fmap_free(void *mem)\n{\n\tfree(mem);\n}\n\nstatic void mspack_fmap_copy(void *src, void *dst, size_t num)\n{\n\tmemcpy(dst, src, num);\n}\n\nstatic struct mspack_system mspack_sys_fmap_ops = {\n\t.open = mspack_fmap_open,\n\t.close = mspack_fmap_close,\n\t.read = mspack_fmap_read,\n\t.write = mspack_fmap_write,\n\t.seek = mspack_fmap_seek,\n\t.tell = mspack_fmap_tell,\n\t.message = mspack_fmap_message,\n\t.alloc = mspack_fmap_alloc,\n\t.free = mspack_fmap_free,\n\t.copy = mspack_fmap_copy,\n};\n\nstatic int cli_scanfile(const char *filename, cli_ctx *ctx)\n{\n\tint fd, ret;\n\n\t/* internal version of cl_scanfile with arec/mrec preserved */\n\tfd = safe_open(filename, O_RDONLY|O_BINARY);\n\tif (fd < 0)\n\t\treturn CL_EOPEN;\n\n\tret = cli_magic_scandesc(fd, ctx);\n\n\tclose(fd);\n\treturn ret;\n}\n\nint cli_scanmscab(cli_ctx *ctx, off_t sfx_offset)\n{\n\tstruct mscab_decompressor *cab_d;\n\tstruct mscabd_cabinet *cab_h;\n\tstruct mscabd_file *cab_f;\n\tint ret;\n\tint files;\n\tint virus_num = 0;\n\tstruct mspack_name mspack_fmap = {\n\t\t.fmap\t= *ctx->fmap,\n\t\t.org\t= sfx_offset,\n\t};\n\tstruct mspack_system_ex ops_ex;\n\tmemset(&ops_ex, 0, sizeof(struct mspack_system_ex));\n \tops_ex.ops = mspack_sys_fmap_ops;\n\n\tMSPACK_SYS_SELFTEST(ret);\n\tif (ret) {\n\t\tcli_dbgmsg(\"%s() failed at %d\\n\", __func__, __LINE__);\n\t\treturn CL_EUNPACK;\n\t}\n\n\tcab_d = mspack_create_cab_decompressor(&ops_ex.ops);\n\tif (!cab_d) {\n\t\tcli_dbgmsg(\"%s() failed at %d\\n\", __func__, __LINE__);\n\t\treturn CL_EUNPACK;\n\t}\n\n\tcab_h = cab_d->open(cab_d, (char *)&mspack_fmap);\n\tif (!cab_h) {\n\t\tret = CL_EFORMAT;\n\t\tcli_dbgmsg(\"%s() failed at %d\\n\", __func__, __LINE__);\n\t\tgoto out_dest;\n\t}\n\tfiles = 0;\n\tfor (cab_f = cab_h->files; cab_f; cab_f = cab_f->next) {\n\t\toff_t max_size;\n\t\tchar *tmp_fname;\n\n\t\tret = cli_matchmeta(ctx, cab_f->filename, 0, cab_f->length, 0,\n\t\t\t\tfiles, 0, NULL);\n\t\tif (ret) {\n\t\t\tif (ret == CL_VIRUS) {\n\t\t\t\tvirus_num++;\n\t\t\t\tif (!SCAN_ALL)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tgoto out_close;\n\t\t}\n\n\t\tif (ctx->engine->maxscansize) {\n\t\t\tif (ctx->scansize >= ctx->engine->maxscansize) {\n\t\t\t\tret = CL_CLEAN;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (ctx->engine->maxscansize &&\n\t\t\t\tctx->scansize + ctx->engine->maxfilesize >=\n\t\t\t\tctx->engine->maxscansize)\n\t\t\tmax_size = ctx->engine->maxscansize -\n\t\t\t\tctx->scansize;\n\t\telse\n\t\t\tmax_size = ctx->engine->maxfilesize ?\n\t\t\t\tctx->engine->maxfilesize :\n\t\t\t\t0xffffffff;\n\n\t\ttmp_fname = cli_gentemp(ctx->engine->tmpdir);\n\t\tif (!tmp_fname) {\n\t\t\tret = CL_EMEM;\n\t\t\tbreak;\n\t\t}\n\n\t\tops_ex.max_size = max_size;\n\t\t/* scan */\n\t\tret = cab_d->extract(cab_d, cab_f, tmp_fname);\n\t\tif (ret)\n\t\t\t/* Failed to extract. Try to scan what is there */\n\t\t\tcli_dbgmsg(\"%s() failed to extract %d\\n\", __func__, ret);\n\n\t\tret = cli_scanfile(tmp_fname, ctx);\n\t\tif (ret == CL_VIRUS)\n\t\t\tvirus_num++;\n\n\t\tif (!ctx->engine->keeptmp) {\n\t\t\tif (!access(tmp_fname, R_OK) && cli_unlink(tmp_fname)) {\n\t\t\t\tfree(tmp_fname);\n\t\t\t\tret = CL_EUNLINK;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfree(tmp_fname);\n\t\tfiles++;\n\t\tif (ret == CL_VIRUS && SCAN_ALL)\n\t\t\tcontinue;\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\nout_close:\n\tcab_d->close(cab_d, cab_h);\nout_dest:\n\tmspack_destroy_cab_decompressor(cab_d);\n\tif (virus_num)\n\t\treturn CL_VIRUS;\n\treturn ret;\n}\n\nint cli_scanmschm(cli_ctx *ctx)\n{\n\tstruct mschm_decompressor *mschm_d;\n\tstruct mschmd_header *mschm_h;\n\tstruct mschmd_file *mschm_f;\n\tint ret;\n\tint files;\n\tint virus_num = 0;\n\tstruct mspack_name mspack_fmap = {\n\t\t.fmap = *ctx->fmap,\n\t};\n\tstruct mspack_system_ex ops_ex;\n\tmemset(&ops_ex, 0, sizeof(struct mspack_system_ex));\n \tops_ex.ops = mspack_sys_fmap_ops;\n\n\tMSPACK_SYS_SELFTEST(ret);\n\tif (ret) {\n\t\tcli_dbgmsg(\"%s() failed at %d\\n\", __func__, __LINE__);\n\t\treturn CL_EUNPACK;\n\t}\n\n\tmschm_d = mspack_create_chm_decompressor(&ops_ex.ops);\n\tif (!mschm_d) {\n\t\tcli_dbgmsg(\"%s() failed at %d\\n\", __func__, __LINE__);\n\t\treturn CL_EUNPACK;\n\t}\n\n\tmschm_h = mschm_d->open(mschm_d, (char *)&mspack_fmap);\n\tif (!mschm_h) {\n\t\tret = CL_EFORMAT;\n\t\tcli_dbgmsg(\"%s() failed at %d\\n\", __func__, __LINE__);\n\t\tgoto out_dest;\n\t}\n\tfiles = 0;\n\tfor (mschm_f = mschm_h->files; mschm_f;\tmschm_f = mschm_f->next) {\n\t\toff_t max_size;\n\t\tchar *tmp_fname;\n\n\t\tret = cli_matchmeta(ctx, mschm_f->filename, 0, mschm_f->length,\n\t\t\t\t0, files, 0, NULL);\n\t\tif (ret) {\n\t\t\tif (ret == CL_VIRUS) {\n\t\t\t\tvirus_num++;\n\t\t\t\tif (!SCAN_ALL)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tgoto out_close;\n\t\t}\n\n\t\tif (ctx->engine->maxscansize) {\n\t\t\tif (ctx->scansize >= ctx->engine->maxscansize) {\n\t\t\t\tret = CL_CLEAN;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (ctx->engine->maxscansize &&\n\t\t\t\tctx->scansize + ctx->engine->maxfilesize >=\n\t\t\t\tctx->engine->maxscansize)\n\t\t\tmax_size = ctx->engine->maxscansize -\n\t\t\t\tctx->scansize;\n\t\telse\n\t\t\tmax_size = ctx->engine->maxfilesize ?\n\t\t\t\tctx->engine->maxfilesize :\n\t\t\t\t0xffffffff;\n\n\t\tops_ex.max_size = max_size;\n\n\t\ttmp_fname = cli_gentemp(ctx->engine->tmpdir);\n\t\tif (!tmp_fname) {\n\t\t\tret = CL_EMEM;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* scan */\n\t\tret = mschm_d->extract(mschm_d, mschm_f, tmp_fname);\n\t\tif (ret)\n\t\t\t/* Failed to extract. Try to scan what is there */\n\t\t\tcli_dbgmsg(\"%s() failed to extract %d\\n\", __func__, ret);\n\n\t\tret = cli_scanfile(tmp_fname, ctx);\n\t\tif (ret == CL_VIRUS)\n\t\t\tvirus_num++;\n\n\t\tif (!ctx->engine->keeptmp) {\n\t\t\tif (!access(tmp_fname, R_OK) && cli_unlink(tmp_fname)) {\n\t\t\t\tfree(tmp_fname);\n\t\t\t\tret = CL_EUNLINK;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfree(tmp_fname);\n\t\tfiles++;\n\t\tif (ret == CL_VIRUS && SCAN_ALL)\n\t\t\tcontinue;\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\nout_close:\n\tmschm_d->close(mschm_d, mschm_h);\nout_dest:\n\tmspack_destroy_chm_decompressor(mschm_d);\n\tif (virus_num)\n\t\treturn CL_VIRUS;\n\treturn ret;\n\n\treturn 0;\n}\n"], "fixing_code": ["/* This file is part of libmspack.\n * (C) 2003-2013 Stuart Caie.\n *\n * The LZX method was created by Jonathan Forbes and Tomi Poutanen, adapted\n * by Microsoft Corporation.\n *\n * libmspack is free software; you can redistribute it and/or modify it under\n * the terms of the GNU Lesser General Public License (LGPL) version 2.1\n *\n * For further details, see the file COPYING.LIB distributed with libmspack\n */\n\n/* LZX decompression implementation */\n\n#include <system.h>\n#include <lzx.h>\n\n/* Microsoft's LZX document (in cab-sdk.exe) and their implementation\n * of the com.ms.util.cab Java package do not concur.\n *\n * In the LZX document, there is a table showing the correlation between\n * window size and the number of position slots. It states that the 1MB\n * window = 40 slots and the 2MB window = 42 slots. In the implementation,\n * 1MB = 42 slots, 2MB = 50 slots. The actual calculation is 'find the\n * first slot whose position base is equal to or more than the required\n * window size'. This would explain why other tables in the document refer\n * to 50 slots rather than 42.\n *\n * The constant NUM_PRIMARY_LENGTHS used in the decompression pseudocode\n * is not defined in the specification.\n *\n * The LZX document does not state the uncompressed block has an\n * uncompressed length field. Where does this length field come from, so\n * we can know how large the block is? The implementation has it as the 24\n * bits following after the 3 blocktype bits, before the alignment\n * padding.\n *\n * The LZX document states that aligned offset blocks have their aligned\n * offset huffman tree AFTER the main and length trees. The implementation\n * suggests that the aligned offset tree is BEFORE the main and length\n * trees.\n *\n * The LZX document decoding algorithm states that, in an aligned offset\n * block, if an extra_bits value is 1, 2 or 3, then that number of bits\n * should be read and the result added to the match offset. This is\n * correct for 1 and 2, but not 3, where just a huffman symbol (using the\n * aligned tree) should be read.\n *\n * Regarding the E8 preprocessing, the LZX document states 'No translation\n * may be performed on the last 6 bytes of the input block'. This is\n * correct.  However, the pseudocode provided checks for the *E8 leader*\n * up to the last 6 bytes. If the leader appears between -10 and -7 bytes\n * from the end, this would cause the next four bytes to be modified, at\n * least one of which would be in the last 6 bytes, which is not allowed\n * according to the spec.\n *\n * The specification states that the huffman trees must always contain at\n * least one element. However, many CAB files contain blocks where the\n * length tree is completely empty (because there are no matches), and\n * this is expected to succeed.\n *\n * The errors in LZX documentation appear have been corrected in the\n * new documentation for the LZX DELTA format.\n *\n *     http://msdn.microsoft.com/en-us/library/cc483133.aspx\n *\n * However, this is a different format, an extension of regular LZX.\n * I have noticed the following differences, there may be more:\n *\n * The maximum window size has increased from 2MB to 32MB. This also\n * increases the maximum number of position slots, etc.\n *\n * If the match length is 257 (the maximum possible), this signals\n * a further length decoding step, that allows for matches up to\n * 33024 bytes long.\n *\n * The format now allows for \"reference data\", supplied by the caller.\n * If match offsets go further back than the number of bytes\n * decompressed so far, that is them accessing the reference data.\n */\n\n/* import bit-reading macros and code */\n#define BITS_TYPE struct lzxd_stream\n#define BITS_VAR lzx\n#define BITS_ORDER_MSB\n#define READ_BYTES do {\t\t\t\\\n    unsigned char b0, b1;\t\t\\\n    READ_IF_NEEDED; b0 = *i_ptr++;\t\\\n    READ_IF_NEEDED; b1 = *i_ptr++;\t\\\n    INJECT_BITS((b1 << 8) | b0, 16);\t\\\n} while (0)\n#include <readbits.h>\n\n/* import huffman-reading macros and code */\n#define TABLEBITS(tbl)      LZX_##tbl##_TABLEBITS\n#define MAXSYMBOLS(tbl)     LZX_##tbl##_MAXSYMBOLS\n#define HUFF_TABLE(tbl,idx) lzx->tbl##_table[idx]\n#define HUFF_LEN(tbl,idx)   lzx->tbl##_len[idx]\n#define HUFF_ERROR          return lzx->error = MSPACK_ERR_DECRUNCH\n#include <readhuff.h>\n\n/* BUILD_TABLE(tbl) builds a huffman lookup table from code lengths */\n#define BUILD_TABLE(tbl)\t\t\t\t\t\t\\\n    if (make_decode_table(MAXSYMBOLS(tbl), TABLEBITS(tbl),\t\t\\\n\t\t\t  &HUFF_LEN(tbl,0), &HUFF_TABLE(tbl,0)))\t\\\n    {\t\t\t\t\t\t\t\t\t\\\n        D((\"failed to build %s table\", #tbl))\t\t\t\t\\\n\treturn lzx->error = MSPACK_ERR_DECRUNCH;\t\t\t\\\n    }\n\n#define BUILD_TABLE_MAYBE_EMPTY(tbl) do {\t\t\t\t\\\n    lzx->tbl##_empty = 0;\t\t\t\t\t\t\\\n    if (make_decode_table(MAXSYMBOLS(tbl), TABLEBITS(tbl),\t\t\\\n                          &HUFF_LEN(tbl,0), &HUFF_TABLE(tbl,0)))\t\\\n    {\t\t\t\t\t\t\t\t\t\\\n\tfor (i = 0; i < MAXSYMBOLS(tbl); i++) {\t\t\t\t\\\n\t    if (HUFF_LEN(tbl, i) > 0) {\t\t\t\t\t\\\n\t\tD((\"failed to build %s table\", #tbl))\t\t\t\\\n\t\treturn lzx->error = MSPACK_ERR_DECRUNCH;\t\t\\\n\t    }\t\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\t/* empty tree - allow it, but don't decode symbols with it */\t\\\n\tlzx->tbl##_empty = 1;\t\t\t\t\t\t\\\n    }\t\t\t\t\t\t\t\t\t\\\n} while (0)\n\n/* READ_LENGTHS(tablename, first, last) reads in code lengths for symbols\n * first to last in the given table. The code lengths are stored in their\n * own special LZX way.\n */\n#define READ_LENGTHS(tbl, first, last) do {\t\t\\\n  STORE_BITS;\t\t\t\t\t\t\\\n  if (lzxd_read_lens(lzx, &HUFF_LEN(tbl, 0), (first),\t\\\n    (unsigned int)(last))) return lzx->error;\t\t\\\n  RESTORE_BITS;\t\t\t\t\t\t\\\n} while (0)\n\nstatic int lzxd_read_lens(struct lzxd_stream *lzx, unsigned char *lens,\n\t\t\t  unsigned int first, unsigned int last)\n{\n  /* bit buffer and huffman symbol decode variables */\n  register unsigned int bit_buffer;\n  register int bits_left, i;\n  register unsigned short sym;\n  unsigned char *i_ptr, *i_end;\n\n  unsigned int x, y;\n  int z;\n\n  RESTORE_BITS;\n  \n  /* read lengths for pretree (20 symbols, lengths stored in fixed 4 bits) */\n  for (x = 0; x < 20; x++) {\n    READ_BITS(y, 4);\n    lzx->PRETREE_len[x] = y;\n  }\n  BUILD_TABLE(PRETREE);\n\n  for (x = first; x < last; ) {\n    READ_HUFFSYM(PRETREE, z);\n    if (z == 17) {\n      /* code = 17, run of ([read 4 bits]+4) zeros */\n      READ_BITS(y, 4); y += 4;\n      while (y--) lens[x++] = 0;\n    }\n    else if (z == 18) {\n      /* code = 18, run of ([read 5 bits]+20) zeros */\n      READ_BITS(y, 5); y += 20;\n      while (y--) lens[x++] = 0;\n    }\n    else if (z == 19) {\n      /* code = 19, run of ([read 1 bit]+4) [read huffman symbol] */\n      READ_BITS(y, 1); y += 4;\n      READ_HUFFSYM(PRETREE, z);\n      z = lens[x] - z; if (z < 0) z += 17;\n      while (y--) lens[x++] = z;\n    }\n    else {\n      /* code = 0 to 16, delta current length entry */\n      z = lens[x] - z; if (z < 0) z += 17;\n      lens[x++] = z;\n    }\n  }\n\n  STORE_BITS;\n\n  return MSPACK_ERR_OK;\n}\n\n/* LZX static data tables:\n *\n * LZX uses 'position slots' to represent match offsets.  For every match,\n * a small 'position slot' number and a small offset from that slot are\n * encoded instead of one large offset.\n *\n * The number of slots is decided by how many are needed to encode the\n * largest offset for a given window size. This is easy when the gap between\n * slots is less than 128Kb, it's a linear relationship. But when extra_bits\n * reaches its limit of 17 (because LZX can only ensure reading 17 bits of\n * data at a time), we can only jump 128Kb at a time and have to start\n * using more and more position slots as each window size doubles.\n *\n * position_base[] is an index to the position slot bases\n *\n * extra_bits[] states how many bits of offset-from-base data is needed.\n *\n * They are calculated as follows:\n * extra_bits[i] = 0 where i < 4\n * extra_bits[i] = floor(i/2)-1 where i >= 4 && i < 36\n * extra_bits[i] = 17 where i >= 36\n * position_base[0] = 0\n * position_base[i] = position_base[i-1] + (1 << extra_bits[i-1])\n */\nstatic const unsigned int position_slots[11] = {\n    30, 32, 34, 36, 38, 42, 50, 66, 98, 162, 290\n};\nstatic const unsigned char extra_bits[36] = {\n    0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8,\n    9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15, 16, 16\n};\nstatic const unsigned int position_base[290] = {\n    0, 1, 2, 3, 4, 6, 8, 12, 16, 24, 32, 48, 64, 96, 128, 192, 256, 384, 512,\n    768, 1024, 1536, 2048, 3072, 4096, 6144, 8192, 12288, 16384, 24576, 32768,\n    49152, 65536, 98304, 131072, 196608, 262144, 393216, 524288, 655360,\n    786432, 917504, 1048576, 1179648, 1310720, 1441792, 1572864, 1703936,\n    1835008, 1966080, 2097152, 2228224, 2359296, 2490368, 2621440, 2752512,\n    2883584, 3014656, 3145728, 3276800, 3407872, 3538944, 3670016, 3801088,\n    3932160, 4063232, 4194304, 4325376, 4456448, 4587520, 4718592, 4849664,\n    4980736, 5111808, 5242880, 5373952, 5505024, 5636096, 5767168, 5898240,\n    6029312, 6160384, 6291456, 6422528, 6553600, 6684672, 6815744, 6946816,\n    7077888, 7208960, 7340032, 7471104, 7602176, 7733248, 7864320, 7995392,\n    8126464, 8257536, 8388608, 8519680, 8650752, 8781824, 8912896, 9043968,\n    9175040, 9306112, 9437184, 9568256, 9699328, 9830400, 9961472, 10092544,\n    10223616, 10354688, 10485760, 10616832, 10747904, 10878976, 11010048,\n    11141120, 11272192, 11403264, 11534336, 11665408, 11796480, 11927552,\n    12058624, 12189696, 12320768, 12451840, 12582912, 12713984, 12845056,\n    12976128, 13107200, 13238272, 13369344, 13500416, 13631488, 13762560,\n    13893632, 14024704, 14155776, 14286848, 14417920, 14548992, 14680064,\n    14811136, 14942208, 15073280, 15204352, 15335424, 15466496, 15597568,\n    15728640, 15859712, 15990784, 16121856, 16252928, 16384000, 16515072,\n    16646144, 16777216, 16908288, 17039360, 17170432, 17301504, 17432576,\n    17563648, 17694720, 17825792, 17956864, 18087936, 18219008, 18350080,\n    18481152, 18612224, 18743296, 18874368, 19005440, 19136512, 19267584,\n    19398656, 19529728, 19660800, 19791872, 19922944, 20054016, 20185088,\n    20316160, 20447232, 20578304, 20709376, 20840448, 20971520, 21102592,\n    21233664, 21364736, 21495808, 21626880, 21757952, 21889024, 22020096,\n    22151168, 22282240, 22413312, 22544384, 22675456, 22806528, 22937600,\n    23068672, 23199744, 23330816, 23461888, 23592960, 23724032, 23855104,\n    23986176, 24117248, 24248320, 24379392, 24510464, 24641536, 24772608,\n    24903680, 25034752, 25165824, 25296896, 25427968, 25559040, 25690112,\n    25821184, 25952256, 26083328, 26214400, 26345472, 26476544, 26607616,\n    26738688, 26869760, 27000832, 27131904, 27262976, 27394048, 27525120,\n    27656192, 27787264, 27918336, 28049408, 28180480, 28311552, 28442624,\n    28573696, 28704768, 28835840, 28966912, 29097984, 29229056, 29360128,\n    29491200, 29622272, 29753344, 29884416, 30015488, 30146560, 30277632,\n    30408704, 30539776, 30670848, 30801920, 30932992, 31064064, 31195136,\n    31326208, 31457280, 31588352, 31719424, 31850496, 31981568, 32112640,\n    32243712, 32374784, 32505856, 32636928, 32768000, 32899072, 33030144,\n    33161216, 33292288, 33423360\n};\n\nstatic void lzxd_reset_state(struct lzxd_stream *lzx) {\n  int i;\n\n  lzx->R0              = 1;\n  lzx->R1              = 1;\n  lzx->R2              = 1;\n  lzx->header_read     = 0;\n  lzx->block_remaining = 0;\n  lzx->block_type      = LZX_BLOCKTYPE_INVALID;\n\n  /* initialise tables to 0 (because deltas will be applied to them) */\n  for (i = 0; i < LZX_MAINTREE_MAXSYMBOLS; i++) lzx->MAINTREE_len[i] = 0;\n  for (i = 0; i < LZX_LENGTH_MAXSYMBOLS; i++)   lzx->LENGTH_len[i]   = 0;\n}\n\n/*-------- main LZX code --------*/\n\nstruct lzxd_stream *lzxd_init(struct mspack_system *system,\n\t\t\t      struct mspack_file *input,\n\t\t\t      struct mspack_file *output,\n\t\t\t      int window_bits,\n\t\t\t      int reset_interval,\n\t\t\t      int input_buffer_size,\n\t\t\t      off_t output_length,\n\t\t\t      char is_delta)\n{\n  unsigned int window_size = 1 << window_bits;\n  struct lzxd_stream *lzx;\n\n  if (!system) return NULL;\n\n  /* LZX DELTA window sizes are between 2^17 (128KiB) and 2^25 (32MiB),\n   * regular LZX windows are between 2^15 (32KiB) and 2^21 (2MiB)\n   */\n  if (is_delta) {\n      if (window_bits < 17 || window_bits > 25) return NULL;\n  }\n  else {\n      if (window_bits < 15 || window_bits > 21) return NULL;\n  }\n\n  input_buffer_size = (input_buffer_size + 1) & -2;\n  if (!input_buffer_size) return NULL;\n\n  /* allocate decompression state */\n  if (!(lzx = (struct lzxd_stream *) system->alloc(system, sizeof(struct lzxd_stream)))) {\n    return NULL;\n  }\n\n  /* allocate decompression window and input buffer */\n  lzx->window = (unsigned char *) system->alloc(system, (size_t) window_size);\n  lzx->inbuf  = (unsigned char *) system->alloc(system, (size_t) input_buffer_size);\n  if (!lzx->window || !lzx->inbuf) {\n    system->free(lzx->window);\n    system->free(lzx->inbuf);\n    system->free(lzx);\n    return NULL;\n  }\n\n  /* initialise decompression state */\n  lzx->sys             = system;\n  lzx->input           = input;\n  lzx->output          = output;\n  lzx->offset          = 0;\n  lzx->length          = output_length;\n\n  lzx->inbuf_size      = input_buffer_size;\n  lzx->window_size     = 1 << window_bits;\n  lzx->ref_data_size   = 0;\n  lzx->window_posn     = 0;\n  lzx->frame_posn      = 0;\n  lzx->frame           = 0;\n  lzx->reset_interval  = reset_interval;\n  lzx->intel_filesize  = 0;\n  lzx->intel_curpos    = 0;\n  lzx->intel_started   = 0;\n  lzx->error           = MSPACK_ERR_OK;\n  lzx->num_offsets     = position_slots[window_bits - 15] << 3;\n  lzx->is_delta        = is_delta;\n\n  lzx->o_ptr = lzx->o_end = &lzx->e8_buf[0];\n  lzxd_reset_state(lzx);\n  INIT_BITS;\n  return lzx;\n}\n\nint lzxd_set_reference_data(struct lzxd_stream *lzx,\n\t\t\t    struct mspack_system *system,\n\t\t\t    struct mspack_file *input,\n\t\t\t    unsigned int length)\n{\n    if (!lzx) return MSPACK_ERR_ARGS;\n\n    if (!lzx->is_delta) {\n        D((\"only LZX DELTA streams support reference data\"))\n        return MSPACK_ERR_ARGS;\n    }\n    if (lzx->offset) {\n\tD((\"too late to set reference data after decoding starts\"))\n\treturn MSPACK_ERR_ARGS;\n    }\n    if (length > lzx->window_size) {\n\tD((\"reference length (%u) is longer than the window\", length))\n\treturn MSPACK_ERR_ARGS;\n    }\n    if (length > 0 && (!system || !input)) {\n        D((\"length > 0 but no system or input\"))\n        return MSPACK_ERR_ARGS;\n    }\n\n    lzx->ref_data_size = length;\n    if (length > 0) {\n        /* copy reference data */\n        unsigned char *pos = &lzx->window[lzx->window_size - length];\n\tint bytes = system->read(input, pos, length);\n        /* length can't be more than 2^25, so no signedness problem */\n\tif (bytes < (int)length) return MSPACK_ERR_READ;\n    }\n    lzx->ref_data_size = length;\n    return MSPACK_ERR_OK;\n}\n\nvoid lzxd_set_output_length(struct lzxd_stream *lzx, off_t out_bytes) {\n  if (lzx) lzx->length = out_bytes;\n}\n\nint lzxd_decompress(struct lzxd_stream *lzx, off_t out_bytes) {\n  /* bitstream and huffman reading variables */\n  register unsigned int bit_buffer;\n  register int bits_left, i=0;\n  unsigned char *i_ptr, *i_end;\n  register unsigned short sym;\n\n  int match_length, length_footer, extra, verbatim_bits, bytes_todo;\n  int this_run, main_element, aligned_bits, j;\n  unsigned char *window, *runsrc, *rundest, buf[12];\n  unsigned int frame_size=0, end_frame, match_offset, window_posn;\n  unsigned int R0, R1, R2;\n\n  /* easy answers */\n  if (!lzx || (out_bytes < 0)) return MSPACK_ERR_ARGS;\n  if (lzx->error) return lzx->error;\n\n  /* flush out any stored-up bytes before we begin */\n  i = lzx->o_end - lzx->o_ptr;\n  if ((off_t) i > out_bytes) i = (int) out_bytes;\n  if (i) {\n    if (lzx->sys->write(lzx->output, lzx->o_ptr, i) != i) {\n      return lzx->error = MSPACK_ERR_WRITE;\n    }\n    lzx->o_ptr  += i;\n    lzx->offset += i;\n    out_bytes   -= i;\n  }\n  if (out_bytes == 0) return MSPACK_ERR_OK;\n\n  /* restore local state */\n  RESTORE_BITS;\n  window = lzx->window;\n  window_posn = lzx->window_posn;\n  R0 = lzx->R0;\n  R1 = lzx->R1;\n  R2 = lzx->R2;\n\n  end_frame = (unsigned int)((lzx->offset + out_bytes) / LZX_FRAME_SIZE) + 1;\n\n  while (lzx->frame < end_frame) {\n    /* have we reached the reset interval? (if there is one?) */\n    if (lzx->reset_interval && ((lzx->frame % lzx->reset_interval) == 0)) {\n      if (lzx->block_remaining) {\n\tD((\"%d bytes remaining at reset interval\", lzx->block_remaining))\n\treturn lzx->error = MSPACK_ERR_DECRUNCH;\n      }\n\n      /* re-read the intel header and reset the huffman lengths */\n      lzxd_reset_state(lzx);\n      R0 = lzx->R0;\n      R1 = lzx->R1;\n      R2 = lzx->R2;\n    }\n\n    /* LZX DELTA format has chunk_size, not present in LZX format */\n    if (lzx->is_delta) {\n      ENSURE_BITS(16);\n      REMOVE_BITS(16);\n    }\n\n    /* read header if necessary */\n    if (!lzx->header_read) {\n      /* read 1 bit. if bit=0, intel filesize = 0.\n       * if bit=1, read intel filesize (32 bits) */\n      j = 0; READ_BITS(i, 1); if (i) { READ_BITS(i, 16); READ_BITS(j, 16); }\n      lzx->intel_filesize = (i << 16) | j;\n      lzx->header_read = 1;\n    } \n\n    /* calculate size of frame: all frames are 32k except the final frame\n     * which is 32kb or less. this can only be calculated when lzx->length\n     * has been filled in. */\n    frame_size = LZX_FRAME_SIZE;\n    if (lzx->length && (lzx->length - lzx->offset) < (off_t)frame_size) {\n      frame_size = lzx->length - lzx->offset;\n    }\n\n    /* decode until one more frame is available */\n    bytes_todo = lzx->frame_posn + frame_size - window_posn;\n    while (bytes_todo > 0) {\n      /* initialise new block, if one is needed */\n      if (lzx->block_remaining == 0) {\n\t/* realign if previous block was an odd-sized UNCOMPRESSED block */\n\tif ((lzx->block_type == LZX_BLOCKTYPE_UNCOMPRESSED) &&\n\t    (lzx->block_length & 1))\n\t{\n\t  READ_IF_NEEDED;\n\t  i_ptr++;\n\t}\n\n\t/* read block type (3 bits) and block length (24 bits) */\n\tREAD_BITS(lzx->block_type, 3);\n\tREAD_BITS(i, 16); READ_BITS(j, 8);\n\tlzx->block_remaining = lzx->block_length = (i << 8) | j;\n\t/*D((\"new block t%d len %u\", lzx->block_type, lzx->block_length))*/\n\n\t/* read individual block headers */\n\tswitch (lzx->block_type) {\n\tcase LZX_BLOCKTYPE_ALIGNED:\n\t  /* read lengths of and build aligned huffman decoding tree */\n\t  for (i = 0; i < 8; i++) { READ_BITS(j, 3); lzx->ALIGNED_len[i] = j; }\n\t  BUILD_TABLE(ALIGNED);\n\t  /* no break -- rest of aligned header is same as verbatim */\n\tcase LZX_BLOCKTYPE_VERBATIM:\n\t  /* read lengths of and build main huffman decoding tree */\n\t  READ_LENGTHS(MAINTREE, 0, 256);\n\t  READ_LENGTHS(MAINTREE, 256, LZX_NUM_CHARS + lzx->num_offsets);\n\t  BUILD_TABLE(MAINTREE);\n\t  /* if the literal 0xE8 is anywhere in the block... */\n\t  if (lzx->MAINTREE_len[0xE8] != 0) lzx->intel_started = 1;\n\t  /* read lengths of and build lengths huffman decoding tree */\n\t  READ_LENGTHS(LENGTH, 0, LZX_NUM_SECONDARY_LENGTHS);\n\t  BUILD_TABLE_MAYBE_EMPTY(LENGTH);\n\t  break;\n\n\tcase LZX_BLOCKTYPE_UNCOMPRESSED:\n\t  /* because we can't assume otherwise */\n\t  lzx->intel_started = 1;\n\n\t  /* read 1-16 (not 0-15) bits to align to bytes */\n\t  if (bits_left == 0) ENSURE_BITS(16);\n\t  bits_left = 0; bit_buffer = 0;\n\n\t  /* read 12 bytes of stored R0 / R1 / R2 values */\n\t  for (rundest = &buf[0], i = 0; i < 12; i++) {\n\t    READ_IF_NEEDED;\n\t    *rundest++ = *i_ptr++;\n\t  }\n\t  R0 = buf[0] | (buf[1] << 8) | (buf[2]  << 16) | (buf[3]  << 24);\n\t  R1 = buf[4] | (buf[5] << 8) | (buf[6]  << 16) | (buf[7]  << 24);\n\t  R2 = buf[8] | (buf[9] << 8) | (buf[10] << 16) | (buf[11] << 24);\n\t  break;\n\n\tdefault:\n\t  D((\"bad block type\"))\n\t  return lzx->error = MSPACK_ERR_DECRUNCH;\n\t}\n      }\n\n      /* decode more of the block:\n       * run = min(what's available, what's needed) */\n      this_run = lzx->block_remaining;\n      if (this_run > bytes_todo) this_run = bytes_todo;\n\n      /* assume we decode exactly this_run bytes, for now */\n      bytes_todo           -= this_run;\n      lzx->block_remaining -= this_run;\n\n      /* decode at least this_run bytes */\n      switch (lzx->block_type) {\n      case LZX_BLOCKTYPE_VERBATIM:\n\twhile (this_run > 0) {\n\t  READ_HUFFSYM(MAINTREE, main_element);\n\t  if (main_element < LZX_NUM_CHARS) {\n\t    /* literal: 0 to LZX_NUM_CHARS-1 */\n\t    window[window_posn++] = main_element;\n\t    this_run--;\n\t  }\n\t  else {\n\t    /* match: LZX_NUM_CHARS + ((slot<<3) | length_header (3 bits)) */\n\t    main_element -= LZX_NUM_CHARS;\n\n\t    /* get match length */\n\t    match_length = main_element & LZX_NUM_PRIMARY_LENGTHS;\n\t    if (match_length == LZX_NUM_PRIMARY_LENGTHS) {\n\t      if (lzx->LENGTH_empty) {\n                D((\"LENGTH symbol needed but tree is empty\"))\n                return lzx->error = MSPACK_ERR_DECRUNCH;\n              }\n\t      READ_HUFFSYM(LENGTH, length_footer);\n\t      match_length += length_footer;\n\t    }\n\t    match_length += LZX_MIN_MATCH;\n\n\t    /* get match offset */\n\t    switch ((match_offset = (main_element >> 3))) {\n\t    case 0: match_offset = R0;                                  break;\n\t    case 1: match_offset = R1; R1=R0;        R0 = match_offset; break;\n\t    case 2: match_offset = R2; R2=R0;        R0 = match_offset; break;\n\t    case 3: match_offset = 1;  R2=R1; R1=R0; R0 = match_offset; break;\n\t    default:\n\t      extra = (match_offset >= 36) ? 17 : extra_bits[match_offset];\n\t      READ_BITS(verbatim_bits, extra);\n\t      match_offset = position_base[match_offset] - 2 + verbatim_bits;\n\t      R2 = R1; R1 = R0; R0 = match_offset;\n\t    }\n\n\t    /* LZX DELTA uses max match length to signal even longer match */\n\t    if (match_length == LZX_MAX_MATCH && lzx->is_delta) {\n\t\tint extra_len = 0;\n\t\tENSURE_BITS(3); /* 4 entry huffman tree */\n\t\tif (PEEK_BITS(1) == 0) {\n\t\t    REMOVE_BITS(1); /* '0' -> 8 extra length bits */\n\t\t    READ_BITS(extra_len, 8);\n\t\t}\n\t\telse if (PEEK_BITS(2) == 2) {\n\t\t    REMOVE_BITS(2); /* '10' -> 10 extra length bits + 0x100 */\n\t\t    READ_BITS(extra_len, 10);\n\t\t    extra_len += 0x100;\n\t\t}\n\t\telse if (PEEK_BITS(3) == 6) {\n\t\t    REMOVE_BITS(3); /* '110' -> 12 extra length bits + 0x500 */\n\t\t    READ_BITS(extra_len, 12);\n\t\t    extra_len += 0x500;\n\t\t}\n\t\telse {\n\t\t    REMOVE_BITS(3); /* '111' -> 15 extra length bits */\n\t\t    READ_BITS(extra_len, 15);\n\t\t}\n\t\tmatch_length += extra_len;\n\t    }\n\n\t    if ((window_posn + match_length) > lzx->window_size) {\n\t      D((\"match ran over window wrap\"))\n\t      return lzx->error = MSPACK_ERR_DECRUNCH;\n\t    }\n\t    \n\t    /* copy match */\n\t    rundest = &window[window_posn];\n\t    i = match_length;\n\t    /* does match offset wrap the window? */\n\t    if (match_offset > window_posn) {\n\t      if (match_offset > lzx->offset &&\n\t\t  (match_offset - window_posn) > lzx->ref_data_size)\n\t      {\n\t\tD((\"match offset beyond LZX stream\"))\n\t\treturn lzx->error = MSPACK_ERR_DECRUNCH;\n\t      }\n\t      /* j = length from match offset to end of window */\n\t      j = match_offset - window_posn;\n\t      if (j > (int) lzx->window_size) {\n\t\tD((\"match offset beyond window boundaries\"))\n\t\treturn lzx->error = MSPACK_ERR_DECRUNCH;\n\t      }\n\t      runsrc = &window[lzx->window_size - j];\n\t      if (j < i) {\n\t\t/* if match goes over the window edge, do two copy runs */\n\t\ti -= j; while (j-- > 0) *rundest++ = *runsrc++;\n\t\trunsrc = window;\n\t      }\n\t      while (i-- > 0) *rundest++ = *runsrc++;\n\t    }\n\t    else {\n\t      runsrc = rundest - match_offset;\n\t      while (i-- > 0) *rundest++ = *runsrc++;\n\t    }\n\n\t    this_run    -= match_length;\n\t    window_posn += match_length;\n\t  }\n\t} /* while (this_run > 0) */\n\tbreak;\n\n      case LZX_BLOCKTYPE_ALIGNED:\n\twhile (this_run > 0) {\n\t  READ_HUFFSYM(MAINTREE, main_element);\n\t  if (main_element < LZX_NUM_CHARS) {\n\t    /* literal: 0 to LZX_NUM_CHARS-1 */\n\t    window[window_posn++] = main_element;\n\t    this_run--;\n\t  }\n\t  else {\n\t    /* match: LZX_NUM_CHARS + ((slot<<3) | length_header (3 bits)) */\n\t    main_element -= LZX_NUM_CHARS;\n\n\t    /* get match length */\n\t    match_length = main_element & LZX_NUM_PRIMARY_LENGTHS;\n\t    if (match_length == LZX_NUM_PRIMARY_LENGTHS) {\n              if (lzx->LENGTH_empty) {\n                D((\"LENGTH symbol needed but tree is empty\"))\n                return lzx->error = MSPACK_ERR_DECRUNCH;\n              } \n\t      READ_HUFFSYM(LENGTH, length_footer);\n\t      match_length += length_footer;\n\t    }\n\t    match_length += LZX_MIN_MATCH;\n\n\t    /* get match offset */\n\t    switch ((match_offset = (main_element >> 3))) {\n\t    case 0: match_offset = R0;                             break;\n\t    case 1: match_offset = R1; R1 = R0; R0 = match_offset; break;\n\t    case 2: match_offset = R2; R2 = R0; R0 = match_offset; break;\n\t    default:\n\t      extra = (match_offset >= 36) ? 17 : extra_bits[match_offset];\n\t      match_offset = position_base[match_offset] - 2;\n\t      if (extra > 3) {\n\t\t/* verbatim and aligned bits */\n\t\textra -= 3;\n\t\tREAD_BITS(verbatim_bits, extra);\n\t\tmatch_offset += (verbatim_bits << 3);\n\t\tREAD_HUFFSYM(ALIGNED, aligned_bits);\n\t\tmatch_offset += aligned_bits;\n\t      }\n\t      else if (extra == 3) {\n\t\t/* aligned bits only */\n\t\tREAD_HUFFSYM(ALIGNED, aligned_bits);\n\t\tmatch_offset += aligned_bits;\n\t      }\n\t      else if (extra > 0) { /* extra==1, extra==2 */\n\t\t/* verbatim bits only */\n\t\tREAD_BITS(verbatim_bits, extra);\n\t\tmatch_offset += verbatim_bits;\n\t      }\n\t      else /* extra == 0 */ {\n\t\t/* ??? not defined in LZX specification! */\n\t\tmatch_offset = 1;\n\t      }\n\t      /* update repeated offset LRU queue */\n\t      R2 = R1; R1 = R0; R0 = match_offset;\n\t    }\n\n\t    /* LZX DELTA uses max match length to signal even longer match */\n\t    if (match_length == LZX_MAX_MATCH && lzx->is_delta) {\n\t\tint extra_len = 0;\n\t\tENSURE_BITS(3); /* 4 entry huffman tree */\n\t\tif (PEEK_BITS(1) == 0) {\n\t\t    REMOVE_BITS(1); /* '0' -> 8 extra length bits */\n\t\t    READ_BITS(extra_len, 8);\n\t\t}\n\t\telse if (PEEK_BITS(2) == 2) {\n\t\t    REMOVE_BITS(2); /* '10' -> 10 extra length bits + 0x100 */\n\t\t    READ_BITS(extra_len, 10);\n\t\t    extra_len += 0x100;\n\t\t}\n\t\telse if (PEEK_BITS(3) == 6) {\n\t\t    REMOVE_BITS(3); /* '110' -> 12 extra length bits + 0x500 */\n\t\t    READ_BITS(extra_len, 12);\n\t\t    extra_len += 0x500;\n\t\t}\n\t\telse {\n\t\t    REMOVE_BITS(3); /* '111' -> 15 extra length bits */\n\t\t    READ_BITS(extra_len, 15);\n\t\t}\n\t\tmatch_length += extra_len;\n\t    }\n\n\t    if ((window_posn + match_length) > lzx->window_size) {\n\t      D((\"match ran over window wrap\"))\n\t      return lzx->error = MSPACK_ERR_DECRUNCH;\n\t    }\n\n\t    /* copy match */\n\t    rundest = &window[window_posn];\n\t    i = match_length;\n\t    /* does match offset wrap the window? */\n\t    if (match_offset > window_posn) {\n\t      if (match_offset > lzx->offset &&\n\t\t  (match_offset - window_posn) > lzx->ref_data_size)\n\t      {\n\t\tD((\"match offset beyond LZX stream\"))\n\t\treturn lzx->error = MSPACK_ERR_DECRUNCH;\n\t      }\n\t      /* j = length from match offset to end of window */\n\t      j = match_offset - window_posn;\n\t      if (j > (int) lzx->window_size) {\n\t\tD((\"match offset beyond window boundaries\"))\n\t\treturn lzx->error = MSPACK_ERR_DECRUNCH;\n\t      }\n\t      runsrc = &window[lzx->window_size - j];\n\t      if (j < i) {\n\t\t/* if match goes over the window edge, do two copy runs */\n\t\ti -= j; while (j-- > 0) *rundest++ = *runsrc++;\n\t\trunsrc = window;\n\t      }\n\t      while (i-- > 0) *rundest++ = *runsrc++;\n\t    }\n\t    else {\n\t      runsrc = rundest - match_offset;\n\t      while (i-- > 0) *rundest++ = *runsrc++;\n\t    }\n\n\t    this_run    -= match_length;\n\t    window_posn += match_length;\n\t  }\n\t} /* while (this_run > 0) */\n\tbreak;\n\n      case LZX_BLOCKTYPE_UNCOMPRESSED:\n\t/* as this_run is limited not to wrap a frame, this also means it\n\t * won't wrap the window (as the window is a multiple of 32k) */\n        if (window_posn + this_run > lzx->window_size) {\n                D((\"match ran over window boundary\"))\n                return lzx->error = MSPACK_ERR_DECRUNCH;\n        }\n\trundest = &window[window_posn];\n\twindow_posn += this_run;\n\n\twhile (this_run > 0) {\n\t  if ((i = i_end - i_ptr) == 0) {\n\t    READ_IF_NEEDED;\n\t  }\n\t  else {\n\t    if (i > this_run) i = this_run;\n\t    lzx->sys->copy(i_ptr, rundest, (size_t) i);\n\t    rundest  += i;\n\t    i_ptr    += i;\n\t    this_run -= i;\n\t  }\n\t}\n\tbreak;\n\n      default:\n\treturn lzx->error = MSPACK_ERR_DECRUNCH; /* might as well */\n      }\n\n      /* did the final match overrun our desired this_run length? */\n      if (this_run < 0) {\n\tif ((unsigned int)(-this_run) > lzx->block_remaining) {\n\t  D((\"overrun went past end of block by %d (%d remaining)\",\n\t     -this_run, lzx->block_remaining ))\n\t  return lzx->error = MSPACK_ERR_DECRUNCH;\n\t}\n\tlzx->block_remaining -= -this_run;\n      }\n    } /* while (bytes_todo > 0) */\n\n    /* streams don't extend over frame boundaries */\n    if ((window_posn - lzx->frame_posn) != frame_size) {\n      D((\"decode beyond output frame limits! %d != %d\",\n\t window_posn - lzx->frame_posn, frame_size))\n      return lzx->error = MSPACK_ERR_DECRUNCH;\n    }\n\n    /* re-align input bitstream */\n    if (bits_left > 0) ENSURE_BITS(16);\n    if (bits_left & 15) REMOVE_BITS(bits_left & 15);\n\n    /* check that we've used all of the previous frame first */\n    if (lzx->o_ptr != lzx->o_end) {\n      D((\"%ld avail bytes, new %d frame\",\n          (long)(lzx->o_end - lzx->o_ptr), frame_size))\n      return lzx->error = MSPACK_ERR_DECRUNCH;\n    }\n\n    /* does this intel block _really_ need decoding? */\n    if (lzx->intel_started && lzx->intel_filesize &&\n\t(lzx->frame <= 32768) && (frame_size > 10))\n    {\n      unsigned char *data    = &lzx->e8_buf[0];\n      unsigned char *dataend = &lzx->e8_buf[frame_size - 10];\n      signed int curpos      = lzx->intel_curpos;\n      signed int filesize    = lzx->intel_filesize;\n      signed int abs_off, rel_off;\n\n      /* copy e8 block to the e8 buffer and tweak if needed */\n      lzx->o_ptr = data;\n      lzx->sys->copy(&lzx->window[lzx->frame_posn], data, frame_size);\n\n      while (data < dataend) {\n\tif (*data++ != 0xE8) { curpos++; continue; }\n\tabs_off = data[0] | (data[1]<<8) | (data[2]<<16) | (data[3]<<24);\n\tif ((abs_off >= -curpos) && (abs_off < filesize)) {\n\t  rel_off = (abs_off >= 0) ? abs_off - curpos : abs_off + filesize;\n\t  data[0] = (unsigned char) rel_off;\n\t  data[1] = (unsigned char) (rel_off >> 8);\n\t  data[2] = (unsigned char) (rel_off >> 16);\n\t  data[3] = (unsigned char) (rel_off >> 24);\n\t}\n\tdata += 4;\n\tcurpos += 5;\n      }\n      lzx->intel_curpos += frame_size;\n    }\n    else {\n      lzx->o_ptr = &lzx->window[lzx->frame_posn];\n      if (lzx->intel_filesize) lzx->intel_curpos += frame_size;\n    }\n    lzx->o_end = &lzx->o_ptr[frame_size];\n\n    /* write a frame */\n    i = (out_bytes < (off_t)frame_size) ? (unsigned int)out_bytes : frame_size;\n    if (lzx->sys->write(lzx->output, lzx->o_ptr, i) != i) {\n      return lzx->error = MSPACK_ERR_WRITE;\n    }\n    lzx->o_ptr  += i;\n    lzx->offset += i;\n    out_bytes   -= i;\n\n    /* advance frame start position */\n    lzx->frame_posn += frame_size;\n    lzx->frame++;\n\n    /* wrap window / frame position pointers */\n    if (window_posn == lzx->window_size)     window_posn = 0;\n    if (lzx->frame_posn == lzx->window_size) lzx->frame_posn = 0;\n\n  } /* while (lzx->frame < end_frame) */\n\n  if (out_bytes) {\n    D((\"bytes left to output\"))\n    return lzx->error = MSPACK_ERR_DECRUNCH;\n  }\n\n  /* store local state */\n  STORE_BITS;\n  lzx->window_posn = window_posn;\n  lzx->R0 = R0;\n  lzx->R1 = R1;\n  lzx->R2 = R2;\n\n  return MSPACK_ERR_OK;\n}\n\nvoid lzxd_free(struct lzxd_stream *lzx) {\n  struct mspack_system *sys;\n  if (lzx) {\n    sys = lzx->sys;\n    if(lzx->inbuf)\n        sys->free(lzx->inbuf);\n    if(lzx->window)\n        sys->free(lzx->window);\n    sys->free(lzx);\n  }\n}\n", "/*\n * Glue code for libmspack handling.\n * Author: \uc6c3 Sebastian Andrzej Siewior\n * \u2709 sebastian @ breakpoint \u0323cc\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n\n#include <mspack.h>\n\n#include \"clamav.h\"\n#include \"fmap.h\"\n#include \"scanners.h\"\n#include \"others.h\"\n\nenum mspack_type {\n\tFILETYPE_DUNNO,\n\tFILETYPE_FMAP,\n\tFILETYPE_FILENAME,\n};\n\nstruct mspack_name {\n\tfmap_t *fmap;\n\toff_t org;\n};\n\nstruct mspack_system_ex {\n\tstruct mspack_system ops;\n\toff_t max_size;\n};\n\nstruct mspack_handle {\n\tenum mspack_type type;\n\n\tfmap_t *fmap;\n\toff_t org;\n\toff_t offset;\n\n\tFILE *f;\n\toff_t max_size;\n};\n\nstatic struct mspack_file *mspack_fmap_open(struct mspack_system *self,\n\t\tconst char *filename, int mode)\n{\n\tstruct mspack_name *mspack_name;\n\tstruct mspack_handle *mspack_handle;\n\tstruct mspack_system_ex *self_ex;\n\tconst char *fmode;\n        const struct mspack_system *mptr = self;\n\n\tif (!filename) {\n\t\tcli_dbgmsg(\"%s() failed at %d\\n\", __func__, __LINE__);\n\t\treturn NULL;\n\t}\n\tmspack_handle = malloc(sizeof(*mspack_handle));\n\tif (!mspack_handle) {\n\t\tcli_dbgmsg(\"%s() failed at %d\\n\", __func__, __LINE__);\n\t\treturn NULL;\n\t}\n\tswitch (mode) {\n\tcase MSPACK_SYS_OPEN_READ:\n\t\tmspack_handle->type = FILETYPE_FMAP;\n\n\t\tmspack_name = (struct mspack_name *)filename;\n\t\tmspack_handle->fmap = mspack_name->fmap;\n\t\tmspack_handle->org = mspack_name->org;\n\t\tmspack_handle->offset = 0;\n\n\t\treturn (struct mspack_file *)mspack_handle;\n\n\tcase MSPACK_SYS_OPEN_WRITE:\n\t\tfmode = \"wb\";\n\t\tbreak;\n\tcase MSPACK_SYS_OPEN_UPDATE:\n\t\tfmode = \"r+b\";\n\t\tbreak;\n\tcase MSPACK_SYS_OPEN_APPEND:\n\t\tfmode = \"ab\";\n\t\tbreak;\n\tdefault:\n\t\tcli_dbgmsg(\"%s() wrong mode\\n\", __func__);\n\t\tgoto out_err;\n\t}\n\n\tmspack_handle->type = FILETYPE_FILENAME;\n\n\tmspack_handle->f = fopen(filename, fmode);\n\tif (!mspack_handle->f) {\n\t\tcli_dbgmsg(\"%s() failed %d\\n\", __func__, __LINE__);\n\t\tgoto out_err;\n\t}\n\n\tself_ex = (struct mspack_system_ex *)((char *)mptr - offsetof(struct mspack_system_ex,ops));\n\tmspack_handle->max_size = self_ex->max_size;\n\treturn (struct mspack_file *)mspack_handle;\n\nout_err:\n\tfree(mspack_handle);\n\treturn NULL;\n}\n\nstatic void mspack_fmap_close(struct mspack_file *file)\n{\n\tstruct mspack_handle *mspack_handle = (struct mspack_handle *)file;\n\n\tif (!mspack_handle)\n\t\treturn;\n\n\tif (mspack_handle->type == FILETYPE_FILENAME)\n\t\tfclose(mspack_handle->f);\n\tfree(mspack_handle);\n}\n\nstatic int mspack_fmap_read(struct mspack_file *file, void *buffer, int bytes)\n{\n\tstruct mspack_handle *mspack_handle = (struct mspack_handle *)file;\n\toff_t offset;\n\tsize_t count;\n\tint ret;\n\n\tif (bytes < 0) {\n\t\tcli_dbgmsg(\"%s() %d\\n\", __func__, __LINE__);\n\t\treturn -1;\n\t}\n\tif (!mspack_handle) {\n\t\tcli_dbgmsg(\"%s() %d\\n\", __func__, __LINE__);\n\t\treturn -1;\n\t}\n\n\tif (mspack_handle->type == FILETYPE_FMAP) {\n\t\toffset = mspack_handle->offset + mspack_handle->org;\n\n\t\tret = fmap_readn(mspack_handle->fmap, buffer, offset, bytes);\n\t\tif (ret != bytes) {\n\t\t\tcli_dbgmsg(\"%s() %d %d, %d\\n\", __func__, __LINE__, bytes, ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tmspack_handle->offset += bytes;\n\t\treturn bytes;\n\t}\n\tcount = fread(buffer, bytes, 1, mspack_handle->f);\n\tif (count < 1) {\n\t\tcli_dbgmsg(\"%s() %d %d, %zd\\n\", __func__, __LINE__, bytes, count);\n\t\treturn -1;\n\t}\n\treturn bytes;\n}\n\nstatic int mspack_fmap_write(struct mspack_file *file, void *buffer, int bytes)\n{\n\tstruct mspack_handle *mspack_handle = (struct mspack_handle *)file;\n\tsize_t count;\n\toff_t max_size;\n\n\tif (bytes < 0 || !mspack_handle) {\n\t\tcli_dbgmsg(\"%s() err %d\\n\", __func__, __LINE__);\n\t\treturn -1;\n\t}\n\n\tif (mspack_handle->type == FILETYPE_FMAP) {\n\t\tcli_dbgmsg(\"%s() err %d\\n\", __func__, __LINE__);\n\t\treturn -1;\n\t}\n\n\tif (!bytes)\n\t\treturn 0;\n\n\tmax_size = mspack_handle->max_size;\n\tif (!max_size)\n\t\treturn bytes;\n\n\tmax_size = max_size < (off_t) bytes ? max_size : (off_t) bytes;\n \n\tmspack_handle->max_size -= max_size;\n\n\tcount = fwrite(buffer, max_size, 1, mspack_handle->f);\n\tif (count < 1) {\n\t\tcli_dbgmsg(\"%s() err %m <%zd %d>\\n\", __func__, count, bytes);\n\t\treturn -1;\n\t}\n\n\treturn bytes;\n}\n\nstatic int mspack_fmap_seek(struct mspack_file *file, off_t offset, int mode)\n{\n\tstruct mspack_handle *mspack_handle = (struct mspack_handle *)file;\n\n\tif (!mspack_handle) {\n\t\tcli_dbgmsg(\"%s() err %d\\n\", __func__, __LINE__);\n\t\treturn -1;\n\t}\n\n\tif (mspack_handle->type == FILETYPE_FMAP) {\n\t\toff_t new_pos;\n\n\t\tswitch (mode) {\n\t\tcase MSPACK_SYS_SEEK_START:\n\t\t\tnew_pos = offset;\n\t\t\tbreak;\n\t\tcase MSPACK_SYS_SEEK_CUR:\n\t\t\tnew_pos = mspack_handle->offset + offset;\n\t\t\tbreak;\n\t\tcase MSPACK_SYS_SEEK_END:\n\t\t\tnew_pos = mspack_handle->fmap->len + offset;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcli_dbgmsg(\"%s() err %d\\n\", __func__, __LINE__);\n\t\t\treturn -1;\n\t\t}\n\t\tif (new_pos < 0 || new_pos > mspack_handle->fmap->len) {\n\t\t\tcli_dbgmsg(\"%s() err %d\\n\", __func__, __LINE__);\n\t\t\treturn -1;\n\t\t}\n\n\t\tmspack_handle->offset = new_pos;\n\t\treturn 0;\n\t}\n\n\tswitch (mode) {\n\tcase MSPACK_SYS_SEEK_START:\n\t\tmode = SEEK_SET;\n\t\tbreak;\n\tcase MSPACK_SYS_SEEK_CUR:\n\t\tmode = SEEK_CUR;\n\t\tbreak;\n\tcase MSPACK_SYS_SEEK_END:\n\t\tmode = SEEK_END;\n\t\tbreak;\n\tdefault:\n\t\tcli_dbgmsg(\"%s() err %d\\n\", __func__, __LINE__);\n\t\treturn -1;\n\t}\n\n\treturn fseek(mspack_handle->f, offset, mode);\n}\n\nstatic off_t mspack_fmap_tell(struct mspack_file *file)\n{\n\tstruct mspack_handle *mspack_handle = (struct mspack_handle *)file;\n\n\tif (!mspack_handle)\n\t\treturn -1;\n\n\tif (mspack_handle->type == FILETYPE_FMAP)\n\t\treturn mspack_handle->offset;\n\n\treturn (off_t) ftell(mspack_handle->f);\n}\n\nstatic void mspack_fmap_message(struct mspack_file *file, const char *fmt, ...)\n{\n\tcli_dbgmsg(\"%s() %s\\n\", __func__, fmt);\n}\nstatic void *mspack_fmap_alloc(struct mspack_system *self, size_t num)\n{\n\treturn malloc(num);\n}\n\nstatic void mspack_fmap_free(void *mem)\n{\n    if(mem) {\n        free(mem);\n        mem = NULL;\n    }\n    return;\n}\n\nstatic void mspack_fmap_copy(void *src, void *dst, size_t num)\n{\n\tmemcpy(dst, src, num);\n}\n\nstatic struct mspack_system mspack_sys_fmap_ops = {\n\t.open = mspack_fmap_open,\n\t.close = mspack_fmap_close,\n\t.read = mspack_fmap_read,\n\t.write = mspack_fmap_write,\n\t.seek = mspack_fmap_seek,\n\t.tell = mspack_fmap_tell,\n\t.message = mspack_fmap_message,\n\t.alloc = mspack_fmap_alloc,\n\t.free = mspack_fmap_free,\n\t.copy = mspack_fmap_copy,\n};\n\nstatic int cli_scanfile(const char *filename, cli_ctx *ctx)\n{\n\tint fd, ret;\n\n\t/* internal version of cl_scanfile with arec/mrec preserved */\n\tfd = safe_open(filename, O_RDONLY|O_BINARY);\n\tif (fd < 0)\n\t\treturn CL_EOPEN;\n\n\tret = cli_magic_scandesc(fd, ctx);\n\n\tclose(fd);\n\treturn ret;\n}\n\nint cli_scanmscab(cli_ctx *ctx, off_t sfx_offset)\n{\n\tstruct mscab_decompressor *cab_d;\n\tstruct mscabd_cabinet *cab_h;\n\tstruct mscabd_file *cab_f;\n\tint ret;\n\tint files;\n\tint virus_num = 0;\n\tstruct mspack_name mspack_fmap = {\n\t\t.fmap\t= *ctx->fmap,\n\t\t.org\t= sfx_offset,\n\t};\n\tstruct mspack_system_ex ops_ex;\n\tmemset(&ops_ex, 0, sizeof(struct mspack_system_ex));\n \tops_ex.ops = mspack_sys_fmap_ops;\n\n\tMSPACK_SYS_SELFTEST(ret);\n\tif (ret) {\n\t\tcli_dbgmsg(\"%s() failed at %d\\n\", __func__, __LINE__);\n\t\treturn CL_EUNPACK;\n\t}\n\n\tcab_d = mspack_create_cab_decompressor(&ops_ex.ops);\n\tif (!cab_d) {\n\t\tcli_dbgmsg(\"%s() failed at %d\\n\", __func__, __LINE__);\n\t\treturn CL_EUNPACK;\n\t}\n\n\tcab_h = cab_d->open(cab_d, (char *)&mspack_fmap);\n\tif (!cab_h) {\n\t\tret = CL_EFORMAT;\n\t\tcli_dbgmsg(\"%s() failed at %d\\n\", __func__, __LINE__);\n\t\tgoto out_dest;\n\t}\n\tfiles = 0;\n\tfor (cab_f = cab_h->files; cab_f; cab_f = cab_f->next) {\n\t\toff_t max_size;\n\t\tchar *tmp_fname;\n\n\t\tret = cli_matchmeta(ctx, cab_f->filename, 0, cab_f->length, 0,\n\t\t\t\tfiles, 0, NULL);\n\t\tif (ret) {\n\t\t\tif (ret == CL_VIRUS) {\n\t\t\t\tvirus_num++;\n\t\t\t\tif (!SCAN_ALL)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tgoto out_close;\n\t\t}\n\n\t\tif (ctx->engine->maxscansize) {\n\t\t\tif (ctx->scansize >= ctx->engine->maxscansize) {\n\t\t\t\tret = CL_CLEAN;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (ctx->engine->maxscansize &&\n\t\t\t\tctx->scansize + ctx->engine->maxfilesize >=\n\t\t\t\tctx->engine->maxscansize)\n\t\t\tmax_size = ctx->engine->maxscansize -\n\t\t\t\tctx->scansize;\n\t\telse\n\t\t\tmax_size = ctx->engine->maxfilesize ?\n\t\t\t\tctx->engine->maxfilesize :\n\t\t\t\t0xffffffff;\n\n\t\ttmp_fname = cli_gentemp(ctx->engine->tmpdir);\n\t\tif (!tmp_fname) {\n\t\t\tret = CL_EMEM;\n\t\t\tbreak;\n\t\t}\n\n\t\tops_ex.max_size = max_size;\n\t\t/* scan */\n\t\tret = cab_d->extract(cab_d, cab_f, tmp_fname);\n\t\tif (ret)\n\t\t\t/* Failed to extract. Try to scan what is there */\n\t\t\tcli_dbgmsg(\"%s() failed to extract %d\\n\", __func__, ret);\n\n\t\tret = cli_scanfile(tmp_fname, ctx);\n\t\tif (ret == CL_VIRUS)\n\t\t\tvirus_num++;\n\n\t\tif (!ctx->engine->keeptmp) {\n\t\t\tif (!access(tmp_fname, R_OK) && cli_unlink(tmp_fname)) {\n\t\t\t\tfree(tmp_fname);\n\t\t\t\tret = CL_EUNLINK;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfree(tmp_fname);\n\t\tfiles++;\n\t\tif (ret == CL_VIRUS && SCAN_ALL)\n\t\t\tcontinue;\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\nout_close:\n\tcab_d->close(cab_d, cab_h);\nout_dest:\n\tmspack_destroy_cab_decompressor(cab_d);\n\tif (virus_num)\n\t\treturn CL_VIRUS;\n\treturn ret;\n}\n\nint cli_scanmschm(cli_ctx *ctx)\n{\n\tstruct mschm_decompressor *mschm_d;\n\tstruct mschmd_header *mschm_h;\n\tstruct mschmd_file *mschm_f;\n\tint ret;\n\tint files;\n\tint virus_num = 0;\n\tstruct mspack_name mspack_fmap = {\n\t\t.fmap = *ctx->fmap,\n\t};\n\tstruct mspack_system_ex ops_ex;\n\tmemset(&ops_ex, 0, sizeof(struct mspack_system_ex));\n \tops_ex.ops = mspack_sys_fmap_ops;\n\n\tMSPACK_SYS_SELFTEST(ret);\n\tif (ret) {\n\t\tcli_dbgmsg(\"%s() failed at %d\\n\", __func__, __LINE__);\n\t\treturn CL_EUNPACK;\n\t}\n\n\tmschm_d = mspack_create_chm_decompressor(&ops_ex.ops);\n\tif (!mschm_d) {\n\t\tcli_dbgmsg(\"%s() failed at %d\\n\", __func__, __LINE__);\n\t\treturn CL_EUNPACK;\n\t}\n\n\tmschm_h = mschm_d->open(mschm_d, (char *)&mspack_fmap);\n\tif (!mschm_h) {\n\t\tret = CL_EFORMAT;\n\t\tcli_dbgmsg(\"%s() failed at %d\\n\", __func__, __LINE__);\n\t\tgoto out_dest;\n\t}\n\tfiles = 0;\n\tfor (mschm_f = mschm_h->files; mschm_f;\tmschm_f = mschm_f->next) {\n\t\toff_t max_size;\n\t\tchar *tmp_fname;\n\n\t\tret = cli_matchmeta(ctx, mschm_f->filename, 0, mschm_f->length,\n\t\t\t\t0, files, 0, NULL);\n\t\tif (ret) {\n\t\t\tif (ret == CL_VIRUS) {\n\t\t\t\tvirus_num++;\n\t\t\t\tif (!SCAN_ALL)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tgoto out_close;\n\t\t}\n\n\t\tif (ctx->engine->maxscansize) {\n\t\t\tif (ctx->scansize >= ctx->engine->maxscansize) {\n\t\t\t\tret = CL_CLEAN;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (ctx->engine->maxscansize &&\n\t\t\t\tctx->scansize + ctx->engine->maxfilesize >=\n\t\t\t\tctx->engine->maxscansize)\n\t\t\tmax_size = ctx->engine->maxscansize -\n\t\t\t\tctx->scansize;\n\t\telse\n\t\t\tmax_size = ctx->engine->maxfilesize ?\n\t\t\t\tctx->engine->maxfilesize :\n\t\t\t\t0xffffffff;\n\n\t\tops_ex.max_size = max_size;\n\n\t\ttmp_fname = cli_gentemp(ctx->engine->tmpdir);\n\t\tif (!tmp_fname) {\n\t\t\tret = CL_EMEM;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* scan */\n\t\tret = mschm_d->extract(mschm_d, mschm_f, tmp_fname);\n\t\tif (ret)\n\t\t\t/* Failed to extract. Try to scan what is there */\n\t\t\tcli_dbgmsg(\"%s() failed to extract %d\\n\", __func__, ret);\n\n\t\tret = cli_scanfile(tmp_fname, ctx);\n\t\tif (ret == CL_VIRUS)\n\t\t\tvirus_num++;\n\n\t\tif (!ctx->engine->keeptmp) {\n\t\t\tif (!access(tmp_fname, R_OK) && cli_unlink(tmp_fname)) {\n\t\t\t\tfree(tmp_fname);\n\t\t\t\tret = CL_EUNLINK;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfree(tmp_fname);\n\t\tfiles++;\n\t\tif (ret == CL_VIRUS && SCAN_ALL)\n\t\t\tcontinue;\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\nout_close:\n\tmschm_d->close(mschm_d, mschm_h);\nout_dest:\n\tmspack_destroy_chm_decompressor(mschm_d);\n\tif (virus_num)\n\t\treturn CL_VIRUS;\n\treturn ret;\n\n\treturn 0;\n}\n"], "filenames": ["libclamav/libmspack-0.5alpha/mspack/lzxd.c", "libclamav/libmspack.c"], "buggy_code_start_loc": [768, 267], "buggy_code_end_loc": [893, 268], "fixing_code_start_loc": [769, 267], "fixing_code_end_loc": [900, 272], "type": "CWE-119", "message": "mspack/lzxd.c in libmspack 0.5alpha, as used in ClamAV 0.99.2, allows remote attackers to cause a denial of service (heap-based buffer overflow and application crash) or possibly have unspecified other impact via a crafted CHM file.", "other": {"cve": {"id": "CVE-2017-6419", "sourceIdentifier": "cve@mitre.org", "published": "2017-08-07T03:29:00.277", "lastModified": "2018-10-21T10:29:09.893", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "mspack/lzxd.c in libmspack 0.5alpha, as used in ClamAV 0.99.2, allows remote attackers to cause a denial of service (heap-based buffer overflow and application crash) or possibly have unspecified other impact via a crafted CHM file."}, {"lang": "es", "value": "mspack/lzxd.c en libmspack 0.5alpha, como se utiliza en la versi\u00f3n 0.99.2 de ClamAV permite a atacantes remotos causar una denegaci\u00f3n de servicio (desbordamiento de b\u00fafer basado en memoria din\u00e1mica y ca\u00edda de la aplicaci\u00f3n) o posiblemente, tener otro impacto no especificado utilizando un archivo CHM manipulado."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:libmspack_project:libmspack:0.5:alpha:*:*:*:*:*:*", "matchCriteriaId": "986DA387-2AD7-4B4B-9153-FAAC30954623"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:a:clamav:clamav:0.99.2:*:*:*:*:*:*:*", "matchCriteriaId": "5643323C-F44D-4F04-A710-D25EA28D301F"}]}]}], "references": [{"url": "http://www.debian.org/security/2017/dsa-3946", "source": "cve@mitre.org"}, {"url": "https://bugzilla.clamav.net/show_bug.cgi?id=11701", "source": "cve@mitre.org", "tags": ["Issue Tracking"]}, {"url": "https://github.com/varsleak/varsleak-vul/blob/master/clamav-vul/heap-overflow/clamav_chm_crash.md", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/vrtadmin/clamav-devel/commit/a83773682e856ad6529ba6db8d1792e6d515d7f1", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2018/02/msg00014.html", "source": "cve@mitre.org"}, {"url": "https://security.gentoo.org/glsa/201804-16", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/vrtadmin/clamav-devel/commit/a83773682e856ad6529ba6db8d1792e6d515d7f1"}}