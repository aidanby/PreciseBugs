{"buggy_code": ["/* radare - LGPL - Copyright 2009-2018 - nibble, pancake */\n\n#include <assert.h>\n#include <stdio.h>\n#include <r_types.h>\n#include <r_util.h>\n#include <r_lib.h>\n#include <r_bin.h>\n#include <r_io.h>\n#include <r_cons.h>\n#include \"elf/elf.h\"\n\nstatic RBinInfo* info(RBinFile *bf);\n\n//TODO: implement r_bin_symbol_dup() and r_bin_symbol_free ?\n\nstatic int get_file_type(RBinFile *bf) {\n\tstruct Elf_(r_bin_elf_obj_t) *obj = bf->o->bin_obj;\n\tchar *type = Elf_(r_bin_elf_get_file_type (obj));\n\treturn type? ((!strncmp (type, \"CORE\", 4)) ? R_BIN_TYPE_CORE : R_BIN_TYPE_DEFAULT) : -1;\n}\n\nstatic RList *maps(RBinFile *bf) {\n\tif (bf && bf->o) {\n\t\treturn Elf_(r_bin_elf_get_maps)(bf->o->bin_obj);\n\t}\n\treturn NULL;\n}\n\nstatic char* regstate(RBinFile *bf) {\n\tstruct Elf_(r_bin_elf_obj_t) *obj = bf->o->bin_obj;\n\tif (obj->ehdr.e_machine != EM_AARCH64 &&\n\t\tobj->ehdr.e_machine != EM_ARM &&\n\t\tobj->ehdr.e_machine != EM_386 &&\n\t\tobj->ehdr.e_machine != EM_X86_64) {\n\t\teprintf (\"Cannot retrieve regstate on: %s (not yet supported)\\n\",\n\t\t\t\t\tElf_(r_bin_elf_get_machine_name)(obj));\n\t\treturn NULL;\n\t}\n\n\tint len = 0;\n\tut8 *regs = Elf_(r_bin_elf_grab_regstate) (obj, &len);\n\tchar *hexregs = (regs && len > 0) ? r_hex_bin2strdup (regs, len) : NULL;\n\n\tfree (regs);\n\treturn hexregs;\n}\n\nstatic void setsymord(ELFOBJ* eobj, ut32 ord, RBinSymbol *ptr) {\n\tif (!eobj->symbols_by_ord || ord >= eobj->symbols_by_ord_size) {\n\t\treturn;\n\t}\n\tfree (eobj->symbols_by_ord[ord]);\n\teobj->symbols_by_ord[ord] = r_mem_dup (ptr, sizeof (RBinSymbol));\n}\n\nstatic inline bool setimpord(ELFOBJ* eobj, ut32 ord, RBinImport *ptr) {\n\tif (!eobj->imports_by_ord || ord >= eobj->imports_by_ord_size) {\n\t\treturn false;\n\t}\n\tif (eobj->imports_by_ord[ord]) {\n\t\tfree (eobj->imports_by_ord[ord]->name);\n\t\tfree (eobj->imports_by_ord[ord]);\n\t}\n\teobj->imports_by_ord[ord] = r_mem_dup (ptr, sizeof (RBinImport));\n\teobj->imports_by_ord[ord]->name = strdup (ptr->name);\n\treturn true;\n}\n\nstatic Sdb* get_sdb(RBinFile *bf) {\n\tRBinObject *o = bf->o;\n\tif (o && o->bin_obj) {\n\t\tstruct Elf_(r_bin_elf_obj_t) *bin = (struct Elf_(r_bin_elf_obj_t) *) o->bin_obj;\n\t\treturn bin->kv;\n\t}\n\treturn NULL;\n}\n\nstatic void * load_buffer(RBinFile *bf, RBuffer *buf, ut64 loadaddr, Sdb *sdb) {\n\tstruct Elf_(r_bin_elf_obj_t) *res;\n\tif (!buf) {\n\t\treturn NULL;\n\t}\n\tres = Elf_(r_bin_elf_new_buf) (buf, bf->rbin->verbose);\n\tif (res) {\n\t\tsdb_ns_set (sdb, \"info\", res->kv);\n\t}\n\treturn res;\n}\n\nstatic void * load_bytes(RBinFile *bf, const ut8 *buf, ut64 sz, ut64 loadaddr, Sdb *sdb) {\n\tstruct Elf_(r_bin_elf_obj_t) *res;\n\tif (!buf || !sz || sz == UT64_MAX) {\n\t\treturn NULL;\n\t}\n\tRBuffer *tbuf = r_buf_new ();\n\t// NOOOEES must use io!\n\tr_buf_set_bytes (tbuf, buf, sz);\n\tres = Elf_(r_bin_elf_new_buf) (tbuf, bf->rbin->verbose);\n\tif (res) {\n\t\tsdb_ns_set (sdb, \"info\", res->kv);\n\t}\n\tr_buf_free (tbuf);\n\treturn res;\n}\n\nstatic bool load(RBinFile *bf) {\n\tconst ut8 *bytes = bf ? r_buf_buffer (bf->buf) : NULL;\n\tut64 sz = bf ? r_buf_size (bf->buf): 0;\n\tif (!bf || !bf->o) {\n\t\treturn false;\n\t}\n\tbf->o->bin_obj = load_bytes (bf, bytes, sz, bf->o->loadaddr, bf->sdb);\n\treturn bf->o->bin_obj != NULL;\n}\n\nstatic int destroy(RBinFile *bf) {\n\tint i;\n\tELFOBJ* eobj = bf->o->bin_obj;\n\tif (eobj && eobj->imports_by_ord) {\n\t\tfor (i = 0; i < eobj->imports_by_ord_size; i++) {\n\t\t\tRBinImport *imp = eobj->imports_by_ord[i];\n\t\t\tif (imp) {\n\t\t\t\tfree (imp->name);\n\t\t\t\tfree (imp);\n\t\t\t\teobj->imports_by_ord[i] = NULL;\n\t\t\t}\n\t\t}\n\t\tR_FREE (eobj->imports_by_ord);\n\t}\n\tElf_(r_bin_elf_free) ((struct Elf_(r_bin_elf_obj_t)*)bf->o->bin_obj);\n\treturn true;\n}\n\nstatic ut64 baddr(RBinFile *bf) {\n\treturn Elf_(r_bin_elf_get_baddr) (bf->o->bin_obj);\n}\n\nstatic ut64 boffset(RBinFile *bf) {\n\treturn Elf_(r_bin_elf_get_boffset) (bf->o->bin_obj);\n}\n\nstatic RBinAddr* binsym(RBinFile *bf, int sym) {\n\tstruct Elf_(r_bin_elf_obj_t)* obj = bf->o->bin_obj;\n\tRBinAddr *ret = NULL;\n\tut64 addr = 0LL;\n\n\tswitch (sym) {\n\tcase R_BIN_SYM_ENTRY:\n\t\taddr = Elf_(r_bin_elf_get_entry_offset) (bf->o->bin_obj);\n\t\tbreak;\n\tcase R_BIN_SYM_MAIN:\n\t\taddr = Elf_(r_bin_elf_get_main_offset) (bf->o->bin_obj);\n\t\tbreak;\n\tcase R_BIN_SYM_INIT:\n\t\taddr = Elf_(r_bin_elf_get_init_offset) (bf->o->bin_obj);\n\t\tbreak;\n\tcase R_BIN_SYM_FINI:\n\t\taddr = Elf_(r_bin_elf_get_fini_offset) (bf->o->bin_obj);\n\t\tbreak;\n\t}\n\tif (addr && addr != UT64_MAX && (ret = R_NEW0 (RBinAddr))) {\n\t\tstruct Elf_(r_bin_elf_obj_t) *bin = bf->o->bin_obj;\n\t\tbool is_arm = bin->ehdr.e_machine == EM_ARM;\n\t\tret->paddr = addr;\n\t\tret->vaddr = Elf_(r_bin_elf_p2v) (obj, addr);\n\t\tif (is_arm && addr & 1) {\n\t\t\tret->bits = 16;\n\t\t\tret->vaddr--; \n\t\t\tret->paddr--; \n\t\t}\n\t}\n\treturn ret;\n}\n\nstatic RList* sections(RBinFile *bf) {\n\tstruct Elf_(r_bin_elf_obj_t)* obj = (bf && bf->o)? bf->o->bin_obj : NULL;\n\tstruct r_bin_elf_section_t *section = NULL;\n\tint i, num, found_load = 0;\n\tElf_(Phdr)* phdr = NULL;\n\tRBinSection *ptr = NULL;\n\tRList *ret = NULL;\n\n\tif (!obj || !(ret = r_list_newf (free))) {\n\t\treturn NULL;\n\t}\n\t//there is not leak in section since they are cached by elf.c\n\t//and freed within Elf_(r_bin_elf_free)\n\tif ((section = Elf_(r_bin_elf_get_sections) (obj))) {\n\t\tfor (i = 0; !section[i].last; i++) {\n\t\t\tif (!(ptr = R_NEW0 (RBinSection))) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstrncpy (ptr->name, (char*)section[i].name, R_BIN_SIZEOF_STRINGS);\n\t\t\tif (strstr (ptr->name, \"data\") && !strstr (ptr->name, \"rel\")) {\n\t\t\t\tptr->is_data = true;\n\t\t\t}\n\t\t\tptr->size = section[i].type != SHT_NOBITS ? section[i].size : 0;\n\t\t\tptr->vsize = section[i].size;\n\t\t\tptr->paddr = section[i].offset;\n\t\t\tptr->vaddr = section[i].rva;\n\t\t\tptr->add = !obj->phdr; // Load sections if there is no PHDR\n\t\t\tptr->srwx = 0;\n\t\t\tif (R_BIN_ELF_SCN_IS_EXECUTABLE (section[i].flags)) {\n\t\t\t\tptr->srwx |= R_BIN_SCN_EXECUTABLE;\n\t\t\t}\n\t\t\tif (R_BIN_ELF_SCN_IS_WRITABLE (section[i].flags)) {\n\t\t\t\tptr->srwx |= R_BIN_SCN_WRITABLE;\n\t\t\t}\n\t\t\tif (R_BIN_ELF_SCN_IS_READABLE (section[i].flags)) {\n\t\t\t\tptr->srwx |= R_BIN_SCN_READABLE;\n\t\t\t}\n\t\t\tr_list_append (ret, ptr);\n\t\t}\n\t}\n\n\t// program headers is another section\n\tnum = obj->ehdr.e_phnum;\n\tphdr = obj->phdr;\n\tif (phdr) {\n\t\tint n = 0;\n\t\tfor (i = 0; i < num; i++) {\n\t\t\tif (!(ptr = R_NEW0 (RBinSection))) {\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tptr->add = false;\n\t\t\tptr->size = phdr[i].p_filesz;\n\t\t\tptr->vsize = phdr[i].p_memsz;\n\t\t\tptr->paddr = phdr[i].p_offset;\n\t\t\tptr->vaddr = phdr[i].p_vaddr;\n\t\t\tptr->srwx = phdr[i].p_flags;\n\t\t\tswitch (phdr[i].p_type) {\n\t\t\tcase PT_DYNAMIC:\n\t\t\t\tstrncpy (ptr->name, \"DYNAMIC\", R_BIN_SIZEOF_STRINGS);\n\t\t\t\tbreak;\n\t\t\tcase PT_LOAD:\n\t\t\t\tsnprintf (ptr->name, R_BIN_SIZEOF_STRINGS, \"LOAD%d\", n++);\n\t\t\t\tfound_load = 1;\n\t\t\t\tptr->add = true;\n\t\t\t\tbreak;\n\t\t\tcase PT_INTERP:\n\t\t\t\tstrncpy (ptr->name, \"INTERP\", R_BIN_SIZEOF_STRINGS);\n\t\t\t\tbreak;\n\t\t\tcase PT_GNU_STACK:\n\t\t\t\tstrncpy (ptr->name, \"GNU_STACK\", R_BIN_SIZEOF_STRINGS);\n\t\t\t\tbreak;\n\t\t\tcase PT_GNU_RELRO:\n\t\t\t\tstrncpy (ptr->name, \"GNU_RELRO\", R_BIN_SIZEOF_STRINGS);\n\t\t\t\tbreak;\n\t\t\tcase PT_GNU_EH_FRAME:\n\t\t\t\tstrncpy (ptr->name, \"GNU_EH_FRAME\", R_BIN_SIZEOF_STRINGS);\n\t\t\t\tbreak;\n\t\t\tcase PT_PHDR:\n\t\t\t\tstrncpy (ptr->name, \"PHDR\", R_BIN_SIZEOF_STRINGS);\n\t\t\t\tbreak;\n\t\t\tcase PT_TLS:\n\t\t\t\tstrncpy (ptr->name, \"TLS\", R_BIN_SIZEOF_STRINGS);\n\t\t\t\tbreak;\n\t\t\tcase PT_NOTE:\n\t\t\t\tstrncpy (ptr->name, \"NOTE\", R_BIN_SIZEOF_STRINGS);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tstrncpy (ptr->name, \"UNKNOWN\", R_BIN_SIZEOF_STRINGS);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tptr->name[R_BIN_SIZEOF_STRINGS - 1] = '\\0';\n\t\t\tr_list_append (ret, ptr);\n\t\t}\n\t}\n\n\tif (r_list_empty (ret)) {\n\t\tif (!bf->size) {\n\t\t\tstruct Elf_(r_bin_elf_obj_t) *bin = bf->o->bin_obj;\n\t\t\tbf->size = bin? bin->size: 0x9999;\n\t\t}\n\t\tif (found_load == 0) {\n\t\t\tif (!(ptr = R_NEW0 (RBinSection))) {\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tsprintf (ptr->name, \"uphdr\");\n\t\t\tptr->size = bf->size;\n\t\t\tptr->vsize = bf->size;\n\t\t\tptr->paddr = 0;\n\t\t\tptr->vaddr = 0x10000;\n\t\t\tptr->add = true;\n\t\t\tptr->srwx = R_BIN_SCN_READABLE | R_BIN_SCN_WRITABLE |\n\t\t\t\tR_BIN_SCN_EXECUTABLE;\n\t\t\tr_list_append (ret, ptr);\n\t\t}\n\t}\n\t// add entry for ehdr\n\tptr = R_NEW0 (RBinSection);\n\tif (ptr) {\n\t\tut64 ehdr_size = sizeof (obj->ehdr);\n\t\tif (bf->size < ehdr_size) {\n\t\t\tehdr_size = bf->size;\n\t\t}\n\t\tsprintf (ptr->name, \"ehdr\");\n\t\tptr->paddr = 0;\n\t\tptr->vaddr = obj->baddr;\n\t\tptr->size = ehdr_size;\n\t\tptr->vsize = ehdr_size;\n\t\tptr->add = false;\n\t\tif (obj->ehdr.e_type == ET_REL) {\n\t\t\tptr->add = true;\n\t\t}\n\t\tptr->srwx = R_BIN_SCN_READABLE | R_BIN_SCN_WRITABLE;\n\t\tr_list_append (ret, ptr);\n\t}\n\treturn ret;\n}\n\nstatic RBinAddr* newEntry(ut64 haddr, ut64 paddr, int type, int bits) {\n\tRBinAddr *ptr = R_NEW0 (RBinAddr);\n\tif (ptr) {\n\t\tptr->paddr = paddr;\n\t\tptr->vaddr = paddr;\n\t\tptr->haddr = haddr;\n\t\tptr->bits = bits;\n\t\tptr->type = type;\n\t\t//realign due to thumb\n\t\tif (bits == 16 && ptr->vaddr & 1) {\n\t\t\tptr->paddr--;\n\t\t\tptr->vaddr--;\n\t\t}\n\t}\n\treturn ptr;\n}\n\nstatic void process_constructors (RBinFile *bf, RList *ret, int bits) {\n\tRList *secs = sections (bf);\n\tRListIter *iter;\n\tRBinSection *sec;\n\tint i, type;\n\tr_list_foreach (secs, iter, sec) {\n\t\ttype = -1;\n\t\tif (!strcmp (sec->name, \".fini_array\")) {\n\t\t\ttype = R_BIN_ENTRY_TYPE_FINI;\n\t\t} else if (!strcmp (sec->name, \".init_array\")) {\n\t\t\ttype = R_BIN_ENTRY_TYPE_INIT;\n\t\t} else if (!strcmp (sec->name, \".preinit_array\")) {\n\t\t\ttype = R_BIN_ENTRY_TYPE_PREINIT;\n\t\t}\n\t\tif (type != -1) {\n\t\t\tut8 *buf = calloc (sec->size, 1);\n\t\t\tif (!buf) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t(void)r_buf_read_at (bf->buf, sec->paddr, buf, sec->size);\n\t\t\tif (bits == 32) {\n\t\t\t\tfor (i = 0; i < sec->size; i += 4) {\n\t\t\t\t\tut32 addr32 = r_read_le32 (buf + i);\n\t\t\t\t\tif (addr32) {\n\t\t\t\t\t\tRBinAddr *ba = newEntry (sec->paddr + i, (ut64)addr32, type, bits);\n\t\t\t\t\t\tr_list_append (ret, ba);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (i = 0; i < sec->size; i += 8) {\n\t\t\t\t\tut64 addr64 = r_read_le64 (buf + i);\n\t\t\t\t\tif (addr64) {\n\t\t\t\t\t\tRBinAddr *ba = newEntry (sec->paddr + i, addr64, type, bits);\n\t\t\t\t\t\tr_list_append (ret, ba);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfree (buf);\n\t\t}\n\t}\n\tr_list_free (secs);\n}\n\nstatic RList* entries(RBinFile *bf) {\n\tstruct Elf_(r_bin_elf_obj_t)* obj;\n\tRBinAddr *ptr = NULL;\n\tstruct r_bin_elf_symbol_t *symbol;\n\tRList *ret;\n\tint i;\n\n\tif (!bf || !bf->o || !bf->o->bin_obj) {\n\t\treturn NULL;\n\t}\n\tobj = bf->o->bin_obj;\n\tif (!(ret = r_list_newf ((RListFree)free))) {\n\t\treturn NULL;\n\t}\n\tif (!(ptr = R_NEW0 (RBinAddr))) {\n\t\treturn ret;\n\t}\n\tptr->paddr = Elf_(r_bin_elf_get_entry_offset) (obj);\n\tptr->vaddr = Elf_(r_bin_elf_p2v) (obj, ptr->paddr);\n\tptr->haddr = 0x18;\n\n\tif (obj->ehdr.e_machine == EM_ARM) {\n\t\tint bin_bits = Elf_(r_bin_elf_get_bits) (obj);\n\t\tif (bin_bits != 64) {\n\t\t\tptr->bits = 32;\n\t\t\tif (ptr->vaddr & 1) {\n\t\t\t\tptr->vaddr--;\n\t\t\t\tptr->bits = 16;\n\t\t\t}\n\t\t\tif (ptr->paddr & 1) {\n\t\t\t\tptr->paddr--;\n\t\t\t\tptr->bits = 16;\n\t\t\t}\n\t\t}\n\t}\n\tr_list_append (ret, ptr);\n\n\t// add entrypoint for jni libraries\n\t// NOTE: this is slow, we shouldnt find for java constructors here\n\tif (!(symbol = Elf_(r_bin_elf_get_symbols) (obj))) {\n\t\treturn ret;\n\t}\n\tfor (i = 0; !symbol[i].last; i++) {\n\t\tif (!strncmp (symbol[i].name, \"Java\", 4)) {\n\t\t\tif (r_str_endswith (symbol[i].name, \"_init\")) {\n\t\t\t\tif (!(ptr = R_NEW0 (RBinAddr))) {\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t\tptr->paddr = symbol[i].offset;\n\t\t\t\tptr->vaddr = Elf_(r_bin_elf_p2v) (obj, ptr->paddr);\n\t\t\t\tptr->haddr = UT64_MAX;\n\t\t\t\tptr->type = R_BIN_ENTRY_TYPE_INIT;\n\t\t\t\tr_list_append (ret, ptr);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tint bin_bits = Elf_(r_bin_elf_get_bits) (bf->o->bin_obj);\n\tprocess_constructors (bf, ret, bin_bits < 32 ? 32: bin_bits);\n\treturn ret;\n}\n\nstatic void _set_arm_thumb_bits(struct Elf_(r_bin_elf_obj_t) *bin, RBinSymbol **sym) {\n\tint bin_bits = Elf_(r_bin_elf_get_bits) (bin);\n\tRBinSymbol *ptr = *sym;\n\tint len = strlen (ptr->name);\n\tif (ptr->name[0] == '$' && (len >= 2 && !ptr->name[2])) {\n\t\tswitch (ptr->name[1]) {\n\t\tcase 'a' : //arm\n\t\t\tptr->bits = 32;\n\t\t\tbreak;\n\t\tcase 't': //thumb\n\t\t\tptr->bits = 16;\n\t\t\tif (ptr->vaddr & 1) {\n\t\t\t\tptr->vaddr--;\n\t\t\t}\n\t\t\tif (ptr->paddr & 1) {\n\t\t\t\tptr->paddr--;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'd': //data\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto arm_symbol;\n\t\t}\n\t} else {\narm_symbol:\n\t\tptr->bits = bin_bits;\n\t\tif (bin_bits != 64) {\n\t\t\tptr->bits = 32;\n\t\t\tif (ptr->vaddr & 1) {\n\t\t\t\tptr->vaddr--;\n\t\t\t\tptr->bits = 16;\n\t\t\t}\n\t\t\tif (ptr->paddr & 1) {\n\t\t\t\tptr->paddr--;\n\t\t\t\tptr->bits = 16;\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic RList* symbols(RBinFile *bf) {\n\tstruct Elf_(r_bin_elf_obj_t) *bin;\n\tstruct r_bin_elf_symbol_t *symbol = NULL;\n\tRBinSymbol *ptr = NULL;\n\tRList *ret = NULL;\n\tint i;\n\n\tif (!bf|| !bf->o || !bf->o->bin_obj) {\n\t\treturn NULL;\n\t}\n\n\tbin = bf->o->bin_obj;\n\tret = r_list_newf (free);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tif (!(symbol = Elf_(r_bin_elf_get_symbols) (bin))) {\n\t\treturn ret;\n\t}\n\tfor (i = 0; !symbol[i].last; i++) {\n\t\tut64 paddr = symbol[i].offset;\n\t\tut64 vaddr = Elf_(r_bin_elf_p2v) (bin, paddr);\n\t\tif (!(ptr = R_NEW0 (RBinSymbol))) {\n\t\t\tbreak;\n\t\t}\n\t\tptr->name = strdup (symbol[i].name);\n\t\tptr->forwarder = r_str_const (\"NONE\");\n\t\tptr->bind = r_str_const (symbol[i].bind);\n\t\tptr->type = r_str_const (symbol[i].type);\n\t\tptr->paddr = paddr;\n\t\tptr->vaddr = vaddr;\n\t\tptr->size = symbol[i].size;\n\t\tptr->ordinal = symbol[i].ordinal;\n\t\tsetsymord (bin, ptr->ordinal, ptr);\n\t\tif (bin->ehdr.e_machine == EM_ARM && *ptr->name) {\n\t\t\t_set_arm_thumb_bits (bin, &ptr);\n\t\t}\n\t\tr_list_append (ret, ptr);\n\t}\n\tif (!(symbol = Elf_(r_bin_elf_get_imports) (bin))) {\n\t\treturn ret;\n\t}\n\tfor (i = 0; !symbol[i].last; i++) {\n\t\tut64 paddr = symbol[i].offset;\n\t\tut64 vaddr = Elf_(r_bin_elf_p2v) (bin, paddr);\n\t\tif (!symbol[i].size) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (!(ptr = R_NEW0 (RBinSymbol))) {\n\t\t\tbreak;\n\t\t}\n\t\t// TODO(eddyb) make a better distinction between imports and other symbols.\n\t\t//snprintf (ptr->name, R_BIN_SIZEOF_STRINGS-1, \"imp.%s\", symbol[i].name);\n\t\tptr->name = r_str_newf (\"imp.%s\", symbol[i].name);\n\t\tptr->forwarder = r_str_const (\"NONE\");\n\t\t//strncpy (ptr->forwarder, \"NONE\", R_BIN_SIZEOF_STRINGS);\n\t\tptr->bind = r_str_const (symbol[i].bind);\n\t\tptr->type = r_str_const (symbol[i].type);\n\t\tptr->paddr = paddr;\n\t\tptr->vaddr = vaddr;\n\t\t//special case where there is not entry in the plt for the import\n\t\tif (ptr->vaddr == UT32_MAX) {\n\t\t\tptr->paddr = 0;\n\t\t\tptr->vaddr = 0;\n\t\t}\n\t\tptr->size = symbol[i].size;\n\t\tptr->ordinal = symbol[i].ordinal;\n\t\tsetsymord (bin, ptr->ordinal, ptr);\n\t\t/* detect thumb */\n\t\tif (bin->ehdr.e_machine == EM_ARM) {\n\t\t\t_set_arm_thumb_bits (bin, &ptr);\n\t\t}\n\t\tr_list_append (ret, ptr);\n\t}\n\treturn ret;\n}\n\nstatic RList* imports(RBinFile *bf) {\n\tstruct Elf_(r_bin_elf_obj_t) *bin = NULL;\n\tRBinElfSymbol *import = NULL;\n\tRBinImport *ptr = NULL;\n\tRList *ret = NULL;\n\tint i;\n\n\tif (!bf || !bf->o || !bf->o->bin_obj) {\n\t\treturn NULL;\n\t}\n\tbin = bf->o->bin_obj;\n\tif (!(ret = r_list_newf (r_bin_import_free))) {\n\t\treturn NULL;\n\t}\n\tif (!(import = Elf_(r_bin_elf_get_imports) (bin))) {\n\t\tr_list_free (ret);\n\t\treturn NULL;\n\t}\n\tfor (i = 0; !import[i].last; i++) {\n\t\tif (!(ptr = R_NEW0 (RBinImport))) {\n\t\t\tbreak;\n\t\t}\n\t\tptr->name = strdup (import[i].name);\n\t\tptr->bind = r_str_const (import[i].bind);\n\t\tptr->type = r_str_const (import[i].type);\n\t\tptr->ordinal = import[i].ordinal;\n\t\t(void)setimpord (bin, ptr->ordinal, ptr);\n\t\tr_list_append (ret, ptr);\n\t}\n\treturn ret;\n}\n\nstatic RList* libs(RBinFile *bf) {\n\tstruct r_bin_elf_lib_t *libs = NULL;\n\tRList *ret = NULL;\n\tchar *ptr = NULL;\n\tint i;\n\n\tif (!bf || !bf->o || !bf->o->bin_obj) {\n\t\treturn NULL;\n\t}\n\tif (!(ret = r_list_newf (free))) {\n\t\treturn NULL;\n\t}\n\tif (!(libs = Elf_(r_bin_elf_get_libs) (bf->o->bin_obj))) {\n\t\treturn ret;\n\t}\n\tfor (i = 0; !libs[i].last; i++) {\n\t\tptr = strdup (libs[i].name);\n\t\tr_list_append (ret, ptr);\n\t}\n\tfree (libs);\n\treturn ret;\n}\n\nstatic RBinReloc *reloc_convert(struct Elf_(r_bin_elf_obj_t) *bin, RBinElfReloc *rel, ut64 GOT) {\n\tRBinReloc *r = NULL;\n\tut64 B, P;\n\n\tif (!bin || !rel) {\n\t\treturn NULL;\n\t}\n\tB = bin->baddr;\n\tP = rel->rva; // rva has taken baddr into account\n\tif (!(r = R_NEW0 (RBinReloc))) {\n\t\treturn r;\n\t}\n\tr->import = NULL;\n\tr->symbol = NULL;\n\tr->is_ifunc = false;\n\tr->addend = rel->addend;\n\tif (rel->sym) {\n\t\tif (rel->sym < bin->imports_by_ord_size && bin->imports_by_ord[rel->sym]) {\n\t\t\tr->import = bin->imports_by_ord[rel->sym];\n\t\t} else if (rel->sym < bin->symbols_by_ord_size && bin->symbols_by_ord[rel->sym]) {\n\t\t\tr->symbol = bin->symbols_by_ord[rel->sym];\n\t\t}\n\t}\n\tr->vaddr = rel->rva;\n\tr->paddr = rel->offset;\n\n\t#define SET(T) r->type = R_BIN_RELOC_ ## T; r->additive = 0; return r\n\t#define ADD(T, A) r->type = R_BIN_RELOC_ ## T; r->addend += A; r->additive = !rel->is_rela; return r\n\n\tswitch (bin->ehdr.e_machine) {\n\tcase EM_386: switch (rel->type) {\n\t\tcase R_386_NONE:     break; // malloc then free. meh. then again, there's no real world use for _NONE.\n\t\tcase R_386_32:       ADD(32, 0);\n\t\tcase R_386_PC32:     ADD(32,-P);\n\t\tcase R_386_GLOB_DAT: SET(32);\n\t\tcase R_386_JMP_SLOT: SET(32);\n\t\tcase R_386_RELATIVE: ADD(32, B);\n\t\tcase R_386_GOTOFF:   ADD(32,-GOT);\n\t\tcase R_386_GOTPC:    ADD(32, GOT-P);\n\t\tcase R_386_16:       ADD(16, 0);\n\t\tcase R_386_PC16:     ADD(16,-P);\n\t\tcase R_386_8:        ADD(8,  0);\n\t\tcase R_386_PC8:      ADD(8, -P);\n\t\tcase R_386_COPY:     ADD(64, 0); // XXX: copy symbol at runtime\n\t\tcase R_386_IRELATIVE: r->is_ifunc = true; SET(32);\n\t\tdefault: break; //eprintf(\"TODO(eddyb): uninmplemented ELF/x86 reloc type %i\\n\", rel->type);\n\t\t}\n\t\tbreak;\n\tcase EM_X86_64: switch (rel->type) {\n\t\tcase R_X86_64_NONE:\tbreak; // malloc then free. meh. then again, there's no real world use for _NONE.\n\t\tcase R_X86_64_64:\tADD(64, 0);\n\t\tcase R_X86_64_PLT32:\tADD(32,-P /* +L */);\n\t\tcase R_X86_64_GOT32:\tADD(32, GOT);\n\t\tcase R_X86_64_PC32:\tADD(32,-P);\n\t\tcase R_X86_64_GLOB_DAT: r->vaddr -= rel->sto; SET(64);\n\t\tcase R_X86_64_JUMP_SLOT: r->vaddr -= rel->sto; SET(64);\n\t\tcase R_X86_64_RELATIVE:\tADD(64, B);\n\t\tcase R_X86_64_32:\tADD(32, 0);\n\t\tcase R_X86_64_32S:\tADD(32, 0);\n\t\tcase R_X86_64_16:\tADD(16, 0);\n\t\tcase R_X86_64_PC16:\tADD(16,-P);\n\t\tcase R_X86_64_8:\tADD(8,  0);\n\t\tcase R_X86_64_PC8:\tADD(8, -P);\n\t\tcase R_X86_64_GOTPCREL:\tADD(64, GOT-P);\n\t\tcase R_X86_64_COPY:\tADD(64, 0); // XXX: copy symbol at runtime\n\t\tcase R_X86_64_IRELATIVE: r->is_ifunc = true; SET(64);\n\t\tdefault: break; ////eprintf(\"TODO(eddyb): uninmplemented ELF/x64 reloc type %i\\n\", rel->type);\n\t\t}\n\t\tbreak;\n\tcase EM_ARM: switch (rel->type) {\n\t\tcase R_ARM_NONE:\tbreak; // malloc then free. meh. then again, there's no real world use for _NONE.\n\t\tcase R_ARM_ABS32:\tADD(32, 0);\n\t\tcase R_ARM_REL32:\tADD(32,-P);\n\t\tcase R_ARM_ABS16:\tADD(16, 0);\n\t\tcase R_ARM_ABS8:\tADD(8,  0);\n\t\tcase R_ARM_SBREL32:\tADD(32, -B);\n\t\tcase R_ARM_GLOB_DAT:\tADD(32, 0);\n\t\tcase R_ARM_JUMP_SLOT:\tADD(32, 0);\n\t\tcase R_ARM_RELATIVE:\tADD(32, B);\n\t\tcase R_ARM_GOTOFF:\tADD(32,-GOT);\n\t\tdefault: ADD(32,GOT); break; // reg relocations\n\t\t ////eprintf(\"TODO(eddyb): uninmplemented ELF/ARM reloc type %i\\n\", rel->type);\n\t\t}\n\t\tbreak;\n\tdefault: break;\n\t}\n\n\t#undef SET\n\t#undef ADD\n\n\tfree(r);\n\treturn 0;\n}\n\nstatic RList* relocs(RBinFile *bf) {\n\tRList *ret = NULL;\n\tRBinReloc *ptr = NULL;\n\tRBinElfReloc *relocs = NULL;\n\tstruct Elf_(r_bin_elf_obj_t) *bin = NULL;\n\tut64 got_addr;\n\tint i;\n\tif (!bf || !bf->o || !bf->o->bin_obj) {\n\t\treturn NULL;\n\t}\n\tbin = bf->o->bin_obj;\n\tif (!(ret = r_list_newf (free))) {\n\t\treturn NULL;\n\t}\n\t/* FIXME: This is a _temporary_ fix/workaround to prevent a use-after-\n\t * free detected by ASan that would corrupt the relocation names */\n\tr_list_free (imports (bf));\n\tif ((got_addr = Elf_(r_bin_elf_get_section_addr) (bin, \".got\")) == -1) {\n\t\tgot_addr = Elf_(r_bin_elf_get_section_addr) (bin, \".got.plt\");\n\t\tif (got_addr == -1) {\n\t\t\tgot_addr = 0;\n\t\t}\n\t}\n\tif (got_addr < 1 && bin->ehdr.e_type == ET_REL) {\n\t\tgot_addr = Elf_(r_bin_elf_get_section_addr) (bin, \".got.r2\");\n\t\tif (got_addr == -1) {\n\t\t\tgot_addr = 0;\n\t\t}\n\t}\n\tif (bf->o) {\n\t\tif (!(relocs = Elf_(r_bin_elf_get_relocs) (bin))) {\n\t\t\treturn ret;\n\t\t}\n\t\tfor (i = 0; !relocs[i].last; i++) {\n\t\t\tif (!(ptr = reloc_convert (bin, &relocs[i], got_addr))) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tr_list_append (ret, ptr);\n\t\t}\n\t\tfree (relocs);\n\t}\n\treturn ret;\n}\n\nstatic void _patch_reloc (ut16 e_machine, RIOBind *iob, RBinElfReloc *rel, ut64 S, ut64 B, ut64 L) {\n\tut64 val;\n\tut64 A = rel->addend, P = rel->rva;\n\tut8 buf[8];\n\tswitch (e_machine) {\n\tcase EM_PPC64: {\n\t\tint low = 0, word = 0;\n\t\tswitch (rel->type) {\n\t\tcase R_PPC64_REL16_HA:\n\t\t\tword = 2;\n\t\t\tval = (S + A - P + 0x8000) >> 16;\n\t\t\tbreak;\n\t\tcase R_PPC64_REL16_LO:\n\t\t\tword = 2;\n\t\t\tval = (S + A - P) & 0xffff;\n\t\t\tbreak;\n\t\tcase R_PPC64_REL14:\n\t\t\tlow = 14;\n\t\t\tval = (st64)(S + A - P) >> 2;\n\t\t\tbreak;\n\t\tcase R_PPC64_REL24:\n\t\t\tlow = 24;\n\t\t\tval = (st64)(S + A - P) >> 2;\n\t\t\tbreak;\n\t\tcase R_PPC64_REL32:\n\t\t\tword = 4;\n\t\t\tval = S + A - P;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tif (low) {\n\t\t\t// TODO big-endian\n\t\t\tswitch (low) {\n\t\t\tcase 14:\n\t\t\t\tval &= (1 << 14) - 1;\n\t\t\t\tiob->read_at (iob->io, rel->rva, buf, 2);\n\t\t\t\tr_write_le32 (buf, (r_read_le32 (buf) & ~((1<<16) - (1<<2))) | val << 2);\n\t\t\t\tiob->write_at (iob->io, rel->rva, buf, 2);\n\t\t\t\tbreak;\n\t\t\tcase 24:\n\t\t\t\tval &= (1 << 24) - 1;\n\t\t\t\tiob->read_at (iob->io, rel->rva, buf, 4);\n\t\t\t\tr_write_le32 (buf, (r_read_le32 (buf) & ~((1<<26) - (1<<2))) | val << 2);\n\t\t\t\tiob->write_at (iob->io, rel->rva, buf, 4);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (word) {\n\t\t\t// TODO big-endian\n\t\t\tswitch (word) {\n\t\t\tcase 2:\n\t\t\t\tr_write_le16 (buf, val);\n\t\t\t\tiob->write_at (iob->io, rel->rva, buf, 2);\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tr_write_le32 (buf, val);\n\t\t\t\tiob->write_at (iob->io, rel->rva, buf, 4);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\tcase EM_X86_64: {\n\t\tint word = 0;\n\t\tswitch (rel->type) {\n\t\tcase R_X86_64_8:\n\t\t\tword = 1;\n\t\t\tval = S + A;\n\t\t\tbreak;\n\t\tcase R_X86_64_16:\n\t\t\tword = 2;\n\t\t\tval = S + A;\n\t\t\tbreak;\n\t\tcase R_X86_64_32:\n\t\tcase R_X86_64_32S:\n\t\t\tword = 4;\n\t\t\tval = S + A;\n\t\t\tbreak;\n\t\tcase R_X86_64_64:\n\t\t\tword = 8;\n\t\t\tval = S + A;\n\t\t\tbreak;\n\t\tcase R_X86_64_GLOB_DAT:\n\t\tcase R_X86_64_JUMP_SLOT:\n\t\t\tword = 4;\n\t\t\tval = S;\n\t\t\tbreak;\n\t\tcase R_X86_64_PC8:\n\t\t\tword = 1;\n\t\t\tval = S + A - P;\n\t\t\tbreak;\n\t\tcase R_X86_64_PC16:\n\t\t\tword = 2;\n\t\t\tval = S + A - P;\n\t\t\tbreak;\n\t\tcase R_X86_64_PC32:\n\t\t\tword = 4;\n\t\t\tval = S + A - P;\n\t\t\tbreak;\n\t\tcase R_X86_64_PC64:\n\t\t\tword = 8;\n\t\t\tval = S + A - P;\n\t\t\tbreak;\n\t\tcase R_X86_64_PLT32:\n\t\t\tword = 4;\n\t\t\tval = L + A - P;\n\t\t\tbreak;\n\t\tcase R_X86_64_RELATIVE:\n\t\t\tword = 8;\n\t\t\tval = B + A;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t//eprintf (\"relocation %d not handle at this time\\n\", rel->type);\n\t\t\tbreak;\n\t\t}\n\t\tswitch (word) {\n\t\tcase 0:\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tbuf[0] = val;\n\t\t\tiob->write_at (iob->io, rel->rva, buf, 1);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tr_write_le16 (buf, val);\n\t\t\tiob->write_at (iob->io, rel->rva, buf, 2);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tr_write_le32 (buf, val);\n\t\t\tiob->write_at (iob->io, rel->rva, buf, 4);\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tr_write_le64 (buf, val);\n\t\t\tiob->write_at (iob->io, rel->rva, buf, 8);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n\t}\n}\n\nstatic bool ht_insert_intu64(SdbHash* ht, int key, ut64 value) {\n\tut64 *mvalue = malloc (sizeof (ut64));\n\tif (!mvalue) {\n\t\treturn false;\n\t}\n\t*mvalue = value;\n\treturn ht_insert (ht, sdb_fmt (\"%d\", key), (void *)mvalue);\n}\n\nstatic ut64 ht_find_intu64(SdbHash* ht, int key, bool* found) {\n\tut64 *mvalue = (ut64 *)ht_find (ht, sdb_fmt (\"%d\", key), found);\n\treturn *mvalue;\n}\n\nstatic void relocs_by_sym_free(HtKv *kv) {\n\tfree (kv->key);\n\tfree (kv->value);\n}\n\nstatic RList* patch_relocs(RBin *b) {\n\tRList *ret = NULL;\n\tRBinReloc *ptr = NULL;\n\tRIO *io = NULL;\n\tRBinObject *obj = NULL;\n\tstruct Elf_(r_bin_elf_obj_t) *bin = NULL;\n\tRIOSection *g = NULL, *s = NULL;\n\tSdbHash *relocs_by_sym;\n\tSdbListIter *iter;\n\tRBinElfReloc *relcs = NULL;\n\tRBinInfo *info;\n\tint cdsz;\n\tint i;\n\tut64 n_off, n_vaddr, vaddr, size, offset = 0;\n\n\tif (!b)\n\t\treturn NULL;\n\tio = b->iob.io;\n\tif (!io || !io->desc)\n\t\treturn NULL;\n\tobj = r_bin_cur_object (b);\n\tif (!obj) {\n\t   \treturn NULL;\n\t}\n\tbin = obj->bin_obj;\n\tif (bin->ehdr.e_type != ET_REL) {\n\t\treturn NULL;\n\t}\n\tif (!io->cached) {\n\t   \teprintf (\"Warning: run r2 with -e io.cache=true to fix relocations in disassembly\\n\");\n\t\treturn relocs (r_bin_cur (b));\n\t}\n\n\tinfo = obj ? obj->info: NULL;\n\tcdsz = info? (info->bits == 64? 8: info->bits == 32? 4: info->bits == 16 ? 4: 0): 0;\n\n\tls_foreach (io->sections, iter, s) {\n\t\tif (s->paddr > offset) {\n\t\t\toffset = s->paddr;\n\t\t\tg = s;\n\t\t}\n\t}\n\tif (!g) {\n\t\treturn NULL;\n\t}\n\tn_off = g->paddr + g->size;\n\tn_vaddr = g->vaddr + g->vsize;\n\t//reserve at least that space\n\tsize = bin->reloc_num * 4;\n\tif (!b->iob.section_add (io, n_off, n_vaddr, size, size, R_BIN_SCN_READABLE, \".got.r2\", 0, io->desc->fd)) {\n\t\treturn NULL;\n\t}\n\tif (!(relcs = Elf_(r_bin_elf_get_relocs) (bin))) {\n\t\treturn NULL;\n\t}\n\tif (!(ret = r_list_newf ((RListFree)free))) {\n\t\tfree (relcs);\n\t\treturn NULL;\n\t}\n\tif (!(relocs_by_sym = ht_new (NULL, relocs_by_sym_free, NULL))) {\n\t\tr_list_free (ret);\n\t\tfree (relcs);\n\t\treturn NULL;\n\t}\n\tvaddr = n_vaddr;\n\tfor (i = 0; !relcs[i].last; i++) {\n\t\tut64 sym_addr = 0;\n\n\t\tif (relcs[i].sym) {\n\t\t\tif (relcs[i].sym < bin->imports_by_ord_size && bin->imports_by_ord[relcs[i].sym]) {\n\t\t\t\tbool found;\n\n\t\t\t\tsym_addr = ht_find_intu64 (relocs_by_sym, relcs[i].sym, &found);\n\t\t\t\tif (!found) {\n\t\t\t\t\tsym_addr = 0;\n\t\t\t\t}\n\t\t\t} else if (relcs[i].sym < bin->symbols_by_ord_size && bin->symbols_by_ord[relcs[i].sym]) {\n\t\t\t\tsym_addr = bin->symbols_by_ord[relcs[i].sym]->vaddr;\n\t\t\t}\n\t\t}\n\t\t// TODO relocation types B, L\n\t\t_patch_reloc (bin->ehdr.e_machine, &b->iob, &relcs[i], sym_addr ? sym_addr : vaddr, 0, n_vaddr + size);\n\t\tif (!(ptr = reloc_convert (bin, &relcs[i], n_vaddr))) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (sym_addr) {\n\t\t\tptr->vaddr = sym_addr;\n\t\t} else {\n\t\t\tptr->vaddr = vaddr;\n\t\t\tht_insert_intu64 (relocs_by_sym, relcs[i].sym, vaddr);\n\t\t\tvaddr += cdsz;\n\t\t}\n\t\tr_list_append (ret, ptr);\n\t}\n\tht_free (relocs_by_sym);\n\tfree (relcs);\n\treturn ret;\n}\n\nstatic bool has_canary(RBinFile *bf) {\n\tbool ret = false;\n\tRList* imports_list = imports (bf);\n\tRListIter *iter;\n\tRBinImport *import;\n\tif (imports_list) {\n\t\tr_list_foreach (imports_list, iter, import) {\n\t\t\tif (!strcmp (import->name, \"__stack_chk_fail\") || !strcmp (import->name, \"__stack_smash_handler\")) {\n\t\t\t\tret = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\timports_list->free = r_bin_import_free;\n\t\tr_list_free (imports_list);\n\t}\n\treturn ret;\n}\n\nstatic RBinInfo* info(RBinFile *bf) {\n\tRBinInfo *ret = NULL;\n\tchar *str;\n\n\tif (!(ret = R_NEW0 (RBinInfo))) {\n\t\treturn NULL;\n\t}\n\tret->lang = \"c\";\n\tret->file = bf->file\n\t\t? strdup (bf->file)\n\t\t: NULL;\n\tvoid *obj = bf->o->bin_obj;\n\tif ((str = Elf_(r_bin_elf_get_rpath)(obj))) {\n\t\tret->rpath = strdup (str);\n\t\tfree (str);\n\t} else {\n\t\tret->rpath = strdup (\"NONE\");\n\t}\n\tif (!(str = Elf_(r_bin_elf_get_file_type) (obj))) {\n\t\tfree (ret);\n\t\treturn NULL;\n\t}\n\tret->type = str;\n\tret->has_pi = (strstr (str, \"DYN\"))? 1: 0;\n\tret->has_lit = true;\n\tret->has_canary = has_canary (bf);\n\tif (!(str = Elf_(r_bin_elf_get_elf_class) (obj))) {\n\t\tfree (ret);\n\t\treturn NULL;\n\t}\n\tret->bclass = str;\n\tif (!(str = Elf_(r_bin_elf_get_osabi_name) (obj))) {\n\t\tfree (ret);\n\t\treturn NULL;\n\t}\n\tret->os = str;\n\tif (!(str = Elf_(r_bin_elf_get_osabi_name) (obj))) {\n\t\tfree (ret);\n\t\treturn NULL;\n\t}\n\tret->subsystem = str;\n\tif (!(str = Elf_(r_bin_elf_get_machine_name) (obj))) {\n\t\tfree (ret);\n\t\treturn NULL;\n\t}\n\tret->machine = str;\n\tif (!(str = Elf_(r_bin_elf_get_arch) (obj))) {\n\t\tfree (ret);\n\t\treturn NULL;\n\t}\n\tret->arch = str;\n\tret->rclass = strdup (\"elf\");\n\tret->bits = Elf_(r_bin_elf_get_bits) (obj);\n\tif (!strcmp (ret->arch, \"avr\")) {\n\t\tret->bits = 16;\n\t}\n\tret->big_endian = Elf_(r_bin_elf_is_big_endian) (obj);\n\tret->has_va = Elf_(r_bin_elf_has_va) (obj);\n\tret->has_nx = Elf_(r_bin_elf_has_nx) (obj);\n\tret->intrp = Elf_(r_bin_elf_intrp) (obj);\n\tret->dbg_info = 0;\n\tif (!Elf_(r_bin_elf_get_stripped) (obj)) {\n\t\tret->dbg_info |= R_BIN_DBG_LINENUMS | R_BIN_DBG_SYMS | R_BIN_DBG_RELOCS;\n\t} else {\n\t\tret->dbg_info |= R_BIN_DBG_STRIPPED;\n\t}\n\tif (Elf_(r_bin_elf_get_static) (obj)) {\n\t\tret->dbg_info |= R_BIN_DBG_STATIC;\n\t}\n\tRBinElfSymbol *symbol;\n\tif (!(symbol = Elf_(r_bin_elf_get_symbols) (obj))) {\n\t\treturn ret;\n\t}\n\tint i;\n\tfor (i = 0; !symbol[i].last; i++) {\n\t\tif (!strncmp (symbol[i].name, \"type.\", 5)) {\n\t\t\tret->lang = \"go\";\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\n\nstatic RList* fields(RBinFile *bf) {\n\tRList *ret = NULL;\n\tRBinField *ptr = NULL;\n\tstruct r_bin_elf_field_t *field = NULL;\n\tint i;\n\n\tif (!(ret = r_list_new ())) {\n\t\treturn NULL;\n\t}\n\tret->free = free;\n\tif (!(field = Elf_(r_bin_elf_get_fields) (bf->o->bin_obj))) {\n\t\treturn ret;\n\t}\n\tfor (i = 0; !field[i].last; i++) {\n\t\tif (!(ptr = R_NEW0 (RBinField))) {\n\t\t\tbreak;\n\t\t}\n\t\tptr->name = strdup (field[i].name);\n\t\tptr->comment = NULL;\n\t\tptr->vaddr = field[i].offset;\n\t\tptr->paddr = field[i].offset;\n\t\tr_list_append (ret, ptr);\n\t}\n\tfree (field);\n\treturn ret;\n}\n\nstatic ut64 size(RBinFile *bf) {\n\tut64 off = 0;\n\tut64 len = 0;\n\tif (!bf->o->sections) {\n\t\tRListIter *iter;\n\t\tRBinSection *section;\n\t\tbf->o->sections = sections (bf);\n\t\tr_list_foreach (bf->o->sections, iter, section) {\n\t\t\tif (section->paddr > off) {\n\t\t\t\toff = section->paddr;\n\t\t\t\tlen = section->size;\n\t\t\t}\n\t\t}\n\t}\n\treturn off + len;\n}\n\n#if !R_BIN_ELF64 && !R_BIN_CGC\n\nstatic void headers32(RBinFile *bf) {\n#define p bf->rbin->cb_printf\n\tconst ut8 *buf = r_buf_get_at (bf->buf, 0, NULL);\n\tp (\"0x00000000  ELF MAGIC   0x%08x\\n\", r_read_le32 (buf));\n\tp (\"0x00000004  Type        0x%04x\\n\", r_read_le16 (buf + 4));\n\tp (\"0x00000006  Machine     0x%04x\\n\", r_read_le16 (buf + 6));\n\tp (\"0x00000008  Version     0x%08x\\n\", r_read_le32 (buf + 8));\n\tp (\"0x0000000c  Entrypoint  0x%08x\\n\", r_read_le32 (buf + 12));\n\tp (\"0x00000010  PhOff       0x%08x\\n\", r_read_le32 (buf + 16));\n\tp (\"0x00000014  ShOff       0x%08x\\n\", r_read_le32 (buf + 20));\n}\n\nstatic bool check_bytes(const ut8 *buf, ut64 length) {\n\treturn buf && length > 4 && memcmp (buf, ELFMAG, SELFMAG) == 0\n\t\t&& buf[4] != 2;\n}\n\nextern struct r_bin_dbginfo_t r_bin_dbginfo_elf;\nextern struct r_bin_write_t r_bin_write_elf;\n\nstatic RBuffer* create(RBin* bin, const ut8 *code, int codelen, const ut8 *data, int datalen) {\n\tut32 filesize, code_va, code_pa, phoff;\n\tut32 p_start, p_phoff, p_phdr;\n\tut32 p_ehdrsz, p_phdrsz;\n\tut16 ehdrsz, phdrsz;\n\tut32 p_vaddr, p_paddr, p_fs, p_fs2;\n\tut32 baddr;\n\tint is_arm = 0;\n\tRBuffer *buf = r_buf_new ();\n\tif (bin && bin->cur && bin->cur->o && bin->cur->o->info) {\n\t\tis_arm = !strcmp (bin->cur->o->info->arch, \"arm\");\n\t}\n\t// XXX: hardcoded\n\tif (is_arm) {\n\t\tbaddr = 0x40000;\n\t} else {\n\t\tbaddr = 0x8048000;\n\t}\n\n#define B(x,y) r_buf_append_bytes(buf,(const ut8*)x,y)\n#define D(x) r_buf_append_ut32(buf,x)\n#define H(x) r_buf_append_ut16(buf,x)\n#define Z(x) r_buf_append_nbytes(buf,x)\n#define W(x,y,z) r_buf_write_at(buf,x,(const ut8*)y,z)\n#define WZ(x,y) p_tmp=buf->length;Z(x);W(p_tmp,y,strlen(y))\n\n\tB (\"\\x7F\" \"ELF\" \"\\x01\\x01\\x01\\x00\", 8);\n\tZ (8);\n\tH (2); // ET_EXEC\n\tif (is_arm) {\n\t\tH (40); // e_machne = EM_ARM\n\t} else {\n\t\tH (3); // e_machne = EM_I386\n\t}\n\n\tD (1);\n\tp_start = buf->length;\n\tD (-1); // _start\n\tp_phoff = buf->length;\n\tD (-1); // phoff -- program headers offset\n\tD (0);  // shoff -- section headers offset\n\tD (0);  // flags\n\tp_ehdrsz = buf->length;\n\tH (-1); // ehdrsz\n\tp_phdrsz = buf->length;\n\tH (-1); // phdrsz\n\tH (1);\n\tH (0);\n\tH (0);\n\tH (0);\n\t// phdr:\n\tp_phdr = buf->length;\n\tD (1);\n\tD (0);\n\tp_vaddr = buf->length;\n\tD (-1); // vaddr = $$\n\tp_paddr = buf->length;\n\tD (-1); // paddr = $$\n\tp_fs = buf->length;\n\tD (-1); // filesize\n\tp_fs2 = buf->length;\n\tD (-1); // filesize\n\tD (5); // flags\n\tD (0x1000); // align\n\n\tehdrsz = p_phdr;\n\tphdrsz = buf->length - p_phdr;\n\tcode_pa = buf->length;\n\tcode_va = code_pa + baddr;\n\tphoff = 0x34;//p_phdr ;\n\tfilesize = code_pa + codelen + datalen;\n\n\tW (p_start, &code_va, 4);\n\tW (p_phoff, &phoff, 4);\n\tW (p_ehdrsz, &ehdrsz, 2);\n\tW (p_phdrsz, &phdrsz, 2);\n\n\tcode_va = baddr; // hack\n\tW (p_vaddr, &code_va, 4);\n\tcode_pa = baddr; // hack\n\tW (p_paddr, &code_pa, 4);\n\n\tW (p_fs, &filesize, 4);\n\tW (p_fs2, &filesize, 4);\n\n\tB (code, codelen);\n\n\tif (data && datalen > 0) {\n\t\t//ut32 data_section = buf->length;\n\t\teprintf (\"Warning: DATA section not support for ELF yet\\n\");\n\t\tB (data, datalen);\n\t}\n\treturn buf;\n}\n\nRBinPlugin r_bin_plugin_elf = {\n\t.name = \"elf\",\n\t.desc = \"ELF format r2 plugin\",\n\t.license = \"LGPL3\",\n\t.get_sdb = &get_sdb,\n\t.load = &load,\n\t.load_bytes = &load_bytes,\n\t.load_buffer = &load_buffer,\n\t.destroy = &destroy,\n\t.check_bytes = &check_bytes,\n\t.baddr = &baddr,\n\t.boffset = &boffset,\n\t.binsym = &binsym,\n\t.entries = &entries,\n\t.sections = &sections,\n\t.symbols = &symbols,\n\t.minstrlen = 4,\n\t.imports = &imports,\n\t.info = &info,\n\t.fields = &fields,\n\t.header = &headers32,\n\t.size = &size,\n\t.libs = &libs,\n\t.relocs = &relocs,\n\t.patch_relocs = &patch_relocs,\n\t.dbginfo = &r_bin_dbginfo_elf,\n\t.create = &create,\n\t.write = &r_bin_write_elf,\n\t.file_type = &get_file_type,\n\t.regstate = &regstate,\n\t.maps = &maps,\n};\n\n#ifndef CORELIB\nRLibStruct radare_plugin = {\n\t.type = R_LIB_TYPE_BIN,\n\t.data = &r_bin_plugin_elf,\n\t.version = R2_VERSION\n};\n#endif\n#endif\n", "/* radare - LGPL - Copyright 2011-2018 - earada, pancake */\n\n#include <r_core.h>\n#include \"r_util.h\"\n\n#define DBSPATH \"/share/radare2/\" R2_VERSION \"/fcnsign\"\n#define is_in_range(at, from, sz) ((at) >= (from) && (at) < ((from) + (sz)))\n\n#define VA_FALSE    0\n#define VA_TRUE     1\n#define VA_NOREBASE 2\n\n#define IS_MODE_SET(mode) (mode & R_CORE_BIN_SET)\n#define IS_MODE_SIMPLE(mode) (mode & R_CORE_BIN_SIMPLE)\n#define IS_MODE_SIMPLEST(mode) (mode & R_CORE_BIN_SIMPLEST)\n#define IS_MODE_JSON(mode) (mode & R_CORE_BIN_JSON)\n#define IS_MODE_RAD(mode) (mode & R_CORE_BIN_RADARE)\n#define IS_MODE_NORMAL(mode) (!mode)\n#define IS_MODE_CLASSDUMP(mode) (mode & R_CORE_BIN_CLASSDUMP)\n\n// dup from cmd_info\n#define PAIR_WIDTH 9\n\nstatic void pair(const char *a, const char *b, int mode, bool last) {\n\tif (!b || !*b) {\n\t\treturn;\n\t}\n\tif (IS_MODE_JSON (mode)) {\n\t\tconst char *lst = last ? \"\" : \",\";\n\t\tr_cons_printf (\"\\\"%s\\\":%s%s\", a, b, lst);\n\t} else {\n\t\tchar ws[16];\n\t\tint al = strlen (a);\n\t\tif (al > PAIR_WIDTH) {\n\t\t\tal = 0;\n\t\t} else {\n\t\t\tal = PAIR_WIDTH - al;\n\t\t}\n\t\tmemset (ws, ' ', al);\n\t\tws[al] = 0;\n\t\tr_cons_printf (\"%s%s%s\\n\", a, ws, b);\n\t}\n}\n\nstatic void pair_bool(const char *a, bool t, int mode, bool last) {\n\tpair (a, r_str_bool (t), mode, last);\n}\n\nstatic void pair_int(const char *a, int n, int mode, bool last) {\n\tpair (a, sdb_fmt (\"%d\", n), mode, last);\n}\n\nstatic void pair_ut64(const char *a, ut64 n, int mode, bool last) {\n\tpair (a, sdb_fmt (\"%\"PFMT64d, n), mode, last);\n}\n\nstatic void pair_str(const char *a, const char *b, int mode, int last) {\n\tif (IS_MODE_JSON (mode)) {\n\t\tif (!b) {\n\t\t\tb = \"\";\n\t\t}\n\t\tchar *eb = r_str_utf16_encode (b, -1);\n\t\tif (eb) {\n\t\t\tchar *qs = r_str_newf (\"\\\"%s\\\"\", eb);\n\t\t\tpair (a, qs, mode, last);\n\t\t\tfree (eb);\n\t\t\tfree (qs);\n\t\t}\n\t} else {\n\t\tpair (a, b, mode, last);\n\t}\n}\n\n#define STR(x) (x)?(x):\"\"\nR_API int r_core_bin_set_cur (RCore *core, RBinFile *binfile);\n\nstatic ut64 rva(RBin *bin, ut64 paddr, ut64 vaddr, int va) {\n\tif (va == VA_TRUE) {\n\t\treturn r_bin_get_vaddr (bin, paddr, vaddr);\n\t}\n\tif (va == VA_NOREBASE) {\n\t\treturn vaddr;\n\t}\n\treturn paddr;\n}\n\nR_API int r_core_bin_set_by_fd(RCore *core, ut64 bin_fd) {\n\tif (r_bin_file_set_cur_by_fd (core->bin, bin_fd)) {\n\t\tr_core_bin_set_cur (core, r_core_bin_cur (core));\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nR_API int r_core_bin_set_by_name(RCore *core, const char * name) {\n\tif (r_bin_file_set_cur_by_name (core->bin, name)) {\n\t\tr_core_bin_set_cur (core, r_core_bin_cur (core));\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nR_API int r_core_bin_set_env(RCore *r, RBinFile *binfile) {\n\tRBinObject *binobj = binfile ? binfile->o: NULL;\n\tRBinInfo *info = binobj ? binobj->info: NULL;\n\tif (info) {\n\t\tint va = info->has_va;\n\t\tconst char * arch = info->arch;\n\t\tut16 bits = info->bits;\n\t\tut64 baseaddr = r_bin_get_baddr (r->bin);\n\t\tr_config_set_i (r->config, \"bin.baddr\", baseaddr);\n\t\tr_config_set (r->config, \"asm.arch\", arch);\n\t\tr_config_set_i (r->config, \"asm.bits\", bits);\n\t\tr_config_set (r->config, \"anal.arch\", arch);\n\t\tif (info->cpu && *info->cpu) {\n\t\t\tr_config_set (r->config, \"anal.cpu\", info->cpu);\n\t\t} else {\n\t\t\tr_config_set (r->config, \"anal.cpu\", arch);\n\t\t}\n\t\tr_asm_use (r->assembler, arch);\n\t\tr_core_bin_info (r, R_CORE_BIN_ACC_ALL, R_CORE_BIN_SET, va, NULL, NULL);\n\t\tr_core_bin_set_cur (r, binfile);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nR_API int r_core_bin_set_cur(RCore *core, RBinFile *binfile) {\n\tif (!core->bin) {\n\t\treturn false;\n\t}\n\tif (!binfile) {\n\t\t// Find first available binfile\n\t\tut32 fd = r_core_file_cur_fd (core);\n\t\tbinfile = fd != (ut32)-1\n\t\t\t\t  ? r_bin_file_find_by_fd (core->bin, fd)\n\t\t\t\t  : NULL;\n\t\tif (!binfile) {\n\t\t\treturn false;\n\t\t}\n\t}\n\tr_bin_file_set_cur_binfile (core->bin, binfile);\n\treturn true;\n}\n\nR_API int r_core_bin_refresh_strings(RCore *r) {\n\treturn r_bin_reset_strings (r->bin) ? true: false;\n}\n\nR_API RBinFile * r_core_bin_cur(RCore *core) {\n\tRBinFile *binfile = r_bin_cur (core->bin);\n\treturn binfile;\n}\n\nstatic void _print_strings(RCore *r, RList *list, int mode, int va) {\n\tbool b64str = r_config_get_i (r->config, \"bin.b64str\");\n\tint minstr = r_config_get_i (r->config, \"bin.minstr\");\n\tint maxstr = r_config_get_i (r->config, \"bin.maxstr\");\n\tRBin *bin = r->bin;\n\tRBinObject *obj = r_bin_cur_object (bin);\n\tRListIter *iter;\n\tRListIter *last_processed = NULL;\n\tRBinString *string;\n\tRBinSection *section;\n\tchar *q;\n\n\tbin->minstrlen = minstr;\n\tbin->maxstrlen = maxstr;\n\tif (IS_MODE_JSON (mode)) {\n\t\tr_cons_printf (\"[\");\n\t}\n\tif (IS_MODE_RAD (mode)) {\n\t\tr_cons_printf (\"fs strings\");\n\t}\n\tif (IS_MODE_SET (mode) && r_config_get_i (r->config, \"bin.strings\")) {\n\t\tr_flag_space_set (r->flags, \"strings\");\n\t\tr_cons_break_push (NULL, NULL);\n\t}\n\tRBinString b64 = {0};\n\tr_list_foreach (list, iter, string) {\n\t\tconst char *section_name, *type_string;\n\t\tut64 paddr, vaddr, addr;\n\t\tpaddr = string->paddr;\n\t\tvaddr = r_bin_get_vaddr (bin, paddr, string->vaddr);\n\t\taddr = va ? vaddr : paddr;\n\t\tif (!r_bin_string_filter (bin, string->string, addr)) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (string->length < minstr) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (maxstr && string->length > maxstr) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tsection = r_bin_get_section_at (obj, paddr, 0);\n\t\tsection_name = section ? section->name : \"\";\n\t\ttype_string = r_bin_string_type (string->type);\n\t\tif (b64str) {\n\t\t\tut8 *s = r_base64_decode_dyn (string->string, -1);\n\t\t\tif (s && *s && IS_PRINTABLE (*s)) {\n\t\t\t\t// TODO: add more checks\n\t\t\t\tfree (b64.string);\n\t\t\t\tmemcpy (&b64, string, sizeof (b64));\n\t\t\t\tb64.string = (char *)s;\n\t\t\t\tb64.size = strlen (b64.string);\n\t\t\t\tstring = &b64;\n\t\t\t}\n\t\t}\n\t\tif (IS_MODE_SET (mode)) {\n\t\t\tchar *f_name, *str;\n\t\t\tif (r_cons_is_breaked ()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tr_meta_add (r->anal, R_META_TYPE_STRING, addr, addr + string->size, string->string);\n\t\t\tf_name = strdup (string->string);\n\t\t\tr_name_filter (f_name, -1);\n\t\t\tif (r->bin->prefix) {\n\t\t\t\tstr = r_str_newf (\"%s.str.%s\", r->bin->prefix, f_name);\n\t\t\t} else {\n\t\t\t\tstr = r_str_newf (\"str.%s\", f_name);\n\t\t\t}\n\t\t\tr_flag_set (r->flags, str, addr, string->size);\n\t\t\tfree (str);\n\t\t\tfree (f_name);\n\t\t} else if (IS_MODE_SIMPLE (mode)) {\n\t\t\tr_cons_printf (\"0x%\"PFMT64x\" %d %d %s\\n\", addr,\n\t\t\t\tstring->size, string->length, string->string);\n\t\t} else if (IS_MODE_SIMPLEST (mode)) {\n\t\t\tr_cons_println (string->string);\n\t\t} else if (IS_MODE_JSON (mode)) {\n\t\t\tint *block_list;\n\t\t\tq = r_base64_encode_dyn (string->string, -1);\n\t\t\tr_cons_printf (\"%s{\\\"vaddr\\\":%\"PFMT64d\n\t\t\t\t\",\\\"paddr\\\":%\"PFMT64d\",\\\"ordinal\\\":%d\"\n\t\t\t\t\",\\\"size\\\":%d,\\\"length\\\":%d,\\\"section\\\":\\\"%s\\\",\"\n\t\t\t\t\"\\\"type\\\":\\\"%s\\\",\\\"string\\\":\\\"%s\\\"\",\n\t\t\t\tlast_processed ? \",\": \"\",\n\t\t\t\tvaddr, paddr, string->ordinal, string->size,\n\t\t\t\tstring->length, section_name, type_string, q);\n\t\t\tswitch (string->type) {\n\t\t\tcase R_STRING_TYPE_UTF8:\n\t\t\tcase R_STRING_TYPE_WIDE:\n\t\t\tcase R_STRING_TYPE_WIDE32:\n\t\t\t\tblock_list = r_utf_block_list ((const ut8*)string->string);\n\t\t\t\tif (block_list) {\n\t\t\t\t\tif (block_list[0] == 0 && block_list[1] == -1) {\n\t\t\t\t\t\t/* Don't include block list if\n\t\t\t\t\t\t   just Basic Latin (0x00 - 0x7F) */\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tint *block_ptr = block_list;\n\t\t\t\t\tr_cons_printf (\",\\\"blocks\\\":[\");\n\t\t\t\t\tfor (; *block_ptr != -1; block_ptr++) {\n\t\t\t\t\t\tif (block_ptr != block_list) {\n\t\t\t\t\t\t\tr_cons_printf (\",\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst char *utfName = r_utf_block_name (*block_ptr);\n\t\t\t\t\t\tr_cons_printf (\"\\\"%s\\\"\", utfName? utfName: \"\");\n\t\t\t\t\t}\n\t\t\t\t\tr_cons_printf (\"]\");\n\t\t\t\t\tR_FREE (block_list);\n\t\t\t\t}\n\t\t\t}\n\t\t\tr_cons_printf (\"}\");\n\t\t\tfree (q);\n\t\t} else if (IS_MODE_RAD (mode)) {\n\t\t\tchar *f_name, *str;\n\t\t\tf_name = strdup (string->string);\n\t\t\tr_name_filter (f_name, R_FLAG_NAME_SIZE);\n\t\t\tif (r->bin->prefix) {\n\t\t\t\tstr = r_str_newf (\"%s.str.%s\", r->bin->prefix, f_name);\n\t\t\t\tr_cons_printf (\"f %s.str.%s %\"PFMT64d\" @ 0x%08\"PFMT64x\"\\n\"\n\t\t\t\t\t\"Cs %\"PFMT64d\" @ 0x%08\"PFMT64x\"\\n\",\n\t\t\t\t\tr->bin->prefix, f_name, string->size, addr,\n\t\t\t\t\tstring->size, addr);\n\t\t\t} else {\n\t\t\t\tstr = r_str_newf (\"str.%s\", f_name);\n\t\t\t\tr_cons_printf (\"f str.%s %\"PFMT64d\" @ 0x%08\"PFMT64x\"\\n\"\n\t\t\t\t\t\"Cs %\"PFMT64d\" @ 0x%08\"PFMT64x\"\\n\",\n\t\t\t\t\tf_name, string->size, addr,\n\t\t\t\t\tstring->size, addr);\n\t\t\t}\n\t\t\tfree (str);\n\t\t\tfree (f_name);\n\t\t} else {\n\t\t\tint *block_list;\n\t\t\tchar *str = string->string;\n\t\t\tchar *no_dbl_bslash_str = NULL;\n\t\t\tif (!r->print->esc_bslash) {\n\t\t\t\tchar *ptr;\n\t\t\t\tfor (ptr = str; *ptr; ptr++) {\n\t\t\t\t\tif (*ptr != '\\\\') {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (*(ptr + 1) == '\\\\') {\n\t\t\t\t\t\tif (!no_dbl_bslash_str) {\n\t\t\t\t\t\t\tno_dbl_bslash_str = strdup (str);\n\t\t\t\t\t\t\tif (!no_dbl_bslash_str) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tptr = no_dbl_bslash_str + (ptr - str);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmemmove (ptr + 1, ptr + 2, strlen (ptr + 2) + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (no_dbl_bslash_str) {\n\t\t\t\t\tstr = no_dbl_bslash_str;\n\t\t\t\t}\n\t\t\t}\n#if 0\n\t\t\tr_cons_printf (\"vaddr=0x%08\"PFMT64x\" paddr=0x%08\"\n\t\t\t\tPFMT64x\" ordinal=%03u sz=%u len=%u \"\n\t\t\t\t\"section=%s type=%s string=%s\",\n\t\t\t\tvaddr, paddr, string->ordinal, string->size,\n\t\t\t\tstring->length, section_name, type_string, str);\n#else\n\t\t\tr_cons_printf (\"%03u 0x%08\"PFMT64x\" 0x%08\"\n\t\t\t\tPFMT64x\" %3u %3u \"\n\t\t\t\t\"(%s) %5s %s\",\n\t\t\t\tstring->ordinal, paddr, vaddr, \n\t\t\t\tstring->length, string->size,\n\t\t\t\tsection_name, type_string, str);\n#endif\n\t\t\tif (str == no_dbl_bslash_str) {\n\t\t\t\tR_FREE (str);\n\t\t\t}\n\t\t\tswitch (string->type) {\n\t\t\tcase R_STRING_TYPE_UTF8:\n\t\t\tcase R_STRING_TYPE_WIDE:\n\t\t\tcase R_STRING_TYPE_WIDE32:\n\t\t\t\tblock_list = r_utf_block_list ((const ut8*)string->string);\n\t\t\t\tif (block_list) {\n\t\t\t\t\tif (block_list[0] == 0 && block_list[1] == -1) {\n\t\t\t\t\t\t/* Don't show block list if\n\t\t\t\t\t\t   just Basic Latin (0x00 - 0x7F) */\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tint *block_ptr = block_list;\n\t\t\t\t\tr_cons_printf (\" blocks=\");\n\t\t\t\t\tfor (; *block_ptr != -1; block_ptr++) {\n\t\t\t\t\t\tif (block_ptr != block_list) {\n\t\t\t\t\t\t\tr_cons_printf (\",\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst char *name = r_utf_block_name (*block_ptr);\n\t\t\t\t\t\tr_cons_printf (\"%s\", name? name: \"\");\n\t\t\t\t\t}\n\t\t\t\t\tfree (block_list);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tr_cons_printf (\"\\n\");\n\t\t}\n\t\tlast_processed = iter;\n\t}\n\tR_FREE (b64.string);\n\tif (IS_MODE_JSON (mode)) {\n\t\tr_cons_printf (\"]\");\n\t}\n\tif (IS_MODE_SET (mode)) {\n\t\tr_cons_break_pop ();\n\t}\n}\n\nstatic bool bin_raw_strings(RCore *r, int mode, int va) {\n\tRBinFile *bf = r_bin_cur (r->bin);\n\tbool new_bf = false;\n\tif (bf && strstr (bf->file, \"malloc://\")) {\n\t\t//sync bf->buf to search string on it\n\t\tr_io_read_at (r->io, 0, bf->buf->buf, bf->size);\n\t}\n\tif (!r->file) {\n\t\teprintf (\"Core file not open\\n\");\n\t\treturn false;\n\t}\n\tif (!bf) {\n\t\tbf = R_NEW0 (RBinFile);\n\t\tif (!bf) {\n\t\t\treturn false;\n\t\t}\n\t\tRIODesc *desc = r_io_desc_get (r->io, r->file->fd);\n\t\tif (!desc) {\n\t\t\tfree (bf);\n\t\t\treturn false;\n\t\t}\n\t\tbf->file = strdup (desc->name);\n\t\tbf->size = r_io_desc_size (desc);\n\t\tif (bf->size == UT64_MAX) {\n\t\t\tfree (bf);\n\t\t\treturn false;\n\t\t}\n\t\tbf->buf = r_buf_new_with_io (&r->bin->iob, r->file->fd);\n#if 0\n\t\tbf->buf = r_buf_new ();\n\t\tif (!bf->buf) {\n\t\t\tfree (bf);\n\t\t\treturn false;\n\t\t}\n\t\tbf->buf->buf = malloc (bf->size);\n\t\tif (!bf->buf->buf) {\n\t\t\tfree (bf->buf);\n\t\t\tfree (bf);\n\t\t\treturn false;\n\t\t}\n\t\tbf->buf->fd = r->file->fd;\n\t\tbf->buf->length = bf->size;\n\t\tr_io_read_at (r->io, 0, bf->buf->buf, bf->size);\n#endif\n\t\tbf->o = NULL;\n\t\tbf->rbin = r->bin;\n\t\tnew_bf = true;\n\t\tva = false;\n\t}\n\tRList *l = r_bin_raw_strings (bf, 0);\n\t_print_strings (r, l, mode, va);\n\tif (new_bf) {\n\t\tr_buf_free (bf->buf);\n\t\tbf->buf = NULL;\n\t\tbf->id = -1;\n\t\tr_bin_file_free (bf);\n\t}\n\treturn true;\n}\n\nstatic bool bin_strings(RCore *r, int mode, int va) {\n\tRList *list;\n\tRBinFile *binfile = r_core_bin_cur (r);\n\tRBinPlugin *plugin = r_bin_file_cur_plugin (binfile);\n\tint rawstr = r_config_get_i (r->config, \"bin.rawstr\");\n\tif (!binfile) {\n\t\treturn false;\n\t}\n\tif (!r_config_get_i (r->config, \"bin.strings\")) {\n\t\treturn false;\n\t}\n\tif (!plugin) {\n\t\treturn false;\n\t}\n\tif (plugin->info && plugin->name) {\n\t\tif (strcmp (plugin->name, \"any\") == 0 && !rawstr) {\n\t\t\tif (IS_MODE_JSON (mode)) {\n\t\t\t\tr_cons_print(\"[]\");\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tif (!(list = r_bin_get_strings (r->bin))) {\n\t\treturn false;\n\t}\n\t_print_strings (r, list, mode, va);\n\treturn true;\n}\n\nstatic const char* get_compile_time(Sdb *binFileSdb) {\n\tSdb *info_ns = sdb_ns (binFileSdb, \"info\", false);\n\tconst char *timeDateStamp_string = sdb_const_get (info_ns,\n\t\t\"image_file_header.TimeDateStamp_string\", 0);\n\treturn timeDateStamp_string;\n}\n\nstatic int is_executable(RBinObject *obj) {\n\tRListIter *it;\n\tRBinSection* sec;\n\tif (obj) {\n\t\tif (obj->info && obj->info->arch) {\n\t\t\treturn true;\n\t\t}\n\t\tr_list_foreach (obj->sections, it, sec) {\n\t\t\tif (R_BIN_SCN_EXECUTABLE & sec->srwx) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nstatic void sdb_concat_by_path(Sdb *s, const char *path) {\n\tSdb *db = sdb_new (0, path, 0);\n\tsdb_merge (s, db);\n\tsdb_close (db);\n\tsdb_free (db);\n}\n\nR_API void r_core_anal_type_init(RCore *core) {\n\tSdb *types = NULL;\n\tconst char *anal_arch = NULL, *os = NULL;\n\tchar *dbpath;\n\tif (!core || !core->anal) {\n\t\treturn;\n\t}\n\tconst char *dir_prefix = r_config_get (core->config, \"dir.prefix\");\n\tint bits = core->assembler->bits;\n\ttypes = core->anal->sdb_types;\n \t// make sure they are empty this is initializing\n\tsdb_reset (types);\n\tanal_arch = r_config_get (core->config, \"anal.arch\");\n\tos = r_config_get (core->config, \"asm.os\");\n\t// spaguetti ahead\n\tdbpath = sdb_fmt (\"%s/\"DBSPATH\"/types.sdb\", dir_prefix);\n\tif (r_file_exists (dbpath)) {\n\t\tsdb_concat_by_path (types, dbpath);\n\t}\n\tdbpath = sdb_fmt (\"%s/\"DBSPATH\"/types-%s.sdb\", dir_prefix, anal_arch);\n\tif (r_file_exists (dbpath)) {\n\t\tsdb_concat_by_path (types, dbpath);\n\t}\n\tdbpath = sdb_fmt (\"%s/\"DBSPATH\"/types-%s.sdb\", dir_prefix, os);\n\tif (r_file_exists (dbpath)) {\n\t\tsdb_concat_by_path (types, dbpath);\n\t}\n\tdbpath = sdb_fmt (\"%s/\"DBSPATH\"/types-%d.sdb\", dir_prefix, bits);\n\tif (r_file_exists (dbpath)) {\n\t\tsdb_concat_by_path (types, dbpath);\n\t}\n\tdbpath = sdb_fmt (\"%s/\"DBSPATH\"/types-%s-%d.sdb\", dir_prefix, os, bits);\n\tif (r_file_exists (dbpath)) {\n\t\tsdb_concat_by_path (types, dbpath);\n\t}\n\tdbpath = sdb_fmt (\"%s/\"DBSPATH\"/types-%s-%d.sdb\", dir_prefix, anal_arch, bits);\n\tif (r_file_exists (dbpath)) {\n\t\tsdb_concat_by_path (types, dbpath);\n\t}\n\tdbpath = sdb_fmt (\"%s/\"DBSPATH\"/types-%s-%s.sdb\", dir_prefix, anal_arch, os);\n\tif (r_file_exists (dbpath)) {\n\t\tsdb_concat_by_path (types, dbpath);\n\t}\n\tdbpath = sdb_fmt (\"%s/\"DBSPATH\"/types-%s-%s-%d.sdb\", dir_prefix, anal_arch, os, bits);\n\tif (r_file_exists (dbpath)) {\n\t\tsdb_concat_by_path (types, dbpath);\n\t}\n}\n\nstatic int save_ptr(void *p, const char *k, const char *v) {\n\tSdb *sdbs[2];\n\tsdbs[0] = ((Sdb**) p)[0];\n\tsdbs[1] = ((Sdb**) p)[1];\n\tif (!strncmp (v, \"cc\", strlen (\"cc\") + 1)) {\n\t\tconst char *x = sdb_const_get (sdbs[1], sdb_fmt (\"cc.%s.name\", k), 0);\n\t\tchar *tmp = sdb_fmt (\"%p\", x);\n\t\tsdb_set (sdbs[0], tmp, x, 0);\n\t}\n\treturn 1;\n}\n\nR_API void r_core_anal_cc_init(RCore *core) {\n\tSdb *sdbs[2] = {\n\t\tsdb_new0 (),\n\t\tcore->anal->sdb_cc\n\t};\n\tconst char *dir_prefix = r_config_get (core->config, \"dir.prefix\");\n\t//save pointers and values stored inside them\n\t//to recover from freeing heeps\n\tconst char *defaultcc = sdb_const_get (sdbs[1], \"default.cc\", 0);\n\tsdb_set (sdbs[0], sdb_fmt (\"0x%08\"PFMT64x, r_num_get (NULL, defaultcc)), defaultcc, 0);\n\tsdb_foreach (core->anal->sdb_cc, save_ptr, sdbs);\n\tsdb_reset ( core->anal->sdb_cc);\n\tconst char *anal_arch = r_config_get (core->config, \"anal.arch\");\n\n\tint bits = core->anal->bits;\n\tif (bits == 16 && !strcmp (anal_arch, \"arm\")) {\n\t\tbits = 32;\n\t}\n\n\tchar *dbpath = sdb_fmt (\"%s/\"DBSPATH\"/cc-%s-%d.sdb\", dir_prefix, anal_arch, bits);\n\tif (r_file_exists (dbpath)) {\n\t\tsdb_concat_by_path (core->anal->sdb_cc, dbpath);\n\t}\n\t//restore all freed CC or replace with new default cc\n\tRListIter *it;\n\tRAnalFunction *fcn;\n\tr_list_foreach (core->anal->fcns, it, fcn) {\n\t\tchar *ptr = sdb_fmt (\"%p\", fcn->cc);\n\t\tconst char *cc = sdb_const_get (sdbs[0], ptr, 0);\n\t\tif (cc) {\n\t\t\tfcn->cc = r_anal_cc_to_constant (core->anal, (char *)cc);\n\t\t}\n\t\tif (!fcn->cc) {\n\t\t\tfcn->cc = r_anal_cc_default (core->anal);\n\t\t}\n\t\tfcn->cc = r_str_const (fcn->cc);\n\t}\n\tsdb_close (sdbs[0]);\n\tsdb_free (sdbs[0]);\n}\n#undef DBSPATH\n\nstatic int bin_info(RCore *r, int mode) {\n\tint i, j, v;\n\tchar str[R_FLAG_NAME_SIZE];\n\tRBinInfo *info = r_bin_get_info (r->bin);\n\tRBinFile *binfile = r_core_bin_cur (r);\n\tRBinObject *obj = r_bin_cur_object (r->bin);\n\tconst char *compiled = NULL;\n\tbool havecode;\n\n\tif (!binfile || !info || !obj) {\n\t\tif (mode & R_CORE_BIN_JSON) {\n\t\t\tr_cons_printf (\"{}\");\n\t\t}\n\t\treturn false;\n\t}\n\thavecode = is_executable (obj) | (obj->entries != NULL);\n\tcompiled = get_compile_time (binfile->sdb);\n\n\tif (IS_MODE_SET (mode)) {\n\t\tr_config_set (r->config, \"file.type\", info->rclass);\n\t\tr_config_set (r->config, \"cfg.bigendian\",\n\t\t\t      info->big_endian ? \"true\" : \"false\");\n\t\tif (info->rclass && !strcmp (info->rclass, \"fs\")) {\n\t\t\t// r_config_set (r->config, \"asm.arch\", info->arch);\n\t\t\t// r_core_seek (r, 0, 1);\n\t\t\t// eprintf (\"m /root %s 0\", info->arch);\n\t//\t\tr_core_cmdf (r, \"m /root hfs @ 0\", info->arch);\n\t\t} else {\n\t\t\tif (info->lang) {\n\t\t\t\tr_config_set (r->config, \"bin.lang\", info->lang);\n\t\t\t}\n\t\t\tr_config_set (r->config, \"asm.os\", info->os);\n\t\t\tif (info->rclass && !strcmp (info->rclass, \"pe\")) {\n\t\t\t\tr_config_set (r->config, \"anal.cpp.abi\", \"msvc\");\n\t\t\t} else {\n\t\t\t\tr_config_set (r->config, \"anal.cpp.abi\", \"itanium\");\n\t\t\t}\n\t\t\tr_config_set (r->config, \"asm.arch\", info->arch);\n\t\t\tif (info->cpu && *info->cpu) {\n\t\t\t\tr_config_set (r->config, \"asm.cpu\", info->cpu);\n\t\t\t}\n\t\t\tr_config_set (r->config, \"anal.arch\", info->arch);\n\t\t\tsnprintf (str, R_FLAG_NAME_SIZE, \"%i\", info->bits);\n\t\t\tr_config_set (r->config, \"asm.bits\", str);\n\t\t\tr_config_set (r->config, \"asm.dwarf\",\n\t\t\t\t(R_BIN_DBG_STRIPPED & info->dbg_info) ? \"false\" : \"true\");\n\t\t\tv = r_anal_archinfo (r->anal, R_ANAL_ARCHINFO_ALIGN);\n\t\t\tif (v != -1) r_config_set_i (r->config, \"asm.pcalign\", v);\n\t\t}\n\t} else if (IS_MODE_SIMPLE (mode)) {\n\t\tr_cons_printf (\"arch %s\\n\", info->arch);\n\t\tif (info->cpu && *info->cpu) {\n\t\t\tr_cons_printf (\"cpu %s\\n\", info->cpu);\n\t\t}\n\t\tr_cons_printf (\"bits %d\\n\", info->bits);\n\t\tr_cons_printf (\"os %s\\n\", info->os);\n\t\tr_cons_printf (\"endian %s\\n\", info->big_endian? \"big\": \"little\");\n\t\tv = r_anal_archinfo (r->anal, R_ANAL_ARCHINFO_MIN_OP_SIZE);\n\t\tif (v != -1) {\n\t\t\tr_cons_printf (\"minopsz %d\\n\", v);\n\t\t}\n\t\tv = r_anal_archinfo (r->anal, R_ANAL_ARCHINFO_MAX_OP_SIZE);\n\t\tif (v != -1) {\n\t\t\tr_cons_printf (\"maxopsz %d\\n\", v);\n\t\t}\n\t\tv = r_anal_archinfo (r->anal, R_ANAL_ARCHINFO_ALIGN);\n\t\tif (v != -1) {\n\t\t\tr_cons_printf (\"pcalign %d\\n\", v);\n\t\t}\n\t} else if (IS_MODE_RAD (mode)) {\n\t\tif (info->type && !strcmp (info->type, \"fs\")) {\n\t\t\tr_cons_printf (\"e file.type=fs\\n\");\n\t\t\tr_cons_printf (\"m /root %s 0\\n\", info->arch);\n\t\t} else {\n\t\t\tr_cons_printf (\"e cfg.bigendian=%s\\n\"\n\t\t\t\t\"e asm.bits=%i\\n\"\n\t\t\t\t\"e asm.dwarf=%s\\n\",\n\t\t\t\tr_str_bool (info->big_endian),\n\t\t\t\tinfo->bits,\n\t\t\t\tr_str_bool (R_BIN_DBG_STRIPPED &info->dbg_info));\n\t\t\tif (info->lang && *info->lang) {\n\t\t\t\tr_cons_printf (\"e bin.lang=%s\\n\", info->lang);\n\t\t\t}\n\t\t\tif (info->rclass && *info->rclass) {\n\t\t\t\tr_cons_printf (\"e file.type=%s\\n\",\n\t\t\t\t\tinfo->rclass);\n\t\t\t}\n\t\t\tif (info->os) {\n\t\t\t\tr_cons_printf (\"e asm.os=%s\\n\", info->os);\n\t\t\t}\n\t\t\tif (info->arch) {\n\t\t\t\tr_cons_printf (\"e asm.arch=%s\\n\", info->arch);\n\t\t\t}\n\t\t\tif (info->cpu && *info->cpu) {\n\t\t\t\tr_cons_printf (\"e asm.cpu=%s\\n\", info->cpu);\n\t\t\t}\n\t\t\tv = r_anal_archinfo (r->anal, R_ANAL_ARCHINFO_ALIGN);\n\t\t\tif (v != -1) r_cons_printf (\"e asm.pcalign=%d\\n\", v);\n\t\t}\n\t} else {\n\t\t// XXX: if type is 'fs' show something different?\n\t\tchar *tmp_buf;\n\t\tif (IS_MODE_JSON (mode)) {\n\t\t\tr_cons_printf (\"{\");\n\t\t}\n\t\tpair_str (\"arch\", info->arch, mode, false);\n\t\tif (info->cpu && *info->cpu) {\n\t\t\tpair_str (\"cpu\", info->cpu, mode, false);\n\t\t}\n\t\tpair_ut64 (\"binsz\", r_bin_get_size (r->bin), mode, false);\n\t\tpair_str (\"bintype\", info->rclass, mode, false);\n\t\tpair_int (\"bits\", info->bits, mode, false);\n\t\tpair_bool (\"canary\", info->has_canary, mode, false);\n\t\tpair_str (\"class\", info->bclass, mode, false);\n\t\tif (info->actual_checksum) {\n\t\t\t/* computed checksum */\n\t\t\tpair_str (\"cmp.csum\", info->actual_checksum, mode, false);\n\t\t}\n\t\tpair_str (\"compiled\", compiled, mode, false);\n\t\tpair_bool (\"crypto\", info->has_crypto, mode, false);\n\t\tpair_str (\"dbg_file\", info->debug_file_name, mode, false);\n\t\tpair_str (\"endian\", info->big_endian ? \"big\" : \"little\", mode, false);\n\t\tif (info->rclass && !strcmp (info->rclass, \"mdmp\")) {\n\t\t\ttmp_buf = sdb_get (binfile->sdb, \"mdmp.flags\", 0);\n\t\t\tif (tmp_buf) {\n\t\t\t\tpair_str (\"flags\", tmp_buf, mode, false);\n\t\t\t\tfree (tmp_buf);\n\t\t\t}\n\t\t}\n\t\tpair_bool (\"havecode\", havecode, mode, false);\n\t\tif (info->claimed_checksum) {\n\t\t\t/* checksum specified in header */\n\t\t\tpair_str (\"hdr.csum\", info->claimed_checksum, mode, false);\n\t\t}\n\t\tpair_str (\"guid\", info->guid, mode, false);\n\t\tpair_str (\"intrp\", info->intrp, mode, false);\n\t\tpair_str (\"lang\", info->lang, mode, false);\n\t\tpair_bool (\"linenum\", R_BIN_DBG_LINENUMS & info->dbg_info, mode, false);\n\t\tpair_bool (\"lsyms\", R_BIN_DBG_SYMS & info->dbg_info, mode, false);\n\t\tpair_str (\"machine\", info->machine, mode, false);\n\t\tv = r_anal_archinfo (r->anal, R_ANAL_ARCHINFO_MAX_OP_SIZE);\n\t\tif (v != -1) {\n\t\t\tpair_int (\"maxopsz\", v, mode, false);\n\t\t}\n\t\tv = r_anal_archinfo (r->anal, R_ANAL_ARCHINFO_MIN_OP_SIZE);\n\t\tif (v != -1) {\n\t\t\tpair_int (\"minopsz\", v, mode, false);\n\t\t}\n\t\tpair_bool (\"nx\", info->has_nx, mode, false);\n\t\tpair_str (\"os\", info->os, mode, false);\n\t\tif (info->rclass && !strcmp (info->rclass, \"pe\")) {\n\t\t\tpair_bool (\"overlay\", info->pe_overlay, mode, false);\n\t\t}\n\t\tv = r_anal_archinfo (r->anal, R_ANAL_ARCHINFO_ALIGN);\n\t\tif (v != -1) {\n\t\t\tpair_int (\"pcalign\", v, mode, false);\n\t\t}\n\t\tpair_bool (\"pic\", info->has_pi, mode, false);\n\t\tpair_bool (\"relocs\", R_BIN_DBG_RELOCS & info->dbg_info, mode, false);\n\t\ttmp_buf = sdb_get (obj->kv, \"elf.relro\", 0);\n\t\tif (tmp_buf) {\n\t\t\tpair_str (\"relro\", tmp_buf, mode, false);\n\t\t\tfree (tmp_buf);\n\t\t}\n\t\tpair_str (\"rpath\", info->rpath, mode, false);\n\t\tif (info->rclass && !strcmp (info->rclass, \"pe\")) {\n\t\t\t//this should be moved if added to mach0 (or others)\n\t\t\tpair_bool (\"signed\", info->signature, mode, false);\n\t\t}\n\t\tpair_bool (\"static\", r_bin_is_static (r->bin), mode, false);\n\t\tif (info->rclass && !strcmp (info->rclass, \"mdmp\")) {\n\t\t\tv = sdb_num_get (binfile->sdb, \"mdmp.streams\", 0);\n\t\t\tif (v != -1) {\n\t\t\t\tpair_int (\"streams\", v, mode, false);\n\t\t\t}\n\t\t}\n\t\tpair_bool (\"stripped\", R_BIN_DBG_STRIPPED & info->dbg_info, mode, false);\n\t\tpair_str (\"subsys\", info->subsystem, mode, false);\n\t\tpair_bool (\"va\", info->has_va, mode, true);\n\t\tif (IS_MODE_JSON (mode)) {\n\t\t\tr_cons_printf (\",\\\"checksums\\\":{\");\n\t\t\tfor (i = 0; info->sum[i].type; i++) {\n\t\t\t\tRBinHash *h = &info->sum[i];\n\t\t\t\tut64 hash = r_hash_name_to_bits (h->type);\n\t\t\t\tRHash *rh = r_hash_new (true, hash);\n\t\t\t\tint len = r_hash_calculate (rh, hash, (const ut8*)\n\t\t\t\t\t\tbinfile->buf->buf+h->from, h->to);\n\t\t\t\tif (len < 1) {\n\t\t\t\t\teprintf (\"Invaild checksum length\\n\");\n\t\t\t\t}\n\t\t\t\tr_hash_free (rh);\n\t\t\t\tr_cons_printf (\"%s\\\"%s\\\":{\\\"hex\\\":\\\"\", i?\",\": \"\", h->type);\n\t\t\t\t// r_cons_printf (\"%s\\t%d-%dc\\t\", h->type, h->from, h->to+h->from);\n\t\t\t\tfor (j = 0; j < h->len; j++) {\n\t\t\t\t\tr_cons_printf (\"%02x\", h->buf[j]);\n\t\t\t\t}\n\t\t\t\tr_cons_printf (\"\\\"}\");\n\t\t\t}\n\t\t\tr_cons_printf (\"}\");\n\t\t} else {\n\t\t\tfor (i = 0; info->sum[i].type; i++) {\n\t\t\t\tRBinHash *h = &info->sum[i];\n\t\t\t\tut64 hash = r_hash_name_to_bits (h->type);\n\t\t\t\tRHash *rh = r_hash_new (true, hash);\n\t\t\t\tint len = r_hash_calculate (rh, hash, (const ut8*)\n\t\t\t\t\t\tbinfile->buf->buf+h->from, h->to);\n\t\t\t\tif (len < 1) {\n\t\t\t\t\teprintf (\"Invaild wtf\\n\");\n\t\t\t\t}\n\t\t\t\tr_hash_free (rh);\n\t\t\t\tr_cons_printf (\"%s  %d-%dc  \", h->type, h->from, h->to+h->from);\n\t\t\t\tfor (j = 0; j < h->len; j++) {\n\t\t\t\t\tr_cons_printf (\"%02x\", h->buf[j]);\n\t\t\t\t}\n\t\t\t\tr_cons_newline ();\n\t\t\t}\n\t\t}\n\t\tif (IS_MODE_JSON (mode)) r_cons_printf (\"}\");\n\t}\n\tr_core_anal_type_init (r);\n\tr_core_anal_cc_init (r);\n\treturn true;\n}\n\nstatic int bin_dwarf(RCore *core, int mode) {\n\tRBinDwarfRow *row;\n\tRListIter *iter;\n\tRList *list = NULL;\n\tif (!r_config_get_i (core->config, \"bin.dbginfo\")) {\n\t\treturn false;\n\t}\n\tRBinFile *binfile = r_core_bin_cur (core);\n\tRBinPlugin * plugin = r_bin_file_cur_plugin (binfile);\n\tif (!binfile) {\n\t\treturn false;\n\t}\n\tif (plugin && plugin->lines) {\n\t\tlist = plugin->lines (binfile);\n\t} else if (core->bin) {\n\t\t// TODO: complete and speed-up support for dwarf\n\t\tRBinDwarfDebugAbbrev *da = NULL;\n\t\tda = r_bin_dwarf_parse_abbrev (core->bin, mode);\n\t\tr_bin_dwarf_parse_info (da, core->bin, mode);\n\t\tr_bin_dwarf_parse_aranges (core->bin, mode);\n\t\tlist = r_bin_dwarf_parse_line (core->bin, mode);\n\t\tr_bin_dwarf_free_debug_abbrev (da);\n\t\tfree (da);\n\t}\n\tif (!list) {\n\t\treturn false;\n\t}\n\n\tr_cons_break_push (NULL, NULL);\n\t/* cache file:line contents */\n\tconst char *lastFile = NULL;\n\tint *lastFileLines = NULL;\n\tchar *lastFileContents = NULL;\n\tint lastFileLinesCount = 0;\n\n\t/* ugly dupe for speedup */\n\tconst char *lastFile2 = NULL;\n\tint *lastFileLines2 = NULL;\n\tchar *lastFileContents2 = NULL;\n\tint lastFileLinesCount2 = 0;\n\n\tconst char *lf = NULL;\n\tint *lfl = NULL;\n\tchar *lfc = NULL;\n\tint lflc = 0;\n\n\t//TODO we should need to store all this in sdb, or do a filecontentscache in libr/util\n\t//XXX this whole thing has leaks\n\tr_list_foreach (list, iter, row) {\n\t\tif (r_cons_is_breaked ()) {\n\t\t\tbreak;\n\t\t}\n\t\tif (mode) {\n\t\t\t// TODO: use 'Cl' instead of CC\n\t\t\tconst char *path = row->file;\n\t\t\tif (!lastFile || strcmp (path, lastFile)) {\n\t\t\t\tif (lastFile && lastFile2 && !strcmp (path, lastFile2)) {\n\t\t\t\t\tlf = lastFile;\n\t\t\t\t\tlfl = lastFileLines;\n\t\t\t\t\tlfc = lastFileContents;\n\t\t\t\t\tlflc = lastFileLinesCount;\n\t\t\t\t\tlastFile = lastFile2;\n\t\t\t\t\tlastFileLines = lastFileLines2;\n\t\t\t\t\tlastFileContents = lastFileContents2;\n\t\t\t\t\tlastFileLinesCount = lastFileLinesCount2;\n\t\t\t\t\tlastFile2 = lf;\n\t\t\t\t\tlastFileLines2 = lfl;\n\t\t\t\t\tlastFileContents2 = lfc;\n\t\t\t\t\tlastFileLinesCount2 = lflc;\n\t\t\t\t} else {\n\t\t\t\t\tlastFile2 = lastFile;\n\t\t\t\t\tlastFileLines2 = lastFileLines;\n\t\t\t\t\tlastFileContents2 = lastFileContents;\n\t\t\t\t\tlastFileLinesCount2 = lastFileLinesCount;\n\t\t\t\t\tlastFile = path;\n\t\t\t\t\tlastFileContents = r_file_slurp (path, NULL);\n\t\t\t\t\tif (lastFileContents) {\n\t\t\t\t\t\tlastFileLines = r_str_split_lines (lastFileContents, &lastFileLinesCount);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tchar *line = NULL;\n\t\t\t//r_file_slurp_line (path, row->line - 1, 0);\n\t\t\tif (lastFileLines && lastFileContents) {\n\t\t\t\tint nl = row->line - 1;\n\t\t\t\tif (nl >= 0 && nl < lastFileLinesCount) {\n\t\t\t\t\tline = strdup (lastFileContents + lastFileLines[nl]);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tline = NULL;\n\t\t\t}\n\t\t\tif (line) {\n\t\t\t\tr_str_filter (line, strlen (line));\n\t\t\t\tline = r_str_replace (line, \"\\\"\", \"\\\\\\\"\", 1);\n\t\t\t\tline = r_str_replace (line, \"\\\\\\\\\", \"\\\\\", 1);\n\t\t\t}\n\t\t\tbool chopPath = !r_config_get_i (core->config, \"dir.dwarf.abspath\");\n\t\t\tchar *file = strdup (row->file);\n\t\t\tif (chopPath) {\n\t\t\t\tconst char *slash = r_str_lchr (file, '/');\n\t\t\t\tif (slash) {\n\t\t\t\t\tmemmove (file, slash + 1, strlen (slash));\n\t\t\t\t}\n\t\t\t}\n\t\t\t// TODO: implement internal : if ((mode & R_CORE_BIN_SET))\n\t\t\tif ((mode & R_CORE_BIN_SET)) {\n\t\t\t\t// TODO: use CL here.. but its not necessary.. so better not do anything imho\n\t\t\t\t// r_core_cmdf (core, \"CL %s:%d 0x%08\"PFMT64x, file, (int)row->line, row->address);\n#if 0\n\t\t\t\tchar *cmt = r_str_newf (\"%s:%d %s\", file, (int)row->line, line? line: \"\");\n\t\t\t\tr_meta_set_string (core->anal, R_META_TYPE_COMMENT, row->address, cmt);\n\t\t\t\tfree (cmt);\n#endif\n\t\t\t} else {\n\t\t\t\tr_cons_printf (\"CL %s:%d 0x%08\" PFMT64x \"\\n\",\n\t\t\t\t\t       file, (int)row->line,\n\t\t\t\t\t       row->address);\n\t\t\t\tr_cons_printf (\"\\\"CC %s:%d %s\\\"@0x%\" PFMT64x\n\t\t\t\t\t       \"\\n\",\n\t\t\t\t\t       file, row->line,\n\t\t\t\t\t       line ? line : \"\", row->address);\n\t\t\t}\n\t\t\tfree (file);\n\t\t\tfree (line);\n\t\t} else {\n\t\t\tr_cons_printf (\"0x%08\" PFMT64x \"\\t%s\\t%d\\n\",\n\t\t\t\t       row->address, row->file, row->line);\n\t\t}\n\t}\n\tr_cons_break_pop ();\n\tR_FREE (lastFileContents);\n\tR_FREE (lastFileContents2);\n\t// this list is owned by rbin, not us, we shouldnt free it\n\t// r_list_free (list);\n\tfree (lastFileLines);\n\treturn true;\n}\n\nR_API int r_core_pdb_info(RCore *core, const char *file, ut64 baddr, int mode) {\n\tR_PDB pdb = R_EMPTY;\n\n\tpdb.cb_printf = r_cons_printf;\n\tif (!init_pdb_parser (&pdb, file)) {\n\t\treturn false;\n\t}\n\tif (!pdb.pdb_parse (&pdb)) {\n\t\teprintf (\"pdb was not parsed\\n\");\n\t\tpdb.finish_pdb_parse (&pdb);\n\t\treturn false;\n\t}\n\tif (mode == R_CORE_BIN_JSON) {\n\t\tr_cons_printf(\"[\");\n\t}\n\n\tswitch (mode) {\n\tcase R_CORE_BIN_SET:\n\t\tmode = 's';\n\t\tr_core_cmd0 (core, \".iP*\");\n\t\treturn true;\n\tcase R_CORE_BIN_JSON:\n\t\tmode = 'j';\n\t\tbreak;\n\tcase '*':\n\tcase 1:\n\t\tmode = 'r';\n\t\tbreak;\n\tdefault:\n\t\tmode = 'd'; // default\n\t\tbreak;\n\t}\n\n\tpdb.print_types (&pdb, mode);\n\tif (mode == 'j') {\n\t\tr_cons_printf (\",\");\n\t}\n\tpdb.print_gvars (&pdb, baddr, mode);\n\tif (mode == 'j') {\n\t\tr_cons_printf (\"]\");\n\t}\n\tpdb.finish_pdb_parse (&pdb);\n\n\treturn true;\n}\n\nstatic int bin_pdb(RCore *core, int mode) {\n\tut64 baddr = r_bin_get_baddr (core->bin);\n\treturn r_core_pdb_info (core, core->bin->file, baddr, mode);\n}\n\nstatic int bin_main(RCore *r, int mode, int va) {\n\tRBinAddr *binmain = r_bin_get_sym (r->bin, R_BIN_SYM_MAIN);\n\tut64 addr;\n\tif (!binmain) {\n\t\treturn false;\n\t}\n\taddr = va ? r_bin_a2b (r->bin, binmain->vaddr) : binmain->paddr;\n\n\tif (IS_MODE_SET (mode)) {\n\t\tr_flag_space_set (r->flags, \"symbols\");\n\t\tr_flag_set (r->flags, \"main\", addr, r->blocksize);\n\t} else if (IS_MODE_SIMPLE (mode)) {\n\t\tr_cons_printf (\"%\"PFMT64d, addr);\n\t} else if (IS_MODE_RAD (mode)) {\n\t\tr_cons_printf (\"fs symbols\\n\");\n\t\tr_cons_printf (\"f main @ 0x%08\"PFMT64x\"\\n\", addr);\n\t} else if (IS_MODE_JSON (mode)) {\n\t\tr_cons_printf (\"{\\\"vaddr\\\":%\" PFMT64d\n\t\t\t\",\\\"paddr\\\":%\" PFMT64d \"}\", addr, binmain->paddr);\n\t} else {\n\t\tr_cons_printf (\"[Main]\\n\");\n\t\tr_cons_printf (\"vaddr=0x%08\"PFMT64x\" paddr=0x%08\"PFMT64x\"\\n\",\n\t\t\taddr, binmain->paddr);\n\t}\n\treturn true;\n}\n\nstatic int bin_entry(RCore *r, int mode, ut64 laddr, int va, bool inifin) {\n\tchar str[R_FLAG_NAME_SIZE];\n\tRList *entries = r_bin_get_entries (r->bin);\n\tRListIter *iter;\n\tRBinAddr *entry = NULL;\n\tint i = 0;\n\tut64 baddr = r_bin_get_baddr (r->bin);\n\n\tif (IS_MODE_RAD (mode)) {\n\t\tr_cons_printf (\"fs symbols\\n\");\n\t} else if (IS_MODE_JSON (mode)) {\n\t\tr_cons_printf (\"[\");\n\t} else if (IS_MODE_NORMAL (mode)) {\n\t\tif (inifin) {\n\t\t\tr_cons_printf (\"[Constructors]\\n\");\n\t\t} else {\n\t\t\tr_cons_printf (\"[Entrypoints]\\n\");\n\t\t}\n\t}\n\n\tr_list_foreach (entries, iter, entry) {\n\t\tut64 paddr = entry->paddr;\n\t\tut64 haddr = UT64_MAX;\n\t\tif (mode != R_CORE_BIN_SET) {\n\t\t\tif (inifin) {\n\t\t\t\tif (entry->type == R_BIN_ENTRY_TYPE_PROGRAM) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (entry->type != R_BIN_ENTRY_TYPE_PROGRAM) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tswitch (entry->type) {\n\t\tcase R_BIN_ENTRY_TYPE_INIT:\n\t\tcase R_BIN_ENTRY_TYPE_FINI:\n\t\tcase R_BIN_ENTRY_TYPE_PREINIT:\n\t\t\tif (r->io->va && entry->paddr == entry->vaddr) {\n\t\t\t\tRIOMap *map = r_io_map_get (r->io, entry->vaddr);\n\t\t\t\tif (map) {\n\t\t\t\t\tpaddr = entry->vaddr - map->itv.addr + map->delta;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (entry->haddr) {\n\t\t\thaddr = entry->haddr;\n\t\t}\n\t\tut64 at = rva (r->bin, paddr, entry->vaddr, va);\n\t\tconst char *type = r_bin_entry_type_string (entry->type);\n\t\tif (!type) {\n\t\t\ttype = \"unknown\";\n\t\t}\n\t\tif (IS_MODE_SET (mode)) {\n\t\t\tr_flag_space_set (r->flags, \"symbols\");\n\t\t\tif (entry->type == R_BIN_ENTRY_TYPE_INIT) {\n\t\t\t\tsnprintf (str, R_FLAG_NAME_SIZE, \"entry%i.init\", i);\n\t\t\t} else if (entry->type == R_BIN_ENTRY_TYPE_FINI) {\n\t\t\t\tsnprintf (str, R_FLAG_NAME_SIZE, \"entry%i.fini\", i);\n\t\t\t} else if (entry->type == R_BIN_ENTRY_TYPE_PREINIT) {\n\t\t\t\tsnprintf (str, R_FLAG_NAME_SIZE, \"entry%i.preinit\", i);\n\t\t\t} else {\n\t\t\t\tsnprintf (str, R_FLAG_NAME_SIZE, \"entry%i\", i);\n\t\t\t}\n\t\t\tr_flag_set (r->flags, str, at, 1);\n\t\t} else if (IS_MODE_SIMPLE (mode)) {\n\t\t\tr_cons_printf (\"0x%08\"PFMT64x\"\\n\", at);\n\t\t} else if (IS_MODE_JSON (mode)) {\n\t\t\tr_cons_printf (\"%s{\\\"vaddr\\\":%\" PFMT64d \",\"\n\t\t\t\t\"\\\"paddr\\\":%\" PFMT64d \",\"\n\t\t\t\t\"\\\"baddr\\\":%\" PFMT64d \",\"\n\t\t\t\t\"\\\"laddr\\\":%\" PFMT64d \",\"\n\t\t\t\t\"\\\"haddr\\\":%\" PFMT64d \",\"\n\t\t\t\t\"\\\"type\\\":\\\"%s\\\"}\",\n\t\t\t\titer->p ? \",\" : \"\", at, paddr, baddr, laddr, haddr, type);\n\t\t} else if (IS_MODE_RAD (mode)) {\n\t\t\tchar *name = NULL;\n\t\t\tif (entry->type == R_BIN_ENTRY_TYPE_INIT) {\n\t\t\t\tname = r_str_newf (\"entry%i.init\", i);\n\t\t\t} else if (entry->type == R_BIN_ENTRY_TYPE_FINI) {\n\t\t\t\tname = r_str_newf (\"entry%i.fini\", i);\n\t\t\t} else if (entry->type == R_BIN_ENTRY_TYPE_PREINIT) {\n\t\t\t\tname = r_str_newf (\"entry%i.preinit\", i);\n\t\t\t} else {\n\t\t\t\tname = r_str_newf (\"entry%i\", i);\n\t\t\t}\n\t\t\tr_cons_printf (\"f %s 1 @ 0x%08\"PFMT64x\"\\n\", name, at);\n\t\t\tr_cons_printf (\"f %s_haddr 1 @ 0x%08\"PFMT64x\"\\n\", name, haddr);\n\t\t\tr_cons_printf (\"s %s\\n\", name);\n\t\t\tfree (name);\n\t\t} else {\n\t\t\tr_cons_printf (\n\t\t\t\t \"vaddr=0x%08\"PFMT64x\n\t\t\t\t\" paddr=0x%08\"PFMT64x\n\t\t\t\t\" baddr=0x%08\"PFMT64x\n\t\t\t\t\" laddr=0x%08\"PFMT64x,\n\t\t\t\tat, paddr, baddr, laddr);\n\t\t\tif (haddr == UT64_MAX) {\n\t\t\t\tr_cons_printf (\n\t\t\t\t\t\" haddr=%\"PFMT64d\n\t\t\t\t\t\" type=%s\\n\",\n\t\t\t\t\thaddr, type);\n\t\t\t} else {\n\t\t\t\tr_cons_printf (\n\t\t\t\t\t\" haddr=0x%08\"PFMT64x\n\t\t\t\t\t\" type=%s\\n\",\n\t\t\t\t\thaddr, type);\n\t\t\t}\n\t\t}\n\t\ti++;\n\t}\n\tif (IS_MODE_SET (mode)) {\n\t\tif (entry) {\n\t\t\tut64 at = rva (r->bin, entry->paddr, entry->vaddr, va);\n\t\t\tr_core_seek (r, at, 0);\n\t\t}\n\t} else if (IS_MODE_JSON (mode)) {\n\t\tr_cons_printf (\"]\");\n\t\tr_cons_newline ();\n\t} else if (IS_MODE_NORMAL (mode)) {\n\t\tr_cons_printf (\"\\n%i entrypoints\\n\", i);\n\t}\n\treturn true;\n}\n\nstatic const char *bin_reloc_type_name(RBinReloc *reloc) {\n#define CASE(T) case R_BIN_RELOC_ ## T: return reloc->additive ? \"ADD_\" #T : \"SET_\" #T\n\tswitch (reloc->type) {\n\t\tCASE(8);\n\t\tCASE(16);\n\t\tCASE(32);\n\t\tCASE(64);\n\t}\n\treturn \"UNKNOWN\";\n#undef CASE\n}\n\nstatic ut8 bin_reloc_size(RBinReloc *reloc) {\n#define CASE(T) case R_BIN_RELOC_ ## T: return T / 8\n\tswitch (reloc->type) {\n\t\tCASE(8);\n\t\tCASE(16);\n\t\tCASE(32);\n\t\tCASE(64);\n\t}\n\treturn 0;\n#undef CASE\n}\n\nstatic char *resolveModuleOrdinal(Sdb *sdb, const char *module, int ordinal) {\n\tSdb *db = sdb;\n\tchar *foo = sdb_get (db, sdb_fmt (\"%d\", ordinal), 0);\n\treturn (foo && *foo) ? foo : NULL;\n}\n\nstatic char *get_reloc_name(RBinReloc *reloc, ut64 addr) {\n\tchar *reloc_name = NULL;\n\tif (reloc->import && reloc->import->name) {\n\t\treloc_name = sdb_fmt (\"reloc.%s_%d\", reloc->import->name,\n\t\t\t\t      (int)(addr & 0xff));\n\t\tif (!reloc_name) {\n\t\t\treturn NULL;\n\t\t}\n\t\tr_str_replace_char (reloc_name, '$', '_');\n\t} else if (reloc->symbol && reloc->symbol->name) {\n\t\treloc_name = sdb_fmt (\"reloc.%s_%d\", reloc->symbol->name, (int)(addr & 0xff));\n\t\tif (!reloc_name) {\n\t\t\treturn NULL;\n\t\t}\n\t\tr_str_replace_char (reloc_name, '$', '_');\n\t} else if (reloc->is_ifunc) {\n\t\t// addend is the function pointer for the resolving ifunc\n\t\treloc_name = sdb_fmt (\"reloc.ifunc_%\"PFMT64x, reloc->addend);\n\t} else {\n\t\t// TODO(eddyb) implement constant relocs.\n\t}\n\treturn reloc_name;\n}\n\nstatic void set_bin_relocs(RCore *r, RBinReloc *reloc, ut64 addr, Sdb **db, char **sdb_module) {\n\tint bin_demangle = r_config_get_i (r->config, \"bin.demangle\");\n\tconst char *lang = r_config_get (r->config, \"bin.lang\");\n\tchar *reloc_name, *demname = NULL;\n\tbool is_pe = true;\n\tint is_sandbox = r_sandbox_enable (0);\n\n\tif (reloc->import && reloc->import->name[0]) {\n\t\tchar str[R_FLAG_NAME_SIZE];\n\t\tRFlagItem *fi;\n\n\t\tif (is_pe && !is_sandbox && strstr (reloc->import->name, \"Ordinal\")) {\n\t\t\tconst char *TOKEN = \".dll_Ordinal_\";\n\t\t\tchar *module = strdup (reloc->import->name);\n\t\t\tchar *import = strstr (module, TOKEN);\n\n\t\t\tr_str_case (module, false);\n\t\t\tif (import) {\n\t\t\t\tchar *filename = NULL;\n\t\t\t\tint ordinal;\n\t\t\t\t*import = 0;\n\t\t\t\timport += strlen (TOKEN);\n\t\t\t\tordinal = atoi (import);\n\t\t\t\tif (!*sdb_module || strcmp (module, *sdb_module)) {\n\t\t\t\t\tsdb_free (*db);\n\t\t\t\t\t*db = NULL;\n\t\t\t\t\tfree (*sdb_module);\n\t\t\t\t\t*sdb_module = strdup (module);\n\t\t\t\t\t/* always lowercase */\n\t\t\t\t\tfilename = sdb_fmt (\"%s.sdb\", module);\n\t\t\t\t\tr_str_case (filename, false);\n\t\t\t\t\tif (r_file_exists (filename)) {\n\t\t\t\t\t\t*db = sdb_new (NULL, filename, 0);\n\t\t\t\t\t} else {\n\t\t\t\t\t// XXX. we have dir.prefix, windows shouldnt work different\n\t\t\t\t\t\tfilename = sdb_fmt (\"%s/share/radare2/\" R2_VERSION\"/format/dll/%s.sdb\", r_config_get (r->config, \"dir.prefix\"), module);\n\t\t\t\t\t\tif (r_file_exists (filename)) {\n\t\t\t\t\t\t\t*db = sdb_new (NULL, filename, 0);\n#if __WINDOWS__\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tchar invoke_dir[MAX_PATH];\n\t\t\t\t\t\t\tif (r_sys_get_src_dir_w32 (invoke_dir)) {\n\t\t\t\t\t\t\t\tfilename = sdb_fmt (\"%s/share/radare2/\"R2_VERSION \"/format/dll/%s.sdb\", invoke_dir, module);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tfilename = sdb_fmt (\"share/radare2/\"R2_VERSION\"/format/dll/%s.sdb\", module);\n\t\t\t\t\t\t\t}\n#else\n\t\t\t\t\t\t\tfilename = sdb_fmt (\"%s/share/radare2/\" R2_VERSION\"/format/dll/%s.sdb\", r_config_get (r->config, \"dir.prefix\"), module);\n\t\t\t\t\t\t\tif (r_file_exists (filename)) {\n\t\t\t\t\t\t\t\t*db = sdb_new (NULL, filename, 0);\n\t\t\t\t\t\t\t}\n#endif\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (*db) {\n\t\t\t\t\t// ordinal-1 because we enumerate starting at 0\n\t\t\t\t\tchar *symname = resolveModuleOrdinal (*db, module, ordinal - 1);  // uses sdb_get\n\t\t\t\t\tif (symname) {\n\t\t\t\t\t\tif (r->bin->prefix) {\n\t\t\t\t\t\t\treloc->import->name = r_str_newf\n\t\t\t\t\t\t\t\t(\"%s.%s.%s\", r->bin->prefix, module, symname);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treloc->import->name = r_str_newf\n\t\t\t\t\t\t\t\t(\"%s.%s\", module, symname);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tR_FREE (symname);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfree (module);\n\t\t\tr_anal_hint_set_size (r->anal, reloc->vaddr, 4);\n\t\t\tr_meta_add (r->anal, R_META_TYPE_DATA, reloc->vaddr, reloc->vaddr+4, NULL);\n\t\t}\n\t\treloc_name = reloc->import->name;\n\t\tif (r->bin->prefix) {\n\t\t\tsnprintf (str, R_FLAG_NAME_SIZE, \"%s.reloc.%s\", r->bin->prefix, reloc_name);\n\t\t} else {\n\t\t\tsnprintf (str, R_FLAG_NAME_SIZE, \"reloc.%s\", reloc_name);\n\t\t}\n\t\tif (bin_demangle) {\n\t\t\tdemname = r_bin_demangle (r->bin->cur, lang, str, addr);\n\t\t}\n\t\tr_name_filter (str, 0);\n\t\tfi = r_flag_set (r->flags, str, addr, bin_reloc_size (reloc));\n\t\tif (demname) {\n\t\t\tchar *realname;\n\t\t\tif (r->bin->prefix) {\n\t\t\t\trealname = sdb_fmt (\"%s.reloc.%s\", r->bin->prefix, demname);\n\t\t\t} else {\n\t\t\t\trealname = sdb_fmt (\"reloc.%s\", demname);\n\t\t\t}\n\t\t\tr_flag_item_set_realname (fi, realname);\n\t\t}\n\t} else {\n\t\tchar *reloc_name = get_reloc_name (reloc, addr);\n\t\tr_flag_set (r->flags, reloc_name, addr, bin_reloc_size (reloc));\n\t}\n}\n\n/* Define new data at relocation address if it's not in an executable section */\nstatic void add_metadata(RCore *r, RBinReloc *reloc, ut64 addr, int mode) {\n\tRBinFile * binfile = r->bin->cur;\n\tRBinObject *binobj = binfile ? binfile->o: NULL;\n\tRBinInfo *info = binobj ? binobj->info: NULL;\n\tRIOSection *section;\n\tint cdsz;\n\n\tcdsz = info? (info->bits == 64? 8: info->bits == 32? 4: info->bits == 16 ? 4: 0): 0;\n\tif (cdsz == 0) {\n\t\treturn;\n\t}\n\n\tsection = r_io_section_vget (r->io, addr);\n\tif (!section || section->flags & R_IO_EXEC) {\n\t\treturn;\n\t}\n\n\tif (IS_MODE_SET(mode)) {\n\t\tr_meta_add (r->anal, R_META_TYPE_DATA, reloc->vaddr, reloc->vaddr + cdsz, NULL);\n\t} else if (IS_MODE_RAD (mode)) {\n\t\tr_cons_printf (\"f Cd %d @ 0x%08\" PFMT64x \"\\n\", cdsz, addr);\n\t}\n}\n\nstatic bool is_section_symbol(RBinSymbol *s) {\n\t/* workaround for some bin plugs (e.g. ELF) */\n\tif (!s || *s->name) {\n\t\treturn false;\n\t}\n\treturn (s->type && !strcmp (s->type, \"SECTION\"));\n}\n\nstatic bool is_section_reloc(RBinReloc *r) {\n\treturn is_section_symbol (r->symbol);\n}\n\nstatic bool is_file_symbol(RBinSymbol *s) {\n\t/* workaround for some bin plugs (e.g. ELF) */\n\treturn (s && s->type && !strcmp (s->type, \"FILE\"));\n}\n\nstatic bool is_file_reloc(RBinReloc *r) {\n\treturn is_file_symbol (r->symbol);\n}\n\nstatic int bin_relocs(RCore *r, int mode, int va) {\n\tbool bin_demangle = r_config_get_i (r->config, \"bin.demangle\");\n\tRList *relocs;\n\tRListIter *iter;\n\tRBinReloc *reloc = NULL;\n\tSdb *db = NULL;\n\tchar *sdb_module = NULL;\n\tint i = 0;\n\n\tva = VA_TRUE; // XXX relocs always vaddr?\n\t//this has been created for reloc object files\n\trelocs = r_bin_patch_relocs (r->bin);\n\tif (!relocs) {\n\t\trelocs = r_bin_get_relocs (r->bin);\n\t}\n\n\tif (IS_MODE_RAD (mode)) {\n\t\tr_cons_println (\"fs relocs\");\n\t} else if (IS_MODE_NORMAL (mode)) {\n\t\tr_cons_println (\"[Relocations]\");\n\t} else if (IS_MODE_JSON (mode)) {\n\t\tr_cons_print (\"[\");\n\t} else if (IS_MODE_SET (mode)) {\n\t\tr_flag_space_set (r->flags, \"relocs\");\n\t}\n\tr_list_foreach (relocs, iter, reloc) {\n\t\tut64 addr = rva (r->bin, reloc->paddr, reloc->vaddr, va);\n\t\tif (IS_MODE_SET (mode) && (is_section_reloc (reloc) || is_file_reloc (reloc))) {\n\t\t\t/*\n\t\t\t * Skip section reloc because they will have their own flag.\n\t\t\t * Skip also file reloc because not useful for now.\n\t\t\t */\n\t\t} else if (IS_MODE_SET (mode)) {\n\t\t\tset_bin_relocs (r, reloc, addr, &db, &sdb_module);\n\t\t\tadd_metadata (r, reloc, addr, mode);\n\t\t} else if (IS_MODE_SIMPLE (mode)) {\n\t\t\tr_cons_printf (\"0x%08\"PFMT64x\"  %s\\n\", addr, reloc->import ? reloc->import->name : \"\");\n\t\t} else if (IS_MODE_RAD (mode)) {\n\t\t\tchar *name = reloc->import\n\t\t\t\t? strdup (reloc->import->name)\n\t\t\t\t: (reloc->symbol ? strdup (reloc->symbol->name) : NULL);\n\t\t\tif (name && bin_demangle) {\n\t\t\t\tchar *mn = r_bin_demangle (r->bin->cur, NULL, name, addr);\n\t\t\t\tif (mn) {\n\t\t\t\t\tfree (name);\n\t\t\t\t\tname = mn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (name) {\n\t\t\t\tr_cons_printf (\"f %s%s%s @ 0x%08\"PFMT64x\"\\n\",\n\t\t\t\t\tr->bin->prefix ? r->bin->prefix : \"reloc.\",\n\t\t\t\t\tr->bin->prefix ? \".\" : \"\", name, addr);\n\t\t\t\tadd_metadata (r, reloc, addr, mode);\n\t\t\t\tfree (name);\n\t\t\t}\n\t\t} else if (IS_MODE_JSON (mode)) {\n\t\t\tif (iter->p) {\n\t\t\t\tr_cons_printf (\",{\\\"name\\\":\");\n\t\t\t} else {\n\t\t\t\tr_cons_printf (\"{\\\"name\\\":\");\n\t\t\t}\n\t\t\t// take care with very long symbol names! do not use sdb_fmt or similar\n\t\t\tif (reloc->import) {\n\t\t\t\tr_cons_printf (\"\\\"%s\\\"\", reloc->import->name);\n\t\t\t} else if (reloc->symbol) {\n\t\t\t\tr_cons_printf (\"\\\"%s\\\"\", reloc->symbol->name);\n\t\t\t} else {\n\t\t\t\tr_cons_printf (\"null\");\n\t\t\t}\n\n\t\t\tr_cons_printf (\",\"\n\t\t\t\t\"\\\"type\\\":\\\"%s\\\",\"\n\t\t\t\t\"\\\"vaddr\\\":%\"PFMT64d\",\"\n\t\t\t\t\"\\\"paddr\\\":%\"PFMT64d\",\"\n\t\t\t\t\"\\\"is_ifunc\\\":%s}\",\n\t\t\t\tbin_reloc_type_name (reloc),\n\t\t\t\treloc->vaddr, reloc->paddr,\n\t\t\t\tr_str_bool (reloc->is_ifunc));\n\t\t} else if (IS_MODE_NORMAL (mode)) {\n\t\t\tchar *name = reloc->import\n\t\t\t\t? strdup (reloc->import->name)\n\t\t\t\t: reloc->symbol\n\t\t\t\t? strdup (reloc->symbol->name)\n\t\t\t\t: strdup (\"null\");\n\t\t\tif (bin_demangle) {\n\t\t\t\tchar *mn = r_bin_demangle (r->bin->cur, NULL, name, addr);\n\t\t\t\tif (mn && *mn) {\n\t\t\t\t\tfree (name);\n\t\t\t\t\tname = mn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tr_cons_printf (\"vaddr=0x%08\"PFMT64x\" paddr=0x%08\"PFMT64x\" type=%s\",\n\t\t\t\taddr, reloc->paddr, bin_reloc_type_name (reloc));\n\t\t\tif (reloc->import && reloc->import->name[0]) {\n\t\t\t\tr_cons_printf (\" %s\", name);\n\t\t\t} else if (reloc->symbol && name && name[0]) {\n\t\t\t\tr_cons_printf (\" %s\", name);\n\t\t\t}\n\t\t\tfree (name);\n\t\t\tif (reloc->addend) {\n\t\t\t\tif (reloc->import && reloc->addend > 0) {\n\t\t\t\t\tr_cons_printf (\" +\");\n\t\t\t\t}\n\t\t\t\tif (reloc->addend < 0) {\n\t\t\t\t\tr_cons_printf (\" - 0x%08\"PFMT64x, -reloc->addend);\n\t\t\t\t} else {\n\t\t\t\t\tr_cons_printf (\" 0x%08\"PFMT64x, reloc->addend);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (reloc->is_ifunc) {\n\t\t\t\tr_cons_print (\" (ifunc)\");\n\t\t\t}\n\t\t\tr_cons_newline ();\n\t\t}\n\t\ti++;\n\t}\n\tif (IS_MODE_JSON (mode)) {\n\t\tr_cons_print (\"]\");\n\t}\n\tif (IS_MODE_NORMAL (mode)) {\n\t\tr_cons_printf (\"\\n%i relocations\\n\", i);\n\t}\n\n\tR_FREE (sdb_module);\n\tsdb_free (db);\n\tdb = NULL;\n\n\treturn relocs != NULL;\n}\n\n#define MYDB 1\n/* this is a hacky workaround that needs proper refactoring in Rbin to use Sdb */\n#if MYDB\nstatic Sdb *mydb = NULL;\nstatic RList *osymbols = NULL;\n\nstatic RBinSymbol *get_symbol(RBin *bin, RList *symbols, const char *name, ut64 addr) {\n\tRBinSymbol *symbol, *res = NULL;\n\tRListIter *iter;\n\tif (mydb && symbols && symbols != osymbols) {\n\t\tsdb_free (mydb);\n\t\tmydb = NULL;\n\t\tosymbols = symbols;\n\t}\n\tif (mydb) {\n\t\tif (name) {\n\t\t\tres = (RBinSymbol*)(void*)(size_t)\n\t\t\t\tsdb_num_get (mydb, sdb_fmt (\"%x\", sdb_hash (name)), NULL);\n\t\t} else {\n\t\t\tres = (RBinSymbol*)(void*)(size_t)\n\t\t\t\tsdb_num_get (mydb, sdb_fmt (\"0x\"PFMT64x, addr), NULL);\n\t\t}\n\t} else {\n\t\tmydb = sdb_new0 ();\n\t\tr_list_foreach (symbols, iter, symbol) {\n\t\t\t/* ${name}=${ptrToSymbol} */\n\t\t\tif (!sdb_num_add (mydb, sdb_fmt (\"%x\", sdb_hash (symbol->name)), (ut64)(size_t)symbol, 0)) {\n\t\t\t//\teprintf (\"DUP (%s)\\n\", symbol->name);\n\t\t\t}\n\t\t\t/* 0x${vaddr}=${ptrToSymbol} */\n\t\t\tif (!sdb_num_add (mydb, sdb_fmt (\"0x\"PFMT64x, symbol->vaddr), (ut64)(size_t)symbol, 0)) {\n\t\t\t//\teprintf (\"DUP (%s)\\n\", symbol->name);\n\t\t\t}\n\t\t\tif (name) {\n\t\t\t\tif (!res && !strcmp (symbol->name, name)) {\n\t\t\t\t\tres = symbol;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (symbol->vaddr == addr) {\n\t\t\t\t\tres = symbol;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tosymbols = symbols;\n\t}\n\treturn res;\n}\n#else\nstatic RList *osymbols = NULL;\nstatic RBinSymbol *get_symbol(RBin *bin, RList *symbols, const char *name, ut64 addr) {\n\tRBinSymbol *symbol;\n\tRListIter *iter;\n\t// XXX this is slow, we should use a hashtable here\n\tr_list_foreach (symbols, iter, symbol) {\n\t\tif (name) {\n\t\t\tif (!strcmp (symbol->name, name))\n\t\t\t\treturn symbol;\n\t\t} else {\n\t\t\tif (symbol->vaddr == addr) {\n\t\t\t\treturn symbol;\n\t\t\t}\n\t\t}\n\t}\n\treturn NULL;\n}\n#endif\n\n/* XXX: This is a hack to get PLT references in rabin2 -i */\n/* imp. is a prefix that can be rewritten by the symbol table */\nstatic ut64 impaddr(RBin *bin, int va, const char *name) {\n\tRList *symbols;\n\n\tif (!name || !*name) {\n\t\treturn false;\n\t}\n\tif (!(symbols = r_bin_get_symbols (bin))) {\n\t\treturn false;\n\t}\n\tchar *impname = r_str_newf (\"imp.%s\", name);\n\tRBinSymbol *s = get_symbol (bin, symbols, impname, 0LL);\n\t// maybe ut64_MAX to indicate import not found?\n\tut64 addr = s? (va? r_bin_get_vaddr (bin, s->paddr, s->vaddr): s->paddr): 0LL;\n\tfree (impname);\n\treturn addr;\n}\n\nstatic int bin_imports(RCore *r, int mode, int va, const char *name) {\n\tRBinInfo *info = r_bin_get_info (r->bin);\n\tint bin_demangle = r_config_get_i (r->config, \"bin.demangle\");\n\tRBinImport *import;\n\tRListIter *iter;\n\tbool lit = info ? info->has_lit: false;\n\tchar *str;\n\tint i = 0;\n\n\tRList *imports = r_bin_get_imports (r->bin);\n\tint cdsz = info? (info->bits == 64? 8: info->bits == 32? 4: info->bits == 16 ? 4: 0): 0;\n\tif (IS_MODE_JSON (mode)) {\n\t\tr_cons_print (\"[\");\n\t} else if (IS_MODE_RAD (mode)) {\n\t\tr_cons_println (\"fs imports\");\n\t} else if (IS_MODE_NORMAL (mode)) {\n\t\tr_cons_println (\"[Imports]\");\n\t}\n\tr_list_foreach (imports, iter, import) {\n\t\tif (name && strcmp (import->name, name)) {\n\t\t\tcontinue;\n\t\t}\n\t\tchar *symname = strdup (import->name);\n\t\tut64 addr = lit ? impaddr (r->bin, va, symname): 0;\n\t\tif (bin_demangle) {\n\t\t\tchar *dname = r_bin_demangle (r->bin->cur, NULL, symname, addr);\n\t\t\tif (dname) {\n\t\t\t\tfree (symname);\n\t\t\t\tsymname = r_str_newf (\"sym.imp.%s\", dname);\n\t\t\t\tfree (dname);\n\t\t\t}\n\t\t}\n\t\tif (r->bin->prefix) {\n\t\t\tchar *prname = r_str_newf (\"%s.%s\", r->bin->prefix, symname);\n\t\t\tfree (symname);\n\t\t\tsymname = prname;\n\t\t}\n\t\tif (IS_MODE_SET (mode)) {\n\t\t\t// TODO(eddyb) symbols that are imports.\n\t\t\t// Add a dword/qword for PE imports\n\t\t\tif (strstr (symname, \".dll_\") && cdsz) {\n\t\t\t\tr_meta_add (r->anal, R_META_TYPE_DATA, addr, addr + cdsz, NULL);\n\t\t\t}\n\t\t} else if (IS_MODE_SIMPLE (mode)) {\n\t\t\tr_cons_println (symname);\n\t\t} else if (IS_MODE_JSON (mode)) {\n\t\t\tstr = r_str_utf16_encode (symname, -1);\n\t\t\tstr = r_str_replace (str, \"\\\"\", \"\\\\\\\"\", 1);\n\t\t\tr_cons_printf (\"%s{\\\"ordinal\\\":%d,\"\n\t\t\t\t\"\\\"bind\\\":\\\"%s\\\",\"\n\t\t\t\t\"\\\"type\\\":\\\"%s\\\",\",\n\t\t\t\titer->p ? \",\" : \"\",\n\t\t\t\timport->ordinal,\n\t\t\t\timport->bind,\n\t\t\t\timport->type);\n\t\t\tif (import->classname && import->classname[0]) {\n\t\t\t\tr_cons_printf (\"\\\"classname\\\":\\\"%s\\\",\"\n\t\t\t\t\t\"\\\"descriptor\\\":\\\"%s\\\",\",\n\t\t\t\t\timport->classname,\n\t\t\t\t\timport->descriptor);\n\t\t\t}\n\t\t\tr_cons_printf (\"\\\"name\\\":\\\"%s\\\",\\\"plt\\\":%\"PFMT64d\"}\",\n\t\t\t\tstr, addr);\n\t\t\tfree (str);\n\t\t} else if (IS_MODE_RAD (mode)) {\n\t\t\t// TODO(eddyb) symbols that are imports.\n\t\t} else {\n\t\t\tconst char *bind = r_str_get (import->bind);\n\t\t\tconst char *type = r_str_get (import->type);\n#if 0\n\t\t\tr_cons_printf (\"ordinal=%03d plt=0x%08\"PFMT64x\" bind=%s type=%s\",\n\t\t\t\timport->ordinal, addr, bind, type);\n\t\t\tif (import->classname && import->classname[0]) {\n\t\t\t\tr_cons_printf (\" classname=%s\", import->classname);\n\t\t\t}\n\t\t\tr_cons_printf (\" name=%s\", symname);\n\t\t\tif (import->descriptor && import->descriptor[0]) {\n\t\t\t\tr_cons_printf (\" descriptor=%s\", import->descriptor);\n\t\t\t}\n\t\t\tr_cons_newline ();\n#else\n\t\t\tr_cons_printf (\"%4d 0x%08\"PFMT64x\" %7s %7s \",\n\t\t\t\timport->ordinal, addr, bind, type);\n\t\t\tif (import->classname && import->classname[0]) {\n\t\t\t\tr_cons_printf (\"%s.\", import->classname);\n\t\t\t}\n\t\t\tr_cons_printf (\"%s\", symname);\n\t\t\tif (import->descriptor && import->descriptor[0]) {\n\t\t\t\t// Uh?\n\t\t\t\tr_cons_printf (\" descriptor=%s\", import->descriptor);\n\t\t\t}\n\t\t\tr_cons_newline ();\n#endif\n\t\t}\n\t\tR_FREE (symname);\n\t\ti++;\n\t}\n\tif (IS_MODE_JSON (mode)) {\n\t\tr_cons_print (\"]\");\n\t} else if (IS_MODE_NORMAL (mode)) {\n\t\t// r_cons_printf (\"# %i imports\\n\", i);\n\t}\n#if MYDB\n\t// NOTE: if we comment out this, it will leak.. but it will be faster\n\t// because it will keep the cache across multiple RBin calls\n\tosymbols = NULL;\n\tsdb_free (mydb);\n\tmydb = NULL;\n#endif\n\treturn true;\n}\n\nstatic const char *getPrefixFor(const char *s) {\n\tif (s) {\n\t\tif (!strcmp (s, \"NOTYPE\")) {\n\t\t\treturn \"loc\";\n\t\t}\n\t\tif (!strcmp (s, \"OBJECT\")) {\n\t\t\treturn \"obj\";\n\t\t}\n\t}\n\treturn \"sym\";\n}\n\ntypedef struct {\n\tconst char *pfx; // prefix for flags\n\tchar *name;      // raw symbol name\n\tchar *nameflag;  // flag name for symbol\n\tchar *demname;   // demangled raw symbol name\n\tchar *demflag;   // flag name for demangled symbol\n\tchar *classname; // classname\n\tchar *classflag; // flag for classname\n\tchar *methname;  // methods [class]::[method]\n\tchar *methflag;  // methods flag sym.[class].[method]\n} SymName;\n\nstatic void snInit(RCore *r, SymName *sn, RBinSymbol *sym, const char *lang) {\n#define MAXFLAG_LEN 128\n\tint bin_demangle = lang != NULL;\n\tconst char *pfx;\n\tif (!r || !sym || !sym->name) return;\n\tpfx = getPrefixFor (sym->type);\n\tsn->name = strdup (sym->name);\n\tif (sym->dup_count) {\n\t\tsn->nameflag = r_str_newf (\"%s.%s_%d\", pfx, sym->name, sym->dup_count);\n\t} else {\n\t\tsn->nameflag = r_str_newf (\"%s.%s\", pfx, sym->name);\n\t}\n\tr_name_filter (sn->nameflag, MAXFLAG_LEN);\n\tif (sym->classname && sym->classname[0]) {\n\t\tsn->classname = strdup (sym->classname);\n\t\tsn->classflag = r_str_newf (\"sym.%s.%s\", sn->classname, sn->name);\n\t\tr_name_filter (sn->classflag, MAXFLAG_LEN);\n\t\tconst char *name = sym->dname? sym->dname: sym->name;\n\t\tsn->methname = r_str_newf (\"%s::%s\", sn->classname, name);\n\t\tsn->methflag = r_str_newf (\"sym.%s.%s\", sn->classname, name);\n\t\tr_name_filter (sn->methflag, strlen (sn->methflag));\n\t} else {\n\t\tsn->classname = NULL;\n\t\tsn->classflag = NULL;\n\t\tsn->methname = NULL;\n\t\tsn->methflag = NULL;\n\t}\n\tsn->demname = NULL;\n\tsn->demflag = NULL;\n\tif (bin_demangle && sym->paddr) {\n\t\tsn->demname = r_bin_demangle (r->bin->cur, lang, sn->name, sym->vaddr);\n\t\tif (sn->demname) {\n\t\t\tsn->demflag = r_str_newf (\"%s.%s\", pfx, sn->demname);\n\t\t\tr_name_filter (sn->demflag, -1);\n\t\t}\n\t}\n}\n\nstatic void snFini(SymName *sn) {\n\tR_FREE (sn->name);\n\tR_FREE (sn->nameflag);\n\tR_FREE (sn->demname);\n\tR_FREE (sn->demflag);\n\tR_FREE (sn->classname);\n\tR_FREE (sn->classflag);\n\tR_FREE (sn->methname);\n\tR_FREE (sn->methflag);\n}\n\n\nstatic bool isAnExport(RBinSymbol *s) {\n\t/* workaround for some bin plugs */\n\tif (!strncmp (s->name, \"imp.\", 4)) {\n\t\treturn false;\n\t}\n\treturn (s->bind && !strcmp (s->bind, \"GLOBAL\"));\n}\n\nstatic int bin_symbols_internal(RCore *r, int mode, ut64 laddr, int va, ut64 at, const char *name, bool exponly, const char *args) {\n\tRBinInfo *info = r_bin_get_info (r->bin);\n\tRList *entries = r_bin_get_entries (r->bin);\n\tRBinSymbol *symbol;\n\tRBinAddr *entry;\n\tRListIter *iter;\n\tRList *symbols;\n\tconst char *lang;\n\tbool firstexp = true;\n\tbool printHere = false;\n\tint i = 0, is_arm, lastfs = 's';\n\tbool bin_demangle = r_config_get_i (r->config, \"bin.demangle\");\n\tif (!info) {\n\t\treturn 0;\n\t}\n\n\tif (args && *args == '.') {\n\t\tprintHere = true;\n\t}\n\n\tis_arm = info && info->arch && !strncmp (info->arch, \"arm\", 3);\n\tlang = bin_demangle ? r_config_get (r->config, \"bin.lang\") : NULL;\n\n\tsymbols = r_bin_get_symbols (r->bin);\n\tr_space_set (&r->anal->meta_spaces, \"bin\");\n\n\tif (IS_MODE_JSON (mode) && !printHere) {\n\t\tr_cons_printf (\"[\");\n\t} else if (IS_MODE_SET (mode)) {\n\t\tr_flag_space_set (r->flags, \"symbols\");\n\t} else if (!at && exponly) {\n\t\tif (IS_MODE_RAD (mode)) {\n\t\t\tr_cons_printf (\"fs exports\\n\");\n\t\t} else if (IS_MODE_NORMAL (mode)) {\n\t\t\tr_cons_printf (printHere ? \"\" : \"[Exports]\\n\");\n\t\t}\n\t} else if (!at && !exponly) {\n\t\tif (IS_MODE_RAD (mode)) {\n\t\t\tr_cons_printf (\"fs symbols\\n\");\n\t\t} else if (IS_MODE_NORMAL (mode)) {\n\t\t\tr_cons_printf (printHere ? \"\" : \"[Symbols]\\n\");\n\t\t}\n\t}\n\n\tr_list_foreach (symbols, iter, symbol) {\n\t\tut64 addr = rva (r->bin, symbol->paddr, symbol->vaddr, va);\n\t\tint len = symbol->size ? symbol->size : 32;\n\t\tSymName sn;\n\n\t\tif (exponly && !isAnExport (symbol)) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (name && strcmp (symbol->name, name)) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (at && (!symbol->size || !is_in_range (at, addr, symbol->size))) {\n\t\t\tcontinue;\n\t\t}\n\t\tif ((printHere && !is_in_range (r->offset, symbol->paddr, len))\n\t\t\t\t&& (printHere && !is_in_range (r->offset, addr, len))) {\n\t\t\tcontinue;\n\t\t}\n\t\tsnInit (r, &sn, symbol, lang);\n\n\t\tif (IS_MODE_SET (mode) && (is_section_symbol (symbol) || is_file_symbol (symbol))) {\n\t\t\t/*\n\t\t\t * Skip section symbols because they will have their own flag.\n\t\t\t * Skip also file symbols because not useful for now.\n\t\t\t */\n\t\t} else if (IS_MODE_SET (mode)) {\n\t\t\tif (is_arm && info->bits < 33) { // 16 or 32\n\t\t\t\tint force_bits = 0;\n\t\t\t\tif (symbol->paddr & 1 || symbol->bits == 16) {\n\t\t\t\t\tforce_bits = 16;\n\t\t\t\t} else if (info->bits == 16 && symbol->bits == 32) {\n\t\t\t\t\tforce_bits = 32;\n\t\t\t\t} else if (!(symbol->paddr & 1) && symbol->bits == 32) {\n\t\t\t\t\tforce_bits = 32;\n\t\t\t\t}\n\t\t\t\tif (force_bits) {\n\t\t\t\t\tr_anal_hint_set_bits (r->anal, addr, force_bits);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!strncmp (symbol->name, \"imp.\", 4)) {\n\t\t\t\tif (lastfs != 'i') {\n\t\t\t\t\tr_flag_space_set (r->flags, \"imports\");\n\t\t\t\t}\n\t\t\t\tlastfs = 'i';\n\t\t\t} else {\n\t\t\t\tif (lastfs != 's') {\n\t\t\t\t\tr_flag_space_set (r->flags, \"symbols\");\n\t\t\t\t}\n\t\t\t\tlastfs = 's';\n\t\t\t}\n\t\t\t/* If that's a Classed symbol (method or so) */\n\t\t\tif (sn.classname) {\n\t\t\t\tRFlagItem *fi = NULL;\n\t\t\t\tchar *comment = NULL;\n\t\t\t\tfi = r_flag_get (r->flags, sn.methflag);\n\t\t\t\tif (r->bin->prefix) {\n\t\t\t\t\tchar *prname;\n\t\t\t\t\tprname = r_str_newf (\"%s.%s\", r->bin->prefix, sn.methflag);\n\t\t\t\t\tr_name_filter (sn.methflag, -1);\n\t\t\t\t\tfree (sn.methflag);\n\t\t\t\t\tsn.methflag = prname;\n\t\t\t\t}\n\t\t\t\tif (fi) {\n\t\t\t\t\tr_flag_item_set_realname (fi, sn.methname);\n\t\t\t\t\tif ((fi->offset - r->flags->base) == addr) {\n\t\t\t\t\t\tcomment = fi->comment ? strdup (fi->comment) : NULL;\n\t\t\t\t\t\tr_flag_unset (r->flags, fi);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfi = r_flag_set (r->flags, sn.methflag, addr, symbol->size);\n\t\t\t\t\tcomment = fi->comment ? strdup (fi->comment) : NULL;\n\t\t\t\t\tif (comment) {\n\t\t\t\t\t\tr_flag_item_set_comment (fi, comment);\n\t\t\t\t\t\tR_FREE (comment);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst char *fn, *n;\n\t\t\t\tRFlagItem *fi;\n\t\t\t\tn = sn.demname ? sn.demname : sn.name;\n\t\t\t\tfn = sn.demflag ? sn.demflag : sn.nameflag;\n\t\t\t\tchar *fnp = (r->bin->prefix) ?\n\t\t\t\t\tr_str_newf (\"%s.%s\", r->bin->prefix, fn):\n\t\t\t\t\tstrdup (fn);\n\t\t\t\tfi = r_flag_set (r->flags, fnp, addr, symbol->size);\n\t\t\t\tif (fi) {\n\t\t\t\t\tr_flag_item_set_realname (fi, n);\n\t\t\t\t} else {\n\t\t\t\t\tif (fn) {\n\t\t\t\t\t\teprintf (\"[Warning] Can't find flag (%s)\\n\", fn);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfree (fnp);\n\t\t\t}\n\t\t\tif (sn.demname) {\n\t\t\t\tr_meta_add (r->anal, R_META_TYPE_COMMENT,\n\t\t\t\t\taddr, symbol->size, sn.demname);\n\t\t\t}\n\t\t} else if (IS_MODE_JSON (mode)) {\n\t\t\tchar *str = r_str_utf16_encode (symbol->name, -1);\n\t\t\t// str = r_str_replace (str, \"\\\"\", \"\\\\\\\"\", 1);\n\t\t\tr_cons_printf (\"%s{\\\"name\\\":\\\"%s\\\",\"\n\t\t\t\t\"\\\"demname\\\":\\\"%s\\\",\"\n\t\t\t\t\"\\\"flagname\\\":\\\"%s\\\",\"\n\t\t\t\t\"\\\"ordinal\\\":%d,\"\n\t\t\t\t\"\\\"bind\\\":\\\"%s\\\",\"\n\t\t\t\t\"\\\"size\\\":%d,\"\n\t\t\t\t\"\\\"type\\\":\\\"%s\\\",\"\n\t\t\t\t\"\\\"vaddr\\\":%\"PFMT64d\",\"\n\t\t\t\t\"\\\"paddr\\\":%\"PFMT64d\"}\",\n\t\t\t\t((exponly && firstexp) || printHere) ? \"\" : (iter->p ? \",\" : \"\"),\n\t\t\t\tstr,\n\t\t\t\tsn.demname? sn.demname: \"\",\n\t\t\t\tsn.nameflag,\n\t\t\t\tsymbol->ordinal,\n\t\t\t\tsymbol->bind,\n\t\t\t\t(int)symbol->size,\n\t\t\t\tsymbol->type,\n\t\t\t\t(ut64)addr, (ut64)symbol->paddr);\n\t\t\tfree (str);\n\t\t} else if (IS_MODE_SIMPLE (mode)) {\n\t\t\tconst char *name = sn.demname? sn.demname: symbol->name;\n\t\t\tr_cons_printf (\"0x%08\"PFMT64x\" %d %s\\n\",\n\t\t\t\taddr, (int)symbol->size, name);\n\t\t} else if (IS_MODE_SIMPLEST (mode)) {\n\t\t\tconst char *name = sn.demname? sn.demname: symbol->name;\n\t\t\tr_cons_printf (\"%s\\n\", name);\n\t\t} else if (IS_MODE_RAD (mode)) {\n\t\t\tRBinFile *binfile;\n\t\t\tRBinPlugin *plugin;\n\t\t\tchar *name = strdup (sn.demname? sn.demname: symbol->name);\n\t\t\tr_name_filter (name, -1);\n\t\t\tif (!strncmp (name, \"imp.\", 4)) {\n\t\t\t\tif (lastfs != 'i')\n\t\t\t\t\tr_cons_printf (\"fs imports\\n\");\n\t\t\t\tlastfs = 'i';\n\t\t\t} else {\n\t\t\t\tif (lastfs != 's') {\n\t\t\t\t\tr_cons_printf (\"fs %s\\n\",\n\t\t\t\t\t\texponly? \"exports\": \"symbols\");\n\t\t\t\t}\n\t\t\t\tlastfs = 's';\n\t\t\t}\n\t\t\tif (r->bin->prefix) {\n\t\t\t\tif (symbol->dup_count) {\n\t\t\t\t\tr_cons_printf (\"f %s.sym.%s_%d %u 0x%08\"PFMT64x\"\\n\",\n\t\t\t\t\t\tr->bin->prefix, name, symbol->dup_count, symbol->size, addr);\n\t\t\t\t} else {\n\t\t\t\t\tr_cons_printf (\"f %s.sym.%s %u 0x%08\"PFMT64x\"\\n\",\n\t\t\t\t\t\tr->bin->prefix, name, symbol->size, addr);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (symbol->dup_count) {\n\t\t\t\t\tr_cons_printf (\"f sym.%s_%d %u 0x%08\"PFMT64x\"\\n\",\n\t\t\t\t\t\tname, symbol->dup_count, symbol->size, addr);\n\t\t\t\t} else {\n\t\t\t\t\tr_cons_printf (\"f sym.%s %u 0x%08\"PFMT64x\"\\n\",\n\t\t\t\t\t\tname, symbol->size, addr);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbinfile = r_core_bin_cur (r);\n\t\t\tplugin = r_bin_file_cur_plugin (binfile);\n\t\t\tif (plugin && plugin->name) {\n\t\t\t\tif (!strncmp (plugin->name, \"pe\", 2)) {\n\t\t\t\t\tchar *p, *module = strdup (symbol->name);\n\t\t\t\t\tp = strstr (module, \".dll_\");\n\t\t\t\t\tif (p) {\n\t\t\t\t\t\tconst char *symname = p + 5;\n\t\t\t\t\t\t*p = 0;\n\t\t\t\t\t\tif (r->bin->prefix) {\n\t\t\t\t\t\t\tr_cons_printf (\"k bin/pe/%s/%d=%s.%s\\n\",\n\t\t\t\t\t\t\t\tmodule, symbol->ordinal, r->bin->prefix, symname);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tr_cons_printf (\"k bin/pe/%s/%d=%s\\n\",\n\t\t\t\t\t\t\t\tmodule, symbol->ordinal, symname);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfree (module);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tconst char *bind = r_str_get (symbol->bind);\n\t\t\tconst char *type = r_str_get (symbol->type);\n\t\t\tconst char *name = r_str_get (sn.demname? sn.demname: symbol->name);\n\t\t\t// const char *fwd = r_str_get (symbol->forwarder);\n\t\t\tr_cons_printf (\"%03u 0x%08\"PFMT64x\" 0x%08\"PFMT64x\" \"\n\t\t\t\t\"%6s %6s %4d %s\\n\",\n\t\t\t\tsymbol->ordinal,\n\t\t\t\tsymbol->paddr, addr, bind, type,\n\t\t\t\tsymbol->size, name);\n\t\t\t// r_cons_printf (\"vaddr=0x%08\"PFMT64x\" paddr=0x%08\"PFMT64x\" ord=%03u \"\n\t\t\t//\t\"fwd=%s sz=%u bind=%s type=%s name=%s\\n\",\n\t\t\t//\taddr, symbol->paddr, symbol->ordinal, fwd,\n\t\t\t//\tsymbol->size, bind, type, name);\n\t\t}\n\t\tsnFini (&sn);\n\t\ti++;\n\t\tif (exponly && firstexp) {\n\t\t\tfirstexp = false;\n\t\t}\n\t\tif (printHere) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t//handle thumb and arm for entry point since they are not present in symbols\n\tif (is_arm) {\n\t\tr_list_foreach (entries, iter, entry) {\n\t\t\tif (IS_MODE_SET (mode)) {\n\t\t\t\tif (info->bits < 33) { // 16 or 32\n\t\t\t\t\tint force_bits = 0;\n\t\t\t\t\tut64 addr = rva (r->bin, entry->paddr, entry->vaddr, va);\n\t\t\t\t\tif (entry->paddr & 1 || entry->bits == 16) {\n\t\t\t\t\t\tforce_bits = 16;\n\t\t\t\t\t} else if (info->bits == 16 && entry->bits == 32) {\n\t\t\t\t\t\tforce_bits = 32;\n\t\t\t\t\t} else if (!(entry->paddr & 1)) {\n\t\t\t\t\t\tforce_bits = 32;\n\t\t\t\t\t}\n\t\t\t\t\tif (force_bits) {\n\t\t\t\t\t\tr_anal_hint_set_bits (r->anal, addr, force_bits);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (IS_MODE_JSON (mode) && !printHere) r_cons_printf (\"]\");\n#if 0\n\tif (IS_MODE_NORMAL (mode) && !at) {\n\t\tr_cons_printf (\"\\n%i %s\\n\", i, exponly ? \"exports\" : \"symbols\");\n\t}\n#endif\n\n\tr_space_set (&r->anal->meta_spaces, NULL);\n\treturn true;\n}\n\nstatic int bin_exports(RCore *r, int mode, ut64 laddr, int va, ut64 at, const char *name, const char *args) {\n\treturn bin_symbols_internal (r, mode, laddr, va, at, name, true, args);\n}\n\nstatic int bin_symbols(RCore *r, int mode, ut64 laddr, int va, ut64 at, const char *name, const char *args) {\n\treturn bin_symbols_internal (r, mode, laddr, va, at, name, false, args);\n}\n\nstatic char *build_hash_string(int mode, const char *chksum, ut8 *data, ut32 datalen) {\n\tchar *chkstr = NULL, *aux, *ret = NULL;\n\tconst char *ptr = chksum;\n\tchar tmp[128];\n\tint i;\n\tdo {\n\t\tfor (i = 0; *ptr && *ptr != ',' && i < sizeof (tmp) -1; i++) {\n\t\t\ttmp[i] = *ptr++;\n\t\t}\n\t\ttmp[i] = '\\0';\n\t\tr_str_trim_head_tail (tmp);\n\t\tchkstr = r_hash_to_string (NULL, tmp, data, datalen);\n\t\tif (!chkstr) {\n\t\t\tif (*ptr && *ptr == ',') {\n\t\t\t\tptr++;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (IS_MODE_SIMPLE (mode)) {\n\t\t\taux = r_str_newf (\"%s \", chkstr);\n\t\t} else if (IS_MODE_JSON (mode)) {\n\t\t\taux = r_str_newf (\"\\\"%s\\\":\\\"%s\\\",\", tmp, chkstr);\n\t\t} else {\n\t\t\taux = r_str_newf (\"%s=%s \", tmp, chkstr);\n\t\t}\n\t\tret = r_str_append (ret, aux);\n\t\tfree (chkstr);\n\t\tfree (aux);\n\t\tif (*ptr && *ptr == ',') ptr++;\n\t} while (*ptr);\n\n\treturn ret;\n}\n\nstatic int bin_sections(RCore *r, int mode, ut64 laddr, int va, ut64 at, const char *name, const char *chksum) {\n\tchar *str = NULL;\n\tRBinSection *section;\n\tRBinInfo *info = NULL;\n\tRList *sections;\n\tRListIter *iter;\n\tint i = 0;\n\tint fd = -1;\n\tbool printHere = false;\n\tsections = r_bin_get_sections (r->bin);\n\tbool inDebugger = r_config_get_i (r->config, \"cfg.debug\");\n\tSdbHash *dup_chk_ht = ht_new (NULL, NULL, NULL);\n\tbool ret = false;\n\n\tif (!dup_chk_ht) {\n\t\treturn false;\n\t}\n\t\n\tif (chksum && *chksum == '.') {\n\t\tprintHere = true;\n\t}\n\tif (IS_MODE_JSON (mode) && !printHere) r_cons_printf (\"[\");\n\telse if (IS_MODE_RAD (mode) && !at) r_cons_printf (\"fs sections\\n\");\n\telse if (IS_MODE_NORMAL (mode) && !at && !printHere) r_cons_printf (\"[Sections]\\n\");\n\telse if (IS_MODE_NORMAL (mode) && printHere) r_cons_printf(\"Current section\\n\");\n\telse if (IS_MODE_SET (mode)) {\n\t\tfd = r_core_file_cur_fd (r);\n\t\tr_flag_space_set (r->flags, \"sections\");\n\t}\n\tr_list_foreach (sections, iter, section) {\n\t\tchar perms[] = \"----\";\n\t\tint va_sect = va;\n\t\tut64 addr;\n\n\t\tif (va && !(section->srwx & R_BIN_SCN_READABLE)) {\n\t\t\tva_sect = VA_NOREBASE;\n\t\t}\n\t\taddr = rva (r->bin, section->paddr, section->vaddr, va_sect);\n\n\t\tif (name && strcmp (section->name, name)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ((printHere && !(section->paddr <= r->offset && r->offset < (section->paddr + section->size)))\n\t\t\t\t&& (printHere && !(addr <= r->offset && r->offset < (addr + section->size)))) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tr_name_filter (section->name, sizeof (section->name));\n\t\tif (at && (!section->size || !is_in_range (at, addr, section->size))) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (section->srwx & R_BIN_SCN_SHAREABLE) perms[0] = 's';\n\t\tif (section->srwx & R_BIN_SCN_READABLE) perms[1] = 'r';\n\t\tif (section->srwx & R_BIN_SCN_WRITABLE) perms[2] = 'w';\n\t\tif (section->srwx & R_BIN_SCN_EXECUTABLE) perms[3] = 'x';\n\n\t\tif (IS_MODE_SET (mode)) {\n#if LOAD_BSS_MALLOC\n\t\t\tif (!strcmp (section->name, \".bss\")) {\n\t\t\t\t// check if there's already a file opened there\n\t\t\t\tint loaded = 0;\n\t\t\t\tRListIter *iter;\n\t\t\t\tRIOMap *m;\n\t\t\t\tr_list_foreach (r->io->maps, iter, m) {\n\t\t\t\t\tif (m->from == addr) {\n\t\t\t\t\t\tloaded = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!loaded && !inDebugger) {\n\t\t\t\t\tr_core_cmdf (r, \"on malloc://%d 0x%\"PFMT64x\" # bss\\n\",\n\t\t\t\t\t\tsection->vsize, addr);\n\t\t\t\t}\n\t\t\t}\n#endif\n\t\t\tr_name_filter (section->name, 128);\n\t\t\tif (section->format) {\n\t\t\t\t// This is damn slow if section vsize is HUGE\n\t\t\t\tif (section->vsize < 1024 * 1024 * 2) {\n\t\t\t\t\tr_core_cmdf (r, \"%s @ 0x%\"PFMT64x, section->format, section->vaddr);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (r->bin->prefix) {\n\t\t\t\tstr = r_str_newf (\"%s.section.%s\", r->bin->prefix, section->name);\n\t\t\t} else {\n\t\t\t\tstr = r_str_newf (\"section.%s\", section->name);\n\n\t\t\t}\n\t\t\tr_flag_set (r->flags, str, addr, section->size);\n\t\t\tR_FREE (str);\n\n\t\t\tif (r->bin->prefix) {\n\t\t\t\tstr = r_str_newf (\"%s.section_end.%s\", r->bin->prefix, section->name);\n\t\t\t} else {\n\t\t\t\tstr = r_str_newf (\"section_end.%s\", section->name);\n\t\t\t}\n\t\t\tr_flag_set (r->flags, str, addr + section->vsize, 0);\n\t\t\tR_FREE (str);\n\n\t\t\tif (section->arch || section->bits) {\n\t\t\t\tconst char *arch = section->arch;\n\t\t\t\tint bits = section->bits;\n\t\t\t\tif (info) {\n\t\t\t\t\tif (!arch) {\n\t\t\t\t\t\tarch = info->arch;\n\t\t\t\t\t}\n\t\t\t\t\tif (!bits) {\n\t\t\t\t\t\tbits = info->bits;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//r_io_section_set_archbits (r->io, addr, arch, bits);\n\t\t\t}\n\t\t\tchar *pfx = r->bin->prefix;\n\t\t\tstr = r_str_newf (\"[%02d] %s section size %\" PFMT64d\" named %s%s%s\",\n\t\t\t\ti, perms, section->size,\n\t\t\t\tpfx? pfx: \"\", pfx? \".\": \"\", section->name);\n\t\t\tr_meta_add (r->anal, R_META_TYPE_COMMENT, addr, addr, str);\n\t\t\tR_FREE (str);\n\t\t\tif (section->add) {\n\t\t\t\tstr = r_str_newf (\"%\"PFMT64x\".%\"PFMT64x\".%\"PFMT64x\".%\"PFMT64x\".%\"PFMT32u\".%s.%\"PFMT32u\".%d\",\n\t\t\t\t\tsection->paddr, addr, section->size, section->vsize, section->srwx, section->name, r->bin->cur->id, fd);\n\t\t\t\tif (!ht_find (dup_chk_ht, str, NULL) && r_io_section_add (r->io, section->paddr, addr,\n\t\t\t\t\t\tsection->size, section->vsize,\n\t\t\t\t\t\tsection->srwx, section->name,\n\t\t\t\t\t\tr->bin->cur->id, fd)) {\n\t\t\t\t\tht_insert (dup_chk_ht, str, NULL);\n\t\t\t\t}\n\t\t\t\tR_FREE (str);\n\t\t\t}\n\t\t} else if (IS_MODE_SIMPLE (mode)) {\n\t\t\tchar *hashstr = NULL;\n\t\t\tif (chksum) {\n\t\t\t\tut8 *data = malloc (section->size);\n\t\t\t\tif (!data) {\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tut32 datalen = section->size;\n\t\t\t\tr_io_pread_at (r->io, section->paddr, data, datalen);\n\t\t\t\thashstr = build_hash_string (mode, chksum,\n\t\t\t\t\t\t\tdata, datalen);\n\t\t\t\tfree (data);\n\t\t\t}\n\t\t\tr_cons_printf (\"0x%\"PFMT64x\" 0x%\"PFMT64x\" %s %s%s%s\\n\",\n\t\t\t\taddr, addr + section->size,\n\t\t\t\tperms,\n\t\t\t\thashstr ? hashstr : \"\", hashstr ? \" \" : \"\",\n\t\t\t\tsection->name\n\t\t\t);\n\t\t\tfree (hashstr);\n\t\t} else if (IS_MODE_JSON (mode)) {\n\t\t\tchar *hashstr = NULL;\n\t\t\tif (chksum) {\n\t\t\t\tut8 *data = malloc (section->size);\n\t\t\t\tif (!data) {\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tut32 datalen = section->size;\n\t\t\t\tr_io_pread_at (r->io, section->paddr, data, datalen);\n\t\t\t\thashstr = build_hash_string (mode, chksum,\n\t\t\t\t\t\t\tdata, datalen);\n\t\t\t\tfree (data);\n\n\t\t\t}\n\t\t\tr_cons_printf (\"%s{\\\"name\\\":\\\"%s\\\",\"\n\t\t\t\t\"\\\"size\\\":%\"PFMT64d\",\"\n\t\t\t\t\"\\\"vsize\\\":%\"PFMT64d\",\"\n\t\t\t\t\"\\\"flags\\\":\\\"%s\\\",\"\n\t\t\t\t\"%s\"\n\t\t\t\t\"\\\"paddr\\\":%\"PFMT64d\",\"\n\t\t\t\t\"\\\"vaddr\\\":%\"PFMT64d\"}\",\n\t\t\t\t(iter->p && !printHere)?\",\":\"\",\n\t\t\t\tsection->name,\n\t\t\t\tsection->size,\n\t\t\t\tsection->vsize,\n\t\t\t\tperms,\n\t\t\t\thashstr ? hashstr : \"\",\n\t\t\t\tsection->paddr,\n\t\t\t\taddr);\n\t\t\tfree (hashstr);\n\t\t} else if (IS_MODE_RAD (mode)) {\n\t\t\tif (!strcmp (section->name, \".bss\") && !inDebugger) {\n#if LOAD_BSS_MALLOC\n\t\t\t\tr_cons_printf (\"on malloc://%d 0x%\"PFMT64x\" # bss\\n\",\n\t\t\t\t\t\tsection->vsize, addr);\n#endif\n\t\t\t}\n\t\t\tif (r->bin->prefix) {\n\t\t\t\tr_cons_printf (\"S 0x%08\"PFMT64x\" 0x%08\"PFMT64x\" 0x%08\"PFMT64x\" 0x%08\"PFMT64x\" %s.%s %d\\n\",\n\t\t\t\t\tsection->paddr, addr, section->size, section->vsize,\n\t\t\t\t\tr->bin->prefix, section->name, (int)section->srwx);\n\t\t\t} else {\n\t\t\t\tr_cons_printf (\"S 0x%08\"PFMT64x\" 0x%08\"PFMT64x\" 0x%08\"PFMT64x\" 0x%08\"PFMT64x\" %s %d\\n\",\n\t\t\t\t\tsection->paddr, addr, section->size, section->vsize,\n\t\t\t\t\tsection->name, (int)section->srwx);\n\n\t\t\t}\n\t\t\tif (section->arch || section->bits) {\n\t\t\t\tconst char *arch = section->arch;\n\t\t\t\tint bits = section->bits;\n\t\t\t\tif (info) {\n\t\t\t\t\tif (!arch) arch = info->arch;\n\t\t\t\t\tif (!bits) bits = info->bits;\n\t\t\t\t}\n\t\t\t\tif (!arch) {\n\t\t\t\t\tarch = r_config_get (r->config, \"asm.arch\");\n\t\t\t\t}\n\t\t\t\tr_cons_printf (\"Sa %s %d @ 0x%08\"\n\t\t\t\t\tPFMT64x\"\\n\", arch, bits, addr);\n\t\t\t}\n\t\t\tif (r->bin->prefix) {\n\t\t\t\tr_cons_printf (\"f %s.section.%s %\"PFMT64d\" 0x%08\"PFMT64x\"\\n\",\n\t\t\t\t\t\tr->bin->prefix, section->name, section->size, addr);\n\t\t\t\tr_cons_printf (\"f %s.section_end.%s 1 0x%08\"PFMT64x\"\\n\",\n\t\t\t\t\t\tr->bin->prefix, section->name, addr + section->vsize);\n\t\t\t\tr_cons_printf (\"CC section %i va=0x%08\"PFMT64x\" pa=0x%08\"PFMT64x\" sz=%\"PFMT64d\" vsz=%\"PFMT64d\" \"\n\t\t\t\t\t\t\"rwx=%s %s.%s @ 0x%08\"PFMT64x\"\\n\",\n\t\t\t\t\t\ti, addr, section->paddr, section->size, section->vsize,\n\t\t\t\t\t\tperms, r->bin->prefix, section->name, addr);\n\n\t\t\t} else {\n\t\t\t\tr_cons_printf (\"f section.%s %\"PFMT64d\" 0x%08\"PFMT64x\"\\n\",\n\t\t\t\t\t\tsection->name, section->size, addr);\n\t\t\t\tr_cons_printf (\"f section_end.%s 1 0x%08\"PFMT64x\"\\n\",\n\t\t\t\t\t\tsection->name, addr + section->vsize);\n\t\t\t\tr_cons_printf (\"CC section %i va=0x%08\"PFMT64x\" pa=0x%08\"PFMT64x\" sz=%\"PFMT64d\" vsz=%\"PFMT64d\" \"\n\t\t\t\t\t\t\"rwx=%s %s @ 0x%08\"PFMT64x\"\\n\",\n\t\t\t\t\t\ti, addr, section->paddr, section->size, section->vsize,\n\t\t\t\t\t\tperms, section->name, addr);\n\t\t\t}\n\t\t} else {\n\t\t\tchar *hashstr = NULL, str[128];\n\t\t\tif (chksum) {\n\t\t\t\tut8 *data = malloc (section->size);\n\t\t\t\tif (!data) {\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tut32 datalen = section->size;\n\t\t\t\t// VA READ IS BROKEN?\n\t\t\t\tr_io_pread_at (r->io, section->paddr, data, datalen);\n\t\t\t\thashstr = build_hash_string (mode, chksum,\n\t\t\t\t\t\t\tdata, datalen);\n\t\t\t\tfree (data);\n\t\t\t}\n\t\t\tif (section->arch || section->bits) {\n\t\t\t\tconst char *arch = section->arch;\n\t\t\t\tint bits = section->bits;\n\t\t\t\tif (!arch && info) {\n\t\t\t\t\tarch = info->arch;\n\t\t\t\t\tif (!arch) {\n\t\t\t\t\t\tarch = r_config_get (r->config, \"asm.arch\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!bits) {\n\t\t\t\t\tbits = info? info->bits: R_SYS_BITS;\n\t\t\t\t}\n\t\t\t\tsnprintf (str, sizeof (str), \"arch=%s bits=%d \",\n\t\t\t\t\tr_str_get2 (arch), bits);\n\t\t\t} else {\n\t\t\t\tstr[0] = 0;\n\t\t\t}\n\t\t\tif (r->bin->prefix) {\n#if 0\n\t\t\t\tr_cons_printf (\"idx=%02i vaddr=0x%08\"PFMT64x\" paddr=0x%08\"PFMT64x\" sz=%\"PFMT64d\" vsz=%\"PFMT64d\" \"\n\t\t\t\t\t\"perm=%s %s%sname=%s.%s\\n\",\n\t\t\t\t\ti, addr, section->paddr, section->size, section->vsize,\n\t\t\t\t\tperms, str, hashstr ?hashstr : \"\", r->bin->prefix, section->name);\n#endif\n\t\t\t\t// r_cons_printf (\"%02i 0x%08\"PFMT64x\" %10\"PFMT64d\" 0x%08\"PFMT64x\" %10\"PFMT64d\" \"\n\t\t\t\tr_cons_printf (\"%02i 0x%08\"PFMT64x\" %5\"PFMT64d\" 0x%08\"PFMT64x\" %5\"PFMT64d\" \"\n\t\t\t\t\t\"%s %s% %s.%s\\n\",\n\t\t\t\t\ti, section->paddr, section->size, addr, section->vsize,\n\t\t\t\t\tperms, str, hashstr ?hashstr : \"\", r->bin->prefix, section->name);\n\t\t\t} else {\n#if 0\n\t\t\t\tr_cons_printf (\"idx=%02i vaddr=0x%08\"PFMT64x\" paddr=0x%08\"PFMT64x\" sz=%\"PFMT64d\" vsz=%\"PFMT64d\" \"\n\t\t\t\t\t\"perm=%s %s%sname=%s\\n\",\n\t\t\t\t\ti, addr, section->paddr, section->size, section->vsize,\n\t\t\t\t\tperms, str, hashstr ?hashstr : \"\", section->name);\n#endif\n\t\t\t\t// r_cons_printf (\"%02i 0x%08\"PFMT64x\" %10\"PFMT64d\" 0x%08\"PFMT64x\" %10\"PFMT64d\" \"\n\t\t\t\tr_cons_printf (\"%02i 0x%08\"PFMT64x\" %5\"PFMT64d\" 0x%08\"PFMT64x\" %5\"PFMT64d\" \"\n\t\t\t\t\t\"%s %s%s%s\\n\",\n\t\t\t\t\ti, section->paddr, (ut64)section->size, addr, (ut64)section->vsize,\n\t\t\t\t\tperms, str, hashstr ?hashstr : \"\", section->name);\n\t\t\t}\n\t\t\tfree (hashstr);\n\t\t}\n\t\ti++;\n\t\tif (printHere) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (r->bin && r->bin->cur && r->io && !r_io_desc_is_dbg (r->io->desc)) {\n\t\tr_io_section_apply_bin (r->io, r->bin->cur->id, R_IO_SECTION_APPLY_FOR_ANALYSIS);\n\t}\n\tif (IS_MODE_JSON (mode) && !printHere) {\n\t\tr_cons_println (\"]\");\n\t} else if (IS_MODE_NORMAL (mode) && !at && !printHere) {\n\t\t// r_cons_printf (\"\\n%i sections\\n\", i);\n\t}\n\n\tret = true;\nout:\n\tht_free (dup_chk_ht);\n\treturn ret;\n}\n\nstatic int bin_fields(RCore *r, int mode, int va) {\n\tRList *fields;\n\tRListIter *iter;\n\tRBinField *field;\n\tint i = 0;\n\tRBin *bin = r->bin;\n\tRBinFile *binfile = r_core_bin_cur (r);\n\tut64 size = binfile ? binfile->size : UT64_MAX;\n\tut64 baddr = r_bin_get_baddr (r->bin);\n\n\tif (!(fields = r_bin_get_fields (bin))) {\n\t\treturn false;\n\t}\n\tif (IS_MODE_JSON (mode)) {\n\t\tr_cons_print (\"[\");\n\t} else if (IS_MODE_RAD (mode)) {\n\t\tr_cons_println (\"fs header\");\n\t} else if (IS_MODE_NORMAL (mode)) {\n\t\tr_cons_println (\"[Header fields]\");\n\t}\n//why this? there is an overlap in bin_sections with ehdr\n//because there can't be two sections with the same name\n#if 0\n\telse if (IS_MODE_SET (mode)) {\n\t\t// XXX: Need more flags??\n\t\t// this will be set even if the binary does not have an ehdr\n\t\tint fd = r_core_file_cur_fd(r);\n\t\tr_io_section_add (r->io, 0, baddr, size, size, 7, \"ehdr\", 0, fd);\n\t}\n#endif\n\tr_list_foreach (fields, iter, field) {\n\t\tut64 addr = rva (bin, field->paddr, field->vaddr, va);\n\n\t\tif (IS_MODE_RAD (mode)) {\n\t\t\tr_name_filter (field->name, -1);\n\t\t\tr_cons_printf (\"f header.%s @ 0x%08\"PFMT64x\"\\n\", field->name, addr);\n\t\t\tif (field->comment && *field->comment) {\n\t\t\t\tr_cons_printf (\"CC %s @ 0x%\"PFMT64x\"\\n\", field->comment, addr);\n\t\t\t}\n\t\t\tif (field->format && *field->format) {\n\t\t\t\tr_cons_printf (\"pf.%s %s\\n\", field->name, field->format);\n\t\t\t}\n\t\t} else if (IS_MODE_JSON (mode)) {\n\t\t\tr_cons_printf (\"%s{\\\"name\\\":\\\"%s\\\",\"\n\t\t\t\t\"\\\"vaddr\\\":%\"PFMT64d\",\"\n\t\t\t\t\"\\\"paddr\\\":%\"PFMT64d,\n\t\t\t\titer->p? \",\": \"\",\n\t\t\t\tfield->name,\n\t\t\t\tfield->vaddr,\n\t\t\t\tfield->paddr\n\t\t\t\t);\n\t\t\tif (field->comment && *field->comment) {\n\t\t\t\t// TODO: filter comment before json\n\t\t\t\tr_cons_printf (\",\\\"comment\\\":\\\"%s\\\"\", field->comment);\n\t\t\t}\n\t\t\tif (field->format && *field->format) {\n\t\t\t\t// TODO: filter comment before json\n\t\t\t\tr_cons_printf (\",\\\"format\\\":\\\"%s\\\"\", field->format);\n\t\t\t}\n\t\t\tr_cons_printf (\"}\");\n\t\t} else if (IS_MODE_NORMAL (mode)) {\n\t\t\tconst bool haveComment = (field->comment && *field->comment);\n\t\t\tr_cons_printf (\"0x%08\"PFMT64x\" 0x%08\"PFMT64x\" %s%s%s\\n\",\n\t\t\t\tfield->vaddr, field->paddr, field->name,\n\t\t\t\thaveComment? \"; \": \"\",\n\t\t\t\thaveComment? field->comment: \"\");\n\t\t}\n\t\ti++;\n\t}\n\tif (IS_MODE_JSON (mode)) {\n\t\tr_cons_printf (\"]\");\n\t} else if (IS_MODE_RAD (mode)) {\n\t\t/* add program header section */\n\t\tr_cons_printf (\"S 0 0x%\"PFMT64x\" 0x%\"PFMT64x\" 0x%\"PFMT64x\" ehdr rwx\\n\",\n\t\t\tbaddr, size, size);\n\t} else if (IS_MODE_NORMAL (mode)) {\n\t\tr_cons_printf (\"\\n%i fields\\n\", i);\n\t}\n\n\treturn true;\n}\n\nstatic char* get_rp (const char* rtype) {\n\tchar *rp = NULL;\n\tswitch(rtype[0]) {\n\tcase 'v':\n\t\trp = strdup (\"void\");\n\t\tbreak;\n\tcase 'c':\n\t\trp = strdup (\"char\");\n\t\tbreak;\n\tcase 'i':\n\t\trp = strdup (\"int\");\n\t\tbreak;\n\tcase 's':\n\t\trp = strdup (\"short\");\n\t\tbreak;\n\tcase 'l':\n\t\trp = strdup (\"long\");\n\t\tbreak;\n\tcase 'q':\n\t\trp = strdup (\"long long\");\n\t\tbreak;\n\tcase 'C':\n\t\trp = strdup (\"unsigned char\");\n\t\tbreak;\n\tcase 'I':\n\t\trp = strdup (\"unsigned int\");\n\t\tbreak;\n\tcase 'S':\n\t\trp = strdup (\"unsigned short\");\n\t\tbreak;\n\tcase 'L':\n\t\trp = strdup (\"unsigned long\");\n\t\tbreak;\n\tcase 'Q':\n\t\trp = strdup (\"unsigned long long\");\n\t\tbreak;\n\tcase 'f':\n\t\trp = strdup (\"float\");\n\t\tbreak;\n\tcase 'd':\n\t\trp = strdup (\"double\");\n\t\tbreak;\n\tcase 'D':\n\t\trp = strdup (\"long double\");\n\t\tbreak;\n\tcase 'B':\n\t\trp = strdup (\"bool\");\n\t\tbreak;\n\tcase '#':\n\t\trp = strdup (\"CLASS\");\n\t\tbreak;\n\tdefault:\n\t\trp = strdup (\"unknown\");\n\t\tbreak;\n\t}\n\treturn rp;\n}\n\nstatic int bin_classes(RCore *r, int mode) {\n\tRListIter *iter, *iter2, *iter3;\n\tRBinSymbol *sym;\n\tRBinClass *c;\n\tRBinField *f;\n\tchar *name;\n\tRList *cs = r_bin_get_classes (r->bin);\n\tif (!cs) {\n\t\tif (IS_MODE_JSON (mode)) {\n\t\t\tr_cons_print(\"[]\");\n\t\t}\n\t\treturn false;\n\t}\n\t// XXX: support for classes is broken and needs more love\n\tif (IS_MODE_JSON (mode)) {\n\t\tr_cons_print (\"[\");\n\t} else if (IS_MODE_SET (mode)) {\n\t\tif (!r_config_get_i (r->config, \"bin.classes\")) {\n\t\t\treturn false;\n\t\t}\n\t\tr_flag_space_set (r->flags, \"classes\");\n\t} else if (IS_MODE_RAD (mode)) {\n\t\tr_cons_println (\"fs classes\");\n\t}\n\n\tr_list_foreach (cs, iter, c) {\n\t\tif (!c || !c->name || !c->name[0]) {\n\t\t\tcontinue;\n\t\t}\n\t\tname = strdup (c->name);\n\t\tr_name_filter (name, 0);\n\t\tut64 at_min = UT64_MAX;\n\t\tut64 at_max = 0LL;\n\n\t\tr_list_foreach (c->methods, iter2, sym) {\n\t\t\tif (sym->vaddr) {\n\t\t\t\tif (sym->vaddr < at_min) {\n\t\t\t\t\tat_min = sym->vaddr;\n\t\t\t\t}\n\t\t\t\tif (sym->vaddr + sym->size > at_max) {\n\t\t\t\t\tat_max = sym->vaddr + sym->size;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (at_min == UT64_MAX) {\n\t\t\tat_min = c->addr;\n\t\t\tat_max = c->addr; // XXX + size?\n\t\t}\n\n\t\tif (IS_MODE_SET (mode)) {\n\t\t\tconst char *classname = sdb_fmt (\"class.%s\", name);\n\t\t\tr_flag_set (r->flags, classname, c->addr, 1);\n\t\t\tr_list_foreach (c->methods, iter2, sym) {\n\t\t\t\tchar *mflags = r_core_bin_method_flags_str (sym->method_flags, mode);\n\t\t\t\tchar *method = sdb_fmt (\"method%s.%s.%s\",\n\t\t\t\t\tmflags, c->name, sym->name);\n\t\t\t\tR_FREE (mflags);\n\t\t\t\tr_name_filter (method, -1);\n\t\t\t\tr_flag_set (r->flags, method, sym->vaddr, 1);\n\t\t\t}\n\t\t} else if (IS_MODE_SIMPLE (mode)) {\n\t\t\tr_cons_printf (\"0x%08\"PFMT64x\" [0x%08\"PFMT64x\" - 0x%08\"PFMT64x\"] %s%s%s\\n\",\n\t\t\t\tc->addr, at_min, at_max, c->name, c->super ? \" \" : \"\",\n\t\t\t\tc->super ? c->super : \"\");\n\t\t} else if (IS_MODE_RAD (mode)) {\n\t\t\tr_cons_printf (\"\\\"f class.%s = 0x%\"PFMT64x\"\\\"\\n\",\n\t\t\t\tname, at_min);\n\t\t\tif (c->super) {\n\t\t\t\tr_cons_printf (\"\\\"f super.%s.%s = %d\\\"\\n\",\n\t\t\t\t\tc->name, c->super, c->index);\n\t\t\t}\n\t\t\tr_list_foreach (c->methods, iter2, sym) {\n\t\t\t\tchar *mflags = r_core_bin_method_flags_str (sym->method_flags, mode);\n\t\t\t\tchar *cmd = r_str_newf (\"\\\"f method%s.%s.%s = 0x%\"PFMT64x\"\\\"\\n\", mflags, c->name, sym->name, sym->vaddr);\n\t\t\t\tr_str_replace_char (cmd, '\\n', 0);\n\t\t\t\tr_cons_printf (\"%s\\n\", cmd);\n\t\t\t\tR_FREE (mflags);\n\t\t\t\tfree (cmd);\n\t\t\t}\n\t\t} else if (IS_MODE_JSON (mode)) {\n\t\t\tif (c->super) {\n\t\t\t\tr_cons_printf (\"%s{\\\"classname\\\":\\\"%s\\\",\\\"addr\\\":%\"PFMT64d\",\\\"index\\\":%d,\\\"super\\\":\\\"%s\\\",\\\"methods\\\":[\",\n\t\t\t\t\titer->p ? \",\" : \"\", c->name, c->addr,\n\t\t\t\t\tc->index, c->super);\n\t\t\t} else {\n\t\t\t\tr_cons_printf (\"%s{\\\"classname\\\":\\\"%s\\\",\\\"addr\\\":%\"PFMT64d\",\\\"index\\\":%d,\\\"methods\\\":[\",\n\t\t\t\t\titer->p ? \",\" : \"\", c->name, c->addr,\n\t\t\t\t\tc->index);\n\t\t\t}\n\t\t\tr_list_foreach (c->methods, iter2, sym) {\n\t\t\t\tif (sym->method_flags) {\n\t\t\t\t\tchar *mflags = r_core_bin_method_flags_str (sym->method_flags, mode);\n\t\t\t\t\tr_cons_printf (\"%s{\\\"name\\\":\\\"%s\\\",\\\"flags\\\":%s,\\\"addr\\\":%\"PFMT64d\"}\",\n\t\t\t\t\t\titer2->p? \",\": \"\", sym->name, mflags, sym->vaddr);\n\t\t\t\t\tR_FREE (mflags);\n\t\t\t\t} else {\n\t\t\t\t\tr_cons_printf (\"%s{\\\"name\\\":\\\"%s\\\",\\\"addr\\\":%\"PFMT64d\"}\",\n\t\t\t\t\t\titer2->p? \",\": \"\", sym->name, sym->vaddr);\n\t\t\t\t}\n\t\t\t}\n\t\t\tr_cons_printf (\"], \\\"fields\\\":[\");\n\t\t\tr_list_foreach (c->fields, iter3, f) {\n\t\t\t\tif (f->flags) {\n\t\t\t\t\tchar *mflags = r_core_bin_method_flags_str (f->flags, mode);\n\t\t\t\t\tr_cons_printf (\"%s{\\\"name\\\":\\\"%s\\\",\\\"flags\\\":%s,\\\"addr\\\":%\"PFMT64d\"}\",\n\t\t\t\t\t\titer3->p? \",\": \"\", f->name, mflags, f->vaddr);\n\t\t\t\t\tR_FREE (mflags);\n\t\t\t\t} else {\n\t\t\t\t\tr_cons_printf (\"%s{\\\"name\\\":\\\"%s\\\",\\\"addr\\\":%\"PFMT64d\"}\",\n\t\t\t\t\t\titer3->p? \",\": \"\", f->name, f->vaddr);\n\t\t\t\t}\n\t\t\t}\n\t\t\tr_cons_printf (\"]}\");\n\t\t} else if (IS_MODE_CLASSDUMP (mode)) {\n\t\t\tchar *rp = NULL;\n\t\t\tif (c) {\n\t\t\t\t//TODO -> Print Superclass\n\t\t\t\tr_cons_printf (\"@interface %s :  \\n{\\n\", c->name);\n\t\t\t\tr_list_foreach (c->fields, iter2, f) {\n\t\t\t\t\tif (f->name && r_regex_match (\"ivar\",\"e\", f->name)) {\n\t\t\t\t\t\tr_cons_printf (\"  %s %s\\n\", f->type, f->name);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tr_cons_printf (\"}\\n\");\n\t\t\t\tr_list_foreach (c->methods, iter3, sym) {\n\t\t\t\t\tif (sym->rtype && sym->rtype[0] != '@') {\n\t\t\t\t\t\trp = get_rp (sym->rtype);\n\t\t\t\t\t\tr_cons_printf (\"%s (%s) %s\\n\", strncmp (sym->type,\"METH\",4) ? \"+\": \"-\", rp, sym->dname? sym->dname: sym->name);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tr_cons_printf (\"@end\\n\");\n\t\t\t}\n\t\t} else {\n\t\t\tint m = 0;\n\t\t\tr_cons_printf (\"0x%08\"PFMT64x\" [0x%08\"PFMT64x\" - 0x%08\"PFMT64x\"] (sz %\"PFMT64d\") class %d %s\",\n\t\t\t\tc->addr, at_min, at_max, (at_max - at_min), c->index, c->name);\n\t\t\tif (c->super) {\n\t\t\t\tr_cons_printf (\" super: %s\\n\", c->super);\n\t\t\t} else {\n\t\t\t\tr_cons_newline ();\n\t\t\t}\n\t\t\tr_list_foreach (c->methods, iter2, sym) {\n\t\t\t\tchar *mflags = r_core_bin_method_flags_str (sym->method_flags, mode);\n\t\t\t\tr_cons_printf (\"0x%08\"PFMT64x\" method %d %s %s\\n\",\n\t\t\t\t\tsym->vaddr, m, mflags, sym->dname? sym->dname: sym->name);\n\t\t\t\tR_FREE (mflags);\n\t\t\t\tm++;\n\t\t\t}\n\t\t}\n\t\tfree (name);\n\t}\n\tif (IS_MODE_JSON (mode)) {\n\t\tr_cons_print (\"]\");\n\t}\n\n\treturn true;\n}\n\nstatic int bin_size(RCore *r, int mode) {\n\tut64 size = r_bin_get_size (r->bin);\n\tif (IS_MODE_SIMPLE (mode) || IS_MODE_JSON (mode)) {\n\t\tr_cons_printf (\"%\"PFMT64u\"\\n\", size);\n\t} else if (IS_MODE_RAD (mode)) {\n\t\tr_cons_printf (\"f bin_size @ %\"PFMT64u\"\\n\", size);\n\t} else if (IS_MODE_SET (mode)) {\n\t\tr_core_cmdf (r, \"f bin_size @ %\"PFMT64u\"\\n\", size);\n\t} else {\n\t\tr_cons_printf (\"%\"PFMT64u\"\\n\", size);\n\t}\n\treturn true;\n}\n\nstatic int bin_libs(RCore *r, int mode) {\n\tRList *libs;\n\tRListIter *iter;\n\tchar* lib;\n\tint i = 0;\n\n\tif (!(libs = r_bin_get_libs (r->bin))) {\n\t\treturn false;\n\t}\n\tif (IS_MODE_JSON (mode)) {\n\t\tr_cons_print (\"[\");\n\t} else if (IS_MODE_NORMAL (mode)) {\n\t\tr_cons_println (\"[Linked libraries]\");\n\t}\n\tr_list_foreach (libs, iter, lib) {\n\t\tif (IS_MODE_SET (mode)) {\n\t\t\t// Nothing to set.\n\t\t\t// TODO: load libraries with iomaps?\n\t\t} else if (IS_MODE_RAD (mode)) {\n\t\t\tr_cons_printf (\"CCa entry0 %s\\n\", lib);\n\t\t} else if (IS_MODE_JSON (mode)) {\n\t\t\tr_cons_printf (\"%s\\\"%s\\\"\", iter->p ? \",\" : \"\", lib);\n\t\t} else {\n\t\t\t// simple and normal print mode\n\t\t\tr_cons_println (lib);\n\t\t}\n\t\ti++;\n\t}\n\tif (IS_MODE_JSON (mode)) {\n\t\tr_cons_print (\"]\");\n\t} else if (IS_MODE_NORMAL (mode)) {\n\t\tif (i == 1) {\n\t\t\tr_cons_printf (\"\\n%i library\\n\", i);\n\t\t} else {\n\t\t\tr_cons_printf (\"\\n%i libraries\\n\", i);\n\t\t}\n\t}\n\treturn true;\n}\n\nstatic void bin_mem_print(RList *mems, int perms, int depth, int mode) {\n\tRBinMem *mem;\n\tRListIter *iter;\n\tif (!mems) {\n\t\treturn;\n\t}\n\tr_list_foreach (mems, iter, mem) {\n\t\tif (IS_MODE_JSON (mode)) {\n\t\t\tr_cons_printf (\"{\\\"name\\\":\\\"%s\\\",\\\"size\\\":%d,\\\"address\\\":%d,\"\n\t\t\t\t\t\"\\\"flags\\\":\\\"%s\\\"}\", mem->name, mem->size,\n\t\t\t\t\tmem->addr, r_str_rwx_i (mem->perms & perms));\n\t\t} else if (IS_MODE_SIMPLE (mode)) {\n\t\t\tr_cons_printf (\"0x%08\"PFMT64x\"\\n\", mem->addr);\n\t\t} else {\n\t\t\tr_cons_printf (\"0x%08\"PFMT64x\" +0x%04x %s %*s%-*s\\n\",\n\t\t\t\t\tmem->addr, mem->size, r_str_rwx_i (mem->perms & perms),\n\t\t\t\t\tdepth, \"\", 20-depth, mem->name);\n\t\t}\n\t\tif (mem->mirrors) {\n\t\t\tif (IS_MODE_JSON (mode)) {\n\t\t\t\tr_cons_printf (\",\");\n\t\t\t}\n\t\t\tbin_mem_print (mem->mirrors, mem->perms & perms, depth + 1, mode);\n\t\t}\n\t\tif (IS_MODE_JSON(mode)) {\n\t\t\tif (iter->n) {\n\t\t\t\tr_cons_printf (\",\");\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic int bin_mem(RCore *r, int mode) {\n\tRList *mem = NULL;\n\tif (!r)\treturn false;\n\tif (!IS_MODE_JSON(mode)) {\n\t\tif (!(IS_MODE_RAD (mode) || IS_MODE_SET (mode))) {\n\t\t\tr_cons_println (\"[Memory]\\n\");\n\t\t}\n\t}\n\tif (!(mem = r_bin_get_mem (r->bin))) {\n\t\tif (IS_MODE_JSON (mode)) {\n\t\t\tr_cons_print(\"[]\");\n\t\t}\n\t\treturn false;\n\t}\n\tif (IS_MODE_JSON (mode)) {\n\t\tr_cons_print (\"[\");\n\t\tbin_mem_print (mem, 7, 0, R_CORE_BIN_JSON);\n\t\tr_cons_println (\"]\");\n\t\treturn true;\n\t} else if (!(IS_MODE_RAD (mode) || IS_MODE_SET (mode))) {\n\t\tbin_mem_print (mem, 7, 0, mode);\n\t}\n\treturn true;\n}\n\nstatic void bin_pe_versioninfo(RCore *r, int mode) {\n\tSdb *sdb = NULL;\n\tint num_version = 0;\n\tint num_stringtable = 0;\n\tint num_string = 0;\n\tconst char *format_version = \"bin/cur/info/vs_version_info/VS_VERSIONINFO%d\";\n\tconst char *format_stringtable = \"%s/string_file_info/stringtable%d\";\n\tconst char *format_string = \"%s/string%d\";\n\tif (!IS_MODE_JSON (mode)) {\n\t\tr_cons_printf (\"=== VS_VERSIONINFO ===\\n\\n\");\n\t}\n\tbool firstit_dowhile = true;\n\tdo {\n\t\tchar path_version[256] = R_EMPTY;\n\t\tsnprintf (path_version, sizeof (path_version), format_version, num_version);\n\t\tif (!(sdb = sdb_ns_path (r->sdb, path_version, 0))) {\n\t\t\tbreak;\n\t\t}\n\t\tif (!firstit_dowhile && IS_MODE_JSON (mode)) { r_cons_printf (\",\"); }\n\t\tif (IS_MODE_JSON (mode)) {\n\t\t\tr_cons_printf (\"{\\\"VS_FIXEDFILEINFO\\\":{\");\n\t\t} else {\n\t\t\tr_cons_printf (\"# VS_FIXEDFILEINFO\\n\\n\");\n\t\t}\n\t\tchar path_fixedfileinfo[256] = R_EMPTY;\n\t\tsnprintf (path_fixedfileinfo, sizeof (path_fixedfileinfo), \"%s/fixed_file_info\", path_version);\n\t\tif (!(sdb = sdb_ns_path (r->sdb, path_fixedfileinfo, 0))) {\n\t\t\tr_cons_printf (\"}\");\n\t\t\tbreak;\n\t\t}\n\t\tif (IS_MODE_JSON (mode)) {\n\t\t\tr_cons_printf (\"\\\"Signature\\\":%\"PFMT64u\",\", sdb_num_get (sdb, \"Signature\", 0));\n\t\t} else {\n\t\t\tr_cons_printf (\"  Signature: 0x%\"PFMT64x\"\\n\", sdb_num_get (sdb, \"Signature\", 0));\n\t\t}\n\t\tif (IS_MODE_JSON (mode)) {\n\t\t\tr_cons_printf (\"\\\"StrucVersion\\\":%\"PFMT64u\",\", sdb_num_get (sdb, \"StrucVersion\", 0));\n\t\t} else {\n\t\t\tr_cons_printf (\"  StrucVersion: 0x%\"PFMT64x\"\\n\", sdb_num_get (sdb, \"StrucVersion\", 0));\n\t\t}\n\t\tif (IS_MODE_JSON (mode)) {\n\t\t\tr_cons_printf (\"\\\"FileVersion\\\":\\\"%\"PFMT64d\".%\"PFMT64d\".%\"PFMT64d\".%\"PFMT64d\"\\\",\",\n\t\t\t\tsdb_num_get (sdb, \"FileVersionMS\", 0) >> 16,\n\t\t\t\tsdb_num_get (sdb, \"FileVersionMS\", 0) & 0xFFFF,\n\t\t\t\tsdb_num_get (sdb, \"FileVersionLS\", 0) >> 16,\n\t\t\t\tsdb_num_get (sdb, \"FileVersionLS\", 0) & 0xFFFF);\n\t\t} else {\n\t\t\tr_cons_printf (\"  FileVersion: %\"PFMT64d\".%\"PFMT64d\".%\"PFMT64d\".%\"PFMT64d\"\\n\",\n\t\t\t\tsdb_num_get (sdb, \"FileVersionMS\", 0) >> 16,\n\t\t\t\tsdb_num_get (sdb, \"FileVersionMS\", 0) & 0xFFFF,\n\t\t\t\tsdb_num_get (sdb, \"FileVersionLS\", 0) >> 16,\n\t\t\t\tsdb_num_get (sdb, \"FileVersionLS\", 0) & 0xFFFF);\n\t\t}\n\t\tif (IS_MODE_JSON (mode)) {\n\t\t\tr_cons_printf (\"\\\"ProductVersion\\\":\\\"%\"PFMT64d\".%\"PFMT64d\".%\"PFMT64d\".%\"PFMT64d\"\\\",\",\n\t\t\t\tsdb_num_get (sdb, \"ProductVersionMS\", 0) >> 16,\n\t\t\t\tsdb_num_get (sdb, \"ProductVersionMS\", 0) & 0xFFFF,\n\t\t\t\tsdb_num_get (sdb, \"ProductVersionLS\", 0) >> 16,\n\t\t\t\tsdb_num_get (sdb, \"ProductVersionLS\", 0) & 0xFFFF);\n\t\t} else {\n\t\t\tr_cons_printf (\"  ProductVersion: %\"PFMT64d\".%\"PFMT64d\".%\"PFMT64d\".%\"PFMT64d\"\\n\",\n\t\t\t\tsdb_num_get (sdb, \"ProductVersionMS\", 0) >> 16,\n\t\t\t\tsdb_num_get (sdb, \"ProductVersionMS\", 0) & 0xFFFF,\n\t\t\t\tsdb_num_get (sdb, \"ProductVersionLS\", 0) >> 16,\n\t\t\t\tsdb_num_get (sdb, \"ProductVersionLS\", 0) & 0xFFFF);\n\t\t}\n\t\tif (IS_MODE_JSON (mode)) {\n\t\t\tr_cons_printf (\"\\\"FileFlagsMask\\\":%\"PFMT64u\",\", sdb_num_get (sdb, \"FileFlagsMask\", 0));\n\t\t} else {\n\t\t\tr_cons_printf (\"  FileFlagsMask: 0x%\"PFMT64x\"\\n\", sdb_num_get (sdb, \"FileFlagsMask\", 0));\n\t\t}\n\t\tif (IS_MODE_JSON (mode)) {\n\t\t\tr_cons_printf (\"\\\"FileFlags\\\":%\"PFMT64u\",\", sdb_num_get (sdb, \"FileFlags\", 0));\n\t\t} else {\n\t\t\tr_cons_printf (\"  FileFlags: 0x%\"PFMT64x\"\\n\", sdb_num_get (sdb, \"FileFlags\", 0));\n\t\t}\n\t\tif (IS_MODE_JSON (mode)) {\n\t\t\tr_cons_printf (\"\\\"FileOS\\\":%\"PFMT64u\",\", sdb_num_get (sdb, \"FileOS\", 0));\n\t\t} else {\n\t\t\tr_cons_printf (\"  FileOS: 0x%\"PFMT64x\"\\n\", sdb_num_get (sdb, \"FileOS\", 0));\n\t\t}\n\t\tif (IS_MODE_JSON (mode)) {\n\t\t\tr_cons_printf (\"\\\"FileType\\\":%\"PFMT64u\",\", sdb_num_get (sdb, \"FileType\", 0));\n\t\t} else {\n\t\t\tr_cons_printf (\"  FileType: 0x%\"PFMT64x\"\\n\", sdb_num_get (sdb, \"FileType\", 0));\n\t\t}\n\t\tif (IS_MODE_JSON (mode)) {\n\t\t\tr_cons_printf (\"\\\"FileSubType\\\":%\"PFMT64u, sdb_num_get (sdb, \"FileSubType\", 0));\n\t\t} else {\n\t\t\tr_cons_printf (\"  FileSubType: 0x%\"PFMT64x\"\\n\", sdb_num_get (sdb, \"FileSubType\", 0));\n\t\t}\n#if 0\n\t\tr_cons_printf (\"  FileDate: %d.%d.%d.%d\\n\",\n\t\t\tsdb_num_get (sdb, \"FileDateMS\", 0) >> 16,\n\t\t\tsdb_num_get (sdb, \"FileDateMS\", 0) & 0xFFFF,\n\t\t\tsdb_num_get (sdb, \"FileDateLS\", 0) >> 16,\n\t\t\tsdb_num_get (sdb, \"FileDateLS\", 0) & 0xFFFF);\n#endif\n\t\tif (IS_MODE_JSON (mode)) {\n\t\t\tr_cons_printf (\"},\");\n\t\t} else {\n\t\t\tr_cons_newline ();\n\t\t}\n\t\tif (IS_MODE_JSON (mode)) {\n\t\t\tr_cons_printf (\"\\\"StringTable\\\":{\");\n\t\t} else {\n\t\t\tr_cons_printf (\"# StringTable\\n\\n\");\n\t\t}\n\t\tfor (num_stringtable = 0; sdb; num_stringtable++) {\n\t\t\tchar path_stringtable[256] = R_EMPTY;\n\t\t\tsnprintf (path_stringtable, sizeof (path_stringtable), format_stringtable, path_version, num_stringtable);\n\t\t\tsdb = sdb_ns_path (r->sdb, path_stringtable, 0);\n\t\t\tbool firstit_for = true;\n\t\t\tfor (num_string = 0; sdb; num_string++) {\n\t\t\t\tchar path_string[256] = R_EMPTY;\n\t\t\t\tsnprintf (path_string, sizeof (path_string), format_string, path_stringtable, num_string);\n\t\t\t\tsdb = sdb_ns_path (r->sdb, path_string, 0);\n\t\t\t\tif (sdb) {\n\t\t\t\t\tif (!firstit_for && IS_MODE_JSON (mode)) { r_cons_printf (\",\"); }\n\t\t\t\t\tint lenkey = 0;\n\t\t\t\t\tint lenval = 0;\n\t\t\t\t\tut8 *key_utf16 = sdb_decode (sdb_const_get (sdb, \"key\", 0), &lenkey);\n\t\t\t\t\tut8 *val_utf16 = sdb_decode (sdb_const_get (sdb, \"value\", 0), &lenval);\n\t\t\t\t\tut8 *key_utf8 = calloc (lenkey * 2, 1);\n\t\t\t\t\tut8 *val_utf8 = calloc (lenval * 2, 1);\n\n\t\t\t\t\tif (r_str_utf16_to_utf8 (key_utf8, lenkey * 2, key_utf16, lenkey, true) < 0\n\t\t\t\t\t\t|| r_str_utf16_to_utf8 (val_utf8, lenval * 2, val_utf16, lenval, true) < 0) {\n\t\t\t\t\t\teprintf (\"Warning: Cannot decode utf16 to utf8\\n\");\n\t\t\t\t\t} else if (IS_MODE_JSON (mode)) {\n\t\t\t\t\t\tchar *escaped_key_utf8 = r_str_escape ((char*)key_utf8);\n\t\t\t\t\t\tchar *escaped_val_utf8 = r_str_escape ((char*)val_utf8);\n\t\t\t\t\t\tr_cons_printf (\"\\\"%s\\\":\\\"%s\\\"\", escaped_key_utf8, escaped_val_utf8);\n\t\t\t\t\t\tfree (escaped_key_utf8);\n\t\t\t\t\t\tfree (escaped_val_utf8);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tr_cons_printf (\"  %s: %s\\n\", (char*)key_utf8, (char*)val_utf8);\n\t\t\t\t\t}\n\n\t\t\t\t\tfree (key_utf8);\n\t\t\t\t\tfree (val_utf8);\n\t\t\t\t\tfree (key_utf16);\n\t\t\t\t\tfree (val_utf16);\n\t\t\t\t}\n\t\t\t\tfirstit_for = false;\n\t\t\t}\n\t\t}\n\t\tif (IS_MODE_JSON (mode)) {\n\t\t\tr_cons_printf (\"}}\");\n\t\t}\n\t\tnum_version++;\n\t\tfirstit_dowhile = false;\n\t} while (sdb);\n}\n\nstatic void bin_elf_versioninfo(RCore *r, int mode) {\n\tconst char *format = \"bin/cur/info/versioninfo/%s%d\";\n\tchar path[256] = {0};\n\tint num_versym = 0;\n\tint num_verneed = 0;\n\tint num_version = 0;\n\tSdb *sdb = NULL;\n\tconst char *oValue = NULL;\n\tbool firstit_for_versym = true;\n\tif (IS_MODE_JSON (mode)) {\n\t\tr_cons_printf (\"{\\\"versym\\\":[\");\n\t}\n\tfor (;; num_versym++) {\n\t\tsnprintf (path, sizeof (path), format, \"versym\", num_versym);\n\t\tif (!(sdb = sdb_ns_path (r->sdb, path, 0))) {\n\t\t\tbreak;\n\t\t}\n\t\tut64 addr = sdb_num_get (sdb, \"addr\", 0);\n\t\tut64 offset = sdb_num_get (sdb, \"offset\", 0);\n\t\tut64 link = sdb_num_get (sdb, \"link\", 0);\n\t\tut64 num_entries = sdb_num_get (sdb, \"num_entries\", 0);\n\t\tconst char *section_name = sdb_const_get (sdb, \"section_name\", 0);\n\t\tconst char *link_section_name = sdb_const_get (sdb, \"link_section_name\", 0);\n\n\t\tif (IS_MODE_JSON (mode)) {\n\t\t\tif (!firstit_for_versym) { r_cons_printf (\",\"); }\n\t\t\tr_cons_printf (\"{\\\"section_name\\\":\\\"%s\\\",\\\"address\\\":%\"PFMT64u\",\\\"offset\\\":%\"PFMT64u\",\",\n\t\t\t\t\tsection_name, (ut64)addr, (ut64)offset);\n\t\t\tr_cons_printf (\"\\\"link\\\":%\"PFMT64u\",\\\"link_section_name\\\":\\\"%s\\\",\\\"entries\\\":[\",\n\t\t\t\t\t(ut32)link, link_section_name);\n\t\t} else {\n\t\t\tr_cons_printf (\"Version symbols section '%s' contains %\"PFMT64u\" entries:\\n\", section_name, num_entries);\n\t\t\tr_cons_printf (\" Addr: 0x%08\"PFMT64x\"  Offset: 0x%08\"PFMT64x\"  Link: %x (%s)\\n\",\n\t\t\t\t(ut64)addr, (ut64)offset, (ut32)link, link_section_name);\n\t\t}\n\t\tint i;\n\t\tfor (i = 0; i < num_entries; i++) {\n\t\t\tchar key[32] = R_EMPTY;\n\t\t\tsnprintf (key, sizeof (key), \"entry%d\", i);\n\t\t\tconst char *value = sdb_const_get (sdb, key, 0);\n\t\t\tif (value) {\n\t\t\t\tif (oValue && !strcmp (value, oValue)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (IS_MODE_JSON (mode)) {\n\t\t\t\t\tif (i > 0) { r_cons_printf (\",\"); }\n\t\t\t\t\tchar *escaped_value = r_str_escape (value);\n\t\t\t\t\tr_cons_printf (\"{\\\"idx\\\":%\"PFMT64u\",\\\"value\\\":\\\"%s\\\"}\",\n\t\t\t\t\t\t\t(ut64) i, escaped_value);\n\t\t\t\t\tfree (escaped_value);\n\t\t\t\t} else {\n\t\t\t\t\tr_cons_printf (\"  0x%08\"PFMT64x\": \", (ut64) i);\n\t\t\t\t\tr_cons_printf (\"%s\\n\", value);\n\t\t\t\t}\n\t\t\t\toValue = value;\n\t\t\t}\n\t\t}\n\t\tif (IS_MODE_JSON (mode)) {\n\t\t\tr_cons_printf (\"]}\");\n\t\t} else {\n\t\t\tr_cons_printf (\"\\n\\n\");\n\t\t}\n\t\tfirstit_for_versym = false;\n\t}\n\tif (IS_MODE_JSON (mode)) { r_cons_printf (\"],\\\"verneed\\\":[\"); }\n\n\tbool firstit_dowhile_verneed = true;\n\tdo {\n\t\tchar path_version[256] = R_EMPTY;\n\t\tsnprintf (path, sizeof (path), format, \"verneed\", num_verneed++);\n\t\tif (!(sdb = sdb_ns_path (r->sdb, path, 0))) {\n\t\t\tbreak;\n\t\t}\n\n\t\tif (IS_MODE_JSON (mode)) {\n\t\t\tif (!firstit_dowhile_verneed) { r_cons_printf (\",\"); }\n\t\t\tr_cons_printf (\"{\\\"section_name\\\":\\\"%s\\\",\\\"address\\\":%\"PFMT64u\",\\\"offset\\\":%\"PFMT64u\",\",\n\t\t\t\tsdb_const_get (sdb, \"section_name\", 0), sdb_num_get (sdb, \"addr\", 0), sdb_num_get (sdb, \"offset\", 0));\n\t\t\tr_cons_printf (\"\\\"link\\\":%\"PFMT64u\",\\\"link_section_name\\\":\\\"%s\\\",\\\"entries\\\":[\",\n\t\t\t\tsdb_num_get (sdb, \"link\", 0), sdb_const_get (sdb, \"link_section_name\", 0));\n\t\t} else {\n\t\t\tr_cons_printf (\"Version need section '%s' contains %d entries:\\n\",\n\t\t\t\tsdb_const_get (sdb, \"section_name\", 0), (int)sdb_num_get (sdb, \"num_entries\", 0));\n\n\t\t\tr_cons_printf (\" Addr: 0x%08\"PFMT64x, sdb_num_get (sdb, \"addr\", 0));\n\n\t\t\tr_cons_printf (\"  Offset: 0x%08\"PFMT64x\"  Link to section: %\"PFMT64d\" (%s)\\n\",\n\t\t\t\tsdb_num_get (sdb, \"offset\", 0), sdb_num_get (sdb, \"link\", 0),\n\t\t\t\tsdb_const_get (sdb, \"link_section_name\", 0));\n\t\t}\n\t\tbool firstit_for_verneed = true;\n\t\tfor (num_version = 0;; num_version++) {\n\t\t\tsnprintf (path_version, sizeof (path_version), \"%s/version%d\", path, num_version);\n\t\t\tconst char *filename = NULL;\n\t\t\tchar path_vernaux[256] = R_EMPTY;\n\t\t\tint num_vernaux = 0;\n\t\t\tif (!(sdb = sdb_ns_path (r->sdb, path_version, 0))) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (IS_MODE_JSON (mode)) {\n\t\t\t\tif (!firstit_for_verneed) { r_cons_printf (\",\"); }\n\t\t\t\tr_cons_printf (\"{\\\"idx\\\":%\"PFMT64u\",\\\"vn_version\\\":%d,\",\n\t\t\t\t\tsdb_num_get (sdb, \"idx\", 0), (int)sdb_num_get (sdb, \"vn_version\", 0));\n\t\t\t} else {\n\t\t\t\tr_cons_printf (\"  0x%08\"PFMT64x\": Version: %d\",\n\t\t\t\t\tsdb_num_get (sdb, \"idx\", 0), (int)sdb_num_get (sdb, \"vn_version\", 0));\n\t\t\t}\n\n\t\t\tif ((filename = sdb_const_get (sdb, \"file_name\", 0))) {\n\t\t\t\tif (IS_MODE_JSON (mode)) {\n\t\t\t\t\tchar *escaped_filename = r_str_escape (filename);\n\t\t\t\t\tr_cons_printf (\"\\\"file_name\\\":\\\"%s\\\",\", escaped_filename);\n\t\t\t\t\tfree (escaped_filename);\n\t\t\t\t} else {\n\t\t\t\t\tr_cons_printf (\"  File: %s\", filename);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (IS_MODE_JSON (mode)) {\n\t\t\t\tr_cons_printf (\"\\\"cnt\\\":%d,\", (int)sdb_num_get (sdb, \"cnt\", 0));\n\t\t\t} else {\n\t\t\t\tr_cons_printf (\"  Cnt: %d\\n\", (int)sdb_num_get (sdb, \"cnt\", 0));\n\t\t\t}\n\t\t\tif (IS_MODE_JSON (mode)) {\n\t\t\t\tr_cons_printf (\"\\\"vernaux\\\":[\");\n\t\t\t}\n\t\t\tbool firstit_dowhile_vernaux = true;\n\t\t\tdo {\n\t\t\t\tsnprintf (path_vernaux, sizeof (path_vernaux), \"%s/vernaux%d\",\n\t\t\t\t\tpath_version, num_vernaux++);\n\t\t\t\tif (!(sdb = sdb_ns_path (r->sdb, path_vernaux, 0))) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (IS_MODE_JSON (mode)) {\n\t\t\t\t\tif (!firstit_dowhile_vernaux) { r_cons_printf (\",\"); }\n\t\t\t\t\tr_cons_printf (\"{\\\"idx\\\":%\"PFMT64x\",\\\"name\\\":\\\"%s\\\",\",\n\t\t\t\t\t\tsdb_num_get (sdb, \"idx\", 0), sdb_const_get (sdb, \"name\", 0));\n\t\t\t\t\tr_cons_printf (\"\\\"flags\\\":\\\"%s\\\",\\\"version\\\":%d}\",\n\t\t\t\t\t\tsdb_const_get (sdb, \"flags\", 0), (int)sdb_num_get (sdb, \"version\", 0));\n\t\t\t\t} else {\n\t\t\t\t\tr_cons_printf (\"  0x%08\"PFMT64x\":   Name: %s\",\n\t\t\t\t\t\tsdb_num_get (sdb, \"idx\", 0), sdb_const_get (sdb, \"name\", 0));\n\t\t\t\t\tr_cons_printf (\"  Flags: %s Version: %d\\n\",\n\t\t\t\t\t\tsdb_const_get (sdb, \"flags\", 0), (int)sdb_num_get (sdb, \"version\", 0));\n\t\t\t\t}\n\t\t\t\tfirstit_dowhile_vernaux = false;\n\t\t\t} while (sdb);\n\t\t\tif (IS_MODE_JSON (mode)) { r_cons_printf (\"]}\"); };\n\t\t\tfirstit_for_verneed = false;\n\t\t}\n\t\tif (IS_MODE_JSON (mode)) { r_cons_printf (\"]}\"); };\n\t\tfirstit_dowhile_verneed = false;\n\t} while (sdb);\n\tif (IS_MODE_JSON (mode)) { r_cons_printf (\"]}\"); }\n}\n\nstatic void bin_mach0_versioninfo(RCore *r) {\n\t/* TODO */\n}\n\nstatic void bin_pe_resources(RCore *r, int mode) {\n\tSdb *sdb = NULL;\n\tint index = 0;\n\tconst char *pe_path = \"bin/cur/info/pe_resource\";\n\tif (!(sdb = sdb_ns_path (r->sdb, pe_path, 0))) {\n\t\treturn;\n\t}\n\tif (IS_MODE_SET (mode)) {\n\t\tr_flag_space_set (r->flags, \"resources\");\n\t} else if (IS_MODE_RAD (mode)) {\n\t\tr_cons_printf (\"fs resources\\n\");\n\t} else if (IS_MODE_JSON (mode)) {\n\t\tr_cons_printf (\"[\");\n\t}\n\twhile (true) {\n\t\tconst char *timestrKey = sdb_fmt (\"resource.%d.timestr\", index);\n\t\tconst char *vaddrKey = sdb_fmt (\"resource.%d.vaddr\", index);\n\t\tconst char *sizeKey  = sdb_fmt (\"resource.%d.size\", index);\n\t\tconst char *typeKey  = sdb_fmt (\"resource.%d.type\", index);\n\t\tconst char *languageKey = sdb_fmt (\"resource.%d.language\", index);\n\t\tconst char *nameKey = sdb_fmt (\"resource.%d.name\", index);\n\t\tchar *timestr = sdb_get (sdb, timestrKey, 0);\n\t\tif (!timestr) {\n\t\t\tbreak;\n\t\t}\n\t\tut64 vaddr = sdb_num_get (sdb, vaddrKey, 0);\n\t\tint size = (int)sdb_num_get (sdb, sizeKey, 0);\n\t\tint name = (int)sdb_num_get (sdb, nameKey, 0);\n\t\tchar *type = sdb_get (sdb, typeKey, 0);\n\t\tchar *lang = sdb_get (sdb, languageKey, 0);\n\n\t\tif (IS_MODE_SET (mode)) {\n\t\t\tconst char *name = sdb_fmt (\"resource.%d\", index);\n\t\t\tr_flag_set (r->flags, name, vaddr, size);\n\t\t} else if (IS_MODE_RAD (mode)) {\n\t\t\tr_cons_printf (\"f resource.%d %d 0x%08\"PFMT32x\"\\n\", index, size, vaddr);\n\t\t} else if (IS_MODE_JSON (mode)) {\n\t\t\tr_cons_printf(\"%s{\\\"name\\\":%d,\\\"index\\\":%d, \\\"type\\\":\\\"%s\\\",\"\n\t\t\t\t\t\"\\\"vaddr\\\":%\"PFMT64d\", \\\"size\\\":%d, \\\"lang\\\":\\\"%s\\\"}\",\n\t\t\t\t\tindex? \",\": \"\", name, index, type, vaddr, size, lang);\n\t\t} else {\n\t\t\tchar *humanSize = r_num_units (NULL, size);\n\t\t\tr_cons_printf (\"Resource %d\\n\", index);\n\t\t\tr_cons_printf (\"  name: %d\\n\", name);\n\t\t\tr_cons_printf (\"  timestamp: %s\\n\", timestr);\n\t\t\tr_cons_printf (\"  vaddr: 0x%08\"PFMT64x\"\\n\", vaddr);\n\t\t\tif (humanSize) {\n\t\t\t\tr_cons_printf (\"  size: %s\\n\", humanSize);\n\t\t\t}\n\t\t\tr_cons_printf (\"  type: %s\\n\", type);\n\t\t\tr_cons_printf (\"  language: %s\\n\", lang);\n\t\t\tfree (humanSize);\n\t\t}\n\n\t\tR_FREE (timestr);\n\t\tR_FREE (type);\n\t\tR_FREE (lang)\n\n\t\tindex++;\n\t}\n\tif (IS_MODE_JSON (mode)) {\n\t\tr_cons_printf (\"]\");\n\t} else if (IS_MODE_RAD (mode)) {\n\t\tr_cons_printf (\"fs *\");\n\t}\n}\n\nstatic void bin_no_resources(RCore *r, int mode) {\n\tif (IS_MODE_JSON (mode)) {\n\t\tr_cons_printf (\"[]\");\n\t}\n}\n\nstatic int bin_resources(RCore *r, int mode) {\n\tconst RBinInfo *info = r_bin_get_info (r->bin);\n\tif (!info || !info->rclass) {\n\t\treturn false;\n\t}\n\tif (!strncmp (\"pe\", info->rclass, 2)) {\n\t\tbin_pe_resources (r, mode);\n\t} else {\n\t\tbin_no_resources (r, mode);\n\t}\n\treturn true;\n}\n\nstatic int bin_versioninfo(RCore *r, int mode) {\n\tconst RBinInfo *info = r_bin_get_info (r->bin);\n\tif (!info || !info->rclass) {\n\t\treturn false;\n\t}\n\tif (!strncmp (\"pe\", info->rclass, 2)) {\n\t\tbin_pe_versioninfo (r, mode);\n\t} else if (!strncmp (\"elf\", info->rclass, 3)) {\n\t\tbin_elf_versioninfo (r, mode);\n\t} else if (!strncmp (\"mach0\", info->rclass, 5)) {\n\t\tbin_mach0_versioninfo (r);\n\t} else {\n\t\tr_cons_println (\"Unknown format\");\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic int bin_signature(RCore *r, int mode) {\n\tRBinFile *cur = r_bin_cur (r->bin);\n\tRBinPlugin *plg = r_bin_file_cur_plugin (cur);\n\tif (plg && plg->signature) {\n\t\tconst char *signature = plg->signature (cur, IS_MODE_JSON (mode));\n\t\tr_cons_println (signature);\n\t\tfree ((char*) signature);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n\nR_API void r_core_bin_export_info_rad(RCore *core) {\n\tSdb *db = NULL;\n\tchar *flagname = NULL, *offset = NULL;\n\tRBinFile *bf = r_core_bin_cur (core);\n\tif (!bf) {\n\t\treturn;\n\t}\n\tdb = sdb_ns (bf->sdb, \"info\", 0);;\n\tif (!db) {\n\t\treturn;\n\t}\n\tif (db) {\n\t\tSdbListIter *iter;\n\t\tSdbKv *kv;\n\t\tr_cons_printf (\"fs format\\n\");\n\t\t// iterate over all keys\n\t\tSdbList *ls = sdb_foreach_list (db, false);\n\t\tls_foreach (ls, iter, kv) {\n\t\t\tchar *k = kv->key;\n\t\t\tchar *v = kv->value;\n\t\t\tchar *dup = strdup (k);\n\t\t\t//printf (\"?e (%s) (%s)\\n\", k, v);\n\t\t\tif ((flagname = strstr (dup, \".offset\"))) {\n\t\t\t\t*flagname = 0;\n\t\t\t\tflagname = dup;\n\t\t\t\tr_cons_printf (\"f %s @ %s\\n\", flagname, v);\n\t\t\t\tfree (offset);\n\t\t\t\toffset = strdup (v);\n\t\t\t}\n\t\t\tif ((flagname = strstr (dup, \".cparse\"))) {\n\t\t\t\tr_cons_printf (\"\\\"td %s\\\"\\n\", v);\n\t\t\t}\n\t\t\tfree (dup);\n\t\t}\n\t\tR_FREE (offset);\n\t\tls_foreach (ls, iter, kv) {\n\t\t\tchar *k = kv->key;\n\t\t\tchar *v = kv->value;\n\t\t\tchar *dup = strdup (k);\n\t\t\tif ((flagname = strstr (dup, \".format\"))) {\n\t\t\t\t*flagname = 0;\n\t\t\t\tif (!offset) {\n\t\t\t\t\toffset = strdup (\"0\");\n\t\t\t\t}\n\t\t\t\tflagname = dup;\n\t\t\t\tr_cons_printf (\"pf.%s %s\\n\", flagname, v);\n\t\t\t}\n\t\t\tfree (dup);\n\t\t}\n\t\tls_foreach (ls, iter, kv) {\n\t\t\tchar *k = kv->key;\n\t\t\tchar *v = kv->value;\n\t\t\tchar *dup = strdup (k);\n\t\t\tif ((flagname = strstr (dup, \".format\"))) {\n\t\t\t\t*flagname = 0;\n\t\t\t\tif (!offset) {\n\t\t\t\t\toffset = strdup (\"0\");\n\t\t\t\t}\n\t\t\t\tflagname = dup;\n\t\t\t\tint fmtsize = r_print_format_struct_size (v, core->print, 0, 0);\n\t\t\t\tchar *offset_key = r_str_newf (\"%s.offset\", flagname);\n\t\t\t\tconst char *off = sdb_const_get (db, offset_key, 0);\n\t\t\t\tfree (offset_key);\n\t\t\t\tif (off) {\n\t\t\t\t\tr_cons_printf (\"Cf %d %s @ %s\\n\", fmtsize, v, off);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ((flagname = strstr (dup, \".size\"))) {\n\t\t\t\t*flagname = 0;\n\t\t\t\tflagname = dup;\n\t\t\t\tr_cons_printf (\"fl %s %s\\n\", flagname, v);\n\t\t\t}\n\t\t}\n\t\tfree (offset);\n\t}\n}\n\nstatic int bin_header(RCore *r, int mode) {\n\tRBinFile *cur = r_bin_cur (r->bin);\n\tRBinPlugin *plg = r_bin_file_cur_plugin (cur);\n\tif (plg && plg->header) {\n\t\tplg->header (cur);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nR_API int r_core_bin_info(RCore *core, int action, int mode, int va, RCoreBinFilter *filter, const char *chksum) {\n\tint ret = true;\n\tconst char *name = NULL;\n\tut64 at = 0, loadaddr = r_bin_get_laddr (core->bin);\n\tif (filter && filter->offset) {\n\t\tat = filter->offset;\n\t}\n\tif (filter && filter->name) {\n\t\tname = filter->name;\n\t}\n\t\n\t// use our internal values for va\n\tva = va ? VA_TRUE : VA_FALSE;\n#if 0\n\tif (r_config_get_i (core->config, \"anal.strings\")) {\n\t\tr_core_cmd0 (core, \"aar\");\n\t}\n#endif\n\tif ((action & R_CORE_BIN_ACC_STRINGS)) ret &= bin_strings (core, mode, va);\n\tif ((action & R_CORE_BIN_ACC_RAW_STRINGS)) ret &= bin_raw_strings (core, mode, va);\n\tif ((action & R_CORE_BIN_ACC_INFO)) ret &= bin_info (core, mode);\n\tif ((action & R_CORE_BIN_ACC_MAIN)) ret &= bin_main (core, mode, va);\n\tif ((action & R_CORE_BIN_ACC_DWARF)) ret &= bin_dwarf (core, mode);\n\tif ((action & R_CORE_BIN_ACC_PDB)) ret &= bin_pdb (core, mode);\n\tif ((action & R_CORE_BIN_ACC_ENTRIES)) ret &= bin_entry (core, mode, loadaddr, va, false);\n\tif ((action & R_CORE_BIN_ACC_INITFINI)) ret &= bin_entry (core, mode, loadaddr, va, true);\n\tif ((action & R_CORE_BIN_ACC_SECTIONS)) ret &= bin_sections (core, mode, loadaddr, va, at, name, chksum);\n\tif (r_config_get_i (core->config, \"bin.relocs\")) {\n\t\tif ((action & R_CORE_BIN_ACC_RELOCS)) ret &= bin_relocs (core, mode, va);\n\t}\n \tif ((action & R_CORE_BIN_ACC_IMPORTS)) ret &= bin_imports (core, mode, va, name); // 6s\n\tif ((action & R_CORE_BIN_ACC_EXPORTS)) ret &= bin_exports (core, mode, loadaddr, va, at, name, chksum);\n\tif ((action & R_CORE_BIN_ACC_SYMBOLS)) ret &= bin_symbols (core, mode, loadaddr, va, at, name, chksum); // 6s\n\tif ((action & R_CORE_BIN_ACC_LIBS)) ret &= bin_libs (core, mode);\n\tif ((action & R_CORE_BIN_ACC_CLASSES)) ret &= bin_classes (core, mode); // 3s\n\tif ((action & R_CORE_BIN_ACC_SIZE)) ret &= bin_size (core, mode);\n\tif ((action & R_CORE_BIN_ACC_MEM)) ret &= bin_mem (core, mode);\n\tif ((action & R_CORE_BIN_ACC_VERSIONINFO)) ret &= bin_versioninfo (core, mode);\n\tif ((action & R_CORE_BIN_ACC_RESOURCES)) ret &= bin_resources (core, mode);\n\tif ((action & R_CORE_BIN_ACC_SIGNATURE)) ret &= bin_signature (core, mode);\n\tif ((action & R_CORE_BIN_ACC_FIELDS)) {\n\t\tif (IS_MODE_SIMPLE (mode)) {\n\t\t\tif ((action & R_CORE_BIN_ACC_HEADER) || action & R_CORE_BIN_ACC_FIELDS) {\n\t\t\t\t/* ignore mode, just for quiet/simple here */\n\t\t\t\tret &= bin_fields (core, 0, va);\n\t\t\t}\n\t\t} else {\n\t\t\tif (IS_MODE_NORMAL (mode)) {\n\t\t\t\tret &= bin_header (core, mode);\n\t\t\t} else {\n\t\t\t\tif ((action & R_CORE_BIN_ACC_HEADER) || action & R_CORE_BIN_ACC_FIELDS) {\n\t\t\t\t\tret &= bin_fields (core, mode, va);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\nR_API int r_core_bin_set_arch_bits(RCore *r, const char *name, const char * arch, ut16 bits) {\n\tint fd = r_io_fd_get_current (r->io);\n\tRIODesc *desc = r_io_desc_get (r->io, fd);\n\tRBinFile *curfile, *binfile = NULL;\n\tif (!name) {\n\t\tname = (desc) ? desc->name : NULL;\n\t}\n\tif (!name) {\n\t\treturn false;\n\t}\n\t/* Check if the arch name is a valid name */\n\tif (!r_asm_is_valid (r->assembler, arch)) {\n\t\treturn false;\n\t}\n\t/* Find a file with the requested name/arch/bits */\n\tbinfile = r_bin_file_find_by_arch_bits (r->bin, arch, bits, name);\n\tif (!binfile) {\n\t\treturn false;\n\t}\n\tif (!r_bin_use_arch (r->bin, arch, bits, name)) {\n\t\treturn false;\n\t}\n\tcurfile = r_bin_cur (r->bin);\n\t//set env if the binfile changed or we are dealing with xtr\n\tif (curfile != binfile || binfile->curxtr) {\n\t\tr_core_bin_set_cur (r, binfile);\n\t\treturn r_core_bin_set_env (r, binfile);\n\t}\n\treturn true;\n}\n\nR_API int r_core_bin_update_arch_bits(RCore *r) {\n\tRBinFile *binfile = NULL;\n\tconst char *name = NULL, *arch = NULL;\n\tut16 bits = 0;\n\tif (!r) {\n\t\treturn 0;\n\t}\n\tif (r->assembler) {\n\t\tbits = r->assembler->bits;\n\t   \tif (r->assembler->cur) {\n\t\t\tarch = r->assembler->cur->arch;\n\t\t}\n\t}\n\tbinfile = r_core_bin_cur (r);\n\tname = binfile ? binfile->file : NULL;\n\tif (binfile && binfile->curxtr) {\n\t\tr_anal_hint_clear (r->anal);\n\t}\n\treturn r_core_bin_set_arch_bits (r, name, arch, bits);\n}\n\nR_API int r_core_bin_raise(RCore *core, ut32 binfile_idx, ut32 binobj_idx) {\n\tRBin *bin = core->bin;\n\tRBinFile *binfile = NULL;\n\n\tif (binfile_idx == UT32_MAX && binobj_idx == UT32_MAX) {\n\t\treturn false;\n\t}\n\tif (!r_bin_select_by_ids (bin, binfile_idx, binobj_idx)) {\n\t\treturn false;\n\t}\n\tbinfile = r_core_bin_cur (core);\n\tif (binfile) {\n\t\tr_io_use_fd (core->io, binfile->fd);\n\t}\n\t// it should be 0 to use r_io_use_fd in r_core_block_read\n\tcore->switch_file_view = 0;\n\treturn binfile && r_core_bin_set_env (core, binfile) && r_core_block_read (core);\n}\n\nR_API bool r_core_bin_delete(RCore *core, ut32 binfile_idx, ut32 binobj_idx) {\n\tif (binfile_idx == UT32_MAX && binobj_idx == UT32_MAX) {\n\t\treturn false;\n\t}\n\tif (!r_bin_object_delete (core->bin, binfile_idx, binobj_idx)) {\n\t\treturn false;\n\t}\n\tRBinFile *binfile = r_core_bin_cur (core);\n\tif (binfile) {\n\t\tr_io_use_fd (core->io, binfile->fd);\n\t}\n\tcore->switch_file_view = 0;\n\treturn binfile && r_core_bin_set_env (core, binfile) && r_core_block_read (core);\n}\n\nstatic int r_core_bin_file_print(RCore *core, RBinFile *binfile, int mode) {\n\tRListIter *iter;\n\tRBinObject *obj;\n\tconst char *name = binfile ? binfile->file : NULL;\n\t(void)r_bin_get_info (core->bin); // XXX is this necssary for proper iniitialization\n\tut32 id = binfile ? binfile->id : 0;\n\tut32 fd = binfile ? binfile->fd : 0;\n\tut32 bin_sz = binfile ? binfile->size : 0;\n\t// TODO: handle mode to print in json and r2 commands\n\n\tif (!binfile) {\n\t\treturn false;\n\t}\n\tswitch (mode) {\n\tcase '*':\n\t\tr_list_foreach (binfile->objs, iter, obj) {\n\t\t\tr_cons_printf (\"oba 0x%08\"PFMT64x\" %s # %d\\n\", obj->boffset, name, obj->id);\n\t\t}\n\t\tbreak;\n\tcase 'q':\n\t\tr_list_foreach (binfile->objs, iter, obj) {\n\t\t\tr_cons_printf (\"%d\\n\", obj->id);\n\t\t}\n\t\tbreak;\n\tcase 'j':\n\t\tr_cons_printf (\"{\\\"name\\\":\\\"%s\\\",\\\"fd\\\":%d,\\\"id\\\":%d,\\\"size\\\":%d,\\\"objs\\\":[\",\n\t\t\tname, fd, id, bin_sz);\n\t\tr_list_foreach (binfile->objs, iter, obj) {\n\t\t\tRBinInfo *info = obj->info;\n\t\t\tut8 bits = info ? info->bits : 0;\n\t\t\tconst char *arch = info ? info->arch : \"unknown\";\n\t\t\tr_cons_printf (\"{\\\"objid\\\":%d,\\\"arch\\\":\\\"%s\\\",\\\"bits\\\":%d,\\\"binoffset\\\":%\"\n\t\t\t\t\tPFMT64d\",\\\"objsize\\\":%\"PFMT64d\"}\",\n\t\t\t\t\tobj->id, arch, bits, obj->boffset, obj->obj_size);\n\t\t\tif (iter->n) {\n\t\t\t\tr_cons_print (\",\");\n\t\t\t}\n\t\t}\n\t\tr_cons_print (\"]}\");\n\t\tbreak;\n\tdefault:\n\t\tr_list_foreach (binfile->objs, iter, obj) {\n\t\t\tRBinInfo *info = obj->info;\n\t\t\tut8 bits = info ? info->bits : 0;\n\t\t\tconst char *arch = info ? info->arch : \"unknown\";\n\t\t\tif (!arch) {\n\t\t\t\tarch = r_config_get (core->config, \"asm.arch\");\n\t\t\t}\n\t\t\tr_cons_printf (\"%4d  %s-%d at:0x%08\"PFMT64x\" sz:%\"PFMT64d\" \",\n\t\t\t\t\tobj->id, arch, bits, obj->boffset, obj->obj_size );\n\t\t\tr_cons_printf (\"fd:%d %s\\n\", fd, name);\n\t\t}\n\t\tbreak;\n\t}\n\treturn true;\n}\n\nR_API int r_core_bin_list(RCore *core, int mode) {\n\t// list all binfiles and there objects and there archs\n\tint count = 0;\n\tRListIter *iter;\n\tRBinFile *binfile = NULL; //, *cur_bf = r_core_bin_cur (core) ;\n\tRBin *bin = core->bin;\n\tconst RList *binfiles = bin ? bin->binfiles: NULL;\n\tif (!binfiles) {\n\t\treturn false;\n\t}\n\tif (mode == 'j') {\n\t\tr_cons_print (\"[\");\n\t}\n\tr_list_foreach (binfiles, iter, binfile) {\n\t\tr_core_bin_file_print (core, binfile, mode);\n\t\tif (iter->n && mode == 'j') {\n\t\t\tr_cons_print (\",\");\n\t\t}\n\t}\n\tif (mode == 'j') {\n\t\tr_cons_println (\"]\");\n\t}\n\t//r_core_file_set_by_file (core, cur_cf);\n\t//r_core_bin_bind (core, cur_bf);\n\treturn count;\n}\n\nR_API char *r_core_bin_method_flags_str(ut64 flags, int mode) {\n\tchar *str;\n\tRStrBuf *buf;\n\tint i, len = 0;\n\n\tbuf = r_strbuf_new (\"\");\n\tif (IS_MODE_SET (mode) || IS_MODE_RAD (mode)) {\n\t\tif (!flags) {\n\t\t\tgoto out;\n\t\t}\n\n\t\tfor (i = 0; i != 64; i++) {\n\t\t\tut64 flag = flags & (1UL << i);\n\t\t\tif (flag) {\n\t\t\t\tconst char *flag_string = r_bin_get_meth_flag_string (flag, false);\n\t\t\t\tif (flag_string) {\n\t\t\t\t\tr_strbuf_appendf (buf, \".%s\", flag_string);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else if (IS_MODE_JSON (mode)) {\n\t\tif (!flags) {\n\t\t\tr_strbuf_append (buf, \"[]\");\n\t\t\tgoto out;\n\t\t}\n\n\t\tr_strbuf_append (buf, \"[\");\n\n\t\tfor (i = 0; i != 64; i++) {\n\t\t\tut64 flag = flags & (1LL << i);\n\t\t\tif (flag) {\n\t\t\t\tconst char *flag_string = r_bin_get_meth_flag_string (flag, false);\n\t\t\t\tif (len != 0) {\n\t\t\t\t\tr_strbuf_append (buf, \",\");\n\t\t\t\t}\n\t\t\t\tif (flag_string) {\n\t\t\t\t\tr_strbuf_appendf (buf, \"\\\"%s\\\"\", flag_string);\n\t\t\t\t} else {\n\t\t\t\t\tr_strbuf_appendf (buf, \"\\\"0x%08\"PFMT64x\"\\\"\", flag);\n\t\t\t\t}\n\t\t\t\tlen++;\n\t\t\t}\n\t\t}\n\n\t\tr_strbuf_append (buf, \"]\");\n\t} else {\n\t\tint pad_len = 4; //TODO: move to a config variable\n\n\t\tif (!flags) {\n\t\t\tgoto padding;\n\t\t}\n\t\tfor (i = 0; i != 64; i++) {\n\t\t\tut64 flag = flags & (1L << i);\n\t\t\tif (flag) {\n\t\t\t\tconst char *flag_string = r_bin_get_meth_flag_string (flag, true);\n\n\t\t\t\tif (flag_string) {\n\t\t\t\t\tr_strbuf_append (buf, flag_string);\n\t\t\t\t} else {\n\t\t\t\t\tr_strbuf_append (buf, \"?\");\n\t\t\t\t}\n\n\t\t\t\tlen++;\n\t\t\t}\n\t\t}\npadding:\n\t\tfor ( ; len < pad_len; len++) {\n\t\t\tr_strbuf_append (buf, \" \");\n\t\t}\n\t}\n\nout:\n\tstr = strdup (r_strbuf_get (buf));\n\tr_strbuf_free (buf);\n\n\treturn str;\n}\n"], "fixing_code": ["/* radare - LGPL - Copyright 2009-2018 - nibble, pancake */\n\n#include <assert.h>\n#include <stdio.h>\n#include <r_types.h>\n#include <r_util.h>\n#include <r_lib.h>\n#include <r_bin.h>\n#include <r_io.h>\n#include <r_cons.h>\n#include \"elf/elf.h\"\n\nstatic RBinInfo* info(RBinFile *bf);\n\n//TODO: implement r_bin_symbol_dup() and r_bin_symbol_free ?\n\nstatic int get_file_type(RBinFile *bf) {\n\tstruct Elf_(r_bin_elf_obj_t) *obj = bf->o->bin_obj;\n\tchar *type = Elf_(r_bin_elf_get_file_type (obj));\n\treturn type? ((!strncmp (type, \"CORE\", 4)) ? R_BIN_TYPE_CORE : R_BIN_TYPE_DEFAULT) : -1;\n}\n\nstatic RList *maps(RBinFile *bf) {\n\tif (bf && bf->o) {\n\t\treturn Elf_(r_bin_elf_get_maps)(bf->o->bin_obj);\n\t}\n\treturn NULL;\n}\n\nstatic char* regstate(RBinFile *bf) {\n\tstruct Elf_(r_bin_elf_obj_t) *obj = bf->o->bin_obj;\n\tif (obj->ehdr.e_machine != EM_AARCH64 &&\n\t\tobj->ehdr.e_machine != EM_ARM &&\n\t\tobj->ehdr.e_machine != EM_386 &&\n\t\tobj->ehdr.e_machine != EM_X86_64) {\n\t\teprintf (\"Cannot retrieve regstate on: %s (not yet supported)\\n\",\n\t\t\t\t\tElf_(r_bin_elf_get_machine_name)(obj));\n\t\treturn NULL;\n\t}\n\n\tint len = 0;\n\tut8 *regs = Elf_(r_bin_elf_grab_regstate) (obj, &len);\n\tchar *hexregs = (regs && len > 0) ? r_hex_bin2strdup (regs, len) : NULL;\n\n\tfree (regs);\n\treturn hexregs;\n}\n\nstatic void setsymord(ELFOBJ* eobj, ut32 ord, RBinSymbol *ptr) {\n\tif (!eobj->symbols_by_ord || ord >= eobj->symbols_by_ord_size) {\n\t\treturn;\n\t}\n\tfree (eobj->symbols_by_ord[ord]);\n\teobj->symbols_by_ord[ord] = r_mem_dup (ptr, sizeof (RBinSymbol));\n}\n\nstatic inline bool setimpord(ELFOBJ* eobj, ut32 ord, RBinImport *ptr) {\n\tif (!eobj->imports_by_ord || ord >= eobj->imports_by_ord_size) {\n\t\treturn false;\n\t}\n\tif (eobj->imports_by_ord[ord]) {\n\t\tfree (eobj->imports_by_ord[ord]->name);\n\t\tfree (eobj->imports_by_ord[ord]);\n\t}\n\teobj->imports_by_ord[ord] = r_mem_dup (ptr, sizeof (RBinImport));\n\teobj->imports_by_ord[ord]->name = strdup (ptr->name);\n\treturn true;\n}\n\nstatic Sdb* get_sdb(RBinFile *bf) {\n\tRBinObject *o = bf->o;\n\tif (o && o->bin_obj) {\n\t\tstruct Elf_(r_bin_elf_obj_t) *bin = (struct Elf_(r_bin_elf_obj_t) *) o->bin_obj;\n\t\treturn bin->kv;\n\t}\n\treturn NULL;\n}\n\nstatic void * load_buffer(RBinFile *bf, RBuffer *buf, ut64 loadaddr, Sdb *sdb) {\n\tstruct Elf_(r_bin_elf_obj_t) *res;\n\tif (!buf) {\n\t\treturn NULL;\n\t}\n\tres = Elf_(r_bin_elf_new_buf) (buf, bf->rbin->verbose);\n\tif (res) {\n\t\tsdb_ns_set (sdb, \"info\", res->kv);\n\t}\n\treturn res;\n}\n\nstatic void * load_bytes(RBinFile *bf, const ut8 *buf, ut64 sz, ut64 loadaddr, Sdb *sdb) {\n\tstruct Elf_(r_bin_elf_obj_t) *res;\n\tif (!buf || !sz || sz == UT64_MAX) {\n\t\treturn NULL;\n\t}\n\tRBuffer *tbuf = r_buf_new ();\n\t// NOOOEES must use io!\n\tr_buf_set_bytes (tbuf, buf, sz);\n\tres = Elf_(r_bin_elf_new_buf) (tbuf, bf->rbin->verbose);\n\tif (res) {\n\t\tsdb_ns_set (sdb, \"info\", res->kv);\n\t}\n\tr_buf_free (tbuf);\n\treturn res;\n}\n\nstatic bool load(RBinFile *bf) {\n\tconst ut8 *bytes = bf ? r_buf_buffer (bf->buf) : NULL;\n\tut64 sz = bf ? r_buf_size (bf->buf): 0;\n\tif (!bf || !bf->o) {\n\t\treturn false;\n\t}\n\tbf->o->bin_obj = load_bytes (bf, bytes, sz, bf->o->loadaddr, bf->sdb);\n\treturn bf->o->bin_obj != NULL;\n}\n\nstatic int destroy(RBinFile *bf) {\n\tint i;\n\tELFOBJ* eobj = bf->o->bin_obj;\n\tif (eobj && eobj->imports_by_ord) {\n\t\tfor (i = 0; i < eobj->imports_by_ord_size; i++) {\n\t\t\tRBinImport *imp = eobj->imports_by_ord[i];\n\t\t\tif (imp) {\n\t\t\t\tfree (imp->name);\n\t\t\t\tfree (imp);\n\t\t\t\teobj->imports_by_ord[i] = NULL;\n\t\t\t}\n\t\t}\n\t\tR_FREE (eobj->imports_by_ord);\n\t}\n\tElf_(r_bin_elf_free) ((struct Elf_(r_bin_elf_obj_t)*)bf->o->bin_obj);\n\treturn true;\n}\n\nstatic ut64 baddr(RBinFile *bf) {\n\treturn Elf_(r_bin_elf_get_baddr) (bf->o->bin_obj);\n}\n\nstatic ut64 boffset(RBinFile *bf) {\n\treturn Elf_(r_bin_elf_get_boffset) (bf->o->bin_obj);\n}\n\nstatic RBinAddr* binsym(RBinFile *bf, int sym) {\n\tstruct Elf_(r_bin_elf_obj_t)* obj = bf->o->bin_obj;\n\tRBinAddr *ret = NULL;\n\tut64 addr = 0LL;\n\n\tswitch (sym) {\n\tcase R_BIN_SYM_ENTRY:\n\t\taddr = Elf_(r_bin_elf_get_entry_offset) (bf->o->bin_obj);\n\t\tbreak;\n\tcase R_BIN_SYM_MAIN:\n\t\taddr = Elf_(r_bin_elf_get_main_offset) (bf->o->bin_obj);\n\t\tbreak;\n\tcase R_BIN_SYM_INIT:\n\t\taddr = Elf_(r_bin_elf_get_init_offset) (bf->o->bin_obj);\n\t\tbreak;\n\tcase R_BIN_SYM_FINI:\n\t\taddr = Elf_(r_bin_elf_get_fini_offset) (bf->o->bin_obj);\n\t\tbreak;\n\t}\n\tif (addr && addr != UT64_MAX && (ret = R_NEW0 (RBinAddr))) {\n\t\tstruct Elf_(r_bin_elf_obj_t) *bin = bf->o->bin_obj;\n\t\tbool is_arm = bin->ehdr.e_machine == EM_ARM;\n\t\tret->paddr = addr;\n\t\tret->vaddr = Elf_(r_bin_elf_p2v) (obj, addr);\n\t\tif (is_arm && addr & 1) {\n\t\t\tret->bits = 16;\n\t\t\tret->vaddr--; \n\t\t\tret->paddr--; \n\t\t}\n\t}\n\treturn ret;\n}\n\nstatic RList* sections(RBinFile *bf) {\n\tstruct Elf_(r_bin_elf_obj_t)* obj = (bf && bf->o)? bf->o->bin_obj : NULL;\n\tstruct r_bin_elf_section_t *section = NULL;\n\tint i, num, found_load = 0;\n\tElf_(Phdr)* phdr = NULL;\n\tRBinSection *ptr = NULL;\n\tRList *ret = NULL;\n\n\tif (!obj || !(ret = r_list_newf (free))) {\n\t\treturn NULL;\n\t}\n\t//there is not leak in section since they are cached by elf.c\n\t//and freed within Elf_(r_bin_elf_free)\n\tif ((section = Elf_(r_bin_elf_get_sections) (obj))) {\n\t\tfor (i = 0; !section[i].last; i++) {\n\t\t\tif (!(ptr = R_NEW0 (RBinSection))) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstrncpy (ptr->name, (char*)section[i].name, R_BIN_SIZEOF_STRINGS);\n\t\t\tif (strstr (ptr->name, \"data\") && !strstr (ptr->name, \"rel\")) {\n\t\t\t\tptr->is_data = true;\n\t\t\t}\n\t\t\tptr->size = section[i].type != SHT_NOBITS ? section[i].size : 0;\n\t\t\tptr->vsize = section[i].size;\n\t\t\tptr->paddr = section[i].offset;\n\t\t\tptr->vaddr = section[i].rva;\n\t\t\tptr->add = !obj->phdr; // Load sections if there is no PHDR\n\t\t\tptr->srwx = 0;\n\t\t\tif (R_BIN_ELF_SCN_IS_EXECUTABLE (section[i].flags)) {\n\t\t\t\tptr->srwx |= R_BIN_SCN_EXECUTABLE;\n\t\t\t}\n\t\t\tif (R_BIN_ELF_SCN_IS_WRITABLE (section[i].flags)) {\n\t\t\t\tptr->srwx |= R_BIN_SCN_WRITABLE;\n\t\t\t}\n\t\t\tif (R_BIN_ELF_SCN_IS_READABLE (section[i].flags)) {\n\t\t\t\tptr->srwx |= R_BIN_SCN_READABLE;\n\t\t\t}\n\t\t\tr_list_append (ret, ptr);\n\t\t}\n\t}\n\n\t// program headers is another section\n\tnum = obj->ehdr.e_phnum;\n\tphdr = obj->phdr;\n\tif (phdr) {\n\t\tint n = 0;\n\t\tfor (i = 0; i < num; i++) {\n\t\t\tif (!(ptr = R_NEW0 (RBinSection))) {\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tptr->add = false;\n\t\t\tptr->size = phdr[i].p_filesz;\n\t\t\tptr->vsize = phdr[i].p_memsz;\n\t\t\tptr->paddr = phdr[i].p_offset;\n\t\t\tptr->vaddr = phdr[i].p_vaddr;\n\t\t\tptr->srwx = phdr[i].p_flags;\n\t\t\tswitch (phdr[i].p_type) {\n\t\t\tcase PT_DYNAMIC:\n\t\t\t\tstrncpy (ptr->name, \"DYNAMIC\", R_BIN_SIZEOF_STRINGS);\n\t\t\t\tbreak;\n\t\t\tcase PT_LOAD:\n\t\t\t\tsnprintf (ptr->name, R_BIN_SIZEOF_STRINGS, \"LOAD%d\", n++);\n\t\t\t\tfound_load = 1;\n\t\t\t\tptr->add = true;\n\t\t\t\tbreak;\n\t\t\tcase PT_INTERP:\n\t\t\t\tstrncpy (ptr->name, \"INTERP\", R_BIN_SIZEOF_STRINGS);\n\t\t\t\tbreak;\n\t\t\tcase PT_GNU_STACK:\n\t\t\t\tstrncpy (ptr->name, \"GNU_STACK\", R_BIN_SIZEOF_STRINGS);\n\t\t\t\tbreak;\n\t\t\tcase PT_GNU_RELRO:\n\t\t\t\tstrncpy (ptr->name, \"GNU_RELRO\", R_BIN_SIZEOF_STRINGS);\n\t\t\t\tbreak;\n\t\t\tcase PT_GNU_EH_FRAME:\n\t\t\t\tstrncpy (ptr->name, \"GNU_EH_FRAME\", R_BIN_SIZEOF_STRINGS);\n\t\t\t\tbreak;\n\t\t\tcase PT_PHDR:\n\t\t\t\tstrncpy (ptr->name, \"PHDR\", R_BIN_SIZEOF_STRINGS);\n\t\t\t\tbreak;\n\t\t\tcase PT_TLS:\n\t\t\t\tstrncpy (ptr->name, \"TLS\", R_BIN_SIZEOF_STRINGS);\n\t\t\t\tbreak;\n\t\t\tcase PT_NOTE:\n\t\t\t\tstrncpy (ptr->name, \"NOTE\", R_BIN_SIZEOF_STRINGS);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tstrncpy (ptr->name, \"UNKNOWN\", R_BIN_SIZEOF_STRINGS);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tptr->name[R_BIN_SIZEOF_STRINGS - 1] = '\\0';\n\t\t\tr_list_append (ret, ptr);\n\t\t}\n\t}\n\n\tif (r_list_empty (ret)) {\n\t\tif (!bf->size) {\n\t\t\tstruct Elf_(r_bin_elf_obj_t) *bin = bf->o->bin_obj;\n\t\t\tbf->size = bin? bin->size: 0x9999;\n\t\t}\n\t\tif (found_load == 0) {\n\t\t\tif (!(ptr = R_NEW0 (RBinSection))) {\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tsprintf (ptr->name, \"uphdr\");\n\t\t\tptr->size = bf->size;\n\t\t\tptr->vsize = bf->size;\n\t\t\tptr->paddr = 0;\n\t\t\tptr->vaddr = 0x10000;\n\t\t\tptr->add = true;\n\t\t\tptr->srwx = R_BIN_SCN_READABLE | R_BIN_SCN_WRITABLE |\n\t\t\t\tR_BIN_SCN_EXECUTABLE;\n\t\t\tr_list_append (ret, ptr);\n\t\t}\n\t}\n\t// add entry for ehdr\n\tptr = R_NEW0 (RBinSection);\n\tif (ptr) {\n\t\tut64 ehdr_size = sizeof (obj->ehdr);\n\t\tif (bf->size < ehdr_size) {\n\t\t\tehdr_size = bf->size;\n\t\t}\n\t\tsprintf (ptr->name, \"ehdr\");\n\t\tptr->paddr = 0;\n\t\tptr->vaddr = obj->baddr;\n\t\tptr->size = ehdr_size;\n\t\tptr->vsize = ehdr_size;\n\t\tptr->add = false;\n\t\tif (obj->ehdr.e_type == ET_REL) {\n\t\t\tptr->add = true;\n\t\t}\n\t\tptr->srwx = R_BIN_SCN_READABLE | R_BIN_SCN_WRITABLE;\n\t\tr_list_append (ret, ptr);\n\t}\n\treturn ret;\n}\n\nstatic RBinAddr* newEntry(ut64 haddr, ut64 paddr, int type, int bits) {\n\tRBinAddr *ptr = R_NEW0 (RBinAddr);\n\tif (ptr) {\n\t\tptr->paddr = paddr;\n\t\tptr->vaddr = paddr;\n\t\tptr->haddr = haddr;\n\t\tptr->bits = bits;\n\t\tptr->type = type;\n\t\t//realign due to thumb\n\t\tif (bits == 16 && ptr->vaddr & 1) {\n\t\t\tptr->paddr--;\n\t\t\tptr->vaddr--;\n\t\t}\n\t}\n\treturn ptr;\n}\n\nstatic void process_constructors (RBinFile *bf, RList *ret, int bits) {\n\tRList *secs = sections (bf);\n\tRListIter *iter;\n\tRBinSection *sec;\n\tint i, type;\n\tr_list_foreach (secs, iter, sec) {\n\t\ttype = -1;\n\t\tif (!strcmp (sec->name, \".fini_array\")) {\n\t\t\ttype = R_BIN_ENTRY_TYPE_FINI;\n\t\t} else if (!strcmp (sec->name, \".init_array\")) {\n\t\t\ttype = R_BIN_ENTRY_TYPE_INIT;\n\t\t} else if (!strcmp (sec->name, \".preinit_array\")) {\n\t\t\ttype = R_BIN_ENTRY_TYPE_PREINIT;\n\t\t}\n\t\tif (type != -1) {\n\t\t\tut8 *buf = calloc (sec->size, 1);\n\t\t\tif (!buf) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t(void)r_buf_read_at (bf->buf, sec->paddr, buf, sec->size);\n\t\t\tif (bits == 32) {\n\t\t\t\tfor (i = 0; (i + 3) < sec->size; i += 4) {\n\t\t\t\t\tut32 addr32 = r_read_le32 (buf + i);\n\t\t\t\t\tif (addr32) {\n\t\t\t\t\t\tRBinAddr *ba = newEntry (sec->paddr + i, (ut64)addr32, type, bits);\n\t\t\t\t\t\tr_list_append (ret, ba);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (i = 0; (i + 7) < sec->size; i += 8) {\n\t\t\t\t\tut64 addr64 = r_read_le64 (buf + i);\n\t\t\t\t\tif (addr64) {\n\t\t\t\t\t\tRBinAddr *ba = newEntry (sec->paddr + i, addr64, type, bits);\n\t\t\t\t\t\tr_list_append (ret, ba);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfree (buf);\n\t\t}\n\t}\n\tr_list_free (secs);\n}\n\nstatic RList* entries(RBinFile *bf) {\n\tstruct Elf_(r_bin_elf_obj_t)* obj;\n\tRBinAddr *ptr = NULL;\n\tstruct r_bin_elf_symbol_t *symbol;\n\tRList *ret;\n\tint i;\n\n\tif (!bf || !bf->o || !bf->o->bin_obj) {\n\t\treturn NULL;\n\t}\n\tobj = bf->o->bin_obj;\n\tif (!(ret = r_list_newf ((RListFree)free))) {\n\t\treturn NULL;\n\t}\n\tif (!(ptr = R_NEW0 (RBinAddr))) {\n\t\treturn ret;\n\t}\n\tptr->paddr = Elf_(r_bin_elf_get_entry_offset) (obj);\n\tptr->vaddr = Elf_(r_bin_elf_p2v) (obj, ptr->paddr);\n\tptr->haddr = 0x18;\n\n\tif (obj->ehdr.e_machine == EM_ARM) {\n\t\tint bin_bits = Elf_(r_bin_elf_get_bits) (obj);\n\t\tif (bin_bits != 64) {\n\t\t\tptr->bits = 32;\n\t\t\tif (ptr->vaddr & 1) {\n\t\t\t\tptr->vaddr--;\n\t\t\t\tptr->bits = 16;\n\t\t\t}\n\t\t\tif (ptr->paddr & 1) {\n\t\t\t\tptr->paddr--;\n\t\t\t\tptr->bits = 16;\n\t\t\t}\n\t\t}\n\t}\n\tr_list_append (ret, ptr);\n\n\t// add entrypoint for jni libraries\n\t// NOTE: this is slow, we shouldnt find for java constructors here\n\tif (!(symbol = Elf_(r_bin_elf_get_symbols) (obj))) {\n\t\treturn ret;\n\t}\n\tfor (i = 0; !symbol[i].last; i++) {\n\t\tif (!strncmp (symbol[i].name, \"Java\", 4)) {\n\t\t\tif (r_str_endswith (symbol[i].name, \"_init\")) {\n\t\t\t\tif (!(ptr = R_NEW0 (RBinAddr))) {\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t\tptr->paddr = symbol[i].offset;\n\t\t\t\tptr->vaddr = Elf_(r_bin_elf_p2v) (obj, ptr->paddr);\n\t\t\t\tptr->haddr = UT64_MAX;\n\t\t\t\tptr->type = R_BIN_ENTRY_TYPE_INIT;\n\t\t\t\tr_list_append (ret, ptr);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tint bin_bits = Elf_(r_bin_elf_get_bits) (bf->o->bin_obj);\n\tprocess_constructors (bf, ret, bin_bits < 32 ? 32: bin_bits);\n\treturn ret;\n}\n\nstatic void _set_arm_thumb_bits(struct Elf_(r_bin_elf_obj_t) *bin, RBinSymbol **sym) {\n\tint bin_bits = Elf_(r_bin_elf_get_bits) (bin);\n\tRBinSymbol *ptr = *sym;\n\tint len = strlen (ptr->name);\n\tif (ptr->name[0] == '$' && (len >= 2 && !ptr->name[2])) {\n\t\tswitch (ptr->name[1]) {\n\t\tcase 'a' : //arm\n\t\t\tptr->bits = 32;\n\t\t\tbreak;\n\t\tcase 't': //thumb\n\t\t\tptr->bits = 16;\n\t\t\tif (ptr->vaddr & 1) {\n\t\t\t\tptr->vaddr--;\n\t\t\t}\n\t\t\tif (ptr->paddr & 1) {\n\t\t\t\tptr->paddr--;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'd': //data\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto arm_symbol;\n\t\t}\n\t} else {\narm_symbol:\n\t\tptr->bits = bin_bits;\n\t\tif (bin_bits != 64) {\n\t\t\tptr->bits = 32;\n\t\t\tif (ptr->vaddr & 1) {\n\t\t\t\tptr->vaddr--;\n\t\t\t\tptr->bits = 16;\n\t\t\t}\n\t\t\tif (ptr->paddr & 1) {\n\t\t\t\tptr->paddr--;\n\t\t\t\tptr->bits = 16;\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic RList* symbols(RBinFile *bf) {\n\tstruct Elf_(r_bin_elf_obj_t) *bin;\n\tstruct r_bin_elf_symbol_t *symbol = NULL;\n\tRBinSymbol *ptr = NULL;\n\tRList *ret = NULL;\n\tint i;\n\n\tif (!bf|| !bf->o || !bf->o->bin_obj) {\n\t\treturn NULL;\n\t}\n\n\tbin = bf->o->bin_obj;\n\tret = r_list_newf (free);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tif (!(symbol = Elf_(r_bin_elf_get_symbols) (bin))) {\n\t\treturn ret;\n\t}\n\tfor (i = 0; !symbol[i].last; i++) {\n\t\tut64 paddr = symbol[i].offset;\n\t\tut64 vaddr = Elf_(r_bin_elf_p2v) (bin, paddr);\n\t\tif (!(ptr = R_NEW0 (RBinSymbol))) {\n\t\t\tbreak;\n\t\t}\n\t\tptr->name = strdup (symbol[i].name);\n\t\tptr->forwarder = r_str_const (\"NONE\");\n\t\tptr->bind = r_str_const (symbol[i].bind);\n\t\tptr->type = r_str_const (symbol[i].type);\n\t\tptr->paddr = paddr;\n\t\tptr->vaddr = vaddr;\n\t\tptr->size = symbol[i].size;\n\t\tptr->ordinal = symbol[i].ordinal;\n\t\tsetsymord (bin, ptr->ordinal, ptr);\n\t\tif (bin->ehdr.e_machine == EM_ARM && *ptr->name) {\n\t\t\t_set_arm_thumb_bits (bin, &ptr);\n\t\t}\n\t\tr_list_append (ret, ptr);\n\t}\n\tif (!(symbol = Elf_(r_bin_elf_get_imports) (bin))) {\n\t\treturn ret;\n\t}\n\tfor (i = 0; !symbol[i].last; i++) {\n\t\tut64 paddr = symbol[i].offset;\n\t\tut64 vaddr = Elf_(r_bin_elf_p2v) (bin, paddr);\n\t\tif (!symbol[i].size) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (!(ptr = R_NEW0 (RBinSymbol))) {\n\t\t\tbreak;\n\t\t}\n\t\t// TODO(eddyb) make a better distinction between imports and other symbols.\n\t\t//snprintf (ptr->name, R_BIN_SIZEOF_STRINGS-1, \"imp.%s\", symbol[i].name);\n\t\tptr->name = r_str_newf (\"imp.%s\", symbol[i].name);\n\t\tptr->forwarder = r_str_const (\"NONE\");\n\t\t//strncpy (ptr->forwarder, \"NONE\", R_BIN_SIZEOF_STRINGS);\n\t\tptr->bind = r_str_const (symbol[i].bind);\n\t\tptr->type = r_str_const (symbol[i].type);\n\t\tptr->paddr = paddr;\n\t\tptr->vaddr = vaddr;\n\t\t//special case where there is not entry in the plt for the import\n\t\tif (ptr->vaddr == UT32_MAX) {\n\t\t\tptr->paddr = 0;\n\t\t\tptr->vaddr = 0;\n\t\t}\n\t\tptr->size = symbol[i].size;\n\t\tptr->ordinal = symbol[i].ordinal;\n\t\tsetsymord (bin, ptr->ordinal, ptr);\n\t\t/* detect thumb */\n\t\tif (bin->ehdr.e_machine == EM_ARM) {\n\t\t\t_set_arm_thumb_bits (bin, &ptr);\n\t\t}\n\t\tr_list_append (ret, ptr);\n\t}\n\treturn ret;\n}\n\nstatic RList* imports(RBinFile *bf) {\n\tstruct Elf_(r_bin_elf_obj_t) *bin = NULL;\n\tRBinElfSymbol *import = NULL;\n\tRBinImport *ptr = NULL;\n\tRList *ret = NULL;\n\tint i;\n\n\tif (!bf || !bf->o || !bf->o->bin_obj) {\n\t\treturn NULL;\n\t}\n\tbin = bf->o->bin_obj;\n\tif (!(ret = r_list_newf (r_bin_import_free))) {\n\t\treturn NULL;\n\t}\n\tif (!(import = Elf_(r_bin_elf_get_imports) (bin))) {\n\t\tr_list_free (ret);\n\t\treturn NULL;\n\t}\n\tfor (i = 0; !import[i].last; i++) {\n\t\tif (!(ptr = R_NEW0 (RBinImport))) {\n\t\t\tbreak;\n\t\t}\n\t\tptr->name = strdup (import[i].name);\n\t\tptr->bind = r_str_const (import[i].bind);\n\t\tptr->type = r_str_const (import[i].type);\n\t\tptr->ordinal = import[i].ordinal;\n\t\t(void)setimpord (bin, ptr->ordinal, ptr);\n\t\tr_list_append (ret, ptr);\n\t}\n\treturn ret;\n}\n\nstatic RList* libs(RBinFile *bf) {\n\tstruct r_bin_elf_lib_t *libs = NULL;\n\tRList *ret = NULL;\n\tchar *ptr = NULL;\n\tint i;\n\n\tif (!bf || !bf->o || !bf->o->bin_obj) {\n\t\treturn NULL;\n\t}\n\tif (!(ret = r_list_newf (free))) {\n\t\treturn NULL;\n\t}\n\tif (!(libs = Elf_(r_bin_elf_get_libs) (bf->o->bin_obj))) {\n\t\treturn ret;\n\t}\n\tfor (i = 0; !libs[i].last; i++) {\n\t\tptr = strdup (libs[i].name);\n\t\tr_list_append (ret, ptr);\n\t}\n\tfree (libs);\n\treturn ret;\n}\n\nstatic RBinReloc *reloc_convert(struct Elf_(r_bin_elf_obj_t) *bin, RBinElfReloc *rel, ut64 GOT) {\n\tRBinReloc *r = NULL;\n\tut64 B, P;\n\n\tif (!bin || !rel) {\n\t\treturn NULL;\n\t}\n\tB = bin->baddr;\n\tP = rel->rva; // rva has taken baddr into account\n\tif (!(r = R_NEW0 (RBinReloc))) {\n\t\treturn r;\n\t}\n\tr->import = NULL;\n\tr->symbol = NULL;\n\tr->is_ifunc = false;\n\tr->addend = rel->addend;\n\tif (rel->sym) {\n\t\tif (rel->sym < bin->imports_by_ord_size && bin->imports_by_ord[rel->sym]) {\n\t\t\tr->import = bin->imports_by_ord[rel->sym];\n\t\t} else if (rel->sym < bin->symbols_by_ord_size && bin->symbols_by_ord[rel->sym]) {\n\t\t\tr->symbol = bin->symbols_by_ord[rel->sym];\n\t\t}\n\t}\n\tr->vaddr = rel->rva;\n\tr->paddr = rel->offset;\n\n\t#define SET(T) r->type = R_BIN_RELOC_ ## T; r->additive = 0; return r\n\t#define ADD(T, A) r->type = R_BIN_RELOC_ ## T; r->addend += A; r->additive = !rel->is_rela; return r\n\n\tswitch (bin->ehdr.e_machine) {\n\tcase EM_386: switch (rel->type) {\n\t\tcase R_386_NONE:     break; // malloc then free. meh. then again, there's no real world use for _NONE.\n\t\tcase R_386_32:       ADD(32, 0);\n\t\tcase R_386_PC32:     ADD(32,-P);\n\t\tcase R_386_GLOB_DAT: SET(32);\n\t\tcase R_386_JMP_SLOT: SET(32);\n\t\tcase R_386_RELATIVE: ADD(32, B);\n\t\tcase R_386_GOTOFF:   ADD(32,-GOT);\n\t\tcase R_386_GOTPC:    ADD(32, GOT-P);\n\t\tcase R_386_16:       ADD(16, 0);\n\t\tcase R_386_PC16:     ADD(16,-P);\n\t\tcase R_386_8:        ADD(8,  0);\n\t\tcase R_386_PC8:      ADD(8, -P);\n\t\tcase R_386_COPY:     ADD(64, 0); // XXX: copy symbol at runtime\n\t\tcase R_386_IRELATIVE: r->is_ifunc = true; SET(32);\n\t\tdefault: break; //eprintf(\"TODO(eddyb): uninmplemented ELF/x86 reloc type %i\\n\", rel->type);\n\t\t}\n\t\tbreak;\n\tcase EM_X86_64: switch (rel->type) {\n\t\tcase R_X86_64_NONE:\tbreak; // malloc then free. meh. then again, there's no real world use for _NONE.\n\t\tcase R_X86_64_64:\tADD(64, 0);\n\t\tcase R_X86_64_PLT32:\tADD(32,-P /* +L */);\n\t\tcase R_X86_64_GOT32:\tADD(32, GOT);\n\t\tcase R_X86_64_PC32:\tADD(32,-P);\n\t\tcase R_X86_64_GLOB_DAT: r->vaddr -= rel->sto; SET(64);\n\t\tcase R_X86_64_JUMP_SLOT: r->vaddr -= rel->sto; SET(64);\n\t\tcase R_X86_64_RELATIVE:\tADD(64, B);\n\t\tcase R_X86_64_32:\tADD(32, 0);\n\t\tcase R_X86_64_32S:\tADD(32, 0);\n\t\tcase R_X86_64_16:\tADD(16, 0);\n\t\tcase R_X86_64_PC16:\tADD(16,-P);\n\t\tcase R_X86_64_8:\tADD(8,  0);\n\t\tcase R_X86_64_PC8:\tADD(8, -P);\n\t\tcase R_X86_64_GOTPCREL:\tADD(64, GOT-P);\n\t\tcase R_X86_64_COPY:\tADD(64, 0); // XXX: copy symbol at runtime\n\t\tcase R_X86_64_IRELATIVE: r->is_ifunc = true; SET(64);\n\t\tdefault: break; ////eprintf(\"TODO(eddyb): uninmplemented ELF/x64 reloc type %i\\n\", rel->type);\n\t\t}\n\t\tbreak;\n\tcase EM_ARM: switch (rel->type) {\n\t\tcase R_ARM_NONE:\tbreak; // malloc then free. meh. then again, there's no real world use for _NONE.\n\t\tcase R_ARM_ABS32:\tADD(32, 0);\n\t\tcase R_ARM_REL32:\tADD(32,-P);\n\t\tcase R_ARM_ABS16:\tADD(16, 0);\n\t\tcase R_ARM_ABS8:\tADD(8,  0);\n\t\tcase R_ARM_SBREL32:\tADD(32, -B);\n\t\tcase R_ARM_GLOB_DAT:\tADD(32, 0);\n\t\tcase R_ARM_JUMP_SLOT:\tADD(32, 0);\n\t\tcase R_ARM_RELATIVE:\tADD(32, B);\n\t\tcase R_ARM_GOTOFF:\tADD(32,-GOT);\n\t\tdefault: ADD(32,GOT); break; // reg relocations\n\t\t ////eprintf(\"TODO(eddyb): uninmplemented ELF/ARM reloc type %i\\n\", rel->type);\n\t\t}\n\t\tbreak;\n\tdefault: break;\n\t}\n\n\t#undef SET\n\t#undef ADD\n\n\tfree(r);\n\treturn 0;\n}\n\nstatic RList* relocs(RBinFile *bf) {\n\tRList *ret = NULL;\n\tRBinReloc *ptr = NULL;\n\tRBinElfReloc *relocs = NULL;\n\tstruct Elf_(r_bin_elf_obj_t) *bin = NULL;\n\tut64 got_addr;\n\tint i;\n\tif (!bf || !bf->o || !bf->o->bin_obj) {\n\t\treturn NULL;\n\t}\n\tbin = bf->o->bin_obj;\n\tif (!(ret = r_list_newf (free))) {\n\t\treturn NULL;\n\t}\n\t/* FIXME: This is a _temporary_ fix/workaround to prevent a use-after-\n\t * free detected by ASan that would corrupt the relocation names */\n\tr_list_free (imports (bf));\n\tif ((got_addr = Elf_(r_bin_elf_get_section_addr) (bin, \".got\")) == -1) {\n\t\tgot_addr = Elf_(r_bin_elf_get_section_addr) (bin, \".got.plt\");\n\t\tif (got_addr == -1) {\n\t\t\tgot_addr = 0;\n\t\t}\n\t}\n\tif (got_addr < 1 && bin->ehdr.e_type == ET_REL) {\n\t\tgot_addr = Elf_(r_bin_elf_get_section_addr) (bin, \".got.r2\");\n\t\tif (got_addr == -1) {\n\t\t\tgot_addr = 0;\n\t\t}\n\t}\n\tif (bf->o) {\n\t\tif (!(relocs = Elf_(r_bin_elf_get_relocs) (bin))) {\n\t\t\treturn ret;\n\t\t}\n\t\tfor (i = 0; !relocs[i].last; i++) {\n\t\t\tif (!(ptr = reloc_convert (bin, &relocs[i], got_addr))) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tr_list_append (ret, ptr);\n\t\t}\n\t\tfree (relocs);\n\t}\n\treturn ret;\n}\n\nstatic void _patch_reloc (ut16 e_machine, RIOBind *iob, RBinElfReloc *rel, ut64 S, ut64 B, ut64 L) {\n\tut64 val;\n\tut64 A = rel->addend, P = rel->rva;\n\tut8 buf[8];\n\tswitch (e_machine) {\n\tcase EM_PPC64: {\n\t\tint low = 0, word = 0;\n\t\tswitch (rel->type) {\n\t\tcase R_PPC64_REL16_HA:\n\t\t\tword = 2;\n\t\t\tval = (S + A - P + 0x8000) >> 16;\n\t\t\tbreak;\n\t\tcase R_PPC64_REL16_LO:\n\t\t\tword = 2;\n\t\t\tval = (S + A - P) & 0xffff;\n\t\t\tbreak;\n\t\tcase R_PPC64_REL14:\n\t\t\tlow = 14;\n\t\t\tval = (st64)(S + A - P) >> 2;\n\t\t\tbreak;\n\t\tcase R_PPC64_REL24:\n\t\t\tlow = 24;\n\t\t\tval = (st64)(S + A - P) >> 2;\n\t\t\tbreak;\n\t\tcase R_PPC64_REL32:\n\t\t\tword = 4;\n\t\t\tval = S + A - P;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tif (low) {\n\t\t\t// TODO big-endian\n\t\t\tswitch (low) {\n\t\t\tcase 14:\n\t\t\t\tval &= (1 << 14) - 1;\n\t\t\t\tiob->read_at (iob->io, rel->rva, buf, 2);\n\t\t\t\tr_write_le32 (buf, (r_read_le32 (buf) & ~((1<<16) - (1<<2))) | val << 2);\n\t\t\t\tiob->write_at (iob->io, rel->rva, buf, 2);\n\t\t\t\tbreak;\n\t\t\tcase 24:\n\t\t\t\tval &= (1 << 24) - 1;\n\t\t\t\tiob->read_at (iob->io, rel->rva, buf, 4);\n\t\t\t\tr_write_le32 (buf, (r_read_le32 (buf) & ~((1<<26) - (1<<2))) | val << 2);\n\t\t\t\tiob->write_at (iob->io, rel->rva, buf, 4);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (word) {\n\t\t\t// TODO big-endian\n\t\t\tswitch (word) {\n\t\t\tcase 2:\n\t\t\t\tr_write_le16 (buf, val);\n\t\t\t\tiob->write_at (iob->io, rel->rva, buf, 2);\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tr_write_le32 (buf, val);\n\t\t\t\tiob->write_at (iob->io, rel->rva, buf, 4);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\tcase EM_X86_64: {\n\t\tint word = 0;\n\t\tswitch (rel->type) {\n\t\tcase R_X86_64_8:\n\t\t\tword = 1;\n\t\t\tval = S + A;\n\t\t\tbreak;\n\t\tcase R_X86_64_16:\n\t\t\tword = 2;\n\t\t\tval = S + A;\n\t\t\tbreak;\n\t\tcase R_X86_64_32:\n\t\tcase R_X86_64_32S:\n\t\t\tword = 4;\n\t\t\tval = S + A;\n\t\t\tbreak;\n\t\tcase R_X86_64_64:\n\t\t\tword = 8;\n\t\t\tval = S + A;\n\t\t\tbreak;\n\t\tcase R_X86_64_GLOB_DAT:\n\t\tcase R_X86_64_JUMP_SLOT:\n\t\t\tword = 4;\n\t\t\tval = S;\n\t\t\tbreak;\n\t\tcase R_X86_64_PC8:\n\t\t\tword = 1;\n\t\t\tval = S + A - P;\n\t\t\tbreak;\n\t\tcase R_X86_64_PC16:\n\t\t\tword = 2;\n\t\t\tval = S + A - P;\n\t\t\tbreak;\n\t\tcase R_X86_64_PC32:\n\t\t\tword = 4;\n\t\t\tval = S + A - P;\n\t\t\tbreak;\n\t\tcase R_X86_64_PC64:\n\t\t\tword = 8;\n\t\t\tval = S + A - P;\n\t\t\tbreak;\n\t\tcase R_X86_64_PLT32:\n\t\t\tword = 4;\n\t\t\tval = L + A - P;\n\t\t\tbreak;\n\t\tcase R_X86_64_RELATIVE:\n\t\t\tword = 8;\n\t\t\tval = B + A;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t//eprintf (\"relocation %d not handle at this time\\n\", rel->type);\n\t\t\tbreak;\n\t\t}\n\t\tswitch (word) {\n\t\tcase 0:\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tbuf[0] = val;\n\t\t\tiob->write_at (iob->io, rel->rva, buf, 1);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tr_write_le16 (buf, val);\n\t\t\tiob->write_at (iob->io, rel->rva, buf, 2);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tr_write_le32 (buf, val);\n\t\t\tiob->write_at (iob->io, rel->rva, buf, 4);\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tr_write_le64 (buf, val);\n\t\t\tiob->write_at (iob->io, rel->rva, buf, 8);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n\t}\n}\n\nstatic bool ht_insert_intu64(SdbHash* ht, int key, ut64 value) {\n\tut64 *mvalue = malloc (sizeof (ut64));\n\tif (!mvalue) {\n\t\treturn false;\n\t}\n\t*mvalue = value;\n\treturn ht_insert (ht, sdb_fmt (\"%d\", key), (void *)mvalue);\n}\n\nstatic ut64 ht_find_intu64(SdbHash* ht, int key, bool* found) {\n\tut64 *mvalue = (ut64 *)ht_find (ht, sdb_fmt (\"%d\", key), found);\n\treturn *mvalue;\n}\n\nstatic void relocs_by_sym_free(HtKv *kv) {\n\tfree (kv->key);\n\tfree (kv->value);\n}\n\nstatic RList* patch_relocs(RBin *b) {\n\tRList *ret = NULL;\n\tRBinReloc *ptr = NULL;\n\tRIO *io = NULL;\n\tRBinObject *obj = NULL;\n\tstruct Elf_(r_bin_elf_obj_t) *bin = NULL;\n\tRIOSection *g = NULL, *s = NULL;\n\tSdbHash *relocs_by_sym;\n\tSdbListIter *iter;\n\tRBinElfReloc *relcs = NULL;\n\tRBinInfo *info;\n\tint cdsz;\n\tint i;\n\tut64 n_off, n_vaddr, vaddr, size, offset = 0;\n\n\tif (!b)\n\t\treturn NULL;\n\tio = b->iob.io;\n\tif (!io || !io->desc)\n\t\treturn NULL;\n\tobj = r_bin_cur_object (b);\n\tif (!obj) {\n\t   \treturn NULL;\n\t}\n\tbin = obj->bin_obj;\n\tif (bin->ehdr.e_type != ET_REL) {\n\t\treturn NULL;\n\t}\n\tif (!io->cached) {\n\t   \teprintf (\"Warning: run r2 with -e io.cache=true to fix relocations in disassembly\\n\");\n\t\treturn relocs (r_bin_cur (b));\n\t}\n\n\tinfo = obj ? obj->info: NULL;\n\tcdsz = info? (info->bits == 64? 8: info->bits == 32? 4: info->bits == 16 ? 4: 0): 0;\n\n\tls_foreach (io->sections, iter, s) {\n\t\tif (s->paddr > offset) {\n\t\t\toffset = s->paddr;\n\t\t\tg = s;\n\t\t}\n\t}\n\tif (!g) {\n\t\treturn NULL;\n\t}\n\tn_off = g->paddr + g->size;\n\tn_vaddr = g->vaddr + g->vsize;\n\t//reserve at least that space\n\tsize = bin->reloc_num * 4;\n\tif (!b->iob.section_add (io, n_off, n_vaddr, size, size, R_BIN_SCN_READABLE, \".got.r2\", 0, io->desc->fd)) {\n\t\treturn NULL;\n\t}\n\tif (!(relcs = Elf_(r_bin_elf_get_relocs) (bin))) {\n\t\treturn NULL;\n\t}\n\tif (!(ret = r_list_newf ((RListFree)free))) {\n\t\tfree (relcs);\n\t\treturn NULL;\n\t}\n\tif (!(relocs_by_sym = ht_new (NULL, relocs_by_sym_free, NULL))) {\n\t\tr_list_free (ret);\n\t\tfree (relcs);\n\t\treturn NULL;\n\t}\n\tvaddr = n_vaddr;\n\tfor (i = 0; !relcs[i].last; i++) {\n\t\tut64 sym_addr = 0;\n\n\t\tif (relcs[i].sym) {\n\t\t\tif (relcs[i].sym < bin->imports_by_ord_size && bin->imports_by_ord[relcs[i].sym]) {\n\t\t\t\tbool found;\n\n\t\t\t\tsym_addr = ht_find_intu64 (relocs_by_sym, relcs[i].sym, &found);\n\t\t\t\tif (!found) {\n\t\t\t\t\tsym_addr = 0;\n\t\t\t\t}\n\t\t\t} else if (relcs[i].sym < bin->symbols_by_ord_size && bin->symbols_by_ord[relcs[i].sym]) {\n\t\t\t\tsym_addr = bin->symbols_by_ord[relcs[i].sym]->vaddr;\n\t\t\t}\n\t\t}\n\t\t// TODO relocation types B, L\n\t\t_patch_reloc (bin->ehdr.e_machine, &b->iob, &relcs[i], sym_addr ? sym_addr : vaddr, 0, n_vaddr + size);\n\t\tif (!(ptr = reloc_convert (bin, &relcs[i], n_vaddr))) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (sym_addr) {\n\t\t\tptr->vaddr = sym_addr;\n\t\t} else {\n\t\t\tptr->vaddr = vaddr;\n\t\t\tht_insert_intu64 (relocs_by_sym, relcs[i].sym, vaddr);\n\t\t\tvaddr += cdsz;\n\t\t}\n\t\tr_list_append (ret, ptr);\n\t}\n\tht_free (relocs_by_sym);\n\tfree (relcs);\n\treturn ret;\n}\n\nstatic bool has_canary(RBinFile *bf) {\n\tbool ret = false;\n\tRList* imports_list = imports (bf);\n\tRListIter *iter;\n\tRBinImport *import;\n\tif (imports_list) {\n\t\tr_list_foreach (imports_list, iter, import) {\n\t\t\tif (!strcmp (import->name, \"__stack_chk_fail\") || !strcmp (import->name, \"__stack_smash_handler\")) {\n\t\t\t\tret = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\timports_list->free = r_bin_import_free;\n\t\tr_list_free (imports_list);\n\t}\n\treturn ret;\n}\n\nstatic RBinInfo* info(RBinFile *bf) {\n\tRBinInfo *ret = NULL;\n\tchar *str;\n\n\tif (!(ret = R_NEW0 (RBinInfo))) {\n\t\treturn NULL;\n\t}\n\tret->lang = \"c\";\n\tret->file = bf->file\n\t\t? strdup (bf->file)\n\t\t: NULL;\n\tvoid *obj = bf->o->bin_obj;\n\tif ((str = Elf_(r_bin_elf_get_rpath)(obj))) {\n\t\tret->rpath = strdup (str);\n\t\tfree (str);\n\t} else {\n\t\tret->rpath = strdup (\"NONE\");\n\t}\n\tif (!(str = Elf_(r_bin_elf_get_file_type) (obj))) {\n\t\tfree (ret);\n\t\treturn NULL;\n\t}\n\tret->type = str;\n\tret->has_pi = (strstr (str, \"DYN\"))? 1: 0;\n\tret->has_lit = true;\n\tret->has_canary = has_canary (bf);\n\tif (!(str = Elf_(r_bin_elf_get_elf_class) (obj))) {\n\t\tfree (ret);\n\t\treturn NULL;\n\t}\n\tret->bclass = str;\n\tif (!(str = Elf_(r_bin_elf_get_osabi_name) (obj))) {\n\t\tfree (ret);\n\t\treturn NULL;\n\t}\n\tret->os = str;\n\tif (!(str = Elf_(r_bin_elf_get_osabi_name) (obj))) {\n\t\tfree (ret);\n\t\treturn NULL;\n\t}\n\tret->subsystem = str;\n\tif (!(str = Elf_(r_bin_elf_get_machine_name) (obj))) {\n\t\tfree (ret);\n\t\treturn NULL;\n\t}\n\tret->machine = str;\n\tif (!(str = Elf_(r_bin_elf_get_arch) (obj))) {\n\t\tfree (ret);\n\t\treturn NULL;\n\t}\n\tret->arch = str;\n\tret->rclass = strdup (\"elf\");\n\tret->bits = Elf_(r_bin_elf_get_bits) (obj);\n\tif (!strcmp (ret->arch, \"avr\")) {\n\t\tret->bits = 16;\n\t}\n\tret->big_endian = Elf_(r_bin_elf_is_big_endian) (obj);\n\tret->has_va = Elf_(r_bin_elf_has_va) (obj);\n\tret->has_nx = Elf_(r_bin_elf_has_nx) (obj);\n\tret->intrp = Elf_(r_bin_elf_intrp) (obj);\n\tret->dbg_info = 0;\n\tif (!Elf_(r_bin_elf_get_stripped) (obj)) {\n\t\tret->dbg_info |= R_BIN_DBG_LINENUMS | R_BIN_DBG_SYMS | R_BIN_DBG_RELOCS;\n\t} else {\n\t\tret->dbg_info |= R_BIN_DBG_STRIPPED;\n\t}\n\tif (Elf_(r_bin_elf_get_static) (obj)) {\n\t\tret->dbg_info |= R_BIN_DBG_STATIC;\n\t}\n\tRBinElfSymbol *symbol;\n\tif (!(symbol = Elf_(r_bin_elf_get_symbols) (obj))) {\n\t\treturn ret;\n\t}\n\tint i;\n\tfor (i = 0; !symbol[i].last; i++) {\n\t\tif (!strncmp (symbol[i].name, \"type.\", 5)) {\n\t\t\tret->lang = \"go\";\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\n\nstatic RList* fields(RBinFile *bf) {\n\tRList *ret = NULL;\n\tRBinField *ptr = NULL;\n\tstruct r_bin_elf_field_t *field = NULL;\n\tint i;\n\n\tif (!(ret = r_list_new ())) {\n\t\treturn NULL;\n\t}\n\tret->free = free;\n\tif (!(field = Elf_(r_bin_elf_get_fields) (bf->o->bin_obj))) {\n\t\treturn ret;\n\t}\n\tfor (i = 0; !field[i].last; i++) {\n\t\tif (!(ptr = R_NEW0 (RBinField))) {\n\t\t\tbreak;\n\t\t}\n\t\tptr->name = strdup (field[i].name);\n\t\tptr->comment = NULL;\n\t\tptr->vaddr = field[i].offset;\n\t\tptr->paddr = field[i].offset;\n\t\tr_list_append (ret, ptr);\n\t}\n\tfree (field);\n\treturn ret;\n}\n\nstatic ut64 size(RBinFile *bf) {\n\tut64 off = 0;\n\tut64 len = 0;\n\tif (!bf->o->sections) {\n\t\tRListIter *iter;\n\t\tRBinSection *section;\n\t\tbf->o->sections = sections (bf);\n\t\tr_list_foreach (bf->o->sections, iter, section) {\n\t\t\tif (section->paddr > off) {\n\t\t\t\toff = section->paddr;\n\t\t\t\tlen = section->size;\n\t\t\t}\n\t\t}\n\t}\n\treturn off + len;\n}\n\n#if !R_BIN_ELF64 && !R_BIN_CGC\n\nstatic void headers32(RBinFile *bf) {\n#define p bf->rbin->cb_printf\n\tconst ut8 *buf = r_buf_get_at (bf->buf, 0, NULL);\n\tp (\"0x00000000  ELF MAGIC   0x%08x\\n\", r_read_le32 (buf));\n\tp (\"0x00000004  Type        0x%04x\\n\", r_read_le16 (buf + 4));\n\tp (\"0x00000006  Machine     0x%04x\\n\", r_read_le16 (buf + 6));\n\tp (\"0x00000008  Version     0x%08x\\n\", r_read_le32 (buf + 8));\n\tp (\"0x0000000c  Entrypoint  0x%08x\\n\", r_read_le32 (buf + 12));\n\tp (\"0x00000010  PhOff       0x%08x\\n\", r_read_le32 (buf + 16));\n\tp (\"0x00000014  ShOff       0x%08x\\n\", r_read_le32 (buf + 20));\n}\n\nstatic bool check_bytes(const ut8 *buf, ut64 length) {\n\treturn buf && length > 4 && memcmp (buf, ELFMAG, SELFMAG) == 0\n\t\t&& buf[4] != 2;\n}\n\nextern struct r_bin_dbginfo_t r_bin_dbginfo_elf;\nextern struct r_bin_write_t r_bin_write_elf;\n\nstatic RBuffer* create(RBin* bin, const ut8 *code, int codelen, const ut8 *data, int datalen) {\n\tut32 filesize, code_va, code_pa, phoff;\n\tut32 p_start, p_phoff, p_phdr;\n\tut32 p_ehdrsz, p_phdrsz;\n\tut16 ehdrsz, phdrsz;\n\tut32 p_vaddr, p_paddr, p_fs, p_fs2;\n\tut32 baddr;\n\tint is_arm = 0;\n\tRBuffer *buf = r_buf_new ();\n\tif (bin && bin->cur && bin->cur->o && bin->cur->o->info) {\n\t\tis_arm = !strcmp (bin->cur->o->info->arch, \"arm\");\n\t}\n\t// XXX: hardcoded\n\tif (is_arm) {\n\t\tbaddr = 0x40000;\n\t} else {\n\t\tbaddr = 0x8048000;\n\t}\n\n#define B(x,y) r_buf_append_bytes(buf,(const ut8*)x,y)\n#define D(x) r_buf_append_ut32(buf,x)\n#define H(x) r_buf_append_ut16(buf,x)\n#define Z(x) r_buf_append_nbytes(buf,x)\n#define W(x,y,z) r_buf_write_at(buf,x,(const ut8*)y,z)\n#define WZ(x,y) p_tmp=buf->length;Z(x);W(p_tmp,y,strlen(y))\n\n\tB (\"\\x7F\" \"ELF\" \"\\x01\\x01\\x01\\x00\", 8);\n\tZ (8);\n\tH (2); // ET_EXEC\n\tif (is_arm) {\n\t\tH (40); // e_machne = EM_ARM\n\t} else {\n\t\tH (3); // e_machne = EM_I386\n\t}\n\n\tD (1);\n\tp_start = buf->length;\n\tD (-1); // _start\n\tp_phoff = buf->length;\n\tD (-1); // phoff -- program headers offset\n\tD (0);  // shoff -- section headers offset\n\tD (0);  // flags\n\tp_ehdrsz = buf->length;\n\tH (-1); // ehdrsz\n\tp_phdrsz = buf->length;\n\tH (-1); // phdrsz\n\tH (1);\n\tH (0);\n\tH (0);\n\tH (0);\n\t// phdr:\n\tp_phdr = buf->length;\n\tD (1);\n\tD (0);\n\tp_vaddr = buf->length;\n\tD (-1); // vaddr = $$\n\tp_paddr = buf->length;\n\tD (-1); // paddr = $$\n\tp_fs = buf->length;\n\tD (-1); // filesize\n\tp_fs2 = buf->length;\n\tD (-1); // filesize\n\tD (5); // flags\n\tD (0x1000); // align\n\n\tehdrsz = p_phdr;\n\tphdrsz = buf->length - p_phdr;\n\tcode_pa = buf->length;\n\tcode_va = code_pa + baddr;\n\tphoff = 0x34;//p_phdr ;\n\tfilesize = code_pa + codelen + datalen;\n\n\tW (p_start, &code_va, 4);\n\tW (p_phoff, &phoff, 4);\n\tW (p_ehdrsz, &ehdrsz, 2);\n\tW (p_phdrsz, &phdrsz, 2);\n\n\tcode_va = baddr; // hack\n\tW (p_vaddr, &code_va, 4);\n\tcode_pa = baddr; // hack\n\tW (p_paddr, &code_pa, 4);\n\n\tW (p_fs, &filesize, 4);\n\tW (p_fs2, &filesize, 4);\n\n\tB (code, codelen);\n\n\tif (data && datalen > 0) {\n\t\t//ut32 data_section = buf->length;\n\t\teprintf (\"Warning: DATA section not support for ELF yet\\n\");\n\t\tB (data, datalen);\n\t}\n\treturn buf;\n}\n\nRBinPlugin r_bin_plugin_elf = {\n\t.name = \"elf\",\n\t.desc = \"ELF format r2 plugin\",\n\t.license = \"LGPL3\",\n\t.get_sdb = &get_sdb,\n\t.load = &load,\n\t.load_bytes = &load_bytes,\n\t.load_buffer = &load_buffer,\n\t.destroy = &destroy,\n\t.check_bytes = &check_bytes,\n\t.baddr = &baddr,\n\t.boffset = &boffset,\n\t.binsym = &binsym,\n\t.entries = &entries,\n\t.sections = &sections,\n\t.symbols = &symbols,\n\t.minstrlen = 4,\n\t.imports = &imports,\n\t.info = &info,\n\t.fields = &fields,\n\t.header = &headers32,\n\t.size = &size,\n\t.libs = &libs,\n\t.relocs = &relocs,\n\t.patch_relocs = &patch_relocs,\n\t.dbginfo = &r_bin_dbginfo_elf,\n\t.create = &create,\n\t.write = &r_bin_write_elf,\n\t.file_type = &get_file_type,\n\t.regstate = &regstate,\n\t.maps = &maps,\n};\n\n#ifndef CORELIB\nRLibStruct radare_plugin = {\n\t.type = R_LIB_TYPE_BIN,\n\t.data = &r_bin_plugin_elf,\n\t.version = R2_VERSION\n};\n#endif\n#endif\n", "/* radare - LGPL - Copyright 2011-2018 - earada, pancake */\n\n#include <r_core.h>\n#include \"r_util.h\"\n\n#define DBSPATH \"/share/radare2/\" R2_VERSION \"/fcnsign\"\n#define is_in_range(at, from, sz) ((at) >= (from) && (at) < ((from) + (sz)))\n\n#define VA_FALSE    0\n#define VA_TRUE     1\n#define VA_NOREBASE 2\n\n#define IS_MODE_SET(mode) (mode & R_CORE_BIN_SET)\n#define IS_MODE_SIMPLE(mode) (mode & R_CORE_BIN_SIMPLE)\n#define IS_MODE_SIMPLEST(mode) (mode & R_CORE_BIN_SIMPLEST)\n#define IS_MODE_JSON(mode) (mode & R_CORE_BIN_JSON)\n#define IS_MODE_RAD(mode) (mode & R_CORE_BIN_RADARE)\n#define IS_MODE_NORMAL(mode) (!mode)\n#define IS_MODE_CLASSDUMP(mode) (mode & R_CORE_BIN_CLASSDUMP)\n\n// dup from cmd_info\n#define PAIR_WIDTH 9\n\nstatic void pair(const char *a, const char *b, int mode, bool last) {\n\tif (!b || !*b) {\n\t\treturn;\n\t}\n\tif (IS_MODE_JSON (mode)) {\n\t\tconst char *lst = last ? \"\" : \",\";\n\t\tr_cons_printf (\"\\\"%s\\\":%s%s\", a, b, lst);\n\t} else {\n\t\tchar ws[16];\n\t\tint al = strlen (a);\n\t\tif (al > PAIR_WIDTH) {\n\t\t\tal = 0;\n\t\t} else {\n\t\t\tal = PAIR_WIDTH - al;\n\t\t}\n\t\tmemset (ws, ' ', al);\n\t\tws[al] = 0;\n\t\tr_cons_printf (\"%s%s%s\\n\", a, ws, b);\n\t}\n}\n\nstatic void pair_bool(const char *a, bool t, int mode, bool last) {\n\tpair (a, r_str_bool (t), mode, last);\n}\n\nstatic void pair_int(const char *a, int n, int mode, bool last) {\n\tpair (a, sdb_fmt (\"%d\", n), mode, last);\n}\n\nstatic void pair_ut64(const char *a, ut64 n, int mode, bool last) {\n\tpair (a, sdb_fmt (\"%\"PFMT64d, n), mode, last);\n}\n\nstatic void pair_str(const char *a, const char *b, int mode, int last) {\n\tif (IS_MODE_JSON (mode)) {\n\t\tif (!b) {\n\t\t\tb = \"\";\n\t\t}\n\t\tchar *eb = r_str_utf16_encode (b, -1);\n\t\tif (eb) {\n\t\t\tchar *qs = r_str_newf (\"\\\"%s\\\"\", eb);\n\t\t\tpair (a, qs, mode, last);\n\t\t\tfree (eb);\n\t\t\tfree (qs);\n\t\t}\n\t} else {\n\t\tpair (a, b, mode, last);\n\t}\n}\n\n#define STR(x) (x)?(x):\"\"\nR_API int r_core_bin_set_cur (RCore *core, RBinFile *binfile);\n\nstatic ut64 rva(RBin *bin, ut64 paddr, ut64 vaddr, int va) {\n\tif (va == VA_TRUE) {\n\t\treturn r_bin_get_vaddr (bin, paddr, vaddr);\n\t}\n\tif (va == VA_NOREBASE) {\n\t\treturn vaddr;\n\t}\n\treturn paddr;\n}\n\nR_API int r_core_bin_set_by_fd(RCore *core, ut64 bin_fd) {\n\tif (r_bin_file_set_cur_by_fd (core->bin, bin_fd)) {\n\t\tr_core_bin_set_cur (core, r_core_bin_cur (core));\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nR_API int r_core_bin_set_by_name(RCore *core, const char * name) {\n\tif (r_bin_file_set_cur_by_name (core->bin, name)) {\n\t\tr_core_bin_set_cur (core, r_core_bin_cur (core));\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nR_API int r_core_bin_set_env(RCore *r, RBinFile *binfile) {\n\tRBinObject *binobj = binfile ? binfile->o: NULL;\n\tRBinInfo *info = binobj ? binobj->info: NULL;\n\tif (info) {\n\t\tint va = info->has_va;\n\t\tconst char * arch = info->arch;\n\t\tut16 bits = info->bits;\n\t\tut64 baseaddr = r_bin_get_baddr (r->bin);\n\t\tr_config_set_i (r->config, \"bin.baddr\", baseaddr);\n\t\tr_config_set (r->config, \"asm.arch\", arch);\n\t\tr_config_set_i (r->config, \"asm.bits\", bits);\n\t\tr_config_set (r->config, \"anal.arch\", arch);\n\t\tif (info->cpu && *info->cpu) {\n\t\t\tr_config_set (r->config, \"anal.cpu\", info->cpu);\n\t\t} else {\n\t\t\tr_config_set (r->config, \"anal.cpu\", arch);\n\t\t}\n\t\tr_asm_use (r->assembler, arch);\n\t\tr_core_bin_info (r, R_CORE_BIN_ACC_ALL, R_CORE_BIN_SET, va, NULL, NULL);\n\t\tr_core_bin_set_cur (r, binfile);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nR_API int r_core_bin_set_cur(RCore *core, RBinFile *binfile) {\n\tif (!core->bin) {\n\t\treturn false;\n\t}\n\tif (!binfile) {\n\t\t// Find first available binfile\n\t\tut32 fd = r_core_file_cur_fd (core);\n\t\tbinfile = fd != (ut32)-1\n\t\t\t\t  ? r_bin_file_find_by_fd (core->bin, fd)\n\t\t\t\t  : NULL;\n\t\tif (!binfile) {\n\t\t\treturn false;\n\t\t}\n\t}\n\tr_bin_file_set_cur_binfile (core->bin, binfile);\n\treturn true;\n}\n\nR_API int r_core_bin_refresh_strings(RCore *r) {\n\treturn r_bin_reset_strings (r->bin) ? true: false;\n}\n\nR_API RBinFile * r_core_bin_cur(RCore *core) {\n\tRBinFile *binfile = r_bin_cur (core->bin);\n\treturn binfile;\n}\n\nstatic void _print_strings(RCore *r, RList *list, int mode, int va) {\n\tbool b64str = r_config_get_i (r->config, \"bin.b64str\");\n\tint minstr = r_config_get_i (r->config, \"bin.minstr\");\n\tint maxstr = r_config_get_i (r->config, \"bin.maxstr\");\n\tRBin *bin = r->bin;\n\tRBinObject *obj = r_bin_cur_object (bin);\n\tRListIter *iter;\n\tRListIter *last_processed = NULL;\n\tRBinString *string;\n\tRBinSection *section;\n\tchar *q;\n\n\tbin->minstrlen = minstr;\n\tbin->maxstrlen = maxstr;\n\tif (IS_MODE_JSON (mode)) {\n\t\tr_cons_printf (\"[\");\n\t}\n\tif (IS_MODE_RAD (mode)) {\n\t\tr_cons_printf (\"fs strings\");\n\t}\n\tif (IS_MODE_SET (mode) && r_config_get_i (r->config, \"bin.strings\")) {\n\t\tr_flag_space_set (r->flags, \"strings\");\n\t\tr_cons_break_push (NULL, NULL);\n\t}\n\tRBinString b64 = {0};\n\tr_list_foreach (list, iter, string) {\n\t\tconst char *section_name, *type_string;\n\t\tut64 paddr, vaddr, addr;\n\t\tpaddr = string->paddr;\n\t\tvaddr = r_bin_get_vaddr (bin, paddr, string->vaddr);\n\t\taddr = va ? vaddr : paddr;\n\t\tif (!r_bin_string_filter (bin, string->string, addr)) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (string->length < minstr) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (maxstr && string->length > maxstr) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tsection = r_bin_get_section_at (obj, paddr, 0);\n\t\tsection_name = section ? section->name : \"\";\n\t\ttype_string = r_bin_string_type (string->type);\n\t\tif (b64str) {\n\t\t\tut8 *s = r_base64_decode_dyn (string->string, -1);\n\t\t\tif (s && *s && IS_PRINTABLE (*s)) {\n\t\t\t\t// TODO: add more checks\n\t\t\t\tfree (b64.string);\n\t\t\t\tmemcpy (&b64, string, sizeof (b64));\n\t\t\t\tb64.string = (char *)s;\n\t\t\t\tb64.size = strlen (b64.string);\n\t\t\t\tstring = &b64;\n\t\t\t}\n\t\t}\n\t\tif (IS_MODE_SET (mode)) {\n\t\t\tchar *f_name, *str;\n\t\t\tif (r_cons_is_breaked ()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tr_meta_add (r->anal, R_META_TYPE_STRING, addr, addr + string->size, string->string);\n\t\t\tf_name = strdup (string->string);\n\t\t\tr_name_filter (f_name, -1);\n\t\t\tif (r->bin->prefix) {\n\t\t\t\tstr = r_str_newf (\"%s.str.%s\", r->bin->prefix, f_name);\n\t\t\t} else {\n\t\t\t\tstr = r_str_newf (\"str.%s\", f_name);\n\t\t\t}\n\t\t\tr_flag_set (r->flags, str, addr, string->size);\n\t\t\tfree (str);\n\t\t\tfree (f_name);\n\t\t} else if (IS_MODE_SIMPLE (mode)) {\n\t\t\tr_cons_printf (\"0x%\"PFMT64x\" %d %d %s\\n\", addr,\n\t\t\t\tstring->size, string->length, string->string);\n\t\t} else if (IS_MODE_SIMPLEST (mode)) {\n\t\t\tr_cons_println (string->string);\n\t\t} else if (IS_MODE_JSON (mode)) {\n\t\t\tint *block_list;\n\t\t\tq = r_base64_encode_dyn (string->string, -1);\n\t\t\tr_cons_printf (\"%s{\\\"vaddr\\\":%\"PFMT64d\n\t\t\t\t\",\\\"paddr\\\":%\"PFMT64d\",\\\"ordinal\\\":%d\"\n\t\t\t\t\",\\\"size\\\":%d,\\\"length\\\":%d,\\\"section\\\":\\\"%s\\\",\"\n\t\t\t\t\"\\\"type\\\":\\\"%s\\\",\\\"string\\\":\\\"%s\\\"\",\n\t\t\t\tlast_processed ? \",\": \"\",\n\t\t\t\tvaddr, paddr, string->ordinal, string->size,\n\t\t\t\tstring->length, section_name, type_string, q);\n\t\t\tswitch (string->type) {\n\t\t\tcase R_STRING_TYPE_UTF8:\n\t\t\tcase R_STRING_TYPE_WIDE:\n\t\t\tcase R_STRING_TYPE_WIDE32:\n\t\t\t\tblock_list = r_utf_block_list ((const ut8*)string->string);\n\t\t\t\tif (block_list) {\n\t\t\t\t\tif (block_list[0] == 0 && block_list[1] == -1) {\n\t\t\t\t\t\t/* Don't include block list if\n\t\t\t\t\t\t   just Basic Latin (0x00 - 0x7F) */\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tint *block_ptr = block_list;\n\t\t\t\t\tr_cons_printf (\",\\\"blocks\\\":[\");\n\t\t\t\t\tfor (; *block_ptr != -1; block_ptr++) {\n\t\t\t\t\t\tif (block_ptr != block_list) {\n\t\t\t\t\t\t\tr_cons_printf (\",\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst char *utfName = r_utf_block_name (*block_ptr);\n\t\t\t\t\t\tr_cons_printf (\"\\\"%s\\\"\", utfName? utfName: \"\");\n\t\t\t\t\t}\n\t\t\t\t\tr_cons_printf (\"]\");\n\t\t\t\t\tR_FREE (block_list);\n\t\t\t\t}\n\t\t\t}\n\t\t\tr_cons_printf (\"}\");\n\t\t\tfree (q);\n\t\t} else if (IS_MODE_RAD (mode)) {\n\t\t\tchar *f_name, *str;\n\t\t\tf_name = strdup (string->string);\n\t\t\tr_name_filter (f_name, R_FLAG_NAME_SIZE);\n\t\t\tif (r->bin->prefix) {\n\t\t\t\tstr = r_str_newf (\"%s.str.%s\", r->bin->prefix, f_name);\n\t\t\t\tr_cons_printf (\"f %s.str.%s %\"PFMT64d\" @ 0x%08\"PFMT64x\"\\n\"\n\t\t\t\t\t\"Cs %\"PFMT64d\" @ 0x%08\"PFMT64x\"\\n\",\n\t\t\t\t\tr->bin->prefix, f_name, string->size, addr,\n\t\t\t\t\tstring->size, addr);\n\t\t\t} else {\n\t\t\t\tstr = r_str_newf (\"str.%s\", f_name);\n\t\t\t\tr_cons_printf (\"f str.%s %\"PFMT64d\" @ 0x%08\"PFMT64x\"\\n\"\n\t\t\t\t\t\"Cs %\"PFMT64d\" @ 0x%08\"PFMT64x\"\\n\",\n\t\t\t\t\tf_name, string->size, addr,\n\t\t\t\t\tstring->size, addr);\n\t\t\t}\n\t\t\tfree (str);\n\t\t\tfree (f_name);\n\t\t} else {\n\t\t\tint *block_list;\n\t\t\tchar *str = string->string;\n\t\t\tchar *no_dbl_bslash_str = NULL;\n\t\t\tif (!r->print->esc_bslash) {\n\t\t\t\tchar *ptr;\n\t\t\t\tfor (ptr = str; *ptr; ptr++) {\n\t\t\t\t\tif (*ptr != '\\\\') {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (*(ptr + 1) == '\\\\') {\n\t\t\t\t\t\tif (!no_dbl_bslash_str) {\n\t\t\t\t\t\t\tno_dbl_bslash_str = strdup (str);\n\t\t\t\t\t\t\tif (!no_dbl_bslash_str) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tptr = no_dbl_bslash_str + (ptr - str);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmemmove (ptr + 1, ptr + 2, strlen (ptr + 2) + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (no_dbl_bslash_str) {\n\t\t\t\t\tstr = no_dbl_bslash_str;\n\t\t\t\t}\n\t\t\t}\n#if 0\n\t\t\tr_cons_printf (\"vaddr=0x%08\"PFMT64x\" paddr=0x%08\"\n\t\t\t\tPFMT64x\" ordinal=%03u sz=%u len=%u \"\n\t\t\t\t\"section=%s type=%s string=%s\",\n\t\t\t\tvaddr, paddr, string->ordinal, string->size,\n\t\t\t\tstring->length, section_name, type_string, str);\n#else\n\t\t\tr_cons_printf (\"%03u 0x%08\"PFMT64x\" 0x%08\"\n\t\t\t\tPFMT64x\" %3u %3u \"\n\t\t\t\t\"(%s) %5s %s\",\n\t\t\t\tstring->ordinal, paddr, vaddr, \n\t\t\t\tstring->length, string->size,\n\t\t\t\tsection_name, type_string, str);\n#endif\n\t\t\tif (str == no_dbl_bslash_str) {\n\t\t\t\tR_FREE (str);\n\t\t\t}\n\t\t\tswitch (string->type) {\n\t\t\tcase R_STRING_TYPE_UTF8:\n\t\t\tcase R_STRING_TYPE_WIDE:\n\t\t\tcase R_STRING_TYPE_WIDE32:\n\t\t\t\tblock_list = r_utf_block_list ((const ut8*)string->string);\n\t\t\t\tif (block_list) {\n\t\t\t\t\tif (block_list[0] == 0 && block_list[1] == -1) {\n\t\t\t\t\t\t/* Don't show block list if\n\t\t\t\t\t\t   just Basic Latin (0x00 - 0x7F) */\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tint *block_ptr = block_list;\n\t\t\t\t\tr_cons_printf (\" blocks=\");\n\t\t\t\t\tfor (; *block_ptr != -1; block_ptr++) {\n\t\t\t\t\t\tif (block_ptr != block_list) {\n\t\t\t\t\t\t\tr_cons_printf (\",\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst char *name = r_utf_block_name (*block_ptr);\n\t\t\t\t\t\tr_cons_printf (\"%s\", name? name: \"\");\n\t\t\t\t\t}\n\t\t\t\t\tfree (block_list);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tr_cons_printf (\"\\n\");\n\t\t}\n\t\tlast_processed = iter;\n\t}\n\tR_FREE (b64.string);\n\tif (IS_MODE_JSON (mode)) {\n\t\tr_cons_printf (\"]\");\n\t}\n\tif (IS_MODE_SET (mode)) {\n\t\tr_cons_break_pop ();\n\t}\n}\n\nstatic bool bin_raw_strings(RCore *r, int mode, int va) {\n\tRBinFile *bf = r_bin_cur (r->bin);\n\tbool new_bf = false;\n\tif (bf && strstr (bf->file, \"malloc://\")) {\n\t\t//sync bf->buf to search string on it\n\t\tr_io_read_at (r->io, 0, bf->buf->buf, bf->size);\n\t}\n\tif (!r->file) {\n\t\teprintf (\"Core file not open\\n\");\n\t\treturn false;\n\t}\n\tif (!bf) {\n\t\tbf = R_NEW0 (RBinFile);\n\t\tif (!bf) {\n\t\t\treturn false;\n\t\t}\n\t\tRIODesc *desc = r_io_desc_get (r->io, r->file->fd);\n\t\tif (!desc) {\n\t\t\tfree (bf);\n\t\t\treturn false;\n\t\t}\n\t\tbf->file = strdup (desc->name);\n\t\tbf->size = r_io_desc_size (desc);\n\t\tif (bf->size == UT64_MAX) {\n\t\t\tfree (bf);\n\t\t\treturn false;\n\t\t}\n\t\tbf->buf = r_buf_new_with_io (&r->bin->iob, r->file->fd);\n#if 0\n\t\tbf->buf = r_buf_new ();\n\t\tif (!bf->buf) {\n\t\t\tfree (bf);\n\t\t\treturn false;\n\t\t}\n\t\tbf->buf->buf = malloc (bf->size);\n\t\tif (!bf->buf->buf) {\n\t\t\tfree (bf->buf);\n\t\t\tfree (bf);\n\t\t\treturn false;\n\t\t}\n\t\tbf->buf->fd = r->file->fd;\n\t\tbf->buf->length = bf->size;\n\t\tr_io_read_at (r->io, 0, bf->buf->buf, bf->size);\n#endif\n\t\tbf->o = NULL;\n\t\tbf->rbin = r->bin;\n\t\tnew_bf = true;\n\t\tva = false;\n\t}\n\tRList *l = r_bin_raw_strings (bf, 0);\n\t_print_strings (r, l, mode, va);\n\tif (new_bf) {\n\t\tr_buf_free (bf->buf);\n\t\tbf->buf = NULL;\n\t\tbf->id = -1;\n\t\tr_bin_file_free (bf);\n\t}\n\treturn true;\n}\n\nstatic bool bin_strings(RCore *r, int mode, int va) {\n\tRList *list;\n\tRBinFile *binfile = r_core_bin_cur (r);\n\tRBinPlugin *plugin = r_bin_file_cur_plugin (binfile);\n\tint rawstr = r_config_get_i (r->config, \"bin.rawstr\");\n\tif (!binfile) {\n\t\treturn false;\n\t}\n\tif (!r_config_get_i (r->config, \"bin.strings\")) {\n\t\treturn false;\n\t}\n\tif (!plugin) {\n\t\treturn false;\n\t}\n\tif (plugin->info && plugin->name) {\n\t\tif (strcmp (plugin->name, \"any\") == 0 && !rawstr) {\n\t\t\tif (IS_MODE_JSON (mode)) {\n\t\t\t\tr_cons_print(\"[]\");\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tif (!(list = r_bin_get_strings (r->bin))) {\n\t\treturn false;\n\t}\n\t_print_strings (r, list, mode, va);\n\treturn true;\n}\n\nstatic const char* get_compile_time(Sdb *binFileSdb) {\n\tSdb *info_ns = sdb_ns (binFileSdb, \"info\", false);\n\tconst char *timeDateStamp_string = sdb_const_get (info_ns,\n\t\t\"image_file_header.TimeDateStamp_string\", 0);\n\treturn timeDateStamp_string;\n}\n\nstatic int is_executable(RBinObject *obj) {\n\tRListIter *it;\n\tRBinSection* sec;\n\tif (obj) {\n\t\tif (obj->info && obj->info->arch) {\n\t\t\treturn true;\n\t\t}\n\t\tr_list_foreach (obj->sections, it, sec) {\n\t\t\tif (R_BIN_SCN_EXECUTABLE & sec->srwx) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nstatic void sdb_concat_by_path(Sdb *s, const char *path) {\n\tSdb *db = sdb_new (0, path, 0);\n\tsdb_merge (s, db);\n\tsdb_close (db);\n\tsdb_free (db);\n}\n\nR_API void r_core_anal_type_init(RCore *core) {\n\tSdb *types = NULL;\n\tconst char *anal_arch = NULL, *os = NULL;\n\tchar *dbpath;\n\tif (!core || !core->anal) {\n\t\treturn;\n\t}\n\tconst char *dir_prefix = r_config_get (core->config, \"dir.prefix\");\n\tint bits = core->assembler->bits;\n\ttypes = core->anal->sdb_types;\n \t// make sure they are empty this is initializing\n\tsdb_reset (types);\n\tanal_arch = r_config_get (core->config, \"anal.arch\");\n\tos = r_config_get (core->config, \"asm.os\");\n\t// spaguetti ahead\n\tdbpath = sdb_fmt (\"%s/\"DBSPATH\"/types.sdb\", dir_prefix);\n\tif (r_file_exists (dbpath)) {\n\t\tsdb_concat_by_path (types, dbpath);\n\t}\n\tdbpath = sdb_fmt (\"%s/\"DBSPATH\"/types-%s.sdb\", dir_prefix, anal_arch);\n\tif (r_file_exists (dbpath)) {\n\t\tsdb_concat_by_path (types, dbpath);\n\t}\n\tdbpath = sdb_fmt (\"%s/\"DBSPATH\"/types-%s.sdb\", dir_prefix, os);\n\tif (r_file_exists (dbpath)) {\n\t\tsdb_concat_by_path (types, dbpath);\n\t}\n\tdbpath = sdb_fmt (\"%s/\"DBSPATH\"/types-%d.sdb\", dir_prefix, bits);\n\tif (r_file_exists (dbpath)) {\n\t\tsdb_concat_by_path (types, dbpath);\n\t}\n\tdbpath = sdb_fmt (\"%s/\"DBSPATH\"/types-%s-%d.sdb\", dir_prefix, os, bits);\n\tif (r_file_exists (dbpath)) {\n\t\tsdb_concat_by_path (types, dbpath);\n\t}\n\tdbpath = sdb_fmt (\"%s/\"DBSPATH\"/types-%s-%d.sdb\", dir_prefix, anal_arch, bits);\n\tif (r_file_exists (dbpath)) {\n\t\tsdb_concat_by_path (types, dbpath);\n\t}\n\tdbpath = sdb_fmt (\"%s/\"DBSPATH\"/types-%s-%s.sdb\", dir_prefix, anal_arch, os);\n\tif (r_file_exists (dbpath)) {\n\t\tsdb_concat_by_path (types, dbpath);\n\t}\n\tdbpath = sdb_fmt (\"%s/\"DBSPATH\"/types-%s-%s-%d.sdb\", dir_prefix, anal_arch, os, bits);\n\tif (r_file_exists (dbpath)) {\n\t\tsdb_concat_by_path (types, dbpath);\n\t}\n}\n\nstatic int save_ptr(void *p, const char *k, const char *v) {\n\tSdb *sdbs[2];\n\tsdbs[0] = ((Sdb**) p)[0];\n\tsdbs[1] = ((Sdb**) p)[1];\n\tif (!strncmp (v, \"cc\", strlen (\"cc\") + 1)) {\n\t\tconst char *x = sdb_const_get (sdbs[1], sdb_fmt (\"cc.%s.name\", k), 0);\n\t\tchar *tmp = sdb_fmt (\"%p\", x);\n\t\tsdb_set (sdbs[0], tmp, x, 0);\n\t}\n\treturn 1;\n}\n\nR_API void r_core_anal_cc_init(RCore *core) {\n\tSdb *sdbs[2] = {\n\t\tsdb_new0 (),\n\t\tcore->anal->sdb_cc\n\t};\n\tconst char *dir_prefix = r_config_get (core->config, \"dir.prefix\");\n\t//save pointers and values stored inside them\n\t//to recover from freeing heeps\n\tconst char *defaultcc = sdb_const_get (sdbs[1], \"default.cc\", 0);\n\tsdb_set (sdbs[0], sdb_fmt (\"0x%08\"PFMT64x, r_num_get (NULL, defaultcc)), defaultcc, 0);\n\tsdb_foreach (core->anal->sdb_cc, save_ptr, sdbs);\n\tsdb_reset ( core->anal->sdb_cc);\n\tconst char *anal_arch = r_config_get (core->config, \"anal.arch\");\n\n\tint bits = core->anal->bits;\n\tif (bits == 16 && !strcmp (anal_arch, \"arm\")) {\n\t\tbits = 32;\n\t}\n\n\tchar *dbpath = sdb_fmt (\"%s/\"DBSPATH\"/cc-%s-%d.sdb\", dir_prefix, anal_arch, bits);\n\tif (r_file_exists (dbpath)) {\n\t\tsdb_concat_by_path (core->anal->sdb_cc, dbpath);\n\t}\n\t//restore all freed CC or replace with new default cc\n\tRListIter *it;\n\tRAnalFunction *fcn;\n\tr_list_foreach (core->anal->fcns, it, fcn) {\n\t\tchar *ptr = sdb_fmt (\"%p\", fcn->cc);\n\t\tconst char *cc = sdb_const_get (sdbs[0], ptr, 0);\n\t\tif (cc) {\n\t\t\tfcn->cc = r_anal_cc_to_constant (core->anal, (char *)cc);\n\t\t}\n\t\tif (!fcn->cc) {\n\t\t\tfcn->cc = r_anal_cc_default (core->anal);\n\t\t}\n\t\tfcn->cc = r_str_const (fcn->cc);\n\t}\n\tsdb_close (sdbs[0]);\n\tsdb_free (sdbs[0]);\n}\n#undef DBSPATH\n\nstatic int bin_info(RCore *r, int mode) {\n\tint i, j, v;\n\tchar str[R_FLAG_NAME_SIZE];\n\tRBinInfo *info = r_bin_get_info (r->bin);\n\tRBinFile *binfile = r_core_bin_cur (r);\n\tRBinObject *obj = r_bin_cur_object (r->bin);\n\tconst char *compiled = NULL;\n\tbool havecode;\n\n\tif (!binfile || !info || !obj) {\n\t\tif (mode & R_CORE_BIN_JSON) {\n\t\t\tr_cons_printf (\"{}\");\n\t\t}\n\t\treturn false;\n\t}\n\thavecode = is_executable (obj) | (obj->entries != NULL);\n\tcompiled = get_compile_time (binfile->sdb);\n\n\tif (IS_MODE_SET (mode)) {\n\t\tr_config_set (r->config, \"file.type\", info->rclass);\n\t\tr_config_set (r->config, \"cfg.bigendian\",\n\t\t\t      info->big_endian ? \"true\" : \"false\");\n\t\tif (info->rclass && !strcmp (info->rclass, \"fs\")) {\n\t\t\t// r_config_set (r->config, \"asm.arch\", info->arch);\n\t\t\t// r_core_seek (r, 0, 1);\n\t\t\t// eprintf (\"m /root %s 0\", info->arch);\n\t//\t\tr_core_cmdf (r, \"m /root hfs @ 0\", info->arch);\n\t\t} else {\n\t\t\tif (info->lang) {\n\t\t\t\tr_config_set (r->config, \"bin.lang\", info->lang);\n\t\t\t}\n\t\t\tr_config_set (r->config, \"asm.os\", info->os);\n\t\t\tif (info->rclass && !strcmp (info->rclass, \"pe\")) {\n\t\t\t\tr_config_set (r->config, \"anal.cpp.abi\", \"msvc\");\n\t\t\t} else {\n\t\t\t\tr_config_set (r->config, \"anal.cpp.abi\", \"itanium\");\n\t\t\t}\n\t\t\tr_config_set (r->config, \"asm.arch\", info->arch);\n\t\t\tif (info->cpu && *info->cpu) {\n\t\t\t\tr_config_set (r->config, \"asm.cpu\", info->cpu);\n\t\t\t}\n\t\t\tr_config_set (r->config, \"anal.arch\", info->arch);\n\t\t\tsnprintf (str, R_FLAG_NAME_SIZE, \"%i\", info->bits);\n\t\t\tr_config_set (r->config, \"asm.bits\", str);\n\t\t\tr_config_set (r->config, \"asm.dwarf\",\n\t\t\t\t(R_BIN_DBG_STRIPPED & info->dbg_info) ? \"false\" : \"true\");\n\t\t\tv = r_anal_archinfo (r->anal, R_ANAL_ARCHINFO_ALIGN);\n\t\t\tif (v != -1) r_config_set_i (r->config, \"asm.pcalign\", v);\n\t\t}\n\t} else if (IS_MODE_SIMPLE (mode)) {\n\t\tr_cons_printf (\"arch %s\\n\", info->arch);\n\t\tif (info->cpu && *info->cpu) {\n\t\t\tr_cons_printf (\"cpu %s\\n\", info->cpu);\n\t\t}\n\t\tr_cons_printf (\"bits %d\\n\", info->bits);\n\t\tr_cons_printf (\"os %s\\n\", info->os);\n\t\tr_cons_printf (\"endian %s\\n\", info->big_endian? \"big\": \"little\");\n\t\tv = r_anal_archinfo (r->anal, R_ANAL_ARCHINFO_MIN_OP_SIZE);\n\t\tif (v != -1) {\n\t\t\tr_cons_printf (\"minopsz %d\\n\", v);\n\t\t}\n\t\tv = r_anal_archinfo (r->anal, R_ANAL_ARCHINFO_MAX_OP_SIZE);\n\t\tif (v != -1) {\n\t\t\tr_cons_printf (\"maxopsz %d\\n\", v);\n\t\t}\n\t\tv = r_anal_archinfo (r->anal, R_ANAL_ARCHINFO_ALIGN);\n\t\tif (v != -1) {\n\t\t\tr_cons_printf (\"pcalign %d\\n\", v);\n\t\t}\n\t} else if (IS_MODE_RAD (mode)) {\n\t\tif (info->type && !strcmp (info->type, \"fs\")) {\n\t\t\tr_cons_printf (\"e file.type=fs\\n\");\n\t\t\tr_cons_printf (\"m /root %s 0\\n\", info->arch);\n\t\t} else {\n\t\t\tr_cons_printf (\"e cfg.bigendian=%s\\n\"\n\t\t\t\t\"e asm.bits=%i\\n\"\n\t\t\t\t\"e asm.dwarf=%s\\n\",\n\t\t\t\tr_str_bool (info->big_endian),\n\t\t\t\tinfo->bits,\n\t\t\t\tr_str_bool (R_BIN_DBG_STRIPPED &info->dbg_info));\n\t\t\tif (info->lang && *info->lang) {\n\t\t\t\tr_cons_printf (\"e bin.lang=%s\\n\", info->lang);\n\t\t\t}\n\t\t\tif (info->rclass && *info->rclass) {\n\t\t\t\tr_cons_printf (\"e file.type=%s\\n\",\n\t\t\t\t\tinfo->rclass);\n\t\t\t}\n\t\t\tif (info->os) {\n\t\t\t\tr_cons_printf (\"e asm.os=%s\\n\", info->os);\n\t\t\t}\n\t\t\tif (info->arch) {\n\t\t\t\tr_cons_printf (\"e asm.arch=%s\\n\", info->arch);\n\t\t\t}\n\t\t\tif (info->cpu && *info->cpu) {\n\t\t\t\tr_cons_printf (\"e asm.cpu=%s\\n\", info->cpu);\n\t\t\t}\n\t\t\tv = r_anal_archinfo (r->anal, R_ANAL_ARCHINFO_ALIGN);\n\t\t\tif (v != -1) r_cons_printf (\"e asm.pcalign=%d\\n\", v);\n\t\t}\n\t} else {\n\t\t// XXX: if type is 'fs' show something different?\n\t\tchar *tmp_buf;\n\t\tif (IS_MODE_JSON (mode)) {\n\t\t\tr_cons_printf (\"{\");\n\t\t}\n\t\tpair_str (\"arch\", info->arch, mode, false);\n\t\tif (info->cpu && *info->cpu) {\n\t\t\tpair_str (\"cpu\", info->cpu, mode, false);\n\t\t}\n\t\tpair_ut64 (\"binsz\", r_bin_get_size (r->bin), mode, false);\n\t\tpair_str (\"bintype\", info->rclass, mode, false);\n\t\tpair_int (\"bits\", info->bits, mode, false);\n\t\tpair_bool (\"canary\", info->has_canary, mode, false);\n\t\tpair_str (\"class\", info->bclass, mode, false);\n\t\tif (info->actual_checksum) {\n\t\t\t/* computed checksum */\n\t\t\tpair_str (\"cmp.csum\", info->actual_checksum, mode, false);\n\t\t}\n\t\tpair_str (\"compiled\", compiled, mode, false);\n\t\tpair_bool (\"crypto\", info->has_crypto, mode, false);\n\t\tpair_str (\"dbg_file\", info->debug_file_name, mode, false);\n\t\tpair_str (\"endian\", info->big_endian ? \"big\" : \"little\", mode, false);\n\t\tif (info->rclass && !strcmp (info->rclass, \"mdmp\")) {\n\t\t\ttmp_buf = sdb_get (binfile->sdb, \"mdmp.flags\", 0);\n\t\t\tif (tmp_buf) {\n\t\t\t\tpair_str (\"flags\", tmp_buf, mode, false);\n\t\t\t\tfree (tmp_buf);\n\t\t\t}\n\t\t}\n\t\tpair_bool (\"havecode\", havecode, mode, false);\n\t\tif (info->claimed_checksum) {\n\t\t\t/* checksum specified in header */\n\t\t\tpair_str (\"hdr.csum\", info->claimed_checksum, mode, false);\n\t\t}\n\t\tpair_str (\"guid\", info->guid, mode, false);\n\t\tpair_str (\"intrp\", info->intrp, mode, false);\n\t\tpair_str (\"lang\", info->lang, mode, false);\n\t\tpair_bool (\"linenum\", R_BIN_DBG_LINENUMS & info->dbg_info, mode, false);\n\t\tpair_bool (\"lsyms\", R_BIN_DBG_SYMS & info->dbg_info, mode, false);\n\t\tpair_str (\"machine\", info->machine, mode, false);\n\t\tv = r_anal_archinfo (r->anal, R_ANAL_ARCHINFO_MAX_OP_SIZE);\n\t\tif (v != -1) {\n\t\t\tpair_int (\"maxopsz\", v, mode, false);\n\t\t}\n\t\tv = r_anal_archinfo (r->anal, R_ANAL_ARCHINFO_MIN_OP_SIZE);\n\t\tif (v != -1) {\n\t\t\tpair_int (\"minopsz\", v, mode, false);\n\t\t}\n\t\tpair_bool (\"nx\", info->has_nx, mode, false);\n\t\tpair_str (\"os\", info->os, mode, false);\n\t\tif (info->rclass && !strcmp (info->rclass, \"pe\")) {\n\t\t\tpair_bool (\"overlay\", info->pe_overlay, mode, false);\n\t\t}\n\t\tv = r_anal_archinfo (r->anal, R_ANAL_ARCHINFO_ALIGN);\n\t\tif (v != -1) {\n\t\t\tpair_int (\"pcalign\", v, mode, false);\n\t\t}\n\t\tpair_bool (\"pic\", info->has_pi, mode, false);\n\t\tpair_bool (\"relocs\", R_BIN_DBG_RELOCS & info->dbg_info, mode, false);\n\t\ttmp_buf = sdb_get (obj->kv, \"elf.relro\", 0);\n\t\tif (tmp_buf) {\n\t\t\tpair_str (\"relro\", tmp_buf, mode, false);\n\t\t\tfree (tmp_buf);\n\t\t}\n\t\tpair_str (\"rpath\", info->rpath, mode, false);\n\t\tif (info->rclass && !strcmp (info->rclass, \"pe\")) {\n\t\t\t//this should be moved if added to mach0 (or others)\n\t\t\tpair_bool (\"signed\", info->signature, mode, false);\n\t\t}\n\t\tpair_bool (\"static\", r_bin_is_static (r->bin), mode, false);\n\t\tif (info->rclass && !strcmp (info->rclass, \"mdmp\")) {\n\t\t\tv = sdb_num_get (binfile->sdb, \"mdmp.streams\", 0);\n\t\t\tif (v != -1) {\n\t\t\t\tpair_int (\"streams\", v, mode, false);\n\t\t\t}\n\t\t}\n\t\tpair_bool (\"stripped\", R_BIN_DBG_STRIPPED & info->dbg_info, mode, false);\n\t\tpair_str (\"subsys\", info->subsystem, mode, false);\n\t\tpair_bool (\"va\", info->has_va, mode, true);\n\t\tif (IS_MODE_JSON (mode)) {\n\t\t\tr_cons_printf (\",\\\"checksums\\\":{\");\n\t\t\tfor (i = 0; info->sum[i].type; i++) {\n\t\t\t\tRBinHash *h = &info->sum[i];\n\t\t\t\tut64 hash = r_hash_name_to_bits (h->type);\n\t\t\t\tRHash *rh = r_hash_new (true, hash);\n\t\t\t\tint len = r_hash_calculate (rh, hash, (const ut8*)\n\t\t\t\t\t\tbinfile->buf->buf+h->from, h->to);\n\t\t\t\tif (len < 1) {\n\t\t\t\t\teprintf (\"Invaild checksum length\\n\");\n\t\t\t\t}\n\t\t\t\tr_hash_free (rh);\n\t\t\t\tr_cons_printf (\"%s\\\"%s\\\":{\\\"hex\\\":\\\"\", i?\",\": \"\", h->type);\n\t\t\t\t// r_cons_printf (\"%s\\t%d-%dc\\t\", h->type, h->from, h->to+h->from);\n\t\t\t\tfor (j = 0; j < h->len; j++) {\n\t\t\t\t\tr_cons_printf (\"%02x\", h->buf[j]);\n\t\t\t\t}\n\t\t\t\tr_cons_printf (\"\\\"}\");\n\t\t\t}\n\t\t\tr_cons_printf (\"}\");\n\t\t} else {\n\t\t\tfor (i = 0; info->sum[i].type; i++) {\n\t\t\t\tRBinHash *h = &info->sum[i];\n\t\t\t\tut64 hash = r_hash_name_to_bits (h->type);\n\t\t\t\tRHash *rh = r_hash_new (true, hash);\n\t\t\t\tint len = r_hash_calculate (rh, hash, (const ut8*)\n\t\t\t\t\t\tbinfile->buf->buf+h->from, h->to);\n\t\t\t\tif (len < 1) {\n\t\t\t\t\teprintf (\"Invaild wtf\\n\");\n\t\t\t\t}\n\t\t\t\tr_hash_free (rh);\n\t\t\t\tr_cons_printf (\"%s  %d-%dc  \", h->type, h->from, h->to+h->from);\n\t\t\t\tfor (j = 0; j < h->len; j++) {\n\t\t\t\t\tr_cons_printf (\"%02x\", h->buf[j]);\n\t\t\t\t}\n\t\t\t\tr_cons_newline ();\n\t\t\t}\n\t\t}\n\t\tif (IS_MODE_JSON (mode)) r_cons_printf (\"}\");\n\t}\n\tr_core_anal_type_init (r);\n\tr_core_anal_cc_init (r);\n\treturn true;\n}\n\nstatic int bin_dwarf(RCore *core, int mode) {\n\tRBinDwarfRow *row;\n\tRListIter *iter;\n\tRList *list = NULL;\n\tif (!r_config_get_i (core->config, \"bin.dbginfo\")) {\n\t\treturn false;\n\t}\n\tRBinFile *binfile = r_core_bin_cur (core);\n\tRBinPlugin * plugin = r_bin_file_cur_plugin (binfile);\n\tif (!binfile) {\n\t\treturn false;\n\t}\n\tif (plugin && plugin->lines) {\n\t\tlist = plugin->lines (binfile);\n\t} else if (core->bin) {\n\t\t// TODO: complete and speed-up support for dwarf\n\t\tRBinDwarfDebugAbbrev *da = NULL;\n\t\tda = r_bin_dwarf_parse_abbrev (core->bin, mode);\n\t\tr_bin_dwarf_parse_info (da, core->bin, mode);\n\t\tr_bin_dwarf_parse_aranges (core->bin, mode);\n\t\tlist = r_bin_dwarf_parse_line (core->bin, mode);\n\t\tr_bin_dwarf_free_debug_abbrev (da);\n\t\tfree (da);\n\t}\n\tif (!list) {\n\t\treturn false;\n\t}\n\n\tr_cons_break_push (NULL, NULL);\n\t/* cache file:line contents */\n\tconst char *lastFile = NULL;\n\tint *lastFileLines = NULL;\n\tchar *lastFileContents = NULL;\n\tint lastFileLinesCount = 0;\n\n\t/* ugly dupe for speedup */\n\tconst char *lastFile2 = NULL;\n\tint *lastFileLines2 = NULL;\n\tchar *lastFileContents2 = NULL;\n\tint lastFileLinesCount2 = 0;\n\n\tconst char *lf = NULL;\n\tint *lfl = NULL;\n\tchar *lfc = NULL;\n\tint lflc = 0;\n\n\t//TODO we should need to store all this in sdb, or do a filecontentscache in libr/util\n\t//XXX this whole thing has leaks\n\tr_list_foreach (list, iter, row) {\n\t\tif (r_cons_is_breaked ()) {\n\t\t\tbreak;\n\t\t}\n\t\tif (mode) {\n\t\t\t// TODO: use 'Cl' instead of CC\n\t\t\tconst char *path = row->file;\n\t\t\tif (!lastFile || strcmp (path, lastFile)) {\n\t\t\t\tif (lastFile && lastFile2 && !strcmp (path, lastFile2)) {\n\t\t\t\t\tlf = lastFile;\n\t\t\t\t\tlfl = lastFileLines;\n\t\t\t\t\tlfc = lastFileContents;\n\t\t\t\t\tlflc = lastFileLinesCount;\n\t\t\t\t\tlastFile = lastFile2;\n\t\t\t\t\tlastFileLines = lastFileLines2;\n\t\t\t\t\tlastFileContents = lastFileContents2;\n\t\t\t\t\tlastFileLinesCount = lastFileLinesCount2;\n\t\t\t\t\tlastFile2 = lf;\n\t\t\t\t\tlastFileLines2 = lfl;\n\t\t\t\t\tlastFileContents2 = lfc;\n\t\t\t\t\tlastFileLinesCount2 = lflc;\n\t\t\t\t} else {\n\t\t\t\t\tlastFile2 = lastFile;\n\t\t\t\t\tlastFileLines2 = lastFileLines;\n\t\t\t\t\tlastFileContents2 = lastFileContents;\n\t\t\t\t\tlastFileLinesCount2 = lastFileLinesCount;\n\t\t\t\t\tlastFile = path;\n\t\t\t\t\tlastFileContents = r_file_slurp (path, NULL);\n\t\t\t\t\tif (lastFileContents) {\n\t\t\t\t\t\tlastFileLines = r_str_split_lines (lastFileContents, &lastFileLinesCount);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tchar *line = NULL;\n\t\t\t//r_file_slurp_line (path, row->line - 1, 0);\n\t\t\tif (lastFileLines && lastFileContents) {\n\t\t\t\tint nl = row->line - 1;\n\t\t\t\tif (nl >= 0 && nl < lastFileLinesCount) {\n\t\t\t\t\tline = strdup (lastFileContents + lastFileLines[nl]);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tline = NULL;\n\t\t\t}\n\t\t\tif (line) {\n\t\t\t\tr_str_filter (line, strlen (line));\n\t\t\t\tline = r_str_replace (line, \"\\\"\", \"\\\\\\\"\", 1);\n\t\t\t\tline = r_str_replace (line, \"\\\\\\\\\", \"\\\\\", 1);\n\t\t\t}\n\t\t\tbool chopPath = !r_config_get_i (core->config, \"dir.dwarf.abspath\");\n\t\t\tchar *file = strdup (row->file);\n\t\t\tif (chopPath) {\n\t\t\t\tconst char *slash = r_str_lchr (file, '/');\n\t\t\t\tif (slash) {\n\t\t\t\t\tmemmove (file, slash + 1, strlen (slash));\n\t\t\t\t}\n\t\t\t}\n\t\t\t// TODO: implement internal : if ((mode & R_CORE_BIN_SET))\n\t\t\tif ((mode & R_CORE_BIN_SET)) {\n\t\t\t\t// TODO: use CL here.. but its not necessary.. so better not do anything imho\n\t\t\t\t// r_core_cmdf (core, \"CL %s:%d 0x%08\"PFMT64x, file, (int)row->line, row->address);\n#if 0\n\t\t\t\tchar *cmt = r_str_newf (\"%s:%d %s\", file, (int)row->line, line? line: \"\");\n\t\t\t\tr_meta_set_string (core->anal, R_META_TYPE_COMMENT, row->address, cmt);\n\t\t\t\tfree (cmt);\n#endif\n\t\t\t} else {\n\t\t\t\tr_cons_printf (\"CL %s:%d 0x%08\" PFMT64x \"\\n\",\n\t\t\t\t\t       file, (int)row->line,\n\t\t\t\t\t       row->address);\n\t\t\t\tr_cons_printf (\"\\\"CC %s:%d %s\\\"@0x%\" PFMT64x\n\t\t\t\t\t       \"\\n\",\n\t\t\t\t\t       file, row->line,\n\t\t\t\t\t       line ? line : \"\", row->address);\n\t\t\t}\n\t\t\tfree (file);\n\t\t\tfree (line);\n\t\t} else {\n\t\t\tr_cons_printf (\"0x%08\" PFMT64x \"\\t%s\\t%d\\n\",\n\t\t\t\t       row->address, row->file, row->line);\n\t\t}\n\t}\n\tr_cons_break_pop ();\n\tR_FREE (lastFileContents);\n\tR_FREE (lastFileContents2);\n\t// this list is owned by rbin, not us, we shouldnt free it\n\t// r_list_free (list);\n\tfree (lastFileLines);\n\treturn true;\n}\n\nR_API int r_core_pdb_info(RCore *core, const char *file, ut64 baddr, int mode) {\n\tR_PDB pdb = R_EMPTY;\n\n\tpdb.cb_printf = r_cons_printf;\n\tif (!init_pdb_parser (&pdb, file)) {\n\t\treturn false;\n\t}\n\tif (!pdb.pdb_parse (&pdb)) {\n\t\teprintf (\"pdb was not parsed\\n\");\n\t\tpdb.finish_pdb_parse (&pdb);\n\t\treturn false;\n\t}\n\tif (mode == R_CORE_BIN_JSON) {\n\t\tr_cons_printf(\"[\");\n\t}\n\n\tswitch (mode) {\n\tcase R_CORE_BIN_SET:\n\t\tmode = 's';\n\t\tr_core_cmd0 (core, \".iP*\");\n\t\treturn true;\n\tcase R_CORE_BIN_JSON:\n\t\tmode = 'j';\n\t\tbreak;\n\tcase '*':\n\tcase 1:\n\t\tmode = 'r';\n\t\tbreak;\n\tdefault:\n\t\tmode = 'd'; // default\n\t\tbreak;\n\t}\n\n\tpdb.print_types (&pdb, mode);\n\tif (mode == 'j') {\n\t\tr_cons_printf (\",\");\n\t}\n\tpdb.print_gvars (&pdb, baddr, mode);\n\tif (mode == 'j') {\n\t\tr_cons_printf (\"]\");\n\t}\n\tpdb.finish_pdb_parse (&pdb);\n\n\treturn true;\n}\n\nstatic int bin_pdb(RCore *core, int mode) {\n\tut64 baddr = r_bin_get_baddr (core->bin);\n\treturn r_core_pdb_info (core, core->bin->file, baddr, mode);\n}\n\nstatic int bin_main(RCore *r, int mode, int va) {\n\tRBinAddr *binmain = r_bin_get_sym (r->bin, R_BIN_SYM_MAIN);\n\tut64 addr;\n\tif (!binmain) {\n\t\treturn false;\n\t}\n\taddr = va ? r_bin_a2b (r->bin, binmain->vaddr) : binmain->paddr;\n\n\tif (IS_MODE_SET (mode)) {\n\t\tr_flag_space_set (r->flags, \"symbols\");\n\t\tr_flag_set (r->flags, \"main\", addr, r->blocksize);\n\t} else if (IS_MODE_SIMPLE (mode)) {\n\t\tr_cons_printf (\"%\"PFMT64d, addr);\n\t} else if (IS_MODE_RAD (mode)) {\n\t\tr_cons_printf (\"fs symbols\\n\");\n\t\tr_cons_printf (\"f main @ 0x%08\"PFMT64x\"\\n\", addr);\n\t} else if (IS_MODE_JSON (mode)) {\n\t\tr_cons_printf (\"{\\\"vaddr\\\":%\" PFMT64d\n\t\t\t\",\\\"paddr\\\":%\" PFMT64d \"}\", addr, binmain->paddr);\n\t} else {\n\t\tr_cons_printf (\"[Main]\\n\");\n\t\tr_cons_printf (\"vaddr=0x%08\"PFMT64x\" paddr=0x%08\"PFMT64x\"\\n\",\n\t\t\taddr, binmain->paddr);\n\t}\n\treturn true;\n}\n\nstatic int bin_entry(RCore *r, int mode, ut64 laddr, int va, bool inifin) {\n\tchar str[R_FLAG_NAME_SIZE];\n\tRList *entries = r_bin_get_entries (r->bin);\n\tRListIter *iter;\n\tRBinAddr *entry = NULL;\n\tint i = 0;\n\tut64 baddr = r_bin_get_baddr (r->bin);\n\n\tif (IS_MODE_RAD (mode)) {\n\t\tr_cons_printf (\"fs symbols\\n\");\n\t} else if (IS_MODE_JSON (mode)) {\n\t\tr_cons_printf (\"[\");\n\t} else if (IS_MODE_NORMAL (mode)) {\n\t\tif (inifin) {\n\t\t\tr_cons_printf (\"[Constructors]\\n\");\n\t\t} else {\n\t\t\tr_cons_printf (\"[Entrypoints]\\n\");\n\t\t}\n\t}\n\tif (r_list_length (entries) > 1024) {\n\t\teprintf (\"Too many entrypoints (%d)\\n\", r_list_length (entries));\n\t\treturn false;\n\t}\n\n\tr_list_foreach (entries, iter, entry) {\n\t\tut64 paddr = entry->paddr;\n\t\tut64 haddr = UT64_MAX;\n\t\tif (mode != R_CORE_BIN_SET) {\n\t\t\tif (inifin) {\n\t\t\t\tif (entry->type == R_BIN_ENTRY_TYPE_PROGRAM) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (entry->type != R_BIN_ENTRY_TYPE_PROGRAM) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tswitch (entry->type) {\n\t\tcase R_BIN_ENTRY_TYPE_INIT:\n\t\tcase R_BIN_ENTRY_TYPE_FINI:\n\t\tcase R_BIN_ENTRY_TYPE_PREINIT:\n\t\t\tif (r->io->va && entry->paddr == entry->vaddr) {\n\t\t\t\tRIOMap *map = r_io_map_get (r->io, entry->vaddr);\n\t\t\t\tif (map) {\n\t\t\t\t\tpaddr = entry->vaddr - map->itv.addr + map->delta;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (entry->haddr) {\n\t\t\thaddr = entry->haddr;\n\t\t}\n\t\tut64 at = rva (r->bin, paddr, entry->vaddr, va);\n\t\tconst char *type = r_bin_entry_type_string (entry->type);\n\t\tif (!type) {\n\t\t\ttype = \"unknown\";\n\t\t}\n\t\tif (IS_MODE_SET (mode)) {\n\t\t\tr_flag_space_set (r->flags, \"symbols\");\n\t\t\tif (entry->type == R_BIN_ENTRY_TYPE_INIT) {\n\t\t\t\tsnprintf (str, R_FLAG_NAME_SIZE, \"entry%i.init\", i);\n\t\t\t} else if (entry->type == R_BIN_ENTRY_TYPE_FINI) {\n\t\t\t\tsnprintf (str, R_FLAG_NAME_SIZE, \"entry%i.fini\", i);\n\t\t\t} else if (entry->type == R_BIN_ENTRY_TYPE_PREINIT) {\n\t\t\t\tsnprintf (str, R_FLAG_NAME_SIZE, \"entry%i.preinit\", i);\n\t\t\t} else {\n\t\t\t\tsnprintf (str, R_FLAG_NAME_SIZE, \"entry%i\", i);\n\t\t\t}\n\t\t\tr_flag_set (r->flags, str, at, 1);\n\t\t} else if (IS_MODE_SIMPLE (mode)) {\n\t\t\tr_cons_printf (\"0x%08\"PFMT64x\"\\n\", at);\n\t\t} else if (IS_MODE_JSON (mode)) {\n\t\t\tr_cons_printf (\"%s{\\\"vaddr\\\":%\" PFMT64d \",\"\n\t\t\t\t\"\\\"paddr\\\":%\" PFMT64d \",\"\n\t\t\t\t\"\\\"baddr\\\":%\" PFMT64d \",\"\n\t\t\t\t\"\\\"laddr\\\":%\" PFMT64d \",\"\n\t\t\t\t\"\\\"haddr\\\":%\" PFMT64d \",\"\n\t\t\t\t\"\\\"type\\\":\\\"%s\\\"}\",\n\t\t\t\titer->p ? \",\" : \"\", at, paddr, baddr, laddr, haddr, type);\n\t\t} else if (IS_MODE_RAD (mode)) {\n\t\t\tchar *name = NULL;\n\t\t\tif (entry->type == R_BIN_ENTRY_TYPE_INIT) {\n\t\t\t\tname = r_str_newf (\"entry%i.init\", i);\n\t\t\t} else if (entry->type == R_BIN_ENTRY_TYPE_FINI) {\n\t\t\t\tname = r_str_newf (\"entry%i.fini\", i);\n\t\t\t} else if (entry->type == R_BIN_ENTRY_TYPE_PREINIT) {\n\t\t\t\tname = r_str_newf (\"entry%i.preinit\", i);\n\t\t\t} else {\n\t\t\t\tname = r_str_newf (\"entry%i\", i);\n\t\t\t}\n\t\t\tr_cons_printf (\"f %s 1 @ 0x%08\"PFMT64x\"\\n\", name, at);\n\t\t\tr_cons_printf (\"f %s_haddr 1 @ 0x%08\"PFMT64x\"\\n\", name, haddr);\n\t\t\tr_cons_printf (\"s %s\\n\", name);\n\t\t\tfree (name);\n\t\t} else {\n\t\t\tr_cons_printf (\n\t\t\t\t \"vaddr=0x%08\"PFMT64x\n\t\t\t\t\" paddr=0x%08\"PFMT64x\n\t\t\t\t\" baddr=0x%08\"PFMT64x\n\t\t\t\t\" laddr=0x%08\"PFMT64x,\n\t\t\t\tat, paddr, baddr, laddr);\n\t\t\tif (haddr == UT64_MAX) {\n\t\t\t\tr_cons_printf (\n\t\t\t\t\t\" haddr=%\"PFMT64d\n\t\t\t\t\t\" type=%s\\n\",\n\t\t\t\t\thaddr, type);\n\t\t\t} else {\n\t\t\t\tr_cons_printf (\n\t\t\t\t\t\" haddr=0x%08\"PFMT64x\n\t\t\t\t\t\" type=%s\\n\",\n\t\t\t\t\thaddr, type);\n\t\t\t}\n\t\t}\n\t\ti++;\n\t}\n\tif (IS_MODE_SET (mode)) {\n\t\tif (entry) {\n\t\t\tut64 at = rva (r->bin, entry->paddr, entry->vaddr, va);\n\t\t\tr_core_seek (r, at, 0);\n\t\t}\n\t} else if (IS_MODE_JSON (mode)) {\n\t\tr_cons_printf (\"]\");\n\t\tr_cons_newline ();\n\t} else if (IS_MODE_NORMAL (mode)) {\n\t\tr_cons_printf (\"\\n%i entrypoints\\n\", i);\n\t}\n\treturn true;\n}\n\nstatic const char *bin_reloc_type_name(RBinReloc *reloc) {\n#define CASE(T) case R_BIN_RELOC_ ## T: return reloc->additive ? \"ADD_\" #T : \"SET_\" #T\n\tswitch (reloc->type) {\n\t\tCASE(8);\n\t\tCASE(16);\n\t\tCASE(32);\n\t\tCASE(64);\n\t}\n\treturn \"UNKNOWN\";\n#undef CASE\n}\n\nstatic ut8 bin_reloc_size(RBinReloc *reloc) {\n#define CASE(T) case R_BIN_RELOC_ ## T: return T / 8\n\tswitch (reloc->type) {\n\t\tCASE(8);\n\t\tCASE(16);\n\t\tCASE(32);\n\t\tCASE(64);\n\t}\n\treturn 0;\n#undef CASE\n}\n\nstatic char *resolveModuleOrdinal(Sdb *sdb, const char *module, int ordinal) {\n\tSdb *db = sdb;\n\tchar *foo = sdb_get (db, sdb_fmt (\"%d\", ordinal), 0);\n\treturn (foo && *foo) ? foo : NULL;\n}\n\nstatic char *get_reloc_name(RBinReloc *reloc, ut64 addr) {\n\tchar *reloc_name = NULL;\n\tif (reloc->import && reloc->import->name) {\n\t\treloc_name = sdb_fmt (\"reloc.%s_%d\", reloc->import->name,\n\t\t\t\t      (int)(addr & 0xff));\n\t\tif (!reloc_name) {\n\t\t\treturn NULL;\n\t\t}\n\t\tr_str_replace_char (reloc_name, '$', '_');\n\t} else if (reloc->symbol && reloc->symbol->name) {\n\t\treloc_name = sdb_fmt (\"reloc.%s_%d\", reloc->symbol->name, (int)(addr & 0xff));\n\t\tif (!reloc_name) {\n\t\t\treturn NULL;\n\t\t}\n\t\tr_str_replace_char (reloc_name, '$', '_');\n\t} else if (reloc->is_ifunc) {\n\t\t// addend is the function pointer for the resolving ifunc\n\t\treloc_name = sdb_fmt (\"reloc.ifunc_%\"PFMT64x, reloc->addend);\n\t} else {\n\t\t// TODO(eddyb) implement constant relocs.\n\t}\n\treturn reloc_name;\n}\n\nstatic void set_bin_relocs(RCore *r, RBinReloc *reloc, ut64 addr, Sdb **db, char **sdb_module) {\n\tint bin_demangle = r_config_get_i (r->config, \"bin.demangle\");\n\tconst char *lang = r_config_get (r->config, \"bin.lang\");\n\tchar *reloc_name, *demname = NULL;\n\tbool is_pe = true;\n\tint is_sandbox = r_sandbox_enable (0);\n\n\tif (reloc->import && reloc->import->name[0]) {\n\t\tchar str[R_FLAG_NAME_SIZE];\n\t\tRFlagItem *fi;\n\n\t\tif (is_pe && !is_sandbox && strstr (reloc->import->name, \"Ordinal\")) {\n\t\t\tconst char *TOKEN = \".dll_Ordinal_\";\n\t\t\tchar *module = strdup (reloc->import->name);\n\t\t\tchar *import = strstr (module, TOKEN);\n\n\t\t\tr_str_case (module, false);\n\t\t\tif (import) {\n\t\t\t\tchar *filename = NULL;\n\t\t\t\tint ordinal;\n\t\t\t\t*import = 0;\n\t\t\t\timport += strlen (TOKEN);\n\t\t\t\tordinal = atoi (import);\n\t\t\t\tif (!*sdb_module || strcmp (module, *sdb_module)) {\n\t\t\t\t\tsdb_free (*db);\n\t\t\t\t\t*db = NULL;\n\t\t\t\t\tfree (*sdb_module);\n\t\t\t\t\t*sdb_module = strdup (module);\n\t\t\t\t\t/* always lowercase */\n\t\t\t\t\tfilename = sdb_fmt (\"%s.sdb\", module);\n\t\t\t\t\tr_str_case (filename, false);\n\t\t\t\t\tif (r_file_exists (filename)) {\n\t\t\t\t\t\t*db = sdb_new (NULL, filename, 0);\n\t\t\t\t\t} else {\n\t\t\t\t\t// XXX. we have dir.prefix, windows shouldnt work different\n\t\t\t\t\t\tfilename = sdb_fmt (\"%s/share/radare2/\" R2_VERSION\"/format/dll/%s.sdb\", r_config_get (r->config, \"dir.prefix\"), module);\n\t\t\t\t\t\tif (r_file_exists (filename)) {\n\t\t\t\t\t\t\t*db = sdb_new (NULL, filename, 0);\n#if __WINDOWS__\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tchar invoke_dir[MAX_PATH];\n\t\t\t\t\t\t\tif (r_sys_get_src_dir_w32 (invoke_dir)) {\n\t\t\t\t\t\t\t\tfilename = sdb_fmt (\"%s/share/radare2/\"R2_VERSION \"/format/dll/%s.sdb\", invoke_dir, module);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tfilename = sdb_fmt (\"share/radare2/\"R2_VERSION\"/format/dll/%s.sdb\", module);\n\t\t\t\t\t\t\t}\n#else\n\t\t\t\t\t\t\tfilename = sdb_fmt (\"%s/share/radare2/\" R2_VERSION\"/format/dll/%s.sdb\", r_config_get (r->config, \"dir.prefix\"), module);\n\t\t\t\t\t\t\tif (r_file_exists (filename)) {\n\t\t\t\t\t\t\t\t*db = sdb_new (NULL, filename, 0);\n\t\t\t\t\t\t\t}\n#endif\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (*db) {\n\t\t\t\t\t// ordinal-1 because we enumerate starting at 0\n\t\t\t\t\tchar *symname = resolveModuleOrdinal (*db, module, ordinal - 1);  // uses sdb_get\n\t\t\t\t\tif (symname) {\n\t\t\t\t\t\tif (r->bin->prefix) {\n\t\t\t\t\t\t\treloc->import->name = r_str_newf\n\t\t\t\t\t\t\t\t(\"%s.%s.%s\", r->bin->prefix, module, symname);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treloc->import->name = r_str_newf\n\t\t\t\t\t\t\t\t(\"%s.%s\", module, symname);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tR_FREE (symname);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfree (module);\n\t\t\tr_anal_hint_set_size (r->anal, reloc->vaddr, 4);\n\t\t\tr_meta_add (r->anal, R_META_TYPE_DATA, reloc->vaddr, reloc->vaddr+4, NULL);\n\t\t}\n\t\treloc_name = reloc->import->name;\n\t\tif (r->bin->prefix) {\n\t\t\tsnprintf (str, R_FLAG_NAME_SIZE, \"%s.reloc.%s\", r->bin->prefix, reloc_name);\n\t\t} else {\n\t\t\tsnprintf (str, R_FLAG_NAME_SIZE, \"reloc.%s\", reloc_name);\n\t\t}\n\t\tif (bin_demangle) {\n\t\t\tdemname = r_bin_demangle (r->bin->cur, lang, str, addr);\n\t\t}\n\t\tr_name_filter (str, 0);\n\t\tfi = r_flag_set (r->flags, str, addr, bin_reloc_size (reloc));\n\t\tif (demname) {\n\t\t\tchar *realname;\n\t\t\tif (r->bin->prefix) {\n\t\t\t\trealname = sdb_fmt (\"%s.reloc.%s\", r->bin->prefix, demname);\n\t\t\t} else {\n\t\t\t\trealname = sdb_fmt (\"reloc.%s\", demname);\n\t\t\t}\n\t\t\tr_flag_item_set_realname (fi, realname);\n\t\t}\n\t} else {\n\t\tchar *reloc_name = get_reloc_name (reloc, addr);\n\t\tr_flag_set (r->flags, reloc_name, addr, bin_reloc_size (reloc));\n\t}\n}\n\n/* Define new data at relocation address if it's not in an executable section */\nstatic void add_metadata(RCore *r, RBinReloc *reloc, ut64 addr, int mode) {\n\tRBinFile * binfile = r->bin->cur;\n\tRBinObject *binobj = binfile ? binfile->o: NULL;\n\tRBinInfo *info = binobj ? binobj->info: NULL;\n\tRIOSection *section;\n\tint cdsz;\n\n\tcdsz = info? (info->bits == 64? 8: info->bits == 32? 4: info->bits == 16 ? 4: 0): 0;\n\tif (cdsz == 0) {\n\t\treturn;\n\t}\n\n\tsection = r_io_section_vget (r->io, addr);\n\tif (!section || section->flags & R_IO_EXEC) {\n\t\treturn;\n\t}\n\n\tif (IS_MODE_SET(mode)) {\n\t\tr_meta_add (r->anal, R_META_TYPE_DATA, reloc->vaddr, reloc->vaddr + cdsz, NULL);\n\t} else if (IS_MODE_RAD (mode)) {\n\t\tr_cons_printf (\"f Cd %d @ 0x%08\" PFMT64x \"\\n\", cdsz, addr);\n\t}\n}\n\nstatic bool is_section_symbol(RBinSymbol *s) {\n\t/* workaround for some bin plugs (e.g. ELF) */\n\tif (!s || *s->name) {\n\t\treturn false;\n\t}\n\treturn (s->type && !strcmp (s->type, \"SECTION\"));\n}\n\nstatic bool is_section_reloc(RBinReloc *r) {\n\treturn is_section_symbol (r->symbol);\n}\n\nstatic bool is_file_symbol(RBinSymbol *s) {\n\t/* workaround for some bin plugs (e.g. ELF) */\n\treturn (s && s->type && !strcmp (s->type, \"FILE\"));\n}\n\nstatic bool is_file_reloc(RBinReloc *r) {\n\treturn is_file_symbol (r->symbol);\n}\n\nstatic int bin_relocs(RCore *r, int mode, int va) {\n\tbool bin_demangle = r_config_get_i (r->config, \"bin.demangle\");\n\tRList *relocs;\n\tRListIter *iter;\n\tRBinReloc *reloc = NULL;\n\tSdb *db = NULL;\n\tchar *sdb_module = NULL;\n\tint i = 0;\n\n\tva = VA_TRUE; // XXX relocs always vaddr?\n\t//this has been created for reloc object files\n\trelocs = r_bin_patch_relocs (r->bin);\n\tif (!relocs) {\n\t\trelocs = r_bin_get_relocs (r->bin);\n\t}\n\n\tif (IS_MODE_RAD (mode)) {\n\t\tr_cons_println (\"fs relocs\");\n\t} else if (IS_MODE_NORMAL (mode)) {\n\t\tr_cons_println (\"[Relocations]\");\n\t} else if (IS_MODE_JSON (mode)) {\n\t\tr_cons_print (\"[\");\n\t} else if (IS_MODE_SET (mode)) {\n\t\tr_flag_space_set (r->flags, \"relocs\");\n\t}\n\tr_list_foreach (relocs, iter, reloc) {\n\t\tut64 addr = rva (r->bin, reloc->paddr, reloc->vaddr, va);\n\t\tif (IS_MODE_SET (mode) && (is_section_reloc (reloc) || is_file_reloc (reloc))) {\n\t\t\t/*\n\t\t\t * Skip section reloc because they will have their own flag.\n\t\t\t * Skip also file reloc because not useful for now.\n\t\t\t */\n\t\t} else if (IS_MODE_SET (mode)) {\n\t\t\tset_bin_relocs (r, reloc, addr, &db, &sdb_module);\n\t\t\tadd_metadata (r, reloc, addr, mode);\n\t\t} else if (IS_MODE_SIMPLE (mode)) {\n\t\t\tr_cons_printf (\"0x%08\"PFMT64x\"  %s\\n\", addr, reloc->import ? reloc->import->name : \"\");\n\t\t} else if (IS_MODE_RAD (mode)) {\n\t\t\tchar *name = reloc->import\n\t\t\t\t? strdup (reloc->import->name)\n\t\t\t\t: (reloc->symbol ? strdup (reloc->symbol->name) : NULL);\n\t\t\tif (name && bin_demangle) {\n\t\t\t\tchar *mn = r_bin_demangle (r->bin->cur, NULL, name, addr);\n\t\t\t\tif (mn) {\n\t\t\t\t\tfree (name);\n\t\t\t\t\tname = mn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (name) {\n\t\t\t\tr_cons_printf (\"f %s%s%s @ 0x%08\"PFMT64x\"\\n\",\n\t\t\t\t\tr->bin->prefix ? r->bin->prefix : \"reloc.\",\n\t\t\t\t\tr->bin->prefix ? \".\" : \"\", name, addr);\n\t\t\t\tadd_metadata (r, reloc, addr, mode);\n\t\t\t\tfree (name);\n\t\t\t}\n\t\t} else if (IS_MODE_JSON (mode)) {\n\t\t\tif (iter->p) {\n\t\t\t\tr_cons_printf (\",{\\\"name\\\":\");\n\t\t\t} else {\n\t\t\t\tr_cons_printf (\"{\\\"name\\\":\");\n\t\t\t}\n\t\t\t// take care with very long symbol names! do not use sdb_fmt or similar\n\t\t\tif (reloc->import) {\n\t\t\t\tr_cons_printf (\"\\\"%s\\\"\", reloc->import->name);\n\t\t\t} else if (reloc->symbol) {\n\t\t\t\tr_cons_printf (\"\\\"%s\\\"\", reloc->symbol->name);\n\t\t\t} else {\n\t\t\t\tr_cons_printf (\"null\");\n\t\t\t}\n\n\t\t\tr_cons_printf (\",\"\n\t\t\t\t\"\\\"type\\\":\\\"%s\\\",\"\n\t\t\t\t\"\\\"vaddr\\\":%\"PFMT64d\",\"\n\t\t\t\t\"\\\"paddr\\\":%\"PFMT64d\",\"\n\t\t\t\t\"\\\"is_ifunc\\\":%s}\",\n\t\t\t\tbin_reloc_type_name (reloc),\n\t\t\t\treloc->vaddr, reloc->paddr,\n\t\t\t\tr_str_bool (reloc->is_ifunc));\n\t\t} else if (IS_MODE_NORMAL (mode)) {\n\t\t\tchar *name = reloc->import\n\t\t\t\t? strdup (reloc->import->name)\n\t\t\t\t: reloc->symbol\n\t\t\t\t? strdup (reloc->symbol->name)\n\t\t\t\t: strdup (\"null\");\n\t\t\tif (bin_demangle) {\n\t\t\t\tchar *mn = r_bin_demangle (r->bin->cur, NULL, name, addr);\n\t\t\t\tif (mn && *mn) {\n\t\t\t\t\tfree (name);\n\t\t\t\t\tname = mn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tr_cons_printf (\"vaddr=0x%08\"PFMT64x\" paddr=0x%08\"PFMT64x\" type=%s\",\n\t\t\t\taddr, reloc->paddr, bin_reloc_type_name (reloc));\n\t\t\tif (reloc->import && reloc->import->name[0]) {\n\t\t\t\tr_cons_printf (\" %s\", name);\n\t\t\t} else if (reloc->symbol && name && name[0]) {\n\t\t\t\tr_cons_printf (\" %s\", name);\n\t\t\t}\n\t\t\tfree (name);\n\t\t\tif (reloc->addend) {\n\t\t\t\tif (reloc->import && reloc->addend > 0) {\n\t\t\t\t\tr_cons_printf (\" +\");\n\t\t\t\t}\n\t\t\t\tif (reloc->addend < 0) {\n\t\t\t\t\tr_cons_printf (\" - 0x%08\"PFMT64x, -reloc->addend);\n\t\t\t\t} else {\n\t\t\t\t\tr_cons_printf (\" 0x%08\"PFMT64x, reloc->addend);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (reloc->is_ifunc) {\n\t\t\t\tr_cons_print (\" (ifunc)\");\n\t\t\t}\n\t\t\tr_cons_newline ();\n\t\t}\n\t\ti++;\n\t}\n\tif (IS_MODE_JSON (mode)) {\n\t\tr_cons_print (\"]\");\n\t}\n\tif (IS_MODE_NORMAL (mode)) {\n\t\tr_cons_printf (\"\\n%i relocations\\n\", i);\n\t}\n\n\tR_FREE (sdb_module);\n\tsdb_free (db);\n\tdb = NULL;\n\n\treturn relocs != NULL;\n}\n\n#define MYDB 1\n/* this is a hacky workaround that needs proper refactoring in Rbin to use Sdb */\n#if MYDB\nstatic Sdb *mydb = NULL;\nstatic RList *osymbols = NULL;\n\nstatic RBinSymbol *get_symbol(RBin *bin, RList *symbols, const char *name, ut64 addr) {\n\tRBinSymbol *symbol, *res = NULL;\n\tRListIter *iter;\n\tif (mydb && symbols && symbols != osymbols) {\n\t\tsdb_free (mydb);\n\t\tmydb = NULL;\n\t\tosymbols = symbols;\n\t}\n\tif (mydb) {\n\t\tif (name) {\n\t\t\tres = (RBinSymbol*)(void*)(size_t)\n\t\t\t\tsdb_num_get (mydb, sdb_fmt (\"%x\", sdb_hash (name)), NULL);\n\t\t} else {\n\t\t\tres = (RBinSymbol*)(void*)(size_t)\n\t\t\t\tsdb_num_get (mydb, sdb_fmt (\"0x\"PFMT64x, addr), NULL);\n\t\t}\n\t} else {\n\t\tmydb = sdb_new0 ();\n\t\tr_list_foreach (symbols, iter, symbol) {\n\t\t\t/* ${name}=${ptrToSymbol} */\n\t\t\tif (!sdb_num_add (mydb, sdb_fmt (\"%x\", sdb_hash (symbol->name)), (ut64)(size_t)symbol, 0)) {\n\t\t\t//\teprintf (\"DUP (%s)\\n\", symbol->name);\n\t\t\t}\n\t\t\t/* 0x${vaddr}=${ptrToSymbol} */\n\t\t\tif (!sdb_num_add (mydb, sdb_fmt (\"0x\"PFMT64x, symbol->vaddr), (ut64)(size_t)symbol, 0)) {\n\t\t\t//\teprintf (\"DUP (%s)\\n\", symbol->name);\n\t\t\t}\n\t\t\tif (name) {\n\t\t\t\tif (!res && !strcmp (symbol->name, name)) {\n\t\t\t\t\tres = symbol;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (symbol->vaddr == addr) {\n\t\t\t\t\tres = symbol;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tosymbols = symbols;\n\t}\n\treturn res;\n}\n#else\nstatic RList *osymbols = NULL;\nstatic RBinSymbol *get_symbol(RBin *bin, RList *symbols, const char *name, ut64 addr) {\n\tRBinSymbol *symbol;\n\tRListIter *iter;\n\t// XXX this is slow, we should use a hashtable here\n\tr_list_foreach (symbols, iter, symbol) {\n\t\tif (name) {\n\t\t\tif (!strcmp (symbol->name, name))\n\t\t\t\treturn symbol;\n\t\t} else {\n\t\t\tif (symbol->vaddr == addr) {\n\t\t\t\treturn symbol;\n\t\t\t}\n\t\t}\n\t}\n\treturn NULL;\n}\n#endif\n\n/* XXX: This is a hack to get PLT references in rabin2 -i */\n/* imp. is a prefix that can be rewritten by the symbol table */\nstatic ut64 impaddr(RBin *bin, int va, const char *name) {\n\tRList *symbols;\n\n\tif (!name || !*name) {\n\t\treturn false;\n\t}\n\tif (!(symbols = r_bin_get_symbols (bin))) {\n\t\treturn false;\n\t}\n\tchar *impname = r_str_newf (\"imp.%s\", name);\n\tRBinSymbol *s = get_symbol (bin, symbols, impname, 0LL);\n\t// maybe ut64_MAX to indicate import not found?\n\tut64 addr = s? (va? r_bin_get_vaddr (bin, s->paddr, s->vaddr): s->paddr): 0LL;\n\tfree (impname);\n\treturn addr;\n}\n\nstatic int bin_imports(RCore *r, int mode, int va, const char *name) {\n\tRBinInfo *info = r_bin_get_info (r->bin);\n\tint bin_demangle = r_config_get_i (r->config, \"bin.demangle\");\n\tRBinImport *import;\n\tRListIter *iter;\n\tbool lit = info ? info->has_lit: false;\n\tchar *str;\n\tint i = 0;\n\n\tRList *imports = r_bin_get_imports (r->bin);\n\tint cdsz = info? (info->bits == 64? 8: info->bits == 32? 4: info->bits == 16 ? 4: 0): 0;\n\tif (IS_MODE_JSON (mode)) {\n\t\tr_cons_print (\"[\");\n\t} else if (IS_MODE_RAD (mode)) {\n\t\tr_cons_println (\"fs imports\");\n\t} else if (IS_MODE_NORMAL (mode)) {\n\t\tr_cons_println (\"[Imports]\");\n\t}\n\tr_list_foreach (imports, iter, import) {\n\t\tif (name && strcmp (import->name, name)) {\n\t\t\tcontinue;\n\t\t}\n\t\tchar *symname = strdup (import->name);\n\t\tut64 addr = lit ? impaddr (r->bin, va, symname): 0;\n\t\tif (bin_demangle) {\n\t\t\tchar *dname = r_bin_demangle (r->bin->cur, NULL, symname, addr);\n\t\t\tif (dname) {\n\t\t\t\tfree (symname);\n\t\t\t\tsymname = r_str_newf (\"sym.imp.%s\", dname);\n\t\t\t\tfree (dname);\n\t\t\t}\n\t\t}\n\t\tif (r->bin->prefix) {\n\t\t\tchar *prname = r_str_newf (\"%s.%s\", r->bin->prefix, symname);\n\t\t\tfree (symname);\n\t\t\tsymname = prname;\n\t\t}\n\t\tif (IS_MODE_SET (mode)) {\n\t\t\t// TODO(eddyb) symbols that are imports.\n\t\t\t// Add a dword/qword for PE imports\n\t\t\tif (strstr (symname, \".dll_\") && cdsz) {\n\t\t\t\tr_meta_add (r->anal, R_META_TYPE_DATA, addr, addr + cdsz, NULL);\n\t\t\t}\n\t\t} else if (IS_MODE_SIMPLE (mode)) {\n\t\t\tr_cons_println (symname);\n\t\t} else if (IS_MODE_JSON (mode)) {\n\t\t\tstr = r_str_utf16_encode (symname, -1);\n\t\t\tstr = r_str_replace (str, \"\\\"\", \"\\\\\\\"\", 1);\n\t\t\tr_cons_printf (\"%s{\\\"ordinal\\\":%d,\"\n\t\t\t\t\"\\\"bind\\\":\\\"%s\\\",\"\n\t\t\t\t\"\\\"type\\\":\\\"%s\\\",\",\n\t\t\t\titer->p ? \",\" : \"\",\n\t\t\t\timport->ordinal,\n\t\t\t\timport->bind,\n\t\t\t\timport->type);\n\t\t\tif (import->classname && import->classname[0]) {\n\t\t\t\tr_cons_printf (\"\\\"classname\\\":\\\"%s\\\",\"\n\t\t\t\t\t\"\\\"descriptor\\\":\\\"%s\\\",\",\n\t\t\t\t\timport->classname,\n\t\t\t\t\timport->descriptor);\n\t\t\t}\n\t\t\tr_cons_printf (\"\\\"name\\\":\\\"%s\\\",\\\"plt\\\":%\"PFMT64d\"}\",\n\t\t\t\tstr, addr);\n\t\t\tfree (str);\n\t\t} else if (IS_MODE_RAD (mode)) {\n\t\t\t// TODO(eddyb) symbols that are imports.\n\t\t} else {\n\t\t\tconst char *bind = r_str_get (import->bind);\n\t\t\tconst char *type = r_str_get (import->type);\n#if 0\n\t\t\tr_cons_printf (\"ordinal=%03d plt=0x%08\"PFMT64x\" bind=%s type=%s\",\n\t\t\t\timport->ordinal, addr, bind, type);\n\t\t\tif (import->classname && import->classname[0]) {\n\t\t\t\tr_cons_printf (\" classname=%s\", import->classname);\n\t\t\t}\n\t\t\tr_cons_printf (\" name=%s\", symname);\n\t\t\tif (import->descriptor && import->descriptor[0]) {\n\t\t\t\tr_cons_printf (\" descriptor=%s\", import->descriptor);\n\t\t\t}\n\t\t\tr_cons_newline ();\n#else\n\t\t\tr_cons_printf (\"%4d 0x%08\"PFMT64x\" %7s %7s \",\n\t\t\t\timport->ordinal, addr, bind, type);\n\t\t\tif (import->classname && import->classname[0]) {\n\t\t\t\tr_cons_printf (\"%s.\", import->classname);\n\t\t\t}\n\t\t\tr_cons_printf (\"%s\", symname);\n\t\t\tif (import->descriptor && import->descriptor[0]) {\n\t\t\t\t// Uh?\n\t\t\t\tr_cons_printf (\" descriptor=%s\", import->descriptor);\n\t\t\t}\n\t\t\tr_cons_newline ();\n#endif\n\t\t}\n\t\tR_FREE (symname);\n\t\ti++;\n\t}\n\tif (IS_MODE_JSON (mode)) {\n\t\tr_cons_print (\"]\");\n\t} else if (IS_MODE_NORMAL (mode)) {\n\t\t// r_cons_printf (\"# %i imports\\n\", i);\n\t}\n#if MYDB\n\t// NOTE: if we comment out this, it will leak.. but it will be faster\n\t// because it will keep the cache across multiple RBin calls\n\tosymbols = NULL;\n\tsdb_free (mydb);\n\tmydb = NULL;\n#endif\n\treturn true;\n}\n\nstatic const char *getPrefixFor(const char *s) {\n\tif (s) {\n\t\tif (!strcmp (s, \"NOTYPE\")) {\n\t\t\treturn \"loc\";\n\t\t}\n\t\tif (!strcmp (s, \"OBJECT\")) {\n\t\t\treturn \"obj\";\n\t\t}\n\t}\n\treturn \"sym\";\n}\n\ntypedef struct {\n\tconst char *pfx; // prefix for flags\n\tchar *name;      // raw symbol name\n\tchar *nameflag;  // flag name for symbol\n\tchar *demname;   // demangled raw symbol name\n\tchar *demflag;   // flag name for demangled symbol\n\tchar *classname; // classname\n\tchar *classflag; // flag for classname\n\tchar *methname;  // methods [class]::[method]\n\tchar *methflag;  // methods flag sym.[class].[method]\n} SymName;\n\nstatic void snInit(RCore *r, SymName *sn, RBinSymbol *sym, const char *lang) {\n#define MAXFLAG_LEN 128\n\tint bin_demangle = lang != NULL;\n\tconst char *pfx;\n\tif (!r || !sym || !sym->name) return;\n\tpfx = getPrefixFor (sym->type);\n\tsn->name = strdup (sym->name);\n\tif (sym->dup_count) {\n\t\tsn->nameflag = r_str_newf (\"%s.%s_%d\", pfx, sym->name, sym->dup_count);\n\t} else {\n\t\tsn->nameflag = r_str_newf (\"%s.%s\", pfx, sym->name);\n\t}\n\tr_name_filter (sn->nameflag, MAXFLAG_LEN);\n\tif (sym->classname && sym->classname[0]) {\n\t\tsn->classname = strdup (sym->classname);\n\t\tsn->classflag = r_str_newf (\"sym.%s.%s\", sn->classname, sn->name);\n\t\tr_name_filter (sn->classflag, MAXFLAG_LEN);\n\t\tconst char *name = sym->dname? sym->dname: sym->name;\n\t\tsn->methname = r_str_newf (\"%s::%s\", sn->classname, name);\n\t\tsn->methflag = r_str_newf (\"sym.%s.%s\", sn->classname, name);\n\t\tr_name_filter (sn->methflag, strlen (sn->methflag));\n\t} else {\n\t\tsn->classname = NULL;\n\t\tsn->classflag = NULL;\n\t\tsn->methname = NULL;\n\t\tsn->methflag = NULL;\n\t}\n\tsn->demname = NULL;\n\tsn->demflag = NULL;\n\tif (bin_demangle && sym->paddr) {\n\t\tsn->demname = r_bin_demangle (r->bin->cur, lang, sn->name, sym->vaddr);\n\t\tif (sn->demname) {\n\t\t\tsn->demflag = r_str_newf (\"%s.%s\", pfx, sn->demname);\n\t\t\tr_name_filter (sn->demflag, -1);\n\t\t}\n\t}\n}\n\nstatic void snFini(SymName *sn) {\n\tR_FREE (sn->name);\n\tR_FREE (sn->nameflag);\n\tR_FREE (sn->demname);\n\tR_FREE (sn->demflag);\n\tR_FREE (sn->classname);\n\tR_FREE (sn->classflag);\n\tR_FREE (sn->methname);\n\tR_FREE (sn->methflag);\n}\n\n\nstatic bool isAnExport(RBinSymbol *s) {\n\t/* workaround for some bin plugs */\n\tif (!strncmp (s->name, \"imp.\", 4)) {\n\t\treturn false;\n\t}\n\treturn (s->bind && !strcmp (s->bind, \"GLOBAL\"));\n}\n\nstatic int bin_symbols_internal(RCore *r, int mode, ut64 laddr, int va, ut64 at, const char *name, bool exponly, const char *args) {\n\tRBinInfo *info = r_bin_get_info (r->bin);\n\tRList *entries = r_bin_get_entries (r->bin);\n\tRBinSymbol *symbol;\n\tRBinAddr *entry;\n\tRListIter *iter;\n\tRList *symbols;\n\tconst char *lang;\n\tbool firstexp = true;\n\tbool printHere = false;\n\tint i = 0, is_arm, lastfs = 's';\n\tbool bin_demangle = r_config_get_i (r->config, \"bin.demangle\");\n\tif (!info) {\n\t\treturn 0;\n\t}\n\n\tif (args && *args == '.') {\n\t\tprintHere = true;\n\t}\n\n\tis_arm = info && info->arch && !strncmp (info->arch, \"arm\", 3);\n\tlang = bin_demangle ? r_config_get (r->config, \"bin.lang\") : NULL;\n\n\tsymbols = r_bin_get_symbols (r->bin);\n\tr_space_set (&r->anal->meta_spaces, \"bin\");\n\n\tif (IS_MODE_JSON (mode) && !printHere) {\n\t\tr_cons_printf (\"[\");\n\t} else if (IS_MODE_SET (mode)) {\n\t\tr_flag_space_set (r->flags, \"symbols\");\n\t} else if (!at && exponly) {\n\t\tif (IS_MODE_RAD (mode)) {\n\t\t\tr_cons_printf (\"fs exports\\n\");\n\t\t} else if (IS_MODE_NORMAL (mode)) {\n\t\t\tr_cons_printf (printHere ? \"\" : \"[Exports]\\n\");\n\t\t}\n\t} else if (!at && !exponly) {\n\t\tif (IS_MODE_RAD (mode)) {\n\t\t\tr_cons_printf (\"fs symbols\\n\");\n\t\t} else if (IS_MODE_NORMAL (mode)) {\n\t\t\tr_cons_printf (printHere ? \"\" : \"[Symbols]\\n\");\n\t\t}\n\t}\n\n\tr_list_foreach (symbols, iter, symbol) {\n\t\tut64 addr = rva (r->bin, symbol->paddr, symbol->vaddr, va);\n\t\tint len = symbol->size ? symbol->size : 32;\n\t\tSymName sn;\n\n\t\tif (exponly && !isAnExport (symbol)) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (name && strcmp (symbol->name, name)) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (at && (!symbol->size || !is_in_range (at, addr, symbol->size))) {\n\t\t\tcontinue;\n\t\t}\n\t\tif ((printHere && !is_in_range (r->offset, symbol->paddr, len))\n\t\t\t\t&& (printHere && !is_in_range (r->offset, addr, len))) {\n\t\t\tcontinue;\n\t\t}\n\t\tsnInit (r, &sn, symbol, lang);\n\n\t\tif (IS_MODE_SET (mode) && (is_section_symbol (symbol) || is_file_symbol (symbol))) {\n\t\t\t/*\n\t\t\t * Skip section symbols because they will have their own flag.\n\t\t\t * Skip also file symbols because not useful for now.\n\t\t\t */\n\t\t} else if (IS_MODE_SET (mode)) {\n\t\t\tif (is_arm && info->bits < 33) { // 16 or 32\n\t\t\t\tint force_bits = 0;\n\t\t\t\tif (symbol->paddr & 1 || symbol->bits == 16) {\n\t\t\t\t\tforce_bits = 16;\n\t\t\t\t} else if (info->bits == 16 && symbol->bits == 32) {\n\t\t\t\t\tforce_bits = 32;\n\t\t\t\t} else if (!(symbol->paddr & 1) && symbol->bits == 32) {\n\t\t\t\t\tforce_bits = 32;\n\t\t\t\t}\n\t\t\t\tif (force_bits) {\n\t\t\t\t\tr_anal_hint_set_bits (r->anal, addr, force_bits);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!strncmp (symbol->name, \"imp.\", 4)) {\n\t\t\t\tif (lastfs != 'i') {\n\t\t\t\t\tr_flag_space_set (r->flags, \"imports\");\n\t\t\t\t}\n\t\t\t\tlastfs = 'i';\n\t\t\t} else {\n\t\t\t\tif (lastfs != 's') {\n\t\t\t\t\tr_flag_space_set (r->flags, \"symbols\");\n\t\t\t\t}\n\t\t\t\tlastfs = 's';\n\t\t\t}\n\t\t\t/* If that's a Classed symbol (method or so) */\n\t\t\tif (sn.classname) {\n\t\t\t\tRFlagItem *fi = NULL;\n\t\t\t\tchar *comment = NULL;\n\t\t\t\tfi = r_flag_get (r->flags, sn.methflag);\n\t\t\t\tif (r->bin->prefix) {\n\t\t\t\t\tchar *prname;\n\t\t\t\t\tprname = r_str_newf (\"%s.%s\", r->bin->prefix, sn.methflag);\n\t\t\t\t\tr_name_filter (sn.methflag, -1);\n\t\t\t\t\tfree (sn.methflag);\n\t\t\t\t\tsn.methflag = prname;\n\t\t\t\t}\n\t\t\t\tif (fi) {\n\t\t\t\t\tr_flag_item_set_realname (fi, sn.methname);\n\t\t\t\t\tif ((fi->offset - r->flags->base) == addr) {\n\t\t\t\t\t\tcomment = fi->comment ? strdup (fi->comment) : NULL;\n\t\t\t\t\t\tr_flag_unset (r->flags, fi);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfi = r_flag_set (r->flags, sn.methflag, addr, symbol->size);\n\t\t\t\t\tcomment = fi->comment ? strdup (fi->comment) : NULL;\n\t\t\t\t\tif (comment) {\n\t\t\t\t\t\tr_flag_item_set_comment (fi, comment);\n\t\t\t\t\t\tR_FREE (comment);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst char *fn, *n;\n\t\t\t\tRFlagItem *fi;\n\t\t\t\tn = sn.demname ? sn.demname : sn.name;\n\t\t\t\tfn = sn.demflag ? sn.demflag : sn.nameflag;\n\t\t\t\tchar *fnp = (r->bin->prefix) ?\n\t\t\t\t\tr_str_newf (\"%s.%s\", r->bin->prefix, fn):\n\t\t\t\t\tstrdup (fn);\n\t\t\t\tfi = r_flag_set (r->flags, fnp, addr, symbol->size);\n\t\t\t\tif (fi) {\n\t\t\t\t\tr_flag_item_set_realname (fi, n);\n\t\t\t\t} else {\n\t\t\t\t\tif (fn) {\n\t\t\t\t\t\teprintf (\"[Warning] Can't find flag (%s)\\n\", fn);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfree (fnp);\n\t\t\t}\n\t\t\tif (sn.demname) {\n\t\t\t\tr_meta_add (r->anal, R_META_TYPE_COMMENT,\n\t\t\t\t\taddr, symbol->size, sn.demname);\n\t\t\t}\n\t\t} else if (IS_MODE_JSON (mode)) {\n\t\t\tchar *str = r_str_utf16_encode (symbol->name, -1);\n\t\t\t// str = r_str_replace (str, \"\\\"\", \"\\\\\\\"\", 1);\n\t\t\tr_cons_printf (\"%s{\\\"name\\\":\\\"%s\\\",\"\n\t\t\t\t\"\\\"demname\\\":\\\"%s\\\",\"\n\t\t\t\t\"\\\"flagname\\\":\\\"%s\\\",\"\n\t\t\t\t\"\\\"ordinal\\\":%d,\"\n\t\t\t\t\"\\\"bind\\\":\\\"%s\\\",\"\n\t\t\t\t\"\\\"size\\\":%d,\"\n\t\t\t\t\"\\\"type\\\":\\\"%s\\\",\"\n\t\t\t\t\"\\\"vaddr\\\":%\"PFMT64d\",\"\n\t\t\t\t\"\\\"paddr\\\":%\"PFMT64d\"}\",\n\t\t\t\t((exponly && firstexp) || printHere) ? \"\" : (iter->p ? \",\" : \"\"),\n\t\t\t\tstr,\n\t\t\t\tsn.demname? sn.demname: \"\",\n\t\t\t\tsn.nameflag,\n\t\t\t\tsymbol->ordinal,\n\t\t\t\tsymbol->bind,\n\t\t\t\t(int)symbol->size,\n\t\t\t\tsymbol->type,\n\t\t\t\t(ut64)addr, (ut64)symbol->paddr);\n\t\t\tfree (str);\n\t\t} else if (IS_MODE_SIMPLE (mode)) {\n\t\t\tconst char *name = sn.demname? sn.demname: symbol->name;\n\t\t\tr_cons_printf (\"0x%08\"PFMT64x\" %d %s\\n\",\n\t\t\t\taddr, (int)symbol->size, name);\n\t\t} else if (IS_MODE_SIMPLEST (mode)) {\n\t\t\tconst char *name = sn.demname? sn.demname: symbol->name;\n\t\t\tr_cons_printf (\"%s\\n\", name);\n\t\t} else if (IS_MODE_RAD (mode)) {\n\t\t\tRBinFile *binfile;\n\t\t\tRBinPlugin *plugin;\n\t\t\tchar *name = strdup (sn.demname? sn.demname: symbol->name);\n\t\t\tr_name_filter (name, -1);\n\t\t\tif (!strncmp (name, \"imp.\", 4)) {\n\t\t\t\tif (lastfs != 'i')\n\t\t\t\t\tr_cons_printf (\"fs imports\\n\");\n\t\t\t\tlastfs = 'i';\n\t\t\t} else {\n\t\t\t\tif (lastfs != 's') {\n\t\t\t\t\tr_cons_printf (\"fs %s\\n\",\n\t\t\t\t\t\texponly? \"exports\": \"symbols\");\n\t\t\t\t}\n\t\t\t\tlastfs = 's';\n\t\t\t}\n\t\t\tif (r->bin->prefix) {\n\t\t\t\tif (symbol->dup_count) {\n\t\t\t\t\tr_cons_printf (\"f %s.sym.%s_%d %u 0x%08\"PFMT64x\"\\n\",\n\t\t\t\t\t\tr->bin->prefix, name, symbol->dup_count, symbol->size, addr);\n\t\t\t\t} else {\n\t\t\t\t\tr_cons_printf (\"f %s.sym.%s %u 0x%08\"PFMT64x\"\\n\",\n\t\t\t\t\t\tr->bin->prefix, name, symbol->size, addr);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (symbol->dup_count) {\n\t\t\t\t\tr_cons_printf (\"f sym.%s_%d %u 0x%08\"PFMT64x\"\\n\",\n\t\t\t\t\t\tname, symbol->dup_count, symbol->size, addr);\n\t\t\t\t} else {\n\t\t\t\t\tr_cons_printf (\"f sym.%s %u 0x%08\"PFMT64x\"\\n\",\n\t\t\t\t\t\tname, symbol->size, addr);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbinfile = r_core_bin_cur (r);\n\t\t\tplugin = r_bin_file_cur_plugin (binfile);\n\t\t\tif (plugin && plugin->name) {\n\t\t\t\tif (!strncmp (plugin->name, \"pe\", 2)) {\n\t\t\t\t\tchar *p, *module = strdup (symbol->name);\n\t\t\t\t\tp = strstr (module, \".dll_\");\n\t\t\t\t\tif (p) {\n\t\t\t\t\t\tconst char *symname = p + 5;\n\t\t\t\t\t\t*p = 0;\n\t\t\t\t\t\tif (r->bin->prefix) {\n\t\t\t\t\t\t\tr_cons_printf (\"k bin/pe/%s/%d=%s.%s\\n\",\n\t\t\t\t\t\t\t\tmodule, symbol->ordinal, r->bin->prefix, symname);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tr_cons_printf (\"k bin/pe/%s/%d=%s\\n\",\n\t\t\t\t\t\t\t\tmodule, symbol->ordinal, symname);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfree (module);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tconst char *bind = r_str_get (symbol->bind);\n\t\t\tconst char *type = r_str_get (symbol->type);\n\t\t\tconst char *name = r_str_get (sn.demname? sn.demname: symbol->name);\n\t\t\t// const char *fwd = r_str_get (symbol->forwarder);\n\t\t\tr_cons_printf (\"%03u 0x%08\"PFMT64x\" 0x%08\"PFMT64x\" \"\n\t\t\t\t\"%6s %6s %4d %s\\n\",\n\t\t\t\tsymbol->ordinal,\n\t\t\t\tsymbol->paddr, addr, bind, type,\n\t\t\t\tsymbol->size, name);\n\t\t\t// r_cons_printf (\"vaddr=0x%08\"PFMT64x\" paddr=0x%08\"PFMT64x\" ord=%03u \"\n\t\t\t//\t\"fwd=%s sz=%u bind=%s type=%s name=%s\\n\",\n\t\t\t//\taddr, symbol->paddr, symbol->ordinal, fwd,\n\t\t\t//\tsymbol->size, bind, type, name);\n\t\t}\n\t\tsnFini (&sn);\n\t\ti++;\n\t\tif (exponly && firstexp) {\n\t\t\tfirstexp = false;\n\t\t}\n\t\tif (printHere) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t//handle thumb and arm for entry point since they are not present in symbols\n\tif (is_arm) {\n\t\tr_list_foreach (entries, iter, entry) {\n\t\t\tif (IS_MODE_SET (mode)) {\n\t\t\t\tif (info->bits < 33) { // 16 or 32\n\t\t\t\t\tint force_bits = 0;\n\t\t\t\t\tut64 addr = rva (r->bin, entry->paddr, entry->vaddr, va);\n\t\t\t\t\tif (entry->paddr & 1 || entry->bits == 16) {\n\t\t\t\t\t\tforce_bits = 16;\n\t\t\t\t\t} else if (info->bits == 16 && entry->bits == 32) {\n\t\t\t\t\t\tforce_bits = 32;\n\t\t\t\t\t} else if (!(entry->paddr & 1)) {\n\t\t\t\t\t\tforce_bits = 32;\n\t\t\t\t\t}\n\t\t\t\t\tif (force_bits) {\n\t\t\t\t\t\tr_anal_hint_set_bits (r->anal, addr, force_bits);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (IS_MODE_JSON (mode) && !printHere) r_cons_printf (\"]\");\n#if 0\n\tif (IS_MODE_NORMAL (mode) && !at) {\n\t\tr_cons_printf (\"\\n%i %s\\n\", i, exponly ? \"exports\" : \"symbols\");\n\t}\n#endif\n\n\tr_space_set (&r->anal->meta_spaces, NULL);\n\treturn true;\n}\n\nstatic int bin_exports(RCore *r, int mode, ut64 laddr, int va, ut64 at, const char *name, const char *args) {\n\treturn bin_symbols_internal (r, mode, laddr, va, at, name, true, args);\n}\n\nstatic int bin_symbols(RCore *r, int mode, ut64 laddr, int va, ut64 at, const char *name, const char *args) {\n\treturn bin_symbols_internal (r, mode, laddr, va, at, name, false, args);\n}\n\nstatic char *build_hash_string(int mode, const char *chksum, ut8 *data, ut32 datalen) {\n\tchar *chkstr = NULL, *aux, *ret = NULL;\n\tconst char *ptr = chksum;\n\tchar tmp[128];\n\tint i;\n\tdo {\n\t\tfor (i = 0; *ptr && *ptr != ',' && i < sizeof (tmp) -1; i++) {\n\t\t\ttmp[i] = *ptr++;\n\t\t}\n\t\ttmp[i] = '\\0';\n\t\tr_str_trim_head_tail (tmp);\n\t\tchkstr = r_hash_to_string (NULL, tmp, data, datalen);\n\t\tif (!chkstr) {\n\t\t\tif (*ptr && *ptr == ',') {\n\t\t\t\tptr++;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (IS_MODE_SIMPLE (mode)) {\n\t\t\taux = r_str_newf (\"%s \", chkstr);\n\t\t} else if (IS_MODE_JSON (mode)) {\n\t\t\taux = r_str_newf (\"\\\"%s\\\":\\\"%s\\\",\", tmp, chkstr);\n\t\t} else {\n\t\t\taux = r_str_newf (\"%s=%s \", tmp, chkstr);\n\t\t}\n\t\tret = r_str_append (ret, aux);\n\t\tfree (chkstr);\n\t\tfree (aux);\n\t\tif (*ptr && *ptr == ',') ptr++;\n\t} while (*ptr);\n\n\treturn ret;\n}\n\nstatic int bin_sections(RCore *r, int mode, ut64 laddr, int va, ut64 at, const char *name, const char *chksum) {\n\tchar *str = NULL;\n\tRBinSection *section;\n\tRBinInfo *info = NULL;\n\tRList *sections;\n\tRListIter *iter;\n\tint i = 0;\n\tint fd = -1;\n\tbool printHere = false;\n\tsections = r_bin_get_sections (r->bin);\n\tbool inDebugger = r_config_get_i (r->config, \"cfg.debug\");\n\tSdbHash *dup_chk_ht = ht_new (NULL, NULL, NULL);\n\tbool ret = false;\n\n\tif (!dup_chk_ht) {\n\t\treturn false;\n\t}\n\t\n\tif (chksum && *chksum == '.') {\n\t\tprintHere = true;\n\t}\n\tif (IS_MODE_JSON (mode) && !printHere) r_cons_printf (\"[\");\n\telse if (IS_MODE_RAD (mode) && !at) r_cons_printf (\"fs sections\\n\");\n\telse if (IS_MODE_NORMAL (mode) && !at && !printHere) r_cons_printf (\"[Sections]\\n\");\n\telse if (IS_MODE_NORMAL (mode) && printHere) r_cons_printf(\"Current section\\n\");\n\telse if (IS_MODE_SET (mode)) {\n\t\tfd = r_core_file_cur_fd (r);\n\t\tr_flag_space_set (r->flags, \"sections\");\n\t}\n\tr_list_foreach (sections, iter, section) {\n\t\tchar perms[] = \"----\";\n\t\tint va_sect = va;\n\t\tut64 addr;\n\n\t\tif (va && !(section->srwx & R_BIN_SCN_READABLE)) {\n\t\t\tva_sect = VA_NOREBASE;\n\t\t}\n\t\taddr = rva (r->bin, section->paddr, section->vaddr, va_sect);\n\n\t\tif (name && strcmp (section->name, name)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ((printHere && !(section->paddr <= r->offset && r->offset < (section->paddr + section->size)))\n\t\t\t\t&& (printHere && !(addr <= r->offset && r->offset < (addr + section->size)))) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tr_name_filter (section->name, sizeof (section->name));\n\t\tif (at && (!section->size || !is_in_range (at, addr, section->size))) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (section->srwx & R_BIN_SCN_SHAREABLE) perms[0] = 's';\n\t\tif (section->srwx & R_BIN_SCN_READABLE) perms[1] = 'r';\n\t\tif (section->srwx & R_BIN_SCN_WRITABLE) perms[2] = 'w';\n\t\tif (section->srwx & R_BIN_SCN_EXECUTABLE) perms[3] = 'x';\n\n\t\tif (IS_MODE_SET (mode)) {\n#if LOAD_BSS_MALLOC\n\t\t\tif (!strcmp (section->name, \".bss\")) {\n\t\t\t\t// check if there's already a file opened there\n\t\t\t\tint loaded = 0;\n\t\t\t\tRListIter *iter;\n\t\t\t\tRIOMap *m;\n\t\t\t\tr_list_foreach (r->io->maps, iter, m) {\n\t\t\t\t\tif (m->from == addr) {\n\t\t\t\t\t\tloaded = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!loaded && !inDebugger) {\n\t\t\t\t\tr_core_cmdf (r, \"on malloc://%d 0x%\"PFMT64x\" # bss\\n\",\n\t\t\t\t\t\tsection->vsize, addr);\n\t\t\t\t}\n\t\t\t}\n#endif\n\t\t\tr_name_filter (section->name, 128);\n\t\t\tif (section->format) {\n\t\t\t\t// This is damn slow if section vsize is HUGE\n\t\t\t\tif (section->vsize < 1024 * 1024 * 2) {\n\t\t\t\t\tr_core_cmdf (r, \"%s @ 0x%\"PFMT64x, section->format, section->vaddr);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (r->bin->prefix) {\n\t\t\t\tstr = r_str_newf (\"%s.section.%s\", r->bin->prefix, section->name);\n\t\t\t} else {\n\t\t\t\tstr = r_str_newf (\"section.%s\", section->name);\n\n\t\t\t}\n\t\t\tr_flag_set (r->flags, str, addr, section->size);\n\t\t\tR_FREE (str);\n\n\t\t\tif (r->bin->prefix) {\n\t\t\t\tstr = r_str_newf (\"%s.section_end.%s\", r->bin->prefix, section->name);\n\t\t\t} else {\n\t\t\t\tstr = r_str_newf (\"section_end.%s\", section->name);\n\t\t\t}\n\t\t\tr_flag_set (r->flags, str, addr + section->vsize, 0);\n\t\t\tR_FREE (str);\n\n\t\t\tif (section->arch || section->bits) {\n\t\t\t\tconst char *arch = section->arch;\n\t\t\t\tint bits = section->bits;\n\t\t\t\tif (info) {\n\t\t\t\t\tif (!arch) {\n\t\t\t\t\t\tarch = info->arch;\n\t\t\t\t\t}\n\t\t\t\t\tif (!bits) {\n\t\t\t\t\t\tbits = info->bits;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//r_io_section_set_archbits (r->io, addr, arch, bits);\n\t\t\t}\n\t\t\tchar *pfx = r->bin->prefix;\n\t\t\tstr = r_str_newf (\"[%02d] %s section size %\" PFMT64d\" named %s%s%s\",\n\t\t\t\ti, perms, section->size,\n\t\t\t\tpfx? pfx: \"\", pfx? \".\": \"\", section->name);\n\t\t\tr_meta_add (r->anal, R_META_TYPE_COMMENT, addr, addr, str);\n\t\t\tR_FREE (str);\n\t\t\tif (section->add) {\n\t\t\t\tstr = r_str_newf (\"%\"PFMT64x\".%\"PFMT64x\".%\"PFMT64x\".%\"PFMT64x\".%\"PFMT32u\".%s.%\"PFMT32u\".%d\",\n\t\t\t\t\tsection->paddr, addr, section->size, section->vsize, section->srwx, section->name, r->bin->cur->id, fd);\n\t\t\t\tif (!ht_find (dup_chk_ht, str, NULL) && r_io_section_add (r->io, section->paddr, addr,\n\t\t\t\t\t\tsection->size, section->vsize,\n\t\t\t\t\t\tsection->srwx, section->name,\n\t\t\t\t\t\tr->bin->cur->id, fd)) {\n\t\t\t\t\tht_insert (dup_chk_ht, str, NULL);\n\t\t\t\t}\n\t\t\t\tR_FREE (str);\n\t\t\t}\n\t\t} else if (IS_MODE_SIMPLE (mode)) {\n\t\t\tchar *hashstr = NULL;\n\t\t\tif (chksum) {\n\t\t\t\tut8 *data = malloc (section->size);\n\t\t\t\tif (!data) {\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tut32 datalen = section->size;\n\t\t\t\tr_io_pread_at (r->io, section->paddr, data, datalen);\n\t\t\t\thashstr = build_hash_string (mode, chksum,\n\t\t\t\t\t\t\tdata, datalen);\n\t\t\t\tfree (data);\n\t\t\t}\n\t\t\tr_cons_printf (\"0x%\"PFMT64x\" 0x%\"PFMT64x\" %s %s%s%s\\n\",\n\t\t\t\taddr, addr + section->size,\n\t\t\t\tperms,\n\t\t\t\thashstr ? hashstr : \"\", hashstr ? \" \" : \"\",\n\t\t\t\tsection->name\n\t\t\t);\n\t\t\tfree (hashstr);\n\t\t} else if (IS_MODE_JSON (mode)) {\n\t\t\tchar *hashstr = NULL;\n\t\t\tif (chksum) {\n\t\t\t\tut8 *data = malloc (section->size);\n\t\t\t\tif (!data) {\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tut32 datalen = section->size;\n\t\t\t\tr_io_pread_at (r->io, section->paddr, data, datalen);\n\t\t\t\thashstr = build_hash_string (mode, chksum,\n\t\t\t\t\t\t\tdata, datalen);\n\t\t\t\tfree (data);\n\n\t\t\t}\n\t\t\tr_cons_printf (\"%s{\\\"name\\\":\\\"%s\\\",\"\n\t\t\t\t\"\\\"size\\\":%\"PFMT64d\",\"\n\t\t\t\t\"\\\"vsize\\\":%\"PFMT64d\",\"\n\t\t\t\t\"\\\"flags\\\":\\\"%s\\\",\"\n\t\t\t\t\"%s\"\n\t\t\t\t\"\\\"paddr\\\":%\"PFMT64d\",\"\n\t\t\t\t\"\\\"vaddr\\\":%\"PFMT64d\"}\",\n\t\t\t\t(iter->p && !printHere)?\",\":\"\",\n\t\t\t\tsection->name,\n\t\t\t\tsection->size,\n\t\t\t\tsection->vsize,\n\t\t\t\tperms,\n\t\t\t\thashstr ? hashstr : \"\",\n\t\t\t\tsection->paddr,\n\t\t\t\taddr);\n\t\t\tfree (hashstr);\n\t\t} else if (IS_MODE_RAD (mode)) {\n\t\t\tif (!strcmp (section->name, \".bss\") && !inDebugger) {\n#if LOAD_BSS_MALLOC\n\t\t\t\tr_cons_printf (\"on malloc://%d 0x%\"PFMT64x\" # bss\\n\",\n\t\t\t\t\t\tsection->vsize, addr);\n#endif\n\t\t\t}\n\t\t\tif (r->bin->prefix) {\n\t\t\t\tr_cons_printf (\"S 0x%08\"PFMT64x\" 0x%08\"PFMT64x\" 0x%08\"PFMT64x\" 0x%08\"PFMT64x\" %s.%s %d\\n\",\n\t\t\t\t\tsection->paddr, addr, section->size, section->vsize,\n\t\t\t\t\tr->bin->prefix, section->name, (int)section->srwx);\n\t\t\t} else {\n\t\t\t\tr_cons_printf (\"S 0x%08\"PFMT64x\" 0x%08\"PFMT64x\" 0x%08\"PFMT64x\" 0x%08\"PFMT64x\" %s %d\\n\",\n\t\t\t\t\tsection->paddr, addr, section->size, section->vsize,\n\t\t\t\t\tsection->name, (int)section->srwx);\n\n\t\t\t}\n\t\t\tif (section->arch || section->bits) {\n\t\t\t\tconst char *arch = section->arch;\n\t\t\t\tint bits = section->bits;\n\t\t\t\tif (info) {\n\t\t\t\t\tif (!arch) arch = info->arch;\n\t\t\t\t\tif (!bits) bits = info->bits;\n\t\t\t\t}\n\t\t\t\tif (!arch) {\n\t\t\t\t\tarch = r_config_get (r->config, \"asm.arch\");\n\t\t\t\t}\n\t\t\t\tr_cons_printf (\"Sa %s %d @ 0x%08\"\n\t\t\t\t\tPFMT64x\"\\n\", arch, bits, addr);\n\t\t\t}\n\t\t\tif (r->bin->prefix) {\n\t\t\t\tr_cons_printf (\"f %s.section.%s %\"PFMT64d\" 0x%08\"PFMT64x\"\\n\",\n\t\t\t\t\t\tr->bin->prefix, section->name, section->size, addr);\n\t\t\t\tr_cons_printf (\"f %s.section_end.%s 1 0x%08\"PFMT64x\"\\n\",\n\t\t\t\t\t\tr->bin->prefix, section->name, addr + section->vsize);\n\t\t\t\tr_cons_printf (\"CC section %i va=0x%08\"PFMT64x\" pa=0x%08\"PFMT64x\" sz=%\"PFMT64d\" vsz=%\"PFMT64d\" \"\n\t\t\t\t\t\t\"rwx=%s %s.%s @ 0x%08\"PFMT64x\"\\n\",\n\t\t\t\t\t\ti, addr, section->paddr, section->size, section->vsize,\n\t\t\t\t\t\tperms, r->bin->prefix, section->name, addr);\n\n\t\t\t} else {\n\t\t\t\tr_cons_printf (\"f section.%s %\"PFMT64d\" 0x%08\"PFMT64x\"\\n\",\n\t\t\t\t\t\tsection->name, section->size, addr);\n\t\t\t\tr_cons_printf (\"f section_end.%s 1 0x%08\"PFMT64x\"\\n\",\n\t\t\t\t\t\tsection->name, addr + section->vsize);\n\t\t\t\tr_cons_printf (\"CC section %i va=0x%08\"PFMT64x\" pa=0x%08\"PFMT64x\" sz=%\"PFMT64d\" vsz=%\"PFMT64d\" \"\n\t\t\t\t\t\t\"rwx=%s %s @ 0x%08\"PFMT64x\"\\n\",\n\t\t\t\t\t\ti, addr, section->paddr, section->size, section->vsize,\n\t\t\t\t\t\tperms, section->name, addr);\n\t\t\t}\n\t\t} else {\n\t\t\tchar *hashstr = NULL, str[128];\n\t\t\tif (chksum) {\n\t\t\t\tut8 *data = malloc (section->size);\n\t\t\t\tif (!data) {\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tut32 datalen = section->size;\n\t\t\t\t// VA READ IS BROKEN?\n\t\t\t\tr_io_pread_at (r->io, section->paddr, data, datalen);\n\t\t\t\thashstr = build_hash_string (mode, chksum,\n\t\t\t\t\t\t\tdata, datalen);\n\t\t\t\tfree (data);\n\t\t\t}\n\t\t\tif (section->arch || section->bits) {\n\t\t\t\tconst char *arch = section->arch;\n\t\t\t\tint bits = section->bits;\n\t\t\t\tif (!arch && info) {\n\t\t\t\t\tarch = info->arch;\n\t\t\t\t\tif (!arch) {\n\t\t\t\t\t\tarch = r_config_get (r->config, \"asm.arch\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!bits) {\n\t\t\t\t\tbits = info? info->bits: R_SYS_BITS;\n\t\t\t\t}\n\t\t\t\tsnprintf (str, sizeof (str), \"arch=%s bits=%d \",\n\t\t\t\t\tr_str_get2 (arch), bits);\n\t\t\t} else {\n\t\t\t\tstr[0] = 0;\n\t\t\t}\n\t\t\tif (r->bin->prefix) {\n#if 0\n\t\t\t\tr_cons_printf (\"idx=%02i vaddr=0x%08\"PFMT64x\" paddr=0x%08\"PFMT64x\" sz=%\"PFMT64d\" vsz=%\"PFMT64d\" \"\n\t\t\t\t\t\"perm=%s %s%sname=%s.%s\\n\",\n\t\t\t\t\ti, addr, section->paddr, section->size, section->vsize,\n\t\t\t\t\tperms, str, hashstr ?hashstr : \"\", r->bin->prefix, section->name);\n#endif\n\t\t\t\t// r_cons_printf (\"%02i 0x%08\"PFMT64x\" %10\"PFMT64d\" 0x%08\"PFMT64x\" %10\"PFMT64d\" \"\n\t\t\t\tr_cons_printf (\"%02i 0x%08\"PFMT64x\" %5\"PFMT64d\" 0x%08\"PFMT64x\" %5\"PFMT64d\" \"\n\t\t\t\t\t\"%s %s% %s.%s\\n\",\n\t\t\t\t\ti, section->paddr, section->size, addr, section->vsize,\n\t\t\t\t\tperms, str, hashstr ?hashstr : \"\", r->bin->prefix, section->name);\n\t\t\t} else {\n#if 0\n\t\t\t\tr_cons_printf (\"idx=%02i vaddr=0x%08\"PFMT64x\" paddr=0x%08\"PFMT64x\" sz=%\"PFMT64d\" vsz=%\"PFMT64d\" \"\n\t\t\t\t\t\"perm=%s %s%sname=%s\\n\",\n\t\t\t\t\ti, addr, section->paddr, section->size, section->vsize,\n\t\t\t\t\tperms, str, hashstr ?hashstr : \"\", section->name);\n#endif\n\t\t\t\t// r_cons_printf (\"%02i 0x%08\"PFMT64x\" %10\"PFMT64d\" 0x%08\"PFMT64x\" %10\"PFMT64d\" \"\n\t\t\t\tr_cons_printf (\"%02i 0x%08\"PFMT64x\" %5\"PFMT64d\" 0x%08\"PFMT64x\" %5\"PFMT64d\" \"\n\t\t\t\t\t\"%s %s%s%s\\n\",\n\t\t\t\t\ti, section->paddr, (ut64)section->size, addr, (ut64)section->vsize,\n\t\t\t\t\tperms, str, hashstr ?hashstr : \"\", section->name);\n\t\t\t}\n\t\t\tfree (hashstr);\n\t\t}\n\t\ti++;\n\t\tif (printHere) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (r->bin && r->bin->cur && r->io && !r_io_desc_is_dbg (r->io->desc)) {\n\t\tr_io_section_apply_bin (r->io, r->bin->cur->id, R_IO_SECTION_APPLY_FOR_ANALYSIS);\n\t}\n\tif (IS_MODE_JSON (mode) && !printHere) {\n\t\tr_cons_println (\"]\");\n\t} else if (IS_MODE_NORMAL (mode) && !at && !printHere) {\n\t\t// r_cons_printf (\"\\n%i sections\\n\", i);\n\t}\n\n\tret = true;\nout:\n\tht_free (dup_chk_ht);\n\treturn ret;\n}\n\nstatic int bin_fields(RCore *r, int mode, int va) {\n\tRList *fields;\n\tRListIter *iter;\n\tRBinField *field;\n\tint i = 0;\n\tRBin *bin = r->bin;\n\tRBinFile *binfile = r_core_bin_cur (r);\n\tut64 size = binfile ? binfile->size : UT64_MAX;\n\tut64 baddr = r_bin_get_baddr (r->bin);\n\n\tif (!(fields = r_bin_get_fields (bin))) {\n\t\treturn false;\n\t}\n\tif (IS_MODE_JSON (mode)) {\n\t\tr_cons_print (\"[\");\n\t} else if (IS_MODE_RAD (mode)) {\n\t\tr_cons_println (\"fs header\");\n\t} else if (IS_MODE_NORMAL (mode)) {\n\t\tr_cons_println (\"[Header fields]\");\n\t}\n//why this? there is an overlap in bin_sections with ehdr\n//because there can't be two sections with the same name\n#if 0\n\telse if (IS_MODE_SET (mode)) {\n\t\t// XXX: Need more flags??\n\t\t// this will be set even if the binary does not have an ehdr\n\t\tint fd = r_core_file_cur_fd(r);\n\t\tr_io_section_add (r->io, 0, baddr, size, size, 7, \"ehdr\", 0, fd);\n\t}\n#endif\n\tr_list_foreach (fields, iter, field) {\n\t\tut64 addr = rva (bin, field->paddr, field->vaddr, va);\n\n\t\tif (IS_MODE_RAD (mode)) {\n\t\t\tr_name_filter (field->name, -1);\n\t\t\tr_cons_printf (\"f header.%s @ 0x%08\"PFMT64x\"\\n\", field->name, addr);\n\t\t\tif (field->comment && *field->comment) {\n\t\t\t\tr_cons_printf (\"CC %s @ 0x%\"PFMT64x\"\\n\", field->comment, addr);\n\t\t\t}\n\t\t\tif (field->format && *field->format) {\n\t\t\t\tr_cons_printf (\"pf.%s %s\\n\", field->name, field->format);\n\t\t\t}\n\t\t} else if (IS_MODE_JSON (mode)) {\n\t\t\tr_cons_printf (\"%s{\\\"name\\\":\\\"%s\\\",\"\n\t\t\t\t\"\\\"vaddr\\\":%\"PFMT64d\",\"\n\t\t\t\t\"\\\"paddr\\\":%\"PFMT64d,\n\t\t\t\titer->p? \",\": \"\",\n\t\t\t\tfield->name,\n\t\t\t\tfield->vaddr,\n\t\t\t\tfield->paddr\n\t\t\t\t);\n\t\t\tif (field->comment && *field->comment) {\n\t\t\t\t// TODO: filter comment before json\n\t\t\t\tr_cons_printf (\",\\\"comment\\\":\\\"%s\\\"\", field->comment);\n\t\t\t}\n\t\t\tif (field->format && *field->format) {\n\t\t\t\t// TODO: filter comment before json\n\t\t\t\tr_cons_printf (\",\\\"format\\\":\\\"%s\\\"\", field->format);\n\t\t\t}\n\t\t\tr_cons_printf (\"}\");\n\t\t} else if (IS_MODE_NORMAL (mode)) {\n\t\t\tconst bool haveComment = (field->comment && *field->comment);\n\t\t\tr_cons_printf (\"0x%08\"PFMT64x\" 0x%08\"PFMT64x\" %s%s%s\\n\",\n\t\t\t\tfield->vaddr, field->paddr, field->name,\n\t\t\t\thaveComment? \"; \": \"\",\n\t\t\t\thaveComment? field->comment: \"\");\n\t\t}\n\t\ti++;\n\t}\n\tif (IS_MODE_JSON (mode)) {\n\t\tr_cons_printf (\"]\");\n\t} else if (IS_MODE_RAD (mode)) {\n\t\t/* add program header section */\n\t\tr_cons_printf (\"S 0 0x%\"PFMT64x\" 0x%\"PFMT64x\" 0x%\"PFMT64x\" ehdr rwx\\n\",\n\t\t\tbaddr, size, size);\n\t} else if (IS_MODE_NORMAL (mode)) {\n\t\tr_cons_printf (\"\\n%i fields\\n\", i);\n\t}\n\n\treturn true;\n}\n\nstatic char* get_rp (const char* rtype) {\n\tchar *rp = NULL;\n\tswitch(rtype[0]) {\n\tcase 'v':\n\t\trp = strdup (\"void\");\n\t\tbreak;\n\tcase 'c':\n\t\trp = strdup (\"char\");\n\t\tbreak;\n\tcase 'i':\n\t\trp = strdup (\"int\");\n\t\tbreak;\n\tcase 's':\n\t\trp = strdup (\"short\");\n\t\tbreak;\n\tcase 'l':\n\t\trp = strdup (\"long\");\n\t\tbreak;\n\tcase 'q':\n\t\trp = strdup (\"long long\");\n\t\tbreak;\n\tcase 'C':\n\t\trp = strdup (\"unsigned char\");\n\t\tbreak;\n\tcase 'I':\n\t\trp = strdup (\"unsigned int\");\n\t\tbreak;\n\tcase 'S':\n\t\trp = strdup (\"unsigned short\");\n\t\tbreak;\n\tcase 'L':\n\t\trp = strdup (\"unsigned long\");\n\t\tbreak;\n\tcase 'Q':\n\t\trp = strdup (\"unsigned long long\");\n\t\tbreak;\n\tcase 'f':\n\t\trp = strdup (\"float\");\n\t\tbreak;\n\tcase 'd':\n\t\trp = strdup (\"double\");\n\t\tbreak;\n\tcase 'D':\n\t\trp = strdup (\"long double\");\n\t\tbreak;\n\tcase 'B':\n\t\trp = strdup (\"bool\");\n\t\tbreak;\n\tcase '#':\n\t\trp = strdup (\"CLASS\");\n\t\tbreak;\n\tdefault:\n\t\trp = strdup (\"unknown\");\n\t\tbreak;\n\t}\n\treturn rp;\n}\n\nstatic int bin_classes(RCore *r, int mode) {\n\tRListIter *iter, *iter2, *iter3;\n\tRBinSymbol *sym;\n\tRBinClass *c;\n\tRBinField *f;\n\tchar *name;\n\tRList *cs = r_bin_get_classes (r->bin);\n\tif (!cs) {\n\t\tif (IS_MODE_JSON (mode)) {\n\t\t\tr_cons_print(\"[]\");\n\t\t}\n\t\treturn false;\n\t}\n\t// XXX: support for classes is broken and needs more love\n\tif (IS_MODE_JSON (mode)) {\n\t\tr_cons_print (\"[\");\n\t} else if (IS_MODE_SET (mode)) {\n\t\tif (!r_config_get_i (r->config, \"bin.classes\")) {\n\t\t\treturn false;\n\t\t}\n\t\tr_flag_space_set (r->flags, \"classes\");\n\t} else if (IS_MODE_RAD (mode)) {\n\t\tr_cons_println (\"fs classes\");\n\t}\n\n\tr_list_foreach (cs, iter, c) {\n\t\tif (!c || !c->name || !c->name[0]) {\n\t\t\tcontinue;\n\t\t}\n\t\tname = strdup (c->name);\n\t\tr_name_filter (name, 0);\n\t\tut64 at_min = UT64_MAX;\n\t\tut64 at_max = 0LL;\n\n\t\tr_list_foreach (c->methods, iter2, sym) {\n\t\t\tif (sym->vaddr) {\n\t\t\t\tif (sym->vaddr < at_min) {\n\t\t\t\t\tat_min = sym->vaddr;\n\t\t\t\t}\n\t\t\t\tif (sym->vaddr + sym->size > at_max) {\n\t\t\t\t\tat_max = sym->vaddr + sym->size;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (at_min == UT64_MAX) {\n\t\t\tat_min = c->addr;\n\t\t\tat_max = c->addr; // XXX + size?\n\t\t}\n\n\t\tif (IS_MODE_SET (mode)) {\n\t\t\tconst char *classname = sdb_fmt (\"class.%s\", name);\n\t\t\tr_flag_set (r->flags, classname, c->addr, 1);\n\t\t\tr_list_foreach (c->methods, iter2, sym) {\n\t\t\t\tchar *mflags = r_core_bin_method_flags_str (sym->method_flags, mode);\n\t\t\t\tchar *method = sdb_fmt (\"method%s.%s.%s\",\n\t\t\t\t\tmflags, c->name, sym->name);\n\t\t\t\tR_FREE (mflags);\n\t\t\t\tr_name_filter (method, -1);\n\t\t\t\tr_flag_set (r->flags, method, sym->vaddr, 1);\n\t\t\t}\n\t\t} else if (IS_MODE_SIMPLE (mode)) {\n\t\t\tr_cons_printf (\"0x%08\"PFMT64x\" [0x%08\"PFMT64x\" - 0x%08\"PFMT64x\"] %s%s%s\\n\",\n\t\t\t\tc->addr, at_min, at_max, c->name, c->super ? \" \" : \"\",\n\t\t\t\tc->super ? c->super : \"\");\n\t\t} else if (IS_MODE_RAD (mode)) {\n\t\t\tr_cons_printf (\"\\\"f class.%s = 0x%\"PFMT64x\"\\\"\\n\",\n\t\t\t\tname, at_min);\n\t\t\tif (c->super) {\n\t\t\t\tr_cons_printf (\"\\\"f super.%s.%s = %d\\\"\\n\",\n\t\t\t\t\tc->name, c->super, c->index);\n\t\t\t}\n\t\t\tr_list_foreach (c->methods, iter2, sym) {\n\t\t\t\tchar *mflags = r_core_bin_method_flags_str (sym->method_flags, mode);\n\t\t\t\tchar *cmd = r_str_newf (\"\\\"f method%s.%s.%s = 0x%\"PFMT64x\"\\\"\\n\", mflags, c->name, sym->name, sym->vaddr);\n\t\t\t\tr_str_replace_char (cmd, '\\n', 0);\n\t\t\t\tr_cons_printf (\"%s\\n\", cmd);\n\t\t\t\tR_FREE (mflags);\n\t\t\t\tfree (cmd);\n\t\t\t}\n\t\t} else if (IS_MODE_JSON (mode)) {\n\t\t\tif (c->super) {\n\t\t\t\tr_cons_printf (\"%s{\\\"classname\\\":\\\"%s\\\",\\\"addr\\\":%\"PFMT64d\",\\\"index\\\":%d,\\\"super\\\":\\\"%s\\\",\\\"methods\\\":[\",\n\t\t\t\t\titer->p ? \",\" : \"\", c->name, c->addr,\n\t\t\t\t\tc->index, c->super);\n\t\t\t} else {\n\t\t\t\tr_cons_printf (\"%s{\\\"classname\\\":\\\"%s\\\",\\\"addr\\\":%\"PFMT64d\",\\\"index\\\":%d,\\\"methods\\\":[\",\n\t\t\t\t\titer->p ? \",\" : \"\", c->name, c->addr,\n\t\t\t\t\tc->index);\n\t\t\t}\n\t\t\tr_list_foreach (c->methods, iter2, sym) {\n\t\t\t\tif (sym->method_flags) {\n\t\t\t\t\tchar *mflags = r_core_bin_method_flags_str (sym->method_flags, mode);\n\t\t\t\t\tr_cons_printf (\"%s{\\\"name\\\":\\\"%s\\\",\\\"flags\\\":%s,\\\"addr\\\":%\"PFMT64d\"}\",\n\t\t\t\t\t\titer2->p? \",\": \"\", sym->name, mflags, sym->vaddr);\n\t\t\t\t\tR_FREE (mflags);\n\t\t\t\t} else {\n\t\t\t\t\tr_cons_printf (\"%s{\\\"name\\\":\\\"%s\\\",\\\"addr\\\":%\"PFMT64d\"}\",\n\t\t\t\t\t\titer2->p? \",\": \"\", sym->name, sym->vaddr);\n\t\t\t\t}\n\t\t\t}\n\t\t\tr_cons_printf (\"], \\\"fields\\\":[\");\n\t\t\tr_list_foreach (c->fields, iter3, f) {\n\t\t\t\tif (f->flags) {\n\t\t\t\t\tchar *mflags = r_core_bin_method_flags_str (f->flags, mode);\n\t\t\t\t\tr_cons_printf (\"%s{\\\"name\\\":\\\"%s\\\",\\\"flags\\\":%s,\\\"addr\\\":%\"PFMT64d\"}\",\n\t\t\t\t\t\titer3->p? \",\": \"\", f->name, mflags, f->vaddr);\n\t\t\t\t\tR_FREE (mflags);\n\t\t\t\t} else {\n\t\t\t\t\tr_cons_printf (\"%s{\\\"name\\\":\\\"%s\\\",\\\"addr\\\":%\"PFMT64d\"}\",\n\t\t\t\t\t\titer3->p? \",\": \"\", f->name, f->vaddr);\n\t\t\t\t}\n\t\t\t}\n\t\t\tr_cons_printf (\"]}\");\n\t\t} else if (IS_MODE_CLASSDUMP (mode)) {\n\t\t\tchar *rp = NULL;\n\t\t\tif (c) {\n\t\t\t\t//TODO -> Print Superclass\n\t\t\t\tr_cons_printf (\"@interface %s :  \\n{\\n\", c->name);\n\t\t\t\tr_list_foreach (c->fields, iter2, f) {\n\t\t\t\t\tif (f->name && r_regex_match (\"ivar\",\"e\", f->name)) {\n\t\t\t\t\t\tr_cons_printf (\"  %s %s\\n\", f->type, f->name);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tr_cons_printf (\"}\\n\");\n\t\t\t\tr_list_foreach (c->methods, iter3, sym) {\n\t\t\t\t\tif (sym->rtype && sym->rtype[0] != '@') {\n\t\t\t\t\t\trp = get_rp (sym->rtype);\n\t\t\t\t\t\tr_cons_printf (\"%s (%s) %s\\n\", strncmp (sym->type,\"METH\",4) ? \"+\": \"-\", rp, sym->dname? sym->dname: sym->name);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tr_cons_printf (\"@end\\n\");\n\t\t\t}\n\t\t} else {\n\t\t\tint m = 0;\n\t\t\tr_cons_printf (\"0x%08\"PFMT64x\" [0x%08\"PFMT64x\" - 0x%08\"PFMT64x\"] (sz %\"PFMT64d\") class %d %s\",\n\t\t\t\tc->addr, at_min, at_max, (at_max - at_min), c->index, c->name);\n\t\t\tif (c->super) {\n\t\t\t\tr_cons_printf (\" super: %s\\n\", c->super);\n\t\t\t} else {\n\t\t\t\tr_cons_newline ();\n\t\t\t}\n\t\t\tr_list_foreach (c->methods, iter2, sym) {\n\t\t\t\tchar *mflags = r_core_bin_method_flags_str (sym->method_flags, mode);\n\t\t\t\tr_cons_printf (\"0x%08\"PFMT64x\" method %d %s %s\\n\",\n\t\t\t\t\tsym->vaddr, m, mflags, sym->dname? sym->dname: sym->name);\n\t\t\t\tR_FREE (mflags);\n\t\t\t\tm++;\n\t\t\t}\n\t\t}\n\t\tfree (name);\n\t}\n\tif (IS_MODE_JSON (mode)) {\n\t\tr_cons_print (\"]\");\n\t}\n\n\treturn true;\n}\n\nstatic int bin_size(RCore *r, int mode) {\n\tut64 size = r_bin_get_size (r->bin);\n\tif (IS_MODE_SIMPLE (mode) || IS_MODE_JSON (mode)) {\n\t\tr_cons_printf (\"%\"PFMT64u\"\\n\", size);\n\t} else if (IS_MODE_RAD (mode)) {\n\t\tr_cons_printf (\"f bin_size @ %\"PFMT64u\"\\n\", size);\n\t} else if (IS_MODE_SET (mode)) {\n\t\tr_core_cmdf (r, \"f bin_size @ %\"PFMT64u\"\\n\", size);\n\t} else {\n\t\tr_cons_printf (\"%\"PFMT64u\"\\n\", size);\n\t}\n\treturn true;\n}\n\nstatic int bin_libs(RCore *r, int mode) {\n\tRList *libs;\n\tRListIter *iter;\n\tchar* lib;\n\tint i = 0;\n\n\tif (!(libs = r_bin_get_libs (r->bin))) {\n\t\treturn false;\n\t}\n\tif (IS_MODE_JSON (mode)) {\n\t\tr_cons_print (\"[\");\n\t} else if (IS_MODE_NORMAL (mode)) {\n\t\tr_cons_println (\"[Linked libraries]\");\n\t}\n\tr_list_foreach (libs, iter, lib) {\n\t\tif (IS_MODE_SET (mode)) {\n\t\t\t// Nothing to set.\n\t\t\t// TODO: load libraries with iomaps?\n\t\t} else if (IS_MODE_RAD (mode)) {\n\t\t\tr_cons_printf (\"CCa entry0 %s\\n\", lib);\n\t\t} else if (IS_MODE_JSON (mode)) {\n\t\t\tr_cons_printf (\"%s\\\"%s\\\"\", iter->p ? \",\" : \"\", lib);\n\t\t} else {\n\t\t\t// simple and normal print mode\n\t\t\tr_cons_println (lib);\n\t\t}\n\t\ti++;\n\t}\n\tif (IS_MODE_JSON (mode)) {\n\t\tr_cons_print (\"]\");\n\t} else if (IS_MODE_NORMAL (mode)) {\n\t\tif (i == 1) {\n\t\t\tr_cons_printf (\"\\n%i library\\n\", i);\n\t\t} else {\n\t\t\tr_cons_printf (\"\\n%i libraries\\n\", i);\n\t\t}\n\t}\n\treturn true;\n}\n\nstatic void bin_mem_print(RList *mems, int perms, int depth, int mode) {\n\tRBinMem *mem;\n\tRListIter *iter;\n\tif (!mems) {\n\t\treturn;\n\t}\n\tr_list_foreach (mems, iter, mem) {\n\t\tif (IS_MODE_JSON (mode)) {\n\t\t\tr_cons_printf (\"{\\\"name\\\":\\\"%s\\\",\\\"size\\\":%d,\\\"address\\\":%d,\"\n\t\t\t\t\t\"\\\"flags\\\":\\\"%s\\\"}\", mem->name, mem->size,\n\t\t\t\t\tmem->addr, r_str_rwx_i (mem->perms & perms));\n\t\t} else if (IS_MODE_SIMPLE (mode)) {\n\t\t\tr_cons_printf (\"0x%08\"PFMT64x\"\\n\", mem->addr);\n\t\t} else {\n\t\t\tr_cons_printf (\"0x%08\"PFMT64x\" +0x%04x %s %*s%-*s\\n\",\n\t\t\t\t\tmem->addr, mem->size, r_str_rwx_i (mem->perms & perms),\n\t\t\t\t\tdepth, \"\", 20-depth, mem->name);\n\t\t}\n\t\tif (mem->mirrors) {\n\t\t\tif (IS_MODE_JSON (mode)) {\n\t\t\t\tr_cons_printf (\",\");\n\t\t\t}\n\t\t\tbin_mem_print (mem->mirrors, mem->perms & perms, depth + 1, mode);\n\t\t}\n\t\tif (IS_MODE_JSON(mode)) {\n\t\t\tif (iter->n) {\n\t\t\t\tr_cons_printf (\",\");\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic int bin_mem(RCore *r, int mode) {\n\tRList *mem = NULL;\n\tif (!r)\treturn false;\n\tif (!IS_MODE_JSON(mode)) {\n\t\tif (!(IS_MODE_RAD (mode) || IS_MODE_SET (mode))) {\n\t\t\tr_cons_println (\"[Memory]\\n\");\n\t\t}\n\t}\n\tif (!(mem = r_bin_get_mem (r->bin))) {\n\t\tif (IS_MODE_JSON (mode)) {\n\t\t\tr_cons_print(\"[]\");\n\t\t}\n\t\treturn false;\n\t}\n\tif (IS_MODE_JSON (mode)) {\n\t\tr_cons_print (\"[\");\n\t\tbin_mem_print (mem, 7, 0, R_CORE_BIN_JSON);\n\t\tr_cons_println (\"]\");\n\t\treturn true;\n\t} else if (!(IS_MODE_RAD (mode) || IS_MODE_SET (mode))) {\n\t\tbin_mem_print (mem, 7, 0, mode);\n\t}\n\treturn true;\n}\n\nstatic void bin_pe_versioninfo(RCore *r, int mode) {\n\tSdb *sdb = NULL;\n\tint num_version = 0;\n\tint num_stringtable = 0;\n\tint num_string = 0;\n\tconst char *format_version = \"bin/cur/info/vs_version_info/VS_VERSIONINFO%d\";\n\tconst char *format_stringtable = \"%s/string_file_info/stringtable%d\";\n\tconst char *format_string = \"%s/string%d\";\n\tif (!IS_MODE_JSON (mode)) {\n\t\tr_cons_printf (\"=== VS_VERSIONINFO ===\\n\\n\");\n\t}\n\tbool firstit_dowhile = true;\n\tdo {\n\t\tchar path_version[256] = R_EMPTY;\n\t\tsnprintf (path_version, sizeof (path_version), format_version, num_version);\n\t\tif (!(sdb = sdb_ns_path (r->sdb, path_version, 0))) {\n\t\t\tbreak;\n\t\t}\n\t\tif (!firstit_dowhile && IS_MODE_JSON (mode)) { r_cons_printf (\",\"); }\n\t\tif (IS_MODE_JSON (mode)) {\n\t\t\tr_cons_printf (\"{\\\"VS_FIXEDFILEINFO\\\":{\");\n\t\t} else {\n\t\t\tr_cons_printf (\"# VS_FIXEDFILEINFO\\n\\n\");\n\t\t}\n\t\tchar path_fixedfileinfo[256] = R_EMPTY;\n\t\tsnprintf (path_fixedfileinfo, sizeof (path_fixedfileinfo), \"%s/fixed_file_info\", path_version);\n\t\tif (!(sdb = sdb_ns_path (r->sdb, path_fixedfileinfo, 0))) {\n\t\t\tr_cons_printf (\"}\");\n\t\t\tbreak;\n\t\t}\n\t\tif (IS_MODE_JSON (mode)) {\n\t\t\tr_cons_printf (\"\\\"Signature\\\":%\"PFMT64u\",\", sdb_num_get (sdb, \"Signature\", 0));\n\t\t} else {\n\t\t\tr_cons_printf (\"  Signature: 0x%\"PFMT64x\"\\n\", sdb_num_get (sdb, \"Signature\", 0));\n\t\t}\n\t\tif (IS_MODE_JSON (mode)) {\n\t\t\tr_cons_printf (\"\\\"StrucVersion\\\":%\"PFMT64u\",\", sdb_num_get (sdb, \"StrucVersion\", 0));\n\t\t} else {\n\t\t\tr_cons_printf (\"  StrucVersion: 0x%\"PFMT64x\"\\n\", sdb_num_get (sdb, \"StrucVersion\", 0));\n\t\t}\n\t\tif (IS_MODE_JSON (mode)) {\n\t\t\tr_cons_printf (\"\\\"FileVersion\\\":\\\"%\"PFMT64d\".%\"PFMT64d\".%\"PFMT64d\".%\"PFMT64d\"\\\",\",\n\t\t\t\tsdb_num_get (sdb, \"FileVersionMS\", 0) >> 16,\n\t\t\t\tsdb_num_get (sdb, \"FileVersionMS\", 0) & 0xFFFF,\n\t\t\t\tsdb_num_get (sdb, \"FileVersionLS\", 0) >> 16,\n\t\t\t\tsdb_num_get (sdb, \"FileVersionLS\", 0) & 0xFFFF);\n\t\t} else {\n\t\t\tr_cons_printf (\"  FileVersion: %\"PFMT64d\".%\"PFMT64d\".%\"PFMT64d\".%\"PFMT64d\"\\n\",\n\t\t\t\tsdb_num_get (sdb, \"FileVersionMS\", 0) >> 16,\n\t\t\t\tsdb_num_get (sdb, \"FileVersionMS\", 0) & 0xFFFF,\n\t\t\t\tsdb_num_get (sdb, \"FileVersionLS\", 0) >> 16,\n\t\t\t\tsdb_num_get (sdb, \"FileVersionLS\", 0) & 0xFFFF);\n\t\t}\n\t\tif (IS_MODE_JSON (mode)) {\n\t\t\tr_cons_printf (\"\\\"ProductVersion\\\":\\\"%\"PFMT64d\".%\"PFMT64d\".%\"PFMT64d\".%\"PFMT64d\"\\\",\",\n\t\t\t\tsdb_num_get (sdb, \"ProductVersionMS\", 0) >> 16,\n\t\t\t\tsdb_num_get (sdb, \"ProductVersionMS\", 0) & 0xFFFF,\n\t\t\t\tsdb_num_get (sdb, \"ProductVersionLS\", 0) >> 16,\n\t\t\t\tsdb_num_get (sdb, \"ProductVersionLS\", 0) & 0xFFFF);\n\t\t} else {\n\t\t\tr_cons_printf (\"  ProductVersion: %\"PFMT64d\".%\"PFMT64d\".%\"PFMT64d\".%\"PFMT64d\"\\n\",\n\t\t\t\tsdb_num_get (sdb, \"ProductVersionMS\", 0) >> 16,\n\t\t\t\tsdb_num_get (sdb, \"ProductVersionMS\", 0) & 0xFFFF,\n\t\t\t\tsdb_num_get (sdb, \"ProductVersionLS\", 0) >> 16,\n\t\t\t\tsdb_num_get (sdb, \"ProductVersionLS\", 0) & 0xFFFF);\n\t\t}\n\t\tif (IS_MODE_JSON (mode)) {\n\t\t\tr_cons_printf (\"\\\"FileFlagsMask\\\":%\"PFMT64u\",\", sdb_num_get (sdb, \"FileFlagsMask\", 0));\n\t\t} else {\n\t\t\tr_cons_printf (\"  FileFlagsMask: 0x%\"PFMT64x\"\\n\", sdb_num_get (sdb, \"FileFlagsMask\", 0));\n\t\t}\n\t\tif (IS_MODE_JSON (mode)) {\n\t\t\tr_cons_printf (\"\\\"FileFlags\\\":%\"PFMT64u\",\", sdb_num_get (sdb, \"FileFlags\", 0));\n\t\t} else {\n\t\t\tr_cons_printf (\"  FileFlags: 0x%\"PFMT64x\"\\n\", sdb_num_get (sdb, \"FileFlags\", 0));\n\t\t}\n\t\tif (IS_MODE_JSON (mode)) {\n\t\t\tr_cons_printf (\"\\\"FileOS\\\":%\"PFMT64u\",\", sdb_num_get (sdb, \"FileOS\", 0));\n\t\t} else {\n\t\t\tr_cons_printf (\"  FileOS: 0x%\"PFMT64x\"\\n\", sdb_num_get (sdb, \"FileOS\", 0));\n\t\t}\n\t\tif (IS_MODE_JSON (mode)) {\n\t\t\tr_cons_printf (\"\\\"FileType\\\":%\"PFMT64u\",\", sdb_num_get (sdb, \"FileType\", 0));\n\t\t} else {\n\t\t\tr_cons_printf (\"  FileType: 0x%\"PFMT64x\"\\n\", sdb_num_get (sdb, \"FileType\", 0));\n\t\t}\n\t\tif (IS_MODE_JSON (mode)) {\n\t\t\tr_cons_printf (\"\\\"FileSubType\\\":%\"PFMT64u, sdb_num_get (sdb, \"FileSubType\", 0));\n\t\t} else {\n\t\t\tr_cons_printf (\"  FileSubType: 0x%\"PFMT64x\"\\n\", sdb_num_get (sdb, \"FileSubType\", 0));\n\t\t}\n#if 0\n\t\tr_cons_printf (\"  FileDate: %d.%d.%d.%d\\n\",\n\t\t\tsdb_num_get (sdb, \"FileDateMS\", 0) >> 16,\n\t\t\tsdb_num_get (sdb, \"FileDateMS\", 0) & 0xFFFF,\n\t\t\tsdb_num_get (sdb, \"FileDateLS\", 0) >> 16,\n\t\t\tsdb_num_get (sdb, \"FileDateLS\", 0) & 0xFFFF);\n#endif\n\t\tif (IS_MODE_JSON (mode)) {\n\t\t\tr_cons_printf (\"},\");\n\t\t} else {\n\t\t\tr_cons_newline ();\n\t\t}\n\t\tif (IS_MODE_JSON (mode)) {\n\t\t\tr_cons_printf (\"\\\"StringTable\\\":{\");\n\t\t} else {\n\t\t\tr_cons_printf (\"# StringTable\\n\\n\");\n\t\t}\n\t\tfor (num_stringtable = 0; sdb; num_stringtable++) {\n\t\t\tchar path_stringtable[256] = R_EMPTY;\n\t\t\tsnprintf (path_stringtable, sizeof (path_stringtable), format_stringtable, path_version, num_stringtable);\n\t\t\tsdb = sdb_ns_path (r->sdb, path_stringtable, 0);\n\t\t\tbool firstit_for = true;\n\t\t\tfor (num_string = 0; sdb; num_string++) {\n\t\t\t\tchar path_string[256] = R_EMPTY;\n\t\t\t\tsnprintf (path_string, sizeof (path_string), format_string, path_stringtable, num_string);\n\t\t\t\tsdb = sdb_ns_path (r->sdb, path_string, 0);\n\t\t\t\tif (sdb) {\n\t\t\t\t\tif (!firstit_for && IS_MODE_JSON (mode)) { r_cons_printf (\",\"); }\n\t\t\t\t\tint lenkey = 0;\n\t\t\t\t\tint lenval = 0;\n\t\t\t\t\tut8 *key_utf16 = sdb_decode (sdb_const_get (sdb, \"key\", 0), &lenkey);\n\t\t\t\t\tut8 *val_utf16 = sdb_decode (sdb_const_get (sdb, \"value\", 0), &lenval);\n\t\t\t\t\tut8 *key_utf8 = calloc (lenkey * 2, 1);\n\t\t\t\t\tut8 *val_utf8 = calloc (lenval * 2, 1);\n\n\t\t\t\t\tif (r_str_utf16_to_utf8 (key_utf8, lenkey * 2, key_utf16, lenkey, true) < 0\n\t\t\t\t\t\t|| r_str_utf16_to_utf8 (val_utf8, lenval * 2, val_utf16, lenval, true) < 0) {\n\t\t\t\t\t\teprintf (\"Warning: Cannot decode utf16 to utf8\\n\");\n\t\t\t\t\t} else if (IS_MODE_JSON (mode)) {\n\t\t\t\t\t\tchar *escaped_key_utf8 = r_str_escape ((char*)key_utf8);\n\t\t\t\t\t\tchar *escaped_val_utf8 = r_str_escape ((char*)val_utf8);\n\t\t\t\t\t\tr_cons_printf (\"\\\"%s\\\":\\\"%s\\\"\", escaped_key_utf8, escaped_val_utf8);\n\t\t\t\t\t\tfree (escaped_key_utf8);\n\t\t\t\t\t\tfree (escaped_val_utf8);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tr_cons_printf (\"  %s: %s\\n\", (char*)key_utf8, (char*)val_utf8);\n\t\t\t\t\t}\n\n\t\t\t\t\tfree (key_utf8);\n\t\t\t\t\tfree (val_utf8);\n\t\t\t\t\tfree (key_utf16);\n\t\t\t\t\tfree (val_utf16);\n\t\t\t\t}\n\t\t\t\tfirstit_for = false;\n\t\t\t}\n\t\t}\n\t\tif (IS_MODE_JSON (mode)) {\n\t\t\tr_cons_printf (\"}}\");\n\t\t}\n\t\tnum_version++;\n\t\tfirstit_dowhile = false;\n\t} while (sdb);\n}\n\nstatic void bin_elf_versioninfo(RCore *r, int mode) {\n\tconst char *format = \"bin/cur/info/versioninfo/%s%d\";\n\tchar path[256] = {0};\n\tint num_versym = 0;\n\tint num_verneed = 0;\n\tint num_version = 0;\n\tSdb *sdb = NULL;\n\tconst char *oValue = NULL;\n\tbool firstit_for_versym = true;\n\tif (IS_MODE_JSON (mode)) {\n\t\tr_cons_printf (\"{\\\"versym\\\":[\");\n\t}\n\tfor (;; num_versym++) {\n\t\tsnprintf (path, sizeof (path), format, \"versym\", num_versym);\n\t\tif (!(sdb = sdb_ns_path (r->sdb, path, 0))) {\n\t\t\tbreak;\n\t\t}\n\t\tut64 addr = sdb_num_get (sdb, \"addr\", 0);\n\t\tut64 offset = sdb_num_get (sdb, \"offset\", 0);\n\t\tut64 link = sdb_num_get (sdb, \"link\", 0);\n\t\tut64 num_entries = sdb_num_get (sdb, \"num_entries\", 0);\n\t\tconst char *section_name = sdb_const_get (sdb, \"section_name\", 0);\n\t\tconst char *link_section_name = sdb_const_get (sdb, \"link_section_name\", 0);\n\n\t\tif (IS_MODE_JSON (mode)) {\n\t\t\tif (!firstit_for_versym) { r_cons_printf (\",\"); }\n\t\t\tr_cons_printf (\"{\\\"section_name\\\":\\\"%s\\\",\\\"address\\\":%\"PFMT64u\",\\\"offset\\\":%\"PFMT64u\",\",\n\t\t\t\t\tsection_name, (ut64)addr, (ut64)offset);\n\t\t\tr_cons_printf (\"\\\"link\\\":%\"PFMT64u\",\\\"link_section_name\\\":\\\"%s\\\",\\\"entries\\\":[\",\n\t\t\t\t\t(ut32)link, link_section_name);\n\t\t} else {\n\t\t\tr_cons_printf (\"Version symbols section '%s' contains %\"PFMT64u\" entries:\\n\", section_name, num_entries);\n\t\t\tr_cons_printf (\" Addr: 0x%08\"PFMT64x\"  Offset: 0x%08\"PFMT64x\"  Link: %x (%s)\\n\",\n\t\t\t\t(ut64)addr, (ut64)offset, (ut32)link, link_section_name);\n\t\t}\n\t\tint i;\n\t\tfor (i = 0; i < num_entries; i++) {\n\t\t\tchar key[32] = R_EMPTY;\n\t\t\tsnprintf (key, sizeof (key), \"entry%d\", i);\n\t\t\tconst char *value = sdb_const_get (sdb, key, 0);\n\t\t\tif (value) {\n\t\t\t\tif (oValue && !strcmp (value, oValue)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (IS_MODE_JSON (mode)) {\n\t\t\t\t\tif (i > 0) { r_cons_printf (\",\"); }\n\t\t\t\t\tchar *escaped_value = r_str_escape (value);\n\t\t\t\t\tr_cons_printf (\"{\\\"idx\\\":%\"PFMT64u\",\\\"value\\\":\\\"%s\\\"}\",\n\t\t\t\t\t\t\t(ut64) i, escaped_value);\n\t\t\t\t\tfree (escaped_value);\n\t\t\t\t} else {\n\t\t\t\t\tr_cons_printf (\"  0x%08\"PFMT64x\": \", (ut64) i);\n\t\t\t\t\tr_cons_printf (\"%s\\n\", value);\n\t\t\t\t}\n\t\t\t\toValue = value;\n\t\t\t}\n\t\t}\n\t\tif (IS_MODE_JSON (mode)) {\n\t\t\tr_cons_printf (\"]}\");\n\t\t} else {\n\t\t\tr_cons_printf (\"\\n\\n\");\n\t\t}\n\t\tfirstit_for_versym = false;\n\t}\n\tif (IS_MODE_JSON (mode)) { r_cons_printf (\"],\\\"verneed\\\":[\"); }\n\n\tbool firstit_dowhile_verneed = true;\n\tdo {\n\t\tchar path_version[256] = R_EMPTY;\n\t\tsnprintf (path, sizeof (path), format, \"verneed\", num_verneed++);\n\t\tif (!(sdb = sdb_ns_path (r->sdb, path, 0))) {\n\t\t\tbreak;\n\t\t}\n\n\t\tif (IS_MODE_JSON (mode)) {\n\t\t\tif (!firstit_dowhile_verneed) { r_cons_printf (\",\"); }\n\t\t\tr_cons_printf (\"{\\\"section_name\\\":\\\"%s\\\",\\\"address\\\":%\"PFMT64u\",\\\"offset\\\":%\"PFMT64u\",\",\n\t\t\t\tsdb_const_get (sdb, \"section_name\", 0), sdb_num_get (sdb, \"addr\", 0), sdb_num_get (sdb, \"offset\", 0));\n\t\t\tr_cons_printf (\"\\\"link\\\":%\"PFMT64u\",\\\"link_section_name\\\":\\\"%s\\\",\\\"entries\\\":[\",\n\t\t\t\tsdb_num_get (sdb, \"link\", 0), sdb_const_get (sdb, \"link_section_name\", 0));\n\t\t} else {\n\t\t\tr_cons_printf (\"Version need section '%s' contains %d entries:\\n\",\n\t\t\t\tsdb_const_get (sdb, \"section_name\", 0), (int)sdb_num_get (sdb, \"num_entries\", 0));\n\n\t\t\tr_cons_printf (\" Addr: 0x%08\"PFMT64x, sdb_num_get (sdb, \"addr\", 0));\n\n\t\t\tr_cons_printf (\"  Offset: 0x%08\"PFMT64x\"  Link to section: %\"PFMT64d\" (%s)\\n\",\n\t\t\t\tsdb_num_get (sdb, \"offset\", 0), sdb_num_get (sdb, \"link\", 0),\n\t\t\t\tsdb_const_get (sdb, \"link_section_name\", 0));\n\t\t}\n\t\tbool firstit_for_verneed = true;\n\t\tfor (num_version = 0;; num_version++) {\n\t\t\tsnprintf (path_version, sizeof (path_version), \"%s/version%d\", path, num_version);\n\t\t\tconst char *filename = NULL;\n\t\t\tchar path_vernaux[256] = R_EMPTY;\n\t\t\tint num_vernaux = 0;\n\t\t\tif (!(sdb = sdb_ns_path (r->sdb, path_version, 0))) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (IS_MODE_JSON (mode)) {\n\t\t\t\tif (!firstit_for_verneed) { r_cons_printf (\",\"); }\n\t\t\t\tr_cons_printf (\"{\\\"idx\\\":%\"PFMT64u\",\\\"vn_version\\\":%d,\",\n\t\t\t\t\tsdb_num_get (sdb, \"idx\", 0), (int)sdb_num_get (sdb, \"vn_version\", 0));\n\t\t\t} else {\n\t\t\t\tr_cons_printf (\"  0x%08\"PFMT64x\": Version: %d\",\n\t\t\t\t\tsdb_num_get (sdb, \"idx\", 0), (int)sdb_num_get (sdb, \"vn_version\", 0));\n\t\t\t}\n\n\t\t\tif ((filename = sdb_const_get (sdb, \"file_name\", 0))) {\n\t\t\t\tif (IS_MODE_JSON (mode)) {\n\t\t\t\t\tchar *escaped_filename = r_str_escape (filename);\n\t\t\t\t\tr_cons_printf (\"\\\"file_name\\\":\\\"%s\\\",\", escaped_filename);\n\t\t\t\t\tfree (escaped_filename);\n\t\t\t\t} else {\n\t\t\t\t\tr_cons_printf (\"  File: %s\", filename);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (IS_MODE_JSON (mode)) {\n\t\t\t\tr_cons_printf (\"\\\"cnt\\\":%d,\", (int)sdb_num_get (sdb, \"cnt\", 0));\n\t\t\t} else {\n\t\t\t\tr_cons_printf (\"  Cnt: %d\\n\", (int)sdb_num_get (sdb, \"cnt\", 0));\n\t\t\t}\n\t\t\tif (IS_MODE_JSON (mode)) {\n\t\t\t\tr_cons_printf (\"\\\"vernaux\\\":[\");\n\t\t\t}\n\t\t\tbool firstit_dowhile_vernaux = true;\n\t\t\tdo {\n\t\t\t\tsnprintf (path_vernaux, sizeof (path_vernaux), \"%s/vernaux%d\",\n\t\t\t\t\tpath_version, num_vernaux++);\n\t\t\t\tif (!(sdb = sdb_ns_path (r->sdb, path_vernaux, 0))) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (IS_MODE_JSON (mode)) {\n\t\t\t\t\tif (!firstit_dowhile_vernaux) { r_cons_printf (\",\"); }\n\t\t\t\t\tr_cons_printf (\"{\\\"idx\\\":%\"PFMT64x\",\\\"name\\\":\\\"%s\\\",\",\n\t\t\t\t\t\tsdb_num_get (sdb, \"idx\", 0), sdb_const_get (sdb, \"name\", 0));\n\t\t\t\t\tr_cons_printf (\"\\\"flags\\\":\\\"%s\\\",\\\"version\\\":%d}\",\n\t\t\t\t\t\tsdb_const_get (sdb, \"flags\", 0), (int)sdb_num_get (sdb, \"version\", 0));\n\t\t\t\t} else {\n\t\t\t\t\tr_cons_printf (\"  0x%08\"PFMT64x\":   Name: %s\",\n\t\t\t\t\t\tsdb_num_get (sdb, \"idx\", 0), sdb_const_get (sdb, \"name\", 0));\n\t\t\t\t\tr_cons_printf (\"  Flags: %s Version: %d\\n\",\n\t\t\t\t\t\tsdb_const_get (sdb, \"flags\", 0), (int)sdb_num_get (sdb, \"version\", 0));\n\t\t\t\t}\n\t\t\t\tfirstit_dowhile_vernaux = false;\n\t\t\t} while (sdb);\n\t\t\tif (IS_MODE_JSON (mode)) { r_cons_printf (\"]}\"); };\n\t\t\tfirstit_for_verneed = false;\n\t\t}\n\t\tif (IS_MODE_JSON (mode)) { r_cons_printf (\"]}\"); };\n\t\tfirstit_dowhile_verneed = false;\n\t} while (sdb);\n\tif (IS_MODE_JSON (mode)) { r_cons_printf (\"]}\"); }\n}\n\nstatic void bin_mach0_versioninfo(RCore *r) {\n\t/* TODO */\n}\n\nstatic void bin_pe_resources(RCore *r, int mode) {\n\tSdb *sdb = NULL;\n\tint index = 0;\n\tconst char *pe_path = \"bin/cur/info/pe_resource\";\n\tif (!(sdb = sdb_ns_path (r->sdb, pe_path, 0))) {\n\t\treturn;\n\t}\n\tif (IS_MODE_SET (mode)) {\n\t\tr_flag_space_set (r->flags, \"resources\");\n\t} else if (IS_MODE_RAD (mode)) {\n\t\tr_cons_printf (\"fs resources\\n\");\n\t} else if (IS_MODE_JSON (mode)) {\n\t\tr_cons_printf (\"[\");\n\t}\n\twhile (true) {\n\t\tconst char *timestrKey = sdb_fmt (\"resource.%d.timestr\", index);\n\t\tconst char *vaddrKey = sdb_fmt (\"resource.%d.vaddr\", index);\n\t\tconst char *sizeKey  = sdb_fmt (\"resource.%d.size\", index);\n\t\tconst char *typeKey  = sdb_fmt (\"resource.%d.type\", index);\n\t\tconst char *languageKey = sdb_fmt (\"resource.%d.language\", index);\n\t\tconst char *nameKey = sdb_fmt (\"resource.%d.name\", index);\n\t\tchar *timestr = sdb_get (sdb, timestrKey, 0);\n\t\tif (!timestr) {\n\t\t\tbreak;\n\t\t}\n\t\tut64 vaddr = sdb_num_get (sdb, vaddrKey, 0);\n\t\tint size = (int)sdb_num_get (sdb, sizeKey, 0);\n\t\tint name = (int)sdb_num_get (sdb, nameKey, 0);\n\t\tchar *type = sdb_get (sdb, typeKey, 0);\n\t\tchar *lang = sdb_get (sdb, languageKey, 0);\n\n\t\tif (IS_MODE_SET (mode)) {\n\t\t\tconst char *name = sdb_fmt (\"resource.%d\", index);\n\t\t\tr_flag_set (r->flags, name, vaddr, size);\n\t\t} else if (IS_MODE_RAD (mode)) {\n\t\t\tr_cons_printf (\"f resource.%d %d 0x%08\"PFMT32x\"\\n\", index, size, vaddr);\n\t\t} else if (IS_MODE_JSON (mode)) {\n\t\t\tr_cons_printf(\"%s{\\\"name\\\":%d,\\\"index\\\":%d, \\\"type\\\":\\\"%s\\\",\"\n\t\t\t\t\t\"\\\"vaddr\\\":%\"PFMT64d\", \\\"size\\\":%d, \\\"lang\\\":\\\"%s\\\"}\",\n\t\t\t\t\tindex? \",\": \"\", name, index, type, vaddr, size, lang);\n\t\t} else {\n\t\t\tchar *humanSize = r_num_units (NULL, size);\n\t\t\tr_cons_printf (\"Resource %d\\n\", index);\n\t\t\tr_cons_printf (\"  name: %d\\n\", name);\n\t\t\tr_cons_printf (\"  timestamp: %s\\n\", timestr);\n\t\t\tr_cons_printf (\"  vaddr: 0x%08\"PFMT64x\"\\n\", vaddr);\n\t\t\tif (humanSize) {\n\t\t\t\tr_cons_printf (\"  size: %s\\n\", humanSize);\n\t\t\t}\n\t\t\tr_cons_printf (\"  type: %s\\n\", type);\n\t\t\tr_cons_printf (\"  language: %s\\n\", lang);\n\t\t\tfree (humanSize);\n\t\t}\n\n\t\tR_FREE (timestr);\n\t\tR_FREE (type);\n\t\tR_FREE (lang)\n\n\t\tindex++;\n\t}\n\tif (IS_MODE_JSON (mode)) {\n\t\tr_cons_printf (\"]\");\n\t} else if (IS_MODE_RAD (mode)) {\n\t\tr_cons_printf (\"fs *\");\n\t}\n}\n\nstatic void bin_no_resources(RCore *r, int mode) {\n\tif (IS_MODE_JSON (mode)) {\n\t\tr_cons_printf (\"[]\");\n\t}\n}\n\nstatic int bin_resources(RCore *r, int mode) {\n\tconst RBinInfo *info = r_bin_get_info (r->bin);\n\tif (!info || !info->rclass) {\n\t\treturn false;\n\t}\n\tif (!strncmp (\"pe\", info->rclass, 2)) {\n\t\tbin_pe_resources (r, mode);\n\t} else {\n\t\tbin_no_resources (r, mode);\n\t}\n\treturn true;\n}\n\nstatic int bin_versioninfo(RCore *r, int mode) {\n\tconst RBinInfo *info = r_bin_get_info (r->bin);\n\tif (!info || !info->rclass) {\n\t\treturn false;\n\t}\n\tif (!strncmp (\"pe\", info->rclass, 2)) {\n\t\tbin_pe_versioninfo (r, mode);\n\t} else if (!strncmp (\"elf\", info->rclass, 3)) {\n\t\tbin_elf_versioninfo (r, mode);\n\t} else if (!strncmp (\"mach0\", info->rclass, 5)) {\n\t\tbin_mach0_versioninfo (r);\n\t} else {\n\t\tr_cons_println (\"Unknown format\");\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic int bin_signature(RCore *r, int mode) {\n\tRBinFile *cur = r_bin_cur (r->bin);\n\tRBinPlugin *plg = r_bin_file_cur_plugin (cur);\n\tif (plg && plg->signature) {\n\t\tconst char *signature = plg->signature (cur, IS_MODE_JSON (mode));\n\t\tr_cons_println (signature);\n\t\tfree ((char*) signature);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n\nR_API void r_core_bin_export_info_rad(RCore *core) {\n\tSdb *db = NULL;\n\tchar *flagname = NULL, *offset = NULL;\n\tRBinFile *bf = r_core_bin_cur (core);\n\tif (!bf) {\n\t\treturn;\n\t}\n\tdb = sdb_ns (bf->sdb, \"info\", 0);;\n\tif (!db) {\n\t\treturn;\n\t}\n\tif (db) {\n\t\tSdbListIter *iter;\n\t\tSdbKv *kv;\n\t\tr_cons_printf (\"fs format\\n\");\n\t\t// iterate over all keys\n\t\tSdbList *ls = sdb_foreach_list (db, false);\n\t\tls_foreach (ls, iter, kv) {\n\t\t\tchar *k = kv->key;\n\t\t\tchar *v = kv->value;\n\t\t\tchar *dup = strdup (k);\n\t\t\t//printf (\"?e (%s) (%s)\\n\", k, v);\n\t\t\tif ((flagname = strstr (dup, \".offset\"))) {\n\t\t\t\t*flagname = 0;\n\t\t\t\tflagname = dup;\n\t\t\t\tr_cons_printf (\"f %s @ %s\\n\", flagname, v);\n\t\t\t\tfree (offset);\n\t\t\t\toffset = strdup (v);\n\t\t\t}\n\t\t\tif ((flagname = strstr (dup, \".cparse\"))) {\n\t\t\t\tr_cons_printf (\"\\\"td %s\\\"\\n\", v);\n\t\t\t}\n\t\t\tfree (dup);\n\t\t}\n\t\tR_FREE (offset);\n\t\tls_foreach (ls, iter, kv) {\n\t\t\tchar *k = kv->key;\n\t\t\tchar *v = kv->value;\n\t\t\tchar *dup = strdup (k);\n\t\t\tif ((flagname = strstr (dup, \".format\"))) {\n\t\t\t\t*flagname = 0;\n\t\t\t\tif (!offset) {\n\t\t\t\t\toffset = strdup (\"0\");\n\t\t\t\t}\n\t\t\t\tflagname = dup;\n\t\t\t\tr_cons_printf (\"pf.%s %s\\n\", flagname, v);\n\t\t\t}\n\t\t\tfree (dup);\n\t\t}\n\t\tls_foreach (ls, iter, kv) {\n\t\t\tchar *k = kv->key;\n\t\t\tchar *v = kv->value;\n\t\t\tchar *dup = strdup (k);\n\t\t\tif ((flagname = strstr (dup, \".format\"))) {\n\t\t\t\t*flagname = 0;\n\t\t\t\tif (!offset) {\n\t\t\t\t\toffset = strdup (\"0\");\n\t\t\t\t}\n\t\t\t\tflagname = dup;\n\t\t\t\tint fmtsize = r_print_format_struct_size (v, core->print, 0, 0);\n\t\t\t\tchar *offset_key = r_str_newf (\"%s.offset\", flagname);\n\t\t\t\tconst char *off = sdb_const_get (db, offset_key, 0);\n\t\t\t\tfree (offset_key);\n\t\t\t\tif (off) {\n\t\t\t\t\tr_cons_printf (\"Cf %d %s @ %s\\n\", fmtsize, v, off);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ((flagname = strstr (dup, \".size\"))) {\n\t\t\t\t*flagname = 0;\n\t\t\t\tflagname = dup;\n\t\t\t\tr_cons_printf (\"fl %s %s\\n\", flagname, v);\n\t\t\t}\n\t\t}\n\t\tfree (offset);\n\t}\n}\n\nstatic int bin_header(RCore *r, int mode) {\n\tRBinFile *cur = r_bin_cur (r->bin);\n\tRBinPlugin *plg = r_bin_file_cur_plugin (cur);\n\tif (plg && plg->header) {\n\t\tplg->header (cur);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nR_API int r_core_bin_info(RCore *core, int action, int mode, int va, RCoreBinFilter *filter, const char *chksum) {\n\tint ret = true;\n\tconst char *name = NULL;\n\tut64 at = 0, loadaddr = r_bin_get_laddr (core->bin);\n\tif (filter && filter->offset) {\n\t\tat = filter->offset;\n\t}\n\tif (filter && filter->name) {\n\t\tname = filter->name;\n\t}\n\t\n\t// use our internal values for va\n\tva = va ? VA_TRUE : VA_FALSE;\n#if 0\n\tif (r_config_get_i (core->config, \"anal.strings\")) {\n\t\tr_core_cmd0 (core, \"aar\");\n\t}\n#endif\n\tif ((action & R_CORE_BIN_ACC_STRINGS)) ret &= bin_strings (core, mode, va);\n\tif ((action & R_CORE_BIN_ACC_RAW_STRINGS)) ret &= bin_raw_strings (core, mode, va);\n\tif ((action & R_CORE_BIN_ACC_INFO)) ret &= bin_info (core, mode);\n\tif ((action & R_CORE_BIN_ACC_MAIN)) ret &= bin_main (core, mode, va);\n\tif ((action & R_CORE_BIN_ACC_DWARF)) ret &= bin_dwarf (core, mode);\n\tif ((action & R_CORE_BIN_ACC_PDB)) ret &= bin_pdb (core, mode);\n\tif ((action & R_CORE_BIN_ACC_ENTRIES)) ret &= bin_entry (core, mode, loadaddr, va, false);\n\tif ((action & R_CORE_BIN_ACC_INITFINI)) ret &= bin_entry (core, mode, loadaddr, va, true);\n\tif ((action & R_CORE_BIN_ACC_SECTIONS)) ret &= bin_sections (core, mode, loadaddr, va, at, name, chksum);\n\tif (r_config_get_i (core->config, \"bin.relocs\")) {\n\t\tif ((action & R_CORE_BIN_ACC_RELOCS)) ret &= bin_relocs (core, mode, va);\n\t}\n \tif ((action & R_CORE_BIN_ACC_IMPORTS)) ret &= bin_imports (core, mode, va, name); // 6s\n\tif ((action & R_CORE_BIN_ACC_EXPORTS)) ret &= bin_exports (core, mode, loadaddr, va, at, name, chksum);\n\tif ((action & R_CORE_BIN_ACC_SYMBOLS)) ret &= bin_symbols (core, mode, loadaddr, va, at, name, chksum); // 6s\n\tif ((action & R_CORE_BIN_ACC_LIBS)) ret &= bin_libs (core, mode);\n\tif ((action & R_CORE_BIN_ACC_CLASSES)) ret &= bin_classes (core, mode); // 3s\n\tif ((action & R_CORE_BIN_ACC_SIZE)) ret &= bin_size (core, mode);\n\tif ((action & R_CORE_BIN_ACC_MEM)) ret &= bin_mem (core, mode);\n\tif ((action & R_CORE_BIN_ACC_VERSIONINFO)) ret &= bin_versioninfo (core, mode);\n\tif ((action & R_CORE_BIN_ACC_RESOURCES)) ret &= bin_resources (core, mode);\n\tif ((action & R_CORE_BIN_ACC_SIGNATURE)) ret &= bin_signature (core, mode);\n\tif ((action & R_CORE_BIN_ACC_FIELDS)) {\n\t\tif (IS_MODE_SIMPLE (mode)) {\n\t\t\tif ((action & R_CORE_BIN_ACC_HEADER) || action & R_CORE_BIN_ACC_FIELDS) {\n\t\t\t\t/* ignore mode, just for quiet/simple here */\n\t\t\t\tret &= bin_fields (core, 0, va);\n\t\t\t}\n\t\t} else {\n\t\t\tif (IS_MODE_NORMAL (mode)) {\n\t\t\t\tret &= bin_header (core, mode);\n\t\t\t} else {\n\t\t\t\tif ((action & R_CORE_BIN_ACC_HEADER) || action & R_CORE_BIN_ACC_FIELDS) {\n\t\t\t\t\tret &= bin_fields (core, mode, va);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\nR_API int r_core_bin_set_arch_bits(RCore *r, const char *name, const char * arch, ut16 bits) {\n\tint fd = r_io_fd_get_current (r->io);\n\tRIODesc *desc = r_io_desc_get (r->io, fd);\n\tRBinFile *curfile, *binfile = NULL;\n\tif (!name) {\n\t\tname = (desc) ? desc->name : NULL;\n\t}\n\tif (!name) {\n\t\treturn false;\n\t}\n\t/* Check if the arch name is a valid name */\n\tif (!r_asm_is_valid (r->assembler, arch)) {\n\t\treturn false;\n\t}\n\t/* Find a file with the requested name/arch/bits */\n\tbinfile = r_bin_file_find_by_arch_bits (r->bin, arch, bits, name);\n\tif (!binfile) {\n\t\treturn false;\n\t}\n\tif (!r_bin_use_arch (r->bin, arch, bits, name)) {\n\t\treturn false;\n\t}\n\tcurfile = r_bin_cur (r->bin);\n\t//set env if the binfile changed or we are dealing with xtr\n\tif (curfile != binfile || binfile->curxtr) {\n\t\tr_core_bin_set_cur (r, binfile);\n\t\treturn r_core_bin_set_env (r, binfile);\n\t}\n\treturn true;\n}\n\nR_API int r_core_bin_update_arch_bits(RCore *r) {\n\tRBinFile *binfile = NULL;\n\tconst char *name = NULL, *arch = NULL;\n\tut16 bits = 0;\n\tif (!r) {\n\t\treturn 0;\n\t}\n\tif (r->assembler) {\n\t\tbits = r->assembler->bits;\n\t   \tif (r->assembler->cur) {\n\t\t\tarch = r->assembler->cur->arch;\n\t\t}\n\t}\n\tbinfile = r_core_bin_cur (r);\n\tname = binfile ? binfile->file : NULL;\n\tif (binfile && binfile->curxtr) {\n\t\tr_anal_hint_clear (r->anal);\n\t}\n\treturn r_core_bin_set_arch_bits (r, name, arch, bits);\n}\n\nR_API int r_core_bin_raise(RCore *core, ut32 binfile_idx, ut32 binobj_idx) {\n\tRBin *bin = core->bin;\n\tRBinFile *binfile = NULL;\n\n\tif (binfile_idx == UT32_MAX && binobj_idx == UT32_MAX) {\n\t\treturn false;\n\t}\n\tif (!r_bin_select_by_ids (bin, binfile_idx, binobj_idx)) {\n\t\treturn false;\n\t}\n\tbinfile = r_core_bin_cur (core);\n\tif (binfile) {\n\t\tr_io_use_fd (core->io, binfile->fd);\n\t}\n\t// it should be 0 to use r_io_use_fd in r_core_block_read\n\tcore->switch_file_view = 0;\n\treturn binfile && r_core_bin_set_env (core, binfile) && r_core_block_read (core);\n}\n\nR_API bool r_core_bin_delete(RCore *core, ut32 binfile_idx, ut32 binobj_idx) {\n\tif (binfile_idx == UT32_MAX && binobj_idx == UT32_MAX) {\n\t\treturn false;\n\t}\n\tif (!r_bin_object_delete (core->bin, binfile_idx, binobj_idx)) {\n\t\treturn false;\n\t}\n\tRBinFile *binfile = r_core_bin_cur (core);\n\tif (binfile) {\n\t\tr_io_use_fd (core->io, binfile->fd);\n\t}\n\tcore->switch_file_view = 0;\n\treturn binfile && r_core_bin_set_env (core, binfile) && r_core_block_read (core);\n}\n\nstatic int r_core_bin_file_print(RCore *core, RBinFile *binfile, int mode) {\n\tRListIter *iter;\n\tRBinObject *obj;\n\tconst char *name = binfile ? binfile->file : NULL;\n\t(void)r_bin_get_info (core->bin); // XXX is this necssary for proper iniitialization\n\tut32 id = binfile ? binfile->id : 0;\n\tut32 fd = binfile ? binfile->fd : 0;\n\tut32 bin_sz = binfile ? binfile->size : 0;\n\t// TODO: handle mode to print in json and r2 commands\n\n\tif (!binfile) {\n\t\treturn false;\n\t}\n\tswitch (mode) {\n\tcase '*':\n\t\tr_list_foreach (binfile->objs, iter, obj) {\n\t\t\tr_cons_printf (\"oba 0x%08\"PFMT64x\" %s # %d\\n\", obj->boffset, name, obj->id);\n\t\t}\n\t\tbreak;\n\tcase 'q':\n\t\tr_list_foreach (binfile->objs, iter, obj) {\n\t\t\tr_cons_printf (\"%d\\n\", obj->id);\n\t\t}\n\t\tbreak;\n\tcase 'j':\n\t\tr_cons_printf (\"{\\\"name\\\":\\\"%s\\\",\\\"fd\\\":%d,\\\"id\\\":%d,\\\"size\\\":%d,\\\"objs\\\":[\",\n\t\t\tname, fd, id, bin_sz);\n\t\tr_list_foreach (binfile->objs, iter, obj) {\n\t\t\tRBinInfo *info = obj->info;\n\t\t\tut8 bits = info ? info->bits : 0;\n\t\t\tconst char *arch = info ? info->arch : \"unknown\";\n\t\t\tr_cons_printf (\"{\\\"objid\\\":%d,\\\"arch\\\":\\\"%s\\\",\\\"bits\\\":%d,\\\"binoffset\\\":%\"\n\t\t\t\t\tPFMT64d\",\\\"objsize\\\":%\"PFMT64d\"}\",\n\t\t\t\t\tobj->id, arch, bits, obj->boffset, obj->obj_size);\n\t\t\tif (iter->n) {\n\t\t\t\tr_cons_print (\",\");\n\t\t\t}\n\t\t}\n\t\tr_cons_print (\"]}\");\n\t\tbreak;\n\tdefault:\n\t\tr_list_foreach (binfile->objs, iter, obj) {\n\t\t\tRBinInfo *info = obj->info;\n\t\t\tut8 bits = info ? info->bits : 0;\n\t\t\tconst char *arch = info ? info->arch : \"unknown\";\n\t\t\tif (!arch) {\n\t\t\t\tarch = r_config_get (core->config, \"asm.arch\");\n\t\t\t}\n\t\t\tr_cons_printf (\"%4d  %s-%d at:0x%08\"PFMT64x\" sz:%\"PFMT64d\" \",\n\t\t\t\t\tobj->id, arch, bits, obj->boffset, obj->obj_size );\n\t\t\tr_cons_printf (\"fd:%d %s\\n\", fd, name);\n\t\t}\n\t\tbreak;\n\t}\n\treturn true;\n}\n\nR_API int r_core_bin_list(RCore *core, int mode) {\n\t// list all binfiles and there objects and there archs\n\tint count = 0;\n\tRListIter *iter;\n\tRBinFile *binfile = NULL; //, *cur_bf = r_core_bin_cur (core) ;\n\tRBin *bin = core->bin;\n\tconst RList *binfiles = bin ? bin->binfiles: NULL;\n\tif (!binfiles) {\n\t\treturn false;\n\t}\n\tif (mode == 'j') {\n\t\tr_cons_print (\"[\");\n\t}\n\tr_list_foreach (binfiles, iter, binfile) {\n\t\tr_core_bin_file_print (core, binfile, mode);\n\t\tif (iter->n && mode == 'j') {\n\t\t\tr_cons_print (\",\");\n\t\t}\n\t}\n\tif (mode == 'j') {\n\t\tr_cons_println (\"]\");\n\t}\n\t//r_core_file_set_by_file (core, cur_cf);\n\t//r_core_bin_bind (core, cur_bf);\n\treturn count;\n}\n\nR_API char *r_core_bin_method_flags_str(ut64 flags, int mode) {\n\tchar *str;\n\tRStrBuf *buf;\n\tint i, len = 0;\n\n\tbuf = r_strbuf_new (\"\");\n\tif (IS_MODE_SET (mode) || IS_MODE_RAD (mode)) {\n\t\tif (!flags) {\n\t\t\tgoto out;\n\t\t}\n\n\t\tfor (i = 0; i != 64; i++) {\n\t\t\tut64 flag = flags & (1UL << i);\n\t\t\tif (flag) {\n\t\t\t\tconst char *flag_string = r_bin_get_meth_flag_string (flag, false);\n\t\t\t\tif (flag_string) {\n\t\t\t\t\tr_strbuf_appendf (buf, \".%s\", flag_string);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else if (IS_MODE_JSON (mode)) {\n\t\tif (!flags) {\n\t\t\tr_strbuf_append (buf, \"[]\");\n\t\t\tgoto out;\n\t\t}\n\n\t\tr_strbuf_append (buf, \"[\");\n\n\t\tfor (i = 0; i != 64; i++) {\n\t\t\tut64 flag = flags & (1LL << i);\n\t\t\tif (flag) {\n\t\t\t\tconst char *flag_string = r_bin_get_meth_flag_string (flag, false);\n\t\t\t\tif (len != 0) {\n\t\t\t\t\tr_strbuf_append (buf, \",\");\n\t\t\t\t}\n\t\t\t\tif (flag_string) {\n\t\t\t\t\tr_strbuf_appendf (buf, \"\\\"%s\\\"\", flag_string);\n\t\t\t\t} else {\n\t\t\t\t\tr_strbuf_appendf (buf, \"\\\"0x%08\"PFMT64x\"\\\"\", flag);\n\t\t\t\t}\n\t\t\t\tlen++;\n\t\t\t}\n\t\t}\n\n\t\tr_strbuf_append (buf, \"]\");\n\t} else {\n\t\tint pad_len = 4; //TODO: move to a config variable\n\n\t\tif (!flags) {\n\t\t\tgoto padding;\n\t\t}\n\t\tfor (i = 0; i != 64; i++) {\n\t\t\tut64 flag = flags & (1L << i);\n\t\t\tif (flag) {\n\t\t\t\tconst char *flag_string = r_bin_get_meth_flag_string (flag, true);\n\n\t\t\t\tif (flag_string) {\n\t\t\t\t\tr_strbuf_append (buf, flag_string);\n\t\t\t\t} else {\n\t\t\t\t\tr_strbuf_append (buf, \"?\");\n\t\t\t\t}\n\n\t\t\t\tlen++;\n\t\t\t}\n\t\t}\npadding:\n\t\tfor ( ; len < pad_len; len++) {\n\t\t\tr_strbuf_append (buf, \" \");\n\t\t}\n\t}\n\nout:\n\tstr = strdup (r_strbuf_get (buf));\n\tr_strbuf_free (buf);\n\n\treturn str;\n}\n"], "filenames": ["libr/bin/p/bin_elf.c", "libr/core/cbin.c"], "buggy_code_start_loc": [351, 1045], "buggy_code_end_loc": [360, 1045], "fixing_code_start_loc": [351, 1046], "fixing_code_end_loc": [360, 1050], "type": "CWE-125", "message": "The r_read_le32() function in radare2 2.5.0 allows remote attackers to cause a denial of service (heap-based out-of-bounds read and application crash) via a crafted ELF file.", "other": {"cve": {"id": "CVE-2018-11376", "sourceIdentifier": "cve@mitre.org", "published": "2018-05-22T19:29:00.270", "lastModified": "2018-06-27T17:52:30.680", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The r_read_le32() function in radare2 2.5.0 allows remote attackers to cause a denial of service (heap-based out-of-bounds read and application crash) via a crafted ELF file."}, {"lang": "es", "value": "La funci\u00f3n r_read_le32() en radare2 2.5.0 permite que atacantes remotos provoquen una denegaci\u00f3n de servicio (lectura fuera de l\u00edmites basada en memoria din\u00e1mica o heap y cierre inesperado de la aplicaci\u00f3n) mediante un archivo ELF manipulado."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:radare:radare2:2.5.0:*:*:*:*:*:*:*", "matchCriteriaId": "81E40EFA-5307-45F3-9722-CB499D21141F"}]}]}], "references": [{"url": "https://github.com/radare/radare2/commit/1f37c04f2a762500222dda2459e6a04646feeedf", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/radare/radare2/issues/9904", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/radare/radare2/commit/1f37c04f2a762500222dda2459e6a04646feeedf"}}