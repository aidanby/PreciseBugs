{"buggy_code": ["/*\n * Copyright 2017 The Netty Project\n *\n * The Netty Project licenses this file to you under the Apache License,\n * version 2.0 (the \"License\"); you may not use this file except in compliance\n * with the License. You may obtain a copy of the License at:\n *\n *   https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations\n * under the License.\n */\npackage io.netty.handler.ssl;\n\nimport io.netty.buffer.ByteBuf;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.util.CharsetUtil;\nimport io.netty.util.concurrent.Future;\nimport io.netty.util.concurrent.ScheduledFuture;\n\nimport java.util.Locale;\nimport java.util.concurrent.TimeUnit;\n\nimport static io.netty.util.internal.ObjectUtil.checkPositiveOrZero;\n\n/**\n * <p>Enables <a href=\"https://tools.ietf.org/html/rfc3546#section-3.1\">SNI\n * (Server Name Indication)</a> extension for server side SSL. For clients\n * support SNI, the server could have multiple host name bound on a single IP.\n * The client will send host name in the handshake data so server could decide\n * which certificate to choose for the host name.</p>\n */\npublic abstract class AbstractSniHandler<T> extends SslClientHelloHandler<T> {\n\n    private static String extractSniHostname(ByteBuf in) {\n        // See https://tools.ietf.org/html/rfc5246#section-7.4.1.2\n        //\n        // Decode the ssl client hello packet.\n        //\n        // struct {\n        //    ProtocolVersion client_version;\n        //    Random random;\n        //    SessionID session_id;\n        //    CipherSuite cipher_suites<2..2^16-2>;\n        //    CompressionMethod compression_methods<1..2^8-1>;\n        //    select (extensions_present) {\n        //        case false:\n        //            struct {};\n        //        case true:\n        //            Extension extensions<0..2^16-1>;\n        //    };\n        // } ClientHello;\n        //\n\n        // We have to skip bytes until SessionID (which sum to 34 bytes in this case).\n        int offset = in.readerIndex();\n        int endOffset = in.writerIndex();\n        offset += 34;\n\n        if (endOffset - offset >= 6) {\n            final int sessionIdLength = in.getUnsignedByte(offset);\n            offset += sessionIdLength + 1;\n\n            final int cipherSuitesLength = in.getUnsignedShort(offset);\n            offset += cipherSuitesLength + 2;\n\n            final int compressionMethodLength = in.getUnsignedByte(offset);\n            offset += compressionMethodLength + 1;\n\n            final int extensionsLength = in.getUnsignedShort(offset);\n            offset += 2;\n            final int extensionsLimit = offset + extensionsLength;\n\n            // Extensions should never exceed the record boundary.\n            if (extensionsLimit <= endOffset) {\n                while (extensionsLimit - offset >= 4) {\n                    final int extensionType = in.getUnsignedShort(offset);\n                    offset += 2;\n\n                    final int extensionLength = in.getUnsignedShort(offset);\n                    offset += 2;\n\n                    if (extensionsLimit - offset < extensionLength) {\n                        break;\n                    }\n\n                    // SNI\n                    // See https://tools.ietf.org/html/rfc6066#page-6\n                    if (extensionType == 0) {\n                        offset += 2;\n                        if (extensionsLimit - offset < 3) {\n                            break;\n                        }\n\n                        final int serverNameType = in.getUnsignedByte(offset);\n                        offset++;\n\n                        if (serverNameType == 0) {\n                            final int serverNameLength = in.getUnsignedShort(offset);\n                            offset += 2;\n\n                            if (extensionsLimit - offset < serverNameLength) {\n                                break;\n                            }\n\n                            final String hostname = in.toString(offset, serverNameLength, CharsetUtil.US_ASCII);\n                            return hostname.toLowerCase(Locale.US);\n                        } else {\n                            // invalid enum value\n                            break;\n                        }\n                    }\n\n                    offset += extensionLength;\n                }\n            }\n        }\n        return null;\n    }\n\n    protected final long handshakeTimeoutMillis;\n    private ScheduledFuture<?> timeoutFuture;\n    private String hostname;\n\n    /**\n     * @param handshakeTimeoutMillis the handshake timeout in milliseconds\n     */\n    protected AbstractSniHandler(long handshakeTimeoutMillis) {\n        this.handshakeTimeoutMillis = checkPositiveOrZero(handshakeTimeoutMillis, \"handshakeTimeoutMillis\");\n    }\n\n    public AbstractSniHandler() {\n        this(0L);\n    }\n\n    @Override\n    public void handlerAdded(ChannelHandlerContext ctx) throws Exception {\n        if (ctx.channel().isActive()) {\n            checkStartTimeout(ctx);\n        }\n    }\n\n    @Override\n    public void channelActive(ChannelHandlerContext ctx) throws Exception {\n        ctx.fireChannelActive();\n        checkStartTimeout(ctx);\n    }\n\n    private void checkStartTimeout(final ChannelHandlerContext ctx) {\n        if (handshakeTimeoutMillis <= 0 || timeoutFuture != null) {\n            return;\n        }\n        timeoutFuture = ctx.executor().schedule(new Runnable() {\n            @Override\n            public void run() {\n                if (ctx.channel().isActive()) {\n                    SslHandshakeTimeoutException exception = new SslHandshakeTimeoutException(\n                        \"handshake timed out after \" + handshakeTimeoutMillis + \"ms\");\n                    ctx.fireUserEventTriggered(new SniCompletionEvent(exception));\n                    ctx.close();\n                }\n            }\n        }, handshakeTimeoutMillis, TimeUnit.MILLISECONDS);\n    }\n\n    @Override\n    protected Future<T> lookup(ChannelHandlerContext ctx, ByteBuf clientHello) throws Exception {\n        hostname = clientHello == null ? null : extractSniHostname(clientHello);\n\n        return lookup(ctx, hostname);\n    }\n\n    @Override\n    protected void onLookupComplete(ChannelHandlerContext ctx, Future<T> future) throws Exception {\n        if (timeoutFuture != null) {\n            timeoutFuture.cancel(false);\n        }\n        try {\n            onLookupComplete(ctx, hostname, future);\n        } finally {\n            fireSniCompletionEvent(ctx, hostname, future);\n        }\n    }\n\n    /**\n     * Kicks off a lookup for the given SNI value and returns a {@link Future} which in turn will\n     * notify the {@link #onLookupComplete(ChannelHandlerContext, String, Future)} on completion.\n     *\n     * @see #onLookupComplete(ChannelHandlerContext, String, Future)\n     */\n    protected abstract Future<T> lookup(ChannelHandlerContext ctx, String hostname) throws Exception;\n\n    /**\n     * Called upon completion of the {@link #lookup(ChannelHandlerContext, String)} {@link Future}.\n     *\n     * @see #lookup(ChannelHandlerContext, String)\n     */\n    protected abstract void onLookupComplete(ChannelHandlerContext ctx,\n                                             String hostname, Future<T> future) throws Exception;\n\n    private static void fireSniCompletionEvent(ChannelHandlerContext ctx, String hostname, Future<?> future) {\n        Throwable cause = future.cause();\n        if (cause == null) {\n            ctx.fireUserEventTriggered(new SniCompletionEvent(hostname));\n        } else {\n            ctx.fireUserEventTriggered(new SniCompletionEvent(hostname, cause));\n        }\n    }\n}\n", "/*\n * Copyright 2014 The Netty Project\n *\n * The Netty Project licenses this file to you under the Apache License,\n * version 2.0 (the \"License\"); you may not use this file except in compliance\n * with the License. You may obtain a copy of the License at:\n *\n *   https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations\n * under the License.\n */\npackage io.netty.handler.ssl;\n\nimport io.netty.buffer.ByteBufAllocator;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.handler.codec.DecoderException;\nimport io.netty.util.AsyncMapping;\nimport io.netty.util.DomainNameMapping;\nimport io.netty.util.Mapping;\nimport io.netty.util.ReferenceCountUtil;\nimport io.netty.util.concurrent.Future;\nimport io.netty.util.concurrent.Promise;\nimport io.netty.util.internal.ObjectUtil;\nimport io.netty.util.internal.PlatformDependent;\n\n/**\n * <p>Enables <a href=\"https://tools.ietf.org/html/rfc3546#section-3.1\">SNI\n * (Server Name Indication)</a> extension for server side SSL. For clients\n * support SNI, the server could have multiple host name bound on a single IP.\n * The client will send host name in the handshake data so server could decide\n * which certificate to choose for the host name.</p>\n */\npublic class SniHandler extends AbstractSniHandler<SslContext> {\n    private static final Selection EMPTY_SELECTION = new Selection(null, null);\n\n    protected final AsyncMapping<String, SslContext> mapping;\n\n    private volatile Selection selection = EMPTY_SELECTION;\n\n    /**\n     * Creates a SNI detection handler with configured {@link SslContext}\n     * maintained by {@link Mapping}\n     *\n     * @param mapping the mapping of domain name to {@link SslContext}\n     */\n    public SniHandler(Mapping<? super String, ? extends SslContext> mapping) {\n        this(new AsyncMappingAdapter(mapping));\n    }\n\n    /**\n     * Creates a SNI detection handler with configured {@link SslContext}\n     * maintained by {@link Mapping}\n     *\n     * @param mapping the mapping of domain name to {@link SslContext}\n     * @param handshakeTimeoutMillis the handshake timeout in milliseconds\n     */\n    public SniHandler(Mapping<? super String, ? extends SslContext> mapping, long handshakeTimeoutMillis) {\n        this(new AsyncMappingAdapter(mapping), handshakeTimeoutMillis);\n    }\n\n    /**\n     * Creates a SNI detection handler with configured {@link SslContext}\n     * maintained by {@link DomainNameMapping}\n     *\n     * @param mapping the mapping of domain name to {@link SslContext}\n     */\n    public SniHandler(DomainNameMapping<? extends SslContext> mapping) {\n        this((Mapping<String, ? extends SslContext>) mapping);\n    }\n\n    /**\n     * Creates a SNI detection handler with configured {@link SslContext}\n     * maintained by {@link AsyncMapping}\n     *\n     * @param mapping the mapping of domain name to {@link SslContext}\n     */\n    @SuppressWarnings(\"unchecked\")\n    public SniHandler(AsyncMapping<? super String, ? extends SslContext> mapping) {\n        this(mapping, 0L);\n    }\n\n    /**\n     * Creates a SNI detection handler with configured {@link SslContext}\n     * maintained by {@link AsyncMapping}\n     *\n     * @param mapping the mapping of domain name to {@link SslContext}\n     * @param handshakeTimeoutMillis the handshake timeout in milliseconds\n     */\n    @SuppressWarnings(\"unchecked\")\n    public SniHandler(AsyncMapping<? super String, ? extends SslContext> mapping, long handshakeTimeoutMillis) {\n        super(handshakeTimeoutMillis);\n        this.mapping = (AsyncMapping<String, SslContext>) ObjectUtil.checkNotNull(mapping, \"mapping\");\n    }\n\n    /**\n     * @return the selected hostname\n     */\n    public String hostname() {\n        return selection.hostname;\n    }\n\n    /**\n     * @return the selected {@link SslContext}\n     */\n    public SslContext sslContext() {\n        return selection.context;\n    }\n\n    /**\n     * The default implementation will simply call {@link AsyncMapping#map(Object, Promise)} but\n     * users can override this method to implement custom behavior.\n     *\n     * @see AsyncMapping#map(Object, Promise)\n     */\n    @Override\n    protected Future<SslContext> lookup(ChannelHandlerContext ctx, String hostname) throws Exception {\n        return mapping.map(hostname, ctx.executor().<SslContext>newPromise());\n    }\n\n    @Override\n    protected final void onLookupComplete(ChannelHandlerContext ctx,\n                                          String hostname, Future<SslContext> future) throws Exception {\n        if (!future.isSuccess()) {\n            final Throwable cause = future.cause();\n            if (cause instanceof Error) {\n                throw (Error) cause;\n            }\n            throw new DecoderException(\"failed to get the SslContext for \" + hostname, cause);\n        }\n\n        SslContext sslContext = future.getNow();\n        selection = new Selection(sslContext, hostname);\n        try {\n            replaceHandler(ctx, hostname, sslContext);\n        } catch (Throwable cause) {\n            selection = EMPTY_SELECTION;\n            PlatformDependent.throwException(cause);\n        }\n    }\n\n    /**\n     * The default implementation of this method will simply replace {@code this} {@link SniHandler}\n     * instance with a {@link SslHandler}. Users may override this method to implement custom behavior.\n     *\n     * Please be aware that this method may get called after a client has already disconnected and\n     * custom implementations must take it into consideration when overriding this method.\n     *\n     * It's also possible for the hostname argument to be {@code null}.\n     */\n    protected void replaceHandler(ChannelHandlerContext ctx, String hostname, SslContext sslContext) throws Exception {\n        SslHandler sslHandler = null;\n        try {\n            sslHandler = newSslHandler(sslContext, ctx.alloc());\n            ctx.pipeline().replace(this, SslHandler.class.getName(), sslHandler);\n            sslHandler = null;\n        } finally {\n            // Since the SslHandler was not inserted into the pipeline the ownership of the SSLEngine was not\n            // transferred to the SslHandler.\n            // See https://github.com/netty/netty/issues/5678\n            if (sslHandler != null) {\n                ReferenceCountUtil.safeRelease(sslHandler.engine());\n            }\n        }\n    }\n\n    /**\n     * Returns a new {@link SslHandler} using the given {@link SslContext} and {@link ByteBufAllocator}.\n     * Users may override this method to implement custom behavior.\n     */\n    protected SslHandler newSslHandler(SslContext context, ByteBufAllocator allocator) {\n        SslHandler sslHandler = context.newHandler(allocator);\n        sslHandler.setHandshakeTimeoutMillis(handshakeTimeoutMillis);\n        return sslHandler;\n    }\n\n    private static final class AsyncMappingAdapter implements AsyncMapping<String, SslContext> {\n        private final Mapping<? super String, ? extends SslContext> mapping;\n\n        private AsyncMappingAdapter(Mapping<? super String, ? extends SslContext> mapping) {\n            this.mapping = ObjectUtil.checkNotNull(mapping, \"mapping\");\n        }\n\n        @Override\n        public Future<SslContext> map(String input, Promise<SslContext> promise) {\n            final SslContext context;\n            try {\n                context = mapping.map(input);\n            } catch (Throwable cause) {\n                return promise.setFailure(cause);\n            }\n            return promise.setSuccess(context);\n        }\n    }\n\n    private static final class Selection {\n        final SslContext context;\n        final String hostname;\n\n        Selection(SslContext context, String hostname) {\n            this.context = context;\n            this.hostname = hostname;\n        }\n    }\n}\n", "/*\n * Copyright 2017 The Netty Project\n *\n * The Netty Project licenses this file to you under the Apache License,\n * version 2.0 (the \"License\"); you may not use this file except in compliance\n * with the License. You may obtain a copy of the License at:\n *\n *   https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations\n * under the License.\n */\npackage io.netty.handler.ssl;\n\nimport io.netty.buffer.ByteBuf;\nimport io.netty.buffer.ByteBufUtil;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.ChannelOutboundHandler;\nimport io.netty.channel.ChannelPromise;\nimport io.netty.handler.codec.ByteToMessageDecoder;\nimport io.netty.handler.codec.DecoderException;\nimport io.netty.util.concurrent.Future;\nimport io.netty.util.concurrent.FutureListener;\nimport io.netty.util.internal.PlatformDependent;\nimport io.netty.util.internal.logging.InternalLogger;\nimport io.netty.util.internal.logging.InternalLoggerFactory;\n\nimport java.net.SocketAddress;\nimport java.util.List;\n\n/**\n * {@link ByteToMessageDecoder} which allows to be notified once a full {@code ClientHello} was received.\n */\npublic abstract class SslClientHelloHandler<T> extends ByteToMessageDecoder implements ChannelOutboundHandler {\n\n    private static final InternalLogger logger =\n            InternalLoggerFactory.getInstance(SslClientHelloHandler.class);\n\n    private boolean handshakeFailed;\n    private boolean suppressRead;\n    private boolean readPending;\n    private ByteBuf handshakeBuffer;\n\n    @Override\n    protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exception {\n        if (!suppressRead && !handshakeFailed) {\n            try {\n                int readerIndex = in.readerIndex();\n                int readableBytes = in.readableBytes();\n                int handshakeLength = -1;\n\n                // Check if we have enough data to determine the record type and length.\n                while (readableBytes >= SslUtils.SSL_RECORD_HEADER_LENGTH) {\n                    final int contentType = in.getUnsignedByte(readerIndex);\n                    switch (contentType) {\n                        case SslUtils.SSL_CONTENT_TYPE_CHANGE_CIPHER_SPEC:\n                            // fall-through\n                        case SslUtils.SSL_CONTENT_TYPE_ALERT:\n                            final int len = SslUtils.getEncryptedPacketLength(in, readerIndex);\n\n                            // Not an SSL/TLS packet\n                            if (len == SslUtils.NOT_ENCRYPTED) {\n                                handshakeFailed = true;\n                                NotSslRecordException e = new NotSslRecordException(\n                                        \"not an SSL/TLS record: \" + ByteBufUtil.hexDump(in));\n                                in.skipBytes(in.readableBytes());\n                                ctx.fireUserEventTriggered(new SniCompletionEvent(e));\n                                SslUtils.handleHandshakeFailure(ctx, e, true);\n                                throw e;\n                            }\n                            if (len == SslUtils.NOT_ENOUGH_DATA) {\n                                // Not enough data\n                                return;\n                            }\n                            // No ClientHello\n                            select(ctx, null);\n                            return;\n                        case SslUtils.SSL_CONTENT_TYPE_HANDSHAKE:\n                            final int majorVersion = in.getUnsignedByte(readerIndex + 1);\n                            // SSLv3 or TLS\n                            if (majorVersion == 3) {\n                                int packetLength = in.getUnsignedShort(readerIndex + 3) +\n                                        SslUtils.SSL_RECORD_HEADER_LENGTH;\n\n                                if (readableBytes < packetLength) {\n                                    // client hello incomplete; try again to decode once more data is ready.\n                                    return;\n                                } else if (packetLength == SslUtils.SSL_RECORD_HEADER_LENGTH) {\n                                    select(ctx, null);\n                                    return;\n                                }\n\n                                final int endOffset = readerIndex + packetLength;\n\n                                // Let's check if we already parsed the handshake length or not.\n                                if (handshakeLength == -1) {\n                                    if (readerIndex + 4 > endOffset) {\n                                        // Need more data to read HandshakeType and handshakeLength (4 bytes)\n                                        return;\n                                    }\n\n                                    final int handshakeType = in.getUnsignedByte(readerIndex +\n                                            SslUtils.SSL_RECORD_HEADER_LENGTH);\n\n                                    // Check if this is a clientHello(1)\n                                    // See https://tools.ietf.org/html/rfc5246#section-7.4\n                                    if (handshakeType != 1) {\n                                        select(ctx, null);\n                                        return;\n                                    }\n\n                                    // Read the length of the handshake as it may arrive in fragments\n                                    // See https://tools.ietf.org/html/rfc5246#section-7.4\n                                    handshakeLength = in.getUnsignedMedium(readerIndex +\n                                            SslUtils.SSL_RECORD_HEADER_LENGTH + 1);\n\n                                    // Consume handshakeType and handshakeLength (this sums up as 4 bytes)\n                                    readerIndex += 4;\n                                    packetLength -= 4;\n\n                                    if (handshakeLength + 4 + SslUtils.SSL_RECORD_HEADER_LENGTH <= packetLength) {\n                                        // We have everything we need in one packet.\n                                        // Skip the record header\n                                        readerIndex += SslUtils.SSL_RECORD_HEADER_LENGTH;\n                                        select(ctx, in.retainedSlice(readerIndex, handshakeLength));\n                                        return;\n                                    } else {\n                                        if (handshakeBuffer == null) {\n                                            handshakeBuffer = ctx.alloc().buffer(handshakeLength);\n                                        } else {\n                                            // Clear the buffer so we can aggregate into it again.\n                                            handshakeBuffer.clear();\n                                        }\n                                    }\n                                }\n\n                                // Combine the encapsulated data in one buffer but not include the SSL_RECORD_HEADER\n                                handshakeBuffer.writeBytes(in, readerIndex + SslUtils.SSL_RECORD_HEADER_LENGTH,\n                                        packetLength - SslUtils.SSL_RECORD_HEADER_LENGTH);\n                                readerIndex += packetLength;\n                                readableBytes -= packetLength;\n                                if (handshakeLength <= handshakeBuffer.readableBytes()) {\n                                    ByteBuf clientHello = handshakeBuffer.setIndex(0, handshakeLength);\n                                    handshakeBuffer = null;\n\n                                    select(ctx, clientHello);\n                                    return;\n                                }\n                                break;\n                            }\n                            // fall-through\n                        default:\n                            // not tls, ssl or application data\n                            select(ctx, null);\n                            return;\n                    }\n                }\n            } catch (NotSslRecordException e) {\n                // Just rethrow as in this case we also closed the channel and this is consistent with SslHandler.\n                throw e;\n            } catch (Exception e) {\n                // unexpected encoding, ignore sni and use default\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"Unexpected client hello packet: \" + ByteBufUtil.hexDump(in), e);\n                }\n                select(ctx, null);\n            }\n        }\n    }\n\n    private void releaseHandshakeBuffer() {\n        releaseIfNotNull(handshakeBuffer);\n        handshakeBuffer = null;\n    }\n\n    private static void releaseIfNotNull(ByteBuf buffer) {\n        if (buffer != null) {\n            buffer.release();\n        }\n    }\n\n    private void select(final ChannelHandlerContext ctx, ByteBuf clientHello) throws Exception {\n        final Future<T> future;\n        try {\n            future = lookup(ctx, clientHello);\n            if (future.isDone()) {\n                onLookupComplete(ctx, future);\n            } else {\n                suppressRead = true;\n                final ByteBuf finalClientHello = clientHello;\n                future.addListener(new FutureListener<T>() {\n                    @Override\n                    public void operationComplete(Future<T> future) {\n                        releaseIfNotNull(finalClientHello);\n                        try {\n                            suppressRead = false;\n                            try {\n                                onLookupComplete(ctx, future);\n                            } catch (DecoderException err) {\n                                ctx.fireExceptionCaught(err);\n                            } catch (Exception cause) {\n                                ctx.fireExceptionCaught(new DecoderException(cause));\n                            } catch (Throwable cause) {\n                                ctx.fireExceptionCaught(cause);\n                            }\n                        } finally {\n                            if (readPending) {\n                                readPending = false;\n                                ctx.read();\n                            }\n                        }\n                    }\n                });\n\n                // Ownership was transferred to the FutureListener.\n                clientHello = null;\n            }\n        } catch (Throwable cause) {\n            PlatformDependent.throwException(cause);\n        } finally {\n            releaseIfNotNull(clientHello);\n        }\n    }\n\n    @Override\n    protected void handlerRemoved0(ChannelHandlerContext ctx) throws Exception {\n        releaseHandshakeBuffer();\n\n        super.handlerRemoved0(ctx);\n    }\n\n    /**\n     * Kicks off a lookup for the given {@code ClientHello} and returns a {@link Future} which in turn will\n     * notify the {@link #onLookupComplete(ChannelHandlerContext, Future)} on completion.\n     *\n     * See https://tools.ietf.org/html/rfc5246#section-7.4.1.2\n     *\n     * <pre>\n     * struct {\n     *    ProtocolVersion client_version;\n     *    Random random;\n     *    SessionID session_id;\n     *    CipherSuite cipher_suites<2..2^16-2>;\n     *    CompressionMethod compression_methods<1..2^8-1>;\n     *    select (extensions_present) {\n     *        case false:\n     *            struct {};\n     *        case true:\n     *            Extension extensions<0..2^16-1>;\n     *    };\n     * } ClientHello;\n     * </pre>\n     *\n     * @see #onLookupComplete(ChannelHandlerContext, Future)\n     */\n    protected abstract Future<T> lookup(ChannelHandlerContext ctx, ByteBuf clientHello) throws Exception;\n\n    /**\n     * Called upon completion of the {@link #lookup(ChannelHandlerContext, ByteBuf)} {@link Future}.\n     *\n     * @see #lookup(ChannelHandlerContext, ByteBuf)\n     */\n    protected abstract void onLookupComplete(ChannelHandlerContext ctx, Future<T> future) throws Exception;\n\n    @Override\n    public void read(ChannelHandlerContext ctx) throws Exception {\n        if (suppressRead) {\n            readPending = true;\n        } else {\n            ctx.read();\n        }\n    }\n\n    @Override\n    public void bind(ChannelHandlerContext ctx, SocketAddress localAddress, ChannelPromise promise) throws Exception {\n        ctx.bind(localAddress, promise);\n    }\n\n    @Override\n    public void connect(ChannelHandlerContext ctx, SocketAddress remoteAddress, SocketAddress localAddress,\n                        ChannelPromise promise) throws Exception {\n        ctx.connect(remoteAddress, localAddress, promise);\n    }\n\n    @Override\n    public void disconnect(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception {\n        ctx.disconnect(promise);\n    }\n\n    @Override\n    public void close(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception {\n        ctx.close(promise);\n    }\n\n    @Override\n    public void deregister(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception {\n        ctx.deregister(promise);\n    }\n\n    @Override\n    public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {\n        ctx.write(msg, promise);\n    }\n\n    @Override\n    public void flush(ChannelHandlerContext ctx) throws Exception {\n        ctx.flush();\n    }\n}\n", "/*\n * Copyright 2014 The Netty Project\n *\n * The Netty Project licenses this file to you under the Apache License,\n * version 2.0 (the \"License\"); you may not use this file except in compliance\n * with the License. You may obtain a copy of the License at:\n *\n *   https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations\n * under the License.\n */\n\npackage io.netty.handler.ssl;\n\nimport java.io.File;\nimport java.net.InetSocketAddress;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport javax.net.ssl.HandshakeCompletedEvent;\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.SSLEngine;\nimport javax.net.ssl.SSLException;\n\nimport io.netty.util.concurrent.Future;\n\nimport io.netty.bootstrap.Bootstrap;\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.buffer.ByteBuf;\nimport io.netty.buffer.ByteBufAllocator;\nimport io.netty.buffer.Unpooled;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.ChannelInboundHandlerAdapter;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelPipeline;\nimport io.netty.channel.DefaultEventLoopGroup;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.embedded.EmbeddedChannel;\nimport io.netty.channel.local.LocalAddress;\nimport io.netty.channel.local.LocalChannel;\nimport io.netty.channel.local.LocalServerChannel;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.codec.DecoderException;\nimport io.netty.handler.ssl.util.InsecureTrustManagerFactory;\nimport io.netty.handler.ssl.util.SelfSignedCertificate;\nimport io.netty.util.DomainNameMapping;\nimport io.netty.util.DomainNameMappingBuilder;\nimport io.netty.util.Mapping;\nimport io.netty.util.ReferenceCountUtil;\nimport io.netty.util.ReferenceCounted;\nimport io.netty.util.concurrent.Promise;\nimport io.netty.util.internal.ObjectUtil;\nimport io.netty.util.internal.ResourcesUtil;\nimport io.netty.util.internal.StringUtil;\nimport org.hamcrest.CoreMatchers;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.Timeout;\nimport org.junit.jupiter.api.function.Executable;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.MethodSource;\n\nimport static org.hamcrest.CoreMatchers.is;\nimport static org.hamcrest.CoreMatchers.nullValue;\nimport static org.hamcrest.MatcherAssert.assertThat;\n\nimport static org.junit.jupiter.api.Assumptions.assumeTrue;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.mockito.Mockito.mock;\n\npublic class SniHandlerTest {\n\n    private static ApplicationProtocolConfig newApnConfig() {\n        return new ApplicationProtocolConfig(\n                ApplicationProtocolConfig.Protocol.ALPN,\n                // NO_ADVERTISE is currently the only mode supported by both OpenSsl and JDK providers.\n                ApplicationProtocolConfig.SelectorFailureBehavior.NO_ADVERTISE,\n                // ACCEPT is currently the only mode supported by both OpenSsl and JDK providers.\n                ApplicationProtocolConfig.SelectedListenerFailureBehavior.ACCEPT,\n                \"myprotocol\");\n    }\n\n    private static void assumeApnSupported(SslProvider provider) {\n        switch (provider) {\n            case OPENSSL:\n            case OPENSSL_REFCNT:\n                assumeTrue(OpenSsl.isAlpnSupported());\n                break;\n            case JDK:\n                assumeTrue(JettyAlpnSslEngine.isAvailable());\n                break;\n            default:\n                throw new Error();\n        }\n    }\n\n    private static SslContext makeSslContext(SslProvider provider, boolean apn) throws Exception {\n        if (apn) {\n            assumeApnSupported(provider);\n        }\n\n        File keyFile = ResourcesUtil.getFile(SniHandlerTest.class, \"test_encrypted.pem\");\n        File crtFile = ResourcesUtil.getFile(SniHandlerTest.class, \"test.crt\");\n\n        SslContextBuilder sslCtxBuilder = SslContextBuilder.forServer(crtFile, keyFile, \"12345\")\n                .sslProvider(provider);\n        if (apn) {\n            sslCtxBuilder.applicationProtocolConfig(newApnConfig());\n        }\n        return sslCtxBuilder.build();\n    }\n\n    private static SslContext makeSslClientContext(SslProvider provider, boolean apn) throws Exception {\n        if (apn) {\n            assumeApnSupported(provider);\n        }\n\n        File crtFile = ResourcesUtil.getFile(SniHandlerTest.class, \"test.crt\");\n\n        SslContextBuilder sslCtxBuilder = SslContextBuilder.forClient().trustManager(crtFile).sslProvider(provider);\n        if (apn) {\n            sslCtxBuilder.applicationProtocolConfig(newApnConfig());\n        }\n        return sslCtxBuilder.build();\n    }\n\n    static Iterable<?> data() {\n        List<SslProvider> params = new ArrayList<SslProvider>(3);\n        if (OpenSsl.isAvailable()) {\n            params.add(SslProvider.OPENSSL);\n            params.add(SslProvider.OPENSSL_REFCNT);\n        }\n        params.add(SslProvider.JDK);\n        return params;\n    }\n\n    @ParameterizedTest(name = \"{index}: sslProvider={0}\")\n    @MethodSource(\"data\")\n    public void testNonSslRecord(SslProvider provider) throws Exception {\n        SslContext nettyContext = makeSslContext(provider, false);\n        try {\n            final AtomicReference<SslHandshakeCompletionEvent> evtRef =\n                    new AtomicReference<SslHandshakeCompletionEvent>();\n            SniHandler handler = new SniHandler(new DomainNameMappingBuilder<SslContext>(nettyContext).build());\n            final EmbeddedChannel ch = new EmbeddedChannel(handler, new ChannelInboundHandlerAdapter() {\n                @Override\n                public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {\n                    if (evt instanceof SslHandshakeCompletionEvent) {\n                        assertTrue(evtRef.compareAndSet(null, (SslHandshakeCompletionEvent) evt));\n                    }\n                }\n            });\n\n            try {\n                final byte[] bytes = new byte[1024];\n                bytes[0] = SslUtils.SSL_CONTENT_TYPE_ALERT;\n\n                DecoderException e = assertThrows(DecoderException.class, new Executable() {\n                    @Override\n                    public void execute() throws Throwable {\n                        ch.writeInbound(Unpooled.wrappedBuffer(bytes));\n                    }\n                });\n                assertThat(e.getCause(), CoreMatchers.instanceOf(NotSslRecordException.class));\n                assertFalse(ch.finish());\n            } finally {\n                ch.finishAndReleaseAll();\n            }\n            assertThat(evtRef.get().cause(), CoreMatchers.instanceOf(NotSslRecordException.class));\n        } finally {\n            releaseAll(nettyContext);\n        }\n    }\n\n    @ParameterizedTest(name = \"{index}: sslProvider={0}\")\n    @MethodSource(\"data\")\n    public void testServerNameParsing(SslProvider provider) throws Exception {\n        SslContext nettyContext = makeSslContext(provider, false);\n        SslContext leanContext = makeSslContext(provider, false);\n        SslContext leanContext2 = makeSslContext(provider, false);\n\n        try {\n            DomainNameMapping<SslContext> mapping = new DomainNameMappingBuilder<SslContext>(nettyContext)\n                    .add(\"*.netty.io\", nettyContext)\n                    // input with custom cases\n                    .add(\"*.LEANCLOUD.CN\", leanContext)\n                    // a hostname conflict with previous one, since we are using order-sensitive config,\n                    // the engine won't be used with the handler.\n                    .add(\"chat4.leancloud.cn\", leanContext2)\n                    .build();\n\n            final AtomicReference<SniCompletionEvent> evtRef = new AtomicReference<SniCompletionEvent>();\n            SniHandler handler = new SniHandler(mapping);\n            EmbeddedChannel ch = new EmbeddedChannel(handler, new ChannelInboundHandlerAdapter() {\n                @Override\n                public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {\n                    if (evt instanceof SniCompletionEvent) {\n                        assertTrue(evtRef.compareAndSet(null, (SniCompletionEvent) evt));\n                    } else {\n                        ctx.fireUserEventTriggered(evt);\n                    }\n                }\n            });\n\n            try {\n                // hex dump of a client hello packet, which contains hostname \"CHAT4.LEANCLOUD.CN\"\n                String tlsHandshakeMessageHex1 = \"16030100\";\n                // part 2\n                String tlsHandshakeMessageHex = \"c6010000c20303bb0855d66532c05a0ef784f7c384feeafa68b3\" +\n                        \"b655ac7288650d5eed4aa3fb52000038c02cc030009fcca9cca8ccaac02b\" +\n                        \"c02f009ec024c028006bc023c0270067c00ac0140039c009c0130033009d\" +\n                        \"009c003d003c0035002f00ff010000610000001700150000124348415434\" +\n                        \"2e4c45414e434c4f55442e434e000b000403000102000a000a0008001d00\" +\n                        \"170019001800230000000d0020001e060106020603050105020503040104\" +\n                        \"0204030301030203030201020202030016000000170000\";\n\n                ch.writeInbound(Unpooled.wrappedBuffer(StringUtil.decodeHexDump(tlsHandshakeMessageHex1)));\n                ch.writeInbound(Unpooled.wrappedBuffer(StringUtil.decodeHexDump(tlsHandshakeMessageHex)));\n\n                // This should produce an alert\n                assertTrue(ch.finish());\n\n                assertThat(handler.hostname(), is(\"chat4.leancloud.cn\"));\n                assertThat(handler.sslContext(), is(leanContext));\n\n                SniCompletionEvent evt = evtRef.get();\n                assertNotNull(evt);\n                assertEquals(\"chat4.leancloud.cn\", evt.hostname());\n                assertTrue(evt.isSuccess());\n                assertNull(evt.cause());\n            } finally {\n                ch.finishAndReleaseAll();\n            }\n        } finally {\n            releaseAll(leanContext, leanContext2, nettyContext);\n        }\n    }\n\n    @ParameterizedTest(name = \"{index}: sslProvider={0}\")\n    @MethodSource(\"data\")\n    public void testNonAsciiServerNameParsing(SslProvider provider) throws Exception {\n        SslContext nettyContext = makeSslContext(provider, false);\n        SslContext leanContext = makeSslContext(provider, false);\n        SslContext leanContext2 = makeSslContext(provider, false);\n\n        try {\n            DomainNameMapping<SslContext> mapping = new DomainNameMappingBuilder<SslContext>(nettyContext)\n                    .add(\"*.netty.io\", nettyContext)\n                    // input with custom cases\n                    .add(\"*.LEANCLOUD.CN\", leanContext)\n                    // a hostname conflict with previous one, since we are using order-sensitive config,\n                    // the engine won't be used with the handler.\n                    .add(\"chat4.leancloud.cn\", leanContext2)\n                    .build();\n\n            SniHandler handler = new SniHandler(mapping);\n            final EmbeddedChannel ch = new EmbeddedChannel(handler);\n\n            try {\n                // hex dump of a client hello packet, which contains an invalid hostname \"CHAT4\u3002LEANCLOUD\u3002CN\"\n                String tlsHandshakeMessageHex1 = \"16030100\";\n                // part 2\n                final String tlsHandshakeMessageHex = \"bd010000b90303a74225676d1814ba57faff3b366\" +\n                        \"3656ed05ee9dbb2a4dbb1bb1c32d2ea5fc39e0000000100008c0000001700150000164348\" +\n                        \"415434E380824C45414E434C4F5544E38082434E000b000403000102000a00340032000e0\" +\n                        \"00d0019000b000c00180009000a0016001700080006000700140015000400050012001300\" +\n                        \"0100020003000f0010001100230000000d0020001e0601060206030501050205030401040\" +\n                        \"20403030103020303020102020203000f00010133740000\";\n\n                // Push the handshake message.\n                // Decode should fail because of the badly encoded \"HostName\" string in the SNI extension\n                // that isn't ASCII as per RFC 6066 - https://tools.ietf.org/html/rfc6066#page-6\n                ch.writeInbound(Unpooled.wrappedBuffer(StringUtil.decodeHexDump(tlsHandshakeMessageHex1)));\n\n                assertThrows(DecoderException.class, new Executable() {\n                    @Override\n                    public void execute() throws Throwable {\n                        ch.writeInbound(Unpooled.wrappedBuffer(StringUtil.decodeHexDump(tlsHandshakeMessageHex)));\n                    }\n                });\n            } finally {\n                ch.finishAndReleaseAll();\n            }\n        } finally {\n            releaseAll(leanContext, leanContext2, nettyContext);\n        }\n    }\n\n    @ParameterizedTest(name = \"{index}: sslProvider={0}\")\n    @MethodSource(\"data\")\n    public void testFallbackToDefaultContext(SslProvider provider) throws Exception {\n        SslContext nettyContext = makeSslContext(provider, false);\n        SslContext leanContext = makeSslContext(provider, false);\n        SslContext leanContext2 = makeSslContext(provider, false);\n\n        try {\n            DomainNameMapping<SslContext> mapping = new DomainNameMappingBuilder<SslContext>(nettyContext)\n                    .add(\"*.netty.io\", nettyContext)\n                    // input with custom cases\n                    .add(\"*.LEANCLOUD.CN\", leanContext)\n                    // a hostname conflict with previous one, since we are using order-sensitive config,\n                    // the engine won't be used with the handler.\n                    .add(\"chat4.leancloud.cn\", leanContext2)\n                    .build();\n\n            SniHandler handler = new SniHandler(mapping);\n            EmbeddedChannel ch = new EmbeddedChannel(handler);\n\n            // invalid\n            byte[] message = {22, 3, 1, 0, 0};\n            try {\n                // Push the handshake message.\n                ch.writeInbound(Unpooled.wrappedBuffer(message));\n                // TODO(scott): This should fail because the engine should reject zero length records during handshake.\n                // See https://github.com/netty/netty/issues/6348.\n                // fail();\n            } catch (Exception e) {\n                // expected\n            }\n\n            ch.close();\n\n            // When the channel is closed the SslHandler will write an empty buffer to the channel.\n            ByteBuf buf = ch.readOutbound();\n            // TODO(scott): if the engine is shutdown correctly then this buffer shouldn't be null!\n            // See https://github.com/netty/netty/issues/6348.\n            if (buf != null) {\n                assertFalse(buf.isReadable());\n                buf.release();\n            }\n\n            assertThat(ch.finish(), is(false));\n            assertThat(handler.hostname(), nullValue());\n            assertThat(handler.sslContext(), is(nettyContext));\n        } finally {\n            releaseAll(leanContext, leanContext2, nettyContext);\n        }\n    }\n\n    @ParameterizedTest(name = \"{index}: sslProvider={0}\")\n    @MethodSource(\"data\")\n    @Timeout(value = 10000, unit = TimeUnit.MILLISECONDS)\n    public void testMajorVersionNot3(SslProvider provider) throws Exception {\n        SslContext nettyContext = makeSslContext(provider, false);\n\n        try {\n            DomainNameMapping<SslContext> mapping = new DomainNameMappingBuilder<SslContext>(nettyContext).build();\n\n            SniHandler handler = new SniHandler(mapping);\n            EmbeddedChannel ch = new EmbeddedChannel(handler);\n\n            // invalid\n            byte[] message = {22, 2, 0, 0, 0};\n            try {\n                // Push the handshake message.\n                ch.writeInbound(Unpooled.wrappedBuffer(message));\n                // TODO(scott): This should fail because the engine should reject zero length records during handshake.\n                // See https://github.com/netty/netty/issues/6348.\n                // fail();\n            } catch (Exception e) {\n                // expected\n            }\n\n            ch.close();\n\n            // Consume all the outbound data that may be produced by the SSLEngine.\n            for (;;) {\n                ByteBuf buf = ch.readOutbound();\n                if (buf == null) {\n                    break;\n                }\n                buf.release();\n            }\n\n            assertThat(ch.finish(), is(false));\n            assertThat(handler.hostname(), nullValue());\n            assertThat(handler.sslContext(), is(nettyContext));\n        } finally {\n            releaseAll(nettyContext);\n        }\n    }\n\n    @ParameterizedTest(name = \"{index}: sslProvider={0}\")\n    @MethodSource(\"data\")\n    public void testSniWithApnHandler(SslProvider provider) throws Exception {\n        SslContext nettyContext = makeSslContext(provider, true);\n        SslContext sniContext = makeSslContext(provider, true);\n        final SslContext clientContext = makeSslClientContext(provider, true);\n        try {\n            final AtomicBoolean serverApnCtx = new AtomicBoolean(false);\n            final AtomicBoolean clientApnCtx = new AtomicBoolean(false);\n            final CountDownLatch serverApnDoneLatch = new CountDownLatch(1);\n            final CountDownLatch clientApnDoneLatch = new CountDownLatch(1);\n\n            final DomainNameMapping<SslContext> mapping = new DomainNameMappingBuilder<SslContext>(nettyContext)\n                    .add(\"*.netty.io\", nettyContext)\n                    .add(\"sni.fake.site\", sniContext).build();\n            final SniHandler handler = new SniHandler(mapping);\n            EventLoopGroup group = new NioEventLoopGroup(2);\n            Channel serverChannel = null;\n            Channel clientChannel = null;\n            try {\n                ServerBootstrap sb = new ServerBootstrap();\n                sb.group(group);\n                sb.channel(NioServerSocketChannel.class);\n                sb.childHandler(new ChannelInitializer<Channel>() {\n                    @Override\n                    protected void initChannel(Channel ch) throws Exception {\n                        ChannelPipeline p = ch.pipeline();\n                        // Server side SNI.\n                        p.addLast(handler);\n                        // Catch the notification event that APN has completed successfully.\n                        p.addLast(new ApplicationProtocolNegotiationHandler(\"foo\") {\n                            @Override\n                            protected void configurePipeline(ChannelHandlerContext ctx, String protocol) {\n                                // addresses issue #9131\n                                serverApnCtx.set(ctx.pipeline().context(this) != null);\n                                serverApnDoneLatch.countDown();\n                            }\n                        });\n                    }\n                });\n\n                Bootstrap cb = new Bootstrap();\n                cb.group(group);\n                cb.channel(NioSocketChannel.class);\n                cb.handler(new ChannelInitializer<Channel>() {\n                    @Override\n                    protected void initChannel(Channel ch) throws Exception {\n                        ch.pipeline().addLast(new SslHandler(clientContext.newEngine(\n                                ch.alloc(), \"sni.fake.site\", -1)));\n                        // Catch the notification event that APN has completed successfully.\n                        ch.pipeline().addLast(new ApplicationProtocolNegotiationHandler(\"foo\") {\n                            @Override\n                            protected void configurePipeline(ChannelHandlerContext ctx, String protocol) {\n                                // addresses issue #9131\n                                clientApnCtx.set(ctx.pipeline().context(this) != null);\n                                clientApnDoneLatch.countDown();\n                            }\n                        });\n                    }\n                });\n\n                serverChannel = sb.bind(new InetSocketAddress(0)).sync().channel();\n\n                ChannelFuture ccf = cb.connect(serverChannel.localAddress());\n                assertTrue(ccf.awaitUninterruptibly().isSuccess());\n                clientChannel = ccf.channel();\n\n                assertTrue(serverApnDoneLatch.await(5, TimeUnit.SECONDS));\n                assertTrue(clientApnDoneLatch.await(5, TimeUnit.SECONDS));\n                assertTrue(serverApnCtx.get());\n                assertTrue(clientApnCtx.get());\n                assertThat(handler.hostname(), is(\"sni.fake.site\"));\n                assertThat(handler.sslContext(), is(sniContext));\n            } finally {\n                if (serverChannel != null) {\n                    serverChannel.close().sync();\n                }\n                if (clientChannel != null) {\n                    clientChannel.close().sync();\n                }\n                group.shutdownGracefully(0, 0, TimeUnit.MICROSECONDS);\n            }\n        } finally {\n            releaseAll(clientContext, nettyContext, sniContext);\n        }\n    }\n\n    @ParameterizedTest(name = \"{index}: sslProvider={0}\")\n    @MethodSource(\"data\")\n    @Timeout(value = 30000, unit = TimeUnit.MILLISECONDS)\n    public void testReplaceHandler(SslProvider provider) throws Exception {\n        switch (provider) {\n            case OPENSSL:\n            case OPENSSL_REFCNT:\n                final String sniHost = \"sni.netty.io\";\n                LocalAddress address = new LocalAddress(\"testReplaceHandler-\" + Math.random());\n                EventLoopGroup group = new DefaultEventLoopGroup(1);\n                Channel sc = null;\n                Channel cc = null;\n                SslContext sslContext = null;\n\n                SelfSignedCertificate cert = new SelfSignedCertificate();\n\n                try {\n                    final SslContext sslServerContext = SslContextBuilder\n                            .forServer(cert.key(), cert.cert())\n                            .sslProvider(provider)\n                            .build();\n\n                    final Mapping<String, SslContext> mapping = new Mapping<String, SslContext>() {\n                        @Override\n                        public SslContext map(String input) {\n                            return sslServerContext;\n                        }\n                    };\n\n                    final Promise<Void> releasePromise = group.next().newPromise();\n\n                    final SniHandler handler = new SniHandler(mapping) {\n                        @Override\n                        protected void replaceHandler(ChannelHandlerContext ctx,\n                                                      String hostname, final SslContext sslContext)\n                                throws Exception {\n\n                            boolean success = false;\n                            try {\n                                assertEquals(1, ((ReferenceCountedOpenSslContext) sslContext).refCnt());\n                                // The SniHandler's replaceHandler() method allows us to implement custom behavior.\n                                // As an example, we want to release() the SslContext upon channelInactive() or rather\n                                // when the SslHandler closes it's SslEngine. If you take a close look at SslHandler\n                                // you'll see that it's doing it in the #handlerRemoved0() method.\n\n                                SSLEngine sslEngine = sslContext.newEngine(ctx.alloc());\n                                try {\n                                    assertEquals(2, ((ReferenceCountedOpenSslContext) sslContext).refCnt());\n                                    SslHandler customSslHandler = new CustomSslHandler(sslContext, sslEngine) {\n                                        @Override\n                                        public void handlerRemoved0(ChannelHandlerContext ctx) throws Exception {\n                                            try {\n                                                super.handlerRemoved0(ctx);\n                                            } finally {\n                                                releasePromise.trySuccess(null);\n                                            }\n                                        }\n                                    };\n                                    ctx.pipeline().replace(this, CustomSslHandler.class.getName(), customSslHandler);\n                                    success = true;\n                                } finally {\n                                    if (!success) {\n                                        ReferenceCountUtil.safeRelease(sslEngine);\n                                    }\n                                }\n                            } finally {\n                                if (!success) {\n                                    ReferenceCountUtil.safeRelease(sslContext);\n                                    releasePromise.cancel(true);\n                                }\n                            }\n                        }\n                    };\n\n                    ServerBootstrap sb = new ServerBootstrap();\n                    sc = sb.group(group).channel(LocalServerChannel.class)\n                            .childHandler(new ChannelInitializer<Channel>() {\n                        @Override\n                        protected void initChannel(Channel ch) throws Exception {\n                            ch.pipeline().addFirst(handler);\n                        }\n                    }).bind(address).syncUninterruptibly().channel();\n\n                    sslContext = SslContextBuilder.forClient().sslProvider(provider)\n                            .trustManager(InsecureTrustManagerFactory.INSTANCE).build();\n\n                    Bootstrap cb = new Bootstrap();\n                    cc = cb.group(group).channel(LocalChannel.class).handler(new SslHandler(\n                            sslContext.newEngine(ByteBufAllocator.DEFAULT, sniHost, -1)))\n                            .connect(address).syncUninterruptibly().channel();\n\n                    cc.writeAndFlush(Unpooled.wrappedBuffer(\"Hello, World!\".getBytes()))\n                            .syncUninterruptibly();\n\n                    // Notice how the server's SslContext refCnt is 2 as it is incremented when the SSLEngine is created\n                    // and only decremented once it is destroyed.\n                    assertEquals(2, ((ReferenceCounted) sslServerContext).refCnt());\n\n                    // The client disconnects\n                    cc.close().syncUninterruptibly();\n                    if (!releasePromise.awaitUninterruptibly(10L, TimeUnit.SECONDS)) {\n                        throw new IllegalStateException(\"It doesn't seem #replaceHandler() got called.\");\n                    }\n\n                    // We should have successfully release() the SslContext\n                    assertEquals(0, ((ReferenceCounted) sslServerContext).refCnt());\n                } finally {\n                    if (cc != null) {\n                        cc.close().syncUninterruptibly();\n                    }\n                    if (sc != null) {\n                        sc.close().syncUninterruptibly();\n                    }\n                    if (sslContext != null) {\n                        ReferenceCountUtil.release(sslContext);\n                    }\n                    group.shutdownGracefully();\n\n                    cert.delete();\n                }\n            case JDK:\n                return;\n            default:\n                throw new Error();\n        }\n    }\n\n    /**\n     * This is a {@link SslHandler} that will call {@code release()} on the {@link SslContext} when\n     * the client disconnects.\n     *\n     * @see SniHandlerTest#testReplaceHandler(SslProvider)\n     */\n    private static class CustomSslHandler extends SslHandler {\n        private final SslContext sslContext;\n\n        CustomSslHandler(SslContext sslContext, SSLEngine sslEngine) {\n            super(sslEngine);\n            this.sslContext = ObjectUtil.checkNotNull(sslContext, \"sslContext\");\n        }\n\n        @Override\n        public void handlerRemoved0(ChannelHandlerContext ctx) throws Exception {\n            super.handlerRemoved0(ctx);\n            ReferenceCountUtil.release(sslContext);\n        }\n    }\n\n    private static void releaseAll(SslContext... contexts) {\n        for (SslContext ctx: contexts) {\n            ReferenceCountUtil.release(ctx);\n        }\n    }\n\n    @ParameterizedTest(name = \"{index}: sslProvider={0}\")\n    @MethodSource(\"data\")\n    public void testNonFragmented(SslProvider provider) throws Exception {\n        testWithFragmentSize(provider, Integer.MAX_VALUE);\n    }\n\n    @ParameterizedTest(name = \"{index}: sslProvider={0}\")\n    @MethodSource(\"data\")\n    public void testFragmented(SslProvider provider) throws Exception {\n        testWithFragmentSize(provider, 50);\n    }\n\n    private void testWithFragmentSize(SslProvider provider, final int maxFragmentSize) throws Exception {\n        final String sni = \"netty.io\";\n        SelfSignedCertificate cert = new SelfSignedCertificate();\n        final SslContext context = SslContextBuilder.forServer(cert.key(), cert.cert())\n                .sslProvider(provider)\n                .build();\n        try {\n            @SuppressWarnings(\"unchecked\") final EmbeddedChannel server = new EmbeddedChannel(\n                    new SniHandler(mock(DomainNameMapping.class)) {\n                @Override\n                protected Future<SslContext> lookup(final ChannelHandlerContext ctx, final String hostname) {\n                    assertEquals(sni, hostname);\n                    return ctx.executor().newSucceededFuture(context);\n                }\n            });\n\n            final List<ByteBuf> buffers = clientHelloInMultipleFragments(provider, sni, maxFragmentSize);\n            for (ByteBuf buffer : buffers) {\n                server.writeInbound(buffer);\n            }\n            assertTrue(server.finishAndReleaseAll());\n        } finally {\n            releaseAll(context);\n            cert.delete();\n        }\n    }\n\n    private static List<ByteBuf> clientHelloInMultipleFragments(\n            SslProvider provider, String hostname, int maxTlsPlaintextSize) throws SSLException {\n        final EmbeddedChannel client = new EmbeddedChannel();\n        final SslContext ctx = SslContextBuilder.forClient()\n                .sslProvider(provider)\n                .trustManager(InsecureTrustManagerFactory.INSTANCE)\n                .build();\n        try {\n            final SslHandler sslHandler = ctx.newHandler(client.alloc(), hostname, -1);\n            client.pipeline().addLast(sslHandler);\n            final ByteBuf clientHello = client.readOutbound();\n            List<ByteBuf> buffers = split(clientHello, maxTlsPlaintextSize);\n            assertTrue(client.finishAndReleaseAll());\n            return buffers;\n        } finally {\n            releaseAll(ctx);\n        }\n    }\n\n    private static List<ByteBuf> split(ByteBuf clientHello, int maxSize) {\n        final int type = clientHello.readUnsignedByte();\n        final int version = clientHello.readUnsignedShort();\n        final int length = clientHello.readUnsignedShort();\n        assertEquals(length, clientHello.readableBytes());\n\n        final List<ByteBuf> result = new ArrayList<ByteBuf>();\n        while (clientHello.readableBytes() > 0) {\n            final int toRead = Math.min(maxSize, clientHello.readableBytes());\n            final ByteBuf bb = clientHello.alloc().buffer(SslUtils.SSL_RECORD_HEADER_LENGTH + toRead);\n            bb.writeByte(type);\n            bb.writeShort(version);\n            bb.writeShort(toRead);\n            bb.writeBytes(clientHello, toRead);\n            result.add(bb);\n        }\n        clientHello.release();\n        return result;\n    }\n\n    @Test\n    public void testSniHandlerFiresHandshakeTimeout() throws Exception {\n        SniHandler handler = new SniHandler(new Mapping<String, SslContext>() {\n            @Override\n            public SslContext map(String input) {\n                throw new UnsupportedOperationException(\"Should not be called\");\n            }\n        }, 10);\n\n        final AtomicReference<SniCompletionEvent> completionEventRef =\n            new AtomicReference<SniCompletionEvent>();\n        EmbeddedChannel ch = new EmbeddedChannel(handler, new ChannelInboundHandlerAdapter() {\n            @Override\n            public void userEventTriggered(ChannelHandlerContext ctx, Object evt) {\n                if (evt instanceof SniCompletionEvent) {\n                    completionEventRef.set((SniCompletionEvent) evt);\n                }\n            }\n        });\n        try {\n            while (completionEventRef.get() == null) {\n                Thread.sleep(100);\n                // We need to run all pending tasks as the handshake timeout is scheduled on the EventLoop.\n                ch.runPendingTasks();\n            }\n            SniCompletionEvent completionEvent = completionEventRef.get();\n            assertNotNull(completionEvent);\n            assertNotNull(completionEvent.cause());\n            assertEquals(SslHandshakeTimeoutException.class, completionEvent.cause().getClass());\n        } finally {\n            ch.finishAndReleaseAll();\n        }\n    }\n\n    @ParameterizedTest(name = \"{index}: sslProvider={0}\")\n    @MethodSource(\"data\")\n    public void testSslHandlerFiresHandshakeTimeout(SslProvider provider) throws Exception {\n        final SslContext context = makeSslContext(provider, false);\n        SniHandler handler = new SniHandler(new Mapping<String, SslContext>() {\n            @Override\n            public SslContext map(String input) {\n                return context;\n            }\n        }, 100);\n\n        final AtomicReference<SniCompletionEvent> sniCompletionEventRef =\n            new AtomicReference<SniCompletionEvent>();\n        final AtomicReference<SslHandshakeCompletionEvent> handshakeCompletionEventRef =\n            new AtomicReference<SslHandshakeCompletionEvent>();\n        EmbeddedChannel ch = new EmbeddedChannel(handler, new ChannelInboundHandlerAdapter() {\n            @Override\n            public void userEventTriggered(ChannelHandlerContext ctx, Object evt) {\n                if (evt instanceof SniCompletionEvent) {\n                    sniCompletionEventRef.set((SniCompletionEvent) evt);\n                } else if (evt instanceof SslHandshakeCompletionEvent) {\n                    handshakeCompletionEventRef.set((SslHandshakeCompletionEvent) evt);\n                }\n            }\n        });\n        try {\n            // Send enough data to add the SslHandler and let the handshake incomplete\n            // Client Hello with \"host1\" server name\n            ch.writeInbound(Unpooled.wrappedBuffer(StringUtil.decodeHexDump(\n                \"16030301800100017c0303478ae7e536aa7a9debad1f873121862d2d3d3173e0ef42975c31007faeb2\" +\n                \"52522047f55f81fc84fe58951e2af14026147d6178498fde551fcbafc636462c016ec9005a13011302\" +\n                \"c02cc02bc030009dc02ec032009f00a3c02f009cc02dc031009e00a2c024c028003dc026c02a006b00\" +\n                \"6ac00ac0140035c005c00f00390038c023c027003cc025c02900670040c009c013002fc004c00e0033\" +\n                \"003200ff010000d90000000a0008000005686f737431000500050100000000000a00160014001d0017\" +\n                \"00180019001e01000101010201030104000b00020100000d0028002604030503060308040805080608\" +\n                \"09080a080b040105010601040203030301030202030201020200320028002604030503060308040805\" +\n                \"08060809080a080b040105010601040203030301030202030201020200110009000702000400000000\" +\n                \"00170000002b00050403040303002d00020101003300260024001d00200bbc37375e214c1e4e7cb90f\" +\n                \"869e131dc983a21f8205ba24456177f340904935\")));\n\n            while (handshakeCompletionEventRef.get() == null) {\n                Thread.sleep(10);\n                // We need to run all pending tasks as the handshake timeout is scheduled on the EventLoop.\n                ch.runPendingTasks();\n            }\n            SniCompletionEvent sniCompletionEvent = sniCompletionEventRef.get();\n            assertNotNull(sniCompletionEvent);\n            assertEquals(\"host1\", sniCompletionEvent.hostname());\n            SslCompletionEvent handshakeCompletionEvent = handshakeCompletionEventRef.get();\n            assertNotNull(handshakeCompletionEvent);\n            assertNotNull(handshakeCompletionEvent.cause());\n            assertEquals(SslHandshakeTimeoutException.class, handshakeCompletionEvent.cause().getClass());\n        } finally {\n            ch.finishAndReleaseAll();\n            releaseAll(context);\n        }\n    }\n}\n"], "fixing_code": ["/*\n * Copyright 2017 The Netty Project\n *\n * The Netty Project licenses this file to you under the Apache License,\n * version 2.0 (the \"License\"); you may not use this file except in compliance\n * with the License. You may obtain a copy of the License at:\n *\n *   https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations\n * under the License.\n */\npackage io.netty.handler.ssl;\n\nimport io.netty.buffer.ByteBuf;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.util.CharsetUtil;\nimport io.netty.util.concurrent.Future;\nimport io.netty.util.concurrent.ScheduledFuture;\n\nimport java.util.Locale;\nimport java.util.concurrent.TimeUnit;\n\nimport static io.netty.util.internal.ObjectUtil.checkPositiveOrZero;\n\n/**\n * <p>Enables <a href=\"https://tools.ietf.org/html/rfc3546#section-3.1\">SNI\n * (Server Name Indication)</a> extension for server side SSL. For clients\n * support SNI, the server could have multiple host name bound on a single IP.\n * The client will send host name in the handshake data so server could decide\n * which certificate to choose for the host name.</p>\n */\npublic abstract class AbstractSniHandler<T> extends SslClientHelloHandler<T> {\n\n    private static String extractSniHostname(ByteBuf in) {\n        // See https://tools.ietf.org/html/rfc5246#section-7.4.1.2\n        //\n        // Decode the ssl client hello packet.\n        //\n        // struct {\n        //    ProtocolVersion client_version;\n        //    Random random;\n        //    SessionID session_id;\n        //    CipherSuite cipher_suites<2..2^16-2>;\n        //    CompressionMethod compression_methods<1..2^8-1>;\n        //    select (extensions_present) {\n        //        case false:\n        //            struct {};\n        //        case true:\n        //            Extension extensions<0..2^16-1>;\n        //    };\n        // } ClientHello;\n        //\n\n        // We have to skip bytes until SessionID (which sum to 34 bytes in this case).\n        int offset = in.readerIndex();\n        int endOffset = in.writerIndex();\n        offset += 34;\n\n        if (endOffset - offset >= 6) {\n            final int sessionIdLength = in.getUnsignedByte(offset);\n            offset += sessionIdLength + 1;\n\n            final int cipherSuitesLength = in.getUnsignedShort(offset);\n            offset += cipherSuitesLength + 2;\n\n            final int compressionMethodLength = in.getUnsignedByte(offset);\n            offset += compressionMethodLength + 1;\n\n            final int extensionsLength = in.getUnsignedShort(offset);\n            offset += 2;\n            final int extensionsLimit = offset + extensionsLength;\n\n            // Extensions should never exceed the record boundary.\n            if (extensionsLimit <= endOffset) {\n                while (extensionsLimit - offset >= 4) {\n                    final int extensionType = in.getUnsignedShort(offset);\n                    offset += 2;\n\n                    final int extensionLength = in.getUnsignedShort(offset);\n                    offset += 2;\n\n                    if (extensionsLimit - offset < extensionLength) {\n                        break;\n                    }\n\n                    // SNI\n                    // See https://tools.ietf.org/html/rfc6066#page-6\n                    if (extensionType == 0) {\n                        offset += 2;\n                        if (extensionsLimit - offset < 3) {\n                            break;\n                        }\n\n                        final int serverNameType = in.getUnsignedByte(offset);\n                        offset++;\n\n                        if (serverNameType == 0) {\n                            final int serverNameLength = in.getUnsignedShort(offset);\n                            offset += 2;\n\n                            if (extensionsLimit - offset < serverNameLength) {\n                                break;\n                            }\n\n                            final String hostname = in.toString(offset, serverNameLength, CharsetUtil.US_ASCII);\n                            return hostname.toLowerCase(Locale.US);\n                        } else {\n                            // invalid enum value\n                            break;\n                        }\n                    }\n\n                    offset += extensionLength;\n                }\n            }\n        }\n        return null;\n    }\n\n    protected final long handshakeTimeoutMillis;\n    private ScheduledFuture<?> timeoutFuture;\n    private String hostname;\n\n    /**\n     * @param handshakeTimeoutMillis    the handshake timeout in milliseconds\n     */\n    protected AbstractSniHandler(long handshakeTimeoutMillis) {\n        this(0, handshakeTimeoutMillis);\n    }\n\n    /**\n     * @paramm maxClientHelloLength     the maximum length of the client hello message.\n     * @param handshakeTimeoutMillis    the handshake timeout in milliseconds\n     */\n    protected AbstractSniHandler(int maxClientHelloLength, long handshakeTimeoutMillis) {\n        super(maxClientHelloLength);\n        this.handshakeTimeoutMillis = checkPositiveOrZero(handshakeTimeoutMillis, \"handshakeTimeoutMillis\");\n    }\n\n    public AbstractSniHandler() {\n        this(0, 0L);\n    }\n\n    @Override\n    public void handlerAdded(ChannelHandlerContext ctx) throws Exception {\n        if (ctx.channel().isActive()) {\n            checkStartTimeout(ctx);\n        }\n    }\n\n    @Override\n    public void channelActive(ChannelHandlerContext ctx) throws Exception {\n        ctx.fireChannelActive();\n        checkStartTimeout(ctx);\n    }\n\n    private void checkStartTimeout(final ChannelHandlerContext ctx) {\n        if (handshakeTimeoutMillis <= 0 || timeoutFuture != null) {\n            return;\n        }\n        timeoutFuture = ctx.executor().schedule(new Runnable() {\n            @Override\n            public void run() {\n                if (ctx.channel().isActive()) {\n                    SslHandshakeTimeoutException exception = new SslHandshakeTimeoutException(\n                        \"handshake timed out after \" + handshakeTimeoutMillis + \"ms\");\n                    ctx.fireUserEventTriggered(new SniCompletionEvent(exception));\n                    ctx.close();\n                }\n            }\n        }, handshakeTimeoutMillis, TimeUnit.MILLISECONDS);\n    }\n\n    @Override\n    protected Future<T> lookup(ChannelHandlerContext ctx, ByteBuf clientHello) throws Exception {\n        hostname = clientHello == null ? null : extractSniHostname(clientHello);\n\n        return lookup(ctx, hostname);\n    }\n\n    @Override\n    protected void onLookupComplete(ChannelHandlerContext ctx, Future<T> future) throws Exception {\n        if (timeoutFuture != null) {\n            timeoutFuture.cancel(false);\n        }\n        try {\n            onLookupComplete(ctx, hostname, future);\n        } finally {\n            fireSniCompletionEvent(ctx, hostname, future);\n        }\n    }\n\n    /**\n     * Kicks off a lookup for the given SNI value and returns a {@link Future} which in turn will\n     * notify the {@link #onLookupComplete(ChannelHandlerContext, String, Future)} on completion.\n     *\n     * @see #onLookupComplete(ChannelHandlerContext, String, Future)\n     */\n    protected abstract Future<T> lookup(ChannelHandlerContext ctx, String hostname) throws Exception;\n\n    /**\n     * Called upon completion of the {@link #lookup(ChannelHandlerContext, String)} {@link Future}.\n     *\n     * @see #lookup(ChannelHandlerContext, String)\n     */\n    protected abstract void onLookupComplete(ChannelHandlerContext ctx,\n                                             String hostname, Future<T> future) throws Exception;\n\n    private static void fireSniCompletionEvent(ChannelHandlerContext ctx, String hostname, Future<?> future) {\n        Throwable cause = future.cause();\n        if (cause == null) {\n            ctx.fireUserEventTriggered(new SniCompletionEvent(hostname));\n        } else {\n            ctx.fireUserEventTriggered(new SniCompletionEvent(hostname, cause));\n        }\n    }\n}\n", "/*\n * Copyright 2014 The Netty Project\n *\n * The Netty Project licenses this file to you under the Apache License,\n * version 2.0 (the \"License\"); you may not use this file except in compliance\n * with the License. You may obtain a copy of the License at:\n *\n *   https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations\n * under the License.\n */\npackage io.netty.handler.ssl;\n\nimport io.netty.buffer.ByteBufAllocator;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.handler.codec.DecoderException;\nimport io.netty.util.AsyncMapping;\nimport io.netty.util.DomainNameMapping;\nimport io.netty.util.Mapping;\nimport io.netty.util.ReferenceCountUtil;\nimport io.netty.util.concurrent.Future;\nimport io.netty.util.concurrent.Promise;\nimport io.netty.util.internal.ObjectUtil;\nimport io.netty.util.internal.PlatformDependent;\n\n/**\n * <p>Enables <a href=\"https://tools.ietf.org/html/rfc3546#section-3.1\">SNI\n * (Server Name Indication)</a> extension for server side SSL. For clients\n * support SNI, the server could have multiple host name bound on a single IP.\n * The client will send host name in the handshake data so server could decide\n * which certificate to choose for the host name.</p>\n */\npublic class SniHandler extends AbstractSniHandler<SslContext> {\n    private static final Selection EMPTY_SELECTION = new Selection(null, null);\n\n    protected final AsyncMapping<String, SslContext> mapping;\n\n    private volatile Selection selection = EMPTY_SELECTION;\n\n    /**\n     * Creates a SNI detection handler with configured {@link SslContext}\n     * maintained by {@link Mapping}\n     *\n     * @param mapping the mapping of domain name to {@link SslContext}\n     */\n    public SniHandler(Mapping<? super String, ? extends SslContext> mapping) {\n        this(new AsyncMappingAdapter(mapping));\n    }\n\n    /**\n     * Creates a SNI detection handler with configured {@link SslContext}\n     * maintained by {@link Mapping}\n     *\n     * @param mapping the mapping of domain name to {@link SslContext}\n     * @param maxClientHelloLength the maximum length of the client hello message\n     * @param handshakeTimeoutMillis the handshake timeout in milliseconds\n     */\n    public SniHandler(Mapping<? super String, ? extends SslContext> mapping,\n                      int maxClientHelloLength, long handshakeTimeoutMillis) {\n        this(new AsyncMappingAdapter(mapping), maxClientHelloLength, handshakeTimeoutMillis);\n    }\n\n    /**\n     * Creates a SNI detection handler with configured {@link SslContext}\n     * maintained by {@link DomainNameMapping}\n     *\n     * @param mapping the mapping of domain name to {@link SslContext}\n     */\n    public SniHandler(DomainNameMapping<? extends SslContext> mapping) {\n        this((Mapping<String, ? extends SslContext>) mapping);\n    }\n\n    /**\n     * Creates a SNI detection handler with configured {@link SslContext}\n     * maintained by {@link AsyncMapping}\n     *\n     * @param mapping the mapping of domain name to {@link SslContext}\n     */\n    @SuppressWarnings(\"unchecked\")\n    public SniHandler(AsyncMapping<? super String, ? extends SslContext> mapping) {\n        this(mapping, 0, 0L);\n    }\n\n    /**\n     * Creates a SNI detection handler with configured {@link SslContext}\n     * maintained by {@link AsyncMapping}\n     *\n     * @param mapping the mapping of domain name to {@link SslContext}\n     * @param maxClientHelloLength the maximum length of the client hello message\n     * @param handshakeTimeoutMillis the handshake timeout in milliseconds\n     */\n    @SuppressWarnings(\"unchecked\")\n    public SniHandler(AsyncMapping<? super String, ? extends SslContext> mapping,\n                      int maxClientHelloLength, long handshakeTimeoutMillis) {\n        super(maxClientHelloLength, handshakeTimeoutMillis);\n        this.mapping = (AsyncMapping<String, SslContext>) ObjectUtil.checkNotNull(mapping, \"mapping\");\n    }\n\n    /**\n     * Creates a SNI detection handler with configured {@link SslContext}\n     * maintained by {@link Mapping}\n     *\n     * @param mapping the mapping of domain name to {@link SslContext}\n     * @param handshakeTimeoutMillis the handshake timeout in milliseconds\n     */\n    public SniHandler(Mapping<? super String, ? extends SslContext> mapping, long handshakeTimeoutMillis) {\n        this(new AsyncMappingAdapter(mapping), handshakeTimeoutMillis);\n    }\n\n    /**\n     * Creates a SNI detection handler with configured {@link SslContext}\n     * maintained by {@link AsyncMapping}\n     *\n     * @param mapping the mapping of domain name to {@link SslContext}\n     * @param handshakeTimeoutMillis the handshake timeout in milliseconds\n     */\n    public SniHandler(AsyncMapping<? super String, ? extends SslContext> mapping, long handshakeTimeoutMillis) {\n        this(mapping, 0, handshakeTimeoutMillis);\n    }\n\n    /**\n     * @return the selected hostname\n     */\n    public String hostname() {\n        return selection.hostname;\n    }\n\n    /**\n     * @return the selected {@link SslContext}\n     */\n    public SslContext sslContext() {\n        return selection.context;\n    }\n\n    /**\n     * The default implementation will simply call {@link AsyncMapping#map(Object, Promise)} but\n     * users can override this method to implement custom behavior.\n     *\n     * @see AsyncMapping#map(Object, Promise)\n     */\n    @Override\n    protected Future<SslContext> lookup(ChannelHandlerContext ctx, String hostname) throws Exception {\n        return mapping.map(hostname, ctx.executor().<SslContext>newPromise());\n    }\n\n    @Override\n    protected final void onLookupComplete(ChannelHandlerContext ctx,\n                                          String hostname, Future<SslContext> future) throws Exception {\n        if (!future.isSuccess()) {\n            final Throwable cause = future.cause();\n            if (cause instanceof Error) {\n                throw (Error) cause;\n            }\n            throw new DecoderException(\"failed to get the SslContext for \" + hostname, cause);\n        }\n\n        SslContext sslContext = future.getNow();\n        selection = new Selection(sslContext, hostname);\n        try {\n            replaceHandler(ctx, hostname, sslContext);\n        } catch (Throwable cause) {\n            selection = EMPTY_SELECTION;\n            PlatformDependent.throwException(cause);\n        }\n    }\n\n    /**\n     * The default implementation of this method will simply replace {@code this} {@link SniHandler}\n     * instance with a {@link SslHandler}. Users may override this method to implement custom behavior.\n     *\n     * Please be aware that this method may get called after a client has already disconnected and\n     * custom implementations must take it into consideration when overriding this method.\n     *\n     * It's also possible for the hostname argument to be {@code null}.\n     */\n    protected void replaceHandler(ChannelHandlerContext ctx, String hostname, SslContext sslContext) throws Exception {\n        SslHandler sslHandler = null;\n        try {\n            sslHandler = newSslHandler(sslContext, ctx.alloc());\n            ctx.pipeline().replace(this, SslHandler.class.getName(), sslHandler);\n            sslHandler = null;\n        } finally {\n            // Since the SslHandler was not inserted into the pipeline the ownership of the SSLEngine was not\n            // transferred to the SslHandler.\n            // See https://github.com/netty/netty/issues/5678\n            if (sslHandler != null) {\n                ReferenceCountUtil.safeRelease(sslHandler.engine());\n            }\n        }\n    }\n\n    /**\n     * Returns a new {@link SslHandler} using the given {@link SslContext} and {@link ByteBufAllocator}.\n     * Users may override this method to implement custom behavior.\n     */\n    protected SslHandler newSslHandler(SslContext context, ByteBufAllocator allocator) {\n        SslHandler sslHandler = context.newHandler(allocator);\n        sslHandler.setHandshakeTimeoutMillis(handshakeTimeoutMillis);\n        return sslHandler;\n    }\n\n    private static final class AsyncMappingAdapter implements AsyncMapping<String, SslContext> {\n        private final Mapping<? super String, ? extends SslContext> mapping;\n\n        private AsyncMappingAdapter(Mapping<? super String, ? extends SslContext> mapping) {\n            this.mapping = ObjectUtil.checkNotNull(mapping, \"mapping\");\n        }\n\n        @Override\n        public Future<SslContext> map(String input, Promise<SslContext> promise) {\n            final SslContext context;\n            try {\n                context = mapping.map(input);\n            } catch (Throwable cause) {\n                return promise.setFailure(cause);\n            }\n            return promise.setSuccess(context);\n        }\n    }\n\n    private static final class Selection {\n        final SslContext context;\n        final String hostname;\n\n        Selection(SslContext context, String hostname) {\n            this.context = context;\n            this.hostname = hostname;\n        }\n    }\n}\n", "/*\n * Copyright 2017 The Netty Project\n *\n * The Netty Project licenses this file to you under the Apache License,\n * version 2.0 (the \"License\"); you may not use this file except in compliance\n * with the License. You may obtain a copy of the License at:\n *\n *   https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations\n * under the License.\n */\npackage io.netty.handler.ssl;\n\nimport io.netty.buffer.ByteBuf;\nimport io.netty.buffer.ByteBufUtil;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.ChannelOutboundHandler;\nimport io.netty.channel.ChannelPromise;\nimport io.netty.handler.codec.ByteToMessageDecoder;\nimport io.netty.handler.codec.DecoderException;\nimport io.netty.handler.codec.TooLongFrameException;\nimport io.netty.util.concurrent.Future;\nimport io.netty.util.concurrent.FutureListener;\nimport io.netty.util.internal.ObjectUtil;\nimport io.netty.util.internal.PlatformDependent;\nimport io.netty.util.internal.logging.InternalLogger;\nimport io.netty.util.internal.logging.InternalLoggerFactory;\n\nimport java.net.SocketAddress;\nimport java.util.List;\n\n/**\n * {@link ByteToMessageDecoder} which allows to be notified once a full {@code ClientHello} was received.\n */\npublic abstract class SslClientHelloHandler<T> extends ByteToMessageDecoder implements ChannelOutboundHandler {\n\n    /**\n     * The maximum length of client hello message as defined by\n     * <a href=\"https://www.rfc-editor.org/rfc/rfc5246#section-6.2.1\">RFC5246</a>.\n     */\n    public static final int MAX_CLIENT_HELLO_LENGTH = 0xFFFFFF;\n\n    private static final InternalLogger logger =\n            InternalLoggerFactory.getInstance(SslClientHelloHandler.class);\n\n    private final int maxClientHelloLength;\n    private boolean handshakeFailed;\n    private boolean suppressRead;\n    private boolean readPending;\n    private ByteBuf handshakeBuffer;\n\n    public SslClientHelloHandler() {\n        this(MAX_CLIENT_HELLO_LENGTH);\n    }\n\n    protected SslClientHelloHandler(int maxClientHelloLength) {\n        // 16MB is the maximum as per RFC:\n        // See https://www.rfc-editor.org/rfc/rfc5246#section-6.2.1\n        this.maxClientHelloLength =\n                ObjectUtil.checkInRange(maxClientHelloLength, 0, MAX_CLIENT_HELLO_LENGTH, \"maxClientHelloLength\");\n    }\n\n    @Override\n    protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exception {\n        if (!suppressRead && !handshakeFailed) {\n            try {\n                int readerIndex = in.readerIndex();\n                int readableBytes = in.readableBytes();\n                int handshakeLength = -1;\n\n                // Check if we have enough data to determine the record type and length.\n                while (readableBytes >= SslUtils.SSL_RECORD_HEADER_LENGTH) {\n                    final int contentType = in.getUnsignedByte(readerIndex);\n                    switch (contentType) {\n                        case SslUtils.SSL_CONTENT_TYPE_CHANGE_CIPHER_SPEC:\n                            // fall-through\n                        case SslUtils.SSL_CONTENT_TYPE_ALERT:\n                            final int len = SslUtils.getEncryptedPacketLength(in, readerIndex);\n\n                            // Not an SSL/TLS packet\n                            if (len == SslUtils.NOT_ENCRYPTED) {\n                                handshakeFailed = true;\n                                NotSslRecordException e = new NotSslRecordException(\n                                        \"not an SSL/TLS record: \" + ByteBufUtil.hexDump(in));\n                                in.skipBytes(in.readableBytes());\n                                ctx.fireUserEventTriggered(new SniCompletionEvent(e));\n                                SslUtils.handleHandshakeFailure(ctx, e, true);\n                                throw e;\n                            }\n                            if (len == SslUtils.NOT_ENOUGH_DATA) {\n                                // Not enough data\n                                return;\n                            }\n                            // No ClientHello\n                            select(ctx, null);\n                            return;\n                        case SslUtils.SSL_CONTENT_TYPE_HANDSHAKE:\n                            final int majorVersion = in.getUnsignedByte(readerIndex + 1);\n                            // SSLv3 or TLS\n                            if (majorVersion == 3) {\n                                int packetLength = in.getUnsignedShort(readerIndex + 3) +\n                                        SslUtils.SSL_RECORD_HEADER_LENGTH;\n\n                                if (readableBytes < packetLength) {\n                                    // client hello incomplete; try again to decode once more data is ready.\n                                    return;\n                                } else if (packetLength == SslUtils.SSL_RECORD_HEADER_LENGTH) {\n                                    select(ctx, null);\n                                    return;\n                                }\n\n                                final int endOffset = readerIndex + packetLength;\n\n                                // Let's check if we already parsed the handshake length or not.\n                                if (handshakeLength == -1) {\n                                    if (readerIndex + 4 > endOffset) {\n                                        // Need more data to read HandshakeType and handshakeLength (4 bytes)\n                                        return;\n                                    }\n\n                                    final int handshakeType = in.getUnsignedByte(readerIndex +\n                                            SslUtils.SSL_RECORD_HEADER_LENGTH);\n\n                                    // Check if this is a clientHello(1)\n                                    // See https://tools.ietf.org/html/rfc5246#section-7.4\n                                    if (handshakeType != 1) {\n                                        select(ctx, null);\n                                        return;\n                                    }\n\n                                    // Read the length of the handshake as it may arrive in fragments\n                                    // See https://tools.ietf.org/html/rfc5246#section-7.4\n                                    handshakeLength = in.getUnsignedMedium(readerIndex +\n                                            SslUtils.SSL_RECORD_HEADER_LENGTH + 1);\n\n                                    if (handshakeLength > maxClientHelloLength && maxClientHelloLength != 0) {\n                                        TooLongFrameException e = new TooLongFrameException(\n                                                \"ClientHello length exceeds \" + maxClientHelloLength +\n                                                        \": \" + handshakeLength);\n                                        in.skipBytes(in.readableBytes());\n                                        ctx.fireUserEventTriggered(new SniCompletionEvent(e));\n                                        SslUtils.handleHandshakeFailure(ctx, e, true);\n                                        throw e;\n                                    }\n                                    // Consume handshakeType and handshakeLength (this sums up as 4 bytes)\n                                    readerIndex += 4;\n                                    packetLength -= 4;\n\n                                    if (handshakeLength + 4 + SslUtils.SSL_RECORD_HEADER_LENGTH <= packetLength) {\n                                        // We have everything we need in one packet.\n                                        // Skip the record header\n                                        readerIndex += SslUtils.SSL_RECORD_HEADER_LENGTH;\n                                        select(ctx, in.retainedSlice(readerIndex, handshakeLength));\n                                        return;\n                                    } else {\n                                        if (handshakeBuffer == null) {\n                                            handshakeBuffer = ctx.alloc().buffer(handshakeLength);\n                                        } else {\n                                            // Clear the buffer so we can aggregate into it again.\n                                            handshakeBuffer.clear();\n                                        }\n                                    }\n                                }\n\n                                // Combine the encapsulated data in one buffer but not include the SSL_RECORD_HEADER\n                                handshakeBuffer.writeBytes(in, readerIndex + SslUtils.SSL_RECORD_HEADER_LENGTH,\n                                        packetLength - SslUtils.SSL_RECORD_HEADER_LENGTH);\n                                readerIndex += packetLength;\n                                readableBytes -= packetLength;\n                                if (handshakeLength <= handshakeBuffer.readableBytes()) {\n                                    ByteBuf clientHello = handshakeBuffer.setIndex(0, handshakeLength);\n                                    handshakeBuffer = null;\n\n                                    select(ctx, clientHello);\n                                    return;\n                                }\n                                break;\n                            }\n                            // fall-through\n                        default:\n                            // not tls, ssl or application data\n                            select(ctx, null);\n                            return;\n                    }\n                }\n            } catch (NotSslRecordException e) {\n                // Just rethrow as in this case we also closed the channel and this is consistent with SslHandler.\n                throw e;\n            } catch (TooLongFrameException e) {\n                // Just rethrow as in this case we also closed the channel\n                throw e;\n            } catch (Exception e) {\n                // unexpected encoding, ignore sni and use default\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"Unexpected client hello packet: \" + ByteBufUtil.hexDump(in), e);\n                }\n                select(ctx, null);\n            }\n        }\n    }\n\n    private void releaseHandshakeBuffer() {\n        releaseIfNotNull(handshakeBuffer);\n        handshakeBuffer = null;\n    }\n\n    private static void releaseIfNotNull(ByteBuf buffer) {\n        if (buffer != null) {\n            buffer.release();\n        }\n    }\n\n    private void select(final ChannelHandlerContext ctx, ByteBuf clientHello) throws Exception {\n        final Future<T> future;\n        try {\n            future = lookup(ctx, clientHello);\n            if (future.isDone()) {\n                onLookupComplete(ctx, future);\n            } else {\n                suppressRead = true;\n                final ByteBuf finalClientHello = clientHello;\n                future.addListener(new FutureListener<T>() {\n                    @Override\n                    public void operationComplete(Future<T> future) {\n                        releaseIfNotNull(finalClientHello);\n                        try {\n                            suppressRead = false;\n                            try {\n                                onLookupComplete(ctx, future);\n                            } catch (DecoderException err) {\n                                ctx.fireExceptionCaught(err);\n                            } catch (Exception cause) {\n                                ctx.fireExceptionCaught(new DecoderException(cause));\n                            } catch (Throwable cause) {\n                                ctx.fireExceptionCaught(cause);\n                            }\n                        } finally {\n                            if (readPending) {\n                                readPending = false;\n                                ctx.read();\n                            }\n                        }\n                    }\n                });\n\n                // Ownership was transferred to the FutureListener.\n                clientHello = null;\n            }\n        } catch (Throwable cause) {\n            PlatformDependent.throwException(cause);\n        } finally {\n            releaseIfNotNull(clientHello);\n        }\n    }\n\n    @Override\n    protected void handlerRemoved0(ChannelHandlerContext ctx) throws Exception {\n        releaseHandshakeBuffer();\n\n        super.handlerRemoved0(ctx);\n    }\n\n    /**\n     * Kicks off a lookup for the given {@code ClientHello} and returns a {@link Future} which in turn will\n     * notify the {@link #onLookupComplete(ChannelHandlerContext, Future)} on completion.\n     *\n     * See https://tools.ietf.org/html/rfc5246#section-7.4.1.2\n     *\n     * <pre>\n     * struct {\n     *    ProtocolVersion client_version;\n     *    Random random;\n     *    SessionID session_id;\n     *    CipherSuite cipher_suites<2..2^16-2>;\n     *    CompressionMethod compression_methods<1..2^8-1>;\n     *    select (extensions_present) {\n     *        case false:\n     *            struct {};\n     *        case true:\n     *            Extension extensions<0..2^16-1>;\n     *    };\n     * } ClientHello;\n     * </pre>\n     *\n     * @see #onLookupComplete(ChannelHandlerContext, Future)\n     */\n    protected abstract Future<T> lookup(ChannelHandlerContext ctx, ByteBuf clientHello) throws Exception;\n\n    /**\n     * Called upon completion of the {@link #lookup(ChannelHandlerContext, ByteBuf)} {@link Future}.\n     *\n     * @see #lookup(ChannelHandlerContext, ByteBuf)\n     */\n    protected abstract void onLookupComplete(ChannelHandlerContext ctx, Future<T> future) throws Exception;\n\n    @Override\n    public void read(ChannelHandlerContext ctx) throws Exception {\n        if (suppressRead) {\n            readPending = true;\n        } else {\n            ctx.read();\n        }\n    }\n\n    @Override\n    public void bind(ChannelHandlerContext ctx, SocketAddress localAddress, ChannelPromise promise) throws Exception {\n        ctx.bind(localAddress, promise);\n    }\n\n    @Override\n    public void connect(ChannelHandlerContext ctx, SocketAddress remoteAddress, SocketAddress localAddress,\n                        ChannelPromise promise) throws Exception {\n        ctx.connect(remoteAddress, localAddress, promise);\n    }\n\n    @Override\n    public void disconnect(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception {\n        ctx.disconnect(promise);\n    }\n\n    @Override\n    public void close(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception {\n        ctx.close(promise);\n    }\n\n    @Override\n    public void deregister(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception {\n        ctx.deregister(promise);\n    }\n\n    @Override\n    public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {\n        ctx.write(msg, promise);\n    }\n\n    @Override\n    public void flush(ChannelHandlerContext ctx) throws Exception {\n        ctx.flush();\n    }\n}\n", "/*\n * Copyright 2014 The Netty Project\n *\n * The Netty Project licenses this file to you under the Apache License,\n * version 2.0 (the \"License\"); you may not use this file except in compliance\n * with the License. You may obtain a copy of the License at:\n *\n *   https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations\n * under the License.\n */\n\npackage io.netty.handler.ssl;\n\nimport java.io.File;\nimport java.net.InetSocketAddress;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport javax.net.ssl.SSLEngine;\nimport javax.net.ssl.SSLException;\n\nimport io.netty.handler.codec.TooLongFrameException;\nimport io.netty.util.concurrent.Future;\n\nimport io.netty.bootstrap.Bootstrap;\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.buffer.ByteBuf;\nimport io.netty.buffer.ByteBufAllocator;\nimport io.netty.buffer.Unpooled;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.ChannelInboundHandlerAdapter;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelPipeline;\nimport io.netty.channel.DefaultEventLoopGroup;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.embedded.EmbeddedChannel;\nimport io.netty.channel.local.LocalAddress;\nimport io.netty.channel.local.LocalChannel;\nimport io.netty.channel.local.LocalServerChannel;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.codec.DecoderException;\nimport io.netty.handler.ssl.util.InsecureTrustManagerFactory;\nimport io.netty.handler.ssl.util.SelfSignedCertificate;\nimport io.netty.util.DomainNameMapping;\nimport io.netty.util.DomainNameMappingBuilder;\nimport io.netty.util.Mapping;\nimport io.netty.util.ReferenceCountUtil;\nimport io.netty.util.ReferenceCounted;\nimport io.netty.util.concurrent.Promise;\nimport io.netty.util.internal.ObjectUtil;\nimport io.netty.util.internal.ResourcesUtil;\nimport io.netty.util.internal.StringUtil;\nimport org.hamcrest.CoreMatchers;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.Timeout;\nimport org.junit.jupiter.api.function.Executable;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.MethodSource;\n\nimport static org.hamcrest.CoreMatchers.is;\nimport static org.hamcrest.CoreMatchers.nullValue;\nimport static org.hamcrest.MatcherAssert.assertThat;\n\nimport static org.junit.jupiter.api.Assumptions.assumeTrue;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.mockito.Mockito.mock;\n\npublic class SniHandlerTest {\n\n    private static ApplicationProtocolConfig newApnConfig() {\n        return new ApplicationProtocolConfig(\n                ApplicationProtocolConfig.Protocol.ALPN,\n                // NO_ADVERTISE is currently the only mode supported by both OpenSsl and JDK providers.\n                ApplicationProtocolConfig.SelectorFailureBehavior.NO_ADVERTISE,\n                // ACCEPT is currently the only mode supported by both OpenSsl and JDK providers.\n                ApplicationProtocolConfig.SelectedListenerFailureBehavior.ACCEPT,\n                \"myprotocol\");\n    }\n\n    private static void assumeApnSupported(SslProvider provider) {\n        switch (provider) {\n            case OPENSSL:\n            case OPENSSL_REFCNT:\n                assumeTrue(OpenSsl.isAlpnSupported());\n                break;\n            case JDK:\n                assumeTrue(JettyAlpnSslEngine.isAvailable());\n                break;\n            default:\n                throw new Error();\n        }\n    }\n\n    private static SslContext makeSslContext(SslProvider provider, boolean apn) throws Exception {\n        if (apn) {\n            assumeApnSupported(provider);\n        }\n\n        File keyFile = ResourcesUtil.getFile(SniHandlerTest.class, \"test_encrypted.pem\");\n        File crtFile = ResourcesUtil.getFile(SniHandlerTest.class, \"test.crt\");\n\n        SslContextBuilder sslCtxBuilder = SslContextBuilder.forServer(crtFile, keyFile, \"12345\")\n                .sslProvider(provider);\n        if (apn) {\n            sslCtxBuilder.applicationProtocolConfig(newApnConfig());\n        }\n        return sslCtxBuilder.build();\n    }\n\n    private static SslContext makeSslClientContext(SslProvider provider, boolean apn) throws Exception {\n        if (apn) {\n            assumeApnSupported(provider);\n        }\n\n        File crtFile = ResourcesUtil.getFile(SniHandlerTest.class, \"test.crt\");\n\n        SslContextBuilder sslCtxBuilder = SslContextBuilder.forClient().trustManager(crtFile).sslProvider(provider);\n        if (apn) {\n            sslCtxBuilder.applicationProtocolConfig(newApnConfig());\n        }\n        return sslCtxBuilder.build();\n    }\n\n    static Iterable<?> data() {\n        List<SslProvider> params = new ArrayList<SslProvider>(3);\n        if (OpenSsl.isAvailable()) {\n            params.add(SslProvider.OPENSSL);\n            params.add(SslProvider.OPENSSL_REFCNT);\n        }\n        params.add(SslProvider.JDK);\n        return params;\n    }\n\n    @ParameterizedTest(name = \"{index}: sslProvider={0}\")\n    @MethodSource(\"data\")\n    public void testNonSslRecord(SslProvider provider) throws Exception {\n        SslContext nettyContext = makeSslContext(provider, false);\n        try {\n            final AtomicReference<SslHandshakeCompletionEvent> evtRef =\n                    new AtomicReference<SslHandshakeCompletionEvent>();\n            SniHandler handler = new SniHandler(new DomainNameMappingBuilder<SslContext>(nettyContext).build());\n            final EmbeddedChannel ch = new EmbeddedChannel(handler, new ChannelInboundHandlerAdapter() {\n                @Override\n                public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {\n                    if (evt instanceof SslHandshakeCompletionEvent) {\n                        assertTrue(evtRef.compareAndSet(null, (SslHandshakeCompletionEvent) evt));\n                    }\n                }\n            });\n\n            try {\n                final byte[] bytes = new byte[1024];\n                bytes[0] = SslUtils.SSL_CONTENT_TYPE_ALERT;\n\n                DecoderException e = assertThrows(DecoderException.class, new Executable() {\n                    @Override\n                    public void execute() throws Throwable {\n                        ch.writeInbound(Unpooled.wrappedBuffer(bytes));\n                    }\n                });\n                assertThat(e.getCause(), CoreMatchers.instanceOf(NotSslRecordException.class));\n                assertFalse(ch.finish());\n            } finally {\n                ch.finishAndReleaseAll();\n            }\n            assertThat(evtRef.get().cause(), CoreMatchers.instanceOf(NotSslRecordException.class));\n        } finally {\n            releaseAll(nettyContext);\n        }\n    }\n\n    @ParameterizedTest(name = \"{index}: sslProvider={0}\")\n    @MethodSource(\"data\")\n    public void testServerNameParsing(SslProvider provider) throws Exception {\n        SslContext nettyContext = makeSslContext(provider, false);\n        SslContext leanContext = makeSslContext(provider, false);\n        SslContext leanContext2 = makeSslContext(provider, false);\n\n        try {\n            DomainNameMapping<SslContext> mapping = new DomainNameMappingBuilder<SslContext>(nettyContext)\n                    .add(\"*.netty.io\", nettyContext)\n                    // input with custom cases\n                    .add(\"*.LEANCLOUD.CN\", leanContext)\n                    // a hostname conflict with previous one, since we are using order-sensitive config,\n                    // the engine won't be used with the handler.\n                    .add(\"chat4.leancloud.cn\", leanContext2)\n                    .build();\n\n            final AtomicReference<SniCompletionEvent> evtRef = new AtomicReference<SniCompletionEvent>();\n            SniHandler handler = new SniHandler(mapping);\n            EmbeddedChannel ch = new EmbeddedChannel(handler, new ChannelInboundHandlerAdapter() {\n                @Override\n                public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {\n                    if (evt instanceof SniCompletionEvent) {\n                        assertTrue(evtRef.compareAndSet(null, (SniCompletionEvent) evt));\n                    } else {\n                        ctx.fireUserEventTriggered(evt);\n                    }\n                }\n            });\n\n            try {\n                // hex dump of a client hello packet, which contains hostname \"CHAT4.LEANCLOUD.CN\"\n                String tlsHandshakeMessageHex1 = \"16030100\";\n                // part 2\n                String tlsHandshakeMessageHex = \"c6010000c20303bb0855d66532c05a0ef784f7c384feeafa68b3\" +\n                        \"b655ac7288650d5eed4aa3fb52000038c02cc030009fcca9cca8ccaac02b\" +\n                        \"c02f009ec024c028006bc023c0270067c00ac0140039c009c0130033009d\" +\n                        \"009c003d003c0035002f00ff010000610000001700150000124348415434\" +\n                        \"2e4c45414e434c4f55442e434e000b000403000102000a000a0008001d00\" +\n                        \"170019001800230000000d0020001e060106020603050105020503040104\" +\n                        \"0204030301030203030201020202030016000000170000\";\n\n                ch.writeInbound(Unpooled.wrappedBuffer(StringUtil.decodeHexDump(tlsHandshakeMessageHex1)));\n                ch.writeInbound(Unpooled.wrappedBuffer(StringUtil.decodeHexDump(tlsHandshakeMessageHex)));\n\n                // This should produce an alert\n                assertTrue(ch.finish());\n\n                assertThat(handler.hostname(), is(\"chat4.leancloud.cn\"));\n                assertThat(handler.sslContext(), is(leanContext));\n\n                SniCompletionEvent evt = evtRef.get();\n                assertNotNull(evt);\n                assertEquals(\"chat4.leancloud.cn\", evt.hostname());\n                assertTrue(evt.isSuccess());\n                assertNull(evt.cause());\n            } finally {\n                ch.finishAndReleaseAll();\n            }\n        } finally {\n            releaseAll(leanContext, leanContext2, nettyContext);\n        }\n    }\n\n    @ParameterizedTest(name = \"{index}: sslProvider={0}\")\n    @MethodSource(\"data\")\n    public void testNonAsciiServerNameParsing(SslProvider provider) throws Exception {\n        SslContext nettyContext = makeSslContext(provider, false);\n        SslContext leanContext = makeSslContext(provider, false);\n        SslContext leanContext2 = makeSslContext(provider, false);\n\n        try {\n            DomainNameMapping<SslContext> mapping = new DomainNameMappingBuilder<SslContext>(nettyContext)\n                    .add(\"*.netty.io\", nettyContext)\n                    // input with custom cases\n                    .add(\"*.LEANCLOUD.CN\", leanContext)\n                    // a hostname conflict with previous one, since we are using order-sensitive config,\n                    // the engine won't be used with the handler.\n                    .add(\"chat4.leancloud.cn\", leanContext2)\n                    .build();\n\n            SniHandler handler = new SniHandler(mapping);\n            final EmbeddedChannel ch = new EmbeddedChannel(handler);\n\n            try {\n                // hex dump of a client hello packet, which contains an invalid hostname \"CHAT4\u3002LEANCLOUD\u3002CN\"\n                String tlsHandshakeMessageHex1 = \"16030100\";\n                // part 2\n                final String tlsHandshakeMessageHex = \"bd010000b90303a74225676d1814ba57faff3b366\" +\n                        \"3656ed05ee9dbb2a4dbb1bb1c32d2ea5fc39e0000000100008c0000001700150000164348\" +\n                        \"415434E380824C45414E434C4F5544E38082434E000b000403000102000a00340032000e0\" +\n                        \"00d0019000b000c00180009000a0016001700080006000700140015000400050012001300\" +\n                        \"0100020003000f0010001100230000000d0020001e0601060206030501050205030401040\" +\n                        \"20403030103020303020102020203000f00010133740000\";\n\n                // Push the handshake message.\n                // Decode should fail because of the badly encoded \"HostName\" string in the SNI extension\n                // that isn't ASCII as per RFC 6066 - https://tools.ietf.org/html/rfc6066#page-6\n                ch.writeInbound(Unpooled.wrappedBuffer(StringUtil.decodeHexDump(tlsHandshakeMessageHex1)));\n\n                assertThrows(DecoderException.class, new Executable() {\n                    @Override\n                    public void execute() throws Throwable {\n                        ch.writeInbound(Unpooled.wrappedBuffer(StringUtil.decodeHexDump(tlsHandshakeMessageHex)));\n                    }\n                });\n            } finally {\n                ch.finishAndReleaseAll();\n            }\n        } finally {\n            releaseAll(leanContext, leanContext2, nettyContext);\n        }\n    }\n\n    @ParameterizedTest(name = \"{index}: sslProvider={0}\")\n    @MethodSource(\"data\")\n    public void testFallbackToDefaultContext(SslProvider provider) throws Exception {\n        SslContext nettyContext = makeSslContext(provider, false);\n        SslContext leanContext = makeSslContext(provider, false);\n        SslContext leanContext2 = makeSslContext(provider, false);\n\n        try {\n            DomainNameMapping<SslContext> mapping = new DomainNameMappingBuilder<SslContext>(nettyContext)\n                    .add(\"*.netty.io\", nettyContext)\n                    // input with custom cases\n                    .add(\"*.LEANCLOUD.CN\", leanContext)\n                    // a hostname conflict with previous one, since we are using order-sensitive config,\n                    // the engine won't be used with the handler.\n                    .add(\"chat4.leancloud.cn\", leanContext2)\n                    .build();\n\n            SniHandler handler = new SniHandler(mapping);\n            EmbeddedChannel ch = new EmbeddedChannel(handler);\n\n            // invalid\n            byte[] message = {22, 3, 1, 0, 0};\n            try {\n                // Push the handshake message.\n                ch.writeInbound(Unpooled.wrappedBuffer(message));\n                // TODO(scott): This should fail because the engine should reject zero length records during handshake.\n                // See https://github.com/netty/netty/issues/6348.\n                // fail();\n            } catch (Exception e) {\n                // expected\n            }\n\n            ch.close();\n\n            // When the channel is closed the SslHandler will write an empty buffer to the channel.\n            ByteBuf buf = ch.readOutbound();\n            // TODO(scott): if the engine is shutdown correctly then this buffer shouldn't be null!\n            // See https://github.com/netty/netty/issues/6348.\n            if (buf != null) {\n                assertFalse(buf.isReadable());\n                buf.release();\n            }\n\n            assertThat(ch.finish(), is(false));\n            assertThat(handler.hostname(), nullValue());\n            assertThat(handler.sslContext(), is(nettyContext));\n        } finally {\n            releaseAll(leanContext, leanContext2, nettyContext);\n        }\n    }\n\n    @ParameterizedTest(name = \"{index}: sslProvider={0}\")\n    @MethodSource(\"data\")\n    @Timeout(value = 10000, unit = TimeUnit.MILLISECONDS)\n    public void testMajorVersionNot3(SslProvider provider) throws Exception {\n        SslContext nettyContext = makeSslContext(provider, false);\n\n        try {\n            DomainNameMapping<SslContext> mapping = new DomainNameMappingBuilder<SslContext>(nettyContext).build();\n\n            SniHandler handler = new SniHandler(mapping);\n            EmbeddedChannel ch = new EmbeddedChannel(handler);\n\n            // invalid\n            byte[] message = {22, 2, 0, 0, 0};\n            try {\n                // Push the handshake message.\n                ch.writeInbound(Unpooled.wrappedBuffer(message));\n                // TODO(scott): This should fail because the engine should reject zero length records during handshake.\n                // See https://github.com/netty/netty/issues/6348.\n                // fail();\n            } catch (Exception e) {\n                // expected\n            }\n\n            ch.close();\n\n            // Consume all the outbound data that may be produced by the SSLEngine.\n            for (;;) {\n                ByteBuf buf = ch.readOutbound();\n                if (buf == null) {\n                    break;\n                }\n                buf.release();\n            }\n\n            assertThat(ch.finish(), is(false));\n            assertThat(handler.hostname(), nullValue());\n            assertThat(handler.sslContext(), is(nettyContext));\n        } finally {\n            releaseAll(nettyContext);\n        }\n    }\n\n    @ParameterizedTest(name = \"{index}: sslProvider={0}\")\n    @MethodSource(\"data\")\n    public void testSniWithApnHandler(SslProvider provider) throws Exception {\n        SslContext nettyContext = makeSslContext(provider, true);\n        SslContext sniContext = makeSslContext(provider, true);\n        final SslContext clientContext = makeSslClientContext(provider, true);\n        try {\n            final AtomicBoolean serverApnCtx = new AtomicBoolean(false);\n            final AtomicBoolean clientApnCtx = new AtomicBoolean(false);\n            final CountDownLatch serverApnDoneLatch = new CountDownLatch(1);\n            final CountDownLatch clientApnDoneLatch = new CountDownLatch(1);\n\n            final DomainNameMapping<SslContext> mapping = new DomainNameMappingBuilder<SslContext>(nettyContext)\n                    .add(\"*.netty.io\", nettyContext)\n                    .add(\"sni.fake.site\", sniContext).build();\n            final SniHandler handler = new SniHandler(mapping);\n            EventLoopGroup group = new NioEventLoopGroup(2);\n            Channel serverChannel = null;\n            Channel clientChannel = null;\n            try {\n                ServerBootstrap sb = new ServerBootstrap();\n                sb.group(group);\n                sb.channel(NioServerSocketChannel.class);\n                sb.childHandler(new ChannelInitializer<Channel>() {\n                    @Override\n                    protected void initChannel(Channel ch) throws Exception {\n                        ChannelPipeline p = ch.pipeline();\n                        // Server side SNI.\n                        p.addLast(handler);\n                        // Catch the notification event that APN has completed successfully.\n                        p.addLast(new ApplicationProtocolNegotiationHandler(\"foo\") {\n                            @Override\n                            protected void configurePipeline(ChannelHandlerContext ctx, String protocol) {\n                                // addresses issue #9131\n                                serverApnCtx.set(ctx.pipeline().context(this) != null);\n                                serverApnDoneLatch.countDown();\n                            }\n                        });\n                    }\n                });\n\n                Bootstrap cb = new Bootstrap();\n                cb.group(group);\n                cb.channel(NioSocketChannel.class);\n                cb.handler(new ChannelInitializer<Channel>() {\n                    @Override\n                    protected void initChannel(Channel ch) throws Exception {\n                        ch.pipeline().addLast(new SslHandler(clientContext.newEngine(\n                                ch.alloc(), \"sni.fake.site\", -1)));\n                        // Catch the notification event that APN has completed successfully.\n                        ch.pipeline().addLast(new ApplicationProtocolNegotiationHandler(\"foo\") {\n                            @Override\n                            protected void configurePipeline(ChannelHandlerContext ctx, String protocol) {\n                                // addresses issue #9131\n                                clientApnCtx.set(ctx.pipeline().context(this) != null);\n                                clientApnDoneLatch.countDown();\n                            }\n                        });\n                    }\n                });\n\n                serverChannel = sb.bind(new InetSocketAddress(0)).sync().channel();\n\n                ChannelFuture ccf = cb.connect(serverChannel.localAddress());\n                assertTrue(ccf.awaitUninterruptibly().isSuccess());\n                clientChannel = ccf.channel();\n\n                assertTrue(serverApnDoneLatch.await(5, TimeUnit.SECONDS));\n                assertTrue(clientApnDoneLatch.await(5, TimeUnit.SECONDS));\n                assertTrue(serverApnCtx.get());\n                assertTrue(clientApnCtx.get());\n                assertThat(handler.hostname(), is(\"sni.fake.site\"));\n                assertThat(handler.sslContext(), is(sniContext));\n            } finally {\n                if (serverChannel != null) {\n                    serverChannel.close().sync();\n                }\n                if (clientChannel != null) {\n                    clientChannel.close().sync();\n                }\n                group.shutdownGracefully(0, 0, TimeUnit.MICROSECONDS);\n            }\n        } finally {\n            releaseAll(clientContext, nettyContext, sniContext);\n        }\n    }\n\n    @ParameterizedTest(name = \"{index}: sslProvider={0}\")\n    @MethodSource(\"data\")\n    @Timeout(value = 30000, unit = TimeUnit.MILLISECONDS)\n    public void testReplaceHandler(SslProvider provider) throws Exception {\n        switch (provider) {\n            case OPENSSL:\n            case OPENSSL_REFCNT:\n                final String sniHost = \"sni.netty.io\";\n                LocalAddress address = new LocalAddress(\"testReplaceHandler-\" + Math.random());\n                EventLoopGroup group = new DefaultEventLoopGroup(1);\n                Channel sc = null;\n                Channel cc = null;\n                SslContext sslContext = null;\n\n                SelfSignedCertificate cert = new SelfSignedCertificate();\n\n                try {\n                    final SslContext sslServerContext = SslContextBuilder\n                            .forServer(cert.key(), cert.cert())\n                            .sslProvider(provider)\n                            .build();\n\n                    final Mapping<String, SslContext> mapping = new Mapping<String, SslContext>() {\n                        @Override\n                        public SslContext map(String input) {\n                            return sslServerContext;\n                        }\n                    };\n\n                    final Promise<Void> releasePromise = group.next().newPromise();\n\n                    final SniHandler handler = new SniHandler(mapping) {\n                        @Override\n                        protected void replaceHandler(ChannelHandlerContext ctx,\n                                                      String hostname, final SslContext sslContext)\n                                throws Exception {\n\n                            boolean success = false;\n                            try {\n                                assertEquals(1, ((ReferenceCountedOpenSslContext) sslContext).refCnt());\n                                // The SniHandler's replaceHandler() method allows us to implement custom behavior.\n                                // As an example, we want to release() the SslContext upon channelInactive() or rather\n                                // when the SslHandler closes it's SslEngine. If you take a close look at SslHandler\n                                // you'll see that it's doing it in the #handlerRemoved0() method.\n\n                                SSLEngine sslEngine = sslContext.newEngine(ctx.alloc());\n                                try {\n                                    assertEquals(2, ((ReferenceCountedOpenSslContext) sslContext).refCnt());\n                                    SslHandler customSslHandler = new CustomSslHandler(sslContext, sslEngine) {\n                                        @Override\n                                        public void handlerRemoved0(ChannelHandlerContext ctx) throws Exception {\n                                            try {\n                                                super.handlerRemoved0(ctx);\n                                            } finally {\n                                                releasePromise.trySuccess(null);\n                                            }\n                                        }\n                                    };\n                                    ctx.pipeline().replace(this, CustomSslHandler.class.getName(), customSslHandler);\n                                    success = true;\n                                } finally {\n                                    if (!success) {\n                                        ReferenceCountUtil.safeRelease(sslEngine);\n                                    }\n                                }\n                            } finally {\n                                if (!success) {\n                                    ReferenceCountUtil.safeRelease(sslContext);\n                                    releasePromise.cancel(true);\n                                }\n                            }\n                        }\n                    };\n\n                    ServerBootstrap sb = new ServerBootstrap();\n                    sc = sb.group(group).channel(LocalServerChannel.class)\n                            .childHandler(new ChannelInitializer<Channel>() {\n                        @Override\n                        protected void initChannel(Channel ch) throws Exception {\n                            ch.pipeline().addFirst(handler);\n                        }\n                    }).bind(address).syncUninterruptibly().channel();\n\n                    sslContext = SslContextBuilder.forClient().sslProvider(provider)\n                            .trustManager(InsecureTrustManagerFactory.INSTANCE).build();\n\n                    Bootstrap cb = new Bootstrap();\n                    cc = cb.group(group).channel(LocalChannel.class).handler(new SslHandler(\n                            sslContext.newEngine(ByteBufAllocator.DEFAULT, sniHost, -1)))\n                            .connect(address).syncUninterruptibly().channel();\n\n                    cc.writeAndFlush(Unpooled.wrappedBuffer(\"Hello, World!\".getBytes()))\n                            .syncUninterruptibly();\n\n                    // Notice how the server's SslContext refCnt is 2 as it is incremented when the SSLEngine is created\n                    // and only decremented once it is destroyed.\n                    assertEquals(2, ((ReferenceCounted) sslServerContext).refCnt());\n\n                    // The client disconnects\n                    cc.close().syncUninterruptibly();\n                    if (!releasePromise.awaitUninterruptibly(10L, TimeUnit.SECONDS)) {\n                        throw new IllegalStateException(\"It doesn't seem #replaceHandler() got called.\");\n                    }\n\n                    // We should have successfully release() the SslContext\n                    assertEquals(0, ((ReferenceCounted) sslServerContext).refCnt());\n                } finally {\n                    if (cc != null) {\n                        cc.close().syncUninterruptibly();\n                    }\n                    if (sc != null) {\n                        sc.close().syncUninterruptibly();\n                    }\n                    if (sslContext != null) {\n                        ReferenceCountUtil.release(sslContext);\n                    }\n                    group.shutdownGracefully();\n\n                    cert.delete();\n                }\n            case JDK:\n                return;\n            default:\n                throw new Error();\n        }\n    }\n\n    /**\n     * This is a {@link SslHandler} that will call {@code release()} on the {@link SslContext} when\n     * the client disconnects.\n     *\n     * @see SniHandlerTest#testReplaceHandler(SslProvider)\n     */\n    private static class CustomSslHandler extends SslHandler {\n        private final SslContext sslContext;\n\n        CustomSslHandler(SslContext sslContext, SSLEngine sslEngine) {\n            super(sslEngine);\n            this.sslContext = ObjectUtil.checkNotNull(sslContext, \"sslContext\");\n        }\n\n        @Override\n        public void handlerRemoved0(ChannelHandlerContext ctx) throws Exception {\n            super.handlerRemoved0(ctx);\n            ReferenceCountUtil.release(sslContext);\n        }\n    }\n\n    private static void releaseAll(SslContext... contexts) {\n        for (SslContext ctx: contexts) {\n            ReferenceCountUtil.release(ctx);\n        }\n    }\n\n    @ParameterizedTest(name = \"{index}: sslProvider={0}\")\n    @MethodSource(\"data\")\n    public void testNonFragmented(SslProvider provider) throws Exception {\n        testWithFragmentSize(provider, Integer.MAX_VALUE);\n    }\n\n    @ParameterizedTest(name = \"{index}: sslProvider={0}\")\n    @MethodSource(\"data\")\n    public void testFragmented(SslProvider provider) throws Exception {\n        testWithFragmentSize(provider, 50);\n    }\n\n    private void testWithFragmentSize(SslProvider provider, final int maxFragmentSize) throws Exception {\n        final String sni = \"netty.io\";\n        SelfSignedCertificate cert = new SelfSignedCertificate();\n        final SslContext context = SslContextBuilder.forServer(cert.key(), cert.cert())\n                .sslProvider(provider)\n                .build();\n        try {\n            @SuppressWarnings(\"unchecked\") final EmbeddedChannel server = new EmbeddedChannel(\n                    new SniHandler(mock(DomainNameMapping.class)) {\n                @Override\n                protected Future<SslContext> lookup(final ChannelHandlerContext ctx, final String hostname) {\n                    assertEquals(sni, hostname);\n                    return ctx.executor().newSucceededFuture(context);\n                }\n            });\n\n            final List<ByteBuf> buffers = clientHelloInMultipleFragments(provider, sni, maxFragmentSize);\n            for (ByteBuf buffer : buffers) {\n                server.writeInbound(buffer);\n            }\n            assertTrue(server.finishAndReleaseAll());\n        } finally {\n            releaseAll(context);\n            cert.delete();\n        }\n    }\n\n    private static List<ByteBuf> clientHelloInMultipleFragments(\n            SslProvider provider, String hostname, int maxTlsPlaintextSize) throws SSLException {\n        final EmbeddedChannel client = new EmbeddedChannel();\n        final SslContext ctx = SslContextBuilder.forClient()\n                .sslProvider(provider)\n                .trustManager(InsecureTrustManagerFactory.INSTANCE)\n                .build();\n        try {\n            final SslHandler sslHandler = ctx.newHandler(client.alloc(), hostname, -1);\n            client.pipeline().addLast(sslHandler);\n            final ByteBuf clientHello = client.readOutbound();\n            List<ByteBuf> buffers = split(clientHello, maxTlsPlaintextSize);\n            assertTrue(client.finishAndReleaseAll());\n            return buffers;\n        } finally {\n            releaseAll(ctx);\n        }\n    }\n\n    private static List<ByteBuf> split(ByteBuf clientHello, int maxSize) {\n        final int type = clientHello.readUnsignedByte();\n        final int version = clientHello.readUnsignedShort();\n        final int length = clientHello.readUnsignedShort();\n        assertEquals(length, clientHello.readableBytes());\n\n        final List<ByteBuf> result = new ArrayList<ByteBuf>();\n        while (clientHello.readableBytes() > 0) {\n            final int toRead = Math.min(maxSize, clientHello.readableBytes());\n            final ByteBuf bb = clientHello.alloc().buffer(SslUtils.SSL_RECORD_HEADER_LENGTH + toRead);\n            bb.writeByte(type);\n            bb.writeShort(version);\n            bb.writeShort(toRead);\n            bb.writeBytes(clientHello, toRead);\n            result.add(bb);\n        }\n        clientHello.release();\n        return result;\n    }\n\n    @Test\n    public void testSniHandlerFailsOnTooBigClientHello() throws Exception {\n        SniHandler handler = new SniHandler(new Mapping<String, SslContext>() {\n            @Override\n            public SslContext map(String input) {\n                throw new UnsupportedOperationException(\"Should not be called\");\n            }\n        }, 10, 0);\n\n        final AtomicReference<SniCompletionEvent> completionEventRef =\n                new AtomicReference<SniCompletionEvent>();\n        final EmbeddedChannel ch = new EmbeddedChannel(handler, new ChannelInboundHandlerAdapter() {\n            @Override\n            public void userEventTriggered(ChannelHandlerContext ctx, Object evt) {\n                if (evt instanceof SniCompletionEvent) {\n                    completionEventRef.set((SniCompletionEvent) evt);\n                }\n            }\n        });\n        final ByteBuf buffer = ch.alloc().buffer();\n        buffer.writeByte(0x16);      // Content Type: Handshake\n        buffer.writeShort((short) 0x0303); // TLS 1.2\n        buffer.writeShort((short) 0x0006); // Packet length\n\n        // 16_777_215\n        buffer.writeByte((byte) 0x01); // Client Hello\n        buffer.writeMedium(0xFFFFFF); // Length\n        buffer.writeShort((short) 0x0303); // TLS 1.2\n\n        assertThrows(TooLongFrameException.class, new Executable() {\n            @Override\n            public void execute() throws Throwable {\n                ch.writeInbound(buffer);\n            }\n        });\n        try {\n            while (completionEventRef.get() == null) {\n                Thread.sleep(100);\n                // We need to run all pending tasks as the handshake timeout is scheduled on the EventLoop.\n                ch.runPendingTasks();\n            }\n            SniCompletionEvent completionEvent = completionEventRef.get();\n            assertNotNull(completionEvent);\n            assertNotNull(completionEvent.cause());\n            assertEquals(TooLongFrameException.class, completionEvent.cause().getClass());\n        } finally {\n            ch.finishAndReleaseAll();\n        }\n    }\n\n    @Test\n    public void testSniHandlerFiresHandshakeTimeout() throws Exception {\n        SniHandler handler = new SniHandler(new Mapping<String, SslContext>() {\n            @Override\n            public SslContext map(String input) {\n                throw new UnsupportedOperationException(\"Should not be called\");\n            }\n        }, 0, 10);\n\n        final AtomicReference<SniCompletionEvent> completionEventRef =\n            new AtomicReference<SniCompletionEvent>();\n        EmbeddedChannel ch = new EmbeddedChannel(handler, new ChannelInboundHandlerAdapter() {\n            @Override\n            public void userEventTriggered(ChannelHandlerContext ctx, Object evt) {\n                if (evt instanceof SniCompletionEvent) {\n                    completionEventRef.set((SniCompletionEvent) evt);\n                }\n            }\n        });\n        try {\n            while (completionEventRef.get() == null) {\n                Thread.sleep(100);\n                // We need to run all pending tasks as the handshake timeout is scheduled on the EventLoop.\n                ch.runPendingTasks();\n            }\n            SniCompletionEvent completionEvent = completionEventRef.get();\n            assertNotNull(completionEvent);\n            assertNotNull(completionEvent.cause());\n            assertEquals(SslHandshakeTimeoutException.class, completionEvent.cause().getClass());\n        } finally {\n            ch.finishAndReleaseAll();\n        }\n    }\n\n    @ParameterizedTest(name = \"{index}: sslProvider={0}\")\n    @MethodSource(\"data\")\n    public void testSslHandlerFiresHandshakeTimeout(SslProvider provider) throws Exception {\n        final SslContext context = makeSslContext(provider, false);\n        SniHandler handler = new SniHandler(new Mapping<String, SslContext>() {\n            @Override\n            public SslContext map(String input) {\n                return context;\n            }\n        }, 0, 100);\n\n        final AtomicReference<SniCompletionEvent> sniCompletionEventRef =\n            new AtomicReference<SniCompletionEvent>();\n        final AtomicReference<SslHandshakeCompletionEvent> handshakeCompletionEventRef =\n            new AtomicReference<SslHandshakeCompletionEvent>();\n        EmbeddedChannel ch = new EmbeddedChannel(handler, new ChannelInboundHandlerAdapter() {\n            @Override\n            public void userEventTriggered(ChannelHandlerContext ctx, Object evt) {\n                if (evt instanceof SniCompletionEvent) {\n                    sniCompletionEventRef.set((SniCompletionEvent) evt);\n                } else if (evt instanceof SslHandshakeCompletionEvent) {\n                    handshakeCompletionEventRef.set((SslHandshakeCompletionEvent) evt);\n                }\n            }\n        });\n        try {\n            // Send enough data to add the SslHandler and let the handshake incomplete\n            // Client Hello with \"host1\" server name\n            ch.writeInbound(Unpooled.wrappedBuffer(StringUtil.decodeHexDump(\n                \"16030301800100017c0303478ae7e536aa7a9debad1f873121862d2d3d3173e0ef42975c31007faeb2\" +\n                \"52522047f55f81fc84fe58951e2af14026147d6178498fde551fcbafc636462c016ec9005a13011302\" +\n                \"c02cc02bc030009dc02ec032009f00a3c02f009cc02dc031009e00a2c024c028003dc026c02a006b00\" +\n                \"6ac00ac0140035c005c00f00390038c023c027003cc025c02900670040c009c013002fc004c00e0033\" +\n                \"003200ff010000d90000000a0008000005686f737431000500050100000000000a00160014001d0017\" +\n                \"00180019001e01000101010201030104000b00020100000d0028002604030503060308040805080608\" +\n                \"09080a080b040105010601040203030301030202030201020200320028002604030503060308040805\" +\n                \"08060809080a080b040105010601040203030301030202030201020200110009000702000400000000\" +\n                \"00170000002b00050403040303002d00020101003300260024001d00200bbc37375e214c1e4e7cb90f\" +\n                \"869e131dc983a21f8205ba24456177f340904935\")));\n\n            while (handshakeCompletionEventRef.get() == null) {\n                Thread.sleep(10);\n                // We need to run all pending tasks as the handshake timeout is scheduled on the EventLoop.\n                ch.runPendingTasks();\n            }\n            SniCompletionEvent sniCompletionEvent = sniCompletionEventRef.get();\n            assertNotNull(sniCompletionEvent);\n            assertEquals(\"host1\", sniCompletionEvent.hostname());\n            SslCompletionEvent handshakeCompletionEvent = handshakeCompletionEventRef.get();\n            assertNotNull(handshakeCompletionEvent);\n            assertNotNull(handshakeCompletionEvent.cause());\n            assertEquals(SslHandshakeTimeoutException.class, handshakeCompletionEvent.cause().getClass());\n        } finally {\n            ch.finishAndReleaseAll();\n            releaseAll(context);\n        }\n    }\n}\n"], "filenames": ["handler/src/main/java/io/netty/handler/ssl/AbstractSniHandler.java", "handler/src/main/java/io/netty/handler/ssl/SniHandler.java", "handler/src/main/java/io/netty/handler/ssl/SslClientHelloHandler.java", "handler/src/test/java/io/netty/handler/ssl/SniHandlerTest.java"], "buggy_code_start_loc": [129, 58, 24, 28], "buggy_code_end_loc": [137, 97, 162, 762], "fixing_code_start_loc": [129, 59, 25, 27], "fixing_code_end_loc": [146, 123, 195, 811], "type": "CWE-400", "message": "Netty is an asynchronous event-driven network application framework for rapid development of maintainable high performance protocol servers & clients. The `SniHandler` can allocate up to 16MB of heap for each channel during the TLS handshake. When the handler or the channel does not have an idle timeout, it can be used to make a TCP server using the `SniHandler` to allocate 16MB of heap. The `SniHandler` class is a handler that waits for the TLS handshake to configure a `SslHandler` according to the indicated server name by the `ClientHello` record. For this matter it allocates a `ByteBuf` using the value defined in the `ClientHello` record. Normally the value of the packet should be smaller than the handshake packet but there are not checks done here and the way the code is written, it is possible to craft a packet that makes the `SslClientHelloHandler`. This vulnerability has been fixed in version 4.1.94.Final.", "other": {"cve": {"id": "CVE-2023-34462", "sourceIdentifier": "security-advisories@github.com", "published": "2023-06-22T23:15:09.573", "lastModified": "2023-11-18T21:15:07.830", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Netty is an asynchronous event-driven network application framework for rapid development of maintainable high performance protocol servers & clients. The `SniHandler` can allocate up to 16MB of heap for each channel during the TLS handshake. When the handler or the channel does not have an idle timeout, it can be used to make a TCP server using the `SniHandler` to allocate 16MB of heap. The `SniHandler` class is a handler that waits for the TLS handshake to configure a `SslHandler` according to the indicated server name by the `ClientHello` record. For this matter it allocates a `ByteBuf` using the value defined in the `ClientHello` record. Normally the value of the packet should be smaller than the handshake packet but there are not checks done here and the way the code is written, it is possible to craft a packet that makes the `SslClientHelloHandler`. This vulnerability has been fixed in version 4.1.94.Final."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-400"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-770"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:netty:netty:*:*:*:*:*:*:*:*", "versionEndExcluding": "4.1.94", "matchCriteriaId": "81839C38-65FD-4F9E-A654-29E4FB5D047C"}]}]}], "references": [{"url": "https://github.com/netty/netty/commit/535da17e45201ae4278c0479e6162bb4127d4c32", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/netty/netty/security/advisories/GHSA-6mjq-h674-j845", "source": "security-advisories@github.com", "tags": ["Exploit", "Vendor Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20230803-0001/", "source": "security-advisories@github.com"}, {"url": "https://www.debian.org/security/2023/dsa-5558", "source": "security-advisories@github.com"}]}, "github_commit_url": "https://github.com/netty/netty/commit/535da17e45201ae4278c0479e6162bb4127d4c32"}}