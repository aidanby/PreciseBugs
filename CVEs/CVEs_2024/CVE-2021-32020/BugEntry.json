{"buggy_code": ["/*\r\n * FreeRTOS Kernel V10.4.2\r\n * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy of\r\n * this software and associated documentation files (the \"Software\"), to deal in\r\n * the Software without restriction, including without limitation the rights to\r\n * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\r\n * the Software, and to permit persons to whom the Software is furnished to do so,\r\n * subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in all\r\n * copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\r\n * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\r\n * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\r\n * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\r\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n * https://www.FreeRTOS.org\r\n * https://github.com/FreeRTOS\r\n *\r\n * 1 tab == 4 spaces!\r\n */\r\n\r\n\r\n/*\r\n * The simplest possible implementation of pvPortMalloc().  Note that this\r\n * implementation does NOT allow allocated memory to be freed again.\r\n *\r\n * See heap_2.c, heap_3.c and heap_4.c for alternative implementations, and the\r\n * memory management pages of https://www.FreeRTOS.org for more information.\r\n */\r\n#include <stdlib.h>\r\n\r\n/* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining\r\n * all the API functions to use the MPU wrappers.  That should only be done when\r\n * task.h is included from an application file. */\r\n#define MPU_WRAPPERS_INCLUDED_FROM_API_FILE\r\n\r\n#include \"FreeRTOS.h\"\r\n#include \"task.h\"\r\n\r\n#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE\r\n\r\n#if ( configSUPPORT_DYNAMIC_ALLOCATION == 0 )\r\n    #error This file must not be used if configSUPPORT_DYNAMIC_ALLOCATION is 0\r\n#endif\r\n\r\n/* A few bytes might be lost to byte aligning the heap start address. */\r\n#define configADJUSTED_HEAP_SIZE    ( configTOTAL_HEAP_SIZE - portBYTE_ALIGNMENT )\r\n\r\n/* Allocate the memory for the heap. */\r\n#if ( configAPPLICATION_ALLOCATED_HEAP == 1 )\r\n\r\n/* The application writer has already defined the array used for the RTOS\r\n* heap - probably so it can be placed in a special segment or address. */\r\n    extern uint8_t ucHeap[ configTOTAL_HEAP_SIZE ];\r\n#else\r\n    static uint8_t ucHeap[ configTOTAL_HEAP_SIZE ];\r\n#endif /* configAPPLICATION_ALLOCATED_HEAP */\r\n\r\n/* Index into the ucHeap array. */\r\nstatic size_t xNextFreeByte = ( size_t ) 0;\r\n\r\n/*-----------------------------------------------------------*/\r\n\r\nvoid * pvPortMalloc( size_t xWantedSize )\r\n{\r\n    void * pvReturn = NULL;\r\n    static uint8_t * pucAlignedHeap = NULL;\r\n\r\n    /* Ensure that blocks are always aligned to the required number of bytes. */\r\n    #if ( portBYTE_ALIGNMENT != 1 )\r\n        {\r\n            if( xWantedSize & portBYTE_ALIGNMENT_MASK )\r\n            {\r\n                /* Byte alignment required. */\r\n                xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );\r\n            }\r\n        }\r\n    #endif\r\n\r\n    vTaskSuspendAll();\r\n    {\r\n        if( pucAlignedHeap == NULL )\r\n        {\r\n            /* Ensure the heap starts on a correctly aligned boundary. */\r\n            pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) & ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );\r\n        }\r\n\r\n        /* Check there is enough room left for the allocation. */\r\n        if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&\r\n            ( ( xNextFreeByte + xWantedSize ) > xNextFreeByte ) ) /* Check for overflow. */\r\n        {\r\n            /* Return the next free byte then increment the index past this\r\n             * block. */\r\n            pvReturn = pucAlignedHeap + xNextFreeByte;\r\n            xNextFreeByte += xWantedSize;\r\n        }\r\n\r\n        traceMALLOC( pvReturn, xWantedSize );\r\n    }\r\n    ( void ) xTaskResumeAll();\r\n\r\n    #if ( configUSE_MALLOC_FAILED_HOOK == 1 )\r\n        {\r\n            if( pvReturn == NULL )\r\n            {\r\n                extern void vApplicationMallocFailedHook( void );\r\n                vApplicationMallocFailedHook();\r\n            }\r\n        }\r\n    #endif\r\n\r\n    return pvReturn;\r\n}\r\n/*-----------------------------------------------------------*/\r\n\r\nvoid vPortFree( void * pv )\r\n{\r\n    /* Memory cannot be freed using this scheme.  See heap_2.c, heap_3.c and\r\n     * heap_4.c for alternative implementations, and the memory management pages of\r\n     * https://www.FreeRTOS.org for more information. */\r\n    ( void ) pv;\r\n\r\n    /* Force an assert as it is invalid to call this function. */\r\n    configASSERT( pv == NULL );\r\n}\r\n/*-----------------------------------------------------------*/\r\n\r\nvoid vPortInitialiseBlocks( void )\r\n{\r\n    /* Only required when static memory is not cleared. */\r\n    xNextFreeByte = ( size_t ) 0;\r\n}\r\n/*-----------------------------------------------------------*/\r\n\r\nsize_t xPortGetFreeHeapSize( void )\r\n{\r\n    return( configADJUSTED_HEAP_SIZE - xNextFreeByte );\r\n}\r\n", "/*\r\n * FreeRTOS Kernel V10.4.2\r\n * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy of\r\n * this software and associated documentation files (the \"Software\"), to deal in\r\n * the Software without restriction, including without limitation the rights to\r\n * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\r\n * the Software, and to permit persons to whom the Software is furnished to do so,\r\n * subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in all\r\n * copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\r\n * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\r\n * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\r\n * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\r\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n * https://www.FreeRTOS.org\r\n * https://github.com/FreeRTOS\r\n *\r\n * 1 tab == 4 spaces!\r\n */\r\n\r\n/*\r\n * A sample implementation of pvPortMalloc() and vPortFree() that permits\r\n * allocated blocks to be freed, but does not combine adjacent free blocks\r\n * into a single larger block (and so will fragment memory).  See heap_4.c for\r\n * an equivalent that does combine adjacent blocks into single larger blocks.\r\n *\r\n * See heap_1.c, heap_3.c and heap_4.c for alternative implementations, and the\r\n * memory management pages of https://www.FreeRTOS.org for more information.\r\n */\r\n#include <stdlib.h>\r\n\r\n/* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining\r\n * all the API functions to use the MPU wrappers.  That should only be done when\r\n * task.h is included from an application file. */\r\n#define MPU_WRAPPERS_INCLUDED_FROM_API_FILE\r\n\r\n#include \"FreeRTOS.h\"\r\n#include \"task.h\"\r\n\r\n#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE\r\n\r\n#if ( configSUPPORT_DYNAMIC_ALLOCATION == 0 )\r\n    #error This file must not be used if configSUPPORT_DYNAMIC_ALLOCATION is 0\r\n#endif\r\n\r\n/* A few bytes might be lost to byte aligning the heap start address. */\r\n#define configADJUSTED_HEAP_SIZE    ( configTOTAL_HEAP_SIZE - portBYTE_ALIGNMENT )\r\n\r\n/*\r\n * Initialises the heap structures before their first use.\r\n */\r\nstatic void prvHeapInit( void );\r\n\r\n/* Allocate the memory for the heap. */\r\n#if ( configAPPLICATION_ALLOCATED_HEAP == 1 )\r\n\r\n/* The application writer has already defined the array used for the RTOS\r\n* heap - probably so it can be placed in a special segment or address. */\r\n    extern uint8_t ucHeap[ configTOTAL_HEAP_SIZE ];\r\n#else\r\n    static uint8_t ucHeap[ configTOTAL_HEAP_SIZE ];\r\n#endif /* configAPPLICATION_ALLOCATED_HEAP */\r\n\r\n\r\n/* Define the linked list structure.  This is used to link free blocks in order\r\n * of their size. */\r\ntypedef struct A_BLOCK_LINK\r\n{\r\n    struct A_BLOCK_LINK * pxNextFreeBlock; /*<< The next free block in the list. */\r\n    size_t xBlockSize;                     /*<< The size of the free block. */\r\n} BlockLink_t;\r\n\r\n\r\nstatic const uint16_t heapSTRUCT_SIZE = ( ( sizeof( BlockLink_t ) + ( portBYTE_ALIGNMENT - 1 ) ) & ~portBYTE_ALIGNMENT_MASK );\r\n#define heapMINIMUM_BLOCK_SIZE    ( ( size_t ) ( heapSTRUCT_SIZE * 2 ) )\r\n\r\n/* Create a couple of list links to mark the start and end of the list. */\r\nstatic BlockLink_t xStart, xEnd;\r\n\r\n/* Keeps track of the number of free bytes remaining, but says nothing about\r\n * fragmentation. */\r\nstatic size_t xFreeBytesRemaining = configADJUSTED_HEAP_SIZE;\r\n\r\n/* STATIC FUNCTIONS ARE DEFINED AS MACROS TO MINIMIZE THE FUNCTION CALL DEPTH. */\r\n\r\n/*\r\n * Insert a block into the list of free blocks - which is ordered by size of\r\n * the block.  Small blocks at the start of the list and large blocks at the end\r\n * of the list.\r\n */\r\n#define prvInsertBlockIntoFreeList( pxBlockToInsert )                                                                               \\\r\n    {                                                                                                                               \\\r\n        BlockLink_t * pxIterator;                                                                                                   \\\r\n        size_t xBlockSize;                                                                                                          \\\r\n                                                                                                                                    \\\r\n        xBlockSize = pxBlockToInsert->xBlockSize;                                                                                   \\\r\n                                                                                                                                    \\\r\n        /* Iterate through the list until a block is found that has a larger size */                                                \\\r\n        /* than the block we are inserting. */                                                                                      \\\r\n        for( pxIterator = &xStart; pxIterator->pxNextFreeBlock->xBlockSize < xBlockSize; pxIterator = pxIterator->pxNextFreeBlock ) \\\r\n        {                                                                                                                           \\\r\n            /* There is nothing to do here - just iterate to the correct position. */                                               \\\r\n        }                                                                                                                           \\\r\n                                                                                                                                    \\\r\n        /* Update the list to include the block being inserted in the correct */                                                    \\\r\n        /* position. */                                                                                                             \\\r\n        pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;                                                             \\\r\n        pxIterator->pxNextFreeBlock = pxBlockToInsert;                                                                              \\\r\n    }\r\n/*-----------------------------------------------------------*/\r\n\r\nvoid * pvPortMalloc( size_t xWantedSize )\r\n{\r\n    BlockLink_t * pxBlock, * pxPreviousBlock, * pxNewBlockLink;\r\n    static BaseType_t xHeapHasBeenInitialised = pdFALSE;\r\n    void * pvReturn = NULL;\r\n\r\n    vTaskSuspendAll();\r\n    {\r\n        /* If this is the first call to malloc then the heap will require\r\n         * initialisation to setup the list of free blocks. */\r\n        if( xHeapHasBeenInitialised == pdFALSE )\r\n        {\r\n            prvHeapInit();\r\n            xHeapHasBeenInitialised = pdTRUE;\r\n        }\r\n\r\n        /* The wanted size is increased so it can contain a BlockLink_t\r\n         * structure in addition to the requested amount of bytes. */\r\n        if( xWantedSize > 0 )\r\n        {\r\n            xWantedSize += heapSTRUCT_SIZE;\r\n\r\n            /* Ensure that blocks are always aligned to the required number of bytes. */\r\n            if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0 )\r\n            {\r\n                /* Byte alignment required. */\r\n                xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );\r\n            }\r\n        }\r\n\r\n        if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )\r\n        {\r\n            /* Blocks are stored in byte order - traverse the list from the start\r\n             * (smallest) block until one of adequate size is found. */\r\n            pxPreviousBlock = &xStart;\r\n            pxBlock = xStart.pxNextFreeBlock;\r\n\r\n            while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )\r\n            {\r\n                pxPreviousBlock = pxBlock;\r\n                pxBlock = pxBlock->pxNextFreeBlock;\r\n            }\r\n\r\n            /* If we found the end marker then a block of adequate size was not found. */\r\n            if( pxBlock != &xEnd )\r\n            {\r\n                /* Return the memory space - jumping over the BlockLink_t structure\r\n                 * at its start. */\r\n                pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );\r\n\r\n                /* This block is being returned for use so must be taken out of the\r\n                 * list of free blocks. */\r\n                pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;\r\n\r\n                /* If the block is larger than required it can be split into two. */\r\n                if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )\r\n                {\r\n                    /* This block is to be split into two.  Create a new block\r\n                     * following the number of bytes requested. The void cast is\r\n                     * used to prevent byte alignment warnings from the compiler. */\r\n                    pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );\r\n\r\n                    /* Calculate the sizes of two blocks split from the single\r\n                     * block. */\r\n                    pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;\r\n                    pxBlock->xBlockSize = xWantedSize;\r\n\r\n                    /* Insert the new block into the list of free blocks. */\r\n                    prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );\r\n                }\r\n\r\n                xFreeBytesRemaining -= pxBlock->xBlockSize;\r\n            }\r\n        }\r\n\r\n        traceMALLOC( pvReturn, xWantedSize );\r\n    }\r\n    ( void ) xTaskResumeAll();\r\n\r\n    #if ( configUSE_MALLOC_FAILED_HOOK == 1 )\r\n        {\r\n            if( pvReturn == NULL )\r\n            {\r\n                extern void vApplicationMallocFailedHook( void );\r\n                vApplicationMallocFailedHook();\r\n            }\r\n        }\r\n    #endif\r\n\r\n    return pvReturn;\r\n}\r\n/*-----------------------------------------------------------*/\r\n\r\nvoid vPortFree( void * pv )\r\n{\r\n    uint8_t * puc = ( uint8_t * ) pv;\r\n    BlockLink_t * pxLink;\r\n\r\n    if( pv != NULL )\r\n    {\r\n        /* The memory being freed will have an BlockLink_t structure immediately\r\n         * before it. */\r\n        puc -= heapSTRUCT_SIZE;\r\n\r\n        /* This unexpected casting is to keep some compilers from issuing\r\n         * byte alignment warnings. */\r\n        pxLink = ( void * ) puc;\r\n\r\n        vTaskSuspendAll();\r\n        {\r\n            /* Add this block to the list of free blocks. */\r\n            prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );\r\n            xFreeBytesRemaining += pxLink->xBlockSize;\r\n            traceFREE( pv, pxLink->xBlockSize );\r\n        }\r\n        ( void ) xTaskResumeAll();\r\n    }\r\n}\r\n/*-----------------------------------------------------------*/\r\n\r\nsize_t xPortGetFreeHeapSize( void )\r\n{\r\n    return xFreeBytesRemaining;\r\n}\r\n/*-----------------------------------------------------------*/\r\n\r\nvoid vPortInitialiseBlocks( void )\r\n{\r\n    /* This just exists to keep the linker quiet. */\r\n}\r\n/*-----------------------------------------------------------*/\r\n\r\nstatic void prvHeapInit( void )\r\n{\r\n    BlockLink_t * pxFirstFreeBlock;\r\n    uint8_t * pucAlignedHeap;\r\n\r\n    /* Ensure the heap starts on a correctly aligned boundary. */\r\n    pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) & ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );\r\n\r\n    /* xStart is used to hold a pointer to the first item in the list of free\r\n     * blocks.  The void cast is used to prevent compiler warnings. */\r\n    xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;\r\n    xStart.xBlockSize = ( size_t ) 0;\r\n\r\n    /* xEnd is used to mark the end of the list of free blocks. */\r\n    xEnd.xBlockSize = configADJUSTED_HEAP_SIZE;\r\n    xEnd.pxNextFreeBlock = NULL;\r\n\r\n    /* To start with there is a single free block that is sized to take up the\r\n     * entire heap space. */\r\n    pxFirstFreeBlock = ( void * ) pucAlignedHeap;\r\n    pxFirstFreeBlock->xBlockSize = configADJUSTED_HEAP_SIZE;\r\n    pxFirstFreeBlock->pxNextFreeBlock = &xEnd;\r\n}\r\n/*-----------------------------------------------------------*/\r\n", "/*\r\n * FreeRTOS Kernel V10.4.2\r\n * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy of\r\n * this software and associated documentation files (the \"Software\"), to deal in\r\n * the Software without restriction, including without limitation the rights to\r\n * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\r\n * the Software, and to permit persons to whom the Software is furnished to do so,\r\n * subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in all\r\n * copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\r\n * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\r\n * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\r\n * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\r\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n * https://www.FreeRTOS.org\r\n * https://github.com/FreeRTOS\r\n *\r\n */\r\n\r\n/*\r\n * A sample implementation of pvPortMalloc() and vPortFree() that combines\r\n * (coalescences) adjacent memory blocks as they are freed, and in so doing\r\n * limits memory fragmentation.\r\n *\r\n * See heap_1.c, heap_2.c and heap_3.c for alternative implementations, and the\r\n * memory management pages of https://www.FreeRTOS.org for more information.\r\n */\r\n#include <stdlib.h>\r\n\r\n/* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining\r\n * all the API functions to use the MPU wrappers.  That should only be done when\r\n * task.h is included from an application file. */\r\n#define MPU_WRAPPERS_INCLUDED_FROM_API_FILE\r\n\r\n#include \"FreeRTOS.h\"\r\n#include \"task.h\"\r\n\r\n#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE\r\n\r\n#if ( configSUPPORT_DYNAMIC_ALLOCATION == 0 )\r\n    #error This file must not be used if configSUPPORT_DYNAMIC_ALLOCATION is 0\r\n#endif\r\n\r\n/* Block sizes must not get too small. */\r\n#define heapMINIMUM_BLOCK_SIZE    ( ( size_t ) ( xHeapStructSize << 1 ) )\r\n\r\n/* Assumes 8bit bytes! */\r\n#define heapBITS_PER_BYTE         ( ( size_t ) 8 )\r\n\r\n/* Allocate the memory for the heap. */\r\n#if ( configAPPLICATION_ALLOCATED_HEAP == 1 )\r\n\r\n/* The application writer has already defined the array used for the RTOS\r\n* heap - probably so it can be placed in a special segment or address. */\r\n    extern uint8_t ucHeap[ configTOTAL_HEAP_SIZE ];\r\n#else\r\n    PRIVILEGED_DATA static uint8_t ucHeap[ configTOTAL_HEAP_SIZE ];\r\n#endif /* configAPPLICATION_ALLOCATED_HEAP */\r\n\r\n/* Define the linked list structure.  This is used to link free blocks in order\r\n * of their memory address. */\r\ntypedef struct A_BLOCK_LINK\r\n{\r\n    struct A_BLOCK_LINK * pxNextFreeBlock; /*<< The next free block in the list. */\r\n    size_t xBlockSize;                     /*<< The size of the free block. */\r\n} BlockLink_t;\r\n\r\n/*-----------------------------------------------------------*/\r\n\r\n/*\r\n * Inserts a block of memory that is being freed into the correct position in\r\n * the list of free memory blocks.  The block being freed will be merged with\r\n * the block in front it and/or the block behind it if the memory blocks are\r\n * adjacent to each other.\r\n */\r\nstatic void prvInsertBlockIntoFreeList( BlockLink_t * pxBlockToInsert ) PRIVILEGED_FUNCTION;\r\n\r\n/*\r\n * Called automatically to setup the required heap structures the first time\r\n * pvPortMalloc() is called.\r\n */\r\nstatic void prvHeapInit( void ) PRIVILEGED_FUNCTION;\r\n\r\n/*-----------------------------------------------------------*/\r\n\r\n/* The size of the structure placed at the beginning of each allocated memory\r\n * block must by correctly byte aligned. */\r\nstatic const size_t xHeapStructSize = ( sizeof( BlockLink_t ) + ( ( size_t ) ( portBYTE_ALIGNMENT - 1 ) ) ) & ~( ( size_t ) portBYTE_ALIGNMENT_MASK );\r\n\r\n/* Create a couple of list links to mark the start and end of the list. */\r\nPRIVILEGED_DATA static BlockLink_t xStart, * pxEnd = NULL;\r\n\r\n/* Keeps track of the number of calls to allocate and free memory as well as the\r\n * number of free bytes remaining, but says nothing about fragmentation. */\r\nPRIVILEGED_DATA static size_t xFreeBytesRemaining = 0U;\r\nPRIVILEGED_DATA static size_t xMinimumEverFreeBytesRemaining = 0U;\r\nPRIVILEGED_DATA static size_t xNumberOfSuccessfulAllocations = 0;\r\nPRIVILEGED_DATA static size_t xNumberOfSuccessfulFrees = 0;\r\n\r\n/* Gets set to the top bit of an size_t type.  When this bit in the xBlockSize\r\n * member of an BlockLink_t structure is set then the block belongs to the\r\n * application.  When the bit is free the block is still part of the free heap\r\n * space. */\r\nPRIVILEGED_DATA static size_t xBlockAllocatedBit = 0;\r\n\r\n/*-----------------------------------------------------------*/\r\n\r\nvoid * pvPortMalloc( size_t xWantedSize )\r\n{\r\n    BlockLink_t * pxBlock, * pxPreviousBlock, * pxNewBlockLink;\r\n    void * pvReturn = NULL;\r\n\r\n    vTaskSuspendAll();\r\n    {\r\n        /* If this is the first call to malloc then the heap will require\r\n         * initialisation to setup the list of free blocks. */\r\n        if( pxEnd == NULL )\r\n        {\r\n            prvHeapInit();\r\n        }\r\n        else\r\n        {\r\n            mtCOVERAGE_TEST_MARKER();\r\n        }\r\n\r\n        /* Check the requested block size is not so large that the top bit is\r\n         * set.  The top bit of the block size member of the BlockLink_t structure\r\n         * is used to determine who owns the block - the application or the\r\n         * kernel, so it must be free. */\r\n        if( ( xWantedSize & xBlockAllocatedBit ) == 0 )\r\n        {\r\n            /* The wanted size is increased so it can contain a BlockLink_t\r\n             * structure in addition to the requested amount of bytes. */\r\n            if( xWantedSize > 0 )\r\n            {\r\n                xWantedSize += xHeapStructSize;\r\n\r\n                /* Ensure that blocks are always aligned to the required number\r\n                 * of bytes. */\r\n                if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 )\r\n                {\r\n                    /* Byte alignment required. */\r\n                    xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );\r\n                    configASSERT( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) == 0 );\r\n                }\r\n                else\r\n                {\r\n                    mtCOVERAGE_TEST_MARKER();\r\n                }\r\n            }\r\n            else\r\n            {\r\n                mtCOVERAGE_TEST_MARKER();\r\n            }\r\n\r\n            if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )\r\n            {\r\n                /* Traverse the list from the start\t(lowest address) block until\r\n                 * one\tof adequate size is found. */\r\n                pxPreviousBlock = &xStart;\r\n                pxBlock = xStart.pxNextFreeBlock;\r\n\r\n                while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )\r\n                {\r\n                    pxPreviousBlock = pxBlock;\r\n                    pxBlock = pxBlock->pxNextFreeBlock;\r\n                }\r\n\r\n                /* If the end marker was reached then a block of adequate size\r\n                 * was\tnot found. */\r\n                if( pxBlock != pxEnd )\r\n                {\r\n                    /* Return the memory space pointed to - jumping over the\r\n                     * BlockLink_t structure at its start. */\r\n                    pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );\r\n\r\n                    /* This block is being returned for use so must be taken out\r\n                     * of the list of free blocks. */\r\n                    pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;\r\n\r\n                    /* If the block is larger than required it can be split into\r\n                     * two. */\r\n                    if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )\r\n                    {\r\n                        /* This block is to be split into two.  Create a new\r\n                         * block following the number of bytes requested. The void\r\n                         * cast is used to prevent byte alignment warnings from the\r\n                         * compiler. */\r\n                        pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );\r\n                        configASSERT( ( ( ( size_t ) pxNewBlockLink ) & portBYTE_ALIGNMENT_MASK ) == 0 );\r\n\r\n                        /* Calculate the sizes of two blocks split from the\r\n                         * single block. */\r\n                        pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;\r\n                        pxBlock->xBlockSize = xWantedSize;\r\n\r\n                        /* Insert the new block into the list of free blocks. */\r\n                        prvInsertBlockIntoFreeList( pxNewBlockLink );\r\n                    }\r\n                    else\r\n                    {\r\n                        mtCOVERAGE_TEST_MARKER();\r\n                    }\r\n\r\n                    xFreeBytesRemaining -= pxBlock->xBlockSize;\r\n\r\n                    if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )\r\n                    {\r\n                        xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;\r\n                    }\r\n                    else\r\n                    {\r\n                        mtCOVERAGE_TEST_MARKER();\r\n                    }\r\n\r\n                    /* The block is being returned - it is allocated and owned\r\n                     * by the application and has no \"next\" block. */\r\n                    pxBlock->xBlockSize |= xBlockAllocatedBit;\r\n                    pxBlock->pxNextFreeBlock = NULL;\r\n                    xNumberOfSuccessfulAllocations++;\r\n                }\r\n                else\r\n                {\r\n                    mtCOVERAGE_TEST_MARKER();\r\n                }\r\n            }\r\n            else\r\n            {\r\n                mtCOVERAGE_TEST_MARKER();\r\n            }\r\n        }\r\n        else\r\n        {\r\n            mtCOVERAGE_TEST_MARKER();\r\n        }\r\n\r\n        traceMALLOC( pvReturn, xWantedSize );\r\n    }\r\n    ( void ) xTaskResumeAll();\r\n\r\n    #if ( configUSE_MALLOC_FAILED_HOOK == 1 )\r\n        {\r\n            if( pvReturn == NULL )\r\n            {\r\n                extern void vApplicationMallocFailedHook( void );\r\n                vApplicationMallocFailedHook();\r\n            }\r\n            else\r\n            {\r\n                mtCOVERAGE_TEST_MARKER();\r\n            }\r\n        }\r\n    #endif /* if ( configUSE_MALLOC_FAILED_HOOK == 1 ) */\r\n\r\n    configASSERT( ( ( ( size_t ) pvReturn ) & ( size_t ) portBYTE_ALIGNMENT_MASK ) == 0 );\r\n    return pvReturn;\r\n}\r\n/*-----------------------------------------------------------*/\r\n\r\nvoid vPortFree( void * pv )\r\n{\r\n    uint8_t * puc = ( uint8_t * ) pv;\r\n    BlockLink_t * pxLink;\r\n\r\n    if( pv != NULL )\r\n    {\r\n        /* The memory being freed will have an BlockLink_t structure immediately\r\n         * before it. */\r\n        puc -= xHeapStructSize;\r\n\r\n        /* This casting is to keep the compiler from issuing warnings. */\r\n        pxLink = ( void * ) puc;\r\n\r\n        /* Check the block is actually allocated. */\r\n        configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );\r\n        configASSERT( pxLink->pxNextFreeBlock == NULL );\r\n\r\n        if( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 )\r\n        {\r\n            if( pxLink->pxNextFreeBlock == NULL )\r\n            {\r\n                /* The block is being returned to the heap - it is no longer\r\n                 * allocated. */\r\n                pxLink->xBlockSize &= ~xBlockAllocatedBit;\r\n\r\n                vTaskSuspendAll();\r\n                {\r\n                    /* Add this block to the list of free blocks. */\r\n                    xFreeBytesRemaining += pxLink->xBlockSize;\r\n                    traceFREE( pv, pxLink->xBlockSize );\r\n                    prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );\r\n                    xNumberOfSuccessfulFrees++;\r\n                }\r\n                ( void ) xTaskResumeAll();\r\n            }\r\n            else\r\n            {\r\n                mtCOVERAGE_TEST_MARKER();\r\n            }\r\n        }\r\n        else\r\n        {\r\n            mtCOVERAGE_TEST_MARKER();\r\n        }\r\n    }\r\n}\r\n/*-----------------------------------------------------------*/\r\n\r\nsize_t xPortGetFreeHeapSize( void )\r\n{\r\n    return xFreeBytesRemaining;\r\n}\r\n/*-----------------------------------------------------------*/\r\n\r\nsize_t xPortGetMinimumEverFreeHeapSize( void )\r\n{\r\n    return xMinimumEverFreeBytesRemaining;\r\n}\r\n/*-----------------------------------------------------------*/\r\n\r\nvoid vPortInitialiseBlocks( void )\r\n{\r\n    /* This just exists to keep the linker quiet. */\r\n}\r\n/*-----------------------------------------------------------*/\r\n\r\nstatic void prvHeapInit( void ) /* PRIVILEGED_FUNCTION */\r\n{\r\n    BlockLink_t * pxFirstFreeBlock;\r\n    uint8_t * pucAlignedHeap;\r\n    size_t uxAddress;\r\n    size_t xTotalHeapSize = configTOTAL_HEAP_SIZE;\r\n\r\n    /* Ensure the heap starts on a correctly aligned boundary. */\r\n    uxAddress = ( size_t ) ucHeap;\r\n\r\n    if( ( uxAddress & portBYTE_ALIGNMENT_MASK ) != 0 )\r\n    {\r\n        uxAddress += ( portBYTE_ALIGNMENT - 1 );\r\n        uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );\r\n        xTotalHeapSize -= uxAddress - ( size_t ) ucHeap;\r\n    }\r\n\r\n    pucAlignedHeap = ( uint8_t * ) uxAddress;\r\n\r\n    /* xStart is used to hold a pointer to the first item in the list of free\r\n     * blocks.  The void cast is used to prevent compiler warnings. */\r\n    xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;\r\n    xStart.xBlockSize = ( size_t ) 0;\r\n\r\n    /* pxEnd is used to mark the end of the list of free blocks and is inserted\r\n     * at the end of the heap space. */\r\n    uxAddress = ( ( size_t ) pucAlignedHeap ) + xTotalHeapSize;\r\n    uxAddress -= xHeapStructSize;\r\n    uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );\r\n    pxEnd = ( void * ) uxAddress;\r\n    pxEnd->xBlockSize = 0;\r\n    pxEnd->pxNextFreeBlock = NULL;\r\n\r\n    /* To start with there is a single free block that is sized to take up the\r\n     * entire heap space, minus the space taken by pxEnd. */\r\n    pxFirstFreeBlock = ( void * ) pucAlignedHeap;\r\n    pxFirstFreeBlock->xBlockSize = uxAddress - ( size_t ) pxFirstFreeBlock;\r\n    pxFirstFreeBlock->pxNextFreeBlock = pxEnd;\r\n\r\n    /* Only one block exists - and it covers the entire usable heap space. */\r\n    xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;\r\n    xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;\r\n\r\n    /* Work out the position of the top bit in a size_t variable. */\r\n    xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );\r\n}\r\n/*-----------------------------------------------------------*/\r\n\r\nstatic void prvInsertBlockIntoFreeList( BlockLink_t * pxBlockToInsert ) /* PRIVILEGED_FUNCTION */\r\n{\r\n    BlockLink_t * pxIterator;\r\n    uint8_t * puc;\r\n\r\n    /* Iterate through the list until a block is found that has a higher address\r\n     * than the block being inserted. */\r\n    for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )\r\n    {\r\n        /* Nothing to do here, just iterate to the right position. */\r\n    }\r\n\r\n    /* Do the block being inserted, and the block it is being inserted after\r\n     * make a contiguous block of memory? */\r\n    puc = ( uint8_t * ) pxIterator;\r\n\r\n    if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )\r\n    {\r\n        pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;\r\n        pxBlockToInsert = pxIterator;\r\n    }\r\n    else\r\n    {\r\n        mtCOVERAGE_TEST_MARKER();\r\n    }\r\n\r\n    /* Do the block being inserted, and the block it is being inserted before\r\n     * make a contiguous block of memory? */\r\n    puc = ( uint8_t * ) pxBlockToInsert;\r\n\r\n    if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )\r\n    {\r\n        if( pxIterator->pxNextFreeBlock != pxEnd )\r\n        {\r\n            /* Form one big block from the two blocks. */\r\n            pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;\r\n            pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;\r\n        }\r\n        else\r\n        {\r\n            pxBlockToInsert->pxNextFreeBlock = pxEnd;\r\n        }\r\n    }\r\n    else\r\n    {\r\n        pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;\r\n    }\r\n\r\n    /* If the block being inserted plugged a gab, so was merged with the block\r\n     * before and the block after, then it's pxNextFreeBlock pointer will have\r\n     * already been set, and should not be set here as that would make it point\r\n     * to itself. */\r\n    if( pxIterator != pxBlockToInsert )\r\n    {\r\n        pxIterator->pxNextFreeBlock = pxBlockToInsert;\r\n    }\r\n    else\r\n    {\r\n        mtCOVERAGE_TEST_MARKER();\r\n    }\r\n}\r\n/*-----------------------------------------------------------*/\r\n\r\nvoid vPortGetHeapStats( HeapStats_t * pxHeapStats )\r\n{\r\n    BlockLink_t * pxBlock;\r\n    size_t xBlocks = 0, xMaxSize = 0, xMinSize = portMAX_DELAY; /* portMAX_DELAY used as a portable way of getting the maximum value. */\r\n\r\n    vTaskSuspendAll();\r\n    {\r\n        pxBlock = xStart.pxNextFreeBlock;\r\n\r\n        /* pxBlock will be NULL if the heap has not been initialised.  The heap\r\n         * is initialised automatically when the first allocation is made. */\r\n        if( pxBlock != NULL )\r\n        {\r\n            do\r\n            {\r\n                /* Increment the number of blocks and record the largest block seen\r\n                 * so far. */\r\n                xBlocks++;\r\n\r\n                if( pxBlock->xBlockSize > xMaxSize )\r\n                {\r\n                    xMaxSize = pxBlock->xBlockSize;\r\n                }\r\n\r\n                if( pxBlock->xBlockSize < xMinSize )\r\n                {\r\n                    xMinSize = pxBlock->xBlockSize;\r\n                }\r\n\r\n                /* Move to the next block in the chain until the last block is\r\n                 * reached. */\r\n                pxBlock = pxBlock->pxNextFreeBlock;\r\n            } while( pxBlock != pxEnd );\r\n        }\r\n    }\r\n    ( void ) xTaskResumeAll();\r\n\r\n    pxHeapStats->xSizeOfLargestFreeBlockInBytes = xMaxSize;\r\n    pxHeapStats->xSizeOfSmallestFreeBlockInBytes = xMinSize;\r\n    pxHeapStats->xNumberOfFreeBlocks = xBlocks;\r\n\r\n    taskENTER_CRITICAL();\r\n    {\r\n        pxHeapStats->xAvailableHeapSpaceInBytes = xFreeBytesRemaining;\r\n        pxHeapStats->xNumberOfSuccessfulAllocations = xNumberOfSuccessfulAllocations;\r\n        pxHeapStats->xNumberOfSuccessfulFrees = xNumberOfSuccessfulFrees;\r\n        pxHeapStats->xMinimumEverFreeBytesRemaining = xMinimumEverFreeBytesRemaining;\r\n    }\r\n    taskEXIT_CRITICAL();\r\n}\r\n", "/*\r\n * FreeRTOS Kernel V10.4.2\r\n * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy of\r\n * this software and associated documentation files (the \"Software\"), to deal in\r\n * the Software without restriction, including without limitation the rights to\r\n * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\r\n * the Software, and to permit persons to whom the Software is furnished to do so,\r\n * subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in all\r\n * copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\r\n * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\r\n * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\r\n * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\r\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n * https://www.FreeRTOS.org\r\n * https://github.com/FreeRTOS\r\n *\r\n * 1 tab == 4 spaces!\r\n */\r\n\r\n/*\r\n * A sample implementation of pvPortMalloc() that allows the heap to be defined\r\n * across multiple non-contigous blocks and combines (coalescences) adjacent\r\n * memory blocks as they are freed.\r\n *\r\n * See heap_1.c, heap_2.c, heap_3.c and heap_4.c for alternative\r\n * implementations, and the memory management pages of https://www.FreeRTOS.org\r\n * for more information.\r\n *\r\n * Usage notes:\r\n *\r\n * vPortDefineHeapRegions() ***must*** be called before pvPortMalloc().\r\n * pvPortMalloc() will be called if any task objects (tasks, queues, event\r\n * groups, etc.) are created, therefore vPortDefineHeapRegions() ***must*** be\r\n * called before any other objects are defined.\r\n *\r\n * vPortDefineHeapRegions() takes a single parameter.  The parameter is an array\r\n * of HeapRegion_t structures.  HeapRegion_t is defined in portable.h as\r\n *\r\n * typedef struct HeapRegion\r\n * {\r\n *\tuint8_t *pucStartAddress; << Start address of a block of memory that will be part of the heap.\r\n *\tsize_t xSizeInBytes;\t  << Size of the block of memory.\r\n * } HeapRegion_t;\r\n *\r\n * The array is terminated using a NULL zero sized region definition, and the\r\n * memory regions defined in the array ***must*** appear in address order from\r\n * low address to high address.  So the following is a valid example of how\r\n * to use the function.\r\n *\r\n * HeapRegion_t xHeapRegions[] =\r\n * {\r\n *  { ( uint8_t * ) 0x80000000UL, 0x10000 }, << Defines a block of 0x10000 bytes starting at address 0x80000000\r\n *  { ( uint8_t * ) 0x90000000UL, 0xa0000 }, << Defines a block of 0xa0000 bytes starting at address of 0x90000000\r\n *  { NULL, 0 }                << Terminates the array.\r\n * };\r\n *\r\n * vPortDefineHeapRegions( xHeapRegions ); << Pass the array into vPortDefineHeapRegions().\r\n *\r\n * Note 0x80000000 is the lower address so appears in the array first.\r\n *\r\n */\r\n#include <stdlib.h>\r\n\r\n/* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining\r\n * all the API functions to use the MPU wrappers.  That should only be done when\r\n * task.h is included from an application file. */\r\n#define MPU_WRAPPERS_INCLUDED_FROM_API_FILE\r\n\r\n#include \"FreeRTOS.h\"\r\n#include \"task.h\"\r\n\r\n#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE\r\n\r\n#if ( configSUPPORT_DYNAMIC_ALLOCATION == 0 )\r\n    #error This file must not be used if configSUPPORT_DYNAMIC_ALLOCATION is 0\r\n#endif\r\n\r\n/* Block sizes must not get too small. */\r\n#define heapMINIMUM_BLOCK_SIZE    ( ( size_t ) ( xHeapStructSize << 1 ) )\r\n\r\n/* Assumes 8bit bytes! */\r\n#define heapBITS_PER_BYTE         ( ( size_t ) 8 )\r\n\r\n/* Define the linked list structure.  This is used to link free blocks in order\r\n * of their memory address. */\r\ntypedef struct A_BLOCK_LINK\r\n{\r\n    struct A_BLOCK_LINK * pxNextFreeBlock; /*<< The next free block in the list. */\r\n    size_t xBlockSize;                     /*<< The size of the free block. */\r\n} BlockLink_t;\r\n\r\n/*-----------------------------------------------------------*/\r\n\r\n/*\r\n * Inserts a block of memory that is being freed into the correct position in\r\n * the list of free memory blocks.  The block being freed will be merged with\r\n * the block in front it and/or the block behind it if the memory blocks are\r\n * adjacent to each other.\r\n */\r\nstatic void prvInsertBlockIntoFreeList( BlockLink_t * pxBlockToInsert );\r\n\r\n/*-----------------------------------------------------------*/\r\n\r\n/* The size of the structure placed at the beginning of each allocated memory\r\n * block must by correctly byte aligned. */\r\nstatic const size_t xHeapStructSize = ( sizeof( BlockLink_t ) + ( ( size_t ) ( portBYTE_ALIGNMENT - 1 ) ) ) & ~( ( size_t ) portBYTE_ALIGNMENT_MASK );\r\n\r\n/* Create a couple of list links to mark the start and end of the list. */\r\nstatic BlockLink_t xStart, * pxEnd = NULL;\r\n\r\n/* Keeps track of the number of calls to allocate and free memory as well as the\r\n * number of free bytes remaining, but says nothing about fragmentation. */\r\nstatic size_t xFreeBytesRemaining = 0U;\r\nstatic size_t xMinimumEverFreeBytesRemaining = 0U;\r\nstatic size_t xNumberOfSuccessfulAllocations = 0;\r\nstatic size_t xNumberOfSuccessfulFrees = 0;\r\n\r\n/* Gets set to the top bit of an size_t type.  When this bit in the xBlockSize\r\n * member of an BlockLink_t structure is set then the block belongs to the\r\n * application.  When the bit is free the block is still part of the free heap\r\n * space. */\r\nstatic size_t xBlockAllocatedBit = 0;\r\n\r\n/*-----------------------------------------------------------*/\r\n\r\nvoid * pvPortMalloc( size_t xWantedSize )\r\n{\r\n    BlockLink_t * pxBlock, * pxPreviousBlock, * pxNewBlockLink;\r\n    void * pvReturn = NULL;\r\n\r\n    /* The heap must be initialised before the first call to\r\n     * prvPortMalloc(). */\r\n    configASSERT( pxEnd );\r\n\r\n    vTaskSuspendAll();\r\n    {\r\n        /* Check the requested block size is not so large that the top bit is\r\n         * set.  The top bit of the block size member of the BlockLink_t structure\r\n         * is used to determine who owns the block - the application or the\r\n         * kernel, so it must be free. */\r\n        if( ( xWantedSize & xBlockAllocatedBit ) == 0 )\r\n        {\r\n            /* The wanted size is increased so it can contain a BlockLink_t\r\n             * structure in addition to the requested amount of bytes. */\r\n            if( xWantedSize > 0 )\r\n            {\r\n                xWantedSize += xHeapStructSize;\r\n\r\n                /* Ensure that blocks are always aligned to the required number\r\n                 * of bytes. */\r\n                if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 )\r\n                {\r\n                    /* Byte alignment required. */\r\n                    xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );\r\n                }\r\n                else\r\n                {\r\n                    mtCOVERAGE_TEST_MARKER();\r\n                }\r\n            }\r\n            else\r\n            {\r\n                mtCOVERAGE_TEST_MARKER();\r\n            }\r\n\r\n            if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )\r\n            {\r\n                /* Traverse the list from the start\t(lowest address) block until\r\n                 * one\tof adequate size is found. */\r\n                pxPreviousBlock = &xStart;\r\n                pxBlock = xStart.pxNextFreeBlock;\r\n\r\n                while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )\r\n                {\r\n                    pxPreviousBlock = pxBlock;\r\n                    pxBlock = pxBlock->pxNextFreeBlock;\r\n                }\r\n\r\n                /* If the end marker was reached then a block of adequate size\r\n                 * was\tnot found. */\r\n                if( pxBlock != pxEnd )\r\n                {\r\n                    /* Return the memory space pointed to - jumping over the\r\n                     * BlockLink_t structure at its start. */\r\n                    pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );\r\n\r\n                    /* This block is being returned for use so must be taken out\r\n                     * of the list of free blocks. */\r\n                    pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;\r\n\r\n                    /* If the block is larger than required it can be split into\r\n                     * two. */\r\n                    if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )\r\n                    {\r\n                        /* This block is to be split into two.  Create a new\r\n                         * block following the number of bytes requested. The void\r\n                         * cast is used to prevent byte alignment warnings from the\r\n                         * compiler. */\r\n                        pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );\r\n\r\n                        /* Calculate the sizes of two blocks split from the\r\n                         * single block. */\r\n                        pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;\r\n                        pxBlock->xBlockSize = xWantedSize;\r\n\r\n                        /* Insert the new block into the list of free blocks. */\r\n                        prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );\r\n                    }\r\n                    else\r\n                    {\r\n                        mtCOVERAGE_TEST_MARKER();\r\n                    }\r\n\r\n                    xFreeBytesRemaining -= pxBlock->xBlockSize;\r\n\r\n                    if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )\r\n                    {\r\n                        xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;\r\n                    }\r\n                    else\r\n                    {\r\n                        mtCOVERAGE_TEST_MARKER();\r\n                    }\r\n\r\n                    /* The block is being returned - it is allocated and owned\r\n                     * by the application and has no \"next\" block. */\r\n                    pxBlock->xBlockSize |= xBlockAllocatedBit;\r\n                    pxBlock->pxNextFreeBlock = NULL;\r\n                    xNumberOfSuccessfulAllocations++;\r\n                }\r\n                else\r\n                {\r\n                    mtCOVERAGE_TEST_MARKER();\r\n                }\r\n            }\r\n            else\r\n            {\r\n                mtCOVERAGE_TEST_MARKER();\r\n            }\r\n        }\r\n        else\r\n        {\r\n            mtCOVERAGE_TEST_MARKER();\r\n        }\r\n\r\n        traceMALLOC( pvReturn, xWantedSize );\r\n    }\r\n    ( void ) xTaskResumeAll();\r\n\r\n    #if ( configUSE_MALLOC_FAILED_HOOK == 1 )\r\n        {\r\n            if( pvReturn == NULL )\r\n            {\r\n                extern void vApplicationMallocFailedHook( void );\r\n                vApplicationMallocFailedHook();\r\n            }\r\n            else\r\n            {\r\n                mtCOVERAGE_TEST_MARKER();\r\n            }\r\n        }\r\n    #endif /* if ( configUSE_MALLOC_FAILED_HOOK == 1 ) */\r\n\r\n    return pvReturn;\r\n}\r\n/*-----------------------------------------------------------*/\r\n\r\nvoid vPortFree( void * pv )\r\n{\r\n    uint8_t * puc = ( uint8_t * ) pv;\r\n    BlockLink_t * pxLink;\r\n\r\n    if( pv != NULL )\r\n    {\r\n        /* The memory being freed will have an BlockLink_t structure immediately\r\n         * before it. */\r\n        puc -= xHeapStructSize;\r\n\r\n        /* This casting is to keep the compiler from issuing warnings. */\r\n        pxLink = ( void * ) puc;\r\n\r\n        /* Check the block is actually allocated. */\r\n        configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );\r\n        configASSERT( pxLink->pxNextFreeBlock == NULL );\r\n\r\n        if( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 )\r\n        {\r\n            if( pxLink->pxNextFreeBlock == NULL )\r\n            {\r\n                /* The block is being returned to the heap - it is no longer\r\n                 * allocated. */\r\n                pxLink->xBlockSize &= ~xBlockAllocatedBit;\r\n\r\n                vTaskSuspendAll();\r\n                {\r\n                    /* Add this block to the list of free blocks. */\r\n                    xFreeBytesRemaining += pxLink->xBlockSize;\r\n                    traceFREE( pv, pxLink->xBlockSize );\r\n                    prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );\r\n                    xNumberOfSuccessfulFrees++;\r\n                }\r\n                ( void ) xTaskResumeAll();\r\n            }\r\n            else\r\n            {\r\n                mtCOVERAGE_TEST_MARKER();\r\n            }\r\n        }\r\n        else\r\n        {\r\n            mtCOVERAGE_TEST_MARKER();\r\n        }\r\n    }\r\n}\r\n/*-----------------------------------------------------------*/\r\n\r\nsize_t xPortGetFreeHeapSize( void )\r\n{\r\n    return xFreeBytesRemaining;\r\n}\r\n/*-----------------------------------------------------------*/\r\n\r\nsize_t xPortGetMinimumEverFreeHeapSize( void )\r\n{\r\n    return xMinimumEverFreeBytesRemaining;\r\n}\r\n/*-----------------------------------------------------------*/\r\n\r\nstatic void prvInsertBlockIntoFreeList( BlockLink_t * pxBlockToInsert )\r\n{\r\n    BlockLink_t * pxIterator;\r\n    uint8_t * puc;\r\n\r\n    /* Iterate through the list until a block is found that has a higher address\r\n     * than the block being inserted. */\r\n    for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )\r\n    {\r\n        /* Nothing to do here, just iterate to the right position. */\r\n    }\r\n\r\n    /* Do the block being inserted, and the block it is being inserted after\r\n     * make a contiguous block of memory? */\r\n    puc = ( uint8_t * ) pxIterator;\r\n\r\n    if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )\r\n    {\r\n        pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;\r\n        pxBlockToInsert = pxIterator;\r\n    }\r\n    else\r\n    {\r\n        mtCOVERAGE_TEST_MARKER();\r\n    }\r\n\r\n    /* Do the block being inserted, and the block it is being inserted before\r\n     * make a contiguous block of memory? */\r\n    puc = ( uint8_t * ) pxBlockToInsert;\r\n\r\n    if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )\r\n    {\r\n        if( pxIterator->pxNextFreeBlock != pxEnd )\r\n        {\r\n            /* Form one big block from the two blocks. */\r\n            pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;\r\n            pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;\r\n        }\r\n        else\r\n        {\r\n            pxBlockToInsert->pxNextFreeBlock = pxEnd;\r\n        }\r\n    }\r\n    else\r\n    {\r\n        pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;\r\n    }\r\n\r\n    /* If the block being inserted plugged a gab, so was merged with the block\r\n     * before and the block after, then it's pxNextFreeBlock pointer will have\r\n     * already been set, and should not be set here as that would make it point\r\n     * to itself. */\r\n    if( pxIterator != pxBlockToInsert )\r\n    {\r\n        pxIterator->pxNextFreeBlock = pxBlockToInsert;\r\n    }\r\n    else\r\n    {\r\n        mtCOVERAGE_TEST_MARKER();\r\n    }\r\n}\r\n/*-----------------------------------------------------------*/\r\n\r\nvoid vPortDefineHeapRegions( const HeapRegion_t * const pxHeapRegions )\r\n{\r\n    BlockLink_t * pxFirstFreeBlockInRegion = NULL, * pxPreviousFreeBlock;\r\n    size_t xAlignedHeap;\r\n    size_t xTotalRegionSize, xTotalHeapSize = 0;\r\n    BaseType_t xDefinedRegions = 0;\r\n    size_t xAddress;\r\n    const HeapRegion_t * pxHeapRegion;\r\n\r\n    /* Can only call once! */\r\n    configASSERT( pxEnd == NULL );\r\n\r\n    pxHeapRegion = &( pxHeapRegions[ xDefinedRegions ] );\r\n\r\n    while( pxHeapRegion->xSizeInBytes > 0 )\r\n    {\r\n        xTotalRegionSize = pxHeapRegion->xSizeInBytes;\r\n\r\n        /* Ensure the heap region starts on a correctly aligned boundary. */\r\n        xAddress = ( size_t ) pxHeapRegion->pucStartAddress;\r\n\r\n        if( ( xAddress & portBYTE_ALIGNMENT_MASK ) != 0 )\r\n        {\r\n            xAddress += ( portBYTE_ALIGNMENT - 1 );\r\n            xAddress &= ~portBYTE_ALIGNMENT_MASK;\r\n\r\n            /* Adjust the size for the bytes lost to alignment. */\r\n            xTotalRegionSize -= xAddress - ( size_t ) pxHeapRegion->pucStartAddress;\r\n        }\r\n\r\n        xAlignedHeap = xAddress;\r\n\r\n        /* Set xStart if it has not already been set. */\r\n        if( xDefinedRegions == 0 )\r\n        {\r\n            /* xStart is used to hold a pointer to the first item in the list of\r\n             *  free blocks.  The void cast is used to prevent compiler warnings. */\r\n            xStart.pxNextFreeBlock = ( BlockLink_t * ) xAlignedHeap;\r\n            xStart.xBlockSize = ( size_t ) 0;\r\n        }\r\n        else\r\n        {\r\n            /* Should only get here if one region has already been added to the\r\n             * heap. */\r\n            configASSERT( pxEnd != NULL );\r\n\r\n            /* Check blocks are passed in with increasing start addresses. */\r\n            configASSERT( xAddress > ( size_t ) pxEnd );\r\n        }\r\n\r\n        /* Remember the location of the end marker in the previous region, if\r\n         * any. */\r\n        pxPreviousFreeBlock = pxEnd;\r\n\r\n        /* pxEnd is used to mark the end of the list of free blocks and is\r\n         * inserted at the end of the region space. */\r\n        xAddress = xAlignedHeap + xTotalRegionSize;\r\n        xAddress -= xHeapStructSize;\r\n        xAddress &= ~portBYTE_ALIGNMENT_MASK;\r\n        pxEnd = ( BlockLink_t * ) xAddress;\r\n        pxEnd->xBlockSize = 0;\r\n        pxEnd->pxNextFreeBlock = NULL;\r\n\r\n        /* To start with there is a single free block in this region that is\r\n         * sized to take up the entire heap region minus the space taken by the\r\n         * free block structure. */\r\n        pxFirstFreeBlockInRegion = ( BlockLink_t * ) xAlignedHeap;\r\n        pxFirstFreeBlockInRegion->xBlockSize = xAddress - ( size_t ) pxFirstFreeBlockInRegion;\r\n        pxFirstFreeBlockInRegion->pxNextFreeBlock = pxEnd;\r\n\r\n        /* If this is not the first region that makes up the entire heap space\r\n         * then link the previous region to this region. */\r\n        if( pxPreviousFreeBlock != NULL )\r\n        {\r\n            pxPreviousFreeBlock->pxNextFreeBlock = pxFirstFreeBlockInRegion;\r\n        }\r\n\r\n        xTotalHeapSize += pxFirstFreeBlockInRegion->xBlockSize;\r\n\r\n        /* Move onto the next HeapRegion_t structure. */\r\n        xDefinedRegions++;\r\n        pxHeapRegion = &( pxHeapRegions[ xDefinedRegions ] );\r\n    }\r\n\r\n    xMinimumEverFreeBytesRemaining = xTotalHeapSize;\r\n    xFreeBytesRemaining = xTotalHeapSize;\r\n\r\n    /* Check something was actually defined before it is accessed. */\r\n    configASSERT( xTotalHeapSize );\r\n\r\n    /* Work out the position of the top bit in a size_t variable. */\r\n    xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );\r\n}\r\n/*-----------------------------------------------------------*/\r\n\r\nvoid vPortGetHeapStats( HeapStats_t * pxHeapStats )\r\n{\r\n    BlockLink_t * pxBlock;\r\n    size_t xBlocks = 0, xMaxSize = 0, xMinSize = portMAX_DELAY; /* portMAX_DELAY used as a portable way of getting the maximum value. */\r\n\r\n    vTaskSuspendAll();\r\n    {\r\n        pxBlock = xStart.pxNextFreeBlock;\r\n\r\n        /* pxBlock will be NULL if the heap has not been initialised.  The heap\r\n         * is initialised automatically when the first allocation is made. */\r\n        if( pxBlock != NULL )\r\n        {\r\n            do\r\n            {\r\n                /* Increment the number of blocks and record the largest block seen\r\n                 * so far. */\r\n                xBlocks++;\r\n\r\n                if( pxBlock->xBlockSize > xMaxSize )\r\n                {\r\n                    xMaxSize = pxBlock->xBlockSize;\r\n                }\r\n\r\n                /* Heap five will have a zero sized block at the end of each\r\n                 * each region - the block is only used to link to the next\r\n                 * heap region so it not a real block. */\r\n                if( pxBlock->xBlockSize != 0 )\r\n                {\r\n                    if( pxBlock->xBlockSize < xMinSize )\r\n                    {\r\n                        xMinSize = pxBlock->xBlockSize;\r\n                    }\r\n                }\r\n\r\n                /* Move to the next block in the chain until the last block is\r\n                 * reached. */\r\n                pxBlock = pxBlock->pxNextFreeBlock;\r\n            } while( pxBlock != pxEnd );\r\n        }\r\n    }\r\n    ( void ) xTaskResumeAll();\r\n\r\n    pxHeapStats->xSizeOfLargestFreeBlockInBytes = xMaxSize;\r\n    pxHeapStats->xSizeOfSmallestFreeBlockInBytes = xMinSize;\r\n    pxHeapStats->xNumberOfFreeBlocks = xBlocks;\r\n\r\n    taskENTER_CRITICAL();\r\n    {\r\n        pxHeapStats->xAvailableHeapSpaceInBytes = xFreeBytesRemaining;\r\n        pxHeapStats->xNumberOfSuccessfulAllocations = xNumberOfSuccessfulAllocations;\r\n        pxHeapStats->xNumberOfSuccessfulFrees = xNumberOfSuccessfulFrees;\r\n        pxHeapStats->xMinimumEverFreeBytesRemaining = xMinimumEverFreeBytesRemaining;\r\n    }\r\n    taskEXIT_CRITICAL();\r\n}\r\n"], "fixing_code": ["/*\r\n * FreeRTOS Kernel V10.4.2\r\n * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy of\r\n * this software and associated documentation files (the \"Software\"), to deal in\r\n * the Software without restriction, including without limitation the rights to\r\n * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\r\n * the Software, and to permit persons to whom the Software is furnished to do so,\r\n * subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in all\r\n * copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\r\n * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\r\n * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\r\n * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\r\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n * https://www.FreeRTOS.org\r\n * https://github.com/FreeRTOS\r\n *\r\n */\r\n\r\n\r\n/*\r\n * The simplest possible implementation of pvPortMalloc().  Note that this\r\n * implementation does NOT allow allocated memory to be freed again.\r\n *\r\n * See heap_2.c, heap_3.c and heap_4.c for alternative implementations, and the\r\n * memory management pages of https://www.FreeRTOS.org for more information.\r\n */\r\n#include <stdlib.h>\r\n\r\n/* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining\r\n * all the API functions to use the MPU wrappers.  That should only be done when\r\n * task.h is included from an application file. */\r\n#define MPU_WRAPPERS_INCLUDED_FROM_API_FILE\r\n\r\n#include \"FreeRTOS.h\"\r\n#include \"task.h\"\r\n\r\n#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE\r\n\r\n#if ( configSUPPORT_DYNAMIC_ALLOCATION == 0 )\r\n    #error This file must not be used if configSUPPORT_DYNAMIC_ALLOCATION is 0\r\n#endif\r\n\r\n/* A few bytes might be lost to byte aligning the heap start address. */\r\n#define configADJUSTED_HEAP_SIZE    ( configTOTAL_HEAP_SIZE - portBYTE_ALIGNMENT )\r\n\r\n/* Allocate the memory for the heap. */\r\n#if ( configAPPLICATION_ALLOCATED_HEAP == 1 )\r\n\r\n/* The application writer has already defined the array used for the RTOS\r\n* heap - probably so it can be placed in a special segment or address. */\r\n    extern uint8_t ucHeap[ configTOTAL_HEAP_SIZE ];\r\n#else\r\n    static uint8_t ucHeap[ configTOTAL_HEAP_SIZE ];\r\n#endif /* configAPPLICATION_ALLOCATED_HEAP */\r\n\r\n/* Index into the ucHeap array. */\r\nstatic size_t xNextFreeByte = ( size_t ) 0;\r\n\r\n/*-----------------------------------------------------------*/\r\n\r\nvoid * pvPortMalloc( size_t xWantedSize )\r\n{\r\n    void * pvReturn = NULL;\r\n    static uint8_t * pucAlignedHeap = NULL;\r\n\r\n    /* Ensure that blocks are always aligned. */\r\n    #if ( portBYTE_ALIGNMENT != 1 )\r\n        {\r\n            if( xWantedSize & portBYTE_ALIGNMENT_MASK )\r\n            {\r\n                /* Byte alignment required. Check for overflow. */\r\n                if ( (xWantedSize + ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) )) > xWantedSize )\r\n                {\r\n                    xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );\r\n                } \r\n                else \r\n                {\r\n                    xWantedSize = 0;\r\n                }\r\n            }\r\n        }\r\n    #endif\r\n\r\n    vTaskSuspendAll();\r\n    {\r\n        if( pucAlignedHeap == NULL )\r\n        {\r\n            /* Ensure the heap starts on a correctly aligned boundary. */\r\n            pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) & ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );\r\n        }\r\n\r\n        /* Check there is enough room left for the allocation and. */\r\n        if( ( xWantedSize > 0 ) && /* valid size */\r\n            ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&\r\n            ( ( xNextFreeByte + xWantedSize ) > xNextFreeByte ) ) /* Check for overflow. */\r\n        {\r\n            /* Return the next free byte then increment the index past this\r\n             * block. */\r\n            pvReturn = pucAlignedHeap + xNextFreeByte;\r\n            xNextFreeByte += xWantedSize;\r\n        }\r\n\r\n        traceMALLOC( pvReturn, xWantedSize );\r\n    }\r\n    ( void ) xTaskResumeAll();\r\n\r\n    #if ( configUSE_MALLOC_FAILED_HOOK == 1 )\r\n        {\r\n            if( pvReturn == NULL )\r\n            {\r\n                extern void vApplicationMallocFailedHook( void );\r\n                vApplicationMallocFailedHook();\r\n            }\r\n        }\r\n    #endif\r\n\r\n    return pvReturn;\r\n}\r\n/*-----------------------------------------------------------*/\r\n\r\nvoid vPortFree( void * pv )\r\n{\r\n    /* Memory cannot be freed using this scheme.  See heap_2.c, heap_3.c and\r\n     * heap_4.c for alternative implementations, and the memory management pages of\r\n     * https://www.FreeRTOS.org for more information. */\r\n    ( void ) pv;\r\n\r\n    /* Force an assert as it is invalid to call this function. */\r\n    configASSERT( pv == NULL );\r\n}\r\n/*-----------------------------------------------------------*/\r\n\r\nvoid vPortInitialiseBlocks( void )\r\n{\r\n    /* Only required when static memory is not cleared. */\r\n    xNextFreeByte = ( size_t ) 0;\r\n}\r\n/*-----------------------------------------------------------*/\r\n\r\nsize_t xPortGetFreeHeapSize( void )\r\n{\r\n    return( configADJUSTED_HEAP_SIZE - xNextFreeByte );\r\n}\r\n", "/*\r\n * FreeRTOS Kernel V10.4.2\r\n * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy of\r\n * this software and associated documentation files (the \"Software\"), to deal in\r\n * the Software without restriction, including without limitation the rights to\r\n * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\r\n * the Software, and to permit persons to whom the Software is furnished to do so,\r\n * subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in all\r\n * copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\r\n * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\r\n * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\r\n * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\r\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n * https://www.FreeRTOS.org\r\n * https://github.com/FreeRTOS\r\n *\r\n */\r\n\r\n/*\r\n * A sample implementation of pvPortMalloc() and vPortFree() that permits\r\n * allocated blocks to be freed, but does not combine adjacent free blocks\r\n * into a single larger block (and so will fragment memory).  See heap_4.c for\r\n * an equivalent that does combine adjacent blocks into single larger blocks.\r\n *\r\n * See heap_1.c, heap_3.c and heap_4.c for alternative implementations, and the\r\n * memory management pages of https://www.FreeRTOS.org for more information.\r\n */\r\n#include <stdlib.h>\r\n\r\n/* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining\r\n * all the API functions to use the MPU wrappers.  That should only be done when\r\n * task.h is included from an application file. */\r\n#define MPU_WRAPPERS_INCLUDED_FROM_API_FILE\r\n\r\n#include \"FreeRTOS.h\"\r\n#include \"task.h\"\r\n\r\n#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE\r\n\r\n#if ( configSUPPORT_DYNAMIC_ALLOCATION == 0 )\r\n    #error This file must not be used if configSUPPORT_DYNAMIC_ALLOCATION is 0\r\n#endif\r\n\r\n/* A few bytes might be lost to byte aligning the heap start address. */\r\n#define configADJUSTED_HEAP_SIZE    ( configTOTAL_HEAP_SIZE - portBYTE_ALIGNMENT )\r\n\r\n/*\r\n * Initialises the heap structures before their first use.\r\n */\r\nstatic void prvHeapInit( void );\r\n\r\n/* Allocate the memory for the heap. */\r\n#if ( configAPPLICATION_ALLOCATED_HEAP == 1 )\r\n\r\n/* The application writer has already defined the array used for the RTOS\r\n* heap - probably so it can be placed in a special segment or address. */\r\n    extern uint8_t ucHeap[ configTOTAL_HEAP_SIZE ];\r\n#else\r\n    static uint8_t ucHeap[ configTOTAL_HEAP_SIZE ];\r\n#endif /* configAPPLICATION_ALLOCATED_HEAP */\r\n\r\n\r\n/* Define the linked list structure.  This is used to link free blocks in order\r\n * of their size. */\r\ntypedef struct A_BLOCK_LINK\r\n{\r\n    struct A_BLOCK_LINK * pxNextFreeBlock; /*<< The next free block in the list. */\r\n    size_t xBlockSize;                     /*<< The size of the free block. */\r\n} BlockLink_t;\r\n\r\n\r\nstatic const uint16_t heapSTRUCT_SIZE = ( ( sizeof( BlockLink_t ) + ( portBYTE_ALIGNMENT - 1 ) ) & ~portBYTE_ALIGNMENT_MASK );\r\n#define heapMINIMUM_BLOCK_SIZE    ( ( size_t ) ( heapSTRUCT_SIZE * 2 ) )\r\n\r\n/* Create a couple of list links to mark the start and end of the list. */\r\nstatic BlockLink_t xStart, xEnd;\r\n\r\n/* Keeps track of the number of free bytes remaining, but says nothing about\r\n * fragmentation. */\r\nstatic size_t xFreeBytesRemaining = configADJUSTED_HEAP_SIZE;\r\n\r\n/* STATIC FUNCTIONS ARE DEFINED AS MACROS TO MINIMIZE THE FUNCTION CALL DEPTH. */\r\n\r\n/*\r\n * Insert a block into the list of free blocks - which is ordered by size of\r\n * the block.  Small blocks at the start of the list and large blocks at the end\r\n * of the list.\r\n */\r\n#define prvInsertBlockIntoFreeList( pxBlockToInsert )                                                                               \\\r\n    {                                                                                                                               \\\r\n        BlockLink_t * pxIterator;                                                                                                   \\\r\n        size_t xBlockSize;                                                                                                          \\\r\n                                                                                                                                    \\\r\n        xBlockSize = pxBlockToInsert->xBlockSize;                                                                                   \\\r\n                                                                                                                                    \\\r\n        /* Iterate through the list until a block is found that has a larger size */                                                \\\r\n        /* than the block we are inserting. */                                                                                      \\\r\n        for( pxIterator = &xStart; pxIterator->pxNextFreeBlock->xBlockSize < xBlockSize; pxIterator = pxIterator->pxNextFreeBlock ) \\\r\n        {                                                                                                                           \\\r\n            /* There is nothing to do here - just iterate to the correct position. */                                               \\\r\n        }                                                                                                                           \\\r\n                                                                                                                                    \\\r\n        /* Update the list to include the block being inserted in the correct */                                                    \\\r\n        /* position. */                                                                                                             \\\r\n        pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;                                                             \\\r\n        pxIterator->pxNextFreeBlock = pxBlockToInsert;                                                                              \\\r\n    }\r\n/*-----------------------------------------------------------*/\r\n\r\nvoid * pvPortMalloc( size_t xWantedSize )\r\n{\r\n    BlockLink_t * pxBlock, * pxPreviousBlock, * pxNewBlockLink;\r\n    static BaseType_t xHeapHasBeenInitialised = pdFALSE;\r\n    void * pvReturn = NULL;\r\n\r\n    vTaskSuspendAll();\r\n    {\r\n        /* If this is the first call to malloc then the heap will require\r\n         * initialisation to setup the list of free blocks. */\r\n        if( xHeapHasBeenInitialised == pdFALSE )\r\n        {\r\n            prvHeapInit();\r\n            xHeapHasBeenInitialised = pdTRUE;\r\n        }\r\n\r\n        /* The wanted size must be increased so it can contain a BlockLink_t\r\n         * structure in addition to the requested amount of bytes. */\r\n        if( ( xWantedSize > 0 ) && \r\n            ( ( xWantedSize + heapSTRUCT_SIZE ) >  xWantedSize ) ) /* Overflow check */\r\n        {\r\n            xWantedSize += heapSTRUCT_SIZE;\r\n\r\n            /* Byte alignment required. Check for overflow. */\r\n            if( ( xWantedSize + ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) ) ) \r\n                    > xWantedSize )\r\n            {\r\n                xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );\r\n                configASSERT( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) == 0 );\r\n            }\r\n            else\r\n            {\r\n                xWantedSize = 0;\r\n            }       \r\n        }\r\n        else \r\n        {\r\n            xWantedSize = 0; \r\n        }\r\n\r\n\r\n        if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )\r\n        {\r\n            /* Blocks are stored in byte order - traverse the list from the start\r\n             * (smallest) block until one of adequate size is found. */\r\n            pxPreviousBlock = &xStart;\r\n            pxBlock = xStart.pxNextFreeBlock;\r\n\r\n            while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )\r\n            {\r\n                pxPreviousBlock = pxBlock;\r\n                pxBlock = pxBlock->pxNextFreeBlock;\r\n            }\r\n\r\n            /* If we found the end marker then a block of adequate size was not found. */\r\n            if( pxBlock != &xEnd )\r\n            {\r\n                /* Return the memory space - jumping over the BlockLink_t structure\r\n                 * at its start. */\r\n                pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );\r\n\r\n                /* This block is being returned for use so must be taken out of the\r\n                 * list of free blocks. */\r\n                pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;\r\n\r\n                /* If the block is larger than required it can be split into two. */\r\n                if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )\r\n                {\r\n                    /* This block is to be split into two.  Create a new block\r\n                     * following the number of bytes requested. The void cast is\r\n                     * used to prevent byte alignment warnings from the compiler. */\r\n                    pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );\r\n\r\n                    /* Calculate the sizes of two blocks split from the single\r\n                     * block. */\r\n                    pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;\r\n                    pxBlock->xBlockSize = xWantedSize;\r\n\r\n                    /* Insert the new block into the list of free blocks. */\r\n                    prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );\r\n                }\r\n\r\n                xFreeBytesRemaining -= pxBlock->xBlockSize;\r\n            }\r\n        }\r\n\r\n        traceMALLOC( pvReturn, xWantedSize );\r\n    }\r\n    ( void ) xTaskResumeAll();\r\n\r\n    #if ( configUSE_MALLOC_FAILED_HOOK == 1 )\r\n        {\r\n            if( pvReturn == NULL )\r\n            {\r\n                extern void vApplicationMallocFailedHook( void );\r\n                vApplicationMallocFailedHook();\r\n            }\r\n        }\r\n    #endif\r\n\r\n    return pvReturn;\r\n}\r\n/*-----------------------------------------------------------*/\r\n\r\nvoid vPortFree( void * pv )\r\n{\r\n    uint8_t * puc = ( uint8_t * ) pv;\r\n    BlockLink_t * pxLink;\r\n\r\n    if( pv != NULL )\r\n    {\r\n        /* The memory being freed will have an BlockLink_t structure immediately\r\n         * before it. */\r\n        puc -= heapSTRUCT_SIZE;\r\n\r\n        /* This unexpected casting is to keep some compilers from issuing\r\n         * byte alignment warnings. */\r\n        pxLink = ( void * ) puc;\r\n\r\n        vTaskSuspendAll();\r\n        {\r\n            /* Add this block to the list of free blocks. */\r\n            prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );\r\n            xFreeBytesRemaining += pxLink->xBlockSize;\r\n            traceFREE( pv, pxLink->xBlockSize );\r\n        }\r\n        ( void ) xTaskResumeAll();\r\n    }\r\n}\r\n/*-----------------------------------------------------------*/\r\n\r\nsize_t xPortGetFreeHeapSize( void )\r\n{\r\n    return xFreeBytesRemaining;\r\n}\r\n/*-----------------------------------------------------------*/\r\n\r\nvoid vPortInitialiseBlocks( void )\r\n{\r\n    /* This just exists to keep the linker quiet. */\r\n}\r\n/*-----------------------------------------------------------*/\r\n\r\nstatic void prvHeapInit( void )\r\n{\r\n    BlockLink_t * pxFirstFreeBlock;\r\n    uint8_t * pucAlignedHeap;\r\n\r\n    /* Ensure the heap starts on a correctly aligned boundary. */\r\n    pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) & ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );\r\n\r\n    /* xStart is used to hold a pointer to the first item in the list of free\r\n     * blocks.  The void cast is used to prevent compiler warnings. */\r\n    xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;\r\n    xStart.xBlockSize = ( size_t ) 0;\r\n\r\n    /* xEnd is used to mark the end of the list of free blocks. */\r\n    xEnd.xBlockSize = configADJUSTED_HEAP_SIZE;\r\n    xEnd.pxNextFreeBlock = NULL;\r\n\r\n    /* To start with there is a single free block that is sized to take up the\r\n     * entire heap space. */\r\n    pxFirstFreeBlock = ( void * ) pucAlignedHeap;\r\n    pxFirstFreeBlock->xBlockSize = configADJUSTED_HEAP_SIZE;\r\n    pxFirstFreeBlock->pxNextFreeBlock = &xEnd;\r\n}\r\n/*-----------------------------------------------------------*/\r\n", "/*\r\n * FreeRTOS Kernel V10.4.2\r\n * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy of\r\n * this software and associated documentation files (the \"Software\"), to deal in\r\n * the Software without restriction, including without limitation the rights to\r\n * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\r\n * the Software, and to permit persons to whom the Software is furnished to do so,\r\n * subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in all\r\n * copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\r\n * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\r\n * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\r\n * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\r\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n * https://www.FreeRTOS.org\r\n * https://github.com/FreeRTOS\r\n *\r\n */\r\n\r\n/*\r\n * A sample implementation of pvPortMalloc() and vPortFree() that combines\r\n * (coalescences) adjacent memory blocks as they are freed, and in so doing\r\n * limits memory fragmentation.\r\n *\r\n * See heap_1.c, heap_2.c and heap_3.c for alternative implementations, and the\r\n * memory management pages of https://www.FreeRTOS.org for more information.\r\n */\r\n#include <stdlib.h>\r\n\r\n/* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining\r\n * all the API functions to use the MPU wrappers.  That should only be done when\r\n * task.h is included from an application file. */\r\n#define MPU_WRAPPERS_INCLUDED_FROM_API_FILE\r\n\r\n#include \"FreeRTOS.h\"\r\n#include \"task.h\"\r\n\r\n#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE\r\n\r\n#if ( configSUPPORT_DYNAMIC_ALLOCATION == 0 )\r\n    #error This file must not be used if configSUPPORT_DYNAMIC_ALLOCATION is 0\r\n#endif\r\n\r\n/* Block sizes must not get too small. */\r\n#define heapMINIMUM_BLOCK_SIZE    ( ( size_t ) ( xHeapStructSize << 1 ) )\r\n\r\n/* Assumes 8bit bytes! */\r\n#define heapBITS_PER_BYTE         ( ( size_t ) 8 )\r\n\r\n/* Allocate the memory for the heap. */\r\n#if ( configAPPLICATION_ALLOCATED_HEAP == 1 )\r\n\r\n/* The application writer has already defined the array used for the RTOS\r\n* heap - probably so it can be placed in a special segment or address. */\r\n    extern uint8_t ucHeap[ configTOTAL_HEAP_SIZE ];\r\n#else\r\n    PRIVILEGED_DATA static uint8_t ucHeap[ configTOTAL_HEAP_SIZE ];\r\n#endif /* configAPPLICATION_ALLOCATED_HEAP */\r\n\r\n/* Define the linked list structure.  This is used to link free blocks in order\r\n * of their memory address. */\r\ntypedef struct A_BLOCK_LINK\r\n{\r\n    struct A_BLOCK_LINK * pxNextFreeBlock; /*<< The next free block in the list. */\r\n    size_t xBlockSize;                     /*<< The size of the free block. */\r\n} BlockLink_t;\r\n\r\n/*-----------------------------------------------------------*/\r\n\r\n/*\r\n * Inserts a block of memory that is being freed into the correct position in\r\n * the list of free memory blocks.  The block being freed will be merged with\r\n * the block in front it and/or the block behind it if the memory blocks are\r\n * adjacent to each other.\r\n */\r\nstatic void prvInsertBlockIntoFreeList( BlockLink_t * pxBlockToInsert ) PRIVILEGED_FUNCTION;\r\n\r\n/*\r\n * Called automatically to setup the required heap structures the first time\r\n * pvPortMalloc() is called.\r\n */\r\nstatic void prvHeapInit( void ) PRIVILEGED_FUNCTION;\r\n\r\n/*-----------------------------------------------------------*/\r\n\r\n/* The size of the structure placed at the beginning of each allocated memory\r\n * block must by correctly byte aligned. */\r\nstatic const size_t xHeapStructSize = ( sizeof( BlockLink_t ) + ( ( size_t ) ( portBYTE_ALIGNMENT - 1 ) ) ) & ~( ( size_t ) portBYTE_ALIGNMENT_MASK );\r\n\r\n/* Create a couple of list links to mark the start and end of the list. */\r\nPRIVILEGED_DATA static BlockLink_t xStart, * pxEnd = NULL;\r\n\r\n/* Keeps track of the number of calls to allocate and free memory as well as the\r\n * number of free bytes remaining, but says nothing about fragmentation. */\r\nPRIVILEGED_DATA static size_t xFreeBytesRemaining = 0U;\r\nPRIVILEGED_DATA static size_t xMinimumEverFreeBytesRemaining = 0U;\r\nPRIVILEGED_DATA static size_t xNumberOfSuccessfulAllocations = 0;\r\nPRIVILEGED_DATA static size_t xNumberOfSuccessfulFrees = 0;\r\n\r\n/* Gets set to the top bit of an size_t type.  When this bit in the xBlockSize\r\n * member of an BlockLink_t structure is set then the block belongs to the\r\n * application.  When the bit is free the block is still part of the free heap\r\n * space. */\r\nPRIVILEGED_DATA static size_t xBlockAllocatedBit = 0;\r\n\r\n/*-----------------------------------------------------------*/\r\n\r\nvoid * pvPortMalloc( size_t xWantedSize )\r\n{\r\n    BlockLink_t * pxBlock, * pxPreviousBlock, * pxNewBlockLink;\r\n    void * pvReturn = NULL;\r\n\r\n    vTaskSuspendAll();\r\n    {\r\n        /* If this is the first call to malloc then the heap will require\r\n         * initialisation to setup the list of free blocks. */\r\n        if( pxEnd == NULL )\r\n        {\r\n            prvHeapInit();\r\n        }\r\n        else\r\n        {\r\n            mtCOVERAGE_TEST_MARKER();\r\n        }\r\n\r\n        /* Check the requested block size is not so large that the top bit is\r\n         * set.  The top bit of the block size member of the BlockLink_t structure\r\n         * is used to determine who owns the block - the application or the\r\n         * kernel, so it must be free. */\r\n        if( ( xWantedSize & xBlockAllocatedBit ) == 0 )\r\n        {\r\n            /* The wanted size must be increased so it can contain a BlockLink_t\r\n             * structure in addition to the requested amount of bytes. */\r\n            if( ( xWantedSize > 0 ) && \r\n                ( ( xWantedSize + xHeapStructSize ) >  xWantedSize ) ) /* Overflow check */\r\n            {\r\n                xWantedSize += xHeapStructSize;\r\n\r\n                /* Ensure that blocks are always aligned. */\r\n                if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 )\r\n                {\r\n                    /* Byte alignment required. Check for overflow. */\r\n                    if( ( xWantedSize + ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) ) ) \r\n                            > xWantedSize )\r\n                    {\r\n                        xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );\r\n                        configASSERT( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) == 0 );\r\n                    }\r\n                    else\r\n                    {\r\n                        xWantedSize = 0;\r\n                    }  \r\n                }\r\n                else\r\n                {\r\n                    mtCOVERAGE_TEST_MARKER();\r\n                }\r\n            } \r\n            else \r\n            {\r\n                xWantedSize = 0;\r\n            }\r\n\r\n            if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )\r\n            {\r\n                /* Traverse the list from the start\t(lowest address) block until\r\n                 * one of adequate size is found. */\r\n                pxPreviousBlock = &xStart;\r\n                pxBlock = xStart.pxNextFreeBlock;\r\n\r\n                while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )\r\n                {\r\n                    pxPreviousBlock = pxBlock;\r\n                    pxBlock = pxBlock->pxNextFreeBlock;\r\n                }\r\n\r\n                /* If the end marker was reached then a block of adequate size\r\n                 * was not found. */\r\n                if( pxBlock != pxEnd )\r\n                {\r\n                    /* Return the memory space pointed to - jumping over the\r\n                     * BlockLink_t structure at its start. */\r\n                    pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );\r\n\r\n                    /* This block is being returned for use so must be taken out\r\n                     * of the list of free blocks. */\r\n                    pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;\r\n\r\n                    /* If the block is larger than required it can be split into\r\n                     * two. */\r\n                    if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )\r\n                    {\r\n                        /* This block is to be split into two.  Create a new\r\n                         * block following the number of bytes requested. The void\r\n                         * cast is used to prevent byte alignment warnings from the\r\n                         * compiler. */\r\n                        pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );\r\n                        configASSERT( ( ( ( size_t ) pxNewBlockLink ) & portBYTE_ALIGNMENT_MASK ) == 0 );\r\n\r\n                        /* Calculate the sizes of two blocks split from the\r\n                         * single block. */\r\n                        pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;\r\n                        pxBlock->xBlockSize = xWantedSize;\r\n\r\n                        /* Insert the new block into the list of free blocks. */\r\n                        prvInsertBlockIntoFreeList( pxNewBlockLink );\r\n                    }\r\n                    else\r\n                    {\r\n                        mtCOVERAGE_TEST_MARKER();\r\n                    }\r\n\r\n                    xFreeBytesRemaining -= pxBlock->xBlockSize;\r\n\r\n                    if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )\r\n                    {\r\n                        xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;\r\n                    }\r\n                    else\r\n                    {\r\n                        mtCOVERAGE_TEST_MARKER();\r\n                    }\r\n\r\n                    /* The block is being returned - it is allocated and owned\r\n                     * by the application and has no \"next\" block. */\r\n                    pxBlock->xBlockSize |= xBlockAllocatedBit;\r\n                    pxBlock->pxNextFreeBlock = NULL;\r\n                    xNumberOfSuccessfulAllocations++;\r\n                }\r\n                else\r\n                {\r\n                    mtCOVERAGE_TEST_MARKER();\r\n                }\r\n            }\r\n            else\r\n            {\r\n                mtCOVERAGE_TEST_MARKER();\r\n            }\r\n        }\r\n        else\r\n        {\r\n            mtCOVERAGE_TEST_MARKER();\r\n        }\r\n\r\n        traceMALLOC( pvReturn, xWantedSize );\r\n    }\r\n    ( void ) xTaskResumeAll();\r\n\r\n    #if ( configUSE_MALLOC_FAILED_HOOK == 1 )\r\n        {\r\n            if( pvReturn == NULL )\r\n            {\r\n                extern void vApplicationMallocFailedHook( void );\r\n                vApplicationMallocFailedHook();\r\n            }\r\n            else\r\n            {\r\n                mtCOVERAGE_TEST_MARKER();\r\n            }\r\n        }\r\n    #endif /* if ( configUSE_MALLOC_FAILED_HOOK == 1 ) */\r\n\r\n    configASSERT( ( ( ( size_t ) pvReturn ) & ( size_t ) portBYTE_ALIGNMENT_MASK ) == 0 );\r\n    return pvReturn;\r\n}\r\n/*-----------------------------------------------------------*/\r\n\r\nvoid vPortFree( void * pv )\r\n{\r\n    uint8_t * puc = ( uint8_t * ) pv;\r\n    BlockLink_t * pxLink;\r\n\r\n    if( pv != NULL )\r\n    {\r\n        /* The memory being freed will have an BlockLink_t structure immediately\r\n         * before it. */\r\n        puc -= xHeapStructSize;\r\n\r\n        /* This casting is to keep the compiler from issuing warnings. */\r\n        pxLink = ( void * ) puc;\r\n\r\n        /* Check the block is actually allocated. */\r\n        configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );\r\n        configASSERT( pxLink->pxNextFreeBlock == NULL );\r\n\r\n        if( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 )\r\n        {\r\n            if( pxLink->pxNextFreeBlock == NULL )\r\n            {\r\n                /* The block is being returned to the heap - it is no longer\r\n                 * allocated. */\r\n                pxLink->xBlockSize &= ~xBlockAllocatedBit;\r\n\r\n                vTaskSuspendAll();\r\n                {\r\n                    /* Add this block to the list of free blocks. */\r\n                    xFreeBytesRemaining += pxLink->xBlockSize;\r\n                    traceFREE( pv, pxLink->xBlockSize );\r\n                    prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );\r\n                    xNumberOfSuccessfulFrees++;\r\n                }\r\n                ( void ) xTaskResumeAll();\r\n            }\r\n            else\r\n            {\r\n                mtCOVERAGE_TEST_MARKER();\r\n            }\r\n        }\r\n        else\r\n        {\r\n            mtCOVERAGE_TEST_MARKER();\r\n        }\r\n    }\r\n}\r\n/*-----------------------------------------------------------*/\r\n\r\nsize_t xPortGetFreeHeapSize( void )\r\n{\r\n    return xFreeBytesRemaining;\r\n}\r\n/*-----------------------------------------------------------*/\r\n\r\nsize_t xPortGetMinimumEverFreeHeapSize( void )\r\n{\r\n    return xMinimumEverFreeBytesRemaining;\r\n}\r\n/*-----------------------------------------------------------*/\r\n\r\nvoid vPortInitialiseBlocks( void )\r\n{\r\n    /* This just exists to keep the linker quiet. */\r\n}\r\n/*-----------------------------------------------------------*/\r\n\r\nstatic void prvHeapInit( void ) /* PRIVILEGED_FUNCTION */\r\n{\r\n    BlockLink_t * pxFirstFreeBlock;\r\n    uint8_t * pucAlignedHeap;\r\n    size_t uxAddress;\r\n    size_t xTotalHeapSize = configTOTAL_HEAP_SIZE;\r\n\r\n    /* Ensure the heap starts on a correctly aligned boundary. */\r\n    uxAddress = ( size_t ) ucHeap;\r\n\r\n    if( ( uxAddress & portBYTE_ALIGNMENT_MASK ) != 0 )\r\n    {\r\n        uxAddress += ( portBYTE_ALIGNMENT - 1 );\r\n        uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );\r\n        xTotalHeapSize -= uxAddress - ( size_t ) ucHeap;\r\n    }\r\n\r\n    pucAlignedHeap = ( uint8_t * ) uxAddress;\r\n\r\n    /* xStart is used to hold a pointer to the first item in the list of free\r\n     * blocks.  The void cast is used to prevent compiler warnings. */\r\n    xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;\r\n    xStart.xBlockSize = ( size_t ) 0;\r\n\r\n    /* pxEnd is used to mark the end of the list of free blocks and is inserted\r\n     * at the end of the heap space. */\r\n    uxAddress = ( ( size_t ) pucAlignedHeap ) + xTotalHeapSize;\r\n    uxAddress -= xHeapStructSize;\r\n    uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );\r\n    pxEnd = ( void * ) uxAddress;\r\n    pxEnd->xBlockSize = 0;\r\n    pxEnd->pxNextFreeBlock = NULL;\r\n\r\n    /* To start with there is a single free block that is sized to take up the\r\n     * entire heap space, minus the space taken by pxEnd. */\r\n    pxFirstFreeBlock = ( void * ) pucAlignedHeap;\r\n    pxFirstFreeBlock->xBlockSize = uxAddress - ( size_t ) pxFirstFreeBlock;\r\n    pxFirstFreeBlock->pxNextFreeBlock = pxEnd;\r\n\r\n    /* Only one block exists - and it covers the entire usable heap space. */\r\n    xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;\r\n    xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;\r\n\r\n    /* Work out the position of the top bit in a size_t variable. */\r\n    xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );\r\n}\r\n/*-----------------------------------------------------------*/\r\n\r\nstatic void prvInsertBlockIntoFreeList( BlockLink_t * pxBlockToInsert ) /* PRIVILEGED_FUNCTION */\r\n{\r\n    BlockLink_t * pxIterator;\r\n    uint8_t * puc;\r\n\r\n    /* Iterate through the list until a block is found that has a higher address\r\n     * than the block being inserted. */\r\n    for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )\r\n    {\r\n        /* Nothing to do here, just iterate to the right position. */\r\n    }\r\n\r\n    /* Do the block being inserted, and the block it is being inserted after\r\n     * make a contiguous block of memory? */\r\n    puc = ( uint8_t * ) pxIterator;\r\n\r\n    if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )\r\n    {\r\n        pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;\r\n        pxBlockToInsert = pxIterator;\r\n    }\r\n    else\r\n    {\r\n        mtCOVERAGE_TEST_MARKER();\r\n    }\r\n\r\n    /* Do the block being inserted, and the block it is being inserted before\r\n     * make a contiguous block of memory? */\r\n    puc = ( uint8_t * ) pxBlockToInsert;\r\n\r\n    if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )\r\n    {\r\n        if( pxIterator->pxNextFreeBlock != pxEnd )\r\n        {\r\n            /* Form one big block from the two blocks. */\r\n            pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;\r\n            pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;\r\n        }\r\n        else\r\n        {\r\n            pxBlockToInsert->pxNextFreeBlock = pxEnd;\r\n        }\r\n    }\r\n    else\r\n    {\r\n        pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;\r\n    }\r\n\r\n    /* If the block being inserted plugged a gab, so was merged with the block\r\n     * before and the block after, then it's pxNextFreeBlock pointer will have\r\n     * already been set, and should not be set here as that would make it point\r\n     * to itself. */\r\n    if( pxIterator != pxBlockToInsert )\r\n    {\r\n        pxIterator->pxNextFreeBlock = pxBlockToInsert;\r\n    }\r\n    else\r\n    {\r\n        mtCOVERAGE_TEST_MARKER();\r\n    }\r\n}\r\n/*-----------------------------------------------------------*/\r\n\r\nvoid vPortGetHeapStats( HeapStats_t * pxHeapStats )\r\n{\r\n    BlockLink_t * pxBlock;\r\n    size_t xBlocks = 0, xMaxSize = 0, xMinSize = portMAX_DELAY; /* portMAX_DELAY used as a portable way of getting the maximum value. */\r\n\r\n    vTaskSuspendAll();\r\n    {\r\n        pxBlock = xStart.pxNextFreeBlock;\r\n\r\n        /* pxBlock will be NULL if the heap has not been initialised.  The heap\r\n         * is initialised automatically when the first allocation is made. */\r\n        if( pxBlock != NULL )\r\n        {\r\n            do\r\n            {\r\n                /* Increment the number of blocks and record the largest block seen\r\n                 * so far. */\r\n                xBlocks++;\r\n\r\n                if( pxBlock->xBlockSize > xMaxSize )\r\n                {\r\n                    xMaxSize = pxBlock->xBlockSize;\r\n                }\r\n\r\n                if( pxBlock->xBlockSize < xMinSize )\r\n                {\r\n                    xMinSize = pxBlock->xBlockSize;\r\n                }\r\n\r\n                /* Move to the next block in the chain until the last block is\r\n                 * reached. */\r\n                pxBlock = pxBlock->pxNextFreeBlock;\r\n            } while( pxBlock != pxEnd );\r\n        }\r\n    }\r\n    ( void ) xTaskResumeAll();\r\n\r\n    pxHeapStats->xSizeOfLargestFreeBlockInBytes = xMaxSize;\r\n    pxHeapStats->xSizeOfSmallestFreeBlockInBytes = xMinSize;\r\n    pxHeapStats->xNumberOfFreeBlocks = xBlocks;\r\n\r\n    taskENTER_CRITICAL();\r\n    {\r\n        pxHeapStats->xAvailableHeapSpaceInBytes = xFreeBytesRemaining;\r\n        pxHeapStats->xNumberOfSuccessfulAllocations = xNumberOfSuccessfulAllocations;\r\n        pxHeapStats->xNumberOfSuccessfulFrees = xNumberOfSuccessfulFrees;\r\n        pxHeapStats->xMinimumEverFreeBytesRemaining = xMinimumEverFreeBytesRemaining;\r\n    }\r\n    taskEXIT_CRITICAL();\r\n}\r\n", "/*\r\n * FreeRTOS Kernel V10.4.2\r\n * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy of\r\n * this software and associated documentation files (the \"Software\"), to deal in\r\n * the Software without restriction, including without limitation the rights to\r\n * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\r\n * the Software, and to permit persons to whom the Software is furnished to do so,\r\n * subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in all\r\n * copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\r\n * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\r\n * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\r\n * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\r\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n * https://www.FreeRTOS.org\r\n * https://github.com/FreeRTOS\r\n *\r\n */\r\n\r\n/*\r\n * A sample implementation of pvPortMalloc() that allows the heap to be defined\r\n * across multiple non-contigous blocks and combines (coalescences) adjacent\r\n * memory blocks as they are freed.\r\n *\r\n * See heap_1.c, heap_2.c, heap_3.c and heap_4.c for alternative\r\n * implementations, and the memory management pages of https://www.FreeRTOS.org\r\n * for more information.\r\n *\r\n * Usage notes:\r\n *\r\n * vPortDefineHeapRegions() ***must*** be called before pvPortMalloc().\r\n * pvPortMalloc() will be called if any task objects (tasks, queues, event\r\n * groups, etc.) are created, therefore vPortDefineHeapRegions() ***must*** be\r\n * called before any other objects are defined.\r\n *\r\n * vPortDefineHeapRegions() takes a single parameter.  The parameter is an array\r\n * of HeapRegion_t structures.  HeapRegion_t is defined in portable.h as\r\n *\r\n * typedef struct HeapRegion\r\n * {\r\n *\tuint8_t *pucStartAddress; << Start address of a block of memory that will be part of the heap.\r\n *\tsize_t xSizeInBytes;\t  << Size of the block of memory.\r\n * } HeapRegion_t;\r\n *\r\n * The array is terminated using a NULL zero sized region definition, and the\r\n * memory regions defined in the array ***must*** appear in address order from\r\n * low address to high address.  So the following is a valid example of how\r\n * to use the function.\r\n *\r\n * HeapRegion_t xHeapRegions[] =\r\n * {\r\n *  { ( uint8_t * ) 0x80000000UL, 0x10000 }, << Defines a block of 0x10000 bytes starting at address 0x80000000\r\n *  { ( uint8_t * ) 0x90000000UL, 0xa0000 }, << Defines a block of 0xa0000 bytes starting at address of 0x90000000\r\n *  { NULL, 0 }                << Terminates the array.\r\n * };\r\n *\r\n * vPortDefineHeapRegions( xHeapRegions ); << Pass the array into vPortDefineHeapRegions().\r\n *\r\n * Note 0x80000000 is the lower address so appears in the array first.\r\n *\r\n */\r\n#include <stdlib.h>\r\n\r\n/* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining\r\n * all the API functions to use the MPU wrappers.  That should only be done when\r\n * task.h is included from an application file. */\r\n#define MPU_WRAPPERS_INCLUDED_FROM_API_FILE\r\n\r\n#include \"FreeRTOS.h\"\r\n#include \"task.h\"\r\n\r\n#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE\r\n\r\n#if ( configSUPPORT_DYNAMIC_ALLOCATION == 0 )\r\n    #error This file must not be used if configSUPPORT_DYNAMIC_ALLOCATION is 0\r\n#endif\r\n\r\n/* Block sizes must not get too small. */\r\n#define heapMINIMUM_BLOCK_SIZE    ( ( size_t ) ( xHeapStructSize << 1 ) )\r\n\r\n/* Assumes 8bit bytes! */\r\n#define heapBITS_PER_BYTE         ( ( size_t ) 8 )\r\n\r\n/* Define the linked list structure.  This is used to link free blocks in order\r\n * of their memory address. */\r\ntypedef struct A_BLOCK_LINK\r\n{\r\n    struct A_BLOCK_LINK * pxNextFreeBlock; /*<< The next free block in the list. */\r\n    size_t xBlockSize;                     /*<< The size of the free block. */\r\n} BlockLink_t;\r\n\r\n/*-----------------------------------------------------------*/\r\n\r\n/*\r\n * Inserts a block of memory that is being freed into the correct position in\r\n * the list of free memory blocks.  The block being freed will be merged with\r\n * the block in front it and/or the block behind it if the memory blocks are\r\n * adjacent to each other.\r\n */\r\nstatic void prvInsertBlockIntoFreeList( BlockLink_t * pxBlockToInsert );\r\n\r\n/*-----------------------------------------------------------*/\r\n\r\n/* The size of the structure placed at the beginning of each allocated memory\r\n * block must by correctly byte aligned. */\r\nstatic const size_t xHeapStructSize = ( sizeof( BlockLink_t ) + ( ( size_t ) ( portBYTE_ALIGNMENT - 1 ) ) ) & ~( ( size_t ) portBYTE_ALIGNMENT_MASK );\r\n\r\n/* Create a couple of list links to mark the start and end of the list. */\r\nstatic BlockLink_t xStart, * pxEnd = NULL;\r\n\r\n/* Keeps track of the number of calls to allocate and free memory as well as the\r\n * number of free bytes remaining, but says nothing about fragmentation. */\r\nstatic size_t xFreeBytesRemaining = 0U;\r\nstatic size_t xMinimumEverFreeBytesRemaining = 0U;\r\nstatic size_t xNumberOfSuccessfulAllocations = 0;\r\nstatic size_t xNumberOfSuccessfulFrees = 0;\r\n\r\n/* Gets set to the top bit of an size_t type.  When this bit in the xBlockSize\r\n * member of an BlockLink_t structure is set then the block belongs to the\r\n * application.  When the bit is free the block is still part of the free heap\r\n * space. */\r\nstatic size_t xBlockAllocatedBit = 0;\r\n\r\n/*-----------------------------------------------------------*/\r\n\r\nvoid * pvPortMalloc( size_t xWantedSize )\r\n{\r\n    BlockLink_t * pxBlock, * pxPreviousBlock, * pxNewBlockLink;\r\n    void * pvReturn = NULL;\r\n\r\n    /* The heap must be initialised before the first call to\r\n     * prvPortMalloc(). */\r\n    configASSERT( pxEnd );\r\n\r\n    vTaskSuspendAll();\r\n    {\r\n        /* Check the requested block size is not so large that the top bit is\r\n         * set.  The top bit of the block size member of the BlockLink_t structure\r\n         * is used to determine who owns the block - the application or the\r\n         * kernel, so it must be free. */\r\n        if( ( xWantedSize & xBlockAllocatedBit ) == 0 )\r\n        {\r\n            /* The wanted size is increased so it can contain a BlockLink_t\r\n             * structure in addition to the requested amount of bytes. */\r\n            if( ( xWantedSize > 0 ) && \r\n                ( ( xWantedSize + xHeapStructSize ) >  xWantedSize ) ) /* Overflow check */\r\n            {\r\n                xWantedSize += xHeapStructSize;\r\n\r\n                /* Ensure that blocks are always aligned */\r\n                if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 )\r\n                {\r\n                    /* Byte alignment required. Check for overflow */\r\n                    if( ( xWantedSize + ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) ) ) >\r\n                         xWantedSize )\r\n                    {\r\n                        xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );\r\n                    } \r\n                    else \r\n                    {\r\n                        xWantedSize = 0;\r\n                    }\r\n                }\r\n                else\r\n                {\r\n                    mtCOVERAGE_TEST_MARKER();\r\n                }\r\n            }\r\n            else\r\n            {\r\n                xWantedSize = 0;\r\n            }\r\n\r\n            if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )\r\n            {\r\n                /* Traverse the list from the start\t(lowest address) block until\r\n                 * one of adequate size is found. */\r\n                pxPreviousBlock = &xStart;\r\n                pxBlock = xStart.pxNextFreeBlock;\r\n\r\n                while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )\r\n                {\r\n                    pxPreviousBlock = pxBlock;\r\n                    pxBlock = pxBlock->pxNextFreeBlock;\r\n                }\r\n\r\n                /* If the end marker was reached then a block of adequate size\r\n                 * was not found. */\r\n                if( pxBlock != pxEnd )\r\n                {\r\n                    /* Return the memory space pointed to - jumping over the\r\n                     * BlockLink_t structure at its start. */\r\n                    pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );\r\n\r\n                    /* This block is being returned for use so must be taken out\r\n                     * of the list of free blocks. */\r\n                    pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;\r\n\r\n                    /* If the block is larger than required it can be split into\r\n                     * two. */\r\n                    if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )\r\n                    {\r\n                        /* This block is to be split into two.  Create a new\r\n                         * block following the number of bytes requested. The void\r\n                         * cast is used to prevent byte alignment warnings from the\r\n                         * compiler. */\r\n                        pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );\r\n\r\n                        /* Calculate the sizes of two blocks split from the\r\n                         * single block. */\r\n                        pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;\r\n                        pxBlock->xBlockSize = xWantedSize;\r\n\r\n                        /* Insert the new block into the list of free blocks. */\r\n                        prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );\r\n                    }\r\n                    else\r\n                    {\r\n                        mtCOVERAGE_TEST_MARKER();\r\n                    }\r\n\r\n                    xFreeBytesRemaining -= pxBlock->xBlockSize;\r\n\r\n                    if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )\r\n                    {\r\n                        xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;\r\n                    }\r\n                    else\r\n                    {\r\n                        mtCOVERAGE_TEST_MARKER();\r\n                    }\r\n\r\n                    /* The block is being returned - it is allocated and owned\r\n                     * by the application and has no \"next\" block. */\r\n                    pxBlock->xBlockSize |= xBlockAllocatedBit;\r\n                    pxBlock->pxNextFreeBlock = NULL;\r\n                    xNumberOfSuccessfulAllocations++;\r\n                }\r\n                else\r\n                {\r\n                    mtCOVERAGE_TEST_MARKER();\r\n                }\r\n            }\r\n            else\r\n            {\r\n                mtCOVERAGE_TEST_MARKER();\r\n            }\r\n        }\r\n        else\r\n        {\r\n            mtCOVERAGE_TEST_MARKER();\r\n        }\r\n\r\n        traceMALLOC( pvReturn, xWantedSize );\r\n    }\r\n    ( void ) xTaskResumeAll();\r\n\r\n    #if ( configUSE_MALLOC_FAILED_HOOK == 1 )\r\n        {\r\n            if( pvReturn == NULL )\r\n            {\r\n                extern void vApplicationMallocFailedHook( void );\r\n                vApplicationMallocFailedHook();\r\n            }\r\n            else\r\n            {\r\n                mtCOVERAGE_TEST_MARKER();\r\n            }\r\n        }\r\n    #endif /* if ( configUSE_MALLOC_FAILED_HOOK == 1 ) */\r\n\r\n    return pvReturn;\r\n}\r\n/*-----------------------------------------------------------*/\r\n\r\nvoid vPortFree( void * pv )\r\n{\r\n    uint8_t * puc = ( uint8_t * ) pv;\r\n    BlockLink_t * pxLink;\r\n\r\n    if( pv != NULL )\r\n    {\r\n        /* The memory being freed will have an BlockLink_t structure immediately\r\n         * before it. */\r\n        puc -= xHeapStructSize;\r\n\r\n        /* This casting is to keep the compiler from issuing warnings. */\r\n        pxLink = ( void * ) puc;\r\n\r\n        /* Check the block is actually allocated. */\r\n        configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );\r\n        configASSERT( pxLink->pxNextFreeBlock == NULL );\r\n\r\n        if( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 )\r\n        {\r\n            if( pxLink->pxNextFreeBlock == NULL )\r\n            {\r\n                /* The block is being returned to the heap - it is no longer\r\n                 * allocated. */\r\n                pxLink->xBlockSize &= ~xBlockAllocatedBit;\r\n\r\n                vTaskSuspendAll();\r\n                {\r\n                    /* Add this block to the list of free blocks. */\r\n                    xFreeBytesRemaining += pxLink->xBlockSize;\r\n                    traceFREE( pv, pxLink->xBlockSize );\r\n                    prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );\r\n                    xNumberOfSuccessfulFrees++;\r\n                }\r\n                ( void ) xTaskResumeAll();\r\n            }\r\n            else\r\n            {\r\n                mtCOVERAGE_TEST_MARKER();\r\n            }\r\n        }\r\n        else\r\n        {\r\n            mtCOVERAGE_TEST_MARKER();\r\n        }\r\n    }\r\n}\r\n/*-----------------------------------------------------------*/\r\n\r\nsize_t xPortGetFreeHeapSize( void )\r\n{\r\n    return xFreeBytesRemaining;\r\n}\r\n/*-----------------------------------------------------------*/\r\n\r\nsize_t xPortGetMinimumEverFreeHeapSize( void )\r\n{\r\n    return xMinimumEverFreeBytesRemaining;\r\n}\r\n/*-----------------------------------------------------------*/\r\n\r\nstatic void prvInsertBlockIntoFreeList( BlockLink_t * pxBlockToInsert )\r\n{\r\n    BlockLink_t * pxIterator;\r\n    uint8_t * puc;\r\n\r\n    /* Iterate through the list until a block is found that has a higher address\r\n     * than the block being inserted. */\r\n    for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )\r\n    {\r\n        /* Nothing to do here, just iterate to the right position. */\r\n    }\r\n\r\n    /* Do the block being inserted, and the block it is being inserted after\r\n     * make a contiguous block of memory? */\r\n    puc = ( uint8_t * ) pxIterator;\r\n\r\n    if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )\r\n    {\r\n        pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;\r\n        pxBlockToInsert = pxIterator;\r\n    }\r\n    else\r\n    {\r\n        mtCOVERAGE_TEST_MARKER();\r\n    }\r\n\r\n    /* Do the block being inserted, and the block it is being inserted before\r\n     * make a contiguous block of memory? */\r\n    puc = ( uint8_t * ) pxBlockToInsert;\r\n\r\n    if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )\r\n    {\r\n        if( pxIterator->pxNextFreeBlock != pxEnd )\r\n        {\r\n            /* Form one big block from the two blocks. */\r\n            pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;\r\n            pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;\r\n        }\r\n        else\r\n        {\r\n            pxBlockToInsert->pxNextFreeBlock = pxEnd;\r\n        }\r\n    }\r\n    else\r\n    {\r\n        pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;\r\n    }\r\n\r\n    /* If the block being inserted plugged a gab, so was merged with the block\r\n     * before and the block after, then it's pxNextFreeBlock pointer will have\r\n     * already been set, and should not be set here as that would make it point\r\n     * to itself. */\r\n    if( pxIterator != pxBlockToInsert )\r\n    {\r\n        pxIterator->pxNextFreeBlock = pxBlockToInsert;\r\n    }\r\n    else\r\n    {\r\n        mtCOVERAGE_TEST_MARKER();\r\n    }\r\n}\r\n/*-----------------------------------------------------------*/\r\n\r\nvoid vPortDefineHeapRegions( const HeapRegion_t * const pxHeapRegions )\r\n{\r\n    BlockLink_t * pxFirstFreeBlockInRegion = NULL, * pxPreviousFreeBlock;\r\n    size_t xAlignedHeap;\r\n    size_t xTotalRegionSize, xTotalHeapSize = 0;\r\n    BaseType_t xDefinedRegions = 0;\r\n    size_t xAddress;\r\n    const HeapRegion_t * pxHeapRegion;\r\n\r\n    /* Can only call once! */\r\n    configASSERT( pxEnd == NULL );\r\n\r\n    pxHeapRegion = &( pxHeapRegions[ xDefinedRegions ] );\r\n\r\n    while( pxHeapRegion->xSizeInBytes > 0 )\r\n    {\r\n        xTotalRegionSize = pxHeapRegion->xSizeInBytes;\r\n\r\n        /* Ensure the heap region starts on a correctly aligned boundary. */\r\n        xAddress = ( size_t ) pxHeapRegion->pucStartAddress;\r\n\r\n        if( ( xAddress & portBYTE_ALIGNMENT_MASK ) != 0 )\r\n        {\r\n            xAddress += ( portBYTE_ALIGNMENT - 1 );\r\n            xAddress &= ~portBYTE_ALIGNMENT_MASK;\r\n\r\n            /* Adjust the size for the bytes lost to alignment. */\r\n            xTotalRegionSize -= xAddress - ( size_t ) pxHeapRegion->pucStartAddress;\r\n        }\r\n\r\n        xAlignedHeap = xAddress;\r\n\r\n        /* Set xStart if it has not already been set. */\r\n        if( xDefinedRegions == 0 )\r\n        {\r\n            /* xStart is used to hold a pointer to the first item in the list of\r\n             *  free blocks.  The void cast is used to prevent compiler warnings. */\r\n            xStart.pxNextFreeBlock = ( BlockLink_t * ) xAlignedHeap;\r\n            xStart.xBlockSize = ( size_t ) 0;\r\n        }\r\n        else\r\n        {\r\n            /* Should only get here if one region has already been added to the\r\n             * heap. */\r\n            configASSERT( pxEnd != NULL );\r\n\r\n            /* Check blocks are passed in with increasing start addresses. */\r\n            configASSERT( xAddress > ( size_t ) pxEnd );\r\n        }\r\n\r\n        /* Remember the location of the end marker in the previous region, if\r\n         * any. */\r\n        pxPreviousFreeBlock = pxEnd;\r\n\r\n        /* pxEnd is used to mark the end of the list of free blocks and is\r\n         * inserted at the end of the region space. */\r\n        xAddress = xAlignedHeap + xTotalRegionSize;\r\n        xAddress -= xHeapStructSize;\r\n        xAddress &= ~portBYTE_ALIGNMENT_MASK;\r\n        pxEnd = ( BlockLink_t * ) xAddress;\r\n        pxEnd->xBlockSize = 0;\r\n        pxEnd->pxNextFreeBlock = NULL;\r\n\r\n        /* To start with there is a single free block in this region that is\r\n         * sized to take up the entire heap region minus the space taken by the\r\n         * free block structure. */\r\n        pxFirstFreeBlockInRegion = ( BlockLink_t * ) xAlignedHeap;\r\n        pxFirstFreeBlockInRegion->xBlockSize = xAddress - ( size_t ) pxFirstFreeBlockInRegion;\r\n        pxFirstFreeBlockInRegion->pxNextFreeBlock = pxEnd;\r\n\r\n        /* If this is not the first region that makes up the entire heap space\r\n         * then link the previous region to this region. */\r\n        if( pxPreviousFreeBlock != NULL )\r\n        {\r\n            pxPreviousFreeBlock->pxNextFreeBlock = pxFirstFreeBlockInRegion;\r\n        }\r\n\r\n        xTotalHeapSize += pxFirstFreeBlockInRegion->xBlockSize;\r\n\r\n        /* Move onto the next HeapRegion_t structure. */\r\n        xDefinedRegions++;\r\n        pxHeapRegion = &( pxHeapRegions[ xDefinedRegions ] );\r\n    }\r\n\r\n    xMinimumEverFreeBytesRemaining = xTotalHeapSize;\r\n    xFreeBytesRemaining = xTotalHeapSize;\r\n\r\n    /* Check something was actually defined before it is accessed. */\r\n    configASSERT( xTotalHeapSize );\r\n\r\n    /* Work out the position of the top bit in a size_t variable. */\r\n    xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );\r\n}\r\n/*-----------------------------------------------------------*/\r\n\r\nvoid vPortGetHeapStats( HeapStats_t * pxHeapStats )\r\n{\r\n    BlockLink_t * pxBlock;\r\n    size_t xBlocks = 0, xMaxSize = 0, xMinSize = portMAX_DELAY; /* portMAX_DELAY used as a portable way of getting the maximum value. */\r\n\r\n    vTaskSuspendAll();\r\n    {\r\n        pxBlock = xStart.pxNextFreeBlock;\r\n\r\n        /* pxBlock will be NULL if the heap has not been initialised.  The heap\r\n         * is initialised automatically when the first allocation is made. */\r\n        if( pxBlock != NULL )\r\n        {\r\n            do\r\n            {\r\n                /* Increment the number of blocks and record the largest block seen\r\n                 * so far. */\r\n                xBlocks++;\r\n\r\n                if( pxBlock->xBlockSize > xMaxSize )\r\n                {\r\n                    xMaxSize = pxBlock->xBlockSize;\r\n                }\r\n\r\n                /* Heap five will have a zero sized block at the end of each\r\n                 * each region - the block is only used to link to the next\r\n                 * heap region so it not a real block. */\r\n                if( pxBlock->xBlockSize != 0 )\r\n                {\r\n                    if( pxBlock->xBlockSize < xMinSize )\r\n                    {\r\n                        xMinSize = pxBlock->xBlockSize;\r\n                    }\r\n                }\r\n\r\n                /* Move to the next block in the chain until the last block is\r\n                 * reached. */\r\n                pxBlock = pxBlock->pxNextFreeBlock;\r\n            } while( pxBlock != pxEnd );\r\n        }\r\n    }\r\n    ( void ) xTaskResumeAll();\r\n\r\n    pxHeapStats->xSizeOfLargestFreeBlockInBytes = xMaxSize;\r\n    pxHeapStats->xSizeOfSmallestFreeBlockInBytes = xMinSize;\r\n    pxHeapStats->xNumberOfFreeBlocks = xBlocks;\r\n\r\n    taskENTER_CRITICAL();\r\n    {\r\n        pxHeapStats->xAvailableHeapSpaceInBytes = xFreeBytesRemaining;\r\n        pxHeapStats->xNumberOfSuccessfulAllocations = xNumberOfSuccessfulAllocations;\r\n        pxHeapStats->xNumberOfSuccessfulFrees = xNumberOfSuccessfulFrees;\r\n        pxHeapStats->xMinimumEverFreeBytesRemaining = xMinimumEverFreeBytesRemaining;\r\n    }\r\n    taskEXIT_CRITICAL();\r\n}\r\n"], "filenames": ["portable/MemMang/heap_1.c", "portable/MemMang/heap_2.c", "portable/MemMang/heap_4.c", "portable/MemMang/heap_5.c"], "buggy_code_start_loc": [25, 25, 139, 25], "buggy_code_end_loc": [96, 150, 178, 189], "fixing_code_start_loc": [24, 24, 139, 24], "fixing_code_end_loc": [103, 160, 186, 196], "type": "CWE-119", "message": "The kernel in Amazon Web Services FreeRTOS before 10.4.3 has insufficient bounds checking during management of heap memory.", "other": {"cve": {"id": "CVE-2021-32020", "sourceIdentifier": "cve@mitre.org", "published": "2021-05-03T22:15:08.697", "lastModified": "2021-05-12T13:23:18.233", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The kernel in Amazon Web Services FreeRTOS before 10.4.3 has insufficient bounds checking during management of heap memory."}, {"lang": "es", "value": "El kernel en Amazon Web Services FreeRTOS versiones anteriores a 10.4.3, presenta una comprobaci\u00f3n insuficiente de l\u00edmites durante la administraci\u00f3n de la memoria de la pila"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:amazon:freertos:*:*:*:*:*:*:*:*", "versionEndExcluding": "10.4.3", "matchCriteriaId": "6F5312AF-71BB-4289-BAB4-CE5931098CCD"}]}]}], "references": [{"url": "https://github.com/FreeRTOS/FreeRTOS-Kernel/commit/c7a9a01c94987082b223d3e59969ede64363da63", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/FreeRTOS/FreeRTOS-Kernel/commit/c7a9a01c94987082b223d3e59969ede64363da63"}}