{"buggy_code": ["<?php\n/*\n * diag_ping.php\n *\n * part of pfSense (https://www.pfsense.org)\n * Copyright (c) 2004-2013 BSD Perimeter\n * Copyright (c) 2013-2016 Electric Sheep Fencing\n * Copyright (c) 2014-2020 Rubicon Communications, LLC (Netgate)\n * Copyright (c) 2003-2005 Bob Zoller (bob@kludgebox.com)\n * All rights reserved.\n *\n * originally based on m0n0wall (http://m0n0.ch/wall)\n * Copyright (c) 2003-2004 Manuel Kasper <mk@neon1.net>.\n * All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n##|+PRIV\n##|*IDENT=page-diagnostics-ping\n##|*NAME=Diagnostics: Ping\n##|*DESCR=Allow access to the 'Diagnostics: Ping' page.\n##|*MATCH=diag_ping.php*\n##|-PRIV\n\n$allowautocomplete = true;\n$pgtitle = array(gettext(\"Diagnostics\"), gettext(\"Ping\"));\nrequire_once(\"guiconfig.inc\");\n\ndefine('MAX_COUNT', 10);\ndefine('DEFAULT_COUNT', 3);\ndefine('MAX_WAIT', 10);\ndefine('DEFAULT_WAIT', 1);\n$do_ping = false;\n$host = '';\n$count = DEFAULT_COUNT;\n$wait = DEFAULT_WAIT;\n\nif ($_POST || $_REQUEST['host']) {\n\tunset($input_errors);\n\tunset($do_ping);\n\n\t/* input validation */\n\t$reqdfields = explode(\" \", \"host count\");\n\t$reqdfieldsn = array(gettext(\"Host\"), gettext(\"Count\"));\n\tdo_input_validation($_REQUEST, $reqdfields, $reqdfieldsn, $input_errors);\n\tif (($_REQUEST['count'] < 1) || ($_REQUEST['count'] > MAX_COUNT) || (!is_numericint($_REQUEST['wait']))) {\n\t\t$input_errors[] = sprintf(gettext(\"Count must be between 1 and %s\"), MAX_COUNT);\n\t}\t\n\tif (($_REQUEST['wait'] < 1) || ($_REQUEST['wait'] > MAX_WAIT) || (!is_numericint($_REQUEST['wait']))) {\n\t\t$input_errors[] = sprintf(gettext(\"Wait must be between 1 and %s\"), MAX_WAIT);\n\t}\t\n\t$host = trim($_REQUEST['host']);\n\t$ipproto = $_REQUEST['ipproto'];\n\tif (($ipproto == \"ipv4\") && is_ipaddrv6($host)) {\n\t\t$input_errors[] = gettext(\"When using IPv4, the target host must be an IPv4 address or hostname.\");\n\t}\n\tif (($ipproto == \"ipv6\") && is_ipaddrv4($host)) {\n\t\t$input_errors[] = gettext(\"When using IPv6, the target host must be an IPv6 address or hostname.\");\n\t}\n\n\tif (!$input_errors) {\n\t\tif ($_POST) {\n\t\t\t$do_ping = true;\n\t\t}\n\t\tif (isset($_REQUEST['sourceip'])) {\n\t\t\t$sourceip = $_REQUEST['sourceip'];\n\t\t}\n\t\t$count = (empty($_REQUEST['count'])) ? DEFAULT_WAIT : $_REQUEST['count'];\n\t\t$wait = (empty($_REQUEST['wait'])) ? DEFAULT_WAIT : $_REQUEST['wait'];\n\t}\n}\n\nif ($do_ping) {\n?>\n\t<script type=\"text/javascript\">\n\t//<![CDATA[\n\twindow.onload=function() {\n\t\tdocument.getElementById(\"pingCaptured\").wrap='off';\n\t}\n\t//]]>\n\t</script>\n<?php\n\t$ifscope = '';\n\t$command = \"/sbin/ping\";\n\tif ($ipproto == \"ipv6\") {\n\t\t$command .= \"6\";\n\t\t$ifaddr = is_ipaddr($sourceip) ? $sourceip : get_interface_ipv6($sourceip);\n\t\tif (is_linklocal($ifaddr)) {\n\t\t\t$ifscope = get_ll_scope($ifaddr);\n\t\t}\n\t} else {\n\t\t$ifaddr = is_ipaddr($sourceip) ? $sourceip : get_interface_ip($sourceip);\n\t}\n\n\tif ($ifaddr && (is_ipaddr($host) || is_hostname($host))) {\n\t\t$srcip = \"-S\" . escapeshellarg($ifaddr);\n\t\tif (is_linklocal($host) && !strstr($host, \"%\") && !empty($ifscope)) {\n\t\t\t$host .= \"%{$ifscope}\";\n\t\t}\n\t}\n\n\t$cmd = \"{$command} {$srcip} -c\" . escapeshellarg($count) . \" -i\" . escapeshellarg($wait) . \" \" . escapeshellarg($host);\n\t//echo \"Ping command: {$cmd}\\n\";\n\t$result = shell_exec($cmd);\n\n\tif (empty($result)) {\n\t\t$input_errors[] = sprintf(gettext('Host \"%s\" did not respond or could not be resolved.'), $host);\n\t}\n\n}\n\ninclude('head.inc');\n\nif ($input_errors) {\n\tprint_input_errors($input_errors);\n}\n\n$form = new Form(false);\n\n$section = new Form_Section('Ping');\n\n$section->addInput(new Form_Input(\n\t'host',\n\t'*Hostname',\n\t'text',\n\t$host,\n\t['placeholder' => 'Hostname to ping']\n));\n\n$section->addInput(new Form_Select(\n\t'ipproto',\n\t'*IP Protocol',\n\t$ipproto,\n\t['ipv4' => 'IPv4', 'ipv6' => 'IPv6']\n));\n\n$section->addInput(new Form_Select(\n\t'sourceip',\n\t'*Source address',\n\t$sourceip,\n\tarray('' => gettext('Automatically selected (default)')) + get_possible_traffic_source_addresses(true)\n))->setHelp('Select source address for the ping.');\n\n$section->addInput(new Form_Select(\n\t'count',\n\t'Maximum number of pings',\n\t$count,\n\tarray_combine(range(1, MAX_COUNT), range(1, MAX_COUNT))\n))->setHelp('Select the maximum number of pings.');\n\n$section->addInput(new Form_Select(\n\t'wait',\n\t'Seconds between pings',\n\t$wait,\n\tarray_combine(range(1, MAX_WAIT), range(1, MAX_WAIT))\n))->setHelp('Select the number of seconds to wait between pings.');\n\n$form->add($section);\n\n$form->addGlobal(new Form_Button(\n\t'Submit',\n\t'Ping',\n\tnull,\n\t'fa-rss'\n))->addClass('btn-primary');\n\nprint $form;\n\nif ($do_ping && !empty($result) && !$input_errors) {\n?>\n\t<div class=\"panel panel-default\">\n\t\t<div class=\"panel-heading\">\n\t\t\t<h2 class=\"panel-title\"><?=gettext('Results')?></h2>\n\t\t</div>\n\n\t\t<div class=\"panel-body\">\n\t\t\t<pre><?= $result ?></pre>\n\t\t</div>\n\t</div>\n<?php\n}\n\ninclude('foot.inc');\n", "<?php\n/*\n * diag_traceroute.php\n *\n * part of pfSense (https://www.pfsense.org)\n * Copyright (c) 2004-2013 BSD Perimeter\n * Copyright (c) 2013-2016 Electric Sheep Fencing\n * Copyright (c) 2014-2020 Rubicon Communications, LLC (Netgate)\n * Copyright (c) 2005 Paul Taylor (paultaylor@winndixie.com)\n * All rights reserved.\n *\n * originally based on m0n0wall (http://m0n0.ch/wall)\n * Copyright (c) 2003-2004 Manuel Kasper <mk@neon1.net>.\n * All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n##|+PRIV\n##|*IDENT=page-diagnostics-traceroute\n##|*NAME=Diagnostics: Traceroute\n##|*DESCR=Allow access to the 'Diagnostics: Traceroute' page.\n##|*MATCH=diag_traceroute.php*\n##|-PRIV\n\nrequire_once(\"guiconfig.inc\");\n\n$allowautocomplete = true;\n$pgtitle = array(gettext(\"Diagnostics\"), gettext(\"Traceroute\"));\ninclude(\"head.inc\");\n\n/* Max TTL of both traceroute and traceroute6 is 255, but in practice more than\n   64 hops would most likely time out in the GUI. If a user requires a\n   traceroute that long, they can use the CLI. */\ndefine('MAX_TTL', 64);\ndefine('DEFAULT_TTL', 18);\n\n// Set defaults in case they are not supplied.\n$do_traceroute = false;\n$host = '';\n$ttl = DEFAULT_TTL;\n$ipproto = 'ipv4';\n$sourceip = 'any';\n\nif ($_POST || $_REQUEST['host']) {\n\tunset($input_errors);\n\n\t/* input validation */\n\t$reqdfields = explode(\" \", \"host ttl\");\n\t$reqdfieldsn = array(gettext(\"Host\"), gettext(\"ttl\"));\n\tdo_input_validation($_REQUEST, $reqdfields, $reqdfieldsn, $input_errors);\n\n\tif (($_REQUEST['ttl'] < 1) || ($_REQUEST['ttl'] > MAX_TTL)) {\n\t\t$input_errors[] = sprintf(gettext(\"Maximum number of hops must be between 1 and %s\"), MAX_TTL);\n\t}\n\t$host = trim($_REQUEST['host']);\n\t$ipproto = $_REQUEST['ipproto'];\n\tif (($ipproto == \"ipv4\") && is_ipaddrv6($host)) {\n\t\t$input_errors[] = gettext(\"When using IPv4, the target host must be an IPv4 address or hostname.\");\n\t}\n\tif (($ipproto == \"ipv6\") && is_ipaddrv4($host)) {\n\t\t$input_errors[] = gettext(\"When using IPv6, the target host must be an IPv6 address or hostname.\");\n\t}\n\n\t$sourceip = $_REQUEST['sourceip'];\n\t$ttl = $_REQUEST['ttl'];\n\t$resolve = $_REQUEST['resolve'];\n\t$useicmp = $_REQUEST['useicmp'];\n\n\tif ($_POST && !$input_errors) {\n\t\t$do_traceroute = true;\n\t}\n\n} else {\n\t$resolve = false;\n\t$useicmp = false;\n}\n\nif ($input_errors) {\n\tprint_input_errors($input_errors);\n}\n\n/* Do the traceroute and show any error */\nif ($do_traceroute) {\n\t$useicmpparam = isset($useicmp) ? \"-I\" : \"\";\n\t$n = isset($resolve) ? \"\" : \"-n\";\n\n\t$command = \"/usr/sbin/traceroute\";\n\tif ($ipproto == \"ipv6\") {\n\t\t$command .= \"6\";\n\t\tif (empty($n)) {\n\t\t\t$n = \"-l\";\n\t\t}\n\t\t$ifaddr = is_ipaddr($sourceip) ? $sourceip : get_interface_ipv6($sourceip);\n\t} else {\n\t\t$ifaddr = is_ipaddr($sourceip) ? $sourceip : get_interface_ip($sourceip);\n\t}\n\n\tif ($ifaddr && (is_ipaddr($host) || is_hostname($host))) {\n\t\t$srcip = \"-s \" . escapeshellarg($ifaddr);\n\t}\n\n\t$cmd = \"{$command} {$n} {$srcip} -w 2 {$useicmpparam} -m \" . escapeshellarg($ttl) . \" \" . escapeshellarg($host);\n\t$result = shell_exec($cmd);\n\n\tif (!$result) {\n\t\tprint_info_box(sprintf(gettext('Error: %s could not be traced/resolved'), htmlspecialchars($host)));\n\t}\n}\n\n$form = new Form(false);\n\n$section = new Form_Section('Traceroute');\n\n$section->addInput(new Form_Input(\n\t'host',\n\t'*Hostname',\n\t'text',\n\t$host,\n\t['placeholder' => 'Hostname to trace.']\n));\n\n$section->addInput(new Form_Select(\n\t'ipproto',\n\t'*IP Protocol',\n\t$ipproto,\n\tarray('ipv4' => 'IPv4', 'ipv6' => 'IPv6')\n))->setHelp('Select the protocol to use.');\n\n$section->addInput(new Form_Select(\n\t'sourceip',\n\t'*Source Address',\n\t$sourceip,\n\tarray('any' => gettext('Any')) + get_possible_traffic_source_addresses(true)\n))->setHelp('Select source address for the trace.');\n\n$section->addInput(new Form_Select(\n\t'ttl',\n\t'Maximum number of hops',\n\t$ttl,\n\tarray_combine(range(1, MAX_TTL), range(1, MAX_TTL))\n))->setHelp('Select the maximum number of network hops to trace.');\n\n$section->addInput(new Form_Checkbox(\n\t'resolve',\n\t'Reverse Address Lookup',\n\t'',\n\t$resolve\n))->setHelp('When checked, traceroute will attempt to perform a PTR lookup to locate hostnames for hops along the path. This will slow down the process as it has to wait for DNS replies.');\n\n$section->addInput(new Form_Checkbox(\n\t'useicmp',\n\tgettext(\"Use ICMP\"),\n\t'',\n\t$useicmp\n))->setHelp('By default, traceroute uses UDP but that may be blocked by some routers. Check this box to use ICMP instead, which may succeed. ');\n\n$form->add($section);\n\n$form->addGlobal(new Form_Button(\n\t'Submit',\n\t'Traceroute',\n\tnull,\n\t'fa-rss'\n))->addClass('btn-primary');\n\nprint $form;\n\n/* Show the traceroute results */\nif ($do_traceroute && $result) {\n?>\n\t<div class=\"panel panel-default\">\n\t\t<div class=\"panel-heading\"><h2 class=\"panel-title\"><?=gettext('Results')?></h2></div>\n\t\t<div class=\"panel-body\">\n<?php\n\tprint('<pre>' . $result . '</pre>');\n?>\n\t\t</div>\n\t</div>\n<?php\n}\n\ninclude(\"foot.inc\");\n?>\n"], "fixing_code": ["<?php\n/*\n * diag_ping.php\n *\n * part of pfSense (https://www.pfsense.org)\n * Copyright (c) 2004-2013 BSD Perimeter\n * Copyright (c) 2013-2016 Electric Sheep Fencing\n * Copyright (c) 2014-2020 Rubicon Communications, LLC (Netgate)\n * Copyright (c) 2003-2005 Bob Zoller (bob@kludgebox.com)\n * All rights reserved.\n *\n * originally based on m0n0wall (http://m0n0.ch/wall)\n * Copyright (c) 2003-2004 Manuel Kasper <mk@neon1.net>.\n * All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n##|+PRIV\n##|*IDENT=page-diagnostics-ping\n##|*NAME=Diagnostics: Ping\n##|*DESCR=Allow access to the 'Diagnostics: Ping' page.\n##|*MATCH=diag_ping.php*\n##|-PRIV\n\n$allowautocomplete = true;\n$pgtitle = array(gettext(\"Diagnostics\"), gettext(\"Ping\"));\nrequire_once(\"guiconfig.inc\");\n\ndefine('MAX_COUNT', 10);\ndefine('DEFAULT_COUNT', 3);\ndefine('MAX_WAIT', 10);\ndefine('DEFAULT_WAIT', 1);\n$do_ping = false;\n$host = '';\n$count = DEFAULT_COUNT;\n$wait = DEFAULT_WAIT;\n\nif ($_POST || $_REQUEST['host']) {\n\tunset($input_errors);\n\tunset($do_ping);\n\n\t/* input validation */\n\t$reqdfields = explode(\" \", \"host count\");\n\t$reqdfieldsn = array(gettext(\"Host\"), gettext(\"Count\"));\n\tdo_input_validation($_REQUEST, $reqdfields, $reqdfieldsn, $input_errors);\n\tif (($_REQUEST['count'] < 1) || ($_REQUEST['count'] > MAX_COUNT) || (!is_numericint($_REQUEST['wait']))) {\n\t\t$input_errors[] = sprintf(gettext(\"Count must be between 1 and %s\"), MAX_COUNT);\n\t}\t\n\tif (($_REQUEST['wait'] < 1) || ($_REQUEST['wait'] > MAX_WAIT) || (!is_numericint($_REQUEST['wait']))) {\n\t\t$input_errors[] = sprintf(gettext(\"Wait must be between 1 and %s\"), MAX_WAIT);\n\t}\t\n\t$host = trim($_REQUEST['host']);\n\t$ipproto = $_REQUEST['ipproto'];\n\tif (($ipproto == \"ipv4\") && is_ipaddrv6($host)) {\n\t\t$input_errors[] = gettext(\"When using IPv4, the target host must be an IPv4 address or hostname.\");\n\t}\n\tif (($ipproto == \"ipv6\") && is_ipaddrv4($host)) {\n\t\t$input_errors[] = gettext(\"When using IPv6, the target host must be an IPv6 address or hostname.\");\n\t}\n\tif (!is_ipaddr($host) && !is_hostname($host)) {\n\t\t$input_errors[] = gettext(\"Hostname must be a valid hostname or IP address.\");\n\t}\n\n\tif (!$input_errors) {\n\t\tif ($_POST) {\n\t\t\t$do_ping = true;\n\t\t}\n\t\tif (isset($_REQUEST['sourceip'])) {\n\t\t\t$sourceip = $_REQUEST['sourceip'];\n\t\t}\n\t\t$count = (empty($_REQUEST['count'])) ? DEFAULT_WAIT : $_REQUEST['count'];\n\t\t$wait = (empty($_REQUEST['wait'])) ? DEFAULT_WAIT : $_REQUEST['wait'];\n\t}\n}\n\nif ($do_ping) {\n?>\n\t<script type=\"text/javascript\">\n\t//<![CDATA[\n\twindow.onload=function() {\n\t\tdocument.getElementById(\"pingCaptured\").wrap='off';\n\t}\n\t//]]>\n\t</script>\n<?php\n\t$ifscope = '';\n\t$command = \"/sbin/ping\";\n\tif ($ipproto == \"ipv6\") {\n\t\t$command .= \"6\";\n\t\t$ifaddr = is_ipaddr($sourceip) ? $sourceip : get_interface_ipv6($sourceip);\n\t\tif (is_linklocal($ifaddr)) {\n\t\t\t$ifscope = get_ll_scope($ifaddr);\n\t\t}\n\t} else {\n\t\t$ifaddr = is_ipaddr($sourceip) ? $sourceip : get_interface_ip($sourceip);\n\t}\n\n\tif ($ifaddr && (is_ipaddr($host) || is_hostname($host))) {\n\t\t$srcip = \"-S\" . escapeshellarg($ifaddr);\n\t\tif (is_linklocal($host) && !strstr($host, \"%\") && !empty($ifscope)) {\n\t\t\t$host .= \"%{$ifscope}\";\n\t\t}\n\t}\n\n\t$cmd = \"{$command} {$srcip} -c\" . escapeshellarg($count) . \" -i\" . escapeshellarg($wait) . \" \" . escapeshellarg($host);\n\t//echo \"Ping command: {$cmd}\\n\";\n\t$result = shell_exec($cmd);\n\n\tif (empty($result)) {\n\t\t$input_errors[] = sprintf(gettext('Host \"%s\" did not respond or could not be resolved.'), $host);\n\t}\n\n}\n\ninclude('head.inc');\n\nif ($input_errors) {\n\tprint_input_errors($input_errors);\n}\n\n$form = new Form(false);\n\n$section = new Form_Section('Ping');\n\n$section->addInput(new Form_Input(\n\t'host',\n\t'*Hostname',\n\t'text',\n\t$host,\n\t['placeholder' => 'Hostname to ping']\n));\n\n$section->addInput(new Form_Select(\n\t'ipproto',\n\t'*IP Protocol',\n\t$ipproto,\n\t['ipv4' => 'IPv4', 'ipv6' => 'IPv6']\n));\n\n$section->addInput(new Form_Select(\n\t'sourceip',\n\t'*Source address',\n\t$sourceip,\n\tarray('' => gettext('Automatically selected (default)')) + get_possible_traffic_source_addresses(true)\n))->setHelp('Select source address for the ping.');\n\n$section->addInput(new Form_Select(\n\t'count',\n\t'Maximum number of pings',\n\t$count,\n\tarray_combine(range(1, MAX_COUNT), range(1, MAX_COUNT))\n))->setHelp('Select the maximum number of pings.');\n\n$section->addInput(new Form_Select(\n\t'wait',\n\t'Seconds between pings',\n\t$wait,\n\tarray_combine(range(1, MAX_WAIT), range(1, MAX_WAIT))\n))->setHelp('Select the number of seconds to wait between pings.');\n\n$form->add($section);\n\n$form->addGlobal(new Form_Button(\n\t'Submit',\n\t'Ping',\n\tnull,\n\t'fa-rss'\n))->addClass('btn-primary');\n\nprint $form;\n\nif ($do_ping && !empty($result) && !$input_errors) {\n?>\n\t<div class=\"panel panel-default\">\n\t\t<div class=\"panel-heading\">\n\t\t\t<h2 class=\"panel-title\"><?=gettext('Results')?></h2>\n\t\t</div>\n\n\t\t<div class=\"panel-body\">\n\t\t\t<pre><?= htmlspecialchars($result) ?></pre>\n\t\t</div>\n\t</div>\n<?php\n}\n\ninclude('foot.inc');\n", "<?php\n/*\n * diag_traceroute.php\n *\n * part of pfSense (https://www.pfsense.org)\n * Copyright (c) 2004-2013 BSD Perimeter\n * Copyright (c) 2013-2016 Electric Sheep Fencing\n * Copyright (c) 2014-2020 Rubicon Communications, LLC (Netgate)\n * Copyright (c) 2005 Paul Taylor (paultaylor@winndixie.com)\n * All rights reserved.\n *\n * originally based on m0n0wall (http://m0n0.ch/wall)\n * Copyright (c) 2003-2004 Manuel Kasper <mk@neon1.net>.\n * All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n##|+PRIV\n##|*IDENT=page-diagnostics-traceroute\n##|*NAME=Diagnostics: Traceroute\n##|*DESCR=Allow access to the 'Diagnostics: Traceroute' page.\n##|*MATCH=diag_traceroute.php*\n##|-PRIV\n\nrequire_once(\"guiconfig.inc\");\n\n$allowautocomplete = true;\n$pgtitle = array(gettext(\"Diagnostics\"), gettext(\"Traceroute\"));\ninclude(\"head.inc\");\n\n/* Max TTL of both traceroute and traceroute6 is 255, but in practice more than\n   64 hops would most likely time out in the GUI. If a user requires a\n   traceroute that long, they can use the CLI. */\ndefine('MAX_TTL', 64);\ndefine('DEFAULT_TTL', 18);\n\n// Set defaults in case they are not supplied.\n$do_traceroute = false;\n$host = '';\n$ttl = DEFAULT_TTL;\n$ipproto = 'ipv4';\n$sourceip = 'any';\n\nif ($_POST || $_REQUEST['host']) {\n\tunset($input_errors);\n\n\t/* input validation */\n\t$reqdfields = explode(\" \", \"host ttl\");\n\t$reqdfieldsn = array(gettext(\"Host\"), gettext(\"ttl\"));\n\tdo_input_validation($_REQUEST, $reqdfields, $reqdfieldsn, $input_errors);\n\n\tif (($_REQUEST['ttl'] < 1) || ($_REQUEST['ttl'] > MAX_TTL)) {\n\t\t$input_errors[] = sprintf(gettext(\"Maximum number of hops must be between 1 and %s\"), MAX_TTL);\n\t}\n\t$host = trim($_REQUEST['host']);\n\t$ipproto = $_REQUEST['ipproto'];\n\tif (($ipproto == \"ipv4\") && is_ipaddrv6($host)) {\n\t\t$input_errors[] = gettext(\"When using IPv4, the target host must be an IPv4 address or hostname.\");\n\t}\n\tif (($ipproto == \"ipv6\") && is_ipaddrv4($host)) {\n\t\t$input_errors[] = gettext(\"When using IPv6, the target host must be an IPv6 address or hostname.\");\n\t}\n\tif (!is_ipaddr($host) && !is_hostname($host)) {\n\t\t$input_errors[] = gettext(\"Hostname must be a valid hostname or IP address.\");\n\t}\n\n\t$sourceip = $_REQUEST['sourceip'];\n\t$ttl = $_REQUEST['ttl'];\n\t$resolve = $_REQUEST['resolve'];\n\t$useicmp = $_REQUEST['useicmp'];\n\n\tif ($_POST && !$input_errors) {\n\t\t$do_traceroute = true;\n\t}\n\n} else {\n\t$resolve = false;\n\t$useicmp = false;\n}\n\nif ($input_errors) {\n\tprint_input_errors($input_errors);\n}\n\n/* Do the traceroute and show any error */\nif ($do_traceroute) {\n\t$useicmpparam = isset($useicmp) ? \"-I\" : \"\";\n\t$n = isset($resolve) ? \"\" : \"-n\";\n\n\t$command = \"/usr/sbin/traceroute\";\n\tif ($ipproto == \"ipv6\") {\n\t\t$command .= \"6\";\n\t\tif (empty($n)) {\n\t\t\t$n = \"-l\";\n\t\t}\n\t\t$ifaddr = is_ipaddr($sourceip) ? $sourceip : get_interface_ipv6($sourceip);\n\t} else {\n\t\t$ifaddr = is_ipaddr($sourceip) ? $sourceip : get_interface_ip($sourceip);\n\t}\n\n\tif ($ifaddr && (is_ipaddr($host) || is_hostname($host))) {\n\t\t$srcip = \"-s \" . escapeshellarg($ifaddr);\n\t}\n\n\t$cmd = \"{$command} {$n} {$srcip} -w 2 {$useicmpparam} -m \" . escapeshellarg($ttl) . \" \" . escapeshellarg($host);\n\t$result = shell_exec($cmd);\n\n\tif (!$result) {\n\t\tprint_info_box(sprintf(gettext('Error: %s could not be traced/resolved'), htmlspecialchars($host)));\n\t}\n}\n\n$form = new Form(false);\n\n$section = new Form_Section('Traceroute');\n\n$section->addInput(new Form_Input(\n\t'host',\n\t'*Hostname',\n\t'text',\n\t$host,\n\t['placeholder' => 'Hostname to trace.']\n));\n\n$section->addInput(new Form_Select(\n\t'ipproto',\n\t'*IP Protocol',\n\t$ipproto,\n\tarray('ipv4' => 'IPv4', 'ipv6' => 'IPv6')\n))->setHelp('Select the protocol to use.');\n\n$section->addInput(new Form_Select(\n\t'sourceip',\n\t'*Source Address',\n\t$sourceip,\n\tarray('any' => gettext('Any')) + get_possible_traffic_source_addresses(true)\n))->setHelp('Select source address for the trace.');\n\n$section->addInput(new Form_Select(\n\t'ttl',\n\t'Maximum number of hops',\n\t$ttl,\n\tarray_combine(range(1, MAX_TTL), range(1, MAX_TTL))\n))->setHelp('Select the maximum number of network hops to trace.');\n\n$section->addInput(new Form_Checkbox(\n\t'resolve',\n\t'Reverse Address Lookup',\n\t'',\n\t$resolve\n))->setHelp('When checked, traceroute will attempt to perform a PTR lookup to locate hostnames for hops along the path. This will slow down the process as it has to wait for DNS replies.');\n\n$section->addInput(new Form_Checkbox(\n\t'useicmp',\n\tgettext(\"Use ICMP\"),\n\t'',\n\t$useicmp\n))->setHelp('By default, traceroute uses UDP but that may be blocked by some routers. Check this box to use ICMP instead, which may succeed. ');\n\n$form->add($section);\n\n$form->addGlobal(new Form_Button(\n\t'Submit',\n\t'Traceroute',\n\tnull,\n\t'fa-rss'\n))->addClass('btn-primary');\n\nprint $form;\n\n/* Show the traceroute results */\nif ($do_traceroute && $result) {\n?>\n\t<div class=\"panel panel-default\">\n\t\t<div class=\"panel-heading\"><h2 class=\"panel-title\"><?=gettext('Results')?></h2></div>\n\t\t<div class=\"panel-body\">\n<?php\n\tprint('<pre>' . htmlspecialchars($result) . '</pre>');\n?>\n\t\t</div>\n\t</div>\n<?php\n}\n\ninclude(\"foot.inc\");\n?>\n"], "filenames": ["src/usr/local/www/diag_ping.php", "src/usr/local/www/diag_traceroute.php"], "buggy_code_start_loc": [69, 72], "buggy_code_end_loc": [189, 187], "fixing_code_start_loc": [70, 73], "fixing_code_end_loc": [192, 190], "type": "CWE-79", "message": "An XSS vulnerability resides in the hostname field of the diag_ping.php page in pfsense before 2.4.5 version. After passing inputs to the command and executing this command, the $result variable is not sanitized before it is printed.", "other": {"cve": {"id": "CVE-2020-10797", "sourceIdentifier": "cve@mitre.org", "published": "2020-04-29T14:15:16.967", "lastModified": "2020-05-01T14:42:33.410", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An XSS vulnerability resides in the hostname field of the diag_ping.php page in pfsense before 2.4.5 version. After passing inputs to the command and executing this command, the $result variable is not sanitized before it is printed."}, {"lang": "es", "value": "Una vulnerabilidad de tipo XSS reside en el campo hostname de la p\u00e1gina diag_ping.php en pfsense versiones anteriores a 2.4.5. Despu\u00e9s de pasar las entradas al comando y ejecutar este comando, la variable $result  no es saneada antes de ser impresa."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:netgate:pfsense:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.4.5", "matchCriteriaId": "D211001F-1AF6-453C-A997-D45C099B5895"}]}]}], "references": [{"url": "https://docs.netgate.com/pfsense/en/latest/releases/2-4-5-new-features-and-changes.html", "source": "cve@mitre.org", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "https://github.com/pfsense/pfsense/commit/cc3990a334059018b004c91eeb66c147d8afe83d", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://redmine.pfsense.org/issues/10355", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/pfsense/pfsense/commit/cc3990a334059018b004c91eeb66c147d8afe83d"}}