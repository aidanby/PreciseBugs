{"buggy_code": ["CHANGES - 2.2.6 - 2017-10-19\n============================\n\n\nChanges in CUPS v2.2.6\n----------------------\n\n- Added USB quirks rules for Canon MP540 and Samsung ML-2160 (Issue #5148)\n- Fixed TLS cipher suite selection with GNU TLS (Issue #5145)\n\n\nChanges in CUPS v2.2.5\n----------------------\n\n- The scheduler's `-t` option did not force all errors to the standard error\n  file, making debugging of configuration problems hard (Issue #5041)\n- Fixed a typo in the CUPS Programming Manual (Issue #5042)\n- Fixed RPM packaging issue (Issue #5043, Issue #5044)\n- The `cupsGetDests` function incorrectly returned an empty list of printers if\n  there was no default printer (Issue #5046)\n- The `cupsGetDests` function waited too long for network printers (Issue #5049)\n- Libtool support was completely broken with current libtool versions that use\n  an incompatible command-line syntax (Issue #5050)\n- Fixed a build issue with `--enable-mallinfo` (Issue #5051)\n- The ippserver test program contained a deadlock issue (Issue #5054)\n- The `cupsLocalizeDest*` functions did not provide base localizations for\n  all registered IPP attributes and values (Issue #5056)\n- The --enable-libtool configure option requires a path to the libtool program,\n  but doesn't document or check for it (Issue #5062)\n- Fixed the `SSLOptions DenyCBC` option when using GNU TLS (Issue #5065)\n- Fixed the `ServerTokens None` option (Issue #5065)\n- Fixed the default `ServerAlias` value from `ServerName` (Issue #5072)\n- Fixed the adminurl field in the TXT record for fully-qualified `ServerName`\n  values (Issue #5074)\n- The scheduler now creates a PID file when not running on demand with a modern\n  service launcher (Issue #5080)\n- The web interface did not support newer language identifiers used by Microsoft\n  web browsers (Issue #5803)\n- Updated the cups-files.conf and cupsd.conf file documentation for missing\n  directives (Issue #5084)\n- Fixed an Avahi-related crash bug in the scheduler (Issue #5085, Issue #5086)\n- Fixed the interactions between the \"print-quality\" and \"cupsPrintQuality\"\n  options (Issue #5090)\n- The IPP Everywhere PPD generator now sorts the supported resolutions before\n  choosing them for draft, normal, and best quality modes (Issue #5091)\n- Fixed the localization unit test on Linux (Issue #5097)\n- The CUPS library did not reuse domain sockets (Issue #5098)\n- Fixed the \"make check\" target for some environments (Issue #5099)\n- The scheduler woke up once per second to remove old temporary queues\n  (Issue #5100)\n- Added USB quirk rule for Kyocera printer (Issue #5102, Issue #5103)\n- Re-documented the limits of `file:///...` device URIs and moved the FileDevice\n  directive in `cups-files.conf` to the list of deprecated configuration\n  directives (Issue #5117)\n- Added USB quirk rule for HP LaserJet 1160 printer (Issue #5121)\n- Fixed the script interpreter detection in the configure script (Issue #5122)\n- The network backends now retry on more error conditions (Issue #5123)\n- Added a French translation of the web interface (Issue #5134)\n- `cupsGetDests2` was not using the supplied HTTP connection (Issue #5135)\n- `httpAddrConnect` leaked sockets in certain circumstances, causing some\n  printers to hang (rdar://31965686)\n- Fixed an issue with Chinese localizations on macOS (rdar://32419311)\n- The IPP backend now always sends the \"finishings\" attribute for printers that\n  support it because otherwise the client cannot override printer defaults\n  (rdar://33169732)\n- The `cupsGetNamedDest` function did not use the local default printer\n  (rdar://33228500)\n- The IPP backend incorrectly sent the \"job-pages-per-set\" attribute to PDF\n  printers (rdar://33250434)\n- Fixed the `cups.strings` file that is used on macOS (rdar://33287650)\n- CUPS now sends the `Date` HTTP header in IPP requests (rdar://33302034)\n- The `ippCopyAttribute` function did not copy out-of-band values correctly\n  (rdar://33688003)\n- Fixed the localization fallback code on macOS (rdar://33583699)\n- The scheduler did not run with a high enough priority, causing problems on\n  busy systems (rdar://33789342)\n- Added support for Japanese Kaku 1 envelope size (rdar://34774110)\n- The `ipptool` program's `-P` option did not work correctly.\n- The `ipptool` program did not compare URI scheme or hostname components\n  correctly for the WITH-ALL-HOSTNAMES, WITH-ALL-SCHEMES, WITH-HOSTNAME, or\n  WITH-SCHEME predicates.\n\n\nChanges in CUPS v2.2.4\n----------------------\n\n- The scheduler did not remove old job files (Issue #4987)\n- cupsEnumDests did not return early when all printers had been discovered\n  (Issue #4989)\n- The CUPS build system now supports cross-compilation (Issue #4897)\n- Added a new CUPS Programming Manual to replace the aging API documentation.\n- Added the `cupsAddIntegerOption` and `cupsGetIntegerOption` functions\n  (Issue #4992)\n- The `cupsGetDests` and `cupsCreateJob` functions now support Bonjour printers\n  (Issue #4993)\n- Added a USB quirk rule for Lexmark E260dn printers (Issue #4994)\n- Fixed a potential buffer overflow in the `cupstestppd` utility (Issue #4996)\n- IPP Everywhere improvements (Issue #4998)\n- Fixed the \"cancel all jobs\" function in the web interface for several\n  languages (Issue #4999)\n- Fixed issues with local queues (Issue #5003, Issue #5008, Issue #5009)\n- The `lpstat` command now supports a `-e` option to enumerate local printers\n  (either previously added or on the network) that can be accessed\n  (Issue #5005)\n- The `lp` and `lpr` commands now support printing to network printers that\n  haven't yet been added (Issue #5006)\n- Fixed a typo in the mime.types file.\n- Fixed a bug in the Spanish web interface template (Issue #5016)\n- The `cupsEnumDests*` and `cupsGetDest*` functions now report the value of the\n  \"printer-is-temporary\" Printer Status attribute (Issue #5028)\n- Added Chinese localization (Issue #5029)\n- The `cupsCheckDestSupported` function did not support `NULL` values\n  (Issue #5031)\n- Fixed some issues in the RPM spec file (Issue #5032)\n- The `cupsConnectDest` function now supports the `CUPS_DEST_FLAGS_DEVICE` flag\n  for explicitly connecting to the device (printer) associated with the\n  destination.\n- The `SSLOptions` directive in \"client.conf\" and \"cupsd.conf\" now supports\n  `DenyCBC` and `DenyTLS1.0` options (Issue #5037)\n\n\nChanges in CUPS v2.2.3\n----------------------\n\n- The IPP backend could get into an infinite loop for certain errors, causing a\n  hung queue (<rdar://problem/28008717>)\n- The scheduler could pause responding to client requests in order to save state\n  changes to disk (<rdar://problem/28690656>)\n- Added support for PPD finishing keywords (Issue #4960, Issue #4961,\n  Issue #4962)\n- The IPP backend did not send a media-col attribute for just the source or type\n  (Issue #4963)\n- IPP Everywhere print queues did not always support all print qualities\n  supported by the printer (Issue #4953)\n- IPP Everywhere print queues did not always support all media types supported\n  by the printer (Issue #4953)\n- The IPP Everywhere PPD generator did not return useful error messages\n  (Issue #4954)\n- The IPP Everywhere finishings support did not work correctly with common UI or\n  command-line options (Issue #4976)\n- Fixed an error handling issue for the network backends (Issue #4979)\n- The default cupsd.conf file did not work on systems compiled without Kerberos\n  support (Issue #4947)\n- The \"reprint job\" option was not available for some canceled jobs\n  (Issue #4915)\n- Updated the job listing in the web interface (Issue #4978)\n- Fixed some localization issues on macOS (<rdar://problem/27245567>)\n\n\nChanges in CUPS v2.2.2\n----------------------\n\n- Fixed some issues with the Zebra ZPL printer driver (Issue #4898)\n- Fixed some issues with IPP Everywhere printer support (Issue #4893,\n  Issue #4909, Issue #4916, Issue #4921, Issue #4923, Issue #4932, Issue #4933,\n  Issue #4938)\n- The rastertopwg filter could crash with certain input (Issue #4942)\n- Optimized connection usage in the IPP backend (<rdar://problem/29547323>)\n- The scheduler did not detect when an encrypted connection was closed by the\n  client on Linux (Issue #4901)\n- The cups-lpd program did not catch all legacy usage of ISO-8859-1\n  (Issue #4899)\n- Fixed builds on systems without a working poll() implementation (Issue #4905)\n- Added a USB quirk rule for the Kyocera Ecosys P6026cdn (Issue #4900)\n- The scheduler no longer creates log files on startup\n  (<rdar://problem/28332470>)\n- The ippContainsString function now uses case-insensitive comparisons for\n  mimeMediaType, name, and text values in conformance with RFC 2911.\n- The network backends now log the addresses that were found for a printer\n  (<rdar://problem/29268474>)\n- Let's Encrypt certificates did not work when the hostname contained uppercase\n  letters (Issue #4919)\n- Fixed reporting of printed pages in the web interface (Issue #4924)\n- Updated systemd config files (Issue #4935)\n- Updated documentation (PR #4896)\n- Updated localizations (PR #4894, PR #4895, PR #4904, PR #4908, Issue #4946)\n- Updated packaging files (Issue #4940)\n\n\nChanges in CUPS v2.2.1\n----------------------\n\n- Added \"CreateSelfSignedCerts\" directive for cups-files.conf to control whether\n  the scheduler automatically creates its own self-signed X.509 certificates for\n  TLS connections (Issue #4876)\n- http*Connect did not handle partial failures (Issue #4870)\n- Addressed some build warnings on Linux (Issue #4881)\n- cupsHashData did not use the correct hashing algorithm\n  (<rdar://problem/28209220>)\n- Updated man pages (PR #4885)\n- Updated localizations (PR #4877, PR #4886)\n\n\nChanges in CUPS v2.2.0\n----------------------\n\n- Normalized the TLS certificate validation code and added additional error\n  messages to aid troubleshooting.\n- The httpConnect functions did not work on Linux when cupsd was not running\n  (Issue #4870)\n- The --no-remote-any option of cupsctl had no effect (Issue #4866)\n- http*Connect did not return early when all addresses failed (Issue #4870)\n\n\nChanges in CUPS v2.2rc1\n-----------------------\n\n- Updated the list of supported IPP Everywhere media types.\n- The IPP backend did not validate TLS credentials properly.\n- The printer-state-message attribute was not cleared after a print job with no\n  errors (Issue #4851)\n- The CUPS-Add-Modify-Class and CUPS-Add-Modify-Printer operations did not\n  always return an error for failed adds (Issue #4854)\n- PPD files with names longer than 127 bytes did not work (Issue #4860)\n- Updated localizations (Issue #4846, PR #4858)\n\n\nChanges in CUPS v2.2b2\n----------------------\n\n- Added Upstart support (PR #4825)\n- CUPS now supports Let's Encrypt certificates on Linux.\n\n\nChanges in CUPS v2.2b1\n----------------------\n\n- All CUPS commands now support POSIX options (Issue #4813)\n- The scheduler now restarts faster (Issue #4760)\n- Improved performance of web interface with large numbers of jobs (Issue #3819)\n- Encrypted printing can now be limited to only trusted printers and servers\n  (<rdar://problem/25711658>)\n- The scheduler now advertises PWG Raster attributes for IPP Everywhere clients\n  (Issue #4428)\n- The scheduler now logs informational messages for jobs at LogLevel \"info\"\n  (Issue #4815)\n- The scheduler now uses the getgrouplist function when available (Issue #4611)\n- The IPP backend no longer enables compression by default except for certain\n  raster formats that generally benefit from it (<rdar://problem/25166952>)\n- The scheduler did not handle out-of-disk situations gracefully (Issue #4742)\n- The LPD mini-daemon now detects invalid UTF-8 sequences in job, document, and\n  user names (Issue #4748)\n- The IPP backend now continues on to the next job when the remote server/\n  printer puts the job on hold (<rdar://problem/24858548>)\n- The scheduler did not cancel multi-document jobs immediately\n  (<rdar://problem/24854834>)\n- The scheduler did not return non-shared printers to local clients unless they\n  connected to the domain socket (<rdar://problem/24566996>)\n- The scheduler now reads the spool directory if one or more job cache entries\n  point to deleted jobs (<rdar://problem/24048846>)\n- Added support for disc media sizes (<rdar://problem/20219536>)\n- The httpAddrConnect and httpConnect* APIs now try connecting to multiple\n  addresses in parallel (<rdar://problem/20643153>)\n- The cupsd domain socket is no longer world-accessible on macOS\n  (<rdar://problem/7542560>)\n- Interface scripts are no longer supported for security reasons\n  (<rdar://problem/23135640>)\n- Added a new cupsHashData API and support for hashed job passwords\n  (<rdar://problem/20221502>)\n- Localization fixes (<rdar://problem/25292403>, <rdar://problem/25461517>,\n  Issue #4041, Issue #4796)\n- Documentation changes (Issue #4624, Issue #4781)\n- Packaging fixes (PR #4832)\n", "/*\n * IPP routines for the CUPS scheduler.\n *\n * Copyright 2007-2016 by Apple Inc.\n * Copyright 1997-2007 by Easy Software Products, all rights reserved.\n *\n * This file contains Kerberos support code, copyright 2006 by\n * Jelmer Vernooij.\n *\n * These coded instructions, statements, and computer programs are the\n * property of Apple Inc. and are protected by Federal copyright\n * law.  Distribution and use rights are outlined in the file \"LICENSE.txt\"\n * which should have been included with this file.  If this file is\n * missing or damaged, see the license at \"http://www.cups.org/\".\n */\n\n/*\n * Include necessary headers...\n */\n\n#include \"cupsd.h\"\n#include <cups/ppd-private.h>\n\n#ifdef __APPLE__\n/*#  include <ApplicationServices/ApplicationServices.h>\nextern CFUUIDRef ColorSyncCreateUUIDFromUInt32(unsigned id);\n#  include <CoreFoundation/CoreFoundation.h>*/\n#  ifdef HAVE_MEMBERSHIP_H\n#    include <membership.h>\n#  endif /* HAVE_MEMBERSHIP_H */\n#  ifdef HAVE_MEMBERSHIPPRIV_H\n#    include <membershipPriv.h>\n#  else\nextern int mbr_user_name_to_uuid(const char* name, uuid_t uu);\nextern int mbr_group_name_to_uuid(const char* name, uuid_t uu);\nextern int mbr_check_membership_by_id(uuid_t user, gid_t group, int* ismember);\n#  endif /* HAVE_MEMBERSHIPPRIV_H */\n#endif /* __APPLE__ */\n\n\n/*\n * Local functions...\n */\n\nstatic void\taccept_jobs(cupsd_client_t *con, ipp_attribute_t *uri);\nstatic void\tadd_class(cupsd_client_t *con, ipp_attribute_t *uri);\nstatic int\tadd_file(cupsd_client_t *con, cupsd_job_t *job,\n\t\t         mime_type_t *filetype, int compression);\nstatic cupsd_job_t *add_job(cupsd_client_t *con, cupsd_printer_t *printer,\n\t\t\t    mime_type_t *filetype);\nstatic void\tadd_job_subscriptions(cupsd_client_t *con, cupsd_job_t *job);\nstatic void\tadd_job_uuid(cupsd_job_t *job);\nstatic void\tadd_printer(cupsd_client_t *con, ipp_attribute_t *uri);\nstatic void\tadd_printer_state_reasons(cupsd_client_t *con,\n\t\t                          cupsd_printer_t *p);\nstatic void\tadd_queued_job_count(cupsd_client_t *con, cupsd_printer_t *p);\nstatic void\tapply_printer_defaults(cupsd_printer_t *printer,\n\t\t\t\t       cupsd_job_t *job);\nstatic void\tauthenticate_job(cupsd_client_t *con, ipp_attribute_t *uri);\nstatic void\tcancel_all_jobs(cupsd_client_t *con, ipp_attribute_t *uri);\nstatic void\tcancel_job(cupsd_client_t *con, ipp_attribute_t *uri);\nstatic void\tcancel_subscription(cupsd_client_t *con, int id);\nstatic int\tcheck_rss_recipient(const char *recipient);\nstatic int\tcheck_quotas(cupsd_client_t *con, cupsd_printer_t *p);\nstatic void\tclose_job(cupsd_client_t *con, ipp_attribute_t *uri);\nstatic void\tcopy_attrs(ipp_t *to, ipp_t *from, cups_array_t *ra,\n\t\t           ipp_tag_t group, int quickcopy,\n\t\t\t   cups_array_t *exclude);\nstatic int\tcopy_banner(cupsd_client_t *con, cupsd_job_t *job,\n\t\t            const char *name);\nstatic int\tcopy_file(const char *from, const char *to, mode_t mode);\nstatic int\tcopy_model(cupsd_client_t *con, const char *from,\n\t\t           const char *to);\nstatic void\tcopy_job_attrs(cupsd_client_t *con,\n\t\t               cupsd_job_t *job,\n\t\t\t       cups_array_t *ra, cups_array_t *exclude);\nstatic void\tcopy_printer_attrs(cupsd_client_t *con,\n\t\t                   cupsd_printer_t *printer,\n\t\t\t\t   cups_array_t *ra);\nstatic void\tcopy_subscription_attrs(cupsd_client_t *con,\n\t\t                        cupsd_subscription_t *sub,\n\t\t\t\t\tcups_array_t *ra,\n\t\t\t\t\tcups_array_t *exclude);\nstatic void\tcreate_job(cupsd_client_t *con, ipp_attribute_t *uri);\nstatic void\tcreate_local_printer(cupsd_client_t *con);\nstatic cups_array_t *create_requested_array(ipp_t *request);\nstatic void\tcreate_subscriptions(cupsd_client_t *con, ipp_attribute_t *uri);\nstatic void\tdelete_printer(cupsd_client_t *con, ipp_attribute_t *uri);\nstatic void\tget_default(cupsd_client_t *con);\nstatic void\tget_devices(cupsd_client_t *con);\nstatic void\tget_document(cupsd_client_t *con, ipp_attribute_t *uri);\nstatic void\tget_jobs(cupsd_client_t *con, ipp_attribute_t *uri);\nstatic void\tget_job_attrs(cupsd_client_t *con, ipp_attribute_t *uri);\nstatic void\tget_notifications(cupsd_client_t *con);\nstatic void\tget_ppd(cupsd_client_t *con, ipp_attribute_t *uri);\nstatic void\tget_ppds(cupsd_client_t *con);\nstatic void\tget_printers(cupsd_client_t *con, int type);\nstatic void\tget_printer_attrs(cupsd_client_t *con, ipp_attribute_t *uri);\nstatic void\tget_printer_supported(cupsd_client_t *con, ipp_attribute_t *uri);\nstatic void\tget_subscription_attrs(cupsd_client_t *con, int sub_id);\nstatic void\tget_subscriptions(cupsd_client_t *con, ipp_attribute_t *uri);\nstatic const char *get_username(cupsd_client_t *con);\nstatic void\thold_job(cupsd_client_t *con, ipp_attribute_t *uri);\nstatic void\thold_new_jobs(cupsd_client_t *con, ipp_attribute_t *uri);\nstatic void\tmove_job(cupsd_client_t *con, ipp_attribute_t *uri);\nstatic int\tppd_parse_line(const char *line, char *option, int olen,\n\t\t               char *choice, int clen);\nstatic void\tprint_job(cupsd_client_t *con, ipp_attribute_t *uri);\nstatic void\tread_job_ticket(cupsd_client_t *con);\nstatic void\treject_jobs(cupsd_client_t *con, ipp_attribute_t *uri);\nstatic void\trelease_held_new_jobs(cupsd_client_t *con,\n\t\t                      ipp_attribute_t *uri);\nstatic void\trelease_job(cupsd_client_t *con, ipp_attribute_t *uri);\nstatic void\trenew_subscription(cupsd_client_t *con, int sub_id);\nstatic void\trestart_job(cupsd_client_t *con, ipp_attribute_t *uri);\nstatic void\tsave_auth_info(cupsd_client_t *con, cupsd_job_t *job,\n\t\t               ipp_attribute_t *auth_info);\nstatic void\tsend_document(cupsd_client_t *con, ipp_attribute_t *uri);\nstatic void\tsend_http_error(cupsd_client_t *con, http_status_t status,\n\t\t                cupsd_printer_t *printer);\nstatic void\tsend_ipp_status(cupsd_client_t *con, ipp_status_t status,\n\t\t                const char *message, ...)\n\t\t__attribute__((__format__(__printf__, 3, 4)));\nstatic void\tset_default(cupsd_client_t *con, ipp_attribute_t *uri);\nstatic void\tset_job_attrs(cupsd_client_t *con, ipp_attribute_t *uri);\nstatic void\tset_printer_attrs(cupsd_client_t *con, ipp_attribute_t *uri);\nstatic int\tset_printer_defaults(cupsd_client_t *con, cupsd_printer_t *printer);\nstatic void\tstart_printer(cupsd_client_t *con, ipp_attribute_t *uri);\nstatic void\tstop_printer(cupsd_client_t *con, ipp_attribute_t *uri);\nstatic void\turl_encode_attr(ipp_attribute_t *attr, char *buffer, size_t bufsize);\nstatic char\t*url_encode_string(const char *s, char *buffer, size_t bufsize);\nstatic int\tuser_allowed(cupsd_printer_t *p, const char *username);\nstatic void\tvalidate_job(cupsd_client_t *con, ipp_attribute_t *uri);\nstatic int\tvalidate_name(const char *name);\nstatic int\tvalidate_user(cupsd_job_t *job, cupsd_client_t *con, const char *owner, char *username, size_t userlen);\n\n\n/*\n * 'cupsdProcessIPPRequest()' - Process an incoming IPP request.\n */\n\nint\t\t\t\t\t/* O - 1 on success, 0 on failure */\ncupsdProcessIPPRequest(\n    cupsd_client_t *con)\t\t/* I - Client connection */\n{\n  ipp_tag_t\t\tgroup;\t\t/* Current group tag */\n  ipp_attribute_t\t*attr;\t\t/* Current attribute */\n  ipp_attribute_t\t*charset;\t/* Character set attribute */\n  ipp_attribute_t\t*language;\t/* Language attribute */\n  ipp_attribute_t\t*uri = NULL;\t/* Printer or job URI attribute */\n  ipp_attribute_t\t*username;\t/* requesting-user-name attr */\n  int\t\t\tsub_id;\t\t/* Subscription ID */\n\n\n  cupsdLogMessage(CUPSD_LOG_DEBUG2, \"cupsdProcessIPPRequest(%p[%d]): operation_id=%04x(%s)\", con, con->number, con->request->request.op.operation_id, ippOpString(con->request->request.op.operation_id));\n\n  if (LogLevel >= CUPSD_LOG_DEBUG2)\n  {\n    for (group = IPP_TAG_ZERO, attr = ippFirstAttribute(con->request); attr; attr = ippNextAttribute(con->request))\n    {\n      const char  *name;                /* Attribute name */\n      char        value[1024];          /* Attribute value */\n\n      if (group != ippGetGroupTag(attr))\n      {\n        group = ippGetGroupTag(attr);\n        if (group != IPP_TAG_ZERO)\n          cupsdLogMessage(CUPSD_LOG_DEBUG2, \"cupsdProcessIPPRequest: %s\", ippTagString(group));\n      }\n\n      if ((name = ippGetName(attr)) == NULL)\n        continue;\n\n      ippAttributeString(attr, value, sizeof(value));\n\n      cupsdLogMessage(CUPSD_LOG_DEBUG2, \"cupsdProcessIPPRequest: %s %s%s '%s'\", name, ippGetCount(attr) > 1 ? \"1setOf \" : \"\", ippTagString(ippGetValueTag(attr)), value);\n    }\n  }\n\n /*\n  * First build an empty response message for this request...\n  */\n\n  con->response = ippNew();\n\n  con->response->request.status.version[0] =\n      con->request->request.op.version[0];\n  con->response->request.status.version[1] =\n      con->request->request.op.version[1];\n  con->response->request.status.request_id =\n      con->request->request.op.request_id;\n\n /*\n  * Then validate the request header and required attributes...\n  */\n\n  if (con->request->request.any.version[0] != 1 &&\n      con->request->request.any.version[0] != 2)\n  {\n   /*\n    * Return an error, since we only support IPP 1.x and 2.x.\n    */\n\n    cupsdAddEvent(CUPSD_EVENT_SERVER_AUDIT, NULL, NULL,\n                  \"%04X %s Bad request version number %d.%d\",\n\t\t  IPP_VERSION_NOT_SUPPORTED, con->http->hostname,\n                  con->request->request.any.version[0],\n\t          con->request->request.any.version[1]);\n\n    send_ipp_status(con, IPP_VERSION_NOT_SUPPORTED,\n                    _(\"Bad request version number %d.%d.\"),\n\t\t    con->request->request.any.version[0],\n\t            con->request->request.any.version[1]);\n  }\n  else if (con->request->request.any.request_id < 1)\n  {\n   /*\n    * Return an error, since request IDs must be between 1 and 2^31-1\n    */\n\n    cupsdAddEvent(CUPSD_EVENT_SERVER_AUDIT, NULL, NULL,\n                  \"%04X %s Bad request ID %d\",\n\t\t  IPP_BAD_REQUEST, con->http->hostname,\n                  con->request->request.any.request_id);\n\n    send_ipp_status(con, IPP_BAD_REQUEST, _(\"Bad request ID %d.\"),\n\t\t    con->request->request.any.request_id);\n  }\n  else if (!con->request->attrs)\n  {\n    cupsdAddEvent(CUPSD_EVENT_SERVER_AUDIT, NULL, NULL,\n                  \"%04X %s No attributes in request\",\n\t\t  IPP_BAD_REQUEST, con->http->hostname);\n\n    send_ipp_status(con, IPP_BAD_REQUEST, _(\"No attributes in request.\"));\n  }\n  else\n  {\n   /*\n    * Make sure that the attributes are provided in the correct order and\n    * don't repeat groups...\n    */\n\n    for (attr = con->request->attrs, group = attr->group_tag;\n\t attr;\n\t attr = attr->next)\n      if (attr->group_tag < group && attr->group_tag != IPP_TAG_ZERO)\n      {\n       /*\n\t* Out of order; return an error...\n\t*/\n\n\tcupsdAddEvent(CUPSD_EVENT_SERVER_AUDIT, NULL, NULL,\n                      \"%04X %s Attribute groups are out of order\",\n\t\t      IPP_BAD_REQUEST, con->http->hostname);\n\n\tsend_ipp_status(con, IPP_BAD_REQUEST,\n\t                _(\"Attribute groups are out of order (%x < %x).\"),\n\t\t\tattr->group_tag, group);\n\tbreak;\n      }\n      else\n\tgroup = attr->group_tag;\n\n    if (!attr)\n    {\n     /*\n      * Then make sure that the first three attributes are:\n      *\n      *     attributes-charset\n      *     attributes-natural-language\n      *     printer-uri/job-uri\n      */\n\n      attr = con->request->attrs;\n      if (attr && attr->name &&\n          !strcmp(attr->name, \"attributes-charset\") &&\n\t  (attr->value_tag & IPP_TAG_MASK) == IPP_TAG_CHARSET)\n\tcharset = attr;\n      else\n\tcharset = NULL;\n\n      if (attr)\n        attr = attr->next;\n\n      if (attr && attr->name &&\n          !strcmp(attr->name, \"attributes-natural-language\") &&\n\t  (attr->value_tag & IPP_TAG_MASK) == IPP_TAG_LANGUAGE)\n      {\n\tlanguage = attr;\n\n       /*\n        * Reset language for this request if different from Accept-Language.\n        */\n\n\tif (!con->language ||\n\t    strcmp(attr->values[0].string.text, con->language->language))\n\t{\n\t  cupsLangFree(con->language);\n\t  con->language = cupsLangGet(attr->values[0].string.text);\n\t}\n      }\n      else\n\tlanguage = NULL;\n\n      if ((attr = ippFindAttribute(con->request, \"printer-uri\",\n                                   IPP_TAG_URI)) != NULL)\n\turi = attr;\n      else if ((attr = ippFindAttribute(con->request, \"job-uri\",\n                                        IPP_TAG_URI)) != NULL)\n\turi = attr;\n      else if (con->request->request.op.operation_id == CUPS_GET_PPD)\n        uri = ippFindAttribute(con->request, \"ppd-name\", IPP_TAG_NAME);\n      else\n\turi = NULL;\n\n      if (charset)\n\tippAddString(con->response, IPP_TAG_OPERATION, IPP_TAG_CHARSET,\n        \t     \"attributes-charset\", NULL,\n\t\t     charset->values[0].string.text);\n      else\n\tippAddString(con->response, IPP_TAG_OPERATION, IPP_TAG_CHARSET,\n        \t     \"attributes-charset\", NULL, \"utf-8\");\n\n      if (language)\n\tippAddString(con->response, IPP_TAG_OPERATION, IPP_TAG_LANGUAGE,\n                     \"attributes-natural-language\", NULL,\n\t\t     language->values[0].string.text);\n      else\n\tippAddString(con->response, IPP_TAG_OPERATION, IPP_TAG_LANGUAGE,\n                     \"attributes-natural-language\", NULL, DefaultLanguage);\n\n      if (charset &&\n          _cups_strcasecmp(charset->values[0].string.text, \"us-ascii\") &&\n          _cups_strcasecmp(charset->values[0].string.text, \"utf-8\"))\n      {\n       /*\n        * Bad character set...\n\t*/\n\n        cupsdLogMessage(CUPSD_LOG_ERROR, \"Unsupported character set \\\"%s\\\"\",\n\t                charset->values[0].string.text);\n\tcupsdAddEvent(CUPSD_EVENT_SERVER_AUDIT, NULL, NULL,\n\t\t      \"%04X %s Unsupported attributes-charset value \\\"%s\\\"\",\n\t\t      IPP_CHARSET, con->http->hostname,\n\t\t      charset->values[0].string.text);\n\tsend_ipp_status(con, IPP_BAD_REQUEST,\n\t                _(\"Unsupported character set \\\"%s\\\".\"),\n\t                charset->values[0].string.text);\n      }\n      else if (!charset || !language ||\n\t       (!uri &&\n\t        con->request->request.op.operation_id != CUPS_GET_DEFAULT &&\n\t        con->request->request.op.operation_id != CUPS_GET_PRINTERS &&\n\t        con->request->request.op.operation_id != CUPS_GET_CLASSES &&\n\t        con->request->request.op.operation_id != CUPS_GET_DEVICES &&\n\t        con->request->request.op.operation_id != CUPS_GET_PPDS))\n      {\n       /*\n\t* Return an error, since attributes-charset,\n\t* attributes-natural-language, and printer-uri/job-uri are required\n\t* for all operations.\n\t*/\n\n        if (!charset)\n\t{\n\t  cupsdLogMessage(CUPSD_LOG_ERROR,\n\t                  \"Missing attributes-charset attribute\");\n\n\t  cupsdAddEvent(CUPSD_EVENT_SERVER_AUDIT, NULL, NULL,\n                \t\"%04X %s Missing attributes-charset attribute\",\n\t\t\tIPP_BAD_REQUEST, con->http->hostname);\n        }\n\n        if (!language)\n\t{\n\t  cupsdLogMessage(CUPSD_LOG_ERROR,\n\t                  \"Missing attributes-natural-language attribute\");\n\n\t  cupsdAddEvent(CUPSD_EVENT_SERVER_AUDIT, NULL, NULL,\n                \t\"%04X %s Missing attributes-natural-language attribute\",\n\t\t\tIPP_BAD_REQUEST, con->http->hostname);\n        }\n\n        if (!uri)\n\t{\n\t  cupsdLogMessage(CUPSD_LOG_ERROR,\n\t                  \"Missing printer-uri, job-uri, or ppd-name \"\n\t\t\t  \"attribute\");\n\n\t  cupsdAddEvent(CUPSD_EVENT_SERVER_AUDIT, NULL, NULL,\n                \t\"%04X %s Missing printer-uri, job-uri, or ppd-name \"\n\t\t\t\"attribute\", IPP_BAD_REQUEST, con->http->hostname);\n        }\n\n\tcupsdLogMessage(CUPSD_LOG_DEBUG, \"Request attributes follow...\");\n\n\tfor (attr = con->request->attrs; attr; attr = attr->next)\n\t  cupsdLogMessage(CUPSD_LOG_DEBUG,\n\t        \t  \"attr \\\"%s\\\": group_tag = %x, value_tag = %x\",\n\t        \t  attr->name ? attr->name : \"(null)\", attr->group_tag,\n\t\t\t  attr->value_tag);\n\n\tcupsdLogMessage(CUPSD_LOG_DEBUG, \"End of attributes...\");\n\n\tsend_ipp_status(con, IPP_BAD_REQUEST,\n\t                _(\"Missing required attributes.\"));\n      }\n      else\n      {\n       /*\n\t* OK, all the checks pass so far; make sure requesting-user-name is\n\t* not \"root\" from a remote host...\n\t*/\n\n        if ((username = ippFindAttribute(con->request, \"requesting-user-name\",\n\t                                 IPP_TAG_NAME)) != NULL)\n\t{\n\t /*\n\t  * Check for root user...\n\t  */\n\n\t  if (!strcmp(username->values[0].string.text, \"root\") &&\n\t      _cups_strcasecmp(con->http->hostname, \"localhost\") &&\n\t      strcmp(con->username, \"root\"))\n\t  {\n\t   /*\n\t    * Remote unauthenticated user masquerading as local root...\n\t    */\n\n            ippSetString(con->request, &username, 0, RemoteRoot);\n\t  }\n\t}\n\n        if ((attr = ippFindAttribute(con->request, \"notify-subscription-id\",\n\t                             IPP_TAG_INTEGER)) != NULL)\n\t  sub_id = attr->values[0].integer;\n\telse\n\t  sub_id = 0;\n\n       /*\n        * Then try processing the operation...\n\t*/\n\n        if (uri)\n\t  cupsdLogMessage(CUPSD_LOG_DEBUG, \"%s %s\",\n                \t  ippOpString(con->request->request.op.operation_id),\n\t\t\t  uri->values[0].string.text);\n        else\n\t  cupsdLogMessage(CUPSD_LOG_DEBUG, \"%s\",\n                \t  ippOpString(con->request->request.op.operation_id));\n\n\tswitch (con->request->request.op.operation_id)\n\t{\n\t  case IPP_OP_PRINT_JOB :\n              print_job(con, uri);\n              break;\n\n\t  case IPP_OP_VALIDATE_JOB :\n              validate_job(con, uri);\n              break;\n\n\t  case IPP_OP_CREATE_JOB :\n              create_job(con, uri);\n              break;\n\n\t  case IPP_OP_SEND_DOCUMENT :\n              send_document(con, uri);\n              break;\n\n\t  case IPP_OP_CANCEL_JOB :\n              cancel_job(con, uri);\n              break;\n\n\t  case IPP_OP_GET_JOB_ATTRIBUTES :\n              get_job_attrs(con, uri);\n              break;\n\n\t  case IPP_OP_GET_JOBS :\n              get_jobs(con, uri);\n              break;\n\n\t  case IPP_OP_GET_PRINTER_ATTRIBUTES :\n              get_printer_attrs(con, uri);\n              break;\n\n\t  case IPP_OP_GET_PRINTER_SUPPORTED_VALUES :\n              get_printer_supported(con, uri);\n              break;\n\n\t  case IPP_OP_HOLD_JOB :\n              hold_job(con, uri);\n              break;\n\n\t  case IPP_OP_RELEASE_JOB :\n              release_job(con, uri);\n              break;\n\n\t  case IPP_OP_RESTART_JOB :\n              restart_job(con, uri);\n              break;\n\n\t  case IPP_OP_PAUSE_PRINTER :\n              stop_printer(con, uri);\n\t      break;\n\n\t  case IPP_OP_RESUME_PRINTER :\n              start_printer(con, uri);\n\t      break;\n\n\t  case IPP_OP_PURGE_JOBS :\n\t  case IPP_OP_CANCEL_JOBS :\n\t  case IPP_OP_CANCEL_MY_JOBS :\n              cancel_all_jobs(con, uri);\n              break;\n\n\t  case IPP_OP_SET_JOB_ATTRIBUTES :\n              set_job_attrs(con, uri);\n              break;\n\n\t  case IPP_OP_SET_PRINTER_ATTRIBUTES :\n              set_printer_attrs(con, uri);\n              break;\n\n\t  case IPP_OP_HOLD_NEW_JOBS :\n              hold_new_jobs(con, uri);\n              break;\n\n\t  case IPP_OP_RELEASE_HELD_NEW_JOBS :\n              release_held_new_jobs(con, uri);\n              break;\n\n\t  case IPP_OP_CLOSE_JOB :\n              close_job(con, uri);\n              break;\n\n\t  case IPP_OP_CUPS_GET_DEFAULT :\n              get_default(con);\n              break;\n\n\t  case IPP_OP_CUPS_GET_PRINTERS :\n              get_printers(con, 0);\n              break;\n\n\t  case IPP_OP_CUPS_GET_CLASSES :\n              get_printers(con, CUPS_PRINTER_CLASS);\n              break;\n\n\t  case IPP_OP_CUPS_ADD_MODIFY_PRINTER :\n              add_printer(con, uri);\n              break;\n\n\t  case IPP_OP_CUPS_DELETE_PRINTER :\n              delete_printer(con, uri);\n              break;\n\n\t  case IPP_OP_CUPS_ADD_MODIFY_CLASS :\n              add_class(con, uri);\n              break;\n\n\t  case IPP_OP_CUPS_DELETE_CLASS :\n              delete_printer(con, uri);\n              break;\n\n\t  case IPP_OP_CUPS_ACCEPT_JOBS :\n\t  case IPP_OP_ENABLE_PRINTER :\n              accept_jobs(con, uri);\n              break;\n\n\t  case IPP_OP_CUPS_REJECT_JOBS :\n\t  case IPP_OP_DISABLE_PRINTER :\n              reject_jobs(con, uri);\n              break;\n\n\t  case IPP_OP_CUPS_SET_DEFAULT :\n              set_default(con, uri);\n              break;\n\n\t  case IPP_OP_CUPS_GET_DEVICES :\n              get_devices(con);\n              break;\n\n          case IPP_OP_CUPS_GET_DOCUMENT :\n\t      get_document(con, uri);\n\t      break;\n\n\t  case IPP_OP_CUPS_GET_PPD :\n              get_ppd(con, uri);\n              break;\n\n\t  case IPP_OP_CUPS_GET_PPDS :\n              get_ppds(con);\n              break;\n\n\t  case IPP_OP_CUPS_MOVE_JOB :\n              move_job(con, uri);\n              break;\n\n\t  case IPP_OP_CUPS_AUTHENTICATE_JOB :\n              authenticate_job(con, uri);\n              break;\n\n          case IPP_OP_CREATE_PRINTER_SUBSCRIPTIONS :\n\t  case IPP_OP_CREATE_JOB_SUBSCRIPTIONS :\n\t      create_subscriptions(con, uri);\n\t      break;\n\n          case IPP_OP_GET_SUBSCRIPTION_ATTRIBUTES :\n\t      get_subscription_attrs(con, sub_id);\n\t      break;\n\n\t  case IPP_OP_GET_SUBSCRIPTIONS :\n\t      get_subscriptions(con, uri);\n\t      break;\n\n\t  case IPP_OP_RENEW_SUBSCRIPTION :\n\t      renew_subscription(con, sub_id);\n\t      break;\n\n\t  case IPP_OP_CANCEL_SUBSCRIPTION :\n\t      cancel_subscription(con, sub_id);\n\t      break;\n\n          case IPP_OP_GET_NOTIFICATIONS :\n\t      get_notifications(con);\n\t      break;\n\n\t  case IPP_OP_CUPS_CREATE_LOCAL_PRINTER :\n\t      create_local_printer(con);\n\t      break;\n\n\t  default :\n\t      cupsdAddEvent(CUPSD_EVENT_SERVER_AUDIT, NULL, NULL,\n                \t    \"%04X %s Operation %04X (%s) not supported\",\n\t\t\t    IPP_OPERATION_NOT_SUPPORTED, con->http->hostname,\n\t\t\t    con->request->request.op.operation_id,\n\t\t\t    ippOpString(con->request->request.op.operation_id));\n\n              send_ipp_status(con, IPP_OPERATION_NOT_SUPPORTED,\n\t                      _(\"%s not supported.\"),\n\t\t\t      ippOpString(\n\t\t\t          con->request->request.op.operation_id));\n\t      break;\n\t}\n      }\n    }\n  }\n\n  if (con->response)\n  {\n   /*\n    * Sending data from the scheduler...\n    */\n\n    cupsdLogMessage(con->response->request.status.status_code\n                        >= IPP_BAD_REQUEST &&\n                    con->response->request.status.status_code\n\t\t        != IPP_NOT_FOUND ? CUPSD_LOG_ERROR : CUPSD_LOG_DEBUG,\n                    \"[Client %d] Returning IPP %s for %s (%s) from %s\",\n\t            con->number,\n\t            ippErrorString(con->response->request.status.status_code),\n\t\t    ippOpString(con->request->request.op.operation_id),\n\t\t    uri ? uri->values[0].string.text : \"no URI\",\n\t\t    con->http->hostname);\n\n    httpClearFields(con->http);\n\n#ifdef CUPSD_USE_CHUNKING\n   /*\n    * Because older versions of CUPS (1.1.17 and older) and some IPP\n    * clients do not implement chunking properly, we cannot use\n    * chunking by default.  This may become the default in future\n    * CUPS releases, or we might add a configuration directive for\n    * it.\n    */\n\n    if (con->http->version == HTTP_1_1)\n    {\n      cupsdLogMessage(CUPSD_LOG_DEBUG,\n\t\t      \"[Client %d] Transfer-Encoding: chunked\",\n\t\t      con->number);\n\n      cupsdSetLength(con->http, 0);\n    }\n    else\n#endif /* CUPSD_USE_CHUNKING */\n    {\n      size_t\tlength;\t\t\t/* Length of response */\n\n\n      length = ippLength(con->response);\n\n      if (con->file >= 0 && !con->pipe_pid)\n      {\n\tstruct stat\tfileinfo;\t/* File information */\n\n\tif (!fstat(con->file, &fileinfo))\n\t  length += (size_t)fileinfo.st_size;\n      }\n\n      cupsdLogMessage(CUPSD_LOG_DEBUG,\n\t\t      \"[Client %d] Content-Length: \" CUPS_LLFMT,\n\t\t      con->number, CUPS_LLCAST length);\n      httpSetLength(con->http, length);\n    }\n\n    if (cupsdSendHeader(con, HTTP_OK, \"application/ipp\", CUPSD_AUTH_NONE))\n    {\n     /*\n      * Tell the caller the response header was sent successfully...\n      */\n\n      cupsdAddSelect(httpGetFd(con->http), (cupsd_selfunc_t)cupsdReadClient,\n\t\t     (cupsd_selfunc_t)cupsdWriteClient, con);\n\n      return (1);\n    }\n    else\n    {\n     /*\n      * Tell the caller the response header could not be sent...\n      */\n\n      return (0);\n    }\n  }\n  else\n  {\n   /*\n    * Sending data from a subprocess like cups-deviced; tell the caller\n    * everything is A-OK so far...\n    */\n\n    return (1);\n  }\n}\n\n\n/*\n * 'cupsdTimeoutJob()' - Timeout a job waiting on job files.\n */\n\nint\t\t\t\t\t/* O - 0 on success, -1 on error */\ncupsdTimeoutJob(cupsd_job_t *job)\t/* I - Job to timeout */\n{\n  cupsd_printer_t\t*printer;\t/* Destination printer or class */\n  ipp_attribute_t\t*attr;\t\t/* job-sheets attribute */\n  int\t\t\tkbytes;\t\t/* Kilobytes in banner */\n\n\n  job->pending_timeout = 0;\n\n /*\n  * See if we need to add the ending sheet...\n  */\n\n  if (!cupsdLoadJob(job))\n    return (-1);\n\n  printer = cupsdFindDest(job->dest);\n  attr    = ippFindAttribute(job->attrs, \"job-sheets\", IPP_TAG_NAME);\n\n  if (printer && !(printer->type & CUPS_PRINTER_REMOTE) &&\n      attr && attr->num_values > 1)\n  {\n   /*\n    * Yes...\n    */\n\n    cupsdLogJob(job, CUPSD_LOG_INFO, \"Adding end banner page \\\"%s\\\".\",\n                attr->values[1].string.text);\n\n    if ((kbytes = copy_banner(NULL, job, attr->values[1].string.text)) < 0)\n      return (-1);\n\n    cupsdUpdateQuota(printer, job->username, 0, kbytes);\n  }\n\n  return (0);\n}\n\n\n/*\n * 'accept_jobs()' - Accept print jobs to a printer.\n */\n\nstatic void\naccept_jobs(cupsd_client_t  *con,\t/* I - Client connection */\n            ipp_attribute_t *uri)\t/* I - Printer or class URI */\n{\n  http_status_t\tstatus;\t\t\t/* Policy status */\n  cups_ptype_t\tdtype;\t\t\t/* Destination type (printer/class) */\n  cupsd_printer_t *printer;\t\t/* Printer data */\n\n\n  cupsdLogMessage(CUPSD_LOG_DEBUG2, \"accept_jobs(%p[%d], %s)\", con,\n                  con->number, uri->values[0].string.text);\n\n /*\n  * Is the destination valid?\n  */\n\n  if (!cupsdValidateDest(uri->values[0].string.text, &dtype, &printer))\n  {\n   /*\n    * Bad URI...\n    */\n\n    send_ipp_status(con, IPP_NOT_FOUND,\n                    _(\"The printer or class does not exist.\"));\n    return;\n  }\n\n /*\n  * Check policy...\n  */\n\n  if ((status = cupsdCheckPolicy(printer->op_policy_ptr, con, NULL)) != HTTP_OK)\n  {\n    send_http_error(con, status, printer);\n    return;\n  }\n\n /*\n  * Accept jobs sent to the printer...\n  */\n\n  printer->accepting        = 1;\n  printer->state_message[0] = '\\0';\n\n  cupsdAddEvent(CUPSD_EVENT_PRINTER_STATE, printer, NULL,\n                \"Now accepting jobs.\");\n\n  if (dtype & CUPS_PRINTER_CLASS)\n  {\n    cupsdMarkDirty(CUPSD_DIRTY_CLASSES);\n\n    cupsdLogMessage(CUPSD_LOG_INFO, \"Class \\\"%s\\\" now accepting jobs (\\\"%s\\\").\",\n                    printer->name, get_username(con));\n  }\n  else\n  {\n    cupsdMarkDirty(CUPSD_DIRTY_PRINTERS);\n\n    cupsdLogMessage(CUPSD_LOG_INFO,\n                    \"Printer \\\"%s\\\" now accepting jobs (\\\"%s\\\").\",\n                    printer->name, get_username(con));\n  }\n\n /*\n  * Everything was ok, so return OK status...\n  */\n\n  con->response->request.status.status_code = IPP_OK;\n}\n\n\n/*\n * 'add_class()' - Add a class to the system.\n */\n\nstatic void\nadd_class(cupsd_client_t  *con,\t\t/* I - Client connection */\n          ipp_attribute_t *uri)\t\t/* I - URI of class */\n{\n  http_status_t\tstatus;\t\t\t/* Policy status */\n  int\t\ti;\t\t\t/* Looping var */\n  char\t\tscheme[HTTP_MAX_URI],\t/* Method portion of URI */\n\t\tusername[HTTP_MAX_URI],\t/* Username portion of URI */\n\t\thost[HTTP_MAX_URI],\t/* Host portion of URI */\n\t\tresource[HTTP_MAX_URI];\t/* Resource portion of URI */\n  int\t\tport;\t\t\t/* Port portion of URI */\n  cupsd_printer_t *pclass,\t\t/* Class */\n\t\t*member;\t\t/* Member printer/class */\n  cups_ptype_t\tdtype;\t\t\t/* Destination type */\n  ipp_attribute_t *attr;\t\t/* Printer attribute */\n  int\t\tmodify;\t\t\t/* Non-zero if we just modified */\n  int\t\tneed_restart_job;\t/* Need to restart job? */\n\n\n  cupsdLogMessage(CUPSD_LOG_DEBUG2, \"add_class(%p[%d], %s)\", con,\n                  con->number, uri->values[0].string.text);\n\n /*\n  * Do we have a valid URI?\n  */\n\n  httpSeparateURI(HTTP_URI_CODING_ALL, uri->values[0].string.text, scheme,\n                  sizeof(scheme), username, sizeof(username), host,\n\t\t  sizeof(host), &port, resource, sizeof(resource));\n\n\n  if (strncmp(resource, \"/classes/\", 9) || strlen(resource) == 9)\n  {\n   /*\n    * No, return an error...\n    */\n\n    send_ipp_status(con, IPP_BAD_REQUEST,\n                    _(\"The printer-uri must be of the form \"\n\t\t      \"\\\"ipp://HOSTNAME/classes/CLASSNAME\\\".\"));\n    return;\n  }\n\n /*\n  * Do we have a valid printer name?\n  */\n\n  if (!validate_name(resource + 9))\n  {\n   /*\n    * No, return an error...\n    */\n\n    send_ipp_status(con, IPP_BAD_REQUEST,\n                    _(\"The printer-uri \\\"%s\\\" contains invalid characters.\"),\n\t\t    uri->values[0].string.text);\n    return;\n  }\n\n /*\n  * See if the class already exists; if not, create a new class...\n  */\n\n  if ((pclass = cupsdFindClass(resource + 9)) == NULL)\n  {\n   /*\n    * Class doesn't exist; see if we have a printer of the same name...\n    */\n\n    if ((pclass = cupsdFindPrinter(resource + 9)) != NULL)\n    {\n     /*\n      * Yes, return an error...\n      */\n\n      send_ipp_status(con, IPP_NOT_POSSIBLE,\n                      _(\"A printer named \\\"%s\\\" already exists.\"),\n\t\t      resource + 9);\n      return;\n    }\n\n   /*\n    * No, check the default policy and then add the class...\n    */\n\n    if ((status = cupsdCheckPolicy(DefaultPolicyPtr, con, NULL)) != HTTP_OK)\n    {\n      send_http_error(con, status, NULL);\n      return;\n    }\n\n    pclass = cupsdAddClass(resource + 9);\n    modify = 0;\n  }\n  else if ((status = cupsdCheckPolicy(pclass->op_policy_ptr, con,\n                                      NULL)) != HTTP_OK)\n  {\n    send_http_error(con, status, pclass);\n    return;\n  }\n  else\n    modify = 1;\n\n /*\n  * Look for attributes and copy them over as needed...\n  */\n\n  need_restart_job = 0;\n\n  if ((attr = ippFindAttribute(con->request, \"printer-location\", IPP_TAG_TEXT)) != NULL)\n    cupsdSetString(&pclass->location, attr->values[0].string.text);\n\n  if ((attr = ippFindAttribute(con->request, \"printer-geo-location\", IPP_TAG_URI)) != NULL && !strncmp(attr->values[0].string.text, \"geo:\", 4))\n    cupsdSetString(&pclass->geo_location, attr->values[0].string.text);\n\n  if ((attr = ippFindAttribute(con->request, \"printer-organization\", IPP_TAG_TEXT)) != NULL)\n    cupsdSetString(&pclass->organization, attr->values[0].string.text);\n\n  if ((attr = ippFindAttribute(con->request, \"printer-organizational-unit\", IPP_TAG_TEXT)) != NULL)\n    cupsdSetString(&pclass->organizational_unit, attr->values[0].string.text);\n\n  if ((attr = ippFindAttribute(con->request, \"printer-info\",\n                               IPP_TAG_TEXT)) != NULL)\n    cupsdSetString(&pclass->info, attr->values[0].string.text);\n\n  if ((attr = ippFindAttribute(con->request, \"printer-is-accepting-jobs\",\n                               IPP_TAG_BOOLEAN)) != NULL &&\n      attr->values[0].boolean != pclass->accepting)\n  {\n    cupsdLogMessage(CUPSD_LOG_INFO,\n                    \"Setting %s printer-is-accepting-jobs to %d (was %d.)\",\n                    pclass->name, attr->values[0].boolean, pclass->accepting);\n\n    pclass->accepting = attr->values[0].boolean;\n\n    cupsdAddEvent(CUPSD_EVENT_PRINTER_STATE, pclass, NULL, \"%s accepting jobs.\",\n\t\t  pclass->accepting ? \"Now\" : \"No longer\");\n  }\n\n  if ((attr = ippFindAttribute(con->request, \"printer-is-shared\", IPP_TAG_BOOLEAN)) != NULL)\n  {\n    if (pclass->type & CUPS_PRINTER_REMOTE)\n    {\n     /*\n      * Cannot re-share remote printers.\n      */\n\n      send_ipp_status(con, IPP_BAD_REQUEST, _(\"Cannot change printer-is-shared for remote queues.\"));\n      if (!modify)\n\tcupsdDeletePrinter(pclass, 0);\n\n      return;\n    }\n\n    if (pclass->shared && !ippGetBoolean(attr, 0))\n      cupsdDeregisterPrinter(pclass, 1);\n\n    cupsdLogMessage(CUPSD_LOG_INFO,\n                    \"Setting %s printer-is-shared to %d (was %d.)\",\n                    pclass->name, attr->values[0].boolean, pclass->shared);\n\n    pclass->shared = ippGetBoolean(attr, 0);\n  }\n\n  if ((attr = ippFindAttribute(con->request, \"printer-state\",\n                               IPP_TAG_ENUM)) != NULL)\n  {\n    if (attr->values[0].integer != IPP_PRINTER_IDLE &&\n        attr->values[0].integer != IPP_PRINTER_STOPPED)\n    {\n      send_ipp_status(con, IPP_BAD_REQUEST,\n                      _(\"Attempt to set %s printer-state to bad value %d.\"),\n                      pclass->name, attr->values[0].integer);\n      if (!modify)\n\tcupsdDeletePrinter(pclass, 0);\n\n      return;\n    }\n\n    cupsdLogMessage(CUPSD_LOG_INFO, \"Setting %s printer-state to %d (was %d.)\",\n                    pclass->name, attr->values[0].integer, pclass->state);\n\n    if (attr->values[0].integer == IPP_PRINTER_STOPPED)\n      cupsdStopPrinter(pclass, 0);\n    else\n    {\n      cupsdSetPrinterState(pclass, (ipp_pstate_t)(attr->values[0].integer), 0);\n      need_restart_job = 1;\n    }\n  }\n  if ((attr = ippFindAttribute(con->request, \"printer-state-message\",\n                               IPP_TAG_TEXT)) != NULL)\n  {\n    strlcpy(pclass->state_message, attr->values[0].string.text,\n            sizeof(pclass->state_message));\n\n    cupsdAddEvent(CUPSD_EVENT_PRINTER_STATE, pclass, NULL, \"%s\",\n                  pclass->state_message);\n  }\n  if ((attr = ippFindAttribute(con->request, \"member-uris\",\n                               IPP_TAG_URI)) != NULL)\n  {\n   /*\n    * Clear the printer array as needed...\n    */\n\n    need_restart_job = 1;\n\n    if (pclass->num_printers > 0)\n    {\n      free(pclass->printers);\n      pclass->num_printers = 0;\n    }\n\n   /*\n    * Add each printer or class that is listed...\n    */\n\n    for (i = 0; i < attr->num_values; i ++)\n    {\n     /*\n      * Search for the printer or class URI...\n      */\n\n      if (!cupsdValidateDest(attr->values[i].string.text, &dtype, &member))\n      {\n       /*\n\t* Bad URI...\n\t*/\n\n\tsend_ipp_status(con, IPP_NOT_FOUND,\n                \t_(\"The printer or class does not exist.\"));\n\tif (!modify)\n\t  cupsdDeletePrinter(pclass, 0);\n\n\treturn;\n      }\n      else if (dtype & CUPS_PRINTER_CLASS)\n      {\n        send_ipp_status(con, IPP_BAD_REQUEST,\n\t\t\t_(\"Nested classes are not allowed.\"));\n\tif (!modify)\n\t  cupsdDeletePrinter(pclass, 0);\n\n        return;\n      }\n\n     /*\n      * Add it to the class...\n      */\n\n      cupsdAddPrinterToClass(pclass, member);\n    }\n  }\n\n  if (!set_printer_defaults(con, pclass))\n  {\n    if (!modify)\n      cupsdDeletePrinter(pclass, 0);\n\n    return;\n  }\n\n  if ((attr = ippFindAttribute(con->request, \"auth-info-required\",\n                               IPP_TAG_KEYWORD)) != NULL)\n    cupsdSetAuthInfoRequired(pclass, NULL, attr);\n\n  pclass->config_time = time(NULL);\n\n /*\n  * Update the printer class attributes and return...\n  */\n\n  cupsdSetPrinterAttrs(pclass);\n  cupsdMarkDirty(CUPSD_DIRTY_CLASSES);\n\n  if (need_restart_job && pclass->job)\n  {\n   /*\n    * Reset the current job to a \"pending\" status...\n    */\n\n    cupsdSetJobState(pclass->job, IPP_JOB_PENDING, CUPSD_JOB_FORCE,\n                     \"Job restarted because the class was modified.\");\n  }\n\n  cupsdMarkDirty(CUPSD_DIRTY_PRINTCAP);\n\n  if (modify)\n  {\n    cupsdAddEvent(CUPSD_EVENT_PRINTER_MODIFIED,\n\t\t  pclass, NULL, \"Class \\\"%s\\\" modified by \\\"%s\\\".\",\n\t\t  pclass->name, get_username(con));\n\n    cupsdLogMessage(CUPSD_LOG_INFO, \"Class \\\"%s\\\" modified by \\\"%s\\\".\",\n                    pclass->name, get_username(con));\n  }\n  else\n  {\n    cupsdAddEvent(CUPSD_EVENT_PRINTER_ADDED,\n\t\t  pclass, NULL, \"New class \\\"%s\\\" added by \\\"%s\\\".\",\n\t\t  pclass->name, get_username(con));\n\n    cupsdLogMessage(CUPSD_LOG_INFO, \"New class \\\"%s\\\" added by \\\"%s\\\".\",\n                    pclass->name, get_username(con));\n  }\n\n  con->response->request.status.status_code = IPP_OK;\n}\n\n\n/*\n * 'add_file()' - Add a file to a job.\n */\n\nstatic int\t\t\t\t/* O - 0 on success, -1 on error */\nadd_file(cupsd_client_t *con,\t\t/* I - Connection to client */\n         cupsd_job_t    *job,\t\t/* I - Job to add to */\n         mime_type_t    *filetype,\t/* I - Type of file */\n\t int            compression)\t/* I - Compression */\n{\n  mime_type_t\t**filetypes;\t\t/* New filetypes array... */\n  int\t\t*compressions;\t\t/* New compressions array... */\n\n\n  cupsdLogMessage(CUPSD_LOG_DEBUG2,\n        \t  \"add_file(con=%p[%d], job=%d, filetype=%s/%s, \"\n\t\t  \"compression=%d)\", con, con ? con->number : -1, job->id,\n\t\t  filetype->super, filetype->type, compression);\n\n /*\n  * Add the file to the job...\n  */\n\n  if (job->num_files == 0)\n  {\n    compressions = (int *)malloc(sizeof(int));\n    filetypes    = (mime_type_t **)malloc(sizeof(mime_type_t *));\n  }\n  else\n  {\n    compressions = (int *)realloc(job->compressions,\n                                  (size_t)(job->num_files + 1) * sizeof(int));\n    filetypes    = (mime_type_t **)realloc(job->filetypes,\n                                           (size_t)(job->num_files + 1) *\n\t\t\t\t\t   sizeof(mime_type_t *));\n  }\n\n  if (compressions)\n    job->compressions = compressions;\n\n  if (filetypes)\n    job->filetypes = filetypes;\n\n  if (!compressions || !filetypes)\n  {\n    cupsdSetJobState(job, IPP_JOB_ABORTED, CUPSD_JOB_PURGE,\n                     \"Job aborted because the scheduler ran out of memory.\");\n\n    if (con)\n      send_ipp_status(con, IPP_INTERNAL_ERROR,\n\t\t      _(\"Unable to allocate memory for file types.\"));\n\n    return (-1);\n  }\n\n  job->compressions[job->num_files] = compression;\n  job->filetypes[job->num_files]    = filetype;\n\n  job->num_files ++;\n\n  job->dirty = 1;\n  cupsdMarkDirty(CUPSD_DIRTY_JOBS);\n\n  return (0);\n}\n\n\n/*\n * 'add_job()' - Add a job to a print queue.\n */\n\nstatic cupsd_job_t *\t\t\t/* O - Job object */\nadd_job(cupsd_client_t  *con,\t\t/* I - Client connection */\n\tcupsd_printer_t *printer,\t/* I - Destination printer */\n\tmime_type_t     *filetype)\t/* I - First print file type, if any */\n{\n  http_status_t\tstatus;\t\t\t/* Policy status */\n  ipp_attribute_t *attr,\t\t/* Current attribute */\n\t\t*auth_info;\t\t/* auth-info attribute */\n  const char\t*mandatory;\t\t/* Current mandatory job attribute */\n  const char\t*val;\t\t\t/* Default option value */\n  int\t\tpriority;\t\t/* Job priority */\n  cupsd_job_t\t*job;\t\t\t/* Current job */\n  char\t\tjob_uri[HTTP_MAX_URI];\t/* Job URI */\n  int\t\tkbytes;\t\t\t/* Size of print file */\n  int\t\ti;\t\t\t/* Looping var */\n  int\t\tlowerpagerange;\t\t/* Page range bound */\n  int\t\texact;\t\t\t/* Did we have an exact match? */\n  ipp_attribute_t *media_col,\t\t/* media-col attribute */\n\t\t*media_margin;\t\t/* media-*-margin attribute */\n  ipp_t\t\t*unsup_col;\t\t/* media-col in unsupported response */\n  static const char * const readonly[] =/* List of read-only attributes */\n  {\n    \"date-time-at-completed\",\n    \"date-time-at-creation\",\n    \"date-time-at-processing\",\n    \"job-detailed-status-messages\",\n    \"job-document-access-errors\",\n    \"job-id\",\n    \"job-impressions-completed\",\n    \"job-k-octets-completed\",\n    \"job-media-sheets-completed\",\n    \"job-pages-completed\",\n    \"job-printer-up-time\",\n    \"job-printer-uri\",\n    \"job-state\",\n    \"job-state-message\",\n    \"job-state-reasons\",\n    \"job-uri\",\n    \"number-of-documents\",\n    \"number-of-intervening-jobs\",\n    \"output-device-assigned\",\n    \"time-at-completed\",\n    \"time-at-creation\",\n    \"time-at-processing\"\n  };\n\n\n  cupsdLogMessage(CUPSD_LOG_DEBUG2, \"add_job(%p[%d], %p(%s), %p(%s/%s))\",\n                  con, con->number, printer, printer->name,\n\t\t  filetype, filetype ? filetype->super : \"none\",\n\t\t  filetype ? filetype->type : \"none\");\n\n /*\n  * Check remote printing to non-shared printer...\n  */\n\n  if (!printer->shared &&\n      _cups_strcasecmp(con->http->hostname, \"localhost\") &&\n      _cups_strcasecmp(con->http->hostname, ServerName))\n  {\n    send_ipp_status(con, IPP_NOT_AUTHORIZED,\n                    _(\"The printer or class is not shared.\"));\n    return (NULL);\n  }\n\n /*\n  * Check policy...\n  */\n\n  auth_info = ippFindAttribute(con->request, \"auth-info\", IPP_TAG_TEXT);\n\n  if ((status = cupsdCheckPolicy(printer->op_policy_ptr, con, NULL)) != HTTP_OK)\n  {\n    send_http_error(con, status, printer);\n    return (NULL);\n  }\n  else if (printer->num_auth_info_required == 1 &&\n           !strcmp(printer->auth_info_required[0], \"negotiate\") &&\n           !con->username[0])\n  {\n    send_http_error(con, HTTP_UNAUTHORIZED, printer);\n    return (NULL);\n  }\n#ifdef HAVE_SSL\n  else if (auth_info && !con->http->tls &&\n           !httpAddrLocalhost(con->http->hostaddr))\n  {\n   /*\n    * Require encryption of auth-info over non-local connections...\n    */\n\n    send_http_error(con, HTTP_UPGRADE_REQUIRED, printer);\n    return (NULL);\n  }\n#endif /* HAVE_SSL */\n\n /*\n  * See if the printer is accepting jobs...\n  */\n\n  if (!printer->accepting)\n  {\n    send_ipp_status(con, IPP_NOT_ACCEPTING,\n                    _(\"Destination \\\"%s\\\" is not accepting jobs.\"),\n                    printer->name);\n    return (NULL);\n  }\n\n /*\n  * Validate job template attributes; for now just document-format,\n  * copies, job-sheets, number-up, page-ranges, mandatory attributes, and\n  * media...\n  */\n\n  for (i = 0; i < (int)(sizeof(readonly) / sizeof(readonly[0])); i ++)\n  {\n    if ((attr = ippFindAttribute(con->request, readonly[i], IPP_TAG_ZERO)) != NULL)\n    {\n      ippDeleteAttribute(con->request, attr);\n\n      if (StrictConformance)\n      {\n\tsend_ipp_status(con, IPP_BAD_REQUEST, _(\"The '%s' Job Status attribute cannot be supplied in a job creation request.\"), readonly[i]);\n\treturn (NULL);\n      }\n\n      cupsdLogMessage(CUPSD_LOG_INFO, \"Unexpected '%s' Job Status attribute in a job creation request.\", readonly[i]);\n    }\n  }\n\n  if (printer->pc)\n  {\n    for (mandatory = (char *)cupsArrayFirst(printer->pc->mandatory);\n\t mandatory;\n\t mandatory = (char *)cupsArrayNext(printer->pc->mandatory))\n    {\n      if (!ippFindAttribute(con->request, mandatory, IPP_TAG_ZERO))\n      {\n       /*\n\t* Missing a required attribute...\n\t*/\n\n\tsend_ipp_status(con, IPP_CONFLICT,\n\t\t\t_(\"The \\\"%s\\\" attribute is required for print jobs.\"),\n\t\t\tmandatory);\n\treturn (NULL);\n      }\n    }\n  }\n\n  if (filetype && printer->filetypes &&\n      !cupsArrayFind(printer->filetypes, filetype))\n  {\n    char\tmimetype[MIME_MAX_SUPER + MIME_MAX_TYPE + 2];\n\t\t\t\t\t/* MIME media type string */\n\n\n    snprintf(mimetype, sizeof(mimetype), \"%s/%s\", filetype->super,\n             filetype->type);\n\n    send_ipp_status(con, IPP_DOCUMENT_FORMAT,\n                    _(\"Unsupported format \\\"%s\\\".\"), mimetype);\n\n    ippAddString(con->response, IPP_TAG_UNSUPPORTED_GROUP, IPP_TAG_MIMETYPE,\n                 \"document-format\", NULL, mimetype);\n\n    return (NULL);\n  }\n\n  if ((attr = ippFindAttribute(con->request, \"copies\",\n                               IPP_TAG_INTEGER)) != NULL)\n  {\n    if (attr->values[0].integer < 1 || attr->values[0].integer > MaxCopies)\n    {\n      send_ipp_status(con, IPP_ATTRIBUTES, _(\"Bad copies value %d.\"),\n                      attr->values[0].integer);\n      ippAddInteger(con->response, IPP_TAG_UNSUPPORTED_GROUP, IPP_TAG_INTEGER,\n\t            \"copies\", attr->values[0].integer);\n      return (NULL);\n    }\n  }\n\n  if ((attr = ippFindAttribute(con->request, \"job-sheets\",\n                               IPP_TAG_ZERO)) != NULL)\n  {\n    if (attr->value_tag != IPP_TAG_KEYWORD &&\n        attr->value_tag != IPP_TAG_NAME)\n    {\n      send_ipp_status(con, IPP_BAD_REQUEST, _(\"Bad job-sheets value type.\"));\n      return (NULL);\n    }\n\n    if (attr->num_values > 2)\n    {\n      send_ipp_status(con, IPP_BAD_REQUEST,\n                      _(\"Too many job-sheets values (%d > 2).\"),\n\t\t      attr->num_values);\n      return (NULL);\n    }\n\n    for (i = 0; i < attr->num_values; i ++)\n      if (strcmp(attr->values[i].string.text, \"none\") &&\n          !cupsdFindBanner(attr->values[i].string.text))\n      {\n\tsend_ipp_status(con, IPP_BAD_REQUEST, _(\"Bad job-sheets value \\\"%s\\\".\"),\n\t\t\tattr->values[i].string.text);\n\treturn (NULL);\n      }\n  }\n\n  if ((attr = ippFindAttribute(con->request, \"number-up\",\n                               IPP_TAG_INTEGER)) != NULL)\n  {\n    if (attr->values[0].integer != 1 &&\n        attr->values[0].integer != 2 &&\n        attr->values[0].integer != 4 &&\n        attr->values[0].integer != 6 &&\n        attr->values[0].integer != 9 &&\n        attr->values[0].integer != 16)\n    {\n      send_ipp_status(con, IPP_ATTRIBUTES, _(\"Bad number-up value %d.\"),\n                      attr->values[0].integer);\n      ippAddInteger(con->response, IPP_TAG_UNSUPPORTED_GROUP, IPP_TAG_INTEGER,\n\t            \"number-up\", attr->values[0].integer);\n      return (NULL);\n    }\n  }\n\n  if ((attr = ippFindAttribute(con->request, \"page-ranges\",\n                               IPP_TAG_RANGE)) != NULL)\n  {\n    for (i = 0, lowerpagerange = 1; i < attr->num_values; i ++)\n    {\n      if (attr->values[i].range.lower < lowerpagerange ||\n\t  attr->values[i].range.lower > attr->values[i].range.upper)\n      {\n\tsend_ipp_status(con, IPP_BAD_REQUEST,\n\t                _(\"Bad page-ranges values %d-%d.\"),\n\t                attr->values[i].range.lower,\n\t\t\tattr->values[i].range.upper);\n\treturn (NULL);\n      }\n\n      lowerpagerange = attr->values[i].range.upper + 1;\n    }\n  }\n\n /*\n  * Do media selection as needed...\n  */\n\n  if (!ippFindAttribute(con->request, \"PageRegion\", IPP_TAG_ZERO) &&\n      !ippFindAttribute(con->request, \"PageSize\", IPP_TAG_ZERO) &&\n      _ppdCacheGetPageSize(printer->pc, con->request, NULL, &exact))\n  {\n    if (!exact &&\n        (media_col = ippFindAttribute(con->request, \"media-col\",\n\t                              IPP_TAG_BEGIN_COLLECTION)) != NULL)\n    {\n      send_ipp_status(con, IPP_OK_SUBST, _(\"Unsupported margins.\"));\n\n      unsup_col = ippNew();\n      if ((media_margin = ippFindAttribute(media_col->values[0].collection,\n                                           \"media-bottom-margin\",\n\t\t\t\t\t   IPP_TAG_INTEGER)) != NULL)\n        ippAddInteger(unsup_col, IPP_TAG_ZERO, IPP_TAG_INTEGER,\n\t              \"media-bottom-margin\", media_margin->values[0].integer);\n\n      if ((media_margin = ippFindAttribute(media_col->values[0].collection,\n                                           \"media-left-margin\",\n\t\t\t\t\t   IPP_TAG_INTEGER)) != NULL)\n        ippAddInteger(unsup_col, IPP_TAG_ZERO, IPP_TAG_INTEGER,\n\t              \"media-left-margin\", media_margin->values[0].integer);\n\n      if ((media_margin = ippFindAttribute(media_col->values[0].collection,\n                                           \"media-right-margin\",\n\t\t\t\t\t   IPP_TAG_INTEGER)) != NULL)\n        ippAddInteger(unsup_col, IPP_TAG_ZERO, IPP_TAG_INTEGER,\n\t              \"media-right-margin\", media_margin->values[0].integer);\n\n      if ((media_margin = ippFindAttribute(media_col->values[0].collection,\n                                           \"media-top-margin\",\n\t\t\t\t\t   IPP_TAG_INTEGER)) != NULL)\n        ippAddInteger(unsup_col, IPP_TAG_ZERO, IPP_TAG_INTEGER,\n\t              \"media-top-margin\", media_margin->values[0].integer);\n\n      ippAddCollection(con->response, IPP_TAG_UNSUPPORTED_GROUP, \"media-col\",\n                       unsup_col);\n      ippDelete(unsup_col);\n    }\n  }\n\n /*\n  * Make sure we aren't over our limit...\n  */\n\n  if (MaxJobs && cupsArrayCount(Jobs) >= MaxJobs)\n    cupsdCleanJobs();\n\n  if (MaxJobs && cupsArrayCount(Jobs) >= MaxJobs)\n  {\n    send_ipp_status(con, IPP_NOT_POSSIBLE, _(\"Too many active jobs.\"));\n    return (NULL);\n  }\n\n  if ((i = check_quotas(con, printer)) < 0)\n  {\n    send_ipp_status(con, IPP_NOT_POSSIBLE, _(\"Quota limit reached.\"));\n    return (NULL);\n  }\n  else if (i == 0)\n  {\n    send_ipp_status(con, IPP_NOT_AUTHORIZED, _(\"Not allowed to print.\"));\n    return (NULL);\n  }\n\n /*\n  * Create the job and set things up...\n  */\n\n  if ((attr = ippFindAttribute(con->request, \"job-priority\",\n                               IPP_TAG_INTEGER)) != NULL)\n    priority = attr->values[0].integer;\n  else\n  {\n    if ((val = cupsGetOption(\"job-priority\", printer->num_options,\n                             printer->options)) != NULL)\n      priority = atoi(val);\n    else\n      priority = 50;\n\n    ippAddInteger(con->request, IPP_TAG_JOB, IPP_TAG_INTEGER, \"job-priority\",\n                  priority);\n  }\n\n  if ((attr = ippFindAttribute(con->request, \"job-name\", IPP_TAG_ZERO)) == NULL)\n    ippAddString(con->request, IPP_TAG_JOB, IPP_TAG_NAME, \"job-name\", NULL, \"Untitled\");\n  else if ((attr->value_tag != IPP_TAG_NAME &&\n            attr->value_tag != IPP_TAG_NAMELANG) ||\n           attr->num_values != 1)\n  {\n    send_ipp_status(con, IPP_ATTRIBUTES,\n                    _(\"Bad job-name value: Wrong type or count.\"));\n    if ((attr = ippCopyAttribute(con->response, attr, 0)) != NULL)\n      attr->group_tag = IPP_TAG_UNSUPPORTED_GROUP;\n    return (NULL);\n  }\n  else if (!ippValidateAttribute(attr))\n  {\n    send_ipp_status(con, IPP_ATTRIBUTES, _(\"Bad job-name value: %s\"),\n                    cupsLastErrorString());\n    if ((attr = ippCopyAttribute(con->response, attr, 0)) != NULL)\n      attr->group_tag = IPP_TAG_UNSUPPORTED_GROUP;\n    return (NULL);\n  }\n\n  if ((job = cupsdAddJob(priority, printer->name)) == NULL)\n  {\n    send_ipp_status(con, IPP_INTERNAL_ERROR,\n                    _(\"Unable to add job for destination \\\"%s\\\".\"),\n\t\t    printer->name);\n    return (NULL);\n  }\n\n  job->dtype   = printer->type & (CUPS_PRINTER_CLASS | CUPS_PRINTER_REMOTE);\n  job->attrs   = con->request;\n  job->dirty   = 1;\n  con->request = ippNewRequest(job->attrs->request.op.operation_id);\n\n  cupsdMarkDirty(CUPSD_DIRTY_JOBS);\n\n  add_job_uuid(job);\n  apply_printer_defaults(printer, job);\n\n  attr = ippFindAttribute(job->attrs, \"requesting-user-name\", IPP_TAG_NAME);\n\n  if (con->username[0])\n  {\n    cupsdSetString(&job->username, con->username);\n\n    if (attr)\n      ippSetString(job->attrs, &attr, 0, con->username);\n  }\n  else if (attr)\n  {\n    cupsdLogMessage(CUPSD_LOG_DEBUG,\n                    \"add_job: requesting-user-name=\\\"%s\\\"\",\n                    attr->values[0].string.text);\n\n    cupsdSetString(&job->username, attr->values[0].string.text);\n  }\n  else\n    cupsdSetString(&job->username, \"anonymous\");\n\n  if (!attr)\n    ippAddString(job->attrs, IPP_TAG_JOB, IPP_TAG_NAME,\n                 \"job-originating-user-name\", NULL, job->username);\n  else\n  {\n    ippSetGroupTag(job->attrs, &attr, IPP_TAG_JOB);\n    ippSetName(job->attrs, &attr, \"job-originating-user-name\");\n  }\n\n  if (con->username[0] || auth_info)\n  {\n    save_auth_info(con, job, auth_info);\n\n   /*\n    * Remove the auth-info attribute from the attribute data...\n    */\n\n    if (auth_info)\n      ippDeleteAttribute(job->attrs, auth_info);\n  }\n\n  if ((attr = ippFindAttribute(con->request, \"job-name\", IPP_TAG_NAME)) != NULL)\n    cupsdSetString(&(job->name), attr->values[0].string.text);\n\n  if ((attr = ippFindAttribute(job->attrs, \"job-originating-host-name\",\n                               IPP_TAG_ZERO)) != NULL)\n  {\n   /*\n    * Request contains a job-originating-host-name attribute; validate it...\n    */\n\n    if (attr->value_tag != IPP_TAG_NAME ||\n        attr->num_values != 1 ||\n        strcmp(con->http->hostname, \"localhost\"))\n    {\n     /*\n      * Can't override the value if we aren't connected via localhost.\n      * Also, we can only have 1 value and it must be a name value.\n      */\n\n      ippDeleteAttribute(job->attrs, attr);\n      ippAddString(job->attrs, IPP_TAG_JOB, IPP_TAG_NAME, \"job-originating-host-name\", NULL, con->http->hostname);\n    }\n    else\n      ippSetGroupTag(job->attrs, &attr, IPP_TAG_JOB);\n  }\n  else\n  {\n   /*\n    * No job-originating-host-name attribute, so use the hostname from\n    * the connection...\n    */\n\n    ippAddString(job->attrs, IPP_TAG_JOB, IPP_TAG_NAME,\n        \t \"job-originating-host-name\", NULL, con->http->hostname);\n  }\n\n  ippAddOutOfBand(job->attrs, IPP_TAG_JOB, IPP_TAG_NOVALUE, \"date-time-at-completed\");\n  ippAddDate(job->attrs, IPP_TAG_JOB, \"date-time-at-creation\", ippTimeToDate(time(NULL)));\n  ippAddOutOfBand(job->attrs, IPP_TAG_JOB, IPP_TAG_NOVALUE, \"date-time-at-processing\");\n  ippAddOutOfBand(job->attrs, IPP_TAG_JOB, IPP_TAG_NOVALUE, \"time-at-completed\");\n  ippAddInteger(job->attrs, IPP_TAG_JOB, IPP_TAG_INTEGER, \"time-at-creation\", time(NULL));\n  ippAddOutOfBand(job->attrs, IPP_TAG_JOB, IPP_TAG_NOVALUE, \"time-at-processing\");\n\n /*\n  * Add remaining job attributes...\n  */\n\n  ippAddInteger(job->attrs, IPP_TAG_JOB, IPP_TAG_INTEGER, \"job-id\", job->id);\n  job->state = ippAddInteger(job->attrs, IPP_TAG_JOB, IPP_TAG_ENUM,\n                             \"job-state\", IPP_JOB_STOPPED);\n  job->state_value = (ipp_jstate_t)job->state->values[0].integer;\n  job->reasons = ippAddString(job->attrs, IPP_TAG_JOB, IPP_TAG_KEYWORD,\n                              \"job-state-reasons\", NULL, \"job-incoming\");\n  job->impressions = ippAddInteger(job->attrs, IPP_TAG_JOB, IPP_TAG_INTEGER, \"job-impressions-completed\", 0);\n  job->sheets = ippAddInteger(job->attrs, IPP_TAG_JOB, IPP_TAG_INTEGER,\n                              \"job-media-sheets-completed\", 0);\n  ippAddString(job->attrs, IPP_TAG_JOB, IPP_TAG_URI, \"job-printer-uri\", NULL,\n               printer->uri);\n\n  if ((attr = ippFindAttribute(job->attrs, \"job-k-octets\", IPP_TAG_INTEGER)) != NULL)\n    attr->values[0].integer = 0;\n  else\n    ippAddInteger(job->attrs, IPP_TAG_JOB, IPP_TAG_INTEGER, \"job-k-octets\", 0);\n\n  if ((attr = ippFindAttribute(job->attrs, \"job-hold-until\",\n                               IPP_TAG_KEYWORD)) == NULL)\n    attr = ippFindAttribute(job->attrs, \"job-hold-until\", IPP_TAG_NAME);\n  if (!attr)\n  {\n    if ((val = cupsGetOption(\"job-hold-until\", printer->num_options,\n                             printer->options)) == NULL)\n      val = \"no-hold\";\n\n    attr = ippAddString(job->attrs, IPP_TAG_JOB, IPP_TAG_KEYWORD,\n                        \"job-hold-until\", NULL, val);\n  }\n\n  if (printer->holding_new_jobs)\n  {\n   /*\n    * Hold all new jobs on this printer...\n    */\n\n    if (attr && strcmp(attr->values[0].string.text, \"no-hold\"))\n      cupsdSetJobHoldUntil(job, ippGetString(attr, 0, NULL), 0);\n    else\n      cupsdSetJobHoldUntil(job, \"indefinite\", 0);\n\n    job->state->values[0].integer = IPP_JOB_HELD;\n    job->state_value              = IPP_JOB_HELD;\n\n    ippSetString(job->attrs, &job->reasons, 0, \"job-held-on-create\");\n  }\n  else if (attr && strcmp(attr->values[0].string.text, \"no-hold\"))\n  {\n   /*\n    * Hold job until specified time...\n    */\n\n    cupsdSetJobHoldUntil(job, attr->values[0].string.text, 0);\n\n    job->state->values[0].integer = IPP_JOB_HELD;\n    job->state_value              = IPP_JOB_HELD;\n\n    ippSetString(job->attrs, &job->reasons, 0, \"job-hold-until-specified\");\n  }\n  else if (job->attrs->request.op.operation_id == IPP_CREATE_JOB)\n  {\n    job->hold_until               = time(NULL) + MultipleOperationTimeout;\n    job->state->values[0].integer = IPP_JOB_HELD;\n    job->state_value              = IPP_JOB_HELD;\n  }\n  else\n  {\n    job->state->values[0].integer = IPP_JOB_PENDING;\n    job->state_value              = IPP_JOB_PENDING;\n\n    ippSetString(job->attrs, &job->reasons, 0, \"none\");\n  }\n\n  if (!(printer->type & CUPS_PRINTER_REMOTE) || Classification)\n  {\n   /*\n    * Add job sheets options...\n    */\n\n    if ((attr = ippFindAttribute(job->attrs, \"job-sheets\",\n                                 IPP_TAG_ZERO)) == NULL)\n    {\n      cupsdLogMessage(CUPSD_LOG_DEBUG,\n                      \"Adding default job-sheets values \\\"%s,%s\\\"...\",\n                      printer->job_sheets[0], printer->job_sheets[1]);\n\n      attr = ippAddStrings(job->attrs, IPP_TAG_JOB, IPP_TAG_NAME, \"job-sheets\",\n                           2, NULL, NULL);\n      ippSetString(job->attrs, &attr, 0, printer->job_sheets[0]);\n      ippSetString(job->attrs, &attr, 1, printer->job_sheets[1]);\n    }\n\n    job->job_sheets = attr;\n\n   /*\n    * Enforce classification level if set...\n    */\n\n    if (Classification)\n    {\n      cupsdLogMessage(CUPSD_LOG_INFO,\n                      \"Classification=\\\"%s\\\", ClassifyOverride=%d\",\n                      Classification ? Classification : \"(null)\",\n\t\t      ClassifyOverride);\n\n      if (ClassifyOverride)\n      {\n        if (!strcmp(attr->values[0].string.text, \"none\") &&\n\t    (attr->num_values == 1 ||\n\t     !strcmp(attr->values[1].string.text, \"none\")))\n        {\n\t /*\n          * Force the leading banner to have the classification on it...\n\t  */\n\n          ippSetString(job->attrs, &attr, 0, Classification);\n\n\t  cupsdLogJob(job, CUPSD_LOG_NOTICE, \"CLASSIFICATION FORCED \"\n\t                \t\t     \"job-sheets=\\\"%s,none\\\", \"\n\t\t\t\t\t     \"job-originating-user-name=\\\"%s\\\"\",\n\t              Classification, job->username);\n\t}\n\telse if (attr->num_values == 2 &&\n\t         strcmp(attr->values[0].string.text,\n\t\t        attr->values[1].string.text) &&\n\t\t strcmp(attr->values[0].string.text, \"none\") &&\n\t\t strcmp(attr->values[1].string.text, \"none\"))\n        {\n\t /*\n\t  * Can't put two different security markings on the same document!\n\t  */\n\n          ippSetString(job->attrs, &attr, 1, attr->values[0].string.text);\n\n\t  cupsdLogJob(job, CUPSD_LOG_NOTICE, \"CLASSIFICATION FORCED \"\n\t                \t\t     \"job-sheets=\\\"%s,%s\\\", \"\n\t\t\t\t\t     \"job-originating-user-name=\\\"%s\\\"\",\n\t\t      attr->values[0].string.text,\n\t\t      attr->values[1].string.text, job->username);\n\t}\n\telse if (strcmp(attr->values[0].string.text, Classification) &&\n\t         strcmp(attr->values[0].string.text, \"none\") &&\n\t\t (attr->num_values == 1 ||\n\t          (strcmp(attr->values[1].string.text, Classification) &&\n\t           strcmp(attr->values[1].string.text, \"none\"))))\n        {\n\t  if (attr->num_values == 1)\n            cupsdLogJob(job, CUPSD_LOG_NOTICE,\n\t\t\t\"CLASSIFICATION OVERRIDDEN \"\n\t\t\t\"job-sheets=\\\"%s\\\", \"\n\t\t\t\"job-originating-user-name=\\\"%s\\\"\",\n\t                attr->values[0].string.text, job->username);\n          else\n            cupsdLogJob(job, CUPSD_LOG_NOTICE,\n\t\t\t\"CLASSIFICATION OVERRIDDEN \"\n\t\t\t\"job-sheets=\\\"%s,%s\\\",fffff \"\n\t\t\t\"job-originating-user-name=\\\"%s\\\"\",\n\t\t\tattr->values[0].string.text,\n\t\t\tattr->values[1].string.text, job->username);\n        }\n      }\n      else if (strcmp(attr->values[0].string.text, Classification) &&\n               (attr->num_values == 1 ||\n\t       strcmp(attr->values[1].string.text, Classification)))\n      {\n       /*\n        * Force the banner to have the classification on it...\n\t*/\n\n        if (attr->num_values > 1 &&\n\t    !strcmp(attr->values[0].string.text, attr->values[1].string.text))\n\t{\n          ippSetString(job->attrs, &attr, 0, Classification);\n          ippSetString(job->attrs, &attr, 1, Classification);\n\t}\n        else\n\t{\n          if (attr->num_values == 1 ||\n\t      strcmp(attr->values[0].string.text, \"none\"))\n            ippSetString(job->attrs, &attr, 0, Classification);\n\n          if (attr->num_values > 1 &&\n\t      strcmp(attr->values[1].string.text, \"none\"))\n\t    ippSetString(job->attrs, &attr, 1, Classification);\n        }\n\n        if (attr->num_values > 1)\n\t  cupsdLogJob(job, CUPSD_LOG_NOTICE,\n\t\t      \"CLASSIFICATION FORCED \"\n\t\t      \"job-sheets=\\\"%s,%s\\\", \"\n\t\t      \"job-originating-user-name=\\\"%s\\\"\",\n\t\t      attr->values[0].string.text,\n\t\t      attr->values[1].string.text, job->username);\n        else\n\t  cupsdLogJob(job, CUPSD_LOG_NOTICE,\n\t\t      \"CLASSIFICATION FORCED \"\n\t\t      \"job-sheets=\\\"%s\\\", \"\n\t\t      \"job-originating-user-name=\\\"%s\\\"\",\n\t\t      Classification, job->username);\n      }\n    }\n\n   /*\n    * See if we need to add the starting sheet...\n    */\n\n    if (!(printer->type & CUPS_PRINTER_REMOTE))\n    {\n      cupsdLogJob(job, CUPSD_LOG_INFO, \"Adding start banner page \\\"%s\\\".\",\n\t\t  attr->values[0].string.text);\n\n      if ((kbytes = copy_banner(con, job, attr->values[0].string.text)) < 0)\n      {\n        cupsdSetJobState(job, IPP_JOB_ABORTED, CUPSD_JOB_PURGE,\n\t                 \"Aborting job because the start banner could not be \"\n\t\t\t \"copied.\");\n        return (NULL);\n      }\n\n      cupsdUpdateQuota(printer, job->username, 0, kbytes);\n    }\n  }\n  else if ((attr = ippFindAttribute(job->attrs, \"job-sheets\",\n                                    IPP_TAG_ZERO)) != NULL)\n    job->job_sheets = attr;\n\n /*\n  * Fill in the response info...\n  */\n\n  httpAssembleURIf(HTTP_URI_CODING_ALL, job_uri, sizeof(job_uri), \"ipp\", NULL,\n                   con->clientname, con->clientport, \"/jobs/%d\", job->id);\n  ippAddString(con->response, IPP_TAG_JOB, IPP_TAG_URI, \"job-uri\", NULL,\n               job_uri);\n\n  ippAddInteger(con->response, IPP_TAG_JOB, IPP_TAG_INTEGER, \"job-id\", job->id);\n\n  ippAddInteger(con->response, IPP_TAG_JOB, IPP_TAG_ENUM, \"job-state\",\n                job->state_value);\n  ippAddString(con->response, IPP_TAG_JOB, IPP_TAG_TEXT, \"job-state-message\", NULL, \"\");\n  ippAddString(con->response, IPP_TAG_JOB, IPP_TAG_KEYWORD, \"job-state-reasons\",\n               NULL, job->reasons->values[0].string.text);\n\n  con->response->request.status.status_code = IPP_OK;\n\n /*\n  * Add any job subscriptions...\n  */\n\n  add_job_subscriptions(con, job);\n\n /*\n  * Set all but the first two attributes to the job attributes group...\n  */\n\n  for (attr = job->attrs->attrs->next->next; attr; attr = attr->next)\n    attr->group_tag = IPP_TAG_JOB;\n\n /*\n  * Fire the \"job created\" event...\n  */\n\n  cupsdAddEvent(CUPSD_EVENT_JOB_CREATED, printer, job, \"Job created.\");\n\n /*\n  * Return the new job...\n  */\n\n  return (job);\n}\n\n\n/*\n * 'add_job_subscriptions()' - Add any subscriptions for a job.\n */\n\nstatic void\nadd_job_subscriptions(\n    cupsd_client_t *con,\t\t/* I - Client connection */\n    cupsd_job_t    *job)\t\t/* I - Newly created job */\n{\n  int\t\t\ti;\t\t/* Looping var */\n  ipp_attribute_t\t*prev,\t\t/* Previous attribute */\n\t\t\t*next,\t\t/* Next attribute */\n\t\t\t*attr;\t\t/* Current attribute */\n  cupsd_subscription_t\t*sub;\t\t/* Subscription object */\n  const char\t\t*recipient,\t/* notify-recipient-uri */\n\t\t\t*pullmethod;\t/* notify-pull-method */\n  ipp_attribute_t\t*user_data;\t/* notify-user-data */\n  int\t\t\tinterval;\t/* notify-time-interval */\n  unsigned\t\tmask;\t\t/* notify-events */\n\n\n /*\n  * Find the first subscription group attribute; return if we have\n  * none...\n  */\n\n  for (attr = job->attrs->attrs; attr; attr = attr->next)\n    if (attr->group_tag == IPP_TAG_SUBSCRIPTION)\n      break;\n\n  if (!attr)\n    return;\n\n /*\n  * Process the subscription attributes in the request...\n  */\n\n  while (attr)\n  {\n    recipient = NULL;\n    pullmethod = NULL;\n    user_data  = NULL;\n    interval   = 0;\n    mask       = CUPSD_EVENT_NONE;\n\n    while (attr && attr->group_tag != IPP_TAG_ZERO)\n    {\n      if (!strcmp(attr->name, \"notify-recipient-uri\") &&\n          attr->value_tag == IPP_TAG_URI)\n      {\n       /*\n        * Validate the recipient scheme against the ServerBin/notifier\n\t* directory...\n\t*/\n\n\tchar\tnotifier[1024],\t\t/* Notifier filename */\n\t\tscheme[HTTP_MAX_URI],\t/* Scheme portion of URI */\n\t\tuserpass[HTTP_MAX_URI],\t/* Username portion of URI */\n\t\thost[HTTP_MAX_URI],\t/* Host portion of URI */\n\t\tresource[HTTP_MAX_URI];\t/* Resource portion of URI */\n        int\tport;\t\t\t/* Port portion of URI */\n\n\n        recipient = attr->values[0].string.text;\n\n\tif (httpSeparateURI(HTTP_URI_CODING_ALL, recipient,\n\t                    scheme, sizeof(scheme), userpass, sizeof(userpass),\n\t\t\t    host, sizeof(host), &port,\n\t\t\t    resource, sizeof(resource)) < HTTP_URI_OK)\n        {\n          send_ipp_status(con, IPP_NOT_POSSIBLE,\n\t                  _(\"Bad notify-recipient-uri \\\"%s\\\".\"), recipient);\n\t  ippAddInteger(con->response, IPP_TAG_SUBSCRIPTION, IPP_TAG_ENUM,\n\t                \"notify-status-code\", IPP_URI_SCHEME);\n\t  return;\n\t}\n\n        snprintf(notifier, sizeof(notifier), \"%s/notifier/%s\", ServerBin,\n\t         scheme);\n        if (access(notifier, X_OK))\n\t{\n          send_ipp_status(con, IPP_NOT_POSSIBLE,\n\t                  _(\"notify-recipient-uri URI \\\"%s\\\" uses unknown \"\n\t\t\t    \"scheme.\"), recipient);\n\t  ippAddInteger(con->response, IPP_TAG_SUBSCRIPTION, IPP_TAG_ENUM,\n\t                \"notify-status-code\", IPP_URI_SCHEME);\n\t  return;\n\t}\n\n        if (!strcmp(scheme, \"rss\") && !check_rss_recipient(recipient))\n\t{\n          send_ipp_status(con, IPP_NOT_POSSIBLE,\n\t                  _(\"notify-recipient-uri URI \\\"%s\\\" is already used.\"),\n\t\t\t  recipient);\n\t  ippAddInteger(con->response, IPP_TAG_SUBSCRIPTION, IPP_TAG_ENUM,\n\t                \"notify-status-code\", IPP_ATTRIBUTES);\n\t  return;\n\t}\n      }\n      else if (!strcmp(attr->name, \"notify-pull-method\") &&\n               attr->value_tag == IPP_TAG_KEYWORD)\n      {\n        pullmethod = attr->values[0].string.text;\n\n        if (strcmp(pullmethod, \"ippget\"))\n\t{\n          send_ipp_status(con, IPP_NOT_POSSIBLE,\n\t                  _(\"Bad notify-pull-method \\\"%s\\\".\"), pullmethod);\n\t  ippAddInteger(con->response, IPP_TAG_SUBSCRIPTION, IPP_TAG_ENUM,\n\t                \"notify-status-code\", IPP_ATTRIBUTES);\n\t  return;\n\t}\n      }\n      else if (!strcmp(attr->name, \"notify-charset\") &&\n               attr->value_tag == IPP_TAG_CHARSET &&\n\t       strcmp(attr->values[0].string.text, \"us-ascii\") &&\n\t       strcmp(attr->values[0].string.text, \"utf-8\"))\n      {\n        send_ipp_status(con, IPP_CHARSET,\n\t                _(\"Character set \\\"%s\\\" not supported.\"),\n\t\t\tattr->values[0].string.text);\n\treturn;\n      }\n      else if (!strcmp(attr->name, \"notify-natural-language\") &&\n               (attr->value_tag != IPP_TAG_LANGUAGE ||\n\t        strcmp(attr->values[0].string.text, DefaultLanguage)))\n      {\n        send_ipp_status(con, IPP_CHARSET,\n\t                _(\"Language \\\"%s\\\" not supported.\"),\n\t\t\tattr->values[0].string.text);\n\treturn;\n      }\n      else if (!strcmp(attr->name, \"notify-user-data\") &&\n               attr->value_tag == IPP_TAG_STRING)\n      {\n        if (attr->num_values > 1 || attr->values[0].unknown.length > 63)\n\t{\n          send_ipp_status(con, IPP_REQUEST_VALUE,\n\t                  _(\"The notify-user-data value is too large \"\n\t\t\t    \"(%d > 63 octets).\"),\n\t\t\t  attr->values[0].unknown.length);\n\t  return;\n\t}\n\n        user_data = attr;\n      }\n      else if (!strcmp(attr->name, \"notify-events\") &&\n               attr->value_tag == IPP_TAG_KEYWORD)\n      {\n        for (i = 0; i < attr->num_values; i ++)\n\t  mask |= cupsdEventValue(attr->values[i].string.text);\n      }\n      else if (!strcmp(attr->name, \"notify-lease-duration\"))\n      {\n        send_ipp_status(con, IPP_BAD_REQUEST,\n\t                _(\"The notify-lease-duration attribute cannot be \"\n\t\t\t  \"used with job subscriptions.\"));\n\treturn;\n      }\n      else if (!strcmp(attr->name, \"notify-time-interval\") &&\n               attr->value_tag == IPP_TAG_INTEGER)\n        interval = attr->values[0].integer;\n\n      attr = attr->next;\n    }\n\n    if (!recipient && !pullmethod)\n      break;\n\n    if (mask == CUPSD_EVENT_NONE)\n      mask = CUPSD_EVENT_JOB_COMPLETED;\n\n    if ((sub = cupsdAddSubscription(mask, cupsdFindDest(job->dest), job,\n                                    recipient, 0)) != NULL)\n    {\n      sub->interval = interval;\n\n      cupsdSetString(&sub->owner, job->username);\n\n      if (user_data)\n      {\n\tsub->user_data_len = user_data->values[0].unknown.length;\n\tmemcpy(sub->user_data, user_data->values[0].unknown.data,\n\t       (size_t)sub->user_data_len);\n      }\n\n      ippAddSeparator(con->response);\n      ippAddInteger(con->response, IPP_TAG_SUBSCRIPTION, IPP_TAG_INTEGER,\n\t\t    \"notify-subscription-id\", sub->id);\n\n      cupsdLogMessage(CUPSD_LOG_DEBUG, \"Added subscription %d for job %d\",\n                      sub->id, job->id);\n    }\n\n    if (attr)\n      attr = attr->next;\n  }\n\n  cupsdMarkDirty(CUPSD_DIRTY_SUBSCRIPTIONS);\n\n /*\n  * Remove all of the subscription attributes from the job request...\n  *\n  * TODO: Optimize this since subscription groups have to come at the\n  * end of the request...\n  */\n\n  for (attr = job->attrs->attrs, prev = NULL; attr; attr = next)\n  {\n    next = attr->next;\n\n    if (attr->group_tag == IPP_TAG_SUBSCRIPTION ||\n        attr->group_tag == IPP_TAG_ZERO)\n    {\n     /*\n      * Free and remove this attribute...\n      */\n\n      ippDeleteAttribute(NULL, attr);\n\n      if (prev)\n        prev->next = next;\n      else\n        job->attrs->attrs = next;\n    }\n    else\n      prev = attr;\n  }\n\n  job->attrs->last    = prev;\n  job->attrs->current = prev;\n}\n\n\n/*\n * 'add_job_uuid()' - Add job-uuid attribute to a job.\n *\n * See RFC 4122 for the definition of UUIDs and the format.\n */\n\nstatic void\nadd_job_uuid(cupsd_job_t *job)\t\t/* I - Job */\n{\n  char\t\t\tuuid[64];\t/* job-uuid string */\n\n\n /*\n  * Add a job-uuid attribute if none exists...\n  */\n\n  if (!ippFindAttribute(job->attrs, \"job-uuid\", IPP_TAG_URI))\n    ippAddString(job->attrs, IPP_TAG_JOB, IPP_TAG_URI, \"job-uuid\", NULL,\n\t\t httpAssembleUUID(ServerName, RemotePort, job->dest, job->id,\n\t\t                  uuid, sizeof(uuid)));\n}\n\n\n/*\n * 'add_printer()' - Add a printer to the system.\n */\n\nstatic void\nadd_printer(cupsd_client_t  *con,\t/* I - Client connection */\n            ipp_attribute_t *uri)\t/* I - URI of printer */\n{\n  http_status_t\tstatus;\t\t\t/* Policy status */\n  int\t\ti;\t\t\t/* Looping var */\n  char\t\tscheme[HTTP_MAX_URI],\t/* Method portion of URI */\n\t\tusername[HTTP_MAX_URI],\t/* Username portion of URI */\n\t\thost[HTTP_MAX_URI],\t/* Host portion of URI */\n\t\tresource[HTTP_MAX_URI];\t/* Resource portion of URI */\n  int\t\tport;\t\t\t/* Port portion of URI */\n  cupsd_printer_t *printer;\t\t/* Printer/class */\n  ipp_attribute_t *attr;\t\t/* Printer attribute */\n  cups_file_t\t*fp;\t\t\t/* Script/PPD file */\n  char\t\tline[1024];\t\t/* Line from file... */\n  char\t\tsrcfile[1024],\t\t/* Source Script/PPD file */\n\t\tdstfile[1024];\t\t/* Destination Script/PPD file */\n  int\t\tmodify;\t\t\t/* Non-zero if we are modifying */\n  int\t\tchanged_driver,\t\t/* Changed the PPD? */\n\t\tneed_restart_job,\t/* Need to restart job? */\n\t\tset_device_uri,\t\t/* Did we set the device URI? */\n\t\tset_port_monitor;\t/* Did we set the port monitor? */\n\n\n  cupsdLogMessage(CUPSD_LOG_DEBUG2, \"add_printer(%p[%d], %s)\", con,\n                  con->number, uri->values[0].string.text);\n\n /*\n  * Do we have a valid URI?\n  */\n\n  httpSeparateURI(HTTP_URI_CODING_ALL, uri->values[0].string.text, scheme,\n                  sizeof(scheme), username, sizeof(username), host,\n\t\t  sizeof(host), &port, resource, sizeof(resource));\n\n  if (strncmp(resource, \"/printers/\", 10) || strlen(resource) == 10)\n  {\n   /*\n    * No, return an error...\n    */\n\n    send_ipp_status(con, IPP_BAD_REQUEST,\n                    _(\"The printer-uri must be of the form \"\n\t\t      \"\\\"ipp://HOSTNAME/printers/PRINTERNAME\\\".\"));\n    return;\n  }\n\n /*\n  * Do we have a valid printer name?\n  */\n\n  if (!validate_name(resource + 10))\n  {\n   /*\n    * No, return an error...\n    */\n\n    send_ipp_status(con, IPP_BAD_REQUEST,\n                    _(\"The printer-uri \\\"%s\\\" contains invalid characters.\"),\n\t\t    uri->values[0].string.text);\n    return;\n  }\n\n /*\n  * See if the printer already exists; if not, create a new printer...\n  */\n\n  if ((printer = cupsdFindPrinter(resource + 10)) == NULL)\n  {\n   /*\n    * Printer doesn't exist; see if we have a class of the same name...\n    */\n\n    if ((printer = cupsdFindClass(resource + 10)) != NULL)\n    {\n     /*\n      * Yes, return an error...\n      */\n\n      send_ipp_status(con, IPP_NOT_POSSIBLE,\n                      _(\"A class named \\\"%s\\\" already exists.\"),\n        \t      resource + 10);\n      return;\n    }\n\n   /*\n    * No, check the default policy then add the printer...\n    */\n\n    if ((status = cupsdCheckPolicy(DefaultPolicyPtr, con, NULL)) != HTTP_OK)\n    {\n      send_http_error(con, status, NULL);\n      return;\n    }\n\n    printer = cupsdAddPrinter(resource + 10);\n    modify  = 0;\n  }\n  else if ((status = cupsdCheckPolicy(printer->op_policy_ptr, con,\n                                      NULL)) != HTTP_OK)\n  {\n    send_http_error(con, status, printer);\n    return;\n  }\n  else\n    modify = 1;\n\n /*\n  * Look for attributes and copy them over as needed...\n  */\n\n  changed_driver   = 0;\n  need_restart_job = 0;\n\n  if ((attr = ippFindAttribute(con->request, \"printer-is-temporary\", IPP_TAG_BOOLEAN)) != NULL)\n    printer->temporary = ippGetBoolean(attr, 0);\n\n  if ((attr = ippFindAttribute(con->request, \"printer-location\",\n                               IPP_TAG_TEXT)) != NULL)\n    cupsdSetString(&printer->location, attr->values[0].string.text);\n\n  if ((attr = ippFindAttribute(con->request, \"printer-geo-location\", IPP_TAG_URI)) != NULL && !strncmp(attr->values[0].string.text, \"geo:\", 4))\n    cupsdSetString(&printer->geo_location, attr->values[0].string.text);\n\n  if ((attr = ippFindAttribute(con->request, \"printer-organization\", IPP_TAG_TEXT)) != NULL)\n    cupsdSetString(&printer->organization, attr->values[0].string.text);\n\n  if ((attr = ippFindAttribute(con->request, \"printer-organizational-unit\", IPP_TAG_TEXT)) != NULL)\n    cupsdSetString(&printer->organizational_unit, attr->values[0].string.text);\n\n  if ((attr = ippFindAttribute(con->request, \"printer-info\",\n                               IPP_TAG_TEXT)) != NULL)\n    cupsdSetString(&printer->info, attr->values[0].string.text);\n\n  set_device_uri = 0;\n\n  if ((attr = ippFindAttribute(con->request, \"device-uri\",\n                               IPP_TAG_URI)) != NULL)\n  {\n   /*\n    * Do we have a valid device URI?\n    */\n\n    http_uri_status_t\turi_status;\t/* URI separation status */\n    char\t\told_device_uri[1024];\n\t\t\t\t\t/* Old device URI */\n\n    need_restart_job = 1;\n\n    uri_status = httpSeparateURI(HTTP_URI_CODING_ALL,\n\t\t\t\t attr->values[0].string.text,\n\t\t\t\t scheme, sizeof(scheme),\n\t\t\t\t username, sizeof(username),\n\t\t\t\t host, sizeof(host), &port,\n\t\t\t\t resource, sizeof(resource));\n\n    cupsdLogMessage(CUPSD_LOG_DEBUG, \"%s device-uri: %s\", printer->name, httpURIStatusString(uri_status));\n\n    if (uri_status < HTTP_URI_OK)\n    {\n      send_ipp_status(con, IPP_NOT_POSSIBLE, _(\"Bad device-uri \\\"%s\\\".\"),\n\t\t      attr->values[0].string.text);\n      if (!modify)\n        cupsdDeletePrinter(printer, 0);\n\n      return;\n    }\n\n    if (!strcmp(scheme, \"file\"))\n    {\n     /*\n      * See if the administrator has enabled file devices...\n      */\n\n      if (!FileDevice && strcmp(resource, \"/dev/null\"))\n      {\n       /*\n        * File devices are disabled and the URL is not file:/dev/null...\n\t*/\n\n\tsend_ipp_status(con, IPP_NOT_POSSIBLE,\n\t                _(\"File device URIs have been disabled. \"\n\t                  \"To enable, see the FileDevice directive in \"\n\t\t\t  \"\\\"%s/cups-files.conf\\\".\"),\n\t\t\tServerRoot);\n\tif (!modify)\n\t  cupsdDeletePrinter(printer, 0);\n\n\treturn;\n      }\n    }\n    else\n    {\n     /*\n      * See if the backend exists and is executable...\n      */\n\n      snprintf(srcfile, sizeof(srcfile), \"%s/backend/%s\", ServerBin, scheme);\n      if (access(srcfile, X_OK))\n      {\n       /*\n        * Could not find device in list!\n\t*/\n\n\tsend_ipp_status(con, IPP_NOT_POSSIBLE,\n                        _(\"Bad device-uri scheme \\\"%s\\\".\"), scheme);\n\tif (!modify)\n\t  cupsdDeletePrinter(printer, 0);\n\n\treturn;\n      }\n    }\n\n    if (printer->sanitized_device_uri)\n      strlcpy(old_device_uri, printer->sanitized_device_uri,\n              sizeof(old_device_uri));\n    else\n      old_device_uri[0] = '\\0';\n\n    cupsdSetDeviceURI(printer, attr->values[0].string.text);\n\n    cupsdLogMessage(CUPSD_LOG_INFO,\n                    \"Setting %s device-uri to \\\"%s\\\" (was \\\"%s\\\".)\",\n        \t    printer->name, printer->sanitized_device_uri,\n\t\t    old_device_uri);\n\n    set_device_uri = 1;\n  }\n\n  set_port_monitor = 0;\n\n  if ((attr = ippFindAttribute(con->request, \"port-monitor\",\n                               IPP_TAG_NAME)) != NULL)\n  {\n    ipp_attribute_t\t*supported;\t/* port-monitor-supported attribute */\n\n\n    need_restart_job = 1;\n\n    supported = ippFindAttribute(printer->ppd_attrs, \"port-monitor-supported\",\n                                 IPP_TAG_NAME);\n    if (supported)\n    {\n      for (i = 0; i < supported->num_values; i ++)\n        if (!strcmp(supported->values[i].string.text,\n                    attr->values[0].string.text))\n          break;\n    }\n\n    if (!supported || i >= supported->num_values)\n    {\n      send_ipp_status(con, IPP_NOT_POSSIBLE, _(\"Bad port-monitor \\\"%s\\\".\"),\n        \t      attr->values[0].string.text);\n      if (!modify)\n        cupsdDeletePrinter(printer, 0);\n\n      return;\n    }\n\n    cupsdLogMessage(CUPSD_LOG_INFO,\n                    \"Setting %s port-monitor to \\\"%s\\\" (was \\\"%s\\\".)\",\n                    printer->name, attr->values[0].string.text,\n\t            printer->port_monitor ? printer->port_monitor : \"none\");\n\n    if (strcmp(attr->values[0].string.text, \"none\"))\n      cupsdSetString(&printer->port_monitor, attr->values[0].string.text);\n    else\n      cupsdClearString(&printer->port_monitor);\n\n    set_port_monitor = 1;\n  }\n\n  if ((attr = ippFindAttribute(con->request, \"printer-is-accepting-jobs\",\n                               IPP_TAG_BOOLEAN)) != NULL &&\n      attr->values[0].boolean != printer->accepting)\n  {\n    cupsdLogMessage(CUPSD_LOG_INFO,\n                    \"Setting %s printer-is-accepting-jobs to %d (was %d.)\",\n                    printer->name, attr->values[0].boolean, printer->accepting);\n\n    printer->accepting = attr->values[0].boolean;\n\n    cupsdAddEvent(CUPSD_EVENT_PRINTER_STATE, printer, NULL,\n                  \"%s accepting jobs.\",\n\t\t  printer->accepting ? \"Now\" : \"No longer\");\n  }\n\n  if ((attr = ippFindAttribute(con->request, \"printer-is-shared\", IPP_TAG_BOOLEAN)) != NULL)\n  {\n    if (ippGetBoolean(attr, 0) &&\n        printer->num_auth_info_required == 1 &&\n\t!strcmp(printer->auth_info_required[0], \"negotiate\"))\n    {\n      send_ipp_status(con, IPP_BAD_REQUEST,\n                      _(\"Cannot share a remote Kerberized printer.\"));\n      if (!modify)\n        cupsdDeletePrinter(printer, 0);\n\n      return;\n    }\n\n    if (printer->type & CUPS_PRINTER_REMOTE)\n    {\n     /*\n      * Cannot re-share remote printers.\n      */\n\n      send_ipp_status(con, IPP_BAD_REQUEST, _(\"Cannot change printer-is-shared for remote queues.\"));\n      if (!modify)\n        cupsdDeletePrinter(printer, 0);\n\n      return;\n    }\n\n    if (printer->shared && !ippGetBoolean(attr, 0))\n      cupsdDeregisterPrinter(printer, 1);\n\n    cupsdLogMessage(CUPSD_LOG_INFO,\n                    \"Setting %s printer-is-shared to %d (was %d.)\",\n                    printer->name, attr->values[0].boolean, printer->shared);\n\n    printer->shared = ippGetBoolean(attr, 0);\n    if (printer->shared && printer->temporary)\n      printer->temporary = 0;\n  }\n\n  if ((attr = ippFindAttribute(con->request, \"printer-state\",\n                               IPP_TAG_ENUM)) != NULL)\n  {\n    if (attr->values[0].integer != IPP_PRINTER_IDLE &&\n        attr->values[0].integer != IPP_PRINTER_STOPPED)\n    {\n      send_ipp_status(con, IPP_BAD_REQUEST, _(\"Bad printer-state value %d.\"),\n                      attr->values[0].integer);\n      if (!modify)\n        cupsdDeletePrinter(printer, 0);\n\n      return;\n    }\n\n    cupsdLogMessage(CUPSD_LOG_INFO, \"Setting %s printer-state to %d (was %d.)\",\n                    printer->name, attr->values[0].integer, printer->state);\n\n    if (attr->values[0].integer == IPP_PRINTER_STOPPED)\n      cupsdStopPrinter(printer, 0);\n    else\n    {\n      need_restart_job = 1;\n      cupsdSetPrinterState(printer, (ipp_pstate_t)(attr->values[0].integer), 0);\n    }\n  }\n\n  if ((attr = ippFindAttribute(con->request, \"printer-state-message\",\n                               IPP_TAG_TEXT)) != NULL)\n  {\n    strlcpy(printer->state_message, attr->values[0].string.text,\n            sizeof(printer->state_message));\n\n    cupsdAddEvent(CUPSD_EVENT_PRINTER_STATE, printer, NULL, \"%s\",\n                  printer->state_message);\n  }\n\n  if ((attr = ippFindAttribute(con->request, \"printer-state-reasons\",\n                               IPP_TAG_KEYWORD)) != NULL)\n  {\n    if (attr->num_values >\n            (int)(sizeof(printer->reasons) / sizeof(printer->reasons[0])))\n    {\n      send_ipp_status(con, IPP_NOT_POSSIBLE,\n                      _(\"Too many printer-state-reasons values (%d > %d).\"),\n\t\t      attr->num_values,\n\t\t      (int)(sizeof(printer->reasons) /\n\t\t            sizeof(printer->reasons[0])));\n      if (!modify)\n        cupsdDeletePrinter(printer, 0);\n\n      return;\n    }\n\n    for (i = 0; i < printer->num_reasons; i ++)\n      _cupsStrFree(printer->reasons[i]);\n\n    printer->num_reasons = 0;\n    for (i = 0; i < attr->num_values; i ++)\n    {\n      if (!strcmp(attr->values[i].string.text, \"none\"))\n        continue;\n\n      printer->reasons[printer->num_reasons] =\n          _cupsStrRetain(attr->values[i].string.text);\n      printer->num_reasons ++;\n\n      if (!strcmp(attr->values[i].string.text, \"paused\") &&\n          printer->state != IPP_PRINTER_STOPPED)\n      {\n\tcupsdLogMessage(CUPSD_LOG_INFO,\n\t                \"Setting %s printer-state to %d (was %d.)\",\n\t\t\tprinter->name, IPP_PRINTER_STOPPED, printer->state);\n\tcupsdStopPrinter(printer, 0);\n      }\n    }\n\n    if (PrintcapFormat == PRINTCAP_PLIST)\n      cupsdMarkDirty(CUPSD_DIRTY_PRINTCAP);\n\n    cupsdAddEvent(CUPSD_EVENT_PRINTER_STATE, printer, NULL,\n                  \"Printer \\\"%s\\\" state changed.\", printer->name);\n  }\n\n  if (!set_printer_defaults(con, printer))\n  {\n    if (!modify)\n      cupsdDeletePrinter(printer, 0);\n\n    return;\n  }\n\n  if ((attr = ippFindAttribute(con->request, \"auth-info-required\",\n                               IPP_TAG_KEYWORD)) != NULL)\n    cupsdSetAuthInfoRequired(printer, NULL, attr);\n\n /*\n  * See if we have all required attributes...\n  */\n\n  if (!printer->device_uri)\n    cupsdSetString(&printer->device_uri, \"file:///dev/null\");\n\n /*\n  * See if we have a PPD file attached to the request...\n  */\n\n  if (con->filename)\n  {\n    need_restart_job = 1;\n    changed_driver   = 1;\n\n    strlcpy(srcfile, con->filename, sizeof(srcfile));\n\n    if ((fp = cupsFileOpen(srcfile, \"rb\")))\n    {\n     /*\n      * Yes; get the first line from it...\n      */\n\n      line[0] = '\\0';\n      cupsFileGets(fp, line, sizeof(line));\n      cupsFileClose(fp);\n\n     /*\n      * Then see what kind of file it is...\n      */\n\n      if (strncmp(line, \"*PPD-Adobe\", 10))\n      {\n\tsend_ipp_status(con, IPP_STATUS_ERROR_DOCUMENT_FORMAT_NOT_SUPPORTED, _(\"Bad PPD file.\"));\n\tif (!modify)\n\t  cupsdDeletePrinter(printer, 0);\n\n\treturn;\n      }\n\n      snprintf(dstfile, sizeof(dstfile), \"%s/ppd/%s.ppd\", ServerRoot,\n               printer->name);\n\n     /*\n      * The new file is a PPD file, so move the file over to the ppd\n      * directory...\n      */\n\n      if (copy_file(srcfile, dstfile, ConfigFilePerm))\n      {\n\tsend_ipp_status(con, IPP_INTERNAL_ERROR, _(\"Unable to copy PPD file - %s\"), strerror(errno));\n\tif (!modify)\n\t  cupsdDeletePrinter(printer, 0);\n\n\treturn;\n      }\n\n      cupsdLogMessage(CUPSD_LOG_DEBUG, \"Copied PPD file successfully\");\n    }\n  }\n  else if ((attr = ippFindAttribute(con->request, \"ppd-name\", IPP_TAG_NAME)) != NULL)\n  {\n    const char *ppd_name = ippGetString(attr, 0, NULL);\n\t\t\t\t\t/* ppd-name value */\n\n    need_restart_job = 1;\n    changed_driver   = 1;\n\n    if (!strcmp(ppd_name, \"raw\"))\n    {\n     /*\n      * Raw driver, remove any existing PPD file.\n      */\n\n      snprintf(dstfile, sizeof(dstfile), \"%s/ppd/%s.ppd\", ServerRoot, printer->name);\n      unlink(dstfile);\n    }\n    else if (strstr(ppd_name, \"../\"))\n    {\n      send_ipp_status(con, IPP_STATUS_ERROR_ATTRIBUTES_OR_VALUES, _(\"Invalid ppd-name value.\"));\n      if (!modify)\n\tcupsdDeletePrinter(printer, 0);\n\n      return;\n    }\n    else\n    {\n     /*\n      * PPD model file...\n      */\n\n      snprintf(dstfile, sizeof(dstfile), \"%s/ppd/%s.ppd\", ServerRoot, printer->name);\n\n      if (copy_model(con, ppd_name, dstfile))\n      {\n        send_ipp_status(con, IPP_INTERNAL_ERROR, _(\"Unable to copy PPD file.\"));\n\tif (!modify)\n\t  cupsdDeletePrinter(printer, 0);\n\n\treturn;\n      }\n\n      cupsdLogMessage(CUPSD_LOG_DEBUG, \"Copied PPD file successfully\");\n    }\n  }\n\n  if (changed_driver)\n  {\n   /*\n    * If we changed the PPD, then remove the printer's cache file and clear the\n    * printer-state-reasons...\n    */\n\n    char cache_name[1024];\t\t/* Cache filename for printer attrs */\n\n    snprintf(cache_name, sizeof(cache_name), \"%s/%s.data\", CacheDir, printer->name);\n    unlink(cache_name);\n\n    cupsdSetPrinterReasons(printer, \"none\");\n\n   /*\n    * (Re)register color profiles...\n    */\n\n    cupsdRegisterColor(printer);\n  }\n\n /*\n  * If we set the device URI but not the port monitor, check which port\n  * monitor to use by default...\n  */\n\n  if (set_device_uri && !set_port_monitor)\n  {\n    ppd_file_t\t*ppd;\t\t\t/* PPD file */\n    ppd_attr_t\t*ppdattr;\t\t/* cupsPortMonitor attribute */\n\n\n    httpSeparateURI(HTTP_URI_CODING_ALL, printer->device_uri, scheme,\n                    sizeof(scheme), username, sizeof(username), host,\n\t\t    sizeof(host), &port, resource, sizeof(resource));\n\n    snprintf(srcfile, sizeof(srcfile), \"%s/ppd/%s.ppd\", ServerRoot,\n\t     printer->name);\n    if ((ppd = _ppdOpenFile(srcfile, _PPD_LOCALIZATION_NONE)) != NULL)\n    {\n      for (ppdattr = ppdFindAttr(ppd, \"cupsPortMonitor\", NULL);\n\t   ppdattr;\n\t   ppdattr = ppdFindNextAttr(ppd, \"cupsPortMonitor\", NULL))\n        if (!strcmp(scheme, ppdattr->spec))\n\t{\n\t  cupsdLogMessage(CUPSD_LOG_INFO,\n\t\t\t  \"Setting %s port-monitor to \\\"%s\\\" (was \\\"%s\\\".)\",\n\t\t\t  printer->name, ppdattr->value,\n\t\t\t  printer->port_monitor ? printer->port_monitor\n\t\t\t                        : \"none\");\n\n\t  if (strcmp(ppdattr->value, \"none\"))\n\t    cupsdSetString(&printer->port_monitor, ppdattr->value);\n\t  else\n\t    cupsdClearString(&printer->port_monitor);\n\n\t  break;\n\t}\n\n      ppdClose(ppd);\n    }\n  }\n\n  printer->config_time = time(NULL);\n\n /*\n  * Update the printer attributes and return...\n  */\n\n  cupsdSetPrinterAttrs(printer);\n  if (!printer->temporary)\n    cupsdMarkDirty(CUPSD_DIRTY_PRINTERS);\n\n  if (need_restart_job && printer->job)\n  {\n   /*\n    * Restart the current job...\n    */\n\n    cupsdSetJobState(printer->job, IPP_JOB_PENDING, CUPSD_JOB_FORCE,\n                     \"Job restarted because the printer was modified.\");\n  }\n\n  cupsdMarkDirty(CUPSD_DIRTY_PRINTCAP);\n\n  if (modify)\n  {\n    cupsdAddEvent(CUPSD_EVENT_PRINTER_MODIFIED,\n                  printer, NULL, \"Printer \\\"%s\\\" modified by \\\"%s\\\".\",\n\t\t  printer->name, get_username(con));\n\n    cupsdLogMessage(CUPSD_LOG_INFO, \"Printer \\\"%s\\\" modified by \\\"%s\\\".\",\n                    printer->name, get_username(con));\n  }\n  else\n  {\n    cupsdAddEvent(CUPSD_EVENT_PRINTER_ADDED,\n                  printer, NULL, \"New printer \\\"%s\\\" added by \\\"%s\\\".\",\n\t\t  printer->name, get_username(con));\n\n    cupsdLogMessage(CUPSD_LOG_INFO, \"New printer \\\"%s\\\" added by \\\"%s\\\".\",\n                    printer->name, get_username(con));\n  }\n\n  con->response->request.status.status_code = IPP_OK;\n}\n\n\n/*\n * 'add_printer_state_reasons()' - Add the \"printer-state-reasons\" attribute\n *                                 based upon the printer state...\n */\n\nstatic void\nadd_printer_state_reasons(\n    cupsd_client_t  *con,\t\t/* I - Client connection */\n    cupsd_printer_t *p)\t\t\t/* I - Printer info */\n{\n  cupsdLogMessage(CUPSD_LOG_DEBUG2,\n                  \"add_printer_state_reasons(%p[%d], %p[%s])\",\n                  con, con->number, p, p->name);\n\n  if (p->num_reasons == 0)\n    ippAddString(con->response, IPP_TAG_PRINTER, IPP_TAG_KEYWORD,\n                 \"printer-state-reasons\", NULL, \"none\");\n  else\n    ippAddStrings(con->response, IPP_TAG_PRINTER, IPP_TAG_KEYWORD,\n                  \"printer-state-reasons\", p->num_reasons, NULL,\n\t\t  (const char * const *)p->reasons);\n}\n\n\n/*\n * 'add_queued_job_count()' - Add the \"queued-job-count\" attribute for\n *                            the specified printer or class.\n */\n\nstatic void\nadd_queued_job_count(\n    cupsd_client_t  *con,\t\t/* I - Client connection */\n    cupsd_printer_t *p)\t\t\t/* I - Printer or class */\n{\n  int\t\tcount;\t\t\t/* Number of jobs on destination */\n\n\n  cupsdLogMessage(CUPSD_LOG_DEBUG2, \"add_queued_job_count(%p[%d], %p[%s])\",\n                  con, con->number, p, p->name);\n\n  count = cupsdGetPrinterJobCount(p->name);\n\n  ippAddInteger(con->response, IPP_TAG_PRINTER, IPP_TAG_INTEGER,\n                \"queued-job-count\", count);\n}\n\n\n/*\n * 'apply_printer_defaults()' - Apply printer default options to a job.\n */\n\nstatic void\napply_printer_defaults(\n    cupsd_printer_t *printer,\t\t/* I - Printer */\n    cupsd_job_t     *job)\t\t/* I - Job */\n{\n  int\t\ti,\t\t\t/* Looping var */\n\t\tnum_options;\t\t/* Number of default options */\n  cups_option_t\t*options,\t\t/* Default options */\n\t\t*option;\t\t/* Current option */\n\n\n  cupsdLogJob(job, CUPSD_LOG_DEBUG, \"Applying default options...\");\n\n /*\n  * Collect all of the default options and add the missing ones to the\n  * job object...\n  */\n\n  for (i = printer->num_options, num_options = 0, options = NULL,\n           option = printer->options;\n       i > 0;\n       i --, option ++)\n    if (!ippFindAttribute(job->attrs, option->name, IPP_TAG_ZERO))\n    {\n      if (!strcmp(option->name, \"print-quality\") && ippFindAttribute(job->attrs, \"cupsPrintQuality\", IPP_TAG_NAME))\n        continue;                     /* Don't override cupsPrintQuality */\n\n      cupsdLogJob(job, CUPSD_LOG_DEBUG, \"Adding default %s=%s\", option->name, option->value);\n\n      num_options = cupsAddOption(option->name, option->value, num_options, &options);\n    }\n\n /*\n  * Encode these options as attributes in the job object...\n  */\n\n  cupsEncodeOptions2(job->attrs, num_options, options, IPP_TAG_JOB);\n  cupsFreeOptions(num_options, options);\n}\n\n\n/*\n * 'authenticate_job()' - Set job authentication info.\n */\n\nstatic void\nauthenticate_job(cupsd_client_t  *con,\t/* I - Client connection */\n\t         ipp_attribute_t *uri)\t/* I - Job URI */\n{\n  ipp_attribute_t\t*attr,\t\t/* job-id attribute */\n\t\t\t*auth_info;\t/* auth-info attribute */\n  int\t\t\tjobid;\t\t/* Job ID */\n  cupsd_job_t\t\t*job;\t\t/* Current job */\n  char\t\t\tscheme[HTTP_MAX_URI],\n\t\t\t\t\t/* Method portion of URI */\n\t\t\tusername[HTTP_MAX_URI],\n\t\t\t\t\t/* Username portion of URI */\n\t\t\thost[HTTP_MAX_URI],\n\t\t\t\t\t/* Host portion of URI */\n\t\t\tresource[HTTP_MAX_URI];\n\t\t\t\t\t/* Resource portion of URI */\n  int\t\t\tport;\t\t/* Port portion of URI */\n\n\n  cupsdLogMessage(CUPSD_LOG_DEBUG2, \"authenticate_job(%p[%d], %s)\",\n                  con, con->number, uri->values[0].string.text);\n\n /*\n  * Start with \"everything is OK\" status...\n  */\n\n  con->response->request.status.status_code = IPP_OK;\n\n /*\n  * See if we have a job URI or a printer URI...\n  */\n\n  if (!strcmp(uri->name, \"printer-uri\"))\n  {\n   /*\n    * Got a printer URI; see if we also have a job-id attribute...\n    */\n\n    if ((attr = ippFindAttribute(con->request, \"job-id\",\n                                 IPP_TAG_INTEGER)) == NULL)\n    {\n      send_ipp_status(con, IPP_BAD_REQUEST,\n                      _(\"Got a printer-uri attribute but no job-id.\"));\n      return;\n    }\n\n    jobid = attr->values[0].integer;\n  }\n  else\n  {\n   /*\n    * Got a job URI; parse it to get the job ID...\n    */\n\n    httpSeparateURI(HTTP_URI_CODING_ALL, uri->values[0].string.text, scheme,\n                    sizeof(scheme), username, sizeof(username), host,\n\t\t    sizeof(host), &port, resource, sizeof(resource));\n\n    if (strncmp(resource, \"/jobs/\", 6))\n    {\n     /*\n      * Not a valid URI!\n      */\n\n      send_ipp_status(con, IPP_BAD_REQUEST, _(\"Bad job-uri \\\"%s\\\".\"),\n                      uri->values[0].string.text);\n      return;\n    }\n\n    jobid = atoi(resource + 6);\n  }\n\n /*\n  * See if the job exists...\n  */\n\n  if ((job = cupsdFindJob(jobid)) == NULL)\n  {\n   /*\n    * Nope - return a \"not found\" error...\n    */\n\n    send_ipp_status(con, IPP_NOT_FOUND, _(\"Job #%d does not exist.\"), jobid);\n    return;\n  }\n\n /*\n  * See if the job has been completed...\n  */\n\n  if (job->state_value != IPP_JOB_HELD)\n  {\n   /*\n    * Return a \"not-possible\" error...\n    */\n\n    send_ipp_status(con, IPP_NOT_POSSIBLE,\n                    _(\"Job #%d is not held for authentication.\"),\n\t\t    jobid);\n    return;\n  }\n\n /*\n  * See if we have already authenticated...\n  */\n\n  auth_info = ippFindAttribute(con->request, \"auth-info\", IPP_TAG_TEXT);\n\n  if (!con->username[0] && !auth_info)\n  {\n    cupsd_printer_t\t*printer;\t/* Job destination */\n\n   /*\n    * No auth data.  If we need to authenticate via Kerberos, send a\n    * HTTP auth challenge, otherwise just return an IPP error...\n    */\n\n    printer = cupsdFindDest(job->dest);\n\n    if (printer && printer->num_auth_info_required > 0 &&\n        !strcmp(printer->auth_info_required[0], \"negotiate\"))\n      send_http_error(con, HTTP_UNAUTHORIZED, printer);\n    else\n      send_ipp_status(con, IPP_NOT_AUTHORIZED,\n\t\t      _(\"No authentication information provided.\"));\n    return;\n  }\n\n /*\n  * See if the job is owned by the requesting user...\n  */\n\n  if (!validate_user(job, con, job->username, username, sizeof(username)))\n  {\n    send_http_error(con, con->username[0] ? HTTP_FORBIDDEN : HTTP_UNAUTHORIZED,\n                    cupsdFindDest(job->dest));\n    return;\n  }\n\n /*\n  * Save the authentication information for this job...\n  */\n\n  save_auth_info(con, job, auth_info);\n\n /*\n  * Reset the job-hold-until value to \"no-hold\"...\n  */\n\n  if ((attr = ippFindAttribute(job->attrs, \"job-hold-until\",\n                               IPP_TAG_KEYWORD)) == NULL)\n    attr = ippFindAttribute(job->attrs, \"job-hold-until\", IPP_TAG_NAME);\n\n  if (attr)\n  {\n    ippSetValueTag(job->attrs, &attr, IPP_TAG_KEYWORD);\n    ippSetString(job->attrs, &attr, 0, \"no-hold\");\n  }\n\n /*\n  * Release the job and return...\n  */\n\n  cupsdReleaseJob(job);\n\n  cupsdAddEvent(CUPSD_EVENT_JOB_STATE, NULL, job, \"Job authenticated by user\");\n\n  cupsdLogJob(job, CUPSD_LOG_INFO, \"Authenticated by \\\"%s\\\".\", con->username);\n\n  cupsdCheckJobs();\n}\n\n\n/*\n * 'cancel_all_jobs()' - Cancel all or selected print jobs.\n */\n\nstatic void\ncancel_all_jobs(cupsd_client_t  *con,\t/* I - Client connection */\n\t        ipp_attribute_t *uri)\t/* I - Job or Printer URI */\n{\n  int\t\ti;\t\t\t/* Looping var */\n  http_status_t\tstatus;\t\t\t/* Policy status */\n  cups_ptype_t\tdtype;\t\t\t/* Destination type */\n  char\t\tscheme[HTTP_MAX_URI],\t/* Scheme portion of URI */\n\t\tuserpass[HTTP_MAX_URI],\t/* Username portion of URI */\n\t\thostname[HTTP_MAX_URI],\t/* Host portion of URI */\n\t\tresource[HTTP_MAX_URI];\t/* Resource portion of URI */\n  int\t\tport;\t\t\t/* Port portion of URI */\n  ipp_attribute_t *attr;\t\t/* Attribute in request */\n  const char\t*username = NULL;\t/* Username */\n  cupsd_jobaction_t purge = CUPSD_JOB_DEFAULT;\n\t\t\t\t\t/* Purge? */\n  cupsd_printer_t *printer;\t\t/* Printer */\n  ipp_attribute_t *job_ids;\t\t/* job-ids attribute */\n  cupsd_job_t\t*job;\t\t\t/* Job */\n\n\n  cupsdLogMessage(CUPSD_LOG_DEBUG2, \"cancel_all_jobs(%p[%d], %s)\", con,\n                  con->number, uri->values[0].string.text);\n\n /*\n  * Get the jobs to cancel/purge...\n  */\n\n  switch (con->request->request.op.operation_id)\n  {\n    case IPP_PURGE_JOBS :\n       /*\n\t* Get the username (if any) for the jobs we want to cancel (only if\n\t* \"my-jobs\" is specified...\n\t*/\n\n        if ((attr = ippFindAttribute(con->request, \"my-jobs\",\n                                     IPP_TAG_BOOLEAN)) != NULL &&\n            attr->values[0].boolean)\n\t{\n\t  if ((attr = ippFindAttribute(con->request, \"requesting-user-name\",\n\t\t\t\t       IPP_TAG_NAME)) != NULL)\n\t    username = attr->values[0].string.text;\n\t  else\n\t  {\n\t    send_ipp_status(con, IPP_BAD_REQUEST,\n\t\t\t    _(\"Missing requesting-user-name attribute.\"));\n\t    return;\n\t  }\n\t}\n\n       /*\n\t* Look for the \"purge-jobs\" attribute...\n\t*/\n\n\tif ((attr = ippFindAttribute(con->request, \"purge-jobs\",\n\t\t\t\t     IPP_TAG_BOOLEAN)) != NULL)\n\t  purge = attr->values[0].boolean ? CUPSD_JOB_PURGE : CUPSD_JOB_DEFAULT;\n\telse\n\t  purge = CUPSD_JOB_PURGE;\n\tbreak;\n\n    case IPP_CANCEL_MY_JOBS :\n        if (con->username[0])\n          username = con->username;\n        else if ((attr = ippFindAttribute(con->request, \"requesting-user-name\",\n\t\t\t\t\t  IPP_TAG_NAME)) != NULL)\n          username = attr->values[0].string.text;\n        else\n        {\n\t  send_ipp_status(con, IPP_BAD_REQUEST,\n\t\t\t  _(\"Missing requesting-user-name attribute.\"));\n\t  return;\n        }\n\n    default :\n        break;\n  }\n\n  job_ids = ippFindAttribute(con->request, \"job-ids\", IPP_TAG_INTEGER);\n\n /*\n  * See if we have a printer URI...\n  */\n\n  if (strcmp(uri->name, \"printer-uri\"))\n  {\n    send_ipp_status(con, IPP_BAD_REQUEST,\n                    _(\"The printer-uri attribute is required.\"));\n    return;\n  }\n\n /*\n  * And if the destination is valid...\n  */\n\n  if (!cupsdValidateDest(uri->values[0].string.text, &dtype, &printer))\n  {\n   /*\n    * Bad URI?\n    */\n\n    httpSeparateURI(HTTP_URI_CODING_ALL, uri->values[0].string.text,\n                    scheme, sizeof(scheme), userpass, sizeof(userpass),\n\t\t    hostname, sizeof(hostname), &port,\n\t\t    resource, sizeof(resource));\n\n    if ((!strncmp(resource, \"/printers/\", 10) && resource[10]) ||\n        (!strncmp(resource, \"/classes/\", 9) && resource[9]))\n    {\n      send_ipp_status(con, IPP_NOT_FOUND,\n                      _(\"The printer or class does not exist.\"));\n      return;\n    }\n\n   /*\n    * Check policy...\n    */\n\n    if ((status = cupsdCheckPolicy(DefaultPolicyPtr, con, NULL)) != HTTP_OK)\n    {\n      send_http_error(con, status, NULL);\n      return;\n    }\n\n    if (job_ids)\n    {\n      for (i = 0; i < job_ids->num_values; i ++)\n      {\n\tif ((job = cupsdFindJob(job_ids->values[i].integer)) == NULL)\n\t  break;\n\n        if (con->request->request.op.operation_id == IPP_CANCEL_MY_JOBS &&\n            _cups_strcasecmp(job->username, username))\n          break;\n      }\n\n      if (i < job_ids->num_values)\n      {\n\tsend_ipp_status(con, IPP_NOT_FOUND, _(\"Job #%d does not exist.\"),\n\t\t\tjob_ids->values[i].integer);\n\treturn;\n      }\n\n      for (i = 0; i < job_ids->num_values; i ++)\n      {\n\tjob = cupsdFindJob(job_ids->values[i].integer);\n\n\tcupsdSetJobState(job, IPP_JOB_CANCELED, purge,\n\t                 purge == CUPSD_JOB_PURGE ? \"Job purged by user.\" :\n\t                                            \"Job canceled by user.\");\n      }\n\n      cupsdLogMessage(CUPSD_LOG_INFO, \"Selected jobs were %s by \\\"%s\\\".\",\n\t\t      purge == CUPSD_JOB_PURGE ? \"purged\" : \"canceled\",\n\t\t      get_username(con));\n    }\n    else\n    {\n     /*\n      * Cancel all jobs on all printers...\n      */\n\n      cupsdCancelJobs(NULL, username, purge);\n\n      cupsdLogMessage(CUPSD_LOG_INFO, \"All jobs were %s by \\\"%s\\\".\",\n\t\t      purge == CUPSD_JOB_PURGE ? \"purged\" : \"canceled\",\n\t\t      get_username(con));\n    }\n  }\n  else\n  {\n   /*\n    * Check policy...\n    */\n\n    if ((status = cupsdCheckPolicy(printer->op_policy_ptr, con,\n                                   NULL)) != HTTP_OK)\n    {\n      send_http_error(con, status, printer);\n      return;\n    }\n\n    if (job_ids)\n    {\n      for (i = 0; i < job_ids->num_values; i ++)\n      {\n\tif ((job = cupsdFindJob(job_ids->values[i].integer)) == NULL ||\n\t    _cups_strcasecmp(job->dest, printer->name))\n\t  break;\n\n        if (con->request->request.op.operation_id == IPP_CANCEL_MY_JOBS &&\n            _cups_strcasecmp(job->username, username))\n          break;\n      }\n\n      if (i < job_ids->num_values)\n      {\n\tsend_ipp_status(con, IPP_NOT_FOUND, _(\"Job #%d does not exist.\"),\n\t\t\tjob_ids->values[i].integer);\n\treturn;\n      }\n\n      for (i = 0; i < job_ids->num_values; i ++)\n      {\n\tjob = cupsdFindJob(job_ids->values[i].integer);\n\n\tcupsdSetJobState(job, IPP_JOB_CANCELED, purge,\n\t                 purge == CUPSD_JOB_PURGE ? \"Job purged by user.\" :\n\t                                            \"Job canceled by user.\");\n      }\n\n      cupsdLogMessage(CUPSD_LOG_INFO, \"Selected jobs were %s by \\\"%s\\\".\",\n\t\t      purge == CUPSD_JOB_PURGE ? \"purged\" : \"canceled\",\n\t\t      get_username(con));\n    }\n    else\n    {\n     /*\n      * Cancel all of the jobs on the named printer...\n      */\n\n      cupsdCancelJobs(printer->name, username, purge);\n\n      cupsdLogMessage(CUPSD_LOG_INFO, \"All jobs on \\\"%s\\\" were %s by \\\"%s\\\".\",\n\t\t      printer->name,\n\t\t      purge == CUPSD_JOB_PURGE ? \"purged\" : \"canceled\",\n\t\t      get_username(con));\n    }\n  }\n\n  con->response->request.status.status_code = IPP_OK;\n\n  cupsdCheckJobs();\n}\n\n\n/*\n * 'cancel_job()' - Cancel a print job.\n */\n\nstatic void\ncancel_job(cupsd_client_t  *con,\t/* I - Client connection */\n\t   ipp_attribute_t *uri)\t/* I - Job or Printer URI */\n{\n  ipp_attribute_t *attr;\t\t/* Current attribute */\n  int\t\tjobid;\t\t\t/* Job ID */\n  char\t\tscheme[HTTP_MAX_URI],\t/* Scheme portion of URI */\n\t\tusername[HTTP_MAX_URI],\t/* Username portion of URI */\n\t\thost[HTTP_MAX_URI],\t/* Host portion of URI */\n\t\tresource[HTTP_MAX_URI];\t/* Resource portion of URI */\n  int\t\tport;\t\t\t/* Port portion of URI */\n  cupsd_job_t\t*job;\t\t\t/* Job information */\n  cups_ptype_t\tdtype;\t\t\t/* Destination type (printer/class) */\n  cupsd_printer_t *printer;\t\t/* Printer data */\n  cupsd_jobaction_t purge;\t\t/* Purge the job? */\n\n\n  cupsdLogMessage(CUPSD_LOG_DEBUG2, \"cancel_job(%p[%d], %s)\", con,\n                  con->number, uri->values[0].string.text);\n\n /*\n  * See if we have a job URI or a printer URI...\n  */\n\n  if (!strcmp(uri->name, \"printer-uri\"))\n  {\n   /*\n    * Got a printer URI; see if we also have a job-id attribute...\n    */\n\n    if ((attr = ippFindAttribute(con->request, \"job-id\",\n                                 IPP_TAG_INTEGER)) == NULL)\n    {\n      send_ipp_status(con, IPP_BAD_REQUEST,\n                      _(\"Got a printer-uri attribute but no job-id.\"));\n      return;\n    }\n\n    if ((jobid = attr->values[0].integer) == 0)\n    {\n     /*\n      * Find the current job on the specified printer...\n      */\n\n      if (!cupsdValidateDest(uri->values[0].string.text, &dtype, &printer))\n      {\n       /*\n\t* Bad URI...\n\t*/\n\n\tsend_ipp_status(con, IPP_NOT_FOUND,\n                \t_(\"The printer or class does not exist.\"));\n\treturn;\n      }\n\n     /*\n      * See if there are any pending jobs...\n      */\n\n      for (job = (cupsd_job_t *)cupsArrayFirst(ActiveJobs);\n\t   job;\n\t   job = (cupsd_job_t *)cupsArrayNext(ActiveJobs))\n\tif (job->state_value <= IPP_JOB_PROCESSING &&\n\t    !_cups_strcasecmp(job->dest, printer->name))\n\t  break;\n\n      if (job)\n\tjobid = job->id;\n      else\n      {\n       /*\n        * No, try stopped jobs...\n\t*/\n\n\tfor (job = (cupsd_job_t *)cupsArrayFirst(ActiveJobs);\n\t     job;\n\t     job = (cupsd_job_t *)cupsArrayNext(ActiveJobs))\n\t  if (job->state_value == IPP_JOB_STOPPED &&\n\t      !_cups_strcasecmp(job->dest, printer->name))\n\t    break;\n\n\tif (job)\n\t  jobid = job->id;\n\telse\n\t{\n\t  send_ipp_status(con, IPP_NOT_POSSIBLE, _(\"No active jobs on %s.\"),\n\t\t\t  printer->name);\n\t  return;\n\t}\n      }\n    }\n  }\n  else\n  {\n   /*\n    * Got a job URI; parse it to get the job ID...\n    */\n\n    httpSeparateURI(HTTP_URI_CODING_ALL, uri->values[0].string.text, scheme,\n                    sizeof(scheme), username, sizeof(username), host,\n\t\t    sizeof(host), &port, resource, sizeof(resource));\n\n    if (strncmp(resource, \"/jobs/\", 6))\n    {\n     /*\n      * Not a valid URI!\n      */\n\n      send_ipp_status(con, IPP_BAD_REQUEST, _(\"Bad job-uri \\\"%s\\\".\"),\n                      uri->values[0].string.text);\n      return;\n    }\n\n    jobid = atoi(resource + 6);\n  }\n\n /*\n  * Look for the \"purge-job\" attribute...\n  */\n\n  if ((attr = ippFindAttribute(con->request, \"purge-job\",\n                               IPP_TAG_BOOLEAN)) != NULL)\n    purge = attr->values[0].boolean ? CUPSD_JOB_PURGE : CUPSD_JOB_DEFAULT;\n  else\n    purge = CUPSD_JOB_DEFAULT;\n\n /*\n  * See if the job exists...\n  */\n\n  if ((job = cupsdFindJob(jobid)) == NULL)\n  {\n   /*\n    * Nope - return a \"not found\" error...\n    */\n\n    send_ipp_status(con, IPP_NOT_FOUND, _(\"Job #%d does not exist.\"), jobid);\n    return;\n  }\n\n /*\n  * See if the job is owned by the requesting user...\n  */\n\n  if (!validate_user(job, con, job->username, username, sizeof(username)))\n  {\n    send_http_error(con, con->username[0] ? HTTP_FORBIDDEN : HTTP_UNAUTHORIZED,\n                    cupsdFindDest(job->dest));\n    return;\n  }\n\n /*\n  * See if the job is already completed, canceled, or aborted; if so,\n  * we can't cancel...\n  */\n\n  if (job->state_value >= IPP_JOB_CANCELED && purge != CUPSD_JOB_PURGE)\n  {\n    switch (job->state_value)\n    {\n      case IPP_JOB_CANCELED :\n\t  send_ipp_status(con, IPP_NOT_POSSIBLE,\n                \t  _(\"Job #%d is already canceled - can\\'t cancel.\"),\n\t\t\t  jobid);\n          break;\n\n      case IPP_JOB_ABORTED :\n\t  send_ipp_status(con, IPP_NOT_POSSIBLE,\n                \t  _(\"Job #%d is already aborted - can\\'t cancel.\"),\n\t\t\t  jobid);\n          break;\n\n      default :\n\t  send_ipp_status(con, IPP_NOT_POSSIBLE,\n                \t  _(\"Job #%d is already completed - can\\'t cancel.\"),\n\t\t\t  jobid);\n          break;\n    }\n\n    return;\n  }\n\n /*\n  * Cancel the job and return...\n  */\n\n  cupsdSetJobState(job, IPP_JOB_CANCELED, purge,\n                   purge == CUPSD_JOB_PURGE ? \"Job purged by \\\"%s\\\"\" :\n\t\t                              \"Job canceled by \\\"%s\\\"\",\n\t\t   username);\n  cupsdCheckJobs();\n\n  if (purge == CUPSD_JOB_PURGE)\n    cupsdLogMessage(CUPSD_LOG_INFO, \"[Job %d] Purged by \\\"%s\\\".\", jobid,\n\t\t    username);\n  else\n    cupsdLogMessage(CUPSD_LOG_INFO, \"[Job %d] Canceled by \\\"%s\\\".\", jobid,\n\t\t    username);\n\n  con->response->request.status.status_code = IPP_OK;\n}\n\n\n/*\n * 'cancel_subscription()' - Cancel a subscription.\n */\n\nstatic void\ncancel_subscription(\n    cupsd_client_t *con,\t\t/* I - Client connection */\n    int            sub_id)\t\t/* I - Subscription ID */\n{\n  http_status_t\t\tstatus;\t\t/* Policy status */\n  cupsd_subscription_t\t*sub;\t\t/* Subscription */\n\n\n  cupsdLogMessage(CUPSD_LOG_DEBUG2,\n                  \"cancel_subscription(con=%p[%d], sub_id=%d)\",\n                  con, con->number, sub_id);\n\n /*\n  * Is the subscription ID valid?\n  */\n\n  if ((sub = cupsdFindSubscription(sub_id)) == NULL)\n  {\n   /*\n    * Bad subscription ID...\n    */\n\n    send_ipp_status(con, IPP_NOT_FOUND,\n                    _(\"Subscription #%d does not exist.\"), sub_id);\n    return;\n  }\n\n /*\n  * Check policy...\n  */\n\n  if ((status = cupsdCheckPolicy(sub->dest ? sub->dest->op_policy_ptr :\n                                             DefaultPolicyPtr,\n                                 con, sub->owner)) != HTTP_OK)\n  {\n    send_http_error(con, status, sub->dest);\n    return;\n  }\n\n /*\n  * Cancel the subscription...\n  */\n\n  cupsdDeleteSubscription(sub, 1);\n\n  con->response->request.status.status_code = IPP_OK;\n}\n\n\n/*\n * 'check_rss_recipient()' - Check that we do not have a duplicate RSS feed URI.\n */\n\nstatic int\t\t\t\t/* O - 1 if OK, 0 if not */\ncheck_rss_recipient(\n    const char *recipient)\t\t/* I - Recipient URI */\n{\n  cupsd_subscription_t\t*sub;\t\t/* Current subscription */\n\n\n  for (sub = (cupsd_subscription_t *)cupsArrayFirst(Subscriptions);\n       sub;\n       sub = (cupsd_subscription_t *)cupsArrayNext(Subscriptions))\n    if (sub->recipient)\n    {\n     /*\n      * Compare the URIs up to the first ?...\n      */\n\n      const char *r1, *r2;\n\n      for (r1 = recipient, r2 = sub->recipient;\n           *r1 == *r2 && *r1 && *r1 != '?' && *r2 && *r2 != '?';\n\t   r1 ++, r2 ++);\n\n      if (*r1 == *r2)\n        return (0);\n    }\n\n  return (1);\n}\n\n\n/*\n * 'check_quotas()' - Check quotas for a printer and user.\n */\n\nstatic int\t\t\t\t/* O - 1 if OK, 0 if forbidden,\n\t\t\t\t\t       -1 if limit reached */\ncheck_quotas(cupsd_client_t  *con,\t/* I - Client connection */\n             cupsd_printer_t *p)\t/* I - Printer or class */\n{\n  char\t\tusername[33],\t\t/* Username */\n\t\t*name;\t\t\t/* Current user name */\n  cupsd_quota_t\t*q;\t\t\t/* Quota data */\n#ifdef HAVE_MBR_UID_TO_UUID\n /*\n  * Use Apple membership APIs which require that all names represent\n  * valid user account or group records accessible by the server.\n  */\n\n  uuid_t\tusr_uuid;\t\t/* UUID for job requesting user  */\n  uuid_t\tusr2_uuid;\t\t/* UUID for ACL user name entry  */\n  uuid_t\tgrp_uuid;\t\t/* UUID for ACL group name entry */\n  int\t\tmbr_err;\t\t/* Error from membership function */\n  int\t\tis_member;\t\t/* Is this user a member? */\n#else\n /*\n  * Use standard POSIX APIs for checking users and groups...\n  */\n\n  struct passwd\t*pw;\t\t\t/* User password data */\n#endif /* HAVE_MBR_UID_TO_UUID */\n\n\n  cupsdLogMessage(CUPSD_LOG_DEBUG2, \"check_quotas(%p[%d], %p[%s])\",\n                  con, con->number, p, p->name);\n\n /*\n  * Figure out who is printing...\n  */\n\n  strlcpy(username, get_username(con), sizeof(username));\n\n  if ((name = strchr(username, '@')) != NULL)\n    *name = '\\0';\t\t\t/* Strip @REALM */\n\n /*\n  * Check global active job limits for printers and users...\n  */\n\n  if (MaxJobsPerPrinter)\n  {\n   /*\n    * Check if there are too many pending jobs on this printer...\n    */\n\n    if (cupsdGetPrinterJobCount(p->name) >= MaxJobsPerPrinter)\n    {\n      cupsdLogMessage(CUPSD_LOG_INFO, \"Too many jobs for printer \\\"%s\\\"...\",\n                      p->name);\n      return (-1);\n    }\n  }\n\n  if (MaxJobsPerUser)\n  {\n   /*\n    * Check if there are too many pending jobs for this user...\n    */\n\n    if (cupsdGetUserJobCount(username) >= MaxJobsPerUser)\n    {\n      cupsdLogMessage(CUPSD_LOG_INFO, \"Too many jobs for user \\\"%s\\\"...\",\n                      username);\n      return (-1);\n    }\n  }\n\n /*\n  * Check against users...\n  */\n\n  if (cupsArrayCount(p->users) == 0 && p->k_limit == 0 && p->page_limit == 0)\n    return (1);\n\n  if (cupsArrayCount(p->users))\n  {\n#ifdef HAVE_MBR_UID_TO_UUID\n   /*\n    * Get UUID for job requesting user...\n    */\n\n    if (mbr_user_name_to_uuid((char *)username, usr_uuid))\n    {\n     /*\n      * Unknown user...\n      */\n\n      cupsdLogMessage(CUPSD_LOG_DEBUG,\n\t\t      \"check_quotas: UUID lookup failed for user \\\"%s\\\"\",\n\t\t      username);\n      cupsdLogMessage(CUPSD_LOG_INFO,\n\t\t      \"Denying user \\\"%s\\\" access to printer \\\"%s\\\" \"\n\t\t      \"(unknown user)...\",\n\t\t      username, p->name);\n      return (0);\n    }\n#else\n   /*\n    * Get UID and GID of requesting user...\n    */\n\n    pw = getpwnam(username);\n    endpwent();\n#endif /* HAVE_MBR_UID_TO_UUID */\n\n    for (name = (char *)cupsArrayFirst(p->users);\n         name;\n\t name = (char *)cupsArrayNext(p->users))\n      if (name[0] == '@')\n      {\n       /*\n        * Check group membership...\n\t*/\n\n#ifdef HAVE_MBR_UID_TO_UUID\n        if (name[1] == '#')\n\t{\n\t  if (uuid_parse(name + 2, grp_uuid))\n\t    uuid_clear(grp_uuid);\n\t}\n\telse if ((mbr_err = mbr_group_name_to_uuid(name + 1, grp_uuid)) != 0)\n\t{\n\t /*\n\t  * Invalid ACL entries are ignored for matching; just record a\n\t  * warning in the log...\n\t  */\n\n\t  cupsdLogMessage(CUPSD_LOG_DEBUG,\n\t                  \"check_quotas: UUID lookup failed for ACL entry \"\n\t\t\t  \"\\\"%s\\\" (err=%d)\", name, mbr_err);\n\t  cupsdLogMessage(CUPSD_LOG_WARN,\n\t                  \"Access control entry \\\"%s\\\" not a valid group name; \"\n\t\t\t  \"entry ignored\", name);\n\t}\n\n\tif ((mbr_err = mbr_check_membership(usr_uuid, grp_uuid,\n\t\t\t\t\t    &is_member)) != 0)\n\t{\n\t /*\n\t  * At this point, there should be no errors, but check anyways...\n\t  */\n\n\t  cupsdLogMessage(CUPSD_LOG_DEBUG,\n\t\t\t  \"check_quotas: group \\\"%s\\\" membership check \"\n\t\t\t  \"failed (err=%d)\", name + 1, mbr_err);\n\t  is_member = 0;\n\t}\n\n       /*\n\t* Stop if we found a match...\n\t*/\n\n\tif (is_member)\n\t  break;\n\n#else\n        if (cupsdCheckGroup(username, pw, name + 1))\n\t  break;\n#endif /* HAVE_MBR_UID_TO_UUID */\n      }\n#ifdef HAVE_MBR_UID_TO_UUID\n      else\n      {\n        if (name[0] == '#')\n\t{\n\t  if (uuid_parse(name + 1, usr2_uuid))\n\t    uuid_clear(usr2_uuid);\n        }\n        else if ((mbr_err = mbr_user_name_to_uuid(name, usr2_uuid)) != 0)\n    \t{\n\t /*\n\t  * Invalid ACL entries are ignored for matching; just record a\n\t  * warning in the log...\n\t  */\n\n          cupsdLogMessage(CUPSD_LOG_DEBUG,\n\t                  \"check_quotas: UUID lookup failed for ACL entry \"\n\t\t\t  \"\\\"%s\\\" (err=%d)\", name, mbr_err);\n          cupsdLogMessage(CUPSD_LOG_WARN,\n\t                  \"Access control entry \\\"%s\\\" not a valid user name; \"\n\t\t\t  \"entry ignored\", name);\n\t}\n\n\tif (!uuid_compare(usr_uuid, usr2_uuid))\n\t  break;\n      }\n#else\n      else if (!_cups_strcasecmp(username, name))\n\tbreak;\n#endif /* HAVE_MBR_UID_TO_UUID */\n\n    if ((name != NULL) == p->deny_users)\n    {\n      cupsdLogMessage(CUPSD_LOG_INFO,\n                      \"Denying user \\\"%s\\\" access to printer \\\"%s\\\"...\",\n        \t      username, p->name);\n      return (0);\n    }\n  }\n\n /*\n  * Check quotas...\n  */\n\n  if (p->k_limit || p->page_limit)\n  {\n    if ((q = cupsdUpdateQuota(p, username, 0, 0)) == NULL)\n    {\n      cupsdLogMessage(CUPSD_LOG_ERROR,\n                      \"Unable to allocate quota data for user \\\"%s\\\"\",\n                      username);\n      return (-1);\n    }\n\n    if ((q->k_count >= p->k_limit && p->k_limit) ||\n        (q->page_count >= p->page_limit && p->page_limit))\n    {\n      cupsdLogMessage(CUPSD_LOG_INFO, \"User \\\"%s\\\" is over the quota limit...\",\n                      username);\n      return (-1);\n    }\n  }\n\n /*\n  * If we have gotten this far, we're done!\n  */\n\n  return (1);\n}\n\n\n/*\n * 'close_job()' - Close a multi-file job.\n */\n\nstatic void\nclose_job(cupsd_client_t  *con,\t\t/* I - Client connection */\n          ipp_attribute_t *uri)\t\t/* I - Printer URI */\n{\n  cupsd_job_t\t\t*job;\t\t/* Job */\n  ipp_attribute_t\t*attr;\t\t/* Attribute */\n  char\t\t\tjob_uri[HTTP_MAX_URI],\n\t\t\t\t\t/* Job URI */\n\t\t\tusername[256];\t/* User name */\n\n\n  cupsdLogMessage(CUPSD_LOG_DEBUG2, \"close_job(%p[%d], %s)\", con,\n                  con->number, uri->values[0].string.text);\n\n /*\n  * See if we have a job URI or a printer URI...\n  */\n\n  if (strcmp(uri->name, \"printer-uri\"))\n  {\n   /*\n    * job-uri is not supported by Close-Job!\n    */\n\n    send_ipp_status(con, IPP_BAD_REQUEST,\n\t\t    _(\"Close-Job doesn't support the job-uri attribute.\"));\n    return;\n  }\n\n /*\n  * Got a printer URI; see if we also have a job-id attribute...\n  */\n\n  if ((attr = ippFindAttribute(con->request, \"job-id\",\n\t\t\t       IPP_TAG_INTEGER)) == NULL)\n  {\n    send_ipp_status(con, IPP_BAD_REQUEST,\n\t\t    _(\"Got a printer-uri attribute but no job-id.\"));\n    return;\n  }\n\n  if ((job = cupsdFindJob(attr->values[0].integer)) == NULL)\n  {\n   /*\n    * Nope - return a \"not found\" error...\n    */\n\n    send_ipp_status(con, IPP_NOT_FOUND, _(\"Job #%d does not exist.\"),\n                    attr->values[0].integer);\n    return;\n  }\n\n /*\n  * See if the job is owned by the requesting user...\n  */\n\n  if (!validate_user(job, con, job->username, username, sizeof(username)))\n  {\n    send_http_error(con, con->username[0] ? HTTP_FORBIDDEN : HTTP_UNAUTHORIZED,\n                    cupsdFindDest(job->dest));\n    return;\n  }\n\n /*\n  * Add any ending sheet...\n  */\n\n  if (cupsdTimeoutJob(job))\n    return;\n\n  if (job->state_value == IPP_JOB_STOPPED)\n  {\n    job->state->values[0].integer = IPP_JOB_PENDING;\n    job->state_value              = IPP_JOB_PENDING;\n  }\n  else if (job->state_value == IPP_JOB_HELD)\n  {\n    if ((attr = ippFindAttribute(job->attrs, \"job-hold-until\",\n\t\t\t\t IPP_TAG_KEYWORD)) == NULL)\n      attr = ippFindAttribute(job->attrs, \"job-hold-until\", IPP_TAG_NAME);\n\n    if (!attr || !strcmp(attr->values[0].string.text, \"no-hold\"))\n    {\n      job->state->values[0].integer = IPP_JOB_PENDING;\n      job->state_value              = IPP_JOB_PENDING;\n    }\n  }\n\n  job->dirty = 1;\n  cupsdMarkDirty(CUPSD_DIRTY_JOBS);\n\n /*\n  * Fill in the response info...\n  */\n\n  httpAssembleURIf(HTTP_URI_CODING_ALL, job_uri, sizeof(job_uri), \"ipp\", NULL,\n                   con->clientname, con->clientport, \"/jobs/%d\", job->id);\n  ippAddString(con->response, IPP_TAG_JOB, IPP_TAG_URI, \"job-uri\", NULL,\n               job_uri);\n\n  ippAddInteger(con->response, IPP_TAG_JOB, IPP_TAG_INTEGER, \"job-id\", job->id);\n\n  ippAddInteger(con->response, IPP_TAG_JOB, IPP_TAG_ENUM, \"job-state\",\n                job->state_value);\n\n  con->response->request.status.status_code = IPP_OK;\n\n /*\n  * Start the job if necessary...\n  */\n\n  cupsdCheckJobs();\n}\n\n\n/*\n * 'copy_attrs()' - Copy attributes from one request to another.\n */\n\nstatic void\ncopy_attrs(ipp_t        *to,\t\t/* I - Destination request */\n           ipp_t        *from,\t\t/* I - Source request */\n           cups_array_t *ra,\t\t/* I - Requested attributes */\n\t   ipp_tag_t    group,\t\t/* I - Group to copy */\n\t   int          quickcopy,\t/* I - Do a quick copy? */\n\t   cups_array_t *exclude)\t/* I - Attributes to exclude? */\n{\n  ipp_attribute_t\t*fromattr;\t/* Source attribute */\n\n\n  cupsdLogMessage(CUPSD_LOG_DEBUG2,\n                  \"copy_attrs(to=%p, from=%p, ra=%p, group=%x, quickcopy=%d)\",\n\t\t  to, from, ra, group, quickcopy);\n\n  if (!to || !from)\n    return;\n\n  for (fromattr = from->attrs; fromattr; fromattr = fromattr->next)\n  {\n   /*\n    * Filter attributes as needed...\n    */\n\n    if ((group != IPP_TAG_ZERO && fromattr->group_tag != group &&\n         fromattr->group_tag != IPP_TAG_ZERO) || !fromattr->name)\n      continue;\n\n    if (!strcmp(fromattr->name, \"document-password\") ||\n        !strcmp(fromattr->name, \"job-authorization-uri\") ||\n        !strcmp(fromattr->name, \"job-password\") ||\n        !strcmp(fromattr->name, \"job-password-encryption\") ||\n        !strcmp(fromattr->name, \"job-printer-uri\"))\n      continue;\n\n    if (exclude &&\n        (cupsArrayFind(exclude, fromattr->name) ||\n\t cupsArrayFind(exclude, \"all\")))\n    {\n     /*\n      * We need to exclude this attribute for security reasons; we require the\n      * job-id attribute regardless of the security settings for IPP\n      * conformance.\n      *\n      * The job-printer-uri attribute is handled by copy_job_attrs().\n      *\n      * Subscription attribute security is handled by copy_subscription_attrs().\n      */\n\n      if (strcmp(fromattr->name, \"job-id\"))\n        continue;\n    }\n\n    if (!ra || cupsArrayFind(ra, fromattr->name))\n    {\n     /*\n      * Don't send collection attributes by default to IPP/1.x clients\n      * since many do not support collections.  Also don't send\n      * media-col-database unless specifically requested by the client.\n      */\n\n      if (fromattr->value_tag == IPP_TAG_BEGIN_COLLECTION &&\n          !ra &&\n\t  (to->request.status.version[0] == 1 ||\n\t   !strcmp(fromattr->name, \"media-col-database\")))\n\tcontinue;\n\n      ippCopyAttribute(to, fromattr, quickcopy);\n    }\n  }\n}\n\n\n/*\n * 'copy_banner()' - Copy a banner file to the requests directory for the\n *                   specified job.\n */\n\nstatic int\t\t\t\t/* O - Size of banner file in kbytes */\ncopy_banner(cupsd_client_t *con,\t/* I - Client connection */\n            cupsd_job_t    *job,\t/* I - Job information */\n            const char     *name)\t/* I - Name of banner */\n{\n  int\t\ti;\t\t\t/* Looping var */\n  int\t\tkbytes;\t\t\t/* Size of banner file in kbytes */\n  char\t\tfilename[1024];\t\t/* Job filename */\n  cupsd_banner_t *banner;\t\t/* Pointer to banner */\n  cups_file_t\t*in;\t\t\t/* Input file */\n  cups_file_t\t*out;\t\t\t/* Output file */\n  int\t\tch;\t\t\t/* Character from file */\n  char\t\tattrname[255],\t\t/* Name of attribute */\n\t\t*s;\t\t\t/* Pointer into name */\n  ipp_attribute_t *attr;\t\t/* Attribute */\n\n\n  cupsdLogMessage(CUPSD_LOG_DEBUG2,\n                  \"copy_banner(con=%p[%d], job=%p[%d], name=\\\"%s\\\")\",\n                  con, con ? con->number : -1, job, job->id,\n\t\t  name ? name : \"(null)\");\n\n /*\n  * Find the banner; return if not found or \"none\"...\n  */\n\n  if (!name || !strcmp(name, \"none\") ||\n      (banner = cupsdFindBanner(name)) == NULL)\n    return (0);\n\n /*\n  * Open the banner and job files...\n  */\n\n  if (add_file(con, job, banner->filetype, 0))\n    return (-1);\n\n  snprintf(filename, sizeof(filename), \"%s/d%05d-%03d\", RequestRoot, job->id,\n           job->num_files);\n  if ((out = cupsFileOpen(filename, \"w\")) == NULL)\n  {\n    cupsdLogMessage(CUPSD_LOG_ERROR,\n                    \"Unable to create banner job file %s - %s\",\n                    filename, strerror(errno));\n    job->num_files --;\n    return (0);\n  }\n\n  fchmod(cupsFileNumber(out), 0640);\n  fchown(cupsFileNumber(out), RunUser, Group);\n\n /*\n  * Try the localized banner file under the subdirectory...\n  */\n\n  strlcpy(attrname, job->attrs->attrs->next->values[0].string.text,\n          sizeof(attrname));\n  if (strlen(attrname) > 2 && attrname[2] == '-')\n  {\n   /*\n    * Convert ll-cc to ll_CC...\n    */\n\n    attrname[2] = '_';\n    attrname[3] = (char)toupper(attrname[3] & 255);\n    attrname[4] = (char)toupper(attrname[4] & 255);\n  }\n\n  snprintf(filename, sizeof(filename), \"%s/banners/%s/%s\", DataDir,\n           attrname, name);\n\n  if (access(filename, 0) && strlen(attrname) > 2)\n  {\n   /*\n    * Wasn't able to find \"ll_CC\" locale file; try the non-national\n    * localization banner directory.\n    */\n\n    attrname[2] = '\\0';\n\n    snprintf(filename, sizeof(filename), \"%s/banners/%s/%s\", DataDir,\n             attrname, name);\n  }\n\n  if (access(filename, 0))\n  {\n   /*\n    * Use the non-localized banner file.\n    */\n\n    snprintf(filename, sizeof(filename), \"%s/banners/%s\", DataDir, name);\n  }\n\n  if ((in = cupsFileOpen(filename, \"r\")) == NULL)\n  {\n    cupsFileClose(out);\n    unlink(filename);\n    cupsdLogMessage(CUPSD_LOG_ERROR,\n                    \"Unable to open banner template file %s - %s\",\n                    filename, strerror(errno));\n    job->num_files --;\n    return (0);\n  }\n\n /*\n  * Parse the file to the end...\n  */\n\n  while ((ch = cupsFileGetChar(in)) != EOF)\n    if (ch == '{')\n    {\n     /*\n      * Get an attribute name...\n      */\n\n      for (s = attrname; (ch = cupsFileGetChar(in)) != EOF;)\n        if (!isalpha(ch & 255) && ch != '-' && ch != '?')\n          break;\n\telse if (s < (attrname + sizeof(attrname) - 1))\n          *s++ = (char)ch;\n\telse\n\t  break;\n\n      *s = '\\0';\n\n      if (ch != '}')\n      {\n       /*\n        * Ignore { followed by stuff that is not an attribute name...\n\t*/\n\n        cupsFilePrintf(out, \"{%s%c\", attrname, ch);\n\tcontinue;\n      }\n\n     /*\n      * See if it is defined...\n      */\n\n      if (attrname[0] == '?')\n        s = attrname + 1;\n      else\n        s = attrname;\n\n      if (!strcmp(s, \"printer-name\"))\n      {\n        cupsFilePuts(out, job->dest);\n\tcontinue;\n      }\n      else if ((attr = ippFindAttribute(job->attrs, s, IPP_TAG_ZERO)) == NULL)\n      {\n       /*\n        * See if we have a leading question mark...\n\t*/\n\n\tif (attrname[0] != '?')\n\t{\n\t /*\n          * Nope, write to file as-is; probably a PostScript procedure...\n\t  */\n\n\t  cupsFilePrintf(out, \"{%s}\", attrname);\n        }\n\n        continue;\n      }\n\n     /*\n      * Output value(s)...\n      */\n\n      for (i = 0; i < attr->num_values; i ++)\n      {\n\tif (i)\n\t  cupsFilePutChar(out, ',');\n\n\tswitch (attr->value_tag)\n\t{\n\t  case IPP_TAG_INTEGER :\n\t  case IPP_TAG_ENUM :\n\t      if (!strncmp(s, \"time-at-\", 8))\n\t      {\n\t        struct timeval tv;\t/* Time value */\n\n\t\ttv.tv_sec  = attr->values[i].integer;\n\t\ttv.tv_usec = 0;\n\n\t        cupsFilePuts(out, cupsdGetDateTime(&tv, CUPSD_TIME_STANDARD));\n\t      }\n\t      else\n\t        cupsFilePrintf(out, \"%d\", attr->values[i].integer);\n\t      break;\n\n\t  case IPP_TAG_BOOLEAN :\n\t      cupsFilePrintf(out, \"%d\", attr->values[i].boolean);\n\t      break;\n\n\t  case IPP_TAG_NOVALUE :\n\t      cupsFilePuts(out, \"novalue\");\n\t      break;\n\n\t  case IPP_TAG_RANGE :\n\t      cupsFilePrintf(out, \"%d-%d\", attr->values[i].range.lower,\n\t\t      attr->values[i].range.upper);\n\t      break;\n\n\t  case IPP_TAG_RESOLUTION :\n\t      cupsFilePrintf(out, \"%dx%d%s\", attr->values[i].resolution.xres,\n\t\t      attr->values[i].resolution.yres,\n\t\t      attr->values[i].resolution.units == IPP_RES_PER_INCH ?\n\t\t\t  \"dpi\" : \"dpcm\");\n\t      break;\n\n\t  case IPP_TAG_URI :\n          case IPP_TAG_STRING :\n\t  case IPP_TAG_TEXT :\n\t  case IPP_TAG_NAME :\n\t  case IPP_TAG_KEYWORD :\n\t  case IPP_TAG_CHARSET :\n\t  case IPP_TAG_LANGUAGE :\n\t      if (!_cups_strcasecmp(banner->filetype->type, \"postscript\"))\n\t      {\n\t       /*\n\t        * Need to quote strings for PS banners...\n\t\t*/\n\n\t        const char *p;\n\n\t\tfor (p = attr->values[i].string.text; *p; p ++)\n\t\t{\n\t\t  if (*p == '(' || *p == ')' || *p == '\\\\')\n\t\t  {\n\t\t    cupsFilePutChar(out, '\\\\');\n\t\t    cupsFilePutChar(out, *p);\n\t\t  }\n\t\t  else if (*p < 32 || *p > 126)\n\t\t    cupsFilePrintf(out, \"\\\\%03o\", *p & 255);\n\t\t  else\n\t\t    cupsFilePutChar(out, *p);\n\t\t}\n\t      }\n\t      else\n\t\tcupsFilePuts(out, attr->values[i].string.text);\n\t      break;\n\n          default :\n\t      break; /* anti-compiler-warning-code */\n\t}\n      }\n    }\n    else if (ch == '\\\\')\t/* Quoted char */\n    {\n      ch = cupsFileGetChar(in);\n\n      if (ch != '{')\t\t/* Only do special handling for \\{ */\n        cupsFilePutChar(out, '\\\\');\n\n      cupsFilePutChar(out, ch);\n    }\n    else\n      cupsFilePutChar(out, ch);\n\n  cupsFileClose(in);\n\n  kbytes = (cupsFileTell(out) + 1023) / 1024;\n\n  job->koctets += kbytes;\n\n  if ((attr = ippFindAttribute(job->attrs, \"job-k-octets\", IPP_TAG_INTEGER)) != NULL)\n    attr->values[0].integer += kbytes;\n\n  cupsFileClose(out);\n\n  return (kbytes);\n}\n\n\n/*\n * 'copy_file()' - Copy a PPD file...\n */\n\nstatic int\t\t\t\t/* O - 0 = success, -1 = error */\ncopy_file(const char *from,\t\t/* I - Source file */\n          const char *to,\t\t/* I - Destination file */\n\t  mode_t     mode)\t\t/* I - Permissions */\n{\n  cups_file_t\t*src,\t\t\t/* Source file */\n\t\t*dst;\t\t\t/* Destination file */\n  int\t\tbytes;\t\t\t/* Bytes to read/write */\n  char\t\tbuffer[2048];\t\t/* Copy buffer */\n\n\n  cupsdLogMessage(CUPSD_LOG_DEBUG2, \"copy_file(\\\"%s\\\", \\\"%s\\\")\", from, to);\n\n /*\n  * Open the source and destination file for a copy...\n  */\n\n  if ((src = cupsFileOpen(from, \"rb\")) == NULL)\n    return (-1);\n\n  if ((dst = cupsdCreateConfFile(to, mode)) == NULL)\n  {\n    cupsFileClose(src);\n    return (-1);\n  }\n\n /*\n  * Copy the source file to the destination...\n  */\n\n  while ((bytes = cupsFileRead(src, buffer, sizeof(buffer))) > 0)\n    if (cupsFileWrite(dst, buffer, (size_t)bytes) < bytes)\n    {\n      cupsFileClose(src);\n      cupsFileClose(dst);\n      return (-1);\n    }\n\n /*\n  * Close both files and return...\n  */\n\n  cupsFileClose(src);\n\n  return (cupsdCloseCreatedConfFile(dst, to));\n}\n\n\n/*\n * 'copy_model()' - Copy a PPD model file, substituting default values\n *                  as needed...\n */\n\nstatic int\t\t\t\t/* O - 0 = success, -1 = error */\ncopy_model(cupsd_client_t *con,\t\t/* I - Client connection */\n           const char     *from,\t/* I - Source file */\n           const char     *to)\t\t/* I - Destination file */\n{\n  fd_set\tinput;\t\t\t/* select() input set */\n  struct timeval timeout;\t\t/* select() timeout */\n  int\t\tmaxfd;\t\t\t/* Max file descriptor for select() */\n  char\t\ttempfile[1024];\t\t/* Temporary PPD file */\n  int\t\ttempfd;\t\t\t/* Temporary PPD file descriptor */\n  int\t\ttemppid;\t\t/* Process ID of cups-driverd */\n  int\t\ttemppipe[2];\t\t/* Temporary pipes */\n  char\t\t*argv[4],\t\t/* Command-line arguments */\n\t\t*envp[MAX_ENV];\t\t/* Environment */\n  cups_file_t\t*src,\t\t\t/* Source file */\n\t\t*dst;\t\t\t/* Destination file */\n  ppd_file_t\t*ppd;\t\t\t/* PPD file */\n  int\t\tbytes,\t\t\t/* Bytes from pipe */\n\t\ttotal;\t\t\t/* Total bytes from pipe */\n  char\t\tbuffer[2048];\t\t/* Copy buffer */\n  int\t\ti;\t\t\t/* Looping var */\n  char\t\toption[PPD_MAX_NAME],\t/* Option name */\n\t\tchoice[PPD_MAX_NAME];\t/* Choice name */\n  ppd_size_t\t*size;\t\t\t/* Default size */\n  int\t\tnum_defaults;\t\t/* Number of default options */\n  cups_option_t\t*defaults;\t\t/* Default options */\n  char\t\tcups_protocol[PPD_MAX_LINE];\n\t\t\t\t\t/* cupsProtocol attribute */\n\n\n  cupsdLogMessage(CUPSD_LOG_DEBUG2, \"copy_model(con=%p, from=\\\"%s\\\", to=\\\"%s\\\")\", con, from, to);\n\n /*\n  * Run cups-driverd to get the PPD file...\n  */\n\n  argv[0] = \"cups-driverd\";\n  argv[1] = \"cat\";\n  argv[2] = (char *)from;\n  argv[3] = NULL;\n\n  cupsdLoadEnv(envp, (int)(sizeof(envp) / sizeof(envp[0])));\n\n  snprintf(buffer, sizeof(buffer), \"%s/daemon/cups-driverd\", ServerBin);\n  snprintf(tempfile, sizeof(tempfile), \"%s/%d.ppd\", TempDir, con->number);\n  tempfd = open(tempfile, O_WRONLY | O_CREAT | O_TRUNC, 0600);\n  if (tempfd < 0 || cupsdOpenPipe(temppipe))\n    return (-1);\n\n  cupsdLogMessage(CUPSD_LOG_DEBUG,\n                  \"copy_model: Running \\\"cups-driverd cat %s\\\"...\", from);\n\n  if (!cupsdStartProcess(buffer, argv, envp, -1, temppipe[1], CGIPipes[1],\n                         -1, -1, 0, DefaultProfile, NULL, &temppid))\n  {\n    close(tempfd);\n    unlink(tempfile);\n\n    return (-1);\n  }\n\n  close(temppipe[1]);\n\n /*\n  * Wait up to 30 seconds for the PPD file to be copied...\n  */\n\n  total = 0;\n\n  if (temppipe[0] > CGIPipes[0])\n    maxfd = temppipe[0] + 1;\n  else\n    maxfd = CGIPipes[0] + 1;\n\n  for (;;)\n  {\n   /*\n    * See if we have data ready...\n    */\n\n    FD_ZERO(&input);\n    FD_SET(temppipe[0], &input);\n    FD_SET(CGIPipes[0], &input);\n\n    timeout.tv_sec  = 30;\n    timeout.tv_usec = 0;\n\n    if ((i = select(maxfd, &input, NULL, NULL, &timeout)) < 0)\n    {\n      if (errno == EINTR)\n        continue;\n      else\n        break;\n    }\n    else if (i == 0)\n    {\n     /*\n      * We have timed out...\n      */\n\n      break;\n    }\n\n    if (FD_ISSET(temppipe[0], &input))\n    {\n     /*\n      * Read the PPD file from the pipe, and write it to the PPD file.\n      */\n\n      if ((bytes = read(temppipe[0], buffer, sizeof(buffer))) > 0)\n      {\n\tif (write(tempfd, buffer, (size_t)bytes) < bytes)\n          break;\n\n\ttotal += bytes;\n      }\n      else\n\tbreak;\n    }\n\n    if (FD_ISSET(CGIPipes[0], &input))\n      cupsdUpdateCGI();\n  }\n\n  close(temppipe[0]);\n  close(tempfd);\n\n  if (!total)\n  {\n   /*\n    * No data from cups-deviced...\n    */\n\n    cupsdLogMessage(CUPSD_LOG_ERROR, \"copy_model: empty PPD file\");\n    unlink(tempfile);\n    return (-1);\n  }\n\n /*\n  * Open the source file for a copy...\n  */\n\n  if ((src = cupsFileOpen(tempfile, \"rb\")) == NULL)\n  {\n    unlink(tempfile);\n    return (-1);\n  }\n\n /*\n  * Read the source file and see what page sizes are supported...\n  */\n\n  if ((ppd = _ppdOpen(src, _PPD_LOCALIZATION_NONE)) == NULL)\n  {\n    cupsFileClose(src);\n    unlink(tempfile);\n    return (-1);\n  }\n\n /*\n  * Open the destination (if possible) and set the default options...\n  */\n\n  num_defaults     = 0;\n  defaults         = NULL;\n  cups_protocol[0] = '\\0';\n\n  if ((dst = cupsFileOpen(to, \"rb\")) != NULL)\n  {\n   /*\n    * Read all of the default lines from the old PPD...\n    */\n\n    while (cupsFileGets(dst, buffer, sizeof(buffer)))\n      if (!strncmp(buffer, \"*Default\", 8))\n      {\n       /*\n\t* Add the default option...\n\t*/\n\n        if (!ppd_parse_line(buffer, option, sizeof(option),\n\t                    choice, sizeof(choice)))\n        {\n\t  ppd_option_t\t*ppdo;\t\t/* PPD option */\n\n\n         /*\n\t  * Only add the default if the default hasn't already been\n\t  * set and the choice exists in the new PPD...\n\t  */\n\n\t  if (!cupsGetOption(option, num_defaults, defaults) &&\n\t      (ppdo = ppdFindOption(ppd, option)) != NULL &&\n\t      ppdFindChoice(ppdo, choice))\n            num_defaults = cupsAddOption(option, choice, num_defaults,\n\t                                 &defaults);\n        }\n      }\n      else if (!strncmp(buffer, \"*cupsProtocol:\", 14))\n        strlcpy(cups_protocol, buffer, sizeof(cups_protocol));\n\n    cupsFileClose(dst);\n  }\n  else if ((size = ppdPageSize(ppd, DefaultPaperSize)) != NULL)\n  {\n   /*\n    * Add the default media sizes...\n    */\n\n    num_defaults = cupsAddOption(\"PageSize\", size->name,\n                                 num_defaults, &defaults);\n    num_defaults = cupsAddOption(\"PageRegion\", size->name,\n                                 num_defaults, &defaults);\n    num_defaults = cupsAddOption(\"PaperDimension\", size->name,\n                                 num_defaults, &defaults);\n    num_defaults = cupsAddOption(\"ImageableArea\", size->name,\n                                 num_defaults, &defaults);\n  }\n\n  ppdClose(ppd);\n\n /*\n  * Open the destination file for a copy...\n  */\n\n  if ((dst = cupsdCreateConfFile(to, ConfigFilePerm)) == NULL)\n  {\n    cupsFreeOptions(num_defaults, defaults);\n    cupsFileClose(src);\n    unlink(tempfile);\n    return (-1);\n  }\n\n /*\n  * Copy the source file to the destination...\n  */\n\n  cupsFileRewind(src);\n\n  while (cupsFileGets(src, buffer, sizeof(buffer)))\n  {\n    if (!strncmp(buffer, \"*Default\", 8))\n    {\n     /*\n      * Check for an previous default option choice...\n      */\n\n      if (!ppd_parse_line(buffer, option, sizeof(option),\n\t                  choice, sizeof(choice)))\n      {\n        const char\t*val;\t\t/* Default option value */\n\n\n        if ((val = cupsGetOption(option, num_defaults, defaults)) != NULL)\n\t{\n\t /*\n\t  * Substitute the previous choice...\n\t  */\n\n\t  snprintf(buffer, sizeof(buffer), \"*Default%s: %s\", option, val);\n\t}\n      }\n    }\n\n    cupsFilePrintf(dst, \"%s\\n\", buffer);\n  }\n\n  if (cups_protocol[0])\n    cupsFilePrintf(dst, \"%s\\n\", cups_protocol);\n\n  cupsFreeOptions(num_defaults, defaults);\n\n /*\n  * Close both files and return...\n  */\n\n  cupsFileClose(src);\n\n  unlink(tempfile);\n\n  return (cupsdCloseCreatedConfFile(dst, to));\n}\n\n\n/*\n * 'copy_job_attrs()' - Copy job attributes.\n */\n\nstatic void\ncopy_job_attrs(cupsd_client_t *con,\t/* I - Client connection */\n\t       cupsd_job_t    *job,\t/* I - Job */\n\t       cups_array_t   *ra,\t/* I - Requested attributes array */\n\t       cups_array_t   *exclude)\t/* I - Private attributes array */\n{\n  char\tjob_uri[HTTP_MAX_URI];\t\t/* Job URI */\n\n\n /*\n  * Send the requested attributes for each job...\n  */\n\n  if (!cupsArrayFind(exclude, \"all\"))\n  {\n    if ((!exclude || !cupsArrayFind(exclude, \"number-of-documents\")) &&\n        (!ra || cupsArrayFind(ra, \"number-of-documents\")))\n      ippAddInteger(con->response, IPP_TAG_JOB, IPP_TAG_INTEGER,\n\t\t    \"number-of-documents\", job->num_files);\n\n    if ((!exclude || !cupsArrayFind(exclude, \"job-media-progress\")) &&\n        (!ra || cupsArrayFind(ra, \"job-media-progress\")))\n      ippAddInteger(con->response, IPP_TAG_JOB, IPP_TAG_INTEGER,\n\t\t    \"job-media-progress\", job->progress);\n\n    if ((!exclude || !cupsArrayFind(exclude, \"job-more-info\")) &&\n        (!ra || cupsArrayFind(ra, \"job-more-info\")))\n    {\n      httpAssembleURIf(HTTP_URI_CODING_ALL, job_uri, sizeof(job_uri), \"http\",\n                       NULL, con->clientname, con->clientport, \"/jobs/%d\",\n\t\t       job->id);\n      ippAddString(con->response, IPP_TAG_JOB, IPP_TAG_URI,\n\t\t   \"job-more-info\", NULL, job_uri);\n    }\n\n    if (job->state_value > IPP_JOB_PROCESSING &&\n\t(!exclude || !cupsArrayFind(exclude, \"job-preserved\")) &&\n        (!ra || cupsArrayFind(ra, \"job-preserved\")))\n      ippAddBoolean(con->response, IPP_TAG_JOB, \"job-preserved\",\n\t\t    job->num_files > 0);\n\n    if ((!exclude || !cupsArrayFind(exclude, \"job-printer-up-time\")) &&\n        (!ra || cupsArrayFind(ra, \"job-printer-up-time\")))\n      ippAddInteger(con->response, IPP_TAG_JOB, IPP_TAG_INTEGER,\n\t\t    \"job-printer-up-time\", time(NULL));\n  }\n\n  if (!ra || cupsArrayFind(ra, \"job-printer-uri\"))\n  {\n    httpAssembleURIf(HTTP_URI_CODING_ALL, job_uri, sizeof(job_uri), \"ipp\", NULL,\n\t\t     con->clientname, con->clientport,\n\t\t     (job->dtype & CUPS_PRINTER_CLASS) ? \"/classes/%s\" :\n\t\t                                         \"/printers/%s\",\n\t\t     job->dest);\n    ippAddString(con->response, IPP_TAG_JOB, IPP_TAG_URI,\n        \t \"job-printer-uri\", NULL, job_uri);\n  }\n\n  if (!ra || cupsArrayFind(ra, \"job-uri\"))\n  {\n    httpAssembleURIf(HTTP_URI_CODING_ALL, job_uri, sizeof(job_uri), \"ipp\", NULL,\n\t\t     con->clientname, con->clientport, \"/jobs/%d\",\n\t\t     job->id);\n    ippAddString(con->response, IPP_TAG_JOB, IPP_TAG_URI,\n        \t \"job-uri\", NULL, job_uri);\n  }\n\n  if (job->attrs)\n  {\n    copy_attrs(con->response, job->attrs, ra, IPP_TAG_JOB, 0, exclude);\n  }\n  else\n  {\n   /*\n    * Generate attributes from the job structure...\n    */\n\n    if (job->completed_time && (!ra || cupsArrayFind(ra, \"date-time-at-completed\")))\n      ippAddDate(con->response, IPP_TAG_JOB, \"date-time-at-completed\", ippTimeToDate(job->completed_time));\n\n    if (job->creation_time && (!ra || cupsArrayFind(ra, \"date-time-at-creation\")))\n      ippAddDate(con->response, IPP_TAG_JOB, \"date-time-at-creation\", ippTimeToDate(job->creation_time));\n\n    if (!ra || cupsArrayFind(ra, \"job-id\"))\n      ippAddInteger(con->response, IPP_TAG_JOB, IPP_TAG_INTEGER, \"job-id\", job->id);\n\n    if (!ra || cupsArrayFind(ra, \"job-k-octets\"))\n      ippAddInteger(con->response, IPP_TAG_JOB, IPP_TAG_INTEGER, \"job-k-octets\", job->koctets);\n\n    if (job->name && (!ra || cupsArrayFind(ra, \"job-name\")))\n      ippAddString(con->response, IPP_TAG_JOB, IPP_CONST_TAG(IPP_TAG_NAME), \"job-name\", NULL, job->name);\n\n    if (job->username && (!ra || cupsArrayFind(ra, \"job-originating-user-name\")))\n      ippAddString(con->response, IPP_TAG_JOB, IPP_CONST_TAG(IPP_TAG_NAME), \"job-originating-user-name\", NULL, job->username);\n\n    if (!ra || cupsArrayFind(ra, \"job-state\"))\n      ippAddInteger(con->response, IPP_TAG_JOB, IPP_TAG_ENUM, \"job-state\", (int)job->state_value);\n\n    if (!ra || cupsArrayFind(ra, \"job-state-reasons\"))\n    {\n      switch (job->state_value)\n      {\n        default : /* Should never get here for processing, pending, held, or stopped jobs since they don't get unloaded... */\n\t    break;\n        case IPP_JSTATE_ABORTED :\n\t    ippAddString(con->response, IPP_TAG_JOB, IPP_TAG_KEYWORD, \"job-state-reasons\", NULL, \"job-aborted-by-system\");\n\t    break;\n        case IPP_JSTATE_CANCELED :\n\t    ippAddString(con->response, IPP_TAG_JOB, IPP_TAG_KEYWORD, \"job-state-reasons\", NULL, \"job-canceled-by-user\");\n\t    break;\n        case IPP_JSTATE_COMPLETED :\n\t    ippAddString(con->response, IPP_TAG_JOB, IPP_TAG_KEYWORD, \"job-state-reasons\", NULL, \"job-completed-successfully\");\n\t    break;\n      }\n    }\n\n    if (job->completed_time && (!ra || cupsArrayFind(ra, \"time-at-completed\")))\n      ippAddInteger(con->response, IPP_TAG_JOB, IPP_TAG_INTEGER, \"time-at-completed\", (int)job->completed_time);\n\n    if (job->creation_time && (!ra || cupsArrayFind(ra, \"time-at-creation\")))\n      ippAddInteger(con->response, IPP_TAG_JOB, IPP_TAG_INTEGER, \"time-at-creation\", (int)job->creation_time);\n  }\n}\n\n\n/*\n * 'copy_printer_attrs()' - Copy printer attributes.\n */\n\nstatic void\ncopy_printer_attrs(\n    cupsd_client_t  *con,\t\t/* I - Client connection */\n    cupsd_printer_t *printer,\t\t/* I - Printer */\n    cups_array_t    *ra)\t\t/* I - Requested attributes array */\n{\n  char\t\t\tprinter_uri[HTTP_MAX_URI];\n\t\t\t\t\t/* Printer URI */\n  char\t\t\tprinter_icons[HTTP_MAX_URI];\n\t\t\t\t\t/* Printer icons */\n  time_t\t\tcurtime;\t/* Current time */\n  int\t\t\ti;\t\t/* Looping var */\n\n\n /*\n  * Copy the printer attributes to the response using requested-attributes\n  * and document-format attributes that may be provided by the client.\n  */\n\n  curtime = time(NULL);\n\n  if (!ra || cupsArrayFind(ra, \"marker-change-time\"))\n    ippAddInteger(con->response, IPP_TAG_PRINTER, IPP_TAG_INTEGER,\n                  \"marker-change-time\", printer->marker_time);\n\n  if (printer->num_printers > 0 &&\n      (!ra || cupsArrayFind(ra, \"member-uris\")))\n  {\n    ipp_attribute_t\t*member_uris;\t/* member-uris attribute */\n    cupsd_printer_t\t*p2;\t\t/* Printer in class */\n    ipp_attribute_t\t*p2_uri;\t/* printer-uri-supported for class printer */\n\n\n    if ((member_uris = ippAddStrings(con->response, IPP_TAG_PRINTER,\n                                     IPP_TAG_URI, \"member-uris\",\n\t\t\t\t     printer->num_printers, NULL,\n\t\t\t\t     NULL)) != NULL)\n    {\n      for (i = 0; i < printer->num_printers; i ++)\n      {\n        p2 = printer->printers[i];\n\n        if ((p2_uri = ippFindAttribute(p2->attrs, \"printer-uri-supported\",\n\t                               IPP_TAG_URI)) != NULL)\n          member_uris->values[i].string.text =\n\t      _cupsStrRetain(p2_uri->values[0].string.text);\n        else\n\t{\n\t  httpAssembleURIf(HTTP_URI_CODING_ALL, printer_uri,\n\t                   sizeof(printer_uri), \"ipp\", NULL, con->clientname,\n\t\t\t   con->clientport,\n\t\t\t   (p2->type & CUPS_PRINTER_CLASS) ?\n\t\t\t       \"/classes/%s\" : \"/printers/%s\", p2->name);\n\t  member_uris->values[i].string.text = _cupsStrAlloc(printer_uri);\n        }\n      }\n    }\n  }\n\n  if (printer->alert && (!ra || cupsArrayFind(ra, \"printer-alert\")))\n    ippAddString(con->response, IPP_TAG_PRINTER, IPP_TAG_STRING,\n                 \"printer-alert\", NULL, printer->alert);\n\n  if (printer->alert_description &&\n      (!ra || cupsArrayFind(ra, \"printer-alert-description\")))\n    ippAddString(con->response, IPP_TAG_PRINTER, IPP_TAG_TEXT,\n                 \"printer-alert-description\", NULL,\n\t\t printer->alert_description);\n\n  if (!ra || cupsArrayFind(ra, \"printer-config-change-date-time\"))\n    ippAddDate(con->response, IPP_TAG_PRINTER, \"printer-config-change-date-time\", ippTimeToDate(printer->config_time));\n\n  if (!ra || cupsArrayFind(ra, \"printer-config-change-time\"))\n    ippAddInteger(con->response, IPP_TAG_PRINTER, IPP_TAG_INTEGER,\n                  \"printer-config-change-time\", printer->config_time);\n\n  if (!ra || cupsArrayFind(ra, \"printer-current-time\"))\n    ippAddDate(con->response, IPP_TAG_PRINTER, \"printer-current-time\",\n               ippTimeToDate(curtime));\n\n#if defined(HAVE_DNSSD) || defined(HAVE_AVAHI)\n  if (!ra || cupsArrayFind(ra, \"printer-dns-sd-name\"))\n  {\n    if (printer->reg_name)\n      ippAddString(con->response, IPP_TAG_PRINTER, IPP_TAG_NAME,\n                   \"printer-dns-sd-name\", NULL, printer->reg_name);\n    else\n      ippAddInteger(con->response, IPP_TAG_PRINTER, IPP_TAG_NOVALUE,\n                   \"printer-dns-sd-name\", 0);\n  }\n#endif /* HAVE_DNSSD || HAVE_AVAHI */\n\n  if (!ra || cupsArrayFind(ra, \"printer-error-policy\"))\n    ippAddString(con->response, IPP_TAG_PRINTER, IPP_TAG_NAME,\n        \t \"printer-error-policy\", NULL, printer->error_policy);\n\n  if (!ra || cupsArrayFind(ra, \"printer-error-policy-supported\"))\n  {\n    static const char * const errors[] =/* printer-error-policy-supported values */\n\t\t  {\n\t\t    \"abort-job\",\n\t\t    \"retry-current-job\",\n\t\t    \"retry-job\",\n\t\t    \"stop-printer\"\n\t\t  };\n\n    if (printer->type & CUPS_PRINTER_CLASS)\n      ippAddString(con->response, IPP_TAG_PRINTER, IPP_TAG_NAME | IPP_TAG_COPY,\n                   \"printer-error-policy-supported\", NULL, \"retry-current-job\");\n    else\n      ippAddStrings(con->response, IPP_TAG_PRINTER, IPP_TAG_NAME | IPP_TAG_COPY,\n\t\t    \"printer-error-policy-supported\",\n\t\t    sizeof(errors) / sizeof(errors[0]), NULL, errors);\n  }\n\n  if (!ra || cupsArrayFind(ra, \"printer-icons\"))\n  {\n    httpAssembleURIf(HTTP_URI_CODING_ALL, printer_icons, sizeof(printer_icons),\n                     \"http\", NULL, con->clientname, con->clientport,\n\t\t     \"/icons/%s.png\", printer->name);\n    ippAddString(con->response, IPP_TAG_PRINTER, IPP_TAG_URI, \"printer-icons\",\n                 NULL, printer_icons);\n    cupsdLogMessage(CUPSD_LOG_DEBUG2, \"printer-icons=\\\"%s\\\"\", printer_icons);\n  }\n\n  if (!ra || cupsArrayFind(ra, \"printer-is-accepting-jobs\"))\n    ippAddBoolean(con->response, IPP_TAG_PRINTER, \"printer-is-accepting-jobs\", (char)printer->accepting);\n\n  if (!ra || cupsArrayFind(ra, \"printer-is-shared\"))\n    ippAddBoolean(con->response, IPP_TAG_PRINTER, \"printer-is-shared\", (char)printer->shared);\n\n  if (!ra || cupsArrayFind(ra, \"printer-is-temporary\"))\n    ippAddBoolean(con->response, IPP_TAG_PRINTER, \"printer-is-temporary\", (char)printer->temporary);\n\n  if (!ra || cupsArrayFind(ra, \"printer-more-info\"))\n  {\n    httpAssembleURIf(HTTP_URI_CODING_ALL, printer_uri, sizeof(printer_uri),\n                     \"http\", NULL, con->clientname, con->clientport,\n\t\t     (printer->type & CUPS_PRINTER_CLASS) ?\n\t\t         \"/classes/%s\" : \"/printers/%s\", printer->name);\n    ippAddString(con->response, IPP_TAG_PRINTER, IPP_TAG_URI,\n        \t \"printer-more-info\", NULL, printer_uri);\n  }\n\n  if (!ra || cupsArrayFind(ra, \"printer-op-policy\"))\n    ippAddString(con->response, IPP_TAG_PRINTER, IPP_TAG_NAME,\n        \t \"printer-op-policy\", NULL, printer->op_policy);\n\n  if (!ra || cupsArrayFind(ra, \"printer-state\"))\n    ippAddInteger(con->response, IPP_TAG_PRINTER, IPP_TAG_ENUM, \"printer-state\",\n                  printer->state);\n\n  if (!ra || cupsArrayFind(ra, \"printer-state-change-date-time\"))\n    ippAddDate(con->response, IPP_TAG_PRINTER, \"printer-state-change-date-time\", ippTimeToDate(printer->state_time));\n\n  if (!ra || cupsArrayFind(ra, \"printer-state-change-time\"))\n    ippAddInteger(con->response, IPP_TAG_PRINTER, IPP_TAG_INTEGER,\n                  \"printer-state-change-time\", printer->state_time);\n\n  if (!ra || cupsArrayFind(ra, \"printer-state-message\"))\n    ippAddString(con->response, IPP_TAG_PRINTER, IPP_TAG_TEXT,\n        \t \"printer-state-message\", NULL, printer->state_message);\n\n  if (!ra || cupsArrayFind(ra, \"printer-state-reasons\"))\n    add_printer_state_reasons(con, printer);\n\n  if (!ra || cupsArrayFind(ra, \"printer-type\"))\n  {\n    cups_ptype_t type;\t\t\t/* printer-type value */\n\n   /*\n    * Add the CUPS-specific printer-type attribute...\n    */\n\n    type = printer->type;\n\n    if (printer == DefaultPrinter)\n      type |= CUPS_PRINTER_DEFAULT;\n\n    if (!printer->accepting)\n      type |= CUPS_PRINTER_REJECTING;\n\n    if (!printer->shared)\n      type |= CUPS_PRINTER_NOT_SHARED;\n\n    ippAddInteger(con->response, IPP_TAG_PRINTER, IPP_TAG_ENUM, \"printer-type\", (int)type);\n  }\n\n  if (!ra || cupsArrayFind(ra, \"printer-up-time\"))\n    ippAddInteger(con->response, IPP_TAG_PRINTER, IPP_TAG_INTEGER,\n                  \"printer-up-time\", curtime);\n\n  if (!ra || cupsArrayFind(ra, \"printer-uri-supported\"))\n  {\n    httpAssembleURIf(HTTP_URI_CODING_ALL, printer_uri, sizeof(printer_uri),\n                     \"ipp\", NULL, con->clientname, con->clientport,\n\t\t     (printer->type & CUPS_PRINTER_CLASS) ?\n\t\t         \"/classes/%s\" : \"/printers/%s\", printer->name);\n    ippAddString(con->response, IPP_TAG_PRINTER, IPP_TAG_URI,\n        \t \"printer-uri-supported\", NULL, printer_uri);\n    cupsdLogMessage(CUPSD_LOG_DEBUG2, \"printer-uri-supported=\\\"%s\\\"\",\n                    printer_uri);\n  }\n\n  if (!ra || cupsArrayFind(ra, \"queued-job-count\"))\n    add_queued_job_count(con, printer);\n\n  copy_attrs(con->response, printer->attrs, ra, IPP_TAG_ZERO, 0, NULL);\n  if (printer->ppd_attrs)\n    copy_attrs(con->response, printer->ppd_attrs, ra, IPP_TAG_ZERO, 0, NULL);\n  copy_attrs(con->response, CommonData, ra, IPP_TAG_ZERO, IPP_TAG_COPY, NULL);\n}\n\n\n/*\n * 'copy_subscription_attrs()' - Copy subscription attributes.\n */\n\nstatic void\ncopy_subscription_attrs(\n    cupsd_client_t       *con,\t\t/* I - Client connection */\n    cupsd_subscription_t *sub,\t\t/* I - Subscription */\n    cups_array_t         *ra,\t\t/* I - Requested attributes array */\n    cups_array_t         *exclude)\t/* I - Private attributes array */\n{\n  ipp_attribute_t\t*attr;\t\t/* Current attribute */\n  char\t\t\tprinter_uri[HTTP_MAX_URI];\n\t\t\t\t\t/* Printer URI */\n  int\t\t\tcount;\t\t/* Number of events */\n  unsigned\t\tmask;\t\t/* Current event mask */\n  const char\t\t*name;\t\t/* Current event name */\n\n\n  cupsdLogMessage(CUPSD_LOG_DEBUG2,\n                  \"copy_subscription_attrs(con=%p, sub=%p, ra=%p, exclude=%p)\",\n\t\t  con, sub, ra, exclude);\n\n /*\n  * Copy the subscription attributes to the response using the\n  * requested-attributes attribute that may be provided by the client.\n  */\n\n  if (!exclude || !cupsArrayFind(exclude, \"all\"))\n  {\n    if ((!exclude || !cupsArrayFind(exclude, \"notify-events\")) &&\n        (!ra || cupsArrayFind(ra, \"notify-events\")))\n    {\n      cupsdLogMessage(CUPSD_LOG_DEBUG2, \"copy_subscription_attrs: notify-events\");\n\n      if ((name = cupsdEventName((cupsd_eventmask_t)sub->mask)) != NULL)\n      {\n       /*\n\t* Simple event list...\n\t*/\n\n\tippAddString(con->response, IPP_TAG_SUBSCRIPTION,\n\t\t     (ipp_tag_t)(IPP_TAG_KEYWORD | IPP_TAG_COPY),\n\t\t     \"notify-events\", NULL, name);\n      }\n      else\n      {\n       /*\n\t* Complex event list...\n\t*/\n\n\tfor (mask = 1, count = 0; mask < CUPSD_EVENT_ALL; mask <<= 1)\n\t  if (sub->mask & mask)\n\t    count ++;\n\n\tattr = ippAddStrings(con->response, IPP_TAG_SUBSCRIPTION,\n\t\t\t     (ipp_tag_t)(IPP_TAG_KEYWORD | IPP_TAG_COPY),\n\t\t\t     \"notify-events\", count, NULL, NULL);\n\n\tfor (mask = 1, count = 0; mask < CUPSD_EVENT_ALL; mask <<= 1)\n\t  if (sub->mask & mask)\n\t  {\n\t    attr->values[count].string.text =\n\t\t(char *)cupsdEventName((cupsd_eventmask_t)mask);\n\n\t    count ++;\n\t  }\n      }\n    }\n\n    if ((!exclude || !cupsArrayFind(exclude, \"notify-lease-duration\")) &&\n        (!sub->job && (!ra || cupsArrayFind(ra, \"notify-lease-duration\"))))\n      ippAddInteger(con->response, IPP_TAG_SUBSCRIPTION, IPP_TAG_INTEGER,\n\t\t    \"notify-lease-duration\", sub->lease);\n\n    if ((!exclude || !cupsArrayFind(exclude, \"notify-recipient-uri\")) &&\n        (sub->recipient && (!ra || cupsArrayFind(ra, \"notify-recipient-uri\"))))\n      ippAddString(con->response, IPP_TAG_SUBSCRIPTION, IPP_TAG_URI,\n\t\t   \"notify-recipient-uri\", NULL, sub->recipient);\n    else if ((!exclude || !cupsArrayFind(exclude, \"notify-pull-method\")) &&\n             (!ra || cupsArrayFind(ra, \"notify-pull-method\")))\n      ippAddString(con->response, IPP_TAG_SUBSCRIPTION, IPP_TAG_KEYWORD,\n\t\t   \"notify-pull-method\", NULL, \"ippget\");\n\n    if ((!exclude || !cupsArrayFind(exclude, \"notify-subscriber-user-name\")) &&\n        (!ra || cupsArrayFind(ra, \"notify-subscriber-user-name\")))\n      ippAddString(con->response, IPP_TAG_SUBSCRIPTION, IPP_TAG_NAME,\n\t\t   \"notify-subscriber-user-name\", NULL, sub->owner);\n\n    if ((!exclude || !cupsArrayFind(exclude, \"notify-time-interval\")) &&\n        (!ra || cupsArrayFind(ra, \"notify-time-interval\")))\n      ippAddInteger(con->response, IPP_TAG_SUBSCRIPTION, IPP_TAG_INTEGER,\n\t\t    \"notify-time-interval\", sub->interval);\n\n    if (sub->user_data_len > 0 &&\n\t(!exclude || !cupsArrayFind(exclude, \"notify-user-data\")) &&\n        (!ra || cupsArrayFind(ra, \"notify-user-data\")))\n      ippAddOctetString(con->response, IPP_TAG_SUBSCRIPTION, \"notify-user-data\",\n\t\t\tsub->user_data, sub->user_data_len);\n  }\n\n  if (sub->job && (!ra || cupsArrayFind(ra, \"notify-job-id\")))\n    ippAddInteger(con->response, IPP_TAG_SUBSCRIPTION, IPP_TAG_INTEGER,\n                  \"notify-job-id\", sub->job->id);\n\n  if (sub->dest && (!ra || cupsArrayFind(ra, \"notify-printer-uri\")))\n  {\n    httpAssembleURIf(HTTP_URI_CODING_ALL, printer_uri, sizeof(printer_uri),\n                     \"ipp\", NULL, con->clientname, con->clientport,\n\t\t     \"/printers/%s\", sub->dest->name);\n    ippAddString(con->response, IPP_TAG_SUBSCRIPTION, IPP_TAG_URI,\n        \t \"notify-printer-uri\", NULL, printer_uri);\n  }\n\n  if (!ra || cupsArrayFind(ra, \"notify-subscription-id\"))\n    ippAddInteger(con->response, IPP_TAG_SUBSCRIPTION, IPP_TAG_INTEGER,\n                  \"notify-subscription-id\", sub->id);\n}\n\n\n/*\n * 'create_job()' - Print a file to a printer or class.\n */\n\nstatic void\ncreate_job(cupsd_client_t  *con,\t/* I - Client connection */\n\t   ipp_attribute_t *uri)\t/* I - Printer URI */\n{\n  int\t\t\ti;\t\t/* Looping var */\n  cupsd_printer_t\t*printer;\t/* Printer */\n  cupsd_job_t\t\t*job;\t\t/* New job */\n  static const char * const forbidden_attrs[] =\n  {\t\t\t\t\t/* List of forbidden attributes */\n    \"compression\",\n    \"document-format\",\n    \"document-name\",\n    \"document-natural-language\"\n  };\n\n\n  cupsdLogMessage(CUPSD_LOG_DEBUG2, \"create_job(%p[%d], %s)\", con,\n                  con->number, uri->values[0].string.text);\n\n /*\n  * Is the destination valid?\n  */\n\n  if (!cupsdValidateDest(uri->values[0].string.text, NULL, &printer))\n  {\n   /*\n    * Bad URI...\n    */\n\n    send_ipp_status(con, IPP_NOT_FOUND,\n                    _(\"The printer or class does not exist.\"));\n    return;\n  }\n\n /*\n  * Check for invalid Create-Job attributes and log a warning or error depending\n  * on whether cupsd is running in \"strict conformance\" mode...\n  */\n\n  for (i = 0;\n       i < (int)(sizeof(forbidden_attrs) / sizeof(forbidden_attrs[0]));\n       i ++)\n    if (ippFindAttribute(con->request, forbidden_attrs[i], IPP_TAG_ZERO))\n    {\n      if (StrictConformance)\n      {\n\tsend_ipp_status(con, IPP_BAD_REQUEST,\n\t\t\t_(\"The '%s' operation attribute cannot be supplied in a \"\n\t\t\t  \"Create-Job request.\"), forbidden_attrs[i]);\n\treturn;\n      }\n\n      cupsdLogMessage(CUPSD_LOG_WARN,\n                      \"Unexpected '%s' operation attribute in a Create-Job \"\n                      \"request.\", forbidden_attrs[i]);\n    }\n\n /*\n  * Create the job object...\n  */\n\n  if ((job = add_job(con, printer, NULL)) == NULL)\n    return;\n\n  job->pending_timeout = 1;\n\n /*\n  * Save and log the job...\n  */\n\n  cupsdLogJob(job, CUPSD_LOG_INFO, \"Queued on \\\"%s\\\" by \\\"%s\\\".\",\n\t      job->dest, job->username);\n}\n\n\n/*\n * 'create_local_bg_thread()' - Background thread for creating a local print queue.\n */\n\nstatic void *\t\t\t\t/* O - Exit status */\ncreate_local_bg_thread(\n    cupsd_printer_t *printer)\t\t/* I - Printer */\n{\n  cups_file_t\t*from,\t\t\t/* Source file */\n\t\t*to;\t\t\t/* Destination file */\n  char\t\tfromppd[1024],\t\t/* Source PPD */\n\t\ttoppd[1024],\t\t/* Destination PPD */\n\t\tscheme[32],\t\t/* URI scheme */\n\t\tuserpass[256],\t\t/* User:pass */\n\t\thost[256],\t\t/* Hostname */\n\t\tresource[1024],\t\t/* Resource path */\n\t\tline[1024];\t\t/* Line from PPD */\n  int\t\tport;\t\t\t/* Port number */\n  http_encryption_t encryption;\t\t/* Type of encryption to use */\n  http_t\t*http;\t\t\t/* Connection to printer */\n  ipp_t\t\t*request,\t\t/* Request to printer */\n\t\t*response;\t\t/* Response from printer */\n  ipp_attribute_t *attr;\t\t/* Attribute in response */\n\n\n /*\n  * Try connecting to the printer...\n  */\n\n  cupsdLogMessage(CUPSD_LOG_DEBUG, \"%s: Generating PPD file from \\\"%s\\\"...\", printer->name, printer->device_uri);\n\n  if (httpSeparateURI(HTTP_URI_CODING_ALL, printer->device_uri, scheme, sizeof(scheme), userpass, sizeof(userpass), host, sizeof(host), &port, resource, sizeof(resource)) < HTTP_URI_STATUS_OK)\n  {\n    cupsdLogMessage(CUPSD_LOG_ERROR, \"%s: Bad device URI \\\"%s\\\".\", printer->name, printer->device_uri);\n    return (NULL);\n  }\n\n  if (!strcmp(scheme, \"ipps\") || port == 443)\n    encryption = HTTP_ENCRYPTION_ALWAYS;\n  else\n    encryption = HTTP_ENCRYPTION_IF_REQUESTED;\n\n  if ((http = httpConnect2(host, port, NULL, AF_UNSPEC, encryption, 1, 30000, NULL)) == NULL)\n  {\n    cupsdLogMessage(CUPSD_LOG_ERROR, \"%s: Unable to connect to %s:%d: %s\", printer->name, host, port, cupsLastErrorString());\n    return (NULL);\n  }\n\n /*\n  * Query the printer for its capabilities...\n  */\n\n  cupsdLogMessage(CUPSD_LOG_DEBUG, \"%s: Connected to %s:%d, sending Get-Printer-Attributes request...\", printer->name, host, port);\n\n  request = ippNewRequest(IPP_OP_GET_PRINTER_ATTRIBUTES);\n  ippAddString(request, IPP_TAG_OPERATION, IPP_TAG_URI, \"printer-uri\", NULL, printer->device_uri);\n  ippAddString(request, IPP_TAG_OPERATION, IPP_TAG_KEYWORD, \"requested-attributes\", NULL, \"all\");\n\n  response = cupsDoRequest(http, request, resource);\n\n  cupsdLogMessage(CUPSD_LOG_DEBUG, \"%s: Get-Printer-Attributes returned %s\", printer->name, ippErrorString(cupsLastError()));\n\n  // TODO: Grab printer icon file...\n  httpClose(http);\n\n /*\n  * Write the PPD for the queue...\n  */\n\n  if (_ppdCreateFromIPP(fromppd, sizeof(fromppd), response))\n  {\n    if ((!printer->info || !*(printer->info)) && (attr = ippFindAttribute(response, \"printer-info\", IPP_TAG_TEXT)) != NULL)\n      cupsdSetString(&printer->info, ippGetString(attr, 0, NULL));\n\n    if ((!printer->location || !*(printer->location)) && (attr = ippFindAttribute(response, \"printer-location\", IPP_TAG_TEXT)) != NULL)\n      cupsdSetString(&printer->location, ippGetString(attr, 0, NULL));\n\n    if ((!printer->geo_location || !*(printer->geo_location)) && (attr = ippFindAttribute(response, \"printer-geo-location\", IPP_TAG_URI)) != NULL)\n      cupsdSetString(&printer->geo_location, ippGetString(attr, 0, NULL));\n\n    if ((from = cupsFileOpen(fromppd, \"r\")) == NULL)\n    {\n      cupsdLogMessage(CUPSD_LOG_ERROR, \"%s: Unable to read generated PPD: %s\", printer->name, strerror(errno));\n      return (NULL);\n    }\n\n    snprintf(toppd, sizeof(toppd), \"%s/ppd/%s.ppd\", ServerRoot, printer->name);\n    if ((to = cupsdCreateConfFile(toppd, ConfigFilePerm)) == NULL)\n    {\n      cupsdLogMessage(CUPSD_LOG_ERROR, \"%s: Unable to create PPD for printer: %s\", printer->name, strerror(errno));\n      cupsFileClose(from);\n      return (NULL);\n    }\n\n    while (cupsFileGets(from, line, sizeof(line)))\n      cupsFilePrintf(to, \"%s\\n\", line);\n\n    cupsFileClose(from);\n    if (!cupsdCloseCreatedConfFile(to, toppd))\n    {\n      printer->config_time = time(NULL);\n      printer->state       = IPP_PSTATE_IDLE;\n      printer->accepting   = 1;\n\n      cupsdSetPrinterAttrs(printer);\n\n      cupsdAddEvent(CUPSD_EVENT_PRINTER_CONFIG, printer, NULL, \"Printer \\\"%s\\\" is now available.\", printer->name);\n      cupsdLogMessage(CUPSD_LOG_INFO, \"Printer \\\"%s\\\" is now available.\", printer->name);\n    }\n  }\n  else\n    cupsdLogMessage(CUPSD_LOG_ERROR, \"%s: PPD creation failed: %s\", printer->name, cupsLastErrorString());\n\n  return (NULL);\n}\n\n\n/*\n * 'create_local_printer()' - Create a local (temporary) print queue.\n */\n\nstatic void\ncreate_local_printer(\n    cupsd_client_t *con)\t\t/* I - Client connection */\n{\n  ipp_attribute_t *device_uri,\t\t/* device-uri attribute */\n\t\t*printer_geo_location,\t/* printer-geo-location attribute */\n\t\t*printer_info,\t\t/* printer-info attribute */\n\t\t*printer_location,\t/* printer-location attribute */\n\t\t*printer_name;\t\t/* printer-name attribute */\n  cupsd_printer_t *printer;\t\t/* New printer */\n  http_status_t\tstatus;\t\t\t/* Policy status */\n  char\t\tname[128],\t\t/* Sanitized printer name */\n\t\t*nameptr,\t\t/* Pointer into name */\n\t\turi[1024];\t\t/* printer-uri-supported value */\n  const char\t*ptr;\t\t\t/* Pointer into attribute value */\n\n\n /*\n  * Require local access to create a local printer...\n  */\n\n  if (!httpAddrLocalhost(httpGetAddress(con->http)))\n  {\n    send_ipp_status(con, IPP_STATUS_ERROR_FORBIDDEN, _(\"Only local users can create a local printer.\"));\n    return;\n  }\n\n /*\n  * Check any other policy limits...\n  */\n\n  if ((status = cupsdCheckPolicy(DefaultPolicyPtr, con, NULL)) != HTTP_OK)\n  {\n    send_http_error(con, status, NULL);\n    return;\n  }\n\n /*\n  * Grab needed attributes...\n  */\n\n  if ((printer_name = ippFindAttribute(con->request, \"printer-name\", IPP_TAG_ZERO)) == NULL || ippGetGroupTag(printer_name) != IPP_TAG_PRINTER || ippGetValueTag(printer_name) != IPP_TAG_NAME)\n  {\n    if (!printer_name)\n      send_ipp_status(con, IPP_STATUS_ERROR_BAD_REQUEST, _(\"Missing required attribute \\\"%s\\\".\"), \"printer-name\");\n    else if (ippGetGroupTag(printer_name) != IPP_TAG_PRINTER)\n      send_ipp_status(con, IPP_STATUS_ERROR_BAD_REQUEST, _(\"Attribute \\\"%s\\\" is in the wrong group.\"), \"printer-name\");\n    else\n      send_ipp_status(con, IPP_STATUS_ERROR_BAD_REQUEST, _(\"Attribute \\\"%s\\\" is the wrong value type.\"), \"printer-name\");\n\n    return;\n  }\n\n  for (nameptr = name, ptr = ippGetString(printer_name, 0, NULL); *ptr && nameptr < (name + sizeof(name) - 1); ptr ++)\n  {\n   /*\n    * Sanitize the printer name...\n    */\n\n    if (_cups_isalnum(*ptr))\n      *nameptr++ = *ptr;\n    else if (nameptr == name || nameptr[-1] != '_')\n      *nameptr++ = '_';\n  }\n\n  *nameptr = '\\0';\n\n  if ((device_uri = ippFindAttribute(con->request, \"device-uri\", IPP_TAG_ZERO)) == NULL || ippGetGroupTag(device_uri) != IPP_TAG_PRINTER || ippGetValueTag(device_uri) != IPP_TAG_URI)\n  {\n    if (!device_uri)\n      send_ipp_status(con, IPP_STATUS_ERROR_BAD_REQUEST, _(\"Missing required attribute \\\"%s\\\".\"), \"device-uri\");\n    else if (ippGetGroupTag(device_uri) != IPP_TAG_PRINTER)\n      send_ipp_status(con, IPP_STATUS_ERROR_BAD_REQUEST, _(\"Attribute \\\"%s\\\" is in the wrong group.\"), \"device-uri\");\n    else\n      send_ipp_status(con, IPP_STATUS_ERROR_BAD_REQUEST, _(\"Attribute \\\"%s\\\" is the wrong value type.\"), \"device-uri\");\n\n    return;\n  }\n\n  printer_geo_location = ippFindAttribute(con->request, \"printer-geo-location\", IPP_TAG_URI);\n  printer_info         = ippFindAttribute(con->request, \"printer-info\", IPP_TAG_TEXT);\n  printer_location     = ippFindAttribute(con->request, \"printer-location\", IPP_TAG_TEXT);\n\n /*\n  * See if the printer already exists...\n  */\n\n  if ((printer = cupsdFindDest(name)) != NULL)\n  {\n    send_ipp_status(con, IPP_STATUS_ERROR_NOT_POSSIBLE, _(\"Printer \\\"%s\\\" already exists.\"), name);\n    goto add_printer_attributes;\n  }\n\n /*\n  * Create the printer...\n  */\n\n  if ((printer = cupsdAddPrinter(name)) == NULL)\n  {\n    send_ipp_status(con, IPP_STATUS_ERROR_INTERNAL, _(\"Unable to create printer.\"));\n    return;\n  }\n\n  printer->shared    = 0;\n  printer->temporary = 1;\n\n  cupsdSetDeviceURI(printer, ippGetString(device_uri, 0, NULL));\n\n  if (printer_geo_location)\n    cupsdSetString(&printer->geo_location, ippGetString(printer_geo_location, 0, NULL));\n  if (printer_info)\n    cupsdSetString(&printer->info, ippGetString(printer_info, 0, NULL));\n  if (printer_location)\n    cupsdSetString(&printer->location, ippGetString(printer_location, 0, NULL));\n\n  cupsdSetPrinterAttrs(printer);\n\n /*\n  * Run a background thread to create the PPD...\n  */\n\n  _cupsThreadCreate((_cups_thread_func_t)create_local_bg_thread, printer);\n\n /*\n  * Return printer attributes...\n  */\n\n  send_ipp_status(con, IPP_STATUS_OK, _(\"Local printer created.\"));\n\n  add_printer_attributes:\n\n  ippAddBoolean(con->response, IPP_TAG_PRINTER, \"printer-is-accepting-jobs\", (char)printer->accepting);\n  ippAddInteger(con->response, IPP_TAG_PRINTER, IPP_TAG_ENUM, \"printer-state\", printer->state);\n  add_printer_state_reasons(con, printer);\n\n  httpAssembleURIf(HTTP_URI_CODING_ALL, uri, sizeof(uri), httpIsEncrypted(con->http) ? \"ipps\" : \"ipp\", NULL, con->clientname, con->clientport, \"/printers/%s\", printer->name);\n  ippAddString(con->response, IPP_TAG_PRINTER, IPP_TAG_URI, \"printer-uri-supported\", NULL, uri);\n}\n\n\n/*\n * 'create_requested_array()' - Create an array for the requested-attributes.\n */\n\nstatic cups_array_t *\t\t\t/* O - Array of attributes or NULL */\ncreate_requested_array(ipp_t *request)\t/* I - IPP request */\n{\n  cups_array_t\t\t*ra;\t\t/* Requested attributes array */\n\n\n /*\n  * Create the array for standard attributes...\n  */\n\n  ra = ippCreateRequestedArray(request);\n\n /*\n  * Add CUPS defaults as needed...\n  */\n\n  if (cupsArrayFind(ra, \"printer-defaults\"))\n  {\n   /*\n    * Include user-set defaults...\n    */\n\n    char\t*name;\t\t\t/* Option name */\n\n    cupsArrayRemove(ra, \"printer-defaults\");\n\n    for (name = (char *)cupsArrayFirst(CommonDefaults);\n\t name;\n\t name = (char *)cupsArrayNext(CommonDefaults))\n      if (!cupsArrayFind(ra, name))\n        cupsArrayAdd(ra, name);\n  }\n\n  return (ra);\n}\n\n\n/*\n * 'create_subscriptions()' - Create one or more notification subscriptions.\n */\n\nstatic void\ncreate_subscriptions(\n    cupsd_client_t  *con,\t\t/* I - Client connection */\n    ipp_attribute_t *uri)\t\t/* I - Printer URI */\n{\n  http_status_t\tstatus;\t\t\t/* Policy status */\n  int\t\t\ti;\t\t/* Looping var */\n  ipp_attribute_t\t*attr;\t\t/* Current attribute */\n  cups_ptype_t\t\tdtype;\t\t/* Destination type (printer/class) */\n  char\t\t\tscheme[HTTP_MAX_URI],\n\t\t\t\t\t/* Scheme portion of URI */\n\t\t\tuserpass[HTTP_MAX_URI],\n\t\t\t\t\t/* Username portion of URI */\n\t\t\thost[HTTP_MAX_URI],\n\t\t\t\t\t/* Host portion of URI */\n\t\t\tresource[HTTP_MAX_URI];\n\t\t\t\t\t/* Resource portion of URI */\n  int\t\t\tport;\t\t/* Port portion of URI */\n  cupsd_printer_t\t*printer;\t/* Printer/class */\n  cupsd_job_t\t\t*job;\t\t/* Job */\n  int\t\t\tjobid;\t\t/* Job ID */\n  cupsd_subscription_t\t*sub;\t\t/* Subscription object */\n  const char\t\t*username,\t/* requesting-user-name or\n\t\t\t\t\t   authenticated username */\n\t\t\t*recipient,\t/* notify-recipient-uri */\n\t\t\t*pullmethod;\t/* notify-pull-method */\n  ipp_attribute_t\t*user_data;\t/* notify-user-data */\n  int\t\t\tinterval,\t/* notify-time-interval */\n\t\t\tlease;\t\t/* notify-lease-duration */\n  unsigned\t\tmask;\t\t/* notify-events */\n  ipp_attribute_t\t*notify_events,/* notify-events(-default) */\n\t\t\t*notify_lease;\t/* notify-lease-duration(-default) */\n\n\n#ifdef DEBUG\n  for (attr = con->request->attrs; attr; attr = attr->next)\n  {\n    if (attr->group_tag != IPP_TAG_ZERO)\n      cupsdLogMessage(CUPSD_LOG_DEBUG2, \"g%04x v%04x %s\", attr->group_tag,\n                      attr->value_tag, attr->name);\n    else\n      cupsdLogMessage(CUPSD_LOG_DEBUG2, \"----SEP----\");\n  }\n#endif /* DEBUG */\n\n /*\n  * Is the destination valid?\n  */\n\n  cupsdLogMessage(CUPSD_LOG_DEBUG, \"create_subscriptions(con=%p(%d), uri=\\\"%s\\\")\", con, con->number, uri->values[0].string.text);\n\n  httpSeparateURI(HTTP_URI_CODING_ALL, uri->values[0].string.text, scheme,\n                  sizeof(scheme), userpass, sizeof(userpass), host,\n\t\t  sizeof(host), &port, resource, sizeof(resource));\n\n  if (!strcmp(resource, \"/\"))\n  {\n    dtype   = (cups_ptype_t)0;\n    printer = NULL;\n  }\n  else if (!strncmp(resource, \"/printers\", 9) && strlen(resource) <= 10)\n  {\n    dtype   = (cups_ptype_t)0;\n    printer = NULL;\n  }\n  else if (!strncmp(resource, \"/classes\", 8) && strlen(resource) <= 9)\n  {\n    dtype   = CUPS_PRINTER_CLASS;\n    printer = NULL;\n  }\n  else if (!cupsdValidateDest(uri->values[0].string.text, &dtype, &printer))\n  {\n   /*\n    * Bad URI...\n    */\n\n    send_ipp_status(con, IPP_NOT_FOUND,\n                    _(\"The printer or class does not exist.\"));\n    return;\n  }\n\n /*\n  * Check policy...\n  */\n\n  if (printer)\n  {\n    if ((status = cupsdCheckPolicy(printer->op_policy_ptr, con,\n                                   NULL)) != HTTP_OK)\n    {\n      send_http_error(con, status, printer);\n      return;\n    }\n  }\n  else if ((status = cupsdCheckPolicy(DefaultPolicyPtr, con, NULL)) != HTTP_OK)\n  {\n    send_http_error(con, status, NULL);\n    return;\n  }\n\n /*\n  * Get the user that is requesting the subscription...\n  */\n\n  username = get_username(con);\n\n /*\n  * Find the first subscription group attribute; return if we have\n  * none...\n  */\n\n  for (attr = con->request->attrs; attr; attr = attr->next)\n    if (attr->group_tag == IPP_TAG_SUBSCRIPTION)\n      break;\n\n  if (!attr)\n  {\n    send_ipp_status(con, IPP_BAD_REQUEST,\n                    _(\"No subscription attributes in request.\"));\n    return;\n  }\n\n /*\n  * Process the subscription attributes in the request...\n  */\n\n  con->response->request.status.status_code = IPP_BAD_REQUEST;\n\n  while (attr)\n  {\n    recipient = NULL;\n    pullmethod = NULL;\n    user_data  = NULL;\n    interval   = 0;\n    lease      = DefaultLeaseDuration;\n    jobid      = 0;\n    mask       = CUPSD_EVENT_NONE;\n\n    if (printer)\n    {\n      notify_events = ippFindAttribute(printer->attrs, \"notify-events-default\",\n                                       IPP_TAG_KEYWORD);\n      notify_lease  = ippFindAttribute(printer->attrs,\n                                       \"notify-lease-duration-default\",\n                                       IPP_TAG_INTEGER);\n\n      if (notify_lease)\n        lease = notify_lease->values[0].integer;\n    }\n    else\n    {\n      notify_events = NULL;\n      notify_lease  = NULL;\n    }\n\n    while (attr && attr->group_tag != IPP_TAG_ZERO)\n    {\n      if (!strcmp(attr->name, \"notify-recipient-uri\") &&\n          attr->value_tag == IPP_TAG_URI)\n      {\n       /*\n        * Validate the recipient scheme against the ServerBin/notifier\n\t* directory...\n\t*/\n\n\tchar\tnotifier[1024];\t\t/* Notifier filename */\n\n\n        recipient = attr->values[0].string.text;\n\n\tif (httpSeparateURI(HTTP_URI_CODING_ALL, recipient,\n\t                    scheme, sizeof(scheme), userpass, sizeof(userpass),\n\t\t\t    host, sizeof(host), &port,\n\t\t\t    resource, sizeof(resource)) < HTTP_URI_OK)\n        {\n          send_ipp_status(con, IPP_NOT_POSSIBLE,\n\t                  _(\"Bad notify-recipient-uri \\\"%s\\\".\"), recipient);\n\t  ippAddInteger(con->response, IPP_TAG_SUBSCRIPTION, IPP_TAG_ENUM,\n\t                \"notify-status-code\", IPP_URI_SCHEME);\n\t  return;\n\t}\n\n        snprintf(notifier, sizeof(notifier), \"%s/notifier/%s\", ServerBin,\n\t         scheme);\n        if (access(notifier, X_OK))\n\t{\n          send_ipp_status(con, IPP_NOT_POSSIBLE,\n\t                  _(\"notify-recipient-uri URI \\\"%s\\\" uses unknown \"\n\t\t\t    \"scheme.\"), recipient);\n\t  ippAddInteger(con->response, IPP_TAG_SUBSCRIPTION, IPP_TAG_ENUM,\n\t                \"notify-status-code\", IPP_URI_SCHEME);\n\t  return;\n\t}\n\n        if (!strcmp(scheme, \"rss\") && !check_rss_recipient(recipient))\n\t{\n          send_ipp_status(con, IPP_NOT_POSSIBLE,\n\t                  _(\"notify-recipient-uri URI \\\"%s\\\" is already used.\"),\n\t\t\t  recipient);\n\t  ippAddInteger(con->response, IPP_TAG_SUBSCRIPTION, IPP_TAG_ENUM,\n\t                \"notify-status-code\", IPP_ATTRIBUTES);\n\t  return;\n\t}\n      }\n      else if (!strcmp(attr->name, \"notify-pull-method\") &&\n               attr->value_tag == IPP_TAG_KEYWORD)\n      {\n        pullmethod = attr->values[0].string.text;\n\n        if (strcmp(pullmethod, \"ippget\"))\n\t{\n          send_ipp_status(con, IPP_NOT_POSSIBLE,\n\t                  _(\"Bad notify-pull-method \\\"%s\\\".\"), pullmethod);\n\t  ippAddInteger(con->response, IPP_TAG_SUBSCRIPTION, IPP_TAG_ENUM,\n\t                \"notify-status-code\", IPP_ATTRIBUTES);\n\t  return;\n\t}\n      }\n      else if (!strcmp(attr->name, \"notify-charset\") &&\n               attr->value_tag == IPP_TAG_CHARSET &&\n\t       strcmp(attr->values[0].string.text, \"us-ascii\") &&\n\t       strcmp(attr->values[0].string.text, \"utf-8\"))\n      {\n        send_ipp_status(con, IPP_CHARSET,\n\t                _(\"Character set \\\"%s\\\" not supported.\"),\n\t\t\tattr->values[0].string.text);\n\treturn;\n      }\n      else if (!strcmp(attr->name, \"notify-natural-language\") &&\n               (attr->value_tag != IPP_TAG_LANGUAGE ||\n\t        strcmp(attr->values[0].string.text, DefaultLanguage)))\n      {\n        send_ipp_status(con, IPP_CHARSET,\n\t                _(\"Language \\\"%s\\\" not supported.\"),\n\t\t\tattr->values[0].string.text);\n\treturn;\n      }\n      else if (!strcmp(attr->name, \"notify-user-data\") &&\n               attr->value_tag == IPP_TAG_STRING)\n      {\n        if (attr->num_values > 1 || attr->values[0].unknown.length > 63)\n\t{\n          send_ipp_status(con, IPP_REQUEST_VALUE,\n\t                  _(\"The notify-user-data value is too large \"\n\t\t\t    \"(%d > 63 octets).\"),\n\t\t\t  attr->values[0].unknown.length);\n\t  return;\n\t}\n\n        user_data = attr;\n      }\n      else if (!strcmp(attr->name, \"notify-events\") &&\n               attr->value_tag == IPP_TAG_KEYWORD)\n        notify_events = attr;\n      else if (!strcmp(attr->name, \"notify-lease-duration\") &&\n               attr->value_tag == IPP_TAG_INTEGER)\n        lease = attr->values[0].integer;\n      else if (!strcmp(attr->name, \"notify-time-interval\") &&\n               attr->value_tag == IPP_TAG_INTEGER)\n        interval = attr->values[0].integer;\n      else if (!strcmp(attr->name, \"notify-job-id\") &&\n               attr->value_tag == IPP_TAG_INTEGER)\n        jobid = attr->values[0].integer;\n\n      attr = attr->next;\n    }\n\n    if (notify_events)\n    {\n      for (i = 0; i < notify_events->num_values; i ++)\n\tmask |= cupsdEventValue(notify_events->values[i].string.text);\n    }\n\n    if (recipient)\n      cupsdLogMessage(CUPSD_LOG_DEBUG, \"recipient=\\\"%s\\\"\", recipient);\n    if (pullmethod)\n      cupsdLogMessage(CUPSD_LOG_DEBUG, \"pullmethod=\\\"%s\\\"\", pullmethod);\n    cupsdLogMessage(CUPSD_LOG_DEBUG, \"notify-lease-duration=%d\", lease);\n    cupsdLogMessage(CUPSD_LOG_DEBUG, \"notify-time-interval=%d\", interval);\n\n    if (!recipient && !pullmethod)\n      break;\n\n    if (mask == CUPSD_EVENT_NONE)\n    {\n      if (jobid)\n        mask = CUPSD_EVENT_JOB_COMPLETED;\n      else if (printer)\n        mask = CUPSD_EVENT_PRINTER_STATE_CHANGED;\n      else\n      {\n        send_ipp_status(con, IPP_BAD_REQUEST,\n\t                _(\"notify-events not specified.\"));\n\treturn;\n      }\n    }\n\n    if (MaxLeaseDuration && (lease == 0 || lease > MaxLeaseDuration))\n    {\n      cupsdLogMessage(CUPSD_LOG_INFO,\n                      \"create_subscriptions: Limiting notify-lease-duration to \"\n\t\t      \"%d seconds.\",\n\t\t      MaxLeaseDuration);\n      lease = MaxLeaseDuration;\n    }\n\n    if (jobid)\n    {\n      if ((job = cupsdFindJob(jobid)) == NULL)\n      {\n\tsend_ipp_status(con, IPP_NOT_FOUND, _(\"Job #%d does not exist.\"),\n\t                jobid);\n\treturn;\n      }\n    }\n    else\n      job = NULL;\n\n    if ((sub = cupsdAddSubscription(mask, printer, job, recipient, 0)) == NULL)\n    {\n      send_ipp_status(con, IPP_TOO_MANY_SUBSCRIPTIONS,\n\t\t      _(\"There are too many subscriptions.\"));\n      return;\n    }\n\n    if (job)\n      cupsdLogMessage(CUPSD_LOG_DEBUG, \"Added subscription #%d for job %d.\",\n\t\t      sub->id, job->id);\n    else if (printer)\n      cupsdLogMessage(CUPSD_LOG_DEBUG,\n                      \"Added subscription #%d for printer \\\"%s\\\".\",\n\t\t      sub->id, printer->name);\n    else\n      cupsdLogMessage(CUPSD_LOG_DEBUG, \"Added subscription #%d for server.\",\n\t\t      sub->id);\n\n    sub->interval = interval;\n    sub->lease    = lease;\n    sub->expire   = lease ? time(NULL) + lease : 0;\n\n    cupsdSetString(&sub->owner, username);\n\n    if (user_data)\n    {\n      sub->user_data_len = user_data->values[0].unknown.length;\n      memcpy(sub->user_data, user_data->values[0].unknown.data,\n             (size_t)sub->user_data_len);\n    }\n\n    ippAddSeparator(con->response);\n    ippAddInteger(con->response, IPP_TAG_SUBSCRIPTION, IPP_TAG_INTEGER,\n                  \"notify-subscription-id\", sub->id);\n\n    con->response->request.status.status_code = IPP_OK;\n\n    if (attr)\n      attr = attr->next;\n  }\n\n  cupsdMarkDirty(CUPSD_DIRTY_SUBSCRIPTIONS);\n}\n\n\n/*\n * 'delete_printer()' - Remove a printer or class from the system.\n */\n\nstatic void\ndelete_printer(cupsd_client_t  *con,\t/* I - Client connection */\n               ipp_attribute_t *uri)\t/* I - URI of printer or class */\n{\n  http_status_t\tstatus;\t\t\t/* Policy status */\n  cups_ptype_t\tdtype;\t\t\t/* Destination type (printer/class) */\n  cupsd_printer_t *printer;\t\t/* Printer/class */\n  char\t\tfilename[1024];\t\t/* Script/PPD filename */\n  int\t\ttemporary;\t\t/* Temporary queue? */\n\n\n  cupsdLogMessage(CUPSD_LOG_DEBUG2, \"delete_printer(%p[%d], %s)\", con,\n                  con->number, uri->values[0].string.text);\n\n /*\n  * Do we have a valid URI?\n  */\n\n  if (!cupsdValidateDest(uri->values[0].string.text, &dtype, &printer))\n  {\n   /*\n    * Bad URI...\n    */\n\n    send_ipp_status(con, IPP_NOT_FOUND,\n                    _(\"The printer or class does not exist.\"));\n    return;\n  }\n\n /*\n  * Check policy...\n  */\n\n  if ((status = cupsdCheckPolicy(DefaultPolicyPtr, con, NULL)) != HTTP_OK)\n  {\n    send_http_error(con, status, NULL);\n    return;\n  }\n\n /*\n  * Remove old jobs...\n  */\n\n  cupsdCancelJobs(printer->name, NULL, 1);\n\n /*\n  * Remove old subscriptions and send a \"deleted printer\" event...\n  */\n\n  cupsdAddEvent(CUPSD_EVENT_PRINTER_DELETED, printer, NULL,\n                \"%s \\\"%s\\\" deleted by \\\"%s\\\".\",\n\t\t(dtype & CUPS_PRINTER_CLASS) ? \"Class\" : \"Printer\",\n\t\tprinter->name, get_username(con));\n\n  cupsdExpireSubscriptions(printer, NULL);\n\n /*\n  * Remove any old PPD or script files...\n  */\n\n  snprintf(filename, sizeof(filename), \"%s/ppd/%s.ppd\", ServerRoot,\n           printer->name);\n  unlink(filename);\n  snprintf(filename, sizeof(filename), \"%s/ppd/%s.ppd.O\", ServerRoot,\n           printer->name);\n  unlink(filename);\n\n  snprintf(filename, sizeof(filename), \"%s/%s.png\", CacheDir, printer->name);\n  unlink(filename);\n\n  snprintf(filename, sizeof(filename), \"%s/%s.data\", CacheDir, printer->name);\n  unlink(filename);\n\n /*\n  * Unregister color profiles...\n  */\n\n  cupsdUnregisterColor(printer);\n\n  temporary = printer->temporary;\n\n  if (dtype & CUPS_PRINTER_CLASS)\n  {\n    cupsdLogMessage(CUPSD_LOG_INFO, \"Class \\\"%s\\\" deleted by \\\"%s\\\".\",\n                    printer->name, get_username(con));\n\n    cupsdDeletePrinter(printer, 0);\n    if (!temporary)\n      cupsdMarkDirty(CUPSD_DIRTY_CLASSES);\n  }\n  else\n  {\n    cupsdLogMessage(CUPSD_LOG_INFO, \"Printer \\\"%s\\\" deleted by \\\"%s\\\".\",\n                    printer->name, get_username(con));\n\n    if (cupsdDeletePrinter(printer, 0) && !temporary)\n      cupsdMarkDirty(CUPSD_DIRTY_CLASSES);\n\n    if (!temporary)\n      cupsdMarkDirty(CUPSD_DIRTY_PRINTERS);\n  }\n\n  if (!temporary)\n    cupsdMarkDirty(CUPSD_DIRTY_PRINTCAP);\n\n /*\n  * Return with no errors...\n  */\n\n  con->response->request.status.status_code = IPP_OK;\n}\n\n\n/*\n * 'get_default()' - Get the default destination.\n */\n\nstatic void\nget_default(cupsd_client_t *con)\t/* I - Client connection */\n{\n  http_status_t\tstatus;\t\t\t/* Policy status */\n  cups_array_t\t*ra;\t\t\t/* Requested attributes array */\n\n\n  cupsdLogMessage(CUPSD_LOG_DEBUG2, \"get_default(%p[%d])\", con, con->number);\n\n /*\n  * Check policy...\n  */\n\n  if ((status = cupsdCheckPolicy(DefaultPolicyPtr, con, NULL)) != HTTP_OK)\n  {\n    send_http_error(con, status, NULL);\n    return;\n  }\n\n  if (DefaultPrinter)\n  {\n    ra = create_requested_array(con->request);\n\n    copy_printer_attrs(con, DefaultPrinter, ra);\n\n    cupsArrayDelete(ra);\n\n    con->response->request.status.status_code = IPP_OK;\n  }\n  else\n    send_ipp_status(con, IPP_NOT_FOUND, _(\"No default printer.\"));\n}\n\n\n/*\n * 'get_devices()' - Get the list of available devices on the local system.\n */\n\nstatic void\nget_devices(cupsd_client_t *con)\t/* I - Client connection */\n{\n  http_status_t\t\tstatus;\t\t/* Policy status */\n  ipp_attribute_t\t*limit,\t\t/* limit attribute */\n\t\t\t*timeout,\t/* timeout attribute */\n\t\t\t*requested,\t/* requested-attributes attribute */\n\t\t\t*exclude,\t/* exclude-schemes attribute */\n\t\t\t*include;\t/* include-schemes attribute */\n  char\t\t\tcommand[1024],\t/* cups-deviced command */\n\t\t\toptions[2048],\t/* Options to pass to command */\n\t\t\trequested_str[256],\n\t\t\t\t\t/* String for requested attributes */\n\t\t\texclude_str[512],\n\t\t\t\t\t/* String for excluded schemes */\n\t\t\tinclude_str[512];\n\t\t\t\t\t/* String for included schemes */\n\n\n  cupsdLogMessage(CUPSD_LOG_DEBUG2, \"get_devices(%p[%d])\", con, con->number);\n\n /*\n  * Check policy...\n  */\n\n  if ((status = cupsdCheckPolicy(DefaultPolicyPtr, con, NULL)) != HTTP_OK)\n  {\n    send_http_error(con, status, NULL);\n    return;\n  }\n\n /*\n  * Run cups-deviced command with the given options...\n  */\n\n  limit     = ippFindAttribute(con->request, \"limit\", IPP_TAG_INTEGER);\n  timeout   = ippFindAttribute(con->request, \"timeout\", IPP_TAG_INTEGER);\n  requested = ippFindAttribute(con->request, \"requested-attributes\",\n                               IPP_TAG_KEYWORD);\n  exclude   = ippFindAttribute(con->request, \"exclude-schemes\", IPP_TAG_NAME);\n  include   = ippFindAttribute(con->request, \"include-schemes\", IPP_TAG_NAME);\n\n  if (requested)\n    url_encode_attr(requested, requested_str, sizeof(requested_str));\n  else\n    strlcpy(requested_str, \"requested-attributes=all\", sizeof(requested_str));\n\n  if (exclude)\n    url_encode_attr(exclude, exclude_str, sizeof(exclude_str));\n  else\n    exclude_str[0] = '\\0';\n\n  if (include)\n    url_encode_attr(include, include_str, sizeof(include_str));\n  else\n    include_str[0] = '\\0';\n\n  snprintf(command, sizeof(command), \"%s/daemon/cups-deviced\", ServerBin);\n  snprintf(options, sizeof(options),\n           \"%d+%d+%d+%d+%s%s%s%s%s\",\n           con->request->request.op.request_id,\n           limit ? limit->values[0].integer : 0,\n\t   timeout ? timeout->values[0].integer : 15,\n\t   (int)User,\n\t   requested_str,\n\t   exclude_str[0] ? \"%20\" : \"\", exclude_str,\n\t   include_str[0] ? \"%20\" : \"\", include_str);\n\n  if (cupsdSendCommand(con, command, options, 1))\n  {\n   /*\n    * Command started successfully, don't send an IPP response here...\n    */\n\n    ippDelete(con->response);\n    con->response = NULL;\n  }\n  else\n  {\n   /*\n    * Command failed, return \"internal error\" so the user knows something\n    * went wrong...\n    */\n\n    send_ipp_status(con, IPP_INTERNAL_ERROR,\n                    _(\"cups-deviced failed to execute.\"));\n  }\n}\n\n\n/*\n * 'get_document()' - Get a copy of a job file.\n */\n\nstatic void\nget_document(cupsd_client_t  *con,\t/* I - Client connection */\n             ipp_attribute_t *uri)\t/* I - Job URI */\n{\n  http_status_t\tstatus;\t\t\t/* Policy status */\n  ipp_attribute_t *attr;\t\t/* Current attribute */\n  int\t\tjobid;\t\t\t/* Job ID */\n  int\t\tdocnum;\t\t\t/* Document number */\n  cupsd_job_t\t*job;\t\t\t/* Current job */\n  char\t\tscheme[HTTP_MAX_URI],\t/* Method portion of URI */\n\t\tusername[HTTP_MAX_URI],\t/* Username portion of URI */\n\t\thost[HTTP_MAX_URI],\t/* Host portion of URI */\n\t\tresource[HTTP_MAX_URI];\t/* Resource portion of URI */\n  int\t\tport;\t\t\t/* Port portion of URI */\n  char\t\tfilename[1024],\t\t/* Filename for document */\n\t\tformat[1024];\t\t/* Format for document */\n\n\n  cupsdLogMessage(CUPSD_LOG_DEBUG2, \"get_document(%p[%d], %s)\", con,\n                  con->number, uri->values[0].string.text);\n\n /*\n  * See if we have a job URI or a printer URI...\n  */\n\n  if (!strcmp(uri->name, \"printer-uri\"))\n  {\n   /*\n    * Got a printer URI; see if we also have a job-id attribute...\n    */\n\n    if ((attr = ippFindAttribute(con->request, \"job-id\",\n                                 IPP_TAG_INTEGER)) == NULL)\n    {\n      send_ipp_status(con, IPP_BAD_REQUEST,\n                      _(\"Got a printer-uri attribute but no job-id.\"));\n      return;\n    }\n\n    jobid = attr->values[0].integer;\n  }\n  else\n  {\n   /*\n    * Got a job URI; parse it to get the job ID...\n    */\n\n    httpSeparateURI(HTTP_URI_CODING_ALL, uri->values[0].string.text, scheme,\n                    sizeof(scheme), username, sizeof(username), host,\n\t\t    sizeof(host), &port, resource, sizeof(resource));\n\n    if (strncmp(resource, \"/jobs/\", 6))\n    {\n     /*\n      * Not a valid URI!\n      */\n\n      send_ipp_status(con, IPP_BAD_REQUEST, _(\"Bad job-uri \\\"%s\\\".\"),\n                      uri->values[0].string.text);\n      return;\n    }\n\n    jobid = atoi(resource + 6);\n  }\n\n /*\n  * See if the job exists...\n  */\n\n  if ((job = cupsdFindJob(jobid)) == NULL)\n  {\n   /*\n    * Nope - return a \"not found\" error...\n    */\n\n    send_ipp_status(con, IPP_NOT_FOUND, _(\"Job #%d does not exist.\"), jobid);\n    return;\n  }\n\n /*\n  * Check policy...\n  */\n\n  if ((status = cupsdCheckPolicy(DefaultPolicyPtr, con,\n                                 job->username)) != HTTP_OK)\n  {\n    send_http_error(con, status, NULL);\n    return;\n  }\n\n /*\n  * Get the document number...\n  */\n\n  if ((attr = ippFindAttribute(con->request, \"document-number\",\n                               IPP_TAG_INTEGER)) == NULL)\n  {\n    send_ipp_status(con, IPP_BAD_REQUEST,\n                    _(\"Missing document-number attribute.\"));\n    return;\n  }\n\n  if ((docnum = attr->values[0].integer) < 1 || docnum > job->num_files ||\n      attr->num_values > 1)\n  {\n    send_ipp_status(con, IPP_NOT_FOUND,\n                    _(\"Document #%d does not exist in job #%d.\"), docnum,\n\t\t    jobid);\n    return;\n  }\n\n  snprintf(filename, sizeof(filename), \"%s/d%05d-%03d\", RequestRoot, jobid,\n           docnum);\n  if ((con->file = open(filename, O_RDONLY)) == -1)\n  {\n    cupsdLogMessage(CUPSD_LOG_ERROR,\n                    \"Unable to open document %d in job %d - %s\", docnum, jobid,\n\t\t    strerror(errno));\n    send_ipp_status(con, IPP_NOT_FOUND,\n                    _(\"Unable to open document #%d in job #%d.\"), docnum,\n\t\t    jobid);\n    return;\n  }\n\n  fcntl(con->file, F_SETFD, fcntl(con->file, F_GETFD) | FD_CLOEXEC);\n\n  cupsdLoadJob(job);\n\n  snprintf(format, sizeof(format), \"%s/%s\", job->filetypes[docnum - 1]->super,\n           job->filetypes[docnum - 1]->type);\n\n  ippAddString(con->response, IPP_TAG_JOB, IPP_TAG_MIMETYPE, \"document-format\",\n               NULL, format);\n  ippAddInteger(con->response, IPP_TAG_JOB, IPP_TAG_INTEGER, \"document-number\",\n                docnum);\n  if ((attr = ippFindAttribute(job->attrs, \"document-name\",\n                               IPP_TAG_NAME)) != NULL)\n    ippAddString(con->response, IPP_TAG_JOB, IPP_TAG_NAME, \"document-name\",\n                 NULL, attr->values[0].string.text);\n}\n\n\n/*\n * 'get_job_attrs()' - Get job attributes.\n */\n\nstatic void\nget_job_attrs(cupsd_client_t  *con,\t/* I - Client connection */\n\t      ipp_attribute_t *uri)\t/* I - Job URI */\n{\n  http_status_t\tstatus;\t\t\t/* Policy status */\n  ipp_attribute_t *attr;\t\t/* Current attribute */\n  int\t\tjobid;\t\t\t/* Job ID */\n  cupsd_job_t\t*job;\t\t\t/* Current job */\n  cupsd_printer_t *printer;\t\t/* Current printer */\n  cupsd_policy_t *policy;\t\t/* Current security policy */\n  char\t\tscheme[HTTP_MAX_URI],\t/* Scheme portion of URI */\n\t\tusername[HTTP_MAX_URI],\t/* Username portion of URI */\n\t\thost[HTTP_MAX_URI],\t/* Host portion of URI */\n\t\tresource[HTTP_MAX_URI];\t/* Resource portion of URI */\n  int\t\tport;\t\t\t/* Port portion of URI */\n  cups_array_t\t*ra,\t\t\t/* Requested attributes array */\n\t\t*exclude;\t\t/* Private attributes array */\n\n\n  cupsdLogMessage(CUPSD_LOG_DEBUG2, \"get_job_attrs(%p[%d], %s)\", con,\n                  con->number, uri->values[0].string.text);\n\n /*\n  * See if we have a job URI or a printer URI...\n  */\n\n  if (!strcmp(uri->name, \"printer-uri\"))\n  {\n   /*\n    * Got a printer URI; see if we also have a job-id attribute...\n    */\n\n    if ((attr = ippFindAttribute(con->request, \"job-id\",\n                                 IPP_TAG_INTEGER)) == NULL)\n    {\n      send_ipp_status(con, IPP_BAD_REQUEST,\n                      _(\"Got a printer-uri attribute but no job-id.\"));\n      return;\n    }\n\n    jobid = attr->values[0].integer;\n  }\n  else\n  {\n   /*\n    * Got a job URI; parse it to get the job ID...\n    */\n\n    httpSeparateURI(HTTP_URI_CODING_ALL, uri->values[0].string.text, scheme,\n                    sizeof(scheme), username, sizeof(username), host,\n\t\t    sizeof(host), &port, resource, sizeof(resource));\n\n    if (strncmp(resource, \"/jobs/\", 6))\n    {\n     /*\n      * Not a valid URI!\n      */\n\n      send_ipp_status(con, IPP_BAD_REQUEST, _(\"Bad job-uri \\\"%s\\\".\"),\n                      uri->values[0].string.text);\n      return;\n    }\n\n    jobid = atoi(resource + 6);\n  }\n\n /*\n  * See if the job exists...\n  */\n\n  if ((job = cupsdFindJob(jobid)) == NULL)\n  {\n   /*\n    * Nope - return a \"not found\" error...\n    */\n\n    send_ipp_status(con, IPP_NOT_FOUND, _(\"Job #%d does not exist.\"), jobid);\n    return;\n  }\n\n /*\n  * Check policy...\n  */\n\n  if ((printer = job->printer) == NULL)\n    printer = cupsdFindDest(job->dest);\n\n  if (printer)\n    policy = printer->op_policy_ptr;\n  else\n    policy = DefaultPolicyPtr;\n\n  if ((status = cupsdCheckPolicy(policy, con, job->username)) != HTTP_OK)\n  {\n    send_http_error(con, status, NULL);\n    return;\n  }\n\n  exclude = cupsdGetPrivateAttrs(policy, con, printer, job->username);\n\n /*\n  * Copy attributes...\n  */\n\n  cupsdLoadJob(job);\n\n  ra = create_requested_array(con->request);\n  copy_job_attrs(con, job, ra, exclude);\n  cupsArrayDelete(ra);\n\n  con->response->request.status.status_code = IPP_OK;\n}\n\n\n/*\n * 'get_jobs()' - Get a list of jobs for the specified printer.\n */\n\nstatic void\nget_jobs(cupsd_client_t  *con,\t\t/* I - Client connection */\n\t ipp_attribute_t *uri)\t\t/* I - Printer URI */\n{\n  http_status_t\tstatus;\t\t\t/* Policy status */\n  ipp_attribute_t *attr;\t\t/* Current attribute */\n  const char\t*dest;\t\t\t/* Destination */\n  cups_ptype_t\tdtype;\t\t\t/* Destination type (printer/class) */\n  cups_ptype_t\tdmask;\t\t\t/* Destination type mask */\n  char\t\tscheme[HTTP_MAX_URI],\t/* Scheme portion of URI */\n\t\tusername[HTTP_MAX_URI],\t/* Username portion of URI */\n\t\thost[HTTP_MAX_URI],\t/* Host portion of URI */\n\t\tresource[HTTP_MAX_URI];\t/* Resource portion of URI */\n  int\t\tport;\t\t\t/* Port portion of URI */\n  int\t\tjob_comparison;\t\t/* Job comparison */\n  ipp_jstate_t\tjob_state;\t\t/* job-state value */\n  int\t\tfirst_job_id = 1,\t/* First job ID */\n\t\tfirst_index = 1,\t/* First index */\n\t\tlimit = 0,\t\t/* Maximum number of jobs to return */\n\t\tcount,\t\t\t/* Number of jobs that match */\n\t\tneed_load_job = 0;\t/* Do we need to load the job? */\n  const char\t*job_attr;\t\t/* Job attribute requested */\n  ipp_attribute_t *job_ids;\t\t/* job-ids attribute */\n  cupsd_job_t\t*job;\t\t\t/* Current job pointer */\n  cupsd_printer_t *printer;\t\t/* Printer */\n  cups_array_t\t*list;\t\t\t/* Which job list... */\n  int\t\tdelete_list = 0;\t/* Delete the list afterwards? */\n  cups_array_t\t*ra,\t\t\t/* Requested attributes array */\n\t\t*exclude;\t\t/* Private attributes array */\n  cupsd_policy_t *policy;\t\t/* Current policy */\n\n\n  cupsdLogMessage(CUPSD_LOG_DEBUG2, \"get_jobs(%p[%d], %s)\", con, con->number,\n                  uri->values[0].string.text);\n\n /*\n  * Is the destination valid?\n  */\n\n  if (strcmp(uri->name, \"printer-uri\"))\n  {\n    send_ipp_status(con, IPP_BAD_REQUEST, _(\"No printer-uri in request.\"));\n    return;\n  }\n\n  httpSeparateURI(HTTP_URI_CODING_ALL, uri->values[0].string.text, scheme,\n                  sizeof(scheme), username, sizeof(username), host,\n\t\t  sizeof(host), &port, resource, sizeof(resource));\n\n  if (!strcmp(resource, \"/\") || !strcmp(resource, \"/jobs\"))\n  {\n    dest    = NULL;\n    dtype   = (cups_ptype_t)0;\n    dmask   = (cups_ptype_t)0;\n    printer = NULL;\n  }\n  else if (!strncmp(resource, \"/printers\", 9) && strlen(resource) <= 10)\n  {\n    dest    = NULL;\n    dtype   = (cups_ptype_t)0;\n    dmask   = CUPS_PRINTER_CLASS;\n    printer = NULL;\n  }\n  else if (!strncmp(resource, \"/classes\", 8) && strlen(resource) <= 9)\n  {\n    dest    = NULL;\n    dtype   = CUPS_PRINTER_CLASS;\n    dmask   = CUPS_PRINTER_CLASS;\n    printer = NULL;\n  }\n  else if ((dest = cupsdValidateDest(uri->values[0].string.text, &dtype,\n                                     &printer)) == NULL)\n  {\n   /*\n    * Bad URI...\n    */\n\n    send_ipp_status(con, IPP_NOT_FOUND,\n                    _(\"The printer or class does not exist.\"));\n    return;\n  }\n  else\n  {\n    dtype &= CUPS_PRINTER_CLASS;\n    dmask = CUPS_PRINTER_CLASS;\n  }\n\n /*\n  * Check policy...\n  */\n\n  if (printer)\n    policy = printer->op_policy_ptr;\n  else\n    policy = DefaultPolicyPtr;\n\n  if ((status = cupsdCheckPolicy(policy, con, NULL)) != HTTP_OK)\n  {\n    send_http_error(con, status, NULL);\n    return;\n  }\n\n  job_ids = ippFindAttribute(con->request, \"job-ids\", IPP_TAG_INTEGER);\n\n /*\n  * See if the \"which-jobs\" attribute have been specified...\n  */\n\n  if ((attr = ippFindAttribute(con->request, \"which-jobs\",\n                               IPP_TAG_KEYWORD)) != NULL && job_ids)\n  {\n    send_ipp_status(con, IPP_CONFLICT,\n                    _(\"The %s attribute cannot be provided with job-ids.\"),\n                    \"which-jobs\");\n    return;\n  }\n  else if (!attr || !strcmp(attr->values[0].string.text, \"not-completed\"))\n  {\n    job_comparison = -1;\n    job_state      = IPP_JOB_STOPPED;\n    list           = ActiveJobs;\n  }\n  else if (!strcmp(attr->values[0].string.text, \"completed\"))\n  {\n    job_comparison = 1;\n    job_state      = IPP_JOB_CANCELED;\n    list           = cupsdGetCompletedJobs(printer);\n    delete_list    = 1;\n  }\n  else if (!strcmp(attr->values[0].string.text, \"aborted\"))\n  {\n    job_comparison = 0;\n    job_state      = IPP_JOB_ABORTED;\n    list           = cupsdGetCompletedJobs(printer);\n    delete_list    = 1;\n  }\n  else if (!strcmp(attr->values[0].string.text, \"all\"))\n  {\n    job_comparison = 1;\n    job_state      = IPP_JOB_PENDING;\n    list           = Jobs;\n  }\n  else if (!strcmp(attr->values[0].string.text, \"canceled\"))\n  {\n    job_comparison = 0;\n    job_state      = IPP_JOB_CANCELED;\n    list           = cupsdGetCompletedJobs(printer);\n    delete_list    = 1;\n  }\n  else if (!strcmp(attr->values[0].string.text, \"pending\"))\n  {\n    job_comparison = 0;\n    job_state      = IPP_JOB_PENDING;\n    list           = ActiveJobs;\n  }\n  else if (!strcmp(attr->values[0].string.text, \"pending-held\"))\n  {\n    job_comparison = 0;\n    job_state      = IPP_JOB_HELD;\n    list           = ActiveJobs;\n  }\n  else if (!strcmp(attr->values[0].string.text, \"processing\"))\n  {\n    job_comparison = 0;\n    job_state      = IPP_JOB_PROCESSING;\n    list           = PrintingJobs;\n  }\n  else if (!strcmp(attr->values[0].string.text, \"processing-stopped\"))\n  {\n    job_comparison = 0;\n    job_state      = IPP_JOB_STOPPED;\n    list           = ActiveJobs;\n  }\n  else\n  {\n    send_ipp_status(con, IPP_ATTRIBUTES,\n                    _(\"The which-jobs value \\\"%s\\\" is not supported.\"),\n\t\t    attr->values[0].string.text);\n    ippAddString(con->response, IPP_TAG_UNSUPPORTED_GROUP, IPP_TAG_KEYWORD,\n                 \"which-jobs\", NULL, attr->values[0].string.text);\n    return;\n  }\n\n /*\n  * See if they want to limit the number of jobs reported...\n  */\n\n  if ((attr = ippFindAttribute(con->request, \"limit\", IPP_TAG_INTEGER)) != NULL)\n  {\n    if (job_ids)\n    {\n      send_ipp_status(con, IPP_CONFLICT,\n\t\t      _(\"The %s attribute cannot be provided with job-ids.\"),\n\t\t      \"limit\");\n      return;\n    }\n\n    limit = attr->values[0].integer;\n  }\n\n  if ((attr = ippFindAttribute(con->request, \"first-index\", IPP_TAG_INTEGER)) != NULL)\n  {\n    if (job_ids)\n    {\n      send_ipp_status(con, IPP_CONFLICT,\n\t\t      _(\"The %s attribute cannot be provided with job-ids.\"),\n\t\t      \"first-index\");\n      return;\n    }\n\n    first_index = attr->values[0].integer;\n  }\n  else if ((attr = ippFindAttribute(con->request, \"first-job-id\", IPP_TAG_INTEGER)) != NULL)\n  {\n    if (job_ids)\n    {\n      send_ipp_status(con, IPP_CONFLICT,\n\t\t      _(\"The %s attribute cannot be provided with job-ids.\"),\n\t\t      \"first-job-id\");\n      return;\n    }\n\n    first_job_id = attr->values[0].integer;\n  }\n\n /*\n  * See if we only want to see jobs for a specific user...\n  */\n\n  if ((attr = ippFindAttribute(con->request, \"my-jobs\", IPP_TAG_BOOLEAN)) != NULL && job_ids)\n  {\n    send_ipp_status(con, IPP_CONFLICT,\n                    _(\"The %s attribute cannot be provided with job-ids.\"),\n                    \"my-jobs\");\n    return;\n  }\n  else if (attr && attr->values[0].boolean)\n    strlcpy(username, get_username(con), sizeof(username));\n  else\n    username[0] = '\\0';\n\n  ra = create_requested_array(con->request);\n  for (job_attr = (char *)cupsArrayFirst(ra); job_attr; job_attr = (char *)cupsArrayNext(ra))\n    if (strcmp(job_attr, \"job-id\") &&\n\tstrcmp(job_attr, \"job-k-octets\") &&\n\tstrcmp(job_attr, \"job-media-progress\") &&\n\tstrcmp(job_attr, \"job-more-info\") &&\n\tstrcmp(job_attr, \"job-name\") &&\n\tstrcmp(job_attr, \"job-originating-user-name\") &&\n\tstrcmp(job_attr, \"job-preserved\") &&\n\tstrcmp(job_attr, \"job-printer-up-time\") &&\n        strcmp(job_attr, \"job-printer-uri\") &&\n\tstrcmp(job_attr, \"job-state\") &&\n\tstrcmp(job_attr, \"job-state-reasons\") &&\n\tstrcmp(job_attr, \"job-uri\") &&\n\tstrcmp(job_attr, \"time-at-completed\") &&\n\tstrcmp(job_attr, \"time-at-creation\") &&\n\tstrcmp(job_attr, \"number-of-documents\"))\n    {\n      need_load_job = 1;\n      break;\n    }\n\n  if (need_load_job && (limit == 0 || limit > 500) && (list == Jobs || delete_list))\n  {\n   /*\n    * Limit expensive Get-Jobs for job history to 500 jobs...\n    */\n\n    ippAddInteger(con->response, IPP_TAG_OPERATION, IPP_TAG_INTEGER, \"limit\", 500);\n\n    if (limit)\n      ippAddInteger(con->response, IPP_TAG_UNSUPPORTED_GROUP, IPP_TAG_INTEGER, \"limit\", limit);\n\n    limit = 500;\n\n    cupsdLogClient(con, CUPSD_LOG_INFO, \"Limiting Get-Jobs response to %d jobs.\", limit);\n  }\n\n /*\n  * OK, build a list of jobs for this printer...\n  */\n\n  if (job_ids)\n  {\n    int\ti;\t\t\t\t/* Looping var */\n\n    for (i = 0; i < job_ids->num_values; i ++)\n    {\n      if (!cupsdFindJob(job_ids->values[i].integer))\n        break;\n    }\n\n    if (i < job_ids->num_values)\n    {\n      send_ipp_status(con, IPP_NOT_FOUND, _(\"Job #%d does not exist.\"),\n                      job_ids->values[i].integer);\n      return;\n    }\n\n    for (i = 0; i < job_ids->num_values; i ++)\n    {\n      job = cupsdFindJob(job_ids->values[i].integer);\n\n      if (need_load_job && !job->attrs)\n      {\n        cupsdLoadJob(job);\n\n\tif (!job->attrs)\n\t{\n\t  cupsdLogMessage(CUPSD_LOG_DEBUG2, \"get_jobs: No attributes for job %d\", job->id);\n\t  continue;\n\t}\n      }\n\n      if (i > 0)\n\tippAddSeparator(con->response);\n\n      exclude = cupsdGetPrivateAttrs(job->printer ?\n                                         job->printer->op_policy_ptr :\n\t\t\t\t\t policy, con, job->printer,\n\t\t\t\t\t job->username);\n\n      copy_job_attrs(con, job, ra, exclude);\n    }\n  }\n  else\n  {\n    if (first_index > 1)\n      job = (cupsd_job_t *)cupsArrayIndex(list, first_index - 1);\n    else\n      job = (cupsd_job_t *)cupsArrayFirst(list);\n\n    for (count = 0; (limit <= 0 || count < limit) && job; job = (cupsd_job_t *)cupsArrayNext(list))\n    {\n     /*\n      * Filter out jobs that don't match...\n      */\n\n      cupsdLogMessage(CUPSD_LOG_DEBUG2,\n\t\t      \"get_jobs: job->id=%d, dest=\\\"%s\\\", username=\\\"%s\\\", \"\n\t\t      \"state_value=%d, attrs=%p\", job->id, job->dest,\n\t\t      job->username, job->state_value, job->attrs);\n\n      if (!job->dest || !job->username)\n\tcupsdLoadJob(job);\n\n      if (!job->dest || !job->username)\n\tcontinue;\n\n      if ((dest && strcmp(job->dest, dest)) &&\n\t  (!job->printer || !dest || strcmp(job->printer->name, dest)))\n\tcontinue;\n      if ((job->dtype & dmask) != dtype &&\n\t  (!job->printer || (job->printer->type & dmask) != dtype))\n\tcontinue;\n\n      if ((job_comparison < 0 && job->state_value > job_state) ||\n          (job_comparison == 0 && job->state_value != job_state) ||\n          (job_comparison > 0 && job->state_value < job_state))\n\tcontinue;\n\n      if (job->id < first_job_id)\n\tcontinue;\n\n      if (need_load_job && !job->attrs)\n      {\n        cupsdLoadJob(job);\n\n\tif (!job->attrs)\n\t{\n\t  cupsdLogMessage(CUPSD_LOG_DEBUG2, \"get_jobs: No attributes for job %d\", job->id);\n\t  continue;\n\t}\n      }\n\n      if (username[0] && _cups_strcasecmp(username, job->username))\n\tcontinue;\n\n      if (count > 0)\n\tippAddSeparator(con->response);\n\n      count ++;\n\n      exclude = cupsdGetPrivateAttrs(job->printer ?\n                                         job->printer->op_policy_ptr :\n\t\t\t\t\t policy, con, job->printer,\n\t\t\t\t\t job->username);\n\n      copy_job_attrs(con, job, ra, exclude);\n    }\n\n    cupsdLogMessage(CUPSD_LOG_DEBUG2, \"get_jobs: count=%d\", count);\n  }\n\n  cupsArrayDelete(ra);\n\n  if (delete_list)\n    cupsArrayDelete(list);\n\n  con->response->request.status.status_code = IPP_OK;\n}\n\n\n/*\n * 'get_notifications()' - Get events for a subscription.\n */\n\nstatic void\nget_notifications(cupsd_client_t *con)\t/* I - Client connection */\n{\n  int\t\t\ti, j;\t\t/* Looping vars */\n  http_status_t\t\tstatus;\t\t/* Policy status */\n  cupsd_subscription_t\t*sub;\t\t/* Subscription */\n  ipp_attribute_t\t*ids,\t\t/* notify-subscription-ids */\n\t\t\t*sequences;\t/* notify-sequence-numbers */\n  int\t\t\tmin_seq;\t/* Minimum sequence number */\n  int\t\t\tinterval;\t/* Poll interval */\n\n\n  cupsdLogMessage(CUPSD_LOG_DEBUG2, \"get_notifications(con=%p[%d])\",\n                  con, con->number);\n\n /*\n  * Get subscription attributes...\n  */\n\n  ids       = ippFindAttribute(con->request, \"notify-subscription-ids\",\n                               IPP_TAG_INTEGER);\n  sequences = ippFindAttribute(con->request, \"notify-sequence-numbers\",\n                               IPP_TAG_INTEGER);\n\n  if (!ids)\n  {\n    send_ipp_status(con, IPP_BAD_REQUEST,\n                    _(\"Missing notify-subscription-ids attribute.\"));\n    return;\n  }\n\n /*\n  * Are the subscription IDs valid?\n  */\n\n  for (i = 0, interval = 60; i < ids->num_values; i ++)\n  {\n    if ((sub = cupsdFindSubscription(ids->values[i].integer)) == NULL)\n    {\n     /*\n      * Bad subscription ID...\n      */\n\n      send_ipp_status(con, IPP_NOT_FOUND, _(\"Subscription #%d does not exist.\"),\n\t\t      ids->values[i].integer);\n      return;\n    }\n\n   /*\n    * Check policy...\n    */\n\n    if ((status = cupsdCheckPolicy(sub->dest ? sub->dest->op_policy_ptr :\n                                               DefaultPolicyPtr,\n                                   con, sub->owner)) != HTTP_OK)\n    {\n      send_http_error(con, status, sub->dest);\n      return;\n    }\n\n   /*\n    * Check the subscription type and update the interval accordingly.\n    */\n\n    if (sub->job && sub->job->state_value == IPP_JOB_PROCESSING &&\n        interval > 10)\n      interval = 10;\n    else if (sub->job && sub->job->state_value >= IPP_JOB_STOPPED)\n      interval = 0;\n    else if (sub->dest && sub->dest->state == IPP_PRINTER_PROCESSING &&\n             interval > 30)\n      interval = 30;\n  }\n\n /*\n  * Tell the client to poll again in N seconds...\n  */\n\n  if (interval > 0)\n    ippAddInteger(con->response, IPP_TAG_OPERATION, IPP_TAG_INTEGER,\n                  \"notify-get-interval\", interval);\n\n  ippAddInteger(con->response, IPP_TAG_OPERATION, IPP_TAG_INTEGER,\n                \"printer-up-time\", time(NULL));\n\n /*\n  * Copy the subscription event attributes to the response.\n  */\n\n  con->response->request.status.status_code =\n      interval ? IPP_OK : IPP_OK_EVENTS_COMPLETE;\n\n  for (i = 0; i < ids->num_values; i ++)\n  {\n   /*\n    * Get the subscription and sequence number...\n    */\n\n    sub = cupsdFindSubscription(ids->values[i].integer);\n\n    if (sequences && i < sequences->num_values)\n      min_seq = sequences->values[i].integer;\n    else\n      min_seq = 1;\n\n   /*\n    * If we don't have any new events, nothing to do here...\n    */\n\n    if (min_seq > (sub->first_event_id + cupsArrayCount(sub->events)))\n      continue;\n\n   /*\n    * Otherwise copy all of the new events...\n    */\n\n    if (sub->first_event_id > min_seq)\n      j = 0;\n    else\n      j = min_seq - sub->first_event_id;\n\n    for (; j < cupsArrayCount(sub->events); j ++)\n    {\n      ippAddSeparator(con->response);\n\n      copy_attrs(con->response,\n                 ((cupsd_event_t *)cupsArrayIndex(sub->events, j))->attrs, NULL,\n        \t IPP_TAG_EVENT_NOTIFICATION, 0, NULL);\n    }\n  }\n}\n\n\n/*\n * 'get_ppd()' - Get a named PPD from the local system.\n */\n\nstatic void\nget_ppd(cupsd_client_t  *con,\t\t/* I - Client connection */\n        ipp_attribute_t *uri)\t\t/* I - Printer URI or PPD name */\n{\n  http_status_t\t\tstatus;\t\t/* Policy status */\n  cupsd_printer_t\t*dest;\t\t/* Destination */\n  cups_ptype_t\t\tdtype;\t\t/* Destination type */\n\n\n  cupsdLogMessage(CUPSD_LOG_DEBUG2, \"get_ppd(%p[%d], %p[%s=%s])\", con,\n                  con->number, uri, uri->name, uri->values[0].string.text);\n\n  if (!strcmp(ippGetName(uri), \"ppd-name\"))\n  {\n   /*\n    * Return a PPD file from cups-driverd...\n    */\n\n    const char *ppd_name = ippGetString(uri, 0, NULL);\n\t\t\t\t\t/* ppd-name value */\n    char\tcommand[1024],\t\t/* cups-driverd command */\n\t\toptions[1024],\t\t/* Options to pass to command */\n\t\toppd_name[1024];\t/* Escaped ppd-name */\n\n   /*\n    * Check policy...\n    */\n\n    if ((status = cupsdCheckPolicy(DefaultPolicyPtr, con, NULL)) != HTTP_OK)\n    {\n      send_http_error(con, status, NULL);\n      return;\n    }\n\n   /*\n    * Check ppd-name value...\n    */\n\n    if (strstr(ppd_name, \"../\"))\n    {\n      send_ipp_status(con, IPP_STATUS_ERROR_ATTRIBUTES_OR_VALUES, _(\"Invalid ppd-name value.\"));\n      return;\n    }\n\n   /*\n    * Run cups-driverd command with the given options...\n    */\n\n    snprintf(command, sizeof(command), \"%s/daemon/cups-driverd\", ServerBin);\n    url_encode_string(ppd_name, oppd_name, sizeof(oppd_name));\n    snprintf(options, sizeof(options), \"get+%d+%s\", ippGetRequestId(con->request), oppd_name);\n\n    if (cupsdSendCommand(con, command, options, 0))\n    {\n     /*\n      * Command started successfully, don't send an IPP response here...\n      */\n\n      ippDelete(con->response);\n      con->response = NULL;\n    }\n    else\n    {\n     /*\n      * Command failed, return \"internal error\" so the user knows something\n      * went wrong...\n      */\n\n      send_ipp_status(con, IPP_INTERNAL_ERROR, _(\"cups-driverd failed to execute.\"));\n    }\n  }\n  else if (!strcmp(ippGetName(uri), \"printer-uri\") && cupsdValidateDest(ippGetString(uri, 0, NULL), &dtype, &dest))\n  {\n    int \ti;\t\t\t/* Looping var */\n    char\tfilename[1024];\t\t/* PPD filename */\n\n   /*\n    * Check policy...\n    */\n\n    if ((status = cupsdCheckPolicy(dest->op_policy_ptr, con, NULL)) != HTTP_OK)\n    {\n      send_http_error(con, status, dest);\n      return;\n    }\n\n   /*\n    * See if we need the PPD for a class or remote printer...\n    */\n\n    snprintf(filename, sizeof(filename), \"%s/ppd/%s.ppd\", ServerRoot, dest->name);\n\n    if ((dtype & CUPS_PRINTER_REMOTE) && access(filename, 0))\n    {\n      send_ipp_status(con, IPP_STATUS_CUPS_SEE_OTHER, _(\"See remote printer.\"));\n      ippAddString(con->response, IPP_TAG_OPERATION, IPP_TAG_URI, \"printer-uri\", NULL, dest->uri);\n      return;\n    }\n    else if (dtype & CUPS_PRINTER_CLASS)\n    {\n      for (i = 0; i < dest->num_printers; i ++)\n        if (!(dest->printers[i]->type & CUPS_PRINTER_CLASS))\n\t{\n\t  snprintf(filename, sizeof(filename), \"%s/ppd/%s.ppd\", ServerRoot, dest->printers[i]->name);\n\n          if (!access(filename, 0))\n\t    break;\n        }\n\n      if (i < dest->num_printers)\n        dest = dest->printers[i];\n      else\n      {\n\tsend_ipp_status(con, IPP_STATUS_CUPS_SEE_OTHER, _(\"See remote printer.\"));\n        ippAddString(con->response, IPP_TAG_OPERATION, IPP_TAG_URI, \"printer-uri\", NULL, dest->printers[0]->uri);\n        return;\n      }\n    }\n\n   /*\n    * Found the printer with the PPD file, now see if there is one...\n    */\n\n    if ((con->file = open(filename, O_RDONLY)) < 0)\n    {\n      send_ipp_status(con, IPP_STATUS_ERROR_NOT_FOUND, _(\"The PPD file \\\"%s\\\" could not be opened: %s\"), ippGetString(uri, 0, NULL), strerror(errno));\n      return;\n    }\n\n    fcntl(con->file, F_SETFD, fcntl(con->file, F_GETFD) | FD_CLOEXEC);\n\n    con->pipe_pid = 0;\n\n    ippSetStatusCode(con->response, IPP_STATUS_OK);\n  }\n  else\n    send_ipp_status(con, IPP_STATUS_ERROR_NOT_FOUND, _(\"The PPD file \\\"%s\\\" could not be found.\"), ippGetString(uri, 0, NULL));\n}\n\n\n/*\n * 'get_ppds()' - Get the list of PPD files on the local system.\n */\n\nstatic void\nget_ppds(cupsd_client_t *con)\t\t/* I - Client connection */\n{\n  http_status_t\t\tstatus;\t\t/* Policy status */\n  ipp_attribute_t\t*limit,\t\t/* Limit attribute */\n\t\t\t*device,\t/* ppd-device-id attribute */\n\t\t\t*language,\t/* ppd-natural-language attribute */\n\t\t\t*make,\t\t/* ppd-make attribute */\n\t\t\t*model,\t\t/* ppd-make-and-model attribute */\n\t\t\t*model_number,\t/* ppd-model-number attribute */\n\t\t\t*product,\t/* ppd-product attribute */\n\t\t\t*psversion,\t/* ppd-psverion attribute */\n\t\t\t*type,\t\t/* ppd-type attribute */\n\t\t\t*requested,\t/* requested-attributes attribute */\n\t\t\t*exclude,\t/* exclude-schemes attribute */\n\t\t\t*include;\t/* include-schemes attribute */\n  char\t\t\tcommand[1024],\t/* cups-driverd command */\n\t\t\toptions[4096],\t/* Options to pass to command */\n\t\t\tdevice_str[256],/* Escaped ppd-device-id string */\n\t\t\tlanguage_str[256],\n\t\t\t\t\t/* Escaped ppd-natural-language */\n\t\t\tmake_str[256],\t/* Escaped ppd-make string */\n\t\t\tmodel_str[256],\t/* Escaped ppd-make-and-model string */\n\t\t\tmodel_number_str[256],\n\t\t\t\t\t/* ppd-model-number string */\n\t\t\tproduct_str[256],\n\t\t\t\t\t/* Escaped ppd-product string */\n\t\t\tpsversion_str[256],\n\t\t\t\t\t/* Escaped ppd-psversion string */\n\t\t\ttype_str[256],\t/* Escaped ppd-type string */\n\t\t\trequested_str[256],\n\t\t\t\t\t/* String for requested attributes */\n\t\t\texclude_str[512],\n\t\t\t\t\t/* String for excluded schemes */\n\t\t\tinclude_str[512];\n\t\t\t\t\t/* String for included schemes */\n\n\n  cupsdLogMessage(CUPSD_LOG_DEBUG2, \"get_ppds(%p[%d])\", con, con->number);\n\n /*\n  * Check policy...\n  */\n\n  if ((status = cupsdCheckPolicy(DefaultPolicyPtr, con, NULL)) != HTTP_OK)\n  {\n    send_http_error(con, status, NULL);\n    return;\n  }\n\n /*\n  * Run cups-driverd command with the given options...\n  */\n\n  limit        = ippFindAttribute(con->request, \"limit\", IPP_TAG_INTEGER);\n  device       = ippFindAttribute(con->request, \"ppd-device-id\", IPP_TAG_TEXT);\n  language     = ippFindAttribute(con->request, \"ppd-natural-language\",\n                                  IPP_TAG_LANGUAGE);\n  make         = ippFindAttribute(con->request, \"ppd-make\", IPP_TAG_TEXT);\n  model        = ippFindAttribute(con->request, \"ppd-make-and-model\",\n                                  IPP_TAG_TEXT);\n  model_number = ippFindAttribute(con->request, \"ppd-model-number\",\n                                  IPP_TAG_INTEGER);\n  product      = ippFindAttribute(con->request, \"ppd-product\", IPP_TAG_TEXT);\n  psversion    = ippFindAttribute(con->request, \"ppd-psversion\", IPP_TAG_TEXT);\n  type         = ippFindAttribute(con->request, \"ppd-type\", IPP_TAG_KEYWORD);\n  requested    = ippFindAttribute(con->request, \"requested-attributes\",\n                                  IPP_TAG_KEYWORD);\n  exclude      = ippFindAttribute(con->request, \"exclude-schemes\",\n                                  IPP_TAG_NAME);\n  include      = ippFindAttribute(con->request, \"include-schemes\",\n                                  IPP_TAG_NAME);\n\n  if (requested)\n    url_encode_attr(requested, requested_str, sizeof(requested_str));\n  else\n    strlcpy(requested_str, \"requested-attributes=all\", sizeof(requested_str));\n\n  if (device)\n    url_encode_attr(device, device_str, sizeof(device_str));\n  else\n    device_str[0] = '\\0';\n\n  if (language)\n    url_encode_attr(language, language_str, sizeof(language_str));\n  else\n    language_str[0] = '\\0';\n\n  if (make)\n    url_encode_attr(make, make_str, sizeof(make_str));\n  else\n    make_str[0] = '\\0';\n\n  if (model)\n    url_encode_attr(model, model_str, sizeof(model_str));\n  else\n    model_str[0] = '\\0';\n\n  if (model_number)\n    snprintf(model_number_str, sizeof(model_number_str), \"ppd-model-number=%d\",\n             model_number->values[0].integer);\n  else\n    model_number_str[0] = '\\0';\n\n  if (product)\n    url_encode_attr(product, product_str, sizeof(product_str));\n  else\n    product_str[0] = '\\0';\n\n  if (psversion)\n    url_encode_attr(psversion, psversion_str, sizeof(psversion_str));\n  else\n    psversion_str[0] = '\\0';\n\n  if (type)\n    url_encode_attr(type, type_str, sizeof(type_str));\n  else\n    type_str[0] = '\\0';\n\n  if (exclude)\n    url_encode_attr(exclude, exclude_str, sizeof(exclude_str));\n  else\n    exclude_str[0] = '\\0';\n\n  if (include)\n    url_encode_attr(include, include_str, sizeof(include_str));\n  else\n    include_str[0] = '\\0';\n\n  snprintf(command, sizeof(command), \"%s/daemon/cups-driverd\", ServerBin);\n  snprintf(options, sizeof(options),\n           \"list+%d+%d+%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s\",\n           con->request->request.op.request_id,\n           limit ? limit->values[0].integer : 0,\n\t   requested_str,\n\t   device ? \"%20\" : \"\", device_str,\n\t   language ? \"%20\" : \"\", language_str,\n\t   make ? \"%20\" : \"\", make_str,\n\t   model ? \"%20\" : \"\", model_str,\n\t   model_number ? \"%20\" : \"\", model_number_str,\n\t   product ? \"%20\" : \"\", product_str,\n\t   psversion ? \"%20\" : \"\", psversion_str,\n\t   type ? \"%20\" : \"\", type_str,\n\t   exclude_str[0] ? \"%20\" : \"\", exclude_str,\n\t   include_str[0] ? \"%20\" : \"\", include_str);\n\n  if (cupsdSendCommand(con, command, options, 0))\n  {\n   /*\n    * Command started successfully, don't send an IPP response here...\n    */\n\n    ippDelete(con->response);\n    con->response = NULL;\n  }\n  else\n  {\n   /*\n    * Command failed, return \"internal error\" so the user knows something\n    * went wrong...\n    */\n\n    send_ipp_status(con, IPP_INTERNAL_ERROR,\n                    _(\"cups-driverd failed to execute.\"));\n  }\n}\n\n\n/*\n * 'get_printer_attrs()' - Get printer attributes.\n */\n\nstatic void\nget_printer_attrs(cupsd_client_t  *con,\t/* I - Client connection */\n\t\t  ipp_attribute_t *uri)\t/* I - Printer URI */\n{\n  http_status_t\t\tstatus;\t\t/* Policy status */\n  cups_ptype_t\t\tdtype;\t\t/* Destination type (printer/class) */\n  cupsd_printer_t\t*printer;\t/* Printer/class */\n  cups_array_t\t\t*ra;\t\t/* Requested attributes array */\n\n\n  cupsdLogMessage(CUPSD_LOG_DEBUG2, \"get_printer_attrs(%p[%d], %s)\", con,\n                  con->number, uri->values[0].string.text);\n\n /*\n  * Is the destination valid?\n  */\n\n  if (!cupsdValidateDest(uri->values[0].string.text, &dtype, &printer))\n  {\n   /*\n    * Bad URI...\n    */\n\n    send_ipp_status(con, IPP_NOT_FOUND,\n                    _(\"The printer or class does not exist.\"));\n    return;\n  }\n\n /*\n  * Check policy...\n  */\n\n  if ((status = cupsdCheckPolicy(printer->op_policy_ptr, con, NULL)) != HTTP_OK)\n  {\n    send_http_error(con, status, printer);\n    return;\n  }\n\n /*\n  * Send the attributes...\n  */\n\n  ra = create_requested_array(con->request);\n\n  copy_printer_attrs(con, printer, ra);\n\n  cupsArrayDelete(ra);\n\n  con->response->request.status.status_code = IPP_OK;\n}\n\n\n/*\n * 'get_printer_supported()' - Get printer supported values.\n */\n\nstatic void\nget_printer_supported(\n    cupsd_client_t  *con,\t\t/* I - Client connection */\n    ipp_attribute_t *uri)\t\t/* I - Printer URI */\n{\n  http_status_t\t\tstatus;\t\t/* Policy status */\n  cups_ptype_t\t\tdtype;\t\t/* Destination type (printer/class) */\n  cupsd_printer_t\t*printer;\t/* Printer/class */\n\n\n  cupsdLogMessage(CUPSD_LOG_DEBUG2, \"get_printer_supported(%p[%d], %s)\", con,\n                  con->number, uri->values[0].string.text);\n\n /*\n  * Is the destination valid?\n  */\n\n  if (!cupsdValidateDest(uri->values[0].string.text, &dtype, &printer))\n  {\n   /*\n    * Bad URI...\n    */\n\n    send_ipp_status(con, IPP_NOT_FOUND,\n                    _(\"The printer or class does not exist.\"));\n    return;\n  }\n\n /*\n  * Check policy...\n  */\n\n  if ((status = cupsdCheckPolicy(printer->op_policy_ptr, con, NULL)) != HTTP_OK)\n  {\n    send_http_error(con, status, printer);\n    return;\n  }\n\n /*\n  * Return a list of attributes that can be set via Set-Printer-Attributes.\n  */\n\n  ippAddInteger(con->response, IPP_TAG_PRINTER, IPP_TAG_ADMINDEFINE,\n                \"printer-geo-location\", 0);\n  ippAddInteger(con->response, IPP_TAG_PRINTER, IPP_TAG_ADMINDEFINE,\n                \"printer-info\", 0);\n  ippAddInteger(con->response, IPP_TAG_PRINTER, IPP_TAG_ADMINDEFINE,\n                \"printer-location\", 0);\n  ippAddInteger(con->response, IPP_TAG_PRINTER, IPP_TAG_ADMINDEFINE,\n                \"printer-organization\", 0);\n  ippAddInteger(con->response, IPP_TAG_PRINTER, IPP_TAG_ADMINDEFINE,\n                \"printer-organizational-unit\", 0);\n\n  con->response->request.status.status_code = IPP_OK;\n}\n\n\n/*\n * 'get_printers()' - Get a list of printers or classes.\n */\n\nstatic void\nget_printers(cupsd_client_t *con,\t/* I - Client connection */\n             int            type)\t/* I - 0 or CUPS_PRINTER_CLASS */\n{\n  http_status_t\tstatus;\t\t\t/* Policy status */\n  ipp_attribute_t *attr;\t\t/* Current attribute */\n  int\t\tlimit;\t\t\t/* Max number of printers to return */\n  int\t\tcount;\t\t\t/* Number of printers that match */\n  cupsd_printer_t *printer;\t\t/* Current printer pointer */\n  cups_ptype_t\tprinter_type,\t\t/* printer-type attribute */\n\t\tprinter_mask;\t\t/* printer-type-mask attribute */\n  char\t\t*location;\t\t/* Location string */\n  const char\t*username;\t\t/* Current user */\n  char\t\t*first_printer_name;\t/* first-printer-name attribute */\n  cups_array_t\t*ra;\t\t\t/* Requested attributes array */\n  int\t\tlocal;\t\t\t/* Local connection? */\n\n\n  cupsdLogMessage(CUPSD_LOG_DEBUG2, \"get_printers(%p[%d], %x)\", con,\n                  con->number, type);\n\n /*\n  * Check policy...\n  */\n\n  if ((status = cupsdCheckPolicy(DefaultPolicyPtr, con, NULL)) != HTTP_OK)\n  {\n    send_http_error(con, status, NULL);\n    return;\n  }\n\n /*\n  * Check for printers...\n  */\n\n  if (!Printers || !cupsArrayCount(Printers))\n  {\n    send_ipp_status(con, IPP_NOT_FOUND, _(\"No destinations added.\"));\n    return;\n  }\n\n /*\n  * See if they want to limit the number of printers reported...\n  */\n\n  if ((attr = ippFindAttribute(con->request, \"limit\",\n                               IPP_TAG_INTEGER)) != NULL)\n    limit = attr->values[0].integer;\n  else\n    limit = 10000000;\n\n  if ((attr = ippFindAttribute(con->request, \"first-printer-name\",\n                               IPP_TAG_NAME)) != NULL)\n    first_printer_name = attr->values[0].string.text;\n  else\n    first_printer_name = NULL;\n\n /*\n  * Support filtering...\n  */\n\n  if ((attr = ippFindAttribute(con->request, \"printer-type\",\n                               IPP_TAG_ENUM)) != NULL)\n    printer_type = (cups_ptype_t)attr->values[0].integer;\n  else\n    printer_type = (cups_ptype_t)0;\n\n  if ((attr = ippFindAttribute(con->request, \"printer-type-mask\",\n                               IPP_TAG_ENUM)) != NULL)\n    printer_mask = (cups_ptype_t)attr->values[0].integer;\n  else\n    printer_mask = (cups_ptype_t)0;\n\n  local = httpAddrLocalhost(&(con->clientaddr));\n\n  if ((attr = ippFindAttribute(con->request, \"printer-location\",\n                               IPP_TAG_TEXT)) != NULL)\n    location = attr->values[0].string.text;\n  else\n    location = NULL;\n\n  if (con->username[0])\n    username = con->username;\n  else if ((attr = ippFindAttribute(con->request, \"requesting-user-name\",\n                                    IPP_TAG_NAME)) != NULL)\n    username = attr->values[0].string.text;\n  else\n    username = NULL;\n\n  ra = create_requested_array(con->request);\n\n /*\n  * OK, build a list of printers for this printer...\n  */\n\n  if (first_printer_name)\n  {\n    if ((printer = cupsdFindDest(first_printer_name)) == NULL)\n      printer = (cupsd_printer_t *)cupsArrayFirst(Printers);\n  }\n  else\n    printer = (cupsd_printer_t *)cupsArrayFirst(Printers);\n\n  for (count = 0;\n       count < limit && printer;\n       printer = (cupsd_printer_t *)cupsArrayNext(Printers))\n  {\n    if (!local && !printer->shared)\n      continue;\n\n    if ((!type || (printer->type & CUPS_PRINTER_CLASS) == type) &&\n        (printer->type & printer_mask) == printer_type &&\n\t(!location ||\n\t (printer->location && !_cups_strcasecmp(printer->location, location))))\n    {\n     /*\n      * If a username is specified, see if it is allowed or denied\n      * access...\n      */\n\n      if (cupsArrayCount(printer->users) && username &&\n\t  !user_allowed(printer, username))\n        continue;\n\n     /*\n      * Add the group separator as needed...\n      */\n\n      if (count > 0)\n        ippAddSeparator(con->response);\n\n      count ++;\n\n     /*\n      * Send the attributes...\n      */\n\n      copy_printer_attrs(con, printer, ra);\n    }\n  }\n\n  cupsArrayDelete(ra);\n\n  con->response->request.status.status_code = IPP_OK;\n}\n\n\n/*\n * 'get_subscription_attrs()' - Get subscription attributes.\n */\n\nstatic void\nget_subscription_attrs(\n    cupsd_client_t *con,\t\t/* I - Client connection */\n    int            sub_id)\t\t/* I - Subscription ID */\n{\n  http_status_t\t\tstatus;\t\t/* Policy status */\n  cupsd_subscription_t\t*sub;\t\t/* Subscription */\n  cupsd_policy_t\t*policy;\t/* Current security policy */\n  cups_array_t\t\t*ra,\t\t/* Requested attributes array */\n\t\t\t*exclude;\t/* Private attributes array */\n\n\n  cupsdLogMessage(CUPSD_LOG_DEBUG2,\n                  \"get_subscription_attrs(con=%p[%d], sub_id=%d)\",\n                  con, con->number, sub_id);\n\n /*\n  * Expire subscriptions as needed...\n  */\n\n  cupsdExpireSubscriptions(NULL, NULL);\n\n /*\n  * Is the subscription ID valid?\n  */\n\n  if ((sub = cupsdFindSubscription(sub_id)) == NULL)\n  {\n   /*\n    * Bad subscription ID...\n    */\n\n    send_ipp_status(con, IPP_NOT_FOUND, _(\"Subscription #%d does not exist.\"),\n                    sub_id);\n    return;\n  }\n\n /*\n  * Check policy...\n  */\n\n  if (sub->dest)\n    policy = sub->dest->op_policy_ptr;\n  else\n    policy = DefaultPolicyPtr;\n\n  if ((status = cupsdCheckPolicy(policy, con, sub->owner)) != HTTP_OK)\n  {\n    send_http_error(con, status, sub->dest);\n    return;\n  }\n\n  exclude = cupsdGetPrivateAttrs(policy, con, sub->dest, sub->owner);\n\n /*\n  * Copy the subscription attributes to the response using the\n  * requested-attributes attribute that may be provided by the client.\n  */\n\n  ra = create_requested_array(con->request);\n\n  copy_subscription_attrs(con, sub, ra, exclude);\n\n  cupsArrayDelete(ra);\n\n  con->response->request.status.status_code = IPP_OK;\n}\n\n\n/*\n * 'get_subscriptions()' - Get subscriptions.\n */\n\nstatic void\nget_subscriptions(cupsd_client_t  *con,\t/* I - Client connection */\n                  ipp_attribute_t *uri)\t/* I - Printer/job URI */\n{\n  http_status_t\t\tstatus;\t\t/* Policy status */\n  int\t\t\tcount;\t\t/* Number of subscriptions */\n  int\t\t\tlimit;\t\t/* Limit */\n  cupsd_subscription_t\t*sub;\t\t/* Subscription */\n  cups_array_t\t\t*ra;\t\t/* Requested attributes array */\n  ipp_attribute_t\t*attr;\t\t/* Attribute */\n  cups_ptype_t\t\tdtype;\t\t/* Destination type (printer/class) */\n  char\t\t\tscheme[HTTP_MAX_URI],\n\t\t\t\t\t/* Scheme portion of URI */\n\t\t\tusername[HTTP_MAX_URI],\n\t\t\t\t\t/* Username portion of URI */\n\t\t\thost[HTTP_MAX_URI],\n\t\t\t\t\t/* Host portion of URI */\n\t\t\tresource[HTTP_MAX_URI];\n\t\t\t\t\t/* Resource portion of URI */\n  int\t\t\tport;\t\t/* Port portion of URI */\n  cupsd_job_t\t\t*job;\t\t/* Job pointer */\n  cupsd_printer_t\t*printer;\t/* Printer */\n  cupsd_policy_t\t*policy;\t/* Policy */\n  cups_array_t\t\t*exclude;\t/* Private attributes array */\n\n\n  cupsdLogMessage(CUPSD_LOG_DEBUG2,\n                  \"get_subscriptions(con=%p[%d], uri=%s)\",\n                  con, con->number, uri->values[0].string.text);\n\n /*\n  * Is the destination valid?\n  */\n\n  httpSeparateURI(HTTP_URI_CODING_ALL, uri->values[0].string.text, scheme,\n                  sizeof(scheme), username, sizeof(username), host,\n\t\t  sizeof(host), &port, resource, sizeof(resource));\n\n  if (!strcmp(resource, \"/\") ||\n      (!strncmp(resource, \"/jobs\", 5) && strlen(resource) <= 6) ||\n      (!strncmp(resource, \"/printers\", 9) && strlen(resource) <= 10) ||\n      (!strncmp(resource, \"/classes\", 8) && strlen(resource) <= 9))\n  {\n    printer = NULL;\n    job     = NULL;\n  }\n  else if (!strncmp(resource, \"/jobs/\", 6) && resource[6])\n  {\n    printer = NULL;\n    job     = cupsdFindJob(atoi(resource + 6));\n\n    if (!job)\n    {\n      send_ipp_status(con, IPP_NOT_FOUND, _(\"Job #%d does not exist.\"),\n                      atoi(resource + 6));\n      return;\n    }\n  }\n  else if (!cupsdValidateDest(uri->values[0].string.text, &dtype, &printer))\n  {\n   /*\n    * Bad URI...\n    */\n\n    send_ipp_status(con, IPP_NOT_FOUND,\n                    _(\"The printer or class does not exist.\"));\n    return;\n  }\n  else if ((attr = ippFindAttribute(con->request, \"notify-job-id\",\n                                    IPP_TAG_INTEGER)) != NULL)\n  {\n    job = cupsdFindJob(attr->values[0].integer);\n\n    if (!job)\n    {\n      send_ipp_status(con, IPP_NOT_FOUND, _(\"Job #%d does not exist.\"),\n                      attr->values[0].integer);\n      return;\n    }\n  }\n  else\n    job = NULL;\n\n /*\n  * Check policy...\n  */\n\n  if (printer)\n    policy = printer->op_policy_ptr;\n  else\n    policy = DefaultPolicyPtr;\n\n  if ((status = cupsdCheckPolicy(policy, con, NULL)) != HTTP_OK)\n  {\n    send_http_error(con, status, printer);\n    return;\n  }\n\n /*\n  * Expire subscriptions as needed...\n  */\n\n  cupsdExpireSubscriptions(NULL, NULL);\n\n /*\n  * Copy the subscription attributes to the response using the\n  * requested-attributes attribute that may be provided by the client.\n  */\n\n  ra = create_requested_array(con->request);\n\n  if ((attr = ippFindAttribute(con->request, \"limit\",\n                               IPP_TAG_INTEGER)) != NULL)\n    limit = attr->values[0].integer;\n  else\n    limit = 0;\n\n /*\n  * See if we only want to see subscriptions for a specific user...\n  */\n\n  if ((attr = ippFindAttribute(con->request, \"my-subscriptions\",\n                               IPP_TAG_BOOLEAN)) != NULL &&\n      attr->values[0].boolean)\n    strlcpy(username, get_username(con), sizeof(username));\n  else\n    username[0] = '\\0';\n\n  for (sub = (cupsd_subscription_t *)cupsArrayFirst(Subscriptions), count = 0;\n       sub;\n       sub = (cupsd_subscription_t *)cupsArrayNext(Subscriptions))\n    if ((!printer || sub->dest == printer) && (!job || sub->job == job) &&\n        (!username[0] || !_cups_strcasecmp(username, sub->owner)))\n    {\n      ippAddSeparator(con->response);\n\n      exclude = cupsdGetPrivateAttrs(sub->dest ? sub->dest->op_policy_ptr :\n\t\t\t\t\t\t policy, con, sub->dest,\n\t\t\t\t\t\t sub->owner);\n\n      copy_subscription_attrs(con, sub, ra, exclude);\n\n      count ++;\n      if (limit && count >= limit)\n        break;\n    }\n\n  cupsArrayDelete(ra);\n\n  if (count)\n    con->response->request.status.status_code = IPP_OK;\n  else\n    send_ipp_status(con, IPP_NOT_FOUND, _(\"No subscriptions found.\"));\n}\n\n\n/*\n * 'get_username()' - Get the username associated with a request.\n */\n\nstatic const char *\t\t\t/* O - Username */\nget_username(cupsd_client_t *con)\t/* I - Connection */\n{\n  ipp_attribute_t\t*attr;\t\t/* Attribute */\n\n\n  if (con->username[0])\n    return (con->username);\n  else if ((attr = ippFindAttribute(con->request, \"requesting-user-name\",\n                                    IPP_TAG_NAME)) != NULL)\n    return (attr->values[0].string.text);\n  else\n    return (\"anonymous\");\n}\n\n\n/*\n * 'hold_job()' - Hold a print job.\n */\n\nstatic void\nhold_job(cupsd_client_t  *con,\t\t/* I - Client connection */\n         ipp_attribute_t *uri)\t\t/* I - Job or Printer URI */\n{\n  ipp_attribute_t *attr;\t\t/* Current job-hold-until */\n  const char\t*when;\t\t\t/* New value */\n  int\t\tjobid;\t\t\t/* Job ID */\n  char\t\tscheme[HTTP_MAX_URI],\t/* Method portion of URI */\n\t\tusername[HTTP_MAX_URI],\t/* Username portion of URI */\n\t\thost[HTTP_MAX_URI],\t/* Host portion of URI */\n\t\tresource[HTTP_MAX_URI];\t/* Resource portion of URI */\n  int\t\tport;\t\t\t/* Port portion of URI */\n  cupsd_job_t\t*job;\t\t\t/* Job information */\n\n\n  cupsdLogMessage(CUPSD_LOG_DEBUG2, \"hold_job(%p[%d], %s)\", con, con->number,\n                  uri->values[0].string.text);\n\n /*\n  * See if we have a job URI or a printer URI...\n  */\n\n  if (!strcmp(uri->name, \"printer-uri\"))\n  {\n   /*\n    * Got a printer URI; see if we also have a job-id attribute...\n    */\n\n    if ((attr = ippFindAttribute(con->request, \"job-id\",\n                                 IPP_TAG_INTEGER)) == NULL)\n    {\n      send_ipp_status(con, IPP_BAD_REQUEST,\n                      _(\"Got a printer-uri attribute but no job-id.\"));\n      return;\n    }\n\n    jobid = attr->values[0].integer;\n  }\n  else\n  {\n   /*\n    * Got a job URI; parse it to get the job ID...\n    */\n\n    httpSeparateURI(HTTP_URI_CODING_ALL, uri->values[0].string.text, scheme,\n                    sizeof(scheme), username, sizeof(username), host,\n\t\t    sizeof(host), &port, resource, sizeof(resource));\n\n    if (strncmp(resource, \"/jobs/\", 6))\n    {\n     /*\n      * Not a valid URI!\n      */\n\n      send_ipp_status(con, IPP_BAD_REQUEST,\n                      _(\"Bad job-uri \\\"%s\\\".\"),\n                      uri->values[0].string.text);\n      return;\n    }\n\n    jobid = atoi(resource + 6);\n  }\n\n /*\n  * See if the job exists...\n  */\n\n  if ((job = cupsdFindJob(jobid)) == NULL)\n  {\n   /*\n    * Nope - return a \"not found\" error...\n    */\n\n    send_ipp_status(con, IPP_NOT_FOUND, _(\"Job #%d does not exist.\"), jobid);\n    return;\n  }\n\n /*\n  * See if the job is owned by the requesting user...\n  */\n\n  if (!validate_user(job, con, job->username, username, sizeof(username)))\n  {\n    send_http_error(con, con->username[0] ? HTTP_FORBIDDEN : HTTP_UNAUTHORIZED,\n\t\t    cupsdFindDest(job->dest));\n    return;\n  }\n\n /*\n  * See if the job is in a state that allows holding...\n  */\n\n  if (job->state_value > IPP_JOB_STOPPED)\n  {\n   /*\n    * Return a \"not-possible\" error...\n    */\n\n    send_ipp_status(con, IPP_NOT_POSSIBLE,\n\t\t    _(\"Job #%d is finished and cannot be altered.\"),\n\t\t    job->id);\n    return;\n  }\n\n /*\n  * Hold the job and return...\n  */\n\n  if ((attr = ippFindAttribute(con->request, \"job-hold-until\",\n\t\t\t       IPP_TAG_KEYWORD)) == NULL)\n    attr = ippFindAttribute(con->request, \"job-hold-until\", IPP_TAG_NAME);\n\n  if (attr)\n  {\n    when = attr->values[0].string.text;\n\n    cupsdAddEvent(CUPSD_EVENT_JOB_CONFIG_CHANGED, cupsdFindDest(job->dest), job,\n\t\t  \"Job job-hold-until value changed by user.\");\n  }\n  else\n    when = \"indefinite\";\n\n  cupsdSetJobHoldUntil(job, when, 1);\n  cupsdSetJobState(job, IPP_JOB_HELD, CUPSD_JOB_DEFAULT, \"Job held by \\\"%s\\\".\",\n                   username);\n\n  con->response->request.status.status_code = IPP_OK;\n}\n\n\n/*\n * 'hold_new_jobs()' - Hold pending/new jobs on a printer or class.\n */\n\nstatic void\nhold_new_jobs(cupsd_client_t  *con,\t/* I - Connection */\n              ipp_attribute_t *uri)\t/* I - Printer URI */\n{\n  http_status_t\t\tstatus;\t\t/* Policy status */\n  cups_ptype_t\t\tdtype;\t\t/* Destination type (printer/class) */\n  cupsd_printer_t\t*printer;\t/* Printer data */\n\n\n  cupsdLogMessage(CUPSD_LOG_DEBUG2, \"hold_new_jobs(%p[%d], %s)\", con,\n                  con->number, uri->values[0].string.text);\n\n /*\n  * Is the destination valid?\n  */\n\n  if (!cupsdValidateDest(uri->values[0].string.text, &dtype, &printer))\n  {\n   /*\n    * Bad URI...\n    */\n\n    send_ipp_status(con, IPP_NOT_FOUND,\n                    _(\"The printer or class does not exist.\"));\n    return;\n  }\n\n /*\n  * Check policy...\n  */\n\n  if ((status = cupsdCheckPolicy(printer->op_policy_ptr, con, NULL)) != HTTP_OK)\n  {\n    send_http_error(con, status, printer);\n    return;\n  }\n\n /*\n  * Hold pending/new jobs sent to the printer...\n  */\n\n  printer->holding_new_jobs = 1;\n\n  cupsdSetPrinterReasons(printer, \"+hold-new-jobs\");\n\n  if (dtype & CUPS_PRINTER_CLASS)\n    cupsdLogMessage(CUPSD_LOG_INFO,\n                    \"Class \\\"%s\\\" now holding pending/new jobs (\\\"%s\\\").\",\n                    printer->name, get_username(con));\n  else\n    cupsdLogMessage(CUPSD_LOG_INFO,\n                    \"Printer \\\"%s\\\" now holding pending/new jobs (\\\"%s\\\").\",\n                    printer->name, get_username(con));\n\n /*\n  * Everything was ok, so return OK status...\n  */\n\n  con->response->request.status.status_code = IPP_OK;\n}\n\n\n/*\n * 'move_job()' - Move a job to a new destination.\n */\n\nstatic void\nmove_job(cupsd_client_t  *con,\t\t/* I - Client connection */\n\t ipp_attribute_t *uri)\t\t/* I - Job URI */\n{\n  http_status_t\tstatus;\t\t\t/* Policy status */\n  ipp_attribute_t *attr;\t\t/* Current attribute */\n  int\t\tjobid;\t\t\t/* Job ID */\n  cupsd_job_t\t*job;\t\t\t/* Current job */\n  const char\t*src;\t\t\t/* Source printer/class */\n  cups_ptype_t\tstype,\t\t\t/* Source type (printer or class) */\n\t\tdtype;\t\t\t/* Destination type (printer/class) */\n  char\t\tscheme[HTTP_MAX_URI],\t/* Scheme portion of URI */\n\t\tusername[HTTP_MAX_URI],\t/* Username portion of URI */\n\t\thost[HTTP_MAX_URI],\t/* Host portion of URI */\n\t\tresource[HTTP_MAX_URI];\t/* Resource portion of URI */\n  int\t\tport;\t\t\t/* Port portion of URI */\n  cupsd_printer_t *sprinter,\t\t/* Source printer */\n\t\t*dprinter;\t\t/* Destination printer */\n\n\n  cupsdLogMessage(CUPSD_LOG_DEBUG2, \"move_job(%p[%d], %s)\", con, con->number,\n                  uri->values[0].string.text);\n\n /*\n  * Get the new printer or class...\n  */\n\n  if ((attr = ippFindAttribute(con->request, \"job-printer-uri\",\n                               IPP_TAG_URI)) == NULL)\n  {\n   /*\n    * Need job-printer-uri...\n    */\n\n    send_ipp_status(con, IPP_BAD_REQUEST,\n                    _(\"job-printer-uri attribute missing.\"));\n    return;\n  }\n\n  if (!cupsdValidateDest(attr->values[0].string.text, &dtype, &dprinter))\n  {\n   /*\n    * Bad URI...\n    */\n\n    send_ipp_status(con, IPP_NOT_FOUND,\n                    _(\"The printer or class does not exist.\"));\n    return;\n  }\n\n /*\n  * See if we have a job URI or a printer URI...\n  */\n\n  httpSeparateURI(HTTP_URI_CODING_ALL, uri->values[0].string.text, scheme,\n                  sizeof(scheme), username, sizeof(username), host,\n\t\t  sizeof(host), &port, resource, sizeof(resource));\n\n  if (!strcmp(uri->name, \"printer-uri\"))\n  {\n   /*\n    * Got a printer URI; see if we also have a job-id attribute...\n    */\n\n    if ((attr = ippFindAttribute(con->request, \"job-id\",\n                                 IPP_TAG_INTEGER)) == NULL)\n    {\n     /*\n      * Move all jobs...\n      */\n\n      if ((src = cupsdValidateDest(uri->values[0].string.text, &stype,\n                                   &sprinter)) == NULL)\n      {\n       /*\n\t* Bad URI...\n\t*/\n\n\tsend_ipp_status(con, IPP_NOT_FOUND,\n                \t_(\"The printer or class does not exist.\"));\n\treturn;\n      }\n\n      job = NULL;\n    }\n    else\n    {\n     /*\n      * Otherwise, just move a single job...\n      */\n\n      if ((job = cupsdFindJob(attr->values[0].integer)) == NULL)\n      {\n       /*\n\t* Nope - return a \"not found\" error...\n\t*/\n\n\tsend_ipp_status(con, IPP_NOT_FOUND,\n                \t_(\"Job #%d does not exist.\"), attr->values[0].integer);\n\treturn;\n      }\n      else\n      {\n       /*\n        * Job found, initialize source pointers...\n\t*/\n\n\tsrc      = NULL;\n\tsprinter = NULL;\n      }\n    }\n  }\n  else\n  {\n   /*\n    * Got a job URI; parse it to get the job ID...\n    */\n\n    if (strncmp(resource, \"/jobs/\", 6))\n    {\n     /*\n      * Not a valid URI!\n      */\n\n      send_ipp_status(con, IPP_BAD_REQUEST, _(\"Bad job-uri \\\"%s\\\".\"),\n                      uri->values[0].string.text);\n      return;\n    }\n\n   /*\n    * See if the job exists...\n    */\n\n    jobid = atoi(resource + 6);\n\n    if ((job = cupsdFindJob(jobid)) == NULL)\n    {\n     /*\n      * Nope - return a \"not found\" error...\n      */\n\n      send_ipp_status(con, IPP_NOT_FOUND, _(\"Job #%d does not exist.\"), jobid);\n      return;\n    }\n    else\n    {\n     /*\n      * Job found, initialize source pointers...\n      */\n\n      src      = NULL;\n      sprinter = NULL;\n    }\n  }\n\n /*\n  * Check the policy of the destination printer...\n  */\n\n  if ((status = cupsdCheckPolicy(dprinter->op_policy_ptr, con,\n                                 job ? job->username : NULL)) != HTTP_OK)\n  {\n    send_http_error(con, status, dprinter);\n    return;\n  }\n\n /*\n  * Now move the job or jobs...\n  */\n\n  if (job)\n  {\n   /*\n    * See if the job has been completed...\n    */\n\n    if (job->state_value > IPP_JOB_STOPPED)\n    {\n     /*\n      * Return a \"not-possible\" error...\n      */\n\n      send_ipp_status(con, IPP_NOT_POSSIBLE,\n                      _(\"Job #%d is finished and cannot be altered.\"),\n\t\t      job->id);\n      return;\n    }\n\n   /*\n    * See if the job is owned by the requesting user...\n    */\n\n    if (!validate_user(job, con, job->username, username, sizeof(username)))\n    {\n      send_http_error(con, con->username[0] ? HTTP_FORBIDDEN : HTTP_UNAUTHORIZED,\n                      cupsdFindDest(job->dest));\n      return;\n    }\n\n   /*\n    * Move the job to a different printer or class...\n    */\n\n    cupsdMoveJob(job, dprinter);\n  }\n  else\n  {\n   /*\n    * Got the source printer, now look through the jobs...\n    */\n\n    for (job = (cupsd_job_t *)cupsArrayFirst(Jobs);\n         job;\n\t job = (cupsd_job_t *)cupsArrayNext(Jobs))\n    {\n     /*\n      * See if the job is pointing at the source printer or has not been\n      * completed...\n      */\n\n      if (_cups_strcasecmp(job->dest, src) ||\n          job->state_value > IPP_JOB_STOPPED)\n\tcontinue;\n\n     /*\n      * See if the job can be moved by the requesting user...\n      */\n\n      if (!validate_user(job, con, job->username, username, sizeof(username)))\n        continue;\n\n     /*\n      * Move the job to a different printer or class...\n      */\n\n      cupsdMoveJob(job, dprinter);\n    }\n  }\n\n /*\n  * Start jobs if possible...\n  */\n\n  cupsdCheckJobs();\n\n /*\n  * Return with \"everything is OK\" status...\n  */\n\n  con->response->request.status.status_code = IPP_OK;\n}\n\n\n/*\n * 'ppd_parse_line()' - Parse a PPD default line.\n */\n\nstatic int\t\t\t\t/* O - 0 on success, -1 on failure */\nppd_parse_line(const char *line,\t/* I - Line */\n               char       *option,\t/* O - Option name */\n\t       int        olen,\t\t/* I - Size of option name */\n               char       *choice,\t/* O - Choice name */\n\t       int        clen)\t\t/* I - Size of choice name */\n{\n /*\n  * Verify this is a default option line...\n  */\n\n  if (strncmp(line, \"*Default\", 8))\n    return (-1);\n\n /*\n  * Read the option name...\n  */\n\n  for (line += 8, olen --;\n       *line > ' ' && *line < 0x7f && *line != ':' && *line != '/';\n       line ++)\n    if (olen > 0)\n    {\n      *option++ = *line;\n      olen --;\n    }\n\n  *option = '\\0';\n\n /*\n  * Skip everything else up to the colon (:)...\n  */\n\n  while (*line && *line != ':')\n    line ++;\n\n  if (!*line)\n    return (-1);\n\n  line ++;\n\n /*\n  * Now grab the option choice, skipping leading whitespace...\n  */\n\n  while (isspace(*line & 255))\n    line ++;\n\n  for (clen --;\n       *line > ' ' && *line < 0x7f && *line != ':' && *line != '/';\n       line ++)\n    if (clen > 0)\n    {\n      *choice++ = *line;\n      clen --;\n    }\n\n  *choice = '\\0';\n\n /*\n  * Return with no errors...\n  */\n\n  return (0);\n}\n\n\n/*\n * 'print_job()' - Print a file to a printer or class.\n */\n\nstatic void\nprint_job(cupsd_client_t  *con,\t\t/* I - Client connection */\n\t  ipp_attribute_t *uri)\t\t/* I - Printer URI */\n{\n  ipp_attribute_t *attr;\t\t/* Current attribute */\n  ipp_attribute_t *doc_name;\t\t/* document-name attribute */\n  ipp_attribute_t *format;\t\t/* Document-format attribute */\n  const char\t*default_format;\t/* document-format-default value */\n  cupsd_job_t\t*job;\t\t\t/* New job */\n  char\t\tfilename[1024];\t\t/* Job filename */\n  mime_type_t\t*filetype;\t\t/* Type of file */\n  char\t\tsuper[MIME_MAX_SUPER],\t/* Supertype of file */\n\t\ttype[MIME_MAX_TYPE],\t/* Subtype of file */\n\t\tmimetype[MIME_MAX_SUPER + MIME_MAX_TYPE + 2];\n\t\t\t\t\t/* Textual name of mime type */\n  cupsd_printer_t *printer;\t\t/* Printer data */\n  struct stat\tfileinfo;\t\t/* File information */\n  int\t\tkbytes;\t\t\t/* Size of file */\n  int\t\tcompression;\t\t/* Document compression */\n\n\n  cupsdLogMessage(CUPSD_LOG_DEBUG2, \"print_job(%p[%d], %s)\", con, con->number,\n                  uri->values[0].string.text);\n\n /*\n  * Validate print file attributes, for now just document-format and\n  * compression (CUPS only supports \"none\" and \"gzip\")...\n  */\n\n  compression = CUPS_FILE_NONE;\n\n  if ((attr = ippFindAttribute(con->request, \"compression\",\n                               IPP_TAG_KEYWORD)) != NULL)\n  {\n    if (strcmp(attr->values[0].string.text, \"none\")\n#ifdef HAVE_LIBZ\n        && strcmp(attr->values[0].string.text, \"gzip\")\n#endif /* HAVE_LIBZ */\n      )\n    {\n      send_ipp_status(con, IPP_ATTRIBUTES,\n                      _(\"Unsupported compression \\\"%s\\\".\"),\n        \t      attr->values[0].string.text);\n      ippAddString(con->response, IPP_TAG_UNSUPPORTED_GROUP, IPP_TAG_KEYWORD,\n\t           \"compression\", NULL, attr->values[0].string.text);\n      return;\n    }\n\n#ifdef HAVE_LIBZ\n    if (!strcmp(attr->values[0].string.text, \"gzip\"))\n      compression = CUPS_FILE_GZIP;\n#endif /* HAVE_LIBZ */\n  }\n\n /*\n  * Do we have a file to print?\n  */\n\n  if (!con->filename)\n  {\n    send_ipp_status(con, IPP_BAD_REQUEST, _(\"No file in print request.\"));\n    return;\n  }\n\n /*\n  * Is the destination valid?\n  */\n\n  if (!cupsdValidateDest(uri->values[0].string.text, NULL, &printer))\n  {\n   /*\n    * Bad URI...\n    */\n\n    send_ipp_status(con, IPP_NOT_FOUND,\n                    _(\"The printer or class does not exist.\"));\n    return;\n  }\n\n /*\n  * Is it a format we support?\n  */\n\n  doc_name = ippFindAttribute(con->request, \"document-name\", IPP_TAG_NAME);\n  if (doc_name)\n    ippSetName(con->request, &doc_name, \"document-name-supplied\");\n\n  if ((format = ippFindAttribute(con->request, \"document-format\",\n                                 IPP_TAG_MIMETYPE)) != NULL)\n  {\n   /*\n    * Grab format from client...\n    */\n\n    if (sscanf(format->values[0].string.text, \"%15[^/]/%255[^;]\", super,\n               type) != 2)\n    {\n      send_ipp_status(con, IPP_BAD_REQUEST,\n                      _(\"Bad document-format \\\"%s\\\".\"),\n\t\t      format->values[0].string.text);\n      return;\n    }\n\n    ippAddString(con->request, IPP_TAG_JOB, IPP_TAG_MIMETYPE, \"document-format-supplied\", NULL, ippGetString(format, 0, NULL));\n  }\n  else if ((default_format = cupsGetOption(\"document-format\",\n                                           printer->num_options,\n\t\t\t\t\t   printer->options)) != NULL)\n  {\n   /*\n    * Use default document format...\n    */\n\n    if (sscanf(default_format, \"%15[^/]/%255[^;]\", super, type) != 2)\n    {\n      send_ipp_status(con, IPP_BAD_REQUEST,\n                      _(\"Bad document-format \\\"%s\\\".\"),\n\t\t      default_format);\n      return;\n    }\n  }\n  else\n  {\n   /*\n    * Auto-type it!\n    */\n\n    strlcpy(super, \"application\", sizeof(super));\n    strlcpy(type, \"octet-stream\", sizeof(type));\n  }\n\n  if (!strcmp(super, \"application\") && !strcmp(type, \"octet-stream\"))\n  {\n   /*\n    * Auto-type the file...\n    */\n\n    cupsdLogMessage(CUPSD_LOG_DEBUG, \"[Job ???] Auto-typing file...\");\n\n\n    filetype = mimeFileType(MimeDatabase, con->filename,\n                            doc_name ? doc_name->values[0].string.text : NULL,\n\t\t\t    &compression);\n\n    if (!filetype)\n      filetype = mimeType(MimeDatabase, super, type);\n\n    cupsdLogMessage(CUPSD_LOG_INFO, \"[Job ???] Request file type is %s/%s.\",\n\t\t    filetype->super, filetype->type);\n\n    snprintf(mimetype, sizeof(mimetype), \"%s/%s\", filetype->super, filetype->type);\n    ippAddString(con->request, IPP_TAG_JOB, IPP_TAG_MIMETYPE, \"document-format-detected\", NULL, mimetype);\n  }\n  else\n    filetype = mimeType(MimeDatabase, super, type);\n\n  if (filetype &&\n      (!format ||\n       (!strcmp(super, \"application\") && !strcmp(type, \"octet-stream\"))))\n  {\n   /*\n    * Replace the document-format attribute value with the auto-typed or\n    * default one.\n    */\n\n    snprintf(mimetype, sizeof(mimetype), \"%s/%s\", filetype->super,\n             filetype->type);\n\n    if (format)\n      ippSetString(con->request, &format, 0, mimetype);\n    else\n      ippAddString(con->request, IPP_TAG_JOB, IPP_TAG_MIMETYPE,\n\t           \"document-format\", NULL, mimetype);\n  }\n  else if (!filetype)\n  {\n    send_ipp_status(con, IPP_DOCUMENT_FORMAT,\n                    _(\"Unsupported document-format \\\"%s\\\".\"),\n\t\t    format ? format->values[0].string.text :\n\t\t\t     \"application/octet-stream\");\n    cupsdLogMessage(CUPSD_LOG_INFO,\n                    \"Hint: Do you have the raw file printing rules enabled?\");\n\n    if (format)\n      ippAddString(con->response, IPP_TAG_UNSUPPORTED_GROUP, IPP_TAG_MIMETYPE,\n                   \"document-format\", NULL, format->values[0].string.text);\n\n    return;\n  }\n\n /*\n  * Read any embedded job ticket info from PS files...\n  */\n\n  if (!_cups_strcasecmp(filetype->super, \"application\") &&\n      (!_cups_strcasecmp(filetype->type, \"postscript\") ||\n       !_cups_strcasecmp(filetype->type, \"pdf\")))\n    read_job_ticket(con);\n\n /*\n  * Create the job object...\n  */\n\n  if ((job = add_job(con, printer, filetype)) == NULL)\n    return;\n\n /*\n  * Update quota data...\n  */\n\n  if (stat(con->filename, &fileinfo))\n    kbytes = 0;\n  else\n    kbytes = (fileinfo.st_size + 1023) / 1024;\n\n  cupsdUpdateQuota(printer, job->username, 0, kbytes);\n\n  job->koctets += kbytes;\n\n  if ((attr = ippFindAttribute(job->attrs, \"job-k-octets\", IPP_TAG_INTEGER)) != NULL)\n    attr->values[0].integer += kbytes;\n\n /*\n  * Add the job file...\n  */\n\n  if (add_file(con, job, filetype, compression))\n    return;\n\n  snprintf(filename, sizeof(filename), \"%s/d%05d-%03d\", RequestRoot, job->id, job->num_files);\n  if (rename(con->filename, filename))\n  {\n    cupsdLogJob(job, CUPSD_LOG_ERROR, \"Unable to rename job document file \\\"%s\\\": %s\", filename, strerror(errno));\n\n    send_ipp_status(con, IPP_INTERNAL_ERROR, _(\"Unable to rename job document file.\"));\n    return;\n  }\n\n  cupsdClearString(&con->filename);\n\n /*\n  * See if we need to add the ending sheet...\n  */\n\n  if (cupsdTimeoutJob(job))\n    return;\n\n /*\n  * Log and save the job...\n  */\n\n  cupsdLogJob(job, CUPSD_LOG_INFO,\n\t      \"File of type %s/%s queued by \\\"%s\\\".\",\n\t      filetype->super, filetype->type, job->username);\n  cupsdLogJob(job, CUPSD_LOG_DEBUG, \"hold_until=%d\", (int)job->hold_until);\n  cupsdLogJob(job, CUPSD_LOG_INFO, \"Queued on \\\"%s\\\" by \\\"%s\\\".\",\n\t      job->dest, job->username);\n\n /*\n  * Start the job if possible...\n  */\n\n  cupsdCheckJobs();\n}\n\n\n/*\n * 'read_job_ticket()' - Read a job ticket embedded in a print file.\n *\n * This function only gets called when printing a single PDF or PostScript\n * file using the Print-Job operation.  It doesn't work for Create-Job +\n * Send-File, since the job attributes need to be set at job creation\n * time for banners to work.  The embedded job ticket stuff is here\n * primarily to allow the Windows printer driver for CUPS to pass in JCL\n * options and IPP attributes which otherwise would be lost.\n *\n * The format of a job ticket is simple:\n *\n *     %cupsJobTicket: attr1=value1 attr2=value2 ... attrN=valueN\n *\n *     %cupsJobTicket: attr1=value1\n *     %cupsJobTicket: attr2=value2\n *     ...\n *     %cupsJobTicket: attrN=valueN\n *\n * Job ticket lines must appear immediately after the first line that\n * specifies PostScript (%!PS-Adobe-3.0) or PDF (%PDF) format, and CUPS\n * stops looking for job ticket info when it finds a line that does not begin\n * with \"%cupsJobTicket:\".\n *\n * The maximum length of a job ticket line, including the prefix, is\n * 255 characters to conform with the Adobe DSC.\n *\n * Read-only attributes are rejected with a notice to the error log in\n * case a malicious user tries anything.  Since the job ticket is read\n * prior to attribute validation in print_job(), job ticket attributes\n * will go through the same validation as IPP attributes...\n */\n\nstatic void\nread_job_ticket(cupsd_client_t *con)\t/* I - Client connection */\n{\n  cups_file_t\t\t*fp;\t\t/* File to read from */\n  char\t\t\tline[256];\t/* Line data */\n  int\t\t\tnum_options;\t/* Number of options */\n  cups_option_t\t\t*options;\t/* Options */\n  ipp_t\t\t\t*ticket;\t/* New attributes */\n  ipp_attribute_t\t*attr,\t\t/* Current attribute */\n\t\t\t*attr2,\t\t/* Job attribute */\n\t\t\t*prev2;\t\t/* Previous job attribute */\n\n\n /*\n  * First open the print file...\n  */\n\n  if ((fp = cupsFileOpen(con->filename, \"rb\")) == NULL)\n  {\n    cupsdLogMessage(CUPSD_LOG_ERROR,\n                    \"Unable to open print file for job ticket - %s\",\n                    strerror(errno));\n    return;\n  }\n\n /*\n  * Skip the first line...\n  */\n\n  if (cupsFileGets(fp, line, sizeof(line)) == NULL)\n  {\n    cupsdLogMessage(CUPSD_LOG_ERROR,\n                    \"Unable to read from print file for job ticket - %s\",\n                    strerror(errno));\n    cupsFileClose(fp);\n    return;\n  }\n\n  if (strncmp(line, \"%!PS-Adobe-\", 11) && strncmp(line, \"%PDF-\", 5))\n  {\n   /*\n    * Not a DSC-compliant file, so no job ticket info will be available...\n    */\n\n    cupsFileClose(fp);\n    return;\n  }\n\n /*\n  * Read job ticket info from the file...\n  */\n\n  num_options = 0;\n  options     = NULL;\n\n  while (cupsFileGets(fp, line, sizeof(line)))\n  {\n   /*\n    * Stop at the first non-ticket line...\n    */\n\n    if (strncmp(line, \"%cupsJobTicket:\", 15))\n      break;\n\n   /*\n    * Add the options to the option array...\n    */\n\n    num_options = cupsParseOptions(line + 15, num_options, &options);\n  }\n\n /*\n  * Done with the file; see if we have any options...\n  */\n\n  cupsFileClose(fp);\n\n  if (num_options == 0)\n    return;\n\n /*\n  * OK, convert the options to an attribute list, and apply them to\n  * the request...\n  */\n\n  ticket = ippNew();\n  cupsEncodeOptions(ticket, num_options, options);\n\n /*\n  * See what the user wants to change.\n  */\n\n  for (attr = ticket->attrs; attr; attr = attr->next)\n  {\n    if (attr->group_tag != IPP_TAG_JOB || !attr->name)\n      continue;\n\n    if (!strncmp(attr->name, \"date-time-at-\", 13) ||\n        !strcmp(attr->name, \"job-impressions-completed\") ||\n\t!strcmp(attr->name, \"job-media-sheets-completed\") ||\n\t!strncmp(attr->name, \"job-k-octets\", 12) ||\n\t!strcmp(attr->name, \"job-id\") ||\n\t!strcmp(attr->name, \"job-originating-host-name\") ||\n        !strcmp(attr->name, \"job-originating-user-name\") ||\n\t!strcmp(attr->name, \"job-pages-completed\") ||\n\t!strcmp(attr->name, \"job-printer-uri\") ||\n\t!strncmp(attr->name, \"job-state\", 9) ||\n\t!strcmp(attr->name, \"job-uri\") ||\n\t!strncmp(attr->name, \"time-at-\", 8))\n      continue; /* Read-only attrs */\n\n    if ((attr2 = ippFindAttribute(con->request, attr->name,\n                                  IPP_TAG_ZERO)) != NULL)\n    {\n     /*\n      * Some other value; first free the old value...\n      */\n\n      if (con->request->attrs == attr2)\n      {\n\tcon->request->attrs = attr2->next;\n\tprev2               = NULL;\n      }\n      else\n      {\n\tfor (prev2 = con->request->attrs; prev2; prev2 = prev2->next)\n\t  if (prev2->next == attr2)\n\t  {\n\t    prev2->next = attr2->next;\n\t    break;\n\t  }\n      }\n\n      if (con->request->last == attr2)\n        con->request->last = prev2;\n\n      ippDeleteAttribute(NULL, attr2);\n    }\n\n   /*\n    * Add new option by copying it...\n    */\n\n    ippCopyAttribute(con->request, attr, 0);\n  }\n\n /*\n  * Then free the attribute list and option array...\n  */\n\n  ippDelete(ticket);\n  cupsFreeOptions(num_options, options);\n}\n\n\n/*\n * 'reject_jobs()' - Reject print jobs to a printer.\n */\n\nstatic void\nreject_jobs(cupsd_client_t  *con,\t/* I - Client connection */\n            ipp_attribute_t *uri)\t/* I - Printer or class URI */\n{\n  http_status_t\tstatus;\t\t\t/* Policy status */\n  cups_ptype_t\tdtype;\t\t\t/* Destination type (printer/class) */\n  cupsd_printer_t *printer;\t\t/* Printer data */\n  ipp_attribute_t *attr;\t\t/* printer-state-message text */\n\n\n  cupsdLogMessage(CUPSD_LOG_DEBUG2, \"reject_jobs(%p[%d], %s)\", con,\n                  con->number, uri->values[0].string.text);\n\n /*\n  * Is the destination valid?\n  */\n\n  if (!cupsdValidateDest(uri->values[0].string.text, &dtype, &printer))\n  {\n   /*\n    * Bad URI...\n    */\n\n    send_ipp_status(con, IPP_NOT_FOUND,\n                    _(\"The printer or class does not exist.\"));\n    return;\n  }\n\n /*\n  * Check policy...\n  */\n\n  if ((status = cupsdCheckPolicy(printer->op_policy_ptr, con, NULL)) != HTTP_OK)\n  {\n    send_http_error(con, status, printer);\n    return;\n  }\n\n /*\n  * Reject jobs sent to the printer...\n  */\n\n  printer->accepting = 0;\n\n  if ((attr = ippFindAttribute(con->request, \"printer-state-message\",\n                               IPP_TAG_TEXT)) == NULL)\n    strlcpy(printer->state_message, \"Rejecting Jobs\",\n            sizeof(printer->state_message));\n  else\n    strlcpy(printer->state_message, attr->values[0].string.text,\n            sizeof(printer->state_message));\n\n  cupsdAddEvent(CUPSD_EVENT_PRINTER_STATE, printer, NULL,\n                \"No longer accepting jobs.\");\n\n  if (dtype & CUPS_PRINTER_CLASS)\n  {\n    cupsdMarkDirty(CUPSD_DIRTY_CLASSES);\n\n    cupsdLogMessage(CUPSD_LOG_INFO, \"Class \\\"%s\\\" rejecting jobs (\\\"%s\\\").\",\n                    printer->name, get_username(con));\n  }\n  else\n  {\n    cupsdMarkDirty(CUPSD_DIRTY_PRINTERS);\n\n    cupsdLogMessage(CUPSD_LOG_INFO, \"Printer \\\"%s\\\" rejecting jobs (\\\"%s\\\").\",\n                    printer->name, get_username(con));\n  }\n\n /*\n  * Everything was ok, so return OK status...\n  */\n\n  con->response->request.status.status_code = IPP_OK;\n}\n\n\n/*\n * 'release_held_new_jobs()' - Release pending/new jobs on a printer or class.\n */\n\nstatic void\nrelease_held_new_jobs(\n    cupsd_client_t  *con,\t\t/* I - Connection */\n    ipp_attribute_t *uri)\t\t/* I - Printer URI */\n{\n  http_status_t\t\tstatus;\t\t/* Policy status */\n  cups_ptype_t\t\tdtype;\t\t/* Destination type (printer/class) */\n  cupsd_printer_t\t*printer;\t/* Printer data */\n\n\n  cupsdLogMessage(CUPSD_LOG_DEBUG2, \"release_held_new_jobs(%p[%d], %s)\", con,\n                  con->number, uri->values[0].string.text);\n\n /*\n  * Is the destination valid?\n  */\n\n  if (!cupsdValidateDest(uri->values[0].string.text, &dtype, &printer))\n  {\n   /*\n    * Bad URI...\n    */\n\n    send_ipp_status(con, IPP_NOT_FOUND,\n                    _(\"The printer or class does not exist.\"));\n    return;\n  }\n\n /*\n  * Check policy...\n  */\n\n  if ((status = cupsdCheckPolicy(printer->op_policy_ptr, con, NULL)) != HTTP_OK)\n  {\n    send_http_error(con, status, printer);\n    return;\n  }\n\n /*\n  * Hold pending/new jobs sent to the printer...\n  */\n\n  printer->holding_new_jobs = 0;\n\n  cupsdSetPrinterReasons(printer, \"-hold-new-jobs\");\n\n  if (dtype & CUPS_PRINTER_CLASS)\n    cupsdLogMessage(CUPSD_LOG_INFO,\n                    \"Class \\\"%s\\\" now printing pending/new jobs (\\\"%s\\\").\",\n                    printer->name, get_username(con));\n  else\n    cupsdLogMessage(CUPSD_LOG_INFO,\n                    \"Printer \\\"%s\\\" now printing pending/new jobs (\\\"%s\\\").\",\n                    printer->name, get_username(con));\n\n  cupsdCheckJobs();\n\n /*\n  * Everything was ok, so return OK status...\n  */\n\n  con->response->request.status.status_code = IPP_OK;\n}\n\n\n/*\n * 'release_job()' - Release a held print job.\n */\n\nstatic void\nrelease_job(cupsd_client_t  *con,\t/* I - Client connection */\n            ipp_attribute_t *uri)\t/* I - Job or Printer URI */\n{\n  ipp_attribute_t *attr;\t\t/* Current attribute */\n  int\t\tjobid;\t\t\t/* Job ID */\n  char\t\tscheme[HTTP_MAX_URI],\t/* Method portion of URI */\n\t\tusername[HTTP_MAX_URI],\t/* Username portion of URI */\n\t\thost[HTTP_MAX_URI],\t/* Host portion of URI */\n\t\tresource[HTTP_MAX_URI];\t/* Resource portion of URI */\n  int\t\tport;\t\t\t/* Port portion of URI */\n  cupsd_job_t\t*job;\t\t\t/* Job information */\n\n\n  cupsdLogMessage(CUPSD_LOG_DEBUG2, \"release_job(%p[%d], %s)\", con,\n                  con->number, uri->values[0].string.text);\n\n /*\n  * See if we have a job URI or a printer URI...\n  */\n\n  if (!strcmp(uri->name, \"printer-uri\"))\n  {\n   /*\n    * Got a printer URI; see if we also have a job-id attribute...\n    */\n\n    if ((attr = ippFindAttribute(con->request, \"job-id\",\n                                 IPP_TAG_INTEGER)) == NULL)\n    {\n      send_ipp_status(con, IPP_BAD_REQUEST,\n                      _(\"Got a printer-uri attribute but no job-id.\"));\n      return;\n    }\n\n    jobid = attr->values[0].integer;\n  }\n  else\n  {\n   /*\n    * Got a job URI; parse it to get the job ID...\n    */\n\n    httpSeparateURI(HTTP_URI_CODING_ALL, uri->values[0].string.text, scheme,\n                    sizeof(scheme), username, sizeof(username), host,\n\t\t    sizeof(host), &port, resource, sizeof(resource));\n\n    if (strncmp(resource, \"/jobs/\", 6))\n    {\n     /*\n      * Not a valid URI!\n      */\n\n      send_ipp_status(con, IPP_BAD_REQUEST, _(\"Bad job-uri \\\"%s\\\".\"),\n                      uri->values[0].string.text);\n      return;\n    }\n\n    jobid = atoi(resource + 6);\n  }\n\n /*\n  * See if the job exists...\n  */\n\n  if ((job = cupsdFindJob(jobid)) == NULL)\n  {\n   /*\n    * Nope - return a \"not found\" error...\n    */\n\n    send_ipp_status(con, IPP_NOT_FOUND, _(\"Job #%d does not exist.\"), jobid);\n    return;\n  }\n\n /*\n  * See if job is \"held\"...\n  */\n\n  if (job->state_value != IPP_JOB_HELD)\n  {\n   /*\n    * Nope - return a \"not possible\" error...\n    */\n\n    send_ipp_status(con, IPP_NOT_POSSIBLE, _(\"Job #%d is not held.\"), jobid);\n    return;\n  }\n\n /*\n  * See if the job is owned by the requesting user...\n  */\n\n  if (!validate_user(job, con, job->username, username, sizeof(username)))\n  {\n    send_http_error(con, con->username[0] ? HTTP_FORBIDDEN : HTTP_UNAUTHORIZED,\n                    cupsdFindDest(job->dest));\n    return;\n  }\n\n /*\n  * Reset the job-hold-until value to \"no-hold\"...\n  */\n\n  if ((attr = ippFindAttribute(job->attrs, \"job-hold-until\",\n                               IPP_TAG_KEYWORD)) == NULL)\n    attr = ippFindAttribute(job->attrs, \"job-hold-until\", IPP_TAG_NAME);\n\n  if (attr)\n  {\n    ippSetValueTag(job->attrs, &attr, IPP_TAG_KEYWORD);\n    ippSetString(job->attrs, &attr, 0, \"no-hold\");\n\n    cupsdAddEvent(CUPSD_EVENT_JOB_CONFIG_CHANGED, cupsdFindDest(job->dest), job,\n                  \"Job job-hold-until value changed by user.\");\n    ippSetString(job->attrs, &job->reasons, 0, \"none\");\n  }\n\n /*\n  * Release the job and return...\n  */\n\n  cupsdReleaseJob(job);\n\n  cupsdAddEvent(CUPSD_EVENT_JOB_STATE, cupsdFindDest(job->dest), job,\n                \"Job released by user.\");\n\n  cupsdLogJob(job, CUPSD_LOG_INFO, \"Released by \\\"%s\\\".\", username);\n\n  con->response->request.status.status_code = IPP_OK;\n\n  cupsdCheckJobs();\n}\n\n\n/*\n * 'renew_subscription()' - Renew an existing subscription...\n */\n\nstatic void\nrenew_subscription(\n    cupsd_client_t *con,\t\t/* I - Client connection */\n    int            sub_id)\t\t/* I - Subscription ID */\n{\n  http_status_t\t\tstatus;\t\t/* Policy status */\n  cupsd_subscription_t\t*sub;\t\t/* Subscription */\n  ipp_attribute_t\t*lease;\t\t/* notify-lease-duration */\n\n\n  cupsdLogMessage(CUPSD_LOG_DEBUG2,\n                  \"renew_subscription(con=%p[%d], sub_id=%d)\",\n                  con, con->number, sub_id);\n\n /*\n  * Is the subscription ID valid?\n  */\n\n  if ((sub = cupsdFindSubscription(sub_id)) == NULL)\n  {\n   /*\n    * Bad subscription ID...\n    */\n\n    send_ipp_status(con, IPP_NOT_FOUND, _(\"Subscription #%d does not exist.\"),\n                    sub_id);\n    return;\n  }\n\n  if (sub->job)\n  {\n   /*\n    * Job subscriptions cannot be renewed...\n    */\n\n    send_ipp_status(con, IPP_NOT_POSSIBLE,\n                    _(\"Job subscriptions cannot be renewed.\"));\n    return;\n  }\n\n /*\n  * Check policy...\n  */\n\n  if ((status = cupsdCheckPolicy(sub->dest ? sub->dest->op_policy_ptr :\n                                             DefaultPolicyPtr,\n                                 con, sub->owner)) != HTTP_OK)\n  {\n    send_http_error(con, status, sub->dest);\n    return;\n  }\n\n /*\n  * Renew the subscription...\n  */\n\n  lease = ippFindAttribute(con->request, \"notify-lease-duration\",\n                           IPP_TAG_INTEGER);\n\n  sub->lease = lease ? lease->values[0].integer : DefaultLeaseDuration;\n\n  if (MaxLeaseDuration && (sub->lease == 0 || sub->lease > MaxLeaseDuration))\n  {\n    cupsdLogMessage(CUPSD_LOG_INFO,\n                    \"renew_subscription: Limiting notify-lease-duration to \"\n\t\t    \"%d seconds.\",\n\t\t    MaxLeaseDuration);\n    sub->lease = MaxLeaseDuration;\n  }\n\n  sub->expire = sub->lease ? time(NULL) + sub->lease : 0;\n\n  cupsdMarkDirty(CUPSD_DIRTY_SUBSCRIPTIONS);\n\n  con->response->request.status.status_code = IPP_OK;\n\n  ippAddInteger(con->response, IPP_TAG_SUBSCRIPTION, IPP_TAG_INTEGER,\n                \"notify-lease-duration\", sub->lease);\n}\n\n\n/*\n * 'restart_job()' - Restart an old print job.\n */\n\nstatic void\nrestart_job(cupsd_client_t  *con,\t/* I - Client connection */\n            ipp_attribute_t *uri)\t/* I - Job or Printer URI */\n{\n  ipp_attribute_t *attr;\t\t/* Current attribute */\n  int\t\tjobid;\t\t\t/* Job ID */\n  cupsd_job_t\t*job;\t\t\t/* Job information */\n  char\t\tscheme[HTTP_MAX_URI],\t/* Method portion of URI */\n\t\tusername[HTTP_MAX_URI],\t/* Username portion of URI */\n\t\thost[HTTP_MAX_URI],\t/* Host portion of URI */\n\t\tresource[HTTP_MAX_URI];\t/* Resource portion of URI */\n  int\t\tport;\t\t\t/* Port portion of URI */\n\n\n  cupsdLogMessage(CUPSD_LOG_DEBUG2, \"restart_job(%p[%d], %s)\", con,\n                  con->number, uri->values[0].string.text);\n\n /*\n  * See if we have a job URI or a printer URI...\n  */\n\n  if (!strcmp(uri->name, \"printer-uri\"))\n  {\n   /*\n    * Got a printer URI; see if we also have a job-id attribute...\n    */\n\n    if ((attr = ippFindAttribute(con->request, \"job-id\",\n                                 IPP_TAG_INTEGER)) == NULL)\n    {\n      send_ipp_status(con, IPP_BAD_REQUEST,\n                      _(\"Got a printer-uri attribute but no job-id.\"));\n      return;\n    }\n\n    jobid = attr->values[0].integer;\n  }\n  else\n  {\n   /*\n    * Got a job URI; parse it to get the job ID...\n    */\n\n    httpSeparateURI(HTTP_URI_CODING_ALL, uri->values[0].string.text, scheme,\n                    sizeof(scheme), username, sizeof(username), host,\n\t\t    sizeof(host), &port, resource, sizeof(resource));\n\n    if (strncmp(resource, \"/jobs/\", 6))\n    {\n     /*\n      * Not a valid URI!\n      */\n\n      send_ipp_status(con, IPP_BAD_REQUEST, _(\"Bad job-uri \\\"%s\\\".\"),\n                      uri->values[0].string.text);\n      return;\n    }\n\n    jobid = atoi(resource + 6);\n  }\n\n /*\n  * See if the job exists...\n  */\n\n  if ((job = cupsdFindJob(jobid)) == NULL)\n  {\n   /*\n    * Nope - return a \"not found\" error...\n    */\n\n    send_ipp_status(con, IPP_NOT_FOUND, _(\"Job #%d does not exist.\"), jobid);\n    return;\n  }\n\n /*\n  * See if job is in any of the \"completed\" states...\n  */\n\n  if (job->state_value <= IPP_JOB_PROCESSING)\n  {\n   /*\n    * Nope - return a \"not possible\" error...\n    */\n\n    send_ipp_status(con, IPP_NOT_POSSIBLE, _(\"Job #%d is not complete.\"),\n                    jobid);\n    return;\n  }\n\n /*\n  * See if we have retained the job files...\n  */\n\n  cupsdLoadJob(job);\n\n  if (!job->attrs || job->num_files == 0)\n  {\n   /*\n    * Nope - return a \"not possible\" error...\n    */\n\n    send_ipp_status(con, IPP_NOT_POSSIBLE,\n                    _(\"Job #%d cannot be restarted - no files.\"), jobid);\n    return;\n  }\n\n /*\n  * See if the job is owned by the requesting user...\n  */\n\n  if (!validate_user(job, con, job->username, username, sizeof(username)))\n  {\n    send_http_error(con, con->username[0] ? HTTP_FORBIDDEN : HTTP_UNAUTHORIZED,\n                    cupsdFindDest(job->dest));\n    return;\n  }\n\n /*\n  * See if the job-hold-until attribute is specified...\n  */\n\n  if ((attr = ippFindAttribute(con->request, \"job-hold-until\",\n                               IPP_TAG_KEYWORD)) == NULL)\n    attr = ippFindAttribute(con->request, \"job-hold-until\", IPP_TAG_NAME);\n\n  if (attr && strcmp(attr->values[0].string.text, \"no-hold\"))\n  {\n   /*\n    * Return the job to a held state...\n    */\n\n    cupsdLogJob(job, CUPSD_LOG_DEBUG,\n\t\t\"Restarted by \\\"%s\\\" with job-hold-until=%s.\",\n                username, attr->values[0].string.text);\n    cupsdSetJobHoldUntil(job, attr->values[0].string.text, 0);\n\n    cupsdAddEvent(CUPSD_EVENT_JOB_CONFIG_CHANGED | CUPSD_EVENT_JOB_STATE,\n                  NULL, job, \"Job restarted by user with job-hold-until=%s\",\n\t\t  attr->values[0].string.text);\n  }\n  else\n  {\n   /*\n    * Restart the job...\n    */\n\n    cupsdRestartJob(job);\n    cupsdCheckJobs();\n  }\n\n  cupsdLogJob(job, CUPSD_LOG_INFO, \"Restarted by \\\"%s\\\".\", username);\n\n  con->response->request.status.status_code = IPP_OK;\n}\n\n\n/*\n * 'save_auth_info()' - Save authentication information for a job.\n */\n\nstatic void\nsave_auth_info(\n    cupsd_client_t  *con,\t\t/* I - Client connection */\n    cupsd_job_t     *job,\t\t/* I - Job */\n    ipp_attribute_t *auth_info)\t\t/* I - auth-info attribute, if any */\n{\n  int\t\t\ti;\t\t/* Looping var */\n  char\t\t\tfilename[1024];\t/* Job authentication filename */\n  cups_file_t\t\t*fp;\t\t/* Job authentication file */\n  char\t\t\tline[65536];\t/* Line for file */\n  cupsd_printer_t\t*dest;\t\t/* Destination printer/class */\n\n\n /*\n  * This function saves the in-memory authentication information for\n  * a job so that it can be used to authenticate with a remote host.\n  * The information is stored in a file that is readable only by the\n  * root user.  The fields are Base-64 encoded, each on a separate line,\n  * followed by random number (up to 1024) of newlines to limit the\n  * amount of information that is exposed.\n  *\n  * Because of the potential for exposing of authentication information,\n  * this functionality is only enabled when running cupsd as root.\n  *\n  * This caching only works for the Basic and BasicDigest authentication\n  * types.  Digest authentication cannot be cached this way, and in\n  * the future Kerberos authentication may make all of this obsolete.\n  *\n  * Authentication information is saved whenever an authenticated\n  * Print-Job, Create-Job, or CUPS-Authenticate-Job operation is\n  * performed.\n  *\n  * This information is deleted after a job is completed or canceled,\n  * so reprints may require subsequent re-authentication.\n  */\n\n  if (RunUser)\n    return;\n\n  if ((dest = cupsdFindDest(job->dest)) == NULL)\n    return;\n\n /*\n  * Create the authentication file and change permissions...\n  */\n\n  snprintf(filename, sizeof(filename), \"%s/a%05d\", RequestRoot, job->id);\n  if ((fp = cupsFileOpen(filename, \"w\")) == NULL)\n  {\n    cupsdLogMessage(CUPSD_LOG_ERROR,\n                    \"Unable to save authentication info to \\\"%s\\\" - %s\",\n                    filename, strerror(errno));\n    return;\n  }\n\n  fchown(cupsFileNumber(fp), 0, 0);\n  fchmod(cupsFileNumber(fp), 0400);\n\n  cupsFilePuts(fp, \"CUPSD-AUTH-V3\\n\");\n\n  for (i = 0;\n       i < (int)(sizeof(job->auth_env) / sizeof(job->auth_env[0]));\n       i ++)\n    cupsdClearString(job->auth_env + i);\n\n  if (auth_info && auth_info->num_values == dest->num_auth_info_required)\n  {\n   /*\n    * Write 1 to 3 auth values...\n    */\n\n    for (i = 0;\n         i < auth_info->num_values &&\n\t     i < (int)(sizeof(job->auth_env) / sizeof(job->auth_env[0]));\n\t i ++)\n    {\n      if (strcmp(dest->auth_info_required[i], \"negotiate\"))\n      {\n\thttpEncode64_2(line, sizeof(line), auth_info->values[i].string.text, (int)strlen(auth_info->values[i].string.text));\n\tcupsFilePutConf(fp, dest->auth_info_required[i], line);\n      }\n      else\n\tcupsFilePutConf(fp, dest->auth_info_required[i],\n\t                auth_info->values[i].string.text);\n\n      if (!strcmp(dest->auth_info_required[i], \"username\"))\n        cupsdSetStringf(job->auth_env + i, \"AUTH_USERNAME=%s\",\n\t                auth_info->values[i].string.text);\n      else if (!strcmp(dest->auth_info_required[i], \"domain\"))\n        cupsdSetStringf(job->auth_env + i, \"AUTH_DOMAIN=%s\",\n\t                auth_info->values[i].string.text);\n      else if (!strcmp(dest->auth_info_required[i], \"password\"))\n        cupsdSetStringf(job->auth_env + i, \"AUTH_PASSWORD=%s\",\n\t                auth_info->values[i].string.text);\n      else if (!strcmp(dest->auth_info_required[i], \"negotiate\"))\n        cupsdSetStringf(job->auth_env + i, \"AUTH_NEGOTIATE=%s\",\n\t                auth_info->values[i].string.text);\n      else\n        i --;\n    }\n  }\n  else if (auth_info && auth_info->num_values == 2 &&\n           dest->num_auth_info_required == 1 &&\n           !strcmp(dest->auth_info_required[0], \"negotiate\"))\n  {\n   /*\n    * Allow fallback to username+password for Kerberized queues...\n    */\n\n    httpEncode64_2(line, sizeof(line), auth_info->values[0].string.text, (int)strlen(auth_info->values[0].string.text));\n    cupsFilePutConf(fp, \"username\", line);\n\n    cupsdSetStringf(job->auth_env + 0, \"AUTH_USERNAME=%s\",\n                    auth_info->values[0].string.text);\n\n    httpEncode64_2(line, sizeof(line), auth_info->values[1].string.text, (int)strlen(auth_info->values[1].string.text));\n    cupsFilePutConf(fp, \"password\", line);\n\n    cupsdSetStringf(job->auth_env + 1, \"AUTH_PASSWORD=%s\",\n                    auth_info->values[1].string.text);\n  }\n  else if (con->username[0])\n  {\n   /*\n    * Write the authenticated username...\n    */\n\n    httpEncode64_2(line, sizeof(line), con->username, (int)strlen(con->username));\n    cupsFilePutConf(fp, \"username\", line);\n\n    cupsdSetStringf(job->auth_env + 0, \"AUTH_USERNAME=%s\", con->username);\n\n   /*\n    * Write the authenticated password...\n    */\n\n    httpEncode64_2(line, sizeof(line), con->password, (int)strlen(con->password));\n    cupsFilePutConf(fp, \"password\", line);\n\n    cupsdSetStringf(job->auth_env + 1, \"AUTH_PASSWORD=%s\", con->password);\n  }\n\n#ifdef HAVE_GSSAPI\n  if (con->gss_uid > 0)\n  {\n    cupsFilePrintf(fp, \"uid %d\\n\", (int)con->gss_uid);\n    cupsdSetStringf(&job->auth_uid, \"AUTH_UID=%d\", (int)con->gss_uid);\n  }\n#endif /* HAVE_GSSAPI */\n\n /*\n  * Write a random number of newlines to the end of the file...\n  */\n\n  for (i = (CUPS_RAND() % 1024); i >= 0; i --)\n    cupsFilePutChar(fp, '\\n');\n\n /*\n  * Close the file and return...\n  */\n\n  cupsFileClose(fp);\n}\n\n\n/*\n * 'send_document()' - Send a file to a printer or class.\n */\n\nstatic void\nsend_document(cupsd_client_t  *con,\t/* I - Client connection */\n\t      ipp_attribute_t *uri)\t/* I - Printer URI */\n{\n  ipp_attribute_t\t*attr;\t\t/* Current attribute */\n  ipp_attribute_t\t*format;\t/* Request's document-format attribute */\n  ipp_attribute_t\t*jformat;\t/* Job's document-format attribute */\n  const char\t\t*default_format;/* document-format-default value */\n  int\t\t\tjobid;\t\t/* Job ID number */\n  cupsd_job_t\t\t*job;\t\t/* Current job */\n  char\t\t\tjob_uri[HTTP_MAX_URI],\n\t\t\t\t\t/* Job URI */\n\t\t\tscheme[HTTP_MAX_URI],\n\t\t\t\t\t/* Method portion of URI */\n\t\t\tusername[HTTP_MAX_URI],\n\t\t\t\t\t/* Username portion of URI */\n\t\t\thost[HTTP_MAX_URI],\n\t\t\t\t\t/* Host portion of URI */\n\t\t\tresource[HTTP_MAX_URI];\n\t\t\t\t\t/* Resource portion of URI */\n  int\t\t\tport;\t\t/* Port portion of URI */\n  mime_type_t\t\t*filetype;\t/* Type of file */\n  char\t\t\tsuper[MIME_MAX_SUPER],\n\t\t\t\t\t/* Supertype of file */\n\t\t\ttype[MIME_MAX_TYPE],\n\t\t\t\t\t/* Subtype of file */\n\t\t\tmimetype[MIME_MAX_SUPER + MIME_MAX_TYPE + 2];\n\t\t\t\t\t/* Textual name of mime type */\n  char\t\t\tfilename[1024];\t/* Job filename */\n  cupsd_printer_t\t*printer;\t/* Current printer */\n  struct stat\t\tfileinfo;\t/* File information */\n  int\t\t\tkbytes;\t\t/* Size of file */\n  int\t\t\tcompression;\t/* Type of compression */\n  int\t\t\tstart_job;\t/* Start the job? */\n\n\n  cupsdLogMessage(CUPSD_LOG_DEBUG2, \"send_document(%p[%d], %s)\", con,\n                  con->number, uri->values[0].string.text);\n\n /*\n  * See if we have a job URI or a printer URI...\n  */\n\n  if (!strcmp(uri->name, \"printer-uri\"))\n  {\n   /*\n    * Got a printer URI; see if we also have a job-id attribute...\n    */\n\n    if ((attr = ippFindAttribute(con->request, \"job-id\",\n                                 IPP_TAG_INTEGER)) == NULL)\n    {\n      send_ipp_status(con, IPP_BAD_REQUEST,\n                      _(\"Got a printer-uri attribute but no job-id.\"));\n      return;\n    }\n\n    jobid = attr->values[0].integer;\n  }\n  else\n  {\n   /*\n    * Got a job URI; parse it to get the job ID...\n    */\n\n    httpSeparateURI(HTTP_URI_CODING_ALL, uri->values[0].string.text, scheme,\n                    sizeof(scheme), username, sizeof(username), host,\n\t\t    sizeof(host), &port, resource, sizeof(resource));\n\n    if (strncmp(resource, \"/jobs/\", 6))\n    {\n     /*\n      * Not a valid URI!\n      */\n\n      send_ipp_status(con, IPP_BAD_REQUEST, _(\"Bad job-uri \\\"%s\\\".\"),\n                      uri->values[0].string.text);\n      return;\n    }\n\n    jobid = atoi(resource + 6);\n  }\n\n /*\n  * See if the job exists...\n  */\n\n  if ((job = cupsdFindJob(jobid)) == NULL)\n  {\n   /*\n    * Nope - return a \"not found\" error...\n    */\n\n    send_ipp_status(con, IPP_NOT_FOUND, _(\"Job #%d does not exist.\"), jobid);\n    return;\n  }\n\n  printer = cupsdFindDest(job->dest);\n\n /*\n  * See if the job is owned by the requesting user...\n  */\n\n  if (!validate_user(job, con, job->username, username, sizeof(username)))\n  {\n    send_http_error(con, con->username[0] ? HTTP_FORBIDDEN : HTTP_UNAUTHORIZED,\n                    cupsdFindDest(job->dest));\n    return;\n  }\n\n /*\n  * OK, see if the client is sending the document compressed - CUPS\n  * only supports \"none\" and \"gzip\".\n  */\n\n  compression = CUPS_FILE_NONE;\n\n  if ((attr = ippFindAttribute(con->request, \"compression\",\n                               IPP_TAG_KEYWORD)) != NULL)\n  {\n    if (strcmp(attr->values[0].string.text, \"none\")\n#ifdef HAVE_LIBZ\n        && strcmp(attr->values[0].string.text, \"gzip\")\n#endif /* HAVE_LIBZ */\n      )\n    {\n      send_ipp_status(con, IPP_ATTRIBUTES, _(\"Unsupported compression \\\"%s\\\".\"),\n        \t      attr->values[0].string.text);\n      ippAddString(con->response, IPP_TAG_UNSUPPORTED_GROUP, IPP_TAG_KEYWORD,\n\t           \"compression\", NULL, attr->values[0].string.text);\n      return;\n    }\n\n#ifdef HAVE_LIBZ\n    if (!strcmp(attr->values[0].string.text, \"gzip\"))\n      compression = CUPS_FILE_GZIP;\n#endif /* HAVE_LIBZ */\n  }\n\n /*\n  * Do we have a file to print?\n  */\n\n  if ((attr = ippFindAttribute(con->request, \"last-document\",\n\t                       IPP_TAG_BOOLEAN)) == NULL)\n  {\n    send_ipp_status(con, IPP_BAD_REQUEST,\n                    _(\"Missing last-document attribute in request.\"));\n    return;\n  }\n\n  if (!con->filename)\n  {\n   /*\n    * Check for an empty request with \"last-document\" set to true, which is\n    * used to close an \"open\" job by RFC 2911, section 3.3.2.\n    */\n\n    if (job->num_files > 0 && attr->values[0].boolean)\n      goto last_document;\n\n    send_ipp_status(con, IPP_BAD_REQUEST, _(\"No file in print request.\"));\n    return;\n  }\n\n /*\n  * Is it a format we support?\n  */\n\n  cupsdLoadJob(job);\n\n  if ((format = ippFindAttribute(con->request, \"document-format\",\n                                 IPP_TAG_MIMETYPE)) != NULL)\n  {\n   /*\n    * Grab format from client...\n    */\n\n    if (sscanf(format->values[0].string.text, \"%15[^/]/%255[^;]\",\n               super, type) != 2)\n    {\n      send_ipp_status(con, IPP_BAD_REQUEST, _(\"Bad document-format \\\"%s\\\".\"),\n\t              format->values[0].string.text);\n      return;\n    }\n\n    ippAddString(job->attrs, IPP_TAG_JOB, IPP_TAG_MIMETYPE, \"document-format-supplied\", NULL, ippGetString(format, 0, NULL));\n  }\n  else if ((default_format = cupsGetOption(\"document-format\",\n                                           printer->num_options,\n\t\t\t\t\t   printer->options)) != NULL)\n  {\n   /*\n    * Use default document format...\n    */\n\n    if (sscanf(default_format, \"%15[^/]/%255[^;]\", super, type) != 2)\n    {\n      send_ipp_status(con, IPP_BAD_REQUEST,\n                      _(\"Bad document-format-default \\\"%s\\\".\"), default_format);\n      return;\n    }\n  }\n  else\n  {\n   /*\n    * No document format attribute?  Auto-type it!\n    */\n\n    strlcpy(super, \"application\", sizeof(super));\n    strlcpy(type, \"octet-stream\", sizeof(type));\n  }\n\n  if (!strcmp(super, \"application\") && !strcmp(type, \"octet-stream\"))\n  {\n   /*\n    * Auto-type the file...\n    */\n\n    ipp_attribute_t\t*doc_name;\t/* document-name attribute */\n\n\n    cupsdLogJob(job, CUPSD_LOG_DEBUG, \"Auto-typing file...\");\n\n    doc_name = ippFindAttribute(con->request, \"document-name\", IPP_TAG_NAME);\n    filetype = mimeFileType(MimeDatabase, con->filename,\n                            doc_name ? doc_name->values[0].string.text : NULL,\n\t\t\t    &compression);\n\n    if (!filetype)\n      filetype = mimeType(MimeDatabase, super, type);\n\n    if (filetype)\n      cupsdLogJob(job, CUPSD_LOG_DEBUG, \"Request file type is %s/%s.\",\n\t\t  filetype->super, filetype->type);\n\n    snprintf(mimetype, sizeof(mimetype), \"%s/%s\", filetype->super, filetype->type);\n    ippAddString(job->attrs, IPP_TAG_JOB, IPP_TAG_MIMETYPE, \"document-format-detected\", NULL, mimetype);\n  }\n  else\n    filetype = mimeType(MimeDatabase, super, type);\n\n  if (filetype)\n  {\n   /*\n    * Replace the document-format attribute value with the auto-typed or\n    * default one.\n    */\n\n    snprintf(mimetype, sizeof(mimetype), \"%s/%s\", filetype->super,\n             filetype->type);\n\n    if ((jformat = ippFindAttribute(job->attrs, \"document-format\",\n                                    IPP_TAG_MIMETYPE)) != NULL)\n      ippSetString(job->attrs, &jformat, 0, mimetype);\n    else\n      ippAddString(job->attrs, IPP_TAG_JOB, IPP_TAG_MIMETYPE,\n\t           \"document-format\", NULL, mimetype);\n  }\n  else if (!filetype)\n  {\n    send_ipp_status(con, IPP_DOCUMENT_FORMAT,\n                    _(\"Unsupported document-format \\\"%s/%s\\\".\"), super, type);\n    cupsdLogMessage(CUPSD_LOG_INFO,\n                    \"Hint: Do you have the raw file printing rules enabled?\");\n\n    if (format)\n      ippAddString(con->response, IPP_TAG_UNSUPPORTED_GROUP, IPP_TAG_MIMETYPE,\n                   \"document-format\", NULL, format->values[0].string.text);\n\n    return;\n  }\n\n  if (printer->filetypes && !cupsArrayFind(printer->filetypes, filetype))\n  {\n    snprintf(mimetype, sizeof(mimetype), \"%s/%s\", filetype->super,\n             filetype->type);\n\n    send_ipp_status(con, IPP_DOCUMENT_FORMAT,\n                    _(\"Unsupported document-format \\\"%s\\\".\"), mimetype);\n\n    ippAddString(con->response, IPP_TAG_UNSUPPORTED_GROUP, IPP_TAG_MIMETYPE,\n                 \"document-format\", NULL, mimetype);\n\n    return;\n  }\n\n /*\n  * Add the file to the job...\n  */\n\n  if (add_file(con, job, filetype, compression))\n    return;\n\n  if ((attr = ippFindAttribute(con->request, \"document-name\", IPP_TAG_NAME)) != NULL)\n    ippAddString(job->attrs, IPP_TAG_JOB, IPP_TAG_NAME, \"document-name-supplied\", NULL, ippGetString(attr, 0, NULL));\n\n  if (stat(con->filename, &fileinfo))\n    kbytes = 0;\n  else\n    kbytes = (fileinfo.st_size + 1023) / 1024;\n\n  cupsdUpdateQuota(printer, job->username, 0, kbytes);\n\n  job->koctets += kbytes;\n\n  if ((attr = ippFindAttribute(job->attrs, \"job-k-octets\", IPP_TAG_INTEGER)) != NULL)\n    attr->values[0].integer += kbytes;\n\n  snprintf(filename, sizeof(filename), \"%s/d%05d-%03d\", RequestRoot, job->id, job->num_files);\n  if (rename(con->filename, filename))\n  {\n    cupsdLogJob(job, CUPSD_LOG_ERROR, \"Unable to rename job document file \\\"%s\\\": %s\", filename, strerror(errno));\n\n    send_ipp_status(con, IPP_INTERNAL_ERROR, _(\"Unable to rename job document file.\"));\n    return;\n  }\n\n  cupsdClearString(&con->filename);\n\n  cupsdLogJob(job, CUPSD_LOG_INFO, \"File of type %s/%s queued by \\\"%s\\\".\",\n\t      filetype->super, filetype->type, job->username);\n\n /*\n  * Start the job if this is the last document...\n  */\n\n  last_document:\n\n  if ((attr = ippFindAttribute(con->request, \"last-document\",\n                               IPP_TAG_BOOLEAN)) != NULL &&\n      attr->values[0].boolean)\n  {\n   /*\n    * See if we need to add the ending sheet...\n    */\n\n    if (cupsdTimeoutJob(job))\n      return;\n\n    if (job->state_value == IPP_JOB_STOPPED)\n    {\n      job->state->values[0].integer = IPP_JOB_PENDING;\n      job->state_value              = IPP_JOB_PENDING;\n\n      ippSetString(job->attrs, &job->reasons, 0, \"none\");\n    }\n    else if (job->state_value == IPP_JOB_HELD)\n    {\n      if ((attr = ippFindAttribute(job->attrs, \"job-hold-until\",\n                                   IPP_TAG_KEYWORD)) == NULL)\n\tattr = ippFindAttribute(job->attrs, \"job-hold-until\", IPP_TAG_NAME);\n\n      if (!attr || !strcmp(attr->values[0].string.text, \"no-hold\"))\n      {\n\tjob->state->values[0].integer = IPP_JOB_PENDING;\n\tjob->state_value              = IPP_JOB_PENDING;\n\n\tippSetString(job->attrs, &job->reasons, 0, \"none\");\n      }\n      else\n\tippSetString(job->attrs, &job->reasons, 0, \"job-hold-until-specified\");\n    }\n\n    job->dirty = 1;\n    cupsdMarkDirty(CUPSD_DIRTY_JOBS);\n\n    start_job = 1;\n  }\n  else\n  {\n    if ((attr = ippFindAttribute(job->attrs, \"job-hold-until\",\n                                 IPP_TAG_KEYWORD)) == NULL)\n      attr = ippFindAttribute(job->attrs, \"job-hold-until\", IPP_TAG_NAME);\n\n    if (!attr || !strcmp(attr->values[0].string.text, \"no-hold\"))\n    {\n      job->state->values[0].integer = IPP_JOB_HELD;\n      job->state_value              = IPP_JOB_HELD;\n      job->hold_until               = time(NULL) + MultipleOperationTimeout;\n\n      ippSetString(job->attrs, &job->reasons, 0, \"job-incoming\");\n\n      job->dirty = 1;\n      cupsdMarkDirty(CUPSD_DIRTY_JOBS);\n    }\n\n    start_job = 0;\n  }\n\n /*\n  * Fill in the response info...\n  */\n\n  httpAssembleURIf(HTTP_URI_CODING_ALL, job_uri, sizeof(job_uri), \"ipp\", NULL,\n                   con->clientname, con->clientport, \"/jobs/%d\", jobid);\n  ippAddString(con->response, IPP_TAG_JOB, IPP_TAG_URI, \"job-uri\", NULL,\n               job_uri);\n\n  ippAddInteger(con->response, IPP_TAG_JOB, IPP_TAG_INTEGER, \"job-id\", jobid);\n\n  ippAddInteger(con->response, IPP_TAG_JOB, IPP_TAG_ENUM, \"job-state\",\n                job->state_value);\n  ippAddString(con->response, IPP_TAG_JOB, IPP_TAG_KEYWORD, \"job-state-reasons\",\n               NULL, job->reasons->values[0].string.text);\n\n  con->response->request.status.status_code = IPP_OK;\n\n /*\n  * Start the job if necessary...\n  */\n\n  if (start_job)\n    cupsdCheckJobs();\n}\n\n\n/*\n * 'send_http_error()' - Send a HTTP error back to the IPP client.\n */\n\nstatic void\nsend_http_error(\n    cupsd_client_t  *con,\t\t/* I - Client connection */\n    http_status_t   status,\t\t/* I - HTTP status code */\n    cupsd_printer_t *printer)\t\t/* I - Printer, if any */\n{\n  ipp_attribute_t\t*uri;\t\t/* Request URI, if any */\n\n\n  if ((uri = ippFindAttribute(con->request, \"printer-uri\",\n                              IPP_TAG_URI)) == NULL)\n    uri = ippFindAttribute(con->request, \"job-uri\", IPP_TAG_URI);\n\n  cupsdLogMessage(status == HTTP_FORBIDDEN ? CUPSD_LOG_ERROR : CUPSD_LOG_DEBUG,\n                  \"[Client %d] Returning HTTP %s for %s (%s) from %s\",\n                  con->number, httpStatus(status),\n\t\t  con->request ?\n\t\t      ippOpString(con->request->request.op.operation_id) :\n\t\t      \"no operation-id\",\n\t\t  uri ? uri->values[0].string.text : \"no URI\",\n\t\t  con->http->hostname);\n\n  if (printer)\n  {\n    int\t\tauth_type;\t\t/* Type of authentication required */\n\n\n    auth_type = CUPSD_AUTH_NONE;\n\n    if (status == HTTP_UNAUTHORIZED &&\n        printer->num_auth_info_required > 0 &&\n        !strcmp(printer->auth_info_required[0], \"negotiate\") &&\n\tcon->request &&\n\t(con->request->request.op.operation_id == IPP_PRINT_JOB ||\n\t con->request->request.op.operation_id == IPP_CREATE_JOB ||\n\t con->request->request.op.operation_id == CUPS_AUTHENTICATE_JOB))\n    {\n     /*\n      * Creating and authenticating jobs requires Kerberos...\n      */\n\n      auth_type = CUPSD_AUTH_NEGOTIATE;\n    }\n    else\n    {\n     /*\n      * Use policy/location-defined authentication requirements...\n      */\n\n      char\tresource[HTTP_MAX_URI];\t/* Resource portion of URI */\n      cupsd_location_t *auth;\t\t/* Pointer to authentication element */\n\n\n      if (printer->type & CUPS_PRINTER_CLASS)\n\tsnprintf(resource, sizeof(resource), \"/classes/%s\", printer->name);\n      else\n\tsnprintf(resource, sizeof(resource), \"/printers/%s\", printer->name);\n\n      if ((auth = cupsdFindBest(resource, HTTP_POST)) == NULL ||\n\t  auth->type == CUPSD_AUTH_NONE)\n\tauth = cupsdFindPolicyOp(printer->op_policy_ptr,\n\t\t\t\t con->request ?\n\t\t\t\t     con->request->request.op.operation_id :\n\t\t\t\t     IPP_PRINT_JOB);\n\n      if (auth)\n      {\n        if (auth->type == CUPSD_AUTH_DEFAULT)\n\t  auth_type = cupsdDefaultAuthType();\n\telse\n\t  auth_type = auth->type;\n      }\n    }\n\n    cupsdSendError(con, status, auth_type);\n  }\n  else\n    cupsdSendError(con, status, CUPSD_AUTH_NONE);\n\n  ippDelete(con->response);\n  con->response = NULL;\n\n  return;\n}\n\n\n/*\n * 'send_ipp_status()' - Send a status back to the IPP client.\n */\n\nstatic void\nsend_ipp_status(cupsd_client_t *con,\t/* I - Client connection */\n                ipp_status_t   status,\t/* I - IPP status code */\n\t        const char     *message,/* I - Status message */\n\t        ...)\t\t\t/* I - Additional args as needed */\n{\n  va_list\tap;\t\t\t/* Pointer to additional args */\n  char\t\tformatted[1024];\t/* Formatted errror message */\n\n\n  va_start(ap, message);\n  vsnprintf(formatted, sizeof(formatted),\n            _cupsLangString(con->language, message), ap);\n  va_end(ap);\n\n  cupsdLogMessage(CUPSD_LOG_DEBUG, \"%s %s: %s\",\n\t\t  ippOpString(con->request->request.op.operation_id),\n\t\t  ippErrorString(status), formatted);\n\n  con->response->request.status.status_code = status;\n\n  if (ippFindAttribute(con->response, \"attributes-charset\",\n                       IPP_TAG_ZERO) == NULL)\n    ippAddString(con->response, IPP_TAG_OPERATION, IPP_TAG_CHARSET,\n                 \"attributes-charset\", NULL, \"utf-8\");\n\n  if (ippFindAttribute(con->response, \"attributes-natural-language\",\n                       IPP_TAG_ZERO) == NULL)\n    ippAddString(con->response, IPP_TAG_OPERATION, IPP_TAG_LANGUAGE,\n                 \"attributes-natural-language\", NULL, DefaultLanguage);\n\n  ippAddString(con->response, IPP_TAG_OPERATION, IPP_TAG_TEXT,\n               \"status-message\", NULL, formatted);\n}\n\n\n/*\n * 'set_default()' - Set the default destination...\n */\n\nstatic void\nset_default(cupsd_client_t  *con,\t/* I - Client connection */\n            ipp_attribute_t *uri)\t/* I - Printer URI */\n{\n  http_status_t\t\tstatus;\t\t/* Policy status */\n  cups_ptype_t\t\tdtype;\t\t/* Destination type (printer/class) */\n  cupsd_printer_t\t*printer,\t/* Printer */\n\t\t\t*oldprinter;\t/* Old default printer */\n\n\n  cupsdLogMessage(CUPSD_LOG_DEBUG2, \"set_default(%p[%d], %s)\", con,\n                  con->number, uri->values[0].string.text);\n\n /*\n  * Is the destination valid?\n  */\n\n  if (!cupsdValidateDest(uri->values[0].string.text, &dtype, &printer))\n  {\n   /*\n    * Bad URI...\n    */\n\n    send_ipp_status(con, IPP_NOT_FOUND,\n                    _(\"The printer or class does not exist.\"));\n    return;\n  }\n\n /*\n  * Check policy...\n  */\n\n  if ((status = cupsdCheckPolicy(DefaultPolicyPtr, con, NULL)) != HTTP_OK)\n  {\n    send_http_error(con, status, NULL);\n    return;\n  }\n\n /*\n  * Set it as the default...\n  */\n\n  oldprinter     = DefaultPrinter;\n  DefaultPrinter = printer;\n\n  if (oldprinter)\n    cupsdAddEvent(CUPSD_EVENT_PRINTER_STATE, oldprinter, NULL,\n                  \"%s is no longer the default printer.\", oldprinter->name);\n\n  cupsdAddEvent(CUPSD_EVENT_PRINTER_STATE, printer, NULL,\n\t\t\"%s is now the default printer.\", printer->name);\n\n  cupsdMarkDirty(CUPSD_DIRTY_PRINTERS | CUPSD_DIRTY_CLASSES |\n                 CUPSD_DIRTY_PRINTCAP);\n\n  cupsdLogMessage(CUPSD_LOG_INFO,\n                  \"Default destination set to \\\"%s\\\" by \\\"%s\\\".\",\n\t\t  printer->name, get_username(con));\n\n /*\n  * Everything was ok, so return OK status...\n  */\n\n  con->response->request.status.status_code = IPP_OK;\n}\n\n\n/*\n * 'set_job_attrs()' - Set job attributes.\n */\n\nstatic void\nset_job_attrs(cupsd_client_t  *con,\t/* I - Client connection */\n\t      ipp_attribute_t *uri)\t/* I - Job URI */\n{\n  ipp_attribute_t\t*attr,\t\t/* Current attribute */\n\t\t\t*attr2;\t\t/* Job attribute */\n  int\t\t\tjobid;\t\t/* Job ID */\n  cupsd_job_t\t\t*job;\t\t/* Current job */\n  char\t\t\tscheme[HTTP_MAX_URI],\n\t\t\t\t\t/* Method portion of URI */\n\t\t\tusername[HTTP_MAX_URI],\n\t\t\t\t\t/* Username portion of URI */\n\t\t\thost[HTTP_MAX_URI],\n\t\t\t\t\t/* Host portion of URI */\n\t\t\tresource[HTTP_MAX_URI];\n\t\t\t\t\t/* Resource portion of URI */\n  int\t\t\tport;\t\t/* Port portion of URI */\n  int\t\t\tevent;\t\t/* Events? */\n  int\t\t\tcheck_jobs;\t/* Check jobs? */\n\n\n  cupsdLogMessage(CUPSD_LOG_DEBUG2, \"set_job_attrs(%p[%d], %s)\", con,\n                  con->number, uri->values[0].string.text);\n\n /*\n  * Start with \"everything is OK\" status...\n  */\n\n  con->response->request.status.status_code = IPP_OK;\n\n /*\n  * See if we have a job URI or a printer URI...\n  */\n\n  if (!strcmp(uri->name, \"printer-uri\"))\n  {\n   /*\n    * Got a printer URI; see if we also have a job-id attribute...\n    */\n\n    if ((attr = ippFindAttribute(con->request, \"job-id\",\n                                 IPP_TAG_INTEGER)) == NULL)\n    {\n      send_ipp_status(con, IPP_BAD_REQUEST,\n                      _(\"Got a printer-uri attribute but no job-id.\"));\n      return;\n    }\n\n    jobid = attr->values[0].integer;\n  }\n  else\n  {\n   /*\n    * Got a job URI; parse it to get the job ID...\n    */\n\n    httpSeparateURI(HTTP_URI_CODING_ALL, uri->values[0].string.text, scheme,\n                    sizeof(scheme), username, sizeof(username), host,\n\t\t    sizeof(host), &port, resource, sizeof(resource));\n\n    if (strncmp(resource, \"/jobs/\", 6))\n    {\n     /*\n      * Not a valid URI!\n      */\n\n      send_ipp_status(con, IPP_BAD_REQUEST, _(\"Bad job-uri \\\"%s\\\".\"),\n                      uri->values[0].string.text);\n      return;\n    }\n\n    jobid = atoi(resource + 6);\n  }\n\n /*\n  * See if the job exists...\n  */\n\n  if ((job = cupsdFindJob(jobid)) == NULL)\n  {\n   /*\n    * Nope - return a \"not found\" error...\n    */\n\n    send_ipp_status(con, IPP_NOT_FOUND, _(\"Job #%d does not exist.\"), jobid);\n    return;\n  }\n\n /*\n  * See if the job has been completed...\n  */\n\n  if (job->state_value > IPP_JOB_STOPPED)\n  {\n   /*\n    * Return a \"not-possible\" error...\n    */\n\n    send_ipp_status(con, IPP_NOT_POSSIBLE,\n                    _(\"Job #%d is finished and cannot be altered.\"), jobid);\n    return;\n  }\n\n /*\n  * See if the job is owned by the requesting user...\n  */\n\n  if (!validate_user(job, con, job->username, username, sizeof(username)))\n  {\n    send_http_error(con, con->username[0] ? HTTP_FORBIDDEN : HTTP_UNAUTHORIZED,\n                    cupsdFindDest(job->dest));\n    return;\n  }\n\n /*\n  * See what the user wants to change.\n  */\n\n  cupsdLoadJob(job);\n\n  check_jobs = 0;\n  event      = 0;\n\n  for (attr = con->request->attrs; attr; attr = attr->next)\n  {\n    if (attr->group_tag != IPP_TAG_JOB || !attr->name)\n      continue;\n\n    if (!strcmp(attr->name, \"attributes-charset\") ||\n\t!strcmp(attr->name, \"attributes-natural-language\") ||\n\t!strncmp(attr->name, \"date-time-at-\", 13) ||\n\t!strncmp(attr->name, \"document-compression\", 20) ||\n\t!strncmp(attr->name, \"document-format\", 15) ||\n\t!strcmp(attr->name, \"job-detailed-status-messages\") ||\n\t!strcmp(attr->name, \"job-document-access-errors\") ||\n\t!strcmp(attr->name, \"job-id\") ||\n\t!strcmp(attr->name, \"job-impressions-completed\") ||\n\t!strcmp(attr->name, \"job-k-octets-completed\") ||\n\t!strcmp(attr->name, \"job-media-sheets-completed\") ||\n        !strcmp(attr->name, \"job-originating-host-name\") ||\n        !strcmp(attr->name, \"job-originating-user-name\") ||\n\t!strcmp(attr->name, \"job-pages-completed\") ||\n\t!strcmp(attr->name, \"job-printer-up-time\") ||\n\t!strcmp(attr->name, \"job-printer-uri\") ||\n\t!strcmp(attr->name, \"job-sheets\") ||\n\t!strcmp(attr->name, \"job-state-message\") ||\n\t!strcmp(attr->name, \"job-state-reasons\") ||\n\t!strcmp(attr->name, \"job-uri\") ||\n\t!strcmp(attr->name, \"number-of-documents\") ||\n\t!strcmp(attr->name, \"number-of-intervening-jobs\") ||\n\t!strcmp(attr->name, \"output-device-assigned\") ||\n\t!strncmp(attr->name, \"time-at-\", 8))\n    {\n     /*\n      * Read-only attrs!\n      */\n\n      send_ipp_status(con, IPP_ATTRIBUTES_NOT_SETTABLE,\n                      _(\"%s cannot be changed.\"), attr->name);\n\n      attr2 = ippCopyAttribute(con->response, attr, 0);\n      ippSetGroupTag(con->response, &attr2, IPP_TAG_UNSUPPORTED_GROUP);\n      continue;\n    }\n\n    if (!strcmp(attr->name, \"job-priority\"))\n    {\n     /*\n      * Change the job priority...\n      */\n\n      if (attr->value_tag != IPP_TAG_INTEGER)\n      {\n\tsend_ipp_status(con, IPP_REQUEST_VALUE, _(\"Bad job-priority value.\"));\n\n\tattr2 = ippCopyAttribute(con->response, attr, 0);\n\tippSetGroupTag(con->response, &attr2, IPP_TAG_UNSUPPORTED_GROUP);\n      }\n      else if (job->state_value >= IPP_JOB_PROCESSING)\n      {\n\tsend_ipp_status(con, IPP_NOT_POSSIBLE,\n\t                _(\"Job is completed and cannot be changed.\"));\n\treturn;\n      }\n      else if (con->response->request.status.status_code == IPP_OK)\n      {\n        cupsdLogJob(job, CUPSD_LOG_DEBUG, \"Setting job-priority to %d\",\n\t            attr->values[0].integer);\n        cupsdSetJobPriority(job, attr->values[0].integer);\n\n\tcheck_jobs = 1;\n        event      |= CUPSD_EVENT_JOB_CONFIG_CHANGED |\n\t              CUPSD_EVENT_PRINTER_QUEUE_ORDER_CHANGED;\n      }\n    }\n    else if (!strcmp(attr->name, \"job-state\"))\n    {\n     /*\n      * Change the job state...\n      */\n\n      if (attr->value_tag != IPP_TAG_ENUM)\n      {\n\tsend_ipp_status(con, IPP_REQUEST_VALUE, _(\"Bad job-state value.\"));\n\n\tattr2 = ippCopyAttribute(con->response, attr, 0);\n\tippSetGroupTag(con->response, &attr2, IPP_TAG_UNSUPPORTED_GROUP);\n      }\n      else\n      {\n        switch (attr->values[0].integer)\n\t{\n\t  case IPP_JOB_PENDING :\n\t  case IPP_JOB_HELD :\n\t      if (job->state_value > IPP_JOB_HELD)\n\t      {\n\t\tsend_ipp_status(con, IPP_NOT_POSSIBLE,\n\t\t                _(\"Job state cannot be changed.\"));\n\t\treturn;\n\t      }\n              else if (con->response->request.status.status_code == IPP_OK)\n\t      {\n\t\tcupsdLogJob(job, CUPSD_LOG_DEBUG, \"Setting job-state to %d\",\n\t\t\t    attr->values[0].integer);\n                cupsdSetJobState(job, (ipp_jstate_t)attr->values[0].integer, CUPSD_JOB_DEFAULT, \"Job state changed by \\\"%s\\\"\", username);\n\t\tcheck_jobs = 1;\n\t      }\n\t      break;\n\n\t  case IPP_JOB_PROCESSING :\n\t  case IPP_JOB_STOPPED :\n\t      if (job->state_value != attr->values[0].integer)\n\t      {\n\t\tsend_ipp_status(con, IPP_NOT_POSSIBLE,\n\t\t                _(\"Job state cannot be changed.\"));\n\t\treturn;\n\t      }\n\t      break;\n\n\t  case IPP_JOB_CANCELED :\n\t  case IPP_JOB_ABORTED :\n\t  case IPP_JOB_COMPLETED :\n\t      if (job->state_value > IPP_JOB_PROCESSING)\n\t      {\n\t\tsend_ipp_status(con, IPP_NOT_POSSIBLE,\n\t\t                _(\"Job state cannot be changed.\"));\n\t\treturn;\n\t      }\n              else if (con->response->request.status.status_code == IPP_OK)\n\t      {\n\t\tcupsdLogJob(job, CUPSD_LOG_DEBUG, \"Setting job-state to %d\",\n\t\t\t    attr->values[0].integer);\n                cupsdSetJobState(job, (ipp_jstate_t)attr->values[0].integer,\n\t\t                 CUPSD_JOB_DEFAULT,\n\t\t\t\t \"Job state changed by \\\"%s\\\"\", username);\n                check_jobs = 1;\n\t      }\n\t      break;\n\t}\n      }\n    }\n    else if (con->response->request.status.status_code != IPP_OK)\n      continue;\n    else if ((attr2 = ippFindAttribute(job->attrs, attr->name,\n                                       IPP_TAG_ZERO)) != NULL)\n    {\n     /*\n      * Some other value; first free the old value...\n      */\n\n      if (job->attrs->prev)\n        job->attrs->prev->next = attr2->next;\n      else\n        job->attrs->attrs = attr2->next;\n\n      if (job->attrs->last == attr2)\n        job->attrs->last = job->attrs->prev;\n\n      ippDeleteAttribute(NULL, attr2);\n\n     /*\n      * Then copy the attribute...\n      */\n\n      ippCopyAttribute(job->attrs, attr, 0);\n\n     /*\n      * See if the job-name or job-hold-until is being changed.\n      */\n\n      if (!strcmp(attr->name, \"job-hold-until\"))\n      {\n        cupsdLogJob(job, CUPSD_LOG_DEBUG, \"Setting job-hold-until to %s\",\n\t\t    attr->values[0].string.text);\n        cupsdSetJobHoldUntil(job, attr->values[0].string.text, 0);\n\n\tif (!strcmp(attr->values[0].string.text, \"no-hold\"))\n\t{\n\t  cupsdReleaseJob(job);\n          check_jobs = 1;\n\t}\n\telse\n\t  cupsdSetJobState(job, IPP_JOB_HELD, CUPSD_JOB_DEFAULT,\n\t                   \"Job held by \\\"%s\\\".\", username);\n\n        event |= CUPSD_EVENT_JOB_CONFIG_CHANGED | CUPSD_EVENT_JOB_STATE;\n      }\n    }\n    else if (attr->value_tag == IPP_TAG_DELETEATTR)\n    {\n     /*\n      * Delete the attribute...\n      */\n\n      if ((attr2 = ippFindAttribute(job->attrs, attr->name,\n                                    IPP_TAG_ZERO)) != NULL)\n      {\n        if (job->attrs->prev)\n\t  job->attrs->prev->next = attr2->next;\n\telse\n\t  job->attrs->attrs = attr2->next;\n\n        if (attr2 == job->attrs->last)\n\t  job->attrs->last = job->attrs->prev;\n\n        ippDeleteAttribute(NULL, attr2);\n\n        event |= CUPSD_EVENT_JOB_CONFIG_CHANGED;\n      }\n    }\n    else\n    {\n     /*\n      * Add new option by copying it...\n      */\n\n      ippCopyAttribute(job->attrs, attr, 0);\n\n      event |= CUPSD_EVENT_JOB_CONFIG_CHANGED;\n    }\n  }\n\n /*\n  * Save the job...\n  */\n\n  job->dirty = 1;\n  cupsdMarkDirty(CUPSD_DIRTY_JOBS);\n\n /*\n  * Send events as needed...\n  */\n\n  if (event & CUPSD_EVENT_PRINTER_QUEUE_ORDER_CHANGED)\n    cupsdAddEvent(CUPSD_EVENT_PRINTER_QUEUE_ORDER_CHANGED,\n                  cupsdFindDest(job->dest), job,\n                  \"Job priority changed by user.\");\n\n  if (event & CUPSD_EVENT_JOB_STATE)\n    cupsdAddEvent(CUPSD_EVENT_JOB_STATE, cupsdFindDest(job->dest), job,\n                  job->state_value == IPP_JOB_HELD ?\n\t\t      \"Job held by user.\" : \"Job restarted by user.\");\n\n  if (event & CUPSD_EVENT_JOB_CONFIG_CHANGED)\n    cupsdAddEvent(CUPSD_EVENT_JOB_CONFIG_CHANGED, cupsdFindDest(job->dest), job,\n                  \"Job options changed by user.\");\n\n /*\n  * Start jobs if possible...\n  */\n\n  if (check_jobs)\n    cupsdCheckJobs();\n}\n\n\n/*\n * 'set_printer_attrs()' - Set printer attributes.\n */\n\nstatic void\nset_printer_attrs(cupsd_client_t  *con,\t/* I - Client connection */\n                  ipp_attribute_t *uri)\t/* I - Printer */\n{\n  http_status_t\t\tstatus;\t\t/* Policy status */\n  cups_ptype_t\t\tdtype;\t\t/* Destination type (printer/class) */\n  cupsd_printer_t\t*printer;\t/* Printer/class */\n  ipp_attribute_t\t*attr;\t\t/* Printer attribute */\n  int\t\t\tchanged = 0;\t/* Was anything changed? */\n\n\n  cupsdLogMessage(CUPSD_LOG_DEBUG2, \"set_printer_attrs(%p[%d], %s)\", con,\n                  con->number, uri->values[0].string.text);\n\n /*\n  * Is the destination valid?\n  */\n\n  if (!cupsdValidateDest(uri->values[0].string.text, &dtype, &printer))\n  {\n   /*\n    * Bad URI...\n    */\n\n    send_ipp_status(con, IPP_NOT_FOUND,\n                    _(\"The printer or class does not exist.\"));\n    return;\n  }\n\n /*\n  * Check policy...\n  */\n\n  if ((status = cupsdCheckPolicy(printer->op_policy_ptr, con, NULL)) != HTTP_OK)\n  {\n    send_http_error(con, status, printer);\n    return;\n  }\n\n /*\n  * Return a list of attributes that can be set via Set-Printer-Attributes.\n  */\n\n  if ((attr = ippFindAttribute(con->request, \"printer-location\",\n                               IPP_TAG_TEXT)) != NULL)\n  {\n    cupsdSetString(&printer->location, attr->values[0].string.text);\n    changed = 1;\n  }\n\n  if ((attr = ippFindAttribute(con->request, \"printer-geo-location\", IPP_TAG_URI)) != NULL && !strncmp(attr->values[0].string.text, \"geo:\", 4))\n  {\n    cupsdSetString(&printer->geo_location, attr->values[0].string.text);\n    changed = 1;\n  }\n\n  if ((attr = ippFindAttribute(con->request, \"printer-organization\", IPP_TAG_TEXT)) != NULL)\n  {\n    cupsdSetString(&printer->organization, attr->values[0].string.text);\n    changed = 1;\n  }\n\n  if ((attr = ippFindAttribute(con->request, \"printer-organizational-unit\", IPP_TAG_TEXT)) != NULL)\n  {\n    cupsdSetString(&printer->organizational_unit, attr->values[0].string.text);\n    changed = 1;\n  }\n\n  if ((attr = ippFindAttribute(con->request, \"printer-info\",\n                               IPP_TAG_TEXT)) != NULL)\n  {\n    cupsdSetString(&printer->info, attr->values[0].string.text);\n    changed = 1;\n  }\n\n /*\n  * Update the printer attributes and return...\n  */\n\n  if (changed)\n  {\n    printer->config_time = time(NULL);\n\n    cupsdSetPrinterAttrs(printer);\n    cupsdMarkDirty(CUPSD_DIRTY_PRINTERS);\n\n    cupsdAddEvent(CUPSD_EVENT_PRINTER_CONFIG, printer, NULL,\n                  \"Printer \\\"%s\\\" description or location changed by \\\"%s\\\".\",\n\t\t  printer->name, get_username(con));\n\n    cupsdLogMessage(CUPSD_LOG_INFO,\n                    \"Printer \\\"%s\\\" description or location changed by \\\"%s\\\".\",\n                    printer->name, get_username(con));\n  }\n\n  con->response->request.status.status_code = IPP_OK;\n}\n\n\n/*\n * 'set_printer_defaults()' - Set printer default options from a request.\n */\n\nstatic int\t\t\t\t/* O - 1 on success, 0 on failure */\nset_printer_defaults(\n    cupsd_client_t  *con,\t\t/* I - Client connection */\n    cupsd_printer_t *printer)\t\t/* I - Printer */\n{\n  int\t\t\ti;\t\t/* Looping var */\n  ipp_attribute_t \t*attr;\t\t/* Current attribute */\n  size_t\t\tnamelen;\t/* Length of attribute name */\n  char\t\t\tname[256],\t/* New attribute name */\n\t\t\tvalue[256];\t/* String version of integer attrs */\n\n\n  for (attr = con->request->attrs; attr; attr = attr->next)\n  {\n   /*\n    * Skip non-printer attributes...\n    */\n\n    if (attr->group_tag != IPP_TAG_PRINTER || !attr->name)\n      continue;\n\n    cupsdLogMessage(CUPSD_LOG_DEBUG2, \"set_printer_defaults: %s\", attr->name);\n\n    if (!strcmp(attr->name, \"job-sheets-default\"))\n    {\n     /*\n      * Only allow keywords and names...\n      */\n\n      if (attr->value_tag != IPP_TAG_NAME && attr->value_tag != IPP_TAG_KEYWORD)\n        continue;\n\n     /*\n      * Only allow job-sheets-default to be set when running without a\n      * system high classification level...\n      */\n\n      if (Classification)\n        continue;\n\n      cupsdSetString(&printer->job_sheets[0], attr->values[0].string.text);\n\n      if (attr->num_values > 1)\n\tcupsdSetString(&printer->job_sheets[1], attr->values[1].string.text);\n      else\n\tcupsdSetString(&printer->job_sheets[1], \"none\");\n    }\n    else if (!strcmp(attr->name, \"requesting-user-name-allowed\"))\n    {\n      cupsdFreeStrings(&(printer->users));\n\n      printer->deny_users = 0;\n\n      if (attr->value_tag == IPP_TAG_NAME &&\n          (attr->num_values > 1 ||\n\t   strcmp(attr->values[0].string.text, \"all\")))\n      {\n\tfor (i = 0; i < attr->num_values; i ++)\n\t  cupsdAddString(&(printer->users), attr->values[i].string.text);\n      }\n    }\n    else if (!strcmp(attr->name, \"requesting-user-name-denied\"))\n    {\n      cupsdFreeStrings(&(printer->users));\n\n      printer->deny_users = 1;\n\n      if (attr->value_tag == IPP_TAG_NAME &&\n          (attr->num_values > 1 ||\n\t   strcmp(attr->values[0].string.text, \"none\")))\n      {\n\tfor (i = 0; i < attr->num_values; i ++)\n\t  cupsdAddString(&(printer->users), attr->values[i].string.text);\n      }\n    }\n    else if (!strcmp(attr->name, \"job-quota-period\"))\n    {\n      if (attr->value_tag != IPP_TAG_INTEGER)\n        continue;\n\n      cupsdLogMessage(CUPSD_LOG_DEBUG, \"Setting job-quota-period to %d...\",\n        \t      attr->values[0].integer);\n      cupsdFreeQuotas(printer);\n\n      printer->quota_period = attr->values[0].integer;\n    }\n    else if (!strcmp(attr->name, \"job-k-limit\"))\n    {\n      if (attr->value_tag != IPP_TAG_INTEGER)\n        continue;\n\n      cupsdLogMessage(CUPSD_LOG_DEBUG, \"Setting job-k-limit to %d...\",\n        \t      attr->values[0].integer);\n      cupsdFreeQuotas(printer);\n\n      printer->k_limit = attr->values[0].integer;\n    }\n    else if (!strcmp(attr->name, \"job-page-limit\"))\n    {\n      if (attr->value_tag != IPP_TAG_INTEGER)\n        continue;\n\n      cupsdLogMessage(CUPSD_LOG_DEBUG, \"Setting job-page-limit to %d...\",\n        \t      attr->values[0].integer);\n      cupsdFreeQuotas(printer);\n\n      printer->page_limit = attr->values[0].integer;\n    }\n    else if (!strcmp(attr->name, \"printer-op-policy\"))\n    {\n      cupsd_policy_t *p;\t\t/* Policy */\n\n\n      if (attr->value_tag != IPP_TAG_NAME)\n        continue;\n\n      if ((p = cupsdFindPolicy(attr->values[0].string.text)) != NULL)\n      {\n\tcupsdLogMessage(CUPSD_LOG_DEBUG,\n                \t\"Setting printer-op-policy to \\\"%s\\\"...\",\n                \tattr->values[0].string.text);\n\tcupsdSetString(&printer->op_policy, attr->values[0].string.text);\n\tprinter->op_policy_ptr = p;\n      }\n      else\n      {\n\tsend_ipp_status(con, IPP_NOT_POSSIBLE,\n                \t_(\"Unknown printer-op-policy \\\"%s\\\".\"),\n                \tattr->values[0].string.text);\n\treturn (0);\n      }\n    }\n    else if (!strcmp(attr->name, \"printer-error-policy\"))\n    {\n      if (attr->value_tag != IPP_TAG_NAME && attr->value_tag != IPP_TAG_KEYWORD)\n        continue;\n\n      if (strcmp(attr->values[0].string.text, \"retry-current-job\") &&\n          ((printer->type & CUPS_PRINTER_CLASS) ||\n\t   (strcmp(attr->values[0].string.text, \"abort-job\") &&\n\t    strcmp(attr->values[0].string.text, \"retry-job\") &&\n\t    strcmp(attr->values[0].string.text, \"stop-printer\"))))\n      {\n\tsend_ipp_status(con, IPP_NOT_POSSIBLE,\n                \t_(\"Unknown printer-error-policy \\\"%s\\\".\"),\n                \tattr->values[0].string.text);\n\treturn (0);\n      }\n\n      cupsdLogMessage(CUPSD_LOG_DEBUG,\n                      \"Setting printer-error-policy to \\\"%s\\\"...\",\n                      attr->values[0].string.text);\n      cupsdSetString(&printer->error_policy, attr->values[0].string.text);\n    }\n\n   /*\n    * Skip any other non-default attributes...\n    */\n\n    namelen = strlen(attr->name);\n    if (namelen < 9 || strcmp(attr->name + namelen - 8, \"-default\") ||\n        namelen > (sizeof(name) - 1) || attr->num_values != 1)\n      continue;\n\n   /*\n    * OK, anything else must be a user-defined default...\n    */\n\n    strlcpy(name, attr->name, sizeof(name));\n    name[namelen - 8] = '\\0';\t\t/* Strip \"-default\" */\n\n    switch (attr->value_tag)\n    {\n      case IPP_TAG_DELETEATTR :\n          printer->num_options = cupsRemoveOption(name,\n\t\t\t\t\t\t  printer->num_options,\n\t\t\t\t\t\t  &(printer->options));\n          cupsdLogMessage(CUPSD_LOG_DEBUG,\n\t                  \"Deleting %s\", attr->name);\n          break;\n\n      case IPP_TAG_NAME :\n      case IPP_TAG_TEXT :\n      case IPP_TAG_KEYWORD :\n      case IPP_TAG_URI :\n          printer->num_options = cupsAddOption(name,\n\t                                       attr->values[0].string.text,\n\t\t\t\t\t       printer->num_options,\n\t\t\t\t\t       &(printer->options));\n          cupsdLogMessage(CUPSD_LOG_DEBUG,\n\t                  \"Setting %s to \\\"%s\\\"...\", attr->name,\n\t\t\t  attr->values[0].string.text);\n          break;\n\n      case IPP_TAG_BOOLEAN :\n          printer->num_options = cupsAddOption(name,\n\t                                       attr->values[0].boolean ?\n\t\t\t\t\t           \"true\" : \"false\",\n\t\t\t\t\t       printer->num_options,\n\t\t\t\t\t       &(printer->options));\n          cupsdLogMessage(CUPSD_LOG_DEBUG,\n\t                  \"Setting %s to %s...\", attr->name,\n\t\t\t  attr->values[0].boolean ? \"true\" : \"false\");\n          break;\n\n      case IPP_TAG_INTEGER :\n      case IPP_TAG_ENUM :\n          sprintf(value, \"%d\", attr->values[0].integer);\n          printer->num_options = cupsAddOption(name, value,\n\t\t\t\t\t       printer->num_options,\n\t\t\t\t\t       &(printer->options));\n          cupsdLogMessage(CUPSD_LOG_DEBUG,\n\t                  \"Setting %s to %s...\", attr->name, value);\n          break;\n\n      case IPP_TAG_RANGE :\n          sprintf(value, \"%d-%d\", attr->values[0].range.lower,\n\t          attr->values[0].range.upper);\n          printer->num_options = cupsAddOption(name, value,\n\t\t\t\t\t       printer->num_options,\n\t\t\t\t\t       &(printer->options));\n          cupsdLogMessage(CUPSD_LOG_DEBUG,\n\t                  \"Setting %s to %s...\", attr->name, value);\n          break;\n\n      case IPP_TAG_RESOLUTION :\n          sprintf(value, \"%dx%d%s\", attr->values[0].resolution.xres,\n\t          attr->values[0].resolution.yres,\n\t\t  attr->values[0].resolution.units == IPP_RES_PER_INCH ?\n\t\t      \"dpi\" : \"dpcm\");\n          printer->num_options = cupsAddOption(name, value,\n\t\t\t\t\t       printer->num_options,\n\t\t\t\t\t       &(printer->options));\n          cupsdLogMessage(CUPSD_LOG_DEBUG,\n\t                  \"Setting %s to %s...\", attr->name, value);\n          break;\n\n      default :\n          /* Do nothing for other values */\n\t  break;\n    }\n  }\n\n  return (1);\n}\n\n\n/*\n * 'start_printer()' - Start a printer.\n */\n\nstatic void\nstart_printer(cupsd_client_t  *con,\t/* I - Client connection */\n              ipp_attribute_t *uri)\t/* I - Printer URI */\n{\n  int\t\t\ti;\t\t/* Temporary variable */\n  http_status_t\t\tstatus;\t\t/* Policy status */\n  cups_ptype_t\t\tdtype;\t\t/* Destination type (printer/class) */\n  cupsd_printer_t\t*printer;\t/* Printer data */\n\n\n  cupsdLogMessage(CUPSD_LOG_DEBUG2, \"start_printer(%p[%d], %s)\", con,\n                  con->number, uri->values[0].string.text);\n\n /*\n  * Is the destination valid?\n  */\n\n  if (!cupsdValidateDest(uri->values[0].string.text, &dtype, &printer))\n  {\n   /*\n    * Bad URI...\n    */\n\n    send_ipp_status(con, IPP_NOT_FOUND,\n                    _(\"The printer or class does not exist.\"));\n    return;\n  }\n\n /*\n  * Check policy...\n  */\n\n  if ((status = cupsdCheckPolicy(printer->op_policy_ptr, con, NULL)) != HTTP_OK)\n  {\n    send_http_error(con, status, printer);\n    return;\n  }\n\n /*\n  * Start the printer...\n  */\n\n  printer->state_message[0] = '\\0';\n\n  cupsdStartPrinter(printer, 1);\n\n  if (dtype & CUPS_PRINTER_CLASS)\n    cupsdLogMessage(CUPSD_LOG_INFO, \"Class \\\"%s\\\" started by \\\"%s\\\".\",\n                    printer->name, get_username(con));\n  else\n    cupsdLogMessage(CUPSD_LOG_INFO, \"Printer \\\"%s\\\" started by \\\"%s\\\".\",\n                    printer->name, get_username(con));\n\n  cupsdCheckJobs();\n\n /*\n  * Check quotas...\n  */\n\n  if ((i = check_quotas(con, printer)) < 0)\n  {\n    send_ipp_status(con, IPP_NOT_POSSIBLE, _(\"Quota limit reached.\"));\n    return;\n  }\n  else if (i == 0)\n  {\n    send_ipp_status(con, IPP_NOT_AUTHORIZED, _(\"Not allowed to print.\"));\n    return;\n  }\n\n /*\n  * Everything was ok, so return OK status...\n  */\n\n  con->response->request.status.status_code = IPP_OK;\n}\n\n\n/*\n * 'stop_printer()' - Stop a printer.\n */\n\nstatic void\nstop_printer(cupsd_client_t  *con,\t/* I - Client connection */\n             ipp_attribute_t *uri)\t/* I - Printer URI */\n{\n  http_status_t\t\tstatus;\t\t/* Policy status */\n  cups_ptype_t\t\tdtype;\t\t/* Destination type (printer/class) */\n  cupsd_printer_t\t*printer;\t/* Printer data */\n  ipp_attribute_t\t*attr;\t\t/* printer-state-message attribute */\n\n\n  cupsdLogMessage(CUPSD_LOG_DEBUG2, \"stop_printer(%p[%d], %s)\", con,\n                  con->number, uri->values[0].string.text);\n\n /*\n  * Is the destination valid?\n  */\n\n  if (!cupsdValidateDest(uri->values[0].string.text, &dtype, &printer))\n  {\n   /*\n    * Bad URI...\n    */\n\n    send_ipp_status(con, IPP_NOT_FOUND,\n                    _(\"The printer or class does not exist.\"));\n    return;\n  }\n\n /*\n  * Check policy...\n  */\n\n  if ((status = cupsdCheckPolicy(printer->op_policy_ptr, con, NULL)) != HTTP_OK)\n  {\n    send_http_error(con, status, printer);\n    return;\n  }\n\n /*\n  * Stop the printer...\n  */\n\n  if ((attr = ippFindAttribute(con->request, \"printer-state-message\",\n                               IPP_TAG_TEXT)) == NULL)\n    strlcpy(printer->state_message, \"Paused\", sizeof(printer->state_message));\n  else\n  {\n    strlcpy(printer->state_message, attr->values[0].string.text,\n            sizeof(printer->state_message));\n  }\n\n  cupsdStopPrinter(printer, 1);\n\n  if (dtype & CUPS_PRINTER_CLASS)\n    cupsdLogMessage(CUPSD_LOG_INFO, \"Class \\\"%s\\\" stopped by \\\"%s\\\".\",\n                    printer->name, get_username(con));\n  else\n    cupsdLogMessage(CUPSD_LOG_INFO, \"Printer \\\"%s\\\" stopped by \\\"%s\\\".\",\n                    printer->name, get_username(con));\n\n /*\n  * Everything was ok, so return OK status...\n  */\n\n  con->response->request.status.status_code = IPP_OK;\n}\n\n\n/*\n * 'url_encode_attr()' - URL-encode a string attribute.\n */\n\nstatic void\nurl_encode_attr(ipp_attribute_t *attr,\t/* I - Attribute */\n                char            *buffer,/* I - String buffer */\n\t\tsize_t          bufsize)/* I - Size of buffer */\n{\n  int\ti;\t\t\t\t/* Looping var */\n  char\t*bufptr,\t\t\t/* Pointer into buffer */\n\t*bufend;\t\t\t/* End of buffer */\n\n\n  strlcpy(buffer, attr->name, bufsize);\n  bufptr = buffer + strlen(buffer);\n  bufend = buffer + bufsize - 1;\n\n  for (i = 0; i < attr->num_values; i ++)\n  {\n    if (bufptr >= bufend)\n      break;\n\n    if (i)\n      *bufptr++ = ',';\n    else\n      *bufptr++ = '=';\n\n    if (bufptr >= bufend)\n      break;\n\n    *bufptr++ = '\\'';\n\n    bufptr = url_encode_string(attr->values[i].string.text, bufptr, (size_t)(bufend - bufptr + 1));\n\n    if (bufptr >= bufend)\n      break;\n\n    *bufptr++ = '\\'';\n  }\n\n  *bufptr = '\\0';\n}\n\n\n/*\n * 'url_encode_string()' - URL-encode a string.\n */\n\nstatic char *\t\t\t\t/* O - End of string */\nurl_encode_string(const char *s,\t/* I - String */\n                  char       *buffer,\t/* I - String buffer */\n\t\t  size_t     bufsize)\t/* I - Size of buffer */\n{\n  char\t*bufptr,\t\t\t/* Pointer into buffer */\n\t*bufend;\t\t\t/* End of buffer */\n  static const char *hex = \"0123456789ABCDEF\";\n\t\t\t\t\t/* Hex digits */\n\n\n  bufptr = buffer;\n  bufend = buffer + bufsize - 1;\n\n  while (*s && bufptr < bufend)\n  {\n    if (*s == ' ' || *s == '%' || *s == '+')\n    {\n      if (bufptr >= (bufend - 2))\n\tbreak;\n\n      *bufptr++ = '%';\n      *bufptr++ = hex[(*s >> 4) & 15];\n      *bufptr++ = hex[*s & 15];\n\n      s ++;\n    }\n    else if (*s == '\\'' || *s == '\\\\')\n    {\n      if (bufptr >= (bufend - 1))\n\tbreak;\n\n      *bufptr++ = '\\\\';\n      *bufptr++ = *s++;\n    }\n    else\n      *bufptr++ = *s++;\n  }\n\n  *bufptr = '\\0';\n\n  return (bufptr);\n}\n\n\n/*\n * 'user_allowed()' - See if a user is allowed to print to a queue.\n */\n\nstatic int\t\t\t\t/* O - 0 if not allowed, 1 if allowed */\nuser_allowed(cupsd_printer_t *p,\t/* I - Printer or class */\n             const char      *username)\t/* I - Username */\n{\n  struct passwd\t*pw;\t\t\t/* User password data */\n  char\t\tbaseuser[256],\t\t/* Base username */\n\t\t*baseptr,\t\t/* Pointer to \"@\" in base username */\n\t\t*name;\t\t\t/* Current user name */\n\n\n  if (cupsArrayCount(p->users) == 0)\n    return (1);\n\n  if (!strcmp(username, \"root\"))\n    return (1);\n\n  if (strchr(username, '@'))\n  {\n   /*\n    * Strip @REALM for username check...\n    */\n\n    strlcpy(baseuser, username, sizeof(baseuser));\n\n    if ((baseptr = strchr(baseuser, '@')) != NULL)\n      *baseptr = '\\0';\n\n    username = baseuser;\n  }\n\n  pw = getpwnam(username);\n  endpwent();\n\n  for (name = (char *)cupsArrayFirst(p->users);\n       name;\n       name = (char *)cupsArrayNext(p->users))\n  {\n    if (name[0] == '@')\n    {\n     /*\n      * Check group membership...\n      */\n\n      if (cupsdCheckGroup(username, pw, name + 1))\n        break;\n    }\n    else if (name[0] == '#')\n    {\n     /*\n      * Check UUID...\n      */\n\n      if (cupsdCheckGroup(username, pw, name))\n        break;\n    }\n    else if (!_cups_strcasecmp(username, name))\n      break;\n  }\n\n  return ((name != NULL) != p->deny_users);\n}\n\n\n/*\n * 'validate_job()' - Validate printer options and destination.\n */\n\nstatic void\nvalidate_job(cupsd_client_t  *con,\t/* I - Client connection */\n\t     ipp_attribute_t *uri)\t/* I - Printer URI */\n{\n  http_status_t\t\tstatus;\t\t/* Policy status */\n  ipp_attribute_t\t*attr;\t\t/* Current attribute */\n#ifdef HAVE_SSL\n  ipp_attribute_t\t*auth_info;\t/* auth-info attribute */\n#endif /* HAVE_SSL */\n  ipp_attribute_t\t*format,\t/* Document-format attribute */\n\t\t\t*name;\t\t/* Job-name attribute */\n  cups_ptype_t\t\tdtype;\t\t/* Destination type (printer/class) */\n  char\t\t\tsuper[MIME_MAX_SUPER],\n\t\t\t\t\t/* Supertype of file */\n\t\t\ttype[MIME_MAX_TYPE];\n\t\t\t\t\t/* Subtype of file */\n  cupsd_printer_t\t*printer;\t/* Printer */\n\n\n  cupsdLogMessage(CUPSD_LOG_DEBUG2, \"validate_job(%p[%d], %s)\", con,\n                  con->number, uri->values[0].string.text);\n\n /*\n  * OK, see if the client is sending the document compressed - CUPS\n  * doesn't support compression yet...\n  */\n\n  if ((attr = ippFindAttribute(con->request, \"compression\",\n                               IPP_TAG_KEYWORD)) != NULL)\n  {\n    if (strcmp(attr->values[0].string.text, \"none\")\n#ifdef HAVE_LIBZ\n        && strcmp(attr->values[0].string.text, \"gzip\")\n#endif /* HAVE_LIBZ */\n      )\n    {\n      send_ipp_status(con, IPP_ATTRIBUTES,\n                      _(\"Unsupported 'compression' value \\\"%s\\\".\"),\n        \t      attr->values[0].string.text);\n      ippAddString(con->response, IPP_TAG_UNSUPPORTED_GROUP, IPP_TAG_KEYWORD,\n\t           \"compression\", NULL, attr->values[0].string.text);\n      return;\n    }\n  }\n\n /*\n  * Is it a format we support?\n  */\n\n  if ((format = ippFindAttribute(con->request, \"document-format\",\n                                 IPP_TAG_MIMETYPE)) != NULL)\n  {\n    if (sscanf(format->values[0].string.text, \"%15[^/]/%255[^;]\",\n               super, type) != 2)\n    {\n      send_ipp_status(con, IPP_BAD_REQUEST,\n                      _(\"Bad 'document-format' value \\\"%s\\\".\"),\n\t\t      format->values[0].string.text);\n      return;\n    }\n\n    if ((strcmp(super, \"application\") || strcmp(type, \"octet-stream\")) &&\n\t!mimeType(MimeDatabase, super, type))\n    {\n      cupsdLogMessage(CUPSD_LOG_INFO,\n                      \"Hint: Do you have the raw file printing rules enabled?\");\n      send_ipp_status(con, IPP_DOCUMENT_FORMAT,\n                      _(\"Unsupported 'document-format' value \\\"%s\\\".\"),\n\t\t      format->values[0].string.text);\n      ippAddString(con->response, IPP_TAG_UNSUPPORTED_GROUP, IPP_TAG_MIMETYPE,\n                   \"document-format\", NULL, format->values[0].string.text);\n      return;\n    }\n  }\n\n /*\n  * Is the job-name valid?\n  */\n\n  if ((name = ippFindAttribute(con->request, \"job-name\", IPP_TAG_ZERO)) != NULL)\n  {\n    int bad_name = 0;\t\t\t/* Is the job-name value bad? */\n\n    if ((name->value_tag != IPP_TAG_NAME && name->value_tag != IPP_TAG_NAMELANG) ||\n        name->num_values != 1)\n    {\n      bad_name = 1;\n    }\n    else\n    {\n     /*\n      * Validate that job-name conforms to RFC 5198 (Network Unicode) and\n      * IPP Everywhere requirements for \"name\" values...\n      */\n\n      const unsigned char *nameptr;\t/* Pointer into \"job-name\" attribute */\n\n      for (nameptr = (unsigned char *)name->values[0].string.text;\n           *nameptr;\n           nameptr ++)\n      {\n        if (*nameptr < ' ' && *nameptr != '\\t')\n          break;\n        else if (*nameptr == 0x7f)\n          break;\n        else if ((*nameptr & 0xe0) == 0xc0)\n        {\n          if ((nameptr[1] & 0xc0) != 0x80)\n            break;\n\n          nameptr ++;\n        }\n        else if ((*nameptr & 0xf0) == 0xe0)\n        {\n          if ((nameptr[1] & 0xc0) != 0x80 ||\n              (nameptr[2] & 0xc0) != 0x80)\n\t    break;\n\n\t  nameptr += 2;\n\t}\n        else if ((*nameptr & 0xf8) == 0xf0)\n        {\n          if ((nameptr[1] & 0xc0) != 0x80 ||\n\t      (nameptr[2] & 0xc0) != 0x80 ||\n\t      (nameptr[3] & 0xc0) != 0x80)\n\t    break;\n\n\t  nameptr += 3;\n\t}\n        else if (*nameptr & 0x80)\n          break;\n      }\n\n      if (*nameptr)\n        bad_name = 1;\n    }\n\n    if (bad_name)\n    {\n      if (StrictConformance)\n      {\n\tsend_ipp_status(con, IPP_ATTRIBUTES,\n\t                _(\"Unsupported 'job-name' value.\"));\n\tippCopyAttribute(con->response, name, 0);\n\treturn;\n      }\n      else\n      {\n        cupsdLogMessage(CUPSD_LOG_WARN,\n                        \"Unsupported 'job-name' value, deleting from request.\");\n        ippDeleteAttribute(con->request, name);\n      }\n    }\n  }\n\n /*\n  * Is the destination valid?\n  */\n\n  if (!cupsdValidateDest(uri->values[0].string.text, &dtype, &printer))\n  {\n   /*\n    * Bad URI...\n    */\n\n    send_ipp_status(con, IPP_NOT_FOUND,\n                    _(\"The printer or class does not exist.\"));\n    return;\n  }\n\n /*\n  * Check policy...\n  */\n\n#ifdef HAVE_SSL\n  auth_info = ippFindAttribute(con->request, \"auth-info\", IPP_TAG_TEXT);\n#endif /* HAVE_SSL */\n\n  if ((status = cupsdCheckPolicy(printer->op_policy_ptr, con, NULL)) != HTTP_OK)\n  {\n    send_http_error(con, status, printer);\n    return;\n  }\n  else if (printer->num_auth_info_required == 1 &&\n           !strcmp(printer->auth_info_required[0], \"negotiate\") &&\n           !con->username[0])\n  {\n    send_http_error(con, HTTP_UNAUTHORIZED, printer);\n    return;\n  }\n#ifdef HAVE_SSL\n  else if (auth_info && !con->http->tls &&\n           !httpAddrLocalhost(con->http->hostaddr))\n  {\n   /*\n    * Require encryption of auth-info over non-local connections...\n    */\n\n    send_http_error(con, HTTP_UPGRADE_REQUIRED, printer);\n    return;\n  }\n#endif /* HAVE_SSL */\n\n /*\n  * Everything was ok, so return OK status...\n  */\n\n  con->response->request.status.status_code = IPP_OK;\n}\n\n\n/*\n * 'validate_name()' - Make sure the printer name only contains valid chars.\n */\n\nstatic int\t\t\t/* O - 0 if name is no good, 1 if good */\nvalidate_name(const char *name)\t/* I - Name to check */\n{\n  const char\t*ptr;\t\t/* Pointer into name */\n\n\n /*\n  * Scan the whole name...\n  */\n\n  for (ptr = name; *ptr; ptr ++)\n    if ((*ptr > 0 && *ptr <= ' ') || *ptr == 127 || *ptr == '/' || *ptr == '#')\n      return (0);\n\n /*\n  * All the characters are good; validate the length, too...\n  */\n\n  return ((ptr - name) < 128);\n}\n\n\n/*\n * 'validate_user()' - Validate the user for the request.\n */\n\nstatic int\t\t\t\t/* O - 1 if permitted, 0 otherwise */\nvalidate_user(cupsd_job_t    *job,\t/* I - Job */\n              cupsd_client_t *con,\t/* I - Client connection */\n              const char     *owner,\t/* I - Owner of job/resource */\n              char           *username,\t/* O - Authenticated username */\n\t      size_t         userlen)\t/* I - Length of username */\n{\n  cupsd_printer_t\t*printer;\t/* Printer for job */\n\n\n  cupsdLogMessage(CUPSD_LOG_DEBUG2, \"validate_user(job=%d, con=%d, owner=\\\"%s\\\", username=%p, userlen=\" CUPS_LLFMT \")\", job->id, con ? con->number : 0, owner ? owner : \"(null)\", username, CUPS_LLCAST userlen);\n\n /*\n  * Validate input...\n  */\n\n  if (!con || !owner || !username || userlen <= 0)\n    return (0);\n\n /*\n  * Get the best authenticated username that is available.\n  */\n\n  strlcpy(username, get_username(con), userlen);\n\n /*\n  * Check the username against the owner...\n  */\n\n  printer = cupsdFindDest(job->dest);\n\n  return (cupsdCheckPolicy(printer ? printer->op_policy_ptr : DefaultPolicyPtr,\n                           con, owner) == HTTP_OK);\n}\n"], "fixing_code": ["CHANGES - 2.2.6 - 2017-10-23\n============================\n\n\nChanges in CUPS v2.2.6\n----------------------\n\n- DBUS notifications could crash the scheduler (Issue #5143)\n- Added USB quirks rules for Canon MP540 and Samsung ML-2160 (Issue #5148)\n- Fixed TLS cipher suite selection with GNU TLS (Issue #5145, Issue #5150)\n\n\nChanges in CUPS v2.2.5\n----------------------\n\n- The scheduler's `-t` option did not force all errors to the standard error\n  file, making debugging of configuration problems hard (Issue #5041)\n- Fixed a typo in the CUPS Programming Manual (Issue #5042)\n- Fixed RPM packaging issue (Issue #5043, Issue #5044)\n- The `cupsGetDests` function incorrectly returned an empty list of printers if\n  there was no default printer (Issue #5046)\n- The `cupsGetDests` function waited too long for network printers (Issue #5049)\n- Libtool support was completely broken with current libtool versions that use\n  an incompatible command-line syntax (Issue #5050)\n- Fixed a build issue with `--enable-mallinfo` (Issue #5051)\n- The ippserver test program contained a deadlock issue (Issue #5054)\n- The `cupsLocalizeDest*` functions did not provide base localizations for\n  all registered IPP attributes and values (Issue #5056)\n- The --enable-libtool configure option requires a path to the libtool program,\n  but doesn't document or check for it (Issue #5062)\n- Fixed the `SSLOptions DenyCBC` option when using GNU TLS (Issue #5065)\n- Fixed the `ServerTokens None` option (Issue #5065)\n- Fixed the default `ServerAlias` value from `ServerName` (Issue #5072)\n- Fixed the adminurl field in the TXT record for fully-qualified `ServerName`\n  values (Issue #5074)\n- The scheduler now creates a PID file when not running on demand with a modern\n  service launcher (Issue #5080)\n- The web interface did not support newer language identifiers used by Microsoft\n  web browsers (Issue #5803)\n- Updated the cups-files.conf and cupsd.conf file documentation for missing\n  directives (Issue #5084)\n- Fixed an Avahi-related crash bug in the scheduler (Issue #5085, Issue #5086)\n- Fixed the interactions between the \"print-quality\" and \"cupsPrintQuality\"\n  options (Issue #5090)\n- The IPP Everywhere PPD generator now sorts the supported resolutions before\n  choosing them for draft, normal, and best quality modes (Issue #5091)\n- Fixed the localization unit test on Linux (Issue #5097)\n- The CUPS library did not reuse domain sockets (Issue #5098)\n- Fixed the \"make check\" target for some environments (Issue #5099)\n- The scheduler woke up once per second to remove old temporary queues\n  (Issue #5100)\n- Added USB quirk rule for Kyocera printer (Issue #5102, Issue #5103)\n- Re-documented the limits of `file:///...` device URIs and moved the FileDevice\n  directive in `cups-files.conf` to the list of deprecated configuration\n  directives (Issue #5117)\n- Added USB quirk rule for HP LaserJet 1160 printer (Issue #5121)\n- Fixed the script interpreter detection in the configure script (Issue #5122)\n- The network backends now retry on more error conditions (Issue #5123)\n- Added a French translation of the web interface (Issue #5134)\n- `cupsGetDests2` was not using the supplied HTTP connection (Issue #5135)\n- `httpAddrConnect` leaked sockets in certain circumstances, causing some\n  printers to hang (rdar://31965686)\n- Fixed an issue with Chinese localizations on macOS (rdar://32419311)\n- The IPP backend now always sends the \"finishings\" attribute for printers that\n  support it because otherwise the client cannot override printer defaults\n  (rdar://33169732)\n- The `cupsGetNamedDest` function did not use the local default printer\n  (rdar://33228500)\n- The IPP backend incorrectly sent the \"job-pages-per-set\" attribute to PDF\n  printers (rdar://33250434)\n- Fixed the `cups.strings` file that is used on macOS (rdar://33287650)\n- CUPS now sends the `Date` HTTP header in IPP requests (rdar://33302034)\n- The `ippCopyAttribute` function did not copy out-of-band values correctly\n  (rdar://33688003)\n- Fixed the localization fallback code on macOS (rdar://33583699)\n- The scheduler did not run with a high enough priority, causing problems on\n  busy systems (rdar://33789342)\n- Added support for Japanese Kaku 1 envelope size (rdar://34774110)\n- The `ipptool` program's `-P` option did not work correctly.\n- The `ipptool` program did not compare URI scheme or hostname components\n  correctly for the WITH-ALL-HOSTNAMES, WITH-ALL-SCHEMES, WITH-HOSTNAME, or\n  WITH-SCHEME predicates.\n\n\nChanges in CUPS v2.2.4\n----------------------\n\n- The scheduler did not remove old job files (Issue #4987)\n- cupsEnumDests did not return early when all printers had been discovered\n  (Issue #4989)\n- The CUPS build system now supports cross-compilation (Issue #4897)\n- Added a new CUPS Programming Manual to replace the aging API documentation.\n- Added the `cupsAddIntegerOption` and `cupsGetIntegerOption` functions\n  (Issue #4992)\n- The `cupsGetDests` and `cupsCreateJob` functions now support Bonjour printers\n  (Issue #4993)\n- Added a USB quirk rule for Lexmark E260dn printers (Issue #4994)\n- Fixed a potential buffer overflow in the `cupstestppd` utility (Issue #4996)\n- IPP Everywhere improvements (Issue #4998)\n- Fixed the \"cancel all jobs\" function in the web interface for several\n  languages (Issue #4999)\n- Fixed issues with local queues (Issue #5003, Issue #5008, Issue #5009)\n- The `lpstat` command now supports a `-e` option to enumerate local printers\n  (either previously added or on the network) that can be accessed\n  (Issue #5005)\n- The `lp` and `lpr` commands now support printing to network printers that\n  haven't yet been added (Issue #5006)\n- Fixed a typo in the mime.types file.\n- Fixed a bug in the Spanish web interface template (Issue #5016)\n- The `cupsEnumDests*` and `cupsGetDest*` functions now report the value of the\n  \"printer-is-temporary\" Printer Status attribute (Issue #5028)\n- Added Chinese localization (Issue #5029)\n- The `cupsCheckDestSupported` function did not support `NULL` values\n  (Issue #5031)\n- Fixed some issues in the RPM spec file (Issue #5032)\n- The `cupsConnectDest` function now supports the `CUPS_DEST_FLAGS_DEVICE` flag\n  for explicitly connecting to the device (printer) associated with the\n  destination.\n- The `SSLOptions` directive in \"client.conf\" and \"cupsd.conf\" now supports\n  `DenyCBC` and `DenyTLS1.0` options (Issue #5037)\n\n\nChanges in CUPS v2.2.3\n----------------------\n\n- The IPP backend could get into an infinite loop for certain errors, causing a\n  hung queue (<rdar://problem/28008717>)\n- The scheduler could pause responding to client requests in order to save state\n  changes to disk (<rdar://problem/28690656>)\n- Added support for PPD finishing keywords (Issue #4960, Issue #4961,\n  Issue #4962)\n- The IPP backend did not send a media-col attribute for just the source or type\n  (Issue #4963)\n- IPP Everywhere print queues did not always support all print qualities\n  supported by the printer (Issue #4953)\n- IPP Everywhere print queues did not always support all media types supported\n  by the printer (Issue #4953)\n- The IPP Everywhere PPD generator did not return useful error messages\n  (Issue #4954)\n- The IPP Everywhere finishings support did not work correctly with common UI or\n  command-line options (Issue #4976)\n- Fixed an error handling issue for the network backends (Issue #4979)\n- The default cupsd.conf file did not work on systems compiled without Kerberos\n  support (Issue #4947)\n- The \"reprint job\" option was not available for some canceled jobs\n  (Issue #4915)\n- Updated the job listing in the web interface (Issue #4978)\n- Fixed some localization issues on macOS (<rdar://problem/27245567>)\n\n\nChanges in CUPS v2.2.2\n----------------------\n\n- Fixed some issues with the Zebra ZPL printer driver (Issue #4898)\n- Fixed some issues with IPP Everywhere printer support (Issue #4893,\n  Issue #4909, Issue #4916, Issue #4921, Issue #4923, Issue #4932, Issue #4933,\n  Issue #4938)\n- The rastertopwg filter could crash with certain input (Issue #4942)\n- Optimized connection usage in the IPP backend (<rdar://problem/29547323>)\n- The scheduler did not detect when an encrypted connection was closed by the\n  client on Linux (Issue #4901)\n- The cups-lpd program did not catch all legacy usage of ISO-8859-1\n  (Issue #4899)\n- Fixed builds on systems without a working poll() implementation (Issue #4905)\n- Added a USB quirk rule for the Kyocera Ecosys P6026cdn (Issue #4900)\n- The scheduler no longer creates log files on startup\n  (<rdar://problem/28332470>)\n- The ippContainsString function now uses case-insensitive comparisons for\n  mimeMediaType, name, and text values in conformance with RFC 2911.\n- The network backends now log the addresses that were found for a printer\n  (<rdar://problem/29268474>)\n- Let's Encrypt certificates did not work when the hostname contained uppercase\n  letters (Issue #4919)\n- Fixed reporting of printed pages in the web interface (Issue #4924)\n- Updated systemd config files (Issue #4935)\n- Updated documentation (PR #4896)\n- Updated localizations (PR #4894, PR #4895, PR #4904, PR #4908, Issue #4946)\n- Updated packaging files (Issue #4940)\n\n\nChanges in CUPS v2.2.1\n----------------------\n\n- Added \"CreateSelfSignedCerts\" directive for cups-files.conf to control whether\n  the scheduler automatically creates its own self-signed X.509 certificates for\n  TLS connections (Issue #4876)\n- http*Connect did not handle partial failures (Issue #4870)\n- Addressed some build warnings on Linux (Issue #4881)\n- cupsHashData did not use the correct hashing algorithm\n  (<rdar://problem/28209220>)\n- Updated man pages (PR #4885)\n- Updated localizations (PR #4877, PR #4886)\n\n\nChanges in CUPS v2.2.0\n----------------------\n\n- Normalized the TLS certificate validation code and added additional error\n  messages to aid troubleshooting.\n- The httpConnect functions did not work on Linux when cupsd was not running\n  (Issue #4870)\n- The --no-remote-any option of cupsctl had no effect (Issue #4866)\n- http*Connect did not return early when all addresses failed (Issue #4870)\n\n\nChanges in CUPS v2.2rc1\n-----------------------\n\n- Updated the list of supported IPP Everywhere media types.\n- The IPP backend did not validate TLS credentials properly.\n- The printer-state-message attribute was not cleared after a print job with no\n  errors (Issue #4851)\n- The CUPS-Add-Modify-Class and CUPS-Add-Modify-Printer operations did not\n  always return an error for failed adds (Issue #4854)\n- PPD files with names longer than 127 bytes did not work (Issue #4860)\n- Updated localizations (Issue #4846, PR #4858)\n\n\nChanges in CUPS v2.2b2\n----------------------\n\n- Added Upstart support (PR #4825)\n- CUPS now supports Let's Encrypt certificates on Linux.\n\n\nChanges in CUPS v2.2b1\n----------------------\n\n- All CUPS commands now support POSIX options (Issue #4813)\n- The scheduler now restarts faster (Issue #4760)\n- Improved performance of web interface with large numbers of jobs (Issue #3819)\n- Encrypted printing can now be limited to only trusted printers and servers\n  (<rdar://problem/25711658>)\n- The scheduler now advertises PWG Raster attributes for IPP Everywhere clients\n  (Issue #4428)\n- The scheduler now logs informational messages for jobs at LogLevel \"info\"\n  (Issue #4815)\n- The scheduler now uses the getgrouplist function when available (Issue #4611)\n- The IPP backend no longer enables compression by default except for certain\n  raster formats that generally benefit from it (<rdar://problem/25166952>)\n- The scheduler did not handle out-of-disk situations gracefully (Issue #4742)\n- The LPD mini-daemon now detects invalid UTF-8 sequences in job, document, and\n  user names (Issue #4748)\n- The IPP backend now continues on to the next job when the remote server/\n  printer puts the job on hold (<rdar://problem/24858548>)\n- The scheduler did not cancel multi-document jobs immediately\n  (<rdar://problem/24854834>)\n- The scheduler did not return non-shared printers to local clients unless they\n  connected to the domain socket (<rdar://problem/24566996>)\n- The scheduler now reads the spool directory if one or more job cache entries\n  point to deleted jobs (<rdar://problem/24048846>)\n- Added support for disc media sizes (<rdar://problem/20219536>)\n- The httpAddrConnect and httpConnect* APIs now try connecting to multiple\n  addresses in parallel (<rdar://problem/20643153>)\n- The cupsd domain socket is no longer world-accessible on macOS\n  (<rdar://problem/7542560>)\n- Interface scripts are no longer supported for security reasons\n  (<rdar://problem/23135640>)\n- Added a new cupsHashData API and support for hashed job passwords\n  (<rdar://problem/20221502>)\n- Localization fixes (<rdar://problem/25292403>, <rdar://problem/25461517>,\n  Issue #4041, Issue #4796)\n- Documentation changes (Issue #4624, Issue #4781)\n- Packaging fixes (PR #4832)\n", "/*\n * IPP routines for the CUPS scheduler.\n *\n * Copyright 2007-2016 by Apple Inc.\n * Copyright 1997-2007 by Easy Software Products, all rights reserved.\n *\n * This file contains Kerberos support code, copyright 2006 by\n * Jelmer Vernooij.\n *\n * These coded instructions, statements, and computer programs are the\n * property of Apple Inc. and are protected by Federal copyright\n * law.  Distribution and use rights are outlined in the file \"LICENSE.txt\"\n * which should have been included with this file.  If this file is\n * missing or damaged, see the license at \"http://www.cups.org/\".\n */\n\n/*\n * Include necessary headers...\n */\n\n#include \"cupsd.h\"\n#include <cups/ppd-private.h>\n\n#ifdef __APPLE__\n/*#  include <ApplicationServices/ApplicationServices.h>\nextern CFUUIDRef ColorSyncCreateUUIDFromUInt32(unsigned id);\n#  include <CoreFoundation/CoreFoundation.h>*/\n#  ifdef HAVE_MEMBERSHIP_H\n#    include <membership.h>\n#  endif /* HAVE_MEMBERSHIP_H */\n#  ifdef HAVE_MEMBERSHIPPRIV_H\n#    include <membershipPriv.h>\n#  else\nextern int mbr_user_name_to_uuid(const char* name, uuid_t uu);\nextern int mbr_group_name_to_uuid(const char* name, uuid_t uu);\nextern int mbr_check_membership_by_id(uuid_t user, gid_t group, int* ismember);\n#  endif /* HAVE_MEMBERSHIPPRIV_H */\n#endif /* __APPLE__ */\n\n\n/*\n * Local functions...\n */\n\nstatic void\taccept_jobs(cupsd_client_t *con, ipp_attribute_t *uri);\nstatic void\tadd_class(cupsd_client_t *con, ipp_attribute_t *uri);\nstatic int\tadd_file(cupsd_client_t *con, cupsd_job_t *job,\n\t\t         mime_type_t *filetype, int compression);\nstatic cupsd_job_t *add_job(cupsd_client_t *con, cupsd_printer_t *printer,\n\t\t\t    mime_type_t *filetype);\nstatic void\tadd_job_subscriptions(cupsd_client_t *con, cupsd_job_t *job);\nstatic void\tadd_job_uuid(cupsd_job_t *job);\nstatic void\tadd_printer(cupsd_client_t *con, ipp_attribute_t *uri);\nstatic void\tadd_printer_state_reasons(cupsd_client_t *con,\n\t\t                          cupsd_printer_t *p);\nstatic void\tadd_queued_job_count(cupsd_client_t *con, cupsd_printer_t *p);\nstatic void\tapply_printer_defaults(cupsd_printer_t *printer,\n\t\t\t\t       cupsd_job_t *job);\nstatic void\tauthenticate_job(cupsd_client_t *con, ipp_attribute_t *uri);\nstatic void\tcancel_all_jobs(cupsd_client_t *con, ipp_attribute_t *uri);\nstatic void\tcancel_job(cupsd_client_t *con, ipp_attribute_t *uri);\nstatic void\tcancel_subscription(cupsd_client_t *con, int id);\nstatic int\tcheck_rss_recipient(const char *recipient);\nstatic int\tcheck_quotas(cupsd_client_t *con, cupsd_printer_t *p);\nstatic void\tclose_job(cupsd_client_t *con, ipp_attribute_t *uri);\nstatic void\tcopy_attrs(ipp_t *to, ipp_t *from, cups_array_t *ra,\n\t\t           ipp_tag_t group, int quickcopy,\n\t\t\t   cups_array_t *exclude);\nstatic int\tcopy_banner(cupsd_client_t *con, cupsd_job_t *job,\n\t\t            const char *name);\nstatic int\tcopy_file(const char *from, const char *to, mode_t mode);\nstatic int\tcopy_model(cupsd_client_t *con, const char *from,\n\t\t           const char *to);\nstatic void\tcopy_job_attrs(cupsd_client_t *con,\n\t\t               cupsd_job_t *job,\n\t\t\t       cups_array_t *ra, cups_array_t *exclude);\nstatic void\tcopy_printer_attrs(cupsd_client_t *con,\n\t\t                   cupsd_printer_t *printer,\n\t\t\t\t   cups_array_t *ra);\nstatic void\tcopy_subscription_attrs(cupsd_client_t *con,\n\t\t                        cupsd_subscription_t *sub,\n\t\t\t\t\tcups_array_t *ra,\n\t\t\t\t\tcups_array_t *exclude);\nstatic void\tcreate_job(cupsd_client_t *con, ipp_attribute_t *uri);\nstatic void\tcreate_local_printer(cupsd_client_t *con);\nstatic cups_array_t *create_requested_array(ipp_t *request);\nstatic void\tcreate_subscriptions(cupsd_client_t *con, ipp_attribute_t *uri);\nstatic void\tdelete_printer(cupsd_client_t *con, ipp_attribute_t *uri);\nstatic void\tget_default(cupsd_client_t *con);\nstatic void\tget_devices(cupsd_client_t *con);\nstatic void\tget_document(cupsd_client_t *con, ipp_attribute_t *uri);\nstatic void\tget_jobs(cupsd_client_t *con, ipp_attribute_t *uri);\nstatic void\tget_job_attrs(cupsd_client_t *con, ipp_attribute_t *uri);\nstatic void\tget_notifications(cupsd_client_t *con);\nstatic void\tget_ppd(cupsd_client_t *con, ipp_attribute_t *uri);\nstatic void\tget_ppds(cupsd_client_t *con);\nstatic void\tget_printers(cupsd_client_t *con, int type);\nstatic void\tget_printer_attrs(cupsd_client_t *con, ipp_attribute_t *uri);\nstatic void\tget_printer_supported(cupsd_client_t *con, ipp_attribute_t *uri);\nstatic void\tget_subscription_attrs(cupsd_client_t *con, int sub_id);\nstatic void\tget_subscriptions(cupsd_client_t *con, ipp_attribute_t *uri);\nstatic const char *get_username(cupsd_client_t *con);\nstatic void\thold_job(cupsd_client_t *con, ipp_attribute_t *uri);\nstatic void\thold_new_jobs(cupsd_client_t *con, ipp_attribute_t *uri);\nstatic void\tmove_job(cupsd_client_t *con, ipp_attribute_t *uri);\nstatic int\tppd_parse_line(const char *line, char *option, int olen,\n\t\t               char *choice, int clen);\nstatic void\tprint_job(cupsd_client_t *con, ipp_attribute_t *uri);\nstatic void\tread_job_ticket(cupsd_client_t *con);\nstatic void\treject_jobs(cupsd_client_t *con, ipp_attribute_t *uri);\nstatic void\trelease_held_new_jobs(cupsd_client_t *con,\n\t\t                      ipp_attribute_t *uri);\nstatic void\trelease_job(cupsd_client_t *con, ipp_attribute_t *uri);\nstatic void\trenew_subscription(cupsd_client_t *con, int sub_id);\nstatic void\trestart_job(cupsd_client_t *con, ipp_attribute_t *uri);\nstatic void\tsave_auth_info(cupsd_client_t *con, cupsd_job_t *job,\n\t\t               ipp_attribute_t *auth_info);\nstatic void\tsend_document(cupsd_client_t *con, ipp_attribute_t *uri);\nstatic void\tsend_http_error(cupsd_client_t *con, http_status_t status,\n\t\t                cupsd_printer_t *printer);\nstatic void\tsend_ipp_status(cupsd_client_t *con, ipp_status_t status,\n\t\t                const char *message, ...)\n\t\t__attribute__((__format__(__printf__, 3, 4)));\nstatic void\tset_default(cupsd_client_t *con, ipp_attribute_t *uri);\nstatic void\tset_job_attrs(cupsd_client_t *con, ipp_attribute_t *uri);\nstatic void\tset_printer_attrs(cupsd_client_t *con, ipp_attribute_t *uri);\nstatic int\tset_printer_defaults(cupsd_client_t *con, cupsd_printer_t *printer);\nstatic void\tstart_printer(cupsd_client_t *con, ipp_attribute_t *uri);\nstatic void\tstop_printer(cupsd_client_t *con, ipp_attribute_t *uri);\nstatic void\turl_encode_attr(ipp_attribute_t *attr, char *buffer, size_t bufsize);\nstatic char\t*url_encode_string(const char *s, char *buffer, size_t bufsize);\nstatic int\tuser_allowed(cupsd_printer_t *p, const char *username);\nstatic void\tvalidate_job(cupsd_client_t *con, ipp_attribute_t *uri);\nstatic int\tvalidate_name(const char *name);\nstatic int\tvalidate_user(cupsd_job_t *job, cupsd_client_t *con, const char *owner, char *username, size_t userlen);\n\n\n/*\n * 'cupsdProcessIPPRequest()' - Process an incoming IPP request.\n */\n\nint\t\t\t\t\t/* O - 1 on success, 0 on failure */\ncupsdProcessIPPRequest(\n    cupsd_client_t *con)\t\t/* I - Client connection */\n{\n  ipp_tag_t\t\tgroup;\t\t/* Current group tag */\n  ipp_attribute_t\t*attr;\t\t/* Current attribute */\n  ipp_attribute_t\t*charset;\t/* Character set attribute */\n  ipp_attribute_t\t*language;\t/* Language attribute */\n  ipp_attribute_t\t*uri = NULL;\t/* Printer or job URI attribute */\n  ipp_attribute_t\t*username;\t/* requesting-user-name attr */\n  int\t\t\tsub_id;\t\t/* Subscription ID */\n\n\n  cupsdLogMessage(CUPSD_LOG_DEBUG2, \"cupsdProcessIPPRequest(%p[%d]): operation_id=%04x(%s)\", con, con->number, con->request->request.op.operation_id, ippOpString(con->request->request.op.operation_id));\n\n  if (LogLevel >= CUPSD_LOG_DEBUG2)\n  {\n    for (group = IPP_TAG_ZERO, attr = ippFirstAttribute(con->request); attr; attr = ippNextAttribute(con->request))\n    {\n      const char  *name;                /* Attribute name */\n      char        value[1024];          /* Attribute value */\n\n      if (group != ippGetGroupTag(attr))\n      {\n        group = ippGetGroupTag(attr);\n        if (group != IPP_TAG_ZERO)\n          cupsdLogMessage(CUPSD_LOG_DEBUG2, \"cupsdProcessIPPRequest: %s\", ippTagString(group));\n      }\n\n      if ((name = ippGetName(attr)) == NULL)\n        continue;\n\n      ippAttributeString(attr, value, sizeof(value));\n\n      cupsdLogMessage(CUPSD_LOG_DEBUG2, \"cupsdProcessIPPRequest: %s %s%s '%s'\", name, ippGetCount(attr) > 1 ? \"1setOf \" : \"\", ippTagString(ippGetValueTag(attr)), value);\n    }\n  }\n\n /*\n  * First build an empty response message for this request...\n  */\n\n  con->response = ippNew();\n\n  con->response->request.status.version[0] =\n      con->request->request.op.version[0];\n  con->response->request.status.version[1] =\n      con->request->request.op.version[1];\n  con->response->request.status.request_id =\n      con->request->request.op.request_id;\n\n /*\n  * Then validate the request header and required attributes...\n  */\n\n  if (con->request->request.any.version[0] != 1 &&\n      con->request->request.any.version[0] != 2)\n  {\n   /*\n    * Return an error, since we only support IPP 1.x and 2.x.\n    */\n\n    cupsdAddEvent(CUPSD_EVENT_SERVER_AUDIT, NULL, NULL,\n                  \"%04X %s Bad request version number %d.%d\",\n\t\t  IPP_VERSION_NOT_SUPPORTED, con->http->hostname,\n                  con->request->request.any.version[0],\n\t          con->request->request.any.version[1]);\n\n    send_ipp_status(con, IPP_VERSION_NOT_SUPPORTED,\n                    _(\"Bad request version number %d.%d.\"),\n\t\t    con->request->request.any.version[0],\n\t            con->request->request.any.version[1]);\n  }\n  else if (con->request->request.any.request_id < 1)\n  {\n   /*\n    * Return an error, since request IDs must be between 1 and 2^31-1\n    */\n\n    cupsdAddEvent(CUPSD_EVENT_SERVER_AUDIT, NULL, NULL,\n                  \"%04X %s Bad request ID %d\",\n\t\t  IPP_BAD_REQUEST, con->http->hostname,\n                  con->request->request.any.request_id);\n\n    send_ipp_status(con, IPP_BAD_REQUEST, _(\"Bad request ID %d.\"),\n\t\t    con->request->request.any.request_id);\n  }\n  else if (!con->request->attrs)\n  {\n    cupsdAddEvent(CUPSD_EVENT_SERVER_AUDIT, NULL, NULL,\n                  \"%04X %s No attributes in request\",\n\t\t  IPP_BAD_REQUEST, con->http->hostname);\n\n    send_ipp_status(con, IPP_BAD_REQUEST, _(\"No attributes in request.\"));\n  }\n  else\n  {\n   /*\n    * Make sure that the attributes are provided in the correct order and\n    * don't repeat groups...\n    */\n\n    for (attr = con->request->attrs, group = attr->group_tag;\n\t attr;\n\t attr = attr->next)\n      if (attr->group_tag < group && attr->group_tag != IPP_TAG_ZERO)\n      {\n       /*\n\t* Out of order; return an error...\n\t*/\n\n\tcupsdAddEvent(CUPSD_EVENT_SERVER_AUDIT, NULL, NULL,\n                      \"%04X %s Attribute groups are out of order\",\n\t\t      IPP_BAD_REQUEST, con->http->hostname);\n\n\tsend_ipp_status(con, IPP_BAD_REQUEST,\n\t                _(\"Attribute groups are out of order (%x < %x).\"),\n\t\t\tattr->group_tag, group);\n\tbreak;\n      }\n      else\n\tgroup = attr->group_tag;\n\n    if (!attr)\n    {\n     /*\n      * Then make sure that the first three attributes are:\n      *\n      *     attributes-charset\n      *     attributes-natural-language\n      *     printer-uri/job-uri\n      */\n\n      attr = con->request->attrs;\n      if (attr && attr->name &&\n          !strcmp(attr->name, \"attributes-charset\") &&\n\t  (attr->value_tag & IPP_TAG_MASK) == IPP_TAG_CHARSET)\n\tcharset = attr;\n      else\n\tcharset = NULL;\n\n      if (attr)\n        attr = attr->next;\n\n      if (attr && attr->name &&\n          !strcmp(attr->name, \"attributes-natural-language\") &&\n\t  (attr->value_tag & IPP_TAG_MASK) == IPP_TAG_LANGUAGE)\n      {\n\tlanguage = attr;\n\n       /*\n        * Reset language for this request if different from Accept-Language.\n        */\n\n\tif (!con->language ||\n\t    strcmp(attr->values[0].string.text, con->language->language))\n\t{\n\t  cupsLangFree(con->language);\n\t  con->language = cupsLangGet(attr->values[0].string.text);\n\t}\n      }\n      else\n\tlanguage = NULL;\n\n      if ((attr = ippFindAttribute(con->request, \"printer-uri\",\n                                   IPP_TAG_URI)) != NULL)\n\turi = attr;\n      else if ((attr = ippFindAttribute(con->request, \"job-uri\",\n                                        IPP_TAG_URI)) != NULL)\n\turi = attr;\n      else if (con->request->request.op.operation_id == CUPS_GET_PPD)\n        uri = ippFindAttribute(con->request, \"ppd-name\", IPP_TAG_NAME);\n      else\n\turi = NULL;\n\n      if (charset)\n\tippAddString(con->response, IPP_TAG_OPERATION, IPP_TAG_CHARSET,\n        \t     \"attributes-charset\", NULL,\n\t\t     charset->values[0].string.text);\n      else\n\tippAddString(con->response, IPP_TAG_OPERATION, IPP_TAG_CHARSET,\n        \t     \"attributes-charset\", NULL, \"utf-8\");\n\n      if (language)\n\tippAddString(con->response, IPP_TAG_OPERATION, IPP_TAG_LANGUAGE,\n                     \"attributes-natural-language\", NULL,\n\t\t     language->values[0].string.text);\n      else\n\tippAddString(con->response, IPP_TAG_OPERATION, IPP_TAG_LANGUAGE,\n                     \"attributes-natural-language\", NULL, DefaultLanguage);\n\n      if (charset &&\n          _cups_strcasecmp(charset->values[0].string.text, \"us-ascii\") &&\n          _cups_strcasecmp(charset->values[0].string.text, \"utf-8\"))\n      {\n       /*\n        * Bad character set...\n\t*/\n\n        cupsdLogMessage(CUPSD_LOG_ERROR, \"Unsupported character set \\\"%s\\\"\",\n\t                charset->values[0].string.text);\n\tcupsdAddEvent(CUPSD_EVENT_SERVER_AUDIT, NULL, NULL,\n\t\t      \"%04X %s Unsupported attributes-charset value \\\"%s\\\"\",\n\t\t      IPP_CHARSET, con->http->hostname,\n\t\t      charset->values[0].string.text);\n\tsend_ipp_status(con, IPP_BAD_REQUEST,\n\t                _(\"Unsupported character set \\\"%s\\\".\"),\n\t                charset->values[0].string.text);\n      }\n      else if (!charset || !language ||\n\t       (!uri &&\n\t        con->request->request.op.operation_id != CUPS_GET_DEFAULT &&\n\t        con->request->request.op.operation_id != CUPS_GET_PRINTERS &&\n\t        con->request->request.op.operation_id != CUPS_GET_CLASSES &&\n\t        con->request->request.op.operation_id != CUPS_GET_DEVICES &&\n\t        con->request->request.op.operation_id != CUPS_GET_PPDS))\n      {\n       /*\n\t* Return an error, since attributes-charset,\n\t* attributes-natural-language, and printer-uri/job-uri are required\n\t* for all operations.\n\t*/\n\n        if (!charset)\n\t{\n\t  cupsdLogMessage(CUPSD_LOG_ERROR,\n\t                  \"Missing attributes-charset attribute\");\n\n\t  cupsdAddEvent(CUPSD_EVENT_SERVER_AUDIT, NULL, NULL,\n                \t\"%04X %s Missing attributes-charset attribute\",\n\t\t\tIPP_BAD_REQUEST, con->http->hostname);\n        }\n\n        if (!language)\n\t{\n\t  cupsdLogMessage(CUPSD_LOG_ERROR,\n\t                  \"Missing attributes-natural-language attribute\");\n\n\t  cupsdAddEvent(CUPSD_EVENT_SERVER_AUDIT, NULL, NULL,\n                \t\"%04X %s Missing attributes-natural-language attribute\",\n\t\t\tIPP_BAD_REQUEST, con->http->hostname);\n        }\n\n        if (!uri)\n\t{\n\t  cupsdLogMessage(CUPSD_LOG_ERROR,\n\t                  \"Missing printer-uri, job-uri, or ppd-name \"\n\t\t\t  \"attribute\");\n\n\t  cupsdAddEvent(CUPSD_EVENT_SERVER_AUDIT, NULL, NULL,\n                \t\"%04X %s Missing printer-uri, job-uri, or ppd-name \"\n\t\t\t\"attribute\", IPP_BAD_REQUEST, con->http->hostname);\n        }\n\n\tcupsdLogMessage(CUPSD_LOG_DEBUG, \"Request attributes follow...\");\n\n\tfor (attr = con->request->attrs; attr; attr = attr->next)\n\t  cupsdLogMessage(CUPSD_LOG_DEBUG,\n\t        \t  \"attr \\\"%s\\\": group_tag = %x, value_tag = %x\",\n\t        \t  attr->name ? attr->name : \"(null)\", attr->group_tag,\n\t\t\t  attr->value_tag);\n\n\tcupsdLogMessage(CUPSD_LOG_DEBUG, \"End of attributes...\");\n\n\tsend_ipp_status(con, IPP_BAD_REQUEST,\n\t                _(\"Missing required attributes.\"));\n      }\n      else\n      {\n       /*\n\t* OK, all the checks pass so far; make sure requesting-user-name is\n\t* not \"root\" from a remote host...\n\t*/\n\n        if ((username = ippFindAttribute(con->request, \"requesting-user-name\",\n\t                                 IPP_TAG_NAME)) != NULL)\n\t{\n\t /*\n\t  * Check for root user...\n\t  */\n\n\t  if (!strcmp(username->values[0].string.text, \"root\") &&\n\t      _cups_strcasecmp(con->http->hostname, \"localhost\") &&\n\t      strcmp(con->username, \"root\"))\n\t  {\n\t   /*\n\t    * Remote unauthenticated user masquerading as local root...\n\t    */\n\n            ippSetString(con->request, &username, 0, RemoteRoot);\n\t  }\n\t}\n\n        if ((attr = ippFindAttribute(con->request, \"notify-subscription-id\",\n\t                             IPP_TAG_INTEGER)) != NULL)\n\t  sub_id = attr->values[0].integer;\n\telse\n\t  sub_id = 0;\n\n       /*\n        * Then try processing the operation...\n\t*/\n\n        if (uri)\n\t  cupsdLogMessage(CUPSD_LOG_DEBUG, \"%s %s\",\n                \t  ippOpString(con->request->request.op.operation_id),\n\t\t\t  uri->values[0].string.text);\n        else\n\t  cupsdLogMessage(CUPSD_LOG_DEBUG, \"%s\",\n                \t  ippOpString(con->request->request.op.operation_id));\n\n\tswitch (con->request->request.op.operation_id)\n\t{\n\t  case IPP_OP_PRINT_JOB :\n              print_job(con, uri);\n              break;\n\n\t  case IPP_OP_VALIDATE_JOB :\n              validate_job(con, uri);\n              break;\n\n\t  case IPP_OP_CREATE_JOB :\n              create_job(con, uri);\n              break;\n\n\t  case IPP_OP_SEND_DOCUMENT :\n              send_document(con, uri);\n              break;\n\n\t  case IPP_OP_CANCEL_JOB :\n              cancel_job(con, uri);\n              break;\n\n\t  case IPP_OP_GET_JOB_ATTRIBUTES :\n              get_job_attrs(con, uri);\n              break;\n\n\t  case IPP_OP_GET_JOBS :\n              get_jobs(con, uri);\n              break;\n\n\t  case IPP_OP_GET_PRINTER_ATTRIBUTES :\n              get_printer_attrs(con, uri);\n              break;\n\n\t  case IPP_OP_GET_PRINTER_SUPPORTED_VALUES :\n              get_printer_supported(con, uri);\n              break;\n\n\t  case IPP_OP_HOLD_JOB :\n              hold_job(con, uri);\n              break;\n\n\t  case IPP_OP_RELEASE_JOB :\n              release_job(con, uri);\n              break;\n\n\t  case IPP_OP_RESTART_JOB :\n              restart_job(con, uri);\n              break;\n\n\t  case IPP_OP_PAUSE_PRINTER :\n              stop_printer(con, uri);\n\t      break;\n\n\t  case IPP_OP_RESUME_PRINTER :\n              start_printer(con, uri);\n\t      break;\n\n\t  case IPP_OP_PURGE_JOBS :\n\t  case IPP_OP_CANCEL_JOBS :\n\t  case IPP_OP_CANCEL_MY_JOBS :\n              cancel_all_jobs(con, uri);\n              break;\n\n\t  case IPP_OP_SET_JOB_ATTRIBUTES :\n              set_job_attrs(con, uri);\n              break;\n\n\t  case IPP_OP_SET_PRINTER_ATTRIBUTES :\n              set_printer_attrs(con, uri);\n              break;\n\n\t  case IPP_OP_HOLD_NEW_JOBS :\n              hold_new_jobs(con, uri);\n              break;\n\n\t  case IPP_OP_RELEASE_HELD_NEW_JOBS :\n              release_held_new_jobs(con, uri);\n              break;\n\n\t  case IPP_OP_CLOSE_JOB :\n              close_job(con, uri);\n              break;\n\n\t  case IPP_OP_CUPS_GET_DEFAULT :\n              get_default(con);\n              break;\n\n\t  case IPP_OP_CUPS_GET_PRINTERS :\n              get_printers(con, 0);\n              break;\n\n\t  case IPP_OP_CUPS_GET_CLASSES :\n              get_printers(con, CUPS_PRINTER_CLASS);\n              break;\n\n\t  case IPP_OP_CUPS_ADD_MODIFY_PRINTER :\n              add_printer(con, uri);\n              break;\n\n\t  case IPP_OP_CUPS_DELETE_PRINTER :\n              delete_printer(con, uri);\n              break;\n\n\t  case IPP_OP_CUPS_ADD_MODIFY_CLASS :\n              add_class(con, uri);\n              break;\n\n\t  case IPP_OP_CUPS_DELETE_CLASS :\n              delete_printer(con, uri);\n              break;\n\n\t  case IPP_OP_CUPS_ACCEPT_JOBS :\n\t  case IPP_OP_ENABLE_PRINTER :\n              accept_jobs(con, uri);\n              break;\n\n\t  case IPP_OP_CUPS_REJECT_JOBS :\n\t  case IPP_OP_DISABLE_PRINTER :\n              reject_jobs(con, uri);\n              break;\n\n\t  case IPP_OP_CUPS_SET_DEFAULT :\n              set_default(con, uri);\n              break;\n\n\t  case IPP_OP_CUPS_GET_DEVICES :\n              get_devices(con);\n              break;\n\n          case IPP_OP_CUPS_GET_DOCUMENT :\n\t      get_document(con, uri);\n\t      break;\n\n\t  case IPP_OP_CUPS_GET_PPD :\n              get_ppd(con, uri);\n              break;\n\n\t  case IPP_OP_CUPS_GET_PPDS :\n              get_ppds(con);\n              break;\n\n\t  case IPP_OP_CUPS_MOVE_JOB :\n              move_job(con, uri);\n              break;\n\n\t  case IPP_OP_CUPS_AUTHENTICATE_JOB :\n              authenticate_job(con, uri);\n              break;\n\n          case IPP_OP_CREATE_PRINTER_SUBSCRIPTIONS :\n\t  case IPP_OP_CREATE_JOB_SUBSCRIPTIONS :\n\t      create_subscriptions(con, uri);\n\t      break;\n\n          case IPP_OP_GET_SUBSCRIPTION_ATTRIBUTES :\n\t      get_subscription_attrs(con, sub_id);\n\t      break;\n\n\t  case IPP_OP_GET_SUBSCRIPTIONS :\n\t      get_subscriptions(con, uri);\n\t      break;\n\n\t  case IPP_OP_RENEW_SUBSCRIPTION :\n\t      renew_subscription(con, sub_id);\n\t      break;\n\n\t  case IPP_OP_CANCEL_SUBSCRIPTION :\n\t      cancel_subscription(con, sub_id);\n\t      break;\n\n          case IPP_OP_GET_NOTIFICATIONS :\n\t      get_notifications(con);\n\t      break;\n\n\t  case IPP_OP_CUPS_CREATE_LOCAL_PRINTER :\n\t      create_local_printer(con);\n\t      break;\n\n\t  default :\n\t      cupsdAddEvent(CUPSD_EVENT_SERVER_AUDIT, NULL, NULL,\n                \t    \"%04X %s Operation %04X (%s) not supported\",\n\t\t\t    IPP_OPERATION_NOT_SUPPORTED, con->http->hostname,\n\t\t\t    con->request->request.op.operation_id,\n\t\t\t    ippOpString(con->request->request.op.operation_id));\n\n              send_ipp_status(con, IPP_OPERATION_NOT_SUPPORTED,\n\t                      _(\"%s not supported.\"),\n\t\t\t      ippOpString(\n\t\t\t          con->request->request.op.operation_id));\n\t      break;\n\t}\n      }\n    }\n  }\n\n  if (con->response)\n  {\n   /*\n    * Sending data from the scheduler...\n    */\n\n    cupsdLogMessage(con->response->request.status.status_code\n                        >= IPP_BAD_REQUEST &&\n                    con->response->request.status.status_code\n\t\t        != IPP_NOT_FOUND ? CUPSD_LOG_ERROR : CUPSD_LOG_DEBUG,\n                    \"[Client %d] Returning IPP %s for %s (%s) from %s\",\n\t            con->number,\n\t            ippErrorString(con->response->request.status.status_code),\n\t\t    ippOpString(con->request->request.op.operation_id),\n\t\t    uri ? uri->values[0].string.text : \"no URI\",\n\t\t    con->http->hostname);\n\n    httpClearFields(con->http);\n\n#ifdef CUPSD_USE_CHUNKING\n   /*\n    * Because older versions of CUPS (1.1.17 and older) and some IPP\n    * clients do not implement chunking properly, we cannot use\n    * chunking by default.  This may become the default in future\n    * CUPS releases, or we might add a configuration directive for\n    * it.\n    */\n\n    if (con->http->version == HTTP_1_1)\n    {\n      cupsdLogMessage(CUPSD_LOG_DEBUG,\n\t\t      \"[Client %d] Transfer-Encoding: chunked\",\n\t\t      con->number);\n\n      cupsdSetLength(con->http, 0);\n    }\n    else\n#endif /* CUPSD_USE_CHUNKING */\n    {\n      size_t\tlength;\t\t\t/* Length of response */\n\n\n      length = ippLength(con->response);\n\n      if (con->file >= 0 && !con->pipe_pid)\n      {\n\tstruct stat\tfileinfo;\t/* File information */\n\n\tif (!fstat(con->file, &fileinfo))\n\t  length += (size_t)fileinfo.st_size;\n      }\n\n      cupsdLogMessage(CUPSD_LOG_DEBUG,\n\t\t      \"[Client %d] Content-Length: \" CUPS_LLFMT,\n\t\t      con->number, CUPS_LLCAST length);\n      httpSetLength(con->http, length);\n    }\n\n    if (cupsdSendHeader(con, HTTP_OK, \"application/ipp\", CUPSD_AUTH_NONE))\n    {\n     /*\n      * Tell the caller the response header was sent successfully...\n      */\n\n      cupsdAddSelect(httpGetFd(con->http), (cupsd_selfunc_t)cupsdReadClient,\n\t\t     (cupsd_selfunc_t)cupsdWriteClient, con);\n\n      return (1);\n    }\n    else\n    {\n     /*\n      * Tell the caller the response header could not be sent...\n      */\n\n      return (0);\n    }\n  }\n  else\n  {\n   /*\n    * Sending data from a subprocess like cups-deviced; tell the caller\n    * everything is A-OK so far...\n    */\n\n    return (1);\n  }\n}\n\n\n/*\n * 'cupsdTimeoutJob()' - Timeout a job waiting on job files.\n */\n\nint\t\t\t\t\t/* O - 0 on success, -1 on error */\ncupsdTimeoutJob(cupsd_job_t *job)\t/* I - Job to timeout */\n{\n  cupsd_printer_t\t*printer;\t/* Destination printer or class */\n  ipp_attribute_t\t*attr;\t\t/* job-sheets attribute */\n  int\t\t\tkbytes;\t\t/* Kilobytes in banner */\n\n\n  job->pending_timeout = 0;\n\n /*\n  * See if we need to add the ending sheet...\n  */\n\n  if (!cupsdLoadJob(job))\n    return (-1);\n\n  printer = cupsdFindDest(job->dest);\n  attr    = ippFindAttribute(job->attrs, \"job-sheets\", IPP_TAG_NAME);\n\n  if (printer && !(printer->type & CUPS_PRINTER_REMOTE) &&\n      attr && attr->num_values > 1)\n  {\n   /*\n    * Yes...\n    */\n\n    cupsdLogJob(job, CUPSD_LOG_INFO, \"Adding end banner page \\\"%s\\\".\",\n                attr->values[1].string.text);\n\n    if ((kbytes = copy_banner(NULL, job, attr->values[1].string.text)) < 0)\n      return (-1);\n\n    cupsdUpdateQuota(printer, job->username, 0, kbytes);\n  }\n\n  return (0);\n}\n\n\n/*\n * 'accept_jobs()' - Accept print jobs to a printer.\n */\n\nstatic void\naccept_jobs(cupsd_client_t  *con,\t/* I - Client connection */\n            ipp_attribute_t *uri)\t/* I - Printer or class URI */\n{\n  http_status_t\tstatus;\t\t\t/* Policy status */\n  cups_ptype_t\tdtype;\t\t\t/* Destination type (printer/class) */\n  cupsd_printer_t *printer;\t\t/* Printer data */\n\n\n  cupsdLogMessage(CUPSD_LOG_DEBUG2, \"accept_jobs(%p[%d], %s)\", con,\n                  con->number, uri->values[0].string.text);\n\n /*\n  * Is the destination valid?\n  */\n\n  if (!cupsdValidateDest(uri->values[0].string.text, &dtype, &printer))\n  {\n   /*\n    * Bad URI...\n    */\n\n    send_ipp_status(con, IPP_NOT_FOUND,\n                    _(\"The printer or class does not exist.\"));\n    return;\n  }\n\n /*\n  * Check policy...\n  */\n\n  if ((status = cupsdCheckPolicy(printer->op_policy_ptr, con, NULL)) != HTTP_OK)\n  {\n    send_http_error(con, status, printer);\n    return;\n  }\n\n /*\n  * Accept jobs sent to the printer...\n  */\n\n  printer->accepting        = 1;\n  printer->state_message[0] = '\\0';\n\n  cupsdAddEvent(CUPSD_EVENT_PRINTER_STATE, printer, NULL,\n                \"Now accepting jobs.\");\n\n  if (dtype & CUPS_PRINTER_CLASS)\n  {\n    cupsdMarkDirty(CUPSD_DIRTY_CLASSES);\n\n    cupsdLogMessage(CUPSD_LOG_INFO, \"Class \\\"%s\\\" now accepting jobs (\\\"%s\\\").\",\n                    printer->name, get_username(con));\n  }\n  else\n  {\n    cupsdMarkDirty(CUPSD_DIRTY_PRINTERS);\n\n    cupsdLogMessage(CUPSD_LOG_INFO,\n                    \"Printer \\\"%s\\\" now accepting jobs (\\\"%s\\\").\",\n                    printer->name, get_username(con));\n  }\n\n /*\n  * Everything was ok, so return OK status...\n  */\n\n  con->response->request.status.status_code = IPP_OK;\n}\n\n\n/*\n * 'add_class()' - Add a class to the system.\n */\n\nstatic void\nadd_class(cupsd_client_t  *con,\t\t/* I - Client connection */\n          ipp_attribute_t *uri)\t\t/* I - URI of class */\n{\n  http_status_t\tstatus;\t\t\t/* Policy status */\n  int\t\ti;\t\t\t/* Looping var */\n  char\t\tscheme[HTTP_MAX_URI],\t/* Method portion of URI */\n\t\tusername[HTTP_MAX_URI],\t/* Username portion of URI */\n\t\thost[HTTP_MAX_URI],\t/* Host portion of URI */\n\t\tresource[HTTP_MAX_URI];\t/* Resource portion of URI */\n  int\t\tport;\t\t\t/* Port portion of URI */\n  cupsd_printer_t *pclass,\t\t/* Class */\n\t\t*member;\t\t/* Member printer/class */\n  cups_ptype_t\tdtype;\t\t\t/* Destination type */\n  ipp_attribute_t *attr;\t\t/* Printer attribute */\n  int\t\tmodify;\t\t\t/* Non-zero if we just modified */\n  int\t\tneed_restart_job;\t/* Need to restart job? */\n\n\n  cupsdLogMessage(CUPSD_LOG_DEBUG2, \"add_class(%p[%d], %s)\", con,\n                  con->number, uri->values[0].string.text);\n\n /*\n  * Do we have a valid URI?\n  */\n\n  httpSeparateURI(HTTP_URI_CODING_ALL, uri->values[0].string.text, scheme,\n                  sizeof(scheme), username, sizeof(username), host,\n\t\t  sizeof(host), &port, resource, sizeof(resource));\n\n\n  if (strncmp(resource, \"/classes/\", 9) || strlen(resource) == 9)\n  {\n   /*\n    * No, return an error...\n    */\n\n    send_ipp_status(con, IPP_BAD_REQUEST,\n                    _(\"The printer-uri must be of the form \"\n\t\t      \"\\\"ipp://HOSTNAME/classes/CLASSNAME\\\".\"));\n    return;\n  }\n\n /*\n  * Do we have a valid printer name?\n  */\n\n  if (!validate_name(resource + 9))\n  {\n   /*\n    * No, return an error...\n    */\n\n    send_ipp_status(con, IPP_BAD_REQUEST,\n                    _(\"The printer-uri \\\"%s\\\" contains invalid characters.\"),\n\t\t    uri->values[0].string.text);\n    return;\n  }\n\n /*\n  * See if the class already exists; if not, create a new class...\n  */\n\n  if ((pclass = cupsdFindClass(resource + 9)) == NULL)\n  {\n   /*\n    * Class doesn't exist; see if we have a printer of the same name...\n    */\n\n    if ((pclass = cupsdFindPrinter(resource + 9)) != NULL)\n    {\n     /*\n      * Yes, return an error...\n      */\n\n      send_ipp_status(con, IPP_NOT_POSSIBLE,\n                      _(\"A printer named \\\"%s\\\" already exists.\"),\n\t\t      resource + 9);\n      return;\n    }\n\n   /*\n    * No, check the default policy and then add the class...\n    */\n\n    if ((status = cupsdCheckPolicy(DefaultPolicyPtr, con, NULL)) != HTTP_OK)\n    {\n      send_http_error(con, status, NULL);\n      return;\n    }\n\n    pclass = cupsdAddClass(resource + 9);\n    modify = 0;\n  }\n  else if ((status = cupsdCheckPolicy(pclass->op_policy_ptr, con,\n                                      NULL)) != HTTP_OK)\n  {\n    send_http_error(con, status, pclass);\n    return;\n  }\n  else\n    modify = 1;\n\n /*\n  * Look for attributes and copy them over as needed...\n  */\n\n  need_restart_job = 0;\n\n  if ((attr = ippFindAttribute(con->request, \"printer-location\", IPP_TAG_TEXT)) != NULL)\n    cupsdSetString(&pclass->location, attr->values[0].string.text);\n\n  if ((attr = ippFindAttribute(con->request, \"printer-geo-location\", IPP_TAG_URI)) != NULL && !strncmp(attr->values[0].string.text, \"geo:\", 4))\n    cupsdSetString(&pclass->geo_location, attr->values[0].string.text);\n\n  if ((attr = ippFindAttribute(con->request, \"printer-organization\", IPP_TAG_TEXT)) != NULL)\n    cupsdSetString(&pclass->organization, attr->values[0].string.text);\n\n  if ((attr = ippFindAttribute(con->request, \"printer-organizational-unit\", IPP_TAG_TEXT)) != NULL)\n    cupsdSetString(&pclass->organizational_unit, attr->values[0].string.text);\n\n  if ((attr = ippFindAttribute(con->request, \"printer-info\",\n                               IPP_TAG_TEXT)) != NULL)\n    cupsdSetString(&pclass->info, attr->values[0].string.text);\n\n  if ((attr = ippFindAttribute(con->request, \"printer-is-accepting-jobs\",\n                               IPP_TAG_BOOLEAN)) != NULL &&\n      attr->values[0].boolean != pclass->accepting)\n  {\n    cupsdLogMessage(CUPSD_LOG_INFO,\n                    \"Setting %s printer-is-accepting-jobs to %d (was %d.)\",\n                    pclass->name, attr->values[0].boolean, pclass->accepting);\n\n    pclass->accepting = attr->values[0].boolean;\n\n    cupsdAddEvent(CUPSD_EVENT_PRINTER_STATE, pclass, NULL, \"%s accepting jobs.\",\n\t\t  pclass->accepting ? \"Now\" : \"No longer\");\n  }\n\n  if ((attr = ippFindAttribute(con->request, \"printer-is-shared\", IPP_TAG_BOOLEAN)) != NULL)\n  {\n    if (pclass->type & CUPS_PRINTER_REMOTE)\n    {\n     /*\n      * Cannot re-share remote printers.\n      */\n\n      send_ipp_status(con, IPP_BAD_REQUEST, _(\"Cannot change printer-is-shared for remote queues.\"));\n      if (!modify)\n\tcupsdDeletePrinter(pclass, 0);\n\n      return;\n    }\n\n    if (pclass->shared && !ippGetBoolean(attr, 0))\n      cupsdDeregisterPrinter(pclass, 1);\n\n    cupsdLogMessage(CUPSD_LOG_INFO,\n                    \"Setting %s printer-is-shared to %d (was %d.)\",\n                    pclass->name, attr->values[0].boolean, pclass->shared);\n\n    pclass->shared = ippGetBoolean(attr, 0);\n  }\n\n  if ((attr = ippFindAttribute(con->request, \"printer-state\",\n                               IPP_TAG_ENUM)) != NULL)\n  {\n    if (attr->values[0].integer != IPP_PRINTER_IDLE &&\n        attr->values[0].integer != IPP_PRINTER_STOPPED)\n    {\n      send_ipp_status(con, IPP_BAD_REQUEST,\n                      _(\"Attempt to set %s printer-state to bad value %d.\"),\n                      pclass->name, attr->values[0].integer);\n      if (!modify)\n\tcupsdDeletePrinter(pclass, 0);\n\n      return;\n    }\n\n    cupsdLogMessage(CUPSD_LOG_INFO, \"Setting %s printer-state to %d (was %d.)\",\n                    pclass->name, attr->values[0].integer, pclass->state);\n\n    if (attr->values[0].integer == IPP_PRINTER_STOPPED)\n      cupsdStopPrinter(pclass, 0);\n    else\n    {\n      cupsdSetPrinterState(pclass, (ipp_pstate_t)(attr->values[0].integer), 0);\n      need_restart_job = 1;\n    }\n  }\n  if ((attr = ippFindAttribute(con->request, \"printer-state-message\",\n                               IPP_TAG_TEXT)) != NULL)\n  {\n    strlcpy(pclass->state_message, attr->values[0].string.text,\n            sizeof(pclass->state_message));\n\n    cupsdAddEvent(CUPSD_EVENT_PRINTER_STATE, pclass, NULL, \"%s\",\n                  pclass->state_message);\n  }\n  if ((attr = ippFindAttribute(con->request, \"member-uris\",\n                               IPP_TAG_URI)) != NULL)\n  {\n   /*\n    * Clear the printer array as needed...\n    */\n\n    need_restart_job = 1;\n\n    if (pclass->num_printers > 0)\n    {\n      free(pclass->printers);\n      pclass->num_printers = 0;\n    }\n\n   /*\n    * Add each printer or class that is listed...\n    */\n\n    for (i = 0; i < attr->num_values; i ++)\n    {\n     /*\n      * Search for the printer or class URI...\n      */\n\n      if (!cupsdValidateDest(attr->values[i].string.text, &dtype, &member))\n      {\n       /*\n\t* Bad URI...\n\t*/\n\n\tsend_ipp_status(con, IPP_NOT_FOUND,\n                \t_(\"The printer or class does not exist.\"));\n\tif (!modify)\n\t  cupsdDeletePrinter(pclass, 0);\n\n\treturn;\n      }\n      else if (dtype & CUPS_PRINTER_CLASS)\n      {\n        send_ipp_status(con, IPP_BAD_REQUEST,\n\t\t\t_(\"Nested classes are not allowed.\"));\n\tif (!modify)\n\t  cupsdDeletePrinter(pclass, 0);\n\n        return;\n      }\n\n     /*\n      * Add it to the class...\n      */\n\n      cupsdAddPrinterToClass(pclass, member);\n    }\n  }\n\n  if (!set_printer_defaults(con, pclass))\n  {\n    if (!modify)\n      cupsdDeletePrinter(pclass, 0);\n\n    return;\n  }\n\n  if ((attr = ippFindAttribute(con->request, \"auth-info-required\",\n                               IPP_TAG_KEYWORD)) != NULL)\n    cupsdSetAuthInfoRequired(pclass, NULL, attr);\n\n  pclass->config_time = time(NULL);\n\n /*\n  * Update the printer class attributes and return...\n  */\n\n  cupsdSetPrinterAttrs(pclass);\n  cupsdMarkDirty(CUPSD_DIRTY_CLASSES);\n\n  if (need_restart_job && pclass->job)\n  {\n   /*\n    * Reset the current job to a \"pending\" status...\n    */\n\n    cupsdSetJobState(pclass->job, IPP_JOB_PENDING, CUPSD_JOB_FORCE,\n                     \"Job restarted because the class was modified.\");\n  }\n\n  cupsdMarkDirty(CUPSD_DIRTY_PRINTCAP);\n\n  if (modify)\n  {\n    cupsdAddEvent(CUPSD_EVENT_PRINTER_MODIFIED,\n\t\t  pclass, NULL, \"Class \\\"%s\\\" modified by \\\"%s\\\".\",\n\t\t  pclass->name, get_username(con));\n\n    cupsdLogMessage(CUPSD_LOG_INFO, \"Class \\\"%s\\\" modified by \\\"%s\\\".\",\n                    pclass->name, get_username(con));\n  }\n  else\n  {\n    cupsdAddEvent(CUPSD_EVENT_PRINTER_ADDED,\n\t\t  pclass, NULL, \"New class \\\"%s\\\" added by \\\"%s\\\".\",\n\t\t  pclass->name, get_username(con));\n\n    cupsdLogMessage(CUPSD_LOG_INFO, \"New class \\\"%s\\\" added by \\\"%s\\\".\",\n                    pclass->name, get_username(con));\n  }\n\n  con->response->request.status.status_code = IPP_OK;\n}\n\n\n/*\n * 'add_file()' - Add a file to a job.\n */\n\nstatic int\t\t\t\t/* O - 0 on success, -1 on error */\nadd_file(cupsd_client_t *con,\t\t/* I - Connection to client */\n         cupsd_job_t    *job,\t\t/* I - Job to add to */\n         mime_type_t    *filetype,\t/* I - Type of file */\n\t int            compression)\t/* I - Compression */\n{\n  mime_type_t\t**filetypes;\t\t/* New filetypes array... */\n  int\t\t*compressions;\t\t/* New compressions array... */\n\n\n  cupsdLogMessage(CUPSD_LOG_DEBUG2,\n        \t  \"add_file(con=%p[%d], job=%d, filetype=%s/%s, \"\n\t\t  \"compression=%d)\", con, con ? con->number : -1, job->id,\n\t\t  filetype->super, filetype->type, compression);\n\n /*\n  * Add the file to the job...\n  */\n\n  if (job->num_files == 0)\n  {\n    compressions = (int *)malloc(sizeof(int));\n    filetypes    = (mime_type_t **)malloc(sizeof(mime_type_t *));\n  }\n  else\n  {\n    compressions = (int *)realloc(job->compressions,\n                                  (size_t)(job->num_files + 1) * sizeof(int));\n    filetypes    = (mime_type_t **)realloc(job->filetypes,\n                                           (size_t)(job->num_files + 1) *\n\t\t\t\t\t   sizeof(mime_type_t *));\n  }\n\n  if (compressions)\n    job->compressions = compressions;\n\n  if (filetypes)\n    job->filetypes = filetypes;\n\n  if (!compressions || !filetypes)\n  {\n    cupsdSetJobState(job, IPP_JOB_ABORTED, CUPSD_JOB_PURGE,\n                     \"Job aborted because the scheduler ran out of memory.\");\n\n    if (con)\n      send_ipp_status(con, IPP_INTERNAL_ERROR,\n\t\t      _(\"Unable to allocate memory for file types.\"));\n\n    return (-1);\n  }\n\n  job->compressions[job->num_files] = compression;\n  job->filetypes[job->num_files]    = filetype;\n\n  job->num_files ++;\n\n  job->dirty = 1;\n  cupsdMarkDirty(CUPSD_DIRTY_JOBS);\n\n  return (0);\n}\n\n\n/*\n * 'add_job()' - Add a job to a print queue.\n */\n\nstatic cupsd_job_t *\t\t\t/* O - Job object */\nadd_job(cupsd_client_t  *con,\t\t/* I - Client connection */\n\tcupsd_printer_t *printer,\t/* I - Destination printer */\n\tmime_type_t     *filetype)\t/* I - First print file type, if any */\n{\n  http_status_t\tstatus;\t\t\t/* Policy status */\n  ipp_attribute_t *attr,\t\t/* Current attribute */\n\t\t*auth_info;\t\t/* auth-info attribute */\n  const char\t*mandatory;\t\t/* Current mandatory job attribute */\n  const char\t*val;\t\t\t/* Default option value */\n  int\t\tpriority;\t\t/* Job priority */\n  cupsd_job_t\t*job;\t\t\t/* Current job */\n  char\t\tjob_uri[HTTP_MAX_URI];\t/* Job URI */\n  int\t\tkbytes;\t\t\t/* Size of print file */\n  int\t\ti;\t\t\t/* Looping var */\n  int\t\tlowerpagerange;\t\t/* Page range bound */\n  int\t\texact;\t\t\t/* Did we have an exact match? */\n  ipp_attribute_t *media_col,\t\t/* media-col attribute */\n\t\t*media_margin;\t\t/* media-*-margin attribute */\n  ipp_t\t\t*unsup_col;\t\t/* media-col in unsupported response */\n  static const char * const readonly[] =/* List of read-only attributes */\n  {\n    \"date-time-at-completed\",\n    \"date-time-at-creation\",\n    \"date-time-at-processing\",\n    \"job-detailed-status-messages\",\n    \"job-document-access-errors\",\n    \"job-id\",\n    \"job-impressions-completed\",\n    \"job-k-octets-completed\",\n    \"job-media-sheets-completed\",\n    \"job-pages-completed\",\n    \"job-printer-up-time\",\n    \"job-printer-uri\",\n    \"job-state\",\n    \"job-state-message\",\n    \"job-state-reasons\",\n    \"job-uri\",\n    \"number-of-documents\",\n    \"number-of-intervening-jobs\",\n    \"output-device-assigned\",\n    \"time-at-completed\",\n    \"time-at-creation\",\n    \"time-at-processing\"\n  };\n\n\n  cupsdLogMessage(CUPSD_LOG_DEBUG2, \"add_job(%p[%d], %p(%s), %p(%s/%s))\",\n                  con, con->number, printer, printer->name,\n\t\t  filetype, filetype ? filetype->super : \"none\",\n\t\t  filetype ? filetype->type : \"none\");\n\n /*\n  * Check remote printing to non-shared printer...\n  */\n\n  if (!printer->shared &&\n      _cups_strcasecmp(con->http->hostname, \"localhost\") &&\n      _cups_strcasecmp(con->http->hostname, ServerName))\n  {\n    send_ipp_status(con, IPP_NOT_AUTHORIZED,\n                    _(\"The printer or class is not shared.\"));\n    return (NULL);\n  }\n\n /*\n  * Check policy...\n  */\n\n  auth_info = ippFindAttribute(con->request, \"auth-info\", IPP_TAG_TEXT);\n\n  if ((status = cupsdCheckPolicy(printer->op_policy_ptr, con, NULL)) != HTTP_OK)\n  {\n    send_http_error(con, status, printer);\n    return (NULL);\n  }\n  else if (printer->num_auth_info_required == 1 &&\n           !strcmp(printer->auth_info_required[0], \"negotiate\") &&\n           !con->username[0])\n  {\n    send_http_error(con, HTTP_UNAUTHORIZED, printer);\n    return (NULL);\n  }\n#ifdef HAVE_SSL\n  else if (auth_info && !con->http->tls &&\n           !httpAddrLocalhost(con->http->hostaddr))\n  {\n   /*\n    * Require encryption of auth-info over non-local connections...\n    */\n\n    send_http_error(con, HTTP_UPGRADE_REQUIRED, printer);\n    return (NULL);\n  }\n#endif /* HAVE_SSL */\n\n /*\n  * See if the printer is accepting jobs...\n  */\n\n  if (!printer->accepting)\n  {\n    send_ipp_status(con, IPP_NOT_ACCEPTING,\n                    _(\"Destination \\\"%s\\\" is not accepting jobs.\"),\n                    printer->name);\n    return (NULL);\n  }\n\n /*\n  * Validate job template attributes; for now just document-format,\n  * copies, job-sheets, number-up, page-ranges, mandatory attributes, and\n  * media...\n  */\n\n  for (i = 0; i < (int)(sizeof(readonly) / sizeof(readonly[0])); i ++)\n  {\n    if ((attr = ippFindAttribute(con->request, readonly[i], IPP_TAG_ZERO)) != NULL)\n    {\n      ippDeleteAttribute(con->request, attr);\n\n      if (StrictConformance)\n      {\n\tsend_ipp_status(con, IPP_BAD_REQUEST, _(\"The '%s' Job Status attribute cannot be supplied in a job creation request.\"), readonly[i]);\n\treturn (NULL);\n      }\n\n      cupsdLogMessage(CUPSD_LOG_INFO, \"Unexpected '%s' Job Status attribute in a job creation request.\", readonly[i]);\n    }\n  }\n\n  if (printer->pc)\n  {\n    for (mandatory = (char *)cupsArrayFirst(printer->pc->mandatory);\n\t mandatory;\n\t mandatory = (char *)cupsArrayNext(printer->pc->mandatory))\n    {\n      if (!ippFindAttribute(con->request, mandatory, IPP_TAG_ZERO))\n      {\n       /*\n\t* Missing a required attribute...\n\t*/\n\n\tsend_ipp_status(con, IPP_CONFLICT,\n\t\t\t_(\"The \\\"%s\\\" attribute is required for print jobs.\"),\n\t\t\tmandatory);\n\treturn (NULL);\n      }\n    }\n  }\n\n  if (filetype && printer->filetypes &&\n      !cupsArrayFind(printer->filetypes, filetype))\n  {\n    char\tmimetype[MIME_MAX_SUPER + MIME_MAX_TYPE + 2];\n\t\t\t\t\t/* MIME media type string */\n\n\n    snprintf(mimetype, sizeof(mimetype), \"%s/%s\", filetype->super,\n             filetype->type);\n\n    send_ipp_status(con, IPP_DOCUMENT_FORMAT,\n                    _(\"Unsupported format \\\"%s\\\".\"), mimetype);\n\n    ippAddString(con->response, IPP_TAG_UNSUPPORTED_GROUP, IPP_TAG_MIMETYPE,\n                 \"document-format\", NULL, mimetype);\n\n    return (NULL);\n  }\n\n  if ((attr = ippFindAttribute(con->request, \"copies\",\n                               IPP_TAG_INTEGER)) != NULL)\n  {\n    if (attr->values[0].integer < 1 || attr->values[0].integer > MaxCopies)\n    {\n      send_ipp_status(con, IPP_ATTRIBUTES, _(\"Bad copies value %d.\"),\n                      attr->values[0].integer);\n      ippAddInteger(con->response, IPP_TAG_UNSUPPORTED_GROUP, IPP_TAG_INTEGER,\n\t            \"copies\", attr->values[0].integer);\n      return (NULL);\n    }\n  }\n\n  if ((attr = ippFindAttribute(con->request, \"job-sheets\",\n                               IPP_TAG_ZERO)) != NULL)\n  {\n    if (attr->value_tag != IPP_TAG_KEYWORD &&\n        attr->value_tag != IPP_TAG_NAME)\n    {\n      send_ipp_status(con, IPP_BAD_REQUEST, _(\"Bad job-sheets value type.\"));\n      return (NULL);\n    }\n\n    if (attr->num_values > 2)\n    {\n      send_ipp_status(con, IPP_BAD_REQUEST,\n                      _(\"Too many job-sheets values (%d > 2).\"),\n\t\t      attr->num_values);\n      return (NULL);\n    }\n\n    for (i = 0; i < attr->num_values; i ++)\n      if (strcmp(attr->values[i].string.text, \"none\") &&\n          !cupsdFindBanner(attr->values[i].string.text))\n      {\n\tsend_ipp_status(con, IPP_BAD_REQUEST, _(\"Bad job-sheets value \\\"%s\\\".\"),\n\t\t\tattr->values[i].string.text);\n\treturn (NULL);\n      }\n  }\n\n  if ((attr = ippFindAttribute(con->request, \"number-up\",\n                               IPP_TAG_INTEGER)) != NULL)\n  {\n    if (attr->values[0].integer != 1 &&\n        attr->values[0].integer != 2 &&\n        attr->values[0].integer != 4 &&\n        attr->values[0].integer != 6 &&\n        attr->values[0].integer != 9 &&\n        attr->values[0].integer != 16)\n    {\n      send_ipp_status(con, IPP_ATTRIBUTES, _(\"Bad number-up value %d.\"),\n                      attr->values[0].integer);\n      ippAddInteger(con->response, IPP_TAG_UNSUPPORTED_GROUP, IPP_TAG_INTEGER,\n\t            \"number-up\", attr->values[0].integer);\n      return (NULL);\n    }\n  }\n\n  if ((attr = ippFindAttribute(con->request, \"page-ranges\",\n                               IPP_TAG_RANGE)) != NULL)\n  {\n    for (i = 0, lowerpagerange = 1; i < attr->num_values; i ++)\n    {\n      if (attr->values[i].range.lower < lowerpagerange ||\n\t  attr->values[i].range.lower > attr->values[i].range.upper)\n      {\n\tsend_ipp_status(con, IPP_BAD_REQUEST,\n\t                _(\"Bad page-ranges values %d-%d.\"),\n\t                attr->values[i].range.lower,\n\t\t\tattr->values[i].range.upper);\n\treturn (NULL);\n      }\n\n      lowerpagerange = attr->values[i].range.upper + 1;\n    }\n  }\n\n /*\n  * Do media selection as needed...\n  */\n\n  if (!ippFindAttribute(con->request, \"PageRegion\", IPP_TAG_ZERO) &&\n      !ippFindAttribute(con->request, \"PageSize\", IPP_TAG_ZERO) &&\n      _ppdCacheGetPageSize(printer->pc, con->request, NULL, &exact))\n  {\n    if (!exact &&\n        (media_col = ippFindAttribute(con->request, \"media-col\",\n\t                              IPP_TAG_BEGIN_COLLECTION)) != NULL)\n    {\n      send_ipp_status(con, IPP_OK_SUBST, _(\"Unsupported margins.\"));\n\n      unsup_col = ippNew();\n      if ((media_margin = ippFindAttribute(media_col->values[0].collection,\n                                           \"media-bottom-margin\",\n\t\t\t\t\t   IPP_TAG_INTEGER)) != NULL)\n        ippAddInteger(unsup_col, IPP_TAG_ZERO, IPP_TAG_INTEGER,\n\t              \"media-bottom-margin\", media_margin->values[0].integer);\n\n      if ((media_margin = ippFindAttribute(media_col->values[0].collection,\n                                           \"media-left-margin\",\n\t\t\t\t\t   IPP_TAG_INTEGER)) != NULL)\n        ippAddInteger(unsup_col, IPP_TAG_ZERO, IPP_TAG_INTEGER,\n\t              \"media-left-margin\", media_margin->values[0].integer);\n\n      if ((media_margin = ippFindAttribute(media_col->values[0].collection,\n                                           \"media-right-margin\",\n\t\t\t\t\t   IPP_TAG_INTEGER)) != NULL)\n        ippAddInteger(unsup_col, IPP_TAG_ZERO, IPP_TAG_INTEGER,\n\t              \"media-right-margin\", media_margin->values[0].integer);\n\n      if ((media_margin = ippFindAttribute(media_col->values[0].collection,\n                                           \"media-top-margin\",\n\t\t\t\t\t   IPP_TAG_INTEGER)) != NULL)\n        ippAddInteger(unsup_col, IPP_TAG_ZERO, IPP_TAG_INTEGER,\n\t              \"media-top-margin\", media_margin->values[0].integer);\n\n      ippAddCollection(con->response, IPP_TAG_UNSUPPORTED_GROUP, \"media-col\",\n                       unsup_col);\n      ippDelete(unsup_col);\n    }\n  }\n\n /*\n  * Make sure we aren't over our limit...\n  */\n\n  if (MaxJobs && cupsArrayCount(Jobs) >= MaxJobs)\n    cupsdCleanJobs();\n\n  if (MaxJobs && cupsArrayCount(Jobs) >= MaxJobs)\n  {\n    send_ipp_status(con, IPP_NOT_POSSIBLE, _(\"Too many active jobs.\"));\n    return (NULL);\n  }\n\n  if ((i = check_quotas(con, printer)) < 0)\n  {\n    send_ipp_status(con, IPP_NOT_POSSIBLE, _(\"Quota limit reached.\"));\n    return (NULL);\n  }\n  else if (i == 0)\n  {\n    send_ipp_status(con, IPP_NOT_AUTHORIZED, _(\"Not allowed to print.\"));\n    return (NULL);\n  }\n\n /*\n  * Create the job and set things up...\n  */\n\n  if ((attr = ippFindAttribute(con->request, \"job-priority\",\n                               IPP_TAG_INTEGER)) != NULL)\n    priority = attr->values[0].integer;\n  else\n  {\n    if ((val = cupsGetOption(\"job-priority\", printer->num_options,\n                             printer->options)) != NULL)\n      priority = atoi(val);\n    else\n      priority = 50;\n\n    ippAddInteger(con->request, IPP_TAG_JOB, IPP_TAG_INTEGER, \"job-priority\",\n                  priority);\n  }\n\n  if ((attr = ippFindAttribute(con->request, \"job-name\", IPP_TAG_ZERO)) == NULL)\n    ippAddString(con->request, IPP_TAG_JOB, IPP_TAG_NAME, \"job-name\", NULL, \"Untitled\");\n  else if ((attr->value_tag != IPP_TAG_NAME &&\n            attr->value_tag != IPP_TAG_NAMELANG) ||\n           attr->num_values != 1)\n  {\n    send_ipp_status(con, IPP_ATTRIBUTES,\n                    _(\"Bad job-name value: Wrong type or count.\"));\n    if ((attr = ippCopyAttribute(con->response, attr, 0)) != NULL)\n      attr->group_tag = IPP_TAG_UNSUPPORTED_GROUP;\n    return (NULL);\n  }\n  else if (!ippValidateAttribute(attr))\n  {\n    send_ipp_status(con, IPP_ATTRIBUTES, _(\"Bad job-name value: %s\"),\n                    cupsLastErrorString());\n    if ((attr = ippCopyAttribute(con->response, attr, 0)) != NULL)\n      attr->group_tag = IPP_TAG_UNSUPPORTED_GROUP;\n    return (NULL);\n  }\n\n  attr = ippFindAttribute(con->request, \"requesting-user-name\", IPP_TAG_NAME);\n\n  if (attr && !ippValidateAttribute(attr))\n  {\n    send_ipp_status(con, IPP_ATTRIBUTES, _(\"Bad requesting-user-name value: %s\"), cupsLastErrorString());\n    if ((attr = ippCopyAttribute(con->response, attr, 0)) != NULL)\n      attr->group_tag = IPP_TAG_UNSUPPORTED_GROUP;\n    return (NULL);\n  }\n\n  if ((job = cupsdAddJob(priority, printer->name)) == NULL)\n  {\n    send_ipp_status(con, IPP_INTERNAL_ERROR,\n                    _(\"Unable to add job for destination \\\"%s\\\".\"),\n\t\t    printer->name);\n    return (NULL);\n  }\n\n  job->dtype   = printer->type & (CUPS_PRINTER_CLASS | CUPS_PRINTER_REMOTE);\n  job->attrs   = con->request;\n  job->dirty   = 1;\n  con->request = ippNewRequest(job->attrs->request.op.operation_id);\n\n  cupsdMarkDirty(CUPSD_DIRTY_JOBS);\n\n  add_job_uuid(job);\n  apply_printer_defaults(printer, job);\n\n  if (con->username[0])\n  {\n    cupsdSetString(&job->username, con->username);\n\n    if (attr)\n      ippSetString(job->attrs, &attr, 0, con->username);\n  }\n  else if (attr)\n  {\n    cupsdLogMessage(CUPSD_LOG_DEBUG,\n                    \"add_job: requesting-user-name=\\\"%s\\\"\",\n                    attr->values[0].string.text);\n\n    cupsdSetString(&job->username, attr->values[0].string.text);\n  }\n  else\n    cupsdSetString(&job->username, \"anonymous\");\n\n  if (!attr)\n    ippAddString(job->attrs, IPP_TAG_JOB, IPP_TAG_NAME,\n                 \"job-originating-user-name\", NULL, job->username);\n  else\n  {\n    ippSetGroupTag(job->attrs, &attr, IPP_TAG_JOB);\n    ippSetName(job->attrs, &attr, \"job-originating-user-name\");\n  }\n\n  if (con->username[0] || auth_info)\n  {\n    save_auth_info(con, job, auth_info);\n\n   /*\n    * Remove the auth-info attribute from the attribute data...\n    */\n\n    if (auth_info)\n      ippDeleteAttribute(job->attrs, auth_info);\n  }\n\n  if ((attr = ippFindAttribute(con->request, \"job-name\", IPP_TAG_NAME)) != NULL)\n    cupsdSetString(&(job->name), attr->values[0].string.text);\n\n  if ((attr = ippFindAttribute(job->attrs, \"job-originating-host-name\",\n                               IPP_TAG_ZERO)) != NULL)\n  {\n   /*\n    * Request contains a job-originating-host-name attribute; validate it...\n    */\n\n    if (attr->value_tag != IPP_TAG_NAME ||\n        attr->num_values != 1 ||\n        strcmp(con->http->hostname, \"localhost\"))\n    {\n     /*\n      * Can't override the value if we aren't connected via localhost.\n      * Also, we can only have 1 value and it must be a name value.\n      */\n\n      ippDeleteAttribute(job->attrs, attr);\n      ippAddString(job->attrs, IPP_TAG_JOB, IPP_TAG_NAME, \"job-originating-host-name\", NULL, con->http->hostname);\n    }\n    else\n      ippSetGroupTag(job->attrs, &attr, IPP_TAG_JOB);\n  }\n  else\n  {\n   /*\n    * No job-originating-host-name attribute, so use the hostname from\n    * the connection...\n    */\n\n    ippAddString(job->attrs, IPP_TAG_JOB, IPP_TAG_NAME,\n        \t \"job-originating-host-name\", NULL, con->http->hostname);\n  }\n\n  ippAddOutOfBand(job->attrs, IPP_TAG_JOB, IPP_TAG_NOVALUE, \"date-time-at-completed\");\n  ippAddDate(job->attrs, IPP_TAG_JOB, \"date-time-at-creation\", ippTimeToDate(time(NULL)));\n  ippAddOutOfBand(job->attrs, IPP_TAG_JOB, IPP_TAG_NOVALUE, \"date-time-at-processing\");\n  ippAddOutOfBand(job->attrs, IPP_TAG_JOB, IPP_TAG_NOVALUE, \"time-at-completed\");\n  ippAddInteger(job->attrs, IPP_TAG_JOB, IPP_TAG_INTEGER, \"time-at-creation\", time(NULL));\n  ippAddOutOfBand(job->attrs, IPP_TAG_JOB, IPP_TAG_NOVALUE, \"time-at-processing\");\n\n /*\n  * Add remaining job attributes...\n  */\n\n  ippAddInteger(job->attrs, IPP_TAG_JOB, IPP_TAG_INTEGER, \"job-id\", job->id);\n  job->state = ippAddInteger(job->attrs, IPP_TAG_JOB, IPP_TAG_ENUM,\n                             \"job-state\", IPP_JOB_STOPPED);\n  job->state_value = (ipp_jstate_t)job->state->values[0].integer;\n  job->reasons = ippAddString(job->attrs, IPP_TAG_JOB, IPP_TAG_KEYWORD,\n                              \"job-state-reasons\", NULL, \"job-incoming\");\n  job->impressions = ippAddInteger(job->attrs, IPP_TAG_JOB, IPP_TAG_INTEGER, \"job-impressions-completed\", 0);\n  job->sheets = ippAddInteger(job->attrs, IPP_TAG_JOB, IPP_TAG_INTEGER,\n                              \"job-media-sheets-completed\", 0);\n  ippAddString(job->attrs, IPP_TAG_JOB, IPP_TAG_URI, \"job-printer-uri\", NULL,\n               printer->uri);\n\n  if ((attr = ippFindAttribute(job->attrs, \"job-k-octets\", IPP_TAG_INTEGER)) != NULL)\n    attr->values[0].integer = 0;\n  else\n    ippAddInteger(job->attrs, IPP_TAG_JOB, IPP_TAG_INTEGER, \"job-k-octets\", 0);\n\n  if ((attr = ippFindAttribute(job->attrs, \"job-hold-until\",\n                               IPP_TAG_KEYWORD)) == NULL)\n    attr = ippFindAttribute(job->attrs, \"job-hold-until\", IPP_TAG_NAME);\n  if (!attr)\n  {\n    if ((val = cupsGetOption(\"job-hold-until\", printer->num_options,\n                             printer->options)) == NULL)\n      val = \"no-hold\";\n\n    attr = ippAddString(job->attrs, IPP_TAG_JOB, IPP_TAG_KEYWORD,\n                        \"job-hold-until\", NULL, val);\n  }\n\n  if (printer->holding_new_jobs)\n  {\n   /*\n    * Hold all new jobs on this printer...\n    */\n\n    if (attr && strcmp(attr->values[0].string.text, \"no-hold\"))\n      cupsdSetJobHoldUntil(job, ippGetString(attr, 0, NULL), 0);\n    else\n      cupsdSetJobHoldUntil(job, \"indefinite\", 0);\n\n    job->state->values[0].integer = IPP_JOB_HELD;\n    job->state_value              = IPP_JOB_HELD;\n\n    ippSetString(job->attrs, &job->reasons, 0, \"job-held-on-create\");\n  }\n  else if (attr && strcmp(attr->values[0].string.text, \"no-hold\"))\n  {\n   /*\n    * Hold job until specified time...\n    */\n\n    cupsdSetJobHoldUntil(job, attr->values[0].string.text, 0);\n\n    job->state->values[0].integer = IPP_JOB_HELD;\n    job->state_value              = IPP_JOB_HELD;\n\n    ippSetString(job->attrs, &job->reasons, 0, \"job-hold-until-specified\");\n  }\n  else if (job->attrs->request.op.operation_id == IPP_CREATE_JOB)\n  {\n    job->hold_until               = time(NULL) + MultipleOperationTimeout;\n    job->state->values[0].integer = IPP_JOB_HELD;\n    job->state_value              = IPP_JOB_HELD;\n  }\n  else\n  {\n    job->state->values[0].integer = IPP_JOB_PENDING;\n    job->state_value              = IPP_JOB_PENDING;\n\n    ippSetString(job->attrs, &job->reasons, 0, \"none\");\n  }\n\n  if (!(printer->type & CUPS_PRINTER_REMOTE) || Classification)\n  {\n   /*\n    * Add job sheets options...\n    */\n\n    if ((attr = ippFindAttribute(job->attrs, \"job-sheets\",\n                                 IPP_TAG_ZERO)) == NULL)\n    {\n      cupsdLogMessage(CUPSD_LOG_DEBUG,\n                      \"Adding default job-sheets values \\\"%s,%s\\\"...\",\n                      printer->job_sheets[0], printer->job_sheets[1]);\n\n      attr = ippAddStrings(job->attrs, IPP_TAG_JOB, IPP_TAG_NAME, \"job-sheets\",\n                           2, NULL, NULL);\n      ippSetString(job->attrs, &attr, 0, printer->job_sheets[0]);\n      ippSetString(job->attrs, &attr, 1, printer->job_sheets[1]);\n    }\n\n    job->job_sheets = attr;\n\n   /*\n    * Enforce classification level if set...\n    */\n\n    if (Classification)\n    {\n      cupsdLogMessage(CUPSD_LOG_INFO,\n                      \"Classification=\\\"%s\\\", ClassifyOverride=%d\",\n                      Classification ? Classification : \"(null)\",\n\t\t      ClassifyOverride);\n\n      if (ClassifyOverride)\n      {\n        if (!strcmp(attr->values[0].string.text, \"none\") &&\n\t    (attr->num_values == 1 ||\n\t     !strcmp(attr->values[1].string.text, \"none\")))\n        {\n\t /*\n          * Force the leading banner to have the classification on it...\n\t  */\n\n          ippSetString(job->attrs, &attr, 0, Classification);\n\n\t  cupsdLogJob(job, CUPSD_LOG_NOTICE, \"CLASSIFICATION FORCED \"\n\t                \t\t     \"job-sheets=\\\"%s,none\\\", \"\n\t\t\t\t\t     \"job-originating-user-name=\\\"%s\\\"\",\n\t              Classification, job->username);\n\t}\n\telse if (attr->num_values == 2 &&\n\t         strcmp(attr->values[0].string.text,\n\t\t        attr->values[1].string.text) &&\n\t\t strcmp(attr->values[0].string.text, \"none\") &&\n\t\t strcmp(attr->values[1].string.text, \"none\"))\n        {\n\t /*\n\t  * Can't put two different security markings on the same document!\n\t  */\n\n          ippSetString(job->attrs, &attr, 1, attr->values[0].string.text);\n\n\t  cupsdLogJob(job, CUPSD_LOG_NOTICE, \"CLASSIFICATION FORCED \"\n\t                \t\t     \"job-sheets=\\\"%s,%s\\\", \"\n\t\t\t\t\t     \"job-originating-user-name=\\\"%s\\\"\",\n\t\t      attr->values[0].string.text,\n\t\t      attr->values[1].string.text, job->username);\n\t}\n\telse if (strcmp(attr->values[0].string.text, Classification) &&\n\t         strcmp(attr->values[0].string.text, \"none\") &&\n\t\t (attr->num_values == 1 ||\n\t          (strcmp(attr->values[1].string.text, Classification) &&\n\t           strcmp(attr->values[1].string.text, \"none\"))))\n        {\n\t  if (attr->num_values == 1)\n            cupsdLogJob(job, CUPSD_LOG_NOTICE,\n\t\t\t\"CLASSIFICATION OVERRIDDEN \"\n\t\t\t\"job-sheets=\\\"%s\\\", \"\n\t\t\t\"job-originating-user-name=\\\"%s\\\"\",\n\t                attr->values[0].string.text, job->username);\n          else\n            cupsdLogJob(job, CUPSD_LOG_NOTICE,\n\t\t\t\"CLASSIFICATION OVERRIDDEN \"\n\t\t\t\"job-sheets=\\\"%s,%s\\\",fffff \"\n\t\t\t\"job-originating-user-name=\\\"%s\\\"\",\n\t\t\tattr->values[0].string.text,\n\t\t\tattr->values[1].string.text, job->username);\n        }\n      }\n      else if (strcmp(attr->values[0].string.text, Classification) &&\n               (attr->num_values == 1 ||\n\t       strcmp(attr->values[1].string.text, Classification)))\n      {\n       /*\n        * Force the banner to have the classification on it...\n\t*/\n\n        if (attr->num_values > 1 &&\n\t    !strcmp(attr->values[0].string.text, attr->values[1].string.text))\n\t{\n          ippSetString(job->attrs, &attr, 0, Classification);\n          ippSetString(job->attrs, &attr, 1, Classification);\n\t}\n        else\n\t{\n          if (attr->num_values == 1 ||\n\t      strcmp(attr->values[0].string.text, \"none\"))\n            ippSetString(job->attrs, &attr, 0, Classification);\n\n          if (attr->num_values > 1 &&\n\t      strcmp(attr->values[1].string.text, \"none\"))\n\t    ippSetString(job->attrs, &attr, 1, Classification);\n        }\n\n        if (attr->num_values > 1)\n\t  cupsdLogJob(job, CUPSD_LOG_NOTICE,\n\t\t      \"CLASSIFICATION FORCED \"\n\t\t      \"job-sheets=\\\"%s,%s\\\", \"\n\t\t      \"job-originating-user-name=\\\"%s\\\"\",\n\t\t      attr->values[0].string.text,\n\t\t      attr->values[1].string.text, job->username);\n        else\n\t  cupsdLogJob(job, CUPSD_LOG_NOTICE,\n\t\t      \"CLASSIFICATION FORCED \"\n\t\t      \"job-sheets=\\\"%s\\\", \"\n\t\t      \"job-originating-user-name=\\\"%s\\\"\",\n\t\t      Classification, job->username);\n      }\n    }\n\n   /*\n    * See if we need to add the starting sheet...\n    */\n\n    if (!(printer->type & CUPS_PRINTER_REMOTE))\n    {\n      cupsdLogJob(job, CUPSD_LOG_INFO, \"Adding start banner page \\\"%s\\\".\",\n\t\t  attr->values[0].string.text);\n\n      if ((kbytes = copy_banner(con, job, attr->values[0].string.text)) < 0)\n      {\n        cupsdSetJobState(job, IPP_JOB_ABORTED, CUPSD_JOB_PURGE,\n\t                 \"Aborting job because the start banner could not be \"\n\t\t\t \"copied.\");\n        return (NULL);\n      }\n\n      cupsdUpdateQuota(printer, job->username, 0, kbytes);\n    }\n  }\n  else if ((attr = ippFindAttribute(job->attrs, \"job-sheets\",\n                                    IPP_TAG_ZERO)) != NULL)\n    job->job_sheets = attr;\n\n /*\n  * Fill in the response info...\n  */\n\n  httpAssembleURIf(HTTP_URI_CODING_ALL, job_uri, sizeof(job_uri), \"ipp\", NULL,\n                   con->clientname, con->clientport, \"/jobs/%d\", job->id);\n  ippAddString(con->response, IPP_TAG_JOB, IPP_TAG_URI, \"job-uri\", NULL,\n               job_uri);\n\n  ippAddInteger(con->response, IPP_TAG_JOB, IPP_TAG_INTEGER, \"job-id\", job->id);\n\n  ippAddInteger(con->response, IPP_TAG_JOB, IPP_TAG_ENUM, \"job-state\",\n                job->state_value);\n  ippAddString(con->response, IPP_TAG_JOB, IPP_TAG_TEXT, \"job-state-message\", NULL, \"\");\n  ippAddString(con->response, IPP_TAG_JOB, IPP_TAG_KEYWORD, \"job-state-reasons\",\n               NULL, job->reasons->values[0].string.text);\n\n  con->response->request.status.status_code = IPP_OK;\n\n /*\n  * Add any job subscriptions...\n  */\n\n  add_job_subscriptions(con, job);\n\n /*\n  * Set all but the first two attributes to the job attributes group...\n  */\n\n  for (attr = job->attrs->attrs->next->next; attr; attr = attr->next)\n    attr->group_tag = IPP_TAG_JOB;\n\n /*\n  * Fire the \"job created\" event...\n  */\n\n  cupsdAddEvent(CUPSD_EVENT_JOB_CREATED, printer, job, \"Job created.\");\n\n /*\n  * Return the new job...\n  */\n\n  return (job);\n}\n\n\n/*\n * 'add_job_subscriptions()' - Add any subscriptions for a job.\n */\n\nstatic void\nadd_job_subscriptions(\n    cupsd_client_t *con,\t\t/* I - Client connection */\n    cupsd_job_t    *job)\t\t/* I - Newly created job */\n{\n  int\t\t\ti;\t\t/* Looping var */\n  ipp_attribute_t\t*prev,\t\t/* Previous attribute */\n\t\t\t*next,\t\t/* Next attribute */\n\t\t\t*attr;\t\t/* Current attribute */\n  cupsd_subscription_t\t*sub;\t\t/* Subscription object */\n  const char\t\t*recipient,\t/* notify-recipient-uri */\n\t\t\t*pullmethod;\t/* notify-pull-method */\n  ipp_attribute_t\t*user_data;\t/* notify-user-data */\n  int\t\t\tinterval;\t/* notify-time-interval */\n  unsigned\t\tmask;\t\t/* notify-events */\n\n\n /*\n  * Find the first subscription group attribute; return if we have\n  * none...\n  */\n\n  for (attr = job->attrs->attrs; attr; attr = attr->next)\n    if (attr->group_tag == IPP_TAG_SUBSCRIPTION)\n      break;\n\n  if (!attr)\n    return;\n\n /*\n  * Process the subscription attributes in the request...\n  */\n\n  while (attr)\n  {\n    recipient = NULL;\n    pullmethod = NULL;\n    user_data  = NULL;\n    interval   = 0;\n    mask       = CUPSD_EVENT_NONE;\n\n    while (attr && attr->group_tag != IPP_TAG_ZERO)\n    {\n      if (!strcmp(attr->name, \"notify-recipient-uri\") &&\n          attr->value_tag == IPP_TAG_URI)\n      {\n       /*\n        * Validate the recipient scheme against the ServerBin/notifier\n\t* directory...\n\t*/\n\n\tchar\tnotifier[1024],\t\t/* Notifier filename */\n\t\tscheme[HTTP_MAX_URI],\t/* Scheme portion of URI */\n\t\tuserpass[HTTP_MAX_URI],\t/* Username portion of URI */\n\t\thost[HTTP_MAX_URI],\t/* Host portion of URI */\n\t\tresource[HTTP_MAX_URI];\t/* Resource portion of URI */\n        int\tport;\t\t\t/* Port portion of URI */\n\n\n        recipient = attr->values[0].string.text;\n\n\tif (httpSeparateURI(HTTP_URI_CODING_ALL, recipient,\n\t                    scheme, sizeof(scheme), userpass, sizeof(userpass),\n\t\t\t    host, sizeof(host), &port,\n\t\t\t    resource, sizeof(resource)) < HTTP_URI_OK)\n        {\n          send_ipp_status(con, IPP_NOT_POSSIBLE,\n\t                  _(\"Bad notify-recipient-uri \\\"%s\\\".\"), recipient);\n\t  ippAddInteger(con->response, IPP_TAG_SUBSCRIPTION, IPP_TAG_ENUM,\n\t                \"notify-status-code\", IPP_URI_SCHEME);\n\t  return;\n\t}\n\n        snprintf(notifier, sizeof(notifier), \"%s/notifier/%s\", ServerBin,\n\t         scheme);\n        if (access(notifier, X_OK))\n\t{\n          send_ipp_status(con, IPP_NOT_POSSIBLE,\n\t                  _(\"notify-recipient-uri URI \\\"%s\\\" uses unknown \"\n\t\t\t    \"scheme.\"), recipient);\n\t  ippAddInteger(con->response, IPP_TAG_SUBSCRIPTION, IPP_TAG_ENUM,\n\t                \"notify-status-code\", IPP_URI_SCHEME);\n\t  return;\n\t}\n\n        if (!strcmp(scheme, \"rss\") && !check_rss_recipient(recipient))\n\t{\n          send_ipp_status(con, IPP_NOT_POSSIBLE,\n\t                  _(\"notify-recipient-uri URI \\\"%s\\\" is already used.\"),\n\t\t\t  recipient);\n\t  ippAddInteger(con->response, IPP_TAG_SUBSCRIPTION, IPP_TAG_ENUM,\n\t                \"notify-status-code\", IPP_ATTRIBUTES);\n\t  return;\n\t}\n      }\n      else if (!strcmp(attr->name, \"notify-pull-method\") &&\n               attr->value_tag == IPP_TAG_KEYWORD)\n      {\n        pullmethod = attr->values[0].string.text;\n\n        if (strcmp(pullmethod, \"ippget\"))\n\t{\n          send_ipp_status(con, IPP_NOT_POSSIBLE,\n\t                  _(\"Bad notify-pull-method \\\"%s\\\".\"), pullmethod);\n\t  ippAddInteger(con->response, IPP_TAG_SUBSCRIPTION, IPP_TAG_ENUM,\n\t                \"notify-status-code\", IPP_ATTRIBUTES);\n\t  return;\n\t}\n      }\n      else if (!strcmp(attr->name, \"notify-charset\") &&\n               attr->value_tag == IPP_TAG_CHARSET &&\n\t       strcmp(attr->values[0].string.text, \"us-ascii\") &&\n\t       strcmp(attr->values[0].string.text, \"utf-8\"))\n      {\n        send_ipp_status(con, IPP_CHARSET,\n\t                _(\"Character set \\\"%s\\\" not supported.\"),\n\t\t\tattr->values[0].string.text);\n\treturn;\n      }\n      else if (!strcmp(attr->name, \"notify-natural-language\") &&\n               (attr->value_tag != IPP_TAG_LANGUAGE ||\n\t        strcmp(attr->values[0].string.text, DefaultLanguage)))\n      {\n        send_ipp_status(con, IPP_CHARSET,\n\t                _(\"Language \\\"%s\\\" not supported.\"),\n\t\t\tattr->values[0].string.text);\n\treturn;\n      }\n      else if (!strcmp(attr->name, \"notify-user-data\") &&\n               attr->value_tag == IPP_TAG_STRING)\n      {\n        if (attr->num_values > 1 || attr->values[0].unknown.length > 63)\n\t{\n          send_ipp_status(con, IPP_REQUEST_VALUE,\n\t                  _(\"The notify-user-data value is too large \"\n\t\t\t    \"(%d > 63 octets).\"),\n\t\t\t  attr->values[0].unknown.length);\n\t  return;\n\t}\n\n        user_data = attr;\n      }\n      else if (!strcmp(attr->name, \"notify-events\") &&\n               attr->value_tag == IPP_TAG_KEYWORD)\n      {\n        for (i = 0; i < attr->num_values; i ++)\n\t  mask |= cupsdEventValue(attr->values[i].string.text);\n      }\n      else if (!strcmp(attr->name, \"notify-lease-duration\"))\n      {\n        send_ipp_status(con, IPP_BAD_REQUEST,\n\t                _(\"The notify-lease-duration attribute cannot be \"\n\t\t\t  \"used with job subscriptions.\"));\n\treturn;\n      }\n      else if (!strcmp(attr->name, \"notify-time-interval\") &&\n               attr->value_tag == IPP_TAG_INTEGER)\n        interval = attr->values[0].integer;\n\n      attr = attr->next;\n    }\n\n    if (!recipient && !pullmethod)\n      break;\n\n    if (mask == CUPSD_EVENT_NONE)\n      mask = CUPSD_EVENT_JOB_COMPLETED;\n\n    if ((sub = cupsdAddSubscription(mask, cupsdFindDest(job->dest), job,\n                                    recipient, 0)) != NULL)\n    {\n      sub->interval = interval;\n\n      cupsdSetString(&sub->owner, job->username);\n\n      if (user_data)\n      {\n\tsub->user_data_len = user_data->values[0].unknown.length;\n\tmemcpy(sub->user_data, user_data->values[0].unknown.data,\n\t       (size_t)sub->user_data_len);\n      }\n\n      ippAddSeparator(con->response);\n      ippAddInteger(con->response, IPP_TAG_SUBSCRIPTION, IPP_TAG_INTEGER,\n\t\t    \"notify-subscription-id\", sub->id);\n\n      cupsdLogMessage(CUPSD_LOG_DEBUG, \"Added subscription %d for job %d\",\n                      sub->id, job->id);\n    }\n\n    if (attr)\n      attr = attr->next;\n  }\n\n  cupsdMarkDirty(CUPSD_DIRTY_SUBSCRIPTIONS);\n\n /*\n  * Remove all of the subscription attributes from the job request...\n  *\n  * TODO: Optimize this since subscription groups have to come at the\n  * end of the request...\n  */\n\n  for (attr = job->attrs->attrs, prev = NULL; attr; attr = next)\n  {\n    next = attr->next;\n\n    if (attr->group_tag == IPP_TAG_SUBSCRIPTION ||\n        attr->group_tag == IPP_TAG_ZERO)\n    {\n     /*\n      * Free and remove this attribute...\n      */\n\n      ippDeleteAttribute(NULL, attr);\n\n      if (prev)\n        prev->next = next;\n      else\n        job->attrs->attrs = next;\n    }\n    else\n      prev = attr;\n  }\n\n  job->attrs->last    = prev;\n  job->attrs->current = prev;\n}\n\n\n/*\n * 'add_job_uuid()' - Add job-uuid attribute to a job.\n *\n * See RFC 4122 for the definition of UUIDs and the format.\n */\n\nstatic void\nadd_job_uuid(cupsd_job_t *job)\t\t/* I - Job */\n{\n  char\t\t\tuuid[64];\t/* job-uuid string */\n\n\n /*\n  * Add a job-uuid attribute if none exists...\n  */\n\n  if (!ippFindAttribute(job->attrs, \"job-uuid\", IPP_TAG_URI))\n    ippAddString(job->attrs, IPP_TAG_JOB, IPP_TAG_URI, \"job-uuid\", NULL,\n\t\t httpAssembleUUID(ServerName, RemotePort, job->dest, job->id,\n\t\t                  uuid, sizeof(uuid)));\n}\n\n\n/*\n * 'add_printer()' - Add a printer to the system.\n */\n\nstatic void\nadd_printer(cupsd_client_t  *con,\t/* I - Client connection */\n            ipp_attribute_t *uri)\t/* I - URI of printer */\n{\n  http_status_t\tstatus;\t\t\t/* Policy status */\n  int\t\ti;\t\t\t/* Looping var */\n  char\t\tscheme[HTTP_MAX_URI],\t/* Method portion of URI */\n\t\tusername[HTTP_MAX_URI],\t/* Username portion of URI */\n\t\thost[HTTP_MAX_URI],\t/* Host portion of URI */\n\t\tresource[HTTP_MAX_URI];\t/* Resource portion of URI */\n  int\t\tport;\t\t\t/* Port portion of URI */\n  cupsd_printer_t *printer;\t\t/* Printer/class */\n  ipp_attribute_t *attr;\t\t/* Printer attribute */\n  cups_file_t\t*fp;\t\t\t/* Script/PPD file */\n  char\t\tline[1024];\t\t/* Line from file... */\n  char\t\tsrcfile[1024],\t\t/* Source Script/PPD file */\n\t\tdstfile[1024];\t\t/* Destination Script/PPD file */\n  int\t\tmodify;\t\t\t/* Non-zero if we are modifying */\n  int\t\tchanged_driver,\t\t/* Changed the PPD? */\n\t\tneed_restart_job,\t/* Need to restart job? */\n\t\tset_device_uri,\t\t/* Did we set the device URI? */\n\t\tset_port_monitor;\t/* Did we set the port monitor? */\n\n\n  cupsdLogMessage(CUPSD_LOG_DEBUG2, \"add_printer(%p[%d], %s)\", con,\n                  con->number, uri->values[0].string.text);\n\n /*\n  * Do we have a valid URI?\n  */\n\n  httpSeparateURI(HTTP_URI_CODING_ALL, uri->values[0].string.text, scheme,\n                  sizeof(scheme), username, sizeof(username), host,\n\t\t  sizeof(host), &port, resource, sizeof(resource));\n\n  if (strncmp(resource, \"/printers/\", 10) || strlen(resource) == 10)\n  {\n   /*\n    * No, return an error...\n    */\n\n    send_ipp_status(con, IPP_BAD_REQUEST,\n                    _(\"The printer-uri must be of the form \"\n\t\t      \"\\\"ipp://HOSTNAME/printers/PRINTERNAME\\\".\"));\n    return;\n  }\n\n /*\n  * Do we have a valid printer name?\n  */\n\n  if (!validate_name(resource + 10))\n  {\n   /*\n    * No, return an error...\n    */\n\n    send_ipp_status(con, IPP_BAD_REQUEST,\n                    _(\"The printer-uri \\\"%s\\\" contains invalid characters.\"),\n\t\t    uri->values[0].string.text);\n    return;\n  }\n\n /*\n  * See if the printer already exists; if not, create a new printer...\n  */\n\n  if ((printer = cupsdFindPrinter(resource + 10)) == NULL)\n  {\n   /*\n    * Printer doesn't exist; see if we have a class of the same name...\n    */\n\n    if ((printer = cupsdFindClass(resource + 10)) != NULL)\n    {\n     /*\n      * Yes, return an error...\n      */\n\n      send_ipp_status(con, IPP_NOT_POSSIBLE,\n                      _(\"A class named \\\"%s\\\" already exists.\"),\n        \t      resource + 10);\n      return;\n    }\n\n   /*\n    * No, check the default policy then add the printer...\n    */\n\n    if ((status = cupsdCheckPolicy(DefaultPolicyPtr, con, NULL)) != HTTP_OK)\n    {\n      send_http_error(con, status, NULL);\n      return;\n    }\n\n    printer = cupsdAddPrinter(resource + 10);\n    modify  = 0;\n  }\n  else if ((status = cupsdCheckPolicy(printer->op_policy_ptr, con,\n                                      NULL)) != HTTP_OK)\n  {\n    send_http_error(con, status, printer);\n    return;\n  }\n  else\n    modify = 1;\n\n /*\n  * Look for attributes and copy them over as needed...\n  */\n\n  changed_driver   = 0;\n  need_restart_job = 0;\n\n  if ((attr = ippFindAttribute(con->request, \"printer-is-temporary\", IPP_TAG_BOOLEAN)) != NULL)\n    printer->temporary = ippGetBoolean(attr, 0);\n\n  if ((attr = ippFindAttribute(con->request, \"printer-location\",\n                               IPP_TAG_TEXT)) != NULL)\n    cupsdSetString(&printer->location, attr->values[0].string.text);\n\n  if ((attr = ippFindAttribute(con->request, \"printer-geo-location\", IPP_TAG_URI)) != NULL && !strncmp(attr->values[0].string.text, \"geo:\", 4))\n    cupsdSetString(&printer->geo_location, attr->values[0].string.text);\n\n  if ((attr = ippFindAttribute(con->request, \"printer-organization\", IPP_TAG_TEXT)) != NULL)\n    cupsdSetString(&printer->organization, attr->values[0].string.text);\n\n  if ((attr = ippFindAttribute(con->request, \"printer-organizational-unit\", IPP_TAG_TEXT)) != NULL)\n    cupsdSetString(&printer->organizational_unit, attr->values[0].string.text);\n\n  if ((attr = ippFindAttribute(con->request, \"printer-info\",\n                               IPP_TAG_TEXT)) != NULL)\n    cupsdSetString(&printer->info, attr->values[0].string.text);\n\n  set_device_uri = 0;\n\n  if ((attr = ippFindAttribute(con->request, \"device-uri\",\n                               IPP_TAG_URI)) != NULL)\n  {\n   /*\n    * Do we have a valid device URI?\n    */\n\n    http_uri_status_t\turi_status;\t/* URI separation status */\n    char\t\told_device_uri[1024];\n\t\t\t\t\t/* Old device URI */\n\n    need_restart_job = 1;\n\n    uri_status = httpSeparateURI(HTTP_URI_CODING_ALL,\n\t\t\t\t attr->values[0].string.text,\n\t\t\t\t scheme, sizeof(scheme),\n\t\t\t\t username, sizeof(username),\n\t\t\t\t host, sizeof(host), &port,\n\t\t\t\t resource, sizeof(resource));\n\n    cupsdLogMessage(CUPSD_LOG_DEBUG, \"%s device-uri: %s\", printer->name, httpURIStatusString(uri_status));\n\n    if (uri_status < HTTP_URI_OK)\n    {\n      send_ipp_status(con, IPP_NOT_POSSIBLE, _(\"Bad device-uri \\\"%s\\\".\"),\n\t\t      attr->values[0].string.text);\n      if (!modify)\n        cupsdDeletePrinter(printer, 0);\n\n      return;\n    }\n\n    if (!strcmp(scheme, \"file\"))\n    {\n     /*\n      * See if the administrator has enabled file devices...\n      */\n\n      if (!FileDevice && strcmp(resource, \"/dev/null\"))\n      {\n       /*\n        * File devices are disabled and the URL is not file:/dev/null...\n\t*/\n\n\tsend_ipp_status(con, IPP_NOT_POSSIBLE,\n\t                _(\"File device URIs have been disabled. \"\n\t                  \"To enable, see the FileDevice directive in \"\n\t\t\t  \"\\\"%s/cups-files.conf\\\".\"),\n\t\t\tServerRoot);\n\tif (!modify)\n\t  cupsdDeletePrinter(printer, 0);\n\n\treturn;\n      }\n    }\n    else\n    {\n     /*\n      * See if the backend exists and is executable...\n      */\n\n      snprintf(srcfile, sizeof(srcfile), \"%s/backend/%s\", ServerBin, scheme);\n      if (access(srcfile, X_OK))\n      {\n       /*\n        * Could not find device in list!\n\t*/\n\n\tsend_ipp_status(con, IPP_NOT_POSSIBLE,\n                        _(\"Bad device-uri scheme \\\"%s\\\".\"), scheme);\n\tif (!modify)\n\t  cupsdDeletePrinter(printer, 0);\n\n\treturn;\n      }\n    }\n\n    if (printer->sanitized_device_uri)\n      strlcpy(old_device_uri, printer->sanitized_device_uri,\n              sizeof(old_device_uri));\n    else\n      old_device_uri[0] = '\\0';\n\n    cupsdSetDeviceURI(printer, attr->values[0].string.text);\n\n    cupsdLogMessage(CUPSD_LOG_INFO,\n                    \"Setting %s device-uri to \\\"%s\\\" (was \\\"%s\\\".)\",\n        \t    printer->name, printer->sanitized_device_uri,\n\t\t    old_device_uri);\n\n    set_device_uri = 1;\n  }\n\n  set_port_monitor = 0;\n\n  if ((attr = ippFindAttribute(con->request, \"port-monitor\",\n                               IPP_TAG_NAME)) != NULL)\n  {\n    ipp_attribute_t\t*supported;\t/* port-monitor-supported attribute */\n\n\n    need_restart_job = 1;\n\n    supported = ippFindAttribute(printer->ppd_attrs, \"port-monitor-supported\",\n                                 IPP_TAG_NAME);\n    if (supported)\n    {\n      for (i = 0; i < supported->num_values; i ++)\n        if (!strcmp(supported->values[i].string.text,\n                    attr->values[0].string.text))\n          break;\n    }\n\n    if (!supported || i >= supported->num_values)\n    {\n      send_ipp_status(con, IPP_NOT_POSSIBLE, _(\"Bad port-monitor \\\"%s\\\".\"),\n        \t      attr->values[0].string.text);\n      if (!modify)\n        cupsdDeletePrinter(printer, 0);\n\n      return;\n    }\n\n    cupsdLogMessage(CUPSD_LOG_INFO,\n                    \"Setting %s port-monitor to \\\"%s\\\" (was \\\"%s\\\".)\",\n                    printer->name, attr->values[0].string.text,\n\t            printer->port_monitor ? printer->port_monitor : \"none\");\n\n    if (strcmp(attr->values[0].string.text, \"none\"))\n      cupsdSetString(&printer->port_monitor, attr->values[0].string.text);\n    else\n      cupsdClearString(&printer->port_monitor);\n\n    set_port_monitor = 1;\n  }\n\n  if ((attr = ippFindAttribute(con->request, \"printer-is-accepting-jobs\",\n                               IPP_TAG_BOOLEAN)) != NULL &&\n      attr->values[0].boolean != printer->accepting)\n  {\n    cupsdLogMessage(CUPSD_LOG_INFO,\n                    \"Setting %s printer-is-accepting-jobs to %d (was %d.)\",\n                    printer->name, attr->values[0].boolean, printer->accepting);\n\n    printer->accepting = attr->values[0].boolean;\n\n    cupsdAddEvent(CUPSD_EVENT_PRINTER_STATE, printer, NULL,\n                  \"%s accepting jobs.\",\n\t\t  printer->accepting ? \"Now\" : \"No longer\");\n  }\n\n  if ((attr = ippFindAttribute(con->request, \"printer-is-shared\", IPP_TAG_BOOLEAN)) != NULL)\n  {\n    if (ippGetBoolean(attr, 0) &&\n        printer->num_auth_info_required == 1 &&\n\t!strcmp(printer->auth_info_required[0], \"negotiate\"))\n    {\n      send_ipp_status(con, IPP_BAD_REQUEST,\n                      _(\"Cannot share a remote Kerberized printer.\"));\n      if (!modify)\n        cupsdDeletePrinter(printer, 0);\n\n      return;\n    }\n\n    if (printer->type & CUPS_PRINTER_REMOTE)\n    {\n     /*\n      * Cannot re-share remote printers.\n      */\n\n      send_ipp_status(con, IPP_BAD_REQUEST, _(\"Cannot change printer-is-shared for remote queues.\"));\n      if (!modify)\n        cupsdDeletePrinter(printer, 0);\n\n      return;\n    }\n\n    if (printer->shared && !ippGetBoolean(attr, 0))\n      cupsdDeregisterPrinter(printer, 1);\n\n    cupsdLogMessage(CUPSD_LOG_INFO,\n                    \"Setting %s printer-is-shared to %d (was %d.)\",\n                    printer->name, attr->values[0].boolean, printer->shared);\n\n    printer->shared = ippGetBoolean(attr, 0);\n    if (printer->shared && printer->temporary)\n      printer->temporary = 0;\n  }\n\n  if ((attr = ippFindAttribute(con->request, \"printer-state\",\n                               IPP_TAG_ENUM)) != NULL)\n  {\n    if (attr->values[0].integer != IPP_PRINTER_IDLE &&\n        attr->values[0].integer != IPP_PRINTER_STOPPED)\n    {\n      send_ipp_status(con, IPP_BAD_REQUEST, _(\"Bad printer-state value %d.\"),\n                      attr->values[0].integer);\n      if (!modify)\n        cupsdDeletePrinter(printer, 0);\n\n      return;\n    }\n\n    cupsdLogMessage(CUPSD_LOG_INFO, \"Setting %s printer-state to %d (was %d.)\",\n                    printer->name, attr->values[0].integer, printer->state);\n\n    if (attr->values[0].integer == IPP_PRINTER_STOPPED)\n      cupsdStopPrinter(printer, 0);\n    else\n    {\n      need_restart_job = 1;\n      cupsdSetPrinterState(printer, (ipp_pstate_t)(attr->values[0].integer), 0);\n    }\n  }\n\n  if ((attr = ippFindAttribute(con->request, \"printer-state-message\",\n                               IPP_TAG_TEXT)) != NULL)\n  {\n    strlcpy(printer->state_message, attr->values[0].string.text,\n            sizeof(printer->state_message));\n\n    cupsdAddEvent(CUPSD_EVENT_PRINTER_STATE, printer, NULL, \"%s\",\n                  printer->state_message);\n  }\n\n  if ((attr = ippFindAttribute(con->request, \"printer-state-reasons\",\n                               IPP_TAG_KEYWORD)) != NULL)\n  {\n    if (attr->num_values >\n            (int)(sizeof(printer->reasons) / sizeof(printer->reasons[0])))\n    {\n      send_ipp_status(con, IPP_NOT_POSSIBLE,\n                      _(\"Too many printer-state-reasons values (%d > %d).\"),\n\t\t      attr->num_values,\n\t\t      (int)(sizeof(printer->reasons) /\n\t\t            sizeof(printer->reasons[0])));\n      if (!modify)\n        cupsdDeletePrinter(printer, 0);\n\n      return;\n    }\n\n    for (i = 0; i < printer->num_reasons; i ++)\n      _cupsStrFree(printer->reasons[i]);\n\n    printer->num_reasons = 0;\n    for (i = 0; i < attr->num_values; i ++)\n    {\n      if (!strcmp(attr->values[i].string.text, \"none\"))\n        continue;\n\n      printer->reasons[printer->num_reasons] =\n          _cupsStrRetain(attr->values[i].string.text);\n      printer->num_reasons ++;\n\n      if (!strcmp(attr->values[i].string.text, \"paused\") &&\n          printer->state != IPP_PRINTER_STOPPED)\n      {\n\tcupsdLogMessage(CUPSD_LOG_INFO,\n\t                \"Setting %s printer-state to %d (was %d.)\",\n\t\t\tprinter->name, IPP_PRINTER_STOPPED, printer->state);\n\tcupsdStopPrinter(printer, 0);\n      }\n    }\n\n    if (PrintcapFormat == PRINTCAP_PLIST)\n      cupsdMarkDirty(CUPSD_DIRTY_PRINTCAP);\n\n    cupsdAddEvent(CUPSD_EVENT_PRINTER_STATE, printer, NULL,\n                  \"Printer \\\"%s\\\" state changed.\", printer->name);\n  }\n\n  if (!set_printer_defaults(con, printer))\n  {\n    if (!modify)\n      cupsdDeletePrinter(printer, 0);\n\n    return;\n  }\n\n  if ((attr = ippFindAttribute(con->request, \"auth-info-required\",\n                               IPP_TAG_KEYWORD)) != NULL)\n    cupsdSetAuthInfoRequired(printer, NULL, attr);\n\n /*\n  * See if we have all required attributes...\n  */\n\n  if (!printer->device_uri)\n    cupsdSetString(&printer->device_uri, \"file:///dev/null\");\n\n /*\n  * See if we have a PPD file attached to the request...\n  */\n\n  if (con->filename)\n  {\n    need_restart_job = 1;\n    changed_driver   = 1;\n\n    strlcpy(srcfile, con->filename, sizeof(srcfile));\n\n    if ((fp = cupsFileOpen(srcfile, \"rb\")))\n    {\n     /*\n      * Yes; get the first line from it...\n      */\n\n      line[0] = '\\0';\n      cupsFileGets(fp, line, sizeof(line));\n      cupsFileClose(fp);\n\n     /*\n      * Then see what kind of file it is...\n      */\n\n      if (strncmp(line, \"*PPD-Adobe\", 10))\n      {\n\tsend_ipp_status(con, IPP_STATUS_ERROR_DOCUMENT_FORMAT_NOT_SUPPORTED, _(\"Bad PPD file.\"));\n\tif (!modify)\n\t  cupsdDeletePrinter(printer, 0);\n\n\treturn;\n      }\n\n      snprintf(dstfile, sizeof(dstfile), \"%s/ppd/%s.ppd\", ServerRoot,\n               printer->name);\n\n     /*\n      * The new file is a PPD file, so move the file over to the ppd\n      * directory...\n      */\n\n      if (copy_file(srcfile, dstfile, ConfigFilePerm))\n      {\n\tsend_ipp_status(con, IPP_INTERNAL_ERROR, _(\"Unable to copy PPD file - %s\"), strerror(errno));\n\tif (!modify)\n\t  cupsdDeletePrinter(printer, 0);\n\n\treturn;\n      }\n\n      cupsdLogMessage(CUPSD_LOG_DEBUG, \"Copied PPD file successfully\");\n    }\n  }\n  else if ((attr = ippFindAttribute(con->request, \"ppd-name\", IPP_TAG_NAME)) != NULL)\n  {\n    const char *ppd_name = ippGetString(attr, 0, NULL);\n\t\t\t\t\t/* ppd-name value */\n\n    need_restart_job = 1;\n    changed_driver   = 1;\n\n    if (!strcmp(ppd_name, \"raw\"))\n    {\n     /*\n      * Raw driver, remove any existing PPD file.\n      */\n\n      snprintf(dstfile, sizeof(dstfile), \"%s/ppd/%s.ppd\", ServerRoot, printer->name);\n      unlink(dstfile);\n    }\n    else if (strstr(ppd_name, \"../\"))\n    {\n      send_ipp_status(con, IPP_STATUS_ERROR_ATTRIBUTES_OR_VALUES, _(\"Invalid ppd-name value.\"));\n      if (!modify)\n\tcupsdDeletePrinter(printer, 0);\n\n      return;\n    }\n    else\n    {\n     /*\n      * PPD model file...\n      */\n\n      snprintf(dstfile, sizeof(dstfile), \"%s/ppd/%s.ppd\", ServerRoot, printer->name);\n\n      if (copy_model(con, ppd_name, dstfile))\n      {\n        send_ipp_status(con, IPP_INTERNAL_ERROR, _(\"Unable to copy PPD file.\"));\n\tif (!modify)\n\t  cupsdDeletePrinter(printer, 0);\n\n\treturn;\n      }\n\n      cupsdLogMessage(CUPSD_LOG_DEBUG, \"Copied PPD file successfully\");\n    }\n  }\n\n  if (changed_driver)\n  {\n   /*\n    * If we changed the PPD, then remove the printer's cache file and clear the\n    * printer-state-reasons...\n    */\n\n    char cache_name[1024];\t\t/* Cache filename for printer attrs */\n\n    snprintf(cache_name, sizeof(cache_name), \"%s/%s.data\", CacheDir, printer->name);\n    unlink(cache_name);\n\n    cupsdSetPrinterReasons(printer, \"none\");\n\n   /*\n    * (Re)register color profiles...\n    */\n\n    cupsdRegisterColor(printer);\n  }\n\n /*\n  * If we set the device URI but not the port monitor, check which port\n  * monitor to use by default...\n  */\n\n  if (set_device_uri && !set_port_monitor)\n  {\n    ppd_file_t\t*ppd;\t\t\t/* PPD file */\n    ppd_attr_t\t*ppdattr;\t\t/* cupsPortMonitor attribute */\n\n\n    httpSeparateURI(HTTP_URI_CODING_ALL, printer->device_uri, scheme,\n                    sizeof(scheme), username, sizeof(username), host,\n\t\t    sizeof(host), &port, resource, sizeof(resource));\n\n    snprintf(srcfile, sizeof(srcfile), \"%s/ppd/%s.ppd\", ServerRoot,\n\t     printer->name);\n    if ((ppd = _ppdOpenFile(srcfile, _PPD_LOCALIZATION_NONE)) != NULL)\n    {\n      for (ppdattr = ppdFindAttr(ppd, \"cupsPortMonitor\", NULL);\n\t   ppdattr;\n\t   ppdattr = ppdFindNextAttr(ppd, \"cupsPortMonitor\", NULL))\n        if (!strcmp(scheme, ppdattr->spec))\n\t{\n\t  cupsdLogMessage(CUPSD_LOG_INFO,\n\t\t\t  \"Setting %s port-monitor to \\\"%s\\\" (was \\\"%s\\\".)\",\n\t\t\t  printer->name, ppdattr->value,\n\t\t\t  printer->port_monitor ? printer->port_monitor\n\t\t\t                        : \"none\");\n\n\t  if (strcmp(ppdattr->value, \"none\"))\n\t    cupsdSetString(&printer->port_monitor, ppdattr->value);\n\t  else\n\t    cupsdClearString(&printer->port_monitor);\n\n\t  break;\n\t}\n\n      ppdClose(ppd);\n    }\n  }\n\n  printer->config_time = time(NULL);\n\n /*\n  * Update the printer attributes and return...\n  */\n\n  cupsdSetPrinterAttrs(printer);\n  if (!printer->temporary)\n    cupsdMarkDirty(CUPSD_DIRTY_PRINTERS);\n\n  if (need_restart_job && printer->job)\n  {\n   /*\n    * Restart the current job...\n    */\n\n    cupsdSetJobState(printer->job, IPP_JOB_PENDING, CUPSD_JOB_FORCE,\n                     \"Job restarted because the printer was modified.\");\n  }\n\n  cupsdMarkDirty(CUPSD_DIRTY_PRINTCAP);\n\n  if (modify)\n  {\n    cupsdAddEvent(CUPSD_EVENT_PRINTER_MODIFIED,\n                  printer, NULL, \"Printer \\\"%s\\\" modified by \\\"%s\\\".\",\n\t\t  printer->name, get_username(con));\n\n    cupsdLogMessage(CUPSD_LOG_INFO, \"Printer \\\"%s\\\" modified by \\\"%s\\\".\",\n                    printer->name, get_username(con));\n  }\n  else\n  {\n    cupsdAddEvent(CUPSD_EVENT_PRINTER_ADDED,\n                  printer, NULL, \"New printer \\\"%s\\\" added by \\\"%s\\\".\",\n\t\t  printer->name, get_username(con));\n\n    cupsdLogMessage(CUPSD_LOG_INFO, \"New printer \\\"%s\\\" added by \\\"%s\\\".\",\n                    printer->name, get_username(con));\n  }\n\n  con->response->request.status.status_code = IPP_OK;\n}\n\n\n/*\n * 'add_printer_state_reasons()' - Add the \"printer-state-reasons\" attribute\n *                                 based upon the printer state...\n */\n\nstatic void\nadd_printer_state_reasons(\n    cupsd_client_t  *con,\t\t/* I - Client connection */\n    cupsd_printer_t *p)\t\t\t/* I - Printer info */\n{\n  cupsdLogMessage(CUPSD_LOG_DEBUG2,\n                  \"add_printer_state_reasons(%p[%d], %p[%s])\",\n                  con, con->number, p, p->name);\n\n  if (p->num_reasons == 0)\n    ippAddString(con->response, IPP_TAG_PRINTER, IPP_TAG_KEYWORD,\n                 \"printer-state-reasons\", NULL, \"none\");\n  else\n    ippAddStrings(con->response, IPP_TAG_PRINTER, IPP_TAG_KEYWORD,\n                  \"printer-state-reasons\", p->num_reasons, NULL,\n\t\t  (const char * const *)p->reasons);\n}\n\n\n/*\n * 'add_queued_job_count()' - Add the \"queued-job-count\" attribute for\n *                            the specified printer or class.\n */\n\nstatic void\nadd_queued_job_count(\n    cupsd_client_t  *con,\t\t/* I - Client connection */\n    cupsd_printer_t *p)\t\t\t/* I - Printer or class */\n{\n  int\t\tcount;\t\t\t/* Number of jobs on destination */\n\n\n  cupsdLogMessage(CUPSD_LOG_DEBUG2, \"add_queued_job_count(%p[%d], %p[%s])\",\n                  con, con->number, p, p->name);\n\n  count = cupsdGetPrinterJobCount(p->name);\n\n  ippAddInteger(con->response, IPP_TAG_PRINTER, IPP_TAG_INTEGER,\n                \"queued-job-count\", count);\n}\n\n\n/*\n * 'apply_printer_defaults()' - Apply printer default options to a job.\n */\n\nstatic void\napply_printer_defaults(\n    cupsd_printer_t *printer,\t\t/* I - Printer */\n    cupsd_job_t     *job)\t\t/* I - Job */\n{\n  int\t\ti,\t\t\t/* Looping var */\n\t\tnum_options;\t\t/* Number of default options */\n  cups_option_t\t*options,\t\t/* Default options */\n\t\t*option;\t\t/* Current option */\n\n\n  cupsdLogJob(job, CUPSD_LOG_DEBUG, \"Applying default options...\");\n\n /*\n  * Collect all of the default options and add the missing ones to the\n  * job object...\n  */\n\n  for (i = printer->num_options, num_options = 0, options = NULL,\n           option = printer->options;\n       i > 0;\n       i --, option ++)\n    if (!ippFindAttribute(job->attrs, option->name, IPP_TAG_ZERO))\n    {\n      if (!strcmp(option->name, \"print-quality\") && ippFindAttribute(job->attrs, \"cupsPrintQuality\", IPP_TAG_NAME))\n        continue;                     /* Don't override cupsPrintQuality */\n\n      cupsdLogJob(job, CUPSD_LOG_DEBUG, \"Adding default %s=%s\", option->name, option->value);\n\n      num_options = cupsAddOption(option->name, option->value, num_options, &options);\n    }\n\n /*\n  * Encode these options as attributes in the job object...\n  */\n\n  cupsEncodeOptions2(job->attrs, num_options, options, IPP_TAG_JOB);\n  cupsFreeOptions(num_options, options);\n}\n\n\n/*\n * 'authenticate_job()' - Set job authentication info.\n */\n\nstatic void\nauthenticate_job(cupsd_client_t  *con,\t/* I - Client connection */\n\t         ipp_attribute_t *uri)\t/* I - Job URI */\n{\n  ipp_attribute_t\t*attr,\t\t/* job-id attribute */\n\t\t\t*auth_info;\t/* auth-info attribute */\n  int\t\t\tjobid;\t\t/* Job ID */\n  cupsd_job_t\t\t*job;\t\t/* Current job */\n  char\t\t\tscheme[HTTP_MAX_URI],\n\t\t\t\t\t/* Method portion of URI */\n\t\t\tusername[HTTP_MAX_URI],\n\t\t\t\t\t/* Username portion of URI */\n\t\t\thost[HTTP_MAX_URI],\n\t\t\t\t\t/* Host portion of URI */\n\t\t\tresource[HTTP_MAX_URI];\n\t\t\t\t\t/* Resource portion of URI */\n  int\t\t\tport;\t\t/* Port portion of URI */\n\n\n  cupsdLogMessage(CUPSD_LOG_DEBUG2, \"authenticate_job(%p[%d], %s)\",\n                  con, con->number, uri->values[0].string.text);\n\n /*\n  * Start with \"everything is OK\" status...\n  */\n\n  con->response->request.status.status_code = IPP_OK;\n\n /*\n  * See if we have a job URI or a printer URI...\n  */\n\n  if (!strcmp(uri->name, \"printer-uri\"))\n  {\n   /*\n    * Got a printer URI; see if we also have a job-id attribute...\n    */\n\n    if ((attr = ippFindAttribute(con->request, \"job-id\",\n                                 IPP_TAG_INTEGER)) == NULL)\n    {\n      send_ipp_status(con, IPP_BAD_REQUEST,\n                      _(\"Got a printer-uri attribute but no job-id.\"));\n      return;\n    }\n\n    jobid = attr->values[0].integer;\n  }\n  else\n  {\n   /*\n    * Got a job URI; parse it to get the job ID...\n    */\n\n    httpSeparateURI(HTTP_URI_CODING_ALL, uri->values[0].string.text, scheme,\n                    sizeof(scheme), username, sizeof(username), host,\n\t\t    sizeof(host), &port, resource, sizeof(resource));\n\n    if (strncmp(resource, \"/jobs/\", 6))\n    {\n     /*\n      * Not a valid URI!\n      */\n\n      send_ipp_status(con, IPP_BAD_REQUEST, _(\"Bad job-uri \\\"%s\\\".\"),\n                      uri->values[0].string.text);\n      return;\n    }\n\n    jobid = atoi(resource + 6);\n  }\n\n /*\n  * See if the job exists...\n  */\n\n  if ((job = cupsdFindJob(jobid)) == NULL)\n  {\n   /*\n    * Nope - return a \"not found\" error...\n    */\n\n    send_ipp_status(con, IPP_NOT_FOUND, _(\"Job #%d does not exist.\"), jobid);\n    return;\n  }\n\n /*\n  * See if the job has been completed...\n  */\n\n  if (job->state_value != IPP_JOB_HELD)\n  {\n   /*\n    * Return a \"not-possible\" error...\n    */\n\n    send_ipp_status(con, IPP_NOT_POSSIBLE,\n                    _(\"Job #%d is not held for authentication.\"),\n\t\t    jobid);\n    return;\n  }\n\n /*\n  * See if we have already authenticated...\n  */\n\n  auth_info = ippFindAttribute(con->request, \"auth-info\", IPP_TAG_TEXT);\n\n  if (!con->username[0] && !auth_info)\n  {\n    cupsd_printer_t\t*printer;\t/* Job destination */\n\n   /*\n    * No auth data.  If we need to authenticate via Kerberos, send a\n    * HTTP auth challenge, otherwise just return an IPP error...\n    */\n\n    printer = cupsdFindDest(job->dest);\n\n    if (printer && printer->num_auth_info_required > 0 &&\n        !strcmp(printer->auth_info_required[0], \"negotiate\"))\n      send_http_error(con, HTTP_UNAUTHORIZED, printer);\n    else\n      send_ipp_status(con, IPP_NOT_AUTHORIZED,\n\t\t      _(\"No authentication information provided.\"));\n    return;\n  }\n\n /*\n  * See if the job is owned by the requesting user...\n  */\n\n  if (!validate_user(job, con, job->username, username, sizeof(username)))\n  {\n    send_http_error(con, con->username[0] ? HTTP_FORBIDDEN : HTTP_UNAUTHORIZED,\n                    cupsdFindDest(job->dest));\n    return;\n  }\n\n /*\n  * Save the authentication information for this job...\n  */\n\n  save_auth_info(con, job, auth_info);\n\n /*\n  * Reset the job-hold-until value to \"no-hold\"...\n  */\n\n  if ((attr = ippFindAttribute(job->attrs, \"job-hold-until\",\n                               IPP_TAG_KEYWORD)) == NULL)\n    attr = ippFindAttribute(job->attrs, \"job-hold-until\", IPP_TAG_NAME);\n\n  if (attr)\n  {\n    ippSetValueTag(job->attrs, &attr, IPP_TAG_KEYWORD);\n    ippSetString(job->attrs, &attr, 0, \"no-hold\");\n  }\n\n /*\n  * Release the job and return...\n  */\n\n  cupsdReleaseJob(job);\n\n  cupsdAddEvent(CUPSD_EVENT_JOB_STATE, NULL, job, \"Job authenticated by user\");\n\n  cupsdLogJob(job, CUPSD_LOG_INFO, \"Authenticated by \\\"%s\\\".\", con->username);\n\n  cupsdCheckJobs();\n}\n\n\n/*\n * 'cancel_all_jobs()' - Cancel all or selected print jobs.\n */\n\nstatic void\ncancel_all_jobs(cupsd_client_t  *con,\t/* I - Client connection */\n\t        ipp_attribute_t *uri)\t/* I - Job or Printer URI */\n{\n  int\t\ti;\t\t\t/* Looping var */\n  http_status_t\tstatus;\t\t\t/* Policy status */\n  cups_ptype_t\tdtype;\t\t\t/* Destination type */\n  char\t\tscheme[HTTP_MAX_URI],\t/* Scheme portion of URI */\n\t\tuserpass[HTTP_MAX_URI],\t/* Username portion of URI */\n\t\thostname[HTTP_MAX_URI],\t/* Host portion of URI */\n\t\tresource[HTTP_MAX_URI];\t/* Resource portion of URI */\n  int\t\tport;\t\t\t/* Port portion of URI */\n  ipp_attribute_t *attr;\t\t/* Attribute in request */\n  const char\t*username = NULL;\t/* Username */\n  cupsd_jobaction_t purge = CUPSD_JOB_DEFAULT;\n\t\t\t\t\t/* Purge? */\n  cupsd_printer_t *printer;\t\t/* Printer */\n  ipp_attribute_t *job_ids;\t\t/* job-ids attribute */\n  cupsd_job_t\t*job;\t\t\t/* Job */\n\n\n  cupsdLogMessage(CUPSD_LOG_DEBUG2, \"cancel_all_jobs(%p[%d], %s)\", con,\n                  con->number, uri->values[0].string.text);\n\n /*\n  * Get the jobs to cancel/purge...\n  */\n\n  switch (con->request->request.op.operation_id)\n  {\n    case IPP_PURGE_JOBS :\n       /*\n\t* Get the username (if any) for the jobs we want to cancel (only if\n\t* \"my-jobs\" is specified...\n\t*/\n\n        if ((attr = ippFindAttribute(con->request, \"my-jobs\",\n                                     IPP_TAG_BOOLEAN)) != NULL &&\n            attr->values[0].boolean)\n\t{\n\t  if ((attr = ippFindAttribute(con->request, \"requesting-user-name\",\n\t\t\t\t       IPP_TAG_NAME)) != NULL)\n\t    username = attr->values[0].string.text;\n\t  else\n\t  {\n\t    send_ipp_status(con, IPP_BAD_REQUEST,\n\t\t\t    _(\"Missing requesting-user-name attribute.\"));\n\t    return;\n\t  }\n\t}\n\n       /*\n\t* Look for the \"purge-jobs\" attribute...\n\t*/\n\n\tif ((attr = ippFindAttribute(con->request, \"purge-jobs\",\n\t\t\t\t     IPP_TAG_BOOLEAN)) != NULL)\n\t  purge = attr->values[0].boolean ? CUPSD_JOB_PURGE : CUPSD_JOB_DEFAULT;\n\telse\n\t  purge = CUPSD_JOB_PURGE;\n\tbreak;\n\n    case IPP_CANCEL_MY_JOBS :\n        if (con->username[0])\n          username = con->username;\n        else if ((attr = ippFindAttribute(con->request, \"requesting-user-name\",\n\t\t\t\t\t  IPP_TAG_NAME)) != NULL)\n          username = attr->values[0].string.text;\n        else\n        {\n\t  send_ipp_status(con, IPP_BAD_REQUEST,\n\t\t\t  _(\"Missing requesting-user-name attribute.\"));\n\t  return;\n        }\n\n    default :\n        break;\n  }\n\n  job_ids = ippFindAttribute(con->request, \"job-ids\", IPP_TAG_INTEGER);\n\n /*\n  * See if we have a printer URI...\n  */\n\n  if (strcmp(uri->name, \"printer-uri\"))\n  {\n    send_ipp_status(con, IPP_BAD_REQUEST,\n                    _(\"The printer-uri attribute is required.\"));\n    return;\n  }\n\n /*\n  * And if the destination is valid...\n  */\n\n  if (!cupsdValidateDest(uri->values[0].string.text, &dtype, &printer))\n  {\n   /*\n    * Bad URI?\n    */\n\n    httpSeparateURI(HTTP_URI_CODING_ALL, uri->values[0].string.text,\n                    scheme, sizeof(scheme), userpass, sizeof(userpass),\n\t\t    hostname, sizeof(hostname), &port,\n\t\t    resource, sizeof(resource));\n\n    if ((!strncmp(resource, \"/printers/\", 10) && resource[10]) ||\n        (!strncmp(resource, \"/classes/\", 9) && resource[9]))\n    {\n      send_ipp_status(con, IPP_NOT_FOUND,\n                      _(\"The printer or class does not exist.\"));\n      return;\n    }\n\n   /*\n    * Check policy...\n    */\n\n    if ((status = cupsdCheckPolicy(DefaultPolicyPtr, con, NULL)) != HTTP_OK)\n    {\n      send_http_error(con, status, NULL);\n      return;\n    }\n\n    if (job_ids)\n    {\n      for (i = 0; i < job_ids->num_values; i ++)\n      {\n\tif ((job = cupsdFindJob(job_ids->values[i].integer)) == NULL)\n\t  break;\n\n        if (con->request->request.op.operation_id == IPP_CANCEL_MY_JOBS &&\n            _cups_strcasecmp(job->username, username))\n          break;\n      }\n\n      if (i < job_ids->num_values)\n      {\n\tsend_ipp_status(con, IPP_NOT_FOUND, _(\"Job #%d does not exist.\"),\n\t\t\tjob_ids->values[i].integer);\n\treturn;\n      }\n\n      for (i = 0; i < job_ids->num_values; i ++)\n      {\n\tjob = cupsdFindJob(job_ids->values[i].integer);\n\n\tcupsdSetJobState(job, IPP_JOB_CANCELED, purge,\n\t                 purge == CUPSD_JOB_PURGE ? \"Job purged by user.\" :\n\t                                            \"Job canceled by user.\");\n      }\n\n      cupsdLogMessage(CUPSD_LOG_INFO, \"Selected jobs were %s by \\\"%s\\\".\",\n\t\t      purge == CUPSD_JOB_PURGE ? \"purged\" : \"canceled\",\n\t\t      get_username(con));\n    }\n    else\n    {\n     /*\n      * Cancel all jobs on all printers...\n      */\n\n      cupsdCancelJobs(NULL, username, purge);\n\n      cupsdLogMessage(CUPSD_LOG_INFO, \"All jobs were %s by \\\"%s\\\".\",\n\t\t      purge == CUPSD_JOB_PURGE ? \"purged\" : \"canceled\",\n\t\t      get_username(con));\n    }\n  }\n  else\n  {\n   /*\n    * Check policy...\n    */\n\n    if ((status = cupsdCheckPolicy(printer->op_policy_ptr, con,\n                                   NULL)) != HTTP_OK)\n    {\n      send_http_error(con, status, printer);\n      return;\n    }\n\n    if (job_ids)\n    {\n      for (i = 0; i < job_ids->num_values; i ++)\n      {\n\tif ((job = cupsdFindJob(job_ids->values[i].integer)) == NULL ||\n\t    _cups_strcasecmp(job->dest, printer->name))\n\t  break;\n\n        if (con->request->request.op.operation_id == IPP_CANCEL_MY_JOBS &&\n            _cups_strcasecmp(job->username, username))\n          break;\n      }\n\n      if (i < job_ids->num_values)\n      {\n\tsend_ipp_status(con, IPP_NOT_FOUND, _(\"Job #%d does not exist.\"),\n\t\t\tjob_ids->values[i].integer);\n\treturn;\n      }\n\n      for (i = 0; i < job_ids->num_values; i ++)\n      {\n\tjob = cupsdFindJob(job_ids->values[i].integer);\n\n\tcupsdSetJobState(job, IPP_JOB_CANCELED, purge,\n\t                 purge == CUPSD_JOB_PURGE ? \"Job purged by user.\" :\n\t                                            \"Job canceled by user.\");\n      }\n\n      cupsdLogMessage(CUPSD_LOG_INFO, \"Selected jobs were %s by \\\"%s\\\".\",\n\t\t      purge == CUPSD_JOB_PURGE ? \"purged\" : \"canceled\",\n\t\t      get_username(con));\n    }\n    else\n    {\n     /*\n      * Cancel all of the jobs on the named printer...\n      */\n\n      cupsdCancelJobs(printer->name, username, purge);\n\n      cupsdLogMessage(CUPSD_LOG_INFO, \"All jobs on \\\"%s\\\" were %s by \\\"%s\\\".\",\n\t\t      printer->name,\n\t\t      purge == CUPSD_JOB_PURGE ? \"purged\" : \"canceled\",\n\t\t      get_username(con));\n    }\n  }\n\n  con->response->request.status.status_code = IPP_OK;\n\n  cupsdCheckJobs();\n}\n\n\n/*\n * 'cancel_job()' - Cancel a print job.\n */\n\nstatic void\ncancel_job(cupsd_client_t  *con,\t/* I - Client connection */\n\t   ipp_attribute_t *uri)\t/* I - Job or Printer URI */\n{\n  ipp_attribute_t *attr;\t\t/* Current attribute */\n  int\t\tjobid;\t\t\t/* Job ID */\n  char\t\tscheme[HTTP_MAX_URI],\t/* Scheme portion of URI */\n\t\tusername[HTTP_MAX_URI],\t/* Username portion of URI */\n\t\thost[HTTP_MAX_URI],\t/* Host portion of URI */\n\t\tresource[HTTP_MAX_URI];\t/* Resource portion of URI */\n  int\t\tport;\t\t\t/* Port portion of URI */\n  cupsd_job_t\t*job;\t\t\t/* Job information */\n  cups_ptype_t\tdtype;\t\t\t/* Destination type (printer/class) */\n  cupsd_printer_t *printer;\t\t/* Printer data */\n  cupsd_jobaction_t purge;\t\t/* Purge the job? */\n\n\n  cupsdLogMessage(CUPSD_LOG_DEBUG2, \"cancel_job(%p[%d], %s)\", con,\n                  con->number, uri->values[0].string.text);\n\n /*\n  * See if we have a job URI or a printer URI...\n  */\n\n  if (!strcmp(uri->name, \"printer-uri\"))\n  {\n   /*\n    * Got a printer URI; see if we also have a job-id attribute...\n    */\n\n    if ((attr = ippFindAttribute(con->request, \"job-id\",\n                                 IPP_TAG_INTEGER)) == NULL)\n    {\n      send_ipp_status(con, IPP_BAD_REQUEST,\n                      _(\"Got a printer-uri attribute but no job-id.\"));\n      return;\n    }\n\n    if ((jobid = attr->values[0].integer) == 0)\n    {\n     /*\n      * Find the current job on the specified printer...\n      */\n\n      if (!cupsdValidateDest(uri->values[0].string.text, &dtype, &printer))\n      {\n       /*\n\t* Bad URI...\n\t*/\n\n\tsend_ipp_status(con, IPP_NOT_FOUND,\n                \t_(\"The printer or class does not exist.\"));\n\treturn;\n      }\n\n     /*\n      * See if there are any pending jobs...\n      */\n\n      for (job = (cupsd_job_t *)cupsArrayFirst(ActiveJobs);\n\t   job;\n\t   job = (cupsd_job_t *)cupsArrayNext(ActiveJobs))\n\tif (job->state_value <= IPP_JOB_PROCESSING &&\n\t    !_cups_strcasecmp(job->dest, printer->name))\n\t  break;\n\n      if (job)\n\tjobid = job->id;\n      else\n      {\n       /*\n        * No, try stopped jobs...\n\t*/\n\n\tfor (job = (cupsd_job_t *)cupsArrayFirst(ActiveJobs);\n\t     job;\n\t     job = (cupsd_job_t *)cupsArrayNext(ActiveJobs))\n\t  if (job->state_value == IPP_JOB_STOPPED &&\n\t      !_cups_strcasecmp(job->dest, printer->name))\n\t    break;\n\n\tif (job)\n\t  jobid = job->id;\n\telse\n\t{\n\t  send_ipp_status(con, IPP_NOT_POSSIBLE, _(\"No active jobs on %s.\"),\n\t\t\t  printer->name);\n\t  return;\n\t}\n      }\n    }\n  }\n  else\n  {\n   /*\n    * Got a job URI; parse it to get the job ID...\n    */\n\n    httpSeparateURI(HTTP_URI_CODING_ALL, uri->values[0].string.text, scheme,\n                    sizeof(scheme), username, sizeof(username), host,\n\t\t    sizeof(host), &port, resource, sizeof(resource));\n\n    if (strncmp(resource, \"/jobs/\", 6))\n    {\n     /*\n      * Not a valid URI!\n      */\n\n      send_ipp_status(con, IPP_BAD_REQUEST, _(\"Bad job-uri \\\"%s\\\".\"),\n                      uri->values[0].string.text);\n      return;\n    }\n\n    jobid = atoi(resource + 6);\n  }\n\n /*\n  * Look for the \"purge-job\" attribute...\n  */\n\n  if ((attr = ippFindAttribute(con->request, \"purge-job\",\n                               IPP_TAG_BOOLEAN)) != NULL)\n    purge = attr->values[0].boolean ? CUPSD_JOB_PURGE : CUPSD_JOB_DEFAULT;\n  else\n    purge = CUPSD_JOB_DEFAULT;\n\n /*\n  * See if the job exists...\n  */\n\n  if ((job = cupsdFindJob(jobid)) == NULL)\n  {\n   /*\n    * Nope - return a \"not found\" error...\n    */\n\n    send_ipp_status(con, IPP_NOT_FOUND, _(\"Job #%d does not exist.\"), jobid);\n    return;\n  }\n\n /*\n  * See if the job is owned by the requesting user...\n  */\n\n  if (!validate_user(job, con, job->username, username, sizeof(username)))\n  {\n    send_http_error(con, con->username[0] ? HTTP_FORBIDDEN : HTTP_UNAUTHORIZED,\n                    cupsdFindDest(job->dest));\n    return;\n  }\n\n /*\n  * See if the job is already completed, canceled, or aborted; if so,\n  * we can't cancel...\n  */\n\n  if (job->state_value >= IPP_JOB_CANCELED && purge != CUPSD_JOB_PURGE)\n  {\n    switch (job->state_value)\n    {\n      case IPP_JOB_CANCELED :\n\t  send_ipp_status(con, IPP_NOT_POSSIBLE,\n                \t  _(\"Job #%d is already canceled - can\\'t cancel.\"),\n\t\t\t  jobid);\n          break;\n\n      case IPP_JOB_ABORTED :\n\t  send_ipp_status(con, IPP_NOT_POSSIBLE,\n                \t  _(\"Job #%d is already aborted - can\\'t cancel.\"),\n\t\t\t  jobid);\n          break;\n\n      default :\n\t  send_ipp_status(con, IPP_NOT_POSSIBLE,\n                \t  _(\"Job #%d is already completed - can\\'t cancel.\"),\n\t\t\t  jobid);\n          break;\n    }\n\n    return;\n  }\n\n /*\n  * Cancel the job and return...\n  */\n\n  cupsdSetJobState(job, IPP_JOB_CANCELED, purge,\n                   purge == CUPSD_JOB_PURGE ? \"Job purged by \\\"%s\\\"\" :\n\t\t                              \"Job canceled by \\\"%s\\\"\",\n\t\t   username);\n  cupsdCheckJobs();\n\n  if (purge == CUPSD_JOB_PURGE)\n    cupsdLogMessage(CUPSD_LOG_INFO, \"[Job %d] Purged by \\\"%s\\\".\", jobid,\n\t\t    username);\n  else\n    cupsdLogMessage(CUPSD_LOG_INFO, \"[Job %d] Canceled by \\\"%s\\\".\", jobid,\n\t\t    username);\n\n  con->response->request.status.status_code = IPP_OK;\n}\n\n\n/*\n * 'cancel_subscription()' - Cancel a subscription.\n */\n\nstatic void\ncancel_subscription(\n    cupsd_client_t *con,\t\t/* I - Client connection */\n    int            sub_id)\t\t/* I - Subscription ID */\n{\n  http_status_t\t\tstatus;\t\t/* Policy status */\n  cupsd_subscription_t\t*sub;\t\t/* Subscription */\n\n\n  cupsdLogMessage(CUPSD_LOG_DEBUG2,\n                  \"cancel_subscription(con=%p[%d], sub_id=%d)\",\n                  con, con->number, sub_id);\n\n /*\n  * Is the subscription ID valid?\n  */\n\n  if ((sub = cupsdFindSubscription(sub_id)) == NULL)\n  {\n   /*\n    * Bad subscription ID...\n    */\n\n    send_ipp_status(con, IPP_NOT_FOUND,\n                    _(\"Subscription #%d does not exist.\"), sub_id);\n    return;\n  }\n\n /*\n  * Check policy...\n  */\n\n  if ((status = cupsdCheckPolicy(sub->dest ? sub->dest->op_policy_ptr :\n                                             DefaultPolicyPtr,\n                                 con, sub->owner)) != HTTP_OK)\n  {\n    send_http_error(con, status, sub->dest);\n    return;\n  }\n\n /*\n  * Cancel the subscription...\n  */\n\n  cupsdDeleteSubscription(sub, 1);\n\n  con->response->request.status.status_code = IPP_OK;\n}\n\n\n/*\n * 'check_rss_recipient()' - Check that we do not have a duplicate RSS feed URI.\n */\n\nstatic int\t\t\t\t/* O - 1 if OK, 0 if not */\ncheck_rss_recipient(\n    const char *recipient)\t\t/* I - Recipient URI */\n{\n  cupsd_subscription_t\t*sub;\t\t/* Current subscription */\n\n\n  for (sub = (cupsd_subscription_t *)cupsArrayFirst(Subscriptions);\n       sub;\n       sub = (cupsd_subscription_t *)cupsArrayNext(Subscriptions))\n    if (sub->recipient)\n    {\n     /*\n      * Compare the URIs up to the first ?...\n      */\n\n      const char *r1, *r2;\n\n      for (r1 = recipient, r2 = sub->recipient;\n           *r1 == *r2 && *r1 && *r1 != '?' && *r2 && *r2 != '?';\n\t   r1 ++, r2 ++);\n\n      if (*r1 == *r2)\n        return (0);\n    }\n\n  return (1);\n}\n\n\n/*\n * 'check_quotas()' - Check quotas for a printer and user.\n */\n\nstatic int\t\t\t\t/* O - 1 if OK, 0 if forbidden,\n\t\t\t\t\t       -1 if limit reached */\ncheck_quotas(cupsd_client_t  *con,\t/* I - Client connection */\n             cupsd_printer_t *p)\t/* I - Printer or class */\n{\n  char\t\tusername[33],\t\t/* Username */\n\t\t*name;\t\t\t/* Current user name */\n  cupsd_quota_t\t*q;\t\t\t/* Quota data */\n#ifdef HAVE_MBR_UID_TO_UUID\n /*\n  * Use Apple membership APIs which require that all names represent\n  * valid user account or group records accessible by the server.\n  */\n\n  uuid_t\tusr_uuid;\t\t/* UUID for job requesting user  */\n  uuid_t\tusr2_uuid;\t\t/* UUID for ACL user name entry  */\n  uuid_t\tgrp_uuid;\t\t/* UUID for ACL group name entry */\n  int\t\tmbr_err;\t\t/* Error from membership function */\n  int\t\tis_member;\t\t/* Is this user a member? */\n#else\n /*\n  * Use standard POSIX APIs for checking users and groups...\n  */\n\n  struct passwd\t*pw;\t\t\t/* User password data */\n#endif /* HAVE_MBR_UID_TO_UUID */\n\n\n  cupsdLogMessage(CUPSD_LOG_DEBUG2, \"check_quotas(%p[%d], %p[%s])\",\n                  con, con->number, p, p->name);\n\n /*\n  * Figure out who is printing...\n  */\n\n  strlcpy(username, get_username(con), sizeof(username));\n\n  if ((name = strchr(username, '@')) != NULL)\n    *name = '\\0';\t\t\t/* Strip @REALM */\n\n /*\n  * Check global active job limits for printers and users...\n  */\n\n  if (MaxJobsPerPrinter)\n  {\n   /*\n    * Check if there are too many pending jobs on this printer...\n    */\n\n    if (cupsdGetPrinterJobCount(p->name) >= MaxJobsPerPrinter)\n    {\n      cupsdLogMessage(CUPSD_LOG_INFO, \"Too many jobs for printer \\\"%s\\\"...\",\n                      p->name);\n      return (-1);\n    }\n  }\n\n  if (MaxJobsPerUser)\n  {\n   /*\n    * Check if there are too many pending jobs for this user...\n    */\n\n    if (cupsdGetUserJobCount(username) >= MaxJobsPerUser)\n    {\n      cupsdLogMessage(CUPSD_LOG_INFO, \"Too many jobs for user \\\"%s\\\"...\",\n                      username);\n      return (-1);\n    }\n  }\n\n /*\n  * Check against users...\n  */\n\n  if (cupsArrayCount(p->users) == 0 && p->k_limit == 0 && p->page_limit == 0)\n    return (1);\n\n  if (cupsArrayCount(p->users))\n  {\n#ifdef HAVE_MBR_UID_TO_UUID\n   /*\n    * Get UUID for job requesting user...\n    */\n\n    if (mbr_user_name_to_uuid((char *)username, usr_uuid))\n    {\n     /*\n      * Unknown user...\n      */\n\n      cupsdLogMessage(CUPSD_LOG_DEBUG,\n\t\t      \"check_quotas: UUID lookup failed for user \\\"%s\\\"\",\n\t\t      username);\n      cupsdLogMessage(CUPSD_LOG_INFO,\n\t\t      \"Denying user \\\"%s\\\" access to printer \\\"%s\\\" \"\n\t\t      \"(unknown user)...\",\n\t\t      username, p->name);\n      return (0);\n    }\n#else\n   /*\n    * Get UID and GID of requesting user...\n    */\n\n    pw = getpwnam(username);\n    endpwent();\n#endif /* HAVE_MBR_UID_TO_UUID */\n\n    for (name = (char *)cupsArrayFirst(p->users);\n         name;\n\t name = (char *)cupsArrayNext(p->users))\n      if (name[0] == '@')\n      {\n       /*\n        * Check group membership...\n\t*/\n\n#ifdef HAVE_MBR_UID_TO_UUID\n        if (name[1] == '#')\n\t{\n\t  if (uuid_parse(name + 2, grp_uuid))\n\t    uuid_clear(grp_uuid);\n\t}\n\telse if ((mbr_err = mbr_group_name_to_uuid(name + 1, grp_uuid)) != 0)\n\t{\n\t /*\n\t  * Invalid ACL entries are ignored for matching; just record a\n\t  * warning in the log...\n\t  */\n\n\t  cupsdLogMessage(CUPSD_LOG_DEBUG,\n\t                  \"check_quotas: UUID lookup failed for ACL entry \"\n\t\t\t  \"\\\"%s\\\" (err=%d)\", name, mbr_err);\n\t  cupsdLogMessage(CUPSD_LOG_WARN,\n\t                  \"Access control entry \\\"%s\\\" not a valid group name; \"\n\t\t\t  \"entry ignored\", name);\n\t}\n\n\tif ((mbr_err = mbr_check_membership(usr_uuid, grp_uuid,\n\t\t\t\t\t    &is_member)) != 0)\n\t{\n\t /*\n\t  * At this point, there should be no errors, but check anyways...\n\t  */\n\n\t  cupsdLogMessage(CUPSD_LOG_DEBUG,\n\t\t\t  \"check_quotas: group \\\"%s\\\" membership check \"\n\t\t\t  \"failed (err=%d)\", name + 1, mbr_err);\n\t  is_member = 0;\n\t}\n\n       /*\n\t* Stop if we found a match...\n\t*/\n\n\tif (is_member)\n\t  break;\n\n#else\n        if (cupsdCheckGroup(username, pw, name + 1))\n\t  break;\n#endif /* HAVE_MBR_UID_TO_UUID */\n      }\n#ifdef HAVE_MBR_UID_TO_UUID\n      else\n      {\n        if (name[0] == '#')\n\t{\n\t  if (uuid_parse(name + 1, usr2_uuid))\n\t    uuid_clear(usr2_uuid);\n        }\n        else if ((mbr_err = mbr_user_name_to_uuid(name, usr2_uuid)) != 0)\n    \t{\n\t /*\n\t  * Invalid ACL entries are ignored for matching; just record a\n\t  * warning in the log...\n\t  */\n\n          cupsdLogMessage(CUPSD_LOG_DEBUG,\n\t                  \"check_quotas: UUID lookup failed for ACL entry \"\n\t\t\t  \"\\\"%s\\\" (err=%d)\", name, mbr_err);\n          cupsdLogMessage(CUPSD_LOG_WARN,\n\t                  \"Access control entry \\\"%s\\\" not a valid user name; \"\n\t\t\t  \"entry ignored\", name);\n\t}\n\n\tif (!uuid_compare(usr_uuid, usr2_uuid))\n\t  break;\n      }\n#else\n      else if (!_cups_strcasecmp(username, name))\n\tbreak;\n#endif /* HAVE_MBR_UID_TO_UUID */\n\n    if ((name != NULL) == p->deny_users)\n    {\n      cupsdLogMessage(CUPSD_LOG_INFO,\n                      \"Denying user \\\"%s\\\" access to printer \\\"%s\\\"...\",\n        \t      username, p->name);\n      return (0);\n    }\n  }\n\n /*\n  * Check quotas...\n  */\n\n  if (p->k_limit || p->page_limit)\n  {\n    if ((q = cupsdUpdateQuota(p, username, 0, 0)) == NULL)\n    {\n      cupsdLogMessage(CUPSD_LOG_ERROR,\n                      \"Unable to allocate quota data for user \\\"%s\\\"\",\n                      username);\n      return (-1);\n    }\n\n    if ((q->k_count >= p->k_limit && p->k_limit) ||\n        (q->page_count >= p->page_limit && p->page_limit))\n    {\n      cupsdLogMessage(CUPSD_LOG_INFO, \"User \\\"%s\\\" is over the quota limit...\",\n                      username);\n      return (-1);\n    }\n  }\n\n /*\n  * If we have gotten this far, we're done!\n  */\n\n  return (1);\n}\n\n\n/*\n * 'close_job()' - Close a multi-file job.\n */\n\nstatic void\nclose_job(cupsd_client_t  *con,\t\t/* I - Client connection */\n          ipp_attribute_t *uri)\t\t/* I - Printer URI */\n{\n  cupsd_job_t\t\t*job;\t\t/* Job */\n  ipp_attribute_t\t*attr;\t\t/* Attribute */\n  char\t\t\tjob_uri[HTTP_MAX_URI],\n\t\t\t\t\t/* Job URI */\n\t\t\tusername[256];\t/* User name */\n\n\n  cupsdLogMessage(CUPSD_LOG_DEBUG2, \"close_job(%p[%d], %s)\", con,\n                  con->number, uri->values[0].string.text);\n\n /*\n  * See if we have a job URI or a printer URI...\n  */\n\n  if (strcmp(uri->name, \"printer-uri\"))\n  {\n   /*\n    * job-uri is not supported by Close-Job!\n    */\n\n    send_ipp_status(con, IPP_BAD_REQUEST,\n\t\t    _(\"Close-Job doesn't support the job-uri attribute.\"));\n    return;\n  }\n\n /*\n  * Got a printer URI; see if we also have a job-id attribute...\n  */\n\n  if ((attr = ippFindAttribute(con->request, \"job-id\",\n\t\t\t       IPP_TAG_INTEGER)) == NULL)\n  {\n    send_ipp_status(con, IPP_BAD_REQUEST,\n\t\t    _(\"Got a printer-uri attribute but no job-id.\"));\n    return;\n  }\n\n  if ((job = cupsdFindJob(attr->values[0].integer)) == NULL)\n  {\n   /*\n    * Nope - return a \"not found\" error...\n    */\n\n    send_ipp_status(con, IPP_NOT_FOUND, _(\"Job #%d does not exist.\"),\n                    attr->values[0].integer);\n    return;\n  }\n\n /*\n  * See if the job is owned by the requesting user...\n  */\n\n  if (!validate_user(job, con, job->username, username, sizeof(username)))\n  {\n    send_http_error(con, con->username[0] ? HTTP_FORBIDDEN : HTTP_UNAUTHORIZED,\n                    cupsdFindDest(job->dest));\n    return;\n  }\n\n /*\n  * Add any ending sheet...\n  */\n\n  if (cupsdTimeoutJob(job))\n    return;\n\n  if (job->state_value == IPP_JOB_STOPPED)\n  {\n    job->state->values[0].integer = IPP_JOB_PENDING;\n    job->state_value              = IPP_JOB_PENDING;\n  }\n  else if (job->state_value == IPP_JOB_HELD)\n  {\n    if ((attr = ippFindAttribute(job->attrs, \"job-hold-until\",\n\t\t\t\t IPP_TAG_KEYWORD)) == NULL)\n      attr = ippFindAttribute(job->attrs, \"job-hold-until\", IPP_TAG_NAME);\n\n    if (!attr || !strcmp(attr->values[0].string.text, \"no-hold\"))\n    {\n      job->state->values[0].integer = IPP_JOB_PENDING;\n      job->state_value              = IPP_JOB_PENDING;\n    }\n  }\n\n  job->dirty = 1;\n  cupsdMarkDirty(CUPSD_DIRTY_JOBS);\n\n /*\n  * Fill in the response info...\n  */\n\n  httpAssembleURIf(HTTP_URI_CODING_ALL, job_uri, sizeof(job_uri), \"ipp\", NULL,\n                   con->clientname, con->clientport, \"/jobs/%d\", job->id);\n  ippAddString(con->response, IPP_TAG_JOB, IPP_TAG_URI, \"job-uri\", NULL,\n               job_uri);\n\n  ippAddInteger(con->response, IPP_TAG_JOB, IPP_TAG_INTEGER, \"job-id\", job->id);\n\n  ippAddInteger(con->response, IPP_TAG_JOB, IPP_TAG_ENUM, \"job-state\",\n                job->state_value);\n\n  con->response->request.status.status_code = IPP_OK;\n\n /*\n  * Start the job if necessary...\n  */\n\n  cupsdCheckJobs();\n}\n\n\n/*\n * 'copy_attrs()' - Copy attributes from one request to another.\n */\n\nstatic void\ncopy_attrs(ipp_t        *to,\t\t/* I - Destination request */\n           ipp_t        *from,\t\t/* I - Source request */\n           cups_array_t *ra,\t\t/* I - Requested attributes */\n\t   ipp_tag_t    group,\t\t/* I - Group to copy */\n\t   int          quickcopy,\t/* I - Do a quick copy? */\n\t   cups_array_t *exclude)\t/* I - Attributes to exclude? */\n{\n  ipp_attribute_t\t*fromattr;\t/* Source attribute */\n\n\n  cupsdLogMessage(CUPSD_LOG_DEBUG2,\n                  \"copy_attrs(to=%p, from=%p, ra=%p, group=%x, quickcopy=%d)\",\n\t\t  to, from, ra, group, quickcopy);\n\n  if (!to || !from)\n    return;\n\n  for (fromattr = from->attrs; fromattr; fromattr = fromattr->next)\n  {\n   /*\n    * Filter attributes as needed...\n    */\n\n    if ((group != IPP_TAG_ZERO && fromattr->group_tag != group &&\n         fromattr->group_tag != IPP_TAG_ZERO) || !fromattr->name)\n      continue;\n\n    if (!strcmp(fromattr->name, \"document-password\") ||\n        !strcmp(fromattr->name, \"job-authorization-uri\") ||\n        !strcmp(fromattr->name, \"job-password\") ||\n        !strcmp(fromattr->name, \"job-password-encryption\") ||\n        !strcmp(fromattr->name, \"job-printer-uri\"))\n      continue;\n\n    if (exclude &&\n        (cupsArrayFind(exclude, fromattr->name) ||\n\t cupsArrayFind(exclude, \"all\")))\n    {\n     /*\n      * We need to exclude this attribute for security reasons; we require the\n      * job-id attribute regardless of the security settings for IPP\n      * conformance.\n      *\n      * The job-printer-uri attribute is handled by copy_job_attrs().\n      *\n      * Subscription attribute security is handled by copy_subscription_attrs().\n      */\n\n      if (strcmp(fromattr->name, \"job-id\"))\n        continue;\n    }\n\n    if (!ra || cupsArrayFind(ra, fromattr->name))\n    {\n     /*\n      * Don't send collection attributes by default to IPP/1.x clients\n      * since many do not support collections.  Also don't send\n      * media-col-database unless specifically requested by the client.\n      */\n\n      if (fromattr->value_tag == IPP_TAG_BEGIN_COLLECTION &&\n          !ra &&\n\t  (to->request.status.version[0] == 1 ||\n\t   !strcmp(fromattr->name, \"media-col-database\")))\n\tcontinue;\n\n      ippCopyAttribute(to, fromattr, quickcopy);\n    }\n  }\n}\n\n\n/*\n * 'copy_banner()' - Copy a banner file to the requests directory for the\n *                   specified job.\n */\n\nstatic int\t\t\t\t/* O - Size of banner file in kbytes */\ncopy_banner(cupsd_client_t *con,\t/* I - Client connection */\n            cupsd_job_t    *job,\t/* I - Job information */\n            const char     *name)\t/* I - Name of banner */\n{\n  int\t\ti;\t\t\t/* Looping var */\n  int\t\tkbytes;\t\t\t/* Size of banner file in kbytes */\n  char\t\tfilename[1024];\t\t/* Job filename */\n  cupsd_banner_t *banner;\t\t/* Pointer to banner */\n  cups_file_t\t*in;\t\t\t/* Input file */\n  cups_file_t\t*out;\t\t\t/* Output file */\n  int\t\tch;\t\t\t/* Character from file */\n  char\t\tattrname[255],\t\t/* Name of attribute */\n\t\t*s;\t\t\t/* Pointer into name */\n  ipp_attribute_t *attr;\t\t/* Attribute */\n\n\n  cupsdLogMessage(CUPSD_LOG_DEBUG2,\n                  \"copy_banner(con=%p[%d], job=%p[%d], name=\\\"%s\\\")\",\n                  con, con ? con->number : -1, job, job->id,\n\t\t  name ? name : \"(null)\");\n\n /*\n  * Find the banner; return if not found or \"none\"...\n  */\n\n  if (!name || !strcmp(name, \"none\") ||\n      (banner = cupsdFindBanner(name)) == NULL)\n    return (0);\n\n /*\n  * Open the banner and job files...\n  */\n\n  if (add_file(con, job, banner->filetype, 0))\n    return (-1);\n\n  snprintf(filename, sizeof(filename), \"%s/d%05d-%03d\", RequestRoot, job->id,\n           job->num_files);\n  if ((out = cupsFileOpen(filename, \"w\")) == NULL)\n  {\n    cupsdLogMessage(CUPSD_LOG_ERROR,\n                    \"Unable to create banner job file %s - %s\",\n                    filename, strerror(errno));\n    job->num_files --;\n    return (0);\n  }\n\n  fchmod(cupsFileNumber(out), 0640);\n  fchown(cupsFileNumber(out), RunUser, Group);\n\n /*\n  * Try the localized banner file under the subdirectory...\n  */\n\n  strlcpy(attrname, job->attrs->attrs->next->values[0].string.text,\n          sizeof(attrname));\n  if (strlen(attrname) > 2 && attrname[2] == '-')\n  {\n   /*\n    * Convert ll-cc to ll_CC...\n    */\n\n    attrname[2] = '_';\n    attrname[3] = (char)toupper(attrname[3] & 255);\n    attrname[4] = (char)toupper(attrname[4] & 255);\n  }\n\n  snprintf(filename, sizeof(filename), \"%s/banners/%s/%s\", DataDir,\n           attrname, name);\n\n  if (access(filename, 0) && strlen(attrname) > 2)\n  {\n   /*\n    * Wasn't able to find \"ll_CC\" locale file; try the non-national\n    * localization banner directory.\n    */\n\n    attrname[2] = '\\0';\n\n    snprintf(filename, sizeof(filename), \"%s/banners/%s/%s\", DataDir,\n             attrname, name);\n  }\n\n  if (access(filename, 0))\n  {\n   /*\n    * Use the non-localized banner file.\n    */\n\n    snprintf(filename, sizeof(filename), \"%s/banners/%s\", DataDir, name);\n  }\n\n  if ((in = cupsFileOpen(filename, \"r\")) == NULL)\n  {\n    cupsFileClose(out);\n    unlink(filename);\n    cupsdLogMessage(CUPSD_LOG_ERROR,\n                    \"Unable to open banner template file %s - %s\",\n                    filename, strerror(errno));\n    job->num_files --;\n    return (0);\n  }\n\n /*\n  * Parse the file to the end...\n  */\n\n  while ((ch = cupsFileGetChar(in)) != EOF)\n    if (ch == '{')\n    {\n     /*\n      * Get an attribute name...\n      */\n\n      for (s = attrname; (ch = cupsFileGetChar(in)) != EOF;)\n        if (!isalpha(ch & 255) && ch != '-' && ch != '?')\n          break;\n\telse if (s < (attrname + sizeof(attrname) - 1))\n          *s++ = (char)ch;\n\telse\n\t  break;\n\n      *s = '\\0';\n\n      if (ch != '}')\n      {\n       /*\n        * Ignore { followed by stuff that is not an attribute name...\n\t*/\n\n        cupsFilePrintf(out, \"{%s%c\", attrname, ch);\n\tcontinue;\n      }\n\n     /*\n      * See if it is defined...\n      */\n\n      if (attrname[0] == '?')\n        s = attrname + 1;\n      else\n        s = attrname;\n\n      if (!strcmp(s, \"printer-name\"))\n      {\n        cupsFilePuts(out, job->dest);\n\tcontinue;\n      }\n      else if ((attr = ippFindAttribute(job->attrs, s, IPP_TAG_ZERO)) == NULL)\n      {\n       /*\n        * See if we have a leading question mark...\n\t*/\n\n\tif (attrname[0] != '?')\n\t{\n\t /*\n          * Nope, write to file as-is; probably a PostScript procedure...\n\t  */\n\n\t  cupsFilePrintf(out, \"{%s}\", attrname);\n        }\n\n        continue;\n      }\n\n     /*\n      * Output value(s)...\n      */\n\n      for (i = 0; i < attr->num_values; i ++)\n      {\n\tif (i)\n\t  cupsFilePutChar(out, ',');\n\n\tswitch (attr->value_tag)\n\t{\n\t  case IPP_TAG_INTEGER :\n\t  case IPP_TAG_ENUM :\n\t      if (!strncmp(s, \"time-at-\", 8))\n\t      {\n\t        struct timeval tv;\t/* Time value */\n\n\t\ttv.tv_sec  = attr->values[i].integer;\n\t\ttv.tv_usec = 0;\n\n\t        cupsFilePuts(out, cupsdGetDateTime(&tv, CUPSD_TIME_STANDARD));\n\t      }\n\t      else\n\t        cupsFilePrintf(out, \"%d\", attr->values[i].integer);\n\t      break;\n\n\t  case IPP_TAG_BOOLEAN :\n\t      cupsFilePrintf(out, \"%d\", attr->values[i].boolean);\n\t      break;\n\n\t  case IPP_TAG_NOVALUE :\n\t      cupsFilePuts(out, \"novalue\");\n\t      break;\n\n\t  case IPP_TAG_RANGE :\n\t      cupsFilePrintf(out, \"%d-%d\", attr->values[i].range.lower,\n\t\t      attr->values[i].range.upper);\n\t      break;\n\n\t  case IPP_TAG_RESOLUTION :\n\t      cupsFilePrintf(out, \"%dx%d%s\", attr->values[i].resolution.xres,\n\t\t      attr->values[i].resolution.yres,\n\t\t      attr->values[i].resolution.units == IPP_RES_PER_INCH ?\n\t\t\t  \"dpi\" : \"dpcm\");\n\t      break;\n\n\t  case IPP_TAG_URI :\n          case IPP_TAG_STRING :\n\t  case IPP_TAG_TEXT :\n\t  case IPP_TAG_NAME :\n\t  case IPP_TAG_KEYWORD :\n\t  case IPP_TAG_CHARSET :\n\t  case IPP_TAG_LANGUAGE :\n\t      if (!_cups_strcasecmp(banner->filetype->type, \"postscript\"))\n\t      {\n\t       /*\n\t        * Need to quote strings for PS banners...\n\t\t*/\n\n\t        const char *p;\n\n\t\tfor (p = attr->values[i].string.text; *p; p ++)\n\t\t{\n\t\t  if (*p == '(' || *p == ')' || *p == '\\\\')\n\t\t  {\n\t\t    cupsFilePutChar(out, '\\\\');\n\t\t    cupsFilePutChar(out, *p);\n\t\t  }\n\t\t  else if (*p < 32 || *p > 126)\n\t\t    cupsFilePrintf(out, \"\\\\%03o\", *p & 255);\n\t\t  else\n\t\t    cupsFilePutChar(out, *p);\n\t\t}\n\t      }\n\t      else\n\t\tcupsFilePuts(out, attr->values[i].string.text);\n\t      break;\n\n          default :\n\t      break; /* anti-compiler-warning-code */\n\t}\n      }\n    }\n    else if (ch == '\\\\')\t/* Quoted char */\n    {\n      ch = cupsFileGetChar(in);\n\n      if (ch != '{')\t\t/* Only do special handling for \\{ */\n        cupsFilePutChar(out, '\\\\');\n\n      cupsFilePutChar(out, ch);\n    }\n    else\n      cupsFilePutChar(out, ch);\n\n  cupsFileClose(in);\n\n  kbytes = (cupsFileTell(out) + 1023) / 1024;\n\n  job->koctets += kbytes;\n\n  if ((attr = ippFindAttribute(job->attrs, \"job-k-octets\", IPP_TAG_INTEGER)) != NULL)\n    attr->values[0].integer += kbytes;\n\n  cupsFileClose(out);\n\n  return (kbytes);\n}\n\n\n/*\n * 'copy_file()' - Copy a PPD file...\n */\n\nstatic int\t\t\t\t/* O - 0 = success, -1 = error */\ncopy_file(const char *from,\t\t/* I - Source file */\n          const char *to,\t\t/* I - Destination file */\n\t  mode_t     mode)\t\t/* I - Permissions */\n{\n  cups_file_t\t*src,\t\t\t/* Source file */\n\t\t*dst;\t\t\t/* Destination file */\n  int\t\tbytes;\t\t\t/* Bytes to read/write */\n  char\t\tbuffer[2048];\t\t/* Copy buffer */\n\n\n  cupsdLogMessage(CUPSD_LOG_DEBUG2, \"copy_file(\\\"%s\\\", \\\"%s\\\")\", from, to);\n\n /*\n  * Open the source and destination file for a copy...\n  */\n\n  if ((src = cupsFileOpen(from, \"rb\")) == NULL)\n    return (-1);\n\n  if ((dst = cupsdCreateConfFile(to, mode)) == NULL)\n  {\n    cupsFileClose(src);\n    return (-1);\n  }\n\n /*\n  * Copy the source file to the destination...\n  */\n\n  while ((bytes = cupsFileRead(src, buffer, sizeof(buffer))) > 0)\n    if (cupsFileWrite(dst, buffer, (size_t)bytes) < bytes)\n    {\n      cupsFileClose(src);\n      cupsFileClose(dst);\n      return (-1);\n    }\n\n /*\n  * Close both files and return...\n  */\n\n  cupsFileClose(src);\n\n  return (cupsdCloseCreatedConfFile(dst, to));\n}\n\n\n/*\n * 'copy_model()' - Copy a PPD model file, substituting default values\n *                  as needed...\n */\n\nstatic int\t\t\t\t/* O - 0 = success, -1 = error */\ncopy_model(cupsd_client_t *con,\t\t/* I - Client connection */\n           const char     *from,\t/* I - Source file */\n           const char     *to)\t\t/* I - Destination file */\n{\n  fd_set\tinput;\t\t\t/* select() input set */\n  struct timeval timeout;\t\t/* select() timeout */\n  int\t\tmaxfd;\t\t\t/* Max file descriptor for select() */\n  char\t\ttempfile[1024];\t\t/* Temporary PPD file */\n  int\t\ttempfd;\t\t\t/* Temporary PPD file descriptor */\n  int\t\ttemppid;\t\t/* Process ID of cups-driverd */\n  int\t\ttemppipe[2];\t\t/* Temporary pipes */\n  char\t\t*argv[4],\t\t/* Command-line arguments */\n\t\t*envp[MAX_ENV];\t\t/* Environment */\n  cups_file_t\t*src,\t\t\t/* Source file */\n\t\t*dst;\t\t\t/* Destination file */\n  ppd_file_t\t*ppd;\t\t\t/* PPD file */\n  int\t\tbytes,\t\t\t/* Bytes from pipe */\n\t\ttotal;\t\t\t/* Total bytes from pipe */\n  char\t\tbuffer[2048];\t\t/* Copy buffer */\n  int\t\ti;\t\t\t/* Looping var */\n  char\t\toption[PPD_MAX_NAME],\t/* Option name */\n\t\tchoice[PPD_MAX_NAME];\t/* Choice name */\n  ppd_size_t\t*size;\t\t\t/* Default size */\n  int\t\tnum_defaults;\t\t/* Number of default options */\n  cups_option_t\t*defaults;\t\t/* Default options */\n  char\t\tcups_protocol[PPD_MAX_LINE];\n\t\t\t\t\t/* cupsProtocol attribute */\n\n\n  cupsdLogMessage(CUPSD_LOG_DEBUG2, \"copy_model(con=%p, from=\\\"%s\\\", to=\\\"%s\\\")\", con, from, to);\n\n /*\n  * Run cups-driverd to get the PPD file...\n  */\n\n  argv[0] = \"cups-driverd\";\n  argv[1] = \"cat\";\n  argv[2] = (char *)from;\n  argv[3] = NULL;\n\n  cupsdLoadEnv(envp, (int)(sizeof(envp) / sizeof(envp[0])));\n\n  snprintf(buffer, sizeof(buffer), \"%s/daemon/cups-driverd\", ServerBin);\n  snprintf(tempfile, sizeof(tempfile), \"%s/%d.ppd\", TempDir, con->number);\n  tempfd = open(tempfile, O_WRONLY | O_CREAT | O_TRUNC, 0600);\n  if (tempfd < 0 || cupsdOpenPipe(temppipe))\n    return (-1);\n\n  cupsdLogMessage(CUPSD_LOG_DEBUG,\n                  \"copy_model: Running \\\"cups-driverd cat %s\\\"...\", from);\n\n  if (!cupsdStartProcess(buffer, argv, envp, -1, temppipe[1], CGIPipes[1],\n                         -1, -1, 0, DefaultProfile, NULL, &temppid))\n  {\n    close(tempfd);\n    unlink(tempfile);\n\n    return (-1);\n  }\n\n  close(temppipe[1]);\n\n /*\n  * Wait up to 30 seconds for the PPD file to be copied...\n  */\n\n  total = 0;\n\n  if (temppipe[0] > CGIPipes[0])\n    maxfd = temppipe[0] + 1;\n  else\n    maxfd = CGIPipes[0] + 1;\n\n  for (;;)\n  {\n   /*\n    * See if we have data ready...\n    */\n\n    FD_ZERO(&input);\n    FD_SET(temppipe[0], &input);\n    FD_SET(CGIPipes[0], &input);\n\n    timeout.tv_sec  = 30;\n    timeout.tv_usec = 0;\n\n    if ((i = select(maxfd, &input, NULL, NULL, &timeout)) < 0)\n    {\n      if (errno == EINTR)\n        continue;\n      else\n        break;\n    }\n    else if (i == 0)\n    {\n     /*\n      * We have timed out...\n      */\n\n      break;\n    }\n\n    if (FD_ISSET(temppipe[0], &input))\n    {\n     /*\n      * Read the PPD file from the pipe, and write it to the PPD file.\n      */\n\n      if ((bytes = read(temppipe[0], buffer, sizeof(buffer))) > 0)\n      {\n\tif (write(tempfd, buffer, (size_t)bytes) < bytes)\n          break;\n\n\ttotal += bytes;\n      }\n      else\n\tbreak;\n    }\n\n    if (FD_ISSET(CGIPipes[0], &input))\n      cupsdUpdateCGI();\n  }\n\n  close(temppipe[0]);\n  close(tempfd);\n\n  if (!total)\n  {\n   /*\n    * No data from cups-deviced...\n    */\n\n    cupsdLogMessage(CUPSD_LOG_ERROR, \"copy_model: empty PPD file\");\n    unlink(tempfile);\n    return (-1);\n  }\n\n /*\n  * Open the source file for a copy...\n  */\n\n  if ((src = cupsFileOpen(tempfile, \"rb\")) == NULL)\n  {\n    unlink(tempfile);\n    return (-1);\n  }\n\n /*\n  * Read the source file and see what page sizes are supported...\n  */\n\n  if ((ppd = _ppdOpen(src, _PPD_LOCALIZATION_NONE)) == NULL)\n  {\n    cupsFileClose(src);\n    unlink(tempfile);\n    return (-1);\n  }\n\n /*\n  * Open the destination (if possible) and set the default options...\n  */\n\n  num_defaults     = 0;\n  defaults         = NULL;\n  cups_protocol[0] = '\\0';\n\n  if ((dst = cupsFileOpen(to, \"rb\")) != NULL)\n  {\n   /*\n    * Read all of the default lines from the old PPD...\n    */\n\n    while (cupsFileGets(dst, buffer, sizeof(buffer)))\n      if (!strncmp(buffer, \"*Default\", 8))\n      {\n       /*\n\t* Add the default option...\n\t*/\n\n        if (!ppd_parse_line(buffer, option, sizeof(option),\n\t                    choice, sizeof(choice)))\n        {\n\t  ppd_option_t\t*ppdo;\t\t/* PPD option */\n\n\n         /*\n\t  * Only add the default if the default hasn't already been\n\t  * set and the choice exists in the new PPD...\n\t  */\n\n\t  if (!cupsGetOption(option, num_defaults, defaults) &&\n\t      (ppdo = ppdFindOption(ppd, option)) != NULL &&\n\t      ppdFindChoice(ppdo, choice))\n            num_defaults = cupsAddOption(option, choice, num_defaults,\n\t                                 &defaults);\n        }\n      }\n      else if (!strncmp(buffer, \"*cupsProtocol:\", 14))\n        strlcpy(cups_protocol, buffer, sizeof(cups_protocol));\n\n    cupsFileClose(dst);\n  }\n  else if ((size = ppdPageSize(ppd, DefaultPaperSize)) != NULL)\n  {\n   /*\n    * Add the default media sizes...\n    */\n\n    num_defaults = cupsAddOption(\"PageSize\", size->name,\n                                 num_defaults, &defaults);\n    num_defaults = cupsAddOption(\"PageRegion\", size->name,\n                                 num_defaults, &defaults);\n    num_defaults = cupsAddOption(\"PaperDimension\", size->name,\n                                 num_defaults, &defaults);\n    num_defaults = cupsAddOption(\"ImageableArea\", size->name,\n                                 num_defaults, &defaults);\n  }\n\n  ppdClose(ppd);\n\n /*\n  * Open the destination file for a copy...\n  */\n\n  if ((dst = cupsdCreateConfFile(to, ConfigFilePerm)) == NULL)\n  {\n    cupsFreeOptions(num_defaults, defaults);\n    cupsFileClose(src);\n    unlink(tempfile);\n    return (-1);\n  }\n\n /*\n  * Copy the source file to the destination...\n  */\n\n  cupsFileRewind(src);\n\n  while (cupsFileGets(src, buffer, sizeof(buffer)))\n  {\n    if (!strncmp(buffer, \"*Default\", 8))\n    {\n     /*\n      * Check for an previous default option choice...\n      */\n\n      if (!ppd_parse_line(buffer, option, sizeof(option),\n\t                  choice, sizeof(choice)))\n      {\n        const char\t*val;\t\t/* Default option value */\n\n\n        if ((val = cupsGetOption(option, num_defaults, defaults)) != NULL)\n\t{\n\t /*\n\t  * Substitute the previous choice...\n\t  */\n\n\t  snprintf(buffer, sizeof(buffer), \"*Default%s: %s\", option, val);\n\t}\n      }\n    }\n\n    cupsFilePrintf(dst, \"%s\\n\", buffer);\n  }\n\n  if (cups_protocol[0])\n    cupsFilePrintf(dst, \"%s\\n\", cups_protocol);\n\n  cupsFreeOptions(num_defaults, defaults);\n\n /*\n  * Close both files and return...\n  */\n\n  cupsFileClose(src);\n\n  unlink(tempfile);\n\n  return (cupsdCloseCreatedConfFile(dst, to));\n}\n\n\n/*\n * 'copy_job_attrs()' - Copy job attributes.\n */\n\nstatic void\ncopy_job_attrs(cupsd_client_t *con,\t/* I - Client connection */\n\t       cupsd_job_t    *job,\t/* I - Job */\n\t       cups_array_t   *ra,\t/* I - Requested attributes array */\n\t       cups_array_t   *exclude)\t/* I - Private attributes array */\n{\n  char\tjob_uri[HTTP_MAX_URI];\t\t/* Job URI */\n\n\n /*\n  * Send the requested attributes for each job...\n  */\n\n  if (!cupsArrayFind(exclude, \"all\"))\n  {\n    if ((!exclude || !cupsArrayFind(exclude, \"number-of-documents\")) &&\n        (!ra || cupsArrayFind(ra, \"number-of-documents\")))\n      ippAddInteger(con->response, IPP_TAG_JOB, IPP_TAG_INTEGER,\n\t\t    \"number-of-documents\", job->num_files);\n\n    if ((!exclude || !cupsArrayFind(exclude, \"job-media-progress\")) &&\n        (!ra || cupsArrayFind(ra, \"job-media-progress\")))\n      ippAddInteger(con->response, IPP_TAG_JOB, IPP_TAG_INTEGER,\n\t\t    \"job-media-progress\", job->progress);\n\n    if ((!exclude || !cupsArrayFind(exclude, \"job-more-info\")) &&\n        (!ra || cupsArrayFind(ra, \"job-more-info\")))\n    {\n      httpAssembleURIf(HTTP_URI_CODING_ALL, job_uri, sizeof(job_uri), \"http\",\n                       NULL, con->clientname, con->clientport, \"/jobs/%d\",\n\t\t       job->id);\n      ippAddString(con->response, IPP_TAG_JOB, IPP_TAG_URI,\n\t\t   \"job-more-info\", NULL, job_uri);\n    }\n\n    if (job->state_value > IPP_JOB_PROCESSING &&\n\t(!exclude || !cupsArrayFind(exclude, \"job-preserved\")) &&\n        (!ra || cupsArrayFind(ra, \"job-preserved\")))\n      ippAddBoolean(con->response, IPP_TAG_JOB, \"job-preserved\",\n\t\t    job->num_files > 0);\n\n    if ((!exclude || !cupsArrayFind(exclude, \"job-printer-up-time\")) &&\n        (!ra || cupsArrayFind(ra, \"job-printer-up-time\")))\n      ippAddInteger(con->response, IPP_TAG_JOB, IPP_TAG_INTEGER,\n\t\t    \"job-printer-up-time\", time(NULL));\n  }\n\n  if (!ra || cupsArrayFind(ra, \"job-printer-uri\"))\n  {\n    httpAssembleURIf(HTTP_URI_CODING_ALL, job_uri, sizeof(job_uri), \"ipp\", NULL,\n\t\t     con->clientname, con->clientport,\n\t\t     (job->dtype & CUPS_PRINTER_CLASS) ? \"/classes/%s\" :\n\t\t                                         \"/printers/%s\",\n\t\t     job->dest);\n    ippAddString(con->response, IPP_TAG_JOB, IPP_TAG_URI,\n        \t \"job-printer-uri\", NULL, job_uri);\n  }\n\n  if (!ra || cupsArrayFind(ra, \"job-uri\"))\n  {\n    httpAssembleURIf(HTTP_URI_CODING_ALL, job_uri, sizeof(job_uri), \"ipp\", NULL,\n\t\t     con->clientname, con->clientport, \"/jobs/%d\",\n\t\t     job->id);\n    ippAddString(con->response, IPP_TAG_JOB, IPP_TAG_URI,\n        \t \"job-uri\", NULL, job_uri);\n  }\n\n  if (job->attrs)\n  {\n    copy_attrs(con->response, job->attrs, ra, IPP_TAG_JOB, 0, exclude);\n  }\n  else\n  {\n   /*\n    * Generate attributes from the job structure...\n    */\n\n    if (job->completed_time && (!ra || cupsArrayFind(ra, \"date-time-at-completed\")))\n      ippAddDate(con->response, IPP_TAG_JOB, \"date-time-at-completed\", ippTimeToDate(job->completed_time));\n\n    if (job->creation_time && (!ra || cupsArrayFind(ra, \"date-time-at-creation\")))\n      ippAddDate(con->response, IPP_TAG_JOB, \"date-time-at-creation\", ippTimeToDate(job->creation_time));\n\n    if (!ra || cupsArrayFind(ra, \"job-id\"))\n      ippAddInteger(con->response, IPP_TAG_JOB, IPP_TAG_INTEGER, \"job-id\", job->id);\n\n    if (!ra || cupsArrayFind(ra, \"job-k-octets\"))\n      ippAddInteger(con->response, IPP_TAG_JOB, IPP_TAG_INTEGER, \"job-k-octets\", job->koctets);\n\n    if (job->name && (!ra || cupsArrayFind(ra, \"job-name\")))\n      ippAddString(con->response, IPP_TAG_JOB, IPP_CONST_TAG(IPP_TAG_NAME), \"job-name\", NULL, job->name);\n\n    if (job->username && (!ra || cupsArrayFind(ra, \"job-originating-user-name\")))\n      ippAddString(con->response, IPP_TAG_JOB, IPP_CONST_TAG(IPP_TAG_NAME), \"job-originating-user-name\", NULL, job->username);\n\n    if (!ra || cupsArrayFind(ra, \"job-state\"))\n      ippAddInteger(con->response, IPP_TAG_JOB, IPP_TAG_ENUM, \"job-state\", (int)job->state_value);\n\n    if (!ra || cupsArrayFind(ra, \"job-state-reasons\"))\n    {\n      switch (job->state_value)\n      {\n        default : /* Should never get here for processing, pending, held, or stopped jobs since they don't get unloaded... */\n\t    break;\n        case IPP_JSTATE_ABORTED :\n\t    ippAddString(con->response, IPP_TAG_JOB, IPP_TAG_KEYWORD, \"job-state-reasons\", NULL, \"job-aborted-by-system\");\n\t    break;\n        case IPP_JSTATE_CANCELED :\n\t    ippAddString(con->response, IPP_TAG_JOB, IPP_TAG_KEYWORD, \"job-state-reasons\", NULL, \"job-canceled-by-user\");\n\t    break;\n        case IPP_JSTATE_COMPLETED :\n\t    ippAddString(con->response, IPP_TAG_JOB, IPP_TAG_KEYWORD, \"job-state-reasons\", NULL, \"job-completed-successfully\");\n\t    break;\n      }\n    }\n\n    if (job->completed_time && (!ra || cupsArrayFind(ra, \"time-at-completed\")))\n      ippAddInteger(con->response, IPP_TAG_JOB, IPP_TAG_INTEGER, \"time-at-completed\", (int)job->completed_time);\n\n    if (job->creation_time && (!ra || cupsArrayFind(ra, \"time-at-creation\")))\n      ippAddInteger(con->response, IPP_TAG_JOB, IPP_TAG_INTEGER, \"time-at-creation\", (int)job->creation_time);\n  }\n}\n\n\n/*\n * 'copy_printer_attrs()' - Copy printer attributes.\n */\n\nstatic void\ncopy_printer_attrs(\n    cupsd_client_t  *con,\t\t/* I - Client connection */\n    cupsd_printer_t *printer,\t\t/* I - Printer */\n    cups_array_t    *ra)\t\t/* I - Requested attributes array */\n{\n  char\t\t\tprinter_uri[HTTP_MAX_URI];\n\t\t\t\t\t/* Printer URI */\n  char\t\t\tprinter_icons[HTTP_MAX_URI];\n\t\t\t\t\t/* Printer icons */\n  time_t\t\tcurtime;\t/* Current time */\n  int\t\t\ti;\t\t/* Looping var */\n\n\n /*\n  * Copy the printer attributes to the response using requested-attributes\n  * and document-format attributes that may be provided by the client.\n  */\n\n  curtime = time(NULL);\n\n  if (!ra || cupsArrayFind(ra, \"marker-change-time\"))\n    ippAddInteger(con->response, IPP_TAG_PRINTER, IPP_TAG_INTEGER,\n                  \"marker-change-time\", printer->marker_time);\n\n  if (printer->num_printers > 0 &&\n      (!ra || cupsArrayFind(ra, \"member-uris\")))\n  {\n    ipp_attribute_t\t*member_uris;\t/* member-uris attribute */\n    cupsd_printer_t\t*p2;\t\t/* Printer in class */\n    ipp_attribute_t\t*p2_uri;\t/* printer-uri-supported for class printer */\n\n\n    if ((member_uris = ippAddStrings(con->response, IPP_TAG_PRINTER,\n                                     IPP_TAG_URI, \"member-uris\",\n\t\t\t\t     printer->num_printers, NULL,\n\t\t\t\t     NULL)) != NULL)\n    {\n      for (i = 0; i < printer->num_printers; i ++)\n      {\n        p2 = printer->printers[i];\n\n        if ((p2_uri = ippFindAttribute(p2->attrs, \"printer-uri-supported\",\n\t                               IPP_TAG_URI)) != NULL)\n          member_uris->values[i].string.text =\n\t      _cupsStrRetain(p2_uri->values[0].string.text);\n        else\n\t{\n\t  httpAssembleURIf(HTTP_URI_CODING_ALL, printer_uri,\n\t                   sizeof(printer_uri), \"ipp\", NULL, con->clientname,\n\t\t\t   con->clientport,\n\t\t\t   (p2->type & CUPS_PRINTER_CLASS) ?\n\t\t\t       \"/classes/%s\" : \"/printers/%s\", p2->name);\n\t  member_uris->values[i].string.text = _cupsStrAlloc(printer_uri);\n        }\n      }\n    }\n  }\n\n  if (printer->alert && (!ra || cupsArrayFind(ra, \"printer-alert\")))\n    ippAddString(con->response, IPP_TAG_PRINTER, IPP_TAG_STRING,\n                 \"printer-alert\", NULL, printer->alert);\n\n  if (printer->alert_description &&\n      (!ra || cupsArrayFind(ra, \"printer-alert-description\")))\n    ippAddString(con->response, IPP_TAG_PRINTER, IPP_TAG_TEXT,\n                 \"printer-alert-description\", NULL,\n\t\t printer->alert_description);\n\n  if (!ra || cupsArrayFind(ra, \"printer-config-change-date-time\"))\n    ippAddDate(con->response, IPP_TAG_PRINTER, \"printer-config-change-date-time\", ippTimeToDate(printer->config_time));\n\n  if (!ra || cupsArrayFind(ra, \"printer-config-change-time\"))\n    ippAddInteger(con->response, IPP_TAG_PRINTER, IPP_TAG_INTEGER,\n                  \"printer-config-change-time\", printer->config_time);\n\n  if (!ra || cupsArrayFind(ra, \"printer-current-time\"))\n    ippAddDate(con->response, IPP_TAG_PRINTER, \"printer-current-time\",\n               ippTimeToDate(curtime));\n\n#if defined(HAVE_DNSSD) || defined(HAVE_AVAHI)\n  if (!ra || cupsArrayFind(ra, \"printer-dns-sd-name\"))\n  {\n    if (printer->reg_name)\n      ippAddString(con->response, IPP_TAG_PRINTER, IPP_TAG_NAME,\n                   \"printer-dns-sd-name\", NULL, printer->reg_name);\n    else\n      ippAddInteger(con->response, IPP_TAG_PRINTER, IPP_TAG_NOVALUE,\n                   \"printer-dns-sd-name\", 0);\n  }\n#endif /* HAVE_DNSSD || HAVE_AVAHI */\n\n  if (!ra || cupsArrayFind(ra, \"printer-error-policy\"))\n    ippAddString(con->response, IPP_TAG_PRINTER, IPP_TAG_NAME,\n        \t \"printer-error-policy\", NULL, printer->error_policy);\n\n  if (!ra || cupsArrayFind(ra, \"printer-error-policy-supported\"))\n  {\n    static const char * const errors[] =/* printer-error-policy-supported values */\n\t\t  {\n\t\t    \"abort-job\",\n\t\t    \"retry-current-job\",\n\t\t    \"retry-job\",\n\t\t    \"stop-printer\"\n\t\t  };\n\n    if (printer->type & CUPS_PRINTER_CLASS)\n      ippAddString(con->response, IPP_TAG_PRINTER, IPP_TAG_NAME | IPP_TAG_COPY,\n                   \"printer-error-policy-supported\", NULL, \"retry-current-job\");\n    else\n      ippAddStrings(con->response, IPP_TAG_PRINTER, IPP_TAG_NAME | IPP_TAG_COPY,\n\t\t    \"printer-error-policy-supported\",\n\t\t    sizeof(errors) / sizeof(errors[0]), NULL, errors);\n  }\n\n  if (!ra || cupsArrayFind(ra, \"printer-icons\"))\n  {\n    httpAssembleURIf(HTTP_URI_CODING_ALL, printer_icons, sizeof(printer_icons),\n                     \"http\", NULL, con->clientname, con->clientport,\n\t\t     \"/icons/%s.png\", printer->name);\n    ippAddString(con->response, IPP_TAG_PRINTER, IPP_TAG_URI, \"printer-icons\",\n                 NULL, printer_icons);\n    cupsdLogMessage(CUPSD_LOG_DEBUG2, \"printer-icons=\\\"%s\\\"\", printer_icons);\n  }\n\n  if (!ra || cupsArrayFind(ra, \"printer-is-accepting-jobs\"))\n    ippAddBoolean(con->response, IPP_TAG_PRINTER, \"printer-is-accepting-jobs\", (char)printer->accepting);\n\n  if (!ra || cupsArrayFind(ra, \"printer-is-shared\"))\n    ippAddBoolean(con->response, IPP_TAG_PRINTER, \"printer-is-shared\", (char)printer->shared);\n\n  if (!ra || cupsArrayFind(ra, \"printer-is-temporary\"))\n    ippAddBoolean(con->response, IPP_TAG_PRINTER, \"printer-is-temporary\", (char)printer->temporary);\n\n  if (!ra || cupsArrayFind(ra, \"printer-more-info\"))\n  {\n    httpAssembleURIf(HTTP_URI_CODING_ALL, printer_uri, sizeof(printer_uri),\n                     \"http\", NULL, con->clientname, con->clientport,\n\t\t     (printer->type & CUPS_PRINTER_CLASS) ?\n\t\t         \"/classes/%s\" : \"/printers/%s\", printer->name);\n    ippAddString(con->response, IPP_TAG_PRINTER, IPP_TAG_URI,\n        \t \"printer-more-info\", NULL, printer_uri);\n  }\n\n  if (!ra || cupsArrayFind(ra, \"printer-op-policy\"))\n    ippAddString(con->response, IPP_TAG_PRINTER, IPP_TAG_NAME,\n        \t \"printer-op-policy\", NULL, printer->op_policy);\n\n  if (!ra || cupsArrayFind(ra, \"printer-state\"))\n    ippAddInteger(con->response, IPP_TAG_PRINTER, IPP_TAG_ENUM, \"printer-state\",\n                  printer->state);\n\n  if (!ra || cupsArrayFind(ra, \"printer-state-change-date-time\"))\n    ippAddDate(con->response, IPP_TAG_PRINTER, \"printer-state-change-date-time\", ippTimeToDate(printer->state_time));\n\n  if (!ra || cupsArrayFind(ra, \"printer-state-change-time\"))\n    ippAddInteger(con->response, IPP_TAG_PRINTER, IPP_TAG_INTEGER,\n                  \"printer-state-change-time\", printer->state_time);\n\n  if (!ra || cupsArrayFind(ra, \"printer-state-message\"))\n    ippAddString(con->response, IPP_TAG_PRINTER, IPP_TAG_TEXT,\n        \t \"printer-state-message\", NULL, printer->state_message);\n\n  if (!ra || cupsArrayFind(ra, \"printer-state-reasons\"))\n    add_printer_state_reasons(con, printer);\n\n  if (!ra || cupsArrayFind(ra, \"printer-type\"))\n  {\n    cups_ptype_t type;\t\t\t/* printer-type value */\n\n   /*\n    * Add the CUPS-specific printer-type attribute...\n    */\n\n    type = printer->type;\n\n    if (printer == DefaultPrinter)\n      type |= CUPS_PRINTER_DEFAULT;\n\n    if (!printer->accepting)\n      type |= CUPS_PRINTER_REJECTING;\n\n    if (!printer->shared)\n      type |= CUPS_PRINTER_NOT_SHARED;\n\n    ippAddInteger(con->response, IPP_TAG_PRINTER, IPP_TAG_ENUM, \"printer-type\", (int)type);\n  }\n\n  if (!ra || cupsArrayFind(ra, \"printer-up-time\"))\n    ippAddInteger(con->response, IPP_TAG_PRINTER, IPP_TAG_INTEGER,\n                  \"printer-up-time\", curtime);\n\n  if (!ra || cupsArrayFind(ra, \"printer-uri-supported\"))\n  {\n    httpAssembleURIf(HTTP_URI_CODING_ALL, printer_uri, sizeof(printer_uri),\n                     \"ipp\", NULL, con->clientname, con->clientport,\n\t\t     (printer->type & CUPS_PRINTER_CLASS) ?\n\t\t         \"/classes/%s\" : \"/printers/%s\", printer->name);\n    ippAddString(con->response, IPP_TAG_PRINTER, IPP_TAG_URI,\n        \t \"printer-uri-supported\", NULL, printer_uri);\n    cupsdLogMessage(CUPSD_LOG_DEBUG2, \"printer-uri-supported=\\\"%s\\\"\",\n                    printer_uri);\n  }\n\n  if (!ra || cupsArrayFind(ra, \"queued-job-count\"))\n    add_queued_job_count(con, printer);\n\n  copy_attrs(con->response, printer->attrs, ra, IPP_TAG_ZERO, 0, NULL);\n  if (printer->ppd_attrs)\n    copy_attrs(con->response, printer->ppd_attrs, ra, IPP_TAG_ZERO, 0, NULL);\n  copy_attrs(con->response, CommonData, ra, IPP_TAG_ZERO, IPP_TAG_COPY, NULL);\n}\n\n\n/*\n * 'copy_subscription_attrs()' - Copy subscription attributes.\n */\n\nstatic void\ncopy_subscription_attrs(\n    cupsd_client_t       *con,\t\t/* I - Client connection */\n    cupsd_subscription_t *sub,\t\t/* I - Subscription */\n    cups_array_t         *ra,\t\t/* I - Requested attributes array */\n    cups_array_t         *exclude)\t/* I - Private attributes array */\n{\n  ipp_attribute_t\t*attr;\t\t/* Current attribute */\n  char\t\t\tprinter_uri[HTTP_MAX_URI];\n\t\t\t\t\t/* Printer URI */\n  int\t\t\tcount;\t\t/* Number of events */\n  unsigned\t\tmask;\t\t/* Current event mask */\n  const char\t\t*name;\t\t/* Current event name */\n\n\n  cupsdLogMessage(CUPSD_LOG_DEBUG2,\n                  \"copy_subscription_attrs(con=%p, sub=%p, ra=%p, exclude=%p)\",\n\t\t  con, sub, ra, exclude);\n\n /*\n  * Copy the subscription attributes to the response using the\n  * requested-attributes attribute that may be provided by the client.\n  */\n\n  if (!exclude || !cupsArrayFind(exclude, \"all\"))\n  {\n    if ((!exclude || !cupsArrayFind(exclude, \"notify-events\")) &&\n        (!ra || cupsArrayFind(ra, \"notify-events\")))\n    {\n      cupsdLogMessage(CUPSD_LOG_DEBUG2, \"copy_subscription_attrs: notify-events\");\n\n      if ((name = cupsdEventName((cupsd_eventmask_t)sub->mask)) != NULL)\n      {\n       /*\n\t* Simple event list...\n\t*/\n\n\tippAddString(con->response, IPP_TAG_SUBSCRIPTION,\n\t\t     (ipp_tag_t)(IPP_TAG_KEYWORD | IPP_TAG_COPY),\n\t\t     \"notify-events\", NULL, name);\n      }\n      else\n      {\n       /*\n\t* Complex event list...\n\t*/\n\n\tfor (mask = 1, count = 0; mask < CUPSD_EVENT_ALL; mask <<= 1)\n\t  if (sub->mask & mask)\n\t    count ++;\n\n\tattr = ippAddStrings(con->response, IPP_TAG_SUBSCRIPTION,\n\t\t\t     (ipp_tag_t)(IPP_TAG_KEYWORD | IPP_TAG_COPY),\n\t\t\t     \"notify-events\", count, NULL, NULL);\n\n\tfor (mask = 1, count = 0; mask < CUPSD_EVENT_ALL; mask <<= 1)\n\t  if (sub->mask & mask)\n\t  {\n\t    attr->values[count].string.text =\n\t\t(char *)cupsdEventName((cupsd_eventmask_t)mask);\n\n\t    count ++;\n\t  }\n      }\n    }\n\n    if ((!exclude || !cupsArrayFind(exclude, \"notify-lease-duration\")) &&\n        (!sub->job && (!ra || cupsArrayFind(ra, \"notify-lease-duration\"))))\n      ippAddInteger(con->response, IPP_TAG_SUBSCRIPTION, IPP_TAG_INTEGER,\n\t\t    \"notify-lease-duration\", sub->lease);\n\n    if ((!exclude || !cupsArrayFind(exclude, \"notify-recipient-uri\")) &&\n        (sub->recipient && (!ra || cupsArrayFind(ra, \"notify-recipient-uri\"))))\n      ippAddString(con->response, IPP_TAG_SUBSCRIPTION, IPP_TAG_URI,\n\t\t   \"notify-recipient-uri\", NULL, sub->recipient);\n    else if ((!exclude || !cupsArrayFind(exclude, \"notify-pull-method\")) &&\n             (!ra || cupsArrayFind(ra, \"notify-pull-method\")))\n      ippAddString(con->response, IPP_TAG_SUBSCRIPTION, IPP_TAG_KEYWORD,\n\t\t   \"notify-pull-method\", NULL, \"ippget\");\n\n    if ((!exclude || !cupsArrayFind(exclude, \"notify-subscriber-user-name\")) &&\n        (!ra || cupsArrayFind(ra, \"notify-subscriber-user-name\")))\n      ippAddString(con->response, IPP_TAG_SUBSCRIPTION, IPP_TAG_NAME,\n\t\t   \"notify-subscriber-user-name\", NULL, sub->owner);\n\n    if ((!exclude || !cupsArrayFind(exclude, \"notify-time-interval\")) &&\n        (!ra || cupsArrayFind(ra, \"notify-time-interval\")))\n      ippAddInteger(con->response, IPP_TAG_SUBSCRIPTION, IPP_TAG_INTEGER,\n\t\t    \"notify-time-interval\", sub->interval);\n\n    if (sub->user_data_len > 0 &&\n\t(!exclude || !cupsArrayFind(exclude, \"notify-user-data\")) &&\n        (!ra || cupsArrayFind(ra, \"notify-user-data\")))\n      ippAddOctetString(con->response, IPP_TAG_SUBSCRIPTION, \"notify-user-data\",\n\t\t\tsub->user_data, sub->user_data_len);\n  }\n\n  if (sub->job && (!ra || cupsArrayFind(ra, \"notify-job-id\")))\n    ippAddInteger(con->response, IPP_TAG_SUBSCRIPTION, IPP_TAG_INTEGER,\n                  \"notify-job-id\", sub->job->id);\n\n  if (sub->dest && (!ra || cupsArrayFind(ra, \"notify-printer-uri\")))\n  {\n    httpAssembleURIf(HTTP_URI_CODING_ALL, printer_uri, sizeof(printer_uri),\n                     \"ipp\", NULL, con->clientname, con->clientport,\n\t\t     \"/printers/%s\", sub->dest->name);\n    ippAddString(con->response, IPP_TAG_SUBSCRIPTION, IPP_TAG_URI,\n        \t \"notify-printer-uri\", NULL, printer_uri);\n  }\n\n  if (!ra || cupsArrayFind(ra, \"notify-subscription-id\"))\n    ippAddInteger(con->response, IPP_TAG_SUBSCRIPTION, IPP_TAG_INTEGER,\n                  \"notify-subscription-id\", sub->id);\n}\n\n\n/*\n * 'create_job()' - Print a file to a printer or class.\n */\n\nstatic void\ncreate_job(cupsd_client_t  *con,\t/* I - Client connection */\n\t   ipp_attribute_t *uri)\t/* I - Printer URI */\n{\n  int\t\t\ti;\t\t/* Looping var */\n  cupsd_printer_t\t*printer;\t/* Printer */\n  cupsd_job_t\t\t*job;\t\t/* New job */\n  static const char * const forbidden_attrs[] =\n  {\t\t\t\t\t/* List of forbidden attributes */\n    \"compression\",\n    \"document-format\",\n    \"document-name\",\n    \"document-natural-language\"\n  };\n\n\n  cupsdLogMessage(CUPSD_LOG_DEBUG2, \"create_job(%p[%d], %s)\", con,\n                  con->number, uri->values[0].string.text);\n\n /*\n  * Is the destination valid?\n  */\n\n  if (!cupsdValidateDest(uri->values[0].string.text, NULL, &printer))\n  {\n   /*\n    * Bad URI...\n    */\n\n    send_ipp_status(con, IPP_NOT_FOUND,\n                    _(\"The printer or class does not exist.\"));\n    return;\n  }\n\n /*\n  * Check for invalid Create-Job attributes and log a warning or error depending\n  * on whether cupsd is running in \"strict conformance\" mode...\n  */\n\n  for (i = 0;\n       i < (int)(sizeof(forbidden_attrs) / sizeof(forbidden_attrs[0]));\n       i ++)\n    if (ippFindAttribute(con->request, forbidden_attrs[i], IPP_TAG_ZERO))\n    {\n      if (StrictConformance)\n      {\n\tsend_ipp_status(con, IPP_BAD_REQUEST,\n\t\t\t_(\"The '%s' operation attribute cannot be supplied in a \"\n\t\t\t  \"Create-Job request.\"), forbidden_attrs[i]);\n\treturn;\n      }\n\n      cupsdLogMessage(CUPSD_LOG_WARN,\n                      \"Unexpected '%s' operation attribute in a Create-Job \"\n                      \"request.\", forbidden_attrs[i]);\n    }\n\n /*\n  * Create the job object...\n  */\n\n  if ((job = add_job(con, printer, NULL)) == NULL)\n    return;\n\n  job->pending_timeout = 1;\n\n /*\n  * Save and log the job...\n  */\n\n  cupsdLogJob(job, CUPSD_LOG_INFO, \"Queued on \\\"%s\\\" by \\\"%s\\\".\",\n\t      job->dest, job->username);\n}\n\n\n/*\n * 'create_local_bg_thread()' - Background thread for creating a local print queue.\n */\n\nstatic void *\t\t\t\t/* O - Exit status */\ncreate_local_bg_thread(\n    cupsd_printer_t *printer)\t\t/* I - Printer */\n{\n  cups_file_t\t*from,\t\t\t/* Source file */\n\t\t*to;\t\t\t/* Destination file */\n  char\t\tfromppd[1024],\t\t/* Source PPD */\n\t\ttoppd[1024],\t\t/* Destination PPD */\n\t\tscheme[32],\t\t/* URI scheme */\n\t\tuserpass[256],\t\t/* User:pass */\n\t\thost[256],\t\t/* Hostname */\n\t\tresource[1024],\t\t/* Resource path */\n\t\tline[1024];\t\t/* Line from PPD */\n  int\t\tport;\t\t\t/* Port number */\n  http_encryption_t encryption;\t\t/* Type of encryption to use */\n  http_t\t*http;\t\t\t/* Connection to printer */\n  ipp_t\t\t*request,\t\t/* Request to printer */\n\t\t*response;\t\t/* Response from printer */\n  ipp_attribute_t *attr;\t\t/* Attribute in response */\n\n\n /*\n  * Try connecting to the printer...\n  */\n\n  cupsdLogMessage(CUPSD_LOG_DEBUG, \"%s: Generating PPD file from \\\"%s\\\"...\", printer->name, printer->device_uri);\n\n  if (httpSeparateURI(HTTP_URI_CODING_ALL, printer->device_uri, scheme, sizeof(scheme), userpass, sizeof(userpass), host, sizeof(host), &port, resource, sizeof(resource)) < HTTP_URI_STATUS_OK)\n  {\n    cupsdLogMessage(CUPSD_LOG_ERROR, \"%s: Bad device URI \\\"%s\\\".\", printer->name, printer->device_uri);\n    return (NULL);\n  }\n\n  if (!strcmp(scheme, \"ipps\") || port == 443)\n    encryption = HTTP_ENCRYPTION_ALWAYS;\n  else\n    encryption = HTTP_ENCRYPTION_IF_REQUESTED;\n\n  if ((http = httpConnect2(host, port, NULL, AF_UNSPEC, encryption, 1, 30000, NULL)) == NULL)\n  {\n    cupsdLogMessage(CUPSD_LOG_ERROR, \"%s: Unable to connect to %s:%d: %s\", printer->name, host, port, cupsLastErrorString());\n    return (NULL);\n  }\n\n /*\n  * Query the printer for its capabilities...\n  */\n\n  cupsdLogMessage(CUPSD_LOG_DEBUG, \"%s: Connected to %s:%d, sending Get-Printer-Attributes request...\", printer->name, host, port);\n\n  request = ippNewRequest(IPP_OP_GET_PRINTER_ATTRIBUTES);\n  ippAddString(request, IPP_TAG_OPERATION, IPP_TAG_URI, \"printer-uri\", NULL, printer->device_uri);\n  ippAddString(request, IPP_TAG_OPERATION, IPP_TAG_KEYWORD, \"requested-attributes\", NULL, \"all\");\n\n  response = cupsDoRequest(http, request, resource);\n\n  cupsdLogMessage(CUPSD_LOG_DEBUG, \"%s: Get-Printer-Attributes returned %s\", printer->name, ippErrorString(cupsLastError()));\n\n  // TODO: Grab printer icon file...\n  httpClose(http);\n\n /*\n  * Write the PPD for the queue...\n  */\n\n  if (_ppdCreateFromIPP(fromppd, sizeof(fromppd), response))\n  {\n    if ((!printer->info || !*(printer->info)) && (attr = ippFindAttribute(response, \"printer-info\", IPP_TAG_TEXT)) != NULL)\n      cupsdSetString(&printer->info, ippGetString(attr, 0, NULL));\n\n    if ((!printer->location || !*(printer->location)) && (attr = ippFindAttribute(response, \"printer-location\", IPP_TAG_TEXT)) != NULL)\n      cupsdSetString(&printer->location, ippGetString(attr, 0, NULL));\n\n    if ((!printer->geo_location || !*(printer->geo_location)) && (attr = ippFindAttribute(response, \"printer-geo-location\", IPP_TAG_URI)) != NULL)\n      cupsdSetString(&printer->geo_location, ippGetString(attr, 0, NULL));\n\n    if ((from = cupsFileOpen(fromppd, \"r\")) == NULL)\n    {\n      cupsdLogMessage(CUPSD_LOG_ERROR, \"%s: Unable to read generated PPD: %s\", printer->name, strerror(errno));\n      return (NULL);\n    }\n\n    snprintf(toppd, sizeof(toppd), \"%s/ppd/%s.ppd\", ServerRoot, printer->name);\n    if ((to = cupsdCreateConfFile(toppd, ConfigFilePerm)) == NULL)\n    {\n      cupsdLogMessage(CUPSD_LOG_ERROR, \"%s: Unable to create PPD for printer: %s\", printer->name, strerror(errno));\n      cupsFileClose(from);\n      return (NULL);\n    }\n\n    while (cupsFileGets(from, line, sizeof(line)))\n      cupsFilePrintf(to, \"%s\\n\", line);\n\n    cupsFileClose(from);\n    if (!cupsdCloseCreatedConfFile(to, toppd))\n    {\n      printer->config_time = time(NULL);\n      printer->state       = IPP_PSTATE_IDLE;\n      printer->accepting   = 1;\n\n      cupsdSetPrinterAttrs(printer);\n\n      cupsdAddEvent(CUPSD_EVENT_PRINTER_CONFIG, printer, NULL, \"Printer \\\"%s\\\" is now available.\", printer->name);\n      cupsdLogMessage(CUPSD_LOG_INFO, \"Printer \\\"%s\\\" is now available.\", printer->name);\n    }\n  }\n  else\n    cupsdLogMessage(CUPSD_LOG_ERROR, \"%s: PPD creation failed: %s\", printer->name, cupsLastErrorString());\n\n  return (NULL);\n}\n\n\n/*\n * 'create_local_printer()' - Create a local (temporary) print queue.\n */\n\nstatic void\ncreate_local_printer(\n    cupsd_client_t *con)\t\t/* I - Client connection */\n{\n  ipp_attribute_t *device_uri,\t\t/* device-uri attribute */\n\t\t*printer_geo_location,\t/* printer-geo-location attribute */\n\t\t*printer_info,\t\t/* printer-info attribute */\n\t\t*printer_location,\t/* printer-location attribute */\n\t\t*printer_name;\t\t/* printer-name attribute */\n  cupsd_printer_t *printer;\t\t/* New printer */\n  http_status_t\tstatus;\t\t\t/* Policy status */\n  char\t\tname[128],\t\t/* Sanitized printer name */\n\t\t*nameptr,\t\t/* Pointer into name */\n\t\turi[1024];\t\t/* printer-uri-supported value */\n  const char\t*ptr;\t\t\t/* Pointer into attribute value */\n\n\n /*\n  * Require local access to create a local printer...\n  */\n\n  if (!httpAddrLocalhost(httpGetAddress(con->http)))\n  {\n    send_ipp_status(con, IPP_STATUS_ERROR_FORBIDDEN, _(\"Only local users can create a local printer.\"));\n    return;\n  }\n\n /*\n  * Check any other policy limits...\n  */\n\n  if ((status = cupsdCheckPolicy(DefaultPolicyPtr, con, NULL)) != HTTP_OK)\n  {\n    send_http_error(con, status, NULL);\n    return;\n  }\n\n /*\n  * Grab needed attributes...\n  */\n\n  if ((printer_name = ippFindAttribute(con->request, \"printer-name\", IPP_TAG_ZERO)) == NULL || ippGetGroupTag(printer_name) != IPP_TAG_PRINTER || ippGetValueTag(printer_name) != IPP_TAG_NAME)\n  {\n    if (!printer_name)\n      send_ipp_status(con, IPP_STATUS_ERROR_BAD_REQUEST, _(\"Missing required attribute \\\"%s\\\".\"), \"printer-name\");\n    else if (ippGetGroupTag(printer_name) != IPP_TAG_PRINTER)\n      send_ipp_status(con, IPP_STATUS_ERROR_BAD_REQUEST, _(\"Attribute \\\"%s\\\" is in the wrong group.\"), \"printer-name\");\n    else\n      send_ipp_status(con, IPP_STATUS_ERROR_BAD_REQUEST, _(\"Attribute \\\"%s\\\" is the wrong value type.\"), \"printer-name\");\n\n    return;\n  }\n\n  for (nameptr = name, ptr = ippGetString(printer_name, 0, NULL); *ptr && nameptr < (name + sizeof(name) - 1); ptr ++)\n  {\n   /*\n    * Sanitize the printer name...\n    */\n\n    if (_cups_isalnum(*ptr))\n      *nameptr++ = *ptr;\n    else if (nameptr == name || nameptr[-1] != '_')\n      *nameptr++ = '_';\n  }\n\n  *nameptr = '\\0';\n\n  if ((device_uri = ippFindAttribute(con->request, \"device-uri\", IPP_TAG_ZERO)) == NULL || ippGetGroupTag(device_uri) != IPP_TAG_PRINTER || ippGetValueTag(device_uri) != IPP_TAG_URI)\n  {\n    if (!device_uri)\n      send_ipp_status(con, IPP_STATUS_ERROR_BAD_REQUEST, _(\"Missing required attribute \\\"%s\\\".\"), \"device-uri\");\n    else if (ippGetGroupTag(device_uri) != IPP_TAG_PRINTER)\n      send_ipp_status(con, IPP_STATUS_ERROR_BAD_REQUEST, _(\"Attribute \\\"%s\\\" is in the wrong group.\"), \"device-uri\");\n    else\n      send_ipp_status(con, IPP_STATUS_ERROR_BAD_REQUEST, _(\"Attribute \\\"%s\\\" is the wrong value type.\"), \"device-uri\");\n\n    return;\n  }\n\n  printer_geo_location = ippFindAttribute(con->request, \"printer-geo-location\", IPP_TAG_URI);\n  printer_info         = ippFindAttribute(con->request, \"printer-info\", IPP_TAG_TEXT);\n  printer_location     = ippFindAttribute(con->request, \"printer-location\", IPP_TAG_TEXT);\n\n /*\n  * See if the printer already exists...\n  */\n\n  if ((printer = cupsdFindDest(name)) != NULL)\n  {\n    send_ipp_status(con, IPP_STATUS_ERROR_NOT_POSSIBLE, _(\"Printer \\\"%s\\\" already exists.\"), name);\n    goto add_printer_attributes;\n  }\n\n /*\n  * Create the printer...\n  */\n\n  if ((printer = cupsdAddPrinter(name)) == NULL)\n  {\n    send_ipp_status(con, IPP_STATUS_ERROR_INTERNAL, _(\"Unable to create printer.\"));\n    return;\n  }\n\n  printer->shared    = 0;\n  printer->temporary = 1;\n\n  cupsdSetDeviceURI(printer, ippGetString(device_uri, 0, NULL));\n\n  if (printer_geo_location)\n    cupsdSetString(&printer->geo_location, ippGetString(printer_geo_location, 0, NULL));\n  if (printer_info)\n    cupsdSetString(&printer->info, ippGetString(printer_info, 0, NULL));\n  if (printer_location)\n    cupsdSetString(&printer->location, ippGetString(printer_location, 0, NULL));\n\n  cupsdSetPrinterAttrs(printer);\n\n /*\n  * Run a background thread to create the PPD...\n  */\n\n  _cupsThreadCreate((_cups_thread_func_t)create_local_bg_thread, printer);\n\n /*\n  * Return printer attributes...\n  */\n\n  send_ipp_status(con, IPP_STATUS_OK, _(\"Local printer created.\"));\n\n  add_printer_attributes:\n\n  ippAddBoolean(con->response, IPP_TAG_PRINTER, \"printer-is-accepting-jobs\", (char)printer->accepting);\n  ippAddInteger(con->response, IPP_TAG_PRINTER, IPP_TAG_ENUM, \"printer-state\", printer->state);\n  add_printer_state_reasons(con, printer);\n\n  httpAssembleURIf(HTTP_URI_CODING_ALL, uri, sizeof(uri), httpIsEncrypted(con->http) ? \"ipps\" : \"ipp\", NULL, con->clientname, con->clientport, \"/printers/%s\", printer->name);\n  ippAddString(con->response, IPP_TAG_PRINTER, IPP_TAG_URI, \"printer-uri-supported\", NULL, uri);\n}\n\n\n/*\n * 'create_requested_array()' - Create an array for the requested-attributes.\n */\n\nstatic cups_array_t *\t\t\t/* O - Array of attributes or NULL */\ncreate_requested_array(ipp_t *request)\t/* I - IPP request */\n{\n  cups_array_t\t\t*ra;\t\t/* Requested attributes array */\n\n\n /*\n  * Create the array for standard attributes...\n  */\n\n  ra = ippCreateRequestedArray(request);\n\n /*\n  * Add CUPS defaults as needed...\n  */\n\n  if (cupsArrayFind(ra, \"printer-defaults\"))\n  {\n   /*\n    * Include user-set defaults...\n    */\n\n    char\t*name;\t\t\t/* Option name */\n\n    cupsArrayRemove(ra, \"printer-defaults\");\n\n    for (name = (char *)cupsArrayFirst(CommonDefaults);\n\t name;\n\t name = (char *)cupsArrayNext(CommonDefaults))\n      if (!cupsArrayFind(ra, name))\n        cupsArrayAdd(ra, name);\n  }\n\n  return (ra);\n}\n\n\n/*\n * 'create_subscriptions()' - Create one or more notification subscriptions.\n */\n\nstatic void\ncreate_subscriptions(\n    cupsd_client_t  *con,\t\t/* I - Client connection */\n    ipp_attribute_t *uri)\t\t/* I - Printer URI */\n{\n  http_status_t\tstatus;\t\t\t/* Policy status */\n  int\t\t\ti;\t\t/* Looping var */\n  ipp_attribute_t\t*attr;\t\t/* Current attribute */\n  cups_ptype_t\t\tdtype;\t\t/* Destination type (printer/class) */\n  char\t\t\tscheme[HTTP_MAX_URI],\n\t\t\t\t\t/* Scheme portion of URI */\n\t\t\tuserpass[HTTP_MAX_URI],\n\t\t\t\t\t/* Username portion of URI */\n\t\t\thost[HTTP_MAX_URI],\n\t\t\t\t\t/* Host portion of URI */\n\t\t\tresource[HTTP_MAX_URI];\n\t\t\t\t\t/* Resource portion of URI */\n  int\t\t\tport;\t\t/* Port portion of URI */\n  cupsd_printer_t\t*printer;\t/* Printer/class */\n  cupsd_job_t\t\t*job;\t\t/* Job */\n  int\t\t\tjobid;\t\t/* Job ID */\n  cupsd_subscription_t\t*sub;\t\t/* Subscription object */\n  const char\t\t*username,\t/* requesting-user-name or\n\t\t\t\t\t   authenticated username */\n\t\t\t*recipient,\t/* notify-recipient-uri */\n\t\t\t*pullmethod;\t/* notify-pull-method */\n  ipp_attribute_t\t*user_data;\t/* notify-user-data */\n  int\t\t\tinterval,\t/* notify-time-interval */\n\t\t\tlease;\t\t/* notify-lease-duration */\n  unsigned\t\tmask;\t\t/* notify-events */\n  ipp_attribute_t\t*notify_events,/* notify-events(-default) */\n\t\t\t*notify_lease;\t/* notify-lease-duration(-default) */\n\n\n#ifdef DEBUG\n  for (attr = con->request->attrs; attr; attr = attr->next)\n  {\n    if (attr->group_tag != IPP_TAG_ZERO)\n      cupsdLogMessage(CUPSD_LOG_DEBUG2, \"g%04x v%04x %s\", attr->group_tag,\n                      attr->value_tag, attr->name);\n    else\n      cupsdLogMessage(CUPSD_LOG_DEBUG2, \"----SEP----\");\n  }\n#endif /* DEBUG */\n\n /*\n  * Is the destination valid?\n  */\n\n  cupsdLogMessage(CUPSD_LOG_DEBUG, \"create_subscriptions(con=%p(%d), uri=\\\"%s\\\")\", con, con->number, uri->values[0].string.text);\n\n  httpSeparateURI(HTTP_URI_CODING_ALL, uri->values[0].string.text, scheme,\n                  sizeof(scheme), userpass, sizeof(userpass), host,\n\t\t  sizeof(host), &port, resource, sizeof(resource));\n\n  if (!strcmp(resource, \"/\"))\n  {\n    dtype   = (cups_ptype_t)0;\n    printer = NULL;\n  }\n  else if (!strncmp(resource, \"/printers\", 9) && strlen(resource) <= 10)\n  {\n    dtype   = (cups_ptype_t)0;\n    printer = NULL;\n  }\n  else if (!strncmp(resource, \"/classes\", 8) && strlen(resource) <= 9)\n  {\n    dtype   = CUPS_PRINTER_CLASS;\n    printer = NULL;\n  }\n  else if (!cupsdValidateDest(uri->values[0].string.text, &dtype, &printer))\n  {\n   /*\n    * Bad URI...\n    */\n\n    send_ipp_status(con, IPP_NOT_FOUND,\n                    _(\"The printer or class does not exist.\"));\n    return;\n  }\n\n /*\n  * Check policy...\n  */\n\n  if (printer)\n  {\n    if ((status = cupsdCheckPolicy(printer->op_policy_ptr, con,\n                                   NULL)) != HTTP_OK)\n    {\n      send_http_error(con, status, printer);\n      return;\n    }\n  }\n  else if ((status = cupsdCheckPolicy(DefaultPolicyPtr, con, NULL)) != HTTP_OK)\n  {\n    send_http_error(con, status, NULL);\n    return;\n  }\n\n /*\n  * Get the user that is requesting the subscription...\n  */\n\n  username = get_username(con);\n\n /*\n  * Find the first subscription group attribute; return if we have\n  * none...\n  */\n\n  for (attr = con->request->attrs; attr; attr = attr->next)\n    if (attr->group_tag == IPP_TAG_SUBSCRIPTION)\n      break;\n\n  if (!attr)\n  {\n    send_ipp_status(con, IPP_BAD_REQUEST,\n                    _(\"No subscription attributes in request.\"));\n    return;\n  }\n\n /*\n  * Process the subscription attributes in the request...\n  */\n\n  con->response->request.status.status_code = IPP_BAD_REQUEST;\n\n  while (attr)\n  {\n    recipient = NULL;\n    pullmethod = NULL;\n    user_data  = NULL;\n    interval   = 0;\n    lease      = DefaultLeaseDuration;\n    jobid      = 0;\n    mask       = CUPSD_EVENT_NONE;\n\n    if (printer)\n    {\n      notify_events = ippFindAttribute(printer->attrs, \"notify-events-default\",\n                                       IPP_TAG_KEYWORD);\n      notify_lease  = ippFindAttribute(printer->attrs,\n                                       \"notify-lease-duration-default\",\n                                       IPP_TAG_INTEGER);\n\n      if (notify_lease)\n        lease = notify_lease->values[0].integer;\n    }\n    else\n    {\n      notify_events = NULL;\n      notify_lease  = NULL;\n    }\n\n    while (attr && attr->group_tag != IPP_TAG_ZERO)\n    {\n      if (!strcmp(attr->name, \"notify-recipient-uri\") &&\n          attr->value_tag == IPP_TAG_URI)\n      {\n       /*\n        * Validate the recipient scheme against the ServerBin/notifier\n\t* directory...\n\t*/\n\n\tchar\tnotifier[1024];\t\t/* Notifier filename */\n\n\n        recipient = attr->values[0].string.text;\n\n\tif (httpSeparateURI(HTTP_URI_CODING_ALL, recipient,\n\t                    scheme, sizeof(scheme), userpass, sizeof(userpass),\n\t\t\t    host, sizeof(host), &port,\n\t\t\t    resource, sizeof(resource)) < HTTP_URI_OK)\n        {\n          send_ipp_status(con, IPP_NOT_POSSIBLE,\n\t                  _(\"Bad notify-recipient-uri \\\"%s\\\".\"), recipient);\n\t  ippAddInteger(con->response, IPP_TAG_SUBSCRIPTION, IPP_TAG_ENUM,\n\t                \"notify-status-code\", IPP_URI_SCHEME);\n\t  return;\n\t}\n\n        snprintf(notifier, sizeof(notifier), \"%s/notifier/%s\", ServerBin,\n\t         scheme);\n        if (access(notifier, X_OK))\n\t{\n          send_ipp_status(con, IPP_NOT_POSSIBLE,\n\t                  _(\"notify-recipient-uri URI \\\"%s\\\" uses unknown \"\n\t\t\t    \"scheme.\"), recipient);\n\t  ippAddInteger(con->response, IPP_TAG_SUBSCRIPTION, IPP_TAG_ENUM,\n\t                \"notify-status-code\", IPP_URI_SCHEME);\n\t  return;\n\t}\n\n        if (!strcmp(scheme, \"rss\") && !check_rss_recipient(recipient))\n\t{\n          send_ipp_status(con, IPP_NOT_POSSIBLE,\n\t                  _(\"notify-recipient-uri URI \\\"%s\\\" is already used.\"),\n\t\t\t  recipient);\n\t  ippAddInteger(con->response, IPP_TAG_SUBSCRIPTION, IPP_TAG_ENUM,\n\t                \"notify-status-code\", IPP_ATTRIBUTES);\n\t  return;\n\t}\n      }\n      else if (!strcmp(attr->name, \"notify-pull-method\") &&\n               attr->value_tag == IPP_TAG_KEYWORD)\n      {\n        pullmethod = attr->values[0].string.text;\n\n        if (strcmp(pullmethod, \"ippget\"))\n\t{\n          send_ipp_status(con, IPP_NOT_POSSIBLE,\n\t                  _(\"Bad notify-pull-method \\\"%s\\\".\"), pullmethod);\n\t  ippAddInteger(con->response, IPP_TAG_SUBSCRIPTION, IPP_TAG_ENUM,\n\t                \"notify-status-code\", IPP_ATTRIBUTES);\n\t  return;\n\t}\n      }\n      else if (!strcmp(attr->name, \"notify-charset\") &&\n               attr->value_tag == IPP_TAG_CHARSET &&\n\t       strcmp(attr->values[0].string.text, \"us-ascii\") &&\n\t       strcmp(attr->values[0].string.text, \"utf-8\"))\n      {\n        send_ipp_status(con, IPP_CHARSET,\n\t                _(\"Character set \\\"%s\\\" not supported.\"),\n\t\t\tattr->values[0].string.text);\n\treturn;\n      }\n      else if (!strcmp(attr->name, \"notify-natural-language\") &&\n               (attr->value_tag != IPP_TAG_LANGUAGE ||\n\t        strcmp(attr->values[0].string.text, DefaultLanguage)))\n      {\n        send_ipp_status(con, IPP_CHARSET,\n\t                _(\"Language \\\"%s\\\" not supported.\"),\n\t\t\tattr->values[0].string.text);\n\treturn;\n      }\n      else if (!strcmp(attr->name, \"notify-user-data\") &&\n               attr->value_tag == IPP_TAG_STRING)\n      {\n        if (attr->num_values > 1 || attr->values[0].unknown.length > 63)\n\t{\n          send_ipp_status(con, IPP_REQUEST_VALUE,\n\t                  _(\"The notify-user-data value is too large \"\n\t\t\t    \"(%d > 63 octets).\"),\n\t\t\t  attr->values[0].unknown.length);\n\t  return;\n\t}\n\n        user_data = attr;\n      }\n      else if (!strcmp(attr->name, \"notify-events\") &&\n               attr->value_tag == IPP_TAG_KEYWORD)\n        notify_events = attr;\n      else if (!strcmp(attr->name, \"notify-lease-duration\") &&\n               attr->value_tag == IPP_TAG_INTEGER)\n        lease = attr->values[0].integer;\n      else if (!strcmp(attr->name, \"notify-time-interval\") &&\n               attr->value_tag == IPP_TAG_INTEGER)\n        interval = attr->values[0].integer;\n      else if (!strcmp(attr->name, \"notify-job-id\") &&\n               attr->value_tag == IPP_TAG_INTEGER)\n        jobid = attr->values[0].integer;\n\n      attr = attr->next;\n    }\n\n    if (notify_events)\n    {\n      for (i = 0; i < notify_events->num_values; i ++)\n\tmask |= cupsdEventValue(notify_events->values[i].string.text);\n    }\n\n    if (recipient)\n      cupsdLogMessage(CUPSD_LOG_DEBUG, \"recipient=\\\"%s\\\"\", recipient);\n    if (pullmethod)\n      cupsdLogMessage(CUPSD_LOG_DEBUG, \"pullmethod=\\\"%s\\\"\", pullmethod);\n    cupsdLogMessage(CUPSD_LOG_DEBUG, \"notify-lease-duration=%d\", lease);\n    cupsdLogMessage(CUPSD_LOG_DEBUG, \"notify-time-interval=%d\", interval);\n\n    if (!recipient && !pullmethod)\n      break;\n\n    if (mask == CUPSD_EVENT_NONE)\n    {\n      if (jobid)\n        mask = CUPSD_EVENT_JOB_COMPLETED;\n      else if (printer)\n        mask = CUPSD_EVENT_PRINTER_STATE_CHANGED;\n      else\n      {\n        send_ipp_status(con, IPP_BAD_REQUEST,\n\t                _(\"notify-events not specified.\"));\n\treturn;\n      }\n    }\n\n    if (MaxLeaseDuration && (lease == 0 || lease > MaxLeaseDuration))\n    {\n      cupsdLogMessage(CUPSD_LOG_INFO,\n                      \"create_subscriptions: Limiting notify-lease-duration to \"\n\t\t      \"%d seconds.\",\n\t\t      MaxLeaseDuration);\n      lease = MaxLeaseDuration;\n    }\n\n    if (jobid)\n    {\n      if ((job = cupsdFindJob(jobid)) == NULL)\n      {\n\tsend_ipp_status(con, IPP_NOT_FOUND, _(\"Job #%d does not exist.\"),\n\t                jobid);\n\treturn;\n      }\n    }\n    else\n      job = NULL;\n\n    if ((sub = cupsdAddSubscription(mask, printer, job, recipient, 0)) == NULL)\n    {\n      send_ipp_status(con, IPP_TOO_MANY_SUBSCRIPTIONS,\n\t\t      _(\"There are too many subscriptions.\"));\n      return;\n    }\n\n    if (job)\n      cupsdLogMessage(CUPSD_LOG_DEBUG, \"Added subscription #%d for job %d.\",\n\t\t      sub->id, job->id);\n    else if (printer)\n      cupsdLogMessage(CUPSD_LOG_DEBUG,\n                      \"Added subscription #%d for printer \\\"%s\\\".\",\n\t\t      sub->id, printer->name);\n    else\n      cupsdLogMessage(CUPSD_LOG_DEBUG, \"Added subscription #%d for server.\",\n\t\t      sub->id);\n\n    sub->interval = interval;\n    sub->lease    = lease;\n    sub->expire   = lease ? time(NULL) + lease : 0;\n\n    cupsdSetString(&sub->owner, username);\n\n    if (user_data)\n    {\n      sub->user_data_len = user_data->values[0].unknown.length;\n      memcpy(sub->user_data, user_data->values[0].unknown.data,\n             (size_t)sub->user_data_len);\n    }\n\n    ippAddSeparator(con->response);\n    ippAddInteger(con->response, IPP_TAG_SUBSCRIPTION, IPP_TAG_INTEGER,\n                  \"notify-subscription-id\", sub->id);\n\n    con->response->request.status.status_code = IPP_OK;\n\n    if (attr)\n      attr = attr->next;\n  }\n\n  cupsdMarkDirty(CUPSD_DIRTY_SUBSCRIPTIONS);\n}\n\n\n/*\n * 'delete_printer()' - Remove a printer or class from the system.\n */\n\nstatic void\ndelete_printer(cupsd_client_t  *con,\t/* I - Client connection */\n               ipp_attribute_t *uri)\t/* I - URI of printer or class */\n{\n  http_status_t\tstatus;\t\t\t/* Policy status */\n  cups_ptype_t\tdtype;\t\t\t/* Destination type (printer/class) */\n  cupsd_printer_t *printer;\t\t/* Printer/class */\n  char\t\tfilename[1024];\t\t/* Script/PPD filename */\n  int\t\ttemporary;\t\t/* Temporary queue? */\n\n\n  cupsdLogMessage(CUPSD_LOG_DEBUG2, \"delete_printer(%p[%d], %s)\", con,\n                  con->number, uri->values[0].string.text);\n\n /*\n  * Do we have a valid URI?\n  */\n\n  if (!cupsdValidateDest(uri->values[0].string.text, &dtype, &printer))\n  {\n   /*\n    * Bad URI...\n    */\n\n    send_ipp_status(con, IPP_NOT_FOUND,\n                    _(\"The printer or class does not exist.\"));\n    return;\n  }\n\n /*\n  * Check policy...\n  */\n\n  if ((status = cupsdCheckPolicy(DefaultPolicyPtr, con, NULL)) != HTTP_OK)\n  {\n    send_http_error(con, status, NULL);\n    return;\n  }\n\n /*\n  * Remove old jobs...\n  */\n\n  cupsdCancelJobs(printer->name, NULL, 1);\n\n /*\n  * Remove old subscriptions and send a \"deleted printer\" event...\n  */\n\n  cupsdAddEvent(CUPSD_EVENT_PRINTER_DELETED, printer, NULL,\n                \"%s \\\"%s\\\" deleted by \\\"%s\\\".\",\n\t\t(dtype & CUPS_PRINTER_CLASS) ? \"Class\" : \"Printer\",\n\t\tprinter->name, get_username(con));\n\n  cupsdExpireSubscriptions(printer, NULL);\n\n /*\n  * Remove any old PPD or script files...\n  */\n\n  snprintf(filename, sizeof(filename), \"%s/ppd/%s.ppd\", ServerRoot,\n           printer->name);\n  unlink(filename);\n  snprintf(filename, sizeof(filename), \"%s/ppd/%s.ppd.O\", ServerRoot,\n           printer->name);\n  unlink(filename);\n\n  snprintf(filename, sizeof(filename), \"%s/%s.png\", CacheDir, printer->name);\n  unlink(filename);\n\n  snprintf(filename, sizeof(filename), \"%s/%s.data\", CacheDir, printer->name);\n  unlink(filename);\n\n /*\n  * Unregister color profiles...\n  */\n\n  cupsdUnregisterColor(printer);\n\n  temporary = printer->temporary;\n\n  if (dtype & CUPS_PRINTER_CLASS)\n  {\n    cupsdLogMessage(CUPSD_LOG_INFO, \"Class \\\"%s\\\" deleted by \\\"%s\\\".\",\n                    printer->name, get_username(con));\n\n    cupsdDeletePrinter(printer, 0);\n    if (!temporary)\n      cupsdMarkDirty(CUPSD_DIRTY_CLASSES);\n  }\n  else\n  {\n    cupsdLogMessage(CUPSD_LOG_INFO, \"Printer \\\"%s\\\" deleted by \\\"%s\\\".\",\n                    printer->name, get_username(con));\n\n    if (cupsdDeletePrinter(printer, 0) && !temporary)\n      cupsdMarkDirty(CUPSD_DIRTY_CLASSES);\n\n    if (!temporary)\n      cupsdMarkDirty(CUPSD_DIRTY_PRINTERS);\n  }\n\n  if (!temporary)\n    cupsdMarkDirty(CUPSD_DIRTY_PRINTCAP);\n\n /*\n  * Return with no errors...\n  */\n\n  con->response->request.status.status_code = IPP_OK;\n}\n\n\n/*\n * 'get_default()' - Get the default destination.\n */\n\nstatic void\nget_default(cupsd_client_t *con)\t/* I - Client connection */\n{\n  http_status_t\tstatus;\t\t\t/* Policy status */\n  cups_array_t\t*ra;\t\t\t/* Requested attributes array */\n\n\n  cupsdLogMessage(CUPSD_LOG_DEBUG2, \"get_default(%p[%d])\", con, con->number);\n\n /*\n  * Check policy...\n  */\n\n  if ((status = cupsdCheckPolicy(DefaultPolicyPtr, con, NULL)) != HTTP_OK)\n  {\n    send_http_error(con, status, NULL);\n    return;\n  }\n\n  if (DefaultPrinter)\n  {\n    ra = create_requested_array(con->request);\n\n    copy_printer_attrs(con, DefaultPrinter, ra);\n\n    cupsArrayDelete(ra);\n\n    con->response->request.status.status_code = IPP_OK;\n  }\n  else\n    send_ipp_status(con, IPP_NOT_FOUND, _(\"No default printer.\"));\n}\n\n\n/*\n * 'get_devices()' - Get the list of available devices on the local system.\n */\n\nstatic void\nget_devices(cupsd_client_t *con)\t/* I - Client connection */\n{\n  http_status_t\t\tstatus;\t\t/* Policy status */\n  ipp_attribute_t\t*limit,\t\t/* limit attribute */\n\t\t\t*timeout,\t/* timeout attribute */\n\t\t\t*requested,\t/* requested-attributes attribute */\n\t\t\t*exclude,\t/* exclude-schemes attribute */\n\t\t\t*include;\t/* include-schemes attribute */\n  char\t\t\tcommand[1024],\t/* cups-deviced command */\n\t\t\toptions[2048],\t/* Options to pass to command */\n\t\t\trequested_str[256],\n\t\t\t\t\t/* String for requested attributes */\n\t\t\texclude_str[512],\n\t\t\t\t\t/* String for excluded schemes */\n\t\t\tinclude_str[512];\n\t\t\t\t\t/* String for included schemes */\n\n\n  cupsdLogMessage(CUPSD_LOG_DEBUG2, \"get_devices(%p[%d])\", con, con->number);\n\n /*\n  * Check policy...\n  */\n\n  if ((status = cupsdCheckPolicy(DefaultPolicyPtr, con, NULL)) != HTTP_OK)\n  {\n    send_http_error(con, status, NULL);\n    return;\n  }\n\n /*\n  * Run cups-deviced command with the given options...\n  */\n\n  limit     = ippFindAttribute(con->request, \"limit\", IPP_TAG_INTEGER);\n  timeout   = ippFindAttribute(con->request, \"timeout\", IPP_TAG_INTEGER);\n  requested = ippFindAttribute(con->request, \"requested-attributes\",\n                               IPP_TAG_KEYWORD);\n  exclude   = ippFindAttribute(con->request, \"exclude-schemes\", IPP_TAG_NAME);\n  include   = ippFindAttribute(con->request, \"include-schemes\", IPP_TAG_NAME);\n\n  if (requested)\n    url_encode_attr(requested, requested_str, sizeof(requested_str));\n  else\n    strlcpy(requested_str, \"requested-attributes=all\", sizeof(requested_str));\n\n  if (exclude)\n    url_encode_attr(exclude, exclude_str, sizeof(exclude_str));\n  else\n    exclude_str[0] = '\\0';\n\n  if (include)\n    url_encode_attr(include, include_str, sizeof(include_str));\n  else\n    include_str[0] = '\\0';\n\n  snprintf(command, sizeof(command), \"%s/daemon/cups-deviced\", ServerBin);\n  snprintf(options, sizeof(options),\n           \"%d+%d+%d+%d+%s%s%s%s%s\",\n           con->request->request.op.request_id,\n           limit ? limit->values[0].integer : 0,\n\t   timeout ? timeout->values[0].integer : 15,\n\t   (int)User,\n\t   requested_str,\n\t   exclude_str[0] ? \"%20\" : \"\", exclude_str,\n\t   include_str[0] ? \"%20\" : \"\", include_str);\n\n  if (cupsdSendCommand(con, command, options, 1))\n  {\n   /*\n    * Command started successfully, don't send an IPP response here...\n    */\n\n    ippDelete(con->response);\n    con->response = NULL;\n  }\n  else\n  {\n   /*\n    * Command failed, return \"internal error\" so the user knows something\n    * went wrong...\n    */\n\n    send_ipp_status(con, IPP_INTERNAL_ERROR,\n                    _(\"cups-deviced failed to execute.\"));\n  }\n}\n\n\n/*\n * 'get_document()' - Get a copy of a job file.\n */\n\nstatic void\nget_document(cupsd_client_t  *con,\t/* I - Client connection */\n             ipp_attribute_t *uri)\t/* I - Job URI */\n{\n  http_status_t\tstatus;\t\t\t/* Policy status */\n  ipp_attribute_t *attr;\t\t/* Current attribute */\n  int\t\tjobid;\t\t\t/* Job ID */\n  int\t\tdocnum;\t\t\t/* Document number */\n  cupsd_job_t\t*job;\t\t\t/* Current job */\n  char\t\tscheme[HTTP_MAX_URI],\t/* Method portion of URI */\n\t\tusername[HTTP_MAX_URI],\t/* Username portion of URI */\n\t\thost[HTTP_MAX_URI],\t/* Host portion of URI */\n\t\tresource[HTTP_MAX_URI];\t/* Resource portion of URI */\n  int\t\tport;\t\t\t/* Port portion of URI */\n  char\t\tfilename[1024],\t\t/* Filename for document */\n\t\tformat[1024];\t\t/* Format for document */\n\n\n  cupsdLogMessage(CUPSD_LOG_DEBUG2, \"get_document(%p[%d], %s)\", con,\n                  con->number, uri->values[0].string.text);\n\n /*\n  * See if we have a job URI or a printer URI...\n  */\n\n  if (!strcmp(uri->name, \"printer-uri\"))\n  {\n   /*\n    * Got a printer URI; see if we also have a job-id attribute...\n    */\n\n    if ((attr = ippFindAttribute(con->request, \"job-id\",\n                                 IPP_TAG_INTEGER)) == NULL)\n    {\n      send_ipp_status(con, IPP_BAD_REQUEST,\n                      _(\"Got a printer-uri attribute but no job-id.\"));\n      return;\n    }\n\n    jobid = attr->values[0].integer;\n  }\n  else\n  {\n   /*\n    * Got a job URI; parse it to get the job ID...\n    */\n\n    httpSeparateURI(HTTP_URI_CODING_ALL, uri->values[0].string.text, scheme,\n                    sizeof(scheme), username, sizeof(username), host,\n\t\t    sizeof(host), &port, resource, sizeof(resource));\n\n    if (strncmp(resource, \"/jobs/\", 6))\n    {\n     /*\n      * Not a valid URI!\n      */\n\n      send_ipp_status(con, IPP_BAD_REQUEST, _(\"Bad job-uri \\\"%s\\\".\"),\n                      uri->values[0].string.text);\n      return;\n    }\n\n    jobid = atoi(resource + 6);\n  }\n\n /*\n  * See if the job exists...\n  */\n\n  if ((job = cupsdFindJob(jobid)) == NULL)\n  {\n   /*\n    * Nope - return a \"not found\" error...\n    */\n\n    send_ipp_status(con, IPP_NOT_FOUND, _(\"Job #%d does not exist.\"), jobid);\n    return;\n  }\n\n /*\n  * Check policy...\n  */\n\n  if ((status = cupsdCheckPolicy(DefaultPolicyPtr, con,\n                                 job->username)) != HTTP_OK)\n  {\n    send_http_error(con, status, NULL);\n    return;\n  }\n\n /*\n  * Get the document number...\n  */\n\n  if ((attr = ippFindAttribute(con->request, \"document-number\",\n                               IPP_TAG_INTEGER)) == NULL)\n  {\n    send_ipp_status(con, IPP_BAD_REQUEST,\n                    _(\"Missing document-number attribute.\"));\n    return;\n  }\n\n  if ((docnum = attr->values[0].integer) < 1 || docnum > job->num_files ||\n      attr->num_values > 1)\n  {\n    send_ipp_status(con, IPP_NOT_FOUND,\n                    _(\"Document #%d does not exist in job #%d.\"), docnum,\n\t\t    jobid);\n    return;\n  }\n\n  snprintf(filename, sizeof(filename), \"%s/d%05d-%03d\", RequestRoot, jobid,\n           docnum);\n  if ((con->file = open(filename, O_RDONLY)) == -1)\n  {\n    cupsdLogMessage(CUPSD_LOG_ERROR,\n                    \"Unable to open document %d in job %d - %s\", docnum, jobid,\n\t\t    strerror(errno));\n    send_ipp_status(con, IPP_NOT_FOUND,\n                    _(\"Unable to open document #%d in job #%d.\"), docnum,\n\t\t    jobid);\n    return;\n  }\n\n  fcntl(con->file, F_SETFD, fcntl(con->file, F_GETFD) | FD_CLOEXEC);\n\n  cupsdLoadJob(job);\n\n  snprintf(format, sizeof(format), \"%s/%s\", job->filetypes[docnum - 1]->super,\n           job->filetypes[docnum - 1]->type);\n\n  ippAddString(con->response, IPP_TAG_JOB, IPP_TAG_MIMETYPE, \"document-format\",\n               NULL, format);\n  ippAddInteger(con->response, IPP_TAG_JOB, IPP_TAG_INTEGER, \"document-number\",\n                docnum);\n  if ((attr = ippFindAttribute(job->attrs, \"document-name\",\n                               IPP_TAG_NAME)) != NULL)\n    ippAddString(con->response, IPP_TAG_JOB, IPP_TAG_NAME, \"document-name\",\n                 NULL, attr->values[0].string.text);\n}\n\n\n/*\n * 'get_job_attrs()' - Get job attributes.\n */\n\nstatic void\nget_job_attrs(cupsd_client_t  *con,\t/* I - Client connection */\n\t      ipp_attribute_t *uri)\t/* I - Job URI */\n{\n  http_status_t\tstatus;\t\t\t/* Policy status */\n  ipp_attribute_t *attr;\t\t/* Current attribute */\n  int\t\tjobid;\t\t\t/* Job ID */\n  cupsd_job_t\t*job;\t\t\t/* Current job */\n  cupsd_printer_t *printer;\t\t/* Current printer */\n  cupsd_policy_t *policy;\t\t/* Current security policy */\n  char\t\tscheme[HTTP_MAX_URI],\t/* Scheme portion of URI */\n\t\tusername[HTTP_MAX_URI],\t/* Username portion of URI */\n\t\thost[HTTP_MAX_URI],\t/* Host portion of URI */\n\t\tresource[HTTP_MAX_URI];\t/* Resource portion of URI */\n  int\t\tport;\t\t\t/* Port portion of URI */\n  cups_array_t\t*ra,\t\t\t/* Requested attributes array */\n\t\t*exclude;\t\t/* Private attributes array */\n\n\n  cupsdLogMessage(CUPSD_LOG_DEBUG2, \"get_job_attrs(%p[%d], %s)\", con,\n                  con->number, uri->values[0].string.text);\n\n /*\n  * See if we have a job URI or a printer URI...\n  */\n\n  if (!strcmp(uri->name, \"printer-uri\"))\n  {\n   /*\n    * Got a printer URI; see if we also have a job-id attribute...\n    */\n\n    if ((attr = ippFindAttribute(con->request, \"job-id\",\n                                 IPP_TAG_INTEGER)) == NULL)\n    {\n      send_ipp_status(con, IPP_BAD_REQUEST,\n                      _(\"Got a printer-uri attribute but no job-id.\"));\n      return;\n    }\n\n    jobid = attr->values[0].integer;\n  }\n  else\n  {\n   /*\n    * Got a job URI; parse it to get the job ID...\n    */\n\n    httpSeparateURI(HTTP_URI_CODING_ALL, uri->values[0].string.text, scheme,\n                    sizeof(scheme), username, sizeof(username), host,\n\t\t    sizeof(host), &port, resource, sizeof(resource));\n\n    if (strncmp(resource, \"/jobs/\", 6))\n    {\n     /*\n      * Not a valid URI!\n      */\n\n      send_ipp_status(con, IPP_BAD_REQUEST, _(\"Bad job-uri \\\"%s\\\".\"),\n                      uri->values[0].string.text);\n      return;\n    }\n\n    jobid = atoi(resource + 6);\n  }\n\n /*\n  * See if the job exists...\n  */\n\n  if ((job = cupsdFindJob(jobid)) == NULL)\n  {\n   /*\n    * Nope - return a \"not found\" error...\n    */\n\n    send_ipp_status(con, IPP_NOT_FOUND, _(\"Job #%d does not exist.\"), jobid);\n    return;\n  }\n\n /*\n  * Check policy...\n  */\n\n  if ((printer = job->printer) == NULL)\n    printer = cupsdFindDest(job->dest);\n\n  if (printer)\n    policy = printer->op_policy_ptr;\n  else\n    policy = DefaultPolicyPtr;\n\n  if ((status = cupsdCheckPolicy(policy, con, job->username)) != HTTP_OK)\n  {\n    send_http_error(con, status, NULL);\n    return;\n  }\n\n  exclude = cupsdGetPrivateAttrs(policy, con, printer, job->username);\n\n /*\n  * Copy attributes...\n  */\n\n  cupsdLoadJob(job);\n\n  ra = create_requested_array(con->request);\n  copy_job_attrs(con, job, ra, exclude);\n  cupsArrayDelete(ra);\n\n  con->response->request.status.status_code = IPP_OK;\n}\n\n\n/*\n * 'get_jobs()' - Get a list of jobs for the specified printer.\n */\n\nstatic void\nget_jobs(cupsd_client_t  *con,\t\t/* I - Client connection */\n\t ipp_attribute_t *uri)\t\t/* I - Printer URI */\n{\n  http_status_t\tstatus;\t\t\t/* Policy status */\n  ipp_attribute_t *attr;\t\t/* Current attribute */\n  const char\t*dest;\t\t\t/* Destination */\n  cups_ptype_t\tdtype;\t\t\t/* Destination type (printer/class) */\n  cups_ptype_t\tdmask;\t\t\t/* Destination type mask */\n  char\t\tscheme[HTTP_MAX_URI],\t/* Scheme portion of URI */\n\t\tusername[HTTP_MAX_URI],\t/* Username portion of URI */\n\t\thost[HTTP_MAX_URI],\t/* Host portion of URI */\n\t\tresource[HTTP_MAX_URI];\t/* Resource portion of URI */\n  int\t\tport;\t\t\t/* Port portion of URI */\n  int\t\tjob_comparison;\t\t/* Job comparison */\n  ipp_jstate_t\tjob_state;\t\t/* job-state value */\n  int\t\tfirst_job_id = 1,\t/* First job ID */\n\t\tfirst_index = 1,\t/* First index */\n\t\tlimit = 0,\t\t/* Maximum number of jobs to return */\n\t\tcount,\t\t\t/* Number of jobs that match */\n\t\tneed_load_job = 0;\t/* Do we need to load the job? */\n  const char\t*job_attr;\t\t/* Job attribute requested */\n  ipp_attribute_t *job_ids;\t\t/* job-ids attribute */\n  cupsd_job_t\t*job;\t\t\t/* Current job pointer */\n  cupsd_printer_t *printer;\t\t/* Printer */\n  cups_array_t\t*list;\t\t\t/* Which job list... */\n  int\t\tdelete_list = 0;\t/* Delete the list afterwards? */\n  cups_array_t\t*ra,\t\t\t/* Requested attributes array */\n\t\t*exclude;\t\t/* Private attributes array */\n  cupsd_policy_t *policy;\t\t/* Current policy */\n\n\n  cupsdLogMessage(CUPSD_LOG_DEBUG2, \"get_jobs(%p[%d], %s)\", con, con->number,\n                  uri->values[0].string.text);\n\n /*\n  * Is the destination valid?\n  */\n\n  if (strcmp(uri->name, \"printer-uri\"))\n  {\n    send_ipp_status(con, IPP_BAD_REQUEST, _(\"No printer-uri in request.\"));\n    return;\n  }\n\n  httpSeparateURI(HTTP_URI_CODING_ALL, uri->values[0].string.text, scheme,\n                  sizeof(scheme), username, sizeof(username), host,\n\t\t  sizeof(host), &port, resource, sizeof(resource));\n\n  if (!strcmp(resource, \"/\") || !strcmp(resource, \"/jobs\"))\n  {\n    dest    = NULL;\n    dtype   = (cups_ptype_t)0;\n    dmask   = (cups_ptype_t)0;\n    printer = NULL;\n  }\n  else if (!strncmp(resource, \"/printers\", 9) && strlen(resource) <= 10)\n  {\n    dest    = NULL;\n    dtype   = (cups_ptype_t)0;\n    dmask   = CUPS_PRINTER_CLASS;\n    printer = NULL;\n  }\n  else if (!strncmp(resource, \"/classes\", 8) && strlen(resource) <= 9)\n  {\n    dest    = NULL;\n    dtype   = CUPS_PRINTER_CLASS;\n    dmask   = CUPS_PRINTER_CLASS;\n    printer = NULL;\n  }\n  else if ((dest = cupsdValidateDest(uri->values[0].string.text, &dtype,\n                                     &printer)) == NULL)\n  {\n   /*\n    * Bad URI...\n    */\n\n    send_ipp_status(con, IPP_NOT_FOUND,\n                    _(\"The printer or class does not exist.\"));\n    return;\n  }\n  else\n  {\n    dtype &= CUPS_PRINTER_CLASS;\n    dmask = CUPS_PRINTER_CLASS;\n  }\n\n /*\n  * Check policy...\n  */\n\n  if (printer)\n    policy = printer->op_policy_ptr;\n  else\n    policy = DefaultPolicyPtr;\n\n  if ((status = cupsdCheckPolicy(policy, con, NULL)) != HTTP_OK)\n  {\n    send_http_error(con, status, NULL);\n    return;\n  }\n\n  job_ids = ippFindAttribute(con->request, \"job-ids\", IPP_TAG_INTEGER);\n\n /*\n  * See if the \"which-jobs\" attribute have been specified...\n  */\n\n  if ((attr = ippFindAttribute(con->request, \"which-jobs\",\n                               IPP_TAG_KEYWORD)) != NULL && job_ids)\n  {\n    send_ipp_status(con, IPP_CONFLICT,\n                    _(\"The %s attribute cannot be provided with job-ids.\"),\n                    \"which-jobs\");\n    return;\n  }\n  else if (!attr || !strcmp(attr->values[0].string.text, \"not-completed\"))\n  {\n    job_comparison = -1;\n    job_state      = IPP_JOB_STOPPED;\n    list           = ActiveJobs;\n  }\n  else if (!strcmp(attr->values[0].string.text, \"completed\"))\n  {\n    job_comparison = 1;\n    job_state      = IPP_JOB_CANCELED;\n    list           = cupsdGetCompletedJobs(printer);\n    delete_list    = 1;\n  }\n  else if (!strcmp(attr->values[0].string.text, \"aborted\"))\n  {\n    job_comparison = 0;\n    job_state      = IPP_JOB_ABORTED;\n    list           = cupsdGetCompletedJobs(printer);\n    delete_list    = 1;\n  }\n  else if (!strcmp(attr->values[0].string.text, \"all\"))\n  {\n    job_comparison = 1;\n    job_state      = IPP_JOB_PENDING;\n    list           = Jobs;\n  }\n  else if (!strcmp(attr->values[0].string.text, \"canceled\"))\n  {\n    job_comparison = 0;\n    job_state      = IPP_JOB_CANCELED;\n    list           = cupsdGetCompletedJobs(printer);\n    delete_list    = 1;\n  }\n  else if (!strcmp(attr->values[0].string.text, \"pending\"))\n  {\n    job_comparison = 0;\n    job_state      = IPP_JOB_PENDING;\n    list           = ActiveJobs;\n  }\n  else if (!strcmp(attr->values[0].string.text, \"pending-held\"))\n  {\n    job_comparison = 0;\n    job_state      = IPP_JOB_HELD;\n    list           = ActiveJobs;\n  }\n  else if (!strcmp(attr->values[0].string.text, \"processing\"))\n  {\n    job_comparison = 0;\n    job_state      = IPP_JOB_PROCESSING;\n    list           = PrintingJobs;\n  }\n  else if (!strcmp(attr->values[0].string.text, \"processing-stopped\"))\n  {\n    job_comparison = 0;\n    job_state      = IPP_JOB_STOPPED;\n    list           = ActiveJobs;\n  }\n  else\n  {\n    send_ipp_status(con, IPP_ATTRIBUTES,\n                    _(\"The which-jobs value \\\"%s\\\" is not supported.\"),\n\t\t    attr->values[0].string.text);\n    ippAddString(con->response, IPP_TAG_UNSUPPORTED_GROUP, IPP_TAG_KEYWORD,\n                 \"which-jobs\", NULL, attr->values[0].string.text);\n    return;\n  }\n\n /*\n  * See if they want to limit the number of jobs reported...\n  */\n\n  if ((attr = ippFindAttribute(con->request, \"limit\", IPP_TAG_INTEGER)) != NULL)\n  {\n    if (job_ids)\n    {\n      send_ipp_status(con, IPP_CONFLICT,\n\t\t      _(\"The %s attribute cannot be provided with job-ids.\"),\n\t\t      \"limit\");\n      return;\n    }\n\n    limit = attr->values[0].integer;\n  }\n\n  if ((attr = ippFindAttribute(con->request, \"first-index\", IPP_TAG_INTEGER)) != NULL)\n  {\n    if (job_ids)\n    {\n      send_ipp_status(con, IPP_CONFLICT,\n\t\t      _(\"The %s attribute cannot be provided with job-ids.\"),\n\t\t      \"first-index\");\n      return;\n    }\n\n    first_index = attr->values[0].integer;\n  }\n  else if ((attr = ippFindAttribute(con->request, \"first-job-id\", IPP_TAG_INTEGER)) != NULL)\n  {\n    if (job_ids)\n    {\n      send_ipp_status(con, IPP_CONFLICT,\n\t\t      _(\"The %s attribute cannot be provided with job-ids.\"),\n\t\t      \"first-job-id\");\n      return;\n    }\n\n    first_job_id = attr->values[0].integer;\n  }\n\n /*\n  * See if we only want to see jobs for a specific user...\n  */\n\n  if ((attr = ippFindAttribute(con->request, \"my-jobs\", IPP_TAG_BOOLEAN)) != NULL && job_ids)\n  {\n    send_ipp_status(con, IPP_CONFLICT,\n                    _(\"The %s attribute cannot be provided with job-ids.\"),\n                    \"my-jobs\");\n    return;\n  }\n  else if (attr && attr->values[0].boolean)\n    strlcpy(username, get_username(con), sizeof(username));\n  else\n    username[0] = '\\0';\n\n  ra = create_requested_array(con->request);\n  for (job_attr = (char *)cupsArrayFirst(ra); job_attr; job_attr = (char *)cupsArrayNext(ra))\n    if (strcmp(job_attr, \"job-id\") &&\n\tstrcmp(job_attr, \"job-k-octets\") &&\n\tstrcmp(job_attr, \"job-media-progress\") &&\n\tstrcmp(job_attr, \"job-more-info\") &&\n\tstrcmp(job_attr, \"job-name\") &&\n\tstrcmp(job_attr, \"job-originating-user-name\") &&\n\tstrcmp(job_attr, \"job-preserved\") &&\n\tstrcmp(job_attr, \"job-printer-up-time\") &&\n        strcmp(job_attr, \"job-printer-uri\") &&\n\tstrcmp(job_attr, \"job-state\") &&\n\tstrcmp(job_attr, \"job-state-reasons\") &&\n\tstrcmp(job_attr, \"job-uri\") &&\n\tstrcmp(job_attr, \"time-at-completed\") &&\n\tstrcmp(job_attr, \"time-at-creation\") &&\n\tstrcmp(job_attr, \"number-of-documents\"))\n    {\n      need_load_job = 1;\n      break;\n    }\n\n  if (need_load_job && (limit == 0 || limit > 500) && (list == Jobs || delete_list))\n  {\n   /*\n    * Limit expensive Get-Jobs for job history to 500 jobs...\n    */\n\n    ippAddInteger(con->response, IPP_TAG_OPERATION, IPP_TAG_INTEGER, \"limit\", 500);\n\n    if (limit)\n      ippAddInteger(con->response, IPP_TAG_UNSUPPORTED_GROUP, IPP_TAG_INTEGER, \"limit\", limit);\n\n    limit = 500;\n\n    cupsdLogClient(con, CUPSD_LOG_INFO, \"Limiting Get-Jobs response to %d jobs.\", limit);\n  }\n\n /*\n  * OK, build a list of jobs for this printer...\n  */\n\n  if (job_ids)\n  {\n    int\ti;\t\t\t\t/* Looping var */\n\n    for (i = 0; i < job_ids->num_values; i ++)\n    {\n      if (!cupsdFindJob(job_ids->values[i].integer))\n        break;\n    }\n\n    if (i < job_ids->num_values)\n    {\n      send_ipp_status(con, IPP_NOT_FOUND, _(\"Job #%d does not exist.\"),\n                      job_ids->values[i].integer);\n      return;\n    }\n\n    for (i = 0; i < job_ids->num_values; i ++)\n    {\n      job = cupsdFindJob(job_ids->values[i].integer);\n\n      if (need_load_job && !job->attrs)\n      {\n        cupsdLoadJob(job);\n\n\tif (!job->attrs)\n\t{\n\t  cupsdLogMessage(CUPSD_LOG_DEBUG2, \"get_jobs: No attributes for job %d\", job->id);\n\t  continue;\n\t}\n      }\n\n      if (i > 0)\n\tippAddSeparator(con->response);\n\n      exclude = cupsdGetPrivateAttrs(job->printer ?\n                                         job->printer->op_policy_ptr :\n\t\t\t\t\t policy, con, job->printer,\n\t\t\t\t\t job->username);\n\n      copy_job_attrs(con, job, ra, exclude);\n    }\n  }\n  else\n  {\n    if (first_index > 1)\n      job = (cupsd_job_t *)cupsArrayIndex(list, first_index - 1);\n    else\n      job = (cupsd_job_t *)cupsArrayFirst(list);\n\n    for (count = 0; (limit <= 0 || count < limit) && job; job = (cupsd_job_t *)cupsArrayNext(list))\n    {\n     /*\n      * Filter out jobs that don't match...\n      */\n\n      cupsdLogMessage(CUPSD_LOG_DEBUG2,\n\t\t      \"get_jobs: job->id=%d, dest=\\\"%s\\\", username=\\\"%s\\\", \"\n\t\t      \"state_value=%d, attrs=%p\", job->id, job->dest,\n\t\t      job->username, job->state_value, job->attrs);\n\n      if (!job->dest || !job->username)\n\tcupsdLoadJob(job);\n\n      if (!job->dest || !job->username)\n\tcontinue;\n\n      if ((dest && strcmp(job->dest, dest)) &&\n\t  (!job->printer || !dest || strcmp(job->printer->name, dest)))\n\tcontinue;\n      if ((job->dtype & dmask) != dtype &&\n\t  (!job->printer || (job->printer->type & dmask) != dtype))\n\tcontinue;\n\n      if ((job_comparison < 0 && job->state_value > job_state) ||\n          (job_comparison == 0 && job->state_value != job_state) ||\n          (job_comparison > 0 && job->state_value < job_state))\n\tcontinue;\n\n      if (job->id < first_job_id)\n\tcontinue;\n\n      if (need_load_job && !job->attrs)\n      {\n        cupsdLoadJob(job);\n\n\tif (!job->attrs)\n\t{\n\t  cupsdLogMessage(CUPSD_LOG_DEBUG2, \"get_jobs: No attributes for job %d\", job->id);\n\t  continue;\n\t}\n      }\n\n      if (username[0] && _cups_strcasecmp(username, job->username))\n\tcontinue;\n\n      if (count > 0)\n\tippAddSeparator(con->response);\n\n      count ++;\n\n      exclude = cupsdGetPrivateAttrs(job->printer ?\n                                         job->printer->op_policy_ptr :\n\t\t\t\t\t policy, con, job->printer,\n\t\t\t\t\t job->username);\n\n      copy_job_attrs(con, job, ra, exclude);\n    }\n\n    cupsdLogMessage(CUPSD_LOG_DEBUG2, \"get_jobs: count=%d\", count);\n  }\n\n  cupsArrayDelete(ra);\n\n  if (delete_list)\n    cupsArrayDelete(list);\n\n  con->response->request.status.status_code = IPP_OK;\n}\n\n\n/*\n * 'get_notifications()' - Get events for a subscription.\n */\n\nstatic void\nget_notifications(cupsd_client_t *con)\t/* I - Client connection */\n{\n  int\t\t\ti, j;\t\t/* Looping vars */\n  http_status_t\t\tstatus;\t\t/* Policy status */\n  cupsd_subscription_t\t*sub;\t\t/* Subscription */\n  ipp_attribute_t\t*ids,\t\t/* notify-subscription-ids */\n\t\t\t*sequences;\t/* notify-sequence-numbers */\n  int\t\t\tmin_seq;\t/* Minimum sequence number */\n  int\t\t\tinterval;\t/* Poll interval */\n\n\n  cupsdLogMessage(CUPSD_LOG_DEBUG2, \"get_notifications(con=%p[%d])\",\n                  con, con->number);\n\n /*\n  * Get subscription attributes...\n  */\n\n  ids       = ippFindAttribute(con->request, \"notify-subscription-ids\",\n                               IPP_TAG_INTEGER);\n  sequences = ippFindAttribute(con->request, \"notify-sequence-numbers\",\n                               IPP_TAG_INTEGER);\n\n  if (!ids)\n  {\n    send_ipp_status(con, IPP_BAD_REQUEST,\n                    _(\"Missing notify-subscription-ids attribute.\"));\n    return;\n  }\n\n /*\n  * Are the subscription IDs valid?\n  */\n\n  for (i = 0, interval = 60; i < ids->num_values; i ++)\n  {\n    if ((sub = cupsdFindSubscription(ids->values[i].integer)) == NULL)\n    {\n     /*\n      * Bad subscription ID...\n      */\n\n      send_ipp_status(con, IPP_NOT_FOUND, _(\"Subscription #%d does not exist.\"),\n\t\t      ids->values[i].integer);\n      return;\n    }\n\n   /*\n    * Check policy...\n    */\n\n    if ((status = cupsdCheckPolicy(sub->dest ? sub->dest->op_policy_ptr :\n                                               DefaultPolicyPtr,\n                                   con, sub->owner)) != HTTP_OK)\n    {\n      send_http_error(con, status, sub->dest);\n      return;\n    }\n\n   /*\n    * Check the subscription type and update the interval accordingly.\n    */\n\n    if (sub->job && sub->job->state_value == IPP_JOB_PROCESSING &&\n        interval > 10)\n      interval = 10;\n    else if (sub->job && sub->job->state_value >= IPP_JOB_STOPPED)\n      interval = 0;\n    else if (sub->dest && sub->dest->state == IPP_PRINTER_PROCESSING &&\n             interval > 30)\n      interval = 30;\n  }\n\n /*\n  * Tell the client to poll again in N seconds...\n  */\n\n  if (interval > 0)\n    ippAddInteger(con->response, IPP_TAG_OPERATION, IPP_TAG_INTEGER,\n                  \"notify-get-interval\", interval);\n\n  ippAddInteger(con->response, IPP_TAG_OPERATION, IPP_TAG_INTEGER,\n                \"printer-up-time\", time(NULL));\n\n /*\n  * Copy the subscription event attributes to the response.\n  */\n\n  con->response->request.status.status_code =\n      interval ? IPP_OK : IPP_OK_EVENTS_COMPLETE;\n\n  for (i = 0; i < ids->num_values; i ++)\n  {\n   /*\n    * Get the subscription and sequence number...\n    */\n\n    sub = cupsdFindSubscription(ids->values[i].integer);\n\n    if (sequences && i < sequences->num_values)\n      min_seq = sequences->values[i].integer;\n    else\n      min_seq = 1;\n\n   /*\n    * If we don't have any new events, nothing to do here...\n    */\n\n    if (min_seq > (sub->first_event_id + cupsArrayCount(sub->events)))\n      continue;\n\n   /*\n    * Otherwise copy all of the new events...\n    */\n\n    if (sub->first_event_id > min_seq)\n      j = 0;\n    else\n      j = min_seq - sub->first_event_id;\n\n    for (; j < cupsArrayCount(sub->events); j ++)\n    {\n      ippAddSeparator(con->response);\n\n      copy_attrs(con->response,\n                 ((cupsd_event_t *)cupsArrayIndex(sub->events, j))->attrs, NULL,\n        \t IPP_TAG_EVENT_NOTIFICATION, 0, NULL);\n    }\n  }\n}\n\n\n/*\n * 'get_ppd()' - Get a named PPD from the local system.\n */\n\nstatic void\nget_ppd(cupsd_client_t  *con,\t\t/* I - Client connection */\n        ipp_attribute_t *uri)\t\t/* I - Printer URI or PPD name */\n{\n  http_status_t\t\tstatus;\t\t/* Policy status */\n  cupsd_printer_t\t*dest;\t\t/* Destination */\n  cups_ptype_t\t\tdtype;\t\t/* Destination type */\n\n\n  cupsdLogMessage(CUPSD_LOG_DEBUG2, \"get_ppd(%p[%d], %p[%s=%s])\", con,\n                  con->number, uri, uri->name, uri->values[0].string.text);\n\n  if (!strcmp(ippGetName(uri), \"ppd-name\"))\n  {\n   /*\n    * Return a PPD file from cups-driverd...\n    */\n\n    const char *ppd_name = ippGetString(uri, 0, NULL);\n\t\t\t\t\t/* ppd-name value */\n    char\tcommand[1024],\t\t/* cups-driverd command */\n\t\toptions[1024],\t\t/* Options to pass to command */\n\t\toppd_name[1024];\t/* Escaped ppd-name */\n\n   /*\n    * Check policy...\n    */\n\n    if ((status = cupsdCheckPolicy(DefaultPolicyPtr, con, NULL)) != HTTP_OK)\n    {\n      send_http_error(con, status, NULL);\n      return;\n    }\n\n   /*\n    * Check ppd-name value...\n    */\n\n    if (strstr(ppd_name, \"../\"))\n    {\n      send_ipp_status(con, IPP_STATUS_ERROR_ATTRIBUTES_OR_VALUES, _(\"Invalid ppd-name value.\"));\n      return;\n    }\n\n   /*\n    * Run cups-driverd command with the given options...\n    */\n\n    snprintf(command, sizeof(command), \"%s/daemon/cups-driverd\", ServerBin);\n    url_encode_string(ppd_name, oppd_name, sizeof(oppd_name));\n    snprintf(options, sizeof(options), \"get+%d+%s\", ippGetRequestId(con->request), oppd_name);\n\n    if (cupsdSendCommand(con, command, options, 0))\n    {\n     /*\n      * Command started successfully, don't send an IPP response here...\n      */\n\n      ippDelete(con->response);\n      con->response = NULL;\n    }\n    else\n    {\n     /*\n      * Command failed, return \"internal error\" so the user knows something\n      * went wrong...\n      */\n\n      send_ipp_status(con, IPP_INTERNAL_ERROR, _(\"cups-driverd failed to execute.\"));\n    }\n  }\n  else if (!strcmp(ippGetName(uri), \"printer-uri\") && cupsdValidateDest(ippGetString(uri, 0, NULL), &dtype, &dest))\n  {\n    int \ti;\t\t\t/* Looping var */\n    char\tfilename[1024];\t\t/* PPD filename */\n\n   /*\n    * Check policy...\n    */\n\n    if ((status = cupsdCheckPolicy(dest->op_policy_ptr, con, NULL)) != HTTP_OK)\n    {\n      send_http_error(con, status, dest);\n      return;\n    }\n\n   /*\n    * See if we need the PPD for a class or remote printer...\n    */\n\n    snprintf(filename, sizeof(filename), \"%s/ppd/%s.ppd\", ServerRoot, dest->name);\n\n    if ((dtype & CUPS_PRINTER_REMOTE) && access(filename, 0))\n    {\n      send_ipp_status(con, IPP_STATUS_CUPS_SEE_OTHER, _(\"See remote printer.\"));\n      ippAddString(con->response, IPP_TAG_OPERATION, IPP_TAG_URI, \"printer-uri\", NULL, dest->uri);\n      return;\n    }\n    else if (dtype & CUPS_PRINTER_CLASS)\n    {\n      for (i = 0; i < dest->num_printers; i ++)\n        if (!(dest->printers[i]->type & CUPS_PRINTER_CLASS))\n\t{\n\t  snprintf(filename, sizeof(filename), \"%s/ppd/%s.ppd\", ServerRoot, dest->printers[i]->name);\n\n          if (!access(filename, 0))\n\t    break;\n        }\n\n      if (i < dest->num_printers)\n        dest = dest->printers[i];\n      else\n      {\n\tsend_ipp_status(con, IPP_STATUS_CUPS_SEE_OTHER, _(\"See remote printer.\"));\n        ippAddString(con->response, IPP_TAG_OPERATION, IPP_TAG_URI, \"printer-uri\", NULL, dest->printers[0]->uri);\n        return;\n      }\n    }\n\n   /*\n    * Found the printer with the PPD file, now see if there is one...\n    */\n\n    if ((con->file = open(filename, O_RDONLY)) < 0)\n    {\n      send_ipp_status(con, IPP_STATUS_ERROR_NOT_FOUND, _(\"The PPD file \\\"%s\\\" could not be opened: %s\"), ippGetString(uri, 0, NULL), strerror(errno));\n      return;\n    }\n\n    fcntl(con->file, F_SETFD, fcntl(con->file, F_GETFD) | FD_CLOEXEC);\n\n    con->pipe_pid = 0;\n\n    ippSetStatusCode(con->response, IPP_STATUS_OK);\n  }\n  else\n    send_ipp_status(con, IPP_STATUS_ERROR_NOT_FOUND, _(\"The PPD file \\\"%s\\\" could not be found.\"), ippGetString(uri, 0, NULL));\n}\n\n\n/*\n * 'get_ppds()' - Get the list of PPD files on the local system.\n */\n\nstatic void\nget_ppds(cupsd_client_t *con)\t\t/* I - Client connection */\n{\n  http_status_t\t\tstatus;\t\t/* Policy status */\n  ipp_attribute_t\t*limit,\t\t/* Limit attribute */\n\t\t\t*device,\t/* ppd-device-id attribute */\n\t\t\t*language,\t/* ppd-natural-language attribute */\n\t\t\t*make,\t\t/* ppd-make attribute */\n\t\t\t*model,\t\t/* ppd-make-and-model attribute */\n\t\t\t*model_number,\t/* ppd-model-number attribute */\n\t\t\t*product,\t/* ppd-product attribute */\n\t\t\t*psversion,\t/* ppd-psverion attribute */\n\t\t\t*type,\t\t/* ppd-type attribute */\n\t\t\t*requested,\t/* requested-attributes attribute */\n\t\t\t*exclude,\t/* exclude-schemes attribute */\n\t\t\t*include;\t/* include-schemes attribute */\n  char\t\t\tcommand[1024],\t/* cups-driverd command */\n\t\t\toptions[4096],\t/* Options to pass to command */\n\t\t\tdevice_str[256],/* Escaped ppd-device-id string */\n\t\t\tlanguage_str[256],\n\t\t\t\t\t/* Escaped ppd-natural-language */\n\t\t\tmake_str[256],\t/* Escaped ppd-make string */\n\t\t\tmodel_str[256],\t/* Escaped ppd-make-and-model string */\n\t\t\tmodel_number_str[256],\n\t\t\t\t\t/* ppd-model-number string */\n\t\t\tproduct_str[256],\n\t\t\t\t\t/* Escaped ppd-product string */\n\t\t\tpsversion_str[256],\n\t\t\t\t\t/* Escaped ppd-psversion string */\n\t\t\ttype_str[256],\t/* Escaped ppd-type string */\n\t\t\trequested_str[256],\n\t\t\t\t\t/* String for requested attributes */\n\t\t\texclude_str[512],\n\t\t\t\t\t/* String for excluded schemes */\n\t\t\tinclude_str[512];\n\t\t\t\t\t/* String for included schemes */\n\n\n  cupsdLogMessage(CUPSD_LOG_DEBUG2, \"get_ppds(%p[%d])\", con, con->number);\n\n /*\n  * Check policy...\n  */\n\n  if ((status = cupsdCheckPolicy(DefaultPolicyPtr, con, NULL)) != HTTP_OK)\n  {\n    send_http_error(con, status, NULL);\n    return;\n  }\n\n /*\n  * Run cups-driverd command with the given options...\n  */\n\n  limit        = ippFindAttribute(con->request, \"limit\", IPP_TAG_INTEGER);\n  device       = ippFindAttribute(con->request, \"ppd-device-id\", IPP_TAG_TEXT);\n  language     = ippFindAttribute(con->request, \"ppd-natural-language\",\n                                  IPP_TAG_LANGUAGE);\n  make         = ippFindAttribute(con->request, \"ppd-make\", IPP_TAG_TEXT);\n  model        = ippFindAttribute(con->request, \"ppd-make-and-model\",\n                                  IPP_TAG_TEXT);\n  model_number = ippFindAttribute(con->request, \"ppd-model-number\",\n                                  IPP_TAG_INTEGER);\n  product      = ippFindAttribute(con->request, \"ppd-product\", IPP_TAG_TEXT);\n  psversion    = ippFindAttribute(con->request, \"ppd-psversion\", IPP_TAG_TEXT);\n  type         = ippFindAttribute(con->request, \"ppd-type\", IPP_TAG_KEYWORD);\n  requested    = ippFindAttribute(con->request, \"requested-attributes\",\n                                  IPP_TAG_KEYWORD);\n  exclude      = ippFindAttribute(con->request, \"exclude-schemes\",\n                                  IPP_TAG_NAME);\n  include      = ippFindAttribute(con->request, \"include-schemes\",\n                                  IPP_TAG_NAME);\n\n  if (requested)\n    url_encode_attr(requested, requested_str, sizeof(requested_str));\n  else\n    strlcpy(requested_str, \"requested-attributes=all\", sizeof(requested_str));\n\n  if (device)\n    url_encode_attr(device, device_str, sizeof(device_str));\n  else\n    device_str[0] = '\\0';\n\n  if (language)\n    url_encode_attr(language, language_str, sizeof(language_str));\n  else\n    language_str[0] = '\\0';\n\n  if (make)\n    url_encode_attr(make, make_str, sizeof(make_str));\n  else\n    make_str[0] = '\\0';\n\n  if (model)\n    url_encode_attr(model, model_str, sizeof(model_str));\n  else\n    model_str[0] = '\\0';\n\n  if (model_number)\n    snprintf(model_number_str, sizeof(model_number_str), \"ppd-model-number=%d\",\n             model_number->values[0].integer);\n  else\n    model_number_str[0] = '\\0';\n\n  if (product)\n    url_encode_attr(product, product_str, sizeof(product_str));\n  else\n    product_str[0] = '\\0';\n\n  if (psversion)\n    url_encode_attr(psversion, psversion_str, sizeof(psversion_str));\n  else\n    psversion_str[0] = '\\0';\n\n  if (type)\n    url_encode_attr(type, type_str, sizeof(type_str));\n  else\n    type_str[0] = '\\0';\n\n  if (exclude)\n    url_encode_attr(exclude, exclude_str, sizeof(exclude_str));\n  else\n    exclude_str[0] = '\\0';\n\n  if (include)\n    url_encode_attr(include, include_str, sizeof(include_str));\n  else\n    include_str[0] = '\\0';\n\n  snprintf(command, sizeof(command), \"%s/daemon/cups-driverd\", ServerBin);\n  snprintf(options, sizeof(options),\n           \"list+%d+%d+%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s\",\n           con->request->request.op.request_id,\n           limit ? limit->values[0].integer : 0,\n\t   requested_str,\n\t   device ? \"%20\" : \"\", device_str,\n\t   language ? \"%20\" : \"\", language_str,\n\t   make ? \"%20\" : \"\", make_str,\n\t   model ? \"%20\" : \"\", model_str,\n\t   model_number ? \"%20\" : \"\", model_number_str,\n\t   product ? \"%20\" : \"\", product_str,\n\t   psversion ? \"%20\" : \"\", psversion_str,\n\t   type ? \"%20\" : \"\", type_str,\n\t   exclude_str[0] ? \"%20\" : \"\", exclude_str,\n\t   include_str[0] ? \"%20\" : \"\", include_str);\n\n  if (cupsdSendCommand(con, command, options, 0))\n  {\n   /*\n    * Command started successfully, don't send an IPP response here...\n    */\n\n    ippDelete(con->response);\n    con->response = NULL;\n  }\n  else\n  {\n   /*\n    * Command failed, return \"internal error\" so the user knows something\n    * went wrong...\n    */\n\n    send_ipp_status(con, IPP_INTERNAL_ERROR,\n                    _(\"cups-driverd failed to execute.\"));\n  }\n}\n\n\n/*\n * 'get_printer_attrs()' - Get printer attributes.\n */\n\nstatic void\nget_printer_attrs(cupsd_client_t  *con,\t/* I - Client connection */\n\t\t  ipp_attribute_t *uri)\t/* I - Printer URI */\n{\n  http_status_t\t\tstatus;\t\t/* Policy status */\n  cups_ptype_t\t\tdtype;\t\t/* Destination type (printer/class) */\n  cupsd_printer_t\t*printer;\t/* Printer/class */\n  cups_array_t\t\t*ra;\t\t/* Requested attributes array */\n\n\n  cupsdLogMessage(CUPSD_LOG_DEBUG2, \"get_printer_attrs(%p[%d], %s)\", con,\n                  con->number, uri->values[0].string.text);\n\n /*\n  * Is the destination valid?\n  */\n\n  if (!cupsdValidateDest(uri->values[0].string.text, &dtype, &printer))\n  {\n   /*\n    * Bad URI...\n    */\n\n    send_ipp_status(con, IPP_NOT_FOUND,\n                    _(\"The printer or class does not exist.\"));\n    return;\n  }\n\n /*\n  * Check policy...\n  */\n\n  if ((status = cupsdCheckPolicy(printer->op_policy_ptr, con, NULL)) != HTTP_OK)\n  {\n    send_http_error(con, status, printer);\n    return;\n  }\n\n /*\n  * Send the attributes...\n  */\n\n  ra = create_requested_array(con->request);\n\n  copy_printer_attrs(con, printer, ra);\n\n  cupsArrayDelete(ra);\n\n  con->response->request.status.status_code = IPP_OK;\n}\n\n\n/*\n * 'get_printer_supported()' - Get printer supported values.\n */\n\nstatic void\nget_printer_supported(\n    cupsd_client_t  *con,\t\t/* I - Client connection */\n    ipp_attribute_t *uri)\t\t/* I - Printer URI */\n{\n  http_status_t\t\tstatus;\t\t/* Policy status */\n  cups_ptype_t\t\tdtype;\t\t/* Destination type (printer/class) */\n  cupsd_printer_t\t*printer;\t/* Printer/class */\n\n\n  cupsdLogMessage(CUPSD_LOG_DEBUG2, \"get_printer_supported(%p[%d], %s)\", con,\n                  con->number, uri->values[0].string.text);\n\n /*\n  * Is the destination valid?\n  */\n\n  if (!cupsdValidateDest(uri->values[0].string.text, &dtype, &printer))\n  {\n   /*\n    * Bad URI...\n    */\n\n    send_ipp_status(con, IPP_NOT_FOUND,\n                    _(\"The printer or class does not exist.\"));\n    return;\n  }\n\n /*\n  * Check policy...\n  */\n\n  if ((status = cupsdCheckPolicy(printer->op_policy_ptr, con, NULL)) != HTTP_OK)\n  {\n    send_http_error(con, status, printer);\n    return;\n  }\n\n /*\n  * Return a list of attributes that can be set via Set-Printer-Attributes.\n  */\n\n  ippAddInteger(con->response, IPP_TAG_PRINTER, IPP_TAG_ADMINDEFINE,\n                \"printer-geo-location\", 0);\n  ippAddInteger(con->response, IPP_TAG_PRINTER, IPP_TAG_ADMINDEFINE,\n                \"printer-info\", 0);\n  ippAddInteger(con->response, IPP_TAG_PRINTER, IPP_TAG_ADMINDEFINE,\n                \"printer-location\", 0);\n  ippAddInteger(con->response, IPP_TAG_PRINTER, IPP_TAG_ADMINDEFINE,\n                \"printer-organization\", 0);\n  ippAddInteger(con->response, IPP_TAG_PRINTER, IPP_TAG_ADMINDEFINE,\n                \"printer-organizational-unit\", 0);\n\n  con->response->request.status.status_code = IPP_OK;\n}\n\n\n/*\n * 'get_printers()' - Get a list of printers or classes.\n */\n\nstatic void\nget_printers(cupsd_client_t *con,\t/* I - Client connection */\n             int            type)\t/* I - 0 or CUPS_PRINTER_CLASS */\n{\n  http_status_t\tstatus;\t\t\t/* Policy status */\n  ipp_attribute_t *attr;\t\t/* Current attribute */\n  int\t\tlimit;\t\t\t/* Max number of printers to return */\n  int\t\tcount;\t\t\t/* Number of printers that match */\n  cupsd_printer_t *printer;\t\t/* Current printer pointer */\n  cups_ptype_t\tprinter_type,\t\t/* printer-type attribute */\n\t\tprinter_mask;\t\t/* printer-type-mask attribute */\n  char\t\t*location;\t\t/* Location string */\n  const char\t*username;\t\t/* Current user */\n  char\t\t*first_printer_name;\t/* first-printer-name attribute */\n  cups_array_t\t*ra;\t\t\t/* Requested attributes array */\n  int\t\tlocal;\t\t\t/* Local connection? */\n\n\n  cupsdLogMessage(CUPSD_LOG_DEBUG2, \"get_printers(%p[%d], %x)\", con,\n                  con->number, type);\n\n /*\n  * Check policy...\n  */\n\n  if ((status = cupsdCheckPolicy(DefaultPolicyPtr, con, NULL)) != HTTP_OK)\n  {\n    send_http_error(con, status, NULL);\n    return;\n  }\n\n /*\n  * Check for printers...\n  */\n\n  if (!Printers || !cupsArrayCount(Printers))\n  {\n    send_ipp_status(con, IPP_NOT_FOUND, _(\"No destinations added.\"));\n    return;\n  }\n\n /*\n  * See if they want to limit the number of printers reported...\n  */\n\n  if ((attr = ippFindAttribute(con->request, \"limit\",\n                               IPP_TAG_INTEGER)) != NULL)\n    limit = attr->values[0].integer;\n  else\n    limit = 10000000;\n\n  if ((attr = ippFindAttribute(con->request, \"first-printer-name\",\n                               IPP_TAG_NAME)) != NULL)\n    first_printer_name = attr->values[0].string.text;\n  else\n    first_printer_name = NULL;\n\n /*\n  * Support filtering...\n  */\n\n  if ((attr = ippFindAttribute(con->request, \"printer-type\",\n                               IPP_TAG_ENUM)) != NULL)\n    printer_type = (cups_ptype_t)attr->values[0].integer;\n  else\n    printer_type = (cups_ptype_t)0;\n\n  if ((attr = ippFindAttribute(con->request, \"printer-type-mask\",\n                               IPP_TAG_ENUM)) != NULL)\n    printer_mask = (cups_ptype_t)attr->values[0].integer;\n  else\n    printer_mask = (cups_ptype_t)0;\n\n  local = httpAddrLocalhost(&(con->clientaddr));\n\n  if ((attr = ippFindAttribute(con->request, \"printer-location\",\n                               IPP_TAG_TEXT)) != NULL)\n    location = attr->values[0].string.text;\n  else\n    location = NULL;\n\n  if (con->username[0])\n    username = con->username;\n  else if ((attr = ippFindAttribute(con->request, \"requesting-user-name\",\n                                    IPP_TAG_NAME)) != NULL)\n    username = attr->values[0].string.text;\n  else\n    username = NULL;\n\n  ra = create_requested_array(con->request);\n\n /*\n  * OK, build a list of printers for this printer...\n  */\n\n  if (first_printer_name)\n  {\n    if ((printer = cupsdFindDest(first_printer_name)) == NULL)\n      printer = (cupsd_printer_t *)cupsArrayFirst(Printers);\n  }\n  else\n    printer = (cupsd_printer_t *)cupsArrayFirst(Printers);\n\n  for (count = 0;\n       count < limit && printer;\n       printer = (cupsd_printer_t *)cupsArrayNext(Printers))\n  {\n    if (!local && !printer->shared)\n      continue;\n\n    if ((!type || (printer->type & CUPS_PRINTER_CLASS) == type) &&\n        (printer->type & printer_mask) == printer_type &&\n\t(!location ||\n\t (printer->location && !_cups_strcasecmp(printer->location, location))))\n    {\n     /*\n      * If a username is specified, see if it is allowed or denied\n      * access...\n      */\n\n      if (cupsArrayCount(printer->users) && username &&\n\t  !user_allowed(printer, username))\n        continue;\n\n     /*\n      * Add the group separator as needed...\n      */\n\n      if (count > 0)\n        ippAddSeparator(con->response);\n\n      count ++;\n\n     /*\n      * Send the attributes...\n      */\n\n      copy_printer_attrs(con, printer, ra);\n    }\n  }\n\n  cupsArrayDelete(ra);\n\n  con->response->request.status.status_code = IPP_OK;\n}\n\n\n/*\n * 'get_subscription_attrs()' - Get subscription attributes.\n */\n\nstatic void\nget_subscription_attrs(\n    cupsd_client_t *con,\t\t/* I - Client connection */\n    int            sub_id)\t\t/* I - Subscription ID */\n{\n  http_status_t\t\tstatus;\t\t/* Policy status */\n  cupsd_subscription_t\t*sub;\t\t/* Subscription */\n  cupsd_policy_t\t*policy;\t/* Current security policy */\n  cups_array_t\t\t*ra,\t\t/* Requested attributes array */\n\t\t\t*exclude;\t/* Private attributes array */\n\n\n  cupsdLogMessage(CUPSD_LOG_DEBUG2,\n                  \"get_subscription_attrs(con=%p[%d], sub_id=%d)\",\n                  con, con->number, sub_id);\n\n /*\n  * Expire subscriptions as needed...\n  */\n\n  cupsdExpireSubscriptions(NULL, NULL);\n\n /*\n  * Is the subscription ID valid?\n  */\n\n  if ((sub = cupsdFindSubscription(sub_id)) == NULL)\n  {\n   /*\n    * Bad subscription ID...\n    */\n\n    send_ipp_status(con, IPP_NOT_FOUND, _(\"Subscription #%d does not exist.\"),\n                    sub_id);\n    return;\n  }\n\n /*\n  * Check policy...\n  */\n\n  if (sub->dest)\n    policy = sub->dest->op_policy_ptr;\n  else\n    policy = DefaultPolicyPtr;\n\n  if ((status = cupsdCheckPolicy(policy, con, sub->owner)) != HTTP_OK)\n  {\n    send_http_error(con, status, sub->dest);\n    return;\n  }\n\n  exclude = cupsdGetPrivateAttrs(policy, con, sub->dest, sub->owner);\n\n /*\n  * Copy the subscription attributes to the response using the\n  * requested-attributes attribute that may be provided by the client.\n  */\n\n  ra = create_requested_array(con->request);\n\n  copy_subscription_attrs(con, sub, ra, exclude);\n\n  cupsArrayDelete(ra);\n\n  con->response->request.status.status_code = IPP_OK;\n}\n\n\n/*\n * 'get_subscriptions()' - Get subscriptions.\n */\n\nstatic void\nget_subscriptions(cupsd_client_t  *con,\t/* I - Client connection */\n                  ipp_attribute_t *uri)\t/* I - Printer/job URI */\n{\n  http_status_t\t\tstatus;\t\t/* Policy status */\n  int\t\t\tcount;\t\t/* Number of subscriptions */\n  int\t\t\tlimit;\t\t/* Limit */\n  cupsd_subscription_t\t*sub;\t\t/* Subscription */\n  cups_array_t\t\t*ra;\t\t/* Requested attributes array */\n  ipp_attribute_t\t*attr;\t\t/* Attribute */\n  cups_ptype_t\t\tdtype;\t\t/* Destination type (printer/class) */\n  char\t\t\tscheme[HTTP_MAX_URI],\n\t\t\t\t\t/* Scheme portion of URI */\n\t\t\tusername[HTTP_MAX_URI],\n\t\t\t\t\t/* Username portion of URI */\n\t\t\thost[HTTP_MAX_URI],\n\t\t\t\t\t/* Host portion of URI */\n\t\t\tresource[HTTP_MAX_URI];\n\t\t\t\t\t/* Resource portion of URI */\n  int\t\t\tport;\t\t/* Port portion of URI */\n  cupsd_job_t\t\t*job;\t\t/* Job pointer */\n  cupsd_printer_t\t*printer;\t/* Printer */\n  cupsd_policy_t\t*policy;\t/* Policy */\n  cups_array_t\t\t*exclude;\t/* Private attributes array */\n\n\n  cupsdLogMessage(CUPSD_LOG_DEBUG2,\n                  \"get_subscriptions(con=%p[%d], uri=%s)\",\n                  con, con->number, uri->values[0].string.text);\n\n /*\n  * Is the destination valid?\n  */\n\n  httpSeparateURI(HTTP_URI_CODING_ALL, uri->values[0].string.text, scheme,\n                  sizeof(scheme), username, sizeof(username), host,\n\t\t  sizeof(host), &port, resource, sizeof(resource));\n\n  if (!strcmp(resource, \"/\") ||\n      (!strncmp(resource, \"/jobs\", 5) && strlen(resource) <= 6) ||\n      (!strncmp(resource, \"/printers\", 9) && strlen(resource) <= 10) ||\n      (!strncmp(resource, \"/classes\", 8) && strlen(resource) <= 9))\n  {\n    printer = NULL;\n    job     = NULL;\n  }\n  else if (!strncmp(resource, \"/jobs/\", 6) && resource[6])\n  {\n    printer = NULL;\n    job     = cupsdFindJob(atoi(resource + 6));\n\n    if (!job)\n    {\n      send_ipp_status(con, IPP_NOT_FOUND, _(\"Job #%d does not exist.\"),\n                      atoi(resource + 6));\n      return;\n    }\n  }\n  else if (!cupsdValidateDest(uri->values[0].string.text, &dtype, &printer))\n  {\n   /*\n    * Bad URI...\n    */\n\n    send_ipp_status(con, IPP_NOT_FOUND,\n                    _(\"The printer or class does not exist.\"));\n    return;\n  }\n  else if ((attr = ippFindAttribute(con->request, \"notify-job-id\",\n                                    IPP_TAG_INTEGER)) != NULL)\n  {\n    job = cupsdFindJob(attr->values[0].integer);\n\n    if (!job)\n    {\n      send_ipp_status(con, IPP_NOT_FOUND, _(\"Job #%d does not exist.\"),\n                      attr->values[0].integer);\n      return;\n    }\n  }\n  else\n    job = NULL;\n\n /*\n  * Check policy...\n  */\n\n  if (printer)\n    policy = printer->op_policy_ptr;\n  else\n    policy = DefaultPolicyPtr;\n\n  if ((status = cupsdCheckPolicy(policy, con, NULL)) != HTTP_OK)\n  {\n    send_http_error(con, status, printer);\n    return;\n  }\n\n /*\n  * Expire subscriptions as needed...\n  */\n\n  cupsdExpireSubscriptions(NULL, NULL);\n\n /*\n  * Copy the subscription attributes to the response using the\n  * requested-attributes attribute that may be provided by the client.\n  */\n\n  ra = create_requested_array(con->request);\n\n  if ((attr = ippFindAttribute(con->request, \"limit\",\n                               IPP_TAG_INTEGER)) != NULL)\n    limit = attr->values[0].integer;\n  else\n    limit = 0;\n\n /*\n  * See if we only want to see subscriptions for a specific user...\n  */\n\n  if ((attr = ippFindAttribute(con->request, \"my-subscriptions\",\n                               IPP_TAG_BOOLEAN)) != NULL &&\n      attr->values[0].boolean)\n    strlcpy(username, get_username(con), sizeof(username));\n  else\n    username[0] = '\\0';\n\n  for (sub = (cupsd_subscription_t *)cupsArrayFirst(Subscriptions), count = 0;\n       sub;\n       sub = (cupsd_subscription_t *)cupsArrayNext(Subscriptions))\n    if ((!printer || sub->dest == printer) && (!job || sub->job == job) &&\n        (!username[0] || !_cups_strcasecmp(username, sub->owner)))\n    {\n      ippAddSeparator(con->response);\n\n      exclude = cupsdGetPrivateAttrs(sub->dest ? sub->dest->op_policy_ptr :\n\t\t\t\t\t\t policy, con, sub->dest,\n\t\t\t\t\t\t sub->owner);\n\n      copy_subscription_attrs(con, sub, ra, exclude);\n\n      count ++;\n      if (limit && count >= limit)\n        break;\n    }\n\n  cupsArrayDelete(ra);\n\n  if (count)\n    con->response->request.status.status_code = IPP_OK;\n  else\n    send_ipp_status(con, IPP_NOT_FOUND, _(\"No subscriptions found.\"));\n}\n\n\n/*\n * 'get_username()' - Get the username associated with a request.\n */\n\nstatic const char *\t\t\t/* O - Username */\nget_username(cupsd_client_t *con)\t/* I - Connection */\n{\n  ipp_attribute_t\t*attr;\t\t/* Attribute */\n\n\n  if (con->username[0])\n    return (con->username);\n  else if ((attr = ippFindAttribute(con->request, \"requesting-user-name\",\n                                    IPP_TAG_NAME)) != NULL)\n    return (attr->values[0].string.text);\n  else\n    return (\"anonymous\");\n}\n\n\n/*\n * 'hold_job()' - Hold a print job.\n */\n\nstatic void\nhold_job(cupsd_client_t  *con,\t\t/* I - Client connection */\n         ipp_attribute_t *uri)\t\t/* I - Job or Printer URI */\n{\n  ipp_attribute_t *attr;\t\t/* Current job-hold-until */\n  const char\t*when;\t\t\t/* New value */\n  int\t\tjobid;\t\t\t/* Job ID */\n  char\t\tscheme[HTTP_MAX_URI],\t/* Method portion of URI */\n\t\tusername[HTTP_MAX_URI],\t/* Username portion of URI */\n\t\thost[HTTP_MAX_URI],\t/* Host portion of URI */\n\t\tresource[HTTP_MAX_URI];\t/* Resource portion of URI */\n  int\t\tport;\t\t\t/* Port portion of URI */\n  cupsd_job_t\t*job;\t\t\t/* Job information */\n\n\n  cupsdLogMessage(CUPSD_LOG_DEBUG2, \"hold_job(%p[%d], %s)\", con, con->number,\n                  uri->values[0].string.text);\n\n /*\n  * See if we have a job URI or a printer URI...\n  */\n\n  if (!strcmp(uri->name, \"printer-uri\"))\n  {\n   /*\n    * Got a printer URI; see if we also have a job-id attribute...\n    */\n\n    if ((attr = ippFindAttribute(con->request, \"job-id\",\n                                 IPP_TAG_INTEGER)) == NULL)\n    {\n      send_ipp_status(con, IPP_BAD_REQUEST,\n                      _(\"Got a printer-uri attribute but no job-id.\"));\n      return;\n    }\n\n    jobid = attr->values[0].integer;\n  }\n  else\n  {\n   /*\n    * Got a job URI; parse it to get the job ID...\n    */\n\n    httpSeparateURI(HTTP_URI_CODING_ALL, uri->values[0].string.text, scheme,\n                    sizeof(scheme), username, sizeof(username), host,\n\t\t    sizeof(host), &port, resource, sizeof(resource));\n\n    if (strncmp(resource, \"/jobs/\", 6))\n    {\n     /*\n      * Not a valid URI!\n      */\n\n      send_ipp_status(con, IPP_BAD_REQUEST,\n                      _(\"Bad job-uri \\\"%s\\\".\"),\n                      uri->values[0].string.text);\n      return;\n    }\n\n    jobid = atoi(resource + 6);\n  }\n\n /*\n  * See if the job exists...\n  */\n\n  if ((job = cupsdFindJob(jobid)) == NULL)\n  {\n   /*\n    * Nope - return a \"not found\" error...\n    */\n\n    send_ipp_status(con, IPP_NOT_FOUND, _(\"Job #%d does not exist.\"), jobid);\n    return;\n  }\n\n /*\n  * See if the job is owned by the requesting user...\n  */\n\n  if (!validate_user(job, con, job->username, username, sizeof(username)))\n  {\n    send_http_error(con, con->username[0] ? HTTP_FORBIDDEN : HTTP_UNAUTHORIZED,\n\t\t    cupsdFindDest(job->dest));\n    return;\n  }\n\n /*\n  * See if the job is in a state that allows holding...\n  */\n\n  if (job->state_value > IPP_JOB_STOPPED)\n  {\n   /*\n    * Return a \"not-possible\" error...\n    */\n\n    send_ipp_status(con, IPP_NOT_POSSIBLE,\n\t\t    _(\"Job #%d is finished and cannot be altered.\"),\n\t\t    job->id);\n    return;\n  }\n\n /*\n  * Hold the job and return...\n  */\n\n  if ((attr = ippFindAttribute(con->request, \"job-hold-until\",\n\t\t\t       IPP_TAG_KEYWORD)) == NULL)\n    attr = ippFindAttribute(con->request, \"job-hold-until\", IPP_TAG_NAME);\n\n  if (attr)\n  {\n    when = attr->values[0].string.text;\n\n    cupsdAddEvent(CUPSD_EVENT_JOB_CONFIG_CHANGED, cupsdFindDest(job->dest), job,\n\t\t  \"Job job-hold-until value changed by user.\");\n  }\n  else\n    when = \"indefinite\";\n\n  cupsdSetJobHoldUntil(job, when, 1);\n  cupsdSetJobState(job, IPP_JOB_HELD, CUPSD_JOB_DEFAULT, \"Job held by \\\"%s\\\".\",\n                   username);\n\n  con->response->request.status.status_code = IPP_OK;\n}\n\n\n/*\n * 'hold_new_jobs()' - Hold pending/new jobs on a printer or class.\n */\n\nstatic void\nhold_new_jobs(cupsd_client_t  *con,\t/* I - Connection */\n              ipp_attribute_t *uri)\t/* I - Printer URI */\n{\n  http_status_t\t\tstatus;\t\t/* Policy status */\n  cups_ptype_t\t\tdtype;\t\t/* Destination type (printer/class) */\n  cupsd_printer_t\t*printer;\t/* Printer data */\n\n\n  cupsdLogMessage(CUPSD_LOG_DEBUG2, \"hold_new_jobs(%p[%d], %s)\", con,\n                  con->number, uri->values[0].string.text);\n\n /*\n  * Is the destination valid?\n  */\n\n  if (!cupsdValidateDest(uri->values[0].string.text, &dtype, &printer))\n  {\n   /*\n    * Bad URI...\n    */\n\n    send_ipp_status(con, IPP_NOT_FOUND,\n                    _(\"The printer or class does not exist.\"));\n    return;\n  }\n\n /*\n  * Check policy...\n  */\n\n  if ((status = cupsdCheckPolicy(printer->op_policy_ptr, con, NULL)) != HTTP_OK)\n  {\n    send_http_error(con, status, printer);\n    return;\n  }\n\n /*\n  * Hold pending/new jobs sent to the printer...\n  */\n\n  printer->holding_new_jobs = 1;\n\n  cupsdSetPrinterReasons(printer, \"+hold-new-jobs\");\n\n  if (dtype & CUPS_PRINTER_CLASS)\n    cupsdLogMessage(CUPSD_LOG_INFO,\n                    \"Class \\\"%s\\\" now holding pending/new jobs (\\\"%s\\\").\",\n                    printer->name, get_username(con));\n  else\n    cupsdLogMessage(CUPSD_LOG_INFO,\n                    \"Printer \\\"%s\\\" now holding pending/new jobs (\\\"%s\\\").\",\n                    printer->name, get_username(con));\n\n /*\n  * Everything was ok, so return OK status...\n  */\n\n  con->response->request.status.status_code = IPP_OK;\n}\n\n\n/*\n * 'move_job()' - Move a job to a new destination.\n */\n\nstatic void\nmove_job(cupsd_client_t  *con,\t\t/* I - Client connection */\n\t ipp_attribute_t *uri)\t\t/* I - Job URI */\n{\n  http_status_t\tstatus;\t\t\t/* Policy status */\n  ipp_attribute_t *attr;\t\t/* Current attribute */\n  int\t\tjobid;\t\t\t/* Job ID */\n  cupsd_job_t\t*job;\t\t\t/* Current job */\n  const char\t*src;\t\t\t/* Source printer/class */\n  cups_ptype_t\tstype,\t\t\t/* Source type (printer or class) */\n\t\tdtype;\t\t\t/* Destination type (printer/class) */\n  char\t\tscheme[HTTP_MAX_URI],\t/* Scheme portion of URI */\n\t\tusername[HTTP_MAX_URI],\t/* Username portion of URI */\n\t\thost[HTTP_MAX_URI],\t/* Host portion of URI */\n\t\tresource[HTTP_MAX_URI];\t/* Resource portion of URI */\n  int\t\tport;\t\t\t/* Port portion of URI */\n  cupsd_printer_t *sprinter,\t\t/* Source printer */\n\t\t*dprinter;\t\t/* Destination printer */\n\n\n  cupsdLogMessage(CUPSD_LOG_DEBUG2, \"move_job(%p[%d], %s)\", con, con->number,\n                  uri->values[0].string.text);\n\n /*\n  * Get the new printer or class...\n  */\n\n  if ((attr = ippFindAttribute(con->request, \"job-printer-uri\",\n                               IPP_TAG_URI)) == NULL)\n  {\n   /*\n    * Need job-printer-uri...\n    */\n\n    send_ipp_status(con, IPP_BAD_REQUEST,\n                    _(\"job-printer-uri attribute missing.\"));\n    return;\n  }\n\n  if (!cupsdValidateDest(attr->values[0].string.text, &dtype, &dprinter))\n  {\n   /*\n    * Bad URI...\n    */\n\n    send_ipp_status(con, IPP_NOT_FOUND,\n                    _(\"The printer or class does not exist.\"));\n    return;\n  }\n\n /*\n  * See if we have a job URI or a printer URI...\n  */\n\n  httpSeparateURI(HTTP_URI_CODING_ALL, uri->values[0].string.text, scheme,\n                  sizeof(scheme), username, sizeof(username), host,\n\t\t  sizeof(host), &port, resource, sizeof(resource));\n\n  if (!strcmp(uri->name, \"printer-uri\"))\n  {\n   /*\n    * Got a printer URI; see if we also have a job-id attribute...\n    */\n\n    if ((attr = ippFindAttribute(con->request, \"job-id\",\n                                 IPP_TAG_INTEGER)) == NULL)\n    {\n     /*\n      * Move all jobs...\n      */\n\n      if ((src = cupsdValidateDest(uri->values[0].string.text, &stype,\n                                   &sprinter)) == NULL)\n      {\n       /*\n\t* Bad URI...\n\t*/\n\n\tsend_ipp_status(con, IPP_NOT_FOUND,\n                \t_(\"The printer or class does not exist.\"));\n\treturn;\n      }\n\n      job = NULL;\n    }\n    else\n    {\n     /*\n      * Otherwise, just move a single job...\n      */\n\n      if ((job = cupsdFindJob(attr->values[0].integer)) == NULL)\n      {\n       /*\n\t* Nope - return a \"not found\" error...\n\t*/\n\n\tsend_ipp_status(con, IPP_NOT_FOUND,\n                \t_(\"Job #%d does not exist.\"), attr->values[0].integer);\n\treturn;\n      }\n      else\n      {\n       /*\n        * Job found, initialize source pointers...\n\t*/\n\n\tsrc      = NULL;\n\tsprinter = NULL;\n      }\n    }\n  }\n  else\n  {\n   /*\n    * Got a job URI; parse it to get the job ID...\n    */\n\n    if (strncmp(resource, \"/jobs/\", 6))\n    {\n     /*\n      * Not a valid URI!\n      */\n\n      send_ipp_status(con, IPP_BAD_REQUEST, _(\"Bad job-uri \\\"%s\\\".\"),\n                      uri->values[0].string.text);\n      return;\n    }\n\n   /*\n    * See if the job exists...\n    */\n\n    jobid = atoi(resource + 6);\n\n    if ((job = cupsdFindJob(jobid)) == NULL)\n    {\n     /*\n      * Nope - return a \"not found\" error...\n      */\n\n      send_ipp_status(con, IPP_NOT_FOUND, _(\"Job #%d does not exist.\"), jobid);\n      return;\n    }\n    else\n    {\n     /*\n      * Job found, initialize source pointers...\n      */\n\n      src      = NULL;\n      sprinter = NULL;\n    }\n  }\n\n /*\n  * Check the policy of the destination printer...\n  */\n\n  if ((status = cupsdCheckPolicy(dprinter->op_policy_ptr, con,\n                                 job ? job->username : NULL)) != HTTP_OK)\n  {\n    send_http_error(con, status, dprinter);\n    return;\n  }\n\n /*\n  * Now move the job or jobs...\n  */\n\n  if (job)\n  {\n   /*\n    * See if the job has been completed...\n    */\n\n    if (job->state_value > IPP_JOB_STOPPED)\n    {\n     /*\n      * Return a \"not-possible\" error...\n      */\n\n      send_ipp_status(con, IPP_NOT_POSSIBLE,\n                      _(\"Job #%d is finished and cannot be altered.\"),\n\t\t      job->id);\n      return;\n    }\n\n   /*\n    * See if the job is owned by the requesting user...\n    */\n\n    if (!validate_user(job, con, job->username, username, sizeof(username)))\n    {\n      send_http_error(con, con->username[0] ? HTTP_FORBIDDEN : HTTP_UNAUTHORIZED,\n                      cupsdFindDest(job->dest));\n      return;\n    }\n\n   /*\n    * Move the job to a different printer or class...\n    */\n\n    cupsdMoveJob(job, dprinter);\n  }\n  else\n  {\n   /*\n    * Got the source printer, now look through the jobs...\n    */\n\n    for (job = (cupsd_job_t *)cupsArrayFirst(Jobs);\n         job;\n\t job = (cupsd_job_t *)cupsArrayNext(Jobs))\n    {\n     /*\n      * See if the job is pointing at the source printer or has not been\n      * completed...\n      */\n\n      if (_cups_strcasecmp(job->dest, src) ||\n          job->state_value > IPP_JOB_STOPPED)\n\tcontinue;\n\n     /*\n      * See if the job can be moved by the requesting user...\n      */\n\n      if (!validate_user(job, con, job->username, username, sizeof(username)))\n        continue;\n\n     /*\n      * Move the job to a different printer or class...\n      */\n\n      cupsdMoveJob(job, dprinter);\n    }\n  }\n\n /*\n  * Start jobs if possible...\n  */\n\n  cupsdCheckJobs();\n\n /*\n  * Return with \"everything is OK\" status...\n  */\n\n  con->response->request.status.status_code = IPP_OK;\n}\n\n\n/*\n * 'ppd_parse_line()' - Parse a PPD default line.\n */\n\nstatic int\t\t\t\t/* O - 0 on success, -1 on failure */\nppd_parse_line(const char *line,\t/* I - Line */\n               char       *option,\t/* O - Option name */\n\t       int        olen,\t\t/* I - Size of option name */\n               char       *choice,\t/* O - Choice name */\n\t       int        clen)\t\t/* I - Size of choice name */\n{\n /*\n  * Verify this is a default option line...\n  */\n\n  if (strncmp(line, \"*Default\", 8))\n    return (-1);\n\n /*\n  * Read the option name...\n  */\n\n  for (line += 8, olen --;\n       *line > ' ' && *line < 0x7f && *line != ':' && *line != '/';\n       line ++)\n    if (olen > 0)\n    {\n      *option++ = *line;\n      olen --;\n    }\n\n  *option = '\\0';\n\n /*\n  * Skip everything else up to the colon (:)...\n  */\n\n  while (*line && *line != ':')\n    line ++;\n\n  if (!*line)\n    return (-1);\n\n  line ++;\n\n /*\n  * Now grab the option choice, skipping leading whitespace...\n  */\n\n  while (isspace(*line & 255))\n    line ++;\n\n  for (clen --;\n       *line > ' ' && *line < 0x7f && *line != ':' && *line != '/';\n       line ++)\n    if (clen > 0)\n    {\n      *choice++ = *line;\n      clen --;\n    }\n\n  *choice = '\\0';\n\n /*\n  * Return with no errors...\n  */\n\n  return (0);\n}\n\n\n/*\n * 'print_job()' - Print a file to a printer or class.\n */\n\nstatic void\nprint_job(cupsd_client_t  *con,\t\t/* I - Client connection */\n\t  ipp_attribute_t *uri)\t\t/* I - Printer URI */\n{\n  ipp_attribute_t *attr;\t\t/* Current attribute */\n  ipp_attribute_t *doc_name;\t\t/* document-name attribute */\n  ipp_attribute_t *format;\t\t/* Document-format attribute */\n  const char\t*default_format;\t/* document-format-default value */\n  cupsd_job_t\t*job;\t\t\t/* New job */\n  char\t\tfilename[1024];\t\t/* Job filename */\n  mime_type_t\t*filetype;\t\t/* Type of file */\n  char\t\tsuper[MIME_MAX_SUPER],\t/* Supertype of file */\n\t\ttype[MIME_MAX_TYPE],\t/* Subtype of file */\n\t\tmimetype[MIME_MAX_SUPER + MIME_MAX_TYPE + 2];\n\t\t\t\t\t/* Textual name of mime type */\n  cupsd_printer_t *printer;\t\t/* Printer data */\n  struct stat\tfileinfo;\t\t/* File information */\n  int\t\tkbytes;\t\t\t/* Size of file */\n  int\t\tcompression;\t\t/* Document compression */\n\n\n  cupsdLogMessage(CUPSD_LOG_DEBUG2, \"print_job(%p[%d], %s)\", con, con->number,\n                  uri->values[0].string.text);\n\n /*\n  * Validate print file attributes, for now just document-format and\n  * compression (CUPS only supports \"none\" and \"gzip\")...\n  */\n\n  compression = CUPS_FILE_NONE;\n\n  if ((attr = ippFindAttribute(con->request, \"compression\",\n                               IPP_TAG_KEYWORD)) != NULL)\n  {\n    if (strcmp(attr->values[0].string.text, \"none\")\n#ifdef HAVE_LIBZ\n        && strcmp(attr->values[0].string.text, \"gzip\")\n#endif /* HAVE_LIBZ */\n      )\n    {\n      send_ipp_status(con, IPP_ATTRIBUTES,\n                      _(\"Unsupported compression \\\"%s\\\".\"),\n        \t      attr->values[0].string.text);\n      ippAddString(con->response, IPP_TAG_UNSUPPORTED_GROUP, IPP_TAG_KEYWORD,\n\t           \"compression\", NULL, attr->values[0].string.text);\n      return;\n    }\n\n#ifdef HAVE_LIBZ\n    if (!strcmp(attr->values[0].string.text, \"gzip\"))\n      compression = CUPS_FILE_GZIP;\n#endif /* HAVE_LIBZ */\n  }\n\n /*\n  * Do we have a file to print?\n  */\n\n  if (!con->filename)\n  {\n    send_ipp_status(con, IPP_BAD_REQUEST, _(\"No file in print request.\"));\n    return;\n  }\n\n /*\n  * Is the destination valid?\n  */\n\n  if (!cupsdValidateDest(uri->values[0].string.text, NULL, &printer))\n  {\n   /*\n    * Bad URI...\n    */\n\n    send_ipp_status(con, IPP_NOT_FOUND,\n                    _(\"The printer or class does not exist.\"));\n    return;\n  }\n\n /*\n  * Is it a format we support?\n  */\n\n  doc_name = ippFindAttribute(con->request, \"document-name\", IPP_TAG_NAME);\n  if (doc_name)\n    ippSetName(con->request, &doc_name, \"document-name-supplied\");\n\n  if ((format = ippFindAttribute(con->request, \"document-format\",\n                                 IPP_TAG_MIMETYPE)) != NULL)\n  {\n   /*\n    * Grab format from client...\n    */\n\n    if (sscanf(format->values[0].string.text, \"%15[^/]/%255[^;]\", super,\n               type) != 2)\n    {\n      send_ipp_status(con, IPP_BAD_REQUEST,\n                      _(\"Bad document-format \\\"%s\\\".\"),\n\t\t      format->values[0].string.text);\n      return;\n    }\n\n    ippAddString(con->request, IPP_TAG_JOB, IPP_TAG_MIMETYPE, \"document-format-supplied\", NULL, ippGetString(format, 0, NULL));\n  }\n  else if ((default_format = cupsGetOption(\"document-format\",\n                                           printer->num_options,\n\t\t\t\t\t   printer->options)) != NULL)\n  {\n   /*\n    * Use default document format...\n    */\n\n    if (sscanf(default_format, \"%15[^/]/%255[^;]\", super, type) != 2)\n    {\n      send_ipp_status(con, IPP_BAD_REQUEST,\n                      _(\"Bad document-format \\\"%s\\\".\"),\n\t\t      default_format);\n      return;\n    }\n  }\n  else\n  {\n   /*\n    * Auto-type it!\n    */\n\n    strlcpy(super, \"application\", sizeof(super));\n    strlcpy(type, \"octet-stream\", sizeof(type));\n  }\n\n  if (!strcmp(super, \"application\") && !strcmp(type, \"octet-stream\"))\n  {\n   /*\n    * Auto-type the file...\n    */\n\n    cupsdLogMessage(CUPSD_LOG_DEBUG, \"[Job ???] Auto-typing file...\");\n\n\n    filetype = mimeFileType(MimeDatabase, con->filename,\n                            doc_name ? doc_name->values[0].string.text : NULL,\n\t\t\t    &compression);\n\n    if (!filetype)\n      filetype = mimeType(MimeDatabase, super, type);\n\n    cupsdLogMessage(CUPSD_LOG_INFO, \"[Job ???] Request file type is %s/%s.\",\n\t\t    filetype->super, filetype->type);\n\n    snprintf(mimetype, sizeof(mimetype), \"%s/%s\", filetype->super, filetype->type);\n    ippAddString(con->request, IPP_TAG_JOB, IPP_TAG_MIMETYPE, \"document-format-detected\", NULL, mimetype);\n  }\n  else\n    filetype = mimeType(MimeDatabase, super, type);\n\n  if (filetype &&\n      (!format ||\n       (!strcmp(super, \"application\") && !strcmp(type, \"octet-stream\"))))\n  {\n   /*\n    * Replace the document-format attribute value with the auto-typed or\n    * default one.\n    */\n\n    snprintf(mimetype, sizeof(mimetype), \"%s/%s\", filetype->super,\n             filetype->type);\n\n    if (format)\n      ippSetString(con->request, &format, 0, mimetype);\n    else\n      ippAddString(con->request, IPP_TAG_JOB, IPP_TAG_MIMETYPE,\n\t           \"document-format\", NULL, mimetype);\n  }\n  else if (!filetype)\n  {\n    send_ipp_status(con, IPP_DOCUMENT_FORMAT,\n                    _(\"Unsupported document-format \\\"%s\\\".\"),\n\t\t    format ? format->values[0].string.text :\n\t\t\t     \"application/octet-stream\");\n    cupsdLogMessage(CUPSD_LOG_INFO,\n                    \"Hint: Do you have the raw file printing rules enabled?\");\n\n    if (format)\n      ippAddString(con->response, IPP_TAG_UNSUPPORTED_GROUP, IPP_TAG_MIMETYPE,\n                   \"document-format\", NULL, format->values[0].string.text);\n\n    return;\n  }\n\n /*\n  * Read any embedded job ticket info from PS files...\n  */\n\n  if (!_cups_strcasecmp(filetype->super, \"application\") &&\n      (!_cups_strcasecmp(filetype->type, \"postscript\") ||\n       !_cups_strcasecmp(filetype->type, \"pdf\")))\n    read_job_ticket(con);\n\n /*\n  * Create the job object...\n  */\n\n  if ((job = add_job(con, printer, filetype)) == NULL)\n    return;\n\n /*\n  * Update quota data...\n  */\n\n  if (stat(con->filename, &fileinfo))\n    kbytes = 0;\n  else\n    kbytes = (fileinfo.st_size + 1023) / 1024;\n\n  cupsdUpdateQuota(printer, job->username, 0, kbytes);\n\n  job->koctets += kbytes;\n\n  if ((attr = ippFindAttribute(job->attrs, \"job-k-octets\", IPP_TAG_INTEGER)) != NULL)\n    attr->values[0].integer += kbytes;\n\n /*\n  * Add the job file...\n  */\n\n  if (add_file(con, job, filetype, compression))\n    return;\n\n  snprintf(filename, sizeof(filename), \"%s/d%05d-%03d\", RequestRoot, job->id, job->num_files);\n  if (rename(con->filename, filename))\n  {\n    cupsdLogJob(job, CUPSD_LOG_ERROR, \"Unable to rename job document file \\\"%s\\\": %s\", filename, strerror(errno));\n\n    send_ipp_status(con, IPP_INTERNAL_ERROR, _(\"Unable to rename job document file.\"));\n    return;\n  }\n\n  cupsdClearString(&con->filename);\n\n /*\n  * See if we need to add the ending sheet...\n  */\n\n  if (cupsdTimeoutJob(job))\n    return;\n\n /*\n  * Log and save the job...\n  */\n\n  cupsdLogJob(job, CUPSD_LOG_INFO,\n\t      \"File of type %s/%s queued by \\\"%s\\\".\",\n\t      filetype->super, filetype->type, job->username);\n  cupsdLogJob(job, CUPSD_LOG_DEBUG, \"hold_until=%d\", (int)job->hold_until);\n  cupsdLogJob(job, CUPSD_LOG_INFO, \"Queued on \\\"%s\\\" by \\\"%s\\\".\",\n\t      job->dest, job->username);\n\n /*\n  * Start the job if possible...\n  */\n\n  cupsdCheckJobs();\n}\n\n\n/*\n * 'read_job_ticket()' - Read a job ticket embedded in a print file.\n *\n * This function only gets called when printing a single PDF or PostScript\n * file using the Print-Job operation.  It doesn't work for Create-Job +\n * Send-File, since the job attributes need to be set at job creation\n * time for banners to work.  The embedded job ticket stuff is here\n * primarily to allow the Windows printer driver for CUPS to pass in JCL\n * options and IPP attributes which otherwise would be lost.\n *\n * The format of a job ticket is simple:\n *\n *     %cupsJobTicket: attr1=value1 attr2=value2 ... attrN=valueN\n *\n *     %cupsJobTicket: attr1=value1\n *     %cupsJobTicket: attr2=value2\n *     ...\n *     %cupsJobTicket: attrN=valueN\n *\n * Job ticket lines must appear immediately after the first line that\n * specifies PostScript (%!PS-Adobe-3.0) or PDF (%PDF) format, and CUPS\n * stops looking for job ticket info when it finds a line that does not begin\n * with \"%cupsJobTicket:\".\n *\n * The maximum length of a job ticket line, including the prefix, is\n * 255 characters to conform with the Adobe DSC.\n *\n * Read-only attributes are rejected with a notice to the error log in\n * case a malicious user tries anything.  Since the job ticket is read\n * prior to attribute validation in print_job(), job ticket attributes\n * will go through the same validation as IPP attributes...\n */\n\nstatic void\nread_job_ticket(cupsd_client_t *con)\t/* I - Client connection */\n{\n  cups_file_t\t\t*fp;\t\t/* File to read from */\n  char\t\t\tline[256];\t/* Line data */\n  int\t\t\tnum_options;\t/* Number of options */\n  cups_option_t\t\t*options;\t/* Options */\n  ipp_t\t\t\t*ticket;\t/* New attributes */\n  ipp_attribute_t\t*attr,\t\t/* Current attribute */\n\t\t\t*attr2,\t\t/* Job attribute */\n\t\t\t*prev2;\t\t/* Previous job attribute */\n\n\n /*\n  * First open the print file...\n  */\n\n  if ((fp = cupsFileOpen(con->filename, \"rb\")) == NULL)\n  {\n    cupsdLogMessage(CUPSD_LOG_ERROR,\n                    \"Unable to open print file for job ticket - %s\",\n                    strerror(errno));\n    return;\n  }\n\n /*\n  * Skip the first line...\n  */\n\n  if (cupsFileGets(fp, line, sizeof(line)) == NULL)\n  {\n    cupsdLogMessage(CUPSD_LOG_ERROR,\n                    \"Unable to read from print file for job ticket - %s\",\n                    strerror(errno));\n    cupsFileClose(fp);\n    return;\n  }\n\n  if (strncmp(line, \"%!PS-Adobe-\", 11) && strncmp(line, \"%PDF-\", 5))\n  {\n   /*\n    * Not a DSC-compliant file, so no job ticket info will be available...\n    */\n\n    cupsFileClose(fp);\n    return;\n  }\n\n /*\n  * Read job ticket info from the file...\n  */\n\n  num_options = 0;\n  options     = NULL;\n\n  while (cupsFileGets(fp, line, sizeof(line)))\n  {\n   /*\n    * Stop at the first non-ticket line...\n    */\n\n    if (strncmp(line, \"%cupsJobTicket:\", 15))\n      break;\n\n   /*\n    * Add the options to the option array...\n    */\n\n    num_options = cupsParseOptions(line + 15, num_options, &options);\n  }\n\n /*\n  * Done with the file; see if we have any options...\n  */\n\n  cupsFileClose(fp);\n\n  if (num_options == 0)\n    return;\n\n /*\n  * OK, convert the options to an attribute list, and apply them to\n  * the request...\n  */\n\n  ticket = ippNew();\n  cupsEncodeOptions(ticket, num_options, options);\n\n /*\n  * See what the user wants to change.\n  */\n\n  for (attr = ticket->attrs; attr; attr = attr->next)\n  {\n    if (attr->group_tag != IPP_TAG_JOB || !attr->name)\n      continue;\n\n    if (!strncmp(attr->name, \"date-time-at-\", 13) ||\n        !strcmp(attr->name, \"job-impressions-completed\") ||\n\t!strcmp(attr->name, \"job-media-sheets-completed\") ||\n\t!strncmp(attr->name, \"job-k-octets\", 12) ||\n\t!strcmp(attr->name, \"job-id\") ||\n\t!strcmp(attr->name, \"job-originating-host-name\") ||\n        !strcmp(attr->name, \"job-originating-user-name\") ||\n\t!strcmp(attr->name, \"job-pages-completed\") ||\n\t!strcmp(attr->name, \"job-printer-uri\") ||\n\t!strncmp(attr->name, \"job-state\", 9) ||\n\t!strcmp(attr->name, \"job-uri\") ||\n\t!strncmp(attr->name, \"time-at-\", 8))\n      continue; /* Read-only attrs */\n\n    if ((attr2 = ippFindAttribute(con->request, attr->name,\n                                  IPP_TAG_ZERO)) != NULL)\n    {\n     /*\n      * Some other value; first free the old value...\n      */\n\n      if (con->request->attrs == attr2)\n      {\n\tcon->request->attrs = attr2->next;\n\tprev2               = NULL;\n      }\n      else\n      {\n\tfor (prev2 = con->request->attrs; prev2; prev2 = prev2->next)\n\t  if (prev2->next == attr2)\n\t  {\n\t    prev2->next = attr2->next;\n\t    break;\n\t  }\n      }\n\n      if (con->request->last == attr2)\n        con->request->last = prev2;\n\n      ippDeleteAttribute(NULL, attr2);\n    }\n\n   /*\n    * Add new option by copying it...\n    */\n\n    ippCopyAttribute(con->request, attr, 0);\n  }\n\n /*\n  * Then free the attribute list and option array...\n  */\n\n  ippDelete(ticket);\n  cupsFreeOptions(num_options, options);\n}\n\n\n/*\n * 'reject_jobs()' - Reject print jobs to a printer.\n */\n\nstatic void\nreject_jobs(cupsd_client_t  *con,\t/* I - Client connection */\n            ipp_attribute_t *uri)\t/* I - Printer or class URI */\n{\n  http_status_t\tstatus;\t\t\t/* Policy status */\n  cups_ptype_t\tdtype;\t\t\t/* Destination type (printer/class) */\n  cupsd_printer_t *printer;\t\t/* Printer data */\n  ipp_attribute_t *attr;\t\t/* printer-state-message text */\n\n\n  cupsdLogMessage(CUPSD_LOG_DEBUG2, \"reject_jobs(%p[%d], %s)\", con,\n                  con->number, uri->values[0].string.text);\n\n /*\n  * Is the destination valid?\n  */\n\n  if (!cupsdValidateDest(uri->values[0].string.text, &dtype, &printer))\n  {\n   /*\n    * Bad URI...\n    */\n\n    send_ipp_status(con, IPP_NOT_FOUND,\n                    _(\"The printer or class does not exist.\"));\n    return;\n  }\n\n /*\n  * Check policy...\n  */\n\n  if ((status = cupsdCheckPolicy(printer->op_policy_ptr, con, NULL)) != HTTP_OK)\n  {\n    send_http_error(con, status, printer);\n    return;\n  }\n\n /*\n  * Reject jobs sent to the printer...\n  */\n\n  printer->accepting = 0;\n\n  if ((attr = ippFindAttribute(con->request, \"printer-state-message\",\n                               IPP_TAG_TEXT)) == NULL)\n    strlcpy(printer->state_message, \"Rejecting Jobs\",\n            sizeof(printer->state_message));\n  else\n    strlcpy(printer->state_message, attr->values[0].string.text,\n            sizeof(printer->state_message));\n\n  cupsdAddEvent(CUPSD_EVENT_PRINTER_STATE, printer, NULL,\n                \"No longer accepting jobs.\");\n\n  if (dtype & CUPS_PRINTER_CLASS)\n  {\n    cupsdMarkDirty(CUPSD_DIRTY_CLASSES);\n\n    cupsdLogMessage(CUPSD_LOG_INFO, \"Class \\\"%s\\\" rejecting jobs (\\\"%s\\\").\",\n                    printer->name, get_username(con));\n  }\n  else\n  {\n    cupsdMarkDirty(CUPSD_DIRTY_PRINTERS);\n\n    cupsdLogMessage(CUPSD_LOG_INFO, \"Printer \\\"%s\\\" rejecting jobs (\\\"%s\\\").\",\n                    printer->name, get_username(con));\n  }\n\n /*\n  * Everything was ok, so return OK status...\n  */\n\n  con->response->request.status.status_code = IPP_OK;\n}\n\n\n/*\n * 'release_held_new_jobs()' - Release pending/new jobs on a printer or class.\n */\n\nstatic void\nrelease_held_new_jobs(\n    cupsd_client_t  *con,\t\t/* I - Connection */\n    ipp_attribute_t *uri)\t\t/* I - Printer URI */\n{\n  http_status_t\t\tstatus;\t\t/* Policy status */\n  cups_ptype_t\t\tdtype;\t\t/* Destination type (printer/class) */\n  cupsd_printer_t\t*printer;\t/* Printer data */\n\n\n  cupsdLogMessage(CUPSD_LOG_DEBUG2, \"release_held_new_jobs(%p[%d], %s)\", con,\n                  con->number, uri->values[0].string.text);\n\n /*\n  * Is the destination valid?\n  */\n\n  if (!cupsdValidateDest(uri->values[0].string.text, &dtype, &printer))\n  {\n   /*\n    * Bad URI...\n    */\n\n    send_ipp_status(con, IPP_NOT_FOUND,\n                    _(\"The printer or class does not exist.\"));\n    return;\n  }\n\n /*\n  * Check policy...\n  */\n\n  if ((status = cupsdCheckPolicy(printer->op_policy_ptr, con, NULL)) != HTTP_OK)\n  {\n    send_http_error(con, status, printer);\n    return;\n  }\n\n /*\n  * Hold pending/new jobs sent to the printer...\n  */\n\n  printer->holding_new_jobs = 0;\n\n  cupsdSetPrinterReasons(printer, \"-hold-new-jobs\");\n\n  if (dtype & CUPS_PRINTER_CLASS)\n    cupsdLogMessage(CUPSD_LOG_INFO,\n                    \"Class \\\"%s\\\" now printing pending/new jobs (\\\"%s\\\").\",\n                    printer->name, get_username(con));\n  else\n    cupsdLogMessage(CUPSD_LOG_INFO,\n                    \"Printer \\\"%s\\\" now printing pending/new jobs (\\\"%s\\\").\",\n                    printer->name, get_username(con));\n\n  cupsdCheckJobs();\n\n /*\n  * Everything was ok, so return OK status...\n  */\n\n  con->response->request.status.status_code = IPP_OK;\n}\n\n\n/*\n * 'release_job()' - Release a held print job.\n */\n\nstatic void\nrelease_job(cupsd_client_t  *con,\t/* I - Client connection */\n            ipp_attribute_t *uri)\t/* I - Job or Printer URI */\n{\n  ipp_attribute_t *attr;\t\t/* Current attribute */\n  int\t\tjobid;\t\t\t/* Job ID */\n  char\t\tscheme[HTTP_MAX_URI],\t/* Method portion of URI */\n\t\tusername[HTTP_MAX_URI],\t/* Username portion of URI */\n\t\thost[HTTP_MAX_URI],\t/* Host portion of URI */\n\t\tresource[HTTP_MAX_URI];\t/* Resource portion of URI */\n  int\t\tport;\t\t\t/* Port portion of URI */\n  cupsd_job_t\t*job;\t\t\t/* Job information */\n\n\n  cupsdLogMessage(CUPSD_LOG_DEBUG2, \"release_job(%p[%d], %s)\", con,\n                  con->number, uri->values[0].string.text);\n\n /*\n  * See if we have a job URI or a printer URI...\n  */\n\n  if (!strcmp(uri->name, \"printer-uri\"))\n  {\n   /*\n    * Got a printer URI; see if we also have a job-id attribute...\n    */\n\n    if ((attr = ippFindAttribute(con->request, \"job-id\",\n                                 IPP_TAG_INTEGER)) == NULL)\n    {\n      send_ipp_status(con, IPP_BAD_REQUEST,\n                      _(\"Got a printer-uri attribute but no job-id.\"));\n      return;\n    }\n\n    jobid = attr->values[0].integer;\n  }\n  else\n  {\n   /*\n    * Got a job URI; parse it to get the job ID...\n    */\n\n    httpSeparateURI(HTTP_URI_CODING_ALL, uri->values[0].string.text, scheme,\n                    sizeof(scheme), username, sizeof(username), host,\n\t\t    sizeof(host), &port, resource, sizeof(resource));\n\n    if (strncmp(resource, \"/jobs/\", 6))\n    {\n     /*\n      * Not a valid URI!\n      */\n\n      send_ipp_status(con, IPP_BAD_REQUEST, _(\"Bad job-uri \\\"%s\\\".\"),\n                      uri->values[0].string.text);\n      return;\n    }\n\n    jobid = atoi(resource + 6);\n  }\n\n /*\n  * See if the job exists...\n  */\n\n  if ((job = cupsdFindJob(jobid)) == NULL)\n  {\n   /*\n    * Nope - return a \"not found\" error...\n    */\n\n    send_ipp_status(con, IPP_NOT_FOUND, _(\"Job #%d does not exist.\"), jobid);\n    return;\n  }\n\n /*\n  * See if job is \"held\"...\n  */\n\n  if (job->state_value != IPP_JOB_HELD)\n  {\n   /*\n    * Nope - return a \"not possible\" error...\n    */\n\n    send_ipp_status(con, IPP_NOT_POSSIBLE, _(\"Job #%d is not held.\"), jobid);\n    return;\n  }\n\n /*\n  * See if the job is owned by the requesting user...\n  */\n\n  if (!validate_user(job, con, job->username, username, sizeof(username)))\n  {\n    send_http_error(con, con->username[0] ? HTTP_FORBIDDEN : HTTP_UNAUTHORIZED,\n                    cupsdFindDest(job->dest));\n    return;\n  }\n\n /*\n  * Reset the job-hold-until value to \"no-hold\"...\n  */\n\n  if ((attr = ippFindAttribute(job->attrs, \"job-hold-until\",\n                               IPP_TAG_KEYWORD)) == NULL)\n    attr = ippFindAttribute(job->attrs, \"job-hold-until\", IPP_TAG_NAME);\n\n  if (attr)\n  {\n    ippSetValueTag(job->attrs, &attr, IPP_TAG_KEYWORD);\n    ippSetString(job->attrs, &attr, 0, \"no-hold\");\n\n    cupsdAddEvent(CUPSD_EVENT_JOB_CONFIG_CHANGED, cupsdFindDest(job->dest), job,\n                  \"Job job-hold-until value changed by user.\");\n    ippSetString(job->attrs, &job->reasons, 0, \"none\");\n  }\n\n /*\n  * Release the job and return...\n  */\n\n  cupsdReleaseJob(job);\n\n  cupsdAddEvent(CUPSD_EVENT_JOB_STATE, cupsdFindDest(job->dest), job,\n                \"Job released by user.\");\n\n  cupsdLogJob(job, CUPSD_LOG_INFO, \"Released by \\\"%s\\\".\", username);\n\n  con->response->request.status.status_code = IPP_OK;\n\n  cupsdCheckJobs();\n}\n\n\n/*\n * 'renew_subscription()' - Renew an existing subscription...\n */\n\nstatic void\nrenew_subscription(\n    cupsd_client_t *con,\t\t/* I - Client connection */\n    int            sub_id)\t\t/* I - Subscription ID */\n{\n  http_status_t\t\tstatus;\t\t/* Policy status */\n  cupsd_subscription_t\t*sub;\t\t/* Subscription */\n  ipp_attribute_t\t*lease;\t\t/* notify-lease-duration */\n\n\n  cupsdLogMessage(CUPSD_LOG_DEBUG2,\n                  \"renew_subscription(con=%p[%d], sub_id=%d)\",\n                  con, con->number, sub_id);\n\n /*\n  * Is the subscription ID valid?\n  */\n\n  if ((sub = cupsdFindSubscription(sub_id)) == NULL)\n  {\n   /*\n    * Bad subscription ID...\n    */\n\n    send_ipp_status(con, IPP_NOT_FOUND, _(\"Subscription #%d does not exist.\"),\n                    sub_id);\n    return;\n  }\n\n  if (sub->job)\n  {\n   /*\n    * Job subscriptions cannot be renewed...\n    */\n\n    send_ipp_status(con, IPP_NOT_POSSIBLE,\n                    _(\"Job subscriptions cannot be renewed.\"));\n    return;\n  }\n\n /*\n  * Check policy...\n  */\n\n  if ((status = cupsdCheckPolicy(sub->dest ? sub->dest->op_policy_ptr :\n                                             DefaultPolicyPtr,\n                                 con, sub->owner)) != HTTP_OK)\n  {\n    send_http_error(con, status, sub->dest);\n    return;\n  }\n\n /*\n  * Renew the subscription...\n  */\n\n  lease = ippFindAttribute(con->request, \"notify-lease-duration\",\n                           IPP_TAG_INTEGER);\n\n  sub->lease = lease ? lease->values[0].integer : DefaultLeaseDuration;\n\n  if (MaxLeaseDuration && (sub->lease == 0 || sub->lease > MaxLeaseDuration))\n  {\n    cupsdLogMessage(CUPSD_LOG_INFO,\n                    \"renew_subscription: Limiting notify-lease-duration to \"\n\t\t    \"%d seconds.\",\n\t\t    MaxLeaseDuration);\n    sub->lease = MaxLeaseDuration;\n  }\n\n  sub->expire = sub->lease ? time(NULL) + sub->lease : 0;\n\n  cupsdMarkDirty(CUPSD_DIRTY_SUBSCRIPTIONS);\n\n  con->response->request.status.status_code = IPP_OK;\n\n  ippAddInteger(con->response, IPP_TAG_SUBSCRIPTION, IPP_TAG_INTEGER,\n                \"notify-lease-duration\", sub->lease);\n}\n\n\n/*\n * 'restart_job()' - Restart an old print job.\n */\n\nstatic void\nrestart_job(cupsd_client_t  *con,\t/* I - Client connection */\n            ipp_attribute_t *uri)\t/* I - Job or Printer URI */\n{\n  ipp_attribute_t *attr;\t\t/* Current attribute */\n  int\t\tjobid;\t\t\t/* Job ID */\n  cupsd_job_t\t*job;\t\t\t/* Job information */\n  char\t\tscheme[HTTP_MAX_URI],\t/* Method portion of URI */\n\t\tusername[HTTP_MAX_URI],\t/* Username portion of URI */\n\t\thost[HTTP_MAX_URI],\t/* Host portion of URI */\n\t\tresource[HTTP_MAX_URI];\t/* Resource portion of URI */\n  int\t\tport;\t\t\t/* Port portion of URI */\n\n\n  cupsdLogMessage(CUPSD_LOG_DEBUG2, \"restart_job(%p[%d], %s)\", con,\n                  con->number, uri->values[0].string.text);\n\n /*\n  * See if we have a job URI or a printer URI...\n  */\n\n  if (!strcmp(uri->name, \"printer-uri\"))\n  {\n   /*\n    * Got a printer URI; see if we also have a job-id attribute...\n    */\n\n    if ((attr = ippFindAttribute(con->request, \"job-id\",\n                                 IPP_TAG_INTEGER)) == NULL)\n    {\n      send_ipp_status(con, IPP_BAD_REQUEST,\n                      _(\"Got a printer-uri attribute but no job-id.\"));\n      return;\n    }\n\n    jobid = attr->values[0].integer;\n  }\n  else\n  {\n   /*\n    * Got a job URI; parse it to get the job ID...\n    */\n\n    httpSeparateURI(HTTP_URI_CODING_ALL, uri->values[0].string.text, scheme,\n                    sizeof(scheme), username, sizeof(username), host,\n\t\t    sizeof(host), &port, resource, sizeof(resource));\n\n    if (strncmp(resource, \"/jobs/\", 6))\n    {\n     /*\n      * Not a valid URI!\n      */\n\n      send_ipp_status(con, IPP_BAD_REQUEST, _(\"Bad job-uri \\\"%s\\\".\"),\n                      uri->values[0].string.text);\n      return;\n    }\n\n    jobid = atoi(resource + 6);\n  }\n\n /*\n  * See if the job exists...\n  */\n\n  if ((job = cupsdFindJob(jobid)) == NULL)\n  {\n   /*\n    * Nope - return a \"not found\" error...\n    */\n\n    send_ipp_status(con, IPP_NOT_FOUND, _(\"Job #%d does not exist.\"), jobid);\n    return;\n  }\n\n /*\n  * See if job is in any of the \"completed\" states...\n  */\n\n  if (job->state_value <= IPP_JOB_PROCESSING)\n  {\n   /*\n    * Nope - return a \"not possible\" error...\n    */\n\n    send_ipp_status(con, IPP_NOT_POSSIBLE, _(\"Job #%d is not complete.\"),\n                    jobid);\n    return;\n  }\n\n /*\n  * See if we have retained the job files...\n  */\n\n  cupsdLoadJob(job);\n\n  if (!job->attrs || job->num_files == 0)\n  {\n   /*\n    * Nope - return a \"not possible\" error...\n    */\n\n    send_ipp_status(con, IPP_NOT_POSSIBLE,\n                    _(\"Job #%d cannot be restarted - no files.\"), jobid);\n    return;\n  }\n\n /*\n  * See if the job is owned by the requesting user...\n  */\n\n  if (!validate_user(job, con, job->username, username, sizeof(username)))\n  {\n    send_http_error(con, con->username[0] ? HTTP_FORBIDDEN : HTTP_UNAUTHORIZED,\n                    cupsdFindDest(job->dest));\n    return;\n  }\n\n /*\n  * See if the job-hold-until attribute is specified...\n  */\n\n  if ((attr = ippFindAttribute(con->request, \"job-hold-until\",\n                               IPP_TAG_KEYWORD)) == NULL)\n    attr = ippFindAttribute(con->request, \"job-hold-until\", IPP_TAG_NAME);\n\n  if (attr && strcmp(attr->values[0].string.text, \"no-hold\"))\n  {\n   /*\n    * Return the job to a held state...\n    */\n\n    cupsdLogJob(job, CUPSD_LOG_DEBUG,\n\t\t\"Restarted by \\\"%s\\\" with job-hold-until=%s.\",\n                username, attr->values[0].string.text);\n    cupsdSetJobHoldUntil(job, attr->values[0].string.text, 0);\n\n    cupsdAddEvent(CUPSD_EVENT_JOB_CONFIG_CHANGED | CUPSD_EVENT_JOB_STATE,\n                  NULL, job, \"Job restarted by user with job-hold-until=%s\",\n\t\t  attr->values[0].string.text);\n  }\n  else\n  {\n   /*\n    * Restart the job...\n    */\n\n    cupsdRestartJob(job);\n    cupsdCheckJobs();\n  }\n\n  cupsdLogJob(job, CUPSD_LOG_INFO, \"Restarted by \\\"%s\\\".\", username);\n\n  con->response->request.status.status_code = IPP_OK;\n}\n\n\n/*\n * 'save_auth_info()' - Save authentication information for a job.\n */\n\nstatic void\nsave_auth_info(\n    cupsd_client_t  *con,\t\t/* I - Client connection */\n    cupsd_job_t     *job,\t\t/* I - Job */\n    ipp_attribute_t *auth_info)\t\t/* I - auth-info attribute, if any */\n{\n  int\t\t\ti;\t\t/* Looping var */\n  char\t\t\tfilename[1024];\t/* Job authentication filename */\n  cups_file_t\t\t*fp;\t\t/* Job authentication file */\n  char\t\t\tline[65536];\t/* Line for file */\n  cupsd_printer_t\t*dest;\t\t/* Destination printer/class */\n\n\n /*\n  * This function saves the in-memory authentication information for\n  * a job so that it can be used to authenticate with a remote host.\n  * The information is stored in a file that is readable only by the\n  * root user.  The fields are Base-64 encoded, each on a separate line,\n  * followed by random number (up to 1024) of newlines to limit the\n  * amount of information that is exposed.\n  *\n  * Because of the potential for exposing of authentication information,\n  * this functionality is only enabled when running cupsd as root.\n  *\n  * This caching only works for the Basic and BasicDigest authentication\n  * types.  Digest authentication cannot be cached this way, and in\n  * the future Kerberos authentication may make all of this obsolete.\n  *\n  * Authentication information is saved whenever an authenticated\n  * Print-Job, Create-Job, or CUPS-Authenticate-Job operation is\n  * performed.\n  *\n  * This information is deleted after a job is completed or canceled,\n  * so reprints may require subsequent re-authentication.\n  */\n\n  if (RunUser)\n    return;\n\n  if ((dest = cupsdFindDest(job->dest)) == NULL)\n    return;\n\n /*\n  * Create the authentication file and change permissions...\n  */\n\n  snprintf(filename, sizeof(filename), \"%s/a%05d\", RequestRoot, job->id);\n  if ((fp = cupsFileOpen(filename, \"w\")) == NULL)\n  {\n    cupsdLogMessage(CUPSD_LOG_ERROR,\n                    \"Unable to save authentication info to \\\"%s\\\" - %s\",\n                    filename, strerror(errno));\n    return;\n  }\n\n  fchown(cupsFileNumber(fp), 0, 0);\n  fchmod(cupsFileNumber(fp), 0400);\n\n  cupsFilePuts(fp, \"CUPSD-AUTH-V3\\n\");\n\n  for (i = 0;\n       i < (int)(sizeof(job->auth_env) / sizeof(job->auth_env[0]));\n       i ++)\n    cupsdClearString(job->auth_env + i);\n\n  if (auth_info && auth_info->num_values == dest->num_auth_info_required)\n  {\n   /*\n    * Write 1 to 3 auth values...\n    */\n\n    for (i = 0;\n         i < auth_info->num_values &&\n\t     i < (int)(sizeof(job->auth_env) / sizeof(job->auth_env[0]));\n\t i ++)\n    {\n      if (strcmp(dest->auth_info_required[i], \"negotiate\"))\n      {\n\thttpEncode64_2(line, sizeof(line), auth_info->values[i].string.text, (int)strlen(auth_info->values[i].string.text));\n\tcupsFilePutConf(fp, dest->auth_info_required[i], line);\n      }\n      else\n\tcupsFilePutConf(fp, dest->auth_info_required[i],\n\t                auth_info->values[i].string.text);\n\n      if (!strcmp(dest->auth_info_required[i], \"username\"))\n        cupsdSetStringf(job->auth_env + i, \"AUTH_USERNAME=%s\",\n\t                auth_info->values[i].string.text);\n      else if (!strcmp(dest->auth_info_required[i], \"domain\"))\n        cupsdSetStringf(job->auth_env + i, \"AUTH_DOMAIN=%s\",\n\t                auth_info->values[i].string.text);\n      else if (!strcmp(dest->auth_info_required[i], \"password\"))\n        cupsdSetStringf(job->auth_env + i, \"AUTH_PASSWORD=%s\",\n\t                auth_info->values[i].string.text);\n      else if (!strcmp(dest->auth_info_required[i], \"negotiate\"))\n        cupsdSetStringf(job->auth_env + i, \"AUTH_NEGOTIATE=%s\",\n\t                auth_info->values[i].string.text);\n      else\n        i --;\n    }\n  }\n  else if (auth_info && auth_info->num_values == 2 &&\n           dest->num_auth_info_required == 1 &&\n           !strcmp(dest->auth_info_required[0], \"negotiate\"))\n  {\n   /*\n    * Allow fallback to username+password for Kerberized queues...\n    */\n\n    httpEncode64_2(line, sizeof(line), auth_info->values[0].string.text, (int)strlen(auth_info->values[0].string.text));\n    cupsFilePutConf(fp, \"username\", line);\n\n    cupsdSetStringf(job->auth_env + 0, \"AUTH_USERNAME=%s\",\n                    auth_info->values[0].string.text);\n\n    httpEncode64_2(line, sizeof(line), auth_info->values[1].string.text, (int)strlen(auth_info->values[1].string.text));\n    cupsFilePutConf(fp, \"password\", line);\n\n    cupsdSetStringf(job->auth_env + 1, \"AUTH_PASSWORD=%s\",\n                    auth_info->values[1].string.text);\n  }\n  else if (con->username[0])\n  {\n   /*\n    * Write the authenticated username...\n    */\n\n    httpEncode64_2(line, sizeof(line), con->username, (int)strlen(con->username));\n    cupsFilePutConf(fp, \"username\", line);\n\n    cupsdSetStringf(job->auth_env + 0, \"AUTH_USERNAME=%s\", con->username);\n\n   /*\n    * Write the authenticated password...\n    */\n\n    httpEncode64_2(line, sizeof(line), con->password, (int)strlen(con->password));\n    cupsFilePutConf(fp, \"password\", line);\n\n    cupsdSetStringf(job->auth_env + 1, \"AUTH_PASSWORD=%s\", con->password);\n  }\n\n#ifdef HAVE_GSSAPI\n  if (con->gss_uid > 0)\n  {\n    cupsFilePrintf(fp, \"uid %d\\n\", (int)con->gss_uid);\n    cupsdSetStringf(&job->auth_uid, \"AUTH_UID=%d\", (int)con->gss_uid);\n  }\n#endif /* HAVE_GSSAPI */\n\n /*\n  * Write a random number of newlines to the end of the file...\n  */\n\n  for (i = (CUPS_RAND() % 1024); i >= 0; i --)\n    cupsFilePutChar(fp, '\\n');\n\n /*\n  * Close the file and return...\n  */\n\n  cupsFileClose(fp);\n}\n\n\n/*\n * 'send_document()' - Send a file to a printer or class.\n */\n\nstatic void\nsend_document(cupsd_client_t  *con,\t/* I - Client connection */\n\t      ipp_attribute_t *uri)\t/* I - Printer URI */\n{\n  ipp_attribute_t\t*attr;\t\t/* Current attribute */\n  ipp_attribute_t\t*format;\t/* Request's document-format attribute */\n  ipp_attribute_t\t*jformat;\t/* Job's document-format attribute */\n  const char\t\t*default_format;/* document-format-default value */\n  int\t\t\tjobid;\t\t/* Job ID number */\n  cupsd_job_t\t\t*job;\t\t/* Current job */\n  char\t\t\tjob_uri[HTTP_MAX_URI],\n\t\t\t\t\t/* Job URI */\n\t\t\tscheme[HTTP_MAX_URI],\n\t\t\t\t\t/* Method portion of URI */\n\t\t\tusername[HTTP_MAX_URI],\n\t\t\t\t\t/* Username portion of URI */\n\t\t\thost[HTTP_MAX_URI],\n\t\t\t\t\t/* Host portion of URI */\n\t\t\tresource[HTTP_MAX_URI];\n\t\t\t\t\t/* Resource portion of URI */\n  int\t\t\tport;\t\t/* Port portion of URI */\n  mime_type_t\t\t*filetype;\t/* Type of file */\n  char\t\t\tsuper[MIME_MAX_SUPER],\n\t\t\t\t\t/* Supertype of file */\n\t\t\ttype[MIME_MAX_TYPE],\n\t\t\t\t\t/* Subtype of file */\n\t\t\tmimetype[MIME_MAX_SUPER + MIME_MAX_TYPE + 2];\n\t\t\t\t\t/* Textual name of mime type */\n  char\t\t\tfilename[1024];\t/* Job filename */\n  cupsd_printer_t\t*printer;\t/* Current printer */\n  struct stat\t\tfileinfo;\t/* File information */\n  int\t\t\tkbytes;\t\t/* Size of file */\n  int\t\t\tcompression;\t/* Type of compression */\n  int\t\t\tstart_job;\t/* Start the job? */\n\n\n  cupsdLogMessage(CUPSD_LOG_DEBUG2, \"send_document(%p[%d], %s)\", con,\n                  con->number, uri->values[0].string.text);\n\n /*\n  * See if we have a job URI or a printer URI...\n  */\n\n  if (!strcmp(uri->name, \"printer-uri\"))\n  {\n   /*\n    * Got a printer URI; see if we also have a job-id attribute...\n    */\n\n    if ((attr = ippFindAttribute(con->request, \"job-id\",\n                                 IPP_TAG_INTEGER)) == NULL)\n    {\n      send_ipp_status(con, IPP_BAD_REQUEST,\n                      _(\"Got a printer-uri attribute but no job-id.\"));\n      return;\n    }\n\n    jobid = attr->values[0].integer;\n  }\n  else\n  {\n   /*\n    * Got a job URI; parse it to get the job ID...\n    */\n\n    httpSeparateURI(HTTP_URI_CODING_ALL, uri->values[0].string.text, scheme,\n                    sizeof(scheme), username, sizeof(username), host,\n\t\t    sizeof(host), &port, resource, sizeof(resource));\n\n    if (strncmp(resource, \"/jobs/\", 6))\n    {\n     /*\n      * Not a valid URI!\n      */\n\n      send_ipp_status(con, IPP_BAD_REQUEST, _(\"Bad job-uri \\\"%s\\\".\"),\n                      uri->values[0].string.text);\n      return;\n    }\n\n    jobid = atoi(resource + 6);\n  }\n\n /*\n  * See if the job exists...\n  */\n\n  if ((job = cupsdFindJob(jobid)) == NULL)\n  {\n   /*\n    * Nope - return a \"not found\" error...\n    */\n\n    send_ipp_status(con, IPP_NOT_FOUND, _(\"Job #%d does not exist.\"), jobid);\n    return;\n  }\n\n  printer = cupsdFindDest(job->dest);\n\n /*\n  * See if the job is owned by the requesting user...\n  */\n\n  if (!validate_user(job, con, job->username, username, sizeof(username)))\n  {\n    send_http_error(con, con->username[0] ? HTTP_FORBIDDEN : HTTP_UNAUTHORIZED,\n                    cupsdFindDest(job->dest));\n    return;\n  }\n\n /*\n  * OK, see if the client is sending the document compressed - CUPS\n  * only supports \"none\" and \"gzip\".\n  */\n\n  compression = CUPS_FILE_NONE;\n\n  if ((attr = ippFindAttribute(con->request, \"compression\",\n                               IPP_TAG_KEYWORD)) != NULL)\n  {\n    if (strcmp(attr->values[0].string.text, \"none\")\n#ifdef HAVE_LIBZ\n        && strcmp(attr->values[0].string.text, \"gzip\")\n#endif /* HAVE_LIBZ */\n      )\n    {\n      send_ipp_status(con, IPP_ATTRIBUTES, _(\"Unsupported compression \\\"%s\\\".\"),\n        \t      attr->values[0].string.text);\n      ippAddString(con->response, IPP_TAG_UNSUPPORTED_GROUP, IPP_TAG_KEYWORD,\n\t           \"compression\", NULL, attr->values[0].string.text);\n      return;\n    }\n\n#ifdef HAVE_LIBZ\n    if (!strcmp(attr->values[0].string.text, \"gzip\"))\n      compression = CUPS_FILE_GZIP;\n#endif /* HAVE_LIBZ */\n  }\n\n /*\n  * Do we have a file to print?\n  */\n\n  if ((attr = ippFindAttribute(con->request, \"last-document\",\n\t                       IPP_TAG_BOOLEAN)) == NULL)\n  {\n    send_ipp_status(con, IPP_BAD_REQUEST,\n                    _(\"Missing last-document attribute in request.\"));\n    return;\n  }\n\n  if (!con->filename)\n  {\n   /*\n    * Check for an empty request with \"last-document\" set to true, which is\n    * used to close an \"open\" job by RFC 2911, section 3.3.2.\n    */\n\n    if (job->num_files > 0 && attr->values[0].boolean)\n      goto last_document;\n\n    send_ipp_status(con, IPP_BAD_REQUEST, _(\"No file in print request.\"));\n    return;\n  }\n\n /*\n  * Is it a format we support?\n  */\n\n  cupsdLoadJob(job);\n\n  if ((format = ippFindAttribute(con->request, \"document-format\",\n                                 IPP_TAG_MIMETYPE)) != NULL)\n  {\n   /*\n    * Grab format from client...\n    */\n\n    if (sscanf(format->values[0].string.text, \"%15[^/]/%255[^;]\",\n               super, type) != 2)\n    {\n      send_ipp_status(con, IPP_BAD_REQUEST, _(\"Bad document-format \\\"%s\\\".\"),\n\t              format->values[0].string.text);\n      return;\n    }\n\n    ippAddString(job->attrs, IPP_TAG_JOB, IPP_TAG_MIMETYPE, \"document-format-supplied\", NULL, ippGetString(format, 0, NULL));\n  }\n  else if ((default_format = cupsGetOption(\"document-format\",\n                                           printer->num_options,\n\t\t\t\t\t   printer->options)) != NULL)\n  {\n   /*\n    * Use default document format...\n    */\n\n    if (sscanf(default_format, \"%15[^/]/%255[^;]\", super, type) != 2)\n    {\n      send_ipp_status(con, IPP_BAD_REQUEST,\n                      _(\"Bad document-format-default \\\"%s\\\".\"), default_format);\n      return;\n    }\n  }\n  else\n  {\n   /*\n    * No document format attribute?  Auto-type it!\n    */\n\n    strlcpy(super, \"application\", sizeof(super));\n    strlcpy(type, \"octet-stream\", sizeof(type));\n  }\n\n  if (!strcmp(super, \"application\") && !strcmp(type, \"octet-stream\"))\n  {\n   /*\n    * Auto-type the file...\n    */\n\n    ipp_attribute_t\t*doc_name;\t/* document-name attribute */\n\n\n    cupsdLogJob(job, CUPSD_LOG_DEBUG, \"Auto-typing file...\");\n\n    doc_name = ippFindAttribute(con->request, \"document-name\", IPP_TAG_NAME);\n    filetype = mimeFileType(MimeDatabase, con->filename,\n                            doc_name ? doc_name->values[0].string.text : NULL,\n\t\t\t    &compression);\n\n    if (!filetype)\n      filetype = mimeType(MimeDatabase, super, type);\n\n    if (filetype)\n      cupsdLogJob(job, CUPSD_LOG_DEBUG, \"Request file type is %s/%s.\",\n\t\t  filetype->super, filetype->type);\n\n    snprintf(mimetype, sizeof(mimetype), \"%s/%s\", filetype->super, filetype->type);\n    ippAddString(job->attrs, IPP_TAG_JOB, IPP_TAG_MIMETYPE, \"document-format-detected\", NULL, mimetype);\n  }\n  else\n    filetype = mimeType(MimeDatabase, super, type);\n\n  if (filetype)\n  {\n   /*\n    * Replace the document-format attribute value with the auto-typed or\n    * default one.\n    */\n\n    snprintf(mimetype, sizeof(mimetype), \"%s/%s\", filetype->super,\n             filetype->type);\n\n    if ((jformat = ippFindAttribute(job->attrs, \"document-format\",\n                                    IPP_TAG_MIMETYPE)) != NULL)\n      ippSetString(job->attrs, &jformat, 0, mimetype);\n    else\n      ippAddString(job->attrs, IPP_TAG_JOB, IPP_TAG_MIMETYPE,\n\t           \"document-format\", NULL, mimetype);\n  }\n  else if (!filetype)\n  {\n    send_ipp_status(con, IPP_DOCUMENT_FORMAT,\n                    _(\"Unsupported document-format \\\"%s/%s\\\".\"), super, type);\n    cupsdLogMessage(CUPSD_LOG_INFO,\n                    \"Hint: Do you have the raw file printing rules enabled?\");\n\n    if (format)\n      ippAddString(con->response, IPP_TAG_UNSUPPORTED_GROUP, IPP_TAG_MIMETYPE,\n                   \"document-format\", NULL, format->values[0].string.text);\n\n    return;\n  }\n\n  if (printer->filetypes && !cupsArrayFind(printer->filetypes, filetype))\n  {\n    snprintf(mimetype, sizeof(mimetype), \"%s/%s\", filetype->super,\n             filetype->type);\n\n    send_ipp_status(con, IPP_DOCUMENT_FORMAT,\n                    _(\"Unsupported document-format \\\"%s\\\".\"), mimetype);\n\n    ippAddString(con->response, IPP_TAG_UNSUPPORTED_GROUP, IPP_TAG_MIMETYPE,\n                 \"document-format\", NULL, mimetype);\n\n    return;\n  }\n\n /*\n  * Add the file to the job...\n  */\n\n  if (add_file(con, job, filetype, compression))\n    return;\n\n  if ((attr = ippFindAttribute(con->request, \"document-name\", IPP_TAG_NAME)) != NULL)\n    ippAddString(job->attrs, IPP_TAG_JOB, IPP_TAG_NAME, \"document-name-supplied\", NULL, ippGetString(attr, 0, NULL));\n\n  if (stat(con->filename, &fileinfo))\n    kbytes = 0;\n  else\n    kbytes = (fileinfo.st_size + 1023) / 1024;\n\n  cupsdUpdateQuota(printer, job->username, 0, kbytes);\n\n  job->koctets += kbytes;\n\n  if ((attr = ippFindAttribute(job->attrs, \"job-k-octets\", IPP_TAG_INTEGER)) != NULL)\n    attr->values[0].integer += kbytes;\n\n  snprintf(filename, sizeof(filename), \"%s/d%05d-%03d\", RequestRoot, job->id, job->num_files);\n  if (rename(con->filename, filename))\n  {\n    cupsdLogJob(job, CUPSD_LOG_ERROR, \"Unable to rename job document file \\\"%s\\\": %s\", filename, strerror(errno));\n\n    send_ipp_status(con, IPP_INTERNAL_ERROR, _(\"Unable to rename job document file.\"));\n    return;\n  }\n\n  cupsdClearString(&con->filename);\n\n  cupsdLogJob(job, CUPSD_LOG_INFO, \"File of type %s/%s queued by \\\"%s\\\".\",\n\t      filetype->super, filetype->type, job->username);\n\n /*\n  * Start the job if this is the last document...\n  */\n\n  last_document:\n\n  if ((attr = ippFindAttribute(con->request, \"last-document\",\n                               IPP_TAG_BOOLEAN)) != NULL &&\n      attr->values[0].boolean)\n  {\n   /*\n    * See if we need to add the ending sheet...\n    */\n\n    if (cupsdTimeoutJob(job))\n      return;\n\n    if (job->state_value == IPP_JOB_STOPPED)\n    {\n      job->state->values[0].integer = IPP_JOB_PENDING;\n      job->state_value              = IPP_JOB_PENDING;\n\n      ippSetString(job->attrs, &job->reasons, 0, \"none\");\n    }\n    else if (job->state_value == IPP_JOB_HELD)\n    {\n      if ((attr = ippFindAttribute(job->attrs, \"job-hold-until\",\n                                   IPP_TAG_KEYWORD)) == NULL)\n\tattr = ippFindAttribute(job->attrs, \"job-hold-until\", IPP_TAG_NAME);\n\n      if (!attr || !strcmp(attr->values[0].string.text, \"no-hold\"))\n      {\n\tjob->state->values[0].integer = IPP_JOB_PENDING;\n\tjob->state_value              = IPP_JOB_PENDING;\n\n\tippSetString(job->attrs, &job->reasons, 0, \"none\");\n      }\n      else\n\tippSetString(job->attrs, &job->reasons, 0, \"job-hold-until-specified\");\n    }\n\n    job->dirty = 1;\n    cupsdMarkDirty(CUPSD_DIRTY_JOBS);\n\n    start_job = 1;\n  }\n  else\n  {\n    if ((attr = ippFindAttribute(job->attrs, \"job-hold-until\",\n                                 IPP_TAG_KEYWORD)) == NULL)\n      attr = ippFindAttribute(job->attrs, \"job-hold-until\", IPP_TAG_NAME);\n\n    if (!attr || !strcmp(attr->values[0].string.text, \"no-hold\"))\n    {\n      job->state->values[0].integer = IPP_JOB_HELD;\n      job->state_value              = IPP_JOB_HELD;\n      job->hold_until               = time(NULL) + MultipleOperationTimeout;\n\n      ippSetString(job->attrs, &job->reasons, 0, \"job-incoming\");\n\n      job->dirty = 1;\n      cupsdMarkDirty(CUPSD_DIRTY_JOBS);\n    }\n\n    start_job = 0;\n  }\n\n /*\n  * Fill in the response info...\n  */\n\n  httpAssembleURIf(HTTP_URI_CODING_ALL, job_uri, sizeof(job_uri), \"ipp\", NULL,\n                   con->clientname, con->clientport, \"/jobs/%d\", jobid);\n  ippAddString(con->response, IPP_TAG_JOB, IPP_TAG_URI, \"job-uri\", NULL,\n               job_uri);\n\n  ippAddInteger(con->response, IPP_TAG_JOB, IPP_TAG_INTEGER, \"job-id\", jobid);\n\n  ippAddInteger(con->response, IPP_TAG_JOB, IPP_TAG_ENUM, \"job-state\",\n                job->state_value);\n  ippAddString(con->response, IPP_TAG_JOB, IPP_TAG_KEYWORD, \"job-state-reasons\",\n               NULL, job->reasons->values[0].string.text);\n\n  con->response->request.status.status_code = IPP_OK;\n\n /*\n  * Start the job if necessary...\n  */\n\n  if (start_job)\n    cupsdCheckJobs();\n}\n\n\n/*\n * 'send_http_error()' - Send a HTTP error back to the IPP client.\n */\n\nstatic void\nsend_http_error(\n    cupsd_client_t  *con,\t\t/* I - Client connection */\n    http_status_t   status,\t\t/* I - HTTP status code */\n    cupsd_printer_t *printer)\t\t/* I - Printer, if any */\n{\n  ipp_attribute_t\t*uri;\t\t/* Request URI, if any */\n\n\n  if ((uri = ippFindAttribute(con->request, \"printer-uri\",\n                              IPP_TAG_URI)) == NULL)\n    uri = ippFindAttribute(con->request, \"job-uri\", IPP_TAG_URI);\n\n  cupsdLogMessage(status == HTTP_FORBIDDEN ? CUPSD_LOG_ERROR : CUPSD_LOG_DEBUG,\n                  \"[Client %d] Returning HTTP %s for %s (%s) from %s\",\n                  con->number, httpStatus(status),\n\t\t  con->request ?\n\t\t      ippOpString(con->request->request.op.operation_id) :\n\t\t      \"no operation-id\",\n\t\t  uri ? uri->values[0].string.text : \"no URI\",\n\t\t  con->http->hostname);\n\n  if (printer)\n  {\n    int\t\tauth_type;\t\t/* Type of authentication required */\n\n\n    auth_type = CUPSD_AUTH_NONE;\n\n    if (status == HTTP_UNAUTHORIZED &&\n        printer->num_auth_info_required > 0 &&\n        !strcmp(printer->auth_info_required[0], \"negotiate\") &&\n\tcon->request &&\n\t(con->request->request.op.operation_id == IPP_PRINT_JOB ||\n\t con->request->request.op.operation_id == IPP_CREATE_JOB ||\n\t con->request->request.op.operation_id == CUPS_AUTHENTICATE_JOB))\n    {\n     /*\n      * Creating and authenticating jobs requires Kerberos...\n      */\n\n      auth_type = CUPSD_AUTH_NEGOTIATE;\n    }\n    else\n    {\n     /*\n      * Use policy/location-defined authentication requirements...\n      */\n\n      char\tresource[HTTP_MAX_URI];\t/* Resource portion of URI */\n      cupsd_location_t *auth;\t\t/* Pointer to authentication element */\n\n\n      if (printer->type & CUPS_PRINTER_CLASS)\n\tsnprintf(resource, sizeof(resource), \"/classes/%s\", printer->name);\n      else\n\tsnprintf(resource, sizeof(resource), \"/printers/%s\", printer->name);\n\n      if ((auth = cupsdFindBest(resource, HTTP_POST)) == NULL ||\n\t  auth->type == CUPSD_AUTH_NONE)\n\tauth = cupsdFindPolicyOp(printer->op_policy_ptr,\n\t\t\t\t con->request ?\n\t\t\t\t     con->request->request.op.operation_id :\n\t\t\t\t     IPP_PRINT_JOB);\n\n      if (auth)\n      {\n        if (auth->type == CUPSD_AUTH_DEFAULT)\n\t  auth_type = cupsdDefaultAuthType();\n\telse\n\t  auth_type = auth->type;\n      }\n    }\n\n    cupsdSendError(con, status, auth_type);\n  }\n  else\n    cupsdSendError(con, status, CUPSD_AUTH_NONE);\n\n  ippDelete(con->response);\n  con->response = NULL;\n\n  return;\n}\n\n\n/*\n * 'send_ipp_status()' - Send a status back to the IPP client.\n */\n\nstatic void\nsend_ipp_status(cupsd_client_t *con,\t/* I - Client connection */\n                ipp_status_t   status,\t/* I - IPP status code */\n\t        const char     *message,/* I - Status message */\n\t        ...)\t\t\t/* I - Additional args as needed */\n{\n  va_list\tap;\t\t\t/* Pointer to additional args */\n  char\t\tformatted[1024];\t/* Formatted errror message */\n\n\n  va_start(ap, message);\n  vsnprintf(formatted, sizeof(formatted),\n            _cupsLangString(con->language, message), ap);\n  va_end(ap);\n\n  cupsdLogMessage(CUPSD_LOG_DEBUG, \"%s %s: %s\",\n\t\t  ippOpString(con->request->request.op.operation_id),\n\t\t  ippErrorString(status), formatted);\n\n  con->response->request.status.status_code = status;\n\n  if (ippFindAttribute(con->response, \"attributes-charset\",\n                       IPP_TAG_ZERO) == NULL)\n    ippAddString(con->response, IPP_TAG_OPERATION, IPP_TAG_CHARSET,\n                 \"attributes-charset\", NULL, \"utf-8\");\n\n  if (ippFindAttribute(con->response, \"attributes-natural-language\",\n                       IPP_TAG_ZERO) == NULL)\n    ippAddString(con->response, IPP_TAG_OPERATION, IPP_TAG_LANGUAGE,\n                 \"attributes-natural-language\", NULL, DefaultLanguage);\n\n  ippAddString(con->response, IPP_TAG_OPERATION, IPP_TAG_TEXT,\n               \"status-message\", NULL, formatted);\n}\n\n\n/*\n * 'set_default()' - Set the default destination...\n */\n\nstatic void\nset_default(cupsd_client_t  *con,\t/* I - Client connection */\n            ipp_attribute_t *uri)\t/* I - Printer URI */\n{\n  http_status_t\t\tstatus;\t\t/* Policy status */\n  cups_ptype_t\t\tdtype;\t\t/* Destination type (printer/class) */\n  cupsd_printer_t\t*printer,\t/* Printer */\n\t\t\t*oldprinter;\t/* Old default printer */\n\n\n  cupsdLogMessage(CUPSD_LOG_DEBUG2, \"set_default(%p[%d], %s)\", con,\n                  con->number, uri->values[0].string.text);\n\n /*\n  * Is the destination valid?\n  */\n\n  if (!cupsdValidateDest(uri->values[0].string.text, &dtype, &printer))\n  {\n   /*\n    * Bad URI...\n    */\n\n    send_ipp_status(con, IPP_NOT_FOUND,\n                    _(\"The printer or class does not exist.\"));\n    return;\n  }\n\n /*\n  * Check policy...\n  */\n\n  if ((status = cupsdCheckPolicy(DefaultPolicyPtr, con, NULL)) != HTTP_OK)\n  {\n    send_http_error(con, status, NULL);\n    return;\n  }\n\n /*\n  * Set it as the default...\n  */\n\n  oldprinter     = DefaultPrinter;\n  DefaultPrinter = printer;\n\n  if (oldprinter)\n    cupsdAddEvent(CUPSD_EVENT_PRINTER_STATE, oldprinter, NULL,\n                  \"%s is no longer the default printer.\", oldprinter->name);\n\n  cupsdAddEvent(CUPSD_EVENT_PRINTER_STATE, printer, NULL,\n\t\t\"%s is now the default printer.\", printer->name);\n\n  cupsdMarkDirty(CUPSD_DIRTY_PRINTERS | CUPSD_DIRTY_CLASSES |\n                 CUPSD_DIRTY_PRINTCAP);\n\n  cupsdLogMessage(CUPSD_LOG_INFO,\n                  \"Default destination set to \\\"%s\\\" by \\\"%s\\\".\",\n\t\t  printer->name, get_username(con));\n\n /*\n  * Everything was ok, so return OK status...\n  */\n\n  con->response->request.status.status_code = IPP_OK;\n}\n\n\n/*\n * 'set_job_attrs()' - Set job attributes.\n */\n\nstatic void\nset_job_attrs(cupsd_client_t  *con,\t/* I - Client connection */\n\t      ipp_attribute_t *uri)\t/* I - Job URI */\n{\n  ipp_attribute_t\t*attr,\t\t/* Current attribute */\n\t\t\t*attr2;\t\t/* Job attribute */\n  int\t\t\tjobid;\t\t/* Job ID */\n  cupsd_job_t\t\t*job;\t\t/* Current job */\n  char\t\t\tscheme[HTTP_MAX_URI],\n\t\t\t\t\t/* Method portion of URI */\n\t\t\tusername[HTTP_MAX_URI],\n\t\t\t\t\t/* Username portion of URI */\n\t\t\thost[HTTP_MAX_URI],\n\t\t\t\t\t/* Host portion of URI */\n\t\t\tresource[HTTP_MAX_URI];\n\t\t\t\t\t/* Resource portion of URI */\n  int\t\t\tport;\t\t/* Port portion of URI */\n  int\t\t\tevent;\t\t/* Events? */\n  int\t\t\tcheck_jobs;\t/* Check jobs? */\n\n\n  cupsdLogMessage(CUPSD_LOG_DEBUG2, \"set_job_attrs(%p[%d], %s)\", con,\n                  con->number, uri->values[0].string.text);\n\n /*\n  * Start with \"everything is OK\" status...\n  */\n\n  con->response->request.status.status_code = IPP_OK;\n\n /*\n  * See if we have a job URI or a printer URI...\n  */\n\n  if (!strcmp(uri->name, \"printer-uri\"))\n  {\n   /*\n    * Got a printer URI; see if we also have a job-id attribute...\n    */\n\n    if ((attr = ippFindAttribute(con->request, \"job-id\",\n                                 IPP_TAG_INTEGER)) == NULL)\n    {\n      send_ipp_status(con, IPP_BAD_REQUEST,\n                      _(\"Got a printer-uri attribute but no job-id.\"));\n      return;\n    }\n\n    jobid = attr->values[0].integer;\n  }\n  else\n  {\n   /*\n    * Got a job URI; parse it to get the job ID...\n    */\n\n    httpSeparateURI(HTTP_URI_CODING_ALL, uri->values[0].string.text, scheme,\n                    sizeof(scheme), username, sizeof(username), host,\n\t\t    sizeof(host), &port, resource, sizeof(resource));\n\n    if (strncmp(resource, \"/jobs/\", 6))\n    {\n     /*\n      * Not a valid URI!\n      */\n\n      send_ipp_status(con, IPP_BAD_REQUEST, _(\"Bad job-uri \\\"%s\\\".\"),\n                      uri->values[0].string.text);\n      return;\n    }\n\n    jobid = atoi(resource + 6);\n  }\n\n /*\n  * See if the job exists...\n  */\n\n  if ((job = cupsdFindJob(jobid)) == NULL)\n  {\n   /*\n    * Nope - return a \"not found\" error...\n    */\n\n    send_ipp_status(con, IPP_NOT_FOUND, _(\"Job #%d does not exist.\"), jobid);\n    return;\n  }\n\n /*\n  * See if the job has been completed...\n  */\n\n  if (job->state_value > IPP_JOB_STOPPED)\n  {\n   /*\n    * Return a \"not-possible\" error...\n    */\n\n    send_ipp_status(con, IPP_NOT_POSSIBLE,\n                    _(\"Job #%d is finished and cannot be altered.\"), jobid);\n    return;\n  }\n\n /*\n  * See if the job is owned by the requesting user...\n  */\n\n  if (!validate_user(job, con, job->username, username, sizeof(username)))\n  {\n    send_http_error(con, con->username[0] ? HTTP_FORBIDDEN : HTTP_UNAUTHORIZED,\n                    cupsdFindDest(job->dest));\n    return;\n  }\n\n /*\n  * See what the user wants to change.\n  */\n\n  cupsdLoadJob(job);\n\n  check_jobs = 0;\n  event      = 0;\n\n  for (attr = con->request->attrs; attr; attr = attr->next)\n  {\n    if (attr->group_tag != IPP_TAG_JOB || !attr->name)\n      continue;\n\n    if (!strcmp(attr->name, \"attributes-charset\") ||\n\t!strcmp(attr->name, \"attributes-natural-language\") ||\n\t!strncmp(attr->name, \"date-time-at-\", 13) ||\n\t!strncmp(attr->name, \"document-compression\", 20) ||\n\t!strncmp(attr->name, \"document-format\", 15) ||\n\t!strcmp(attr->name, \"job-detailed-status-messages\") ||\n\t!strcmp(attr->name, \"job-document-access-errors\") ||\n\t!strcmp(attr->name, \"job-id\") ||\n\t!strcmp(attr->name, \"job-impressions-completed\") ||\n\t!strcmp(attr->name, \"job-k-octets-completed\") ||\n\t!strcmp(attr->name, \"job-media-sheets-completed\") ||\n        !strcmp(attr->name, \"job-originating-host-name\") ||\n        !strcmp(attr->name, \"job-originating-user-name\") ||\n\t!strcmp(attr->name, \"job-pages-completed\") ||\n\t!strcmp(attr->name, \"job-printer-up-time\") ||\n\t!strcmp(attr->name, \"job-printer-uri\") ||\n\t!strcmp(attr->name, \"job-sheets\") ||\n\t!strcmp(attr->name, \"job-state-message\") ||\n\t!strcmp(attr->name, \"job-state-reasons\") ||\n\t!strcmp(attr->name, \"job-uri\") ||\n\t!strcmp(attr->name, \"number-of-documents\") ||\n\t!strcmp(attr->name, \"number-of-intervening-jobs\") ||\n\t!strcmp(attr->name, \"output-device-assigned\") ||\n\t!strncmp(attr->name, \"time-at-\", 8))\n    {\n     /*\n      * Read-only attrs!\n      */\n\n      send_ipp_status(con, IPP_ATTRIBUTES_NOT_SETTABLE,\n                      _(\"%s cannot be changed.\"), attr->name);\n\n      attr2 = ippCopyAttribute(con->response, attr, 0);\n      ippSetGroupTag(con->response, &attr2, IPP_TAG_UNSUPPORTED_GROUP);\n      continue;\n    }\n\n    if (!strcmp(attr->name, \"job-priority\"))\n    {\n     /*\n      * Change the job priority...\n      */\n\n      if (attr->value_tag != IPP_TAG_INTEGER)\n      {\n\tsend_ipp_status(con, IPP_REQUEST_VALUE, _(\"Bad job-priority value.\"));\n\n\tattr2 = ippCopyAttribute(con->response, attr, 0);\n\tippSetGroupTag(con->response, &attr2, IPP_TAG_UNSUPPORTED_GROUP);\n      }\n      else if (job->state_value >= IPP_JOB_PROCESSING)\n      {\n\tsend_ipp_status(con, IPP_NOT_POSSIBLE,\n\t                _(\"Job is completed and cannot be changed.\"));\n\treturn;\n      }\n      else if (con->response->request.status.status_code == IPP_OK)\n      {\n        cupsdLogJob(job, CUPSD_LOG_DEBUG, \"Setting job-priority to %d\",\n\t            attr->values[0].integer);\n        cupsdSetJobPriority(job, attr->values[0].integer);\n\n\tcheck_jobs = 1;\n        event      |= CUPSD_EVENT_JOB_CONFIG_CHANGED |\n\t              CUPSD_EVENT_PRINTER_QUEUE_ORDER_CHANGED;\n      }\n    }\n    else if (!strcmp(attr->name, \"job-state\"))\n    {\n     /*\n      * Change the job state...\n      */\n\n      if (attr->value_tag != IPP_TAG_ENUM)\n      {\n\tsend_ipp_status(con, IPP_REQUEST_VALUE, _(\"Bad job-state value.\"));\n\n\tattr2 = ippCopyAttribute(con->response, attr, 0);\n\tippSetGroupTag(con->response, &attr2, IPP_TAG_UNSUPPORTED_GROUP);\n      }\n      else\n      {\n        switch (attr->values[0].integer)\n\t{\n\t  case IPP_JOB_PENDING :\n\t  case IPP_JOB_HELD :\n\t      if (job->state_value > IPP_JOB_HELD)\n\t      {\n\t\tsend_ipp_status(con, IPP_NOT_POSSIBLE,\n\t\t                _(\"Job state cannot be changed.\"));\n\t\treturn;\n\t      }\n              else if (con->response->request.status.status_code == IPP_OK)\n\t      {\n\t\tcupsdLogJob(job, CUPSD_LOG_DEBUG, \"Setting job-state to %d\",\n\t\t\t    attr->values[0].integer);\n                cupsdSetJobState(job, (ipp_jstate_t)attr->values[0].integer, CUPSD_JOB_DEFAULT, \"Job state changed by \\\"%s\\\"\", username);\n\t\tcheck_jobs = 1;\n\t      }\n\t      break;\n\n\t  case IPP_JOB_PROCESSING :\n\t  case IPP_JOB_STOPPED :\n\t      if (job->state_value != attr->values[0].integer)\n\t      {\n\t\tsend_ipp_status(con, IPP_NOT_POSSIBLE,\n\t\t                _(\"Job state cannot be changed.\"));\n\t\treturn;\n\t      }\n\t      break;\n\n\t  case IPP_JOB_CANCELED :\n\t  case IPP_JOB_ABORTED :\n\t  case IPP_JOB_COMPLETED :\n\t      if (job->state_value > IPP_JOB_PROCESSING)\n\t      {\n\t\tsend_ipp_status(con, IPP_NOT_POSSIBLE,\n\t\t                _(\"Job state cannot be changed.\"));\n\t\treturn;\n\t      }\n              else if (con->response->request.status.status_code == IPP_OK)\n\t      {\n\t\tcupsdLogJob(job, CUPSD_LOG_DEBUG, \"Setting job-state to %d\",\n\t\t\t    attr->values[0].integer);\n                cupsdSetJobState(job, (ipp_jstate_t)attr->values[0].integer,\n\t\t                 CUPSD_JOB_DEFAULT,\n\t\t\t\t \"Job state changed by \\\"%s\\\"\", username);\n                check_jobs = 1;\n\t      }\n\t      break;\n\t}\n      }\n    }\n    else if (con->response->request.status.status_code != IPP_OK)\n      continue;\n    else if ((attr2 = ippFindAttribute(job->attrs, attr->name,\n                                       IPP_TAG_ZERO)) != NULL)\n    {\n     /*\n      * Some other value; first free the old value...\n      */\n\n      if (job->attrs->prev)\n        job->attrs->prev->next = attr2->next;\n      else\n        job->attrs->attrs = attr2->next;\n\n      if (job->attrs->last == attr2)\n        job->attrs->last = job->attrs->prev;\n\n      ippDeleteAttribute(NULL, attr2);\n\n     /*\n      * Then copy the attribute...\n      */\n\n      ippCopyAttribute(job->attrs, attr, 0);\n\n     /*\n      * See if the job-name or job-hold-until is being changed.\n      */\n\n      if (!strcmp(attr->name, \"job-hold-until\"))\n      {\n        cupsdLogJob(job, CUPSD_LOG_DEBUG, \"Setting job-hold-until to %s\",\n\t\t    attr->values[0].string.text);\n        cupsdSetJobHoldUntil(job, attr->values[0].string.text, 0);\n\n\tif (!strcmp(attr->values[0].string.text, \"no-hold\"))\n\t{\n\t  cupsdReleaseJob(job);\n          check_jobs = 1;\n\t}\n\telse\n\t  cupsdSetJobState(job, IPP_JOB_HELD, CUPSD_JOB_DEFAULT,\n\t                   \"Job held by \\\"%s\\\".\", username);\n\n        event |= CUPSD_EVENT_JOB_CONFIG_CHANGED | CUPSD_EVENT_JOB_STATE;\n      }\n    }\n    else if (attr->value_tag == IPP_TAG_DELETEATTR)\n    {\n     /*\n      * Delete the attribute...\n      */\n\n      if ((attr2 = ippFindAttribute(job->attrs, attr->name,\n                                    IPP_TAG_ZERO)) != NULL)\n      {\n        if (job->attrs->prev)\n\t  job->attrs->prev->next = attr2->next;\n\telse\n\t  job->attrs->attrs = attr2->next;\n\n        if (attr2 == job->attrs->last)\n\t  job->attrs->last = job->attrs->prev;\n\n        ippDeleteAttribute(NULL, attr2);\n\n        event |= CUPSD_EVENT_JOB_CONFIG_CHANGED;\n      }\n    }\n    else\n    {\n     /*\n      * Add new option by copying it...\n      */\n\n      ippCopyAttribute(job->attrs, attr, 0);\n\n      event |= CUPSD_EVENT_JOB_CONFIG_CHANGED;\n    }\n  }\n\n /*\n  * Save the job...\n  */\n\n  job->dirty = 1;\n  cupsdMarkDirty(CUPSD_DIRTY_JOBS);\n\n /*\n  * Send events as needed...\n  */\n\n  if (event & CUPSD_EVENT_PRINTER_QUEUE_ORDER_CHANGED)\n    cupsdAddEvent(CUPSD_EVENT_PRINTER_QUEUE_ORDER_CHANGED,\n                  cupsdFindDest(job->dest), job,\n                  \"Job priority changed by user.\");\n\n  if (event & CUPSD_EVENT_JOB_STATE)\n    cupsdAddEvent(CUPSD_EVENT_JOB_STATE, cupsdFindDest(job->dest), job,\n                  job->state_value == IPP_JOB_HELD ?\n\t\t      \"Job held by user.\" : \"Job restarted by user.\");\n\n  if (event & CUPSD_EVENT_JOB_CONFIG_CHANGED)\n    cupsdAddEvent(CUPSD_EVENT_JOB_CONFIG_CHANGED, cupsdFindDest(job->dest), job,\n                  \"Job options changed by user.\");\n\n /*\n  * Start jobs if possible...\n  */\n\n  if (check_jobs)\n    cupsdCheckJobs();\n}\n\n\n/*\n * 'set_printer_attrs()' - Set printer attributes.\n */\n\nstatic void\nset_printer_attrs(cupsd_client_t  *con,\t/* I - Client connection */\n                  ipp_attribute_t *uri)\t/* I - Printer */\n{\n  http_status_t\t\tstatus;\t\t/* Policy status */\n  cups_ptype_t\t\tdtype;\t\t/* Destination type (printer/class) */\n  cupsd_printer_t\t*printer;\t/* Printer/class */\n  ipp_attribute_t\t*attr;\t\t/* Printer attribute */\n  int\t\t\tchanged = 0;\t/* Was anything changed? */\n\n\n  cupsdLogMessage(CUPSD_LOG_DEBUG2, \"set_printer_attrs(%p[%d], %s)\", con,\n                  con->number, uri->values[0].string.text);\n\n /*\n  * Is the destination valid?\n  */\n\n  if (!cupsdValidateDest(uri->values[0].string.text, &dtype, &printer))\n  {\n   /*\n    * Bad URI...\n    */\n\n    send_ipp_status(con, IPP_NOT_FOUND,\n                    _(\"The printer or class does not exist.\"));\n    return;\n  }\n\n /*\n  * Check policy...\n  */\n\n  if ((status = cupsdCheckPolicy(printer->op_policy_ptr, con, NULL)) != HTTP_OK)\n  {\n    send_http_error(con, status, printer);\n    return;\n  }\n\n /*\n  * Return a list of attributes that can be set via Set-Printer-Attributes.\n  */\n\n  if ((attr = ippFindAttribute(con->request, \"printer-location\",\n                               IPP_TAG_TEXT)) != NULL)\n  {\n    cupsdSetString(&printer->location, attr->values[0].string.text);\n    changed = 1;\n  }\n\n  if ((attr = ippFindAttribute(con->request, \"printer-geo-location\", IPP_TAG_URI)) != NULL && !strncmp(attr->values[0].string.text, \"geo:\", 4))\n  {\n    cupsdSetString(&printer->geo_location, attr->values[0].string.text);\n    changed = 1;\n  }\n\n  if ((attr = ippFindAttribute(con->request, \"printer-organization\", IPP_TAG_TEXT)) != NULL)\n  {\n    cupsdSetString(&printer->organization, attr->values[0].string.text);\n    changed = 1;\n  }\n\n  if ((attr = ippFindAttribute(con->request, \"printer-organizational-unit\", IPP_TAG_TEXT)) != NULL)\n  {\n    cupsdSetString(&printer->organizational_unit, attr->values[0].string.text);\n    changed = 1;\n  }\n\n  if ((attr = ippFindAttribute(con->request, \"printer-info\",\n                               IPP_TAG_TEXT)) != NULL)\n  {\n    cupsdSetString(&printer->info, attr->values[0].string.text);\n    changed = 1;\n  }\n\n /*\n  * Update the printer attributes and return...\n  */\n\n  if (changed)\n  {\n    printer->config_time = time(NULL);\n\n    cupsdSetPrinterAttrs(printer);\n    cupsdMarkDirty(CUPSD_DIRTY_PRINTERS);\n\n    cupsdAddEvent(CUPSD_EVENT_PRINTER_CONFIG, printer, NULL,\n                  \"Printer \\\"%s\\\" description or location changed by \\\"%s\\\".\",\n\t\t  printer->name, get_username(con));\n\n    cupsdLogMessage(CUPSD_LOG_INFO,\n                    \"Printer \\\"%s\\\" description or location changed by \\\"%s\\\".\",\n                    printer->name, get_username(con));\n  }\n\n  con->response->request.status.status_code = IPP_OK;\n}\n\n\n/*\n * 'set_printer_defaults()' - Set printer default options from a request.\n */\n\nstatic int\t\t\t\t/* O - 1 on success, 0 on failure */\nset_printer_defaults(\n    cupsd_client_t  *con,\t\t/* I - Client connection */\n    cupsd_printer_t *printer)\t\t/* I - Printer */\n{\n  int\t\t\ti;\t\t/* Looping var */\n  ipp_attribute_t \t*attr;\t\t/* Current attribute */\n  size_t\t\tnamelen;\t/* Length of attribute name */\n  char\t\t\tname[256],\t/* New attribute name */\n\t\t\tvalue[256];\t/* String version of integer attrs */\n\n\n  for (attr = con->request->attrs; attr; attr = attr->next)\n  {\n   /*\n    * Skip non-printer attributes...\n    */\n\n    if (attr->group_tag != IPP_TAG_PRINTER || !attr->name)\n      continue;\n\n    cupsdLogMessage(CUPSD_LOG_DEBUG2, \"set_printer_defaults: %s\", attr->name);\n\n    if (!strcmp(attr->name, \"job-sheets-default\"))\n    {\n     /*\n      * Only allow keywords and names...\n      */\n\n      if (attr->value_tag != IPP_TAG_NAME && attr->value_tag != IPP_TAG_KEYWORD)\n        continue;\n\n     /*\n      * Only allow job-sheets-default to be set when running without a\n      * system high classification level...\n      */\n\n      if (Classification)\n        continue;\n\n      cupsdSetString(&printer->job_sheets[0], attr->values[0].string.text);\n\n      if (attr->num_values > 1)\n\tcupsdSetString(&printer->job_sheets[1], attr->values[1].string.text);\n      else\n\tcupsdSetString(&printer->job_sheets[1], \"none\");\n    }\n    else if (!strcmp(attr->name, \"requesting-user-name-allowed\"))\n    {\n      cupsdFreeStrings(&(printer->users));\n\n      printer->deny_users = 0;\n\n      if (attr->value_tag == IPP_TAG_NAME &&\n          (attr->num_values > 1 ||\n\t   strcmp(attr->values[0].string.text, \"all\")))\n      {\n\tfor (i = 0; i < attr->num_values; i ++)\n\t  cupsdAddString(&(printer->users), attr->values[i].string.text);\n      }\n    }\n    else if (!strcmp(attr->name, \"requesting-user-name-denied\"))\n    {\n      cupsdFreeStrings(&(printer->users));\n\n      printer->deny_users = 1;\n\n      if (attr->value_tag == IPP_TAG_NAME &&\n          (attr->num_values > 1 ||\n\t   strcmp(attr->values[0].string.text, \"none\")))\n      {\n\tfor (i = 0; i < attr->num_values; i ++)\n\t  cupsdAddString(&(printer->users), attr->values[i].string.text);\n      }\n    }\n    else if (!strcmp(attr->name, \"job-quota-period\"))\n    {\n      if (attr->value_tag != IPP_TAG_INTEGER)\n        continue;\n\n      cupsdLogMessage(CUPSD_LOG_DEBUG, \"Setting job-quota-period to %d...\",\n        \t      attr->values[0].integer);\n      cupsdFreeQuotas(printer);\n\n      printer->quota_period = attr->values[0].integer;\n    }\n    else if (!strcmp(attr->name, \"job-k-limit\"))\n    {\n      if (attr->value_tag != IPP_TAG_INTEGER)\n        continue;\n\n      cupsdLogMessage(CUPSD_LOG_DEBUG, \"Setting job-k-limit to %d...\",\n        \t      attr->values[0].integer);\n      cupsdFreeQuotas(printer);\n\n      printer->k_limit = attr->values[0].integer;\n    }\n    else if (!strcmp(attr->name, \"job-page-limit\"))\n    {\n      if (attr->value_tag != IPP_TAG_INTEGER)\n        continue;\n\n      cupsdLogMessage(CUPSD_LOG_DEBUG, \"Setting job-page-limit to %d...\",\n        \t      attr->values[0].integer);\n      cupsdFreeQuotas(printer);\n\n      printer->page_limit = attr->values[0].integer;\n    }\n    else if (!strcmp(attr->name, \"printer-op-policy\"))\n    {\n      cupsd_policy_t *p;\t\t/* Policy */\n\n\n      if (attr->value_tag != IPP_TAG_NAME)\n        continue;\n\n      if ((p = cupsdFindPolicy(attr->values[0].string.text)) != NULL)\n      {\n\tcupsdLogMessage(CUPSD_LOG_DEBUG,\n                \t\"Setting printer-op-policy to \\\"%s\\\"...\",\n                \tattr->values[0].string.text);\n\tcupsdSetString(&printer->op_policy, attr->values[0].string.text);\n\tprinter->op_policy_ptr = p;\n      }\n      else\n      {\n\tsend_ipp_status(con, IPP_NOT_POSSIBLE,\n                \t_(\"Unknown printer-op-policy \\\"%s\\\".\"),\n                \tattr->values[0].string.text);\n\treturn (0);\n      }\n    }\n    else if (!strcmp(attr->name, \"printer-error-policy\"))\n    {\n      if (attr->value_tag != IPP_TAG_NAME && attr->value_tag != IPP_TAG_KEYWORD)\n        continue;\n\n      if (strcmp(attr->values[0].string.text, \"retry-current-job\") &&\n          ((printer->type & CUPS_PRINTER_CLASS) ||\n\t   (strcmp(attr->values[0].string.text, \"abort-job\") &&\n\t    strcmp(attr->values[0].string.text, \"retry-job\") &&\n\t    strcmp(attr->values[0].string.text, \"stop-printer\"))))\n      {\n\tsend_ipp_status(con, IPP_NOT_POSSIBLE,\n                \t_(\"Unknown printer-error-policy \\\"%s\\\".\"),\n                \tattr->values[0].string.text);\n\treturn (0);\n      }\n\n      cupsdLogMessage(CUPSD_LOG_DEBUG,\n                      \"Setting printer-error-policy to \\\"%s\\\"...\",\n                      attr->values[0].string.text);\n      cupsdSetString(&printer->error_policy, attr->values[0].string.text);\n    }\n\n   /*\n    * Skip any other non-default attributes...\n    */\n\n    namelen = strlen(attr->name);\n    if (namelen < 9 || strcmp(attr->name + namelen - 8, \"-default\") ||\n        namelen > (sizeof(name) - 1) || attr->num_values != 1)\n      continue;\n\n   /*\n    * OK, anything else must be a user-defined default...\n    */\n\n    strlcpy(name, attr->name, sizeof(name));\n    name[namelen - 8] = '\\0';\t\t/* Strip \"-default\" */\n\n    switch (attr->value_tag)\n    {\n      case IPP_TAG_DELETEATTR :\n          printer->num_options = cupsRemoveOption(name,\n\t\t\t\t\t\t  printer->num_options,\n\t\t\t\t\t\t  &(printer->options));\n          cupsdLogMessage(CUPSD_LOG_DEBUG,\n\t                  \"Deleting %s\", attr->name);\n          break;\n\n      case IPP_TAG_NAME :\n      case IPP_TAG_TEXT :\n      case IPP_TAG_KEYWORD :\n      case IPP_TAG_URI :\n          printer->num_options = cupsAddOption(name,\n\t                                       attr->values[0].string.text,\n\t\t\t\t\t       printer->num_options,\n\t\t\t\t\t       &(printer->options));\n          cupsdLogMessage(CUPSD_LOG_DEBUG,\n\t                  \"Setting %s to \\\"%s\\\"...\", attr->name,\n\t\t\t  attr->values[0].string.text);\n          break;\n\n      case IPP_TAG_BOOLEAN :\n          printer->num_options = cupsAddOption(name,\n\t                                       attr->values[0].boolean ?\n\t\t\t\t\t           \"true\" : \"false\",\n\t\t\t\t\t       printer->num_options,\n\t\t\t\t\t       &(printer->options));\n          cupsdLogMessage(CUPSD_LOG_DEBUG,\n\t                  \"Setting %s to %s...\", attr->name,\n\t\t\t  attr->values[0].boolean ? \"true\" : \"false\");\n          break;\n\n      case IPP_TAG_INTEGER :\n      case IPP_TAG_ENUM :\n          sprintf(value, \"%d\", attr->values[0].integer);\n          printer->num_options = cupsAddOption(name, value,\n\t\t\t\t\t       printer->num_options,\n\t\t\t\t\t       &(printer->options));\n          cupsdLogMessage(CUPSD_LOG_DEBUG,\n\t                  \"Setting %s to %s...\", attr->name, value);\n          break;\n\n      case IPP_TAG_RANGE :\n          sprintf(value, \"%d-%d\", attr->values[0].range.lower,\n\t          attr->values[0].range.upper);\n          printer->num_options = cupsAddOption(name, value,\n\t\t\t\t\t       printer->num_options,\n\t\t\t\t\t       &(printer->options));\n          cupsdLogMessage(CUPSD_LOG_DEBUG,\n\t                  \"Setting %s to %s...\", attr->name, value);\n          break;\n\n      case IPP_TAG_RESOLUTION :\n          sprintf(value, \"%dx%d%s\", attr->values[0].resolution.xres,\n\t          attr->values[0].resolution.yres,\n\t\t  attr->values[0].resolution.units == IPP_RES_PER_INCH ?\n\t\t      \"dpi\" : \"dpcm\");\n          printer->num_options = cupsAddOption(name, value,\n\t\t\t\t\t       printer->num_options,\n\t\t\t\t\t       &(printer->options));\n          cupsdLogMessage(CUPSD_LOG_DEBUG,\n\t                  \"Setting %s to %s...\", attr->name, value);\n          break;\n\n      default :\n          /* Do nothing for other values */\n\t  break;\n    }\n  }\n\n  return (1);\n}\n\n\n/*\n * 'start_printer()' - Start a printer.\n */\n\nstatic void\nstart_printer(cupsd_client_t  *con,\t/* I - Client connection */\n              ipp_attribute_t *uri)\t/* I - Printer URI */\n{\n  int\t\t\ti;\t\t/* Temporary variable */\n  http_status_t\t\tstatus;\t\t/* Policy status */\n  cups_ptype_t\t\tdtype;\t\t/* Destination type (printer/class) */\n  cupsd_printer_t\t*printer;\t/* Printer data */\n\n\n  cupsdLogMessage(CUPSD_LOG_DEBUG2, \"start_printer(%p[%d], %s)\", con,\n                  con->number, uri->values[0].string.text);\n\n /*\n  * Is the destination valid?\n  */\n\n  if (!cupsdValidateDest(uri->values[0].string.text, &dtype, &printer))\n  {\n   /*\n    * Bad URI...\n    */\n\n    send_ipp_status(con, IPP_NOT_FOUND,\n                    _(\"The printer or class does not exist.\"));\n    return;\n  }\n\n /*\n  * Check policy...\n  */\n\n  if ((status = cupsdCheckPolicy(printer->op_policy_ptr, con, NULL)) != HTTP_OK)\n  {\n    send_http_error(con, status, printer);\n    return;\n  }\n\n /*\n  * Start the printer...\n  */\n\n  printer->state_message[0] = '\\0';\n\n  cupsdStartPrinter(printer, 1);\n\n  if (dtype & CUPS_PRINTER_CLASS)\n    cupsdLogMessage(CUPSD_LOG_INFO, \"Class \\\"%s\\\" started by \\\"%s\\\".\",\n                    printer->name, get_username(con));\n  else\n    cupsdLogMessage(CUPSD_LOG_INFO, \"Printer \\\"%s\\\" started by \\\"%s\\\".\",\n                    printer->name, get_username(con));\n\n  cupsdCheckJobs();\n\n /*\n  * Check quotas...\n  */\n\n  if ((i = check_quotas(con, printer)) < 0)\n  {\n    send_ipp_status(con, IPP_NOT_POSSIBLE, _(\"Quota limit reached.\"));\n    return;\n  }\n  else if (i == 0)\n  {\n    send_ipp_status(con, IPP_NOT_AUTHORIZED, _(\"Not allowed to print.\"));\n    return;\n  }\n\n /*\n  * Everything was ok, so return OK status...\n  */\n\n  con->response->request.status.status_code = IPP_OK;\n}\n\n\n/*\n * 'stop_printer()' - Stop a printer.\n */\n\nstatic void\nstop_printer(cupsd_client_t  *con,\t/* I - Client connection */\n             ipp_attribute_t *uri)\t/* I - Printer URI */\n{\n  http_status_t\t\tstatus;\t\t/* Policy status */\n  cups_ptype_t\t\tdtype;\t\t/* Destination type (printer/class) */\n  cupsd_printer_t\t*printer;\t/* Printer data */\n  ipp_attribute_t\t*attr;\t\t/* printer-state-message attribute */\n\n\n  cupsdLogMessage(CUPSD_LOG_DEBUG2, \"stop_printer(%p[%d], %s)\", con,\n                  con->number, uri->values[0].string.text);\n\n /*\n  * Is the destination valid?\n  */\n\n  if (!cupsdValidateDest(uri->values[0].string.text, &dtype, &printer))\n  {\n   /*\n    * Bad URI...\n    */\n\n    send_ipp_status(con, IPP_NOT_FOUND,\n                    _(\"The printer or class does not exist.\"));\n    return;\n  }\n\n /*\n  * Check policy...\n  */\n\n  if ((status = cupsdCheckPolicy(printer->op_policy_ptr, con, NULL)) != HTTP_OK)\n  {\n    send_http_error(con, status, printer);\n    return;\n  }\n\n /*\n  * Stop the printer...\n  */\n\n  if ((attr = ippFindAttribute(con->request, \"printer-state-message\",\n                               IPP_TAG_TEXT)) == NULL)\n    strlcpy(printer->state_message, \"Paused\", sizeof(printer->state_message));\n  else\n  {\n    strlcpy(printer->state_message, attr->values[0].string.text,\n            sizeof(printer->state_message));\n  }\n\n  cupsdStopPrinter(printer, 1);\n\n  if (dtype & CUPS_PRINTER_CLASS)\n    cupsdLogMessage(CUPSD_LOG_INFO, \"Class \\\"%s\\\" stopped by \\\"%s\\\".\",\n                    printer->name, get_username(con));\n  else\n    cupsdLogMessage(CUPSD_LOG_INFO, \"Printer \\\"%s\\\" stopped by \\\"%s\\\".\",\n                    printer->name, get_username(con));\n\n /*\n  * Everything was ok, so return OK status...\n  */\n\n  con->response->request.status.status_code = IPP_OK;\n}\n\n\n/*\n * 'url_encode_attr()' - URL-encode a string attribute.\n */\n\nstatic void\nurl_encode_attr(ipp_attribute_t *attr,\t/* I - Attribute */\n                char            *buffer,/* I - String buffer */\n\t\tsize_t          bufsize)/* I - Size of buffer */\n{\n  int\ti;\t\t\t\t/* Looping var */\n  char\t*bufptr,\t\t\t/* Pointer into buffer */\n\t*bufend;\t\t\t/* End of buffer */\n\n\n  strlcpy(buffer, attr->name, bufsize);\n  bufptr = buffer + strlen(buffer);\n  bufend = buffer + bufsize - 1;\n\n  for (i = 0; i < attr->num_values; i ++)\n  {\n    if (bufptr >= bufend)\n      break;\n\n    if (i)\n      *bufptr++ = ',';\n    else\n      *bufptr++ = '=';\n\n    if (bufptr >= bufend)\n      break;\n\n    *bufptr++ = '\\'';\n\n    bufptr = url_encode_string(attr->values[i].string.text, bufptr, (size_t)(bufend - bufptr + 1));\n\n    if (bufptr >= bufend)\n      break;\n\n    *bufptr++ = '\\'';\n  }\n\n  *bufptr = '\\0';\n}\n\n\n/*\n * 'url_encode_string()' - URL-encode a string.\n */\n\nstatic char *\t\t\t\t/* O - End of string */\nurl_encode_string(const char *s,\t/* I - String */\n                  char       *buffer,\t/* I - String buffer */\n\t\t  size_t     bufsize)\t/* I - Size of buffer */\n{\n  char\t*bufptr,\t\t\t/* Pointer into buffer */\n\t*bufend;\t\t\t/* End of buffer */\n  static const char *hex = \"0123456789ABCDEF\";\n\t\t\t\t\t/* Hex digits */\n\n\n  bufptr = buffer;\n  bufend = buffer + bufsize - 1;\n\n  while (*s && bufptr < bufend)\n  {\n    if (*s == ' ' || *s == '%' || *s == '+')\n    {\n      if (bufptr >= (bufend - 2))\n\tbreak;\n\n      *bufptr++ = '%';\n      *bufptr++ = hex[(*s >> 4) & 15];\n      *bufptr++ = hex[*s & 15];\n\n      s ++;\n    }\n    else if (*s == '\\'' || *s == '\\\\')\n    {\n      if (bufptr >= (bufend - 1))\n\tbreak;\n\n      *bufptr++ = '\\\\';\n      *bufptr++ = *s++;\n    }\n    else\n      *bufptr++ = *s++;\n  }\n\n  *bufptr = '\\0';\n\n  return (bufptr);\n}\n\n\n/*\n * 'user_allowed()' - See if a user is allowed to print to a queue.\n */\n\nstatic int\t\t\t\t/* O - 0 if not allowed, 1 if allowed */\nuser_allowed(cupsd_printer_t *p,\t/* I - Printer or class */\n             const char      *username)\t/* I - Username */\n{\n  struct passwd\t*pw;\t\t\t/* User password data */\n  char\t\tbaseuser[256],\t\t/* Base username */\n\t\t*baseptr,\t\t/* Pointer to \"@\" in base username */\n\t\t*name;\t\t\t/* Current user name */\n\n\n  if (cupsArrayCount(p->users) == 0)\n    return (1);\n\n  if (!strcmp(username, \"root\"))\n    return (1);\n\n  if (strchr(username, '@'))\n  {\n   /*\n    * Strip @REALM for username check...\n    */\n\n    strlcpy(baseuser, username, sizeof(baseuser));\n\n    if ((baseptr = strchr(baseuser, '@')) != NULL)\n      *baseptr = '\\0';\n\n    username = baseuser;\n  }\n\n  pw = getpwnam(username);\n  endpwent();\n\n  for (name = (char *)cupsArrayFirst(p->users);\n       name;\n       name = (char *)cupsArrayNext(p->users))\n  {\n    if (name[0] == '@')\n    {\n     /*\n      * Check group membership...\n      */\n\n      if (cupsdCheckGroup(username, pw, name + 1))\n        break;\n    }\n    else if (name[0] == '#')\n    {\n     /*\n      * Check UUID...\n      */\n\n      if (cupsdCheckGroup(username, pw, name))\n        break;\n    }\n    else if (!_cups_strcasecmp(username, name))\n      break;\n  }\n\n  return ((name != NULL) != p->deny_users);\n}\n\n\n/*\n * 'validate_job()' - Validate printer options and destination.\n */\n\nstatic void\nvalidate_job(cupsd_client_t  *con,\t/* I - Client connection */\n\t     ipp_attribute_t *uri)\t/* I - Printer URI */\n{\n  http_status_t\t\tstatus;\t\t/* Policy status */\n  ipp_attribute_t\t*attr;\t\t/* Current attribute */\n#ifdef HAVE_SSL\n  ipp_attribute_t\t*auth_info;\t/* auth-info attribute */\n#endif /* HAVE_SSL */\n  ipp_attribute_t\t*format,\t/* Document-format attribute */\n\t\t\t*name;\t\t/* Job-name attribute */\n  cups_ptype_t\t\tdtype;\t\t/* Destination type (printer/class) */\n  char\t\t\tsuper[MIME_MAX_SUPER],\n\t\t\t\t\t/* Supertype of file */\n\t\t\ttype[MIME_MAX_TYPE];\n\t\t\t\t\t/* Subtype of file */\n  cupsd_printer_t\t*printer;\t/* Printer */\n\n\n  cupsdLogMessage(CUPSD_LOG_DEBUG2, \"validate_job(%p[%d], %s)\", con,\n                  con->number, uri->values[0].string.text);\n\n /*\n  * OK, see if the client is sending the document compressed - CUPS\n  * doesn't support compression yet...\n  */\n\n  if ((attr = ippFindAttribute(con->request, \"compression\",\n                               IPP_TAG_KEYWORD)) != NULL)\n  {\n    if (strcmp(attr->values[0].string.text, \"none\")\n#ifdef HAVE_LIBZ\n        && strcmp(attr->values[0].string.text, \"gzip\")\n#endif /* HAVE_LIBZ */\n      )\n    {\n      send_ipp_status(con, IPP_ATTRIBUTES,\n                      _(\"Unsupported 'compression' value \\\"%s\\\".\"),\n        \t      attr->values[0].string.text);\n      ippAddString(con->response, IPP_TAG_UNSUPPORTED_GROUP, IPP_TAG_KEYWORD,\n\t           \"compression\", NULL, attr->values[0].string.text);\n      return;\n    }\n  }\n\n /*\n  * Is it a format we support?\n  */\n\n  if ((format = ippFindAttribute(con->request, \"document-format\",\n                                 IPP_TAG_MIMETYPE)) != NULL)\n  {\n    if (sscanf(format->values[0].string.text, \"%15[^/]/%255[^;]\",\n               super, type) != 2)\n    {\n      send_ipp_status(con, IPP_BAD_REQUEST,\n                      _(\"Bad 'document-format' value \\\"%s\\\".\"),\n\t\t      format->values[0].string.text);\n      return;\n    }\n\n    if ((strcmp(super, \"application\") || strcmp(type, \"octet-stream\")) &&\n\t!mimeType(MimeDatabase, super, type))\n    {\n      cupsdLogMessage(CUPSD_LOG_INFO,\n                      \"Hint: Do you have the raw file printing rules enabled?\");\n      send_ipp_status(con, IPP_DOCUMENT_FORMAT,\n                      _(\"Unsupported 'document-format' value \\\"%s\\\".\"),\n\t\t      format->values[0].string.text);\n      ippAddString(con->response, IPP_TAG_UNSUPPORTED_GROUP, IPP_TAG_MIMETYPE,\n                   \"document-format\", NULL, format->values[0].string.text);\n      return;\n    }\n  }\n\n /*\n  * Is the job-name valid?\n  */\n\n  if ((name = ippFindAttribute(con->request, \"job-name\", IPP_TAG_ZERO)) != NULL)\n  {\n    int bad_name = 0;\t\t\t/* Is the job-name value bad? */\n\n    if ((name->value_tag != IPP_TAG_NAME && name->value_tag != IPP_TAG_NAMELANG) ||\n        name->num_values != 1)\n    {\n      bad_name = 1;\n    }\n    else\n    {\n     /*\n      * Validate that job-name conforms to RFC 5198 (Network Unicode) and\n      * IPP Everywhere requirements for \"name\" values...\n      */\n\n      const unsigned char *nameptr;\t/* Pointer into \"job-name\" attribute */\n\n      for (nameptr = (unsigned char *)name->values[0].string.text;\n           *nameptr;\n           nameptr ++)\n      {\n        if (*nameptr < ' ' && *nameptr != '\\t')\n          break;\n        else if (*nameptr == 0x7f)\n          break;\n        else if ((*nameptr & 0xe0) == 0xc0)\n        {\n          if ((nameptr[1] & 0xc0) != 0x80)\n            break;\n\n          nameptr ++;\n        }\n        else if ((*nameptr & 0xf0) == 0xe0)\n        {\n          if ((nameptr[1] & 0xc0) != 0x80 ||\n              (nameptr[2] & 0xc0) != 0x80)\n\t    break;\n\n\t  nameptr += 2;\n\t}\n        else if ((*nameptr & 0xf8) == 0xf0)\n        {\n          if ((nameptr[1] & 0xc0) != 0x80 ||\n\t      (nameptr[2] & 0xc0) != 0x80 ||\n\t      (nameptr[3] & 0xc0) != 0x80)\n\t    break;\n\n\t  nameptr += 3;\n\t}\n        else if (*nameptr & 0x80)\n          break;\n      }\n\n      if (*nameptr)\n        bad_name = 1;\n    }\n\n    if (bad_name)\n    {\n      if (StrictConformance)\n      {\n\tsend_ipp_status(con, IPP_ATTRIBUTES,\n\t                _(\"Unsupported 'job-name' value.\"));\n\tippCopyAttribute(con->response, name, 0);\n\treturn;\n      }\n      else\n      {\n        cupsdLogMessage(CUPSD_LOG_WARN,\n                        \"Unsupported 'job-name' value, deleting from request.\");\n        ippDeleteAttribute(con->request, name);\n      }\n    }\n  }\n\n /*\n  * Is the destination valid?\n  */\n\n  if (!cupsdValidateDest(uri->values[0].string.text, &dtype, &printer))\n  {\n   /*\n    * Bad URI...\n    */\n\n    send_ipp_status(con, IPP_NOT_FOUND,\n                    _(\"The printer or class does not exist.\"));\n    return;\n  }\n\n /*\n  * Check policy...\n  */\n\n#ifdef HAVE_SSL\n  auth_info = ippFindAttribute(con->request, \"auth-info\", IPP_TAG_TEXT);\n#endif /* HAVE_SSL */\n\n  if ((status = cupsdCheckPolicy(printer->op_policy_ptr, con, NULL)) != HTTP_OK)\n  {\n    send_http_error(con, status, printer);\n    return;\n  }\n  else if (printer->num_auth_info_required == 1 &&\n           !strcmp(printer->auth_info_required[0], \"negotiate\") &&\n           !con->username[0])\n  {\n    send_http_error(con, HTTP_UNAUTHORIZED, printer);\n    return;\n  }\n#ifdef HAVE_SSL\n  else if (auth_info && !con->http->tls &&\n           !httpAddrLocalhost(con->http->hostaddr))\n  {\n   /*\n    * Require encryption of auth-info over non-local connections...\n    */\n\n    send_http_error(con, HTTP_UPGRADE_REQUIRED, printer);\n    return;\n  }\n#endif /* HAVE_SSL */\n\n /*\n  * Everything was ok, so return OK status...\n  */\n\n  con->response->request.status.status_code = IPP_OK;\n}\n\n\n/*\n * 'validate_name()' - Make sure the printer name only contains valid chars.\n */\n\nstatic int\t\t\t/* O - 0 if name is no good, 1 if good */\nvalidate_name(const char *name)\t/* I - Name to check */\n{\n  const char\t*ptr;\t\t/* Pointer into name */\n\n\n /*\n  * Scan the whole name...\n  */\n\n  for (ptr = name; *ptr; ptr ++)\n    if ((*ptr > 0 && *ptr <= ' ') || *ptr == 127 || *ptr == '/' || *ptr == '#')\n      return (0);\n\n /*\n  * All the characters are good; validate the length, too...\n  */\n\n  return ((ptr - name) < 128);\n}\n\n\n/*\n * 'validate_user()' - Validate the user for the request.\n */\n\nstatic int\t\t\t\t/* O - 1 if permitted, 0 otherwise */\nvalidate_user(cupsd_job_t    *job,\t/* I - Job */\n              cupsd_client_t *con,\t/* I - Client connection */\n              const char     *owner,\t/* I - Owner of job/resource */\n              char           *username,\t/* O - Authenticated username */\n\t      size_t         userlen)\t/* I - Length of username */\n{\n  cupsd_printer_t\t*printer;\t/* Printer for job */\n\n\n  cupsdLogMessage(CUPSD_LOG_DEBUG2, \"validate_user(job=%d, con=%d, owner=\\\"%s\\\", username=%p, userlen=\" CUPS_LLFMT \")\", job->id, con ? con->number : 0, owner ? owner : \"(null)\", username, CUPS_LLCAST userlen);\n\n /*\n  * Validate input...\n  */\n\n  if (!con || !owner || !username || userlen <= 0)\n    return (0);\n\n /*\n  * Get the best authenticated username that is available.\n  */\n\n  strlcpy(username, get_username(con), userlen);\n\n /*\n  * Check the username against the owner...\n  */\n\n  printer = cupsdFindDest(job->dest);\n\n  return (cupsdCheckPolicy(printer ? printer->op_policy_ptr : DefaultPolicyPtr,\n                           con, owner) == HTTP_OK);\n}\n"], "filenames": ["CHANGES.md", "scheduler/ipp.c"], "buggy_code_start_loc": [1, 1599], "buggy_code_end_loc": [10, 1619], "fixing_code_start_loc": [1, 1600], "fixing_code_end_loc": [11, 1626], "type": "CWE-20", "message": "The add_job function in scheduler/ipp.c in CUPS before 2.2.6, when D-Bus support is enabled, can be crashed by remote attackers by sending print jobs with an invalid username, related to a D-Bus notification.", "other": {"cve": {"id": "CVE-2017-18248", "sourceIdentifier": "cve@mitre.org", "published": "2018-03-26T17:29:00.207", "lastModified": "2018-07-13T01:29:00.997", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The add_job function in scheduler/ipp.c in CUPS before 2.2.6, when D-Bus support is enabled, can be crashed by remote attackers by sending print jobs with an invalid username, related to a D-Bus notification."}, {"lang": "es", "value": "La funci\u00f3n add_job en scheduler/ipp.c en CUPS, en versiones anteriores a la 2.2.6, cuando un soporte D-Bus est\u00e1 habilitado, podr\u00eda experimentar un cierre inesperado llevado a cabo por atacantes remotos mediante el env\u00edo de tareas de impresi\u00f3n con un nombre de usuario no v\u00e1lido. Esto est\u00e1 relacionado con una notificaci\u00f3n D-Bus."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.6, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:S/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 3.5}, "baseSeverity": "LOW", "exploitabilityScore": 6.8, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:apple:cups:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.2.6", "matchCriteriaId": "6A17CA65-4B96-400E-B3EE-EA8D32F0AB63"}]}]}], "references": [{"url": "https://github.com/apple/cups/commit/49fa4983f25b64ec29d548ffa3b9782426007df3", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/apple/cups/issues/5143", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://github.com/apple/cups/releases/tag/v2.2.6", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2018/05/msg00018.html", "source": "cve@mitre.org"}, {"url": "https://lists.debian.org/debian-lts-announce/2018/07/msg00003.html", "source": "cve@mitre.org"}, {"url": "https://security.cucumberlinux.com/security/details.php?id=346", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3713-1/", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/apple/cups/commit/49fa4983f25b64ec29d548ffa3b9782426007df3"}}