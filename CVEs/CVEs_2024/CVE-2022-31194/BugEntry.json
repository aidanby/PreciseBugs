{"buggy_code": ["/**\n * The contents of this file are subject to the license and copyright\n * detailed in the LICENSE and NOTICE files at the root of the source\n * tree and available online at\n *\n * http://www.dspace.org/license/\n */\npackage org.dspace.app.webui.servlet;\n\nimport java.io.BufferedInputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.sql.SQLException;\nimport java.util.Enumeration;\nimport java.util.UUID;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\nimport org.apache.commons.fileupload.FileUploadBase.FileSizeLimitExceededException;\nimport org.apache.commons.lang.StringUtils;\nimport org.apache.log4j.Logger;\nimport org.dspace.app.util.SubmissionInfo;\nimport org.dspace.app.util.SubmissionStepConfig;\nimport org.dspace.app.webui.submit.JSPStepManager;\nimport org.dspace.app.webui.util.FileUploadRequest;\nimport org.dspace.app.webui.util.JSONUploadResponse;\nimport org.dspace.app.webui.util.JSPManager;\nimport org.dspace.app.webui.util.UIUtil;\nimport org.dspace.authorize.AuthorizeException;\nimport org.dspace.content.WorkspaceItem;\nimport org.dspace.content.factory.ContentServiceFactory;\nimport org.dspace.content.service.BitstreamService;\nimport org.dspace.content.service.BundleService;\nimport org.dspace.content.service.WorkspaceItemService;\nimport org.dspace.core.ConfigurationManager;\nimport org.dspace.core.Context;\nimport org.dspace.core.LogManager;\nimport org.dspace.submit.AbstractProcessingStep;\nimport org.dspace.submit.step.UploadStep;\nimport org.dspace.workflow.WorkflowItem;\nimport org.dspace.workflow.WorkflowItemService;\nimport org.dspace.workflowbasic.factory.BasicWorkflowServiceFactory;\n\nimport com.google.gson.Gson;\n\n/**\n * Submission Manager servlet for DSpace. Handles the initial submission of\n * items, as well as the editing of items further down the line.\n * <p>\n * Whenever the submit servlet receives a GET request, this is taken to indicate\n * the start of a fresh new submission, where no collection has been selected,\n * and the submission process is started from scratch.\n * <p>\n * All other interactions happen via POSTs. Part of the post will normally be a\n * (hidden) \"step\" parameter, which will correspond to the form that the user\n * has just filled out. If this is absent, step 0 (select collection) is\n * assumed, meaning that it's simple to place \"Submit to this collection\"\n * buttons on collection home pages.\n * <p>\n * According to the step number of the incoming form, the values posted from the\n * form are processed (using the process* methods), and the item updated as\n * appropriate. The servlet then forwards control of the request to the\n * appropriate JSP (from jsp/submit) to render the next stage of the process or\n * an error if appropriate. Each of these JSPs may require that attributes be\n * passed in. Check the comments at the top of a JSP to see which attributes are\n * needed. All submit-related forms require a properly initialised\n * SubmissionInfo object to be present in the the \"submission.info\" attribute.\n * This holds the core information relevant to the submission, e.g. the item,\n * personal workspace or workflow item, the submitting \"e-person\", and the\n * target collection.\n * <p>\n * When control of the request reaches a JSP, it is assumed that all checks,\n * interactions with the database and so on have been performed and that all\n * necessary information to render the form is in memory. e.g. The\n * SubmitFormInfo object passed in must be correctly filled out. Thus the JSPs\n * do no error or integrity checking; it is the servlet's responsibility to\n * ensure that everything is prepared. The servlet is fairly diligent about\n * ensuring integrity at each step.\n * <p>\n * Each step has an integer constant defined below. The main sequence of the\n * submission procedure always runs from 0 upwards, until SUBMISSION_COMPLETE.\n * Other, not-in-sequence steps (such as the cancellation screen and the\n * \"previous version ID verification\" screen) have numbers much higher than\n * SUBMISSION_COMPLETE. These conventions allow the progress bar component of\n * the submission forms to render the user's progress through the process.\n * \n * @see org.dspace.app.util.SubmissionInfo\n * @see org.dspace.app.util.SubmissionConfig\n * @see org.dspace.app.util.SubmissionStepConfig\n * @see org.dspace.app.webui.submit.JSPStepManager\n * \n * @author Tim Donohue\n * @version $Revision$\n */\npublic class SubmissionController extends DSpaceServlet\n{\n    // Steps in the submission process\n\n    /** Selection collection step */\n    public static final int SELECT_COLLECTION = 0;\n\n    /** First step after \"select collection\" */\n    public static final int FIRST_STEP = 1;\n    \n    /** For workflows, first step is step #0 (since Select Collection is already filtered out) */\n    public static final int WORKFLOW_FIRST_STEP = 0;\n    \n    /** path to the JSP shown once the submission is completed */\n    private static final String COMPLETE_JSP = \"/submit/complete.jsp\";\n    \n    private String tempDir = null;\n    \n    private static Object mutex = new Object();\n    \n    /** log4j logger */\n    private static Logger log = Logger\n            .getLogger(SubmissionController.class);\n\n    private static WorkspaceItemService workspaceItemService;\n    \n    private static BitstreamService bitstreamService;\n    \n    private static BundleService bundleService;\n    \n    private static WorkflowItemService workflowItemService;\n    \n    @Override\n    public void init() throws ServletException {\n    \tsuper.init();\n    \t// this is a sort of HACK as we are injecting static services using the singleton nature of the servlet...\n    \tworkspaceItemService = ContentServiceFactory.getInstance().getWorkspaceItemService();\n    \tbitstreamService = ContentServiceFactory.getInstance().getBitstreamService();\n    \tbundleService = ContentServiceFactory.getInstance().getBundleService();\n    \tworkflowItemService = BasicWorkflowServiceFactory.getInstance().getBasicWorkflowItemService();    \t\n    }\n    \n    protected void doDSGet(Context context, HttpServletRequest request,\n            HttpServletResponse response) throws ServletException, IOException,\n            SQLException, AuthorizeException\n    {\n        /*\n         * Possible GET parameters:\n         * \n         * resume= <workspace_item_id> - Resumes submitting the given workspace\n         * item\n         * \n         * workflow= <workflow_id> - Starts editing the given workflow item in\n         * workflow mode\n         * \n         * With no parameters, doDSGet() just calls doDSPost(), which continues\n         * the current submission (if one exists in the Request), or creates a\n         * new submission (if no existing submission can be found).\n         */\n\n        // try to get a workspace ID or workflow ID\n        String workspaceID = request.getParameter(\"resume\");\n        String workflowID = request.getParameter(\"workflow\");\n        String resumableFilename = request.getParameter(\"resumableFilename\");\n\n        // If resuming a workspace item\n        if (workspaceID != null)\n        {\n            try\n            {\n                // load the workspace item\n                WorkspaceItem wi = workspaceItemService.find(context, Integer\n                        .parseInt(workspaceID));\n\n                //load submission information\n                SubmissionInfo si = SubmissionInfo.load(request, wi);\n                \n                //TD: Special case - If a user is resuming a submission\n                //where the submission process now has less steps, then\n                //we will need to reset the stepReached in the database\n                //(Hopefully this will never happen, but just in case!)\n                if(getStepReached(si) >= si.getSubmissionConfig().getNumberOfSteps())\n                {\n                    //update Stage Reached to the last step in the Process\n                    int lastStep = si.getSubmissionConfig().getNumberOfSteps()-1;\n                    wi.setStageReached(lastStep);\n                    \n                    //flag that user is on last page of last step\n                    wi.setPageReached(AbstractProcessingStep.LAST_PAGE_REACHED);\n                    \n                    //commit all changes to database immediately\n                    workspaceItemService.update(context, wi);\n                    \n                    //update submission info\n                    si.setSubmissionItem(wi);\n                }\n                    \n                // start over at beginning of first step\n                setBeginningOfStep(request, true);\n                doStep(context, request, response, si, FIRST_STEP);\n            }\n            catch (NumberFormatException nfe)\n            {\n                log.warn(LogManager.getHeader(context, \"bad_workspace_id\",\n                        \"bad_id=\" + workspaceID));\n                JSPManager.showInvalidIDError(request, response, workspaceID,\n                        -1);\n            }\n        }\n        else if (workflowID != null) // if resuming a workflow item\n        {\n            try\n            {\n                // load the workflow item\n                WorkflowItem wi = workflowItemService.find(context, Integer\n                        .parseInt(workflowID));\n\n                //load submission information\n                SubmissionInfo si = SubmissionInfo.load(request, wi);\n                \n                // start over at beginning of first workflow step\n                setBeginningOfStep(request, true);\n                doStep(context, request, response, si, WORKFLOW_FIRST_STEP);\n            }\n            catch (NumberFormatException nfe)\n            {\n                log.warn(LogManager.getHeader(context, \"bad_workflow_id\",\n                        \"bad_id=\" + workflowID));\n                JSPManager\n                        .showInvalidIDError(request, response, workflowID, -1);\n            }\n        }\n        else if (!StringUtils.isEmpty(resumableFilename)) // if resumable.js asks whether a part of af file was received\n        {\n            if (request.getMethod().equals(\"GET\"))\n            {\n                DoGetResumable(request, response);\n            }\n        }\n        else\n        {\n            // otherwise, forward to doDSPost() to do usual processing\n            doDSPost(context, request, response);\n        }\n\n    }\n\n    protected void doDSPost(Context context, HttpServletRequest request,\n            HttpServletResponse response) throws ServletException, IOException,\n            SQLException, AuthorizeException\n    {\n    \t// Configuration of current step in Item Submission Process\n        SubmissionStepConfig currentStepConfig;\n        \n        //need to find out what type of form we are dealing with\n        String contentType = request.getContentType();\n\n        // if multipart form, we have to wrap the multipart request\n        // in order to be able to retrieve request parameters, etc.\n        if ((contentType != null)\n                && (contentType.indexOf(\"multipart/form-data\") != -1))\n        {\n            try\n            {\n                    request = wrapMultipartRequest(request);\n                    \n                    // check if the POST request was send by resumable.js\n                    String resumableFilename = request.getParameter(\"resumableFilename\");\n                    \n                    if (!StringUtils.isEmpty(resumableFilename))\n                    {\n                        log.debug(\"resumable Filename: '\" + resumableFilename + \"'.\");\n                        File completedFile = null;\n                        try\n                        {\n                            log.debug(\"Starting doPostResumable method.\");\n                            completedFile = doPostResumable(request);\n                        } catch(IOException e){\n                            // we were unable to receive the complete chunk => initialize reupload\n                            response.sendError(HttpServletResponse.SC_REQUESTED_RANGE_NOT_SATISFIABLE);\n                        }\n                        \n                        if (completedFile == null)\n                        {\n                            // if a part/chunk was uploaded, but the file is not completly uploaded yet\n                            log.debug(\"Got one file chunk, but the upload is not completed yet.\");\n                            return;\n                        }\n                        else\n                        {\n                            // We got the complete file. Assemble it and store\n                            // it in the repository.\n                            log.debug(\"Going to assemble file chunks.\");\n\n                            if (completedFile.length() > 0)\n                            {\n                                String fileName = completedFile.getName();\n                                String filePath = tempDir + File.separator + fileName;\n                                // Read the temporary file\n                                InputStream fileInputStream = \n                                        new BufferedInputStream(new FileInputStream(completedFile));\n                                \n                                // to safely store the file in the repository\n                                // we have to add it as a bitstream to the\n                                // appropriate item (or to be specific its\n                                // bundle). Instead of rewriting this code,\n                                // we should use the same code, that's used for\n                                // the \"old\" file upload (which is not using JS).\n                                SubmissionInfo si = getSubmissionInfo(context, request);\n                                UploadStep us = new UploadStep();\n                                request.setAttribute(fileName + \"-path\", filePath);\n                                request.setAttribute(fileName + \"-inputstream\", fileInputStream);\n                                request.setAttribute(fileName + \"-description\", request.getParameter(\"description\"));\n                                int uploadResult = us.processUploadFile(context, request, response, si);\n\n                                // cleanup our temporary file\n                                if (!completedFile.delete())\n                                {\n                                    log.error(\"Unable to delete temporary file \" + filePath);\n                                }\n\n                                // We already assembled the complete file.\n                                // In case of any error it won't help to\n                                // reupload the last chunk. That makes the error\n                                // handling realy easy:\n                                if (uploadResult != UploadStep.STATUS_COMPLETE)\n                                {\n                                    response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);\n                                    return;\n                                }\n                            }\n                            return;\n                        }\n                   }\n            }\n            catch (FileSizeLimitExceededException e)\n            {\n                log.warn(\"Upload exceeded upload.max\");\n                if (ConfigurationManager.getBooleanProperty(\"webui.submit.upload.progressbar\", true))\n                {\n                    Gson gson = new Gson();\n                    // old browser need to see this response as html to work            \n                    response.setContentType(\"text/html\");\n                    JSONUploadResponse jsonResponse = new JSONUploadResponse();\n                    jsonResponse.addUploadFileSizeLimitExceeded(\n                            e.getActualSize(), e.getPermittedSize());\n                    response.getWriter().print(gson.toJson(jsonResponse));\n                    response.flushBuffer();                    \n                }\n                else\n                {\n                    JSPManager.showFileSizeLimitExceededError(request, response, e.getMessage(), e.getActualSize(), e.getPermittedSize());                    \n                }\n                return;\n            }\n            \n            //also, upload any files and save their contents to Request (for later processing by UploadStep)\n            uploadFiles(context, request);\n        }\n        \n        // Reload submission info from request parameters\n        SubmissionInfo subInfo = getSubmissionInfo(context, request);\n\n        // a submission info object is necessary to continue\n        if (subInfo == null)\n        {\n            // Work around for problem where people select \"is a thesis\", see\n            // the error page, and then use their \"back\" button thinking they\n            // can start another submission - it's been removed so the ID in the\n            // form is invalid. If we detect the \"removed_thesis\" attribute we\n            // display a friendly message instead of an integrity error.\n            if (request.getSession().getAttribute(\"removed_thesis\") != null)\n            {\n                request.getSession().removeAttribute(\"removed_thesis\");\n                JSPManager.showJSP(request, response,\n                        \"/submit/thesis-removed-workaround.jsp\");\n\n                return;\n            }\n            else\n            {\n                // If the submission info was invalid, throw an integrity error\n                log.warn(LogManager.getHeader(context, \"integrity_error\",\n                        UIUtil.getRequestLogInfo(request)));\n                JSPManager.showIntegrityError(request, response);\n                return;\n            }\n        }\n\n        // First, check for a click on \"Cancel/Save\" button.\n        if (UIUtil.getSubmitButton(request, \"\").equals(AbstractProcessingStep.CANCEL_BUTTON))\n        {\n        \t// Get the current step\n            currentStepConfig = getCurrentStepConfig(request, subInfo);\n            \n        \t// forward user to JSP which will confirm \n            // the cancel/save request.\n            doCancelOrSave(context, request, response, subInfo,\n                    currentStepConfig);\n        }\n        // Special case - no InProgressSubmission yet\n        // If no submission, we assume we will be going\n        // to the \"select collection\" step.\n        else if (subInfo.getSubmissionItem() == null)\n        {\n            // we have just started this submission\n            // (or we have just resumed a saved submission)\n\n            // do the \"Select Collection\" step\n            doStep(context, request, response, subInfo, SELECT_COLLECTION);\n        }\n        else\n        // otherwise, figure out the next Step to call!\n        {\n            // Get the current step\n            currentStepConfig = getCurrentStepConfig(request, subInfo);\n\n            //if user already confirmed the cancel/save request\n            if (UIUtil.getBoolParameter(request, \"cancellation\"))\n            {\n                // user came from the cancel/save page, \n                // so we need to process that page before proceeding\n                processCancelOrSave(context, request, response, subInfo, currentStepConfig);\n            }\n            //check for click on \"<- Previous\" button\n            else if (UIUtil.getSubmitButton(request, \"\").startsWith(\n                    AbstractProcessingStep.PREVIOUS_BUTTON))\n            {\n                // return to the previous step\n                doPreviousStep(context, request, response, subInfo, currentStepConfig);\n            }\n            //check for click on Progress Bar\n            else if (UIUtil.getSubmitButton(request, \"\").startsWith(\n                    AbstractProcessingStep.PROGRESS_BAR_PREFIX))\n            {\n                // jumping to a particular step/page\n                doStepJump(context, request, response, subInfo, currentStepConfig);\n            }\n            else\n            {\n                // by default, load step class to start \n                // or continue its processing\n                doStep(context, request, response, subInfo, currentStepConfig.getStepNumber());\n            }\n        }\n    }\n\n    /**\n     * Forward processing to the specified step.\n     * \n     * @param context\n     *            DSpace context\n     * @param request\n     *            the request object\n     * @param response\n     *            the response object\n     * @param subInfo\n     *            SubmissionInfo pertaining to this submission\n     * @param stepNumber\n     *            The number of the step to perform\n     */\n    private void doStep(Context context, HttpServletRequest request,\n            HttpServletResponse response, SubmissionInfo subInfo, int stepNumber)\n            throws ServletException, IOException, SQLException,\n            AuthorizeException\n    {\n    \tSubmissionStepConfig currentStepConfig = null;\n    \t\n        if (subInfo.getSubmissionConfig() != null)\n        {\n            // get step to perform\n            currentStepConfig = subInfo.getSubmissionConfig().getStep(stepNumber);\n        }\n        else\n        {\n            log.fatal(LogManager.getHeader(context, \"no_submission_process\",\n                    \"trying to load step=\" + stepNumber\n                            + \", but submission process is null\"));\n\n            JSPManager.showInternalError(request, response);\n        }\n\n        // if this is the furthest step the user has been to, save that info\n        if (!subInfo.isInWorkflow() && (currentStepConfig.getStepNumber() > getStepReached(subInfo)))\n        {\n            // update submission info\n            userHasReached(context, subInfo, currentStepConfig.getStepNumber());\n            \n            // flag that we just started this step (for JSPStepManager class)\n            setBeginningOfStep(request, true);\n        }\n       \n        // save current step to request attribute\n        saveCurrentStepConfig(request, currentStepConfig);\n\n        log.debug(\"Calling Step Class: '\"\n                + currentStepConfig.getProcessingClassName() + \"'\");\n\n        try\n        {\n            \n            JSPStepManager stepManager = JSPStepManager.loadStep(currentStepConfig);\n           \n            //tell the step class to do its processing\n            boolean stepFinished = stepManager.processStep(context, request, response, subInfo);\n            \n            //if this step is finished, continue to next step\n            if(stepFinished)\n            {\n                // If we finished up an upload, then we need to change\n                // the FileUploadRequest object back to a normal HTTPServletRequest\n                if(request instanceof FileUploadRequest)\n                {\n                    request = ((FileUploadRequest)request).getOriginalRequest();\n                }\n                \n                //retrieve any changes to the SubmissionInfo object\n                subInfo = getSubmissionInfo(context, request);\n                \n                //do the next step!\n                doNextStep(context, request, response, subInfo, currentStepConfig);\n            }\n            else\n            {\n                //commit & close context\n                context.complete();\n            }\n        }\n        catch (AuthorizeException ae)\n        {\n        \tthrow ae;\n        }\n        catch (Exception e)\n        {\n            log.error(\"Error loading step class'\" + currentStepConfig.getProcessingClassName() + \"':\", e);\n            JSPManager.showInternalError(request, response);\n        }\n\n    }\n\n    /**\n     * Forward processing to the next step.\n     * \n     * @param context\n     *            DSpace context\n     * @param request\n     *            the request object\n     * @param response\n     *            the response object\n     * @param subInfo\n     *            SubmissionInfo pertaining to this submission\n     */\n    private void doNextStep(Context context, HttpServletRequest request,\n            HttpServletResponse response, SubmissionInfo subInfo, SubmissionStepConfig currentStepConfig)\n            throws ServletException, IOException, SQLException,\n            AuthorizeException\n    {\n        // find current Step number\n        int currentStepNum;\n        if (currentStepConfig == null)\n        {\n            currentStepNum = -1;\n        }\n        else\n        {\n            currentStepNum = currentStepConfig.getStepNumber();\n        }\n\n        // as long as there are more steps after the current step,\n        // do the next step in the current Submission Process\n        if (subInfo.getSubmissionConfig().hasMoreSteps(currentStepNum))\n        {\n            // update the current step & do this step\n            currentStepNum++;\n            \n            //flag that we are going to the start of this next step (for JSPStepManager class)\n            setBeginningOfStep(request, true);\n\n            doStep(context, request, response, subInfo, currentStepNum);\n        }\n        else\n        {\n            //if this submission is in the workflow process, \n            //forward user back to relevant task page\n            if(subInfo.isInWorkflow())\n            {\n                request.setAttribute(\"workflow.item\", subInfo.getSubmissionItem());\n                JSPManager.showJSP(request, response,\n                        \"/mydspace/perform-task.jsp\");\n            }\n            else\n            {\n                // The Submission is COMPLETE!!\n               \n                // save our current Submission information into the Request object\n                saveSubmissionInfo(request, subInfo);\n    \n                // forward to completion JSP\n                showProgressAwareJSP(request, response, subInfo, COMPLETE_JSP);\n        \n            }\n        }\n    }\n\n    /**\n     * Forward processing to the previous step. This method is called if it is\n     * determined that the \"previous\" button was pressed.\n     * \n     * @param context\n     *            DSpace context\n     * @param request\n     *            the request object\n     * @param response\n     *            the response object\n     * @param subInfo\n     *            SubmissionInfo pertaining to this submission\n     */\n    private void doPreviousStep(Context context, HttpServletRequest request,\n            HttpServletResponse response, SubmissionInfo subInfo, SubmissionStepConfig currentStepConfig)\n            throws ServletException, IOException, SQLException,\n            AuthorizeException\n    {\n        int result = doSaveCurrentState(context, request, response, subInfo, currentStepConfig);\n        \n        // find current Step number\n        int currentStepNum;\n        if (currentStepConfig == null)\n        {\n            currentStepNum = -1;\n        }\n        else\n        {\n            currentStepNum = currentStepConfig.getStepNumber();\n        }\n\n        int currPage=AbstractProcessingStep.getCurrentPage(request);\n        double currStepAndPage = Double.parseDouble(currentStepNum+\".\"+currPage);\n        // default value if we are in workflow\n        double stepAndPageReached = -1;\n        \n        if (!subInfo.isInWorkflow())\n        {\n            stepAndPageReached = Double.parseDouble(getStepReached(subInfo)+\".\"+JSPStepManager.getPageReached(subInfo));\n        }\n        \n        if (result != AbstractProcessingStep.STATUS_COMPLETE && currStepAndPage != stepAndPageReached)\n        {\n            doStep(context, request, response, subInfo, currentStepNum);\n        }\n        \n        //Check to see if we are actually just going to a\n        //previous PAGE within the same step.\n        int currentPageNum = AbstractProcessingStep.getCurrentPage(request);\n        \n        boolean foundPrevious = false;\n        \n        //since there are pages before this one in this current step\n        //just go backwards one page.\n        if(currentPageNum > 1)\n        {\n            //decrease current page number\n            AbstractProcessingStep.setCurrentPage(request, currentPageNum-1);\n     \n            foundPrevious = true;\n            \n            //send user back to the beginning of same step!\n            //NOTE: the step should handle going back one page\n            // in its doPreProcessing() method\n            setBeginningOfStep(request, true);\n\n            doStep(context, request, response, subInfo, currentStepNum);\n        }\n        // Since we cannot go back one page, \n        // check if there is a step before this step. \n        // If so, go backwards one step\n        else if (currentStepNum > FIRST_STEP)\n        {\n            \n            currentStepConfig = getPreviousVisibleStep(request, subInfo);\n            \n            if(currentStepConfig != null)\n            {\n                currentStepNum = currentStepConfig.getStepNumber();\n                foundPrevious = true;\n            }\n                \n            if(foundPrevious)\n            {    \n                //flag to JSPStepManager that we are going backwards\n                //an entire step\n                request.setAttribute(\"step.backwards\", Boolean.TRUE);\n                \n                // flag that we are going back to the start of this step (for JSPStepManager class)\n                setBeginningOfStep(request, true);\n    \n                doStep(context, request, response, subInfo, currentStepNum);\n            }    \n        }\n        \n        //if there is no previous, visible step, throw an error!\n        if(!foundPrevious)\n        {\n            log.error(LogManager\n                    .getHeader(context, \"no_previous_visible_step\",\n                            \"Attempting to go to previous step for step=\"\n                                    + currentStepNum + \".\" +\n                                    \"NO PREVIOUS VISIBLE STEP OR PAGE FOUND!\"));\n\n            JSPManager.showIntegrityError(request, response);\n        }\n    }\n\n    /**\n     * Process a click on a button in the progress bar. This jumps to the step\n     * whose button was pressed.\n     * \n     * @param context\n     *            DSpace context object\n     * @param request\n     *            the request object\n     * @param response\n     *            the response object\n     * @param subInfo\n     *            SubmissionInfo pertaining to this submission\n     */\n    private void doStepJump(Context context, HttpServletRequest request,\n            HttpServletResponse response, SubmissionInfo subInfo, SubmissionStepConfig currentStepConfig)\n            throws ServletException, IOException, SQLException,\n            AuthorizeException\n    {\n        // Find the button that was pressed. It would start with\n        // \"submit_jump_\".\n        String buttonPressed = UIUtil.getSubmitButton(request, \"\");\n\n        int nextStep = -1; // next step to load\n        int nextPage = -1; // page within the nextStep to load\n\n        if (buttonPressed.startsWith(\"submit_jump_\"))\n        {\n            // Button on progress bar pressed\n            try\n            {\n                // get step & page info (in form: stepNum.pageNum) after\n                // \"submit_jump_\"\n                String stepAndPage = buttonPressed.substring(12);\n\n                // split into stepNum and pageNum\n                String[] fields = stepAndPage.split(\"\\\\.\"); // split on period\n                nextStep = Integer.parseInt(fields[0]);\n                nextPage = Integer.parseInt(fields[1]);\n            }\n            catch (NumberFormatException ne)\n            {\n                // mangled number\n                nextStep = -1;\n                nextPage = -1;\n            }\n\n            // Integrity check: make sure they aren't going\n            // forward or backward too far\n            if ((!subInfo.isInWorkflow() && nextStep < FIRST_STEP) ||\n                    (subInfo.isInWorkflow() && nextStep < WORKFLOW_FIRST_STEP))\n            {\n                nextStep = -1;\n                nextPage = -1;\n            }\n\n            // if trying to jump to a step you haven't been to yet\n            if (!subInfo.isInWorkflow() && (nextStep > getStepReached(subInfo)))\n            {\n                nextStep = -1;\n            }\n        }\n\n        if (nextStep == -1)\n        {\n            // Either no button pressed, or an illegal stage\n            // reached. UI doesn't allow this, so something's\n            // wrong if that happens.\n            log.warn(LogManager.getHeader(context, \"integrity_error\", UIUtil\n                    .getRequestLogInfo(request)));\n            JSPManager.showIntegrityError(request, response);\n        }\n        else\n        {\n            int result = doSaveCurrentState(context, request, response,\n                    subInfo, currentStepConfig);\n\n            // Now, if the request was a multi-part (file upload), we need to\n            // get the original request back out, as the wrapper causes problems\n            // further down the line.\n            if (request instanceof FileUploadRequest)\n            {\n                FileUploadRequest fur = (FileUploadRequest) request;\n                request = fur.getOriginalRequest();\n            }\n\n            int currStep = currentStepConfig.getStepNumber();\n            int currPage = AbstractProcessingStep.getCurrentPage(request);\n            double currStepAndPage = Double.parseDouble(currStep + \".\" + currPage);\n            // default value if we are in workflow\n            double stepAndPageReached = -1;\n            \n            if (!subInfo.isInWorkflow())\n            {\n                stepAndPageReached = Double.parseDouble(getStepReached(subInfo)+\".\"+JSPStepManager.getPageReached(subInfo));\n            }\n            \n            if (result != AbstractProcessingStep.STATUS_COMPLETE\n                    && currStepAndPage != stepAndPageReached)\n            {\n                doStep(context, request, response, subInfo, currStep);\n            }\n            else\n            {\n                // save page info to request (for the step to access)\n                AbstractProcessingStep.setCurrentPage(request, nextPage);\n\n                // flag that we are going back to the start of this step (for\n                // JSPStepManager class)\n                setBeginningOfStep(request, true);\n\n                log.debug(\"Jumping to Step \" + nextStep + \" and Page \"\n                        + nextPage);\n\n                // do the step (the step should take care of going to\n                // the specified page)\n                doStep(context, request, response, subInfo, nextStep);\n            }\n        }\n    }\n\n    /**\n     * Respond to the user clicking \"cancel/save\" \n     * from any of the steps.  This method first calls\n     * the \"doPostProcessing()\" method of the step, in \n     * order to ensure any inputs are saved.\n     * \n     * @param context\n     *            DSpace context\n     * @param request\n     *            current servlet request object\n     * @param response\n     *            current servlet response object\n     * @param subInfo\n     *            SubmissionInfo object\n     * @param stepConfig\n     *            config of step who's page the user clicked \"cancel\" on.\n     */\n    private void doCancelOrSave(Context context, HttpServletRequest request,\n            HttpServletResponse response, SubmissionInfo subInfo,\n            SubmissionStepConfig stepConfig) throws ServletException, IOException,\n            SQLException, AuthorizeException\n    {\n        // If this is a workflow item, we need to return the\n        // user to the \"perform task\" page\n        if (subInfo.isInWorkflow())\n        {\n            int result = doSaveCurrentState(context, request, response, subInfo, stepConfig);\n            \n            if (result == AbstractProcessingStep.STATUS_COMPLETE)\n            {\n                request.setAttribute(\"workflow.item\", subInfo.getSubmissionItem());\n                JSPManager.showJSP(request, response, \"/mydspace/perform-task.jsp\");                \n            }\n            else\n            {\n                int currStep=stepConfig.getStepNumber();\n                doStep(context, request, response, subInfo, currStep);\n            }\n        }\n        else\n        {\n            // if no submission has been started,\n            if (subInfo.getSubmissionItem() == null)\n            {\n                // forward them to the 'cancelled' page,\n                // since we haven't created an item yet.\n                JSPManager.showJSP(request, response,\n                        \"/submit/cancelled-removed.jsp\");\n            }\n            else\n            {\n                //tell the step class to do its processing (to save any inputs)\n                //but, send flag that this is a \"cancellation\"\n                setCancellationInProgress(request, true);\n                \n                int result = doSaveCurrentState(context, request, response, subInfo,\n                        stepConfig);\n                \n                int currStep=stepConfig.getStepNumber();\n                int currPage=AbstractProcessingStep.getCurrentPage(request);\n                double currStepAndPage = Float.parseFloat(currStep+\".\"+currPage);\n                double stepAndPageReached = Float.parseFloat(getStepReached(subInfo)+\".\"+JSPStepManager.getPageReached(subInfo));\n                \n                if (result != AbstractProcessingStep.STATUS_COMPLETE && currStepAndPage < stepAndPageReached){\n                    setReachedStepAndPage(context, subInfo, currStep, currPage);\n                }\n                \n                //commit & close context\n                context.complete();\n                \n                // save changes to submission info & step info for JSP\n                saveSubmissionInfo(request, subInfo);\n                saveCurrentStepConfig(request, stepConfig);\n\n                // forward to cancellation confirmation JSP\n                showProgressAwareJSP(request, response, subInfo,\n                        \"/submit/cancel.jsp\");\n            }\n        }\n    }\n\n    private int doSaveCurrentState(Context context,\n            HttpServletRequest request, HttpServletResponse response,\n            SubmissionInfo subInfo, SubmissionStepConfig stepConfig)\n            throws ServletException\n    {\n        int result = -1;\n        // As long as we're not uploading a file, go ahead and SAVE\n        // all of the user's inputs for later\n        try\n        {\n            // call post-processing on Step (to save any inputs from JSP)\n            log\n                    .debug(\"Cancel/Save or Jump/Previous Request: calling processing for Step: '\"\n                            + stepConfig.getProcessingClassName() + \"'\");\n\n            try\n            {\n                // load the step class (using the current class loader)\n                ClassLoader loader = this.getClass().getClassLoader();\n                Class stepClass = loader.loadClass(stepConfig\n                        .getProcessingClassName());\n\n                // load the JSPStepManager object for this step\n                AbstractProcessingStep step = (AbstractProcessingStep) stepClass\n                        .newInstance();\n\n                result = step.doProcessing(context, request, response, subInfo);\n            }\n            catch (Exception e)\n            {\n                log.error(\"Error loading step class'\"\n                        + stepConfig.getProcessingClassName() + \"':\", e);\n                JSPManager.showInternalError(request, response);\n            }\n        }\n        catch(Exception e)\n        {\n            throw new ServletException(e);\n        }\n        return result;\n    }\n\n    /**\n     * Process information from \"submission cancelled\" page.\n     * This saves the item if the user decided to \"cancel & save\",\n     * or removes the item if the user decided to \"cancel & remove\".\n     * \n     * @param context\n     *            current DSpace context\n     * @param request\n     *            current servlet request object\n     * @param response\n     *            current servlet response object\n     * @param subInfo\n     *            submission info object\n     */\n    private void processCancelOrSave(Context context,\n            HttpServletRequest request, HttpServletResponse response,\n            SubmissionInfo subInfo, SubmissionStepConfig currentStepConfig) throws ServletException, IOException,\n            SQLException, AuthorizeException\n    {\n        String buttonPressed = UIUtil.getSubmitButton(request, \"submit_back\");\n\n        if (buttonPressed.equals(\"submit_back\"))\n        {\n            // re-load current step at beginning\n            setBeginningOfStep(request, true);\n            doStep(context, request, response, subInfo, currentStepConfig\n                    .getStepNumber());\n        }\n        else if (buttonPressed.equals(\"submit_remove\"))\n        {\n            // User wants to cancel and remove\n            // Cancellation page only applies to workspace items\n            WorkspaceItem wi = (WorkspaceItem) subInfo.getSubmissionItem();\n\n            workspaceItemService.deleteAll(context, wi);\n\n            JSPManager.showJSP(request, response,\n                    \"/submit/cancelled-removed.jsp\");\n\n            context.complete();\n        }\n        else if (buttonPressed.equals(\"submit_keep\"))\n        {\n            // Save submission for later - just show message\n            JSPManager.showJSP(request, response, \"/submit/saved.jsp\");\n        }\n        else\n        {\n            doStepJump(context, request, response, subInfo, currentStepConfig);\n        }\n    }\n\n    // ****************************************************************\n    // ****************************************************************\n    // MISCELLANEOUS CONVENIENCE METHODS\n    // ****************************************************************\n    // ****************************************************************\n\n    /**\n     * Show a JSP after setting attributes needed by progress bar\n     * \n     * @param request\n     *            the request object\n     * @param response\n     *            the response object\n     * @param subInfo\n     *            the SubmissionInfo object\n     * @param jspPath\n     *            relative path to JSP\n     */\n    private static void showProgressAwareJSP(HttpServletRequest request,\n            HttpServletResponse response, SubmissionInfo subInfo, String jspPath)\n            throws ServletException, IOException\n    {\n        saveSubmissionInfo(request, subInfo);\n\n        JSPManager.showJSP(request, response, jspPath);\n    }\n\n    /**\n     * Reloads a filled-out submission info object from the parameters in the\n     * current request. If there is a problem, <code>null</code> is returned.\n     * \n     * @param context\n     *            DSpace context\n     * @param request\n     *            HTTP request\n     * \n     * @return filled-out submission info, or null\n     */\n    public static SubmissionInfo getSubmissionInfo(Context context,\n            HttpServletRequest request) throws SQLException, ServletException\n    {\n        SubmissionInfo info = null;\n        \n        // Is full Submission Info in Request Attribute?\n        if (request.getAttribute(\"submission.info\") != null)\n        {\n            // load from cache\n            info = (SubmissionInfo) request.getAttribute(\"submission.info\");\n        }\n        else\n        {\n            \n            \n            // Need to rebuild Submission Info from Request Parameters\n            if (request.getParameter(\"workflow_id\") != null)\n            {\n                int workflowID = UIUtil.getIntParameter(request, \"workflow_id\");\n                \n                info = SubmissionInfo.load(request, workflowItemService.find(context, workflowID));\n            }\n            else if(request.getParameter(\"workspace_item_id\") != null)\n            {\n                int workspaceID = UIUtil.getIntParameter(request,\n                        \"workspace_item_id\");\n                \n                info = SubmissionInfo.load(request, workspaceItemService.find(context, workspaceID));\n            }\n            else\n            {\n                //by default, initialize Submission Info with no item\n                info = SubmissionInfo.load(request, null);\n            }\n            \n            // We must have a submission object if after the first step,\n            // otherwise something is wrong!\n            if ((getStepReached(info) > FIRST_STEP)\n                    && (info.getSubmissionItem() == null))\n            {\n                log.warn(LogManager.getHeader(context,\n                        \"cannot_load_submission_info\",\n                        \"InProgressSubmission is null!\"));\n                return null;\n            }\n               \n\n            if (request.getParameter(\"bundle_id\") != null)\n            {\n                UUID bundleID = UIUtil.getUUIDParameter(request, \"bundle_id\");\n                info.setBundle(bundleService.find(context, bundleID));\n            }\n\n            if (request.getParameter(\"bitstream_id\") != null)\n            {\n                UUID bitstreamID = UIUtil.getUUIDParameter(request,\n                        \"bitstream_id\");\n                info.setBitstream(bitstreamService.find(context, bitstreamID));\n            }\n\n            // save to Request Attribute\n            saveSubmissionInfo(request, info);\n        }// end if unable to load SubInfo from Request Attribute\n\n        return info;\n    }\n\n    /**\n     * Saves the submission info object to the current request.\n     * \n     * @param request\n     *            HTTP request\n     * @param si\n     *            the current submission info\n     * \n     */\n    public static void saveSubmissionInfo(HttpServletRequest request,\n            SubmissionInfo si)\n    {\n        // save to request\n        request.setAttribute(\"submission.info\", si);\n    }\n\n    /**\n     * Get the configuration of the current step from parameters in the request, \n     * along with the current SubmissionInfo object. \n     * If there is a problem, <code>null</code> is returned.\n     * \n     * @param request\n     *            HTTP request\n     * @param si\n     *            The current SubmissionInfo object\n     * \n     * @return the current SubmissionStepConfig\n     */\n    public static SubmissionStepConfig getCurrentStepConfig(\n            HttpServletRequest request, SubmissionInfo si)\n    {\n        int stepNum = -1;\n        SubmissionStepConfig step = (SubmissionStepConfig) request\n                .getAttribute(\"step\");\n\n        if (step == null)\n        {\n            // try and get it as a parameter\n            stepNum = UIUtil.getIntParameter(request, \"step\");\n\n            // if something is wrong, return null\n            if (stepNum < 0 || si == null || si.getSubmissionConfig() == null)\n            {\n                return null;\n            }\n            else\n            {\n                return si.getSubmissionConfig().getStep(stepNum);\n            }\n        }\n        else\n        {\n            return step;\n        }\n    }\n\n    /**\n     * Saves the current step configuration into the request.\n     * \n     * @param request\n     *            HTTP request\n     * @param step\n     *            The current SubmissionStepConfig\n     */\n    public static void saveCurrentStepConfig(HttpServletRequest request,\n            SubmissionStepConfig step)\n    {\n        // save to request\n        request.setAttribute(\"step\", step);\n    }\n\n    /**\n     * Checks if the current step is also the first \"visibile\" step in the item submission\n     * process.\n     * \n     * @param request\n     *            HTTP request\n     * @param si\n     *            The current Submission Info\n     * \n     * @return whether or not the current step is the first step\n     */\n    public static boolean isFirstStep(HttpServletRequest request,\n            SubmissionInfo si)\n    {\n        SubmissionStepConfig step = getCurrentStepConfig(request, si);\n\n        return ((step != null) && (getPreviousVisibleStep(request, si) == null));\n    }\n    \n    /**\n     * Return the previous \"visibile\" step in the item submission\n     * process if any, <code>null</code> otherwise.\n     * \n     * @param request\n     *            HTTP request\n     * @param si\n     *            The current Submission Info\n     * \n     * @return the previous step in the item submission process if any\n     */\n    public static SubmissionStepConfig getPreviousVisibleStep(HttpServletRequest request,\n            SubmissionInfo si)\n    {\n        SubmissionStepConfig step = getCurrentStepConfig(request, si);\n\n        SubmissionStepConfig currentStepConfig, previousStep = null;\n\n        int currentStepNum = step.getStepNumber();\n        \n        //need to find a previous step that is VISIBLE to the user!\n        while(currentStepNum>FIRST_STEP)\n        {\n            // update the current step & do this previous step\n            currentStepNum--;\n        \n            //get previous step\n            currentStepConfig = si.getSubmissionConfig().getStep(currentStepNum);\n        \n            if(currentStepConfig.isVisible())\n            {\n                previousStep = currentStepConfig;\n                break;\n            }\n        }\n        return previousStep;\n    }\n\n    /**\n     * Get whether or not the current step has just begun. This helps determine\n     * if we've done any pre-processing yet. If the step is just started, we\n     * need to do pre-processing, otherwise we should be doing post-processing.\n     * If there is a problem, <code>false</code> is returned.\n     * \n     * @param request\n     *            HTTP request\n     * \n     * @return true if the step has just started (and JSP has not been loaded\n     *         for this step), false otherwise.\n     */\n    public static boolean isBeginningOfStep(HttpServletRequest request)\n    {\n        Boolean stepStart = (Boolean) request.getAttribute(\"step.start\");\n\n        if (stepStart != null)\n        {\n            return stepStart.booleanValue();\n        }\n        else\n        {\n            return false;\n        }\n    }\n\n    /**\n     * Get whether or not the current step has just begun. This helps determine\n     * if we've done any pre-processing yet. If the step is just started, we\n     * need to do pre-processing, otherwise we should be doing post-processing.\n     * If there is a problem, <code>false</code> is returned.\n     * \n     * @param request\n     *            HTTP request\n     * @param beginningOfStep\n     *            true if step just began\n     */\n    public static void setBeginningOfStep(HttpServletRequest request,\n            boolean beginningOfStep)\n    {\n        request.setAttribute(\"step.start\", Boolean.valueOf(beginningOfStep));\n    }\n\n    \n    /**\n     * Get whether or not a cancellation is in progress (i.e. the \n     * user clicked on the \"Cancel/Save\" button from any submission\n     * page).\n     * \n     * @param request\n     *            HTTP request\n     *            \n     * @return true if a cancellation is in progress\n     */\n    public static boolean isCancellationInProgress(HttpServletRequest request)\n    {\n        Boolean cancellation = (Boolean) request.getAttribute(\"submission.cancellation\");\n\n        if (cancellation != null)\n        {\n            return cancellation.booleanValue();\n        }\n        else\n        {\n            return false;\n        }\n    }\n    \n    /**\n     * Sets whether or not a cancellation is in progress (i.e. the \n     * user clicked on the \"Cancel/Save\" button from any submission\n     * page).\n     * \n     * @param request\n     *            HTTP request\n     * @param cancellationInProgress\n     *            true if cancellation is in progress\n     */\n    private static void setCancellationInProgress(HttpServletRequest request, boolean cancellationInProgress)\n    {\n        request.setAttribute(\"submission.cancellation\", Boolean.valueOf(cancellationInProgress));\n    }\n    \n    \n    /**\n     * Return the submission info as hidden parameters for an HTML form on a JSP\n     * page.\n     * \n     * @param context\n     *            DSpace context\n     * @param request\n     *            HTTP request\n     * @return HTML hidden parameters\n     */\n    public static String getSubmissionParameters(Context context,\n            HttpServletRequest request) throws SQLException, ServletException\n    {\n        SubmissionInfo si = getSubmissionInfo(context, request);\n\n        SubmissionStepConfig step = getCurrentStepConfig(request, si);\n\n        String info = \"\";\n\n        if ((si.getSubmissionItem() != null) && si.isInWorkflow())\n        {\n            info = info\n                    + \"<input type=\\\"hidden\\\" name=\\\"workflow_id\\\" value=\\\"\"\n                    + si.getSubmissionItem().getID() + \"\\\"/>\";\n        }\n        else if (si.getSubmissionItem() != null)\n        {\n            info = info\n                    + \"<input type=\\\"hidden\\\" name=\\\"workspace_item_id\\\" value=\\\"\"\n                    + si.getSubmissionItem().getID() + \"\\\"/>\";\n        }\n\n        if (si.getBundle() != null)\n        {\n            info = info + \"<input type=\\\"hidden\\\" name=\\\"bundle_id\\\" value=\\\"\"\n                    + si.getBundle().getID() + \"\\\"/>\";\n        }\n\n        if (si.getBitstream() != null)\n        {\n            info = info\n                    + \"<input type=\\\"hidden\\\" name=\\\"bitstream_id\\\" value=\\\"\"\n                    + si.getBitstream().getID() + \"\\\"/>\";\n        }\n\n        if (step != null)\n        {\n            info = info + \"<input type=\\\"hidden\\\" name=\\\"step\\\" value=\\\"\"\n                    + step.getStepNumber() + \"\\\"/>\";\n        }\n\n        // save the current page from the current Step Servlet\n        int page = AbstractProcessingStep.getCurrentPage(request);\n        info = info + \"<input type=\\\"hidden\\\" name=\\\"page\\\" value=\\\"\" + page\n                + \"\\\"/>\";\n\n        // save the current JSP name to a hidden variable\n        String jspDisplayed = JSPStepManager.getLastJSPDisplayed(request);\n        info = info + \"<input type=\\\"hidden\\\" name=\\\"jsp\\\" value=\\\"\"\n                   + jspDisplayed + \"\\\"/>\";\n\n        return info;\n    }\n\n   \n\n    /**\n     * Indicate the user has advanced to the given stage. This will only\n     * actually do anything when it's a user initially entering a submission. It\n     * will only increase the \"stage reached\" column - it will not \"set back\"\n     * where a user has reached. Whenever the \"stage reached\" column is\n     * increased, the \"page reached\" column is reset to 1, since you've now\n     * reached page #1 of the next stage.\n     * \n     * @param subInfo\n     *            the SubmissionInfo object pertaining to the current submission\n     * @param step\n     *            the step the user has just reached\n     */\n    private void userHasReached(Context c, SubmissionInfo subInfo, int step)\n            throws SQLException, AuthorizeException, IOException\n    {\n        if (!subInfo.isInWorkflow() && subInfo.getSubmissionItem() != null)\n        {\n            WorkspaceItem wi = (WorkspaceItem) subInfo.getSubmissionItem();\n\n            if (step > wi.getStageReached())\n            {\n                wi.setStageReached(step);\n                wi.setPageReached(1); // reset page reached back to 1 (since\n                                        // it's page 1 of the new step)\n                workspaceItemService.update(c, wi);\n            }\n        }\n    }\n    \n    /**\n    * Set a specific step and page as reached. \n    * It will also \"set back\" where a user has reached.\n    * \n    * @param subInfo\n     *            the SubmissionInfo object pertaining to the current submission\n    * @param step the step to set as reached, can be also a previous reached step\n    * @param page the page (within the step) to set as reached, can be also a previous reached page\n    */\n    private void setReachedStepAndPage(Context c, SubmissionInfo subInfo, int step,\n            int page) throws SQLException, AuthorizeException, IOException\n    {\n        if (!subInfo.isInWorkflow() && subInfo.getSubmissionItem() != null)\n        {\n            WorkspaceItem wi = (WorkspaceItem) subInfo.getSubmissionItem();\n\n            wi.setStageReached(step);\n            wi.setPageReached(page);\n            workspaceItemService.update(c, wi);\n        }\n    }\n\n    \n    /**\n     * Find out which step a user has reached in the submission process. If the\n     * submission is in the workflow process, this returns -1.\n     * \n     * @param subInfo\n     *            submission info object\n     * \n     * @return step reached\n     */\n    public static int getStepReached(SubmissionInfo subInfo)\n    {\n        if (subInfo == null || subInfo.isInWorkflow() || subInfo.getSubmissionItem() == null)\n        {\n            return -1;\n        }\n        else\n        {\n            WorkspaceItem wi = (WorkspaceItem) subInfo.getSubmissionItem();\n            int i = wi.getStageReached();\n\n            // Uninitialised workspace items give \"-1\" as the stage reached\n            // this is a special value used by the progress bar, so we change\n            // it to \"FIRST_STEP\"\n            if (i == -1)\n            {\n                i = FIRST_STEP;\n            }\n\n            return i;\n        }\n    }\n\n    \n    /**\n     * Wraps a multipart form request, so that its attributes and parameters can\n     * still be accessed as normal.\n     * \n     * @return wrapped multipart request object\n     * \n     * @throws ServletException\n     *             if there are no more pages in this step\n     */\n    private HttpServletRequest wrapMultipartRequest(HttpServletRequest request)\n            throws ServletException, FileSizeLimitExceededException\n    {\n        HttpServletRequest wrappedRequest;\n\n        try\n        {\n            // if not already wrapped\n            if (!Class.forName(\"org.dspace.app.webui.util.FileUploadRequest\")\n                    .isInstance(request))\n            {\n                // Wrap multipart request\n                wrappedRequest = new FileUploadRequest(request);\n\n                return (HttpServletRequest) wrappedRequest;\n            }\n            else\n            { // already wrapped\n                return request;\n            }\n        }\n        catch (FileSizeLimitExceededException e)\n        {\n            throw new FileSizeLimitExceededException(e.getMessage(),e.getActualSize(),e.getPermittedSize());\n        }\n        catch (Exception e)\n        {\n            throw new ServletException(e);\n        }\n    }\n    \n    \n    /**\n     * Upload any files found on the Request or in assembledFiles, and save them back as \n     * Request attributes, for further processing by the appropriate user interface.\n     * \n     * @param context\n     *            current DSpace context\n     * @param request\n     *            current servlet request object\n     */\n    public void uploadFiles(Context context, HttpServletRequest request)\n            throws ServletException\n    {\n        FileUploadRequest wrapper = null;\n        String filePath = null;\n        InputStream fileInputStream = null;\n\n        try\n        {\n            // if we already have a FileUploadRequest, use it\n            if (Class.forName(\"org.dspace.app.webui.util.FileUploadRequest\")\n                    .isInstance(request))\n            {\n                wrapper = (FileUploadRequest) request;\n            }\n            else\n            {\n                // Wrap multipart request to get the submission info\n                wrapper = new FileUploadRequest(request);\n            }\n            \n            log.debug(\"Did not recoginze resumable upload, falling back to \"\n                    + \"simple upload.\");\n            Enumeration fileParams = wrapper.getFileParameterNames();\n            while (fileParams.hasMoreElements()) \n            {\n                String fileName = (String) fileParams.nextElement();\n\n                File temp = wrapper.getFile(fileName);\n\n                //if file exists and has a size greater than zero\n                if (temp != null && temp.length() > 0) \n                {\n                    // Read the temp file into an inputstream\n                    fileInputStream = new BufferedInputStream(\n                            new FileInputStream(temp));\n\n                    filePath = wrapper.getFilesystemName(fileName);\n\n                    // cleanup our temp file\n                    if (!temp.delete()) \n                    {\n                        log.error(\"Unable to delete temporary file\");\n                    }\n\n                    //save this file's info to request (for UploadStep class)\n                    request.setAttribute(fileName + \"-path\", filePath);\n                    request.setAttribute(fileName + \"-inputstream\", fileInputStream);\n                    request.setAttribute(fileName + \"-description\", wrapper.getParameter(\"description\"));\n                }\n            }\n        }\n        catch (Exception e)\n        {\n            // Problem with uploading\n            log.warn(LogManager.getHeader(context, \"upload_error\", \"\"), e);\n            throw new ServletException(e);\n        }\n    }\n    \n    // Resumable.js uses HTTP Get to recognize whether a specific part/chunk of \n    // a file was uploaded already. This method handles those requests.\n    protected void DoGetResumable(HttpServletRequest request, HttpServletResponse response) \n        throws IOException\n    {\n        if (ConfigurationManager.getProperty(\"upload.temp.dir\") != null)\n        {\n            tempDir = ConfigurationManager.getProperty(\"upload.temp.dir\");\n        }\n        else\n        {\n            tempDir = System.getProperty(\"java.io.tmpdir\");\n        }\n\n        String resumableIdentifier = request.getParameter(\"resumableIdentifier\");\n        String resumableChunkNumber = request.getParameter(\"resumableChunkNumber\");\n        long resumableCurrentChunkSize = \n                Long.valueOf(request.getParameter(\"resumableCurrentChunkSize\"));\n\n        tempDir = tempDir + File.separator + resumableIdentifier;\n\n        File fileDir = new File(tempDir);\n\n        // create a new directory for each resumableIdentifier\n        if (!fileDir.exists()) {\n            fileDir.mkdir();\n        }\n        // use the String \"part\" and the chunkNumber as filename of a chunk\n        String chunkPath = tempDir + File.separator + \"part\" + resumableChunkNumber;\n\n        File chunkFile = new File(chunkPath);\n        // if the chunk was uploaded already, we send a status code of 200\n        if (chunkFile.exists()) {\n            if (chunkFile.length() == resumableCurrentChunkSize) {\n                response.setStatus(HttpServletResponse.SC_OK);\n                return;\n            }\n            // The chunk file does not have the expected size, delete it and \n            // pretend that it wasn't uploaded already.\n            chunkFile.delete();\n        }\n        // if we don't have the chunk send a http status code 404\n        response.sendError(HttpServletResponse.SC_NOT_FOUND);\n    }\n\n    // Resumable.js sends chunks of files using http post.\n    // If a chunk was the last missing one, we have to assemble the file and\n    // return it. If other chunks are missing, we just return null.\n    protected File doPostResumable(HttpServletRequest request)\n            throws FileSizeLimitExceededException, IOException, ServletException \n    {\n        File completedFile = null;\n        FileUploadRequest wrapper = null;\n        \n        if (ConfigurationManager.getProperty(\"upload.temp.dir\") != null)\n        {\n            tempDir = ConfigurationManager.getProperty(\"upload.temp.dir\");\n        }\n        else {\n            tempDir = System.getProperty(\"java.io.tmpdir\");\n        }\n        \n        try\n        {\n            // if we already have a FileUploadRequest, use it\n            if (Class.forName(\"org.dspace.app.webui.util.FileUploadRequest\").isInstance(request))\n            {\n                wrapper = (FileUploadRequest) request;\n            } \n            else // if not wrap the mulitpart request to get the submission info\n            {\n                wrapper = new FileUploadRequest(request);\n            }\n        }\n        catch (ClassNotFoundException ex)\n        {\n            // Cannot find a class that is part of the JSPUI?\n            log.fatal(\"Cannot find class org.dspace.app.webui.util.FileUploadRequest\");\n            throw new ServletException(\"Cannot find class org.dspace.app.webui.util.FileUploadRequest.\", ex);\n        }\n\n        String resumableIdentifier = wrapper.getParameter(\"resumableIdentifier\");\n        long resumableTotalSize = Long.valueOf(wrapper.getParameter(\"resumableTotalSize\"));\n        int resumableTotalChunks = Integer.valueOf(wrapper.getParameter(\"resumableTotalChunks\"));\n\n        String chunkDirPath = tempDir + File.separator + resumableIdentifier;\n        File chunkDirPathFile = new File(chunkDirPath);\n        boolean foundAll = true;\n        long currentSize = 0l;\n        \n        // check whether all chunks were received.\n        if(chunkDirPathFile.exists())\n        {\n            for (int p = 1; p <= resumableTotalChunks; p++) \n            {\n                File file = new File(chunkDirPath + File.separator + \"part\" + Integer.toString(p));\n\n                if (!file.exists()) \n                {\n                    foundAll = false;\n                    break;\n                }\n                currentSize += file.length();\n            }\n        }\n        \n        if (foundAll && currentSize >= resumableTotalSize) \n        {\n            try {\n                // assemble the file from it chunks.\n                File file = makeFileFromChunks(tempDir, chunkDirPathFile, wrapper);\n            \n                if (file != null) \n                {\n                    completedFile = file;\n                }\n            } catch (IOException ex) {\n                // if the assembling of a file results in an IOException a\n                // retransmission has to be triggered. Throw the IOException\n                // here and handle it above.\n                throw ex;\n            }\n        }\n\n        return completedFile;\n    }\n    \n    // assembles a file from it chunks\n    protected File makeFileFromChunks(String tmpDir, File chunkDirPath, HttpServletRequest request) \n            throws IOException\n    {\n        int resumableTotalChunks = Integer.valueOf(request.getParameter(\"resumableTotalChunks\"));\n        String resumableFilename = request.getParameter(\"resumableFilename\");\n        String chunkPath = chunkDirPath.getAbsolutePath() + File.separator + \"part\";\n        File destFile = null;\n\n        String destFilePath = tmpDir + File.separator + resumableFilename;\n        destFile = new File(destFilePath);\n        InputStream is = null;\n        OutputStream os = null;\n\n        try {\n            destFile.createNewFile();\n            os = new FileOutputStream(destFile);\n\n            for (int i = 1; i <= resumableTotalChunks; i++) \n            {\n                File fi = new File(chunkPath.concat(Integer.toString(i)));\n                try \n                {\n                    is = new FileInputStream(fi);\n\n                    byte[] buffer = new byte[1024];\n\n                    int lenght;\n\n                    while ((lenght = is.read(buffer)) > 0) \n                    {\n                        os.write(buffer, 0, lenght);\n                    }\n                } \n                catch (IOException e) \n                {\n                    // try to delete destination file, as we got an exception while writing it.\n                    if(!destFile.delete())\n                    {\n                        log.warn(\"While writing an uploaded file an error occurred. \"\n                                + \"We were unable to delete the damaged file: \" \n                                + destFile.getAbsolutePath() + \".\");\n                    }\n                    // throw IOException to handle it in the calling method\n                    throw e;\n                }\n                finally {\n                    try\n                    {\n                        if (is != null)\n                        {\n                            is.close();\n                        }\n                    }\n                    catch (IOException ex)\n                    {\n                        // nothing to do here\n                    }\n                }\n            }\n        } \n        finally \n        {\n            try \n            {\n                if (os != null) \n                {\n                    os.close();\n                }\n            } \n            catch (IOException ex) \n            {\n                // nothing to do here\n            }\n            if (!deleteDirectory(chunkDirPath)) \n            {\n                log.warn(\"Coudln't delete temporary upload path \" + chunkDirPath.getAbsolutePath() + \", ignoring it.\");\n            }\n        }\n        return destFile;\n    }\n\n    public boolean deleteDirectory(File path) \n    {\n        if (path.exists()) \n        {\n            File[] files = path.listFiles();\n            for (int i = 0; i < files.length; i++) \n            {\n                if (files[i].isDirectory()) \n                {\n                    deleteDirectory(files[i]);\n                } \n                else \n                {\n                    files[i].delete();\n                }\n            }\n        }\n        \n        return (path.delete());\n    }\n\n}\n", "/**\n * The contents of this file are subject to the license and copyright\n * detailed in the LICENSE and NOTICE files at the root of the source\n * tree and available online at\n *\n * http://www.dspace.org/license/\n */\npackage org.dspace.app.webui.util;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.*;\n\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletRequestWrapper;\nimport javax.servlet.http.HttpSession;\n\nimport org.apache.commons.fileupload.FileItem;\nimport org.apache.commons.fileupload.FileUploadBase.FileSizeLimitExceededException;\nimport org.apache.commons.fileupload.FileUploadBase.IOFileUploadException;\nimport org.apache.commons.fileupload.servlet.ServletFileUpload;\nimport org.apache.commons.fileupload.disk.DiskFileItemFactory;\nimport org.apache.commons.lang.StringUtils;\nimport org.dspace.core.ConfigurationManager;\n\n/**\n * Based on the com.oreilly.servlet.MultipartWrapper object, this is an HTTP\n * request wrapper for multi-part (MIME) POSTs. It uses DSpace configuration\n * properties to determine the temporary directory to use and the maximum\n * allowable upload size.\n * \n * @author Robert Tansley\n * @version $Revision$\n */\npublic class FileUploadRequest extends HttpServletRequestWrapper\n{\n    public static final String FILE_UPLOAD_LISTNER = \"file-upload-listner\";\n    \n    private Map<String, String> parameters = new HashMap<String, String>();\n\n    private Map<String, FileItem> fileitems = new HashMap<String, FileItem>();\n\n    private List<String> filenames = new ArrayList<String>();\n\n    private String tempDir = null;\n\n    /** Original request */\n    private HttpServletRequest original = null;\n\n    /**\n     * Parse a multipart request and extracts the files\n     * \n     * @param req\n     *            the original request\n     */\n    public FileUploadRequest(HttpServletRequest req) throws IOException, FileSizeLimitExceededException\n    {\n        super(req);\n\n        original = req;\n\n        tempDir = (ConfigurationManager.getProperty(\"upload.temp.dir\") != null)\n            ? ConfigurationManager.getProperty(\"upload.temp.dir\") : System.getProperty(\"java.io.tmpdir\"); \n        long maxSize = ConfigurationManager.getLongProperty(\"upload.max\");\n\n        // Create a factory for disk-based file items\n        DiskFileItemFactory factory = new DiskFileItemFactory();\n        factory.setRepository(new File(tempDir));\n\n        // Create a new file upload handler\n        ServletFileUpload upload = new ServletFileUpload(factory);\n\n        HttpSession session = req.getSession();\n        \n        if (ConfigurationManager.getBooleanProperty(\"webui.submit.upload.progressbar\", true))\n        {\n            // set file upload progress listener\n            FileUploadListener listener = new FileUploadListener();\n    \n            session.setAttribute(FILE_UPLOAD_LISTNER, listener);\n    \n            // upload servlet allows to set upload listener\n            upload.setProgressListener(listener);\n        }\n        \n        try\n        {\n            upload.setSizeMax(maxSize);\n            List<FileItem> items = upload.parseRequest(req);\n            for (FileItem item : items)\n            {\n                if (item.isFormField())\n                {\n                    parameters.put(item.getFieldName(), item.getString(\"UTF-8\"));\n                }\n                else\n                {\n                    if (parameters.containsKey(\"resumableIdentifier\")) \n                    {\n                        String filename = getFilename(parameters.get(\"resumableFilename\"));\n                        if (!StringUtils.isEmpty(filename)) \n                        {\n                            String chunkDirPath = tempDir + File.separator + parameters.get(\"resumableIdentifier\");\n                            String chunkPath = chunkDirPath + File.separator + \"part\" + parameters.get(\"resumableChunkNumber\");\n                            File fileDir = new File(chunkDirPath);\n                            \n                            if(fileDir.exists())\n                            {\n                                item.write(new File(chunkPath));\n                            }\n                        }\n                    }\n                    else\n                    {\n                        parameters.put(item.getFieldName(), item.getName());\n                        fileitems.put(item.getFieldName(), item);\n                        filenames.add(item.getName());\n\n                        String filename = getFilename(item.getName());\n                        if (filename != null && !\"\".equals(filename))\n                        {\n                            item.write(new File(tempDir + File.separator\n                                            + filename));\n                        }\n                    }\n                }\n            }\n        }\n        catch(IOFileUploadException e){\n            if (!(e.getMessage().contains(\"Stream ended unexpectedly\")))\n            {\n                throw new IOException(e.getMessage(), e);\n            }\n        }\n        catch (Exception e)\n        {\n            if(e.getMessage().contains(\"exceeds the configured maximum\"))\n            {\n                // ServletFileUpload is not throwing the correct error, so this is workaround\n                // the request was rejected because its size (11302) exceeds the configured maximum (536)\n                int startFirstParen = e.getMessage().indexOf(\"(\")+1;\n                int endFirstParen = e.getMessage().indexOf(\")\");\n                String uploadedSize = e.getMessage().substring(startFirstParen, endFirstParen).trim();\n                Long actualSize = Long.parseLong(uploadedSize);\n                throw new FileSizeLimitExceededException(e.getMessage(), actualSize, maxSize);\n            }\n            throw new IOException(e.getMessage(), e);\n        }\n        finally\n        {\n            if (ConfigurationManager.getBooleanProperty(\"webui.submit.upload.progressbar\", true))\n            {\n                session.removeAttribute(FILE_UPLOAD_LISTNER);\n            }\n        }\n    }\n\n    // Methods to replace HSR methods\n    public Enumeration getParameterNames()\n    {\n        Collection<String> c = parameters.keySet();\n        return Collections.enumeration(c);\n    }\n\n    public String getParameter(String name)\n    {\n        return parameters.get(name);\n    }\n\n    public String[] getParameterValues(String name)\n    {\n        return parameters.values().toArray(new String[parameters.values().size()]);\n    }\n\n    public Map getParameterMap()\n    {\n        Map<String, String[]> map = new HashMap<String, String[]>();\n        Enumeration eNum = getParameterNames();\n\n        while (eNum.hasMoreElements())\n        {\n            String name = (String) eNum.nextElement();\n            map.put(name, getParameterValues(name));\n        }\n\n        return map;\n    }\n\n    public String getFilesystemName(String name)\n    {\n        String filename = getFilename((fileitems.get(name))\n                .getName());\n        return tempDir + File.separator + filename;\n    }\n\n    public String getContentType(String name)\n    {\n        return (fileitems.get(name)).getContentType();\n    }\n\n    public File getFile(String name)\n    {\n        FileItem temp = fileitems.get(name);\n        String tempName = temp.getName();\n        String filename = getFilename(tempName);\n        if (\"\".equals(filename.trim()))\n        {\n            return null;\n        }\n        return new File(tempDir + File.separator + filename);\n    }\n\n    public Enumeration<String> getFileParameterNames()\n    {\n        Collection<String> c = fileitems.keySet();\n        return Collections.enumeration(c);\n    }\n    \n    public Enumeration<String> getFileNames()\n    {\n        return Collections.enumeration(filenames);\n    }\n\n    /**\n     * Get back the original HTTP request object\n     * \n     * @return the original HTTP request\n     */\n    public HttpServletRequest getOriginalRequest()\n    {\n        return original;\n    }\n\n    // Required due to the fact the contents of getName() may vary based on\n    // browser\n    private String getFilename(String filepath)\n    {\n        String filename = filepath.trim();\n\n        int index = filepath.lastIndexOf(File.separator);\n        if (index > -1)\n        {\n            filename = filepath.substring(index);\n        }\n        return filename;\n    }\n}\n"], "fixing_code": ["/**\n * The contents of this file are subject to the license and copyright\n * detailed in the LICENSE and NOTICE files at the root of the source\n * tree and available online at\n *\n * http://www.dspace.org/license/\n */\npackage org.dspace.app.webui.servlet;\n\nimport java.io.BufferedInputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.sql.SQLException;\nimport java.util.Enumeration;\nimport java.util.UUID;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\nimport org.apache.commons.fileupload.FileUploadBase.FileSizeLimitExceededException;\nimport org.apache.commons.lang.StringUtils;\nimport org.apache.log4j.Logger;\nimport org.dspace.app.util.SubmissionInfo;\nimport org.dspace.app.util.SubmissionStepConfig;\nimport org.dspace.app.webui.submit.JSPStepManager;\nimport org.dspace.app.webui.util.FileUploadRequest;\nimport org.dspace.app.webui.util.JSONUploadResponse;\nimport org.dspace.app.webui.util.JSPManager;\nimport org.dspace.app.webui.util.UIUtil;\nimport org.dspace.authorize.AuthorizeException;\nimport org.dspace.content.WorkspaceItem;\nimport org.dspace.content.factory.ContentServiceFactory;\nimport org.dspace.content.service.BitstreamService;\nimport org.dspace.content.service.BundleService;\nimport org.dspace.content.service.WorkspaceItemService;\nimport org.dspace.core.ConfigurationManager;\nimport org.dspace.core.Context;\nimport org.dspace.core.LogManager;\nimport org.dspace.submit.AbstractProcessingStep;\nimport org.dspace.submit.step.UploadStep;\nimport org.dspace.workflow.WorkflowItem;\nimport org.dspace.workflow.WorkflowItemService;\nimport org.dspace.workflowbasic.factory.BasicWorkflowServiceFactory;\n\nimport com.google.gson.Gson;\n\n/**\n * Submission Manager servlet for DSpace. Handles the initial submission of\n * items, as well as the editing of items further down the line.\n * <p>\n * Whenever the submit servlet receives a GET request, this is taken to indicate\n * the start of a fresh new submission, where no collection has been selected,\n * and the submission process is started from scratch.\n * <p>\n * All other interactions happen via POSTs. Part of the post will normally be a\n * (hidden) \"step\" parameter, which will correspond to the form that the user\n * has just filled out. If this is absent, step 0 (select collection) is\n * assumed, meaning that it's simple to place \"Submit to this collection\"\n * buttons on collection home pages.\n * <p>\n * According to the step number of the incoming form, the values posted from the\n * form are processed (using the process* methods), and the item updated as\n * appropriate. The servlet then forwards control of the request to the\n * appropriate JSP (from jsp/submit) to render the next stage of the process or\n * an error if appropriate. Each of these JSPs may require that attributes be\n * passed in. Check the comments at the top of a JSP to see which attributes are\n * needed. All submit-related forms require a properly initialised\n * SubmissionInfo object to be present in the the \"submission.info\" attribute.\n * This holds the core information relevant to the submission, e.g. the item,\n * personal workspace or workflow item, the submitting \"e-person\", and the\n * target collection.\n * <p>\n * When control of the request reaches a JSP, it is assumed that all checks,\n * interactions with the database and so on have been performed and that all\n * necessary information to render the form is in memory. e.g. The\n * SubmitFormInfo object passed in must be correctly filled out. Thus the JSPs\n * do no error or integrity checking; it is the servlet's responsibility to\n * ensure that everything is prepared. The servlet is fairly diligent about\n * ensuring integrity at each step.\n * <p>\n * Each step has an integer constant defined below. The main sequence of the\n * submission procedure always runs from 0 upwards, until SUBMISSION_COMPLETE.\n * Other, not-in-sequence steps (such as the cancellation screen and the\n * \"previous version ID verification\" screen) have numbers much higher than\n * SUBMISSION_COMPLETE. These conventions allow the progress bar component of\n * the submission forms to render the user's progress through the process.\n * \n * @see org.dspace.app.util.SubmissionInfo\n * @see org.dspace.app.util.SubmissionConfig\n * @see org.dspace.app.util.SubmissionStepConfig\n * @see org.dspace.app.webui.submit.JSPStepManager\n * \n * @author Tim Donohue\n * @version $Revision$\n */\npublic class SubmissionController extends DSpaceServlet\n{\n    // Steps in the submission process\n\n    /** Selection collection step */\n    public static final int SELECT_COLLECTION = 0;\n\n    /** First step after \"select collection\" */\n    public static final int FIRST_STEP = 1;\n    \n    /** For workflows, first step is step #0 (since Select Collection is already filtered out) */\n    public static final int WORKFLOW_FIRST_STEP = 0;\n    \n    /** path to the JSP shown once the submission is completed */\n    private static final String COMPLETE_JSP = \"/submit/complete.jsp\";\n    \n    private String tempDir = null;\n    \n    private static Object mutex = new Object();\n    \n    /** log4j logger */\n    private static Logger log = Logger\n            .getLogger(SubmissionController.class);\n\n    private static WorkspaceItemService workspaceItemService;\n    \n    private static BitstreamService bitstreamService;\n    \n    private static BundleService bundleService;\n    \n    private static WorkflowItemService workflowItemService;\n    \n    @Override\n    public void init() throws ServletException {\n    \tsuper.init();\n    \t// this is a sort of HACK as we are injecting static services using the singleton nature of the servlet...\n    \tworkspaceItemService = ContentServiceFactory.getInstance().getWorkspaceItemService();\n    \tbitstreamService = ContentServiceFactory.getInstance().getBitstreamService();\n    \tbundleService = ContentServiceFactory.getInstance().getBundleService();\n    \tworkflowItemService = BasicWorkflowServiceFactory.getInstance().getBasicWorkflowItemService();    \t\n    }\n    \n    protected void doDSGet(Context context, HttpServletRequest request,\n            HttpServletResponse response) throws ServletException, IOException,\n            SQLException, AuthorizeException\n    {\n        /*\n         * Possible GET parameters:\n         * \n         * resume= <workspace_item_id> - Resumes submitting the given workspace\n         * item\n         * \n         * workflow= <workflow_id> - Starts editing the given workflow item in\n         * workflow mode\n         * \n         * With no parameters, doDSGet() just calls doDSPost(), which continues\n         * the current submission (if one exists in the Request), or creates a\n         * new submission (if no existing submission can be found).\n         */\n\n        // try to get a workspace ID or workflow ID\n        String workspaceID = request.getParameter(\"resume\");\n        String workflowID = request.getParameter(\"workflow\");\n        String resumableFilename = request.getParameter(\"resumableFilename\");\n\n        // If resuming a workspace item\n        if (workspaceID != null)\n        {\n            try\n            {\n                // load the workspace item\n                WorkspaceItem wi = workspaceItemService.find(context, Integer\n                        .parseInt(workspaceID));\n\n                //load submission information\n                SubmissionInfo si = SubmissionInfo.load(request, wi);\n                \n                //TD: Special case - If a user is resuming a submission\n                //where the submission process now has less steps, then\n                //we will need to reset the stepReached in the database\n                //(Hopefully this will never happen, but just in case!)\n                if(getStepReached(si) >= si.getSubmissionConfig().getNumberOfSteps())\n                {\n                    //update Stage Reached to the last step in the Process\n                    int lastStep = si.getSubmissionConfig().getNumberOfSteps()-1;\n                    wi.setStageReached(lastStep);\n                    \n                    //flag that user is on last page of last step\n                    wi.setPageReached(AbstractProcessingStep.LAST_PAGE_REACHED);\n                    \n                    //commit all changes to database immediately\n                    workspaceItemService.update(context, wi);\n                    \n                    //update submission info\n                    si.setSubmissionItem(wi);\n                }\n                    \n                // start over at beginning of first step\n                setBeginningOfStep(request, true);\n                doStep(context, request, response, si, FIRST_STEP);\n            }\n            catch (NumberFormatException nfe)\n            {\n                log.warn(LogManager.getHeader(context, \"bad_workspace_id\",\n                        \"bad_id=\" + workspaceID));\n                JSPManager.showInvalidIDError(request, response, workspaceID,\n                        -1);\n            }\n        }\n        else if (workflowID != null) // if resuming a workflow item\n        {\n            try\n            {\n                // load the workflow item\n                WorkflowItem wi = workflowItemService.find(context, Integer\n                        .parseInt(workflowID));\n\n                //load submission information\n                SubmissionInfo si = SubmissionInfo.load(request, wi);\n                \n                // start over at beginning of first workflow step\n                setBeginningOfStep(request, true);\n                doStep(context, request, response, si, WORKFLOW_FIRST_STEP);\n            }\n            catch (NumberFormatException nfe)\n            {\n                log.warn(LogManager.getHeader(context, \"bad_workflow_id\",\n                        \"bad_id=\" + workflowID));\n                JSPManager\n                        .showInvalidIDError(request, response, workflowID, -1);\n            }\n        }\n        else if (!StringUtils.isEmpty(resumableFilename)) // if resumable.js asks whether a part of af file was received\n        {\n            if (request.getMethod().equals(\"GET\"))\n            {\n                DoGetResumable(context, request, response);\n            }\n        }\n        else\n        {\n            // otherwise, forward to doDSPost() to do usual processing\n            doDSPost(context, request, response);\n        }\n\n    }\n\n    protected void doDSPost(Context context, HttpServletRequest request,\n            HttpServletResponse response) throws ServletException, IOException,\n            SQLException, AuthorizeException\n    {\n    \t// Configuration of current step in Item Submission Process\n        SubmissionStepConfig currentStepConfig;\n        \n        //need to find out what type of form we are dealing with\n        String contentType = request.getContentType();\n\n        // if multipart form, we have to wrap the multipart request\n        // in order to be able to retrieve request parameters, etc.\n        if ((contentType != null)\n                && (contentType.indexOf(\"multipart/form-data\") != -1))\n        {\n            try\n            {\n                    request = wrapMultipartRequest(request);\n                    \n                    // check if the POST request was send by resumable.js\n                    String resumableFilename = request.getParameter(\"resumableFilename\");\n                    \n                    if (!StringUtils.isEmpty(resumableFilename))\n                    {\n                        log.debug(\"resumable Filename: '\" + resumableFilename + \"'.\");\n                        File completedFile = null;\n                        try\n                        {\n                            log.debug(\"Starting doPostResumable method.\");\n                            completedFile = doPostResumable(request);\n                        } catch(IOException e){\n                            // we were unable to receive the complete chunk => initialize reupload\n                            response.sendError(HttpServletResponse.SC_REQUESTED_RANGE_NOT_SATISFIABLE);\n                        }\n                        \n                        if (completedFile == null)\n                        {\n                            // if a part/chunk was uploaded, but the file is not completly uploaded yet\n                            log.debug(\"Got one file chunk, but the upload is not completed yet.\");\n                            return;\n                        }\n                        else\n                        {\n                            // We got the complete file. Assemble it and store\n                            // it in the repository.\n                            log.debug(\"Going to assemble file chunks.\");\n\n                            if (completedFile.length() > 0)\n                            {\n                                String fileName = completedFile.getName();\n                                String filePath = tempDir + File.separator + fileName;\n                                // Read the temporary file\n                                InputStream fileInputStream = \n                                        new BufferedInputStream(new FileInputStream(completedFile));\n                                \n                                // to safely store the file in the repository\n                                // we have to add it as a bitstream to the\n                                // appropriate item (or to be specific its\n                                // bundle). Instead of rewriting this code,\n                                // we should use the same code, that's used for\n                                // the \"old\" file upload (which is not using JS).\n                                SubmissionInfo si = getSubmissionInfo(context, request);\n                                UploadStep us = new UploadStep();\n                                request.setAttribute(fileName + \"-path\", filePath);\n                                request.setAttribute(fileName + \"-inputstream\", fileInputStream);\n                                request.setAttribute(fileName + \"-description\", request.getParameter(\"description\"));\n                                int uploadResult = us.processUploadFile(context, request, response, si);\n\n                                // cleanup our temporary file\n                                if (!completedFile.delete())\n                                {\n                                    log.error(\"Unable to delete temporary file \" + filePath);\n                                }\n\n                                // We already assembled the complete file.\n                                // In case of any error it won't help to\n                                // reupload the last chunk. That makes the error\n                                // handling realy easy:\n                                if (uploadResult != UploadStep.STATUS_COMPLETE)\n                                {\n                                    response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);\n                                    return;\n                                }\n                            }\n                            return;\n                        }\n                   }\n            }\n            catch (FileSizeLimitExceededException e)\n            {\n                log.warn(\"Upload exceeded upload.max\");\n                if (ConfigurationManager.getBooleanProperty(\"webui.submit.upload.progressbar\", true))\n                {\n                    Gson gson = new Gson();\n                    // old browser need to see this response as html to work            \n                    response.setContentType(\"text/html\");\n                    JSONUploadResponse jsonResponse = new JSONUploadResponse();\n                    jsonResponse.addUploadFileSizeLimitExceeded(\n                            e.getActualSize(), e.getPermittedSize());\n                    response.getWriter().print(gson.toJson(jsonResponse));\n                    response.flushBuffer();                    \n                }\n                else\n                {\n                    JSPManager.showFileSizeLimitExceededError(request, response, e.getMessage(), e.getActualSize(), e.getPermittedSize());                    \n                }\n                return;\n            }\n            \n            //also, upload any files and save their contents to Request (for later processing by UploadStep)\n            uploadFiles(context, request);\n        }\n        \n        // Reload submission info from request parameters\n        SubmissionInfo subInfo = getSubmissionInfo(context, request);\n\n        // a submission info object is necessary to continue\n        if (subInfo == null)\n        {\n            // Work around for problem where people select \"is a thesis\", see\n            // the error page, and then use their \"back\" button thinking they\n            // can start another submission - it's been removed so the ID in the\n            // form is invalid. If we detect the \"removed_thesis\" attribute we\n            // display a friendly message instead of an integrity error.\n            if (request.getSession().getAttribute(\"removed_thesis\") != null)\n            {\n                request.getSession().removeAttribute(\"removed_thesis\");\n                JSPManager.showJSP(request, response,\n                        \"/submit/thesis-removed-workaround.jsp\");\n\n                return;\n            }\n            else\n            {\n                // If the submission info was invalid, throw an integrity error\n                log.warn(LogManager.getHeader(context, \"integrity_error\",\n                        UIUtil.getRequestLogInfo(request)));\n                JSPManager.showIntegrityError(request, response);\n                return;\n            }\n        }\n\n        // First, check for a click on \"Cancel/Save\" button.\n        if (UIUtil.getSubmitButton(request, \"\").equals(AbstractProcessingStep.CANCEL_BUTTON))\n        {\n        \t// Get the current step\n            currentStepConfig = getCurrentStepConfig(request, subInfo);\n            \n        \t// forward user to JSP which will confirm \n            // the cancel/save request.\n            doCancelOrSave(context, request, response, subInfo,\n                    currentStepConfig);\n        }\n        // Special case - no InProgressSubmission yet\n        // If no submission, we assume we will be going\n        // to the \"select collection\" step.\n        else if (subInfo.getSubmissionItem() == null)\n        {\n            // we have just started this submission\n            // (or we have just resumed a saved submission)\n\n            // do the \"Select Collection\" step\n            doStep(context, request, response, subInfo, SELECT_COLLECTION);\n        }\n        else\n        // otherwise, figure out the next Step to call!\n        {\n            // Get the current step\n            currentStepConfig = getCurrentStepConfig(request, subInfo);\n\n            //if user already confirmed the cancel/save request\n            if (UIUtil.getBoolParameter(request, \"cancellation\"))\n            {\n                // user came from the cancel/save page, \n                // so we need to process that page before proceeding\n                processCancelOrSave(context, request, response, subInfo, currentStepConfig);\n            }\n            //check for click on \"<- Previous\" button\n            else if (UIUtil.getSubmitButton(request, \"\").startsWith(\n                    AbstractProcessingStep.PREVIOUS_BUTTON))\n            {\n                // return to the previous step\n                doPreviousStep(context, request, response, subInfo, currentStepConfig);\n            }\n            //check for click on Progress Bar\n            else if (UIUtil.getSubmitButton(request, \"\").startsWith(\n                    AbstractProcessingStep.PROGRESS_BAR_PREFIX))\n            {\n                // jumping to a particular step/page\n                doStepJump(context, request, response, subInfo, currentStepConfig);\n            }\n            else\n            {\n                // by default, load step class to start \n                // or continue its processing\n                doStep(context, request, response, subInfo, currentStepConfig.getStepNumber());\n            }\n        }\n    }\n\n    /**\n     * Forward processing to the specified step.\n     * \n     * @param context\n     *            DSpace context\n     * @param request\n     *            the request object\n     * @param response\n     *            the response object\n     * @param subInfo\n     *            SubmissionInfo pertaining to this submission\n     * @param stepNumber\n     *            The number of the step to perform\n     */\n    private void doStep(Context context, HttpServletRequest request,\n            HttpServletResponse response, SubmissionInfo subInfo, int stepNumber)\n            throws ServletException, IOException, SQLException,\n            AuthorizeException\n    {\n    \tSubmissionStepConfig currentStepConfig = null;\n    \t\n        if (subInfo.getSubmissionConfig() != null)\n        {\n            // get step to perform\n            currentStepConfig = subInfo.getSubmissionConfig().getStep(stepNumber);\n        }\n        else\n        {\n            log.fatal(LogManager.getHeader(context, \"no_submission_process\",\n                    \"trying to load step=\" + stepNumber\n                            + \", but submission process is null\"));\n\n            JSPManager.showInternalError(request, response);\n        }\n\n        // if this is the furthest step the user has been to, save that info\n        if (!subInfo.isInWorkflow() && (currentStepConfig.getStepNumber() > getStepReached(subInfo)))\n        {\n            // update submission info\n            userHasReached(context, subInfo, currentStepConfig.getStepNumber());\n            \n            // flag that we just started this step (for JSPStepManager class)\n            setBeginningOfStep(request, true);\n        }\n       \n        // save current step to request attribute\n        saveCurrentStepConfig(request, currentStepConfig);\n\n        log.debug(\"Calling Step Class: '\"\n                + currentStepConfig.getProcessingClassName() + \"'\");\n\n        try\n        {\n            \n            JSPStepManager stepManager = JSPStepManager.loadStep(currentStepConfig);\n           \n            //tell the step class to do its processing\n            boolean stepFinished = stepManager.processStep(context, request, response, subInfo);\n            \n            //if this step is finished, continue to next step\n            if(stepFinished)\n            {\n                // If we finished up an upload, then we need to change\n                // the FileUploadRequest object back to a normal HTTPServletRequest\n                if(request instanceof FileUploadRequest)\n                {\n                    request = ((FileUploadRequest)request).getOriginalRequest();\n                }\n                \n                //retrieve any changes to the SubmissionInfo object\n                subInfo = getSubmissionInfo(context, request);\n                \n                //do the next step!\n                doNextStep(context, request, response, subInfo, currentStepConfig);\n            }\n            else\n            {\n                //commit & close context\n                context.complete();\n            }\n        }\n        catch (AuthorizeException ae)\n        {\n        \tthrow ae;\n        }\n        catch (Exception e)\n        {\n            log.error(\"Error loading step class'\" + currentStepConfig.getProcessingClassName() + \"':\", e);\n            JSPManager.showInternalError(request, response);\n        }\n\n    }\n\n    /**\n     * Forward processing to the next step.\n     * \n     * @param context\n     *            DSpace context\n     * @param request\n     *            the request object\n     * @param response\n     *            the response object\n     * @param subInfo\n     *            SubmissionInfo pertaining to this submission\n     */\n    private void doNextStep(Context context, HttpServletRequest request,\n            HttpServletResponse response, SubmissionInfo subInfo, SubmissionStepConfig currentStepConfig)\n            throws ServletException, IOException, SQLException,\n            AuthorizeException\n    {\n        // find current Step number\n        int currentStepNum;\n        if (currentStepConfig == null)\n        {\n            currentStepNum = -1;\n        }\n        else\n        {\n            currentStepNum = currentStepConfig.getStepNumber();\n        }\n\n        // as long as there are more steps after the current step,\n        // do the next step in the current Submission Process\n        if (subInfo.getSubmissionConfig().hasMoreSteps(currentStepNum))\n        {\n            // update the current step & do this step\n            currentStepNum++;\n            \n            //flag that we are going to the start of this next step (for JSPStepManager class)\n            setBeginningOfStep(request, true);\n\n            doStep(context, request, response, subInfo, currentStepNum);\n        }\n        else\n        {\n            //if this submission is in the workflow process, \n            //forward user back to relevant task page\n            if(subInfo.isInWorkflow())\n            {\n                request.setAttribute(\"workflow.item\", subInfo.getSubmissionItem());\n                JSPManager.showJSP(request, response,\n                        \"/mydspace/perform-task.jsp\");\n            }\n            else\n            {\n                // The Submission is COMPLETE!!\n               \n                // save our current Submission information into the Request object\n                saveSubmissionInfo(request, subInfo);\n    \n                // forward to completion JSP\n                showProgressAwareJSP(request, response, subInfo, COMPLETE_JSP);\n        \n            }\n        }\n    }\n\n    /**\n     * Forward processing to the previous step. This method is called if it is\n     * determined that the \"previous\" button was pressed.\n     * \n     * @param context\n     *            DSpace context\n     * @param request\n     *            the request object\n     * @param response\n     *            the response object\n     * @param subInfo\n     *            SubmissionInfo pertaining to this submission\n     */\n    private void doPreviousStep(Context context, HttpServletRequest request,\n            HttpServletResponse response, SubmissionInfo subInfo, SubmissionStepConfig currentStepConfig)\n            throws ServletException, IOException, SQLException,\n            AuthorizeException\n    {\n        int result = doSaveCurrentState(context, request, response, subInfo, currentStepConfig);\n        \n        // find current Step number\n        int currentStepNum;\n        if (currentStepConfig == null)\n        {\n            currentStepNum = -1;\n        }\n        else\n        {\n            currentStepNum = currentStepConfig.getStepNumber();\n        }\n\n        int currPage=AbstractProcessingStep.getCurrentPage(request);\n        double currStepAndPage = Double.parseDouble(currentStepNum+\".\"+currPage);\n        // default value if we are in workflow\n        double stepAndPageReached = -1;\n        \n        if (!subInfo.isInWorkflow())\n        {\n            stepAndPageReached = Double.parseDouble(getStepReached(subInfo)+\".\"+JSPStepManager.getPageReached(subInfo));\n        }\n        \n        if (result != AbstractProcessingStep.STATUS_COMPLETE && currStepAndPage != stepAndPageReached)\n        {\n            doStep(context, request, response, subInfo, currentStepNum);\n        }\n        \n        //Check to see if we are actually just going to a\n        //previous PAGE within the same step.\n        int currentPageNum = AbstractProcessingStep.getCurrentPage(request);\n        \n        boolean foundPrevious = false;\n        \n        //since there are pages before this one in this current step\n        //just go backwards one page.\n        if(currentPageNum > 1)\n        {\n            //decrease current page number\n            AbstractProcessingStep.setCurrentPage(request, currentPageNum-1);\n     \n            foundPrevious = true;\n            \n            //send user back to the beginning of same step!\n            //NOTE: the step should handle going back one page\n            // in its doPreProcessing() method\n            setBeginningOfStep(request, true);\n\n            doStep(context, request, response, subInfo, currentStepNum);\n        }\n        // Since we cannot go back one page, \n        // check if there is a step before this step. \n        // If so, go backwards one step\n        else if (currentStepNum > FIRST_STEP)\n        {\n            \n            currentStepConfig = getPreviousVisibleStep(request, subInfo);\n            \n            if(currentStepConfig != null)\n            {\n                currentStepNum = currentStepConfig.getStepNumber();\n                foundPrevious = true;\n            }\n                \n            if(foundPrevious)\n            {    \n                //flag to JSPStepManager that we are going backwards\n                //an entire step\n                request.setAttribute(\"step.backwards\", Boolean.TRUE);\n                \n                // flag that we are going back to the start of this step (for JSPStepManager class)\n                setBeginningOfStep(request, true);\n    \n                doStep(context, request, response, subInfo, currentStepNum);\n            }    \n        }\n        \n        //if there is no previous, visible step, throw an error!\n        if(!foundPrevious)\n        {\n            log.error(LogManager\n                    .getHeader(context, \"no_previous_visible_step\",\n                            \"Attempting to go to previous step for step=\"\n                                    + currentStepNum + \".\" +\n                                    \"NO PREVIOUS VISIBLE STEP OR PAGE FOUND!\"));\n\n            JSPManager.showIntegrityError(request, response);\n        }\n    }\n\n    /**\n     * Process a click on a button in the progress bar. This jumps to the step\n     * whose button was pressed.\n     * \n     * @param context\n     *            DSpace context object\n     * @param request\n     *            the request object\n     * @param response\n     *            the response object\n     * @param subInfo\n     *            SubmissionInfo pertaining to this submission\n     */\n    private void doStepJump(Context context, HttpServletRequest request,\n            HttpServletResponse response, SubmissionInfo subInfo, SubmissionStepConfig currentStepConfig)\n            throws ServletException, IOException, SQLException,\n            AuthorizeException\n    {\n        // Find the button that was pressed. It would start with\n        // \"submit_jump_\".\n        String buttonPressed = UIUtil.getSubmitButton(request, \"\");\n\n        int nextStep = -1; // next step to load\n        int nextPage = -1; // page within the nextStep to load\n\n        if (buttonPressed.startsWith(\"submit_jump_\"))\n        {\n            // Button on progress bar pressed\n            try\n            {\n                // get step & page info (in form: stepNum.pageNum) after\n                // \"submit_jump_\"\n                String stepAndPage = buttonPressed.substring(12);\n\n                // split into stepNum and pageNum\n                String[] fields = stepAndPage.split(\"\\\\.\"); // split on period\n                nextStep = Integer.parseInt(fields[0]);\n                nextPage = Integer.parseInt(fields[1]);\n            }\n            catch (NumberFormatException ne)\n            {\n                // mangled number\n                nextStep = -1;\n                nextPage = -1;\n            }\n\n            // Integrity check: make sure they aren't going\n            // forward or backward too far\n            if ((!subInfo.isInWorkflow() && nextStep < FIRST_STEP) ||\n                    (subInfo.isInWorkflow() && nextStep < WORKFLOW_FIRST_STEP))\n            {\n                nextStep = -1;\n                nextPage = -1;\n            }\n\n            // if trying to jump to a step you haven't been to yet\n            if (!subInfo.isInWorkflow() && (nextStep > getStepReached(subInfo)))\n            {\n                nextStep = -1;\n            }\n        }\n\n        if (nextStep == -1)\n        {\n            // Either no button pressed, or an illegal stage\n            // reached. UI doesn't allow this, so something's\n            // wrong if that happens.\n            log.warn(LogManager.getHeader(context, \"integrity_error\", UIUtil\n                    .getRequestLogInfo(request)));\n            JSPManager.showIntegrityError(request, response);\n        }\n        else\n        {\n            int result = doSaveCurrentState(context, request, response,\n                    subInfo, currentStepConfig);\n\n            // Now, if the request was a multi-part (file upload), we need to\n            // get the original request back out, as the wrapper causes problems\n            // further down the line.\n            if (request instanceof FileUploadRequest)\n            {\n                FileUploadRequest fur = (FileUploadRequest) request;\n                request = fur.getOriginalRequest();\n            }\n\n            int currStep = currentStepConfig.getStepNumber();\n            int currPage = AbstractProcessingStep.getCurrentPage(request);\n            double currStepAndPage = Double.parseDouble(currStep + \".\" + currPage);\n            // default value if we are in workflow\n            double stepAndPageReached = -1;\n            \n            if (!subInfo.isInWorkflow())\n            {\n                stepAndPageReached = Double.parseDouble(getStepReached(subInfo)+\".\"+JSPStepManager.getPageReached(subInfo));\n            }\n            \n            if (result != AbstractProcessingStep.STATUS_COMPLETE\n                    && currStepAndPage != stepAndPageReached)\n            {\n                doStep(context, request, response, subInfo, currStep);\n            }\n            else\n            {\n                // save page info to request (for the step to access)\n                AbstractProcessingStep.setCurrentPage(request, nextPage);\n\n                // flag that we are going back to the start of this step (for\n                // JSPStepManager class)\n                setBeginningOfStep(request, true);\n\n                log.debug(\"Jumping to Step \" + nextStep + \" and Page \"\n                        + nextPage);\n\n                // do the step (the step should take care of going to\n                // the specified page)\n                doStep(context, request, response, subInfo, nextStep);\n            }\n        }\n    }\n\n    /**\n     * Respond to the user clicking \"cancel/save\" \n     * from any of the steps.  This method first calls\n     * the \"doPostProcessing()\" method of the step, in \n     * order to ensure any inputs are saved.\n     * \n     * @param context\n     *            DSpace context\n     * @param request\n     *            current servlet request object\n     * @param response\n     *            current servlet response object\n     * @param subInfo\n     *            SubmissionInfo object\n     * @param stepConfig\n     *            config of step who's page the user clicked \"cancel\" on.\n     */\n    private void doCancelOrSave(Context context, HttpServletRequest request,\n            HttpServletResponse response, SubmissionInfo subInfo,\n            SubmissionStepConfig stepConfig) throws ServletException, IOException,\n            SQLException, AuthorizeException\n    {\n        // If this is a workflow item, we need to return the\n        // user to the \"perform task\" page\n        if (subInfo.isInWorkflow())\n        {\n            int result = doSaveCurrentState(context, request, response, subInfo, stepConfig);\n            \n            if (result == AbstractProcessingStep.STATUS_COMPLETE)\n            {\n                request.setAttribute(\"workflow.item\", subInfo.getSubmissionItem());\n                JSPManager.showJSP(request, response, \"/mydspace/perform-task.jsp\");                \n            }\n            else\n            {\n                int currStep=stepConfig.getStepNumber();\n                doStep(context, request, response, subInfo, currStep);\n            }\n        }\n        else\n        {\n            // if no submission has been started,\n            if (subInfo.getSubmissionItem() == null)\n            {\n                // forward them to the 'cancelled' page,\n                // since we haven't created an item yet.\n                JSPManager.showJSP(request, response,\n                        \"/submit/cancelled-removed.jsp\");\n            }\n            else\n            {\n                //tell the step class to do its processing (to save any inputs)\n                //but, send flag that this is a \"cancellation\"\n                setCancellationInProgress(request, true);\n                \n                int result = doSaveCurrentState(context, request, response, subInfo,\n                        stepConfig);\n                \n                int currStep=stepConfig.getStepNumber();\n                int currPage=AbstractProcessingStep.getCurrentPage(request);\n                double currStepAndPage = Float.parseFloat(currStep+\".\"+currPage);\n                double stepAndPageReached = Float.parseFloat(getStepReached(subInfo)+\".\"+JSPStepManager.getPageReached(subInfo));\n                \n                if (result != AbstractProcessingStep.STATUS_COMPLETE && currStepAndPage < stepAndPageReached){\n                    setReachedStepAndPage(context, subInfo, currStep, currPage);\n                }\n                \n                //commit & close context\n                context.complete();\n                \n                // save changes to submission info & step info for JSP\n                saveSubmissionInfo(request, subInfo);\n                saveCurrentStepConfig(request, stepConfig);\n\n                // forward to cancellation confirmation JSP\n                showProgressAwareJSP(request, response, subInfo,\n                        \"/submit/cancel.jsp\");\n            }\n        }\n    }\n\n    private int doSaveCurrentState(Context context,\n            HttpServletRequest request, HttpServletResponse response,\n            SubmissionInfo subInfo, SubmissionStepConfig stepConfig)\n            throws ServletException\n    {\n        int result = -1;\n        // As long as we're not uploading a file, go ahead and SAVE\n        // all of the user's inputs for later\n        try\n        {\n            // call post-processing on Step (to save any inputs from JSP)\n            log\n                    .debug(\"Cancel/Save or Jump/Previous Request: calling processing for Step: '\"\n                            + stepConfig.getProcessingClassName() + \"'\");\n\n            try\n            {\n                // load the step class (using the current class loader)\n                ClassLoader loader = this.getClass().getClassLoader();\n                Class stepClass = loader.loadClass(stepConfig\n                        .getProcessingClassName());\n\n                // load the JSPStepManager object for this step\n                AbstractProcessingStep step = (AbstractProcessingStep) stepClass\n                        .newInstance();\n\n                result = step.doProcessing(context, request, response, subInfo);\n            }\n            catch (Exception e)\n            {\n                log.error(\"Error loading step class'\"\n                        + stepConfig.getProcessingClassName() + \"':\", e);\n                JSPManager.showInternalError(request, response);\n            }\n        }\n        catch(Exception e)\n        {\n            throw new ServletException(e);\n        }\n        return result;\n    }\n\n    /**\n     * Process information from \"submission cancelled\" page.\n     * This saves the item if the user decided to \"cancel & save\",\n     * or removes the item if the user decided to \"cancel & remove\".\n     * \n     * @param context\n     *            current DSpace context\n     * @param request\n     *            current servlet request object\n     * @param response\n     *            current servlet response object\n     * @param subInfo\n     *            submission info object\n     */\n    private void processCancelOrSave(Context context,\n            HttpServletRequest request, HttpServletResponse response,\n            SubmissionInfo subInfo, SubmissionStepConfig currentStepConfig) throws ServletException, IOException,\n            SQLException, AuthorizeException\n    {\n        String buttonPressed = UIUtil.getSubmitButton(request, \"submit_back\");\n\n        if (buttonPressed.equals(\"submit_back\"))\n        {\n            // re-load current step at beginning\n            setBeginningOfStep(request, true);\n            doStep(context, request, response, subInfo, currentStepConfig\n                    .getStepNumber());\n        }\n        else if (buttonPressed.equals(\"submit_remove\"))\n        {\n            // User wants to cancel and remove\n            // Cancellation page only applies to workspace items\n            WorkspaceItem wi = (WorkspaceItem) subInfo.getSubmissionItem();\n\n            workspaceItemService.deleteAll(context, wi);\n\n            JSPManager.showJSP(request, response,\n                    \"/submit/cancelled-removed.jsp\");\n\n            context.complete();\n        }\n        else if (buttonPressed.equals(\"submit_keep\"))\n        {\n            // Save submission for later - just show message\n            JSPManager.showJSP(request, response, \"/submit/saved.jsp\");\n        }\n        else\n        {\n            doStepJump(context, request, response, subInfo, currentStepConfig);\n        }\n    }\n\n    // ****************************************************************\n    // ****************************************************************\n    // MISCELLANEOUS CONVENIENCE METHODS\n    // ****************************************************************\n    // ****************************************************************\n\n    /**\n     * Show a JSP after setting attributes needed by progress bar\n     * \n     * @param request\n     *            the request object\n     * @param response\n     *            the response object\n     * @param subInfo\n     *            the SubmissionInfo object\n     * @param jspPath\n     *            relative path to JSP\n     */\n    private static void showProgressAwareJSP(HttpServletRequest request,\n            HttpServletResponse response, SubmissionInfo subInfo, String jspPath)\n            throws ServletException, IOException\n    {\n        saveSubmissionInfo(request, subInfo);\n\n        JSPManager.showJSP(request, response, jspPath);\n    }\n\n    /**\n     * Reloads a filled-out submission info object from the parameters in the\n     * current request. If there is a problem, <code>null</code> is returned.\n     * \n     * @param context\n     *            DSpace context\n     * @param request\n     *            HTTP request\n     * \n     * @return filled-out submission info, or null\n     */\n    public static SubmissionInfo getSubmissionInfo(Context context,\n            HttpServletRequest request) throws SQLException, ServletException\n    {\n        SubmissionInfo info = null;\n        \n        // Is full Submission Info in Request Attribute?\n        if (request.getAttribute(\"submission.info\") != null)\n        {\n            // load from cache\n            info = (SubmissionInfo) request.getAttribute(\"submission.info\");\n        }\n        else\n        {\n            \n            \n            // Need to rebuild Submission Info from Request Parameters\n            if (request.getParameter(\"workflow_id\") != null)\n            {\n                int workflowID = UIUtil.getIntParameter(request, \"workflow_id\");\n                \n                info = SubmissionInfo.load(request, workflowItemService.find(context, workflowID));\n            }\n            else if(request.getParameter(\"workspace_item_id\") != null)\n            {\n                int workspaceID = UIUtil.getIntParameter(request,\n                        \"workspace_item_id\");\n                \n                info = SubmissionInfo.load(request, workspaceItemService.find(context, workspaceID));\n            }\n            else\n            {\n                //by default, initialize Submission Info with no item\n                info = SubmissionInfo.load(request, null);\n            }\n            \n            // We must have a submission object if after the first step,\n            // otherwise something is wrong!\n            if ((getStepReached(info) > FIRST_STEP)\n                    && (info.getSubmissionItem() == null))\n            {\n                log.warn(LogManager.getHeader(context,\n                        \"cannot_load_submission_info\",\n                        \"InProgressSubmission is null!\"));\n                return null;\n            }\n               \n\n            if (request.getParameter(\"bundle_id\") != null)\n            {\n                UUID bundleID = UIUtil.getUUIDParameter(request, \"bundle_id\");\n                info.setBundle(bundleService.find(context, bundleID));\n            }\n\n            if (request.getParameter(\"bitstream_id\") != null)\n            {\n                UUID bitstreamID = UIUtil.getUUIDParameter(request,\n                        \"bitstream_id\");\n                info.setBitstream(bitstreamService.find(context, bitstreamID));\n            }\n\n            // save to Request Attribute\n            saveSubmissionInfo(request, info);\n        }// end if unable to load SubInfo from Request Attribute\n\n        return info;\n    }\n\n    /**\n     * Saves the submission info object to the current request.\n     * \n     * @param request\n     *            HTTP request\n     * @param si\n     *            the current submission info\n     * \n     */\n    public static void saveSubmissionInfo(HttpServletRequest request,\n            SubmissionInfo si)\n    {\n        // save to request\n        request.setAttribute(\"submission.info\", si);\n    }\n\n    /**\n     * Get the configuration of the current step from parameters in the request, \n     * along with the current SubmissionInfo object. \n     * If there is a problem, <code>null</code> is returned.\n     * \n     * @param request\n     *            HTTP request\n     * @param si\n     *            The current SubmissionInfo object\n     * \n     * @return the current SubmissionStepConfig\n     */\n    public static SubmissionStepConfig getCurrentStepConfig(\n            HttpServletRequest request, SubmissionInfo si)\n    {\n        int stepNum = -1;\n        SubmissionStepConfig step = (SubmissionStepConfig) request\n                .getAttribute(\"step\");\n\n        if (step == null)\n        {\n            // try and get it as a parameter\n            stepNum = UIUtil.getIntParameter(request, \"step\");\n\n            // if something is wrong, return null\n            if (stepNum < 0 || si == null || si.getSubmissionConfig() == null)\n            {\n                return null;\n            }\n            else\n            {\n                return si.getSubmissionConfig().getStep(stepNum);\n            }\n        }\n        else\n        {\n            return step;\n        }\n    }\n\n    /**\n     * Saves the current step configuration into the request.\n     * \n     * @param request\n     *            HTTP request\n     * @param step\n     *            The current SubmissionStepConfig\n     */\n    public static void saveCurrentStepConfig(HttpServletRequest request,\n            SubmissionStepConfig step)\n    {\n        // save to request\n        request.setAttribute(\"step\", step);\n    }\n\n    /**\n     * Checks if the current step is also the first \"visibile\" step in the item submission\n     * process.\n     * \n     * @param request\n     *            HTTP request\n     * @param si\n     *            The current Submission Info\n     * \n     * @return whether or not the current step is the first step\n     */\n    public static boolean isFirstStep(HttpServletRequest request,\n            SubmissionInfo si)\n    {\n        SubmissionStepConfig step = getCurrentStepConfig(request, si);\n\n        return ((step != null) && (getPreviousVisibleStep(request, si) == null));\n    }\n    \n    /**\n     * Return the previous \"visibile\" step in the item submission\n     * process if any, <code>null</code> otherwise.\n     * \n     * @param request\n     *            HTTP request\n     * @param si\n     *            The current Submission Info\n     * \n     * @return the previous step in the item submission process if any\n     */\n    public static SubmissionStepConfig getPreviousVisibleStep(HttpServletRequest request,\n            SubmissionInfo si)\n    {\n        SubmissionStepConfig step = getCurrentStepConfig(request, si);\n\n        SubmissionStepConfig currentStepConfig, previousStep = null;\n\n        int currentStepNum = step.getStepNumber();\n        \n        //need to find a previous step that is VISIBLE to the user!\n        while(currentStepNum>FIRST_STEP)\n        {\n            // update the current step & do this previous step\n            currentStepNum--;\n        \n            //get previous step\n            currentStepConfig = si.getSubmissionConfig().getStep(currentStepNum);\n        \n            if(currentStepConfig.isVisible())\n            {\n                previousStep = currentStepConfig;\n                break;\n            }\n        }\n        return previousStep;\n    }\n\n    /**\n     * Get whether or not the current step has just begun. This helps determine\n     * if we've done any pre-processing yet. If the step is just started, we\n     * need to do pre-processing, otherwise we should be doing post-processing.\n     * If there is a problem, <code>false</code> is returned.\n     * \n     * @param request\n     *            HTTP request\n     * \n     * @return true if the step has just started (and JSP has not been loaded\n     *         for this step), false otherwise.\n     */\n    public static boolean isBeginningOfStep(HttpServletRequest request)\n    {\n        Boolean stepStart = (Boolean) request.getAttribute(\"step.start\");\n\n        if (stepStart != null)\n        {\n            return stepStart.booleanValue();\n        }\n        else\n        {\n            return false;\n        }\n    }\n\n    /**\n     * Get whether or not the current step has just begun. This helps determine\n     * if we've done any pre-processing yet. If the step is just started, we\n     * need to do pre-processing, otherwise we should be doing post-processing.\n     * If there is a problem, <code>false</code> is returned.\n     * \n     * @param request\n     *            HTTP request\n     * @param beginningOfStep\n     *            true if step just began\n     */\n    public static void setBeginningOfStep(HttpServletRequest request,\n            boolean beginningOfStep)\n    {\n        request.setAttribute(\"step.start\", Boolean.valueOf(beginningOfStep));\n    }\n\n    \n    /**\n     * Get whether or not a cancellation is in progress (i.e. the \n     * user clicked on the \"Cancel/Save\" button from any submission\n     * page).\n     * \n     * @param request\n     *            HTTP request\n     *            \n     * @return true if a cancellation is in progress\n     */\n    public static boolean isCancellationInProgress(HttpServletRequest request)\n    {\n        Boolean cancellation = (Boolean) request.getAttribute(\"submission.cancellation\");\n\n        if (cancellation != null)\n        {\n            return cancellation.booleanValue();\n        }\n        else\n        {\n            return false;\n        }\n    }\n    \n    /**\n     * Sets whether or not a cancellation is in progress (i.e. the \n     * user clicked on the \"Cancel/Save\" button from any submission\n     * page).\n     * \n     * @param request\n     *            HTTP request\n     * @param cancellationInProgress\n     *            true if cancellation is in progress\n     */\n    private static void setCancellationInProgress(HttpServletRequest request, boolean cancellationInProgress)\n    {\n        request.setAttribute(\"submission.cancellation\", Boolean.valueOf(cancellationInProgress));\n    }\n    \n    \n    /**\n     * Return the submission info as hidden parameters for an HTML form on a JSP\n     * page.\n     * \n     * @param context\n     *            DSpace context\n     * @param request\n     *            HTTP request\n     * @return HTML hidden parameters\n     */\n    public static String getSubmissionParameters(Context context,\n            HttpServletRequest request) throws SQLException, ServletException\n    {\n        SubmissionInfo si = getSubmissionInfo(context, request);\n\n        SubmissionStepConfig step = getCurrentStepConfig(request, si);\n\n        String info = \"\";\n\n        if ((si.getSubmissionItem() != null) && si.isInWorkflow())\n        {\n            info = info\n                    + \"<input type=\\\"hidden\\\" name=\\\"workflow_id\\\" value=\\\"\"\n                    + si.getSubmissionItem().getID() + \"\\\"/>\";\n        }\n        else if (si.getSubmissionItem() != null)\n        {\n            info = info\n                    + \"<input type=\\\"hidden\\\" name=\\\"workspace_item_id\\\" value=\\\"\"\n                    + si.getSubmissionItem().getID() + \"\\\"/>\";\n        }\n\n        if (si.getBundle() != null)\n        {\n            info = info + \"<input type=\\\"hidden\\\" name=\\\"bundle_id\\\" value=\\\"\"\n                    + si.getBundle().getID() + \"\\\"/>\";\n        }\n\n        if (si.getBitstream() != null)\n        {\n            info = info\n                    + \"<input type=\\\"hidden\\\" name=\\\"bitstream_id\\\" value=\\\"\"\n                    + si.getBitstream().getID() + \"\\\"/>\";\n        }\n\n        if (step != null)\n        {\n            info = info + \"<input type=\\\"hidden\\\" name=\\\"step\\\" value=\\\"\"\n                    + step.getStepNumber() + \"\\\"/>\";\n        }\n\n        // save the current page from the current Step Servlet\n        int page = AbstractProcessingStep.getCurrentPage(request);\n        info = info + \"<input type=\\\"hidden\\\" name=\\\"page\\\" value=\\\"\" + page\n                + \"\\\"/>\";\n\n        // save the current JSP name to a hidden variable\n        String jspDisplayed = JSPStepManager.getLastJSPDisplayed(request);\n        info = info + \"<input type=\\\"hidden\\\" name=\\\"jsp\\\" value=\\\"\"\n                   + jspDisplayed + \"\\\"/>\";\n\n        return info;\n    }\n\n   \n\n    /**\n     * Indicate the user has advanced to the given stage. This will only\n     * actually do anything when it's a user initially entering a submission. It\n     * will only increase the \"stage reached\" column - it will not \"set back\"\n     * where a user has reached. Whenever the \"stage reached\" column is\n     * increased, the \"page reached\" column is reset to 1, since you've now\n     * reached page #1 of the next stage.\n     * \n     * @param subInfo\n     *            the SubmissionInfo object pertaining to the current submission\n     * @param step\n     *            the step the user has just reached\n     */\n    private void userHasReached(Context c, SubmissionInfo subInfo, int step)\n            throws SQLException, AuthorizeException, IOException\n    {\n        if (!subInfo.isInWorkflow() && subInfo.getSubmissionItem() != null)\n        {\n            WorkspaceItem wi = (WorkspaceItem) subInfo.getSubmissionItem();\n\n            if (step > wi.getStageReached())\n            {\n                wi.setStageReached(step);\n                wi.setPageReached(1); // reset page reached back to 1 (since\n                                        // it's page 1 of the new step)\n                workspaceItemService.update(c, wi);\n            }\n        }\n    }\n    \n    /**\n    * Set a specific step and page as reached. \n    * It will also \"set back\" where a user has reached.\n    * \n    * @param subInfo\n     *            the SubmissionInfo object pertaining to the current submission\n    * @param step the step to set as reached, can be also a previous reached step\n    * @param page the page (within the step) to set as reached, can be also a previous reached page\n    */\n    private void setReachedStepAndPage(Context c, SubmissionInfo subInfo, int step,\n            int page) throws SQLException, AuthorizeException, IOException\n    {\n        if (!subInfo.isInWorkflow() && subInfo.getSubmissionItem() != null)\n        {\n            WorkspaceItem wi = (WorkspaceItem) subInfo.getSubmissionItem();\n\n            wi.setStageReached(step);\n            wi.setPageReached(page);\n            workspaceItemService.update(c, wi);\n        }\n    }\n\n    \n    /**\n     * Find out which step a user has reached in the submission process. If the\n     * submission is in the workflow process, this returns -1.\n     * \n     * @param subInfo\n     *            submission info object\n     * \n     * @return step reached\n     */\n    public static int getStepReached(SubmissionInfo subInfo)\n    {\n        if (subInfo == null || subInfo.isInWorkflow() || subInfo.getSubmissionItem() == null)\n        {\n            return -1;\n        }\n        else\n        {\n            WorkspaceItem wi = (WorkspaceItem) subInfo.getSubmissionItem();\n            int i = wi.getStageReached();\n\n            // Uninitialised workspace items give \"-1\" as the stage reached\n            // this is a special value used by the progress bar, so we change\n            // it to \"FIRST_STEP\"\n            if (i == -1)\n            {\n                i = FIRST_STEP;\n            }\n\n            return i;\n        }\n    }\n\n    \n    /**\n     * Wraps a multipart form request, so that its attributes and parameters can\n     * still be accessed as normal.\n     * \n     * @return wrapped multipart request object\n     * \n     * @throws ServletException\n     *             if there are no more pages in this step\n     */\n    private HttpServletRequest wrapMultipartRequest(HttpServletRequest request)\n            throws ServletException, FileSizeLimitExceededException\n    {\n        HttpServletRequest wrappedRequest;\n\n        try\n        {\n            // if not already wrapped\n            if (!Class.forName(\"org.dspace.app.webui.util.FileUploadRequest\")\n                    .isInstance(request))\n            {\n                // Wrap multipart request\n                wrappedRequest = new FileUploadRequest(request);\n\n                return (HttpServletRequest) wrappedRequest;\n            }\n            else\n            { // already wrapped\n                return request;\n            }\n        }\n        catch (FileSizeLimitExceededException e)\n        {\n            throw new FileSizeLimitExceededException(e.getMessage(),e.getActualSize(),e.getPermittedSize());\n        }\n        catch (Exception e)\n        {\n            throw new ServletException(e);\n        }\n    }\n    \n    \n    /**\n     * Upload any files found on the Request or in assembledFiles, and save them back as \n     * Request attributes, for further processing by the appropriate user interface.\n     * \n     * @param context\n     *            current DSpace context\n     * @param request\n     *            current servlet request object\n     */\n    public void uploadFiles(Context context, HttpServletRequest request)\n            throws ServletException\n    {\n        FileUploadRequest wrapper = null;\n        String filePath = null;\n        InputStream fileInputStream = null;\n\n        try\n        {\n            // if we already have a FileUploadRequest, use it\n            if (Class.forName(\"org.dspace.app.webui.util.FileUploadRequest\")\n                    .isInstance(request))\n            {\n                wrapper = (FileUploadRequest) request;\n            }\n            else\n            {\n                // Wrap multipart request to get the submission info\n                wrapper = new FileUploadRequest(request);\n            }\n            \n            log.debug(\"Did not recoginze resumable upload, falling back to \"\n                    + \"simple upload.\");\n            Enumeration fileParams = wrapper.getFileParameterNames();\n            while (fileParams.hasMoreElements()) \n            {\n                String fileName = (String) fileParams.nextElement();\n\n                File temp = wrapper.getFile(fileName);\n\n                //if file exists and has a size greater than zero\n                if (temp != null && temp.length() > 0) \n                {\n                    // Read the temp file into an inputstream\n                    fileInputStream = new BufferedInputStream(\n                            new FileInputStream(temp));\n\n                    filePath = wrapper.getFilesystemName(fileName);\n\n                    // cleanup our temp file\n                    if (!temp.delete()) \n                    {\n                        log.error(\"Unable to delete temporary file\");\n                    }\n\n                    //save this file's info to request (for UploadStep class)\n                    request.setAttribute(fileName + \"-path\", filePath);\n                    request.setAttribute(fileName + \"-inputstream\", fileInputStream);\n                    request.setAttribute(fileName + \"-description\", wrapper.getParameter(\"description\"));\n                }\n            }\n        }\n        catch (Exception e)\n        {\n            // Problem with uploading\n            log.warn(LogManager.getHeader(context, \"upload_error\", \"\"), e);\n            throw new ServletException(e);\n        }\n    }\n    \n    // Resumable.js uses HTTP Get to recognize whether a specific part/chunk of \n    // a file was uploaded already. This method handles those requests.\n    protected void DoGetResumable(Context context, HttpServletRequest request, HttpServletResponse response)\n        throws IOException\n    {\n        String baseDir;\n\n        if (ConfigurationManager.getProperty(\"upload.temp.dir\") != null)\n        {\n            baseDir = ConfigurationManager.getProperty(\"upload.temp.dir\");\n        }\n        else\n        {\n            baseDir = System.getProperty(\"java.io.tmpdir\");\n        }\n\n        String resumableIdentifier = request.getParameter(\"resumableIdentifier\");\n        String resumableChunkNumber = request.getParameter(\"resumableChunkNumber\");\n        long resumableCurrentChunkSize = \n                Long.valueOf(request.getParameter(\"resumableCurrentChunkSize\"));\n\n        tempDir = baseDir + File.separator + resumableIdentifier;\n\n        File fileDir = new File(tempDir);\n\n        // Test fileDir to see if canonical path is within the original baseDir\n        if(!fileDir.getCanonicalPath().startsWith(baseDir)) {\n            log.error(\"Error processing resumable upload chunk: temporary chunk file would be created outside \" +\n                    \"permissible temp dir (\"+ baseDir +\") for submitter: \" + context.getCurrentUser().getEmail());\n            throw new IOException(\"Error processing resumableIdentifier: \" + resumableIdentifier +\n                    \" (submitter: \" + context.getCurrentUser().getEmail() + \")\" +\n                    \". Temporary upload directory would be created outside permissible base temp dir (\"+ baseDir +\")\");\n        }\n\n        // create a new directory for each resumableIdentifier\n        if (!fileDir.exists()) {\n            fileDir.mkdir();\n        }\n        // use the String \"part\" and the chunkNumber as filename of a chunk\n        String chunkPath = tempDir + File.separator + \"part\" + resumableChunkNumber;\n\n        File chunkFile = new File(chunkPath);\n\n        // Test chunkFile to see if canonical path is within the original baseDir\n        if(!chunkFile.getCanonicalPath().startsWith(baseDir)) {\n            log.error(\"Error processing resumable upload chunk: temporary chunk file would be created outside \" +\n                    \"permissible temp dir (\"+ baseDir +\") for submitter: \" + context.getCurrentUser().getEmail());\n            throw new IOException(\"Error processing resumableIdentifier: \" + resumableIdentifier +\n                    \" (submitter: \" + context.getCurrentUser().getEmail() + \")\" +\n                    \". Temporary upload directory would be created outside permissible base temp dir (\"+ baseDir +\")\");\n        }\n\n        // if the chunk was uploaded already, we send a status code of 200\n        if (chunkFile.exists()) {\n            if (chunkFile.length() == resumableCurrentChunkSize) {\n                response.setStatus(HttpServletResponse.SC_OK);\n                return;\n            }\n            // The chunk file does not have the expected size, delete it and \n            // pretend that it wasn't uploaded already.\n            chunkFile.delete();\n        }\n        // if we don't have the chunk send a http status code 404\n        response.sendError(HttpServletResponse.SC_NOT_FOUND);\n    }\n\n    // Resumable.js sends chunks of files using http post.\n    // If a chunk was the last missing one, we have to assemble the file and\n    // return it. If other chunks are missing, we just return null.\n    protected File doPostResumable(HttpServletRequest request)\n            throws FileSizeLimitExceededException, IOException, ServletException \n    {\n        File completedFile = null;\n        FileUploadRequest wrapper = null;\n        \n        if (ConfigurationManager.getProperty(\"upload.temp.dir\") != null)\n        {\n            tempDir = ConfigurationManager.getProperty(\"upload.temp.dir\");\n        }\n        else {\n            tempDir = System.getProperty(\"java.io.tmpdir\");\n        }\n        \n        try\n        {\n            // if we already have a FileUploadRequest, use it\n            if (Class.forName(\"org.dspace.app.webui.util.FileUploadRequest\").isInstance(request))\n            {\n                wrapper = (FileUploadRequest) request;\n            } \n            else // if not wrap the mulitpart request to get the submission info\n            {\n                wrapper = new FileUploadRequest(request);\n            }\n        }\n        catch (ClassNotFoundException ex)\n        {\n            // Cannot find a class that is part of the JSPUI?\n            log.fatal(\"Cannot find class org.dspace.app.webui.util.FileUploadRequest\");\n            throw new ServletException(\"Cannot find class org.dspace.app.webui.util.FileUploadRequest.\", ex);\n        }\n\n        String resumableIdentifier = wrapper.getParameter(\"resumableIdentifier\");\n        long resumableTotalSize = Long.valueOf(wrapper.getParameter(\"resumableTotalSize\"));\n        int resumableTotalChunks = Integer.valueOf(wrapper.getParameter(\"resumableTotalChunks\"));\n\n        String chunkDirPath = tempDir + File.separator + resumableIdentifier;\n        File chunkDirPathFile = new File(chunkDirPath);\n        boolean foundAll = true;\n        long currentSize = 0l;\n        \n        // check whether all chunks were received.\n        if(chunkDirPathFile.exists())\n        {\n            for (int p = 1; p <= resumableTotalChunks; p++) \n            {\n                File file = new File(chunkDirPath + File.separator + \"part\" + Integer.toString(p));\n\n                if (!file.exists()) \n                {\n                    foundAll = false;\n                    break;\n                }\n                currentSize += file.length();\n            }\n        }\n        \n        if (foundAll && currentSize >= resumableTotalSize) \n        {\n            try {\n                // assemble the file from it chunks.\n                File file = makeFileFromChunks(tempDir, chunkDirPathFile, wrapper);\n            \n                if (file != null) \n                {\n                    completedFile = file;\n                }\n            } catch (IOException ex) {\n                // if the assembling of a file results in an IOException a\n                // retransmission has to be triggered. Throw the IOException\n                // here and handle it above.\n                throw ex;\n            }\n        }\n\n        return completedFile;\n    }\n    \n    // assembles a file from it chunks\n    protected File makeFileFromChunks(String tmpDir, File chunkDirPath, HttpServletRequest request) \n            throws IOException\n    {\n        int resumableTotalChunks = Integer.valueOf(request.getParameter(\"resumableTotalChunks\"));\n        String resumableFilename = request.getParameter(\"resumableFilename\");\n        String chunkPath = chunkDirPath.getAbsolutePath() + File.separator + \"part\";\n        File destFile = null;\n\n        String destFilePath = tmpDir + File.separator + resumableFilename;\n        destFile = new File(destFilePath);\n        InputStream is = null;\n        OutputStream os = null;\n\n        try {\n            destFile.createNewFile();\n            os = new FileOutputStream(destFile);\n\n            for (int i = 1; i <= resumableTotalChunks; i++) \n            {\n                File fi = new File(chunkPath.concat(Integer.toString(i)));\n                try \n                {\n                    is = new FileInputStream(fi);\n\n                    byte[] buffer = new byte[1024];\n\n                    int lenght;\n\n                    while ((lenght = is.read(buffer)) > 0) \n                    {\n                        os.write(buffer, 0, lenght);\n                    }\n                } \n                catch (IOException e) \n                {\n                    // try to delete destination file, as we got an exception while writing it.\n                    if(!destFile.delete())\n                    {\n                        log.warn(\"While writing an uploaded file an error occurred. \"\n                                + \"We were unable to delete the damaged file: \" \n                                + destFile.getAbsolutePath() + \".\");\n                    }\n                    // throw IOException to handle it in the calling method\n                    throw e;\n                }\n                finally {\n                    try\n                    {\n                        if (is != null)\n                        {\n                            is.close();\n                        }\n                    }\n                    catch (IOException ex)\n                    {\n                        // nothing to do here\n                    }\n                }\n            }\n        } \n        finally \n        {\n            try \n            {\n                if (os != null) \n                {\n                    os.close();\n                }\n            } \n            catch (IOException ex) \n            {\n                // nothing to do here\n            }\n            if (!deleteDirectory(chunkDirPath)) \n            {\n                log.warn(\"Coudln't delete temporary upload path \" + chunkDirPath.getAbsolutePath() + \", ignoring it.\");\n            }\n        }\n        return destFile;\n    }\n\n    public boolean deleteDirectory(File path) \n    {\n        if (path.exists()) \n        {\n            File[] files = path.listFiles();\n            for (int i = 0; i < files.length; i++) \n            {\n                if (files[i].isDirectory()) \n                {\n                    deleteDirectory(files[i]);\n                } \n                else \n                {\n                    files[i].delete();\n                }\n            }\n        }\n        \n        return (path.delete());\n    }\n\n}\n", "/**\n * The contents of this file are subject to the license and copyright\n * detailed in the LICENSE and NOTICE files at the root of the source\n * tree and available online at\n *\n * http://www.dspace.org/license/\n */\npackage org.dspace.app.webui.util;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.*;\n\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletRequestWrapper;\nimport javax.servlet.http.HttpSession;\n\nimport org.apache.commons.fileupload.FileItem;\nimport org.apache.commons.fileupload.FileUploadBase.FileSizeLimitExceededException;\nimport org.apache.commons.fileupload.FileUploadBase.IOFileUploadException;\nimport org.apache.commons.fileupload.servlet.ServletFileUpload;\nimport org.apache.commons.fileupload.disk.DiskFileItemFactory;\nimport org.apache.commons.lang.StringUtils;\nimport org.apache.log4j.Logger;\nimport org.dspace.core.ConfigurationManager;\n\n/**\n * Based on the com.oreilly.servlet.MultipartWrapper object, this is an HTTP\n * request wrapper for multi-part (MIME) POSTs. It uses DSpace configuration\n * properties to determine the temporary directory to use and the maximum\n * allowable upload size.\n * \n * @author Robert Tansley\n * @version $Revision$\n */\npublic class FileUploadRequest extends HttpServletRequestWrapper\n{\n    public static final String FILE_UPLOAD_LISTNER = \"file-upload-listner\";\n    \n    private Map<String, String> parameters = new HashMap<String, String>();\n\n    private Map<String, FileItem> fileitems = new HashMap<String, FileItem>();\n\n    private List<String> filenames = new ArrayList<String>();\n\n    private String tempDir = null;\n\n    /** log4j logger */\n    private static Logger log = Logger\n            .getLogger(FileUploadRequest.class);\n\n    /** Original request */\n    private HttpServletRequest original = null;\n\n    /**\n     * Parse a multipart request and extracts the files\n     * \n     * @param req\n     *            the original request\n     */\n    public FileUploadRequest(HttpServletRequest req) throws IOException, FileSizeLimitExceededException\n    {\n        super(req);\n\n        original = req;\n\n        tempDir = (ConfigurationManager.getProperty(\"upload.temp.dir\") != null)\n            ? ConfigurationManager.getProperty(\"upload.temp.dir\") : System.getProperty(\"java.io.tmpdir\"); \n        long maxSize = ConfigurationManager.getLongProperty(\"upload.max\");\n\n        // Create a factory for disk-based file items\n        DiskFileItemFactory factory = new DiskFileItemFactory();\n        factory.setRepository(new File(tempDir));\n\n        // Create a new file upload handler\n        ServletFileUpload upload = new ServletFileUpload(factory);\n\n        HttpSession session = req.getSession();\n        \n        if (ConfigurationManager.getBooleanProperty(\"webui.submit.upload.progressbar\", true))\n        {\n            // set file upload progress listener\n            FileUploadListener listener = new FileUploadListener();\n    \n            session.setAttribute(FILE_UPLOAD_LISTNER, listener);\n    \n            // upload servlet allows to set upload listener\n            upload.setProgressListener(listener);\n        }\n        \n        try\n        {\n            upload.setSizeMax(maxSize);\n            List<FileItem> items = upload.parseRequest(req);\n            for (FileItem item : items)\n            {\n                if (item.isFormField())\n                {\n                    parameters.put(item.getFieldName(), item.getString(\"UTF-8\"));\n                }\n                else\n                {\n                    if (parameters.containsKey(\"resumableIdentifier\")) \n                    {\n                        String filename = getFilename(parameters.get(\"resumableFilename\"));\n                        if (!StringUtils.isEmpty(filename)) \n                        {\n                            String chunkDirPath = tempDir + File.separator + parameters.get(\"resumableIdentifier\");\n                            String chunkPath = chunkDirPath + File.separator + \"part\" + parameters.get(\"resumableChunkNumber\");\n\n                            File fileDir = new File(chunkDirPath);\n\n                            // Test fileDir to see if canonical path is within the original tempDir\n                            if(!fileDir.getCanonicalPath().startsWith(tempDir)) {\n                                log.error(\"Error processing resumable upload chunk: temporary chunk file would be created outside \" +\n                                        \"permissible temp dir (\"+ tempDir +\") for file: \" + filename);\n                                throw new IOException(\"Error processing resumable chunk directory \" + chunkDirPath +\n                                        \" (filename: \" + filename + \")\" +\n                                        \". Temporary upload directory would be created outside permissible base temp dir (\"+ tempDir +\")\");\n                            }\n\n                            if(fileDir.exists())\n                            {\n                                item.write(new File(chunkPath));\n                            }\n                        }\n                    }\n                    else\n                    {\n                        parameters.put(item.getFieldName(), item.getName());\n                        fileitems.put(item.getFieldName(), item);\n                        filenames.add(item.getName());\n\n                        String filename = getFilename(item.getName());\n                        if (filename != null && !\"\".equals(filename))\n                        {\n                            File fileDir = new File(tempDir + File.separator+ filename);\n                            // Test fileDir to see if canonical path is within the original tempDir\n                            if(!fileDir.getCanonicalPath().startsWith(tempDir)) {\n                                log.error(\"Error processing resumable upload chunk: temporary chunk file would be created outside \" +\n                                        \"permissible temp dir (\"+ tempDir +\") for file: \" + filename);\n                                throw new IOException(\"Error processing resumable chunk directory \" + fileDir +\n                                        \" (filename: \" + filename + \")\" +\n                                        \". Temporary upload directory would be created outside permissible base temp dir (\"+ tempDir +\")\");\n                            }\n\n                            item.write(fileDir);\n                        }\n                    }\n                }\n            }\n        }\n        catch(IOFileUploadException e){\n            if (!(e.getMessage().contains(\"Stream ended unexpectedly\")))\n            {\n                throw new IOException(e.getMessage(), e);\n            }\n        }\n        catch (Exception e)\n        {\n            if(e.getMessage().contains(\"exceeds the configured maximum\"))\n            {\n                // ServletFileUpload is not throwing the correct error, so this is workaround\n                // the request was rejected because its size (11302) exceeds the configured maximum (536)\n                int startFirstParen = e.getMessage().indexOf(\"(\")+1;\n                int endFirstParen = e.getMessage().indexOf(\")\");\n                String uploadedSize = e.getMessage().substring(startFirstParen, endFirstParen).trim();\n                Long actualSize = Long.parseLong(uploadedSize);\n                throw new FileSizeLimitExceededException(e.getMessage(), actualSize, maxSize);\n            }\n            throw new IOException(e.getMessage(), e);\n        }\n        finally\n        {\n            if (ConfigurationManager.getBooleanProperty(\"webui.submit.upload.progressbar\", true))\n            {\n                session.removeAttribute(FILE_UPLOAD_LISTNER);\n            }\n        }\n    }\n\n    // Methods to replace HSR methods\n    public Enumeration getParameterNames()\n    {\n        Collection<String> c = parameters.keySet();\n        return Collections.enumeration(c);\n    }\n\n    public String getParameter(String name)\n    {\n        return parameters.get(name);\n    }\n\n    public String[] getParameterValues(String name)\n    {\n        return parameters.values().toArray(new String[parameters.values().size()]);\n    }\n\n    public Map getParameterMap()\n    {\n        Map<String, String[]> map = new HashMap<String, String[]>();\n        Enumeration eNum = getParameterNames();\n\n        while (eNum.hasMoreElements())\n        {\n            String name = (String) eNum.nextElement();\n            map.put(name, getParameterValues(name));\n        }\n\n        return map;\n    }\n\n    public String getFilesystemName(String name)\n    {\n        String filename = getFilename((fileitems.get(name))\n                .getName());\n        return tempDir + File.separator + filename;\n    }\n\n    public String getContentType(String name)\n    {\n        return (fileitems.get(name)).getContentType();\n    }\n\n    public File getFile(String name)\n    {\n        FileItem temp = fileitems.get(name);\n        String tempName = temp.getName();\n        String filename = getFilename(tempName);\n        if (\"\".equals(filename.trim()))\n        {\n            return null;\n        }\n        return new File(tempDir + File.separator + filename);\n    }\n\n    public Enumeration<String> getFileParameterNames()\n    {\n        Collection<String> c = fileitems.keySet();\n        return Collections.enumeration(c);\n    }\n    \n    public Enumeration<String> getFileNames()\n    {\n        return Collections.enumeration(filenames);\n    }\n\n    /**\n     * Get back the original HTTP request object\n     * \n     * @return the original HTTP request\n     */\n    public HttpServletRequest getOriginalRequest()\n    {\n        return original;\n    }\n\n    // Required due to the fact the contents of getName() may vary based on\n    // browser\n    private String getFilename(String filepath)\n    {\n        String filename = filepath.trim();\n\n        int index = filepath.lastIndexOf(File.separator);\n        if (index > -1)\n        {\n            filename = filepath.substring(index);\n        }\n        return filename;\n    }\n}\n"], "filenames": ["dspace-jspui/src/main/java/org/dspace/app/webui/servlet/SubmissionController.java", "dspace-jspui/src/main/java/org/dspace/app/webui/util/FileUploadRequest.java"], "buggy_code_start_loc": [237, 23], "buggy_code_end_loc": [1617, 124], "fixing_code_start_loc": [237, 24], "fixing_code_end_loc": [1639, 148], "type": "CWE-22", "message": "DSpace open source software is a repository application which provides durable access to digital resources. dspace-jspui is a UI component for DSpace. The JSPUI resumable upload implementations in SubmissionController and FileUploadRequest are vulnerable to multiple path traversal attacks, allowing an attacker to create files/directories anywhere on the server writable by the Tomcat/DSpace user, by modifying some request parameters during submission. This path traversal can only be executed by a user with special privileges (submitter rights). This vulnerability only impacts the JSPUI. Users are advised to upgrade. There are no known workarounds. However, this vulnerability cannot be exploited by an anonymous user or a basic user. The user must first have submitter privileges to at least one Collection and be able to determine how to modify the request parameters to exploit the vulnerability.", "other": {"cve": {"id": "CVE-2022-31194", "sourceIdentifier": "security-advisories@github.com", "published": "2022-08-01T21:15:13.490", "lastModified": "2022-08-08T17:15:19.907", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "DSpace open source software is a repository application which provides durable access to digital resources. dspace-jspui is a UI component for DSpace. The JSPUI resumable upload implementations in SubmissionController and FileUploadRequest are vulnerable to multiple path traversal attacks, allowing an attacker to create files/directories anywhere on the server writable by the Tomcat/DSpace user, by modifying some request parameters during submission. This path traversal can only be executed by a user with special privileges (submitter rights). This vulnerability only impacts the JSPUI. Users are advised to upgrade. There are no known workarounds. However, this vulnerability cannot be exploited by an anonymous user or a basic user. The user must first have submitter privileges to at least one Collection and be able to determine how to modify the request parameters to exploit the vulnerability."}, {"lang": "es", "value": "El software de c\u00f3digo abierto DSpace es una aplicaci\u00f3n de repositorio que proporciona acceso duradero a los recursos digitales. dspace-jspui es un componente de interfaz de usuario para DSpace. Las implementaciones de subida reanudable de JSPUI en SubmissionController y FileUploadRequest son vulnerables a m\u00faltiples ataques de salto de ruta, permitiendo a un atacante crear archivos/directorios en cualquier lugar del servidor escribibles por el usuario de Tomcat/DSpace, al modificar algunos par\u00e1metros de petici\u00f3n durante el env\u00edo. Este path traversal s\u00f3lo puede ser ejecutado por un usuario con privilegios especiales (submitter rights). Esta vulnerabilidad s\u00f3lo afecta a la JSPUI. Es recomendado a usuarios actualizar. No se presentan mitigaciones conocidas. Sin embargo, esta vulnerabilidad no puede ser explotada por un usuario an\u00f3nimo o un usuario b\u00e1sico. El usuario debe tener primero privilegios de remitente para al menos una colecci\u00f3n y ser capaz de determinar c\u00f3mo modificar los par\u00e1metros de la petici\u00f3n para explotar la vulnerabilidad"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.2, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.2, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:C/C:L/I:L/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "HIGH", "baseScore": 8.2, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.3, "impactScore": 5.3}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-22"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:duraspace:dspace:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.0", "versionEndIncluding": "5.10", "matchCriteriaId": "D0931332-ACDA-450E-BDC7-BE5D44E27F66"}, {"vulnerable": true, "criteria": "cpe:2.3:a:duraspace:dspace:*:*:*:*:*:*:*:*", "versionStartExcluding": "6.0", "versionEndExcluding": "6.4", "matchCriteriaId": "27C1503E-2C8B-43CD-8937-9ABE6C24C67F"}]}]}], "references": [{"url": "https://github.com/DSpace/DSpace/commit/7569c6374aefeafb996e202cf8d631020eda5f24", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/DSpace/DSpace/commit/d1dd7d23329ef055069759df15cfa200c8e3", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/DSpace/DSpace/security/advisories/GHSA-qp5m-c3m9-8q2p", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/DSpace/DSpace/commit/7569c6374aefeafb996e202cf8d631020eda5f24"}}