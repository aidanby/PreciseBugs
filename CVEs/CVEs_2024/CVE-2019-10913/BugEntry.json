{"buggy_code": ["<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\HttpFoundation;\n\nuse Symfony\\Component\\HttpFoundation\\Exception\\ConflictingHeadersException;\nuse Symfony\\Component\\HttpFoundation\\Exception\\SuspiciousOperationException;\nuse Symfony\\Component\\HttpFoundation\\Session\\SessionInterface;\n\n/**\n * Request represents an HTTP request.\n *\n * The methods dealing with URL accept / return a raw path (% encoded):\n *   * getBasePath\n *   * getBaseUrl\n *   * getPathInfo\n *   * getRequestUri\n *   * getUri\n *   * getUriForPath\n *\n * @author Fabien Potencier <fabien@symfony.com>\n */\nclass Request\n{\n    const HEADER_FORWARDED = 0b00001; // When using RFC 7239\n    const HEADER_X_FORWARDED_FOR = 0b00010;\n    const HEADER_X_FORWARDED_HOST = 0b00100;\n    const HEADER_X_FORWARDED_PROTO = 0b01000;\n    const HEADER_X_FORWARDED_PORT = 0b10000;\n    const HEADER_X_FORWARDED_ALL = 0b11110; // All \"X-Forwarded-*\" headers\n    const HEADER_X_FORWARDED_AWS_ELB = 0b11010; // AWS ELB doesn't send X-Forwarded-Host\n\n    /** @deprecated since version 3.3, to be removed in 4.0 */\n    const HEADER_CLIENT_IP = self::HEADER_X_FORWARDED_FOR;\n    /** @deprecated since version 3.3, to be removed in 4.0 */\n    const HEADER_CLIENT_HOST = self::HEADER_X_FORWARDED_HOST;\n    /** @deprecated since version 3.3, to be removed in 4.0 */\n    const HEADER_CLIENT_PROTO = self::HEADER_X_FORWARDED_PROTO;\n    /** @deprecated since version 3.3, to be removed in 4.0 */\n    const HEADER_CLIENT_PORT = self::HEADER_X_FORWARDED_PORT;\n\n    const METHOD_HEAD = 'HEAD';\n    const METHOD_GET = 'GET';\n    const METHOD_POST = 'POST';\n    const METHOD_PUT = 'PUT';\n    const METHOD_PATCH = 'PATCH';\n    const METHOD_DELETE = 'DELETE';\n    const METHOD_PURGE = 'PURGE';\n    const METHOD_OPTIONS = 'OPTIONS';\n    const METHOD_TRACE = 'TRACE';\n    const METHOD_CONNECT = 'CONNECT';\n\n    /**\n     * @var string[]\n     */\n    protected static $trustedProxies = [];\n\n    /**\n     * @var string[]\n     */\n    protected static $trustedHostPatterns = [];\n\n    /**\n     * @var string[]\n     */\n    protected static $trustedHosts = [];\n\n    /**\n     * Names for headers that can be trusted when\n     * using trusted proxies.\n     *\n     * The FORWARDED header is the standard as of rfc7239.\n     *\n     * The other headers are non-standard, but widely used\n     * by popular reverse proxies (like Apache mod_proxy or Amazon EC2).\n     *\n     * @deprecated since version 3.3, to be removed in 4.0\n     */\n    protected static $trustedHeaders = [\n        self::HEADER_FORWARDED => 'FORWARDED',\n        self::HEADER_CLIENT_IP => 'X_FORWARDED_FOR',\n        self::HEADER_CLIENT_HOST => 'X_FORWARDED_HOST',\n        self::HEADER_CLIENT_PROTO => 'X_FORWARDED_PROTO',\n        self::HEADER_CLIENT_PORT => 'X_FORWARDED_PORT',\n    ];\n\n    protected static $httpMethodParameterOverride = false;\n\n    /**\n     * Custom parameters.\n     *\n     * @var \\Symfony\\Component\\HttpFoundation\\ParameterBag\n     */\n    public $attributes;\n\n    /**\n     * Request body parameters ($_POST).\n     *\n     * @var \\Symfony\\Component\\HttpFoundation\\ParameterBag\n     */\n    public $request;\n\n    /**\n     * Query string parameters ($_GET).\n     *\n     * @var \\Symfony\\Component\\HttpFoundation\\ParameterBag\n     */\n    public $query;\n\n    /**\n     * Server and execution environment parameters ($_SERVER).\n     *\n     * @var \\Symfony\\Component\\HttpFoundation\\ServerBag\n     */\n    public $server;\n\n    /**\n     * Uploaded files ($_FILES).\n     *\n     * @var \\Symfony\\Component\\HttpFoundation\\FileBag\n     */\n    public $files;\n\n    /**\n     * Cookies ($_COOKIE).\n     *\n     * @var \\Symfony\\Component\\HttpFoundation\\ParameterBag\n     */\n    public $cookies;\n\n    /**\n     * Headers (taken from the $_SERVER).\n     *\n     * @var \\Symfony\\Component\\HttpFoundation\\HeaderBag\n     */\n    public $headers;\n\n    /**\n     * @var string|resource|false|null\n     */\n    protected $content;\n\n    /**\n     * @var array\n     */\n    protected $languages;\n\n    /**\n     * @var array\n     */\n    protected $charsets;\n\n    /**\n     * @var array\n     */\n    protected $encodings;\n\n    /**\n     * @var array\n     */\n    protected $acceptableContentTypes;\n\n    /**\n     * @var string\n     */\n    protected $pathInfo;\n\n    /**\n     * @var string\n     */\n    protected $requestUri;\n\n    /**\n     * @var string\n     */\n    protected $baseUrl;\n\n    /**\n     * @var string\n     */\n    protected $basePath;\n\n    /**\n     * @var string\n     */\n    protected $method;\n\n    /**\n     * @var string\n     */\n    protected $format;\n\n    /**\n     * @var \\Symfony\\Component\\HttpFoundation\\Session\\SessionInterface\n     */\n    protected $session;\n\n    /**\n     * @var string\n     */\n    protected $locale;\n\n    /**\n     * @var string\n     */\n    protected $defaultLocale = 'en';\n\n    /**\n     * @var array\n     */\n    protected static $formats;\n\n    protected static $requestFactory;\n\n    private $isHostValid = true;\n    private $isForwardedValid = true;\n\n    private static $trustedHeaderSet = -1;\n\n    /** @deprecated since version 3.3, to be removed in 4.0 */\n    private static $trustedHeaderNames = [\n        self::HEADER_FORWARDED => 'FORWARDED',\n        self::HEADER_CLIENT_IP => 'X_FORWARDED_FOR',\n        self::HEADER_CLIENT_HOST => 'X_FORWARDED_HOST',\n        self::HEADER_CLIENT_PROTO => 'X_FORWARDED_PROTO',\n        self::HEADER_CLIENT_PORT => 'X_FORWARDED_PORT',\n    ];\n\n    private static $forwardedParams = [\n        self::HEADER_X_FORWARDED_FOR => 'for',\n        self::HEADER_X_FORWARDED_HOST => 'host',\n        self::HEADER_X_FORWARDED_PROTO => 'proto',\n        self::HEADER_X_FORWARDED_PORT => 'host',\n    ];\n\n    /**\n     * @param array                $query      The GET parameters\n     * @param array                $request    The POST parameters\n     * @param array                $attributes The request attributes (parameters parsed from the PATH_INFO, ...)\n     * @param array                $cookies    The COOKIE parameters\n     * @param array                $files      The FILES parameters\n     * @param array                $server     The SERVER parameters\n     * @param string|resource|null $content    The raw body data\n     */\n    public function __construct(array $query = [], array $request = [], array $attributes = [], array $cookies = [], array $files = [], array $server = [], $content = null)\n    {\n        $this->initialize($query, $request, $attributes, $cookies, $files, $server, $content);\n    }\n\n    /**\n     * Sets the parameters for this request.\n     *\n     * This method also re-initializes all properties.\n     *\n     * @param array                $query      The GET parameters\n     * @param array                $request    The POST parameters\n     * @param array                $attributes The request attributes (parameters parsed from the PATH_INFO, ...)\n     * @param array                $cookies    The COOKIE parameters\n     * @param array                $files      The FILES parameters\n     * @param array                $server     The SERVER parameters\n     * @param string|resource|null $content    The raw body data\n     */\n    public function initialize(array $query = [], array $request = [], array $attributes = [], array $cookies = [], array $files = [], array $server = [], $content = null)\n    {\n        $this->request = new ParameterBag($request);\n        $this->query = new ParameterBag($query);\n        $this->attributes = new ParameterBag($attributes);\n        $this->cookies = new ParameterBag($cookies);\n        $this->files = new FileBag($files);\n        $this->server = new ServerBag($server);\n        $this->headers = new HeaderBag($this->server->getHeaders());\n\n        $this->content = $content;\n        $this->languages = null;\n        $this->charsets = null;\n        $this->encodings = null;\n        $this->acceptableContentTypes = null;\n        $this->pathInfo = null;\n        $this->requestUri = null;\n        $this->baseUrl = null;\n        $this->basePath = null;\n        $this->method = null;\n        $this->format = null;\n    }\n\n    /**\n     * Creates a new request with values from PHP's super globals.\n     *\n     * @return static\n     */\n    public static function createFromGlobals()\n    {\n        // With the php's bug #66606, the php's built-in web server\n        // stores the Content-Type and Content-Length header values in\n        // HTTP_CONTENT_TYPE and HTTP_CONTENT_LENGTH fields.\n        $server = $_SERVER;\n        if ('cli-server' === \\PHP_SAPI) {\n            if (\\array_key_exists('HTTP_CONTENT_LENGTH', $_SERVER)) {\n                $server['CONTENT_LENGTH'] = $_SERVER['HTTP_CONTENT_LENGTH'];\n            }\n            if (\\array_key_exists('HTTP_CONTENT_TYPE', $_SERVER)) {\n                $server['CONTENT_TYPE'] = $_SERVER['HTTP_CONTENT_TYPE'];\n            }\n        }\n\n        $request = self::createRequestFromFactory($_GET, $_POST, [], $_COOKIE, $_FILES, $server);\n\n        if (0 === strpos($request->headers->get('CONTENT_TYPE'), 'application/x-www-form-urlencoded')\n            && \\in_array(strtoupper($request->server->get('REQUEST_METHOD', 'GET')), ['PUT', 'DELETE', 'PATCH'])\n        ) {\n            parse_str($request->getContent(), $data);\n            $request->request = new ParameterBag($data);\n        }\n\n        return $request;\n    }\n\n    /**\n     * Creates a Request based on a given URI and configuration.\n     *\n     * The information contained in the URI always take precedence\n     * over the other information (server and parameters).\n     *\n     * @param string               $uri        The URI\n     * @param string               $method     The HTTP method\n     * @param array                $parameters The query (GET) or request (POST) parameters\n     * @param array                $cookies    The request cookies ($_COOKIE)\n     * @param array                $files      The request files ($_FILES)\n     * @param array                $server     The server parameters ($_SERVER)\n     * @param string|resource|null $content    The raw body data\n     *\n     * @return static\n     */\n    public static function create($uri, $method = 'GET', $parameters = [], $cookies = [], $files = [], $server = [], $content = null)\n    {\n        $server = array_replace([\n            'SERVER_NAME' => 'localhost',\n            'SERVER_PORT' => 80,\n            'HTTP_HOST' => 'localhost',\n            'HTTP_USER_AGENT' => 'Symfony/3.X',\n            'HTTP_ACCEPT' => 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',\n            'HTTP_ACCEPT_LANGUAGE' => 'en-us,en;q=0.5',\n            'HTTP_ACCEPT_CHARSET' => 'ISO-8859-1,utf-8;q=0.7,*;q=0.7',\n            'REMOTE_ADDR' => '127.0.0.1',\n            'SCRIPT_NAME' => '',\n            'SCRIPT_FILENAME' => '',\n            'SERVER_PROTOCOL' => 'HTTP/1.1',\n            'REQUEST_TIME' => time(),\n        ], $server);\n\n        $server['PATH_INFO'] = '';\n        $server['REQUEST_METHOD'] = strtoupper($method);\n\n        $components = parse_url($uri);\n        if (isset($components['host'])) {\n            $server['SERVER_NAME'] = $components['host'];\n            $server['HTTP_HOST'] = $components['host'];\n        }\n\n        if (isset($components['scheme'])) {\n            if ('https' === $components['scheme']) {\n                $server['HTTPS'] = 'on';\n                $server['SERVER_PORT'] = 443;\n            } else {\n                unset($server['HTTPS']);\n                $server['SERVER_PORT'] = 80;\n            }\n        }\n\n        if (isset($components['port'])) {\n            $server['SERVER_PORT'] = $components['port'];\n            $server['HTTP_HOST'] .= ':'.$components['port'];\n        }\n\n        if (isset($components['user'])) {\n            $server['PHP_AUTH_USER'] = $components['user'];\n        }\n\n        if (isset($components['pass'])) {\n            $server['PHP_AUTH_PW'] = $components['pass'];\n        }\n\n        if (!isset($components['path'])) {\n            $components['path'] = '/';\n        }\n\n        switch (strtoupper($method)) {\n            case 'POST':\n            case 'PUT':\n            case 'DELETE':\n                if (!isset($server['CONTENT_TYPE'])) {\n                    $server['CONTENT_TYPE'] = 'application/x-www-form-urlencoded';\n                }\n                // no break\n            case 'PATCH':\n                $request = $parameters;\n                $query = [];\n                break;\n            default:\n                $request = [];\n                $query = $parameters;\n                break;\n        }\n\n        $queryString = '';\n        if (isset($components['query'])) {\n            parse_str(html_entity_decode($components['query']), $qs);\n\n            if ($query) {\n                $query = array_replace($qs, $query);\n                $queryString = http_build_query($query, '', '&');\n            } else {\n                $query = $qs;\n                $queryString = $components['query'];\n            }\n        } elseif ($query) {\n            $queryString = http_build_query($query, '', '&');\n        }\n\n        $server['REQUEST_URI'] = $components['path'].('' !== $queryString ? '?'.$queryString : '');\n        $server['QUERY_STRING'] = $queryString;\n\n        return self::createRequestFromFactory($query, $request, [], $cookies, $files, $server, $content);\n    }\n\n    /**\n     * Sets a callable able to create a Request instance.\n     *\n     * This is mainly useful when you need to override the Request class\n     * to keep BC with an existing system. It should not be used for any\n     * other purpose.\n     *\n     * @param callable|null $callable A PHP callable\n     */\n    public static function setFactory($callable)\n    {\n        self::$requestFactory = $callable;\n    }\n\n    /**\n     * Clones a request and overrides some of its parameters.\n     *\n     * @param array $query      The GET parameters\n     * @param array $request    The POST parameters\n     * @param array $attributes The request attributes (parameters parsed from the PATH_INFO, ...)\n     * @param array $cookies    The COOKIE parameters\n     * @param array $files      The FILES parameters\n     * @param array $server     The SERVER parameters\n     *\n     * @return static\n     */\n    public function duplicate(array $query = null, array $request = null, array $attributes = null, array $cookies = null, array $files = null, array $server = null)\n    {\n        $dup = clone $this;\n        if (null !== $query) {\n            $dup->query = new ParameterBag($query);\n        }\n        if (null !== $request) {\n            $dup->request = new ParameterBag($request);\n        }\n        if (null !== $attributes) {\n            $dup->attributes = new ParameterBag($attributes);\n        }\n        if (null !== $cookies) {\n            $dup->cookies = new ParameterBag($cookies);\n        }\n        if (null !== $files) {\n            $dup->files = new FileBag($files);\n        }\n        if (null !== $server) {\n            $dup->server = new ServerBag($server);\n            $dup->headers = new HeaderBag($dup->server->getHeaders());\n        }\n        $dup->languages = null;\n        $dup->charsets = null;\n        $dup->encodings = null;\n        $dup->acceptableContentTypes = null;\n        $dup->pathInfo = null;\n        $dup->requestUri = null;\n        $dup->baseUrl = null;\n        $dup->basePath = null;\n        $dup->method = null;\n        $dup->format = null;\n\n        if (!$dup->get('_format') && $this->get('_format')) {\n            $dup->attributes->set('_format', $this->get('_format'));\n        }\n\n        if (!$dup->getRequestFormat(null)) {\n            $dup->setRequestFormat($this->getRequestFormat(null));\n        }\n\n        return $dup;\n    }\n\n    /**\n     * Clones the current request.\n     *\n     * Note that the session is not cloned as duplicated requests\n     * are most of the time sub-requests of the main one.\n     */\n    public function __clone()\n    {\n        $this->query = clone $this->query;\n        $this->request = clone $this->request;\n        $this->attributes = clone $this->attributes;\n        $this->cookies = clone $this->cookies;\n        $this->files = clone $this->files;\n        $this->server = clone $this->server;\n        $this->headers = clone $this->headers;\n    }\n\n    /**\n     * Returns the request as a string.\n     *\n     * @return string The request\n     */\n    public function __toString()\n    {\n        try {\n            $content = $this->getContent();\n        } catch (\\LogicException $e) {\n            return trigger_error($e, E_USER_ERROR);\n        }\n\n        $cookieHeader = '';\n        $cookies = [];\n\n        foreach ($this->cookies as $k => $v) {\n            $cookies[] = $k.'='.$v;\n        }\n\n        if (!empty($cookies)) {\n            $cookieHeader = 'Cookie: '.implode('; ', $cookies).\"\\r\\n\";\n        }\n\n        return\n            sprintf('%s %s %s', $this->getMethod(), $this->getRequestUri(), $this->server->get('SERVER_PROTOCOL')).\"\\r\\n\".\n            $this->headers.\n            $cookieHeader.\"\\r\\n\".\n            $content;\n    }\n\n    /**\n     * Overrides the PHP global variables according to this request instance.\n     *\n     * It overrides $_GET, $_POST, $_REQUEST, $_SERVER, $_COOKIE.\n     * $_FILES is never overridden, see rfc1867\n     */\n    public function overrideGlobals()\n    {\n        $this->server->set('QUERY_STRING', static::normalizeQueryString(http_build_query($this->query->all(), '', '&')));\n\n        $_GET = $this->query->all();\n        $_POST = $this->request->all();\n        $_SERVER = $this->server->all();\n        $_COOKIE = $this->cookies->all();\n\n        foreach ($this->headers->all() as $key => $value) {\n            $key = strtoupper(str_replace('-', '_', $key));\n            if (\\in_array($key, ['CONTENT_TYPE', 'CONTENT_LENGTH'])) {\n                $_SERVER[$key] = implode(', ', $value);\n            } else {\n                $_SERVER['HTTP_'.$key] = implode(', ', $value);\n            }\n        }\n\n        $request = ['g' => $_GET, 'p' => $_POST, 'c' => $_COOKIE];\n\n        $requestOrder = ini_get('request_order') ?: ini_get('variables_order');\n        $requestOrder = preg_replace('#[^cgp]#', '', strtolower($requestOrder)) ?: 'gp';\n\n        $_REQUEST = [];\n        foreach (str_split($requestOrder) as $order) {\n            $_REQUEST = array_merge($_REQUEST, $request[$order]);\n        }\n    }\n\n    /**\n     * Sets a list of trusted proxies.\n     *\n     * You should only list the reverse proxies that you manage directly.\n     *\n     * @param array $proxies          A list of trusted proxies\n     * @param int   $trustedHeaderSet A bit field of Request::HEADER_*, to set which headers to trust from your proxies\n     *\n     * @throws \\InvalidArgumentException When $trustedHeaderSet is invalid\n     */\n    public static function setTrustedProxies(array $proxies/*, int $trustedHeaderSet*/)\n    {\n        self::$trustedProxies = $proxies;\n\n        if (2 > \\func_num_args()) {\n            @trigger_error(sprintf('The %s() method expects a bit field of Request::HEADER_* as second argument since Symfony 3.3. Defining it will be required in 4.0. ', __METHOD__), E_USER_DEPRECATED);\n\n            return;\n        }\n        $trustedHeaderSet = (int) func_get_arg(1);\n\n        foreach (self::$trustedHeaderNames as $header => $name) {\n            self::$trustedHeaders[$header] = $header & $trustedHeaderSet ? $name : null;\n        }\n        self::$trustedHeaderSet = $trustedHeaderSet;\n    }\n\n    /**\n     * Gets the list of trusted proxies.\n     *\n     * @return array An array of trusted proxies\n     */\n    public static function getTrustedProxies()\n    {\n        return self::$trustedProxies;\n    }\n\n    /**\n     * Gets the set of trusted headers from trusted proxies.\n     *\n     * @return int A bit field of Request::HEADER_* that defines which headers are trusted from your proxies\n     */\n    public static function getTrustedHeaderSet()\n    {\n        return self::$trustedHeaderSet;\n    }\n\n    /**\n     * Sets a list of trusted host patterns.\n     *\n     * You should only list the hosts you manage using regexs.\n     *\n     * @param array $hostPatterns A list of trusted host patterns\n     */\n    public static function setTrustedHosts(array $hostPatterns)\n    {\n        self::$trustedHostPatterns = array_map(function ($hostPattern) {\n            return sprintf('{%s}i', $hostPattern);\n        }, $hostPatterns);\n        // we need to reset trusted hosts on trusted host patterns change\n        self::$trustedHosts = [];\n    }\n\n    /**\n     * Gets the list of trusted host patterns.\n     *\n     * @return array An array of trusted host patterns\n     */\n    public static function getTrustedHosts()\n    {\n        return self::$trustedHostPatterns;\n    }\n\n    /**\n     * Sets the name for trusted headers.\n     *\n     * The following header keys are supported:\n     *\n     *  * Request::HEADER_CLIENT_IP:    defaults to X-Forwarded-For   (see getClientIp())\n     *  * Request::HEADER_CLIENT_HOST:  defaults to X-Forwarded-Host  (see getHost())\n     *  * Request::HEADER_CLIENT_PORT:  defaults to X-Forwarded-Port  (see getPort())\n     *  * Request::HEADER_CLIENT_PROTO: defaults to X-Forwarded-Proto (see getScheme() and isSecure())\n     *  * Request::HEADER_FORWARDED:    defaults to Forwarded         (see RFC 7239)\n     *\n     * Setting an empty value allows to disable the trusted header for the given key.\n     *\n     * @param string $key   The header key\n     * @param string $value The header name\n     *\n     * @throws \\InvalidArgumentException\n     *\n     * @deprecated since version 3.3, to be removed in 4.0. Use the $trustedHeaderSet argument of the Request::setTrustedProxies() method instead.\n     */\n    public static function setTrustedHeaderName($key, $value)\n    {\n        @trigger_error(sprintf('The \"%s()\" method is deprecated since Symfony 3.3 and will be removed in 4.0. Use the $trustedHeaderSet argument of the Request::setTrustedProxies() method instead.', __METHOD__), E_USER_DEPRECATED);\n\n        if ('forwarded' === $key) {\n            $key = self::HEADER_FORWARDED;\n        } elseif ('client_ip' === $key) {\n            $key = self::HEADER_CLIENT_IP;\n        } elseif ('client_host' === $key) {\n            $key = self::HEADER_CLIENT_HOST;\n        } elseif ('client_proto' === $key) {\n            $key = self::HEADER_CLIENT_PROTO;\n        } elseif ('client_port' === $key) {\n            $key = self::HEADER_CLIENT_PORT;\n        } elseif (!\\array_key_exists($key, self::$trustedHeaders)) {\n            throw new \\InvalidArgumentException(sprintf('Unable to set the trusted header name for key \"%s\".', $key));\n        }\n\n        self::$trustedHeaders[$key] = $value;\n\n        if (null !== $value) {\n            self::$trustedHeaderNames[$key] = $value;\n            self::$trustedHeaderSet |= $key;\n        } else {\n            self::$trustedHeaderSet &= ~$key;\n        }\n    }\n\n    /**\n     * Gets the trusted proxy header name.\n     *\n     * @param string $key The header key\n     *\n     * @return string The header name\n     *\n     * @throws \\InvalidArgumentException\n     *\n     * @deprecated since version 3.3, to be removed in 4.0. Use the Request::getTrustedHeaderSet() method instead.\n     */\n    public static function getTrustedHeaderName($key)\n    {\n        if (2 > \\func_num_args() || func_get_arg(1)) {\n            @trigger_error(sprintf('The \"%s()\" method is deprecated since Symfony 3.3 and will be removed in 4.0. Use the Request::getTrustedHeaderSet() method instead.', __METHOD__), E_USER_DEPRECATED);\n        }\n\n        if (!\\array_key_exists($key, self::$trustedHeaders)) {\n            throw new \\InvalidArgumentException(sprintf('Unable to get the trusted header name for key \"%s\".', $key));\n        }\n\n        return self::$trustedHeaders[$key];\n    }\n\n    /**\n     * Normalizes a query string.\n     *\n     * It builds a normalized query string, where keys/value pairs are alphabetized,\n     * have consistent escaping and unneeded delimiters are removed.\n     *\n     * @param string $qs Query string\n     *\n     * @return string A normalized query string for the Request\n     */\n    public static function normalizeQueryString($qs)\n    {\n        if ('' == $qs) {\n            return '';\n        }\n\n        $parts = [];\n        $order = [];\n\n        foreach (explode('&', $qs) as $param) {\n            if ('' === $param || '=' === $param[0]) {\n                // Ignore useless delimiters, e.g. \"x=y&\".\n                // Also ignore pairs with empty key, even if there was a value, e.g. \"=value\", as such nameless values cannot be retrieved anyway.\n                // PHP also does not include them when building _GET.\n                continue;\n            }\n\n            $keyValuePair = explode('=', $param, 2);\n\n            // GET parameters, that are submitted from a HTML form, encode spaces as \"+\" by default (as defined in enctype application/x-www-form-urlencoded).\n            // PHP also converts \"+\" to spaces when filling the global _GET or when using the function parse_str. This is why we use urldecode and then normalize to\n            // RFC 3986 with rawurlencode.\n            $parts[] = isset($keyValuePair[1]) ?\n                rawurlencode(urldecode($keyValuePair[0])).'='.rawurlencode(urldecode($keyValuePair[1])) :\n                rawurlencode(urldecode($keyValuePair[0]));\n            $order[] = urldecode($keyValuePair[0]);\n        }\n\n        array_multisort($order, SORT_ASC, $parts);\n\n        return implode('&', $parts);\n    }\n\n    /**\n     * Enables support for the _method request parameter to determine the intended HTTP method.\n     *\n     * Be warned that enabling this feature might lead to CSRF issues in your code.\n     * Check that you are using CSRF tokens when required.\n     * If the HTTP method parameter override is enabled, an html-form with method \"POST\" can be altered\n     * and used to send a \"PUT\" or \"DELETE\" request via the _method request parameter.\n     * If these methods are not protected against CSRF, this presents a possible vulnerability.\n     *\n     * The HTTP method can only be overridden when the real HTTP method is POST.\n     */\n    public static function enableHttpMethodParameterOverride()\n    {\n        self::$httpMethodParameterOverride = true;\n    }\n\n    /**\n     * Checks whether support for the _method request parameter is enabled.\n     *\n     * @return bool True when the _method request parameter is enabled, false otherwise\n     */\n    public static function getHttpMethodParameterOverride()\n    {\n        return self::$httpMethodParameterOverride;\n    }\n\n    /**\n     * Gets a \"parameter\" value from any bag.\n     *\n     * This method is mainly useful for libraries that want to provide some flexibility. If you don't need the\n     * flexibility in controllers, it is better to explicitly get request parameters from the appropriate\n     * public property instead (attributes, query, request).\n     *\n     * Order of precedence: PATH (routing placeholders or custom attributes), GET, BODY\n     *\n     * @param string $key     The key\n     * @param mixed  $default The default value if the parameter key does not exist\n     *\n     * @return mixed\n     */\n    public function get($key, $default = null)\n    {\n        if ($this !== $result = $this->attributes->get($key, $this)) {\n            return $result;\n        }\n\n        if ($this !== $result = $this->query->get($key, $this)) {\n            return $result;\n        }\n\n        if ($this !== $result = $this->request->get($key, $this)) {\n            return $result;\n        }\n\n        return $default;\n    }\n\n    /**\n     * Gets the Session.\n     *\n     * @return SessionInterface|null The session\n     */\n    public function getSession()\n    {\n        return $this->session;\n    }\n\n    /**\n     * Whether the request contains a Session which was started in one of the\n     * previous requests.\n     *\n     * @return bool\n     */\n    public function hasPreviousSession()\n    {\n        // the check for $this->session avoids malicious users trying to fake a session cookie with proper name\n        return $this->hasSession() && $this->cookies->has($this->session->getName());\n    }\n\n    /**\n     * Whether the request contains a Session object.\n     *\n     * This method does not give any information about the state of the session object,\n     * like whether the session is started or not. It is just a way to check if this Request\n     * is associated with a Session instance.\n     *\n     * @return bool true when the Request contains a Session object, false otherwise\n     */\n    public function hasSession()\n    {\n        return null !== $this->session;\n    }\n\n    /**\n     * Sets the Session.\n     *\n     * @param SessionInterface $session The Session\n     */\n    public function setSession(SessionInterface $session)\n    {\n        $this->session = $session;\n    }\n\n    /**\n     * Returns the client IP addresses.\n     *\n     * In the returned array the most trusted IP address is first, and the\n     * least trusted one last. The \"real\" client IP address is the last one,\n     * but this is also the least trusted one. Trusted proxies are stripped.\n     *\n     * Use this method carefully; you should use getClientIp() instead.\n     *\n     * @return array The client IP addresses\n     *\n     * @see getClientIp()\n     */\n    public function getClientIps()\n    {\n        $ip = $this->server->get('REMOTE_ADDR');\n\n        if (!$this->isFromTrustedProxy()) {\n            return [$ip];\n        }\n\n        return $this->getTrustedValues(self::HEADER_CLIENT_IP, $ip) ?: [$ip];\n    }\n\n    /**\n     * Returns the client IP address.\n     *\n     * This method can read the client IP address from the \"X-Forwarded-For\" header\n     * when trusted proxies were set via \"setTrustedProxies()\". The \"X-Forwarded-For\"\n     * header value is a comma+space separated list of IP addresses, the left-most\n     * being the original client, and each successive proxy that passed the request\n     * adding the IP address where it received the request from.\n     *\n     * If your reverse proxy uses a different header name than \"X-Forwarded-For\",\n     * (\"Client-Ip\" for instance), configure it via the $trustedHeaderSet\n     * argument of the Request::setTrustedProxies() method instead.\n     *\n     * @return string|null The client IP address\n     *\n     * @see getClientIps()\n     * @see http://en.wikipedia.org/wiki/X-Forwarded-For\n     */\n    public function getClientIp()\n    {\n        $ipAddresses = $this->getClientIps();\n\n        return $ipAddresses[0];\n    }\n\n    /**\n     * Returns current script name.\n     *\n     * @return string\n     */\n    public function getScriptName()\n    {\n        return $this->server->get('SCRIPT_NAME', $this->server->get('ORIG_SCRIPT_NAME', ''));\n    }\n\n    /**\n     * Returns the path being requested relative to the executed script.\n     *\n     * The path info always starts with a /.\n     *\n     * Suppose this request is instantiated from /mysite on localhost:\n     *\n     *  * http://localhost/mysite              returns an empty string\n     *  * http://localhost/mysite/about        returns '/about'\n     *  * http://localhost/mysite/enco%20ded   returns '/enco%20ded'\n     *  * http://localhost/mysite/about?var=1  returns '/about'\n     *\n     * @return string The raw path (i.e. not urldecoded)\n     */\n    public function getPathInfo()\n    {\n        if (null === $this->pathInfo) {\n            $this->pathInfo = $this->preparePathInfo();\n        }\n\n        return $this->pathInfo;\n    }\n\n    /**\n     * Returns the root path from which this request is executed.\n     *\n     * Suppose that an index.php file instantiates this request object:\n     *\n     *  * http://localhost/index.php         returns an empty string\n     *  * http://localhost/index.php/page    returns an empty string\n     *  * http://localhost/web/index.php     returns '/web'\n     *  * http://localhost/we%20b/index.php  returns '/we%20b'\n     *\n     * @return string The raw path (i.e. not urldecoded)\n     */\n    public function getBasePath()\n    {\n        if (null === $this->basePath) {\n            $this->basePath = $this->prepareBasePath();\n        }\n\n        return $this->basePath;\n    }\n\n    /**\n     * Returns the root URL from which this request is executed.\n     *\n     * The base URL never ends with a /.\n     *\n     * This is similar to getBasePath(), except that it also includes the\n     * script filename (e.g. index.php) if one exists.\n     *\n     * @return string The raw URL (i.e. not urldecoded)\n     */\n    public function getBaseUrl()\n    {\n        if (null === $this->baseUrl) {\n            $this->baseUrl = $this->prepareBaseUrl();\n        }\n\n        return $this->baseUrl;\n    }\n\n    /**\n     * Gets the request's scheme.\n     *\n     * @return string\n     */\n    public function getScheme()\n    {\n        return $this->isSecure() ? 'https' : 'http';\n    }\n\n    /**\n     * Returns the port on which the request is made.\n     *\n     * This method can read the client port from the \"X-Forwarded-Port\" header\n     * when trusted proxies were set via \"setTrustedProxies()\".\n     *\n     * The \"X-Forwarded-Port\" header must contain the client port.\n     *\n     * If your reverse proxy uses a different header name than \"X-Forwarded-Port\",\n     * configure it via via the $trustedHeaderSet argument of the\n     * Request::setTrustedProxies() method instead.\n     *\n     * @return int|string can be a string if fetched from the server bag\n     */\n    public function getPort()\n    {\n        if ($this->isFromTrustedProxy() && $host = $this->getTrustedValues(self::HEADER_CLIENT_PORT)) {\n            $host = $host[0];\n        } elseif ($this->isFromTrustedProxy() && $host = $this->getTrustedValues(self::HEADER_CLIENT_HOST)) {\n            $host = $host[0];\n        } elseif (!$host = $this->headers->get('HOST')) {\n            return $this->server->get('SERVER_PORT');\n        }\n\n        if ('[' === $host[0]) {\n            $pos = strpos($host, ':', strrpos($host, ']'));\n        } else {\n            $pos = strrpos($host, ':');\n        }\n\n        if (false !== $pos) {\n            return (int) substr($host, $pos + 1);\n        }\n\n        return 'https' === $this->getScheme() ? 443 : 80;\n    }\n\n    /**\n     * Returns the user.\n     *\n     * @return string|null\n     */\n    public function getUser()\n    {\n        return $this->headers->get('PHP_AUTH_USER');\n    }\n\n    /**\n     * Returns the password.\n     *\n     * @return string|null\n     */\n    public function getPassword()\n    {\n        return $this->headers->get('PHP_AUTH_PW');\n    }\n\n    /**\n     * Gets the user info.\n     *\n     * @return string A user name and, optionally, scheme-specific information about how to gain authorization to access the server\n     */\n    public function getUserInfo()\n    {\n        $userinfo = $this->getUser();\n\n        $pass = $this->getPassword();\n        if ('' != $pass) {\n            $userinfo .= \":$pass\";\n        }\n\n        return $userinfo;\n    }\n\n    /**\n     * Returns the HTTP host being requested.\n     *\n     * The port name will be appended to the host if it's non-standard.\n     *\n     * @return string\n     */\n    public function getHttpHost()\n    {\n        $scheme = $this->getScheme();\n        $port = $this->getPort();\n\n        if (('http' == $scheme && 80 == $port) || ('https' == $scheme && 443 == $port)) {\n            return $this->getHost();\n        }\n\n        return $this->getHost().':'.$port;\n    }\n\n    /**\n     * Returns the requested URI (path and query string).\n     *\n     * @return string The raw URI (i.e. not URI decoded)\n     */\n    public function getRequestUri()\n    {\n        if (null === $this->requestUri) {\n            $this->requestUri = $this->prepareRequestUri();\n        }\n\n        return $this->requestUri;\n    }\n\n    /**\n     * Gets the scheme and HTTP host.\n     *\n     * If the URL was called with basic authentication, the user\n     * and the password are not added to the generated string.\n     *\n     * @return string The scheme and HTTP host\n     */\n    public function getSchemeAndHttpHost()\n    {\n        return $this->getScheme().'://'.$this->getHttpHost();\n    }\n\n    /**\n     * Generates a normalized URI (URL) for the Request.\n     *\n     * @return string A normalized URI (URL) for the Request\n     *\n     * @see getQueryString()\n     */\n    public function getUri()\n    {\n        if (null !== $qs = $this->getQueryString()) {\n            $qs = '?'.$qs;\n        }\n\n        return $this->getSchemeAndHttpHost().$this->getBaseUrl().$this->getPathInfo().$qs;\n    }\n\n    /**\n     * Generates a normalized URI for the given path.\n     *\n     * @param string $path A path to use instead of the current one\n     *\n     * @return string The normalized URI for the path\n     */\n    public function getUriForPath($path)\n    {\n        return $this->getSchemeAndHttpHost().$this->getBaseUrl().$path;\n    }\n\n    /**\n     * Returns the path as relative reference from the current Request path.\n     *\n     * Only the URIs path component (no schema, host etc.) is relevant and must be given.\n     * Both paths must be absolute and not contain relative parts.\n     * Relative URLs from one resource to another are useful when generating self-contained downloadable document archives.\n     * Furthermore, they can be used to reduce the link size in documents.\n     *\n     * Example target paths, given a base path of \"/a/b/c/d\":\n     * - \"/a/b/c/d\"     -> \"\"\n     * - \"/a/b/c/\"      -> \"./\"\n     * - \"/a/b/\"        -> \"../\"\n     * - \"/a/b/c/other\" -> \"other\"\n     * - \"/a/x/y\"       -> \"../../x/y\"\n     *\n     * @param string $path The target path\n     *\n     * @return string The relative target path\n     */\n    public function getRelativeUriForPath($path)\n    {\n        // be sure that we are dealing with an absolute path\n        if (!isset($path[0]) || '/' !== $path[0]) {\n            return $path;\n        }\n\n        if ($path === $basePath = $this->getPathInfo()) {\n            return '';\n        }\n\n        $sourceDirs = explode('/', isset($basePath[0]) && '/' === $basePath[0] ? substr($basePath, 1) : $basePath);\n        $targetDirs = explode('/', substr($path, 1));\n        array_pop($sourceDirs);\n        $targetFile = array_pop($targetDirs);\n\n        foreach ($sourceDirs as $i => $dir) {\n            if (isset($targetDirs[$i]) && $dir === $targetDirs[$i]) {\n                unset($sourceDirs[$i], $targetDirs[$i]);\n            } else {\n                break;\n            }\n        }\n\n        $targetDirs[] = $targetFile;\n        $path = str_repeat('../', \\count($sourceDirs)).implode('/', $targetDirs);\n\n        // A reference to the same base directory or an empty subdirectory must be prefixed with \"./\".\n        // This also applies to a segment with a colon character (e.g., \"file:colon\") that cannot be used\n        // as the first segment of a relative-path reference, as it would be mistaken for a scheme name\n        // (see http://tools.ietf.org/html/rfc3986#section-4.2).\n        return !isset($path[0]) || '/' === $path[0]\n            || false !== ($colonPos = strpos($path, ':')) && ($colonPos < ($slashPos = strpos($path, '/')) || false === $slashPos)\n            ? \"./$path\" : $path;\n    }\n\n    /**\n     * Generates the normalized query string for the Request.\n     *\n     * It builds a normalized query string, where keys/value pairs are alphabetized\n     * and have consistent escaping.\n     *\n     * @return string|null A normalized query string for the Request\n     */\n    public function getQueryString()\n    {\n        $qs = static::normalizeQueryString($this->server->get('QUERY_STRING'));\n\n        return '' === $qs ? null : $qs;\n    }\n\n    /**\n     * Checks whether the request is secure or not.\n     *\n     * This method can read the client protocol from the \"X-Forwarded-Proto\" header\n     * when trusted proxies were set via \"setTrustedProxies()\".\n     *\n     * The \"X-Forwarded-Proto\" header must contain the protocol: \"https\" or \"http\".\n     *\n     * If your reverse proxy uses a different header name than \"X-Forwarded-Proto\"\n     * (\"SSL_HTTPS\" for instance), configure it via the $trustedHeaderSet\n     * argument of the Request::setTrustedProxies() method instead.\n     *\n     * @return bool\n     */\n    public function isSecure()\n    {\n        if ($this->isFromTrustedProxy() && $proto = $this->getTrustedValues(self::HEADER_CLIENT_PROTO)) {\n            return \\in_array(strtolower($proto[0]), ['https', 'on', 'ssl', '1'], true);\n        }\n\n        $https = $this->server->get('HTTPS');\n\n        return !empty($https) && 'off' !== strtolower($https);\n    }\n\n    /**\n     * Returns the host name.\n     *\n     * This method can read the client host name from the \"X-Forwarded-Host\" header\n     * when trusted proxies were set via \"setTrustedProxies()\".\n     *\n     * The \"X-Forwarded-Host\" header must contain the client host name.\n     *\n     * If your reverse proxy uses a different header name than \"X-Forwarded-Host\",\n     * configure it via the $trustedHeaderSet argument of the\n     * Request::setTrustedProxies() method instead.\n     *\n     * @return string\n     *\n     * @throws SuspiciousOperationException when the host name is invalid or not trusted\n     */\n    public function getHost()\n    {\n        if ($this->isFromTrustedProxy() && $host = $this->getTrustedValues(self::HEADER_CLIENT_HOST)) {\n            $host = $host[0];\n        } elseif (!$host = $this->headers->get('HOST')) {\n            if (!$host = $this->server->get('SERVER_NAME')) {\n                $host = $this->server->get('SERVER_ADDR', '');\n            }\n        }\n\n        // trim and remove port number from host\n        // host is lowercase as per RFC 952/2181\n        $host = strtolower(preg_replace('/:\\d+$/', '', trim($host)));\n\n        // as the host can come from the user (HTTP_HOST and depending on the configuration, SERVER_NAME too can come from the user)\n        // check that it does not contain forbidden characters (see RFC 952 and RFC 2181)\n        // use preg_replace() instead of preg_match() to prevent DoS attacks with long host names\n        if ($host && '' !== preg_replace('/(?:^\\[)?[a-zA-Z0-9-:\\]_]+\\.?/', '', $host)) {\n            if (!$this->isHostValid) {\n                return '';\n            }\n            $this->isHostValid = false;\n\n            throw new SuspiciousOperationException(sprintf('Invalid Host \"%s\".', $host));\n        }\n\n        if (\\count(self::$trustedHostPatterns) > 0) {\n            // to avoid host header injection attacks, you should provide a list of trusted host patterns\n\n            if (\\in_array($host, self::$trustedHosts)) {\n                return $host;\n            }\n\n            foreach (self::$trustedHostPatterns as $pattern) {\n                if (preg_match($pattern, $host)) {\n                    self::$trustedHosts[] = $host;\n\n                    return $host;\n                }\n            }\n\n            if (!$this->isHostValid) {\n                return '';\n            }\n            $this->isHostValid = false;\n\n            throw new SuspiciousOperationException(sprintf('Untrusted Host \"%s\".', $host));\n        }\n\n        return $host;\n    }\n\n    /**\n     * Sets the request method.\n     *\n     * @param string $method\n     */\n    public function setMethod($method)\n    {\n        $this->method = null;\n        $this->server->set('REQUEST_METHOD', $method);\n    }\n\n    /**\n     * Gets the request \"intended\" method.\n     *\n     * If the X-HTTP-Method-Override header is set, and if the method is a POST,\n     * then it is used to determine the \"real\" intended HTTP method.\n     *\n     * The _method request parameter can also be used to determine the HTTP method,\n     * but only if enableHttpMethodParameterOverride() has been called.\n     *\n     * The method is always an uppercased string.\n     *\n     * @return string The request method\n     *\n     * @see getRealMethod()\n     */\n    public function getMethod()\n    {\n        if (null === $this->method) {\n            $this->method = strtoupper($this->server->get('REQUEST_METHOD', 'GET'));\n\n            if ('POST' === $this->method) {\n                if ($method = $this->headers->get('X-HTTP-METHOD-OVERRIDE')) {\n                    $this->method = strtoupper($method);\n                } elseif (self::$httpMethodParameterOverride) {\n                    $method = $this->request->get('_method', $this->query->get('_method', 'POST'));\n                    if (\\is_string($method)) {\n                        $this->method = strtoupper($method);\n                    }\n                }\n            }\n        }\n\n        return $this->method;\n    }\n\n    /**\n     * Gets the \"real\" request method.\n     *\n     * @return string The request method\n     *\n     * @see getMethod()\n     */\n    public function getRealMethod()\n    {\n        return strtoupper($this->server->get('REQUEST_METHOD', 'GET'));\n    }\n\n    /**\n     * Gets the mime type associated with the format.\n     *\n     * @param string $format The format\n     *\n     * @return string|null The associated mime type (null if not found)\n     */\n    public function getMimeType($format)\n    {\n        if (null === static::$formats) {\n            static::initializeFormats();\n        }\n\n        return isset(static::$formats[$format]) ? static::$formats[$format][0] : null;\n    }\n\n    /**\n     * Gets the mime types associated with the format.\n     *\n     * @param string $format The format\n     *\n     * @return array The associated mime types\n     */\n    public static function getMimeTypes($format)\n    {\n        if (null === static::$formats) {\n            static::initializeFormats();\n        }\n\n        return isset(static::$formats[$format]) ? static::$formats[$format] : [];\n    }\n\n    /**\n     * Gets the format associated with the mime type.\n     *\n     * @param string $mimeType The associated mime type\n     *\n     * @return string|null The format (null if not found)\n     */\n    public function getFormat($mimeType)\n    {\n        $canonicalMimeType = null;\n        if (false !== $pos = strpos($mimeType, ';')) {\n            $canonicalMimeType = trim(substr($mimeType, 0, $pos));\n        }\n\n        if (null === static::$formats) {\n            static::initializeFormats();\n        }\n\n        foreach (static::$formats as $format => $mimeTypes) {\n            if (\\in_array($mimeType, (array) $mimeTypes)) {\n                return $format;\n            }\n            if (null !== $canonicalMimeType && \\in_array($canonicalMimeType, (array) $mimeTypes)) {\n                return $format;\n            }\n        }\n    }\n\n    /**\n     * Associates a format with mime types.\n     *\n     * @param string       $format    The format\n     * @param string|array $mimeTypes The associated mime types (the preferred one must be the first as it will be used as the content type)\n     */\n    public function setFormat($format, $mimeTypes)\n    {\n        if (null === static::$formats) {\n            static::initializeFormats();\n        }\n\n        static::$formats[$format] = \\is_array($mimeTypes) ? $mimeTypes : [$mimeTypes];\n    }\n\n    /**\n     * Gets the request format.\n     *\n     * Here is the process to determine the format:\n     *\n     *  * format defined by the user (with setRequestFormat())\n     *  * _format request attribute\n     *  * $default\n     *\n     * @param string|null $default The default format\n     *\n     * @return string|null The request format\n     */\n    public function getRequestFormat($default = 'html')\n    {\n        if (null === $this->format) {\n            $this->format = $this->attributes->get('_format');\n        }\n\n        return null === $this->format ? $default : $this->format;\n    }\n\n    /**\n     * Sets the request format.\n     *\n     * @param string $format The request format\n     */\n    public function setRequestFormat($format)\n    {\n        $this->format = $format;\n    }\n\n    /**\n     * Gets the format associated with the request.\n     *\n     * @return string|null The format (null if no content type is present)\n     */\n    public function getContentType()\n    {\n        return $this->getFormat($this->headers->get('CONTENT_TYPE'));\n    }\n\n    /**\n     * Sets the default locale.\n     *\n     * @param string $locale\n     */\n    public function setDefaultLocale($locale)\n    {\n        $this->defaultLocale = $locale;\n\n        if (null === $this->locale) {\n            $this->setPhpDefaultLocale($locale);\n        }\n    }\n\n    /**\n     * Get the default locale.\n     *\n     * @return string\n     */\n    public function getDefaultLocale()\n    {\n        return $this->defaultLocale;\n    }\n\n    /**\n     * Sets the locale.\n     *\n     * @param string $locale\n     */\n    public function setLocale($locale)\n    {\n        $this->setPhpDefaultLocale($this->locale = $locale);\n    }\n\n    /**\n     * Get the locale.\n     *\n     * @return string\n     */\n    public function getLocale()\n    {\n        return null === $this->locale ? $this->defaultLocale : $this->locale;\n    }\n\n    /**\n     * Checks if the request method is of specified type.\n     *\n     * @param string $method Uppercase request method (GET, POST etc)\n     *\n     * @return bool\n     */\n    public function isMethod($method)\n    {\n        return $this->getMethod() === strtoupper($method);\n    }\n\n    /**\n     * Checks whether or not the method is safe.\n     *\n     * @see https://tools.ietf.org/html/rfc7231#section-4.2.1\n     *\n     * @param bool $andCacheable Adds the additional condition that the method should be cacheable. True by default.\n     *\n     * @return bool\n     */\n    public function isMethodSafe(/* $andCacheable = true */)\n    {\n        if (!\\func_num_args() || func_get_arg(0)) {\n            // This deprecation should be turned into a BadMethodCallException in 4.0 (without adding the argument in the signature)\n            // then setting $andCacheable to false should be deprecated in 4.1\n            @trigger_error('Checking only for cacheable HTTP methods with Symfony\\Component\\HttpFoundation\\Request::isMethodSafe() is deprecated since Symfony 3.2 and will throw an exception in 4.0. Disable checking only for cacheable methods by calling the method with `false` as first argument or use the Request::isMethodCacheable() instead.', E_USER_DEPRECATED);\n\n            return \\in_array($this->getMethod(), ['GET', 'HEAD']);\n        }\n\n        return \\in_array($this->getMethod(), ['GET', 'HEAD', 'OPTIONS', 'TRACE']);\n    }\n\n    /**\n     * Checks whether or not the method is idempotent.\n     *\n     * @return bool\n     */\n    public function isMethodIdempotent()\n    {\n        return \\in_array($this->getMethod(), ['HEAD', 'GET', 'PUT', 'DELETE', 'TRACE', 'OPTIONS', 'PURGE']);\n    }\n\n    /**\n     * Checks whether the method is cacheable or not.\n     *\n     * @see https://tools.ietf.org/html/rfc7231#section-4.2.3\n     *\n     * @return bool True for GET and HEAD, false otherwise\n     */\n    public function isMethodCacheable()\n    {\n        return \\in_array($this->getMethod(), ['GET', 'HEAD']);\n    }\n\n    /**\n     * Returns the protocol version.\n     *\n     * If the application is behind a proxy, the protocol version used in the\n     * requests between the client and the proxy and between the proxy and the\n     * server might be different. This returns the former (from the \"Via\" header)\n     * if the proxy is trusted (see \"setTrustedProxies()\"), otherwise it returns\n     * the latter (from the \"SERVER_PROTOCOL\" server parameter).\n     *\n     * @return string\n     */\n    public function getProtocolVersion()\n    {\n        if ($this->isFromTrustedProxy()) {\n            preg_match('~^(HTTP/)?([1-9]\\.[0-9]) ~', $this->headers->get('Via'), $matches);\n\n            if ($matches) {\n                return 'HTTP/'.$matches[2];\n            }\n        }\n\n        return $this->server->get('SERVER_PROTOCOL');\n    }\n\n    /**\n     * Returns the request body content.\n     *\n     * @param bool $asResource If true, a resource will be returned\n     *\n     * @return string|resource The request body content or a resource to read the body stream\n     *\n     * @throws \\LogicException\n     */\n    public function getContent($asResource = false)\n    {\n        $currentContentIsResource = \\is_resource($this->content);\n        if (\\PHP_VERSION_ID < 50600 && false === $this->content) {\n            throw new \\LogicException('getContent() can only be called once when using the resource return type and PHP below 5.6.');\n        }\n\n        if (true === $asResource) {\n            if ($currentContentIsResource) {\n                rewind($this->content);\n\n                return $this->content;\n            }\n\n            // Content passed in parameter (test)\n            if (\\is_string($this->content)) {\n                $resource = fopen('php://temp', 'r+');\n                fwrite($resource, $this->content);\n                rewind($resource);\n\n                return $resource;\n            }\n\n            $this->content = false;\n\n            return fopen('php://input', 'rb');\n        }\n\n        if ($currentContentIsResource) {\n            rewind($this->content);\n\n            return stream_get_contents($this->content);\n        }\n\n        if (null === $this->content || false === $this->content) {\n            $this->content = file_get_contents('php://input');\n        }\n\n        return $this->content;\n    }\n\n    /**\n     * Gets the Etags.\n     *\n     * @return array The entity tags\n     */\n    public function getETags()\n    {\n        return preg_split('/\\s*,\\s*/', $this->headers->get('if_none_match'), null, PREG_SPLIT_NO_EMPTY);\n    }\n\n    /**\n     * @return bool\n     */\n    public function isNoCache()\n    {\n        return $this->headers->hasCacheControlDirective('no-cache') || 'no-cache' == $this->headers->get('Pragma');\n    }\n\n    /**\n     * Returns the preferred language.\n     *\n     * @param array $locales An array of ordered available locales\n     *\n     * @return string|null The preferred locale\n     */\n    public function getPreferredLanguage(array $locales = null)\n    {\n        $preferredLanguages = $this->getLanguages();\n\n        if (empty($locales)) {\n            return isset($preferredLanguages[0]) ? $preferredLanguages[0] : null;\n        }\n\n        if (!$preferredLanguages) {\n            return $locales[0];\n        }\n\n        $extendedPreferredLanguages = [];\n        foreach ($preferredLanguages as $language) {\n            $extendedPreferredLanguages[] = $language;\n            if (false !== $position = strpos($language, '_')) {\n                $superLanguage = substr($language, 0, $position);\n                if (!\\in_array($superLanguage, $preferredLanguages)) {\n                    $extendedPreferredLanguages[] = $superLanguage;\n                }\n            }\n        }\n\n        $preferredLanguages = array_values(array_intersect($extendedPreferredLanguages, $locales));\n\n        return isset($preferredLanguages[0]) ? $preferredLanguages[0] : $locales[0];\n    }\n\n    /**\n     * Gets a list of languages acceptable by the client browser.\n     *\n     * @return array Languages ordered in the user browser preferences\n     */\n    public function getLanguages()\n    {\n        if (null !== $this->languages) {\n            return $this->languages;\n        }\n\n        $languages = AcceptHeader::fromString($this->headers->get('Accept-Language'))->all();\n        $this->languages = [];\n        foreach ($languages as $lang => $acceptHeaderItem) {\n            if (false !== strpos($lang, '-')) {\n                $codes = explode('-', $lang);\n                if ('i' === $codes[0]) {\n                    // Language not listed in ISO 639 that are not variants\n                    // of any listed language, which can be registered with the\n                    // i-prefix, such as i-cherokee\n                    if (\\count($codes) > 1) {\n                        $lang = $codes[1];\n                    }\n                } else {\n                    for ($i = 0, $max = \\count($codes); $i < $max; ++$i) {\n                        if (0 === $i) {\n                            $lang = strtolower($codes[0]);\n                        } else {\n                            $lang .= '_'.strtoupper($codes[$i]);\n                        }\n                    }\n                }\n            }\n\n            $this->languages[] = $lang;\n        }\n\n        return $this->languages;\n    }\n\n    /**\n     * Gets a list of charsets acceptable by the client browser.\n     *\n     * @return array List of charsets in preferable order\n     */\n    public function getCharsets()\n    {\n        if (null !== $this->charsets) {\n            return $this->charsets;\n        }\n\n        return $this->charsets = array_keys(AcceptHeader::fromString($this->headers->get('Accept-Charset'))->all());\n    }\n\n    /**\n     * Gets a list of encodings acceptable by the client browser.\n     *\n     * @return array List of encodings in preferable order\n     */\n    public function getEncodings()\n    {\n        if (null !== $this->encodings) {\n            return $this->encodings;\n        }\n\n        return $this->encodings = array_keys(AcceptHeader::fromString($this->headers->get('Accept-Encoding'))->all());\n    }\n\n    /**\n     * Gets a list of content types acceptable by the client browser.\n     *\n     * @return array List of content types in preferable order\n     */\n    public function getAcceptableContentTypes()\n    {\n        if (null !== $this->acceptableContentTypes) {\n            return $this->acceptableContentTypes;\n        }\n\n        return $this->acceptableContentTypes = array_keys(AcceptHeader::fromString($this->headers->get('Accept'))->all());\n    }\n\n    /**\n     * Returns true if the request is a XMLHttpRequest.\n     *\n     * It works if your JavaScript library sets an X-Requested-With HTTP header.\n     * It is known to work with common JavaScript frameworks:\n     *\n     * @see http://en.wikipedia.org/wiki/List_of_Ajax_frameworks#JavaScript\n     *\n     * @return bool true if the request is an XMLHttpRequest, false otherwise\n     */\n    public function isXmlHttpRequest()\n    {\n        return 'XMLHttpRequest' == $this->headers->get('X-Requested-With');\n    }\n\n    /*\n     * The following methods are derived from code of the Zend Framework (1.10dev - 2010-01-24)\n     *\n     * Code subject to the new BSD license (http://framework.zend.com/license/new-bsd).\n     *\n     * Copyright (c) 2005-2010 Zend Technologies USA Inc. (http://www.zend.com)\n     */\n\n    protected function prepareRequestUri()\n    {\n        $requestUri = '';\n\n        if ('1' == $this->server->get('IIS_WasUrlRewritten') && '' != $this->server->get('UNENCODED_URL')) {\n            // IIS7 with URL Rewrite: make sure we get the unencoded URL (double slash problem)\n            $requestUri = $this->server->get('UNENCODED_URL');\n            $this->server->remove('UNENCODED_URL');\n            $this->server->remove('IIS_WasUrlRewritten');\n        } elseif ($this->server->has('REQUEST_URI')) {\n            $requestUri = $this->server->get('REQUEST_URI');\n\n            if ('' !== $requestUri && '/' === $requestUri[0]) {\n                // To only use path and query remove the fragment.\n                if (false !== $pos = strpos($requestUri, '#')) {\n                    $requestUri = substr($requestUri, 0, $pos);\n                }\n            } else {\n                // HTTP proxy reqs setup request URI with scheme and host [and port] + the URL path,\n                // only use URL path.\n                $uriComponents = parse_url($requestUri);\n\n                if (isset($uriComponents['path'])) {\n                    $requestUri = $uriComponents['path'];\n                }\n\n                if (isset($uriComponents['query'])) {\n                    $requestUri .= '?'.$uriComponents['query'];\n                }\n            }\n        } elseif ($this->server->has('ORIG_PATH_INFO')) {\n            // IIS 5.0, PHP as CGI\n            $requestUri = $this->server->get('ORIG_PATH_INFO');\n            if ('' != $this->server->get('QUERY_STRING')) {\n                $requestUri .= '?'.$this->server->get('QUERY_STRING');\n            }\n            $this->server->remove('ORIG_PATH_INFO');\n        }\n\n        // normalize the request URI to ease creating sub-requests from this request\n        $this->server->set('REQUEST_URI', $requestUri);\n\n        return $requestUri;\n    }\n\n    /**\n     * Prepares the base URL.\n     *\n     * @return string\n     */\n    protected function prepareBaseUrl()\n    {\n        $filename = basename($this->server->get('SCRIPT_FILENAME'));\n\n        if (basename($this->server->get('SCRIPT_NAME')) === $filename) {\n            $baseUrl = $this->server->get('SCRIPT_NAME');\n        } elseif (basename($this->server->get('PHP_SELF')) === $filename) {\n            $baseUrl = $this->server->get('PHP_SELF');\n        } elseif (basename($this->server->get('ORIG_SCRIPT_NAME')) === $filename) {\n            $baseUrl = $this->server->get('ORIG_SCRIPT_NAME'); // 1and1 shared hosting compatibility\n        } else {\n            // Backtrack up the script_filename to find the portion matching\n            // php_self\n            $path = $this->server->get('PHP_SELF', '');\n            $file = $this->server->get('SCRIPT_FILENAME', '');\n            $segs = explode('/', trim($file, '/'));\n            $segs = array_reverse($segs);\n            $index = 0;\n            $last = \\count($segs);\n            $baseUrl = '';\n            do {\n                $seg = $segs[$index];\n                $baseUrl = '/'.$seg.$baseUrl;\n                ++$index;\n            } while ($last > $index && (false !== $pos = strpos($path, $baseUrl)) && 0 != $pos);\n        }\n\n        // Does the baseUrl have anything in common with the request_uri?\n        $requestUri = $this->getRequestUri();\n        if ('' !== $requestUri && '/' !== $requestUri[0]) {\n            $requestUri = '/'.$requestUri;\n        }\n\n        if ($baseUrl && false !== $prefix = $this->getUrlencodedPrefix($requestUri, $baseUrl)) {\n            // full $baseUrl matches\n            return $prefix;\n        }\n\n        if ($baseUrl && false !== $prefix = $this->getUrlencodedPrefix($requestUri, rtrim(\\dirname($baseUrl), '/'.\\DIRECTORY_SEPARATOR).'/')) {\n            // directory portion of $baseUrl matches\n            return rtrim($prefix, '/'.\\DIRECTORY_SEPARATOR);\n        }\n\n        $truncatedRequestUri = $requestUri;\n        if (false !== $pos = strpos($requestUri, '?')) {\n            $truncatedRequestUri = substr($requestUri, 0, $pos);\n        }\n\n        $basename = basename($baseUrl);\n        if (empty($basename) || !strpos(rawurldecode($truncatedRequestUri), $basename)) {\n            // no match whatsoever; set it blank\n            return '';\n        }\n\n        // If using mod_rewrite or ISAPI_Rewrite strip the script filename\n        // out of baseUrl. $pos !== 0 makes sure it is not matching a value\n        // from PATH_INFO or QUERY_STRING\n        if (\\strlen($requestUri) >= \\strlen($baseUrl) && (false !== $pos = strpos($requestUri, $baseUrl)) && 0 !== $pos) {\n            $baseUrl = substr($requestUri, 0, $pos + \\strlen($baseUrl));\n        }\n\n        return rtrim($baseUrl, '/'.\\DIRECTORY_SEPARATOR);\n    }\n\n    /**\n     * Prepares the base path.\n     *\n     * @return string base path\n     */\n    protected function prepareBasePath()\n    {\n        $baseUrl = $this->getBaseUrl();\n        if (empty($baseUrl)) {\n            return '';\n        }\n\n        $filename = basename($this->server->get('SCRIPT_FILENAME'));\n        if (basename($baseUrl) === $filename) {\n            $basePath = \\dirname($baseUrl);\n        } else {\n            $basePath = $baseUrl;\n        }\n\n        if ('\\\\' === \\DIRECTORY_SEPARATOR) {\n            $basePath = str_replace('\\\\', '/', $basePath);\n        }\n\n        return rtrim($basePath, '/');\n    }\n\n    /**\n     * Prepares the path info.\n     *\n     * @return string path info\n     */\n    protected function preparePathInfo()\n    {\n        if (null === ($requestUri = $this->getRequestUri())) {\n            return '/';\n        }\n\n        // Remove the query string from REQUEST_URI\n        if (false !== $pos = strpos($requestUri, '?')) {\n            $requestUri = substr($requestUri, 0, $pos);\n        }\n        if ('' !== $requestUri && '/' !== $requestUri[0]) {\n            $requestUri = '/'.$requestUri;\n        }\n\n        if (null === ($baseUrl = $this->getBaseUrl())) {\n            return $requestUri;\n        }\n\n        $pathInfo = substr($requestUri, \\strlen($baseUrl));\n        if (false === $pathInfo || '' === $pathInfo) {\n            // If substr() returns false then PATH_INFO is set to an empty string\n            return '/';\n        }\n\n        return (string) $pathInfo;\n    }\n\n    /**\n     * Initializes HTTP request formats.\n     */\n    protected static function initializeFormats()\n    {\n        static::$formats = [\n            'html' => ['text/html', 'application/xhtml+xml'],\n            'txt' => ['text/plain'],\n            'js' => ['application/javascript', 'application/x-javascript', 'text/javascript'],\n            'css' => ['text/css'],\n            'json' => ['application/json', 'application/x-json'],\n            'jsonld' => ['application/ld+json'],\n            'xml' => ['text/xml', 'application/xml', 'application/x-xml'],\n            'rdf' => ['application/rdf+xml'],\n            'atom' => ['application/atom+xml'],\n            'rss' => ['application/rss+xml'],\n            'form' => ['application/x-www-form-urlencoded'],\n        ];\n    }\n\n    /**\n     * Sets the default PHP locale.\n     *\n     * @param string $locale\n     */\n    private function setPhpDefaultLocale($locale)\n    {\n        // if either the class Locale doesn't exist, or an exception is thrown when\n        // setting the default locale, the intl module is not installed, and\n        // the call can be ignored:\n        try {\n            if (class_exists('Locale', false)) {\n                \\Locale::setDefault($locale);\n            }\n        } catch (\\Exception $e) {\n        }\n    }\n\n    /*\n     * Returns the prefix as encoded in the string when the string starts with\n     * the given prefix, false otherwise.\n     *\n     * @param string $string The urlencoded string\n     * @param string $prefix The prefix not encoded\n     *\n     * @return string|false The prefix as it is encoded in $string, or false\n     */\n    private function getUrlencodedPrefix($string, $prefix)\n    {\n        if (0 !== strpos(rawurldecode($string), $prefix)) {\n            return false;\n        }\n\n        $len = \\strlen($prefix);\n\n        if (preg_match(sprintf('#^(%%[[:xdigit:]]{2}|.){%d}#', $len), $string, $match)) {\n            return $match[0];\n        }\n\n        return false;\n    }\n\n    private static function createRequestFromFactory(array $query = [], array $request = [], array $attributes = [], array $cookies = [], array $files = [], array $server = [], $content = null)\n    {\n        if (self::$requestFactory) {\n            $request = \\call_user_func(self::$requestFactory, $query, $request, $attributes, $cookies, $files, $server, $content);\n\n            if (!$request instanceof self) {\n                throw new \\LogicException('The Request factory must return an instance of Symfony\\Component\\HttpFoundation\\Request.');\n            }\n\n            return $request;\n        }\n\n        return new static($query, $request, $attributes, $cookies, $files, $server, $content);\n    }\n\n    /**\n     * Indicates whether this request originated from a trusted proxy.\n     *\n     * This can be useful to determine whether or not to trust the\n     * contents of a proxy-specific header.\n     *\n     * @return bool true if the request came from a trusted proxy, false otherwise\n     */\n    public function isFromTrustedProxy()\n    {\n        return self::$trustedProxies && IpUtils::checkIp($this->server->get('REMOTE_ADDR'), self::$trustedProxies);\n    }\n\n    private function getTrustedValues($type, $ip = null)\n    {\n        $clientValues = [];\n        $forwardedValues = [];\n\n        if (self::$trustedHeaders[$type] && $this->headers->has(self::$trustedHeaders[$type])) {\n            foreach (explode(',', $this->headers->get(self::$trustedHeaders[$type])) as $v) {\n                $clientValues[] = (self::HEADER_CLIENT_PORT === $type ? '0.0.0.0:' : '').trim($v);\n            }\n        }\n\n        if (self::$trustedHeaders[self::HEADER_FORWARDED] && $this->headers->has(self::$trustedHeaders[self::HEADER_FORWARDED])) {\n            $forwardedValues = $this->headers->get(self::$trustedHeaders[self::HEADER_FORWARDED]);\n            $forwardedValues = preg_match_all(sprintf('{(?:%s)=\"?([a-zA-Z0-9\\.:_\\-/\\[\\]]*+)}', self::$forwardedParams[$type]), $forwardedValues, $matches) ? $matches[1] : [];\n            if (self::HEADER_CLIENT_PORT === $type) {\n                foreach ($forwardedValues as $k => $v) {\n                    if (']' === substr($v, -1) || false === $v = strrchr($v, ':')) {\n                        $v = $this->isSecure() ? ':443' : ':80';\n                    }\n                    $forwardedValues[$k] = '0.0.0.0'.$v;\n                }\n            }\n        }\n\n        if (null !== $ip) {\n            $clientValues = $this->normalizeAndFilterClientIps($clientValues, $ip);\n            $forwardedValues = $this->normalizeAndFilterClientIps($forwardedValues, $ip);\n        }\n\n        if ($forwardedValues === $clientValues || !$clientValues) {\n            return $forwardedValues;\n        }\n\n        if (!$forwardedValues) {\n            return $clientValues;\n        }\n\n        if (!$this->isForwardedValid) {\n            return null !== $ip ? ['0.0.0.0', $ip] : [];\n        }\n        $this->isForwardedValid = false;\n\n        throw new ConflictingHeadersException(sprintf('The request has both a trusted \"%s\" header and a trusted \"%s\" header, conflicting with each other. You should either configure your proxy to remove one of them, or configure your project to distrust the offending one.', self::$trustedHeaders[self::HEADER_FORWARDED], self::$trustedHeaders[$type]));\n    }\n\n    private function normalizeAndFilterClientIps(array $clientIps, $ip)\n    {\n        if (!$clientIps) {\n            return [];\n        }\n        $clientIps[] = $ip; // Complete the IP chain with the IP the request actually came from\n        $firstTrustedIp = null;\n\n        foreach ($clientIps as $key => $clientIp) {\n            if (strpos($clientIp, '.')) {\n                // Strip :port from IPv4 addresses. This is allowed in Forwarded\n                // and may occur in X-Forwarded-For.\n                $i = strpos($clientIp, ':');\n                if ($i) {\n                    $clientIps[$key] = $clientIp = substr($clientIp, 0, $i);\n                }\n            } elseif (0 === strpos($clientIp, '[')) {\n                // Strip brackets and :port from IPv6 addresses.\n                $i = strpos($clientIp, ']', 1);\n                $clientIps[$key] = $clientIp = substr($clientIp, 1, $i - 1);\n            }\n\n            if (!filter_var($clientIp, FILTER_VALIDATE_IP)) {\n                unset($clientIps[$key]);\n\n                continue;\n            }\n\n            if (IpUtils::checkIp($clientIp, self::$trustedProxies)) {\n                unset($clientIps[$key]);\n\n                // Fallback to this when the client IP falls into the range of trusted proxies\n                if (null === $firstTrustedIp) {\n                    $firstTrustedIp = $clientIp;\n                }\n            }\n        }\n\n        // Now the IP chain contains only untrusted proxies and the client IP\n        return $clientIps ? array_reverse($clientIps) : [$firstTrustedIp];\n    }\n}\n"], "fixing_code": ["<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\HttpFoundation;\n\nuse Symfony\\Component\\HttpFoundation\\Exception\\ConflictingHeadersException;\nuse Symfony\\Component\\HttpFoundation\\Exception\\SuspiciousOperationException;\nuse Symfony\\Component\\HttpFoundation\\Session\\SessionInterface;\n\n/**\n * Request represents an HTTP request.\n *\n * The methods dealing with URL accept / return a raw path (% encoded):\n *   * getBasePath\n *   * getBaseUrl\n *   * getPathInfo\n *   * getRequestUri\n *   * getUri\n *   * getUriForPath\n *\n * @author Fabien Potencier <fabien@symfony.com>\n */\nclass Request\n{\n    const HEADER_FORWARDED = 0b00001; // When using RFC 7239\n    const HEADER_X_FORWARDED_FOR = 0b00010;\n    const HEADER_X_FORWARDED_HOST = 0b00100;\n    const HEADER_X_FORWARDED_PROTO = 0b01000;\n    const HEADER_X_FORWARDED_PORT = 0b10000;\n    const HEADER_X_FORWARDED_ALL = 0b11110; // All \"X-Forwarded-*\" headers\n    const HEADER_X_FORWARDED_AWS_ELB = 0b11010; // AWS ELB doesn't send X-Forwarded-Host\n\n    /** @deprecated since version 3.3, to be removed in 4.0 */\n    const HEADER_CLIENT_IP = self::HEADER_X_FORWARDED_FOR;\n    /** @deprecated since version 3.3, to be removed in 4.0 */\n    const HEADER_CLIENT_HOST = self::HEADER_X_FORWARDED_HOST;\n    /** @deprecated since version 3.3, to be removed in 4.0 */\n    const HEADER_CLIENT_PROTO = self::HEADER_X_FORWARDED_PROTO;\n    /** @deprecated since version 3.3, to be removed in 4.0 */\n    const HEADER_CLIENT_PORT = self::HEADER_X_FORWARDED_PORT;\n\n    const METHOD_HEAD = 'HEAD';\n    const METHOD_GET = 'GET';\n    const METHOD_POST = 'POST';\n    const METHOD_PUT = 'PUT';\n    const METHOD_PATCH = 'PATCH';\n    const METHOD_DELETE = 'DELETE';\n    const METHOD_PURGE = 'PURGE';\n    const METHOD_OPTIONS = 'OPTIONS';\n    const METHOD_TRACE = 'TRACE';\n    const METHOD_CONNECT = 'CONNECT';\n\n    /**\n     * @var string[]\n     */\n    protected static $trustedProxies = [];\n\n    /**\n     * @var string[]\n     */\n    protected static $trustedHostPatterns = [];\n\n    /**\n     * @var string[]\n     */\n    protected static $trustedHosts = [];\n\n    /**\n     * Names for headers that can be trusted when\n     * using trusted proxies.\n     *\n     * The FORWARDED header is the standard as of rfc7239.\n     *\n     * The other headers are non-standard, but widely used\n     * by popular reverse proxies (like Apache mod_proxy or Amazon EC2).\n     *\n     * @deprecated since version 3.3, to be removed in 4.0\n     */\n    protected static $trustedHeaders = [\n        self::HEADER_FORWARDED => 'FORWARDED',\n        self::HEADER_CLIENT_IP => 'X_FORWARDED_FOR',\n        self::HEADER_CLIENT_HOST => 'X_FORWARDED_HOST',\n        self::HEADER_CLIENT_PROTO => 'X_FORWARDED_PROTO',\n        self::HEADER_CLIENT_PORT => 'X_FORWARDED_PORT',\n    ];\n\n    protected static $httpMethodParameterOverride = false;\n\n    /**\n     * Custom parameters.\n     *\n     * @var \\Symfony\\Component\\HttpFoundation\\ParameterBag\n     */\n    public $attributes;\n\n    /**\n     * Request body parameters ($_POST).\n     *\n     * @var \\Symfony\\Component\\HttpFoundation\\ParameterBag\n     */\n    public $request;\n\n    /**\n     * Query string parameters ($_GET).\n     *\n     * @var \\Symfony\\Component\\HttpFoundation\\ParameterBag\n     */\n    public $query;\n\n    /**\n     * Server and execution environment parameters ($_SERVER).\n     *\n     * @var \\Symfony\\Component\\HttpFoundation\\ServerBag\n     */\n    public $server;\n\n    /**\n     * Uploaded files ($_FILES).\n     *\n     * @var \\Symfony\\Component\\HttpFoundation\\FileBag\n     */\n    public $files;\n\n    /**\n     * Cookies ($_COOKIE).\n     *\n     * @var \\Symfony\\Component\\HttpFoundation\\ParameterBag\n     */\n    public $cookies;\n\n    /**\n     * Headers (taken from the $_SERVER).\n     *\n     * @var \\Symfony\\Component\\HttpFoundation\\HeaderBag\n     */\n    public $headers;\n\n    /**\n     * @var string|resource|false|null\n     */\n    protected $content;\n\n    /**\n     * @var array\n     */\n    protected $languages;\n\n    /**\n     * @var array\n     */\n    protected $charsets;\n\n    /**\n     * @var array\n     */\n    protected $encodings;\n\n    /**\n     * @var array\n     */\n    protected $acceptableContentTypes;\n\n    /**\n     * @var string\n     */\n    protected $pathInfo;\n\n    /**\n     * @var string\n     */\n    protected $requestUri;\n\n    /**\n     * @var string\n     */\n    protected $baseUrl;\n\n    /**\n     * @var string\n     */\n    protected $basePath;\n\n    /**\n     * @var string\n     */\n    protected $method;\n\n    /**\n     * @var string\n     */\n    protected $format;\n\n    /**\n     * @var \\Symfony\\Component\\HttpFoundation\\Session\\SessionInterface\n     */\n    protected $session;\n\n    /**\n     * @var string\n     */\n    protected $locale;\n\n    /**\n     * @var string\n     */\n    protected $defaultLocale = 'en';\n\n    /**\n     * @var array\n     */\n    protected static $formats;\n\n    protected static $requestFactory;\n\n    private $isHostValid = true;\n    private $isForwardedValid = true;\n\n    private static $trustedHeaderSet = -1;\n\n    /** @deprecated since version 3.3, to be removed in 4.0 */\n    private static $trustedHeaderNames = [\n        self::HEADER_FORWARDED => 'FORWARDED',\n        self::HEADER_CLIENT_IP => 'X_FORWARDED_FOR',\n        self::HEADER_CLIENT_HOST => 'X_FORWARDED_HOST',\n        self::HEADER_CLIENT_PROTO => 'X_FORWARDED_PROTO',\n        self::HEADER_CLIENT_PORT => 'X_FORWARDED_PORT',\n    ];\n\n    private static $forwardedParams = [\n        self::HEADER_X_FORWARDED_FOR => 'for',\n        self::HEADER_X_FORWARDED_HOST => 'host',\n        self::HEADER_X_FORWARDED_PROTO => 'proto',\n        self::HEADER_X_FORWARDED_PORT => 'host',\n    ];\n\n    /**\n     * @param array                $query      The GET parameters\n     * @param array                $request    The POST parameters\n     * @param array                $attributes The request attributes (parameters parsed from the PATH_INFO, ...)\n     * @param array                $cookies    The COOKIE parameters\n     * @param array                $files      The FILES parameters\n     * @param array                $server     The SERVER parameters\n     * @param string|resource|null $content    The raw body data\n     */\n    public function __construct(array $query = [], array $request = [], array $attributes = [], array $cookies = [], array $files = [], array $server = [], $content = null)\n    {\n        $this->initialize($query, $request, $attributes, $cookies, $files, $server, $content);\n    }\n\n    /**\n     * Sets the parameters for this request.\n     *\n     * This method also re-initializes all properties.\n     *\n     * @param array                $query      The GET parameters\n     * @param array                $request    The POST parameters\n     * @param array                $attributes The request attributes (parameters parsed from the PATH_INFO, ...)\n     * @param array                $cookies    The COOKIE parameters\n     * @param array                $files      The FILES parameters\n     * @param array                $server     The SERVER parameters\n     * @param string|resource|null $content    The raw body data\n     */\n    public function initialize(array $query = [], array $request = [], array $attributes = [], array $cookies = [], array $files = [], array $server = [], $content = null)\n    {\n        $this->request = new ParameterBag($request);\n        $this->query = new ParameterBag($query);\n        $this->attributes = new ParameterBag($attributes);\n        $this->cookies = new ParameterBag($cookies);\n        $this->files = new FileBag($files);\n        $this->server = new ServerBag($server);\n        $this->headers = new HeaderBag($this->server->getHeaders());\n\n        $this->content = $content;\n        $this->languages = null;\n        $this->charsets = null;\n        $this->encodings = null;\n        $this->acceptableContentTypes = null;\n        $this->pathInfo = null;\n        $this->requestUri = null;\n        $this->baseUrl = null;\n        $this->basePath = null;\n        $this->method = null;\n        $this->format = null;\n    }\n\n    /**\n     * Creates a new request with values from PHP's super globals.\n     *\n     * @return static\n     */\n    public static function createFromGlobals()\n    {\n        // With the php's bug #66606, the php's built-in web server\n        // stores the Content-Type and Content-Length header values in\n        // HTTP_CONTENT_TYPE and HTTP_CONTENT_LENGTH fields.\n        $server = $_SERVER;\n        if ('cli-server' === \\PHP_SAPI) {\n            if (\\array_key_exists('HTTP_CONTENT_LENGTH', $_SERVER)) {\n                $server['CONTENT_LENGTH'] = $_SERVER['HTTP_CONTENT_LENGTH'];\n            }\n            if (\\array_key_exists('HTTP_CONTENT_TYPE', $_SERVER)) {\n                $server['CONTENT_TYPE'] = $_SERVER['HTTP_CONTENT_TYPE'];\n            }\n        }\n\n        $request = self::createRequestFromFactory($_GET, $_POST, [], $_COOKIE, $_FILES, $server);\n\n        if (0 === strpos($request->headers->get('CONTENT_TYPE'), 'application/x-www-form-urlencoded')\n            && \\in_array(strtoupper($request->server->get('REQUEST_METHOD', 'GET')), ['PUT', 'DELETE', 'PATCH'])\n        ) {\n            parse_str($request->getContent(), $data);\n            $request->request = new ParameterBag($data);\n        }\n\n        return $request;\n    }\n\n    /**\n     * Creates a Request based on a given URI and configuration.\n     *\n     * The information contained in the URI always take precedence\n     * over the other information (server and parameters).\n     *\n     * @param string               $uri        The URI\n     * @param string               $method     The HTTP method\n     * @param array                $parameters The query (GET) or request (POST) parameters\n     * @param array                $cookies    The request cookies ($_COOKIE)\n     * @param array                $files      The request files ($_FILES)\n     * @param array                $server     The server parameters ($_SERVER)\n     * @param string|resource|null $content    The raw body data\n     *\n     * @return static\n     */\n    public static function create($uri, $method = 'GET', $parameters = [], $cookies = [], $files = [], $server = [], $content = null)\n    {\n        $server = array_replace([\n            'SERVER_NAME' => 'localhost',\n            'SERVER_PORT' => 80,\n            'HTTP_HOST' => 'localhost',\n            'HTTP_USER_AGENT' => 'Symfony/3.X',\n            'HTTP_ACCEPT' => 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',\n            'HTTP_ACCEPT_LANGUAGE' => 'en-us,en;q=0.5',\n            'HTTP_ACCEPT_CHARSET' => 'ISO-8859-1,utf-8;q=0.7,*;q=0.7',\n            'REMOTE_ADDR' => '127.0.0.1',\n            'SCRIPT_NAME' => '',\n            'SCRIPT_FILENAME' => '',\n            'SERVER_PROTOCOL' => 'HTTP/1.1',\n            'REQUEST_TIME' => time(),\n        ], $server);\n\n        $server['PATH_INFO'] = '';\n        $server['REQUEST_METHOD'] = strtoupper($method);\n\n        $components = parse_url($uri);\n        if (isset($components['host'])) {\n            $server['SERVER_NAME'] = $components['host'];\n            $server['HTTP_HOST'] = $components['host'];\n        }\n\n        if (isset($components['scheme'])) {\n            if ('https' === $components['scheme']) {\n                $server['HTTPS'] = 'on';\n                $server['SERVER_PORT'] = 443;\n            } else {\n                unset($server['HTTPS']);\n                $server['SERVER_PORT'] = 80;\n            }\n        }\n\n        if (isset($components['port'])) {\n            $server['SERVER_PORT'] = $components['port'];\n            $server['HTTP_HOST'] .= ':'.$components['port'];\n        }\n\n        if (isset($components['user'])) {\n            $server['PHP_AUTH_USER'] = $components['user'];\n        }\n\n        if (isset($components['pass'])) {\n            $server['PHP_AUTH_PW'] = $components['pass'];\n        }\n\n        if (!isset($components['path'])) {\n            $components['path'] = '/';\n        }\n\n        switch (strtoupper($method)) {\n            case 'POST':\n            case 'PUT':\n            case 'DELETE':\n                if (!isset($server['CONTENT_TYPE'])) {\n                    $server['CONTENT_TYPE'] = 'application/x-www-form-urlencoded';\n                }\n                // no break\n            case 'PATCH':\n                $request = $parameters;\n                $query = [];\n                break;\n            default:\n                $request = [];\n                $query = $parameters;\n                break;\n        }\n\n        $queryString = '';\n        if (isset($components['query'])) {\n            parse_str(html_entity_decode($components['query']), $qs);\n\n            if ($query) {\n                $query = array_replace($qs, $query);\n                $queryString = http_build_query($query, '', '&');\n            } else {\n                $query = $qs;\n                $queryString = $components['query'];\n            }\n        } elseif ($query) {\n            $queryString = http_build_query($query, '', '&');\n        }\n\n        $server['REQUEST_URI'] = $components['path'].('' !== $queryString ? '?'.$queryString : '');\n        $server['QUERY_STRING'] = $queryString;\n\n        return self::createRequestFromFactory($query, $request, [], $cookies, $files, $server, $content);\n    }\n\n    /**\n     * Sets a callable able to create a Request instance.\n     *\n     * This is mainly useful when you need to override the Request class\n     * to keep BC with an existing system. It should not be used for any\n     * other purpose.\n     *\n     * @param callable|null $callable A PHP callable\n     */\n    public static function setFactory($callable)\n    {\n        self::$requestFactory = $callable;\n    }\n\n    /**\n     * Clones a request and overrides some of its parameters.\n     *\n     * @param array $query      The GET parameters\n     * @param array $request    The POST parameters\n     * @param array $attributes The request attributes (parameters parsed from the PATH_INFO, ...)\n     * @param array $cookies    The COOKIE parameters\n     * @param array $files      The FILES parameters\n     * @param array $server     The SERVER parameters\n     *\n     * @return static\n     */\n    public function duplicate(array $query = null, array $request = null, array $attributes = null, array $cookies = null, array $files = null, array $server = null)\n    {\n        $dup = clone $this;\n        if (null !== $query) {\n            $dup->query = new ParameterBag($query);\n        }\n        if (null !== $request) {\n            $dup->request = new ParameterBag($request);\n        }\n        if (null !== $attributes) {\n            $dup->attributes = new ParameterBag($attributes);\n        }\n        if (null !== $cookies) {\n            $dup->cookies = new ParameterBag($cookies);\n        }\n        if (null !== $files) {\n            $dup->files = new FileBag($files);\n        }\n        if (null !== $server) {\n            $dup->server = new ServerBag($server);\n            $dup->headers = new HeaderBag($dup->server->getHeaders());\n        }\n        $dup->languages = null;\n        $dup->charsets = null;\n        $dup->encodings = null;\n        $dup->acceptableContentTypes = null;\n        $dup->pathInfo = null;\n        $dup->requestUri = null;\n        $dup->baseUrl = null;\n        $dup->basePath = null;\n        $dup->method = null;\n        $dup->format = null;\n\n        if (!$dup->get('_format') && $this->get('_format')) {\n            $dup->attributes->set('_format', $this->get('_format'));\n        }\n\n        if (!$dup->getRequestFormat(null)) {\n            $dup->setRequestFormat($this->getRequestFormat(null));\n        }\n\n        return $dup;\n    }\n\n    /**\n     * Clones the current request.\n     *\n     * Note that the session is not cloned as duplicated requests\n     * are most of the time sub-requests of the main one.\n     */\n    public function __clone()\n    {\n        $this->query = clone $this->query;\n        $this->request = clone $this->request;\n        $this->attributes = clone $this->attributes;\n        $this->cookies = clone $this->cookies;\n        $this->files = clone $this->files;\n        $this->server = clone $this->server;\n        $this->headers = clone $this->headers;\n    }\n\n    /**\n     * Returns the request as a string.\n     *\n     * @return string The request\n     */\n    public function __toString()\n    {\n        try {\n            $content = $this->getContent();\n        } catch (\\LogicException $e) {\n            return trigger_error($e, E_USER_ERROR);\n        }\n\n        $cookieHeader = '';\n        $cookies = [];\n\n        foreach ($this->cookies as $k => $v) {\n            $cookies[] = $k.'='.$v;\n        }\n\n        if (!empty($cookies)) {\n            $cookieHeader = 'Cookie: '.implode('; ', $cookies).\"\\r\\n\";\n        }\n\n        return\n            sprintf('%s %s %s', $this->getMethod(), $this->getRequestUri(), $this->server->get('SERVER_PROTOCOL')).\"\\r\\n\".\n            $this->headers.\n            $cookieHeader.\"\\r\\n\".\n            $content;\n    }\n\n    /**\n     * Overrides the PHP global variables according to this request instance.\n     *\n     * It overrides $_GET, $_POST, $_REQUEST, $_SERVER, $_COOKIE.\n     * $_FILES is never overridden, see rfc1867\n     */\n    public function overrideGlobals()\n    {\n        $this->server->set('QUERY_STRING', static::normalizeQueryString(http_build_query($this->query->all(), '', '&')));\n\n        $_GET = $this->query->all();\n        $_POST = $this->request->all();\n        $_SERVER = $this->server->all();\n        $_COOKIE = $this->cookies->all();\n\n        foreach ($this->headers->all() as $key => $value) {\n            $key = strtoupper(str_replace('-', '_', $key));\n            if (\\in_array($key, ['CONTENT_TYPE', 'CONTENT_LENGTH'])) {\n                $_SERVER[$key] = implode(', ', $value);\n            } else {\n                $_SERVER['HTTP_'.$key] = implode(', ', $value);\n            }\n        }\n\n        $request = ['g' => $_GET, 'p' => $_POST, 'c' => $_COOKIE];\n\n        $requestOrder = ini_get('request_order') ?: ini_get('variables_order');\n        $requestOrder = preg_replace('#[^cgp]#', '', strtolower($requestOrder)) ?: 'gp';\n\n        $_REQUEST = [];\n        foreach (str_split($requestOrder) as $order) {\n            $_REQUEST = array_merge($_REQUEST, $request[$order]);\n        }\n    }\n\n    /**\n     * Sets a list of trusted proxies.\n     *\n     * You should only list the reverse proxies that you manage directly.\n     *\n     * @param array $proxies          A list of trusted proxies\n     * @param int   $trustedHeaderSet A bit field of Request::HEADER_*, to set which headers to trust from your proxies\n     *\n     * @throws \\InvalidArgumentException When $trustedHeaderSet is invalid\n     */\n    public static function setTrustedProxies(array $proxies/*, int $trustedHeaderSet*/)\n    {\n        self::$trustedProxies = $proxies;\n\n        if (2 > \\func_num_args()) {\n            @trigger_error(sprintf('The %s() method expects a bit field of Request::HEADER_* as second argument since Symfony 3.3. Defining it will be required in 4.0. ', __METHOD__), E_USER_DEPRECATED);\n\n            return;\n        }\n        $trustedHeaderSet = (int) func_get_arg(1);\n\n        foreach (self::$trustedHeaderNames as $header => $name) {\n            self::$trustedHeaders[$header] = $header & $trustedHeaderSet ? $name : null;\n        }\n        self::$trustedHeaderSet = $trustedHeaderSet;\n    }\n\n    /**\n     * Gets the list of trusted proxies.\n     *\n     * @return array An array of trusted proxies\n     */\n    public static function getTrustedProxies()\n    {\n        return self::$trustedProxies;\n    }\n\n    /**\n     * Gets the set of trusted headers from trusted proxies.\n     *\n     * @return int A bit field of Request::HEADER_* that defines which headers are trusted from your proxies\n     */\n    public static function getTrustedHeaderSet()\n    {\n        return self::$trustedHeaderSet;\n    }\n\n    /**\n     * Sets a list of trusted host patterns.\n     *\n     * You should only list the hosts you manage using regexs.\n     *\n     * @param array $hostPatterns A list of trusted host patterns\n     */\n    public static function setTrustedHosts(array $hostPatterns)\n    {\n        self::$trustedHostPatterns = array_map(function ($hostPattern) {\n            return sprintf('{%s}i', $hostPattern);\n        }, $hostPatterns);\n        // we need to reset trusted hosts on trusted host patterns change\n        self::$trustedHosts = [];\n    }\n\n    /**\n     * Gets the list of trusted host patterns.\n     *\n     * @return array An array of trusted host patterns\n     */\n    public static function getTrustedHosts()\n    {\n        return self::$trustedHostPatterns;\n    }\n\n    /**\n     * Sets the name for trusted headers.\n     *\n     * The following header keys are supported:\n     *\n     *  * Request::HEADER_CLIENT_IP:    defaults to X-Forwarded-For   (see getClientIp())\n     *  * Request::HEADER_CLIENT_HOST:  defaults to X-Forwarded-Host  (see getHost())\n     *  * Request::HEADER_CLIENT_PORT:  defaults to X-Forwarded-Port  (see getPort())\n     *  * Request::HEADER_CLIENT_PROTO: defaults to X-Forwarded-Proto (see getScheme() and isSecure())\n     *  * Request::HEADER_FORWARDED:    defaults to Forwarded         (see RFC 7239)\n     *\n     * Setting an empty value allows to disable the trusted header for the given key.\n     *\n     * @param string $key   The header key\n     * @param string $value The header name\n     *\n     * @throws \\InvalidArgumentException\n     *\n     * @deprecated since version 3.3, to be removed in 4.0. Use the $trustedHeaderSet argument of the Request::setTrustedProxies() method instead.\n     */\n    public static function setTrustedHeaderName($key, $value)\n    {\n        @trigger_error(sprintf('The \"%s()\" method is deprecated since Symfony 3.3 and will be removed in 4.0. Use the $trustedHeaderSet argument of the Request::setTrustedProxies() method instead.', __METHOD__), E_USER_DEPRECATED);\n\n        if ('forwarded' === $key) {\n            $key = self::HEADER_FORWARDED;\n        } elseif ('client_ip' === $key) {\n            $key = self::HEADER_CLIENT_IP;\n        } elseif ('client_host' === $key) {\n            $key = self::HEADER_CLIENT_HOST;\n        } elseif ('client_proto' === $key) {\n            $key = self::HEADER_CLIENT_PROTO;\n        } elseif ('client_port' === $key) {\n            $key = self::HEADER_CLIENT_PORT;\n        } elseif (!\\array_key_exists($key, self::$trustedHeaders)) {\n            throw new \\InvalidArgumentException(sprintf('Unable to set the trusted header name for key \"%s\".', $key));\n        }\n\n        self::$trustedHeaders[$key] = $value;\n\n        if (null !== $value) {\n            self::$trustedHeaderNames[$key] = $value;\n            self::$trustedHeaderSet |= $key;\n        } else {\n            self::$trustedHeaderSet &= ~$key;\n        }\n    }\n\n    /**\n     * Gets the trusted proxy header name.\n     *\n     * @param string $key The header key\n     *\n     * @return string The header name\n     *\n     * @throws \\InvalidArgumentException\n     *\n     * @deprecated since version 3.3, to be removed in 4.0. Use the Request::getTrustedHeaderSet() method instead.\n     */\n    public static function getTrustedHeaderName($key)\n    {\n        if (2 > \\func_num_args() || func_get_arg(1)) {\n            @trigger_error(sprintf('The \"%s()\" method is deprecated since Symfony 3.3 and will be removed in 4.0. Use the Request::getTrustedHeaderSet() method instead.', __METHOD__), E_USER_DEPRECATED);\n        }\n\n        if (!\\array_key_exists($key, self::$trustedHeaders)) {\n            throw new \\InvalidArgumentException(sprintf('Unable to get the trusted header name for key \"%s\".', $key));\n        }\n\n        return self::$trustedHeaders[$key];\n    }\n\n    /**\n     * Normalizes a query string.\n     *\n     * It builds a normalized query string, where keys/value pairs are alphabetized,\n     * have consistent escaping and unneeded delimiters are removed.\n     *\n     * @param string $qs Query string\n     *\n     * @return string A normalized query string for the Request\n     */\n    public static function normalizeQueryString($qs)\n    {\n        if ('' == $qs) {\n            return '';\n        }\n\n        $parts = [];\n        $order = [];\n\n        foreach (explode('&', $qs) as $param) {\n            if ('' === $param || '=' === $param[0]) {\n                // Ignore useless delimiters, e.g. \"x=y&\".\n                // Also ignore pairs with empty key, even if there was a value, e.g. \"=value\", as such nameless values cannot be retrieved anyway.\n                // PHP also does not include them when building _GET.\n                continue;\n            }\n\n            $keyValuePair = explode('=', $param, 2);\n\n            // GET parameters, that are submitted from a HTML form, encode spaces as \"+\" by default (as defined in enctype application/x-www-form-urlencoded).\n            // PHP also converts \"+\" to spaces when filling the global _GET or when using the function parse_str. This is why we use urldecode and then normalize to\n            // RFC 3986 with rawurlencode.\n            $parts[] = isset($keyValuePair[1]) ?\n                rawurlencode(urldecode($keyValuePair[0])).'='.rawurlencode(urldecode($keyValuePair[1])) :\n                rawurlencode(urldecode($keyValuePair[0]));\n            $order[] = urldecode($keyValuePair[0]);\n        }\n\n        array_multisort($order, SORT_ASC, $parts);\n\n        return implode('&', $parts);\n    }\n\n    /**\n     * Enables support for the _method request parameter to determine the intended HTTP method.\n     *\n     * Be warned that enabling this feature might lead to CSRF issues in your code.\n     * Check that you are using CSRF tokens when required.\n     * If the HTTP method parameter override is enabled, an html-form with method \"POST\" can be altered\n     * and used to send a \"PUT\" or \"DELETE\" request via the _method request parameter.\n     * If these methods are not protected against CSRF, this presents a possible vulnerability.\n     *\n     * The HTTP method can only be overridden when the real HTTP method is POST.\n     */\n    public static function enableHttpMethodParameterOverride()\n    {\n        self::$httpMethodParameterOverride = true;\n    }\n\n    /**\n     * Checks whether support for the _method request parameter is enabled.\n     *\n     * @return bool True when the _method request parameter is enabled, false otherwise\n     */\n    public static function getHttpMethodParameterOverride()\n    {\n        return self::$httpMethodParameterOverride;\n    }\n\n    /**\n     * Gets a \"parameter\" value from any bag.\n     *\n     * This method is mainly useful for libraries that want to provide some flexibility. If you don't need the\n     * flexibility in controllers, it is better to explicitly get request parameters from the appropriate\n     * public property instead (attributes, query, request).\n     *\n     * Order of precedence: PATH (routing placeholders or custom attributes), GET, BODY\n     *\n     * @param string $key     The key\n     * @param mixed  $default The default value if the parameter key does not exist\n     *\n     * @return mixed\n     */\n    public function get($key, $default = null)\n    {\n        if ($this !== $result = $this->attributes->get($key, $this)) {\n            return $result;\n        }\n\n        if ($this !== $result = $this->query->get($key, $this)) {\n            return $result;\n        }\n\n        if ($this !== $result = $this->request->get($key, $this)) {\n            return $result;\n        }\n\n        return $default;\n    }\n\n    /**\n     * Gets the Session.\n     *\n     * @return SessionInterface|null The session\n     */\n    public function getSession()\n    {\n        return $this->session;\n    }\n\n    /**\n     * Whether the request contains a Session which was started in one of the\n     * previous requests.\n     *\n     * @return bool\n     */\n    public function hasPreviousSession()\n    {\n        // the check for $this->session avoids malicious users trying to fake a session cookie with proper name\n        return $this->hasSession() && $this->cookies->has($this->session->getName());\n    }\n\n    /**\n     * Whether the request contains a Session object.\n     *\n     * This method does not give any information about the state of the session object,\n     * like whether the session is started or not. It is just a way to check if this Request\n     * is associated with a Session instance.\n     *\n     * @return bool true when the Request contains a Session object, false otherwise\n     */\n    public function hasSession()\n    {\n        return null !== $this->session;\n    }\n\n    /**\n     * Sets the Session.\n     *\n     * @param SessionInterface $session The Session\n     */\n    public function setSession(SessionInterface $session)\n    {\n        $this->session = $session;\n    }\n\n    /**\n     * Returns the client IP addresses.\n     *\n     * In the returned array the most trusted IP address is first, and the\n     * least trusted one last. The \"real\" client IP address is the last one,\n     * but this is also the least trusted one. Trusted proxies are stripped.\n     *\n     * Use this method carefully; you should use getClientIp() instead.\n     *\n     * @return array The client IP addresses\n     *\n     * @see getClientIp()\n     */\n    public function getClientIps()\n    {\n        $ip = $this->server->get('REMOTE_ADDR');\n\n        if (!$this->isFromTrustedProxy()) {\n            return [$ip];\n        }\n\n        return $this->getTrustedValues(self::HEADER_CLIENT_IP, $ip) ?: [$ip];\n    }\n\n    /**\n     * Returns the client IP address.\n     *\n     * This method can read the client IP address from the \"X-Forwarded-For\" header\n     * when trusted proxies were set via \"setTrustedProxies()\". The \"X-Forwarded-For\"\n     * header value is a comma+space separated list of IP addresses, the left-most\n     * being the original client, and each successive proxy that passed the request\n     * adding the IP address where it received the request from.\n     *\n     * If your reverse proxy uses a different header name than \"X-Forwarded-For\",\n     * (\"Client-Ip\" for instance), configure it via the $trustedHeaderSet\n     * argument of the Request::setTrustedProxies() method instead.\n     *\n     * @return string|null The client IP address\n     *\n     * @see getClientIps()\n     * @see http://en.wikipedia.org/wiki/X-Forwarded-For\n     */\n    public function getClientIp()\n    {\n        $ipAddresses = $this->getClientIps();\n\n        return $ipAddresses[0];\n    }\n\n    /**\n     * Returns current script name.\n     *\n     * @return string\n     */\n    public function getScriptName()\n    {\n        return $this->server->get('SCRIPT_NAME', $this->server->get('ORIG_SCRIPT_NAME', ''));\n    }\n\n    /**\n     * Returns the path being requested relative to the executed script.\n     *\n     * The path info always starts with a /.\n     *\n     * Suppose this request is instantiated from /mysite on localhost:\n     *\n     *  * http://localhost/mysite              returns an empty string\n     *  * http://localhost/mysite/about        returns '/about'\n     *  * http://localhost/mysite/enco%20ded   returns '/enco%20ded'\n     *  * http://localhost/mysite/about?var=1  returns '/about'\n     *\n     * @return string The raw path (i.e. not urldecoded)\n     */\n    public function getPathInfo()\n    {\n        if (null === $this->pathInfo) {\n            $this->pathInfo = $this->preparePathInfo();\n        }\n\n        return $this->pathInfo;\n    }\n\n    /**\n     * Returns the root path from which this request is executed.\n     *\n     * Suppose that an index.php file instantiates this request object:\n     *\n     *  * http://localhost/index.php         returns an empty string\n     *  * http://localhost/index.php/page    returns an empty string\n     *  * http://localhost/web/index.php     returns '/web'\n     *  * http://localhost/we%20b/index.php  returns '/we%20b'\n     *\n     * @return string The raw path (i.e. not urldecoded)\n     */\n    public function getBasePath()\n    {\n        if (null === $this->basePath) {\n            $this->basePath = $this->prepareBasePath();\n        }\n\n        return $this->basePath;\n    }\n\n    /**\n     * Returns the root URL from which this request is executed.\n     *\n     * The base URL never ends with a /.\n     *\n     * This is similar to getBasePath(), except that it also includes the\n     * script filename (e.g. index.php) if one exists.\n     *\n     * @return string The raw URL (i.e. not urldecoded)\n     */\n    public function getBaseUrl()\n    {\n        if (null === $this->baseUrl) {\n            $this->baseUrl = $this->prepareBaseUrl();\n        }\n\n        return $this->baseUrl;\n    }\n\n    /**\n     * Gets the request's scheme.\n     *\n     * @return string\n     */\n    public function getScheme()\n    {\n        return $this->isSecure() ? 'https' : 'http';\n    }\n\n    /**\n     * Returns the port on which the request is made.\n     *\n     * This method can read the client port from the \"X-Forwarded-Port\" header\n     * when trusted proxies were set via \"setTrustedProxies()\".\n     *\n     * The \"X-Forwarded-Port\" header must contain the client port.\n     *\n     * If your reverse proxy uses a different header name than \"X-Forwarded-Port\",\n     * configure it via via the $trustedHeaderSet argument of the\n     * Request::setTrustedProxies() method instead.\n     *\n     * @return int|string can be a string if fetched from the server bag\n     */\n    public function getPort()\n    {\n        if ($this->isFromTrustedProxy() && $host = $this->getTrustedValues(self::HEADER_CLIENT_PORT)) {\n            $host = $host[0];\n        } elseif ($this->isFromTrustedProxy() && $host = $this->getTrustedValues(self::HEADER_CLIENT_HOST)) {\n            $host = $host[0];\n        } elseif (!$host = $this->headers->get('HOST')) {\n            return $this->server->get('SERVER_PORT');\n        }\n\n        if ('[' === $host[0]) {\n            $pos = strpos($host, ':', strrpos($host, ']'));\n        } else {\n            $pos = strrpos($host, ':');\n        }\n\n        if (false !== $pos) {\n            return (int) substr($host, $pos + 1);\n        }\n\n        return 'https' === $this->getScheme() ? 443 : 80;\n    }\n\n    /**\n     * Returns the user.\n     *\n     * @return string|null\n     */\n    public function getUser()\n    {\n        return $this->headers->get('PHP_AUTH_USER');\n    }\n\n    /**\n     * Returns the password.\n     *\n     * @return string|null\n     */\n    public function getPassword()\n    {\n        return $this->headers->get('PHP_AUTH_PW');\n    }\n\n    /**\n     * Gets the user info.\n     *\n     * @return string A user name and, optionally, scheme-specific information about how to gain authorization to access the server\n     */\n    public function getUserInfo()\n    {\n        $userinfo = $this->getUser();\n\n        $pass = $this->getPassword();\n        if ('' != $pass) {\n            $userinfo .= \":$pass\";\n        }\n\n        return $userinfo;\n    }\n\n    /**\n     * Returns the HTTP host being requested.\n     *\n     * The port name will be appended to the host if it's non-standard.\n     *\n     * @return string\n     */\n    public function getHttpHost()\n    {\n        $scheme = $this->getScheme();\n        $port = $this->getPort();\n\n        if (('http' == $scheme && 80 == $port) || ('https' == $scheme && 443 == $port)) {\n            return $this->getHost();\n        }\n\n        return $this->getHost().':'.$port;\n    }\n\n    /**\n     * Returns the requested URI (path and query string).\n     *\n     * @return string The raw URI (i.e. not URI decoded)\n     */\n    public function getRequestUri()\n    {\n        if (null === $this->requestUri) {\n            $this->requestUri = $this->prepareRequestUri();\n        }\n\n        return $this->requestUri;\n    }\n\n    /**\n     * Gets the scheme and HTTP host.\n     *\n     * If the URL was called with basic authentication, the user\n     * and the password are not added to the generated string.\n     *\n     * @return string The scheme and HTTP host\n     */\n    public function getSchemeAndHttpHost()\n    {\n        return $this->getScheme().'://'.$this->getHttpHost();\n    }\n\n    /**\n     * Generates a normalized URI (URL) for the Request.\n     *\n     * @return string A normalized URI (URL) for the Request\n     *\n     * @see getQueryString()\n     */\n    public function getUri()\n    {\n        if (null !== $qs = $this->getQueryString()) {\n            $qs = '?'.$qs;\n        }\n\n        return $this->getSchemeAndHttpHost().$this->getBaseUrl().$this->getPathInfo().$qs;\n    }\n\n    /**\n     * Generates a normalized URI for the given path.\n     *\n     * @param string $path A path to use instead of the current one\n     *\n     * @return string The normalized URI for the path\n     */\n    public function getUriForPath($path)\n    {\n        return $this->getSchemeAndHttpHost().$this->getBaseUrl().$path;\n    }\n\n    /**\n     * Returns the path as relative reference from the current Request path.\n     *\n     * Only the URIs path component (no schema, host etc.) is relevant and must be given.\n     * Both paths must be absolute and not contain relative parts.\n     * Relative URLs from one resource to another are useful when generating self-contained downloadable document archives.\n     * Furthermore, they can be used to reduce the link size in documents.\n     *\n     * Example target paths, given a base path of \"/a/b/c/d\":\n     * - \"/a/b/c/d\"     -> \"\"\n     * - \"/a/b/c/\"      -> \"./\"\n     * - \"/a/b/\"        -> \"../\"\n     * - \"/a/b/c/other\" -> \"other\"\n     * - \"/a/x/y\"       -> \"../../x/y\"\n     *\n     * @param string $path The target path\n     *\n     * @return string The relative target path\n     */\n    public function getRelativeUriForPath($path)\n    {\n        // be sure that we are dealing with an absolute path\n        if (!isset($path[0]) || '/' !== $path[0]) {\n            return $path;\n        }\n\n        if ($path === $basePath = $this->getPathInfo()) {\n            return '';\n        }\n\n        $sourceDirs = explode('/', isset($basePath[0]) && '/' === $basePath[0] ? substr($basePath, 1) : $basePath);\n        $targetDirs = explode('/', substr($path, 1));\n        array_pop($sourceDirs);\n        $targetFile = array_pop($targetDirs);\n\n        foreach ($sourceDirs as $i => $dir) {\n            if (isset($targetDirs[$i]) && $dir === $targetDirs[$i]) {\n                unset($sourceDirs[$i], $targetDirs[$i]);\n            } else {\n                break;\n            }\n        }\n\n        $targetDirs[] = $targetFile;\n        $path = str_repeat('../', \\count($sourceDirs)).implode('/', $targetDirs);\n\n        // A reference to the same base directory or an empty subdirectory must be prefixed with \"./\".\n        // This also applies to a segment with a colon character (e.g., \"file:colon\") that cannot be used\n        // as the first segment of a relative-path reference, as it would be mistaken for a scheme name\n        // (see http://tools.ietf.org/html/rfc3986#section-4.2).\n        return !isset($path[0]) || '/' === $path[0]\n            || false !== ($colonPos = strpos($path, ':')) && ($colonPos < ($slashPos = strpos($path, '/')) || false === $slashPos)\n            ? \"./$path\" : $path;\n    }\n\n    /**\n     * Generates the normalized query string for the Request.\n     *\n     * It builds a normalized query string, where keys/value pairs are alphabetized\n     * and have consistent escaping.\n     *\n     * @return string|null A normalized query string for the Request\n     */\n    public function getQueryString()\n    {\n        $qs = static::normalizeQueryString($this->server->get('QUERY_STRING'));\n\n        return '' === $qs ? null : $qs;\n    }\n\n    /**\n     * Checks whether the request is secure or not.\n     *\n     * This method can read the client protocol from the \"X-Forwarded-Proto\" header\n     * when trusted proxies were set via \"setTrustedProxies()\".\n     *\n     * The \"X-Forwarded-Proto\" header must contain the protocol: \"https\" or \"http\".\n     *\n     * If your reverse proxy uses a different header name than \"X-Forwarded-Proto\"\n     * (\"SSL_HTTPS\" for instance), configure it via the $trustedHeaderSet\n     * argument of the Request::setTrustedProxies() method instead.\n     *\n     * @return bool\n     */\n    public function isSecure()\n    {\n        if ($this->isFromTrustedProxy() && $proto = $this->getTrustedValues(self::HEADER_CLIENT_PROTO)) {\n            return \\in_array(strtolower($proto[0]), ['https', 'on', 'ssl', '1'], true);\n        }\n\n        $https = $this->server->get('HTTPS');\n\n        return !empty($https) && 'off' !== strtolower($https);\n    }\n\n    /**\n     * Returns the host name.\n     *\n     * This method can read the client host name from the \"X-Forwarded-Host\" header\n     * when trusted proxies were set via \"setTrustedProxies()\".\n     *\n     * The \"X-Forwarded-Host\" header must contain the client host name.\n     *\n     * If your reverse proxy uses a different header name than \"X-Forwarded-Host\",\n     * configure it via the $trustedHeaderSet argument of the\n     * Request::setTrustedProxies() method instead.\n     *\n     * @return string\n     *\n     * @throws SuspiciousOperationException when the host name is invalid or not trusted\n     */\n    public function getHost()\n    {\n        if ($this->isFromTrustedProxy() && $host = $this->getTrustedValues(self::HEADER_CLIENT_HOST)) {\n            $host = $host[0];\n        } elseif (!$host = $this->headers->get('HOST')) {\n            if (!$host = $this->server->get('SERVER_NAME')) {\n                $host = $this->server->get('SERVER_ADDR', '');\n            }\n        }\n\n        // trim and remove port number from host\n        // host is lowercase as per RFC 952/2181\n        $host = strtolower(preg_replace('/:\\d+$/', '', trim($host)));\n\n        // as the host can come from the user (HTTP_HOST and depending on the configuration, SERVER_NAME too can come from the user)\n        // check that it does not contain forbidden characters (see RFC 952 and RFC 2181)\n        // use preg_replace() instead of preg_match() to prevent DoS attacks with long host names\n        if ($host && '' !== preg_replace('/(?:^\\[)?[a-zA-Z0-9-:\\]_]+\\.?/', '', $host)) {\n            if (!$this->isHostValid) {\n                return '';\n            }\n            $this->isHostValid = false;\n\n            throw new SuspiciousOperationException(sprintf('Invalid Host \"%s\".', $host));\n        }\n\n        if (\\count(self::$trustedHostPatterns) > 0) {\n            // to avoid host header injection attacks, you should provide a list of trusted host patterns\n\n            if (\\in_array($host, self::$trustedHosts)) {\n                return $host;\n            }\n\n            foreach (self::$trustedHostPatterns as $pattern) {\n                if (preg_match($pattern, $host)) {\n                    self::$trustedHosts[] = $host;\n\n                    return $host;\n                }\n            }\n\n            if (!$this->isHostValid) {\n                return '';\n            }\n            $this->isHostValid = false;\n\n            throw new SuspiciousOperationException(sprintf('Untrusted Host \"%s\".', $host));\n        }\n\n        return $host;\n    }\n\n    /**\n     * Sets the request method.\n     *\n     * @param string $method\n     */\n    public function setMethod($method)\n    {\n        $this->method = null;\n        $this->server->set('REQUEST_METHOD', $method);\n    }\n\n    /**\n     * Gets the request \"intended\" method.\n     *\n     * If the X-HTTP-Method-Override header is set, and if the method is a POST,\n     * then it is used to determine the \"real\" intended HTTP method.\n     *\n     * The _method request parameter can also be used to determine the HTTP method,\n     * but only if enableHttpMethodParameterOverride() has been called.\n     *\n     * The method is always an uppercased string.\n     *\n     * @return string The request method\n     *\n     * @see getRealMethod()\n     */\n    public function getMethod()\n    {\n        if (null !== $this->method) {\n            return $this->method;\n        }\n\n        $this->method = strtoupper($this->server->get('REQUEST_METHOD', 'GET'));\n\n        if ('POST' !== $this->method) {\n            return $this->method;\n        }\n\n        $method = $this->headers->get('X-HTTP-METHOD-OVERRIDE');\n\n        if (!$method && self::$httpMethodParameterOverride) {\n            $method = $this->request->get('_method', $this->query->get('_method', 'POST'));\n        }\n\n        if (!\\is_string($method)) {\n            return $this->method;\n        }\n\n        $method = strtoupper($method);\n\n        if (\\in_array($method, ['GET', 'HEAD', 'POST', 'PUT', 'DELETE', 'CONNECT', 'OPTIONS', 'PATCH', 'PURGE', 'TRACE'], true)) {\n            return $this->method = $method;\n        }\n\n        if (!preg_match('/^[A-Z]++$/D', $method)) {\n            throw new SuspiciousOperationException(sprintf('Invalid method override \"%s\".', $method));\n        }\n\n        return $this->method = $method;\n    }\n\n    /**\n     * Gets the \"real\" request method.\n     *\n     * @return string The request method\n     *\n     * @see getMethod()\n     */\n    public function getRealMethod()\n    {\n        return strtoupper($this->server->get('REQUEST_METHOD', 'GET'));\n    }\n\n    /**\n     * Gets the mime type associated with the format.\n     *\n     * @param string $format The format\n     *\n     * @return string|null The associated mime type (null if not found)\n     */\n    public function getMimeType($format)\n    {\n        if (null === static::$formats) {\n            static::initializeFormats();\n        }\n\n        return isset(static::$formats[$format]) ? static::$formats[$format][0] : null;\n    }\n\n    /**\n     * Gets the mime types associated with the format.\n     *\n     * @param string $format The format\n     *\n     * @return array The associated mime types\n     */\n    public static function getMimeTypes($format)\n    {\n        if (null === static::$formats) {\n            static::initializeFormats();\n        }\n\n        return isset(static::$formats[$format]) ? static::$formats[$format] : [];\n    }\n\n    /**\n     * Gets the format associated with the mime type.\n     *\n     * @param string $mimeType The associated mime type\n     *\n     * @return string|null The format (null if not found)\n     */\n    public function getFormat($mimeType)\n    {\n        $canonicalMimeType = null;\n        if (false !== $pos = strpos($mimeType, ';')) {\n            $canonicalMimeType = trim(substr($mimeType, 0, $pos));\n        }\n\n        if (null === static::$formats) {\n            static::initializeFormats();\n        }\n\n        foreach (static::$formats as $format => $mimeTypes) {\n            if (\\in_array($mimeType, (array) $mimeTypes)) {\n                return $format;\n            }\n            if (null !== $canonicalMimeType && \\in_array($canonicalMimeType, (array) $mimeTypes)) {\n                return $format;\n            }\n        }\n    }\n\n    /**\n     * Associates a format with mime types.\n     *\n     * @param string       $format    The format\n     * @param string|array $mimeTypes The associated mime types (the preferred one must be the first as it will be used as the content type)\n     */\n    public function setFormat($format, $mimeTypes)\n    {\n        if (null === static::$formats) {\n            static::initializeFormats();\n        }\n\n        static::$formats[$format] = \\is_array($mimeTypes) ? $mimeTypes : [$mimeTypes];\n    }\n\n    /**\n     * Gets the request format.\n     *\n     * Here is the process to determine the format:\n     *\n     *  * format defined by the user (with setRequestFormat())\n     *  * _format request attribute\n     *  * $default\n     *\n     * @param string|null $default The default format\n     *\n     * @return string|null The request format\n     */\n    public function getRequestFormat($default = 'html')\n    {\n        if (null === $this->format) {\n            $this->format = $this->attributes->get('_format');\n        }\n\n        return null === $this->format ? $default : $this->format;\n    }\n\n    /**\n     * Sets the request format.\n     *\n     * @param string $format The request format\n     */\n    public function setRequestFormat($format)\n    {\n        $this->format = $format;\n    }\n\n    /**\n     * Gets the format associated with the request.\n     *\n     * @return string|null The format (null if no content type is present)\n     */\n    public function getContentType()\n    {\n        return $this->getFormat($this->headers->get('CONTENT_TYPE'));\n    }\n\n    /**\n     * Sets the default locale.\n     *\n     * @param string $locale\n     */\n    public function setDefaultLocale($locale)\n    {\n        $this->defaultLocale = $locale;\n\n        if (null === $this->locale) {\n            $this->setPhpDefaultLocale($locale);\n        }\n    }\n\n    /**\n     * Get the default locale.\n     *\n     * @return string\n     */\n    public function getDefaultLocale()\n    {\n        return $this->defaultLocale;\n    }\n\n    /**\n     * Sets the locale.\n     *\n     * @param string $locale\n     */\n    public function setLocale($locale)\n    {\n        $this->setPhpDefaultLocale($this->locale = $locale);\n    }\n\n    /**\n     * Get the locale.\n     *\n     * @return string\n     */\n    public function getLocale()\n    {\n        return null === $this->locale ? $this->defaultLocale : $this->locale;\n    }\n\n    /**\n     * Checks if the request method is of specified type.\n     *\n     * @param string $method Uppercase request method (GET, POST etc)\n     *\n     * @return bool\n     */\n    public function isMethod($method)\n    {\n        return $this->getMethod() === strtoupper($method);\n    }\n\n    /**\n     * Checks whether or not the method is safe.\n     *\n     * @see https://tools.ietf.org/html/rfc7231#section-4.2.1\n     *\n     * @param bool $andCacheable Adds the additional condition that the method should be cacheable. True by default.\n     *\n     * @return bool\n     */\n    public function isMethodSafe(/* $andCacheable = true */)\n    {\n        if (!\\func_num_args() || func_get_arg(0)) {\n            // This deprecation should be turned into a BadMethodCallException in 4.0 (without adding the argument in the signature)\n            // then setting $andCacheable to false should be deprecated in 4.1\n            @trigger_error('Checking only for cacheable HTTP methods with Symfony\\Component\\HttpFoundation\\Request::isMethodSafe() is deprecated since Symfony 3.2 and will throw an exception in 4.0. Disable checking only for cacheable methods by calling the method with `false` as first argument or use the Request::isMethodCacheable() instead.', E_USER_DEPRECATED);\n\n            return \\in_array($this->getMethod(), ['GET', 'HEAD']);\n        }\n\n        return \\in_array($this->getMethod(), ['GET', 'HEAD', 'OPTIONS', 'TRACE']);\n    }\n\n    /**\n     * Checks whether or not the method is idempotent.\n     *\n     * @return bool\n     */\n    public function isMethodIdempotent()\n    {\n        return \\in_array($this->getMethod(), ['HEAD', 'GET', 'PUT', 'DELETE', 'TRACE', 'OPTIONS', 'PURGE']);\n    }\n\n    /**\n     * Checks whether the method is cacheable or not.\n     *\n     * @see https://tools.ietf.org/html/rfc7231#section-4.2.3\n     *\n     * @return bool True for GET and HEAD, false otherwise\n     */\n    public function isMethodCacheable()\n    {\n        return \\in_array($this->getMethod(), ['GET', 'HEAD']);\n    }\n\n    /**\n     * Returns the protocol version.\n     *\n     * If the application is behind a proxy, the protocol version used in the\n     * requests between the client and the proxy and between the proxy and the\n     * server might be different. This returns the former (from the \"Via\" header)\n     * if the proxy is trusted (see \"setTrustedProxies()\"), otherwise it returns\n     * the latter (from the \"SERVER_PROTOCOL\" server parameter).\n     *\n     * @return string\n     */\n    public function getProtocolVersion()\n    {\n        if ($this->isFromTrustedProxy()) {\n            preg_match('~^(HTTP/)?([1-9]\\.[0-9]) ~', $this->headers->get('Via'), $matches);\n\n            if ($matches) {\n                return 'HTTP/'.$matches[2];\n            }\n        }\n\n        return $this->server->get('SERVER_PROTOCOL');\n    }\n\n    /**\n     * Returns the request body content.\n     *\n     * @param bool $asResource If true, a resource will be returned\n     *\n     * @return string|resource The request body content or a resource to read the body stream\n     *\n     * @throws \\LogicException\n     */\n    public function getContent($asResource = false)\n    {\n        $currentContentIsResource = \\is_resource($this->content);\n        if (\\PHP_VERSION_ID < 50600 && false === $this->content) {\n            throw new \\LogicException('getContent() can only be called once when using the resource return type and PHP below 5.6.');\n        }\n\n        if (true === $asResource) {\n            if ($currentContentIsResource) {\n                rewind($this->content);\n\n                return $this->content;\n            }\n\n            // Content passed in parameter (test)\n            if (\\is_string($this->content)) {\n                $resource = fopen('php://temp', 'r+');\n                fwrite($resource, $this->content);\n                rewind($resource);\n\n                return $resource;\n            }\n\n            $this->content = false;\n\n            return fopen('php://input', 'rb');\n        }\n\n        if ($currentContentIsResource) {\n            rewind($this->content);\n\n            return stream_get_contents($this->content);\n        }\n\n        if (null === $this->content || false === $this->content) {\n            $this->content = file_get_contents('php://input');\n        }\n\n        return $this->content;\n    }\n\n    /**\n     * Gets the Etags.\n     *\n     * @return array The entity tags\n     */\n    public function getETags()\n    {\n        return preg_split('/\\s*,\\s*/', $this->headers->get('if_none_match'), null, PREG_SPLIT_NO_EMPTY);\n    }\n\n    /**\n     * @return bool\n     */\n    public function isNoCache()\n    {\n        return $this->headers->hasCacheControlDirective('no-cache') || 'no-cache' == $this->headers->get('Pragma');\n    }\n\n    /**\n     * Returns the preferred language.\n     *\n     * @param array $locales An array of ordered available locales\n     *\n     * @return string|null The preferred locale\n     */\n    public function getPreferredLanguage(array $locales = null)\n    {\n        $preferredLanguages = $this->getLanguages();\n\n        if (empty($locales)) {\n            return isset($preferredLanguages[0]) ? $preferredLanguages[0] : null;\n        }\n\n        if (!$preferredLanguages) {\n            return $locales[0];\n        }\n\n        $extendedPreferredLanguages = [];\n        foreach ($preferredLanguages as $language) {\n            $extendedPreferredLanguages[] = $language;\n            if (false !== $position = strpos($language, '_')) {\n                $superLanguage = substr($language, 0, $position);\n                if (!\\in_array($superLanguage, $preferredLanguages)) {\n                    $extendedPreferredLanguages[] = $superLanguage;\n                }\n            }\n        }\n\n        $preferredLanguages = array_values(array_intersect($extendedPreferredLanguages, $locales));\n\n        return isset($preferredLanguages[0]) ? $preferredLanguages[0] : $locales[0];\n    }\n\n    /**\n     * Gets a list of languages acceptable by the client browser.\n     *\n     * @return array Languages ordered in the user browser preferences\n     */\n    public function getLanguages()\n    {\n        if (null !== $this->languages) {\n            return $this->languages;\n        }\n\n        $languages = AcceptHeader::fromString($this->headers->get('Accept-Language'))->all();\n        $this->languages = [];\n        foreach ($languages as $lang => $acceptHeaderItem) {\n            if (false !== strpos($lang, '-')) {\n                $codes = explode('-', $lang);\n                if ('i' === $codes[0]) {\n                    // Language not listed in ISO 639 that are not variants\n                    // of any listed language, which can be registered with the\n                    // i-prefix, such as i-cherokee\n                    if (\\count($codes) > 1) {\n                        $lang = $codes[1];\n                    }\n                } else {\n                    for ($i = 0, $max = \\count($codes); $i < $max; ++$i) {\n                        if (0 === $i) {\n                            $lang = strtolower($codes[0]);\n                        } else {\n                            $lang .= '_'.strtoupper($codes[$i]);\n                        }\n                    }\n                }\n            }\n\n            $this->languages[] = $lang;\n        }\n\n        return $this->languages;\n    }\n\n    /**\n     * Gets a list of charsets acceptable by the client browser.\n     *\n     * @return array List of charsets in preferable order\n     */\n    public function getCharsets()\n    {\n        if (null !== $this->charsets) {\n            return $this->charsets;\n        }\n\n        return $this->charsets = array_keys(AcceptHeader::fromString($this->headers->get('Accept-Charset'))->all());\n    }\n\n    /**\n     * Gets a list of encodings acceptable by the client browser.\n     *\n     * @return array List of encodings in preferable order\n     */\n    public function getEncodings()\n    {\n        if (null !== $this->encodings) {\n            return $this->encodings;\n        }\n\n        return $this->encodings = array_keys(AcceptHeader::fromString($this->headers->get('Accept-Encoding'))->all());\n    }\n\n    /**\n     * Gets a list of content types acceptable by the client browser.\n     *\n     * @return array List of content types in preferable order\n     */\n    public function getAcceptableContentTypes()\n    {\n        if (null !== $this->acceptableContentTypes) {\n            return $this->acceptableContentTypes;\n        }\n\n        return $this->acceptableContentTypes = array_keys(AcceptHeader::fromString($this->headers->get('Accept'))->all());\n    }\n\n    /**\n     * Returns true if the request is a XMLHttpRequest.\n     *\n     * It works if your JavaScript library sets an X-Requested-With HTTP header.\n     * It is known to work with common JavaScript frameworks:\n     *\n     * @see http://en.wikipedia.org/wiki/List_of_Ajax_frameworks#JavaScript\n     *\n     * @return bool true if the request is an XMLHttpRequest, false otherwise\n     */\n    public function isXmlHttpRequest()\n    {\n        return 'XMLHttpRequest' == $this->headers->get('X-Requested-With');\n    }\n\n    /*\n     * The following methods are derived from code of the Zend Framework (1.10dev - 2010-01-24)\n     *\n     * Code subject to the new BSD license (http://framework.zend.com/license/new-bsd).\n     *\n     * Copyright (c) 2005-2010 Zend Technologies USA Inc. (http://www.zend.com)\n     */\n\n    protected function prepareRequestUri()\n    {\n        $requestUri = '';\n\n        if ('1' == $this->server->get('IIS_WasUrlRewritten') && '' != $this->server->get('UNENCODED_URL')) {\n            // IIS7 with URL Rewrite: make sure we get the unencoded URL (double slash problem)\n            $requestUri = $this->server->get('UNENCODED_URL');\n            $this->server->remove('UNENCODED_URL');\n            $this->server->remove('IIS_WasUrlRewritten');\n        } elseif ($this->server->has('REQUEST_URI')) {\n            $requestUri = $this->server->get('REQUEST_URI');\n\n            if ('' !== $requestUri && '/' === $requestUri[0]) {\n                // To only use path and query remove the fragment.\n                if (false !== $pos = strpos($requestUri, '#')) {\n                    $requestUri = substr($requestUri, 0, $pos);\n                }\n            } else {\n                // HTTP proxy reqs setup request URI with scheme and host [and port] + the URL path,\n                // only use URL path.\n                $uriComponents = parse_url($requestUri);\n\n                if (isset($uriComponents['path'])) {\n                    $requestUri = $uriComponents['path'];\n                }\n\n                if (isset($uriComponents['query'])) {\n                    $requestUri .= '?'.$uriComponents['query'];\n                }\n            }\n        } elseif ($this->server->has('ORIG_PATH_INFO')) {\n            // IIS 5.0, PHP as CGI\n            $requestUri = $this->server->get('ORIG_PATH_INFO');\n            if ('' != $this->server->get('QUERY_STRING')) {\n                $requestUri .= '?'.$this->server->get('QUERY_STRING');\n            }\n            $this->server->remove('ORIG_PATH_INFO');\n        }\n\n        // normalize the request URI to ease creating sub-requests from this request\n        $this->server->set('REQUEST_URI', $requestUri);\n\n        return $requestUri;\n    }\n\n    /**\n     * Prepares the base URL.\n     *\n     * @return string\n     */\n    protected function prepareBaseUrl()\n    {\n        $filename = basename($this->server->get('SCRIPT_FILENAME'));\n\n        if (basename($this->server->get('SCRIPT_NAME')) === $filename) {\n            $baseUrl = $this->server->get('SCRIPT_NAME');\n        } elseif (basename($this->server->get('PHP_SELF')) === $filename) {\n            $baseUrl = $this->server->get('PHP_SELF');\n        } elseif (basename($this->server->get('ORIG_SCRIPT_NAME')) === $filename) {\n            $baseUrl = $this->server->get('ORIG_SCRIPT_NAME'); // 1and1 shared hosting compatibility\n        } else {\n            // Backtrack up the script_filename to find the portion matching\n            // php_self\n            $path = $this->server->get('PHP_SELF', '');\n            $file = $this->server->get('SCRIPT_FILENAME', '');\n            $segs = explode('/', trim($file, '/'));\n            $segs = array_reverse($segs);\n            $index = 0;\n            $last = \\count($segs);\n            $baseUrl = '';\n            do {\n                $seg = $segs[$index];\n                $baseUrl = '/'.$seg.$baseUrl;\n                ++$index;\n            } while ($last > $index && (false !== $pos = strpos($path, $baseUrl)) && 0 != $pos);\n        }\n\n        // Does the baseUrl have anything in common with the request_uri?\n        $requestUri = $this->getRequestUri();\n        if ('' !== $requestUri && '/' !== $requestUri[0]) {\n            $requestUri = '/'.$requestUri;\n        }\n\n        if ($baseUrl && false !== $prefix = $this->getUrlencodedPrefix($requestUri, $baseUrl)) {\n            // full $baseUrl matches\n            return $prefix;\n        }\n\n        if ($baseUrl && false !== $prefix = $this->getUrlencodedPrefix($requestUri, rtrim(\\dirname($baseUrl), '/'.\\DIRECTORY_SEPARATOR).'/')) {\n            // directory portion of $baseUrl matches\n            return rtrim($prefix, '/'.\\DIRECTORY_SEPARATOR);\n        }\n\n        $truncatedRequestUri = $requestUri;\n        if (false !== $pos = strpos($requestUri, '?')) {\n            $truncatedRequestUri = substr($requestUri, 0, $pos);\n        }\n\n        $basename = basename($baseUrl);\n        if (empty($basename) || !strpos(rawurldecode($truncatedRequestUri), $basename)) {\n            // no match whatsoever; set it blank\n            return '';\n        }\n\n        // If using mod_rewrite or ISAPI_Rewrite strip the script filename\n        // out of baseUrl. $pos !== 0 makes sure it is not matching a value\n        // from PATH_INFO or QUERY_STRING\n        if (\\strlen($requestUri) >= \\strlen($baseUrl) && (false !== $pos = strpos($requestUri, $baseUrl)) && 0 !== $pos) {\n            $baseUrl = substr($requestUri, 0, $pos + \\strlen($baseUrl));\n        }\n\n        return rtrim($baseUrl, '/'.\\DIRECTORY_SEPARATOR);\n    }\n\n    /**\n     * Prepares the base path.\n     *\n     * @return string base path\n     */\n    protected function prepareBasePath()\n    {\n        $baseUrl = $this->getBaseUrl();\n        if (empty($baseUrl)) {\n            return '';\n        }\n\n        $filename = basename($this->server->get('SCRIPT_FILENAME'));\n        if (basename($baseUrl) === $filename) {\n            $basePath = \\dirname($baseUrl);\n        } else {\n            $basePath = $baseUrl;\n        }\n\n        if ('\\\\' === \\DIRECTORY_SEPARATOR) {\n            $basePath = str_replace('\\\\', '/', $basePath);\n        }\n\n        return rtrim($basePath, '/');\n    }\n\n    /**\n     * Prepares the path info.\n     *\n     * @return string path info\n     */\n    protected function preparePathInfo()\n    {\n        if (null === ($requestUri = $this->getRequestUri())) {\n            return '/';\n        }\n\n        // Remove the query string from REQUEST_URI\n        if (false !== $pos = strpos($requestUri, '?')) {\n            $requestUri = substr($requestUri, 0, $pos);\n        }\n        if ('' !== $requestUri && '/' !== $requestUri[0]) {\n            $requestUri = '/'.$requestUri;\n        }\n\n        if (null === ($baseUrl = $this->getBaseUrl())) {\n            return $requestUri;\n        }\n\n        $pathInfo = substr($requestUri, \\strlen($baseUrl));\n        if (false === $pathInfo || '' === $pathInfo) {\n            // If substr() returns false then PATH_INFO is set to an empty string\n            return '/';\n        }\n\n        return (string) $pathInfo;\n    }\n\n    /**\n     * Initializes HTTP request formats.\n     */\n    protected static function initializeFormats()\n    {\n        static::$formats = [\n            'html' => ['text/html', 'application/xhtml+xml'],\n            'txt' => ['text/plain'],\n            'js' => ['application/javascript', 'application/x-javascript', 'text/javascript'],\n            'css' => ['text/css'],\n            'json' => ['application/json', 'application/x-json'],\n            'jsonld' => ['application/ld+json'],\n            'xml' => ['text/xml', 'application/xml', 'application/x-xml'],\n            'rdf' => ['application/rdf+xml'],\n            'atom' => ['application/atom+xml'],\n            'rss' => ['application/rss+xml'],\n            'form' => ['application/x-www-form-urlencoded'],\n        ];\n    }\n\n    /**\n     * Sets the default PHP locale.\n     *\n     * @param string $locale\n     */\n    private function setPhpDefaultLocale($locale)\n    {\n        // if either the class Locale doesn't exist, or an exception is thrown when\n        // setting the default locale, the intl module is not installed, and\n        // the call can be ignored:\n        try {\n            if (class_exists('Locale', false)) {\n                \\Locale::setDefault($locale);\n            }\n        } catch (\\Exception $e) {\n        }\n    }\n\n    /*\n     * Returns the prefix as encoded in the string when the string starts with\n     * the given prefix, false otherwise.\n     *\n     * @param string $string The urlencoded string\n     * @param string $prefix The prefix not encoded\n     *\n     * @return string|false The prefix as it is encoded in $string, or false\n     */\n    private function getUrlencodedPrefix($string, $prefix)\n    {\n        if (0 !== strpos(rawurldecode($string), $prefix)) {\n            return false;\n        }\n\n        $len = \\strlen($prefix);\n\n        if (preg_match(sprintf('#^(%%[[:xdigit:]]{2}|.){%d}#', $len), $string, $match)) {\n            return $match[0];\n        }\n\n        return false;\n    }\n\n    private static function createRequestFromFactory(array $query = [], array $request = [], array $attributes = [], array $cookies = [], array $files = [], array $server = [], $content = null)\n    {\n        if (self::$requestFactory) {\n            $request = \\call_user_func(self::$requestFactory, $query, $request, $attributes, $cookies, $files, $server, $content);\n\n            if (!$request instanceof self) {\n                throw new \\LogicException('The Request factory must return an instance of Symfony\\Component\\HttpFoundation\\Request.');\n            }\n\n            return $request;\n        }\n\n        return new static($query, $request, $attributes, $cookies, $files, $server, $content);\n    }\n\n    /**\n     * Indicates whether this request originated from a trusted proxy.\n     *\n     * This can be useful to determine whether or not to trust the\n     * contents of a proxy-specific header.\n     *\n     * @return bool true if the request came from a trusted proxy, false otherwise\n     */\n    public function isFromTrustedProxy()\n    {\n        return self::$trustedProxies && IpUtils::checkIp($this->server->get('REMOTE_ADDR'), self::$trustedProxies);\n    }\n\n    private function getTrustedValues($type, $ip = null)\n    {\n        $clientValues = [];\n        $forwardedValues = [];\n\n        if (self::$trustedHeaders[$type] && $this->headers->has(self::$trustedHeaders[$type])) {\n            foreach (explode(',', $this->headers->get(self::$trustedHeaders[$type])) as $v) {\n                $clientValues[] = (self::HEADER_CLIENT_PORT === $type ? '0.0.0.0:' : '').trim($v);\n            }\n        }\n\n        if (self::$trustedHeaders[self::HEADER_FORWARDED] && $this->headers->has(self::$trustedHeaders[self::HEADER_FORWARDED])) {\n            $forwardedValues = $this->headers->get(self::$trustedHeaders[self::HEADER_FORWARDED]);\n            $forwardedValues = preg_match_all(sprintf('{(?:%s)=\"?([a-zA-Z0-9\\.:_\\-/\\[\\]]*+)}', self::$forwardedParams[$type]), $forwardedValues, $matches) ? $matches[1] : [];\n            if (self::HEADER_CLIENT_PORT === $type) {\n                foreach ($forwardedValues as $k => $v) {\n                    if (']' === substr($v, -1) || false === $v = strrchr($v, ':')) {\n                        $v = $this->isSecure() ? ':443' : ':80';\n                    }\n                    $forwardedValues[$k] = '0.0.0.0'.$v;\n                }\n            }\n        }\n\n        if (null !== $ip) {\n            $clientValues = $this->normalizeAndFilterClientIps($clientValues, $ip);\n            $forwardedValues = $this->normalizeAndFilterClientIps($forwardedValues, $ip);\n        }\n\n        if ($forwardedValues === $clientValues || !$clientValues) {\n            return $forwardedValues;\n        }\n\n        if (!$forwardedValues) {\n            return $clientValues;\n        }\n\n        if (!$this->isForwardedValid) {\n            return null !== $ip ? ['0.0.0.0', $ip] : [];\n        }\n        $this->isForwardedValid = false;\n\n        throw new ConflictingHeadersException(sprintf('The request has both a trusted \"%s\" header and a trusted \"%s\" header, conflicting with each other. You should either configure your proxy to remove one of them, or configure your project to distrust the offending one.', self::$trustedHeaders[self::HEADER_FORWARDED], self::$trustedHeaders[$type]));\n    }\n\n    private function normalizeAndFilterClientIps(array $clientIps, $ip)\n    {\n        if (!$clientIps) {\n            return [];\n        }\n        $clientIps[] = $ip; // Complete the IP chain with the IP the request actually came from\n        $firstTrustedIp = null;\n\n        foreach ($clientIps as $key => $clientIp) {\n            if (strpos($clientIp, '.')) {\n                // Strip :port from IPv4 addresses. This is allowed in Forwarded\n                // and may occur in X-Forwarded-For.\n                $i = strpos($clientIp, ':');\n                if ($i) {\n                    $clientIps[$key] = $clientIp = substr($clientIp, 0, $i);\n                }\n            } elseif (0 === strpos($clientIp, '[')) {\n                // Strip brackets and :port from IPv6 addresses.\n                $i = strpos($clientIp, ']', 1);\n                $clientIps[$key] = $clientIp = substr($clientIp, 1, $i - 1);\n            }\n\n            if (!filter_var($clientIp, FILTER_VALIDATE_IP)) {\n                unset($clientIps[$key]);\n\n                continue;\n            }\n\n            if (IpUtils::checkIp($clientIp, self::$trustedProxies)) {\n                unset($clientIps[$key]);\n\n                // Fallback to this when the client IP falls into the range of trusted proxies\n                if (null === $firstTrustedIp) {\n                    $firstTrustedIp = $clientIp;\n                }\n            }\n        }\n\n        // Now the IP chain contains only untrusted proxies and the client IP\n        return $clientIps ? array_reverse($clientIps) : [$firstTrustedIp];\n    }\n}\n"], "filenames": ["src/Symfony/Component/HttpFoundation/Request.php"], "buggy_code_start_loc": [1349], "buggy_code_end_loc": [1365], "fixing_code_start_loc": [1349], "fixing_code_end_loc": [1380], "type": "CWE-79", "message": "In Symfony before 2.7.51, 2.8.x before 2.8.50, 3.x before 3.4.26, 4.x before 4.1.12, and 4.2.x before 4.2.7, HTTP Methods provided as verbs or using the override header may be treated as trusted input, but they are not validated, possibly causing SQL injection or XSS. This is related to symfony/http-foundation.", "other": {"cve": {"id": "CVE-2019-10913", "sourceIdentifier": "cve@mitre.org", "published": "2019-05-16T22:29:00.673", "lastModified": "2020-08-24T17:37:01.140", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In Symfony before 2.7.51, 2.8.x before 2.8.50, 3.x before 3.4.26, 4.x before 4.1.12, and 4.2.x before 4.2.7, HTTP Methods provided as verbs or using the override header may be treated as trusted input, but they are not validated, possibly causing SQL injection or XSS. This is related to symfony/http-foundation."}, {"lang": "es", "value": "En Symfony la versi\u00f3n anterior a 2.7.51, versi\u00f3n 2.8.x anterior a 2.8.50, versi\u00f3n 3.x anterior a 3.4.26, versi\u00f3n 4.x anterior a 4.1.12 y versi\u00f3n 4.2.x anterior a 4.2.7, los m\u00e9todos HTTP se proporcionan como verbos o usando el encabezado de anulaci\u00f3n pueden tratarse como entradas de confianza, pero no est\u00e1n validadas, lo que posiblemente provoque la inyecci\u00f3n de SQL o XSS. Esto est\u00e1 relacionado con Symfony/http-foundation."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}, {"lang": "en", "value": "CWE-89"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:sensiolabs:symfony:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.7.0", "versionEndExcluding": "2.7.51", "matchCriteriaId": "A86884C0-A185-4CCF-AB21-1D1529AEDAED"}, {"vulnerable": true, "criteria": "cpe:2.3:a:sensiolabs:symfony:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.8.0", "versionEndExcluding": "2.8.50", "matchCriteriaId": "A4716654-1055-44B3-8E51-5BC0E739E0CB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:sensiolabs:symfony:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.4.0", "versionEndExcluding": "3.4.26", "matchCriteriaId": "CF53486E-FAAC-40B3-82CE-4EDCD2C96690"}, {"vulnerable": true, "criteria": "cpe:2.3:a:sensiolabs:symfony:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.1.0", "versionEndExcluding": "4.1.12", "matchCriteriaId": "25A92454-6E0B-4BDE-8967-BB3E32125102"}, {"vulnerable": true, "criteria": "cpe:2.3:a:sensiolabs:symfony:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.2.0", "versionEndExcluding": "4.2.7", "matchCriteriaId": "53E58B92-6D5D-4949-B75F-687F52961FDA"}]}]}], "references": [{"url": "https://github.com/symfony/symfony/commit/944e60f083c3bffbc6a0b5112db127a10a66a8ec", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://symfony.com/blog/cve-2019-10913-reject-invalid-http-method-overrides", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/symfony/symfony/commit/944e60f083c3bffbc6a0b5112db127a10a66a8ec"}}