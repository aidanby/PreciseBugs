{"buggy_code": ["from __future__ import annotations\n\nfrom typing import List\n\nfrom fastapi import HTTPException, status\nfrom starlette.status import (\n    HTTP_400_BAD_REQUEST,\n    HTTP_401_UNAUTHORIZED,\n    HTTP_404_NOT_FOUND,\n)\n\nfrom fides.common.api.scope_registry import SCOPE_REGISTRY as SCOPES\n\n\nclass FidesopsException(Exception):\n    \"\"\"Base class for fidesops exceptions\"\"\"\n\n    def __init__(self, message: str, errors: List[str] = []):\n        super().__init__(message)\n        self.message = message\n        self.errors = errors\n\n\nclass TraversalError(FidesopsException):\n    \"\"\"Fidesops error with the names of all nodes that could not be reached.\"\"\"\n\n\nclass ValidationError(FidesopsException):\n    \"\"\"Data does not pass validation.\"\"\"\n\n\nclass StorageUploadError(FidesopsException):\n    \"\"\"Data cannot be uploaded to storage destination\"\"\"\n\n\nclass SystemManagerException(FidesopsException):\n    \"\"\"Exception class when there are errors making a systemmanager\"\"\"\n\n\nclass ConnectionException(FidesopsException):\n    \"\"\"Exception class when there are errors making a connection\"\"\"\n\n\nclass InsufficientDataException(FidesopsException):\n    \"\"\"Exception class when there is not sufficient data to proceed\"\"\"\n\n\nclass SkippingConsentPropagation(BaseException):\n    \"\"\"Skipping consent propagation for collection. Used to trigger \"skipped\" execution logs being created where applicable\n    for Privacy Preference requests on saas connectors.\n    \"\"\"\n\n\nclass RedisConnectionError(Exception):\n    \"\"\"The Configured Redis instance is uncontactable.\"\"\"\n\n\nclass MisconfiguredPolicyException(Exception):\n    \"\"\"Thrown when a Privacy Request cannot be processed due to a misconfigured Policy.\"\"\"\n\n\nclass PolicyValidationError(ValueError):\n    \"\"\"The policy you are trying to create has invalid data\"\"\"\n\n\nclass InvalidDataLengthValidationError(ValueError):\n    \"\"\"The length provided is invalid\"\"\"\n\n\nclass RuleValidationError(ValueError):\n    \"\"\"The Rule you are trying to create has invalid data\"\"\"\n\n\nclass StorageConfigValidationError(ValueError):\n    \"\"\"The Storage Config you are trying to create has invalid data\"\"\"\n\n\nclass InvalidDataTypeValidationError(ValueError):\n    \"\"\"The specified data type is invalid.\"\"\"\n\n\nclass RuleTargetValidationError(ValueError):\n    \"\"\"The Rule you are trying to create has invalid data\"\"\"\n\n\nclass DataCategoryNotSupported(ValueError):\n    \"\"\"The data category you have supplied is not supported.\"\"\"\n\n\nclass PolicyNotFoundException(Exception):\n    \"\"\"Policy could not be found\"\"\"\n\n\nclass ConnectorNotFoundException(Exception):\n    \"\"\"Connector could not be found\"\"\"\n\n\nclass DrpActionValidationError(Exception):\n    \"\"\"A resource already exists with this DRP Action.\"\"\"\n\n\nclass StorageConfigNotFoundException(BaseException):\n    \"\"\"Custom Exception - StorageConfig Not Found\"\"\"\n\n\nclass PrivacyNoticeHistoryNotFound(BaseException):\n    \"\"\"PrivacyNoticeHistory Not Found\"\"\"\n\n\nclass IdentityNotFoundException(BaseException):\n    \"\"\"Identity Not Found\"\"\"\n\n\nclass WebhookOrderException(BaseException):\n    \"\"\"Custom Exception - Issue with webhooks order\"\"\"\n\n\nclass PostProcessingException(BaseException):\n    \"\"\"Custom Exception - Issue with post processing\"\"\"\n\n\nclass CollectionDisabled(BaseException):\n    \"\"\"Collection is attached to disabled ConnectionConfig\"\"\"\n\n\nclass NotSupportedForCollection(BaseException):\n    \"\"\"The given action is not supported for this type of collection\"\"\"\n\n\nclass PrivacyRequestPaused(BaseException):\n    \"\"\"Halt Instruction Received on Privacy Request\"\"\"\n\n\nclass PrivacyRequestNotFound(BaseException):\n    \"\"\"Privacy Request Not Found\"\"\"\n\n\nclass NoCachedManualWebhookEntry(BaseException):\n    \"\"\"No manual data exists for this webhook on the given privacy request.\"\"\"\n\n\nclass ManualWebhookFieldsUnset(BaseException):\n    \"\"\"Manual webhook has fields that are not explicitly set: Likely new field has been added\"\"\"\n\n\nclass PrivacyRequestErasureEmailSendRequired(BaseException):\n    \"\"\"Erasure requests will need to be fulfilled by email send.  Exception is raised to change ExecutionLog details\"\"\"\n\n\nclass SaaSConfigNotFoundException(FidesopsException):\n    \"\"\"Custom Exception - SaaS Config Not Found\"\"\"\n\n\nclass MessagingConfigNotFoundException(FidesopsException):\n    \"\"\"Custom Exception - Messaging Config Not Found\"\"\"\n\n\nclass MessageDispatchException(FidesopsException):\n    \"\"\"Custom Exception - Message Dispatch Error\"\"\"\n\n\nclass EmailTemplateUnhandledActionType(FidesopsException):\n    \"\"\"Custom Exception - Email Template Unhandled ActionType Error\"\"\"\n\n\nclass OAuth2TokenException(FidesopsException):\n    \"\"\"Custom Exception - Unable to access or refresh OAuth2 tokens for SaaS connector\"\"\"\n\n\nclass AuthenticationFailure(HTTPException):\n    \"\"\"Wrapper for authentication failure exception\"\"\"\n\n    def __init__(self, detail: str) -> None:\n        super().__init__(status_code=HTTP_401_UNAUTHORIZED, detail=detail)\n\n\nclass BadRequest(HTTPException):\n    \"\"\"Wrapper for bad request exception\"\"\"\n\n    def __init__(self, detail: str) -> None:\n        super().__init__(status_code=HTTP_400_BAD_REQUEST, detail=detail)\n\n\nclass NotFoundException(HTTPException):\n    \"\"\"Wrapper for not found exception\"\"\"\n\n    def __init__(self, detail: str) -> None:\n        super().__init__(status_code=HTTP_404_NOT_FOUND, detail=detail)\n\n\nclass ClientUnsuccessfulException(FidesopsException):\n    \"\"\"Exception for when client call fails\"\"\"\n\n    def __init__(self, status_code: int):\n        super().__init__(message=f\"Client call failed with status code '{status_code}'\")\n\n\nclass NoSuchStrategyException(ValueError):\n    \"\"\"Exception for when a masking strategy does not exist\"\"\"\n\n\nclass FunctionalityNotConfigured(Exception):\n    \"\"\"Custom exception for when invoked functionality is unavailable due to configuration.\"\"\"\n\n\nclass InvalidSaaSRequestOverrideException(ValueError):\n    \"\"\"Exception for when a provied SaaS request override function is invalid\"\"\"\n\n\nclass NoSuchSaaSRequestOverrideException(ValueError):\n    \"\"\"Exception for when a requested SaaS request override function does not exist\"\"\"\n\n\nclass IdentityVerificationException(FidesopsException):\n    \"\"\"Custom exceptions for when we cannot verify the identity of a subjct\"\"\"\n\n\nclass NoSuchConnectionTypeSecretSchemaError(Exception):\n    \"\"\"Exception for when a connection type secret schema is not found.\"\"\"\n\n\nclass SSHTunnelConfigNotFoundException(Exception):\n    \"\"\"Exception for when Fides is configured to use an SSH tunnel without config provided.\"\"\"\n\n\nclass AuthenticationError(HTTPException):\n    \"\"\"To be raised when attempting to fetch an access token using\n    invalid credentials.\n    \"\"\"\n\n    def __init__(self, detail: str) -> None:\n        super().__init__(\n            status_code=status.HTTP_401_UNAUTHORIZED,\n            detail=detail,\n        )\n\n\nclass AuthorizationError(HTTPException):\n    \"\"\"Throws an HTTP 403\"\"\"\n\n    def __init__(self, detail: str) -> None:\n        \"\"\"Override the regular HTTPException throwing only a 403\"\"\"\n        super().__init__(status_code=status.HTTP_403_FORBIDDEN, detail=detail)\n\n\nclass ClientWriteFailedError(HTTPException):\n    \"\"\"To be raised when a client cannot be created.\"\"\"\n\n    def __init__(self) -> None:\n        super().__init__(\n            status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,\n            detail=\"Failed to create client\",\n        )\n\n\nclass ClientNotFoundError(HTTPException):\n    \"\"\"To be raised when attempting to fetch a client that does not exist.\"\"\"\n\n    def __init__(self, client_id: str) -> None:\n        super().__init__(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail={\n                \"error\": \"Client does not exist\",\n                \"id\": client_id,\n            },\n        )\n\n\nclass ExpiredTokenError(HTTPException):\n    \"\"\"To be raised when a provided token is expired.\"\"\"\n\n    def __init__(self) -> None:\n        super().__init__(\n            status_code=status.HTTP_403_FORBIDDEN,\n            detail=\"OAuth token expired\",\n        )\n\n\nclass InvalidAuthorizationSchemeError(HTTPException):\n    \"\"\"To be raised when attempting to authenticate with an unexpected\n    Authorization header value.\n    \"\"\"\n\n    def __init__(self) -> None:\n        super().__init__(\n            status_code=status.HTTP_401_UNAUTHORIZED,\n            detail=\"Failed to authenticate\",\n            headers={\"WWW-Authenticate\": \"Bearer\"},\n        )\n\n\nclass InvalidScopeError(HTTPException):\n    \"\"\"To be raised when a provided scope does not exist.\"\"\"\n\n    def __init__(self, invalid_scopes: list[str]) -> None:\n        SCOPES.sort()\n\n        super().__init__(\n            status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,\n            detail={\n                \"error\": \"Invalid scope provided\",\n                \"invalid_scopes\": invalid_scopes,\n                \"valid_scopes\": SCOPES,\n            },\n        )\n\n\nclass KeyOrNameAlreadyExists(Exception):\n    \"\"\"A resource already exists with this key or name.\"\"\"\n\n\nclass KeyValidationError(Exception):\n    \"\"\"The resource you're trying to create has a key specified but not\n    a name specified.\n    \"\"\"\n\n\nclass MissingConfig(Exception):\n    \"\"\"Custom exception for when no valid configuration file is provided.\"\"\"\n", "\"\"\"\nContains the code that sets up the API.\n\"\"\"\nimport sys\nfrom datetime import datetime, timezone\nfrom logging import WARNING\nfrom typing import Callable, Optional\n\nfrom fastapi import HTTPException, Request, Response, status\nfrom fastapi.responses import FileResponse\nfrom fideslog.sdk.python.event import AnalyticsEvent\nfrom loguru import logger\nfrom starlette.background import BackgroundTask\nfrom uvicorn import Config, Server\n\nimport fides\nfrom fides.api.app_setup import (\n    check_redis,\n    create_fides_app,\n    log_startup,\n    run_database_startup,\n)\nfrom fides.api.middleware import handle_audit_log_resource\nfrom fides.api.schemas.analytics import Event, ExtraData\n\n# pylint: disable=wildcard-import, unused-wildcard-import\nfrom fides.api.service.privacy_request.email_batch_service import (\n    initiate_scheduled_batch_email_send,\n)\nfrom fides.api.tasks.scheduled.scheduler import scheduler\nfrom fides.api.ui import (\n    get_admin_index_as_response,\n    get_path_to_admin_ui_file,\n    get_ui_file_map,\n    match_route,\n    path_is_in_ui_directory,\n)\nfrom fides.api.util.endpoint_utils import API_PREFIX\nfrom fides.api.util.logger import _log_exception\nfrom fides.cli.utils import FIDES_ASCII_ART\nfrom fides.config import CONFIG, check_required_webserver_config_values\n\nIGNORED_AUDIT_LOG_RESOURCE_PATHS = {\"/api/v1/login\"}\n\nVERSION = fides.__version__\n\napp = create_fides_app()\n\n\n@app.middleware(\"http\")\nasync def dispatch_log_request(request: Request, call_next: Callable) -> Response:\n    \"\"\"\n    HTTP Middleware that logs analytics events for each call to Fides endpoints.\n    :param request: Request to Fides api\n    :param call_next: Callable api endpoint\n    :return: Response\n    \"\"\"\n\n    # Only log analytics events for requests that are for API endpoints (i.e. /api/...)\n    path = request.url.path\n    if (not path.startswith(API_PREFIX)) or (path.endswith(\"/health\")):\n        return await call_next(request)\n\n    fides_source: Optional[str] = request.headers.get(\"X-Fides-Source\")\n    now: datetime = datetime.now(tz=timezone.utc)\n    endpoint = f\"{request.method}: {request.url}\"\n\n    try:\n        response = await call_next(request)\n        # HTTPExceptions are considered a handled err by default so are not thrown here.\n        # Accepted workaround is to inspect status code of response.\n        # More context- https://github.com/tiangolo/fastapi/issues/1840\n        response.background = BackgroundTask(\n            prepare_and_log_request,\n            endpoint,\n            request.url.hostname,\n            response.status_code,\n            now,\n            fides_source,\n            \"HTTPException\" if response.status_code >= 400 else None,\n        )\n        return response\n\n    except Exception as e:\n        await prepare_and_log_request(\n            endpoint, request.url.hostname, 500, now, fides_source, e.__class__.__name__\n        )\n        _log_exception(e, CONFIG.dev_mode)\n        raise\n\n\nasync def prepare_and_log_request(\n    endpoint: str,\n    hostname: Optional[str],\n    status_code: int,\n    event_created_at: datetime,\n    fides_source: Optional[str],\n    error_class: Optional[str],\n) -> None:\n    \"\"\"\n    Prepares and sends analytics event provided the user is not opted out of analytics.\n    \"\"\"\n    # Avoid circular imports\n    from fides.api.analytics import (\n        accessed_through_local_host,\n        in_docker_container,\n        send_analytics_event,\n    )\n\n    # this check prevents AnalyticsEvent from being called with invalid endpoint during unit tests\n    if CONFIG.user.analytics_opt_out:\n        return\n    await send_analytics_event(\n        AnalyticsEvent(\n            docker=in_docker_container(),\n            event=Event.endpoint_call.value,\n            event_created_at=event_created_at,\n            local_host=accessed_through_local_host(hostname),\n            endpoint=endpoint,\n            status_code=status_code,\n            error=error_class or None,\n            extra_data={ExtraData.fides_source.value: fides_source}\n            if fides_source\n            else None,\n        )\n    )\n\n\n@app.middleware(\"http\")\nasync def log_request(request: Request, call_next: Callable) -> Response:\n    \"\"\"Log basic information about every request handled by the server.\"\"\"\n    start = datetime.now()\n    response = await call_next(request)\n    handler_time = datetime.now() - start\n    logger.bind(\n        method=request.method,\n        status_code=response.status_code,\n        handler_time=f\"{round(handler_time.microseconds * 0.001,3)}ms\",\n        path=request.url.path,\n    ).info(\"Request received\")\n    return response\n\n\n# Configure the static file paths last since otherwise it will take over all paths\n@app.get(\"/\", tags=[\"Default\"])\ndef read_index() -> Response:\n    \"\"\"\n    Return an index.html at the root path\n    \"\"\"\n\n    return get_admin_index_as_response()\n\n\n@app.get(\"/{catchall:path}\", response_class=Response, tags=[\"Default\"])\ndef read_other_paths(request: Request) -> Response:\n    \"\"\"\n    Return related frontend files. Adapted from https://github.com/tiangolo/fastapi/issues/130\n    \"\"\"\n    # check first if requested file exists (for frontend assets)\n    path = request.path_params[\"catchall\"]\n\n    # search for matching route in package (i.e. /dataset)\n    ui_file = match_route(get_ui_file_map(), path)\n\n    # if not, check if the requested file is an asset (i.e. /_next/static/...)\n    if not ui_file:\n        ui_file = get_path_to_admin_ui_file(path)\n\n    # Serve up the file as long as it is within the UI directory\n    if ui_file and ui_file.is_file():\n        if not path_is_in_ui_directory(ui_file):\n            raise HTTPException(\n                status_code=status.HTTP_404_NOT_FOUND, detail=\"Item not found\"\n            )\n        logger.debug(\n            \"catchall request path '{}' matched static admin UI file: {}\",\n            path,\n            ui_file,\n        )\n        return FileResponse(ui_file)\n\n    # raise 404 for anything that should be backend endpoint but we can't find it\n    if path.startswith(API_PREFIX[1:]):\n        logger.debug(\n            \"catchall request path '{}' matched an invalid API route, return 404\",\n            path,\n        )\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND, detail=\"Item not found\"\n        )\n\n    # otherwise return the index\n    logger.debug(\n        \"catchall request path '{}' did not match any admin UI routes, return generic admin UI index\",\n        path,\n    )\n    return get_admin_index_as_response()\n\n\n@app.on_event(\"startup\")\nasync def setup_server() -> None:\n    \"\"\"Run all of the required setup steps for the webserver.\n\n    **NOTE**: The order of operations here _is_ deliberate\n    and must be maintained.\n    \"\"\"\n    if not CONFIG.dev_mode:\n        sys.tracebacklimit = 0\n\n    log_startup()\n\n    await run_database_startup()\n\n    check_redis()\n\n    if not scheduler.running:\n        scheduler.start()\n\n    initiate_scheduled_batch_email_send()\n\n    logger.debug(\"Sending startup analytics events...\")\n    # Avoid circular imports\n    from fides.api.analytics import in_docker_container, send_analytics_event\n\n    await send_analytics_event(\n        AnalyticsEvent(\n            docker=in_docker_container(),\n            event=Event.server_start.value,\n            event_created_at=datetime.now(tz=timezone.utc),\n        )\n    )\n\n    logger.info(FIDES_ASCII_ART)\n    logger.info(f\"Fides startup complete! v{VERSION}\")\n\n\ndef start_webserver(port: int = 8080) -> None:\n    \"\"\"Run the webserver.\"\"\"\n    check_required_webserver_config_values(config=CONFIG)\n    server = Server(Config(app, host=\"0.0.0.0\", port=port, log_level=WARNING))\n\n    logger.info(\n        \"Starting webserver - Host: {}, Port: {}, Log Level: {}\",\n        server.config.host,\n        server.config.port,\n        server.config.log_level,\n    )\n    server.run()\n\n\n@app.middleware(\"http\")\nasync def action_to_audit_log(\n    request: Request,\n    call_next: Callable,\n) -> Response:\n    \"\"\"Log basic information about every non-GET request handled by the server.\"\"\"\n\n    if (\n        request.method != \"GET\"\n        and request.scope[\"path\"] not in IGNORED_AUDIT_LOG_RESOURCE_PATHS\n        and CONFIG.security.enable_audit_log_resource_middleware\n    ):\n        try:\n            await handle_audit_log_resource(request)\n        except Exception as exc:\n            logger.debug(exc)\n    return await call_next(request)\n", "import pytest\nfrom starlette.status import HTTP_200_OK, HTTP_404_NOT_FOUND\nfrom starlette.testclient import TestClient\n\nfrom fides.api.models.client import ClientDetail\nfrom fides.common.api.scope_registry import PRIVACY_REQUEST_READ\nfrom fides.common.api.v1.urn_registry import PRIVACY_REQUESTS, V1_URL_PREFIX\n\n\nclass TestApiRouter:\n    @pytest.fixture(scope=\"function\")\n    def url(self, oauth_client: ClientDetail) -> str:\n        return V1_URL_PREFIX + PRIVACY_REQUESTS\n\n    def test_no_trailing_slash(\n        self, api_client: TestClient, generate_auth_header, url\n    ) -> None:\n        auth_header = generate_auth_header(scopes=[PRIVACY_REQUEST_READ])\n        resp = api_client.get(url, headers=auth_header)\n        assert resp.status_code == HTTP_200_OK\n\n    def test_trailing_slash(\n        self, api_client: TestClient, generate_auth_header, url\n    ) -> None:\n        auth_header = generate_auth_header(scopes=[PRIVACY_REQUEST_READ])\n        resp = api_client.get(f\"{url}/\", headers=auth_header)\n        assert resp.status_code == HTTP_200_OK\n\n    def test_non_existent_route_404(\n        self, api_client: TestClient, generate_auth_header, url\n    ) -> None:\n        auth_header = generate_auth_header(scopes=[PRIVACY_REQUEST_READ])\n        resp = api_client.get(f\"{url}/route/does/not/exist\", headers=auth_header)\n        assert resp.status_code == HTTP_404_NOT_FOUND\n\n        resp_2 = api_client.get(f\"{url}/route/does/not/exist/\", headers=auth_header)\n        assert resp_2.status_code == HTTP_404_NOT_FOUND\n\n        resp_3 = api_client.get(\n            f\"{V1_URL_PREFIX}/route/does/not/exist\", headers=auth_header\n        )\n        assert resp_3.status_code == HTTP_404_NOT_FOUND\n\n        resp_4 = api_client.get(\n            f\"{V1_URL_PREFIX}/route/does/not/exist/\", headers=auth_header\n        )\n        assert resp_4.status_code == HTTP_404_NOT_FOUND\n"], "fixing_code": ["from __future__ import annotations\n\nfrom typing import List\n\nfrom fastapi import HTTPException, status\nfrom starlette.status import (\n    HTTP_400_BAD_REQUEST,\n    HTTP_401_UNAUTHORIZED,\n    HTTP_404_NOT_FOUND,\n)\n\nfrom fides.common.api.scope_registry import SCOPE_REGISTRY as SCOPES\n\n\nclass FidesopsException(Exception):\n    \"\"\"Base class for fidesops exceptions\"\"\"\n\n    def __init__(self, message: str, errors: List[str] = []):\n        super().__init__(message)\n        self.message = message\n        self.errors = errors\n\n\nclass TraversalError(FidesopsException):\n    \"\"\"Fidesops error with the names of all nodes that could not be reached.\"\"\"\n\n\nclass ValidationError(FidesopsException):\n    \"\"\"Data does not pass validation.\"\"\"\n\n\nclass StorageUploadError(FidesopsException):\n    \"\"\"Data cannot be uploaded to storage destination\"\"\"\n\n\nclass SystemManagerException(FidesopsException):\n    \"\"\"Exception class when there are errors making a systemmanager\"\"\"\n\n\nclass ConnectionException(FidesopsException):\n    \"\"\"Exception class when there are errors making a connection\"\"\"\n\n\nclass InsufficientDataException(FidesopsException):\n    \"\"\"Exception class when there is not sufficient data to proceed\"\"\"\n\n\nclass SkippingConsentPropagation(BaseException):\n    \"\"\"Skipping consent propagation for collection. Used to trigger \"skipped\" execution logs being created where applicable\n    for Privacy Preference requests on saas connectors.\n    \"\"\"\n\n\nclass RedisConnectionError(Exception):\n    \"\"\"The Configured Redis instance is uncontactable.\"\"\"\n\n\nclass MisconfiguredPolicyException(Exception):\n    \"\"\"Thrown when a Privacy Request cannot be processed due to a misconfigured Policy.\"\"\"\n\n\nclass PolicyValidationError(ValueError):\n    \"\"\"The policy you are trying to create has invalid data\"\"\"\n\n\nclass InvalidDataLengthValidationError(ValueError):\n    \"\"\"The length provided is invalid\"\"\"\n\n\nclass RuleValidationError(ValueError):\n    \"\"\"The Rule you are trying to create has invalid data\"\"\"\n\n\nclass StorageConfigValidationError(ValueError):\n    \"\"\"The Storage Config you are trying to create has invalid data\"\"\"\n\n\nclass InvalidDataTypeValidationError(ValueError):\n    \"\"\"The specified data type is invalid.\"\"\"\n\n\nclass RuleTargetValidationError(ValueError):\n    \"\"\"The Rule you are trying to create has invalid data\"\"\"\n\n\nclass DataCategoryNotSupported(ValueError):\n    \"\"\"The data category you have supplied is not supported.\"\"\"\n\n\nclass PolicyNotFoundException(Exception):\n    \"\"\"Policy could not be found\"\"\"\n\n\nclass ConnectorNotFoundException(Exception):\n    \"\"\"Connector could not be found\"\"\"\n\n\nclass DrpActionValidationError(Exception):\n    \"\"\"A resource already exists with this DRP Action.\"\"\"\n\n\nclass StorageConfigNotFoundException(BaseException):\n    \"\"\"Custom Exception - StorageConfig Not Found\"\"\"\n\n\nclass PrivacyNoticeHistoryNotFound(BaseException):\n    \"\"\"PrivacyNoticeHistory Not Found\"\"\"\n\n\nclass IdentityNotFoundException(BaseException):\n    \"\"\"Identity Not Found\"\"\"\n\n\nclass WebhookOrderException(BaseException):\n    \"\"\"Custom Exception - Issue with webhooks order\"\"\"\n\n\nclass PostProcessingException(BaseException):\n    \"\"\"Custom Exception - Issue with post processing\"\"\"\n\n\nclass CollectionDisabled(BaseException):\n    \"\"\"Collection is attached to disabled ConnectionConfig\"\"\"\n\n\nclass NotSupportedForCollection(BaseException):\n    \"\"\"The given action is not supported for this type of collection\"\"\"\n\n\nclass PrivacyRequestPaused(BaseException):\n    \"\"\"Halt Instruction Received on Privacy Request\"\"\"\n\n\nclass PrivacyRequestNotFound(BaseException):\n    \"\"\"Privacy Request Not Found\"\"\"\n\n\nclass NoCachedManualWebhookEntry(BaseException):\n    \"\"\"No manual data exists for this webhook on the given privacy request.\"\"\"\n\n\nclass ManualWebhookFieldsUnset(BaseException):\n    \"\"\"Manual webhook has fields that are not explicitly set: Likely new field has been added\"\"\"\n\n\nclass PrivacyRequestErasureEmailSendRequired(BaseException):\n    \"\"\"Erasure requests will need to be fulfilled by email send.  Exception is raised to change ExecutionLog details\"\"\"\n\n\nclass SaaSConfigNotFoundException(FidesopsException):\n    \"\"\"Custom Exception - SaaS Config Not Found\"\"\"\n\n\nclass MessagingConfigNotFoundException(FidesopsException):\n    \"\"\"Custom Exception - Messaging Config Not Found\"\"\"\n\n\nclass MessageDispatchException(FidesopsException):\n    \"\"\"Custom Exception - Message Dispatch Error\"\"\"\n\n\nclass EmailTemplateUnhandledActionType(FidesopsException):\n    \"\"\"Custom Exception - Email Template Unhandled ActionType Error\"\"\"\n\n\nclass OAuth2TokenException(FidesopsException):\n    \"\"\"Custom Exception - Unable to access or refresh OAuth2 tokens for SaaS connector\"\"\"\n\n\nclass AuthenticationFailure(HTTPException):\n    \"\"\"Wrapper for authentication failure exception\"\"\"\n\n    def __init__(self, detail: str) -> None:\n        super().__init__(status_code=HTTP_401_UNAUTHORIZED, detail=detail)\n\n\nclass BadRequest(HTTPException):\n    \"\"\"Wrapper for bad request exception\"\"\"\n\n    def __init__(self, detail: str) -> None:\n        super().__init__(status_code=HTTP_400_BAD_REQUEST, detail=detail)\n\n\nclass NotFoundException(HTTPException):\n    \"\"\"Wrapper for not found exception\"\"\"\n\n    def __init__(self, detail: str) -> None:\n        super().__init__(status_code=HTTP_404_NOT_FOUND, detail=detail)\n\n\nclass ClientUnsuccessfulException(FidesopsException):\n    \"\"\"Exception for when client call fails\"\"\"\n\n    def __init__(self, status_code: int):\n        super().__init__(message=f\"Client call failed with status code '{status_code}'\")\n\n\nclass NoSuchStrategyException(ValueError):\n    \"\"\"Exception for when a masking strategy does not exist\"\"\"\n\n\nclass FunctionalityNotConfigured(Exception):\n    \"\"\"Custom exception for when invoked functionality is unavailable due to configuration.\"\"\"\n\n\nclass InvalidSaaSRequestOverrideException(ValueError):\n    \"\"\"Exception for when a provied SaaS request override function is invalid\"\"\"\n\n\nclass NoSuchSaaSRequestOverrideException(ValueError):\n    \"\"\"Exception for when a requested SaaS request override function does not exist\"\"\"\n\n\nclass IdentityVerificationException(FidesopsException):\n    \"\"\"Custom exceptions for when we cannot verify the identity of a subjct\"\"\"\n\n\nclass NoSuchConnectionTypeSecretSchemaError(Exception):\n    \"\"\"Exception for when a connection type secret schema is not found.\"\"\"\n\n\nclass SSHTunnelConfigNotFoundException(Exception):\n    \"\"\"Exception for when Fides is configured to use an SSH tunnel without config provided.\"\"\"\n\n\nclass MalisciousUrlException(Exception):\n    \"\"\"Fides has detected a potentially maliscious URL.\"\"\"\n\n\nclass AuthenticationError(HTTPException):\n    \"\"\"To be raised when attempting to fetch an access token using\n    invalid credentials.\n    \"\"\"\n\n    def __init__(self, detail: str) -> None:\n        super().__init__(\n            status_code=status.HTTP_401_UNAUTHORIZED,\n            detail=detail,\n        )\n\n\nclass AuthorizationError(HTTPException):\n    \"\"\"Throws an HTTP 403\"\"\"\n\n    def __init__(self, detail: str) -> None:\n        \"\"\"Override the regular HTTPException throwing only a 403\"\"\"\n        super().__init__(status_code=status.HTTP_403_FORBIDDEN, detail=detail)\n\n\nclass ClientWriteFailedError(HTTPException):\n    \"\"\"To be raised when a client cannot be created.\"\"\"\n\n    def __init__(self) -> None:\n        super().__init__(\n            status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,\n            detail=\"Failed to create client\",\n        )\n\n\nclass ClientNotFoundError(HTTPException):\n    \"\"\"To be raised when attempting to fetch a client that does not exist.\"\"\"\n\n    def __init__(self, client_id: str) -> None:\n        super().__init__(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail={\n                \"error\": \"Client does not exist\",\n                \"id\": client_id,\n            },\n        )\n\n\nclass ExpiredTokenError(HTTPException):\n    \"\"\"To be raised when a provided token is expired.\"\"\"\n\n    def __init__(self) -> None:\n        super().__init__(\n            status_code=status.HTTP_403_FORBIDDEN,\n            detail=\"OAuth token expired\",\n        )\n\n\nclass InvalidAuthorizationSchemeError(HTTPException):\n    \"\"\"To be raised when attempting to authenticate with an unexpected\n    Authorization header value.\n    \"\"\"\n\n    def __init__(self) -> None:\n        super().__init__(\n            status_code=status.HTTP_401_UNAUTHORIZED,\n            detail=\"Failed to authenticate\",\n            headers={\"WWW-Authenticate\": \"Bearer\"},\n        )\n\n\nclass InvalidScopeError(HTTPException):\n    \"\"\"To be raised when a provided scope does not exist.\"\"\"\n\n    def __init__(self, invalid_scopes: list[str]) -> None:\n        SCOPES.sort()\n\n        super().__init__(\n            status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,\n            detail={\n                \"error\": \"Invalid scope provided\",\n                \"invalid_scopes\": invalid_scopes,\n                \"valid_scopes\": SCOPES,\n            },\n        )\n\n\nclass KeyOrNameAlreadyExists(Exception):\n    \"\"\"A resource already exists with this key or name.\"\"\"\n\n\nclass KeyValidationError(Exception):\n    \"\"\"The resource you're trying to create has a key specified but not\n    a name specified.\n    \"\"\"\n\n\nclass MissingConfig(Exception):\n    \"\"\"Custom exception for when no valid configuration file is provided.\"\"\"\n", "\"\"\"\nContains the code that sets up the API.\n\"\"\"\nimport os\nimport sys\nfrom datetime import datetime, timezone\nfrom logging import WARNING\nfrom typing import Callable, Optional\n\nfrom fastapi import HTTPException, Request, Response, status\nfrom fastapi.responses import FileResponse\nfrom fideslog.sdk.python.event import AnalyticsEvent\nfrom loguru import logger\nfrom starlette.background import BackgroundTask\nfrom urllib.parse import unquote\nfrom uvicorn import Config, Server\n\nimport fides\nfrom fides.api.app_setup import (\n    check_redis,\n    create_fides_app,\n    log_startup,\n    run_database_startup,\n)\nfrom fides.api.common_exceptions import MalisciousUrlException\nfrom fides.api.middleware import handle_audit_log_resource\nfrom fides.api.schemas.analytics import Event, ExtraData\n\n# pylint: disable=wildcard-import, unused-wildcard-import\nfrom fides.api.service.privacy_request.email_batch_service import (\n    initiate_scheduled_batch_email_send,\n)\nfrom fides.api.tasks.scheduled.scheduler import scheduler\nfrom fides.api.ui import (\n    get_admin_index_as_response,\n    get_path_to_admin_ui_file,\n    get_ui_file_map,\n    match_route,\n    path_is_in_ui_directory,\n)\nfrom fides.api.util.endpoint_utils import API_PREFIX\nfrom fides.api.util.logger import _log_exception\nfrom fides.cli.utils import FIDES_ASCII_ART\nfrom fides.config import CONFIG, check_required_webserver_config_values\n\nIGNORED_AUDIT_LOG_RESOURCE_PATHS = {\"/api/v1/login\"}\n\nVERSION = fides.__version__\n\napp = create_fides_app()\n\n\n@app.middleware(\"http\")\nasync def dispatch_log_request(request: Request, call_next: Callable) -> Response:\n    \"\"\"\n    HTTP Middleware that logs analytics events for each call to Fides endpoints.\n    :param request: Request to Fides api\n    :param call_next: Callable api endpoint\n    :return: Response\n    \"\"\"\n\n    # Only log analytics events for requests that are for API endpoints (i.e. /api/...)\n    path = request.url.path\n    if (not path.startswith(API_PREFIX)) or (path.endswith(\"/health\")):\n        return await call_next(request)\n\n    fides_source: Optional[str] = request.headers.get(\"X-Fides-Source\")\n    now: datetime = datetime.now(tz=timezone.utc)\n    endpoint = f\"{request.method}: {request.url}\"\n\n    try:\n        response = await call_next(request)\n        # HTTPExceptions are considered a handled err by default so are not thrown here.\n        # Accepted workaround is to inspect status code of response.\n        # More context- https://github.com/tiangolo/fastapi/issues/1840\n        response.background = BackgroundTask(\n            prepare_and_log_request,\n            endpoint,\n            request.url.hostname,\n            response.status_code,\n            now,\n            fides_source,\n            \"HTTPException\" if response.status_code >= 400 else None,\n        )\n        return response\n\n    except Exception as e:\n        await prepare_and_log_request(\n            endpoint, request.url.hostname, 500, now, fides_source, e.__class__.__name__\n        )\n        _log_exception(e, CONFIG.dev_mode)\n        raise\n\n\nasync def prepare_and_log_request(\n    endpoint: str,\n    hostname: Optional[str],\n    status_code: int,\n    event_created_at: datetime,\n    fides_source: Optional[str],\n    error_class: Optional[str],\n) -> None:\n    \"\"\"\n    Prepares and sends analytics event provided the user is not opted out of analytics.\n    \"\"\"\n    # Avoid circular imports\n    from fides.api.analytics import (\n        accessed_through_local_host,\n        in_docker_container,\n        send_analytics_event,\n    )\n\n    # this check prevents AnalyticsEvent from being called with invalid endpoint during unit tests\n    if CONFIG.user.analytics_opt_out:\n        return\n    await send_analytics_event(\n        AnalyticsEvent(\n            docker=in_docker_container(),\n            event=Event.endpoint_call.value,\n            event_created_at=event_created_at,\n            local_host=accessed_through_local_host(hostname),\n            endpoint=endpoint,\n            status_code=status_code,\n            error=error_class or None,\n            extra_data={ExtraData.fides_source.value: fides_source}\n            if fides_source\n            else None,\n        )\n    )\n\n\n@app.middleware(\"http\")\nasync def log_request(request: Request, call_next: Callable) -> Response:\n    \"\"\"Log basic information about every request handled by the server.\"\"\"\n    start = datetime.now()\n    response = await call_next(request)\n    handler_time = datetime.now() - start\n    logger.bind(\n        method=request.method,\n        status_code=response.status_code,\n        handler_time=f\"{round(handler_time.microseconds * 0.001,3)}ms\",\n        path=request.url.path,\n    ).info(\"Request received\")\n    return response\n\n\n# Configure the static file paths last since otherwise it will take over all paths\n@app.get(\"/\", tags=[\"Default\"])\ndef read_index() -> Response:\n    \"\"\"\n    Return an index.html at the root path\n    \"\"\"\n\n    return get_admin_index_as_response()\n\n\ndef sanitise_url_path(path: str) -> str:\n    \"\"\"Returns a URL path that does not contain any ../ or //\"\"\"\n    path = unquote(path)\n    path = os.path.normpath(path)\n    for token in path.split(\"/\"):\n        if \"..\" in token:\n            logger.warning(f\"Potentially dangerous use of URL hierarchy in path: {path}\")\n            raise MalisciousUrlException()\n    return path\n\n\n@app.get(\"/{catchall:path}\", response_class=Response, tags=[\"Default\"])\ndef read_other_paths(request: Request) -> Response:\n    \"\"\"\n    Return related frontend files. Adapted from https://github.com/tiangolo/fastapi/issues/130\n    \"\"\"\n    # check first if requested file exists (for frontend assets)\n    path = request.path_params[\"catchall\"]\n    logger.debug(f\"Catch all path detected: {path}\")\n    try:\n        path = sanitise_url_path(path)\n    except MalisciousUrlException:\n        # if a maliscious URL is detected, route the user to the index\n        return get_admin_index_as_response()\n\n    # search for matching route in package (i.e. /dataset)\n    ui_file = match_route(get_ui_file_map(), path)\n\n    # if not, check if the requested file is an asset (i.e. /_next/static/...)\n    if not ui_file:\n        ui_file = get_path_to_admin_ui_file(path)\n\n    # Serve up the file as long as it is within the UI directory\n    if ui_file and ui_file.is_file():\n        if not path_is_in_ui_directory(ui_file):\n            raise HTTPException(\n                status_code=status.HTTP_404_NOT_FOUND, detail=\"Item not found\"\n            )\n        logger.debug(\n            \"catchall request path '{}' matched static admin UI file: {}\",\n            path,\n            ui_file,\n        )\n        return FileResponse(ui_file)\n\n    # raise 404 for anything that should be backend endpoint but we can't find it\n    if path.startswith(API_PREFIX[1:]):\n        logger.debug(\n            \"catchall request path '{}' matched an invalid API route, return 404\",\n            path,\n        )\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND, detail=\"Item not found\"\n        )\n\n    # otherwise return the index\n    logger.debug(\n        \"catchall request path '{}' did not match any admin UI routes, return generic admin UI index\",\n        path,\n    )\n    return get_admin_index_as_response()\n\n\n@app.on_event(\"startup\")\nasync def setup_server() -> None:\n    \"\"\"Run all of the required setup steps for the webserver.\n\n    **NOTE**: The order of operations here _is_ deliberate\n    and must be maintained.\n    \"\"\"\n    if not CONFIG.dev_mode:\n        sys.tracebacklimit = 0\n\n    log_startup()\n\n    await run_database_startup()\n\n    check_redis()\n\n    if not scheduler.running:\n        scheduler.start()\n\n    initiate_scheduled_batch_email_send()\n\n    logger.debug(\"Sending startup analytics events...\")\n    # Avoid circular imports\n    from fides.api.analytics import in_docker_container, send_analytics_event\n\n    await send_analytics_event(\n        AnalyticsEvent(\n            docker=in_docker_container(),\n            event=Event.server_start.value,\n            event_created_at=datetime.now(tz=timezone.utc),\n        )\n    )\n\n    logger.info(FIDES_ASCII_ART)\n    logger.info(f\"Fides startup complete! v{VERSION}\")\n\n\ndef start_webserver(port: int = 8080) -> None:\n    \"\"\"Run the webserver.\"\"\"\n    check_required_webserver_config_values(config=CONFIG)\n    server = Server(Config(app, host=\"0.0.0.0\", port=port, log_level=WARNING))\n\n    logger.info(\n        \"Starting webserver - Host: {}, Port: {}, Log Level: {}\",\n        server.config.host,\n        server.config.port,\n        server.config.log_level,\n    )\n    server.run()\n\n\n@app.middleware(\"http\")\nasync def action_to_audit_log(\n    request: Request,\n    call_next: Callable,\n) -> Response:\n    \"\"\"Log basic information about every non-GET request handled by the server.\"\"\"\n\n    if (\n        request.method != \"GET\"\n        and request.scope[\"path\"] not in IGNORED_AUDIT_LOG_RESOURCE_PATHS\n        and CONFIG.security.enable_audit_log_resource_middleware\n    ):\n        try:\n            await handle_audit_log_resource(request)\n        except Exception as exc:\n            logger.debug(exc)\n    return await call_next(request)\n", "import pytest\nfrom starlette.status import HTTP_200_OK, HTTP_404_NOT_FOUND\nfrom starlette.testclient import TestClient\n\nfrom fides.api.models.client import ClientDetail\nfrom fides.common.api.scope_registry import PRIVACY_REQUEST_READ\nfrom fides.common.api.v1.urn_registry import PRIVACY_REQUESTS, V1_URL_PREFIX\n\n\nclass TestApiRouter:\n    @pytest.fixture(scope=\"function\")\n    def url(self, oauth_client: ClientDetail) -> str:\n        return V1_URL_PREFIX + PRIVACY_REQUESTS\n\n    def test_no_trailing_slash(\n        self, api_client: TestClient, generate_auth_header, url\n    ) -> None:\n        auth_header = generate_auth_header(scopes=[PRIVACY_REQUEST_READ])\n        resp = api_client.get(url, headers=auth_header)\n        assert resp.status_code == HTTP_200_OK\n\n    def test_trailing_slash(\n        self, api_client: TestClient, generate_auth_header, url\n    ) -> None:\n        auth_header = generate_auth_header(scopes=[PRIVACY_REQUEST_READ])\n        resp = api_client.get(f\"{url}/\", headers=auth_header)\n        assert resp.status_code == HTTP_200_OK\n\n    def test_non_existent_route_404(\n        self, api_client: TestClient, generate_auth_header, url\n    ) -> None:\n        auth_header = generate_auth_header(scopes=[PRIVACY_REQUEST_READ])\n        resp = api_client.get(f\"{url}/route/does/not/exist\", headers=auth_header)\n        assert resp.status_code == HTTP_404_NOT_FOUND\n\n        resp_2 = api_client.get(f\"{url}/route/does/not/exist/\", headers=auth_header)\n        assert resp_2.status_code == HTTP_404_NOT_FOUND\n\n        resp_3 = api_client.get(\n            f\"{V1_URL_PREFIX}/route/does/not/exist\", headers=auth_header\n        )\n        assert resp_3.status_code == HTTP_404_NOT_FOUND\n\n        resp_4 = api_client.get(\n            f\"{V1_URL_PREFIX}/route/does/not/exist/\", headers=auth_header\n        )\n        assert resp_4.status_code == HTTP_404_NOT_FOUND\n\n    def test_malicious_url(\n        self,\n        api_client: TestClient,\n        url,\n    ) -> None:\n        malicious_paths = [\n            \"../../../../../../../../../etc/passwd\",\n            \"..%2f..%2f..%2f..%2f..%2f..%2f..%2f..%2f..%2fetc/passwd\",\n            \"%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/etc/passwd\",\n            \"%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2fetc/passwd\",\n            \"..%c0%2f..%c0%2f..%c0%2f..%c0%2f..%c0%2f..%c0%2f..%c0%2f..%c0%2f..%c0%2f/etc/passwd\",\n            \".../...//.../...//.../...//.../...//.../...//.../...//.../...//.../...//.../...//etc/passwd\",\n            \"...%2f...%2f%2f...%2f...%2f%2f...%2f...%2f%2f...%2f...%2f%2f...%2f...%2f%2f...%2f...%2f%2f...%2f...%2f%2f...%2f...%2f%2f...%2f...%2f%2fetc/passwd\",\n            \"%2e%2e%2e/%2e%2e%2e//%2e%2e%2e/%2e%2e%2e//%2e%2e%2e/%2e%2e%2e//%2e%2e%2e/%2e%2e%2e//%2e%2e%2e/%2e%2e%2e//%2e%2e%2e/%2e%2e%2e//%2e%2e%2e/%2e%2e%2e//%2e%2e%2e/%2e%2e%2e//%2e%2e%2e/%2e%2e%2e//etc/passwd\",\n            \"%2e%2e%2e%2f%2e%2e%2e%2f%2f%2e%2e%2e%2f%2e%2e%2e%2f%2f%2e%2e%2e%2f%2e%2e%2e%2f%2f%2e%2e%2e%2f%2e%2e%2e%2f%2f%2e%2e%2e%2f%2e%2e%2e%2f%2f%2e%2e%2e%2f%2e%2e%2e%2f%2f%2e%2e%2e%2f%2e%2e%2e%2f%2f%2e%2e%2e%2f%2e%2e%2e%2f%2f%2e%2e%2e%2f%2e%2e%2e%2f%2fetc/passwd\",\n        ]\n        for path in malicious_paths:\n            resp = api_client.get(f\"{url}/{path}\")\n            assert resp.status_code == 200\n            assert resp.text == \"<h1>Privacy is a Human Right!</h1>\"\n"], "filenames": ["src/fides/api/common_exceptions.py", "src/fides/api/main.py", "tests/ops/util/test_api_router.py"], "buggy_code_start_loc": [225, 3, 47], "buggy_code_end_loc": [225, 160, 47], "fixing_code_start_loc": [226, 4, 48], "fixing_code_end_loc": [230, 181, 69], "type": "CWE-22", "message": "Fides is an open-source privacy engineering platform for managing the fulfillment of data privacy requests in a runtime environment, and the enforcement of privacy regulations in code. A path traversal (directory traversal) vulnerability affects fides versions lower than version `2.15.1`, allowing remote attackers to access arbitrary files on the fides webserver container's filesystem. The vulnerability is patched in fides `2.15.1`.\n\nIf the Fides webserver API is not directly accessible to attackers and is instead deployed behind a reverse proxy as recommended in Ethyca's security best practice documentation, and the reverse proxy is an AWS application load balancer, the vulnerability can't be exploited by these attackers. An AWS application load balancer will reject this attack with a 400 error. Additionally, any secrets supplied to the container using environment variables rather than a `fides.toml` configuration file are not affected by this vulnerability.\n", "other": {"cve": {"id": "CVE-2023-36827", "sourceIdentifier": "security-advisories@github.com", "published": "2023-07-05T22:15:10.033", "lastModified": "2023-07-12T15:56:36.760", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Fides is an open-source privacy engineering platform for managing the fulfillment of data privacy requests in a runtime environment, and the enforcement of privacy regulations in code. A path traversal (directory traversal) vulnerability affects fides versions lower than version `2.15.1`, allowing remote attackers to access arbitrary files on the fides webserver container's filesystem. The vulnerability is patched in fides `2.15.1`.\n\nIf the Fides webserver API is not directly accessible to attackers and is instead deployed behind a reverse proxy as recommended in Ethyca's security best practice documentation, and the reverse proxy is an AWS application load balancer, the vulnerability can't be exploited by these attackers. An AWS application load balancer will reject this attack with a 400 error. Additionally, any secrets supplied to the container using environment variables rather than a `fides.toml` configuration file are not affected by this vulnerability.\n"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-22"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:ethyca:fides:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.15.1", "matchCriteriaId": "CF59FB40-ECE6-4B0C-85F3-030839164E9F"}]}]}], "references": [{"url": "https://github.com/ethyca/fides/commit/f526d9ffb176006d701493c9d0eff6b4884e811f", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/ethyca/fides/releases/tag/2.15.1", "source": "security-advisories@github.com", "tags": ["Release Notes"]}, {"url": "https://github.com/ethyca/fides/security/advisories/GHSA-r25m-cr6v-p9hq", "source": "security-advisories@github.com", "tags": ["Mitigation", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/ethyca/fides/commit/f526d9ffb176006d701493c9d0eff6b4884e811f"}}