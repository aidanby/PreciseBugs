{"buggy_code": ["/***\n  This file is part of systemd.\n\n  Copyright 2014 Lennart Poettering\n\n  systemd is free software; you can redistribute it and/or modify it\n  under the terms of the GNU Lesser General Public License as published by\n  the Free Software Foundation; either version 2.1 of the License, or\n  (at your option) any later version.\n\n  systemd is distributed in the hope that it will be useful, but\n  WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n  Lesser General Public License for more details.\n\n  You should have received a copy of the GNU Lesser General Public License\n  along with systemd; If not, see <http://www.gnu.org/licenses/>.\n ***/\n\n#include \"alloc-util.h\"\n#include \"dns-domain.h\"\n#include \"resolved-dns-packet.h\"\n#include \"string-table.h\"\n#include \"strv.h\"\n#include \"unaligned.h\"\n#include \"utf8.h\"\n#include \"util.h\"\n\n#define EDNS0_OPT_DO (1<<15)\n\ntypedef struct DnsPacketRewinder {\n        DnsPacket *packet;\n        size_t saved_rindex;\n} DnsPacketRewinder;\n\nstatic void rewind_dns_packet(DnsPacketRewinder *rewinder) {\n        if (rewinder->packet)\n                dns_packet_rewind(rewinder->packet, rewinder->saved_rindex);\n}\n\n#define INIT_REWINDER(rewinder, p) do { rewinder.packet = p; rewinder.saved_rindex = p->rindex; } while (0)\n#define CANCEL_REWINDER(rewinder) do { rewinder.packet = NULL; } while (0)\n\nint dns_packet_new(DnsPacket **ret, DnsProtocol protocol, size_t mtu) {\n        DnsPacket *p;\n        size_t a;\n\n        assert(ret);\n\n        if (mtu <= UDP_PACKET_HEADER_SIZE)\n                a = DNS_PACKET_SIZE_START;\n        else\n                a = mtu - UDP_PACKET_HEADER_SIZE;\n\n        if (a < DNS_PACKET_HEADER_SIZE)\n                a = DNS_PACKET_HEADER_SIZE;\n\n        /* round up to next page size */\n        a = PAGE_ALIGN(ALIGN(sizeof(DnsPacket)) + a) - ALIGN(sizeof(DnsPacket));\n\n        /* make sure we never allocate more than useful */\n        if (a > DNS_PACKET_SIZE_MAX)\n                a = DNS_PACKET_SIZE_MAX;\n\n        p = malloc0(ALIGN(sizeof(DnsPacket)) + a);\n        if (!p)\n                return -ENOMEM;\n\n        p->size = p->rindex = DNS_PACKET_HEADER_SIZE;\n        p->allocated = a;\n        p->protocol = protocol;\n        p->opt_start = p->opt_size = (size_t) -1;\n        p->n_ref = 1;\n\n        *ret = p;\n\n        return 0;\n}\n\nvoid dns_packet_set_flags(DnsPacket *p, bool dnssec_checking_disabled, bool truncated) {\n\n        DnsPacketHeader *h;\n\n        assert(p);\n\n        h = DNS_PACKET_HEADER(p);\n\n        switch(p->protocol) {\n        case DNS_PROTOCOL_LLMNR:\n                assert(!truncated);\n\n                h->flags = htobe16(DNS_PACKET_MAKE_FLAGS(0 /* qr */,\n                                                         0 /* opcode */,\n                                                         0 /* c */,\n                                                         0 /* tc */,\n                                                         0 /* t */,\n                                                         0 /* ra */,\n                                                         0 /* ad */,\n                                                         0 /* cd */,\n                                                         0 /* rcode */));\n                break;\n\n        case DNS_PROTOCOL_MDNS:\n                h->flags = htobe16(DNS_PACKET_MAKE_FLAGS(0         /* qr */,\n                                                         0         /* opcode */,\n                                                         0         /* aa */,\n                                                         truncated /* tc */,\n                                                         0         /* rd (ask for recursion) */,\n                                                         0         /* ra */,\n                                                         0         /* ad */,\n                                                         0         /* cd */,\n                                                         0         /* rcode */));\n                break;\n\n        default:\n                assert(!truncated);\n\n                h->flags = htobe16(DNS_PACKET_MAKE_FLAGS(0 /* qr */,\n                                                         0 /* opcode */,\n                                                         0 /* aa */,\n                                                         0 /* tc */,\n                                                         1 /* rd (ask for recursion) */,\n                                                         0 /* ra */,\n                                                         0 /* ad */,\n                                                         dnssec_checking_disabled /* cd */,\n                                                         0 /* rcode */));\n        }\n}\n\nint dns_packet_new_query(DnsPacket **ret, DnsProtocol protocol, size_t mtu, bool dnssec_checking_disabled) {\n        DnsPacket *p;\n        int r;\n\n        assert(ret);\n\n        r = dns_packet_new(&p, protocol, mtu);\n        if (r < 0)\n                return r;\n\n        /* Always set the TC bit to 0 initially.\n         * If there are multiple packets later, we'll update the bit shortly before sending.\n         */\n        dns_packet_set_flags(p, dnssec_checking_disabled, false);\n\n        *ret = p;\n        return 0;\n}\n\nDnsPacket *dns_packet_ref(DnsPacket *p) {\n\n        if (!p)\n                return NULL;\n\n        assert(!p->on_stack);\n\n        assert(p->n_ref > 0);\n        p->n_ref++;\n        return p;\n}\n\nstatic void dns_packet_free(DnsPacket *p) {\n        char *s;\n\n        assert(p);\n\n        dns_question_unref(p->question);\n        dns_answer_unref(p->answer);\n        dns_resource_record_unref(p->opt);\n\n        while ((s = hashmap_steal_first_key(p->names)))\n                free(s);\n        hashmap_free(p->names);\n\n        free(p->_data);\n\n        if (!p->on_stack)\n                free(p);\n}\n\nDnsPacket *dns_packet_unref(DnsPacket *p) {\n        if (!p)\n                return NULL;\n\n        assert(p->n_ref > 0);\n\n        dns_packet_unref(p->more);\n\n        if (p->n_ref == 1)\n                dns_packet_free(p);\n        else\n                p->n_ref--;\n\n        return NULL;\n}\n\nint dns_packet_validate(DnsPacket *p) {\n        assert(p);\n\n        if (p->size < DNS_PACKET_HEADER_SIZE)\n                return -EBADMSG;\n\n        if (p->size > DNS_PACKET_SIZE_MAX)\n                return -EBADMSG;\n\n        return 1;\n}\n\nint dns_packet_validate_reply(DnsPacket *p) {\n        int r;\n\n        assert(p);\n\n        r = dns_packet_validate(p);\n        if (r < 0)\n                return r;\n\n        if (DNS_PACKET_QR(p) != 1)\n                return 0;\n\n        if (DNS_PACKET_OPCODE(p) != 0)\n                return -EBADMSG;\n\n        switch (p->protocol) {\n\n        case DNS_PROTOCOL_LLMNR:\n                /* RFC 4795, Section 2.1.1. says to discard all replies with QDCOUNT != 1 */\n                if (DNS_PACKET_QDCOUNT(p) != 1)\n                        return -EBADMSG;\n\n                break;\n\n        case DNS_PROTOCOL_MDNS:\n                /* RFC 6762, Section 18 */\n                if (DNS_PACKET_RCODE(p) != 0)\n                        return -EBADMSG;\n\n                break;\n\n        default:\n                break;\n        }\n\n        return 1;\n}\n\nint dns_packet_validate_query(DnsPacket *p) {\n        int r;\n\n        assert(p);\n\n        r = dns_packet_validate(p);\n        if (r < 0)\n                return r;\n\n        if (DNS_PACKET_QR(p) != 0)\n                return 0;\n\n        if (DNS_PACKET_OPCODE(p) != 0)\n                return -EBADMSG;\n\n        if (DNS_PACKET_TC(p))\n                return -EBADMSG;\n\n        switch (p->protocol) {\n\n        case DNS_PROTOCOL_LLMNR:\n        case DNS_PROTOCOL_DNS:\n                /* RFC 4795, Section 2.1.1. says to discard all queries with QDCOUNT != 1 */\n                if (DNS_PACKET_QDCOUNT(p) != 1)\n                        return -EBADMSG;\n\n                /* RFC 4795, Section 2.1.1. says to discard all queries with ANCOUNT != 0 */\n                if (DNS_PACKET_ANCOUNT(p) > 0)\n                        return -EBADMSG;\n\n                /* RFC 4795, Section 2.1.1. says to discard all queries with NSCOUNT != 0 */\n                if (DNS_PACKET_NSCOUNT(p) > 0)\n                        return -EBADMSG;\n\n                break;\n\n        case DNS_PROTOCOL_MDNS:\n                /* RFC 6762, Section 18 */\n                if (DNS_PACKET_AA(p)    != 0 ||\n                    DNS_PACKET_RD(p)    != 0 ||\n                    DNS_PACKET_RA(p)    != 0 ||\n                    DNS_PACKET_AD(p)    != 0 ||\n                    DNS_PACKET_CD(p)    != 0 ||\n                    DNS_PACKET_RCODE(p) != 0)\n                        return -EBADMSG;\n\n                break;\n\n        default:\n                break;\n        }\n\n        return 1;\n}\n\nstatic int dns_packet_extend(DnsPacket *p, size_t add, void **ret, size_t *start) {\n        assert(p);\n\n        if (p->size + add > p->allocated) {\n                size_t a;\n\n                a = PAGE_ALIGN((p->size + add) * 2);\n                if (a > DNS_PACKET_SIZE_MAX)\n                        a = DNS_PACKET_SIZE_MAX;\n\n                if (p->size + add > a)\n                        return -EMSGSIZE;\n\n                if (p->_data) {\n                        void *d;\n\n                        d = realloc(p->_data, a);\n                        if (!d)\n                                return -ENOMEM;\n\n                        p->_data = d;\n                } else {\n                        p->_data = malloc(a);\n                        if (!p->_data)\n                                return -ENOMEM;\n\n                        memcpy(p->_data, (uint8_t*) p + ALIGN(sizeof(DnsPacket)), p->size);\n                        memzero((uint8_t*) p->_data + p->size, a - p->size);\n                }\n\n                p->allocated = a;\n        }\n\n        if (start)\n                *start = p->size;\n\n        if (ret)\n                *ret = (uint8_t*) DNS_PACKET_DATA(p) + p->size;\n\n        p->size += add;\n        return 0;\n}\n\nvoid dns_packet_truncate(DnsPacket *p, size_t sz) {\n        Iterator i;\n        char *s;\n        void *n;\n\n        assert(p);\n\n        if (p->size <= sz)\n                return;\n\n        HASHMAP_FOREACH_KEY(n, s, p->names, i) {\n\n                if (PTR_TO_SIZE(n) < sz)\n                        continue;\n\n                hashmap_remove(p->names, s);\n                free(s);\n        }\n\n        p->size = sz;\n}\n\nint dns_packet_append_blob(DnsPacket *p, const void *d, size_t l, size_t *start) {\n        void *q;\n        int r;\n\n        assert(p);\n\n        r = dns_packet_extend(p, l, &q, start);\n        if (r < 0)\n                return r;\n\n        memcpy(q, d, l);\n        return 0;\n}\n\nint dns_packet_append_uint8(DnsPacket *p, uint8_t v, size_t *start) {\n        void *d;\n        int r;\n\n        assert(p);\n\n        r = dns_packet_extend(p, sizeof(uint8_t), &d, start);\n        if (r < 0)\n                return r;\n\n        ((uint8_t*) d)[0] = v;\n\n        return 0;\n}\n\nint dns_packet_append_uint16(DnsPacket *p, uint16_t v, size_t *start) {\n        void *d;\n        int r;\n\n        assert(p);\n\n        r = dns_packet_extend(p, sizeof(uint16_t), &d, start);\n        if (r < 0)\n                return r;\n\n        unaligned_write_be16(d, v);\n\n        return 0;\n}\n\nint dns_packet_append_uint32(DnsPacket *p, uint32_t v, size_t *start) {\n        void *d;\n        int r;\n\n        assert(p);\n\n        r = dns_packet_extend(p, sizeof(uint32_t), &d, start);\n        if (r < 0)\n                return r;\n\n        unaligned_write_be32(d, v);\n\n        return 0;\n}\n\nint dns_packet_append_string(DnsPacket *p, const char *s, size_t *start) {\n        assert(p);\n        assert(s);\n\n        return dns_packet_append_raw_string(p, s, strlen(s), start);\n}\n\nint dns_packet_append_raw_string(DnsPacket *p, const void *s, size_t size, size_t *start) {\n        void *d;\n        int r;\n\n        assert(p);\n        assert(s || size == 0);\n\n        if (size > 255)\n                return -E2BIG;\n\n        r = dns_packet_extend(p, 1 + size, &d, start);\n        if (r < 0)\n                return r;\n\n        ((uint8_t*) d)[0] = (uint8_t) size;\n\n        memcpy_safe(((uint8_t*) d) + 1, s, size);\n\n        return 0;\n}\n\nint dns_packet_append_label(DnsPacket *p, const char *d, size_t l, bool canonical_candidate, size_t *start) {\n        uint8_t *w;\n        int r;\n\n        /* Append a label to a packet. Optionally, does this in DNSSEC\n         * canonical form, if this label is marked as a candidate for\n         * it, and the canonical form logic is enabled for the\n         * packet */\n\n        assert(p);\n        assert(d);\n\n        if (l > DNS_LABEL_MAX)\n                return -E2BIG;\n\n        r = dns_packet_extend(p, 1 + l, (void**) &w, start);\n        if (r < 0)\n                return r;\n\n        *(w++) = (uint8_t) l;\n\n        if (p->canonical_form && canonical_candidate) {\n                size_t i;\n\n                /* Generate in canonical form, as defined by DNSSEC\n                 * RFC 4034, Section 6.2, i.e. all lower-case. */\n\n                for (i = 0; i < l; i++)\n                        w[i] = (uint8_t) ascii_tolower(d[i]);\n        } else\n                /* Otherwise, just copy the string unaltered. This is\n                 * essential for DNS-SD, where the casing of labels\n                 * matters and needs to be retained. */\n                memcpy(w, d, l);\n\n        return 0;\n}\n\nint dns_packet_append_name(\n                DnsPacket *p,\n                const char *name,\n                bool allow_compression,\n                bool canonical_candidate,\n                size_t *start) {\n\n        size_t saved_size;\n        int r;\n\n        assert(p);\n        assert(name);\n\n        if (p->refuse_compression)\n                allow_compression = false;\n\n        saved_size = p->size;\n\n        while (!dns_name_is_root(name)) {\n                const char *z = name;\n                char label[DNS_LABEL_MAX];\n                size_t n = 0;\n\n                if (allow_compression)\n                        n = PTR_TO_SIZE(hashmap_get(p->names, name));\n                if (n > 0) {\n                        assert(n < p->size);\n\n                        if (n < 0x4000) {\n                                r = dns_packet_append_uint16(p, 0xC000 | n, NULL);\n                                if (r < 0)\n                                        goto fail;\n\n                                goto done;\n                        }\n                }\n\n                r = dns_label_unescape(&name, label, sizeof(label));\n                if (r < 0)\n                        goto fail;\n\n                r = dns_packet_append_label(p, label, r, canonical_candidate, &n);\n                if (r < 0)\n                        goto fail;\n\n                if (allow_compression) {\n                        _cleanup_free_ char *s = NULL;\n\n                        s = strdup(z);\n                        if (!s) {\n                                r = -ENOMEM;\n                                goto fail;\n                        }\n\n                        r = hashmap_ensure_allocated(&p->names, &dns_name_hash_ops);\n                        if (r < 0)\n                                goto fail;\n\n                        r = hashmap_put(p->names, s, SIZE_TO_PTR(n));\n                        if (r < 0)\n                                goto fail;\n\n                        s = NULL;\n                }\n        }\n\n        r = dns_packet_append_uint8(p, 0, NULL);\n        if (r < 0)\n                return r;\n\ndone:\n        if (start)\n                *start = saved_size;\n\n        return 0;\n\nfail:\n        dns_packet_truncate(p, saved_size);\n        return r;\n}\n\nint dns_packet_append_key(DnsPacket *p, const DnsResourceKey *k, const DnsAnswerFlags flags, size_t *start) {\n        size_t saved_size;\n        uint16_t class;\n        int r;\n\n        assert(p);\n        assert(k);\n\n        saved_size = p->size;\n\n        r = dns_packet_append_name(p, dns_resource_key_name(k), true, true, NULL);\n        if (r < 0)\n                goto fail;\n\n        r = dns_packet_append_uint16(p, k->type, NULL);\n        if (r < 0)\n                goto fail;\n\n        class = flags & DNS_ANSWER_CACHE_FLUSH ? k->class | MDNS_RR_CACHE_FLUSH : k->class;\n        r = dns_packet_append_uint16(p, class, NULL);\n        if (r < 0)\n                goto fail;\n\n        if (start)\n                *start = saved_size;\n\n        return 0;\n\nfail:\n        dns_packet_truncate(p, saved_size);\n        return r;\n}\n\nstatic int dns_packet_append_type_window(DnsPacket *p, uint8_t window, uint8_t length, const uint8_t *types, size_t *start) {\n        size_t saved_size;\n        int r;\n\n        assert(p);\n        assert(types);\n        assert(length > 0);\n\n        saved_size = p->size;\n\n        r = dns_packet_append_uint8(p, window, NULL);\n        if (r < 0)\n                goto fail;\n\n        r = dns_packet_append_uint8(p, length, NULL);\n        if (r < 0)\n                goto fail;\n\n        r = dns_packet_append_blob(p, types, length, NULL);\n        if (r < 0)\n                goto fail;\n\n        if (start)\n                *start = saved_size;\n\n        return 0;\nfail:\n        dns_packet_truncate(p, saved_size);\n        return r;\n}\n\nstatic int dns_packet_append_types(DnsPacket *p, Bitmap *types, size_t *start) {\n        Iterator i;\n        uint8_t window = 0;\n        uint8_t entry = 0;\n        uint8_t bitmaps[32] = {};\n        unsigned n;\n        size_t saved_size;\n        int r;\n\n        assert(p);\n\n        saved_size = p->size;\n\n        BITMAP_FOREACH(n, types, i) {\n                assert(n <= 0xffff);\n\n                if ((n >> 8) != window && bitmaps[entry / 8] != 0) {\n                        r = dns_packet_append_type_window(p, window, entry / 8 + 1, bitmaps, NULL);\n                        if (r < 0)\n                                goto fail;\n\n                        zero(bitmaps);\n                }\n\n                window = n >> 8;\n                entry = n & 255;\n\n                bitmaps[entry / 8] |= 1 << (7 - (entry % 8));\n        }\n\n        if (bitmaps[entry / 8] != 0) {\n                r = dns_packet_append_type_window(p, window, entry / 8 + 1, bitmaps, NULL);\n                if (r < 0)\n                        goto fail;\n        }\n\n        if (start)\n                *start = saved_size;\n\n        return 0;\nfail:\n        dns_packet_truncate(p, saved_size);\n        return r;\n}\n\n/* Append the OPT pseudo-RR described in RFC6891 */\nint dns_packet_append_opt(DnsPacket *p, uint16_t max_udp_size, bool edns0_do, int rcode, size_t *start) {\n        size_t saved_size;\n        int r;\n\n        assert(p);\n        /* we must never advertise supported packet size smaller than the legacy max */\n        assert(max_udp_size >= DNS_PACKET_UNICAST_SIZE_MAX);\n        assert(rcode >= 0);\n        assert(rcode <= _DNS_RCODE_MAX);\n\n        if (p->opt_start != (size_t) -1)\n                return -EBUSY;\n\n        assert(p->opt_size == (size_t) -1);\n\n        saved_size = p->size;\n\n        /* empty name */\n        r = dns_packet_append_uint8(p, 0, NULL);\n        if (r < 0)\n                return r;\n\n        /* type */\n        r = dns_packet_append_uint16(p, DNS_TYPE_OPT, NULL);\n        if (r < 0)\n                goto fail;\n\n        /* class: maximum udp packet that can be received */\n        r = dns_packet_append_uint16(p, max_udp_size, NULL);\n        if (r < 0)\n                goto fail;\n\n        /* extended RCODE and VERSION */\n        r = dns_packet_append_uint16(p, ((uint16_t) rcode & 0x0FF0) << 4, NULL);\n        if (r < 0)\n                goto fail;\n\n        /* flags: DNSSEC OK (DO), see RFC3225 */\n        r = dns_packet_append_uint16(p, edns0_do ? EDNS0_OPT_DO : 0, NULL);\n        if (r < 0)\n                goto fail;\n\n        /* RDLENGTH */\n        if (edns0_do && !DNS_PACKET_QR(p)) {\n                /* If DO is on and this is not a reply, also append RFC6975 Algorithm data */\n\n                static const uint8_t rfc6975[] = {\n\n                        0, 5, /* OPTION_CODE: DAU */\n                        0, 6, /* LIST_LENGTH */\n                        DNSSEC_ALGORITHM_RSASHA1,\n                        DNSSEC_ALGORITHM_RSASHA1_NSEC3_SHA1,\n                        DNSSEC_ALGORITHM_RSASHA256,\n                        DNSSEC_ALGORITHM_RSASHA512,\n                        DNSSEC_ALGORITHM_ECDSAP256SHA256,\n                        DNSSEC_ALGORITHM_ECDSAP384SHA384,\n\n                        0, 6, /* OPTION_CODE: DHU */\n                        0, 3, /* LIST_LENGTH */\n                        DNSSEC_DIGEST_SHA1,\n                        DNSSEC_DIGEST_SHA256,\n                        DNSSEC_DIGEST_SHA384,\n\n                        0, 7, /* OPTION_CODE: N3U */\n                        0, 1, /* LIST_LENGTH */\n                        NSEC3_ALGORITHM_SHA1,\n                };\n\n                r = dns_packet_append_uint16(p, sizeof(rfc6975), NULL);\n                if (r < 0)\n                        goto fail;\n\n                r = dns_packet_append_blob(p, rfc6975, sizeof(rfc6975), NULL);\n        } else\n                r = dns_packet_append_uint16(p, 0, NULL);\n        if (r < 0)\n                goto fail;\n\n        DNS_PACKET_HEADER(p)->arcount = htobe16(DNS_PACKET_ARCOUNT(p) + 1);\n\n        p->opt_start = saved_size;\n        p->opt_size = p->size - saved_size;\n\n        if (start)\n                *start = saved_size;\n\n        return 0;\n\nfail:\n        dns_packet_truncate(p, saved_size);\n        return r;\n}\n\nint dns_packet_truncate_opt(DnsPacket *p) {\n        assert(p);\n\n        if (p->opt_start == (size_t) -1) {\n                assert(p->opt_size == (size_t) -1);\n                return 0;\n        }\n\n        assert(p->opt_size != (size_t) -1);\n        assert(DNS_PACKET_ARCOUNT(p) > 0);\n\n        if (p->opt_start + p->opt_size != p->size)\n                return -EBUSY;\n\n        dns_packet_truncate(p, p->opt_start);\n        DNS_PACKET_HEADER(p)->arcount = htobe16(DNS_PACKET_ARCOUNT(p) - 1);\n        p->opt_start = p->opt_size = (size_t) -1;\n\n        return 1;\n}\n\nint dns_packet_append_rr(DnsPacket *p, const DnsResourceRecord *rr, const DnsAnswerFlags flags, size_t *start, size_t *rdata_start) {\n\n        size_t saved_size, rdlength_offset, end, rdlength, rds;\n        uint32_t ttl;\n        int r;\n\n        assert(p);\n        assert(rr);\n\n        saved_size = p->size;\n\n        r = dns_packet_append_key(p, rr->key, flags, NULL);\n        if (r < 0)\n                goto fail;\n\n        ttl = flags & DNS_ANSWER_GOODBYE ? 0 : rr->ttl;\n        r = dns_packet_append_uint32(p, ttl, NULL);\n        if (r < 0)\n                goto fail;\n\n        /* Initially we write 0 here */\n        r = dns_packet_append_uint16(p, 0, &rdlength_offset);\n        if (r < 0)\n                goto fail;\n\n        rds = p->size - saved_size;\n\n        switch (rr->unparseable ? _DNS_TYPE_INVALID : rr->key->type) {\n\n        case DNS_TYPE_SRV:\n                r = dns_packet_append_uint16(p, rr->srv.priority, NULL);\n                if (r < 0)\n                        goto fail;\n\n                r = dns_packet_append_uint16(p, rr->srv.weight, NULL);\n                if (r < 0)\n                        goto fail;\n\n                r = dns_packet_append_uint16(p, rr->srv.port, NULL);\n                if (r < 0)\n                        goto fail;\n\n                r = dns_packet_append_name(p, rr->srv.name, true, false, NULL);\n                break;\n\n        case DNS_TYPE_PTR:\n        case DNS_TYPE_NS:\n        case DNS_TYPE_CNAME:\n        case DNS_TYPE_DNAME:\n                r = dns_packet_append_name(p, rr->ptr.name, true, false, NULL);\n                break;\n\n        case DNS_TYPE_HINFO:\n                r = dns_packet_append_string(p, rr->hinfo.cpu, NULL);\n                if (r < 0)\n                        goto fail;\n\n                r = dns_packet_append_string(p, rr->hinfo.os, NULL);\n                break;\n\n        case DNS_TYPE_SPF: /* exactly the same as TXT */\n        case DNS_TYPE_TXT:\n\n                if (!rr->txt.items) {\n                        /* RFC 6763, section 6.1 suggests to generate\n                         * single empty string for an empty array. */\n\n                        r = dns_packet_append_raw_string(p, NULL, 0, NULL);\n                        if (r < 0)\n                                goto fail;\n                } else {\n                        DnsTxtItem *i;\n\n                        LIST_FOREACH(items, i, rr->txt.items) {\n                                r = dns_packet_append_raw_string(p, i->data, i->length, NULL);\n                                if (r < 0)\n                                        goto fail;\n                        }\n                }\n\n                r = 0;\n                break;\n\n        case DNS_TYPE_A:\n                r = dns_packet_append_blob(p, &rr->a.in_addr, sizeof(struct in_addr), NULL);\n                break;\n\n        case DNS_TYPE_AAAA:\n                r = dns_packet_append_blob(p, &rr->aaaa.in6_addr, sizeof(struct in6_addr), NULL);\n                break;\n\n        case DNS_TYPE_SOA:\n                r = dns_packet_append_name(p, rr->soa.mname, true, false, NULL);\n                if (r < 0)\n                        goto fail;\n\n                r = dns_packet_append_name(p, rr->soa.rname, true, false, NULL);\n                if (r < 0)\n                        goto fail;\n\n                r = dns_packet_append_uint32(p, rr->soa.serial, NULL);\n                if (r < 0)\n                        goto fail;\n\n                r = dns_packet_append_uint32(p, rr->soa.refresh, NULL);\n                if (r < 0)\n                        goto fail;\n\n                r = dns_packet_append_uint32(p, rr->soa.retry, NULL);\n                if (r < 0)\n                        goto fail;\n\n                r = dns_packet_append_uint32(p, rr->soa.expire, NULL);\n                if (r < 0)\n                        goto fail;\n\n                r = dns_packet_append_uint32(p, rr->soa.minimum, NULL);\n                break;\n\n        case DNS_TYPE_MX:\n                r = dns_packet_append_uint16(p, rr->mx.priority, NULL);\n                if (r < 0)\n                        goto fail;\n\n                r = dns_packet_append_name(p, rr->mx.exchange, true, false, NULL);\n                break;\n\n        case DNS_TYPE_LOC:\n                r = dns_packet_append_uint8(p, rr->loc.version, NULL);\n                if (r < 0)\n                        goto fail;\n\n                r = dns_packet_append_uint8(p, rr->loc.size, NULL);\n                if (r < 0)\n                        goto fail;\n\n                r = dns_packet_append_uint8(p, rr->loc.horiz_pre, NULL);\n                if (r < 0)\n                        goto fail;\n\n                r = dns_packet_append_uint8(p, rr->loc.vert_pre, NULL);\n                if (r < 0)\n                        goto fail;\n\n                r = dns_packet_append_uint32(p, rr->loc.latitude, NULL);\n                if (r < 0)\n                        goto fail;\n\n                r = dns_packet_append_uint32(p, rr->loc.longitude, NULL);\n                if (r < 0)\n                        goto fail;\n\n                r = dns_packet_append_uint32(p, rr->loc.altitude, NULL);\n                break;\n\n        case DNS_TYPE_DS:\n                r = dns_packet_append_uint16(p, rr->ds.key_tag, NULL);\n                if (r < 0)\n                        goto fail;\n\n                r = dns_packet_append_uint8(p, rr->ds.algorithm, NULL);\n                if (r < 0)\n                        goto fail;\n\n                r = dns_packet_append_uint8(p, rr->ds.digest_type, NULL);\n                if (r < 0)\n                        goto fail;\n\n                r = dns_packet_append_blob(p, rr->ds.digest, rr->ds.digest_size, NULL);\n                break;\n\n        case DNS_TYPE_SSHFP:\n                r = dns_packet_append_uint8(p, rr->sshfp.algorithm, NULL);\n                if (r < 0)\n                        goto fail;\n\n                r = dns_packet_append_uint8(p, rr->sshfp.fptype, NULL);\n                if (r < 0)\n                        goto fail;\n\n                r = dns_packet_append_blob(p, rr->sshfp.fingerprint, rr->sshfp.fingerprint_size, NULL);\n                break;\n\n        case DNS_TYPE_DNSKEY:\n                r = dns_packet_append_uint16(p, rr->dnskey.flags, NULL);\n                if (r < 0)\n                        goto fail;\n\n                r = dns_packet_append_uint8(p, rr->dnskey.protocol, NULL);\n                if (r < 0)\n                        goto fail;\n\n                r = dns_packet_append_uint8(p, rr->dnskey.algorithm, NULL);\n                if (r < 0)\n                        goto fail;\n\n                r = dns_packet_append_blob(p, rr->dnskey.key, rr->dnskey.key_size, NULL);\n                break;\n\n        case DNS_TYPE_RRSIG:\n                r = dns_packet_append_uint16(p, rr->rrsig.type_covered, NULL);\n                if (r < 0)\n                        goto fail;\n\n                r = dns_packet_append_uint8(p, rr->rrsig.algorithm, NULL);\n                if (r < 0)\n                        goto fail;\n\n                r = dns_packet_append_uint8(p, rr->rrsig.labels, NULL);\n                if (r < 0)\n                        goto fail;\n\n                r = dns_packet_append_uint32(p, rr->rrsig.original_ttl, NULL);\n                if (r < 0)\n                        goto fail;\n\n                r = dns_packet_append_uint32(p, rr->rrsig.expiration, NULL);\n                if (r < 0)\n                        goto fail;\n\n                r = dns_packet_append_uint32(p, rr->rrsig.inception, NULL);\n                if (r < 0)\n                        goto fail;\n\n                r = dns_packet_append_uint16(p, rr->rrsig.key_tag, NULL);\n                if (r < 0)\n                        goto fail;\n\n                r = dns_packet_append_name(p, rr->rrsig.signer, false, true, NULL);\n                if (r < 0)\n                        goto fail;\n\n                r = dns_packet_append_blob(p, rr->rrsig.signature, rr->rrsig.signature_size, NULL);\n                break;\n\n        case DNS_TYPE_NSEC:\n                r = dns_packet_append_name(p, rr->nsec.next_domain_name, false, false, NULL);\n                if (r < 0)\n                        goto fail;\n\n                r = dns_packet_append_types(p, rr->nsec.types, NULL);\n                if (r < 0)\n                        goto fail;\n\n                break;\n\n        case DNS_TYPE_NSEC3:\n                r = dns_packet_append_uint8(p, rr->nsec3.algorithm, NULL);\n                if (r < 0)\n                        goto fail;\n\n                r = dns_packet_append_uint8(p, rr->nsec3.flags, NULL);\n                if (r < 0)\n                        goto fail;\n\n                r = dns_packet_append_uint16(p, rr->nsec3.iterations, NULL);\n                if (r < 0)\n                        goto fail;\n\n                r = dns_packet_append_uint8(p, rr->nsec3.salt_size, NULL);\n                if (r < 0)\n                        goto fail;\n\n                r = dns_packet_append_blob(p, rr->nsec3.salt, rr->nsec3.salt_size, NULL);\n                if (r < 0)\n                        goto fail;\n\n                r = dns_packet_append_uint8(p, rr->nsec3.next_hashed_name_size, NULL);\n                if (r < 0)\n                        goto fail;\n\n                r = dns_packet_append_blob(p, rr->nsec3.next_hashed_name, rr->nsec3.next_hashed_name_size, NULL);\n                if (r < 0)\n                        goto fail;\n\n                r = dns_packet_append_types(p, rr->nsec3.types, NULL);\n                if (r < 0)\n                        goto fail;\n\n                break;\n\n        case DNS_TYPE_TLSA:\n                r = dns_packet_append_uint8(p, rr->tlsa.cert_usage, NULL);\n                if (r < 0)\n                        goto fail;\n\n                r = dns_packet_append_uint8(p, rr->tlsa.selector, NULL);\n                if (r < 0)\n                        goto fail;\n\n                r = dns_packet_append_uint8(p, rr->tlsa.matching_type, NULL);\n                if (r < 0)\n                        goto fail;\n\n                r = dns_packet_append_blob(p, rr->tlsa.data, rr->tlsa.data_size, NULL);\n                break;\n\n        case DNS_TYPE_CAA:\n                r = dns_packet_append_uint8(p, rr->caa.flags, NULL);\n                if (r < 0)\n                        goto fail;\n\n                r = dns_packet_append_string(p, rr->caa.tag, NULL);\n                if (r < 0)\n                        goto fail;\n\n                r = dns_packet_append_blob(p, rr->caa.value, rr->caa.value_size, NULL);\n                break;\n\n        case DNS_TYPE_OPT:\n        case DNS_TYPE_OPENPGPKEY:\n        case _DNS_TYPE_INVALID: /* unparseable */\n        default:\n\n                r = dns_packet_append_blob(p, rr->generic.data, rr->generic.data_size, NULL);\n                break;\n        }\n        if (r < 0)\n                goto fail;\n\n        /* Let's calculate the actual data size and update the field */\n        rdlength = p->size - rdlength_offset - sizeof(uint16_t);\n        if (rdlength > 0xFFFF) {\n                r = -ENOSPC;\n                goto fail;\n        }\n\n        end = p->size;\n        p->size = rdlength_offset;\n        r = dns_packet_append_uint16(p, rdlength, NULL);\n        if (r < 0)\n                goto fail;\n        p->size = end;\n\n        if (start)\n                *start = saved_size;\n\n        if (rdata_start)\n                *rdata_start = rds;\n\n        return 0;\n\nfail:\n        dns_packet_truncate(p, saved_size);\n        return r;\n}\n\nint dns_packet_append_question(DnsPacket *p, DnsQuestion *q) {\n        DnsResourceKey *key;\n        int r;\n\n        assert(p);\n\n        DNS_QUESTION_FOREACH(key, q) {\n                r = dns_packet_append_key(p, key, 0, NULL);\n                if (r < 0)\n                        return r;\n        }\n\n        return 0;\n}\n\nint dns_packet_append_answer(DnsPacket *p, DnsAnswer *a) {\n        DnsResourceRecord *rr;\n        DnsAnswerFlags flags;\n        int r;\n\n        assert(p);\n\n        DNS_ANSWER_FOREACH_FLAGS(rr, flags, a) {\n                r = dns_packet_append_rr(p, rr, flags, NULL, NULL);\n                if (r < 0)\n                        return r;\n        }\n\n        return 0;\n}\n\nint dns_packet_read(DnsPacket *p, size_t sz, const void **ret, size_t *start) {\n        assert(p);\n\n        if (p->rindex + sz > p->size)\n                return -EMSGSIZE;\n\n        if (ret)\n                *ret = (uint8_t*) DNS_PACKET_DATA(p) + p->rindex;\n\n        if (start)\n                *start = p->rindex;\n\n        p->rindex += sz;\n        return 0;\n}\n\nvoid dns_packet_rewind(DnsPacket *p, size_t idx) {\n        assert(p);\n        assert(idx <= p->size);\n        assert(idx >= DNS_PACKET_HEADER_SIZE);\n\n        p->rindex = idx;\n}\n\nint dns_packet_read_blob(DnsPacket *p, void *d, size_t sz, size_t *start) {\n        const void *q;\n        int r;\n\n        assert(p);\n        assert(d);\n\n        r = dns_packet_read(p, sz, &q, start);\n        if (r < 0)\n                return r;\n\n        memcpy(d, q, sz);\n        return 0;\n}\n\nstatic int dns_packet_read_memdup(\n                DnsPacket *p, size_t size,\n                void **ret, size_t *ret_size,\n                size_t *ret_start) {\n\n        const void *src;\n        size_t start;\n        int r;\n\n        assert(p);\n        assert(ret);\n\n        r = dns_packet_read(p, size, &src, &start);\n        if (r < 0)\n                return r;\n\n        if (size <= 0)\n                *ret = NULL;\n        else {\n                void *copy;\n\n                copy = memdup(src, size);\n                if (!copy)\n                        return -ENOMEM;\n\n                *ret = copy;\n        }\n\n        if (ret_size)\n                *ret_size = size;\n        if (ret_start)\n                *ret_start = start;\n\n        return 0;\n}\n\nint dns_packet_read_uint8(DnsPacket *p, uint8_t *ret, size_t *start) {\n        const void *d;\n        int r;\n\n        assert(p);\n\n        r = dns_packet_read(p, sizeof(uint8_t), &d, start);\n        if (r < 0)\n                return r;\n\n        *ret = ((uint8_t*) d)[0];\n        return 0;\n}\n\nint dns_packet_read_uint16(DnsPacket *p, uint16_t *ret, size_t *start) {\n        const void *d;\n        int r;\n\n        assert(p);\n\n        r = dns_packet_read(p, sizeof(uint16_t), &d, start);\n        if (r < 0)\n                return r;\n\n        *ret = unaligned_read_be16(d);\n\n        return 0;\n}\n\nint dns_packet_read_uint32(DnsPacket *p, uint32_t *ret, size_t *start) {\n        const void *d;\n        int r;\n\n        assert(p);\n\n        r = dns_packet_read(p, sizeof(uint32_t), &d, start);\n        if (r < 0)\n                return r;\n\n        *ret = unaligned_read_be32(d);\n\n        return 0;\n}\n\nint dns_packet_read_string(DnsPacket *p, char **ret, size_t *start) {\n        _cleanup_(rewind_dns_packet) DnsPacketRewinder rewinder;\n        const void *d;\n        char *t;\n        uint8_t c;\n        int r;\n\n        assert(p);\n        INIT_REWINDER(rewinder, p);\n\n        r = dns_packet_read_uint8(p, &c, NULL);\n        if (r < 0)\n                return r;\n\n        r = dns_packet_read(p, c, &d, NULL);\n        if (r < 0)\n                return r;\n\n        if (memchr(d, 0, c))\n                return -EBADMSG;\n\n        t = strndup(d, c);\n        if (!t)\n                return -ENOMEM;\n\n        if (!utf8_is_valid(t)) {\n                free(t);\n                return -EBADMSG;\n        }\n\n        *ret = t;\n\n        if (start)\n                *start = rewinder.saved_rindex;\n        CANCEL_REWINDER(rewinder);\n\n        return 0;\n}\n\nint dns_packet_read_raw_string(DnsPacket *p, const void **ret, size_t *size, size_t *start) {\n        _cleanup_(rewind_dns_packet) DnsPacketRewinder rewinder;\n        uint8_t c;\n        int r;\n\n        assert(p);\n        INIT_REWINDER(rewinder, p);\n\n        r = dns_packet_read_uint8(p, &c, NULL);\n        if (r < 0)\n                return r;\n\n        r = dns_packet_read(p, c, ret, NULL);\n        if (r < 0)\n                return r;\n\n        if (size)\n                *size = c;\n        if (start)\n                *start = rewinder.saved_rindex;\n        CANCEL_REWINDER(rewinder);\n\n        return 0;\n}\n\nint dns_packet_read_name(\n                DnsPacket *p,\n                char **_ret,\n                bool allow_compression,\n                size_t *start) {\n\n        _cleanup_(rewind_dns_packet) DnsPacketRewinder rewinder;\n        size_t after_rindex = 0, jump_barrier;\n        _cleanup_free_ char *ret = NULL;\n        size_t n = 0, allocated = 0;\n        bool first = true;\n        int r;\n\n        assert(p);\n        assert(_ret);\n        INIT_REWINDER(rewinder, p);\n        jump_barrier = p->rindex;\n\n        if (p->refuse_compression)\n                allow_compression = false;\n\n        for (;;) {\n                uint8_t c, d;\n\n                r = dns_packet_read_uint8(p, &c, NULL);\n                if (r < 0)\n                        return r;\n\n                if (c == 0)\n                        /* End of name */\n                        break;\n                else if (c <= 63) {\n                        const char *label;\n\n                        /* Literal label */\n                        r = dns_packet_read(p, c, (const void**) &label, NULL);\n                        if (r < 0)\n                                return r;\n\n                        if (!GREEDY_REALLOC(ret, allocated, n + !first + DNS_LABEL_ESCAPED_MAX))\n                                return -ENOMEM;\n\n                        if (first)\n                                first = false;\n                        else\n                                ret[n++] = '.';\n\n                        r = dns_label_escape(label, c, ret + n, DNS_LABEL_ESCAPED_MAX);\n                        if (r < 0)\n                                return r;\n\n                        n += r;\n                        continue;\n                } else if (allow_compression && (c & 0xc0) == 0xc0) {\n                        uint16_t ptr;\n\n                        /* Pointer */\n                        r = dns_packet_read_uint8(p, &d, NULL);\n                        if (r < 0)\n                                return r;\n\n                        ptr = (uint16_t) (c & ~0xc0) << 8 | (uint16_t) d;\n                        if (ptr < DNS_PACKET_HEADER_SIZE || ptr >= jump_barrier)\n                                return -EBADMSG;\n\n                        if (after_rindex == 0)\n                                after_rindex = p->rindex;\n\n                        /* Jumps are limited to a \"prior occurrence\" (RFC-1035 4.1.4) */\n                        jump_barrier = ptr;\n                        p->rindex = ptr;\n                } else\n                        return -EBADMSG;\n        }\n\n        if (!GREEDY_REALLOC(ret, allocated, n + 1))\n                return -ENOMEM;\n\n        ret[n] = 0;\n\n        if (after_rindex != 0)\n                p->rindex= after_rindex;\n\n        *_ret = ret;\n        ret = NULL;\n\n        if (start)\n                *start = rewinder.saved_rindex;\n        CANCEL_REWINDER(rewinder);\n\n        return 0;\n}\n\nstatic int dns_packet_read_type_window(DnsPacket *p, Bitmap **types, size_t *start) {\n        uint8_t window;\n        uint8_t length;\n        const uint8_t *bitmap;\n        uint8_t bit = 0;\n        unsigned i;\n        bool found = false;\n        _cleanup_(rewind_dns_packet) DnsPacketRewinder rewinder;\n        int r;\n\n        assert(p);\n        assert(types);\n        INIT_REWINDER(rewinder, p);\n\n        r = bitmap_ensure_allocated(types);\n        if (r < 0)\n                return r;\n\n        r = dns_packet_read_uint8(p, &window, NULL);\n        if (r < 0)\n                return r;\n\n        r = dns_packet_read_uint8(p, &length, NULL);\n        if (r < 0)\n                return r;\n\n        if (length == 0 || length > 32)\n                return -EBADMSG;\n\n        r = dns_packet_read(p, length, (const void **)&bitmap, NULL);\n        if (r < 0)\n                return r;\n\n        for (i = 0; i < length; i++) {\n                uint8_t bitmask = 1 << 7;\n\n                if (!bitmap[i]) {\n                        found = false;\n                        bit += 8;\n                        continue;\n                }\n\n                found = true;\n\n                while (bitmask) {\n                        if (bitmap[i] & bitmask) {\n                                uint16_t n;\n\n                                n = (uint16_t) window << 8 | (uint16_t) bit;\n\n                                /* Ignore pseudo-types. see RFC4034 section 4.1.2 */\n                                if (dns_type_is_pseudo(n))\n                                        continue;\n\n                                r = bitmap_set(*types, n);\n                                if (r < 0)\n                                        return r;\n                        }\n\n                        bit++;\n                        bitmask >>= 1;\n                }\n        }\n\n        if (!found)\n                return -EBADMSG;\n\n        if (start)\n                *start = rewinder.saved_rindex;\n        CANCEL_REWINDER(rewinder);\n\n        return 0;\n}\n\nstatic int dns_packet_read_type_windows(DnsPacket *p, Bitmap **types, size_t size, size_t *start) {\n        _cleanup_(rewind_dns_packet) DnsPacketRewinder rewinder;\n        int r;\n\n        INIT_REWINDER(rewinder, p);\n\n        while (p->rindex < rewinder.saved_rindex + size) {\n                r = dns_packet_read_type_window(p, types, NULL);\n                if (r < 0)\n                        return r;\n\n                /* don't read past end of current RR */\n                if (p->rindex > rewinder.saved_rindex + size)\n                        return -EBADMSG;\n        }\n\n        if (p->rindex != rewinder.saved_rindex + size)\n                return -EBADMSG;\n\n        if (start)\n                *start = rewinder.saved_rindex;\n        CANCEL_REWINDER(rewinder);\n\n        return 0;\n}\n\nint dns_packet_read_key(DnsPacket *p, DnsResourceKey **ret, bool *ret_cache_flush, size_t *start) {\n        _cleanup_(rewind_dns_packet) DnsPacketRewinder rewinder;\n        _cleanup_free_ char *name = NULL;\n        bool cache_flush = false;\n        uint16_t class, type;\n        DnsResourceKey *key;\n        int r;\n\n        assert(p);\n        assert(ret);\n        INIT_REWINDER(rewinder, p);\n\n        r = dns_packet_read_name(p, &name, true, NULL);\n        if (r < 0)\n                return r;\n\n        r = dns_packet_read_uint16(p, &type, NULL);\n        if (r < 0)\n                return r;\n\n        r = dns_packet_read_uint16(p, &class, NULL);\n        if (r < 0)\n                return r;\n\n        if (p->protocol == DNS_PROTOCOL_MDNS) {\n                /* See RFC6762, Section 10.2 */\n\n                if (type != DNS_TYPE_OPT && (class & MDNS_RR_CACHE_FLUSH)) {\n                        class &= ~MDNS_RR_CACHE_FLUSH;\n                        cache_flush = true;\n                }\n        }\n\n        key = dns_resource_key_new_consume(class, type, name);\n        if (!key)\n                return -ENOMEM;\n\n        name = NULL;\n        *ret = key;\n\n        if (ret_cache_flush)\n                *ret_cache_flush = cache_flush;\n        if (start)\n                *start = rewinder.saved_rindex;\n        CANCEL_REWINDER(rewinder);\n\n        return 0;\n}\n\nstatic bool loc_size_ok(uint8_t size) {\n        uint8_t m = size >> 4, e = size & 0xF;\n\n        return m <= 9 && e <= 9 && (m > 0 || e == 0);\n}\n\nint dns_packet_read_rr(DnsPacket *p, DnsResourceRecord **ret, bool *ret_cache_flush, size_t *start) {\n        _cleanup_(dns_resource_record_unrefp) DnsResourceRecord *rr = NULL;\n        _cleanup_(dns_resource_key_unrefp) DnsResourceKey *key = NULL;\n        _cleanup_(rewind_dns_packet) DnsPacketRewinder rewinder;\n        size_t offset;\n        uint16_t rdlength;\n        bool cache_flush;\n        int r;\n\n        assert(p);\n        assert(ret);\n\n        INIT_REWINDER(rewinder, p);\n\n        r = dns_packet_read_key(p, &key, &cache_flush, NULL);\n        if (r < 0)\n                return r;\n\n        if (!dns_class_is_valid_rr(key->class) || !dns_type_is_valid_rr(key->type))\n                return -EBADMSG;\n\n        rr = dns_resource_record_new(key);\n        if (!rr)\n                return -ENOMEM;\n\n        r = dns_packet_read_uint32(p, &rr->ttl, NULL);\n        if (r < 0)\n                return r;\n\n        /* RFC 2181, Section 8, suggests to\n         * treat a TTL with the MSB set as a zero TTL. */\n        if (rr->ttl & UINT32_C(0x80000000))\n                rr->ttl = 0;\n\n        r = dns_packet_read_uint16(p, &rdlength, NULL);\n        if (r < 0)\n                return r;\n\n        if (p->rindex + rdlength > p->size)\n                return -EBADMSG;\n\n        offset = p->rindex;\n\n        switch (rr->key->type) {\n\n        case DNS_TYPE_SRV:\n                r = dns_packet_read_uint16(p, &rr->srv.priority, NULL);\n                if (r < 0)\n                        return r;\n                r = dns_packet_read_uint16(p, &rr->srv.weight, NULL);\n                if (r < 0)\n                        return r;\n                r = dns_packet_read_uint16(p, &rr->srv.port, NULL);\n                if (r < 0)\n                        return r;\n                r = dns_packet_read_name(p, &rr->srv.name, true, NULL);\n                break;\n\n        case DNS_TYPE_PTR:\n        case DNS_TYPE_NS:\n        case DNS_TYPE_CNAME:\n        case DNS_TYPE_DNAME:\n                r = dns_packet_read_name(p, &rr->ptr.name, true, NULL);\n                break;\n\n        case DNS_TYPE_HINFO:\n                r = dns_packet_read_string(p, &rr->hinfo.cpu, NULL);\n                if (r < 0)\n                        return r;\n\n                r = dns_packet_read_string(p, &rr->hinfo.os, NULL);\n                break;\n\n        case DNS_TYPE_SPF: /* exactly the same as TXT */\n        case DNS_TYPE_TXT:\n                if (rdlength <= 0) {\n                        DnsTxtItem *i;\n                        /* RFC 6763, section 6.1 suggests to treat\n                         * empty TXT RRs as equivalent to a TXT record\n                         * with a single empty string. */\n\n                        i = malloc0(offsetof(DnsTxtItem, data) + 1); /* for safety reasons we add an extra NUL byte */\n                        if (!i)\n                                return -ENOMEM;\n\n                        rr->txt.items = i;\n                } else {\n                        DnsTxtItem *last = NULL;\n\n                        while (p->rindex < offset + rdlength) {\n                                DnsTxtItem *i;\n                                const void *data;\n                                size_t sz;\n\n                                r = dns_packet_read_raw_string(p, &data, &sz, NULL);\n                                if (r < 0)\n                                        return r;\n\n                                i = malloc0(offsetof(DnsTxtItem, data) + sz + 1); /* extra NUL byte at the end */\n                                if (!i)\n                                        return -ENOMEM;\n\n                                memcpy(i->data, data, sz);\n                                i->length = sz;\n\n                                LIST_INSERT_AFTER(items, rr->txt.items, last, i);\n                                last = i;\n                        }\n                }\n\n                r = 0;\n                break;\n\n        case DNS_TYPE_A:\n                r = dns_packet_read_blob(p, &rr->a.in_addr, sizeof(struct in_addr), NULL);\n                break;\n\n        case DNS_TYPE_AAAA:\n                r = dns_packet_read_blob(p, &rr->aaaa.in6_addr, sizeof(struct in6_addr), NULL);\n                break;\n\n        case DNS_TYPE_SOA:\n                r = dns_packet_read_name(p, &rr->soa.mname, true, NULL);\n                if (r < 0)\n                        return r;\n\n                r = dns_packet_read_name(p, &rr->soa.rname, true, NULL);\n                if (r < 0)\n                        return r;\n\n                r = dns_packet_read_uint32(p, &rr->soa.serial, NULL);\n                if (r < 0)\n                        return r;\n\n                r = dns_packet_read_uint32(p, &rr->soa.refresh, NULL);\n                if (r < 0)\n                        return r;\n\n                r = dns_packet_read_uint32(p, &rr->soa.retry, NULL);\n                if (r < 0)\n                        return r;\n\n                r = dns_packet_read_uint32(p, &rr->soa.expire, NULL);\n                if (r < 0)\n                        return r;\n\n                r = dns_packet_read_uint32(p, &rr->soa.minimum, NULL);\n                break;\n\n        case DNS_TYPE_MX:\n                r = dns_packet_read_uint16(p, &rr->mx.priority, NULL);\n                if (r < 0)\n                        return r;\n\n                r = dns_packet_read_name(p, &rr->mx.exchange, true, NULL);\n                break;\n\n        case DNS_TYPE_LOC: {\n                uint8_t t;\n                size_t pos;\n\n                r = dns_packet_read_uint8(p, &t, &pos);\n                if (r < 0)\n                        return r;\n\n                if (t == 0) {\n                        rr->loc.version = t;\n\n                        r = dns_packet_read_uint8(p, &rr->loc.size, NULL);\n                        if (r < 0)\n                                return r;\n\n                        if (!loc_size_ok(rr->loc.size))\n                                return -EBADMSG;\n\n                        r = dns_packet_read_uint8(p, &rr->loc.horiz_pre, NULL);\n                        if (r < 0)\n                                return r;\n\n                        if (!loc_size_ok(rr->loc.horiz_pre))\n                                return -EBADMSG;\n\n                        r = dns_packet_read_uint8(p, &rr->loc.vert_pre, NULL);\n                        if (r < 0)\n                                return r;\n\n                        if (!loc_size_ok(rr->loc.vert_pre))\n                                return -EBADMSG;\n\n                        r = dns_packet_read_uint32(p, &rr->loc.latitude, NULL);\n                        if (r < 0)\n                                return r;\n\n                        r = dns_packet_read_uint32(p, &rr->loc.longitude, NULL);\n                        if (r < 0)\n                                return r;\n\n                        r = dns_packet_read_uint32(p, &rr->loc.altitude, NULL);\n                        if (r < 0)\n                                return r;\n\n                        break;\n                } else {\n                        dns_packet_rewind(p, pos);\n                        rr->unparseable = true;\n                        goto unparseable;\n                }\n        }\n\n        case DNS_TYPE_DS:\n                r = dns_packet_read_uint16(p, &rr->ds.key_tag, NULL);\n                if (r < 0)\n                        return r;\n\n                r = dns_packet_read_uint8(p, &rr->ds.algorithm, NULL);\n                if (r < 0)\n                        return r;\n\n                r = dns_packet_read_uint8(p, &rr->ds.digest_type, NULL);\n                if (r < 0)\n                        return r;\n\n                r = dns_packet_read_memdup(p, rdlength - 4,\n                                           &rr->ds.digest, &rr->ds.digest_size,\n                                           NULL);\n                if (r < 0)\n                        return r;\n\n                if (rr->ds.digest_size <= 0)\n                        /* the accepted size depends on the algorithm, but for now\n                           just ensure that the value is greater than zero */\n                        return -EBADMSG;\n\n                break;\n\n        case DNS_TYPE_SSHFP:\n                r = dns_packet_read_uint8(p, &rr->sshfp.algorithm, NULL);\n                if (r < 0)\n                        return r;\n\n                r = dns_packet_read_uint8(p, &rr->sshfp.fptype, NULL);\n                if (r < 0)\n                        return r;\n\n                r = dns_packet_read_memdup(p, rdlength - 2,\n                                           &rr->sshfp.fingerprint, &rr->sshfp.fingerprint_size,\n                                           NULL);\n\n                if (rr->sshfp.fingerprint_size <= 0)\n                        /* the accepted size depends on the algorithm, but for now\n                           just ensure that the value is greater than zero */\n                        return -EBADMSG;\n\n                break;\n\n        case DNS_TYPE_DNSKEY:\n                r = dns_packet_read_uint16(p, &rr->dnskey.flags, NULL);\n                if (r < 0)\n                        return r;\n\n                r = dns_packet_read_uint8(p, &rr->dnskey.protocol, NULL);\n                if (r < 0)\n                        return r;\n\n                r = dns_packet_read_uint8(p, &rr->dnskey.algorithm, NULL);\n                if (r < 0)\n                        return r;\n\n                r = dns_packet_read_memdup(p, rdlength - 4,\n                                           &rr->dnskey.key, &rr->dnskey.key_size,\n                                           NULL);\n\n                if (rr->dnskey.key_size <= 0)\n                        /* the accepted size depends on the algorithm, but for now\n                           just ensure that the value is greater than zero */\n                        return -EBADMSG;\n\n                break;\n\n        case DNS_TYPE_RRSIG:\n                r = dns_packet_read_uint16(p, &rr->rrsig.type_covered, NULL);\n                if (r < 0)\n                        return r;\n\n                r = dns_packet_read_uint8(p, &rr->rrsig.algorithm, NULL);\n                if (r < 0)\n                        return r;\n\n                r = dns_packet_read_uint8(p, &rr->rrsig.labels, NULL);\n                if (r < 0)\n                        return r;\n\n                r = dns_packet_read_uint32(p, &rr->rrsig.original_ttl, NULL);\n                if (r < 0)\n                        return r;\n\n                r = dns_packet_read_uint32(p, &rr->rrsig.expiration, NULL);\n                if (r < 0)\n                        return r;\n\n                r = dns_packet_read_uint32(p, &rr->rrsig.inception, NULL);\n                if (r < 0)\n                        return r;\n\n                r = dns_packet_read_uint16(p, &rr->rrsig.key_tag, NULL);\n                if (r < 0)\n                        return r;\n\n                r = dns_packet_read_name(p, &rr->rrsig.signer, false, NULL);\n                if (r < 0)\n                        return r;\n\n                r = dns_packet_read_memdup(p, offset + rdlength - p->rindex,\n                                           &rr->rrsig.signature, &rr->rrsig.signature_size,\n                                           NULL);\n\n                if (rr->rrsig.signature_size <= 0)\n                        /* the accepted size depends on the algorithm, but for now\n                           just ensure that the value is greater than zero */\n                        return -EBADMSG;\n\n                break;\n\n        case DNS_TYPE_NSEC: {\n\n                /*\n                 * RFC6762, section 18.14 explictly states mDNS should use name compression.\n                 * This contradicts RFC3845, section 2.1.1\n                 */\n\n                bool allow_compressed = p->protocol == DNS_PROTOCOL_MDNS;\n\n                r = dns_packet_read_name(p, &rr->nsec.next_domain_name, allow_compressed, NULL);\n                if (r < 0)\n                        return r;\n\n                r = dns_packet_read_type_windows(p, &rr->nsec.types, offset + rdlength - p->rindex, NULL);\n\n                /* We accept empty NSEC bitmaps. The bit indicating the presence of the NSEC record itself\n                 * is redundant and in e.g., RFC4956 this fact is used to define a use for NSEC records\n                 * without the NSEC bit set. */\n\n                break;\n        }\n        case DNS_TYPE_NSEC3: {\n                uint8_t size;\n\n                r = dns_packet_read_uint8(p, &rr->nsec3.algorithm, NULL);\n                if (r < 0)\n                        return r;\n\n                r = dns_packet_read_uint8(p, &rr->nsec3.flags, NULL);\n                if (r < 0)\n                        return r;\n\n                r = dns_packet_read_uint16(p, &rr->nsec3.iterations, NULL);\n                if (r < 0)\n                        return r;\n\n                /* this may be zero */\n                r = dns_packet_read_uint8(p, &size, NULL);\n                if (r < 0)\n                        return r;\n\n                r = dns_packet_read_memdup(p, size, &rr->nsec3.salt, &rr->nsec3.salt_size, NULL);\n                if (r < 0)\n                        return r;\n\n                r = dns_packet_read_uint8(p, &size, NULL);\n                if (r < 0)\n                        return r;\n\n                if (size <= 0)\n                        return -EBADMSG;\n\n                r = dns_packet_read_memdup(p, size,\n                                           &rr->nsec3.next_hashed_name, &rr->nsec3.next_hashed_name_size,\n                                           NULL);\n                if (r < 0)\n                        return r;\n\n                r = dns_packet_read_type_windows(p, &rr->nsec3.types, offset + rdlength - p->rindex, NULL);\n\n                /* empty non-terminals can have NSEC3 records, so empty bitmaps are allowed */\n\n                break;\n        }\n\n        case DNS_TYPE_TLSA:\n                r = dns_packet_read_uint8(p, &rr->tlsa.cert_usage, NULL);\n                if (r < 0)\n                        return r;\n\n                r = dns_packet_read_uint8(p, &rr->tlsa.selector, NULL);\n                if (r < 0)\n                        return r;\n\n                r = dns_packet_read_uint8(p, &rr->tlsa.matching_type, NULL);\n                if (r < 0)\n                        return r;\n\n                r = dns_packet_read_memdup(p, rdlength - 3,\n                                           &rr->tlsa.data, &rr->tlsa.data_size,\n                                           NULL);\n\n                if (rr->tlsa.data_size <= 0)\n                        /* the accepted size depends on the algorithm, but for now\n                           just ensure that the value is greater than zero */\n                        return -EBADMSG;\n\n                break;\n\n        case DNS_TYPE_CAA:\n                r = dns_packet_read_uint8(p, &rr->caa.flags, NULL);\n                if (r < 0)\n                        return r;\n\n                r = dns_packet_read_string(p, &rr->caa.tag, NULL);\n                if (r < 0)\n                        return r;\n\n                r = dns_packet_read_memdup(p,\n                                           rdlength + offset - p->rindex,\n                                           &rr->caa.value, &rr->caa.value_size, NULL);\n\n                break;\n\n        case DNS_TYPE_OPT: /* we only care about the header of OPT for now. */\n        case DNS_TYPE_OPENPGPKEY:\n        default:\n        unparseable:\n                r = dns_packet_read_memdup(p, rdlength, &rr->generic.data, &rr->generic.data_size, NULL);\n\n                break;\n        }\n        if (r < 0)\n                return r;\n        if (p->rindex != offset + rdlength)\n                return -EBADMSG;\n\n        *ret = rr;\n        rr = NULL;\n\n        if (ret_cache_flush)\n                *ret_cache_flush = cache_flush;\n        if (start)\n                *start = rewinder.saved_rindex;\n        CANCEL_REWINDER(rewinder);\n\n        return 0;\n}\n\nstatic bool opt_is_good(DnsResourceRecord *rr, bool *rfc6975) {\n        const uint8_t* p;\n        bool found_dau_dhu_n3u = false;\n        size_t l;\n\n        /* Checks whether the specified OPT RR is well-formed and whether it contains RFC6975 data (which is not OK in\n         * a reply). */\n\n        assert(rr);\n        assert(rr->key->type == DNS_TYPE_OPT);\n\n        /* Check that the version is 0 */\n        if (((rr->ttl >> 16) & UINT32_C(0xFF)) != 0) {\n                *rfc6975 = false;\n                return true; /* if it's not version 0, it's OK, but we will ignore the OPT field contents */\n        }\n\n        p = rr->opt.data;\n        l = rr->opt.data_size;\n        while (l > 0) {\n                uint16_t option_code, option_length;\n\n                /* At least four bytes for OPTION-CODE and OPTION-LENGTH are required */\n                if (l < 4U)\n                        return false;\n\n                option_code = unaligned_read_be16(p);\n                option_length = unaligned_read_be16(p + 2);\n\n                if (l < option_length + 4U)\n                        return false;\n\n                /* RFC 6975 DAU, DHU or N3U fields found. */\n                if (IN_SET(option_code, 5, 6, 7))\n                        found_dau_dhu_n3u = true;\n\n                p += option_length + 4U;\n                l -= option_length + 4U;\n        }\n\n        *rfc6975 = found_dau_dhu_n3u;\n        return true;\n}\n\nint dns_packet_extract(DnsPacket *p) {\n        _cleanup_(dns_question_unrefp) DnsQuestion *question = NULL;\n        _cleanup_(dns_answer_unrefp) DnsAnswer *answer = NULL;\n        _cleanup_(rewind_dns_packet) DnsPacketRewinder rewinder = {};\n        unsigned n, i;\n        int r;\n\n        if (p->extracted)\n                return 0;\n\n        INIT_REWINDER(rewinder, p);\n        dns_packet_rewind(p, DNS_PACKET_HEADER_SIZE);\n\n        n = DNS_PACKET_QDCOUNT(p);\n        if (n > 0) {\n                question = dns_question_new(n);\n                if (!question)\n                        return -ENOMEM;\n\n                for (i = 0; i < n; i++) {\n                        _cleanup_(dns_resource_key_unrefp) DnsResourceKey *key = NULL;\n                        bool cache_flush;\n\n                        r = dns_packet_read_key(p, &key, &cache_flush, NULL);\n                        if (r < 0)\n                                return r;\n\n                        if (cache_flush)\n                                return -EBADMSG;\n\n                        if (!dns_type_is_valid_query(key->type))\n                                return -EBADMSG;\n\n                        r = dns_question_add(question, key);\n                        if (r < 0)\n                                return r;\n                }\n        }\n\n        n = DNS_PACKET_RRCOUNT(p);\n        if (n > 0) {\n                _cleanup_(dns_resource_record_unrefp) DnsResourceRecord *previous = NULL;\n                bool bad_opt = false;\n\n                answer = dns_answer_new(n);\n                if (!answer)\n                        return -ENOMEM;\n\n                for (i = 0; i < n; i++) {\n                        _cleanup_(dns_resource_record_unrefp) DnsResourceRecord *rr = NULL;\n                        bool cache_flush = false;\n\n                        r = dns_packet_read_rr(p, &rr, &cache_flush, NULL);\n                        if (r < 0)\n                                return r;\n\n                        /* Try to reduce memory usage a bit */\n                        if (previous)\n                                dns_resource_key_reduce(&rr->key, &previous->key);\n\n                        if (rr->key->type == DNS_TYPE_OPT) {\n                                bool has_rfc6975;\n\n                                if (p->opt || bad_opt) {\n                                        /* Multiple OPT RRs? if so, let's ignore all, because there's something wrong\n                                         * with the server, and if one is valid we wouldn't know which one. */\n                                        log_debug(\"Multiple OPT RRs detected, ignoring all.\");\n                                        bad_opt = true;\n                                        continue;\n                                }\n\n                                if (!dns_name_is_root(dns_resource_key_name(rr->key))) {\n                                        /* If the OPT RR is not owned by the root domain, then it is bad, let's ignore\n                                         * it. */\n                                        log_debug(\"OPT RR is not owned by root domain, ignoring.\");\n                                        bad_opt = true;\n                                        continue;\n                                }\n\n                                if (i < DNS_PACKET_ANCOUNT(p) + DNS_PACKET_NSCOUNT(p)) {\n                                        /* OPT RR is in the wrong section? Some Belkin routers do this. This is a hint\n                                         * the EDNS implementation is borked, like the Belkin one is, hence ignore\n                                         * it. */\n                                        log_debug(\"OPT RR in wrong section, ignoring.\");\n                                        bad_opt = true;\n                                        continue;\n                                }\n\n                                if (!opt_is_good(rr, &has_rfc6975)) {\n                                        log_debug(\"Malformed OPT RR, ignoring.\");\n                                        bad_opt = true;\n                                        continue;\n                                }\n\n                                if (DNS_PACKET_QR(p)) {\n                                        /* Additional checks for responses */\n\n                                        if (!DNS_RESOURCE_RECORD_OPT_VERSION_SUPPORTED(rr)) {\n                                                /* If this is a reply and we don't know the EDNS version then something\n                                                 * is weird... */\n                                                log_debug(\"EDNS version newer that our request, bad server.\");\n                                                return -EBADMSG;\n                                        }\n\n                                        if (has_rfc6975) {\n                                                /* If the OPT RR contains RFC6975 algorithm data, then this is indication that\n                                                 * the server just copied the OPT it got from us (which contained that data)\n                                                 * back into the reply. If so, then it doesn't properly support EDNS, as\n                                                 * RFC6975 makes it very clear that the algorithm data should only be contained\n                                                 * in questions, never in replies. Crappy Belkin routers copy the OPT data for\n                                                 * example, hence let's detect this so that we downgrade early. */\n                                                log_debug(\"OPT RR contained RFC6975 data, ignoring.\");\n                                                bad_opt = true;\n                                                continue;\n                                        }\n                                }\n\n                                p->opt = dns_resource_record_ref(rr);\n                        } else {\n\n                                /* According to RFC 4795, section 2.9. only the RRs from the Answer section shall be\n                                 * cached. Hence mark only those RRs as cacheable by default, but not the ones from the\n                                 * Additional or Authority sections. */\n\n                                r = dns_answer_add(answer, rr, p->ifindex,\n                                                   (i < DNS_PACKET_ANCOUNT(p) ? DNS_ANSWER_CACHEABLE : 0) |\n                                                   (p->protocol == DNS_PROTOCOL_MDNS && !cache_flush ? DNS_ANSWER_SHARED_OWNER : 0));\n                                if (r < 0)\n                                        return r;\n                        }\n\n                        /* Remember this RR, so that we potentically can merge it's ->key object with the next RR. Note\n                         * that we only do this if we actually decided to keep the RR around. */\n                        dns_resource_record_unref(previous);\n                        previous = dns_resource_record_ref(rr);\n                }\n\n                if (bad_opt)\n                        p->opt = dns_resource_record_unref(p->opt);\n        }\n\n        p->question = question;\n        question = NULL;\n\n        p->answer = answer;\n        answer = NULL;\n\n        p->extracted = true;\n\n        /* no CANCEL, always rewind */\n        return 0;\n}\n\nint dns_packet_is_reply_for(DnsPacket *p, const DnsResourceKey *key) {\n        int r;\n\n        assert(p);\n        assert(key);\n\n        /* Checks if the specified packet is a reply for the specified\n         * key and the specified key is the only one in the question\n         * section. */\n\n        if (DNS_PACKET_QR(p) != 1)\n                return 0;\n\n        /* Let's unpack the packet, if that hasn't happened yet. */\n        r = dns_packet_extract(p);\n        if (r < 0)\n                return r;\n\n        if (p->question->n_keys != 1)\n                return 0;\n\n        return dns_resource_key_equal(p->question->keys[0], key);\n}\n\nstatic const char* const dns_rcode_table[_DNS_RCODE_MAX_DEFINED] = {\n        [DNS_RCODE_SUCCESS] = \"SUCCESS\",\n        [DNS_RCODE_FORMERR] = \"FORMERR\",\n        [DNS_RCODE_SERVFAIL] = \"SERVFAIL\",\n        [DNS_RCODE_NXDOMAIN] = \"NXDOMAIN\",\n        [DNS_RCODE_NOTIMP] = \"NOTIMP\",\n        [DNS_RCODE_REFUSED] = \"REFUSED\",\n        [DNS_RCODE_YXDOMAIN] = \"YXDOMAIN\",\n        [DNS_RCODE_YXRRSET] = \"YRRSET\",\n        [DNS_RCODE_NXRRSET] = \"NXRRSET\",\n        [DNS_RCODE_NOTAUTH] = \"NOTAUTH\",\n        [DNS_RCODE_NOTZONE] = \"NOTZONE\",\n        [DNS_RCODE_BADVERS] = \"BADVERS\",\n        [DNS_RCODE_BADKEY] = \"BADKEY\",\n        [DNS_RCODE_BADTIME] = \"BADTIME\",\n        [DNS_RCODE_BADMODE] = \"BADMODE\",\n        [DNS_RCODE_BADNAME] = \"BADNAME\",\n        [DNS_RCODE_BADALG] = \"BADALG\",\n        [DNS_RCODE_BADTRUNC] = \"BADTRUNC\",\n        [DNS_RCODE_BADCOOKIE] = \"BADCOOKIE\",\n};\nDEFINE_STRING_TABLE_LOOKUP(dns_rcode, int);\n\nstatic const char* const dns_protocol_table[_DNS_PROTOCOL_MAX] = {\n        [DNS_PROTOCOL_DNS] = \"dns\",\n        [DNS_PROTOCOL_MDNS] = \"mdns\",\n        [DNS_PROTOCOL_LLMNR] = \"llmnr\",\n};\nDEFINE_STRING_TABLE_LOOKUP(dns_protocol, DnsProtocol);\n"], "fixing_code": ["/***\n  This file is part of systemd.\n\n  Copyright 2014 Lennart Poettering\n\n  systemd is free software; you can redistribute it and/or modify it\n  under the terms of the GNU Lesser General Public License as published by\n  the Free Software Foundation; either version 2.1 of the License, or\n  (at your option) any later version.\n\n  systemd is distributed in the hope that it will be useful, but\n  WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n  Lesser General Public License for more details.\n\n  You should have received a copy of the GNU Lesser General Public License\n  along with systemd; If not, see <http://www.gnu.org/licenses/>.\n ***/\n\n#include \"alloc-util.h\"\n#include \"dns-domain.h\"\n#include \"resolved-dns-packet.h\"\n#include \"string-table.h\"\n#include \"strv.h\"\n#include \"unaligned.h\"\n#include \"utf8.h\"\n#include \"util.h\"\n\n#define EDNS0_OPT_DO (1<<15)\n\ntypedef struct DnsPacketRewinder {\n        DnsPacket *packet;\n        size_t saved_rindex;\n} DnsPacketRewinder;\n\nstatic void rewind_dns_packet(DnsPacketRewinder *rewinder) {\n        if (rewinder->packet)\n                dns_packet_rewind(rewinder->packet, rewinder->saved_rindex);\n}\n\n#define INIT_REWINDER(rewinder, p) do { rewinder.packet = p; rewinder.saved_rindex = p->rindex; } while (0)\n#define CANCEL_REWINDER(rewinder) do { rewinder.packet = NULL; } while (0)\n\nint dns_packet_new(DnsPacket **ret, DnsProtocol protocol, size_t mtu) {\n        DnsPacket *p;\n        size_t a;\n\n        assert(ret);\n\n        if (mtu <= UDP_PACKET_HEADER_SIZE)\n                a = DNS_PACKET_SIZE_START;\n        else\n                a = mtu - UDP_PACKET_HEADER_SIZE;\n\n        if (a < DNS_PACKET_HEADER_SIZE)\n                a = DNS_PACKET_HEADER_SIZE;\n\n        /* round up to next page size */\n        a = PAGE_ALIGN(ALIGN(sizeof(DnsPacket)) + a) - ALIGN(sizeof(DnsPacket));\n\n        /* make sure we never allocate more than useful */\n        if (a > DNS_PACKET_SIZE_MAX)\n                a = DNS_PACKET_SIZE_MAX;\n\n        p = malloc0(ALIGN(sizeof(DnsPacket)) + a);\n        if (!p)\n                return -ENOMEM;\n\n        p->size = p->rindex = DNS_PACKET_HEADER_SIZE;\n        p->allocated = a;\n        p->protocol = protocol;\n        p->opt_start = p->opt_size = (size_t) -1;\n        p->n_ref = 1;\n\n        *ret = p;\n\n        return 0;\n}\n\nvoid dns_packet_set_flags(DnsPacket *p, bool dnssec_checking_disabled, bool truncated) {\n\n        DnsPacketHeader *h;\n\n        assert(p);\n\n        h = DNS_PACKET_HEADER(p);\n\n        switch(p->protocol) {\n        case DNS_PROTOCOL_LLMNR:\n                assert(!truncated);\n\n                h->flags = htobe16(DNS_PACKET_MAKE_FLAGS(0 /* qr */,\n                                                         0 /* opcode */,\n                                                         0 /* c */,\n                                                         0 /* tc */,\n                                                         0 /* t */,\n                                                         0 /* ra */,\n                                                         0 /* ad */,\n                                                         0 /* cd */,\n                                                         0 /* rcode */));\n                break;\n\n        case DNS_PROTOCOL_MDNS:\n                h->flags = htobe16(DNS_PACKET_MAKE_FLAGS(0         /* qr */,\n                                                         0         /* opcode */,\n                                                         0         /* aa */,\n                                                         truncated /* tc */,\n                                                         0         /* rd (ask for recursion) */,\n                                                         0         /* ra */,\n                                                         0         /* ad */,\n                                                         0         /* cd */,\n                                                         0         /* rcode */));\n                break;\n\n        default:\n                assert(!truncated);\n\n                h->flags = htobe16(DNS_PACKET_MAKE_FLAGS(0 /* qr */,\n                                                         0 /* opcode */,\n                                                         0 /* aa */,\n                                                         0 /* tc */,\n                                                         1 /* rd (ask for recursion) */,\n                                                         0 /* ra */,\n                                                         0 /* ad */,\n                                                         dnssec_checking_disabled /* cd */,\n                                                         0 /* rcode */));\n        }\n}\n\nint dns_packet_new_query(DnsPacket **ret, DnsProtocol protocol, size_t mtu, bool dnssec_checking_disabled) {\n        DnsPacket *p;\n        int r;\n\n        assert(ret);\n\n        r = dns_packet_new(&p, protocol, mtu);\n        if (r < 0)\n                return r;\n\n        /* Always set the TC bit to 0 initially.\n         * If there are multiple packets later, we'll update the bit shortly before sending.\n         */\n        dns_packet_set_flags(p, dnssec_checking_disabled, false);\n\n        *ret = p;\n        return 0;\n}\n\nDnsPacket *dns_packet_ref(DnsPacket *p) {\n\n        if (!p)\n                return NULL;\n\n        assert(!p->on_stack);\n\n        assert(p->n_ref > 0);\n        p->n_ref++;\n        return p;\n}\n\nstatic void dns_packet_free(DnsPacket *p) {\n        char *s;\n\n        assert(p);\n\n        dns_question_unref(p->question);\n        dns_answer_unref(p->answer);\n        dns_resource_record_unref(p->opt);\n\n        while ((s = hashmap_steal_first_key(p->names)))\n                free(s);\n        hashmap_free(p->names);\n\n        free(p->_data);\n\n        if (!p->on_stack)\n                free(p);\n}\n\nDnsPacket *dns_packet_unref(DnsPacket *p) {\n        if (!p)\n                return NULL;\n\n        assert(p->n_ref > 0);\n\n        dns_packet_unref(p->more);\n\n        if (p->n_ref == 1)\n                dns_packet_free(p);\n        else\n                p->n_ref--;\n\n        return NULL;\n}\n\nint dns_packet_validate(DnsPacket *p) {\n        assert(p);\n\n        if (p->size < DNS_PACKET_HEADER_SIZE)\n                return -EBADMSG;\n\n        if (p->size > DNS_PACKET_SIZE_MAX)\n                return -EBADMSG;\n\n        return 1;\n}\n\nint dns_packet_validate_reply(DnsPacket *p) {\n        int r;\n\n        assert(p);\n\n        r = dns_packet_validate(p);\n        if (r < 0)\n                return r;\n\n        if (DNS_PACKET_QR(p) != 1)\n                return 0;\n\n        if (DNS_PACKET_OPCODE(p) != 0)\n                return -EBADMSG;\n\n        switch (p->protocol) {\n\n        case DNS_PROTOCOL_LLMNR:\n                /* RFC 4795, Section 2.1.1. says to discard all replies with QDCOUNT != 1 */\n                if (DNS_PACKET_QDCOUNT(p) != 1)\n                        return -EBADMSG;\n\n                break;\n\n        case DNS_PROTOCOL_MDNS:\n                /* RFC 6762, Section 18 */\n                if (DNS_PACKET_RCODE(p) != 0)\n                        return -EBADMSG;\n\n                break;\n\n        default:\n                break;\n        }\n\n        return 1;\n}\n\nint dns_packet_validate_query(DnsPacket *p) {\n        int r;\n\n        assert(p);\n\n        r = dns_packet_validate(p);\n        if (r < 0)\n                return r;\n\n        if (DNS_PACKET_QR(p) != 0)\n                return 0;\n\n        if (DNS_PACKET_OPCODE(p) != 0)\n                return -EBADMSG;\n\n        if (DNS_PACKET_TC(p))\n                return -EBADMSG;\n\n        switch (p->protocol) {\n\n        case DNS_PROTOCOL_LLMNR:\n        case DNS_PROTOCOL_DNS:\n                /* RFC 4795, Section 2.1.1. says to discard all queries with QDCOUNT != 1 */\n                if (DNS_PACKET_QDCOUNT(p) != 1)\n                        return -EBADMSG;\n\n                /* RFC 4795, Section 2.1.1. says to discard all queries with ANCOUNT != 0 */\n                if (DNS_PACKET_ANCOUNT(p) > 0)\n                        return -EBADMSG;\n\n                /* RFC 4795, Section 2.1.1. says to discard all queries with NSCOUNT != 0 */\n                if (DNS_PACKET_NSCOUNT(p) > 0)\n                        return -EBADMSG;\n\n                break;\n\n        case DNS_PROTOCOL_MDNS:\n                /* RFC 6762, Section 18 */\n                if (DNS_PACKET_AA(p)    != 0 ||\n                    DNS_PACKET_RD(p)    != 0 ||\n                    DNS_PACKET_RA(p)    != 0 ||\n                    DNS_PACKET_AD(p)    != 0 ||\n                    DNS_PACKET_CD(p)    != 0 ||\n                    DNS_PACKET_RCODE(p) != 0)\n                        return -EBADMSG;\n\n                break;\n\n        default:\n                break;\n        }\n\n        return 1;\n}\n\nstatic int dns_packet_extend(DnsPacket *p, size_t add, void **ret, size_t *start) {\n        assert(p);\n\n        if (p->size + add > p->allocated) {\n                size_t a;\n\n                a = PAGE_ALIGN((p->size + add) * 2);\n                if (a > DNS_PACKET_SIZE_MAX)\n                        a = DNS_PACKET_SIZE_MAX;\n\n                if (p->size + add > a)\n                        return -EMSGSIZE;\n\n                if (p->_data) {\n                        void *d;\n\n                        d = realloc(p->_data, a);\n                        if (!d)\n                                return -ENOMEM;\n\n                        p->_data = d;\n                } else {\n                        p->_data = malloc(a);\n                        if (!p->_data)\n                                return -ENOMEM;\n\n                        memcpy(p->_data, (uint8_t*) p + ALIGN(sizeof(DnsPacket)), p->size);\n                        memzero((uint8_t*) p->_data + p->size, a - p->size);\n                }\n\n                p->allocated = a;\n        }\n\n        if (start)\n                *start = p->size;\n\n        if (ret)\n                *ret = (uint8_t*) DNS_PACKET_DATA(p) + p->size;\n\n        p->size += add;\n        return 0;\n}\n\nvoid dns_packet_truncate(DnsPacket *p, size_t sz) {\n        Iterator i;\n        char *s;\n        void *n;\n\n        assert(p);\n\n        if (p->size <= sz)\n                return;\n\n        HASHMAP_FOREACH_KEY(n, s, p->names, i) {\n\n                if (PTR_TO_SIZE(n) < sz)\n                        continue;\n\n                hashmap_remove(p->names, s);\n                free(s);\n        }\n\n        p->size = sz;\n}\n\nint dns_packet_append_blob(DnsPacket *p, const void *d, size_t l, size_t *start) {\n        void *q;\n        int r;\n\n        assert(p);\n\n        r = dns_packet_extend(p, l, &q, start);\n        if (r < 0)\n                return r;\n\n        memcpy(q, d, l);\n        return 0;\n}\n\nint dns_packet_append_uint8(DnsPacket *p, uint8_t v, size_t *start) {\n        void *d;\n        int r;\n\n        assert(p);\n\n        r = dns_packet_extend(p, sizeof(uint8_t), &d, start);\n        if (r < 0)\n                return r;\n\n        ((uint8_t*) d)[0] = v;\n\n        return 0;\n}\n\nint dns_packet_append_uint16(DnsPacket *p, uint16_t v, size_t *start) {\n        void *d;\n        int r;\n\n        assert(p);\n\n        r = dns_packet_extend(p, sizeof(uint16_t), &d, start);\n        if (r < 0)\n                return r;\n\n        unaligned_write_be16(d, v);\n\n        return 0;\n}\n\nint dns_packet_append_uint32(DnsPacket *p, uint32_t v, size_t *start) {\n        void *d;\n        int r;\n\n        assert(p);\n\n        r = dns_packet_extend(p, sizeof(uint32_t), &d, start);\n        if (r < 0)\n                return r;\n\n        unaligned_write_be32(d, v);\n\n        return 0;\n}\n\nint dns_packet_append_string(DnsPacket *p, const char *s, size_t *start) {\n        assert(p);\n        assert(s);\n\n        return dns_packet_append_raw_string(p, s, strlen(s), start);\n}\n\nint dns_packet_append_raw_string(DnsPacket *p, const void *s, size_t size, size_t *start) {\n        void *d;\n        int r;\n\n        assert(p);\n        assert(s || size == 0);\n\n        if (size > 255)\n                return -E2BIG;\n\n        r = dns_packet_extend(p, 1 + size, &d, start);\n        if (r < 0)\n                return r;\n\n        ((uint8_t*) d)[0] = (uint8_t) size;\n\n        memcpy_safe(((uint8_t*) d) + 1, s, size);\n\n        return 0;\n}\n\nint dns_packet_append_label(DnsPacket *p, const char *d, size_t l, bool canonical_candidate, size_t *start) {\n        uint8_t *w;\n        int r;\n\n        /* Append a label to a packet. Optionally, does this in DNSSEC\n         * canonical form, if this label is marked as a candidate for\n         * it, and the canonical form logic is enabled for the\n         * packet */\n\n        assert(p);\n        assert(d);\n\n        if (l > DNS_LABEL_MAX)\n                return -E2BIG;\n\n        r = dns_packet_extend(p, 1 + l, (void**) &w, start);\n        if (r < 0)\n                return r;\n\n        *(w++) = (uint8_t) l;\n\n        if (p->canonical_form && canonical_candidate) {\n                size_t i;\n\n                /* Generate in canonical form, as defined by DNSSEC\n                 * RFC 4034, Section 6.2, i.e. all lower-case. */\n\n                for (i = 0; i < l; i++)\n                        w[i] = (uint8_t) ascii_tolower(d[i]);\n        } else\n                /* Otherwise, just copy the string unaltered. This is\n                 * essential for DNS-SD, where the casing of labels\n                 * matters and needs to be retained. */\n                memcpy(w, d, l);\n\n        return 0;\n}\n\nint dns_packet_append_name(\n                DnsPacket *p,\n                const char *name,\n                bool allow_compression,\n                bool canonical_candidate,\n                size_t *start) {\n\n        size_t saved_size;\n        int r;\n\n        assert(p);\n        assert(name);\n\n        if (p->refuse_compression)\n                allow_compression = false;\n\n        saved_size = p->size;\n\n        while (!dns_name_is_root(name)) {\n                const char *z = name;\n                char label[DNS_LABEL_MAX];\n                size_t n = 0;\n\n                if (allow_compression)\n                        n = PTR_TO_SIZE(hashmap_get(p->names, name));\n                if (n > 0) {\n                        assert(n < p->size);\n\n                        if (n < 0x4000) {\n                                r = dns_packet_append_uint16(p, 0xC000 | n, NULL);\n                                if (r < 0)\n                                        goto fail;\n\n                                goto done;\n                        }\n                }\n\n                r = dns_label_unescape(&name, label, sizeof(label));\n                if (r < 0)\n                        goto fail;\n\n                r = dns_packet_append_label(p, label, r, canonical_candidate, &n);\n                if (r < 0)\n                        goto fail;\n\n                if (allow_compression) {\n                        _cleanup_free_ char *s = NULL;\n\n                        s = strdup(z);\n                        if (!s) {\n                                r = -ENOMEM;\n                                goto fail;\n                        }\n\n                        r = hashmap_ensure_allocated(&p->names, &dns_name_hash_ops);\n                        if (r < 0)\n                                goto fail;\n\n                        r = hashmap_put(p->names, s, SIZE_TO_PTR(n));\n                        if (r < 0)\n                                goto fail;\n\n                        s = NULL;\n                }\n        }\n\n        r = dns_packet_append_uint8(p, 0, NULL);\n        if (r < 0)\n                return r;\n\ndone:\n        if (start)\n                *start = saved_size;\n\n        return 0;\n\nfail:\n        dns_packet_truncate(p, saved_size);\n        return r;\n}\n\nint dns_packet_append_key(DnsPacket *p, const DnsResourceKey *k, const DnsAnswerFlags flags, size_t *start) {\n        size_t saved_size;\n        uint16_t class;\n        int r;\n\n        assert(p);\n        assert(k);\n\n        saved_size = p->size;\n\n        r = dns_packet_append_name(p, dns_resource_key_name(k), true, true, NULL);\n        if (r < 0)\n                goto fail;\n\n        r = dns_packet_append_uint16(p, k->type, NULL);\n        if (r < 0)\n                goto fail;\n\n        class = flags & DNS_ANSWER_CACHE_FLUSH ? k->class | MDNS_RR_CACHE_FLUSH : k->class;\n        r = dns_packet_append_uint16(p, class, NULL);\n        if (r < 0)\n                goto fail;\n\n        if (start)\n                *start = saved_size;\n\n        return 0;\n\nfail:\n        dns_packet_truncate(p, saved_size);\n        return r;\n}\n\nstatic int dns_packet_append_type_window(DnsPacket *p, uint8_t window, uint8_t length, const uint8_t *types, size_t *start) {\n        size_t saved_size;\n        int r;\n\n        assert(p);\n        assert(types);\n        assert(length > 0);\n\n        saved_size = p->size;\n\n        r = dns_packet_append_uint8(p, window, NULL);\n        if (r < 0)\n                goto fail;\n\n        r = dns_packet_append_uint8(p, length, NULL);\n        if (r < 0)\n                goto fail;\n\n        r = dns_packet_append_blob(p, types, length, NULL);\n        if (r < 0)\n                goto fail;\n\n        if (start)\n                *start = saved_size;\n\n        return 0;\nfail:\n        dns_packet_truncate(p, saved_size);\n        return r;\n}\n\nstatic int dns_packet_append_types(DnsPacket *p, Bitmap *types, size_t *start) {\n        Iterator i;\n        uint8_t window = 0;\n        uint8_t entry = 0;\n        uint8_t bitmaps[32] = {};\n        unsigned n;\n        size_t saved_size;\n        int r;\n\n        assert(p);\n\n        saved_size = p->size;\n\n        BITMAP_FOREACH(n, types, i) {\n                assert(n <= 0xffff);\n\n                if ((n >> 8) != window && bitmaps[entry / 8] != 0) {\n                        r = dns_packet_append_type_window(p, window, entry / 8 + 1, bitmaps, NULL);\n                        if (r < 0)\n                                goto fail;\n\n                        zero(bitmaps);\n                }\n\n                window = n >> 8;\n                entry = n & 255;\n\n                bitmaps[entry / 8] |= 1 << (7 - (entry % 8));\n        }\n\n        if (bitmaps[entry / 8] != 0) {\n                r = dns_packet_append_type_window(p, window, entry / 8 + 1, bitmaps, NULL);\n                if (r < 0)\n                        goto fail;\n        }\n\n        if (start)\n                *start = saved_size;\n\n        return 0;\nfail:\n        dns_packet_truncate(p, saved_size);\n        return r;\n}\n\n/* Append the OPT pseudo-RR described in RFC6891 */\nint dns_packet_append_opt(DnsPacket *p, uint16_t max_udp_size, bool edns0_do, int rcode, size_t *start) {\n        size_t saved_size;\n        int r;\n\n        assert(p);\n        /* we must never advertise supported packet size smaller than the legacy max */\n        assert(max_udp_size >= DNS_PACKET_UNICAST_SIZE_MAX);\n        assert(rcode >= 0);\n        assert(rcode <= _DNS_RCODE_MAX);\n\n        if (p->opt_start != (size_t) -1)\n                return -EBUSY;\n\n        assert(p->opt_size == (size_t) -1);\n\n        saved_size = p->size;\n\n        /* empty name */\n        r = dns_packet_append_uint8(p, 0, NULL);\n        if (r < 0)\n                return r;\n\n        /* type */\n        r = dns_packet_append_uint16(p, DNS_TYPE_OPT, NULL);\n        if (r < 0)\n                goto fail;\n\n        /* class: maximum udp packet that can be received */\n        r = dns_packet_append_uint16(p, max_udp_size, NULL);\n        if (r < 0)\n                goto fail;\n\n        /* extended RCODE and VERSION */\n        r = dns_packet_append_uint16(p, ((uint16_t) rcode & 0x0FF0) << 4, NULL);\n        if (r < 0)\n                goto fail;\n\n        /* flags: DNSSEC OK (DO), see RFC3225 */\n        r = dns_packet_append_uint16(p, edns0_do ? EDNS0_OPT_DO : 0, NULL);\n        if (r < 0)\n                goto fail;\n\n        /* RDLENGTH */\n        if (edns0_do && !DNS_PACKET_QR(p)) {\n                /* If DO is on and this is not a reply, also append RFC6975 Algorithm data */\n\n                static const uint8_t rfc6975[] = {\n\n                        0, 5, /* OPTION_CODE: DAU */\n                        0, 6, /* LIST_LENGTH */\n                        DNSSEC_ALGORITHM_RSASHA1,\n                        DNSSEC_ALGORITHM_RSASHA1_NSEC3_SHA1,\n                        DNSSEC_ALGORITHM_RSASHA256,\n                        DNSSEC_ALGORITHM_RSASHA512,\n                        DNSSEC_ALGORITHM_ECDSAP256SHA256,\n                        DNSSEC_ALGORITHM_ECDSAP384SHA384,\n\n                        0, 6, /* OPTION_CODE: DHU */\n                        0, 3, /* LIST_LENGTH */\n                        DNSSEC_DIGEST_SHA1,\n                        DNSSEC_DIGEST_SHA256,\n                        DNSSEC_DIGEST_SHA384,\n\n                        0, 7, /* OPTION_CODE: N3U */\n                        0, 1, /* LIST_LENGTH */\n                        NSEC3_ALGORITHM_SHA1,\n                };\n\n                r = dns_packet_append_uint16(p, sizeof(rfc6975), NULL);\n                if (r < 0)\n                        goto fail;\n\n                r = dns_packet_append_blob(p, rfc6975, sizeof(rfc6975), NULL);\n        } else\n                r = dns_packet_append_uint16(p, 0, NULL);\n        if (r < 0)\n                goto fail;\n\n        DNS_PACKET_HEADER(p)->arcount = htobe16(DNS_PACKET_ARCOUNT(p) + 1);\n\n        p->opt_start = saved_size;\n        p->opt_size = p->size - saved_size;\n\n        if (start)\n                *start = saved_size;\n\n        return 0;\n\nfail:\n        dns_packet_truncate(p, saved_size);\n        return r;\n}\n\nint dns_packet_truncate_opt(DnsPacket *p) {\n        assert(p);\n\n        if (p->opt_start == (size_t) -1) {\n                assert(p->opt_size == (size_t) -1);\n                return 0;\n        }\n\n        assert(p->opt_size != (size_t) -1);\n        assert(DNS_PACKET_ARCOUNT(p) > 0);\n\n        if (p->opt_start + p->opt_size != p->size)\n                return -EBUSY;\n\n        dns_packet_truncate(p, p->opt_start);\n        DNS_PACKET_HEADER(p)->arcount = htobe16(DNS_PACKET_ARCOUNT(p) - 1);\n        p->opt_start = p->opt_size = (size_t) -1;\n\n        return 1;\n}\n\nint dns_packet_append_rr(DnsPacket *p, const DnsResourceRecord *rr, const DnsAnswerFlags flags, size_t *start, size_t *rdata_start) {\n\n        size_t saved_size, rdlength_offset, end, rdlength, rds;\n        uint32_t ttl;\n        int r;\n\n        assert(p);\n        assert(rr);\n\n        saved_size = p->size;\n\n        r = dns_packet_append_key(p, rr->key, flags, NULL);\n        if (r < 0)\n                goto fail;\n\n        ttl = flags & DNS_ANSWER_GOODBYE ? 0 : rr->ttl;\n        r = dns_packet_append_uint32(p, ttl, NULL);\n        if (r < 0)\n                goto fail;\n\n        /* Initially we write 0 here */\n        r = dns_packet_append_uint16(p, 0, &rdlength_offset);\n        if (r < 0)\n                goto fail;\n\n        rds = p->size - saved_size;\n\n        switch (rr->unparseable ? _DNS_TYPE_INVALID : rr->key->type) {\n\n        case DNS_TYPE_SRV:\n                r = dns_packet_append_uint16(p, rr->srv.priority, NULL);\n                if (r < 0)\n                        goto fail;\n\n                r = dns_packet_append_uint16(p, rr->srv.weight, NULL);\n                if (r < 0)\n                        goto fail;\n\n                r = dns_packet_append_uint16(p, rr->srv.port, NULL);\n                if (r < 0)\n                        goto fail;\n\n                r = dns_packet_append_name(p, rr->srv.name, true, false, NULL);\n                break;\n\n        case DNS_TYPE_PTR:\n        case DNS_TYPE_NS:\n        case DNS_TYPE_CNAME:\n        case DNS_TYPE_DNAME:\n                r = dns_packet_append_name(p, rr->ptr.name, true, false, NULL);\n                break;\n\n        case DNS_TYPE_HINFO:\n                r = dns_packet_append_string(p, rr->hinfo.cpu, NULL);\n                if (r < 0)\n                        goto fail;\n\n                r = dns_packet_append_string(p, rr->hinfo.os, NULL);\n                break;\n\n        case DNS_TYPE_SPF: /* exactly the same as TXT */\n        case DNS_TYPE_TXT:\n\n                if (!rr->txt.items) {\n                        /* RFC 6763, section 6.1 suggests to generate\n                         * single empty string for an empty array. */\n\n                        r = dns_packet_append_raw_string(p, NULL, 0, NULL);\n                        if (r < 0)\n                                goto fail;\n                } else {\n                        DnsTxtItem *i;\n\n                        LIST_FOREACH(items, i, rr->txt.items) {\n                                r = dns_packet_append_raw_string(p, i->data, i->length, NULL);\n                                if (r < 0)\n                                        goto fail;\n                        }\n                }\n\n                r = 0;\n                break;\n\n        case DNS_TYPE_A:\n                r = dns_packet_append_blob(p, &rr->a.in_addr, sizeof(struct in_addr), NULL);\n                break;\n\n        case DNS_TYPE_AAAA:\n                r = dns_packet_append_blob(p, &rr->aaaa.in6_addr, sizeof(struct in6_addr), NULL);\n                break;\n\n        case DNS_TYPE_SOA:\n                r = dns_packet_append_name(p, rr->soa.mname, true, false, NULL);\n                if (r < 0)\n                        goto fail;\n\n                r = dns_packet_append_name(p, rr->soa.rname, true, false, NULL);\n                if (r < 0)\n                        goto fail;\n\n                r = dns_packet_append_uint32(p, rr->soa.serial, NULL);\n                if (r < 0)\n                        goto fail;\n\n                r = dns_packet_append_uint32(p, rr->soa.refresh, NULL);\n                if (r < 0)\n                        goto fail;\n\n                r = dns_packet_append_uint32(p, rr->soa.retry, NULL);\n                if (r < 0)\n                        goto fail;\n\n                r = dns_packet_append_uint32(p, rr->soa.expire, NULL);\n                if (r < 0)\n                        goto fail;\n\n                r = dns_packet_append_uint32(p, rr->soa.minimum, NULL);\n                break;\n\n        case DNS_TYPE_MX:\n                r = dns_packet_append_uint16(p, rr->mx.priority, NULL);\n                if (r < 0)\n                        goto fail;\n\n                r = dns_packet_append_name(p, rr->mx.exchange, true, false, NULL);\n                break;\n\n        case DNS_TYPE_LOC:\n                r = dns_packet_append_uint8(p, rr->loc.version, NULL);\n                if (r < 0)\n                        goto fail;\n\n                r = dns_packet_append_uint8(p, rr->loc.size, NULL);\n                if (r < 0)\n                        goto fail;\n\n                r = dns_packet_append_uint8(p, rr->loc.horiz_pre, NULL);\n                if (r < 0)\n                        goto fail;\n\n                r = dns_packet_append_uint8(p, rr->loc.vert_pre, NULL);\n                if (r < 0)\n                        goto fail;\n\n                r = dns_packet_append_uint32(p, rr->loc.latitude, NULL);\n                if (r < 0)\n                        goto fail;\n\n                r = dns_packet_append_uint32(p, rr->loc.longitude, NULL);\n                if (r < 0)\n                        goto fail;\n\n                r = dns_packet_append_uint32(p, rr->loc.altitude, NULL);\n                break;\n\n        case DNS_TYPE_DS:\n                r = dns_packet_append_uint16(p, rr->ds.key_tag, NULL);\n                if (r < 0)\n                        goto fail;\n\n                r = dns_packet_append_uint8(p, rr->ds.algorithm, NULL);\n                if (r < 0)\n                        goto fail;\n\n                r = dns_packet_append_uint8(p, rr->ds.digest_type, NULL);\n                if (r < 0)\n                        goto fail;\n\n                r = dns_packet_append_blob(p, rr->ds.digest, rr->ds.digest_size, NULL);\n                break;\n\n        case DNS_TYPE_SSHFP:\n                r = dns_packet_append_uint8(p, rr->sshfp.algorithm, NULL);\n                if (r < 0)\n                        goto fail;\n\n                r = dns_packet_append_uint8(p, rr->sshfp.fptype, NULL);\n                if (r < 0)\n                        goto fail;\n\n                r = dns_packet_append_blob(p, rr->sshfp.fingerprint, rr->sshfp.fingerprint_size, NULL);\n                break;\n\n        case DNS_TYPE_DNSKEY:\n                r = dns_packet_append_uint16(p, rr->dnskey.flags, NULL);\n                if (r < 0)\n                        goto fail;\n\n                r = dns_packet_append_uint8(p, rr->dnskey.protocol, NULL);\n                if (r < 0)\n                        goto fail;\n\n                r = dns_packet_append_uint8(p, rr->dnskey.algorithm, NULL);\n                if (r < 0)\n                        goto fail;\n\n                r = dns_packet_append_blob(p, rr->dnskey.key, rr->dnskey.key_size, NULL);\n                break;\n\n        case DNS_TYPE_RRSIG:\n                r = dns_packet_append_uint16(p, rr->rrsig.type_covered, NULL);\n                if (r < 0)\n                        goto fail;\n\n                r = dns_packet_append_uint8(p, rr->rrsig.algorithm, NULL);\n                if (r < 0)\n                        goto fail;\n\n                r = dns_packet_append_uint8(p, rr->rrsig.labels, NULL);\n                if (r < 0)\n                        goto fail;\n\n                r = dns_packet_append_uint32(p, rr->rrsig.original_ttl, NULL);\n                if (r < 0)\n                        goto fail;\n\n                r = dns_packet_append_uint32(p, rr->rrsig.expiration, NULL);\n                if (r < 0)\n                        goto fail;\n\n                r = dns_packet_append_uint32(p, rr->rrsig.inception, NULL);\n                if (r < 0)\n                        goto fail;\n\n                r = dns_packet_append_uint16(p, rr->rrsig.key_tag, NULL);\n                if (r < 0)\n                        goto fail;\n\n                r = dns_packet_append_name(p, rr->rrsig.signer, false, true, NULL);\n                if (r < 0)\n                        goto fail;\n\n                r = dns_packet_append_blob(p, rr->rrsig.signature, rr->rrsig.signature_size, NULL);\n                break;\n\n        case DNS_TYPE_NSEC:\n                r = dns_packet_append_name(p, rr->nsec.next_domain_name, false, false, NULL);\n                if (r < 0)\n                        goto fail;\n\n                r = dns_packet_append_types(p, rr->nsec.types, NULL);\n                if (r < 0)\n                        goto fail;\n\n                break;\n\n        case DNS_TYPE_NSEC3:\n                r = dns_packet_append_uint8(p, rr->nsec3.algorithm, NULL);\n                if (r < 0)\n                        goto fail;\n\n                r = dns_packet_append_uint8(p, rr->nsec3.flags, NULL);\n                if (r < 0)\n                        goto fail;\n\n                r = dns_packet_append_uint16(p, rr->nsec3.iterations, NULL);\n                if (r < 0)\n                        goto fail;\n\n                r = dns_packet_append_uint8(p, rr->nsec3.salt_size, NULL);\n                if (r < 0)\n                        goto fail;\n\n                r = dns_packet_append_blob(p, rr->nsec3.salt, rr->nsec3.salt_size, NULL);\n                if (r < 0)\n                        goto fail;\n\n                r = dns_packet_append_uint8(p, rr->nsec3.next_hashed_name_size, NULL);\n                if (r < 0)\n                        goto fail;\n\n                r = dns_packet_append_blob(p, rr->nsec3.next_hashed_name, rr->nsec3.next_hashed_name_size, NULL);\n                if (r < 0)\n                        goto fail;\n\n                r = dns_packet_append_types(p, rr->nsec3.types, NULL);\n                if (r < 0)\n                        goto fail;\n\n                break;\n\n        case DNS_TYPE_TLSA:\n                r = dns_packet_append_uint8(p, rr->tlsa.cert_usage, NULL);\n                if (r < 0)\n                        goto fail;\n\n                r = dns_packet_append_uint8(p, rr->tlsa.selector, NULL);\n                if (r < 0)\n                        goto fail;\n\n                r = dns_packet_append_uint8(p, rr->tlsa.matching_type, NULL);\n                if (r < 0)\n                        goto fail;\n\n                r = dns_packet_append_blob(p, rr->tlsa.data, rr->tlsa.data_size, NULL);\n                break;\n\n        case DNS_TYPE_CAA:\n                r = dns_packet_append_uint8(p, rr->caa.flags, NULL);\n                if (r < 0)\n                        goto fail;\n\n                r = dns_packet_append_string(p, rr->caa.tag, NULL);\n                if (r < 0)\n                        goto fail;\n\n                r = dns_packet_append_blob(p, rr->caa.value, rr->caa.value_size, NULL);\n                break;\n\n        case DNS_TYPE_OPT:\n        case DNS_TYPE_OPENPGPKEY:\n        case _DNS_TYPE_INVALID: /* unparseable */\n        default:\n\n                r = dns_packet_append_blob(p, rr->generic.data, rr->generic.data_size, NULL);\n                break;\n        }\n        if (r < 0)\n                goto fail;\n\n        /* Let's calculate the actual data size and update the field */\n        rdlength = p->size - rdlength_offset - sizeof(uint16_t);\n        if (rdlength > 0xFFFF) {\n                r = -ENOSPC;\n                goto fail;\n        }\n\n        end = p->size;\n        p->size = rdlength_offset;\n        r = dns_packet_append_uint16(p, rdlength, NULL);\n        if (r < 0)\n                goto fail;\n        p->size = end;\n\n        if (start)\n                *start = saved_size;\n\n        if (rdata_start)\n                *rdata_start = rds;\n\n        return 0;\n\nfail:\n        dns_packet_truncate(p, saved_size);\n        return r;\n}\n\nint dns_packet_append_question(DnsPacket *p, DnsQuestion *q) {\n        DnsResourceKey *key;\n        int r;\n\n        assert(p);\n\n        DNS_QUESTION_FOREACH(key, q) {\n                r = dns_packet_append_key(p, key, 0, NULL);\n                if (r < 0)\n                        return r;\n        }\n\n        return 0;\n}\n\nint dns_packet_append_answer(DnsPacket *p, DnsAnswer *a) {\n        DnsResourceRecord *rr;\n        DnsAnswerFlags flags;\n        int r;\n\n        assert(p);\n\n        DNS_ANSWER_FOREACH_FLAGS(rr, flags, a) {\n                r = dns_packet_append_rr(p, rr, flags, NULL, NULL);\n                if (r < 0)\n                        return r;\n        }\n\n        return 0;\n}\n\nint dns_packet_read(DnsPacket *p, size_t sz, const void **ret, size_t *start) {\n        assert(p);\n\n        if (p->rindex + sz > p->size)\n                return -EMSGSIZE;\n\n        if (ret)\n                *ret = (uint8_t*) DNS_PACKET_DATA(p) + p->rindex;\n\n        if (start)\n                *start = p->rindex;\n\n        p->rindex += sz;\n        return 0;\n}\n\nvoid dns_packet_rewind(DnsPacket *p, size_t idx) {\n        assert(p);\n        assert(idx <= p->size);\n        assert(idx >= DNS_PACKET_HEADER_SIZE);\n\n        p->rindex = idx;\n}\n\nint dns_packet_read_blob(DnsPacket *p, void *d, size_t sz, size_t *start) {\n        const void *q;\n        int r;\n\n        assert(p);\n        assert(d);\n\n        r = dns_packet_read(p, sz, &q, start);\n        if (r < 0)\n                return r;\n\n        memcpy(d, q, sz);\n        return 0;\n}\n\nstatic int dns_packet_read_memdup(\n                DnsPacket *p, size_t size,\n                void **ret, size_t *ret_size,\n                size_t *ret_start) {\n\n        const void *src;\n        size_t start;\n        int r;\n\n        assert(p);\n        assert(ret);\n\n        r = dns_packet_read(p, size, &src, &start);\n        if (r < 0)\n                return r;\n\n        if (size <= 0)\n                *ret = NULL;\n        else {\n                void *copy;\n\n                copy = memdup(src, size);\n                if (!copy)\n                        return -ENOMEM;\n\n                *ret = copy;\n        }\n\n        if (ret_size)\n                *ret_size = size;\n        if (ret_start)\n                *ret_start = start;\n\n        return 0;\n}\n\nint dns_packet_read_uint8(DnsPacket *p, uint8_t *ret, size_t *start) {\n        const void *d;\n        int r;\n\n        assert(p);\n\n        r = dns_packet_read(p, sizeof(uint8_t), &d, start);\n        if (r < 0)\n                return r;\n\n        *ret = ((uint8_t*) d)[0];\n        return 0;\n}\n\nint dns_packet_read_uint16(DnsPacket *p, uint16_t *ret, size_t *start) {\n        const void *d;\n        int r;\n\n        assert(p);\n\n        r = dns_packet_read(p, sizeof(uint16_t), &d, start);\n        if (r < 0)\n                return r;\n\n        *ret = unaligned_read_be16(d);\n\n        return 0;\n}\n\nint dns_packet_read_uint32(DnsPacket *p, uint32_t *ret, size_t *start) {\n        const void *d;\n        int r;\n\n        assert(p);\n\n        r = dns_packet_read(p, sizeof(uint32_t), &d, start);\n        if (r < 0)\n                return r;\n\n        *ret = unaligned_read_be32(d);\n\n        return 0;\n}\n\nint dns_packet_read_string(DnsPacket *p, char **ret, size_t *start) {\n        _cleanup_(rewind_dns_packet) DnsPacketRewinder rewinder;\n        const void *d;\n        char *t;\n        uint8_t c;\n        int r;\n\n        assert(p);\n        INIT_REWINDER(rewinder, p);\n\n        r = dns_packet_read_uint8(p, &c, NULL);\n        if (r < 0)\n                return r;\n\n        r = dns_packet_read(p, c, &d, NULL);\n        if (r < 0)\n                return r;\n\n        if (memchr(d, 0, c))\n                return -EBADMSG;\n\n        t = strndup(d, c);\n        if (!t)\n                return -ENOMEM;\n\n        if (!utf8_is_valid(t)) {\n                free(t);\n                return -EBADMSG;\n        }\n\n        *ret = t;\n\n        if (start)\n                *start = rewinder.saved_rindex;\n        CANCEL_REWINDER(rewinder);\n\n        return 0;\n}\n\nint dns_packet_read_raw_string(DnsPacket *p, const void **ret, size_t *size, size_t *start) {\n        _cleanup_(rewind_dns_packet) DnsPacketRewinder rewinder;\n        uint8_t c;\n        int r;\n\n        assert(p);\n        INIT_REWINDER(rewinder, p);\n\n        r = dns_packet_read_uint8(p, &c, NULL);\n        if (r < 0)\n                return r;\n\n        r = dns_packet_read(p, c, ret, NULL);\n        if (r < 0)\n                return r;\n\n        if (size)\n                *size = c;\n        if (start)\n                *start = rewinder.saved_rindex;\n        CANCEL_REWINDER(rewinder);\n\n        return 0;\n}\n\nint dns_packet_read_name(\n                DnsPacket *p,\n                char **_ret,\n                bool allow_compression,\n                size_t *start) {\n\n        _cleanup_(rewind_dns_packet) DnsPacketRewinder rewinder;\n        size_t after_rindex = 0, jump_barrier;\n        _cleanup_free_ char *ret = NULL;\n        size_t n = 0, allocated = 0;\n        bool first = true;\n        int r;\n\n        assert(p);\n        assert(_ret);\n        INIT_REWINDER(rewinder, p);\n        jump_barrier = p->rindex;\n\n        if (p->refuse_compression)\n                allow_compression = false;\n\n        for (;;) {\n                uint8_t c, d;\n\n                r = dns_packet_read_uint8(p, &c, NULL);\n                if (r < 0)\n                        return r;\n\n                if (c == 0)\n                        /* End of name */\n                        break;\n                else if (c <= 63) {\n                        const char *label;\n\n                        /* Literal label */\n                        r = dns_packet_read(p, c, (const void**) &label, NULL);\n                        if (r < 0)\n                                return r;\n\n                        if (!GREEDY_REALLOC(ret, allocated, n + !first + DNS_LABEL_ESCAPED_MAX))\n                                return -ENOMEM;\n\n                        if (first)\n                                first = false;\n                        else\n                                ret[n++] = '.';\n\n                        r = dns_label_escape(label, c, ret + n, DNS_LABEL_ESCAPED_MAX);\n                        if (r < 0)\n                                return r;\n\n                        n += r;\n                        continue;\n                } else if (allow_compression && (c & 0xc0) == 0xc0) {\n                        uint16_t ptr;\n\n                        /* Pointer */\n                        r = dns_packet_read_uint8(p, &d, NULL);\n                        if (r < 0)\n                                return r;\n\n                        ptr = (uint16_t) (c & ~0xc0) << 8 | (uint16_t) d;\n                        if (ptr < DNS_PACKET_HEADER_SIZE || ptr >= jump_barrier)\n                                return -EBADMSG;\n\n                        if (after_rindex == 0)\n                                after_rindex = p->rindex;\n\n                        /* Jumps are limited to a \"prior occurrence\" (RFC-1035 4.1.4) */\n                        jump_barrier = ptr;\n                        p->rindex = ptr;\n                } else\n                        return -EBADMSG;\n        }\n\n        if (!GREEDY_REALLOC(ret, allocated, n + 1))\n                return -ENOMEM;\n\n        ret[n] = 0;\n\n        if (after_rindex != 0)\n                p->rindex= after_rindex;\n\n        *_ret = ret;\n        ret = NULL;\n\n        if (start)\n                *start = rewinder.saved_rindex;\n        CANCEL_REWINDER(rewinder);\n\n        return 0;\n}\n\nstatic int dns_packet_read_type_window(DnsPacket *p, Bitmap **types, size_t *start) {\n        uint8_t window;\n        uint8_t length;\n        const uint8_t *bitmap;\n        uint8_t bit = 0;\n        unsigned i;\n        bool found = false;\n        _cleanup_(rewind_dns_packet) DnsPacketRewinder rewinder;\n        int r;\n\n        assert(p);\n        assert(types);\n        INIT_REWINDER(rewinder, p);\n\n        r = bitmap_ensure_allocated(types);\n        if (r < 0)\n                return r;\n\n        r = dns_packet_read_uint8(p, &window, NULL);\n        if (r < 0)\n                return r;\n\n        r = dns_packet_read_uint8(p, &length, NULL);\n        if (r < 0)\n                return r;\n\n        if (length == 0 || length > 32)\n                return -EBADMSG;\n\n        r = dns_packet_read(p, length, (const void **)&bitmap, NULL);\n        if (r < 0)\n                return r;\n\n        for (i = 0; i < length; i++) {\n                uint8_t bitmask = 1 << 7;\n\n                if (!bitmap[i]) {\n                        found = false;\n                        bit += 8;\n                        continue;\n                }\n\n                found = true;\n\n                while (bitmask) {\n                        if (bitmap[i] & bitmask) {\n                                uint16_t n;\n\n                                n = (uint16_t) window << 8 | (uint16_t) bit;\n\n                                /* Ignore pseudo-types. see RFC4034 section 4.1.2 */\n                                if (dns_type_is_pseudo(n))\n                                        continue;\n\n                                r = bitmap_set(*types, n);\n                                if (r < 0)\n                                        return r;\n                        }\n\n                        bit++;\n                        bitmask >>= 1;\n                }\n        }\n\n        if (!found)\n                return -EBADMSG;\n\n        if (start)\n                *start = rewinder.saved_rindex;\n        CANCEL_REWINDER(rewinder);\n\n        return 0;\n}\n\nstatic int dns_packet_read_type_windows(DnsPacket *p, Bitmap **types, size_t size, size_t *start) {\n        _cleanup_(rewind_dns_packet) DnsPacketRewinder rewinder;\n        int r;\n\n        INIT_REWINDER(rewinder, p);\n\n        while (p->rindex < rewinder.saved_rindex + size) {\n                r = dns_packet_read_type_window(p, types, NULL);\n                if (r < 0)\n                        return r;\n\n                /* don't read past end of current RR */\n                if (p->rindex > rewinder.saved_rindex + size)\n                        return -EBADMSG;\n        }\n\n        if (p->rindex != rewinder.saved_rindex + size)\n                return -EBADMSG;\n\n        if (start)\n                *start = rewinder.saved_rindex;\n        CANCEL_REWINDER(rewinder);\n\n        return 0;\n}\n\nint dns_packet_read_key(DnsPacket *p, DnsResourceKey **ret, bool *ret_cache_flush, size_t *start) {\n        _cleanup_(rewind_dns_packet) DnsPacketRewinder rewinder;\n        _cleanup_free_ char *name = NULL;\n        bool cache_flush = false;\n        uint16_t class, type;\n        DnsResourceKey *key;\n        int r;\n\n        assert(p);\n        assert(ret);\n        INIT_REWINDER(rewinder, p);\n\n        r = dns_packet_read_name(p, &name, true, NULL);\n        if (r < 0)\n                return r;\n\n        r = dns_packet_read_uint16(p, &type, NULL);\n        if (r < 0)\n                return r;\n\n        r = dns_packet_read_uint16(p, &class, NULL);\n        if (r < 0)\n                return r;\n\n        if (p->protocol == DNS_PROTOCOL_MDNS) {\n                /* See RFC6762, Section 10.2 */\n\n                if (type != DNS_TYPE_OPT && (class & MDNS_RR_CACHE_FLUSH)) {\n                        class &= ~MDNS_RR_CACHE_FLUSH;\n                        cache_flush = true;\n                }\n        }\n\n        key = dns_resource_key_new_consume(class, type, name);\n        if (!key)\n                return -ENOMEM;\n\n        name = NULL;\n        *ret = key;\n\n        if (ret_cache_flush)\n                *ret_cache_flush = cache_flush;\n        if (start)\n                *start = rewinder.saved_rindex;\n        CANCEL_REWINDER(rewinder);\n\n        return 0;\n}\n\nstatic bool loc_size_ok(uint8_t size) {\n        uint8_t m = size >> 4, e = size & 0xF;\n\n        return m <= 9 && e <= 9 && (m > 0 || e == 0);\n}\n\nint dns_packet_read_rr(DnsPacket *p, DnsResourceRecord **ret, bool *ret_cache_flush, size_t *start) {\n        _cleanup_(dns_resource_record_unrefp) DnsResourceRecord *rr = NULL;\n        _cleanup_(dns_resource_key_unrefp) DnsResourceKey *key = NULL;\n        _cleanup_(rewind_dns_packet) DnsPacketRewinder rewinder;\n        size_t offset;\n        uint16_t rdlength;\n        bool cache_flush;\n        int r;\n\n        assert(p);\n        assert(ret);\n\n        INIT_REWINDER(rewinder, p);\n\n        r = dns_packet_read_key(p, &key, &cache_flush, NULL);\n        if (r < 0)\n                return r;\n\n        if (!dns_class_is_valid_rr(key->class) || !dns_type_is_valid_rr(key->type))\n                return -EBADMSG;\n\n        rr = dns_resource_record_new(key);\n        if (!rr)\n                return -ENOMEM;\n\n        r = dns_packet_read_uint32(p, &rr->ttl, NULL);\n        if (r < 0)\n                return r;\n\n        /* RFC 2181, Section 8, suggests to\n         * treat a TTL with the MSB set as a zero TTL. */\n        if (rr->ttl & UINT32_C(0x80000000))\n                rr->ttl = 0;\n\n        r = dns_packet_read_uint16(p, &rdlength, NULL);\n        if (r < 0)\n                return r;\n\n        if (p->rindex + rdlength > p->size)\n                return -EBADMSG;\n\n        offset = p->rindex;\n\n        switch (rr->key->type) {\n\n        case DNS_TYPE_SRV:\n                r = dns_packet_read_uint16(p, &rr->srv.priority, NULL);\n                if (r < 0)\n                        return r;\n                r = dns_packet_read_uint16(p, &rr->srv.weight, NULL);\n                if (r < 0)\n                        return r;\n                r = dns_packet_read_uint16(p, &rr->srv.port, NULL);\n                if (r < 0)\n                        return r;\n                r = dns_packet_read_name(p, &rr->srv.name, true, NULL);\n                break;\n\n        case DNS_TYPE_PTR:\n        case DNS_TYPE_NS:\n        case DNS_TYPE_CNAME:\n        case DNS_TYPE_DNAME:\n                r = dns_packet_read_name(p, &rr->ptr.name, true, NULL);\n                break;\n\n        case DNS_TYPE_HINFO:\n                r = dns_packet_read_string(p, &rr->hinfo.cpu, NULL);\n                if (r < 0)\n                        return r;\n\n                r = dns_packet_read_string(p, &rr->hinfo.os, NULL);\n                break;\n\n        case DNS_TYPE_SPF: /* exactly the same as TXT */\n        case DNS_TYPE_TXT:\n                if (rdlength <= 0) {\n                        DnsTxtItem *i;\n                        /* RFC 6763, section 6.1 suggests to treat\n                         * empty TXT RRs as equivalent to a TXT record\n                         * with a single empty string. */\n\n                        i = malloc0(offsetof(DnsTxtItem, data) + 1); /* for safety reasons we add an extra NUL byte */\n                        if (!i)\n                                return -ENOMEM;\n\n                        rr->txt.items = i;\n                } else {\n                        DnsTxtItem *last = NULL;\n\n                        while (p->rindex < offset + rdlength) {\n                                DnsTxtItem *i;\n                                const void *data;\n                                size_t sz;\n\n                                r = dns_packet_read_raw_string(p, &data, &sz, NULL);\n                                if (r < 0)\n                                        return r;\n\n                                i = malloc0(offsetof(DnsTxtItem, data) + sz + 1); /* extra NUL byte at the end */\n                                if (!i)\n                                        return -ENOMEM;\n\n                                memcpy(i->data, data, sz);\n                                i->length = sz;\n\n                                LIST_INSERT_AFTER(items, rr->txt.items, last, i);\n                                last = i;\n                        }\n                }\n\n                r = 0;\n                break;\n\n        case DNS_TYPE_A:\n                r = dns_packet_read_blob(p, &rr->a.in_addr, sizeof(struct in_addr), NULL);\n                break;\n\n        case DNS_TYPE_AAAA:\n                r = dns_packet_read_blob(p, &rr->aaaa.in6_addr, sizeof(struct in6_addr), NULL);\n                break;\n\n        case DNS_TYPE_SOA:\n                r = dns_packet_read_name(p, &rr->soa.mname, true, NULL);\n                if (r < 0)\n                        return r;\n\n                r = dns_packet_read_name(p, &rr->soa.rname, true, NULL);\n                if (r < 0)\n                        return r;\n\n                r = dns_packet_read_uint32(p, &rr->soa.serial, NULL);\n                if (r < 0)\n                        return r;\n\n                r = dns_packet_read_uint32(p, &rr->soa.refresh, NULL);\n                if (r < 0)\n                        return r;\n\n                r = dns_packet_read_uint32(p, &rr->soa.retry, NULL);\n                if (r < 0)\n                        return r;\n\n                r = dns_packet_read_uint32(p, &rr->soa.expire, NULL);\n                if (r < 0)\n                        return r;\n\n                r = dns_packet_read_uint32(p, &rr->soa.minimum, NULL);\n                break;\n\n        case DNS_TYPE_MX:\n                r = dns_packet_read_uint16(p, &rr->mx.priority, NULL);\n                if (r < 0)\n                        return r;\n\n                r = dns_packet_read_name(p, &rr->mx.exchange, true, NULL);\n                break;\n\n        case DNS_TYPE_LOC: {\n                uint8_t t;\n                size_t pos;\n\n                r = dns_packet_read_uint8(p, &t, &pos);\n                if (r < 0)\n                        return r;\n\n                if (t == 0) {\n                        rr->loc.version = t;\n\n                        r = dns_packet_read_uint8(p, &rr->loc.size, NULL);\n                        if (r < 0)\n                                return r;\n\n                        if (!loc_size_ok(rr->loc.size))\n                                return -EBADMSG;\n\n                        r = dns_packet_read_uint8(p, &rr->loc.horiz_pre, NULL);\n                        if (r < 0)\n                                return r;\n\n                        if (!loc_size_ok(rr->loc.horiz_pre))\n                                return -EBADMSG;\n\n                        r = dns_packet_read_uint8(p, &rr->loc.vert_pre, NULL);\n                        if (r < 0)\n                                return r;\n\n                        if (!loc_size_ok(rr->loc.vert_pre))\n                                return -EBADMSG;\n\n                        r = dns_packet_read_uint32(p, &rr->loc.latitude, NULL);\n                        if (r < 0)\n                                return r;\n\n                        r = dns_packet_read_uint32(p, &rr->loc.longitude, NULL);\n                        if (r < 0)\n                                return r;\n\n                        r = dns_packet_read_uint32(p, &rr->loc.altitude, NULL);\n                        if (r < 0)\n                                return r;\n\n                        break;\n                } else {\n                        dns_packet_rewind(p, pos);\n                        rr->unparseable = true;\n                        goto unparseable;\n                }\n        }\n\n        case DNS_TYPE_DS:\n                r = dns_packet_read_uint16(p, &rr->ds.key_tag, NULL);\n                if (r < 0)\n                        return r;\n\n                r = dns_packet_read_uint8(p, &rr->ds.algorithm, NULL);\n                if (r < 0)\n                        return r;\n\n                r = dns_packet_read_uint8(p, &rr->ds.digest_type, NULL);\n                if (r < 0)\n                        return r;\n\n                r = dns_packet_read_memdup(p, rdlength - 4,\n                                           &rr->ds.digest, &rr->ds.digest_size,\n                                           NULL);\n                if (r < 0)\n                        return r;\n\n                if (rr->ds.digest_size <= 0)\n                        /* the accepted size depends on the algorithm, but for now\n                           just ensure that the value is greater than zero */\n                        return -EBADMSG;\n\n                break;\n\n        case DNS_TYPE_SSHFP:\n                r = dns_packet_read_uint8(p, &rr->sshfp.algorithm, NULL);\n                if (r < 0)\n                        return r;\n\n                r = dns_packet_read_uint8(p, &rr->sshfp.fptype, NULL);\n                if (r < 0)\n                        return r;\n\n                r = dns_packet_read_memdup(p, rdlength - 2,\n                                           &rr->sshfp.fingerprint, &rr->sshfp.fingerprint_size,\n                                           NULL);\n\n                if (rr->sshfp.fingerprint_size <= 0)\n                        /* the accepted size depends on the algorithm, but for now\n                           just ensure that the value is greater than zero */\n                        return -EBADMSG;\n\n                break;\n\n        case DNS_TYPE_DNSKEY:\n                r = dns_packet_read_uint16(p, &rr->dnskey.flags, NULL);\n                if (r < 0)\n                        return r;\n\n                r = dns_packet_read_uint8(p, &rr->dnskey.protocol, NULL);\n                if (r < 0)\n                        return r;\n\n                r = dns_packet_read_uint8(p, &rr->dnskey.algorithm, NULL);\n                if (r < 0)\n                        return r;\n\n                r = dns_packet_read_memdup(p, rdlength - 4,\n                                           &rr->dnskey.key, &rr->dnskey.key_size,\n                                           NULL);\n\n                if (rr->dnskey.key_size <= 0)\n                        /* the accepted size depends on the algorithm, but for now\n                           just ensure that the value is greater than zero */\n                        return -EBADMSG;\n\n                break;\n\n        case DNS_TYPE_RRSIG:\n                r = dns_packet_read_uint16(p, &rr->rrsig.type_covered, NULL);\n                if (r < 0)\n                        return r;\n\n                r = dns_packet_read_uint8(p, &rr->rrsig.algorithm, NULL);\n                if (r < 0)\n                        return r;\n\n                r = dns_packet_read_uint8(p, &rr->rrsig.labels, NULL);\n                if (r < 0)\n                        return r;\n\n                r = dns_packet_read_uint32(p, &rr->rrsig.original_ttl, NULL);\n                if (r < 0)\n                        return r;\n\n                r = dns_packet_read_uint32(p, &rr->rrsig.expiration, NULL);\n                if (r < 0)\n                        return r;\n\n                r = dns_packet_read_uint32(p, &rr->rrsig.inception, NULL);\n                if (r < 0)\n                        return r;\n\n                r = dns_packet_read_uint16(p, &rr->rrsig.key_tag, NULL);\n                if (r < 0)\n                        return r;\n\n                r = dns_packet_read_name(p, &rr->rrsig.signer, false, NULL);\n                if (r < 0)\n                        return r;\n\n                r = dns_packet_read_memdup(p, offset + rdlength - p->rindex,\n                                           &rr->rrsig.signature, &rr->rrsig.signature_size,\n                                           NULL);\n\n                if (rr->rrsig.signature_size <= 0)\n                        /* the accepted size depends on the algorithm, but for now\n                           just ensure that the value is greater than zero */\n                        return -EBADMSG;\n\n                break;\n\n        case DNS_TYPE_NSEC: {\n\n                /*\n                 * RFC6762, section 18.14 explictly states mDNS should use name compression.\n                 * This contradicts RFC3845, section 2.1.1\n                 */\n\n                bool allow_compressed = p->protocol == DNS_PROTOCOL_MDNS;\n\n                r = dns_packet_read_name(p, &rr->nsec.next_domain_name, allow_compressed, NULL);\n                if (r < 0)\n                        return r;\n\n                r = dns_packet_read_type_windows(p, &rr->nsec.types, offset + rdlength - p->rindex, NULL);\n\n                /* We accept empty NSEC bitmaps. The bit indicating the presence of the NSEC record itself\n                 * is redundant and in e.g., RFC4956 this fact is used to define a use for NSEC records\n                 * without the NSEC bit set. */\n\n                break;\n        }\n        case DNS_TYPE_NSEC3: {\n                uint8_t size;\n\n                r = dns_packet_read_uint8(p, &rr->nsec3.algorithm, NULL);\n                if (r < 0)\n                        return r;\n\n                r = dns_packet_read_uint8(p, &rr->nsec3.flags, NULL);\n                if (r < 0)\n                        return r;\n\n                r = dns_packet_read_uint16(p, &rr->nsec3.iterations, NULL);\n                if (r < 0)\n                        return r;\n\n                /* this may be zero */\n                r = dns_packet_read_uint8(p, &size, NULL);\n                if (r < 0)\n                        return r;\n\n                r = dns_packet_read_memdup(p, size, &rr->nsec3.salt, &rr->nsec3.salt_size, NULL);\n                if (r < 0)\n                        return r;\n\n                r = dns_packet_read_uint8(p, &size, NULL);\n                if (r < 0)\n                        return r;\n\n                if (size <= 0)\n                        return -EBADMSG;\n\n                r = dns_packet_read_memdup(p, size,\n                                           &rr->nsec3.next_hashed_name, &rr->nsec3.next_hashed_name_size,\n                                           NULL);\n                if (r < 0)\n                        return r;\n\n                r = dns_packet_read_type_windows(p, &rr->nsec3.types, offset + rdlength - p->rindex, NULL);\n\n                /* empty non-terminals can have NSEC3 records, so empty bitmaps are allowed */\n\n                break;\n        }\n\n        case DNS_TYPE_TLSA:\n                r = dns_packet_read_uint8(p, &rr->tlsa.cert_usage, NULL);\n                if (r < 0)\n                        return r;\n\n                r = dns_packet_read_uint8(p, &rr->tlsa.selector, NULL);\n                if (r < 0)\n                        return r;\n\n                r = dns_packet_read_uint8(p, &rr->tlsa.matching_type, NULL);\n                if (r < 0)\n                        return r;\n\n                r = dns_packet_read_memdup(p, rdlength - 3,\n                                           &rr->tlsa.data, &rr->tlsa.data_size,\n                                           NULL);\n\n                if (rr->tlsa.data_size <= 0)\n                        /* the accepted size depends on the algorithm, but for now\n                           just ensure that the value is greater than zero */\n                        return -EBADMSG;\n\n                break;\n\n        case DNS_TYPE_CAA:\n                r = dns_packet_read_uint8(p, &rr->caa.flags, NULL);\n                if (r < 0)\n                        return r;\n\n                r = dns_packet_read_string(p, &rr->caa.tag, NULL);\n                if (r < 0)\n                        return r;\n\n                r = dns_packet_read_memdup(p,\n                                           rdlength + offset - p->rindex,\n                                           &rr->caa.value, &rr->caa.value_size, NULL);\n\n                break;\n\n        case DNS_TYPE_OPT: /* we only care about the header of OPT for now. */\n        case DNS_TYPE_OPENPGPKEY:\n        default:\n        unparseable:\n                r = dns_packet_read_memdup(p, rdlength, &rr->generic.data, &rr->generic.data_size, NULL);\n\n                break;\n        }\n        if (r < 0)\n                return r;\n        if (p->rindex != offset + rdlength)\n                return -EBADMSG;\n\n        *ret = rr;\n        rr = NULL;\n\n        if (ret_cache_flush)\n                *ret_cache_flush = cache_flush;\n        if (start)\n                *start = rewinder.saved_rindex;\n        CANCEL_REWINDER(rewinder);\n\n        return 0;\n}\n\nstatic bool opt_is_good(DnsResourceRecord *rr, bool *rfc6975) {\n        const uint8_t* p;\n        bool found_dau_dhu_n3u = false;\n        size_t l;\n\n        /* Checks whether the specified OPT RR is well-formed and whether it contains RFC6975 data (which is not OK in\n         * a reply). */\n\n        assert(rr);\n        assert(rr->key->type == DNS_TYPE_OPT);\n\n        /* Check that the version is 0 */\n        if (((rr->ttl >> 16) & UINT32_C(0xFF)) != 0) {\n                *rfc6975 = false;\n                return true; /* if it's not version 0, it's OK, but we will ignore the OPT field contents */\n        }\n\n        p = rr->opt.data;\n        l = rr->opt.data_size;\n        while (l > 0) {\n                uint16_t option_code, option_length;\n\n                /* At least four bytes for OPTION-CODE and OPTION-LENGTH are required */\n                if (l < 4U)\n                        return false;\n\n                option_code = unaligned_read_be16(p);\n                option_length = unaligned_read_be16(p + 2);\n\n                if (l < option_length + 4U)\n                        return false;\n\n                /* RFC 6975 DAU, DHU or N3U fields found. */\n                if (IN_SET(option_code, 5, 6, 7))\n                        found_dau_dhu_n3u = true;\n\n                p += option_length + 4U;\n                l -= option_length + 4U;\n        }\n\n        *rfc6975 = found_dau_dhu_n3u;\n        return true;\n}\n\nint dns_packet_extract(DnsPacket *p) {\n        _cleanup_(dns_question_unrefp) DnsQuestion *question = NULL;\n        _cleanup_(dns_answer_unrefp) DnsAnswer *answer = NULL;\n        _cleanup_(rewind_dns_packet) DnsPacketRewinder rewinder = {};\n        unsigned n, i;\n        int r;\n\n        if (p->extracted)\n                return 0;\n\n        INIT_REWINDER(rewinder, p);\n        dns_packet_rewind(p, DNS_PACKET_HEADER_SIZE);\n\n        n = DNS_PACKET_QDCOUNT(p);\n        if (n > 0) {\n                question = dns_question_new(n);\n                if (!question)\n                        return -ENOMEM;\n\n                for (i = 0; i < n; i++) {\n                        _cleanup_(dns_resource_key_unrefp) DnsResourceKey *key = NULL;\n                        bool cache_flush;\n\n                        r = dns_packet_read_key(p, &key, &cache_flush, NULL);\n                        if (r < 0)\n                                return r;\n\n                        if (cache_flush)\n                                return -EBADMSG;\n\n                        if (!dns_type_is_valid_query(key->type))\n                                return -EBADMSG;\n\n                        r = dns_question_add(question, key);\n                        if (r < 0)\n                                return r;\n                }\n        }\n\n        n = DNS_PACKET_RRCOUNT(p);\n        if (n > 0) {\n                _cleanup_(dns_resource_record_unrefp) DnsResourceRecord *previous = NULL;\n                bool bad_opt = false;\n\n                answer = dns_answer_new(n);\n                if (!answer)\n                        return -ENOMEM;\n\n                for (i = 0; i < n; i++) {\n                        _cleanup_(dns_resource_record_unrefp) DnsResourceRecord *rr = NULL;\n                        bool cache_flush = false;\n\n                        r = dns_packet_read_rr(p, &rr, &cache_flush, NULL);\n                        if (r < 0)\n                                return r;\n\n                        /* Try to reduce memory usage a bit */\n                        if (previous)\n                                dns_resource_key_reduce(&rr->key, &previous->key);\n\n                        if (rr->key->type == DNS_TYPE_OPT) {\n                                bool has_rfc6975;\n\n                                if (p->opt || bad_opt) {\n                                        /* Multiple OPT RRs? if so, let's ignore all, because there's something wrong\n                                         * with the server, and if one is valid we wouldn't know which one. */\n                                        log_debug(\"Multiple OPT RRs detected, ignoring all.\");\n                                        bad_opt = true;\n                                        continue;\n                                }\n\n                                if (!dns_name_is_root(dns_resource_key_name(rr->key))) {\n                                        /* If the OPT RR is not owned by the root domain, then it is bad, let's ignore\n                                         * it. */\n                                        log_debug(\"OPT RR is not owned by root domain, ignoring.\");\n                                        bad_opt = true;\n                                        continue;\n                                }\n\n                                if (i < DNS_PACKET_ANCOUNT(p) + DNS_PACKET_NSCOUNT(p)) {\n                                        /* OPT RR is in the wrong section? Some Belkin routers do this. This is a hint\n                                         * the EDNS implementation is borked, like the Belkin one is, hence ignore\n                                         * it. */\n                                        log_debug(\"OPT RR in wrong section, ignoring.\");\n                                        bad_opt = true;\n                                        continue;\n                                }\n\n                                if (!opt_is_good(rr, &has_rfc6975)) {\n                                        log_debug(\"Malformed OPT RR, ignoring.\");\n                                        bad_opt = true;\n                                        continue;\n                                }\n\n                                if (DNS_PACKET_QR(p)) {\n                                        /* Additional checks for responses */\n\n                                        if (!DNS_RESOURCE_RECORD_OPT_VERSION_SUPPORTED(rr)) {\n                                                /* If this is a reply and we don't know the EDNS version then something\n                                                 * is weird... */\n                                                log_debug(\"EDNS version newer that our request, bad server.\");\n                                                return -EBADMSG;\n                                        }\n\n                                        if (has_rfc6975) {\n                                                /* If the OPT RR contains RFC6975 algorithm data, then this is indication that\n                                                 * the server just copied the OPT it got from us (which contained that data)\n                                                 * back into the reply. If so, then it doesn't properly support EDNS, as\n                                                 * RFC6975 makes it very clear that the algorithm data should only be contained\n                                                 * in questions, never in replies. Crappy Belkin routers copy the OPT data for\n                                                 * example, hence let's detect this so that we downgrade early. */\n                                                log_debug(\"OPT RR contained RFC6975 data, ignoring.\");\n                                                bad_opt = true;\n                                                continue;\n                                        }\n                                }\n\n                                p->opt = dns_resource_record_ref(rr);\n                        } else {\n\n                                /* According to RFC 4795, section 2.9. only the RRs from the Answer section shall be\n                                 * cached. Hence mark only those RRs as cacheable by default, but not the ones from the\n                                 * Additional or Authority sections. */\n\n                                r = dns_answer_add(answer, rr, p->ifindex,\n                                                   (i < DNS_PACKET_ANCOUNT(p) ? DNS_ANSWER_CACHEABLE : 0) |\n                                                   (p->protocol == DNS_PROTOCOL_MDNS && !cache_flush ? DNS_ANSWER_SHARED_OWNER : 0));\n                                if (r < 0)\n                                        return r;\n                        }\n\n                        /* Remember this RR, so that we potentically can merge it's ->key object with the next RR. Note\n                         * that we only do this if we actually decided to keep the RR around. */\n                        dns_resource_record_unref(previous);\n                        previous = dns_resource_record_ref(rr);\n                }\n\n                if (bad_opt)\n                        p->opt = dns_resource_record_unref(p->opt);\n        }\n\n        p->question = question;\n        question = NULL;\n\n        p->answer = answer;\n        answer = NULL;\n\n        p->extracted = true;\n\n        /* no CANCEL, always rewind */\n        return 0;\n}\n\nint dns_packet_is_reply_for(DnsPacket *p, const DnsResourceKey *key) {\n        int r;\n\n        assert(p);\n        assert(key);\n\n        /* Checks if the specified packet is a reply for the specified\n         * key and the specified key is the only one in the question\n         * section. */\n\n        if (DNS_PACKET_QR(p) != 1)\n                return 0;\n\n        /* Let's unpack the packet, if that hasn't happened yet. */\n        r = dns_packet_extract(p);\n        if (r < 0)\n                return r;\n\n        if (!p->question)\n                return 0;\n\n        if (p->question->n_keys != 1)\n                return 0;\n\n        return dns_resource_key_equal(p->question->keys[0], key);\n}\n\nstatic const char* const dns_rcode_table[_DNS_RCODE_MAX_DEFINED] = {\n        [DNS_RCODE_SUCCESS] = \"SUCCESS\",\n        [DNS_RCODE_FORMERR] = \"FORMERR\",\n        [DNS_RCODE_SERVFAIL] = \"SERVFAIL\",\n        [DNS_RCODE_NXDOMAIN] = \"NXDOMAIN\",\n        [DNS_RCODE_NOTIMP] = \"NOTIMP\",\n        [DNS_RCODE_REFUSED] = \"REFUSED\",\n        [DNS_RCODE_YXDOMAIN] = \"YXDOMAIN\",\n        [DNS_RCODE_YXRRSET] = \"YRRSET\",\n        [DNS_RCODE_NXRRSET] = \"NXRRSET\",\n        [DNS_RCODE_NOTAUTH] = \"NOTAUTH\",\n        [DNS_RCODE_NOTZONE] = \"NOTZONE\",\n        [DNS_RCODE_BADVERS] = \"BADVERS\",\n        [DNS_RCODE_BADKEY] = \"BADKEY\",\n        [DNS_RCODE_BADTIME] = \"BADTIME\",\n        [DNS_RCODE_BADMODE] = \"BADMODE\",\n        [DNS_RCODE_BADNAME] = \"BADNAME\",\n        [DNS_RCODE_BADALG] = \"BADALG\",\n        [DNS_RCODE_BADTRUNC] = \"BADTRUNC\",\n        [DNS_RCODE_BADCOOKIE] = \"BADCOOKIE\",\n};\nDEFINE_STRING_TABLE_LOOKUP(dns_rcode, int);\n\nstatic const char* const dns_protocol_table[_DNS_PROTOCOL_MAX] = {\n        [DNS_PROTOCOL_DNS] = \"dns\",\n        [DNS_PROTOCOL_MDNS] = \"mdns\",\n        [DNS_PROTOCOL_LLMNR] = \"llmnr\",\n};\nDEFINE_STRING_TABLE_LOOKUP(dns_protocol, DnsProtocol);\n"], "filenames": ["src/resolve/resolved-dns-packet.c"], "buggy_code_start_loc": [2270], "buggy_code_end_loc": [2270], "fixing_code_start_loc": [2271], "fixing_code_end_loc": [2274], "type": "CWE-476", "message": "systemd-resolved through 233 allows remote attackers to cause a denial of service (daemon crash) via a crafted DNS response with an empty question section.", "other": {"cve": {"id": "CVE-2017-9217", "sourceIdentifier": "cve@mitre.org", "published": "2017-05-24T05:29:00.223", "lastModified": "2022-01-31T18:09:21.210", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "systemd-resolved through 233 allows remote attackers to cause a denial of service (daemon crash) via a crafted DNS response with an empty question section."}, {"lang": "es", "value": "systemd-resolved hasta la versi\u00f3n 223 permite a los atacantes remotos provocar una denegaci\u00f3n de servicio (daemon crash) mediante una respuesta DNS manipulada con un secci\u00f3n de preguntas vac\u00eda."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:systemd_project:systemd:*:*:*:*:*:*:*:*", "versionEndIncluding": "233", "matchCriteriaId": "E819026E-9D55-416F-8781-3B8C9C6A1776"}]}]}], "references": [{"url": "http://www.securityfocus.com/bid/98677", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/systemd/systemd/commit/a924f43f30f9c4acaf70618dd2a055f8b0f166be", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/systemd/systemd/pull/5998", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://launchpad.net/bugs/1621396", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/systemd/systemd/commit/a924f43f30f9c4acaf70618dd2a055f8b0f166be"}}