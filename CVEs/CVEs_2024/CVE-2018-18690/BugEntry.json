{"buggy_code": ["/*\n * Copyright (c) 2000-2005 Silicon Graphics, Inc.\n * All Rights Reserved.\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation.\n *\n * This program is distributed in the hope that it would be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write the Free Software Foundation,\n * Inc.,  51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n */\n#include \"xfs.h\"\n#include \"xfs_fs.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_format.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_defer.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trace.h\"\n\n/*\n * xfs_attr.c\n *\n * Provide the external interfaces to manage attribute lists.\n */\n\n/*========================================================================\n * Function prototypes for the kernel.\n *========================================================================*/\n\n/*\n * Internal routines when attribute list fits inside the inode.\n */\nSTATIC int xfs_attr_shortform_addname(xfs_da_args_t *args);\n\n/*\n * Internal routines when attribute list is one block.\n */\nSTATIC int xfs_attr_leaf_get(xfs_da_args_t *args);\nSTATIC int xfs_attr_leaf_addname(xfs_da_args_t *args);\nSTATIC int xfs_attr_leaf_removename(xfs_da_args_t *args);\n\n/*\n * Internal routines when attribute list is more than one block.\n */\nSTATIC int xfs_attr_node_get(xfs_da_args_t *args);\nSTATIC int xfs_attr_node_addname(xfs_da_args_t *args);\nSTATIC int xfs_attr_node_removename(xfs_da_args_t *args);\nSTATIC int xfs_attr_fillstate(xfs_da_state_t *state);\nSTATIC int xfs_attr_refillstate(xfs_da_state_t *state);\n\n\nSTATIC int\nxfs_attr_args_init(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_inode\t*dp,\n\tconst unsigned char\t*name,\n\tint\t\t\tflags)\n{\n\n\tif (!name)\n\t\treturn -EINVAL;\n\n\tmemset(args, 0, sizeof(*args));\n\targs->geo = dp->i_mount->m_attr_geo;\n\targs->whichfork = XFS_ATTR_FORK;\n\targs->dp = dp;\n\targs->flags = flags;\n\targs->name = name;\n\targs->namelen = strlen((const char *)name);\n\tif (args->namelen >= MAXNAMELEN)\n\t\treturn -EFAULT;\t\t/* match IRIX behaviour */\n\n\targs->hashval = xfs_da_hashname(args->name, args->namelen);\n\treturn 0;\n}\n\nint\nxfs_inode_hasattr(\n\tstruct xfs_inode\t*ip)\n{\n\tif (!XFS_IFORK_Q(ip) ||\n\t    (ip->i_d.di_aformat == XFS_DINODE_FMT_EXTENTS &&\n\t     ip->i_d.di_anextents == 0))\n\t\treturn 0;\n\treturn 1;\n}\n\n/*========================================================================\n * Overall external interface routines.\n *========================================================================*/\n\n/* Retrieve an extended attribute and its value.  Must have ilock. */\nint\nxfs_attr_get_ilocked(\n\tstruct xfs_inode\t*ip,\n\tstruct xfs_da_args\t*args)\n{\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\n\tif (!xfs_inode_hasattr(ip))\n\t\treturn -ENOATTR;\n\telse if (ip->i_d.di_aformat == XFS_DINODE_FMT_LOCAL)\n\t\treturn xfs_attr_shortform_getvalue(args);\n\telse if (xfs_bmap_one_block(ip, XFS_ATTR_FORK))\n\t\treturn xfs_attr_leaf_get(args);\n\telse\n\t\treturn xfs_attr_node_get(args);\n}\n\n/* Retrieve an extended attribute by name, and its value. */\nint\nxfs_attr_get(\n\tstruct xfs_inode\t*ip,\n\tconst unsigned char\t*name,\n\tunsigned char\t\t*value,\n\tint\t\t\t*valuelenp,\n\tint\t\t\tflags)\n{\n\tstruct xfs_da_args\targs;\n\tuint\t\t\tlock_mode;\n\tint\t\t\terror;\n\n\tXFS_STATS_INC(ip->i_mount, xs_attr_get);\n\n\tif (XFS_FORCED_SHUTDOWN(ip->i_mount))\n\t\treturn -EIO;\n\n\terror = xfs_attr_args_init(&args, ip, name, flags);\n\tif (error)\n\t\treturn error;\n\n\targs.value = value;\n\targs.valuelen = *valuelenp;\n\t/* Entirely possible to look up a name which doesn't exist */\n\targs.op_flags = XFS_DA_OP_OKNOENT;\n\n\tlock_mode = xfs_ilock_attr_map_shared(ip);\n\terror = xfs_attr_get_ilocked(ip, &args);\n\txfs_iunlock(ip, lock_mode);\n\n\t*valuelenp = args.valuelen;\n\treturn error == -EEXIST ? 0 : error;\n}\n\n/*\n * Calculate how many blocks we need for the new attribute,\n */\nSTATIC int\nxfs_attr_calc_size(\n\tstruct xfs_da_args\t*args,\n\tint\t\t\t*local)\n{\n\tstruct xfs_mount\t*mp = args->dp->i_mount;\n\tint\t\t\tsize;\n\tint\t\t\tnblks;\n\n\t/*\n\t * Determine space new attribute will use, and if it would be\n\t * \"local\" or \"remote\" (note: local != inline).\n\t */\n\tsize = xfs_attr_leaf_newentsize(args, local);\n\tnblks = XFS_DAENTER_SPACE_RES(mp, XFS_ATTR_FORK);\n\tif (*local) {\n\t\tif (size > (args->geo->blksize / 2)) {\n\t\t\t/* Double split possible */\n\t\t\tnblks *= 2;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Out of line attribute, cannot double split, but\n\t\t * make room for the attribute value itself.\n\t\t */\n\t\tuint\tdblocks = xfs_attr3_rmt_blocks(mp, args->valuelen);\n\t\tnblks += dblocks;\n\t\tnblks += XFS_NEXTENTADD_SPACE_RES(mp, dblocks, XFS_ATTR_FORK);\n\t}\n\n\treturn nblks;\n}\n\nint\nxfs_attr_set(\n\tstruct xfs_inode\t*dp,\n\tconst unsigned char\t*name,\n\tunsigned char\t\t*value,\n\tint\t\t\tvaluelen,\n\tint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = dp->i_mount;\n\tstruct xfs_buf\t\t*leaf_bp = NULL;\n\tstruct xfs_da_args\targs;\n\tstruct xfs_defer_ops\tdfops;\n\tstruct xfs_trans_res\ttres;\n\txfs_fsblock_t\t\tfirstblock;\n\tint\t\t\trsvd = (flags & ATTR_ROOT) != 0;\n\tint\t\t\terror, err2, local;\n\n\tXFS_STATS_INC(mp, xs_attr_set);\n\n\tif (XFS_FORCED_SHUTDOWN(dp->i_mount))\n\t\treturn -EIO;\n\n\terror = xfs_attr_args_init(&args, dp, name, flags);\n\tif (error)\n\t\treturn error;\n\n\targs.value = value;\n\targs.valuelen = valuelen;\n\targs.firstblock = &firstblock;\n\targs.dfops = &dfops;\n\targs.op_flags = XFS_DA_OP_ADDNAME | XFS_DA_OP_OKNOENT;\n\targs.total = xfs_attr_calc_size(&args, &local);\n\n\terror = xfs_qm_dqattach(dp, 0);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * If the inode doesn't have an attribute fork, add one.\n\t * (inode must not be locked when we call this routine)\n\t */\n\tif (XFS_IFORK_Q(dp) == 0) {\n\t\tint sf_size = sizeof(xfs_attr_sf_hdr_t) +\n\t\t\tXFS_ATTR_SF_ENTSIZE_BYNAME(args.namelen, valuelen);\n\n\t\terror = xfs_bmap_add_attrfork(dp, sf_size, rsvd);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\ttres.tr_logres = M_RES(mp)->tr_attrsetm.tr_logres +\n\t\t\t M_RES(mp)->tr_attrsetrt.tr_logres * args.total;\n\ttres.tr_logcount = XFS_ATTRSET_LOG_COUNT;\n\ttres.tr_logflags = XFS_TRANS_PERM_LOG_RES;\n\n\t/*\n\t * Root fork attributes can use reserved data blocks for this\n\t * operation if necessary\n\t */\n\terror = xfs_trans_alloc(mp, &tres, args.total, 0,\n\t\t\trsvd ? XFS_TRANS_RESERVE : 0, &args.trans);\n\tif (error)\n\t\treturn error;\n\n\txfs_ilock(dp, XFS_ILOCK_EXCL);\n\terror = xfs_trans_reserve_quota_nblks(args.trans, dp, args.total, 0,\n\t\t\t\trsvd ? XFS_QMOPT_RES_REGBLKS | XFS_QMOPT_FORCE_RES :\n\t\t\t\t       XFS_QMOPT_RES_REGBLKS);\n\tif (error) {\n\t\txfs_iunlock(dp, XFS_ILOCK_EXCL);\n\t\txfs_trans_cancel(args.trans);\n\t\treturn error;\n\t}\n\n\txfs_trans_ijoin(args.trans, dp, 0);\n\n\t/*\n\t * If the attribute list is non-existent or a shortform list,\n\t * upgrade it to a single-leaf-block attribute list.\n\t */\n\tif (dp->i_d.di_aformat == XFS_DINODE_FMT_LOCAL ||\n\t    (dp->i_d.di_aformat == XFS_DINODE_FMT_EXTENTS &&\n\t     dp->i_d.di_anextents == 0)) {\n\n\t\t/*\n\t\t * Build initial attribute list (if required).\n\t\t */\n\t\tif (dp->i_d.di_aformat == XFS_DINODE_FMT_EXTENTS)\n\t\t\txfs_attr_shortform_create(&args);\n\n\t\t/*\n\t\t * Try to add the attr to the attribute list in\n\t\t * the inode.\n\t\t */\n\t\terror = xfs_attr_shortform_addname(&args);\n\t\tif (error != -ENOSPC) {\n\t\t\t/*\n\t\t\t * Commit the shortform mods, and we're done.\n\t\t\t * NOTE: this is also the error path (EEXIST, etc).\n\t\t\t */\n\t\t\tASSERT(args.trans != NULL);\n\n\t\t\t/*\n\t\t\t * If this is a synchronous mount, make sure that\n\t\t\t * the transaction goes to disk before returning\n\t\t\t * to the user.\n\t\t\t */\n\t\t\tif (mp->m_flags & XFS_MOUNT_WSYNC)\n\t\t\t\txfs_trans_set_sync(args.trans);\n\n\t\t\tif (!error && (flags & ATTR_KERNOTIME) == 0) {\n\t\t\t\txfs_trans_ichgtime(args.trans, dp,\n\t\t\t\t\t\t\tXFS_ICHGTIME_CHG);\n\t\t\t}\n\t\t\terr2 = xfs_trans_commit(args.trans);\n\t\t\txfs_iunlock(dp, XFS_ILOCK_EXCL);\n\n\t\t\treturn error ? error : err2;\n\t\t}\n\n\t\t/*\n\t\t * It won't fit in the shortform, transform to a leaf block.\n\t\t * GROT: another possible req'mt for a double-split btree op.\n\t\t */\n\t\txfs_defer_init(args.dfops, args.firstblock);\n\t\terror = xfs_attr_shortform_to_leaf(&args, &leaf_bp);\n\t\tif (error)\n\t\t\tgoto out_defer_cancel;\n\t\t/*\n\t\t * Prevent the leaf buffer from being unlocked so that a\n\t\t * concurrent AIL push cannot grab the half-baked leaf\n\t\t * buffer and run into problems with the write verifier.\n\t\t */\n\t\txfs_trans_bhold(args.trans, leaf_bp);\n\t\txfs_defer_bjoin(args.dfops, leaf_bp);\n\t\txfs_defer_ijoin(args.dfops, dp);\n\t\terror = xfs_defer_finish(&args.trans, args.dfops);\n\t\tif (error)\n\t\t\tgoto out_defer_cancel;\n\n\t\t/*\n\t\t * Commit the leaf transformation.  We'll need another (linked)\n\t\t * transaction to add the new attribute to the leaf, which\n\t\t * means that we have to hold & join the leaf buffer here too.\n\t\t */\n\t\terror = xfs_trans_roll_inode(&args.trans, dp);\n\t\tif (error)\n\t\t\tgoto out;\n\t\txfs_trans_bjoin(args.trans, leaf_bp);\n\t\tleaf_bp = NULL;\n\t}\n\n\tif (xfs_bmap_one_block(dp, XFS_ATTR_FORK))\n\t\terror = xfs_attr_leaf_addname(&args);\n\telse\n\t\terror = xfs_attr_node_addname(&args);\n\tif (error)\n\t\tgoto out;\n\n\t/*\n\t * If this is a synchronous mount, make sure that the\n\t * transaction goes to disk before returning to the user.\n\t */\n\tif (mp->m_flags & XFS_MOUNT_WSYNC)\n\t\txfs_trans_set_sync(args.trans);\n\n\tif ((flags & ATTR_KERNOTIME) == 0)\n\t\txfs_trans_ichgtime(args.trans, dp, XFS_ICHGTIME_CHG);\n\n\t/*\n\t * Commit the last in the sequence of transactions.\n\t */\n\txfs_trans_log_inode(args.trans, dp, XFS_ILOG_CORE);\n\terror = xfs_trans_commit(args.trans);\n\txfs_iunlock(dp, XFS_ILOCK_EXCL);\n\n\treturn error;\n\nout_defer_cancel:\n\txfs_defer_cancel(&dfops);\nout:\n\tif (leaf_bp)\n\t\txfs_trans_brelse(args.trans, leaf_bp);\n\tif (args.trans)\n\t\txfs_trans_cancel(args.trans);\n\txfs_iunlock(dp, XFS_ILOCK_EXCL);\n\treturn error;\n}\n\n/*\n * Generic handler routine to remove a name from an attribute list.\n * Transitions attribute list from Btree to shortform as necessary.\n */\nint\nxfs_attr_remove(\n\tstruct xfs_inode\t*dp,\n\tconst unsigned char\t*name,\n\tint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = dp->i_mount;\n\tstruct xfs_da_args\targs;\n\tstruct xfs_defer_ops\tdfops;\n\txfs_fsblock_t\t\tfirstblock;\n\tint\t\t\terror;\n\n\tXFS_STATS_INC(mp, xs_attr_remove);\n\n\tif (XFS_FORCED_SHUTDOWN(dp->i_mount))\n\t\treturn -EIO;\n\n\terror = xfs_attr_args_init(&args, dp, name, flags);\n\tif (error)\n\t\treturn error;\n\n\targs.firstblock = &firstblock;\n\targs.dfops = &dfops;\n\n\t/*\n\t * we have no control over the attribute names that userspace passes us\n\t * to remove, so we have to allow the name lookup prior to attribute\n\t * removal to fail.\n\t */\n\targs.op_flags = XFS_DA_OP_OKNOENT;\n\n\terror = xfs_qm_dqattach(dp, 0);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * Root fork attributes can use reserved data blocks for this\n\t * operation if necessary\n\t */\n\terror = xfs_trans_alloc(mp, &M_RES(mp)->tr_attrrm,\n\t\t\tXFS_ATTRRM_SPACE_RES(mp), 0,\n\t\t\t(flags & ATTR_ROOT) ? XFS_TRANS_RESERVE : 0,\n\t\t\t&args.trans);\n\tif (error)\n\t\treturn error;\n\n\txfs_ilock(dp, XFS_ILOCK_EXCL);\n\t/*\n\t * No need to make quota reservations here. We expect to release some\n\t * blocks not allocate in the common case.\n\t */\n\txfs_trans_ijoin(args.trans, dp, 0);\n\n\tif (!xfs_inode_hasattr(dp)) {\n\t\terror = -ENOATTR;\n\t} else if (dp->i_d.di_aformat == XFS_DINODE_FMT_LOCAL) {\n\t\tASSERT(dp->i_afp->if_flags & XFS_IFINLINE);\n\t\terror = xfs_attr_shortform_remove(&args);\n\t} else if (xfs_bmap_one_block(dp, XFS_ATTR_FORK)) {\n\t\terror = xfs_attr_leaf_removename(&args);\n\t} else {\n\t\terror = xfs_attr_node_removename(&args);\n\t}\n\n\tif (error)\n\t\tgoto out;\n\n\t/*\n\t * If this is a synchronous mount, make sure that the\n\t * transaction goes to disk before returning to the user.\n\t */\n\tif (mp->m_flags & XFS_MOUNT_WSYNC)\n\t\txfs_trans_set_sync(args.trans);\n\n\tif ((flags & ATTR_KERNOTIME) == 0)\n\t\txfs_trans_ichgtime(args.trans, dp, XFS_ICHGTIME_CHG);\n\n\t/*\n\t * Commit the last in the sequence of transactions.\n\t */\n\txfs_trans_log_inode(args.trans, dp, XFS_ILOG_CORE);\n\terror = xfs_trans_commit(args.trans);\n\txfs_iunlock(dp, XFS_ILOCK_EXCL);\n\n\treturn error;\n\nout:\n\tif (args.trans)\n\t\txfs_trans_cancel(args.trans);\n\txfs_iunlock(dp, XFS_ILOCK_EXCL);\n\treturn error;\n}\n\n/*========================================================================\n * External routines when attribute list is inside the inode\n *========================================================================*/\n\n/*\n * Add a name to the shortform attribute list structure\n * This is the external routine.\n */\nSTATIC int\nxfs_attr_shortform_addname(xfs_da_args_t *args)\n{\n\tint newsize, forkoff, retval;\n\n\ttrace_xfs_attr_sf_addname(args);\n\n\tretval = xfs_attr_shortform_lookup(args);\n\tif ((args->flags & ATTR_REPLACE) && (retval == -ENOATTR)) {\n\t\treturn retval;\n\t} else if (retval == -EEXIST) {\n\t\tif (args->flags & ATTR_CREATE)\n\t\t\treturn retval;\n\t\tretval = xfs_attr_shortform_remove(args);\n\t\tASSERT(retval == 0);\n\t}\n\n\tif (args->namelen >= XFS_ATTR_SF_ENTSIZE_MAX ||\n\t    args->valuelen >= XFS_ATTR_SF_ENTSIZE_MAX)\n\t\treturn -ENOSPC;\n\n\tnewsize = XFS_ATTR_SF_TOTSIZE(args->dp);\n\tnewsize += XFS_ATTR_SF_ENTSIZE_BYNAME(args->namelen, args->valuelen);\n\n\tforkoff = xfs_attr_shortform_bytesfit(args->dp, newsize);\n\tif (!forkoff)\n\t\treturn -ENOSPC;\n\n\txfs_attr_shortform_add(args, forkoff);\n\treturn 0;\n}\n\n\n/*========================================================================\n * External routines when attribute list is one block\n *========================================================================*/\n\n/*\n * Add a name to the leaf attribute list structure\n *\n * This leaf block cannot have a \"remote\" value, we only call this routine\n * if bmap_one_block() says there is only one block (ie: no remote blks).\n */\nSTATIC int\nxfs_attr_leaf_addname(xfs_da_args_t *args)\n{\n\txfs_inode_t *dp;\n\tstruct xfs_buf *bp;\n\tint retval, error, forkoff;\n\n\ttrace_xfs_attr_leaf_addname(args);\n\n\t/*\n\t * Read the (only) block in the attribute list in.\n\t */\n\tdp = args->dp;\n\targs->blkno = 0;\n\terror = xfs_attr3_leaf_read(args->trans, args->dp, args->blkno, -1, &bp);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * Look up the given attribute in the leaf block.  Figure out if\n\t * the given flags produce an error or call for an atomic rename.\n\t */\n\tretval = xfs_attr3_leaf_lookup_int(bp, args);\n\tif ((args->flags & ATTR_REPLACE) && (retval == -ENOATTR)) {\n\t\txfs_trans_brelse(args->trans, bp);\n\t\treturn retval;\n\t} else if (retval == -EEXIST) {\n\t\tif (args->flags & ATTR_CREATE) {\t/* pure create op */\n\t\t\txfs_trans_brelse(args->trans, bp);\n\t\t\treturn retval;\n\t\t}\n\n\t\ttrace_xfs_attr_leaf_replace(args);\n\n\t\t/* save the attribute state for later removal*/\n\t\targs->op_flags |= XFS_DA_OP_RENAME;\t/* an atomic rename */\n\t\targs->blkno2 = args->blkno;\t\t/* set 2nd entry info*/\n\t\targs->index2 = args->index;\n\t\targs->rmtblkno2 = args->rmtblkno;\n\t\targs->rmtblkcnt2 = args->rmtblkcnt;\n\t\targs->rmtvaluelen2 = args->rmtvaluelen;\n\n\t\t/*\n\t\t * clear the remote attr state now that it is saved so that the\n\t\t * values reflect the state of the attribute we are about to\n\t\t * add, not the attribute we just found and will remove later.\n\t\t */\n\t\targs->rmtblkno = 0;\n\t\targs->rmtblkcnt = 0;\n\t\targs->rmtvaluelen = 0;\n\t}\n\n\t/*\n\t * Add the attribute to the leaf block, transitioning to a Btree\n\t * if required.\n\t */\n\tretval = xfs_attr3_leaf_add(bp, args);\n\tif (retval == -ENOSPC) {\n\t\t/*\n\t\t * Promote the attribute list to the Btree format, then\n\t\t * Commit that transaction so that the node_addname() call\n\t\t * can manage its own transactions.\n\t\t */\n\t\txfs_defer_init(args->dfops, args->firstblock);\n\t\terror = xfs_attr3_leaf_to_node(args);\n\t\tif (error)\n\t\t\tgoto out_defer_cancel;\n\t\txfs_defer_ijoin(args->dfops, dp);\n\t\terror = xfs_defer_finish(&args->trans, args->dfops);\n\t\tif (error)\n\t\t\tgoto out_defer_cancel;\n\n\t\t/*\n\t\t * Commit the current trans (including the inode) and start\n\t\t * a new one.\n\t\t */\n\t\terror = xfs_trans_roll_inode(&args->trans, dp);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\t/*\n\t\t * Fob the whole rest of the problem off on the Btree code.\n\t\t */\n\t\terror = xfs_attr_node_addname(args);\n\t\treturn error;\n\t}\n\n\t/*\n\t * Commit the transaction that added the attr name so that\n\t * later routines can manage their own transactions.\n\t */\n\terror = xfs_trans_roll_inode(&args->trans, dp);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * If there was an out-of-line value, allocate the blocks we\n\t * identified for its storage and copy the value.  This is done\n\t * after we create the attribute so that we don't overflow the\n\t * maximum size of a transaction and/or hit a deadlock.\n\t */\n\tif (args->rmtblkno > 0) {\n\t\terror = xfs_attr_rmtval_set(args);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/*\n\t * If this is an atomic rename operation, we must \"flip\" the\n\t * incomplete flags on the \"new\" and \"old\" attribute/value pairs\n\t * so that one disappears and one appears atomically.  Then we\n\t * must remove the \"old\" attribute/value pair.\n\t */\n\tif (args->op_flags & XFS_DA_OP_RENAME) {\n\t\t/*\n\t\t * In a separate transaction, set the incomplete flag on the\n\t\t * \"old\" attr and clear the incomplete flag on the \"new\" attr.\n\t\t */\n\t\terror = xfs_attr3_leaf_flipflags(args);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\t/*\n\t\t * Dismantle the \"old\" attribute/value pair by removing\n\t\t * a \"remote\" value (if it exists).\n\t\t */\n\t\targs->index = args->index2;\n\t\targs->blkno = args->blkno2;\n\t\targs->rmtblkno = args->rmtblkno2;\n\t\targs->rmtblkcnt = args->rmtblkcnt2;\n\t\targs->rmtvaluelen = args->rmtvaluelen2;\n\t\tif (args->rmtblkno) {\n\t\t\terror = xfs_attr_rmtval_remove(args);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\n\t\t/*\n\t\t * Read in the block containing the \"old\" attr, then\n\t\t * remove the \"old\" attr from that block (neat, huh!)\n\t\t */\n\t\terror = xfs_attr3_leaf_read(args->trans, args->dp, args->blkno,\n\t\t\t\t\t   -1, &bp);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\txfs_attr3_leaf_remove(bp, args);\n\n\t\t/*\n\t\t * If the result is small enough, shrink it all into the inode.\n\t\t */\n\t\tif ((forkoff = xfs_attr_shortform_allfit(bp, dp))) {\n\t\t\txfs_defer_init(args->dfops, args->firstblock);\n\t\t\terror = xfs_attr3_leaf_to_shortform(bp, args, forkoff);\n\t\t\t/* bp is gone due to xfs_da_shrink_inode */\n\t\t\tif (error)\n\t\t\t\tgoto out_defer_cancel;\n\t\t\txfs_defer_ijoin(args->dfops, dp);\n\t\t\terror = xfs_defer_finish(&args->trans, args->dfops);\n\t\t\tif (error)\n\t\t\t\tgoto out_defer_cancel;\n\t\t}\n\n\t\t/*\n\t\t * Commit the remove and start the next trans in series.\n\t\t */\n\t\terror = xfs_trans_roll_inode(&args->trans, dp);\n\n\t} else if (args->rmtblkno > 0) {\n\t\t/*\n\t\t * Added a \"remote\" value, just clear the incomplete flag.\n\t\t */\n\t\terror = xfs_attr3_leaf_clearflag(args);\n\t}\n\treturn error;\nout_defer_cancel:\n\txfs_defer_cancel(args->dfops);\n\treturn error;\n}\n\n/*\n * Remove a name from the leaf attribute list structure\n *\n * This leaf block cannot have a \"remote\" value, we only call this routine\n * if bmap_one_block() says there is only one block (ie: no remote blks).\n */\nSTATIC int\nxfs_attr_leaf_removename(xfs_da_args_t *args)\n{\n\txfs_inode_t *dp;\n\tstruct xfs_buf *bp;\n\tint error, forkoff;\n\n\ttrace_xfs_attr_leaf_removename(args);\n\n\t/*\n\t * Remove the attribute.\n\t */\n\tdp = args->dp;\n\targs->blkno = 0;\n\terror = xfs_attr3_leaf_read(args->trans, args->dp, args->blkno, -1, &bp);\n\tif (error)\n\t\treturn error;\n\n\terror = xfs_attr3_leaf_lookup_int(bp, args);\n\tif (error == -ENOATTR) {\n\t\txfs_trans_brelse(args->trans, bp);\n\t\treturn error;\n\t}\n\n\txfs_attr3_leaf_remove(bp, args);\n\n\t/*\n\t * If the result is small enough, shrink it all into the inode.\n\t */\n\tif ((forkoff = xfs_attr_shortform_allfit(bp, dp))) {\n\t\txfs_defer_init(args->dfops, args->firstblock);\n\t\terror = xfs_attr3_leaf_to_shortform(bp, args, forkoff);\n\t\t/* bp is gone due to xfs_da_shrink_inode */\n\t\tif (error)\n\t\t\tgoto out_defer_cancel;\n\t\txfs_defer_ijoin(args->dfops, dp);\n\t\terror = xfs_defer_finish(&args->trans, args->dfops);\n\t\tif (error)\n\t\t\tgoto out_defer_cancel;\n\t}\n\treturn 0;\nout_defer_cancel:\n\txfs_defer_cancel(args->dfops);\n\treturn error;\n}\n\n/*\n * Look up a name in a leaf attribute list structure.\n *\n * This leaf block cannot have a \"remote\" value, we only call this routine\n * if bmap_one_block() says there is only one block (ie: no remote blks).\n */\nSTATIC int\nxfs_attr_leaf_get(xfs_da_args_t *args)\n{\n\tstruct xfs_buf *bp;\n\tint error;\n\n\ttrace_xfs_attr_leaf_get(args);\n\n\targs->blkno = 0;\n\terror = xfs_attr3_leaf_read(args->trans, args->dp, args->blkno, -1, &bp);\n\tif (error)\n\t\treturn error;\n\n\terror = xfs_attr3_leaf_lookup_int(bp, args);\n\tif (error != -EEXIST)  {\n\t\txfs_trans_brelse(args->trans, bp);\n\t\treturn error;\n\t}\n\terror = xfs_attr3_leaf_getvalue(bp, args);\n\txfs_trans_brelse(args->trans, bp);\n\tif (!error && (args->rmtblkno > 0) && !(args->flags & ATTR_KERNOVAL)) {\n\t\terror = xfs_attr_rmtval_get(args);\n\t}\n\treturn error;\n}\n\n/*========================================================================\n * External routines when attribute list size > geo->blksize\n *========================================================================*/\n\n/*\n * Add a name to a Btree-format attribute list.\n *\n * This will involve walking down the Btree, and may involve splitting\n * leaf nodes and even splitting intermediate nodes up to and including\n * the root node (a special case of an intermediate node).\n *\n * \"Remote\" attribute values confuse the issue and atomic rename operations\n * add a whole extra layer of confusion on top of that.\n */\nSTATIC int\nxfs_attr_node_addname(xfs_da_args_t *args)\n{\n\txfs_da_state_t *state;\n\txfs_da_state_blk_t *blk;\n\txfs_inode_t *dp;\n\txfs_mount_t *mp;\n\tint retval, error;\n\n\ttrace_xfs_attr_node_addname(args);\n\n\t/*\n\t * Fill in bucket of arguments/results/context to carry around.\n\t */\n\tdp = args->dp;\n\tmp = dp->i_mount;\nrestart:\n\tstate = xfs_da_state_alloc();\n\tstate->args = args;\n\tstate->mp = mp;\n\n\t/*\n\t * Search to see if name already exists, and get back a pointer\n\t * to where it should go.\n\t */\n\terror = xfs_da3_node_lookup_int(state, &retval);\n\tif (error)\n\t\tgoto out;\n\tblk = &state->path.blk[ state->path.active-1 ];\n\tASSERT(blk->magic == XFS_ATTR_LEAF_MAGIC);\n\tif ((args->flags & ATTR_REPLACE) && (retval == -ENOATTR)) {\n\t\tgoto out;\n\t} else if (retval == -EEXIST) {\n\t\tif (args->flags & ATTR_CREATE)\n\t\t\tgoto out;\n\n\t\ttrace_xfs_attr_node_replace(args);\n\n\t\t/* save the attribute state for later removal*/\n\t\targs->op_flags |= XFS_DA_OP_RENAME;\t/* atomic rename op */\n\t\targs->blkno2 = args->blkno;\t\t/* set 2nd entry info*/\n\t\targs->index2 = args->index;\n\t\targs->rmtblkno2 = args->rmtblkno;\n\t\targs->rmtblkcnt2 = args->rmtblkcnt;\n\t\targs->rmtvaluelen2 = args->rmtvaluelen;\n\n\t\t/*\n\t\t * clear the remote attr state now that it is saved so that the\n\t\t * values reflect the state of the attribute we are about to\n\t\t * add, not the attribute we just found and will remove later.\n\t\t */\n\t\targs->rmtblkno = 0;\n\t\targs->rmtblkcnt = 0;\n\t\targs->rmtvaluelen = 0;\n\t}\n\n\tretval = xfs_attr3_leaf_add(blk->bp, state->args);\n\tif (retval == -ENOSPC) {\n\t\tif (state->path.active == 1) {\n\t\t\t/*\n\t\t\t * Its really a single leaf node, but it had\n\t\t\t * out-of-line values so it looked like it *might*\n\t\t\t * have been a b-tree.\n\t\t\t */\n\t\t\txfs_da_state_free(state);\n\t\t\tstate = NULL;\n\t\t\txfs_defer_init(args->dfops, args->firstblock);\n\t\t\terror = xfs_attr3_leaf_to_node(args);\n\t\t\tif (error)\n\t\t\t\tgoto out_defer_cancel;\n\t\t\txfs_defer_ijoin(args->dfops, dp);\n\t\t\terror = xfs_defer_finish(&args->trans, args->dfops);\n\t\t\tif (error)\n\t\t\t\tgoto out_defer_cancel;\n\n\t\t\t/*\n\t\t\t * Commit the node conversion and start the next\n\t\t\t * trans in the chain.\n\t\t\t */\n\t\t\terror = xfs_trans_roll_inode(&args->trans, dp);\n\t\t\tif (error)\n\t\t\t\tgoto out;\n\n\t\t\tgoto restart;\n\t\t}\n\n\t\t/*\n\t\t * Split as many Btree elements as required.\n\t\t * This code tracks the new and old attr's location\n\t\t * in the index/blkno/rmtblkno/rmtblkcnt fields and\n\t\t * in the index2/blkno2/rmtblkno2/rmtblkcnt2 fields.\n\t\t */\n\t\txfs_defer_init(args->dfops, args->firstblock);\n\t\terror = xfs_da3_split(state);\n\t\tif (error)\n\t\t\tgoto out_defer_cancel;\n\t\txfs_defer_ijoin(args->dfops, dp);\n\t\terror = xfs_defer_finish(&args->trans, args->dfops);\n\t\tif (error)\n\t\t\tgoto out_defer_cancel;\n\t} else {\n\t\t/*\n\t\t * Addition succeeded, update Btree hashvals.\n\t\t */\n\t\txfs_da3_fixhashpath(state, &state->path);\n\t}\n\n\t/*\n\t * Kill the state structure, we're done with it and need to\n\t * allow the buffers to come back later.\n\t */\n\txfs_da_state_free(state);\n\tstate = NULL;\n\n\t/*\n\t * Commit the leaf addition or btree split and start the next\n\t * trans in the chain.\n\t */\n\terror = xfs_trans_roll_inode(&args->trans, dp);\n\tif (error)\n\t\tgoto out;\n\n\t/*\n\t * If there was an out-of-line value, allocate the blocks we\n\t * identified for its storage and copy the value.  This is done\n\t * after we create the attribute so that we don't overflow the\n\t * maximum size of a transaction and/or hit a deadlock.\n\t */\n\tif (args->rmtblkno > 0) {\n\t\terror = xfs_attr_rmtval_set(args);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/*\n\t * If this is an atomic rename operation, we must \"flip\" the\n\t * incomplete flags on the \"new\" and \"old\" attribute/value pairs\n\t * so that one disappears and one appears atomically.  Then we\n\t * must remove the \"old\" attribute/value pair.\n\t */\n\tif (args->op_flags & XFS_DA_OP_RENAME) {\n\t\t/*\n\t\t * In a separate transaction, set the incomplete flag on the\n\t\t * \"old\" attr and clear the incomplete flag on the \"new\" attr.\n\t\t */\n\t\terror = xfs_attr3_leaf_flipflags(args);\n\t\tif (error)\n\t\t\tgoto out;\n\n\t\t/*\n\t\t * Dismantle the \"old\" attribute/value pair by removing\n\t\t * a \"remote\" value (if it exists).\n\t\t */\n\t\targs->index = args->index2;\n\t\targs->blkno = args->blkno2;\n\t\targs->rmtblkno = args->rmtblkno2;\n\t\targs->rmtblkcnt = args->rmtblkcnt2;\n\t\targs->rmtvaluelen = args->rmtvaluelen2;\n\t\tif (args->rmtblkno) {\n\t\t\terror = xfs_attr_rmtval_remove(args);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\n\t\t/*\n\t\t * Re-find the \"old\" attribute entry after any split ops.\n\t\t * The INCOMPLETE flag means that we will find the \"old\"\n\t\t * attr, not the \"new\" one.\n\t\t */\n\t\targs->flags |= XFS_ATTR_INCOMPLETE;\n\t\tstate = xfs_da_state_alloc();\n\t\tstate->args = args;\n\t\tstate->mp = mp;\n\t\tstate->inleaf = 0;\n\t\terror = xfs_da3_node_lookup_int(state, &retval);\n\t\tif (error)\n\t\t\tgoto out;\n\n\t\t/*\n\t\t * Remove the name and update the hashvals in the tree.\n\t\t */\n\t\tblk = &state->path.blk[ state->path.active-1 ];\n\t\tASSERT(blk->magic == XFS_ATTR_LEAF_MAGIC);\n\t\terror = xfs_attr3_leaf_remove(blk->bp, args);\n\t\txfs_da3_fixhashpath(state, &state->path);\n\n\t\t/*\n\t\t * Check to see if the tree needs to be collapsed.\n\t\t */\n\t\tif (retval && (state->path.active > 1)) {\n\t\t\txfs_defer_init(args->dfops, args->firstblock);\n\t\t\terror = xfs_da3_join(state);\n\t\t\tif (error)\n\t\t\t\tgoto out_defer_cancel;\n\t\t\txfs_defer_ijoin(args->dfops, dp);\n\t\t\terror = xfs_defer_finish(&args->trans, args->dfops);\n\t\t\tif (error)\n\t\t\t\tgoto out_defer_cancel;\n\t\t}\n\n\t\t/*\n\t\t * Commit and start the next trans in the chain.\n\t\t */\n\t\terror = xfs_trans_roll_inode(&args->trans, dp);\n\t\tif (error)\n\t\t\tgoto out;\n\n\t} else if (args->rmtblkno > 0) {\n\t\t/*\n\t\t * Added a \"remote\" value, just clear the incomplete flag.\n\t\t */\n\t\terror = xfs_attr3_leaf_clearflag(args);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\tretval = error = 0;\n\nout:\n\tif (state)\n\t\txfs_da_state_free(state);\n\tif (error)\n\t\treturn error;\n\treturn retval;\nout_defer_cancel:\n\txfs_defer_cancel(args->dfops);\n\tgoto out;\n}\n\n/*\n * Remove a name from a B-tree attribute list.\n *\n * This will involve walking down the Btree, and may involve joining\n * leaf nodes and even joining intermediate nodes up to and including\n * the root node (a special case of an intermediate node).\n */\nSTATIC int\nxfs_attr_node_removename(xfs_da_args_t *args)\n{\n\txfs_da_state_t *state;\n\txfs_da_state_blk_t *blk;\n\txfs_inode_t *dp;\n\tstruct xfs_buf *bp;\n\tint retval, error, forkoff;\n\n\ttrace_xfs_attr_node_removename(args);\n\n\t/*\n\t * Tie a string around our finger to remind us where we are.\n\t */\n\tdp = args->dp;\n\tstate = xfs_da_state_alloc();\n\tstate->args = args;\n\tstate->mp = dp->i_mount;\n\n\t/*\n\t * Search to see if name exists, and get back a pointer to it.\n\t */\n\terror = xfs_da3_node_lookup_int(state, &retval);\n\tif (error || (retval != -EEXIST)) {\n\t\tif (error == 0)\n\t\t\terror = retval;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * If there is an out-of-line value, de-allocate the blocks.\n\t * This is done before we remove the attribute so that we don't\n\t * overflow the maximum size of a transaction and/or hit a deadlock.\n\t */\n\tblk = &state->path.blk[ state->path.active-1 ];\n\tASSERT(blk->bp != NULL);\n\tASSERT(blk->magic == XFS_ATTR_LEAF_MAGIC);\n\tif (args->rmtblkno > 0) {\n\t\t/*\n\t\t * Fill in disk block numbers in the state structure\n\t\t * so that we can get the buffers back after we commit\n\t\t * several transactions in the following calls.\n\t\t */\n\t\terror = xfs_attr_fillstate(state);\n\t\tif (error)\n\t\t\tgoto out;\n\n\t\t/*\n\t\t * Mark the attribute as INCOMPLETE, then bunmapi() the\n\t\t * remote value.\n\t\t */\n\t\terror = xfs_attr3_leaf_setflag(args);\n\t\tif (error)\n\t\t\tgoto out;\n\t\terror = xfs_attr_rmtval_remove(args);\n\t\tif (error)\n\t\t\tgoto out;\n\n\t\t/*\n\t\t * Refill the state structure with buffers, the prior calls\n\t\t * released our buffers.\n\t\t */\n\t\terror = xfs_attr_refillstate(state);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t * Remove the name and update the hashvals in the tree.\n\t */\n\tblk = &state->path.blk[ state->path.active-1 ];\n\tASSERT(blk->magic == XFS_ATTR_LEAF_MAGIC);\n\tretval = xfs_attr3_leaf_remove(blk->bp, args);\n\txfs_da3_fixhashpath(state, &state->path);\n\n\t/*\n\t * Check to see if the tree needs to be collapsed.\n\t */\n\tif (retval && (state->path.active > 1)) {\n\t\txfs_defer_init(args->dfops, args->firstblock);\n\t\terror = xfs_da3_join(state);\n\t\tif (error)\n\t\t\tgoto out_defer_cancel;\n\t\txfs_defer_ijoin(args->dfops, dp);\n\t\terror = xfs_defer_finish(&args->trans, args->dfops);\n\t\tif (error)\n\t\t\tgoto out_defer_cancel;\n\t\t/*\n\t\t * Commit the Btree join operation and start a new trans.\n\t\t */\n\t\terror = xfs_trans_roll_inode(&args->trans, dp);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t * If the result is small enough, push it all into the inode.\n\t */\n\tif (xfs_bmap_one_block(dp, XFS_ATTR_FORK)) {\n\t\t/*\n\t\t * Have to get rid of the copy of this dabuf in the state.\n\t\t */\n\t\tASSERT(state->path.active == 1);\n\t\tASSERT(state->path.blk[0].bp);\n\t\tstate->path.blk[0].bp = NULL;\n\n\t\terror = xfs_attr3_leaf_read(args->trans, args->dp, 0, -1, &bp);\n\t\tif (error)\n\t\t\tgoto out;\n\n\t\tif ((forkoff = xfs_attr_shortform_allfit(bp, dp))) {\n\t\t\txfs_defer_init(args->dfops, args->firstblock);\n\t\t\terror = xfs_attr3_leaf_to_shortform(bp, args, forkoff);\n\t\t\t/* bp is gone due to xfs_da_shrink_inode */\n\t\t\tif (error)\n\t\t\t\tgoto out_defer_cancel;\n\t\t\txfs_defer_ijoin(args->dfops, dp);\n\t\t\terror = xfs_defer_finish(&args->trans, args->dfops);\n\t\t\tif (error)\n\t\t\t\tgoto out_defer_cancel;\n\t\t} else\n\t\t\txfs_trans_brelse(args->trans, bp);\n\t}\n\terror = 0;\n\nout:\n\txfs_da_state_free(state);\n\treturn error;\nout_defer_cancel:\n\txfs_defer_cancel(args->dfops);\n\tgoto out;\n}\n\n/*\n * Fill in the disk block numbers in the state structure for the buffers\n * that are attached to the state structure.\n * This is done so that we can quickly reattach ourselves to those buffers\n * after some set of transaction commits have released these buffers.\n */\nSTATIC int\nxfs_attr_fillstate(xfs_da_state_t *state)\n{\n\txfs_da_state_path_t *path;\n\txfs_da_state_blk_t *blk;\n\tint level;\n\n\ttrace_xfs_attr_fillstate(state->args);\n\n\t/*\n\t * Roll down the \"path\" in the state structure, storing the on-disk\n\t * block number for those buffers in the \"path\".\n\t */\n\tpath = &state->path;\n\tASSERT((path->active >= 0) && (path->active < XFS_DA_NODE_MAXDEPTH));\n\tfor (blk = path->blk, level = 0; level < path->active; blk++, level++) {\n\t\tif (blk->bp) {\n\t\t\tblk->disk_blkno = XFS_BUF_ADDR(blk->bp);\n\t\t\tblk->bp = NULL;\n\t\t} else {\n\t\t\tblk->disk_blkno = 0;\n\t\t}\n\t}\n\n\t/*\n\t * Roll down the \"altpath\" in the state structure, storing the on-disk\n\t * block number for those buffers in the \"altpath\".\n\t */\n\tpath = &state->altpath;\n\tASSERT((path->active >= 0) && (path->active < XFS_DA_NODE_MAXDEPTH));\n\tfor (blk = path->blk, level = 0; level < path->active; blk++, level++) {\n\t\tif (blk->bp) {\n\t\t\tblk->disk_blkno = XFS_BUF_ADDR(blk->bp);\n\t\t\tblk->bp = NULL;\n\t\t} else {\n\t\t\tblk->disk_blkno = 0;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n/*\n * Reattach the buffers to the state structure based on the disk block\n * numbers stored in the state structure.\n * This is done after some set of transaction commits have released those\n * buffers from our grip.\n */\nSTATIC int\nxfs_attr_refillstate(xfs_da_state_t *state)\n{\n\txfs_da_state_path_t *path;\n\txfs_da_state_blk_t *blk;\n\tint level, error;\n\n\ttrace_xfs_attr_refillstate(state->args);\n\n\t/*\n\t * Roll down the \"path\" in the state structure, storing the on-disk\n\t * block number for those buffers in the \"path\".\n\t */\n\tpath = &state->path;\n\tASSERT((path->active >= 0) && (path->active < XFS_DA_NODE_MAXDEPTH));\n\tfor (blk = path->blk, level = 0; level < path->active; blk++, level++) {\n\t\tif (blk->disk_blkno) {\n\t\t\terror = xfs_da3_node_read(state->args->trans,\n\t\t\t\t\t\tstate->args->dp,\n\t\t\t\t\t\tblk->blkno, blk->disk_blkno,\n\t\t\t\t\t\t&blk->bp, XFS_ATTR_FORK);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t} else {\n\t\t\tblk->bp = NULL;\n\t\t}\n\t}\n\n\t/*\n\t * Roll down the \"altpath\" in the state structure, storing the on-disk\n\t * block number for those buffers in the \"altpath\".\n\t */\n\tpath = &state->altpath;\n\tASSERT((path->active >= 0) && (path->active < XFS_DA_NODE_MAXDEPTH));\n\tfor (blk = path->blk, level = 0; level < path->active; blk++, level++) {\n\t\tif (blk->disk_blkno) {\n\t\t\terror = xfs_da3_node_read(state->args->trans,\n\t\t\t\t\t\tstate->args->dp,\n\t\t\t\t\t\tblk->blkno, blk->disk_blkno,\n\t\t\t\t\t\t&blk->bp, XFS_ATTR_FORK);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t} else {\n\t\t\tblk->bp = NULL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n/*\n * Look up a filename in a node attribute list.\n *\n * This routine gets called for any attribute fork that has more than one\n * block, ie: both true Btree attr lists and for single-leaf-blocks with\n * \"remote\" values taking up more blocks.\n */\nSTATIC int\nxfs_attr_node_get(xfs_da_args_t *args)\n{\n\txfs_da_state_t *state;\n\txfs_da_state_blk_t *blk;\n\tint error, retval;\n\tint i;\n\n\ttrace_xfs_attr_node_get(args);\n\n\tstate = xfs_da_state_alloc();\n\tstate->args = args;\n\tstate->mp = args->dp->i_mount;\n\n\t/*\n\t * Search to see if name exists, and get back a pointer to it.\n\t */\n\terror = xfs_da3_node_lookup_int(state, &retval);\n\tif (error) {\n\t\tretval = error;\n\t} else if (retval == -EEXIST) {\n\t\tblk = &state->path.blk[ state->path.active-1 ];\n\t\tASSERT(blk->bp != NULL);\n\t\tASSERT(blk->magic == XFS_ATTR_LEAF_MAGIC);\n\n\t\t/*\n\t\t * Get the value, local or \"remote\"\n\t\t */\n\t\tretval = xfs_attr3_leaf_getvalue(blk->bp, args);\n\t\tif (!retval && (args->rmtblkno > 0)\n\t\t    && !(args->flags & ATTR_KERNOVAL)) {\n\t\t\tretval = xfs_attr_rmtval_get(args);\n\t\t}\n\t}\n\n\t/*\n\t * If not in a transaction, we have to release all the buffers.\n\t */\n\tfor (i = 0; i < state->path.active; i++) {\n\t\txfs_trans_brelse(args->trans, state->path.blk[i].bp);\n\t\tstate->path.blk[i].bp = NULL;\n\t}\n\n\txfs_da_state_free(state);\n\treturn retval;\n}\n"], "fixing_code": ["/*\n * Copyright (c) 2000-2005 Silicon Graphics, Inc.\n * All Rights Reserved.\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation.\n *\n * This program is distributed in the hope that it would be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write the Free Software Foundation,\n * Inc.,  51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n */\n#include \"xfs.h\"\n#include \"xfs_fs.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_format.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_defer.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trace.h\"\n\n/*\n * xfs_attr.c\n *\n * Provide the external interfaces to manage attribute lists.\n */\n\n/*========================================================================\n * Function prototypes for the kernel.\n *========================================================================*/\n\n/*\n * Internal routines when attribute list fits inside the inode.\n */\nSTATIC int xfs_attr_shortform_addname(xfs_da_args_t *args);\n\n/*\n * Internal routines when attribute list is one block.\n */\nSTATIC int xfs_attr_leaf_get(xfs_da_args_t *args);\nSTATIC int xfs_attr_leaf_addname(xfs_da_args_t *args);\nSTATIC int xfs_attr_leaf_removename(xfs_da_args_t *args);\n\n/*\n * Internal routines when attribute list is more than one block.\n */\nSTATIC int xfs_attr_node_get(xfs_da_args_t *args);\nSTATIC int xfs_attr_node_addname(xfs_da_args_t *args);\nSTATIC int xfs_attr_node_removename(xfs_da_args_t *args);\nSTATIC int xfs_attr_fillstate(xfs_da_state_t *state);\nSTATIC int xfs_attr_refillstate(xfs_da_state_t *state);\n\n\nSTATIC int\nxfs_attr_args_init(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_inode\t*dp,\n\tconst unsigned char\t*name,\n\tint\t\t\tflags)\n{\n\n\tif (!name)\n\t\treturn -EINVAL;\n\n\tmemset(args, 0, sizeof(*args));\n\targs->geo = dp->i_mount->m_attr_geo;\n\targs->whichfork = XFS_ATTR_FORK;\n\targs->dp = dp;\n\targs->flags = flags;\n\targs->name = name;\n\targs->namelen = strlen((const char *)name);\n\tif (args->namelen >= MAXNAMELEN)\n\t\treturn -EFAULT;\t\t/* match IRIX behaviour */\n\n\targs->hashval = xfs_da_hashname(args->name, args->namelen);\n\treturn 0;\n}\n\nint\nxfs_inode_hasattr(\n\tstruct xfs_inode\t*ip)\n{\n\tif (!XFS_IFORK_Q(ip) ||\n\t    (ip->i_d.di_aformat == XFS_DINODE_FMT_EXTENTS &&\n\t     ip->i_d.di_anextents == 0))\n\t\treturn 0;\n\treturn 1;\n}\n\n/*========================================================================\n * Overall external interface routines.\n *========================================================================*/\n\n/* Retrieve an extended attribute and its value.  Must have ilock. */\nint\nxfs_attr_get_ilocked(\n\tstruct xfs_inode\t*ip,\n\tstruct xfs_da_args\t*args)\n{\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\n\tif (!xfs_inode_hasattr(ip))\n\t\treturn -ENOATTR;\n\telse if (ip->i_d.di_aformat == XFS_DINODE_FMT_LOCAL)\n\t\treturn xfs_attr_shortform_getvalue(args);\n\telse if (xfs_bmap_one_block(ip, XFS_ATTR_FORK))\n\t\treturn xfs_attr_leaf_get(args);\n\telse\n\t\treturn xfs_attr_node_get(args);\n}\n\n/* Retrieve an extended attribute by name, and its value. */\nint\nxfs_attr_get(\n\tstruct xfs_inode\t*ip,\n\tconst unsigned char\t*name,\n\tunsigned char\t\t*value,\n\tint\t\t\t*valuelenp,\n\tint\t\t\tflags)\n{\n\tstruct xfs_da_args\targs;\n\tuint\t\t\tlock_mode;\n\tint\t\t\terror;\n\n\tXFS_STATS_INC(ip->i_mount, xs_attr_get);\n\n\tif (XFS_FORCED_SHUTDOWN(ip->i_mount))\n\t\treturn -EIO;\n\n\terror = xfs_attr_args_init(&args, ip, name, flags);\n\tif (error)\n\t\treturn error;\n\n\targs.value = value;\n\targs.valuelen = *valuelenp;\n\t/* Entirely possible to look up a name which doesn't exist */\n\targs.op_flags = XFS_DA_OP_OKNOENT;\n\n\tlock_mode = xfs_ilock_attr_map_shared(ip);\n\terror = xfs_attr_get_ilocked(ip, &args);\n\txfs_iunlock(ip, lock_mode);\n\n\t*valuelenp = args.valuelen;\n\treturn error == -EEXIST ? 0 : error;\n}\n\n/*\n * Calculate how many blocks we need for the new attribute,\n */\nSTATIC int\nxfs_attr_calc_size(\n\tstruct xfs_da_args\t*args,\n\tint\t\t\t*local)\n{\n\tstruct xfs_mount\t*mp = args->dp->i_mount;\n\tint\t\t\tsize;\n\tint\t\t\tnblks;\n\n\t/*\n\t * Determine space new attribute will use, and if it would be\n\t * \"local\" or \"remote\" (note: local != inline).\n\t */\n\tsize = xfs_attr_leaf_newentsize(args, local);\n\tnblks = XFS_DAENTER_SPACE_RES(mp, XFS_ATTR_FORK);\n\tif (*local) {\n\t\tif (size > (args->geo->blksize / 2)) {\n\t\t\t/* Double split possible */\n\t\t\tnblks *= 2;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Out of line attribute, cannot double split, but\n\t\t * make room for the attribute value itself.\n\t\t */\n\t\tuint\tdblocks = xfs_attr3_rmt_blocks(mp, args->valuelen);\n\t\tnblks += dblocks;\n\t\tnblks += XFS_NEXTENTADD_SPACE_RES(mp, dblocks, XFS_ATTR_FORK);\n\t}\n\n\treturn nblks;\n}\n\nint\nxfs_attr_set(\n\tstruct xfs_inode\t*dp,\n\tconst unsigned char\t*name,\n\tunsigned char\t\t*value,\n\tint\t\t\tvaluelen,\n\tint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = dp->i_mount;\n\tstruct xfs_buf\t\t*leaf_bp = NULL;\n\tstruct xfs_da_args\targs;\n\tstruct xfs_defer_ops\tdfops;\n\tstruct xfs_trans_res\ttres;\n\txfs_fsblock_t\t\tfirstblock;\n\tint\t\t\trsvd = (flags & ATTR_ROOT) != 0;\n\tint\t\t\terror, err2, local;\n\n\tXFS_STATS_INC(mp, xs_attr_set);\n\n\tif (XFS_FORCED_SHUTDOWN(dp->i_mount))\n\t\treturn -EIO;\n\n\terror = xfs_attr_args_init(&args, dp, name, flags);\n\tif (error)\n\t\treturn error;\n\n\targs.value = value;\n\targs.valuelen = valuelen;\n\targs.firstblock = &firstblock;\n\targs.dfops = &dfops;\n\targs.op_flags = XFS_DA_OP_ADDNAME | XFS_DA_OP_OKNOENT;\n\targs.total = xfs_attr_calc_size(&args, &local);\n\n\terror = xfs_qm_dqattach(dp, 0);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * If the inode doesn't have an attribute fork, add one.\n\t * (inode must not be locked when we call this routine)\n\t */\n\tif (XFS_IFORK_Q(dp) == 0) {\n\t\tint sf_size = sizeof(xfs_attr_sf_hdr_t) +\n\t\t\tXFS_ATTR_SF_ENTSIZE_BYNAME(args.namelen, valuelen);\n\n\t\terror = xfs_bmap_add_attrfork(dp, sf_size, rsvd);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\ttres.tr_logres = M_RES(mp)->tr_attrsetm.tr_logres +\n\t\t\t M_RES(mp)->tr_attrsetrt.tr_logres * args.total;\n\ttres.tr_logcount = XFS_ATTRSET_LOG_COUNT;\n\ttres.tr_logflags = XFS_TRANS_PERM_LOG_RES;\n\n\t/*\n\t * Root fork attributes can use reserved data blocks for this\n\t * operation if necessary\n\t */\n\terror = xfs_trans_alloc(mp, &tres, args.total, 0,\n\t\t\trsvd ? XFS_TRANS_RESERVE : 0, &args.trans);\n\tif (error)\n\t\treturn error;\n\n\txfs_ilock(dp, XFS_ILOCK_EXCL);\n\terror = xfs_trans_reserve_quota_nblks(args.trans, dp, args.total, 0,\n\t\t\t\trsvd ? XFS_QMOPT_RES_REGBLKS | XFS_QMOPT_FORCE_RES :\n\t\t\t\t       XFS_QMOPT_RES_REGBLKS);\n\tif (error) {\n\t\txfs_iunlock(dp, XFS_ILOCK_EXCL);\n\t\txfs_trans_cancel(args.trans);\n\t\treturn error;\n\t}\n\n\txfs_trans_ijoin(args.trans, dp, 0);\n\n\t/*\n\t * If the attribute list is non-existent or a shortform list,\n\t * upgrade it to a single-leaf-block attribute list.\n\t */\n\tif (dp->i_d.di_aformat == XFS_DINODE_FMT_LOCAL ||\n\t    (dp->i_d.di_aformat == XFS_DINODE_FMT_EXTENTS &&\n\t     dp->i_d.di_anextents == 0)) {\n\n\t\t/*\n\t\t * Build initial attribute list (if required).\n\t\t */\n\t\tif (dp->i_d.di_aformat == XFS_DINODE_FMT_EXTENTS)\n\t\t\txfs_attr_shortform_create(&args);\n\n\t\t/*\n\t\t * Try to add the attr to the attribute list in\n\t\t * the inode.\n\t\t */\n\t\terror = xfs_attr_shortform_addname(&args);\n\t\tif (error != -ENOSPC) {\n\t\t\t/*\n\t\t\t * Commit the shortform mods, and we're done.\n\t\t\t * NOTE: this is also the error path (EEXIST, etc).\n\t\t\t */\n\t\t\tASSERT(args.trans != NULL);\n\n\t\t\t/*\n\t\t\t * If this is a synchronous mount, make sure that\n\t\t\t * the transaction goes to disk before returning\n\t\t\t * to the user.\n\t\t\t */\n\t\t\tif (mp->m_flags & XFS_MOUNT_WSYNC)\n\t\t\t\txfs_trans_set_sync(args.trans);\n\n\t\t\tif (!error && (flags & ATTR_KERNOTIME) == 0) {\n\t\t\t\txfs_trans_ichgtime(args.trans, dp,\n\t\t\t\t\t\t\tXFS_ICHGTIME_CHG);\n\t\t\t}\n\t\t\terr2 = xfs_trans_commit(args.trans);\n\t\t\txfs_iunlock(dp, XFS_ILOCK_EXCL);\n\n\t\t\treturn error ? error : err2;\n\t\t}\n\n\t\t/*\n\t\t * It won't fit in the shortform, transform to a leaf block.\n\t\t * GROT: another possible req'mt for a double-split btree op.\n\t\t */\n\t\txfs_defer_init(args.dfops, args.firstblock);\n\t\terror = xfs_attr_shortform_to_leaf(&args, &leaf_bp);\n\t\tif (error)\n\t\t\tgoto out_defer_cancel;\n\t\t/*\n\t\t * Prevent the leaf buffer from being unlocked so that a\n\t\t * concurrent AIL push cannot grab the half-baked leaf\n\t\t * buffer and run into problems with the write verifier.\n\t\t */\n\t\txfs_trans_bhold(args.trans, leaf_bp);\n\t\txfs_defer_bjoin(args.dfops, leaf_bp);\n\t\txfs_defer_ijoin(args.dfops, dp);\n\t\terror = xfs_defer_finish(&args.trans, args.dfops);\n\t\tif (error)\n\t\t\tgoto out_defer_cancel;\n\n\t\t/*\n\t\t * Commit the leaf transformation.  We'll need another (linked)\n\t\t * transaction to add the new attribute to the leaf, which\n\t\t * means that we have to hold & join the leaf buffer here too.\n\t\t */\n\t\terror = xfs_trans_roll_inode(&args.trans, dp);\n\t\tif (error)\n\t\t\tgoto out;\n\t\txfs_trans_bjoin(args.trans, leaf_bp);\n\t\tleaf_bp = NULL;\n\t}\n\n\tif (xfs_bmap_one_block(dp, XFS_ATTR_FORK))\n\t\terror = xfs_attr_leaf_addname(&args);\n\telse\n\t\terror = xfs_attr_node_addname(&args);\n\tif (error)\n\t\tgoto out;\n\n\t/*\n\t * If this is a synchronous mount, make sure that the\n\t * transaction goes to disk before returning to the user.\n\t */\n\tif (mp->m_flags & XFS_MOUNT_WSYNC)\n\t\txfs_trans_set_sync(args.trans);\n\n\tif ((flags & ATTR_KERNOTIME) == 0)\n\t\txfs_trans_ichgtime(args.trans, dp, XFS_ICHGTIME_CHG);\n\n\t/*\n\t * Commit the last in the sequence of transactions.\n\t */\n\txfs_trans_log_inode(args.trans, dp, XFS_ILOG_CORE);\n\terror = xfs_trans_commit(args.trans);\n\txfs_iunlock(dp, XFS_ILOCK_EXCL);\n\n\treturn error;\n\nout_defer_cancel:\n\txfs_defer_cancel(&dfops);\nout:\n\tif (leaf_bp)\n\t\txfs_trans_brelse(args.trans, leaf_bp);\n\tif (args.trans)\n\t\txfs_trans_cancel(args.trans);\n\txfs_iunlock(dp, XFS_ILOCK_EXCL);\n\treturn error;\n}\n\n/*\n * Generic handler routine to remove a name from an attribute list.\n * Transitions attribute list from Btree to shortform as necessary.\n */\nint\nxfs_attr_remove(\n\tstruct xfs_inode\t*dp,\n\tconst unsigned char\t*name,\n\tint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = dp->i_mount;\n\tstruct xfs_da_args\targs;\n\tstruct xfs_defer_ops\tdfops;\n\txfs_fsblock_t\t\tfirstblock;\n\tint\t\t\terror;\n\n\tXFS_STATS_INC(mp, xs_attr_remove);\n\n\tif (XFS_FORCED_SHUTDOWN(dp->i_mount))\n\t\treturn -EIO;\n\n\terror = xfs_attr_args_init(&args, dp, name, flags);\n\tif (error)\n\t\treturn error;\n\n\targs.firstblock = &firstblock;\n\targs.dfops = &dfops;\n\n\t/*\n\t * we have no control over the attribute names that userspace passes us\n\t * to remove, so we have to allow the name lookup prior to attribute\n\t * removal to fail.\n\t */\n\targs.op_flags = XFS_DA_OP_OKNOENT;\n\n\terror = xfs_qm_dqattach(dp, 0);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * Root fork attributes can use reserved data blocks for this\n\t * operation if necessary\n\t */\n\terror = xfs_trans_alloc(mp, &M_RES(mp)->tr_attrrm,\n\t\t\tXFS_ATTRRM_SPACE_RES(mp), 0,\n\t\t\t(flags & ATTR_ROOT) ? XFS_TRANS_RESERVE : 0,\n\t\t\t&args.trans);\n\tif (error)\n\t\treturn error;\n\n\txfs_ilock(dp, XFS_ILOCK_EXCL);\n\t/*\n\t * No need to make quota reservations here. We expect to release some\n\t * blocks not allocate in the common case.\n\t */\n\txfs_trans_ijoin(args.trans, dp, 0);\n\n\tif (!xfs_inode_hasattr(dp)) {\n\t\terror = -ENOATTR;\n\t} else if (dp->i_d.di_aformat == XFS_DINODE_FMT_LOCAL) {\n\t\tASSERT(dp->i_afp->if_flags & XFS_IFINLINE);\n\t\terror = xfs_attr_shortform_remove(&args);\n\t} else if (xfs_bmap_one_block(dp, XFS_ATTR_FORK)) {\n\t\terror = xfs_attr_leaf_removename(&args);\n\t} else {\n\t\terror = xfs_attr_node_removename(&args);\n\t}\n\n\tif (error)\n\t\tgoto out;\n\n\t/*\n\t * If this is a synchronous mount, make sure that the\n\t * transaction goes to disk before returning to the user.\n\t */\n\tif (mp->m_flags & XFS_MOUNT_WSYNC)\n\t\txfs_trans_set_sync(args.trans);\n\n\tif ((flags & ATTR_KERNOTIME) == 0)\n\t\txfs_trans_ichgtime(args.trans, dp, XFS_ICHGTIME_CHG);\n\n\t/*\n\t * Commit the last in the sequence of transactions.\n\t */\n\txfs_trans_log_inode(args.trans, dp, XFS_ILOG_CORE);\n\terror = xfs_trans_commit(args.trans);\n\txfs_iunlock(dp, XFS_ILOCK_EXCL);\n\n\treturn error;\n\nout:\n\tif (args.trans)\n\t\txfs_trans_cancel(args.trans);\n\txfs_iunlock(dp, XFS_ILOCK_EXCL);\n\treturn error;\n}\n\n/*========================================================================\n * External routines when attribute list is inside the inode\n *========================================================================*/\n\n/*\n * Add a name to the shortform attribute list structure\n * This is the external routine.\n */\nSTATIC int\nxfs_attr_shortform_addname(xfs_da_args_t *args)\n{\n\tint newsize, forkoff, retval;\n\n\ttrace_xfs_attr_sf_addname(args);\n\n\tretval = xfs_attr_shortform_lookup(args);\n\tif ((args->flags & ATTR_REPLACE) && (retval == -ENOATTR)) {\n\t\treturn retval;\n\t} else if (retval == -EEXIST) {\n\t\tif (args->flags & ATTR_CREATE)\n\t\t\treturn retval;\n\t\tretval = xfs_attr_shortform_remove(args);\n\t\tif (retval)\n\t\t\treturn retval;\n\t\t/*\n\t\t * Since we have removed the old attr, clear ATTR_REPLACE so\n\t\t * that the leaf format add routine won't trip over the attr\n\t\t * not being around.\n\t\t */\n\t\targs->flags &= ~ATTR_REPLACE;\n\t}\n\n\tif (args->namelen >= XFS_ATTR_SF_ENTSIZE_MAX ||\n\t    args->valuelen >= XFS_ATTR_SF_ENTSIZE_MAX)\n\t\treturn -ENOSPC;\n\n\tnewsize = XFS_ATTR_SF_TOTSIZE(args->dp);\n\tnewsize += XFS_ATTR_SF_ENTSIZE_BYNAME(args->namelen, args->valuelen);\n\n\tforkoff = xfs_attr_shortform_bytesfit(args->dp, newsize);\n\tif (!forkoff)\n\t\treturn -ENOSPC;\n\n\txfs_attr_shortform_add(args, forkoff);\n\treturn 0;\n}\n\n\n/*========================================================================\n * External routines when attribute list is one block\n *========================================================================*/\n\n/*\n * Add a name to the leaf attribute list structure\n *\n * This leaf block cannot have a \"remote\" value, we only call this routine\n * if bmap_one_block() says there is only one block (ie: no remote blks).\n */\nSTATIC int\nxfs_attr_leaf_addname(xfs_da_args_t *args)\n{\n\txfs_inode_t *dp;\n\tstruct xfs_buf *bp;\n\tint retval, error, forkoff;\n\n\ttrace_xfs_attr_leaf_addname(args);\n\n\t/*\n\t * Read the (only) block in the attribute list in.\n\t */\n\tdp = args->dp;\n\targs->blkno = 0;\n\terror = xfs_attr3_leaf_read(args->trans, args->dp, args->blkno, -1, &bp);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * Look up the given attribute in the leaf block.  Figure out if\n\t * the given flags produce an error or call for an atomic rename.\n\t */\n\tretval = xfs_attr3_leaf_lookup_int(bp, args);\n\tif ((args->flags & ATTR_REPLACE) && (retval == -ENOATTR)) {\n\t\txfs_trans_brelse(args->trans, bp);\n\t\treturn retval;\n\t} else if (retval == -EEXIST) {\n\t\tif (args->flags & ATTR_CREATE) {\t/* pure create op */\n\t\t\txfs_trans_brelse(args->trans, bp);\n\t\t\treturn retval;\n\t\t}\n\n\t\ttrace_xfs_attr_leaf_replace(args);\n\n\t\t/* save the attribute state for later removal*/\n\t\targs->op_flags |= XFS_DA_OP_RENAME;\t/* an atomic rename */\n\t\targs->blkno2 = args->blkno;\t\t/* set 2nd entry info*/\n\t\targs->index2 = args->index;\n\t\targs->rmtblkno2 = args->rmtblkno;\n\t\targs->rmtblkcnt2 = args->rmtblkcnt;\n\t\targs->rmtvaluelen2 = args->rmtvaluelen;\n\n\t\t/*\n\t\t * clear the remote attr state now that it is saved so that the\n\t\t * values reflect the state of the attribute we are about to\n\t\t * add, not the attribute we just found and will remove later.\n\t\t */\n\t\targs->rmtblkno = 0;\n\t\targs->rmtblkcnt = 0;\n\t\targs->rmtvaluelen = 0;\n\t}\n\n\t/*\n\t * Add the attribute to the leaf block, transitioning to a Btree\n\t * if required.\n\t */\n\tretval = xfs_attr3_leaf_add(bp, args);\n\tif (retval == -ENOSPC) {\n\t\t/*\n\t\t * Promote the attribute list to the Btree format, then\n\t\t * Commit that transaction so that the node_addname() call\n\t\t * can manage its own transactions.\n\t\t */\n\t\txfs_defer_init(args->dfops, args->firstblock);\n\t\terror = xfs_attr3_leaf_to_node(args);\n\t\tif (error)\n\t\t\tgoto out_defer_cancel;\n\t\txfs_defer_ijoin(args->dfops, dp);\n\t\terror = xfs_defer_finish(&args->trans, args->dfops);\n\t\tif (error)\n\t\t\tgoto out_defer_cancel;\n\n\t\t/*\n\t\t * Commit the current trans (including the inode) and start\n\t\t * a new one.\n\t\t */\n\t\terror = xfs_trans_roll_inode(&args->trans, dp);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\t/*\n\t\t * Fob the whole rest of the problem off on the Btree code.\n\t\t */\n\t\terror = xfs_attr_node_addname(args);\n\t\treturn error;\n\t}\n\n\t/*\n\t * Commit the transaction that added the attr name so that\n\t * later routines can manage their own transactions.\n\t */\n\terror = xfs_trans_roll_inode(&args->trans, dp);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * If there was an out-of-line value, allocate the blocks we\n\t * identified for its storage and copy the value.  This is done\n\t * after we create the attribute so that we don't overflow the\n\t * maximum size of a transaction and/or hit a deadlock.\n\t */\n\tif (args->rmtblkno > 0) {\n\t\terror = xfs_attr_rmtval_set(args);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/*\n\t * If this is an atomic rename operation, we must \"flip\" the\n\t * incomplete flags on the \"new\" and \"old\" attribute/value pairs\n\t * so that one disappears and one appears atomically.  Then we\n\t * must remove the \"old\" attribute/value pair.\n\t */\n\tif (args->op_flags & XFS_DA_OP_RENAME) {\n\t\t/*\n\t\t * In a separate transaction, set the incomplete flag on the\n\t\t * \"old\" attr and clear the incomplete flag on the \"new\" attr.\n\t\t */\n\t\terror = xfs_attr3_leaf_flipflags(args);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\t/*\n\t\t * Dismantle the \"old\" attribute/value pair by removing\n\t\t * a \"remote\" value (if it exists).\n\t\t */\n\t\targs->index = args->index2;\n\t\targs->blkno = args->blkno2;\n\t\targs->rmtblkno = args->rmtblkno2;\n\t\targs->rmtblkcnt = args->rmtblkcnt2;\n\t\targs->rmtvaluelen = args->rmtvaluelen2;\n\t\tif (args->rmtblkno) {\n\t\t\terror = xfs_attr_rmtval_remove(args);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\n\t\t/*\n\t\t * Read in the block containing the \"old\" attr, then\n\t\t * remove the \"old\" attr from that block (neat, huh!)\n\t\t */\n\t\terror = xfs_attr3_leaf_read(args->trans, args->dp, args->blkno,\n\t\t\t\t\t   -1, &bp);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\txfs_attr3_leaf_remove(bp, args);\n\n\t\t/*\n\t\t * If the result is small enough, shrink it all into the inode.\n\t\t */\n\t\tif ((forkoff = xfs_attr_shortform_allfit(bp, dp))) {\n\t\t\txfs_defer_init(args->dfops, args->firstblock);\n\t\t\terror = xfs_attr3_leaf_to_shortform(bp, args, forkoff);\n\t\t\t/* bp is gone due to xfs_da_shrink_inode */\n\t\t\tif (error)\n\t\t\t\tgoto out_defer_cancel;\n\t\t\txfs_defer_ijoin(args->dfops, dp);\n\t\t\terror = xfs_defer_finish(&args->trans, args->dfops);\n\t\t\tif (error)\n\t\t\t\tgoto out_defer_cancel;\n\t\t}\n\n\t\t/*\n\t\t * Commit the remove and start the next trans in series.\n\t\t */\n\t\terror = xfs_trans_roll_inode(&args->trans, dp);\n\n\t} else if (args->rmtblkno > 0) {\n\t\t/*\n\t\t * Added a \"remote\" value, just clear the incomplete flag.\n\t\t */\n\t\terror = xfs_attr3_leaf_clearflag(args);\n\t}\n\treturn error;\nout_defer_cancel:\n\txfs_defer_cancel(args->dfops);\n\treturn error;\n}\n\n/*\n * Remove a name from the leaf attribute list structure\n *\n * This leaf block cannot have a \"remote\" value, we only call this routine\n * if bmap_one_block() says there is only one block (ie: no remote blks).\n */\nSTATIC int\nxfs_attr_leaf_removename(xfs_da_args_t *args)\n{\n\txfs_inode_t *dp;\n\tstruct xfs_buf *bp;\n\tint error, forkoff;\n\n\ttrace_xfs_attr_leaf_removename(args);\n\n\t/*\n\t * Remove the attribute.\n\t */\n\tdp = args->dp;\n\targs->blkno = 0;\n\terror = xfs_attr3_leaf_read(args->trans, args->dp, args->blkno, -1, &bp);\n\tif (error)\n\t\treturn error;\n\n\terror = xfs_attr3_leaf_lookup_int(bp, args);\n\tif (error == -ENOATTR) {\n\t\txfs_trans_brelse(args->trans, bp);\n\t\treturn error;\n\t}\n\n\txfs_attr3_leaf_remove(bp, args);\n\n\t/*\n\t * If the result is small enough, shrink it all into the inode.\n\t */\n\tif ((forkoff = xfs_attr_shortform_allfit(bp, dp))) {\n\t\txfs_defer_init(args->dfops, args->firstblock);\n\t\terror = xfs_attr3_leaf_to_shortform(bp, args, forkoff);\n\t\t/* bp is gone due to xfs_da_shrink_inode */\n\t\tif (error)\n\t\t\tgoto out_defer_cancel;\n\t\txfs_defer_ijoin(args->dfops, dp);\n\t\terror = xfs_defer_finish(&args->trans, args->dfops);\n\t\tif (error)\n\t\t\tgoto out_defer_cancel;\n\t}\n\treturn 0;\nout_defer_cancel:\n\txfs_defer_cancel(args->dfops);\n\treturn error;\n}\n\n/*\n * Look up a name in a leaf attribute list structure.\n *\n * This leaf block cannot have a \"remote\" value, we only call this routine\n * if bmap_one_block() says there is only one block (ie: no remote blks).\n */\nSTATIC int\nxfs_attr_leaf_get(xfs_da_args_t *args)\n{\n\tstruct xfs_buf *bp;\n\tint error;\n\n\ttrace_xfs_attr_leaf_get(args);\n\n\targs->blkno = 0;\n\terror = xfs_attr3_leaf_read(args->trans, args->dp, args->blkno, -1, &bp);\n\tif (error)\n\t\treturn error;\n\n\terror = xfs_attr3_leaf_lookup_int(bp, args);\n\tif (error != -EEXIST)  {\n\t\txfs_trans_brelse(args->trans, bp);\n\t\treturn error;\n\t}\n\terror = xfs_attr3_leaf_getvalue(bp, args);\n\txfs_trans_brelse(args->trans, bp);\n\tif (!error && (args->rmtblkno > 0) && !(args->flags & ATTR_KERNOVAL)) {\n\t\terror = xfs_attr_rmtval_get(args);\n\t}\n\treturn error;\n}\n\n/*========================================================================\n * External routines when attribute list size > geo->blksize\n *========================================================================*/\n\n/*\n * Add a name to a Btree-format attribute list.\n *\n * This will involve walking down the Btree, and may involve splitting\n * leaf nodes and even splitting intermediate nodes up to and including\n * the root node (a special case of an intermediate node).\n *\n * \"Remote\" attribute values confuse the issue and atomic rename operations\n * add a whole extra layer of confusion on top of that.\n */\nSTATIC int\nxfs_attr_node_addname(xfs_da_args_t *args)\n{\n\txfs_da_state_t *state;\n\txfs_da_state_blk_t *blk;\n\txfs_inode_t *dp;\n\txfs_mount_t *mp;\n\tint retval, error;\n\n\ttrace_xfs_attr_node_addname(args);\n\n\t/*\n\t * Fill in bucket of arguments/results/context to carry around.\n\t */\n\tdp = args->dp;\n\tmp = dp->i_mount;\nrestart:\n\tstate = xfs_da_state_alloc();\n\tstate->args = args;\n\tstate->mp = mp;\n\n\t/*\n\t * Search to see if name already exists, and get back a pointer\n\t * to where it should go.\n\t */\n\terror = xfs_da3_node_lookup_int(state, &retval);\n\tif (error)\n\t\tgoto out;\n\tblk = &state->path.blk[ state->path.active-1 ];\n\tASSERT(blk->magic == XFS_ATTR_LEAF_MAGIC);\n\tif ((args->flags & ATTR_REPLACE) && (retval == -ENOATTR)) {\n\t\tgoto out;\n\t} else if (retval == -EEXIST) {\n\t\tif (args->flags & ATTR_CREATE)\n\t\t\tgoto out;\n\n\t\ttrace_xfs_attr_node_replace(args);\n\n\t\t/* save the attribute state for later removal*/\n\t\targs->op_flags |= XFS_DA_OP_RENAME;\t/* atomic rename op */\n\t\targs->blkno2 = args->blkno;\t\t/* set 2nd entry info*/\n\t\targs->index2 = args->index;\n\t\targs->rmtblkno2 = args->rmtblkno;\n\t\targs->rmtblkcnt2 = args->rmtblkcnt;\n\t\targs->rmtvaluelen2 = args->rmtvaluelen;\n\n\t\t/*\n\t\t * clear the remote attr state now that it is saved so that the\n\t\t * values reflect the state of the attribute we are about to\n\t\t * add, not the attribute we just found and will remove later.\n\t\t */\n\t\targs->rmtblkno = 0;\n\t\targs->rmtblkcnt = 0;\n\t\targs->rmtvaluelen = 0;\n\t}\n\n\tretval = xfs_attr3_leaf_add(blk->bp, state->args);\n\tif (retval == -ENOSPC) {\n\t\tif (state->path.active == 1) {\n\t\t\t/*\n\t\t\t * Its really a single leaf node, but it had\n\t\t\t * out-of-line values so it looked like it *might*\n\t\t\t * have been a b-tree.\n\t\t\t */\n\t\t\txfs_da_state_free(state);\n\t\t\tstate = NULL;\n\t\t\txfs_defer_init(args->dfops, args->firstblock);\n\t\t\terror = xfs_attr3_leaf_to_node(args);\n\t\t\tif (error)\n\t\t\t\tgoto out_defer_cancel;\n\t\t\txfs_defer_ijoin(args->dfops, dp);\n\t\t\terror = xfs_defer_finish(&args->trans, args->dfops);\n\t\t\tif (error)\n\t\t\t\tgoto out_defer_cancel;\n\n\t\t\t/*\n\t\t\t * Commit the node conversion and start the next\n\t\t\t * trans in the chain.\n\t\t\t */\n\t\t\terror = xfs_trans_roll_inode(&args->trans, dp);\n\t\t\tif (error)\n\t\t\t\tgoto out;\n\n\t\t\tgoto restart;\n\t\t}\n\n\t\t/*\n\t\t * Split as many Btree elements as required.\n\t\t * This code tracks the new and old attr's location\n\t\t * in the index/blkno/rmtblkno/rmtblkcnt fields and\n\t\t * in the index2/blkno2/rmtblkno2/rmtblkcnt2 fields.\n\t\t */\n\t\txfs_defer_init(args->dfops, args->firstblock);\n\t\terror = xfs_da3_split(state);\n\t\tif (error)\n\t\t\tgoto out_defer_cancel;\n\t\txfs_defer_ijoin(args->dfops, dp);\n\t\terror = xfs_defer_finish(&args->trans, args->dfops);\n\t\tif (error)\n\t\t\tgoto out_defer_cancel;\n\t} else {\n\t\t/*\n\t\t * Addition succeeded, update Btree hashvals.\n\t\t */\n\t\txfs_da3_fixhashpath(state, &state->path);\n\t}\n\n\t/*\n\t * Kill the state structure, we're done with it and need to\n\t * allow the buffers to come back later.\n\t */\n\txfs_da_state_free(state);\n\tstate = NULL;\n\n\t/*\n\t * Commit the leaf addition or btree split and start the next\n\t * trans in the chain.\n\t */\n\terror = xfs_trans_roll_inode(&args->trans, dp);\n\tif (error)\n\t\tgoto out;\n\n\t/*\n\t * If there was an out-of-line value, allocate the blocks we\n\t * identified for its storage and copy the value.  This is done\n\t * after we create the attribute so that we don't overflow the\n\t * maximum size of a transaction and/or hit a deadlock.\n\t */\n\tif (args->rmtblkno > 0) {\n\t\terror = xfs_attr_rmtval_set(args);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/*\n\t * If this is an atomic rename operation, we must \"flip\" the\n\t * incomplete flags on the \"new\" and \"old\" attribute/value pairs\n\t * so that one disappears and one appears atomically.  Then we\n\t * must remove the \"old\" attribute/value pair.\n\t */\n\tif (args->op_flags & XFS_DA_OP_RENAME) {\n\t\t/*\n\t\t * In a separate transaction, set the incomplete flag on the\n\t\t * \"old\" attr and clear the incomplete flag on the \"new\" attr.\n\t\t */\n\t\terror = xfs_attr3_leaf_flipflags(args);\n\t\tif (error)\n\t\t\tgoto out;\n\n\t\t/*\n\t\t * Dismantle the \"old\" attribute/value pair by removing\n\t\t * a \"remote\" value (if it exists).\n\t\t */\n\t\targs->index = args->index2;\n\t\targs->blkno = args->blkno2;\n\t\targs->rmtblkno = args->rmtblkno2;\n\t\targs->rmtblkcnt = args->rmtblkcnt2;\n\t\targs->rmtvaluelen = args->rmtvaluelen2;\n\t\tif (args->rmtblkno) {\n\t\t\terror = xfs_attr_rmtval_remove(args);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\n\t\t/*\n\t\t * Re-find the \"old\" attribute entry after any split ops.\n\t\t * The INCOMPLETE flag means that we will find the \"old\"\n\t\t * attr, not the \"new\" one.\n\t\t */\n\t\targs->flags |= XFS_ATTR_INCOMPLETE;\n\t\tstate = xfs_da_state_alloc();\n\t\tstate->args = args;\n\t\tstate->mp = mp;\n\t\tstate->inleaf = 0;\n\t\terror = xfs_da3_node_lookup_int(state, &retval);\n\t\tif (error)\n\t\t\tgoto out;\n\n\t\t/*\n\t\t * Remove the name and update the hashvals in the tree.\n\t\t */\n\t\tblk = &state->path.blk[ state->path.active-1 ];\n\t\tASSERT(blk->magic == XFS_ATTR_LEAF_MAGIC);\n\t\terror = xfs_attr3_leaf_remove(blk->bp, args);\n\t\txfs_da3_fixhashpath(state, &state->path);\n\n\t\t/*\n\t\t * Check to see if the tree needs to be collapsed.\n\t\t */\n\t\tif (retval && (state->path.active > 1)) {\n\t\t\txfs_defer_init(args->dfops, args->firstblock);\n\t\t\terror = xfs_da3_join(state);\n\t\t\tif (error)\n\t\t\t\tgoto out_defer_cancel;\n\t\t\txfs_defer_ijoin(args->dfops, dp);\n\t\t\terror = xfs_defer_finish(&args->trans, args->dfops);\n\t\t\tif (error)\n\t\t\t\tgoto out_defer_cancel;\n\t\t}\n\n\t\t/*\n\t\t * Commit and start the next trans in the chain.\n\t\t */\n\t\terror = xfs_trans_roll_inode(&args->trans, dp);\n\t\tif (error)\n\t\t\tgoto out;\n\n\t} else if (args->rmtblkno > 0) {\n\t\t/*\n\t\t * Added a \"remote\" value, just clear the incomplete flag.\n\t\t */\n\t\terror = xfs_attr3_leaf_clearflag(args);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\tretval = error = 0;\n\nout:\n\tif (state)\n\t\txfs_da_state_free(state);\n\tif (error)\n\t\treturn error;\n\treturn retval;\nout_defer_cancel:\n\txfs_defer_cancel(args->dfops);\n\tgoto out;\n}\n\n/*\n * Remove a name from a B-tree attribute list.\n *\n * This will involve walking down the Btree, and may involve joining\n * leaf nodes and even joining intermediate nodes up to and including\n * the root node (a special case of an intermediate node).\n */\nSTATIC int\nxfs_attr_node_removename(xfs_da_args_t *args)\n{\n\txfs_da_state_t *state;\n\txfs_da_state_blk_t *blk;\n\txfs_inode_t *dp;\n\tstruct xfs_buf *bp;\n\tint retval, error, forkoff;\n\n\ttrace_xfs_attr_node_removename(args);\n\n\t/*\n\t * Tie a string around our finger to remind us where we are.\n\t */\n\tdp = args->dp;\n\tstate = xfs_da_state_alloc();\n\tstate->args = args;\n\tstate->mp = dp->i_mount;\n\n\t/*\n\t * Search to see if name exists, and get back a pointer to it.\n\t */\n\terror = xfs_da3_node_lookup_int(state, &retval);\n\tif (error || (retval != -EEXIST)) {\n\t\tif (error == 0)\n\t\t\terror = retval;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * If there is an out-of-line value, de-allocate the blocks.\n\t * This is done before we remove the attribute so that we don't\n\t * overflow the maximum size of a transaction and/or hit a deadlock.\n\t */\n\tblk = &state->path.blk[ state->path.active-1 ];\n\tASSERT(blk->bp != NULL);\n\tASSERT(blk->magic == XFS_ATTR_LEAF_MAGIC);\n\tif (args->rmtblkno > 0) {\n\t\t/*\n\t\t * Fill in disk block numbers in the state structure\n\t\t * so that we can get the buffers back after we commit\n\t\t * several transactions in the following calls.\n\t\t */\n\t\terror = xfs_attr_fillstate(state);\n\t\tif (error)\n\t\t\tgoto out;\n\n\t\t/*\n\t\t * Mark the attribute as INCOMPLETE, then bunmapi() the\n\t\t * remote value.\n\t\t */\n\t\terror = xfs_attr3_leaf_setflag(args);\n\t\tif (error)\n\t\t\tgoto out;\n\t\terror = xfs_attr_rmtval_remove(args);\n\t\tif (error)\n\t\t\tgoto out;\n\n\t\t/*\n\t\t * Refill the state structure with buffers, the prior calls\n\t\t * released our buffers.\n\t\t */\n\t\terror = xfs_attr_refillstate(state);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t * Remove the name and update the hashvals in the tree.\n\t */\n\tblk = &state->path.blk[ state->path.active-1 ];\n\tASSERT(blk->magic == XFS_ATTR_LEAF_MAGIC);\n\tretval = xfs_attr3_leaf_remove(blk->bp, args);\n\txfs_da3_fixhashpath(state, &state->path);\n\n\t/*\n\t * Check to see if the tree needs to be collapsed.\n\t */\n\tif (retval && (state->path.active > 1)) {\n\t\txfs_defer_init(args->dfops, args->firstblock);\n\t\terror = xfs_da3_join(state);\n\t\tif (error)\n\t\t\tgoto out_defer_cancel;\n\t\txfs_defer_ijoin(args->dfops, dp);\n\t\terror = xfs_defer_finish(&args->trans, args->dfops);\n\t\tif (error)\n\t\t\tgoto out_defer_cancel;\n\t\t/*\n\t\t * Commit the Btree join operation and start a new trans.\n\t\t */\n\t\terror = xfs_trans_roll_inode(&args->trans, dp);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t * If the result is small enough, push it all into the inode.\n\t */\n\tif (xfs_bmap_one_block(dp, XFS_ATTR_FORK)) {\n\t\t/*\n\t\t * Have to get rid of the copy of this dabuf in the state.\n\t\t */\n\t\tASSERT(state->path.active == 1);\n\t\tASSERT(state->path.blk[0].bp);\n\t\tstate->path.blk[0].bp = NULL;\n\n\t\terror = xfs_attr3_leaf_read(args->trans, args->dp, 0, -1, &bp);\n\t\tif (error)\n\t\t\tgoto out;\n\n\t\tif ((forkoff = xfs_attr_shortform_allfit(bp, dp))) {\n\t\t\txfs_defer_init(args->dfops, args->firstblock);\n\t\t\terror = xfs_attr3_leaf_to_shortform(bp, args, forkoff);\n\t\t\t/* bp is gone due to xfs_da_shrink_inode */\n\t\t\tif (error)\n\t\t\t\tgoto out_defer_cancel;\n\t\t\txfs_defer_ijoin(args->dfops, dp);\n\t\t\terror = xfs_defer_finish(&args->trans, args->dfops);\n\t\t\tif (error)\n\t\t\t\tgoto out_defer_cancel;\n\t\t} else\n\t\t\txfs_trans_brelse(args->trans, bp);\n\t}\n\terror = 0;\n\nout:\n\txfs_da_state_free(state);\n\treturn error;\nout_defer_cancel:\n\txfs_defer_cancel(args->dfops);\n\tgoto out;\n}\n\n/*\n * Fill in the disk block numbers in the state structure for the buffers\n * that are attached to the state structure.\n * This is done so that we can quickly reattach ourselves to those buffers\n * after some set of transaction commits have released these buffers.\n */\nSTATIC int\nxfs_attr_fillstate(xfs_da_state_t *state)\n{\n\txfs_da_state_path_t *path;\n\txfs_da_state_blk_t *blk;\n\tint level;\n\n\ttrace_xfs_attr_fillstate(state->args);\n\n\t/*\n\t * Roll down the \"path\" in the state structure, storing the on-disk\n\t * block number for those buffers in the \"path\".\n\t */\n\tpath = &state->path;\n\tASSERT((path->active >= 0) && (path->active < XFS_DA_NODE_MAXDEPTH));\n\tfor (blk = path->blk, level = 0; level < path->active; blk++, level++) {\n\t\tif (blk->bp) {\n\t\t\tblk->disk_blkno = XFS_BUF_ADDR(blk->bp);\n\t\t\tblk->bp = NULL;\n\t\t} else {\n\t\t\tblk->disk_blkno = 0;\n\t\t}\n\t}\n\n\t/*\n\t * Roll down the \"altpath\" in the state structure, storing the on-disk\n\t * block number for those buffers in the \"altpath\".\n\t */\n\tpath = &state->altpath;\n\tASSERT((path->active >= 0) && (path->active < XFS_DA_NODE_MAXDEPTH));\n\tfor (blk = path->blk, level = 0; level < path->active; blk++, level++) {\n\t\tif (blk->bp) {\n\t\t\tblk->disk_blkno = XFS_BUF_ADDR(blk->bp);\n\t\t\tblk->bp = NULL;\n\t\t} else {\n\t\t\tblk->disk_blkno = 0;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n/*\n * Reattach the buffers to the state structure based on the disk block\n * numbers stored in the state structure.\n * This is done after some set of transaction commits have released those\n * buffers from our grip.\n */\nSTATIC int\nxfs_attr_refillstate(xfs_da_state_t *state)\n{\n\txfs_da_state_path_t *path;\n\txfs_da_state_blk_t *blk;\n\tint level, error;\n\n\ttrace_xfs_attr_refillstate(state->args);\n\n\t/*\n\t * Roll down the \"path\" in the state structure, storing the on-disk\n\t * block number for those buffers in the \"path\".\n\t */\n\tpath = &state->path;\n\tASSERT((path->active >= 0) && (path->active < XFS_DA_NODE_MAXDEPTH));\n\tfor (blk = path->blk, level = 0; level < path->active; blk++, level++) {\n\t\tif (blk->disk_blkno) {\n\t\t\terror = xfs_da3_node_read(state->args->trans,\n\t\t\t\t\t\tstate->args->dp,\n\t\t\t\t\t\tblk->blkno, blk->disk_blkno,\n\t\t\t\t\t\t&blk->bp, XFS_ATTR_FORK);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t} else {\n\t\t\tblk->bp = NULL;\n\t\t}\n\t}\n\n\t/*\n\t * Roll down the \"altpath\" in the state structure, storing the on-disk\n\t * block number for those buffers in the \"altpath\".\n\t */\n\tpath = &state->altpath;\n\tASSERT((path->active >= 0) && (path->active < XFS_DA_NODE_MAXDEPTH));\n\tfor (blk = path->blk, level = 0; level < path->active; blk++, level++) {\n\t\tif (blk->disk_blkno) {\n\t\t\terror = xfs_da3_node_read(state->args->trans,\n\t\t\t\t\t\tstate->args->dp,\n\t\t\t\t\t\tblk->blkno, blk->disk_blkno,\n\t\t\t\t\t\t&blk->bp, XFS_ATTR_FORK);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t} else {\n\t\t\tblk->bp = NULL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n/*\n * Look up a filename in a node attribute list.\n *\n * This routine gets called for any attribute fork that has more than one\n * block, ie: both true Btree attr lists and for single-leaf-blocks with\n * \"remote\" values taking up more blocks.\n */\nSTATIC int\nxfs_attr_node_get(xfs_da_args_t *args)\n{\n\txfs_da_state_t *state;\n\txfs_da_state_blk_t *blk;\n\tint error, retval;\n\tint i;\n\n\ttrace_xfs_attr_node_get(args);\n\n\tstate = xfs_da_state_alloc();\n\tstate->args = args;\n\tstate->mp = args->dp->i_mount;\n\n\t/*\n\t * Search to see if name exists, and get back a pointer to it.\n\t */\n\terror = xfs_da3_node_lookup_int(state, &retval);\n\tif (error) {\n\t\tretval = error;\n\t} else if (retval == -EEXIST) {\n\t\tblk = &state->path.blk[ state->path.active-1 ];\n\t\tASSERT(blk->bp != NULL);\n\t\tASSERT(blk->magic == XFS_ATTR_LEAF_MAGIC);\n\n\t\t/*\n\t\t * Get the value, local or \"remote\"\n\t\t */\n\t\tretval = xfs_attr3_leaf_getvalue(blk->bp, args);\n\t\tif (!retval && (args->rmtblkno > 0)\n\t\t    && !(args->flags & ATTR_KERNOVAL)) {\n\t\t\tretval = xfs_attr_rmtval_get(args);\n\t\t}\n\t}\n\n\t/*\n\t * If not in a transaction, we have to release all the buffers.\n\t */\n\tfor (i = 0; i < state->path.active; i++) {\n\t\txfs_trans_brelse(args->trans, state->path.blk[i].bp);\n\t\tstate->path.blk[i].bp = NULL;\n\t}\n\n\txfs_da_state_free(state);\n\treturn retval;\n}\n"], "filenames": ["fs/xfs/libxfs/xfs_attr.c"], "buggy_code_start_loc": [514], "buggy_code_end_loc": [515], "fixing_code_start_loc": [514], "fixing_code_end_loc": [522], "type": "CWE-754", "message": "In the Linux kernel before 4.17, a local attacker able to set attributes on an xfs filesystem could make this filesystem non-operational until the next mount by triggering an unchecked error condition during an xfs attribute change, because xfs_attr_shortform_addname in fs/xfs/libxfs/xfs_attr.c mishandles ATTR_REPLACE operations with conversion of an attr from short to long form.", "other": {"cve": {"id": "CVE-2018-18690", "sourceIdentifier": "cve@mitre.org", "published": "2018-10-26T18:29:00.227", "lastModified": "2019-10-03T00:03:26.223", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In the Linux kernel before 4.17, a local attacker able to set attributes on an xfs filesystem could make this filesystem non-operational until the next mount by triggering an unchecked error condition during an xfs attribute change, because xfs_attr_shortform_addname in fs/xfs/libxfs/xfs_attr.c mishandles ATTR_REPLACE operations with conversion of an attr from short to long form."}, {"lang": "es", "value": "En el kernel de Linux en versiones anteriores a la 4.17, un atacante local que sea capaz de establecer atributos en un sistema de archivos xfs podr\u00eda hacer que este sistema de archivos no est\u00e9 operativo hasta el siguiente montaje desencadenando una condici\u00f3n de error no marcada. Esto se debe a que xfs_attr_shortform_addname en fs/xfs/libxfs/xfs_attr.c gestiona de manera incorrecta las operaciones ATTR_REPLACE con la conversi\u00f3n de un attr de forma corta a forma larga."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:N/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 4.9}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-754"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "4.17", "matchCriteriaId": "0667D0B1-8AC7-46D8-BB4B-68157115D405"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:12.04:*:*:*:esm:*:*:*", "matchCriteriaId": "8D305F7A-D159-4716-AB26-5E38BB5CD991"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.04:*:*:*:lts:*:*:*", "matchCriteriaId": "B5A6F2F3-4894-4392-8296-3B8DD2679084"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:lts:*:*:*", "matchCriteriaId": "F7016A2A-8365-4F1A-89A2-7A19F2BCAE5B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}]}]}], "references": [{"url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=7b38460dc8e4eafba06c78f8e37099d3b34d473c", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "http://www.securityfocus.com/bid/105753", "source": "cve@mitre.org", "tags": ["VDB Entry", "Third Party Advisory"]}, {"url": "https://bugzilla.kernel.org/show_bug.cgi?id=199119", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Vendor Advisory"]}, {"url": "https://bugzilla.suse.com/show_bug.cgi?id=1105025", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/7b38460dc8e4eafba06c78f8e37099d3b34d473c", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2019/03/msg00017.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2019/03/msg00034.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2019/04/msg00004.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3847-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3847-2/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3847-3/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3848-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3848-2/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3849-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3849-2/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/7b38460dc8e4eafba06c78f8e37099d3b34d473c"}}