{"buggy_code": ["/*\n * (c) Copyright Ascensio System SIA 2010-2019\n *\n * This program is a free software product. You can redistribute it and/or\n * modify it under the terms of the GNU Affero General Public License (AGPL)\n * version 3 as published by the Free Software Foundation. In accordance with\n * Section 7(a) of the GNU AGPL its Section 15 shall be amended to the effect\n * that Ascensio System SIA expressly excludes the warranty of non-infringement\n * of any third-party rights.\n *\n * This program is distributed WITHOUT ANY WARRANTY; without even the implied\n * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR  PURPOSE. For\n * details, see the GNU AGPL at: http://www.gnu.org/licenses/agpl-3.0.html\n *\n * You can contact Ascensio System SIA at 20A-12 Ernesta Birznieka-Upisha\n * street, Riga, Latvia, EU, LV-1050.\n *\n * The  interactive user interfaces in modified source and object code versions\n * of the Program must display Appropriate Legal Notices, as required under\n * Section 5 of the GNU AGPL version 3.\n *\n * Pursuant to Section 7(b) of the License you must retain the original Product\n * logo when distributing the program. Pursuant to Section 7(e) we decline to\n * grant you any rights under trademark law for use of our trademarks.\n *\n * All the Product's GUI elements, including illustrations and icon sets, as\n * well as technical writing content are licensed under the terms of the\n * Creative Commons Attribution-ShareAlike 4.0 International. See the License\n * terms at http://creativecommons.org/licenses/by-sa/4.0/legalcode\n *\n */\n\n#include <fstream>\n#include <time.h>\n#include \"errno.h\"\n\n#if defined(_WIN32) || defined(_WIN32_WCE) || defined(_WIN64)\n    #include <wchar.h>\n    #include <windows.h>\n#endif\n\n#ifdef _LINUX\n#include <unistd.h>\n#include <string.h>\n#include <sys/stat.h>\n#endif\n\n#ifdef _IOS\n    const char* fileSystemRepresentation(const std::wstring& sFileName);\n#endif\n\n#ifdef _MAC\n#include <mach-o/dyld.h>\n#endif\n\n#ifndef MAX_PATH\n    #define MAX_PATH 1024\n#endif\n\n// \u0440\u0435\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044f \u0432\u043e\u0437\u043c\u043e\u0436\u043d\u043e\u0441\u0442\u0438 \u043f\u043e\u0434\u043c\u0435\u043d\u044b \u043e\u043f\u0440\u0435\u0434\u0435\u043b\u0435\u043d\u0438\u044f GetTempPath\nstd::wstring g_overrideTmpPath = L\"\";\n\n#include \"File.h\"\n\n#if defined(_WIN32) || defined(_WIN32_WCE) || defined(_WIN64)\n\t#include <wchar.h>\n\t#include <windows.h>\n\n\tstd::wstring CorrectPathW(const std::wstring& path)\n\t{\n\t\tint len = (int)path.length();\n\t\tif (2 > len)\n\t\t\treturn path;\n\n\t\tconst wchar_t* path_str = path.c_str();\n\t\tif (path_str[0] == '\\\\' || path_str[1] == '/')\n\t\t\treturn path;\n\n\t\t// local files: '\\\\?\\' prefix\n\t\t// server files: '\\\\?\\UNC\\' prefix <== TODO!\n\t\tint nLen = GetFullPathNameW(path_str, 0, 0, 0);\n\t\twchar_t* pBuf = new wchar_t[(4 + nLen) * sizeof(wchar_t)];\n\n\t\tpBuf[0] = L'\\\\', pBuf[1] = L'\\\\',  pBuf[2] = L'?', pBuf[3] = L'\\\\';\n\t\tGetFullPathNameW(path_str, nLen, pBuf + 4, NULL);\n\n\t\tstd::wstring retPath(pBuf);\n\t\tdelete [] pBuf;\n\t\treturn retPath;\n\t}\n#else\n\tstd::wstring CorrectPathW(const std::wstring& path)\n\t{\n\t\treturn path;\n\t}\n#endif\n\nnamespace NSFile\n{\n    std::wstring CUtf8Converter::GetUnicodeFromCharPtr(const char* pData, LONG lCount, INT bIsUtf8)\n    {\n        if (bIsUtf8)\n            return GetUnicodeStringFromUTF8((BYTE*)pData, lCount);\n\n        wchar_t* pUnicode = new wchar_t[lCount + 1];\n        for (LONG i = 0; i < lCount; ++i)\n            pUnicode[i] = (wchar_t)(BYTE)pData[i];\n\n        pUnicode[lCount] = 0;\n\n        std::wstring s(pUnicode, lCount);\n        RELEASEARRAYOBJECTS(pUnicode);\n\n        return s;\n    }\n    std::wstring CUtf8Converter::GetUnicodeFromCharPtr(const std::string& sParam, INT bIsUtf8)\n    {\n        return GetUnicodeFromCharPtr(sParam.c_str(), (LONG)sParam.length(), bIsUtf8);\n    }\n\tLONG CUtf8Converter::GetUnicodeStringFromUTF8BufferSize(LONG lCount)\n    {\n        return lCount + 1;\n    }\n    std::wstring CUtf8Converter::GetUnicodeStringFromUTF8_4bytes( BYTE* pBuffer, LONG lCount )\n    {\n        std::wstring strRes;\n        GetUnicodeStringFromUTF8_4bytes(pBuffer, lCount, strRes);\n        return strRes;\n    }\n    std::wstring CUtf8Converter::GetUnicodeStringFromUTF8_2bytes( BYTE* pBuffer, LONG lCount )\n    {\n        std::wstring strRes;\n        GetUnicodeStringFromUTF8_2bytes(pBuffer, lCount, strRes);\n        return strRes;\n    }\n\n    std::wstring CUtf8Converter::GetUnicodeStringFromUTF8( BYTE* pBuffer, LONG lCount )\n    {\n        std::wstring strRes;\n        GetUnicodeStringFromUTF8(pBuffer, lCount, strRes);\n        return strRes;\n    }\n\n    void CUtf8Converter::GetUnicodeStringFromUTF8_4bytes( BYTE* pBuffer, LONG lCount, std::wstring& sOutput )\n    {\n        WCHAR* pUnicodeString = new WCHAR[lCount + 1];\n        LONG lIndexUnicode = 0;\n\n        LONG lIndex = 0;\n        while (lIndex < lCount)\n        {\n            BYTE byteMain = pBuffer[lIndex];\n            if (0x00 == (byteMain & 0x80))\n            {\n                // 1 byte\n                pUnicodeString[lIndexUnicode++] = (WCHAR)byteMain;\n                ++lIndex;\n            }\n            else if (0x00 == (byteMain & 0x20))\n            {\n                // 2 byte\n                int val = (int)(((byteMain & 0x1F) << 6) |\n                    (pBuffer[lIndex + 1] & 0x3F));\n                pUnicodeString[lIndexUnicode++] = (WCHAR)(val);\n                lIndex += 2;\n            }\n            else if (0x00 == (byteMain & 0x10))\n            {\n                // 3 byte\n                int val = (int)(((byteMain & 0x0F) << 12) |\n                    ((pBuffer[lIndex + 1] & 0x3F) << 6) |\n                    (pBuffer[lIndex + 2] & 0x3F));\n                pUnicodeString[lIndexUnicode++] = (WCHAR)(val);\n                lIndex += 3;\n            }\n            else if (0x00 == (byteMain & 0x0F))\n            {\n                // 4 byte\n                int val = (int)(((byteMain & 0x07) << 18) |\n                    ((pBuffer[lIndex + 1] & 0x3F) << 12) |\n                    ((pBuffer[lIndex + 2] & 0x3F) << 6) |\n                    (pBuffer[lIndex + 3] & 0x3F));\n                pUnicodeString[lIndexUnicode++] = (WCHAR)(val);\n                lIndex += 4;\n            }\n            else if (0x00 == (byteMain & 0x08))\n            {\n                // 4 byte\n                int val = (int)(((byteMain & 0x07) << 18) |\n                    ((pBuffer[lIndex + 1] & 0x3F) << 12) |\n                    ((pBuffer[lIndex + 2] & 0x3F) << 6) |\n                    (pBuffer[lIndex + 3] & 0x3F));\n                pUnicodeString[lIndexUnicode++] = (WCHAR)(val);\n                lIndex += 4;\n            }\n            else if (0x00 == (byteMain & 0x04))\n            {\n                // 5 byte\n                int val = (int)(((byteMain & 0x03) << 24) |\n                    ((pBuffer[lIndex + 1] & 0x3F) << 18) |\n                    ((pBuffer[lIndex + 2] & 0x3F) << 12) |\n                    ((pBuffer[lIndex + 3] & 0x3F) << 6) |\n                    (pBuffer[lIndex + 4] & 0x3F));\n                pUnicodeString[lIndexUnicode++] = (WCHAR)(val);\n                lIndex += 5;\n            }\n            else\n            {\n                // 6 byte\n                int val = (int)(((byteMain & 0x01) << 30) |\n                    ((pBuffer[lIndex + 1] & 0x3F) << 24) |\n                    ((pBuffer[lIndex + 2] & 0x3F) << 18) |\n                    ((pBuffer[lIndex + 3] & 0x3F) << 12) |\n                    ((pBuffer[lIndex + 4] & 0x3F) << 6) |\n                    (pBuffer[lIndex + 5] & 0x3F));\n                pUnicodeString[lIndexUnicode++] = (WCHAR)(val);\n                lIndex += 5;\n            }\n        }\n\n        pUnicodeString[lIndexUnicode] = 0;\n\n        sOutput.append(pUnicodeString);\n\n        delete [] pUnicodeString;\n    }\n    void CUtf8Converter::GetUnicodeStringFromUTF8_2bytes( BYTE* pBuffer, LONG lCount, std::wstring& sOutput )\n    {\n        WCHAR* pUnicodeString = new WCHAR[lCount + 1];\n        WCHAR* pStart = pUnicodeString;\n\n        LONG lIndex = 0;\n        while (lIndex < lCount)\n        {\n            BYTE byteMain = pBuffer[lIndex];\n            if (0x00 == (byteMain & 0x80))\n            {\n                // 1 byte\n                *pUnicodeString++ = (WCHAR)byteMain;\n                ++lIndex;\n            }\n            else if (0x00 == (byteMain & 0x20))\n            {\n                // 2 byte\n                int val = (int)(((byteMain & 0x1F) << 6) |\n                    (pBuffer[lIndex + 1] & 0x3F));\n                *pUnicodeString++ = (WCHAR)(val);\n                lIndex += 2;\n            }\n            else if (0x00 == (byteMain & 0x10))\n            {\n                // 3 byte\n                int val = (int)(((byteMain & 0x0F) << 12) |\n                    ((pBuffer[lIndex + 1] & 0x3F) << 6) |\n                    (pBuffer[lIndex + 2] & 0x3F));\n\n                WriteUtf16_WCHAR(val, pUnicodeString);\n                lIndex += 3;\n            }\n            else if (0x00 == (byteMain & 0x0F))\n            {\n                // 4 byte\n                int val = (int)(((byteMain & 0x07) << 18) |\n                    ((pBuffer[lIndex + 1] & 0x3F) << 12) |\n                    ((pBuffer[lIndex + 2] & 0x3F) << 6) |\n                    (pBuffer[lIndex + 3] & 0x3F));\n\n                WriteUtf16_WCHAR(val, pUnicodeString);\n                lIndex += 4;\n            }\n            else if (0x00 == (byteMain & 0x08))\n            {\n                // 4 byte\n                int val = (int)(((byteMain & 0x07) << 18) |\n                    ((pBuffer[lIndex + 1] & 0x3F) << 12) |\n                    ((pBuffer[lIndex + 2] & 0x3F) << 6) |\n                    (pBuffer[lIndex + 3] & 0x3F));\n\n                WriteUtf16_WCHAR(val, pUnicodeString);\n                lIndex += 4;\n            }\n            else if (0x00 == (byteMain & 0x04))\n            {\n                // 5 byte\n                int val = (int)(((byteMain & 0x03) << 24) |\n                    ((pBuffer[lIndex + 1] & 0x3F) << 18) |\n                    ((pBuffer[lIndex + 2] & 0x3F) << 12) |\n                    ((pBuffer[lIndex + 3] & 0x3F) << 6) |\n                    (pBuffer[lIndex + 4] & 0x3F));\n\n                WriteUtf16_WCHAR(val, pUnicodeString);\n                lIndex += 5;\n            }\n            else\n            {\n                // 6 byte\n                int val = (int)(((byteMain & 0x01) << 30) |\n                    ((pBuffer[lIndex + 1] & 0x3F) << 24) |\n                    ((pBuffer[lIndex + 2] & 0x3F) << 18) |\n                    ((pBuffer[lIndex + 3] & 0x3F) << 12) |\n                    ((pBuffer[lIndex + 4] & 0x3F) << 6) |\n                    (pBuffer[lIndex + 5] & 0x3F));\n\n                WriteUtf16_WCHAR(val, pUnicodeString);\n                lIndex += 5;\n            }\n        }\n\n        *pUnicodeString++ = 0;\n\n        sOutput.append(pStart);\n\n        delete [] pStart;\n    }\n    void CUtf8Converter::GetUnicodeStringFromUTF8( BYTE* pBuffer, LONG lCount, std::wstring& sOutput )\n    {\n        if (sizeof(WCHAR) == 2)\n            GetUnicodeStringFromUTF8_2bytes(pBuffer, lCount, sOutput);\n        else\n            GetUnicodeStringFromUTF8_4bytes(pBuffer, lCount, sOutput);\n    }\n\n#define CHECK_HHHH(pBuffer) \\\n    wchar_t code = 0; \\\n    if('_' == pBuffer[0] && 'x' == pBuffer[1] && 0 != pBuffer[2] && 0 != pBuffer[3] && 0 != pBuffer[4] && 0 != pBuffer[5]  && '_' == pBuffer[6]) \\\n    { \\\n        int i = 2; \\\n        for(; i < 6; ++i) \\\n        { \\\n            code *= 16; \\\n            if('0' <= pBuffer[i] && pBuffer[i] <= '9') \\\n            { \\\n                code += pBuffer[i] - '0'; \\\n            } \\\n            else if('A' <= pBuffer[i] && pBuffer[i] <= 'F') \\\n            { \\\n                code += pBuffer[i] - 'A' + 10; \\\n            } \\\n            else if('a' <= pBuffer[i] && pBuffer[i] <= 'f') \\\n            { \\\n                code += pBuffer[i] - 'a' + 10; \\\n            } \\\n            else \\\n            { \\\n                break; \\\n            } \\\n        } \\\n        if(i == 6) \\\n        { \\\n            if(0x005F == code) \\\n            { \\\n                code = '_'; \\\n            } \\\n            return code; \\\n        } \\\n    } \\\n    return -1;\n\n    long CUtf8Converter::CheckHHHHChar(const BYTE* pBuffer)\n\t{\n        CHECK_HHHH(pBuffer);\n\t}\n    long CUtf8Converter::CheckHHHHChar(const wchar_t* pBuffer)\n\t{\n        CHECK_HHHH(pBuffer);\n\t}\n\n    void CUtf8Converter::GetUnicodeStringFromUTF8WithHHHH_4bytes( const BYTE* pBuffer, LONG lCount, wchar_t*& pUnicodes, LONG& lOutputCount )\n    {\n        if (NULL == pUnicodes)\n        {\n            pUnicodes = new wchar_t[GetUnicodeStringFromUTF8BufferSize(lCount)];\n        }\n        WCHAR* pUnicodeString = pUnicodes;\n        LONG lIndexUnicode = 0;\n\n        LONG lIndex = 0;\n        while (lIndex < lCount)\n        {\n            BYTE byteMain = pBuffer[lIndex];\n            if (0x00 == (byteMain & 0x80))\n            {\n\t\t\t\t// 1 byte\n                long code = CheckHHHHChar(pBuffer + lIndex);\n                if(code < 0)\n                {\n\t\t\t\t\tpUnicodeString[lIndexUnicode++] = (WCHAR)byteMain;\n\t\t\t\t\t++lIndex;\n\t\t\t\t}\n                else\n                {\n                    pUnicodeString[lIndexUnicode++] = (WCHAR)code;\n                    lIndex += 7;\n                }\n            }\n            else if (0x00 == (byteMain & 0x20))\n            {\n                // 2 byte\n                int val = (int)(((byteMain & 0x1F) << 6) |\n                    (pBuffer[lIndex + 1] & 0x3F));\n                pUnicodeString[lIndexUnicode++] = (WCHAR)(val);\n                lIndex += 2;\n            }\n            else if (0x00 == (byteMain & 0x10))\n            {\n                // 3 byte\n                int val = (int)(((byteMain & 0x0F) << 12) |\n                    ((pBuffer[lIndex + 1] & 0x3F) << 6) |\n                    (pBuffer[lIndex + 2] & 0x3F));\n                pUnicodeString[lIndexUnicode++] = (WCHAR)(val);\n                lIndex += 3;\n            }\n            else if (0x00 == (byteMain & 0x0F))\n            {\n                // 4 byte\n                int val = (int)(((byteMain & 0x07) << 18) |\n                    ((pBuffer[lIndex + 1] & 0x3F) << 12) |\n                    ((pBuffer[lIndex + 2] & 0x3F) << 6) |\n                    (pBuffer[lIndex + 3] & 0x3F));\n                pUnicodeString[lIndexUnicode++] = (WCHAR)(val);\n                lIndex += 4;\n            }\n            else if (0x00 == (byteMain & 0x08))\n            {\n                // 4 byte\n                int val = (int)(((byteMain & 0x07) << 18) |\n                    ((pBuffer[lIndex + 1] & 0x3F) << 12) |\n                    ((pBuffer[lIndex + 2] & 0x3F) << 6) |\n                    (pBuffer[lIndex + 3] & 0x3F));\n                pUnicodeString[lIndexUnicode++] = (WCHAR)(val);\n                lIndex += 4;\n            }\n            else if (0x00 == (byteMain & 0x04))\n            {\n                // 5 byte\n                int val = (int)(((byteMain & 0x03) << 24) |\n                    ((pBuffer[lIndex + 1] & 0x3F) << 18) |\n                    ((pBuffer[lIndex + 2] & 0x3F) << 12) |\n                    ((pBuffer[lIndex + 3] & 0x3F) << 6) |\n                    (pBuffer[lIndex + 4] & 0x3F));\n                pUnicodeString[lIndexUnicode++] = (WCHAR)(val);\n                lIndex += 5;\n            }\n            else\n            {\n                // 6 byte\n                int val = (int)(((byteMain & 0x01) << 30) |\n                    ((pBuffer[lIndex + 1] & 0x3F) << 24) |\n                    ((pBuffer[lIndex + 2] & 0x3F) << 18) |\n                    ((pBuffer[lIndex + 3] & 0x3F) << 12) |\n                    ((pBuffer[lIndex + 4] & 0x3F) << 6) |\n                    (pBuffer[lIndex + 5] & 0x3F));\n                pUnicodeString[lIndexUnicode++] = (WCHAR)(val);\n                lIndex += 5;\n            }\n        }\n\n        pUnicodeString[lIndexUnicode] = 0;\n\t\tlOutputCount = lIndexUnicode;\n    }\n    void CUtf8Converter::GetUnicodeStringFromUTF8WithHHHH_2bytes( const BYTE* pBuffer, LONG lCount, wchar_t*& pUnicodes, LONG& lOutputCount )\n    {\n        if (NULL == pUnicodes)\n        {\n            pUnicodes = new wchar_t[GetUnicodeStringFromUTF8BufferSize(lCount)];\n        }\n        WCHAR* pUnicodeString = pUnicodes;\n        WCHAR* pStart = pUnicodeString;\n        LONG lIndex = 0;\n        while (lIndex < lCount)\n        {\n            BYTE byteMain = pBuffer[lIndex];\n            if (0x00 == (byteMain & 0x80))\n            {\n                // 1 byte\n                long code = CheckHHHHChar(pBuffer + lIndex);\n                if(code < 0)\n                {\n                    *pUnicodeString++ = (WCHAR)byteMain;\n                    ++lIndex;\n                }\n                else\n                {\n                    *pUnicodeString++ = (WCHAR)code;\n                    lIndex += 7;\n                }\n\n            }\n            else if (0x00 == (byteMain & 0x20))\n            {\n                // 2 byte\n                int val = (int)(((byteMain & 0x1F) << 6) |\n                    (pBuffer[lIndex + 1] & 0x3F));\n                *pUnicodeString++ = (WCHAR)(val);\n                lIndex += 2;\n            }\n            else if (0x00 == (byteMain & 0x10))\n            {\n                // 3 byte\n                int val = (int)(((byteMain & 0x0F) << 12) |\n                    ((pBuffer[lIndex + 1] & 0x3F) << 6) |\n                    (pBuffer[lIndex + 2] & 0x3F));\n\n                WriteUtf16_WCHAR(val, pUnicodeString);\n                lIndex += 3;\n            }\n            else if (0x00 == (byteMain & 0x0F))\n            {\n                // 4 byte\n                int val = (int)(((byteMain & 0x07) << 18) |\n                    ((pBuffer[lIndex + 1] & 0x3F) << 12) |\n                    ((pBuffer[lIndex + 2] & 0x3F) << 6) |\n                    (pBuffer[lIndex + 3] & 0x3F));\n\n                WriteUtf16_WCHAR(val, pUnicodeString);\n                lIndex += 4;\n            }\n            else if (0x00 == (byteMain & 0x08))\n            {\n                // 4 byte\n                int val = (int)(((byteMain & 0x07) << 18) |\n                    ((pBuffer[lIndex + 1] & 0x3F) << 12) |\n                    ((pBuffer[lIndex + 2] & 0x3F) << 6) |\n                    (pBuffer[lIndex + 3] & 0x3F));\n\n                WriteUtf16_WCHAR(val, pUnicodeString);\n                lIndex += 4;\n            }\n            else if (0x00 == (byteMain & 0x04))\n            {\n                // 5 byte\n                int val = (int)(((byteMain & 0x03) << 24) |\n                    ((pBuffer[lIndex + 1] & 0x3F) << 18) |\n                    ((pBuffer[lIndex + 2] & 0x3F) << 12) |\n                    ((pBuffer[lIndex + 3] & 0x3F) << 6) |\n                    (pBuffer[lIndex + 4] & 0x3F));\n\n                WriteUtf16_WCHAR(val, pUnicodeString);\n                lIndex += 5;\n            }\n            else\n            {\n                // 6 byte\n                int val = (int)(((byteMain & 0x01) << 30) |\n                    ((pBuffer[lIndex + 1] & 0x3F) << 24) |\n                    ((pBuffer[lIndex + 2] & 0x3F) << 18) |\n                    ((pBuffer[lIndex + 3] & 0x3F) << 12) |\n                    ((pBuffer[lIndex + 4] & 0x3F) << 6) |\n                    (pBuffer[lIndex + 5] & 0x3F));\n\n                WriteUtf16_WCHAR(val, pUnicodeString);\n                lIndex += 5;\n            }\n        }\n\n\t\tlOutputCount = pUnicodeString - pStart;\n        *pUnicodeString++ = 0;\n    }\n    void CUtf8Converter::GetUnicodeStringFromUTF8WithHHHH( const BYTE* pBuffer, LONG lCount, wchar_t*& pUnicodes, LONG& lOutputCount )\n    {\n        if (sizeof(WCHAR) == 2)\n            return GetUnicodeStringFromUTF8WithHHHH_2bytes(pBuffer, lCount, pUnicodes, lOutputCount);\n        return GetUnicodeStringFromUTF8WithHHHH_4bytes(pBuffer, lCount, pUnicodes, lOutputCount);\n    }\n\n    void CUtf8Converter::GetUtf8StringFromUnicode_4bytes(const wchar_t* pUnicodes, LONG lCount, BYTE*& pData, LONG& lOutputCount, bool bIsBOM)\n    {\n        if (NULL == pData)\n        {\n            pData = new BYTE[6 * lCount + 3 + 1 ];\n        }\n\n        BYTE* pCodesCur = pData;\n        if (bIsBOM)\n        {\n            pCodesCur[0] = 0xEF;\n            pCodesCur[1] = 0xBB;\n            pCodesCur[2] = 0xBF;\n            pCodesCur += 3;\n        }\n\n        const wchar_t* pEnd = pUnicodes + lCount;\n        const wchar_t* pCur = pUnicodes;\n\n        while (pCur < pEnd)\n        {\n            unsigned int code = (unsigned int)*pCur++;\n\n            if (code < 0x80)\n            {\n                *pCodesCur++ = (BYTE)code;\n            }\n            else if (code < 0x0800)\n            {\n                *pCodesCur++ = 0xC0 | (code >> 6);\n                *pCodesCur++ = 0x80 | (code & 0x3F);\n            }\n            else if (code < 0x10000)\n            {\n                *pCodesCur++ = 0xE0 | (code >> 12);\n                *pCodesCur++ = 0x80 | (code >> 6 & 0x3F);\n                *pCodesCur++ = 0x80 | (code & 0x3F);\n            }\n            else if (code < 0x1FFFFF)\n            {\n                *pCodesCur++ = 0xF0 | (code >> 18);\n                *pCodesCur++ = 0x80 | (code >> 12 & 0x3F);\n                *pCodesCur++ = 0x80 | (code >> 6 & 0x3F);\n                *pCodesCur++ = 0x80 | (code & 0x3F);\n            }\n            else if (code < 0x3FFFFFF)\n            {\n                *pCodesCur++ = 0xF8 | (code >> 24);\n                *pCodesCur++ = 0x80 | (code >> 18 & 0x3F);\n                *pCodesCur++ = 0x80 | (code >> 12 & 0x3F);\n                *pCodesCur++ = 0x80 | (code >> 6 & 0x3F);\n                *pCodesCur++ = 0x80 | (code & 0x3F);\n            }\n            else if (code < 0x7FFFFFFF)\n            {\n                *pCodesCur++ = 0xFC | (code >> 30);\n                *pCodesCur++ = 0x80 | (code >> 24 & 0x3F);\n                *pCodesCur++ = 0x80 | (code >> 18 & 0x3F);\n                *pCodesCur++ = 0x80 | (code >> 12 & 0x3F);\n                *pCodesCur++ = 0x80 | (code >> 6 & 0x3F);\n                *pCodesCur++ = 0x80 | (code & 0x3F);\n            }\n        }\n\n        lOutputCount = (LONG)(pCodesCur - pData);\n        *pCodesCur++ = 0;\n    }\n\n    void CUtf8Converter::GetUtf8StringFromUnicode_2bytes(const wchar_t* pUnicodes, LONG lCount, BYTE*& pData, LONG& lOutputCount, bool bIsBOM)\n    {\n        if (NULL == pData)\n        {\n            pData = new BYTE[6 * lCount + 3 + 1];\n        }\n\n        BYTE* pCodesCur = pData;\n        if (bIsBOM)\n        {\n            pCodesCur[0] = 0xEF;\n            pCodesCur[1] = 0xBB;\n            pCodesCur[2] = 0xBF;\n            pCodesCur += 3;\n        }\n\n        const wchar_t* pEnd = pUnicodes + lCount;\n        const wchar_t* pCur = pUnicodes;\n\n        while (pCur < pEnd)\n        {\n            unsigned int code = (unsigned int)*pCur++;\n            if (code >= 0xD800 && code <= 0xDFFF && pCur < pEnd)\n            {\n                code = 0x10000 + (((code & 0x3FF) << 10) | (0x03FF & *pCur++));\n            }\n\n            if (code < 0x80)\n            {\n                *pCodesCur++ = (BYTE)code;\n            }\n            else if (code < 0x0800)\n            {\n                *pCodesCur++ = 0xC0 | (code >> 6);\n                *pCodesCur++ = 0x80 | (code & 0x3F);\n            }\n            else if (code < 0x10000)\n            {\n                *pCodesCur++ = 0xE0 | (code >> 12);\n                *pCodesCur++ = 0x80 | ((code >> 6) & 0x3F);\n                *pCodesCur++ = 0x80 | (code & 0x3F);\n            }\n            else if (code < 0x1FFFFF)\n            {\n                *pCodesCur++ = 0xF0 | (code >> 18);\n                *pCodesCur++ = 0x80 | ((code >> 12) & 0x3F);\n                *pCodesCur++ = 0x80 | ((code >> 6) & 0x3F);\n                *pCodesCur++ = 0x80 | (code & 0x3F);\n            }\n            else if (code < 0x3FFFFFF)\n            {\n                *pCodesCur++ = 0xF8 | (code >> 24);\n                *pCodesCur++ = 0x80 | ((code >> 18) & 0x3F);\n                *pCodesCur++ = 0x80 | ((code >> 12) & 0x3F);\n                *pCodesCur++ = 0x80 | ((code >> 6) & 0x3F);\n                *pCodesCur++ = 0x80 | (code & 0x3F);\n            }\n            else if (code < 0x7FFFFFFF)\n            {\n                *pCodesCur++ = 0xFC | (code >> 30);\n                *pCodesCur++ = 0x80 | ((code >> 24) & 0x3F);\n                *pCodesCur++ = 0x80 | ((code >> 18) & 0x3F);\n                *pCodesCur++ = 0x80 | ((code >> 12) & 0x3F);\n                *pCodesCur++ = 0x80 | ((code >> 6) & 0x3F);\n                *pCodesCur++ = 0x80 | (code & 0x3F);\n            }\n        }\n\n        lOutputCount = (LONG)(pCodesCur - pData);\n        *pCodesCur++ = 0;\n    }\n\n    void CUtf8Converter::GetUtf8StringFromUnicode(const wchar_t* pUnicodes, LONG lCount, BYTE*& pData, LONG& lOutputCount, bool bIsBOM)\n    {\n        if (sizeof(WCHAR) == 2)\n            return GetUtf8StringFromUnicode_2bytes(pUnicodes, lCount, pData, lOutputCount, bIsBOM);\n        return GetUtf8StringFromUnicode_4bytes(pUnicodes, lCount, pData, lOutputCount, bIsBOM);\n    }\n\n    std::string CUtf8Converter::GetUtf8StringFromUnicode2(const wchar_t* pUnicodes, LONG lCount, bool bIsBOM)\n    {\n        BYTE* pData = NULL;\n        LONG lLen = 0;\n\n        GetUtf8StringFromUnicode(pUnicodes, lCount, pData, lLen, bIsBOM);\n\n        std::string s((char*)pData, lLen);\n\n        RELEASEARRAYOBJECTS(pData);\n        return s;\n    }\n\n    std::string CUtf8Converter::GetUtf8StringFromUnicode(const std::wstring& sData)\n    {\n        return GetUtf8StringFromUnicode2(sData.c_str(), (LONG)sData.length());\n    }\n\n    // utf16\n    void CUtf8Converter::GetUtf16StringFromUnicode_4bytes(const wchar_t* pUnicodes, LONG lCount, BYTE*& pData, int& lOutputCount, bool bIsBOM)\n    {\n        if (NULL == pData)\n        {\n            pData = new BYTE[4 * lCount + 3 + 2];\n        }\n\n        BYTE* pCodesCur = pData;\n        if (bIsBOM)\n        {\n            pCodesCur[0] = 0xEF;\n            pCodesCur[1] = 0xBB;\n            pCodesCur[2] = 0xBF;\n            pCodesCur += 3;\n        }\n\n        const wchar_t* pEnd = pUnicodes + lCount;\n        const wchar_t* pCur = pUnicodes;\n\n        while (pCur < pEnd)\n        {\n            unsigned int code = (unsigned int)*pCur++;\n\n            if (code <= 0xFFFF)\n            {\n                USHORT usCode = (USHORT)(code & 0xFFFF);\n                memcpy(pCodesCur, &usCode, 2);\n                pCodesCur += 2;\n            }\n            else\n            {\n                code -= 0x10000;\n                code &= 0xFFFFF;\n\n                USHORT us1 = 0xD800 | ((code >> 10) & 0x03FF);\n                USHORT us2 = 0xDC00 | (code & 0x03FF);\n\n                memcpy(pCodesCur, &us1, 2);\n                pCodesCur += 2;\n\n                memcpy(pCodesCur, &us2, 2);\n                pCodesCur += 2;\n            }\n        }\n\n        lOutputCount = (LONG)(pCodesCur - pData);\n        *pCodesCur++ = 0;\n        *pCodesCur++ = 0;\n    }\n\n    void CUtf8Converter::GetUtf16StringFromUnicode_4bytes2(const wchar_t* pUnicodes, LONG lCount, CStringUtf16& data)\n    {\n        GetUtf16StringFromUnicode_4bytes(pUnicodes, lCount, data.Data, data.Length);\n    }\n\n    std::wstring CUtf8Converter::GetWStringFromUTF16(const CStringUtf16& data)\n    {\n        if (0 == data.Length)\n            return L\"\";\n\n        if (sizeof(wchar_t) == 2)\n            return std::wstring((wchar_t*)data.Data, data.Length / 2);\n\n        int nCount = data.Length / 2;\n        USHORT* pShort = (USHORT*)data.Data;\n\n        wchar_t* pWChar = new wchar_t[nCount + 1];\n        wchar_t* pWCurrent = pWChar;\n\n        int nCurrent = 0;\n        while (nCurrent < nCount)\n        {\n            if (*pShort < 0xD800 || *pShort > 0xDBFF)\n            {\n                *pWCurrent = (wchar_t)(*pShort);\n                ++pShort;\n                ++nCurrent;\n            }\n            else\n            {\n                *pWCurrent = (wchar_t)(((((pShort[0] - 0xD800) & 0x03FF) << 10) | ((pShort[1] - 0xDC00) & 0x03FF)) + 0x10000);\n                pShort += 2;\n                nCurrent += 2;\n            }\n            ++pWCurrent;\n        }\n\n        std::wstring sRet(pWChar, pWCurrent - pWChar);\n\n        RELEASEARRAYOBJECTS(pWChar);\n        return sRet;\n    }\n    std::wstring CUtf8Converter::GetWStringFromUTF16(const unsigned short* pUtf16, LONG lCount)\n    {\n        CStringUtf16 oString;\n        oString.Data   = (BYTE*)pUtf16;\n        oString.Length = lCount * 2;\n        std::wstring wsResult = GetWStringFromUTF16(oString);\n        oString.Data = NULL;\n        return wsResult;\n    }\n}\n\nnamespace NSFile\n{\n    CFileBinary::CFileBinary()\n    {\n        m_pFile = NULL;\n        m_lFilePosition = 0;\n        m_lFileSize = 0;\n    }\n    CFileBinary::~CFileBinary()\n    {\n        CloseFile();\n    }\n\n    void CFileBinary::CloseFile()\n    {\n        m_lFilePosition = 0;\n        m_lFileSize = 0;\n\n        if (m_pFile != NULL)\n        {\n            fclose(m_pFile);\n            m_pFile = NULL;\n        }\n    }\n\n    FILE* CFileBinary::GetFileNative()\n    {\n        return m_pFile;\n    }\n    long CFileBinary::GetFileSize()\n    {\n        return m_lFileSize;\n    }\n    long CFileBinary::GetFilePosition()\n    {\n        return m_lFilePosition;\n    }\n\n#ifdef _IOS\n    \n    bool CFileBinary::OpenFile(const std::wstring& sFileName, bool bRewrite)\n    {\n        m_pFile = fopen(fileSystemRepresentation(sFileName), bRewrite ? \"rb+\" : \"rb\");\n        \n        if (NULL == m_pFile) {\n#if DEBUG\n            //    printf (\"NSFile::OpenFile - error open file : %s\\n\",strerror(errno));\n#endif\n            return false;\n        }\n        \n        fseek(m_pFile, 0, SEEK_END);\n        m_lFileSize = ftell(m_pFile);\n        fseek(m_pFile, 0, SEEK_SET);\n        \n        m_lFilePosition = 0;\n        \n        if (0 < sFileName.length())\n        {\n            if (((wchar_t)'/') == sFileName.c_str()[sFileName.length() - 1])\n                m_lFileSize = 0x7FFFFFFF;\n        }\n        \n        unsigned int err = 0x7FFFFFFF;\n        unsigned int cur = (unsigned int)m_lFileSize;\n        if (err == cur)\n        {\n            CloseFile();\n            return false;\n        }\n        \n        return true;\n    }\n\n    bool CFileBinary::CreateFileW(const std::wstring& sFileName)\n    {\n        m_pFile = fopen(fileSystemRepresentation(sFileName), \"wb\");\n\n        if (NULL == m_pFile) {\n#if DEBUG\n        //    printf (\"NSFile::CreateFileW - error create file : %s\\n\",strerror(errno));\n#endif\n            return false;\n        }\n\n        m_lFilePosition = 0;\n        return true;\n    }\n\n#else\n\n    bool CFileBinary::OpenFile(const std::wstring& sFileName, bool bRewrite)\n    {\n#if defined(_WIN32) || defined(_WIN32_WCE) || defined(_WIN64)\n        if ( 0 != _wfopen_s(&m_pFile, sFileName.c_str(), bRewrite ? L\"rb+\" : L\"rb\"))\n            return false;\n#else\n        BYTE* pUtf8 = NULL;\n        LONG lLen = 0;\n        CUtf8Converter::GetUtf8StringFromUnicode(sFileName.c_str(), sFileName.length(), pUtf8, lLen, false);\n        m_pFile = fopen((char*)pUtf8, bRewrite ? \"rb+\" : \"rb\");\n\n        delete [] pUtf8;\n#endif\n        if (NULL == m_pFile)\n            return false;\n\n        fseek(m_pFile, 0, SEEK_END);\n        m_lFileSize = ftell(m_pFile);\n        fseek(m_pFile, 0, SEEK_SET);\n\n        m_lFilePosition = 0;\n\n        if (0 < sFileName.length())\n        {\n            if (((wchar_t)'/') == sFileName.c_str()[sFileName.length() - 1])\n                m_lFileSize = 0x7FFFFFFF;\n        }\n\n        unsigned int err = 0x7FFFFFFF;\n        unsigned int cur = (unsigned int)m_lFileSize;\n        if (err == cur)\n        {\n            CloseFile();\n            return false;\n        }\n\n        return true;\n    }\n\n    bool CFileBinary::CreateFileW(const std::wstring& sFileName)\n    {\n#if defined(_WIN32) || defined(_WIN32_WCE) || defined(_WIN64)\n         if ( 0 != _wfopen_s(&m_pFile, sFileName.c_str(), L\"wb\"))\n             return false;\n#else\n        BYTE* pUtf8 = NULL;\n        LONG lLen = 0;\n        CUtf8Converter::GetUtf8StringFromUnicode(sFileName.c_str(), sFileName.length(), pUtf8, lLen, false);\n        m_pFile = fopen((char*)pUtf8, \"wb\");\n        delete [] pUtf8;\n#endif\n        if (NULL == m_pFile)\n            return false;\n\n        m_lFilePosition = 0;\n        return true;\n    }\n\n#endif\n\n    bool CFileBinary::CreateTempFile()\n    {\n#if defined(_WIN32) || defined(_WIN32_WCE) || defined(_WIN64)\n        if (0 != tmpfile_s(&m_pFile))\n            return false;\n#else\n        m_pFile = tmpfile();\n        if (NULL == m_pFile)\n            return false;\n#endif\n        m_lFilePosition = 0;\n        return true;\n    }\n    bool CFileBinary::SeekFile(int lFilePosition, int nSeekMode)\n    {\n        if (!m_pFile)\n            return false;\n\n        m_lFilePosition = fseek(m_pFile, lFilePosition, nSeekMode);\n        return true;\n    }\n    bool CFileBinary::ReadFile(BYTE* pData, DWORD nBytesToRead, DWORD& dwSizeRead)\n    {\n        if (!m_pFile)\n            return false;\n\n        dwSizeRead = (DWORD)fread((void*)pData, 1, nBytesToRead, m_pFile);\n        return true;\n    }\n    bool CFileBinary::WriteFile(const BYTE* pData, DWORD nBytesCount)\n    {\n        if (!m_pFile)\n            return false;\n\n        size_t nCountWrite = fwrite((const void*)pData, 1, nBytesCount, m_pFile);\n        return true;\n    }\n    long CFileBinary::TellFile()\n    {\n        if (!m_pFile)\n            return 0;\n\n        return ftell(m_pFile);\n    }\n    long CFileBinary::SizeFile()\n    {\n        if (!m_pFile)\n            return 0;\n\n        long lPos = TellFile();\n        fseek(m_pFile, 0, SEEK_END);\n        m_lFileSize = ftell(m_pFile);\n        fseek(m_pFile, lPos, SEEK_SET);\n\n        return m_lFileSize;\n    }\n    void CFileBinary::WriteStringUTF8(const std::wstring& strXml, bool bIsBOM)\n    {\n        BYTE* pData = NULL;\n        LONG lLen = 0;\n\n        CUtf8Converter::GetUtf8StringFromUnicode(strXml.c_str(), (LONG)strXml.length(), pData, lLen, bIsBOM);\n\n        WriteFile(pData, lLen);\n\n        RELEASEARRAYOBJECTS(pData);\n    }\n    bool CFileBinary::ReadAllBytes(const std::wstring&  strFileName, BYTE** ppData, DWORD& nBytesCount)\n    {\n        *ppData = NULL;\n        nBytesCount = 0;\n        bool bRes = false;\n        CFileBinary oFileBinary;\n        if (oFileBinary.OpenFile(strFileName))\n        {\n            long nFileSize = oFileBinary.GetFileSize();\n            BYTE* pData = new BYTE[nFileSize];\n            DWORD dwSizeRead;\n            if (oFileBinary.ReadFile(pData, nFileSize, dwSizeRead))\n            {\n                oFileBinary.CloseFile();\n                *ppData = pData;\n                nBytesCount = dwSizeRead;\n                bRes = true;\n            }\n            else\n                RELEASEARRAYOBJECTS(pData);\n        }\n        return bRes;\n    }\n    bool CFileBinary::ReadAllTextUtf8(const std::wstring&  strFileName, std::wstring& sData)\n    {\n        bool bRes = false;\n        BYTE* pData = NULL;\n        DWORD nDataSize;\n        if (CFileBinary::ReadAllBytes(strFileName, &pData, nDataSize))\n        {\n            //remove BOM if exist\n            BYTE* pDataStart = pData;\n            DWORD nBOMSize = 3;\n            if (nDataSize > nBOMSize && 0xef == pDataStart[0] && 0xbb == pDataStart[1] && 0xbf == pDataStart[2])\n            {\n                pDataStart += nBOMSize;\n                nDataSize -= nBOMSize;\n            }\n            sData = CUtf8Converter::GetUnicodeStringFromUTF8(pDataStart, nDataSize);\n            RELEASEARRAYOBJECTS(pData);\n            bRes = true;\n        }\n        return bRes;\n    }\n    bool CFileBinary::ReadAllTextUtf8A(const std::wstring&  strFileName, std::string& sData)\n    {\n        bool bRes = false;\n        BYTE* pData = NULL;\n        DWORD nDataSize;\n        if (CFileBinary::ReadAllBytes(strFileName, &pData, nDataSize))\n        {\n            //remove BOM if exist\n            BYTE* pDataStart = pData;\n            DWORD nBOMSize = 3;\n            if (nDataSize > nBOMSize && 0xef == pDataStart[0] && 0xbb == pDataStart[1] && 0xbf == pDataStart[2])\n            {\n                pDataStart += nBOMSize;\n                nDataSize -= nBOMSize;\n            }\n            sData = std::string((char*)pDataStart, nDataSize);\n            RELEASEARRAYOBJECTS(pData);\n            bRes = true;\n        }\n        return bRes;\n    }\n    bool CFileBinary::SaveToFile(const std::wstring&  strFileName, const std::wstring& strXml, bool bIsBOM)\n    {\n        CFileBinary oFile;\n        oFile.CreateFileW(strFileName);\n        oFile.WriteStringUTF8(strXml, bIsBOM);\n        oFile.CloseFile();\n        return true;\n    }\n    bool CFileBinary::Exists(const std::wstring&  strFileName)\n    {\n#if defined(_WIN32) || defined(_WIN32_WCE) || defined(_WIN64)\n        FILE* pFile = NULL;\n        if ( 0 != _wfopen_s( &pFile, strFileName.c_str(), L\"rb\"))\n            return false;\n#else\n        BYTE* pUtf8 = NULL;\n        LONG lLen = 0;\n        CUtf8Converter::GetUtf8StringFromUnicode(strFileName.c_str(), strFileName.length(), pUtf8, lLen, false);\n        FILE* pFile = fopen((char*)pUtf8, \"rb\");\n        delete [] pUtf8;\n#endif\n        if (NULL != pFile)\n        {\n            fclose(pFile);\n            return true;\n        }\n        else\n            return false;\n    }\n    bool CFileBinary::Copy(const std::wstring&  strSrc, const std::wstring& strDst)\n    {\n        if (strSrc == strDst)\n            return true;\n\n        std::ifstream src;\n        std::ofstream dst;\n\n        int nLenBuffer = 1024 * 1024; // 10\n        CFileBinary oFile;\n        if (oFile.OpenFile(strSrc))\n        {\n            int nFileSize = (int)oFile.GetFileSize();\n            if (nFileSize < nLenBuffer)\n                nLenBuffer = nFileSize;\n\n            oFile.CloseFile();\n        }\n        else\n        {\n#ifdef _WIN32\n            return (0 != ::CopyFileW(strSrc.c_str(), strDst.c_str(), 1));\n#endif\n        }\n\n        char* pBuffer_in = NULL;\n        char* pBuffer_out = NULL;\n\n        if (nLenBuffer > 0)\n        {\n            pBuffer_in = new char[nLenBuffer];\n            pBuffer_out = new char[nLenBuffer];\n\n            src.rdbuf()->pubsetbuf(pBuffer_in, nLenBuffer);\n            dst.rdbuf()->pubsetbuf(pBuffer_out, nLenBuffer);\n        }\n\n#if defined(_WIN32) || defined(_WIN32_WCE) || defined(_WIN64)\n        src.open(strSrc.c_str(), std::ios::binary);\n        dst.open(strDst.c_str(), std::ios::binary);\n#else\n        BYTE* pUtf8Src = NULL;\n        LONG lLenSrc = 0;\n        CUtf8Converter::GetUtf8StringFromUnicode(strSrc.c_str(), strSrc.length(), pUtf8Src, lLenSrc, false);\n        BYTE* pUtf8Dst = NULL;\n        LONG lLenDst = 0;\n        CUtf8Converter::GetUtf8StringFromUnicode(strDst.c_str(), strDst.length(), pUtf8Dst, lLenDst, false);\n\n        src.open((char*)pUtf8Src, std::ios::binary);\n        dst.open((char*)pUtf8Dst, std::ios::binary);\n\n        delete [] pUtf8Src;\n        delete [] pUtf8Dst;\n#endif\n\n        bool bRet = false;\n\n        if (src.is_open() && dst.is_open())\n        {\n            dst << src.rdbuf();\n            src.close();\n            dst.close();\n\n            bRet = true;\n        }\n        RELEASEARRAYOBJECTS(pBuffer_in);\n        RELEASEARRAYOBJECTS(pBuffer_out);\n        return bRet;\n    }\n    bool CFileBinary::Remove(const std::wstring& strFileName)\n    {\n#if defined(_WIN32) || defined(_WIN32_WCE) || defined(_WIN64)\n        int nRes = _wremove(strFileName.c_str());\n#else\n        BYTE* pUtf8 = NULL;\n        LONG lLen = 0;\n        CUtf8Converter::GetUtf8StringFromUnicode(strFileName.c_str(), strFileName.length(), pUtf8, lLen, false);\n        int nRes = std::remove((char*)pUtf8);\n        delete [] pUtf8;\n#endif\n        return 0 == nRes;\n    }\n    bool CFileBinary::Move(const std::wstring&  strSrc, const std::wstring& strDst)\n    {\n        if (strSrc == strDst)\n            return true;\n        if (Copy(strSrc, strDst))\n            if (Remove(strSrc))\n                return true;\n        return false;\n    }\n\n    bool CFileBinary::Truncate(const std::wstring& sPath, size_t nNewSize)\n    {\n        bool bIsSuccess = false;\n\n#if defined(_WIN32) || defined(_WIN32_WCE) || defined(_WIN64)\n        HANDLE hFile = ::CreateFileW( sPath.c_str(), GENERIC_WRITE, FILE_SHARE_READ,\n                                        NULL, OPEN_EXISTING,\n                                        FILE_ATTRIBUTE_NORMAL, NULL );\n        if ( hFile == INVALID_HANDLE_VALUE )\n        {\n            return bIsSuccess;\n        }\n\n        LARGE_INTEGER Size = { 0 };\n\n        if ( GetFileSizeEx( hFile, &Size ) )\n        {\n            LARGE_INTEGER Distance = { 0 };\n            // Negative values move the pointer backward in the file\n            Distance.QuadPart = (LONGLONG)nNewSize - Size.QuadPart;\n            bIsSuccess = (SetFilePointerEx(hFile, Distance, NULL, FILE_END) && SetEndOfFile(hFile));\n        }\n\n        CloseHandle( hFile );\n#else\n        std::string sFileUTF8 = U_TO_UTF8(sPath);\n        bIsSuccess = (0 == truncate(sFileUTF8.c_str(), nNewSize));\n#endif\n        return bIsSuccess;\n    }\n\n    std::wstring CFileBinary::GetTempPath()\n    {\n        if (!g_overrideTmpPath.empty())\n            return g_overrideTmpPath;\n\n#if defined(_WIN32) || defined(_WIN32_WCE) || defined(_WIN64)\n        wchar_t pBuffer[MAX_PATH + 1];\n        memset(pBuffer, 0, sizeof(wchar_t) * (MAX_PATH + 1));\n        ::GetTempPathW(MAX_PATH, pBuffer);\n\n        std::wstring sRet(pBuffer);\n\n        size_t nSeparatorPos = sRet.find_last_of(wchar_t('/'));\n        if (std::wstring::npos == nSeparatorPos)\n        {\n            nSeparatorPos = sRet.find_last_of(wchar_t('\\\\'));\n        }\n\n        if (std::wstring::npos == nSeparatorPos)\n            return L\"\";\n\n        return sRet.substr(0, nSeparatorPos);\n#else\n        char *folder = getenv(\"TEMP\");\n\n        if (NULL == folder)\n            folder = getenv(\"TMP\");\n        if (NULL == folder)\n            folder = getenv(\"TMPDIR\");\n        if (NULL == folder)\n            folder = \"/tmp\";\n\n        return NSFile::CUtf8Converter::GetUnicodeStringFromUTF8((BYTE*)folder, strlen(folder));\n#endif\n    }\n    std::wstring CFileBinary::CreateTempFileWithUniqueName(const std::wstring& strFolderPathRoot, const std::wstring& Prefix)\n    {\n#if defined(_WIN32) || defined(_WIN32_WCE) || defined(_WIN64)\n        wchar_t pBuffer[MAX_PATH + 1];\n        ::GetTempFileNameW(strFolderPathRoot.c_str(), Prefix.c_str(), 0, pBuffer);\n        std::wstring sRet(pBuffer);\n        return sRet;\n#else\n        char pcRes[MAX_PATH];\n        BYTE* pData = (BYTE*)pcRes;\n\n        std::wstring sPrefix = strFolderPathRoot + L\"/\" + Prefix + L\"_XXXXXX\";\n        LONG lLen = 0;\n        NSFile::CUtf8Converter::GetUtf8StringFromUnicode(sPrefix.c_str(), (LONG)sPrefix.length(), pData, lLen);\n        pcRes[lLen] = '\\0';\n\n        int res = mkstemp(pcRes);\n        if (-1 != res)\n            close(res);\n\n        std::string sRes = pcRes;\n        return NSFile::CUtf8Converter::GetUnicodeStringFromUTF8((BYTE*)sRes.c_str(), sRes.length());\n#endif\n    }\n    bool CFileBinary::OpenTempFile(std::wstring *pwsName, FILE **ppFile, wchar_t *wsMode, wchar_t *wsExt, wchar_t *wsFolder, wchar_t* wsName)\n    {\n        // TODO: \u0420\u0435\u0430\u043b\u0438\u0437\u043e\u0432\u0430\u0442\u044c \u043a\u043e\u0433\u0434\u0430 wsName != NULL\n\n        std::wstring wsTemp, wsFileName;\n        FILE *pTempFile = NULL;\n#if defined(_WIN32) || defined (_WIN64)\n        wchar_t *wsTempDir = NULL;\n        size_t sz = 0;\n        if ( (0 == _wdupenv_s(&wsTempDir, &sz, L\"TEMP\")) && (wsFolder == NULL))\n        {\n            wsTemp = std::wstring(wsTempDir, sz-1);\n#else\n        char *wsTempDirA;\n        if ((wsTempDirA = getenv(\"TEMP\")) && (wsFolder == NULL))\n        {\n            std::wstring wsTempDir = NSFile::CUtf8Converter::GetUnicodeStringFromUTF8((BYTE*)wsTempDirA, strlen(wsTempDirA));\n            wsTemp = wsTempDir.c_str();\n#endif\n            wsTemp += L\"/\";\n        }\n        else if (wsFolder != NULL)\n        {\n            wsTemp = std::wstring(wsFolder);\n            wsTemp += L\"/\";\n        }\n        else\n        {\n            wsTemp = L\"\";\n        }\n        wsTemp += L\"x\";\n        int nTime = (int)time(NULL);\n        for (int nIndex = 0; nIndex < 1000; ++nIndex)\n        {\n            wsFileName = wsTemp;\n            wsFileName.append(std::to_wstring(nTime + nIndex));\n\n            if (wsExt)\n            {\n                wsFileName.append(wsExt);\n            }\n#if defined (_WIN32) || defined (_WIN64)\n            if ( 0 != _wfopen_s(&pTempFile, wsFileName.c_str(), L\"r\") )\n            {\n                if (0 != _wfopen_s(&pTempFile, wsFileName.c_str(), wsMode))\n#else\n            std::string sFileName = U_TO_UTF8(wsFileName);\n            if (!(pTempFile = fopen(sFileName.c_str(), \"r\")))\n            {\n                std::wstring strMode(wsMode);\n                std::string sMode = U_TO_UTF8(strMode);\n                if (!(pTempFile = fopen(sFileName.c_str(), sMode.c_str())))\n#endif\n                {\n                    return FALSE;\n                }\n                *pwsName = wsFileName;\n                *ppFile = pTempFile;\n                return TRUE;\n            }\n\n            fclose(pTempFile);\n        }\n\n        return FALSE;\n    }\n    FILE* CFileBinary::OpenFileNative(const std::wstring& sFileName, const std::wstring& sMode)\n    {\n#if defined(_WIN32) || defined(_WIN32_WCE) || defined(_WIN64)\n        FILE* pFile = NULL;\n        _wfopen_s(&pFile, sFileName.c_str(), sMode.c_str());\n\n        return pFile;\n#else\n        BYTE* pUtf8 = NULL;\n        LONG lLen = 0;\n        CUtf8Converter::GetUtf8StringFromUnicode(sFileName.c_str(), sFileName.length(), pUtf8, lLen, false);\n\n        BYTE* pMode = NULL;\n        LONG lLenMode;\n        CUtf8Converter::GetUtf8StringFromUnicode(sMode.c_str(), sMode.length(), pMode, lLenMode, false);\n\n        FILE* pFile = fopen((char*)pUtf8, (char*)pMode);\n\n        delete [] pUtf8;\n        delete [] pMode;\n\n        return pFile;\n#endif\n    }\n\n    void CFileBinary::SetTempPath(const std::wstring& strTempPath)\n    {\n        g_overrideTmpPath = strTempPath;\n    }\n\n    unsigned long CFileBinary::GetDateTime(const std::wstring & inputFile)\n    {\n        unsigned long result = 0;\n#if defined(_WIN32) || defined (_WIN64)\n        HANDLE hFile;\n        hFile = ::CreateFileW(inputFile.c_str(), GENERIC_READ, FILE_SHARE_READ,  NULL,  OPEN_EXISTING,  FILE_ATTRIBUTE_NORMAL, NULL);\n\n        if (hFile)\n        {\n            FILETIME ft; ft.dwLowDateTime = ft.dwHighDateTime = 0;\n            if (GetFileTime(hFile, NULL, NULL, &ft))\n            {\n                WORD fatDate = 0, fatTime = 0;\n                if (FileTimeToDosDateTime(&ft, &fatDate,  &fatTime))\n                {\n                    result = (fatDate << 16) + fatTime;\n                }\n            }\n            CloseHandle(hFile);\n        }\n#else\n        std::string inputFileA = U_TO_UTF8(inputFile);\n#if defined(__linux__) && !defined(_MAC)\n        struct stat attrib;\n        stat(inputFileA.c_str(), &attrib);\n        result = attrib.st_mtim.tv_nsec;\n#else\n        struct stat attrib;\n        stat(inputFileA.c_str(), &attrib);\n        result = (unsigned long)attrib.st_mtimespec.tv_nsec;\n#endif\n#endif\n        return result;\n    }\n}\n\nnamespace NSFile\n{\n    bool CBase64Converter::Encode(BYTE* pDataSrc, int nLenSrc, char*& pDataDst, int& nLenDst, DWORD dwFlags)\n    {\n        if (!pDataSrc || nLenSrc < 1)\n            return false;\n\n        nLenDst = NSBase64::Base64EncodeGetRequiredLength(nLenSrc, dwFlags);\n        pDataDst = new char[nLenDst];\n\n        if (FALSE == NSBase64::Base64Encode(pDataSrc, nLenSrc, (BYTE*)pDataDst, &nLenDst, dwFlags))\n        {\n            RELEASEARRAYOBJECTS(pDataDst);\n            return false;\n        }\n        return true;\n    }\n    bool CBase64Converter::Decode(const char* pDataSrc, int nLenSrc, BYTE*& pDataDst, int& nLenDst)\n    {\n        if (!pDataSrc || nLenSrc < 1)\n            return false;\n\n        nLenDst = NSBase64::Base64DecodeGetRequiredLength(nLenSrc);\n        pDataDst = new BYTE[nLenDst];\n\n        if (FALSE == NSBase64::Base64Decode(pDataSrc, nLenSrc, pDataDst, &nLenDst))\n        {\n            RELEASEARRAYOBJECTS(pDataDst);\n            return false;\n        }\n        return true;\n    }\n}\n\nnamespace NSFile\n{\n    std::wstring GetProcessPath()\n    {\n#if defined (_WIN64) || defined(_WIN32)\n        wchar_t buf [NS_FILE_MAX_PATH];\n        GetModuleFileNameW(GetModuleHandle(NULL), buf, NS_FILE_MAX_PATH);\n        return std::wstring(buf);\n#endif\n\n#if defined(__linux__) || defined(_MAC) && !defined(_IOS)\n        char buf[NS_FILE_MAX_PATH];\n        memset(buf, 0, NS_FILE_MAX_PATH);\n        if (readlink (\"/proc/self/exe\", buf, NS_FILE_MAX_PATH) <= 0)\n        {\n#ifdef _MAC\n            uint32_t _size = NS_FILE_MAX_PATH;\n            _NSGetExecutablePath(buf, &_size);\n            std::string sUTF8(buf);\n            std::wstring sRet = CUtf8Converter::GetUnicodeStringFromUTF8((BYTE*)sUTF8.c_str(), sUTF8.length());\n            return sRet;\n#endif\n            return L\"\";\n        }\n\n        std::string sUTF8(buf);\n        std::wstring sRet = CUtf8Converter::GetUnicodeStringFromUTF8((BYTE*)sUTF8.c_str(), sUTF8.length());\n        return sRet;\n#endif\n\n        return L\"\";\n    }\n\n    std::wstring GetProcessDirectory()\n    {\n        std::wstring sPath = GetProcessPath();\n\n        size_t pos1 = sPath.find_last_of(wchar_t('/'));\n        size_t pos2 = sPath.find_last_of(wchar_t('\\\\'));\n\n        size_t pos = std::wstring::npos;\n        if (pos1 != std::wstring::npos)\n            pos = pos1;\n\n        if (pos2 != std::wstring::npos)\n        {\n            if (pos == std::wstring::npos)\n                pos = pos2;\n            else if (pos2 > pos)\n                pos = pos2;\n        }\n\n        if (pos != std::wstring::npos)\n        {\n            sPath = sPath.substr(0, pos);\n        }\n        return sPath;\n    }\n\n    // CommonFunctions\n    std::wstring GetFileExtention(const std::wstring& sPath)\n    {\n        std::wstring::size_type nPos = sPath.rfind('.');\n        if (nPos != std::wstring::npos)\n            return sPath.substr(nPos + 1);\n        return sPath;\n    }\n    std::wstring GetFileName(const std::wstring& sPath)\n    {\n        std::wstring::size_type nPos1 = sPath.rfind('\\\\');\n        std::wstring::size_type nPos2 = sPath.rfind('/');\n        std::wstring::size_type nPos = std::wstring::npos;\n\n        if (nPos1 != std::wstring::npos)\n        {\n            nPos = nPos1;\n            if (nPos2 != std::wstring::npos && nPos2 > nPos)\n                nPos = nPos2;\n        }\n        else\n            nPos = nPos2;\n\n        if (nPos == std::wstring::npos)\n            return sPath;\n        return sPath.substr(nPos + 1);\n    }\n    std::wstring GetDirectoryName(const std::wstring& sPath)\n    {\n        std::wstring::size_type nPos1 = sPath.rfind('\\\\');\n        std::wstring::size_type nPos2 = sPath.rfind('/');\n        std::wstring::size_type nPos = std::wstring::npos;\n\n        if (nPos1 != std::wstring::npos)\n        {\n            nPos = nPos1;\n            if (nPos2 != std::wstring::npos && nPos2 > nPos)\n                nPos = nPos2;\n        }\n        else\n            nPos = nPos2;\n\n        if (nPos == std::wstring::npos)\n            return sPath;\n        return sPath.substr(0, nPos);\n    }\n}\n", "\ufeff/*\r\n * File:\txfile.h\r\n * Purpose:\tGeneral Purpose File Class \r\n */\r\n/*\r\n  --------------------------------------------------------------------------------\r\n\r\n\tCOPYRIGHT NOTICE, DISCLAIMER, and LICENSE:\r\n\r\n\tCxFile (c)  11/May/2002 Davide Pizzolato - www.xdp.it\r\n\tCxFile version 2.00 23/Aug/2002\r\n\tCxFile version 2.10 16/Dec/2007\r\n\t\r\n\tSpecial thanks to Chris Shearer Cooper for new features, enhancements and bugfixes\r\n\r\n\tCovered code is provided under this license on an \"as is\" basis, without warranty\r\n\tof any kind, either expressed or implied, including, without limitation, warranties\r\n\tthat the covered code is free of defects, merchantable, fit for a particular purpose\r\n\tor non-infringing. The entire risk as to the quality and performance of the covered\r\n\tcode is with you. Should any covered code prove defective in any respect, you (not\r\n\tthe initial developer or any other contributor) assume the cost of any necessary\r\n\tservicing, repair or correction. This disclaimer of warranty constitutes an essential\r\n\tpart of this license. No use of any covered code is authorized hereunder except under\r\n\tthis disclaimer.\r\n\r\n\tPermission is hereby granted to use, copy, modify, and distribute this\r\n\tsource code, or portions hereof, for any purpose, including commercial applications,\r\n\tfreely and without fee, subject to the following restrictions: \r\n\r\n\t1. The origin of this software must not be misrepresented; you must not\r\n\tclaim that you wrote the original software. If you use this software\r\n\tin a product, an acknowledgment in the product documentation would be\r\n\tappreciated but is not required.\r\n\r\n\t2. Altered source versions must be plainly marked as such, and must not be\r\n\tmisrepresented as being the original software.\r\n\r\n\t3. This notice may not be removed or altered from any source distribution.\r\n  --------------------------------------------------------------------------------\r\n */\r\n#if !defined(__xfile_h)\r\n#define __xfile_h\r\n\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n\r\n#include \"ximadef.h\"\r\n\r\nclass DLL_EXP CxFile\r\n{\r\npublic:\r\n\tCxFile(void) { };\r\n\tvirtual ~CxFile() { };\r\n\r\n\tvirtual bool\tClose() = 0;\r\n\tvirtual size_t\tRead(void *buffer, size_t size, size_t count) = 0;\r\n\tvirtual size_t\tWrite(const void *buffer, size_t size, size_t count) = 0;\r\n\tvirtual bool\tSeek(int32_t offset, int32_t origin) = 0;\r\n\tvirtual int32_t\tTell() = 0;\r\n\tvirtual int32_t\tSize() = 0;\r\n\tvirtual bool\tFlush() = 0;\r\n\tvirtual bool\tEof() = 0;\r\n\tvirtual int32_t\tError() = 0;\r\n\tvirtual bool\tPutC(uint8_t c)\r\n\t\t{\r\n\t\t// Default implementation\r\n\t\tsize_t nWrote = Write(&c, 1, 1);\r\n\t\treturn (bool)(nWrote == 1);\r\n\t\t}\r\n\tvirtual int32_t\tGetC() = 0;\r\n\tvirtual char *\tGetS(char *string, int32_t n) = 0;\r\n\tvirtual int32_t\tScanf(const char *format, void* output) = 0;\r\n};\r\n\r\n#endif //__xfile_h\r\n", "\ufeff/*\r\n * File:\tximabmp.cpp\r\n * Purpose:\tPlatform Independent BMP Image Class Loader and Writer\r\n * 07/Aug/2001 Davide Pizzolato - www.xdp.it\r\n * CxImage version 7.0.2 07/Feb/2011\r\n */\r\n\r\n#include \"ximabmp.h\"\r\n\r\n#if CXIMAGE_SUPPORT_BMP\r\n\r\n#include \"ximaiter.h\" \r\n\r\n#ifndef min\r\n#define min(a,b) (((a)<(b))?(a):(b))\r\n#endif\r\n#ifndef max\r\n#define max(a,b) (((a)>(b))?(a):(b))\r\n#endif\r\n\r\n////////////////////////////////////////////////////////////////////////////////\r\n#if CXIMAGE_SUPPORT_ENCODE\r\n////////////////////////////////////////////////////////////////////////////////\r\nbool CxImageBMP::Encode(CxFile * hFile)\r\n{\r\n\r\n\tif (EncodeSafeCheck(hFile)) return false;\r\n\r\n\tBITMAPFILEHEADER\thdr;\r\n\r\n\thdr.bfType = 0x4d42;   // 'BM' WINDOWS_BITMAP_SIGNATURE\r\n\thdr.bfSize = GetSize() + 14 /*sizeof(BITMAPFILEHEADER)*/;\r\n\thdr.bfReserved1 = hdr.bfReserved2 = 0;\r\n\thdr.bfOffBits = 14 /*sizeof(BITMAPFILEHEADER)*/ + head.biSize + GetPaletteSize();\r\n\r\n\thdr.bfType = m_ntohs(hdr.bfType); \r\n\thdr.bfSize = m_ntohl(hdr.bfSize); \r\n\thdr.bfOffBits = m_ntohl(hdr.bfOffBits); \r\n\r\n#if CXIMAGE_SUPPORT_ALPHA\r\n\tif (GetNumColors()==0 && AlphaIsValid()){\r\n\t\r\n\t\tBITMAPINFOHEADER  infohdr;\r\n\t\tmemcpy(&infohdr,&head,sizeof(BITMAPINFOHEADER));\r\n\t\tinfohdr.biCompression = BI_RGB;\r\n\t\tinfohdr.biBitCount = 32;\r\n\t\tuint32_t dwEffWidth = ((((infohdr.biBitCount * infohdr.biWidth) + 31) / 32) * 4);\r\n\t\tinfohdr.biSizeImage = dwEffWidth * infohdr.biHeight;\r\n\r\n\t\thdr.bfSize = infohdr.biSize + infohdr.biSizeImage + 14 /*sizeof(BITMAPFILEHEADER)*/;\r\n\r\n\t\thdr.bfSize = m_ntohl(hdr.bfSize);\r\n\t\tbihtoh(&infohdr);\r\n\r\n\t\t// Write the file header\r\n\t\thFile->Write(&hdr,min(14,sizeof(BITMAPFILEHEADER)),1);\r\n\t\thFile->Write(&infohdr,sizeof(BITMAPINFOHEADER),1);\r\n\t\t //and DIB+ALPHA interlaced\r\n\t\tuint8_t *srcalpha = AlphaGetPointer();\r\n\t\tfor(int32_t y = 0; y < infohdr.biHeight; ++y){\r\n\t\t\tuint8_t *srcdib = GetBits(y);\r\n\t\t\tfor(int32_t x = 0; x < infohdr.biWidth; ++x){\r\n\t\t\t\thFile->Write(srcdib,3,1);\r\n\t\t\t\thFile->Write(srcalpha,1,1);\r\n\t\t\t\tsrcdib += 3;\r\n\t\t\t\t++srcalpha;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t} else \r\n#endif //CXIMAGE_SUPPORT_ALPHA\r\n\t{\r\n\t\t// Write the file header\r\n\t\thFile->Write(&hdr,min(14,sizeof(BITMAPFILEHEADER)),1);\r\n\t\t//copy attributes\r\n\t\tmemcpy(pDib,&head,sizeof(BITMAPINFOHEADER));\r\n\t\tbihtoh((BITMAPINFOHEADER*)pDib);\r\n\t\t// Write the DIB header and the pixels\r\n\t\thFile->Write(pDib,GetSize(),1);\r\n\t\tbihtoh((BITMAPINFOHEADER*)pDib);\r\n\t}\r\n\treturn true;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n#endif //CXIMAGE_SUPPORT_ENCODE\r\n////////////////////////////////////////////////////////////////////////////////\r\n#if CXIMAGE_SUPPORT_DECODE\r\n////////////////////////////////////////////////////////////////////////////////\r\nbool CxImageBMP::Decode(CxFile * hFile)\r\n{\r\n\tif (hFile == NULL) return false;\r\n\r\n\tBITMAPFILEHEADER   bf;\r\n\tuint32_t off = hFile->Tell(); //<CSC>\r\n  cx_try {\r\n\tif (hFile->Read(&bf,min(14,sizeof(bf)),1)==0) cx_throw(\"Not a BMP\");\r\n\r\n\tbf.bfSize = m_ntohl(bf.bfSize); \r\n\tbf.bfOffBits = m_ntohl(bf.bfOffBits); \r\n\r\n    if (m_ntohs(bf.bfType) != BFT_BITMAP) { //do we have a RC HEADER?\r\n        bf.bfOffBits = 0L;\r\n        hFile->Seek(off,SEEK_SET);\r\n    }\r\n\r\n\tBITMAPINFOHEADER bmpHeader;\r\n\tif (!DibReadBitmapInfo(hFile,&bmpHeader)) cx_throw(\"Error reading BMP info\");\r\n\tuint32_t dwCompression=bmpHeader.biCompression;\r\n\tuint32_t dwBitCount=bmpHeader.biBitCount; //preserve for BI_BITFIELDS compression <Thomas Ernst>\r\n\tbool bIsOldBmp = bmpHeader.biSize == sizeof(BITMAPCOREHEADER);\r\n\r\n\tbool bTopDownDib = bmpHeader.biHeight<0; //<Flanders> check if it's a top-down bitmap\r\n\tif (bTopDownDib) bmpHeader.biHeight=-bmpHeader.biHeight;\r\n\r\n\tif (info.nEscape == -1) {\r\n\t\t// Return output dimensions only\r\n\t\thead.biWidth = bmpHeader.biWidth;\r\n\t\thead.biHeight = bmpHeader.biHeight;\r\n\t\tinfo.dwType = CXIMAGE_FORMAT_BMP;\r\n\t\tcx_throw(\"output dimensions returned\");\r\n\t}\r\n\r\n\tif (!Create(bmpHeader.biWidth,bmpHeader.biHeight,bmpHeader.biBitCount,CXIMAGE_FORMAT_BMP))\r\n\t\tcx_throw(\"\");\r\n\r\n\tSetXDPI((int32_t) floor(bmpHeader.biXPelsPerMeter * 254.0 / 10000.0 + 0.5));\r\n\tSetYDPI((int32_t) floor(bmpHeader.biYPelsPerMeter * 254.0 / 10000.0 + 0.5));\r\n\r\n\tif (info.nEscape) cx_throw(\"Cancelled\"); // <vho> - cancel decoding\r\n\r\n    RGBQUAD *pRgb = GetPalette();\r\n    if (pRgb){\r\n        if (bIsOldBmp){\r\n             // convert a old color table (3 byte entries) to a new\r\n             // color table (4 byte entries)\r\n            hFile->Read((void*)pRgb,DibNumColors(&bmpHeader) * sizeof(RGBTRIPLE),1);\r\n            for (int32_t i=DibNumColors(&head)-1; i>=0; i--){\r\n                pRgb[i].rgbRed      = ((RGBTRIPLE *)pRgb)[i].rgbtRed;\r\n                pRgb[i].rgbBlue     = ((RGBTRIPLE *)pRgb)[i].rgbtBlue;\r\n                pRgb[i].rgbGreen    = ((RGBTRIPLE *)pRgb)[i].rgbtGreen;\r\n                pRgb[i].rgbReserved = (uint8_t)0;\r\n            }\r\n        } else {\r\n            hFile->Read((void*)pRgb,DibNumColors(&bmpHeader) * sizeof(RGBQUAD),1);\r\n\t\t\t//force rgbReserved=0, to avoid problems with some WinXp bitmaps\r\n\t\t\tfor (uint32_t i=0; i<head.biClrUsed; i++) pRgb[i].rgbReserved=0;\r\n        }\r\n    }\r\n\r\n\tif (info.nEscape) cx_throw(\"Cancelled\"); // <vho> - cancel decoding\r\n\r\n\tswitch (dwBitCount) {\r\n\t\tcase 32 :\r\n\t\t\tuint32_t bfmask[3];\r\n\t\t\tif (dwCompression == BI_BITFIELDS)\r\n\t\t\t{\r\n\t\t\t\thFile->Read(bfmask, 12, 1);\r\n\t\t\t} else {\r\n\t\t\t\tbfmask[0]=0x00FF0000;\r\n\t\t\t\tbfmask[1]=0x0000FF00;\r\n\t\t\t\tbfmask[2]=0x000000FF;\r\n\t\t\t}\r\n\t\t\tif (bf.bfOffBits != 0L) hFile->Seek(off + bf.bfOffBits,SEEK_SET);\r\n\t\t\tif (dwCompression == BI_BITFIELDS || dwCompression == BI_RGB){\r\n\t\t\t\tint32_t imagesize=4*head.biHeight*head.biWidth;\r\n\t\t\t\tuint8_t* buff32=(uint8_t*)malloc(imagesize);\r\n\t\t\t\tif (buff32){\r\n\t\t\t\t\thFile->Read(buff32, imagesize,1); // read in the pixels\r\n\r\n#if CXIMAGE_SUPPORT_ALPHA\r\n\t\t\t\t\tif (dwCompression == BI_RGB){\r\n\t\t\t\t\t\tAlphaCreate();\r\n\t\t\t\t\t\tif (AlphaIsValid()){\r\n\t\t\t\t\t\t\tbool bAlphaOk = false;\r\n\t\t\t\t\t\t\tuint8_t* p;\r\n\t\t\t\t\t\t\tfor (int32_t y=0; y<head.biHeight; y++){\r\n\t\t\t\t\t\t\t\tp = buff32 + 3 + head.biWidth * 4 * y;\r\n\t\t\t\t\t\t\t\tfor (int32_t x=0; x<head.biWidth; x++){\r\n\t\t\t\t\t\t\t\t\tif (*p) bAlphaOk = true;\r\n\t\t\t\t\t\t\t\t\tAlphaSet(x,y,*p);\r\n\t\t\t\t\t\t\t\t\tp+=4;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t// fix if alpha pixels are all zero\r\n\t\t\t\t\t\t\tif (!bAlphaOk) AlphaInvert();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n#endif //CXIMAGE_SUPPORT_ALPHA\r\n\r\n\t\t\t\t\tBitfield2RGB(buff32,bfmask[0],bfmask[1],bfmask[2],32);\r\n\t\t\t\t\tfree(buff32);\r\n\t\t\t\t} else cx_throw(\"can't allocate memory\");\r\n\t\t\t} else cx_throw(\"unknown compression\");\r\n\t\t\tbreak;\r\n\t\tcase 24 :\r\n\t\t\tif (bf.bfOffBits != 0L) hFile->Seek(off + bf.bfOffBits,SEEK_SET);\r\n\t\t\tif (dwCompression == BI_RGB){\r\n\t\t\t\thFile->Read(info.pImage, head.biSizeImage,1); // read in the pixels\r\n\t\t\t} else cx_throw(\"unknown compression\");\r\n\t\t\tbreak;\r\n\t\tcase 16 :\r\n\t\t{\r\n\t\t\tuint32_t bfmask[3];\r\n\t\t\tif (dwCompression == BI_BITFIELDS)\r\n\t\t\t{\r\n\t\t\t\thFile->Read(bfmask, 12, 1);\r\n\t\t\t} else {\r\n\t\t\t\tbfmask[0]=0x7C00; bfmask[1]=0x3E0; bfmask[2]=0x1F; //RGB555\r\n\t\t\t}\r\n\t\t\t// bf.bfOffBits required after the bitfield mask <Cui Ying Jie>\r\n\t\t\tif (bf.bfOffBits != 0L) hFile->Seek(off + bf.bfOffBits,SEEK_SET);\r\n\t\t\t// read in the pixels\r\n\t\t\thFile->Read(info.pImage, head.biHeight*((head.biWidth+1)/2)*4,1);\r\n\t\t\t// transform into RGB\r\n\t\t\tBitfield2RGB(info.pImage,bfmask[0],bfmask[1],bfmask[2],16);\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tcase 8 :\r\n\t\tcase 4 :\r\n\t\tcase 1 :\r\n\t\t\tif (off + bf.bfOffBits < bmpHeader.biSize)\r\n\t\t\t{\r\n\t\t\t\t// \u041e\u0428\u0418\u0411\u041a\u0410\r\n\t\t\t\t// \u0444\u0430\u0439\u043b\u044b \u043f\u0430\u0442\u0442\u0435\u0440\u043d\u044b\u0445 \u0437\u0430\u043b\u0438\u0432\u043e\u043a \u0430\u0432\u0442\u043e\u0444\u0438\u0433\u0443\u0440 \u0432 ppt \u0444\u0430\u0439\u043b\u0430\u0445 !!!\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tif (bf.bfOffBits != 0L) hFile->Seek(off + bf.bfOffBits,SEEK_SET);\r\n\t\t\t}\r\n\t\tswitch (dwCompression) {\r\n\t\t\tcase BI_RGB :\r\n\t\t\t\thFile->Read(info.pImage, head.biSizeImage,1); // read in the pixels\r\n\t\t\t\tbreak;\r\n\t\t\tcase BI_RLE4 :\r\n\t\t\t{\r\n\t\t\t\tuint8_t status_byte = 0;\r\n\t\t\t\tuint8_t second_byte = 0;\r\n\t\t\t\tint32_t scanline = 0;\r\n\t\t\t\tint32_t bits = 0;\r\n\t\t\t\tBOOL low_nibble = FALSE;\r\n\t\t\t\tCImageIterator iter(this);\r\n\r\n\t\t\t\tfor (BOOL bContinue = TRUE; bContinue && hFile->Read(&status_byte, sizeof(uint8_t), 1);) {\r\n\t\t\t\t\t\r\n\t\t\t\t\tswitch (status_byte) {\r\n\t\t\t\t\t\tcase RLE_COMMAND :\r\n\t\t\t\t\t\t\thFile->Read(&status_byte, sizeof(uint8_t), 1);\r\n\t\t\t\t\t\t\tswitch (status_byte) {\r\n\t\t\t\t\t\t\t\tcase RLE_ENDOFLINE :\r\n\t\t\t\t\t\t\t\t\tbits = 0;\r\n\t\t\t\t\t\t\t\t\tscanline++;\r\n\t\t\t\t\t\t\t\t\tlow_nibble = FALSE;\r\n\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\tcase RLE_ENDOFBITMAP :\r\n\t\t\t\t\t\t\t\t\tbContinue=FALSE;\r\n\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\tcase RLE_DELTA :\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t// read the delta values\r\n\t\t\t\t\t\t\t\t\tuint8_t delta_x;\r\n\t\t\t\t\t\t\t\t\tuint8_t delta_y;\r\n\t\t\t\t\t\t\t\t\thFile->Read(&delta_x, sizeof(uint8_t), 1);\r\n\t\t\t\t\t\t\t\t\thFile->Read(&delta_y, sizeof(uint8_t), 1);\r\n\t\t\t\t\t\t\t\t\t// apply them\r\n\t\t\t\t\t\t\t\t\tbits       += delta_x / 2;\r\n\t\t\t\t\t\t\t\t\tscanline   += delta_y;\r\n\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tdefault :\r\n\t\t\t\t\t\t\t\t\thFile->Read(&second_byte, sizeof(uint8_t), 1);\r\n\t\t\t\t\t\t\t\t\tuint8_t *sline = iter.GetRow(scanline);\r\n\t\t\t\t\t\t\t\t\tfor (int32_t i = 0; i < status_byte; i++) {\r\n\t\t\t\t\t\t\t\t\t\tif ((uint8_t*)(sline+bits) < (uint8_t*)(info.pImage+head.biSizeImage)){\r\n\t\t\t\t\t\t\t\t\t\t\tif (low_nibble) {\r\n\t\t\t\t\t\t\t\t\t\t\t\tif (i&1)\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t*(sline + bits) |= (second_byte & 0x0f);\r\n\t\t\t\t\t\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t*(sline + bits) |= (second_byte & 0xf0)>>4;\r\n\t\t\t\t\t\t\t\t\t\t\t\tbits++;\r\n\t\t\t\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t\t\t\tif (i&1)\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t*(sline + bits) = (uint8_t)(second_byte & 0x0f)<<4;\r\n\t\t\t\t\t\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t*(sline + bits) = (uint8_t)(second_byte & 0xf0);\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\tif ((i & 1) && (i != (status_byte - 1)))\r\n\t\t\t\t\t\t\t\t\t\t\thFile->Read(&second_byte, sizeof(uint8_t), 1);\r\n\r\n\t\t\t\t\t\t\t\t\t\tlow_nibble = !low_nibble;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\tif ((((status_byte+1) >> 1) & 1 ) == 1)\r\n\t\t\t\t\t\t\t\t\t\thFile->Read(&second_byte, sizeof(uint8_t), 1);\t\t\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t};\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tdefault :\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tuint8_t *sline = iter.GetRow(scanline);\r\n\t\t\t\t\t\t\thFile->Read(&second_byte, sizeof(uint8_t), 1);\r\n\t\t\t\t\t\t\tfor (unsigned i = 0; i < status_byte; i++) {\r\n\t\t\t\t\t\t\t\tif ((uint8_t*)(sline+bits) < (uint8_t*)(info.pImage+head.biSizeImage)){\r\n\t\t\t\t\t\t\t\t\tif (low_nibble) {\r\n\t\t\t\t\t\t\t\t\t\tif (i&1)\r\n\t\t\t\t\t\t\t\t\t\t\t*(sline + bits) |= (second_byte & 0x0f);\r\n\t\t\t\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t\t\t\t\t*(sline + bits) |= (second_byte & 0xf0)>>4;\r\n\t\t\t\t\t\t\t\t\t\tbits++;\r\n\t\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t\tif (i&1)\r\n\t\t\t\t\t\t\t\t\t\t\t*(sline + bits) = (uint8_t)(second_byte & 0x0f)<<4;\r\n\t\t\t\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t\t\t\t\t*(sline + bits) = (uint8_t)(second_byte & 0xf0);\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tlow_nibble = !low_nibble;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t};\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tcase BI_RLE8 :\r\n\t\t\t{\r\n\t\t\t\tuint8_t status_byte = 0;\r\n\t\t\t\tuint8_t second_byte = 0;\r\n\t\t\t\tint32_t scanline = 0;\r\n\t\t\t\tint32_t bits = 0;\r\n\t\t\t\tCImageIterator iter(this);\r\n\r\n\t\t\t\tfor (BOOL bContinue = TRUE; bContinue && hFile->Read(&status_byte, sizeof(uint8_t), 1);) {\r\n\t\t\t\t\tswitch (status_byte) {\r\n\t\t\t\t\t\tcase RLE_COMMAND :\r\n\t\t\t\t\t\t\thFile->Read(&status_byte, sizeof(uint8_t), 1);\r\n\t\t\t\t\t\t\tswitch (status_byte) {\r\n\t\t\t\t\t\t\t\tcase RLE_ENDOFLINE :\r\n\t\t\t\t\t\t\t\t\tbits = 0;\r\n\t\t\t\t\t\t\t\t\tscanline++;\r\n\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\tcase RLE_ENDOFBITMAP :\r\n\t\t\t\t\t\t\t\t\tbContinue=FALSE;\r\n\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\tcase RLE_DELTA :\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t// read the delta values\r\n\t\t\t\t\t\t\t\t\tuint8_t delta_x;\r\n\t\t\t\t\t\t\t\t\tuint8_t delta_y;\r\n\t\t\t\t\t\t\t\t\thFile->Read(&delta_x, sizeof(uint8_t), 1);\r\n\t\t\t\t\t\t\t\t\thFile->Read(&delta_y, sizeof(uint8_t), 1);\r\n\t\t\t\t\t\t\t\t\t// apply them\r\n\t\t\t\t\t\t\t\t\tbits     += delta_x;\r\n\t\t\t\t\t\t\t\t\tscanline += delta_y;\r\n\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tdefault :\r\n\t\t\t\t\t\t\t\t\thFile->Read((void *)(iter.GetRow(scanline) + bits), sizeof(uint8_t) * status_byte, 1);\r\n\t\t\t\t\t\t\t\t\t// align run length to even number of bytes \r\n\t\t\t\t\t\t\t\t\tif ((status_byte & 1) == 1)\r\n\t\t\t\t\t\t\t\t\t\thFile->Read(&second_byte, sizeof(uint8_t), 1);\t\t\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\tbits += status_byte;\t\t\t\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\tbreak;\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t};\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tdefault :\r\n\t\t\t\t\t\t\tuint8_t *sline = iter.GetRow(scanline);\r\n\t\t\t\t\t\t\thFile->Read(&second_byte, sizeof(uint8_t), 1);\r\n\t\t\t\t\t\t\tfor (unsigned i = 0; i < status_byte; i++) {\r\n\t\t\t\t\t\t\t\tif ((uint8_t*)(sline+bits) < (uint8_t*)(info.pImage+head.biSizeImage)){\r\n\t\t\t\t\t\t\t\t\t*(sline + bits) = second_byte;\r\n\t\t\t\t\t\t\t\t\tbits++;\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t};\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tdefault :\t\t\t\t\t\t\t\t\r\n\t\t\t\tcx_throw(\"compression type not supported\");\r\n\t\t}\r\n\t}\r\n\r\n\tif (bTopDownDib) Flip(); //<Flanders>\r\n\r\n  } cx_catch {\r\n\tif (strcmp(message,\"\")) strncpy(info.szLastError,message,255);\r\n\tif (info.nEscape == -1 && info.dwType == CXIMAGE_FORMAT_BMP) return true;\r\n\treturn false;\r\n  }\r\n    return true;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n/*  ReadDibBitmapInfo()\r\n *\r\n *  Will read a file in DIB format and return a global HANDLE to its\r\n *  BITMAPINFO.  This function will work with both \"old\" and \"new\"\r\n *  bitmap formats, but will always return a \"new\" BITMAPINFO.\r\n */\r\nbool CxImageBMP::DibReadBitmapInfo(CxFile* fh, BITMAPINFOHEADER *pdib)\r\n{\r\n\tif ((fh==NULL)||(pdib==NULL)) return false;\r\n\r\n    if (fh->Read(pdib,sizeof(BITMAPINFOHEADER),1)==0) return false;\r\n\r\n\tbihtoh(pdib);\r\n\r\n    switch (pdib->biSize) // what type of bitmap info is this?\r\n    {\r\n        case sizeof(BITMAPINFOHEADER):\r\n            break;\r\n\r\n\t\tcase 64: //sizeof(OS2_BMP_HEADER):\r\n            fh->Seek((int32_t)(64 - sizeof(BITMAPINFOHEADER)),SEEK_CUR);\r\n\t\t\tbreak;\r\n\r\n        case 124: //sizeof(BITMAPV5HEADER):\r\n\t\t\tfh->Seek((long)(124-sizeof(BITMAPINFOHEADER)), SEEK_CUR);\r\n\t\t\tbreak;\r\n\r\n        case sizeof(BITMAPCOREHEADER):\r\n\t\t{\r\n            BITMAPCOREHEADER bc = *(BITMAPCOREHEADER*)pdib;\r\n            pdib->biSize               = bc.bcSize;\r\n            pdib->biWidth              = (uint32_t)bc.bcWidth;\r\n            pdib->biHeight             = (uint32_t)bc.bcHeight;\r\n            pdib->biPlanes             =  bc.bcPlanes;\r\n            pdib->biBitCount           =  bc.bcBitCount;\r\n            pdib->biCompression        = BI_RGB;\r\n            pdib->biSizeImage          = 0;\r\n            pdib->biXPelsPerMeter      = 0;\r\n            pdib->biYPelsPerMeter      = 0;\r\n            pdib->biClrUsed            = 0;\r\n            pdib->biClrImportant       = 0;\r\n\r\n\t\t\tfh->Seek((int32_t)(sizeof(BITMAPCOREHEADER)-sizeof(BITMAPINFOHEADER)), SEEK_CUR);\r\n\t\t}\r\n            break;\r\n        default:\r\n\t\t\t//give a last chance\r\n\t\t\t if (pdib->biSize>(sizeof(BITMAPINFOHEADER))&&\r\n\t\t\t\t(pdib->biSizeImage>=(uint32_t)(pdib->biHeight*((((pdib->biBitCount*pdib->biWidth)+31)/32)*4)))&&\r\n\t\t\t\t(pdib->biPlanes==1)&&(pdib->biClrUsed==0))\r\n\t\t\t {\r\n\t             if (pdib->biCompression==BI_RGB)\r\n\t\t\t\t\t fh->Seek((int32_t)(pdib->biSize - sizeof(BITMAPINFOHEADER)),SEEK_CUR);\r\n\t\t\t\t break;\r\n\t\t\t }\r\n\t\t\treturn false;\r\n    }\r\n\r\n    FixBitmapInfo(pdib);\r\n\r\n    return true;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n#endif //CXIMAGE_SUPPORT_DECODE\r\n////////////////////////////////////////////////////////////////////////////////\r\n#endif \t// CXIMAGE_SUPPORT_BMP\r\n////////////////////////////////////////////////////////////////////////////////\r\n", "\ufeff// ximage.cpp : main implementation file\r\n/* 07/08/2001 v1.00 - Davide Pizzolato - www.xdp.it\r\n * CxImage version 7.0.2 07/Feb/2011\r\n */\r\n\r\n#include \"ximage.h\"\r\n\r\n#ifndef min\r\n#define min(a,b) (((a)<(b))?(a):(b))\r\n#endif\r\n#ifndef max\r\n#define max(a,b) (((a)>(b))?(a):(b))\r\n#endif\r\n\r\n////////////////////////////////////////////////////////////////////////////////\r\n// CxImage \r\n////////////////////////////////////////////////////////////////////////////////\r\n/**\r\n * Initialize the internal structures\r\n */\r\nvoid CxImage::Startup(uint32_t imagetype)\r\n{\r\n\t//init pointers\r\n\tpDib = pSelection = pAlpha = NULL;\r\n\tppLayers = ppFrames = NULL;\r\n\t//init structures\r\n\tmemset(&head,0,sizeof(BITMAPINFOHEADER));\r\n\tmemset(&info,0,sizeof(CXIMAGEINFO));\r\n\t//init default attributes\r\n    info.dwType = imagetype;\r\n\tinfo.fQuality = 90.0f;\r\n\tinfo.nAlphaMax = 255;\r\n\tinfo.nBkgndIndex = -1;\r\n\tinfo.bEnabled = true;\r\n\tinfo.nJpegScale = 1;\r\n\tSetXDPI(CXIMAGE_DEFAULT_DPI);\r\n\tSetYDPI(CXIMAGE_DEFAULT_DPI);\r\n\r\n\tint16_t test = 1;\r\n\tinfo.bLittleEndianHost = (*((char *) &test) == 1);\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n/**\r\n * Empty image constructor\r\n * \\param imagetype: (optional) set the image format, see ENUM_CXIMAGE_FORMATS\r\n */\r\nCxImage::CxImage(uint32_t imagetype)\r\n{\r\n\tStartup(imagetype);\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n/**\r\n * Call this function to destroy image pixels, alpha channel, selection and sub layers.\r\n * - Attributes are not erased, but IsValid returns false.\r\n *\r\n * \\return true if everything is freed, false if the image is a Ghost\r\n */\r\nbool CxImage::Destroy()\r\n{\r\n\t//free this only if it's valid and it's not a ghost\r\n\tif (info.pGhost==NULL){\r\n\t\tif (ppLayers) { \r\n\t\t\tfor(int32_t n=0; n<info.nNumLayers;n++){ delete ppLayers[n]; }\r\n\t\t\tdelete [] ppLayers; ppLayers=0; info.nNumLayers = 0;\r\n\t\t}\r\n\t\tif (pSelection) {free(pSelection); pSelection=0;}\r\n\t\tif (pAlpha) {free(pAlpha); pAlpha=0;}\r\n\t\tif (pDib) {free(pDib); pDib=0;}\r\n\t\treturn true;\r\n\t}\r\n\treturn false;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\nbool CxImage::DestroyFrames()\r\n{\r\n\tif (info.pGhost==NULL) {\r\n\t\tif (ppFrames) {\r\n\t\t\tfor (int32_t n=0; n<info.nNumFrames; n++) { delete ppFrames[n]; }\r\n\t\t\tdelete [] ppFrames; ppFrames = NULL; info.nNumFrames = 0;\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n\treturn false;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n/**\r\n * Sized image constructor\r\n * \\param dwWidth: width\r\n * \\param dwHeight: height\r\n * \\param wBpp: bit per pixel, can be 1, 4, 8, 24\r\n * \\param imagetype: (optional) set the image format, see ENUM_CXIMAGE_FORMATS\r\n */\r\nCxImage::CxImage(uint32_t dwWidth, uint32_t dwHeight, uint32_t wBpp, uint32_t imagetype)\r\n{\r\n\tStartup(imagetype);\r\n\tCreate(dwWidth,dwHeight,wBpp,imagetype);\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n/**\r\n * image constructor from existing source\r\n * \\param src: source image.\r\n * \\param copypixels: copy the pixels from the source image into the new image.\r\n * \\param copyselection: copy the selection from source\r\n * \\param copyalpha: copy the alpha channel from source\r\n * \\sa Copy\r\n */\r\nCxImage::CxImage(const CxImage &src, bool copypixels, bool copyselection, bool copyalpha)\r\n{\r\n\tStartup(src.GetType());\r\n\tCopy(src,copypixels,copyselection,copyalpha);\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n/**\r\n * Copies the image from an exsisting source\r\n * \\param src: source image.\r\n * \\param copypixels: copy the pixels from the source image into the new image.\r\n * \\param copyselection: copy the selection from source\r\n * \\param copyalpha: copy the alpha channel from source\r\n */\r\nvoid CxImage::Copy(const CxImage &src, bool copypixels, bool copyselection, bool copyalpha)\r\n{\r\n\t// if the source is a ghost, the copy is still a ghost\r\n\tif (src.info.pGhost){\r\n\t\tGhost(&src);\r\n\t\treturn;\r\n\t}\r\n\t//copy the attributes\r\n\tmemcpy(&info,&src.info,sizeof(CXIMAGEINFO));\r\n\tmemcpy(&head,&src.head,sizeof(BITMAPINFOHEADER)); // [andy] - fix for bitmap header DPI\r\n\t//rebuild the image\r\n\tCreate(src.GetWidth(),src.GetHeight(),src.GetBpp(),src.GetType());\r\n\t//copy the pixels and the palette, or at least copy the palette only.\r\n\tif (copypixels && pDib && src.pDib) memcpy(pDib,src.pDib,GetSize());\r\n\telse SetPalette(src.GetPalette());\r\n\tint32_t nSize = head.biWidth * head.biHeight;\r\n\t//copy the selection\r\n\tif (copyselection && src.pSelection){\r\n\t\tif (pSelection) free(pSelection);\r\n\t\tpSelection = (uint8_t*)malloc(nSize);\r\n\t\tmemcpy(pSelection,src.pSelection,nSize);\r\n\t}\r\n\t//copy the alpha channel\r\n\tif (copyalpha && src.pAlpha){\r\n\t\tif (pAlpha) free(pAlpha);\r\n\t\tpAlpha = (uint8_t*)malloc(nSize);\r\n\t\tmemcpy(pAlpha,src.pAlpha,nSize);\r\n\t}\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n/**\r\n * Copies the image attributes from an existing image.\r\n * - Works only on an empty image, and the image will be still empty.\r\n * - <b> Use it before Create() </b>\r\n */\r\nvoid CxImage::CopyInfo(const CxImage &src)\r\n{\r\n\tif (pDib==NULL) memcpy(&info,&src.info,sizeof(CXIMAGEINFO));\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n/**\r\n * \\sa Copy\r\n */\r\nCxImage& CxImage::operator = (const CxImage& isrc)\r\n{\r\n\tif (this != &isrc) Copy(isrc);\r\n\treturn *this;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n/**\r\n * Initializes or rebuilds the image.\r\n * \\param dwWidth: width\r\n * \\param dwHeight: height\r\n * \\param wBpp: bit per pixel, can be 1, 4, 8, 24\r\n * \\param imagetype: (optional) set the image format, see ENUM_CXIMAGE_FORMATS\r\n * \\return pointer to the internal pDib object; NULL if an error occurs.\r\n */\r\nvoid* CxImage::Create(uint32_t dwWidth, uint32_t dwHeight, uint32_t wBpp, uint32_t imagetype)\r\n{\r\n\t// destroy the existing image (if any)\r\n\tif (!Destroy())\r\n\t\treturn NULL;\r\n\r\n\t// prevent further actions if width or height are not vaild <Balabasnia>\r\n\tif ((dwWidth == 0) || (dwHeight == 0)){\r\n\t\tstrcpy(info.szLastError,\"CxImage::Create : width and height must be greater than zero\");\r\n\t\treturn NULL;\r\n\t}\r\n\r\n    // Make sure bits per pixel is valid\r\n    if\t\t(wBpp <= 1)\twBpp = 1;\r\n    else if (wBpp <= 4)\twBpp = 4;\r\n    else if (wBpp <= 8)\twBpp = 8;\r\n    else\t\t\t\twBpp = 24;\r\n\r\n\t// limit memory requirements\r\n\tif ((((float)dwWidth*(float)dwHeight*(float)wBpp)/8.0f) > (float)CXIMAGE_MAX_MEMORY)\r\n\t{\r\n\t\tstrcpy(info.szLastError,\"CXIMAGE_MAX_MEMORY exceeded\");\r\n\t\treturn NULL;\r\n\t}\r\n\r\n\t// set the correct bpp value\r\n    switch (wBpp){\r\n        case 1:\r\n            head.biClrUsed = 2;\tbreak;\r\n        case 4:\r\n            head.biClrUsed = 16; break;\r\n        case 8:\r\n            head.biClrUsed = 256; break;\r\n        default:\r\n            head.biClrUsed = 0;\r\n    }\r\n\r\n\t//set the common image informations\r\n    info.dwEffWidth = ((((wBpp * dwWidth) + 31) / 32) * 4);\r\n    info.dwType = imagetype;\r\n\r\n    // initialize BITMAPINFOHEADER\r\n\thead.biSize = sizeof(BITMAPINFOHEADER); //<ralphw>\r\n    head.biWidth = dwWidth;\t\t// fill in width from parameter\r\n    head.biHeight = dwHeight;\t// fill in height from parameter\r\n    head.biPlanes = 1;\t\t\t// must be 1\r\n    head.biBitCount = (uint16_t)wBpp;\t\t// from parameter\r\n    head.biCompression = BI_RGB;    \r\n    head.biSizeImage = info.dwEffWidth * dwHeight;\r\n//    head.biXPelsPerMeter = 0; See SetXDPI\r\n//    head.biYPelsPerMeter = 0; See SetYDPI\r\n//    head.biClrImportant = 0;  See SetClrImportant\r\n\r\n\tpDib = malloc(GetSize()); // alloc memory block to store our bitmap\r\n    if (!pDib){\r\n\t\tstrcpy(info.szLastError,\"CxImage::Create can't allocate memory\");\r\n\t\treturn NULL;\r\n\t}\r\n\r\n\t//clear the palette\r\n\tRGBQUAD* pal=GetPalette();\r\n\tif (pal) memset(pal,0,GetPaletteSize());\r\n\t//Destroy the existing selection\r\n#if CXIMAGE_SUPPORT_SELECTION\r\n\tif (pSelection) SelectionDelete();\r\n#endif //CXIMAGE_SUPPORT_SELECTION\r\n\t//Destroy the existing alpha channel\r\n#if CXIMAGE_SUPPORT_ALPHA\r\n\tif (pAlpha) AlphaDelete();\r\n#endif //CXIMAGE_SUPPORT_ALPHA\r\n\r\n    // use our bitmap info structure to fill in first part of\r\n    // our DIB with the BITMAPINFOHEADER\r\n    BITMAPINFOHEADER*  lpbi;\r\n\tlpbi = (BITMAPINFOHEADER*)(pDib);\r\n    *lpbi = head;\r\n\r\n\tinfo.pImage=GetBits();\r\n\r\n    return pDib; //return handle to the DIB\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n/**\r\n * \\return pointer to the image pixels. <b> USE CAREFULLY </b>\r\n */\r\nuint8_t* CxImage::GetBits(uint32_t row)\r\n{ \r\n\tif (pDib){\r\n\t\tif (row) {\r\n\t\t\tif (row<(uint32_t)head.biHeight){\r\n\t\t\t\treturn ((uint8_t*)pDib + *(uint32_t*)pDib + GetPaletteSize() + (info.dwEffWidth * row));\r\n\t\t\t} else {\r\n\t\t\t\treturn NULL;\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\treturn ((uint8_t*)pDib + *(uint32_t*)pDib + GetPaletteSize());\r\n\t\t}\r\n\t}\r\n\treturn NULL;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n/**\r\n * \\return the size in bytes of the internal pDib object\r\n */\r\nint32_t CxImage::GetSize()\r\n{\r\n\treturn head.biSize + head.biSizeImage + GetPaletteSize();\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n/**\r\n * Checks if the coordinates are inside the image\r\n * \\return true if x and y are both inside the image\r\n */\r\nbool CxImage::IsInside(int32_t x, int32_t y)\r\n{\r\n  return (0<=y && y<head.biHeight && 0<=x && x<head.biWidth);\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n/**\r\n * Sets the image bits to the specified value\r\n * - for indexed images, the output color is set by the palette entries.\r\n * - for RGB images, the output color is a shade of gray.\r\n */\r\nvoid CxImage::Clear(uint8_t bval)\r\n{\r\n\tif (pDib == 0) return;\r\n\r\n\tif (GetBpp() == 1){\r\n\t\tif (bval > 0) bval = 255;\r\n\t}\r\n\tif (GetBpp() == 4){\r\n\t\tbval = (uint8_t)(17*(0x0F & bval));\r\n\t}\r\n\r\n\tmemset(info.pImage,bval,head.biSizeImage);\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n/**\r\n * Transfers the image from an existing source image. The source becomes empty.\r\n * \\return true if everything is ok\r\n */\r\nbool CxImage::Transfer(CxImage &from, bool bTransferFrames /*=true*/)\r\n{\r\n\tif (!Destroy())\r\n\t\treturn false;\r\n\r\n\tmemcpy(&head,&from.head,sizeof(BITMAPINFOHEADER));\r\n\tmemcpy(&info,&from.info,sizeof(CXIMAGEINFO));\r\n\r\n\tpDib = from.pDib;\r\n\tpSelection = from.pSelection;\r\n\tpAlpha = from.pAlpha;\r\n\tppLayers = from.ppLayers;\r\n\r\n\tmemset(&from.head,0,sizeof(BITMAPINFOHEADER));\r\n\tmemset(&from.info,0,sizeof(CXIMAGEINFO));\r\n\tfrom.pDib = from.pSelection = from.pAlpha = NULL;\r\n\tfrom.ppLayers = NULL;\r\n\r\n\tif (bTransferFrames){\r\n\t\tDestroyFrames();\r\n\t\tppFrames = from.ppFrames;\r\n\t\tfrom.ppFrames = NULL;\r\n\t}\r\n\r\n\treturn true;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n/**\r\n * (this) points to the same pDib owned by (*from), the image remains in (*from)\r\n * but (this) has the access to the pixels. <b>Use carefully !!!</b>\r\n */\r\nvoid CxImage::Ghost(const CxImage *from)\r\n{\r\n\tif (from){\r\n\t\tmemcpy(&head,&from->head,sizeof(BITMAPINFOHEADER));\r\n\t\tmemcpy(&info,&from->info,sizeof(CXIMAGEINFO));\r\n\t\tpDib = from->pDib;\r\n\t\tpSelection = from->pSelection;\r\n\t\tpAlpha = from->pAlpha;\r\n\t\tppLayers = from->ppLayers;\r\n\t\tppFrames = from->ppFrames;\r\n\t\tinfo.pGhost=(CxImage *)from;\r\n\t}\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n/**\r\n * turns a 16 or 32 bit bitfield image into a RGB image\r\n */\r\nvoid CxImage::Bitfield2RGB(uint8_t *src, uint32_t redmask, uint32_t greenmask, uint32_t bluemask, uint8_t bpp)\r\n{\r\n\tswitch (bpp){\r\n\tcase 16:\r\n\t{\r\n\t\tuint32_t ns[3]={0,0,0};\r\n\t\t// compute the number of shift for each mask\r\n\t\tfor (int32_t i=0;i<16;i++){\r\n\t\t\tif ((redmask>>i)&0x01) ns[0]++;\r\n\t\t\tif ((greenmask>>i)&0x01) ns[1]++;\r\n\t\t\tif ((bluemask>>i)&0x01) ns[2]++;\r\n\t\t}\r\n\t\tns[1]+=ns[0]; ns[2]+=ns[1];\tns[0]=8-ns[0]; ns[1]-=8; ns[2]-=8;\r\n\t\t// dword aligned width for 16 bit image\r\n\t\tint32_t effwidth2=(((head.biWidth + 1) / 2) * 4);\r\n\t\tuint16_t w;\r\n\t\tint32_t y2,y3,x2,x3;\r\n\t\tuint8_t *p=info.pImage;\r\n\t\t// scan the buffer in reverse direction to avoid reallocations\r\n\t\tfor (int32_t y=head.biHeight-1; y>=0; y--){\r\n\t\t\ty2=effwidth2*y;\r\n\t\t\ty3=info.dwEffWidth*y;\r\n\t\t\tfor (int32_t x=head.biWidth-1; x>=0; x--){\r\n\t\t\t\tx2 = 2*x+y2;\r\n\t\t\t\tx3 = 3*x+y3;\r\n\t\t\t\tw = (uint16_t)(src[x2]+256*src[1+x2]);\r\n\t\t\t\tp[  x3]=(uint8_t)((w & bluemask)<<ns[0]);\r\n\t\t\t\tp[1+x3]=(uint8_t)((w & greenmask)>>ns[1]);\r\n\t\t\t\tp[2+x3]=(uint8_t)((w & redmask)>>ns[2]);\r\n\t\t\t}\r\n\t\t}\r\n\t\tbreak;\r\n\t}\r\n\tcase 32:\r\n\t{\r\n\t\tuint32_t ns[3]={0,0,0};\r\n\t\t// compute the number of shift for each mask\r\n\t\tfor (int32_t i=8;i<32;i+=8){\r\n\t\t\tif (redmask>>i) ns[0]++;\r\n\t\t\tif (greenmask>>i) ns[1]++;\r\n\t\t\tif (bluemask>>i) ns[2]++;\r\n\t\t}\r\n\t\t// dword aligned width for 32 bit image\r\n\t\tint32_t effwidth4 = head.biWidth * 4;\r\n\t\tint32_t y4,y3,x4,x3;\r\n\t\tuint8_t *p=info.pImage;\r\n\t\t// scan the buffer in reverse direction to avoid reallocations\r\n\t\tfor (int32_t y=head.biHeight-1; y>=0; y--){\r\n\t\t\ty4=effwidth4*y;\r\n\t\t\ty3=info.dwEffWidth*y;\r\n\t\t\tfor (int32_t x=head.biWidth-1; x>=0; x--){\r\n\t\t\t\tx4 = 4*x+y4;\r\n\t\t\t\tx3 = 3*x+y3;\r\n\t\t\t\tp[  x3]=src[ns[2]+x4];\r\n\t\t\t\tp[1+x3]=src[ns[1]+x4];\r\n\t\t\t\tp[2+x3]=src[ns[0]+x4];\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t}\r\n\treturn;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n/**\r\n * Creates an image from a generic buffer\r\n * \\param pArray: source memory buffer\r\n * \\param dwWidth: image width\r\n * \\param dwHeight: image height\r\n * \\param dwBitsperpixel: can be 1,4,8,24,32\r\n * \\param dwBytesperline: line alignment, in bytes, for a single row stored in pArray\r\n * \\param bFlipImage: tune this parameter if the image is upsidedown\r\n * \\return true if everything is ok\r\n */\r\nbool CxImage::CreateFromArray(uint8_t* pArray,uint32_t dwWidth,uint32_t dwHeight,uint32_t dwBitsperpixel, uint32_t dwBytesperline, bool bFlipImage)\r\n{\r\n\tif (pArray==NULL) return false;\r\n\tif (!((dwBitsperpixel==1)||(dwBitsperpixel==4)||(dwBitsperpixel==8)||\r\n\t\t(dwBitsperpixel==24)||(dwBitsperpixel==32))) return false;\r\n\r\n\tif (!Create(dwWidth,dwHeight,dwBitsperpixel)) return false;\r\n\r\n\tif (dwBitsperpixel<24) SetGrayPalette();\r\n\r\n#if CXIMAGE_SUPPORT_ALPHA\r\n\tif (dwBitsperpixel==32) AlphaCreate();\r\n#endif //CXIMAGE_SUPPORT_ALPHA\r\n\r\n\tuint8_t *dst,*src;\r\n\r\n\tfor (uint32_t y = 0; y<dwHeight; y++) {\r\n\t\tdst = info.pImage + (bFlipImage?(dwHeight-1-y):y) * info.dwEffWidth;\r\n\t\tsrc = pArray + y * dwBytesperline;\r\n\t\tif (dwBitsperpixel==32){\r\n\t\t\tfor(uint32_t x=0;x<dwWidth;x++){\r\n\t\t\t\t*dst++=src[0];\r\n\t\t\t\t*dst++=src[1];\r\n\t\t\t\t*dst++=src[2];\r\n#if CXIMAGE_SUPPORT_ALPHA\r\n\t\t\t\tAlphaSet(x,(bFlipImage?(dwHeight-1-y):y),src[3]);\r\n#endif //CXIMAGE_SUPPORT_ALPHA\r\n\t\t\t\tsrc+=4;\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tmemcpy(dst,src,min(info.dwEffWidth,dwBytesperline));\r\n\t\t}\r\n\t}\r\n\treturn true;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n/**\r\n * \\sa CreateFromArray\r\n */\r\nbool CxImage::CreateFromMatrix(uint8_t** ppMatrix,uint32_t dwWidth,uint32_t dwHeight,uint32_t dwBitsperpixel, uint32_t dwBytesperline, bool bFlipImage)\r\n{\r\n\tif (ppMatrix==NULL) return false;\r\n\tif (!((dwBitsperpixel==1)||(dwBitsperpixel==4)||(dwBitsperpixel==8)||\r\n\t\t(dwBitsperpixel==24)||(dwBitsperpixel==32))) return false;\r\n\r\n\tif (!Create(dwWidth,dwHeight,dwBitsperpixel)) return false;\r\n\r\n\tif (dwBitsperpixel<24) SetGrayPalette();\r\n\r\n#if CXIMAGE_SUPPORT_ALPHA\r\n\tif (dwBitsperpixel==32) AlphaCreate();\r\n#endif //CXIMAGE_SUPPORT_ALPHA\r\n\r\n\tuint8_t *dst,*src;\r\n\r\n\tfor (uint32_t y = 0; y<dwHeight; y++) {\r\n\t\tdst = info.pImage + (bFlipImage?(dwHeight-1-y):y) * info.dwEffWidth;\r\n\t\tsrc = ppMatrix[y];\r\n\t\tif (src){\r\n\t\t\tif (dwBitsperpixel==32){\r\n\t\t\t\tfor(uint32_t x=0;x<dwWidth;x++){\r\n\t\t\t\t\t*dst++=src[0];\r\n\t\t\t\t\t*dst++=src[1];\r\n\t\t\t\t\t*dst++=src[2];\r\n#if CXIMAGE_SUPPORT_ALPHA\r\n\t\t\t\t\tAlphaSet(x,(bFlipImage?(dwHeight-1-y):y),src[3]);\r\n#endif //CXIMAGE_SUPPORT_ALPHA\r\n\t\t\t\t\tsrc+=4;\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tmemcpy(dst,src,min(info.dwEffWidth,dwBytesperline));\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn true;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n/**\r\n * \\return lightness difference between elem1 and elem2\r\n */\r\nint32_t CxImage::CompareColors(const void *elem1, const void *elem2)\r\n{\r\n\tRGBQUAD* c1 = (RGBQUAD*)elem1;\r\n\tRGBQUAD* c2 = (RGBQUAD*)elem2;\r\n\r\n\tint32_t g1 = (int32_t)RGB2GRAY(c1->rgbRed,c1->rgbGreen,c1->rgbBlue);\r\n\tint32_t g2 = (int32_t)RGB2GRAY(c2->rgbRed,c2->rgbGreen,c2->rgbBlue);\r\n\t\r\n\treturn (g1-g2);\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n/**\r\n * simply calls \"if (memblock) free(memblock);\".\r\n * Useful when calling Encode for a memory buffer,\r\n * from a DLL compiled with different memory management options.\r\n * CxImage::FreeMemory will use the same memory environment used by Encode. \r\n * \\author [livecn]\r\n */\r\nvoid CxImage::FreeMemory(void* memblock)\r\n{\r\n\tif (memblock)\r\n\t\tfree(memblock);\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n//EOF\r\n", "\ufeff/*\r\n * File:\tximage.h\r\n * Purpose:\tGeneral Purpose Image Class \r\n */\r\n/*\r\n  --------------------------------------------------------------------------------\r\n\r\n\tCOPYRIGHT NOTICE, DISCLAIMER, and LICENSE:\r\n\r\n\tCxImage version 7.0.2 07/Feb/2011\r\n\r\n\tCxImage : Copyright (C) 2001 - 2010, Davide Pizzolato\r\n\r\n\tOriginal CImage and CImageIterator implementation are:\r\n\tCopyright (C) 1995, Alejandro Aguilar Sierra (asierra(at)servidor(dot)unam(dot)mx)\r\n\r\n\tCovered code is provided under this license on an \"as is\" basis, without warranty\r\n\tof any kind, either expressed or implied, including, without limitation, warranties\r\n\tthat the covered code is free of defects, merchantable, fit for a particular purpose\r\n\tor non-infringing. The entire risk as to the quality and performance of the covered\r\n\tcode is with you. Should any covered code prove defective in any respect, you (not\r\n\tthe initial developer or any other contributor) assume the cost of any necessary\r\n\tservicing, repair or correction. This disclaimer of warranty constitutes an essential\r\n\tpart of this license. No use of any covered code is authorized hereunder except under\r\n\tthis disclaimer.\r\n\r\n\tPermission is hereby granted to use, copy, modify, and distribute this\r\n\tsource code, or portions hereof, for any purpose, including commercial applications,\r\n\tfreely and without fee, subject to the following restrictions: \r\n\r\n\t1. The origin of this software must not be misrepresented; you must not\r\n\tclaim that you wrote the original software. If you use this software\r\n\tin a product, an acknowledgment in the product documentation would be\r\n\tappreciated but is not required.\r\n\r\n\t2. Altered source versions must be plainly marked as such, and must not be\r\n\tmisrepresented as being the original software.\r\n\r\n\t3. This notice may not be removed or altered from any source distribution.\r\n\r\n  --------------------------------------------------------------------------------\r\n\r\n\tOther information about CxImage, and the latest version, can be found at the\r\n\tCxImage home page: http://www.xdp.it/cximage/\r\n\r\n  --------------------------------------------------------------------------------\r\n */\r\n#if !defined(__CXIMAGE_H)\r\n#define __CXIMAGE_H\r\n\r\n#if _MSC_VER > 1000\r\n#pragma once\r\n#endif \r\n\r\n#ifdef _LINUX\r\n  #define _XOPEN_SOURCE\r\n  #include <unistd.h>\r\n  #include <arpa/inet.h>\r\n#endif\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\n#include \"xfile.h\"\r\n#include \"xiofile.h\"\r\n#include \"xmemfile.h\"\r\n#include \"ximadef.h\"\t//<vho> adjust some #define\r\n\r\n/* see \"ximacfg.h\" for CxImage configuration options */\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\n// CxImage formats enumerator\r\nenum ENUM_CXIMAGE_FORMATS{\r\nCXIMAGE_FORMAT_UNKNOWN = 0,\r\n#if CXIMAGE_SUPPORT_BMP\r\nCXIMAGE_FORMAT_BMP = 1,\r\n#endif\r\n#if CXIMAGE_SUPPORT_GIF\r\nCXIMAGE_FORMAT_GIF = 2,\r\n#endif\r\n#if CXIMAGE_SUPPORT_JPG\r\nCXIMAGE_FORMAT_JPG = 3,\r\n#endif\r\n#if CXIMAGE_SUPPORT_PNG\r\nCXIMAGE_FORMAT_PNG = 4,\r\n#endif\r\n#if CXIMAGE_SUPPORT_ICO\r\nCXIMAGE_FORMAT_ICO = 5,\r\n#endif\r\n#if CXIMAGE_SUPPORT_TIF\r\nCXIMAGE_FORMAT_TIF = 6,\r\n#endif\r\n#if CXIMAGE_SUPPORT_TGA\r\nCXIMAGE_FORMAT_TGA = 7,\r\n#endif\r\n#if CXIMAGE_SUPPORT_PCX\r\nCXIMAGE_FORMAT_PCX = 8,\r\n#endif\r\n#if CXIMAGE_SUPPORT_WBMP\r\nCXIMAGE_FORMAT_WBMP = 9,\r\n#endif\r\n#if CXIMAGE_SUPPORT_WMF\r\nCXIMAGE_FORMAT_WMF = 10,\r\n#endif\r\n#if CXIMAGE_SUPPORT_JP2\r\nCXIMAGE_FORMAT_JP2 = 11,\r\n#endif\r\n#if CXIMAGE_SUPPORT_JPC\r\nCXIMAGE_FORMAT_JPC = 12,\r\n#endif\r\n#if CXIMAGE_SUPPORT_PGX\r\nCXIMAGE_FORMAT_PGX = 13,\r\n#endif\r\n#if CXIMAGE_SUPPORT_PNM\r\nCXIMAGE_FORMAT_PNM = 14,\r\n#endif\r\n#if CXIMAGE_SUPPORT_RAS\r\nCXIMAGE_FORMAT_RAS = 15,\r\n#endif\r\n#if CXIMAGE_SUPPORT_JBG\r\nCXIMAGE_FORMAT_JBG = 16,\r\n#endif\r\n#if CXIMAGE_SUPPORT_MNG\r\nCXIMAGE_FORMAT_MNG = 17,\r\n#endif\r\n#if CXIMAGE_SUPPORT_SKA\r\nCXIMAGE_FORMAT_SKA = 18,\r\n#endif\r\n#if CXIMAGE_SUPPORT_RAW\r\nCXIMAGE_FORMAT_RAW = 19,\r\n#endif\r\n#if CXIMAGE_SUPPORT_PSD\r\nCXIMAGE_FORMAT_PSD = 20,\r\n#endif\r\nCMAX_IMAGE_FORMATS = CXIMAGE_SUPPORT_BMP + CXIMAGE_SUPPORT_GIF + CXIMAGE_SUPPORT_JPG +\r\n\t\t\t\t\t CXIMAGE_SUPPORT_PNG + CXIMAGE_SUPPORT_MNG + CXIMAGE_SUPPORT_ICO +\r\n\t\t\t\t\t CXIMAGE_SUPPORT_TIF + CXIMAGE_SUPPORT_TGA + CXIMAGE_SUPPORT_PCX +\r\n\t\t\t\t\t CXIMAGE_SUPPORT_WBMP+ CXIMAGE_SUPPORT_WMF +\r\n\t\t\t\t\t CXIMAGE_SUPPORT_JBG + CXIMAGE_SUPPORT_JP2 + CXIMAGE_SUPPORT_JPC +\r\n\t\t\t\t\t CXIMAGE_SUPPORT_PGX + CXIMAGE_SUPPORT_PNM + CXIMAGE_SUPPORT_RAS +\r\n\t\t\t\t\t CXIMAGE_SUPPORT_SKA + CXIMAGE_SUPPORT_RAW + CXIMAGE_SUPPORT_PSD + 1\r\n};\r\n\r\n#if CXIMAGE_SUPPORT_EXIF\r\n\r\n#define MAX_COMMENT 255\r\n#define MAX_SECTIONS 20\r\n\r\ntypedef struct tag_ExifInfo {\r\n\tchar  Version      [5];\r\n    char  CameraMake   [32];\r\n    char  CameraModel  [40];\r\n    char  DateTime     [20];\r\n    int32_t   Height, Width;\r\n    int32_t   Orientation;\r\n    int32_t   IsColor;\r\n    int32_t   Process;\r\n    int32_t   FlashUsed;\r\n    float FocalLength;\r\n    float ExposureTime;\r\n    float ApertureFNumber;\r\n    float Distance;\r\n    float CCDWidth;\r\n    float ExposureBias;\r\n    int32_t   Whitebalance;\r\n    int32_t   MeteringMode;\r\n    int32_t   ExposureProgram;\r\n    int32_t   ISOequivalent;\r\n    int32_t   CompressionLevel;\r\n\tfloat FocalplaneXRes;\r\n\tfloat FocalplaneYRes;\r\n\tfloat FocalplaneUnits;\r\n\tfloat Xresolution;\r\n\tfloat Yresolution;\r\n\tfloat ResolutionUnit;\r\n\tfloat Brightness;\r\n    char  Comments[MAX_COMMENT+1];\r\n\r\n    uint8_t * ThumbnailPointer;  /* Pointer at the thumbnail */\r\n    unsigned ThumbnailSize;     /* Size of thumbnail. */\r\n\r\n\tbool  IsExif;\r\n} EXIFINFO;\r\n\r\n#endif //CXIMAGE_SUPPORT_EXIF\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\n// CxImage class\r\n/////////////////////////////////////////////////////////////////////////////\r\nclass DLL_EXP CxImage\r\n{\r\n//extensible information collector\r\ntypedef struct tagCxImageInfo {\r\n\tuint32_t\tdwEffWidth;\t\t\t///< uint32_t aligned scan line width\r\n\tuint8_t*\tpImage;\t\t\t\t///< THE IMAGE BITS\r\n\tCxImage* pGhost;\t\t\t///< if this is a ghost, pGhost points to the body\r\n\tCxImage* pParent;\t\t\t///< if this is a layer, pParent points to the body\r\n\tuint32_t\tdwType;\t\t\t\t///< original image format\r\n\tchar\tszLastError[256];\t///< debugging\r\n\tint32_t\tnProgress;\t\t\t///< monitor\r\n\tint32_t\tnEscape;\t\t\t///< escape\r\n\tint32_t\tnBkgndIndex;\t\t///< used for GIF, PNG, MNG\r\n\tRGBQUAD nBkgndColor;\t\t///< used for RGB transparency\r\n\tfloat\tfQuality;\t\t\t///< used for JPEG, JPEG2000 (0.0f ... 100.0f)\r\n\tuint8_t\tnJpegScale;\t\t\t///< used for JPEG [ignacio]\r\n\tint32_t\tnFrame;\t\t\t\t///< used for TIF, GIF, MNG : actual frame\r\n\tint32_t\tnNumFrames;\t\t\t///< used for TIF, GIF, MNG : total number of frames\r\n\tuint32_t\tdwFrameDelay;\t\t///< used for GIF, MNG\r\n\tint32_t\txDPI;\t\t\t\t///< horizontal resolution\r\n\tint32_t\tyDPI;\t\t\t\t///< vertical resolution\r\n\tRECT\trSelectionBox;\t\t///< bounding rectangle\r\n\tuint8_t\tnAlphaMax;\t\t\t///< max opacity (fade)\r\n\tbool\tbAlphaPaletteEnabled; ///< true if alpha values in the palette are enabled.\r\n\tbool\tbEnabled;\t\t\t///< enables the painting functions\r\n\tint32_t\txOffset;\r\n\tint32_t\tyOffset;\r\n\tuint32_t\tdwCodecOpt[CMAX_IMAGE_FORMATS];\t///< for GIF, TIF : 0=def.1=unc,2=fax3,3=fax4,4=pack,5=jpg\r\n\tRGBQUAD last_c;\t\t\t\t///< for GetNearestIndex optimization\r\n\tuint8_t\tlast_c_index;\r\n\tbool\tlast_c_isvalid;\r\n\tint32_t\tnNumLayers;\r\n\tuint32_t\tdwFlags;\t\t\t///< 0x??00000 = reserved, 0x00??0000 = blend mode, 0x0000???? = layer id - user flags\r\n\tuint8_t\tdispmeth;\r\n\tbool\tbGetAllFrames;\r\n\tbool\tbLittleEndianHost;\r\n\r\n#if CXIMAGE_SUPPORT_EXIF\r\n\tEXIFINFO ExifInfo;\r\n#endif\r\n\r\n} CXIMAGEINFO;\r\n\r\npublic:\r\n\t//public structures\r\nstruct rgb_color { uint8_t r,g,b; };\r\n\r\n#if CXIMAGE_SUPPORT_WINDOWS\r\n// <VATI> text placement data\r\n// members must be initialized with the InitTextInfo(&this) function.\r\ntypedef struct tagCxTextInfo\r\n{\r\n#if defined (_WIN32_WCE)\r\n\tTCHAR    text[256];  ///< text for windows CE\r\n#else\r\n\tTCHAR    text[4096]; ///< text (char -> TCHAR for UNICODE [Cesar M])\r\n#endif\r\n\tLOGFONT  lfont;      ///< font and codepage data\r\n    COLORREF fcolor;     ///< foreground color\r\n    int32_t     align;      ///< DT_CENTER, DT_RIGHT, DT_LEFT aligment for multiline text\r\n    uint8_t     smooth;     ///< text smoothing option. Default is false.\r\n    uint8_t     opaque;     ///< text has background or hasn't. Default is true.\r\n\t\t\t\t\t\t ///< data for background (ignored if .opaque==FALSE) \r\n    COLORREF bcolor;     ///< background color\r\n    float    b_opacity;  ///< opacity value for background between 0.0-1.0 Default is 0. (opaque)\r\n    uint8_t     b_outline;  ///< outline width for background (zero: no outline)\r\n    uint8_t     b_round;    ///< rounding radius for background rectangle. % of the height, between 0-50. Default is 10.\r\n                         ///< (backgr. always has a frame: width = 3 pixel + 10% of height by default.)\r\n} CXTEXTINFO;\r\n#endif\r\n\r\npublic:\r\n/** \\addtogroup Constructors */ //@{\r\n\tCxImage(uint32_t imagetype = 0);\r\n\tCxImage(uint32_t dwWidth, uint32_t dwHeight, uint32_t wBpp, uint32_t imagetype = 0);\r\n\tCxImage(const CxImage &src, bool copypixels = true, bool copyselection = true, bool copyalpha = true);\r\n#if CXIMAGE_SUPPORT_DECODE\r\n\tCxImage(const TCHAR * filename, uint32_t imagetype);\t// For UNICODE support: char -> TCHAR\r\n\tCxImage(FILE * stream, uint32_t imagetype);\r\n\tCxImage(CxFile * stream, uint32_t imagetype);\r\n\tCxImage(uint8_t * buffer, uint32_t size, uint32_t imagetype);\r\n#endif\r\n\tvirtual ~CxImage() { DestroyFrames(); Destroy(); };\r\n\tCxImage& operator = (const CxImage&);\r\n//@}\r\n\r\n/** \\addtogroup Initialization */ //@{\r\n\tvoid*\tCreate(uint32_t dwWidth, uint32_t dwHeight, uint32_t wBpp, uint32_t imagetype = 0);\r\n\tbool\tDestroy();\r\n\tbool\tDestroyFrames();\r\n\tvoid\tClear(uint8_t bval=0);\r\n\tvoid\tCopy(const CxImage &src, bool copypixels = true, bool copyselection = true, bool copyalpha = true);\r\n\tbool\tTransfer(CxImage &from, bool bTransferFrames = true);\r\n\tbool\tCreateFromArray(uint8_t* pArray,uint32_t dwWidth,uint32_t dwHeight,uint32_t dwBitsperpixel, uint32_t dwBytesperline, bool bFlipImage);\r\n\tbool\tCreateFromMatrix(uint8_t** ppMatrix,uint32_t dwWidth,uint32_t dwHeight,uint32_t dwBitsperpixel, uint32_t dwBytesperline, bool bFlipImage);\r\n\tvoid\tFreeMemory(void* memblock);\r\n\r\n\tuint32_t Dump(uint8_t * dst);\r\n\tuint32_t UnDump(const uint8_t * src);\r\n\tuint32_t DumpSize();\r\n\r\n//@}\r\n\r\n/** \\addtogroup Attributes */ //@{\r\n\tint32_t\tGetSize();\r\n\tuint8_t*\tGetBits(uint32_t row = 0);\r\n\tuint8_t\tGetColorType();\r\n\tvoid*\tGetDIB() const;\r\n\tuint32_t\tGetHeight() const;\r\n\tuint32_t\tGetWidth() const;\r\n\tuint32_t\tGetEffWidth() const;\r\n\tuint32_t\tGetNumColors() const;\r\n\tuint16_t\tGetBpp() const;\r\n\tuint32_t\tGetType() const;\r\n\tconst char*\tGetLastError();\r\n\tstatic const TCHAR* GetVersion();\r\n\tstatic const float GetVersionNumber();\r\n\r\n\tuint32_t\tGetFrameDelay() const;\r\n\tvoid\tSetFrameDelay(uint32_t d);\r\n\r\n\tvoid\tGetOffset(int32_t *x,int32_t *y);\r\n\tvoid\tSetOffset(int32_t x,int32_t y);\r\n\r\n\tuint8_t\tGetJpegQuality() const;\r\n\tvoid\tSetJpegQuality(uint8_t q);\r\n\tfloat\tGetJpegQualityF() const;\r\n\tvoid\tSetJpegQualityF(float q);\r\n\r\n\tuint8_t\tGetJpegScale() const;\r\n\tvoid\tSetJpegScale(uint8_t q);\r\n\r\n#if CXIMAGE_SUPPORT_EXIF\r\n\tEXIFINFO *GetExifInfo() {return &info.ExifInfo;};\r\n\tbool  GetExifThumbnail(const TCHAR *filename, const TCHAR *outname, int32_t imageType);\r\n  #if CXIMAGE_SUPPORT_TRANSFORMATION\r\n\tbool  RotateExif(int32_t orientation = 0);\r\n  #endif\r\n#endif\r\n\r\n\tint32_t\tGetXDPI() const;\r\n\tint32_t\tGetYDPI() const;\r\n\tvoid\tSetXDPI(int32_t dpi);\r\n\tvoid\tSetYDPI(int32_t dpi);\r\n\r\n\tuint32_t\tGetClrImportant() const;\r\n\tvoid\tSetClrImportant(uint32_t ncolors = 0);\r\n\r\n\tint32_t\tGetProgress() const;\r\n\tint32_t\tGetEscape() const;\r\n\tvoid\tSetProgress(int32_t p);\r\n\tvoid\tSetEscape(int32_t i);\r\n\r\n\tint32_t\tGetTransIndex() const;\r\n\tRGBQUAD\tGetTransColor();\r\n\tvoid\tSetTransIndex(int32_t idx);\r\n\tvoid\tSetTransColor(RGBQUAD rgb);\r\n\tbool\tIsTransparent() const;\r\n\r\n\tuint32_t\tGetCodecOption(uint32_t imagetype = 0);\r\n\tbool\tSetCodecOption(uint32_t opt, uint32_t imagetype = 0);\r\n\r\n\tuint32_t\tGetFlags() const;\r\n\tvoid\tSetFlags(uint32_t flags, bool bLockReservedFlags = true);\r\n\r\n\tuint8_t\tGetDisposalMethod() const;\r\n\tvoid\tSetDisposalMethod(uint8_t dm);\r\n\r\n\tbool\tSetType(uint32_t type);\r\n\r\n\tstatic uint32_t GetNumTypes();\r\n\tstatic uint32_t GetTypeIdFromName(const TCHAR* ext);\r\n\tstatic uint32_t GetTypeIdFromIndex(const uint32_t index);\r\n\tstatic uint32_t GetTypeIndexFromId(const uint32_t id);\r\n\r\n\tbool\tGetRetreiveAllFrames() const;\r\n\tvoid\tSetRetreiveAllFrames(bool flag);\r\n\tCxImage * GetFrame(int32_t nFrame) const;\r\n\r\n\t//void*\tGetUserData() const {return info.pUserData;}\r\n\t//void\tSetUserData(void* pUserData) {info.pUserData = pUserData;}\r\n//@}\r\n\r\n/** \\addtogroup Palette\r\n * These functions have no effects on RGB images and in this case the returned value is always 0.\r\n * @{ */\r\n\tbool\tIsGrayScale();\r\n\tbool\tIsIndexed() const;\r\n\tbool\tIsSamePalette(CxImage &img, bool bCheckAlpha = true);\r\n\tuint32_t\tGetPaletteSize();\r\n\tRGBQUAD* GetPalette() const;\r\n\tRGBQUAD GetPaletteColor(uint8_t idx);\r\n\tbool\tGetPaletteColor(uint8_t i, uint8_t* r, uint8_t* g, uint8_t* b);\r\n\tuint8_t\tGetNearestIndex(RGBQUAD c);\r\n\tvoid\tBlendPalette(COLORREF cr,int32_t perc);\r\n\tvoid\tSetGrayPalette();\r\n\tvoid\tSetPalette(uint32_t n, uint8_t *r, uint8_t *g, uint8_t *b);\r\n\tvoid\tSetPalette(RGBQUAD* pPal,uint32_t nColors=256);\r\n\tvoid\tSetPalette(rgb_color *rgb,uint32_t nColors=256);\r\n\tvoid\tSetPaletteColor(uint8_t idx, uint8_t r, uint8_t g, uint8_t b, uint8_t alpha=0);\r\n\tvoid\tSetPaletteColor(uint8_t idx, RGBQUAD c);\r\n\tvoid\tSetPaletteColor(uint8_t idx, COLORREF cr);\r\n\tvoid\tSwapIndex(uint8_t idx1, uint8_t idx2);\r\n\tvoid\tSwapRGB2BGR();\r\n\tvoid\tSetStdPalette();\r\n//@}\r\n\r\n/** \\addtogroup Pixel */ //@{\r\n\tbool\tIsInside(int32_t x, int32_t y);\r\n\tbool\tIsTransparent(int32_t x,int32_t y);\r\n\tbool\tGetTransparentMask(CxImage* iDst = 0);\r\n\tRGBQUAD GetPixelColor(int32_t x,int32_t y, bool bGetAlpha = true);\r\n\tuint8_t\tGetPixelIndex(int32_t x,int32_t y);\r\n\tuint8_t\tGetPixelGray(int32_t x, int32_t y);\r\n\tvoid\tSetPixelColor(int32_t x,int32_t y,RGBQUAD c, bool bSetAlpha = false);\r\n\tvoid\tSetPixelColor(int32_t x,int32_t y,COLORREF cr);\r\n\tvoid\tSetPixelIndex(int32_t x,int32_t y,uint8_t i);\r\n\tvoid\tDrawLine(int32_t StartX, int32_t EndX, int32_t StartY, int32_t EndY, RGBQUAD color, bool bSetAlpha=false);\r\n\tvoid\tDrawLine(int32_t StartX, int32_t EndX, int32_t StartY, int32_t EndY, COLORREF cr);\r\n\tvoid\tBlendPixelColor(int32_t x,int32_t y,RGBQUAD c, float blend, bool bSetAlpha = false);\r\n\tbool\tSetRectColor(int32_t left, int32_t top, int32_t right, int32_t bottom, RGBQUAD color, bool bSetAlpha = false);\r\n\tbool\tSetRectColor(RECT& rect, RGBQUAD color, bool bSetAlpha = false);\r\n//@}\r\n\r\nprotected:\r\n/** \\addtogroup Protected */ //@{\r\n\tuint8_t BlindGetPixelIndex(const int32_t x,const int32_t y);\r\n\tRGBQUAD BlindGetPixelColor(const int32_t x,const int32_t y, bool bGetAlpha = true);\r\n\tvoid *BlindGetPixelPointer(const int32_t x,const  int32_t y);\r\n\tvoid BlindSetPixelColor(int32_t x,int32_t y,RGBQUAD c, bool bSetAlpha = false);\r\n\tvoid BlindSetPixelIndex(int32_t x,int32_t y,uint8_t i);\r\n//@}\r\n\r\npublic:\r\n\r\n#if CXIMAGE_SUPPORT_INTERPOLATION\r\n/** \\addtogroup Interpolation */ //@{\r\n\t//overflow methods:\r\n\tenum OverflowMethod {\r\n\t\tOM_COLOR=1,\r\n\t\tOM_BACKGROUND=2,\r\n\t\tOM_TRANSPARENT=3,\r\n\t\tOM_WRAP=4,\r\n\t\tOM_REPEAT=5,\r\n\t\tOM_MIRROR=6\r\n\t};\r\n\tvoid OverflowCoordinates(float &x, float &y, OverflowMethod const ofMethod);\r\n\tvoid OverflowCoordinates(int32_t  &x, int32_t &y, OverflowMethod const ofMethod);\r\n\tRGBQUAD GetPixelColorWithOverflow(int32_t x, int32_t y, OverflowMethod const ofMethod=OM_BACKGROUND, RGBQUAD* const rplColor=0);\r\n\t//interpolation methods:\r\n\tenum InterpolationMethod {\r\n\t\tIM_NEAREST_NEIGHBOUR=1,\r\n\t\tIM_BILINEAR\t\t=2,\r\n\t\tIM_BSPLINE\t\t=3,\r\n\t\tIM_BICUBIC\t\t=4,\r\n\t\tIM_BICUBIC2\t\t=5,\r\n\t\tIM_LANCZOS\t\t=6,\r\n\t\tIM_BOX\t\t\t=7,\r\n\t\tIM_HERMITE\t\t=8,\r\n\t\tIM_HAMMING\t\t=9,\r\n\t\tIM_SINC\t\t\t=10,\r\n\t\tIM_BLACKMAN\t\t=11,\r\n\t\tIM_BESSEL\t\t=12,\r\n\t\tIM_GAUSSIAN\t\t=13,\r\n\t\tIM_QUADRATIC\t=14,\r\n\t\tIM_MITCHELL\t\t=15,\r\n\t\tIM_CATROM\t\t=16,\r\n\t\tIM_HANNING\t\t=17,\r\n\t\tIM_POWER\t\t=18\r\n\t};\r\n\tRGBQUAD GetPixelColorInterpolated(float x,float y, InterpolationMethod const inMethod=IM_BILINEAR, OverflowMethod const ofMethod=OM_BACKGROUND, RGBQUAD* const rplColor=0);\r\n\tRGBQUAD GetAreaColorInterpolated(float const xc, float const yc, float const w, float const h, InterpolationMethod const inMethod, OverflowMethod const ofMethod=OM_BACKGROUND, RGBQUAD* const rplColor=0);\r\n//@}\r\n\r\nprotected:\r\n/** \\addtogroup Protected */ //@{\r\n\tvoid  AddAveragingCont(RGBQUAD const &color, float const surf, float &rr, float &gg, float &bb, float &aa);\r\n//@}\r\n\r\n/** \\addtogroup Kernels */ //@{\r\npublic:\r\n\tstatic float KernelBSpline(const float x);\r\n\tstatic float KernelLinear(const float t);\r\n\tstatic float KernelCubic(const float t);\r\n\tstatic float KernelGeneralizedCubic(const float t, const float a=-1);\r\n\tstatic float KernelLanczosSinc(const float t, const float r = 3);\r\n\tstatic float KernelBox(const float x);\r\n\tstatic float KernelHermite(const float x);\r\n\tstatic float KernelHamming(const float x);\r\n\tstatic float KernelSinc(const float x);\r\n\tstatic float KernelBlackman(const float x);\r\n\tstatic float KernelBessel_J1(const float x);\r\n\tstatic float KernelBessel_P1(const float x);\r\n\tstatic float KernelBessel_Q1(const float x);\r\n\tstatic float KernelBessel_Order1(float x);\r\n\tstatic float KernelBessel(const float x);\r\n\tstatic float KernelGaussian(const float x);\r\n\tstatic float KernelQuadratic(const float x);\r\n\tstatic float KernelMitchell(const float x);\r\n\tstatic float KernelCatrom(const float x);\r\n\tstatic float KernelHanning(const float x);\r\n\tstatic float KernelPower(const float x, const float a = 2);\r\n//@}\r\n#endif //CXIMAGE_SUPPORT_INTERPOLATION\r\n\t\r\n/** \\addtogroup Painting */ //@{\r\n#if CXIMAGE_SUPPORT_WINDOWS\r\n\tint32_t\tBlt(HDC pDC, int32_t x=0, int32_t y=0);\r\n\tHBITMAP Draw2HBITMAP(HDC hdc, int32_t x, int32_t y, int32_t cx, int32_t cy, RECT* pClipRect, bool bSmooth);\r\n\tHBITMAP MakeBitmap(HDC hdc = NULL, bool bTransparency = false);\r\n\tHICON   MakeIcon(HDC hdc = NULL, bool bTransparency = false);\r\n\tHANDLE\tCopyToHandle();\r\n\tbool\tCreateFromHANDLE(HANDLE hMem);\t\t//Windows objects (clipboard)\r\n\tbool\tCreateFromHBITMAP(HBITMAP hbmp, HPALETTE hpal=0, bool bTransparency = false);\t//Windows resource\r\n\tbool\tCreateFromHICON(HICON hico, bool bTransparency = false);\r\n\tint32_t\tDraw(HDC hdc, int32_t x=0, int32_t y=0, int32_t cx = -1, int32_t cy = -1, RECT* pClipRect = 0, bool bSmooth = false, bool bFlipY = false);\r\n\tint32_t\tDraw(HDC hdc, const RECT& rect, RECT* pClipRect=NULL, bool bSmooth = false, bool bFlipY = false);\r\n\tint32_t\tStretch(HDC hdc, int32_t xoffset, int32_t yoffset, int32_t xsize, int32_t ysize, uint32_t dwRop = SRCCOPY);\r\n\tint32_t\tStretch(HDC hdc, const RECT& rect, uint32_t dwRop = SRCCOPY);\r\n\tint32_t\tTile(HDC hdc, RECT *rc);\r\n\tint32_t\tDraw2(HDC hdc, int32_t x=0, int32_t y=0, int32_t cx = -1, int32_t cy = -1);\r\n\tint32_t\tDraw2(HDC hdc, const RECT& rect);\r\n\t//int32_t\tDrawString(HDC hdc, int32_t x, int32_t y, const char* text, RGBQUAD color, const char* font, int32_t lSize=0, int32_t lWeight=400, uint8_t bItalic=0, uint8_t bUnderline=0, bool bSetAlpha=false);\r\n\tint32_t\tDrawString(HDC hdc, int32_t x, int32_t y, const TCHAR* text, RGBQUAD color, const TCHAR* font, int32_t lSize=0, int32_t lWeight=400, uint8_t bItalic=0, uint8_t bUnderline=0, bool bSetAlpha=false);\r\n\t// <VATI> extensions\r\n\tint32_t    DrawStringEx(HDC hdc, int32_t x, int32_t y, CXTEXTINFO *pTextType, bool bSetAlpha=false );\r\n\tvoid    InitTextInfo( CXTEXTINFO *txt );\r\nprotected:\r\n\tbool IsHBITMAPAlphaValid( HBITMAP hbmp );\r\npublic:\r\n#endif //CXIMAGE_SUPPORT_WINDOWS\r\n//@}\r\n\r\n\t// file operations\r\n#if CXIMAGE_SUPPORT_DECODE\r\n/** \\addtogroup Decode */ //@{\r\n#if defined(_WIN32) || defined (_WIN64)\r\n\t//bool Load(LPCWSTR filename, uint32_t imagetype=0);\r\n\tbool LoadResource(HRSRC hRes, uint32_t imagetype, HMODULE hModule=NULL);\r\n#endif\r\n\t// For UNICODE support: char -> TCHAR\r\n\tbool Load(const TCHAR* filename, uint32_t imagetype=0);\r\n\t//bool Load(const char * filename, uint32_t imagetype=0);\r\n\tbool Decode(FILE * hFile, uint32_t imagetype);\r\n\tbool Decode(CxFile * hFile, uint32_t imagetype);\r\n\tbool Decode(uint8_t * buffer, uint32_t size, uint32_t imagetype);\r\n\r\n\tbool CheckFormat(CxFile * hFile, uint32_t imagetype = 0);\r\n\tbool CheckFormat(uint8_t * buffer, uint32_t size, uint32_t imagetype = 0);\r\n//@}\r\n#endif //CXIMAGE_SUPPORT_DECODE\r\n\r\n#if CXIMAGE_SUPPORT_ENCODE\r\nprotected:\r\n/** \\addtogroup Protected */ //@{\r\n\tbool EncodeSafeCheck(CxFile *hFile);\r\n//@}\r\n\r\npublic:\r\n/** \\addtogroup Encode */ //@{\r\n#if defined(_WIN32) || defined (_WIN64)\r\n\t//bool Save(LPCWSTR filename, uint32_t imagetype=0);\r\n#endif\r\n\t// For UNICODE support: char -> TCHAR\r\n\tbool Save(const TCHAR* filename, uint32_t imagetype);\r\n\t//bool Save(const char * filename, uint32_t imagetype=0);\r\n\tbool Encode(FILE * hFile, uint32_t imagetype);\r\n\tbool Encode(CxFile * hFile, uint32_t imagetype);\r\n\tbool Encode(CxFile * hFile, CxImage ** pImages, int32_t pagecount, uint32_t imagetype);\r\n\tbool Encode(FILE *hFile, CxImage ** pImages, int32_t pagecount, uint32_t imagetype);\r\n\tbool Encode(uint8_t * &buffer, int32_t &size, uint32_t imagetype);\r\n\r\n\tbool Encode2RGBA(CxFile *hFile, bool bFlipY = false);\r\n\tbool Encode2RGBA(uint8_t * &buffer, int32_t &size, bool bFlipY = false);\r\n//@}\r\n#endif //CXIMAGE_SUPPORT_ENCODE\r\n\r\n/** \\addtogroup Attributes */ //@{\r\n\t//misc.\r\n\tbool IsValid() const;\r\n\tbool IsEnabled() const;\r\n\tvoid Enable(bool enable=true);\r\n\r\n\t// frame operations\r\n\tint32_t GetNumFrames() const;\r\n\tint32_t GetFrame() const;\r\n\tvoid SetFrame(int32_t nFrame);\r\n//@}\r\n\r\n#if CXIMAGE_SUPPORT_BASICTRANSFORMATIONS\r\n/** \\addtogroup BasicTransformations */ //@{\r\n\tbool GrayScale();\r\n\tbool Flip(bool bFlipSelection = false, bool bFlipAlpha = true);\r\n\tbool Mirror(bool bMirrorSelection = false, bool bMirrorAlpha = true);\r\n\tbool Negative();\r\n\tbool RotateLeft(CxImage* iDst = NULL);\r\n\tbool RotateRight(CxImage* iDst = NULL);\r\n\tbool IncreaseBpp(uint32_t nbit);\r\n//@}\r\n#endif //CXIMAGE_SUPPORT_BASICTRANSFORMATIONS\r\n\r\n#if CXIMAGE_SUPPORT_TRANSFORMATION\r\n/** \\addtogroup Transformations */ //@{\r\n\t// image operations\r\n\tbool Rotate(float angle, CxImage* iDst = NULL);\r\n\tbool Rotate2(float angle, CxImage *iDst = NULL, InterpolationMethod inMethod=IM_BILINEAR,\r\n                OverflowMethod ofMethod=OM_BACKGROUND, RGBQUAD *replColor=0,\r\n                bool const optimizeRightAngles=true, bool const bKeepOriginalSize=false);\r\n\tbool Rotate180(CxImage* iDst = NULL);\r\n\tbool Resample(int32_t newx, int32_t newy, int32_t mode = 1, CxImage* iDst = NULL);\r\n\tbool Resample2(int32_t newx, int32_t newy, InterpolationMethod const inMethod=IM_BICUBIC2,\r\n\t\t\t\tOverflowMethod const ofMethod=OM_REPEAT, CxImage* const iDst = NULL,\r\n\t\t\t\tbool const disableAveraging=false);\r\n\tbool DecreaseBpp(uint32_t nbit, bool errordiffusion, RGBQUAD* ppal = 0, uint32_t clrimportant = 0);\r\n\tbool Dither(int32_t method = 0);\r\n\tbool Crop(int32_t left, int32_t top, int32_t right, int32_t bottom, CxImage* iDst = NULL);\r\n\tbool Crop(const RECT& rect, CxImage* iDst = NULL);\r\n\tbool CropRotatedRectangle( int32_t topx, int32_t topy, int32_t width, int32_t height, float angle, CxImage* iDst = NULL);\r\n\tbool Skew(float xgain, float ygain, int32_t xpivot=0, int32_t ypivot=0, bool bEnableInterpolation = false);\r\n\tbool Expand(int32_t left, int32_t top, int32_t right, int32_t bottom, RGBQUAD canvascolor, CxImage* iDst = 0);\r\n\tbool Expand(int32_t newx, int32_t newy, RGBQUAD canvascolor, CxImage* iDst = 0);\r\n\tbool Thumbnail(int32_t newx, int32_t newy, RGBQUAD canvascolor, CxImage* iDst = 0);\r\n\tbool CircleTransform(int32_t type,int32_t rmax=0,float Koeff=1.0f);\r\n\tbool QIShrink(int32_t newx, int32_t newy, CxImage* const iDst = NULL, bool bChangeBpp = false);\r\n\r\n//@}\r\n#endif //CXIMAGE_SUPPORT_TRANSFORMATION\r\n\r\n#if CXIMAGE_SUPPORT_DSP\r\n/** \\addtogroup DSP */ //@{\r\n\tbool Contour();\r\n\tbool HistogramStretch(int32_t method = 0, double threshold = 0);\r\n\tbool HistogramEqualize();\r\n\tbool HistogramNormalize();\r\n\tbool HistogramRoot();\r\n\tbool HistogramLog();\r\n\tint32_t Histogram(int32_t* red, int32_t* green = 0, int32_t* blue = 0, int32_t* gray = 0, int32_t colorspace = 0);\r\n\tbool Jitter(int32_t radius=2);\r\n\tbool Repair(float radius = 0.25f, int32_t niterations = 1, int32_t colorspace = 0);\r\n\tbool Combine(CxImage* r,CxImage* g,CxImage* b,CxImage* a, int32_t colorspace = 0);\r\n\tbool FFT2(CxImage* srcReal, CxImage* srcImag, CxImage* dstReal, CxImage* dstImag, int32_t direction = 1, bool bForceFFT = true, bool bMagnitude = true);\r\n\tbool Noise(int32_t level);\r\n\tbool Median(int32_t Ksize=3);\r\n\tbool Gamma(float gamma);\r\n\tbool GammaRGB(float gammaR, float gammaG, float gammaB);\r\n\tbool ShiftRGB(int32_t r, int32_t g, int32_t b);\r\n\tbool Threshold(uint8_t level);\r\n\tbool Threshold(CxImage* pThresholdMask);\r\n\tbool Threshold2(uint8_t level, bool bDirection, RGBQUAD nBkgndColor, bool bSetAlpha = false);\r\n\tbool Colorize(uint8_t hue, uint8_t sat, float blend = 1.0f);\r\n\tbool Light(int32_t brightness, int32_t contrast = 0);\r\n\tfloat Mean();\r\n\tbool Filter(int32_t* kernel, int32_t Ksize, int32_t Kfactor, int32_t Koffset);\r\n\tbool Erode(int32_t Ksize=2);\r\n\tbool Dilate(int32_t Ksize=2);\r\n\tbool Edge(int32_t Ksize=2);\r\n\tvoid HuePalette(float correction=1);\r\n\tenum ImageOpType { OpAdd, OpAnd, OpXor, OpOr, OpMask, OpSrcCopy, OpDstCopy, OpSub, OpSrcBlend, OpScreen, OpAvg, OpBlendAlpha };\r\n\tvoid Mix(CxImage & imgsrc2, ImageOpType op, int32_t lXOffset = 0, int32_t lYOffset = 0, bool bMixAlpha = false);\r\n\tvoid MixFrom(CxImage & imagesrc2, int32_t lXOffset, int32_t lYOffset);\r\n\tbool UnsharpMask(float radius = 5.0f, float amount = 0.5f, int32_t threshold = 0);\r\n\tbool Lut(uint8_t* pLut);\r\n\tbool Lut(uint8_t* pLutR, uint8_t* pLutG, uint8_t* pLutB, uint8_t* pLutA = 0);\r\n\tbool GaussianBlur(float radius = 1.0f, CxImage* iDst = 0);\r\n\tbool TextBlur(uint8_t threshold = 100, uint8_t decay = 2, uint8_t max_depth = 5, bool bBlurHorizontal = true, bool bBlurVertical = true, CxImage* iDst = 0);\r\n\tbool SelectiveBlur(float radius = 1.0f, uint8_t threshold = 25, CxImage* iDst = 0);\r\n\tbool Solarize(uint8_t level = 128, bool bLinkedChannels = true);\r\n\tbool FloodFill(const int32_t xStart, const int32_t yStart, const RGBQUAD cFillColor, const uint8_t tolerance = 0,\r\n\t\t\t\t\tuint8_t nOpacity = 255, const bool bSelectFilledArea = false, const uint8_t nSelectionLevel = 255);\r\n\tbool Saturate(const int32_t saturation, const int32_t colorspace = 1);\r\n\tbool ConvertColorSpace(const int32_t dstColorSpace, const int32_t srcColorSpace);\r\n\tint32_t  OptimalThreshold(int32_t method = 0, RECT * pBox = 0, CxImage* pContrastMask = 0);\r\n\tbool AdaptiveThreshold(int32_t method = 0, int32_t nBoxSize = 64, CxImage* pContrastMask = 0, int32_t nBias = 0, float fGlobalLocalBalance = 0.5f);\r\n\tbool RedEyeRemove(float strength = 0.8f);\r\n\tbool Trace(RGBQUAD color_target, RGBQUAD color_trace);\r\n\r\n//@}\r\n\r\nprotected:\r\n/** \\addtogroup Protected */ //@{\r\n\tbool IsPowerof2(int32_t x);\r\n\tbool FFT(int32_t dir,int32_t m,double *x,double *y);\r\n\tbool DFT(int32_t dir,int32_t m,double *x1,double *y1,double *x2,double *y2);\r\n\tbool RepairChannel(CxImage *ch, float radius);\r\n\t// <nipper>\r\n\tint32_t gen_convolve_matrix (float radius, float **cmatrix_p);\r\n\tfloat* gen_lookup_table (float *cmatrix, int32_t cmatrix_length);\r\n\tvoid blur_line (float *ctable, float *cmatrix, int32_t cmatrix_length, uint8_t* cur_col, uint8_t* dest_col, int32_t y, int32_t bytes);\r\n\tvoid blur_text (uint8_t threshold, uint8_t decay, uint8_t max_depth, CxImage* iSrc, CxImage* iDst, uint8_t bytes);\r\n//@}\r\n\r\npublic:\r\n/** \\addtogroup ColorSpace */ //@{\r\n\tbool SplitRGB(CxImage* r,CxImage* g,CxImage* b);\r\n\tbool SplitYUV(CxImage* y,CxImage* u,CxImage* v);\r\n\tbool SplitHSL(CxImage* h,CxImage* s,CxImage* l);\r\n\tbool SplitYIQ(CxImage* y,CxImage* i,CxImage* q);\r\n\tbool SplitXYZ(CxImage* x,CxImage* y,CxImage* z);\r\n\tbool SplitCMYK(CxImage* c,CxImage* m,CxImage* y,CxImage* k);\r\n\tstatic RGBQUAD HSLtoRGB(COLORREF cHSLColor);\r\n\tstatic RGBQUAD RGBtoHSL(RGBQUAD lRGBColor);\r\n\tstatic RGBQUAD HSLtoRGB(RGBQUAD lHSLColor);\r\n\tstatic RGBQUAD YUVtoRGB(RGBQUAD lYUVColor);\r\n\tstatic RGBQUAD RGBtoYUV(RGBQUAD lRGBColor);\r\n\tstatic RGBQUAD YIQtoRGB(RGBQUAD lYIQColor);\r\n\tstatic RGBQUAD RGBtoYIQ(RGBQUAD lRGBColor);\r\n\tstatic RGBQUAD XYZtoRGB(RGBQUAD lXYZColor);\r\n\tstatic RGBQUAD RGBtoXYZ(RGBQUAD lRGBColor);\r\n#endif //CXIMAGE_SUPPORT_DSP\r\n\tstatic RGBQUAD RGBtoRGBQUAD(COLORREF cr);\r\n\tstatic COLORREF RGBQUADtoRGB (RGBQUAD c);\r\n//@}\r\n\r\n/** \\addtogroup Selection */ //@{\r\n\tbool SelectionIsValid();\r\n#if CXIMAGE_SUPPORT_SELECTION\r\n\tbool SelectionClear(uint8_t level = 0);\r\n\tbool SelectionCreate();\r\n\tbool SelectionDelete();\r\n\tbool SelectionInvert();\r\n\tbool SelectionMirror();\r\n\tbool SelectionFlip();\r\n\tbool SelectionAddRect(RECT r, uint8_t level = 255);\r\n\tbool SelectionAddEllipse(RECT r, uint8_t level = 255);\r\n\tbool SelectionAddPolygon(POINT *points, int32_t npoints, uint8_t level = 255);\r\n\tbool SelectionAddColor(RGBQUAD c, uint8_t level = 255);\r\n\tbool SelectionAddPixel(int32_t x, int32_t y, uint8_t level = 255);\r\n\tbool SelectionCopy(CxImage &from);\r\n\tbool SelectionIsInside(int32_t x, int32_t y);\r\n\tvoid SelectionGetBox(RECT& r);\r\n\tbool SelectionToHRGN(HRGN& region);\r\n\tbool SelectionSplit(CxImage *dest);\r\n\tuint8_t SelectionGet(const int32_t x,const int32_t y);\r\n\tbool SelectionSet(CxImage &from);\r\n\tvoid SelectionRebuildBox();\r\n\tuint8_t* SelectionGetPointer(const int32_t x = 0,const int32_t y = 0);\r\n//@}\r\n\r\nprotected:\r\n/** \\addtogroup Protected */ //@{\r\n\tbool BlindSelectionIsInside(int32_t x, int32_t y);\r\n\tuint8_t BlindSelectionGet(const int32_t x,const int32_t y);\r\n\tvoid SelectionSet(const int32_t x,const int32_t y,const uint8_t level);\r\n\r\npublic:\r\n\r\n#endif //CXIMAGE_SUPPORT_SELECTION\r\n//@}\r\n\r\n#if CXIMAGE_SUPPORT_ALPHA\r\n/** \\addtogroup Alpha */ //@{\r\n\tvoid AlphaClear();\r\n\tbool AlphaCreate();\r\n\tvoid AlphaDelete();\r\n\tvoid AlphaInvert();\r\n\tbool AlphaMirror();\r\n\tbool AlphaFlip();\r\n\tbool AlphaCopy(CxImage &from);\r\n\tbool AlphaSplit(CxImage *dest);\r\n\tvoid AlphaStrip();\r\n\tvoid AlphaSet(uint8_t level);\r\n\tbool AlphaSet(CxImage &from);\r\n\tvoid AlphaSet(const int32_t x,const int32_t y,const uint8_t level);\r\n\tuint8_t AlphaGet(const int32_t x,const int32_t y);\r\n\tuint8_t AlphaGetMax() const;\r\n\tvoid AlphaSetMax(uint8_t nAlphaMax);\r\n\tbool AlphaIsValid();\r\n\tuint8_t* AlphaGetPointer(const int32_t x = 0,const int32_t y = 0);\r\n\tbool AlphaFromTransparency();\r\n\r\n\tvoid AlphaPaletteClear();\r\n\tvoid AlphaPaletteEnable(bool enable=true);\r\n\tbool AlphaPaletteIsEnabled();\r\n\tbool AlphaPaletteIsValid();\r\n\tbool AlphaPaletteSplit(CxImage *dest);\r\n//@}\r\n\r\nprotected:\r\n/** \\addtogroup Protected */ //@{\r\n\tuint8_t BlindAlphaGet(const int32_t x,const int32_t y);\r\n//@}\r\n#endif //CXIMAGE_SUPPORT_ALPHA\r\n\r\npublic:\r\n#if CXIMAGE_SUPPORT_LAYERS\r\n/** \\addtogroup Layers */ //@{\r\n\tbool LayerCreate(int32_t position = -1);\r\n\tbool LayerDelete(int32_t position = -1);\r\n\tvoid LayerDeleteAll();\r\n\tCxImage* GetLayer(int32_t position);\r\n\tCxImage* GetParent() const;\r\n\tint32_t GetNumLayers() const;\r\n\tint32_t LayerDrawAll(HDC hdc, int32_t x=0, int32_t y=0, int32_t cx = -1, int32_t cy = -1, RECT* pClipRect = 0, bool bSmooth = false);\r\n\tint32_t LayerDrawAll(HDC hdc, const RECT& rect, RECT* pClipRect=NULL, bool bSmooth = false);\r\n//@}\r\n#endif //CXIMAGE_SUPPORT_LAYERS\r\n\r\nprotected:\r\n/** \\addtogroup Protected */ //@{\r\n\tvoid Startup(uint32_t imagetype = 0);\r\n\tvoid CopyInfo(const CxImage &src);\r\n\tvoid Ghost(const CxImage *src);\r\n\tvoid RGBtoBGR(uint8_t *buffer, int32_t length);\r\n\tstatic float HueToRGB(float n1,float n2, float hue);\r\n\tvoid Bitfield2RGB(uint8_t *src, uint32_t redmask, uint32_t greenmask, uint32_t bluemask, uint8_t bpp);\r\n\tstatic int32_t CompareColors(const void *elem1, const void *elem2);\r\n\tint16_t m_ntohs(const int16_t word);\r\n\tint32_t m_ntohl(const int32_t dword);\r\n\tvoid bihtoh(BITMAPINFOHEADER* bih);\r\n\r\n\tvoid*\t\t\t\tpDib; //contains the header, the palette, the pixels\r\n    BITMAPINFOHEADER    head; //standard header\r\n\tCXIMAGEINFO\t\t\tinfo; //extended information\r\n\tuint8_t*\t\t\tpSelection;\t//selected region\r\n\tuint8_t*\t\t\tpAlpha; //alpha channel\r\n\tCxImage**\t\t\tppLayers; //generic layers\r\n\tCxImage**\t\t\tppFrames;\r\n//@}\r\n};\r\n////////////////////////////////////////////////////////////////////////////\r\n#endif // !defined(__CXIMAGE_H)\r\n", "\ufeff/*\r\n * File:\tximaico.cpp\r\n * Purpose:\tPlatform Independent ICON Image Class Loader and Writer (MS version)\r\n * 07/Aug/2001 Davide Pizzolato - www.xdp.it\r\n * CxImage version 7.0.2 07/Feb/2011\r\n */\r\n\r\n#include \"ximaico.h\"\r\n\r\n#if CXIMAGE_SUPPORT_ICO\r\n\r\n////////////////////////////////////////////////////////////////////////////////\r\n#if CXIMAGE_SUPPORT_DECODE\r\n////////////////////////////////////////////////////////////////////////////////\r\nbool CxImageICO::Decode(CxFile *hFile)\r\n{\r\n\tif (hFile==NULL) return false;\r\n\r\n\tuint32_t off = hFile->Tell(); //<yuandi>\r\n\tint32_t\tpage=info.nFrame;\t//internal icon structure indexes\r\n\r\n\t// read the first part of the header\r\n\tICONHEADER icon_header;\r\n\thFile->Read(&icon_header,sizeof(ICONHEADER),1);\r\n\r\n\ticon_header.idType = m_ntohs(icon_header.idType);\r\n\ticon_header.idCount = m_ntohs(icon_header.idCount);\r\n\r\n\t// check if it's an icon or a cursor\r\n\tif ((icon_header.idReserved == 0) && ((icon_header.idType == 1)||(icon_header.idType == 2))) {\r\n\r\n\t\tinfo.nNumFrames = icon_header.idCount;\r\n\r\n\t\t// load the icon descriptions\r\n\t\tICONDIRENTRY *icon_list = (ICONDIRENTRY *)malloc(icon_header.idCount * sizeof(ICONDIRENTRY));\r\n\t\tint32_t c;\r\n\t\tfor (c = 0; c < icon_header.idCount; c++) {\r\n\t\t\thFile->Read(icon_list + c, sizeof(ICONDIRENTRY), 1);\r\n\r\n\t\t\ticon_list[c].wPlanes = m_ntohs(icon_list[c].wPlanes);\r\n\t\t\ticon_list[c].wBitCount = m_ntohs(icon_list[c].wBitCount);\r\n\t\t\ticon_list[c].dwBytesInRes = m_ntohl(icon_list[c].dwBytesInRes);\r\n\t\t\ticon_list[c].dwImageOffset = m_ntohl(icon_list[c].dwImageOffset);\r\n\t\t}\r\n\r\n\t\tif ((page>=0)&&(page<icon_header.idCount)){\r\n\r\n\t\t\tif (info.nEscape == -1) {\r\n\t\t\t\t// Return output dimensions only\r\n\t\t\t\thead.biWidth = icon_list[page].bWidth;\r\n\t\t\t\thead.biHeight = icon_list[page].bHeight;\r\n#if CXIMAGE_SUPPORT_PNG\r\n\t\t\t\tif (head.biWidth==0 && head.biHeight==0)\r\n\t\t\t\t{\t// Vista icon support\r\n\t\t\t\t\thFile->Seek(off + icon_list[page].dwImageOffset, SEEK_SET);\r\n\t\t\t\t\tCxImage png;\r\n\t\t\t\t\tpng.SetEscape(-1);\r\n\t\t\t\t\tif (png.Decode(hFile,CXIMAGE_FORMAT_PNG)){\r\n\t\t\t\t\t\tTransfer(png);\r\n\t\t\t\t\t\tinfo.nNumFrames = icon_header.idCount;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n#endif //CXIMAGE_SUPPORT_PNG\r\n\t\t\t\tfree(icon_list);\r\n\t\t\t\tinfo.dwType = CXIMAGE_FORMAT_ICO;\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\r\n\t\t\t// get the bit count for the colors in the icon <CoreyRLucier>\r\n\t\t\tBITMAPINFOHEADER bih;\r\n\t\t\thFile->Seek(off + icon_list[page].dwImageOffset, SEEK_SET);\r\n\r\n\t\t\tif (icon_list[page].bWidth==0 && icon_list[page].bHeight==0)\r\n\t\t\t{\t// Vista icon support\r\n#if CXIMAGE_SUPPORT_PNG\r\n\t\t\t\tCxImage png;\r\n\t\t\t\tif (png.Decode(hFile,CXIMAGE_FORMAT_PNG)){\r\n\t\t\t\t\tTransfer(png);\r\n\t\t\t\t\tinfo.nNumFrames = icon_header.idCount;\r\n\t\t\t\t}\r\n\t\t\t\tSetType(CXIMAGE_FORMAT_ICO);\r\n#endif //CXIMAGE_SUPPORT_PNG\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\t// standard icon\r\n\t\t\t\thFile->Read(&bih,sizeof(BITMAPINFOHEADER),1);\r\n\r\n\t\t\t\tbihtoh(&bih);\r\n\r\n\t\t\t\tc = bih.biBitCount;\r\n\r\n\t\t\t\t// allocate memory for one icon\r\n\t\t\t\tCreate(icon_list[page].bWidth,icon_list[page].bHeight, c, CXIMAGE_FORMAT_ICO);\t//image creation\r\n\r\n\t\t\t\t// read the palette\r\n\t\t\t\tRGBQUAD pal[256];\r\n\t\t\t\tif (bih.biClrUsed)\r\n\t\t\t\t\thFile->Read(pal,bih.biClrUsed*sizeof(RGBQUAD), 1);\r\n\t\t\t\telse\r\n\t\t\t\t\thFile->Read(pal,head.biClrUsed*sizeof(RGBQUAD), 1);\r\n\r\n\t\t\t\tSetPalette(pal,head.biClrUsed);\t//palette assign\r\n\r\n\t\t\t\t//read the icon\r\n\t\t\t\tif (c<=24){\r\n\t\t\t\t\thFile->Read(info.pImage, head.biSizeImage, 1);\r\n\t\t\t\t} else { // 32 bit icon\r\n\t\t\t\t\tuint8_t* buf=(uint8_t*)malloc(4*head.biHeight*head.biWidth);\r\n\t\t\t\t\tuint8_t* src = buf;\r\n\t\t\t\t\thFile->Read(buf, 4*head.biHeight*head.biWidth, 1);\r\n#if CXIMAGE_SUPPORT_ALPHA\r\n\t\t\t\t\tif (!AlphaIsValid()) AlphaCreate();\r\n#endif //CXIMAGE_SUPPORT_ALPHA\r\n\t\t\t\t\tfor (int32_t y = 0; y < head.biHeight; y++) {\r\n\t\t\t\t\t\tuint8_t* dst = GetBits(y);\r\n\t\t\t\t\t\tfor(int32_t x=0;x<head.biWidth;x++){\r\n\t\t\t\t\t\t\t*dst++=src[0];\r\n\t\t\t\t\t\t\t*dst++=src[1];\r\n\t\t\t\t\t\t\t*dst++=src[2];\r\n#if CXIMAGE_SUPPORT_ALPHA\r\n\t\t\t\t\t\t\tAlphaSet(x,y,src[3]);\r\n#endif //CXIMAGE_SUPPORT_ALPHA\r\n\t\t\t\t\t\t\tsrc+=4;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tfree(buf);\r\n\t\t\t\t}\r\n\t\t\t\t// apply the AND and XOR masks\r\n\t\t\t\tint32_t maskwdt = ((head.biWidth+31) / 32) * 4;\t//line width of AND mask (always 1 Bpp)\r\n\t\t\t\tint32_t masksize = head.biHeight * maskwdt;\t\t\t\t//size of mask\r\n\t\t\t\tuint8_t *mask = (uint8_t *)malloc(masksize);\r\n\t\t\t\tif (hFile->Read(mask, masksize, 1)){\r\n\r\n\t\t\t\t\tbool bGoodMask=false;\r\n\t\t\t\t\tfor (int32_t im=0;im<masksize;im++){\r\n\t\t\t\t\t\tif (mask[im]!=255){\r\n\t\t\t\t\t\t\tbGoodMask=true;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (bGoodMask){\r\n\t\t\t\t\t\tint32_t x,y;\r\n#if CXIMAGE_SUPPORT_ALPHA\r\n\t\t\t\t\t\tbool bNeedAlpha = false;\r\n\t\t\t\t\t\tif (!AlphaIsValid()){\r\n\t\t\t\t\t\t\tAlphaCreate();\r\n\t\t\t\t\t\t} else { \r\n\t\t\t\t\t\t\tbNeedAlpha=true; //32bit icon\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tfor (y = 0; y < head.biHeight; y++) {\r\n\t\t\t\t\t\t\tfor (x = 0; x < head.biWidth; x++) {\r\n\t\t\t\t\t\t\t\tif (((mask[y*maskwdt+(x>>3)]>>(7-x%8))&0x01)){\r\n\t\t\t\t\t\t\t\t\tAlphaSet(x,y,0);\r\n\t\t\t\t\t\t\t\t\tbNeedAlpha=true;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (!bNeedAlpha) AlphaDelete();\r\n#endif //CXIMAGE_SUPPORT_ALPHA\r\n\r\n\t\t\t\t\t\t//check if there is only one transparent color\r\n\t\t\t\t\t\tRGBQUAD cc,ct;\r\n\t\t\t\t\t\tint32_t nTransColors=0;\r\n\t\t\t\t\t\tint32_t nTransIndex=0;\r\n\t\t\t\t\t\tfor (y = 0; y < head.biHeight; y++){\r\n\t\t\t\t\t\t\tfor (x = 0; x < head.biWidth; x++){\r\n\t\t\t\t\t\t\t\tif (((mask[y*maskwdt+(x>>3)] >> (7-x%8)) & 0x01)){\r\n\t\t\t\t\t\t\t\t\tcc = GetPixelColor(x,y,false);\r\n\t\t\t\t\t\t\t\t\tif (nTransColors==0){\r\n\t\t\t\t\t\t\t\t\t\tnTransIndex = GetPixelIndex(x,y);\r\n\t\t\t\t\t\t\t\t\t\tnTransColors++;\r\n\t\t\t\t\t\t\t\t\t\tct = cc;\r\n\t\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t\tif (memcmp(&cc, &ct, sizeof(RGBQUAD)) != 0){\r\n\t\t\t\t\t\t\t\t\t\t\tnTransColors++;\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (nTransColors==1 && c<=8){\r\n\t\t\t\t\t\t\tSetTransColor(ct);\r\n\t\t\t\t\t\t\tSetTransIndex(nTransIndex);\r\n#if CXIMAGE_SUPPORT_ALPHA\r\n\t\t\t\t\t\t\tAlphaDelete(); //because we have a unique transparent color in the image\r\n#endif //CXIMAGE_SUPPORT_ALPHA\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// <vho> - Transparency support w/o Alpha support\r\n\t\t\t\t\t\tif (c <= 8){ // only for icons with less than 256 colors (XP icons need alpha).\r\n\t\t\t\t\t\t\t  \r\n\t\t\t\t\t\t\t// find a color index, which is not used in the image\r\n\t\t\t\t\t\t\t// it is almost sure to find one, bcs. nobody uses all possible colors for an icon\r\n\r\n\t\t\t\t\t\t\tuint8_t colorsUsed[256];\r\n\t\t\t\t\t\t\tmemset(colorsUsed, 0, sizeof(colorsUsed));\r\n\r\n\t\t\t\t\t\t\tfor (y = 0; y < head.biHeight; y++){\r\n\t\t\t\t\t\t\t\tfor (x = 0; x < head.biWidth; x++){\r\n\t\t\t\t\t\t\t\t\tcolorsUsed[BlindGetPixelIndex(x,y)] = 1;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tint32_t iTransIdx = -1;\r\n\t\t\t\t\t\t\tfor (x = (int32_t)(head.biClrUsed-1); x>=0 ; x--){\r\n\t\t\t\t\t\t\t\tif (colorsUsed[x] == 0){\r\n\t\t\t\t\t\t\t\t\tiTransIdx = x; // this one is not in use. we may use it as transparent color\r\n\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t// Go thru image and set unused color as transparent index if needed\r\n\t\t\t\t\t\t\tif (iTransIdx >= 0){\r\n\t\t\t\t\t\t\t\tbool bNeedTrans = false;\r\n\t\t\t\t\t\t\t\tfor (y = 0; y < head.biHeight; y++){\r\n\t\t\t\t\t\t\t\t\tfor (x = 0; x < head.biWidth; x++){\r\n\t\t\t\t\t\t\t\t\t\t// AND mask (Each Byte represents 8 Pixels)\r\n\t\t\t\t\t\t\t\t\t\tif (((mask[y*maskwdt+(x>>3)] >> (7-x%8)) & 0x01)){\r\n\t\t\t\t\t\t\t\t\t\t\t// AND mask is set (!=0). This is a transparent part\r\n\t\t\t\t\t\t\t\t\t\t\tSetPixelIndex(x, y, (uint8_t)iTransIdx);\r\n\t\t\t\t\t\t\t\t\t\t\tbNeedTrans = true;\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t// set transparent index if needed\r\n\t\t\t\t\t\t\t\tif (bNeedTrans)\tSetTransIndex(iTransIdx);\r\n#if CXIMAGE_SUPPORT_ALPHA\r\n\t\t\t\t\t\t\t\tAlphaDelete(); //because we have a transparent color in the palette\r\n#endif //CXIMAGE_SUPPORT_ALPHA\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tSetTransIndex(0); //empty mask, set black as transparent color\r\n\t\t\t\t\t\tNegative();\r\n\t\t\t\t\t}\r\n\t\t\t\t} \r\n\t\t\t\tfree(mask);\r\n\t\t\t}\r\n\t\t\tfree(icon_list);\r\n\t\t\t// icon has been loaded successfully!\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\tfree(icon_list);\r\n\t}\r\n\treturn false;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n#endif //CXIMAGE_SUPPORT_DECODE\r\n////////////////////////////////////////////////////////////////////////////////\r\n#if CXIMAGE_SUPPORT_ENCODE\r\n////////////////////////////////////////////////////////////////////////////////\r\n// Thanks to <Alas>\r\nbool CxImageICO::Encode(CxFile * hFile, CxImage ** pImages, int32_t nPageCount)\r\n{\r\n  cx_try\r\n  {\r\n\tif (hFile==NULL) cx_throw(\"invalid file pointer\");\r\n\tif (pImages==NULL || nPageCount<=0) cx_throw(\"multipage ICO, no images!\");\r\n\r\n\tint32_t i;\r\n\tfor (i=0; i<nPageCount; i++){\r\n\t\tif (pImages[i]==NULL)\r\n\t\t\tcx_throw(\"Bad image pointer\");\r\n\t\tif (!(pImages[i]->IsValid()))\r\n\t\t\tcx_throw(\"Empty image\");\r\n\t}\r\n\r\n\tCxImageICO ghost;\r\n\tfor (i=0; i<nPageCount; i++){\t//write headers\r\n\t\tghost.Ghost(pImages[i]);\r\n\t\tghost.info.nNumFrames = nPageCount;\r\n\t\tif (i==0) {\r\n\t\t\tif (!ghost.Encode(hFile,false,nPageCount))\r\n\t\t\t\tcx_throw(\"Error writing ICO file header\");\r\n\t\t}\r\n\t\tif (!ghost.Encode(hFile,true,nPageCount)) \r\n\t\t\tcx_throw(\"Error saving ICO image header\");\r\n\t}\r\n\tfor (i=0; i<nPageCount; i++){\t//write bodies\r\n\t\tghost.Ghost(pImages[i]);\r\n\t\tghost.info.nNumFrames = nPageCount;\r\n\t\tif (!ghost.Encode(hFile,true,i)) \r\n\t\t\tcx_throw(\"Error saving ICO body\");\r\n\t}\r\n\r\n  } cx_catch {\r\n\t  if (strcmp(message,\"\")) strncpy(info.szLastError,message,255);\r\n\t  return false;\r\n  }\r\n\treturn true;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\nbool CxImageICO::Encode(CxFile * hFile, bool bAppend, int32_t nPageCount)\r\n{\r\n\tif (EncodeSafeCheck(hFile)) return false;\r\n\r\n#if CXIMAGE_SUPPORT_PNG == 0\r\n\t//check format limits\r\n\tif ((head.biWidth>255)||(head.biHeight>255)){\r\n\t\tstrcpy(info.szLastError,\"Can't save this image as icon\");\r\n\t\treturn false;\r\n\t}\r\n#endif\r\n\r\n\t//prepare the palette struct\r\n\tRGBQUAD* pal=GetPalette();\r\n\tif (head.biBitCount<=8 && pal==NULL) return false;\r\n\r\n\tint32_t maskwdt=((head.biWidth+31)/32)*4; //mask line width\r\n\tint32_t masksize=head.biHeight * maskwdt; //size of mask\r\n\tint32_t bitcount=head.biBitCount;\r\n\tint32_t imagesize=head.biSizeImage;\r\n#if CXIMAGE_SUPPORT_ALPHA\r\n\tif (AlphaIsValid() && head.biClrUsed==0){\r\n\t\tbitcount=32;\r\n\t\timagesize=4*head.biHeight*head.biWidth;\r\n\t}\r\n#endif\r\n\r\n\t//fill the icon headers\r\n\tint32_t nPages = nPageCount;\r\n\tif (nPages<1) nPages = 1;\r\n\r\n\tICONHEADER icon_header={0,1,(uint16_t)nPages};\r\n\r\n\tif (!bAppend)\r\n\t\tm_dwImageOffset = sizeof(ICONHEADER) + nPages * sizeof(ICONDIRENTRY);\r\n\r\n\tuint32_t dwBytesInRes = sizeof(BITMAPINFOHEADER)+head.biClrUsed*sizeof(RGBQUAD)+imagesize+masksize;\r\n\r\n\tICONDIRENTRY icon_list={\r\n\t\t(uint8_t)head.biWidth,\r\n\t\t(uint8_t)head.biHeight,\r\n\t\t(uint8_t)head.biClrUsed,\r\n\t\t0, 0,\r\n\t\t(uint16_t)bitcount,\r\n\t\tdwBytesInRes,\r\n\t\tm_dwImageOffset\r\n\t};\r\n\r\n\tBITMAPINFOHEADER bi={\r\n\t\tsizeof(BITMAPINFOHEADER),\r\n\t\thead.biWidth,\r\n\t\t2*head.biHeight,\r\n\t\t1,\r\n\t\t(uint16_t)bitcount,\r\n\t\t0, (uint32_t)imagesize,\r\n\t\t0, 0, 0, 0\r\n\t};\r\n\r\n#if CXIMAGE_SUPPORT_PNG // Vista icon support\r\n\tCxImage png(*this);\r\n\tCxMemFile memfile;\r\n\tif (head.biWidth>255 || head.biHeight>255){\r\n\t\ticon_list.bWidth = icon_list.bHeight = 0;\r\n\t\tmemfile.Open();\r\n\t\tpng.Encode(&memfile,CXIMAGE_FORMAT_PNG);\r\n\t\ticon_list.dwBytesInRes = dwBytesInRes = memfile.Size();\r\n\t}\r\n#endif //CXIMAGE_SUPPORT_PNG\r\n\r\n\tif (!bAppend){\r\n\t\ticon_header.idType = m_ntohs(icon_header.idType);\r\n\t\ticon_header.idCount = m_ntohs(icon_header.idCount);\r\n\t\thFile->Write(&icon_header,sizeof(ICONHEADER),1);\t//write the file header\r\n\t\ticon_header.idType = m_ntohs(icon_header.idType);\r\n\t\ticon_header.idCount = m_ntohs(icon_header.idCount);\r\n\t}\r\n\r\n\r\n\tif ((bAppend && nPageCount==info.nNumFrames) || (!bAppend && nPageCount==0)){\r\n\t\ticon_list.wPlanes = m_ntohs(icon_list.wPlanes);\r\n\t\ticon_list.wBitCount = m_ntohs(icon_list.wBitCount);\r\n\t\ticon_list.dwBytesInRes = m_ntohl(icon_list.dwBytesInRes);\r\n\t\ticon_list.dwImageOffset = m_ntohl(icon_list.dwImageOffset);\r\n\t\thFile->Write(&icon_list,sizeof(ICONDIRENTRY),1);\t//write the image entry\r\n\t\ticon_list.wPlanes = m_ntohs(icon_list.wPlanes);\r\n\t\ticon_list.wBitCount = m_ntohs(icon_list.wBitCount);\r\n\t\ticon_list.dwBytesInRes = m_ntohl(icon_list.dwBytesInRes);\r\n\t\ticon_list.dwImageOffset = m_ntohl(icon_list.dwImageOffset);\r\n\r\n\t\tm_dwImageOffset += dwBytesInRes;\t\t\t//update offset for next header\r\n\t}\r\n\r\n\tif ((bAppend && nPageCount<info.nNumFrames) || (!bAppend && nPageCount==0))\r\n\t{\r\n#if CXIMAGE_SUPPORT_PNG\r\n\t\tif (icon_list.bWidth==0 && icon_list.bHeight==0) {\t// Vista icon support\r\n\t\t\thFile->Write(memfile.GetBuffer(false),dwBytesInRes,1);\r\n\t\t} else\r\n#endif //CXIMAGE_SUPPORT_PNG\r\n\t\t{\t// standard icon\r\n\t\t\tbihtoh(&bi);\r\n\t\t\thFile->Write(&bi,sizeof(BITMAPINFOHEADER),1);\t\t\t//write the image header\r\n\t\t\tbihtoh(&bi);\r\n\r\n\t\t\tbool bTransparent = info.nBkgndIndex >= 0;\r\n\t\t\tRGBQUAD ct = GetTransColor();\r\n\t\t\tif (pal){\r\n\t\t\t\tif (bTransparent) SetPaletteColor((uint8_t)info.nBkgndIndex,0,0,0,0);\r\n\t\t\t \thFile->Write(pal,head.biClrUsed*sizeof(RGBQUAD),1); //write palette\r\n\t\t\t\tif (bTransparent) SetPaletteColor((uint8_t)info.nBkgndIndex,ct);\r\n\t\t\t}\r\n\r\n#if CXIMAGE_SUPPORT_ALPHA\r\n\t\t\tif (AlphaIsValid() && head.biClrUsed==0){\r\n\t\t\t\tuint8_t* buf=(uint8_t*)malloc(imagesize);\r\n\t\t\t\tuint8_t* dst = buf;\r\n\t\t\t\tfor (int32_t y = 0; y < head.biHeight; y++) {\r\n\t\t\t\t\tuint8_t* src = GetBits(y);\r\n\t\t\t\t\tfor(int32_t x=0;x<head.biWidth;x++){\r\n\t\t\t\t\t\t*dst++=*src++;\r\n\t\t\t\t\t\t*dst++=*src++;\r\n\t\t\t\t\t\t*dst++=*src++;\r\n\t\t\t\t\t\t*dst++=AlphaGet(x,y);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\thFile->Write(buf,imagesize, 1);\r\n\t\t\t\tfree(buf);\r\n\t\t\t} else {\r\n\t\t\t\thFile->Write(info.pImage,imagesize,1);\t//write image\r\n\t\t\t}\r\n#else\r\n\t\t\thFile->Write(info.pImage,imagesize,1);\t//write image\r\n#endif\r\n\r\n\t\t\t//save transparency mask\r\n\t\t\tuint8_t* mask=(uint8_t*)calloc(masksize,1);\t//create empty AND/XOR masks\r\n\t\t\tif (!mask) return false;\r\n\r\n\t\t\t//prepare the variables to build the mask\r\n\t\t\tuint8_t* iDst;\r\n\t\t\tint32_t pos,i;\r\n\t\t\tRGBQUAD c={0,0,0,0};\r\n\t\t\tint32_t* pc = (int32_t*)&c;\r\n\t\t\tint32_t* pct= (int32_t*)&ct;\r\n#if CXIMAGE_SUPPORT_ALPHA\r\n\t\t\tbool bAlphaPaletteIsValid = AlphaPaletteIsValid();\r\n\t\t\tbool bAlphaIsValid = AlphaIsValid();\r\n#endif\r\n\t\t\t//build the mask\r\n\t\t\tfor (int32_t y = 0; y < head.biHeight; y++) {\r\n\t\t\t\tfor (int32_t x = 0; x < head.biWidth; x++) {\r\n\t\t\t\t\ti=0;\r\n#if CXIMAGE_SUPPORT_ALPHA\r\n\t\t\t\t\tif (bAlphaIsValid && AlphaGet(x,y)==0) i=1;\r\n\t\t\t\t\tif (bAlphaPaletteIsValid && BlindGetPixelColor(x,y).rgbReserved==0) i=1;\r\n#endif\r\n\t\t\t\t\tc=GetPixelColor(x,y,false);\r\n\t\t\t\t\tif (bTransparent && *pc==*pct) i=1;\r\n\t\t\t\t\tiDst = mask + y*maskwdt + (x>>3);\r\n\t\t\t\t\tpos = 7-x%8;\r\n\t\t\t\t\t*iDst &= ~(0x01<<pos);\r\n\t\t\t\t\t*iDst |= ((i & 0x01)<<pos);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t//write AND/XOR masks\r\n\t\t\thFile->Write(mask,masksize,1);\r\n\t\t\tfree(mask);\r\n\t\t}\r\n\t}\r\n\r\n\treturn true;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n#endif // CXIMAGE_SUPPORT_ENCODE\r\n////////////////////////////////////////////////////////////////////////////////\r\n#endif // CXIMAGE_SUPPORT_ICO\r\n\r\n", "\ufeff// ximainfo.cpp : main attributes\r\n/* 03/10/2004 v1.00 - Davide Pizzolato - www.xdp.it\r\n * CxImage version 7.0.2 07/Feb/2011\r\n */\r\n\r\n#include \"ximage.h\"\r\n\r\n#if defined(_LINUX) || defined(__APPLE__)\r\n    #ifdef UNICODE\r\n        #define _tcsnicmp(a,b,c) wcscasecmp(a,b)\r\n    #else\r\n        #define _tcsnicmp(a,b,c) strcasecmp(a,b)\r\n    #endif\r\n#endif\r\n\r\n////////////////////////////////////////////////////////////////////////////////\r\n/**\r\n * \\return the color used for transparency, and/or for background color\r\n */\r\nRGBQUAD\tCxImage::GetTransColor()\r\n{\r\n\tif (head.biBitCount<24 && info.nBkgndIndex>=0) return GetPaletteColor((uint8_t)info.nBkgndIndex);\r\n\treturn info.nBkgndColor;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n/**\r\n * Gets the index used for transparency. Returns -1 for no transparancy.\r\n */\r\nint32_t CxImage::GetTransIndex() const\r\n{\r\n\treturn info.nBkgndIndex;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n/**\r\n * Sets the index used for transparency with 1, 4 and 8 bpp images. Set to -1 to remove the effect.\r\n */\r\nvoid CxImage::SetTransIndex(int32_t idx)\r\n{\r\n\tif (idx<(int32_t)head.biClrUsed)\r\n\t\tinfo.nBkgndIndex = idx;\r\n\telse \r\n\t\tinfo.nBkgndIndex = 0;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n/**\r\n * Sets the color used for transparency with 24 bpp images.\r\n * You must call SetTransIndex(0) to enable the effect, SetTransIndex(-1) to disable it.\r\n */\r\nvoid CxImage::SetTransColor(RGBQUAD rgb)\r\n{\r\n\trgb.rgbReserved=0;\r\n\tinfo.nBkgndColor = rgb;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\nbool CxImage::IsTransparent() const\r\n{\r\n\treturn info.nBkgndIndex>=0; // <vho>\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n/**\r\n * Returns true if the image has 256 colors or less.\r\n */\r\nbool CxImage::IsIndexed() const\r\n{\r\n\treturn head.biClrUsed!=0;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n/**\r\n * \\return 1 = indexed, 2 = RGB, 4 = RGBA\r\n */\r\nuint8_t CxImage::GetColorType()\r\n{\r\n\tuint8_t b = (uint8_t)((head.biBitCount>8) ? 2 /*COLORTYPE_COLOR*/ : 1 /*COLORTYPE_PALETTE*/);\r\n#if CXIMAGE_SUPPORT_ALPHA\r\n\tif (AlphaIsValid()) b = 4 /*COLORTYPE_ALPHA*/;\r\n#endif //CXIMAGE_SUPPORT_ALPHA\r\n\treturn b;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n/**\r\n * \\return Resolution for TIFF, JPEG, PNG and BMP formats.\r\n */\r\nint32_t CxImage::GetXDPI() const\r\n{\r\n\treturn info.xDPI;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n/**\r\n * \\return Resolution for TIFF, JPEG, PNG and BMP formats.\r\n */\r\nint32_t CxImage::GetYDPI() const\r\n{\r\n\treturn info.yDPI;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n/**\r\n * Set resolution for TIFF, JPEG, PNG and BMP formats.\r\n */\r\nvoid CxImage::SetXDPI(int32_t dpi)\r\n{\r\n\tif (dpi<=0) dpi = CXIMAGE_DEFAULT_DPI;\r\n\tinfo.xDPI = dpi;\r\n\thead.biXPelsPerMeter = (int32_t) floor(dpi * 10000.0 / 254.0 + 0.5);\r\n\tif (pDib) ((BITMAPINFOHEADER*)pDib)->biXPelsPerMeter = head.biXPelsPerMeter;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n/**\r\n * Set resolution for TIFF, JPEG, PNG and BMP formats.\r\n */\r\nvoid CxImage::SetYDPI(int32_t dpi)\r\n{\r\n\tif (dpi<=0) dpi = CXIMAGE_DEFAULT_DPI;\r\n\tinfo.yDPI = dpi;\r\n\thead.biYPelsPerMeter = (int32_t) floor(dpi * 10000.0 / 254.0 + 0.5);\r\n\tif (pDib) ((BITMAPINFOHEADER*)pDib)->biYPelsPerMeter = head.biYPelsPerMeter;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n/**\r\n * \\sa SetFlags\r\n */\r\nuint32_t CxImage::GetFlags() const\r\n{\r\n\treturn info.dwFlags;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n/**\r\n * Image flags, for future use\r\n * \\param flags\r\n *  - 0x??00000 = reserved for 16 bit, CMYK, multilayer\r\n *  - 0x00??0000 = blend modes\r\n *  - 0x0000???? = layer id or user flags\r\n *\r\n * \\param bLockReservedFlags protects the \"reserved\" and \"blend modes\" flags \r\n */\r\nvoid CxImage::SetFlags(uint32_t flags, bool bLockReservedFlags)\r\n{\r\n\tif (bLockReservedFlags) info.dwFlags = flags & 0x0000ffff;\r\n\telse info.dwFlags = flags;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n/**\r\n * \\sa SetCodecOption\r\n */\r\nuint32_t CxImage::GetCodecOption(uint32_t imagetype)\r\n{\r\n\timagetype = GetTypeIndexFromId(imagetype);\r\n\tif (imagetype==0){\r\n\t\timagetype = GetTypeIndexFromId(GetType());\r\n\t}\r\n\treturn info.dwCodecOpt[imagetype];\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n/**\r\n * Encode option for GIF, TIF, JPG, PNG and RAW\r\n * - GIF : 0 = LZW (default), 1 = none, 2 = RLE.\r\n * - TIF : 0 = automatic (default), or a valid compression code as defined in \"tiff.h\" (COMPRESSION_NONE = 1, COMPRESSION_CCITTRLE = 2, ...)\r\n * - JPG : valid values stored in enum CODEC_OPTION ( ENCODE_BASELINE = 0x01, ENCODE_PROGRESSIVE = 0x10, ...)\r\n * - PNG : combination of interlace option and compression option\r\n *         interlace option :  1 = interlace, 0 = no interlace\r\n *         compression option : 2 = no compression, 4 = best speed, 6 = best compression, 8 = default compression\r\n *         default is no interlace and default compression\r\n *         example : 5 = 1+4 = interlace + best speed\r\n * - RAW : valid values stored in enum CODEC_OPTION ( DECODE_QUALITY_LIN = 0x00, DECODE_QUALITY_VNG = 0x01, ...)\r\n *\r\n * \\return true if everything is ok\r\n */\r\nbool CxImage::SetCodecOption(uint32_t opt, uint32_t imagetype)\r\n{\r\n\timagetype = GetTypeIndexFromId(imagetype);\r\n\tif (imagetype==0){\r\n\t\timagetype = GetTypeIndexFromId(GetType());\r\n\t}\r\n\tinfo.dwCodecOpt[imagetype] = opt;\r\n\treturn true;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n/**\r\n * \\return internal hDib object..\r\n */\r\nvoid* CxImage::GetDIB() const\r\n{\r\n\treturn pDib;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\nuint32_t CxImage::GetHeight() const\r\n{\r\n\treturn head.biHeight;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\nuint32_t CxImage::GetWidth() const\r\n{\r\n\treturn head.biWidth;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n/**\r\n * \\return uint32_t aligned width of the image.\r\n */\r\nuint32_t CxImage::GetEffWidth() const\r\n{\r\n\treturn info.dwEffWidth;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n/**\r\n * \\return 2, 16, 256; 0 for RGB images.\r\n */\r\nuint32_t CxImage::GetNumColors() const\r\n{\r\n\treturn head.biClrUsed;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n/**\r\n * \\return: 1, 4, 8, 24.\r\n */\r\nuint16_t CxImage::GetBpp() const\r\n{\r\n\treturn head.biBitCount;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n/**\r\n * \\return original image format\r\n * \\sa ENUM_CXIMAGE_FORMATS.\r\n */\r\nuint32_t CxImage::GetType() const\r\n{\r\n\treturn info.dwType;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n/**\r\n * change image format identifier\r\n * \\sa ENUM_CXIMAGE_FORMATS.\r\n */\r\nbool CxImage::SetType(uint32_t type)\r\n{\r\n\tswitch (type){\r\n#if CXIMAGE_SUPPORT_BMP\r\n\tcase CXIMAGE_FORMAT_BMP:\r\n#endif\r\n#if CXIMAGE_SUPPORT_GIF\r\n\tcase CXIMAGE_FORMAT_GIF:\r\n#endif\r\n#if CXIMAGE_SUPPORT_JPG\r\n\tcase CXIMAGE_FORMAT_JPG:\r\n#endif\r\n#if CXIMAGE_SUPPORT_PNG\r\n\tcase CXIMAGE_FORMAT_PNG:\r\n#endif\r\n#if CXIMAGE_SUPPORT_MNG\r\n\tcase CXIMAGE_FORMAT_MNG:\r\n#endif\r\n#if CXIMAGE_SUPPORT_ICO\r\n\tcase CXIMAGE_FORMAT_ICO:\r\n#endif\r\n#if CXIMAGE_SUPPORT_TIF\r\n\tcase CXIMAGE_FORMAT_TIF:\r\n#endif\r\n#if CXIMAGE_SUPPORT_TGA\r\n\tcase CXIMAGE_FORMAT_TGA:\r\n#endif\r\n#if CXIMAGE_SUPPORT_PCX\r\n\tcase CXIMAGE_FORMAT_PCX:\r\n#endif\r\n#if CXIMAGE_SUPPORT_WBMP\r\n\tcase CXIMAGE_FORMAT_WBMP:\r\n#endif\r\n#if CXIMAGE_SUPPORT_WMF\r\n\tcase CXIMAGE_FORMAT_WMF:\r\n#endif\r\n#if CXIMAGE_SUPPORT_JBG\r\n\tcase CXIMAGE_FORMAT_JBG:\r\n#endif\r\n#if CXIMAGE_SUPPORT_JP2\r\n\tcase CXIMAGE_FORMAT_JP2:\r\n#endif\r\n#if CXIMAGE_SUPPORT_JPC\r\n\tcase CXIMAGE_FORMAT_JPC:\r\n#endif\r\n#if CXIMAGE_SUPPORT_PGX\r\n\tcase CXIMAGE_FORMAT_PGX:\r\n#endif\r\n#if CXIMAGE_SUPPORT_PNM\r\n\tcase CXIMAGE_FORMAT_PNM:\r\n#endif\r\n#if CXIMAGE_SUPPORT_RAS\r\n\tcase CXIMAGE_FORMAT_RAS:\r\n#endif\r\n#if CXIMAGE_SUPPORT_SKA\r\n\tcase CXIMAGE_FORMAT_SKA:\r\n#endif\r\n#if CXIMAGE_SUPPORT_RAW\r\n\tcase CXIMAGE_FORMAT_RAW:\r\n#endif\r\n#if CXIMAGE_SUPPORT_PSD\r\n\tcase CXIMAGE_FORMAT_PSD:\r\n#endif\r\n\t\tinfo.dwType = type;\r\n\t\treturn true;\r\n\tcase CXIMAGE_FORMAT_UNKNOWN:\r\n\tdefault:\r\n\t\tinfo.dwType = CXIMAGE_FORMAT_UNKNOWN;\r\n\t}\r\n\treturn false;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\nuint32_t CxImage::GetNumTypes()\r\n{\r\n\treturn CMAX_IMAGE_FORMATS-1;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\nuint32_t CxImage::GetTypeIdFromName(const TCHAR* ext)\r\n{\r\n#if CXIMAGE_SUPPORT_BMP\r\n\tif (_tcsnicmp(ext,_T(\"bmp\"),3)==0 )\t\treturn CXIMAGE_FORMAT_BMP;\r\n#endif\r\n#if CXIMAGE_SUPPORT_JPG\r\n\tif (_tcsnicmp(ext,_T(\"jpg\"),3)==0 ||\r\n\t\t_tcsnicmp(ext,_T(\"jpe\"),3)==0 ||\r\n\t\t_tcsnicmp(ext,_T(\"jfi\"),3)==0 )\t\treturn CXIMAGE_FORMAT_JPG;\r\n#endif\r\n#if CXIMAGE_SUPPORT_GIF\r\n\tif (_tcsnicmp(ext,_T(\"gif\"),3)==0 )\t\treturn CXIMAGE_FORMAT_GIF;\r\n#endif\r\n#if CXIMAGE_SUPPORT_PNG\r\n\tif (_tcsnicmp(ext,_T(\"png\"),3)==0 )\t\treturn CXIMAGE_FORMAT_PNG;\r\n#endif\r\n#if CXIMAGE_SUPPORT_ICO\r\n\tif (_tcsnicmp(ext,_T(\"ico\"),3)==0 ||\r\n\t\t_tcsnicmp(ext,_T(\"cur\"),3)==0 )\t\treturn CXIMAGE_FORMAT_ICO;\r\n#endif\r\n#if CXIMAGE_SUPPORT_TIF\r\n\tif (_tcsnicmp(ext,_T(\"tif\"),3)==0 )\t\treturn CXIMAGE_FORMAT_TIF;\r\n#endif\r\n#if CXIMAGE_SUPPORT_TGA\r\n\tif (_tcsnicmp(ext,_T(\"tga\"),3)==0 )\t\treturn CXIMAGE_FORMAT_TGA;\r\n#endif\r\n#if CXIMAGE_SUPPORT_PCX\r\n\tif (_tcsnicmp(ext,_T(\"pcx\"),3)==0 )\t\treturn CXIMAGE_FORMAT_PCX;\r\n#endif\r\n#if CXIMAGE_SUPPORT_WBMP\r\n\tif (_tcsnicmp(ext,_T(\"wbm\"),3)==0 )\t\treturn CXIMAGE_FORMAT_WBMP;\r\n#endif\r\n#if CXIMAGE_SUPPORT_WMF\r\n\tif (_tcsnicmp(ext,_T(\"wmf\"),3)==0 ||\r\n\t\t_tcsnicmp(ext,_T(\"emf\"),3)==0 )\t\treturn CXIMAGE_FORMAT_WMF;\r\n#endif\r\n#if CXIMAGE_SUPPORT_JP2\r\n\tif (_tcsnicmp(ext,_T(\"jp2\"),3)==0 ||\r\n\t\t_tcsnicmp(ext,_T(\"j2k\"),3)==0 )\t\treturn CXIMAGE_FORMAT_JP2;\r\n#endif\r\n#if CXIMAGE_SUPPORT_JPC\r\n\tif (_tcsnicmp(ext,_T(\"jpc\"),3)==0 ||\r\n\t\t_tcsnicmp(ext,_T(\"j2c\"),3)==0 )\t\treturn CXIMAGE_FORMAT_JPC;\r\n#endif\r\n#if CXIMAGE_SUPPORT_PGX\r\n\tif (_tcsnicmp(ext,_T(\"pgx\"),3)==0 )\t\treturn CXIMAGE_FORMAT_PGX;\r\n#endif\r\n#if CXIMAGE_SUPPORT_RAS\r\n\tif (_tcsnicmp(ext,_T(\"ras\"),3)==0 )\t\treturn CXIMAGE_FORMAT_RAS;\r\n#endif\r\n#if CXIMAGE_SUPPORT_PNM\r\n\tif (_tcsnicmp(ext,_T(\"pnm\"),3)==0 ||\r\n\t\t_tcsnicmp(ext,_T(\"pgm\"),3)==0 ||\r\n\t\t_tcsnicmp(ext,_T(\"ppm\"),3)==0 )\t\treturn CXIMAGE_FORMAT_PNM;\r\n#endif\r\n#if CXIMAGE_SUPPORT_JBG\r\n\tif (_tcsnicmp(ext,_T(\"jbg\"),3)==0 )\t\treturn CXIMAGE_FORMAT_JBG;\r\n#endif\r\n#if CXIMAGE_SUPPORT_MNG\r\n\tif (_tcsnicmp(ext,_T(\"mng\"),3)==0 ||\r\n\t\t_tcsnicmp(ext,_T(\"jng\"),3)==0 )\t\treturn CXIMAGE_FORMAT_MNG;\r\n#endif\r\n#if CXIMAGE_SUPPORT_SKA\r\n\tif (_tcsnicmp(ext,_T(\"ska\"),3)==0 )\t\treturn CXIMAGE_FORMAT_SKA;\r\n#endif\r\n#if CXIMAGE_SUPPORT_PSD\r\n\tif (_tcsnicmp(ext,_T(\"psd\"),3)==0 )\t\treturn CXIMAGE_FORMAT_PSD;\r\n#endif\r\n#if CXIMAGE_SUPPORT_RAW\r\n\tif (_tcsnicmp(ext,_T(\"nef\"),3)==0 ||\r\n\t\t_tcsnicmp(ext,_T(\"crw\"),3)==0 ||\r\n\t\t_tcsnicmp(ext,_T(\"cr2\"),3)==0 ||\r\n\t\t_tcsnicmp(ext,_T(\"dng\"),3)==0 ||\r\n\t\t_tcsnicmp(ext,_T(\"arw\"),3)==0 ||\r\n\t\t_tcsnicmp(ext,_T(\"erf\"),3)==0 ||\r\n\t\t_tcsnicmp(ext,_T(\"3fr\"),3)==0 ||\r\n\t\t_tcsnicmp(ext,_T(\"dcr\"),3)==0 ||\r\n\t\t_tcsnicmp(ext,_T(\"raw\"),3)==0 ||\r\n\t\t_tcsnicmp(ext,_T(\"x3f\"),3)==0 ||\r\n\t\t_tcsnicmp(ext,_T(\"mef\"),3)==0 ||\r\n\t\t_tcsnicmp(ext,_T(\"raf\"),3)==0 ||\r\n\t\t_tcsnicmp(ext,_T(\"mrw\"),3)==0 ||\r\n\t\t_tcsnicmp(ext,_T(\"pef\"),3)==0 ||\r\n\t\t_tcsnicmp(ext,_T(\"sr2\"),3)==0 ||\r\n\t\t_tcsnicmp(ext,_T(\"orf\"),3)==0 )\t\treturn CXIMAGE_FORMAT_RAW;\r\n#endif\r\n\r\n\treturn CXIMAGE_FORMAT_UNKNOWN;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\nuint32_t CxImage::GetTypeIdFromIndex(const uint32_t index)\r\n{\r\n\tuint32_t n;\r\n\r\n\tn=0; if (index == n) return CXIMAGE_FORMAT_UNKNOWN;\r\n#if CXIMAGE_SUPPORT_BMP\r\n\tn++; if (index == n) return CXIMAGE_FORMAT_BMP;\r\n#endif\r\n#if CXIMAGE_SUPPORT_GIF\r\n\tn++; if (index == n) return CXIMAGE_FORMAT_GIF;\r\n#endif\r\n#if CXIMAGE_SUPPORT_JPG\r\n\tn++; if (index == n) return CXIMAGE_FORMAT_JPG;\r\n#endif\r\n#if CXIMAGE_SUPPORT_PNG\r\n\tn++; if (index == n) return CXIMAGE_FORMAT_PNG;\r\n#endif\r\n#if CXIMAGE_SUPPORT_ICO\r\n\tn++; if (index == n) return CXIMAGE_FORMAT_ICO;\r\n#endif\r\n#if CXIMAGE_SUPPORT_TIF\r\n\tn++; if (index == n) return CXIMAGE_FORMAT_TIF;\r\n#endif\r\n#if CXIMAGE_SUPPORT_TGA\r\n\tn++; if (index == n) return CXIMAGE_FORMAT_TGA;\r\n#endif\r\n#if CXIMAGE_SUPPORT_PCX\r\n\tn++; if (index == n) return CXIMAGE_FORMAT_PCX;\r\n#endif\r\n#if CXIMAGE_SUPPORT_WBMP\r\n\tn++; if (index == n) return CXIMAGE_FORMAT_WBMP;\r\n#endif\r\n#if CXIMAGE_SUPPORT_WMF\r\n\tn++; if (index == n) return CXIMAGE_FORMAT_WMF;\r\n#endif\r\n#if CXIMAGE_SUPPORT_JP2\r\n\tn++; if (index == n) return CXIMAGE_FORMAT_JP2;\r\n#endif\r\n#if CXIMAGE_SUPPORT_JPC\r\n\tn++; if (index == n) return CXIMAGE_FORMAT_JPC;\r\n#endif\r\n#if CXIMAGE_SUPPORT_PGX\r\n\tn++; if (index == n) return CXIMAGE_FORMAT_PGX;\r\n#endif\r\n#if CXIMAGE_SUPPORT_PNM\r\n\tn++; if (index == n) return CXIMAGE_FORMAT_PNM;\r\n#endif\r\n#if CXIMAGE_SUPPORT_RAS\r\n\tn++; if (index == n) return CXIMAGE_FORMAT_RAS;\r\n#endif\r\n#if CXIMAGE_SUPPORT_JBG\r\n\tn++; if (index == n) return CXIMAGE_FORMAT_JBG;\r\n#endif\r\n#if CXIMAGE_SUPPORT_MNG\r\n\tn++; if (index == n) return CXIMAGE_FORMAT_MNG;\r\n#endif\r\n#if CXIMAGE_SUPPORT_SKA\r\n\tn++; if (index == n) return CXIMAGE_FORMAT_SKA;\r\n#endif\r\n#if CXIMAGE_SUPPORT_RAW\r\n\tn++; if (index == n) return CXIMAGE_FORMAT_RAW;\r\n#endif\r\n#if CXIMAGE_SUPPORT_PSD\r\n\tn++; if (index == n) return CXIMAGE_FORMAT_PSD;\r\n#endif\r\n\r\n\treturn CXIMAGE_FORMAT_UNKNOWN;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\nuint32_t CxImage::GetTypeIndexFromId(const uint32_t id)\r\n{\r\n\tuint32_t n;\r\n\r\n\tn=0; if (id == CXIMAGE_FORMAT_UNKNOWN) return n;\r\n#if CXIMAGE_SUPPORT_BMP\r\n\tn++; if (id == CXIMAGE_FORMAT_BMP) return n;\r\n#endif\r\n#if CXIMAGE_SUPPORT_GIF\r\n\tn++; if (id == CXIMAGE_FORMAT_GIF) return n;\r\n#endif\r\n#if CXIMAGE_SUPPORT_JPG\r\n\tn++; if (id == CXIMAGE_FORMAT_JPG) return n;\r\n#endif\r\n#if CXIMAGE_SUPPORT_PNG\r\n\tn++; if (id == CXIMAGE_FORMAT_PNG) return n;\r\n#endif\r\n#if CXIMAGE_SUPPORT_ICO\r\n\tn++; if (id == CXIMAGE_FORMAT_ICO) return n;\r\n#endif\r\n#if CXIMAGE_SUPPORT_TIF\r\n\tn++; if (id == CXIMAGE_FORMAT_TIF) return n;\r\n#endif\r\n#if CXIMAGE_SUPPORT_TGA\r\n\tn++; if (id == CXIMAGE_FORMAT_TGA) return n;\r\n#endif\r\n#if CXIMAGE_SUPPORT_PCX\r\n\tn++; if (id == CXIMAGE_FORMAT_PCX) return n;\r\n#endif\r\n#if CXIMAGE_SUPPORT_WBMP\r\n\tn++; if (id == CXIMAGE_FORMAT_WBMP) return n;\r\n#endif\r\n#if CXIMAGE_SUPPORT_WMF\r\n\tn++; if (id == CXIMAGE_FORMAT_WMF) return n;\r\n#endif\r\n#if CXIMAGE_SUPPORT_JP2\r\n\tn++; if (id == CXIMAGE_FORMAT_JP2) return n;\r\n#endif\r\n#if CXIMAGE_SUPPORT_JPC\r\n\tn++; if (id == CXIMAGE_FORMAT_JPC) return n;\r\n#endif\r\n#if CXIMAGE_SUPPORT_PGX\r\n\tn++; if (id == CXIMAGE_FORMAT_PGX) return n;\r\n#endif\r\n#if CXIMAGE_SUPPORT_PNM\r\n\tn++; if (id == CXIMAGE_FORMAT_PNM) return n;\r\n#endif\r\n#if CXIMAGE_SUPPORT_RAS\r\n\tn++; if (id == CXIMAGE_FORMAT_RAS) return n;\r\n#endif\r\n#if CXIMAGE_SUPPORT_JBG\r\n\tn++; if (id == CXIMAGE_FORMAT_JBG) return n;\r\n#endif\r\n#if CXIMAGE_SUPPORT_MNG\r\n\tn++; if (id == CXIMAGE_FORMAT_MNG) return n;\r\n#endif\r\n#if CXIMAGE_SUPPORT_SKA\r\n\tn++; if (id == CXIMAGE_FORMAT_SKA) return n;\r\n#endif\r\n#if CXIMAGE_SUPPORT_RAW\r\n\tn++; if (id == CXIMAGE_FORMAT_RAW) return n;\r\n#endif\r\n#if CXIMAGE_SUPPORT_PSD\r\n\tn++; if (id == CXIMAGE_FORMAT_PSD) return n;\r\n#endif\r\n\r\n\treturn 0;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n/**\r\n * \\return current frame delay in milliseconds. Only for GIF and MNG formats.\r\n */\r\nuint32_t CxImage::GetFrameDelay() const\r\n{\r\n\treturn info.dwFrameDelay;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n/**\r\n * Sets current frame delay. Only for GIF format.\r\n * \\param d = delay in milliseconds\r\n */\r\nvoid CxImage::SetFrameDelay(uint32_t d)\r\n{\r\n\tinfo.dwFrameDelay=d;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\nvoid CxImage::GetOffset(int32_t *x,int32_t *y)\r\n{\r\n\t*x=info.xOffset;\r\n\t*y=info.yOffset;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\nvoid CxImage::SetOffset(int32_t x,int32_t y)\r\n{\r\n\tinfo.xOffset=x;\r\n\tinfo.yOffset=y;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n/**\r\n * \\sa SetJpegQuality, GetJpegQualityF\r\n * \\author [DP]; changes [Stefan Sch\u044crmans]\r\n */\r\nuint8_t CxImage::GetJpegQuality() const\r\n{\r\n\treturn (uint8_t)(info.fQuality + 0.5f);\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n/**\r\n * \\sa SetJpegQuality, GetJpegQuality\r\n * \\author [Stefan Sch\u044crmans]\r\n */\r\nfloat CxImage::GetJpegQualityF() const\r\n{\r\n\treturn info.fQuality;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n/**\r\n * quality level for JPEG and JPEG2000\r\n * \\param q: can be from 0 to 100\r\n * \\author [DP]; changes [Stefan Sch\u044crmans]\r\n */\r\nvoid CxImage::SetJpegQuality(uint8_t q){\r\n\tinfo.fQuality = (float)q;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n/**\r\n * quality level for JPEG and JPEG2000\r\n * necessary for JPEG2000 when quality is between 0.0 and 1.0\r\n * \\param q: can be from 0.0 to 100.0\r\n * \\author [Stefan Sch\u044crmans]\r\n */\r\nvoid CxImage::SetJpegQualityF(float q){\r\n\tif (q>0) info.fQuality = q;\r\n\telse  info.fQuality = 0.0f;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n/**\r\n * \\sa SetJpegScale\r\n */\r\nuint8_t CxImage::GetJpegScale() const\r\n{\r\n\treturn info.nJpegScale;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n/**\r\n * scaling down during JPEG decoding valid numbers are 1, 2, 4, 8\r\n * \\author [ignacio]\r\n */\r\nvoid CxImage::SetJpegScale(uint8_t q){\r\n\tinfo.nJpegScale = q;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n/**\r\n * Used to monitor the slow loops.\r\n * \\return value is from 0 to 100.\r\n * \\sa SetProgress\r\n */\r\nint32_t CxImage::GetProgress() const\r\n{\r\n\treturn info.nProgress;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n/**\r\n * \\return the escape code.\r\n * \\sa SetEscape\r\n */\r\nint32_t CxImage::GetEscape() const\r\n{\r\n\treturn info.nEscape;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n/**\r\n * Forces the value of the internal progress variable.\r\n * \\param p should be from 0 to 100.\r\n * \\sa GetProgress\r\n */\r\nvoid CxImage::SetProgress(int32_t p)\r\n{\r\n\tinfo.nProgress = p;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n/**\r\n * Used to quit the slow loops or the codecs.\r\n * - SetEscape(-1) before Decode forces the function to exit, right after  \r\n *   the image width and height are available ( for bmp, jpg, gif, tif )\r\n */\r\nvoid CxImage::SetEscape(int32_t i)\r\n{\r\n\tinfo.nEscape = i;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n/**\r\n * Checks if the image is correctly initializated.\r\n */\r\nbool CxImage::IsValid() const\r\n{\r\n\treturn pDib!=0;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n/**\r\n * True if the image is enabled for painting.\r\n */\r\nbool CxImage::IsEnabled() const\r\n{\r\n\treturn info.bEnabled;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n/**\r\n * Enables/disables the image.\r\n */\r\nvoid CxImage::Enable(bool enable)\r\n{\r\n\tinfo.bEnabled=enable;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n/**\r\n * This function must be used after a Decode() / Load() call.\r\n * Use the sequence SetFrame(-1); Load(...); GetNumFrames();\r\n * to get the number of images without loading the first image.\r\n * \\return the number of images in the file.\r\n */\r\nint32_t CxImage::GetNumFrames() const\r\n{\r\n\treturn info.nNumFrames;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n/**\r\n * \\return the current selected image (zero-based index).\r\n */\r\nint32_t CxImage::GetFrame() const\r\n{\r\n\treturn info.nFrame;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n/**\r\n * Sets the image number that the next Decode() / Load() call will load\r\n */\r\nvoid CxImage::SetFrame(int32_t nFrame){\r\n\tinfo.nFrame=nFrame;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n/**\r\n * Sets the method for drawing the frame related to others\r\n * \\sa GetDisposalMethod\r\n */\r\nvoid CxImage::SetDisposalMethod(uint8_t dm)\r\n{\tinfo.dispmeth=dm; }\r\n////////////////////////////////////////////////////////////////////////////////\r\n/**\r\n * Gets the method for drawing the frame related to others\r\n * Values :    0 -   No disposal specified. The decoder is\r\n *                   not required to take any action.\r\n *             1 -   Do not dispose. The graphic is to be left\r\n *                   in place.\r\n *             2 -   Restore to background color. The area used by the\r\n *                   graphic must be restored to the background color.\r\n *             3 -   Restore to previous. The decoder is required to\r\n *                   restore the area overwritten by the graphic with\r\n *                   what was there prior to rendering the graphic.\r\n *             4-7 -    To be defined.\r\n */\r\nuint8_t CxImage::GetDisposalMethod() const\r\n{\treturn info.dispmeth; }\r\n////////////////////////////////////////////////////////////////////////////////\r\nbool CxImage::GetRetreiveAllFrames() const\r\n{\treturn info.bGetAllFrames; }\r\n////////////////////////////////////////////////////////////////////////////////\r\nvoid CxImage::SetRetreiveAllFrames(bool flag)\r\n{\tinfo.bGetAllFrames = flag; }\r\n////////////////////////////////////////////////////////////////////////////////\r\nCxImage * CxImage::GetFrame(int32_t nFrame) const\r\n{\r\n\tif ( ppFrames == NULL) return NULL;\r\n\tif ( info.nNumFrames == 0) return NULL;\r\n\tif ( nFrame >= info.nNumFrames ) return NULL;\r\n\tif ( nFrame < 0) nFrame = info.nNumFrames - 1;\r\n\treturn ppFrames[nFrame];\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\nint16_t CxImage::m_ntohs(const int16_t word)\r\n{\r\n\tif (info.bLittleEndianHost) return word;\r\n\treturn ( (word & 0xff) << 8 ) | ( (word >> 8) & 0xff );\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\nint32_t CxImage::m_ntohl(const int32_t dword)\r\n{\r\n\tif (info.bLittleEndianHost) return dword;\r\n\treturn  ((dword & 0xff) << 24 ) | ((dword & 0xff00) << 8 ) |\r\n\t\t\t((dword >> 8) & 0xff00) | ((dword >> 24) & 0xff);\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\nvoid CxImage::bihtoh(BITMAPINFOHEADER* bih)\r\n{\r\n\tbih->biSize = m_ntohl(bih->biSize);\r\n\tbih->biWidth = m_ntohl(bih->biWidth);\r\n\tbih->biHeight = m_ntohl(bih->biHeight);\r\n\tbih->biPlanes = m_ntohs(bih->biPlanes);\r\n\tbih->biBitCount = m_ntohs(bih->biBitCount);\r\n\tbih->biCompression = m_ntohl(bih->biCompression);\r\n\tbih->biSizeImage = m_ntohl(bih->biSizeImage);\r\n\tbih->biXPelsPerMeter = m_ntohl(bih->biXPelsPerMeter);\r\n\tbih->biYPelsPerMeter = m_ntohl(bih->biYPelsPerMeter);\r\n\tbih->biClrUsed = m_ntohl(bih->biClrUsed);\r\n\tbih->biClrImportant = m_ntohl(bih->biClrImportant);\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n/**\r\n * Returns the last reported error.\r\n */\r\nconst char* CxImage::GetLastError()\r\n{\r\n\treturn info.szLastError;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\nuint32_t CxImage::DumpSize()\r\n{\r\n\tuint32_t n;\r\n\tn = sizeof(BITMAPINFOHEADER) + sizeof(CXIMAGEINFO) + GetSize();\r\n\r\n#if CXIMAGE_SUPPORT_ALPHA\r\n\tif (pAlpha){\r\n\t\tn += 1 + head.biWidth * head.biHeight;\r\n\t} else n++;\r\n#endif\r\n\r\n#if CXIMAGE_SUPPORT_SELECTION\r\n\tif (pSelection){\r\n\t\tn += 1 + head.biWidth * head.biHeight;\r\n\t} else n++;\r\n#endif\r\n\r\n#if CXIMAGE_SUPPORT_LAYERS\r\n\tif (ppLayers){\r\n\t\tfor (int32_t m=0; m<GetNumLayers(); m++){\r\n\t\t\tif (GetLayer(m)){\r\n\t\t\t\tn += 1 + GetLayer(m)->DumpSize();\r\n\t\t\t}\r\n\t\t}\r\n\t} else n++;\r\n#endif\r\n\r\n\tif (ppFrames){\r\n\t\tfor (int32_t m=0; m<GetNumFrames(); m++){\r\n\t\t\tif (GetFrame(m)){\r\n\t\t\t\tn += 1 + GetFrame(m)->DumpSize();\r\n\t\t\t}\r\n\t\t}\r\n\t} else n++;\r\n\r\n\treturn n;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\nuint32_t CxImage::Dump(uint8_t * dst)\r\n{\r\n\tif (!dst) return 0;\r\n\r\n\tmemcpy(dst,&head,sizeof(BITMAPINFOHEADER));\r\n\tdst += sizeof(BITMAPINFOHEADER);\r\n\r\n\tmemcpy(dst,&info,sizeof(CXIMAGEINFO));\r\n\tdst += sizeof(CXIMAGEINFO);\r\n\r\n\tmemcpy(dst,pDib,GetSize());\r\n\tdst += GetSize();\r\n\r\n#if CXIMAGE_SUPPORT_ALPHA\r\n\tif (pAlpha){\r\n\t\tmemset(dst++, 1, 1);\r\n\t\tmemcpy(dst,pAlpha,head.biWidth * head.biHeight);\r\n\t\tdst += head.biWidth * head.biHeight;\r\n\t} else {\r\n\t\tmemset(dst++, 0, 1);\r\n\t}\r\n#endif\r\n\r\n#if CXIMAGE_SUPPORT_SELECTION\r\n\tif (pSelection){\r\n\t\tmemset(dst++, 1, 1);\r\n\t\tmemcpy(dst,pSelection,head.biWidth * head.biHeight);\r\n\t\tdst += head.biWidth * head.biHeight;\r\n\t} else {\r\n\t\tmemset(dst++, 0, 1);\r\n\t}\r\n#endif\r\n\r\n#if CXIMAGE_SUPPORT_LAYERS\r\n\tif (ppLayers){\r\n\t\tmemset(dst++, 1, 1);\r\n\t\tfor (int32_t m=0; m<GetNumLayers(); m++){\r\n\t\t\tif (GetLayer(m)){\r\n\t\t\t\tdst += GetLayer(m)->Dump(dst);\r\n\t\t\t}\r\n\t\t}\r\n\t} else {\r\n\t\tmemset(dst++, 0, 1);\r\n\t}\r\n#endif\r\n\r\n\tif (ppFrames){\r\n\t\tmemset(dst++, 1, 1);\r\n\t\tfor (int32_t m=0; m<GetNumFrames(); m++){\r\n\t\t\tif (GetFrame(m)){\r\n\t\t\t\tdst += GetFrame(m)->Dump(dst);\r\n\t\t\t}\r\n\t\t}\r\n\t} else {\r\n\t\tmemset(dst++, 0, 1);\r\n\t}\r\n\r\n\treturn DumpSize();\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\nuint32_t CxImage::UnDump(const uint8_t * src)\r\n{\r\n\tif (!src)\r\n\t\treturn 0;\r\n\tif (!Destroy())\r\n\t\treturn 0;\r\n\tif (!DestroyFrames())\r\n\t\treturn 0;\r\n\r\n\tuint32_t n = 0;\r\n\r\n\tmemcpy(&head,src,sizeof(BITMAPINFOHEADER));\r\n\tn += sizeof(BITMAPINFOHEADER);\r\n\r\n\tmemcpy(&info,&src[n],sizeof(CXIMAGEINFO));\r\n\tn += sizeof(CXIMAGEINFO);\r\n\r\n\tif (!Create(head.biWidth, head.biHeight, head.biBitCount, info.dwType))\r\n\t\treturn 0;\r\n\r\n\tmemcpy(pDib,&src[n],GetSize());\r\n\tn += GetSize();\r\n\r\n#if CXIMAGE_SUPPORT_ALPHA\r\n\tif (src[n++]){\r\n\t\tif (AlphaCreate()){\r\n\t\t\tmemcpy(pAlpha, &src[n], head.biWidth * head.biHeight);\r\n\t\t}\r\n\t\tn += head.biWidth * head.biHeight;\r\n\t}\r\n#endif\r\n\r\n#if CXIMAGE_SUPPORT_SELECTION\r\n\tif (src[n++]){\r\n\t\tRECT box = info.rSelectionBox;\r\n\t\tif (SelectionCreate()){\r\n\t\t\tinfo.rSelectionBox = box;\r\n\t\t\tmemcpy(pSelection, &src[n], head.biWidth * head.biHeight);\r\n\t\t}\r\n\t\tn += head.biWidth * head.biHeight;\r\n\t}\r\n#endif\r\n\r\n#if CXIMAGE_SUPPORT_LAYERS\r\n\tif (src[n++]){\r\n\t\tppLayers = new CxImage*[info.nNumLayers];\r\n\t\tfor (int32_t m=0; m<GetNumLayers(); m++){\r\n\t\t\tppLayers[m] = new CxImage();\r\n\t\t\tn += ppLayers[m]->UnDump(&src[n]);\r\n\t\t}\r\n\t}\r\n#endif\r\n\r\n\tif (src[n++]){\r\n\t\tppFrames = new CxImage*[info.nNumFrames];\r\n\t\tfor (int32_t m=0; m<GetNumFrames(); m++){\r\n\t\t\tppFrames[m] = new CxImage();\r\n\t\t\tn += ppFrames[m]->UnDump(&src[n]);\r\n\t\t}\r\n\t}\r\n\r\n\treturn n;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n/**\r\n * \\return A.BBCCCDDDD\r\n *  - A = main version\r\n *  - BB = main revision\r\n *  - CCC = minor revision (letter)\r\n *  - DDDD = experimental revision\r\n */\r\nconst float CxImage::GetVersionNumber()\r\n{\r\n\treturn 7.000020000f;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\nconst TCHAR* CxImage::GetVersion()\r\n{\r\n\tstatic const TCHAR CxImageVersion[] = _T(\"CxImage 7.0.2\");\r\n\treturn (CxImageVersion);\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n", "\ufeff/*\r\n * File:\tximapcx.cpp\r\n * Purpose:\tPlatform Independent PCX Image Class Loader and Writer\r\n * 05/Jan/2002 Davide Pizzolato - www.xdp.it\r\n * CxImage version 7.0.2 07/Feb/2011\r\n *\r\n * based on ppmtopcx.c - convert a portable pixmap to PCX\r\n * Copyright (C) 1994 by Ingo Wilken (Ingo.Wilken@informatik.uni-oldenburg.de)\r\n * based on ppmtopcx.c by Michael Davidson\r\n */\r\n\r\n#include \"ximapcx.h\"\r\n\r\n#if CXIMAGE_SUPPORT_PCX\r\n\r\n#include \"xmemfile.h\"\r\n\r\n#define PCX_MAGIC 0X0A  // PCX magic number\r\n#define PCX_256_COLORS 0X0C  // magic number for 256 colors\r\n#define PCX_HDR_SIZE 128  // size of PCX header\r\n#define PCX_MAXCOLORS 256\r\n#define PCX_MAXPLANES 4\r\n#define PCX_MAXVAL 255\r\n\r\n////////////////////////////////////////////////////////////////////////////////\r\n#if CXIMAGE_SUPPORT_DECODE\r\n////////////////////////////////////////////////////////////////////////////////\r\nbool CxImagePCX::Decode(CxFile *hFile)\r\n{\r\n\tif (hFile == NULL) return false;\r\n\r\n\tPCXHEADER pcxHeader;\r\n\tint32_t i, x, y, y2, nbytes, count, Height, Width;\r\n\tuint8_t c, ColorMap[PCX_MAXCOLORS][3];\r\n\tuint8_t *pcximage = NULL, *lpHead1 = NULL, *lpHead2 = NULL;\r\n\tuint8_t *pcxplanes, *pcxpixels;\r\n\r\n  cx_try\r\n  {\r\n\tif (hFile->Read(&pcxHeader,sizeof(PCXHEADER),1)==0) cx_throw(\"Can't read PCX image\");\r\n\r\n\tPCX_toh(&pcxHeader);\r\n\r\n    if (pcxHeader.Manufacturer != PCX_MAGIC) cx_throw(\"Error: Not a PCX file\");\r\n    // Check for PCX run length encoding\r\n    if (pcxHeader.Encoding != 1) cx_throw(\"PCX file has unknown encoding scheme\");\r\n \r\n    Width = (pcxHeader.Xmax - pcxHeader.Xmin) + 1;\r\n    Height = (pcxHeader.Ymax - pcxHeader.Ymin) + 1;\r\n\tinfo.xDPI = pcxHeader.Hres;\r\n\tinfo.yDPI = pcxHeader.Vres;\r\n\r\n\tif (info.nEscape == -1){\r\n\t\thead.biWidth = Width;\r\n\t\thead.biHeight= Height;\r\n\t\tinfo.dwType = CXIMAGE_FORMAT_PCX;\r\n\t\treturn true;\r\n\t}\r\n\r\n    // Check that we can handle this image format\r\n    if (pcxHeader.ColorPlanes > 4)\r\n\t\tcx_throw(\"Can't handle image with more than 4 planes\");\r\n\r\n\t// Create the image\r\n\tif (pcxHeader.ColorPlanes >= 3 && pcxHeader.BitsPerPixel == 8){\r\n\t\tCreate (Width, Height, 24, CXIMAGE_FORMAT_PCX);\r\n#if CXIMAGE_SUPPORT_ALPHA\r\n\t\tif (pcxHeader.ColorPlanes==4) AlphaCreate();\r\n#endif //CXIMAGE_SUPPORT_ALPHA\r\n\t} else if (pcxHeader.ColorPlanes == 4 && pcxHeader.BitsPerPixel == 1)\r\n\t\tCreate (Width, Height, 4, CXIMAGE_FORMAT_PCX);\r\n\telse\r\n\t\tCreate (Width, Height, pcxHeader.BitsPerPixel, CXIMAGE_FORMAT_PCX);\r\n\r\n\tif (info.nEscape) cx_throw(\"Cancelled\"); // <vho> - cancel decoding\r\n\r\n\t//Read the image and check if it's ok\r\n    nbytes = pcxHeader.BytesPerLine * pcxHeader.ColorPlanes * Height;\r\n    lpHead1 = pcximage = (uint8_t*)malloc(nbytes);\r\n    while (nbytes > 0){\r\n\t\tif (hFile == NULL || hFile->Eof()) cx_throw(\"corrupted PCX\");\r\n\r\n\t\thFile->Read(&c,1,1);\r\n\t\tif ((c & 0XC0) != 0XC0){ // Repeated group\r\n\t\t\t*pcximage++ = c;\r\n\t\t\t--nbytes;\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\tcount = c & 0X3F; // extract count\r\n\t\thFile->Read(&c,1,1);\r\n\t\tif (count > nbytes) cx_throw(\"repeat count spans end of image\");\r\n\r\n\t\tnbytes -= count;\r\n\t\twhile (--count >=0) *pcximage++ = c;\r\n\t}\r\n    pcximage = lpHead1;\r\n\r\n\t//store the palette\r\n    for (i = 0; i < 16; i++){\r\n\t\tColorMap[i][0] = pcxHeader.ColorMap[i][0];\r\n\t\tColorMap[i][1] = pcxHeader.ColorMap[i][1];\r\n\t\tColorMap[i][2] = pcxHeader.ColorMap[i][2];\r\n\t}\r\n    if (pcxHeader.BitsPerPixel == 8 && pcxHeader.ColorPlanes == 1){\r\n\t\thFile->Read(&c,1,1);\r\n\t\tif (c != PCX_256_COLORS) cx_throw(\"bad color map signature\");\r\n\t\t\r\n\t\tfor (i = 0; i < PCX_MAXCOLORS; i++){\r\n\t\t\thFile->Read(&ColorMap[i][0],1,1);\r\n\t\t\thFile->Read(&ColorMap[i][1],1,1);\r\n\t\t\thFile->Read(&ColorMap[i][2],1,1);\r\n\t\t}\r\n\t}\r\n    if (pcxHeader.BitsPerPixel == 1 && pcxHeader.ColorPlanes == 1){\r\n\t\tColorMap[0][0] = ColorMap[0][1] = ColorMap[0][2] = 0;\r\n\t\tColorMap[1][0] = ColorMap[1][1] = ColorMap[1][2] = 255;\r\n\t}\r\n\r\n\tfor (uint32_t idx=0; idx<head.biClrUsed; idx++) SetPaletteColor((uint8_t)idx,ColorMap[idx][0],ColorMap[idx][1],ColorMap[idx][2]);\r\n\r\n    lpHead2 = pcxpixels = (uint8_t *)malloc(Width + pcxHeader.BytesPerLine * 8);\r\n    // Convert the image\r\n    for (y = 0; y < Height; y++){\r\n\r\n\t\tif (info.nEscape) cx_throw(\"Cancelled\"); // <vho> - cancel decoding\r\n\r\n\t\ty2=Height-1-y;\r\n\t\tpcxpixels = lpHead2;\r\n\t\tpcxplanes = pcximage + (y * pcxHeader.BytesPerLine * pcxHeader.ColorPlanes);\r\n\r\n\t\tif (pcxHeader.ColorPlanes == 3 && pcxHeader.BitsPerPixel == 8){\r\n\t\t\t// Deal with 24 bit color image\r\n\t\t\tfor (x = 0; x < Width; x++){\r\n\t\t\t\tSetPixelColor(x,y2,RGB(pcxplanes[x],pcxplanes[pcxHeader.BytesPerLine + x],pcxplanes[2*pcxHeader.BytesPerLine + x]));\r\n\t\t\t}\r\n\t\t\tcontinue;\r\n#if CXIMAGE_SUPPORT_ALPHA\r\n\t\t} else if (pcxHeader.ColorPlanes == 4 && pcxHeader.BitsPerPixel == 8){\r\n\t\t\tfor (x = 0; x < Width; x++){\r\n\t\t\t\tSetPixelColor(x,y2,RGB(pcxplanes[x],pcxplanes[pcxHeader.BytesPerLine + x],pcxplanes[2*pcxHeader.BytesPerLine + x]));\r\n\t\t\t\tAlphaSet(x,y2,pcxplanes[3*pcxHeader.BytesPerLine + x]);\r\n\t\t\t}\r\n\t\t\tcontinue;\r\n#endif //CXIMAGE_SUPPORT_ALPHA\r\n\t\t} else if (pcxHeader.ColorPlanes == 1) {\r\n\t\t\tif (!PCX_UnpackPixels(pcxpixels, pcxplanes, pcxHeader.BytesPerLine, pcxHeader.ColorPlanes, pcxHeader.BitsPerPixel)){\r\n\t\t\t\tcx_throw(\"PCX_UnpackPixels: Can't handle packed pixels with more than 1 plane\");\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tif (!PCX_PlanesToPixels(pcxpixels, pcxplanes, pcxHeader.BytesPerLine, pcxHeader.ColorPlanes, pcxHeader.BitsPerPixel)){\r\n\t\t\t\tcx_throw(\"PCX_PlanesToPixels: more than 4 planes or more than 1 bit per pixel\");\r\n\t\t\t}\r\n\t\t}\r\n\t\tfor (x = 0; x < Width; x++)\tSetPixelIndex(x,y2,pcxpixels[x]);\r\n\t}\r\n\r\n  } cx_catch {\r\n\tif (strcmp(message,\"\")) strncpy(info.szLastError,message,255);\r\n\tif (lpHead1){ free(lpHead1); lpHead1 = NULL; }\r\n    if (lpHead2){ free(lpHead2); lpHead2 = NULL; }\r\n\treturn false;\r\n  }\r\n\tif (lpHead1){ free(lpHead1); lpHead1 = NULL; }\r\n    if (lpHead2){ free(lpHead2); lpHead2 = NULL; }\r\n\treturn true;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n#endif //CXIMAGE_SUPPORT_DECODE\r\n////////////////////////////////////////////////////////////////////////////////\r\n#if CXIMAGE_SUPPORT_ENCODE\r\n////////////////////////////////////////////////////////////////////////////////\r\nbool CxImagePCX::Encode(CxFile * hFile)\r\n{\r\n\tif (EncodeSafeCheck(hFile)) return false;\r\n\r\n  cx_try\r\n  {\r\n\tPCXHEADER pcxHeader;\r\n\tmemset(&pcxHeader,0,sizeof(pcxHeader));\r\n\tpcxHeader.Manufacturer = PCX_MAGIC;\r\n\tpcxHeader.Version = 5;\r\n\tpcxHeader.Encoding = 1;\r\n\tpcxHeader.Xmin = 0;\r\n\tpcxHeader.Ymin = 0;\r\n\tpcxHeader.Xmax = (uint16_t)head.biWidth-1;\r\n\tpcxHeader.Ymax = (uint16_t)head.biHeight-1;\r\n\tpcxHeader.Hres = (uint16_t)info.xDPI;\r\n\tpcxHeader.Vres = (uint16_t)info.yDPI;\r\n\tpcxHeader.Reserved = 0;\r\n\tpcxHeader.PaletteType = head.biClrUsed==0;\r\n\r\n\tswitch(head.biBitCount){\r\n\tcase 24:\r\n\tcase 8:\r\n\t\t{\r\n\t\t\tpcxHeader.BitsPerPixel = 8;\r\n\t\t\tpcxHeader.ColorPlanes = head.biClrUsed==0 ? 3 : 1;\r\n#if CXIMAGE_SUPPORT_ALPHA\r\n\t\t\tif (AlphaIsValid() && head.biClrUsed==0) pcxHeader.ColorPlanes =4;\r\n#endif //CXIMAGE_SUPPORT_ALPHA\r\n\t\t\tpcxHeader.BytesPerLine = (uint16_t)head.biWidth;\r\n\t\t\tbreak;\r\n\t\t}\r\n\tdefault: //(4 1)\r\n\t\tpcxHeader.BitsPerPixel = 1;\r\n\t\tpcxHeader.ColorPlanes = head.biClrUsed==16 ? 4 : 1;\r\n\t\tpcxHeader.BytesPerLine = (uint16_t)((head.biWidth * pcxHeader.BitsPerPixel + 7)>>3);\r\n\t}\r\n\r\n    if (pcxHeader.BitsPerPixel == 1 && pcxHeader.ColorPlanes == 1){\r\n\t\tpcxHeader.ColorMap[0][0] = pcxHeader.ColorMap[0][1] = pcxHeader.ColorMap[0][2] = 0;\r\n\t\tpcxHeader.ColorMap[1][0] = pcxHeader.ColorMap[1][1] = pcxHeader.ColorMap[1][2] = 255;\r\n\t}\r\n\tif (pcxHeader.BitsPerPixel == 1 && pcxHeader.ColorPlanes == 4){\r\n\t\tRGBQUAD c;\r\n\t\tfor (int32_t i = 0; i < 16; i++){\r\n\t\t\tc=GetPaletteColor(i);\r\n\t\t\tpcxHeader.ColorMap[i][0] = c.rgbRed;\r\n\t\t\tpcxHeader.ColorMap[i][1] = c.rgbGreen;\r\n\t\t\tpcxHeader.ColorMap[i][2] = c.rgbBlue;\r\n\t\t}\r\n\t}\r\n\r\n\tpcxHeader.BytesPerLine = (pcxHeader.BytesPerLine + 1)&(~1);\r\n\r\n\tPCX_toh(&pcxHeader);\r\n\tif (hFile->Write(&pcxHeader, sizeof(pcxHeader), 1) == 0 )\r\n\t   cx_throw(\"cannot write PCX header\");\r\n\tPCX_toh(&pcxHeader);\r\n\r\n\tCxMemFile buffer;\r\n\tbuffer.Open();\r\n\r\n\tuint8_t c,n;\r\n\tint32_t x,y;\r\n\tif (head.biClrUsed==0){\r\n\t\tfor (y = head.biHeight-1; y >=0 ; y--){\r\n\t\t\tfor (int32_t p=0; p<pcxHeader.ColorPlanes; p++){\r\n\t\t\t\tc=n=0;\r\n\t\t\t\tfor (x = 0; x<head.biWidth; x++){\r\n\t\t\t\t\tif (p==0)\r\n\t\t\t\t\t\tPCX_PackPixels(BlindGetPixelColor(x,y).rgbRed,c,n,buffer);\r\n\t\t\t\t\telse if (p==1)\r\n\t\t\t\t\t\tPCX_PackPixels(BlindGetPixelColor(x,y).rgbGreen,c,n,buffer);\r\n\t\t\t\t\telse if (p==2)\r\n\t\t\t\t\t\tPCX_PackPixels(BlindGetPixelColor(x,y).rgbBlue,c,n,buffer);\r\n#if CXIMAGE_SUPPORT_ALPHA\r\n\t\t\t\t\telse if (p==3)\r\n\t\t\t\t\t\tPCX_PackPixels(BlindAlphaGet(x,y),c,n,buffer);\r\n#endif //CXIMAGE_SUPPORT_ALPHA\r\n\t\t\t\t}\r\n\t\t\t\tPCX_PackPixels(-1-(head.biWidth&0x1),c,n,buffer);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\thFile->Write(buffer.GetBuffer(false),buffer.Tell(),1);\r\n\r\n\t} else if (head.biBitCount==8) {\r\n\r\n\t\tfor (y = head.biHeight-1; y >=0 ; y--){\r\n\t\t\tc=n=0;\r\n\t\t\tfor (x = 0; x<head.biWidth; x++){\r\n\t\t\t\tPCX_PackPixels(GetPixelIndex(x,y),c,n,buffer);\r\n\t\t\t}\r\n\t\t\tPCX_PackPixels(-1-(head.biWidth&0x1),c,n,buffer);\r\n\t\t}\r\n\r\n\t\thFile->Write(buffer.GetBuffer(false),buffer.Tell(),1);\r\n\r\n\t\tif (head.biBitCount == 8){\r\n\t\t\thFile->PutC(0x0C);\r\n\t\t\tuint8_t* pal = (uint8_t*)malloc(768);\r\n\t\t\tRGBQUAD c;\r\n\t\t\tfor (int32_t i=0;i<256;i++){\r\n\t\t\t\tc=GetPaletteColor(i);\r\n\t\t\t\tpal[3*i+0] = c.rgbRed;\r\n\t\t\t\tpal[3*i+1] = c.rgbGreen;\r\n\t\t\t\tpal[3*i+2] = c.rgbBlue;\r\n\t\t\t}\r\n\t\t\thFile->Write(pal,768,1);\r\n\t\t\tfree(pal);\r\n\t\t}\r\n\t} else { //(head.biBitCount==4) || (head.biBitCount==1)\r\n\r\n\t\tRGBQUAD *rgb = GetPalette();\r\n\t\tbool binvert = false;\r\n\t\tif (CompareColors(&rgb[0],&rgb[1])>0) binvert=(head.biBitCount==1);\r\n\t\t\r\n\t\tuint8_t* plane = (uint8_t*)malloc(pcxHeader.BytesPerLine);\r\n\t\tuint8_t* raw = (uint8_t*)malloc(head.biWidth);\r\n\r\n\t\tfor(y = head.biHeight-1; y >=0 ; y--) {\r\n\r\n\t\t\tfor( x = 0; x < head.biWidth; x++)\traw[x] = (uint8_t)GetPixelIndex(x,y);\r\n\r\n\t\t\tif (binvert) for( x = 0; x < head.biWidth; x++)\traw[x] = 1-raw[x];\r\n\r\n\t\t\tfor( x = 0; x < pcxHeader.ColorPlanes; x++ ) {\r\n\t\t\t\tPCX_PixelsToPlanes(raw, head.biWidth, plane, x);\r\n\t\t\t\tPCX_PackPlanes(plane, pcxHeader.BytesPerLine, buffer);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfree(plane);\r\n\t\tfree(raw);\r\n\r\n\t\thFile->Write(buffer.GetBuffer(false),buffer.Tell(),1);\r\n\r\n\t}\r\n\r\n  } cx_catch {\r\n\tif (strcmp(message,\"\")) strncpy(info.szLastError,message,255);\r\n\treturn false;\r\n  }\r\n    return true;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n#endif // CXIMAGE_SUPPORT_ENCODE\r\n////////////////////////////////////////////////////////////////////////////////\r\n// Convert multi-plane format into 1 pixel per byte\r\n// from unpacked file data bitplanes[] into pixel row pixels[]\r\n// image Height rows, with each row having planes image planes each\r\n// bytesperline bytes\r\nbool CxImagePCX::PCX_PlanesToPixels(uint8_t * pixels, uint8_t * bitplanes, int16_t bytesperline, int16_t planes, int16_t bitsperpixel)\r\n{\r\n\tint32_t i, j, npixels;\r\n\tuint8_t * p;\r\n\tif (planes > 4) return false;\r\n\tif (bitsperpixel != 1) return false;\r\n\r\n\t// Clear the pixel buffer\r\n\tnpixels = (bytesperline * 8) / bitsperpixel;\r\n\tp = pixels;\r\n\twhile (--npixels >= 0) *p++ = 0;\r\n\r\n\t// Do the format conversion\r\n\tfor (i = 0; i < planes; i++){\r\n\t\tint32_t pixbit, bits, mask;\r\n\t\tp = pixels;\r\n\t\tpixbit = (1 << i);  // pixel bit for this plane\r\n\t\tfor (j = 0; j < bytesperline; j++){\r\n\t\t\tbits = *bitplanes++;\r\n\t\t\tfor (mask = 0X80; mask != 0; mask >>= 1, p++)\r\n\t\t\t\tif (bits & mask) *p |= pixbit;\r\n\t\t}\r\n\t}\r\n\treturn true;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n// convert packed pixel format into 1 pixel per byte\r\n// from unpacked file data bitplanes[] into pixel row pixels[]\r\n// image Height rows, with each row having planes image planes each\r\n// bytesperline bytes\r\nbool CxImagePCX::PCX_UnpackPixels(uint8_t * pixels, uint8_t * bitplanes, int16_t bytesperline, int16_t planes, int16_t bitsperpixel)\r\n{\r\n\tregister int32_t bits;\r\n\tif (planes != 1) return false;\r\n\t\r\n\tif (bitsperpixel == 8){  // 8 bits/pixels, no unpacking needed\r\n\t\twhile (bytesperline-- > 0) *pixels++ = *bitplanes++;\r\n\t} else if (bitsperpixel == 4){  // 4 bits/pixel, two pixels per byte\r\n\t\twhile (bytesperline-- > 0){\r\n\t\t\tbits = *bitplanes++;\r\n\t\t\t*pixels++ = (uint8_t)((bits >> 4) & 0X0F);\r\n\t\t\t*pixels++ = (uint8_t)((bits) & 0X0F);\r\n\t\t}\r\n\t} else if (bitsperpixel == 2){  // 2 bits/pixel, four pixels per byte\r\n\t\twhile (bytesperline-- > 0){\r\n\t\t\tbits = *bitplanes++;\r\n\t\t\t*pixels++ = (uint8_t)((bits >> 6) & 0X03);\r\n\t\t\t*pixels++ = (uint8_t)((bits >> 4) & 0X03);\r\n\t\t\t*pixels++ = (uint8_t)((bits >> 2) & 0X03);\r\n\t\t\t*pixels++ = (uint8_t)((bits) & 0X03);\r\n\t\t}\r\n\t} else if (bitsperpixel == 1){  // 1 bits/pixel, 8 pixels per byte\r\n\t\twhile (bytesperline-- > 0){\r\n\t\t\tbits = *bitplanes++;\r\n\t\t\t*pixels++ = ((bits & 0X80) != 0);\r\n\t\t\t*pixels++ = ((bits & 0X40) != 0);\r\n\t\t\t*pixels++ = ((bits & 0X20) != 0);\r\n\t\t\t*pixels++ = ((bits & 0X10) != 0);\r\n\t\t\t*pixels++ = ((bits & 0X08) != 0);\r\n\t\t\t*pixels++ = ((bits & 0X04) != 0);\r\n\t\t\t*pixels++ = ((bits & 0X02) != 0);\r\n\t\t\t*pixels++ = ((bits & 0X01) != 0);\r\n\t\t}\r\n\t}\r\n\treturn true;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n/* PCX_PackPixels(const int32_t p,uint8_t &c, uint8_t &n, int32_t &l, CxFile &f)\r\n * p = current pixel (-1 ends the line -2 ends odd line)\r\n * c = previous pixel\r\n * n = number of consecutive pixels\r\n */\r\nvoid CxImagePCX::PCX_PackPixels(const int32_t p,uint8_t &c, uint8_t &n, CxFile &f)\r\n{\r\n\tif (p!=c && n){\r\n\t\tif (n==1 && c<0xC0){\r\n\t\t\tf.PutC(c);\r\n\t\t} else {\r\n\t\t\tf.PutC(0xC0|n);\r\n\t\t\tf.PutC(c);\r\n\t\t}\r\n\t\tn=0;\r\n\t}\r\n\tif (n==0x3F) {\r\n\t\tf.PutC(0xFF);\r\n\t\tf.PutC(c);\r\n\t\tn=0;\r\n\t}\r\n\tif (p==-2) f.PutC(0);\r\n\tc=(uint8_t)p;\r\n\tn++;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\nvoid CxImagePCX::PCX_PackPlanes(uint8_t* buff, const int32_t size, CxFile &f)\r\n{\r\n    uint8_t *start,*end;\r\n    uint8_t c, previous, count;\r\n\r\n\tstart = buff;\r\n    end = buff + size;\r\n    previous = *start++;\r\n    count    = 1;\r\n\r\n    while (start < end) {\r\n        c = *start++;\r\n        if (c == previous && count < 63) {\r\n            ++count;\r\n            continue;\r\n        }\r\n\r\n        if (count > 1 || (previous & 0xc0) == 0xc0) {\r\n            f.PutC( count | 0xc0 );\r\n        }\r\n        f.PutC(previous);\r\n        previous = c;\r\n        count   = 1;\r\n    }\r\n\r\n    if (count > 1 || (previous & 0xc0) == 0xc0) {\r\n        count |= 0xc0;\r\n        f.PutC(count);\r\n    }\r\n    f.PutC(previous);\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\nvoid CxImagePCX::PCX_PixelsToPlanes(uint8_t* raw, int32_t width, uint8_t* buf, int32_t plane)\r\n{\r\n    int32_t cbit, x, mask;\r\n    uint8_t *cp = buf-1;\r\n\r\n    mask = 1 << plane;\r\n    cbit = -1;\r\n    for( x = 0; x < width; x++ ) {\r\n        if( cbit < 0 ) {\r\n            cbit = 7;\r\n            *++cp = 0;\r\n        }\r\n        if( raw[x] & mask )\r\n            *cp |= (1<<cbit);\r\n        --cbit;\r\n    }\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\nvoid CxImagePCX::PCX_toh(PCXHEADER* p)\r\n{\r\n\tp->Xmin = m_ntohs(p->Xmin);\r\n\tp->Ymin = m_ntohs(p->Ymin);\r\n\tp->Xmax = m_ntohs(p->Xmax);\r\n\tp->Ymax = m_ntohs(p->Ymax);\r\n\tp->Hres = m_ntohs(p->Hres);\r\n\tp->Vres = m_ntohs(p->Vres);\r\n\tp->BytesPerLine = m_ntohs(p->BytesPerLine);\r\n\tp->PaletteType = m_ntohs(p->PaletteType);\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n#endif // CXIMAGE_SUPPORT_PCX\r\n", "\ufeff/*\r\n * File:\tximatif.cpp\r\n * Purpose:\tPlatform Independent TIFF Image Class Loader and Writer\r\n * 07/Aug/2001 Davide Pizzolato - www.xdp.it\r\n * CxImage version 7.0.2 07/Feb/2011\r\n */\r\n\r\n#include \"ximatif.h\"\r\n\r\n#ifndef min\r\n#define min(a,b) (((a)<(b))?(a):(b))\r\n#endif\r\n#ifndef max\r\n#define max(a,b) (((a)>(b))?(a):(b))\r\n#endif\r\n\r\n\r\n#if CXIMAGE_SUPPORT_TIF\r\n\r\n#define FIX_16BPP_DARKIMG // + VK: if uncomment, dark 16bpp images are fixed\r\n\r\n#include \"../tiff/tiffio.h\"\r\n\r\n#define CVT(x)\t\t\t(((x) * 255L) / ((1L<<16)-1))\r\n#define\tSCALE(x)\t\t(((x)*((1L<<16)-1))/255)\r\n#define CalculateLine(width,bitdepth)\t(((width * bitdepth) + 7) / 8)\r\n#define CalculatePitch(line)\t(line + 3 & ~3)\r\n\r\nextern \"C\" TIFF* _TIFFOpenEx(CxFile* stream, const char* mode);\r\n\r\n////////////////////////////////////////////////////////////////////////////////\r\nCxImageTIF::~CxImageTIF()\r\n{\r\n\tif (m_tif2) TIFFClose(m_tif2);\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n#if CXIMAGE_SUPPORT_DECODE\r\n////////////////////////////////////////////////////////////////////////////////\r\nbool CxImageTIF::Decode(CxFile * hFile)\r\n{\r\n\t//Comment this line if you need more information on errors\r\n\t// TIFFSetErrorHandler(NULL);\t//<Patrick Hoffmann>\r\n\r\n\t//Open file and fill the TIFF structure\r\n\t// m_tif = TIFFOpen(imageFileName,\"rb\");\r\n\tTIFF* m_tif = _TIFFOpenEx(hFile, \"rb\");\r\n\r\n\tuint32 height=0;\r\n\tuint32 width=0;\r\n\tuint16 bitspersample=1;\r\n\tuint16 samplesperpixel=1;\r\n\tuint32 rowsperstrip=(uint32_t)-1;\r\n\tuint16 photometric=0;\r\n\tuint16 compression=1;\r\n\tuint16 orientation=ORIENTATION_TOPLEFT; //<vho>\r\n\tuint16 res_unit; //<Trifon>\r\n\tuint32 x, y;\r\n\tfloat resolution, offset;\r\n\tBOOL isRGB;\r\n\tuint8_t *bits;\t\t//pointer to source data\r\n\tuint8_t *bits2;\t//pointer to destination data\r\n\r\n  cx_try\r\n  {\r\n\t//check if it's a tiff file\r\n\tif (!m_tif)\r\n\t\tcx_throw(\"Error encountered while opening TIFF file\");\r\n\r\n\t// <Robert Abram> - 12/2002 : get NumFrames directly, instead of looping\r\n\t// info.nNumFrames=0;\r\n\t// while(TIFFSetDirectory(m_tif,(uint16)info.nNumFrames)) info.nNumFrames++;\r\n\tinfo.nNumFrames = TIFFNumberOfDirectories(m_tif);\r\n\r\n\tif (!TIFFSetDirectory(m_tif, (uint16)info.nFrame))\r\n\t\tcx_throw(\"Error: page not present in TIFF file\");\t\t\t\r\n\r\n\t//get image info\r\n\tTIFFGetField(m_tif, TIFFTAG_IMAGEWIDTH, &width);\r\n\tTIFFGetField(m_tif, TIFFTAG_IMAGELENGTH, &height);\r\n\tTIFFGetField(m_tif, TIFFTAG_SAMPLESPERPIXEL, &samplesperpixel);\r\n\tTIFFGetField(m_tif, TIFFTAG_BITSPERSAMPLE, &bitspersample);\r\n\tTIFFGetField(m_tif, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);   \r\n\tTIFFGetField(m_tif, TIFFTAG_PHOTOMETRIC, &photometric);\r\n\tTIFFGetField(m_tif, TIFFTAG_ORIENTATION, &orientation);\r\n\r\n\tif (info.nEscape == -1) {\r\n\t\t// Return output dimensions only\r\n\t\thead.biWidth = width;\r\n\t\thead.biHeight = height;\r\n\t\tinfo.dwType = CXIMAGE_FORMAT_TIF;\r\n\t\tcx_throw(\"output dimensions returned\");\r\n\t}\r\n\r\n\tTIFFGetFieldDefaulted(m_tif, TIFFTAG_RESOLUTIONUNIT, &res_unit);\r\n\tif (TIFFGetField(m_tif, TIFFTAG_XRESOLUTION, &resolution))\r\n\t{\r\n\t\tif (res_unit == RESUNIT_CENTIMETER) resolution = (float)(resolution*2.54f + 0.5f);\r\n\t\tSetXDPI((int32_t)resolution);\r\n\t}\r\n\tif (TIFFGetField(m_tif, TIFFTAG_YRESOLUTION, &resolution))\r\n\t{\r\n\t\tif (res_unit == RESUNIT_CENTIMETER) resolution = (float)(resolution*2.54f + 0.5f);\r\n\t\tSetYDPI((int32_t)resolution);\r\n\t}\r\n\r\n\tif (TIFFGetField(m_tif, TIFFTAG_XPOSITION, &offset))\tinfo.xOffset = (int32_t)offset;\r\n\tif (TIFFGetField(m_tif, TIFFTAG_YPOSITION, &offset))\tinfo.yOffset = (int32_t)offset;\r\n\r\n\thead.biClrUsed=0;\r\n\tinfo.nBkgndIndex =-1;\r\n\r\n\tif (rowsperstrip>height){\r\n\t\trowsperstrip=height;\r\n\t\tTIFFSetField(m_tif, TIFFTAG_ROWSPERSTRIP, rowsperstrip);\r\n\t}\r\n\r\n\tisRGB = /*(bitspersample >= 8) && (VK: it is possible so for RGB to have < 8 bpp!)*/\r\n\t\t(photometric == PHOTOMETRIC_RGB) ||\r\n\t\t(photometric == PHOTOMETRIC_YCBCR) ||\r\n\t\t(photometric == PHOTOMETRIC_SEPARATED) ||\r\n\t\t(photometric == PHOTOMETRIC_LOGL) ||\r\n\t\t(photometric == PHOTOMETRIC_LOGLUV);\r\n\r\n\tif (isRGB){\r\n\t\thead.biBitCount=24;\r\n\t}else{\r\n\t\tif ((photometric==PHOTOMETRIC_MINISBLACK)||(photometric==PHOTOMETRIC_MINISWHITE)||(photometric==PHOTOMETRIC_PALETTE)){\r\n\t\t\tif\t(bitspersample == 1){\r\n\t\t\t\thead.biBitCount=1;\t\t//B&W image\r\n\t\t\t\thead.biClrUsed =2;\r\n\t\t\t} else if (bitspersample == 4) {\r\n\t\t\t\thead.biBitCount=4;\t\t//16 colors gray scale\r\n\t\t\t\thead.biClrUsed =16;\r\n\t\t\t} else {\r\n\t\t\t\thead.biBitCount=8;\t\t//gray scale\r\n\t\t\t\thead.biClrUsed =256;\r\n\t\t\t}\r\n\t\t} else if (bitspersample == 4) {\r\n\t\t\thead.biBitCount=4;\t\t\t// 16 colors\r\n\t\t\thead.biClrUsed=16;\r\n\t\t} else {\r\n\t\t\thead.biBitCount=8;\t\t\t//256 colors\r\n\t\t\thead.biClrUsed=256;\r\n\t\t}\r\n\r\n\t\tif ((bitspersample > 8) && (photometric==PHOTOMETRIC_PALETTE))\t// + VK + (BIG palette! => convert to RGB)\r\n\t\t{\thead.biBitCount=24;\r\n\t\t\thead.biClrUsed =0;\r\n\t\t}\r\n\t}\r\n\r\n\tif (info.nEscape) cx_throw(\"Cancelled\"); // <vho> - cancel decoding\r\n\r\n\tCreate(width,height,head.biBitCount,CXIMAGE_FORMAT_TIF);\t//image creation\r\n\tif (!pDib) cx_throw(\"CxImageTIF can't create image\");\r\n\r\n#if CXIMAGE_SUPPORT_ALPHA\r\n\tif (samplesperpixel==4) AlphaCreate();\t//add alpha support for 32bpp tiffs\r\n\tif (samplesperpixel==2 && bitspersample==8) AlphaCreate();\t//add alpha support for 8bpp + alpha\r\n#endif //CXIMAGE_SUPPORT_ALPHA\r\n\r\n\tTIFFGetField(m_tif, TIFFTAG_COMPRESSION, &compression);\r\n\tSetCodecOption(compression); // <DPR> save original compression type\r\n\r\n\tif (isRGB) {\r\n\t\t// Read the whole image into one big RGBA buffer using\r\n\t\t// the traditional TIFFReadRGBAImage() API that we trust.\r\n\t\tuint32* raster;\t\t// retrieve RGBA image\r\n\t\tuint32 *row;\r\n\r\n\t\traster = (uint32*)_TIFFmalloc(width * height * sizeof (uint32));\r\n\t\tif (raster == NULL) cx_throw(\"No space for raster buffer\");\r\n\t\t\t\r\n\t\t// Read the image in one chunk into an RGBA array\r\n\t\tif(!TIFFReadRGBAImage(m_tif, width, height, raster, 1)) {\r\n\t\t\t\t_TIFFfree(raster);\r\n\t\t\t\tcx_throw(\"Corrupted TIFF file!\");\r\n\t\t}\r\n\r\n\t\t// read the raster lines and save them in the DIB\r\n\t\t// with RGB mode, we have to change the order of the 3 samples RGB\r\n\t\trow = &raster[0];\r\n\t\tbits2 = info.pImage;\r\n\t\tfor (y = 0; y < height; y++) {\r\n\r\n\t\t\tif (info.nEscape){ // <vho> - cancel decoding\r\n\t\t\t\t_TIFFfree(raster);\r\n\t\t\t\tcx_throw(\"Cancelled\");\r\n\t\t\t}\r\n\r\n\t\t\tbits = bits2;\r\n\t\t\tfor (x = 0; x < width; x++) {\r\n\t\t\t\t*bits++ = (uint8_t)TIFFGetB(row[x]);\r\n\t\t\t\t*bits++ = (uint8_t)TIFFGetG(row[x]);\r\n\t\t\t\t*bits++ = (uint8_t)TIFFGetR(row[x]);\r\n#if CXIMAGE_SUPPORT_ALPHA\r\n\t\t\t\tif (samplesperpixel==4) AlphaSet(x,y,(uint8_t)TIFFGetA(row[x]));\r\n#endif //CXIMAGE_SUPPORT_ALPHA\r\n\t\t\t}\r\n\t\t\trow += width;\r\n\t\t\tbits2 += info.dwEffWidth;\r\n\t\t}\r\n\t\t_TIFFfree(raster);\r\n\t} else {\r\n\t\tint32_t BIG_palette = (bitspersample > 8) &&\t// + VK\r\n\t\t\t\t\t\t  (photometric==PHOTOMETRIC_PALETTE);\t\t\r\n\t\tif (BIG_palette && (bitspersample > 24))\t// + VK\r\n\t\t\tcx_throw(\"Too big palette to handle\");\t\t// + VK\r\n\r\n\t\tRGBQUAD *pal;\r\n\t\tpal=(RGBQUAD*)calloc(BIG_palette ? 1<<bitspersample : 256,sizeof(RGBQUAD)); \r\n\t\t\t// ! VK: it coasts nothing but more correct to use 256 as temp palette storage\r\n\t\t\t// ! VK: but for case of BIG palette it just copied\r\n\t\tif (pal==NULL) cx_throw(\"Unable to allocate TIFF palette\");\r\n\r\n\t\tint32_t bpp = bitspersample <= 8 ? bitspersample : 8; // + VK (to use instead of bitspersample for case of > 8)\r\n\r\n\t\t// set up the colormap based on photometric\t\r\n\t\tswitch(photometric) {\r\n\t\t\tcase PHOTOMETRIC_MINISBLACK:\t// bitmap and greyscale image types\r\n\t\t\tcase PHOTOMETRIC_MINISWHITE:\r\n\t\t\t\tif (bitspersample == 1) {\t// Monochrome image\r\n\t\t\t\t\tif (photometric == PHOTOMETRIC_MINISBLACK) {\r\n\t\t\t\t\t\tpal[1].rgbRed = pal[1].rgbGreen = pal[1].rgbBlue = 255;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tpal[0].rgbRed = pal[0].rgbGreen = pal[0].rgbBlue = 255;\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\t\t// need to build the scale for greyscale images\r\n\t\t\t\t\tif (photometric == PHOTOMETRIC_MINISBLACK) {\r\n\t\t\t\t\t\tfor (int32_t i=0; i<(1<<bpp); i++){\r\n\t\t\t\t\t\t\tpal[i].rgbRed = pal[i].rgbGreen = pal[i].rgbBlue = (uint8_t)(i*(255/((1<<bpp)-1)));\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tfor (int32_t i=0; i<(1<<bpp); i++){\r\n\t\t\t\t\t\t\tpal[i].rgbRed = pal[i].rgbGreen = pal[i].rgbBlue = (uint8_t)(255-i*(255/((1<<bpp)-1)));\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase PHOTOMETRIC_PALETTE:\t// color map indexed\r\n\t\t\t\tuint16 *red;\r\n\t\t\t\tuint16 *green;\r\n\t\t\t\tuint16 *blue;\r\n\t\t\t\tTIFFGetField(m_tif, TIFFTAG_COLORMAP, &red, &green, &blue); \r\n\r\n\t\t\t\t// Is the palette 16 or 8 bits ?\r\n\t\t\t\tBOOL Palette16Bits = /*FALSE*/ BIG_palette;\r\n\t\t\t\tif (!BIG_palette) {\r\n\t\t\t\t\tint32_t n= 1<<bpp;\r\n\t\t\t\t\twhile (n-- > 0) {\r\n\t\t\t\t\t\tif (red[n] >= 256 || green[n] >= 256 || blue[n] >= 256) {\r\n\t\t\t\t\t\t\tPalette16Bits=TRUE;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// load the palette in the DIB\r\n\t\t\t\tfor (int32_t i = (1 << ( BIG_palette ? bitspersample : bpp )) - 1; i >= 0; i--) {\r\n\t\t\t\t\tif (Palette16Bits) {\r\n\t\t\t\t\t\tpal[i].rgbRed =(uint8_t) CVT(red[i]);\r\n\t\t\t\t\t\tpal[i].rgbGreen = (uint8_t) CVT(green[i]);\r\n\t\t\t\t\t\tpal[i].rgbBlue = (uint8_t) CVT(blue[i]);           \r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tpal[i].rgbRed = (uint8_t) red[i];\r\n\t\t\t\t\t\tpal[i].rgbGreen = (uint8_t) green[i];\r\n\t\t\t\t\t\tpal[i].rgbBlue = (uint8_t) blue[i];        \r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\t\tif (!BIG_palette) { // + VK (BIG palette is stored until image is ready)\r\n\t\t\tSetPalette(pal,/*head.biClrUsed*/ 1<<bpp);\t//palette assign // * VK\r\n\t\t\tfree(pal); \r\n\t\t\tpal = NULL; \r\n\t\t}\r\n\r\n\t\t// read the tiff lines and save them in the DIB\r\n\t\tuint32 nrow;\r\n\t\tuint32 ys;\r\n\t\tint32_t line = CalculateLine(width, bitspersample * samplesperpixel);\r\n\t\t\r\n\t\tint32_t bitsize = TIFFStripSize(m_tif);\r\n\t\t//verify bitsize: could be wrong if StripByteCounts is missing.\r\n\t\tif (bitsize>(int32_t)(head.biSizeImage*samplesperpixel))\r\n\t\t\tbitsize = head.biSizeImage*samplesperpixel;\r\n\t\tif (bitsize<(int32_t)(info.dwEffWidth*rowsperstrip))\r\n\t\t\tbitsize = info.dwEffWidth*rowsperstrip;\r\n\r\n\t\tif ((bitspersample > 8) && (bitspersample != 16))\t// + VK (for bitspersample == 9..15,17..32..64\r\n\t\t\tbitsize *= (bitspersample + 7)/8; \r\n\r\n\t\tint32_t tiled_image = TIFFIsTiled(m_tif);\r\n\t\tuint32 tw=0, tl=0;\r\n\t\tuint8_t* tilebuf=NULL;\r\n\t\tif (tiled_image){\r\n\t\t\tTIFFGetField(m_tif, TIFFTAG_TILEWIDTH, &tw);\r\n\t\t\tTIFFGetField(m_tif, TIFFTAG_TILELENGTH, &tl);\r\n\t\t\trowsperstrip = tl;\r\n\t\t\tbitsize = TIFFTileSize(m_tif) * (int32_t)(1+width/tw);\r\n\t\t\ttilebuf = (uint8_t*)malloc(TIFFTileSize(m_tif));\r\n\t\t}\r\n\t\t\r\n\t\tbits = (uint8_t*)malloc(bitspersample==16? bitsize*2 : bitsize); // * VK\r\n\t\tuint8_t * bits16 = NULL;\t\t\t\t\t\t\t\t\t\t  // + VK\r\n\t\tint32_t line16    = 0;\t\t\t\t\t\t\t\t\t\t\t  // + VK\r\n\r\n\t\tif (!tiled_image && bitspersample==16) {\t\t\t\t\t  // + VK +\r\n\t\t\tline16 = line;\r\n\t\t\tline   = CalculateLine(width, 8 * samplesperpixel);\r\n\t\t\tbits16 = bits;\r\n\t\t\tbits   = (uint8_t*)malloc(bitsize);\r\n\t\t}\r\n\r\n\t\tif (bits==NULL){\r\n\t\t\tif (bits16) free(bits16);\t\t\t\t\t\t\t\t  // + VK\r\n\t\t\tif (pal)\tfree(pal);\t\t\t\t\t\t\t\t\t  // + VK\r\n\t\t\tif (tilebuf)free(tilebuf);\t\t\t\t\t\t\t\t  // + VK\t\r\n\t\t\tcx_throw(\"CxImageTIF can't allocate memory\");\r\n\t\t}\r\n\r\n#ifdef FIX_16BPP_DARKIMG // + VK: for each line, store shift count bits used to fix it\r\n\t\tuint8_t* row_shifts = NULL;\r\n\t\tif (bits16) row_shifts = (uint8_t*)malloc(height); \r\n#endif\r\n\r\n\t\tfor (ys = 0; ys < height; ys += rowsperstrip) {\r\n\r\n\t\t\tif (info.nEscape){ // <vho> - cancel decoding\r\n\t\t\t\tfree(bits);\r\n\t\t\t\tcx_throw(\"Cancelled\");\r\n\t\t\t}\r\n\r\n\t\t\tnrow = (ys + rowsperstrip > height ? height - ys : rowsperstrip);\r\n\r\n\t\t\tif (tiled_image){\r\n\t\t\t\tuint32 imagew = TIFFScanlineSize(m_tif);\r\n\t\t\t\tuint32 tilew  = TIFFTileRowSize(m_tif);\r\n\t\t\t\tint32_t iskew = imagew - tilew;\r\n\t\t\t\tuint8* bufp = (uint8*) bits;\r\n\r\n\t\t\t\tuint32 colb = 0;\r\n\t\t\t\tfor (uint32 col = 0; col < width; col += tw) {\r\n\t\t\t\t\tif (TIFFReadTile(m_tif, tilebuf, col, ys, 0, 0) < 0){\r\n\t\t\t\t\t\tfree(tilebuf);\r\n\t\t\t\t\t\tfree(bits);\r\n\t\t\t\t\t\tcx_throw(\"Corrupted tiled TIFF file!\");\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (colb + tw > imagew) {\r\n\t\t\t\t\t\tuint32 owidth = imagew - colb;\r\n\t\t\t\t\t\tuint32 oskew = tilew - owidth;\r\n\t\t\t\t\t\tTileToStrip(bufp + colb, tilebuf, nrow, owidth, oskew + iskew, oskew );\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tTileToStrip(bufp + colb, tilebuf, nrow, tilew, iskew, 0);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tcolb += tilew;\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\t\t\t\tif (TIFFReadEncodedStrip(m_tif, TIFFComputeStrip(m_tif, ys, 0), \r\n\t\t\t\t\t(bits16? bits16 : bits), nrow * (bits16 ? line16 : line)) == -1) { // * VK\r\n\r\n#ifdef NOT_IGNORE_CORRUPTED\r\n\t\t\t\t\tfree(bits);\r\n\t\t\t\t\tif (bits16) free(bits16);  // + VK\r\n\t\t\t\t\tcx_throw(\"Corrupted TIFF file!\");\r\n#else\r\n\t\t\t\t\tbreak;\r\n#endif\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tfor (y = 0; y < nrow; y++) {\r\n\t\t\t\tint32_t offset=(nrow-y-1)*line;\r\n\t\t\t\tif ((bitspersample==16) && !BIG_palette) {\t// * VK\r\n\t\t\t\t\tint32_t offset16 = (nrow-y-1)*line16;\t\t// + VK\r\n\t\t\t\t\tif (bits16)\t{\t\t\t\t\t\t\t// + VK +\r\n#ifdef FIX_16BPP_DARKIMG\r\n\t\t\t\t\t\tint32_t the_shift;\r\n\t\t\t\t\t\tuint8_t hi_byte, hi_max=0;\r\n\t\t\t\t\t\tuint32_t xi;\r\n\t\t\t\t\t\tfor (xi=0;xi<(uint32)line;xi++) {\r\n\t\t\t\t\t\t\thi_byte = bits16[xi*2+offset16+1];\r\n\t\t\t\t\t\t\tif(hi_byte>hi_max)\r\n\t\t\t\t\t\t\t\thi_max = hi_byte;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tthe_shift = (hi_max == 0) ? 8 : 0;\r\n\t\t\t\t\t\tif (!the_shift)\r\n\t\t\t\t\t\t\twhile( ! (hi_max & 0x80) ) {\r\n\t\t\t\t\t\t\t\tthe_shift++;\r\n\t\t\t\t\t\t\t\thi_max <<= 1;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\trow_shifts[height-ys-nrow+y] = the_shift;\r\n\t\t\t\t\t\tthe_shift = 8 - the_shift;\r\n\t\t\t\t\t\tfor (xi=0;xi<(uint32)line;xi++) \r\n\t\t\t\t\t\t\tbits[xi+offset]= ((bits16[xi*2+offset16+1]<<8) | bits16[xi*2+offset16]) >> the_shift;\r\n#else\r\n\t\t\t\t\t\tfor (uint32_t xi=0;xi<(uint32)line;xi++) \r\n\t\t\t\t\t\t\tbits[xi+offset]=bits16[xi*2+offset16+1];\r\n#endif\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tfor (uint32_t xi=0;xi<width;xi++)\r\n\t\t\t\t\t\t\tbits[xi+offset]=bits[xi*2+offset+1];\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (samplesperpixel==1) { \r\n\t\t\t\t\tif (BIG_palette)\r\n\t\t\t\t\t\tif (bits16) {\r\n\t\t\t\t\t\t\tint32_t offset16 = (nrow-y-1)*line16;\t\t// + VK\r\n\t\t\t\t\t\t\tMoveBitsPal( info.pImage + info.dwEffWidth * (height-ys-nrow+y),\r\n\t\t\t\t\t\t\t\t\t bits16 + offset16, width, bitspersample, pal );\r\n\t\t\t\t\t\t} else\r\n\t\t\t\t\t\t\tMoveBitsPal( info.pImage + info.dwEffWidth * (height-ys-nrow+y),\r\n\t\t\t\t\t\t\t\t\t bits + offset, width, bitspersample, pal );\r\n\t\t\t\t\telse if ((bitspersample == head.biBitCount) || \r\n\t\t\t\t\t\t(bitspersample == 16))\t//simple 8bpp, 4bpp image or 16bpp\r\n\t\t\t\t\t\tmemcpy(info.pImage+info.dwEffWidth*(height-ys-nrow+y),bits+offset,min((unsigned)line, info.dwEffWidth));\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tMoveBits( info.pImage + info.dwEffWidth * (height-ys-nrow+y),\r\n\t\t\t\t\t\t\t\t  bits + offset, width, bitspersample );\r\n\t\t\t\t} else if (samplesperpixel==2) { //8bpp image with alpha layer\r\n\t\t\t\t\tint32_t xi=0;\r\n\t\t\t\t\tint32_t ii=0;\r\n\t\t\t\t\tint32_t yi=height-ys-nrow+y;\r\n#if CXIMAGE_SUPPORT_ALPHA\r\n\t\t\t\t\tif (!pAlpha) AlphaCreate();\t\t\t// + VK\r\n#endif //CXIMAGE_SUPPORT_ALPHA\r\n\t\t\t\t\twhile (ii<line){\r\n\t\t\t\t\t\tSetPixelIndex(xi,yi,bits[ii+offset]);\r\n#if CXIMAGE_SUPPORT_ALPHA\r\n\t\t\t\t\t\tAlphaSet(xi,yi,bits[ii+offset+1]);\r\n#endif //CXIMAGE_SUPPORT_ALPHA\r\n\t\t\t\t\t\tii+=2;\r\n\t\t\t\t\t\txi++;\r\n\t\t\t\t\t\tif (xi>=(int32_t)width){\r\n\t\t\t\t\t\t\tyi--;\r\n\t\t\t\t\t\t\txi=0;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t} else { //photometric==PHOTOMETRIC_CIELAB\r\n\t\t\t\t\tif (head.biBitCount!=24){ //fix image\r\n\t\t\t\t\t\tCreate(width,height,24,CXIMAGE_FORMAT_TIF);\r\n#if CXIMAGE_SUPPORT_ALPHA\r\n\t\t\t\t\t\tif (samplesperpixel==4) AlphaCreate();\r\n#endif //CXIMAGE_SUPPORT_ALPHA\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tint32_t xi=0;\r\n\t\t\t\t\tuint32 ii=0;\r\n\t\t\t\t\tint32_t yi=height-ys-nrow+y;\r\n\t\t\t\t\tRGBQUAD c;\r\n\t\t\t\t\tint32_t l,a,b,bitsoffset;\r\n\t\t\t\t\tdouble p,cx,cy,cz,cr,cg,cb;\r\n\t\t\t\t\twhile (ii</*line*/width){\t\t// * VK\r\n\t\t\t\t\t\tbitsoffset = ii*samplesperpixel+offset;\r\n\t\t\t\t\t\tl=bits[bitsoffset];\r\n\t\t\t\t\t\ta=bits[bitsoffset+1];\r\n\t\t\t\t\t\tb=bits[bitsoffset+2];\r\n\t\t\t\t\t\tif (a>127) a-=256;\r\n\t\t\t\t\t\tif (b>127) b-=256;\r\n\t\t\t\t\t\t// lab to xyz\r\n\t\t\t\t\t\tp = (l/2.55 + 16) / 116.0;\r\n\t\t\t\t\t\tcx = pow( p + a * 0.002, 3);\r\n\t\t\t\t\t\tcy = pow( p, 3);\r\n\t\t\t\t\t\tcz = pow( p - b * 0.005, 3);\r\n\t\t\t\t\t\t// white point\r\n\t\t\t\t\t\tcx*=0.95047;\r\n\t\t\t\t\t\t//cy*=1.000;\r\n\t\t\t\t\t\tcz*=1.0883;\r\n\t\t\t\t\t\t// xyz to rgb\r\n\t\t\t\t\t\tcr =  3.240479 * cx - 1.537150 * cy - 0.498535 * cz;\r\n\t\t\t\t\t\tcg = -0.969256 * cx + 1.875992 * cy + 0.041556 * cz;\r\n\t\t\t\t\t\tcb =  0.055648 * cx - 0.204043 * cy + 1.057311 * cz;\r\n\r\n\t\t\t\t\t\tif ( cr > 0.00304 ) cr = 1.055 * pow(cr,0.41667) - 0.055;\r\n\t\t\t\t\t\t\telse            cr = 12.92 * cr;\r\n\t\t\t\t\t\tif ( cg > 0.00304 ) cg = 1.055 * pow(cg,0.41667) - 0.055;\r\n\t\t\t\t\t\t\telse            cg = 12.92 * cg;\r\n\t\t\t\t\t\tif ( cb > 0.00304 ) cb = 1.055 * pow(cb,0.41667) - 0.055;\r\n\t\t\t\t\t\t\telse            cb = 12.92 * cb;\r\n\r\n\t\t\t\t\t\tc.rgbRed  =(uint8_t)max(0,min(255,(int32_t)(cr*255)));\r\n\t\t\t\t\t\tc.rgbGreen=(uint8_t)max(0,min(255,(int32_t)(cg*255)));\r\n\t\t\t\t\t\tc.rgbBlue =(uint8_t)max(0,min(255,(int32_t)(cb*255)));\r\n\r\n\t\t\t\t\t\tSetPixelColor(xi,yi,c);\r\n#if CXIMAGE_SUPPORT_ALPHA\r\n\t\t\t\t\t\tif (samplesperpixel==4) AlphaSet(xi,yi,bits[bitsoffset+3]);\r\n#endif //CXIMAGE_SUPPORT_ALPHA\r\n\t\t\t\t\t\tii++;\r\n\t\t\t\t\t\txi++;\r\n\t\t\t\t\t\tif (xi>=(int32_t)width){\r\n\t\t\t\t\t\t\tyi--;\r\n\t\t\t\t\t\t\txi=0;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tfree(bits);\r\n\t\tif (bits16) free(bits16);\r\n\r\n#ifdef FIX_16BPP_DARKIMG\r\n\t\tif (row_shifts && (samplesperpixel == 1) && (bitspersample==16) && !BIG_palette) {\r\n\t\t\t// 1. calculate maximum necessary shift\r\n\t\t\tint32_t min_row_shift = 8;\r\n\t\t\tfor( y=0; y<height; y++ ) {\r\n\t\t\t\tif (min_row_shift > row_shifts[y]) min_row_shift = row_shifts[y];\r\n\t\t\t}\r\n\t\t\t// 2. for rows having less shift value, correct such rows:\r\n\t\t\tfor( y=0; y<height; y++ ) {\r\n\t\t\t\tif (min_row_shift < row_shifts[y]) {\r\n\t\t\t\t\tint32_t need_shift = row_shifts[y] - min_row_shift;\r\n\t\t\t\t\tuint8_t* data = info.pImage + info.dwEffWidth * y;\r\n\t\t\t\t\tfor( x=0; x<width; x++, data++ )\r\n\t\t\t\t\t\t*data >>= need_shift;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (row_shifts)\tfree( row_shifts );\r\n#endif\r\n\r\n\t\tif (tiled_image) free(tilebuf);\r\n\t\tif (pal)\t\t free(pal);\r\n\r\n\t\tswitch(orientation){\r\n\t\tcase ORIENTATION_TOPRIGHT: /* row 0 top, col 0 rhs */\r\n\t\t\tMirror();\r\n\t\t\tbreak;\r\n\t\tcase ORIENTATION_BOTRIGHT: /* row 0 bottom, col 0 rhs */\r\n\t\t\tFlip();\r\n\t\t\tMirror();\r\n\t\t\tbreak;\r\n\t\tcase ORIENTATION_BOTLEFT: /* row 0 bottom, col 0 lhs */\r\n\t\t\tFlip();\r\n\t\t\tbreak;\r\n\t\tcase ORIENTATION_LEFTTOP: /* row 0 lhs, col 0 top */\r\n\t\t\tRotateRight();\r\n\t\t\tMirror();\r\n\t\t\tbreak;\r\n\t\tcase ORIENTATION_RIGHTTOP: /* row 0 rhs, col 0 top */\r\n\t\t\tRotateLeft();\r\n\t\t\tbreak;\r\n\t\tcase ORIENTATION_RIGHTBOT: /* row 0 rhs, col 0 bottom */\r\n\t\t\tRotateLeft();\r\n\t\t\tMirror();\r\n\t\t\tbreak;\r\n\t\tcase ORIENTATION_LEFTBOT: /* row 0 lhs, col 0 bottom */\r\n\t\t\tRotateRight();\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t}\r\n  } cx_catch {\r\n\t  if (strcmp(message,\"\")) strncpy(info.szLastError,message,255);\r\n\t  if (m_tif) TIFFClose(m_tif);\r\n\t  if (info.nEscape == -1 && info.dwType == CXIMAGE_FORMAT_TIF) return true;\r\n\t  return false;\r\n  }\r\n\tTIFFClose(m_tif);\r\n\treturn true;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n#endif //CXIMAGE_SUPPORT_DECODE\r\n////////////////////////////////////////////////////////////////////////////////\r\n#if CXIMAGE_SUPPORT_ENCODE\r\n////////////////////////////////////////////////////////////////////////////////\r\nbool CxImageTIF::Encode(CxFile * hFile, bool bAppend)\r\n{\r\n  cx_try\r\n  {\r\n\tif (hFile==NULL) cx_throw(CXIMAGE_ERR_NOFILE);\r\n\tif (pDib==NULL) cx_throw(CXIMAGE_ERR_NOIMAGE);\r\n\r\n\t// <RJ> replaced \"w+b\" with \"a\", to append an image directly on an existing file\r\n\tif (m_tif2==NULL) m_tif2=_TIFFOpenEx(hFile, \"a\");\r\n\tif (m_tif2==NULL) cx_throw(\"initialization fail\");\r\n\r\n\tif (bAppend || m_pages) m_multipage=true;\r\n\tm_pages++;\r\n\r\n\tif (!EncodeBody(m_tif2,m_multipage,m_pages,m_pages)) cx_throw(\"Error saving TIFF file\");\r\n\tif (bAppend) {\r\n\t\tif (!TIFFWriteDirectory(m_tif2)) cx_throw(\"Error saving TIFF directory\");\r\n\t}\r\n  } cx_catch {\r\n\t  if (strcmp(message,\"\")) strncpy(info.szLastError,message,255);\r\n\t  if (m_tif2){\r\n\t\t  TIFFClose(m_tif2);\r\n\t\t  m_tif2=NULL;\r\n\t\t  m_multipage=false;\r\n\t\t  m_pages=0;\r\n\t  }\r\n\t  return false;\r\n  }\r\n\tif (!bAppend){\r\n\t\tTIFFClose(m_tif2);\r\n\t\tm_tif2=NULL;\r\n\t\tm_multipage=false;\r\n\t\tm_pages=0;\r\n\t}\r\n\treturn true;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n// Thanks to Abe <God(dot)bless(at)marihuana(dot)com>\r\nbool CxImageTIF::Encode(CxFile * hFile, CxImage ** pImages, int32_t pagecount)\r\n{\r\n  cx_try\r\n  {\r\n\tif (hFile==NULL) cx_throw(\"invalid file pointer\");\r\n\tif (pImages==NULL || pagecount<=0) cx_throw(\"multipage TIFF, no images!\");\r\n\r\n\tint32_t i;\r\n\tfor (i=0; i<pagecount; i++){\r\n\t\tif (pImages[i]==NULL)\r\n\t\t\tcx_throw(\"Bad image pointer\");\r\n\t\tif (!(pImages[i]->IsValid()))\r\n\t\t\tcx_throw(\"Empty image\");\r\n\t}\r\n\r\n\tCxImageTIF ghost;\r\n\tfor (i=0; i<pagecount; i++){\r\n\t\tghost.Ghost(pImages[i]);\r\n\t\tif (!ghost.Encode(hFile,true)) cx_throw(\"Error saving TIFF file\");\r\n\t}\r\n  } cx_catch {\r\n\t  if (strcmp(message,\"\")) strncpy(info.szLastError,message,255);\r\n\t  return false;\r\n  }\r\n\treturn true;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\nbool CxImageTIF::EncodeBody(TIFF *m_tif, bool multipage, int32_t page, int32_t pagecount)\r\n{\r\n\tuint32 height=head.biHeight;\r\n\tuint32 width=head.biWidth;\r\n\tuint16 bitcount=head.biBitCount;\r\n\tuint16 bitspersample;\r\n\tuint16 samplesperpixel;\r\n\tuint16 photometric=0;\r\n\tuint16 compression;\r\n//\tuint16 pitch;\r\n//\tint32_t line;\r\n\tuint32 x, y;\r\n\r\n\tsamplesperpixel = ((bitcount == 24) || (bitcount == 32)) ? (uint8_t)3 : (uint8_t)1;\r\n#if CXIMAGE_SUPPORT_ALPHA\r\n\tif (bitcount==24 && AlphaIsValid()) { bitcount=32; samplesperpixel=4; }\r\n#endif //CXIMAGE_SUPPORT_ALPHA\r\n\r\n\tbitspersample = bitcount / samplesperpixel;\r\n\r\n\t//set the PHOTOMETRIC tag\r\n\tRGBQUAD *rgb = GetPalette();\r\n\tswitch (bitcount) {\r\n\t\tcase 1:\r\n\t\t\tif (CompareColors(&rgb[0],&rgb[1])<0) {\r\n\t\t\t\t/* <abe> some viewers do not handle PHOTOMETRIC_MINISBLACK:\r\n\t\t\t\t * let's transform the image in PHOTOMETRIC_MINISWHITE\r\n\t\t\t\t */\r\n\t\t\t\t//invert the colors\r\n\t\t\t\tRGBQUAD tempRGB=GetPaletteColor(0);\r\n\t\t\t\tSetPaletteColor(0,GetPaletteColor(1));\r\n\t\t\t\tSetPaletteColor(1,tempRGB);\r\n\t\t\t\t//invert the pixels\r\n\t\t\t\tuint8_t *iSrc=info.pImage;\r\n\t\t\t\tfor (uint32_t i=0;i<head.biSizeImage;i++){\r\n\t\t\t\t\t*iSrc=(uint8_t)~(*(iSrc));\r\n\t\t\t\t\tiSrc++;\r\n\t\t\t\t}\r\n\t\t\t\tphotometric = PHOTOMETRIC_MINISWHITE;\r\n\t\t\t\t//photometric = PHOTOMETRIC_MINISBLACK;\r\n\t\t\t} else {\r\n\t\t\t\tphotometric = PHOTOMETRIC_MINISWHITE;\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\tcase 4:\t// Check if the DIB has a color or a greyscale palette\r\n\t\tcase 8:\r\n\t\t\tphotometric = PHOTOMETRIC_MINISBLACK; //default to gray scale\r\n\t\t\tfor (x = 0; x < head.biClrUsed; x++) {\r\n\t\t\t\tif ((rgb->rgbRed != x)||(rgb->rgbRed != rgb->rgbGreen)||(rgb->rgbRed != rgb->rgbBlue)){\r\n\t\t\t\t\tphotometric = PHOTOMETRIC_PALETTE;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\trgb++;\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\tcase 24:\r\n\t\tcase 32:\r\n\t\t\tphotometric = PHOTOMETRIC_RGB;\t\t\t\r\n\t\t\tbreak;\r\n\t}\r\n\r\n#if CXIMAGE_SUPPORT_ALPHA\r\n\tif (AlphaIsValid() && bitcount==8) samplesperpixel=2; //8bpp + alpha layer\r\n#endif //CXIMAGE_SUPPORT_ALPHA\r\n\r\n//\tline = CalculateLine(width, bitspersample * samplesperpixel);\r\n//\tpitch = (uint16)CalculatePitch(line);\r\n\r\n\t//prepare the palette struct\r\n\tRGBQUAD pal[256];\r\n\tif (GetPalette()){\r\n\t\tuint8_t b;\r\n\t\tmemcpy(pal,GetPalette(),GetPaletteSize());\r\n\t\tfor(uint16_t a=0;a<head.biClrUsed;a++){\t//swap blue and red components\r\n\t\t\tb=pal[a].rgbBlue; pal[a].rgbBlue=pal[a].rgbRed; pal[a].rgbRed=b;\r\n\t\t}\r\n\t}\r\n\r\n\t// handle standard width/height/bpp stuff\r\n\tTIFFSetField(m_tif, TIFFTAG_IMAGEWIDTH, width);\r\n\tTIFFSetField(m_tif, TIFFTAG_IMAGELENGTH, height);\r\n\tTIFFSetField(m_tif, TIFFTAG_SAMPLESPERPIXEL, samplesperpixel);\r\n\tTIFFSetField(m_tif, TIFFTAG_BITSPERSAMPLE, bitspersample);\r\n\tTIFFSetField(m_tif, TIFFTAG_PHOTOMETRIC, photometric);\r\n\tTIFFSetField(m_tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\t// single image plane \r\n\tTIFFSetField(m_tif, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\r\n\r\n\tuint32 rowsperstrip = TIFFDefaultStripSize(m_tif, (uint32) -1);  //<REC> gives better compression\r\n\tTIFFSetField(m_tif, TIFFTAG_ROWSPERSTRIP, rowsperstrip);\r\n\r\n\t// handle metrics\r\n\tTIFFSetField(m_tif, TIFFTAG_RESOLUTIONUNIT, RESUNIT_INCH);\r\n\tTIFFSetField(m_tif, TIFFTAG_XRESOLUTION, (float)info.xDPI);\r\n\tTIFFSetField(m_tif, TIFFTAG_YRESOLUTION, (float)info.yDPI);\r\n//\tTIFFSetField(m_tif, TIFFTAG_XPOSITION, (float)info.xOffset);\r\n//\tTIFFSetField(m_tif, TIFFTAG_YPOSITION, (float)info.yOffset);\r\n\r\n\t// multi-paging - Thanks to Abe <God(dot)bless(at)marihuana(dot)com>\r\n\tif (multipage)\r\n\t{\r\n\t\tchar page_number[20];\r\n\t\tsprintf(page_number, \"Page %d\", page);\r\n\r\n\t\tTIFFSetField(m_tif, TIFFTAG_SUBFILETYPE, FILETYPE_PAGE);\r\n\t\tTIFFSetField(m_tif, TIFFTAG_PAGENUMBER, page,pagecount);\r\n\t\tTIFFSetField(m_tif, TIFFTAG_PAGENAME, page_number);\r\n\t} else {\r\n\t\tTIFFSetField(m_tif, TIFFTAG_SUBFILETYPE, 0);\r\n\t}\r\n\r\n\t// palettes (image colormaps are automatically scaled to 16-bits)\r\n\tif (photometric == PHOTOMETRIC_PALETTE) {\r\n\t\tuint16 *r, *g, *b;\r\n\t\tr = (uint16 *) _TIFFmalloc(sizeof(uint16) * 3 * 256);\r\n\t\tg = r + 256;\r\n\t\tb = g + 256;\r\n\r\n\t\tfor (int32_t i = 255; i >= 0; i--) {\r\n\t\t\tb[i] = (uint16)SCALE((uint16)pal[i].rgbRed);\r\n\t\t\tg[i] = (uint16)SCALE((uint16)pal[i].rgbGreen);\r\n\t\t\tr[i] = (uint16)SCALE((uint16)pal[i].rgbBlue);\r\n\t\t}\r\n\r\n\t\tTIFFSetField(m_tif, TIFFTAG_COLORMAP, r, g, b);\r\n\t\t_TIFFfree(r);\r\n\t}\r\n\r\n\t// compression\r\n\tif (GetCodecOption(CXIMAGE_FORMAT_TIF)) {\r\n\t\tcompression = (uint16_t)GetCodecOption(CXIMAGE_FORMAT_TIF);\r\n\t} else {\r\n\t\tswitch (bitcount) {\r\n\t\t\tcase 1 :\r\n\t\t\t\tcompression = COMPRESSION_CCITTFAX4;\r\n\t\t\t\tbreak;\r\n\t\t\tcase 4 :\r\n\t\t\tcase 8 :\r\n\t\t\t\tcompression = COMPRESSION_LZW;\r\n\t\t\t\tbreak;\r\n\t\t\tcase 24 :\r\n\t\t\tcase 32 :\r\n\t\t\t\tcompression = COMPRESSION_JPEG;\r\n\t\t\t\tbreak;\r\n\t\t\tdefault :\r\n\t\t\t\tcompression = COMPRESSION_NONE;\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\tTIFFSetField(m_tif, TIFFTAG_COMPRESSION, compression);\r\n\r\n\tswitch (compression) {\r\n\tcase COMPRESSION_JPEG:\r\n\t\tTIFFSetField(m_tif, TIFFTAG_JPEGQUALITY, GetJpegQuality());\r\n\t\tTIFFSetField(m_tif, TIFFTAG_ROWSPERSTRIP, ((7+rowsperstrip)>>3)<<3);\r\n   \t\tbreak;\r\n\tcase COMPRESSION_LZW:\r\n\t\tif (bitcount>=8) TIFFSetField(m_tif, TIFFTAG_PREDICTOR, 2);\r\n\t\tbreak;\r\n\t}\r\n\r\n\t// read the DIB lines from bottom to top and save them in the TIF\r\n\r\n\tuint8_t *bits;\r\n\tswitch(bitcount) {\t\t\t\t\r\n\t\tcase 1 :\r\n\t\tcase 4 :\r\n\t\tcase 8 :\r\n\t\t{\r\n\t\t\tif (samplesperpixel==1){\r\n\t\t\t\tbits = (uint8_t*)malloc(info.dwEffWidth);\r\n\t\t\t\tif (!bits) return false;\r\n\t\t\t\tfor (y = 0; y < height; y++) {\r\n\t\t\t\t\tmemcpy(bits,info.pImage + (height - y - 1)*info.dwEffWidth,info.dwEffWidth);\r\n\t\t\t\t\tif (TIFFWriteScanline(m_tif,bits, y, 0)==-1){\r\n\t\t\t\t\t\tfree(bits);\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tfree(bits);\r\n\t\t\t}\r\n#if CXIMAGE_SUPPORT_ALPHA\r\n\t\t\telse { //8bpp + alpha layer\r\n\t\t\t\tbits = (uint8_t*)malloc(2*width);\r\n\t\t\t\tif (!bits) return false;\r\n\t\t\t\tfor (y = 0; y < height; y++) {\r\n\t\t\t\t\tfor (x=0;x<width;x++){\r\n\t\t\t\t\t\tbits[2*x]=BlindGetPixelIndex(x,height - y - 1);\r\n\t\t\t\t\t\tbits[2*x+1]=AlphaGet(x,height - y - 1);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (TIFFWriteScanline(m_tif,bits, y, 0)==-1) {\r\n\t\t\t\t\t\tfree(bits);\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tfree(bits);\r\n\t\t\t}\r\n#endif //CXIMAGE_SUPPORT_ALPHA\r\n\t\t\tbreak;\r\n\t\t}\t\t\t\t\r\n\t\tcase 24:\r\n\t\t{\r\n\t\t\tuint8_t *buffer = (uint8_t *)malloc(info.dwEffWidth);\r\n\t\t\tif (!buffer) return false;\r\n\t\t\tfor (y = 0; y < height; y++) {\r\n\t\t\t\t// get a pointer to the scanline\r\n\t\t\t\tmemcpy(buffer, info.pImage + (height - y - 1)*info.dwEffWidth, info.dwEffWidth);\r\n\t\t\t\t// TIFFs store color data RGB instead of BGR\r\n\t\t\t\tuint8_t *pBuf = buffer;\r\n\t\t\t\tfor (x = 0; x < width; x++) {\r\n\t\t\t\t\tuint8_t tmp = pBuf[0];\r\n\t\t\t\t\tpBuf[0] = pBuf[2];\r\n\t\t\t\t\tpBuf[2] = tmp;\r\n\t\t\t\t\tpBuf += 3;\r\n\t\t\t\t}\r\n\t\t\t\t// write the scanline to disc\r\n\t\t\t\tif (TIFFWriteScanline(m_tif, buffer, y, 0)==-1){\r\n\t\t\t\t\tfree(buffer);\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tfree(buffer);\r\n\t\t\tbreak;\r\n\t\t}\t\t\t\t\r\n\t\tcase 32 :\r\n\t\t{\r\n#if CXIMAGE_SUPPORT_ALPHA\r\n\t\t\tuint8_t *buffer = (uint8_t *)malloc((info.dwEffWidth*4)/3);\r\n\t\t\tif (!buffer) return false;\r\n\t\t\tfor (y = 0; y < height; y++) {\r\n\t\t\t\t// get a pointer to the scanline\r\n\t\t\t\tmemcpy(buffer, info.pImage + (height - y - 1)*info.dwEffWidth, info.dwEffWidth);\r\n\t\t\t\t// TIFFs store color data RGB instead of BGR\r\n\t\t\t\tuint8_t *pSrc = buffer + 3 * width;\r\n\t\t\t\tuint8_t *pDst = buffer + 4 * width;\r\n\t\t\t\tfor (x = 0; x < width; x++) {\r\n\t\t\t\t\tpDst-=4;\r\n\t\t\t\t\tpSrc-=3;\r\n\t\t\t\t\tpDst[3] = AlphaGet(width-x-1,height-y-1);\r\n\t\t\t\t\tpDst[2] = pSrc[0];\r\n\t\t\t\t\tpDst[1] = pSrc[1];\r\n\t\t\t\t\tpDst[0] = pSrc[2];\r\n\t\t\t\t}\r\n\t\t\t\t// write the scanline to disc\r\n\t\t\t\tif (TIFFWriteScanline(m_tif, buffer, y, 0)==-1){\r\n\t\t\t\t\tfree(buffer);\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tfree(buffer);\r\n#endif //CXIMAGE_SUPPORT_ALPHA\r\n\t\t\tbreak;\r\n\t\t}\t\t\t\t\r\n\t}\r\n\treturn true;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n#endif // CXIMAGE_SUPPORT_ENCODE\r\n////////////////////////////////////////////////////////////////////////////////\r\nvoid CxImageTIF::TileToStrip(uint8* out, uint8* in,\tuint32 rows, uint32 cols, int32_t outskew, int32_t inskew)\r\n{\r\n\twhile (rows-- > 0) {\r\n\t\tuint32 j = cols;\r\n\t\twhile (j-- > 0)\r\n\t\t\t*out++ = *in++;\r\n\t\tout += outskew;\r\n\t\tin += inskew;\r\n\t}\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\nTIFF* CxImageTIF::TIFFOpenEx(CxFile * hFile)\r\n{\r\n\tif (hFile) return _TIFFOpenEx(hFile, \"rb\");\r\n\treturn NULL;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\nvoid CxImageTIF::TIFFCloseEx(TIFF* tif)\r\n{\r\n\tif (tif) TIFFClose(tif);\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\nvoid CxImageTIF::MoveBits( uint8_t* dest, uint8_t* from, int32_t count, int32_t bpp )\r\n{\tint32_t offbits = 0;\r\n\tuint16 w;\r\n\tuint32 d;\r\n\tif (bpp <= 8) {\r\n\t\twhile (count-- > 0) {\r\n\t\t\tif (offbits + bpp <= 8)\r\n\t\t\t\tw = *from >> (8 - offbits - bpp);\r\n\t\t\telse {\r\n\t\t        w = *from++ << (offbits + bpp - 8);\r\n\t\t\t\tw |= *from >> (16 - offbits - bpp);\r\n\t\t\t}\r\n\t\t\toffbits += bpp;\r\n\t\t\tif (offbits >= 8) {\r\n\t\t\t\toffbits -= 8;\r\n\t\t        if (offbits == 0) from++;\r\n\t\t\t}\t\r\n\t\t\t*dest++ = (uint8_t)w & ((1 << bpp)-1);\r\n\t\t}\r\n\t} else if (bpp < 16) {\r\n\t\twhile (count-- > 0) {\r\n\t\t\td = (*from << 24) | (from[1]<<16) | (from[2]<<8) | from[3];\r\n\t\t\td >>= (24 - offbits);\r\n\t\t\t*dest++ = (uint8_t) ( d );\r\n\t\t\toffbits += bpp;\r\n\t\t\twhile (offbits >= 8) {\r\n\t\t\t\tfrom++;\r\n\t\t\t\toffbits -= 8;\r\n\t\t\t}\r\n\t\t}\r\n\t} else if (bpp < 32) {\r\n\t\twhile (count-- > 0) {\r\n\t\t\td = (*from << 24) | (from[1]<<16) | (from[2]<<8) | from[3];\r\n\t\t\t//d = *(uint32*)from;\r\n\t\t\t*dest++ = (uint8_t) ( d >> (offbits + bpp - 8) );\r\n\t\t\toffbits += bpp;\r\n\t\t\twhile (offbits >= 8) {\r\n\t\t\t\tfrom++;\r\n\t\t\t\toffbits -= 8;\r\n\t\t\t}\r\n\t\t}\r\n\t} else {\r\n\t\twhile (count-- > 0) {\r\n\t\t\td = *(uint32*)from;\r\n\t\t\t*dest++ = (uint8_t) (d >> 24);\r\n\t\t\tfrom += 4;\r\n\t\t}\r\n\t}\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\nvoid CxImageTIF::MoveBitsPal( uint8_t* dest, uint8_t*from, int32_t count, int32_t bpp, RGBQUAD* pal )\r\n{\tint32_t offbits = 0;\r\n\tuint32 d;\r\n\tuint16 palidx;\r\n\twhile (count-- > 0) {\r\n\t\td = (*from << 24) | ( *( from + 1 ) << 16 )\r\n\t\t\t\t\t\t  | ( *( from + 2 ) << 8 )\r\n\t\t\t\t\t\t  | ( *( from + 3 ) );\r\n\t\tpalidx = (uint16) (d >> (32 - offbits - bpp));\r\n\t\tif (bpp < 16) {\r\n\t\t\tpalidx <<= 16-bpp;\r\n\t\t\tpalidx = (palidx >> 8) | (palidx <<8);\r\n\t\t\tpalidx >>= 16-bpp;\r\n\t\t} else palidx = (palidx >> 8) | (palidx << 8);\r\n\t\t*dest++ = pal[palidx].rgbBlue;\r\n\t\t*dest++ = pal[palidx].rgbGreen;\r\n\t\t*dest++ = pal[palidx].rgbRed;\r\n\t\toffbits += bpp;\r\n\t\twhile (offbits >= 8) {\r\n\t\t\tfrom++;\r\n\t\t\toffbits -= 8;\r\n\t\t}\r\n\t}\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n\r\n#endif // CXIMAGE_SUPPORT_TIF\r\n", "\ufeff#if !defined(__xiofile_h)\r\n#define __xiofile_h\r\n\r\n#include \"xfile.h\"\r\n#if !defined(_WIN32) && !defined (_WIN64)\r\n//#include \"../../../Common/DocxFormat/Source/Base/ASCString.h\"\r\n#endif\r\n//#include <TCHAR.h>\r\n\r\n/*\r\n#ifndef WIN32\r\n    #ifdef _UNICODE\r\n        typedef wchar_t TCHAR;\r\n    #else\r\n        typedef char TCHAR;\r\n    #endif\r\n#endif\r\n*/\r\n\r\nclass DLL_EXP CxIOFile : public CxFile\r\n\t{\r\npublic:\r\n\tCxIOFile(FILE* fp = NULL)\r\n\t{\r\n\t\tm_fp = fp;\r\n\t\tm_bCloseFile = (bool)(fp==0);\r\n\t}\r\n\r\n\t~CxIOFile()\r\n\t{\r\n\t\tClose();\r\n\t}\r\n//////////////////////////////////////////////////////////\r\n\tbool Open(const TCHAR * filename, const TCHAR * mode)\r\n\t{\r\n#ifdef CXIMAGE_DONT_USE_LOAD_SAVE\r\n    return false;\r\n#else\r\n#if defined(_WIN32) || defined (_WIN64)\r\n\t\tif (m_fp) return false;\t// Can't re-open without closing first\r\n\r\n\t\tm_fp = _tfopen(filename, mode);\r\n\t\tif (!m_fp) return false;\r\n\r\n\t\tm_bCloseFile = true;\r\n#endif\r\n\r\n\t\treturn true;\r\n#endif // #ifdef CXIMAGE_DONT_USE_LOAD_SAVE\r\n\t}\r\n//////////////////////////////////////////////////////////\r\n\tvirtual bool Close()\r\n\t{\r\n\t\tint32_t iErr = 0;\r\n\t\tif ( (m_fp) && (m_bCloseFile) ){ \r\n\t\t\tiErr = fclose(m_fp);\r\n\t\t\tm_fp = NULL;\r\n\t\t}\r\n\t\treturn (bool)(iErr==0);\r\n\t}\r\n//////////////////////////////////////////////////////////\r\n\tvirtual size_t\tRead(void *buffer, size_t size, size_t count)\r\n\t{\r\n\t\tif (!m_fp) return 0;\r\n\t\treturn fread(buffer, size, count, m_fp);\r\n\t}\r\n//////////////////////////////////////////////////////////\r\n\tvirtual size_t\tWrite(const void *buffer, size_t size, size_t count)\r\n\t{\r\n\t\tif (!m_fp) return 0;\r\n\t\treturn fwrite(buffer, size, count, m_fp);\r\n\t}\r\n//////////////////////////////////////////////////////////\r\n\tvirtual bool Seek(int32_t offset, int32_t origin)\r\n\t{\r\n\t\tif (!m_fp) return false;\r\n\t\treturn (bool)(fseek(m_fp, offset, origin) == 0);\r\n\t}\r\n//////////////////////////////////////////////////////////\r\n\tvirtual int32_t Tell()\r\n\t{\r\n\t\tif (!m_fp) return 0;\r\n\t\treturn ftell(m_fp);\r\n\t}\r\n//////////////////////////////////////////////////////////\r\n\tvirtual int32_t\tSize()\r\n\t{\r\n\t\tif (!m_fp) return -1;\r\n\t\tint32_t pos,size;\r\n\t\tpos = ftell(m_fp);\r\n\t\tfseek(m_fp, 0, SEEK_END);\r\n\t\tsize = ftell(m_fp);\r\n\t\tfseek(m_fp, pos,SEEK_SET);\r\n\t\treturn size;\r\n\t}\r\n//////////////////////////////////////////////////////////\r\n\tvirtual bool\tFlush()\r\n\t{\r\n\t\tif (!m_fp) return false;\r\n\t\treturn (bool)(fflush(m_fp) == 0);\r\n\t}\r\n//////////////////////////////////////////////////////////\r\n\tvirtual bool\tEof()\r\n\t{\r\n\t\tif (!m_fp) return true;\r\n\t\treturn (bool)(feof(m_fp) != 0);\r\n\t}\r\n//////////////////////////////////////////////////////////\r\n\tvirtual int32_t\tError()\r\n\t{\r\n\t\tif (!m_fp) return -1;\r\n\t\treturn ferror(m_fp);\r\n\t}\r\n//////////////////////////////////////////////////////////\r\n\tvirtual bool PutC(uint8_t c)\r\n\t{\r\n\t\tif (!m_fp) return false;\r\n\t\treturn (bool)(fputc(c, m_fp) == c);\r\n\t}\r\n//////////////////////////////////////////////////////////\r\n\tvirtual int32_t\tGetC()\r\n\t{\r\n\t\tif (!m_fp) return EOF;\r\n\t\treturn getc(m_fp);\r\n\t}\r\n//////////////////////////////////////////////////////////\r\n\tvirtual char *\tGetS(char *string, int32_t n)\r\n\t{\r\n\t\tif (!m_fp) return NULL;\r\n\t\treturn fgets(string,n,m_fp);\r\n\t}\r\n//////////////////////////////////////////////////////////\r\n\tvirtual int32_t\tScanf(const char *format, void* output)\r\n\t{\r\n\t\tif (!m_fp) return EOF;\r\n\t\treturn fscanf(m_fp, format, output);\r\n\t}\r\n//////////////////////////////////////////////////////////\r\nprotected:\r\n\tFILE *m_fp;\r\n\tbool m_bCloseFile;\r\n\t};\r\n\r\n#endif\r\n", "\ufeff#include \"xmemfile.h\"\r\n\r\n//////////////////////////////////////////////////////////\r\nCxMemFile::CxMemFile(uint8_t* pBuffer, uint32_t size)\r\n{\r\n\tm_pBuffer = pBuffer;\r\n\tm_Position = 0;\r\n\tm_Size = m_Edge = size;\r\n\tm_bFreeOnClose = (bool)(pBuffer==0);\r\n\tm_bEOF = false;\r\n}\r\n//////////////////////////////////////////////////////////\r\nCxMemFile::~CxMemFile()\r\n{\r\n\tClose();\r\n}\r\n//////////////////////////////////////////////////////////\r\nbool CxMemFile::Close()\r\n{\r\n\tif ( (m_pBuffer) && (m_bFreeOnClose) ){\r\n\t\tfree(m_pBuffer);\r\n\t\tm_pBuffer = NULL;\r\n\t\tm_Size = 0;\r\n\t}\r\n\treturn true;\r\n}\r\n//////////////////////////////////////////////////////////\r\nbool CxMemFile::Open()\r\n{\r\n\tif (m_pBuffer) return false;\t// Can't re-open without closing first\r\n\r\n\tm_Position = m_Size = m_Edge = 0;\r\n\tm_pBuffer=(uint8_t*)malloc(1);\r\n\tm_bFreeOnClose = true;\r\n\r\n\treturn (m_pBuffer!=0);\r\n}\r\n//////////////////////////////////////////////////////////\r\nuint8_t* CxMemFile::GetBuffer(bool bDetachBuffer)\r\n{\r\n\t//can only detach, avoid inadvertantly attaching to\r\n\t// memory that may not be ours [Jason De Arte]\r\n\tif( bDetachBuffer )\r\n\t\tm_bFreeOnClose = false;\r\n\treturn m_pBuffer;\r\n}\r\n//////////////////////////////////////////////////////////\r\nsize_t CxMemFile::Read(void *buffer, size_t size, size_t count)\r\n{\r\n\tif (buffer==NULL) return 0;\r\n\r\n\tif (m_pBuffer==NULL) return 0;\r\n\tif (m_Position >= (int32_t)m_Size){\r\n\t\tm_bEOF = true;\r\n\t\treturn 0;\r\n\t}\r\n\r\n\tint32_t nCount = (int32_t)(count*size);\r\n\tif (nCount == 0) return 0;\r\n\r\n\tint32_t nRead;\r\n\tif (m_Position + nCount > (int32_t)m_Size){\r\n\t\tm_bEOF = true;\r\n\t\tnRead = (m_Size - m_Position);\r\n\t} else\r\n\t\tnRead = nCount;\r\n\r\n\tmemcpy(buffer, m_pBuffer + m_Position, nRead);\r\n\tm_Position += nRead;\r\n\r\n\treturn (size_t)(nRead/size);\r\n}\r\n//////////////////////////////////////////////////////////\r\nsize_t CxMemFile::Write(const void *buffer, size_t size, size_t count)\r\n{\r\n\tm_bEOF = false;\r\n\tif (m_pBuffer==NULL) return 0;\r\n\tif (buffer==NULL) return 0;\r\n\r\n\tint32_t nCount = (int32_t)(count*size);\r\n\tif (nCount == 0) return 0;\r\n\r\n\tif (m_Position + nCount > m_Edge){\r\n\t\tif (!Alloc(m_Position + nCount)){\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n\r\n\tmemcpy(m_pBuffer + m_Position, buffer, nCount);\r\n\r\n\tm_Position += nCount;\r\n\r\n\tif (m_Position > (int32_t)m_Size) m_Size = m_Position;\r\n\t\r\n\treturn count;\r\n}\r\n//////////////////////////////////////////////////////////\r\nbool CxMemFile::Seek(int32_t offset, int32_t origin)\r\n{\r\n\tm_bEOF = false;\r\n\tif (m_pBuffer==NULL) return false;\r\n\tint32_t lNewPos = m_Position;\r\n\r\n\tif (origin == SEEK_SET)\t\t lNewPos = offset;\r\n\telse if (origin == SEEK_CUR) lNewPos += offset;\r\n\telse if (origin == SEEK_END) lNewPos = m_Size + offset;\r\n\telse return false;\r\n\r\n\tif (lNewPos < 0) lNewPos = 0;\r\n\r\n\tm_Position = lNewPos;\r\n\treturn true;\r\n}\r\n//////////////////////////////////////////////////////////\r\nint32_t CxMemFile::Tell()\r\n{\r\n\tif (m_pBuffer==NULL) return -1;\r\n\treturn m_Position;\r\n}\r\n//////////////////////////////////////////////////////////\r\nint32_t CxMemFile::Size()\r\n{\r\n\tif (m_pBuffer==NULL) return -1;\r\n\treturn m_Size;\r\n}\r\n//////////////////////////////////////////////////////////\r\nbool CxMemFile::Flush()\r\n{\r\n\tif (m_pBuffer==NULL) return false;\r\n\treturn true;\r\n}\r\n//////////////////////////////////////////////////////////\r\nbool CxMemFile::Eof()\r\n{\r\n\tif (m_pBuffer==NULL) return true;\r\n\treturn m_bEOF;\r\n}\r\n//////////////////////////////////////////////////////////\r\nint32_t CxMemFile::Error()\r\n{\r\n\tif (m_pBuffer==NULL) return -1;\r\n\treturn (m_Position > (int32_t)m_Size);\r\n}\r\n//////////////////////////////////////////////////////////\r\nbool CxMemFile::PutC(uint8_t c)\r\n{\r\n\tm_bEOF = false;\r\n\tif (m_pBuffer==NULL) return false;\r\n\r\n\tif (m_Position >= m_Edge){\r\n\t\tif (!Alloc(m_Position + 1)){\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n\r\n\tm_pBuffer[m_Position++] = c;\r\n\r\n\tif (m_Position > (int32_t)m_Size) m_Size = m_Position;\r\n\t\r\n\treturn true;\r\n}\r\n//////////////////////////////////////////////////////////\r\nint32_t CxMemFile::GetC()\r\n{\r\n\tif (m_pBuffer==NULL || m_Position >= (int32_t)m_Size){\r\n\t\tm_bEOF = true;\r\n\t\treturn EOF;\r\n\t}\r\n\treturn *(uint8_t*)((uint8_t*)m_pBuffer + m_Position++);\r\n}\r\n//////////////////////////////////////////////////////////\r\nchar * CxMemFile::GetS(char *string, int32_t n)\r\n{\r\n\tn--;\r\n\tint32_t c,i=0;\r\n\twhile (i<n){\r\n\t\tc = GetC();\r\n\t\tif (c == EOF) return 0;\r\n\t\tstring[i++] = (char)c;\r\n\t\tif (c == '\\n') break;\r\n\t}\r\n\tstring[i] = 0;\r\n\treturn string;\r\n}\r\n//////////////////////////////////////////////////////////\r\nint32_t\tCxMemFile::Scanf(const char *format, void* output)\r\n{\r\n\treturn 0;\r\n}\r\n//////////////////////////////////////////////////////////\r\nbool CxMemFile::Alloc(uint32_t dwNewLen)\r\n{\r\n\tif (dwNewLen > (uint32_t)m_Edge)\r\n\t{\r\n\t\t// find new buffer size\r\n\t\tuint32_t dwNewBufferSize = (uint32_t)(((dwNewLen>>16)+1)<<16);\r\n\r\n\t\t// allocate new buffer\r\n\t\tif (m_pBuffer == NULL) m_pBuffer = (uint8_t*)malloc(dwNewBufferSize);\r\n\t\telse\tm_pBuffer = (uint8_t*)realloc(m_pBuffer, dwNewBufferSize);\r\n\t\t// I own this buffer now (caller knows nothing about it)\r\n\t\tm_bFreeOnClose = true;\r\n\r\n\t\tm_Edge = dwNewBufferSize;\r\n\t}\r\n\treturn (m_pBuffer!=0);\r\n}\r\n//////////////////////////////////////////////////////////\r\nvoid CxMemFile::Free()\r\n{\r\n\tClose();\r\n}\r\n//////////////////////////////////////////////////////////\r\n", "\ufeff#if !defined(__xmemfile_h)\r\n#define __xmemfile_h\r\n\r\n#include \"xfile.h\"\r\n\r\n//////////////////////////////////////////////////////////\r\nclass DLL_EXP CxMemFile : public CxFile\r\n{\r\npublic:\r\n\tCxMemFile(uint8_t* pBuffer = NULL, uint32_t size = 0);\r\n\t~CxMemFile();\r\n\r\n\tbool Open();\r\n\tuint8_t* GetBuffer(bool bDetachBuffer = true);\r\n\r\n\tvirtual bool\tClose();\r\n\tvirtual size_t\tRead(void *buffer, size_t size, size_t count);\r\n\tvirtual size_t\tWrite(const void *buffer, size_t size, size_t count);\r\n\tvirtual bool\tSeek(int32_t offset, int32_t origin);\r\n\tvirtual int32_t\tTell();\r\n\tvirtual int32_t\tSize();\r\n\tvirtual bool\tFlush();\r\n\tvirtual bool\tEof();\r\n\tvirtual int32_t\tError();\r\n\tvirtual bool\tPutC(uint8_t c);\r\n\tvirtual int32_t\tGetC();\r\n\tvirtual char *\tGetS(char *string, int32_t n);\r\n\tvirtual int32_t\tScanf(const char *format, void* output);\r\n\r\nprotected:\r\n\tbool\tAlloc(uint32_t nBytes);\r\n\tvoid\tFree();\r\n\r\n\tuint8_t*\tm_pBuffer;\r\n\tuint32_t\tm_Size;\r\n\tbool\tm_bFreeOnClose;\r\n\tint32_t\tm_Position;\t//current position\r\n\tint32_t\tm_Edge;\t\t//buffer size\r\n\tbool\tm_bEOF;\r\n};\r\n\r\n#endif\r\n", "/*\n * Copyright (c) 1999-2000 Image Power, Inc. and the University of\n *   British Columbia.\n * Copyright (c) 2001-2003 Michael David Adams.\n * All rights reserved.\n */\n\n/* __START_OF_JASPER_LICENSE__\n * \n * JasPer License Version 2.0\n * \n * Copyright (c) 2001-2006 Michael David Adams\n * Copyright (c) 1999-2000 Image Power, Inc.\n * Copyright (c) 1999-2000 The University of British Columbia\n * \n * All rights reserved.\n * \n * Permission is hereby granted, free of charge, to any person (the\n * \"User\") obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without restriction,\n * including without limitation the rights to use, copy, modify, merge,\n * publish, distribute, and/or sell copies of the Software, and to permit\n * persons to whom the Software is furnished to do so, subject to the\n * following conditions:\n * \n * 1.  The above copyright notices and this permission notice (which\n * includes the disclaimer below) shall be included in all copies or\n * substantial portions of the Software.\n * \n * 2.  The name of a copyright holder shall not be used to endorse or\n * promote products derived from the Software without specific prior\n * written permission.\n * \n * THIS DISCLAIMER OF WARRANTY CONSTITUTES AN ESSENTIAL PART OF THIS\n * LICENSE.  NO USE OF THE SOFTWARE IS AUTHORIZED HEREUNDER EXCEPT UNDER\n * THIS DISCLAIMER.  THE SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS\n * \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING\n * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n * PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY RIGHTS.  IN NO\n * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL\n * INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING\n * FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,\n * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION\n * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  NO ASSURANCES ARE\n * PROVIDED BY THE COPYRIGHT HOLDERS THAT THE SOFTWARE DOES NOT INFRINGE\n * THE PATENT OR OTHER INTELLECTUAL PROPERTY RIGHTS OF ANY OTHER ENTITY.\n * EACH COPYRIGHT HOLDER DISCLAIMS ANY LIABILITY TO THE USER FOR CLAIMS\n * BROUGHT BY ANY OTHER ENTITY BASED ON INFRINGEMENT OF INTELLECTUAL\n * PROPERTY RIGHTS OR OTHERWISE.  AS A CONDITION TO EXERCISING THE RIGHTS\n * GRANTED HEREUNDER, EACH USER HEREBY ASSUMES SOLE RESPONSIBILITY TO SECURE\n * ANY OTHER INTELLECTUAL PROPERTY RIGHTS NEEDED, IF ANY.  THE SOFTWARE\n * IS NOT FAULT-TOLERANT AND IS NOT INTENDED FOR USE IN MISSION-CRITICAL\n * SYSTEMS, SUCH AS THOSE USED IN THE OPERATION OF NUCLEAR FACILITIES,\n * AIRCRAFT NAVIGATION OR COMMUNICATION SYSTEMS, AIR TRAFFIC CONTROL\n * SYSTEMS, DIRECT LIFE SUPPORT MACHINES, OR WEAPONS SYSTEMS, IN WHICH\n * THE FAILURE OF THE SOFTWARE OR SYSTEM COULD LEAD DIRECTLY TO DEATH,\n * PERSONAL INJURY, OR SEVERE PHYSICAL OR ENVIRONMENTAL DAMAGE (\"HIGH\n * RISK ACTIVITIES\").  THE COPYRIGHT HOLDERS SPECIFICALLY DISCLAIM ANY\n * EXPRESS OR IMPLIED WARRANTY OF FITNESS FOR HIGH RISK ACTIVITIES.\n * \n * __END_OF_JASPER_LICENSE__\n */\n\n/*\n * $Id$\n */\n\n/******************************************************************************\\\n* Includes.\n\\******************************************************************************/\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n\n#include \"jasper/jas_types.h\"\n#include \"jasper/jas_math.h\"\n#include \"jasper/jas_tvp.h\"\n#include \"jasper/jas_malloc.h\"\n#include \"jasper/jas_debug.h\"\n\n#include \"jpc_fix.h\"\n#include \"jpc_dec.h\"\n#include \"jpc_cs.h\"\n#include \"jpc_mct.h\"\n#include \"jpc_t2dec.h\"\n#include \"jpc_t1dec.h\"\n#include \"jpc_math.h\"\n\n/******************************************************************************\\\n*\n\\******************************************************************************/\n\n#define\tJPC_MHSOC\t0x0001\n  /* In the main header, expecting a SOC marker segment. */\n#define\tJPC_MHSIZ\t0x0002\n  /* In the main header, expecting a SIZ marker segment. */\n#define\tJPC_MH\t\t0x0004\n  /* In the main header, expecting \"other\" marker segments. */\n#define\tJPC_TPHSOT\t0x0008\n  /* In a tile-part header, expecting a SOT marker segment. */\n#define\tJPC_TPH\t\t0x0010\n  /* In a tile-part header, expecting \"other\" marker segments. */\n#define\tJPC_MT\t\t0x0020\n  /* In the main trailer. */\n\ntypedef struct {\n\n\tuint_fast16_t id;\n\t/* The marker segment type. */\n\n\tint validstates;\n\t/* The states in which this type of marker segment can be\n\t  validly encountered. */\n\n\tint (*action)(jpc_dec_t *dec, jpc_ms_t *ms);\n\t/* The action to take upon encountering this type of marker segment. */\n\n} jpc_dec_mstabent_t;\n\n/******************************************************************************\\\n*\n\\******************************************************************************/\n\n/* COD/COC parameters have been specified. */\n#define\tJPC_CSET\t0x0001\n/* QCD/QCC parameters have been specified. */\n#define\tJPC_QSET\t0x0002\n/* COD/COC parameters set from a COC marker segment. */\n#define\tJPC_COC\t0x0004\n/* QCD/QCC parameters set from a QCC marker segment. */\n#define\tJPC_QCC\t0x0008\n\n/******************************************************************************\\\n* Local function prototypes.\n\\******************************************************************************/\n\nstatic int jpc_dec_dump(jpc_dec_t *dec, FILE *out);\n\njpc_ppxstab_t *jpc_ppxstab_create(void);\nvoid jpc_ppxstab_destroy(jpc_ppxstab_t *tab);\nint jpc_ppxstab_grow(jpc_ppxstab_t *tab, int maxents);\nint jpc_ppxstab_insert(jpc_ppxstab_t *tab, jpc_ppxstabent_t *ent);\njpc_streamlist_t *jpc_ppmstabtostreams(jpc_ppxstab_t *tab);\nint jpc_pptstabwrite(jas_stream_t *out, jpc_ppxstab_t *tab);\njpc_ppxstabent_t *jpc_ppxstabent_create(void);\nvoid jpc_ppxstabent_destroy(jpc_ppxstabent_t *ent);\n\nint jpc_streamlist_numstreams(jpc_streamlist_t *streamlist);\njpc_streamlist_t *jpc_streamlist_create(void);\nint jpc_streamlist_insert(jpc_streamlist_t *streamlist, int streamno,\n  jas_stream_t *stream);\njas_stream_t *jpc_streamlist_remove(jpc_streamlist_t *streamlist, int streamno);\nvoid jpc_streamlist_destroy(jpc_streamlist_t *streamlist);\njas_stream_t *jpc_streamlist_get(jpc_streamlist_t *streamlist, int streamno);\n\nstatic void jpc_dec_cp_resetflags(jpc_dec_cp_t *cp);\nstatic jpc_dec_cp_t *jpc_dec_cp_create(uint_fast16_t numcomps);\nstatic int jpc_dec_cp_isvalid(jpc_dec_cp_t *cp);\nstatic jpc_dec_cp_t *jpc_dec_cp_copy(jpc_dec_cp_t *cp);\nstatic int jpc_dec_cp_setfromcod(jpc_dec_cp_t *cp, jpc_cod_t *cod);\nstatic int jpc_dec_cp_setfromcoc(jpc_dec_cp_t *cp, jpc_coc_t *coc);\nstatic int jpc_dec_cp_setfromcox(jpc_dec_cp_t *cp, jpc_dec_ccp_t *ccp,\n  jpc_coxcp_t *compparms, int flags);\nstatic int jpc_dec_cp_setfromqcd(jpc_dec_cp_t *cp, jpc_qcd_t *qcd);\nstatic int jpc_dec_cp_setfromqcc(jpc_dec_cp_t *cp, jpc_qcc_t *qcc);\nstatic int jpc_dec_cp_setfromqcx(jpc_dec_cp_t *cp, jpc_dec_ccp_t *ccp,\n  jpc_qcxcp_t *compparms, int flags);\nstatic int jpc_dec_cp_setfromrgn(jpc_dec_cp_t *cp, jpc_rgn_t *rgn);\nstatic int jpc_dec_cp_prepare(jpc_dec_cp_t *cp);\nstatic void jpc_dec_cp_destroy(jpc_dec_cp_t *cp);\nstatic int jpc_dec_cp_setfrompoc(jpc_dec_cp_t *cp, jpc_poc_t *poc, int reset);\nstatic int jpc_pi_addpchgfrompoc(jpc_pi_t *pi, jpc_poc_t *poc);\n\nstatic int jpc_dec_decode(jpc_dec_t *dec);\nstatic jpc_dec_t *jpc_dec_create(jpc_dec_importopts_t *impopts, jas_stream_t *in);\nstatic void jpc_dec_destroy(jpc_dec_t *dec);\nstatic void jpc_dequantize(jas_matrix_t *x, jpc_fix_t absstepsize);\nstatic void jpc_undo_roi(jas_matrix_t *x, int roishift, int bgshift, int numbps);\nstatic jpc_fix_t jpc_calcabsstepsize(int stepsize, int numbits);\nstatic int jpc_dec_tiledecode(jpc_dec_t *dec, jpc_dec_tile_t *tile);\nstatic int jpc_dec_tileinit(jpc_dec_t *dec, jpc_dec_tile_t *tile);\nstatic int jpc_dec_tilefini(jpc_dec_t *dec, jpc_dec_tile_t *tile);\nstatic int jpc_dec_process_soc(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_sot(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_sod(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_eoc(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_siz(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_cod(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_coc(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_rgn(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_qcd(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_qcc(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_poc(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_ppm(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_ppt(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_com(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_unk(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_crg(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_parseopts(char *optstr, jpc_dec_importopts_t *opts);\n\nstatic jpc_dec_mstabent_t *jpc_dec_mstab_lookup(uint_fast16_t id);\n\n/******************************************************************************\\\n* Global data.\n\\******************************************************************************/\n\njpc_dec_mstabent_t jpc_dec_mstab[] = {\n\t{JPC_MS_SOC, JPC_MHSOC, jpc_dec_process_soc},\n\t{JPC_MS_SOT, JPC_MH | JPC_TPHSOT, jpc_dec_process_sot},\n\t{JPC_MS_SOD, JPC_TPH, jpc_dec_process_sod},\n\t{JPC_MS_EOC, JPC_TPHSOT, jpc_dec_process_eoc},\n\t{JPC_MS_SIZ, JPC_MHSIZ, jpc_dec_process_siz},\n\t{JPC_MS_COD, JPC_MH | JPC_TPH, jpc_dec_process_cod},\n\t{JPC_MS_COC, JPC_MH | JPC_TPH, jpc_dec_process_coc},\n\t{JPC_MS_RGN, JPC_MH | JPC_TPH, jpc_dec_process_rgn},\n\t{JPC_MS_QCD, JPC_MH | JPC_TPH, jpc_dec_process_qcd},\n\t{JPC_MS_QCC, JPC_MH | JPC_TPH, jpc_dec_process_qcc},\n\t{JPC_MS_POC, JPC_MH | JPC_TPH, jpc_dec_process_poc},\n\t{JPC_MS_TLM, JPC_MH, 0},\n\t{JPC_MS_PLM, JPC_MH, 0},\n\t{JPC_MS_PLT, JPC_TPH, 0},\n\t{JPC_MS_PPM, JPC_MH, jpc_dec_process_ppm},\n\t{JPC_MS_PPT, JPC_TPH, jpc_dec_process_ppt},\n\t{JPC_MS_SOP, 0, 0},\n\t{JPC_MS_CRG, JPC_MH, jpc_dec_process_crg},\n\t{JPC_MS_COM, JPC_MH | JPC_TPH, jpc_dec_process_com},\n\t{0, JPC_MH | JPC_TPH, jpc_dec_process_unk}\n};\n\n/******************************************************************************\\\n* The main entry point for the JPEG-2000 decoder.\n\\******************************************************************************/\n\njas_image_t *jpc_decode(jas_stream_t *in, char *optstr)\n{\n\tjpc_dec_importopts_t opts;\n\tjpc_dec_t *dec;\n\tjas_image_t *image;\n\n\tdec = 0;\n\n\tif (jpc_dec_parseopts(optstr, &opts)) {\n\t\tgoto error;\n\t}\n\n\tjpc_initluts();\n\n\tif (!(dec = jpc_dec_create(&opts, in))) {\n\t\tgoto error;\n\t}\n\n\t/* Do most of the work. */\n\tif (jpc_dec_decode(dec)) {\n\t\tgoto error;\n\t}\n\n\tif (jas_image_numcmpts(dec->image) >= 3) {\n\t\tjas_image_setclrspc(dec->image, JAS_CLRSPC_SRGB);\n\t\tjas_image_setcmpttype(dec->image, 0,\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_R));\n\t\tjas_image_setcmpttype(dec->image, 1,\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_G));\n\t\tjas_image_setcmpttype(dec->image, 2,\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_B));\n\t} else {\n\t\tjas_image_setclrspc(dec->image, JAS_CLRSPC_SGRAY);\n\t\tjas_image_setcmpttype(dec->image, 0,\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_GRAY_Y));\n\t}\n\n\t/* Save the return value. */\n\timage = dec->image;\n\n\t/* Stop the image from being discarded. */\n\tdec->image = 0;\n\n\t/* Destroy decoder. */\n\tjpc_dec_destroy(dec);\n\n\treturn image;\n\nerror:\n\tif (dec) {\n\t\tjpc_dec_destroy(dec);\n\t}\n\treturn 0;\n}\n\ntypedef enum {\n\tOPT_MAXLYRS,\n\tOPT_MAXPKTS,\n\tOPT_DEBUG\n} optid_t;\n\njas_taginfo_t decopts[] = {\n\t{OPT_MAXLYRS, \"maxlyrs\"},\n\t{OPT_MAXPKTS, \"maxpkts\"},\n\t{OPT_DEBUG, \"debug\"},\n\t{-1, 0}\n};\n\nstatic int jpc_dec_parseopts(char *optstr, jpc_dec_importopts_t *opts)\n{\n\tjas_tvparser_t *tvp;\n\n\topts->debug = 0;\n\topts->maxlyrs = JPC_MAXLYRS;\n\topts->maxpkts = -1;\n\n\tif (!(tvp = jas_tvparser_create(optstr ? optstr : \"\"))) {\n\t\treturn -1;\n\t}\n\n\twhile (!jas_tvparser_next(tvp)) {\n\t\tswitch (jas_taginfo_nonull(jas_taginfos_lookup(decopts,\n\t\t  jas_tvparser_gettag(tvp)))->id) {\n\t\tcase OPT_MAXLYRS:\n\t\t\topts->maxlyrs = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_DEBUG:\n\t\t\topts->debug = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_MAXPKTS:\n\t\t\topts->maxpkts = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tjas_eprintf(\"warning: ignoring invalid option %s\\n\",\n\t\t\t  jas_tvparser_gettag(tvp));\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tjas_tvparser_destroy(tvp);\n\n\treturn 0;\n}\n\n/******************************************************************************\\\n* Code for table-driven code stream decoder.\n\\******************************************************************************/\n\nstatic jpc_dec_mstabent_t *jpc_dec_mstab_lookup(uint_fast16_t id)\n{\n\tjpc_dec_mstabent_t *mstabent;\n\tfor (mstabent = jpc_dec_mstab; mstabent->id != 0; ++mstabent) {\n\t\tif (mstabent->id == id) {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn mstabent;\n}\n\nstatic int jpc_dec_decode(jpc_dec_t *dec)\n{\n\tjpc_ms_t *ms;\n\tjpc_dec_mstabent_t *mstabent;\n\tint ret;\n\tjpc_cstate_t *cstate;\n\n\tif (!(cstate = jpc_cstate_create())) {\n\t\treturn -1;\n\t}\n\tdec->cstate = cstate;\n\n\t/* Initially, we should expect to encounter a SOC marker segment. */\n\tdec->state = JPC_MHSOC;\n\n\tfor (;;) {\n\n\t\t/* Get the next marker segment in the code stream. */\n\t\tif (!(ms = jpc_getms(dec->in, cstate))) {\n\t\t\tjas_eprintf(\"cannot get marker segment\\n\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tmstabent = jpc_dec_mstab_lookup(ms->id);\n\t\tassert(mstabent);\n\n\t\t/* Ensure that this type of marker segment is permitted\n\t\t  at this point in the code stream. */\n\t\tif (!(dec->state & mstabent->validstates)) {\n\t\t\tjas_eprintf(\"unexpected marker segment type\\n\");\n\t\t\tjpc_ms_destroy(ms);\n\t\t\treturn -1;\n\t\t}\n\n\t\t/* Process the marker segment. */\n\t\tif (mstabent->action) {\n\t\t\tret = (*mstabent->action)(dec, ms);\n\t\t} else {\n\t\t\t/* No explicit action is required. */\n\t\t\tret = 0;\n\t\t}\n\n\t\t/* Destroy the marker segment. */\n\t\tjpc_ms_destroy(ms);\n\n\t\tif (ret < 0) {\n\t\t\treturn -1;\n\t\t} else if (ret > 0) {\n\t\t\tbreak;\n\t\t}\n\n\t}\n\n\treturn 0;\n}\n\nstatic int jpc_dec_process_crg(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tint cmptno;\n\tjpc_dec_cmpt_t *cmpt;\n\tjpc_crg_t *crg;\n\n\tcrg = &ms->parms.crg;\n\tfor (cmptno = 0, cmpt = dec->cmpts; cmptno < dec->numcomps; ++cmptno,\n\t  ++cmpt) {\n\t\t/* Ignore the information in the CRG marker segment for now.\n\t\t  This information serves no useful purpose for decoding anyhow.\n\t\t  Some other parts of the code need to be changed if these lines\n\t\t  are uncommented.\n\t\tcmpt->hsubstep = crg->comps[cmptno].hoff;\n\t\tcmpt->vsubstep = crg->comps[cmptno].voff;\n\t\t*/\n\t}\n\treturn 0;\n}\n\nstatic int jpc_dec_process_soc(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\t/* Eliminate warnings about unused variables. */\n\tms = 0;\n\n\t/* We should expect to encounter a SIZ marker segment next. */\n\tdec->state = JPC_MHSIZ;\n\n\treturn 0;\n}\n\nstatic int jpc_dec_process_sot(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tjpc_dec_tile_t *tile;\n\tjpc_sot_t *sot = &ms->parms.sot;\n\tjas_image_cmptparm_t *compinfos;\n\tjas_image_cmptparm_t *compinfo;\n\tjpc_dec_cmpt_t *cmpt;\n\tint cmptno;\n\n\tif (dec->state == JPC_MH) {\n\n\t\tcompinfos = jas_malloc(dec->numcomps * sizeof(jas_image_cmptparm_t));\n\t\tassert(compinfos);\n\t\tfor (cmptno = 0, cmpt = dec->cmpts, compinfo = compinfos;\n\t\t  cmptno < dec->numcomps; ++cmptno, ++cmpt, ++compinfo) {\n\t\t\tcompinfo->tlx = 0;\n\t\t\tcompinfo->tly = 0;\n\t\t\tcompinfo->prec = cmpt->prec;\n\t\t\tcompinfo->sgnd = cmpt->sgnd;\n\t\t\tcompinfo->width = cmpt->width;\n\t\t\tcompinfo->height = cmpt->height;\n\t\t\tcompinfo->hstep = cmpt->hstep;\n\t\t\tcompinfo->vstep = cmpt->vstep;\n\t\t}\n\n\t\tif (!(dec->image = jas_image_create(dec->numcomps, compinfos,\n\t\t  JAS_CLRSPC_UNKNOWN))) {\n\t\t\treturn -1;\n\t\t}\n\t\tjas_free(compinfos);\n\n\t\t/* Is the packet header information stored in PPM marker segments in\n\t\t  the main header? */\n\t\tif (dec->ppmstab) {\n\t\t\t/* Convert the PPM marker segment data into a collection of streams\n\t\t\t  (one stream per tile-part). */\n\t\t\tif (!(dec->pkthdrstreams = jpc_ppmstabtostreams(dec->ppmstab))) {\n\t\t\t\tabort();\n\t\t\t}\n\t\t\tjpc_ppxstab_destroy(dec->ppmstab);\n\t\t\tdec->ppmstab = 0;\n\t\t}\n\t}\n\n\tif (sot->len > 0) {\n\t\tdec->curtileendoff = jas_stream_getrwcount(dec->in) - ms->len -\n\t\t  4 + sot->len;\n\t} else {\n\t\tdec->curtileendoff = 0;\n\t}\n\n\tif (JAS_CAST(int, sot->tileno) > dec->numtiles) {\n\t\tjas_eprintf(\"invalid tile number in SOT marker segment\\n\");\n\t\treturn -1;\n\t}\n\t/* Set the current tile. */\n\tdec->curtile = &dec->tiles[sot->tileno];\n\ttile = dec->curtile;\n\t/* Ensure that this is the expected part number. */\n\tif (sot->partno != tile->partno) {\n\t\treturn -1;\n\t}\n\tif (tile->numparts > 0 && sot->partno >= tile->numparts) {\n\t\treturn -1;\n\t}\n\tif (!tile->numparts && sot->numparts > 0) {\n\t\ttile->numparts = sot->numparts;\n\t}\n\n\ttile->pptstab = 0;\n\n\tswitch (tile->state) {\n\tcase JPC_TILE_INIT:\n\t\t/* This is the first tile-part for this tile. */\n\t\ttile->state = JPC_TILE_ACTIVE;\n\t\tassert(!tile->cp);\n\t\tif (!(tile->cp = jpc_dec_cp_copy(dec->cp))) {\n\t\t\treturn -1;\n\t\t}\n\t\tjpc_dec_cp_resetflags(dec->cp);\n\t\tbreak;\n\tdefault:\n\t\tif (sot->numparts == sot->partno - 1) {\n\t\t\ttile->state = JPC_TILE_ACTIVELAST;\n\t\t}\n\t\tbreak;\n\t}\n\n\t/* Note: We do not increment the expected tile-part number until\n\t  all processing for this tile-part is complete. */\n\n\t/* We should expect to encounter other tile-part header marker\n\t  segments next. */\n\tdec->state = JPC_TPH;\n\n\treturn 0;\n}\n\nstatic int jpc_dec_process_sod(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tjpc_dec_tile_t *tile;\n\tint pos;\n\n\t/* Eliminate compiler warnings about unused variables. */\n\tms = 0;\n\n\tif (!(tile = dec->curtile)) {\n\t\treturn -1;\n\t}\n\n\tif (!tile->partno) {\n\t\tif (!jpc_dec_cp_isvalid(tile->cp)) {\n\t\t\treturn -1;\n\t\t}\n\t\tjpc_dec_cp_prepare(tile->cp);\n\t\tif (jpc_dec_tileinit(dec, tile)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t/* Are packet headers stored in the main header or tile-part header? */\n\tif (dec->pkthdrstreams) {\n\t\t/* Get the stream containing the packet header data for this\n\t\t  tile-part. */\n\t\tif (!(tile->pkthdrstream = jpc_streamlist_remove(dec->pkthdrstreams, 0))) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (tile->pptstab) {\n\t\tif (!tile->pkthdrstream) {\n\t\t\tif (!(tile->pkthdrstream = jas_stream_memopen(0, 0))) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tpos = jas_stream_tell(tile->pkthdrstream);\n\t\tjas_stream_seek(tile->pkthdrstream, 0, SEEK_END);\n\t\tif (jpc_pptstabwrite(tile->pkthdrstream, tile->pptstab)) {\n\t\t\treturn -1;\n\t\t}\n\t\tjas_stream_seek(tile->pkthdrstream, pos, SEEK_SET);\n\t\tjpc_ppxstab_destroy(tile->pptstab);\n\t\ttile->pptstab = 0;\n\t}\n\n\tif (jas_getdbglevel() >= 10) {\n\t\tjpc_dec_dump(dec, stderr);\n\t}\n\n\tif (jpc_dec_decodepkts(dec, (tile->pkthdrstream) ? tile->pkthdrstream :\n\t  dec->in, dec->in)) {\n\t\tjas_eprintf(\"jpc_dec_decodepkts failed\\n\");\n\t\treturn -1;\n\t}\n\n\t/* Gobble any unconsumed tile data. */\n\tif (dec->curtileendoff > 0) {\n\t\tlong curoff;\n\t\tuint_fast32_t n;\n\t\tcuroff = jas_stream_getrwcount(dec->in);\n\t\tif (curoff < dec->curtileendoff) {\n\t\t\tn = dec->curtileendoff - curoff;\n\t\t\tjas_eprintf(\"warning: ignoring trailing garbage (%lu bytes)\\n\",\n\t\t\t  (unsigned long) n);\n\n\t\t\twhile (n-- > 0) {\n\t\t\t\tif (jas_stream_getc(dec->in) == EOF) {\n\t\t\t\t\tjas_eprintf(\"read error\\n\");\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (curoff > dec->curtileendoff) {\n\t\t\tjas_eprintf(\"warning: not enough tile data (%lu bytes)\\n\",\n\t\t\t  (unsigned long) curoff - dec->curtileendoff);\n\t\t}\n\n\t}\n\n\tif (tile->numparts > 0 && tile->partno == tile->numparts - 1) {\n\t\tif (jpc_dec_tiledecode(dec, tile)) {\n\t\t\treturn -1;\n\t\t}\n\t\tjpc_dec_tilefini(dec, tile);\n\t}\n\n\tdec->curtile = 0;\n\n\t/* Increment the expected tile-part number. */\n\t++tile->partno;\n\n\t/* We should expect to encounter a SOT marker segment next. */\n\tdec->state = JPC_TPHSOT;\n\n\treturn 0;\n}\n\nstatic int jpc_dec_tileinit(jpc_dec_t *dec, jpc_dec_tile_t *tile)\n{\n\tjpc_dec_tcomp_t *tcomp;\n\tint compno;\n\tint rlvlno;\n\tjpc_dec_rlvl_t *rlvl;\n\tjpc_dec_band_t *band;\n\tjpc_dec_prc_t *prc;\n\tint bndno;\n\tjpc_tsfb_band_t *bnd;\n\tint bandno;\n\tjpc_dec_ccp_t *ccp;\n\tint prccnt;\n\tjpc_dec_cblk_t *cblk;\n\tint cblkcnt;\n\tuint_fast32_t tlprcxstart;\n\tuint_fast32_t tlprcystart;\n\tuint_fast32_t brprcxend;\n\tuint_fast32_t brprcyend;\n\tuint_fast32_t tlcbgxstart;\n\tuint_fast32_t tlcbgystart;\n\tuint_fast32_t brcbgxend;\n\tuint_fast32_t brcbgyend;\n\tuint_fast32_t cbgxstart;\n\tuint_fast32_t cbgystart;\n\tuint_fast32_t cbgxend;\n\tuint_fast32_t cbgyend;\n\tuint_fast32_t tlcblkxstart;\n\tuint_fast32_t tlcblkystart;\n\tuint_fast32_t brcblkxend;\n\tuint_fast32_t brcblkyend;\n\tuint_fast32_t cblkxstart;\n\tuint_fast32_t cblkystart;\n\tuint_fast32_t cblkxend;\n\tuint_fast32_t cblkyend;\n\tuint_fast32_t tmpxstart;\n\tuint_fast32_t tmpystart;\n\tuint_fast32_t tmpxend;\n\tuint_fast32_t tmpyend;\n\tjpc_dec_cp_t *cp;\n\tjpc_tsfb_band_t bnds[64];\n\tjpc_pchg_t *pchg;\n\tint pchgno;\n\tjpc_dec_cmpt_t *cmpt;\n\n\tcp = tile->cp;\n\ttile->realmode = 0;\n\tif (cp->mctid == JPC_MCT_ICT) {\n\t\ttile->realmode = 1;\n\t}\n\n\tfor (compno = 0, tcomp = tile->tcomps, cmpt = dec->cmpts; compno <\n\t  dec->numcomps; ++compno, ++tcomp, ++cmpt) {\n\t\tccp = &tile->cp->ccps[compno];\n\t\tif (ccp->qmfbid == JPC_COX_INS) {\n\t\t\ttile->realmode = 1;\n\t\t}\n\t\ttcomp->numrlvls = ccp->numrlvls;\n\t\tif (!(tcomp->rlvls = jas_malloc(tcomp->numrlvls *\n\t\t  sizeof(jpc_dec_rlvl_t)))) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (!(tcomp->data = jas_seq2d_create(JPC_CEILDIV(tile->xstart,\n\t\t  cmpt->hstep), JPC_CEILDIV(tile->ystart, cmpt->vstep),\n\t\t  JPC_CEILDIV(tile->xend, cmpt->hstep), JPC_CEILDIV(tile->yend,\n\t\t  cmpt->vstep)))) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (!(tcomp->tsfb = jpc_cod_gettsfb(ccp->qmfbid,\n\t\t  tcomp->numrlvls - 1))) {\n\t\t\treturn -1;\n\t\t}\n{\n\tjpc_tsfb_getbands(tcomp->tsfb, jas_seq2d_xstart(tcomp->data), jas_seq2d_ystart(tcomp->data), jas_seq2d_xend(tcomp->data), jas_seq2d_yend(tcomp->data), bnds);\n}\n\t\tfor (rlvlno = 0, rlvl = tcomp->rlvls; rlvlno < tcomp->numrlvls;\n\t\t  ++rlvlno, ++rlvl) {\nrlvl->bands = 0;\n\t\t\trlvl->xstart = JPC_CEILDIVPOW2(tcomp->xstart,\n\t\t\t  tcomp->numrlvls - 1 - rlvlno);\n\t\t\trlvl->ystart = JPC_CEILDIVPOW2(tcomp->ystart,\n\t\t\t  tcomp->numrlvls - 1 - rlvlno);\n\t\t\trlvl->xend = JPC_CEILDIVPOW2(tcomp->xend,\n\t\t\t  tcomp->numrlvls - 1 - rlvlno);\n\t\t\trlvl->yend = JPC_CEILDIVPOW2(tcomp->yend,\n\t\t\t  tcomp->numrlvls - 1 - rlvlno);\n\t\t\trlvl->prcwidthexpn = ccp->prcwidthexpns[rlvlno];\n\t\t\trlvl->prcheightexpn = ccp->prcheightexpns[rlvlno];\n\t\t\ttlprcxstart = JPC_FLOORDIVPOW2(rlvl->xstart,\n\t\t\t  rlvl->prcwidthexpn) << rlvl->prcwidthexpn;\n\t\t\ttlprcystart = JPC_FLOORDIVPOW2(rlvl->ystart,\n\t\t\t  rlvl->prcheightexpn) << rlvl->prcheightexpn;\n\t\t\tbrprcxend = JPC_CEILDIVPOW2(rlvl->xend,\n\t\t\t  rlvl->prcwidthexpn) << rlvl->prcwidthexpn;\n\t\t\tbrprcyend = JPC_CEILDIVPOW2(rlvl->yend,\n\t\t\t  rlvl->prcheightexpn) << rlvl->prcheightexpn;\n\t\t\trlvl->numhprcs = (brprcxend - tlprcxstart) >>\n\t\t\t  rlvl->prcwidthexpn;\n\t\t\trlvl->numvprcs = (brprcyend - tlprcystart) >>\n\t\t\t  rlvl->prcheightexpn;\n\t\t\trlvl->numprcs = rlvl->numhprcs * rlvl->numvprcs;\n\n\t\t\tif (rlvl->xstart >= rlvl->xend || rlvl->ystart >= rlvl->yend) {\n\t\t\t\trlvl->bands = 0;\n\t\t\t\trlvl->numprcs = 0;\n\t\t\t\trlvl->numhprcs = 0;\n\t\t\t\trlvl->numvprcs = 0;\n\t\t\t\tcontinue;\n\t\t\t}\t\n\t\t\tif (!rlvlno) {\n\t\t\t\ttlcbgxstart = tlprcxstart;\n\t\t\t\ttlcbgystart = tlprcystart;\n\t\t\t\tbrcbgxend = brprcxend;\n\t\t\t\tbrcbgyend = brprcyend;\n\t\t\t\trlvl->cbgwidthexpn = rlvl->prcwidthexpn;\n\t\t\t\trlvl->cbgheightexpn = rlvl->prcheightexpn;\n\t\t\t} else {\n\t\t\t\ttlcbgxstart = JPC_CEILDIVPOW2(tlprcxstart, 1);\n\t\t\t\ttlcbgystart = JPC_CEILDIVPOW2(tlprcystart, 1);\n\t\t\t\tbrcbgxend = JPC_CEILDIVPOW2(brprcxend, 1);\n\t\t\t\tbrcbgyend = JPC_CEILDIVPOW2(brprcyend, 1);\n\t\t\t\trlvl->cbgwidthexpn = rlvl->prcwidthexpn - 1;\n\t\t\t\trlvl->cbgheightexpn = rlvl->prcheightexpn - 1;\n\t\t\t}\n\t\t\trlvl->cblkwidthexpn = JAS_MIN(ccp->cblkwidthexpn,\n\t\t\t  rlvl->cbgwidthexpn);\n\t\t\trlvl->cblkheightexpn = JAS_MIN(ccp->cblkheightexpn,\n\t\t\t  rlvl->cbgheightexpn);\n\n\t\t\trlvl->numbands = (!rlvlno) ? 1 : 3;\n\t\t\tif (!(rlvl->bands = jas_malloc(rlvl->numbands *\n\t\t\t  sizeof(jpc_dec_band_t)))) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor (bandno = 0, band = rlvl->bands;\n\t\t\t  bandno < rlvl->numbands; ++bandno, ++band) {\n\t\t\t\tbndno = (!rlvlno) ? 0 : (3 * (rlvlno - 1) +\n\t\t\t\t  bandno + 1);\n\t\t\t\tbnd = &bnds[bndno];\n\n\t\t\t\tband->orient = bnd->orient;\n\t\t\t\tband->stepsize = ccp->stepsizes[bndno];\n\t\t\t\tband->analgain = JPC_NOMINALGAIN(ccp->qmfbid,\n\t\t\t\t  tcomp->numrlvls - 1, rlvlno, band->orient);\n\t\t\t\tband->absstepsize = jpc_calcabsstepsize(band->stepsize,\n\t\t\t\t  cmpt->prec + band->analgain);\n\t\t\t\tband->numbps = ccp->numguardbits +\n\t\t\t\t  JPC_QCX_GETEXPN(band->stepsize) - 1;\n\t\t\t\tband->roishift = (ccp->roishift + band->numbps >= JPC_PREC) ?\n\t\t\t\t  (JPC_PREC - 1 - band->numbps) : ccp->roishift;\n\t\t\t\tband->data = 0;\n\t\t\t\tband->prcs = 0;\n\t\t\t\tif (bnd->xstart == bnd->xend || bnd->ystart == bnd->yend) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (!(band->data = jas_seq2d_create(0, 0, 0, 0))) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tjas_seq2d_bindsub(band->data, tcomp->data, bnd->locxstart, bnd->locystart, bnd->locxend, bnd->locyend);\n\t\t\t\tjas_seq2d_setshift(band->data, bnd->xstart, bnd->ystart);\n\n\t\t\t\tassert(rlvl->numprcs);\n\n\t\t\t\tif (!(band->prcs = jas_malloc(rlvl->numprcs * sizeof(jpc_dec_prc_t)))) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\n/************************************************/\n\tcbgxstart = tlcbgxstart;\n\tcbgystart = tlcbgystart;\n\tfor (prccnt = rlvl->numprcs, prc = band->prcs;\n\t  prccnt > 0; --prccnt, ++prc) {\n\t\tcbgxend = cbgxstart + (1 << rlvl->cbgwidthexpn);\n\t\tcbgyend = cbgystart + (1 << rlvl->cbgheightexpn);\n\t\tprc->xstart = JAS_MAX(cbgxstart, JAS_CAST(uint_fast32_t, jas_seq2d_xstart(band->data)));\n\t\tprc->ystart = JAS_MAX(cbgystart, JAS_CAST(uint_fast32_t, jas_seq2d_ystart(band->data)));\n\t\tprc->xend = JAS_MIN(cbgxend, JAS_CAST(uint_fast32_t, jas_seq2d_xend(band->data)));\n\t\tprc->yend = JAS_MIN(cbgyend, JAS_CAST(uint_fast32_t, jas_seq2d_yend(band->data)));\n\t\tif (prc->xend > prc->xstart && prc->yend > prc->ystart) {\n\t\t\ttlcblkxstart = JPC_FLOORDIVPOW2(prc->xstart,\n\t\t\t  rlvl->cblkwidthexpn) << rlvl->cblkwidthexpn;\n\t\t\ttlcblkystart = JPC_FLOORDIVPOW2(prc->ystart,\n\t\t\t  rlvl->cblkheightexpn) << rlvl->cblkheightexpn;\n\t\t\tbrcblkxend = JPC_CEILDIVPOW2(prc->xend,\n\t\t\t  rlvl->cblkwidthexpn) << rlvl->cblkwidthexpn;\n\t\t\tbrcblkyend = JPC_CEILDIVPOW2(prc->yend,\n\t\t\t  rlvl->cblkheightexpn) << rlvl->cblkheightexpn;\n\t\t\tprc->numhcblks = (brcblkxend - tlcblkxstart) >>\n\t\t\t  rlvl->cblkwidthexpn;\n\t\t\tprc->numvcblks = (brcblkyend - tlcblkystart) >>\n\t\t\t  rlvl->cblkheightexpn;\n\t\t\tprc->numcblks = prc->numhcblks * prc->numvcblks;\n\t\t\tassert(prc->numcblks > 0);\n\n\t\t\tif (!(prc->incltagtree = jpc_tagtree_create(prc->numhcblks, prc->numvcblks))) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (!(prc->numimsbstagtree = jpc_tagtree_create(prc->numhcblks, prc->numvcblks))) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (!(prc->cblks = jas_malloc(prc->numcblks * sizeof(jpc_dec_cblk_t)))) {\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tcblkxstart = cbgxstart;\n\t\t\tcblkystart = cbgystart;\n\t\t\tfor (cblkcnt = prc->numcblks, cblk = prc->cblks; cblkcnt > 0;) {\n\t\t\t\tcblkxend = cblkxstart + (1 << rlvl->cblkwidthexpn);\n\t\t\t\tcblkyend = cblkystart + (1 << rlvl->cblkheightexpn);\n\t\t\t\ttmpxstart = JAS_MAX(cblkxstart, prc->xstart);\n\t\t\t\ttmpystart = JAS_MAX(cblkystart, prc->ystart);\n\t\t\t\ttmpxend = JAS_MIN(cblkxend, prc->xend);\n\t\t\t\ttmpyend = JAS_MIN(cblkyend, prc->yend);\n\t\t\t\tif (tmpxend > tmpxstart && tmpyend > tmpystart) {\n\t\t\t\t\tcblk->firstpassno = -1;\n\t\t\t\t\tcblk->mqdec = 0;\n\t\t\t\t\tcblk->nulldec = 0;\n\t\t\t\t\tcblk->flags = 0;\n\t\t\t\t\tcblk->numpasses = 0;\n\t\t\t\t\tcblk->segs.head = 0;\n\t\t\t\t\tcblk->segs.tail = 0;\n\t\t\t\t\tcblk->curseg = 0;\n\t\t\t\t\tcblk->numimsbs = 0;\n\t\t\t\t\tcblk->numlenbits = 3;\n\t\t\t\t\tcblk->flags = 0;\n\t\t\t\t\tif (!(cblk->data = jas_seq2d_create(0, 0, 0, 0))) {\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\t\tjas_seq2d_bindsub(cblk->data, band->data, tmpxstart, tmpystart, tmpxend, tmpyend);\n\t\t\t\t\t++cblk;\n\t\t\t\t\t--cblkcnt;\n\t\t\t\t}\n\t\t\t\tcblkxstart += 1 << rlvl->cblkwidthexpn;\n\t\t\t\tif (cblkxstart >= cbgxend) {\n\t\t\t\t\tcblkxstart = cbgxstart;\n\t\t\t\t\tcblkystart += 1 << rlvl->cblkheightexpn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t} else {\n\t\t\tprc->cblks = 0;\n\t\t\tprc->incltagtree = 0;\n\t\t\tprc->numimsbstagtree = 0;\n\t\t}\n\t\tcbgxstart += 1 << rlvl->cbgwidthexpn;\n\t\tif (cbgxstart >= brcbgxend) {\n\t\t\tcbgxstart = tlcbgxstart;\n\t\t\tcbgystart += 1 << rlvl->cbgheightexpn;\n\t\t}\n\n\t}\n/********************************************/\n\t\t\t}\n\t\t}\n\t}\n\nif (!(tile->pi = jpc_dec_pi_create(dec, tile)))\n{\n\treturn -1;\n}\n\n\tfor (pchgno = 0; pchgno < jpc_pchglist_numpchgs(tile->cp->pchglist);\n\t  ++pchgno) {\n\t\tpchg = jpc_pchg_copy(jpc_pchglist_get(tile->cp->pchglist, pchgno));\n\t\tassert(pchg);\n\t\tjpc_pi_addpchg(tile->pi, pchg);\n\t}\n\tjpc_pi_init(tile->pi);\n\n\treturn 0;\n}\n\nstatic int jpc_dec_tilefini(jpc_dec_t *dec, jpc_dec_tile_t *tile)\n{\n\tjpc_dec_tcomp_t *tcomp;\n\tint compno;\n\tint bandno;\n\tint rlvlno;\n\tjpc_dec_band_t *band;\n\tjpc_dec_rlvl_t *rlvl;\n\tint prcno;\n\tjpc_dec_prc_t *prc;\n\tjpc_dec_seg_t *seg;\n\tjpc_dec_cblk_t *cblk;\n\tint cblkno;\n\nif (tile->tcomps) {\n\n\tfor (compno = 0, tcomp = tile->tcomps; compno < dec->numcomps;\n\t  ++compno, ++tcomp) {\n\t\tfor (rlvlno = 0, rlvl = tcomp->rlvls; rlvlno < tcomp->numrlvls;\n\t\t  ++rlvlno, ++rlvl) {\nif (!rlvl->bands) {\n\tcontinue;\n}\n\t\t\tfor (bandno = 0, band = rlvl->bands; bandno < rlvl->numbands; ++bandno, ++band) {\nif (band->prcs) {\n\t\t\t\tfor (prcno = 0, prc = band->prcs; prcno <\n\t\t\t\t  rlvl->numprcs; ++prcno, ++prc) {\nif (!prc->cblks) {\n\tcontinue;\n}\n\t\t\t\t\tfor (cblkno = 0, cblk = prc->cblks; cblkno < prc->numcblks; ++cblkno, ++cblk) {\n\n\twhile (cblk->segs.head) {\n\t\tseg = cblk->segs.head;\n\t\tjpc_seglist_remove(&cblk->segs, seg);\n\t\tjpc_seg_destroy(seg);\n\t}\n\tjas_matrix_destroy(cblk->data);\n\tif (cblk->mqdec) {\n\t\tjpc_mqdec_destroy(cblk->mqdec);\n\t}\n\tif (cblk->nulldec) {\n\t\tjpc_bitstream_close(cblk->nulldec);\n\t}\n\tif (cblk->flags) {\n\t\tjas_matrix_destroy(cblk->flags);\n\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (prc->incltagtree) {\n\t\t\t\t\t\tjpc_tagtree_destroy(prc->incltagtree);\n\t\t\t\t\t}\n\t\t\t\t\tif (prc->numimsbstagtree) {\n\t\t\t\t\t\tjpc_tagtree_destroy(prc->numimsbstagtree);\n\t\t\t\t\t}\n\t\t\t\t\tif (prc->cblks) {\n\t\t\t\t\t\tjas_free(prc->cblks);\n\t\t\t\t\t}\n\t\t\t\t}\n}\n\t\t\t\tif (band->data) {\n\t\t\t\t\tjas_matrix_destroy(band->data);\n\t\t\t\t}\n\t\t\t\tif (band->prcs) {\n\t\t\t\t\tjas_free(band->prcs);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (rlvl->bands) {\n\t\t\t\tjas_free(rlvl->bands);\n\t\t\t}\n\t\t}\n\t\tif (tcomp->rlvls) {\n\t\t\tjas_free(tcomp->rlvls);\n\t\t}\n\t\tif (tcomp->data) {\n\t\t\tjas_matrix_destroy(tcomp->data);\n\t\t}\n\t\tif (tcomp->tsfb) {\n\t\t\tjpc_tsfb_destroy(tcomp->tsfb);\n\t\t}\n\t}\n}\n\tif (tile->cp) {\n\t\tjpc_dec_cp_destroy(tile->cp);\n\t\ttile->cp = 0;\n\t}\n\tif (tile->tcomps) {\n\t\tjas_free(tile->tcomps);\n\t\ttile->tcomps = 0;\n\t}\n\tif (tile->pi) {\n\t\tjpc_pi_destroy(tile->pi);\n\t\ttile->pi = 0;\n\t}\n\tif (tile->pkthdrstream) {\n\t\tjas_stream_close(tile->pkthdrstream);\n\t\ttile->pkthdrstream = 0;\n\t}\n\tif (tile->pptstab) {\n\t\tjpc_ppxstab_destroy(tile->pptstab);\n\t\ttile->pptstab = 0;\n\t}\n\n\ttile->state = JPC_TILE_DONE;\n\n\treturn 0;\n}\n\nstatic int jpc_dec_tiledecode(jpc_dec_t *dec, jpc_dec_tile_t *tile)\n{\n\tint i;\n\tint j;\n\tjpc_dec_tcomp_t *tcomp;\n\tjpc_dec_rlvl_t *rlvl;\n\tjpc_dec_band_t *band;\n\tint compno;\n\tint rlvlno;\n\tint bandno;\n\tint adjust;\n\tint v;\n\tjpc_dec_ccp_t *ccp;\n\tjpc_dec_cmpt_t *cmpt;\n\n\tif (jpc_dec_decodecblks(dec, tile)) {\n\t\tjas_eprintf(\"jpc_dec_decodecblks failed\\n\");\n\t\treturn -1;\n\t}\n\n\t/* Perform dequantization. */\n\tfor (compno = 0, tcomp = tile->tcomps; compno < dec->numcomps;\n\t  ++compno, ++tcomp) {\n\t\tccp = &tile->cp->ccps[compno];\n\t\tfor (rlvlno = 0, rlvl = tcomp->rlvls; rlvlno < tcomp->numrlvls;\n\t\t  ++rlvlno, ++rlvl) {\n\t\t\tif (!rlvl->bands) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (bandno = 0, band = rlvl->bands;\n\t\t\t  bandno < rlvl->numbands; ++bandno, ++band) {\n\t\t\t\tif (!band->data) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tjpc_undo_roi(band->data, band->roishift, ccp->roishift -\n\t\t\t\t  band->roishift, band->numbps);\n\t\t\t\tif (tile->realmode) {\n\t\t\t\t\tjas_matrix_asl(band->data, JPC_FIX_FRACBITS);\n\t\t\t\t\tjpc_dequantize(band->data, band->absstepsize);\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Apply an inverse wavelet transform if necessary. */\n\tfor (compno = 0, tcomp = tile->tcomps; compno < dec->numcomps;\n\t  ++compno, ++tcomp) {\n\t\tccp = &tile->cp->ccps[compno];\n\t\tjpc_tsfb_synthesize(tcomp->tsfb, tcomp->data);\n\t}\n\n\n\t/* Apply an inverse intercomponent transform if necessary. */\n\tswitch (tile->cp->mctid) {\n\tcase JPC_MCT_RCT:\n\t\tassert(dec->numcomps == 3);\n\t\tjpc_irct(tile->tcomps[0].data, tile->tcomps[1].data,\n\t\t  tile->tcomps[2].data);\n\t\tbreak;\n\tcase JPC_MCT_ICT:\n\t\tassert(dec->numcomps == 3);\n\t\tjpc_iict(tile->tcomps[0].data, tile->tcomps[1].data,\n\t\t  tile->tcomps[2].data);\n\t\tbreak;\n\t}\n\n\t/* Perform rounding and convert to integer values. */\n\tif (tile->realmode) {\n\t\tfor (compno = 0, tcomp = tile->tcomps; compno < dec->numcomps;\n\t\t  ++compno, ++tcomp) {\n\t\t\tfor (i = 0; i < jas_matrix_numrows(tcomp->data); ++i) {\n\t\t\t\tfor (j = 0; j < jas_matrix_numcols(tcomp->data); ++j) {\n\t\t\t\t\tv = jas_matrix_get(tcomp->data, i, j);\n\t\t\t\t\tv = jpc_fix_round(v);\n\t\t\t\t\tjas_matrix_set(tcomp->data, i, j, jpc_fixtoint(v));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Perform level shift. */\n\tfor (compno = 0, tcomp = tile->tcomps, cmpt = dec->cmpts; compno <\n\t  dec->numcomps; ++compno, ++tcomp, ++cmpt) {\n\t\tadjust = cmpt->sgnd ? 0 : (1 << (cmpt->prec - 1));\n\t\tfor (i = 0; i < jas_matrix_numrows(tcomp->data); ++i) {\n\t\t\tfor (j = 0; j < jas_matrix_numcols(tcomp->data); ++j) {\n\t\t\t\t*jas_matrix_getref(tcomp->data, i, j) += adjust;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Perform clipping. */\n\tfor (compno = 0, tcomp = tile->tcomps, cmpt = dec->cmpts; compno <\n\t  dec->numcomps; ++compno, ++tcomp, ++cmpt) {\n\t\tjpc_fix_t mn;\n\t\tjpc_fix_t mx;\n\t\tmn = cmpt->sgnd ? (-(1 << (cmpt->prec - 1))) : (0);\n\t\tmx = cmpt->sgnd ? ((1 << (cmpt->prec - 1)) - 1) : ((1 <<\n\t\t  cmpt->prec) - 1);\n\t\tjas_matrix_clip(tcomp->data, mn, mx);\n\t}\n\n\t/* XXX need to free tsfb struct */\n\n\t/* Write the data for each component of the image. */\n\tfor (compno = 0, tcomp = tile->tcomps, cmpt = dec->cmpts; compno <\n\t  dec->numcomps; ++compno, ++tcomp, ++cmpt) {\n\t\tif (jas_image_writecmpt(dec->image, compno, tcomp->xstart -\n\t\t  JPC_CEILDIV(dec->xstart, cmpt->hstep), tcomp->ystart -\n\t\t  JPC_CEILDIV(dec->ystart, cmpt->vstep), jas_matrix_numcols(\n\t\t  tcomp->data), jas_matrix_numrows(tcomp->data), tcomp->data)) {\n\t\t\tjas_eprintf(\"write component failed\\n\");\n\t\t\treturn -4;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int jpc_dec_process_eoc(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tint tileno;\n\tjpc_dec_tile_t *tile;\n\n\t/* Eliminate compiler warnings about unused variables. */\n\tms = 0;\n\n\tfor (tileno = 0, tile = dec->tiles; tileno < dec->numtiles; ++tileno,\n\t  ++tile) {\n\t\tif (tile->state == JPC_TILE_ACTIVE) {\n\t\t\tif (jpc_dec_tiledecode(dec, tile)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tjpc_dec_tilefini(dec, tile);\n\t}\n\n\t/* We are done processing the code stream. */\n\tdec->state = JPC_MT;\n\n\treturn 1;\n}\n\nstatic int jpc_dec_process_siz(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tjpc_siz_t *siz = &ms->parms.siz;\n\tint compno;\n\tint tileno;\n\tjpc_dec_tile_t *tile;\n\tjpc_dec_tcomp_t *tcomp;\n\tint htileno;\n\tint vtileno;\n\tjpc_dec_cmpt_t *cmpt;\n\n\tdec->xstart = siz->xoff;\n\tdec->ystart = siz->yoff;\n\tdec->xend = siz->width;\n\tdec->yend = siz->height;\n\tdec->tilewidth = siz->tilewidth;\n\tdec->tileheight = siz->tileheight;\n\tdec->tilexoff = siz->tilexoff;\n\tdec->tileyoff = siz->tileyoff;\n\tdec->numcomps = siz->numcomps;\n\tif (!(dec->cp = jpc_dec_cp_create(dec->numcomps))) {\n\t\treturn -1;\n\t}\n\n\tif (!(dec->cmpts = jas_malloc(dec->numcomps * sizeof(jpc_dec_cmpt_t)))) {\n\t\treturn -1;\n\t}\n\n\tfor (compno = 0, cmpt = dec->cmpts; compno < dec->numcomps; ++compno,\n\t  ++cmpt) {\n\t\tcmpt->prec = siz->comps[compno].prec;\n\t\tcmpt->sgnd = siz->comps[compno].sgnd;\n\t\tcmpt->hstep = siz->comps[compno].hsamp;\n\t\tcmpt->vstep = siz->comps[compno].vsamp;\n\t\tcmpt->width = JPC_CEILDIV(dec->xend, cmpt->hstep) -\n\t\t  JPC_CEILDIV(dec->xstart, cmpt->hstep);\n\t\tcmpt->height = JPC_CEILDIV(dec->yend, cmpt->vstep) -\n\t\t  JPC_CEILDIV(dec->ystart, cmpt->vstep);\n\t\tcmpt->hsubstep = 0;\n\t\tcmpt->vsubstep = 0;\n\t}\n\n\tdec->image = 0;\n\n\tdec->numhtiles = JPC_CEILDIV(dec->xend - dec->tilexoff, dec->tilewidth);\n\tdec->numvtiles = JPC_CEILDIV(dec->yend - dec->tileyoff, dec->tileheight);\n\tdec->numtiles = dec->numhtiles * dec->numvtiles;\n\tif (!(dec->tiles = jas_malloc(dec->numtiles * sizeof(jpc_dec_tile_t)))) {\n\t\treturn -1;\n\t}\n\n\tfor (tileno = 0, tile = dec->tiles; tileno < dec->numtiles; ++tileno,\n\t  ++tile) {\n\t\thtileno = tileno % dec->numhtiles;\n\t\tvtileno = tileno / dec->numhtiles;\n\t\ttile->realmode = 0;\n\t\ttile->state = JPC_TILE_INIT;\n\t\ttile->xstart = JAS_MAX(dec->tilexoff + htileno * dec->tilewidth,\n\t\t  dec->xstart);\n\t\ttile->ystart = JAS_MAX(dec->tileyoff + vtileno * dec->tileheight,\n\t\t  dec->ystart);\n\t\ttile->xend = JAS_MIN(dec->tilexoff + (htileno + 1) *\n\t\t  dec->tilewidth, dec->xend);\n\t\ttile->yend = JAS_MIN(dec->tileyoff + (vtileno + 1) *\n\t\t  dec->tileheight, dec->yend);\n\t\ttile->numparts = 0;\n\t\ttile->partno = 0;\n\t\ttile->pkthdrstream = 0;\n\t\ttile->pkthdrstreampos = 0;\n\t\ttile->pptstab = 0;\n\t\ttile->cp = 0;\n\t\tif (!(tile->tcomps = jas_malloc(dec->numcomps *\n\t\t  sizeof(jpc_dec_tcomp_t)))) {\n\t\t\treturn -1;\n\t\t}\n\t\tfor (compno = 0, cmpt = dec->cmpts, tcomp = tile->tcomps;\n\t\t  compno < dec->numcomps; ++compno, ++cmpt, ++tcomp) {\n\t\t\ttcomp->rlvls = 0;\n\t\t\ttcomp->data = 0;\n\t\t\ttcomp->xstart = JPC_CEILDIV(tile->xstart, cmpt->hstep);\n\t\t\ttcomp->ystart = JPC_CEILDIV(tile->ystart, cmpt->vstep);\n\t\t\ttcomp->xend = JPC_CEILDIV(tile->xend, cmpt->hstep);\n\t\t\ttcomp->yend = JPC_CEILDIV(tile->yend, cmpt->vstep);\n\t\t\ttcomp->tsfb = 0;\n\t\t}\n\t}\n\n\tdec->pkthdrstreams = 0;\n\n\t/* We should expect to encounter other main header marker segments\n\t  or an SOT marker segment next. */\n\tdec->state = JPC_MH;\n\n\treturn 0;\n}\n\nstatic int jpc_dec_process_cod(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tjpc_cod_t *cod = &ms->parms.cod;\n\tjpc_dec_tile_t *tile;\n\n\tswitch (dec->state) {\n\tcase JPC_MH:\n\t\tjpc_dec_cp_setfromcod(dec->cp, cod);\n\t\tbreak;\n\tcase JPC_TPH:\n\t\tif (!(tile = dec->curtile)) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (tile->partno != 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tjpc_dec_cp_setfromcod(tile->cp, cod);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_dec_process_coc(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tjpc_coc_t *coc = &ms->parms.coc;\n\tjpc_dec_tile_t *tile;\n\n\tif (JAS_CAST(int, coc->compno) > dec->numcomps) {\n\t\tjas_eprintf(\"invalid component number in COC marker segment\\n\");\n\t\treturn -1;\n\t}\n\tswitch (dec->state) {\n\tcase JPC_MH:\n\t\tjpc_dec_cp_setfromcoc(dec->cp, coc);\n\t\tbreak;\n\tcase JPC_TPH:\n\t\tif (!(tile = dec->curtile)) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (tile->partno > 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tjpc_dec_cp_setfromcoc(tile->cp, coc);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_dec_process_rgn(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tjpc_rgn_t *rgn = &ms->parms.rgn;\n\tjpc_dec_tile_t *tile;\n\n\tif (JAS_CAST(int, rgn->compno) > dec->numcomps) {\n\t\tjas_eprintf(\"invalid component number in RGN marker segment\\n\");\n\t\treturn -1;\n\t}\n\tswitch (dec->state) {\n\tcase JPC_MH:\n\t\tjpc_dec_cp_setfromrgn(dec->cp, rgn);\n\t\tbreak;\n\tcase JPC_TPH:\n\t\tif (!(tile = dec->curtile)) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (tile->partno > 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tjpc_dec_cp_setfromrgn(tile->cp, rgn);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int jpc_dec_process_qcd(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tjpc_qcd_t *qcd = &ms->parms.qcd;\n\tjpc_dec_tile_t *tile;\n\n\tswitch (dec->state) {\n\tcase JPC_MH:\n\t\tjpc_dec_cp_setfromqcd(dec->cp, qcd);\n\t\tbreak;\n\tcase JPC_TPH:\n\t\tif (!(tile = dec->curtile)) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (tile->partno > 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tjpc_dec_cp_setfromqcd(tile->cp, qcd);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_dec_process_qcc(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tjpc_qcc_t *qcc = &ms->parms.qcc;\n\tjpc_dec_tile_t *tile;\n\n\tif (JAS_CAST(int, qcc->compno) > dec->numcomps) {\n\t\tjas_eprintf(\"invalid component number in QCC marker segment\\n\");\n\t\treturn -1;\n\t}\n\tswitch (dec->state) {\n\tcase JPC_MH:\n\t\tjpc_dec_cp_setfromqcc(dec->cp, qcc);\n\t\tbreak;\n\tcase JPC_TPH:\n\t\tif (!(tile = dec->curtile)) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (tile->partno > 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tjpc_dec_cp_setfromqcc(tile->cp, qcc);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_dec_process_poc(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tjpc_poc_t *poc = &ms->parms.poc;\n\tjpc_dec_tile_t *tile;\n\tswitch (dec->state) {\n\tcase JPC_MH:\n\t\tif (jpc_dec_cp_setfrompoc(dec->cp, poc, 1)) {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tcase JPC_TPH:\n\t\tif (!(tile = dec->curtile)) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (!tile->partno) {\n\t\t\tif (jpc_dec_cp_setfrompoc(tile->cp, poc, (!tile->partno))) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t} else {\n\t\t\tjpc_pi_addpchgfrompoc(tile->pi, poc);\n\t\t}\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_dec_process_ppm(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tjpc_ppm_t *ppm = &ms->parms.ppm;\n\tjpc_ppxstabent_t *ppmstabent;\n\n\tif (!dec->ppmstab) {\n\t\tif (!(dec->ppmstab = jpc_ppxstab_create())) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (!(ppmstabent = jpc_ppxstabent_create())) {\n\t\treturn -1;\n\t}\n\tppmstabent->ind = ppm->ind;\n\tppmstabent->data = ppm->data;\n\tppm->data = 0;\n\tppmstabent->len = ppm->len;\n\tif (jpc_ppxstab_insert(dec->ppmstab, ppmstabent)) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_dec_process_ppt(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tjpc_ppt_t *ppt = &ms->parms.ppt;\n\tjpc_dec_tile_t *tile;\n\tjpc_ppxstabent_t *pptstabent;\n\n\ttile = dec->curtile;\n\tif (!tile->pptstab) {\n\t\tif (!(tile->pptstab = jpc_ppxstab_create())) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\tif (!(pptstabent = jpc_ppxstabent_create())) {\n\t\treturn -1;\n\t}\n\tpptstabent->ind = ppt->ind;\n\tpptstabent->data = ppt->data;\n\tppt->data = 0;\n\tpptstabent->len = ppt->len;\n\tif (jpc_ppxstab_insert(tile->pptstab, pptstabent)) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_dec_process_com(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\t/* Eliminate compiler warnings about unused variables. */\n\tdec = 0;\n\tms = 0;\n\n\treturn 0;\n}\n\nstatic int jpc_dec_process_unk(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\t/* Eliminate compiler warnings about unused variables. */\n\tdec = 0;\n\n\tjas_eprintf(\"warning: ignoring unknown marker segment\\n\");\n\tjpc_ms_dump(ms, stderr);\n\treturn 0;\n}\n\n/******************************************************************************\\\n*\n\\******************************************************************************/\n\nstatic jpc_dec_cp_t *jpc_dec_cp_create(uint_fast16_t numcomps)\n{\n\tjpc_dec_cp_t *cp;\n\tjpc_dec_ccp_t *ccp;\n\tint compno;\n\n\tif (!(cp = jas_malloc(sizeof(jpc_dec_cp_t)))) {\n\t\treturn 0;\n\t}\n\tcp->flags = 0;\n\tcp->numcomps = numcomps;\n\tcp->prgord = 0;\n\tcp->numlyrs = 0;\n\tcp->mctid = 0;\n\tcp->csty = 0;\n\tif (!(cp->ccps = jas_malloc(cp->numcomps * sizeof(jpc_dec_ccp_t)))) {\n\t\treturn 0;\n\t}\n\tif (!(cp->pchglist = jpc_pchglist_create())) {\n\t\tjas_free(cp->ccps);\n\t\treturn 0;\n\t}\n\tfor (compno = 0, ccp = cp->ccps; compno < cp->numcomps;\n\t  ++compno, ++ccp) {\n\t\tccp->flags = 0;\n\t\tccp->numrlvls = 0;\n\t\tccp->cblkwidthexpn = 0;\n\t\tccp->cblkheightexpn = 0;\n\t\tccp->qmfbid = 0;\n\t\tccp->numstepsizes = 0;\n\t\tccp->numguardbits = 0;\n\t\tccp->roishift = 0;\n\t\tccp->cblkctx = 0;\n\t}\n\treturn cp;\n}\n\nstatic jpc_dec_cp_t *jpc_dec_cp_copy(jpc_dec_cp_t *cp)\n{\n\tjpc_dec_cp_t *newcp;\n\tjpc_dec_ccp_t *newccp;\n\tjpc_dec_ccp_t *ccp;\n\tint compno;\n\n\tif (!(newcp = jpc_dec_cp_create(cp->numcomps))) {\n\t\treturn 0;\n\t}\n\tnewcp->flags = cp->flags;\n\tnewcp->prgord = cp->prgord;\n\tnewcp->numlyrs = cp->numlyrs;\n\tnewcp->mctid = cp->mctid;\n\tnewcp->csty = cp->csty;\n\tjpc_pchglist_destroy(newcp->pchglist);\n\tnewcp->pchglist = 0;\n\tif (!(newcp->pchglist = jpc_pchglist_copy(cp->pchglist))) {\n\t\tjas_free(newcp);\n\t\treturn 0;\n\t}\n\tfor (compno = 0, newccp = newcp->ccps, ccp = cp->ccps;\n\t  compno < cp->numcomps;\n\t  ++compno, ++newccp, ++ccp) {\n\t\t*newccp = *ccp;\n\t}\n\treturn newcp;\n}\n\nstatic void jpc_dec_cp_resetflags(jpc_dec_cp_t *cp)\n{\n\tint compno;\n\tjpc_dec_ccp_t *ccp;\n\tcp->flags &= (JPC_CSET | JPC_QSET);\n\tfor (compno = 0, ccp = cp->ccps; compno < cp->numcomps;\n\t  ++compno, ++ccp) {\n\t\tccp->flags = 0;\n\t}\n}\n\nstatic void jpc_dec_cp_destroy(jpc_dec_cp_t *cp)\n{\n\tif (cp->ccps) {\n\t\tjas_free(cp->ccps);\n\t}\n\tif (cp->pchglist) {\n\t\tjpc_pchglist_destroy(cp->pchglist);\n\t}\n\tjas_free(cp);\n}\n\nstatic int jpc_dec_cp_isvalid(jpc_dec_cp_t *cp)\n{\n\tuint_fast16_t compcnt;\n\tjpc_dec_ccp_t *ccp;\n\n\tif (!(cp->flags & JPC_CSET) || !(cp->flags & JPC_QSET)) {\n\t\treturn 0;\n\t}\n\tfor (compcnt = cp->numcomps, ccp = cp->ccps; compcnt > 0; --compcnt,\n\t  ++ccp) {\n\t\t/* Is there enough step sizes for the number of bands? */\n\t\tif ((ccp->qsty != JPC_QCX_SIQNT && JAS_CAST(int, ccp->numstepsizes) < 3 *\n\t\t  ccp->numrlvls - 2) || (ccp->qsty == JPC_QCX_SIQNT &&\n\t\t  ccp->numstepsizes != 1)) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}\n\nstatic void calcstepsizes(uint_fast16_t refstepsize, int numrlvls,\n  uint_fast16_t *stepsizes)\n{\n\tint bandno;\n\tint numbands;\n\tuint_fast16_t expn;\n\tuint_fast16_t mant;\n\texpn = JPC_QCX_GETEXPN(refstepsize);\n\tmant = JPC_QCX_GETMANT(refstepsize);\n\tnumbands = 3 * numrlvls - 2;\n\tfor (bandno = 0; bandno < numbands; ++bandno) {\n\t\tstepsizes[bandno] = JPC_QCX_MANT(mant) | JPC_QCX_EXPN(expn +\n\t\t  (numrlvls - 1) - (numrlvls - 1 - ((bandno > 0) ? ((bandno + 2) / 3) : (0))));\n\t}\n}\n\nstatic int jpc_dec_cp_prepare(jpc_dec_cp_t *cp)\n{\n\tjpc_dec_ccp_t *ccp;\n\tint compno;\n\tint i;\n\tfor (compno = 0, ccp = cp->ccps; compno < cp->numcomps;\n\t  ++compno, ++ccp) {\n\t\tif (!(ccp->csty & JPC_COX_PRT)) {\n\t\t\tfor (i = 0; i < JPC_MAXRLVLS; ++i) {\n\t\t\t\tccp->prcwidthexpns[i] = 15;\n\t\t\t\tccp->prcheightexpns[i] = 15;\n\t\t\t}\n\t\t}\n\t\tif (ccp->qsty == JPC_QCX_SIQNT) {\n\t\t\tcalcstepsizes(ccp->stepsizes[0], ccp->numrlvls, ccp->stepsizes);\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int jpc_dec_cp_setfromcod(jpc_dec_cp_t *cp, jpc_cod_t *cod)\n{\n\tjpc_dec_ccp_t *ccp;\n\tint compno;\n\tcp->flags |= JPC_CSET;\n\tcp->prgord = cod->prg;\n\tif (cod->mctrans) {\n\t\tcp->mctid = (cod->compparms.qmfbid == JPC_COX_INS) ? (JPC_MCT_ICT) : (JPC_MCT_RCT);\n\t} else {\n\t\tcp->mctid = JPC_MCT_NONE;\n\t}\n\tcp->numlyrs = cod->numlyrs;\n\tcp->csty = cod->csty & (JPC_COD_SOP | JPC_COD_EPH);\n\tfor (compno = 0, ccp = cp->ccps; compno < cp->numcomps;\n\t  ++compno, ++ccp) {\n\t\tjpc_dec_cp_setfromcox(cp, ccp, &cod->compparms, 0);\n\t}\n\tcp->flags |= JPC_CSET;\n\treturn 0;\n}\n\nstatic int jpc_dec_cp_setfromcoc(jpc_dec_cp_t *cp, jpc_coc_t *coc)\n{\n\tjpc_dec_cp_setfromcox(cp, &cp->ccps[coc->compno], &coc->compparms, JPC_COC);\n\treturn 0;\n}\n\nstatic int jpc_dec_cp_setfromcox(jpc_dec_cp_t *cp, jpc_dec_ccp_t *ccp,\n  jpc_coxcp_t *compparms, int flags)\n{\n\tint rlvlno;\n\n\t/* Eliminate compiler warnings about unused variables. */\n\tcp = 0;\n\n\tif ((flags & JPC_COC) || !(ccp->flags & JPC_COC)) {\n\t\tccp->numrlvls = compparms->numdlvls + 1;\n\t\tccp->cblkwidthexpn = JPC_COX_GETCBLKSIZEEXPN(\n\t\t  compparms->cblkwidthval);\n\t\tccp->cblkheightexpn = JPC_COX_GETCBLKSIZEEXPN(\n\t\t  compparms->cblkheightval);\n\t\tccp->qmfbid = compparms->qmfbid;\n\t\tccp->cblkctx = compparms->cblksty;\n\t\tccp->csty = compparms->csty & JPC_COX_PRT;\n\t\tfor (rlvlno = 0; rlvlno < compparms->numrlvls; ++rlvlno) {\n\t\t\tccp->prcwidthexpns[rlvlno] =\n\t\t\t  compparms->rlvls[rlvlno].parwidthval;\n\t\t\tccp->prcheightexpns[rlvlno] =\n\t\t\t  compparms->rlvls[rlvlno].parheightval;\n\t\t}\n\t\tccp->flags |= flags | JPC_CSET;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_dec_cp_setfromqcd(jpc_dec_cp_t *cp, jpc_qcd_t *qcd)\n{\n\tint compno;\n\tjpc_dec_ccp_t *ccp;\n\tfor (compno = 0, ccp = cp->ccps; compno < cp->numcomps;\n\t  ++compno, ++ccp) {\n\t\tjpc_dec_cp_setfromqcx(cp, ccp, &qcd->compparms, 0);\n\t}\n\tcp->flags |= JPC_QSET;\n\treturn 0;\n}\n\nstatic int jpc_dec_cp_setfromqcc(jpc_dec_cp_t *cp, jpc_qcc_t *qcc)\n{\n\treturn jpc_dec_cp_setfromqcx(cp, &cp->ccps[qcc->compno], &qcc->compparms, JPC_QCC);\n}\n\nstatic int jpc_dec_cp_setfromqcx(jpc_dec_cp_t *cp, jpc_dec_ccp_t *ccp,\n  jpc_qcxcp_t *compparms, int flags)\n{\n\tint bandno;\n\n\t/* Eliminate compiler warnings about unused variables. */\n\tcp = 0;\n\n\tif ((flags & JPC_QCC) || !(ccp->flags & JPC_QCC)) {\n\t\tccp->flags |= flags | JPC_QSET;\n\t\tfor (bandno = 0; bandno < compparms->numstepsizes; ++bandno) {\n\t\t\tccp->stepsizes[bandno] = compparms->stepsizes[bandno];\n\t\t}\n\t\tccp->numstepsizes = compparms->numstepsizes;\n\t\tccp->numguardbits = compparms->numguard;\n\t\tccp->qsty = compparms->qntsty;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_dec_cp_setfromrgn(jpc_dec_cp_t *cp, jpc_rgn_t *rgn)\n{\n\tjpc_dec_ccp_t *ccp;\n\tccp = &cp->ccps[rgn->compno];\n\tccp->roishift = rgn->roishift;\n\treturn 0;\n}\n\nstatic int jpc_pi_addpchgfrompoc(jpc_pi_t *pi, jpc_poc_t *poc)\n{\n\tint pchgno;\n\tjpc_pchg_t *pchg;\n\tfor (pchgno = 0; pchgno < poc->numpchgs; ++pchgno) {\n\t\tif (!(pchg = jpc_pchg_copy(&poc->pchgs[pchgno]))) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (jpc_pchglist_insert(pi->pchglist, -1, pchg)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int jpc_dec_cp_setfrompoc(jpc_dec_cp_t *cp, jpc_poc_t *poc, int reset)\n{\n\tint pchgno;\n\tjpc_pchg_t *pchg;\n\tif (reset) {\n\t\twhile (jpc_pchglist_numpchgs(cp->pchglist) > 0) {\n\t\t\tpchg = jpc_pchglist_remove(cp->pchglist, 0);\n\t\t\tjpc_pchg_destroy(pchg);\n\t\t}\n\t}\n\tfor (pchgno = 0; pchgno < poc->numpchgs; ++pchgno) {\n\t\tif (!(pchg = jpc_pchg_copy(&poc->pchgs[pchgno]))) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (jpc_pchglist_insert(cp->pchglist, -1, pchg)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic jpc_fix_t jpc_calcabsstepsize(int stepsize, int numbits)\n{\n\tjpc_fix_t absstepsize;\n\tint n;\n\n\tabsstepsize = jpc_inttofix(1);\n\tn = JPC_FIX_FRACBITS - 11;\n\tabsstepsize |= (n >= 0) ? (JPC_QCX_GETMANT(stepsize) << n) :\n\t  (JPC_QCX_GETMANT(stepsize) >> (-n));\n\tn = numbits - JPC_QCX_GETEXPN(stepsize);\n\tabsstepsize = (n >= 0) ? (absstepsize << n) : (absstepsize >> (-n));\n\treturn absstepsize;\n}\n\nstatic void jpc_dequantize(jas_matrix_t *x, jpc_fix_t absstepsize)\n{\n\tint i;\n\tint j;\n\tint t;\n\n\tassert(absstepsize >= 0);\n\tif (absstepsize == jpc_inttofix(1)) {\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < jas_matrix_numrows(x); ++i) {\n\t\tfor (j = 0; j < jas_matrix_numcols(x); ++j) {\n\t\t\tt = jas_matrix_get(x, i, j);\n\t\t\tif (t) {\n\t\t\t\tt = jpc_fix_mul(t, absstepsize);\n\t\t\t} else {\n\t\t\t\tt = 0;\n\t\t\t}\n\t\t\tjas_matrix_set(x, i, j, t);\n\t\t}\n\t}\n\n}\n\nstatic void jpc_undo_roi(jas_matrix_t *x, int roishift, int bgshift, int numbps)\n{\n\tint i;\n\tint j;\n\tint thresh;\n\tjpc_fix_t val;\n\tjpc_fix_t mag;\n\tbool warn;\n\tuint_fast32_t mask;\n\n\tif (roishift == 0 && bgshift == 0) {\n\t\treturn;\n\t}\n\tthresh = 1 << roishift;\n\n\twarn = false;\n\tfor (i = 0; i < jas_matrix_numrows(x); ++i) {\n\t\tfor (j = 0; j < jas_matrix_numcols(x); ++j) {\n\t\t\tval = jas_matrix_get(x, i, j);\n\t\t\tmag = JAS_ABS(val);\n\t\t\tif (mag >= thresh) {\n\t\t\t\t/* We are dealing with ROI data. */\n\t\t\t\tmag >>= roishift;\n\t\t\t\tval = (val < 0) ? (-mag) : mag;\n\t\t\t\tjas_matrix_set(x, i, j, val);\n\t\t\t} else {\n\t\t\t\t/* We are dealing with non-ROI (i.e., background) data. */\n\t\t\t\tmag <<= bgshift;\n\t\t\t\tmask = (1 << numbps) - 1;\n\t\t\t\t/* Perform a basic sanity check on the sample value. */\n\t\t\t\t/* Some implementations write garbage in the unused\n\t\t\t\t  most-significant bit planes introduced by ROI shifting.\n\t\t\t\t  Here we ensure that any such bits are masked off. */\n\t\t\t\tif (mag & (~mask)) {\n\t\t\t\t\tif (!warn) {\n\t\t\t\t\t\tjas_eprintf(\"warning: possibly corrupt code stream\\n\");\n\t\t\t\t\t\twarn = true;\n\t\t\t\t\t}\n\t\t\t\t\tmag &= mask;\n\t\t\t\t}\n\t\t\t\tval = (val < 0) ? (-mag) : mag;\n\t\t\t\tjas_matrix_set(x, i, j, val);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic jpc_dec_t *jpc_dec_create(jpc_dec_importopts_t *impopts, jas_stream_t *in)\n{\n\tjpc_dec_t *dec;\n\n\tif (!(dec = jas_malloc(sizeof(jpc_dec_t)))) {\n\t\treturn 0;\n\t}\n\n\tdec->image = 0;\n\tdec->xstart = 0;\n\tdec->ystart = 0;\n\tdec->xend = 0;\n\tdec->yend = 0;\n\tdec->tilewidth = 0;\n\tdec->tileheight = 0;\n\tdec->tilexoff = 0;\n\tdec->tileyoff = 0;\n\tdec->numhtiles = 0;\n\tdec->numvtiles = 0;\n\tdec->numtiles = 0;\n\tdec->tiles = 0;\n\tdec->curtile = 0;\n\tdec->numcomps = 0;\n\tdec->in = in;\n\tdec->cp = 0;\n\tdec->maxlyrs = impopts->maxlyrs;\n\tdec->maxpkts = impopts->maxpkts;\ndec->numpkts = 0;\n\tdec->ppmseqno = 0;\n\tdec->state = 0;\n\tdec->cmpts = 0;\n\tdec->pkthdrstreams = 0;\n\tdec->ppmstab = 0;\n\tdec->curtileendoff = 0;\n\n\treturn dec;\n}\n\nstatic void jpc_dec_destroy(jpc_dec_t *dec)\n{\n\tif (dec->cstate) {\n\t\tjpc_cstate_destroy(dec->cstate);\n\t}\n\tif (dec->pkthdrstreams) {\n\t\tjpc_streamlist_destroy(dec->pkthdrstreams);\n\t}\n\tif (dec->image) {\n\t\tjas_image_destroy(dec->image);\n\t}\n\n\tif (dec->cp) {\n\t\tjpc_dec_cp_destroy(dec->cp);\n\t}\n\n\tif (dec->cmpts) {\n\t\tjas_free(dec->cmpts);\n\t}\n\n\tif (dec->tiles) {\n\t\tjas_free(dec->tiles);\n\t}\n\n\tjas_free(dec);\n}\n\n/******************************************************************************\\\n*\n\\******************************************************************************/\n\nvoid jpc_seglist_insert(jpc_dec_seglist_t *list, jpc_dec_seg_t *ins, jpc_dec_seg_t *node)\n{\n\tjpc_dec_seg_t *prev;\n\tjpc_dec_seg_t *next;\n\n\tprev = ins;\n\tnode->prev = prev;\n\tnext = prev ? (prev->next) : 0;\n\tnode->prev = prev;\n\tnode->next = next;\n\tif (prev) {\n\t\tprev->next = node;\n\t} else {\n\t\tlist->head = node;\n\t}\n\tif (next) {\n\t\tnext->prev = node;\n\t} else {\n\t\tlist->tail = node;\n\t}\n}\n\nvoid jpc_seglist_remove(jpc_dec_seglist_t *list, jpc_dec_seg_t *seg)\n{\n\tjpc_dec_seg_t *prev;\n\tjpc_dec_seg_t *next;\n\n\tprev = seg->prev;\n\tnext = seg->next;\n\tif (prev) {\n\t\tprev->next = next;\n\t} else {\n\t\tlist->head = next;\n\t}\n\tif (next) {\n\t\tnext->prev = prev;\n\t} else {\n\t\tlist->tail = prev;\n\t}\n\tseg->prev = 0;\n\tseg->next = 0;\n}\n\njpc_dec_seg_t *jpc_seg_alloc()\n{\n\tjpc_dec_seg_t *seg;\n\n\tif (!(seg = jas_malloc(sizeof(jpc_dec_seg_t)))) {\n\t\treturn 0;\n\t}\n\tseg->prev = 0;\n\tseg->next = 0;\n\tseg->passno = -1;\n\tseg->numpasses = 0;\n\tseg->maxpasses = 0;\n\tseg->type = JPC_SEG_INVALID;\n\tseg->stream = 0;\n\tseg->cnt = 0;\n\tseg->complete = 0;\n\tseg->lyrno = -1;\n\treturn seg;\n}\n\nvoid jpc_seg_destroy(jpc_dec_seg_t *seg)\n{\n\tif (seg->stream) {\n\t\tjas_stream_close(seg->stream);\n\t}\n\tjas_free(seg);\n}\n\nstatic int jpc_dec_dump(jpc_dec_t *dec, FILE *out)\n{\n\tjpc_dec_tile_t *tile;\n\tint tileno;\n\tjpc_dec_tcomp_t *tcomp;\n\tint compno;\n\tjpc_dec_rlvl_t *rlvl;\n\tint rlvlno;\n\tjpc_dec_band_t *band;\n\tint bandno;\n\tjpc_dec_prc_t *prc;\n\tint prcno;\n\tjpc_dec_cblk_t *cblk;\n\tint cblkno;\n\n\tfor (tileno = 0, tile = dec->tiles; tileno < dec->numtiles;\n\t  ++tileno, ++tile) {\n\t\tfor (compno = 0, tcomp = tile->tcomps; compno < dec->numcomps;\n\t\t  ++compno, ++tcomp) {\n\t\t\tfor (rlvlno = 0, rlvl = tcomp->rlvls; rlvlno <\n\t\t\t  tcomp->numrlvls; ++rlvlno, ++rlvl) {\nfprintf(out, \"RESOLUTION LEVEL %d\\n\", rlvlno);\nfprintf(out, \"xs =%d, ys = %d, xe = %d, ye = %d, w = %d, h = %d\\n\",\n  rlvl->xstart, rlvl->ystart, rlvl->xend, rlvl->yend, rlvl->xend -\n  rlvl->xstart, rlvl->yend - rlvl->ystart);\n\t\t\t\tfor (bandno = 0, band = rlvl->bands;\n\t\t\t\t  bandno < rlvl->numbands; ++bandno, ++band) {\nfprintf(out, \"BAND %d\\n\", bandno);\nfprintf(out, \"xs =%d, ys = %d, xe = %d, ye = %d, w = %d, h = %d\\n\",\n  jas_seq2d_xstart(band->data), jas_seq2d_ystart(band->data), jas_seq2d_xend(band->data),\n  jas_seq2d_yend(band->data), jas_seq2d_xend(band->data) - jas_seq2d_xstart(band->data),\n  jas_seq2d_yend(band->data) - jas_seq2d_ystart(band->data));\n\t\t\t\t\tfor (prcno = 0, prc = band->prcs;\n\t\t\t\t\t  prcno < rlvl->numprcs; ++prcno,\n\t\t\t\t\t  ++prc) {\nfprintf(out, \"CODE BLOCK GROUP %d\\n\", prcno);\nfprintf(out, \"xs =%d, ys = %d, xe = %d, ye = %d, w = %d, h = %d\\n\",\n  prc->xstart, prc->ystart, prc->xend, prc->yend, prc->xend -\n  prc->xstart, prc->yend - prc->ystart);\n\t\t\t\t\t\tfor (cblkno = 0, cblk =\n\t\t\t\t\t\t  prc->cblks; cblkno <\n\t\t\t\t\t\t  prc->numcblks; ++cblkno,\n\t\t\t\t\t\t  ++cblk) {\nfprintf(out, \"CODE BLOCK %d\\n\", cblkno);\nfprintf(out, \"xs =%d, ys = %d, xe = %d, ye = %d, w = %d, h = %d\\n\",\n  jas_seq2d_xstart(cblk->data), jas_seq2d_ystart(cblk->data), jas_seq2d_xend(cblk->data),\n  jas_seq2d_yend(cblk->data), jas_seq2d_xend(cblk->data) - jas_seq2d_xstart(cblk->data),\n  jas_seq2d_yend(cblk->data) - jas_seq2d_ystart(cblk->data));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\njpc_streamlist_t *jpc_streamlist_create()\n{\n\tjpc_streamlist_t *streamlist;\n\tint i;\n\n\tif (!(streamlist = jas_malloc(sizeof(jpc_streamlist_t)))) {\n\t\treturn 0;\n\t}\n\tstreamlist->numstreams = 0;\n\tstreamlist->maxstreams = 100;\n\tif (!(streamlist->streams = jas_malloc(streamlist->maxstreams *\n\t  sizeof(jas_stream_t *)))) {\n\t\tjas_free(streamlist);\n\t\treturn 0;\n\t}\n\tfor (i = 0; i < streamlist->maxstreams; ++i) {\n\t\tstreamlist->streams[i] = 0;\n\t}\n\treturn streamlist;\n}\n\nint jpc_streamlist_insert(jpc_streamlist_t *streamlist, int streamno,\n  jas_stream_t *stream)\n{\n\tjas_stream_t **newstreams;\n\tint newmaxstreams;\n\tint i;\n\t/* Grow the array of streams if necessary. */\n\tif (streamlist->numstreams >= streamlist->maxstreams) {\n\t\tnewmaxstreams = streamlist->maxstreams + 1024;\n\t\tif (!(newstreams = jas_realloc(streamlist->streams,\n\t\t  (newmaxstreams + 1024) * sizeof(jas_stream_t *)))) {\n\t\t\treturn -1;\n\t\t}\n\t\tfor (i = streamlist->numstreams; i < streamlist->maxstreams; ++i) {\n\t\t\tstreamlist->streams[i] = 0;\n\t\t}\n\t\tstreamlist->maxstreams = newmaxstreams;\n\t\tstreamlist->streams = newstreams;\n\t}\n\tif (streamno != streamlist->numstreams) {\n\t\t/* Can only handle insertion at start of list. */\n\t\treturn -1;\n\t}\n\tstreamlist->streams[streamno] = stream;\n\t++streamlist->numstreams;\n\treturn 0;\n}\n\njas_stream_t *jpc_streamlist_remove(jpc_streamlist_t *streamlist, int streamno)\n{\n\tjas_stream_t *stream;\n\tint i;\n\tif (streamno >= streamlist->numstreams) {\n\t\tabort();\n\t}\n\tstream = streamlist->streams[streamno];\n\tfor (i = streamno + 1; i < streamlist->numstreams; ++i) {\n\t\tstreamlist->streams[i - 1] = streamlist->streams[i];\n\t}\n\t--streamlist->numstreams;\n\treturn stream;\n}\n\nvoid jpc_streamlist_destroy(jpc_streamlist_t *streamlist)\n{\n\tint streamno;\n\tif (streamlist->streams) {\n\t\tfor (streamno = 0; streamno < streamlist->numstreams;\n\t\t  ++streamno) {\n\t\t\tjas_stream_close(streamlist->streams[streamno]);\n\t\t}\n\t\tjas_free(streamlist->streams);\n\t}\n\tjas_free(streamlist);\n}\n\njas_stream_t *jpc_streamlist_get(jpc_streamlist_t *streamlist, int streamno)\n{\n\tassert(streamno < streamlist->numstreams);\n\treturn streamlist->streams[streamno];\n}\n\nint jpc_streamlist_numstreams(jpc_streamlist_t *streamlist)\n{\n\treturn streamlist->numstreams;\n}\n\njpc_ppxstab_t *jpc_ppxstab_create()\n{\n\tjpc_ppxstab_t *tab;\n\n\tif (!(tab = jas_malloc(sizeof(jpc_ppxstab_t)))) {\n\t\treturn 0;\n\t}\n\ttab->numents = 0;\n\ttab->maxents = 0;\n\ttab->ents = 0;\n\treturn tab;\n}\n\nvoid jpc_ppxstab_destroy(jpc_ppxstab_t *tab)\n{\n\tint i;\n\tfor (i = 0; i < tab->numents; ++i) {\n\t\tjpc_ppxstabent_destroy(tab->ents[i]);\n\t}\n\tif (tab->ents) {\n\t\tjas_free(tab->ents);\n\t}\n\tjas_free(tab);\n}\n\nint jpc_ppxstab_grow(jpc_ppxstab_t *tab, int maxents)\n{\n\tjpc_ppxstabent_t **newents;\n\tif (tab->maxents < maxents) {\n\t\tnewents = (tab->ents) ? jas_realloc(tab->ents, maxents *\n\t\t  sizeof(jpc_ppxstabent_t *)) : jas_malloc(maxents * sizeof(jpc_ppxstabent_t *));\n\t\tif (!newents) {\n\t\t\treturn -1;\n\t\t}\n\t\ttab->ents = newents;\n\t\ttab->maxents = maxents;\n\t}\n\treturn 0;\n}\n\nint jpc_ppxstab_insert(jpc_ppxstab_t *tab, jpc_ppxstabent_t *ent)\n{\n\tint inspt;\n\tint i;\n\n\tfor (i = 0; i < tab->numents; ++i) {\n\t\tif (tab->ents[i]->ind > ent->ind) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tinspt = i;\n\n\tif (tab->numents >= tab->maxents) {\n\t\tif (jpc_ppxstab_grow(tab, tab->maxents + 128)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tfor (i = tab->numents; i > inspt; --i) {\n\t\ttab->ents[i] = tab->ents[i - 1];\n\t}\n\ttab->ents[i] = ent;\n\t++tab->numents;\n\n\treturn 0;\n}\n\njpc_streamlist_t *jpc_ppmstabtostreams(jpc_ppxstab_t *tab)\n{\n\tjpc_streamlist_t *streams;\n\tuchar *dataptr;\n\tuint_fast32_t datacnt;\n\tuint_fast32_t tpcnt;\n\tjpc_ppxstabent_t *ent;\n\tint entno;\n\tjas_stream_t *stream;\n\tint n;\n\n\tif (!(streams = jpc_streamlist_create())) {\n\t\tgoto error;\n\t}\n\n\tif (!tab->numents) {\n\t\treturn streams;\n\t}\n\n\tentno = 0;\n\tent = tab->ents[entno];\n\tdataptr = ent->data;\n\tdatacnt = ent->len;\n\tfor (;;) {\n\n\t\t/* Get the length of the packet header data for the current\n\t\t  tile-part. */\n\t\tif (datacnt < 4) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (!(stream = jas_stream_memopen(0, 0))) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (jpc_streamlist_insert(streams, jpc_streamlist_numstreams(streams),\n\t\t  stream)) {\n\t\t\tgoto error;\n\t\t}\n\t\ttpcnt = (dataptr[0] << 24) | (dataptr[1] << 16) | (dataptr[2] << 8)\n\t\t  | dataptr[3];\n\t\tdatacnt -= 4;\n\t\tdataptr += 4;\n\n\t\t/* Get the packet header data for the current tile-part. */\n\t\twhile (tpcnt) {\n\t\t\tif (!datacnt) {\n\t\t\t\tif (++entno >= tab->numents) {\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t\tent = tab->ents[entno];\n\t\t\t\tdataptr = ent->data;\n\t\t\t\tdatacnt = ent->len;\n\t\t\t}\n\t\t\tn = JAS_MIN(tpcnt, datacnt);\n\t\t\tif (jas_stream_write(stream, dataptr, n) != n) {\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\ttpcnt -= n;\n\t\t\tdataptr += n;\n\t\t\tdatacnt -= n;\n\t\t}\n\t\tjas_stream_rewind(stream);\n\t\tif (!datacnt) {\n\t\t\tif (++entno >= tab->numents) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tent = tab->ents[entno];\n\t\t\tdataptr = ent->data;\n\t\t\tdatacnt = ent->len;\n\t\t}\n\t}\n\n\treturn streams;\n\nerror:\n\tjpc_streamlist_destroy(streams);\n\treturn 0;\n}\n\nint jpc_pptstabwrite(jas_stream_t *out, jpc_ppxstab_t *tab)\n{\n\tint i;\n\tjpc_ppxstabent_t *ent;\n\tfor (i = 0; i < tab->numents; ++i) {\n\t\tent = tab->ents[i];\n\t\tif (jas_stream_write(out, ent->data, ent->len) != JAS_CAST(int, ent->len)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n\njpc_ppxstabent_t *jpc_ppxstabent_create()\n{\n\tjpc_ppxstabent_t *ent;\n\tif (!(ent = jas_malloc(sizeof(jpc_ppxstabent_t)))) {\n\t\treturn 0;\n\t}\n\tent->data = 0;\n\tent->len = 0;\n\tent->ind = 0;\n\treturn ent;\n}\n\nvoid jpc_ppxstabent_destroy(jpc_ppxstabent_t *ent)\n{\n\tif (ent->data) {\n\t\tjas_free(ent->data);\n\t}\n\tjas_free(ent);\n}\n", "/*\r\n  libdcr version 0.1.8.93 03/May/2009\r\n\r\n  libdcr : copyright (C) 2007-2009, Davide Pizzolato\r\n\r\n  based on dcraw.c -- Dave Coffin's raw photo decoder\r\n  Copyright 1997-2009 by Dave Coffin, dcoffin a cybercom o net\r\n\r\n  Covered code is provided under this license on an \"as is\" basis, without warranty\r\n  of any kind, either expressed or implied, including, without limitation, warranties\r\n  that the covered code is free of defects, merchantable, fit for a particular purpose\r\n  or non-infringing. The entire risk as to the quality and performance of the covered\r\n  code is with you. Should any covered code prove defective in any respect, you (not\r\n  the initial developer or any other contributor) assume the cost of any necessary\r\n  servicing, repair or correction. This disclaimer of warranty constitutes an essential\r\n  part of this license. No use of any covered code is authorized hereunder except under\r\n  this disclaimer.\r\n\r\n  No license is required to download and use libdcr.  However,\r\n  to lawfully redistribute libdcr, you must either (a) offer, at\r\n  no extra charge, full source code for all executable files\r\n  containing RESTRICTED functions, (b) distribute this code under\r\n  the GPL Version 2 or later, (c) remove all RESTRICTED functions,\r\n  re-implement them, or copy them from an earlier, unrestricted\r\n  revision of dcraw.c, or (d) purchase a license from the author\r\n  of dcraw.c.\r\n\r\n  --------------------------------------------------------------------------------\r\n\r\n  dcraw.c home page: http://cybercom.net/~dcoffin/dcraw/\r\n  libdcr  home page: http://www.xdp.it/libdcr/\r\n\r\n */\r\n\r\n#define _GNU_SOURCE\r\n#define _USE_MATH_DEFINES\r\n#include <ctype.h>\r\n#include <errno.h>\r\n#include <fcntl.h>\r\n#include <float.h>\r\n#include <limits.h>\r\n#include <math.h>\r\n#include <setjmp.h>\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n#include <time.h>\r\n#include <sys/types.h>\r\n\r\n#include \"libdcr.h\"\r\n\r\n// XYZ from RGB\r\nconst double xyz_rgb[3][3] = {\r\n\t{ 0.412453, 0.357580, 0.180423 },\r\n\t{ 0.212671, 0.715160, 0.072169 },\r\n\t{ 0.019334, 0.119193, 0.950227 } };\r\n\r\nconst float d65_white[3] = { 0.950456f, 1.0f, 1.088754f };\r\n\r\nstatic int   dcr_sfile_read(dcr_stream_obj *obj, void *buf, int size, int cnt);\r\nstatic int   dcr_sfile_write(dcr_stream_obj *obj, void *buf, int size, int cnt);\r\nstatic long  dcr_sfile_seek(dcr_stream_obj *obj, long offset, int origin);\r\nstatic int   dcr_sfile_close(dcr_stream_obj *obj);\r\nstatic char* dcr_sfile_gets(dcr_stream_obj *obj, char *string, int n);\r\nstatic int   dcr_sfile_eof(dcr_stream_obj *obj);\r\nstatic long  dcr_sfile_tell(dcr_stream_obj *obj);\r\nstatic int   dcr_sfile_getc(dcr_stream_obj *obj);\r\nstatic int   dcr_sfile_scanf(dcr_stream_obj *obj,const char *format, void* output);\r\n\r\nstatic dcr_stream_ops dcr_stream_fileops = {\r\n\tdcr_sfile_read,\r\n\tdcr_sfile_write,\r\n\tdcr_sfile_seek,\r\n\tdcr_sfile_close,\r\n\tdcr_sfile_gets,\r\n\tdcr_sfile_eof,\r\n\tdcr_sfile_tell,\r\n\tdcr_sfile_getc,\r\n\tdcr_sfile_scanf\r\n};\r\n\r\n\t/*\r\n\tNO_JPEG disables decoding of compressed Kodak DC120 files.\r\n\tNO_LCMS disables the \"-p\" option.\r\n\t*/\r\n#ifndef NO_JPEG\r\n  #if defined(_WIN32) || defined (_WIN64)\r\n    #include \"../jpeg/jpeglib.h\"\r\n  #else\r\n    #include <jpeglib.h>\r\n  #endif\r\n#endif\r\n\r\n#ifndef NO_LCMS\r\n  #if defined(_WIN32) || defined (_WIN64)\r\n    #include \"../lcms/lcms.h\"\r\n  #else\r\n    #include <lcms.h>\r\n  #endif\r\n#endif\r\n\r\n#ifdef LOCALEDIR\r\n#include <libintl.h>\r\n#define _(String) gettext(String)\r\n#else\r\n#define _(String) (String)\r\n#endif\r\n\r\n#ifdef __CYGWIN__\r\n#include <io.h>\r\n#endif\r\n#if defined(_WIN32) || defined (_WIN64)\r\n#include <sys/utime.h>\r\n#include <winsock2.h>\r\n#pragma comment(lib, \"ws2_32.lib\")\r\n#if defined(_MSC_VER) && _MSC_VER < 1900\r\n#define snprintf _snprintf\r\n#endif\r\n#define strcasecmp _stricmp\r\n#define strncasecmp _strnicmp\r\n\ttypedef __int64 INT64;\r\n\ttypedef unsigned __int64 UINT64;\r\n#else\r\n#include <unistd.h>\r\n#include <utime.h>\r\n#include <netinet/in.h>\r\n\ttypedef long long INT64;\r\n\ttypedef unsigned long long UINT64;\r\n\t#define __int64\t\tlong long\r\n#endif\r\n\r\n#ifdef LJPEG_DECODE\r\n#error Please compile dcraw.c by itself.\r\n#error Do not link it with ljpeg_decode.\r\n#endif\r\n\r\n#ifndef max\r\n#define max(A,B) (((A)>(B))?(A):(B))\r\n#endif\r\n\r\n/*\r\n   In order to inline this calculation, I make the risky\r\n   assumption that all filter patterns can be described\r\n   by a repeating pattern of eight rows and two columns\r\n\r\n   Do not use the FC or BAYER macros with the Leaf CatchLight,\r\n   because its pattern is 16x16, not 2x8.\r\n\r\n   Return values are either 0/1/2/3 = G/M/C/Y or 0/1/2/3 = R/G1/B/G2\r\n\r\n\tPowerShot 600\tPowerShot A50\tPowerShot Pro70\tPro90 & G1\r\n\t0xe1e4e1e4:\t0x1b4e4b1e:\t0x1e4b4e1b:\t0xb4b4b4b4:\r\n\r\n\t  0 1 2 3 4 5\t  0 1 2 3 4 5\t  0 1 2 3 4 5\t  0 1 2 3 4 5\r\n\t0 G M G M G M\t0 C Y C Y C Y\t0 Y C Y C Y C\t0 G M G M G M\r\n\t1 C Y C Y C Y\t1 M G M G M G\t1 M G M G M G\t1 Y C Y C Y C\r\n\t2 M G M G M G\t2 Y C Y C Y C\t2 C Y C Y C Y\r\n\t3 C Y C Y C Y\t3 G M G M G M\t3 G M G M G M\r\n\t\t\t4 C Y C Y C Y\t4 Y C Y C Y C\r\n\tPowerShot A5\t5 G M G M G M\t5 G M G M G M\r\n\t0x1e4e1e4e:\t6 Y C Y C Y C\t6 C Y C Y C Y\r\n\t\t\t7 M G M G M G\t7 M G M G M G\r\n\t  0 1 2 3 4 5\r\n\t0 C Y C Y C Y\r\n\t1 G M G M G M\r\n\t2 C Y C Y C Y\r\n\t3 M G M G M G\r\n\r\n   All RGB cameras use one of these Bayer grids:\r\n\r\n\t0x16161616:\t0x61616161:\t0x49494949:\t0x94949494:\r\n\r\n\t  0 1 2 3 4 5\t  0 1 2 3 4 5\t  0 1 2 3 4 5\t  0 1 2 3 4 5\r\n\t0 B G B G B G\t0 G R G R G R\t0 G B G B G B\t0 R G R G R G\r\n\t1 G R G R G R\t1 B G B G B G\t1 R G R G R G\t1 G B G B G B\r\n\t2 B G B G B G\t2 G R G R G R\t2 G B G B G B\t2 R G R G R G\r\n\t3 G R G R G R\t3 B G B G B G\t3 R G R G R G\t3 G B G B G B\r\n */\r\n\r\n#define FC(row,col) \\\r\n\t(p->filters >> ((((row) << 1 & 14) + ((col) & 1)) << 1) & 3)\r\n\r\n#define BAYER(row,col) \\\r\n\tp->image[((row) >> p->shrink)*p->iwidth + ((col) >> p->shrink)][FC(row,col)]\r\n\r\n#define BAYER2(row,col) \\\r\n\tp->image[((row) >> p->shrink)*p->iwidth + ((col) >> p->shrink)][dcr_fc(p,row,col)]\r\n\r\nint DCR_CLASS dcr_fc (DCRAW* p, int row, int col)\r\n{\r\n\tstatic const char filter[16][16] =\r\n\t{ { 2,1,1,3,2,3,2,0,3,2,3,0,1,2,1,0 },\r\n\t{ 0,3,0,2,0,1,3,1,0,1,1,2,0,3,3,2 },\r\n\t{ 2,3,3,2,3,1,1,3,3,1,2,1,2,0,0,3 },\r\n\t{ 0,1,0,1,0,2,0,2,2,0,3,0,1,3,2,1 },\r\n\t{ 3,1,1,2,0,1,0,2,1,3,1,3,0,1,3,0 },\r\n\t{ 2,0,0,3,3,2,3,1,2,0,2,0,3,2,2,1 },\r\n\t{ 2,3,3,1,2,1,2,1,2,1,1,2,3,0,0,1 },\r\n\t{ 1,0,0,2,3,0,0,3,0,3,0,3,2,1,2,3 },\r\n\t{ 2,3,3,1,1,2,1,0,3,2,3,0,2,3,1,3 },\r\n\t{ 1,0,2,0,3,0,3,2,0,1,1,2,0,1,0,2 },\r\n\t{ 0,1,1,3,3,2,2,1,1,3,3,0,2,1,3,2 },\r\n\t{ 2,3,2,0,0,1,3,0,2,0,1,2,3,0,1,0 },\r\n\t{ 1,3,1,2,3,2,3,2,0,2,0,1,1,0,3,0 },\r\n\t{ 0,2,0,3,1,0,0,1,1,3,3,2,3,2,2,1 },\r\n\t{ 2,1,3,2,3,1,2,1,0,3,0,2,0,2,0,2 },\r\n\t{ 0,3,1,0,0,2,0,3,2,1,3,1,1,3,1,3 } };\r\n\r\n\tif (p->filters != 1) return FC(row,col);\r\n\treturn filter[(row+p->top_margin) & 15][(col+p->left_margin) & 15];\r\n}\r\n\r\n#ifndef __GLIBC__\r\nchar *dcr_memmem (char *haystack, size_t haystacklen,\r\n\tchar *needle, size_t needlelen)\r\n{\r\n\tchar *c;\r\n\tfor (c = haystack; c <= haystack + haystacklen - needlelen; c++)\r\n\t\tif (!memcmp (c, needle, needlelen))\r\n\t\t\treturn c;\r\n\t\treturn 0;\r\n}\r\n#define memmem dcr_memmem\r\n#endif\r\n\r\nvoid DCR_CLASS dcr_merror (DCRAW* p, void *ptr, char *where)\r\n{\r\n\tif (ptr) return;\r\n\tif (p->sz_error){\r\n\t\tsprintf (p->sz_error,_(\"%s: Out of memory in %s\\n\"), p->ifname, where);\r\n\t} else {\r\n\t\tfprintf (stderr,_(\"%s: Out of memory in %s\\n\"), p->ifname, where);\r\n\t}\r\n\tlongjmp (p->failure, 1);\r\n}\r\n\r\nvoid DCR_CLASS dcr_derror(DCRAW* p)\r\n{\r\n\tif (!p->data_error) {\r\n\t\tfprintf (stderr, \"%s: \", p->ifname);\r\n\t\tif (dcr_feof(p->obj_))\r\n\t\t\tfprintf (stderr,_(\"Unexpected end of file\\n\"));\r\n\t\telse\r\n\t\t\tfprintf (stderr,_(\"Corrupt data near 0x%llx\\n\"), (INT64) dcr_ftell(p->obj_));\r\n\t}\r\n\tp->data_error = 1;\r\n}\r\n\r\nushort DCR_CLASS dcr_sget2 (DCRAW* p,uchar *s)\r\n{\r\n\tif (p->order == 0x4949)\t\t/* \"II\" means little-endian */\r\n\t\treturn s[0] | s[1] << 8;\r\n\telse\t\t\t\t/* \"MM\" means big-endian */\r\n\t\treturn s[0] << 8 | s[1];\r\n}\r\n\r\nushort DCR_CLASS dcr_get2(DCRAW* p)\r\n{\r\n\tuchar str[2] = { 0xff,0xff };\r\n\tdcr_fread(p->obj_, str, 1, 2);\r\n\treturn dcr_sget2(p, str);\r\n}\r\n\r\nunsigned DCR_CLASS dcr_sget4 (DCRAW* p,uchar *s)\r\n{\r\n\tif (p->order == 0x4949)\r\n\t\treturn s[0] | s[1] << 8 | s[2] << 16 | s[3] << 24;\r\n\telse\r\n\t\treturn s[0] << 24 | s[1] << 16 | s[2] << 8 | s[3];\r\n}\r\n#define dcr_sget4(p, s) dcr_sget4(p, (uchar *)s)\r\n\r\nunsigned DCR_CLASS dcr_get4(DCRAW* p)\r\n{\r\n\tuchar str[4] = { 0xff,0xff,0xff,0xff };\r\n\tdcr_fread(p->obj_, str, 1, 4);\r\n\treturn dcr_sget4(p, str);\r\n}\r\n\r\nunsigned DCR_CLASS dcr_getint (DCRAW* p,int type)\r\n{\r\n\treturn type == 3 ? dcr_get2(p) : dcr_get4(p);\r\n}\r\n\r\nfloat DCR_CLASS dcr_int_to_float (int i)\r\n{\r\n\tunion { int i; float f; } u;\r\n\tu.i = i;\r\n\treturn u.f;\r\n}\r\n\r\ndouble DCR_CLASS dcr_getreal (DCRAW* p,int type)\r\n{\r\n\tunion { char c[8]; double d; } u;\r\n\tint i, rev;\r\n\r\n\tswitch (type) {\r\n\tcase 3: return (unsigned short) dcr_get2(p);\r\n\tcase 4: return (unsigned int) dcr_get4(p);\r\n\tcase 5:  u.d = (unsigned int) dcr_get4(p);\r\n\t\treturn u.d / (unsigned int) dcr_get4(p);\r\n\tcase 8: return (signed short) dcr_get2(p);\r\n\tcase 9: return (signed int) dcr_get4(p);\r\n\tcase 10: u.d = (signed int) dcr_get4(p);\r\n\t\treturn u.d / (signed int) dcr_get4(p);\r\n\tcase 11: return dcr_int_to_float (dcr_get4(p));\r\n\tcase 12:\r\n\t\trev = 7 * ((p->order == 0x4949) == (ntohs(0x1234) == 0x1234));\r\n\t\tfor (i=0; i < 8; i++)\r\n\t\t\tu.c[i ^ rev] = dcr_fgetc(p->obj_);\r\n\t\treturn u.d;\r\n\tdefault: return dcr_fgetc(p->obj_);\r\n\t}\r\n}\r\n\r\nvoid DCR_CLASS dcr_read_shorts (DCRAW* p,ushort *pixel, int count)\r\n{\r\n\tif ((int)dcr_fread(p->obj_, pixel, 2, count) < count) dcr_derror(p);\r\n\tif ((p->order == 0x4949) == (ntohs(0x1234) == 0x1234))\r\n\t\t_swab ((char*)pixel, (char*)pixel, count*2);\r\n}\r\n\r\nvoid DCR_CLASS dcr_canon_black (DCRAW* p, double dark[2])\r\n{\r\n  int c, diff, row, col;\r\n\r\n  if (p->raw_width < p->width+4) return;\r\n  FORC(2) dark[c] /= (p->raw_width-p->width-2) * p->height >> 1;\r\n  if ((diff = (int)(dark[0] - dark[1])))\r\n    for (row=0; row < p->height; row++)\r\n      for (col=1; col < p->width; col+=2)\r\n\tBAYER(row,col) += diff;\r\n  dark[1] += diff;\r\n  p->black = (unsigned int)((dark[0] + dark[1] + 1) / 2);\r\n}\r\n\r\nvoid DCR_CLASS dcr_canon_600_fixed_wb (DCRAW* p,int temp)\r\n{\r\n\tstatic const short mul[4][5] = {\r\n\t\t{  667, 358,397,565,452 },\r\n\t\t{  731, 390,367,499,517 },\r\n\t\t{ 1119, 396,348,448,537 },\r\n\t\t{ 1399, 485,431,508,688 } };\r\n\tint lo, hi, i;\r\n\tfloat frac=0;\r\n\r\n\tfor (lo=4; --lo; )\r\n\t\tif (*mul[lo] <= temp) break;\r\n\tfor (hi=0; hi < 3; hi++)\r\n\t\tif (*mul[hi] >= temp) break;\r\n\tif (lo != hi)\r\n\t\tfrac = (float) (temp - *mul[lo]) / (*mul[hi] - *mul[lo]);\r\n\tfor (i=1; i < 5; i++)\r\n\t\tp->pre_mul[i-1] = 1 / (frac * mul[hi][i] + (1-frac) * mul[lo][i]);\r\n}\r\n\r\n/* Return values:  0 = p->white  1 = near p->white  2 = not p->white */\r\nint DCR_CLASS dcr_canon_600_color (DCRAW* p,int ratio[2], int mar)\r\n{\r\n\tint clipped=0, target, miss;\r\n\r\n\tif (p->flash_used) {\r\n\t\tif (ratio[1] < -104)\r\n\t\t{ ratio[1] = -104; clipped = 1; }\r\n\t\tif (ratio[1] >   12)\r\n\t\t{ ratio[1] =   12; clipped = 1; }\r\n\t} else {\r\n\t\tif (ratio[1] < -264 || ratio[1] > 461) return 2;\r\n\t\tif (ratio[1] < -50)\r\n\t\t{ ratio[1] = -50; clipped = 1; }\r\n\t\tif (ratio[1] > 307)\r\n\t\t{ ratio[1] = 307; clipped = 1; }\r\n\t}\r\n\ttarget = p->flash_used || ratio[1] < 197\r\n\t\t? -38 - (398 * ratio[1] >> 10)\r\n\t\t: -123 + (48 * ratio[1] >> 10);\r\n\tif (target - mar <= ratio[0] &&\r\n\t\ttarget + 20  >= ratio[0] && !clipped) return 0;\r\n\tmiss = target - ratio[0];\r\n\tif (abs(miss) >= mar*4) return 2;\r\n\tif (miss < -20) miss = -20;\r\n\tif (miss > mar) miss = mar;\r\n\tratio[0] = target - miss;\r\n\treturn 1;\r\n}\r\n\r\nvoid DCR_CLASS dcr_canon_600_auto_wb(DCRAW* p)\r\n{\r\n\tint mar, row, col, i, j, st, count[] = { 0,0 };\r\n\tint test[8], total[2][8], ratio[2][2], stat[2];\r\n\r\n\tmemset (&total, 0, sizeof total);\r\n\ti = (int)(p->canon_ev + 0.5);\r\n\tif      (i < 10) mar = 150;\r\n\telse if (i > 12) mar = 20;\r\n\telse mar = 280 - 20 * i;\r\n\tif (p->flash_used) mar = 80;\r\n\tfor (row=14; row < p->height-14; row+=4)\r\n\t\tfor (col=10; col < p->width; col+=2) {\r\n\t\t\tfor (i=0; i < 8; i++)\r\n\t\t\t\ttest[(i & 4) + FC(row+(i >> 1),col+(i & 1))] =\r\n\t\t\t\tBAYER(row+(i >> 1),col+(i & 1));\r\n\t\t\tfor (i=0; i < 8; i++)\r\n\t\t\t\tif (test[i] < 150 || test[i] > 1500) goto next;\r\n\t\t\tfor (i=0; i < 4; i++)\r\n\t\t\t\tif (abs(test[i] - test[i+4]) > 50) goto next;\r\n\t\t\tfor (i=0; i < 2; i++) {\r\n\t\t\t\tfor (j=0; j < 4; j+=2)\r\n\t\t\t\t\tratio[i][j >> 1] = ((test[i*4+j+1]-test[i*4+j]) << 10) / test[i*4+j];\r\n\t\t\t\tstat[i] = dcr_canon_600_color (p,ratio[i], mar);\r\n\t\t\t}\r\n\t\t\tif ((st = stat[0] | stat[1]) > 1) goto next;\r\n\t\t\tfor (i=0; i < 2; i++)\r\n\t\t\t\tif (stat[i])\r\n\t\t\t\t\tfor (j=0; j < 2; j++)\r\n\t\t\t\t\t\ttest[i*4+j*2+1] = test[i*4+j*2] * (0x400 + ratio[i][j]) >> 10;\r\n\t\t\tfor (i=0; i < 8; i++)\r\n\t\t\t\ttotal[st][i] += test[i];\r\n\t\t\tcount[st]++;\r\nnext: ;\r\n\t\t}\r\n\tif (count[0] | count[1]) {\r\n\t\tst = count[0]*200 < count[1];\r\n\t\tfor (i=0; i < 4; i++)\r\n\t\t\tp->pre_mul[i] = 1.0f / (total[st][i] + total[st][i+4]);\r\n\t}\r\n}\r\n\r\nvoid DCR_CLASS dcr_canon_600_coeff(DCRAW* p)\r\n{\r\n\tstatic const short table[6][12] = {\r\n\t\t{ -190,702,-1878,2390,   1861,-1349,905,-393, -432,944,2617,-2105  },\r\n\t\t{ -1203,1715,-1136,1648, 1388,-876,267,245,  -1641,2153,3921,-3409 },\r\n\t\t{ -615,1127,-1563,2075,  1437,-925,509,3,     -756,1268,2519,-2007 },\r\n\t\t{ -190,702,-1886,2398,   2153,-1641,763,-251, -452,964,3040,-2528  },\r\n\t\t{ -190,702,-1878,2390,   1861,-1349,905,-393, -432,944,2617,-2105  },\r\n\t\t{ -807,1319,-1785,2297,  1388,-876,769,-257,  -230,742,2067,-1555  } };\r\n\tint t=0, i, c;\r\n\tfloat mc, yc;\r\n\r\n\tmc = p->pre_mul[1] / p->pre_mul[2];\r\n\tyc = p->pre_mul[3] / p->pre_mul[2];\r\n\tif (mc > 1 && mc <= 1.28 && yc < 0.8789) t=1;\r\n\tif (mc > 1.28 && mc <= 2) {\r\n\t\tif  (yc < 0.8789) t=3;\r\n\t\telse if (yc <= 2) t=4;\r\n\t}\r\n\tif (p->flash_used) t=5;\r\n\tfor (p->raw_color = i=0; i < 3; i++)\r\n\t\tFORCC(p) p->rgb_cam[i][c] = table[t][i*4 + c] / 1024.0f;\r\n}\r\n\r\nvoid DCR_CLASS dcr_canon_600_load_raw(DCRAW* p)\r\n{\r\n\tuchar  data[1120], *dp;\r\n\tushort pixel[896], *pix;\r\n\tint irow, row, col, val;\r\n\tstatic const short mul[4][2] =\r\n\t{ { 1141,1145 }, { 1128,1109 }, { 1178,1149 }, { 1128,1109 } };\r\n\r\n\tfor (irow=row=0; irow < p->height; irow++) {\r\n\t\tif ((long)dcr_fread(p->obj_, data, 1, p->raw_width*5/4) < (long)(p->raw_width*5/4)) dcr_derror(p);\r\n\t\tfor (dp=data, pix=pixel; dp < data+1120; dp+=10, pix+=8) {\r\n\t\t\tpix[0] = (dp[0] << 2) + (dp[1] >> 6    );\r\n\t\t\tpix[1] = (dp[2] << 2) + (dp[1] >> 4 & 3);\r\n\t\t\tpix[2] = (dp[3] << 2) + (dp[1] >> 2 & 3);\r\n\t\t\tpix[3] = (dp[4] << 2) + (dp[1]      & 3);\r\n\t\t\tpix[4] = (dp[5] << 2) + (dp[9]      & 3);\r\n\t\t\tpix[5] = (dp[6] << 2) + (dp[9] >> 2 & 3);\r\n\t\t\tpix[6] = (dp[7] << 2) + (dp[9] >> 4 & 3);\r\n\t\t\tpix[7] = (dp[8] << 2) + (dp[9] >> 6    );\r\n\t\t}\r\n\t\tfor (col=0; col < p->width; col++)\r\n\t\t\tBAYER(row,col) = pixel[col];\r\n\t\tfor (col=p->width; col < p->raw_width; col++)\r\n\t\t\tp->black += pixel[col];\r\n\t\tif ((row+=2) > p->height) row = 1;\r\n\t}\r\n\tif (p->raw_width > p->width)\r\n\t\tp->black = p->black / ((p->raw_width - p->width) * p->height) - 4;\r\n\tfor (row=0; row < p->height; row++)\r\n\t\tfor (col=0; col < p->width; col++) {\r\n\t\t\tif ((val = BAYER(row,col) - p->black) < 0) val = 0;\r\n\t\t\tval = val * mul[row & 3][col & 1] >> 9;\r\n\t\t\tBAYER(row,col) = val;\r\n\t\t}\r\n\tdcr_canon_600_fixed_wb(p,1311);\r\n\tdcr_canon_600_auto_wb(p);\r\n\tdcr_canon_600_coeff(p);\r\n\tp->maximum = (0x3ff - p->black) * 1109 >> 9;\r\n\tp->black = 0;\r\n}\r\n\r\nvoid DCR_CLASS dcr_remove_zeroes(DCRAW* p)\r\n{\r\n\tunsigned row, col, tot, n, r, c;\r\n\r\n\tfor (row=0; row < p->height; row++)\r\n\t\tfor (col=0; col < p->width; col++)\r\n\t\t\tif (BAYER(row,col) == 0) {\r\n\t\t\t\ttot = n = 0;\r\n\t\t\t\tfor (r = row-2; r <= row+2; r++)\r\n\t\t\t\t\tfor (c = col-2; c <= col+2; c++)\r\n\t\t\t\t\t\tif (r < p->height && c < p->width &&\r\n\t\t\t\t\t\t\tFC(r,c) == FC(row,col) && BAYER(r,c))\r\n\t\t\t\t\t\t\ttot += (n++,BAYER(r,c));\r\n\t\t\t\t\t\tif (n) BAYER(row,col) = tot/n;\r\n\t\t\t}\r\n}\r\n\r\nint DCR_CLASS dcr_canon_s2is(DCRAW* p)\r\n{\r\n\tunsigned row;\r\n\r\n\tfor (row=0; row < 100; row++) {\r\n\t\tdcr_fseek(p->obj_, row*3340 + 3284, SEEK_SET);\r\n\t\tif (dcr_fgetc(p->obj_) > 15) return 1;\r\n\t}\r\n\treturn 0;\r\n}\r\n\r\nvoid DCR_CLASS dcr_canon_a5_load_raw(DCRAW* p)\r\n{\r\n\tushort data[2565], *dp, pixel;\r\n\tint vbits=0, buf=0, row, col, bc=0;\r\n\r\n\tp->order = 0x4949;\r\n\tfor (row=-p->top_margin; row < p->raw_height-p->top_margin; row++) {\r\n\t\tdcr_read_shorts (p,dp=data, p->raw_width * 10 / 16);\r\n\t\tfor (col=-p->left_margin; col < p->raw_width-p->left_margin; col++) {\r\n\t\t\tif ((vbits -= 10) < 0)\r\n\t\t\t\tbuf = (vbits += 16, (buf << 16) + *dp++);\r\n\t\t\tpixel = buf >> vbits & 0x3ff;\r\n\t\t\tif ((unsigned) row < p->height && (unsigned) col < p->width)\r\n\t\t\t\tBAYER(row,col) = pixel;\r\n\t\t\telse if (col > 1-p->left_margin && col != p->width)\r\n\t\t\t\tp->black += (bc++,pixel);\r\n\t\t}\r\n\t}\r\n\tif (bc) p->black /= bc;\r\n\tp->maximum = 0x3ff;\r\n\tif (p->raw_width > 1600) dcr_remove_zeroes(p);\r\n}\r\n\r\n/*\r\ndcr_getbits(p, -1) initializes the buffer\r\ndcr_getbits(p, n) where 0 <= n <= 25 returns an n-bit integer\r\n*/\r\nunsigned DCR_CLASS dcr_getbits (DCRAW* p, int nbits)\r\n{\r\n\tstatic unsigned bitbuf=0;\r\n\tstatic int vbits=0, reset=0;\r\n\tunsigned c;\r\n\r\n\tif (nbits == -1)\r\n\t\treturn bitbuf = vbits = reset = 0;\r\n\tif (nbits == 0 || reset) return 0;\r\n\twhile (vbits < nbits) {\r\n\t\tif ((c = dcr_fgetc(p->obj_)) == EOF) dcr_derror(p);\r\n\t\tif ((reset = p->zero_after_ff && c == 0xff && dcr_fgetc(p->obj_))) return 0;\r\n\t\tbitbuf = (bitbuf << 8) + (uchar) c;\r\n\t\tvbits += 8;\r\n\t}\r\n\tvbits -= nbits;\r\n\treturn bitbuf << (32-nbits-vbits) >> (32-nbits);\r\n}\r\n\r\nvoid DCR_CLASS dcr_init_decoder(DCRAW* p)\r\n{\r\n\tmemset (p->first_decode, 0, sizeof p->first_decode);\r\n\tp->free_decode = p->first_decode;\r\n}\r\n\r\n/*\r\n   Construct a decode tree according the specification in *source.\r\n   The first 16 bytes specify how many codes should be 1-bit, 2-bit\r\n   3-bit, etc.  Bytes after that are the leaf values.\r\n\r\n   For example, if the source is\r\n\r\n    { 0,1,4,2,3,1,2,0,0,0,0,0,0,0,0,0,\r\n      0x04,0x03,0x05,0x06,0x02,0x07,0x01,0x08,0x09,0x00,0x0a,0x0b,0xff  },\r\n\r\n   then the code is\r\n\r\n\t00\t\t0x04\r\n\t010\t\t0x03\r\n\t011\t\t0x05\r\n\t100\t\t0x06\r\n\t101\t\t0x02\r\n\t1100\t\t0x07\r\n\t1101\t\t0x01\r\n\t11100\t\t0x08\r\n\t11101\t\t0x09\r\n\t11110\t\t0x00\r\n\t111110\t\t0x0a\r\n\t1111110\t\t0x0b\r\n\t1111111\t\t0xff\r\n */\r\nuchar * DCR_CLASS dcr_make_decoder (DCRAW* p, const uchar *source, int level)\r\n{\r\n\tstruct dcr_decode *cur;\r\n\tstatic int leaf;\r\n\tint i, next;\r\n\r\n\tif (level==0) leaf=0;\r\n\tcur = p->free_decode++;\r\n\tif (p->free_decode > p->first_decode+2048) {\r\n\t\tfprintf (stderr,_(\"%s: decoder table overflow\\n\"), p->ifname);\r\n\t\tlongjmp (p->failure, 2);\r\n\t}\r\n\tfor (i=next=0; i <= leaf && next < 16; )\r\n\t\ti += source[next++];\r\n\tif (i > leaf) {\r\n\t\tif (level < next) {\r\n\t\t\tcur->branch[0] = p->free_decode;\r\n\t\t\tdcr_make_decoder (p, source, level+1);\r\n\t\t\tcur->branch[1] = p->free_decode;\r\n\t\t\tdcr_make_decoder (p, source, level+1);\r\n\t\t} else\r\n\t\t\tcur->leaf = source[16 + leaf++];\r\n\t}\r\n\treturn (uchar *) source + 16 + leaf;\r\n}\r\n\r\nvoid DCR_CLASS dcr_crw_init_tables (DCRAW* p, unsigned table)\r\n{\r\n\tstatic const uchar first_tree[3][29] = {\r\n\t\t{ 0,1,4,2,3,1,2,0,0,0,0,0,0,0,0,0,\r\n\t\t\t0x04,0x03,0x05,0x06,0x02,0x07,0x01,0x08,0x09,0x00,0x0a,0x0b,0xff  },\r\n\t\t{ 0,2,2,3,1,1,1,1,2,0,0,0,0,0,0,0,\r\n\t\t0x03,0x02,0x04,0x01,0x05,0x00,0x06,0x07,0x09,0x08,0x0a,0x0b,0xff  },\r\n\t\t{ 0,0,6,3,1,1,2,0,0,0,0,0,0,0,0,0,\r\n\t\t0x06,0x05,0x07,0x04,0x08,0x03,0x09,0x02,0x00,0x0a,0x01,0x0b,0xff  },\r\n\t};\r\n\tstatic const uchar second_tree[3][180] = {\r\n\t\t{ 0,2,2,2,1,4,2,1,2,5,1,1,0,0,0,139,\r\n\t\t0x03,0x04,0x02,0x05,0x01,0x06,0x07,0x08,\r\n\t\t0x12,0x13,0x11,0x14,0x09,0x15,0x22,0x00,0x21,0x16,0x0a,0xf0,\r\n\t\t0x23,0x17,0x24,0x31,0x32,0x18,0x19,0x33,0x25,0x41,0x34,0x42,\r\n\t\t0x35,0x51,0x36,0x37,0x38,0x29,0x79,0x26,0x1a,0x39,0x56,0x57,\r\n\t\t0x28,0x27,0x52,0x55,0x58,0x43,0x76,0x59,0x77,0x54,0x61,0xf9,\r\n\t\t0x71,0x78,0x75,0x96,0x97,0x49,0xb7,0x53,0xd7,0x74,0xb6,0x98,\r\n\t\t0x47,0x48,0x95,0x69,0x99,0x91,0xfa,0xb8,0x68,0xb5,0xb9,0xd6,\r\n\t\t0xf7,0xd8,0x67,0x46,0x45,0x94,0x89,0xf8,0x81,0xd5,0xf6,0xb4,\r\n\t\t0x88,0xb1,0x2a,0x44,0x72,0xd9,0x87,0x66,0xd4,0xf5,0x3a,0xa7,\r\n\t\t0x73,0xa9,0xa8,0x86,0x62,0xc7,0x65,0xc8,0xc9,0xa1,0xf4,0xd1,\r\n\t\t0xe9,0x5a,0x92,0x85,0xa6,0xe7,0x93,0xe8,0xc1,0xc6,0x7a,0x64,\r\n\t\t0xe1,0x4a,0x6a,0xe6,0xb3,0xf1,0xd3,0xa5,0x8a,0xb2,0x9a,0xba,\r\n\t\t0x84,0xa4,0x63,0xe5,0xc5,0xf3,0xd2,0xc4,0x82,0xaa,0xda,0xe4,\r\n\t\t0xf2,0xca,0x83,0xa3,0xa2,0xc3,0xea,0xc2,0xe2,0xe3,0xff,0xff  },\r\n\t\t{ 0,2,2,1,4,1,4,1,3,3,1,0,0,0,0,140,\r\n\t\t0x02,0x03,0x01,0x04,0x05,0x12,0x11,0x06,\r\n\t\t0x13,0x07,0x08,0x14,0x22,0x09,0x21,0x00,0x23,0x15,0x31,0x32,\r\n\t\t0x0a,0x16,0xf0,0x24,0x33,0x41,0x42,0x19,0x17,0x25,0x18,0x51,\r\n\t\t0x34,0x43,0x52,0x29,0x35,0x61,0x39,0x71,0x62,0x36,0x53,0x26,\r\n\t\t0x38,0x1a,0x37,0x81,0x27,0x91,0x79,0x55,0x45,0x28,0x72,0x59,\r\n\t\t0xa1,0xb1,0x44,0x69,0x54,0x58,0xd1,0xfa,0x57,0xe1,0xf1,0xb9,\r\n\t\t0x49,0x47,0x63,0x6a,0xf9,0x56,0x46,0xa8,0x2a,0x4a,0x78,0x99,\r\n\t\t0x3a,0x75,0x74,0x86,0x65,0xc1,0x76,0xb6,0x96,0xd6,0x89,0x85,\r\n\t\t0xc9,0xf5,0x95,0xb4,0xc7,0xf7,0x8a,0x97,0xb8,0x73,0xb7,0xd8,\r\n\t\t0xd9,0x87,0xa7,0x7a,0x48,0x82,0x84,0xea,0xf4,0xa6,0xc5,0x5a,\r\n\t\t0x94,0xa4,0xc6,0x92,0xc3,0x68,0xb5,0xc8,0xe4,0xe5,0xe6,0xe9,\r\n\t\t0xa2,0xa3,0xe3,0xc2,0x66,0x67,0x93,0xaa,0xd4,0xd5,0xe7,0xf8,\r\n\t\t0x88,0x9a,0xd7,0x77,0xc4,0x64,0xe2,0x98,0xa5,0xca,0xda,0xe8,\r\n\t\t0xf3,0xf6,0xa9,0xb2,0xb3,0xf2,0xd2,0x83,0xba,0xd3,0xff,0xff  },\r\n\t\t{ 0,0,6,2,1,3,3,2,5,1,2,2,8,10,0,117,\r\n\t\t0x04,0x05,0x03,0x06,0x02,0x07,0x01,0x08,\r\n\t\t0x09,0x12,0x13,0x14,0x11,0x15,0x0a,0x16,0x17,0xf0,0x00,0x22,\r\n\t\t0x21,0x18,0x23,0x19,0x24,0x32,0x31,0x25,0x33,0x38,0x37,0x34,\r\n\t\t0x35,0x36,0x39,0x79,0x57,0x58,0x59,0x28,0x56,0x78,0x27,0x41,\r\n\t\t0x29,0x77,0x26,0x42,0x76,0x99,0x1a,0x55,0x98,0x97,0xf9,0x48,\r\n\t\t0x54,0x96,0x89,0x47,0xb7,0x49,0xfa,0x75,0x68,0xb6,0x67,0x69,\r\n\t\t0xb9,0xb8,0xd8,0x52,0xd7,0x88,0xb5,0x74,0x51,0x46,0xd9,0xf8,\r\n\t\t0x3a,0xd6,0x87,0x45,0x7a,0x95,0xd5,0xf6,0x86,0xb4,0xa9,0x94,\r\n\t\t0x53,0x2a,0xa8,0x43,0xf5,0xf7,0xd4,0x66,0xa7,0x5a,0x44,0x8a,\r\n\t\t0xc9,0xe8,0xc8,0xe7,0x9a,0x6a,0x73,0x4a,0x61,0xc7,0xf4,0xc6,\r\n\t\t0x65,0xe9,0x72,0xe6,0x71,0x91,0x93,0xa6,0xda,0x92,0x85,0x62,\r\n\t\t0xf3,0xc5,0xb2,0xa4,0x84,0xba,0x64,0xa5,0xb3,0xd2,0x81,0xe5,\r\n\t\t0xd3,0xaa,0xc4,0xca,0xf2,0xb1,0xe4,0xd1,0x83,0x63,0xea,0xc3,\r\n\t\t0xe2,0x82,0xf1,0xa3,0xc2,0xa1,0xc1,0xe3,0xa2,0xe1,0xff,0xff  }\r\n\t};\r\n\tif (table > 2) table = 2;\r\n\tdcr_init_decoder(p);\r\n\tdcr_make_decoder (p, first_tree[table], 0);\r\n\tp->second_decode = p->free_decode;\r\n\tdcr_make_decoder (p, second_tree[table], 0);\r\n}\r\n\r\n/*\r\nReturn 0 if the image starts with compressed data,\r\n1 if it starts with uncompressed low-order bits.\r\n\r\n  In Canon compressed data, 0xff is always followed by 0x00.\r\n*/\r\nint DCR_CLASS dcr_canon_has_lowbits(DCRAW* p)\r\n{\r\n\tuchar test[0x4000];\r\n\tint ret=1, i;\r\n\r\n\tdcr_fseek(p->obj_, 0, SEEK_SET);\r\n\tdcr_fread(p->obj_, test, 1, sizeof test);\r\n\tfor (i=540; i < sizeof test - 1; i++)\r\n\t\tif (test[i] == 0xff) {\r\n\t\t\tif (test[i+1]) return 1;\r\n\t\t\tret=0;\r\n\t\t}\r\n\treturn ret;\r\n}\r\n\r\nvoid DCR_CLASS dcr_canon_compressed_load_raw(DCRAW* p)\r\n{\r\n\tushort *pixel, *prow;\r\n\tint nblocks, lowbits, i, row, r, col, save, val;\r\n\tunsigned irow, icol;\r\n\tstruct dcr_decode *decode, *dindex;\r\n\tint block, diffbuf[64], leaf, len, diff, carry=0, pnum=0, base[2];\r\n\tdouble dark[2] = { 0,0 };\r\n\tuchar c;\r\n\r\n\tdcr_crw_init_tables (p, p->tiff_compress);\r\n\tpixel = (ushort *) calloc (p->raw_width*8, sizeof *pixel);\r\n\tdcr_merror (p, pixel, \"canon_compressed_load_raw()\");\r\n\tlowbits = dcr_canon_has_lowbits(p);\r\n\tif (!lowbits) p->maximum = 0x3ff;\r\n\tdcr_fseek(p->obj_, 540 + lowbits*p->raw_height*p->raw_width/4, SEEK_SET);\r\n\tp->zero_after_ff = 1;\r\n\tdcr_getbits(p, -1);\r\n\tfor (row=0; row < p->raw_height; row+=8) {\r\n\t\tnblocks = MIN (8, p->raw_height-row) * p->raw_width >> 6;\r\n\t\tfor (block=0; block < nblocks; block++) {\r\n\t\t\tmemset (diffbuf, 0, sizeof diffbuf);\r\n\t\t\tdecode = p->first_decode;\r\n\t\t\tfor (i=0; i < 64; i++ ) {\r\n\t\t\t\tfor (dindex=decode; dindex->branch[0]; )\r\n\t\t\t\t\tdindex = dindex->branch[dcr_getbits(p, 1)];\r\n\t\t\t\tleaf = dindex->leaf;\r\n\t\t\t\tdecode = p->second_decode;\r\n\t\t\t\tif (leaf == 0 && i) break;\r\n\t\t\t\tif (leaf == 0xff) continue;\r\n\t\t\t\ti  += leaf >> 4;\r\n\t\t\t\tlen = leaf & 15;\r\n\t\t\t\tif (len == 0) continue;\r\n\t\t\t\tdiff = dcr_getbits(p, len);\r\n\t\t\t\tif ((diff & (1 << (len-1))) == 0)\r\n\t\t\t\t\tdiff -= (1 << len) - 1;\r\n\t\t\t\tif (i < 64) diffbuf[i] = diff;\r\n\t\t\t}\r\n\t\t\tdiffbuf[0] += carry;\r\n\t\t\tcarry = diffbuf[0];\r\n\t\t\tfor (i=0; i < 64; i++ ) {\r\n\t\t\t\tif (pnum++ % p->raw_width == 0)\r\n\t\t\t\t\tbase[0] = base[1] = 512;\r\n\t\t\t\tif ((pixel[(block << 6) + i] = base[i & 1] += diffbuf[i]) >> 10)\r\n\t\t\t\t\tdcr_derror(p);\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (lowbits) {\r\n\t\t\tsave = dcr_ftell(p->obj_);\r\n\t\t\tdcr_fseek(p->obj_, 26 + row*p->raw_width/4, SEEK_SET);\r\n\t\t\tfor (prow=pixel, i=0; i < p->raw_width*2; i++) {\r\n\t\t\t\tc = dcr_fgetc(p->obj_);\r\n\t\t\t\tfor (r=0; r < 8; r+=2, prow++) {\r\n\t\t\t\t\tval = (*prow << 2) + ((c >> r) & 3);\r\n\t\t\t\t\tif (p->raw_width == 2672 && val < 512) val += 2;\r\n\t\t\t\t\t*prow = val;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tdcr_fseek(p->obj_, save, SEEK_SET);\r\n\t\t}\r\n\t\tfor (r=0; r < 8; r++) {\r\n\t\t\tirow = row - p->top_margin + r;\r\n\t\t\tif (irow >= p->height) continue;\r\n\t\t\tfor (col=0; col < p->raw_width; col++) {\r\n\t\t\t\ticol = col - p->left_margin;\r\n\t\t\t\tif (icol < p->width)\r\n\t\t\t\t\tBAYER(irow,icol) = pixel[r*p->raw_width+col];\r\n\t\t\t\telse if (col > 1)\r\n\t\t\t\t\tdark[icol & 1] += pixel[r*p->raw_width+col];\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tfree (pixel);\r\n\tdcr_canon_black (p, dark);\r\n}\r\n\r\n/*\r\nNot a full implementation of Lossless JPEG, just\r\nenough to decode Canon, Kodak and Adobe DNG images.\r\n*/\r\n\r\nint DCR_CLASS dcr_ljpeg_start (DCRAW* p, struct dcr_jhead *jh, int info_only)\r\n{\r\n\tint c, tag, len;\r\n\tuchar data[0x10000], *dp;\r\n\r\n\tif (!info_only) dcr_init_decoder(p);\r\n\tmemset (jh, 0, sizeof *jh);\r\n\tFORC(6) jh->huff[c] = p->free_decode;\r\n\tjh->restart = INT_MAX;\r\n\tdcr_fread(p->obj_, data, 2, 1);\r\n\tif (data[1] != 0xd8) return 0;\r\n\tdo {\r\n\t\tdcr_fread(p->obj_, data, 2, 2);\r\n\t\ttag =  data[0] << 8 | data[1];\r\n\t\tlen = (data[2] << 8 | data[3]) - 2;\r\n\t\tif (tag <= 0xff00) return 0;\r\n\t\tdcr_fread(p->obj_, data, 1, len);\r\n\t\tswitch (tag) {\r\n\t\tcase 0xffc3:\r\n\t\t\tjh->sraw = ((data[7] >> 4) * (data[7] & 15) - 1) & 3;\r\n\t\tcase 0xffc0:\r\n\t\t\tjh->bits = data[0];\r\n\t\t\tjh->high = data[1] << 8 | data[2];\r\n\t\t\tjh->wide = data[3] << 8 | data[4];\r\n\t\t\tjh->clrs = data[5] + jh->sraw;\r\n\t\t\tif (len == 9 && !p->dng_version) dcr_fgetc(p->obj_);\r\n\t\t\tbreak;\r\n\t\tcase 0xffc4:\r\n\t\t\tif (info_only) break;\r\n\t\t\tfor (dp = data; dp < data+len && *dp < 4; ) {\r\n\t\t\t\tjh->huff[*dp] = p->free_decode;\r\n\t\t\t\tdp = dcr_make_decoder (p, ++dp, 0);\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\tcase 0xffda:\r\n\t\t\tjh->psv = data[1+data[0]*2];\r\n\t\t\tjh->bits -= data[3+data[0]*2] & 15;\r\n\t\t\tbreak;\r\n\t\tcase 0xffdd:\r\n\t\t\tjh->restart = data[0] << 8 | data[1];\r\n\t\t}\r\n\t} while (tag != 0xffda);\r\n\tif (info_only) return 1;\r\n\tif (jh->sraw) {\r\n\t\tFORC(4)        jh->huff[2+c] = jh->huff[1];\r\n\t\tFORC(jh->sraw) jh->huff[1+c] = jh->huff[0];\r\n\t}\r\n\tjh->row = (ushort *) calloc (jh->wide*jh->clrs, 4);\r\n\tdcr_merror (p, jh->row, \"dcr_ljpeg_start()\");\r\n\treturn p->zero_after_ff = 1;\r\n}\r\n\r\nint DCR_CLASS dcr_ljpeg_diff (DCRAW* p, struct dcr_decode *dindex)\r\n{\r\n\tint len, diff;\r\n\r\n\twhile (dindex->branch[0])\r\n\t\tdindex = dindex->branch[dcr_getbits(p, 1)];\r\n\tlen = dindex->leaf;\r\n\tif (len == 16 && (!p->dng_version || p->dng_version >= 0x1010000))\r\n\t\treturn -32768;\r\n\tdiff = dcr_getbits(p, len);\r\n\tif ((diff & (1 << (len-1))) == 0)\r\n\t\tdiff -= (1 << len) - 1;\r\n\treturn diff;\r\n}\r\n\r\nushort * DCR_CLASS dcr_ljpeg_row (DCRAW* p, int jrow, struct dcr_jhead *jh)\r\n{\r\n\tint col, c, diff, pred, spred=0;\r\n\tushort mark=0, *row[3];\r\n\r\n\tif (jrow * jh->wide % jh->restart == 0) {\r\n\t\tFORC(6) jh->vpred[c] = 1 << (jh->bits-1);\r\n\t\tif (jrow)\r\n\t\t\tdo mark = (mark << 8) + (c = dcr_fgetc(p->obj_));\r\n\t\t\twhile (c != EOF && mark >> 4 != 0xffd);\r\n\t\t\tdcr_getbits(p, -1);\r\n\t}\r\n\tFORC3 row[c] = jh->row + jh->wide*jh->clrs*((jrow+c) & 1);\r\n\tfor (col=0; col < jh->wide; col++)\r\n\t\tFORC(jh->clrs) {\r\n\t\t\tdiff = dcr_ljpeg_diff (p, jh->huff[c]);\r\n\t\t\tif (jh->sraw && c <= jh->sraw && (col | c))\r\n\t\t\t\tpred = spred;\r\n\t\t\telse if (col) pred = row[0][-jh->clrs];\r\n\t\t\telse\t    pred = (jh->vpred[c] += diff) - diff;\r\n\t\t\tif (jrow && col) switch (jh->psv) {\r\n\t\t\t\tcase 1:\tbreak;\r\n\t\t\t\tcase 2: pred = row[1][0];\t\t\t\t\tbreak;\r\n\t\t\t\tcase 3: pred = row[1][-jh->clrs];\t\t\t\tbreak;\r\n\t\t\t\tcase 4: pred = pred +   row[1][0] - row[1][-jh->clrs];\t\tbreak;\r\n\t\t\t\tcase 5: pred = pred + ((row[1][0] - row[1][-jh->clrs]) >> 1);\tbreak;\r\n\t\t\t\tcase 6: pred = row[1][0] + ((pred - row[1][-jh->clrs]) >> 1);\tbreak;\r\n\t\t\t\tcase 7: pred = (pred + row[1][0]) >> 1;\t\t\t\tbreak;\r\n\t\t\t\tdefault: pred = 0;\r\n\t\t\t}\r\n\t\t\tif ((**row = pred + diff) >> jh->bits) dcr_derror(p);\r\n\t\t\tif (c <= jh->sraw) spred = **row;\r\n\t\t\trow[0]++; row[1]++;\r\n\t\t}\r\n\t\treturn row[2];\r\n}\r\n\r\nvoid DCR_CLASS dcr_lossless_jpeg_load_raw(DCRAW* p)\r\n{\r\n\tint jwide, jrow, jcol, val, jidx, i, j, row=0, col=0;\r\n\tdouble dark[2] = { 0,0 };\r\n\tstruct dcr_jhead jh;\r\n\tint min=INT_MAX;\r\n\tushort *rp;\r\n\r\n\tif (!dcr_ljpeg_start (p,&jh, 0)) return;\r\n\tjwide = jh.wide * jh.clrs;\r\n\r\n\tfor (jrow=0; jrow < jh.high; jrow++) {\r\n\t\trp = dcr_ljpeg_row (p, jrow, &jh);\r\n\t\tfor (jcol=0; jcol < jwide; jcol++) {\r\n\t\t\tval = *rp++;\r\n\t\t\tif (jh.bits <= 12)\r\n\t\t\t\tval = p->curve[val & 0xfff];\r\n\t\t\tif (p->cr2_slice[0]) {\r\n\t\t\t\tjidx = jrow*jwide + jcol;\r\n\t\t\t\ti = jidx / (p->cr2_slice[1]*jh.high);\r\n\t\t\t\tif ((j = i >= p->cr2_slice[0]))\r\n\t\t\t\t\ti  = p->cr2_slice[0];\r\n\t\t\t\tjidx -= i * (p->cr2_slice[1]*jh.high);\r\n\t\t\t\trow = jidx / p->cr2_slice[1+j];\r\n\t\t\t\tcol = jidx % p->cr2_slice[1+j] + i*p->cr2_slice[1];\r\n\t\t\t}\r\n\t\t\tif (p->raw_width == 3984 && (col -= 2) < 0)\r\n\t\t\t\tcol += (row--,p->raw_width);\r\n\t\t\tif ((unsigned) (row-p->top_margin) < p->height) {\r\n\t\t\t\tif ((unsigned) (col-p->left_margin) < p->width) {\r\n\t\t\t\t\tBAYER(row-p->top_margin,col-p->left_margin) = val;\r\n\t\t\t\t\tif (min > val) min = val;\r\n\t\t\t\t} else if (col > 1)\r\n\t\t\t\t\tdark[(col-p->left_margin) & 1] += val;\r\n\t\t\t}\r\n\t\t\tif (++col >= p->raw_width)\r\n\t\t\t\tcol = (row++,0);\r\n\t\t}\r\n\t}\r\n\tfree (jh.row);\r\n\tdcr_canon_black (p, dark);\r\n\tif (!strcasecmp(p->make,\"KODAK\"))\r\n\t\tp->black = min;\r\n}\r\n\r\nvoid DCR_CLASS dcr_canon_sraw_load_raw(DCRAW* p)\r\n{\r\n\tstruct dcr_jhead jh;\r\n\tshort *rp=0, (*ip)[4];\r\n\tint jwide, slice, scol, ecol, row, col, jrow=0, jcol=0, pix[3], c;\r\n\tint v[3]={0,0,0}, ver, hue;\r\n\tchar *cp;\r\n\t\r\n\tif (!dcr_ljpeg_start (p, &jh, 0)) return;\r\n\tjwide = (jh.wide >>= 1) * jh.clrs;\r\n\t\r\n\tfor (ecol=slice=0; slice <= p->cr2_slice[0]; slice++) {\r\n\t\tscol = ecol;\r\n\t\tecol += p->cr2_slice[1] * 2 / jh.clrs;\r\n\t\tif (!p->cr2_slice[0] || ecol > p->raw_width-1) ecol = p->raw_width & -2;\r\n\t\tfor (row=0; row < p->height; row += (jh.clrs >> 1) - 1) {\r\n\t\t\tip = (short (*)[4]) p->image + row*p->width;\r\n\t\t\tfor (col=scol; col < ecol; col+=2, jcol+=jh.clrs) {\r\n\t\t\t\tif ((jcol %= jwide) == 0)\r\n\t\t\t\t\trp = (short *) dcr_ljpeg_row (p, jrow++, &jh);\r\n\t\t\t\tif (col >= p->width) continue;\r\n\t\t\t\tFORC (jh.clrs-2)\r\n\t\t\t\t\tip[col + (c >> 1)*p->width + (c & 1)][0] = rp[jcol+c];\r\n\t\t\t\tip[col][1] = rp[jcol+jh.clrs-2] - 16384;\r\n\t\t\t\tip[col][2] = rp[jcol+jh.clrs-1] - 16384;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tfor (cp=p->model2; *cp && !isdigit(*cp); cp++);\r\n\tsscanf (cp, \"%d.%d.%d\", v, v+1, v+2);\r\n\tver = (v[0]*1000 + v[1])*1000 + v[2];\r\n\thue = (jh.sraw+1) << 2;\r\n\tif (p->unique_id == 0x80000218 && ver > 1000006 && ver < 3000000)\r\n\t\thue = jh.sraw << 1;\r\n\tip = (short (*)[4]) p->image;\r\n\trp = ip[0];\r\n\tfor (row=0; row < p->height; row++, ip+=p->width) {\r\n\t\tif (row & (jh.sraw >> 1))\r\n\t\t\tfor (col=0; col < p->width; col+=2)\r\n\t\t\t\tfor (c=1; c < 3; c++)\r\n\t\t\t\t\tif (row == p->height-1)\r\n\t\t\t\t\t\tip[col][c] =  ip[col-p->width][c];\r\n\t\t\t\t\telse ip[col][c] = (ip[col-p->width][c] + ip[col+p->width][c] + 1) >> 1;\r\n\t\t\t\t\tfor (col=1; col < p->width; col+=2)\r\n\t\t\t\t\t\tfor (c=1; c < 3; c++)\r\n\t\t\t\t\t\t\tif (col == p->width-1)\r\n\t\t\t\t\t\t\t\tip[col][c] =  ip[col-1][c];\r\n\t\t\t\t\t\t\telse ip[col][c] = (ip[col-1][c] + ip[col+1][c] + 1) >> 1;\r\n\t}\r\n\tfor ( ; rp < ip[0]; rp+=4) {\r\n\t\tif (p->unique_id < 0x80000200) {\r\n\t\t\tpix[0] = rp[0] + rp[2] - 512;\r\n\t\t\tpix[2] = rp[0] + rp[1] - 512;\r\n\t\t\tpix[1] = rp[0] + ((-778*rp[1] - (rp[2] << 11)) >> 12) - 512;\r\n\t\t} else {\r\n\t\t\trp[1] = (rp[1] << 2) + hue;\r\n\t\t\trp[2] = (rp[2] << 2) + hue;\r\n\t\t\tpix[0] = rp[0] + ((  200*rp[1] + 22929*rp[2]) >> 14);\r\n\t\t\tpix[1] = rp[0] + ((-5640*rp[1] - 11751*rp[2]) >> 14);\r\n\t\t\tpix[2] = rp[0] + ((29040*rp[1] -   101*rp[2]) >> 14);\r\n\t\t}\r\n\t\tFORC3 rp[c] = CLIP(pix[c] * p->sraw_mul[c] >> 10);\r\n\t}\r\n\tfree (jh.row);\r\n\tp->maximum = 0x3fff;\r\n}\r\n\r\nvoid DCR_CLASS dcr_adobe_copy_pixel (DCRAW* p, int row, int col, ushort **rp)\r\n{\r\n\tunsigned r, c;\r\n\r\n\tr = row -= p->top_margin;\r\n\tc = col -= p->left_margin;\r\n\tif (p->is_raw == 2 && p->opt.shot_select) (*rp)++;\r\n\tif (p->filters) {\r\n\t\tif (p->fuji_width) {\r\n\t\t\tr = row + p->fuji_width - 1 - (col >> 1);\r\n\t\t\tc = row + ((col+1) >> 1);\r\n\t\t}\r\n\t\tif (r < p->height && c < p->width)\r\n\t\t\tBAYER(r,c) = **rp < 0x1000 ? p->curve[**rp] : **rp;\r\n\t\t*rp += p->is_raw;\r\n\t} else {\r\n\t\tif (r < p->height && c < p->width)\r\n\t\t\tFORC(p->tiff_samples)\r\n\t\t\t\tp->image[row*p->width+col][c] = (*rp)[c] < 0x1000 ? p->curve[(*rp)[c]]:(*rp)[c];\r\n\t\t\t*rp += p->tiff_samples;\r\n\t}\r\n\tif (p->is_raw == 2 && p->opt.shot_select) (*rp)--;\r\n}\r\n\r\nvoid DCR_CLASS dcr_adobe_dng_load_raw_lj(DCRAW* p)\r\n{\r\n\tunsigned save, trow=0, tcol=0, jwide, jrow, jcol, row, col;\r\n\tstruct dcr_jhead jh;\r\n\tushort *rp;\r\n\r\n\twhile (trow < p->raw_height) {\r\n\t\tsave = dcr_ftell(p->obj_);\r\n\t\tif (p->tile_length < INT_MAX)\r\n\t\t\tdcr_fseek(p->obj_, dcr_get4(p), SEEK_SET);\r\n\t\tif (!dcr_ljpeg_start (p,&jh, 0)) break;\r\n\t\tjwide = jh.wide;\r\n\t\tif (p->filters) jwide *= jh.clrs;\r\n\t\tjwide /= p->is_raw;\r\n\t\tfor (row=col=jrow=0; (int)jrow < jh.high; jrow++) {\r\n\t\t\trp = dcr_ljpeg_row (p, jrow, &jh);\r\n\t\t\tfor (jcol=0; jcol < jwide; jcol++) {\r\n\t\t\t\tdcr_adobe_copy_pixel (p,trow+row, tcol+col, &rp);\r\n\t\t\t\tif (++col >= p->tile_width || col >= p->raw_width)\r\n\t\t\t\t\trow += 1 + (col = 0);\r\n\t\t\t}\r\n\t\t}\r\n\t\tdcr_fseek(p->obj_, save+4, SEEK_SET);\r\n\t\tif ((tcol += p->tile_width) >= p->raw_width)\r\n\t\t\ttrow += p->tile_length + (tcol = 0);\r\n\t\tfree (jh.row);\r\n\t}\r\n}\r\n\r\nvoid DCR_CLASS dcr_adobe_dng_load_raw_nc(DCRAW* p)\r\n{\r\n\tushort *pixel, *rp;\r\n\tunsigned int row, col;\r\n\r\n\tpixel = (ushort *) calloc (p->raw_width * p->tiff_samples, sizeof *pixel);\r\n\tdcr_merror (p, pixel, \"adobe_dng_load_raw_nc()\");\r\n\tfor (row=0; row < p->raw_height; row++) {\r\n\t\tif (p->tiff_bps == 16)\r\n\t\t\tdcr_read_shorts (p, pixel, p->raw_width * p->tiff_samples);\r\n\t\telse {\r\n\t\t\tdcr_getbits(p, -1);\r\n\t\t\tfor (col=0; col < p->raw_width * p->tiff_samples; col++)\r\n\t\t\t\tpixel[col] = dcr_getbits(p, p->tiff_bps);\r\n\t\t}\r\n\t\tfor (rp=pixel, col=0; col < p->raw_width; col++)\r\n\t\t\tdcr_adobe_copy_pixel (p,row, col, &rp);\r\n\t}\r\n\tfree (pixel);\r\n}\r\n\r\nvoid DCR_CLASS dcr_pentax_tree(DCRAW* p)\r\n{\r\n  ushort bit[2][13];\r\n  struct dcr_decode *cur;\r\n  int c, i, j;\r\n\r\n  dcr_init_decoder(p);\r\n  FORC(13) bit[0][c] = dcr_get2(p);\r\n  FORC(13) bit[1][c] = dcr_fgetc(p->obj_) & 15;\r\n  FORC(13) {\r\n    cur = p->first_decode;\r\n    for (i=0; i < bit[1][c]; i++) {\r\n      j = bit[0][c] >> (11-i) & 1;\r\n      if (!cur->branch[j]) cur->branch[j] = ++p->free_decode;\r\n      cur = cur->branch[j];\r\n    }\r\n    cur->leaf = c;\r\n  }\r\n}\r\n\r\nvoid DCR_CLASS dcr_pentax_k10_load_raw(DCRAW* p)\r\n{\r\n\tint row, col, diff;\r\n\tushort vpred[2][2] = {{0,0},{0,0}}, hpred[2];\r\n\r\n\tdcr_getbits(p, -1);\r\n\tfor (row=0; row < p->height; row++)\r\n\t\tfor (col=0; col < p->raw_width; col++) {\r\n\t\t\tdiff = dcr_ljpeg_diff (p, p->first_decode);\r\n\t\t\tif (col < 2) hpred[col] = vpred[row & 1][col] += diff;\r\n\t\t\telse\t   hpred[col & 1] += diff;\r\n\t\t\tif (col < p->width)\r\n\t\t\t\tBAYER(row,col) = hpred[col & 1];\r\n\t\t\tif (hpred[col & 1] >> 12) dcr_derror(p);\r\n\t\t}\r\n}\r\n\r\nvoid DCR_CLASS dcr_nikon_compressed_load_raw(DCRAW* p)\r\n{\r\n\tstatic const uchar nikon_tree[][32] = {\r\n\t\t{ 0,1,5,1,1,1,1,1,1,2,0,0,0,0,0,0,\t/* 12-bit lossy */\r\n\t\t\t5,4,3,6,2,7,1,0,8,9,11,10,12 },\r\n\t\t{ 0,1,5,1,1,1,1,1,1,2,0,0,0,0,0,0,\t/* 12-bit lossy after split */\r\n\t\t0x39,0x5a,0x38,0x27,0x16,5,4,3,2,1,0,11,12,12 },\r\n\t\t{ 0,1,4,2,3,1,2,0,0,0,0,0,0,0,0,0,  /* 12-bit lossless */\r\n\t\t5,4,6,3,7,2,8,1,9,0,10,11,12 },\r\n\t\t{ 0,1,4,3,1,1,1,1,1,2,0,0,0,0,0,0,\t/* 14-bit lossy */\r\n\t\t5,6,4,7,8,3,9,2,1,0,10,11,12,13,14 },\r\n\t\t{ 0,1,5,1,1,1,1,1,1,1,2,0,0,0,0,0,\t/* 14-bit lossy after split */\r\n\t\t8,0x5c,0x4b,0x3a,0x29,7,6,5,4,3,2,1,0,13,14 },\r\n\t\t{ 0,1,4,2,2,3,1,2,0,0,0,0,0,0,0,0,\t/* 14-bit lossless */\r\n\t\t7,6,8,5,9,4,10,3,11,12,2,0,1,13,14 } };\r\n\tstruct dcr_decode *dindex;\r\n\tushort ver0, ver1, vpred[2][2], hpred[2], csize;\r\n\tint i, min, max, step=0, huff=0, split=0, row, col, len, shl, diff;\r\n\r\n\tdcr_fseek(p->obj_, p->meta_offset, SEEK_SET);\r\n\tver0 = dcr_fgetc(p->obj_);\r\n\tver1 = dcr_fgetc(p->obj_);\r\n\tif (ver0 == 0x49 || ver1 == 0x58)\r\n\t\tdcr_fseek(p->obj_, 2110, SEEK_CUR);\r\n\tif (ver0 == 0x46) huff = 2;\r\n\tif (p->tiff_bps == 14) huff += 3;\r\n\tdcr_read_shorts (p, vpred[0], 4);\r\n\tmax = 1 << p->tiff_bps & 0x7fff;\r\n\tif ((csize = dcr_get2(p)) > 1)\r\n\t\tstep = max / (csize-1);\r\n\tif (ver0 == 0x44 && ver1 == 0x20 && step > 0) {\r\n\t\tfor (i=0; i < csize; i++)\r\n\t\t\tp->curve[i*step] = dcr_get2(p);\r\n\t\tfor (i=0; i < max; i++)\r\n\t\t\tp->curve[i] = ( p->curve[i-i%step]*(step-i%step) +\r\n\t\t\tp->curve[i-i%step+step]*(i%step) ) / step;\r\n\t\tdcr_fseek(p->obj_, p->meta_offset+562, SEEK_SET);\r\n\t\tsplit = dcr_get2(p);\r\n\t} else if (ver0 != 0x46 && csize <= 0x4001)\r\n\t\tdcr_read_shorts (p, p->curve, max=csize);\r\n\twhile (p->curve[max-2] == p->curve[max-1]) max--;\r\n\tdcr_init_decoder(p);\r\n\tdcr_make_decoder (p, nikon_tree[huff], 0);\r\n\tdcr_fseek(p->obj_, p->data_offset, SEEK_SET);\r\n\tdcr_getbits(p, -1);\r\n\tfor (min=row=0; row < p->height; row++) {\r\n\t\tif (split && row == split) {\r\n\t\t\tdcr_init_decoder(p);\r\n\t\t\tdcr_make_decoder (p, nikon_tree[huff+1], 0);\r\n\t\t\tmax += (min = 16) << 1;\r\n\t\t}\r\n\t\tfor (col=0; col < p->raw_width; col++) {\r\n\t\t\tfor (dindex=p->first_decode; dindex->branch[0]; )\r\n\t\t\t\tdindex = dindex->branch[dcr_getbits(p, 1)];\r\n\t\t\tlen = dindex->leaf & 15;\r\n\t\t\tshl = dindex->leaf >> 4;\r\n\t\t\tdiff = ((dcr_getbits(p, len-shl) << 1) + 1) << shl >> 1;\r\n\t\t\tif ((diff & (1 << (len-1))) == 0)\r\n\t\t\t\tdiff -= (1 << len) - !shl;\r\n\t\t\tif (col < 2) hpred[col] = vpred[row & 1][col] += diff;\r\n\t\t\telse\t   hpred[col & 1] += diff;\r\n\t\t\tif ((ushort)(hpred[col & 1] + min) >= max) dcr_derror(p);\r\n\t\t\tif ((unsigned) (col-p->left_margin) < p->width)\r\n\t\t\t\tBAYER(row,col-p->left_margin) = p->curve[LIM((short)hpred[col & 1],0,0x3fff)];\r\n\t\t}\r\n\t}\r\n}\r\n\r\n/*\r\nFigure out if a NEF file is compressed.  These fancy heuristics\r\nare only needed for the D100, thanks to a bug in some cameras\r\nthat tags all images as \"compressed\".\r\n*/\r\nint DCR_CLASS dcr_nikon_is_compressed(DCRAW* p)\r\n{\r\n\tuchar test[256];\r\n\tint i;\r\n\r\n\tdcr_fseek(p->obj_, p->data_offset, SEEK_SET);\r\n\tdcr_fread(p->obj_, test, 1, 256);\r\n\tfor (i=15; i < 256; i+=16)\r\n\t\tif (test[i]) return 1;\r\n\t\treturn 0;\r\n}\r\n\r\n/*\r\nReturns 1 for a Coolpix 995, 0 for anything else.\r\n*/\r\nint DCR_CLASS dcr_nikon_e995(DCRAW* p)\r\n{\r\n\tint i, histo[256];\r\n\tconst uchar often[] = { 0x00, 0x55, 0xaa, 0xff };\r\n\r\n\tmemset (histo, 0, sizeof histo);\r\n\tdcr_fseek(p->obj_, -2000, SEEK_END);\r\n\tfor (i=0; i < 2000; i++)\r\n\t\thisto[dcr_fgetc(p->obj_)]++;\r\n\tfor (i=0; i < 4; i++)\r\n\t\tif (histo[often[i]] < 200)\r\n\t\t\treturn 0;\r\n\t\treturn 1;\r\n}\r\n\r\n/*\r\nReturns 1 for a Coolpix 2100, 0 for anything else.\r\n*/\r\nint DCR_CLASS dcr_nikon_e2100(DCRAW* p)\r\n{\r\n\tuchar t[12];\r\n\tint i;\r\n\r\n\tdcr_fseek(p->obj_, 0, SEEK_SET);\r\n\tfor (i=0; i < 1024; i++) {\r\n\t\tdcr_fread(p->obj_, t, 1, 12);\r\n\t\tif (((t[2] & t[4] & t[7] & t[9]) >> 4\r\n\t\t\t& t[1] & t[6] & t[8] & t[11] & 3) != 3)\r\n\t\t\treturn 0;\r\n\t}\r\n\treturn 1;\r\n}\r\n\r\nvoid DCR_CLASS dcr_nikon_3700(DCRAW* p)\r\n{\r\n\tint bits, i;\r\n\tuchar dp[24];\r\n\tconst struct {\r\n\t\tint bits;\r\n\t\tchar make[12], model[15];\r\n\t} table[] = {\r\n\t\t{ 0x00, \"PENTAX\",  \"Optio 33WR\" },\r\n\t\t{ 0x03, \"NIKON\",   \"E3200\" },\r\n\t\t{ 0x32, \"NIKON\",   \"E3700\" },\r\n\t\t{ 0x33, \"OLYMPUS\", \"C740UZ\" } };\r\n\r\n\tdcr_fseek(p->obj_, 3072, SEEK_SET);\r\n\tdcr_fread(p->obj_, dp, 1, 24);\r\n\tbits = (dp[8] & 3) << 4 | (dp[20] & 3);\r\n\tfor (i=0; i < sizeof table / sizeof *table; i++)\r\n\t\tif (bits == table[i].bits) {\r\n\t\t\tstrcpy (p->make,  table[i].make );\r\n\t\t\tstrcpy (p->model, table[i].model);\r\n\t\t}\r\n}\r\n\r\n/*\r\nSeparates a Minolta DiMAGE Z2 from a Nikon E4300.\r\n*/\r\nint DCR_CLASS dcr_minolta_z2(DCRAW* p)\r\n{\r\n\tint i, nz;\r\n\tchar tail[424];\r\n\r\n\tdcr_fseek(p->obj_, -(long)(sizeof tail), SEEK_END);\r\n\tdcr_fread(p->obj_, tail, 1, sizeof tail);\r\n\tfor (nz=i=0; i < sizeof tail; i++)\r\n\t\tif (tail[i]) nz++;\r\n\treturn nz > 20;\r\n}\r\n\r\n/* Here p->raw_width is in bytes, not pixels. */\r\nvoid DCR_CLASS dcr_nikon_e900_load_raw(DCRAW* p)\r\n{\r\n\tint offset=0, irow, row, col;\r\n\r\n\tfor (irow=0; irow < p->height; irow++) {\r\n\t\trow = irow * 2 % p->height;\r\n\t\tif (row == 1)\r\n\t\t\toffset = - (-offset & -4096);\r\n\t\tdcr_fseek(p->obj_, offset, SEEK_SET);\r\n\t\toffset += p->raw_width;\r\n\t\tdcr_getbits(p, -1);\r\n\t\tfor (col=0; col < p->width; col++)\r\n\t\t\tBAYER(row,col) = dcr_getbits(p, 10);\r\n\t}\r\n}\r\n\r\n/*\r\nThe Fuji Super CCD is just a Bayer grid rotated 45 degrees.\r\n*/\r\nvoid DCR_CLASS dcr_fuji_load_raw(DCRAW* p)\r\n{\r\n\tushort *pixel;\r\n\tint wide, row, col, r, c;\r\n\r\n\tdcr_fseek(p->obj_, (p->top_margin*p->raw_width + p->left_margin) * 2, SEEK_CUR);\r\n\twide = p->fuji_width << !p->fuji_layout;\r\n\tpixel = (ushort *) calloc (wide, sizeof *pixel);\r\n\tdcr_merror (p, pixel, \"fuji_load_raw()\");\r\n\tfor (row=0; row < p->raw_height; row++) {\r\n\t\tdcr_read_shorts (p, pixel, wide);\r\n\t\tdcr_fseek(p->obj_, 2*(p->raw_width - wide), SEEK_CUR);\r\n\t\tfor (col=0; col < wide; col++) {\r\n\t\t\tif (p->fuji_layout) {\r\n\t\t\t\tr = p->fuji_width - 1 - col + (row >> 1);\r\n\t\t\t\tc = col + ((row+1) >> 1);\r\n\t\t\t} else {\r\n\t\t\t\tr = p->fuji_width - 1 + row - (col >> 1);\r\n\t\t\t\tc = row + ((col+1) >> 1);\r\n\t\t\t}\r\n\t\t\tBAYER(r,c) = pixel[col];\r\n\t\t}\r\n\t}\r\n\tfree (pixel);\r\n}\r\n\r\nvoid DCR_CLASS dcr_jpeg_thumb (DCRAW* p, FILE *tfp);\r\n\r\nvoid DCR_CLASS dcr_ppm_thumb (DCRAW* p, FILE *tfp)\r\n{\r\n\tchar *thumb;\r\n\tp->thumb_length = p->thumb_width*p->thumb_height*3;\r\n\tthumb = (char *) malloc (p->thumb_length);\r\n\tdcr_merror (p, thumb, \"ppm_thumb()\");\r\n\tfprintf (tfp, \"P6\\n%d %d\\n255\\n\", p->thumb_width, p->thumb_height);\r\n\tdcr_fread(p->obj_, thumb, 1, p->thumb_length);\r\n\tfwrite (thumb, 1, p->thumb_length, tfp);\r\n\tfree (thumb);\r\n}\r\n\r\nvoid DCR_CLASS dcr_layer_thumb (DCRAW* p, FILE *tfp)\r\n{\r\n\tint i, c;\r\n\tchar *thumb, map[][4] = { \"012\",\"102\" };\r\n\r\n\tp->colors = p->thumb_misc >> 5 & 7;\r\n\tp->thumb_length = p->thumb_width*p->thumb_height;\r\n\tthumb = (char *) calloc (p->colors, p->thumb_length);\r\n\tdcr_merror (p, thumb, \"layer_thumb()\");\r\n\tfprintf (tfp, \"P%d\\n%d %d\\n255\\n\",\r\n\t\t5 + (p->colors >> 1), p->thumb_width, p->thumb_height);\r\n\tdcr_fread(p->obj_, thumb, p->thumb_length, p->colors);\r\n\tfor (i=0; i < (int)p->thumb_length; i++)\r\n\t\tFORCC(p) putc (thumb[i+p->thumb_length*(map[p->thumb_misc >> 8][c]-'0')], tfp);\r\n\tfree (thumb);\r\n}\r\n\r\nvoid DCR_CLASS dcr_rollei_thumb (DCRAW* p, FILE *tfp)\r\n{\r\n\tunsigned i;\r\n\tushort *thumb;\r\n\r\n\tp->thumb_length = p->thumb_width * p->thumb_height;\r\n\tthumb = (ushort *) calloc (p->thumb_length, 2);\r\n\tdcr_merror (p, thumb, \"rollei_thumb()\");\r\n\tfprintf (tfp, \"P6\\n%d %d\\n255\\n\", p->thumb_width, p->thumb_height);\r\n\tdcr_read_shorts (p, thumb, p->thumb_length);\r\n\tfor (i=0; i < p->thumb_length; i++) {\r\n\t\tputc (thumb[i] << 3, tfp);\r\n\t\tputc (thumb[i] >> 5  << 2, tfp);\r\n\t\tputc (thumb[i] >> 11 << 3, tfp);\r\n\t}\r\n\tfree (thumb);\r\n}\r\n\r\nvoid DCR_CLASS dcr_rollei_load_raw(DCRAW* p)\r\n{\r\n\tuchar pixel[10];\r\n\tunsigned iten=0, isix, i, buffer=0, row, col, todo[16];\r\n\r\n\tisix = p->raw_width * p->raw_height * 5 / 8;\r\n\twhile (dcr_fread(p->obj_, pixel, 1, 10) == 10) {\r\n\t\tfor (i=0; i < 10; i+=2) {\r\n\t\t\ttodo[i]   = iten++;\r\n\t\t\ttodo[i+1] = pixel[i] << 8 | pixel[i+1];\r\n\t\t\tbuffer    = pixel[i] >> 2 | buffer << 6;\r\n\t\t}\r\n\t\tfor (   ; i < 16; i+=2) {\r\n\t\t\ttodo[i]   = isix++;\r\n\t\t\ttodo[i+1] = buffer >> (14-i)*5;\r\n\t\t}\r\n\t\tfor (i=0; i < 16; i+=2) {\r\n\t\t\trow = todo[i] / p->raw_width - p->top_margin;\r\n\t\t\tcol = todo[i] % p->raw_width - p->left_margin;\r\n\t\t\tif (row < p->height && col < p->width)\r\n\t\t\t\tBAYER(row,col) = (todo[i+1] & 0x3ff);\r\n\t\t}\r\n\t}\r\n\tp->maximum = 0x3ff;\r\n}\r\n\r\nint DCR_CLASS dcr_bayer (DCRAW* p, unsigned row, unsigned col)\r\n{\r\n\treturn (row < p->height && col < p->width) ? BAYER(row,col) : 0;\r\n}\r\n\r\nvoid DCR_CLASS dcr_phase_one_flat_field (DCRAW* p, int is_float, int nc)\r\n{\r\n\tushort head[8];\r\n\tunsigned wide, y, x, rend, cend, row, col;\r\n\tint c;\r\n\tfloat *mrow, num, mult[4];\r\n\r\n\tdcr_read_shorts (p, head, 8);\r\n\twide = head[2] / head[4];\r\n\tmrow = (float *) calloc (nc*wide, sizeof *mrow);\r\n\tdcr_merror (p, mrow, \"phase_one_flat_field()\");\r\n\tfor (y=0; y < (unsigned int)(head[3] / head[5]); y++) {\r\n\t\tfor (x=0; x < wide; x++)\r\n\t\t\tfor (c=0; c < nc; c+=2) {\r\n\t\t\t\tnum = is_float ? (float)dcr_getreal(p, 11) : dcr_get2(p)/32768.0f;\r\n\t\t\t\tif (y==0) mrow[c*wide+x] = num;\r\n\t\t\t\telse mrow[(c+1)*wide+x] = (num - mrow[c*wide+x]) / head[5];\r\n\t\t\t}\r\n\t\tif (y==0) continue;\r\n\t\trend = head[1]-p->top_margin + y*head[5];\r\n\t\tfor (row = rend-head[5]; row < p->height && row < rend; row++) {\r\n\t\t\tfor (x=1; x < wide; x++) {\r\n\t\t\t\tfor (c=0; c < nc; c+=2) {\r\n\t\t\t\t\tmult[c] = mrow[c*wide+x-1];\r\n\t\t\t\t\tmult[c+1] = (mrow[c*wide+x] - mult[c]) / head[4];\r\n\t\t\t\t}\r\n\t\t\t\tcend = head[0]-p->left_margin + x*head[4];\r\n\t\t\t\tfor (col = cend-head[4]; col < p->width && col < cend; col++) {\r\n\t\t\t\t\tc = nc > 2 ? FC(row,col) : 0;\r\n\t\t\t\t\tif (!(c & 1)) {\r\n\t\t\t\t\t\tc = (int)(BAYER(row,col) * mult[c]);\r\n\t\t\t\t\t\tBAYER(row,col) = LIM(c,0,65535);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tfor (c=0; c < nc; c+=2)\r\n\t\t\t\t\t\tmult[c] += mult[c+1];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tfor (x=0; x < wide; x++)\r\n\t\t\t\tfor (c=0; c < nc; c+=2)\r\n\t\t\t\t\tmrow[c*wide+x] += mrow[(c+1)*wide+x];\r\n\t\t}\r\n\t}\r\n\tfree (mrow);\r\n}\r\n\r\nvoid DCR_CLASS dcr_phase_one_correct(DCRAW* p)\r\n{\r\n\tunsigned entries, tag, data, save, col, row, type;\r\n\tint len, i, j, k, cip, val[4], dev[4], sum, max;\r\n\tint head[9], diff, mindiff=INT_MAX, off_412=0;\r\n\tstatic const signed char dir[12][2] =\r\n\t{ {-1,-1}, {-1,1}, {1,-1}, {1,1}, {-2,0}, {0,-2}, {0,2}, {2,0},\r\n\t{-2,-2}, {-2,2}, {2,-2}, {2,2} };\r\n\tfloat poly[8], num, cfrac, frac, mult[2], *yval[2];\r\n\tushort curve[0x10000], *xval[2];\r\n\r\n\tif (p->opt.half_size || !p->meta_length) return;\r\n\tif (p->opt.verbose) fprintf (stderr,_(\"Phase One correction...\\n\"));\r\n\tdcr_fseek(p->obj_, p->meta_offset, SEEK_SET);\r\n\tp->order = dcr_get2(p);\r\n\tdcr_fseek(p->obj_, 6, SEEK_CUR);\r\n\tdcr_fseek(p->obj_, p->meta_offset+dcr_get4(p), SEEK_SET);\r\n\tentries = dcr_get4(p);  dcr_get4(p);\r\n\twhile (entries--) {\r\n\t\ttag  = dcr_get4(p);\r\n\t\tlen  = dcr_get4(p);\r\n\t\tdata = dcr_get4(p);\r\n\t\tsave = dcr_ftell(p->obj_);\r\n\t\tdcr_fseek(p->obj_, p->meta_offset+data, SEEK_SET);\r\n\t\tif (tag == 0x419) {\t\t\t\t/* Polynomial curve */\r\n\t\t\tfor (dcr_get4(p), i=0; i < 8; i++)\r\n\t\t\t\tpoly[i] = (float)dcr_getreal(p, 11);\r\n\t\t\tpoly[3] += (p->ph1.tag_210 - poly[7]) * poly[6] + 1;\r\n\t\t\tfor (i=0; i < 0x10000; i++) {\r\n\t\t\t\tnum = (poly[5]*i + poly[3])*i + poly[1];\r\n\t\t\t\tcurve[i] = (unsigned short)LIM(num,0,65535);\r\n\t\t\t} goto apply;\t\t\t\t/* apply to right half */\r\n\t\t} else if (tag == 0x41a) {\t\t\t/* Polynomial curve */\r\n\t\t\tfor (i=0; i < 4; i++)\r\n\t\t\t\tpoly[i] = (float)dcr_getreal(p, 11);\r\n\t\t\tfor (i=0; i < 0x10000; i++) {\r\n\t\t\t\tfor (num=0, j=4; j--; )\r\n\t\t\t\t\tnum = num * i + poly[j];\r\n\t\t\t\tcurve[i] = (unsigned short)LIM(num+i,0,65535);\r\n\t\t\t} apply:\t\t\t\t\t/* apply to whole image */\r\n\t\t\tfor (row=0; row < p->height; row++)\r\n\t\t\t\tfor (col = (tag & 1)*p->ph1.split_col; col < p->width; col++)\r\n\t\t\t\t\tBAYER(row,col) = curve[BAYER(row,col)];\r\n\t\t} else if (tag == 0x400) {\t\t\t/* Sensor defects */\r\n\t\t\twhile ((len -= 8) >= 0) {\r\n\t\t\t\tcol  = dcr_get2(p) - p->left_margin;\r\n\t\t\t\trow  = dcr_get2(p) - p->top_margin;\r\n\t\t\t\ttype = dcr_get2(p); dcr_get2(p);\r\n\t\t\t\tif (col >= p->width) continue;\r\n\t\t\t\tif (type == 131)\t\t\t/* Bad column */\r\n\t\t\t\t\tfor (row=0; row < p->height; row++)\r\n\t\t\t\t\t\tif (FC(row,col) == 1) {\r\n\t\t\t\t\t\t\tfor (sum=i=0; i < 4; i++)\r\n\t\t\t\t\t\t\t\tsum += val[i] = dcr_bayer (p, row+dir[i][0], col+dir[i][1]);\r\n\t\t\t\t\t\t\tfor (max=i=0; i < 4; i++) {\r\n\t\t\t\t\t\t\t\tdev[i] = abs((val[i] << 2) - sum);\r\n\t\t\t\t\t\t\t\tif (dev[max] < dev[i]) max = i;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tBAYER(row,col) = (unsigned short)((sum - val[max])/3.0 + 0.5);\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tfor (sum=0, i=8; i < 12; i++)\r\n\t\t\t\t\t\t\t\tsum += dcr_bayer (p, row+dir[i][0], col+dir[i][1]);\r\n\t\t\t\t\t\t\tBAYER(row,col) = (unsigned short)(0.5 + sum * 0.0732233 +\r\n\t\t\t\t\t\t\t\t(dcr_bayer(p, row,col-2) + dcr_bayer(p, row,col+2)) * 0.3535534);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse if (type == 129) {\t\t\t/* Bad pixel */\r\n\t\t\t\t\t\t\tif (row >= p->height) continue;\r\n\t\t\t\t\t\t\tj = (FC(row,col) != 1) * 4;\r\n\t\t\t\t\t\t\tfor (sum=0, i=j; i < j+8; i++)\r\n\t\t\t\t\t\t\t\tsum += dcr_bayer (p, row+dir[i][0], col+dir[i][1]);\r\n\t\t\t\t\t\t\tBAYER(row,col) = (sum + 4) >> 3;\r\n\t\t\t\t\t\t}\r\n\t\t\t}\r\n\t\t} else if (tag == 0x401) {\t\t\t/* All-color flat fields */\r\n\t\t\tdcr_phase_one_flat_field (p, 1, 2);\r\n\t\t} else if (tag == 0x416 || tag == 0x410) {\r\n\t\t\tdcr_phase_one_flat_field (p, 0, 2);\r\n\t\t} else if (tag == 0x40b) {\t\t\t/* Red+blue flat field */\r\n\t\t\tdcr_phase_one_flat_field (p, 0, 4);\r\n\t\t} else if (tag == 0x412) {\r\n\t\t\tdcr_fseek(p->obj_, 36, SEEK_CUR);\r\n\t\t\tdiff = abs (dcr_get2(p) - p->ph1.tag_21a);\r\n\t\t\tif (mindiff > diff) {\r\n\t\t\t\tmindiff = diff;\r\n\t\t\t\toff_412 = dcr_ftell(p->obj_) - 38;\r\n\t\t\t}\r\n\t\t}\r\n\t\tdcr_fseek(p->obj_, save, SEEK_SET);\r\n\t}\r\n\tif (off_412) {\r\n\t\tdcr_fseek(p->obj_, off_412, SEEK_SET);\r\n\t\tfor (i=0; i < 9; i++) head[i] = dcr_get4(p) & 0x7fff;\r\n\t\tyval[0] = (float *) calloc (head[1]*head[3] + head[2]*head[4], 6);\r\n\t\tdcr_merror (p, yval[0], \"phase_one_correct()\");\r\n\t\tyval[1] = (float  *) (yval[0] + head[1]*head[3]);\r\n\t\txval[0] = (ushort *) (yval[1] + head[2]*head[4]);\r\n\t\txval[1] = (ushort *) (xval[0] + head[1]*head[3]);\r\n\t\tdcr_get2(p);\r\n\t\tfor (i=0; i < 2; i++)\r\n\t\t\tfor (j=0; j < head[i+1]*head[i+3]; j++)\r\n\t\t\t\tyval[i][j] = (float)dcr_getreal(p, 11);\r\n\t\tfor (i=0; i < 2; i++)\r\n\t\t\tfor (j=0; j < head[i+1]*head[i+3]; j++)\r\n\t\t\t\txval[i][j] = dcr_get2(p);\r\n\t\tfor (row=0; row < p->height; row++)\r\n\t\t\tfor (col=0; col < p->width; col++) {\r\n\t\t\t\tcfrac = (float) col * head[3] / p->raw_width;\r\n\t\t\t\tcfrac -= cip = (int)cfrac;\r\n\t\t\t\tnum = (float)(BAYER(row,col) * 0.5);\r\n\t\t\t\tfor (i=cip; i < cip+2; i++) {\r\n\t\t\t\t\tfor (k=j=0; j < head[1]; j++)\r\n\t\t\t\t\t\tif (num < xval[0][k = head[1]*i+j]) break;\r\n\t\t\t\t\t\tfrac = (j == 0 || j == head[1]) ? 0 :\r\n\t\t\t\t\t\t(xval[0][k] - num) / (xval[0][k] - xval[0][k-1]);\r\n\t\t\t\t\t\tmult[i-cip] = yval[0][k-1] * frac + yval[0][k] * (1-frac);\r\n\t\t\t\t}\r\n\t\t\t\ti = (int)(((mult[0] * (1-cfrac) + mult[1] * cfrac)\r\n\t\t\t\t\t* (row + p->top_margin) + num) * 2);\r\n\t\t\t\tBAYER(row,col) = LIM(i,0,65535);\r\n\t\t\t}\r\n\t\tfree (yval[0]);\r\n\t}\r\n}\r\n\r\nvoid DCR_CLASS dcr_phase_one_load_raw(DCRAW* p)\r\n{\r\n\tint row, col, a, b;\r\n\tushort *pixel, akey, bkey, mask;\r\n\r\n\tdcr_fseek(p->obj_, p->ph1.key_off, SEEK_SET);\r\n\takey = dcr_get2(p);\r\n\tbkey = dcr_get2(p);\r\n\tmask = p->ph1.format == 1 ? 0x5555:0x1354;\r\n\tdcr_fseek(p->obj_, p->data_offset + p->top_margin*p->raw_width*2, SEEK_SET);\r\n\tpixel = (ushort *) calloc (p->raw_width, sizeof *pixel);\r\n\tdcr_merror (p, pixel, \"phase_one_load_raw()\");\r\n\tfor (row=0; row < p->height; row++) {\r\n\t\tdcr_read_shorts (p, pixel, p->raw_width);\r\n\t\tfor (col=0; col < p->raw_width; col+=2) {\r\n\t\t\ta = pixel[col+0] ^ akey;\r\n\t\t\tb = pixel[col+1] ^ bkey;\r\n\t\t\tpixel[col+0] = (a & mask) | (b & ~mask);\r\n\t\t\tpixel[col+1] = (b & mask) | (a & ~mask);\r\n\t\t}\r\n\t\tfor (col=0; col < p->width; col++)\r\n\t\t\tBAYER(row,col) = pixel[col+p->left_margin];\r\n\t}\r\n\tfree (pixel);\r\n\tdcr_phase_one_correct(p);\r\n}\r\n\r\nunsigned DCR_CLASS dcr_ph1_bits (DCRAW* p,int nbits)\r\n{\r\n\tstatic UINT64 bitbuf=0;\r\n\tstatic int vbits=0;\r\n\r\n\tif (nbits == -1)\r\n\t\treturn (unsigned int)(bitbuf = vbits = 0);\r\n\tif (nbits == 0) return 0;\r\n\tif ((vbits -= nbits) < 0) {\r\n\t\tbitbuf = bitbuf << 32 | dcr_get4(p);\r\n\t\tvbits += 32;\r\n\t}\r\n\treturn (unsigned int)(bitbuf << (64-nbits-vbits) >> (64-nbits));\r\n}\r\n\r\nvoid DCR_CLASS dcr_phase_one_load_raw_c(DCRAW* p)\r\n{\r\n\tstatic const int length[] = { 8,7,6,9,11,10,5,12,14,13 };\r\n\tint *offset, len[2], pred[2], row, col, i, j;\r\n\tushort *pixel;\r\n\tshort (*black)[2];\r\n\r\n\tpixel = (ushort *) calloc (p->raw_width + p->raw_height*4, 2);\r\n\tdcr_merror (p, pixel, \"phase_one_load_raw_c()\");\r\n\toffset = (int *) (pixel + p->raw_width);\r\n\tdcr_fseek(p->obj_, p->strip_offset, SEEK_SET);\r\n\tfor (row=0; row < p->raw_height; row++)\r\n\t\toffset[row] = dcr_get4(p);\r\n\tblack = (short (*)[2]) offset + p->raw_height;\r\n\tdcr_fseek(p->obj_, p->ph1.black_off, SEEK_SET);\r\n\tif (p->ph1.black_off)\r\n\t\tdcr_read_shorts (p, (ushort *) black[0], p->raw_height*2);\r\n\tfor (i=0; i < 256; i++)\r\n\t\tp->curve[i] = (unsigned short)(i*i / 3.969 + 0.5);\r\n\tfor (row=0; row < p->raw_height; row++) {\r\n\t\tdcr_fseek(p->obj_, p->data_offset + offset[row], SEEK_SET);\r\n\t\tdcr_ph1_bits(p,-1);\r\n\t\tpred[0] = pred[1] = 0;\r\n\t\tfor (col=0; col < p->raw_width; col++) {\r\n\t\t\tif (col >= (p->raw_width & -8))\r\n\t\t\t\tlen[0] = len[1] = 14;\r\n\t\t\telse if ((col & 7) == 0)\r\n\t\t\t\tfor (i=0; i < 2; i++) {\r\n\t\t\t\t\tfor (j=0; j < 5 && !dcr_ph1_bits(p,1); j++);\r\n\t\t\t\t\tif (j--) len[i] = length[j*2 + dcr_ph1_bits(p,1)];\r\n\t\t\t\t}\r\n\t\t\t\tif ((i = len[col & 1]) == 14)\r\n\t\t\t\t\tpixel[col] = pred[col & 1] = dcr_ph1_bits(p,16);\r\n\t\t\t\telse\r\n\t\t\t\t\tpixel[col] = pred[col & 1] += dcr_ph1_bits(p,i) + 1 - (1 << (i - 1));\r\n\t\t\t\tif (pred[col & 1] >> 16) dcr_derror(p);\r\n\t\t\t\tif (p->ph1.format == 5 && pixel[col] < 256)\r\n\t\t\t\t\tpixel[col] = p->curve[pixel[col]];\r\n\t\t}\r\n\t\tif ((unsigned) (row-p->top_margin) < p->height)\r\n\t\t\tfor (col=0; col < p->width; col++) {\r\n\t\t\t\ti = (pixel[col+p->left_margin] << 2)\r\n\t\t\t\t\t- p->ph1.black + black[row][col >= p->ph1.split_col];\r\n\t\t\t\tif (i > 0) BAYER(row-p->top_margin,col) = i;\r\n\t\t\t}\r\n\t}\r\n\tfree (pixel);\r\n\tdcr_phase_one_correct(p);\r\n\tp->maximum = 0xfffc - p->ph1.black;\r\n}\r\n\r\nvoid DCR_CLASS dcr_hasselblad_load_raw(DCRAW* p)\r\n{\r\n\tstruct dcr_jhead jh;\r\n\tstruct dcr_decode *dindex;\r\n\tint row, col, pred[2], len[2], diff, i;\r\n\r\n\tif (!dcr_ljpeg_start (p,&jh, 0)) return;\r\n\tfree (jh.row);\r\n\tp->order = 0x4949;\r\n\tdcr_ph1_bits(p,-1);\r\n\tfor (row=-p->top_margin; row < p->height; row++) {\r\n\t\tpred[0] = pred[1] = 0x8000;\r\n\t\tfor (col=-p->left_margin; col < p->raw_width-p->left_margin; col+=2) {\r\n\t\t\tfor (i=0; i < 2; i++) {\r\n\t\t\t\tfor (dindex=jh.huff[0]; dindex->branch[0]; )\r\n\t\t\t\t\tdindex = dindex->branch[dcr_ph1_bits(p,1)];\r\n\t\t\t\tlen[i] = dindex->leaf;\r\n\t\t\t}\r\n\t\t\tfor (i=0; i < 2; i++) {\r\n\t\t\t\tdiff = dcr_ph1_bits(p,len[i]);\r\n\t\t\t\tif ((diff & (1 << (len[i]-1))) == 0)\r\n\t\t\t\t\tdiff -= (1 << len[i]) - 1;\r\n\t\t\t\tif (diff == 65535) diff = -32768;\r\n\t\t\t\tpred[i] += diff;\r\n\t\t\t\tif (row >= 0 && (unsigned)(col+i) < p->width)\r\n\t\t\t\t\tBAYER(row,col+i) = pred[i];\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tp->maximum = 0xffff;\r\n}\r\n\r\nvoid DCR_CLASS dcr_leaf_hdr_load_raw(DCRAW* p)\r\n{\r\n\tushort *pixel;\r\n\tunsigned tile=0, r, c, row, col;\r\n\r\n\tpixel = (ushort *) calloc (p->raw_width, sizeof *pixel);\r\n\tdcr_merror (p, pixel, \"leaf_hdr_load_raw()\");\r\n\tFORC(p->tiff_samples) {\r\n\t\tfor (r=0; r < p->raw_height; r++) {\r\n\t\t\tif (r % p->tile_length == 0) {\r\n\t\t\t\tdcr_fseek(p->obj_, p->data_offset + 4*tile++, SEEK_SET);\r\n\t\t\t\tdcr_fseek(p->obj_, dcr_get4(p) + 2*p->left_margin, SEEK_SET);\r\n\t\t\t}\r\n\t\t\tif (p->filters && c != p->opt.shot_select) continue;\r\n\t\t\tdcr_read_shorts (p, pixel, p->raw_width);\r\n\t\t\tif ((row = r - p->top_margin) >= p->height) continue;\r\n\t\t\tfor (col=0; col < p->width; col++)\r\n\t\t\t\tif (p->filters)  BAYER(row,col) = pixel[col];\r\n\t\t\t\telse p->image[row*p->width+col][c] = pixel[col];\r\n\t\t}\r\n\t}\r\n\tfree (pixel);\r\n\tif (!p->filters) {\r\n\t\tp->maximum = 0xffff;\r\n\t\tp->raw_color = 1;\r\n\t}\r\n}\r\n\r\nvoid DCR_CLASS dcr_sinar_4shot_load_raw(DCRAW* p)\r\n{\r\n\tushort *pixel;\r\n\tunsigned shot, row, col, r, c;\r\n\r\n\tif ((shot = p->opt.shot_select) || p->opt.half_size) {\r\n\t\tif (shot) shot--;\r\n\t\tif (shot > 3) shot = 3;\r\n\t\tdcr_fseek(p->obj_, p->data_offset + shot*4, SEEK_SET);\r\n\t\tdcr_fseek(p->obj_, dcr_get4(p), SEEK_SET);\r\n\t\tdcr_unpacked_load_raw(p);\r\n\t\treturn;\r\n\t}\r\n\tfree (p->image);\r\n\tp->image = (ushort (*)[4])\r\n\t\tcalloc ((p->iheight=p->height)*(p->iwidth=p->width), sizeof *p->image);\r\n\tdcr_merror (p, p->image, \"sinar_4shot_load_raw()\");\r\n\tpixel = (ushort *) calloc (p->raw_width, sizeof *pixel);\r\n\tdcr_merror (p, pixel, \"sinar_4shot_load_raw()\");\r\n\tfor (shot=0; shot < 4; shot++) {\r\n\t\tdcr_fseek(p->obj_, p->data_offset + shot*4, SEEK_SET);\r\n\t\tdcr_fseek(p->obj_, dcr_get4(p), SEEK_SET);\r\n\t\tfor (row=0; row < p->raw_height; row++) {\r\n\t\t\tdcr_read_shorts (p, pixel, p->raw_width);\r\n\t\t\tif ((r = row-p->top_margin - (shot >> 1 & 1)) >= p->height) continue;\r\n\t\t\tfor (col=0; col < p->raw_width; col++) {\r\n\t\t\t\tif ((c = col-p->left_margin - (shot & 1)) >= p->width) continue;\r\n\t\t\t\tp->image[r*p->width+c][FC(row,col)] = pixel[col];\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tfree (pixel);\r\n\tp->shrink = p->filters = 0;\r\n}\r\n\r\nvoid DCR_CLASS dcr_imacon_full_load_raw(DCRAW* p)\r\n{\r\n\tint row, col;\r\n\r\n\tfor (row=0; row < p->height; row++)\r\n\t\tfor (col=0; col < p->width; col++)\r\n\t\t\tdcr_read_shorts (p, p->image[row*p->width+col], 3);\r\n}\r\n\r\nvoid DCR_CLASS dcr_packed_12_load_raw(DCRAW* p)\r\n{\r\n\tint vbits=0, rbits=0, irow, row, col;\r\n\tUINT64 bitbuf=0;\r\n\r\n\tif (p->raw_width * 2 >= p->width * 3) {\t/* If raw_width is in bytes, */\r\n\t\trbits = p->raw_width * 8;\r\n\t\tp->raw_width = p->raw_width * 2 / 3;\t/* convert it to pixels and  */\r\n\t\trbits -= p->raw_width * 12;\t\t/* save the remainder.       */\r\n\t}\r\n\tp->order = p->load_flags & 1 ? 0x4949 : 0x4d4d;\r\n\tfor (irow=0; irow < p->height; irow++) {\r\n\t\trow = irow;\r\n\t\tif (p->load_flags & 2 &&\r\n\t\t\t(row = irow * 2 % p->height + irow / (p->height/2)) == 1 &&\r\n\t\t\tp->load_flags & 4) {\r\n\t\t\tif (vbits=0, p->tiff_compress)\r\n\t\t\t\tdcr_fseek(p->obj_, p->data_offset - (-p->width*p->height*3/4 & -2048), SEEK_SET);\r\n\t\t\telse {\r\n\t\t\t\tdcr_fseek(p->obj_, 0, SEEK_END);\r\n\t\t\t\tdcr_fseek(p->obj_, dcr_ftell(p->obj_)/2, SEEK_SET);\r\n\t\t\t}\r\n\t\t}\r\n\t\tfor (col=0; col < p->raw_width; col++) {\r\n\t\t\tif ((vbits -= 12) < 0) {\r\n\t\t\t\tbitbuf = bitbuf << 32 | dcr_get4(p);\r\n\t\t\t\tvbits += 32;\r\n\t\t\t}\r\n\t\t\tif ((unsigned) (col-p->left_margin) < p->width)\r\n\t\t\t\tBAYER(row,col-p->left_margin) = (unsigned short)(bitbuf << (52-vbits) >> 52);\r\n\t\t\tif (p->load_flags & 8 && (col % 10) == 9)\r\n\t\t\t\tif (vbits=0, bitbuf & 255) dcr_derror(p);\r\n\t\t}\r\n\t\tvbits -= rbits;\r\n\t}\r\n\tif (!strcmp(p->make,\"OLYMPUS\")) p->black >>= 4;\r\n}\r\n\r\nvoid DCR_CLASS dcr_unpacked_load_raw(DCRAW* p)\r\n{\r\n\tushort *pixel;\r\n\tint row, col, bits=0;\r\n\r\n\twhile (1 << ++bits < (int)p->maximum);\r\n\tdcr_fseek(p->obj_, (p->top_margin*p->raw_width + p->left_margin) * 2, SEEK_CUR);\r\n\tpixel = (ushort *) calloc (p->width, sizeof *pixel);\r\n\tdcr_merror (p, pixel, \"unpacked_load_raw()\");\r\n\tfor (row=0; row < p->height; row++) {\r\n\t\tdcr_read_shorts (p, pixel, p->width);\r\n\t\tdcr_fseek(p->obj_, 2*(p->raw_width - p->width), SEEK_CUR);\r\n\t\tfor (col=0; col < p->width; col++)\r\n\t\t\tif ((BAYER2(row,col) = pixel[col]) >> bits) dcr_derror(p);\r\n\t}\r\n\tfree (pixel);\r\n}\r\n\r\nvoid DCR_CLASS nokia_load_raw(DCRAW* p)\r\n{\r\n  uchar  *data,  *dp;\r\n  ushort *pixel, *pix;\r\n  int dwide, row, c;\r\n\r\n  dwide = p->raw_width * 5 / 4;\r\n  data = (uchar *) malloc (dwide + p->raw_width*2);\r\n  dcr_merror (p,data, \"nokia_load_raw()\");\r\n  pixel = (ushort *) (data + dwide);\r\n  for (row=0; row < p->raw_height; row++) {\r\n    if (dcr_fread(p->obj_, data, 1, dwide) < dwide) dcr_derror(p);\r\n    for (dp=data, pix=pixel; pix < pixel+p->raw_width; dp+=5, pix+=4)\r\n      FORC4 pix[c] = (dp[c] << 2) | (dp[4] >> (c << 1) & 3);\r\n    if (row < p->top_margin)\r\n      FORC(p->width) p->black += pixel[c];\r\n    else\r\n      FORC(p->width) BAYER(row-p->top_margin,c) = pixel[c];\r\n  }\r\n  free (data);\r\n  if (p->top_margin) p->black /= p->top_margin * p->width;\r\n  p->maximum = 0x3ff;\r\n}\r\n\r\nunsigned DCR_CLASS dcr_pana_bits (DCRAW* p,int nbits)\r\n{\r\n  static uchar buf[0x4000];\r\n  static int vbits;\r\n  int byte;\r\n\r\n  if (!nbits) return vbits=0;\r\n  if (!vbits) {\r\n    dcr_fread(p->obj_, buf+p->load_flags, 1, 0x4000-p->load_flags);\r\n    dcr_fread(p->obj_, buf, 1, p->load_flags);\r\n  }\r\n  vbits = (vbits - nbits) & 0x1ffff;\r\n  byte = vbits >> 3 ^ 0x3ff0;\r\n  return (buf[byte] | buf[byte+1] << 8) >> (vbits & 7) & ~(-1 << nbits);\r\n}\r\n\r\nvoid DCR_CLASS dcr_panasonic_load_raw(DCRAW* p)\r\n{\r\n  int row, col, i, j, sh=0, pred[2], nonz[2];\r\n\r\n  dcr_pana_bits(p,0);\r\n  for (row=0; row < p->height; row++)\r\n    for (col=0; col < p->raw_width; col++) {\r\n      if ((i = col % 14) == 0)\r\n\tpred[0] = pred[1] = nonz[0] = nonz[1] = 0;\r\n      if (i % 3 == 2) sh = 4 >> (3 - dcr_pana_bits(p,2));\r\n      if (nonz[i & 1]) {\r\n\tif ((j = dcr_pana_bits(p,8))) {\r\n\t  if ((pred[i & 1] -= 0x80 << sh) < 0 || sh == 4)\r\n\t       pred[i & 1] &= ~(-1 << sh);\r\n\t  pred[i & 1] += j << sh;\r\n\t}\r\n      } else if ((nonz[i & 1] = dcr_pana_bits(p,8)) || i > 11)\r\n\tpred[i & 1] = nonz[i & 1] << 4 | dcr_pana_bits(p,4);\r\n      if (col < p->width)\r\n\tif ((BAYER(row,col) = pred[col & 1]) > 4098) dcr_derror(p);\r\n    }\r\n}\r\n\r\nvoid DCR_CLASS dcr_olympus_e300_load_raw(DCRAW* p)\r\n{\r\n\tuchar  *data,  *dp;\r\n\tushort *pixel, *pix;\r\n\tint dwide, row, col;\r\n\r\n\tdwide = p->raw_width * 16 / 10;\r\n\tdcr_fseek(p->obj_, dwide*p->top_margin, SEEK_CUR);\r\n\tdata = (uchar *) malloc (dwide + p->raw_width*2);\r\n\tdcr_merror (p, data, \"olympus_e300_load_raw()\");\r\n\tpixel = (ushort *) (data + dwide);\r\n\tfor (row=0; row < p->height; row++) {\r\n\t\tif ((int)dcr_fread(p->obj_, data, 1, dwide) < dwide) dcr_derror(p);\r\n\t\tfor (dp=data, pix=pixel; pix < pixel+p->raw_width; dp+=3, pix+=2) {\r\n\t\t\tif (((dp-data) & 15) == 15)\r\n\t\t\t\tif (*dp++ && pix < pixel+p->width+p->left_margin) dcr_derror(p);\r\n\t\t\t\tpix[0] = dp[1] << 8 | dp[0];\r\n\t\t\t\tpix[1] = dp[2] << 4 | dp[1] >> 4;\r\n\t\t}\r\n\t\tfor (col=0; col < p->width; col++)\r\n\t\t\tBAYER(row,col) = (pixel[col+p->left_margin] & 0xfff);\r\n\t}\r\n\tfree (data);\r\n\tp->maximum >>= 4;\r\n\tp->black >>= 4;\r\n}\r\n\r\nvoid DCR_CLASS dcr_olympus_e410_load_raw(DCRAW* p)\r\n{\r\n\tint row, col, nbits, sign, low, high, i, w, n, nw;\r\n\tint acarry[2][3], *carry, pred, diff;\r\n\r\n\tdcr_fseek(p->obj_, 7, SEEK_CUR);\r\n\tdcr_getbits(p, -1);\r\n\tfor (row=0; row < p->height; row++) {\r\n\t\tmemset (acarry, 0, sizeof acarry);\r\n\t\tfor (col=0; col < p->width; col++) {\r\n\t\t\tcarry = acarry[col & 1];\r\n\t\t\ti = 2 * (carry[2] < 3);\r\n\t\t\tfor (nbits=2+i; (ushort) carry[0] >> (nbits+i); nbits++);\r\n\t\t\tsign = dcr_getbits(p, 1) * -1;\r\n\t\t\tlow  = dcr_getbits(p, 2);\r\n\t\t\tfor (high=0; high < 12; high++)\r\n\t\t\t\tif (dcr_getbits(p, 1)) break;\r\n\t\t\t\tif (high == 12)\r\n\t\t\t\t\thigh = dcr_getbits(p, 16-nbits) >> 1;\r\n\t\t\t\tcarry[0] = (high << nbits) | dcr_getbits(p, nbits);\r\n\t\t\t\tdiff = (carry[0] ^ sign) + carry[1];\r\n\t\t\t\tcarry[1] = (diff*3 + carry[1]) >> 5;\r\n\t\t\t\tcarry[2] = carry[0] > 16 ? 0 : carry[2]+1;\r\n\t\t\t\tif (row < 2 && col < 2) pred = 0;\r\n\t\t\t\telse if (row < 2) pred = BAYER(row,col-2);\r\n\t\t\t\telse if (col < 2) pred = BAYER(row-2,col);\r\n\t\t\t\telse {\r\n\t\t\t\t\tw  = BAYER(row,col-2);\r\n\t\t\t\t\tn  = BAYER(row-2,col);\r\n\t\t\t\t\tnw = BAYER(row-2,col-2);\r\n\t\t\t\t\tif ((w < nw && nw < n) || (n < nw && nw < w)) {\r\n\t\t\t\t\t\tif (ABS(w-nw) > 32 || ABS(n-nw) > 32)\r\n\t\t\t\t\t\t\tpred = w + n - nw;\r\n\t\t\t\t\t\telse pred = (w + n) >> 1;\r\n\t\t\t\t\t} else pred = ABS(w-nw) > ABS(n-nw) ? w : n;\r\n\t\t\t\t}\r\n\t\t\t\tif ((BAYER(row,col) = pred + ((diff << 2) | low)) >> 12) dcr_derror(p);\r\n\t\t}\r\n\t}\r\n}\r\n\r\nvoid DCR_CLASS dcr_minolta_rd175_load_raw(DCRAW* p)\r\n{\r\n\tuchar pixel[768];\r\n\tunsigned irow, box, row, col;\r\n\r\n\tfor (irow=0; irow < 1481; irow++) {\r\n\t\tif (dcr_fread(p->obj_, pixel, 1, 768) < 768) dcr_derror(p);\r\n\t\tbox = irow / 82;\r\n\t\trow = irow % 82 * 12 + ((box < 12) ? box | 1 : (box-12)*2);\r\n\t\tswitch (irow) {\r\n\t\tcase 1477: case 1479: continue;\r\n\t\tcase 1476: row = 984; break;\r\n\t\tcase 1480: row = 985; break;\r\n\t\tcase 1478: row = 985; box = 1;\r\n\t\t}\r\n\t\tif ((box < 12) && (box & 1)) {\r\n\t\t\tfor (col=0; col < 1533; col++, row ^= 1)\r\n\t\t\t\tif (col != 1) BAYER(row,col) = (col+1) & 2 ?\r\n\t\t\t\t\tpixel[col/2-1] + pixel[col/2+1] : pixel[col/2] << 1;\r\n\t\t\t\tBAYER(row,1)    = pixel[1]   << 1;\r\n\t\t\t\tBAYER(row,1533) = pixel[765] << 1;\r\n\t\t} else\r\n\t\t\tfor (col=row & 1; col < 1534; col+=2)\r\n\t\t\t\tBAYER(row,col) = pixel[col/2] << 1;\r\n\t}\r\n\tp->maximum = 0xff << 1;\r\n}\r\n\r\nvoid DCR_CLASS dcr_casio_qv5700_load_raw(DCRAW* p)\r\n{\r\n\tuchar  data[3232],  *dp;\r\n\tushort pixel[2576], *pix;\r\n\tint row, col;\r\n\r\n\tfor (row=0; row < p->height; row++) {\r\n\t\tdcr_fread(p->obj_, data, 1, 3232);\r\n\t\tfor (dp=data, pix=pixel; dp < data+3220; dp+=5, pix+=4) {\r\n\t\t\tpix[0] = (dp[0] << 2) + (dp[1] >> 6);\r\n\t\t\tpix[1] = (dp[1] << 4) + (dp[2] >> 4);\r\n\t\t\tpix[2] = (dp[2] << 6) + (dp[3] >> 2);\r\n\t\t\tpix[3] = (dp[3] << 8) + (dp[4]     );\r\n\t\t}\r\n\t\tfor (col=0; col < p->width; col++)\r\n\t\t\tBAYER(row,col) = (pixel[col] & 0x3ff);\r\n\t}\r\n\tp->maximum = 0x3fc;\r\n}\r\n\r\nvoid DCR_CLASS dcr_quicktake_100_load_raw(DCRAW* p)\r\n{\r\n\tuchar pixel[484][644];\r\n\tstatic const short gstep[16] =\r\n\t{ -89,-60,-44,-32,-22,-15,-8,-2,2,8,15,22,32,44,60,89 };\r\n\tstatic const short rstep[6][4] =\r\n\t{ {  -3,-1,1,3  }, {  -5,-1,1,5  }, {  -8,-2,2,8  },\r\n    { -13,-3,3,13 }, { -19,-4,4,19 }, { -28,-6,6,28 } };\r\n\tstatic const short curve[256] =\r\n\t{ 0,1,2,3,4,5,6,7,8,9,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,\r\n    28,29,30,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,53,\r\n    54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,74,75,76,77,78,\r\n    79,80,81,82,83,84,86,88,90,92,94,97,99,101,103,105,107,110,112,114,116,\r\n    118,120,123,125,127,129,131,134,136,138,140,142,144,147,149,151,153,155,\r\n    158,160,162,164,166,168,171,173,175,177,179,181,184,186,188,190,192,195,\r\n    197,199,201,203,205,208,210,212,214,216,218,221,223,226,230,235,239,244,\r\n    248,252,257,261,265,270,274,278,283,287,291,296,300,305,309,313,318,322,\r\n    326,331,335,339,344,348,352,357,361,365,370,374,379,383,387,392,396,400,\r\n    405,409,413,418,422,426,431,435,440,444,448,453,457,461,466,470,474,479,\r\n    483,487,492,496,500,508,519,531,542,553,564,575,587,598,609,620,631,643,\r\n    654,665,676,687,698,710,721,732,743,754,766,777,788,799,810,822,833,844,\r\n    855,866,878,889,900,911,922,933,945,956,967,978,989,1001,1012,1023 };\r\n\tint rb, row, col, sharp, val=0;\r\n\r\n\tdcr_getbits(p, -1);\r\n\tmemset (pixel, 0x80, sizeof pixel);\r\n\tfor (row=2; row < p->height+2; row++) {\r\n\t\tfor (col=2+(row & 1); col < p->width+2; col+=2) {\r\n\t\t\tval = ((pixel[row-1][col-1] + 2*pixel[row-1][col+1] +\r\n\t\t\t\tpixel[row][col-2]) >> 2) + gstep[dcr_getbits(p, 4)];\r\n\t\t\tpixel[row][col] = val = LIM(val,0,255);\r\n\t\t\tif (col < 4)\r\n\t\t\t\tpixel[row][col-2] = pixel[row+1][~row & 1] = val;\r\n\t\t\tif (row == 2)\r\n\t\t\t\tpixel[row-1][col+1] = pixel[row-1][col+3] = val;\r\n\t\t}\r\n\t\tpixel[row][col] = val;\r\n\t}\r\n\tfor (rb=0; rb < 2; rb++)\r\n\t\tfor (row=2+rb; row < p->height+2; row+=2)\r\n\t\t\tfor (col=3-(row & 1); col < p->width+2; col+=2) {\r\n\t\t\t\tif (row < 4 || col < 4) sharp = 2;\r\n\t\t\t\telse {\r\n\t\t\t\t\tval = ABS(pixel[row-2][col] - pixel[row][col-2])\r\n\t\t\t\t\t\t+ ABS(pixel[row-2][col] - pixel[row-2][col-2])\r\n\t\t\t\t\t\t+ ABS(pixel[row][col-2] - pixel[row-2][col-2]);\r\n\t\t\t\t\tsharp = val <  4 ? 0 : val <  8 ? 1 : val < 16 ? 2 :\r\n\t\t\t\t\tval < 32 ? 3 : val < 48 ? 4 : 5;\r\n\t\t\t\t}\r\n\t\t\t\tval = ((pixel[row-2][col] + pixel[row][col-2]) >> 1)\r\n\t\t\t\t\t+ rstep[sharp][dcr_getbits(p, 2)];\r\n\t\t\t\tpixel[row][col] = val = LIM(val,0,255);\r\n\t\t\t\tif (row < 4) pixel[row-2][col+2] = val;\r\n\t\t\t\tif (col < 4) pixel[row+2][col-2] = val;\r\n\t\t\t}\r\n\tfor (row=2; row < p->height+2; row++)\r\n\t\tfor (col=3-(row & 1); col < p->width+2; col+=2) {\r\n\t\t\tval = ((pixel[row][col-1] + (pixel[row][col] << 2) +\r\n\t\t\t\tpixel[row][col+1]) >> 1) - 0x100;\r\n\t\t\tpixel[row][col] = LIM(val,0,255);\r\n\t\t}\r\n\tfor (row=0; row < p->height; row++)\r\n\t\tfor (col=0; col < p->width; col++)\r\n\t\t\tBAYER(row,col) = curve[pixel[row+2][col+2]];\r\n\tp->maximum = 0x3ff;\r\n}\r\n\r\nconst int * DCR_CLASS dcr_make_decoder_int (DCRAW* p, const int *source, int level)\r\n{\r\n\tstruct dcr_decode *cur;\r\n\r\n\tcur = p->free_decode++;\r\n\tif (level < source[0]) {\r\n\t\tcur->branch[0] = p->free_decode;\r\n\t\tsource = dcr_make_decoder_int (p, source, level+1);\r\n\t\tcur->branch[1] = p->free_decode;\r\n\t\tsource = dcr_make_decoder_int (p, source, level+1);\r\n\t} else {\r\n\t\tcur->leaf = source[1];\r\n\t\tsource += 2;\r\n\t}\r\n\treturn source;\r\n}\r\n\r\nint DCR_CLASS dcr_radc_token (DCRAW* p, int tree)\r\n{\r\n\tint t;\r\n\tstatic struct dcr_decode *dstart[18], *dindex;\r\n\tstatic const int *s, source[] = {\r\n\t\t1,1, 2,3, 3,4, 4,2, 5,7, 6,5, 7,6, 7,8,\r\n\t\t1,0, 2,1, 3,3, 4,4, 5,2, 6,7, 7,6, 8,5, 8,8,\r\n\t\t2,1, 2,3, 3,0, 3,2, 3,4, 4,6, 5,5, 6,7, 6,8,\r\n\t\t2,0, 2,1, 2,3, 3,2, 4,4, 5,6, 6,7, 7,5, 7,8,\r\n\t\t2,1, 2,4, 3,0, 3,2, 3,3, 4,7, 5,5, 6,6, 6,8,\r\n\t\t2,3, 3,1, 3,2, 3,4, 3,5, 3,6, 4,7, 5,0, 5,8,\r\n\t\t2,3, 2,6, 3,0, 3,1, 4,4, 4,5, 4,7, 5,2, 5,8,\r\n\t\t2,4, 2,7, 3,3, 3,6, 4,1, 4,2, 4,5, 5,0, 5,8,\r\n\t\t2,6, 3,1, 3,3, 3,5, 3,7, 3,8, 4,0, 5,2, 5,4,\r\n\t\t2,0, 2,1, 3,2, 3,3, 4,4, 4,5, 5,6, 5,7, 4,8,\r\n\t\t1,0, 2,2, 2,-2,\r\n\t\t1,-3, 1,3,\r\n\t\t2,-17, 2,-5, 2,5, 2,17,\r\n\t\t2,-7, 2,2, 2,9, 2,18,\r\n\t\t2,-18, 2,-9, 2,-2, 2,7,\r\n\t\t2,-28, 2,28, 3,-49, 3,-9, 3,9, 4,49, 5,-79, 5,79,\r\n\t\t2,-1, 2,13, 2,26, 3,39, 4,-16, 5,55, 6,-37, 6,76,\r\n\t\t2,-26, 2,-13, 2,1, 3,-39, 4,16, 5,-55, 6,-76, 6,37\r\n\t};\r\n\r\n\tif (p->free_decode == p->first_decode)\r\n\t\tfor (s=source, t=0; t < 18; t++) {\r\n\t\t\tdstart[t] = p->free_decode;\r\n\t\t\ts = dcr_make_decoder_int (p, s, 0);\r\n\t\t}\r\n\tif (tree == 18) {\r\n\t\tif (p->kodak_cbpp == 243)\r\n\t\t\treturn (dcr_getbits(p, 6) << 2) + 2;\t/* most DC50 photos */\r\n\t\telse\r\n\t\t\treturn (dcr_getbits(p, 5) << 3) + 4;\t/* DC40, Fotoman Pixtura */\r\n\t}\r\n\tfor (dindex = dstart[tree]; dindex->branch[0]; )\r\n\t\tdindex = dindex->branch[dcr_getbits(p, 1)];\r\n\treturn dindex->leaf;\r\n}\r\n\r\n#define FORYX for (y=1; y < 3; y++) for (x=col+1; x >= col; x--)\r\n\r\n#define PREDICTOR (c ? (buf[c][y-1][x] + buf[c][y][x+1]) / 2 \\\r\n: (buf[c][y-1][x+1] + 2*buf[c][y-1][x] + buf[c][y][x+1]) / 4)\r\n\r\nvoid DCR_CLASS dcr_kodak_radc_load_raw(DCRAW* p)\r\n{\r\n\tint row, col, tree, nreps, rep, step, i, c, s, r, x, y, val;\r\n\tshort last[3] = { 16,16,16 }, mul[3], buf[3][3][386];\r\n\r\n\tdcr_init_decoder(p);\r\n\tdcr_getbits(p, -1);\r\n\tfor (i=0; i < sizeof(buf)/sizeof(short); i++)\r\n\t\tbuf[0][0][i] = 2048;\r\n\tfor (row=0; row < p->height; row+=4) {\r\n\t\tFORC3 mul[c] = dcr_getbits(p, 6);\r\n\t\tFORC3 {\r\n\t\t\tval = ((0x1000000/last[c] + 0x7ff) >> 12) * mul[c];\r\n\t\t\ts = val > 65564 ? 10:12;\r\n\t\t\tx = ~(-1 << (s-1));\r\n\t\t\tval <<= 12-s;\r\n\t\t\tfor (i=0; i < sizeof(buf[0])/sizeof(short); i++)\r\n\t\t\t\tbuf[c][0][i] = (buf[c][0][i] * val + x) >> s;\r\n\t\t\tlast[c] = mul[c];\r\n\t\t\tfor (r=0; r <= !c; r++) {\r\n\t\t\t\tbuf[c][1][p->width/2] = buf[c][2][p->width/2] = mul[c] << 7;\r\n\t\t\t\tfor (tree=1, col=p->width/2; col > 0; ) {\r\n\t\t\t\t\tif ((tree = dcr_radc_token(p,tree))) {\r\n\t\t\t\t\t\tcol -= 2;\r\n\t\t\t\t\t\tif (tree == 8)\r\n\t\t\t\t\t\t\tFORYX buf[c][y][x] = dcr_radc_token(p,tree+10) * mul[c];\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\tFORYX buf[c][y][x] = dcr_radc_token(p,tree+10) * 16 + PREDICTOR;\r\n\t\t\t\t\t} else\r\n\t\t\t\t\t\tdo {\r\n\t\t\t\t\t\t\tnreps = (col > 2) ? dcr_radc_token(p,9) + 1 : 1;\r\n\t\t\t\t\t\t\tfor (rep=0; rep < 8 && rep < nreps && col > 0; rep++) {\r\n\t\t\t\t\t\t\t\tcol -= 2;\r\n\t\t\t\t\t\t\t\tFORYX buf[c][y][x] = PREDICTOR;\r\n\t\t\t\t\t\t\t\tif (rep & 1) {\r\n\t\t\t\t\t\t\t\t\tstep = dcr_radc_token(p,10) << 4;\r\n\t\t\t\t\t\t\t\t\tFORYX buf[c][y][x] += step;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} while (nreps == 9);\r\n\t\t\t\t}\r\n\t\t\t\tfor (y=0; y < 2; y++)\r\n\t\t\t\t\tfor (x=0; x < p->width/2; x++) {\r\n\t\t\t\t\t\tval = (buf[c][y+1][x] << 4) / mul[c];\r\n\t\t\t\t\t\tif (val < 0) val = 0;\r\n\t\t\t\t\t\tif (c) BAYER(row+y*2+c-1,x*2+2-c) = val;\r\n\t\t\t\t\t\telse   BAYER(row+r*2+y,x*2+y) = val;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tmemcpy (buf[c][0]+!c, buf[c][2], sizeof buf[c][0]-2*!c);\r\n\t\t\t}\r\n\t\t}\r\n\t\tfor (y=row; y < row+4; y++)\r\n\t\t\tfor (x=0; x < p->width; x++)\r\n\t\t\t\tif ((x+y) & 1) {\r\n\t\t\t\t\tr = x ? x-1 : x+1;\r\n\t\t\t\t\ts = x+1 < p->width ? x+1 : x-1;\r\n\t\t\t\t\tval = (BAYER(y,x)-2048)*2 + (BAYER(y,r)+BAYER(y,s))/2;\r\n\t\t\t\t\tif (val < 0) val = 0;\r\n\t\t\t\t\tBAYER(y,x) = val;\r\n\t\t\t\t}\r\n\t}\r\n\tp->maximum = 0xfff;\r\n\tp->use_gamma = 0;\r\n}\r\n\r\n#undef FORYX\r\n#undef PREDICTOR\r\n\r\n#ifdef NO_JPEG\r\nvoid DCR_CLASS dcr_kodak_jpeg_load_raw(DCRAW* p) {}\r\n#else\r\n\r\nMETHODDEF(boolean)\r\nfill_input_buffer (j_decompress_ptr cinfo)\r\n{\r\n\tstatic uchar jpeg_buffer[4096];\r\n\tsize_t nbytes;\r\n\r\n\t//nbytes = dcr_fread(p->obj_, jpeg_buffer, 1, 4096);\r\n\tnbytes = fread (jpeg_buffer, 1, 4096, ifp);\r\n\t_swab (jpeg_buffer, jpeg_buffer, nbytes);\r\n\tcinfo->src->next_input_byte = jpeg_buffer;\r\n\tcinfo->src->bytes_in_buffer = nbytes;\r\n\treturn TRUE;\r\n}\r\n\r\nvoid DCR_CLASS dcr_kodak_jpeg_load_raw(DCRAW* p)\r\n{\r\n\tstruct jpeg_decompress_struct cinfo;\r\n\tstruct jpeg_error_mgr jerr;\r\n\tJSAMPARRAY buf;\r\n\tJSAMPLE (*pixel)[3];\r\n\tint row, col;\r\n\r\n\tcinfo.err = jpeg_std_error (&jerr);\r\n\tjpeg_create_decompress (&cinfo);\r\n\tjpeg_stdio_src (&cinfo);\r\n\tcinfo.src->fill_input_buffer = fill_input_buffer;\r\n\tjpeg_read_header (&cinfo, TRUE);\r\n\tjpeg_start_decompress (&cinfo);\r\n\tif ((cinfo.output_width      != p->width  ) ||\r\n\t\t(cinfo.output_height*2   != p->height ) ||\r\n\t\t(cinfo.output_components != 3      )) {\r\n\t\tfprintf (stderr,_(\"%s: incorrect JPEG dimensions\\n\"), p->ifname);\r\n\t\tjpeg_destroy_decompress (&cinfo);\r\n\t\tlongjmp (p->failure, 3);\r\n\t}\r\n\tbuf = (*cinfo.mem->alloc_sarray)\r\n\t\t((j_common_ptr) &cinfo, JPOOL_IMAGE, p->width*3, 1);\r\n\r\n\twhile (cinfo.output_scanline < cinfo.output_height) {\r\n\t\trow = cinfo.output_scanline * 2;\r\n\t\tjpeg_read_scanlines (&cinfo, buf, 1);\r\n\t\tpixel = (JSAMPLE (*)[3]) buf[0];\r\n\t\tfor (col=0; col < p->width; col+=2) {\r\n\t\t\tBAYER(row+0,col+0) = pixel[col+0][1] << 1;\r\n\t\t\tBAYER(row+1,col+1) = pixel[col+1][1] << 1;\r\n\t\t\tBAYER(row+0,col+1) = pixel[col][0] + pixel[col+1][0];\r\n\t\t\tBAYER(row+1,col+0) = pixel[col][2] + pixel[col+1][2];\r\n\t\t}\r\n\t}\r\n\tjpeg_finish_decompress (&cinfo);\r\n\tjpeg_destroy_decompress (&cinfo);\r\n\tp->maximum = 0xff << 1;\r\n}\r\n#endif\r\n\r\nvoid DCR_CLASS dcr_kodak_dc120_load_raw(DCRAW* p)\r\n{\r\n\tstatic const int mul[4] = { 162, 192, 187,  92 };\r\n\tstatic const int add[4] = {   0, 636, 424, 212 };\r\n\tuchar pixel[848];\r\n\tint row, shift, col;\r\n\r\n\tfor (row=0; row < p->height; row++) {\r\n\t\tif (dcr_fread(p->obj_, pixel, 1, 848) < 848) dcr_derror(p);\r\n\t\tshift = row * mul[row & 3] + add[row & 3];\r\n\t\tfor (col=0; col < p->width; col++)\r\n\t\t\tBAYER(row,col) = (ushort) pixel[(col + shift) % 848];\r\n\t}\r\n\tp->maximum = 0xff;\r\n}\r\n\r\nvoid DCR_CLASS dcr_eight_bit_load_raw(DCRAW* p)\r\n{\r\n\tuchar *pixel;\r\n\tunsigned row, col, val, lblack=0;\r\n\r\n\tpixel = (uchar *) calloc (p->raw_width, sizeof *pixel);\r\n\tdcr_merror (p, pixel, \"eight_bit_load_raw()\");\r\n\tdcr_fseek(p->obj_, p->top_margin*p->raw_width, SEEK_CUR);\r\n\tfor (row=0; row < p->height; row++) {\r\n\t\tif (dcr_fread(p->obj_, pixel, 1, p->raw_width) < p->raw_width) dcr_derror(p);\r\n\t\tfor (col=0; col < p->raw_width; col++) {\r\n\t\t\tval = p->curve[pixel[col]];\r\n\t\t\tif ((unsigned) (col-p->left_margin) < p->width)\r\n\t\t\t\tBAYER(row,col-p->left_margin) = val;\r\n\t\t\telse lblack += val;\r\n\t\t}\r\n\t}\r\n\tfree (pixel);\r\n\tif (p->raw_width > p->width+1)\r\n\t\tp->black = lblack / ((p->raw_width - p->width) * p->height);\r\n\tif (!strncmp(p->model,\"DC2\",3))\r\n\t\tp->black = 0;\r\n\tp->maximum = p->curve[0xff];\r\n}\r\n\r\nvoid DCR_CLASS dcr_kodak_yrgb_load_raw(DCRAW* p)\r\n{\r\n  uchar *pixel;\r\n  int row, col, y, cb, cr, rgb[3], c;\r\n\r\n  pixel = (uchar *) calloc (p->raw_width, 3*sizeof *pixel);\r\n  dcr_merror (p, pixel, \"kodak_yrgb_load_raw()\");\r\n  for (row=0; row < p->height; row++) {\r\n    if (~row & 1)\r\n      if (dcr_fread(p->obj_, pixel, p->raw_width, 3) < 3) dcr_derror(p);\r\n    for (col=0; col < p->raw_width; col++) {\r\n      y  = pixel[p->width*2*(row & 1) + col];\r\n      cb = pixel[p->width + (col & -2)]   - 128;\r\n      cr = pixel[p->width + (col & -2)+1] - 128;\r\n      rgb[1] = y-((cb + cr + 2) >> 2);\r\n      rgb[2] = rgb[1] + cb;\r\n      rgb[0] = rgb[1] + cr;\r\n      FORC3 p->image[row*p->width+col][c] = LIM(rgb[c],0,255);\r\n    }\r\n  }\r\n  free (pixel);\r\n  p->use_gamma = 0;\r\n}\r\n\r\nvoid DCR_CLASS dcr_kodak_262_load_raw(DCRAW* p)\r\n{\r\n\tstatic const uchar kodak_tree[2][26] =\r\n\t{ { 0,1,5,1,1,2,0,0,0,0,0,0,0,0,0,0, 0,1,2,3,4,5,6,7,8,9 },\r\n    { 0,3,1,1,1,1,1,2,0,0,0,0,0,0,0,0, 0,1,2,3,4,5,6,7,8,9 } };\r\n\tstruct dcr_decode *decode[2];\r\n\tuchar *pixel;\r\n\tint *strip, ns, i, row, col, chess, pi=0, pi1, pi2, pred, val;\r\n\r\n\tdcr_init_decoder(p);\r\n\tfor (i=0; i < 2; i++) {\r\n\t\tdecode[i] = p->free_decode;\r\n\t\tdcr_make_decoder (p, kodak_tree[i], 0);\r\n\t}\r\n\tns = (p->raw_height+63) >> 5;\r\n\tpixel = (uchar *) malloc (p->raw_width*32 + ns*4);\r\n\tdcr_merror (p, pixel, \"kodak_262_load_raw()\");\r\n\tstrip = (int *) (pixel + p->raw_width*32);\r\n\tp->order = 0x4d4d;\r\n\tfor (i=0; i < ns; i++)\r\n\t\tstrip[i] = dcr_get4(p);\r\n\tfor (row=0; row < p->raw_height; row++) {\r\n\t\tif ((row & 31) == 0) {\r\n\t\t\tdcr_fseek(p->obj_, strip[row >> 5], SEEK_SET);\r\n\t\t\tdcr_getbits(p, -1);\r\n\t\t\tpi = 0;\r\n\t\t}\r\n\t\tfor (col=0; col < p->raw_width; col++) {\r\n\t\t\tchess = (row + col) & 1;\r\n\t\t\tpi1 = chess ? pi-2           : pi-p->raw_width-1;\r\n\t\t\tpi2 = chess ? pi-2*p->raw_width : pi-p->raw_width+1;\r\n\t\t\tif (col <= chess) pi1 = -1;\r\n\t\t\tif (pi1 < 0) pi1 = pi2;\r\n\t\t\tif (pi2 < 0) pi2 = pi1;\r\n\t\t\tif (pi1 < 0 && col > 1) pi1 = pi2 = pi-2;\r\n\t\t\tpred = (pi1 < 0) ? 0 : (pixel[pi1] + pixel[pi2]) >> 1;\r\n\t\t\tpixel[pi] = val = pred + dcr_ljpeg_diff (p, decode[chess]);\r\n\t\t\tif (val >> 8) dcr_derror(p);\r\n\t\t\tval = p->curve[pixel[pi++]];\r\n\t\t\tif ((unsigned) (col-p->left_margin) < p->width)\r\n\t\t\t\tBAYER(row,col-p->left_margin) = val;\r\n\t\t\telse p->black += val;\r\n\t\t}\r\n\t}\r\n\tfree (pixel);\r\n\tif (p->raw_width > p->width)\r\n\t\tp->black /= (p->raw_width - p->width) * p->height;\r\n}\r\n\r\nint DCR_CLASS dcr_kodak_65000_decode (DCRAW* p, short *out, int bsize)\r\n{\r\n\tuchar c, blen[768];\r\n\tushort raw[6];\r\n\tINT64 bitbuf=0;\r\n\tint save, bits=0, i, j, len, diff;\r\n\r\n\tsave = dcr_ftell(p->obj_);\r\n\tbsize = (bsize + 3) & -4;\r\n\tfor (i=0; i < bsize; i+=2) {\r\n\t\tc = dcr_fgetc(p->obj_);\r\n\t\tif ((blen[i  ] = c & 15) > 12 ||\r\n\t\t\t(blen[i+1] = c >> 4) > 12 ) {\r\n\t\t\tdcr_fseek(p->obj_, save, SEEK_SET);\r\n\t\t\tfor (i=0; i < bsize; i+=8) {\r\n\t\t\t\tdcr_read_shorts (p, raw, 6);\r\n\t\t\t\tout[i  ] = raw[0] >> 12 << 8 | raw[2] >> 12 << 4 | raw[4] >> 12;\r\n\t\t\t\tout[i+1] = raw[1] >> 12 << 8 | raw[3] >> 12 << 4 | raw[5] >> 12;\r\n\t\t\t\tfor (j=0; j < 6; j++)\r\n\t\t\t\t\tout[i+2+j] = raw[j] & 0xfff;\r\n\t\t\t}\r\n\t\t\treturn 1;\r\n\t\t}\r\n\t}\r\n\tif ((bsize & 7) == 4) {\r\n\t\tbitbuf  = dcr_fgetc(p->obj_) << 8;\r\n\t\tbitbuf += dcr_fgetc(p->obj_);\r\n\t\tbits = 16;\r\n\t}\r\n\tfor (i=0; i < bsize; i++) {\r\n\t\tlen = blen[i];\r\n\t\tif (bits < len) {\r\n\t\t\tfor (j=0; j < 32; j+=8)\r\n\t\t\t\tbitbuf += (INT64) dcr_fgetc(p->obj_) << (bits+(j^8));\r\n\t\t\tbits += 32;\r\n\t\t}\r\n\t\tdiff = (int)(bitbuf & (0xffff >> (16-len)));\r\n\t\tbitbuf >>= len;\r\n\t\tbits -= len;\r\n\t\tif ((diff & (1 << (len-1))) == 0)\r\n\t\t\tdiff -= (1 << len) - 1;\r\n\t\tout[i] = diff;\r\n\t}\r\n\treturn 0;\r\n}\r\n\r\nvoid DCR_CLASS dcr_kodak_65000_load_raw(DCRAW* p)\r\n{\r\n\tshort buf[256];\r\n\tint row, col, len, pred[2], ret, i;\r\n\r\n\tfor (row=0; row < p->height; row++)\r\n\t\tfor (col=0; col < p->width; col+=256) {\r\n\t\t\tpred[0] = pred[1] = 0;\r\n\t\t\tlen = MIN (256, p->width-col);\r\n\t\t\tret = dcr_kodak_65000_decode (p, buf, len);\r\n\t\t\tfor (i=0; i < len; i++)\r\n\t\t\t\tif ((BAYER(row,col+i) =\tp->curve[ret ? buf[i] :\r\n\t\t\t\t(pred[i & 1] += buf[i])]) >> 12) dcr_derror(p);\r\n\t\t}\r\n}\r\n\r\nvoid DCR_CLASS dcr_kodak_ycbcr_load_raw(DCRAW* p)\r\n{\r\n\tshort buf[384], *bp;\r\n\tint row, col, len, c, i, j, k, y[2][2], cb, cr, rgb[3];\r\n\tushort *ip;\r\n\r\n\tfor (row=0; row < p->height; row+=2)\r\n\t\tfor (col=0; col < p->width; col+=128) {\r\n\t\t\tlen = MIN (128, p->width-col);\r\n\t\t\tdcr_kodak_65000_decode (p, buf, len*3);\r\n\t\t\ty[0][1] = y[1][1] = cb = cr = 0;\r\n\t\t\tfor (bp=buf, i=0; i < len; i+=2, bp+=2) {\r\n\t\t\t\tcb += bp[4];\r\n\t\t\t\tcr += bp[5];\r\n\t\t\t\trgb[1] = -((cb + cr + 2) >> 2);\r\n\t\t\t\trgb[2] = rgb[1] + cb;\r\n\t\t\t\trgb[0] = rgb[1] + cr;\r\n\t\t\t\tfor (j=0; j < 2; j++)\r\n\t\t\t\t\tfor (k=0; k < 2; k++) {\r\n\t\t\t\t\t\tif ((y[j][k] = y[j][k^1] + *bp++) >> 10) dcr_derror(p);\r\n\t\t\t\t\t\tip = p->image[(row+j)*p->width + col+i+k];\r\n\t\t\t\t\t\tFORC3 ip[c] = p->curve[LIM(y[j][k]+rgb[c], 0, 0xfff)];\r\n\t\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n}\r\n\r\nvoid DCR_CLASS dcr_kodak_rgb_load_raw(DCRAW* p)\r\n{\r\n\tshort buf[768], *bp;\r\n\tint row, col, len, c, i, rgb[3];\r\n\tushort *ip=p->image[0];\r\n\r\n\tfor (row=0; row < p->height; row++)\r\n\t\tfor (col=0; col < p->width; col+=256) {\r\n\t\t\tlen = MIN (256, p->width-col);\r\n\t\t\tdcr_kodak_65000_decode (p, buf, len*3);\r\n\t\t\tmemset (rgb, 0, sizeof rgb);\r\n\t\t\tfor (bp=buf, i=0; i < len; i++, ip+=4)\r\n\t\t\t\tFORC3 if ((ip[c] = rgb[c] += *bp++) >> 12) dcr_derror(p);\r\n\t\t}\r\n}\r\n\r\nvoid DCR_CLASS dcr_kodak_thumb_load_raw(DCRAW* p)\r\n{\r\n\tint row, col;\r\n\tp->colors = p->thumb_misc >> 5;\r\n\tfor (row=0; row < p->height; row++)\r\n\t\tfor (col=0; col < p->width; col++)\r\n\t\t\tdcr_read_shorts (p, p->image[row*p->width+col], p->colors);\r\n\t\tp->maximum = (1 << (p->thumb_misc & 31)) - 1;\r\n}\r\n\r\nvoid DCR_CLASS dcr_sony_decrypt (unsigned *data, int len, int start, int key)\r\n{\r\n\tstatic unsigned pad[128], p;\r\n\r\n\tif (start) {\r\n\t\tfor (p=0; p < 4; p++)\r\n\t\t\tpad[p] = key = key * 48828125 + 1;\r\n\t\tpad[3] = pad[3] << 1 | (pad[0]^pad[2]) >> 31;\r\n\t\tfor (p=4; p < 127; p++)\r\n\t\t\tpad[p] = (pad[p-4]^pad[p-2]) << 1 | (pad[p-3]^pad[p-1]) >> 31;\r\n\t\tfor (p=0; p < 127; p++)\r\n\t\t\tpad[p] = htonl(pad[p]);\r\n\t}\r\n\twhile (len--)\r\n\t\t*data++ ^= pad[p++ & 127] = pad[(p+1) & 127] ^ pad[(p+65) & 127];\r\n}\r\n\r\nvoid DCR_CLASS dcr_sony_load_raw(DCRAW* p)\r\n{\r\n\tuchar head[40];\r\n\tushort *pixel;\r\n\tunsigned i, key, row, col;\r\n\r\n\tdcr_fseek(p->obj_, 200896, SEEK_SET);\r\n\tdcr_fseek(p->obj_, (unsigned) dcr_fgetc(p->obj_)*4 - 1, SEEK_CUR);\r\n\tp->order = 0x4d4d;\r\n\tkey = dcr_get4(p);\r\n\tdcr_fseek(p->obj_, 164600, SEEK_SET);\r\n\tdcr_fread(p->obj_, head, 1, 40);\r\n\tdcr_sony_decrypt ((unsigned int *) head, 10, 1, key);\r\n\tfor (i=26; i-- > 22; )\r\n\t\tkey = key << 8 | head[i];\r\n\tdcr_fseek(p->obj_, p->data_offset, SEEK_SET);\r\n\tpixel = (ushort *) calloc (p->raw_width, sizeof *pixel);\r\n\tdcr_merror (p, pixel, \"sony_load_raw()\");\r\n\tfor (row=0; row < p->height; row++) {\r\n\t\tif (dcr_fread(p->obj_, pixel, 2, p->raw_width) < p->raw_width) dcr_derror(p);\r\n\t\tdcr_sony_decrypt ((unsigned int *) pixel, p->raw_width/2, !row, key);\r\n\t\tfor (col=9; col < p->left_margin; col++)\r\n\t\t\tp->black += ntohs(pixel[col]);\r\n\t\tfor (col=0; col < p->width; col++)\r\n\t\t\tif ((BAYER(row,col) = ntohs(pixel[col+p->left_margin])) >> 14)\r\n\t\t\t\tdcr_derror(p);\r\n\t}\r\n\tfree (pixel);\r\n\tif (p->left_margin > 9)\r\n\t\tp->black /= (p->left_margin-9) * p->height;\r\n\tp->maximum = 0x3ff0;\r\n}\r\n\r\nvoid DCR_CLASS dcr_sony_arw_load_raw(DCRAW* p)\r\n{\r\n\tint col, row, len, diff, sum=0;\r\n\r\n\tdcr_getbits(p, -1);\r\n\tfor (col = p->raw_width; col--; )\r\n\t\tfor (row=0; row < p->raw_height+1; row+=2) {\r\n\t\t\tif (row == p->raw_height) row = 1;\r\n\t\t\tlen = 4 - dcr_getbits(p, 2);\r\n\t\t\tif (len == 3 && dcr_getbits(p, 1)) len = 0;\r\n\t\t\tif (len == 4)\r\n\t\t\t\twhile (len < 17 && !dcr_getbits(p, 1)) len++;\r\n\t\t\t\tdiff = dcr_getbits(p, len);\r\n\t\t\t\tif ((diff & (1 << (len-1))) == 0)\r\n\t\t\t\t\tdiff -= (1 << len) - 1;\r\n\t\t\t\tif ((sum += diff) >> 12) dcr_derror(p);\r\n\t\t\t\tif (row < p->height) BAYER(row,col) = sum;\r\n\t\t}\r\n}\r\n\r\nvoid DCR_CLASS dcr_sony_arw2_load_raw(DCRAW* p)\r\n{\r\n\tuchar *data, *dp;\r\n\tushort pix[16];\r\n\tint row, col, val, max, min, imax, imin, sh, bit, i;\r\n\r\n\tdata = (uchar *) malloc (p->raw_width*p->tiff_bps >> 3);\r\n\tdcr_merror (p, data, \"sony_arw2_load_raw()\");\r\n\tfor (row=0; row < p->height; row++) {\r\n\t\tdcr_fread(p->obj_, data, 1, p->raw_width*p->tiff_bps >> 3);\r\n\t\tif (p->tiff_bps == 8) {\r\n\t\t\tfor (dp=data, col=0; col < p->width-30; dp+=16) {\r\n\t\t\t\tmax = 0x7ff & (val = dcr_sget4(p, dp));\r\n\t\t\t\tmin = 0x7ff & val >> 11;\r\n\t\t\t\timax = 0x0f & val >> 22;\r\n\t\t\t\timin = 0x0f & val >> 26;\r\n\t\t\t\tfor (sh=0; sh < 4 && 0x80 << sh <= max-min; sh++);\r\n\t\t\t\tfor (bit=30, i=0; i < 16; i++)\r\n\t\t\t\t\tif      (i == imax) pix[i] = max;\r\n\t\t\t\t\telse if (i == imin) pix[i] = min;\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tpix[i] = ((dcr_sget2(p, dp+(bit >> 3)) >> (bit & 7) & 0x7f) << sh) + min;\r\n\t\t\t\t\t\tif (pix[i] > 0x7ff) pix[i] = 0x7ff;\r\n\t\t\t\t\t\tbit += 7;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tfor (i=0; i < 16; i++, col+=2)\r\n\t\t\t\t\t\tBAYER(row,col) = p->curve[pix[i] << 1] >> 1;\r\n\t\t\t\t\tcol -= col & 1 ? 1:31;\r\n\t\t\t}\r\n\t\t} else if (p->tiff_bps == 12)\r\n\t\t\tfor (dp=data, col=0; col < p->width; dp+=3, col+=2) {\r\n\t\t\t\tBAYER(row,col)   = ((dp[1] << 8 | dp[0]) & 0xfff) << 1;\r\n\t\t\t\tBAYER(row,col+1) =  (dp[2] << 4 | dp[1] >> 4) << 1;\r\n\t\t\t}\r\n\t}\r\n\tfree (data);\r\n}\r\n\r\n#define HOLE(row) ((holes >> (((row) - p->raw_height) & 7)) & 1)\r\n\r\n/* Kudos to Rich Taylor for figuring out SMaL's compression algorithm. */\r\nvoid DCR_CLASS dcr_smal_decode_segment (DCRAW* p, unsigned seg[2][2], int holes)\r\n{\r\n\tuchar hist[3][13] = {\r\n\t\t{ 7, 7, 0, 0, 63, 55, 47, 39, 31, 23, 15, 7, 0 },\r\n\t\t{ 7, 7, 0, 0, 63, 55, 47, 39, 31, 23, 15, 7, 0 },\r\n\t\t{ 3, 3, 0, 0, 63,     47,     31,     15,    0 } };\r\n\tint low, high=0xff, carry=0, nbits=8;\r\n\tint s, count, bin, next, i, sym[3];\r\n\tuchar diff, pred[]={0,0};\r\n\tushort data=0, range=0;\r\n\tunsigned pix, row, col;\r\n\r\n\tdcr_fseek(p->obj_, seg[0][1]+1, SEEK_SET);\r\n\tdcr_getbits(p, -1);\r\n\tfor (pix=seg[0][0]; pix < seg[1][0]; pix++) {\r\n\t\tfor (s=0; s < 3; s++) {\r\n\t\t\tdata = data << nbits | dcr_getbits(p, nbits);\r\n\t\t\tif (carry < 0)\r\n\t\t\t\tcarry = (nbits += carry+1) < 1 ? nbits-1 : 0;\r\n\t\t\twhile (--nbits >= 0)\r\n\t\t\t\tif ((data >> nbits & 0xff) == 0xff) break;\r\n\t\t\t\tif (nbits > 0)\r\n\t\t\t\t\tdata = ((data & ((1 << (nbits-1)) - 1)) << 1) |\r\n\t\t\t\t\t((data + (((data & (1 << (nbits-1)))) << 1)) & (-1 << nbits));\r\n\t\t\t\tif (nbits >= 0) {\r\n\t\t\t\t\tdata += dcr_getbits(p, 1);\r\n\t\t\t\t\tcarry = nbits - 8;\r\n\t\t\t\t}\r\n\t\t\t\tcount = ((((data-range+1) & 0xffff) << 2) - 1) / (high >> 4);\r\n\t\t\t\tfor (bin=0; hist[s][bin+5] > count; bin++);\r\n\t\t\t\tlow = hist[s][bin+5] * (high >> 4) >> 2;\r\n\t\t\t\tif (bin) high = hist[s][bin+4] * (high >> 4) >> 2;\r\n\t\t\t\thigh -= low;\r\n\t\t\t\tfor (nbits=0; high << nbits < 128; nbits++);\r\n\t\t\t\trange = (range+low) << nbits;\r\n\t\t\t\thigh <<= nbits;\r\n\t\t\t\tnext = hist[s][1];\r\n\t\t\t\tif (++hist[s][2] > hist[s][3]) {\r\n\t\t\t\t\tnext = (next+1) & hist[s][0];\r\n\t\t\t\t\thist[s][3] = (hist[s][next+4] - hist[s][next+5]) >> 2;\r\n\t\t\t\t\thist[s][2] = 1;\r\n\t\t\t\t}\r\n\t\t\t\tif (hist[s][hist[s][1]+4] - hist[s][hist[s][1]+5] > 1) {\r\n\t\t\t\t\tif (bin < hist[s][1])\r\n\t\t\t\t\t\tfor (i=bin; i < hist[s][1]; i++) hist[s][i+5]--;\r\n\t\t\t\t\t\telse if (next <= bin)\r\n\t\t\t\t\t\t\tfor (i=hist[s][1]; i < bin; i++) hist[s][i+5]++;\r\n\t\t\t\t}\r\n\t\t\t\thist[s][1] = next;\r\n\t\t\t\tsym[s] = bin;\r\n\t\t}\r\n\t\tdiff = sym[2] << 5 | sym[1] << 2 | (sym[0] & 3);\r\n\t\tif (sym[0] & 4)\r\n\t\t\tdiff = diff ? -diff : 0x80;\r\n\t\tif (dcr_ftell(p->obj_) + 12 >= (long)seg[1][1])\r\n\t\t\tdiff = 0;\r\n\t\tpred[pix & 1] += diff;\r\n\t\trow = pix / p->raw_width - p->top_margin;\r\n\t\tcol = pix % p->raw_width - p->left_margin;\r\n\t\tif (row < p->height && col < p->width)\r\n\t\t\tBAYER(row,col) = pred[pix & 1];\r\n\t\tif (!(pix & 1) && HOLE(row)) pix += 2;\r\n\t}\r\n\tp->maximum = 0xff;\r\n}\r\n\r\nvoid DCR_CLASS dcr_smal_v6_load_raw(DCRAW* p)\r\n{\r\n\tunsigned seg[2][2];\r\n\r\n\tdcr_fseek(p->obj_, 16, SEEK_SET);\r\n\tseg[0][0] = 0;\r\n\tseg[0][1] = dcr_get2(p);\r\n\tseg[1][0] = p->raw_width * p->raw_height;\r\n\tseg[1][1] = INT_MAX;\r\n\tdcr_smal_decode_segment (p,seg, 0);\r\n\tp->use_gamma = 0;\r\n}\r\n\r\nint DCR_CLASS dcr_median4 (int *p)\r\n{\r\n\tint min, max, sum, i;\r\n\r\n\tmin = max = sum = p[0];\r\n\tfor (i=1; i < 4; i++) {\r\n\t\tsum += p[i];\r\n\t\tif (min > p[i]) min = p[i];\r\n\t\tif (max < p[i]) max = p[i];\r\n\t}\r\n\treturn (sum - min - max) >> 1;\r\n}\r\n\r\nvoid DCR_CLASS dcr_fill_holes (DCRAW* p, int holes)\r\n{\r\n\tint row, col, val[4];\r\n\r\n\tfor (row=2; row < p->height-2; row++) {\r\n\t\tif (!HOLE(row)) continue;\r\n\t\tfor (col=1; col < p->width-1; col+=4) {\r\n\t\t\tval[0] = BAYER(row-1,col-1);\r\n\t\t\tval[1] = BAYER(row-1,col+1);\r\n\t\t\tval[2] = BAYER(row+1,col-1);\r\n\t\t\tval[3] = BAYER(row+1,col+1);\r\n\t\t\tBAYER(row,col) = dcr_median4(val);\r\n\t\t}\r\n\t\tfor (col=2; col < p->width-2; col+=4)\r\n\t\t\tif (HOLE(row-2) || HOLE(row+2))\r\n\t\t\t\tBAYER(row,col) = (BAYER(row,col-2) + BAYER(row,col+2)) >> 1;\r\n\t\t\telse {\r\n\t\t\t\tval[0] = BAYER(row,col-2);\r\n\t\t\t\tval[1] = BAYER(row,col+2);\r\n\t\t\t\tval[2] = BAYER(row-2,col);\r\n\t\t\t\tval[3] = BAYER(row+2,col);\r\n\t\t\t\tBAYER(row,col) = dcr_median4(val);\r\n\t\t\t}\r\n\t}\r\n}\r\n\r\nvoid DCR_CLASS dcr_smal_v9_load_raw(DCRAW* p)\r\n{\r\n\tunsigned seg[256][2], offset, nseg, holes, i;\r\n\r\n\tdcr_fseek(p->obj_, 67, SEEK_SET);\r\n\toffset = dcr_get4(p);\r\n\tnseg = dcr_fgetc(p->obj_);\r\n\tdcr_fseek(p->obj_, offset, SEEK_SET);\r\n\tfor (i=0; i < nseg*2; i++)\r\n\t\tseg[0][i] = dcr_get4(p) + p->data_offset*(i & 1);\r\n\tdcr_fseek(p->obj_, 78, SEEK_SET);\r\n\tholes = dcr_fgetc(p->obj_);\r\n\tdcr_fseek(p->obj_, 88, SEEK_SET);\r\n\tseg[nseg][0] = p->raw_height * p->raw_width;\r\n\tseg[nseg][1] = dcr_get4(p) + p->data_offset;\r\n\tfor (i=0; i < nseg; i++)\r\n\t\tdcr_smal_decode_segment (p,seg+i, holes);\r\n\tif (holes) dcr_fill_holes (p,holes);\r\n}\r\n\r\n/* RESTRICTED code starts here */\r\n#if RESTRICTED\r\n\r\nvoid DCR_CLASS dcr_foveon_decoder (DCRAW* p, unsigned size, unsigned code)\r\n{\r\n\tstatic unsigned huff[1024];\r\n\tstruct dcr_decode *cur;\r\n\tint i, len;\r\n\r\n\tif (!code) {\r\n\t\tfor (i=0; i < (int)size; i++)\r\n\t\t\thuff[i] = dcr_get4(p);\r\n\t\tdcr_init_decoder(p);\r\n\t}\r\n\tcur = p->free_decode++;\r\n\tif (p->free_decode > p->first_decode+2048) {\r\n\t\tfprintf (stderr,_(\"%s: decoder table overflow\\n\"), p->ifname);\r\n\t\tlongjmp (p->failure, 2);\r\n\t}\r\n\tif (code)\r\n\t\tfor (i=0; i < (int)size; i++)\r\n\t\t\tif (huff[i] == code) {\r\n\t\t\t\tcur->leaf = i;\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\tif ((len = code >> 27) > 26) return;\r\n\tcode = (len+1) << 27 | (code & 0x3ffffff) << 1;\r\n\r\n\tcur->branch[0] = p->free_decode;\r\n\tdcr_foveon_decoder (p,size, code);\r\n\tcur->branch[1] = p->free_decode;\r\n\tdcr_foveon_decoder (p,size, code+1);\r\n}\r\n\r\nvoid DCR_CLASS dcr_foveon_thumb (DCRAW* p, FILE *tfp)\r\n{\r\n\tunsigned bwide, row, col, bitbuf=0, bit=1, c, i;\r\n\tchar *buf;\r\n\tstruct dcr_decode *dindex;\r\n\tshort pred[3];\r\n\r\n\tbwide = dcr_get4(p);\r\n\tfprintf (tfp, \"P6\\n%d %d\\n255\\n\", p->thumb_width, p->thumb_height);\r\n\tif (bwide > 0) {\r\n\t\tif (bwide < (unsigned int)(p->thumb_width*3)) return;\r\n\t\tbuf = (char *) malloc (bwide);\r\n\t\tdcr_merror (p, buf, \"foveon_thumb()\");\r\n\t\tfor (row=0; row < p->thumb_height; row++) {\r\n\t\t\tdcr_fread(p->obj_, buf, 1, bwide);\r\n\t\t\tfwrite (buf, 3, p->thumb_width, tfp);\r\n\t\t}\r\n\t\tfree (buf);\r\n\t\treturn;\r\n\t}\r\n\tdcr_foveon_decoder (p,256, 0);\r\n\r\n\tfor (row=0; row < p->thumb_height; row++) {\r\n\t\tmemset (pred, 0, sizeof pred);\r\n\t\tif (!bit) dcr_get4(p);\r\n\t\tfor (bit=col=0; col < p->thumb_width; col++)\r\n\t\t\tFORC3 {\r\n\t\t\tfor (dindex=p->first_decode; dindex->branch[0]; ) {\r\n\t\t\t\tif ((bit = (bit-1) & 31) == 31)\r\n\t\t\t\t\tfor (i=0; i < 4; i++)\r\n\t\t\t\t\t\tbitbuf = (bitbuf << 8) + dcr_fgetc(p->obj_);\r\n\t\t\t\t\tdindex = dindex->branch[bitbuf >> bit & 1];\r\n\t\t\t}\r\n\t\t\tpred[c] += dindex->leaf;\r\n\t\t\tfputc (pred[c], tfp);\r\n\t\t}\r\n\t}\r\n}\r\n\r\nvoid DCR_CLASS dcr_foveon_load_camf(DCRAW* p)\r\n{\r\n\tunsigned key, i, val;\r\n\r\n\tdcr_fseek(p->obj_, p->meta_offset, SEEK_SET);\r\n\tkey = dcr_get4(p);\r\n\tdcr_fread(p->obj_, p->meta_data, 1, p->meta_length);\r\n\tfor (i=0; i < p->meta_length; i++) {\r\n\t\tkey = (key * 1597 + 51749) % 244944;\r\n\t\tval = (unsigned int)(key * (INT64) 301593171 >> 24);\r\n\t\tp->meta_data[i] ^= ((((key << 8) - val) >> 1) + val) >> 17;\r\n\t}\r\n}\r\n\r\nvoid DCR_CLASS dcr_foveon_load_raw(DCRAW* p)\r\n{\r\n\tstruct dcr_decode *dindex;\r\n\tshort diff[1024];\r\n\tunsigned bitbuf=0;\r\n\tint pred[3], fixed, row, col, bit=-1, c, i;\r\n\r\n\tfixed = dcr_get4(p);\r\n\tdcr_read_shorts (p, (ushort *) diff, 1024);\r\n\tif (!fixed) dcr_foveon_decoder (p, 1024, 0);\r\n\r\n\tfor (row=0; row < p->height; row++) {\r\n\t\tmemset (pred, 0, sizeof pred);\r\n\t\tif (!bit && !fixed && atoi(p->model+2) < 14) dcr_get4(p);\r\n\t\tfor (col=bit=0; col < p->width; col++) {\r\n\t\t\tif (fixed) {\r\n\t\t\t\tbitbuf = dcr_get4(p);\r\n\t\t\t\tFORC3 pred[2-c] += diff[bitbuf >> c*10 & 0x3ff];\r\n\t\t\t}\r\n\t\t\telse FORC3 {\r\n\t\t\t\tfor (dindex=p->first_decode; dindex->branch[0]; ) {\r\n\t\t\t\t\tif ((bit = (bit-1) & 31) == 31)\r\n\t\t\t\t\t\tfor (i=0; i < 4; i++)\r\n\t\t\t\t\t\t\tbitbuf = (bitbuf << 8) + dcr_fgetc(p->obj_);\r\n\t\t\t\t\t\tdindex = dindex->branch[bitbuf >> bit & 1];\r\n\t\t\t\t}\r\n\t\t\t\tpred[c] += diff[dindex->leaf];\r\n\t\t\t\tif (pred[c] >> 16 && ~pred[c] >> 16) dcr_derror(p);\r\n\t\t\t}\r\n\t\t\tFORC3 p->image[row*p->width+col][c] = pred[c];\r\n\t\t}\r\n\t}\r\n\tif (p->opt.document_mode)\r\n\t\tfor (i=0; i < p->height*p->width*4; i++)\r\n\t\t\tif ((short) p->image[0][i] < 0) p->image[0][i] = 0;\r\n\t\t\tdcr_foveon_load_camf(p);\r\n}\r\n\r\nconst char * DCR_CLASS dcr_foveon_camf_param (DCRAW* p, const char *block, const char *param)\r\n{\r\n\tunsigned idx, num;\r\n\tchar *pos, *cp, *dp;\r\n\r\n\tfor (idx=0; idx < p->meta_length; idx += dcr_sget4(p, pos+8)) {\r\n\t\tpos = p->meta_data + idx;\r\n\t\tif (strncmp (pos, \"CMb\", 3)) break;\r\n\t\tif (pos[3] != 'P') continue;\r\n\t\tif (strcmp (block, pos+dcr_sget4(p, pos+12))) continue;\r\n\t\tcp = pos + dcr_sget4(p, pos+16);\r\n\t\tnum = dcr_sget4(p, cp);\r\n\t\tdp = pos + dcr_sget4(p, cp+4);\r\n\t\twhile (num--) {\r\n\t\t\tcp += 8;\r\n\t\t\tif (!strcmp (param, dp+dcr_sget4(p, cp)))\r\n\t\t\t\treturn dp+dcr_sget4(p, cp+4);\r\n\t\t}\r\n\t}\r\n\treturn 0;\r\n}\r\n\r\nvoid * DCR_CLASS dcr_foveon_camf_matrix (DCRAW* p, unsigned dim[3], const char *name)\r\n{\r\n\tunsigned i, idx, type, ndim, size, *mat;\r\n\tchar *pos, *cp, *dp;\r\n\tdouble dsize;\r\n\r\n\tfor (idx=0; idx < p->meta_length; idx += dcr_sget4(p, pos+8)) {\r\n\t\tpos = p->meta_data + idx;\r\n\t\tif (strncmp (pos, \"CMb\", 3)) break;\r\n\t\tif (pos[3] != 'M') continue;\r\n\t\tif (strcmp (name, pos+dcr_sget4(p, pos+12))) continue;\r\n\t\tdim[0] = dim[1] = dim[2] = 1;\r\n\t\tcp = pos + dcr_sget4(p, pos+16);\r\n\t\ttype = dcr_sget4(p, cp);\r\n\t\tif ((ndim = dcr_sget4(p, cp+4)) > 3) break;\r\n\t\tdp = pos + dcr_sget4(p, cp+8);\r\n\t\tfor (i=ndim; i--; ) {\r\n\t\t\tcp += 12;\r\n\t\t\tdim[i] = dcr_sget4(p, cp);\r\n\t\t}\r\n\t\tif ((dsize = (double) dim[0]*dim[1]*dim[2]) > p->meta_length/4) break;\r\n\t\tmat = (unsigned *) malloc ((size = (unsigned int)dsize) * 4);\r\n\t\tdcr_merror (p, mat, \"dcr_foveon_camf_matrix()\");\r\n\t\tfor (i=0; i < size; i++)\r\n\t\t\tif (type && type != 6)\r\n\t\t\t\tmat[i] = dcr_sget4(p, dp + i*4);\r\n\t\t\telse\r\n\t\t\t\tmat[i] = dcr_sget4(p, dp + i*2) & 0xffff;\r\n\t\t\treturn mat;\r\n\t}\r\n\tfprintf (stderr,_(\"%s: \\\"%s\\\" matrix not found!\\n\"), p->ifname, name);\r\n\treturn 0;\r\n}\r\n\r\nint DCR_CLASS dcr_foveon_fixed (DCRAW* p, void *ptr, int size, const char *name)\r\n{\r\n\tvoid *dp;\r\n\tunsigned dim[3];\r\n\r\n\tdp = dcr_foveon_camf_matrix (p,dim, name);\r\n\tif (!dp) return 0;\r\n\tmemcpy (ptr, dp, size*4);\r\n\tfree (dp);\r\n\treturn 1;\r\n}\r\n\r\nfloat DCR_CLASS dcr_foveon_avg (short *pix, int range[2], float cfilt)\r\n{\r\n\tint i;\r\n\tfloat val, min=FLT_MAX, max=-FLT_MAX, sum=0;\r\n\r\n\tfor (i=range[0]; i <= range[1]; i++) {\r\n\t\tsum += val = pix[i*4] + (pix[i*4]-pix[(i-1)*4]) * cfilt;\r\n\t\tif (min > val) min = val;\r\n\t\tif (max < val) max = val;\r\n\t}\r\n\tif (range[1] - range[0] == 1) return sum/2;\r\n\treturn (sum - min - max) / (range[1] - range[0] - 1);\r\n}\r\n\r\nshort * DCR_CLASS dcr_foveon_make_curve (DCRAW* p, double max, double mul, double filt)\r\n{\r\n\tshort *curve;\r\n\tunsigned i, size;\r\n\tdouble x;\r\n\r\n\tif (!filt) filt = 0.8;\r\n\tsize = (unsigned int)(4*M_PI*max / filt);\r\n\tif (size == UINT_MAX) size--;\r\n\tcurve = (short *) calloc (size+1, sizeof *curve);\r\n\tdcr_merror (p, p->curve, \"foveon_make_curve()\");\r\n\tp->curve[0] = size;\r\n\tfor (i=0; i < size; i++) {\r\n\t\tx = i*filt/max/4;\r\n\t\tp->curve[i+1] = (short)((cos(x)+1)/2 * tanh(i*filt/mul) * mul + 0.5);\r\n\t}\r\n\treturn curve;\r\n}\r\n\r\nvoid DCR_CLASS dcr_foveon_make_curves\r\n(DCRAW* p, short **curvep, float dq[3], float div[3], float filt)\r\n{\r\n\tdouble mul[3], max=0;\r\n\tint c;\r\n\r\n\tFORC3 mul[c] = dq[c]/div[c];\r\n\tFORC3 if (max < mul[c]) max = mul[c];\r\n\tFORC3 curvep[c] = dcr_foveon_make_curve (p,max, mul[c], filt);\r\n}\r\n\r\nint DCR_CLASS dcr_foveon_apply_curve (short *curve, int i)\r\n{\r\n\tif (abs(i) >= curve[0]) return 0;\r\n\treturn i < 0 ? -curve[1-i] : curve[1+i];\r\n}\r\n\r\n#define image4 ((short (*)[4]) p->image)\r\n\r\nvoid DCR_CLASS dcr_foveon_interpolate(DCRAW* p)\r\n{\r\n\tstatic const short hood[] = { -1,-1, -1,0, -1,1, 0,-1, 0,1, 1,-1, 1,0, 1,1 };\r\n\tshort *pix, prev[3], *curve[8], (*shrink)[3];\r\n\tfloat cfilt=0, ddft[3][3][2], ppm[3][3][3];\r\n\tfloat cam_xyz[3][3], correct[3][3], last[3][3], trans[3][3];\r\n\tfloat chroma_dq[3], color_dq[3], diag[3][3], div[3];\r\n\tfloat (*black)[3], (*sgain)[3], (*sgrow)[3];\r\n\tfloat fsum[3], val, frow, num;\r\n\tint row, col, c, i, j, diff, sgx, irow, sum, min, max, limit;\r\n\tint dscr[2][2], dstb[4], (*smrow[7])[3], total[4], ipix[3];\r\n\tint work[3][3], smlast, smred, smred_p=0, dev[3];\r\n\tint satlev[3], keep[4], active[4];\r\n\tunsigned dim[3], *badpix;\r\n\tdouble dsum=0, trsum[3];\r\n\tchar str[128];\r\n\tconst char* cp;\r\n\r\n\tif (p->opt.verbose)\r\n\t\tfprintf (stderr,_(\"Foveon interpolation...\\n\"));\r\n\r\n\tdcr_foveon_fixed (p, dscr, 4, \"DarkShieldColRange\");\r\n\tdcr_foveon_fixed (p, ppm[0][0], 27, \"PostPolyMatrix\");\r\n\tdcr_foveon_fixed (p, satlev, 3, \"SaturationLevel\");\r\n\tdcr_foveon_fixed (p, keep, 4, \"KeepImageArea\");\r\n\tdcr_foveon_fixed (p, active, 4, \"ActiveImageArea\");\r\n\tdcr_foveon_fixed (p, chroma_dq, 3, \"ChromaDQ\");\r\n\tdcr_foveon_fixed (p, color_dq, 3,\r\n\t\tdcr_foveon_camf_param (p, \"IncludeBlocks\", \"ColorDQ\") ?\r\n\t\t\"ColorDQ\" : \"ColorDQCamRGB\");\r\n\tif (dcr_foveon_camf_param (p, \"IncludeBlocks\", \"ColumnFilter\"))\r\n\t\tdcr_foveon_fixed (p, &cfilt, 1, \"ColumnFilter\");\r\n\r\n\tmemset (ddft, 0, sizeof ddft);\r\n\tif (!dcr_foveon_camf_param (p, \"IncludeBlocks\", \"DarkDrift\")\r\n\t\t|| !dcr_foveon_fixed (p, ddft[1][0], 12, \"DarkDrift\"))\r\n\t\tfor (i=0; i < 2; i++) {\r\n\t\t\tdcr_foveon_fixed (p, dstb, 4, i ? \"DarkShieldBottom\":\"DarkShieldTop\");\r\n\t\t\tfor (row = dstb[1]; row <= dstb[3]; row++)\r\n\t\t\t\tfor (col = dstb[0]; col <= dstb[2]; col++)\r\n\t\t\t\t\tFORC3 ddft[i+1][c][1] += (short) image4[row*p->width+col][c];\r\n\t\t\t\tFORC3 ddft[i+1][c][1] /= (dstb[3]-dstb[1]+1) * (dstb[2]-dstb[0]+1);\r\n\t\t}\r\n\r\n\tif (!(cp = dcr_foveon_camf_param (p, \"WhiteBalanceIlluminants\", p->model2)))\r\n\t{ fprintf (stderr,_(\"%s: Invalid p->white balance \\\"%s\\\"\\n\"), p->ifname, p->model2);\r\n\treturn; }\r\n\tdcr_foveon_fixed (p, cam_xyz, 9, cp);\r\n\tdcr_foveon_fixed (p, correct, 9,\r\n\t\tdcr_foveon_camf_param (p, \"WhiteBalanceCorrections\", p->model2));\r\n\tmemset (last, 0, sizeof last);\r\n\tfor (i=0; i < 3; i++)\r\n\t\tfor (j=0; j < 3; j++)\r\n\t\t\tFORC3 last[i][j] += correct[i][c] * cam_xyz[c][j];\r\n\r\n#define LAST(x,y) last[(i+x)%3][(c+y)%3]\r\n\tfor (i=0; i < 3; i++)\r\n\t\tFORC3 diag[c][i] = LAST(1,1)*LAST(2,2) - LAST(1,2)*LAST(2,1);\r\n#undef LAST\r\n\tFORC3 div[c] = diag[c][0]*0.3127f + diag[c][1]*0.329f + diag[c][2]*0.3583f;\r\n\tsprintf (str, \"%sRGBNeutral\", p->model2);\r\n\tif (dcr_foveon_camf_param (p, \"IncludeBlocks\", str))\r\n\t\tdcr_foveon_fixed (p, div, 3, str);\r\n\tnum = 0;\r\n\tFORC3 if (num < div[c]) num = div[c];\r\n\tFORC3 div[c] /= num;\r\n\r\n\tmemset (trans, 0, sizeof trans);\r\n\tfor (i=0; i < 3; i++)\r\n\t\tfor (j=0; j < 3; j++)\r\n\t\t\tFORC3 trans[i][j] += p->rgb_cam[i][c] * last[c][j] * div[j];\r\n\tFORC3 trsum[c] = trans[c][0] + trans[c][1] + trans[c][2];\r\n\tdsum = (6*trsum[0] + 11*trsum[1] + 3*trsum[2]) / 20;\r\n\tfor (i=0; i < 3; i++)\r\n\t\tFORC3 last[i][c] = (float)(trans[i][c] * dsum / trsum[i]);\r\n\tmemset (trans, 0, sizeof trans);\r\n\tfor (i=0; i < 3; i++)\r\n\t\tfor (j=0; j < 3; j++)\r\n\t\t\tFORC3 trans[i][j] += (i==c ? 32 : -1) * last[c][j] / 30;\r\n\r\n\tdcr_foveon_make_curves (p, curve, color_dq, div, cfilt);\r\n\tFORC3 chroma_dq[c] /= 3;\r\n\tdcr_foveon_make_curves (p, curve+3, chroma_dq, div, cfilt);\r\n\tFORC3 dsum += chroma_dq[c] / div[c];\r\n\tcurve[6] = dcr_foveon_make_curve (p, dsum, dsum, cfilt);\r\n\tcurve[7] = dcr_foveon_make_curve (p, dsum*2, dsum*2, cfilt);\r\n\r\n\tsgain = (float (*)[3]) dcr_foveon_camf_matrix (p, dim, \"SpatialGain\");\r\n\tif (!sgain) return;\r\n\tsgrow = (float (*)[3]) calloc (dim[1], sizeof *sgrow);\r\n\tsgx = (p->width + dim[1]-2) / (dim[1]-1);\r\n\r\n\tblack = (float (*)[3]) calloc (p->height, sizeof *black);\r\n\tfor (row=0; row < p->height; row++) {\r\n\t\tfor (i=0; i < 6; i++)\r\n\t\t\tddft[0][0][i] = (float)(ddft[1][0][i] +\r\n\t\t\trow / (p->height-1.0) * (ddft[2][0][i] - ddft[1][0][i]));\r\n\t\tFORC3 black[row][c] =\r\n\t\t\t( dcr_foveon_avg (p->image[row*p->width]+c, dscr[0], cfilt) +\r\n\t\t\tdcr_foveon_avg (p->image[row*p->width]+c, dscr[1], cfilt) * 3\r\n\t\t\t- ddft[0][c][0] ) / 4 - ddft[0][c][1];\r\n\t}\r\n\tmemcpy (black, black+8, sizeof *black*8);\r\n\tmemcpy (black+p->height-11, black+p->height-22, 11*sizeof *black);\r\n\tmemcpy (last, black, sizeof last);\r\n\r\n\tfor (row=1; row < p->height-1; row++) {\r\n\t\tFORC3 if (last[1][c] > last[0][c]) {\r\n\t\t\tif (last[1][c] > last[2][c])\r\n\t\t\t\tblack[row][c] = (last[0][c] > last[2][c]) ? last[0][c]:last[2][c];\r\n\t\t} else\r\n\t\t\tif (last[1][c] < last[2][c])\r\n\t\t\t\tblack[row][c] = (last[0][c] < last[2][c]) ? last[0][c]:last[2][c];\r\n\t\t\tmemmove (last, last+1, 2*sizeof last[0]);\r\n\t\t\tmemcpy (last[2], black[row+1], sizeof last[2]);\r\n\t}\r\n\tFORC3 black[row][c] = (last[0][c] + last[1][c])/2;\r\n\tFORC3 black[0][c] = (black[1][c] + black[3][c])/2;\r\n\r\n\tval = (float)(1 - exp(-1/24.0));\r\n\tmemcpy (fsum, black, sizeof fsum);\r\n\tfor (row=1; row < p->height; row++)\r\n\t\tFORC3 fsum[c] += black[row][c] =\r\n\t\t(black[row][c] - black[row-1][c])*val + black[row-1][c];\r\n\tmemcpy (last[0], black[p->height-1], sizeof last[0]);\r\n\tFORC3 fsum[c] /= p->height;\r\n\tfor (row = p->height; row--; )\r\n\t\tFORC3 last[0][c] = black[row][c] =\r\n\t\t(black[row][c] - fsum[c] - last[0][c])*val + last[0][c];\r\n\r\n\tmemset (total, 0, sizeof total);\r\n\tfor (row=2; row < p->height; row+=4)\r\n\t\tfor (col=2; col < p->width; col+=4) {\r\n\t\t\tFORC3 total[c] += (short) p->image[row*p->width+col][c];\r\n\t\t\ttotal[3]++;\r\n\t\t}\r\n\tfor (row=0; row < p->height; row++)\r\n\t\tFORC3 black[row][c] += fsum[c]/2 + total[c]/(total[3]*100.0f);\r\n\r\n\tfor (row=0; row < p->height; row++) {\r\n\t\tfor (i=0; i < 6; i++)\r\n\t\t\tddft[0][0][i] = (float)(ddft[1][0][i] +\r\n\t\t\trow / (p->height-1.0) * (ddft[2][0][i] - ddft[1][0][i]));\r\n\t\tpix = p->image[row*p->width];\r\n\t\tmemcpy (prev, pix, sizeof prev);\r\n\t\tfrow = (float)(row / (p->height-1.0) * (dim[2]-1));\r\n\t\tif ((irow = (int)frow) == (int)(dim[2]-1)) irow--;\r\n\t\tfrow -= irow;\r\n\t\tfor (i=0; i < (int)dim[1]; i++)\r\n\t\t\tFORC3 sgrow[i][c] = sgain[ irow   *dim[1]+i][c] * (1-frow) +\r\n\t\t\tsgain[(irow+1)*dim[1]+i][c] *    frow;\r\n\t\tfor (col=0; col < p->width; col++) {\r\n\t\t\tFORC3 {\r\n\t\t\t\tdiff = pix[c] - prev[c];\r\n\t\t\t\tprev[c] = pix[c];\r\n\t\t\t\tipix[c] = (int)( pix[c] + floor ((diff + (diff*diff >> 14)) * cfilt\r\n\t\t\t\t\t- ddft[0][c][1] - ddft[0][c][0] * ((float) col/p->width - 0.5)\r\n\t\t\t\t\t- black[row][c] ));\r\n\t\t\t}\r\n\t\t\tFORC3 {\r\n\t\t\t\twork[0][c] = ipix[c] * ipix[c] >> 14;\r\n\t\t\t\twork[2][c] = ipix[c] * work[0][c] >> 14;\r\n\t\t\t\twork[1][2-c] = ipix[(c+1) % 3] * ipix[(c+2) % 3] >> 14;\r\n\t\t\t}\r\n\t\t\tFORC3 {\r\n\t\t\t\tfor (val=0, i=0; i < 3; i++)\r\n\t\t\t\t\tfor (  j=0; j < 3; j++)\r\n\t\t\t\t\t\tval += ppm[c][i][j] * work[i][j];\r\n\t\t\t\t\tipix[c] = (int)(floor ((ipix[c] + floor(val)) *\r\n\t\t\t\t\t\t( sgrow[col/sgx  ][c] * (sgx - col%sgx) +\r\n\t\t\t\t\t\tsgrow[col/sgx+1][c] * (col%sgx) ) / sgx / div[c]));\r\n\t\t\t\t\tif (ipix[c] > 32000) ipix[c] = 32000;\r\n\t\t\t\t\tpix[c] = ipix[c];\r\n\t\t\t}\r\n\t\t\tpix += 4;\r\n\t\t}\r\n\t}\r\n\tfree (black);\r\n\tfree (sgrow);\r\n\tfree (sgain);\r\n\r\n\tif ((badpix = (unsigned int *) dcr_foveon_camf_matrix (p, dim, \"BadPixels\"))) {\r\n\t\tfor (i=0; i < (int)dim[0]; i++) {\r\n\t\t\tcol = (badpix[i] >> 8 & 0xfff) - keep[0];\r\n\t\t\trow = (badpix[i] >> 20       ) - keep[1];\r\n\t\t\tif ((int)(row-1) > p->height-3 || (int)(col-1) > p->width-3)\r\n\t\t\t\tcontinue;\r\n\t\t\tmemset (fsum, 0, sizeof fsum);\r\n\t\t\tfor (sum=j=0; j < 8; j++)\r\n\t\t\t\tif (badpix[i] & (1 << j)) {\r\n\t\t\t\t\tFORC3 fsum[c] += (short)\r\n\t\t\t\t\t\tp->image[(row+hood[j*2])*p->width+col+hood[j*2+1]][c];\r\n\t\t\t\t\tsum++;\r\n\t\t\t\t}\r\n\t\t\t\tif (sum) FORC3 p->image[row*p->width+col][c] = (unsigned short)(fsum[c]/sum);\r\n\t\t}\r\n\t\tfree (badpix);\r\n\t}\r\n\r\n\t/* Array for 5x5 Gaussian averaging of red values */\r\n\tsmrow[6] = (int (*)[3]) calloc (p->width*5, sizeof **smrow);\r\n\tdcr_merror (p, smrow[6], \"foveon_interpolate()\");\r\n\tfor (i=0; i < 5; i++)\r\n\t\tsmrow[i] = smrow[6] + i*p->width;\r\n\r\n\t/* Sharpen the reds against these Gaussian averages */\r\n\tfor (smlast=-1, row=2; row < p->height-2; row++) {\r\n\t\twhile (smlast < row+2) {\r\n\t\t\tfor (i=0; i < 6; i++)\r\n\t\t\t\tsmrow[(i+5) % 6] = smrow[i];\r\n\t\t\tpix = p->image[++smlast*p->width+2];\r\n\t\t\tfor (col=2; col < p->width-2; col++) {\r\n\t\t\t\tsmrow[4][col][0] =\r\n\t\t\t\t\t(pix[0]*6 + (pix[-4]+pix[4])*4 + pix[-8]+pix[8] + 8) >> 4;\r\n\t\t\t\tpix += 4;\r\n\t\t\t}\r\n\t\t}\r\n\t\tpix = p->image[row*p->width+2];\r\n\t\tfor (col=2; col < p->width-2; col++) {\r\n\t\t\tsmred = ( 6 *  smrow[2][col][0]\r\n\t\t\t\t+ 4 * (smrow[1][col][0] + smrow[3][col][0])\r\n\t\t\t\t+      smrow[0][col][0] + smrow[4][col][0] + 8 ) >> 4;\r\n\t\t\tif (col == 2)\r\n\t\t\t\tsmred_p = smred;\r\n\t\t\ti = pix[0] + ((pix[0] - ((smred*7 + smred_p) >> 3)) >> 3);\r\n\t\t\tif (i > 32000) i = 32000;\r\n\t\t\tpix[0] = i;\r\n\t\t\tsmred_p = smred;\r\n\t\t\tpix += 4;\r\n\t\t}\r\n\t}\r\n\r\n\t/* Adjust the brighter pixels for better linearity */\r\n\tmin = 0xffff;\r\n\tFORC3 {\r\n\t\ti = (int)(satlev[c] / div[c]);\r\n\t\tif (min > i) min = i;\r\n\t}\r\n\tlimit = min * 9 >> 4;\r\n\tfor (pix=p->image[0]; pix < p->image[p->height*p->width]; pix+=4) {\r\n\t\tif (pix[0] <= limit || pix[1] <= limit || pix[2] <= limit)\r\n\t\t\tcontinue;\r\n\t\tmin = max = pix[0];\r\n\t\tfor (c=1; c < 3; c++) {\r\n\t\t\tif (min > pix[c]) min = pix[c];\r\n\t\t\tif (max < pix[c]) max = pix[c];\r\n\t\t}\r\n\t\tif (min >= limit*2) {\r\n\t\t\tpix[0] = pix[1] = pix[2] = max;\r\n\t\t} else {\r\n\t\t\ti = 0x4000 - ((min - limit) << 14) / limit;\r\n\t\t\ti = 0x4000 - (i*i >> 14);\r\n\t\t\ti = i*i >> 14;\r\n\t\t\tFORC3 pix[c] += (max - pix[c]) * i >> 14;\r\n\t\t}\r\n\t}\r\n\t/*\r\n\tBecause photons that miss one detector often hit another,\r\n\tthe sum R+G+B is much less noisy than the individual p->colors.\r\n\tSo smooth the hues without smoothing the total.\r\n\t*/\r\n\tfor (smlast=-1, row=2; row < p->height-2; row++) {\r\n\t\twhile (smlast < row+2) {\r\n\t\t\tfor (i=0; i < 6; i++)\r\n\t\t\t\tsmrow[(i+5) % 6] = smrow[i];\r\n\t\t\tpix = p->image[++smlast*p->width+2];\r\n\t\t\tfor (col=2; col < p->width-2; col++) {\r\n\t\t\t\tFORC3 smrow[4][col][c] = (pix[c-4]+2*pix[c]+pix[c+4]+2) >> 2;\r\n\t\t\t\tpix += 4;\r\n\t\t\t}\r\n\t\t}\r\n\t\tpix = p->image[row*p->width+2];\r\n\t\tfor (col=2; col < p->width-2; col++) {\r\n\t\t\tFORC3 dev[c] = -dcr_foveon_apply_curve (curve[7], pix[c] -\r\n\t\t\t\t((smrow[1][col][c] + 2*smrow[2][col][c] + smrow[3][col][c]) >> 2));\r\n\t\t\tsum = (dev[0] + dev[1] + dev[2]) >> 3;\r\n\t\t\tFORC3 pix[c] += dev[c] - sum;\r\n\t\t\tpix += 4;\r\n\t\t}\r\n\t}\r\n\tfor (smlast=-1, row=2; row < p->height-2; row++) {\r\n\t\twhile (smlast < row+2) {\r\n\t\t\tfor (i=0; i < 6; i++)\r\n\t\t\t\tsmrow[(i+5) % 6] = smrow[i];\r\n\t\t\tpix = p->image[++smlast*p->width+2];\r\n\t\t\tfor (col=2; col < p->width-2; col++) {\r\n\t\t\t\tFORC3 smrow[4][col][c] =\r\n\t\t\t\t\t(pix[c-8]+pix[c-4]+pix[c]+pix[c+4]+pix[c+8]+2) >> 2;\r\n\t\t\t\tpix += 4;\r\n\t\t\t}\r\n\t\t}\r\n\t\tpix = p->image[row*p->width+2];\r\n\t\tfor (col=2; col < p->width-2; col++) {\r\n\t\t\tfor (total[3]=375, sum=60, c=0; c < 3; c++) {\r\n\t\t\t\tfor (total[c]=i=0; i < 5; i++)\r\n\t\t\t\t\ttotal[c] += smrow[i][col][c];\r\n\t\t\t\ttotal[3] += total[c];\r\n\t\t\t\tsum += pix[c];\r\n\t\t\t}\r\n\t\t\tif (sum < 0) sum = 0;\r\n\t\t\tj = total[3] > 375 ? (sum << 16) / total[3] : sum * 174;\r\n\t\t\tFORC3 pix[c] += dcr_foveon_apply_curve (curve[6],\r\n\t\t\t\t((j*total[c] + 0x8000) >> 16) - pix[c]);\r\n\t\t\tpix += 4;\r\n\t\t}\r\n\t}\r\n\r\n\t/* Transform the image to a different colorspace */\r\n\tfor (pix=p->image[0]; pix < p->image[p->height*p->width]; pix+=4) {\r\n\t\tFORC3 pix[c] -= dcr_foveon_apply_curve (curve[c], pix[c]);\r\n\t\tsum = (pix[0]+pix[1]+pix[1]+pix[2]) >> 2;\r\n\t\tFORC3 pix[c] -= dcr_foveon_apply_curve (curve[c], pix[c]-sum);\r\n\t\tFORC3 {\r\n\t\t\tfor (dsum=i=0; i < 3; i++)\r\n\t\t\t\tdsum += trans[c][i] * pix[i];\r\n\t\t\tif (dsum < 0)  dsum = 0;\r\n\t\t\tif (dsum > 24000) dsum = 24000;\r\n\t\t\tipix[c] = (int)(dsum + 0.5);\r\n\t\t}\r\n\t\tFORC3 pix[c] = ipix[c];\r\n\t}\r\n\r\n\t/* Smooth the image bottom-to-top and save at 1/4 scale */\r\n\tshrink = (short (*)[3]) calloc ((p->width/4) * (p->height/4), sizeof *shrink);\r\n\tdcr_merror (p, shrink, \"foveon_interpolate()\");\r\n\tfor (row = p->height/4; row--; )\r\n\t\tfor (col=0; col < p->width/4; col++) {\r\n\t\t\tipix[0] = ipix[1] = ipix[2] = 0;\r\n\t\t\tfor (i=0; i < 4; i++)\r\n\t\t\t\tfor (j=0; j < 4; j++)\r\n\t\t\t\t\tFORC3 ipix[c] += p->image[(row*4+i)*p->width+col*4+j][c];\r\n\t\t\t\tFORC3\r\n\t\t\t\t\tif (row+2 > p->height/4)\r\n\t\t\t\t\t\tshrink[row*(p->width/4)+col][c] = ipix[c] >> 4;\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tshrink[row*(p->width/4)+col][c] =\r\n\t\t\t\t\t\t(shrink[(row+1)*(p->width/4)+col][c]*1840 + ipix[c]*141 + 2048) >> 12;\r\n\t\t}\r\n\t/* From the 1/4-scale image, smooth right-to-left */\r\n\tfor (row=0; row < (p->height & ~3); row++) {\r\n\t\tipix[0] = ipix[1] = ipix[2] = 0;\r\n\t\tif ((row & 3) == 0)\r\n\t\t\tfor (col = p->width & ~3 ; col--; )\r\n\t\t\t\tFORC3 smrow[0][col][c] = ipix[c] =\r\n\t\t\t\t(shrink[(row/4)*(p->width/4)+col/4][c]*1485 + ipix[c]*6707 + 4096) >> 13;\r\n\r\n\t\t/* Then smooth left-to-right */\r\n\t\tipix[0] = ipix[1] = ipix[2] = 0;\r\n\t\tfor (col=0; col < (p->width & ~3); col++)\r\n\t\t\tFORC3 smrow[1][col][c] = ipix[c] =\r\n\t\t\t(smrow[0][col][c]*1485 + ipix[c]*6707 + 4096) >> 13;\r\n\r\n\t\t/* Smooth top-to-bottom */\r\n\t\tif (row == 0)\r\n\t\t\tmemcpy (smrow[2], smrow[1], sizeof **smrow * p->width);\r\n\t\telse\r\n\t\t\tfor (col=0; col < (p->width & ~3); col++)\r\n\t\t\t\tFORC3 smrow[2][col][c] =\r\n\t\t\t\t(smrow[2][col][c]*6707 + smrow[1][col][c]*1485 + 4096) >> 13;\r\n\r\n\t\t\t/* Adjust the chroma toward the smooth values */\r\n\t\t\tfor (col=0; col < (p->width & ~3); col++) {\r\n\t\t\t\tfor (i=j=30, c=0; c < 3; c++) {\r\n\t\t\t\t\ti += smrow[2][col][c];\r\n\t\t\t\t\tj += p->image[row*p->width+col][c];\r\n\t\t\t\t}\r\n\t\t\t\tj = (j << 16) / i;\r\n\t\t\t\tfor (sum=c=0; c < 3; c++) {\r\n\t\t\t\t\tipix[c] = dcr_foveon_apply_curve (curve[c+3],\r\n\t\t\t\t\t\t((smrow[2][col][c] * j + 0x8000) >> 16) - p->image[row*p->width+col][c]);\r\n\t\t\t\t\tsum += ipix[c];\r\n\t\t\t\t}\r\n\t\t\t\tsum >>= 3;\r\n\t\t\t\tFORC3 {\r\n\t\t\t\t\ti = p->image[row*p->width+col][c] + ipix[c] - sum;\r\n\t\t\t\t\tif (i < 0) i = 0;\r\n\t\t\t\t\tp->image[row*p->width+col][c] = i;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t}\r\n\tfree (shrink);\r\n\tfree (smrow[6]);\r\n\tfor (i=0; i < 8; i++)\r\n\t\tfree (curve[i]);\r\n\r\n\t/* Trim off the black border */\r\n\tactive[1] -= keep[1];\r\n\tactive[3] -= 2;\r\n\ti = active[2] - active[0];\r\n\tfor (row=0; row < active[3]-active[1]; row++)\r\n\t\tmemcpy (p->image[row*i], p->image[(row+active[1])*p->width+active[0]],\r\n\t\ti * sizeof *p->image);\r\n\tp->width = i;\r\n\tp->height = row;\r\n}\r\n//#undef image\r\n#endif //RESTRICTED\r\n/* RESTRICTED code ends here */\r\n\r\n/*\r\nSeach from the current directory up to the root looking for\r\na \".badpixels\" file, and fix those pixels now.\r\n*/\r\nvoid DCR_CLASS dcr_bad_pixels(DCRAW* p, char *fname)\r\n{\r\n\tFILE *fp=0;\r\n\tchar *cp, line[128];\r\n\tint len, time, row, col, r, c, rad, tot, n, fixed=0;\r\n\r\n\tif (!p->filters) return;\r\n\tif (fname)\r\n\t\tfp = fopen (fname, \"r\");\r\n\telse {\r\n\t\tfor (len=32 ; ; len *= 2) {\r\n\t\t\tfname = (char *) malloc (len);\r\n\t\t\tif (!fname) return;\r\n\t\t\tif (_getcwd (fname, len-16)) break;\r\n\t\t\tfree (fname);\r\n\t\t\tif (errno != ERANGE) return;\r\n\t\t}\r\n#if defined(WIN32) || defined(DJGPP)\r\n\t\tif (fname[1] == ':')\r\n\t\t\tmemmove (fname, fname+2, len-2);\r\n\t\tfor (cp=fname; *cp; cp++)\r\n\t\t\tif (*cp == '\\\\') *cp = '/';\r\n#endif\r\n\t\tcp = fname + strlen(fname);\r\n\t\tif (cp[-1] == '/') cp--;\r\n\t\twhile (*fname == '/') {\r\n\t\t\tstrcpy (cp, \"/.badpixels\");\r\n\t\t\tif ((fp = fopen (fname, \"r\"))) break;\r\n\t\t\tif (cp == fname) break;\r\n\t\t\twhile (*--cp != '/');\r\n\t\t}\r\n\t\tfree (fname);\r\n\t}\r\n\tif (!fp) return;\r\n\twhile (fgets (line, 128, fp)) {\r\n\t\tcp = strchr (line, '#');\r\n\t\tif (cp) *cp = 0;\r\n\t\tif (sscanf (line, \"%d %d %d\", &col, &row, &time) != 3) continue;\r\n\t\tif ((unsigned) col >= p->width || (unsigned) row >= p->height) continue;\r\n\t\tif (time > p->timestamp) continue;\r\n\t\tfor (tot=n=0, rad=1; rad < 3 && n==0; rad++)\r\n\t\t\tfor (r = row-rad; r <= row+rad; r++)\r\n\t\t\t\tfor (c = col-rad; c <= col+rad; c++)\r\n\t\t\t\t\tif ((unsigned) r < p->height && (unsigned) c < p->width &&\r\n\t\t\t\t\t\t(r != row || c != col) && dcr_fc(p,r,c) == dcr_fc(p,row,col)) {\r\n\t\t\t\t\t\ttot += BAYER2(r,c);\r\n\t\t\t\t\t\tn++;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tBAYER2(row,col) = tot/n;\r\n\t\t\t\t\tif (p->opt.verbose) {\r\n\t\t\t\t\t\tif (!fixed++)\r\n\t\t\t\t\t\t\tfprintf (stderr,_(\"Fixed dead pixels at:\"));\r\n\t\t\t\t\t\tfprintf (stderr, \" %d,%d\", col, row);\r\n\t\t\t\t\t}\r\n\t}\r\n\tif (fixed) fputc ('\\n', stderr);\r\n\tfclose (fp);\r\n}\r\n\r\nvoid DCR_CLASS dcr_subtract (DCRAW* p,char *fname)\r\n{\r\n\tFILE *fp;\r\n\tint dim[3]={0,0,0}, comment=0, number=0, error=0, nd=0, c, row, col;\r\n\tushort *pixel;\r\n\r\n\tif (!(fp = fopen (fname, \"rb\"))) {\r\n\t\tperror (fname);  return;\r\n\t}\r\n\tif (fgetc(fp) != 'P' || fgetc(fp) != '5') error = 1;\r\n\twhile (!error && nd < 3 && (c = fgetc(fp)) != EOF) {\r\n\t\tif (c == '#')  comment = 1;\r\n\t\tif (c == '\\n') comment = 0;\r\n\t\tif (comment) continue;\r\n\t\tif (isdigit(c)) number = 1;\r\n\t\tif (number) {\r\n\t\t\tif (isdigit(c)) dim[nd] = dim[nd]*10 + c -'0';\r\n\t\t\telse if (isspace(c)) {\r\n\t\t\t\tnumber = 0;  nd++;\r\n\t\t\t} else error = 1;\r\n\t\t}\r\n\t}\r\n\tif (error || nd < 3) {\r\n\t\tfprintf (stderr,_(\"%s is not a valid PGM file!\\n\"), fname);\r\n\t\tfclose (fp);  return;\r\n\t} else if (dim[0] != p->width || dim[1] != p->height || dim[2] != 65535) {\r\n\t\tfprintf (stderr,_(\"%s has the wrong dimensions!\\n\"), fname);\r\n\t\tfclose (fp);  return;\r\n\t}\r\n\tpixel = (ushort *) calloc (p->width, sizeof *pixel);\r\n\tdcr_merror (p, pixel, \"subtract()\");\r\n\tfor (row=0; row < p->height; row++) {\r\n\t\tfread (pixel, 2, p->width, fp);\r\n\t\tfor (col=0; col < p->width; col++)\r\n\t\t\tBAYER(row,col) = MAX (BAYER(row,col) - ntohs(pixel[col]), 0);\r\n\t}\r\n\tfclose (fp);\r\n\tfree (pixel);\r\n\tp->black = 0;\r\n}\r\n\r\nvoid DCR_CLASS dcr_pseudoinverse (double (*in)[3], double (*out)[3], int size)\r\n{\r\n\tdouble work[3][6], num;\r\n\tint i, j, k;\r\n\r\n\tfor (i=0; i < 3; i++) {\r\n\t\tfor (j=0; j < 6; j++)\r\n\t\t\twork[i][j] = j == i+3;\r\n\t\tfor (j=0; j < 3; j++)\r\n\t\t\tfor (k=0; k < size; k++)\r\n\t\t\t\twork[i][j] += in[k][i] * in[k][j];\r\n\t}\r\n\tfor (i=0; i < 3; i++) {\r\n\t\tnum = work[i][i];\r\n\t\tfor (j=0; j < 6; j++)\r\n\t\t\twork[i][j] /= num;\r\n\t\tfor (k=0; k < 3; k++) {\r\n\t\t\tif (k==i) continue;\r\n\t\t\tnum = work[k][i];\r\n\t\t\tfor (j=0; j < 6; j++)\r\n\t\t\t\twork[k][j] -= work[i][j] * num;\r\n\t\t}\r\n\t}\r\n\tfor (i=0; i < size; i++)\r\n\t\tfor (j=0; j < 3; j++)\r\n\t\t\tfor (out[i][j]=k=0; k < 3; k++)\r\n\t\t\t\tout[i][j] += work[j][k+3] * in[i][k];\r\n}\r\n\r\nvoid DCR_CLASS dcr_cam_xyz_coeff (DCRAW* p, double cam_xyz[4][3])\r\n{\r\n\tdouble cam_rgb[4][3], inverse[4][3], num;\r\n\tint i, j, k;\r\n\r\n\tfor (i=0; i < p->colors; i++)\t\t/* Multiply out XYZ colorspace */\r\n\t\tfor (j=0; j < 3; j++)\r\n\t\t\tfor (cam_rgb[i][j] = k=0; k < 3; k++)\r\n\t\t\t\tcam_rgb[i][j] += cam_xyz[i][k] * xyz_rgb[k][j];\r\n\r\n\tfor (i=0; i < p->colors; i++) {\t\t/* Normalize cam_rgb so that */\r\n\t\tfor (num=j=0; j < 3; j++)\t\t/* cam_rgb * (1,1,1) is (1,1,1,1) */\r\n\t\t\tnum += cam_rgb[i][j];\r\n\t\tfor (j=0; j < 3; j++)\r\n\t\t\tcam_rgb[i][j] /= num;\r\n\t\tp->pre_mul[i] = 1 / (float)num;\r\n\t}\r\n\tdcr_pseudoinverse (cam_rgb, inverse, p->colors);\r\n\tfor (p->raw_color = i=0; i < 3; i++)\r\n\t\tfor (j=0; j < p->colors; j++)\r\n\t\t\tp->rgb_cam[i][j] = (float)inverse[j][i];\r\n}\r\n\r\n#ifdef COLORCHECK\r\nvoid DCR_CLASS dcr_colorcheck(DCRAW* p)\r\n{\r\n#define NSQ 24\r\n\t// Coordinates of the GretagMacbeth ColorChecker squares\r\n\t// p->width, p->height, 1st_column, 1st_row\r\n\tstatic const int cut[NSQ][4] = {\r\n\t\t{ 241, 231, 234, 274 },\r\n\t\t{ 251, 235, 534, 274 },\r\n\t\t{ 255, 239, 838, 272 },\r\n\t\t{ 255, 240, 1146, 274 },\r\n\t\t{ 251, 237, 1452, 278 },\r\n\t\t{ 243, 238, 1758, 288 },\r\n\t\t{ 253, 253, 218, 558 },\r\n\t\t{ 255, 249, 524, 562 },\r\n\t\t{ 261, 253, 830, 562 },\r\n\t\t{ 260, 255, 1144, 564 },\r\n\t\t{ 261, 255, 1450, 566 },\r\n\t\t{ 247, 247, 1764, 576 },\r\n\t\t{ 255, 251, 212, 862 },\r\n\t\t{ 259, 259, 518, 862 },\r\n\t\t{ 263, 261, 826, 864 },\r\n\t\t{ 265, 263, 1138, 866 },\r\n\t\t{ 265, 257, 1450, 872 },\r\n\t\t{ 257, 255, 1762, 874 },\r\n\t\t{ 257, 253, 212, 1164 },\r\n\t\t{ 262, 251, 516, 1172 },\r\n\t\t{ 263, 257, 826, 1172 },\r\n\t\t{ 263, 255, 1136, 1176 },\r\n\t\t{ 255, 252, 1452, 1182 },\r\n\t\t{ 257, 253, 1760, 1180 } };\r\n\t// ColorChecker Chart under 6500-kelvin illumination\r\n\tstatic const double gmb_xyY[NSQ][3] = {\r\n\t\t{ 0.400, 0.350, 10.1 },\t\t// Dark Skin\r\n\t\t{ 0.377, 0.345, 35.8 },\t\t// Light Skin\r\n\t\t{ 0.247, 0.251, 19.3 },\t\t// Blue Sky\r\n\t\t{ 0.337, 0.422, 13.3 },\t\t// Foliage\r\n\t\t{ 0.265, 0.240, 24.3 },\t\t// Blue Flower\r\n\t\t{ 0.261, 0.343, 43.1 },\t\t// Bluish Green\r\n\t\t{ 0.506, 0.407, 30.1 },\t\t// Orange\r\n\t\t{ 0.211, 0.175, 12.0 },\t\t// Purplish Blue\r\n\t\t{ 0.453, 0.306, 19.8 },\t\t// Moderate Red\r\n\t\t{ 0.285, 0.202, 6.6 },\t\t// Purple\r\n\t\t{ 0.380, 0.489, 44.3 },\t\t// Yellow Green\r\n\t\t{ 0.473, 0.438, 43.1 },\t\t// Orange Yellow\r\n\t\t{ 0.187, 0.129, 6.1 },\t\t// Blue\r\n\t\t{ 0.305, 0.478, 23.4 },\t\t// Green\r\n\t\t{ 0.539, 0.313, 12.0 },\t\t// Red\r\n\t\t{ 0.448, 0.470, 59.1 },\t\t// Yellow\r\n\t\t{ 0.364, 0.233, 19.8 },\t\t// Magenta\r\n\t\t{ 0.196, 0.252, 19.8 },\t\t// Cyan\r\n\t\t{ 0.310, 0.316, 90.0 },\t\t// White\r\n\t\t{ 0.310, 0.316, 59.1 },\t\t// Neutral 8\r\n\t\t{ 0.310, 0.316, 36.2 },\t\t// Neutral 6.5\r\n\t\t{ 0.310, 0.316, 19.8 },\t\t// Neutral 5\r\n\t\t{ 0.310, 0.316, 9.0 },\t\t// Neutral 3.5\r\n\t\t{ 0.310, 0.316, 3.1 } };\t\t// Black\r\n\tdouble gmb_cam[NSQ][4], gmb_xyz[NSQ][3];\r\n\tdouble inverse[NSQ][3], cam_xyz[4][3], num;\r\n\tint c, i, j, k, sq, row, col, count[4];\r\n\r\n\tmemset (gmb_cam, 0, sizeof gmb_cam);\r\n\tfor (sq=0; sq < NSQ; sq++) {\r\n\t\tFORCC(p) count[c] = 0;\r\n\t\tfor   (row=cut[sq][3]; row < cut[sq][3]+cut[sq][1]; row++)\r\n\t\t\tfor (col=cut[sq][2]; col < cut[sq][2]+cut[sq][0]; col++) {\r\n\t\t\t\tc = FC(row,col);\r\n\t\t\t\tif (c >= p->colors) c -= 2;\r\n\t\t\t\tgmb_cam[sq][c] += BAYER(row,col);\r\n\t\t\t\tcount[c]++;\r\n\t\t\t}\r\n\t\t\tFORCC(p) gmb_cam[sq][c] = gmb_cam[sq][c]/count[c] - p->black;\r\n\t\t\tgmb_xyz[sq][0] = gmb_xyY[sq][2] * gmb_xyY[sq][0] / gmb_xyY[sq][1];\r\n\t\t\tgmb_xyz[sq][1] = gmb_xyY[sq][2];\r\n\t\t\tgmb_xyz[sq][2] = gmb_xyY[sq][2] *\r\n\t\t\t\t(1 - gmb_xyY[sq][0] - gmb_xyY[sq][1]) / gmb_xyY[sq][1];\r\n\t}\r\n\tdcr_pseudoinverse (gmb_xyz, inverse, NSQ);\r\n\tfor (i=0; i < p->colors; i++)\r\n\t\tfor (j=0; j < 3; j++)\r\n\t\t\tfor (cam_xyz[i][j] = k=0; k < NSQ; k++)\r\n\t\t\t\tcam_xyz[i][j] += gmb_cam[k][i] * inverse[k][j];\r\n\tdcr_cam_xyz_coeff (p, cam_xyz);\r\n\tif (p->opt.verbose) {\r\n\t\tprintf (\"    { \\\"%s %s\\\", %d,\\n\\t{\", p->make, p->model, p->black);\r\n\t\tnum = 10000 / (cam_xyz[1][0] + cam_xyz[1][1] + cam_xyz[1][2]);\r\n\t\tFORCC(p) for (j=0; j < 3; j++)\r\n\t\t\tprintf (\"%c%d\", (c | j) ? ',':' ', (int) (cam_xyz[c][j] * num + 0.5));\r\n\t\tputs (\" } },\");\r\n\t}\r\n#undef NSQ\r\n}\r\n#endif\r\n\r\nvoid DCR_CLASS dcr_hat_transform (float *temp, float *base, int st, int size, int sc)\r\n{\r\n\tint i;\r\n\tfor (i=0; i < sc; i++)\r\n\t\ttemp[i] = 2*base[st*i] + base[st*(sc-i)] + base[st*(i+sc)];\r\n\tfor (; i+sc < size; i++)\r\n\t\ttemp[i] = 2*base[st*i] + base[st*(i-sc)] + base[st*(i+sc)];\r\n\tfor (; i < size; i++)\r\n\t\ttemp[i] = 2*base[st*i] + base[st*(i-sc)] + base[st*(2*size-2-(i+sc))];\r\n}\r\n\r\nvoid DCR_CLASS dcr_wavelet_denoise(DCRAW* p)\r\n{\r\n\tfloat *fimg=0, *temp, thold, mul[2], avg, diff;\r\n\tint scale=1, size, lev, hpass, lpass, row, col, nc, c, i, wlast;\r\n\tushort *window[4];\r\n\tstatic const float noise[] =\r\n\t{ 0.8002f,0.2735f,0.1202f,0.0585f,0.0291f,0.0152f,0.0080f,0.0044f };\r\n\r\n\tif (p->opt.verbose) fprintf (stderr,_(\"Wavelet denoising...\\n\"));\r\n\r\n\twhile (p->maximum << scale < 0x10000) scale++;\r\n\tp->maximum <<= --scale;\r\n\tp->black <<= scale;\r\n\tif ((size = p->iheight*p->iwidth) < 0x15550000)\r\n\t\tfimg = (float *) malloc ((size*3 + p->iheight + p->iwidth) * sizeof *fimg);\r\n\tdcr_merror (p, fimg, \"wavelet_denoise()\");\r\n\ttemp = fimg + size*3;\r\n\tif ((nc = p->colors) == 3 && p->filters) nc++;\r\n\tFORC(nc) {\t/* denoise R,G1,B,G3 individually */\r\n\t\tfor (i=0; i < size; i++)\r\n\t\t\tfimg[i] = 256 * (float)sqrt(p->image[i][c] << scale);\r\n\t\tfor (hpass=lev=0; lev < 5; lev++) {\r\n\t\t\tlpass = size*((lev & 1)+1);\r\n\t\t\tfor (row=0; row < p->iheight; row++) {\r\n\t\t\t\tdcr_hat_transform (temp, fimg+hpass+row*p->iwidth, 1, p->iwidth, 1 << lev);\r\n\t\t\t\tfor (col=0; col < p->iwidth; col++)\r\n\t\t\t\t\tfimg[lpass + row*p->iwidth + col] = temp[col] * 0.25f;\r\n\t\t\t}\r\n\t\t\tfor (col=0; col < p->iwidth; col++) {\r\n\t\t\t\tdcr_hat_transform (temp, fimg+lpass+col, p->iwidth, p->iheight, 1 << lev);\r\n\t\t\t\tfor (row=0; row < p->iheight; row++)\r\n\t\t\t\t\tfimg[lpass + row*p->iwidth + col] = temp[row] * 0.25f;\r\n\t\t\t}\r\n\t\t\tthold = p->opt.threshold * noise[lev];\r\n\t\t\tfor (i=0; i < size; i++) {\r\n\t\t\t\tfimg[hpass+i] -= fimg[lpass+i];\r\n\t\t\t\tif\t(fimg[hpass+i] < -thold) fimg[hpass+i] += thold;\r\n\t\t\t\telse if (fimg[hpass+i] >  thold) fimg[hpass+i] -= thold;\r\n\t\t\t\telse\t fimg[hpass+i] = 0;\r\n\t\t\t\tif (hpass) fimg[i] += fimg[hpass+i];\r\n\t\t\t}\r\n\t\t\thpass = lpass;\r\n\t\t}\r\n\t\tfor (i=0; i < size; i++)\r\n\t\t\tp->image[i][c] = (unsigned short)(CLIP(SQR(fimg[i]+fimg[lpass+i])/0x10000));\r\n\t}\r\n\tif (p->filters && p->colors == 3) {  /* pull G1 and G3 closer together */\r\n\t\tfor (row=0; row < 2; row++)\r\n\t\t\tmul[row] = 0.125f * p->pre_mul[FC(row+1,0) | 1] / p->pre_mul[FC(row,0) | 1];\r\n\t\tfor (i=0; i < 4; i++)\r\n\t\t\twindow[i] = (ushort *) fimg + p->width*i;\r\n\t\tfor (wlast=-1, row=1; row < p->height-1; row++) {\r\n\t\t\twhile (wlast < row+1) {\r\n\t\t\t\tfor (wlast++, i=0; i < 4; i++)\r\n\t\t\t\t\twindow[(i+3) & 3] = window[i];\r\n\t\t\t\tfor (col = FC(wlast,1) & 1; col < p->width; col+=2)\r\n\t\t\t\t\twindow[2][col] = BAYER(wlast,col);\r\n\t\t\t}\r\n\t\t\tthold = p->opt.threshold/512;\r\n\t\t\tfor (col = (FC(row,0) & 1)+1; col < p->width-1; col+=2) {\r\n\t\t\t\tavg = ( window[0][col-1] + window[0][col+1] +\r\n\t\t\t\t\twindow[2][col-1] + window[2][col+1] - p->black*4 )\r\n\t\t\t\t\t* mul[row & 1] + (window[1][col] - p->black) * 0.5f + p->black;\r\n\t\t\t\tavg = avg < 0 ? 0 : (float)sqrt(avg);\r\n\t\t\t\tdiff = (float)sqrt(BAYER(row,col)) - avg;\r\n\t\t\t\tif      (diff < -thold) diff += thold;\r\n\t\t\t\telse if (diff >  thold) diff -= thold;\r\n\t\t\t\telse diff = 0;\r\n\t\t\t\tBAYER(row,col) = (unsigned short)(CLIP(SQR(avg+diff) + 0.5f));\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tfree (fimg);\r\n}\r\n\r\nvoid DCR_CLASS dcr_scale_colors(DCRAW* p)\r\n{\r\n\tunsigned bottom, right, size, row, col, ur, uc, i, x, y, c, sum[8];\r\n\tint val, dark, sat;\r\n\tdouble dsum[8], dmin, dmax;\r\n\tfloat scale_mul[4], fr, fc;\r\n\tushort *img=0, *pix;\r\n\r\n\tif (p->opt.user_mul[0])\r\n\t\tmemcpy (p->pre_mul, p->opt.user_mul, sizeof p->pre_mul);\r\n\tif (p->opt.use_auto_wb || (p->opt.use_camera_wb && p->cam_mul[0] == -1)) {\r\n\t\tmemset (dsum, 0, sizeof dsum);\r\n\t\tbottom = MIN (p->opt.greybox[1]+p->opt.greybox[3], p->height);\r\n\t\tright  = MIN (p->opt.greybox[0]+p->opt.greybox[2], p->width);\r\n\t\tfor (row=p->opt.greybox[1]; row < bottom; row += 8)\r\n\t\t\tfor (col=p->opt.greybox[0]; col < right; col += 8) {\r\n\t\t\t\tmemset (sum, 0, sizeof sum);\r\n\t\t\t\tfor (y=row; y < row+8 && y < bottom; y++)\r\n\t\t\t\t\tfor (x=col; x < col+8 && x < right; x++)\r\n\t\t\t\t\t\tFORC4 {\r\n\t\t\t\t\t\tif (p->filters) {\r\n\t\t\t\t\t\t\tc = FC(y,x);\r\n\t\t\t\t\t\t\tval = BAYER(y,x);\r\n\t\t\t\t\t\t} else\r\n\t\t\t\t\t\t\tval = p->image[y*p->width+x][c];\r\n\t\t\t\t\t\tif (val > (int)p->maximum-25) goto skip_block;\r\n\t\t\t\t\t\tif ((val -= p->black) < 0) val = 0;\r\n\t\t\t\t\t\tsum[c] += val;\r\n\t\t\t\t\t\tsum[c+4]++;\r\n\t\t\t\t\t\tif (p->filters) break;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tFORC(8) dsum[c] += sum[c];\r\nskip_block: ;\r\n\t\t\t}\r\n\t\t\tFORC4 if (dsum[c]) p->pre_mul[c] = (float)(dsum[c+4] / dsum[c]);\r\n\t}\r\n\tif (p->opt.use_camera_wb && p->cam_mul[0] != -1) {\r\n\t\tmemset (sum, 0, sizeof sum);\r\n\t\tfor (row=0; row < 8; row++)\r\n\t\t\tfor (col=0; col < 8; col++) {\r\n\t\t\t\tc = FC(row,col);\r\n\t\t\t\tif ((val = p->white[row][col] - p->black) > 0)\r\n\t\t\t\t\tsum[c] += val;\r\n\t\t\t\tsum[c+4]++;\r\n\t\t\t}\r\n\t\t\tif (sum[0] && sum[1] && sum[2] && sum[3])\r\n\t\t\t\tFORC4 p->pre_mul[c] = (float) sum[c+4] / sum[c];\r\n\t\t\telse if (p->cam_mul[0] && p->cam_mul[2])\r\n\t\t\t\tmemcpy (p->pre_mul, p->cam_mul, sizeof p->pre_mul);\r\n\t\t\telse\r\n\t\t\t\tfprintf (stderr,_(\"%s: Cannot use camera p->white balance.\\n\"), p->ifname);\r\n\t}\r\n\tif (p->pre_mul[3] == 0) p->pre_mul[3] = p->colors < 4 ? p->pre_mul[1] : 1;\r\n\tdark = p->black;\r\n\tsat = p->maximum;\r\n\tif (p->opt.threshold) dcr_wavelet_denoise(p);\r\n\tp->maximum -= p->black;\r\n\tfor (dmin=DBL_MAX, dmax=c=0; c < 4; c++) {\r\n\t\tif (dmin > p->pre_mul[c])\r\n\t\t\tdmin = p->pre_mul[c];\r\n\t\tif (dmax < p->pre_mul[c])\r\n\t\t\tdmax = p->pre_mul[c];\r\n\t}\r\n\tif (!p->opt.highlight) dmax = dmin;\r\n\tFORC4 scale_mul[c] = (float)((p->pre_mul[c] /= (float)dmax) * 65535.0f / p->maximum);\r\n\tif (p->opt.verbose) {\r\n\t\tfprintf (stderr,_(\"Scaling with darkness %d, saturation %d, and\\nmultipliers\"), dark, sat);\r\n\t\tFORC4 fprintf (stderr, \" %f\", p->pre_mul[c]);\r\n\t\tfputc ('\\n', stderr);\r\n\t}\r\n\tsize = p->iheight*p->iwidth;\r\n\tfor (i=0; i < size*4; i++) {\r\n\t\tval = p->image[0][i];\r\n\t\tif (!val) continue;\r\n\t\tval -= p->black;\r\n\t\tval = (int)(val * scale_mul[i & 3]);\r\n\t\tp->image[0][i] = CLIP(val);\r\n\t}\r\n\tif ((p->opt.aber[0] != 1 || p->opt.aber[2] != 1) && p->colors == 3) {\r\n\t\tif (p->opt.verbose)\r\n\t\t\tfprintf (stderr,_(\"Correcting chromatic aberration...\\n\"));\r\n\t\tfor (c=0; c < 4; c+=2) {\r\n\t\t\tif (p->opt.aber[c] == 1) continue;\r\n\t\t\timg = (ushort *) malloc (size * sizeof *img);\r\n\t\t\tdcr_merror (p, img, \"scale_colors()\");\r\n\t\t\tfor (i=0; i < size; i++)\r\n\t\t\t\timg[i] = p->image[i][c];\r\n\t\t\tfor (row=0; row < p->iheight; row++) {\r\n\t\t\t\tfr = (float)((row - p->iheight*0.5) * p->opt.aber[c] + p->iheight*0.5);\r\n\t\t\t\tur = (unsigned int)fr;\r\n\t\t\t\tif ((int)ur > p->iheight-2) continue;\r\n\t\t\t\tfr -= ur;\r\n\t\t\t\tfor (col=0; col < p->iwidth; col++) {\r\n\t\t\t\t\tfc = (float)((col - p->iwidth*0.5) * p->opt.aber[c] + p->iwidth*0.5);\r\n\t\t\t\t\tuc = (unsigned int)fc;\r\n\t\t\t\t\tif ((int)uc > p->iwidth-2) continue;\r\n\t\t\t\t\tfc -= uc;\r\n\t\t\t\t\tpix = img + ur*p->iwidth + uc;\r\n\t\t\t\t\tp->image[row*p->iwidth+col][c] = (unsigned short)(\r\n\t\t\t\t\t\t(pix[     0]*(1-fc) + pix[       1]*fc) * (1-fr) +\r\n\t\t\t\t\t\t(pix[p->iwidth]*(1-fc) + pix[p->iwidth+1]*fc) * fr);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tfree(img);\r\n\t\t}\r\n\t}\r\n}\r\n\r\nvoid DCR_CLASS dcr_pre_interpolate(DCRAW* p)\r\n{\r\n\tushort (*img)[4];\r\n\tint row, col, c;\r\n\r\n\tif (p->shrink) {\r\n\t\tif (p->opt.half_size) {\r\n\t\t\tp->height = p->iheight;\r\n\t\t\tp->width  = p->iwidth;\r\n\t\t} else {\r\n\t\t\timg = (ushort (*)[4]) calloc (p->height*p->width, sizeof *img);\r\n\t\t\tdcr_merror (p, img, \"pre_interpolate()\");\r\n\t\t\tfor (row=0; row < p->height; row++)\r\n\t\t\t\tfor (col=0; col < p->width; col++) {\r\n\t\t\t\t\tc = dcr_fc(p,row,col);\r\n\t\t\t\t\timg[row*p->width+col][c] = p->image[(row >> 1)*p->iwidth+(col >> 1)][c];\r\n\t\t\t\t}\r\n\t\t\t\tfree (p->image);\r\n\t\t\t\tp->image = img;\r\n\t\t\t\tp->shrink = 0;\r\n\t\t}\r\n\t}\r\n\tif (p->filters && p->colors == 3) {\r\n\t\tif ((p->mix_green = p->opt.four_color_rgb)) p->colors++;\r\n\t\telse {\r\n\t\t\tfor (row = FC(1,0) >> 1; row < p->height; row+=2)\r\n\t\t\t\tfor (col = FC(row,1) & 1; col < p->width; col+=2)\r\n\t\t\t\t\tp->image[row*p->width+col][1] = p->image[row*p->width+col][3];\r\n\t\t\t\tp->filters &= ~((p->filters & 0x55555555) << 1);\r\n\t\t}\r\n\t}\r\n\tif (p->opt.half_size) p->filters = 0;\r\n}\r\n\r\nvoid DCR_CLASS dcr_border_interpolate (DCRAW* p, int border)\r\n{\r\n\tunsigned row, col, y, x, f, sum[8];\r\n\tint c;\r\n\r\n\tfor (row=0; row < p->height; row++)\r\n\t\tfor (col=0; col < p->width; col++) {\r\n\t\t\tif (col==(unsigned int)border && row >= (unsigned int)border && row < p->height-(unsigned int)border)\r\n\t\t\t\tcol = p->width-border;\r\n\t\t\tmemset (sum, 0, sizeof sum);\r\n\t\t\tfor (y=row-1; y != row+2; y++)\r\n\t\t\t\tfor (x=col-1; x != col+2; x++)\r\n\t\t\t\t\tif (y < p->height && x < p->width) {\r\n\t\t\t\t\t\tf = dcr_fc(p,y,x);\r\n\t\t\t\t\t\tsum[f] += p->image[y*p->width+x][f];\r\n\t\t\t\t\t\tsum[f+4]++;\r\n\t\t\t\t\t}\r\n\t\t\tf = dcr_fc(p,row,col);\r\n\t\t\tFORCC(p) if ((unsigned int)c != f && sum[c+4])\r\n\t\t\t\tp->image[row*p->width+col][c] = sum[c] / sum[c+4];\r\n\t\t}\r\n}\r\n\r\nvoid DCR_CLASS dcr_lin_interpolate(DCRAW* p)\r\n{\r\n\tint code[16][16][32], *ip, sum[4];\r\n\tint c, i, x, y, row, col, shift, color;\r\n\tushort *pix;\r\n\r\n\tif (p->opt.verbose) fprintf (stderr,_(\"Bilinear interpolation...\\n\"));\r\n\r\n\tdcr_border_interpolate(p,1);\r\n\tfor (row=0; row < 16; row++)\r\n\t\tfor (col=0; col < 16; col++) {\r\n\t\t\tip = code[row][col];\r\n\t\t\tmemset (sum, 0, sizeof sum);\r\n\t\t\tfor (y=-1; y <= 1; y++)\r\n\t\t\t\tfor (x=-1; x <= 1; x++) {\r\n\t\t\t\t\tshift = (y==0) + (x==0);\r\n\t\t\t\t\tif (shift == 2) continue;\r\n\t\t\t\t\tcolor = dcr_fc(p,row+y,col+x);\r\n\t\t\t\t\t*ip++ = (p->width*y + x)*4 + color;\r\n\t\t\t\t\t*ip++ = shift;\r\n\t\t\t\t\t*ip++ = color;\r\n\t\t\t\t\tsum[color] += 1 << shift;\r\n\t\t\t\t}\r\n\t\t\t\tFORCC(p)\r\n\t\t\t\t\tif (c != dcr_fc(p,row,col)) {\r\n\t\t\t\t\t\t*ip++ = c;\r\n\t\t\t\t\t\t*ip++ = 256 / sum[c];\r\n\t\t\t\t\t}\r\n\t\t}\r\n\tfor (row=1; row < p->height-1; row++)\r\n\t\tfor (col=1; col < p->width-1; col++) {\r\n\t\t\tpix = p->image[row*p->width+col];\r\n\t\t\tip = code[row & 15][col & 15];\r\n\t\t\tmemset (sum, 0, sizeof sum);\r\n\t\t\tfor (i=8; i--; ip+=3)\r\n\t\t\t\tsum[ip[2]] += pix[ip[0]] << ip[1];\r\n\t\t\tfor (i=p->colors; --i; ip+=2)\r\n\t\t\t\tpix[ip[0]] = sum[ip[0]] * ip[1] >> 8;\r\n\t\t}\r\n}\r\n\r\n/*\r\nThis algorithm is officially called:\r\n\r\n  \"Interpolation using a Threshold-based variable number of gradients\"\r\n\r\n\tdescribed in http://scien.stanford.edu/class/psych221/projects/99/tingchen/algodep/vargra.html\r\n\r\n\t  I've extended the basic idea to work with non-Bayer filter arrays.\r\n\t  Gradients are numbered clockwise from NW=0 to W=7.\r\n*/\r\nvoid DCR_CLASS dcr_vng_interpolate(DCRAW* p)\r\n{\r\n\tstatic const signed char *cp, terms[] = {\r\n\t\t-2,-2,+0,-1,0,0x01, -2,-2,+0,+0,1,0x01, -2,-1,-1,+0,0,0x01,\r\n\t\t-2,-1,+0,-1,0,0x02, -2,-1,+0,+0,0,0x03, -2,-1,+0,+1,1,0x01,\r\n\t\t-2,+0,+0,-1,0,0x06, -2,+0,+0,+0,1,0x02, -2,+0,+0,+1,0,0x03,\r\n\t\t-2,+1,-1,+0,0,0x04, -2,+1,+0,-1,1,0x04, -2,+1,+0,+0,0,0x06,\r\n\t\t-2,+1,+0,+1,0,0x02, -2,+2,+0,+0,1,0x04, -2,+2,+0,+1,0,0x04,\r\n\t\t-1,-2,-1,+0,0,(const signed char)0x80, -1,-2,+0,-1,0,0x01, -1,-2,+1,-1,0,0x01,\r\n\t\t-1,-2,+1,+0,1,0x01, -1,-1,-1,+1,0,(const signed char)0x88, -1,-1,+1,-2,0,0x40,\r\n\t\t-1,-1,+1,-1,0,0x22, -1,-1,+1,+0,0,0x33, -1,-1,+1,+1,1,0x11,\r\n\t\t-1,+0,-1,+2,0,0x08, -1,+0,+0,-1,0,0x44, -1,+0,+0,+1,0,0x11,\r\n\t\t-1,+0,+1,-2,1,0x40, -1,+0,+1,-1,0,0x66, -1,+0,+1,+0,1,0x22,\r\n\t\t-1,+0,+1,+1,0,0x33, -1,+0,+1,+2,1,0x10, -1,+1,+1,-1,1,0x44,\r\n\t\t-1,+1,+1,+0,0,0x66, -1,+1,+1,+1,0,0x22, -1,+1,+1,+2,0,0x10,\r\n\t\t-1,+2,+0,+1,0,0x04, -1,+2,+1,+0,1,0x04, -1,+2,+1,+1,0,0x04,\r\n\t\t+0,-2,+0,+0,1,(const signed char)0x80, +0,-1,+0,+1,1,(const signed char)0x88, +0,-1,+1,-2,0,0x40,\r\n\t\t+0,-1,+1,+0,0,0x11, +0,-1,+2,-2,0,0x40, +0,-1,+2,-1,0,0x20,\r\n\t\t+0,-1,+2,+0,0,0x30, +0,-1,+2,+1,1,0x10, +0,+0,+0,+2,1,0x08,\r\n\t\t+0,+0,+2,-2,1,0x40, +0,+0,+2,-1,0,0x60, +0,+0,+2,+0,1,0x20,\r\n\t\t+0,+0,+2,+1,0,0x30, +0,+0,+2,+2,1,0x10, +0,+1,+1,+0,0,0x44,\r\n\t\t+0,+1,+1,+2,0,0x10, +0,+1,+2,-1,1,0x40, +0,+1,+2,+0,0,0x60,\r\n\t\t+0,+1,+2,+1,0,0x20, +0,+1,+2,+2,0,0x10, +1,-2,+1,+0,0,(const signed char)0x80,\r\n\t\t+1,-1,+1,+1,0,(const signed char)0x88, +1,+0,+1,+2,0,0x08, +1,+0,+2,-1,0,0x40,\r\n\t\t+1,+0,+2,+1,0,0x10\r\n\t}, chood[] = { -1,-1, -1,0, -1,+1, 0,+1, +1,+1, +1,0, +1,-1, 0,-1 };\r\n\tushort (*brow[5])[4], *pix;\r\n\tint prow=7, pcol=1, *ip, *code[16][16], gval[8], gmin, gmax, sum[4];\r\n\tint row, col, x, y, x1, x2, y1, y2, t, weight, grads, color, diag;\r\n\tint g, diff, thold, num, c;\r\n\r\n\tdcr_lin_interpolate(p);\r\n\tif (p->opt.verbose) fprintf (stderr,_(\"VNG interpolation...\\n\"));\r\n\r\n\tif (p->filters == 1) prow = pcol = 15;\r\n\tip = (int *) calloc ((prow+1)*(pcol+1), 1280);\r\n\tdcr_merror (p, ip, \"vng_interpolate()\");\r\n\tfor (row=0; row <= prow; row++)\t\t/* Precalculate for VNG */\r\n\t\tfor (col=0; col <= pcol; col++) {\r\n\t\t\tcode[row][col] = ip;\r\n\t\t\tfor (cp=terms, t=0; t < 64; t++) {\r\n\t\t\t\ty1 = *cp++;  x1 = *cp++;\r\n\t\t\t\ty2 = *cp++;  x2 = *cp++;\r\n\t\t\t\tweight = *cp++;\r\n\t\t\t\tgrads = *cp++;\r\n\t\t\t\tcolor = dcr_fc(p, row+y1,col+x1);\r\n\t\t\t\tif (dcr_fc(p, row+y2,col+x2) != color) continue;\r\n\t\t\t\tdiag = (dcr_fc(p, row,col+1) == color && dcr_fc(p, row+1,col) == color) ? 2:1;\r\n\t\t\t\tif (abs(y1-y2) == diag && abs(x1-x2) == diag) continue;\r\n\t\t\t\t*ip++ = (y1*p->width + x1)*4 + color;\r\n\t\t\t\t*ip++ = (y2*p->width + x2)*4 + color;\r\n\t\t\t\t*ip++ = weight;\r\n\t\t\t\tfor (g=0; g < 8; g++)\r\n\t\t\t\t\tif (grads & 1<<g) *ip++ = g;\r\n\t\t\t\t\t*ip++ = -1;\r\n\t\t\t}\r\n\t\t\t*ip++ = INT_MAX;\r\n\t\t\tfor (cp=chood, g=0; g < 8; g++) {\r\n\t\t\t\ty = *cp++;  x = *cp++;\r\n\t\t\t\t*ip++ = (y*p->width + x) * 4;\r\n\t\t\t\tcolor = dcr_fc(p, row,col);\r\n\t\t\t\tif (dcr_fc(p, row+y,col+x) != color && dcr_fc(p, row+y*2,col+x*2) == color)\r\n\t\t\t\t\t*ip++ = (y*p->width + x) * 8 + color;\r\n\t\t\t\telse\r\n\t\t\t\t\t*ip++ = 0;\r\n\t\t\t}\r\n\t\t}\r\n\tbrow[4] = (ushort (*)[4]) calloc (p->width*3, sizeof **brow);\r\n\tdcr_merror (p, brow[4], \"vng_interpolate()\");\r\n\tfor (row=0; row < 3; row++)\r\n\t\tbrow[row] = brow[4] + row*p->width;\r\n\tfor (row=2; row < p->height-2; row++) {\t\t/* Do VNG interpolation */\r\n\t\tfor (col=2; col < p->width-2; col++) {\r\n\t\t\tpix = p->image[row*p->width+col];\r\n\t\t\tip = code[row & prow][col & pcol];\r\n\t\t\tmemset (gval, 0, sizeof gval);\r\n\t\t\twhile ((g = ip[0]) != INT_MAX) {\t\t/* Calculate gradients */\r\n\t\t\t\tdiff = ABS(pix[g] - pix[ip[1]]) << ip[2];\r\n\t\t\t\tgval[ip[3]] += diff;\r\n\t\t\t\tip += 5;\r\n\t\t\t\tif ((g = ip[-1]) == -1) continue;\r\n\t\t\t\tgval[g] += diff;\r\n\t\t\t\twhile ((g = *ip++) != -1)\r\n\t\t\t\t\tgval[g] += diff;\r\n\t\t\t}\r\n\t\t\tip++;\r\n\t\t\tgmin = gmax = gval[0];\t\t\t/* Choose a p->opt.threshold */\r\n\t\t\tfor (g=1; g < 8; g++) {\r\n\t\t\t\tif (gmin > gval[g]) gmin = gval[g];\r\n\t\t\t\tif (gmax < gval[g]) gmax = gval[g];\r\n\t\t\t}\r\n\t\t\tif (gmax == 0) {\r\n\t\t\t\tmemcpy (brow[2][col], pix, sizeof *p->image);\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tthold = gmin + (gmax >> 1);\r\n\t\t\tmemset (sum, 0, sizeof sum);\r\n\t\t\tcolor = dcr_fc(p, row,col);\r\n\t\t\tfor (num=g=0; g < 8; g++,ip+=2) {\t\t/* Average the neighbors */\r\n\t\t\t\tif (gval[g] <= thold) {\r\n\t\t\t\t\tFORCC(p)\r\n\t\t\t\t\t\tif (c == color && ip[1])\r\n\t\t\t\t\t\t\tsum[c] += (pix[c] + pix[ip[1]]) >> 1;\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\tsum[c] += pix[ip[0] + c];\r\n\t\t\t\t\t\tnum++;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tFORCC(p) {\t\t\t\t\t/* Save to buffer */\r\n\t\t\t\tt = pix[color];\r\n\t\t\t\tif (c != color)\r\n\t\t\t\t\tt += (sum[c] - sum[color]) / num;\r\n\t\t\t\tbrow[2][col][c] = CLIP(t);\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (row > 3)\t\t\t\t/* Write buffer to image */\r\n\t\t\tmemcpy (p->image[(row-2)*p->width+2], brow[0]+2, (p->width-4)*sizeof *p->image);\r\n\t\tfor (g=0; g < 4; g++)\r\n\t\t\tbrow[(g-1) & 3] = brow[g];\r\n\t}\r\n\tmemcpy (p->image[(row-2)*p->width+2], brow[0]+2, (p->width-4)*sizeof *p->image);\r\n\tmemcpy (p->image[(row-1)*p->width+2], brow[1]+2, (p->width-4)*sizeof *p->image);\r\n\tfree (brow[4]);\r\n\tfree (code[0][0]);\r\n}\r\n\r\n/*\r\nPatterned Pixel Grouping Interpolation by Alain Desbiolles\r\n*/\r\nvoid DCR_CLASS dcr_ppg_interpolate(DCRAW* p)\r\n{\r\n\tint dir[5] = { 1, p->width, -1, -p->width, 1 };\r\n\tint row, col, diff[2], guess[2], c, d, i;\r\n\tushort (*pix)[4];\r\n\r\n\tdcr_border_interpolate(p,3);\r\n\tif (p->opt.verbose) fprintf (stderr,_(\"PPG interpolation...\\n\"));\r\n\r\n\t/*  Fill in the green layer with gradients and pattern recognition: */\r\n\tfor (row=3; row < p->height-3; row++)\r\n\t\tfor (col=3+(FC(row,3) & 1), c=FC(row,col); col < p->width-3; col+=2) {\r\n\t\t\tpix = p->image + row*p->width+col;\r\n\t\t\tfor (i=0; (d=dir[i]) > 0; i++) {\r\n\t\t\t\tguess[i] = (pix[-d][1] + pix[0][c] + pix[d][1]) * 2\r\n\t\t\t\t\t- pix[-2*d][c] - pix[2*d][c];\r\n\t\t\t\tdiff[i] = ( ABS(pix[-2*d][c] - pix[ 0][c]) +\r\n\t\t\t\t\tABS(pix[ 2*d][c] - pix[ 0][c]) +\r\n\t\t\t\t\tABS(pix[  -d][1] - pix[ d][1]) ) * 3 +\r\n\t\t\t\t\t( ABS(pix[ 3*d][1] - pix[ d][1]) +\r\n\t\t\t\t\tABS(pix[-3*d][1] - pix[-d][1]) ) * 2;\r\n\t\t\t}\r\n\t\t\td = dir[i = diff[0] > diff[1]];\r\n\t\t\tpix[0][1] = ULIM(guess[i] >> 2, pix[d][1], pix[-d][1]);\r\n\t\t}\r\n\t\t/*  Calculate red and blue for each green pixel:\t\t*/\r\n\t\tfor (row=1; row < p->height-1; row++)\r\n\t\t\tfor (col=1+(FC(row,2) & 1), c=FC(row,col+1); col < p->width-1; col+=2) {\r\n\t\t\t\tpix = p->image + row*p->width+col;\r\n\t\t\t\tfor (i=0; (d=dir[i]) > 0; c=2-c, i++)\r\n\t\t\t\t\tpix[0][c] = CLIP((pix[-d][c] + pix[d][c] + 2*pix[0][1]\r\n\t\t\t\t\t- pix[-d][1] - pix[d][1]) >> 1);\r\n\t\t\t}\r\n\t\t/*  Calculate blue for red pixels and vice versa:\t\t*/\r\n\t\tfor (row=1; row < p->height-1; row++)\r\n\t\t\tfor (col=1+(FC(row,1) & 1), c=2-FC(row,col); col < p->width-1; col+=2) {\r\n\t\t\t\tpix = p->image + row*p->width+col;\r\n\t\t\t\tfor (i=0; (d=dir[i]+dir[i+1]) > 0; i++) {\r\n\t\t\t\t\tdiff[i] = ABS(pix[-d][c] - pix[d][c]) +\r\n\t\t\t\t\t\tABS(pix[-d][1] - pix[0][1]) +\r\n\t\t\t\t\t\tABS(pix[ d][1] - pix[0][1]);\r\n\t\t\t\t\tguess[i] = pix[-d][c] + pix[d][c] + 2*pix[0][1]\r\n\t\t\t\t\t\t- pix[-d][1] - pix[d][1];\r\n\t\t\t\t}\r\n\t\t\t\tif (diff[0] != diff[1])\r\n\t\t\t\t\tpix[0][c] = CLIP(guess[diff[0] > diff[1]] >> 1);\r\n\t\t\t\telse\r\n\t\t\t\t\tpix[0][c] = CLIP((guess[0]+guess[1]) >> 2);\r\n\t\t\t}\r\n}\r\n\r\n/*\r\nAdaptive Homogeneity-Directed interpolation is based on\r\nthe work of Keigo Hirakawa, Thomas Parks, and Paul Lee.\r\n*/\r\n#define TS 256\t\t/* Tile Size */\r\n\r\nvoid DCR_CLASS dcr_ahd_interpolate(DCRAW* p)\r\n{\r\n\tint i, j, k, top, left, row, col, tr, tc, c, d, val, hm[2];\r\n\tushort (*pix)[4], (*rix)[3];\r\n\tstatic const int dir[4] = { -1, 1, -TS, TS };\r\n\tunsigned ldiff[2][4], abdiff[2][4], leps, abeps;\r\n\tfloat r, cbrt[0x10000], xyz[3], xyz_cam[3][4];\r\n\tushort (*rgb)[TS][TS][3];\r\n\tshort (*lab)[TS][TS][3], (*lix)[3];\r\n\tchar (*homo)[TS][TS], *buffer;\r\n\r\n\tif (p->opt.verbose) fprintf (stderr,_(\"AHD interpolation...\\n\"));\r\n\r\n\tfor (i=0; i < 0x10000; i++) {\r\n\t\tr = i / 65535.0f;\r\n\t\tcbrt[i] = r > 0.008856f ? (float)pow(r,1/3.0f) : 7.787f*r + 16/116.0f;\r\n\t}\r\n\tfor (i=0; i < 3; i++)\r\n\t\tfor (j=0; j < p->colors; j++)\r\n\t\t\tfor (xyz_cam[i][j] =0, k=0; k < 3; k++)\r\n\t\t\t\txyz_cam[i][j] += (float)(xyz_rgb[i][k] * p->rgb_cam[k][j] / d65_white[i]);\r\n\r\n\t\tdcr_border_interpolate(p,5);\r\n\t\tbuffer = (char *) malloc (26*TS*TS);\t\t/* 1664 kB */\r\n\t\tdcr_merror (p, buffer, \"ahd_interpolate()\");\r\n\t\trgb  = (ushort(*)[TS][TS][3]) buffer;\r\n\t\tlab  = (short (*)[TS][TS][3])(buffer + 12*TS*TS);\r\n\t\thomo = (char  (*)[TS][TS])   (buffer + 24*TS*TS);\r\n\r\n\t\tfor (top=2; top < p->height-5; top += TS-6)\r\n\t\t\tfor (left=2; left < p->width-5; left += TS-6) {\r\n\r\n\t\t\t\t/*  Interpolate green horizontally and vertically:\t\t*/\r\n\t\t\t\tfor (row = top; row < top+TS && row < p->height-2; row++) {\r\n\t\t\t\t\tcol = left + (FC(row,left) & 1);\r\n\t\t\t\t\tfor (c = FC(row,col); col < left+TS && col < p->width-2; col+=2) {\r\n\t\t\t\t\t\tpix = p->image + row*p->width+col;\r\n\t\t\t\t\t\tval = ((pix[-1][1] + pix[0][c] + pix[1][1]) * 2\r\n\t\t\t\t\t\t\t- pix[-2][c] - pix[2][c]) >> 2;\r\n\t\t\t\t\t\trgb[0][row-top][col-left][1] = ULIM(val,pix[-1][1],pix[1][1]);\r\n\t\t\t\t\t\tval = ((pix[-p->width][1] + pix[0][c] + pix[p->width][1]) * 2\r\n\t\t\t\t\t\t\t- pix[-2*p->width][c] - pix[2*p->width][c]) >> 2;\r\n\t\t\t\t\t\trgb[1][row-top][col-left][1] = ULIM(val,pix[-p->width][1],pix[p->width][1]);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t/*  Interpolate red and blue, and convert to CIELab:\t\t*/\r\n\t\t\t\tfor (d=0; d < 2; d++)\r\n\t\t\t\t\tfor (row=top+1; row < top+TS-1 && row < p->height-3; row++)\r\n\t\t\t\t\t\tfor (col=left+1; col < left+TS-1 && col < p->width-3; col++) {\r\n\t\t\t\t\t\t\tpix = p->image + row*p->width+col;\r\n\t\t\t\t\t\t\trix = &rgb[d][row-top][col-left];\r\n\t\t\t\t\t\t\tlix = &lab[d][row-top][col-left];\r\n\t\t\t\t\t\t\tif ((c = 2 - FC(row,col)) == 1) {\r\n\t\t\t\t\t\t\t\tc = FC(row+1,col);\r\n\t\t\t\t\t\t\t\tval = pix[0][1] + (( pix[-1][2-c] + pix[1][2-c]\r\n\t\t\t\t\t\t\t\t\t- rix[-1][1] - rix[1][1] ) >> 1);\r\n\t\t\t\t\t\t\t\trix[0][2-c] = CLIP(val);\r\n\t\t\t\t\t\t\t\tval = pix[0][1] + (( pix[-p->width][c] + pix[p->width][c]\r\n\t\t\t\t\t\t\t\t\t- rix[-TS][1] - rix[TS][1] ) >> 1);\r\n\t\t\t\t\t\t\t} else\r\n\t\t\t\t\t\t\t\tval = rix[0][1] + (( pix[-p->width-1][c] + pix[-p->width+1][c]\r\n\t\t\t\t\t\t\t\t+ pix[+p->width-1][c] + pix[+p->width+1][c]\r\n\t\t\t\t\t\t\t\t- rix[-TS-1][1] - rix[-TS+1][1]\r\n\t\t\t\t\t\t\t\t- rix[+TS-1][1] - rix[+TS+1][1] + 1) >> 2);\r\n\t\t\t\t\t\t\trix[0][c] = CLIP(val);\r\n\t\t\t\t\t\t\tc = FC(row,col);\r\n\t\t\t\t\t\t\trix[0][c] = pix[0][c];\r\n\t\t\t\t\t\t\txyz[0] = xyz[1] = xyz[2] = 0.5;\r\n\t\t\t\t\t\t\tFORCC(p) {\r\n\t\t\t\t\t\t\t\txyz[0] += xyz_cam[0][c] * rix[0][c];\r\n\t\t\t\t\t\t\t\txyz[1] += xyz_cam[1][c] * rix[0][c];\r\n\t\t\t\t\t\t\t\txyz[2] += xyz_cam[2][c] * rix[0][c];\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\txyz[0] = cbrt[CLIP((int) xyz[0])];\r\n\t\t\t\t\t\t\txyz[1] = cbrt[CLIP((int) xyz[1])];\r\n\t\t\t\t\t\t\txyz[2] = cbrt[CLIP((int) xyz[2])];\r\n\t\t\t\t\t\t\tlix[0][0] = (short)(64 * (116 * xyz[1] - 16));\r\n\t\t\t\t\t\t\tlix[0][1] = (short)(64 * 500 * (xyz[0] - xyz[1]));\r\n\t\t\t\t\t\t\tlix[0][2] = (short)(64 * 200 * (xyz[1] - xyz[2]));\r\n\t\t\t\t\t\t}\r\n\t\t\t\t/*  Build homogeneity maps from the CIELab images:\t\t*/\r\n\t\t\t\tmemset (homo, 0, 2*TS*TS);\r\n\t\t\t\tfor (row=top+2; row < top+TS-2 && row < p->height-4; row++) {\r\n\t\t\t\t\ttr = row-top;\r\n\t\t\t\t\tfor (col=left+2; col < left+TS-2 && col < p->width-4; col++) {\r\n\t\t\t\t\t\ttc = col-left;\r\n\t\t\t\t\t\tfor (d=0; d < 2; d++) {\r\n\t\t\t\t\t\t\tlix = &lab[d][tr][tc];\r\n\t\t\t\t\t\t\tfor (i=0; i < 4; i++) {\r\n\t\t\t\t\t\t\t\tldiff[d][i] = ABS(lix[0][0]-lix[dir[i]][0]);\r\n\t\t\t\t\t\t\t\tabdiff[d][i] = SQR(lix[0][1]-lix[dir[i]][1])\r\n\t\t\t\t\t\t\t\t\t+ SQR(lix[0][2]-lix[dir[i]][2]);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tleps = MIN(MAX(ldiff[0][0],ldiff[0][1]),\r\n\t\t\t\t\t\t\tMAX(ldiff[1][2],ldiff[1][3]));\r\n\t\t\t\t\t\tabeps = MIN(MAX(abdiff[0][0],abdiff[0][1]),\r\n\t\t\t\t\t\t\tMAX(abdiff[1][2],abdiff[1][3]));\r\n\t\t\t\t\t\tfor (d=0; d < 2; d++)\r\n\t\t\t\t\t\t\tfor (i=0; i < 4; i++)\r\n\t\t\t\t\t\t\t\tif (ldiff[d][i] <= leps && abdiff[d][i] <= abeps)\r\n\t\t\t\t\t\t\t\t\thomo[d][tr][tc]++;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t/*  Combine the most homogenous pixels for the final result:\t*/\r\n\t\t\t\tfor (row=top+3; row < top+TS-3 && row < p->height-5; row++) {\r\n\t\t\t\t\ttr = row-top;\r\n\t\t\t\t\tfor (col=left+3; col < left+TS-3 && col < p->width-5; col++) {\r\n\t\t\t\t\t\ttc = col-left;\r\n\t\t\t\t\t\tfor (d=0; d < 2; d++)\r\n\t\t\t\t\t\t\tfor (hm[d]=0, i=tr-1; i <= tr+1; i++)\r\n\t\t\t\t\t\t\t\tfor (j=tc-1; j <= tc+1; j++)\r\n\t\t\t\t\t\t\t\t\thm[d] += homo[d][i][j];\r\n\t\t\t\t\t\t\t\tif (hm[0] != hm[1])\r\n\t\t\t\t\t\t\t\t\tFORC3 p->image[row*p->width+col][c] = rgb[hm[1] > hm[0]][tr][tc][c];\r\n\t\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t\t\tFORC3 p->image[row*p->width+col][c] =\r\n\t\t\t\t\t\t\t\t\t(rgb[0][tr][tc][c] + rgb[1][tr][tc][c]) >> 1;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tfree (buffer);\r\n}\r\n#undef TS\r\n\r\nvoid DCR_CLASS dcr_median_filter(DCRAW* p)\r\n{\r\n\tushort (*pix)[4];\r\n\tint pass, c, i, j, k, med[9];\r\n\tstatic const uchar opt[] =\t/* Optimal 9-element median search */\r\n\t{ 1,2, 4,5, 7,8, 0,1, 3,4, 6,7, 1,2, 4,5, 7,8,\r\n    0,3, 5,8, 4,7, 3,6, 1,4, 2,5, 4,7, 4,2, 6,4, 4,2 };\r\n\r\n\tfor (pass=1; pass <= p->opt.med_passes; pass++) {\r\n\t\tif (p->opt.verbose)\r\n\t\t\tfprintf (stderr,_(\"Median filter pass %d...\\n\"), pass);\r\n\t\tfor (c=0; c < 3; c+=2) {\r\n\t\t\tfor (pix = p->image; pix < p->image+p->width*p->height; pix++)\r\n\t\t\t\tpix[0][3] = pix[0][c];\r\n\t\t\tfor (pix = p->image+p->width; pix < p->image+p->width*(p->height-1); pix++) {\r\n\t\t\t\tif ((pix-p->image+1) % p->width < 2) continue;\r\n\t\t\t\tfor (k=0, i = -p->width; i <= p->width; i += p->width)\r\n\t\t\t\t\tfor (j = i-1; j <= i+1; j++)\r\n\t\t\t\t\t\tmed[k++] = pix[j][3] - pix[j][1];\r\n\t\t\t\t\tfor (i=0; i < sizeof opt; i+=2)\r\n\t\t\t\t\t\tif     (med[opt[i]] > med[opt[i+1]])\r\n\t\t\t\t\t\t\tSWAP (med[opt[i]] , med[opt[i+1]]);\r\n\t\t\t\t\t\tpix[0][c] = CLIP(med[4] + pix[0][1]);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\nvoid DCR_CLASS dcr_blend_highlights(DCRAW* p)\r\n{\r\n\tint clip=INT_MAX, row, col, c, i, j;\r\n\tstatic const float trans[2][4][4] =\r\n\t{ { { 1,1,1 }, { 1.7320508f,-1.7320508f,0 }, { -1,-1,2 } },\r\n    { { 1,1,1,1 }, { 1,-1,1,-1 }, { 1,1,-1,-1 }, { 1,-1,-1,1 } } };\r\n\tstatic const float itrans[2][4][4] =\r\n\t{ { { 1,0.8660254f,-0.5f }, { 1,-0.8660254f,-0.5f }, { 1,0,1 } },\r\n    { { 1,1,1,1 }, { 1,-1,1,-1 }, { 1,1,-1,-1 }, { 1,-1,-1,1 } } };\r\n\tfloat cam[2][4], lab[2][4], sum[2], chratio;\r\n\r\n\tif ((unsigned) (p->colors-3) > 1) return;\r\n\tif (p->opt.verbose) fprintf (stderr,_(\"Blending highlights...\\n\"));\r\n\tFORCC(p) if (clip > (i = (int)(65535*p->pre_mul[c]))) clip = i;\r\n\tfor (row=0; row < p->height; row++)\r\n\t\tfor (col=0; col < p->width; col++) {\r\n\t\t\tFORCC(p) if (p->image[row*p->width+col][c] > clip) break;\r\n\t\t\tif (c == p->colors) continue;\r\n\t\t\tFORCC(p) {\r\n\t\t\t\tcam[0][c] = p->image[row*p->width+col][c];\r\n\t\t\t\tcam[1][c] = MIN(cam[0][c],clip);\r\n\t\t\t}\r\n\t\t\tfor (i=0; i < 2; i++) {\r\n\t\t\t\tFORCC(p) for (lab[i][c]=0, j=0; j < p->colors; j++)\r\n\t\t\t\t\tlab[i][c] += trans[p->colors-3][c][j] * cam[i][j];\r\n\t\t\t\tfor (sum[i]=0,c=1; c < p->colors; c++)\r\n\t\t\t\t\tsum[i] += SQR(lab[i][c]);\r\n\t\t\t}\r\n\t\t\tchratio = (float)sqrt(sum[1]/sum[0]);\r\n\t\t\tfor (c=1; c < p->colors; c++)\r\n\t\t\t\tlab[0][c] *= chratio;\r\n\t\t\tFORCC(p) for (cam[0][c]=0, j=0; j < p->colors; j++)\r\n\t\t\t\tcam[0][c] += itrans[p->colors-3][c][j] * lab[0][j];\r\n\t\t\tFORCC(p) p->image[row*p->width+col][c] = (unsigned short)(cam[0][c] / p->colors);\r\n\t\t}\r\n}\r\n\r\n#define SCALE (4 >> p->shrink)\r\nvoid DCR_CLASS dcr_recover_highlights(DCRAW* p)\r\n{\r\n\tfloat *map, sum, wgt, grow;\r\n\tint hsat[4], count, spread, change, val, i, c;\r\n\tunsigned high, wide, mrow, mcol, row, col, kc, d, y, x;\r\n\tushort *pixel;\r\n\tstatic const signed char dir[8][2] =\r\n    { {-1,-1}, {-1,0}, {-1,1}, {0,1}, {1,1}, {1,0}, {1,-1}, {0,-1} };\r\n\r\n\tif (p->opt.verbose) fprintf (stderr,_(\"Rebuilding highlights...\\n\"));\r\n\r\n\tgrow = (float)pow (2, 4-p->opt.highlight);\r\n\tFORCC(p) hsat[c] = (int)(32000 * p->pre_mul[c]);\r\n\tfor (kc=0, c=1; (int)c < p->colors; c++)\r\n\t\tif (p->pre_mul[kc] < p->pre_mul[c]) kc = c;\r\n\t\thigh = p->height / SCALE;\r\n\t\twide =  p->width / SCALE;\r\n\t\tmap = (float *) calloc (high*wide, sizeof *map);\r\n\t\tdcr_merror (p, map, \"recover_highlights()\");\r\n\t\tFORCC(p) if ((unsigned int)c != kc) {\r\n\t\t\tmemset (map, 0, high*wide*sizeof *map);\r\n\t\t\tfor (mrow=0; mrow < high; mrow++)\r\n\t\t\t\tfor (mcol=0; mcol < wide; mcol++) {\r\n\t\t\t\t\tsum = wgt = 0;\r\n\t\t\t\t\tcount = 0;\r\n\t\t\t\t\tfor (row = mrow*SCALE; row < (mrow+1)*SCALE; row++)\r\n\t\t\t\t\t\tfor (col = mcol*SCALE; col < (mcol+1)*SCALE; col++) {\r\n\t\t\t\t\t\t\tpixel = p->image[row*p->width+col];\r\n\t\t\t\t\t\t\tif (pixel[c] / hsat[c] == 1 && pixel[kc] > 24000) {\r\n\t\t\t\t\t\t\t\tsum += pixel[c];\r\n\t\t\t\t\t\t\t\twgt += pixel[kc];\r\n\t\t\t\t\t\t\t\tcount++;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (count == SCALE*SCALE)\r\n\t\t\t\t\t\t\tmap[mrow*wide+mcol] = sum / wgt;\r\n\t\t\t\t}\r\n\t\t\tfor (spread = (int)(32/grow); spread--; ) {\r\n\t\t\t\tfor (mrow=0; mrow < high; mrow++)\r\n\t\t\t\t\tfor (mcol=0; mcol < wide; mcol++) {\r\n\t\t\t\t\t\tif (map[mrow*wide+mcol]) continue;\r\n\t\t\t\t\t\tsum = 0;\r\n\t\t\t\t\t\tcount = 0;\r\n\t\t\t\t\t\tfor (d=0; d < 8; d++) {\r\n\t\t\t\t\t\t\ty = mrow + dir[d][0];\r\n\t\t\t\t\t\t\tx = mcol + dir[d][1];\r\n\t\t\t\t\t\t\tif (y < high && x < wide && map[y*wide+x] > 0) {\r\n\t\t\t\t\t\t\t\tsum  += (1 + (d & 1)) * map[y*wide+x];\r\n\t\t\t\t\t\t\t\tcount += 1 + (d & 1);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (count > 3)\r\n\t\t\t\t\t\t\tmap[mrow*wide+mcol] = - (sum+grow) / (count+grow);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tfor (change=i=0; i < (int)(high*wide); i++)\r\n\t\t\t\t\t\tif (map[i] < 0) {\r\n\t\t\t\t\t\t\tmap[i] = -map[i];\r\n\t\t\t\t\t\t\tchange = 1;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (!change) break;\r\n\t\t\t}\r\n\t\t\tfor (i=0; i < (int)(high*wide); i++)\r\n\t\t\t\tif (map[i] == 0) map[i] = 1;\r\n\t\t\tfor (mrow=0; mrow < high; mrow++)\r\n\t\t\t\tfor (mcol=0; mcol < wide; mcol++) {\r\n\t\t\t\t\tfor (row = mrow*SCALE; row < (mrow+1)*SCALE; row++)\r\n\t\t\t\t\t\tfor (col = mcol*SCALE; col < (mcol+1)*SCALE; col++) {\r\n\t\t\t\t\t\t\tpixel = p->image[row*p->width+col];\r\n\t\t\t\t\t\t\tif (pixel[c] / hsat[c] > 1) {\r\n\t\t\t\t\t\t\t\tval = (int)(pixel[kc] * map[mrow*wide+mcol]);\r\n\t\t\t\t\t\t\t\tif (pixel[c] < val) pixel[c] = CLIP(val);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t}\r\n\t\tfree (map);\r\n}\r\n#undef SCALE\r\n\r\nvoid DCR_CLASS dcr_tiff_get (DCRAW* p, unsigned base,\r\n\t\t\t\t\t\t\t unsigned *tag, unsigned *type, unsigned *len, unsigned *save)\r\n{\r\n\t*tag  = dcr_get2(p);\r\n\t*type = dcr_get2(p);\r\n\t*len  = dcr_get4(p);\r\n\t*save = dcr_ftell(p->obj_) + 4;\r\n\tif (*len * (\"11124811248488\"[*type < 14 ? *type:0]-'0') > 4)\r\n\t\tdcr_fseek(p->obj_, dcr_get4(p)+base, SEEK_SET);\r\n}\r\n\r\nvoid DCR_CLASS dcr_parse_thumb_note (DCRAW* p, int base, unsigned toff, unsigned tlen)\r\n{\r\n\tunsigned entries, tag, type, len, save;\r\n\r\n\tentries = dcr_get2(p);\r\n\twhile (entries--) {\r\n\t\tdcr_tiff_get (p, base, &tag, &type, &len, &save);\r\n\t\tif (tag == toff) p->thumb_offset = dcr_get4(p)+base;\r\n\t\tif (tag == tlen) p->thumb_length = dcr_get4(p);\r\n\t\tdcr_fseek(p->obj_, save, SEEK_SET);\r\n\t}\r\n}\r\n\r\nint DCR_CLASS dcr_parse_tiff_ifd (DCRAW* p, int base);\r\n\r\nvoid DCR_CLASS dcr_parse_makernote (DCRAW* p, int base, int uptag)\r\n{\r\n\tstatic const uchar xlat[2][256] = {\r\n\t\t{ 0xc1,0xbf,0x6d,0x0d,0x59,0xc5,0x13,0x9d,0x83,0x61,0x6b,0x4f,0xc7,0x7f,0x3d,0x3d,\r\n\t\t0x53,0x59,0xe3,0xc7,0xe9,0x2f,0x95,0xa7,0x95,0x1f,0xdf,0x7f,0x2b,0x29,0xc7,0x0d,\r\n\t\t0xdf,0x07,0xef,0x71,0x89,0x3d,0x13,0x3d,0x3b,0x13,0xfb,0x0d,0x89,0xc1,0x65,0x1f,\r\n\t\t0xb3,0x0d,0x6b,0x29,0xe3,0xfb,0xef,0xa3,0x6b,0x47,0x7f,0x95,0x35,0xa7,0x47,0x4f,\r\n\t\t0xc7,0xf1,0x59,0x95,0x35,0x11,0x29,0x61,0xf1,0x3d,0xb3,0x2b,0x0d,0x43,0x89,0xc1,\r\n\t\t0x9d,0x9d,0x89,0x65,0xf1,0xe9,0xdf,0xbf,0x3d,0x7f,0x53,0x97,0xe5,0xe9,0x95,0x17,\r\n\t\t0x1d,0x3d,0x8b,0xfb,0xc7,0xe3,0x67,0xa7,0x07,0xf1,0x71,0xa7,0x53,0xb5,0x29,0x89,\r\n\t\t0xe5,0x2b,0xa7,0x17,0x29,0xe9,0x4f,0xc5,0x65,0x6d,0x6b,0xef,0x0d,0x89,0x49,0x2f,\r\n\t\t0xb3,0x43,0x53,0x65,0x1d,0x49,0xa3,0x13,0x89,0x59,0xef,0x6b,0xef,0x65,0x1d,0x0b,\r\n\t\t0x59,0x13,0xe3,0x4f,0x9d,0xb3,0x29,0x43,0x2b,0x07,0x1d,0x95,0x59,0x59,0x47,0xfb,\r\n\t\t0xe5,0xe9,0x61,0x47,0x2f,0x35,0x7f,0x17,0x7f,0xef,0x7f,0x95,0x95,0x71,0xd3,0xa3,\r\n\t\t0x0b,0x71,0xa3,0xad,0x0b,0x3b,0xb5,0xfb,0xa3,0xbf,0x4f,0x83,0x1d,0xad,0xe9,0x2f,\r\n\t\t0x71,0x65,0xa3,0xe5,0x07,0x35,0x3d,0x0d,0xb5,0xe9,0xe5,0x47,0x3b,0x9d,0xef,0x35,\r\n\t\t0xa3,0xbf,0xb3,0xdf,0x53,0xd3,0x97,0x53,0x49,0x71,0x07,0x35,0x61,0x71,0x2f,0x43,\r\n\t\t0x2f,0x11,0xdf,0x17,0x97,0xfb,0x95,0x3b,0x7f,0x6b,0xd3,0x25,0xbf,0xad,0xc7,0xc5,\r\n\t\t0xc5,0xb5,0x8b,0xef,0x2f,0xd3,0x07,0x6b,0x25,0x49,0x95,0x25,0x49,0x6d,0x71,0xc7 },\r\n\t\t{ 0xa7,0xbc,0xc9,0xad,0x91,0xdf,0x85,0xe5,0xd4,0x78,0xd5,0x17,0x46,0x7c,0x29,0x4c,\r\n\t\t0x4d,0x03,0xe9,0x25,0x68,0x11,0x86,0xb3,0xbd,0xf7,0x6f,0x61,0x22,0xa2,0x26,0x34,\r\n\t\t0x2a,0xbe,0x1e,0x46,0x14,0x68,0x9d,0x44,0x18,0xc2,0x40,0xf4,0x7e,0x5f,0x1b,0xad,\r\n\t\t0x0b,0x94,0xb6,0x67,0xb4,0x0b,0xe1,0xea,0x95,0x9c,0x66,0xdc,0xe7,0x5d,0x6c,0x05,\r\n\t\t0xda,0xd5,0xdf,0x7a,0xef,0xf6,0xdb,0x1f,0x82,0x4c,0xc0,0x68,0x47,0xa1,0xbd,0xee,\r\n\t\t0x39,0x50,0x56,0x4a,0xdd,0xdf,0xa5,0xf8,0xc6,0xda,0xca,0x90,0xca,0x01,0x42,0x9d,\r\n\t\t0x8b,0x0c,0x73,0x43,0x75,0x05,0x94,0xde,0x24,0xb3,0x80,0x34,0xe5,0x2c,0xdc,0x9b,\r\n\t\t0x3f,0xca,0x33,0x45,0xd0,0xdb,0x5f,0xf5,0x52,0xc3,0x21,0xda,0xe2,0x22,0x72,0x6b,\r\n\t\t0x3e,0xd0,0x5b,0xa8,0x87,0x8c,0x06,0x5d,0x0f,0xdd,0x09,0x19,0x93,0xd0,0xb9,0xfc,\r\n\t\t0x8b,0x0f,0x84,0x60,0x33,0x1c,0x9b,0x45,0xf1,0xf0,0xa3,0x94,0x3a,0x12,0x77,0x33,\r\n\t\t0x4d,0x44,0x78,0x28,0x3c,0x9e,0xfd,0x65,0x57,0x16,0x94,0x6b,0xfb,0x59,0xd0,0xc8,\r\n\t\t0x22,0x36,0xdb,0xd2,0x63,0x98,0x43,0xa1,0x04,0x87,0x86,0xf7,0xa6,0x26,0xbb,0xd6,\r\n\t\t0x59,0x4d,0xbf,0x6a,0x2e,0xaa,0x2b,0xef,0xe6,0x78,0xb6,0x4e,0xe0,0x2f,0xdc,0x7c,\r\n\t\t0xbe,0x57,0x19,0x32,0x7e,0x2a,0xd0,0xb8,0xba,0x29,0x00,0x3c,0x52,0x7d,0xa8,0x49,\r\n\t\t0x3b,0x2d,0xeb,0x25,0x49,0xfa,0xa3,0xaa,0x39,0xa7,0xc5,0xa7,0x50,0x11,0x36,0xfb,\r\n\t\t0xc6,0x67,0x4a,0xf5,0xa5,0x12,0x65,0x7e,0xb0,0xdf,0xaf,0x4e,0xb3,0x61,0x7f,0x2f } };\r\n\tunsigned offset=0, entries, tag, type, len, save, c;\r\n\tunsigned ver97=0, serial=0, i, wbi=0, wb[4]={0,0,0,0};\r\n\tuchar buf97[324], ci, cj, ck;\r\n\tshort sorder=p->order;\r\n\tchar buf[10];\r\n\t/*\r\n\tThe MakerNote might have its own TIFF header (possibly with\r\n\tits own byte-order!), or it might just be a table.\r\n\t*/\r\n\tdcr_fread(p->obj_, buf, 1, 10);\r\n\tif (!strncmp (buf,\"KDK\" ,3) ||\t/* these aren't TIFF tables */\r\n\t\t!strncmp (buf,\"VER\" ,3) ||\r\n\t\t!strncmp (buf,\"IIII\",4) ||\r\n\t\t!strncmp (buf,\"MMMM\",4)) return;\r\n\tif (!strncmp (buf,\"KC\"  ,2) ||\t/* Konica KD-400Z, KD-510Z */\r\n\t\t!strncmp (buf,\"MLY\" ,3)) {\t/* Minolta DiMAGE G series */\r\n\t\tp->order = 0x4d4d;\r\n\t\twhile ((long)(i=dcr_ftell(p->obj_)) < p->data_offset && i < 16384) {\r\n\t\t\twb[0] = wb[2];  wb[2] = wb[1];  wb[1] = wb[3];\r\n\t\t\twb[3] = dcr_get2(p);\r\n\t\t\tif (wb[1] == 256 && wb[3] == 256 &&\r\n\t\t\t\twb[0] > 256 && wb[0] < 640 && wb[2] > 256 && wb[2] < 640)\r\n\t\t\t\tFORC4 p->cam_mul[c] = (float)wb[c];\r\n\t\t}\r\n\t\tgoto quit;\r\n\t}\r\n\tif (!strcmp (buf,\"Nikon\")) {\r\n\t\tbase = dcr_ftell(p->obj_);\r\n\t\tp->order = dcr_get2(p);\r\n\t\tif (dcr_get2(p) != 42) goto quit;\r\n\t\toffset = dcr_get4(p);\r\n\t\tdcr_fseek(p->obj_, offset-8, SEEK_CUR);\r\n\t} else if (!strcmp (buf,\"OLYMPUS\")) {\r\n\t\tbase = dcr_ftell(p->obj_)-10;\r\n\t\tdcr_fseek(p->obj_, -2, SEEK_CUR);\r\n\t\tp->order = dcr_get2(p);  dcr_get2(p);\r\n\t} else if (!strncmp (buf,\"FUJIFILM\",8) ||\r\n\t\t!strncmp (buf,\"SONY\",4) ||\r\n\t\t!strcmp  (buf,\"Panasonic\")) {\r\n\t\tp->order = 0x4949;\r\n\t\tdcr_fseek(p->obj_,  2, SEEK_CUR);\r\n\t} else if (!strcmp (buf,\"OLYMP\") ||\r\n\t\t!strcmp (buf,\"LEICA\") ||\r\n\t\t!strcmp (buf,\"Ricoh\") ||\r\n\t\t!strcmp (buf,\"EPSON\"))\r\n\t\tdcr_fseek(p->obj_, -2, SEEK_CUR);\r\n\telse if (!strcmp (buf,\"AOC\") ||\r\n\t\t!strcmp (buf,\"QVC\"))\r\n\t\tdcr_fseek(p->obj_, -4, SEEK_CUR);\r\n\telse dcr_fseek(p->obj_, -10, SEEK_CUR);\r\n\r\n\tentries = dcr_get2(p);\r\n\tif (entries > 1000) return;\r\n\twhile (entries--) {\r\n\t\tdcr_tiff_get (p, base, &tag, &type, &len, &save);\r\n\t\ttag |= uptag << 16;\r\n\t\tif (tag == 2 && strstr(p->make,\"NIKON\"))\r\n\t\t\tp->iso_speed = (dcr_get2(p),dcr_get2(p));\r\n\t\tif (tag == 4 && len > 26 && len < 35) {\r\n\t\t\tif ((i=(dcr_get4(p),dcr_get2(p))) != 0x7fff && !p->iso_speed)\r\n\t\t\t\tp->iso_speed = 50 * (float)pow (2, i/32.0 - 4);\r\n\t\t\tif ((i=(dcr_get2(p),dcr_get2(p))) != 0x7fff && !p->aperture)\r\n\t\t\t\tp->aperture = (float)pow (2, i/64.0);\r\n\t\t\tif ((i=dcr_get2(p)) != 0xffff && !p->shutter)\r\n\t\t\t\tp->shutter = (float)pow (2, (short) i/-32.0);\r\n\t\t\twbi = (dcr_get2(p),dcr_get2(p));\r\n\t\t\tp->shot_order = (dcr_get2(p),dcr_get2(p));\r\n\t\t}\r\n\t\tif (tag == 7 && type == 2 && len > 20)\r\n\t\t\tdcr_fgets (p->obj_, p->model2, 64);\r\n\t\tif (tag == 8 && type == 4)\r\n\t\t\tp->shot_order = dcr_get4(p);\r\n\t\tif (tag == 9 && !strcmp(p->make,\"Canon\"))\r\n\t\t\tdcr_fread(p->obj_, p->artist, 64, 1);\r\n\t\tif (tag == 0xc && len == 4) {\r\n\t\t\tp->cam_mul[0] = (float)dcr_getreal(p,type);\r\n\t\t\tp->cam_mul[2] = (float)dcr_getreal(p,type);\r\n\t\t}\r\n\t\tif (tag == 0x10 && type == 4)\r\n\t\t\tp->unique_id = dcr_get4(p);\r\n\t\tif (tag == 0x11 && p->is_raw && !strncmp(p->make,\"NIKON\",5)) {\r\n\t\t\tdcr_fseek(p->obj_, dcr_get4(p)+base, SEEK_SET);\r\n\t\t\tdcr_parse_tiff_ifd (p, base);\r\n\t\t}\r\n\t\tif (tag == 0x14 && len == 2560 && type == 7) {\r\n\t\t\tdcr_fseek(p->obj_, 1248, SEEK_CUR);\r\n\t\t\tgoto get2_256;\r\n\t\t}\r\n\t\tif (tag == 0x15 && type == 2 && p->is_raw)\r\n\t\t\tdcr_fread(p->obj_, p->model, 64, 1);\r\n\t\tif (strstr(p->make,\"PENTAX\")) {\r\n\t\t\tif (tag == 0x1b) tag = 0x1018;\r\n\t\t\tif (tag == 0x1c) tag = 0x1017;\r\n\t\t}\r\n\t\tif (tag == 0x1d)\r\n\t\t\twhile ((c = dcr_fgetc(p->obj_)) && c != EOF)\r\n\t\t\t\tserial = serial*10 + (isdigit(c) ? c - '0' : c % 10);\r\n\t\tif (tag == 0x81 && type == 4) {\r\n\t\t\tp->data_offset = dcr_get4(p);\r\n\t\t\tdcr_fseek(p->obj_, p->data_offset + 41, SEEK_SET);\r\n\t\t\tp->raw_height = dcr_get2(p) * 2;\r\n\t\t\tp->raw_width  = dcr_get2(p);\r\n\t\t\tp->filters = 0x61616161;\r\n\t\t}\r\n\t\tif (tag == 0x29 && type == 1) {\r\n\t\t\tc = wbi < 18 ? \"012347800000005896\"[wbi]-'0' : 0;\r\n\t\t\tdcr_fseek(p->obj_, 8 + c*32, SEEK_CUR);\r\n\t\t\tFORC4 p->cam_mul[c ^ (c >> 1) ^ 1] = (float)dcr_get4(p);\r\n\t\t}\r\n\t\tif ((tag == 0x81  && type == 7) ||\r\n\t\t\t(tag == 0x100 && type == 7) ||\r\n\t\t\t(tag == 0x280 && type == 1)) {\r\n\t\t\tp->thumb_offset = dcr_ftell(p->obj_);\r\n\t\t\tp->thumb_length = len;\r\n\t\t}\r\n\t\tif (tag == 0x88 && type == 4 && (p->thumb_offset = dcr_get4(p)))\r\n\t\t\tp->thumb_offset += base;\r\n\t\tif (tag == 0x89 && type == 4)\r\n\t\t\tp->thumb_length = dcr_get4(p);\r\n\t\tif (tag == 0x8c || tag == 0x96)\r\n\t\t\tp->meta_offset = dcr_ftell(p->obj_);\r\n\t\tif (tag == 0x97) {\r\n\t\t\tfor (i=0; i < 4; i++)\r\n\t\t\t\tver97 = ver97 * 10 + dcr_fgetc(p->obj_)-'0';\r\n\t\t\tswitch (ver97) {\r\n\t\t\tcase 100:\r\n\t\t\t\tdcr_fseek(p->obj_, 68, SEEK_CUR);\r\n\t\t\t\tFORC4 p->cam_mul[(c >> 1) | ((c & 1) << 1)] = dcr_get2(p);\r\n\t\t\t\tbreak;\r\n\t\t\tcase 102:\r\n\t\t\t\tdcr_fseek(p->obj_, 6, SEEK_CUR);\r\n\t\t\t\tgoto get2_rggb;\r\n\t\t\tcase 103:\r\n\t\t\t\tdcr_fseek(p->obj_, 16, SEEK_CUR);\r\n\t\t\t\tFORC4 p->cam_mul[c] = dcr_get2(p);\r\n\t\t\t}\r\n\t\t\tif (ver97 >= 200) {\r\n\t\t\t\tif (ver97 != 205) dcr_fseek(p->obj_, 280, SEEK_CUR);\r\n\t\t\t\tdcr_fread(p->obj_, buf97, 324, 1);\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (tag == 0xa4 && type == 3) {\r\n\t\t\tdcr_fseek(p->obj_, wbi*48, SEEK_CUR);\r\n\t\t\tFORC3 p->cam_mul[c] = dcr_get2(p);\r\n\t\t}\r\n\t\tif (tag == 0xa7 && (unsigned) (ver97-200) < 12 && !p->cam_mul[0]) {\r\n\t\t\tci = xlat[0][serial & 0xff];\r\n\t\t\tcj = xlat[1][dcr_fgetc(p->obj_)^dcr_fgetc(p->obj_)^dcr_fgetc(p->obj_)^dcr_fgetc(p->obj_)];\r\n\t\t\tck = 0x60;\r\n\t\t\tfor (i=0; i < 324; i++)\r\n\t\t\t\tbuf97[i] ^= (cj += ci * ck++);\r\n\t\t\ti = \"66666>666;6A\"[ver97-200] - '0';\r\n\t\t\tFORC4 p->cam_mul[c ^ (c >> 1) ^ (i & 1)] =\r\n\t\t\t\tdcr_sget2 (p, buf97 + (i & -2) + c*2);\r\n\t\t}\r\n\t\tif (tag == 0x200 && len == 3)\r\n\t\t\tp->shot_order = (dcr_get4(p),dcr_get4(p));\r\n\t\tif (tag == 0x200 && len == 4)\r\n\t\t\tp->black = (dcr_get2(p)+dcr_get2(p)+dcr_get2(p)+dcr_get2(p))/4;\r\n\t\tif (tag == 0x201 && len == 4)\r\n\t\t\tgoto get2_rggb;\r\n\t\tif (tag == 0x220 && len == 53) {\r\n\t\t\tdcr_fseek (p->obj_, 14, SEEK_CUR);\r\n\t\t\tdcr_pentax_tree(p);\r\n\t\t}\r\n\t\tif (tag == 0x401 && len == 4) {\r\n\t\t\tp->black = (dcr_get4(p)+dcr_get4(p)+dcr_get4(p)+dcr_get4(p))/4;\r\n\t\t}\r\n\t\tif (tag == 0xe01) {\t\t/* Nikon Capture Note */\r\n\t\t\ttype = p->order;\r\n\t\t\tp->order = 0x4949;\r\n\t\t\tdcr_fseek(p->obj_, 22, SEEK_CUR);\r\n\t\t\tfor (offset=22; offset+22 < len; offset += 22+i) {\r\n\t\t\t\ttag = dcr_get4(p);\r\n\t\t\t\tdcr_fseek(p->obj_, 14, SEEK_CUR);\r\n\t\t\t\ti = dcr_get4(p)-4;\r\n\t\t\t\tif (tag == 0x76a43207) p->flip = dcr_get2(p);\r\n\t\t\t\telse dcr_fseek(p->obj_, i, SEEK_CUR);\r\n\t\t\t}\r\n\t\t\tp->order = type;\r\n\t\t}\r\n\t\tif (tag == 0xe80 && len == 256 && type == 7) {\r\n\t\t\tdcr_fseek(p->obj_, 48, SEEK_CUR);\r\n\t\t\tp->cam_mul[0] = dcr_get2(p) * 508 * 1.078f / 0x10000;\r\n\t\t\tp->cam_mul[2] = dcr_get2(p) * 382 * 1.173f / 0x10000;\r\n\t\t}\r\n\t\tif (tag == 0xf00 && type == 7) {\r\n\t\t\tif (len == 614)\r\n\t\t\t\tdcr_fseek(p->obj_, 176, SEEK_CUR);\r\n\t\t\telse if (len == 734 || len == 1502)\r\n\t\t\t\tdcr_fseek(p->obj_, 148, SEEK_CUR);\r\n\t\t\telse goto next;\r\n\t\t\tgoto get2_256;\r\n\t\t}\r\n\t\tif ((tag == 0x1011 && len == 9) || tag == 0x20400200)\r\n\t\t\tfor (i=0; i < 3; i++)\r\n\t\t\t\tFORC3 p->cmatrix[i][c] = ((short) dcr_get2(p)) / 256.0f;\r\n\t\tif ((tag == 0x1012 || tag == 0x20400600) && len == 4)\r\n\t\t\tfor (p->black = i=0; i < 4; i++)\r\n\t\t\t\tp->black += dcr_get2(p) << 2;\r\n\t\tif (tag == 0x1017 || tag == 0x20400100)\r\n\t\t\tp->cam_mul[0] = dcr_get2(p) / 256.0f;\r\n\t\tif (tag == 0x1018 || tag == 0x20400100)\r\n\t\t\tp->cam_mul[2] = dcr_get2(p) / 256.0f;\r\n\t\tif (tag == 0x2011 && len == 2) {\r\nget2_256:\r\n\t\tp->order = 0x4d4d;\r\n\t\tp->cam_mul[0] = dcr_get2(p) / 256.0f;\r\n\t\tp->cam_mul[2] = dcr_get2(p) / 256.0f;\r\n\t\t}\r\n\t\tif ((tag | 0x70) == 0x2070 && type == 4)\r\n\t\t\tdcr_fseek(p->obj_, dcr_get4(p)+base, SEEK_SET);\r\n\t\tif (tag == 0x2010 && type != 7)\r\n\t\t\tp->load_raw = &DCR_CLASS dcr_olympus_e410_load_raw;\r\n\t\tif (tag == 0x2020)\r\n\t\t\tdcr_parse_thumb_note (p, base, 257, 258);\r\n\t\tif (tag == 0x2040)\r\n\t\t\tdcr_parse_makernote (p, base, 0x2040);\r\n\t\tif (tag == 0xb028) {\r\n\t\t\tdcr_fseek(p->obj_, dcr_get4(p), SEEK_SET);\r\n\t\t\tdcr_parse_thumb_note (p, base, 136, 137);\r\n\t\t}\r\n\t\tif (tag == 0x4001 && len > 500) {\r\n\t\t\ti = len == 582 ? 50 : len == 653 ? 68 : len == 5120 ? 142 : 126;\r\n\t\t\tdcr_fseek(p->obj_, i, SEEK_CUR);\r\nget2_rggb:\r\n\t\t\tFORC4 p->cam_mul[c ^ (c >> 1)] = dcr_get2(p);\r\n\t\t\tdcr_fseek(p->obj_, 22, SEEK_CUR);\r\n\t\t\tFORC4 p->sraw_mul[c ^ (c >> 1)] = dcr_get2(p);\r\n\t\t}\r\nnext:\r\n\t\tdcr_fseek(p->obj_, save, SEEK_SET);\r\n  }\r\nquit:\r\n  p->order = sorder;\r\n}\r\n\r\n/*\r\nSince the TIFF DateTime string has no timezone information,\r\nassume that the camera's clock was set to Universal Time.\r\n*/\r\nvoid DCR_CLASS dcr_get_timestamp (DCRAW* p, int reversed)\r\n{\r\n\tstruct tm t;\r\n\tchar str[20];\r\n\tint i;\r\n\r\n\tstr[19] = 0;\r\n\tif (reversed)\r\n\t\tfor (i=19; i--; ) str[i] = dcr_fgetc(p->obj_);\r\n\telse\r\n\t\tdcr_fread(p->obj_, str, 19, 1);\r\n\tmemset (&t, 0, sizeof t);\r\n\tif (sscanf (str, \"%d:%d:%d %d:%d:%d\", &t.tm_year, &t.tm_mon,\r\n\t\t&t.tm_mday, &t.tm_hour, &t.tm_min, &t.tm_sec) != 6)\r\n\t\treturn;\r\n\tt.tm_year -= 1900;\r\n\tt.tm_mon -= 1;\r\n\tif (mktime(&t) > 0)\r\n\t\tp->timestamp = mktime(&t);\r\n}\r\n\r\nvoid DCR_CLASS dcr_parse_exif (DCRAW* p, int base)\r\n{\r\n\tunsigned kodak, entries, tag, type, len, save, c;\r\n\tdouble expo;\r\n\r\n\tkodak = !strncmp(p->make,\"EASTMAN\",7);\r\n\tentries = dcr_get2(p);\r\n\twhile (entries--) {\r\n\t\tdcr_tiff_get (p, base, &tag, &type, &len, &save);\r\n\t\tswitch (tag) {\r\n\t\tcase 33434:  p->shutter = (float)dcr_getreal(p,type);\t\t\tbreak;\r\n\t\tcase 33437:  p->aperture = (float)dcr_getreal(p,type);\t\t\tbreak;\r\n\t\tcase 34855:  p->iso_speed = dcr_get2(p);\t\t\tbreak;\r\n\t\tcase 36867:\r\n\t\tcase 36868:  dcr_get_timestamp(p,0);\t\t\tbreak;\r\n\t\tcase 37377:  if ((expo = -dcr_getreal(p,type)) < 128)\r\n\t\t\t\t\t\t p->shutter = (float)pow (2, expo);\t\tbreak;\r\n\t\tcase 37378:  p->aperture = (float)pow (2, dcr_getreal(p,type)/2);\tbreak;\r\n\t\tcase 37386:  p->focal_len = (float)dcr_getreal(p,type);\t\tbreak;\r\n\t\tcase 37500:  dcr_parse_makernote (p,base, 0);\t\tbreak;\r\n\t\tcase 40962:  if (kodak) p->raw_width  = dcr_get4(p);\tbreak;\r\n\t\tcase 40963:  if (kodak) p->raw_height = dcr_get4(p);\tbreak;\r\n\t\tcase 41730:\r\n\t\t\tif (dcr_get4(p) == 0x20002)\r\n\t\t\t\tfor (p->exif_cfa=c=0; c < 8; c+=2)\r\n\t\t\t\t\tp->exif_cfa |= dcr_fgetc(p->obj_) * 0x01010101 << c;\r\n\t\t}\r\n\t\tdcr_fseek(p->obj_, save, SEEK_SET);\r\n\t}\r\n}\r\n\r\nvoid DCR_CLASS dcr_parse_gps (DCRAW* p, int base)\r\n{\r\n  unsigned entries, tag, type, len, save, c;\r\n\r\n  entries = dcr_get2(p);\r\n  while (entries--) {\r\n    dcr_tiff_get (p, base, &tag, &type, &len, &save);\r\n    switch (tag) {\r\n    case 1: case 3: case 5:\r\n\t  p->gpsdata[29+tag/2] = dcr_fgetc(p->obj_);\tbreak;\r\n    case 2: case 4: case 7:\r\n\t  FORC(6) p->gpsdata[tag/3*6+c] = dcr_get4(p);\tbreak;\r\n    case 6:\r\n\t  FORC(2) p->gpsdata[18+c] = dcr_get4(p);\t\tbreak;\r\n    case 18: case 29:\r\n\t  dcr_fgets(p->obj_, (char *) (p->gpsdata+14+tag/3), MIN(len,12));\r\n    }\r\n    dcr_fseek(p->obj_, save, SEEK_SET);\r\n  }\r\n}\r\n\r\nvoid DCR_CLASS dcr_romm_coeff (DCRAW* p, float romm_cam[3][3])\r\n{\r\n\tstatic const float rgb_romm[3][3] =\t/* ROMM == Kodak ProPhoto */\r\n\t{ {  2.034193f, -0.727420f, -0.306766f },\r\n    { -0.228811f,  1.231729f, -0.002922f },\r\n    { -0.008565f, -0.153273f,  1.161839f } };\r\n\tint i, j, k;\r\n\r\n\tfor (i=0; i < 3; i++)\r\n\t\tfor (j=0; j < 3; j++)\r\n\t\t\tfor (p->cmatrix[i][j]=0, k=0; k < 3; k++)\r\n\t\t\t\tp->cmatrix[i][j] += rgb_romm[i][k] * romm_cam[k][j];\r\n}\r\n\r\nvoid DCR_CLASS dcr_parse_mos (DCRAW* p, int offset)\r\n{\r\n\tchar data[40];\r\n\tint skip, from, i=0, c, neut[4], planes=0, frot=0;\r\n\tstatic const char *mod[] =\r\n\t{ \"\",\"DCB2\",\"Volare\",\"Cantare\",\"CMost\",\"Valeo 6\",\"Valeo 11\",\"Valeo 22\",\r\n    \"Valeo 11p\",\"Valeo 17\",\"\",\"Aptus 17\",\"Aptus 22\",\"Aptus 75\",\"Aptus 65\",\r\n    \"Aptus 54S\",\"Aptus 65S\",\"Aptus 75S\",\"AFi 5\",\"AFi 6\",\"AFi 7\" };\r\n\tfloat romm_cam[3][3];\r\n\r\n\tdcr_fseek(p->obj_, offset, SEEK_SET);\r\n\twhile (1) {\r\n\t\tif (dcr_get4(p) != 0x504b5453) break;\r\n\t\tdcr_get4(p);\r\n\t\tdcr_fread(p->obj_, data, 1, 40);\r\n\t\tskip = dcr_get4(p);\r\n\t\tfrom = dcr_ftell(p->obj_);\r\n\t\tif (!strcmp(data,\"JPEG_preview_data\")) {\r\n\t\t\tp->thumb_offset = from;\r\n\t\t\tp->thumb_length = skip;\r\n\t\t}\r\n\t\tif (!strcmp(data,\"icc_camera_profile\")) {\r\n\t\t\tp->profile_offset = from;\r\n\t\t\tp->profile_length = skip;\r\n\t\t}\r\n\t\tif (!strcmp(data,\"ShootObj_back_type\")) {\r\n\t\t\tdcr_fscanf(p->obj_, \"%d\", &i);\r\n\t\t\tif ((unsigned) i < sizeof mod / sizeof (*mod))\r\n\t\t\t\tstrcpy (p->model, mod[i]);\r\n\t\t}\r\n\t\tif (!strcmp(data,\"icc_camera_to_tone_matrix\")) {\r\n\t\t\tfor (i=0; i < 9; i++)\r\n\t\t\t\tromm_cam[0][i] = dcr_int_to_float(dcr_get4(p));\r\n\t\t\tdcr_romm_coeff (p,romm_cam);\r\n\t\t}\r\n\t\tif (!strcmp(data,\"CaptProf_color_matrix\")) {\r\n\t\t\tfor (i=0; i < 9; i++)\r\n\t\t\t\tdcr_fscanf(p->obj_, \"%f\", &romm_cam[0][i]);\r\n\t\t\tdcr_romm_coeff (p,romm_cam);\r\n\t\t}\r\n\t\tif (!strcmp(data,\"CaptProf_number_of_planes\"))\r\n\t\t\tdcr_fscanf(p->obj_, \"%d\", &planes);\r\n\t\tif (!strcmp(data,\"CaptProf_raw_data_rotation\"))\r\n\t\t\tdcr_fscanf(p->obj_, \"%d\", &p->flip);\r\n\t\tif (!strcmp(data,\"CaptProf_mosaic_pattern\"))\r\n\t\t\tFORC4 {\r\n\t\t\tdcr_fscanf(p->obj_, \"%d\", &i);\r\n\t\t\tif (i == 1) frot = c ^ (c >> 1);\r\n\t\t}\r\n\t\tif (!strcmp(data,\"ImgProf_rotation_angle\")) {\r\n\t\t\tdcr_fscanf(p->obj_, \"%d\", &i);\r\n\t\t\tp->flip = i - p->flip;\r\n\t\t}\r\n\t\tif (!strcmp(data,\"NeutObj_neutrals\") && !p->cam_mul[0]) {\r\n\t\t\tFORC4 dcr_fscanf(p->obj_, \"%d\", neut+c);\r\n\t\t\tFORC3 p->cam_mul[c] = (neut[c+1] ? (float) neut[0] / neut[c+1] : 0);\r\n\t\t}\r\n\t\tdcr_parse_mos (p,from);\r\n\t\tdcr_fseek(p->obj_, skip+from, SEEK_SET);\r\n\t}\r\n\tif (planes)\r\n\t\tp->filters = (planes == 1) * 0x01010101 *\r\n\t\t(uchar) \"\\x94\\x61\\x16\\x49\"[(p->flip/90 + frot) & 3];\r\n}\r\n\r\nvoid DCR_CLASS dcr_linear_table (DCRAW* p, unsigned len)\r\n{\r\n\tint i;\r\n\tif (len > 0x1000) len = 0x1000;\r\n\tdcr_read_shorts (p, p->curve, len);\r\n\tfor (i=len; i < 0x1000; i++)\r\n\t\tp->curve[i] = p->curve[i-1];\r\n\tp->maximum = p->curve[0xfff];\r\n}\r\n\r\nvoid DCR_CLASS dcr_parse_kodak_ifd (DCRAW* p, int base)\r\n{\r\n\tunsigned entries, tag, type, len, save;\r\n\tint i, c, wbi=-2, wbtemp=6500;\r\n\tfloat mul[3], num;\r\n\r\n\tentries = dcr_get2(p);\r\n\tif (entries > 1024) return;\r\n\twhile (entries--) {\r\n\t\tdcr_tiff_get (p, base, &tag, &type, &len, &save);\r\n\t\tif (tag == 1020) wbi = dcr_getint(p, type);\r\n\t\tif (tag == 1021 && len == 72) {\t\t/* WB set in software */\r\n\t\t\tdcr_fseek(p->obj_, 40, SEEK_CUR);\r\n\t\t\tFORC3 p->cam_mul[c] = 2048.0f / dcr_get2(p);\r\n\t\t\twbi = -2;\r\n\t\t}\r\n\t\tif (tag == (unsigned int)2118) wbtemp = dcr_getint(p, type);\r\n\t\tif (tag == (unsigned int)2130 + wbi)\r\n\t\t\tFORC3 mul[c] = (float)dcr_getreal(p, type);\r\n\t\tif (tag == (unsigned int)2140 + wbi && wbi >= 0)\r\n\t\t\tFORC3 {\r\n\t\t\tfor (num=0.0f, i=0; i < 4; i++)\r\n\t\t\t\tnum += (float)(dcr_getreal(p, type) * pow (wbtemp/100.0, i));\r\n\t\t\tp->cam_mul[c] = 2048 / (num * mul[c]);\r\n\t\t}\r\n\t\tif (tag == 2317) dcr_linear_table (p,len);\r\n\t\tif (tag == 6020) p->iso_speed = (float)dcr_getint(p, type);\r\n\t\tdcr_fseek(p->obj_, save, SEEK_SET);\r\n\t}\r\n}\r\n\r\nvoid DCR_CLASS dcr_parse_minolta (DCRAW* p, int base);\r\n\r\nint DCR_CLASS dcr_parse_tiff_ifd (DCRAW* p, int base)\r\n{\r\n\tunsigned entries, tag, type, len, plen=16, save;\r\n\tint ifd, use_cm=0, cfa, i, j, c, ima_len=0;\r\n\tchar software[64], *cbuf, *cp;\r\n\tuchar cfa_pat[16], cfa_pc[] = { 0,1,2,3 }, tab[256];\r\n\tdouble dblack, cc[4][4], cm[4][3], cam_xyz[4][3], num;\r\n\tdouble ab[]={ 1,1,1,1 }, asn[] = { 0,0,0,0 }, xyz[] = { 1,1,1 };\r\n\tunsigned sony_curve[] = { 0,0,0,0,0,4095 };\r\n\tunsigned *buf, sony_offset=0, sony_length=0, sony_key=0;\r\n\tstruct dcr_jhead jh;\r\n\r\n\tif (p->tiff_nifds >= sizeof p->tiff_ifd / sizeof p->tiff_ifd[0])\r\n\t\treturn 1;\r\n\tifd = p->tiff_nifds++;\r\n\tfor (j=0; j < 4; j++)\r\n\t\tfor (i=0; i < 4; i++)\r\n\t\t\tcc[j][i] = i == j;\r\n\tentries = dcr_get2(p);\r\n\tif (entries > 512) return 1;\r\n\twhile (entries--) {\r\n\t\tdcr_tiff_get (p, base, &tag, &type, &len, &save);\r\n\t\tswitch (tag) {\r\n\t\tcase 17: case 18:\r\n\t\t\tif (type == 3 && len == 1)\r\n\t\t\t\tp->cam_mul[(tag-17)*2] = dcr_get2(p) / 256.0f;\r\n\t\t\tbreak;\r\n\t\tcase 23:\r\n\t\t\tif (type == 3) p->iso_speed = dcr_get2(p);\r\n\t\t\tbreak;\r\n\t\tcase 36: case 37: case 38:\r\n\t\t\tp->cam_mul[tag-0x24] = dcr_get2(p);\r\n\t\t\tbreak;\r\n\t\tcase 39:\r\n\t\t\tif (len < 50 || p->cam_mul[0]) break;\r\n\t\t\tdcr_fseek(p->obj_, 12, SEEK_CUR);\r\n\t\t\tFORC3 p->cam_mul[c] = dcr_get2(p);\r\n\t\t\tbreak;\r\n\t\tcase 46:\r\n\t\t\tif (type != 7 || dcr_fgetc(p->obj_) != 0xff || dcr_fgetc(p->obj_) != 0xd8) break;\r\n\t\t\tp->thumb_offset = dcr_ftell(p->obj_) - 2;\r\n\t\t\tp->thumb_length = len;\r\n\t\t\tbreak;\r\n\t\tcase 2: case 256:\t\t\t/* ImageWidth */\r\n\t\t\tp->tiff_ifd[ifd].width = dcr_getint(p, type);\r\n\t\t\tbreak;\r\n\t\tcase 3: case 257:\t\t\t/* ImageHeight */\r\n\t\t\tp->tiff_ifd[ifd].height = dcr_getint(p, type);\r\n\t\t\tbreak;\r\n\t\tcase 258:\t\t\t\t/* BitsPerSample */\r\n\t\t\tp->tiff_ifd[ifd].samples = len & 7;\r\n\t\t\tp->tiff_ifd[ifd].bps = dcr_get2(p);\r\n\t\t\tbreak;\r\n\t\tcase 259:\t\t\t\t/* Compression */\r\n\t\t\tp->tiff_ifd[ifd].comp = dcr_get2(p);\r\n\t\t\tbreak;\r\n\t\tcase 262:\t\t\t\t/* PhotometricInterpretation */\r\n\t\t\tp->tiff_ifd[ifd].phint = dcr_get2(p);\r\n\t\t\tbreak;\r\n\t\tcase 270:\t\t\t\t/* ImageDescription */\r\n\t\t\tdcr_fread(p->obj_, p->desc, 512, 1);\r\n\t\t\tbreak;\r\n\t\tcase 271:\t\t\t\t/* Make */\r\n\t\t\tdcr_fgets(p->obj_, p->make, 64);\r\n\t\t\tbreak;\r\n\t\tcase 272:\t\t\t\t/* Model */\r\n\t\t\tdcr_fgets(p->obj_, p->model, 64);\r\n\t\t\tbreak;\r\n\t\tcase 280:\t\t\t\t/* Panasonic RW2 offset */\r\n\t\t\tif (type != 4) break;\r\n\t\t\tp->load_raw = &DCR_CLASS dcr_panasonic_load_raw;\r\n\t\t\tp->load_flags = 0x2008;\r\n\t\tcase 273:\t\t\t\t/* StripOffset */\r\n\t\tcase 513:\r\n\t\t\tp->tiff_ifd[ifd].offset = dcr_get4(p)+base;\r\n\t\t\tif (!p->tiff_ifd[ifd].bps) {\r\n\t\t\t\tdcr_fseek(p->obj_, p->tiff_ifd[ifd].offset, SEEK_SET);\r\n\t\t\t\tif (dcr_ljpeg_start (p,&jh, 1)) {\r\n\t\t\t\t\tp->tiff_ifd[ifd].comp    = 6;\r\n\t\t\t\t\tp->tiff_ifd[ifd].width   = jh.wide << (jh.clrs == 2);\r\n\t\t\t\t\tp->tiff_ifd[ifd].height  = jh.high;\r\n\t\t\t\t\tp->tiff_ifd[ifd].bps     = jh.bits;\r\n\t\t\t\t\tp->tiff_ifd[ifd].samples = jh.clrs;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\tcase 274:\t\t\t\t/* Orientation */\r\n\t\t\tp->tiff_ifd[ifd].flip = \"50132467\"[dcr_get2(p) & 7]-'0';\r\n\t\t\tbreak;\r\n\t\tcase 277:\t\t\t\t/* SamplesPerPixel */\r\n\t\t\tp->tiff_ifd[ifd].samples = dcr_getint(p, type) & 7;\r\n\t\t\tbreak;\r\n\t\tcase 279:\t\t\t\t/* StripByteCounts */\r\n\t\tcase 514:\r\n\t\t\tp->tiff_ifd[ifd].bytes = dcr_get4(p);\r\n\t\t\tbreak;\r\n\t\tcase 305:  case 11:\t\t/* Software */\r\n\t\t\tdcr_fgets(p->obj_, software, 64);\r\n\t\t\tif (!strncmp(software,\"Adobe\",5) ||\r\n\t\t\t\t!strncmp(software,\"dcraw\",5) ||\r\n\t\t\t\t!strncmp(software,\"UFRaw\",5) ||\r\n\t\t\t\t!strncmp(software,\"Bibble\",6) ||\r\n\t\t\t\t!strncmp(software,\"Nikon Scan\",10) ||\r\n\t\t\t\t!strcmp (software,\"Digital Photo Professional\"))\r\n\t\t\t\tp->is_raw = 0;\r\n\t\t\tbreak;\r\n\t\tcase 306:\t\t\t\t/* DateTime */\r\n\t\t\tdcr_get_timestamp(p,0);\r\n\t\t\tbreak;\r\n\t\tcase 315:\t\t\t\t/* Artist */\r\n\t\t\tdcr_fread(p->obj_, p->artist, 64, 1);\r\n\t\t\tbreak;\r\n\t\tcase 322:\t\t\t\t/* TileWidth */\r\n\t\t\tp->tile_width = dcr_getint(p, type);\r\n\t\t\tbreak;\r\n\t\tcase 323:\t\t\t\t/* TileLength */\r\n\t\t\tp->tile_length = dcr_getint(p, type);\r\n\t\t\tbreak;\r\n\t\tcase 324:\t\t\t\t/* TileOffsets */\r\n\t\t\tp->tiff_ifd[ifd].offset = len > 1 ? dcr_ftell(p->obj_) : dcr_get4(p);\r\n\t\t\tif (len == 4) {\r\n\t\t\t\tp->load_raw = &DCR_CLASS dcr_sinar_4shot_load_raw;\r\n\t\t\t\tp->is_raw = 5;\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\tcase 330:\t\t\t\t/* SubIFDs */\r\n\t\t\tif (!strcmp(p->model,\"DSLR-A100\") && p->tiff_ifd[ifd].width == 3872) {\r\n\t\t\t\tp->load_raw = &DCR_CLASS dcr_sony_arw_load_raw;\r\n\t\t\t\tp->data_offset = dcr_get4(p)+base;\r\n\t\t\t\tifd++;  break;\r\n\t\t\t}\r\n\t\t\twhile (len--) {\r\n\t\t\t\ti = dcr_ftell(p->obj_);\r\n\t\t\t\tdcr_fseek(p->obj_, dcr_get4(p)+base, SEEK_SET);\r\n\t\t\t\tif (dcr_parse_tiff_ifd (p, base)) break;\r\n\t\t\t\tdcr_fseek(p->obj_, i+4, SEEK_SET);\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\tcase 400:\r\n\t\t\tstrcpy (p->make, \"Sarnoff\");\r\n\t\t\tp->maximum = 0xfff;\r\n\t\t\tbreak;\r\n\t\tcase 28688:\r\n\t\t\tFORC4 sony_curve[c+1] = dcr_get2(p) >> 2 & 0xfff;\r\n\t\t\tfor (i=0; i < 5; i++)\r\n\t\t\t\tfor (j = sony_curve[i]+1; j <= (int)sony_curve[i+1]; j++)\r\n\t\t\t\t\tp->curve[j] = p->curve[j-1] + (1 << i);\r\n\t\t\t\tbreak;\r\n\t\tcase 29184: sony_offset = dcr_get4(p);  break;\r\n\t\tcase 29185: sony_length = dcr_get4(p);  break;\r\n\t\tcase 29217: sony_key    = dcr_get4(p);  break;\r\n\t\tcase 29264:\r\n\t\t\tdcr_parse_minolta (p, dcr_ftell(p->obj_));\r\n\t\t\tp->raw_width = 0;\r\n\t\t\tbreak;\r\n\t\tcase 29443:\r\n\t\t\tFORC4 p->cam_mul[c ^ (c < 2)] = dcr_get2(p);\r\n\t\t\tbreak;\r\n\t\tcase 29459:\r\n\t\t\tFORC4 p->cam_mul[c ^ (c >> 1)] = dcr_get2(p);\r\n\t\t\tbreak;\r\n\t\tcase 33405:\t\t\t/* Model2 */\r\n\t\t\tdcr_fgets(p->obj_, p->model2, 64);\r\n\t\t\tbreak;\r\n\t\tcase 33422:\t\t\t/* CFAPattern */\r\n\t\tcase 64777:\t\t\t/* Kodak P-series */\r\n\t\t\tif ((plen=len) > 16) plen = 16;\r\n\t\t\tdcr_fread(p->obj_, cfa_pat, 1, plen);\r\n\t\t\tfor (p->colors=cfa=i=0; i < (int)plen; i++) {\r\n\t\t\t\tp->colors += !(cfa & (1 << cfa_pat[i]));\r\n\t\t\t\tcfa |= 1 << cfa_pat[i];\r\n\t\t\t}\r\n\t\t\tif (cfa == 070) memcpy (cfa_pc,\"\\003\\004\\005\",3);\t/* CMY */\r\n\t\t\tif (cfa == 072) memcpy (cfa_pc,\"\\005\\003\\004\\001\",4);\t/* GMCY */\r\n\t\t\tgoto guess_cfa_pc;\r\n\t\tcase 33424:\r\n\t\t\tdcr_fseek(p->obj_, dcr_get4(p)+base, SEEK_SET);\r\n\t\t\tdcr_parse_kodak_ifd (p,base);\r\n\t\t\tbreak;\r\n\t\tcase 33434:\t\t\t/* ExposureTime */\r\n\t\t\tp->shutter = (float)dcr_getreal(p,type);\r\n\t\t\tbreak;\r\n\t\tcase 33437:\t\t\t/* FNumber */\r\n\t\t\tp->aperture = (float)dcr_getreal(p,type);\r\n\t\t\tbreak;\r\n\t\tcase 34306:\t\t\t/* Leaf p->white balance */\r\n\t\t\tFORC4 p->cam_mul[c ^ 1] = 4096.0f / dcr_get2(p);\r\n\t\t\tbreak;\r\n\t\tcase 34307:\t\t\t/* Leaf CatchLight color matrix */\r\n\t\t\tdcr_fread(p->obj_, software, 1, 7);\r\n\t\t\tif (strncmp(software,\"MATRIX\",6)) break;\r\n\t\t\tp->colors = 4;\r\n\t\t\tfor (p->raw_color = i=0; i < 3; i++) {\r\n\t\t\t\tFORC4 dcr_fscanf(p->obj_, \"%f\", &p->rgb_cam[i][c^1]);\r\n\t\t\t\tif (!p->opt.use_camera_wb) continue;\r\n\t\t\t\tnum = 0;\r\n\t\t\t\tFORC4 num += p->rgb_cam[i][c];\r\n\t\t\t\tFORC4 p->rgb_cam[i][c] /= (float)num;\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\tcase 34310:\t\t\t/* Leaf metadata */\r\n\t\t\tdcr_parse_mos (p,dcr_ftell(p->obj_));\r\n\t\tcase 34303:\r\n\t\t\tstrcpy (p->make, \"Leaf\");\r\n\t\t\tbreak;\r\n\t\tcase 34665:\t\t\t/* EXIF tag */\r\n\t\t\tdcr_fseek(p->obj_, dcr_get4(p)+base, SEEK_SET);\r\n\t\t\tdcr_parse_exif (p,base);\r\n\t\t\tbreak;\r\n\t\tcase 34853:\t\t\t/* GPSInfo tag */\r\n\t\t\tdcr_fseek(p->obj_, dcr_get4(p)+base, SEEK_SET);\r\n\t\t\tdcr_parse_gps (p,base);\r\n\t\t\tbreak;\r\n\t\tcase 34675:\t\t\t/* InterColorProfile */\r\n\t\tcase 50831:\t\t\t/* AsShotICCProfile */\r\n\t\t\tp->profile_offset = dcr_ftell(p->obj_);\r\n\t\t\tp->profile_length = len;\r\n\t\t\tbreak;\r\n\t\tcase 37122:\t\t\t/* CompressedBitsPerPixel */\r\n\t\t\tp->kodak_cbpp = dcr_get4(p);\r\n\t\t\tbreak;\r\n\t\tcase 37386:\t\t\t/* FocalLength */\r\n\t\t\tp->focal_len = (float)dcr_getreal(p,type);\r\n\t\t\tbreak;\r\n\t\tcase 37393:\t\t\t/* ImageNumber */\r\n\t\t\tp->shot_order = dcr_getint(p, type);\r\n\t\t\tbreak;\r\n\t\tcase 37400:\t\t\t/* old Kodak KDC tag */\r\n\t\t\tfor (p->raw_color = i=0; i < 3; i++) {\r\n\t\t\t\tdcr_getreal(p,type);\r\n\t\t\t\tFORC3 p->rgb_cam[i][c] = (float)dcr_getreal(p,type);\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\tcase 46275:\t\t\t/* Imacon tags */\r\n\t\t\tstrcpy (p->make, \"Imacon\");\r\n\t\t\tp->data_offset = dcr_ftell(p->obj_);\r\n\t\t\tima_len = len;\r\n\t\t\tbreak;\r\n\t\tcase 46279:\r\n\t\t\tif (!ima_len) break;\r\n\t\t\tdcr_fseek(p->obj_, 78, SEEK_CUR);\r\n\t\t\tp->raw_width  = dcr_get4(p);\r\n\t\t\tp->raw_height = dcr_get4(p);\r\n\t\t\tp->left_margin = dcr_get4(p) & 7;\r\n\t\t\tp->width = p->raw_width - p->left_margin - (dcr_get4(p) & 7);\r\n\t\t\tp->top_margin = dcr_get4(p) & 7;\r\n\t\t\tp->height = p->raw_height - p->top_margin - (dcr_get4(p) & 7);\r\n\t\t\tif (p->raw_width == 7262) {\r\n\t\t\t\tp->height = 5444;\r\n\t\t\t\tp->width  = 7244;\r\n\t\t\t\tp->left_margin = 7;\r\n\t\t\t}\r\n\t\t\tdcr_fseek(p->obj_, 52, SEEK_CUR);\r\n\t\t\tFORC3 p->cam_mul[c] = (float)dcr_getreal(p, 11);\r\n\t\t\tdcr_fseek(p->obj_, 114, SEEK_CUR);\r\n\t\t\tp->flip = (dcr_get2(p) >> 7) * 90;\r\n\t\t\tif (p->width * p->height * 6 == ima_len) {\r\n\t\t\t\tif (p->flip % 180 == 90) SWAP(p->width,p->height);\r\n\t\t\t\tp->filters = p->flip = 0;\r\n\t\t\t}\r\n\t\t\tsprintf (p->model, \"Ixpress %d-Mp\", p->height*p->width/1000000);\r\n\t\t\tp->load_raw = &DCR_CLASS dcr_imacon_full_load_raw;\r\n\t\t\tif (p->filters) {\r\n\t\t\t\tif (p->left_margin & 1) p->filters = 0x61616161;\r\n\t\t\t\tp->load_raw = &DCR_CLASS dcr_unpacked_load_raw;\r\n\t\t\t}\r\n\t\t\tp->maximum = 0xffff;\r\n\t\t\tbreak;\r\n\t\tcase 50454:\t\t\t/* Sinar tag */\r\n\t\tcase 50455:\r\n\t\t\tif (!(cbuf = (char *) malloc(len))) break;\r\n\t\t\tdcr_fread(p->obj_, cbuf, 1, len);\r\n\t\t\tfor (cp = cbuf-1; cp && cp < cbuf+len; cp = strchr(cp,'\\n'))\r\n\t\t\t\tif (!strncmp (++cp,\"Neutral \",8))\r\n\t\t\t\t\tsscanf (cp+8, \"%f %f %f\", p->cam_mul, p->cam_mul+1, p->cam_mul+2);\r\n\t\t\tfree (cbuf);\r\n\t\t\tbreak;\r\n\t\tcase 50458:\r\n\t\t\tif (!p->make[0]) strcpy (p->make, \"Hasselblad\");\r\n\t\t\tbreak;\r\n\t\tcase 50459:\t\t\t/* Hasselblad tag */\r\n\t\t\ti = p->order;\r\n\t\t\tj = dcr_ftell(p->obj_);\r\n\t\t\tc = p->tiff_nifds;\r\n\t\t\tp->order = dcr_get2(p);\r\n\t\t\tdcr_fseek(p->obj_, j+(dcr_get2(p),dcr_get4(p)), SEEK_SET);\r\n\t\t\tdcr_parse_tiff_ifd (p, j);\r\n\t\t\tp->maximum = 0xffff;\r\n\t\t\tp->tiff_nifds = c;\r\n\t\t\tp->order = i;\r\n\t\t\tbreak;\r\n\t\tcase 50706:\t\t\t/* DNGVersion */\r\n\t\t\tFORC4 p->dng_version = (p->dng_version << 8) + dcr_fgetc(p->obj_);\r\n\t\t\tif (!p->make[0]) strcpy (p->make, \"DNG\");\r\n\t\t\tp->is_raw = 1;\r\n\t\t\tbreak;\r\n\t\tcase 50710:\t\t\t/* CFAPlaneColor */\r\n\t\t\tif (len > 4) len = 4;\r\n\t\t\tp->colors = len;\r\n\t\t\tdcr_fread(p->obj_, cfa_pc, 1, p->colors);\r\nguess_cfa_pc:\r\n\t\t\tFORCC(p) tab[cfa_pc[c]] = c;\r\n\t\t\tp->cdesc[c] = 0;\r\n\t\t\tfor (i=16; i--; )\r\n\t\t\t\tp->filters = p->filters << 2 | tab[cfa_pat[i % plen]];\r\n\t\t\tbreak;\r\n\t\tcase 50711:\t\t\t/* CFALayout */\r\n\t\t\tif (dcr_get2(p) == 2) {\r\n\t\t\t\tp->fuji_width = 1;\r\n\t\t\t\tp->filters = 0x49494949;\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\tcase 291:\r\n\t\tcase 50712:\t\t\t/* LinearizationTable */\r\n\t\t\tdcr_linear_table (p,len);\r\n\t\t\tbreak;\r\n\t\tcase 50714:\t\t\t/* BlackLevel */\r\n\t\tcase 50715:\t\t\t/* BlackLevelDeltaH */\r\n\t\tcase 50716:\t\t\t/* BlackLevelDeltaV */\r\n\t\t\tfor (dblack=i=0; i < (int)len; i++)\r\n\t\t\t\tdblack += dcr_getreal(p, type);\r\n\t\t\tp->black += (unsigned int)(dblack/len + 0.5);\r\n\t\t\tbreak;\r\n\t\tcase 50717:\t\t\t/* WhiteLevel */\r\n\t\t\tp->maximum = dcr_getint(p, type);\r\n\t\t\tbreak;\r\n\t\tcase 50718:\t\t\t/* DefaultScale */\r\n\t\t\tp->pixel_aspect  = dcr_getreal(p,type);\r\n\t\t\tp->pixel_aspect /= dcr_getreal(p,type);\r\n\t\t\tbreak;\r\n\t\tcase 50721:\t\t\t/* ColorMatrix1 */\r\n\t\tcase 50722:\t\t\t/* ColorMatrix2 */\r\n\t\t\tFORCC(p) for (j=0; j < 3; j++)\r\n\t\t\t\tcm[c][j] = dcr_getreal(p,type);\r\n\t\t\tuse_cm = 1;\r\n\t\t\tbreak;\r\n\t\tcase 50723:\t\t\t/* CameraCalibration1 */\r\n\t\tcase 50724:\t\t\t/* CameraCalibration2 */\r\n\t\t\tfor (i=0; i < p->colors; i++)\r\n\t\t\t\tFORCC(p) cc[i][c] = dcr_getreal(p,type);\r\n\t\tcase 50727:\t\t\t/* AnalogBalance */\r\n\t\t\tFORCC(p) ab[c] = dcr_getreal(p,type);\r\n\t\t\tbreak;\r\n\t\tcase 50728:\t\t\t/* AsShotNeutral */\r\n\t\t\tFORCC(p) asn[c] = dcr_getreal(p, type);\r\n\t\t\tbreak;\r\n\t\tcase 50729:\t\t\t/* AsShotWhiteXY */\r\n\t\t\txyz[0] = dcr_getreal(p,type);\r\n\t\t\txyz[1] = dcr_getreal(p,type);\r\n\t\t\txyz[2] = 1 - xyz[0] - xyz[1];\r\n\t\t\tFORC3 xyz[c] /= d65_white[c];\r\n\t\t\tbreak;\r\n\t\tcase 50740:\t\t\t/* DNGPrivateData */\r\n\t\t\tif (p->dng_version) break;\r\n\t\t\tdcr_parse_minolta (p, j = dcr_get4(p)+base);\r\n\t\t\tdcr_fseek(p->obj_, j, SEEK_SET);\r\n\t\t\tdcr_parse_tiff_ifd (p, base);\r\n\t\t\tbreak;\r\n\t\tcase 50752:\r\n\t\t\tdcr_read_shorts (p, p->cr2_slice, 3);\r\n\t\t\tbreak;\r\n\t\tcase 50829:\t\t\t/* ActiveArea */\r\n\t\t\tp->top_margin = dcr_getint(p, type);\r\n\t\t\tp->left_margin = dcr_getint(p, type);\r\n\t\t\tp->height = dcr_getint(p, type) - p->top_margin;\r\n\t\t\tp->width = dcr_getint(p, type) - p->left_margin;\r\n\t\t\tbreak;\r\n\t\tcase 64772:\t\t\t/* Kodak P-series */\r\n\t\t\tdcr_fseek(p->obj_, 16, SEEK_CUR);\r\n\t\t\tp->data_offset = dcr_get4(p);\r\n\t\t\tdcr_fseek(p->obj_, 28, SEEK_CUR);\r\n\t\t\tp->data_offset += dcr_get4(p);\r\n\t\t\tp->load_raw = &DCR_CLASS dcr_packed_12_load_raw;\r\n    }\r\n    dcr_fseek(p->obj_, save, SEEK_SET);\r\n  }\r\n  if (sony_length && (buf = (unsigned *) malloc(sony_length))) {\r\n\t  dcr_stream_ops *sops_;\r\n\t  dcr_stream_obj *sobj_;\r\n\t  dcr_fseek(p->obj_, sony_offset, SEEK_SET);\r\n\t  dcr_fread(p->obj_, buf, sony_length, 1);\r\n\t  dcr_sony_decrypt (buf, sony_length/4, 1, sony_key);\r\n\r\n\t  sops_ = p->ops_;\r\n\t  sobj_ = p->obj_;\r\n  \t  p->ops_ = &dcr_stream_fileops;\r\n\t  if ((p->obj_ = tmpfile())) {\r\n\t\t  dcr_fwrite(p->obj_, buf, sony_length, 1);\r\n\t\t  dcr_fseek(p->obj_, 0, SEEK_SET);\r\n\t\t  dcr_parse_tiff_ifd (p, -(int)sony_offset);\r\n\t\t  dcr_fclose(p->obj_);\r\n\t  }\r\n\t  p->ops_ = sops_;\r\n\t  p->obj_ = sobj_;\r\n\r\n\t  free (buf);\r\n  }\r\n  for (i=0; i < p->colors; i++)\r\n\t  FORCC(p) cc[i][c] *= ab[i];\r\n  if (use_cm) {\r\n\t  FORCC(p) for (i=0; i < 3; i++)\r\n\t\t  for (cam_xyz[c][i]=j=0; j < p->colors; j++)\r\n\t\t\t  cam_xyz[c][i] += cc[c][j] * cm[j][i] * xyz[i];\r\n\t\t  dcr_cam_xyz_coeff (p, cam_xyz);\r\n  }\r\n  if (asn[0]) {\r\n\t  p->cam_mul[3] = 0;\r\n\t  FORCC(p) p->cam_mul[c] = 1.0f / (float)asn[c];\r\n  }\r\n  if (!use_cm)\r\n\t  FORCC(p) p->pre_mul[c] /= (float)cc[c][c];\r\n  return 0;\r\n}\r\n\r\nvoid DCR_CLASS dcr_parse_tiff (DCRAW* p, int base)\r\n{\r\n\tint doff, max_samp=0, raw=-1, thm=-1, i;\r\n\tstruct dcr_jhead jh;\r\n\r\n\tdcr_fseek(p->obj_, base, SEEK_SET);\r\n\tp->order = dcr_get2(p);\r\n\tif (p->order != 0x4949 && p->order != 0x4d4d) return;\r\n\tdcr_get2(p);\r\n\tmemset (p->tiff_ifd, 0, sizeof p->tiff_ifd);\r\n\tp->tiff_nifds = 0;\r\n\twhile ((doff = dcr_get4(p))) {\r\n\t\tdcr_fseek(p->obj_, doff+base, SEEK_SET);\r\n\t\tif (dcr_parse_tiff_ifd (p, base)) break;\r\n\t}\r\n\tp->thumb_misc = 16;\r\n\tif (p->thumb_offset) {\r\n\t\tdcr_fseek(p->obj_, p->thumb_offset, SEEK_SET);\r\n\t\tif (dcr_ljpeg_start (p,&jh, 1)) {\r\n\t\t\tp->thumb_misc   = jh.bits;\r\n\t\t\tp->thumb_width  = jh.wide;\r\n\t\t\tp->thumb_height = jh.high;\r\n\t\t}\r\n\t}\r\n\tfor (i=0; i < (int)p->tiff_nifds; i++) {\r\n\t\tif (max_samp < p->tiff_ifd[i].samples)\r\n\t\t\tmax_samp = p->tiff_ifd[i].samples;\r\n\t\tif (max_samp > 3) max_samp = 3;\r\n\t\tif ((p->tiff_ifd[i].comp != 6 || p->tiff_ifd[i].samples != 3) &&\r\n\t\t\tp->tiff_ifd[i].width*p->tiff_ifd[i].height > p->raw_width*p->raw_height) {\r\n\t\t\tp->raw_width     = p->tiff_ifd[i].width;\r\n\t\t\tp->raw_height    = p->tiff_ifd[i].height;\r\n\t\t\tp->tiff_bps      = p->tiff_ifd[i].bps;\r\n\t\t\tp->tiff_compress = p->tiff_ifd[i].comp;\r\n\t\t\tp->data_offset   = p->tiff_ifd[i].offset;\r\n\t\t\tp->tiff_flip     = p->tiff_ifd[i].flip;\r\n\t\t\tp->tiff_samples  = p->tiff_ifd[i].samples;\r\n\t\t\traw = i;\r\n\t\t}\r\n\t}\r\n\tp->fuji_width *= (p->raw_width+1)/2;\r\n\tif (p->tiff_ifd[0].flip) p->tiff_flip = p->tiff_ifd[0].flip;\r\n\tif (raw >= 0 && !p->load_raw)\r\n\t\tswitch (p->tiff_compress) {\r\n\tcase 0:  case 1:\r\n\t\tswitch (p->tiff_bps) {\r\n\t\tcase  8: p->load_raw = &DCR_CLASS dcr_eight_bit_load_raw;\tbreak;\r\n\t\tcase 12: p->load_raw = &DCR_CLASS dcr_packed_12_load_raw;\r\n\t\t\tif (p->tiff_ifd[raw].phint == 2)\r\n\t\t\t\tp->load_flags = 6;\r\n\t\t\tif (strncmp(p->make,\"PENTAX\",6)) break;\r\n\t\tcase 14:\r\n\t\tcase 16: p->load_raw = &DCR_CLASS dcr_unpacked_load_raw;\t\tbreak;\r\n\t\t}\r\n\t\tif (p->tiff_ifd[raw].bytes*5 == p->raw_width*p->raw_height*8)\r\n\t\t\tp->load_raw = &DCR_CLASS dcr_olympus_e300_load_raw;\r\n\t\tbreak;\r\n\t\tcase 6:  case 7:  case 99:\r\n\t\t\tp->load_raw = &DCR_CLASS dcr_lossless_jpeg_load_raw;\t\tbreak;\r\n\t\tcase 262:\r\n\t\t\tp->load_raw = &DCR_CLASS dcr_kodak_262_load_raw;\t\t\tbreak;\r\n\t\tcase 32767:\r\n\t\t\tp->load_raw = &DCR_CLASS dcr_sony_arw2_load_raw;\r\n\t\t\tif (p->tiff_ifd[raw].bytes*8 == (int)(p->raw_width*p->raw_height*p->tiff_bps))\r\n\t\t\t\tbreak;\r\n\t\t\tp->raw_height += 8;\r\n\t\t\tp->load_raw = &DCR_CLASS dcr_sony_arw_load_raw;\t\t\tbreak;\r\n\t\tcase 32769:\r\n\t\t\tp->load_flags = 8;\r\n\t\tcase 32773:\r\n\t\t\tp->load_raw = &DCR_CLASS dcr_packed_12_load_raw;\t\t\tbreak;\r\n\t\tcase 34713:\r\n\t\t\tp->load_raw = &DCR_CLASS dcr_nikon_compressed_load_raw;\t\tbreak;\r\n\t\tcase 65535:\r\n\t\t\tp->load_raw = &DCR_CLASS dcr_pentax_k10_load_raw;\t\t\tbreak;\r\n\t\tcase 65000:\r\n\t\t\tswitch (p->tiff_ifd[raw].phint) {\r\n\t\t\tcase 2: p->load_raw = &DCR_CLASS dcr_kodak_rgb_load_raw;   p->filters = 0;  break;\r\n\t\t\tcase 6: p->load_raw = &DCR_CLASS dcr_kodak_ycbcr_load_raw; p->filters = 0;  break;\r\n\t\t\tcase 32803: p->load_raw = &DCR_CLASS dcr_kodak_65000_load_raw;\r\n\t\t\t}\r\n\t\t\tcase 32867: break;\r\n\t\t\tdefault: p->is_raw = 0;\r\n    }\r\n\tif (!p->dng_version && p->tiff_samples == 3)\r\n\t\tif (p->tiff_ifd[raw].bytes && p->tiff_bps != 14 && p->tiff_bps != 2048)\r\n\t\t\tp->is_raw = 0;\r\n\tif (!p->dng_version && p->tiff_bps == 8 && p->tiff_compress == 1 &&\r\n\t\tp->tiff_ifd[raw].phint == 1) p->is_raw = 0;\r\n\tif (p->tiff_bps == 8 && p->tiff_samples == 4) p->is_raw = 0;\r\n\tfor (i=0; i < (int)p->tiff_nifds; i++)\r\n\t\tif (i != raw && p->tiff_ifd[i].samples == max_samp &&\r\n\t\t\tp->tiff_ifd[i].width * p->tiff_ifd[i].height / SQR(p->tiff_ifd[i].bps+1) >\r\n\t\t\t(int)(p->thumb_width *       p->thumb_height / SQR(p->thumb_misc+1))) {\r\n\t\t\tp->thumb_width  = p->tiff_ifd[i].width;\r\n\t\t\tp->thumb_height = p->tiff_ifd[i].height;\r\n\t\t\tp->thumb_offset = p->tiff_ifd[i].offset;\r\n\t\t\tp->thumb_length = p->tiff_ifd[i].bytes;\r\n\t\t\tp->thumb_misc   = p->tiff_ifd[i].bps;\r\n\t\t\tthm = i;\r\n\t\t}\r\n\tif (thm >= 0) {\r\n\t\tp->thumb_misc |= p->tiff_ifd[thm].samples << 5;\r\n\t\tswitch (p->tiff_ifd[thm].comp) {\r\n\t\tcase 0:\r\n\t\t\tp->write_thumb = &DCR_CLASS dcr_layer_thumb;\r\n\t\t\tbreak;\r\n\t\tcase 1:\r\n\t\t\tif (p->tiff_ifd[thm].bps > 8)\r\n\t\t\t\tp->thumb_load_raw = &DCR_CLASS dcr_kodak_thumb_load_raw;\r\n\t\t\telse\r\n\t\t\t\tp->write_thumb = &DCR_CLASS dcr_ppm_thumb;\r\n\t\t\tbreak;\r\n\t\tcase 65000:\r\n\t\t\tp->thumb_load_raw = p->tiff_ifd[thm].phint == 6 ?\r\n\t\t\t\t&DCR_CLASS dcr_kodak_ycbcr_load_raw : &DCR_CLASS dcr_kodak_rgb_load_raw;\r\n\t\t}\r\n\t}\r\n}\r\n\r\nvoid DCR_CLASS dcr_parse_minolta (DCRAW* p, int base)\r\n{\r\n\tint save, tag, len, offset, high=0, wide=0, i, c;\r\n\tshort sorder=p->order;\r\n\r\n\tdcr_fseek(p->obj_, base, SEEK_SET);\r\n\tif (dcr_fgetc(p->obj_) || dcr_fgetc(p->obj_)-'M' || dcr_fgetc(p->obj_)-'R') return;\r\n\tp->order = dcr_fgetc(p->obj_) * 0x101;\r\n\toffset = base + dcr_get4(p) + 8;\r\n\twhile ((save=dcr_ftell(p->obj_)) < offset) {\r\n\t\tfor (tag=i=0; i < 4; i++)\r\n\t\t\ttag = tag << 8 | dcr_fgetc(p->obj_);\r\n\t\tlen = dcr_get4(p);\r\n\t\tswitch (tag) {\r\n\t\tcase 0x505244:\t\t\t\t/* PRD */\r\n\t\t\tdcr_fseek(p->obj_, 8, SEEK_CUR);\r\n\t\t\thigh = dcr_get2(p);\r\n\t\t\twide = dcr_get2(p);\r\n\t\t\tbreak;\r\n\t\tcase 0x574247:\t\t\t\t/* WBG */\r\n\t\t\tdcr_get4(p);\r\n\t\t\ti = strcmp(p->model,\"DiMAGE A200\") ? 0:3;\r\n\t\t\tFORC4 p->cam_mul[c ^ (c >> 1) ^ i] = dcr_get2(p);\r\n\t\t\tbreak;\r\n\t\tcase 0x545457:\t\t\t\t/* TTW */\r\n\t\t\tdcr_parse_tiff (p, dcr_ftell(p->obj_));\r\n\t\t\tp->data_offset = offset;\r\n\t\t}\r\n\t\tdcr_fseek(p->obj_, save+len+8, SEEK_SET);\r\n\t}\r\n\tp->raw_height = high;\r\n\tp->raw_width  = wide;\r\n\tp->order = sorder;\r\n}\r\n\r\n/*\r\nMany cameras have a \"debug mode\" that writes JPEG and raw\r\nat the same time.  The raw file has no header, so try to\r\nto open the matching JPEG file and read its metadata.\r\n*/\r\nvoid DCR_CLASS dcr_parse_external_jpeg(DCRAW* p)\r\n{\r\n\tchar *file, *ext, *jname, *jfile, *jext;\r\n\tdcr_stream_ops *sops_;\r\n\tdcr_stream_obj *sobj_;\r\n\r\n\text  = strrchr (p->ifname, '.');\r\n\tfile = strrchr (p->ifname, '/');\r\n\tif (!file) file = strrchr (p->ifname, '\\\\');\r\n\tif (!file) file = p->ifname-1;\r\n\tfile++;\r\n\tif (!ext || strlen(ext) != 4 || ext-file != 8) return;\r\n\tjname = (char *) malloc (strlen(p->ifname) + 1);\r\n\tdcr_merror (p, jname, \"parse_external_jpeg()\");\r\n\tstrcpy (jname, p->ifname);\r\n\tjfile = file - p->ifname + jname;\r\n\tjext  = ext  - p->ifname + jname;\r\n\tif (strcasecmp (ext, \".jpg\")) {\r\n\t\tstrcpy (jext, isupper(ext[1]) ? \".JPG\":\".jpg\");\r\n\t\tif (isdigit(*file)) {\r\n\t\t\tmemcpy (jfile, file+4, 4);\r\n\t\t\tmemcpy (jfile+4, file, 4);\r\n\t\t}\r\n\t} else\r\n\t\twhile (isdigit(*--jext)) {\r\n\t\t\tif (*jext != '9') {\r\n\t\t\t\t(*jext)++;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\t*jext = '0';\r\n\t\t}\r\n\tif (strcmp (jname, p->ifname)) {\r\n\r\n\t\tsops_ = p->ops_;\r\n\t\tsobj_ = p->obj_;\r\n  \t\tp->ops_ = &dcr_stream_fileops;\r\n\r\n\t\tif ((p->obj_ = fopen (jname, \"rb\"))) {\r\n\t\t\tif (p->opt.verbose)\r\n\t\t\t\tfprintf (stderr,_(\"Reading metadata from %s ...\\n\"), jname);\r\n\t\t\tdcr_parse_tiff (p, 12);\r\n\t\t\tp->thumb_offset = 0;\r\n\t\t\tp->is_raw = 1;\r\n\t\t\tdcr_fclose(p->obj_);\r\n\t\t}\r\n\r\n\t\tp->ops_ = sops_;\r\n\t\tp->obj_ = sobj_;\r\n\r\n\t}\r\n\tif (!p->timestamp)\r\n\t\tfprintf (stderr,_(\"Failed to read metadata from %s\\n\"), jname);\r\n\tfree (jname);\r\n}\r\n\r\n/*\r\nCIFF block 0x1030 contains an 8x8 p->white sample.\r\nLoad this into p->white[][] for use in scale_colors().\r\n*/\r\nvoid DCR_CLASS dcr_ciff_block_1030(DCRAW* p)\r\n{\r\n\tstatic const ushort key[] = { 0x410, 0x45f3 };\r\n\tint i, bpp, row, col, vbits=0;\r\n\tunsigned long bitbuf=0;\r\n\r\n\tif ((dcr_get2(p),dcr_get4(p)) != 0x80008 || !dcr_get4(p)) return;\r\n\tbpp = dcr_get2(p);\r\n\tif (bpp != 10 && bpp != 12) return;\r\n\tfor (i=row=0; row < 8; row++)\r\n\t\tfor (col=0; col < 8; col++) {\r\n\t\t\tif (vbits < bpp) {\r\n\t\t\t\tbitbuf = bitbuf << 16 | (dcr_get2(p) ^ key[i++ & 1]);\r\n\t\t\t\tvbits += 16;\r\n\t\t\t}\r\n\t\t\tp->white[row][col] = (unsigned short)(\r\n\t\t\t\tbitbuf << (LONG_BIT - vbits) >> (LONG_BIT - bpp));\r\n\t\t\tvbits -= bpp;\r\n\t\t}\r\n}\r\n\r\n/*\r\nParse a CIFF file, better known as Canon CRW format.\r\n*/\r\nvoid DCR_CLASS dcr_parse_ciff (DCRAW* p, int offset, int length)\r\n{\r\n\tint tboff, nrecs, c, type, len, save, wbi=-1;\r\n\tushort key[] = { 0x410, 0x45f3 };\r\n\r\n\tdcr_fseek(p->obj_, offset+length-4, SEEK_SET);\r\n\ttboff = dcr_get4(p) + offset;\r\n\tdcr_fseek(p->obj_, tboff, SEEK_SET);\r\n\tnrecs = dcr_get2(p);\r\n\tif (nrecs > 100) return;\r\n\twhile (nrecs--) {\r\n\t\ttype = dcr_get2(p);\r\n\t\tlen  = dcr_get4(p);\r\n\t\tsave = dcr_ftell(p->obj_) + 4;\r\n\t\tdcr_fseek(p->obj_, offset+dcr_get4(p), SEEK_SET);\r\n\t\tif ((((type >> 8) + 8) | 8) == 0x38)\r\n\t\t\tdcr_parse_ciff (p,dcr_ftell(p->obj_), len);\t/* Parse a sub-table */\r\n\r\n\t\tif (type == 0x0810)\r\n\t\t\tdcr_fread(p->obj_, p->artist, 64, 1);\r\n\t\tif (type == 0x080a) {\r\n\t\t\tdcr_fread(p->obj_, p->make, 64, 1);\r\n\t\t\tdcr_fseek(p->obj_, strlen(p->make) - 63, SEEK_CUR);\r\n\t\t\tdcr_fread(p->obj_, p->model, 64, 1);\r\n\t\t}\r\n\t\tif (type == 0x1810) {\r\n\t\t\tdcr_fseek(p->obj_, 12, SEEK_CUR);\r\n\t\t\tp->flip = dcr_get4(p);\r\n\t\t}\r\n\t\tif (type == 0x1835)\t\t\t/* Get the decoder table */\r\n\t\t\tp->tiff_compress = dcr_get4(p);\r\n\t\tif (type == 0x2007) {\r\n\t\t\tp->thumb_offset = dcr_ftell(p->obj_);\r\n\t\t\tp->thumb_length = len;\r\n\t\t}\r\n\t\tif (type == 0x1818) {\r\n\t\t\tp->shutter = (float)pow (2, -dcr_int_to_float((dcr_get4(p),dcr_get4(p))));\r\n\t\t\tp->aperture = (float)pow (2, dcr_int_to_float(dcr_get4(p))/2);\r\n\t\t}\r\n\t\tif (type == 0x102a) {\r\n\t\t\tp->iso_speed = (float)pow (2, (dcr_get4(p),dcr_get2(p))/32.0f - 4) * 50;\r\n\t\t\tp->aperture  = (float)pow (2, (dcr_get2(p),(short)dcr_get2(p))/64.0f);\r\n\t\t\tp->shutter   = (float)pow (2,-((short)dcr_get2(p))/32.0f);\r\n\t\t\twbi = (dcr_get2(p),dcr_get2(p));\r\n\t\t\tif (wbi > 17) wbi = 0;\r\n\t\t\tdcr_fseek(p->obj_, 32, SEEK_CUR);\r\n\t\t\tif (p->shutter > 1e6) p->shutter = dcr_get2(p)/10.0f;\r\n\t\t}\r\n\t\tif (type == 0x102c) {\r\n\t\t\tif (dcr_get2(p) > 512) {\t\t/* Pro90, G1 */\r\n\t\t\t\tdcr_fseek(p->obj_, 118, SEEK_CUR);\r\n\t\t\t\tFORC4 p->cam_mul[c ^ 2] = dcr_get2(p);\r\n\t\t\t} else {\t\t\t\t/* G2, S30, S40 */\r\n\t\t\t\tdcr_fseek(p->obj_, 98, SEEK_CUR);\r\n\t\t\t\tFORC4 p->cam_mul[c ^ (c >> 1) ^ 1] = dcr_get2(p);\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (type == 0x0032) {\r\n\t\t\tif (len == 768) {\t\t\t/* EOS D30 */\r\n\t\t\t\tdcr_fseek(p->obj_, 72, SEEK_CUR);\r\n\t\t\t\tFORC4 p->cam_mul[c ^ (c >> 1)] = 1024.0f / dcr_get2(p);\r\n\t\t\t\tif (!wbi) p->cam_mul[0] = -1;\t/* use my auto p->white balance */\r\n\t\t\t} else if (!p->cam_mul[0]) {\r\n\t\t\t\tif (dcr_get2(p) == key[0])\t\t/* Pro1, G6, S60, S70 */\r\n\t\t\t\t\tc = (strstr(p->model,\"Pro1\") ?\r\n\t\t\t\t\t\"012346000000000000\":\"01345:000000006008\")[wbi]-'0'+ 2;\r\n\t\t\t\telse {\t\t\t\t/* G3, G5, S45, S50 */\r\n\t\t\t\t\tc = \"023457000000006000\"[wbi]-'0';\r\n\t\t\t\t\tkey[0] = key[1] = 0;\r\n\t\t\t\t}\r\n\t\t\t\tdcr_fseek(p->obj_, 78 + c*8, SEEK_CUR);\r\n\t\t\t\tFORC4 p->cam_mul[c ^ (c >> 1) ^ 1] = (float)(dcr_get2(p) ^ key[c & 1]);\r\n\t\t\t\tif (!wbi) p->cam_mul[0] = -1;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (type == 0x10a9) {\t\t/* D60, 10D, 300D, and clones */\r\n\t\t\tif (len > 66) wbi = \"0134567028\"[wbi]-'0';\r\n\t\t\tdcr_fseek(p->obj_, 2 + wbi*8, SEEK_CUR);\r\n\t\t\tFORC4 p->cam_mul[c ^ (c >> 1)] = dcr_get2(p);\r\n\t\t}\r\n\t\tif (type == 0x1030 && (0x18040 >> wbi & 1))\r\n\t\t\tdcr_ciff_block_1030(p);\t\t/* all that don't have 0x10a9 */\r\n\t\tif (type == 0x1031) {\r\n\t\t\tp->raw_width = (dcr_get2(p),dcr_get2(p));\r\n\t\t\tp->raw_height = dcr_get2(p);\r\n\t\t}\r\n\t\tif (type == 0x5029) {\r\n\t\t\tp->focal_len = (float)(len >> 16);\r\n\t\t\tif ((len & 0xffff) == 2) p->focal_len /= 32;\r\n\t\t}\r\n\t\tif (type == 0x5813) p->flash_used = dcr_int_to_float(len);\r\n\t\tif (type == 0x5814) p->canon_ev   = dcr_int_to_float(len);\r\n\t\tif (type == 0x5817) p->shot_order = len;\r\n\t\tif (type == 0x5834) p->unique_id  = len;\r\n\t\tif (type == 0x580e) p->timestamp  = len;\r\n\t\tif (type == 0x180e) p->timestamp  = dcr_get4(p);\r\n#ifdef LOCALTIME\r\n\t\tif ((type | 0x4000) == 0x580e)\r\n\t\t\tp->timestamp = mktime (gmtime (&p->timestamp));\r\n#endif\r\n\t\tdcr_fseek(p->obj_, save, SEEK_SET);\r\n\t}\r\n}\r\n\r\nvoid DCR_CLASS dcr_parse_rollei(DCRAW* p)\r\n{\r\n\tchar line[128], *val;\r\n\tstruct tm t;\r\n\r\n\tdcr_fseek(p->obj_, 0, SEEK_SET);\r\n\tmemset (&t, 0, sizeof t);\r\n\tdo {\r\n\t\tdcr_fgets(p->obj_, line, 128);\r\n\t\tif ((val = strchr(line,'=')))\r\n\t\t\t*val++ = 0;\r\n\t\telse\r\n\t\t\tval = line + strlen(line);\r\n\t\tif (!strcmp(line,\"DAT\"))\r\n\t\t\tsscanf (val, \"%d.%d.%d\", &t.tm_mday, &t.tm_mon, &t.tm_year);\r\n\t\tif (!strcmp(line,\"TIM\"))\r\n\t\t\tsscanf (val, \"%d:%d:%d\", &t.tm_hour, &t.tm_min, &t.tm_sec);\r\n\t\tif (!strcmp(line,\"HDR\"))\r\n\t\t\tp->thumb_offset = atoi(val);\r\n\t\tif (!strcmp(line,\"X  \"))\r\n\t\t\tp->raw_width = atoi(val);\r\n\t\tif (!strcmp(line,\"Y  \"))\r\n\t\t\tp->raw_height = atoi(val);\r\n\t\tif (!strcmp(line,\"TX \"))\r\n\t\t\tp->thumb_width = atoi(val);\r\n\t\tif (!strcmp(line,\"TY \"))\r\n\t\t\tp->thumb_height = atoi(val);\r\n\t} while (strncmp(line,\"EOHD\",4));\r\n\tp->data_offset = p->thumb_offset + p->thumb_width * p->thumb_height * 2;\r\n\tt.tm_year -= 1900;\r\n\tt.tm_mon -= 1;\r\n\tif (mktime(&t) > 0)\r\n\t\tp->timestamp = mktime(&t);\r\n\tstrcpy (p->make, \"Rollei\");\r\n\tstrcpy (p->model,\"d530flex\");\r\n\tp->write_thumb = &DCR_CLASS dcr_rollei_thumb;\r\n}\r\n\r\nvoid DCR_CLASS dcr_parse_sinar_ia(DCRAW* p)\r\n{\r\n\tint entries, off;\r\n\tchar str[8], *cp;\r\n\r\n\tp->order = 0x4949;\r\n\tdcr_fseek(p->obj_, 4, SEEK_SET);\r\n\tentries = dcr_get4(p);\r\n\tdcr_fseek(p->obj_, dcr_get4(p), SEEK_SET);\r\n\twhile (entries--) {\r\n\t\toff = dcr_get4(p); dcr_get4(p);\r\n\t\tdcr_fread(p->obj_, str, 8, 1);\r\n\t\tif (!strcmp(str,\"META\"))   p->meta_offset = off;\r\n\t\tif (!strcmp(str,\"THUMB\")) p->thumb_offset = off;\r\n\t\tif (!strcmp(str,\"RAW0\"))   p->data_offset = off;\r\n\t}\r\n\tdcr_fseek(p->obj_, p->meta_offset+20, SEEK_SET);\r\n\tdcr_fread(p->obj_, p->make, 64, 1);\r\n\tp->make[63] = 0;\r\n\tif ((cp = strchr(p->make,' '))) {\r\n\t\tstrcpy (p->model, cp+1);\r\n\t\t*cp = 0;\r\n\t}\r\n\tp->raw_width  = dcr_get2(p);\r\n\tp->raw_height = dcr_get2(p);\r\n\tp->load_raw = &DCR_CLASS dcr_unpacked_load_raw;\r\n\tp->thumb_width = (dcr_get4(p),dcr_get2(p));\r\n\tp->thumb_height = dcr_get2(p);\r\n\tp->write_thumb = &DCR_CLASS dcr_ppm_thumb;\r\n\tp->maximum = 0x3fff;\r\n}\r\n\r\nvoid DCR_CLASS dcr_parse_phase_one (DCRAW* p, int base)\r\n{\r\n\tunsigned entries, tag, type, len, data, save, i, c;\r\n\tfloat romm_cam[3][3];\r\n\tchar *cp;\r\n\r\n\tmemset (&p->ph1, 0, sizeof p->ph1);\r\n\tdcr_fseek(p->obj_, base, SEEK_SET);\r\n\tp->order = dcr_get4(p) & 0xffff;\r\n\tif (dcr_get4(p) >> 8 != 0x526177) return;\t\t/* \"Raw\" */\r\n\tdcr_fseek(p->obj_, dcr_get4(p)+base, SEEK_SET);\r\n\tentries = dcr_get4(p);\r\n\tdcr_get4(p);\r\n\twhile (entries--) {\r\n\t\ttag  = dcr_get4(p);\r\n\t\ttype = dcr_get4(p);\r\n\t\tlen  = dcr_get4(p);\r\n\t\tdata = dcr_get4(p);\r\n\t\tsave = dcr_ftell(p->obj_);\r\n\t\tdcr_fseek(p->obj_, base+data, SEEK_SET);\r\n\t\tswitch (tag) {\r\n\t\tcase 0x100:  p->flip = \"0653\"[data & 3]-'0';  break;\r\n\t\tcase 0x106:\r\n\t\t\tfor (i=0; i < 9; i++)\r\n\t\t\t\tromm_cam[0][i] = (float)dcr_getreal(p, 11);\r\n\t\t\tdcr_romm_coeff (p,romm_cam);\r\n\t\t\tbreak;\r\n\t\tcase 0x107:\r\n\t\t\tFORC3 p->cam_mul[c] = (float)dcr_getreal(p, 11);\r\n\t\t\tbreak;\r\n\t\tcase 0x108:  p->raw_width     = data;\tbreak;\r\n\t\tcase 0x109:  p->raw_height    = data;\tbreak;\r\n\t\tcase 0x10a:  p->left_margin   = data;\tbreak;\r\n\t\tcase 0x10b:  p->top_margin    = data;\tbreak;\r\n\t\tcase 0x10c:  p->width         = data;\tbreak;\r\n\t\tcase 0x10d:  p->height        = data;\tbreak;\r\n\t\tcase 0x10e:  p->ph1.format    = data;\tbreak;\r\n\t\tcase 0x10f:  p->data_offset   = data+base;\tbreak;\r\n\t\tcase 0x110:  p->meta_offset   = data+base;\r\n\t\t\tp->meta_length   = len;\t\t\tbreak;\r\n\t\tcase 0x112:  p->ph1.key_off   = save - 4;\t\tbreak;\r\n\t\tcase 0x210:  p->ph1.tag_210   = dcr_int_to_float(data);\tbreak;\r\n\t\tcase 0x21a:  p->ph1.tag_21a   = data;\t\tbreak;\r\n\t\tcase 0x21c:  p->strip_offset  = data+base;\t\tbreak;\r\n\t\tcase 0x21d:  p->ph1.black     = data;\t\tbreak;\r\n\t\tcase 0x222:  p->ph1.split_col = data - p->left_margin;\tbreak;\r\n\t\tcase 0x223:  p->ph1.black_off = data+base;\t\tbreak;\r\n\t\tcase 0x301:\r\n\t\t\tp->model[63] = 0;\r\n\t\t\tdcr_fread(p->obj_, p->model, 1, 63);\r\n\t\t\tif ((cp = strstr(p->model,\" camera\"))) *cp = 0;\r\n\t\t}\r\n\t\tdcr_fseek(p->obj_, save, SEEK_SET);\r\n\t}\r\n\tp->load_raw = p->ph1.format < 3 ?\r\n\t\t&DCR_CLASS dcr_phase_one_load_raw : &DCR_CLASS dcr_phase_one_load_raw_c;\r\n\tp->maximum = 0xffff;\r\n\tstrcpy (p->make, \"Phase One\");\r\n\tif (p->model[0]) return;\r\n\tswitch (p->raw_height) {\r\n    case 2060: strcpy (p->model,\"LightPhase\");\tbreak;\r\n    case 2682: strcpy (p->model,\"H 10\");\t\tbreak;\r\n    case 4128: strcpy (p->model,\"H 20\");\t\tbreak;\r\n    case 5488: strcpy (p->model,\"H 25\");\t\tbreak;\r\n\t}\r\n}\r\n\r\nvoid DCR_CLASS dcr_parse_fuji (DCRAW* p, int offset)\r\n{\r\n\tunsigned entries, tag, len, save, c;\r\n\r\n\tdcr_fseek(p->obj_, offset, SEEK_SET);\r\n\tentries = dcr_get4(p);\r\n\tif (entries > 255) return;\r\n\twhile (entries--) {\r\n\t\ttag = dcr_get2(p);\r\n\t\tlen = dcr_get2(p);\r\n\t\tsave = dcr_ftell(p->obj_);\r\n\t\tif (tag == 0x100) {\r\n\t\t\tp->raw_height = dcr_get2(p);\r\n\t\t\tp->raw_width  = dcr_get2(p);\r\n\t\t} else if (tag == 0x121) {\r\n\t\t\tp->height = dcr_get2(p);\r\n\t\t\tif ((p->width = dcr_get2(p)) == 4284) p->width += 3;\r\n\t\t} else if (tag == 0x130)\r\n\t\t\tp->fuji_layout = dcr_fgetc(p->obj_) >> 7;\r\n\t\tif (tag == 0x2ff0)\r\n\t\t\tFORC4 p->cam_mul[c ^ 1] = dcr_get2(p);\r\n\t\tdcr_fseek(p->obj_, save+len, SEEK_SET);\r\n\t}\r\n\tp->height <<= p->fuji_layout;\r\n\tp->width  >>= p->fuji_layout;\r\n}\r\n\r\nint DCR_CLASS dcr_parse_jpeg (DCRAW* p, int offset)\r\n{\r\n\tint len, save, hlen, mark;\r\n\r\n\tdcr_fseek(p->obj_, offset, SEEK_SET);\r\n\tif (dcr_fgetc(p->obj_) != 0xff || dcr_fgetc(p->obj_) != 0xd8) return 0;\r\n\r\n\twhile (dcr_fgetc(p->obj_) == 0xff && (mark = dcr_fgetc(p->obj_)) != 0xda) {\r\n\t\tp->order = 0x4d4d;\r\n\t\tlen   = dcr_get2(p) - 2;\r\n\t\tsave  = dcr_ftell(p->obj_);\r\n\t\tif (mark == 0xc0 || mark == 0xc3) {\r\n\t\t\tdcr_fgetc(p->obj_);\r\n\t\t\tp->raw_height = dcr_get2(p);\r\n\t\t\tp->raw_width  = dcr_get2(p);\r\n\t\t}\r\n\t\tp->order = dcr_get2(p);\r\n\t\thlen  = dcr_get4(p);\r\n\t\tif (dcr_get4(p) == 0x48454150)\t\t/* \"HEAP\" */\r\n\t\t\tdcr_parse_ciff (p,save+hlen, len-hlen);\r\n\t\tdcr_parse_tiff (p, save+6);\r\n\t\tdcr_fseek(p->obj_, save+len, SEEK_SET);\r\n\t}\r\n\treturn 1;\r\n}\r\n\r\nvoid DCR_CLASS dcr_parse_riff(DCRAW* p)\r\n{\r\n\tunsigned i, size, end;\r\n\tchar tag[4], date[64], month[64];\r\n\tstatic const char mon[12][4] =\r\n\t{ \"Jan\",\"Feb\",\"Mar\",\"Apr\",\"May\",\"Jun\",\"Jul\",\"Aug\",\"Sep\",\"Oct\",\"Nov\",\"Dec\" };\r\n\tstruct tm t;\r\n\r\n\tp->order = 0x4949;\r\n\tdcr_fread(p->obj_, tag, 4, 1);\r\n\tsize = dcr_get4(p);\r\n\tend = dcr_ftell(p->obj_) + size;\r\n\tif (!memcmp(tag,\"RIFF\",4) || !memcmp(tag,\"LIST\",4)) {\r\n\t\tdcr_get4(p);\r\n\t\twhile (dcr_ftell(p->obj_)+7 < (long)end)\r\n\t\t\tdcr_parse_riff(p);\r\n\t} else if (!memcmp(tag,\"nctg\",4)) {\r\n\t\twhile (dcr_ftell(p->obj_)+7 < (long)end) {\r\n\t\t\ti = dcr_get2(p);\r\n\t\t\tsize = dcr_get2(p);\r\n\t\t\tif ((i+1) >> 1 == 10 && size == 20)\r\n\t\t\t\tdcr_get_timestamp(p,0);\r\n\t\t\telse dcr_fseek(p->obj_, size, SEEK_CUR);\r\n\t\t}\r\n\t} else if (!memcmp(tag,\"IDIT\",4) && size < 64) {\r\n\t\tdcr_fread(p->obj_, date, 64, 1);\r\n\t\tdate[size] = 0;\r\n\t\tmemset (&t, 0, sizeof t);\r\n\t\tif (sscanf (date, \"%*s %s %d %d:%d:%d %d\", month, &t.tm_mday,\r\n\t\t\t&t.tm_hour, &t.tm_min, &t.tm_sec, &t.tm_year) == 6) {\r\n\t\t\tfor (i=0; i < 12 && strcasecmp(mon[i],month); i++);\r\n\t\t\tt.tm_mon = i;\r\n\t\t\tt.tm_year -= 1900;\r\n\t\t\tif (mktime(&t) > 0)\r\n\t\t\t\tp->timestamp = mktime(&t);\r\n\t\t}\r\n\t} else\r\n\t\tdcr_fseek(p->obj_, size, SEEK_CUR);\r\n}\r\n\r\nvoid DCR_CLASS dcr_parse_smal (DCRAW* p, int offset, int fsize)\r\n{\r\n\tint ver;\r\n\r\n\tdcr_fseek(p->obj_, offset+2, SEEK_SET);\r\n\tp->order = 0x4949;\r\n\tver = dcr_fgetc(p->obj_);\r\n\tif (ver == 6)\r\n\t\tdcr_fseek(p->obj_, 5, SEEK_CUR);\r\n\tif ((int)dcr_get4(p) != fsize) return;\r\n\tif (ver > 6) p->data_offset = dcr_get4(p);\r\n\tp->raw_height = p->height = dcr_get2(p);\r\n\tp->raw_width  = p->width  = dcr_get2(p);\r\n\tstrcpy (p->make, \"SMaL\");\r\n\tsprintf (p->model, \"v%d %dx%d\", ver, p->width, p->height);\r\n\tif (ver == 6) p->load_raw = &DCR_CLASS dcr_smal_v6_load_raw;\r\n\tif (ver == 9) p->load_raw = &DCR_CLASS dcr_smal_v9_load_raw;\r\n}\r\n\r\nvoid DCR_CLASS dcr_parse_cine(DCRAW* p)\r\n{\r\n\tunsigned off_head, off_setup, off_image, i;\r\n\r\n\tp->order = 0x4949;\r\n\tdcr_fseek(p->obj_, 4, SEEK_SET);\r\n\tp->is_raw = dcr_get2(p) == 2;\r\n\tdcr_fseek(p->obj_, 14, SEEK_CUR);\r\n\tp->is_raw *= dcr_get4(p);\r\n\toff_head = dcr_get4(p);\r\n\toff_setup = dcr_get4(p);\r\n\toff_image = dcr_get4(p);\r\n\tp->timestamp = dcr_get4(p);\r\n\tif ((i = dcr_get4(p))) p->timestamp = i;\r\n\tdcr_fseek(p->obj_, off_head+4, SEEK_SET);\r\n\tp->raw_width = dcr_get4(p);\r\n\tp->raw_height = dcr_get4(p);\r\n\tswitch (dcr_get2(p),dcr_get2(p)) {\r\n    case  8:  p->load_raw = &DCR_CLASS dcr_eight_bit_load_raw;  break;\r\n    case 16:  p->load_raw = &DCR_CLASS dcr_unpacked_load_raw;\r\n\t}\r\n\tdcr_fseek(p->obj_, off_setup+792, SEEK_SET);\r\n\tstrcpy (p->make, \"CINE\");\r\n\tsprintf (p->model, \"%d\", dcr_get4(p));\r\n\tdcr_fseek(p->obj_, 12, SEEK_CUR);\r\n\tswitch ((i=dcr_get4(p)) & 0xffffff) {\r\n    case  3:  p->filters = 0x94949494;  break;\r\n    case  4:  p->filters = 0x49494949;  break;\r\n    default:  p->is_raw = 0;\r\n\t}\r\n\tdcr_fseek(p->obj_, 72, SEEK_CUR);\r\n\tswitch ((dcr_get4(p)+3600) % 360) {\r\n    case 270:  p->flip = 4;  break;\r\n    case 180:  p->flip = 1;  break;\r\n    case  90:  p->flip = 7;  break;\r\n    case   0:  p->flip = 2;\r\n\t}\r\n\tp->cam_mul[0] = (float)dcr_getreal(p, 11);\r\n\tp->cam_mul[2] = (float)dcr_getreal(p, 11);\r\n\tp->maximum = ~(-1 << dcr_get4(p));\r\n\tdcr_fseek(p->obj_, 668, SEEK_CUR);\r\n\tp->shutter = dcr_get4(p)/1000000000.0f;\r\n\tdcr_fseek(p->obj_, off_image, SEEK_SET);\r\n\tif (p->opt.shot_select < p->is_raw)\r\n\t\tdcr_fseek(p->obj_, p->opt.shot_select*8, SEEK_CUR);\r\n\tp->data_offset  = (off_t) dcr_get4(p) + 8;\r\n\tp->data_offset += (off_t) ((__int64)dcr_get4(p) << 32);\r\n}\r\n\r\nchar * DCR_CLASS dcr_foveon_gets (DCRAW* p, int offset, char *str, int len)\r\n{\r\n\tint i;\r\n\tdcr_fseek(p->obj_, offset, SEEK_SET);\r\n\tfor (i=0; i < len-1; i++)\r\n\t\tif ((str[i] = (char)dcr_get2(p)) == 0) break;\r\n\tstr[i] = 0;\r\n\treturn str;\r\n}\r\n\r\nvoid DCR_CLASS dcr_parse_foveon(DCRAW* p)\r\n{\r\n\tint entries, img=0, off, len, tag, save, i, wide, high, pent, poff[256][2];\r\n\tchar name[64], value[64];\r\n\r\n\tp->order = 0x4949;\t\t\t/* Little-endian */\r\n\tdcr_fseek(p->obj_, 36, SEEK_SET);\r\n\tp->flip = dcr_get4(p);\r\n\tdcr_fseek(p->obj_, -4, SEEK_END);\r\n\tdcr_fseek(p->obj_, dcr_get4(p), SEEK_SET);\r\n\tif (dcr_get4(p) != 0x64434553) return;\t/* SECd */\r\n\tentries = (dcr_get4(p),dcr_get4(p));\r\n\twhile (entries--) {\r\n\t\toff = dcr_get4(p);\r\n\t\tlen = dcr_get4(p);\r\n\t\ttag = dcr_get4(p);\r\n\t\tsave = dcr_ftell(p->obj_);\r\n\t\tdcr_fseek(p->obj_, off, SEEK_SET);\r\n\t\tif (dcr_get4(p) != (unsigned int)(0x20434553 | (tag << 24))) return;\r\n\t\tswitch (tag) {\r\n\t\tcase 0x47414d49:\t\t\t/* IMAG */\r\n\t\tcase 0x32414d49:\t\t\t/* IMA2 */\r\n\t\t\tdcr_fseek(p->obj_, 12, SEEK_CUR);\r\n\t\t\twide = dcr_get4(p);\r\n\t\t\thigh = dcr_get4(p);\r\n\t\t\tif (wide > p->raw_width && high > p->raw_height) {\r\n\t\t\t\tp->raw_width  = wide;\r\n\t\t\t\tp->raw_height = high;\r\n\t\t\t\tp->data_offset = off+24;\r\n\t\t\t}\r\n\t\t\tdcr_fseek(p->obj_, off+28, SEEK_SET);\r\n\t\t\tif (dcr_fgetc(p->obj_) == 0xff && dcr_fgetc(p->obj_) == 0xd8\r\n\t\t\t\t&& (int)p->thumb_length < len-28) {\r\n\t\t\t\tp->thumb_offset = off+28;\r\n\t\t\t\tp->thumb_length = len-28;\r\n\t\t\t\tp->write_thumb = &DCR_CLASS dcr_jpeg_thumb;\r\n\t\t\t}\r\n\t\t\tif (++img == 2 && !p->thumb_length) {\r\n#if RESTRICTED\r\n\t\t\t\tp->thumb_offset = off+24;\r\n\t\t\t\tp->thumb_width = wide;\r\n\t\t\t\tp->thumb_height = high;\r\n\t\t\t\tp->write_thumb = &DCR_CLASS dcr_foveon_thumb;\r\n#endif //RESTRICTED\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\tcase 0x464d4143:\t\t\t/* CAMF */\r\n\t\t\tp->meta_offset = off+24;\r\n\t\t\tp->meta_length = len-28;\r\n\t\t\tif (p->meta_length > 0x20000)\r\n\t\t\t\tp->meta_length = 0x20000;\r\n\t\t\tbreak;\r\n\t\tcase 0x504f5250:\t\t\t/* PROP */\r\n\t\t\tpent = (dcr_get4(p),dcr_get4(p));\r\n\t\t\tdcr_fseek(p->obj_, 12, SEEK_CUR);\r\n\t\t\toff += pent*8 + 24;\r\n\t\t\tif ((unsigned) pent > 256) pent=256;\r\n\t\t\tfor (i=0; i < pent*2; i++)\r\n\t\t\t\tpoff[0][i] = off + dcr_get4(p)*2;\r\n\t\t\tfor (i=0; i < pent; i++) {\r\n\t\t\t\tdcr_foveon_gets (p, poff[i][0], name, 64);\r\n\t\t\t\tdcr_foveon_gets (p, poff[i][1], value, 64);\r\n\t\t\t\tif (!strcmp (name, \"ISO\"))\r\n\t\t\t\t\tp->iso_speed = (float)atoi(value);\r\n\t\t\t\tif (!strcmp (name, \"CAMMANUF\"))\r\n\t\t\t\t\tstrcpy (p->make, value);\r\n\t\t\t\tif (!strcmp (name, \"CAMMODEL\"))\r\n\t\t\t\t\tstrcpy (p->model, value);\r\n\t\t\t\tif (!strcmp (name, \"WB_DESC\"))\r\n\t\t\t\t\tstrcpy (p->model2, value);\r\n\t\t\t\tif (!strcmp (name, \"TIME\"))\r\n\t\t\t\t\tp->timestamp = atoi(value);\r\n\t\t\t\tif (!strcmp (name, \"EXPTIME\"))\r\n\t\t\t\t\tp->shutter = atoi(value) / 1000000.0f;\r\n\t\t\t\tif (!strcmp (name, \"APERTURE\"))\r\n\t\t\t\t\tp->aperture = (float)atof(value);\r\n\t\t\t\tif (!strcmp (name, \"FLENGTH\"))\r\n\t\t\t\t\tp->focal_len = (float)atof(value);\r\n\t\t\t}\r\n#ifdef LOCALTIME\r\n\t\t\tp->timestamp = mktime (gmtime (&p->timestamp));\r\n#endif\r\n\t\t}\r\n\t\tdcr_fseek(p->obj_, save, SEEK_SET);\r\n\t}\r\n\tp->is_foveon = 1;\r\n}\r\n\r\n/*\r\nThanks to Adobe for providing these excellent CAM -> XYZ matrices!\r\n*/\r\nvoid DCR_CLASS dcr_adobe_coeff (DCRAW* p, char *make, char *model)\r\n{\r\n\tstatic const struct {\r\n\t\tconst char *prefix;\r\n\t\tshort black, maximum, trans[12];\r\n\t} table[] = {\r\n    { \"Apple QuickTake\", 0, 0,\t\t/* DJC */\r\n\t{ 17576,-3191,-3318,5210,6733,-1942,9031,1280,-124 } },\r\n    { \"Canon EOS D2000\", 0, 0,\r\n\t{ 24542,-10860,-3401,-1490,11370,-297,2858,-605,3225 } },\r\n    { \"Canon EOS D6000\", 0, 0,\r\n\t{ 20482,-7172,-3125,-1033,10410,-285,2542,226,3136 } },\r\n    { \"Canon EOS D30\", 0, 0,\r\n\t{ 9805,-2689,-1312,-5803,13064,3068,-2438,3075,8775 } },\r\n    { \"Canon EOS D60\", 0, 0xfa0,\r\n\t{ 6188,-1341,-890,-7168,14489,2937,-2640,3228,8483 } },\r\n    { \"Canon EOS 5D Mark II\", 0, 0x3cf0,\r\n\t{ 4716,603,-830,-7798,15474,2480,-1496,1937,6651 } },\r\n    { \"Canon EOS 5D\", 0, 0xe6c,\r\n\t{ 6347,-479,-972,-8297,15954,2480,-1968,2131,7649 } },\r\n    { \"Canon EOS 10D\", 0, 0xfa0,\r\n\t{ 8197,-2000,-1118,-6714,14335,2592,-2536,3178,8266 } },\r\n    { \"Canon EOS 20Da\", 0, 0,\r\n\t{ 14155,-5065,-1382,-6550,14633,2039,-1623,1824,6561 } },\r\n    { \"Canon EOS 20D\", 0, 0xfff,\r\n\t{ 6599,-537,-891,-8071,15783,2424,-1983,2234,7462 } },\r\n    { \"Canon EOS 30D\", 0, 0,\r\n\t{ 6257,-303,-1000,-7880,15621,2396,-1714,1904,7046 } },\r\n    { \"Canon EOS 40D\", 0, 0x3f60,\r\n\t{ 6071,-747,-856,-7653,15365,2441,-2025,2553,7315 } },\r\n    { \"Canon EOS 50D\", 0, 0x3d93,\r\n\t{ 4920,616,-593,-6493,13964,2784,-1774,3178,7005 } },\r\n    { \"Canon EOS 300D\", 0, 0xfa0,\r\n\t{ 8197,-2000,-1118,-6714,14335,2592,-2536,3178,8266 } },\r\n    { \"Canon EOS 350D\", 0, 0xfff,\r\n\t{ 6018,-617,-965,-8645,15881,2975,-1530,1719,7642 } },\r\n    { \"Canon EOS 400D\", 0, 0xe8e,\r\n\t{ 7054,-1501,-990,-8156,15544,2812,-1278,1414,7796 } },\r\n    { \"Canon EOS 450D\", 0, 0x390d,\r\n\t{ 5784,-262,-821,-7539,15064,2672,-1982,2681,7427 } },\r\n    { \"Canon EOS 1000D\", 0, 0xe43,\r\n\t{ 6771,-1139,-977,-7818,15123,2928,-1244,1437,7533 } },\r\n    { \"Canon EOS-1Ds Mark III\", 0, 0x3bb0,\r\n\t{ 5859,-211,-930,-8255,16017,2353,-1732,1887,7448 } },\r\n    { \"Canon EOS-1Ds Mark II\", 0, 0xe80,\r\n\t{ 6517,-602,-867,-8180,15926,2378,-1618,1771,7633 } },\r\n    { \"Canon EOS-1D Mark II N\", 0, 0xe80,\r\n\t{ 6240,-466,-822,-8180,15825,2500,-1801,1938,8042 } },\r\n    { \"Canon EOS-1D Mark III\", 0, 0x3bb0,\r\n\t{ 6291,-540,-976,-8350,16145,2311,-1714,1858,7326 } },\r\n    { \"Canon EOS-1D Mark II\", 0, 0xe80,\r\n\t{ 6264,-582,-724,-8312,15948,2504,-1744,1919,8664 } },\r\n    { \"Canon EOS-1DS\", 0, 0xe20,\r\n\t{ 4374,3631,-1743,-7520,15212,2472,-2892,3632,8161 } },\r\n    { \"Canon EOS-1D\", 0, 0xe20,\r\n\t{ 6806,-179,-1020,-8097,16415,1687,-3267,4236,7690 } },\r\n    { \"Canon EOS\", 0, 0,\r\n\t{ 8197,-2000,-1118,-6714,14335,2592,-2536,3178,8266 } },\r\n    { \"Canon PowerShot A50\", 0, 0,\r\n\t{ -5300,9846,1776,3436,684,3939,-5540,9879,6200,-1404,11175,217 } },\r\n    { \"Canon PowerShot A5\", 0, 0,\r\n\t{ -4801,9475,1952,2926,1611,4094,-5259,10164,5947,-1554,10883,547 } },\r\n    { \"Canon PowerShot G10\", 0, 0,\r\n\t{ 11093,-3906,-1028,-5047,12492,2879,-1003,1750,5561 } },\r\n    { \"Canon PowerShot G1\", 0, 0,\r\n\t{ -4778,9467,2172,4743,-1141,4344,-5146,9908,6077,-1566,11051,557 } },\r\n    { \"Canon PowerShot G2\", 0, 0,\r\n\t{ 9087,-2693,-1049,-6715,14382,2537,-2291,2819,7790 } },\r\n    { \"Canon PowerShot G3\", 0, 0,\r\n\t{ 9212,-2781,-1073,-6573,14189,2605,-2300,2844,7664 } },\r\n    { \"Canon PowerShot G5\", 0, 0,\r\n\t{ 9757,-2872,-933,-5972,13861,2301,-1622,2328,7212 } },\r\n    { \"Canon PowerShot G6\", 0, 0,\r\n\t{ 9877,-3775,-871,-7613,14807,3072,-1448,1305,7485 } },\r\n    { \"Canon PowerShot G9\", 0, 0,\r\n\t{ 7368,-2141,-598,-5621,13254,2625,-1418,1696,5743 } },\r\n    { \"Canon PowerShot Pro1\", 0, 0,\r\n\t{ 10062,-3522,-999,-7643,15117,2730,-765,817,7323 } },\r\n    { \"Canon PowerShot Pro70\", 34, 0,\r\n\t{ -4155,9818,1529,3939,-25,4522,-5521,9870,6610,-2238,10873,1342 } },\r\n    { \"Canon PowerShot Pro90\", 0, 0,\r\n\t{ -4963,9896,2235,4642,-987,4294,-5162,10011,5859,-1770,11230,577 } },\r\n    { \"Canon PowerShot S30\", 0, 0,\r\n\t{ 10566,-3652,-1129,-6552,14662,2006,-2197,2581,7670 } },\r\n    { \"Canon PowerShot S40\", 0, 0,\r\n\t{ 8510,-2487,-940,-6869,14231,2900,-2318,2829,9013 } },\r\n    { \"Canon PowerShot S45\", 0, 0,\r\n\t{ 8163,-2333,-955,-6682,14174,2751,-2077,2597,8041 } },\r\n    { \"Canon PowerShot S50\", 0, 0,\r\n\t{ 8882,-2571,-863,-6348,14234,2288,-1516,2172,6569 } },\r\n    { \"Canon PowerShot S60\", 0, 0,\r\n\t{ 8795,-2482,-797,-7804,15403,2573,-1422,1996,7082 } },\r\n    { \"Canon PowerShot S70\", 0, 0,\r\n\t{ 9976,-3810,-832,-7115,14463,2906,-901,989,7889 } },\r\n    { \"Canon PowerShot A610\", 0, 0,\t/* DJC */\r\n\t{ 15591,-6402,-1592,-5365,13198,2168,-1300,1824,5075 } },\r\n    { \"Canon PowerShot A620\", 0, 0,\t/* DJC */\r\n\t{ 15265,-6193,-1558,-4125,12116,2010,-888,1639,5220 } },\r\n    { \"Canon PowerShot A630\", 0, 0,\t/* DJC */\r\n\t{ 14201,-5308,-1757,-6087,14472,1617,-2191,3105,5348 } },\r\n    { \"Canon PowerShot A640\", 0, 0,\t/* DJC */\r\n\t{ 13124,-5329,-1390,-3602,11658,1944,-1612,2863,4885 } },\r\n    { \"Canon PowerShot A650\", 0, 0,\t/* DJC */\r\n\t{ 9427,-3036,-959,-2581,10671,1911,-1039,1982,4430 } },\r\n    { \"Canon PowerShot A720\", 0, 0,\t/* DJC */\r\n\t{ 14573,-5482,-1546,-1266,9799,1468,-1040,1912,3810 } },\r\n    { \"Canon PowerShot S3 IS\", 0, 0,\t/* DJC */\r\n\t{ 14062,-5199,-1446,-4712,12470,2243,-1286,2028,4836 } },\r\n    { \"CINE 650\", 0, 0,\r\n\t{ 3390,480,-500,-800,3610,340,-550,2336,1192 } },\r\n    { \"CINE 660\", 0, 0,\r\n\t{ 3390,480,-500,-800,3610,340,-550,2336,1192 } },\r\n    { \"CINE\", 0, 0,\r\n\t{ 20183,-4295,-423,-3940,15330,3985,-280,4870,9800 } },\r\n    { \"Contax N Digital\", 0, 0xf1e,\r\n\t{ 7777,1285,-1053,-9280,16543,2916,-3677,5679,7060 } },\r\n    { \"EPSON R-D1\", 0, 0,\r\n\t{ 6827,-1878,-732,-8429,16012,2564,-704,592,7145 } },\r\n    { \"FUJIFILM FinePix E550\", 0, 0,\r\n\t{ 11044,-3888,-1120,-7248,15168,2208,-1531,2277,8069 } },\r\n    { \"FUJIFILM FinePix E900\", 0, 0,\r\n\t{ 9183,-2526,-1078,-7461,15071,2574,-2022,2440,8639 } },\r\n    { \"FUJIFILM FinePix F8\", 0, 0,\r\n\t{ 11044,-3888,-1120,-7248,15168,2208,-1531,2277,8069 } },\r\n    { \"FUJIFILM FinePix F7\", 0, 0,\r\n\t{ 10004,-3219,-1201,-7036,15047,2107,-1863,2565,7736 } },\r\n    { \"FUJIFILM FinePix S100FS\", 514, 0,\r\n\t{ 11521,-4355,-1065,-6524,13767,3058,-1466,1984,6045 } },\r\n    { \"FUJIFILM FinePix S20Pro\", 0, 0,\r\n\t{ 10004,-3219,-1201,-7036,15047,2107,-1863,2565,7736 } },\r\n    { \"FUJIFILM FinePix S2Pro\", 128, 0,\r\n\t{ 12492,-4690,-1402,-7033,15423,1647,-1507,2111,7697 } },\r\n    { \"FUJIFILM FinePix S3Pro\", 0, 0,\r\n\t{ 11807,-4612,-1294,-8927,16968,1988,-2120,2741,8006 } },\r\n    { \"FUJIFILM FinePix S5Pro\", 0, 0,\r\n\t{ 12300,-5110,-1304,-9117,17143,1998,-1947,2448,8100 } },\r\n    { \"FUJIFILM FinePix S5000\", 0, 0,\r\n\t{ 8754,-2732,-1019,-7204,15069,2276,-1702,2334,6982 } },\r\n    { \"FUJIFILM FinePix S5100\", 0, 0x3e00,\r\n\t{ 11940,-4431,-1255,-6766,14428,2542,-993,1165,7421 } },\r\n    { \"FUJIFILM FinePix S5500\", 0, 0x3e00,\r\n\t{ 11940,-4431,-1255,-6766,14428,2542,-993,1165,7421 } },\r\n    { \"FUJIFILM FinePix S5200\", 0, 0,\r\n\t{ 9636,-2804,-988,-7442,15040,2589,-1803,2311,8621 } },\r\n    { \"FUJIFILM FinePix S5600\", 0, 0,\r\n\t{ 9636,-2804,-988,-7442,15040,2589,-1803,2311,8621 } },\r\n    { \"FUJIFILM FinePix S6\", 0, 0,\r\n\t{ 12628,-4887,-1401,-6861,14996,1962,-2198,2782,7091 } },\r\n    { \"FUJIFILM FinePix S7000\", 0, 0,\r\n\t{ 10190,-3506,-1312,-7153,15051,2238,-2003,2399,7505 } },\r\n    { \"FUJIFILM FinePix S9000\", 0, 0,\r\n\t{ 10491,-3423,-1145,-7385,15027,2538,-1809,2275,8692 } },\r\n    { \"FUJIFILM FinePix S9500\", 0, 0,\r\n\t{ 10491,-3423,-1145,-7385,15027,2538,-1809,2275,8692 } },\r\n    { \"FUJIFILM FinePix S9100\", 0, 0,\r\n\t{ 12343,-4515,-1285,-7165,14899,2435,-1895,2496,8800 } },\r\n    { \"FUJIFILM FinePix S9600\", 0, 0,\r\n\t{ 12343,-4515,-1285,-7165,14899,2435,-1895,2496,8800 } },\r\n    { \"FUJIFILM IS-1\", 0, 0,\r\n\t{ 21461,-10807,-1441,-2332,10599,1999,289,875,7703 } },\r\n    { \"FUJIFILM IS Pro\", 0, 0,\r\n\t{ 12300,-5110,-1304,-9117,17143,1998,-1947,2448,8100 } },\r\n    { \"Imacon Ixpress\", 0, 0,\t\t/* DJC */\r\n\t{ 7025,-1415,-704,-5188,13765,1424,-1248,2742,6038 } },\r\n    { \"KODAK NC2000\", 0, 0,\r\n\t{ 13891,-6055,-803,-465,9919,642,2121,82,1291 } },\r\n    { \"Kodak DCS315C\", 8, 0,\r\n\t{ 17523,-4827,-2510,756,8546,-137,6113,1649,2250 } },\r\n    { \"Kodak DCS330C\", 8, 0,\r\n\t{ 20620,-7572,-2801,-103,10073,-396,3551,-233,2220 } },\r\n    { \"KODAK DCS420\", 0, 0,\r\n\t{ 10868,-1852,-644,-1537,11083,484,2343,628,2216 } },\r\n    { \"KODAK DCS460\", 0, 0,\r\n\t{ 10592,-2206,-967,-1944,11685,230,2206,670,1273 } },\r\n    { \"KODAK EOSDCS1\", 0, 0,\r\n\t{ 10592,-2206,-967,-1944,11685,230,2206,670,1273 } },\r\n    { \"KODAK EOSDCS3B\", 0, 0,\r\n\t{ 9898,-2700,-940,-2478,12219,206,1985,634,1031 } },\r\n    { \"Kodak DCS520C\", 180, 0,\r\n\t{ 24542,-10860,-3401,-1490,11370,-297,2858,-605,3225 } },\r\n    { \"Kodak DCS560C\", 188, 0,\r\n\t{ 20482,-7172,-3125,-1033,10410,-285,2542,226,3136 } },\r\n    { \"Kodak DCS620C\", 180, 0,\r\n\t{ 23617,-10175,-3149,-2054,11749,-272,2586,-489,3453 } },\r\n    { \"Kodak DCS620X\", 185, 0,\r\n\t{ 13095,-6231,154,12221,-21,-2137,895,4602,2258 } },\r\n    { \"Kodak DCS660C\", 214, 0,\r\n\t{ 18244,-6351,-2739,-791,11193,-521,3711,-129,2802 } },\r\n    { \"Kodak DCS720X\", 0, 0,\r\n\t{ 11775,-5884,950,9556,1846,-1286,-1019,6221,2728 } },\r\n    { \"Kodak DCS760C\", 0, 0,\r\n\t{ 16623,-6309,-1411,-4344,13923,323,2285,274,2926 } },\r\n    { \"Kodak DCS Pro SLR\", 0, 0,\r\n\t{ 5494,2393,-232,-6427,13850,2846,-1876,3997,5445 } },\r\n    { \"Kodak DCS Pro 14nx\", 0, 0,\r\n\t{ 5494,2393,-232,-6427,13850,2846,-1876,3997,5445 } },\r\n    { \"Kodak DCS Pro 14\", 0, 0,\r\n\t{ 7791,3128,-776,-8588,16458,2039,-2455,4006,6198 } },\r\n    { \"Kodak ProBack645\", 0, 0,\r\n\t{ 16414,-6060,-1470,-3555,13037,473,2545,122,4948 } },\r\n    { \"Kodak ProBack\", 0, 0,\r\n\t{ 21179,-8316,-2918,-915,11019,-165,3477,-180,4210 } },\r\n    { \"KODAK P712\", 0, 0,\r\n\t{ 9658,-3314,-823,-5163,12695,2768,-1342,1843,6044 } },\r\n    { \"KODAK P850\", 0, 0xf7c,\r\n\t{ 10511,-3836,-1102,-6946,14587,2558,-1481,1792,6246 } },\r\n    { \"KODAK P880\", 0, 0xfff,\r\n\t{ 12805,-4662,-1376,-7480,15267,2360,-1626,2194,7904 } },\r\n    { \"Leaf CMost\", 0, 0,\r\n\t{ 3952,2189,449,-6701,14585,2275,-4536,7349,6536 } },\r\n    { \"Leaf Valeo 6\", 0, 0,\r\n\t{ 3952,2189,449,-6701,14585,2275,-4536,7349,6536 } },\r\n    { \"Leaf Aptus 54S\", 0, 0,\r\n\t{ 8236,1746,-1314,-8251,15953,2428,-3673,5786,5771 } },\r\n    { \"Leaf Aptus 65\", 0, 0,\r\n\t{ 7914,1414,-1190,-8777,16582,2280,-2811,4605,5562 } },\r\n    { \"Leaf Aptus 75\", 0, 0,\r\n\t{ 7914,1414,-1190,-8777,16582,2280,-2811,4605,5562 } },\r\n    { \"Leaf\", 0, 0,\r\n\t{ 8236,1746,-1314,-8251,15953,2428,-3673,5786,5771 } },\r\n    { \"Mamiya ZD\", 0, 0,\r\n\t{ 7645,2579,-1363,-8689,16717,2015,-3712,5941,5961 } },\r\n    { \"Micron 2010\", 110, 0,\t\t/* DJC */\r\n\t{ 16695,-3761,-2151,155,9682,163,3433,951,4904 } },\r\n    { \"Minolta DiMAGE 5\", 0, 0xf7d,\r\n\t{ 8983,-2942,-963,-6556,14476,2237,-2426,2887,8014 } },\r\n    { \"Minolta DiMAGE 7Hi\", 0, 0xf7d,\r\n\t{ 11368,-3894,-1242,-6521,14358,2339,-2475,3056,7285 } },\r\n    { \"Minolta DiMAGE 7\", 0, 0xf7d,\r\n\t{ 9144,-2777,-998,-6676,14556,2281,-2470,3019,7744 } },\r\n    { \"Minolta DiMAGE A1\", 0, 0xf8b,\r\n\t{ 9274,-2547,-1167,-8220,16323,1943,-2273,2720,8340 } },\r\n    { \"MINOLTA DiMAGE A200\", 0, 0,\r\n\t{ 8560,-2487,-986,-8112,15535,2771,-1209,1324,7743 } },\r\n    { \"Minolta DiMAGE A2\", 0, 0xf8f,\r\n\t{ 9097,-2726,-1053,-8073,15506,2762,-966,981,7763 } },\r\n    { \"Minolta DiMAGE Z2\", 0, 0,\t/* DJC */\r\n\t{ 11280,-3564,-1370,-4655,12374,2282,-1423,2168,5396 } },\r\n    { \"MINOLTA DYNAX 5\", 0, 0xffb,\r\n\t{ 10284,-3283,-1086,-7957,15762,2316,-829,882,6644 } },\r\n    { \"MINOLTA DYNAX 7\", 0, 0xffb,\r\n\t{ 10239,-3104,-1099,-8037,15727,2451,-927,925,6871 } },\r\n    { \"NIKON D100\", 0, 0,\r\n\t{ 5902,-933,-782,-8983,16719,2354,-1402,1455,6464 } },\r\n    { \"NIKON D1H\", 0, 0,\r\n\t{ 7577,-2166,-926,-7454,15592,1934,-2377,2808,8606 } },\r\n    { \"NIKON D1X\", 0, 0,\r\n\t{ 7702,-2245,-975,-9114,17242,1875,-2679,3055,8521 } },\r\n    { \"NIKON D1\", 0, 0, /* multiplied by 2.218750, 1.0, 1.148438 */\r\n\t{ 16772,-4726,-2141,-7611,15713,1972,-2846,3494,9521 } },\r\n    { \"NIKON D2H\", 0, 0,\r\n\t{ 5710,-901,-615,-8594,16617,2024,-2975,4120,6830 } },\r\n    { \"NIKON D2X\", 0, 0,\r\n\t{ 10231,-2769,-1255,-8301,15900,2552,-797,680,7148 } },\r\n    { \"NIKON D40X\", 0, 0,\r\n\t{ 8819,-2543,-911,-9025,16928,2151,-1329,1213,8449 } },\r\n    { \"NIKON D40\", 0, 0,\r\n\t{ 6992,-1668,-806,-8138,15748,2543,-874,850,7897 } },\r\n    { \"NIKON D50\", 0, 0,\r\n\t{ 7732,-2422,-789,-8238,15884,2498,-859,783,7330 } },\r\n    { \"NIKON D60\", 0, 0,\r\n\t{ 8736,-2458,-935,-9075,16894,2251,-1354,1242,8263 } },\r\n    { \"NIKON D700\", 0, 0,\r\n\t{ 8139,-2171,-663,-8747,16541,2295,-1925,2008,8093 } },\r\n    { \"NIKON D70\", 0, 0,\r\n\t{ 7732,-2422,-789,-8238,15884,2498,-859,783,7330 } },\r\n    { \"NIKON D80\", 0, 0,\r\n\t{ 8629,-2410,-883,-9055,16940,2171,-1490,1363,8520 } },\r\n    { \"NIKON D90\", 0, 0xf00,\r\n\t{ 7309,-1403,-519,-8474,16008,2622,-2434,2826,8064 } },\r\n    { \"NIKON D200\", 0, 0xfbc,\r\n\t{ 8367,-2248,-763,-8758,16447,2422,-1527,1550,8053 } },\r\n    { \"NIKON D300\", 0, 0,\r\n\t{ 9030,-1992,-715,-8465,16302,2255,-2689,3217,8069 } },\r\n    { \"NIKON D3\", 0, 0,\r\n\t{ 8139,-2171,-663,-8747,16541,2295,-1925,2008,8093 } },\r\n    { \"NIKON E950\", 0, 0x3dd,\t\t/* DJC */\r\n\t{ -3746,10611,1665,9621,-1734,2114,-2389,7082,3064,3406,6116,-244 } },\r\n    { \"NIKON E995\", 0, 0,\t/* copied from E5000 */\r\n\t{ -5547,11762,2189,5814,-558,3342,-4924,9840,5949,688,9083,96 } },\r\n    { \"NIKON E2100\", 0, 0,\t/* copied from Z2, new white balance */\r\n\t{ 13142,-4152,-1596,-4655,12374,2282,-1769,2696,6711} },\r\n    { \"NIKON E2500\", 0, 0,\r\n\t{ -5547,11762,2189,5814,-558,3342,-4924,9840,5949,688,9083,96 } },\r\n    { \"NIKON E4300\", 0, 0,\t/* copied from Minolta DiMAGE Z2 */\r\n\t{ 11280,-3564,-1370,-4655,12374,2282,-1423,2168,5396 } },\r\n    { \"NIKON E4500\", 0, 0,\r\n\t{ -5547,11762,2189,5814,-558,3342,-4924,9840,5949,688,9083,96 } },\r\n    { \"NIKON E5000\", 0, 0,\r\n\t{ -5547,11762,2189,5814,-558,3342,-4924,9840,5949,688,9083,96 } },\r\n    { \"NIKON E5400\", 0, 0,\r\n\t{ 9349,-2987,-1001,-7919,15766,2266,-2098,2680,6839 } },\r\n    { \"NIKON E5700\", 0, 0,\r\n\t{ -5368,11478,2368,5537,-113,3148,-4969,10021,5782,778,9028,211 } },\r\n    { \"NIKON E8400\", 0, 0,\r\n\t{ 7842,-2320,-992,-8154,15718,2599,-1098,1342,7560 } },\r\n    { \"NIKON E8700\", 0, 0,\r\n\t{ 8489,-2583,-1036,-8051,15583,2643,-1307,1407,7354 } },\r\n    { \"NIKON E8800\", 0, 0,\r\n\t{ 7971,-2314,-913,-8451,15762,2894,-1442,1520,7610 } },\r\n    { \"NIKON COOLPIX P6000\", 0, 0,\r\n\t{ 9698,-3367,-914,-4706,12584,2368,-837,968,5801 } },\r\n    { \"OLYMPUS C5050\", 0, 0,\r\n\t{ 10508,-3124,-1273,-6079,14294,1901,-1653,2306,6237 } },\r\n    { \"OLYMPUS C5060\", 0, 0,\r\n\t{ 10445,-3362,-1307,-7662,15690,2058,-1135,1176,7602 } },\r\n    { \"OLYMPUS C7070\", 0, 0,\r\n\t{ 10252,-3531,-1095,-7114,14850,2436,-1451,1723,6365 } },\r\n    { \"OLYMPUS C70\", 0, 0,\r\n\t{ 10793,-3791,-1146,-7498,15177,2488,-1390,1577,7321 } },\r\n    { \"OLYMPUS C80\", 0, 0,\r\n\t{ 8606,-2509,-1014,-8238,15714,2703,-942,979,7760 } },\r\n    { \"OLYMPUS E-10\", 0, (short)0xffc0,\r\n\t{ 12745,-4500,-1416,-6062,14542,1580,-1934,2256,6603 } },\r\n    { \"OLYMPUS E-1\", 0, (short)0xfff0,\r\n\t{ 11846,-4767,-945,-7027,15878,1089,-2699,4122,8311 } },\r\n    { \"OLYMPUS E-20\", 0, (short)0xffc0,\r\n\t{ 13173,-4732,-1499,-5807,14036,1895,-2045,2452,7142 } },\r\n    { \"OLYMPUS E-300\", 0, 0,\r\n\t{ 7828,-1761,-348,-5788,14071,1830,-2853,4518,6557 } },\r\n    { \"OLYMPUS E-330\", 0, 0,\r\n\t{ 8961,-2473,-1084,-7979,15990,2067,-2319,3035,8249 } },\r\n    { \"OLYMPUS E-3\", 0, 0xf99,\r\n\t{ 9487,-2875,-1115,-7533,15606,2010,-1618,2100,7389 } },\r\n    { \"OLYMPUS E-400\", 0, (short)0xfff0,\r\n\t{ 6169,-1483,-21,-7107,14761,2536,-2904,3580,8568 } },\r\n    { \"OLYMPUS E-410\", 0, 0xf6a,\r\n\t{ 8856,-2582,-1026,-7761,15766,2082,-2009,2575,7469 } },\r\n    { \"OLYMPUS E-420\", 0, 0xfd7,\r\n\t{ 8746,-2425,-1095,-7594,15612,2073,-1780,2309,7416 } },\r\n    { \"OLYMPUS E-500\", 0, 0,\r\n\t{ 8136,-1968,-299,-5481,13742,1871,-2556,4205,6630 } },\r\n    { \"OLYMPUS E-510\", 0, 0xf6a,\r\n\t{ 8785,-2529,-1033,-7639,15624,2112,-1783,2300,7817 } },\r\n    { \"OLYMPUS E-520\", 0, 0xfd2,\r\n\t{ 8344,-2322,-1020,-7596,15635,2048,-1748,2269,7287 } },\r\n    { \"OLYMPUS SP350\", 0, 0,\r\n\t{ 12078,-4836,-1069,-6671,14306,2578,-786,939,7418 } },\r\n    { \"OLYMPUS SP3\", 0, 0,\r\n\t{ 11766,-4445,-1067,-6901,14421,2707,-1029,1217,7572 } },\r\n    { \"OLYMPUS SP500UZ\", 0, 0xfff,\r\n\t{ 9493,-3415,-666,-5211,12334,3260,-1548,2262,6482 } },\r\n    { \"OLYMPUS SP510UZ\", 0, 0xffe,\r\n\t{ 10593,-3607,-1010,-5881,13127,3084,-1200,1805,6721 } },\r\n    { \"OLYMPUS SP550UZ\", 0, 0xffe,\r\n\t{ 11597,-4006,-1049,-5432,12799,2957,-1029,1750,6516 } },\r\n    { \"OLYMPUS SP560UZ\", 0, 0xff9,\r\n\t{ 10915,-3677,-982,-5587,12986,2911,-1168,1968,6223 } },\r\n    { \"OLYMPUS SP570UZ\", 0, 0,\r\n\t{ 11522,-4044,-1146,-4736,12172,2904,-988,1829,6039 } },\r\n    { \"PENTAX *ist DL2\", 0, 0,\r\n\t{ 10504,-2438,-1189,-8603,16207,2531,-1022,863,12242 } },\r\n    { \"PENTAX *ist DL\", 0, 0,\r\n\t{ 10829,-2838,-1115,-8339,15817,2696,-837,680,11939 } },\r\n    { \"PENTAX *ist DS2\", 0, 0,\r\n\t{ 10504,-2438,-1189,-8603,16207,2531,-1022,863,12242 } },\r\n    { \"PENTAX *ist DS\", 0, 0,\r\n\t{ 10371,-2333,-1206,-8688,16231,2602,-1230,1116,11282 } },\r\n    { \"PENTAX *ist D\", 0, 0,\r\n\t{ 9651,-2059,-1189,-8881,16512,2487,-1460,1345,10687 } },\r\n    { \"PENTAX K10D\", 0, 0,\r\n\t{ 9566,-2863,-803,-7170,15172,2112,-818,803,9705 } },\r\n    { \"PENTAX K1\", 0, 0,\r\n\t{ 11095,-3157,-1324,-8377,15834,2720,-1108,947,11688 } },\r\n    { \"PENTAX K20D\", 0, 0,\r\n\t{ 9427,-2714,-868,-7493,16092,1373,-2199,3264,7180 } },\r\n    { \"PENTAX K200D\", 0, 0,\r\n\t{ 9186,-2678,-907,-8693,16517,2260,-1129,1094,8524 } },\r\n    { \"PENTAX K2000\", 0, 0,\r\n\t{ 11057,-3604,-1155,-5152,13046,2329,-282,375,8104 } },\r\n    { \"PENTAX K-m\", 0, 0,\r\n\t{ 11057,-3604,-1155,-5152,13046,2329,-282,375,8104 } },\r\n    { \"Panasonic DMC-FZ8\", 0, (short)0xf7f0,\r\n\t{ 8986,-2755,-802,-6341,13575,3077,-1476,2144,6379 } },\r\n    { \"Panasonic DMC-FZ18\", 0, 0,\r\n\t{ 9932,-3060,-935,-5809,13331,2753,-1267,2155,5575 } },\r\n    { \"Panasonic DMC-FZ28\", 15, 0xfff,\r\n\t{ 10109,-3488,-993,-5412,12812,2916,-1305,2140,5543 } },\r\n    { \"Panasonic DMC-FZ30\", 0, (short)0xf94c,\r\n\t{ 10976,-4029,-1141,-7918,15491,2600,-1670,2071,8246 } },\r\n    { \"Panasonic DMC-FZ50\", 0, (short)0xfff0,\t/* aka \"LEICA V-LUX1\" */\r\n\t{ 7906,-2709,-594,-6231,13351,3220,-1922,2631,6537 } },\r\n    { \"Panasonic DMC-L10\", 15, 0xf96,\r\n\t{ 8025,-1942,-1050,-7920,15904,2100,-2456,3005,7039 } },\r\n    { \"Panasonic DMC-L1\", 0, (short)0xf7fc,\t/* aka \"LEICA DIGILUX 3\" */\r\n\t{ 8054,-1885,-1025,-8349,16367,2040,-2805,3542,7629 } },\r\n    { \"Panasonic DMC-LC1\", 0, 0,\t/* aka \"LEICA DIGILUX 2\" */\r\n\t{ 11340,-4069,-1275,-7555,15266,2448,-2960,3426,7685 } },\r\n    { \"Panasonic DMC-LX1\", 0, (short)0xf7f0,\t/* aka \"LEICA D-LUX2\" */\r\n\t{ 10704,-4187,-1230,-8314,15952,2501,-920,945,8927 } },\r\n    { \"Panasonic DMC-LX2\", 0, 0,\t/* aka \"LEICA D-LUX3\" */\r\n\t{ 8048,-2810,-623,-6450,13519,3272,-1700,2146,7049 } },\r\n    { \"Panasonic DMC-LX3\", 15, 0xfff,\t/* aka \"LEICA D-LUX4\" */\r\n\t{ 8128,-2668,-655,-6134,13307,3161,-1782,2568,6083 } },\r\n    { \"Panasonic DMC-FX150\", 15, 0xfff,\r\n\t{ 9082,-2907,-925,-6119,13377,3058,-1797,2641,5609 } },\r\n    { \"Panasonic DMC-G1\", 15, 0xfff,\r\n\t{ 8199,-2065,-1056,-8124,16156,2033,-2458,3022,7220 } },\r\n    { \"Phase One H 20\", 0, 0,\t\t/* DJC */\r\n\t{ 1313,1855,-109,-6715,15908,808,-327,1840,6020 } },\r\n    { \"Phase One P 2\", 0, 0,\r\n\t{ 2905,732,-237,-8134,16626,1476,-3038,4253,7517 } },\r\n    { \"Phase One P 30\", 0, 0,\r\n\t{ 4516,-245,-37,-7020,14976,2173,-3206,4671,7087 } },\r\n    { \"Phase One P 45\", 0, 0,\r\n\t{ 5053,-24,-117,-5684,14076,1702,-2619,4492,5849 } },\r\n    { \"SAMSUNG GX-1\", 0, 0,\r\n\t{ 10504,-2438,-1189,-8603,16207,2531,-1022,863,12242 } },\r\n    { \"Sinar\", 0, 0,\t\t\t/* DJC */\r\n\t{ 16442,-2956,-2422,-2877,12128,750,-1136,6066,4559 } },\r\n    { \"SONY DSC-F828\", 491, 0,\r\n\t{ 7924,-1910,-777,-8226,15459,2998,-1517,2199,6818,-7242,11401,3481 } },\r\n    { \"SONY DSC-R1\", 512, 0,\r\n\t{ 8512,-2641,-694,-8042,15670,2526,-1821,2117,7414 } },\r\n    { \"SONY DSC-V3\", 0, 0,\r\n\t{ 7511,-2571,-692,-7894,15088,3060,-948,1111,8128 } },\r\n    { \"SONY DSLR-A100\", 0, 0xfeb,\r\n\t{ 9437,-2811,-774,-8405,16215,2290,-710,596,7181 } },\r\n    { \"SONY DSLR-A200\", 0, 0,\r\n\t{ 9847,-3091,-928,-8485,16345,2225,-715,595,7103 } },\r\n    { \"SONY DSLR-A300\", 0, 0,\r\n\t{ 9847,-3091,-928,-8485,16345,2225,-715,595,7103 } },\r\n    { \"SONY DSLR-A350\", 0, 0xffc,\r\n\t{ 6038,-1484,-578,-9146,16746,2513,-875,746,7217 } },\r\n    { \"SONY DSLR-A700\", 254, 0x1ffe,\r\n\t{ 5775,-805,-359,-8574,16295,2391,-1943,2341,7249 } },\r\n    { \"SONY DSLR-A900\", 254, 0x1ffe,\r\n\t{ 5209,-1072,-397,-8845,16120,2919,-1618,1803,8654 } }\r\n  };\r\n  double cam_xyz[4][3];\r\n  char name[130];\r\n  int i, j;\r\n\r\n  sprintf (name, \"%s %s\", make, model);\r\n  for (i=0; i < sizeof table / sizeof *table; i++)\r\n\t  if (!strncmp (name, table[i].prefix, strlen(table[i].prefix))) {\r\n\t\t  if (table[i].black)   p->black = (ushort) table[i].black;\r\n\t\t  if (table[i].maximum) p->maximum = (ushort) table[i].maximum;\r\n\t\t  for (j=0; j < 12; j++)\r\n\t\t\t  cam_xyz[0][j] = table[i].trans[j] / 10000.0;\r\n\t\t  dcr_cam_xyz_coeff (p, cam_xyz);\r\n\t\t  break;\r\n\t  }\r\n}\r\n\r\nvoid DCR_CLASS dcr_simple_coeff (DCRAW* p, int index)\r\n{\r\n\tstatic const float table[][12] = {\r\n\t\t/* index 0 -- all Foveon cameras */\r\n\t\t{ 1.4032f,-0.2231f,-0.1016f,-0.5263f,1.4816f,0.017f,-0.0112f,0.0183f,0.9113f },\r\n\t\t\t/* index 1 -- Kodak DC20 and DC25 */\r\n\t\t{ 2.25f,0.75f,-1.75f,-0.25f,-0.25f,0.75f,0.75f,-0.25f,-0.25f,-1.75f,0.75f,2.25f },\r\n\t\t/* index 2 -- Logitech Fotoman Pixtura */\r\n\t\t{ 1.893f,-0.418f,-0.476f,-0.495f,1.773f,-0.278f,-1.017f,-0.655f,2.672f },\r\n\t\t/* index 3 -- Nikon E880, E900, and E990 */\r\n\t\t{ -1.936280f,  1.800443f, -1.448486f,  2.584324f,\r\n\t\t1.405365f, -0.524955f, -0.289090f,  0.408680f,\r\n\t\t-1.204965f,  1.082304f,  2.941367f, -1.818705f }\r\n\t};\r\n\tint i, c;\r\n\r\n\tfor (p->raw_color = i=0; i < 3; i++)\r\n\t\tFORCC(p) p->rgb_cam[i][c] = table[index][i*p->colors+c];\r\n}\r\n\r\nshort DCR_CLASS dcr_guess_byte_order (DCRAW* p, int words)\r\n{\r\n\tuchar test[4][2];\r\n\tint t=2, msb;\r\n\tdouble diff, sum[2] = {0,0};\r\n\r\n\tdcr_fread(p->obj_, test[0], 2, 2);\r\n\tfor (words-=2; words--; ) {\r\n\t\tdcr_fread(p->obj_, test[t], 2, 1);\r\n\t\tfor (msb=0; msb < 2; msb++) {\r\n\t\t\tdiff = (test[t^2][msb] << 8 | test[t^2][!msb])\r\n\t\t\t\t- (test[t  ][msb] << 8 | test[t  ][!msb]);\r\n\t\t\tsum[msb] += diff*diff;\r\n\t\t}\r\n\t\tt = (t+1) & 3;\r\n\t}\r\n\treturn sum[0] < sum[1] ? 0x4d4d : 0x4949;\r\n}\r\n\r\n/*\r\nIdentify which camera created this file, and set global variables\r\naccordingly.\r\n*/\r\nvoid DCR_CLASS dcr_identify(DCRAW* p)\r\n{\r\n\tchar head[32], *cp;\r\n\tunsigned hlen, fsize, i, c, is_canon;\r\n\tstruct dcr_jhead jh;\r\n\tstatic const struct {\r\n\t\tint fsize;\r\n\t\tchar make[12], model[19], withjpeg;\r\n\t} table[] = {\r\n\t\t{    62464, \"Kodak\",    \"DC20\"            ,0 },\r\n\t\t{   124928, \"Kodak\",    \"DC20\"            ,0 },\r\n\t\t{  1652736, \"Kodak\",    \"DCS200\"          ,0 },\r\n\t\t{  4159302, \"Kodak\",    \"C330\"            ,0 },\r\n\t\t{  4162462, \"Kodak\",    \"C330\"            ,0 },\r\n\t\t{   460800, \"Kodak\",    \"C603v\"           ,0 },\r\n\t\t{   614400, \"Kodak\",    \"C603v\"           ,0 },\r\n\t\t{  6163328, \"Kodak\",    \"C603\"            ,0 },\r\n\t\t{  6166488, \"Kodak\",    \"C603\"            ,0 },\r\n\t\t{  9116448, \"Kodak\",    \"C603y\"           ,0 },\r\n\t\t{   311696, \"ST Micro\", \"STV680 VGA\"      ,0 },  /* SPYz */\r\n\t\t{   614400, \"Kodak\",    \"KAI-0340\"        ,0 },\r\n\t\t{   787456, \"Creative\", \"PC-CAM 600\"      ,0 },\r\n\t\t{  1138688, \"Minolta\",  \"RD175\"           ,0 },\r\n\t\t{  3840000, \"Foculus\",  \"531C\"            ,0 },\r\n\t\t{   786432, \"AVT\",      \"F-080C\"          ,0 },\r\n\t\t{  1447680, \"AVT\",      \"F-145C\"          ,0 },\r\n\t\t{  1920000, \"AVT\",      \"F-201C\"          ,0 },\r\n\t\t{  5067304, \"AVT\",      \"F-510C\"          ,0 },\r\n\t\t{ 10134608, \"AVT\",      \"F-510C\"          ,0 },\r\n\t\t{ 16157136, \"AVT\",      \"F-810C\"          ,0 },\r\n\t\t{  1409024, \"Sony\",     \"XCD-SX910CR\"     ,0 },\r\n\t\t{  2818048, \"Sony\",     \"XCD-SX910CR\"     ,0 },\r\n\t\t{  3884928, \"Micron\",   \"2010\"            ,0 },\r\n\t\t{  6624000, \"Pixelink\", \"A782\"            ,0 },\r\n\t\t{ 13248000, \"Pixelink\", \"A782\"            ,0 },\r\n\t\t{  6291456, \"RoverShot\",\"3320AF\"          ,0 },\r\n\t\t{  6553440, \"Canon\",    \"PowerShot A460\"  ,0 },\r\n\t\t{  6653280, \"Canon\",    \"PowerShot A530\"  ,0 },\r\n\t\t{  6573120, \"Canon\",    \"PowerShot A610\"  ,0 },\r\n\t\t{  9219600, \"Canon\",    \"PowerShot A620\"  ,0 },\r\n\t\t{ 10341600, \"Canon\",    \"PowerShot A720\"  ,0 },\r\n\t\t{ 10383120, \"Canon\",    \"PowerShot A630\"  ,0 },\r\n\t\t{ 12945240, \"Canon\",    \"PowerShot A640\"  ,0 },\r\n\t\t{ 15636240, \"Canon\",    \"PowerShot A650\"  ,0 },\r\n\t\t{  5298000, \"Canon\",    \"PowerShot SD300\" ,0 },\r\n\t\t{  7710960, \"Canon\",    \"PowerShot S3 IS\" ,0 },\r\n\t\t{  5939200, \"OLYMPUS\",  \"C770UZ\"          ,0 },\r\n\t\t{  1581060, \"NIKON\",    \"E900\"            ,1 },  /* or E900s,E910 */\r\n\t\t{  2465792, \"NIKON\",    \"E950\"            ,1 },  /* or E800,E700 */\r\n\t\t{  2940928, \"NIKON\",    \"E2100\"           ,1 },  /* or E2500 */\r\n\t\t{  4771840, \"NIKON\",    \"E990\"            ,1 },  /* or E995, Oly C3030Z */\r\n\t\t{  4775936, \"NIKON\",    \"E3700\"           ,1 },  /* or Optio 33WR */\r\n\t\t{  5869568, \"NIKON\",    \"E4300\"           ,1 },  /* or DiMAGE Z2 */\r\n\t\t{  5865472, \"NIKON\",    \"E4500\"           ,1 },\r\n\t\t{  7438336, \"NIKON\",    \"E5000\"           ,1 },  /* or E5700 */\r\n\t\t{  8998912, \"NIKON\",    \"COOLPIX S6\"      ,1 },\r\n\t\t{  1976352, \"CASIO\",    \"QV-2000UX\"       ,1 },\r\n\t\t{  3217760, \"CASIO\",    \"QV-3*00EX\"       ,1 },\r\n\t\t{  6218368, \"CASIO\",    \"QV-5700\"         ,1 },\r\n\t\t{  6054400, \"CASIO\",    \"QV-R41\"          ,1 },\r\n\t\t{  7530816, \"CASIO\",    \"QV-R51\"          ,1 },\r\n\t\t{  7684000, \"CASIO\",    \"QV-4000\"         ,1 },\r\n\t\t{  4948608, \"CASIO\",    \"EX-S100\"         ,1 },\r\n\t\t{  7542528, \"CASIO\",    \"EX-Z50\"          ,1 },\r\n\t\t{  7753344, \"CASIO\",    \"EX-Z55\"          ,1 },\r\n\t\t{  7426656, \"CASIO\",    \"EX-P505\"         ,1 },\r\n\t\t{  9313536, \"CASIO\",    \"EX-P600\"         ,1 },\r\n\t\t{ 10979200, \"CASIO\",    \"EX-P700\"         ,1 },\r\n\t\t{  3178560, \"PENTAX\",   \"Optio S\"         ,1 },\r\n\t\t{  4841984, \"PENTAX\",   \"Optio S\"         ,1 },\r\n\t\t{  6114240, \"PENTAX\",   \"Optio S4\"        ,1 },  /* or S4i, CASIO EX-Z4 */\r\n\t\t{ 10702848, \"PENTAX\",   \"Optio 750Z\"      ,1 },\r\n\t\t{ 16098048, \"SAMSUNG\",  \"S85\"             ,1 },\r\n\t\t{ 16215552, \"SAMSUNG\",  \"S85\"             ,1 },\r\n\t\t{ 12582980, \"Sinar\",    \"\"                ,0 },\r\n\t\t{ 33292868, \"Sinar\",    \"\"                ,0 },\r\n\t\t{ 44390468, \"Sinar\",    \"\"                ,0 } };\r\n\tstatic const char *corp[] =\r\n\t\t{ \"Canon\", \"NIKON\", \"EPSON\", \"KODAK\", \"Kodak\", \"OLYMPUS\", \"PENTAX\",\r\n\t\t\"MINOLTA\", \"Minolta\", \"Konica\", \"CASIO\", \"Sinar\", \"Phase One\",\r\n\t\t\"SAMSUNG\", \"Mamiya\" };\r\n\r\n\tp->tiff_flip = p->flip = p->filters = -1;\t/* 0 is valid, so -1 is unknown */\r\n\tp->raw_height = p->raw_width = p->fuji_width = p->fuji_layout = p->cr2_slice[0] = 0;\r\n\tp->maximum = p->height = p->width = p->top_margin = p->left_margin = 0;\r\n\tp->cdesc[0] = p->desc[0] = p->artist[0] = p->make[0] = p->model[0] = p->model2[0] = 0;\r\n\tp->iso_speed = p->shutter = p->aperture = p->focal_len = 0.0f; p->unique_id = 0;\r\n\tmemset (p->gpsdata, 0, sizeof p->gpsdata);\r\n\tmemset (p->white, 0, sizeof p->white);\r\n\tp->thumb_offset = p->thumb_length = p->thumb_width = p->thumb_height = 0;\r\n\tp->load_raw = p->thumb_load_raw = 0;\r\n\tp->write_thumb = &DCR_CLASS dcr_jpeg_thumb;\r\n\tp->data_offset = p->meta_length = p->tiff_bps = p->tiff_compress = 0;\r\n\tp->kodak_cbpp = p->zero_after_ff = p->dng_version = p->load_flags = 0;\r\n\tp->timestamp = p->shot_order = p->tiff_samples = p->black = p->is_foveon = 0;\r\n\tp->mix_green = p->profile_length = p->data_error = p->zero_is_bad = 0;\r\n\tp->pixel_aspect = p->is_raw = p->raw_color = p->use_gamma = 1;\r\n\tp->tile_width = p->tile_length = INT_MAX;\r\n\tfor (i=0; i < 4; i++) {\r\n\t\tp->cam_mul[i] = (float)(i == 1);\r\n\t\tp->pre_mul[i] = (float)(i < 3);\r\n\t\tFORC3 p->cmatrix[c][i] = 0.0f;\r\n\t\tFORC3 p->rgb_cam[c][i] = (float)(c == i);\r\n\t}\r\n\tp->colors = 3;\r\n\tp->tiff_bps = 12;\r\n\tfor (i=0; i < 0x4000; i++) p->curve[i] = i;\r\n\r\n\tp->order = dcr_get2(p);\r\n\thlen = dcr_get4(p);\r\n\tdcr_fseek(p->obj_, 0, SEEK_SET);\r\n\tdcr_fread(p->obj_, head, 1, 32);\r\n\tdcr_fseek(p->obj_, 0, SEEK_END);\r\n\tfsize = dcr_ftell(p->obj_);\r\n\tif ((cp = (char *) memmem (head, 32, \"MMMM\", 4)) ||\r\n\t\t(cp = (char *) memmem (head, 32, \"IIII\", 4))) {\r\n\t\tdcr_parse_phase_one (p,cp-head);\r\n\t\tif (cp-head) dcr_parse_tiff(p,0);\r\n\t} else if (p->order == 0x4949 || p->order == 0x4d4d) {\r\n\t\tif (!memcmp (head+6,\"HEAPCCDR\",8)) {\r\n\t\t\tp->data_offset = hlen;\r\n\t\t\tdcr_parse_ciff (p,hlen, fsize - hlen);\r\n\t\t} else {\r\n\t\t\tdcr_parse_tiff(p,0);\r\n\t\t}\r\n\t} else if (!memcmp (head,\"\\xff\\xd8\\xff\\xe1\",4) &&\r\n\t\t!memcmp (head+6,\"Exif\",4)) {\r\n\t\tdcr_fseek(p->obj_, 4, SEEK_SET);\r\n\t\tp->data_offset = 4 + dcr_get2(p);\r\n\t\tdcr_fseek(p->obj_, p->data_offset, SEEK_SET);\r\n\t\tif (dcr_fgetc(p->obj_) != 0xff)\r\n\t\t\tdcr_parse_tiff(p,12);\r\n\t\tp->thumb_offset = 0;\r\n\t} else if (!memcmp (head+25,\"ARECOYK\",7)) {\r\n\t\tstrcpy (p->make, \"Contax\");\r\n\t\tstrcpy (p->model,\"N Digital\");\r\n\t\tdcr_fseek(p->obj_, 33, SEEK_SET);\r\n\t\tdcr_get_timestamp(p,1);\r\n\t\tdcr_fseek(p->obj_, 60, SEEK_SET);\r\n\t\tFORC4 p->cam_mul[c ^ (c >> 1)] = (float)dcr_get4(p);\r\n\t} else if (!strcmp (head, \"PXN\")) {\r\n\t\tstrcpy (p->make, \"Logitech\");\r\n\t\tstrcpy (p->model,\"Fotoman Pixtura\");\r\n\t} else if (!strcmp (head, \"qktk\")) {\r\n\t\tstrcpy (p->make, \"Apple\");\r\n\t\tstrcpy (p->model,\"QuickTake 100\");\r\n\t} else if (!strcmp (head, \"qktn\")) {\r\n\t\tstrcpy (p->make, \"Apple\");\r\n\t\tstrcpy (p->model,\"QuickTake 150\");\r\n\t} else if (!memcmp (head,\"FUJIFILM\",8)) {\r\n\t\tdcr_fseek(p->obj_, 84, SEEK_SET);\r\n\t\tp->thumb_offset = dcr_get4(p);\r\n\t\tp->thumb_length = dcr_get4(p);\r\n\t\tdcr_fseek(p->obj_, 92, SEEK_SET);\r\n\t\tdcr_parse_fuji (p,dcr_get4(p));\r\n\t\tif (p->thumb_offset > 120) {\r\n\t\t\tdcr_fseek(p->obj_, 120, SEEK_SET);\r\n\t\t\tp->is_raw += (i = dcr_get4(p)) && 1;\r\n\t\t\tif (p->is_raw == 2 && p->opt.shot_select)\r\n\t\t\t\tdcr_parse_fuji (p,i);\r\n\t\t}\r\n\t\tdcr_fseek(p->obj_, 100, SEEK_SET);\r\n\t\tp->data_offset = dcr_get4(p);\r\n\t\tdcr_parse_tiff (p, p->thumb_offset+12);\r\n\t} else if (!memcmp (head,\"RIFF\",4)) {\r\n\t\tdcr_fseek(p->obj_, 0, SEEK_SET);\r\n\t\tdcr_parse_riff(p);\r\n\t} else if (!memcmp (head,\"\\0\\001\\0\\001\\0@\",6)) {\r\n\t\tdcr_fseek(p->obj_, 6, SEEK_SET);\r\n\t\tdcr_fread(p->obj_, p->make, 1, 8);\r\n\t\tdcr_fread(p->obj_, p->model, 1, 8);\r\n\t\tdcr_fread(p->obj_, p->model2, 1, 16);\r\n\t\tp->data_offset = dcr_get2(p);\r\n\t\tdcr_get2(p);\r\n\t\tp->raw_width = dcr_get2(p);\r\n\t\tp->raw_height = dcr_get2(p);\r\n\t\tp->load_raw = &DCR_CLASS nokia_load_raw;\r\n\t\tp->filters = 0x61616161;\r\n\t} else if (!memcmp (head,\"DSC-Image\",9))\r\n\t\tdcr_parse_rollei(p);\r\n\telse if (!memcmp (head,\"PWAD\",4))\r\n\t\tdcr_parse_sinar_ia(p);\r\n\telse if (!memcmp (head,\"\\0MRM\",4))\r\n\t\tdcr_parse_minolta(p, 0);\r\n\telse if (!memcmp (head,\"FOVb\",4))\r\n\t\tdcr_parse_foveon(p);\r\n\telse if (!memcmp (head,\"CI\",2))\r\n\t\tdcr_parse_cine(p);\r\n\telse\r\n\t\tfor (i=0; i < sizeof table / sizeof *table; i++)\r\n\t\t\tif ((int)fsize == table[i].fsize) {\r\n\t\t\t\tstrcpy (p->make,  table[i].make );\r\n\t\t\t\tstrcpy (p->model, table[i].model);\r\n\t\t\t\tif (table[i].withjpeg)\r\n\t\t\t\t\tdcr_parse_external_jpeg(p);\r\n\t\t\t}\r\n\tif (p->make[0] == 0) dcr_parse_smal (p,0, fsize);\r\n\tif (p->make[0] == 0) dcr_parse_jpeg (p,p->is_raw = 0);\r\n\r\n\tfor (i=0; i < sizeof corp / sizeof *corp; i++)\r\n\t\tif (strstr (p->make, corp[i]))\t\t/* Simplify company names */\r\n\t\t\tstrcpy (p->make, corp[i]);\r\n\tif (!strncmp (p->make,\"KODAK\",5))\r\n\t\tp->make[16] = p->model[16] = 0;\r\n\tcp = p->make + strlen(p->make);\t\t/* Remove trailing spaces */\r\n\twhile (*--cp == ' ') *cp = 0;\r\n\tcp = p->model + strlen(p->model);\r\n\twhile (*--cp == ' ') *cp = 0;\r\n\ti = strlen(p->make);\t\t\t/* Remove p->make from p->model */\r\n\tif (!strncasecmp (p->model, p->make, i) && p->model[i++] == ' ')\r\n\t\tmemmove (p->model, p->model+i, 64-i);\r\n\tif (!strncmp (p->model,\"Digital Camera \",15))\r\n\t\tstrcpy (p->model, p->model+15);\r\n\tp->desc[511] = p->artist[63] = p->make[63] = p->model[63] = p->model2[63] = 0;\r\n\tif (!p->is_raw) goto notraw;\r\n\r\n\tif (!p->maximum) p->maximum = (1 << p->tiff_bps) - 1;\r\n\tif (!p->height) p->height = p->raw_height;\r\n\tif (!p->width)  p->width  = p->raw_width;\r\n\tif (p->fuji_width) {\r\n\t\tp->width = p->height + p->fuji_width;\r\n\t\tp->height = p->width - 1;\r\n\t\tp->pixel_aspect = 1;\r\n\t}\r\n\tif (p->height == 2624 && p->width == 3936)  /* Pentax K10D and Samsung GX10 */\r\n\t{   p->height  = 2616;   p->width  = 3896; }\r\n\tif (p->height == 3136 && p->width == 4864)\t/* Pentax K20D */\r\n\t{   p->height  = 3124;   p->width  = 4688; }\r\n\tif (p->height == 3014 && p->width == 4096)\t/* Ricoh GX200 */\r\n\t\tp->width  = 4014;\r\n\tif (p->dng_version) {\r\n\t\tif (p->filters == UINT_MAX) p->filters = 0;\r\n\t\tif (p->filters) p->is_raw = p->tiff_samples;\r\n\t\telse\t p->colors = p->tiff_samples;\r\n\t\tif (p->tiff_compress == 1)\r\n\t\t\tp->load_raw = &DCR_CLASS dcr_adobe_dng_load_raw_nc;\r\n\t\tif (p->tiff_compress == 7)\r\n\t\t\tp->load_raw = &DCR_CLASS dcr_adobe_dng_load_raw_lj;\r\n\t\tgoto dng_skip;\r\n\t}\r\n\tif ((is_canon = !strcmp(p->make,\"Canon\")))\r\n\t\tp->load_raw = memcmp (head+6,\"HEAPCCDR\",8) ?\r\n\t\t\t&DCR_CLASS dcr_lossless_jpeg_load_raw : &DCR_CLASS dcr_canon_compressed_load_raw;\r\n\tif (!strcmp(p->make,\"NIKON\")) {\r\n\t\tif (!p->load_raw)\r\n\t\t\tp->load_raw = &DCR_CLASS dcr_packed_12_load_raw;\r\n\t\tif (p->model[0] == 'E')\r\n\t\t\tp->load_flags |= !p->data_offset << 2 | 2;\r\n\t}\r\n\tif (!strcmp(p->make,\"CASIO\")) {\r\n\t\tp->load_raw = &DCR_CLASS dcr_packed_12_load_raw;\r\n\t\tp->maximum = 0xf7f;\r\n\t}\r\n\r\n\t/* Set parameters based on camera name (for non-DNG files). */\r\n\r\n\tif (p->is_foveon) {\r\n#if RESTRICTED\r\n\t\tif (p->height*2 < p->width) p->pixel_aspect = 0.5;\r\n\t\tif (p->height   > p->width) p->pixel_aspect = 2;\r\n\t\tp->filters = 0;\r\n\t\tp->load_raw = &DCR_CLASS dcr_foveon_load_raw;\r\n\t\tdcr_simple_coeff(p, 0);\r\n#endif //RESTRICTED\r\n\t} else if (is_canon && p->tiff_bps == 15) {\r\n\t\tswitch (p->width) {\r\n\t\tcase 3344: p->width -= 66;\r\n\t\tcase 3872: p->width -= 6;\r\n\t\t}\r\n\t\tp->filters = 0;\r\n\t\tp->load_raw = &DCR_CLASS dcr_canon_sraw_load_raw;\r\n\t} else if (!strcmp(p->model,\"PowerShot 600\")) {\r\n\t\tp->height = 613;\r\n\t\tp->width  = 854;\r\n\t\tp->raw_width = 896;\r\n\t\tp->pixel_aspect = 607/628.0;\r\n\t\tp->colors = 4;\r\n\t\tp->filters = 0xe1e4e1e4;\r\n\t\tp->load_raw = &DCR_CLASS dcr_canon_600_load_raw;\r\n\t} else if (!strcmp(p->model,\"PowerShot A5\") ||\r\n\t\t!strcmp(p->model,\"PowerShot A5 Zoom\")) {\r\n\t\tp->height = 773;\r\n\t\tp->width  = 960;\r\n\t\tp->raw_width = 992;\r\n\t\tp->pixel_aspect = 256/235.0;\r\n\t\tp->colors = 4;\r\n\t\tp->filters = 0x1e4e1e4e;\r\n\t\tp->load_raw = &DCR_CLASS dcr_canon_a5_load_raw;\r\n\t} else if (!strcmp(p->model,\"PowerShot A50\")) {\r\n\t\tp->height =  968;\r\n\t\tp->width  = 1290;\r\n\t\tp->raw_width = 1320;\r\n\t\tp->colors = 4;\r\n\t\tp->filters = 0x1b4e4b1e;\r\n\t\tp->load_raw = &DCR_CLASS dcr_canon_a5_load_raw;\r\n\t} else if (!strcmp(p->model,\"PowerShot Pro70\")) {\r\n\t\tp->height = 1024;\r\n\t\tp->width  = 1552;\r\n\t\tp->colors = 4;\r\n\t\tp->filters = 0x1e4b4e1b;\r\n\t\tp->load_raw = &DCR_CLASS dcr_canon_a5_load_raw;\r\n\t} else if (!strcmp(p->model,\"PowerShot SD300\")) {\r\n\t\tp->height = 1752;\r\n\t\tp->width  = 2344;\r\n\t\tp->raw_height = 1766;\r\n\t\tp->raw_width  = 2400;\r\n\t\tp->top_margin  = 12;\r\n\t\tp->left_margin = 12;\r\n\t\tp->load_raw = &DCR_CLASS dcr_canon_a5_load_raw;\r\n\t} else if (!strcmp(p->model,\"PowerShot A460\")) {\r\n\t\tp->height = 1960;\r\n\t\tp->width  = 2616;\r\n\t\tp->raw_height = 1968;\r\n\t\tp->raw_width  = 2664;\r\n\t\tp->top_margin  = 4;\r\n\t\tp->left_margin = 4;\r\n\t\tp->load_raw = &DCR_CLASS dcr_canon_a5_load_raw;\r\n\t} else if (!strcmp(p->model,\"PowerShot A530\")) {\r\n\t\tp->height = 1984;\r\n\t\tp->width  = 2620;\r\n\t\tp->raw_height = 1992;\r\n\t\tp->raw_width  = 2672;\r\n\t\tp->top_margin  = 6;\r\n\t\tp->left_margin = 10;\r\n\t\tp->load_raw = &DCR_CLASS dcr_canon_a5_load_raw;\r\n\t\tp->raw_color = 0;\r\n\t} else if (!strcmp(p->model,\"PowerShot A610\")) {\r\n\t\tif (dcr_canon_s2is(p)) strcpy (p->model+10, \"S2 IS\");\r\n\t\tp->height = 1960;\r\n\t\tp->width  = 2616;\r\n\t\tp->raw_height = 1968;\r\n\t\tp->raw_width  = 2672;\r\n\t\tp->top_margin  = 8;\r\n\t\tp->left_margin = 12;\r\n\t\tp->load_raw = &DCR_CLASS dcr_canon_a5_load_raw;\r\n\t} else if (!strcmp(p->model,\"PowerShot A620\")) {\r\n\t\tp->height = 2328;\r\n\t\tp->width  = 3112;\r\n\t\tp->raw_height = 2340;\r\n\t\tp->raw_width  = 3152;\r\n\t\tp->top_margin  = 12;\r\n\t\tp->left_margin = 36;\r\n\t\tp->load_raw = &DCR_CLASS dcr_canon_a5_load_raw;\r\n\t} else if (!strcmp(p->model,\"PowerShot A720\")) {\r\n\t\tp->height = 2472;\r\n\t\tp->width  = 3298;\r\n\t\tp->raw_height = 2480;\r\n\t\tp->raw_width  = 3336;\r\n\t\tp->top_margin  = 5;\r\n\t\tp->left_margin = 6;\r\n\t\tp->load_raw = &DCR_CLASS dcr_canon_a5_load_raw;\r\n\t} else if (!strcmp(p->model,\"PowerShot A630\")) {\r\n\t\tp->height = 2472;\r\n\t\tp->width  = 3288;\r\n\t\tp->raw_height = 2484;\r\n\t\tp->raw_width  = 3344;\r\n\t\tp->top_margin  = 6;\r\n\t\tp->left_margin = 12;\r\n\t\tp->load_raw = &DCR_CLASS dcr_canon_a5_load_raw;\r\n\t} else if (!strcmp(p->model,\"PowerShot A640\")) {\r\n\t\tp->height = 2760;\r\n\t\tp->width  = 3672;\r\n\t\tp->raw_height = 2772;\r\n\t\tp->raw_width  = 3736;\r\n\t\tp->top_margin  = 6;\r\n\t\tp->left_margin = 12;\r\n\t\tp->load_raw = &DCR_CLASS dcr_canon_a5_load_raw;\r\n\t} else if (!strcmp(p->model,\"PowerShot A650\")) {\r\n\t\tp->height = 3024;\r\n\t\tp->width  = 4032;\r\n\t\tp->raw_height = 3048;\r\n\t\tp->raw_width  = 4104;\r\n\t\tp->top_margin  = 12;\r\n\t\tp->left_margin = 48;\r\n\t\tp->load_raw = &DCR_CLASS dcr_canon_a5_load_raw;\r\n\t} else if (!strcmp(p->model,\"PowerShot S3 IS\")) {\r\n\t\tp->height = 2128;\r\n\t\tp->width  = 2840;\r\n\t\tp->raw_height = 2136;\r\n\t\tp->raw_width  = 2888;\r\n\t\tp->top_margin  = 8;\r\n\t\tp->left_margin = 44;\r\n\t\tp->load_raw = &DCR_CLASS dcr_canon_a5_load_raw;\r\n\t} else if (!strcmp(p->model,\"PowerShot Pro90 IS\")) {\r\n\t\tp->width  = 1896;\r\n\t\tp->colors = 4;\r\n\t\tp->filters = 0xb4b4b4b4;\r\n\t} else if (is_canon && p->raw_width == 2144) {\r\n\t\tp->height = 1550;\r\n\t\tp->width  = 2088;\r\n\t\tp->top_margin  = 8;\r\n\t\tp->left_margin = 4;\r\n\t\tif (!strcmp(p->model,\"PowerShot G1\")) {\r\n\t\t\tp->colors = 4;\r\n\t\t\tp->filters = 0xb4b4b4b4;\r\n\t\t}\r\n\t} else if (is_canon && p->raw_width == 2224) {\r\n\t\tp->height = 1448;\r\n\t\tp->width  = 2176;\r\n\t\tp->top_margin  = 6;\r\n\t\tp->left_margin = 48;\r\n\t} else if (is_canon && p->raw_width == 2376) {\r\n\t\tp->height = 1720;\r\n\t\tp->width  = 2312;\r\n\t\tp->top_margin  = 6;\r\n\t\tp->left_margin = 12;\r\n\t} else if (is_canon && p->raw_width == 2672) {\r\n\t\tp->height = 1960;\r\n\t\tp->width  = 2616;\r\n\t\tp->top_margin  = 6;\r\n\t\tp->left_margin = 12;\r\n\t} else if (is_canon && p->raw_width == 3152) {\r\n\t\tp->height = 2056;\r\n\t\tp->width  = 3088;\r\n\t\tp->top_margin  = 12;\r\n\t\tp->left_margin = 64;\r\n\t\tif (p->unique_id == 0x80000170)\r\n\t\t\tdcr_adobe_coeff (p, \"Canon\",\"EOS 300D\");\r\n\t} else if (is_canon && p->raw_width == 3160) {\r\n\t\tp->height = 2328;\r\n\t\tp->width  = 3112;\r\n\t\tp->top_margin  = 12;\r\n\t\tp->left_margin = 44;\r\n\t} else if (is_canon && p->raw_width == 3344) {\r\n\t\tp->height = 2472;\r\n\t\tp->width  = 3288;\r\n\t\tp->top_margin  = 6;\r\n\t\tp->left_margin = 4;\r\n\t} else if (!strcmp(p->model,\"EOS D2000C\")) {\r\n\t\tp->filters = 0x61616161;\r\n\t\tp->black = p->curve[200];\r\n\t} else if (is_canon && p->raw_width == 3516) {\r\n\t\tp->top_margin  = 14;\r\n\t\tp->left_margin = 42;\r\n\t\tif (p->unique_id == 0x80000189)\r\n\t\t\tdcr_adobe_coeff (p, \"Canon\",\"EOS 350D\");\r\n\t\tgoto canon_cr2;\r\n\t} else if (is_canon && p->raw_width == 3596) {\r\n\t\tp->top_margin  = 12;\r\n\t\tp->left_margin = 74;\r\n\t\tgoto canon_cr2;\r\n\t} else if (is_canon && p->raw_width == 3944) {\r\n\t\tp->height = 2602;\r\n\t\tp->width  = 3908;\r\n\t\tp->top_margin  = 18;\r\n\t\tp->left_margin = 30;\r\n\t} else if (is_canon && p->raw_width == 3948) {\r\n\t\tp->top_margin  = 18;\r\n\t\tp->left_margin = 42;\r\n\t\tp->height -= 2;\r\n\t\tif (p->unique_id == 0x80000236)\r\n\t\t\tdcr_adobe_coeff (p, \"Canon\",\"EOS 400D\");\r\n\t\tif (p->unique_id == 0x80000254)\r\n\t\t\tdcr_adobe_coeff (p, \"Canon\",\"EOS 1000D\");\r\n\t\tgoto canon_cr2;\r\n\t} else if (is_canon && p->raw_width == 3984) {\r\n\t\tp->top_margin  = 20;\r\n\t\tp->left_margin = 76;\r\n\t\tp->height -= 2;\r\n\t\tgoto canon_cr2;\r\n\t} else if (is_canon && p->raw_width == 4104) {\r\n\t\tp->height = 3024;\r\n\t\tp->width  = 4032;\r\n\t\tp->top_margin  = 12;\r\n\t\tp->left_margin = 48;\r\n\t} else if (is_canon && p->raw_width == 4312) {\r\n\t\tp->top_margin  = 18;\r\n\t\tp->left_margin = 22;\r\n\t\tp->height -= 2;\r\n\t\tif (p->unique_id == 0x80000176)\r\n\t\t\tdcr_adobe_coeff (p, \"Canon\",\"EOS 450D\");\r\n\t\tgoto canon_cr2;\r\n\t} else if (is_canon && p->raw_width == 4476) {\r\n\t\tp->top_margin  = 34;\r\n\t\tp->left_margin = 90;\r\n\t\tgoto canon_cr2;\r\n\t} else if (is_canon && p->raw_width == 4480) {\r\n\t\tp->height = 3326;\r\n\t\tp->width  = 4432;\r\n\t\tp->top_margin  = 10;\r\n\t\tp->left_margin = 12;\r\n\t\tp->filters = 0x49494949;\r\n\t} else if (is_canon && p->raw_width == 1208) {\r\n\t\tp->top_margin  = 51;\r\n\t\tp->left_margin = 62;\r\n\t\tp->raw_width = p->width *= 4;\r\n\t\tgoto canon_cr2;\r\n\t} else if (is_canon && p->raw_width == 1448) {\r\n\t\tp->top_margin  = 51;\r\n\t\tp->left_margin = 158;\r\n\t\tp->raw_width = p->width *= 4;\r\n\t\tgoto canon_cr2;\r\n\t} else if (is_canon && p->raw_width == 5108) {\r\n\t\tp->top_margin  = 13;\r\n\t\tp->left_margin = 98;\r\ncanon_cr2:\r\n\t\tp->height -= p->top_margin;\r\n\t\tp->width  -= p->left_margin;\r\n\t} else if (is_canon && p->raw_width == 5712) {\r\n\t\tp->height = 3752;\r\n\t\tp->width  = 5640;\r\n\t\tp->top_margin  = 20;\r\n\t\tp->left_margin = 62;\r\n\t} else if (!strcmp(p->model,\"D1\")) {\r\n\t\tp->cam_mul[0] *= 256/527.0f;\r\n\t\tp->cam_mul[2] *= 256/317.0f;\r\n\t} else if (!strcmp(p->model,\"D1X\")) {\r\n\t\tp->width -= 4;\r\n\t\tp->pixel_aspect = 0.5;\r\n\t} else if (!strcmp(p->model,\"D40X\") ||\r\n\t\t!strcmp(p->model,\"D60\")  ||\r\n\t\t!strcmp(p->model,\"D80\")) {\r\n\t\tp->height -= 3;\r\n\t\tp->width  -= 4;\r\n\t} else if (!strcmp(p->model,\"D3\")   ||\r\n\t\t!strcmp(p->model,\"D700\")) {\r\n\t\tp->width -= 4;\r\n\t\tp->left_margin = 2;\r\n\t} else if (!strncmp(p->model,\"D40\",3) ||\r\n\t\t!strncmp(p->model,\"D50\",3) ||\r\n\t\t!strncmp(p->model,\"D70\",3)) {\r\n\t\tp->width--;\r\n\t} else if (!strcmp(p->model,\"D90\")) {\r\n\t\tp->width -= 42;\r\n\t} else if (!strcmp(p->model,\"D100\")) {\r\n\t\tif (p->tiff_compress == 34713 && !dcr_nikon_is_compressed(p)) {\r\n\t\t\tp->load_raw = &DCR_CLASS dcr_packed_12_load_raw;\r\n\t\t\tp->load_flags |= 8;\r\n\t\t\tp->raw_width = (p->width += 3) + 3;\r\n\t\t}\r\n\t} else if (!strcmp(p->model,\"D200\")) {\r\n\t\tp->left_margin = 1;\r\n\t\tp->width -= 4;\r\n\t\tp->filters = 0x94949494;\r\n\t} else if (!strncmp(p->model,\"D2H\",3)) {\r\n\t\tp->left_margin = 6;\r\n\t\tp->width -= 14;\r\n\t} else if (!strncmp(p->model,\"D2X\",3)) {\r\n\t\tif (p->width == 3264) p->width -= 32;\r\n\t\telse p->width -= 8;\r\n\t} else if (!strcmp(p->model,\"D300\")) {\r\n\t\tp->width -= 32;\r\n\t} else if (!strcmp(p->model,\"COOLPIX P6000\")) {\r\n\t\tp->load_flags = 1;\r\n\t\tp->filters = 0x94949494;\r\n\t} else if (fsize == 1581060) {\r\n\t\tp->height = 963;\r\n\t\tp->width = 1287;\r\n\t\tp->raw_width = 1632;\r\n\t\tp->load_raw = &DCR_CLASS dcr_nikon_e900_load_raw;\r\n\t\tp->maximum = 0x3f4;\r\n\t\tp->colors = 4;\r\n\t\tp->filters = 0x1e1e1e1e;\r\n\t\tdcr_simple_coeff(p, 3);\r\n\t\tp->pre_mul[0] = 1.2085f;\r\n\t\tp->pre_mul[1] = 1.0943f;\r\n\t\tp->pre_mul[3] = 1.1103f;\r\n\t} else if (fsize == 2465792) {\r\n\t\tp->height = 1203;\r\n\t\tp->width  = 1616;\r\n\t\tp->raw_width = 2048;\r\n\t\tp->load_raw = &DCR_CLASS dcr_nikon_e900_load_raw;\r\n\t\tp->colors = 4;\r\n\t\tp->filters = 0x4b4b4b4b;\r\n\t\tdcr_adobe_coeff (p, \"NIKON\",\"E950\");\r\n\t} else if (fsize == 4771840) {\r\n\t\tp->height = 1540;\r\n\t\tp->width  = 2064;\r\n\t\tp->colors = 4;\r\n\t\tp->filters = 0xe1e1e1e1;\r\n\t\tp->load_raw = &DCR_CLASS dcr_packed_12_load_raw;\r\n\t\tp->load_flags = 6;\r\n\t\tif (!p->timestamp && dcr_nikon_e995(p))\r\n\t\t\tstrcpy (p->model, \"E995\");\r\n\t\tif (strcmp(p->model,\"E995\")) {\r\n\t\t\tp->filters = 0xb4b4b4b4;\r\n\t\t\tdcr_simple_coeff(p, 3);\r\n\t\t\tp->pre_mul[0] = 1.196f;\r\n\t\t\tp->pre_mul[1] = 1.246f;\r\n\t\t\tp->pre_mul[2] = 1.018f;\r\n\t\t}\r\n\t} else if (!strcmp(p->model,\"E2100\")) {\r\n\t\tif (!p->timestamp && !dcr_nikon_e2100(p)) goto cp_e2500;\r\n\t\tp->height = 1206;\r\n\t\tp->width  = 1616;\r\n\t\tp->load_flags = 7;\r\n\t} else if (!strcmp(p->model,\"E2500\")) {\r\ncp_e2500:\r\n\tstrcpy (p->model, \"E2500\");\r\n\tp->height = 1204;\r\n\tp->width  = 1616;\r\n\tp->colors = 4;\r\n\tp->filters = 0x4b4b4b4b;\r\n\t} else if (fsize == 4775936) {\r\n\t\tp->height = 1542;\r\n\t\tp->width  = 2064;\r\n\t\tp->load_raw = &DCR_CLASS dcr_packed_12_load_raw;\r\n\t\tp->load_flags = 7;\r\n\t\tp->pre_mul[0] = 1.818f;\r\n\t\tp->pre_mul[2] = 1.618f;\r\n\t\tif (!p->timestamp) dcr_nikon_3700(p);\r\n\t\tif (p->model[0] == 'E' && atoi(p->model+1) < 3700)\r\n\t\t\tp->filters = 0x49494949;\r\n\t\tif (!strcmp(p->model,\"Optio 33WR\")) {\r\n\t\t\tp->flip = 1;\r\n\t\t\tp->filters = 0x16161616;\r\n\t\t\tp->pre_mul[0] = 1.331f;\r\n\t\t\tp->pre_mul[2] = 1.820f;\r\n\t\t}\r\n\t} else if (fsize == 5869568) {\r\n\t\tp->height = 1710;\r\n\t\tp->width  = 2288;\r\n\t\tp->filters = 0x16161616;\r\n\t\tif (!p->timestamp && dcr_minolta_z2(p)) {\r\n\t\t\tstrcpy (p->make, \"Minolta\");\r\n\t\t\tstrcpy (p->model,\"DiMAGE Z2\");\r\n\t\t}\r\n\t\tp->load_raw = &DCR_CLASS dcr_packed_12_load_raw;\r\n\t\tp->load_flags = 6 + (p->make[0] == 'M');\r\n\t} else if (!strcmp(p->model,\"E4500\")) {\r\n\t\tp->height = 1708;\r\n\t\tp->width  = 2288;\r\n\t\tp->colors = 4;\r\n\t\tp->filters = 0xb4b4b4b4;\r\n\t} else if (fsize == 7438336) {\r\n\t\tp->height = 1924;\r\n\t\tp->width  = 2576;\r\n\t\tp->colors = 4;\r\n\t\tp->filters = 0xb4b4b4b4;\r\n\t} else if (fsize == 8998912) {\r\n\t\tp->height = 2118;\r\n\t\tp->width  = 2832;\r\n\t\tp->maximum = 0xf83;\r\n\t\tp->load_raw = &DCR_CLASS dcr_packed_12_load_raw;\r\n\t\tp->load_flags = 7;\r\n\t} else if (!strcmp(p->model,\"FinePix S5100\") ||\r\n\t\t!strcmp(p->model,\"FinePix S5500\")) {\r\n\t\tp->load_raw = &DCR_CLASS dcr_unpacked_load_raw;\r\n\t} else if (!strcmp(p->make,\"FUJIFILM\")) {\r\n\t\tif (!strcmp(p->model+7,\"S2Pro\")) {\r\n\t\t\tstrcpy (p->model+7,\" S2Pro\");\r\n\t\t\tp->height = 2144;\r\n\t\t\tp->width  = 2880;\r\n\t\t\tp->flip = 6;\r\n\t\t} else\r\n\t\t\tp->maximum = 0x3e00;\r\n\t\tif (p->is_raw == 2 && p->opt.shot_select)\r\n\t\t\tp->maximum = 0x2f00;\r\n\t\tp->top_margin = (p->raw_height - p->height)/2;\r\n\t\tp->left_margin = (p->raw_width - p->width )/2;\r\n\t\tif (p->is_raw == 2)\r\n\t\t\tp->data_offset += (p->opt.shot_select > 0) * ( p->fuji_layout ?\r\n\t\t\t(p->raw_width *= 2) : p->raw_height*p->raw_width*2 );\r\n\t\tp->fuji_width = p->width >> !p->fuji_layout;\r\n\t\tp->width = (p->height >> p->fuji_layout) + p->fuji_width;\r\n\t\tp->raw_height = p->height;\r\n\t\tp->height = p->width - 1;\r\n\t\tp->load_raw = &DCR_CLASS dcr_fuji_load_raw;\r\n\t\tif (!(p->fuji_width & 1)) p->filters = 0x49494949;\r\n\t} else if (!strcmp(p->model,\"RD175\")) {\r\n\t\tp->height = 986;\r\n\t\tp->width = 1534;\r\n\t\tp->data_offset = 513;\r\n\t\tp->filters = 0x61616161;\r\n\t\tp->load_raw = &DCR_CLASS dcr_minolta_rd175_load_raw;\r\n\t} else if (!strcmp(p->model,\"KD-400Z\")) {\r\n\t\tp->height = 1712;\r\n\t\tp->width  = 2312;\r\n\t\tp->raw_width = 2336;\r\n\t\tgoto konica_400z;\r\n\t} else if (!strcmp(p->model,\"KD-510Z\")) {\r\n\t\tgoto konica_510z;\r\n\t} else if (!strcasecmp(p->make,\"MINOLTA\")) {\r\n\t\tp->load_raw = &DCR_CLASS dcr_unpacked_load_raw;\r\n\t\tif (!strncmp(p->model,\"DiMAGE A\",8)) {\r\n\t\t\tif (!strcmp(p->model,\"DiMAGE A200\"))\r\n\t\t\t\tp->filters = 0x49494949;\r\n\t\t\tp->load_raw = &DCR_CLASS dcr_packed_12_load_raw;\r\n\t\t} else if (!strncmp(p->model,\"ALPHA\",5) ||\r\n\t\t\t!strncmp(p->model,\"DYNAX\",5) ||\r\n\t\t\t!strncmp(p->model,\"MAXXUM\",6)) {\r\n\t\t\tsprintf (p->model+20, \"DYNAX %-10s\", p->model+6+(p->model[0]=='M'));\r\n\t\t\tdcr_adobe_coeff (p, p->make, p->model+20);\r\n\t\t\tp->load_raw = &DCR_CLASS dcr_packed_12_load_raw;\r\n\t\t} else if (!strncmp(p->model,\"DiMAGE G\",8)) {\r\n\t\t\tif (p->model[8] == '4') {\r\n\t\t\t\tp->height = 1716;\r\n\t\t\t\tp->width  = 2304;\r\n\t\t\t} else if (p->model[8] == '5') {\r\nkonica_510z:\r\n\t\t\tp->height = 1956;\r\n\t\t\tp->width  = 2607;\r\n\t\t\tp->raw_width = 2624;\r\n\t\t\t} else if (p->model[8] == '6') {\r\n\t\t\t\tp->height = 2136;\r\n\t\t\t\tp->width  = 2848;\r\n\t\t\t}\r\n\t\t\tp->data_offset += 14;\r\n\t\t\tp->filters = 0x61616161;\r\nkonica_400z:\r\n\t\t\tp->load_raw = &DCR_CLASS dcr_unpacked_load_raw;\r\n\t\t\tp->maximum = 0x3df;\r\n\t\t\tp->order = 0x4d4d;\r\n\t\t}\r\n\t} else if (!strcmp(p->model,\"*ist DS\")) {\r\n\t\tp->height -= 2;\r\n\t} else if (!strcmp(p->model,\"K20D\")) {\r\n\t\tp->filters = 0x16161616;\r\n\t} else if (!strcmp(p->model,\"Optio S\")) {\r\n\t\tif (fsize == 3178560) {\r\n\t\t\tp->height = 1540;\r\n\t\t\tp->width  = 2064;\r\n\t\t\tp->load_raw = &DCR_CLASS dcr_eight_bit_load_raw;\r\n\t\t\tp->cam_mul[0] *= 4;\r\n\t\t\tp->cam_mul[2] *= 4;\r\n\t\t\tp->pre_mul[0] = 1.391f;\r\n\t\t\tp->pre_mul[2] = 1.188f;\r\n\t\t} else {\r\n\t\t\tp->height = 1544;\r\n\t\t\tp->width  = 2068;\r\n\t\t\tp->raw_width = 3136;\r\n\t\t\tp->load_raw = &DCR_CLASS dcr_packed_12_load_raw;\r\n\t\t\tp->maximum = 0xf7c;\r\n\t\t\tp->pre_mul[0] = 1.137f;\r\n\t\t\tp->pre_mul[2] = 1.453f;\r\n\t\t}\r\n\t} else if (fsize == 6114240) {\r\n\t\tp->height = 1737;\r\n\t\tp->width  = 2324;\r\n\t\tp->raw_width = 3520;\r\n\t\tp->load_raw = &DCR_CLASS dcr_packed_12_load_raw;\r\n\t\tp->maximum = 0xf7a;\r\n\t\tp->pre_mul[0] = 1.980f;\r\n\t\tp->pre_mul[2] = 1.570f;\r\n\t} else if (!strcmp(p->model,\"Optio 750Z\")) {\r\n\t\tp->height = 2302;\r\n\t\tp->width  = 3072;\r\n\t\tp->load_raw = &DCR_CLASS dcr_packed_12_load_raw;\r\n\t\tp->load_flags = 7;\r\n\t} else if (!strcmp(p->model,\"S85\")) {\r\n\t\tp->height = 2448;\r\n\t\tp->width  = 3264;\r\n\t\tp->raw_width = fsize/p->height/2;\r\n\t\tp->order = 0x4d4d;\r\n\t\tp->load_raw = &DCR_CLASS dcr_unpacked_load_raw;\r\n\t\tp->maximum = 0xffff;\r\n\t} else if (!strcmp(p->model,\"STV680 VGA\")) {\r\n\t\tp->height = 484;\r\n\t\tp->width  = 644;\r\n\t\tp->load_raw = &DCR_CLASS dcr_eight_bit_load_raw;\r\n\t\tp->flip = 2;\r\n\t\tp->filters = 0x16161616;\r\n\t\tp->black = 16;\r\n\t\tp->pre_mul[0] = 1.097f;\r\n\t\tp->pre_mul[2] = 1.128f;\r\n\t} else if (!strcmp(p->model,\"KAI-0340\")) {\r\n\t\tp->height = 477;\r\n\t\tp->width  = 640;\r\n\t\tp->order = 0x4949;\r\n\t\tp->data_offset = 3840;\r\n\t\tp->load_raw = &DCR_CLASS dcr_unpacked_load_raw;\r\n\t\tp->pre_mul[0] = 1.561f;\r\n\t\tp->pre_mul[2] = 2.454f;\r\n\t} else if (!strcmp(p->model,\"N95\")) {\r\n\t\tp->height = p->raw_height - (p->top_margin = 2);\r\n\t} else if (!strcmp(p->model,\"531C\")) {\r\n\t\tp->height = 1200;\r\n\t\tp->width  = 1600;\r\n\t\tp->load_raw = &DCR_CLASS dcr_unpacked_load_raw;\r\n\t\tp->filters = 0x49494949;\r\n\t\tp->pre_mul[1] = 1.218f;\r\n\t} else if (!strcmp(p->model,\"F-080C\")) {\r\n\t\tp->height = 768;\r\n\t\tp->width  = 1024;\r\n\t\tp->load_raw = &DCR_CLASS dcr_eight_bit_load_raw;\r\n\t} else if (!strcmp(p->model,\"F-145C\")) {\r\n\t\tp->height = 1040;\r\n\t\tp->width  = 1392;\r\n\t\tp->load_raw = &DCR_CLASS dcr_eight_bit_load_raw;\r\n\t} else if (!strcmp(p->model,\"F-201C\")) {\r\n\t\tp->height = 1200;\r\n\t\tp->width  = 1600;\r\n\t\tp->load_raw = &DCR_CLASS dcr_eight_bit_load_raw;\r\n\t} else if (!strcmp(p->model,\"F-510C\")) {\r\n\t\tp->height = 1958;\r\n\t\tp->width  = 2588;\r\n\t\tp->load_raw = fsize < 7500000 ?\r\n\t\t\t&DCR_CLASS dcr_eight_bit_load_raw : &DCR_CLASS dcr_unpacked_load_raw;\r\n\t\tp->maximum = 0xfff0;\r\n\t} else if (!strcmp(p->model,\"F-810C\")) {\r\n\t\tp->height = 2469;\r\n\t\tp->width  = 3272;\r\n\t\tp->load_raw = &DCR_CLASS dcr_unpacked_load_raw;\r\n\t\tp->maximum = 0xfff0;\r\n\t} else if (!strcmp(p->model,\"XCD-SX910CR\")) {\r\n\t\tp->height = 1024;\r\n\t\tp->width  = 1375;\r\n\t\tp->raw_width = 1376;\r\n\t\tp->filters = 0x49494949;\r\n\t\tp->maximum = 0x3ff;\r\n\t\tp->load_raw = fsize < 2000000 ?\r\n\t\t\t&DCR_CLASS dcr_eight_bit_load_raw : &DCR_CLASS dcr_unpacked_load_raw;\r\n\t} else if (!strcmp(p->model,\"2010\")) {\r\n\t\tp->height = 1207;\r\n\t\tp->width  = 1608;\r\n\t\tp->order = 0x4949;\r\n\t\tp->filters = 0x16161616;\r\n\t\tp->data_offset = 3212;\r\n\t\tp->maximum = 0x3ff;\r\n\t\tp->load_raw = &DCR_CLASS dcr_unpacked_load_raw;\r\n\t} else if (!strcmp(p->model,\"A782\")) {\r\n\t\tp->height = 3000;\r\n\t\tp->width  = 2208;\r\n\t\tp->filters = 0x61616161;\r\n\t\tp->load_raw = fsize < 10000000 ?\r\n\t\t\t&DCR_CLASS dcr_eight_bit_load_raw : &DCR_CLASS dcr_unpacked_load_raw;\r\n\t\tp->maximum = 0xffc0;\r\n\t} else if (!strcmp(p->model,\"3320AF\")) {\r\n\t\tp->height = 1536;\r\n\t\tp->raw_width = p->width = 2048;\r\n\t\tp->filters = 0x61616161;\r\n\t\tp->load_raw = &DCR_CLASS dcr_unpacked_load_raw;\r\n\t\tp->maximum = 0x3ff;\r\n\t\tp->pre_mul[0] = 1.717f;\r\n\t\tp->pre_mul[2] = 1.138f;\r\n\t\tdcr_fseek(p->obj_, 0x300000, SEEK_SET);\r\n\t\tif ((p->order = dcr_guess_byte_order(p, 0x10000)) == 0x4d4d) {\r\n\t\t\tp->height -= (p->top_margin = 16);\r\n\t\t\tp->width -= (p->left_margin = 28);\r\n\t\t\tp->maximum = 0xf5c0;\r\n\t\t\tstrcpy (p->make, \"ISG\");\r\n\t\t\tp->model[0] = 0;\r\n\t\t}\r\n\t} else if (!strcmp(p->make,\"Hasselblad\")) {\r\n\t\tif (p->load_raw == &DCR_CLASS dcr_lossless_jpeg_load_raw)\r\n\t\t\tp->load_raw = &DCR_CLASS dcr_hasselblad_load_raw;\r\n\t\tif (p->raw_width == 7262) {\r\n\t\t\tp->height = 5444;\r\n\t\t\tp->width  = 7248;\r\n\t\t\tp->top_margin  = 4;\r\n\t\t\tp->left_margin = 7;\r\n\t\t\tp->filters = 0x61616161;\r\n\t\t} else if (p->raw_width == 4090) {\r\n\t\t\tstrcpy (p->model, \"V96C\");\r\n\t\t\tp->height -= (p->top_margin = 6);\r\n\t\t\tp->width -= (p->left_margin = 3) + 7;\r\n\t\t\tp->filters = 0x61616161;\r\n\t\t}\r\n\t} else if (!strcmp(p->make,\"Sinar\")) {\r\n\t\tif (!memcmp(head,\"8BPS\",4)) {\r\n\t\t\tdcr_fseek(p->obj_, 14, SEEK_SET);\r\n\t\t\tp->height = dcr_get4(p);\r\n\t\t\tp->width  = dcr_get4(p);\r\n\t\t\tp->filters = 0x61616161;\r\n\t\t\tp->data_offset = 68;\r\n\t\t}\r\n\t\tif (!p->load_raw) p->load_raw = &DCR_CLASS dcr_unpacked_load_raw;\r\n\t\tp->maximum = 0x3fff;\r\n\t} else if (!strcmp(p->make,\"Leaf\")) {\r\n\t\tp->maximum = 0x3fff;\r\n\t\tdcr_fseek(p->obj_, p->data_offset, SEEK_SET);\r\n\t\tif (dcr_ljpeg_start (p, &jh, 1) && jh.bits == 15)\r\n\t\t\tp->maximum = 0x1fff;\r\n\t\tif (p->tiff_samples > 1) p->filters = 0;\r\n\t\tif (p->tiff_samples > 1 || p->tile_length < p->raw_height)\r\n\t\t\tp->load_raw = &DCR_CLASS dcr_leaf_hdr_load_raw;\r\n\t\tif ((p->width | p->height) == 2048) {\r\n\t\t\tif (p->tiff_samples == 1) {\r\n\t\t\t\tp->filters = 1;\r\n\t\t\t\tstrcpy (p->cdesc, \"RBTG\");\r\n\t\t\t\tstrcpy (p->model, \"CatchLight\");\r\n\t\t\t\tp->top_margin =  8; p->left_margin = 18; p->height = 2032; p->width = 2016;\r\n\t\t\t} else {\r\n\t\t\t\tstrcpy (p->model, \"DCB2\");\r\n\t\t\t\tp->top_margin = 10; p->left_margin = 16; p->height = 2028; p->width = 2022;\r\n\t\t\t}\r\n\t\t} else if (p->width+p->height == 3144+2060) {\r\n\t\t\tif (!p->model[0]) strcpy (p->model, \"Cantare\");\r\n\t\t\tif (p->width > p->height) {\r\n\t\t\t\tp->top_margin = 6; p->left_margin = 32; p->height = 2048;  p->width = 3072;\r\n\t\t\t\tp->filters = 0x61616161;\r\n\t\t\t} else {\r\n\t\t\t\tp->left_margin = 6;  p->top_margin = 32;  p->width = 2048; p->height = 3072;\r\n\t\t\t\tp->filters = 0x16161616;\r\n\t\t\t}\r\n\t\t\tif (!p->cam_mul[0] || p->model[0] == 'V') p->filters = 0;\r\n\t\t\telse p->is_raw = p->tiff_samples;\r\n\t\t} else if (p->width == 2116) {\r\n\t\t\tstrcpy (p->model, \"Valeo 6\");\r\n\t\t\tp->height -= 2 * (p->top_margin = 30);\r\n\t\t\tp->width -= 2 * (p->left_margin = 55);\r\n\t\t\tp->filters = 0x49494949;\r\n\t\t} else if (p->width == 3171) {\r\n\t\t\tstrcpy (p->model, \"Valeo 6\");\r\n\t\t\tp->height -= 2 * (p->top_margin = 24);\r\n\t\t\tp->width -= 2 * (p->left_margin = 24);\r\n\t\t\tp->filters = 0x16161616;\r\n\t\t}\r\n\t} else if (!strcmp(p->make,\"LEICA\") || !strcmp(p->make,\"Panasonic\")) {\r\n\t\tp->maximum = 0xfff0;\r\n        if ((fsize-p->data_offset) / max(1, p->width*8/7) == p->height)\r\n\t\t\tp->load_raw = &DCR_CLASS dcr_panasonic_load_raw;\r\n\t\tif (!p->load_raw) p->load_raw = &DCR_CLASS dcr_unpacked_load_raw;\r\n\t\tswitch (p->width) {\r\n\t\tcase 2568:\r\n\t\t\tdcr_adobe_coeff (p, \"Panasonic\",\"DMC-LC1\");  break;\r\n\t\tcase 3130:\r\n\t\t\tp->left_margin = -14;\r\n\t\tcase 3170:\r\n\t\t\tp->left_margin += 18;\r\n\t\t\tp->width = 3096;\r\n\t\t\tif (p->height > 2326) {\r\n\t\t\t\tp->height = 2326;\r\n\t\t\t\tp->top_margin = 13;\r\n\t\t\t\tp->filters = 0x49494949;\r\n\t\t\t}\r\n\t\t\tp->zero_is_bad = 1;\r\n\t\t\tdcr_adobe_coeff (p, \"Panasonic\",\"DMC-FZ8\");  break;\r\n\t\tcase 3213:\r\n\t\t\tp->width -= 27;\r\n\t\tcase 3177:\r\n\t\t\tp->width -= 10;\r\n\t\t\tp->filters = 0x49494949;\r\n\t\t\tp->zero_is_bad = 1;\r\n\t\t\tdcr_adobe_coeff (p, \"Panasonic\",\"DMC-L1\");  break;\r\n\t\tcase 3304:\r\n\t\t\tp->width -= 17;\r\n\t\t\tp->zero_is_bad = 1;\r\n\t\t\tdcr_adobe_coeff (p, \"Panasonic\",\"DMC-FZ30\");  break;\r\n\t\tcase 3330:\r\n\t\t\tp->width += 43;\r\n\t\t\tp->left_margin = -6;\r\n\t\t\tp->maximum = 0xf7f0;\r\n\t\tcase 3370:\r\n\t\t\tp->width -= 82;\r\n\t\t\tp->left_margin += 15;\r\n\t\t\tif (p->height > 2480)\r\n\t\t\t\tp->height = 2480 - (p->top_margin = 10);\r\n\t\t\tp->filters = 0x49494949;\r\n\t\t\tp->zero_is_bad = 1;\r\n\t\t\tdcr_adobe_coeff (p, \"Panasonic\",\"DMC-FZ18\");  break;\r\n\t\tcase 3690:\r\n\t\t\tp->height -= 2;\r\n\t\t\tp->left_margin = -14;\r\n\t\t\tp->maximum = 0xf7f0;\r\n\t\tcase 3770:\r\n\t\t\tp->width = 3672;\r\n\t\t\tif (--p->height == 2798 && (p->height = 2760))\r\n\t\t\t\tp->top_margin = 15;\r\n\t\t\telse p->filters = 0x49494949;\r\n\t\t\tp->left_margin += 17;\r\n\t\t\tp->zero_is_bad = 1;\r\n\t\t\tdcr_adobe_coeff (p, \"Panasonic\",\"DMC-FZ50\");  break;\r\n\t\tcase 3710:\r\n\t\t\tp->width = 3682;\r\n\t\t\tp->filters = 0x49494949;\r\n\t\t\tdcr_adobe_coeff (p, \"Panasonic\",\"DMC-L10\");  break;\r\n\t\tcase 3724:\r\n\t\t\tp->width -= 14;\r\n\t\tcase 3836:\r\n\t\t\tp->width -= 42;\r\nlx3:\tp->filters = 0x16161616;\r\n\t\tif (p->make[0] != 'P')\r\n\t\t\tdcr_adobe_coeff (p, \"Panasonic\",\"DMC-LX3\");\r\n\t\tbreak;\r\n\t\tcase 3880:\r\n\t\t\tp->width -= 22;\r\n\t\t\tp->left_margin = 6;\r\n\t\t\tp->zero_is_bad = 1;\r\n\t\t\tdcr_adobe_coeff (p, \"Panasonic\",\"DMC-LX1\");  break;\r\n\t\tcase 4060:\r\n\t\t\tp->width = 3982;\r\n\t\t\tif (p->height == 2250) goto lx3;\r\n\t\t\tp->width = 4018;\r\n\t\t\tp->filters = 0x49494949;\r\n\t\t\tp->zero_is_bad = 1;\r\n\t\t\tdcr_adobe_coeff (p, \"Panasonic\",\"DMC-G1\");  break;\r\n\t\tcase 4290:\r\n\t\t\tp->height += 38;\r\n\t\t\tp->left_margin = -14;\r\n\t\t\tp->filters = 0x49494949;\r\n\t\tcase 4330:\r\n\t\t\tp->width = 4248;\r\n\t\t\tif ((p->height -= 39) == 2400)\r\n\t\t\t\tp->top_margin = 15;\r\n\t\t\tp->left_margin += 17;\r\n\t\t\tdcr_adobe_coeff (p, \"Panasonic\",\"DMC-LX2\");  break;\r\n\t\tcase 4508:\r\n\t\t\tp->height -= 6;\r\n\t\t\tp->width = 4429;\r\n\t\t\tp->filters = 0x16161616;\r\n\t\t\tdcr_adobe_coeff (p, \"Panasonic\",\"DMC-FX150\");  break;\r\n\t\t}\r\n\t} else if (!strcmp(p->model,\"C770UZ\")) {\r\n\t\tp->height = 1718;\r\n\t\tp->width  = 2304;\r\n\t\tp->filters = 0x16161616;\r\n\t\tp->load_raw = &DCR_CLASS dcr_packed_12_load_raw;\r\n\t\tp->load_flags = 7;\r\n\t} else if (!strcmp(p->make,\"OLYMPUS\")) {\r\n\t\tp->height += p->height & 1;\r\n\t\tp->filters = p->exif_cfa;\r\n\t\tif (p->load_raw == &DCR_CLASS dcr_olympus_e410_load_raw) {\r\n\t\t\tp->black >>= 4;\r\n\t\t} else if (!strcmp(p->model,\"E-10\") ||\r\n\t\t\t!strncmp(p->model,\"E-20\",4)) {\r\n\t\t\tp->black <<= 2;\r\n\t\t} else if (!strcmp(p->model,\"E-300\") ||\r\n\t\t\t!strcmp(p->model,\"E-500\")) {\r\n\t\t\tp->width -= 20;\r\n\t\t\tif (p->load_raw == &DCR_CLASS dcr_unpacked_load_raw) {\r\n\t\t\t\tp->maximum = 0xfc30;\r\n\t\t\t\tp->black = 0;\r\n\t\t\t}\r\n\t\t} else if (!strcmp(p->model,\"E-330\")) {\r\n\t\t\tp->width -= 30;\r\n\t\t\tif (p->load_raw == &DCR_CLASS dcr_unpacked_load_raw)\r\n\t\t\t\tp->maximum = 0xf790;\r\n\t\t} else if (!strcmp(p->model,\"SP550UZ\")) {\r\n\t\t\tp->thumb_length = fsize - (p->thumb_offset = 0xa39800);\r\n\t\t\tp->thumb_height = 480;\r\n\t\t\tp->thumb_width  = 640;\r\n\t\t}\r\n\t} else if (!strcmp(p->model,\"N Digital\")) {\r\n\t\tp->height = 2047;\r\n\t\tp->width  = 3072;\r\n\t\tp->filters = 0x61616161;\r\n\t\tp->data_offset = 0x1a00;\r\n\t\tp->load_raw = &DCR_CLASS dcr_packed_12_load_raw;\r\n\t} else if (!strcmp(p->model,\"DSC-F828\")) {\r\n\t\tp->width = 3288;\r\n\t\tp->left_margin = 5;\r\n\t\tp->data_offset = 862144;\r\n\t\tp->load_raw = &DCR_CLASS dcr_sony_load_raw;\r\n\t\tp->filters = 0x9c9c9c9c;\r\n\t\tp->colors = 4;\r\n\t\tstrcpy (p->cdesc, \"RGBE\");\r\n\t} else if (!strcmp(p->model,\"DSC-V3\")) {\r\n\t\tp->width = 3109;\r\n\t\tp->left_margin = 59;\r\n\t\tp->data_offset = 787392;\r\n\t\tp->load_raw = &DCR_CLASS dcr_sony_load_raw;\r\n\t} else if (!strcmp(p->make,\"SONY\") && p->raw_width == 3984) {\r\n\t\tdcr_adobe_coeff (p, \"SONY\",\"DSC-R1\");\r\n\t\tp->width = 3925;\r\n\t\tp->order = 0x4d4d;\r\n\t} else if (!strcmp(p->model,\"DSLR-A100\")) {\r\n\t\tp->height--;\r\n\t} else if (!strcmp(p->model,\"DSLR-A350\")) {\r\n\t\tp->height -= 4;\r\n\t} else if (!strcmp(p->model,\"C603v\")) {\r\n\t\tp->height = 480;\r\n\t\tp->width  = 640;\r\n\t\tgoto c603v;\r\n\t} else if (!strcmp(p->model,\"C603y\")) {\r\n\t\tp->height = 2134;\r\n\t\tp->width  = 2848;\r\nc603v:\r\n\t\tp->filters = 0;\r\n\t\tp->load_raw = &DCR_CLASS dcr_kodak_yrgb_load_raw;\r\n\t} else if (!strcmp(p->model,\"C603\")) {\r\n\t\tp->raw_height = p->height = 2152;\r\n\t\tp->raw_width  = p->width  = 2864;\r\n\t\tgoto c603;\r\n\t} else if (!strcmp(p->model,\"C330\")) {\r\n\t\tp->height = 1744;\r\n\t\tp->width  = 2336;\r\n\t\tp->raw_height = 1779;\r\n\t\tp->raw_width  = 2338;\r\n\t\tp->top_margin = 33;\r\n\t\tp->left_margin = 1;\r\nc603:\r\n\t\tp->order = 0x4949;\r\n\t\tif ((p->data_offset = fsize - p->raw_height*p->raw_width)) {\r\n\t\t\tdcr_fseek(p->obj_, 168, SEEK_SET);\r\n\t\t\tdcr_read_shorts (p, p->curve, 256);\r\n\t\t} else p->use_gamma = 0;\r\n\t\tp->load_raw = &DCR_CLASS dcr_eight_bit_load_raw;\r\n\t} else if (!strcasecmp(p->make,\"KODAK\")) {\r\n\t\tif (p->filters == UINT_MAX) p->filters = 0x61616161;\r\n\t\tif (!strncmp(p->model,\"NC2000\",6)) {\r\n\t\t\tp->width -= 4;\r\n\t\t\tp->left_margin = 2;\r\n\t\t} else if (!strcmp(p->model,\"EOSDCS3B\")) {\r\n\t\t\tp->width -= 4;\r\n\t\t\tp->left_margin = 2;\r\n\t\t} else if (!strcmp(p->model,\"EOSDCS1\")) {\r\n\t\t\tp->width -= 4;\r\n\t\t\tp->left_margin = 2;\r\n\t\t} else if (!strcmp(p->model,\"DCS420\")) {\r\n\t\t\tp->width -= 4;\r\n\t\t\tp->left_margin = 2;\r\n\t\t} else if (!strcmp(p->model,\"DCS460\")) {\r\n\t\t\tp->width -= 4;\r\n\t\t\tp->left_margin = 2;\r\n\t\t} else if (!strcmp(p->model,\"DCS460A\")) {\r\n\t\t\tp->width -= 4;\r\n\t\t\tp->left_margin = 2;\r\n\t\t\tp->colors = 1;\r\n\t\t\tp->filters = 0;\r\n\t\t} else if (!strcmp(p->model,\"DCS660M\")) {\r\n\t\t\tp->black = 214;\r\n\t\t\tp->colors = 1;\r\n\t\t\tp->filters = 0;\r\n\t\t} else if (!strcmp(p->model,\"DCS760M\")) {\r\n\t\t\tp->colors = 1;\r\n\t\t\tp->filters = 0;\r\n\t\t}\r\n\t\tif (!strcmp(p->model+4,\"20X\"))\r\n\t\t\tstrcpy (p->cdesc, \"MYCY\");\r\n\t\tif (strstr(p->model,\"DC25\")) {\r\n\t\t\tstrcpy (p->model, \"DC25\");\r\n\t\t\tp->data_offset = 15424;\r\n\t\t}\r\n\t\tif (!strncmp(p->model,\"DC2\",3)) {\r\n\t\t\tp->height = 242;\r\n\t\t\tif (fsize < 100000) {\r\n\t\t\t\tp->raw_width = 256; p->width = 249;\r\n\t\t\t\tp->pixel_aspect = (4.0*p->height) / (3.0*p->width);\r\n\t\t\t} else {\r\n\t\t\t\tp->raw_width = 512; p->width = 501;\r\n\t\t\t\tp->pixel_aspect = (493.0*p->height) / (373.0*p->width);\r\n\t\t\t}\r\n\t\t\tp->data_offset += p->raw_width + 1;\r\n\t\t\tp->colors = 4;\r\n\t\t\tp->filters = 0x8d8d8d8d;\r\n\t\t\tdcr_simple_coeff(p, 1);\r\n\t\t\tp->pre_mul[1] = 1.179f;\r\n\t\t\tp->pre_mul[2] = 1.209f;\r\n\t\t\tp->pre_mul[3] = 1.036f;\r\n\t\t\tp->load_raw = &DCR_CLASS dcr_eight_bit_load_raw;\r\n\t\t} else if (!strcmp(p->model,\"40\")) {\r\n\t\t\tstrcpy (p->model, \"DC40\");\r\n\t\t\tp->height = 512;\r\n\t\t\tp->width  = 768;\r\n\t\t\tp->data_offset = 1152;\r\n\t\t\tp->load_raw = &DCR_CLASS dcr_kodak_radc_load_raw;\r\n\t\t} else if (strstr(p->model,\"DC50\")) {\r\n\t\t\tstrcpy (p->model, \"DC50\");\r\n\t\t\tp->height = 512;\r\n\t\t\tp->width  = 768;\r\n\t\t\tp->data_offset = 19712;\r\n\t\t\tp->load_raw = &DCR_CLASS dcr_kodak_radc_load_raw;\r\n\t\t} else if (strstr(p->model,\"DC120\")) {\r\n\t\t\tstrcpy (p->model, \"DC120\");\r\n\t\t\tp->height = 976;\r\n\t\t\tp->width  = 848;\r\n\t\t\tp->pixel_aspect = p->height/0.75/p->width;\r\n\t\t\tp->load_raw = p->tiff_compress == 7 ?\r\n\t\t\t\t&DCR_CLASS dcr_kodak_jpeg_load_raw : &DCR_CLASS dcr_kodak_dc120_load_raw;\r\n\t\t} else if (!strcmp(p->model,\"DCS200\")) {\r\n\t\t\tp->thumb_height = 128;\r\n\t\t\tp->thumb_width  = 192;\r\n\t\t\tp->thumb_offset = 6144;\r\n\t\t\tp->thumb_misc   = 360;\r\n\t\t\tp->write_thumb = &DCR_CLASS dcr_layer_thumb;\r\n\t\t\tp->height = 1024;\r\n\t\t\tp->width  = 1536;\r\n\t\t\tp->data_offset = 79872;\r\n\t\t\tp->load_raw = &DCR_CLASS dcr_eight_bit_load_raw;\r\n\t\t\tp->black = 17;\r\n\t\t}\r\n\t} else if (!strcmp(p->model,\"Fotoman Pixtura\")) {\r\n\t\tp->height = 512;\r\n\t\tp->width  = 768;\r\n\t\tp->data_offset = 3632;\r\n\t\tp->load_raw = &DCR_CLASS dcr_kodak_radc_load_raw;\r\n\t\tp->filters = 0x61616161;\r\n\t\tdcr_simple_coeff(p, 2);\r\n\t} else if (!strcmp(p->model,\"QuickTake 100\")) {\r\n\t\tdcr_fseek(p->obj_, 544, SEEK_SET);\r\n\t\tp->height = dcr_get2(p);\r\n\t\tp->width  = dcr_get2(p);\r\n\t\tp->data_offset = (dcr_get4(p),dcr_get2(p)) == 30 ? 738:736;\r\n\t\tif (p->height > p->width) {\r\n\t\t\tSWAP(p->height,p->width);\r\n\t\t\tdcr_fseek(p->obj_, p->data_offset-6, SEEK_SET);\r\n\t\t\tp->flip = ~dcr_get2(p) & 3 ? 5:6;\r\n\t\t}\r\n\t\tp->load_raw = &DCR_CLASS dcr_quicktake_100_load_raw;\r\n\t\tp->filters = 0x61616161;\r\n\t} else if (!strcmp(p->model,\"QuickTake 150\")) {\r\n\t\tp->data_offset = 738 - head[5];\r\n\t\tif (head[5]) strcpy (p->model+10, \"200\");\r\n\t\tp->load_raw = &DCR_CLASS dcr_kodak_radc_load_raw;\r\n\t\tp->height = 480;\r\n\t\tp->width  = 640;\r\n\t\tp->filters = 0x61616161;\r\n\t} else if (!strcmp(p->make,\"Rollei\") && !p->load_raw) {\r\n\t\tswitch (p->raw_width) {\r\n\t\tcase 1316:\r\n\t\t\tp->height = 1030;\r\n\t\t\tp->width  = 1300;\r\n\t\t\tp->top_margin  = 1;\r\n\t\t\tp->left_margin = 6;\r\n\t\t\tbreak;\r\n\t\tcase 2568:\r\n\t\t\tp->height = 1960;\r\n\t\t\tp->width  = 2560;\r\n\t\t\tp->top_margin  = 2;\r\n\t\t\tp->left_margin = 8;\r\n\t\t}\r\n\t\tp->filters = 0x16161616;\r\n\t\tp->load_raw = &DCR_CLASS dcr_rollei_load_raw;\r\n\t\tp->pre_mul[0] = 1.8f;\r\n\t\tp->pre_mul[2] = 1.3f;\r\n\t} else if (!strcmp(p->model,\"PC-CAM 600\")) {\r\n\t\tp->height = 768;\r\n\t\tp->data_offset = p->width = 1024;\r\n\t\tp->filters = 0x49494949;\r\n\t\tp->load_raw = &DCR_CLASS dcr_eight_bit_load_raw;\r\n\t\tp->pre_mul[0] = 1.14f;\r\n\t\tp->pre_mul[2] = 2.73f;\r\n\t} else if (!strcmp(p->model,\"QV-2000UX\")) {\r\n\t\tp->height = 1208;\r\n\t\tp->width  = 1632;\r\n\t\tp->data_offset = p->width * 2;\r\n\t\tp->load_raw = &DCR_CLASS dcr_eight_bit_load_raw;\r\n\t} else if (fsize == 3217760) {\r\n\t\tp->height = 1546;\r\n\t\tp->width  = 2070;\r\n\t\tp->raw_width = 2080;\r\n\t\tp->load_raw = &DCR_CLASS dcr_eight_bit_load_raw;\r\n\t} else if (!strcmp(p->model,\"QV-4000\")) {\r\n\t\tp->height = 1700;\r\n\t\tp->width  = 2260;\r\n\t\tp->load_raw = &DCR_CLASS dcr_unpacked_load_raw;\r\n\t\tp->maximum = 0xffff;\r\n\t} else if (!strcmp(p->model,\"QV-5700\")) {\r\n\t\tp->height = 1924;\r\n\t\tp->width  = 2576;\r\n\t\tp->load_raw = &DCR_CLASS dcr_casio_qv5700_load_raw;\r\n\t} else if (!strcmp(p->model,\"QV-R41\")) {\r\n\t\tp->height = 1720;\r\n\t\tp->width  = 2312;\r\n\t\tp->raw_width = 3520;\r\n\t\tp->left_margin = 2;\r\n\t} else if (!strcmp(p->model,\"QV-R51\")) {\r\n\t\tp->height = 1926;\r\n\t\tp->width  = 2580;\r\n\t\tp->raw_width = 3904;\r\n\t\tp->pre_mul[0] = 1.340f;\r\n\t\tp->pre_mul[2] = 1.672f;\r\n\t} else if (!strcmp(p->model,\"EX-S100\")) {\r\n\t\tp->height = 1544;\r\n\t\tp->width  = 2058;\r\n\t\tp->raw_width = 3136;\r\n\t\tp->pre_mul[0] = 1.631f;\r\n\t\tp->pre_mul[2] = 1.106f;\r\n\t} else if (!strcmp(p->model,\"EX-Z50\")) {\r\n\t\tp->height = 1931;\r\n\t\tp->width  = 2570;\r\n\t\tp->raw_width = 3904;\r\n\t\tp->pre_mul[0] = 2.529f;\r\n\t\tp->pre_mul[2] = 1.185f;\r\n\t} else if (!strcmp(p->model,\"EX-Z55\")) {\r\n\t\tp->height = 1960;\r\n\t\tp->width  = 2570;\r\n\t\tp->raw_width = 3904;\r\n\t\tp->pre_mul[0] = 1.520f;\r\n\t\tp->pre_mul[2] = 1.316f;\r\n\t} else if (!strcmp(p->model,\"EX-P505\")) {\r\n\t\tp->height = 1928;\r\n\t\tp->width  = 2568;\r\n\t\tp->raw_width = 3852;\r\n\t\tp->maximum = 0xfff;\r\n\t\tp->pre_mul[0] = 2.07f;\r\n\t\tp->pre_mul[2] = 1.88f;\r\n\t} else if (fsize == 9313536) {\t/* EX-P600 or QV-R61 */\r\n\t\tp->height = 2142;\r\n\t\tp->width  = 2844;\r\n\t\tp->raw_width = 4288;\r\n\t\tp->pre_mul[0] = 1.797f;\r\n\t\tp->pre_mul[2] = 1.219f;\r\n\t} else if (!strcmp(p->model,\"EX-P700\")) {\r\n\t\tp->height = 2318;\r\n\t\tp->width  = 3082;\r\n\t\tp->raw_width = 4672;\r\n\t\tp->pre_mul[0] = 1.758f;\r\n\t\tp->pre_mul[2] = 1.504f;\r\n\t}\r\n\tif (!p->model[0])\r\n\t\tsprintf (p->model, \"%dx%d\", p->width, p->height);\r\n\tif (p->filters == UINT_MAX) p->filters = 0x94949494;\r\n\tif (p->raw_color) dcr_adobe_coeff (p, p->make, p->model);\r\n\tif (p->thumb_offset && !p->thumb_height) {\r\n\t\tdcr_fseek(p->obj_, p->thumb_offset, SEEK_SET);\r\n\t\tif (dcr_ljpeg_start (p,&jh, 1)) {\r\n\t\t\tp->thumb_width  = jh.wide;\r\n\t\t\tp->thumb_height = jh.high;\r\n\t\t}\r\n\t}\r\ndng_skip:\r\n\tif (!p->load_raw || p->height < 22) p->is_raw = 0;\r\n#ifdef NO_JPEG\r\n\tif (p->load_raw == &DCR_CLASS dcr_kodak_jpeg_load_raw) {\r\n\t\tfprintf (stderr,_(\"%s: You must link dcraw with libjpeg!!\\n\"), p->ifname);\r\n\t\tp->is_raw = 0;\r\n\t}\r\n#endif\r\n\tif (!p->cdesc[0])\r\n\t\tstrcpy (p->cdesc, p->colors == 3 ? \"RGB\":\"GMCY\");\r\n\tif (!p->raw_height) p->raw_height = p->height;\r\n\tif (!p->raw_width ) p->raw_width  = p->width;\r\n\tif (p->filters && p->colors == 3)\r\n\t\tfor (i=0; i < 32; i+=4) {\r\n\t\t\tif ((p->filters >> i & 15) == 9)\r\n\t\t\t\tp->filters |= 2 << i;\r\n\t\t\tif ((p->filters >> i & 15) == 6)\r\n\t\t\t\tp->filters |= 8 << i;\r\n\t\t}\r\nnotraw:\r\n\t\tif (p->flip == -1) p->flip = p->tiff_flip;\r\n\t\tif (p->flip == -1) p->flip = 0;\r\n}\r\n\r\n#ifndef NO_LCMS\r\nvoid DCR_CLASS dcr_apply_profile (DCRAW* p, char *input, char *output)\r\n{\r\n\tchar *prof;\r\n\tcmsHPROFILE hInProfile=0, hOutProfile=0;\r\n\tcmsHTRANSFORM hTransform;\r\n\tFILE *fp;\r\n\tunsigned size;\r\n\r\n\tcmsErrorAction (LCMS_ERROR_SHOW);\r\n\tif (strcmp (input, \"embed\"))\r\n\t\thInProfile = cmsOpenProfileFromFile (input, \"r\");\r\n\telse if (p->profile_length) {\r\n\t\tprof = (char *) malloc (p->profile_length);\r\n\t\tdcr_merror (p, prof, \"apply_profile()\");\r\n\t\tdcr_fseek(p->obj_, p->profile_offset, SEEK_SET);\r\n\t\tdcr_fread(p->obj_, prof, 1, p->profile_length);\r\n\t\thInProfile = cmsOpenProfileFromMem (prof, p->profile_length);\r\n\t\tfree (prof);\r\n\t} else\r\n\t\tfprintf (stderr,_(\"%s has no embedded profile.\\n\"), p->ifname);\r\n\tif (!hInProfile) return;\r\n\tif (!output)\r\n\t\thOutProfile = cmsCreate_sRGBProfile();\r\n\telse if ((fp = fopen (output, \"rb\"))) {\r\n\t\tdcr_fread(p->obj_, &size, 4, 1);\r\n\t\tfseek (fp, 0, SEEK_SET);\r\n\t\tp->oprof = (unsigned *) malloc (size = ntohl(size));\r\n\t\tdcr_merror (p, p->oprof, \"apply_profile()\");\r\n\t\tdcr_fread(p->obj_, p->oprof, 1, size);\r\n\t\tfclose (fp);\r\n\t\tif (!(hOutProfile = cmsOpenProfileFromMem (p->oprof, size))) {\r\n\t\t\tfree (p->oprof);\r\n\t\t\tp->oprof = 0;\r\n\t\t}\r\n\t} else\r\n\t\tfprintf (stderr,_(\"Cannot open file %s!\\n\"), output);\r\n\tif (!hOutProfile) goto quit;\r\n\tif (p->opt.verbose)\r\n\t\tfprintf (stderr,_(\"Applying color profile...\\n\"));\r\n\thTransform = cmsCreateTransform (hInProfile, TYPE_RGBA_16,\r\n\t\thOutProfile, TYPE_RGBA_16, INTENT_PERCEPTUAL, 0);\r\n\tcmsDoTransform (hTransform, p->image, p->image, p->width*p->height);\r\n\tp->raw_color = 1;\t\t/* Don't use rgb_cam with a profile */\r\n\tcmsDeleteTransform (hTransform);\r\n\tcmsCloseProfile (hOutProfile);\r\nquit:\r\n\tcmsCloseProfile (hInProfile);\r\n}\r\n#endif\r\n\r\nvoid DCR_CLASS dcr_convert_to_rgb(DCRAW* p)\r\n{\r\n\tint row, col, c, i, j, k;\r\n\tushort *img;\r\n\tfloat out[3], out_cam[3][4];\r\n\tdouble num, inverse[3][3], bnd[2]={0,0};\r\n\tstatic const double xyzd50_srgb[3][3] =\r\n\t{ { 0.436083, 0.385083, 0.143055 },\r\n    { 0.222507, 0.716888, 0.060608 },\r\n    { 0.013930, 0.097097, 0.714022 } };\r\n\tstatic const double rgb_rgb[3][3] =\r\n\t{ { 1,0,0 }, { 0,1,0 }, { 0,0,1 } };\r\n\tstatic const double adobe_rgb[3][3] =\r\n\t{ { 0.715146, 0.284856, 0.000000 },\r\n    { 0.000000, 1.000000, 0.000000 },\r\n    { 0.000000, 0.041166, 0.958839 } };\r\n\tstatic const double wide_rgb[3][3] =\r\n\t{ { 0.593087, 0.404710, 0.002206 },\r\n    { 0.095413, 0.843149, 0.061439 },\r\n    { 0.011621, 0.069091, 0.919288 } };\r\n\tstatic const double prophoto_rgb[3][3] =\r\n\t{ { 0.529317, 0.330092, 0.140588 },\r\n    { 0.098368, 0.873465, 0.028169 },\r\n    { 0.016879, 0.117663, 0.865457 } };\r\n\r\n\tstatic const double (*out_rgb[])[3] =\r\n\t{ rgb_rgb, adobe_rgb, wide_rgb, prophoto_rgb, xyz_rgb };\r\n\tstatic const char *name[] =\r\n\t{ \"sRGB\", \"Adobe RGB (1998)\", \"WideGamut D65\", \"ProPhoto D65\", \"XYZ\" };\r\n\tstatic const unsigned phead[] =\r\n\t{ 1024, 0, 0x2100000, 0x6d6e7472, 0x52474220, 0x58595a20, 0, 0, 0,\r\n    0x61637370, 0, 0, 0x6e6f6e65, 0, 0, 0, 0, 0xf6d6, 0x10000, 0xd32d };\r\n\tunsigned pbody[] =\r\n\t{ 10, 0x63707274, 0, 36,\t/* cprt */\r\n\t0x64657363, 0, 40,\t/* desc */\r\n\t0x77747074, 0, 20,\t/* wtpt */\r\n\t0x626b7074, 0, 20,\t/* bkpt */\r\n\t0x72545243, 0, 14,\t/* rTRC */\r\n\t0x67545243, 0, 14,\t/* gTRC */\r\n\t0x62545243, 0, 14,\t/* bTRC */\r\n\t0x7258595a, 0, 20,\t/* rXYZ */\r\n\t0x6758595a, 0, 20,\t/* gXYZ */\r\n\t0x6258595a, 0, 20 };\t/* bXYZ */\r\n\tstatic const unsigned pwhite[] = { 0xf351, 0x10000, 0x116cc };\r\n\tunsigned pcurve[] = { 0x63757276, 0, 1, 0x1000000 };\r\n\r\n\tbnd[p->opt.gamm[1] >= 1] = 1;\r\n\tif (p->opt.gamm[1] && (p->opt.gamm[1]-1)*(p->opt.gamm[0]-1) <= 0) {\r\n\t\tfor (i=0; i < 36; i++) {\r\n\t\t\tp->opt.gamm[2] = (bnd[0] + bnd[1])/2;\r\n\t\t\tbnd[(pow(p->opt.gamm[2]/p->opt.gamm[1],-p->opt.gamm[0])-1)/p->opt.gamm[0]-1/p->opt.gamm[2] > -1] = p->opt.gamm[2];\r\n\t\t}\r\n\t\tp->opt.gamm[3] = p->opt.gamm[2]*(1/p->opt.gamm[0]-1);\r\n\t\tp->opt.gamm[2] /= p->opt.gamm[1];\r\n\t}\r\n\tp->opt.gamm[4] = 1 / (p->opt.gamm[1]/2*SQR(p->opt.gamm[2]) - p->opt.gamm[3]*(1-p->opt.gamm[2]) +\r\n\t\t(1-pow(p->opt.gamm[2],1+p->opt.gamm[0]))*(1+p->opt.gamm[3])/(1+p->opt.gamm[0])) - 1;\r\n\r\n\tmemcpy (out_cam, p->rgb_cam, sizeof out_cam);\r\n\tp->raw_color |= p->colors == 1 || p->opt.document_mode ||\r\n\t\tp->opt.output_color < 1 || p->opt.output_color > 5;\r\n\tif (!p->raw_color) {\r\n\t\tp->oprof = (unsigned *) calloc (phead[0], 1);\r\n\t\tdcr_merror (p, p->oprof, \"convert_to_rgb()\");\r\n\t\tmemcpy (p->oprof, phead, sizeof phead);\r\n\t\tif (p->opt.output_color == 5) p->oprof[4] = p->oprof[5];\r\n\t\tp->oprof[0] = 132 + 12*pbody[0];\r\n\t\tfor (i=0; i < (int)pbody[0]; i++) {\r\n\t\t\tp->oprof[p->oprof[0]/4] = i ? (i > 1 ? 0x58595a20 : 0x64657363) : 0x74657874;\r\n\t\t\tpbody[i*3+2] = p->oprof[0];\r\n\t\t\tp->oprof[0] += (pbody[i*3+3] + 3) & -4;\r\n\t\t}\r\n\t\tmemcpy (p->oprof+32, pbody, sizeof pbody);\r\n\t\tp->oprof[pbody[5]/4+2] = strlen(name[p->opt.output_color-1]) + 1;\r\n\t\tmemcpy ((char *)p->oprof+pbody[8]+8, pwhite, sizeof pwhite);\r\n\t\tif (p->opt.output_bps == 8)\r\n\t\t\tpcurve[3] = (short)(256/p->opt.gamm[4]+0.5) << 16;\r\n\t\tfor (i=4; i < 7; i++)\r\n\t\t\tmemcpy ((char *)p->oprof+pbody[i*3+2], pcurve, sizeof pcurve);\r\n\t\tdcr_pseudoinverse ((double (*)[3]) out_rgb[p->opt.output_color-1], inverse, 3);\r\n\t\tfor (i=0; i < 3; i++)\r\n\t\t\tfor (j=0; j < 3; j++) {\r\n\t\t\t\tfor (num = k=0; k < 3; k++)\r\n\t\t\t\t\tnum += xyzd50_srgb[i][k] * inverse[j][k];\r\n\t\t\t\tp->oprof[pbody[j*3+23]/4+i+2] = (unsigned int)(num * 0x10000 + 0.5);\r\n\t\t\t}\r\n\t\t\tfor (i=0; i < (int)(phead[0]/4); i++)\r\n\t\t\t\tp->oprof[i] = htonl(p->oprof[i]);\r\n\t\t\tstrcpy ((char *)p->oprof+pbody[2]+8, \"auto-generated by dcraw\");\r\n\t\t\tstrcpy ((char *)p->oprof+pbody[5]+12, name[p->opt.output_color-1]);\r\n\t\t\tfor (i=0; i < 3; i++)\r\n\t\t\t\tfor (j=0; j < p->colors; j++)\r\n                    for (out_cam[i][j] = 0, k=0; k < 3; k++)\r\n\t\t\t\t\t\tout_cam[i][j] += (float)out_rgb[p->opt.output_color-1][i][k] * p->rgb_cam[k][j];\r\n\t}\r\n\tif (p->opt.verbose)\r\n\t\tfprintf (stderr, p->raw_color ? _(\"Building histograms...\\n\") :\r\n\t_(\"Converting to %s colorspace...\\n\"), name[p->opt.output_color-1]);\r\n\r\n\tmemset (p->histogram, 0, sizeof p->histogram);\r\n\tfor (img=p->image[0], row=0; row < p->height; row++)\r\n\t\tfor (col=0; col < p->width; col++, img+=4) {\r\n\t\t\tif (!p->raw_color) {\r\n\t\t\t\tout[0] = out[1] = out[2] = 0;\r\n\t\t\t\tFORCC(p) {\r\n\t\t\t\t\tout[0] += out_cam[0][c] * img[c];\r\n\t\t\t\t\tout[1] += out_cam[1][c] * img[c];\r\n\t\t\t\t\tout[2] += out_cam[2][c] * img[c];\r\n\t\t\t\t}\r\n\t\t\t\tFORC3 img[c] = CLIP((int) out[c]);\r\n\t\t\t}\r\n\t\t\telse if (p->opt.document_mode)\r\n\t\t\t\timg[0] = img[FC(row,col)];\r\n\t\t\tFORCC(p) p->histogram[c][img[c] >> 3]++;\r\n\t\t}\r\n\tif (p->colors == 4 && p->opt.output_color) p->colors = 3;\r\n\tif (p->opt.document_mode && p->filters) p->colors = 1;\r\n}\r\n\r\nvoid DCR_CLASS dcr_fuji_rotate(DCRAW* p)\r\n{\r\n\tint i, row, col;\r\n\tdouble step;\r\n\tfloat r, c, fr, fc;\r\n\tunsigned ur, uc;\r\n\tushort wide, high, (*img)[4], (*pix)[4];\r\n\r\n\tif (!p->fuji_width) return;\r\n\tif (p->opt.verbose)\r\n\t\tfprintf (stderr,_(\"Rotating image 45 degrees...\\n\"));\r\n\tp->fuji_width = (p->fuji_width - 1 + p->shrink) >> p->shrink;\r\n\tstep = sqrt(0.5);\r\n\twide = (unsigned short)(p->fuji_width / step);\r\n\thigh = (unsigned short)((p->height - p->fuji_width) / step);\r\n\timg = (ushort (*)[4]) calloc (wide*high, sizeof *img);\r\n\tdcr_merror (p, img, \"fuji_rotate()\");\r\n\r\n\tfor (row=0; row < high; row++)\r\n\t\tfor (col=0; col < wide; col++) {\r\n\t\t\tr = (float)(p->fuji_width + (row-col)*step);\r\n\t\t\tur = (unsigned int)r;\r\n\t\t\tc = (float)((row+col)*step);\r\n\t\t\tuc = (unsigned int)c;\r\n\t\t\tif ((int)ur > (int)(p->height-2) || (int)uc > (int)(p->width-2)) continue;\r\n\t\t\tfr = r - ur;\r\n\t\t\tfc = c - uc;\r\n\t\t\tpix = p->image + ur*p->width + uc;\r\n\t\t\tfor (i=0; i < p->colors; i++)\r\n\t\t\t\timg[row*wide+col][i] = (unsigned short)(\r\n\t\t\t\t(pix[    0][i]*(1-fc) + pix[      1][i]*fc) * (1-fr) +\r\n\t\t\t\t(pix[p->width][i]*(1-fc) + pix[p->width+1][i]*fc) * fr);\r\n\t\t}\r\n\tfree (p->image);\r\n\tp->width  = wide;\r\n\tp->height = high;\r\n\tp->image  = img;\r\n\tp->fuji_width = 0;\r\n}\r\n\r\nvoid DCR_CLASS dcr_stretch(DCRAW* p)\r\n{\r\n\tushort newdim, (*img)[4], *pix0, *pix1;\r\n\tint row, col, c;\r\n\tdouble rc, frac;\r\n\r\n\tif (p->pixel_aspect == 1) return;\r\n\tif (p->opt.verbose) fprintf (stderr,_(\"Stretching the image...\\n\"));\r\n\tif (p->pixel_aspect < 1) {\r\n\t\tnewdim = (unsigned short)(p->height / p->pixel_aspect + 0.5);\r\n\t\timg = (ushort (*)[4]) calloc (p->width*newdim, sizeof *img);\r\n\t\tdcr_merror (p, img, \"stretch()\");\r\n\t\tfor (rc=row=0; row < newdim; row++, rc+=p->pixel_aspect) {\r\n\t\t\tfrac = rc - (c = (int)rc);\r\n\t\t\tpix0 = pix1 = p->image[c*p->width];\r\n\t\t\tif (c+1 < p->height) pix1 += p->width*4;\r\n\t\t\tfor (col=0; col < p->width; col++, pix0+=4, pix1+=4)\r\n\t\t\t\tFORCC(p) img[row*p->width+col][c] = (unsigned short)(pix0[c]*(1-frac) + pix1[c]*frac + 0.5);\r\n\t\t}\r\n\t\tp->height = newdim;\r\n\t} else {\r\n\t\tnewdim = (unsigned short)(p->width * p->pixel_aspect + 0.5);\r\n\t\timg = (ushort (*)[4]) calloc (p->height*newdim, sizeof *img);\r\n\t\tdcr_merror (p, img, \"stretch()\");\r\n\t\tfor (rc=col=0; col < newdim; col++, rc+=1/p->pixel_aspect) {\r\n\t\t\tfrac = rc - (c = (int)rc);\r\n\t\t\tpix0 = pix1 = p->image[c];\r\n\t\t\tif (c+1 < p->width) pix1 += 4;\r\n\t\t\tfor (row=0; row < p->height; row++, pix0+=p->width*4, pix1+=p->width*4)\r\n\t\t\t\tFORCC(p) img[row*newdim+col][c] = (unsigned short)(pix0[c]*(1-frac) + pix1[c]*frac + 0.5);\r\n\t\t}\r\n\t\tp->width = newdim;\r\n\t}\r\n\tfree (p->image);\r\n\tp->image = img;\r\n}\r\n\r\nint DCR_CLASS dcr_flip_index (DCRAW* p, int row, int col)\r\n{\r\n\tif (p->flip & 4) SWAP(row,col);\r\n\tif (p->flip & 2) row = p->iheight - 1 - row;\r\n\tif (p->flip & 1) col = p->iwidth  - 1 - col;\r\n\treturn row * p->iwidth + col;\r\n}\r\n\r\nvoid DCR_CLASS dcr_gamma_lut (DCRAW* p, uchar lut[0x10000])\r\n{\r\n\tint perc, c, val, total, i;\r\n\tfloat white=0, r;\r\n\r\n\tperc = (int)(p->width * p->height * 0.01);\t\t/* 99th percentile white level */\r\n\tif (p->fuji_width) perc /= 2;\r\n\tif ((p->opt.highlight & ~2) || p->opt.no_auto_bright) perc = -1;\r\n\tFORCC(p) {\r\n\t\tfor (val=0x2000, total=0; --val > 32; )\r\n\t\t\tif ((total += p->histogram[c][val]) > perc) break;\r\n\t\t\tif (white < val) white = (float)val;\r\n\t}\r\n\twhite *= 8 / p->opt.bright;\r\n\tfor (i=0; i < 0x10000; i++) {\r\n\t\tr = i / white;\r\n\t\tval = (int)(256 * ( !p->use_gamma ? r :\r\n\t\tr <= p->opt.gamm[2] ? r*p->opt.gamm[1] : pow(r,p->opt.gamm[0])*(1+p->opt.gamm[3])-p->opt.gamm[3]));\r\n\t\tif (val > 255) val = 255;\r\n\t\tlut[i] = val;\r\n\t}\r\n}\r\n\r\nvoid DCR_CLASS dcr_tiff_set (ushort *ntag,\r\n\t\t\t\t\t\t\t ushort tag, ushort type, int count, int val)\r\n{\r\n\tstruct dcr_tiff_tag *tt;\r\n\tint c;\r\n\r\n\ttt = (struct dcr_tiff_tag *)(ntag+1) + (*ntag)++;\r\n\ttt->tag = tag;\r\n\ttt->type = type;\r\n\ttt->count = count;\r\n\tif (type < 3 && count <= 4)\r\n\t\tFORC(4) tt->val.c[c] = val >> (c << 3);\r\n\telse if (type == 3 && count <= 2)\r\n\t\tFORC(2) tt->val.s[c] = val >> (c << 4);\r\n\telse tt->val.i = val;\r\n}\r\n\r\n#define TOFF(ptr) ((char *)(&(ptr)) - (char *)th)\r\n\r\nvoid DCR_CLASS dcr_tiff_head (DCRAW* p, struct dcr_tiff_hdr *th, int full)\r\n{\r\n\tint c, psize=0;\r\n\tstruct tm *t;\r\n\r\n\tmemset (th, 0, sizeof *th);\r\n\tth->order = (unsigned short)(htonl(0x4d4d4949) >> 16);\r\n\tth->magic = 42;\r\n\tth->ifd = 10;\r\n\tif (full) {\r\n\t\tdcr_tiff_set (&th->ntag, 254, 4, 1, 0);\r\n\t\tdcr_tiff_set (&th->ntag, 256, 4, 1, p->width);\r\n\t\tdcr_tiff_set (&th->ntag, 257, 4, 1, p->height);\r\n\t\tdcr_tiff_set (&th->ntag, 258, 3, p->colors, p->opt.output_bps);\r\n\t\tif (p->colors > 2)\r\n\t\t\tth->tag[th->ntag-1].val.i = TOFF(th->bps);\r\n\t\tFORC4 th->bps[c] = p->opt.output_bps;\r\n\t\tdcr_tiff_set (&th->ntag, 259, 3, 1, 1);\r\n\t\tdcr_tiff_set (&th->ntag, 262, 3, 1, 1 + (p->colors > 1));\r\n\t}\r\n\tdcr_tiff_set (&th->ntag, 270, 2, 512, TOFF(th->desc));\r\n\tdcr_tiff_set (&th->ntag, 271, 2, 64, TOFF(th->make));\r\n\tdcr_tiff_set (&th->ntag, 272, 2, 64, TOFF(th->model));\r\n\tif (full) {\r\n\t\tif (p->oprof) psize = ntohl(p->oprof[0]);\r\n\t\tdcr_tiff_set (&th->ntag, 273, 4, 1, sizeof *th + psize);\r\n\t\tdcr_tiff_set (&th->ntag, 277, 3, 1, p->colors);\r\n\t\tdcr_tiff_set (&th->ntag, 278, 4, 1, p->height);\r\n\t\tdcr_tiff_set (&th->ntag, 279, 4, 1, p->height*p->width*p->colors*p->opt.output_bps/8);\r\n\t} else\r\n\t\tdcr_tiff_set (&th->ntag, 274, 3, 1, \"12435867\"[p->flip]-'0');\r\n\tdcr_tiff_set (&th->ntag, 282, 5, 1, TOFF(th->rat[0]));\r\n\tdcr_tiff_set (&th->ntag, 283, 5, 1, TOFF(th->rat[2]));\r\n\tdcr_tiff_set (&th->ntag, 284, 3, 1, 1);\r\n\tdcr_tiff_set (&th->ntag, 296, 3, 1, 2);\r\n\tdcr_tiff_set (&th->ntag, 305, 2, 32, TOFF(th->soft));\r\n\tdcr_tiff_set (&th->ntag, 306, 2, 20, TOFF(th->date));\r\n\tdcr_tiff_set (&th->ntag, 315, 2, 64, TOFF(th->artist));\r\n\tdcr_tiff_set (&th->ntag, 34665, 4, 1, TOFF(th->nexif));\r\n\tif (psize) dcr_tiff_set (&th->ntag, 34675, 7, psize, sizeof *th);\r\n\tdcr_tiff_set (&th->nexif, 33434, 5, 1, TOFF(th->rat[4]));\r\n\tdcr_tiff_set (&th->nexif, 33437, 5, 1, TOFF(th->rat[6]));\r\n\tdcr_tiff_set (&th->nexif, 34855, 3, 1, (int)p->iso_speed);\r\n\tdcr_tiff_set (&th->nexif, 37386, 5, 1, TOFF(th->rat[8]));\r\n\tif (p->gpsdata[1]) {\r\n\t\tdcr_tiff_set (&th->ntag, 34853, 4, 1, TOFF(th->ngps));\r\n\t\tdcr_tiff_set (&th->ngps,  0, 1,  4, 0x202);\r\n\t\tdcr_tiff_set (&th->ngps,  1, 2,  2, p->gpsdata[29]);\r\n\t\tdcr_tiff_set (&th->ngps,  2, 5,  3, TOFF(th->gps[0]));\r\n\t\tdcr_tiff_set (&th->ngps,  3, 2,  2, p->gpsdata[30]);\r\n\t\tdcr_tiff_set (&th->ngps,  4, 5,  3, TOFF(th->gps[6]));\r\n\t\tdcr_tiff_set (&th->ngps,  5, 1,  1, p->gpsdata[31]);\r\n\t\tdcr_tiff_set (&th->ngps,  6, 5,  1, TOFF(th->gps[18]));\r\n\t\tdcr_tiff_set (&th->ngps,  7, 5,  3, TOFF(th->gps[12]));\r\n\t\tdcr_tiff_set (&th->ngps, 18, 2, 12, TOFF(th->gps[20]));\r\n\t\tdcr_tiff_set (&th->ngps, 29, 2, 12, TOFF(th->gps[23]));\r\n\t\tmemcpy (th->gps, p->gpsdata, sizeof th->gps);\r\n\t}\r\n\tth->rat[0] = th->rat[2] = 300;\r\n\tth->rat[1] = th->rat[3] = 1;\r\n\tFORC(6) th->rat[4+c] = 1000000;\r\n\tth->rat[4] = (int)(th->rat[4] * p->shutter);\r\n\tth->rat[6] = (int)(th->rat[6] * p->aperture);\r\n\tth->rat[8] = (int)(th->rat[8] * p->focal_len);\r\n\tstrncpy (th->desc, p->desc, 512);\r\n\tstrncpy (th->make, p->make, 64);\r\n\tstrncpy (th->model, p->model, 64);\r\n\tstrcpy (th->soft, \"dcraw v\"DCR_VERSION);\r\n\tt = gmtime (&p->timestamp);\r\n\tsprintf (th->date, \"%04d:%02d:%02d %02d:%02d:%02d\",\r\n\t\tt->tm_year+1900,t->tm_mon+1,t->tm_mday,t->tm_hour,t->tm_min,t->tm_sec);\r\n\tstrncpy (th->artist, p->artist, 64);\r\n}\r\n\r\nvoid DCR_CLASS dcr_jpeg_thumb (DCRAW* p, FILE *tfp)\r\n{\r\n\tchar *thumb;\r\n\tushort exif[5];\r\n\tstruct dcr_tiff_hdr th;\r\n\r\n\tthumb = (char *) malloc (p->thumb_length);\r\n\tdcr_merror (p, thumb, \"jpeg_thumb()\");\r\n\tdcr_fread(p->obj_, thumb, 1, p->thumb_length);\r\n\tfputc (0xff, tfp);\r\n\tfputc (0xd8, tfp);\r\n\tif (strcmp (thumb+6, \"Exif\")) {\r\n\t\tmemcpy (exif, \"\\xff\\xe1  Exif\\0\\0\", 10);\r\n\t\texif[1] = htons (8 + sizeof th);\r\n\t\tfwrite (exif, 1, sizeof exif, tfp);\r\n\t\tdcr_tiff_head (p,&th, 0);\r\n\t\tfwrite (&th, 1, sizeof th, tfp);\r\n\t}\r\n\tfwrite (thumb+2, 1, p->thumb_length-2, tfp);\r\n\tfree (thumb);\r\n}\r\n\r\nvoid DCR_CLASS dcr_write_ppm_tiff (DCRAW* p, FILE *ofp)\r\n{\r\n\tstruct dcr_tiff_hdr th;\r\n\tuchar *ppm, lut[0x10000];\r\n\tushort *ppm2;\r\n\tint c, row, col, soff, rstep, cstep;\r\n\r\n\tp->iheight = p->height;\r\n\tp->iwidth  = p->width;\r\n\tif (p->flip & 4) SWAP(p->height,p->width);\r\n\tppm = (uchar *) calloc (p->width, p->colors*p->opt.output_bps/8);\r\n\tppm2 = (ushort *) ppm;\r\n\tdcr_merror (p, ppm, \"write_ppm_tiff()\");\r\n\tif (p->opt.output_tiff) {\r\n\t\tdcr_tiff_head (p, &th, 1);\r\n\t\tfwrite (&th, sizeof th, 1, ofp);\r\n\t\tif (p->oprof)\r\n\t\t\tfwrite (p->oprof, ntohl(p->oprof[0]), 1, ofp);\r\n\t} else if (p->colors > 3)\r\n\t\tfprintf (ofp,\r\n\t\t\"P7\\nWIDTH %d\\nHEIGHT %d\\nDEPTH %d\\nMAXVAL %d\\nTUPLTYPE %s\\nENDHDR\\n\",\r\n\t\tp->width, p->height, p->colors, (1 << p->opt.output_bps)-1, p->cdesc);\r\n\telse\r\n\t\tfprintf (ofp, \"P%d\\n%d %d\\n%d\\n\",\r\n\t\tp->colors/2+5, p->width, p->height, (1 << p->opt.output_bps)-1);\r\n\r\n\tif (p->opt.output_bps == 8) dcr_gamma_lut (p, lut);\r\n\tsoff  = dcr_flip_index (p, 0, 0);\r\n\tcstep = dcr_flip_index (p, 0, 1) - soff;\r\n\trstep = dcr_flip_index (p, 1, 0) - dcr_flip_index (p, 0, p->width);\r\n\tfor (row=0; row < p->height; row++, soff += rstep) {\r\n\t\tfor (col=0; col < p->width; col++, soff += cstep){\r\n\t\t\tif (p->opt.output_bps == 8)\r\n\t\t\t\tFORCC(p) ppm [col*p->colors+c] = lut[p->image[soff][c]];\r\n\t\t\telse\r\n\t\t\t\tFORCC(p) ppm2[col*p->colors+c] =     p->image[soff][c];\r\n\t\t}\r\n\t\tif (p->opt.output_bps == 16 && !p->opt.output_tiff && htons(0x55aa) != 0x55aa)\r\n\t\t\t_swab ((char*)ppm2, (char*)ppm2, p->width*p->colors*2);\r\n\t\tfwrite (ppm, p->colors*p->opt.output_bps/8, p->width, ofp);\r\n\t}\r\n\tfree (ppm);\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////////\r\n\r\n\r\n\r\n\r\nstatic int dcr_sfile_read(dcr_stream_obj *obj, void *buf, int size, int cnt)\r\n{\r\n\treturn fread(buf, size, cnt, (FILE *)obj);\r\n}\r\n\r\nstatic int dcr_sfile_write(dcr_stream_obj *obj, void *buf, int size, int cnt)\r\n{\r\n\treturn fwrite(buf, size, cnt, (FILE *)obj);\r\n}\r\n\r\nstatic long dcr_sfile_seek(dcr_stream_obj *obj, long offset, int origin)\r\n{\r\n\treturn fseek((FILE *)obj, offset, origin);\r\n}\r\n\r\nstatic int dcr_sfile_close(dcr_stream_obj *obj)\r\n{\r\n\treturn fclose((FILE *)obj);\r\n}\r\n\r\nstatic char* dcr_sfile_gets(dcr_stream_obj *obj, char *string, int n)\r\n{\r\n\treturn fgets(string,n,(FILE *)obj);\r\n}\r\n\r\nstatic int   dcr_sfile_eof(dcr_stream_obj *obj)\r\n{\r\n\treturn feof((FILE *)obj);\r\n}\r\n\r\nstatic long  dcr_sfile_tell(dcr_stream_obj *obj)\r\n{\r\n\treturn ftell((FILE *)obj);\r\n}\r\n\r\nstatic int   dcr_sfile_getc(dcr_stream_obj *obj)\r\n{\r\n\treturn fgetc((FILE *)obj);\r\n}\r\n\r\nstatic int   dcr_sfile_scanf(dcr_stream_obj *obj,const char *format, void* output)\r\n{\r\n\treturn fscanf((FILE *)obj, format, output);\r\n}\r\n\r\n\r\n///////////////////////////////////////////////////////////////////////////////\r\n\r\n\r\nvoid DCR_CLASS dcr_init_dcraw(DCRAW* p)\r\n{\r\n\tmemset(p,0,sizeof(DCRAW));\r\n\r\n\tp->ops_ = &dcr_stream_fileops;\r\n\r\n\tp->opt.dark_frame = NULL;\r\n\tp->opt.bpfile     = NULL;\r\n\tp->opt.user_flip  = -1;\r\n\tp->opt.user_black = -1;\r\n\tp->opt.user_qual  = -1;\r\n\tp->opt.user_sat   = -1;\r\n\tp->opt.timestamp_only = 0;\r\n\tp->opt.thumbnail_only = 0;\r\n\tp->opt.identify_only  = 0;\r\n\tp->opt.use_fuji_rotate = 1;\r\n\tp->opt.write_to_stdout = 0;\r\n\tp->opt.bright = 1;\r\n\tp->opt.aber[0] = p->opt.aber[1] = p->opt.aber[2] = p->opt.aber[3] = 1;\r\n\tp->opt.gamm[0] = 0.45;\r\n\tp->opt.gamm[1] = 4.5;\r\n\tp->opt.gamm[2] = p->opt.gamm[3] = p->opt.gamm[4] = 0;\r\n\tp->opt.output_color = 1;\r\n\tp->opt.output_bps =8;\r\n\tp->opt.greybox[0] = p->opt.greybox[1] = 0;\r\n\tp->opt.greybox[2] = p->opt.greybox[3] = UINT_MAX;\r\n\tp->opt.use_camera_matrix = -1;\r\n\r\n}\r\n\r\nvoid\tDCR_CLASS dcr_cleanup_dcraw(DCRAW* p)\r\n{\r\n\tif (p->meta_data) free (p->meta_data);\r\n\tif (p->oprof) free (p->oprof);\r\n\tif (p->image) free (p->image);\r\n}\r\n\r\nvoid DCR_CLASS dcr_print_manual(int argc, char **argv)\r\n{\r\n\tprintf(_(\"\\nRaw photo decoder \\\"dcraw\\\" v%s\"), DCR_VERSION);\r\n    printf(_(\"\\nby Dave Coffin, dcoffin a cybercom o net\\n\"));\r\n    printf(_(\"\\nUsage:  %s [OPTION]... [FILE]...\\n\\n\"), argv[0]);\r\n    puts(_(\"-v        Print verbose messages\"));\r\n    puts(_(\"-c        Write image data to standard output\"));\r\n    puts(_(\"-e        Extract embedded thumbnail image\"));\r\n    puts(_(\"-i        Identify files without decoding them\"));\r\n    puts(_(\"-i -v     Identify files and show metadata\"));\r\n    puts(_(\"-z        Change file dates to camera timestamp\"));\r\n    puts(_(\"-w        Use camera white balance, if possible\"));\r\n    puts(_(\"-a        Average the whole image for white balance\"));\r\n    puts(_(\"-A <x y w h> Average a grey box for white balance\"));\r\n    puts(_(\"-r <r g b g> Set custom white balance\"));\r\n    puts(_(\"+M/-M     Use/don't use an embedded color matrix\"));\r\n    puts(_(\"-C <r b>  Correct chromatic aberration\"));\r\n    puts(_(\"-P <file> Fix the dead pixels listed in this file\"));\r\n    puts(_(\"-K <file> Subtract dark frame (16-bit raw PGM)\"));\r\n    puts(_(\"-k <num>  Set the darkness level\"));\r\n    puts(_(\"-S <num>  Set the saturation level\"));\r\n    puts(_(\"-n <num>  Set threshold for wavelet denoising\"));\r\n    puts(_(\"-H [0-9]  Highlight mode (0=clip, 1=unclip, 2=blend, 3+=rebuild)\"));\r\n    puts(_(\"-t [0-7]  Flip image (0=none, 3=180, 5=90CCW, 6=90CW)\"));\r\n    puts(_(\"-o [0-5]  Output colorspace (raw,sRGB,Adobe,Wide,ProPhoto,XYZ)\"));\r\n#ifndef NO_LCMS\r\n    puts(_(\"-o <file> Apply output ICC profile from file\"));\r\n    puts(_(\"-p <file> Apply camera ICC profile from file or \\\"embed\\\"\"));\r\n#endif\r\n    puts(_(\"-d        Document mode (no color, no interpolation)\"));\r\n    puts(_(\"-D        Document mode without scaling (totally raw)\"));\r\n    puts(_(\"-j        Don't stretch or rotate raw pixels\"));\r\n    puts(_(\"-W        Don't automatically brighten the image\"));\r\n    puts(_(\"-b <num>  Adjust brightness (default = 1.0)\"));\r\n\tputs(_(\"-g <p ts> Set custom gamma curve (default = 2.222 4.5)\"));\r\n    puts(_(\"-q [0-3]  Set the interpolation quality\"));\r\n    puts(_(\"-h        Half-size color image (twice as fast as \\\"-q 0\\\")\"));\r\n    puts(_(\"-f        Interpolate RGGB as four colors\"));\r\n    puts(_(\"-m <num>  Apply a 3x3 median filter to R-G and B-G\"));\r\n    puts(_(\"-s [0..N-1] Select one raw image or \\\"all\\\" from each file\"));\r\n    puts(_(\"-4        Write 16-bit linear instead of 8-bit with gamma\"));\r\n    puts(_(\"-T        Write TIFF instead of PPM\"));\r\n    puts(\"\");\r\n}\r\n\r\nint DCR_CLASS dcr_parse_command_line_options(DCRAW* p, int argc, char **argv, int *arg)\r\n{\r\n\tchar opm, opt, *sp, *cp;\r\n\tint i, c;\r\n\r\n\tif (argv && arg) {\r\n\t\targv[argc] = \"\";\r\n\t\tfor (*arg=1; (((opm = argv[*arg][0]) - 2) | 2) == '+'; ) {\r\n\r\n\t\t\topt = argv[(*arg)++][1];\r\n\t\t\tif ((cp = strchr (sp=\"nbrkStqmHACg\", opt)))\r\n\t\t\t\tfor (i=0;    i < \"114111111422\"[cp-sp]-'0'; i++)\r\n\t\t\t\t\tif (!isdigit(argv[(*arg)+i][0])) {\r\n\t\t\t\t\t\tfprintf (stderr,_(\"Non-numeric argument to \\\"-%c\\\"\\n\"), opt);\r\n\t\t\t\t\t\treturn 1;\r\n\t\t\t\t\t}\r\n\r\n\t\t\tswitch (opt) {\r\n\t\t\tcase 'n':  p->opt.threshold   = (float)atof(argv[(*arg)++]);  break;\r\n\t\t\tcase 'b':  p->opt.bright      = (float)atof(argv[(*arg)++]);  break;\r\n\t\t\tcase 'r':  FORC4 p->opt.user_mul[c] = (float)atof(argv[(*arg)++]);  break;\r\n\t\t\tcase 'C':  p->opt.aber[0]     = 1 / atof(argv[(*arg)++]);\r\n\t\t\t\t\t   p->opt.aber[2]     = 1 / atof(argv[(*arg)++]);  break;\r\n\t\t\tcase 'g':  p->opt.gamm[0]     = 1 / atof(argv[(*arg)++]);\r\n\t\t\t\t\t   p->opt.gamm[1]     =     atof(argv[(*arg)++]);  break;\r\n\t\t\tcase 'k':  p->opt.user_black  = atoi(argv[(*arg)++]);  break;\r\n\t\t\tcase 'S':  p->opt.user_sat    = atoi(argv[(*arg)++]);  break;\r\n\t\t\tcase 't':  p->opt.user_flip   = atoi(argv[(*arg)++]);  break;\r\n\t\t\tcase 'q':  p->opt.user_qual   = atoi(argv[(*arg)++]);  break;\r\n\t\t\tcase 'm':  p->opt.med_passes  = atoi(argv[(*arg)++]);  break;\r\n\t\t\tcase 'H':  p->opt.highlight   = atoi(argv[(*arg)++]);  break;\r\n\t\t\tcase 's':\r\n\t\t\t\t\t   p->opt.shot_select = abs(atoi(argv[*arg]));\r\n\t\t\t\t\t   p->opt.multi_out = !strcmp(argv[(*arg)++],\"all\");\r\n\t\t\t\t\t   break;\r\n\t\t\tcase 'o':\r\n\t\t\t\t\t   if (isdigit(argv[*arg][0]) && !argv[*arg][1])\r\n\t\t\t\t\t\t   p->opt.output_color = atoi(argv[(*arg)++]);\r\n#ifndef NO_LCMS\r\n\t\t\t\t\t\telse p->opt.out_profile = argv[(*arg)++];\r\n\t\t\t\t\t\tbreak;\r\n\t\t\tcase 'p':  p->opt.cam_profile = argv[(*arg)++];\r\n#endif\r\n\t\t\t\t\t   break;\r\n\t\t\tcase 'P':  p->opt.bpfile     = argv[(*arg)++];  break;\r\n\t\t\tcase 'K':  p->opt.dark_frame = argv[(*arg)++];  break;\r\n\t\t\tcase 'z':  p->opt.timestamp_only    = 1;  break;\r\n\t\t\tcase 'e':  p->opt.thumbnail_only    = 1;  break;\r\n\t\t\tcase 'i':  p->opt.identify_only     = 1;  break;\r\n\t\t\tcase 'c':  p->opt.write_to_stdout   = 1;  break;\r\n\t\t\tcase 'v':  p->opt.verbose           = 1;  break;\r\n\t\t\tcase 'h':  p->opt.half_size         = 1;\t\t/* \"-h\" implies \"-f\" */\r\n\t\t\tcase 'f':  p->opt.four_color_rgb    = 1;  break;\r\n\t\t\tcase 'A':  FORC4 p->opt.greybox[c]  = atoi(argv[(*arg)++]);\r\n\t\t\tcase 'a':  p->opt.use_auto_wb       = 1;  break;\r\n\t\t\tcase 'w':  p->opt.use_camera_wb     = 1;  break;\r\n\t\t\tcase 'M':  p->opt.use_camera_matrix = (opm == '+');  break;\r\n\t\t\tcase 'D':\r\n\t\t\tcase 'd':  p->opt.document_mode = 1 + (opt == 'D');\r\n\t\t\tcase 'j':  p->opt.use_fuji_rotate   = 0;  break;\r\n\t\t\tcase 'W':  p->opt.no_auto_bright    = 1;  break;\r\n\t\t\tcase 'T':  p->opt.output_tiff       = 1;  break;\r\n\t\t\tcase '4':  p->opt.output_bps       = 16;  break;\r\n\t\t\tdefault:\r\n\t\t\t\tfprintf (stderr,_(\"Unknown option \\\"-%c\\\".\\n\"), opt);\r\n\t\t\t\treturn 1;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tif (p->opt.use_camera_matrix < 0)\r\n\t\tp->opt.use_camera_matrix = p->opt.use_camera_wb;\r\n\r\n\treturn 0;\r\n}\r\n", "/* $Id: tif_dirread.c,v 1.92.2.9 2010-06-14 00:21:46 fwarmerdam Exp $ */\n\n/*\n * Copyright (c) 1988-1997 Sam Leffler\n * Copyright (c) 1991-1997 Silicon Graphics, Inc.\n *\n * Permission to use, copy, modify, distribute, and sell this software and \n * its documentation for any purpose is hereby granted without fee, provided\n * that (i) the above copyright notices and this permission notice appear in\n * all copies of the software and related documentation, and (ii) the names of\n * Sam Leffler and Silicon Graphics may not be used in any advertising or\n * publicity relating to the software without the specific, prior written\n * permission of Sam Leffler and Silicon Graphics.\n * \n * THE SOFTWARE IS PROVIDED \"AS-IS\" AND WITHOUT WARRANTY OF ANY KIND, \n * EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY \n * WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  \n * \n * IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR\n * ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND,\n * OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,\n * WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF \n * LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE \n * OF THIS SOFTWARE.\n */\n\n/*\n * TIFF Library.\n *\n * Directory Read Support Routines.\n */\n#include \"tiffiop.h\"\n\n#define\tIGNORE\t0\t\t/* tag placeholder used below */\n\n#ifdef HAVE_IEEEFP\n# define\tTIFFCvtIEEEFloatToNative(tif, n, fp)\n# define\tTIFFCvtIEEEDoubleToNative(tif, n, dp)\n#else\nextern\tvoid TIFFCvtIEEEFloatToNative(TIFF*, uint32, float*);\nextern\tvoid TIFFCvtIEEEDoubleToNative(TIFF*, uint32, double*);\n#endif\n\nstatic  TIFFDirEntry* TIFFReadDirectoryFind(TIFFDirEntry* dir,\n\t\t\t\t\t    uint16 dircount, uint16 tagid);\nstatic\tint EstimateStripByteCounts(TIFF*, TIFFDirEntry*, uint16);\nstatic\tvoid MissingRequired(TIFF*, const char*);\nstatic\tint TIFFCheckDirOffset(TIFF*, toff_t);\nstatic\tint CheckDirCount(TIFF*, TIFFDirEntry*, uint32);\nstatic\tuint16 TIFFFetchDirectory(TIFF*, toff_t, TIFFDirEntry**, toff_t *);\nstatic\ttsize_t TIFFFetchData(TIFF*, TIFFDirEntry*, char*);\nstatic\ttsize_t TIFFFetchString(TIFF*, TIFFDirEntry*, char*);\nstatic\tfloat TIFFFetchRational(TIFF*, TIFFDirEntry*);\nstatic\tint TIFFFetchNormalTag(TIFF*, TIFFDirEntry*);\nstatic\tint TIFFFetchPerSampleShorts(TIFF*, TIFFDirEntry*, uint16*);\nstatic\tint TIFFFetchPerSampleLongs(TIFF*, TIFFDirEntry*, uint32*);\nstatic\tint TIFFFetchPerSampleAnys(TIFF*, TIFFDirEntry*, double*);\nstatic\tint TIFFFetchShortArray(TIFF*, TIFFDirEntry*, uint16*);\nstatic\tint TIFFFetchStripThing(TIFF*, TIFFDirEntry*, long, uint32**);\nstatic\tint TIFFFetchRefBlackWhite(TIFF*, TIFFDirEntry*);\nstatic\tint TIFFFetchSubjectDistance(TIFF*, TIFFDirEntry*);\nstatic\tfloat TIFFFetchFloat(TIFF*, TIFFDirEntry*);\nstatic\tint TIFFFetchFloatArray(TIFF*, TIFFDirEntry*, float*);\nstatic\tint TIFFFetchDoubleArray(TIFF*, TIFFDirEntry*, double*);\nstatic\tint TIFFFetchAnyArray(TIFF*, TIFFDirEntry*, double*);\nstatic\tint TIFFFetchShortPair(TIFF*, TIFFDirEntry*);\nstatic\tvoid ChopUpSingleUncompressedStrip(TIFF*);\n\n/*\n * Read the next TIFF directory from a file and convert it to the internal\n * format. We read directories sequentially.\n */\nint\nTIFFReadDirectory(TIFF* tif)\n{\n\tstatic const char module[] = \"TIFFReadDirectory\";\n\n\tint n;\n\tTIFFDirectory* td;\n\tTIFFDirEntry *dp, *dir = NULL;\n\tuint16 iv;\n\tuint32 v;\n\tconst TIFFFieldInfo* fip;\n\tsize_t fix;\n\tuint16 dircount;\n\tint diroutoforderwarning = 0, compressionknown = 0;\n\tint haveunknowntags = 0;\n\n\ttif->tif_diroff = tif->tif_nextdiroff;\n\t/*\n\t * Check whether we have the last offset or bad offset (IFD looping).\n\t */\n\tif (!TIFFCheckDirOffset(tif, tif->tif_nextdiroff))\n\t\treturn 0;\n\t/*\n\t * Cleanup any previous compression state.\n\t */\n\t(*tif->tif_cleanup)(tif);\n\ttif->tif_curdir++;\n\tdircount = TIFFFetchDirectory(tif, tif->tif_nextdiroff,\n\t\t\t\t      &dir, &tif->tif_nextdiroff);\n\tif (!dircount) {\n\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t     \"%s: Failed to read directory at offset %u\",\n\t\t\t     tif->tif_name, tif->tif_nextdiroff);\n\t\treturn 0;\n\t}\n\n\ttif->tif_flags &= ~TIFF_BEENWRITING;\t/* reset before new dir */\n\t/*\n\t * Setup default value and then make a pass over\n\t * the fields to check type and tag information,\n\t * and to extract info required to size data\n\t * structures.  A second pass is made afterwards\n\t * to read in everthing not taken in the first pass.\n\t */\n\ttd = &tif->tif_dir;\n\t/* free any old stuff and reinit */\n\tTIFFFreeDirectory(tif);\n\tTIFFDefaultDirectory(tif);\n\t/*\n\t * Electronic Arts writes gray-scale TIFF files\n\t * without a PlanarConfiguration directory entry.\n\t * Thus we setup a default value here, even though\n\t * the TIFF spec says there is no default value.\n\t */\n\tTIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n\n\t/*\n\t * Sigh, we must make a separate pass through the\n\t * directory for the following reason:\n\t *\n\t * We must process the Compression tag in the first pass\n\t * in order to merge in codec-private tag definitions (otherwise\n\t * we may get complaints about unknown tags).  However, the\n\t * Compression tag may be dependent on the SamplesPerPixel\n\t * tag value because older TIFF specs permited Compression\n\t * to be written as a SamplesPerPixel-count tag entry.\n\t * Thus if we don't first figure out the correct SamplesPerPixel\n\t * tag value then we may end up ignoring the Compression tag\n\t * value because it has an incorrect count value (if the\n\t * true value of SamplesPerPixel is not 1).\n\t *\n\t * It sure would have been nice if Aldus had really thought\n\t * this stuff through carefully.\n\t */\n\tfor (dp = dir, n = dircount; n > 0; n--, dp++) {\n\t\tif (tif->tif_flags & TIFF_SWAB) {\n\t\t\tTIFFSwabArrayOfShort(&dp->tdir_tag, 2);\n\t\t\tTIFFSwabArrayOfLong(&dp->tdir_count, 2);\n\t\t}\n\t\tif (dp->tdir_tag == TIFFTAG_SAMPLESPERPIXEL) {\n\t\t\tif (!TIFFFetchNormalTag(tif, dp))\n\t\t\t\tgoto bad;\n\t\t\tdp->tdir_tag = IGNORE;\n\t\t}\n\t}\n\t/*\n\t * First real pass over the directory.\n\t */\n\tfix = 0;\n\tfor (dp = dir, n = dircount; n > 0; n--, dp++) {\n\n\t\tif (dp->tdir_tag == IGNORE)\n\t\t\tcontinue;\n\t\tif (fix >= tif->tif_nfields)\n\t\t\tfix = 0;\n\n\t\t/*\n\t\t * Silicon Beach (at least) writes unordered\n\t\t * directory tags (violating the spec).  Handle\n\t\t * it here, but be obnoxious (maybe they'll fix it?).\n\t\t */\n\t\tif (dp->tdir_tag < tif->tif_fieldinfo[fix]->field_tag) {\n\t\t\tif (!diroutoforderwarning) {\n\t\t\t\tTIFFWarningExt(tif->tif_clientdata, module,\n\t\"%s: invalid TIFF directory; tags are not sorted in ascending order\",\n\t\t\t\t\t    tif->tif_name);\n\t\t\t\tdiroutoforderwarning = 1;\n\t\t\t}\n\t\t\tfix = 0;\t\t\t/* O(n^2) */\n\t\t}\n\t\twhile (fix < tif->tif_nfields &&\n\t\t    tif->tif_fieldinfo[fix]->field_tag < dp->tdir_tag)\n\t\t\tfix++;\n\t\tif (fix >= tif->tif_nfields ||\n\t\t    tif->tif_fieldinfo[fix]->field_tag != dp->tdir_tag) {\n\t\t\t/* Unknown tag ... we'll deal with it below */\n\t\t\thaveunknowntags = 1;\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * Null out old tags that we ignore.\n\t\t */\n\t\tif (tif->tif_fieldinfo[fix]->field_bit == FIELD_IGNORE) {\n\tignore:\n\t\t\tdp->tdir_tag = IGNORE;\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * Check data type.\n\t\t */\n\t\tfip = tif->tif_fieldinfo[fix];\n\t\twhile (dp->tdir_type != (unsigned short) fip->field_type\n\t\t    && fix < tif->tif_nfields) {\n\t\t\tif (fip->field_type == TIFF_ANY)\t/* wildcard */\n\t\t\t\tbreak;\n\t\t\tfip = tif->tif_fieldinfo[++fix];\n\t\t\tif (fix >= tif->tif_nfields ||\n\t\t\t    fip->field_tag != dp->tdir_tag) {\n\t\t\t\tTIFFWarningExt(tif->tif_clientdata, module,\n\t\t\t\"%s: wrong data type %d for \\\"%s\\\"; tag ignored\",\n\t\t\t\t\t    tif->tif_name, dp->tdir_type,\n\t\t\t\t\t    tif->tif_fieldinfo[fix-1]->field_name);\n\t\t\t\tgoto ignore;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * Check count if known in advance.\n\t\t */\n\t\tif (fip->field_readcount != TIFF_VARIABLE\n\t\t    && fip->field_readcount != TIFF_VARIABLE2) {\n\t\t\tuint32 expected = (fip->field_readcount == TIFF_SPP) ?\n\t\t\t    (uint32) td->td_samplesperpixel :\n\t\t\t    (uint32) fip->field_readcount;\n\t\t\tif (!CheckDirCount(tif, dp, expected))\n\t\t\t\tgoto ignore;\n\t\t}\n\n\t\tswitch (dp->tdir_tag) {\n\t\tcase TIFFTAG_COMPRESSION:\n\t\t\t/*\n\t\t\t * The 5.0 spec says the Compression tag has\n\t\t\t * one value, while earlier specs say it has\n\t\t\t * one value per sample.  Because of this, we\n\t\t\t * accept the tag if one value is supplied.\n\t\t\t */\n\t\t\tif (dp->tdir_count == 1) {\n\t\t\t\tv = TIFFExtractData(tif,\n\t\t\t\t    dp->tdir_type, dp->tdir_offset);\n\t\t\t\tif (!TIFFSetField(tif, dp->tdir_tag, (uint16)v))\n\t\t\t\t\tgoto bad;\n\t\t\t\telse\n\t\t\t\t\tcompressionknown = 1;\n\t\t\t\tbreak;\n\t\t\t/* XXX: workaround for broken TIFFs */\n\t\t\t} else if (dp->tdir_type == TIFF_LONG) {\n\t\t\t\tif (!TIFFFetchPerSampleLongs(tif, dp, &v) ||\n\t\t\t\t    !TIFFSetField(tif, dp->tdir_tag, (uint16)v))\n\t\t\t\t\tgoto bad;\n\t\t\t} else {\n\t\t\t\tif (!TIFFFetchPerSampleShorts(tif, dp, &iv)\n\t\t\t\t    || !TIFFSetField(tif, dp->tdir_tag, iv))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tdp->tdir_tag = IGNORE;\n\t\t\tbreak;\n\t\tcase TIFFTAG_STRIPOFFSETS:\n\t\tcase TIFFTAG_STRIPBYTECOUNTS:\n\t\tcase TIFFTAG_TILEOFFSETS:\n\t\tcase TIFFTAG_TILEBYTECOUNTS:\n\t\t\tTIFFSetFieldBit(tif, fip->field_bit);\n\t\t\tbreak;\n\t\tcase TIFFTAG_IMAGEWIDTH:\n\t\tcase TIFFTAG_IMAGELENGTH:\n\t\tcase TIFFTAG_IMAGEDEPTH:\n\t\tcase TIFFTAG_TILELENGTH:\n\t\tcase TIFFTAG_TILEWIDTH:\n\t\tcase TIFFTAG_TILEDEPTH:\n\t\tcase TIFFTAG_PLANARCONFIG:\n\t\tcase TIFFTAG_ROWSPERSTRIP:\n\t\tcase TIFFTAG_EXTRASAMPLES:\n\t\t\tif (!TIFFFetchNormalTag(tif, dp))\n\t\t\t\tgoto bad;\n\t\t\tdp->tdir_tag = IGNORE;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*\n\t * If we saw any unknown tags, make an extra pass over the directory\n\t * to deal with them.  This must be done separately because the tags\n\t * could have become known when we registered a codec after finding\n\t * the Compression tag.  In a correctly-sorted directory there's\n\t * no problem because Compression will come before any codec-private\n\t * tags, but if the sorting is wrong that might not hold.\n\t */\n\tif (haveunknowntags) {\n\t    fix = 0;\n\t    for (dp = dir, n = dircount; n > 0; n--, dp++) {\n\t\tif (dp->tdir_tag == IGNORE)\n\t\t\tcontinue;\n\t\tif (fix >= tif->tif_nfields ||\n\t\t    dp->tdir_tag < tif->tif_fieldinfo[fix]->field_tag)\n\t\t\tfix = 0;\t\t\t/* O(n^2) */\n\t\twhile (fix < tif->tif_nfields &&\n\t\t    tif->tif_fieldinfo[fix]->field_tag < dp->tdir_tag)\n\t\t\tfix++;\n\t\tif (fix >= tif->tif_nfields ||\n\t\t    tif->tif_fieldinfo[fix]->field_tag != dp->tdir_tag) {\n\n\t\t\t\t\tTIFFWarningExt(tif->tif_clientdata,\n\t\t\t\t\t\t       module,\n                        \"%s: unknown field with tag %d (0x%x) encountered\",\n\t\t\t\t\t\t       tif->tif_name,\n\t\t\t\t\t\t       dp->tdir_tag,\n\t\t\t\t\t\t       dp->tdir_tag);\n\n\t\t\t\t\tif (!_TIFFMergeFieldInfo(tif,\n\t\t\t\t\t\t_TIFFCreateAnonFieldInfo(tif,\n\t\t\t\t\t\tdp->tdir_tag,\n\t\t\t\t\t\t(TIFFDataType) dp->tdir_type),\n\t\t\t\t\t\t1))\n\t\t\t\t\t{\n\t\t\t\t\tTIFFWarningExt(tif->tif_clientdata,\n\t\t\t\t\t\t       module,\n\t\t\t\"Registering anonymous field with tag %d (0x%x) failed\",\n\t\t\t\t\t\t       dp->tdir_tag,\n\t\t\t\t\t\t       dp->tdir_tag);\n\t\t\t\t\tdp->tdir_tag = IGNORE;\n\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\tfix = 0;\n\t\t\twhile (fix < tif->tif_nfields &&\n\t\t\t       tif->tif_fieldinfo[fix]->field_tag < dp->tdir_tag)\n\t\t\t\tfix++;\n\t\t}\n\t\t/*\n\t\t * Check data type.\n\t\t */\n\t\tfip = tif->tif_fieldinfo[fix];\n\t\twhile (dp->tdir_type != (unsigned short) fip->field_type\n\t\t    && fix < tif->tif_nfields) {\n\t\t\tif (fip->field_type == TIFF_ANY)\t/* wildcard */\n\t\t\t\tbreak;\n\t\t\tfip = tif->tif_fieldinfo[++fix];\n\t\t\tif (fix >= tif->tif_nfields ||\n\t\t\t    fip->field_tag != dp->tdir_tag) {\n\t\t\t\tTIFFWarningExt(tif->tif_clientdata, module,\n\t\t\t\"%s: wrong data type %d for \\\"%s\\\"; tag ignored\",\n\t\t\t\t\t    tif->tif_name, dp->tdir_type,\n\t\t\t\t\t    tif->tif_fieldinfo[fix-1]->field_name);\n\t\t\t\tdp->tdir_tag = IGNORE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t    }\n\t}\n\n\t/*\n\t * XXX: OJPEG hack.\n\t * If a) compression is OJPEG, b) planarconfig tag says it's separate,\n\t * c) strip offsets/bytecounts tag are both present and\n\t * d) both contain exactly one value, then we consistently find\n\t * that the buggy implementation of the buggy compression scheme\n\t * matches contig planarconfig best. So we 'fix-up' the tag here\n\t */\n\tif ((td->td_compression==COMPRESSION_OJPEG) &&\n\t    (td->td_planarconfig==PLANARCONFIG_SEPARATE)) {\n\t\tdp = TIFFReadDirectoryFind(dir,dircount,TIFFTAG_STRIPOFFSETS);\n\t\tif ((dp!=0) && (dp->tdir_count==1)) {\n\t\t\tdp = TIFFReadDirectoryFind(dir, dircount,\n\t\t\t\t\t\t   TIFFTAG_STRIPBYTECOUNTS);\n\t\t\tif ((dp!=0) && (dp->tdir_count==1)) {\n\t\t\t\ttd->td_planarconfig=PLANARCONFIG_CONTIG;\n\t\t\t\tTIFFWarningExt(tif->tif_clientdata,\n\t\t\t\t\t       \"TIFFReadDirectory\",\n\t\t\t\t\"Planarconfig tag value assumed incorrect, \"\n\t\t\t\t\"assuming data is contig instead of chunky\");\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Allocate directory structure and setup defaults.\n\t */\n\tif (!TIFFFieldSet(tif, FIELD_IMAGEDIMENSIONS)) {\n\t\tMissingRequired(tif, \"ImageLength\");\n\t\tgoto bad;\n\t}\n\t/* \n\t * Setup appropriate structures (by strip or by tile)\n\t */\n\tif (!TIFFFieldSet(tif, FIELD_TILEDIMENSIONS)) {\n\t\ttd->td_nstrips = TIFFNumberOfStrips(tif);\n\t\ttd->td_tilewidth = td->td_imagewidth;\n\t\ttd->td_tilelength = td->td_rowsperstrip;\n\t\ttd->td_tiledepth = td->td_imagedepth;\n\t\ttif->tif_flags &= ~TIFF_ISTILED;\n\t} else {\n\t\ttd->td_nstrips = TIFFNumberOfTiles(tif);\n\t\ttif->tif_flags |= TIFF_ISTILED;\n\t}\n\tif (!td->td_nstrips) {\n\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t     \"%s: cannot handle zero number of %s\",\n\t\t\t     tif->tif_name, isTiled(tif) ? \"tiles\" : \"strips\");\n\t\tgoto bad;\n\t}\n\ttd->td_stripsperimage = td->td_nstrips;\n\tif (td->td_planarconfig == PLANARCONFIG_SEPARATE)\n\t\ttd->td_stripsperimage /= td->td_samplesperpixel;\n\tif (!TIFFFieldSet(tif, FIELD_STRIPOFFSETS)) {\n\t\tif ((td->td_compression==COMPRESSION_OJPEG) &&\n\t\t    (isTiled(tif)==0) &&\n\t\t    (td->td_nstrips==1)) {\n\t\t\t/*\n\t\t\t * XXX: OJPEG hack.\n\t\t\t * If a) compression is OJPEG, b) it's not a tiled TIFF,\n\t\t\t * and c) the number of strips is 1,\n\t\t\t * then we tolerate the absence of stripoffsets tag,\n\t\t\t * because, presumably, all required data is in the\n\t\t\t * JpegInterchangeFormat stream.\n\t\t\t */\n\t\t\tTIFFSetFieldBit(tif, FIELD_STRIPOFFSETS);\n\t\t} else {\n\t\t\tMissingRequired(tif,\n\t\t\t\tisTiled(tif) ? \"TileOffsets\" : \"StripOffsets\");\n\t\t\tgoto bad;\n\t\t}\n\t}\n\n\t/*\n\t * Second pass: extract other information.\n\t */\n\tfor (dp = dir, n = dircount; n > 0; n--, dp++) {\n\t\tif (dp->tdir_tag == IGNORE)\n\t\t\tcontinue;\n\t\tswitch (dp->tdir_tag) {\n\t\tcase TIFFTAG_MINSAMPLEVALUE:\n\t\tcase TIFFTAG_MAXSAMPLEVALUE:\n\t\tcase TIFFTAG_BITSPERSAMPLE:\n\t\tcase TIFFTAG_DATATYPE:\n\t\tcase TIFFTAG_SAMPLEFORMAT:\n\t\t\t/*\n\t\t\t * The 5.0 spec says the Compression tag has\n\t\t\t * one value, while earlier specs say it has\n\t\t\t * one value per sample.  Because of this, we\n\t\t\t * accept the tag if one value is supplied.\n\t\t\t *\n\t\t\t * The MinSampleValue, MaxSampleValue, BitsPerSample\n\t\t\t * DataType and SampleFormat tags are supposed to be\n\t\t\t * written as one value/sample, but some vendors\n\t\t\t * incorrectly write one value only -- so we accept\n\t\t\t * that as well (yech). Other vendors write correct\n\t\t\t * value for NumberOfSamples, but incorrect one for\n\t\t\t * BitsPerSample and friends, and we will read this\n\t\t\t * too.\n\t\t\t */\n\t\t\tif (dp->tdir_count == 1) {\n\t\t\t\tv = TIFFExtractData(tif,\n\t\t\t\t    dp->tdir_type, dp->tdir_offset);\n\t\t\t\tif (!TIFFSetField(tif, dp->tdir_tag, (uint16)v))\n\t\t\t\t\tgoto bad;\n\t\t\t/* XXX: workaround for broken TIFFs */\n\t\t\t} else if (dp->tdir_tag == TIFFTAG_BITSPERSAMPLE\n\t\t\t\t   && dp->tdir_type == TIFF_LONG) {\n\t\t\t\tif (!TIFFFetchPerSampleLongs(tif, dp, &v) ||\n\t\t\t\t    !TIFFSetField(tif, dp->tdir_tag, (uint16)v))\n\t\t\t\t\tgoto bad;\n\t\t\t} else {\n\t\t\t\tif (!TIFFFetchPerSampleShorts(tif, dp, &iv) ||\n\t\t\t\t    !TIFFSetField(tif, dp->tdir_tag, iv))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFFTAG_SMINSAMPLEVALUE:\n\t\tcase TIFFTAG_SMAXSAMPLEVALUE:\n\t\t\t{\n\t\t\t\tdouble dv = 0.0;\n\t\t\t\tif (!TIFFFetchPerSampleAnys(tif, dp, &dv) ||\n\t\t\t\t    !TIFFSetField(tif, dp->tdir_tag, dv))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFFTAG_STRIPOFFSETS:\n\t\tcase TIFFTAG_TILEOFFSETS:\n\t\t\tif (!TIFFFetchStripThing(tif, dp,\n\t\t\t    td->td_nstrips, &td->td_stripoffset))\n\t\t\t\tgoto bad;\n\t\t\tbreak;\n\t\tcase TIFFTAG_STRIPBYTECOUNTS:\n\t\tcase TIFFTAG_TILEBYTECOUNTS:\n\t\t\tif (!TIFFFetchStripThing(tif, dp,\n\t\t\t    td->td_nstrips, &td->td_stripbytecount))\n\t\t\t\tgoto bad;\n\t\t\tbreak;\n\t\tcase TIFFTAG_COLORMAP:\n\t\tcase TIFFTAG_TRANSFERFUNCTION:\n\t\t\t{\n\t\t\t\tchar* cp;\n\t\t\t\t/*\n\t\t\t\t * TransferFunction can have either 1x or 3x\n\t\t\t\t * data values; Colormap can have only 3x\n\t\t\t\t * items.\n\t\t\t\t */\n\t\t\t\tv = 1L<<td->td_bitspersample;\n\t\t\t\tif (dp->tdir_tag == TIFFTAG_COLORMAP ||\n\t\t\t\t    dp->tdir_count != v) {\n\t\t\t\t\tif (!CheckDirCount(tif, dp, 3 * v))\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tv *= sizeof(uint16);\n\t\t\t\tcp = (char *)_TIFFCheckMalloc(tif,\n\t\t\t\t\t\t\t      dp->tdir_count,\n\t\t\t\t\t\t\t      sizeof (uint16),\n\t\t\t\t\t\"to read \\\"TransferFunction\\\" tag\");\n\t\t\t\tif (cp != NULL) {\n\t\t\t\t\tif (TIFFFetchData(tif, dp, cp)) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * This deals with there being\n\t\t\t\t\t\t * only one array to apply to\n\t\t\t\t\t\t * all samples.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tuint32 c = 1L << td->td_bitspersample;\n\t\t\t\t\t\tif (dp->tdir_count == c)\n\t\t\t\t\t\t\tv = 0L;\n\t\t\t\t\t\tTIFFSetField(tif, dp->tdir_tag,\n\t\t\t\t\t\t    cp, cp+v, cp+2*v);\n\t\t\t\t\t}\n\t\t\t\t\t_TIFFfree(cp);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\tcase TIFFTAG_PAGENUMBER:\n\t\tcase TIFFTAG_HALFTONEHINTS:\n\t\tcase TIFFTAG_YCBCRSUBSAMPLING:\n\t\tcase TIFFTAG_DOTRANGE:\n\t\t\t(void) TIFFFetchShortPair(tif, dp);\n\t\t\tbreak;\n\t\tcase TIFFTAG_REFERENCEBLACKWHITE:\n\t\t\t(void) TIFFFetchRefBlackWhite(tif, dp);\n\t\t\tbreak;\n/* BEGIN REV 4.0 COMPATIBILITY */\n\t\tcase TIFFTAG_OSUBFILETYPE:\n\t\t\tv = 0L;\n\t\t\tswitch (TIFFExtractData(tif, dp->tdir_type,\n\t\t\t    dp->tdir_offset)) {\n\t\t\tcase OFILETYPE_REDUCEDIMAGE:\n\t\t\t\tv = FILETYPE_REDUCEDIMAGE;\n\t\t\t\tbreak;\n\t\t\tcase OFILETYPE_PAGE:\n\t\t\t\tv = FILETYPE_PAGE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (v)\n\t\t\t\tTIFFSetField(tif, TIFFTAG_SUBFILETYPE, v);\n\t\t\tbreak;\n/* END REV 4.0 COMPATIBILITY */\n\t\tdefault:\n\t\t\t(void) TIFFFetchNormalTag(tif, dp);\n\t\t\tbreak;\n\t\t}\n\t}\n\t/*\n\t * OJPEG hack:\n\t * - If a) compression is OJPEG, and b) photometric tag is missing,\n\t * then we consistently find that photometric should be YCbCr\n\t * - If a) compression is OJPEG, and b) photometric tag says it's RGB,\n\t * then we consistently find that the buggy implementation of the\n\t * buggy compression scheme matches photometric YCbCr instead.\n\t * - If a) compression is OJPEG, and b) bitspersample tag is missing,\n\t * then we consistently find bitspersample should be 8.\n\t * - If a) compression is OJPEG, b) samplesperpixel tag is missing,\n\t * and c) photometric is RGB or YCbCr, then we consistently find\n\t * samplesperpixel should be 3\n\t * - If a) compression is OJPEG, b) samplesperpixel tag is missing,\n\t * and c) photometric is MINISWHITE or MINISBLACK, then we consistently\n\t * find samplesperpixel should be 3\n\t */\n\tif (td->td_compression==COMPRESSION_OJPEG)\n\t{\n\t\tif (!TIFFFieldSet(tif,FIELD_PHOTOMETRIC))\n\t\t{\n\t\t\tTIFFWarningExt(tif->tif_clientdata, \"TIFFReadDirectory\",\n\t\t\t\"Photometric tag is missing, assuming data is YCbCr\");\n\t\t\tif (!TIFFSetField(tif,TIFFTAG_PHOTOMETRIC,PHOTOMETRIC_YCBCR))\n\t\t\t\tgoto bad;\n\t\t}\n\t\telse if (td->td_photometric==PHOTOMETRIC_RGB)\n\t\t{\n\t\t\ttd->td_photometric=PHOTOMETRIC_YCBCR;\n\t\t\tTIFFWarningExt(tif->tif_clientdata, \"TIFFReadDirectory\",\n\t\t\t\"Photometric tag value assumed incorrect, \"\n\t\t\t\"assuming data is YCbCr instead of RGB\");\n\t\t}\n\t\tif (!TIFFFieldSet(tif,FIELD_BITSPERSAMPLE))\n\t\t{\n\t\t\tTIFFWarningExt(tif->tif_clientdata,\"TIFFReadDirectory\",\n\t\t\"BitsPerSample tag is missing, assuming 8 bits per sample\");\n\t\t\tif (!TIFFSetField(tif,TIFFTAG_BITSPERSAMPLE,8))\n\t\t\t\tgoto bad;\n\t\t}\n\t\tif (!TIFFFieldSet(tif,FIELD_SAMPLESPERPIXEL))\n\t\t{\n\t\t\tif ((td->td_photometric==PHOTOMETRIC_RGB)\n\t\t\t    || (td->td_photometric==PHOTOMETRIC_YCBCR))\n\t\t\t{\n\t\t\t\tTIFFWarningExt(tif->tif_clientdata,\n\t\t\t\t\t       \"TIFFReadDirectory\",\n\t\t\t\t\"SamplesPerPixel tag is missing, \"\n\t\t\t\t\"assuming correct SamplesPerPixel value is 3\");\n\t\t\t\tif (!TIFFSetField(tif,TIFFTAG_SAMPLESPERPIXEL,3))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\telse if ((td->td_photometric==PHOTOMETRIC_MINISWHITE)\n\t\t\t\t || (td->td_photometric==PHOTOMETRIC_MINISBLACK))\n\t\t\t{\n\t\t\t\tTIFFWarningExt(tif->tif_clientdata,\n\t\t\t\t\t       \"TIFFReadDirectory\",\n\t\t\t\t\"SamplesPerPixel tag is missing, \"\n\t\t\t\t\"assuming correct SamplesPerPixel value is 1\");\n\t\t\t\tif (!TIFFSetField(tif,TIFFTAG_SAMPLESPERPIXEL,1))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\t * Verify Palette image has a Colormap.\n\t */\n\tif (td->td_photometric == PHOTOMETRIC_PALETTE &&\n\t    !TIFFFieldSet(tif, FIELD_COLORMAP)) {\n\t\tMissingRequired(tif, \"Colormap\");\n\t\tgoto bad;\n\t}\n\t/*\n\t * OJPEG hack:\n\t * We do no further messing with strip/tile offsets/bytecounts in OJPEG\n\t * TIFFs\n\t */\n\tif (td->td_compression!=COMPRESSION_OJPEG)\n\t{\n\t\t/*\n\t\t * Attempt to deal with a missing StripByteCounts tag.\n\t\t */\n\t\tif (!TIFFFieldSet(tif, FIELD_STRIPBYTECOUNTS)) {\n\t\t\t/*\n\t\t\t * Some manufacturers violate the spec by not giving\n\t\t\t * the size of the strips.  In this case, assume there\n\t\t\t * is one uncompressed strip of data.\n\t\t\t */\n\t\t\tif ((td->td_planarconfig == PLANARCONFIG_CONTIG &&\n\t\t\t    td->td_nstrips > 1) ||\n\t\t\t    (td->td_planarconfig == PLANARCONFIG_SEPARATE &&\n\t\t\t     td->td_nstrips != td->td_samplesperpixel)) {\n\t\t\t    MissingRequired(tif, \"StripByteCounts\");\n\t\t\t    goto bad;\n\t\t\t}\n\t\t\tTIFFWarningExt(tif->tif_clientdata, module,\n\t\t\t\t\"%s: TIFF directory is missing required \"\n\t\t\t\t\"\\\"%s\\\" field, calculating from imagelength\",\n\t\t\t\ttif->tif_name,\n\t\t\t\t_TIFFFieldWithTag(tif,TIFFTAG_STRIPBYTECOUNTS)->field_name);\n\t\t\tif (EstimateStripByteCounts(tif, dir, dircount) < 0)\n\t\t\t    goto bad;\n\t\t/*\n\t\t * Assume we have wrong StripByteCount value (in case\n\t\t * of single strip) in following cases:\n\t\t *   - it is equal to zero along with StripOffset;\n\t\t *   - it is larger than file itself (in case of uncompressed\n\t\t *     image);\n\t\t *   - it is smaller than the size of the bytes per row\n\t\t *     multiplied on the number of rows.  The last case should\n\t\t *     not be checked in the case of writing new image,\n\t\t *     because we may do not know the exact strip size\n\t\t *     until the whole image will be written and directory\n\t\t *     dumped out.\n\t\t */\n\t\t#define\tBYTECOUNTLOOKSBAD \\\n\t\t    ( (td->td_stripbytecount[0] == 0 && td->td_stripoffset[0] != 0) || \\\n\t\t      (td->td_compression == COMPRESSION_NONE && \\\n\t\t       td->td_stripbytecount[0] > TIFFGetFileSize(tif) - td->td_stripoffset[0]) || \\\n\t\t      (tif->tif_mode == O_RDONLY && \\\n\t\t       td->td_compression == COMPRESSION_NONE && \\\n\t\t       td->td_stripbytecount[0] < TIFFScanlineSize(tif) * td->td_imagelength) )\n\n\t\t} else if (td->td_nstrips == 1\n\t\t\t   && td->td_stripoffset[0] != 0\n\t\t\t   && BYTECOUNTLOOKSBAD) {\n\t\t\t/*\n\t\t\t * XXX: Plexus (and others) sometimes give a value of\n\t\t\t * zero for a tag when they don't know what the\n\t\t\t * correct value is!  Try and handle the simple case\n\t\t\t * of estimating the size of a one strip image.\n\t\t\t */\n\t\t\tTIFFWarningExt(tif->tif_clientdata, module,\n\t\"%s: Bogus \\\"%s\\\" field, ignoring and calculating from imagelength\",\n\t\t\t\t    tif->tif_name,\n\t\t\t\t    _TIFFFieldWithTag(tif,TIFFTAG_STRIPBYTECOUNTS)->field_name);\n\t\t\tif(EstimateStripByteCounts(tif, dir, dircount) < 0)\n\t\t\t    goto bad;\n\t\t} else if (td->td_planarconfig == PLANARCONFIG_CONTIG\n\t\t\t   && td->td_nstrips > 2\n\t\t\t   && td->td_compression == COMPRESSION_NONE\n\t\t\t   && td->td_stripbytecount[0] != td->td_stripbytecount[1]\n                           && td->td_stripbytecount[0] != 0 \n                           && td->td_stripbytecount[1] != 0 ) {\n\t\t\t/*\n\t\t\t * XXX: Some vendors fill StripByteCount array with \n                         * absolutely wrong values (it can be equal to \n                         * StripOffset array, for example). Catch this case \n                         * here.\n\t\t\t */\n\t\t\tTIFFWarningExt(tif->tif_clientdata, module,\n\t\"%s: Wrong \\\"%s\\\" field, ignoring and calculating from imagelength\",\n\t\t\t\t    tif->tif_name,\n\t\t\t\t    _TIFFFieldWithTag(tif,TIFFTAG_STRIPBYTECOUNTS)->field_name);\n\t\t\tif (EstimateStripByteCounts(tif, dir, dircount) < 0)\n\t\t\t    goto bad;\n\t\t}\n\t}\n\tif (dir) {\n\t\t_TIFFfree((char *)dir);\n\t\tdir = NULL;\n\t}\n\tif (!TIFFFieldSet(tif, FIELD_MAXSAMPLEVALUE))\n\t\ttd->td_maxsamplevalue = (uint16)((1L<<td->td_bitspersample)-1);\n\t/*\n\t * Setup default compression scheme.\n\t */\n\n\t/*\n\t * XXX: We can optimize checking for the strip bounds using the sorted\n\t * bytecounts array. See also comments for TIFFAppendToStrip()\n\t * function in tif_write.c.\n\t */\n\tif (td->td_nstrips > 1) {\n\t\ttstrip_t strip;\n\n\t\ttd->td_stripbytecountsorted = 1;\n\t\tfor (strip = 1; strip < td->td_nstrips; strip++) {\n\t\t\tif (td->td_stripoffset[strip - 1] >\n\t\t\t    td->td_stripoffset[strip]) {\n\t\t\t\ttd->td_stripbytecountsorted = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!TIFFFieldSet(tif, FIELD_COMPRESSION))\n\t\tTIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_NONE);\n\t/*\n\t * Some manufacturers make life difficult by writing\n\t * large amounts of uncompressed data as a single strip.\n\t * This is contrary to the recommendations of the spec.\n\t * The following makes an attempt at breaking such images\n\t * into strips closer to the recommended 8k bytes.  A\n\t * side effect, however, is that the RowsPerStrip tag\n\t * value may be changed.\n\t */\n\tif (td->td_nstrips == 1 && td->td_compression == COMPRESSION_NONE &&\n\t    (tif->tif_flags & (TIFF_STRIPCHOP|TIFF_ISTILED)) == TIFF_STRIPCHOP)\n\t\tChopUpSingleUncompressedStrip(tif);\n\n\t/*\n\t * Reinitialize i/o since we are starting on a new directory.\n\t */\n\ttif->tif_row = (uint32) -1;\n\ttif->tif_curstrip = (tstrip_t) -1;\n\ttif->tif_col = (uint32) -1;\n\ttif->tif_curtile = (ttile_t) -1;\n\ttif->tif_tilesize = (tsize_t) -1;\n\n\ttif->tif_scanlinesize = TIFFScanlineSize(tif);\n\tif (!tif->tif_scanlinesize) {\n\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t     \"%s: cannot handle zero scanline size\",\n\t\t\t     tif->tif_name);\n\t\treturn (0);\n\t}\n\n\tif (isTiled(tif)) {\n\t\ttif->tif_tilesize = TIFFTileSize(tif);\n\t\tif (!tif->tif_tilesize) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t     \"%s: cannot handle zero tile size\",\n\t\t\t\t     tif->tif_name);\n\t\t\treturn (0);\n\t\t}\n\t} else {\n\t\tif (!TIFFStripSize(tif)) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t     \"%s: cannot handle zero strip size\",\n\t\t\t\t     tif->tif_name);\n\t\t\treturn (0);\n\t\t}\n\t}\n\treturn (1);\nbad:\n\tif (dir)\n\t\t_TIFFfree(dir);\n\treturn (0);\n}\n\nstatic TIFFDirEntry*\nTIFFReadDirectoryFind(TIFFDirEntry* dir, uint16 dircount, uint16 tagid)\n{\n\tTIFFDirEntry* m;\n\tuint16 n;\n\tfor (m=dir, n=0; n<dircount; m++, n++)\n\t{\n\t\tif (m->tdir_tag==tagid)\n\t\t\treturn(m);\n\t}\n\treturn(0);\n}\n\n/*\n * Read custom directory from the arbitarry offset.\n * The code is very similar to TIFFReadDirectory().\n */\nint\nTIFFReadCustomDirectory(TIFF* tif, toff_t diroff,\n\t\t\tconst TIFFFieldInfo info[], size_t n)\n{\n\tstatic const char module[] = \"TIFFReadCustomDirectory\";\n\n\tTIFFDirectory* td = &tif->tif_dir;\n\tTIFFDirEntry *dp, *dir = NULL;\n\tconst TIFFFieldInfo* fip;\n\tsize_t fix;\n\tuint16 i, dircount;\n\n\t_TIFFSetupFieldInfo(tif, info, n);\n\n\tdircount = TIFFFetchDirectory(tif, diroff, &dir, NULL);\n\tif (!dircount) {\n\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\"%s: Failed to read custom directory at offset %u\",\n\t\t\t     tif->tif_name, diroff);\n\t\treturn 0;\n\t}\n\n\tTIFFFreeDirectory(tif);\n        _TIFFmemset(&tif->tif_dir, 0, sizeof(TIFFDirectory));\n\n\tfix = 0;\n\tfor (dp = dir, i = dircount; i > 0; i--, dp++) {\n\t\tif (tif->tif_flags & TIFF_SWAB) {\n\t\t\tTIFFSwabArrayOfShort(&dp->tdir_tag, 2);\n\t\t\tTIFFSwabArrayOfLong(&dp->tdir_count, 2);\n\t\t}\n\n\t\tif (fix >= tif->tif_nfields || dp->tdir_tag == IGNORE)\n\t\t\tcontinue;\n\n\t\twhile (fix < tif->tif_nfields &&\n\t\t       tif->tif_fieldinfo[fix]->field_tag < dp->tdir_tag)\n\t\t\tfix++;\n\n\t\tif (fix >= tif->tif_nfields ||\n\t\t    tif->tif_fieldinfo[fix]->field_tag != dp->tdir_tag) {\n\n\t\t\tTIFFWarningExt(tif->tif_clientdata, module,\n                        \"%s: unknown field with tag %d (0x%x) encountered\",\n\t\t\t\t    tif->tif_name, dp->tdir_tag, dp->tdir_tag);\n\t\t\tif (!_TIFFMergeFieldInfo(tif,\n\t\t\t\t\t\t _TIFFCreateAnonFieldInfo(tif,\n\t\t\t\t\t\t dp->tdir_tag,\n\t\t\t\t\t\t (TIFFDataType) dp->tdir_type),\n\t\t\t\t\t\t 1))\n\t\t\t{\n\t\t\t\tTIFFWarningExt(tif->tif_clientdata, module,\n\t\t\t\"Registering anonymous field with tag %d (0x%x) failed\",\n\t\t\t\t\t\tdp->tdir_tag, dp->tdir_tag);\n\t\t\t\tgoto ignore;\n\t\t\t}\n\n\t\t\tfix = 0;\n\t\t\twhile (fix < tif->tif_nfields &&\n\t\t\t       tif->tif_fieldinfo[fix]->field_tag < dp->tdir_tag)\n\t\t\t\tfix++;\n\t\t}\n\t\t/*\n\t\t * Null out old tags that we ignore.\n\t\t */\n\t\tif (tif->tif_fieldinfo[fix]->field_bit == FIELD_IGNORE) {\n\tignore:\n\t\t\tdp->tdir_tag = IGNORE;\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * Check data type.\n\t\t */\n\t\tfip = tif->tif_fieldinfo[fix];\n\t\twhile (dp->tdir_type != (unsigned short) fip->field_type\n                       && fix < tif->tif_nfields) {\n\t\t\tif (fip->field_type == TIFF_ANY)\t/* wildcard */\n\t\t\t\tbreak;\n                        fip = tif->tif_fieldinfo[++fix];\n\t\t\tif (fix >= tif->tif_nfields ||\n\t\t\t    fip->field_tag != dp->tdir_tag) {\n\t\t\t\tTIFFWarningExt(tif->tif_clientdata, module,\n\t\t\t\"%s: wrong data type %d for \\\"%s\\\"; tag ignored\",\n\t\t\t\t\t    tif->tif_name, dp->tdir_type,\n\t\t\t\t\t    tif->tif_fieldinfo[fix-1]->field_name);\n\t\t\t\tgoto ignore;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * Check count if known in advance.\n\t\t */\n\t\tif (fip->field_readcount != TIFF_VARIABLE\n\t\t    && fip->field_readcount != TIFF_VARIABLE2) {\n\t\t\tuint32 expected = (fip->field_readcount == TIFF_SPP) ?\n\t\t\t    (uint32) td->td_samplesperpixel :\n\t\t\t    (uint32) fip->field_readcount;\n\t\t\tif (!CheckDirCount(tif, dp, expected))\n\t\t\t\tgoto ignore;\n\t\t}\n\n\t\t/*\n\t\t * EXIF tags which need to be specifically processed.\n\t\t */\n\t\tswitch (dp->tdir_tag) {\n\t\t\tcase EXIFTAG_SUBJECTDISTANCE:\n\t\t\t\t(void) TIFFFetchSubjectDistance(tif, dp);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t(void) TIFFFetchNormalTag(tif, dp);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tif (dir)\n\t\t_TIFFfree(dir);\n\treturn 1;\n}\n\n/*\n * EXIF is important special case of custom IFD, so we have a special\n * function to read it.\n */\nint\nTIFFReadEXIFDirectory(TIFF* tif, toff_t diroff)\n{\n\tsize_t exifFieldInfoCount;\n\tconst TIFFFieldInfo *exifFieldInfo =\n\t\t_TIFFGetExifFieldInfo(&exifFieldInfoCount);\n\treturn TIFFReadCustomDirectory(tif, diroff, exifFieldInfo,\n\t\t\t\t       exifFieldInfoCount);\n}\n\nstatic int\nEstimateStripByteCounts(TIFF* tif, TIFFDirEntry* dir, uint16 dircount)\n{\n\tstatic const char module[] = \"EstimateStripByteCounts\";\n\n\tTIFFDirEntry *dp;\n\tTIFFDirectory *td = &tif->tif_dir;\n\tuint32 strip;\n\n\tif (td->td_stripbytecount)\n\t\t_TIFFfree(td->td_stripbytecount);\n\ttd->td_stripbytecount = (uint32*)\n\t    _TIFFCheckMalloc(tif, td->td_nstrips, sizeof (uint32),\n\t\t\"for \\\"StripByteCounts\\\" array\");\n        if( td->td_stripbytecount == NULL )\n            return -1;\n\n\tif (td->td_compression != COMPRESSION_NONE) {\n\t\tuint32 space = (uint32)(sizeof (TIFFHeader)\n\t\t    + sizeof (uint16)\n\t\t    + (dircount * sizeof (TIFFDirEntry))\n\t\t    + sizeof (uint32));\n\t\ttoff_t filesize = TIFFGetFileSize(tif);\n\t\tuint16 n;\n\n\t\t/* calculate amount of space used by indirect values */\n\t\tfor (dp = dir, n = dircount; n > 0; n--, dp++)\n\t\t{\n\t\t\tuint32 cc = TIFFDataWidth((TIFFDataType) dp->tdir_type);\n\t\t\tif (cc == 0) {\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\"%s: Cannot determine size of unknown tag type %d\",\n\t\t\t\t\t  tif->tif_name, dp->tdir_type);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tcc = cc * dp->tdir_count;\n\t\t\tif (cc > sizeof (uint32))\n\t\t\t\tspace += cc;\n\t\t}\n\t\tspace = filesize - space;\n\t\tif (td->td_planarconfig == PLANARCONFIG_SEPARATE)\n\t\t\tspace /= td->td_samplesperpixel;\n\t\tfor (strip = 0; strip < td->td_nstrips; strip++)\n\t\t\ttd->td_stripbytecount[strip] = space;\n\t\t/*\n\t\t * This gross hack handles the case were the offset to\n\t\t * the last strip is past the place where we think the strip\n\t\t * should begin.  Since a strip of data must be contiguous,\n\t\t * it's safe to assume that we've overestimated the amount\n\t\t * of data in the strip and trim this number back accordingly.\n\t\t */ \n\t\tstrip--;\n\t\tif (((toff_t)(td->td_stripoffset[strip]+\n\t\t\t      td->td_stripbytecount[strip])) > filesize)\n\t\t\ttd->td_stripbytecount[strip] =\n\t\t\t    filesize - td->td_stripoffset[strip];\n\t} else if (isTiled(tif)) {\n\t\tuint32 bytespertile = TIFFTileSize(tif);\n\n\t\tfor (strip = 0; strip < td->td_nstrips; strip++)\n                    td->td_stripbytecount[strip] = bytespertile;\n\t} else {\n\t\tuint32 rowbytes = TIFFScanlineSize(tif);\n\t\tuint32 rowsperstrip = td->td_imagelength/td->td_stripsperimage;\n\t\tfor (strip = 0; strip < td->td_nstrips; strip++)\n\t\t\ttd->td_stripbytecount[strip] = rowbytes * rowsperstrip;\n\t}\n\tTIFFSetFieldBit(tif, FIELD_STRIPBYTECOUNTS);\n\tif (!TIFFFieldSet(tif, FIELD_ROWSPERSTRIP))\n\t\ttd->td_rowsperstrip = td->td_imagelength;\n\treturn 1;\n}\n\nstatic void\nMissingRequired(TIFF* tif, const char* tagname)\n{\n\tstatic const char module[] = \"MissingRequired\";\n\n\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t  \"%s: TIFF directory is missing required \\\"%s\\\" field\",\n\t\t  tif->tif_name, tagname);\n}\n\n/*\n * Check the directory offset against the list of already seen directory\n * offsets. This is a trick to prevent IFD looping. The one can create TIFF\n * file with looped directory pointers. We will maintain a list of already\n * seen directories and check every IFD offset against that list.\n */\nstatic int\nTIFFCheckDirOffset(TIFF* tif, toff_t diroff)\n{\n\tuint16 n;\n\n\tif (diroff == 0)\t\t\t/* no more directories */\n\t\treturn 0;\n\n\tfor (n = 0; n < tif->tif_dirnumber && tif->tif_dirlist; n++) {\n\t\tif (tif->tif_dirlist[n] == diroff)\n\t\t\treturn 0;\n\t}\n\n\ttif->tif_dirnumber++;\n\n\tif (tif->tif_dirnumber > tif->tif_dirlistsize) {\n\t\ttoff_t* new_dirlist;\n\n\t\t/*\n\t\t * XXX: Reduce memory allocation granularity of the dirlist\n\t\t * array.\n\t\t */\n\t\tnew_dirlist = (toff_t *)_TIFFCheckRealloc(tif,\n\t\t\t\t\t\t\t  tif->tif_dirlist,\n\t\t\t\t\t\t\t  tif->tif_dirnumber,\n\t\t\t\t\t\t\t  2 * sizeof(toff_t),\n\t\t\t\t\t\t\t  \"for IFD list\");\n\t\tif (!new_dirlist)\n\t\t\treturn 0;\n\t\ttif->tif_dirlistsize = 2 * tif->tif_dirnumber;\n\t\ttif->tif_dirlist = new_dirlist;\n\t}\n\n\ttif->tif_dirlist[tif->tif_dirnumber - 1] = diroff;\n\n\treturn 1;\n}\n\n/*\n * Check the count field of a directory entry against a known value.  The\n * caller is expected to skip/ignore the tag if there is a mismatch.\n */\nstatic int\nCheckDirCount(TIFF* tif, TIFFDirEntry* dir, uint32 count)\n{\n\tif (count > dir->tdir_count) {\n\t\tTIFFWarningExt(tif->tif_clientdata, tif->tif_name,\n\t\"incorrect count for field \\\"%s\\\" (%u, expecting %u); tag ignored\",\n\t\t    _TIFFFieldWithTag(tif, dir->tdir_tag)->field_name,\n\t\t    dir->tdir_count, count);\n\t\treturn (0);\n\t} else if (count < dir->tdir_count) {\n\t\tTIFFWarningExt(tif->tif_clientdata, tif->tif_name,\n\t\"incorrect count for field \\\"%s\\\" (%u, expecting %u); tag trimmed\",\n\t\t    _TIFFFieldWithTag(tif, dir->tdir_tag)->field_name,\n\t\t    dir->tdir_count, count);\n\t\treturn (1);\n\t}\n\treturn (1);\n}\n\n/*\n * Read IFD structure from the specified offset. If the pointer to\n * nextdiroff variable has been specified, read it too. Function returns a\n * number of fields in the directory or 0 if failed.\n */\nstatic uint16\nTIFFFetchDirectory(TIFF* tif, toff_t diroff, TIFFDirEntry **pdir,\n\t\t   toff_t *nextdiroff)\n{\n\tstatic const char module[] = \"TIFFFetchDirectory\";\n\n\tTIFFDirEntry *dir;\n\tuint16 dircount;\n\n\tassert(pdir);\n\n\ttif->tif_diroff = diroff;\n\tif (nextdiroff)\n\t\t*nextdiroff = 0;\n\tif (!isMapped(tif)) {\n\t\tif (!SeekOK(tif, tif->tif_diroff)) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t\"%s: Seek error accessing TIFF directory\",\n\t\t\t\ttif->tif_name);\n\t\t\treturn 0;\n\t\t}\n\t\tif (!ReadOK(tif, &dircount, sizeof (uint16))) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t\"%s: Can not read TIFF directory count\",\n\t\t\t\ttif->tif_name);\n\t\t\treturn 0;\n\t\t}\n\t\tif (tif->tif_flags & TIFF_SWAB)\n\t\t\tTIFFSwabShort(&dircount);\n\t\tdir = (TIFFDirEntry *)_TIFFCheckMalloc(tif, dircount,\n\t\t\t\t\t\tsizeof (TIFFDirEntry),\n\t\t\t\t\t\t\"to read TIFF directory\");\n\t\tif (dir == NULL)\n\t\t\treturn 0;\n\t\tif (!ReadOK(tif, dir, dircount*sizeof (TIFFDirEntry))) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t\"%.100s: Can not read TIFF directory\",\n\t\t\t\ttif->tif_name);\n\t\t\t_TIFFfree(dir);\n\t\t\treturn 0;\n\t\t}\n\t\t/*\n\t\t * Read offset to next directory for sequential scans if\n\t\t * needed.\n\t\t */\n\t\tif (nextdiroff)\n\t\t\t(void) ReadOK(tif, nextdiroff, sizeof(uint32));\n\t} else {\n\t\ttoff_t off = tif->tif_diroff;\n\n\t\t/*\n\t\t * Check for integer overflow when validating the dir_off,\n\t\t * otherwise a very high offset may cause an OOB read and\n\t\t * crash the client. Make two comparisons instead of\n\t\t *\n\t\t *  off + sizeof(uint16) > tif->tif_size\n\t\t *\n\t\t * to avoid overflow.\n\t\t */\n\t\tif (tif->tif_size < sizeof (uint16) ||\n\t\t    off > tif->tif_size - sizeof(uint16)) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t\"%s: Can not read TIFF directory count\",\n\t\t\t\ttif->tif_name);\n\t\t\treturn 0;\n\t\t} else {\n\t\t\t_TIFFmemcpy(&dircount, tif->tif_base + off,\n\t\t\t\t    sizeof(uint16));\n\t\t}\n\t\toff += sizeof (uint16);\n\t\tif (tif->tif_flags & TIFF_SWAB)\n\t\t\tTIFFSwabShort(&dircount);\n\t\tdir = (TIFFDirEntry *)_TIFFCheckMalloc(tif, dircount,\n\t\t\t\t\t\tsizeof(TIFFDirEntry),\n\t\t\t\t\t\t\"to read TIFF directory\");\n\t\tif (dir == NULL)\n\t\t\treturn 0;\n\t\tif (off + dircount * sizeof (TIFFDirEntry) > tif->tif_size) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t     \"%s: Can not read TIFF directory\",\n\t\t\t\t     tif->tif_name);\n\t\t\t_TIFFfree(dir);\n\t\t\treturn 0;\n\t\t} else {\n\t\t\t_TIFFmemcpy(dir, tif->tif_base + off,\n\t\t\t\t    dircount * sizeof(TIFFDirEntry));\n\t\t}\n\t\tif (nextdiroff) {\n\t\t\toff += dircount * sizeof (TIFFDirEntry);\n\t\t\tif (off + sizeof (uint32) <= tif->tif_size) {\n\t\t\t\t_TIFFmemcpy(nextdiroff, tif->tif_base + off,\n\t\t\t\t\t    sizeof (uint32));\n\t\t\t}\n\t\t}\n\t}\n\tif (nextdiroff && tif->tif_flags & TIFF_SWAB)\n\t\tTIFFSwabLong(nextdiroff);\n\t*pdir = dir;\n\treturn dircount;\n}\n\n/*\n * Fetch a contiguous directory item.\n */\nstatic tsize_t\nTIFFFetchData(TIFF* tif, TIFFDirEntry* dir, char* cp)\n{\n\tuint32 w = TIFFDataWidth((TIFFDataType) dir->tdir_type);\n\t/* \n\t * FIXME: butecount should have tsize_t type, but for now libtiff\n\t * defines tsize_t as a signed 32-bit integer and we are losing\n\t * ability to read arrays larger than 2^31 bytes. So we are using\n\t * uint32 instead of tsize_t here.\n\t */\n\tuint32 cc = dir->tdir_count * w;\n\n\t/* Check for overflow. */\n\tif (!dir->tdir_count || !w || cc / w != dir->tdir_count)\n\t\tgoto bad;\n\n\tif (!isMapped(tif)) {\n\t\tif (!SeekOK(tif, dir->tdir_offset))\n\t\t\tgoto bad;\n\t\tif (!ReadOK(tif, cp, cc))\n\t\t\tgoto bad;\n\t} else {\n\t\t/* Check for overflow. */\n\t\tif (dir->tdir_offset + cc < dir->tdir_offset\n\t\t    || dir->tdir_offset + cc < cc\n\t\t    || dir->tdir_offset + cc > tif->tif_size)\n\t\t\tgoto bad;\n\t\t_TIFFmemcpy(cp, tif->tif_base + dir->tdir_offset, cc);\n\t}\n\tif (tif->tif_flags & TIFF_SWAB) {\n\t\tswitch (dir->tdir_type) {\n\t\tcase TIFF_SHORT:\n\t\tcase TIFF_SSHORT:\n\t\t\tTIFFSwabArrayOfShort((uint16*) cp, dir->tdir_count);\n\t\t\tbreak;\n\t\tcase TIFF_LONG:\n\t\tcase TIFF_SLONG:\n\t\tcase TIFF_FLOAT:\n\t\t\tTIFFSwabArrayOfLong((uint32*) cp, dir->tdir_count);\n\t\t\tbreak;\n\t\tcase TIFF_RATIONAL:\n\t\tcase TIFF_SRATIONAL:\n\t\t\tTIFFSwabArrayOfLong((uint32*) cp, 2*dir->tdir_count);\n\t\t\tbreak;\n\t\tcase TIFF_DOUBLE:\n\t\t\tTIFFSwabArrayOfDouble((double*) cp, dir->tdir_count);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn (cc);\nbad:\n\tTIFFErrorExt(tif->tif_clientdata, tif->tif_name,\n\t\t     \"Error fetching data for field \\\"%s\\\"\",\n\t\t     _TIFFFieldWithTag(tif, dir->tdir_tag)->field_name);\n\treturn (tsize_t) 0;\n}\n\n/*\n * Fetch an ASCII item from the file.\n */\nstatic tsize_t\nTIFFFetchString(TIFF* tif, TIFFDirEntry* dir, char* cp)\n{\n\tif (dir->tdir_count <= 4) {\n\t\tuint32 l = dir->tdir_offset;\n\t\tif (tif->tif_flags & TIFF_SWAB)\n\t\t\tTIFFSwabLong(&l);\n\t\t_TIFFmemcpy(cp, &l, dir->tdir_count);\n\t\treturn (1);\n\t}\n\treturn (TIFFFetchData(tif, dir, cp));\n}\n\n/*\n * Convert numerator+denominator to float.\n */\nstatic int\ncvtRational(TIFF* tif, TIFFDirEntry* dir, uint32 num, uint32 denom, float* rv)\n{\n\tif (denom == 0) {\n\t\tTIFFErrorExt(tif->tif_clientdata, tif->tif_name,\n\t\t    \"%s: Rational with zero denominator (num = %u)\",\n\t\t    _TIFFFieldWithTag(tif, dir->tdir_tag)->field_name, num);\n\t\treturn (0);\n\t} else {\n\t\tif (dir->tdir_type == TIFF_RATIONAL)\n\t\t\t*rv = ((float)num / (float)denom);\n\t\telse\n\t\t\t*rv = ((float)(int32)num / (float)(int32)denom);\n\t\treturn (1);\n\t}\n}\n\n/*\n * Fetch a rational item from the file at offset off and return the value as a\n * floating point number.\n */\nstatic float\nTIFFFetchRational(TIFF* tif, TIFFDirEntry* dir)\n{\n\tuint32 l[2];\n\tfloat v;\n\n\treturn (!TIFFFetchData(tif, dir, (char *)l) ||\n\t    !cvtRational(tif, dir, l[0], l[1], &v) ? 1.0f : v);\n}\n\n/*\n * Fetch a single floating point value from the offset field and return it as\n * a native float.\n */\nstatic float\nTIFFFetchFloat(TIFF* tif, TIFFDirEntry* dir)\n{\n\tfloat v;\n\tint32 l = TIFFExtractData(tif, dir->tdir_type, dir->tdir_offset);\n        _TIFFmemcpy(&v, &l, sizeof(float));\n\tTIFFCvtIEEEFloatToNative(tif, 1, &v);\n\treturn (v);\n}\n\n/*\n * Fetch an array of BYTE or SBYTE values.\n */\nstatic int\nTIFFFetchByteArray(TIFF* tif, TIFFDirEntry* dir, uint8* v)\n{\n    if (dir->tdir_count <= 4) {\n        /*\n         * Extract data from offset field.\n         */\n        if (tif->tif_header.tiff_magic == TIFF_BIGENDIAN) {\n\t    if (dir->tdir_type == TIFF_SBYTE)\n                switch (dir->tdir_count) {\n                    case 4: v[3] = dir->tdir_offset & 0xff;\n                    case 3: v[2] = (dir->tdir_offset >> 8) & 0xff;\n                    case 2: v[1] = (dir->tdir_offset >> 16) & 0xff;\n\t\t    case 1: v[0] = dir->tdir_offset >> 24;\n                }\n\t    else\n                switch (dir->tdir_count) {\n                    case 4: v[3] = dir->tdir_offset & 0xff;\n                    case 3: v[2] = (dir->tdir_offset >> 8) & 0xff;\n                    case 2: v[1] = (dir->tdir_offset >> 16) & 0xff;\n\t\t    case 1: v[0] = dir->tdir_offset >> 24;\n                }\n\t} else {\n\t    if (dir->tdir_type == TIFF_SBYTE)\n                switch (dir->tdir_count) {\n                    case 4: v[3] = dir->tdir_offset >> 24;\n                    case 3: v[2] = (dir->tdir_offset >> 16) & 0xff;\n                    case 2: v[1] = (dir->tdir_offset >> 8) & 0xff;\n                    case 1: v[0] = dir->tdir_offset & 0xff;\n\t\t}\n\t    else\n                switch (dir->tdir_count) {\n                    case 4: v[3] = dir->tdir_offset >> 24;\n                    case 3: v[2] = (dir->tdir_offset >> 16) & 0xff;\n                    case 2: v[1] = (dir->tdir_offset >> 8) & 0xff;\n                    case 1: v[0] = dir->tdir_offset & 0xff;\n\t\t}\n\t}\n        return (1);\n    } else\n        return (TIFFFetchData(tif, dir, (char*) v) != 0);\t/* XXX */\n}\n\n/*\n * Fetch an array of SHORT or SSHORT values.\n */\nstatic int\nTIFFFetchShortArray(TIFF* tif, TIFFDirEntry* dir, uint16* v)\n{\n\tif (dir->tdir_count <= 2) {\n\t\tif (tif->tif_header.tiff_magic == TIFF_BIGENDIAN) {\n\t\t\tswitch (dir->tdir_count) {\n\t\t\tcase 2: v[1] = (uint16) (dir->tdir_offset & 0xffff);\n\t\t\tcase 1: v[0] = (uint16) (dir->tdir_offset >> 16);\n\t\t\t}\n\t\t} else {\n\t\t\tswitch (dir->tdir_count) {\n\t\t\tcase 2: v[1] = (uint16) (dir->tdir_offset >> 16);\n\t\t\tcase 1: v[0] = (uint16) (dir->tdir_offset & 0xffff);\n\t\t\t}\n\t\t}\n\t\treturn (1);\n\t} else\n\t\treturn (TIFFFetchData(tif, dir, (char *)v) != 0);\n}\n\n/*\n * Fetch a pair of SHORT or BYTE values. Some tags may have either BYTE\n * or SHORT type and this function works with both ones.\n */\nstatic int\nTIFFFetchShortPair(TIFF* tif, TIFFDirEntry* dir)\n{\n\t/*\n\t * Prevent overflowing the v stack arrays below by performing a sanity\n\t * check on tdir_count, this should never be greater than two.\n\t */\n\tif (dir->tdir_count > 2) {\n\t\tTIFFWarningExt(tif->tif_clientdata, tif->tif_name,\n\t\t\"unexpected count for field \\\"%s\\\", %u, expected 2; ignored\",\n\t\t\t_TIFFFieldWithTag(tif, dir->tdir_tag)->field_name,\n\t\t\tdir->tdir_count);\n\t\treturn 0;\n\t}\n\n\tswitch (dir->tdir_type) {\n\t\tcase TIFF_BYTE:\n\t\tcase TIFF_SBYTE:\n\t\t\t{\n\t\t\tuint8 v[4];\n\t\t\treturn TIFFFetchByteArray(tif, dir, v)\n\t\t\t\t&& TIFFSetField(tif, dir->tdir_tag, v[0], v[1]);\n\t\t\t}\n\t\tcase TIFF_SHORT:\n\t\tcase TIFF_SSHORT:\n\t\t\t{\n\t\t\tuint16 v[2];\n\t\t\treturn TIFFFetchShortArray(tif, dir, v)\n\t\t\t\t&& TIFFSetField(tif, dir->tdir_tag, v[0], v[1]);\n\t\t\t}\n\t\tdefault:\n\t\t\treturn 0;\n\t}\n}\n\n/*\n * Fetch an array of LONG or SLONG values.\n */\nstatic int\nTIFFFetchLongArray(TIFF* tif, TIFFDirEntry* dir, uint32* v)\n{\n\tif (dir->tdir_count == 1) {\n\t\tv[0] = dir->tdir_offset;\n\t\treturn (1);\n\t} else\n\t\treturn (TIFFFetchData(tif, dir, (char*) v) != 0);\n}\n\n/*\n * Fetch an array of RATIONAL or SRATIONAL values.\n */\nstatic int\nTIFFFetchRationalArray(TIFF* tif, TIFFDirEntry* dir, float* v)\n{\n\tint ok = 0;\n\tuint32* l;\n\n\tl = (uint32*)_TIFFCheckMalloc(tif,\n\t    dir->tdir_count, TIFFDataWidth((TIFFDataType) dir->tdir_type),\n\t    \"to fetch array of rationals\");\n\tif (l) {\n\t\tif (TIFFFetchData(tif, dir, (char *)l)) {\n\t\t\tuint32 i;\n\t\t\tfor (i = 0; i < dir->tdir_count; i++) {\n\t\t\t\tok = cvtRational(tif, dir,\n\t\t\t\t    l[2*i+0], l[2*i+1], &v[i]);\n\t\t\t\tif (!ok)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t_TIFFfree((char *)l);\n\t}\n\treturn (ok);\n}\n\n/*\n * Fetch an array of FLOAT values.\n */\nstatic int\nTIFFFetchFloatArray(TIFF* tif, TIFFDirEntry* dir, float* v)\n{\n\n\tif (dir->tdir_count == 1) {\n\t        union\n\t\t{\n\t\t  float  f;\n\t\t  uint32 i;\n\t\t} float_union;\n\n\t\tfloat_union.i=dir->tdir_offset;\n\t\tv[0]=float_union.f;\n\t\tTIFFCvtIEEEFloatToNative(tif, dir->tdir_count, v);\n\t\treturn (1);\n\t} else\tif (TIFFFetchData(tif, dir, (char*) v)) {\n\t\tTIFFCvtIEEEFloatToNative(tif, dir->tdir_count, v);\n\t\treturn (1);\n\t} else\n\t\treturn (0);\n}\n\n/*\n * Fetch an array of DOUBLE values.\n */\nstatic int\nTIFFFetchDoubleArray(TIFF* tif, TIFFDirEntry* dir, double* v)\n{\n\tif (TIFFFetchData(tif, dir, (char*) v)) {\n\t\tTIFFCvtIEEEDoubleToNative(tif, dir->tdir_count, v);\n\t\treturn (1);\n\t} else\n\t\treturn (0);\n}\n\n/*\n * Fetch an array of ANY values.  The actual values are returned as doubles\n * which should be able hold all the types.  Yes, there really should be an\n * tany_t to avoid this potential non-portability ...  Note in particular that\n * we assume that the double return value vector is large enough to read in\n * any fundamental type.  We use that vector as a buffer to read in the base\n * type vector and then convert it in place to double (from end to front of\n * course).\n */\nstatic int\nTIFFFetchAnyArray(TIFF* tif, TIFFDirEntry* dir, double* v)\n{\n\tint i;\n\n\tswitch (dir->tdir_type) {\n\tcase TIFF_BYTE:\n\tcase TIFF_SBYTE:\n\t\tif (!TIFFFetchByteArray(tif, dir, (uint8*) v))\n\t\t\treturn (0);\n\t\tif (dir->tdir_type == TIFF_BYTE) {\n\t\t\tuint8* vp = (uint8*) v;\n\t\t\tfor (i = dir->tdir_count-1; i >= 0; i--)\n\t\t\t\tv[i] = vp[i];\n\t\t} else {\n\t\t\tint8* vp = (int8*) v;\n\t\t\tfor (i = dir->tdir_count-1; i >= 0; i--)\n\t\t\t\tv[i] = vp[i];\n\t\t}\n\t\tbreak;\n\tcase TIFF_SHORT:\n\tcase TIFF_SSHORT:\n\t\tif (!TIFFFetchShortArray(tif, dir, (uint16*) v))\n\t\t\treturn (0);\n\t\tif (dir->tdir_type == TIFF_SHORT) {\n\t\t\tuint16* vp = (uint16*) v;\n\t\t\tfor (i = dir->tdir_count-1; i >= 0; i--)\n\t\t\t\tv[i] = vp[i];\n\t\t} else {\n\t\t\tint16* vp = (int16*) v;\n\t\t\tfor (i = dir->tdir_count-1; i >= 0; i--)\n\t\t\t\tv[i] = vp[i];\n\t\t}\n\t\tbreak;\n\tcase TIFF_LONG:\n\tcase TIFF_SLONG:\n\t\tif (!TIFFFetchLongArray(tif, dir, (uint32*) v))\n\t\t\treturn (0);\n\t\tif (dir->tdir_type == TIFF_LONG) {\n\t\t\tuint32* vp = (uint32*) v;\n\t\t\tfor (i = dir->tdir_count-1; i >= 0; i--)\n\t\t\t\tv[i] = vp[i];\n\t\t} else {\n\t\t\tint32* vp = (int32*) v;\n\t\t\tfor (i = dir->tdir_count-1; i >= 0; i--)\n\t\t\t\tv[i] = vp[i];\n\t\t}\n\t\tbreak;\n\tcase TIFF_RATIONAL:\n\tcase TIFF_SRATIONAL:\n\t\tif (!TIFFFetchRationalArray(tif, dir, (float*) v))\n\t\t\treturn (0);\n\t\t{ float* vp = (float*) v;\n\t\t  for (i = dir->tdir_count-1; i >= 0; i--)\n\t\t\tv[i] = vp[i];\n\t\t}\n\t\tbreak;\n\tcase TIFF_FLOAT:\n\t\tif (!TIFFFetchFloatArray(tif, dir, (float*) v))\n\t\t\treturn (0);\n\t\t{ float* vp = (float*) v;\n\t\t  for (i = dir->tdir_count-1; i >= 0; i--)\n\t\t\tv[i] = vp[i];\n\t\t}\n\t\tbreak;\n\tcase TIFF_DOUBLE:\n\t\treturn (TIFFFetchDoubleArray(tif, dir, (double*) v));\n\tdefault:\n\t\t/* TIFF_NOTYPE */\n\t\t/* TIFF_ASCII */\n\t\t/* TIFF_UNDEFINED */\n\t\tTIFFErrorExt(tif->tif_clientdata, tif->tif_name,\n\t\t\t     \"cannot read TIFF_ANY type %d for field \\\"%s\\\"\",\n\t\t\t     dir->tdir_type,\n\t\t\t     _TIFFFieldWithTag(tif, dir->tdir_tag)->field_name);\n\t\treturn (0);\n\t}\n\treturn (1);\n}\n\n/*\n * Fetch a tag that is not handled by special case code.\n */\nstatic int\nTIFFFetchNormalTag(TIFF* tif, TIFFDirEntry* dp)\n{\n\tstatic const char mesg[] = \"to fetch tag value\";\n\tint ok = 0;\n\tconst TIFFFieldInfo* fip = _TIFFFieldWithTag(tif, dp->tdir_tag);\n\n\tif (dp->tdir_count > 1) {\t\t/* array of values */\n\t\tchar* cp = NULL;\n\n\t\tswitch (dp->tdir_type) {\n\t\tcase TIFF_BYTE:\n\t\tcase TIFF_SBYTE:\n\t\t\tcp = (char *)_TIFFCheckMalloc(tif,\n\t\t\t    dp->tdir_count, sizeof (uint8), mesg);\n\t\t\tok = cp && TIFFFetchByteArray(tif, dp, (uint8*) cp);\n\t\t\tbreak;\n\t\tcase TIFF_SHORT:\n\t\tcase TIFF_SSHORT:\n\t\t\tcp = (char *)_TIFFCheckMalloc(tif,\n\t\t\t    dp->tdir_count, sizeof (uint16), mesg);\n\t\t\tok = cp && TIFFFetchShortArray(tif, dp, (uint16*) cp);\n\t\t\tbreak;\n\t\tcase TIFF_LONG:\n\t\tcase TIFF_SLONG:\n\t\t\tcp = (char *)_TIFFCheckMalloc(tif,\n\t\t\t    dp->tdir_count, sizeof (uint32), mesg);\n\t\t\tok = cp && TIFFFetchLongArray(tif, dp, (uint32*) cp);\n\t\t\tbreak;\n\t\tcase TIFF_RATIONAL:\n\t\tcase TIFF_SRATIONAL:\n\t\t\tcp = (char *)_TIFFCheckMalloc(tif,\n\t\t\t    dp->tdir_count, sizeof (float), mesg);\n\t\t\tok = cp && TIFFFetchRationalArray(tif, dp, (float*) cp);\n\t\t\tbreak;\n\t\tcase TIFF_FLOAT:\n\t\t\tcp = (char *)_TIFFCheckMalloc(tif,\n\t\t\t    dp->tdir_count, sizeof (float), mesg);\n\t\t\tok = cp && TIFFFetchFloatArray(tif, dp, (float*) cp);\n\t\t\tbreak;\n\t\tcase TIFF_DOUBLE:\n\t\t\tcp = (char *)_TIFFCheckMalloc(tif,\n\t\t\t    dp->tdir_count, sizeof (double), mesg);\n\t\t\tok = cp && TIFFFetchDoubleArray(tif, dp, (double*) cp);\n\t\t\tbreak;\n\t\tcase TIFF_ASCII:\n\t\tcase TIFF_UNDEFINED:\t\t/* bit of a cheat... */\n\t\t\t/*\n\t\t\t * Some vendors write strings w/o the trailing\n\t\t\t * NULL byte, so always append one just in case.\n\t\t\t */\n\t\t\tcp = (char *)_TIFFCheckMalloc(tif, dp->tdir_count + 1,\n\t\t\t\t\t\t      1, mesg);\n\t\t\tif( (ok = (cp && TIFFFetchString(tif, dp, cp))) != 0 )\n\t\t\t\tcp[dp->tdir_count] = '\\0';\t/* XXX */\n\t\t\tbreak;\n\t\t}\n\t\tif (ok) {\n\t\t\tok = (fip->field_passcount ?\n\t\t\t    TIFFSetField(tif, dp->tdir_tag, dp->tdir_count, cp)\n\t\t\t  : TIFFSetField(tif, dp->tdir_tag, cp));\n\t\t}\n\t\tif (cp != NULL)\n\t\t\t_TIFFfree(cp);\n\t} else if (CheckDirCount(tif, dp, 1)) {\t/* singleton value */\n\t\tswitch (dp->tdir_type) {\n\t\tcase TIFF_BYTE:\n\t\tcase TIFF_SBYTE:\n\t\tcase TIFF_SHORT:\n\t\tcase TIFF_SSHORT:\n\t\t\t/*\n\t\t\t * If the tag is also acceptable as a LONG or SLONG\n\t\t\t * then TIFFSetField will expect an uint32 parameter\n\t\t\t * passed to it (through varargs).  Thus, for machines\n\t\t\t * where sizeof (int) != sizeof (uint32) we must do\n\t\t\t * a careful check here.  It's hard to say if this\n\t\t\t * is worth optimizing.\n\t\t\t *\n\t\t\t * NB: We use TIFFFieldWithTag here knowing that\n\t\t\t *     it returns us the first entry in the table\n\t\t\t *     for the tag and that that entry is for the\n\t\t\t *     widest potential data type the tag may have.\n\t\t\t */\n\t\t\t{ TIFFDataType type = fip->field_type;\n\t\t\t  if (type != TIFF_LONG && type != TIFF_SLONG) {\n\t\t\t\tuint16 v = (uint16)\n\t\t\t   TIFFExtractData(tif, dp->tdir_type, dp->tdir_offset);\n\t\t\t\tok = (fip->field_passcount ?\n\t\t\t\t    TIFFSetField(tif, dp->tdir_tag, 1, &v)\n\t\t\t\t  : TIFFSetField(tif, dp->tdir_tag, v));\n\t\t\t\tbreak;\n\t\t\t  }\n\t\t\t}\n\t\t\t/* fall thru... */\n\t\tcase TIFF_LONG:\n\t\tcase TIFF_SLONG:\n\t\t\t{ uint32 v32 =\n\t\t    TIFFExtractData(tif, dp->tdir_type, dp->tdir_offset);\n\t\t\t  ok = (fip->field_passcount ? \n\t\t\t      TIFFSetField(tif, dp->tdir_tag, 1, &v32)\n\t\t\t    : TIFFSetField(tif, dp->tdir_tag, v32));\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_RATIONAL:\n\t\tcase TIFF_SRATIONAL:\n\t\tcase TIFF_FLOAT:\n\t\t\t{ float v = (dp->tdir_type == TIFF_FLOAT ? \n\t\t\t      TIFFFetchFloat(tif, dp)\n\t\t\t    : TIFFFetchRational(tif, dp));\n\t\t\t  ok = (fip->field_passcount ?\n\t\t\t      TIFFSetField(tif, dp->tdir_tag, 1, &v)\n\t\t\t    : TIFFSetField(tif, dp->tdir_tag, v));\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_DOUBLE:\n\t\t\t{ double v;\n\t\t\t  ok = (TIFFFetchDoubleArray(tif, dp, &v) &&\n\t\t\t    (fip->field_passcount ?\n\t\t\t      TIFFSetField(tif, dp->tdir_tag, 1, &v)\n\t\t\t    : TIFFSetField(tif, dp->tdir_tag, v))\n\t\t\t  );\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_ASCII:\n\t\tcase TIFF_UNDEFINED:\t\t/* bit of a cheat... */\n\t\t\t{ char c[2];\n\t\t\t  if( (ok = (TIFFFetchString(tif, dp, c) != 0)) != 0 ) {\n\t\t\t\tc[1] = '\\0';\t\t/* XXX paranoid */\n\t\t\t\tok = (fip->field_passcount ?\n\t\t\t\t\tTIFFSetField(tif, dp->tdir_tag, 1, c)\n\t\t\t\t      : TIFFSetField(tif, dp->tdir_tag, c));\n\t\t\t  }\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn (ok);\n}\n\n#define\tNITEMS(x)\t(sizeof (x) / sizeof (x[0]))\n/*\n * Fetch samples/pixel short values for \n * the specified tag and verify that\n * all values are the same.\n */\nstatic int\nTIFFFetchPerSampleShorts(TIFF* tif, TIFFDirEntry* dir, uint16* pl)\n{\n    uint16 samples = tif->tif_dir.td_samplesperpixel;\n    int status = 0;\n\n    if (CheckDirCount(tif, dir, (uint32) samples)) {\n        uint16 buf[10];\n        uint16* v = buf;\n\n        if (dir->tdir_count > NITEMS(buf))\n            v = (uint16*) _TIFFCheckMalloc(tif, dir->tdir_count, sizeof(uint16),\n                                      \"to fetch per-sample values\");\n        if (v && TIFFFetchShortArray(tif, dir, v)) {\n            uint16 i;\n            int check_count = dir->tdir_count;\n            if( samples < check_count )\n                check_count = samples;\n\n            for (i = 1; i < check_count; i++)\n                if (v[i] != v[0]) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, tif->tif_name,\n                \"Cannot handle different per-sample values for field \\\"%s\\\"\",\n\t\t\t_TIFFFieldWithTag(tif, dir->tdir_tag)->field_name);\n\t\t\tgoto bad;\n                }\n            *pl = v[0];\n            status = 1;\n        }\n      bad:\n        if (v && v != buf)\n            _TIFFfree(v);\n    }\n    return (status);\n}\n\n/*\n * Fetch samples/pixel long values for \n * the specified tag and verify that\n * all values are the same.\n */\nstatic int\nTIFFFetchPerSampleLongs(TIFF* tif, TIFFDirEntry* dir, uint32* pl)\n{\n    uint16 samples = tif->tif_dir.td_samplesperpixel;\n    int status = 0;\n\n    if (CheckDirCount(tif, dir, (uint32) samples)) {\n        uint32 buf[10];\n        uint32* v = buf;\n\n        if (dir->tdir_count > NITEMS(buf))\n            v = (uint32*) _TIFFCheckMalloc(tif, dir->tdir_count, sizeof(uint32),\n                                      \"to fetch per-sample values\");\n        if (v && TIFFFetchLongArray(tif, dir, v)) {\n            uint16 i;\n            int check_count = dir->tdir_count;\n\n            if( samples < check_count )\n                check_count = samples;\n            for (i = 1; i < check_count; i++)\n                if (v[i] != v[0]) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, tif->tif_name,\n                \"Cannot handle different per-sample values for field \\\"%s\\\"\",\n\t\t\t_TIFFFieldWithTag(tif, dir->tdir_tag)->field_name);\n\t\t\tgoto bad;\n                }\n            *pl = v[0];\n            status = 1;\n        }\n      bad:\n        if (v && v != buf)\n            _TIFFfree(v);\n    }\n    return (status);\n}\n\n/*\n * Fetch samples/pixel ANY values for the specified tag and verify that all\n * values are the same.\n */\nstatic int\nTIFFFetchPerSampleAnys(TIFF* tif, TIFFDirEntry* dir, double* pl)\n{\n    uint16 samples = tif->tif_dir.td_samplesperpixel;\n    int status = 0;\n\n    if (CheckDirCount(tif, dir, (uint32) samples)) {\n        double buf[10];\n        double* v = buf;\n\n        if (dir->tdir_count > NITEMS(buf))\n            v = (double*) _TIFFCheckMalloc(tif, dir->tdir_count, sizeof (double),\n                                      \"to fetch per-sample values\");\n        if (v && TIFFFetchAnyArray(tif, dir, v)) {\n            uint16 i;\n            int check_count = dir->tdir_count;\n            if( samples < check_count )\n                check_count = samples;\n\n            for (i = 1; i < check_count; i++)\n                if (v[i] != v[0]) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, tif->tif_name,\n\t\t\"Cannot handle different per-sample values for field \\\"%s\\\"\",\n\t\t\t_TIFFFieldWithTag(tif, dir->tdir_tag)->field_name);\n\t\t\tgoto bad;\n                }\n            *pl = v[0];\n            status = 1;\n        }\n      bad:\n        if (v && v != buf)\n            _TIFFfree(v);\n    }\n    return (status);\n}\n#undef NITEMS\n\n/*\n * Fetch a set of offsets or lengths.\n * While this routine says \"strips\", in fact it's also used for tiles.\n */\nstatic int\nTIFFFetchStripThing(TIFF* tif, TIFFDirEntry* dir, long nstrips, uint32** lpp)\n{\n\tregister uint32* lp;\n\tint status;\n\n        CheckDirCount(tif, dir, (uint32) nstrips);\n\n\t/*\n\t * Allocate space for strip information.\n\t */\n\tif (*lpp == NULL &&\n\t    (*lpp = (uint32 *)_TIFFCheckMalloc(tif,\n\t      nstrips, sizeof (uint32), \"for strip array\")) == NULL)\n\t\treturn (0);\n\tlp = *lpp;\n        _TIFFmemset( lp, 0, sizeof(uint32) * nstrips );\n\n\tif (dir->tdir_type == (int)TIFF_SHORT) {\n\t\t/*\n\t\t * Handle uint16->uint32 expansion.\n\t\t */\n\t\tuint16* dp = (uint16*) _TIFFCheckMalloc(tif,\n\t\t    dir->tdir_count, sizeof (uint16), \"to fetch strip tag\");\n\t\tif (dp == NULL)\n\t\t\treturn (0);\n\t\tif( (status = TIFFFetchShortArray(tif, dir, dp)) != 0 ) {\n                    int i;\n                    \n                    for( i = 0; i < nstrips && i < (int) dir->tdir_count; i++ )\n                    {\n                        lp[i] = dp[i];\n                    }\n\t\t}\n\t\t_TIFFfree((char*) dp);\n\n        } else if( nstrips != (int) dir->tdir_count ) {\n            /* Special case to correct length */\n\n            uint32* dp = (uint32*) _TIFFCheckMalloc(tif,\n\t\t    dir->tdir_count, sizeof (uint32), \"to fetch strip tag\");\n            if (dp == NULL)\n                return (0);\n\n            status = TIFFFetchLongArray(tif, dir, dp);\n            if( status != 0 ) {\n                int i;\n\n                for( i = 0; i < nstrips && i < (int) dir->tdir_count; i++ )\n                {\n                    lp[i] = dp[i];\n                }\n            }\n\n            _TIFFfree( (char *) dp );\n\t} else\n            status = TIFFFetchLongArray(tif, dir, lp);\n        \n\treturn (status);\n}\n\n/*\n * Fetch and set the RefBlackWhite tag.\n */\nstatic int\nTIFFFetchRefBlackWhite(TIFF* tif, TIFFDirEntry* dir)\n{\n\tstatic const char mesg[] = \"for \\\"ReferenceBlackWhite\\\" array\";\n\tchar* cp;\n\tint ok;\n\n\tif (dir->tdir_type == TIFF_RATIONAL)\n\t\treturn (TIFFFetchNormalTag(tif, dir));\n\t/*\n\t * Handle LONG's for backward compatibility.\n\t */\n\tcp = (char *)_TIFFCheckMalloc(tif, dir->tdir_count,\n\t\t\t\t      sizeof (uint32), mesg);\n\tif( (ok = (cp && TIFFFetchLongArray(tif, dir, (uint32*) cp))) != 0) {\n\t\tfloat* fp = (float*)\n\t\t    _TIFFCheckMalloc(tif, dir->tdir_count, sizeof (float), mesg);\n\t\tif( (ok = (fp != NULL)) != 0 ) {\n\t\t\tuint32 i;\n\t\t\tfor (i = 0; i < dir->tdir_count; i++)\n\t\t\t\tfp[i] = (float)((uint32*) cp)[i];\n\t\t\tok = TIFFSetField(tif, dir->tdir_tag, fp);\n\t\t\t_TIFFfree((char*) fp);\n\t\t}\n\t}\n\tif (cp)\n\t\t_TIFFfree(cp);\n\treturn (ok);\n}\n\n/*\n * Fetch and set the SubjectDistance EXIF tag.\n */\nstatic int\nTIFFFetchSubjectDistance(TIFF* tif, TIFFDirEntry* dir)\n{\n\tuint32 l[2];\n\tfloat v;\n\tint ok = 0;\n\n    if( dir->tdir_count != 1 || dir->tdir_type != TIFF_RATIONAL )\n    {\n\t\tTIFFWarningExt(tif->tif_clientdata, tif->tif_name,\n                       \"incorrect count or type for SubjectDistance, tag ignored\" );\n\t\treturn (0);\n    }\n\n\tif (TIFFFetchData(tif, dir, (char *)l)\n\t    && cvtRational(tif, dir, l[0], l[1], &v)) {\n\t\t/*\n\t\t * XXX: Numerator 0xFFFFFFFF means that we have infinite\n\t\t * distance. Indicate that with a negative floating point\n\t\t * SubjectDistance value.\n\t\t */\n\t\tok = TIFFSetField(tif, dir->tdir_tag,\n\t\t\t\t  (l[0] != 0xFFFFFFFF) ? v : -v);\n\t}\n\n\treturn ok;\n}\n\n/*\n * Replace a single strip (tile) of uncompressed data by multiple strips\n * (tiles), each approximately STRIP_SIZE_DEFAULT bytes. This is useful for\n * dealing with large images or for dealing with machines with a limited\n * amount memory.\n */\nstatic void\nChopUpSingleUncompressedStrip(TIFF* tif)\n{\n\tregister TIFFDirectory *td = &tif->tif_dir;\n\tuint32 bytecount = td->td_stripbytecount[0];\n\tuint32 offset = td->td_stripoffset[0];\n\ttsize_t rowbytes = TIFFVTileSize(tif, 1), stripbytes;\n\ttstrip_t strip, nstrips, rowsperstrip;\n\tuint32* newcounts;\n\tuint32* newoffsets;\n\n\t/*\n\t * Make the rows hold at least one scanline, but fill specified amount\n\t * of data if possible.\n\t */\n\tif (rowbytes > STRIP_SIZE_DEFAULT) {\n\t\tstripbytes = rowbytes;\n\t\trowsperstrip = 1;\n\t} else if (rowbytes > 0 ) {\n\t\trowsperstrip = STRIP_SIZE_DEFAULT / rowbytes;\n\t\tstripbytes = rowbytes * rowsperstrip;\n\t}\n        else\n            return;\n\n\t/* \n\t * never increase the number of strips in an image\n\t */\n\tif (rowsperstrip >= td->td_rowsperstrip)\n\t\treturn;\n\tnstrips = (tstrip_t) TIFFhowmany(bytecount, stripbytes);\n        if( nstrips == 0 ) /* something is wonky, do nothing. */\n            return;\n\n\tnewcounts = (uint32*) _TIFFCheckMalloc(tif, nstrips, sizeof (uint32),\n\t\t\t\t\"for chopped \\\"StripByteCounts\\\" array\");\n\tnewoffsets = (uint32*) _TIFFCheckMalloc(tif, nstrips, sizeof (uint32),\n\t\t\t\t\"for chopped \\\"StripOffsets\\\" array\");\n\tif (newcounts == NULL || newoffsets == NULL) {\n\t        /*\n\t\t * Unable to allocate new strip information, give up and use\n\t\t * the original one strip information.\n\t\t */\n\t\tif (newcounts != NULL)\n\t\t\t_TIFFfree(newcounts);\n\t\tif (newoffsets != NULL)\n\t\t\t_TIFFfree(newoffsets);\n\t\treturn;\n\t}\n\t/*\n\t * Fill the strip information arrays with new bytecounts and offsets\n\t * that reflect the broken-up format.\n\t */\n\tfor (strip = 0; strip < nstrips; strip++) {\n\t\tif ((uint32)stripbytes > bytecount)\n\t\t\tstripbytes = bytecount;\n\t\tnewcounts[strip] = stripbytes;\n\t\tnewoffsets[strip] = offset;\n\t\toffset += stripbytes;\n\t\tbytecount -= stripbytes;\n\t}\n\t/*\n\t * Replace old single strip info with multi-strip info.\n\t */\n\ttd->td_stripsperimage = td->td_nstrips = nstrips;\n\tTIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, rowsperstrip);\n\n\t_TIFFfree(td->td_stripbytecount);\n\t_TIFFfree(td->td_stripoffset);\n\ttd->td_stripbytecount = newcounts;\n\ttd->td_stripoffset = newoffsets;\n\ttd->td_stripbytecountsorted = 1;\n}\n\n/* vim: set ts=8 sts=8 sw=8 noet: */\n/*\n * Local Variables:\n * mode: c\n * c-basic-offset: 8\n * fill-column: 78\n * End:\n */\n", "/* $Id: tif_ojpeg.c,v 1.24.2.6 2010-06-08 23:29:51 bfriesen Exp $ */\n\n/* WARNING: The type of JPEG encapsulation defined by the TIFF Version 6.0\n   specification is now totally obsolete and deprecated for new applications and\n   images. This file was was created solely in order to read unconverted images\n   still present on some users' computer systems. It will never be extended\n   to write such files. Writing new-style JPEG compressed TIFFs is implemented\n   in tif_jpeg.c.\n\n   The code is carefully crafted to robustly read all gathered JPEG-in-TIFF\n   testfiles, and anticipate as much as possible all other... But still, it may\n   fail on some. If you encounter problems, please report them on the TIFF\n   mailing list and/or to Joris Van Damme <info@awaresystems.be>.\n\n   Please read the file called \"TIFF Technical Note #2\" if you need to be\n   convinced this compression scheme is bad and breaks TIFF. That document\n   is linked to from the LibTiff site <http://www.remotesensing.org/libtiff/>\n   and from AWare Systems' TIFF section\n   <http://www.awaresystems.be/imaging/tiff.html>. It is also absorbed\n   in Adobe's specification supplements, marked \"draft\" up to this day, but\n   supported by the TIFF community.\n\n   This file interfaces with Release 6B of the JPEG Library written by the\n   Independent JPEG Group. Previous versions of this file required a hack inside\n   the LibJpeg library. This version no longer requires that. Remember to\n   remove the hack if you update from the old version.\n\n   Copyright (c) Joris Van Damme <info@awaresystems.be>\n   Copyright (c) AWare Systems <http://www.awaresystems.be/>\n\n   The licence agreement for this file is the same as the rest of the LibTiff\n   library.\n\n   IN NO EVENT SHALL JORIS VAN DAMME OR AWARE SYSTEMS BE LIABLE FOR\n   ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND,\n   OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,\n   WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF\n   LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE\n   OF THIS SOFTWARE.\n\n   Joris Van Damme and/or AWare Systems may be available for custom\n   developement. If you like what you see, and need anything similar or related,\n   contact <info@awaresystems.be>.\n*/\n\n/* What is what, and what is not?\n\n   This decoder starts with an input stream, that is essentially the JpegInterchangeFormat\n   stream, if any, followed by the strile data, if any. This stream is read in\n   OJPEGReadByte and related functions.\n\n   It analyzes the start of this stream, until it encounters non-marker data, i.e.\n   compressed image data. Some of the header markers it sees have no actual content,\n   like the SOI marker, and APP/COM markers that really shouldn't even be there. Some\n   other markers do have content, and the valuable bits and pieces of information\n   in these markers are saved, checking all to verify that the stream is more or\n   less within expected bounds. This happens inside the OJPEGReadHeaderInfoSecStreamXxx\n   functions.\n\n   Some OJPEG imagery contains no valid JPEG header markers. This situation is picked\n   up on if we've seen no SOF marker when we're at the start of the compressed image\n   data. In this case, the tables are read from JpegXxxTables tags, and the other\n   bits and pieces of information is initialized to its most basic value. This is\n   implemented in the OJPEGReadHeaderInfoSecTablesXxx functions.\n\n   When this is complete, a good and valid JPEG header can be assembled, and this is\n   passed through to LibJpeg. When that's done, the remainder of the input stream, i.e.\n   the compressed image data, can be passed through unchanged. This is done in\n   OJPEGWriteStream functions.\n\n   LibTiff rightly expects to know the subsampling values before decompression. Just like\n   in new-style JPEG-in-TIFF, though, or even more so, actually, the YCbCrsubsampling\n   tag is notoriously unreliable. To correct these tag values with the ones inside\n   the JPEG stream, the first part of the input stream is pre-scanned in\n   OJPEGSubsamplingCorrect, making no note of any other data, reporting no warnings\n   or errors, up to the point where either these values are read, or it's clear they\n   aren't there. This means that some of the data is read twice, but we feel speed\n   in correcting these values is important enough to warrant this sacrifice. Allthough\n   there is currently no define or other configuration mechanism to disable this behaviour,\n   the actual header scanning is build to robustly respond with error report if it\n   should encounter an uncorrected mismatch of subsampling values. See\n   OJPEGReadHeaderInfoSecStreamSof.\n\n   The restart interval and restart markers are the most tricky part... The restart\n   interval can be specified in a tag. It can also be set inside the input JPEG stream.\n   It can be used inside the input JPEG stream. If reading from strile data, we've\n   consistenly discovered the need to insert restart markers in between the different\n   striles, as is also probably the most likely interpretation of the original TIFF 6.0\n   specification. With all this setting of interval, and actual use of markers that is not\n   predictable at the time of valid JPEG header assembly, the restart thing may turn\n   out the Achilles heel of this implementation. Fortunately, most OJPEG writer vendors\n   succeed in reading back what they write, which may be the reason why we've been able\n   to discover ways that seem to work.\n\n   Some special provision is made for planarconfig separate OJPEG files. These seem\n   to consistently contain header info, a SOS marker, a plane, SOS marker, plane, SOS,\n   and plane. This may or may not be a valid JPEG configuration, we don't know and don't\n   care. We want LibTiff to be able to access the planes individually, without huge\n   buffering inside LibJpeg, anyway. So we compose headers to feed to LibJpeg, in this\n   case, that allow us to pass a single plane such that LibJpeg sees a valid\n   single-channel JPEG stream. Locating subsequent SOS markers, and thus subsequent\n   planes, is done inside OJPEGReadSecondarySos.\n\n   The benefit of the scheme is... that it works, basically. We know of no other that\n   does. It works without checking software tag, or otherwise going about things in an\n   OJPEG flavor specific manner. Instead, it is a single scheme, that covers the cases\n   with and without JpegInterchangeFormat, with and without striles, with part of\n   the header in JpegInterchangeFormat and remainder in first strile, etc. It is forgiving\n   and robust, may likely work with OJPEG flavors we've not seen yet, and makes most out\n   of the data.\n\n   Another nice side-effect is that a complete JPEG single valid stream is build if\n   planarconfig is not separate (vast majority). We may one day use that to build\n   converters to JPEG, and/or to new-style JPEG compression inside TIFF.\n\n   A dissadvantage is the lack of random access to the individual striles. This is the\n   reason for much of the complicated restart-and-position stuff inside OJPEGPreDecode.\n   Applications would do well accessing all striles in order, as this will result in\n   a single sequential scan of the input stream, and no restarting of LibJpeg decoding\n   session.\n*/\n\n\n#include \"tiffiop.h\"\n#ifdef OJPEG_SUPPORT\n\n/* Configuration defines here are:\n * JPEG_ENCAP_EXTERNAL: The normal way to call libjpeg, uses longjump. In some environments,\n * \tlike eg LibTiffDelphi, this is not possible. For this reason, the actual calls to\n * \tlibjpeg, with longjump stuff, are encapsulated in dedicated functions. When\n * \tJPEG_ENCAP_EXTERNAL is defined, these encapsulating functions are declared external\n * \tto this unit, and can be defined elsewhere to use stuff other then longjump.\n * \tThe default mode, without JPEG_ENCAP_EXTERNAL, implements the call encapsulators\n * \there, internally, with normal longjump.\n * SETJMP, LONGJMP, JMP_BUF: On some machines/environments a longjump equivalent is\n * \tconviniently available, but still it may be worthwhile to use _setjmp or sigsetjmp\n * \tin place of plain setjmp. These macros will make it easier. It is useless\n * \tto fiddle with these if you define JPEG_ENCAP_EXTERNAL.\n * OJPEG_BUFFER: Define the size of the desired buffer here. Should be small enough so as to guarantee\n * \tinstant processing, optimal streaming and optimal use of processor cache, but also big\n * \tenough so as to not result in significant call overhead. It should be at least a few\n * \tbytes to accomodate some structures (this is verified in asserts), but it would not be\n * \tsensible to make it this small anyway, and it should be at most 64K since it is indexed\n * \twith uint16. We recommend 2K.\n * EGYPTIANWALK: You could also define EGYPTIANWALK here, but it is not used anywhere and has\n * \tabsolutely no effect. That is why most people insist the EGYPTIANWALK is a bit silly.\n */\n\n/* #define LIBJPEG_ENCAP_EXTERNAL */\n#define SETJMP(jbuf) setjmp(jbuf)\n#define LONGJMP(jbuf,code) longjmp(jbuf,code)\n#define JMP_BUF jmp_buf\n#define OJPEG_BUFFER 2048\n/* define EGYPTIANWALK */\n\n#define JPEG_MARKER_SOF0 0xC0\n#define JPEG_MARKER_SOF1 0xC1\n#define JPEG_MARKER_SOF3 0xC3\n#define JPEG_MARKER_DHT 0xC4\n#define JPEG_MARKER_RST0 0XD0\n#define JPEG_MARKER_SOI 0xD8\n#define JPEG_MARKER_EOI 0xD9\n#define JPEG_MARKER_SOS 0xDA\n#define JPEG_MARKER_DQT 0xDB\n#define JPEG_MARKER_DRI 0xDD\n#define JPEG_MARKER_APP0 0xE0\n#define JPEG_MARKER_COM 0xFE\n\n#define FIELD_OJPEG_JPEGINTERCHANGEFORMAT (FIELD_CODEC+0)\n#define FIELD_OJPEG_JPEGINTERCHANGEFORMATLENGTH (FIELD_CODEC+1)\n#define FIELD_OJPEG_JPEGQTABLES (FIELD_CODEC+2)\n#define FIELD_OJPEG_JPEGDCTABLES (FIELD_CODEC+3)\n#define FIELD_OJPEG_JPEGACTABLES (FIELD_CODEC+4)\n#define FIELD_OJPEG_JPEGPROC (FIELD_CODEC+5)\n#define FIELD_OJPEG_JPEGRESTARTINTERVAL (FIELD_CODEC+6)\n#define FIELD_OJPEG_COUNT 7\n\nstatic const TIFFFieldInfo ojpeg_field_info[] = {\n\t{TIFFTAG_JPEGIFOFFSET,1,1,TIFF_LONG,FIELD_OJPEG_JPEGINTERCHANGEFORMAT,TRUE,FALSE,\"JpegInterchangeFormat\"},\n\t{TIFFTAG_JPEGIFBYTECOUNT,1,1,TIFF_LONG,FIELD_OJPEG_JPEGINTERCHANGEFORMATLENGTH,TRUE,FALSE,\"JpegInterchangeFormatLength\"},\n\t{TIFFTAG_JPEGQTABLES,TIFF_VARIABLE,TIFF_VARIABLE,TIFF_LONG,FIELD_OJPEG_JPEGQTABLES,FALSE,TRUE,\"JpegQTables\"},\n\t{TIFFTAG_JPEGDCTABLES,TIFF_VARIABLE,TIFF_VARIABLE,TIFF_LONG,FIELD_OJPEG_JPEGDCTABLES,FALSE,TRUE,\"JpegDcTables\"},\n\t{TIFFTAG_JPEGACTABLES,TIFF_VARIABLE,TIFF_VARIABLE,TIFF_LONG,FIELD_OJPEG_JPEGACTABLES,FALSE,TRUE,\"JpegAcTables\"},\n\t{TIFFTAG_JPEGPROC,1,1,TIFF_SHORT,FIELD_OJPEG_JPEGPROC,FALSE,FALSE,\"JpegProc\"},\n\t{TIFFTAG_JPEGRESTARTINTERVAL,1,1,TIFF_SHORT,FIELD_OJPEG_JPEGRESTARTINTERVAL,FALSE,FALSE,\"JpegRestartInterval\"},\n};\n\n#ifndef LIBJPEG_ENCAP_EXTERNAL\n#include <setjmp.h>\n#endif\n\n#include \"../jpeg/jpeglib.h\"\n#include \"../jpeg/jerror.h\"\n\ntypedef struct jpeg_error_mgr jpeg_error_mgr;\ntypedef struct jpeg_common_struct jpeg_common_struct;\ntypedef struct jpeg_decompress_struct jpeg_decompress_struct;\ntypedef struct jpeg_source_mgr jpeg_source_mgr;\n\ntypedef enum {\n\tosibsNotSetYet,\n\tosibsJpegInterchangeFormat,\n\tosibsStrile,\n\tosibsEof\n} OJPEGStateInBufferSource;\n\ntypedef enum {\n\tososSoi,\n\tososQTable0,ososQTable1,ososQTable2,ososQTable3,\n\tososDcTable0,ososDcTable1,ososDcTable2,ososDcTable3,\n\tososAcTable0,ososAcTable1,ososAcTable2,ososAcTable3,\n\tososDri,\n\tososSof,\n\tososSos,\n\tososCompressed,\n\tososRst,\n\tososEoi\n} OJPEGStateOutState;\n\ntypedef struct {\n\tTIFF* tif;\n\t#ifndef LIBJPEG_ENCAP_EXTERNAL\n\tJMP_BUF exit_jmpbuf;\n\t#endif\n\tTIFFVGetMethod vgetparent;\n\tTIFFVSetMethod vsetparent;\n\ttoff_t file_size;\n\tuint32 image_width;\n\tuint32 image_length;\n\tuint32 strile_width;\n\tuint32 strile_length;\n\tuint32 strile_length_total;\n\tuint8 samples_per_pixel;\n\tuint8 plane_sample_offset;\n\tuint8 samples_per_pixel_per_plane;\n\ttoff_t jpeg_interchange_format;\n\ttoff_t jpeg_interchange_format_length;\n\tuint8 jpeg_proc;\n\tuint8 subsamplingcorrect;\n\tuint8 subsamplingcorrect_done;\n\tuint8 subsampling_tag;\n\tuint8 subsampling_hor;\n\tuint8 subsampling_ver;\n\tuint8 subsampling_force_desubsampling_inside_decompression;\n\tuint8 qtable_offset_count;\n\tuint8 dctable_offset_count;\n\tuint8 actable_offset_count;\n\ttoff_t qtable_offset[3];\n\ttoff_t dctable_offset[3];\n\ttoff_t actable_offset[3];\n\tuint8* qtable[4];\n\tuint8* dctable[4];\n\tuint8* actable[4];\n\tuint16 restart_interval;\n\tuint8 restart_index;\n\tuint8 sof_log;\n\tuint8 sof_marker_id;\n\tuint32 sof_x;\n\tuint32 sof_y;\n\tuint8 sof_c[3];\n\tuint8 sof_hv[3];\n\tuint8 sof_tq[3];\n\tuint8 sos_cs[3];\n\tuint8 sos_tda[3];\n\tstruct {\n\t\tuint8 log;\n\t\tOJPEGStateInBufferSource in_buffer_source;\n\t\ttstrile_t in_buffer_next_strile;\n\t\ttoff_t in_buffer_file_pos;\n\t\ttoff_t in_buffer_file_togo;\n\t} sos_end[3];\n\tuint8 readheader_done;\n\tuint8 writeheader_done;\n\ttsample_t write_cursample;\n\ttstrile_t write_curstrile;\n\tuint8 libjpeg_session_active;\n\tuint8 libjpeg_jpeg_query_style;\n\tjpeg_error_mgr libjpeg_jpeg_error_mgr;\n\tjpeg_decompress_struct libjpeg_jpeg_decompress_struct;\n\tjpeg_source_mgr libjpeg_jpeg_source_mgr;\n\tuint8 subsampling_convert_log;\n\tuint32 subsampling_convert_ylinelen;\n\tuint32 subsampling_convert_ylines;\n\tuint32 subsampling_convert_clinelen;\n\tuint32 subsampling_convert_clines;\n\tuint32 subsampling_convert_ybuflen;\n\tuint32 subsampling_convert_cbuflen;\n\tuint32 subsampling_convert_ycbcrbuflen;\n\tuint8* subsampling_convert_ycbcrbuf;\n\tuint8* subsampling_convert_ybuf;\n\tuint8* subsampling_convert_cbbuf;\n\tuint8* subsampling_convert_crbuf;\n\tuint32 subsampling_convert_ycbcrimagelen;\n\tuint8** subsampling_convert_ycbcrimage;\n\tuint32 subsampling_convert_clinelenout;\n\tuint32 subsampling_convert_state;\n\tuint32 bytes_per_line;   /* if the codec outputs subsampled data, a 'line' in bytes_per_line */\n\tuint32 lines_per_strile; /* and lines_per_strile means subsampling_ver desubsampled rows     */\n\tOJPEGStateInBufferSource in_buffer_source;\n\ttstrile_t in_buffer_next_strile;\n\ttstrile_t in_buffer_strile_count;\n\ttoff_t in_buffer_file_pos;\n\tuint8 in_buffer_file_pos_log;\n\ttoff_t in_buffer_file_togo;\n\tuint16 in_buffer_togo;\n\tuint8* in_buffer_cur;\n\tuint8 in_buffer[OJPEG_BUFFER];\n\tOJPEGStateOutState out_state;\n\tuint8 out_buffer[OJPEG_BUFFER];\n\tuint8* skip_buffer;\n} OJPEGState;\n\nstatic int OJPEGVGetField(TIFF* tif, ttag_t tag, va_list ap);\nstatic int OJPEGVSetField(TIFF* tif, ttag_t tag, va_list ap);\nstatic void OJPEGPrintDir(TIFF* tif, FILE* fd, long flags);\n\nstatic int OJPEGSetupDecode(TIFF* tif);\nstatic int OJPEGPreDecode(TIFF* tif, tsample_t s);\nstatic int OJPEGPreDecodeSkipRaw(TIFF* tif);\nstatic int OJPEGPreDecodeSkipScanlines(TIFF* tif);\nstatic int OJPEGDecode(TIFF* tif, tidata_t buf, tsize_t cc, tsample_t s);\nstatic int OJPEGDecodeRaw(TIFF* tif, tidata_t buf, tsize_t cc);\nstatic int OJPEGDecodeScanlines(TIFF* tif, tidata_t buf, tsize_t cc);\nstatic void OJPEGPostDecode(TIFF* tif, tidata_t buf, tsize_t cc);\nstatic int OJPEGSetupEncode(TIFF* tif);\nstatic int OJPEGPreEncode(TIFF* tif, tsample_t s);\nstatic int OJPEGEncode(TIFF* tif, tidata_t buf, tsize_t cc, tsample_t s);\nstatic int OJPEGPostEncode(TIFF* tif);\nstatic void OJPEGCleanup(TIFF* tif);\n\nstatic void OJPEGSubsamplingCorrect(TIFF* tif);\nstatic int OJPEGReadHeaderInfo(TIFF* tif);\nstatic int OJPEGReadSecondarySos(TIFF* tif, tsample_t s);\nstatic int OJPEGWriteHeaderInfo(TIFF* tif);\nstatic void OJPEGLibjpegSessionAbort(TIFF* tif);\n\nstatic int OJPEGReadHeaderInfoSec(TIFF* tif);\nstatic int OJPEGReadHeaderInfoSecStreamDri(TIFF* tif);\nstatic int OJPEGReadHeaderInfoSecStreamDqt(TIFF* tif);\nstatic int OJPEGReadHeaderInfoSecStreamDht(TIFF* tif);\nstatic int OJPEGReadHeaderInfoSecStreamSof(TIFF* tif, uint8 marker_id);\nstatic int OJPEGReadHeaderInfoSecStreamSos(TIFF* tif);\nstatic int OJPEGReadHeaderInfoSecTablesQTable(TIFF* tif);\nstatic int OJPEGReadHeaderInfoSecTablesDcTable(TIFF* tif);\nstatic int OJPEGReadHeaderInfoSecTablesAcTable(TIFF* tif);\n\nstatic int OJPEGReadBufferFill(OJPEGState* sp);\nstatic int OJPEGReadByte(OJPEGState* sp, uint8* byte);\nstatic int OJPEGReadBytePeek(OJPEGState* sp, uint8* byte);\nstatic void OJPEGReadByteAdvance(OJPEGState* sp);\nstatic int OJPEGReadWord(OJPEGState* sp, uint16* word);\nstatic int OJPEGReadBlock(OJPEGState* sp, uint16 len, void* mem);\nstatic void OJPEGReadSkip(OJPEGState* sp, uint16 len);\n\nstatic int OJPEGWriteStream(TIFF* tif, void** mem, uint32* len);\nstatic void OJPEGWriteStreamSoi(TIFF* tif, void** mem, uint32* len);\nstatic void OJPEGWriteStreamQTable(TIFF* tif, uint8 table_index, void** mem, uint32* len);\nstatic void OJPEGWriteStreamDcTable(TIFF* tif, uint8 table_index, void** mem, uint32* len);\nstatic void OJPEGWriteStreamAcTable(TIFF* tif, uint8 table_index, void** mem, uint32* len);\nstatic void OJPEGWriteStreamDri(TIFF* tif, void** mem, uint32* len);\nstatic void OJPEGWriteStreamSof(TIFF* tif, void** mem, uint32* len);\nstatic void OJPEGWriteStreamSos(TIFF* tif, void** mem, uint32* len);\nstatic int OJPEGWriteStreamCompressed(TIFF* tif, void** mem, uint32* len);\nstatic void OJPEGWriteStreamRst(TIFF* tif, void** mem, uint32* len);\nstatic void OJPEGWriteStreamEoi(TIFF* tif, void** mem, uint32* len);\n\n#ifdef LIBJPEG_ENCAP_EXTERNAL\nextern int jpeg_create_decompress_encap(OJPEGState* sp, jpeg_decompress_struct* cinfo);\nextern int jpeg_read_header_encap(OJPEGState* sp, jpeg_decompress_struct* cinfo, uint8 require_image);\nextern int jpeg_start_decompress_encap(OJPEGState* sp, jpeg_decompress_struct* cinfo);\nextern int jpeg_read_scanlines_encap(OJPEGState* sp, jpeg_decompress_struct* cinfo, void* scanlines, uint32 max_lines);\nextern int jpeg_read_raw_data_encap(OJPEGState* sp, jpeg_decompress_struct* cinfo, void* data, uint32 max_lines);\nextern void jpeg_encap_unwind(TIFF* tif);\n#else\nstatic int jpeg_create_decompress_encap(OJPEGState* sp, jpeg_decompress_struct* j);\nstatic int jpeg_read_header_encap(OJPEGState* sp, jpeg_decompress_struct* cinfo, uint8 require_image);\nstatic int jpeg_start_decompress_encap(OJPEGState* sp, jpeg_decompress_struct* cinfo);\nstatic int jpeg_read_scanlines_encap(OJPEGState* sp, jpeg_decompress_struct* cinfo, void* scanlines, uint32 max_lines);\nstatic int jpeg_read_raw_data_encap(OJPEGState* sp, jpeg_decompress_struct* cinfo, void* data, uint32 max_lines);\nstatic void jpeg_encap_unwind(TIFF* tif);\n#endif\n\nstatic void OJPEGLibjpegJpegErrorMgrOutputMessage(jpeg_common_struct* cinfo);\nstatic void OJPEGLibjpegJpegErrorMgrErrorExit(jpeg_common_struct* cinfo);\nstatic void OJPEGLibjpegJpegSourceMgrInitSource(jpeg_decompress_struct* cinfo);\nstatic boolean OJPEGLibjpegJpegSourceMgrFillInputBuffer(jpeg_decompress_struct* cinfo);\nstatic void OJPEGLibjpegJpegSourceMgrSkipInputData(jpeg_decompress_struct* cinfo, long num_bytes);\nstatic boolean OJPEGLibjpegJpegSourceMgrResyncToRestart(jpeg_decompress_struct* cinfo, int desired);\nstatic void OJPEGLibjpegJpegSourceMgrTermSource(jpeg_decompress_struct* cinfo);\n\nint\nTIFFInitOJPEG(TIFF* tif, int scheme)\n{\n\tstatic const char module[]=\"TIFFInitOJPEG\";\n\tOJPEGState* sp;\n\n\tassert(scheme==COMPRESSION_OJPEG);\n\n        /*\n\t * Merge codec-specific tag information.\n\t */\n\tif (!_TIFFMergeFieldInfo(tif,ojpeg_field_info,FIELD_OJPEG_COUNT)) {\n\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t     \"Merging Old JPEG codec-specific tags failed\");\n\t\treturn 0;\n\t}\n\n\t/* state block */\n\tsp=_TIFFmalloc(sizeof(OJPEGState));\n\tif (sp==NULL)\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata,module,\"No space for OJPEG state block\");\n\t\treturn(0);\n\t}\n\t_TIFFmemset(sp,0,sizeof(OJPEGState));\n\tsp->tif=tif;\n\tsp->jpeg_proc=1;\n\tsp->subsampling_hor=2;\n\tsp->subsampling_ver=2;\n\tTIFFSetField(tif,TIFFTAG_YCBCRSUBSAMPLING,2,2);\n\t/* tif codec methods */\n\ttif->tif_setupdecode=OJPEGSetupDecode;\n\ttif->tif_predecode=OJPEGPreDecode;\n\ttif->tif_postdecode=OJPEGPostDecode;\n\ttif->tif_decoderow=OJPEGDecode;\n\ttif->tif_decodestrip=OJPEGDecode;\n\ttif->tif_decodetile=OJPEGDecode;\n\ttif->tif_setupencode=OJPEGSetupEncode;\n\ttif->tif_preencode=OJPEGPreEncode;\n\ttif->tif_postencode=OJPEGPostEncode;\n\ttif->tif_encoderow=OJPEGEncode;\n\ttif->tif_encodestrip=OJPEGEncode;\n\ttif->tif_encodetile=OJPEGEncode;\n\ttif->tif_cleanup=OJPEGCleanup;\n\ttif->tif_data=(tidata_t)sp;\n\t/* tif tag methods */\n\tsp->vgetparent=tif->tif_tagmethods.vgetfield;\n\ttif->tif_tagmethods.vgetfield=OJPEGVGetField;\n\tsp->vsetparent=tif->tif_tagmethods.vsetfield;\n\ttif->tif_tagmethods.vsetfield=OJPEGVSetField;\n\ttif->tif_tagmethods.printdir=OJPEGPrintDir;\n\t/* Some OJPEG files don't have strip or tile offsets or bytecounts tags.\n\t   Some others do, but have totally meaningless or corrupt values\n\t   in these tags. In these cases, the JpegInterchangeFormat stream is\n\t   reliable. In any case, this decoder reads the compressed data itself,\n\t   from the most reliable locations, and we need to notify encapsulating\n\t   LibTiff not to read raw strips or tiles for us. */\n\ttif->tif_flags|=TIFF_NOREADRAW;\n\treturn(1);\n}\n\nstatic int\nOJPEGVGetField(TIFF* tif, ttag_t tag, va_list ap)\n{\n\tOJPEGState* sp=(OJPEGState*)tif->tif_data;\n\tswitch(tag)\n\t{\n\t\tcase TIFFTAG_JPEGIFOFFSET:\n\t\t\t*va_arg(ap,uint32*)=(uint32)sp->jpeg_interchange_format;\n\t\t\tbreak;\n\t\tcase TIFFTAG_JPEGIFBYTECOUNT:\n\t\t\t*va_arg(ap,uint32*)=(uint32)sp->jpeg_interchange_format_length;\n\t\t\tbreak;\n\t\tcase TIFFTAG_YCBCRSUBSAMPLING:\n\t\t\tif (sp->subsamplingcorrect_done==0)\n\t\t\t\tOJPEGSubsamplingCorrect(tif);\n\t\t\t*va_arg(ap,uint16*)=(uint16)sp->subsampling_hor;\n\t\t\t*va_arg(ap,uint16*)=(uint16)sp->subsampling_ver;\n\t\t\tbreak;\n\t\tcase TIFFTAG_JPEGQTABLES:\n\t\t\t*va_arg(ap,uint32*)=(uint32)sp->qtable_offset_count;\n\t\t\t*va_arg(ap,void**)=(void*)sp->qtable_offset;\n\t\t\tbreak;\n\t\tcase TIFFTAG_JPEGDCTABLES:\n\t\t\t*va_arg(ap,uint32*)=(uint32)sp->dctable_offset_count;\n\t\t\t*va_arg(ap,void**)=(void*)sp->dctable_offset;\n\t\t\tbreak;\n\t\tcase TIFFTAG_JPEGACTABLES:\n\t\t\t*va_arg(ap,uint32*)=(uint32)sp->actable_offset_count;\n\t\t\t*va_arg(ap,void**)=(void*)sp->actable_offset;\n\t\t\tbreak;\n\t\tcase TIFFTAG_JPEGPROC:\n\t\t\t*va_arg(ap,uint16*)=(uint16)sp->jpeg_proc;\n\t\t\tbreak;\n\t\tcase TIFFTAG_JPEGRESTARTINTERVAL:\n\t\t\t*va_arg(ap,uint16*)=sp->restart_interval;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn (*sp->vgetparent)(tif,tag,ap);\n\t}\n\treturn (1);\n}\n\nstatic int\nOJPEGVSetField(TIFF* tif, ttag_t tag, va_list ap)\n{\n\tstatic const char module[]=\"OJPEGVSetField\";\n\tOJPEGState* sp=(OJPEGState*)tif->tif_data;\n\tuint32 ma;\n\tuint32* mb;\n\tuint32 n;\n\tswitch(tag)\n\t{\n\t\tcase TIFFTAG_JPEGIFOFFSET:\n\t\t\tsp->jpeg_interchange_format=(toff_t)va_arg(ap,uint32);  \n\t\t\tbreak;\n\t\tcase TIFFTAG_JPEGIFBYTECOUNT:\n\t\t\tsp->jpeg_interchange_format_length=(toff_t)va_arg(ap,uint32);  \n\t\t\tbreak;\n\t\tcase TIFFTAG_YCBCRSUBSAMPLING:\n\t\t\tsp->subsampling_tag=1;\n\t\t\tsp->subsampling_hor=(uint8)va_arg(ap,int);\n\t\t\tsp->subsampling_ver=(uint8)va_arg(ap,int);\n\t\t\ttif->tif_dir.td_ycbcrsubsampling[0]=sp->subsampling_hor;\n\t\t\ttif->tif_dir.td_ycbcrsubsampling[1]=sp->subsampling_ver;\n\t\t\tbreak;\n\t\tcase TIFFTAG_JPEGQTABLES:\n\t\t\tma=va_arg(ap,uint32);\n\t\t\tif (ma!=0)\n\t\t\t{\n\t\t\t\tif (ma>3)\n\t\t\t\t{\n\t\t\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"JpegQTables tag has incorrect count\");\n\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t\tsp->qtable_offset_count=(uint8)ma;\n\t\t\t\tmb=va_arg(ap,uint32*);\n\t\t\t\tfor (n=0; n<ma; n++)\n\t\t\t\t\tsp->qtable_offset[n]=(toff_t)mb[n];\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFFTAG_JPEGDCTABLES:\n\t\t\tma=va_arg(ap,uint32);\n\t\t\tif (ma!=0)\n\t\t\t{\n\t\t\t\tif (ma>3)\n\t\t\t\t{\n\t\t\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"JpegDcTables tag has incorrect count\");\n\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t\tsp->dctable_offset_count=(uint8)ma;\n\t\t\t\tmb=va_arg(ap,uint32*);\n\t\t\t\tfor (n=0; n<ma; n++)\n\t\t\t\t\tsp->dctable_offset[n]=(toff_t)mb[n];\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFFTAG_JPEGACTABLES:\n\t\t\tma=va_arg(ap,uint32);\n\t\t\tif (ma!=0)\n\t\t\t{\n\t\t\t\tif (ma>3)\n\t\t\t\t{\n\t\t\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"JpegAcTables tag has incorrect count\");\n\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t\tsp->actable_offset_count=(uint8)ma;\n\t\t\t\tmb=va_arg(ap,uint32*);\n\t\t\t\tfor (n=0; n<ma; n++)\n\t\t\t\t\tsp->actable_offset[n]=(toff_t)mb[n];\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFFTAG_JPEGPROC:\n\t\t\tsp->jpeg_proc=(uint8)va_arg(ap,uint32);\n\t\t\tbreak;\n\t\tcase TIFFTAG_JPEGRESTARTINTERVAL:\n\t\t\tsp->restart_interval=(uint16)va_arg(ap,uint32);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn (*sp->vsetparent)(tif,tag,ap);\n\t}\n\tTIFFSetFieldBit(tif,_TIFFFieldWithTag(tif,tag)->field_bit);\n\ttif->tif_flags|=TIFF_DIRTYDIRECT;\n\treturn(1);\n}\n\nstatic void\nOJPEGPrintDir(TIFF* tif, FILE* fd, long flags)\n{\n\tOJPEGState* sp=(OJPEGState*)tif->tif_data;\n\tuint8 m;\n\t(void)flags;\n\tassert(sp!=NULL);\n\tif (TIFFFieldSet(tif,FIELD_OJPEG_JPEGINTERCHANGEFORMAT))\n\t\tfprintf(fd,\"  JpegInterchangeFormat: %lu\\n\",(unsigned long)sp->jpeg_interchange_format);\n\tif (TIFFFieldSet(tif,FIELD_OJPEG_JPEGINTERCHANGEFORMATLENGTH))\n\t\tfprintf(fd,\"  JpegInterchangeFormatLength: %lu\\n\",(unsigned long)sp->jpeg_interchange_format_length);\n\tif (TIFFFieldSet(tif,FIELD_OJPEG_JPEGQTABLES))\n\t{\n\t\tfprintf(fd,\"  JpegQTables:\");\n\t\tfor (m=0; m<sp->qtable_offset_count; m++)\n\t\t\tfprintf(fd,\" %lu\",(unsigned long)sp->qtable_offset[m]);\n\t\tfprintf(fd,\"\\n\");\n\t}\n\tif (TIFFFieldSet(tif,FIELD_OJPEG_JPEGDCTABLES))\n\t{\n\t\tfprintf(fd,\"  JpegDcTables:\");\n\t\tfor (m=0; m<sp->dctable_offset_count; m++)\n\t\t\tfprintf(fd,\" %lu\",(unsigned long)sp->dctable_offset[m]);\n\t\tfprintf(fd,\"\\n\");\n\t}\n\tif (TIFFFieldSet(tif,FIELD_OJPEG_JPEGACTABLES))\n\t{\n\t\tfprintf(fd,\"  JpegAcTables:\");\n\t\tfor (m=0; m<sp->actable_offset_count; m++)\n\t\t\tfprintf(fd,\" %lu\",(unsigned long)sp->actable_offset[m]);\n\t\tfprintf(fd,\"\\n\");\n\t}\n\tif (TIFFFieldSet(tif,FIELD_OJPEG_JPEGPROC))\n\t\tfprintf(fd,\"  JpegProc: %u\\n\",(unsigned int)sp->jpeg_proc);\n\tif (TIFFFieldSet(tif,FIELD_OJPEG_JPEGRESTARTINTERVAL))\n\t\tfprintf(fd,\"  JpegRestartInterval: %u\\n\",(unsigned int)sp->restart_interval);\n}\n\nstatic int\nOJPEGSetupDecode(TIFF* tif)\n{\n\tstatic const char module[]=\"OJPEGSetupDecode\";\n\tTIFFWarningExt(tif->tif_clientdata,module,\"Depreciated and troublesome old-style JPEG compression mode, please convert to new-style JPEG compression and notify vendor of writing software\");\n\treturn(1);\n}\n\nstatic int\nOJPEGPreDecode(TIFF* tif, tsample_t s)\n{\n\tOJPEGState* sp=(OJPEGState*)tif->tif_data;\n\ttstrile_t m;\n\tif (sp->subsamplingcorrect_done==0)\n\t\tOJPEGSubsamplingCorrect(tif);\n\tif (sp->readheader_done==0)\n\t{\n\t\tif (OJPEGReadHeaderInfo(tif)==0)\n\t\t\treturn(0);\n\t}\n\tif (sp->sos_end[s].log==0)\n\t{\n\t\tif (OJPEGReadSecondarySos(tif,s)==0)\n\t\t\treturn(0);\n\t}\n\tif isTiled(tif)\n\t\tm=(tstrile_t)tif->tif_curtile;\n\telse\n\t\tm=(tstrile_t)tif->tif_curstrip;\n\tif ((sp->writeheader_done!=0) && ((sp->write_cursample!=s) || (sp->write_curstrile>m)))\n\t{\n\t\tif (sp->libjpeg_session_active!=0)\n\t\t\tOJPEGLibjpegSessionAbort(tif);\n\t\tsp->writeheader_done=0;\n\t}\n\tif (sp->writeheader_done==0)\n\t{\n\t\tsp->plane_sample_offset=(uint8)s;\n\t\tsp->write_cursample=s;\n\t\tsp->write_curstrile=s*tif->tif_dir.td_stripsperimage;\n\t\tif ((sp->in_buffer_file_pos_log==0) ||\n\t\t    (sp->in_buffer_file_pos-sp->in_buffer_togo!=sp->sos_end[s].in_buffer_file_pos))\n\t\t{\n\t\t\tsp->in_buffer_source=sp->sos_end[s].in_buffer_source;\n\t\t\tsp->in_buffer_next_strile=sp->sos_end[s].in_buffer_next_strile;\n\t\t\tsp->in_buffer_file_pos=sp->sos_end[s].in_buffer_file_pos;\n\t\t\tsp->in_buffer_file_pos_log=0;\n\t\t\tsp->in_buffer_file_togo=sp->sos_end[s].in_buffer_file_togo;\n\t\t\tsp->in_buffer_togo=0;\n\t\t\tsp->in_buffer_cur=0;\n\t\t}\n\t\tif (OJPEGWriteHeaderInfo(tif)==0)\n\t\t\treturn(0);\n\t}\n\twhile (sp->write_curstrile<m)          \n\t{\n\t\tif (sp->libjpeg_jpeg_query_style==0)\n\t\t{\n\t\t\tif (OJPEGPreDecodeSkipRaw(tif)==0)\n\t\t\t\treturn(0);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (OJPEGPreDecodeSkipScanlines(tif)==0)\n\t\t\t\treturn(0);\n\t\t}\n\t\tsp->write_curstrile++;\n\t}\n\treturn(1);\n}\n\nstatic int\nOJPEGPreDecodeSkipRaw(TIFF* tif)\n{\n\tOJPEGState* sp=(OJPEGState*)tif->tif_data;\n\tuint32 m;\n\tm=sp->lines_per_strile;\n\tif (sp->subsampling_convert_state!=0)\n\t{\n\t\tif (sp->subsampling_convert_clines-sp->subsampling_convert_state>=m)\n\t\t{\n\t\t\tsp->subsampling_convert_state+=m;\n\t\t\tif (sp->subsampling_convert_state==sp->subsampling_convert_clines)\n\t\t\t\tsp->subsampling_convert_state=0;\n\t\t\treturn(1);\n\t\t}\n\t\tm-=sp->subsampling_convert_clines-sp->subsampling_convert_state;\n\t\tsp->subsampling_convert_state=0;\n\t}\n\twhile (m>=sp->subsampling_convert_clines)\n\t{\n\t\tif (jpeg_read_raw_data_encap(sp,&(sp->libjpeg_jpeg_decompress_struct),sp->subsampling_convert_ycbcrimage,sp->subsampling_ver*8)==0)\n\t\t\treturn(0);\n\t\tm-=sp->subsampling_convert_clines;\n\t}\n\tif (m>0)\n\t{\n\t\tif (jpeg_read_raw_data_encap(sp,&(sp->libjpeg_jpeg_decompress_struct),sp->subsampling_convert_ycbcrimage,sp->subsampling_ver*8)==0)\n\t\t\treturn(0);\n\t\tsp->subsampling_convert_state=m;\n\t}\n\treturn(1);\n}\n\nstatic int\nOJPEGPreDecodeSkipScanlines(TIFF* tif)\n{\n\tstatic const char module[]=\"OJPEGPreDecodeSkipScanlines\";\n\tOJPEGState* sp=(OJPEGState*)tif->tif_data;\n\tuint32 m;\n\tif (sp->skip_buffer==NULL)\n\t{\n\t\tsp->skip_buffer=_TIFFmalloc(sp->bytes_per_line);\n\t\tif (sp->skip_buffer==NULL)\n\t\t{\n\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Out of memory\");\n\t\t\treturn(0);\n\t\t}\n\t}\n\tfor (m=0; m<sp->lines_per_strile; m++)\n\t{\n\t\tif (jpeg_read_scanlines_encap(sp,&(sp->libjpeg_jpeg_decompress_struct),&sp->skip_buffer,1)==0)\n\t\t\treturn(0);\n\t}\n\treturn(1);\n}\n\nstatic int\nOJPEGDecode(TIFF* tif, tidata_t buf, tsize_t cc, tsample_t s)\n{\n\tOJPEGState* sp=(OJPEGState*)tif->tif_data;\n\t(void)s;\n\tif (sp->libjpeg_jpeg_query_style==0)\n\t{\n\t\tif (OJPEGDecodeRaw(tif,buf,cc)==0)\n\t\t\treturn(0);\n\t}\n\telse\n\t{\n\t\tif (OJPEGDecodeScanlines(tif,buf,cc)==0)\n\t\t\treturn(0);\n\t}\n\treturn(1);\n}\n\nstatic int\nOJPEGDecodeRaw(TIFF* tif, tidata_t buf, tsize_t cc)\n{\n\tstatic const char module[]=\"OJPEGDecodeRaw\";\n\tOJPEGState* sp=(OJPEGState*)tif->tif_data;\n\tuint8* m;\n\tuint32 n;\n\tuint8* oy;\n\tuint8* ocb;\n\tuint8* ocr;\n\tuint8* p;\n\tuint32 q;\n\tuint8* r;\n\tuint8 sx,sy;\n\tif (cc%sp->bytes_per_line!=0)\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Fractional scanline not read\");\n\t\treturn(0);\n\t}\n\tassert(cc>0);\n\tm=buf;\n\tn=cc;\n\tdo\n\t{\n\t\tif (sp->subsampling_convert_state==0)\n\t\t{\n\t\t\tif (jpeg_read_raw_data_encap(sp,&(sp->libjpeg_jpeg_decompress_struct),sp->subsampling_convert_ycbcrimage,sp->subsampling_ver*8)==0)\n\t\t\t\treturn(0);\n\t\t}\n\t\toy=sp->subsampling_convert_ybuf+sp->subsampling_convert_state*sp->subsampling_ver*sp->subsampling_convert_ylinelen;\n\t\tocb=sp->subsampling_convert_cbbuf+sp->subsampling_convert_state*sp->subsampling_convert_clinelen;\n\t\tocr=sp->subsampling_convert_crbuf+sp->subsampling_convert_state*sp->subsampling_convert_clinelen;\n\t\tp=m;\n\t\tfor (q=0; q<sp->subsampling_convert_clinelenout; q++)\n\t\t{\n\t\t\tr=oy;\n\t\t\tfor (sy=0; sy<sp->subsampling_ver; sy++)\n\t\t\t{\n\t\t\t\tfor (sx=0; sx<sp->subsampling_hor; sx++)\n\t\t\t\t\t*p++=*r++;\n\t\t\t\tr+=sp->subsampling_convert_ylinelen-sp->subsampling_hor;\n\t\t\t}\n\t\t\toy+=sp->subsampling_hor;\n\t\t\t*p++=*ocb++;\n\t\t\t*p++=*ocr++;\n\t\t}\n\t\tsp->subsampling_convert_state++;\n\t\tif (sp->subsampling_convert_state==sp->subsampling_convert_clines)\n\t\t\tsp->subsampling_convert_state=0;\n\t\tm+=sp->bytes_per_line;\n\t\tn-=sp->bytes_per_line;\n\t} while(n>0);\n\treturn(1);\n}\n\nstatic int\nOJPEGDecodeScanlines(TIFF* tif, tidata_t buf, tsize_t cc)\n{\n\tstatic const char module[]=\"OJPEGDecodeScanlines\";\n\tOJPEGState* sp=(OJPEGState*)tif->tif_data;\n\tuint8* m;\n\tuint32 n;\n\tif (cc%sp->bytes_per_line!=0)\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Fractional scanline not read\");\n\t\treturn(0);\n\t}\n\tassert(cc>0);\n\tm=buf;\n\tn=cc;\n\tdo\n\t{\n\t\tif (jpeg_read_scanlines_encap(sp,&(sp->libjpeg_jpeg_decompress_struct),&m,1)==0)\n\t\t\treturn(0);\n\t\tm+=sp->bytes_per_line;\n\t\tn-=sp->bytes_per_line;\n\t} while(n>0);\n\treturn(1);\n}\n\nstatic void\nOJPEGPostDecode(TIFF* tif, tidata_t buf, tsize_t cc)\n{\n\tOJPEGState* sp=(OJPEGState*)tif->tif_data;\n\t(void)buf;\n\t(void)cc;\n\tsp->write_curstrile++;\n\tif (sp->write_curstrile%tif->tif_dir.td_stripsperimage==0)\n\t{\n\t\tassert(sp->libjpeg_session_active!=0);\n\t\tOJPEGLibjpegSessionAbort(tif);\n\t\tsp->writeheader_done=0;\n\t}\n}\n\nstatic int\nOJPEGSetupEncode(TIFF* tif)\n{\n\tstatic const char module[]=\"OJPEGSetupEncode\";\n\tTIFFErrorExt(tif->tif_clientdata,module,\"OJPEG encoding not supported; use new-style JPEG compression instead\");\n\treturn(0);\n}\n\nstatic int\nOJPEGPreEncode(TIFF* tif, tsample_t s)\n{\n\tstatic const char module[]=\"OJPEGPreEncode\";\n\t(void)s;\n\tTIFFErrorExt(tif->tif_clientdata,module,\"OJPEG encoding not supported; use new-style JPEG compression instead\");\n\treturn(0);\n}\n\nstatic int\nOJPEGEncode(TIFF* tif, tidata_t buf, tsize_t cc, tsample_t s)\n{\n\tstatic const char module[]=\"OJPEGEncode\";\n\t(void)buf;\n\t(void)cc;\n\t(void)s;\n\tTIFFErrorExt(tif->tif_clientdata,module,\"OJPEG encoding not supported; use new-style JPEG compression instead\");\n\treturn(0);\n}\n\nstatic int\nOJPEGPostEncode(TIFF* tif)\n{\n\tstatic const char module[]=\"OJPEGPostEncode\";\n\tTIFFErrorExt(tif->tif_clientdata,module,\"OJPEG encoding not supported; use new-style JPEG compression instead\");\n\treturn(0);\n}\n\nstatic void\nOJPEGCleanup(TIFF* tif)\n{\n\tOJPEGState* sp=(OJPEGState*)tif->tif_data;\n\tif (sp!=0)\n\t{\n\t\ttif->tif_tagmethods.vgetfield=sp->vgetparent;\n\t\ttif->tif_tagmethods.vsetfield=sp->vsetparent;\n\t\tif (sp->qtable[0]!=0)\n\t\t\t_TIFFfree(sp->qtable[0]);\n\t\tif (sp->qtable[1]!=0)\n\t\t\t_TIFFfree(sp->qtable[1]);\n\t\tif (sp->qtable[2]!=0)\n\t\t\t_TIFFfree(sp->qtable[2]);\n\t\tif (sp->qtable[3]!=0)\n\t\t\t_TIFFfree(sp->qtable[3]);\n\t\tif (sp->dctable[0]!=0)\n\t\t\t_TIFFfree(sp->dctable[0]);\n\t\tif (sp->dctable[1]!=0)\n\t\t\t_TIFFfree(sp->dctable[1]);\n\t\tif (sp->dctable[2]!=0)\n\t\t\t_TIFFfree(sp->dctable[2]);\n\t\tif (sp->dctable[3]!=0)\n\t\t\t_TIFFfree(sp->dctable[3]);\n\t\tif (sp->actable[0]!=0)\n\t\t\t_TIFFfree(sp->actable[0]);\n\t\tif (sp->actable[1]!=0)\n\t\t\t_TIFFfree(sp->actable[1]);\n\t\tif (sp->actable[2]!=0)\n\t\t\t_TIFFfree(sp->actable[2]);\n\t\tif (sp->actable[3]!=0)\n\t\t\t_TIFFfree(sp->actable[3]);\n\t\tif (sp->libjpeg_session_active!=0)\n\t\t\tOJPEGLibjpegSessionAbort(tif);\n\t\tif (sp->subsampling_convert_ycbcrbuf!=0)\n\t\t\t_TIFFfree(sp->subsampling_convert_ycbcrbuf);\n\t\tif (sp->subsampling_convert_ycbcrimage!=0)\n\t\t\t_TIFFfree(sp->subsampling_convert_ycbcrimage);\n\t\tif (sp->skip_buffer!=0)\n\t\t\t_TIFFfree(sp->skip_buffer);\n\t\t_TIFFfree(sp);\n\t\ttif->tif_data=NULL;\n\t\t_TIFFSetDefaultCompressionState(tif);\n\t}\n}\n\nstatic void\nOJPEGSubsamplingCorrect(TIFF* tif)\n{\n\tstatic const char module[]=\"OJPEGSubsamplingCorrect\";\n\tOJPEGState* sp=(OJPEGState*)tif->tif_data;\n\tuint8 mh;\n\tuint8 mv;\n\tassert(sp->subsamplingcorrect_done==0);\n\tif ((tif->tif_dir.td_samplesperpixel!=3) || ((tif->tif_dir.td_photometric!=PHOTOMETRIC_YCBCR) &&\n\t    (tif->tif_dir.td_photometric!=PHOTOMETRIC_ITULAB)))\n\t{\n\t\tif (sp->subsampling_tag!=0)\n\t\t\tTIFFWarningExt(tif->tif_clientdata,module,\"Subsampling tag not appropriate for this Photometric and/or SamplesPerPixel\");\n\t\tsp->subsampling_hor=1;\n\t\tsp->subsampling_ver=1;\n\t\tsp->subsampling_force_desubsampling_inside_decompression=0;\n\t}\n\telse\n\t{\n\t\tsp->subsamplingcorrect_done=1;\n\t\tmh=sp->subsampling_hor;\n\t\tmv=sp->subsampling_ver;\n\t\tsp->subsamplingcorrect=1;\n\t\tOJPEGReadHeaderInfoSec(tif);\n\t\tif (sp->subsampling_force_desubsampling_inside_decompression!=0)\n\t\t{\n\t\t\tsp->subsampling_hor=1;\n\t\t\tsp->subsampling_ver=1;\n\t\t}\n\t\tsp->subsamplingcorrect=0;\n\t\tif (((sp->subsampling_hor!=mh) || (sp->subsampling_ver!=mv)) && (sp->subsampling_force_desubsampling_inside_decompression==0))\n\t\t{\n\t\t\tif (sp->subsampling_tag==0)\n\t\t\t\tTIFFWarningExt(tif->tif_clientdata,module,\"Subsampling tag is not set, yet subsampling inside JPEG data [%d,%d] does not match default values [2,2]; assuming subsampling inside JPEG data is correct\",sp->subsampling_hor,sp->subsampling_ver);\n\t\t\telse\n\t\t\t\tTIFFWarningExt(tif->tif_clientdata,module,\"Subsampling inside JPEG data [%d,%d] does not match subsampling tag values [%d,%d]; assuming subsampling inside JPEG data is correct\",sp->subsampling_hor,sp->subsampling_ver,mh,mv);\n\t\t}\n\t\tif (sp->subsampling_force_desubsampling_inside_decompression!=0)\n\t\t{\n\t\t\tif (sp->subsampling_tag==0)\n\t\t\t\tTIFFWarningExt(tif->tif_clientdata,module,\"Subsampling tag is not set, yet subsampling inside JPEG data does not match default values [2,2] (nor any other values allowed in TIFF); assuming subsampling inside JPEG data is correct and desubsampling inside JPEG decompression\");\n\t\t\telse\n\t\t\t\tTIFFWarningExt(tif->tif_clientdata,module,\"Subsampling inside JPEG data does not match subsampling tag values [%d,%d] (nor any other values allowed in TIFF); assuming subsampling inside JPEG data is correct and desubsampling inside JPEG decompression\",mh,mv);\n\t\t}\n\t\tif (sp->subsampling_force_desubsampling_inside_decompression==0)\n\t\t{\n\t\t\tif (sp->subsampling_hor<sp->subsampling_ver)\n\t\t\t\tTIFFWarningExt(tif->tif_clientdata,module,\"Subsampling values [%d,%d] are not allowed in TIFF\",sp->subsampling_hor,sp->subsampling_ver);\n\t\t}\n\t}\n\tsp->subsamplingcorrect_done=1;\n}\n\nstatic int\nOJPEGReadHeaderInfo(TIFF* tif)\n{\n\tstatic const char module[]=\"OJPEGReadHeaderInfo\";\n\tOJPEGState* sp=(OJPEGState*)tif->tif_data;\n\tassert(sp->readheader_done==0);\n\tsp->image_width=tif->tif_dir.td_imagewidth;\n\tsp->image_length=tif->tif_dir.td_imagelength;\n\tif isTiled(tif)\n\t{\n\t\tsp->strile_width=tif->tif_dir.td_tilewidth;\n\t\tsp->strile_length=tif->tif_dir.td_tilelength;\n\t\tsp->strile_length_total=((sp->image_length+sp->strile_length-1)/sp->strile_length)*sp->strile_length;\n\t}\n\telse\n\t{\n\t\tsp->strile_width=sp->image_width;\n\t\tsp->strile_length=tif->tif_dir.td_rowsperstrip;\n\t\tsp->strile_length_total=sp->image_length;\n\t}\n\tsp->samples_per_pixel=(uint8)tif->tif_dir.td_samplesperpixel;\n\tif (sp->samples_per_pixel==1)\n\t{\n\t\tsp->plane_sample_offset=0;\n\t\tsp->samples_per_pixel_per_plane=sp->samples_per_pixel;\n\t\tsp->subsampling_hor=1;\n\t\tsp->subsampling_ver=1;\n\t}\n\telse\n\t{\n\t\tif (sp->samples_per_pixel!=3)\n\t\t{\n\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"SamplesPerPixel %d not supported for this compression scheme\",sp->samples_per_pixel);\n\t\t\treturn(0);\n\t\t}\n\t\tsp->plane_sample_offset=0;\n\t\tif (tif->tif_dir.td_planarconfig==PLANARCONFIG_CONTIG)\n\t\t\tsp->samples_per_pixel_per_plane=3;\n\t\telse\n\t\t\tsp->samples_per_pixel_per_plane=1;\n\t}\n\tif (sp->strile_length<sp->image_length)\n\t{\n\t\tif (sp->strile_length%(sp->subsampling_ver*8)!=0)\n\t\t{\n\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Incompatible vertical subsampling and image strip/tile length\");\n\t\t\treturn(0);\n\t\t}\n\t\tsp->restart_interval=((sp->strile_width+sp->subsampling_hor*8-1)/(sp->subsampling_hor*8))*(sp->strile_length/(sp->subsampling_ver*8));\n\t}\n\tif (OJPEGReadHeaderInfoSec(tif)==0)\n\t\treturn(0);\n\tsp->sos_end[0].log=1;\n\tsp->sos_end[0].in_buffer_source=sp->in_buffer_source;\n\tsp->sos_end[0].in_buffer_next_strile=sp->in_buffer_next_strile;\n\tsp->sos_end[0].in_buffer_file_pos=sp->in_buffer_file_pos-sp->in_buffer_togo;\n\tsp->sos_end[0].in_buffer_file_togo=sp->in_buffer_file_togo+sp->in_buffer_togo;\n\tsp->readheader_done=1;\n\treturn(1);\n}\n\nstatic int\nOJPEGReadSecondarySos(TIFF* tif, tsample_t s)\n{\n\tOJPEGState* sp=(OJPEGState*)tif->tif_data;\n\tuint8 m;\n\tassert(s>0);\n\tassert(s<3);\n\tassert(sp->sos_end[0].log!=0);\n\tassert(sp->sos_end[s].log==0);\n\tsp->plane_sample_offset=s-1;\n\twhile(sp->sos_end[sp->plane_sample_offset].log==0)\n\t\tsp->plane_sample_offset--;\n\tsp->in_buffer_source=sp->sos_end[sp->plane_sample_offset].in_buffer_source;\n\tsp->in_buffer_next_strile=sp->sos_end[sp->plane_sample_offset].in_buffer_next_strile;\n\tsp->in_buffer_file_pos=sp->sos_end[sp->plane_sample_offset].in_buffer_file_pos;  \n\tsp->in_buffer_file_pos_log=0;\n\tsp->in_buffer_file_togo=sp->sos_end[sp->plane_sample_offset].in_buffer_file_togo;\n\tsp->in_buffer_togo=0;\n\tsp->in_buffer_cur=0;\n\twhile(sp->plane_sample_offset<s)\n\t{\n\t\tdo\n\t\t{\n\t\t\tif (OJPEGReadByte(sp,&m)==0)\n\t\t\t\treturn(0);\n\t\t\tif (m==255)\n\t\t\t{\n\t\t\t\tdo\n\t\t\t\t{\n\t\t\t\t\tif (OJPEGReadByte(sp,&m)==0)\n\t\t\t\t\t\treturn(0);\n\t\t\t\t\tif (m!=255)\n\t\t\t\t\t\tbreak;\n\t\t\t\t} while(1);\n\t\t\t\tif (m==JPEG_MARKER_SOS)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t} while(1);\n\t\tsp->plane_sample_offset++;\n\t\tif (OJPEGReadHeaderInfoSecStreamSos(tif)==0)\n\t\t\treturn(0);\n\t\tsp->sos_end[sp->plane_sample_offset].log=1;\n\t\tsp->sos_end[sp->plane_sample_offset].in_buffer_source=sp->in_buffer_source;\n\t\tsp->sos_end[sp->plane_sample_offset].in_buffer_next_strile=sp->in_buffer_next_strile;\n\t\tsp->sos_end[sp->plane_sample_offset].in_buffer_file_pos=sp->in_buffer_file_pos-sp->in_buffer_togo;\n\t\tsp->sos_end[sp->plane_sample_offset].in_buffer_file_togo=sp->in_buffer_file_togo+sp->in_buffer_togo;\n\t}\n\treturn(1);\n}\n\nstatic int\nOJPEGWriteHeaderInfo(TIFF* tif)\n{\n\tstatic const char module[]=\"OJPEGWriteHeaderInfo\";\n\tOJPEGState* sp=(OJPEGState*)tif->tif_data;\n\tuint8** m;\n\tuint32 n;\n\tassert(sp->libjpeg_session_active==0);\n\tsp->out_state=ososSoi;\n\tsp->restart_index=0;\n\tjpeg_std_error(&(sp->libjpeg_jpeg_error_mgr));\n\tsp->libjpeg_jpeg_error_mgr.output_message=OJPEGLibjpegJpegErrorMgrOutputMessage;\n\tsp->libjpeg_jpeg_error_mgr.error_exit=OJPEGLibjpegJpegErrorMgrErrorExit;\n\tsp->libjpeg_jpeg_decompress_struct.err=&(sp->libjpeg_jpeg_error_mgr);\n\tsp->libjpeg_jpeg_decompress_struct.client_data=(void*)tif;\n\tif (jpeg_create_decompress_encap(sp,&(sp->libjpeg_jpeg_decompress_struct))==0)\n\t\treturn(0);\n\tsp->libjpeg_session_active=1;\n\tsp->libjpeg_jpeg_source_mgr.bytes_in_buffer=0;\n\tsp->libjpeg_jpeg_source_mgr.init_source=OJPEGLibjpegJpegSourceMgrInitSource;\n\tsp->libjpeg_jpeg_source_mgr.fill_input_buffer=OJPEGLibjpegJpegSourceMgrFillInputBuffer;\n\tsp->libjpeg_jpeg_source_mgr.skip_input_data=OJPEGLibjpegJpegSourceMgrSkipInputData;\n\tsp->libjpeg_jpeg_source_mgr.resync_to_restart=OJPEGLibjpegJpegSourceMgrResyncToRestart;\n\tsp->libjpeg_jpeg_source_mgr.term_source=OJPEGLibjpegJpegSourceMgrTermSource;\n\tsp->libjpeg_jpeg_decompress_struct.src=&(sp->libjpeg_jpeg_source_mgr);\n\tif (jpeg_read_header_encap(sp,&(sp->libjpeg_jpeg_decompress_struct),1)==0)\n\t\treturn(0);\n\tif ((sp->subsampling_force_desubsampling_inside_decompression==0) && (sp->samples_per_pixel_per_plane>1))\n\t{\n\t\tsp->libjpeg_jpeg_decompress_struct.raw_data_out=1;\n#if JPEG_LIB_VERSION >= 70\n\t\tsp->libjpeg_jpeg_decompress_struct.do_fancy_upsampling=FALSE;\n#endif\n\t\tsp->libjpeg_jpeg_query_style=0;\n\t\tif (sp->subsampling_convert_log==0)\n\t\t{\n\t\t\tassert(sp->subsampling_convert_ycbcrbuf==0);\n\t\t\tassert(sp->subsampling_convert_ycbcrimage==0);\n\t\t\tsp->subsampling_convert_ylinelen=((sp->strile_width+sp->subsampling_hor*8-1)/(sp->subsampling_hor*8)*sp->subsampling_hor*8);\n\t\t\tsp->subsampling_convert_ylines=sp->subsampling_ver*8;\n\t\t\tsp->subsampling_convert_clinelen=sp->subsampling_convert_ylinelen/sp->subsampling_hor;\n\t\t\tsp->subsampling_convert_clines=8;\n\t\t\tsp->subsampling_convert_ybuflen=sp->subsampling_convert_ylinelen*sp->subsampling_convert_ylines;\n\t\t\tsp->subsampling_convert_cbuflen=sp->subsampling_convert_clinelen*sp->subsampling_convert_clines;\n\t\t\tsp->subsampling_convert_ycbcrbuflen=sp->subsampling_convert_ybuflen+2*sp->subsampling_convert_cbuflen;\n\t\t\tsp->subsampling_convert_ycbcrbuf=_TIFFmalloc(sp->subsampling_convert_ycbcrbuflen);\n\t\t\tif (sp->subsampling_convert_ycbcrbuf==0)\n\t\t\t{\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Out of memory\");\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tsp->subsampling_convert_ybuf=sp->subsampling_convert_ycbcrbuf;\n\t\t\tsp->subsampling_convert_cbbuf=sp->subsampling_convert_ybuf+sp->subsampling_convert_ybuflen;\n\t\t\tsp->subsampling_convert_crbuf=sp->subsampling_convert_cbbuf+sp->subsampling_convert_cbuflen;\n\t\t\tsp->subsampling_convert_ycbcrimagelen=3+sp->subsampling_convert_ylines+2*sp->subsampling_convert_clines;\n\t\t\tsp->subsampling_convert_ycbcrimage=_TIFFmalloc(sp->subsampling_convert_ycbcrimagelen*sizeof(uint8*));\n\t\t\tif (sp->subsampling_convert_ycbcrimage==0)\n\t\t\t{\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Out of memory\");\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tm=sp->subsampling_convert_ycbcrimage;\n\t\t\t*m++=(uint8*)(sp->subsampling_convert_ycbcrimage+3);\n\t\t\t*m++=(uint8*)(sp->subsampling_convert_ycbcrimage+3+sp->subsampling_convert_ylines);\n\t\t\t*m++=(uint8*)(sp->subsampling_convert_ycbcrimage+3+sp->subsampling_convert_ylines+sp->subsampling_convert_clines);\n\t\t\tfor (n=0; n<sp->subsampling_convert_ylines; n++)\n\t\t\t\t*m++=sp->subsampling_convert_ybuf+n*sp->subsampling_convert_ylinelen;\n\t\t\tfor (n=0; n<sp->subsampling_convert_clines; n++)\n\t\t\t\t*m++=sp->subsampling_convert_cbbuf+n*sp->subsampling_convert_clinelen;\n\t\t\tfor (n=0; n<sp->subsampling_convert_clines; n++)\n\t\t\t\t*m++=sp->subsampling_convert_crbuf+n*sp->subsampling_convert_clinelen;\n\t\t\tsp->subsampling_convert_clinelenout=((sp->strile_width+sp->subsampling_hor-1)/sp->subsampling_hor);\n\t\t\tsp->subsampling_convert_state=0;\n\t\t\tsp->bytes_per_line=sp->subsampling_convert_clinelenout*(sp->subsampling_ver*sp->subsampling_hor+2);\n\t\t\tsp->lines_per_strile=((sp->strile_length+sp->subsampling_ver-1)/sp->subsampling_ver);\n\t\t\tsp->subsampling_convert_log=1;\n\t\t}\n\t}\n\telse\n\t{\n\t\tsp->libjpeg_jpeg_decompress_struct.jpeg_color_space=JCS_UNKNOWN;\n\t\tsp->libjpeg_jpeg_decompress_struct.out_color_space=JCS_UNKNOWN;\n\t\tsp->libjpeg_jpeg_query_style=1;\n\t\tsp->bytes_per_line=sp->samples_per_pixel_per_plane*sp->strile_width;\n\t\tsp->lines_per_strile=sp->strile_length;\n\t}\n\tif (jpeg_start_decompress_encap(sp,&(sp->libjpeg_jpeg_decompress_struct))==0)\n\t\treturn(0);\n\tsp->writeheader_done=1;\n\treturn(1);\n}\n\nstatic void\nOJPEGLibjpegSessionAbort(TIFF* tif)\n{\n\tOJPEGState* sp=(OJPEGState*)tif->tif_data;\n\tassert(sp->libjpeg_session_active!=0);\n\tjpeg_destroy((jpeg_common_struct*)(&(sp->libjpeg_jpeg_decompress_struct)));\n\tsp->libjpeg_session_active=0;\n}\n\nstatic int\nOJPEGReadHeaderInfoSec(TIFF* tif)\n{\n\tstatic const char module[]=\"OJPEGReadHeaderInfoSec\";\n\tOJPEGState* sp=(OJPEGState*)tif->tif_data;\n\tuint8 m;\n\tuint16 n;\n\tuint8 o;\n\tif (sp->file_size==0)\n\t\tsp->file_size=TIFFGetFileSize(tif);\n\tif (sp->jpeg_interchange_format!=0)\n\t{\n\t\tif (sp->jpeg_interchange_format>=sp->file_size)\n\t\t{\n\t\t\tsp->jpeg_interchange_format=0;\n\t\t\tsp->jpeg_interchange_format_length=0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif ((sp->jpeg_interchange_format_length==0) || (sp->jpeg_interchange_format+sp->jpeg_interchange_format_length>sp->file_size))\n\t\t\t\tsp->jpeg_interchange_format_length=sp->file_size-sp->jpeg_interchange_format;\n\t\t}\n\t}\n\tsp->in_buffer_source=osibsNotSetYet;\n\tsp->in_buffer_next_strile=0;\n\tsp->in_buffer_strile_count=tif->tif_dir.td_nstrips;   \n\tsp->in_buffer_file_togo=0;\n\tsp->in_buffer_togo=0;\n\tdo\n\t{\n\t\tif (OJPEGReadBytePeek(sp,&m)==0)\n\t\t\treturn(0);\n\t\tif (m!=255)\n\t\t\tbreak;\n\t\tOJPEGReadByteAdvance(sp);\n\t\tdo\n\t\t{\n\t\t\tif (OJPEGReadByte(sp,&m)==0)\n\t\t\t\treturn(0);\n\t\t} while(m==255);\n\t\tswitch(m)\n\t\t{\n\t\t\tcase JPEG_MARKER_SOI:\n\t\t\t\t/* this type of marker has no data, and should be skipped */\n\t\t\t\tbreak;\n\t\t\tcase JPEG_MARKER_COM:\n\t\t\tcase JPEG_MARKER_APP0:\n\t\t\tcase JPEG_MARKER_APP0+1:\n\t\t\tcase JPEG_MARKER_APP0+2:\n\t\t\tcase JPEG_MARKER_APP0+3:\n\t\t\tcase JPEG_MARKER_APP0+4:\n\t\t\tcase JPEG_MARKER_APP0+5:\n\t\t\tcase JPEG_MARKER_APP0+6:\n\t\t\tcase JPEG_MARKER_APP0+7:\n\t\t\tcase JPEG_MARKER_APP0+8:\n\t\t\tcase JPEG_MARKER_APP0+9:\n\t\t\tcase JPEG_MARKER_APP0+10:\n\t\t\tcase JPEG_MARKER_APP0+11:\n\t\t\tcase JPEG_MARKER_APP0+12:\n\t\t\tcase JPEG_MARKER_APP0+13:\n\t\t\tcase JPEG_MARKER_APP0+14:\n\t\t\tcase JPEG_MARKER_APP0+15:\n\t\t\t\t/* this type of marker has data, but it has no use to us (and no place here) and should be skipped */\n\t\t\t\tif (OJPEGReadWord(sp,&n)==0)\n\t\t\t\t\treturn(0);\n\t\t\t\tif (n<2)\n\t\t\t\t{\n\t\t\t\t\tif (sp->subsamplingcorrect==0)\n\t\t\t\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Corrupt JPEG data\");\n\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t\tif (n>2)\n\t\t\t\t\tOJPEGReadSkip(sp,(uint16)(n-2));\n\t\t\t\tbreak;\n\t\t\tcase JPEG_MARKER_DRI:\n\t\t\t\tif (OJPEGReadHeaderInfoSecStreamDri(tif)==0)\n\t\t\t\t\treturn(0);\n\t\t\t\tbreak;\n\t\t\tcase JPEG_MARKER_DQT:\n\t\t\t\tif (OJPEGReadHeaderInfoSecStreamDqt(tif)==0)\n\t\t\t\t\treturn(0);\n\t\t\t\tbreak;\n\t\t\tcase JPEG_MARKER_DHT:\n\t\t\t\tif (OJPEGReadHeaderInfoSecStreamDht(tif)==0)\n\t\t\t\t\treturn(0);\n\t\t\t\tbreak;\n\t\t\tcase JPEG_MARKER_SOF0:\n\t\t\tcase JPEG_MARKER_SOF1:\n\t\t\tcase JPEG_MARKER_SOF3:\n\t\t\t\tif (OJPEGReadHeaderInfoSecStreamSof(tif,m)==0)\n\t\t\t\t\treturn(0);\n\t\t\t\tif (sp->subsamplingcorrect!=0)\n\t\t\t\t\treturn(1);\n\t\t\t\tbreak;\n\t\t\tcase JPEG_MARKER_SOS:\n\t\t\t\tif (sp->subsamplingcorrect!=0)\n\t\t\t\t\treturn(1);\n\t\t\t\tassert(sp->plane_sample_offset==0);\n\t\t\t\tif (OJPEGReadHeaderInfoSecStreamSos(tif)==0)\n\t\t\t\t\treturn(0);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Unknown marker type %d in JPEG data\",m);\n\t\t\t\treturn(0);\n\t\t}\n\t} while(m!=JPEG_MARKER_SOS);\n\tif (sp->subsamplingcorrect)\n\t\treturn(1);\n\tif (sp->sof_log==0)\n\t{\n\t\tif (OJPEGReadHeaderInfoSecTablesQTable(tif)==0)\n\t\t\treturn(0);\n\t\tsp->sof_marker_id=JPEG_MARKER_SOF0;\n\t\tfor (o=0; o<sp->samples_per_pixel; o++)\n\t\t\tsp->sof_c[o]=o;\n\t\tsp->sof_hv[0]=((sp->subsampling_hor<<4)|sp->subsampling_ver);\n\t\tfor (o=1; o<sp->samples_per_pixel; o++)\n\t\t\tsp->sof_hv[o]=17;\n\t\tsp->sof_x=sp->strile_width;\n\t\tsp->sof_y=sp->strile_length_total;\n\t\tsp->sof_log=1;\n\t\tif (OJPEGReadHeaderInfoSecTablesDcTable(tif)==0)\n\t\t\treturn(0);\n\t\tif (OJPEGReadHeaderInfoSecTablesAcTable(tif)==0)\n\t\t\treturn(0);\n\t\tfor (o=1; o<sp->samples_per_pixel; o++)\n\t\t\tsp->sos_cs[o]=o;\n\t}\n\treturn(1);\n}\n\nstatic int\nOJPEGReadHeaderInfoSecStreamDri(TIFF* tif)\n{\n\t/* this could easilly cause trouble in some cases... but no such cases have occured sofar */\n\tstatic const char module[]=\"OJPEGReadHeaderInfoSecStreamDri\";\n\tOJPEGState* sp=(OJPEGState*)tif->tif_data;\n\tuint16 m;\n\tif (OJPEGReadWord(sp,&m)==0)\n\t\treturn(0);\n\tif (m!=4)\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Corrupt DRI marker in JPEG data\");\n\t\treturn(0);\n\t}\n\tif (OJPEGReadWord(sp,&m)==0)\n\t\treturn(0);\n\tsp->restart_interval=m;\n\treturn(1);\n}\n\nstatic int\nOJPEGReadHeaderInfoSecStreamDqt(TIFF* tif)\n{\n\t/* this is a table marker, and it is to be saved as a whole for exact pushing on the jpeg stream later on */\n\tstatic const char module[]=\"OJPEGReadHeaderInfoSecStreamDqt\";\n\tOJPEGState* sp=(OJPEGState*)tif->tif_data;\n\tuint16 m;\n\tuint32 na;\n\tuint8* nb;\n\tuint8 o;\n\tif (OJPEGReadWord(sp,&m)==0)\n\t\treturn(0);\n\tif (m<=2)\n\t{\n\t\tif (sp->subsamplingcorrect==0)\n\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Corrupt DQT marker in JPEG data\");\n\t\treturn(0);\n\t}\n\tif (sp->subsamplingcorrect!=0)\n\t\tOJPEGReadSkip(sp,(uint16)(m-2));\n\telse\n\t{\n\t\tm-=2;\n\t\tdo\n\t\t{\n\t\t\tif (m<65)\n\t\t\t{\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Corrupt DQT marker in JPEG data\");\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tna=sizeof(uint32)+69;\n\t\t\tnb=_TIFFmalloc(na);\n\t\t\tif (nb==0)\n\t\t\t{\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Out of memory\");\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\t*(uint32*)nb=na;\n\t\t\tnb[sizeof(uint32)]=255;\n\t\t\tnb[sizeof(uint32)+1]=JPEG_MARKER_DQT;\n\t\t\tnb[sizeof(uint32)+2]=0;\n\t\t\tnb[sizeof(uint32)+3]=67;\n\t\t\tif (OJPEGReadBlock(sp,65,&nb[sizeof(uint32)+4])==0)\n\t\t\t\treturn(0);\n\t\t\to=nb[sizeof(uint32)+4]&15;\n\t\t\tif (3<o)\n\t\t\t{\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Corrupt DQT marker in JPEG data\");\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tif (sp->qtable[o]!=0)\n\t\t\t\t_TIFFfree(sp->qtable[o]);\n\t\t\tsp->qtable[o]=nb;\n\t\t\tm-=65;\n\t\t} while(m>0);\n\t}\n\treturn(1);\n}\n\nstatic int\nOJPEGReadHeaderInfoSecStreamDht(TIFF* tif)\n{\n\t/* this is a table marker, and it is to be saved as a whole for exact pushing on the jpeg stream later on */\n\t/* TODO: the following assumes there is only one table in this marker... but i'm not quite sure that assumption is guaranteed correct */\n\tstatic const char module[]=\"OJPEGReadHeaderInfoSecStreamDht\";\n\tOJPEGState* sp=(OJPEGState*)tif->tif_data;\n\tuint16 m;\n\tuint32 na;\n\tuint8* nb;\n\tuint8 o;\n\tif (OJPEGReadWord(sp,&m)==0)\n\t\treturn(0);\n\tif (m<=2)\n\t{\n\t\tif (sp->subsamplingcorrect==0)\n\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Corrupt DHT marker in JPEG data\");\n\t\treturn(0);\n\t}\n\tif (sp->subsamplingcorrect!=0)\n\t{\n\t\tOJPEGReadSkip(sp,(uint16)(m-2));\n\t}\n\telse\n\t{\n\t\tna=sizeof(uint32)+2+m;\n\t\tnb=_TIFFmalloc(na);\n\t\tif (nb==0)\n\t\t{\n\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Out of memory\");\n\t\t\treturn(0);\n\t\t}\n\t\t*(uint32*)nb=na;\n\t\tnb[sizeof(uint32)]=255;\n\t\tnb[sizeof(uint32)+1]=JPEG_MARKER_DHT;\n\t\tnb[sizeof(uint32)+2]=(m>>8);\n\t\tnb[sizeof(uint32)+3]=(m&255);\n\t\tif (OJPEGReadBlock(sp,(uint16)(m-2),&nb[sizeof(uint32)+4])==0)\n\t\t\treturn(0);\n\t\to=nb[sizeof(uint32)+4];\n\t\tif ((o&240)==0)\n\t\t{\n\t\t\tif (3<o)\n\t\t\t{\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Corrupt DHT marker in JPEG data\");\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tif (sp->dctable[o]!=0)\n\t\t\t\t_TIFFfree(sp->dctable[o]);\n\t\t\tsp->dctable[o]=nb;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif ((o&240)!=16)\n\t\t\t{\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Corrupt DHT marker in JPEG data\");\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\to&=15;\n\t\t\tif (3<o)\n\t\t\t{\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Corrupt DHT marker in JPEG data\");\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tif (sp->actable[o]!=0)\n\t\t\t\t_TIFFfree(sp->actable[o]);\n\t\t\tsp->actable[o]=nb;\n\t\t}\n\t}\n\treturn(1);\n}\n\nstatic int\nOJPEGReadHeaderInfoSecStreamSof(TIFF* tif, uint8 marker_id)\n{\n\t/* this marker needs to be checked, and part of its data needs to be saved for regeneration later on */\n\tstatic const char module[]=\"OJPEGReadHeaderInfoSecStreamSof\";\n\tOJPEGState* sp=(OJPEGState*)tif->tif_data;\n\tuint16 m;\n\tuint16 n;\n\tuint8 o;\n\tuint16 p;\n\tuint16 q;\n\tif (sp->sof_log!=0)\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Corrupt JPEG data\");\n\t\treturn(0);\n\t}\n\tif (sp->subsamplingcorrect==0)\n\t\tsp->sof_marker_id=marker_id;\n\t/* Lf: data length */\n\tif (OJPEGReadWord(sp,&m)==0)\n\t\treturn(0);\n\tif (m<11)\n\t{\n\t\tif (sp->subsamplingcorrect==0)\n\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Corrupt SOF marker in JPEG data\");\n\t\treturn(0);\n\t}\n\tm-=8;\n\tif (m%3!=0)\n\t{\n\t\tif (sp->subsamplingcorrect==0)\n\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Corrupt SOF marker in JPEG data\");\n\t\treturn(0);\n\t}\n\tn=m/3;\n\tif (sp->subsamplingcorrect==0)\n\t{\n\t\tif (n!=sp->samples_per_pixel)\n\t\t{\n\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"JPEG compressed data indicates unexpected number of samples\");\n\t\t\treturn(0);\n\t\t}\n\t}\n\t/* P: Sample precision */\n\tif (OJPEGReadByte(sp,&o)==0)\n\t\treturn(0);\n\tif (o!=8)\n\t{\n\t\tif (sp->subsamplingcorrect==0)\n\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"JPEG compressed data indicates unexpected number of bits per sample\");\n\t\treturn(0);\n\t}\n\t/* Y: Number of lines, X: Number of samples per line */\n\tif (sp->subsamplingcorrect)\n\t\tOJPEGReadSkip(sp,4);\n\telse\n\t{\n\t\t/* TODO: probably best to also add check on allowed upper bound, especially x, may cause buffer overflow otherwise i think */\n\t\t/* Y: Number of lines */\n\t\tif (OJPEGReadWord(sp,&p)==0)\n\t\t\treturn(0);\n\t\tif ((p<sp->image_length) && (p<sp->strile_length_total))\n\t\t{\n\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"JPEG compressed data indicates unexpected height\");\n\t\t\treturn(0);\n\t\t}\n\t\tsp->sof_y=p;\n\t\t/* X: Number of samples per line */\n\t\tif (OJPEGReadWord(sp,&p)==0)\n\t\t\treturn(0);\n\t\tif ((p<sp->image_width) && (p<sp->strile_width))\n\t\t{\n\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"JPEG compressed data indicates unexpected width\");\n\t\t\treturn(0);\n\t\t}\n\t\tsp->sof_x=p;\n\t}\n\t/* Nf: Number of image components in frame */\n\tif (OJPEGReadByte(sp,&o)==0)\n\t\treturn(0);\n\tif (o!=n)\n\t{\n\t\tif (sp->subsamplingcorrect==0)\n\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Corrupt SOF marker in JPEG data\");\n\t\treturn(0);\n\t}\n\t/* per component stuff */\n\t/* TODO: double-check that flow implies that n cannot be as big as to make us overflow sof_c, sof_hv and sof_tq arrays */\n\tfor (q=0; q<n; q++)\n\t{\n\t\t/* C: Component identifier */\n\t\tif (OJPEGReadByte(sp,&o)==0)\n\t\t\treturn(0);\n\t\tif (sp->subsamplingcorrect==0)\n\t\t\tsp->sof_c[q]=o;\n\t\t/* H: Horizontal sampling factor, and V: Vertical sampling factor */\n\t\tif (OJPEGReadByte(sp,&o)==0)\n\t\t\treturn(0);\n\t\tif (sp->subsamplingcorrect!=0)\n\t\t{\n\t\t\tif (q==0)\n\t\t\t{\n\t\t\t\tsp->subsampling_hor=(o>>4);\n\t\t\t\tsp->subsampling_ver=(o&15);\n\t\t\t\tif (((sp->subsampling_hor!=1) && (sp->subsampling_hor!=2) && (sp->subsampling_hor!=4)) ||\n\t\t\t\t\t((sp->subsampling_ver!=1) && (sp->subsampling_ver!=2) && (sp->subsampling_ver!=4)))\n\t\t\t\t\tsp->subsampling_force_desubsampling_inside_decompression=1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (o!=17)\n\t\t\t\t\tsp->subsampling_force_desubsampling_inside_decompression=1;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsp->sof_hv[q]=o;\n\t\t\tif (sp->subsampling_force_desubsampling_inside_decompression==0)\n\t\t\t{\n\t\t\t\tif (q==0)\n\t\t\t\t{\n\t\t\t\t\tif (o!=((sp->subsampling_hor<<4)|sp->subsampling_ver))\n\t\t\t\t\t{\n\t\t\t\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"JPEG compressed data indicates unexpected subsampling values\");\n\t\t\t\t\t\treturn(0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (o!=17)\n\t\t\t\t\t{\n\t\t\t\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"JPEG compressed data indicates unexpected subsampling values\");\n\t\t\t\t\t\treturn(0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/* Tq: Quantization table destination selector */\n\t\tif (OJPEGReadByte(sp,&o)==0)\n\t\t\treturn(0);\n\t\tif (sp->subsamplingcorrect==0)\n\t\t\tsp->sof_tq[q]=o;\n\t}\n\tif (sp->subsamplingcorrect==0)\n\t\tsp->sof_log=1;\n\treturn(1);\n}\n\nstatic int\nOJPEGReadHeaderInfoSecStreamSos(TIFF* tif)\n{\n\t/* this marker needs to be checked, and part of its data needs to be saved for regeneration later on */\n\tstatic const char module[]=\"OJPEGReadHeaderInfoSecStreamSos\";\n\tOJPEGState* sp=(OJPEGState*)tif->tif_data;\n\tuint16 m;\n\tuint8 n;\n\tuint8 o;\n\tassert(sp->subsamplingcorrect==0);\n\tif (sp->sof_log==0)\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Corrupt SOS marker in JPEG data\");\n\t\treturn(0);\n\t}\n\t/* Ls */\n\tif (OJPEGReadWord(sp,&m)==0)\n\t\treturn(0);\n\tif (m!=6+sp->samples_per_pixel_per_plane*2)\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Corrupt SOS marker in JPEG data\");\n\t\treturn(0);\n\t}\n\t/* Ns */\n\tif (OJPEGReadByte(sp,&n)==0)\n\t\treturn(0);\n\tif (n!=sp->samples_per_pixel_per_plane)\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Corrupt SOS marker in JPEG data\");\n\t\treturn(0);\n\t}\n\t/* Cs, Td, and Ta */\n\tfor (o=0; o<sp->samples_per_pixel_per_plane; o++)\n\t{\n\t\t/* Cs */\n\t\tif (OJPEGReadByte(sp,&n)==0)\n\t\t\treturn(0);\n\t\tsp->sos_cs[sp->plane_sample_offset+o]=n;\n\t\t/* Td and Ta */\n\t\tif (OJPEGReadByte(sp,&n)==0)\n\t\t\treturn(0);\n\t\tsp->sos_tda[sp->plane_sample_offset+o]=n;\n\t}\n\t/* skip Ss, Se, Ah, en Al -> no check, as per Tom Lane recommendation, as per LibJpeg source */\n\tOJPEGReadSkip(sp,3);\n\treturn(1);\n}\n\nstatic int\nOJPEGReadHeaderInfoSecTablesQTable(TIFF* tif)\n{\n\tstatic const char module[]=\"OJPEGReadHeaderInfoSecTablesQTable\";\n\tOJPEGState* sp=(OJPEGState*)tif->tif_data;\n\tuint8 m;\n\tuint8 n;\n\tuint32 oa;\n\tuint8* ob;\n\tuint32 p;\n\tif (sp->qtable_offset[0]==0)\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Missing JPEG tables\");\n\t\treturn(0);\n\t}\n\tsp->in_buffer_file_pos_log=0;\n\tfor (m=0; m<sp->samples_per_pixel; m++)\n\t{\n\t\tif ((sp->qtable_offset[m]!=0) && ((m==0) || (sp->qtable_offset[m]!=sp->qtable_offset[m-1])))\n\t\t{\n\t\t\tfor (n=0; n<m-1; n++)\n\t\t\t{\n\t\t\t\tif (sp->qtable_offset[m]==sp->qtable_offset[n])\n\t\t\t\t{\n\t\t\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Corrupt JpegQTables tag value\");\n\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\toa=sizeof(uint32)+69;\n\t\t\tob=_TIFFmalloc(oa);\n\t\t\tif (ob==0)\n\t\t\t{\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Out of memory\");\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\t*(uint32*)ob=oa;\n\t\t\tob[sizeof(uint32)]=255;\n\t\t\tob[sizeof(uint32)+1]=JPEG_MARKER_DQT;\n\t\t\tob[sizeof(uint32)+2]=0;\n\t\t\tob[sizeof(uint32)+3]=67;\n\t\t\tob[sizeof(uint32)+4]=m;\n\t\t\tTIFFSeekFile(tif,sp->qtable_offset[m],SEEK_SET);\n\t\t\tp=TIFFReadFile(tif,&ob[sizeof(uint32)+5],64);\n\t\t\tif (p!=64)\n\t\t\t\treturn(0);\n\t\t\tsp->qtable[m]=ob;\n\t\t\tsp->sof_tq[m]=m;\n\t\t}\n\t\telse\n\t\t\tsp->sof_tq[m]=sp->sof_tq[m-1];\n\t}\n\treturn(1);\n}\n\nstatic int\nOJPEGReadHeaderInfoSecTablesDcTable(TIFF* tif)\n{\n\tstatic const char module[]=\"OJPEGReadHeaderInfoSecTablesDcTable\";\n\tOJPEGState* sp=(OJPEGState*)tif->tif_data;\n\tuint8 m;\n\tuint8 n;\n\tuint8 o[16];\n\tuint32 p;\n\tuint32 q;\n\tuint32 ra;\n\tuint8* rb;\n\tif (sp->dctable_offset[0]==0)\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Missing JPEG tables\");\n\t\treturn(0);\n\t}\n\tsp->in_buffer_file_pos_log=0;\n\tfor (m=0; m<sp->samples_per_pixel; m++)\n\t{\n\t\tif ((sp->dctable_offset[m]!=0) && ((m==0) || (sp->dctable_offset[m]!=sp->dctable_offset[m-1])))\n\t\t{\n\t\t\tfor (n=0; n<m-1; n++)\n\t\t\t{\n\t\t\t\tif (sp->dctable_offset[m]==sp->dctable_offset[n])\n\t\t\t\t{\n\t\t\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Corrupt JpegDcTables tag value\");\n\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tTIFFSeekFile(tif,sp->dctable_offset[m],SEEK_SET);\n\t\t\tp=TIFFReadFile(tif,o,16);\n\t\t\tif (p!=16)\n\t\t\t\treturn(0);\n\t\t\tq=0;\n\t\t\tfor (n=0; n<16; n++)\n\t\t\t\tq+=o[n];\n\t\t\tra=sizeof(uint32)+21+q;\n\t\t\trb=_TIFFmalloc(ra);\n\t\t\tif (rb==0)\n\t\t\t{\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Out of memory\");\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\t*(uint32*)rb=ra;\n\t\t\trb[sizeof(uint32)]=255;\n\t\t\trb[sizeof(uint32)+1]=JPEG_MARKER_DHT;\n\t\t\trb[sizeof(uint32)+2]=((19+q)>>8);\n\t\t\trb[sizeof(uint32)+3]=((19+q)&255);\n\t\t\trb[sizeof(uint32)+4]=m;\n\t\t\tfor (n=0; n<16; n++)\n\t\t\t\trb[sizeof(uint32)+5+n]=o[n];\n\t\t\tp=TIFFReadFile(tif,&(rb[sizeof(uint32)+21]),q);\n\t\t\tif (p!=q)\n\t\t\t\treturn(0);\n\t\t\tsp->dctable[m]=rb;\n\t\t\tsp->sos_tda[m]=(m<<4);\n\t\t}\n\t\telse\n\t\t\tsp->sos_tda[m]=sp->sos_tda[m-1];\n\t}\n\treturn(1);\n}\n\nstatic int\nOJPEGReadHeaderInfoSecTablesAcTable(TIFF* tif)\n{\n\tstatic const char module[]=\"OJPEGReadHeaderInfoSecTablesAcTable\";\n\tOJPEGState* sp=(OJPEGState*)tif->tif_data;\n\tuint8 m;\n\tuint8 n;\n\tuint8 o[16];\n\tuint32 p;\n\tuint32 q;\n\tuint32 ra;\n\tuint8* rb;\n\tif (sp->actable_offset[0]==0)\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Missing JPEG tables\");\n\t\treturn(0);\n\t}\n\tsp->in_buffer_file_pos_log=0;\n\tfor (m=0; m<sp->samples_per_pixel; m++)\n\t{\n\t\tif ((sp->actable_offset[m]!=0) && ((m==0) || (sp->actable_offset[m]!=sp->actable_offset[m-1])))\n\t\t{\n\t\t\tfor (n=0; n<m-1; n++)\n\t\t\t{\n\t\t\t\tif (sp->actable_offset[m]==sp->actable_offset[n])\n\t\t\t\t{\n\t\t\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Corrupt JpegAcTables tag value\");\n\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tTIFFSeekFile(tif,sp->actable_offset[m],SEEK_SET);\n\t\t\tp=TIFFReadFile(tif,o,16);\n\t\t\tif (p!=16)\n\t\t\t\treturn(0);\n\t\t\tq=0;\n\t\t\tfor (n=0; n<16; n++)\n\t\t\t\tq+=o[n];\n\t\t\tra=sizeof(uint32)+21+q;\n\t\t\trb=_TIFFmalloc(ra);\n\t\t\tif (rb==0)\n\t\t\t{\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Out of memory\");\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\t*(uint32*)rb=ra;\n\t\t\trb[sizeof(uint32)]=255;\n\t\t\trb[sizeof(uint32)+1]=JPEG_MARKER_DHT;\n\t\t\trb[sizeof(uint32)+2]=((19+q)>>8);\n\t\t\trb[sizeof(uint32)+3]=((19+q)&255);\n\t\t\trb[sizeof(uint32)+4]=(16|m);\n\t\t\tfor (n=0; n<16; n++)\n\t\t\t\trb[sizeof(uint32)+5+n]=o[n];\n\t\t\tp=TIFFReadFile(tif,&(rb[sizeof(uint32)+21]),q);\n\t\t\tif (p!=q)\n\t\t\t\treturn(0);\n\t\t\tsp->actable[m]=rb;\n\t\t\tsp->sos_tda[m]=(sp->sos_tda[m]|m);\n\t\t}\n\t\telse\n\t\t\tsp->sos_tda[m]=(sp->sos_tda[m]|(sp->sos_tda[m-1]&15));\n\t}\n\treturn(1);\n}\n\nstatic int\nOJPEGReadBufferFill(OJPEGState* sp)\n{\n\tuint16 m;\n\ttsize_t n;\n\t/* TODO: double-check: when subsamplingcorrect is set, no call to TIFFErrorExt or TIFFWarningExt should be made\n\t * in any other case, seek or read errors should be passed through */\n\tdo\n\t{\n\t\tif (sp->in_buffer_file_togo!=0)\n\t\t{\n\t\t\tif (sp->in_buffer_file_pos_log==0)\n\t\t\t{\n\t\t\t\tTIFFSeekFile(sp->tif,sp->in_buffer_file_pos,SEEK_SET);\n\t\t\t\tsp->in_buffer_file_pos_log=1;\n\t\t\t}\n\t\t\tm=OJPEG_BUFFER;\n\t\t\tif (m>sp->in_buffer_file_togo)\n\t\t\t\tm=(uint16)sp->in_buffer_file_togo;\n\t\t\tn=TIFFReadFile(sp->tif,sp->in_buffer,(tsize_t)m);\n\t\t\tif (n==0)\n\t\t\t\treturn(0);\n\t\t\tassert(n>0);\n\t\t\tassert(n<=OJPEG_BUFFER);\n\t\t\tassert(n<65536);\n\t\t\tassert((uint16)n<=sp->in_buffer_file_togo);\n\t\t\tm=(uint16)n;\n\t\t\tsp->in_buffer_togo=m;\n\t\t\tsp->in_buffer_cur=sp->in_buffer;\n\t\t\tsp->in_buffer_file_togo-=m;\n\t\t\tsp->in_buffer_file_pos+=m;\n\t\t\tbreak;\n\t\t}\n\t\tsp->in_buffer_file_pos_log=0;\n\t\tswitch(sp->in_buffer_source)\n\t\t{\n\t\t\tcase osibsNotSetYet:\n\t\t\t\tif (sp->jpeg_interchange_format!=0)\n\t\t\t\t{\n\t\t\t\t\tsp->in_buffer_file_pos=sp->jpeg_interchange_format;\n\t\t\t\t\tsp->in_buffer_file_togo=sp->jpeg_interchange_format_length;\n\t\t\t\t}\n\t\t\t\tsp->in_buffer_source=osibsJpegInterchangeFormat;\n\t\t\t\tbreak;\n\t\t\tcase osibsJpegInterchangeFormat:\n\t\t\t\tsp->in_buffer_source=osibsStrile;\n\t\t\tcase osibsStrile:\n\t\t\t\tif (sp->in_buffer_next_strile==sp->in_buffer_strile_count)  \n\t\t\t\t\tsp->in_buffer_source=osibsEof;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (sp->tif->tif_dir.td_stripoffset == 0) {\n\t\t\t\t\t\tTIFFErrorExt(sp->tif->tif_clientdata,sp->tif->tif_name,\"Strip offsets are missing\");\n\t\t\t\t\t\treturn(0);\n\t\t\t\t\t}\n\t\t\t\t\tsp->in_buffer_file_pos=sp->tif->tif_dir.td_stripoffset[sp->in_buffer_next_strile];  \n\t\t\t\t\tif (sp->in_buffer_file_pos!=0)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (sp->in_buffer_file_pos>=sp->file_size)\n\t\t\t\t\t\t\tsp->in_buffer_file_pos=0;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tsp->in_buffer_file_togo=sp->tif->tif_dir.td_stripbytecount[sp->in_buffer_next_strile];  \n\t\t\t\t\t\t\tif (sp->in_buffer_file_togo==0)\n\t\t\t\t\t\t\t\tsp->in_buffer_file_pos=0;\n\t\t\t\t\t\t\telse if (sp->in_buffer_file_pos+sp->in_buffer_file_togo>sp->file_size)\n\t\t\t\t\t\t\t\tsp->in_buffer_file_togo=sp->file_size-sp->in_buffer_file_pos;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tsp->in_buffer_next_strile++;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn(0);\n\t\t}\n\t} while (1);\n\treturn(1);\n}\n\nstatic int\nOJPEGReadByte(OJPEGState* sp, uint8* byte)\n{\n\tif (sp->in_buffer_togo==0)\n\t{\n\t\tif (OJPEGReadBufferFill(sp)==0)\n\t\t\treturn(0);\n\t\tassert(sp->in_buffer_togo>0);\n\t}\n\t*byte=*(sp->in_buffer_cur);\n\tsp->in_buffer_cur++;\n\tsp->in_buffer_togo--;\n\treturn(1);\n}\n\nstatic int\nOJPEGReadBytePeek(OJPEGState* sp, uint8* byte)\n{\n\tif (sp->in_buffer_togo==0)\n\t{\n\t\tif (OJPEGReadBufferFill(sp)==0)\n\t\t\treturn(0);\n\t\tassert(sp->in_buffer_togo>0);\n\t}\n\t*byte=*(sp->in_buffer_cur);\n\treturn(1);\n}\n\nstatic void\nOJPEGReadByteAdvance(OJPEGState* sp)\n{\n\tassert(sp->in_buffer_togo>0);\n\tsp->in_buffer_cur++;\n\tsp->in_buffer_togo--;\n}\n\nstatic int\nOJPEGReadWord(OJPEGState* sp, uint16* word)\n{\n\tuint8 m;\n\tif (OJPEGReadByte(sp,&m)==0)\n\t\treturn(0);\n\t*word=(m<<8);\n\tif (OJPEGReadByte(sp,&m)==0)\n\t\treturn(0);\n\t*word|=m;\n\treturn(1);\n}\n\nstatic int\nOJPEGReadBlock(OJPEGState* sp, uint16 len, void* mem)\n{\n\tuint16 mlen;\n\tuint8* mmem;\n\tuint16 n;\n\tassert(len>0);\n\tmlen=len;\n\tmmem=mem;\n\tdo\n\t{\n\t\tif (sp->in_buffer_togo==0)\n\t\t{\n\t\t\tif (OJPEGReadBufferFill(sp)==0)\n\t\t\t\treturn(0);\n\t\t\tassert(sp->in_buffer_togo>0);\n\t\t}\n\t\tn=mlen;\n\t\tif (n>sp->in_buffer_togo)\n\t\t\tn=sp->in_buffer_togo;\n\t\t_TIFFmemcpy(mmem,sp->in_buffer_cur,n);\n\t\tsp->in_buffer_cur+=n;\n\t\tsp->in_buffer_togo-=n;\n\t\tmlen-=n;\n\t\tmmem+=n;\n\t} while(mlen>0);\n\treturn(1);\n}\n\nstatic void\nOJPEGReadSkip(OJPEGState* sp, uint16 len)\n{\n\tuint16 m;\n\tuint16 n;\n\tm=len;\n\tn=m;\n\tif (n>sp->in_buffer_togo)\n\t\tn=sp->in_buffer_togo;\n\tsp->in_buffer_cur+=n;\n\tsp->in_buffer_togo-=n;\n\tm-=n;\n\tif (m>0)\n\t{\n\t\tassert(sp->in_buffer_togo==0);\n\t\tn=m;\n\t\tif (n>sp->in_buffer_file_togo)\n\t\t\tn=sp->in_buffer_file_togo;\n\t\tsp->in_buffer_file_pos+=n;\n\t\tsp->in_buffer_file_togo-=n;\n\t\tsp->in_buffer_file_pos_log=0;\n\t\t/* we don't skip past jpeginterchangeformat/strile block...\n\t\t * if that is asked from us, we're dealing with totally bazurk\n\t\t * data anyway, and we've not seen this happening on any\n\t\t * testfile, so we might as well likely cause some other\n\t\t * meaningless error to be passed at some later time\n\t\t */\n\t}\n}\n\nstatic int\nOJPEGWriteStream(TIFF* tif, void** mem, uint32* len)\n{\n\tOJPEGState* sp=(OJPEGState*)tif->tif_data;\n\t*len=0;\n\tdo\n\t{\n\t\tassert(sp->out_state<=ososEoi);\n\t\tswitch(sp->out_state)\n\t\t{\n\t\t\tcase ososSoi:\n\t\t\t\tOJPEGWriteStreamSoi(tif,mem,len);\n\t\t\t\tbreak;\n\t\t\tcase ososQTable0:\n\t\t\t\tOJPEGWriteStreamQTable(tif,0,mem,len);\n\t\t\t\tbreak;\n\t\t\tcase ososQTable1:\n\t\t\t\tOJPEGWriteStreamQTable(tif,1,mem,len);\n\t\t\t\tbreak;\n\t\t\tcase ososQTable2:\n\t\t\t\tOJPEGWriteStreamQTable(tif,2,mem,len);\n\t\t\t\tbreak;\n\t\t\tcase ososQTable3:\n\t\t\t\tOJPEGWriteStreamQTable(tif,3,mem,len);\n\t\t\t\tbreak;\n\t\t\tcase ososDcTable0:\n\t\t\t\tOJPEGWriteStreamDcTable(tif,0,mem,len);\n\t\t\t\tbreak;\n\t\t\tcase ososDcTable1:\n\t\t\t\tOJPEGWriteStreamDcTable(tif,1,mem,len);\n\t\t\t\tbreak;\n\t\t\tcase ososDcTable2:\n\t\t\t\tOJPEGWriteStreamDcTable(tif,2,mem,len);\n\t\t\t\tbreak;\n\t\t\tcase ososDcTable3:\n\t\t\t\tOJPEGWriteStreamDcTable(tif,3,mem,len);\n\t\t\t\tbreak;\n\t\t\tcase ososAcTable0:\n\t\t\t\tOJPEGWriteStreamAcTable(tif,0,mem,len);\n\t\t\t\tbreak;\n\t\t\tcase ososAcTable1:\n\t\t\t\tOJPEGWriteStreamAcTable(tif,1,mem,len);\n\t\t\t\tbreak;\n\t\t\tcase ososAcTable2:\n\t\t\t\tOJPEGWriteStreamAcTable(tif,2,mem,len);\n\t\t\t\tbreak;\n\t\t\tcase ososAcTable3:\n\t\t\t\tOJPEGWriteStreamAcTable(tif,3,mem,len);\n\t\t\t\tbreak;\n\t\t\tcase ososDri:\n\t\t\t\tOJPEGWriteStreamDri(tif,mem,len);\n\t\t\t\tbreak;\n\t\t\tcase ososSof:\n\t\t\t\tOJPEGWriteStreamSof(tif,mem,len);\n\t\t\t\tbreak;\n\t\t\tcase ososSos:\n\t\t\t\tOJPEGWriteStreamSos(tif,mem,len);\n\t\t\t\tbreak;\n\t\t\tcase ososCompressed:\n\t\t\t\tif (OJPEGWriteStreamCompressed(tif,mem,len)==0)\n\t\t\t\t\treturn(0);\n\t\t\t\tbreak;\n\t\t\tcase ososRst:\n\t\t\t\tOJPEGWriteStreamRst(tif,mem,len);\n\t\t\t\tbreak;\n\t\t\tcase ososEoi:\n\t\t\t\tOJPEGWriteStreamEoi(tif,mem,len);\n\t\t\t\tbreak;\n\t\t}\n\t} while (*len==0);\n\treturn(1);\n}\n\nstatic void\nOJPEGWriteStreamSoi(TIFF* tif, void** mem, uint32* len)\n{\n\tOJPEGState* sp=(OJPEGState*)tif->tif_data;\n\tassert(OJPEG_BUFFER>=2);\n\tsp->out_buffer[0]=255;\n\tsp->out_buffer[1]=JPEG_MARKER_SOI;\n\t*len=2;\n\t*mem=(void*)sp->out_buffer;\n\tsp->out_state++;\n}\n\nstatic void\nOJPEGWriteStreamQTable(TIFF* tif, uint8 table_index, void** mem, uint32* len)\n{\n\tOJPEGState* sp=(OJPEGState*)tif->tif_data;\n\tif (sp->qtable[table_index]!=0)\n\t{\n\t\t*mem=(void*)(sp->qtable[table_index]+sizeof(uint32));\n\t\t*len=*((uint32*)sp->qtable[table_index])-sizeof(uint32);\n\t}\n\tsp->out_state++;\n}\n\nstatic void\nOJPEGWriteStreamDcTable(TIFF* tif, uint8 table_index, void** mem, uint32* len)\n{\n\tOJPEGState* sp=(OJPEGState*)tif->tif_data;\n\tif (sp->dctable[table_index]!=0)\n\t{\n\t\t*mem=(void*)(sp->dctable[table_index]+sizeof(uint32));\n\t\t*len=*((uint32*)sp->dctable[table_index])-sizeof(uint32);\n\t}\n\tsp->out_state++;\n}\n\nstatic void\nOJPEGWriteStreamAcTable(TIFF* tif, uint8 table_index, void** mem, uint32* len)\n{\n\tOJPEGState* sp=(OJPEGState*)tif->tif_data;\n\tif (sp->actable[table_index]!=0)\n\t{\n\t\t*mem=(void*)(sp->actable[table_index]+sizeof(uint32));\n\t\t*len=*((uint32*)sp->actable[table_index])-sizeof(uint32);\n\t}\n\tsp->out_state++;\n}\n\nstatic void\nOJPEGWriteStreamDri(TIFF* tif, void** mem, uint32* len)\n{\n\tOJPEGState* sp=(OJPEGState*)tif->tif_data;\n\tassert(OJPEG_BUFFER>=6);\n\tif (sp->restart_interval!=0)\n\t{\n\t\tsp->out_buffer[0]=255;\n\t\tsp->out_buffer[1]=JPEG_MARKER_DRI;\n\t\tsp->out_buffer[2]=0;\n\t\tsp->out_buffer[3]=4;\n\t\tsp->out_buffer[4]=(sp->restart_interval>>8);\n\t\tsp->out_buffer[5]=(sp->restart_interval&255);\n\t\t*len=6;\n\t\t*mem=(void*)sp->out_buffer;\n\t}\n\tsp->out_state++;\n}\n\nstatic void\nOJPEGWriteStreamSof(TIFF* tif, void** mem, uint32* len)\n{\n\tOJPEGState* sp=(OJPEGState*)tif->tif_data;\n\tuint8 m;\n\tassert(OJPEG_BUFFER>=2+8+sp->samples_per_pixel_per_plane*3);\n\tassert(255>=8+sp->samples_per_pixel_per_plane*3);\n\tsp->out_buffer[0]=255;\n\tsp->out_buffer[1]=sp->sof_marker_id;\n\t/* Lf */\n\tsp->out_buffer[2]=0;\n\tsp->out_buffer[3]=8+sp->samples_per_pixel_per_plane*3;\n\t/* P */\n\tsp->out_buffer[4]=8;\n\t/* Y */\n\tsp->out_buffer[5]=(sp->sof_y>>8);\n\tsp->out_buffer[6]=(sp->sof_y&255);\n\t/* X */\n\tsp->out_buffer[7]=(sp->sof_x>>8);\n\tsp->out_buffer[8]=(sp->sof_x&255);\n\t/* Nf */\n\tsp->out_buffer[9]=sp->samples_per_pixel_per_plane;\n\tfor (m=0; m<sp->samples_per_pixel_per_plane; m++)\n\t{\n\t\t/* C */\n\t\tsp->out_buffer[10+m*3]=sp->sof_c[sp->plane_sample_offset+m];\n\t\t/* H and V */\n\t\tsp->out_buffer[10+m*3+1]=sp->sof_hv[sp->plane_sample_offset+m];\n\t\t/* Tq */\n\t\tsp->out_buffer[10+m*3+2]=sp->sof_tq[sp->plane_sample_offset+m];\n\t}\n\t*len=10+sp->samples_per_pixel_per_plane*3;\n\t*mem=(void*)sp->out_buffer;\n\tsp->out_state++;\n}\n\nstatic void\nOJPEGWriteStreamSos(TIFF* tif, void** mem, uint32* len)\n{\n\tOJPEGState* sp=(OJPEGState*)tif->tif_data;\n\tuint8 m;\n\tassert(OJPEG_BUFFER>=2+6+sp->samples_per_pixel_per_plane*2);\n\tassert(255>=6+sp->samples_per_pixel_per_plane*2);\n\tsp->out_buffer[0]=255;\n\tsp->out_buffer[1]=JPEG_MARKER_SOS;\n\t/* Ls */\n\tsp->out_buffer[2]=0;\n\tsp->out_buffer[3]=6+sp->samples_per_pixel_per_plane*2;\n\t/* Ns */\n\tsp->out_buffer[4]=sp->samples_per_pixel_per_plane;\n\tfor (m=0; m<sp->samples_per_pixel_per_plane; m++)\n\t{\n\t\t/* Cs */\n\t\tsp->out_buffer[5+m*2]=sp->sos_cs[sp->plane_sample_offset+m];\n\t\t/* Td and Ta */\n\t\tsp->out_buffer[5+m*2+1]=sp->sos_tda[sp->plane_sample_offset+m];\n\t}\n\t/* Ss */\n\tsp->out_buffer[5+sp->samples_per_pixel_per_plane*2]=0;\n\t/* Se */\n\tsp->out_buffer[5+sp->samples_per_pixel_per_plane*2+1]=63;\n\t/* Ah and Al */\n\tsp->out_buffer[5+sp->samples_per_pixel_per_plane*2+2]=0;\n\t*len=8+sp->samples_per_pixel_per_plane*2;\n\t*mem=(void*)sp->out_buffer;\n\tsp->out_state++;\n}\n\nstatic int\nOJPEGWriteStreamCompressed(TIFF* tif, void** mem, uint32* len)\n{\n\tOJPEGState* sp=(OJPEGState*)tif->tif_data;\n\tif (sp->in_buffer_togo==0)\n\t{\n\t\tif (OJPEGReadBufferFill(sp)==0)\n\t\t\treturn(0);\n\t\tassert(sp->in_buffer_togo>0);\n\t}\n\t*len=sp->in_buffer_togo;\n\t*mem=(void*)sp->in_buffer_cur;\n\tsp->in_buffer_togo=0;\n\tif (sp->in_buffer_file_togo==0)\n\t{\n\t\tswitch(sp->in_buffer_source)\n\t\t{\n\t\t\tcase osibsStrile:\n\t\t\t\tif (sp->in_buffer_next_strile<sp->in_buffer_strile_count)  \n\t\t\t\t\tsp->out_state=ososRst;\n\t\t\t\telse\n\t\t\t\t\tsp->out_state=ososEoi;\n\t\t\t\tbreak;\n\t\t\tcase osibsEof:\n\t\t\t\tsp->out_state=ososEoi;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn(1);\n}\n\nstatic void\nOJPEGWriteStreamRst(TIFF* tif, void** mem, uint32* len)\n{\n\tOJPEGState* sp=(OJPEGState*)tif->tif_data;\n\tassert(OJPEG_BUFFER>=2);\n\tsp->out_buffer[0]=255;\n\tsp->out_buffer[1]=JPEG_MARKER_RST0+sp->restart_index;\n\tsp->restart_index++;\n\tif (sp->restart_index==8)\n\t\tsp->restart_index=0;\n\t*len=2;\n\t*mem=(void*)sp->out_buffer;\n\tsp->out_state=ososCompressed;\n}\n\nstatic void\nOJPEGWriteStreamEoi(TIFF* tif, void** mem, uint32* len)\n{\n\tOJPEGState* sp=(OJPEGState*)tif->tif_data;\n\tassert(OJPEG_BUFFER>=2);\n\tsp->out_buffer[0]=255;\n\tsp->out_buffer[1]=JPEG_MARKER_EOI;\n\t*len=2;\n\t*mem=(void*)sp->out_buffer;\n}\n\n#ifndef LIBJPEG_ENCAP_EXTERNAL\nstatic int\njpeg_create_decompress_encap(OJPEGState* sp, jpeg_decompress_struct* cinfo)\n{\n\treturn(SETJMP(sp->exit_jmpbuf)?0:(jpeg_create_decompress(cinfo),1));\n}\n#endif\n\n#ifndef LIBJPEG_ENCAP_EXTERNAL\nstatic int\njpeg_read_header_encap(OJPEGState* sp, jpeg_decompress_struct* cinfo, uint8 require_image)\n{\n\treturn(SETJMP(sp->exit_jmpbuf)?0:(jpeg_read_header(cinfo,require_image),1));\n}\n#endif\n\n#ifndef LIBJPEG_ENCAP_EXTERNAL\nstatic int\njpeg_start_decompress_encap(OJPEGState* sp, jpeg_decompress_struct* cinfo)\n{\n\treturn(SETJMP(sp->exit_jmpbuf)?0:(jpeg_start_decompress(cinfo),1));\n}\n#endif\n\n#ifndef LIBJPEG_ENCAP_EXTERNAL\nstatic int\njpeg_read_scanlines_encap(OJPEGState* sp, jpeg_decompress_struct* cinfo, void* scanlines, uint32 max_lines)\n{\n\treturn(SETJMP(sp->exit_jmpbuf)?0:(jpeg_read_scanlines(cinfo,scanlines,max_lines),1));\n}\n#endif\n\n#ifndef LIBJPEG_ENCAP_EXTERNAL\nstatic int\njpeg_read_raw_data_encap(OJPEGState* sp, jpeg_decompress_struct* cinfo, void* data, uint32 max_lines)\n{\n\treturn(SETJMP(sp->exit_jmpbuf)?0:(jpeg_read_raw_data(cinfo,data,max_lines),1));\n}\n#endif\n\n#ifndef LIBJPEG_ENCAP_EXTERNAL\nstatic void\njpeg_encap_unwind(TIFF* tif)\n{\n\tOJPEGState* sp=(OJPEGState*)tif->tif_data;\n\tLONGJMP(sp->exit_jmpbuf,1);\n}\n#endif\n\nstatic void\nOJPEGLibjpegJpegErrorMgrOutputMessage(jpeg_common_struct* cinfo)\n{\n\tchar buffer[JMSG_LENGTH_MAX];\n\t(*cinfo->err->format_message)(cinfo,buffer);\n\tTIFFWarningExt(((TIFF*)(cinfo->client_data))->tif_clientdata,\"LibJpeg\", \"%s\", buffer);\n}\n\nstatic void\nOJPEGLibjpegJpegErrorMgrErrorExit(jpeg_common_struct* cinfo)\n{\n\tchar buffer[JMSG_LENGTH_MAX];\n\t(*cinfo->err->format_message)(cinfo,buffer);\n\tTIFFErrorExt(((TIFF*)(cinfo->client_data))->tif_clientdata,\"LibJpeg\", \"%s\", buffer);\n\tjpeg_encap_unwind((TIFF*)(cinfo->client_data));\n}\n\nstatic void\nOJPEGLibjpegJpegSourceMgrInitSource(jpeg_decompress_struct* cinfo)\n{\n\t(void)cinfo;\n}\n\nstatic boolean\nOJPEGLibjpegJpegSourceMgrFillInputBuffer(jpeg_decompress_struct* cinfo)\n{\n\tTIFF* tif=(TIFF*)cinfo->client_data;\n\tOJPEGState* sp=(OJPEGState*)tif->tif_data;\n\tvoid* mem=0;\n\tuint32 len=0;\n\tif (OJPEGWriteStream(tif,&mem,&len)==0)\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata,\"LibJpeg\",\"Premature end of JPEG data\");\n\t\tjpeg_encap_unwind(tif);\n\t}\n\tsp->libjpeg_jpeg_source_mgr.bytes_in_buffer=len;\n\tsp->libjpeg_jpeg_source_mgr.next_input_byte=mem;\n\treturn(1);\n}\n\nstatic void\nOJPEGLibjpegJpegSourceMgrSkipInputData(jpeg_decompress_struct* cinfo, long num_bytes)\n{\n\tTIFF* tif=(TIFF*)cinfo->client_data;\n\t(void)num_bytes;\n\tTIFFErrorExt(tif->tif_clientdata,\"LibJpeg\",\"Unexpected error\");\n\tjpeg_encap_unwind(tif);\n}\n\nstatic boolean\nOJPEGLibjpegJpegSourceMgrResyncToRestart(jpeg_decompress_struct* cinfo, int desired)\n{\n\tTIFF* tif=(TIFF*)cinfo->client_data;\n\t(void)desired;\n\tTIFFErrorExt(tif->tif_clientdata,\"LibJpeg\",\"Unexpected error\");\n\tjpeg_encap_unwind(tif);\n\treturn(0);\n}\n\nstatic void\nOJPEGLibjpegJpegSourceMgrTermSource(jpeg_decompress_struct* cinfo)\n{\n\t(void)cinfo;\n}\n\n#endif\n\n\n/*\n * Local Variables:\n * mode: c\n * c-basic-offset: 8\n * fill-column: 78\n * End:\n */\n", "\ufeff/*\n * (c) Copyright Ascensio System SIA 2010-2019\n *\n * This program is a free software product. You can redistribute it and/or\n * modify it under the terms of the GNU Affero General Public License (AGPL)\n * version 3 as published by the Free Software Foundation. In accordance with\n * Section 7(a) of the GNU AGPL its Section 15 shall be amended to the effect\n * that Ascensio System SIA expressly excludes the warranty of non-infringement\n * of any third-party rights.\n *\n * This program is distributed WITHOUT ANY WARRANTY; without even the implied\n * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR  PURPOSE. For\n * details, see the GNU AGPL at: http://www.gnu.org/licenses/agpl-3.0.html\n *\n * You can contact Ascensio System SIA at 20A-12 Ernesta Birznieka-Upisha\n * street, Riga, Latvia, EU, LV-1050.\n *\n * The  interactive user interfaces in modified source and object code versions\n * of the Program must display Appropriate Legal Notices, as required under\n * Section 5 of the GNU AGPL version 3.\n *\n * Pursuant to Section 7(b) of the License you must retain the original Product\n * logo when distributing the program. Pursuant to Section 7(e) we decline to\n * grant you any rights under trademark law for use of our trademarks.\n *\n * All the Product's GUI elements, including illustrations and icon sets, as\n * well as technical writing content are licensed under the terms of the\n * Creative Commons Attribution-ShareAlike 4.0 International. See the License\n * terms at http://creativecommons.org/licenses/by-sa/4.0/legalcode\n *\n */\n#include <stdlib.h>\n#include <string.h>\n#include \"MemoryUtils.h\"\n#include \"FontFileEncodings.h\"\n#include \"FontFileType1.h\"\n\nnamespace NSFontConverter\n{\n    #define LINESIZE 1024\n\n    #define PFB_MARKER 128\n    #define PFB_ASCII    1\n    #define PFB_BINARY   2\n    #define PFB_DONE     3\n\n\n    #define IS_PS_NEWLINE( ch ) \\\n      ( (ch) == '\\r' ||         \\\n        (ch) == '\\n' )\n\n    #define IS_PS_SPACE( ch )  \\\n      ( (ch) == ' '         || \\\n        IS_PS_NEWLINE( ch ) || \\\n        (ch) == '\\t'        || \\\n        (ch) == '\\f'        || \\\n        (ch) == '\\0' )\n\n    // \u0422\u0430\u0431\u043b\u0438\u0446\u0430 \u0434\u043b\u044f \u0431\u044b\u0441\u0442\u0440\u043e\u0433\u043e \u043a\u043e\u043d\u0432\u0435\u0440\u0442\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u0446\u0438\u0444\u0440 (\u0434\u0435\u0441\u044f\u0442\u0438\u0447\u043d\u044b\u0445 \u0438 \u043d\u0435 \u0434\u0435\u0441\u044f\u0442\u0438\u0447\u043d\u044b\u0445) \u0432 \u0447\u0438\u0441\u043b\u0430\n    static const signed char c_arrCharTable[128] =\n    {\n        /* 0x00 */\n        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n         0,  1,  2,  3,  4,  5,  6,  7,  8,  9, -1, -1, -1, -1, -1, -1,\n        -1, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, -1, -1, -1, -1, -1,\n        -1, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, -1, -1, -1, -1, -1,\n    };\n\n    // \u041d\u0438 \u043e\u0434\u0438\u043d \u0441\u0438\u043c\u0432\u043e\u043b \u0431\u043e\u043b\u044c\u0448\u0435 >= 0x80 \u043d\u0435 \u043c\u043e\u0436\u0435\u0442 \u043f\u0440\u0435\u0434\u0441\u0442\u0430\u0432\u043b\u044f\u0442\u044c \u0447\u0438\u0441\u043b\u043e\n    #define OP  >=\n\n    #define WriteChar(Value) \\\n        nChar = (char)(Value);\\\n        pOutputFunc( pOutputStream, &nChar, 1 );\n\n    unsigned int EexecDecode   (unsigned char** cursor, unsigned char* limit, unsigned char* buffer, unsigned int n, unsigned short* seed )\n    {\n        unsigned char*  p;\n        unsigned int r;\n        unsigned int s = *seed;\n\n        p = *cursor;\n        if ( n > (unsigned int)(limit - p) )\n          n = (unsigned int)(limit - p);\n\n        for ( r = 0; r < n; r++ )\n        {\n          unsigned int  val = p[r];\n          unsigned int  b   = ( val ^ ( s >> 8 ) );\n\n\n          s         = ( (val + s)*52845U + 22719 ) & 0xFFFFU;\n          buffer[r] = (unsigned char) b;\n        }\n\n        *cursor = p + n;\n        *seed   = (unsigned short)s;\n\n        return r;\n      }\n\n    unsigned int ASCIIHexDecode(unsigned char** cursor, unsigned char* limit, unsigned char* buffer, unsigned int n)\n    {\n        unsigned char*  p;\n        unsigned int  r   = 0;\n        unsigned int  w   = 0;\n        unsigned int  pad = 0x01;\n\n\n        n *= 2;\n\n        p  = *cursor;\n        if ( n > (unsigned int)( limit - p ) )\n          n = (unsigned int)( limit - p );\n\n        /* we try to process two nibbles at a time to be as fast as possible */\n        for ( ; r < n; r++ )\n        {\n          FT_UInt  c = p[r];\n\n\n          if ( IS_PS_SPACE( c ) )\n            continue;\n\n          if ( c OP 0x80 )\n            break;\n\n          c = c_arrCharTable[c & 0x7F];\n          if ( (unsigned)c >= 16 )\n            break;\n\n          pad = ( pad << 4 ) | c;\n          if ( pad & 0x100 )\n          {\n            buffer[w++] = (FT_Byte)pad;\n            pad         = 0x01;\n          }\n        }\n\n        if ( pad != 0x01 )\n          buffer[w++] = (FT_Byte)( pad << 4 );\n\n        *cursor = p + r;\n\n        return w;\n      }\n    //------------------------------------------------------------------------\n    // CFontFileType1\n    //------------------------------------------------------------------------\n\n    CFontFileType1 *CFontFileType1::LoadFromBuffer(char *sBuffer, int nLen)\n    {\n        return new CFontFileType1(sBuffer, nLen, false);\n    }\n\n    CFontFileType1 *CFontFileType1::LoadFromFile(const wchar_t *wsFileName)\n    {\n        char *sBuffer;\n        int nLen = 0;\n\n        if ( !( sBuffer = CFontFileBase::ReadFile(wsFileName, &nLen) ) )\n            return NULL;\n\n        return new CFontFileType1(sBuffer, nLen, true);\n    }\n\n    CFontFileType1::CFontFileType1(char *sBuffer, int nLen, bool bFreeData):\n    CFontFileBase(sBuffer, nLen, bFreeData)\n    {\n        m_sName = NULL;\n        m_arrEncoding = NULL;\n\n        Parse();\n        m_bParsed = false;\n    }\n\n    CFontFileType1::~CFontFileType1()\n    {\n        if (m_sName)\n            MemUtilsFree(m_sName);\n\n        if ( m_arrEncoding && m_arrEncoding != c_arrsFontFileType1StandardEncoding )\n        {\n            for (int nIndex = 0; nIndex < 256; ++nIndex )\n            {\n                MemUtilsFree( m_arrEncoding[nIndex] );\n            }\n            MemUtilsFree(m_arrEncoding);\n        }\n    }\n\n    char *CFontFileType1::GetName()\n    {\n        if ( !m_bParsed )\n            Parse();\n\n        return m_sName;\n    }\n\n    char **CFontFileType1::GetEncoding()\n    {\n        if (!m_bParsed)\n            Parse();\n\n        return m_arrEncoding;\n    }\n\n    void CFontFileType1::WriteEncoded(char **ppNewEncoding, FontFileOutputFunc pOutputFunc, void *pOutputStream)\n    {\n        char sBuffer[512];\n        char *sLine, *sLine2, *sCurChar;\n\n        // \u043a\u043e\u043f\u0438\u0440\u0443\u0435\u043c \u0432\u0441\u0435 \u0434\u043e \u0441\u0442\u0440\u043e\u0447\u043a\u0438 /Encoding\n        for ( sLine = (char *)m_sFile; sLine && strncmp( sLine, \"/Encoding\", 9); sLine = GetNextLine(sLine) );\n        if ( !sLine )\n        {\n            // \u043d\u0435 \u043d\u0430\u0448\u043b\u0438 \u043a\u043e\u0434\u0438\u0440\u043e\u0432\u043a\u0443, \u0442\u043e\u0433\u0434\u0430 \u043a\u043e\u043f\u0438\u0440\u0443\u0435\u043c \u0446\u0435\u043b\u0438\u043a\u043e\u043c \u0444\u043e\u043d\u0442 \u0444\u0430\u0439\u043b\n            (*pOutputFunc)( pOutputStream, (char *)m_sFile, m_nLen);\n            return;\n        }\n        (*pOutputFunc)( pOutputStream, (char *)m_sFile, sLine - (char *)m_sFile);\n\n        // \u043f\u0438\u0448\u0435\u043c \u043d\u043e\u0432\u0443\u044e \u043a\u043e\u0434\u0438\u0440\u043e\u0432\u043a\u0443\n        (*pOutputFunc)( pOutputStream, \"/Encoding 256 array\\n\", 20);\n        (*pOutputFunc)( pOutputStream, \"0 1 255 {1 index exch /.notdef put} for\\n\", 40);\n        for ( int nIndex = 0; nIndex < 256; ++nIndex )\n        {\n            if (ppNewEncoding[nIndex])\n            {\n                sprintf( sBuffer, \"dup %d /%s put\\n\", nIndex, ppNewEncoding[nIndex]);\n                (*pOutputFunc)( pOutputStream, sBuffer, strlen( sBuffer ));\n            }\n        }\n        (*pOutputFunc)( pOutputStream, \"readonly def\\n\", 13);\n\n        if ( !strncmp( sLine, \"/Encoding StandardEncoding def\", 30) )\n        {\n            sLine = GetNextLine(sLine);\n        }\n        else\n        {\n            sCurChar = sLine + 10;\n            sLine = NULL;\n            for (; sCurChar < (char *)m_sFile + m_nLen; ++sCurChar)\n            {\n                if ((*sCurChar == ' ' || *sCurChar == '\\t' || *sCurChar == '\\x0a' || *sCurChar == '\\x0d' || *sCurChar == '\\x0c' || *sCurChar == '\\0') && sCurChar + 4 <= (char *)m_sFile + m_nLen && !strncmp(sCurChar + 1, \"def\", 3) )\n                {\n                    sLine = sCurChar + 4;\n                    break;\n                }\n            }\n        }\n\n        // \u0423 \u043d\u0435\u043a\u043e\u0442\u043e\u0440\u044b\u0445 \u0444\u043e\u043d\u0442\u043e\u0432 \u0434\u0432\u0435 \u0437\u0430\u043f\u0438\u0441\u0438 /Encoding, \u043f\u043e\u044d\u0442\u043e\u043c\u0443 \u043f\u0440\u043e\u0432\u0435\u0440\u044f\u0435\u043c \u043d\u0430\u043b\u0438\u0447\u0438\u0435 \u0432\u0442\u043e\u0440\u043e\u0439 \u0437\u0430\u043f\u0438\u0441\u0438\n        if ( sLine )\n        {\n            int nIndex;\n            for ( sLine2 = sLine, nIndex = 0; nIndex < 20 && sLine2 && strncmp(sLine2, \"/Encoding\", 9); sLine2 = GetNextLine(sLine2), ++nIndex) ;\n            if ( nIndex < 20 && sLine2 )\n            {\n                (*pOutputFunc)( pOutputStream, sLine, sLine2 - sLine);\n                if ( !strncmp(sLine2, \"/Encoding StandardEncoding def\", 30) )\n                {\n                    sLine = GetNextLine( sLine2 );\n                }\n                else\n                {\n                    sCurChar = sLine2 + 10;\n                    sLine = NULL;\n                    for (; sCurChar < (char *)m_sFile + m_nLen; ++sCurChar)\n                    {\n                        if ((*sCurChar == ' ' || *sCurChar == '\\t' || *sCurChar == '\\x0a' || *sCurChar == '\\x0d' || *sCurChar == '\\x0c' || *sCurChar == '\\0') && sCurChar + 4 <= (char *)m_sFile + m_nLen && !strncmp(sCurChar + 1, \"def\", 3) )\n                        {\n                            sLine = sCurChar + 4;\n                            break;\n                        }\n                    }\n                }\n            }\n\n            // \u043a\u043e\u043f\u0438\u0440\u0443\u0435\u043c \u0432\u0441\u0435 \u043f\u043e\u0441\u043b\u0435 \u043a\u043e\u0434\u0438\u0440\u043e\u0432\u043a\u0438\n            if ( sLine )\n            {\n                (*pOutputFunc)( pOutputStream, sLine, ((char *)m_sFile + m_nLen) - sLine );\n            }\n        }\n    }\n\n    char *CFontFileType1::GetNextLine(char *sLine)\n    {\n        while ( sLine < (char *)m_sFile + m_nLen && *sLine != '\\x0a' && *sLine != '\\x0d')\n            ++sLine;\n\n        if ( sLine < (char *)m_sFile + m_nLen && *sLine == '\\x0d')\n            ++sLine;\n\n        if ( sLine < (char *)m_sFile + m_nLen && *sLine == '\\x0a')\n            ++sLine;\n\n        if ( sLine >= (char *)m_sFile + m_nLen )\n            return NULL;\n\n        return sLine;\n    }\n\n    void CFontFileType1::Parse()\n    {\n        // \u0421\u043d\u0430\u0447\u0430\u043b\u0430 \u043f\u0440\u043e\u0432\u0435\u0440\u0438\u043c, \u0435\u0441\u043b\u0438 \u044d\u0442\u043e pfb \u0444\u0430\u0439\u043b, \u0442\u043e\u0433\u0434\u0430 \u0438\u0437\u0431\u0430\u0432\u0438\u043c\u0441\u044f \u043e\u0442 \u0432\u0441\u0435\u0445 \u0435\u0433\u043e \u043c\u0430\u0440\u043a\u0435\u0440\u043e\u0432.\n        Reset();\n\n        while( m_nPos < m_nLen && ( ' ' == m_sFile[m_nPos] || '\\t' == m_sFile[m_nPos] || '\\r' == m_sFile[m_nPos] || '\\n' == m_sFile[m_nPos] ) )\n            ++m_nPos;\n\n        bool bSuccess = true;\n        int nChar = GetU8( m_nPos, &bSuccess );\n        if ( !bSuccess || ( PFB_MARKER != nChar && '%' != nChar ) )\n            return;\n        else if ( PFB_MARKER == nChar )\n        {\n            if ( !RemovePfbMarkers() )\n                return;\n        }\n\n        char *sLine, *sLine1, *pCur, *pTemp;\n        char sBuffer[256];\n        int nCount, nCode;\n        int nIndex = 0;\n        unsigned char *sEexec = NULL;\n\n        m_oTopDict.arrdFontBBox[0] = 0; m_oTopDict.arrdFontBBox[1] = 0;\n        m_oTopDict.arrdFontBBox[2] = 0; m_oTopDict.arrdFontBBox[3] = 0;\n\n        m_oTopDict.arrdFontMatrix[0] = 0.001; m_oTopDict.arrdFontMatrix[1] = 0;\n        m_oTopDict.arrdFontMatrix[2] = 0;     m_oTopDict.arrdFontMatrix[3] = 0.001;\n        m_oTopDict.arrdFontMatrix[4] = 0;     m_oTopDict.arrdFontMatrix[5] = 0;\n\n        for (nIndex = 1, sLine = (char *)m_sFile; nIndex <= 100 && sLine && (!m_sName || !m_arrEncoding); ++nIndex )\n        {\n            if ( !m_sName && !strncmp( sLine, \"/FontName\", 9) )\n            {\n                strncpy( sBuffer, sLine, 255);\n                sBuffer[255] = '\\0';\n                if ( ( pCur = strchr( sBuffer + 9, '/' ) ) && ( pCur = strtok( pCur + 1, \" \\t\\n\\r\" ) ) )\n                {\n                    m_sName = CopyString( pCur );\n                }\n                sLine = GetNextLine(sLine);\n\n            }\n            else if ( !strncmp( sLine, \"/FontMatrix\", 11 ) )\n            {\n                strncpy( sBuffer, sLine, 255);\n                sBuffer[255] = '\\0';\n\n                ReadDoubleArray<6>( (unsigned char*)(sBuffer + 11), 244, m_oTopDict.arrdFontMatrix );\n                sLine = GetNextLine( sLine );\n            }\n            else if ( !strncmp( sLine, \"/FontBBox\", 9 ) )\n            {\n                strncpy( sBuffer, sLine, 255);\n                sBuffer[255] = '\\0';\n\n                ReadDoubleArray<4>( (unsigned char*)(sBuffer + 9), 246, m_oTopDict.arrdFontBBox );\n                sLine = GetNextLine( sLine );\n            }\n            else if (!m_arrEncoding && !strncmp( sLine, \"/Encoding StandardEncoding def\", 30))\n            {\n                m_arrEncoding = c_arrsFontFileType1StandardEncoding;\n            }\n            else if (!m_arrEncoding && !strncmp( sLine, \"/Encoding 256 array\", 19))\n            {\n                m_arrEncoding = (char **)MemUtilsMallocArray(256, sizeof(char *));\n                int nJ = 0;\n                for (nJ = 0; nJ < 256; ++nJ )\n                {\n                    m_arrEncoding[nJ] = NULL;\n                }\n                for (nJ = 0, sLine = GetNextLine(sLine); nJ < 300 && sLine && ( sLine1 = GetNextLine( sLine )); ++nJ, sLine = sLine1)\n                {\n                    if ( ( nCount = sLine1 - sLine ) > 255 )\n                    {\n                        nCount = 255;\n                    }\n                    strncpy( sBuffer, sLine, nCount);\n                    sBuffer[ nCount ] = '\\0';\n                    for ( pCur = sBuffer; *pCur == ' ' || *pCur == '\\t'; ++pCur );\n                    if ( !strncmp( pCur, \"dup\", 3 ) )\n                    {\n                        for ( pCur += 3; *pCur == ' ' || *pCur == '\\t'; ++pCur ) ;\n                        for ( pTemp = pCur; *pTemp >= '0' && *pTemp <= '9'; ++pTemp ) ;\n                        if ( *pTemp )\n                        {\n                            char nChar = *pTemp;\n                            *pTemp = '\\0';\n                            nCode = atoi( pCur );\n\t\t\t\t\t\t\tif (nCode < 0) nCode = 0;\t\t\t\t\t\t\t\t\n                            *pTemp = nChar;\n                            if ( nCode == 8 && *pTemp == '#')\n                            {\n                                nCode = 0;\n                                for (++pTemp; *pTemp >= '0' && *pTemp <= '7'; ++pTemp)\n                                {\n                                    nCode = nCode * 8 + (*pTemp - '0');\n                                }\n                            }\n                            if ( nCode < 256 )\n                            {\n                                for ( pCur = pTemp; *pCur == ' ' || *pCur == '\\t'; ++pCur ) ;\n                                if ( *pCur == '/')\n                                {\n                                    ++pCur;\n                                    for ( pTemp = pCur; *pTemp && *pTemp != ' ' && *pTemp != '\\t'; ++pTemp ) ;\n                                    *pTemp = '\\0';\n                                    m_arrEncoding[ nCode ] = CopyString( pCur );\n                                }\n                            }\n                        }\n                    }\n                    else\n                    {\n                        if ( strtok( sBuffer, \" \\t\") && ( pCur = strtok(NULL, \" \\t\\n\\r\")) && !strcmp( pCur, \"def\"))\n                        {\n                            break;\n                        }\n                    }\n                }\n            }\n            else\n            {\n                if ( !sEexec )\n                    sEexec = (unsigned char*)strstr( sLine, \"currentfile eexec\" );\n\n                sLine = GetNextLine(sLine);\n            }\n        }\n\n        if ( NULL != sEexec )\n        {\n            unsigned char* sTemp = sEexec;\n            while ( sTemp != (unsigned char*)strstr( (char*)sTemp, \"cleartomark\" ) && sTemp < m_sFile + m_nLen )\n                sTemp++;\n\n            int nBufferLen = sTemp - ( sEexec + 17 );\n            unsigned char *sEexecBuffer = (unsigned char*)MemUtilsMalloc( nBufferLen );\n            if ( !sEexecBuffer )\n                return;\n\n            memcpy( sEexecBuffer, sEexec + 17, nBufferLen );\n            DecryptEexec( &sEexecBuffer, nBufferLen );\n\n            sEexec = sEexecBuffer + 4; // \u041f\u0435\u0440\u0432\u044b\u0435 \u0447\u0435\u0442\u044b\u0440\u0435 \u0431\u0430\u0439\u0442\u0430 \u0431\u044b\u043b\u0438 \u0441\u043b\u0443\u0447\u0430\u0439\u043d\u044b\u043c\u0438\n            int nEexecLen = nBufferLen - 4;\n\n            // \u0422\u0435\u043f\u0435\u0440\u044c \u043f\u0440\u043e\u0447\u0438\u0442\u0430\u0435\u043c \u0441\u043e\u0434\u0435\u0440\u0436\u0438\u043c\u043e\u0435 Private Dict\n            bool bGlyphsSection = false, bSubrsSection = false;\n            //unsigned short ushChar = '';\n            std::wstring sToken, sGlyph;\n            int nLength = 0;\n\n            // \u0412\u044b\u0441\u0442\u0430\u0432\u043b\u044f\u0435\u043c \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f \u043f\u043e \u0443\u043c\u043e\u043b\u0447\u0430\u043d\u0438\u044e \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u043e\u0432 Private Dict\n            m_oPrivateDict.nBlueValues       = 0;\n            m_oPrivateDict.nOtherBlues       = 0;\n            m_oPrivateDict.nFamilyBlues      = 0;\n            m_oPrivateDict.nFamilyOtherBlues = 0;\n            m_oPrivateDict.dBlueScale        = 0.039625;\n            m_oPrivateDict.nBlueShift        = 7;\n            m_oPrivateDict.nBlueFuzz         = 1;\n            m_oPrivateDict.bHasStdHW         = false;\n            m_oPrivateDict.bHasStdVW         = false;\n            m_oPrivateDict.nStemSnapH        = 0;\n            m_oPrivateDict.nStemSnapV        = 0;\n            m_oPrivateDict.bHasForceBold     = false;\n            m_oPrivateDict.nLanguageGroup    = 0;\n            m_oPrivateDict.nLenIV            = 4;\n            m_oPrivateDict.dExpansionFactor  = 0.06;\n\n            for ( int nIndex = 0; nIndex < nEexecLen; nIndex++ )\n            {\n                unsigned char nChar = sEexec[nIndex];\n\n                if ( ( bGlyphsSection || bSubrsSection ) && 'R' == nChar && nLength > 0 )\n                {\n                    unsigned char *sData = new unsigned char[nLength];\n                    if ( sData )\n                    {\n                        memcpy( sData, sEexec + nIndex + 3, nLength );\n                        unsigned short unKey = 4330U;\n                        unsigned char *sCur = sData;\n                        EexecDecode( &sCur, sCur + nLength, sCur, nLength, &unKey );\n\n                        if ( m_oPrivateDict.nLenIV > 0 && m_oPrivateDict.nLenIV < nLength )\n                        {\n                            Type1Charstring oCharstring = DecodeCharString( sData + m_oPrivateDict.nLenIV, nLength - m_oPrivateDict.nLenIV );\n                            if ( bGlyphsSection )\n                            {\n                                int nUnicode = Type1NameToUnicodeW( sGlyph.c_str() );\n\n                                if ( 0 != nUnicode )\n                                    m_arrCharstrings.Add( Type1Glyph( sGlyph, nUnicode, oCharstring )  );\n                            }\n                            else // if ( bSubrsSection )\n                            {\n                                m_arrSubrs.Add( oCharstring );\n                            }\n                        }\n\n                        delete []sData;\n                    }\n\n                    nIndex += nLength + 3;\n                }\n                else if ( IS_PS_SPACE( nChar ) )\n                {\n                    nLength = Utils::GetInteger( sToken );\n                    sToken.clear();\n                }\n                else\n                {\n                    sToken.push_back( (wchar_t)nChar );\n                    if ( !bGlyphsSection && '/' == sToken[0] )\n                    {\n                        int nTempChar = sToken[1];\n                        switch (nTempChar)\n                        {\n                        case 'B':\n                            {\n                                if ( L\"/BlueValues\" == sToken )\n                                    m_oPrivateDict.nBlueValues = ReadIntArray<type1MaxBlueValues>( sEexec + nIndex + 2, nEexecLen - nIndex - 2, m_oPrivateDict.arrnBlueValues );\n                                else if ( L\"/BlueScale\" == sToken )\n                                    m_oPrivateDict.dBlueScale  = ReadDouble( sEexec + nIndex + 1, nEexecLen - nIndex - 1 );\n                                else if ( L\"/BlueShift\" == sToken )\n                                    m_oPrivateDict.nBlueShift  = ReadInt( sEexec + nIndex + 1, nEexecLen - nIndex - 1 );\n                                else if ( L\"/BlueFuzz\" == sToken )\n                                    m_oPrivateDict.nBlueFuzz   = ReadInt( sEexec + nIndex + 1, nEexecLen - nIndex - 1 );\n\n                                break;\n                            }\n                        case 'C':\n                            {\n                                if ( L\"/CharString\" == sToken )\n                                    bGlyphsSection = true;\n\n                                break;\n                            }\n                        case 'E':\n                            {\n                                if ( L\"/ExpansionFactor\" == sToken )\n                                    m_oPrivateDict.dExpansionFactor = ReadDouble( sEexec + nIndex + 1, nEexecLen - nIndex - 1 );\n\n                                break;\n                            }\n                        case 'F':\n                            {\n                                if ( L\"/FamilyBlues\" == sToken )\n                                    m_oPrivateDict.nFamilyBlues = ReadIntArray<type1MaxBlueValues>( sEexec + nIndex + 2, nEexecLen - nIndex - 2, m_oPrivateDict.arrnFamilyBlues );\n                                else if ( L\"/FamilyOtherBlues\" == sToken )\n                                    m_oPrivateDict.nFamilyOtherBlues = ReadIntArray<type1MaxOtherBlues>( sEexec + nIndex + 2, nEexecLen - nIndex - 2, m_oPrivateDict.arrnFamilyOtherBlues );\n                                else if ( L\"/ForceBold\" == sToken )\n                                {\n                                    m_oPrivateDict.bHasForceBold = true;\n                                    m_oPrivateDict.bForceBold = ReadBool( sEexec + nIndex + 1, nEexecLen - nIndex - 1 );\n                                }\n\n                                break;\n                            }\n                        case 'L':\n                            {\n                                if ( L\"/LanguageGroup\" == sToken )\n                                    m_oPrivateDict.nLanguageGroup = ReadInt( sEexec + nIndex + 1, nEexecLen - nIndex - 1 );\n                                else if ( L\"/lenIV\" == sToken )\n                                    m_oPrivateDict.nLenIV = ReadInt( sEexec + nIndex + 1, nEexecLen - nIndex - 1 );\n\n                                break;\n                            }\n                        case 'S':\n                            {\n                                if ( L\"/Subrs\" == sToken )\n                                    bSubrsSection = true;\n                                else if ( L\"/StemSnapH\" == sToken )\n                                    m_oPrivateDict.nStemSnapH = ReadDoubleArray<type1MaxStemSnap>( sEexec + nIndex + 2, nEexecLen - nIndex - 2, m_oPrivateDict.arrdStemSnapH );\n                                else if ( L\"/StemSnapV\" == sToken )\n                                    m_oPrivateDict.nStemSnapV = ReadDoubleArray<type1MaxStemSnap>( sEexec + nIndex + 2, nEexecLen - nIndex - 2, m_oPrivateDict.arrdStemSnapV );\n                                else if ( L\"/StdHW\" == sToken )\n                                {\n                                    // \u0417\u0434\u0435\u0441\u044c \u0441\u043e\u0434\u0435\u0440\u0436\u0438\u0442\u0441\u044f \u043c\u0430\u0441\u0441\u0438\u0432 \u0441 \u043e\u0434\u043d\u0438\u043c \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435\u043c\n                                    double dTemp[1];\n\n                                    if ( ReadDoubleArray<1>( sEexec + nIndex + 2, nEexecLen - nIndex - 2, dTemp ) > 0 )\n                                    {\n                                        m_oPrivateDict.bHasStdHW = true;\n                                        m_oPrivateDict.dStdHW = dTemp[0];\n                                    }\n                                }\n                                else if ( L\"/StdVW\" == sToken )\n                                {\n                                    // \u0417\u0434\u0435\u0441\u044c \u0441\u043e\u0434\u0435\u0440\u0436\u0438\u0442\u0441\u044f \u043c\u0430\u0441\u0441\u0438\u0432 \u0441 \u043e\u0434\u043d\u0438\u043c \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435\u043c\n                                    double dTemp[1];\n                                    if ( ReadDoubleArray<1>( sEexec + nIndex + 2, nEexecLen - nIndex - 2, dTemp ) > 0 )\n                                    {\n                                        m_oPrivateDict.bHasStdHW = true;\n                                        m_oPrivateDict.dStdVW = dTemp[0];\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    else if ( '/' == nChar  )\n                    {\n                        sToken.clear();\n                        sGlyph.clear();\n\n                        while ( nIndex < nEexecLen && ( nChar = sEexec[++nIndex] ) != ' ' )\n                            sGlyph.push_back( (wchar_t)nChar );\n                    }\n                }\n            }\n            MemUtilsFree( sEexecBuffer );\n\n            // \u041f\u0440\u043e\u0432\u0435\u0434\u0435\u043c \u0441\u043e\u0440\u0442\u0438\u0440\u043e\u0432\u043a\u0443 \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u043e\u0432 m_arrCharstrings \u043f\u043e \u044e\u043d\u0438\u043a\u043e\u0434\u043d\u043e\u043c\u0443 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044e\n            qsort( m_arrCharstrings.GetData(), m_arrCharstrings.GetSize(), sizeof(Type1Glyph), CompareType1Glyph );\n        }\n\n        m_bParsed = true;\n    }\n\n    void CFontFileType1::DecryptEexec(unsigned char** ppEexecBuffer, int nLen)\n    {\n        // \u0421\u043e\u0433\u043b\u0430\u0441\u043d\u043e \u0441\u043f\u0435\u0446\u0438\u0444\u0438\u043a\u0430\u0446\u0438\u0438 Type1, \u043f\u0435\u0440\u0432\u044b\u0439 \u0431\u0430\u0439\u0442 \u043d\u0435 \u0434\u043e\u043b\u0436\u0435\u043d \u0431\u044b\u0442\u044c ASCII \u043f\u0440\u043e\u0431\u0435\u043b\u043e\u043c\n        // (\u043f\u0440\u043e\u0431\u0435\u043b, \u0442\u0430\u0431, \u043f\u0435\u0440\u0435\u043d\u043e\u0441 \u043a\u0430\u0440\u0435\u0442\u043a\u0438 \u0438\u043b\u0438 \u043f\u0435\u0440\u0435\u043d\u043e\u0441 \u0441\u0442\u0440\u043e\u043a\u0438).\n        unsigned char *sCur = (unsigned char*)(*ppEexecBuffer);\n        while( sCur < (unsigned char*)(*ppEexecBuffer) + nLen && ( ' ' == *sCur || '\\t' == *sCur || '\\r' == *sCur || '\\n' == *sCur ) )\n            ++sCur;\n\n        // \u0422\u0435\u043f\u0435\u0440\u044c \u043d\u0430\u043c \u043d\u0430\u0434\u043e \u043e\u043f\u0440\u0435\u0434\u0435\u043b\u0438\u0442\u044c \u0432 \u043a\u0430\u043a\u043e\u043c \u0444\u043e\u0440\u043c\u0430\u0442\u0435 \u0443 \u043d\u0430\u0441 \u0434\u0430\u043d\u043d\u044b\u0435: ASKII \u0438\u043b\u0438 \u0431\u0438\u043d\u0430\u0440\u043d\u044b\u0435 \u0434\u0430\u043d\u043d\u044b\u0435.\n        // \u0415\u0441\u043b\u0438 \u043f\u0435\u0440\u0432\u044b\u0435 \u0447\u0435\u0442\u044b\u0440\u0435 \u0431\u0430\u0439\u0442\u0430 \u044f\u0432\u043b\u044f\u044e\u0442\u0441\u044f \u0448\u0435\u0441\u0442\u043d\u0430\u0434\u0446\u0430\u0442\u0438\u0440\u0438\u0447\u043d\u044b\u043c\u0438 \u0441\u0438\u043c\u0432\u043e\u043b\u0430\u043c\u0438, \u0437\u043d\u0430\u0447\u0438\u0442, \u043a\u043e\u0434\u0438\u0440\u043e\u0432\u043a\u0430 ASCII.\n        bool bASCII = false;\n\n        if ( isxdigit( sCur[0] ) && isxdigit( sCur[1] ) && isxdigit( sCur[2] ) && isxdigit( sCur[3] ) )\n            bASCII = true;\n\n        if ( bASCII )\n            ASCIIHexDecode( &sCur, sCur + nLen, sCur, nLen );\n\n        unsigned short ushKey = 55665U;\n        EexecDecode( &sCur, *ppEexecBuffer + nLen, sCur, nLen, &ushKey );\n    }\n    bool CFontFileType1::RemovePfbMarkers()\n    {\n        bool bSuccess = true;\n\n        int nBlockType = 0;\n        int nBlockLen  = 0;\n        int nChar = 0;\n\n        unsigned char *sBuffer = NULL;\n        unsigned int nBufLen = 0;\n\n        while ( nBlockType != PFB_DONE )\n        {\n            while ( 0 == nBlockLen )\n            {\n                nChar = ReadU8( &bSuccess );\n                if ( !bSuccess )\n                    return false;\n\n                nBlockType = ReadU8( &bSuccess );\n                if ( !bSuccess || PFB_MARKER != nChar || ( PFB_ASCII != nBlockType && PFB_BINARY != nBlockType && PFB_DONE != nBlockType ) )\n                    return false;\n\n                if ( PFB_DONE == nBlockType )\n                    break;\n\n                nBlockLen = ReadU32LE( &bSuccess );\n                if ( !bSuccess )\n                    return false;\n            }\n\n            // \u0427\u0438\u0442\u0430\u0435\u043c \u0441\u0430\u043c \u0431\u043b\u043e\u043a \u0434\u0430\u043d\u043d\u044b\u0445\n            if ( nBlockLen > 0 )\n            {\n                if ( !sBuffer )\n                {\n                    sBuffer = (unsigned char*)MemUtilsMalloc( nBlockLen );\n                    if ( !sBuffer )\n                        return false;\n                }\n                else\n                    sBuffer = (unsigned char*)MemUtilsRealloc( sBuffer, nBufLen + nBlockLen );\n\n                Read( sBuffer + nBufLen, nBlockLen );\n                nBufLen += nBlockLen;\n            }\n            nBlockLen = 0;\n        }\n\n        if ( m_bFreeFileData )\n            MemUtilsFree( m_sFile );\n\n        m_bFreeFileData = true;\n        m_sFile         = (unsigned char*)sBuffer;\n        m_sFileData     = m_sFile;\n        m_nLen          = nBufLen;\n        m_nPos          = 0;\n\n        return true;\n    }\n\n    Type1Charstring CFontFileType1::DecodeCharString(unsigned char *sString, int nLen)\n    {\n        CArray<Type1CharstringItem> sCharString;\n\n        int nLSB = 0, nWidth = 0;\n\n        for ( int nIndex = 0; nIndex < nLen; nIndex++ )\n        {\n            int nValue = sString[nIndex];\n\n            if ( nValue < 32 ) // \u043a\u043e\u043c\u0430\u043d\u0434\u0430\n            {\n                int nCommand = 0;\n\n                if ( 12 == nValue )\n                {\n                    int nNextValue = sString[++nIndex];\n\n                    if ( 16 == nNextValue )\n                    {\n                        if ( sCharString.GetSize() <= 0 )\n                            continue;\n\n                        int nInd = sCharString[sCharString.GetSize() - 1].nValue;\n                        sCharString.RemoveAt( sCharString.GetSize() - 1 );\n\n                        while ( sCharString.GetSize() > 0 && false == sCharString[sCharString.GetSize() - 1].bCommand )\n                            sCharString.RemoveAt( sCharString.GetSize() - 1 );\n\n                        // If the flex mechanishm is not used in a font program, Adobe\n                        // state that that entries 0, 1 and 2 can simply be replace by\n                        // {}, which means that we can simply ignore them.\n                        if ( nInd < 3 )\n                            continue;\n\n                        // This is the same things about hint replacement, if it is not used\n                        // entry 3 can be replaced by {3}\n                        if ( 3 == nInd )\n                        {\n                            sCharString.Add( Type1CharstringItem( 3, true ) );\n                            nIndex++;\n                            continue;\n                        }\n                    }\n\n                    nCommand = 12 + ( nNextValue << 8 );\n                }\n                else\n                {\n                    if ( 13 == nValue )\n                    {\n                        if ( 2 == sCharString.GetSize() )\n                            nWidth = sCharString[1].nValue;\n                        else if ( 4 == sCharString.GetSize() && 0x0C0C == sCharString[3].nValue && sCharString[3].bCommand )\n                            nWidth = sCharString[1].nValue / sCharString[2].nValue;\n                        else\n                        {\n                            // TO DO: \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u0430\u0442\u044c \u043e\u0448\u0438\u0431\u043a\u0443\n                            nWidth = 0;\n                        }\n\n                        if ( sCharString.GetSize() > 0 )\n                        {\n                            nLSB = sCharString[0].nValue;\n                            sCharString.Add( Type1CharstringItem( nLSB, false ) );\n                            sCharString.Add( Type1CharstringItem( c_nType1hmoveto, true ) );\n                            sCharString.RemoveAt( 0 );\n                        }\n                        else\n                        {\n                            nLSB = 0;\n                            sCharString.Add( Type1CharstringItem( nLSB, false ) );\n                            sCharString.Add( Type1CharstringItem( c_nType1hmoveto, true ) );\n                        }\n\n                        continue;\n                    }\n\n                    nCommand = nValue;\n                }\n\n                // Some charstring commands are meaningless in Type2 and will return\n                // a null, let's just ignored them\n                if ( !nCommand && nIndex < nLen )\n                    continue;\n                else if ( !nCommand )\n                    break;\n                else if ( c_nType1seac == nCommand || c_nType1sbw == nCommand )\n                {\n                    // TO DO: \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u0430\u0442\u044c \u043e\u0448\u0438\u0431\u043a\u0443\n                }\n\n                sCharString.Add( Type1CharstringItem( nCommand, true ) );\n            }\n            else\n            {\n                if ( nValue <= 246 )\n                    nValue = nValue - 139;\n                else if ( nValue <= 250 )\n                    nValue =  ( ( nValue - 247 ) * 256 ) + (int)( sString[++nIndex] ) + 108;\n                else if ( nValue <= 254 )\n                    nValue = -( ( nValue - 251 ) * 256 ) - (int)( sString[++nIndex] ) - 108;\n                else\n                    nValue = ( sString[++nIndex] & 0xff ) << 24 | ( sString[++nIndex] & 0xff ) << 16 | ( sString[++nIndex] & 0xff ) << 8 | ( sString[++nIndex] & 0xff ) << 0;\n\n                sCharString.Add( Type1CharstringItem( nValue, false ) );\n            }\n        }\n\n        return Type1Charstring( sCharString, nWidth, nLSB );\n    }\n    Type1Charstring CFontFileType1::FlattenCharstring(Type1Charstring& oCharstring, int nBias)\n    {\n        Type1Charstring oNew;\n        oNew.nLSB   = oCharstring.nLSB;\n        oNew.nWidth = oCharstring.nWidth;\n\n        for ( int nIndex = 0; nIndex < oCharstring.arrCharstring.GetSize(); nIndex++ )\n        {\n            Type1CharstringItem oItem = oCharstring.arrCharstring[nIndex];\n            int nValue = oItem.nValue;\n            if ( oItem.bCommand )\n            {\n                if ( nValue == c_nType1sub )\n                {\n                    oNew.arrCharstring.Add( Type1CharstringItem( 12, true ) );\n                    oNew.arrCharstring.Add( Type1CharstringItem( 11, true ) );\n                }\n                else if ( nValue == c_nType1div )\n                {\n                    oNew.arrCharstring.Add( Type1CharstringItem( 12, true ) );\n                    oNew.arrCharstring.Add( Type1CharstringItem( 12, true ) );\n                }\n                else if ( nValue == c_nType1pop )\n                {\n                    //oNew.arrCharstring.Add( Type1CharstringItem( 1, true ) );\n                    oNew.arrCharstring.Add( Type1CharstringItem( 12, true ) );\n                    oNew.arrCharstring.Add( Type1CharstringItem( 18, true ) );\n                }\n                else if ( nValue == c_nType1callsubr  )\n                {\n                    //int nTempLen = oNew.arrCharstring.GetSize();\n                    //int nT1 = oNew.arrCharstring[nTempLen - 2].nValue;\n                    //int nT2 = oNew.arrCharstring[nTempLen - 1].nValue;\n                    //int nInd = nT1 << 8 | nT2;\n\n                    //if ( 107 == nBias )\n                    //{\n                    //\tif ( nInd <= 215 )\n                    //\t{\n                    //\t\toNew.arrCharstring.RemoveAt( nTempLen - 1 );\n                    //\t\toNew.arrCharstring.RemoveAt( nTempLen - 2 );\n\n                    //\t\toNew.arrCharstring[nTempLen - 3].nValue = nInd - nBias + 139;\n                    //\t\toNew.arrCharstring.Add( Type1CharstringItem( oItem.nValue, true ) );\n                    //\t}\n                    //\telse\n                    //\t{\n                    //\t\toNew.arrCharstring.RemoveAt( nTempLen - 1 );\n\n                    //\t\toNew.arrCharstring[nTempLen - 3].nValue = ((nInd - nBias) - 108) / 256 + 247;\n                    //\t\toNew.arrCharstring[nTempLen - 2].nValue = ((nInd - nBias) - 108) - (oNew.arrCharstring[nTempLen - 3].nValue - 247) * 256;\n                    //\t\toNew.arrCharstring.Add( Type1CharstringItem( oItem.nValue, true ) );\n                    //\t}\n                    //}\n                    //else\n                    //{\n\n                    //\tnInd -= nBias;\n                    //\toNew.arrCharstring[nTempLen - 2].nValue = nInd >> 8;\n                    //\toNew.arrCharstring[nTempLen - 1].nValue = nInd & 0xFF;\n                    //\toNew.arrCharstring.Add( Type1CharstringItem( oItem.nValue, true ) );\n                    //}\n                    oNew.arrCharstring.Add( Type1CharstringItem( oItem.nValue, true ) );\n                }\n                else\n                    oNew.arrCharstring.Add( Type1CharstringItem( oItem.nValue, true ) );\n            }\n            else\n            {\n                // Type1 charstrings \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u044e\u0442 \u0434\u0435\u043b\u0435\u043d\u0438\u044f \u0434\u043b\u044f \u0447\u0438\u0441\u0435\u043b \u0431\u043e\u043b\u044c\u0448\u0438\u0445 32000\n                if ( oItem.nValue > 32000 )\n                {\n                    int nDivisor = oCharstring.arrCharstring[nIndex + 1].nValue;\n                    if ( 0 != nDivisor )\n                        nValue /= nDivisor;\n                }\n                oNew.arrCharstring.Add( Type1CharstringItem( 28, true ) );\n                oNew.arrCharstring.Add( Type1CharstringItem( nValue >> 8, false ) );\n                oNew.arrCharstring.Add( Type1CharstringItem( nValue & 0xFF, false ) );\n            }\n        }\n\n        return oNew;\n    }\n    void CFontFileType1::CFFCreateIndexHeader(FontFileOutputFunc pOutputFunc, void *pOutputStream, CArray<std::wstring> aObjects)\n    {\n        char nChar;\n        int nCount = aObjects.GetSize();\n        if ( 0 == nCount )\n        {\n            pOutputFunc( pOutputStream, \"\\x00\\x00\\x00\", 3 );\n            return;\n        }\n\n        // \u041f\u0435\u0440\u0432\u044b\u0435 \u0434\u0432\u0430 \u0431\u0430\u0439\u0442\u0430 - \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u043e\u0432\n        WriteChar( nCount >> 8 );\n        WriteChar( nCount & 0xFF );\n        // \u0420\u0430\u0437\u043c\u0435\u0440 \u0441\u0434\u0432\u0438\u0433\u043e\u0432, \u0441\u0442\u0430\u0432\u0438\u043c \u043f\u043e \u043c\u0430\u043a\u0441\u0438\u043c\u0443\u043c\u0443\n        WriteChar( 0x04 );\n\n        int nRelativeOffset = 1;\n        for ( int nIndex = 0; nIndex < nCount + 1; nIndex++ )\n        {\n            WriteChar( (nRelativeOffset >> 24) & 0xFF );\n            WriteChar( (nRelativeOffset >> 16) & 0xFF );\n            WriteChar( (nRelativeOffset >>  8) & 0xFF );\n            WriteChar( (nRelativeOffset)       & 0xFF );\n\n            if ( nIndex < nCount )\n                nRelativeOffset += aObjects[nIndex].length();\n        }\n\n        for ( int nIndex = 0; nIndex < nCount; nIndex++ )\n        {\n            std::string sCur = U_TO_UTF8((aObjects[nIndex]));\n            pOutputFunc( pOutputStream, sCur.c_str(), sCur.length() );\n        }\n    }\n    void CFontFileType1::CFFCreateIndexHeader(FontFileOutputFunc pOutputFunc, void *pOutputStream, CArray<Type1Charstring> aObjects)\n    {\n        char nChar;\n        int nCount = aObjects.GetSize();\n        if ( 0 == nCount )\n        {\n            pOutputFunc( pOutputStream, \"\\x00\\x00\\x00\", 3 );\n            return;\n        }\n\n        // \u041f\u0435\u0440\u0432\u044b\u0435 \u0434\u0432\u0430 \u0431\u0430\u0439\u0442\u0430 - \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u043e\u0432\n        WriteChar( nCount >> 8 );\n        WriteChar( nCount & 0xFF );\n        // \u0420\u0430\u0437\u043c\u0435\u0440 \u0441\u0434\u0432\u0438\u0433\u043e\u0432, \u0441\u0442\u0430\u0432\u0438\u043c \u043f\u043e \u043c\u0430\u043a\u0441\u0438\u043c\u0443\u043c\u0443\n        WriteChar( 0x04 );\n\n        int nRelativeOffset = 1;\n        for ( int nIndex = 0; nIndex < nCount + 1; nIndex++ )\n        {\n            WriteChar( (nRelativeOffset >> 24) & 0xFF );\n            WriteChar( (nRelativeOffset >> 16) & 0xFF );\n            WriteChar( (nRelativeOffset >>  8) & 0xFF );\n            WriteChar( (nRelativeOffset)       & 0xFF );\n\n            if ( nIndex < nCount )\n                nRelativeOffset += aObjects[nIndex].arrCharstring.GetSize();\n        }\n\n        for ( int nI = 0; nI < nCount; nI++ )\n        {\n            for ( int nJ = 0; nJ < aObjects[nI].arrCharstring.GetSize(); nJ++ )\n            {\n                WriteChar( aObjects[nI].arrCharstring[nJ].nValue & 0xFF );\n            }\n        }\n    }\n    void CFontFileType1::CFFEncodeNumber(FontFileOutputFunc pOutputFunc, void *pOutputStream, int nValue, bool bForceLong)\n    {\n        char nChar;\n        if ( !bForceLong && nValue >= -32768 && nValue <= 32767 )\n        {\n            WriteChar( 0x1c );\n            WriteChar( ( nValue >> 8 ) & 0xFF );\n            WriteChar( nValue & 0xFF );\n        }\n        else // if ( nValue >= (-2147483648) && nValue <= 2147483647 )\n        {\n            WriteChar( 0x1d );\n            WriteChar( ( nValue >> 24 ) & 0xFF );\n            WriteChar( ( nValue >> 16 ) & 0xFF );\n            WriteChar( ( nValue >>  8 ) & 0xFF );\n            WriteChar( nValue & 0xFF );\n        }\n    }\n    void CFontFileType1::CFFEncodeNumber(FontFileOutputFunc pOutputFunc, void *pOutputStream, double dValue)\n    {\n        char nChar = 0;\n\n        WriteChar( 0x1e ); // \u043d\u0430\u0447\u0430\u043b\u043e \u0434\u0435\u0441\u044f\u0442\u0438\u0447\u043d\u043e\u0433\u043e \u0447\u0438\u0441\u043b\u0430\n\n        std::wstring sValue = std::to_wstring(dValue);\n        bool bFirstNibble = true;\n        for ( int nIndex = 0; nIndex < sValue.length(); nIndex++ )\n        {\n            int nCurChar = sValue.c_str()[ nIndex ];\n            if ( '0' <= nCurChar && nCurChar <= '9' )\n                nCurChar -= (int)('0');\n            else if ( '.' == nCurChar )\n                nCurChar = 0x0a;\n            else if ( '-' == nCurChar )\n                nCurChar = 0x0e;\n            else\n                continue;\n\n            if ( bFirstNibble )\n                nChar = nCurChar << 4;\n            else\n            {\n                nChar += nCurChar;\n                WriteChar( nChar );\n            }\n\n            bFirstNibble = !bFirstNibble;\n        }\n\n        // \u0417\u0430\u043f\u0438\u0441\u044b\u0432\u0430\u0435\u043c \u043e\u043a\u043e\u043d\u0447\u0430\u043d\u0438\u0435\u0434\u0435\u0441\u044f\u0442\u0438\u0447\u043d\u043e\u0433\u043e \u0447\u0438\u0441\u043b\u0430\n        if ( bFirstNibble )\n            nChar = (char)0xff;\n        else\n            nChar += 0x0f;\n\n        WriteChar( nChar );\n    }\n    void CFontFileType1::ToCFF(FontFileOutputFunc pOutputFunc, void *pOutputStream)\n    {\n        std::wstring sFontName = NSFile::CUtf8Converter::GetUnicodeFromCharPtr( m_sName, (LONG)strlen(m_sName) );\n        CArray<std::wstring> aString;\n\n        int nBias = 0;\n        int nSubrsLen = m_arrSubrs.GetSize();\n        if ( nSubrsLen < 1240 )\n            nBias = 107;\n        else if ( nSubrsLen < 33900 )\n            nBias = 1131;\n        else\n            nBias = 32768;\n\n        CArray<Type1Charstring> arrType2Charstrings;\n        Type1Charstring oFirstCharstring;\n        oFirstCharstring.arrCharstring.Add( Type1CharstringItem( 0x8B, false ) );\n        oFirstCharstring.arrCharstring.Add( Type1CharstringItem( 0x0E, false ) );\n        arrType2Charstrings.Add( oFirstCharstring );\n        for ( int nIndex = 0; nIndex < m_arrCharstrings.GetSize(); nIndex++ )\n        {\n            std::wstring sG = m_arrCharstrings[nIndex].sGlyph;\n            if ( L\"afii10090\" == sG )\n                int k = 10;\n            arrType2Charstrings.Add( FlattenCharstring( m_arrCharstrings[nIndex].oData, nBias ) );\n        }\n\n        CArray<Type1Charstring> arrType2Subrs;\n\n        //Type1Charstring oBias;\n        ////oBias.arrCharstring.Add( Type1CharstringItem( 0x0B, false ) );\n        //oBias.arrCharstring.Add( Type1CharstringItem( 0x0E, false ) );\n        //for ( int nIndex = 0; nIndex < nBias; nIndex++ )\n        //\tarrType2Subrs.Add( oBias );\n\n        for ( int nIndex = 0; nIndex < nSubrsLen; nIndex++ )\n        {\n            //if ( nIndex == 256 )\n            //{\n            //\tType1Charstring oBias;\n            //\toBias.arrCharstring.Add( Type1CharstringItem( 0x0B, false ) );\n            //\tfor ( int nIndex = 0; nIndex < nBias; nIndex++ )\n            //\t\tarrType2Subrs.Add( oBias );\n            //}\n            arrType2Subrs.Add( FlattenCharstring( m_arrSubrs[nIndex], 0 ) );\n        }\n\n        // Header\n        TCharBuffer oHeader;\n        oHeader.Write( \"\\x01\\x00\\x04\\x04\", 4 );\n\n        // Name\n        TCharBuffer oName;\n        aString.RemoveAll();\n        aString.Add( sFontName );\n        CFFCreateIndexHeader( CharBufferWrite, &oName, aString );\n\n        // Strings\n        TCharBuffer oStrings;\n        aString.RemoveAll();\n        int nNewSID = CFF_STANDARD_STRINGS_COUNT;\n        aString.Add( L\"Version 0.11\" );        nNewSID++; // Version\n        aString.Add( L\"See original notice\" ); nNewSID++; // Notice\n        aString.Add( sFontName );                 nNewSID++; // FullName\n        aString.Add( sFontName );                 nNewSID++; // FamilyName\n        aString.Add( L\"Medium\" );              nNewSID++; // Weight\n\n        for ( int nIndex = 0; nIndex < m_arrCharstrings.GetSize(); nIndex++ )\n        {\n            int nSID = GetCFFStringIndex( m_arrCharstrings[nIndex].sGlyph.c_str() );\n            if ( nSID < 0 )\n            {\n                aString.Add( m_arrCharstrings[nIndex].sGlyph );\n                nSID = nNewSID;\n                nNewSID++;\n            }\n\n            m_arrCharstrings[nIndex].nReserved = nSID;\n        }\n\n        CFFCreateIndexHeader( CharBufferWrite, &oStrings, aString );\n\n        // GlobalSubrs\n        TCharBuffer oGlobalSubrs;\n        aString.RemoveAll(); // \u0417\u0430\u043f\u0438\u0441\u044b\u0432\u0430\u0435\u043c \u043f\u0443\u0441\u0442\u043e\u0439 \u043c\u0430\u0441\u0441\u0438\u0432\n        CFFCreateIndexHeader( CharBufferWrite, &oGlobalSubrs, aString );\n\n        // Charset\n        TCharBuffer oCharset;\n        oCharset.Write( (char)0x00 ); // Encoding\n\n        int nGlyphsCount = m_arrCharstrings.GetSize();\n        for ( int nIndex = 0; nIndex < nGlyphsCount; nIndex++ )\n        {\n            int nSID = m_arrCharstrings[nIndex].nReserved;\n            oCharset.Write( (char)(nSID >> 8) );\n            oCharset.Write( (char)(nSID & 0xFF) );\n        }\n\n        // Charstrings\n        TCharBuffer oCharstrings;\n        CFFCreateIndexHeader( NSFontConverter::CharBufferWrite, &oCharstrings, arrType2Charstrings );\n\n        // Private\n        TCharBuffer oPrivate;\n        oPrivate.Write( \"\\x8b\\x14\", 2 ); // defaultWidth\n        oPrivate.Write( \"\\x8b\\x15\", 2 ); // nominalWidth\n\n        // Private: BlueValues\n        if ( m_oPrivateDict.nBlueValues > 0 )\n        {\n            CFFEncodeNumber( CharBufferWrite, &oPrivate, m_oPrivateDict.arrnBlueValues[0] );\n            for ( int nIndex = 1; nIndex < m_oPrivateDict.nBlueValues; nIndex++ )\n                CFFEncodeNumber( CharBufferWrite, &oPrivate, m_oPrivateDict.arrnBlueValues[nIndex] - m_oPrivateDict.arrnBlueValues[nIndex - 1] );\n\n            oPrivate.Write( (char)0x06 );\n        }\n\n        // Private: OtherBlues\n        if ( m_oPrivateDict.nOtherBlues > 0 )\n        {\n            CFFEncodeNumber( CharBufferWrite, &oPrivate, m_oPrivateDict.arrnOtherBlues[0] );\n            for ( int nIndex = 1; nIndex < m_oPrivateDict.nOtherBlues; nIndex++ )\n                CFFEncodeNumber( CharBufferWrite, &oPrivate, m_oPrivateDict.arrnOtherBlues[nIndex] - m_oPrivateDict.arrnOtherBlues[nIndex - 1] );\n\n            oPrivate.Write( (char)0x07 );\n        }\n\n        // Private: FamilyBlues\n        if ( m_oPrivateDict.nFamilyBlues > 0 )\n        {\n            CFFEncodeNumber( CharBufferWrite, &oPrivate, m_oPrivateDict.arrnFamilyBlues[0] );\n            for ( int nIndex = 1; nIndex < m_oPrivateDict.nFamilyBlues; nIndex++ )\n                CFFEncodeNumber( CharBufferWrite, &oPrivate, m_oPrivateDict.arrnFamilyBlues[nIndex] - m_oPrivateDict.arrnFamilyBlues[nIndex - 1] );\n\n            oPrivate.Write( (char)0x08 );\n        }\n\n        // Private: FamilyOtherBlues\n        if ( m_oPrivateDict.nFamilyOtherBlues > 0 )\n        {\n            CFFEncodeNumber( CharBufferWrite, &oPrivate, m_oPrivateDict.arrnFamilyOtherBlues[0] );\n            for ( int nIndex = 1; nIndex < m_oPrivateDict.nFamilyOtherBlues; nIndex++ )\n                CFFEncodeNumber( CharBufferWrite, &oPrivate, m_oPrivateDict.arrnFamilyOtherBlues[nIndex] - m_oPrivateDict.arrnFamilyOtherBlues[nIndex - 1] );\n\n            oPrivate.Write( (char)0x09 );\n        }\n\n        // Private: StemSnapH\n        if ( m_oPrivateDict.nStemSnapH > 0 )\n        {\n            CFFEncodeNumber( CharBufferWrite, &oPrivate, m_oPrivateDict.arrdStemSnapH[0] );\n            for ( int nIndex = 1; nIndex < m_oPrivateDict.nStemSnapH; nIndex++ )\n                CFFEncodeNumber( CharBufferWrite, &oPrivate, m_oPrivateDict.arrdStemSnapH[nIndex] - m_oPrivateDict.arrdStemSnapH[nIndex - 1] );\n\n            oPrivate.Write( \"\\x0c\\x0c\" , 2);\n        }\n\n        // Private: StemSnapV\n        if ( m_oPrivateDict.nStemSnapV > 0 )\n        {\n            CFFEncodeNumber( CharBufferWrite, &oPrivate, m_oPrivateDict.arrdStemSnapV[0] );\n            for ( int nIndex = 1; nIndex < m_oPrivateDict.nStemSnapV; nIndex++ )\n                CFFEncodeNumber( CharBufferWrite, &oPrivate, m_oPrivateDict.arrdStemSnapV[nIndex] - m_oPrivateDict.arrdStemSnapV[nIndex - 1] );\n\n            oPrivate.Write( \"\\x0c\\x0d\" , 2);\n        }\n\n        // Private: BlueShift\n        CFFEncodeNumber( CharBufferWrite, &oPrivate, m_oPrivateDict.nBlueShift );\n        oPrivate.Write( \"\\x0c\\x0a\", 2 );\n\n        // Private: BlueFuzz\n        CFFEncodeNumber( CharBufferWrite, &oPrivate, m_oPrivateDict.nBlueFuzz );\n        oPrivate.Write( \"\\x0c\\x0b\", 2 );\n\n        // Private: BlueScale\n        CFFEncodeNumber( CharBufferWrite, &oPrivate, m_oPrivateDict.dBlueScale );\n        oPrivate.Write( \"\\x0c\\x09\", 2 );\n\n        // Private: LanguageGroup\n        CFFEncodeNumber( CharBufferWrite, &oPrivate, m_oPrivateDict.nLanguageGroup );\n        oPrivate.Write( \"\\x0c\\x11\", 2 );\n\n        // Private: ExpansionFactor\n        CFFEncodeNumber( CharBufferWrite, &oPrivate, m_oPrivateDict.dExpansionFactor );\n        oPrivate.Write( \"\\x0c\\x18\", 2 );\n\n        // Private: Subrs\n        int nPrivateLen = oPrivate.nLen + (5 + 1);\n        CFFEncodeNumber( CharBufferWrite, &oPrivate, nPrivateLen, true );\n        oPrivate.Write( \"\\x13\", 1 );\n\n        // LocalSubrs\n        TCharBuffer oLocalSubrs;\n        CFFCreateIndexHeader( CharBufferWrite, &oLocalSubrs, arrType2Subrs );\n\n        // Top Dict\n        TCharBuffer oTopDict;\n        oTopDict.Write( \"\\x00\\x01\\x04\\x00\\x00\\x00\\x01\\x00\\x00\\0x00\\x00\", 11 );\n        oTopDict.Write( \"\\xf8\\x1b\\x00\", 3 ); // Version\n        oTopDict.Write( \"\\xf8\\x1c\\x01\", 3 ); // Notice\n        oTopDict.Write( \"\\xf8\\x1d\\x02\", 3 ); // FullName\n        oTopDict.Write( \"\\xf8\\x1e\\x03\", 3 ); // FamilyName\n        oTopDict.Write( \"\\xf8\\x1f\\x04\", 3 ); // Weight\n        oTopDict.Write( \"\\x1c\\x00\\x00\\x10\", 4 ); // Encoding\n\n        // BBox\n        CFFEncodeNumber( CharBufferWrite, &oTopDict, m_oTopDict.arrdFontBBox[0] );\n        CFFEncodeNumber( CharBufferWrite, &oTopDict, m_oTopDict.arrdFontBBox[1] );\n        CFFEncodeNumber( CharBufferWrite, &oTopDict, m_oTopDict.arrdFontBBox[2] );\n        CFFEncodeNumber( CharBufferWrite, &oTopDict, m_oTopDict.arrdFontBBox[3] );\n        oTopDict.Write( \"\\x05\", 1 );\n\n        // \u0422\u0435\u043f\u0435\u0440\u044c \u043e\u0446\u0435\u043d\u0438\u043c \u0440\u0430\u0437\u043c\u0435\u0440 TopDict: \u0412\u043e\u0437\u044c\u043c\u0435\u043c \u0442\u0435\u043a\u0443\u0449\u0443\u044e \u0434\u043b\u0438\u043d\u0443, \u0434\u043e\u0431\u0430\u0432\u0438\u043c \u043a \u043d\u0435\u0439 (4 * 5 + 3)\n        // ( 4 \u0447\u0438\u0441\u043b\u0430, \u043a\u043e\u0442\u043e\u0440\u044b\u0435 \u043f\u0438\u0448\u0435\u043c \u043f\u043e 5 \u0431\u0430\u0439\u0442 + 3 \u0431\u0430\u0439\u0442\u0430 \u043d\u0430 3 \u043a\u043e\u043c\u0430\u043d\u0434\u044b)\n        int nTopDictLen = oTopDict.nLen + ( 4 * 5 + 3);\n\n        int nOffset = oHeader.nLen + oName.nLen + nTopDictLen + oStrings.nLen + oGlobalSubrs.nLen;\n        CFFEncodeNumber( CharBufferWrite, &oTopDict, nOffset, true );\n        oTopDict.Write( \"\\x0f\", 1 ); // Charset\n\n        nOffset += oCharset.nLen;//( arrType2Charstrings.GetSize() * 2 ) + 1;\n        CFFEncodeNumber( CharBufferWrite, &oTopDict, nOffset, true );\n        oTopDict.Write( \"\\x11\", 1 ); // Charstrings\n\n        CFFEncodeNumber( CharBufferWrite, &oTopDict, oPrivate.nLen, true );\n        nOffset += oCharstrings.nLen;\n        CFFEncodeNumber( CharBufferWrite, &oTopDict, nOffset, true );\n        oTopDict.Write( \"\\x12\", 1 ); // Private\n\n        // \u0422\u0435\u043f\u0435\u0440\u044c \u0437\u0430\u043f\u0438\u0448\u0435\u043c \u0440\u0435\u0430\u043b\u044c\u043d\u044b\u0439 \u0440\u0430\u0437\u043c\u0435\u0440 TopDict\n        int nTopDictDataLen = nTopDictLen - 10;\n        oTopDict.sBuffer[7]  = ( nTopDictDataLen >> 24 ) & 0xFF;\n        oTopDict.sBuffer[8]  = ( nTopDictDataLen >> 16 ) & 0xFF;\n        oTopDict.sBuffer[9]  = ( nTopDictDataLen >> 8  ) & 0xFF;\n        oTopDict.sBuffer[10] = nTopDictDataLen & 0xFF;\n\n        // \u0417\u0430\u043f\u0438\u0441\u044b\u0432\u0430\u0435\u043c \u0432\u0441\u0435 \u0432 \u0444\u0430\u0439\u043b\n        pOutputFunc( pOutputStream, oHeader.sBuffer,      oHeader.nLen      );\n        pOutputFunc( pOutputStream, oName.sBuffer,        oName.nLen        );\n        pOutputFunc( pOutputStream, oTopDict.sBuffer,     oTopDict.nLen     );\n        pOutputFunc( pOutputStream, oStrings.sBuffer,     oStrings.nLen     );\n        pOutputFunc( pOutputStream, oGlobalSubrs.sBuffer, oGlobalSubrs.nLen );\n        pOutputFunc( pOutputStream, oCharset.sBuffer,     oCharset.nLen     );\n        pOutputFunc( pOutputStream, oCharstrings.sBuffer, oCharstrings.nLen );\n        pOutputFunc( pOutputStream, oPrivate.sBuffer,     oPrivate.nLen     );\n        pOutputFunc( pOutputStream, oLocalSubrs.sBuffer,  oLocalSubrs.nLen  );\n    }\n}\n", "\ufeff/*\n * (c) Copyright Ascensio System SIA 2010-2019\n *\n * This program is a free software product. You can redistribute it and/or\n * modify it under the terms of the GNU Affero General Public License (AGPL)\n * version 3 as published by the Free Software Foundation. In accordance with\n * Section 7(a) of the GNU AGPL its Section 15 shall be amended to the effect\n * that Ascensio System SIA expressly excludes the warranty of non-infringement\n * of any third-party rights.\n *\n * This program is distributed WITHOUT ANY WARRANTY; without even the implied\n * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR  PURPOSE. For\n * details, see the GNU AGPL at: http://www.gnu.org/licenses/agpl-3.0.html\n *\n * You can contact Ascensio System SIA at 20A-12 Ernesta Birznieka-Upisha\n * street, Riga, Latvia, EU, LV-1050.\n *\n * The  interactive user interfaces in modified source and object code versions\n * of the Program must display Appropriate Legal Notices, as required under\n * Section 5 of the GNU AGPL version 3.\n *\n * Pursuant to Section 7(b) of the License you must retain the original Product\n * logo when distributing the program. Pursuant to Section 7(e) we decline to\n * grant you any rights under trademark law for use of our trademarks.\n *\n * All the Product's GUI elements, including illustrations and icon sets, as\n * well as technical writing content are licensed under the terms of the\n * Creative Commons Attribution-ShareAlike 4.0 International. See the License\n * terms at http://creativecommons.org/licenses/by-sa/4.0/legalcode\n *\n */\n#ifndef _ASC_FONTCONVERTER_FONT_FILE_TYPE1_H\n#define _ASC_FONTCONVERTER_FONT_FILE_TYPE1_H\n\n#include \"Utils.h\"\n#include \"FontFileBase.h\"\n#include \"FontFileEncodings.h\"\n#include \"../../common/Array.h\"\n\nnamespace NSFontConverter\n{\n    #define type1MaxBlueValues 14 // 7 \u043f\u0430\u0440\n    #define type1MaxOtherBlues 10 // 5 \u043f\u0430\u0440\n    #define type1MaxStemSnap   12\n\n    struct Type1PrivateDict\n    {\n        int    arrnBlueValues[type1MaxBlueValues];\n        int    nBlueValues;\n        int    arrnOtherBlues[type1MaxOtherBlues];\n        int    nOtherBlues;\n        int    arrnFamilyBlues[type1MaxBlueValues];\n        int    nFamilyBlues;\n        int    arrnFamilyOtherBlues[type1MaxOtherBlues];\n        int    nFamilyOtherBlues;\n        double dBlueScale;\n        int    nBlueShift;\n        int    nBlueFuzz;\n        double dStdHW;\n        bool   bHasStdHW;\n        double dStdVW;\n        bool   bHasStdVW;\n        double arrdStemSnapH[type1MaxStemSnap];\n        int    nStemSnapH;\n        double arrdStemSnapV[type1MaxStemSnap];\n        int    nStemSnapV;\n        bool   bHasForceBold;\n        bool   bForceBold;\n        int    nLanguageGroup;\n        int    nLenIV;\n        double dExpansionFactor;\n    };\n\n    struct Type1TopDict\n    {\n        // TO DO: \u0434\u043e\u043f\u043e\u043b\u043d\u0438\u0442\u044c \u0434\u0430\u043d\u043d\u0443\u044e \u0441\u0442\u0440\u0443\u043a\u0442\u0443\u0440\u0443\n        double arrdFontMatrix[6];\n        double arrdFontBBox[4];\n    };\n\n    // \u043a\u043e\u043c\u0430\u043d\u0434\u044b\n    const int c_nType1hstem\t\t\t\t= 0x0001; // 'hstem'\n    const int c_nType1vstem\t\t\t\t= 0x0003; // 'vstem'\n    const int c_nType1vmoveto\t\t\t= 0x0004; // 'vmoveto'\n    const int c_nType1rlineto\t\t\t= 0x0005; // 'rlineto'\n    const int c_nType1hlineto\t\t\t= 0x0006; // 'hlineto'\n    const int c_nType1vlineto\t\t\t= 0x0007; // 'vlineto'\n    const int c_nType1rrcurveto\t\t\t= 0x0008; // 'rrcurveto'\n    const int c_nType1closepath\t\t\t= 0x0009; // 'closepath' \u043d\u0435 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u0442\u0441\u044f \u0432 Type2\n    const int c_nType1callsubr\t\t\t= 0x000A; // 'callsubr\n    const int c_nType1return\t\t\t= 0x000B; // 'return'\n    const int c_nType1dotsection\t\t= 0x000C; // 'dotsection' \u043d\u0435 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u0442\u0441\u044f \u0432 Type2\n    const int c_nType1vstem3\t\t\t= 0x010C; // 'vstem'\n    const int c_nType1hstem3\t\t\t= 0x020C; // 'hstem'\n    const int c_nType1seac\t\t\t\t= 0x060C; // 'seac' Type1 only\n    const int c_nType1sbw\t\t\t\t= 0x070C; // 'sbw'  Type1 only\n    const int c_nType1sub\t\t\t\t= 0x0B0C; // 'sub'\n    const int c_nType1div\t\t\t\t= 0x0C0C; // 'div'\n    const int c_nType1callothersubr\t\t= 0x100C; // 'callothersubr'\n    const int c_nType1pop\t\t\t\t= 0x110C; // 'pop'\n    const int c_nType1setcurrentpoint\t= 0x210C; // 'setcurrentpoint' \u043d\u0435 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u0442\u0441\u044f \u0432 Type2\n    const int c_nType1hsbw\t\t\t\t= 0x000D; // 'hsbw'\n    const int c_nType1endchar\t\t\t= 0x000E; // 'endchar'\n    const int c_nType1rmoveto\t\t\t= 0x0015; // 'rmoveto'\n    const int c_nType1hmoveto\t\t\t= 0x0016; // 'hmoveto'\n    const int c_nType1vhcurveto\t\t\t= 0x001E; // 'vhcurveto'\n    const int c_nType1hvcurveto\t\t\t= 0x001F; // 'hvcurveto'\n\n    struct Type1CharstringItem\n    {\n        int  nValue;   // \u0417\u043d\u0430\u0447\u0435\u043d\u0438\u0435\n        bool bCommand; // TRUE: \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435 - \u043d\u043e\u043c\u0435\u0440 \u043a\u043e\u043c\u0430\u043d\u0434\u044b, FALSE: \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435 - \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440 \u043a\u043e\u043c\u0430\u043d\u0434\u044b\n\n        Type1CharstringItem(int nVal, bool bCom)\n        {\n            nValue   = nVal;\n            bCommand = bCom;\n        }\n        Type1CharstringItem()\n        {\n            nValue   = 0;\n            bCommand = false;\n        }\n    };\n\n    struct Type1Charstring\n    {\n        CArray<Type1CharstringItem> arrCharstring;\n        int                               nWidth;\n        int                               nLSB;\n\n        Type1Charstring()\n        {\n            nWidth    = 0;\n            nLSB      = 0;\n        }\n\n        Type1Charstring(CArray<Type1CharstringItem> &arrCs, int nW, int nL)\n        {\n            arrCharstring = arrCs;\n            nWidth        = nW;\n            nLSB          = nL;\n        }\n    };\n\n\n    struct Type1Glyph\n    {\n        std::wstring    sGlyph;    // Type1 \u0438\u043c\u044f \u0433\u043b\u0438\u0444\u0430\n        int             nUnicode;  // \u042e\u043d\u0438\u043a\u043e\u0434\u043d\u043e\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435 \u0433\u043b\u0438\u0444\u0430\n        Type1Charstring oData;\n        int             nReserved; // \u0418\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u043c \u0434\u043b\u044f SID \u043f\u0440\u0438 \u043a\u043e\u043d\u0432\u0435\u0440\u0442\u0430\u0446\u0438\u0438 Type1->Type2\n\n        Type1Glyph(std::wstring& sGlyf, int nUni, Type1Charstring &oCharstring)\n        {\n            sGlyph    = sGlyf;\n            nUnicode  = nUni;\n            oData     = oCharstring;\n            nReserved = 0;\n        }\n        Type1Glyph()\n        {\n            nUnicode  = 0;\n            nReserved = 0;\n        }\n    };\n\n    static int CompareType1Glyph(const void *pGlyph1, const void *pGlyph2)\n    {\n        Type1Glyph *pGlyf1 = (Type1Glyph *)pGlyph1;\n        Type1Glyph *pGlyf2 = (Type1Glyph *)pGlyph2;\n\n        return pGlyf1->nUnicode - pGlyf2->nUnicode;\n    }\n\n\n    //------------------------------------------------------------------------\n    // CFontFileType1\n    //------------------------------------------------------------------------\n\n    class CFontFileType1: public CFontFileBase\n    {\n    public:\n\n        static CFontFileType1 *LoadFromBuffer(char *sBuffer, int nLen);\n        static CFontFileType1 *LoadFromFile(const wchar_t *wsFileName);\n\n        virtual ~CFontFileType1();\n\n        char *GetName();\n\n        char **GetEncoding();\n\n        void WriteEncoded(char **ppNewEncoding, FontFileOutputFunc pOutputFunc, void *pOutputStream);\n        void ToCFF(FontFileOutputFunc pOutputFunc, void *pOutputStream);\n\n    private:\n\n        CFontFileType1(char *sBuffer, int nLen, bool bFreeData);\n        void Parse();\n        void DecryptEexec(unsigned char** ppEexecBuffer, int nLen);\n        Type1Charstring DecodeCharString(unsigned char *sString, int nLen);\n        char *GetNextLine(char *sLine);\n        bool RemovePfbMarkers();\n        template<int nMax>\n        int    ReadDoubleArray(unsigned char *sString, int nLen, double (&pArray)[nMax])\n        {\n            int nStart = 0;\n            while( sString[nStart] != '[' )\n            {\n                nStart++;\n                if ( nStart >= nLen )\n                    return 0;\n            }\n\n            int nEnd = ++nStart;\n            while ( sString[nEnd] != ']' )\n            {\n                nEnd++;\n                if ( nEnd >= nLen )\n                    return 0;\n            }\n\n            sString = sString + nStart;\n            nLen    = nEnd - nStart;\n\n\n            int nCount = 0;\n            const int c_nNumLimit = 32;\n            unsigned char sBuffer[c_nNumLimit];\n            int nBufPos = 0;\n            bool bNewItem = true;\n\n            for ( int nIndex = 0; nIndex < nLen; ++nIndex )\n            {\n                unsigned char unChar = sString[nIndex];\n                if ( ' ' == unChar )\n                {\n                    if ( !bNewItem )\n                        bNewItem = true;\n\n                    continue;\n                }\n\n                if ( bNewItem )\n                {\n                    if ( nCount >= nMax )\n                        break;\n\n                    // \u0414\u043e\u0431\u0430\u0432\u043b\u044f\u0435\u043c \u043f\u0440\u0435\u0434\u044b\u0434\u0443\u0449\u0435\u0435 \u0447\u0438\u0441\u043b\u043e \u0432 \u043c\u0430\u0441\u0441\u0438\u0432\n                    if ( nCount > 0 )\n                        pArray[nCount - 1] = Utils::GetDouble( (const char *)sBuffer );\n\n                    memset( sBuffer, 0x00, c_nNumLimit );\n                    nBufPos = 0;\n\n                    bNewItem = false;\n                    nCount++;\n                }\n\n                sBuffer[nBufPos++] = unChar;\n            }\n\n            if ( 0 != sBuffer[0] && nCount > 0 )\n                pArray[nCount - 1] = Utils::GetDouble( (const char *)sBuffer );\n\n            return nCount;\n        }\n\n        template<int nMax>\n        int    ReadIntArray   (unsigned char *sString, int nLen, int (&pArray)[nMax])\n        {\n            int nStart = 0;\n            while( sString[nStart] != '[' )\n            {\n                nStart++;\n                if ( nStart >= nLen )\n                    return 0;\n            }\n\n            int nEnd = ++nStart;\n            while ( sString[nEnd] != ']' )\n            {\n                nEnd++;\n                if ( nEnd >= nLen )\n                    return 0;\n            }\n\n            sString = sString + nStart;\n            nLen    = nEnd - nStart;\n\n            int nCount = 0;\n            const int c_nNumLimit = 32;\n            unsigned char sBuffer[c_nNumLimit];\n            int nBufPos = 0;\n            bool bNewItem = true;\n\n            for ( int nIndex = 0; nIndex < nLen; ++nIndex )\n            {\n                unsigned char unChar = sString[nIndex];\n                if ( ' ' == unChar )\n                {\n                    if ( !bNewItem )\n                        bNewItem = true;\n\n                    continue;\n                }\n\n                if ( bNewItem )\n                {\n                    if ( nCount >= nMax )\n                        break;\n\n                    // \u0414\u043e\u0431\u0430\u0432\u043b\u044f\u0435\u043c \u043f\u0440\u0435\u0434\u044b\u0434\u0443\u0449\u0435\u0435 \u0447\u0438\u0441\u043b\u043e \u0432 \u043c\u0430\u0441\u0441\u0438\u0432\n                    if ( nCount > 0 )\n                        pArray[nCount - 1] = Utils::GetInteger( (const char *)sBuffer );\n\n                    memset( sBuffer, 0x00, c_nNumLimit );\n                    nBufPos = 0;\n\n                    bNewItem = false;\n                    nCount++;\n                }\n\n                sBuffer[nBufPos++] = unChar;\n            }\n\n            if ( 0 != sBuffer[0] && nCount > 0 )\n                pArray[nCount - 1] = Utils::GetInteger( (const char *)sBuffer );\n\n            return nCount;\n        }\n\n        double ReadDouble     (unsigned char *sString, int nMaxLen)\n        {\n            // \u0421\u043c\u0435\u0449\u0430\u0435\u043c\u0441\u044f \u043a \u043f\u0435\u0440\u0432\u043e\u043c\u0443 \u043f\u0440\u043e\u0431\u0435\u043b\u0443 (\u043f\u043e\u0441\u043b\u0435 \u043d\u0435\u0433\u043e \u0438\u0434\u0435\u0442 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435)\n            int nPos = 0;\n            while ( ' ' == sString[nPos] && nPos < nMaxLen )\n                nPos++;\n\n            return Utils::GetDouble( (const char*)( sString + nPos ) );\n        }\n        int    ReadInt        (unsigned char *sString, int nMaxLen)\n        {\n            int nPos = 0;\n            while ( ' ' == sString[nPos] && nPos < nMaxLen )\n                nPos++;\n\n            return Utils::GetInteger( (const char*)( sString + nPos ) );\n        }\n\n        bool   ReadBool       (unsigned char *sString, int nMaxLen)\n        {\n            int nStartPos = 0;\n            while ( ' ' == sString[nStartPos] && nStartPos < nMaxLen )\n                nStartPos++;\n\n            if ( nStartPos >= nMaxLen - 4 )\n                return false;\n\n            if ( 't' == sString[nStartPos + 0] &&\n                 'r' == sString[nStartPos + 1] &&\n                 'u' == sString[nStartPos + 2] &&\n                 'e' == sString[nStartPos + 3] )\n                return true;\n\n            return false;\n        }\n\n        Type1Charstring FlattenCharstring(Type1Charstring& oCharstring, int nBias = 0);\n        void   CFFCreateIndexHeader(FontFileOutputFunc pOutputFunc, void *pOutputStream, CArray<std::wstring> aObjects);\n        void   CFFCreateIndexHeader(FontFileOutputFunc pOutputFunc, void *pOutputStream, CArray<Type1Charstring> aObjects);\n        void   CFFEncodeNumber     (FontFileOutputFunc pOutputFunc, void *pOutputStream, int nValue, bool bForceLong = false);\n        void   CFFEncodeNumber     (FontFileOutputFunc pOutputFunc, void *pOutputStream, double dValue);\n\n    private:\n\n        char                         *m_sName;\n        char                        **m_arrEncoding;\n        bool                          m_bParsed;\n\n        Type1PrivateDict              m_oPrivateDict;\n        Type1TopDict                  m_oTopDict;\n\n        CArray<Type1Glyph>      m_arrCharstrings;\n        CArray<Type1Charstring> m_arrSubrs;\n    };\n}\n\n#endif /* _ASC_FONTCONVERTER_FONT_FILE_TYPE1_H */\n"], "fixing_code": ["/*\n * (c) Copyright Ascensio System SIA 2010-2019\n *\n * This program is a free software product. You can redistribute it and/or\n * modify it under the terms of the GNU Affero General Public License (AGPL)\n * version 3 as published by the Free Software Foundation. In accordance with\n * Section 7(a) of the GNU AGPL its Section 15 shall be amended to the effect\n * that Ascensio System SIA expressly excludes the warranty of non-infringement\n * of any third-party rights.\n *\n * This program is distributed WITHOUT ANY WARRANTY; without even the implied\n * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR  PURPOSE. For\n * details, see the GNU AGPL at: http://www.gnu.org/licenses/agpl-3.0.html\n *\n * You can contact Ascensio System SIA at 20A-12 Ernesta Birznieka-Upisha\n * street, Riga, Latvia, EU, LV-1050.\n *\n * The  interactive user interfaces in modified source and object code versions\n * of the Program must display Appropriate Legal Notices, as required under\n * Section 5 of the GNU AGPL version 3.\n *\n * Pursuant to Section 7(b) of the License you must retain the original Product\n * logo when distributing the program. Pursuant to Section 7(e) we decline to\n * grant you any rights under trademark law for use of our trademarks.\n *\n * All the Product's GUI elements, including illustrations and icon sets, as\n * well as technical writing content are licensed under the terms of the\n * Creative Commons Attribution-ShareAlike 4.0 International. See the License\n * terms at http://creativecommons.org/licenses/by-sa/4.0/legalcode\n *\n */\n\n#include <fstream>\n#include <time.h>\n#include \"errno.h\"\n\n#if defined(_WIN32) || defined(_WIN32_WCE) || defined(_WIN64)\n    #include <wchar.h>\n    #include <windows.h>\n#endif\n\n#ifdef _LINUX\n#include <unistd.h>\n#include <string.h>\n#include <sys/stat.h>\n#endif\n\n#ifdef _IOS\n    const char* fileSystemRepresentation(const std::wstring& sFileName);\n#endif\n\n#ifdef _MAC\n#include <mach-o/dyld.h>\n#endif\n\n#ifndef MAX_PATH\n    #define MAX_PATH 1024\n#endif\n\n// \u0440\u0435\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044f \u0432\u043e\u0437\u043c\u043e\u0436\u043d\u043e\u0441\u0442\u0438 \u043f\u043e\u0434\u043c\u0435\u043d\u044b \u043e\u043f\u0440\u0435\u0434\u0435\u043b\u0435\u043d\u0438\u044f GetTempPath\nstd::wstring g_overrideTmpPath = L\"\";\n\n#include \"File.h\"\n\n#if defined(_WIN32) || defined(_WIN32_WCE) || defined(_WIN64)\n\t#include <wchar.h>\n\t#include <windows.h>\n\n\tstd::wstring CorrectPathW(const std::wstring& path)\n\t{\n\t\tint len = (int)path.length();\n\t\tif (2 > len)\n\t\t\treturn path;\n\n\t\tconst wchar_t* path_str = path.c_str();\n\t\tif (path_str[0] == '\\\\' || path_str[1] == '/')\n\t\t\treturn path;\n\n\t\t// local files: '\\\\?\\' prefix\n\t\t// server files: '\\\\?\\UNC\\' prefix <== TODO!\n\t\tint nLen = GetFullPathNameW(path_str, 0, 0, 0);\n\t\twchar_t* pBuf = new wchar_t[(4 + nLen) * sizeof(wchar_t)];\n\n\t\tpBuf[0] = L'\\\\', pBuf[1] = L'\\\\',  pBuf[2] = L'?', pBuf[3] = L'\\\\';\n\t\tGetFullPathNameW(path_str, nLen, pBuf + 4, NULL);\n\n\t\tstd::wstring retPath(pBuf);\n\t\tdelete [] pBuf;\n\t\treturn retPath;\n\t}\n#else\n\tstd::wstring CorrectPathW(const std::wstring& path)\n\t{\n\t\treturn path;\n\t}\n#endif\n\nnamespace NSFile\n{\n    std::wstring CUtf8Converter::GetUnicodeFromCharPtr(const char* pData, LONG lCount, INT bIsUtf8)\n    {\n        if (bIsUtf8)\n            return GetUnicodeStringFromUTF8((BYTE*)pData, lCount);\n\n        wchar_t* pUnicode = new wchar_t[lCount + 1];\n        for (LONG i = 0; i < lCount; ++i)\n            pUnicode[i] = (wchar_t)(BYTE)pData[i];\n\n        pUnicode[lCount] = 0;\n\n        std::wstring s(pUnicode, lCount);\n        RELEASEARRAYOBJECTS(pUnicode);\n\n        return s;\n    }\n    std::wstring CUtf8Converter::GetUnicodeFromCharPtr(const std::string& sParam, INT bIsUtf8)\n    {\n        return GetUnicodeFromCharPtr(sParam.c_str(), (LONG)sParam.length(), bIsUtf8);\n    }\n\tLONG CUtf8Converter::GetUnicodeStringFromUTF8BufferSize(LONG lCount)\n    {\n        return lCount + 1;\n    }\n    std::wstring CUtf8Converter::GetUnicodeStringFromUTF8_4bytes( BYTE* pBuffer, LONG lCount )\n    {\n        std::wstring strRes;\n        GetUnicodeStringFromUTF8_4bytes(pBuffer, lCount, strRes);\n        return strRes;\n    }\n    std::wstring CUtf8Converter::GetUnicodeStringFromUTF8_2bytes( BYTE* pBuffer, LONG lCount )\n    {\n        std::wstring strRes;\n        GetUnicodeStringFromUTF8_2bytes(pBuffer, lCount, strRes);\n        return strRes;\n    }\n\n    std::wstring CUtf8Converter::GetUnicodeStringFromUTF8( BYTE* pBuffer, LONG lCount )\n    {\n        std::wstring strRes;\n        GetUnicodeStringFromUTF8(pBuffer, lCount, strRes);\n        return strRes;\n    }\n\n    void CUtf8Converter::GetUnicodeStringFromUTF8_4bytes( BYTE* pBuffer, LONG lCount, std::wstring& sOutput )\n    {\n        WCHAR* pUnicodeString = new WCHAR[lCount + 1];\n        LONG lIndexUnicode = 0;\n\n        LONG lIndex = 0;\n        while (lIndex < lCount)\n        {\n            BYTE byteMain = pBuffer[lIndex];\n            if (0x00 == (byteMain & 0x80))\n            {\n                // 1 byte\n                pUnicodeString[lIndexUnicode++] = (WCHAR)byteMain;\n                ++lIndex;\n            }\n            else if (0x00 == (byteMain & 0x20))\n            {\n                // 2 byte\n                int val = 0;\n                if ((lIndex + 1) < lCount)\n                {\n                    val = (int)(((byteMain & 0x1F) << 6) |\n                                (pBuffer[lIndex + 1] & 0x3F));\n                }\n\n                pUnicodeString[lIndexUnicode++] = (WCHAR)(val);\n                lIndex += 2;\n            }\n            else if (0x00 == (byteMain & 0x10))\n            {\n                // 3 byte\n                int val = 0;\n                if ((lIndex + 2) < lCount)\n                {\n                    val = (int)(((byteMain & 0x0F) << 12) |\n                                ((pBuffer[lIndex + 1] & 0x3F) << 6) |\n                                (pBuffer[lIndex + 2] & 0x3F));\n                }\n\n                pUnicodeString[lIndexUnicode++] = (WCHAR)(val);\n                lIndex += 3;\n            }\n            else if (0x00 == (byteMain & 0x0F))\n            {\n                // 4 byte\n                int val = 0;\n                if ((lIndex + 3) < lCount)\n                {\n                    val = (int)(((byteMain & 0x07) << 18) |\n                                ((pBuffer[lIndex + 1] & 0x3F) << 12) |\n                                ((pBuffer[lIndex + 2] & 0x3F) << 6) |\n                                (pBuffer[lIndex + 3] & 0x3F));\n                }\n\n                pUnicodeString[lIndexUnicode++] = (WCHAR)(val);\n                lIndex += 4;\n            }\n            else if (0x00 == (byteMain & 0x08))\n            {\n                // 4 byte\n                int val = 0;\n                if ((lIndex + 3) < lCount)\n                {\n                    val = (int)(((byteMain & 0x07) << 18) |\n                                ((pBuffer[lIndex + 1] & 0x3F) << 12) |\n                                ((pBuffer[lIndex + 2] & 0x3F) << 6) |\n                                (pBuffer[lIndex + 3] & 0x3F));\n                }\n\n                pUnicodeString[lIndexUnicode++] = (WCHAR)(val);\n                lIndex += 4;\n            }\n            else if (0x00 == (byteMain & 0x04))\n            {\n                // 5 byte\n                int val = 0;\n                if ((lIndex + 4) < lCount)\n                {\n                    val = (int)(((byteMain & 0x03) << 24) |\n                                ((pBuffer[lIndex + 1] & 0x3F) << 18) |\n                                ((pBuffer[lIndex + 2] & 0x3F) << 12) |\n                                ((pBuffer[lIndex + 3] & 0x3F) << 6) |\n                                (pBuffer[lIndex + 4] & 0x3F));\n                }\n\n                pUnicodeString[lIndexUnicode++] = (WCHAR)(val);\n                lIndex += 5;\n            }\n            else\n            {\n                // 6 byte\n                int val = 0;\n                if ((lIndex + 5) < lCount)\n                {\n                    val = (int)(((byteMain & 0x01) << 30) |\n                                ((pBuffer[lIndex + 1] & 0x3F) << 24) |\n                                ((pBuffer[lIndex + 2] & 0x3F) << 18) |\n                                ((pBuffer[lIndex + 3] & 0x3F) << 12) |\n                                ((pBuffer[lIndex + 4] & 0x3F) << 6) |\n                                (pBuffer[lIndex + 5] & 0x3F));\n                }\n\n                pUnicodeString[lIndexUnicode++] = (WCHAR)(val);\n                lIndex += 5;\n            }\n        }\n\n        pUnicodeString[lIndexUnicode] = 0;\n\n        sOutput.append(pUnicodeString);\n\n        delete [] pUnicodeString;\n    }\n    void CUtf8Converter::GetUnicodeStringFromUTF8_2bytes( BYTE* pBuffer, LONG lCount, std::wstring& sOutput )\n    {\n        WCHAR* pUnicodeString = new WCHAR[lCount + 1];\n        WCHAR* pStart = pUnicodeString;\n\n        LONG lIndex = 0;\n        while (lIndex < lCount)\n        {\n            BYTE byteMain = pBuffer[lIndex];\n            if (0x00 == (byteMain & 0x80))\n            {\n                // 1 byte\n                *pUnicodeString++ = (WCHAR)byteMain;\n                ++lIndex;\n            }\n            else if (0x00 == (byteMain & 0x20))\n            {\n                // 2 byte\n                int val = 0;\n                if ((lIndex + 1) < lCount)\n                {\n                    val = (int)(((byteMain & 0x1F) << 6) |\n                                (pBuffer[lIndex + 1] & 0x3F));\n                }\n\n                *pUnicodeString++ = (WCHAR)(val);\n                lIndex += 2;\n            }\n            else if (0x00 == (byteMain & 0x10))\n            {\n                // 3 byte\n                int val = 0;\n                if ((lIndex + 2) < lCount)\n                {\n                    val = (int)(((byteMain & 0x0F) << 12) |\n                                ((pBuffer[lIndex + 1] & 0x3F) << 6) |\n                                (pBuffer[lIndex + 2] & 0x3F));\n                }\n\n                WriteUtf16_WCHAR(val, pUnicodeString);\n                lIndex += 3;\n            }\n            else if (0x00 == (byteMain & 0x0F))\n            {\n                // 4 byte\n                int val = 0;\n                if ((lIndex + 3) < lCount)\n                {\n                    val = (int)(((byteMain & 0x07) << 18) |\n                                ((pBuffer[lIndex + 1] & 0x3F) << 12) |\n                                ((pBuffer[lIndex + 2] & 0x3F) << 6) |\n                                (pBuffer[lIndex + 3] & 0x3F));\n                }\n\n                WriteUtf16_WCHAR(val, pUnicodeString);\n                lIndex += 4;\n            }\n            else if (0x00 == (byteMain & 0x08))\n            {\n                // 4 byte\n                int val = 0;\n                if ((lIndex + 3) < lCount)\n                {\n                    val = (int)(((byteMain & 0x07) << 18) |\n                                ((pBuffer[lIndex + 1] & 0x3F) << 12) |\n                                ((pBuffer[lIndex + 2] & 0x3F) << 6) |\n                                (pBuffer[lIndex + 3] & 0x3F));\n                }\n\n                WriteUtf16_WCHAR(val, pUnicodeString);\n                lIndex += 4;\n            }\n            else if (0x00 == (byteMain & 0x04))\n            {\n                // 5 byte\n                int val = 0;\n                if ((lIndex + 4) < lCount)\n                {\n                    val = (int)(((byteMain & 0x03) << 24) |\n                                ((pBuffer[lIndex + 1] & 0x3F) << 18) |\n                                ((pBuffer[lIndex + 2] & 0x3F) << 12) |\n                                ((pBuffer[lIndex + 3] & 0x3F) << 6) |\n                                (pBuffer[lIndex + 4] & 0x3F));\n                }\n\n                WriteUtf16_WCHAR(val, pUnicodeString);\n                lIndex += 5;\n            }\n            else\n            {\n                // 6 byte\n                int val = 0;\n                if ((lIndex + 5) < lCount)\n                {\n                    val = (int)(((byteMain & 0x01) << 30) |\n                                ((pBuffer[lIndex + 1] & 0x3F) << 24) |\n                                ((pBuffer[lIndex + 2] & 0x3F) << 18) |\n                                ((pBuffer[lIndex + 3] & 0x3F) << 12) |\n                                ((pBuffer[lIndex + 4] & 0x3F) << 6) |\n                                (pBuffer[lIndex + 5] & 0x3F));\n                }\n\n                WriteUtf16_WCHAR(val, pUnicodeString);\n                lIndex += 5;\n            }\n        }\n\n        *pUnicodeString++ = 0;\n\n        sOutput.append(pStart);\n\n        delete [] pStart;\n    }\n    void CUtf8Converter::GetUnicodeStringFromUTF8( BYTE* pBuffer, LONG lCount, std::wstring& sOutput )\n    {\n        if (sizeof(WCHAR) == 2)\n            GetUnicodeStringFromUTF8_2bytes(pBuffer, lCount, sOutput);\n        else\n            GetUnicodeStringFromUTF8_4bytes(pBuffer, lCount, sOutput);\n    }\n\n#define CHECK_HHHH(pBuffer) \\\n    wchar_t code = 0; \\\n    if('_' == pBuffer[0] && 'x' == pBuffer[1] && 0 != pBuffer[2] && 0 != pBuffer[3] && 0 != pBuffer[4] && 0 != pBuffer[5]  && '_' == pBuffer[6]) \\\n    { \\\n        int i = 2; \\\n        for(; i < 6; ++i) \\\n        { \\\n            code *= 16; \\\n            if('0' <= pBuffer[i] && pBuffer[i] <= '9') \\\n            { \\\n                code += pBuffer[i] - '0'; \\\n            } \\\n            else if('A' <= pBuffer[i] && pBuffer[i] <= 'F') \\\n            { \\\n                code += pBuffer[i] - 'A' + 10; \\\n            } \\\n            else if('a' <= pBuffer[i] && pBuffer[i] <= 'f') \\\n            { \\\n                code += pBuffer[i] - 'a' + 10; \\\n            } \\\n            else \\\n            { \\\n                break; \\\n            } \\\n        } \\\n        if(i == 6) \\\n        { \\\n            if(0x005F == code) \\\n            { \\\n                code = '_'; \\\n            } \\\n            return code; \\\n        } \\\n    } \\\n    return -1;\n\n    long CUtf8Converter::CheckHHHHChar(const BYTE* pBuffer)\n\t{\n        CHECK_HHHH(pBuffer);\n\t}\n    long CUtf8Converter::CheckHHHHChar(const wchar_t* pBuffer)\n\t{\n        CHECK_HHHH(pBuffer);\n\t}\n\n    void CUtf8Converter::GetUnicodeStringFromUTF8WithHHHH_4bytes( const BYTE* pBuffer, LONG lCount, wchar_t*& pUnicodes, LONG& lOutputCount )\n    {\n        if (NULL == pUnicodes)\n        {\n            pUnicodes = new wchar_t[GetUnicodeStringFromUTF8BufferSize(lCount)];\n        }\n        WCHAR* pUnicodeString = pUnicodes;\n        LONG lIndexUnicode = 0;\n\n        LONG lIndex = 0;\n        while (lIndex < lCount)\n        {\n            BYTE byteMain = pBuffer[lIndex];\n            if (0x00 == (byteMain & 0x80))\n            {\n\t\t\t\t// 1 byte\n                long code = CheckHHHHChar(pBuffer + lIndex);\n                if(code < 0)\n                {\n\t\t\t\t\tpUnicodeString[lIndexUnicode++] = (WCHAR)byteMain;\n\t\t\t\t\t++lIndex;\n\t\t\t\t}\n                else\n                {\n                    pUnicodeString[lIndexUnicode++] = (WCHAR)code;\n                    lIndex += 7;\n                }\n            }\n            else if (0x00 == (byteMain & 0x20))\n            {\n                // 2 byte\n                int val = (int)(((byteMain & 0x1F) << 6) |\n                    (pBuffer[lIndex + 1] & 0x3F));\n                pUnicodeString[lIndexUnicode++] = (WCHAR)(val);\n                lIndex += 2;\n            }\n            else if (0x00 == (byteMain & 0x10))\n            {\n                // 3 byte\n                int val = (int)(((byteMain & 0x0F) << 12) |\n                    ((pBuffer[lIndex + 1] & 0x3F) << 6) |\n                    (pBuffer[lIndex + 2] & 0x3F));\n                pUnicodeString[lIndexUnicode++] = (WCHAR)(val);\n                lIndex += 3;\n            }\n            else if (0x00 == (byteMain & 0x0F))\n            {\n                // 4 byte\n                int val = (int)(((byteMain & 0x07) << 18) |\n                    ((pBuffer[lIndex + 1] & 0x3F) << 12) |\n                    ((pBuffer[lIndex + 2] & 0x3F) << 6) |\n                    (pBuffer[lIndex + 3] & 0x3F));\n                pUnicodeString[lIndexUnicode++] = (WCHAR)(val);\n                lIndex += 4;\n            }\n            else if (0x00 == (byteMain & 0x08))\n            {\n                // 4 byte\n                int val = (int)(((byteMain & 0x07) << 18) |\n                    ((pBuffer[lIndex + 1] & 0x3F) << 12) |\n                    ((pBuffer[lIndex + 2] & 0x3F) << 6) |\n                    (pBuffer[lIndex + 3] & 0x3F));\n                pUnicodeString[lIndexUnicode++] = (WCHAR)(val);\n                lIndex += 4;\n            }\n            else if (0x00 == (byteMain & 0x04))\n            {\n                // 5 byte\n                int val = (int)(((byteMain & 0x03) << 24) |\n                    ((pBuffer[lIndex + 1] & 0x3F) << 18) |\n                    ((pBuffer[lIndex + 2] & 0x3F) << 12) |\n                    ((pBuffer[lIndex + 3] & 0x3F) << 6) |\n                    (pBuffer[lIndex + 4] & 0x3F));\n                pUnicodeString[lIndexUnicode++] = (WCHAR)(val);\n                lIndex += 5;\n            }\n            else\n            {\n                // 6 byte\n                int val = (int)(((byteMain & 0x01) << 30) |\n                    ((pBuffer[lIndex + 1] & 0x3F) << 24) |\n                    ((pBuffer[lIndex + 2] & 0x3F) << 18) |\n                    ((pBuffer[lIndex + 3] & 0x3F) << 12) |\n                    ((pBuffer[lIndex + 4] & 0x3F) << 6) |\n                    (pBuffer[lIndex + 5] & 0x3F));\n                pUnicodeString[lIndexUnicode++] = (WCHAR)(val);\n                lIndex += 5;\n            }\n        }\n\n        pUnicodeString[lIndexUnicode] = 0;\n\t\tlOutputCount = lIndexUnicode;\n    }\n    void CUtf8Converter::GetUnicodeStringFromUTF8WithHHHH_2bytes( const BYTE* pBuffer, LONG lCount, wchar_t*& pUnicodes, LONG& lOutputCount )\n    {\n        if (NULL == pUnicodes)\n        {\n            pUnicodes = new wchar_t[GetUnicodeStringFromUTF8BufferSize(lCount)];\n        }\n        WCHAR* pUnicodeString = pUnicodes;\n        WCHAR* pStart = pUnicodeString;\n        LONG lIndex = 0;\n        while (lIndex < lCount)\n        {\n            BYTE byteMain = pBuffer[lIndex];\n            if (0x00 == (byteMain & 0x80))\n            {\n                // 1 byte\n                long code = CheckHHHHChar(pBuffer + lIndex);\n                if(code < 0)\n                {\n                    *pUnicodeString++ = (WCHAR)byteMain;\n                    ++lIndex;\n                }\n                else\n                {\n                    *pUnicodeString++ = (WCHAR)code;\n                    lIndex += 7;\n                }\n\n            }\n            else if (0x00 == (byteMain & 0x20))\n            {\n                // 2 byte\n                int val = (int)(((byteMain & 0x1F) << 6) |\n                    (pBuffer[lIndex + 1] & 0x3F));\n                *pUnicodeString++ = (WCHAR)(val);\n                lIndex += 2;\n            }\n            else if (0x00 == (byteMain & 0x10))\n            {\n                // 3 byte\n                int val = (int)(((byteMain & 0x0F) << 12) |\n                    ((pBuffer[lIndex + 1] & 0x3F) << 6) |\n                    (pBuffer[lIndex + 2] & 0x3F));\n\n                WriteUtf16_WCHAR(val, pUnicodeString);\n                lIndex += 3;\n            }\n            else if (0x00 == (byteMain & 0x0F))\n            {\n                // 4 byte\n                int val = (int)(((byteMain & 0x07) << 18) |\n                    ((pBuffer[lIndex + 1] & 0x3F) << 12) |\n                    ((pBuffer[lIndex + 2] & 0x3F) << 6) |\n                    (pBuffer[lIndex + 3] & 0x3F));\n\n                WriteUtf16_WCHAR(val, pUnicodeString);\n                lIndex += 4;\n            }\n            else if (0x00 == (byteMain & 0x08))\n            {\n                // 4 byte\n                int val = (int)(((byteMain & 0x07) << 18) |\n                    ((pBuffer[lIndex + 1] & 0x3F) << 12) |\n                    ((pBuffer[lIndex + 2] & 0x3F) << 6) |\n                    (pBuffer[lIndex + 3] & 0x3F));\n\n                WriteUtf16_WCHAR(val, pUnicodeString);\n                lIndex += 4;\n            }\n            else if (0x00 == (byteMain & 0x04))\n            {\n                // 5 byte\n                int val = (int)(((byteMain & 0x03) << 24) |\n                    ((pBuffer[lIndex + 1] & 0x3F) << 18) |\n                    ((pBuffer[lIndex + 2] & 0x3F) << 12) |\n                    ((pBuffer[lIndex + 3] & 0x3F) << 6) |\n                    (pBuffer[lIndex + 4] & 0x3F));\n\n                WriteUtf16_WCHAR(val, pUnicodeString);\n                lIndex += 5;\n            }\n            else\n            {\n                // 6 byte\n                int val = (int)(((byteMain & 0x01) << 30) |\n                    ((pBuffer[lIndex + 1] & 0x3F) << 24) |\n                    ((pBuffer[lIndex + 2] & 0x3F) << 18) |\n                    ((pBuffer[lIndex + 3] & 0x3F) << 12) |\n                    ((pBuffer[lIndex + 4] & 0x3F) << 6) |\n                    (pBuffer[lIndex + 5] & 0x3F));\n\n                WriteUtf16_WCHAR(val, pUnicodeString);\n                lIndex += 5;\n            }\n        }\n\n\t\tlOutputCount = pUnicodeString - pStart;\n        *pUnicodeString++ = 0;\n    }\n    void CUtf8Converter::GetUnicodeStringFromUTF8WithHHHH( const BYTE* pBuffer, LONG lCount, wchar_t*& pUnicodes, LONG& lOutputCount )\n    {\n        if (sizeof(WCHAR) == 2)\n            return GetUnicodeStringFromUTF8WithHHHH_2bytes(pBuffer, lCount, pUnicodes, lOutputCount);\n        return GetUnicodeStringFromUTF8WithHHHH_4bytes(pBuffer, lCount, pUnicodes, lOutputCount);\n    }\n\n    void CUtf8Converter::GetUtf8StringFromUnicode_4bytes(const wchar_t* pUnicodes, LONG lCount, BYTE*& pData, LONG& lOutputCount, bool bIsBOM)\n    {\n        if (NULL == pData)\n        {\n            pData = new BYTE[6 * lCount + 3 + 1 ];\n        }\n\n        BYTE* pCodesCur = pData;\n        if (bIsBOM)\n        {\n            pCodesCur[0] = 0xEF;\n            pCodesCur[1] = 0xBB;\n            pCodesCur[2] = 0xBF;\n            pCodesCur += 3;\n        }\n\n        const wchar_t* pEnd = pUnicodes + lCount;\n        const wchar_t* pCur = pUnicodes;\n\n        while (pCur < pEnd)\n        {\n            unsigned int code = (unsigned int)*pCur++;\n\n            if (code < 0x80)\n            {\n                *pCodesCur++ = (BYTE)code;\n            }\n            else if (code < 0x0800)\n            {\n                *pCodesCur++ = 0xC0 | (code >> 6);\n                *pCodesCur++ = 0x80 | (code & 0x3F);\n            }\n            else if (code < 0x10000)\n            {\n                *pCodesCur++ = 0xE0 | (code >> 12);\n                *pCodesCur++ = 0x80 | (code >> 6 & 0x3F);\n                *pCodesCur++ = 0x80 | (code & 0x3F);\n            }\n            else if (code < 0x1FFFFF)\n            {\n                *pCodesCur++ = 0xF0 | (code >> 18);\n                *pCodesCur++ = 0x80 | (code >> 12 & 0x3F);\n                *pCodesCur++ = 0x80 | (code >> 6 & 0x3F);\n                *pCodesCur++ = 0x80 | (code & 0x3F);\n            }\n            else if (code < 0x3FFFFFF)\n            {\n                *pCodesCur++ = 0xF8 | (code >> 24);\n                *pCodesCur++ = 0x80 | (code >> 18 & 0x3F);\n                *pCodesCur++ = 0x80 | (code >> 12 & 0x3F);\n                *pCodesCur++ = 0x80 | (code >> 6 & 0x3F);\n                *pCodesCur++ = 0x80 | (code & 0x3F);\n            }\n            else if (code < 0x7FFFFFFF)\n            {\n                *pCodesCur++ = 0xFC | (code >> 30);\n                *pCodesCur++ = 0x80 | (code >> 24 & 0x3F);\n                *pCodesCur++ = 0x80 | (code >> 18 & 0x3F);\n                *pCodesCur++ = 0x80 | (code >> 12 & 0x3F);\n                *pCodesCur++ = 0x80 | (code >> 6 & 0x3F);\n                *pCodesCur++ = 0x80 | (code & 0x3F);\n            }\n        }\n\n        lOutputCount = (LONG)(pCodesCur - pData);\n        *pCodesCur++ = 0;\n    }\n\n    void CUtf8Converter::GetUtf8StringFromUnicode_2bytes(const wchar_t* pUnicodes, LONG lCount, BYTE*& pData, LONG& lOutputCount, bool bIsBOM)\n    {\n        if (NULL == pData)\n        {\n            pData = new BYTE[6 * lCount + 3 + 1];\n        }\n\n        BYTE* pCodesCur = pData;\n        if (bIsBOM)\n        {\n            pCodesCur[0] = 0xEF;\n            pCodesCur[1] = 0xBB;\n            pCodesCur[2] = 0xBF;\n            pCodesCur += 3;\n        }\n\n        const wchar_t* pEnd = pUnicodes + lCount;\n        const wchar_t* pCur = pUnicodes;\n\n        while (pCur < pEnd)\n        {\n            unsigned int code = (unsigned int)*pCur++;\n            if (code >= 0xD800 && code <= 0xDFFF && pCur < pEnd)\n            {\n                code = 0x10000 + (((code & 0x3FF) << 10) | (0x03FF & *pCur++));\n            }\n\n            if (code < 0x80)\n            {\n                *pCodesCur++ = (BYTE)code;\n            }\n            else if (code < 0x0800)\n            {\n                *pCodesCur++ = 0xC0 | (code >> 6);\n                *pCodesCur++ = 0x80 | (code & 0x3F);\n            }\n            else if (code < 0x10000)\n            {\n                *pCodesCur++ = 0xE0 | (code >> 12);\n                *pCodesCur++ = 0x80 | ((code >> 6) & 0x3F);\n                *pCodesCur++ = 0x80 | (code & 0x3F);\n            }\n            else if (code < 0x1FFFFF)\n            {\n                *pCodesCur++ = 0xF0 | (code >> 18);\n                *pCodesCur++ = 0x80 | ((code >> 12) & 0x3F);\n                *pCodesCur++ = 0x80 | ((code >> 6) & 0x3F);\n                *pCodesCur++ = 0x80 | (code & 0x3F);\n            }\n            else if (code < 0x3FFFFFF)\n            {\n                *pCodesCur++ = 0xF8 | (code >> 24);\n                *pCodesCur++ = 0x80 | ((code >> 18) & 0x3F);\n                *pCodesCur++ = 0x80 | ((code >> 12) & 0x3F);\n                *pCodesCur++ = 0x80 | ((code >> 6) & 0x3F);\n                *pCodesCur++ = 0x80 | (code & 0x3F);\n            }\n            else if (code < 0x7FFFFFFF)\n            {\n                *pCodesCur++ = 0xFC | (code >> 30);\n                *pCodesCur++ = 0x80 | ((code >> 24) & 0x3F);\n                *pCodesCur++ = 0x80 | ((code >> 18) & 0x3F);\n                *pCodesCur++ = 0x80 | ((code >> 12) & 0x3F);\n                *pCodesCur++ = 0x80 | ((code >> 6) & 0x3F);\n                *pCodesCur++ = 0x80 | (code & 0x3F);\n            }\n        }\n\n        lOutputCount = (LONG)(pCodesCur - pData);\n        *pCodesCur++ = 0;\n    }\n\n    void CUtf8Converter::GetUtf8StringFromUnicode(const wchar_t* pUnicodes, LONG lCount, BYTE*& pData, LONG& lOutputCount, bool bIsBOM)\n    {\n        if (sizeof(WCHAR) == 2)\n            return GetUtf8StringFromUnicode_2bytes(pUnicodes, lCount, pData, lOutputCount, bIsBOM);\n        return GetUtf8StringFromUnicode_4bytes(pUnicodes, lCount, pData, lOutputCount, bIsBOM);\n    }\n\n    std::string CUtf8Converter::GetUtf8StringFromUnicode2(const wchar_t* pUnicodes, LONG lCount, bool bIsBOM)\n    {\n        BYTE* pData = NULL;\n        LONG lLen = 0;\n\n        GetUtf8StringFromUnicode(pUnicodes, lCount, pData, lLen, bIsBOM);\n\n        std::string s((char*)pData, lLen);\n\n        RELEASEARRAYOBJECTS(pData);\n        return s;\n    }\n\n    std::string CUtf8Converter::GetUtf8StringFromUnicode(const std::wstring& sData)\n    {\n        return GetUtf8StringFromUnicode2(sData.c_str(), (LONG)sData.length());\n    }\n\n    // utf16\n    void CUtf8Converter::GetUtf16StringFromUnicode_4bytes(const wchar_t* pUnicodes, LONG lCount, BYTE*& pData, int& lOutputCount, bool bIsBOM)\n    {\n        if (NULL == pData)\n        {\n            pData = new BYTE[4 * lCount + 3 + 2];\n        }\n\n        BYTE* pCodesCur = pData;\n        if (bIsBOM)\n        {\n            pCodesCur[0] = 0xEF;\n            pCodesCur[1] = 0xBB;\n            pCodesCur[2] = 0xBF;\n            pCodesCur += 3;\n        }\n\n        const wchar_t* pEnd = pUnicodes + lCount;\n        const wchar_t* pCur = pUnicodes;\n\n        while (pCur < pEnd)\n        {\n            unsigned int code = (unsigned int)*pCur++;\n\n            if (code <= 0xFFFF)\n            {\n                USHORT usCode = (USHORT)(code & 0xFFFF);\n                memcpy(pCodesCur, &usCode, 2);\n                pCodesCur += 2;\n            }\n            else\n            {\n                code -= 0x10000;\n                code &= 0xFFFFF;\n\n                USHORT us1 = 0xD800 | ((code >> 10) & 0x03FF);\n                USHORT us2 = 0xDC00 | (code & 0x03FF);\n\n                memcpy(pCodesCur, &us1, 2);\n                pCodesCur += 2;\n\n                memcpy(pCodesCur, &us2, 2);\n                pCodesCur += 2;\n            }\n        }\n\n        lOutputCount = (LONG)(pCodesCur - pData);\n        *pCodesCur++ = 0;\n        *pCodesCur++ = 0;\n    }\n\n    void CUtf8Converter::GetUtf16StringFromUnicode_4bytes2(const wchar_t* pUnicodes, LONG lCount, CStringUtf16& data)\n    {\n        GetUtf16StringFromUnicode_4bytes(pUnicodes, lCount, data.Data, data.Length);\n    }\n\n    std::wstring CUtf8Converter::GetWStringFromUTF16(const CStringUtf16& data)\n    {\n        if (0 == data.Length)\n            return L\"\";\n\n        if (sizeof(wchar_t) == 2)\n            return std::wstring((wchar_t*)data.Data, data.Length / 2);\n\n        int nCount = data.Length / 2;\n        USHORT* pShort = (USHORT*)data.Data;\n\n        wchar_t* pWChar = new wchar_t[nCount + 1];\n        wchar_t* pWCurrent = pWChar;\n\n        int nCurrent = 0;\n        while (nCurrent < nCount)\n        {\n            if (*pShort < 0xD800 || *pShort > 0xDBFF)\n            {\n                *pWCurrent = (wchar_t)(*pShort);\n                ++pShort;\n                ++nCurrent;\n            }\n            else\n            {\n                *pWCurrent = (wchar_t)(((((pShort[0] - 0xD800) & 0x03FF) << 10) | ((pShort[1] - 0xDC00) & 0x03FF)) + 0x10000);\n                pShort += 2;\n                nCurrent += 2;\n            }\n            ++pWCurrent;\n        }\n\n        std::wstring sRet(pWChar, pWCurrent - pWChar);\n\n        RELEASEARRAYOBJECTS(pWChar);\n        return sRet;\n    }\n    std::wstring CUtf8Converter::GetWStringFromUTF16(const unsigned short* pUtf16, LONG lCount)\n    {\n        CStringUtf16 oString;\n        oString.Data   = (BYTE*)pUtf16;\n        oString.Length = lCount * 2;\n        std::wstring wsResult = GetWStringFromUTF16(oString);\n        oString.Data = NULL;\n        return wsResult;\n    }\n}\n\nnamespace NSFile\n{\n    CFileBinary::CFileBinary()\n    {\n        m_pFile = NULL;\n        m_lFilePosition = 0;\n        m_lFileSize = 0;\n    }\n    CFileBinary::~CFileBinary()\n    {\n        CloseFile();\n    }\n\n    void CFileBinary::CloseFile()\n    {\n        m_lFilePosition = 0;\n        m_lFileSize = 0;\n\n        if (m_pFile != NULL)\n        {\n            fclose(m_pFile);\n            m_pFile = NULL;\n        }\n    }\n\n    FILE* CFileBinary::GetFileNative()\n    {\n        return m_pFile;\n    }\n    long CFileBinary::GetFileSize()\n    {\n        return m_lFileSize;\n    }\n    long CFileBinary::GetFilePosition()\n    {\n        return m_lFilePosition;\n    }\n\n#ifdef _IOS\n    \n    bool CFileBinary::OpenFile(const std::wstring& sFileName, bool bRewrite)\n    {\n        m_pFile = fopen(fileSystemRepresentation(sFileName), bRewrite ? \"rb+\" : \"rb\");\n        \n        if (NULL == m_pFile) {\n#if DEBUG\n            //    printf (\"NSFile::OpenFile - error open file : %s\\n\",strerror(errno));\n#endif\n            return false;\n        }\n        \n        fseek(m_pFile, 0, SEEK_END);\n        m_lFileSize = ftell(m_pFile);\n        fseek(m_pFile, 0, SEEK_SET);\n        \n        m_lFilePosition = 0;\n        \n        if (0 < sFileName.length())\n        {\n            if (((wchar_t)'/') == sFileName.c_str()[sFileName.length() - 1])\n                m_lFileSize = 0x7FFFFFFF;\n        }\n        \n        unsigned int err = 0x7FFFFFFF;\n        unsigned int cur = (unsigned int)m_lFileSize;\n        if (err == cur)\n        {\n            CloseFile();\n            return false;\n        }\n        \n        return true;\n    }\n\n    bool CFileBinary::CreateFileW(const std::wstring& sFileName)\n    {\n        m_pFile = fopen(fileSystemRepresentation(sFileName), \"wb\");\n\n        if (NULL == m_pFile) {\n#if DEBUG\n        //    printf (\"NSFile::CreateFileW - error create file : %s\\n\",strerror(errno));\n#endif\n            return false;\n        }\n\n        m_lFilePosition = 0;\n        return true;\n    }\n\n#else\n\n    bool CFileBinary::OpenFile(const std::wstring& sFileName, bool bRewrite)\n    {\n#if defined(_WIN32) || defined(_WIN32_WCE) || defined(_WIN64)\n        if ( 0 != _wfopen_s(&m_pFile, sFileName.c_str(), bRewrite ? L\"rb+\" : L\"rb\"))\n            return false;\n#else\n        BYTE* pUtf8 = NULL;\n        LONG lLen = 0;\n        CUtf8Converter::GetUtf8StringFromUnicode(sFileName.c_str(), sFileName.length(), pUtf8, lLen, false);\n        m_pFile = fopen((char*)pUtf8, bRewrite ? \"rb+\" : \"rb\");\n\n        delete [] pUtf8;\n#endif\n        if (NULL == m_pFile)\n            return false;\n\n        fseek(m_pFile, 0, SEEK_END);\n        m_lFileSize = ftell(m_pFile);\n        fseek(m_pFile, 0, SEEK_SET);\n\n        m_lFilePosition = 0;\n\n        if (0 < sFileName.length())\n        {\n            if (((wchar_t)'/') == sFileName.c_str()[sFileName.length() - 1])\n                m_lFileSize = 0x7FFFFFFF;\n        }\n\n        unsigned int err = 0x7FFFFFFF;\n        unsigned int cur = (unsigned int)m_lFileSize;\n        if (err == cur)\n        {\n            CloseFile();\n            return false;\n        }\n\n        return true;\n    }\n\n    bool CFileBinary::CreateFileW(const std::wstring& sFileName)\n    {\n#if defined(_WIN32) || defined(_WIN32_WCE) || defined(_WIN64)\n         if ( 0 != _wfopen_s(&m_pFile, sFileName.c_str(), L\"wb\"))\n             return false;\n#else\n        BYTE* pUtf8 = NULL;\n        LONG lLen = 0;\n        CUtf8Converter::GetUtf8StringFromUnicode(sFileName.c_str(), sFileName.length(), pUtf8, lLen, false);\n        m_pFile = fopen((char*)pUtf8, \"wb\");\n        delete [] pUtf8;\n#endif\n        if (NULL == m_pFile)\n            return false;\n\n        m_lFilePosition = 0;\n        return true;\n    }\n\n#endif\n\n    bool CFileBinary::CreateTempFile()\n    {\n#if defined(_WIN32) || defined(_WIN32_WCE) || defined(_WIN64)\n        if (0 != tmpfile_s(&m_pFile))\n            return false;\n#else\n        m_pFile = tmpfile();\n        if (NULL == m_pFile)\n            return false;\n#endif\n        m_lFilePosition = 0;\n        return true;\n    }\n    bool CFileBinary::SeekFile(int lFilePosition, int nSeekMode)\n    {\n        if (!m_pFile)\n            return false;\n\n        m_lFilePosition = fseek(m_pFile, lFilePosition, nSeekMode);\n        return true;\n    }\n    bool CFileBinary::ReadFile(BYTE* pData, DWORD nBytesToRead, DWORD& dwSizeRead)\n    {\n        if (!m_pFile)\n            return false;\n\n        dwSizeRead = (DWORD)fread((void*)pData, 1, nBytesToRead, m_pFile);\n        return true;\n    }\n    bool CFileBinary::WriteFile(const BYTE* pData, DWORD nBytesCount)\n    {\n        if (!m_pFile)\n            return false;\n\n        size_t nCountWrite = fwrite((const void*)pData, 1, nBytesCount, m_pFile);\n        return true;\n    }\n    long CFileBinary::TellFile()\n    {\n        if (!m_pFile)\n            return 0;\n\n        return ftell(m_pFile);\n    }\n    long CFileBinary::SizeFile()\n    {\n        if (!m_pFile)\n            return 0;\n\n        long lPos = TellFile();\n        fseek(m_pFile, 0, SEEK_END);\n        m_lFileSize = ftell(m_pFile);\n        fseek(m_pFile, lPos, SEEK_SET);\n\n        return m_lFileSize;\n    }\n    void CFileBinary::WriteStringUTF8(const std::wstring& strXml, bool bIsBOM)\n    {\n        BYTE* pData = NULL;\n        LONG lLen = 0;\n\n        CUtf8Converter::GetUtf8StringFromUnicode(strXml.c_str(), (LONG)strXml.length(), pData, lLen, bIsBOM);\n\n        WriteFile(pData, lLen);\n\n        RELEASEARRAYOBJECTS(pData);\n    }\n    bool CFileBinary::ReadAllBytes(const std::wstring&  strFileName, BYTE** ppData, DWORD& nBytesCount)\n    {\n        *ppData = NULL;\n        nBytesCount = 0;\n        bool bRes = false;\n        CFileBinary oFileBinary;\n        if (oFileBinary.OpenFile(strFileName))\n        {\n            long nFileSize = oFileBinary.GetFileSize();\n            BYTE* pData = new BYTE[nFileSize];\n            DWORD dwSizeRead;\n            if (oFileBinary.ReadFile(pData, nFileSize, dwSizeRead))\n            {\n                oFileBinary.CloseFile();\n                *ppData = pData;\n                nBytesCount = dwSizeRead;\n                bRes = true;\n            }\n            else\n                RELEASEARRAYOBJECTS(pData);\n        }\n        return bRes;\n    }\n    bool CFileBinary::ReadAllTextUtf8(const std::wstring&  strFileName, std::wstring& sData)\n    {\n        bool bRes = false;\n        BYTE* pData = NULL;\n        DWORD nDataSize;\n        if (CFileBinary::ReadAllBytes(strFileName, &pData, nDataSize))\n        {\n            //remove BOM if exist\n            BYTE* pDataStart = pData;\n            DWORD nBOMSize = 3;\n            if (nDataSize > nBOMSize && 0xef == pDataStart[0] && 0xbb == pDataStart[1] && 0xbf == pDataStart[2])\n            {\n                pDataStart += nBOMSize;\n                nDataSize -= nBOMSize;\n            }\n            sData = CUtf8Converter::GetUnicodeStringFromUTF8(pDataStart, nDataSize);\n            RELEASEARRAYOBJECTS(pData);\n            bRes = true;\n        }\n        return bRes;\n    }\n    bool CFileBinary::ReadAllTextUtf8A(const std::wstring&  strFileName, std::string& sData)\n    {\n        bool bRes = false;\n        BYTE* pData = NULL;\n        DWORD nDataSize;\n        if (CFileBinary::ReadAllBytes(strFileName, &pData, nDataSize))\n        {\n            //remove BOM if exist\n            BYTE* pDataStart = pData;\n            DWORD nBOMSize = 3;\n            if (nDataSize > nBOMSize && 0xef == pDataStart[0] && 0xbb == pDataStart[1] && 0xbf == pDataStart[2])\n            {\n                pDataStart += nBOMSize;\n                nDataSize -= nBOMSize;\n            }\n            sData = std::string((char*)pDataStart, nDataSize);\n            RELEASEARRAYOBJECTS(pData);\n            bRes = true;\n        }\n        return bRes;\n    }\n    bool CFileBinary::SaveToFile(const std::wstring&  strFileName, const std::wstring& strXml, bool bIsBOM)\n    {\n        CFileBinary oFile;\n        oFile.CreateFileW(strFileName);\n        oFile.WriteStringUTF8(strXml, bIsBOM);\n        oFile.CloseFile();\n        return true;\n    }\n    bool CFileBinary::Exists(const std::wstring&  strFileName)\n    {\n#if defined(_WIN32) || defined(_WIN32_WCE) || defined(_WIN64)\n        FILE* pFile = NULL;\n        if ( 0 != _wfopen_s( &pFile, strFileName.c_str(), L\"rb\"))\n            return false;\n#else\n        BYTE* pUtf8 = NULL;\n        LONG lLen = 0;\n        CUtf8Converter::GetUtf8StringFromUnicode(strFileName.c_str(), strFileName.length(), pUtf8, lLen, false);\n        FILE* pFile = fopen((char*)pUtf8, \"rb\");\n        delete [] pUtf8;\n#endif\n        if (NULL != pFile)\n        {\n            fclose(pFile);\n            return true;\n        }\n        else\n            return false;\n    }\n    bool CFileBinary::Copy(const std::wstring&  strSrc, const std::wstring& strDst)\n    {\n        if (strSrc == strDst)\n            return true;\n\n        std::ifstream src;\n        std::ofstream dst;\n\n        int nLenBuffer = 1024 * 1024; // 10\n        CFileBinary oFile;\n        if (oFile.OpenFile(strSrc))\n        {\n            int nFileSize = (int)oFile.GetFileSize();\n            if (nFileSize < nLenBuffer)\n                nLenBuffer = nFileSize;\n\n            oFile.CloseFile();\n        }\n        else\n        {\n#ifdef _WIN32\n            return (0 != ::CopyFileW(strSrc.c_str(), strDst.c_str(), 1));\n#endif\n        }\n\n        char* pBuffer_in = NULL;\n        char* pBuffer_out = NULL;\n\n        if (nLenBuffer > 0)\n        {\n            pBuffer_in = new char[nLenBuffer];\n            pBuffer_out = new char[nLenBuffer];\n\n            src.rdbuf()->pubsetbuf(pBuffer_in, nLenBuffer);\n            dst.rdbuf()->pubsetbuf(pBuffer_out, nLenBuffer);\n        }\n\n#if defined(_WIN32) || defined(_WIN32_WCE) || defined(_WIN64)\n        src.open(strSrc.c_str(), std::ios::binary);\n        dst.open(strDst.c_str(), std::ios::binary);\n#else\n        BYTE* pUtf8Src = NULL;\n        LONG lLenSrc = 0;\n        CUtf8Converter::GetUtf8StringFromUnicode(strSrc.c_str(), strSrc.length(), pUtf8Src, lLenSrc, false);\n        BYTE* pUtf8Dst = NULL;\n        LONG lLenDst = 0;\n        CUtf8Converter::GetUtf8StringFromUnicode(strDst.c_str(), strDst.length(), pUtf8Dst, lLenDst, false);\n\n        src.open((char*)pUtf8Src, std::ios::binary);\n        dst.open((char*)pUtf8Dst, std::ios::binary);\n\n        delete [] pUtf8Src;\n        delete [] pUtf8Dst;\n#endif\n\n        bool bRet = false;\n\n        if (src.is_open() && dst.is_open())\n        {\n            dst << src.rdbuf();\n            src.close();\n            dst.close();\n\n            bRet = true;\n        }\n        RELEASEARRAYOBJECTS(pBuffer_in);\n        RELEASEARRAYOBJECTS(pBuffer_out);\n        return bRet;\n    }\n    bool CFileBinary::Remove(const std::wstring& strFileName)\n    {\n#if defined(_WIN32) || defined(_WIN32_WCE) || defined(_WIN64)\n        int nRes = _wremove(strFileName.c_str());\n#else\n        BYTE* pUtf8 = NULL;\n        LONG lLen = 0;\n        CUtf8Converter::GetUtf8StringFromUnicode(strFileName.c_str(), strFileName.length(), pUtf8, lLen, false);\n        int nRes = std::remove((char*)pUtf8);\n        delete [] pUtf8;\n#endif\n        return 0 == nRes;\n    }\n    bool CFileBinary::Move(const std::wstring&  strSrc, const std::wstring& strDst)\n    {\n        if (strSrc == strDst)\n            return true;\n        if (Copy(strSrc, strDst))\n            if (Remove(strSrc))\n                return true;\n        return false;\n    }\n\n    bool CFileBinary::Truncate(const std::wstring& sPath, size_t nNewSize)\n    {\n        bool bIsSuccess = false;\n\n#if defined(_WIN32) || defined(_WIN32_WCE) || defined(_WIN64)\n        HANDLE hFile = ::CreateFileW( sPath.c_str(), GENERIC_WRITE, FILE_SHARE_READ,\n                                        NULL, OPEN_EXISTING,\n                                        FILE_ATTRIBUTE_NORMAL, NULL );\n        if ( hFile == INVALID_HANDLE_VALUE )\n        {\n            return bIsSuccess;\n        }\n\n        LARGE_INTEGER Size = { 0 };\n\n        if ( GetFileSizeEx( hFile, &Size ) )\n        {\n            LARGE_INTEGER Distance = { 0 };\n            // Negative values move the pointer backward in the file\n            Distance.QuadPart = (LONGLONG)nNewSize - Size.QuadPart;\n            bIsSuccess = (SetFilePointerEx(hFile, Distance, NULL, FILE_END) && SetEndOfFile(hFile));\n        }\n\n        CloseHandle( hFile );\n#else\n        std::string sFileUTF8 = U_TO_UTF8(sPath);\n        bIsSuccess = (0 == truncate(sFileUTF8.c_str(), nNewSize));\n#endif\n        return bIsSuccess;\n    }\n\n    std::wstring CFileBinary::GetTempPath()\n    {\n        if (!g_overrideTmpPath.empty())\n            return g_overrideTmpPath;\n\n#if defined(_WIN32) || defined(_WIN32_WCE) || defined(_WIN64)\n        wchar_t pBuffer[MAX_PATH + 1];\n        memset(pBuffer, 0, sizeof(wchar_t) * (MAX_PATH + 1));\n        ::GetTempPathW(MAX_PATH, pBuffer);\n\n        std::wstring sRet(pBuffer);\n\n        size_t nSeparatorPos = sRet.find_last_of(wchar_t('/'));\n        if (std::wstring::npos == nSeparatorPos)\n        {\n            nSeparatorPos = sRet.find_last_of(wchar_t('\\\\'));\n        }\n\n        if (std::wstring::npos == nSeparatorPos)\n            return L\"\";\n\n        return sRet.substr(0, nSeparatorPos);\n#else\n        char *folder = getenv(\"TEMP\");\n\n        if (NULL == folder)\n            folder = getenv(\"TMP\");\n        if (NULL == folder)\n            folder = getenv(\"TMPDIR\");\n        if (NULL == folder)\n            folder = \"/tmp\";\n\n        return NSFile::CUtf8Converter::GetUnicodeStringFromUTF8((BYTE*)folder, strlen(folder));\n#endif\n    }\n    std::wstring CFileBinary::CreateTempFileWithUniqueName(const std::wstring& strFolderPathRoot, const std::wstring& Prefix)\n    {\n#if defined(_WIN32) || defined(_WIN32_WCE) || defined(_WIN64)\n        wchar_t pBuffer[MAX_PATH + 1];\n        ::GetTempFileNameW(strFolderPathRoot.c_str(), Prefix.c_str(), 0, pBuffer);\n        std::wstring sRet(pBuffer);\n        return sRet;\n#else\n        char pcRes[MAX_PATH];\n        BYTE* pData = (BYTE*)pcRes;\n\n        std::wstring sPrefix = strFolderPathRoot + L\"/\" + Prefix + L\"_XXXXXX\";\n        LONG lLen = 0;\n        NSFile::CUtf8Converter::GetUtf8StringFromUnicode(sPrefix.c_str(), (LONG)sPrefix.length(), pData, lLen);\n        pcRes[lLen] = '\\0';\n\n        int res = mkstemp(pcRes);\n        if (-1 != res)\n            close(res);\n\n        std::string sRes = pcRes;\n        return NSFile::CUtf8Converter::GetUnicodeStringFromUTF8((BYTE*)sRes.c_str(), sRes.length());\n#endif\n    }\n    bool CFileBinary::OpenTempFile(std::wstring *pwsName, FILE **ppFile, wchar_t *wsMode, wchar_t *wsExt, wchar_t *wsFolder, wchar_t* wsName)\n    {\n        // TODO: \u0420\u0435\u0430\u043b\u0438\u0437\u043e\u0432\u0430\u0442\u044c \u043a\u043e\u0433\u0434\u0430 wsName != NULL\n\n        std::wstring wsTemp, wsFileName;\n        FILE *pTempFile = NULL;\n#if defined(_WIN32) || defined (_WIN64)\n        wchar_t *wsTempDir = NULL;\n        size_t sz = 0;\n        if ( (0 == _wdupenv_s(&wsTempDir, &sz, L\"TEMP\")) && (wsFolder == NULL))\n        {\n            wsTemp = std::wstring(wsTempDir, sz-1);\n#else\n        char *wsTempDirA;\n        if ((wsTempDirA = getenv(\"TEMP\")) && (wsFolder == NULL))\n        {\n            std::wstring wsTempDir = NSFile::CUtf8Converter::GetUnicodeStringFromUTF8((BYTE*)wsTempDirA, strlen(wsTempDirA));\n            wsTemp = wsTempDir.c_str();\n#endif\n            wsTemp += L\"/\";\n        }\n        else if (wsFolder != NULL)\n        {\n            wsTemp = std::wstring(wsFolder);\n            wsTemp += L\"/\";\n        }\n        else\n        {\n            wsTemp = L\"\";\n        }\n        wsTemp += L\"x\";\n        int nTime = (int)time(NULL);\n        for (int nIndex = 0; nIndex < 1000; ++nIndex)\n        {\n            wsFileName = wsTemp;\n            wsFileName.append(std::to_wstring(nTime + nIndex));\n\n            if (wsExt)\n            {\n                wsFileName.append(wsExt);\n            }\n#if defined (_WIN32) || defined (_WIN64)\n            if ( 0 != _wfopen_s(&pTempFile, wsFileName.c_str(), L\"r\") )\n            {\n                if (0 != _wfopen_s(&pTempFile, wsFileName.c_str(), wsMode))\n#else\n            std::string sFileName = U_TO_UTF8(wsFileName);\n            if (!(pTempFile = fopen(sFileName.c_str(), \"r\")))\n            {\n                std::wstring strMode(wsMode);\n                std::string sMode = U_TO_UTF8(strMode);\n                if (!(pTempFile = fopen(sFileName.c_str(), sMode.c_str())))\n#endif\n                {\n                    return FALSE;\n                }\n                *pwsName = wsFileName;\n                *ppFile = pTempFile;\n                return TRUE;\n            }\n\n            fclose(pTempFile);\n        }\n\n        return FALSE;\n    }\n    FILE* CFileBinary::OpenFileNative(const std::wstring& sFileName, const std::wstring& sMode)\n    {\n#if defined(_WIN32) || defined(_WIN32_WCE) || defined(_WIN64)\n        FILE* pFile = NULL;\n        _wfopen_s(&pFile, sFileName.c_str(), sMode.c_str());\n\n        return pFile;\n#else\n        BYTE* pUtf8 = NULL;\n        LONG lLen = 0;\n        CUtf8Converter::GetUtf8StringFromUnicode(sFileName.c_str(), sFileName.length(), pUtf8, lLen, false);\n\n        BYTE* pMode = NULL;\n        LONG lLenMode;\n        CUtf8Converter::GetUtf8StringFromUnicode(sMode.c_str(), sMode.length(), pMode, lLenMode, false);\n\n        FILE* pFile = fopen((char*)pUtf8, (char*)pMode);\n\n        delete [] pUtf8;\n        delete [] pMode;\n\n        return pFile;\n#endif\n    }\n\n    void CFileBinary::SetTempPath(const std::wstring& strTempPath)\n    {\n        g_overrideTmpPath = strTempPath;\n    }\n\n    unsigned long CFileBinary::GetDateTime(const std::wstring & inputFile)\n    {\n        unsigned long result = 0;\n#if defined(_WIN32) || defined (_WIN64)\n        HANDLE hFile;\n        hFile = ::CreateFileW(inputFile.c_str(), GENERIC_READ, FILE_SHARE_READ,  NULL,  OPEN_EXISTING,  FILE_ATTRIBUTE_NORMAL, NULL);\n\n        if (hFile)\n        {\n            FILETIME ft; ft.dwLowDateTime = ft.dwHighDateTime = 0;\n            if (GetFileTime(hFile, NULL, NULL, &ft))\n            {\n                WORD fatDate = 0, fatTime = 0;\n                if (FileTimeToDosDateTime(&ft, &fatDate,  &fatTime))\n                {\n                    result = (fatDate << 16) + fatTime;\n                }\n            }\n            CloseHandle(hFile);\n        }\n#else\n        std::string inputFileA = U_TO_UTF8(inputFile);\n#if defined(__linux__) && !defined(_MAC)\n        struct stat attrib;\n        stat(inputFileA.c_str(), &attrib);\n        result = attrib.st_mtim.tv_nsec;\n#else\n        struct stat attrib;\n        stat(inputFileA.c_str(), &attrib);\n        result = (unsigned long)attrib.st_mtimespec.tv_nsec;\n#endif\n#endif\n        return result;\n    }\n}\n\nnamespace NSFile\n{\n    bool CBase64Converter::Encode(BYTE* pDataSrc, int nLenSrc, char*& pDataDst, int& nLenDst, DWORD dwFlags)\n    {\n        if (!pDataSrc || nLenSrc < 1)\n            return false;\n\n        nLenDst = NSBase64::Base64EncodeGetRequiredLength(nLenSrc, dwFlags);\n        pDataDst = new char[nLenDst];\n\n        if (FALSE == NSBase64::Base64Encode(pDataSrc, nLenSrc, (BYTE*)pDataDst, &nLenDst, dwFlags))\n        {\n            RELEASEARRAYOBJECTS(pDataDst);\n            return false;\n        }\n        return true;\n    }\n    bool CBase64Converter::Decode(const char* pDataSrc, int nLenSrc, BYTE*& pDataDst, int& nLenDst)\n    {\n        if (!pDataSrc || nLenSrc < 1)\n            return false;\n\n        nLenDst = NSBase64::Base64DecodeGetRequiredLength(nLenSrc);\n        pDataDst = new BYTE[nLenDst];\n\n        if (FALSE == NSBase64::Base64Decode(pDataSrc, nLenSrc, pDataDst, &nLenDst))\n        {\n            RELEASEARRAYOBJECTS(pDataDst);\n            return false;\n        }\n        return true;\n    }\n}\n\nnamespace NSFile\n{\n    std::wstring GetProcessPath()\n    {\n#if defined (_WIN64) || defined(_WIN32)\n        wchar_t buf [NS_FILE_MAX_PATH];\n        GetModuleFileNameW(GetModuleHandle(NULL), buf, NS_FILE_MAX_PATH);\n        return std::wstring(buf);\n#endif\n\n#if defined(__linux__) || defined(_MAC) && !defined(_IOS)\n        char buf[NS_FILE_MAX_PATH];\n        memset(buf, 0, NS_FILE_MAX_PATH);\n        if (readlink (\"/proc/self/exe\", buf, NS_FILE_MAX_PATH) <= 0)\n        {\n#ifdef _MAC\n            uint32_t _size = NS_FILE_MAX_PATH;\n            _NSGetExecutablePath(buf, &_size);\n            std::string sUTF8(buf);\n            std::wstring sRet = CUtf8Converter::GetUnicodeStringFromUTF8((BYTE*)sUTF8.c_str(), sUTF8.length());\n            return sRet;\n#endif\n            return L\"\";\n        }\n\n        std::string sUTF8(buf);\n        std::wstring sRet = CUtf8Converter::GetUnicodeStringFromUTF8((BYTE*)sUTF8.c_str(), sUTF8.length());\n        return sRet;\n#endif\n\n        return L\"\";\n    }\n\n    std::wstring GetProcessDirectory()\n    {\n        std::wstring sPath = GetProcessPath();\n\n        size_t pos1 = sPath.find_last_of(wchar_t('/'));\n        size_t pos2 = sPath.find_last_of(wchar_t('\\\\'));\n\n        size_t pos = std::wstring::npos;\n        if (pos1 != std::wstring::npos)\n            pos = pos1;\n\n        if (pos2 != std::wstring::npos)\n        {\n            if (pos == std::wstring::npos)\n                pos = pos2;\n            else if (pos2 > pos)\n                pos = pos2;\n        }\n\n        if (pos != std::wstring::npos)\n        {\n            sPath = sPath.substr(0, pos);\n        }\n        return sPath;\n    }\n\n    // CommonFunctions\n    std::wstring GetFileExtention(const std::wstring& sPath)\n    {\n        std::wstring::size_type nPos = sPath.rfind('.');\n        if (nPos != std::wstring::npos)\n            return sPath.substr(nPos + 1);\n        return sPath;\n    }\n    std::wstring GetFileName(const std::wstring& sPath)\n    {\n        std::wstring::size_type nPos1 = sPath.rfind('\\\\');\n        std::wstring::size_type nPos2 = sPath.rfind('/');\n        std::wstring::size_type nPos = std::wstring::npos;\n\n        if (nPos1 != std::wstring::npos)\n        {\n            nPos = nPos1;\n            if (nPos2 != std::wstring::npos && nPos2 > nPos)\n                nPos = nPos2;\n        }\n        else\n            nPos = nPos2;\n\n        if (nPos == std::wstring::npos)\n            return sPath;\n        return sPath.substr(nPos + 1);\n    }\n    std::wstring GetDirectoryName(const std::wstring& sPath)\n    {\n        std::wstring::size_type nPos1 = sPath.rfind('\\\\');\n        std::wstring::size_type nPos2 = sPath.rfind('/');\n        std::wstring::size_type nPos = std::wstring::npos;\n\n        if (nPos1 != std::wstring::npos)\n        {\n            nPos = nPos1;\n            if (nPos2 != std::wstring::npos && nPos2 > nPos)\n                nPos = nPos2;\n        }\n        else\n            nPos = nPos2;\n\n        if (nPos == std::wstring::npos)\n            return sPath;\n        return sPath.substr(0, nPos);\n    }\n}\n", "\ufeff/*\r\n * File:\txfile.h\r\n * Purpose:\tGeneral Purpose File Class \r\n */\r\n/*\r\n  --------------------------------------------------------------------------------\r\n\r\n\tCOPYRIGHT NOTICE, DISCLAIMER, and LICENSE:\r\n\r\n\tCxFile (c)  11/May/2002 Davide Pizzolato - www.xdp.it\r\n\tCxFile version 2.00 23/Aug/2002\r\n\tCxFile version 2.10 16/Dec/2007\r\n\t\r\n\tSpecial thanks to Chris Shearer Cooper for new features, enhancements and bugfixes\r\n\r\n\tCovered code is provided under this license on an \"as is\" basis, without warranty\r\n\tof any kind, either expressed or implied, including, without limitation, warranties\r\n\tthat the covered code is free of defects, merchantable, fit for a particular purpose\r\n\tor non-infringing. The entire risk as to the quality and performance of the covered\r\n\tcode is with you. Should any covered code prove defective in any respect, you (not\r\n\tthe initial developer or any other contributor) assume the cost of any necessary\r\n\tservicing, repair or correction. This disclaimer of warranty constitutes an essential\r\n\tpart of this license. No use of any covered code is authorized hereunder except under\r\n\tthis disclaimer.\r\n\r\n\tPermission is hereby granted to use, copy, modify, and distribute this\r\n\tsource code, or portions hereof, for any purpose, including commercial applications,\r\n\tfreely and without fee, subject to the following restrictions: \r\n\r\n\t1. The origin of this software must not be misrepresented; you must not\r\n\tclaim that you wrote the original software. If you use this software\r\n\tin a product, an acknowledgment in the product documentation would be\r\n\tappreciated but is not required.\r\n\r\n\t2. Altered source versions must be plainly marked as such, and must not be\r\n\tmisrepresented as being the original software.\r\n\r\n\t3. This notice may not be removed or altered from any source distribution.\r\n  --------------------------------------------------------------------------------\r\n */\r\n#if !defined(__xfile_h)\r\n#define __xfile_h\r\n\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n\r\n#include \"ximadef.h\"\r\n\r\nclass DLL_EXP CxFile\r\n{\r\npublic:\r\n\tCxFile(void) { }\r\n\tvirtual ~CxFile() { }\r\n\r\n\tvirtual bool\tClose() = 0;\r\n\tvirtual size_t\tRead(void *buffer, size_t size, size_t count, void* limit_start = NULL, void* limit_end = NULL) = 0;\r\n\tvirtual size_t\tWrite(const void *buffer, size_t size, size_t count) = 0;\r\n\tvirtual bool\tSeek(int32_t offset, int32_t origin) = 0;\r\n\tvirtual int32_t\tTell() = 0;\r\n\tvirtual int32_t\tSize() = 0;\r\n\tvirtual bool\tFlush() = 0;\r\n\tvirtual bool\tEof() = 0;\r\n\tvirtual int32_t\tError() = 0;\r\n\tvirtual bool\tPutC(uint8_t c)\r\n\t\t{\r\n\t\t// Default implementation\r\n\t\tsize_t nWrote = Write(&c, 1, 1);\r\n\t\treturn (bool)(nWrote == 1);\r\n\t\t}\r\n\tvirtual int32_t\tGetC() = 0;\r\n\tvirtual char *\tGetS(char *string, int32_t n) = 0;\r\n\tvirtual int32_t\tScanf(const char *format, void* output) = 0;\r\n};\r\n\r\nstatic void clamp_buffer(void*& buffer, size_t& size, void* limit_start, void* limit_end)\r\n{\r\n\tif (NULL == limit_start || NULL == limit_end)\r\n\t\treturn;\r\n\r\n\tuint8_t* _buffer = (uint8_t*)buffer;\r\n\tuint8_t* _limit_start = (uint8_t*)limit_start;\r\n\tuint8_t* _limit_end = (uint8_t*)limit_end;\r\n\r\n\tif (_buffer > _limit_end)\r\n\t{\r\n\t\tbuffer = limit_end;\r\n\t\tsize = 0;\r\n\t\treturn;\r\n\t}\r\n\r\n\tif (_buffer < _limit_start)\r\n\t\t_buffer = _limit_start;\r\n\r\n\tif ((_buffer + size) > _limit_end)\r\n\t\tsize = (_limit_end - _buffer);\r\n}\r\n\r\n#endif //__xfile_h\r\n", "\ufeff/*\r\n * File:\tximabmp.cpp\r\n * Purpose:\tPlatform Independent BMP Image Class Loader and Writer\r\n * 07/Aug/2001 Davide Pizzolato - www.xdp.it\r\n * CxImage version 7.0.2 07/Feb/2011\r\n */\r\n\r\n#include \"ximabmp.h\"\r\n\r\n#if CXIMAGE_SUPPORT_BMP\r\n\r\n#include \"ximaiter.h\" \r\n\r\n#ifndef min\r\n#define min(a,b) (((a)<(b))?(a):(b))\r\n#endif\r\n#ifndef max\r\n#define max(a,b) (((a)>(b))?(a):(b))\r\n#endif\r\n\r\n////////////////////////////////////////////////////////////////////////////////\r\n#if CXIMAGE_SUPPORT_ENCODE\r\n////////////////////////////////////////////////////////////////////////////////\r\nbool CxImageBMP::Encode(CxFile * hFile)\r\n{\r\n\r\n\tif (EncodeSafeCheck(hFile)) return false;\r\n\r\n\tBITMAPFILEHEADER\thdr;\r\n\r\n\thdr.bfType = 0x4d42;   // 'BM' WINDOWS_BITMAP_SIGNATURE\r\n\thdr.bfSize = GetSize() + 14 /*sizeof(BITMAPFILEHEADER)*/;\r\n\thdr.bfReserved1 = hdr.bfReserved2 = 0;\r\n\thdr.bfOffBits = 14 /*sizeof(BITMAPFILEHEADER)*/ + head.biSize + GetPaletteSize();\r\n\r\n\thdr.bfType = m_ntohs(hdr.bfType); \r\n\thdr.bfSize = m_ntohl(hdr.bfSize); \r\n\thdr.bfOffBits = m_ntohl(hdr.bfOffBits); \r\n\r\n#if CXIMAGE_SUPPORT_ALPHA\r\n\tif (GetNumColors()==0 && AlphaIsValid()){\r\n\t\r\n\t\tBITMAPINFOHEADER  infohdr;\r\n\t\tmemcpy(&infohdr,&head,sizeof(BITMAPINFOHEADER));\r\n\t\tinfohdr.biCompression = BI_RGB;\r\n\t\tinfohdr.biBitCount = 32;\r\n\t\tuint32_t dwEffWidth = ((((infohdr.biBitCount * infohdr.biWidth) + 31) / 32) * 4);\r\n\t\tinfohdr.biSizeImage = dwEffWidth * infohdr.biHeight;\r\n\r\n\t\thdr.bfSize = infohdr.biSize + infohdr.biSizeImage + 14 /*sizeof(BITMAPFILEHEADER)*/;\r\n\r\n\t\thdr.bfSize = m_ntohl(hdr.bfSize);\r\n\t\tbihtoh(&infohdr);\r\n\r\n\t\t// Write the file header\r\n\t\thFile->Write(&hdr,min(14,sizeof(BITMAPFILEHEADER)),1);\r\n\t\thFile->Write(&infohdr,sizeof(BITMAPINFOHEADER),1);\r\n\t\t //and DIB+ALPHA interlaced\r\n\t\tuint8_t *srcalpha = AlphaGetPointer();\r\n\t\tfor(int32_t y = 0; y < infohdr.biHeight; ++y){\r\n\t\t\tuint8_t *srcdib = GetBits(y);\r\n\t\t\tfor(int32_t x = 0; x < infohdr.biWidth; ++x){\r\n\t\t\t\thFile->Write(srcdib,3,1);\r\n\t\t\t\thFile->Write(srcalpha,1,1);\r\n\t\t\t\tsrcdib += 3;\r\n\t\t\t\t++srcalpha;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t} else \r\n#endif //CXIMAGE_SUPPORT_ALPHA\r\n\t{\r\n\t\t// Write the file header\r\n\t\thFile->Write(&hdr,min(14,sizeof(BITMAPFILEHEADER)),1);\r\n\t\t//copy attributes\r\n\t\tmemcpy(pDib,&head,sizeof(BITMAPINFOHEADER));\r\n\t\tbihtoh((BITMAPINFOHEADER*)pDib);\r\n\t\t// Write the DIB header and the pixels\r\n\t\thFile->Write(pDib,GetSize(),1);\r\n\t\tbihtoh((BITMAPINFOHEADER*)pDib);\r\n\t}\r\n\treturn true;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n#endif //CXIMAGE_SUPPORT_ENCODE\r\n////////////////////////////////////////////////////////////////////////////////\r\n#if CXIMAGE_SUPPORT_DECODE\r\n////////////////////////////////////////////////////////////////////////////////\r\nbool CxImageBMP::Decode(CxFile * hFile)\r\n{\r\n\tif (hFile == NULL) return false;\r\n\r\n\tBITMAPFILEHEADER   bf;\r\n\tuint32_t off = hFile->Tell(); //<CSC>\r\n  cx_try {\r\n\tif (hFile->Read(&bf,min(14,sizeof(bf)),1)==0) cx_throw(\"Not a BMP\");\r\n\r\n\tbf.bfSize = m_ntohl(bf.bfSize); \r\n\tbf.bfOffBits = m_ntohl(bf.bfOffBits); \r\n\r\n    if (m_ntohs(bf.bfType) != BFT_BITMAP) { //do we have a RC HEADER?\r\n        bf.bfOffBits = 0L;\r\n        hFile->Seek(off,SEEK_SET);\r\n    }\r\n\r\n\tBITMAPINFOHEADER bmpHeader;\r\n\tif (!DibReadBitmapInfo(hFile,&bmpHeader)) cx_throw(\"Error reading BMP info\");\r\n\tuint32_t dwCompression=bmpHeader.biCompression;\r\n\tuint32_t dwBitCount=bmpHeader.biBitCount; //preserve for BI_BITFIELDS compression <Thomas Ernst>\r\n\tbool bIsOldBmp = bmpHeader.biSize == sizeof(BITMAPCOREHEADER);\r\n\r\n\tbool bTopDownDib = bmpHeader.biHeight<0; //<Flanders> check if it's a top-down bitmap\r\n\tif (bTopDownDib) bmpHeader.biHeight=-bmpHeader.biHeight;\r\n\r\n\tif (info.nEscape == -1) {\r\n\t\t// Return output dimensions only\r\n\t\thead.biWidth = bmpHeader.biWidth;\r\n\t\thead.biHeight = bmpHeader.biHeight;\r\n\t\tinfo.dwType = CXIMAGE_FORMAT_BMP;\r\n\t\tcx_throw(\"output dimensions returned\");\r\n\t}\r\n\r\n\tif (!Create(bmpHeader.biWidth,bmpHeader.biHeight,bmpHeader.biBitCount,CXIMAGE_FORMAT_BMP))\r\n\t\tcx_throw(\"\");\r\n\r\n\tSetXDPI((int32_t) floor(bmpHeader.biXPelsPerMeter * 254.0 / 10000.0 + 0.5));\r\n\tSetYDPI((int32_t) floor(bmpHeader.biYPelsPerMeter * 254.0 / 10000.0 + 0.5));\r\n\r\n\tif (info.nEscape) cx_throw(\"Cancelled\"); // <vho> - cancel decoding\r\n\r\n    RGBQUAD *pRgb = GetPalette();\r\n    if (pRgb){\r\n        if (bIsOldBmp){\r\n             // convert a old color table (3 byte entries) to a new\r\n             // color table (4 byte entries)\r\n            hFile->Read((void*)pRgb,DibNumColors(&bmpHeader) * sizeof(RGBTRIPLE),1,GetDIB(),GetDIBLimit());\r\n            for (int32_t i=DibNumColors(&head)-1; i>=0; i--){\r\n                pRgb[i].rgbRed      = ((RGBTRIPLE *)pRgb)[i].rgbtRed;\r\n                pRgb[i].rgbBlue     = ((RGBTRIPLE *)pRgb)[i].rgbtBlue;\r\n                pRgb[i].rgbGreen    = ((RGBTRIPLE *)pRgb)[i].rgbtGreen;\r\n                pRgb[i].rgbReserved = (uint8_t)0;\r\n            }\r\n        } else {\r\n            hFile->Read((void*)pRgb,DibNumColors(&bmpHeader) * sizeof(RGBQUAD),1,GetDIB(),GetDIBLimit());\r\n\t\t\t//force rgbReserved=0, to avoid problems with some WinXp bitmaps\r\n\t\t\tfor (uint32_t i=0; i<head.biClrUsed; i++) pRgb[i].rgbReserved=0;\r\n        }\r\n    }\r\n\r\n\tif (info.nEscape) cx_throw(\"Cancelled\"); // <vho> - cancel decoding\r\n\r\n\tswitch (dwBitCount) {\r\n\t\tcase 32 :\r\n\t\t\tuint32_t bfmask[3];\r\n\t\t\tif (dwCompression == BI_BITFIELDS)\r\n\t\t\t{\r\n\t\t\t\thFile->Read(bfmask, 12, 1);\r\n\t\t\t} else {\r\n\t\t\t\tbfmask[0]=0x00FF0000;\r\n\t\t\t\tbfmask[1]=0x0000FF00;\r\n\t\t\t\tbfmask[2]=0x000000FF;\r\n\t\t\t}\r\n\t\t\tif (bf.bfOffBits != 0L) hFile->Seek(off + bf.bfOffBits,SEEK_SET);\r\n\t\t\tif (dwCompression == BI_BITFIELDS || dwCompression == BI_RGB){\r\n\t\t\t\tint32_t imagesize=4*head.biHeight*head.biWidth;\r\n\t\t\t\tuint8_t* buff32=(uint8_t*)malloc(imagesize);\r\n\t\t\t\tif (buff32){\r\n                    hFile->Read(buff32, imagesize,1,GetDIB(),GetDIBLimit()); // read in the pixels\r\n\r\n#if CXIMAGE_SUPPORT_ALPHA\r\n\t\t\t\t\tif (dwCompression == BI_RGB){\r\n\t\t\t\t\t\tAlphaCreate();\r\n\t\t\t\t\t\tif (AlphaIsValid()){\r\n\t\t\t\t\t\t\tbool bAlphaOk = false;\r\n\t\t\t\t\t\t\tuint8_t* p;\r\n\t\t\t\t\t\t\tfor (int32_t y=0; y<head.biHeight; y++){\r\n\t\t\t\t\t\t\t\tp = buff32 + 3 + head.biWidth * 4 * y;\r\n\t\t\t\t\t\t\t\tfor (int32_t x=0; x<head.biWidth; x++){\r\n\t\t\t\t\t\t\t\t\tif (*p) bAlphaOk = true;\r\n\t\t\t\t\t\t\t\t\tAlphaSet(x,y,*p);\r\n\t\t\t\t\t\t\t\t\tp+=4;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t// fix if alpha pixels are all zero\r\n\t\t\t\t\t\t\tif (!bAlphaOk) AlphaInvert();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n#endif //CXIMAGE_SUPPORT_ALPHA\r\n\r\n\t\t\t\t\tBitfield2RGB(buff32,bfmask[0],bfmask[1],bfmask[2],32);\r\n\t\t\t\t\tfree(buff32);\r\n\t\t\t\t} else cx_throw(\"can't allocate memory\");\r\n\t\t\t} else cx_throw(\"unknown compression\");\r\n\t\t\tbreak;\r\n\t\tcase 24 :\r\n\t\t\tif (bf.bfOffBits != 0L) hFile->Seek(off + bf.bfOffBits,SEEK_SET);\r\n\t\t\tif (dwCompression == BI_RGB){\r\n                hFile->Read(info.pImage, head.biSizeImage,1,GetDIB(),GetDIBLimit()); // read in the pixels\r\n\t\t\t} else cx_throw(\"unknown compression\");\r\n\t\t\tbreak;\r\n\t\tcase 16 :\r\n\t\t{\r\n\t\t\tuint32_t bfmask[3];\r\n\t\t\tif (dwCompression == BI_BITFIELDS)\r\n\t\t\t{\r\n\t\t\t\thFile->Read(bfmask, 12, 1);\r\n\t\t\t} else {\r\n\t\t\t\tbfmask[0]=0x7C00; bfmask[1]=0x3E0; bfmask[2]=0x1F; //RGB555\r\n\t\t\t}\r\n\t\t\t// bf.bfOffBits required after the bitfield mask <Cui Ying Jie>\r\n\t\t\tif (bf.bfOffBits != 0L) hFile->Seek(off + bf.bfOffBits,SEEK_SET);\r\n\t\t\t// read in the pixels\r\n            hFile->Read(info.pImage, head.biHeight*((head.biWidth+1)/2)*4,1,GetDIB(),GetDIBLimit());\r\n\t\t\t// transform into RGB\r\n\t\t\tBitfield2RGB(info.pImage,bfmask[0],bfmask[1],bfmask[2],16);\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tcase 8 :\r\n\t\tcase 4 :\r\n\t\tcase 1 :\r\n\t\t\tif (off + bf.bfOffBits < bmpHeader.biSize)\r\n\t\t\t{\r\n\t\t\t\t// \u041e\u0428\u0418\u0411\u041a\u0410\r\n\t\t\t\t// \u0444\u0430\u0439\u043b\u044b \u043f\u0430\u0442\u0442\u0435\u0440\u043d\u044b\u0445 \u0437\u0430\u043b\u0438\u0432\u043e\u043a \u0430\u0432\u0442\u043e\u0444\u0438\u0433\u0443\u0440 \u0432 ppt \u0444\u0430\u0439\u043b\u0430\u0445 !!!\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tif (bf.bfOffBits != 0L) hFile->Seek(off + bf.bfOffBits,SEEK_SET);\r\n\t\t\t}\r\n\t\tswitch (dwCompression) {\r\n\t\t\tcase BI_RGB :\r\n                hFile->Read(info.pImage, head.biSizeImage,1,GetDIB(),GetDIBLimit()); // read in the pixels\r\n\t\t\t\tbreak;\r\n\t\t\tcase BI_RLE4 :\r\n\t\t\t{\r\n\t\t\t\tuint8_t status_byte = 0;\r\n\t\t\t\tuint8_t second_byte = 0;\r\n\t\t\t\tint32_t scanline = 0;\r\n\t\t\t\tint32_t bits = 0;\r\n\t\t\t\tBOOL low_nibble = FALSE;\r\n\t\t\t\tCImageIterator iter(this);\r\n\r\n\t\t\t\tfor (BOOL bContinue = TRUE; bContinue && hFile->Read(&status_byte, sizeof(uint8_t), 1);) {\r\n\t\t\t\t\t\r\n\t\t\t\t\tswitch (status_byte) {\r\n\t\t\t\t\t\tcase RLE_COMMAND :\r\n\t\t\t\t\t\t\thFile->Read(&status_byte, sizeof(uint8_t), 1);\r\n\t\t\t\t\t\t\tswitch (status_byte) {\r\n\t\t\t\t\t\t\t\tcase RLE_ENDOFLINE :\r\n\t\t\t\t\t\t\t\t\tbits = 0;\r\n\t\t\t\t\t\t\t\t\tscanline++;\r\n\t\t\t\t\t\t\t\t\tlow_nibble = FALSE;\r\n\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\tcase RLE_ENDOFBITMAP :\r\n\t\t\t\t\t\t\t\t\tbContinue=FALSE;\r\n\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\tcase RLE_DELTA :\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t// read the delta values\r\n\t\t\t\t\t\t\t\t\tuint8_t delta_x;\r\n\t\t\t\t\t\t\t\t\tuint8_t delta_y;\r\n\t\t\t\t\t\t\t\t\thFile->Read(&delta_x, sizeof(uint8_t), 1);\r\n\t\t\t\t\t\t\t\t\thFile->Read(&delta_y, sizeof(uint8_t), 1);\r\n\t\t\t\t\t\t\t\t\t// apply them\r\n\t\t\t\t\t\t\t\t\tbits       += delta_x / 2;\r\n\t\t\t\t\t\t\t\t\tscanline   += delta_y;\r\n\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tdefault :\r\n\t\t\t\t\t\t\t\t\thFile->Read(&second_byte, sizeof(uint8_t), 1);\r\n\t\t\t\t\t\t\t\t\tuint8_t *sline = iter.GetRow(scanline);\r\n\t\t\t\t\t\t\t\t\tfor (int32_t i = 0; i < status_byte; i++) {\r\n\t\t\t\t\t\t\t\t\t\tif ((uint8_t*)(sline+bits) < (uint8_t*)(info.pImage+head.biSizeImage)){\r\n\t\t\t\t\t\t\t\t\t\t\tif (low_nibble) {\r\n\t\t\t\t\t\t\t\t\t\t\t\tif (i&1)\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t*(sline + bits) |= (second_byte & 0x0f);\r\n\t\t\t\t\t\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t*(sline + bits) |= (second_byte & 0xf0)>>4;\r\n\t\t\t\t\t\t\t\t\t\t\t\tbits++;\r\n\t\t\t\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t\t\t\tif (i&1)\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t*(sline + bits) = (uint8_t)(second_byte & 0x0f)<<4;\r\n\t\t\t\t\t\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t*(sline + bits) = (uint8_t)(second_byte & 0xf0);\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\tif ((i & 1) && (i != (status_byte - 1)))\r\n\t\t\t\t\t\t\t\t\t\t\thFile->Read(&second_byte, sizeof(uint8_t), 1);\r\n\r\n\t\t\t\t\t\t\t\t\t\tlow_nibble = !low_nibble;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\tif ((((status_byte+1) >> 1) & 1 ) == 1)\r\n\t\t\t\t\t\t\t\t\t\thFile->Read(&second_byte, sizeof(uint8_t), 1);\t\t\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t};\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tdefault :\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tuint8_t *sline = iter.GetRow(scanline);\r\n\t\t\t\t\t\t\thFile->Read(&second_byte, sizeof(uint8_t), 1);\r\n\t\t\t\t\t\t\tfor (unsigned i = 0; i < status_byte; i++) {\r\n\t\t\t\t\t\t\t\tif ((uint8_t*)(sline+bits) < (uint8_t*)(info.pImage+head.biSizeImage)){\r\n\t\t\t\t\t\t\t\t\tif (low_nibble) {\r\n\t\t\t\t\t\t\t\t\t\tif (i&1)\r\n\t\t\t\t\t\t\t\t\t\t\t*(sline + bits) |= (second_byte & 0x0f);\r\n\t\t\t\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t\t\t\t\t*(sline + bits) |= (second_byte & 0xf0)>>4;\r\n\t\t\t\t\t\t\t\t\t\tbits++;\r\n\t\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t\tif (i&1)\r\n\t\t\t\t\t\t\t\t\t\t\t*(sline + bits) = (uint8_t)(second_byte & 0x0f)<<4;\r\n\t\t\t\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t\t\t\t\t*(sline + bits) = (uint8_t)(second_byte & 0xf0);\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tlow_nibble = !low_nibble;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t};\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tcase BI_RLE8 :\r\n\t\t\t{\r\n\t\t\t\tuint8_t status_byte = 0;\r\n\t\t\t\tuint8_t second_byte = 0;\r\n\t\t\t\tint32_t scanline = 0;\r\n\t\t\t\tint32_t bits = 0;\r\n\t\t\t\tCImageIterator iter(this);\r\n\r\n\t\t\t\tfor (BOOL bContinue = TRUE; bContinue && hFile->Read(&status_byte, sizeof(uint8_t), 1);) {\r\n\t\t\t\t\tswitch (status_byte) {\r\n\t\t\t\t\t\tcase RLE_COMMAND :\r\n\t\t\t\t\t\t\thFile->Read(&status_byte, sizeof(uint8_t), 1);\r\n\t\t\t\t\t\t\tswitch (status_byte) {\r\n\t\t\t\t\t\t\t\tcase RLE_ENDOFLINE :\r\n\t\t\t\t\t\t\t\t\tbits = 0;\r\n\t\t\t\t\t\t\t\t\tscanline++;\r\n\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\tcase RLE_ENDOFBITMAP :\r\n\t\t\t\t\t\t\t\t\tbContinue=FALSE;\r\n\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\tcase RLE_DELTA :\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t// read the delta values\r\n\t\t\t\t\t\t\t\t\tuint8_t delta_x;\r\n\t\t\t\t\t\t\t\t\tuint8_t delta_y;\r\n\t\t\t\t\t\t\t\t\thFile->Read(&delta_x, sizeof(uint8_t), 1);\r\n\t\t\t\t\t\t\t\t\thFile->Read(&delta_y, sizeof(uint8_t), 1);\r\n\t\t\t\t\t\t\t\t\t// apply them\r\n\t\t\t\t\t\t\t\t\tbits     += delta_x;\r\n\t\t\t\t\t\t\t\t\tscanline += delta_y;\r\n\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tdefault :\r\n                                    hFile->Read((void *)(iter.GetRow(scanline) + bits), sizeof(uint8_t) * status_byte, 1,GetDIB(),GetDIBLimit());\r\n\t\t\t\t\t\t\t\t\t// align run length to even number of bytes \r\n\t\t\t\t\t\t\t\t\tif ((status_byte & 1) == 1)\r\n\t\t\t\t\t\t\t\t\t\thFile->Read(&second_byte, sizeof(uint8_t), 1);\t\t\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\tbits += status_byte;\t\t\t\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\tbreak;\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t};\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tdefault :\r\n\t\t\t\t\t\t\tuint8_t *sline = iter.GetRow(scanline);\r\n\t\t\t\t\t\t\thFile->Read(&second_byte, sizeof(uint8_t), 1);\r\n\t\t\t\t\t\t\tfor (unsigned i = 0; i < status_byte; i++) {\r\n\t\t\t\t\t\t\t\tif ((uint8_t*)(sline+bits) < (uint8_t*)(info.pImage+head.biSizeImage)){\r\n\t\t\t\t\t\t\t\t\t*(sline + bits) = second_byte;\r\n\t\t\t\t\t\t\t\t\tbits++;\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t};\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tdefault :\t\t\t\t\t\t\t\t\r\n\t\t\t\tcx_throw(\"compression type not supported\");\r\n\t\t}\r\n\t}\r\n\r\n\tif (bTopDownDib) Flip(); //<Flanders>\r\n\r\n  } cx_catch {\r\n\tif (strcmp(message,\"\")) strncpy(info.szLastError,message,255);\r\n\tif (info.nEscape == -1 && info.dwType == CXIMAGE_FORMAT_BMP) return true;\r\n\treturn false;\r\n  }\r\n    return true;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n/*  ReadDibBitmapInfo()\r\n *\r\n *  Will read a file in DIB format and return a global HANDLE to its\r\n *  BITMAPINFO.  This function will work with both \"old\" and \"new\"\r\n *  bitmap formats, but will always return a \"new\" BITMAPINFO.\r\n */\r\nbool CxImageBMP::DibReadBitmapInfo(CxFile* fh, BITMAPINFOHEADER *pdib)\r\n{\r\n\tif ((fh==NULL)||(pdib==NULL)) return false;\r\n\r\n    if (fh->Read(pdib,sizeof(BITMAPINFOHEADER),1)==0) return false;\r\n\r\n\tbihtoh(pdib);\r\n\r\n    switch (pdib->biSize) // what type of bitmap info is this?\r\n    {\r\n        case sizeof(BITMAPINFOHEADER):\r\n            break;\r\n\r\n\t\tcase 64: //sizeof(OS2_BMP_HEADER):\r\n            fh->Seek((int32_t)(64 - sizeof(BITMAPINFOHEADER)),SEEK_CUR);\r\n\t\t\tbreak;\r\n\r\n        case 124: //sizeof(BITMAPV5HEADER):\r\n\t\t\tfh->Seek((long)(124-sizeof(BITMAPINFOHEADER)), SEEK_CUR);\r\n\t\t\tbreak;\r\n\r\n        case sizeof(BITMAPCOREHEADER):\r\n\t\t{\r\n            BITMAPCOREHEADER bc = *(BITMAPCOREHEADER*)pdib;\r\n            pdib->biSize               = bc.bcSize;\r\n            pdib->biWidth              = (uint32_t)bc.bcWidth;\r\n            pdib->biHeight             = (uint32_t)bc.bcHeight;\r\n            pdib->biPlanes             =  bc.bcPlanes;\r\n            pdib->biBitCount           =  bc.bcBitCount;\r\n            pdib->biCompression        = BI_RGB;\r\n            pdib->biSizeImage          = 0;\r\n            pdib->biXPelsPerMeter      = 0;\r\n            pdib->biYPelsPerMeter      = 0;\r\n            pdib->biClrUsed            = 0;\r\n            pdib->biClrImportant       = 0;\r\n\r\n\t\t\tfh->Seek((int32_t)(sizeof(BITMAPCOREHEADER)-sizeof(BITMAPINFOHEADER)), SEEK_CUR);\r\n\t\t}\r\n            break;\r\n        default:\r\n\t\t\t//give a last chance\r\n\t\t\t if (pdib->biSize>(sizeof(BITMAPINFOHEADER))&&\r\n\t\t\t\t(pdib->biSizeImage>=(uint32_t)(pdib->biHeight*((((pdib->biBitCount*pdib->biWidth)+31)/32)*4)))&&\r\n\t\t\t\t(pdib->biPlanes==1)&&(pdib->biClrUsed==0))\r\n\t\t\t {\r\n\t             if (pdib->biCompression==BI_RGB)\r\n\t\t\t\t\t fh->Seek((int32_t)(pdib->biSize - sizeof(BITMAPINFOHEADER)),SEEK_CUR);\r\n\t\t\t\t break;\r\n\t\t\t }\r\n\t\t\treturn false;\r\n    }\r\n\r\n    FixBitmapInfo(pdib);\r\n\r\n    return true;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n#endif //CXIMAGE_SUPPORT_DECODE\r\n////////////////////////////////////////////////////////////////////////////////\r\n#endif \t// CXIMAGE_SUPPORT_BMP\r\n////////////////////////////////////////////////////////////////////////////////\r\n", "\ufeff// ximage.cpp : main implementation file\r\n/* 07/08/2001 v1.00 - Davide Pizzolato - www.xdp.it\r\n * CxImage version 7.0.2 07/Feb/2011\r\n */\r\n\r\n#include \"ximage.h\"\r\n\r\n#ifndef min\r\n#define min(a,b) (((a)<(b))?(a):(b))\r\n#endif\r\n#ifndef max\r\n#define max(a,b) (((a)>(b))?(a):(b))\r\n#endif\r\n\r\n////////////////////////////////////////////////////////////////////////////////\r\n// CxImage \r\n////////////////////////////////////////////////////////////////////////////////\r\n/**\r\n * Initialize the internal structures\r\n */\r\nvoid CxImage::Startup(uint32_t imagetype)\r\n{\r\n\t//init pointers\r\n    pDib = pDibLimit = pSelection = pAlpha = NULL;\r\n\tppLayers = ppFrames = NULL;\r\n\t//init structures\r\n\tmemset(&head,0,sizeof(BITMAPINFOHEADER));\r\n\tmemset(&info,0,sizeof(CXIMAGEINFO));\r\n\t//init default attributes\r\n    info.dwType = imagetype;\r\n\tinfo.fQuality = 90.0f;\r\n\tinfo.nAlphaMax = 255;\r\n\tinfo.nBkgndIndex = -1;\r\n\tinfo.bEnabled = true;\r\n\tinfo.nJpegScale = 1;\r\n\tSetXDPI(CXIMAGE_DEFAULT_DPI);\r\n\tSetYDPI(CXIMAGE_DEFAULT_DPI);\r\n\r\n\tint16_t test = 1;\r\n\tinfo.bLittleEndianHost = (*((char *) &test) == 1);\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n/**\r\n * Empty image constructor\r\n * \\param imagetype: (optional) set the image format, see ENUM_CXIMAGE_FORMATS\r\n */\r\nCxImage::CxImage(uint32_t imagetype)\r\n{\r\n\tStartup(imagetype);\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n/**\r\n * Call this function to destroy image pixels, alpha channel, selection and sub layers.\r\n * - Attributes are not erased, but IsValid returns false.\r\n *\r\n * \\return true if everything is freed, false if the image is a Ghost\r\n */\r\nbool CxImage::Destroy()\r\n{\r\n\t//free this only if it's valid and it's not a ghost\r\n\tif (info.pGhost==NULL){\r\n\t\tif (ppLayers) { \r\n\t\t\tfor(int32_t n=0; n<info.nNumLayers;n++){ delete ppLayers[n]; }\r\n\t\t\tdelete [] ppLayers; ppLayers=0; info.nNumLayers = 0;\r\n\t\t}\r\n\t\tif (pSelection) {free(pSelection); pSelection=0;}\r\n\t\tif (pAlpha) {free(pAlpha); pAlpha=0;}\r\n\t\tif (pDib) {free(pDib); pDib=0;}\r\n\t\treturn true;\r\n\t}\r\n\treturn false;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\nbool CxImage::DestroyFrames()\r\n{\r\n\tif (info.pGhost==NULL) {\r\n\t\tif (ppFrames) {\r\n\t\t\tfor (int32_t n=0; n<info.nNumFrames; n++) { delete ppFrames[n]; }\r\n\t\t\tdelete [] ppFrames; ppFrames = NULL; info.nNumFrames = 0;\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n\treturn false;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n/**\r\n * Sized image constructor\r\n * \\param dwWidth: width\r\n * \\param dwHeight: height\r\n * \\param wBpp: bit per pixel, can be 1, 4, 8, 24\r\n * \\param imagetype: (optional) set the image format, see ENUM_CXIMAGE_FORMATS\r\n */\r\nCxImage::CxImage(uint32_t dwWidth, uint32_t dwHeight, uint32_t wBpp, uint32_t imagetype)\r\n{\r\n\tStartup(imagetype);\r\n\tCreate(dwWidth,dwHeight,wBpp,imagetype);\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n/**\r\n * image constructor from existing source\r\n * \\param src: source image.\r\n * \\param copypixels: copy the pixels from the source image into the new image.\r\n * \\param copyselection: copy the selection from source\r\n * \\param copyalpha: copy the alpha channel from source\r\n * \\sa Copy\r\n */\r\nCxImage::CxImage(const CxImage &src, bool copypixels, bool copyselection, bool copyalpha)\r\n{\r\n\tStartup(src.GetType());\r\n\tCopy(src,copypixels,copyselection,copyalpha);\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n/**\r\n * Copies the image from an exsisting source\r\n * \\param src: source image.\r\n * \\param copypixels: copy the pixels from the source image into the new image.\r\n * \\param copyselection: copy the selection from source\r\n * \\param copyalpha: copy the alpha channel from source\r\n */\r\nvoid CxImage::Copy(const CxImage &src, bool copypixels, bool copyselection, bool copyalpha)\r\n{\r\n\t// if the source is a ghost, the copy is still a ghost\r\n\tif (src.info.pGhost){\r\n\t\tGhost(&src);\r\n\t\treturn;\r\n\t}\r\n\t//copy the attributes\r\n\tmemcpy(&info,&src.info,sizeof(CXIMAGEINFO));\r\n\tmemcpy(&head,&src.head,sizeof(BITMAPINFOHEADER)); // [andy] - fix for bitmap header DPI\r\n\t//rebuild the image\r\n\tCreate(src.GetWidth(),src.GetHeight(),src.GetBpp(),src.GetType());\r\n\t//copy the pixels and the palette, or at least copy the palette only.\r\n\tif (copypixels && pDib && src.pDib) memcpy(pDib,src.pDib,GetSize());\r\n\telse SetPalette(src.GetPalette());\r\n\tint32_t nSize = head.biWidth * head.biHeight;\r\n\t//copy the selection\r\n\tif (copyselection && src.pSelection){\r\n\t\tif (pSelection) free(pSelection);\r\n\t\tpSelection = (uint8_t*)malloc(nSize);\r\n\t\tmemcpy(pSelection,src.pSelection,nSize);\r\n\t}\r\n\t//copy the alpha channel\r\n\tif (copyalpha && src.pAlpha){\r\n\t\tif (pAlpha) free(pAlpha);\r\n\t\tpAlpha = (uint8_t*)malloc(nSize);\r\n\t\tmemcpy(pAlpha,src.pAlpha,nSize);\r\n\t}\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n/**\r\n * Copies the image attributes from an existing image.\r\n * - Works only on an empty image, and the image will be still empty.\r\n * - <b> Use it before Create() </b>\r\n */\r\nvoid CxImage::CopyInfo(const CxImage &src)\r\n{\r\n\tif (pDib==NULL) memcpy(&info,&src.info,sizeof(CXIMAGEINFO));\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n/**\r\n * \\sa Copy\r\n */\r\nCxImage& CxImage::operator = (const CxImage& isrc)\r\n{\r\n\tif (this != &isrc) Copy(isrc);\r\n\treturn *this;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n/**\r\n * Initializes or rebuilds the image.\r\n * \\param dwWidth: width\r\n * \\param dwHeight: height\r\n * \\param wBpp: bit per pixel, can be 1, 4, 8, 24\r\n * \\param imagetype: (optional) set the image format, see ENUM_CXIMAGE_FORMATS\r\n * \\return pointer to the internal pDib object; NULL if an error occurs.\r\n */\r\nvoid* CxImage::Create(uint32_t dwWidth, uint32_t dwHeight, uint32_t wBpp, uint32_t imagetype)\r\n{\r\n\t// destroy the existing image (if any)\r\n\tif (!Destroy())\r\n\t\treturn NULL;\r\n\r\n\t// prevent further actions if width or height are not vaild <Balabasnia>\r\n\tif ((dwWidth == 0) || (dwHeight == 0)){\r\n\t\tstrcpy(info.szLastError,\"CxImage::Create : width and height must be greater than zero\");\r\n\t\treturn NULL;\r\n\t}\r\n\r\n    // Make sure bits per pixel is valid\r\n    if\t\t(wBpp <= 1)\twBpp = 1;\r\n    else if (wBpp <= 4)\twBpp = 4;\r\n    else if (wBpp <= 8)\twBpp = 8;\r\n    else\t\t\t\twBpp = 24;\r\n\r\n\t// limit memory requirements\r\n\tif ((((float)dwWidth*(float)dwHeight*(float)wBpp)/8.0f) > (float)CXIMAGE_MAX_MEMORY)\r\n\t{\r\n\t\tstrcpy(info.szLastError,\"CXIMAGE_MAX_MEMORY exceeded\");\r\n\t\treturn NULL;\r\n\t}\r\n\r\n\t// set the correct bpp value\r\n    switch (wBpp){\r\n        case 1:\r\n            head.biClrUsed = 2;\tbreak;\r\n        case 4:\r\n            head.biClrUsed = 16; break;\r\n        case 8:\r\n            head.biClrUsed = 256; break;\r\n        default:\r\n            head.biClrUsed = 0;\r\n    }\r\n\r\n\t//set the common image informations\r\n    info.dwEffWidth = ((((wBpp * dwWidth) + 31) / 32) * 4);\r\n    info.dwType = imagetype;\r\n\r\n    // initialize BITMAPINFOHEADER\r\n\thead.biSize = sizeof(BITMAPINFOHEADER); //<ralphw>\r\n    head.biWidth = dwWidth;\t\t// fill in width from parameter\r\n    head.biHeight = dwHeight;\t// fill in height from parameter\r\n    head.biPlanes = 1;\t\t\t// must be 1\r\n    head.biBitCount = (uint16_t)wBpp;\t\t// from parameter\r\n    head.biCompression = BI_RGB;    \r\n    head.biSizeImage = info.dwEffWidth * dwHeight;\r\n//    head.biXPelsPerMeter = 0; See SetXDPI\r\n//    head.biYPelsPerMeter = 0; See SetYDPI\r\n//    head.biClrImportant = 0;  See SetClrImportant\r\n\r\n\tpDib = malloc(GetSize()); // alloc memory block to store our bitmap\r\n    if (!pDib){\r\n\t\tstrcpy(info.szLastError,\"CxImage::Create can't allocate memory\");\r\n\t\treturn NULL;\r\n\t}\r\n    pDibLimit = (void*)((uint8_t*)pDib + GetSize());\r\n\r\n\t//clear the palette\r\n\tRGBQUAD* pal=GetPalette();\r\n\tif (pal) memset(pal,0,GetPaletteSize());\r\n\t//Destroy the existing selection\r\n#if CXIMAGE_SUPPORT_SELECTION\r\n\tif (pSelection) SelectionDelete();\r\n#endif //CXIMAGE_SUPPORT_SELECTION\r\n\t//Destroy the existing alpha channel\r\n#if CXIMAGE_SUPPORT_ALPHA\r\n\tif (pAlpha) AlphaDelete();\r\n#endif //CXIMAGE_SUPPORT_ALPHA\r\n\r\n    // use our bitmap info structure to fill in first part of\r\n    // our DIB with the BITMAPINFOHEADER\r\n    BITMAPINFOHEADER*  lpbi;\r\n\tlpbi = (BITMAPINFOHEADER*)(pDib);\r\n    *lpbi = head;\r\n\r\n\tinfo.pImage=GetBits();\r\n\r\n    return pDib; //return handle to the DIB\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n/**\r\n * \\return pointer to the image pixels. <b> USE CAREFULLY </b>\r\n */\r\nuint8_t* CxImage::GetBits(uint32_t row)\r\n{ \r\n\tif (pDib){\r\n\t\tif (row) {\r\n\t\t\tif (row<(uint32_t)head.biHeight){\r\n\t\t\t\treturn ((uint8_t*)pDib + *(uint32_t*)pDib + GetPaletteSize() + (info.dwEffWidth * row));\r\n\t\t\t} else {\r\n\t\t\t\treturn NULL;\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\treturn ((uint8_t*)pDib + *(uint32_t*)pDib + GetPaletteSize());\r\n\t\t}\r\n\t}\r\n\treturn NULL;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n/**\r\n * \\return the size in bytes of the internal pDib object\r\n */\r\nuint32_t CxImage::GetSize()\r\n{\r\n    uint64_t size64 = head.biSize + head.biSizeImage + GetPaletteSize();\r\n    if (size64 > 0xFFFFFFFF)\r\n        return 0xFFFFFFFF;\r\n    return (uint32_t)size64;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n/**\r\n * Checks if the coordinates are inside the image\r\n * \\return true if x and y are both inside the image\r\n */\r\nbool CxImage::IsInside(int32_t x, int32_t y)\r\n{\r\n  return (0<=y && y<head.biHeight && 0<=x && x<head.biWidth);\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n/**\r\n * Sets the image bits to the specified value\r\n * - for indexed images, the output color is set by the palette entries.\r\n * - for RGB images, the output color is a shade of gray.\r\n */\r\nvoid CxImage::Clear(uint8_t bval)\r\n{\r\n\tif (pDib == 0) return;\r\n\r\n\tif (GetBpp() == 1){\r\n\t\tif (bval > 0) bval = 255;\r\n\t}\r\n\tif (GetBpp() == 4){\r\n\t\tbval = (uint8_t)(17*(0x0F & bval));\r\n\t}\r\n\r\n\tmemset(info.pImage,bval,head.biSizeImage);\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n/**\r\n * Transfers the image from an existing source image. The source becomes empty.\r\n * \\return true if everything is ok\r\n */\r\nbool CxImage::Transfer(CxImage &from, bool bTransferFrames /*=true*/)\r\n{\r\n\tif (!Destroy())\r\n\t\treturn false;\r\n\r\n\tmemcpy(&head,&from.head,sizeof(BITMAPINFOHEADER));\r\n\tmemcpy(&info,&from.info,sizeof(CXIMAGEINFO));\r\n\r\n\tpDib = from.pDib;\r\n    pDib = from.pDibLimit;\r\n\tpSelection = from.pSelection;\r\n\tpAlpha = from.pAlpha;\r\n\tppLayers = from.ppLayers;\r\n\r\n\tmemset(&from.head,0,sizeof(BITMAPINFOHEADER));\r\n\tmemset(&from.info,0,sizeof(CXIMAGEINFO));\r\n    from.pDib = from.pDibLimit = from.pSelection = from.pAlpha = NULL;\r\n\tfrom.ppLayers = NULL;\r\n\r\n\tif (bTransferFrames){\r\n\t\tDestroyFrames();\r\n\t\tppFrames = from.ppFrames;\r\n\t\tfrom.ppFrames = NULL;\r\n\t}\r\n\r\n\treturn true;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n/**\r\n * (this) points to the same pDib owned by (*from), the image remains in (*from)\r\n * but (this) has the access to the pixels. <b>Use carefully !!!</b>\r\n */\r\nvoid CxImage::Ghost(const CxImage *from)\r\n{\r\n\tif (from){\r\n\t\tmemcpy(&head,&from->head,sizeof(BITMAPINFOHEADER));\r\n\t\tmemcpy(&info,&from->info,sizeof(CXIMAGEINFO));\r\n\t\tpDib = from->pDib;\r\n        pDibLimit = from->pDibLimit;\r\n\t\tpSelection = from->pSelection;\r\n\t\tpAlpha = from->pAlpha;\r\n\t\tppLayers = from->ppLayers;\r\n\t\tppFrames = from->ppFrames;\r\n\t\tinfo.pGhost=(CxImage *)from;\r\n\t}\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n/**\r\n * turns a 16 or 32 bit bitfield image into a RGB image\r\n */\r\nvoid CxImage::Bitfield2RGB(uint8_t *src, uint32_t redmask, uint32_t greenmask, uint32_t bluemask, uint8_t bpp)\r\n{\r\n\tswitch (bpp){\r\n\tcase 16:\r\n\t{\r\n\t\tuint32_t ns[3]={0,0,0};\r\n\t\t// compute the number of shift for each mask\r\n\t\tfor (int32_t i=0;i<16;i++){\r\n\t\t\tif ((redmask>>i)&0x01) ns[0]++;\r\n\t\t\tif ((greenmask>>i)&0x01) ns[1]++;\r\n\t\t\tif ((bluemask>>i)&0x01) ns[2]++;\r\n\t\t}\r\n\t\tns[1]+=ns[0]; ns[2]+=ns[1];\tns[0]=8-ns[0]; ns[1]-=8; ns[2]-=8;\r\n\t\t// dword aligned width for 16 bit image\r\n\t\tint32_t effwidth2=(((head.biWidth + 1) / 2) * 4);\r\n\t\tuint16_t w;\r\n\t\tint32_t y2,y3,x2,x3;\r\n\t\tuint8_t *p=info.pImage;\r\n\t\t// scan the buffer in reverse direction to avoid reallocations\r\n\t\tfor (int32_t y=head.biHeight-1; y>=0; y--){\r\n\t\t\ty2=effwidth2*y;\r\n\t\t\ty3=info.dwEffWidth*y;\r\n\t\t\tfor (int32_t x=head.biWidth-1; x>=0; x--){\r\n\t\t\t\tx2 = 2*x+y2;\r\n\t\t\t\tx3 = 3*x+y3;\r\n\t\t\t\tw = (uint16_t)(src[x2]+256*src[1+x2]);\r\n\t\t\t\tp[  x3]=(uint8_t)((w & bluemask)<<ns[0]);\r\n\t\t\t\tp[1+x3]=(uint8_t)((w & greenmask)>>ns[1]);\r\n\t\t\t\tp[2+x3]=(uint8_t)((w & redmask)>>ns[2]);\r\n\t\t\t}\r\n\t\t}\r\n\t\tbreak;\r\n\t}\r\n\tcase 32:\r\n\t{\r\n\t\tuint32_t ns[3]={0,0,0};\r\n\t\t// compute the number of shift for each mask\r\n\t\tfor (int32_t i=8;i<32;i+=8){\r\n\t\t\tif (redmask>>i) ns[0]++;\r\n\t\t\tif (greenmask>>i) ns[1]++;\r\n\t\t\tif (bluemask>>i) ns[2]++;\r\n\t\t}\r\n\t\t// dword aligned width for 32 bit image\r\n\t\tint32_t effwidth4 = head.biWidth * 4;\r\n\t\tint32_t y4,y3,x4,x3;\r\n\t\tuint8_t *p=info.pImage;\r\n\t\t// scan the buffer in reverse direction to avoid reallocations\r\n\t\tfor (int32_t y=head.biHeight-1; y>=0; y--){\r\n\t\t\ty4=effwidth4*y;\r\n\t\t\ty3=info.dwEffWidth*y;\r\n\t\t\tfor (int32_t x=head.biWidth-1; x>=0; x--){\r\n\t\t\t\tx4 = 4*x+y4;\r\n\t\t\t\tx3 = 3*x+y3;\r\n\t\t\t\tp[  x3]=src[ns[2]+x4];\r\n\t\t\t\tp[1+x3]=src[ns[1]+x4];\r\n\t\t\t\tp[2+x3]=src[ns[0]+x4];\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t}\r\n\treturn;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n/**\r\n * Creates an image from a generic buffer\r\n * \\param pArray: source memory buffer\r\n * \\param dwWidth: image width\r\n * \\param dwHeight: image height\r\n * \\param dwBitsperpixel: can be 1,4,8,24,32\r\n * \\param dwBytesperline: line alignment, in bytes, for a single row stored in pArray\r\n * \\param bFlipImage: tune this parameter if the image is upsidedown\r\n * \\return true if everything is ok\r\n */\r\nbool CxImage::CreateFromArray(uint8_t* pArray,uint32_t dwWidth,uint32_t dwHeight,uint32_t dwBitsperpixel, uint32_t dwBytesperline, bool bFlipImage)\r\n{\r\n\tif (pArray==NULL) return false;\r\n\tif (!((dwBitsperpixel==1)||(dwBitsperpixel==4)||(dwBitsperpixel==8)||\r\n\t\t(dwBitsperpixel==24)||(dwBitsperpixel==32))) return false;\r\n\r\n\tif (!Create(dwWidth,dwHeight,dwBitsperpixel)) return false;\r\n\r\n\tif (dwBitsperpixel<24) SetGrayPalette();\r\n\r\n#if CXIMAGE_SUPPORT_ALPHA\r\n\tif (dwBitsperpixel==32) AlphaCreate();\r\n#endif //CXIMAGE_SUPPORT_ALPHA\r\n\r\n\tuint8_t *dst,*src;\r\n\r\n\tfor (uint32_t y = 0; y<dwHeight; y++) {\r\n\t\tdst = info.pImage + (bFlipImage?(dwHeight-1-y):y) * info.dwEffWidth;\r\n\t\tsrc = pArray + y * dwBytesperline;\r\n\t\tif (dwBitsperpixel==32){\r\n\t\t\tfor(uint32_t x=0;x<dwWidth;x++){\r\n\t\t\t\t*dst++=src[0];\r\n\t\t\t\t*dst++=src[1];\r\n\t\t\t\t*dst++=src[2];\r\n#if CXIMAGE_SUPPORT_ALPHA\r\n\t\t\t\tAlphaSet(x,(bFlipImage?(dwHeight-1-y):y),src[3]);\r\n#endif //CXIMAGE_SUPPORT_ALPHA\r\n\t\t\t\tsrc+=4;\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tmemcpy(dst,src,min(info.dwEffWidth,dwBytesperline));\r\n\t\t}\r\n\t}\r\n\treturn true;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n/**\r\n * \\sa CreateFromArray\r\n */\r\nbool CxImage::CreateFromMatrix(uint8_t** ppMatrix,uint32_t dwWidth,uint32_t dwHeight,uint32_t dwBitsperpixel, uint32_t dwBytesperline, bool bFlipImage)\r\n{\r\n\tif (ppMatrix==NULL) return false;\r\n\tif (!((dwBitsperpixel==1)||(dwBitsperpixel==4)||(dwBitsperpixel==8)||\r\n\t\t(dwBitsperpixel==24)||(dwBitsperpixel==32))) return false;\r\n\r\n\tif (!Create(dwWidth,dwHeight,dwBitsperpixel)) return false;\r\n\r\n\tif (dwBitsperpixel<24) SetGrayPalette();\r\n\r\n#if CXIMAGE_SUPPORT_ALPHA\r\n\tif (dwBitsperpixel==32) AlphaCreate();\r\n#endif //CXIMAGE_SUPPORT_ALPHA\r\n\r\n\tuint8_t *dst,*src;\r\n\r\n\tfor (uint32_t y = 0; y<dwHeight; y++) {\r\n\t\tdst = info.pImage + (bFlipImage?(dwHeight-1-y):y) * info.dwEffWidth;\r\n\t\tsrc = ppMatrix[y];\r\n\t\tif (src){\r\n\t\t\tif (dwBitsperpixel==32){\r\n\t\t\t\tfor(uint32_t x=0;x<dwWidth;x++){\r\n\t\t\t\t\t*dst++=src[0];\r\n\t\t\t\t\t*dst++=src[1];\r\n\t\t\t\t\t*dst++=src[2];\r\n#if CXIMAGE_SUPPORT_ALPHA\r\n\t\t\t\t\tAlphaSet(x,(bFlipImage?(dwHeight-1-y):y),src[3]);\r\n#endif //CXIMAGE_SUPPORT_ALPHA\r\n\t\t\t\t\tsrc+=4;\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tmemcpy(dst,src,min(info.dwEffWidth,dwBytesperline));\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn true;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n/**\r\n * \\return lightness difference between elem1 and elem2\r\n */\r\nint32_t CxImage::CompareColors(const void *elem1, const void *elem2)\r\n{\r\n\tRGBQUAD* c1 = (RGBQUAD*)elem1;\r\n\tRGBQUAD* c2 = (RGBQUAD*)elem2;\r\n\r\n\tint32_t g1 = (int32_t)RGB2GRAY(c1->rgbRed,c1->rgbGreen,c1->rgbBlue);\r\n\tint32_t g2 = (int32_t)RGB2GRAY(c2->rgbRed,c2->rgbGreen,c2->rgbBlue);\r\n\t\r\n\treturn (g1-g2);\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n/**\r\n * simply calls \"if (memblock) free(memblock);\".\r\n * Useful when calling Encode for a memory buffer,\r\n * from a DLL compiled with different memory management options.\r\n * CxImage::FreeMemory will use the same memory environment used by Encode. \r\n * \\author [livecn]\r\n */\r\nvoid CxImage::FreeMemory(void* memblock)\r\n{\r\n\tif (memblock)\r\n\t\tfree(memblock);\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n//EOF\r\n", "\ufeff/*\r\n * File:\tximage.h\r\n * Purpose:\tGeneral Purpose Image Class \r\n */\r\n/*\r\n  --------------------------------------------------------------------------------\r\n\r\n\tCOPYRIGHT NOTICE, DISCLAIMER, and LICENSE:\r\n\r\n\tCxImage version 7.0.2 07/Feb/2011\r\n\r\n\tCxImage : Copyright (C) 2001 - 2010, Davide Pizzolato\r\n\r\n\tOriginal CImage and CImageIterator implementation are:\r\n\tCopyright (C) 1995, Alejandro Aguilar Sierra (asierra(at)servidor(dot)unam(dot)mx)\r\n\r\n\tCovered code is provided under this license on an \"as is\" basis, without warranty\r\n\tof any kind, either expressed or implied, including, without limitation, warranties\r\n\tthat the covered code is free of defects, merchantable, fit for a particular purpose\r\n\tor non-infringing. The entire risk as to the quality and performance of the covered\r\n\tcode is with you. Should any covered code prove defective in any respect, you (not\r\n\tthe initial developer or any other contributor) assume the cost of any necessary\r\n\tservicing, repair or correction. This disclaimer of warranty constitutes an essential\r\n\tpart of this license. No use of any covered code is authorized hereunder except under\r\n\tthis disclaimer.\r\n\r\n\tPermission is hereby granted to use, copy, modify, and distribute this\r\n\tsource code, or portions hereof, for any purpose, including commercial applications,\r\n\tfreely and without fee, subject to the following restrictions: \r\n\r\n\t1. The origin of this software must not be misrepresented; you must not\r\n\tclaim that you wrote the original software. If you use this software\r\n\tin a product, an acknowledgment in the product documentation would be\r\n\tappreciated but is not required.\r\n\r\n\t2. Altered source versions must be plainly marked as such, and must not be\r\n\tmisrepresented as being the original software.\r\n\r\n\t3. This notice may not be removed or altered from any source distribution.\r\n\r\n  --------------------------------------------------------------------------------\r\n\r\n\tOther information about CxImage, and the latest version, can be found at the\r\n\tCxImage home page: http://www.xdp.it/cximage/\r\n\r\n  --------------------------------------------------------------------------------\r\n */\r\n#if !defined(__CXIMAGE_H)\r\n#define __CXIMAGE_H\r\n\r\n#if _MSC_VER > 1000\r\n#pragma once\r\n#endif \r\n\r\n#ifdef _LINUX\r\n  #define _XOPEN_SOURCE\r\n  #include <unistd.h>\r\n  #include <arpa/inet.h>\r\n#endif\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\n#include \"xfile.h\"\r\n#include \"xiofile.h\"\r\n#include \"xmemfile.h\"\r\n#include \"ximadef.h\"\t//<vho> adjust some #define\r\n\r\n/* see \"ximacfg.h\" for CxImage configuration options */\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\n// CxImage formats enumerator\r\nenum ENUM_CXIMAGE_FORMATS{\r\nCXIMAGE_FORMAT_UNKNOWN = 0,\r\n#if CXIMAGE_SUPPORT_BMP\r\nCXIMAGE_FORMAT_BMP = 1,\r\n#endif\r\n#if CXIMAGE_SUPPORT_GIF\r\nCXIMAGE_FORMAT_GIF = 2,\r\n#endif\r\n#if CXIMAGE_SUPPORT_JPG\r\nCXIMAGE_FORMAT_JPG = 3,\r\n#endif\r\n#if CXIMAGE_SUPPORT_PNG\r\nCXIMAGE_FORMAT_PNG = 4,\r\n#endif\r\n#if CXIMAGE_SUPPORT_ICO\r\nCXIMAGE_FORMAT_ICO = 5,\r\n#endif\r\n#if CXIMAGE_SUPPORT_TIF\r\nCXIMAGE_FORMAT_TIF = 6,\r\n#endif\r\n#if CXIMAGE_SUPPORT_TGA\r\nCXIMAGE_FORMAT_TGA = 7,\r\n#endif\r\n#if CXIMAGE_SUPPORT_PCX\r\nCXIMAGE_FORMAT_PCX = 8,\r\n#endif\r\n#if CXIMAGE_SUPPORT_WBMP\r\nCXIMAGE_FORMAT_WBMP = 9,\r\n#endif\r\n#if CXIMAGE_SUPPORT_WMF\r\nCXIMAGE_FORMAT_WMF = 10,\r\n#endif\r\n#if CXIMAGE_SUPPORT_JP2\r\nCXIMAGE_FORMAT_JP2 = 11,\r\n#endif\r\n#if CXIMAGE_SUPPORT_JPC\r\nCXIMAGE_FORMAT_JPC = 12,\r\n#endif\r\n#if CXIMAGE_SUPPORT_PGX\r\nCXIMAGE_FORMAT_PGX = 13,\r\n#endif\r\n#if CXIMAGE_SUPPORT_PNM\r\nCXIMAGE_FORMAT_PNM = 14,\r\n#endif\r\n#if CXIMAGE_SUPPORT_RAS\r\nCXIMAGE_FORMAT_RAS = 15,\r\n#endif\r\n#if CXIMAGE_SUPPORT_JBG\r\nCXIMAGE_FORMAT_JBG = 16,\r\n#endif\r\n#if CXIMAGE_SUPPORT_MNG\r\nCXIMAGE_FORMAT_MNG = 17,\r\n#endif\r\n#if CXIMAGE_SUPPORT_SKA\r\nCXIMAGE_FORMAT_SKA = 18,\r\n#endif\r\n#if CXIMAGE_SUPPORT_RAW\r\nCXIMAGE_FORMAT_RAW = 19,\r\n#endif\r\n#if CXIMAGE_SUPPORT_PSD\r\nCXIMAGE_FORMAT_PSD = 20,\r\n#endif\r\nCMAX_IMAGE_FORMATS = CXIMAGE_SUPPORT_BMP + CXIMAGE_SUPPORT_GIF + CXIMAGE_SUPPORT_JPG +\r\n\t\t\t\t\t CXIMAGE_SUPPORT_PNG + CXIMAGE_SUPPORT_MNG + CXIMAGE_SUPPORT_ICO +\r\n\t\t\t\t\t CXIMAGE_SUPPORT_TIF + CXIMAGE_SUPPORT_TGA + CXIMAGE_SUPPORT_PCX +\r\n\t\t\t\t\t CXIMAGE_SUPPORT_WBMP+ CXIMAGE_SUPPORT_WMF +\r\n\t\t\t\t\t CXIMAGE_SUPPORT_JBG + CXIMAGE_SUPPORT_JP2 + CXIMAGE_SUPPORT_JPC +\r\n\t\t\t\t\t CXIMAGE_SUPPORT_PGX + CXIMAGE_SUPPORT_PNM + CXIMAGE_SUPPORT_RAS +\r\n\t\t\t\t\t CXIMAGE_SUPPORT_SKA + CXIMAGE_SUPPORT_RAW + CXIMAGE_SUPPORT_PSD + 1\r\n};\r\n\r\n#if CXIMAGE_SUPPORT_EXIF\r\n\r\n#define MAX_COMMENT 255\r\n#define MAX_SECTIONS 20\r\n\r\ntypedef struct tag_ExifInfo {\r\n\tchar  Version      [5];\r\n    char  CameraMake   [32];\r\n    char  CameraModel  [40];\r\n    char  DateTime     [20];\r\n    int32_t   Height, Width;\r\n    int32_t   Orientation;\r\n    int32_t   IsColor;\r\n    int32_t   Process;\r\n    int32_t   FlashUsed;\r\n    float FocalLength;\r\n    float ExposureTime;\r\n    float ApertureFNumber;\r\n    float Distance;\r\n    float CCDWidth;\r\n    float ExposureBias;\r\n    int32_t   Whitebalance;\r\n    int32_t   MeteringMode;\r\n    int32_t   ExposureProgram;\r\n    int32_t   ISOequivalent;\r\n    int32_t   CompressionLevel;\r\n\tfloat FocalplaneXRes;\r\n\tfloat FocalplaneYRes;\r\n\tfloat FocalplaneUnits;\r\n\tfloat Xresolution;\r\n\tfloat Yresolution;\r\n\tfloat ResolutionUnit;\r\n\tfloat Brightness;\r\n    char  Comments[MAX_COMMENT+1];\r\n\r\n    uint8_t * ThumbnailPointer;  /* Pointer at the thumbnail */\r\n    unsigned ThumbnailSize;     /* Size of thumbnail. */\r\n\r\n\tbool  IsExif;\r\n} EXIFINFO;\r\n\r\n#endif //CXIMAGE_SUPPORT_EXIF\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\n// CxImage class\r\n/////////////////////////////////////////////////////////////////////////////\r\nclass DLL_EXP CxImage\r\n{\r\n//extensible information collector\r\ntypedef struct tagCxImageInfo {\r\n\tuint32_t\tdwEffWidth;\t\t\t///< uint32_t aligned scan line width\r\n\tuint8_t*\tpImage;\t\t\t\t///< THE IMAGE BITS\r\n\tCxImage* pGhost;\t\t\t///< if this is a ghost, pGhost points to the body\r\n\tCxImage* pParent;\t\t\t///< if this is a layer, pParent points to the body\r\n\tuint32_t\tdwType;\t\t\t\t///< original image format\r\n\tchar\tszLastError[256];\t///< debugging\r\n\tint32_t\tnProgress;\t\t\t///< monitor\r\n\tint32_t\tnEscape;\t\t\t///< escape\r\n\tint32_t\tnBkgndIndex;\t\t///< used for GIF, PNG, MNG\r\n\tRGBQUAD nBkgndColor;\t\t///< used for RGB transparency\r\n\tfloat\tfQuality;\t\t\t///< used for JPEG, JPEG2000 (0.0f ... 100.0f)\r\n\tuint8_t\tnJpegScale;\t\t\t///< used for JPEG [ignacio]\r\n\tint32_t\tnFrame;\t\t\t\t///< used for TIF, GIF, MNG : actual frame\r\n\tint32_t\tnNumFrames;\t\t\t///< used for TIF, GIF, MNG : total number of frames\r\n\tuint32_t\tdwFrameDelay;\t\t///< used for GIF, MNG\r\n\tint32_t\txDPI;\t\t\t\t///< horizontal resolution\r\n\tint32_t\tyDPI;\t\t\t\t///< vertical resolution\r\n\tRECT\trSelectionBox;\t\t///< bounding rectangle\r\n\tuint8_t\tnAlphaMax;\t\t\t///< max opacity (fade)\r\n\tbool\tbAlphaPaletteEnabled; ///< true if alpha values in the palette are enabled.\r\n\tbool\tbEnabled;\t\t\t///< enables the painting functions\r\n\tint32_t\txOffset;\r\n\tint32_t\tyOffset;\r\n\tuint32_t\tdwCodecOpt[CMAX_IMAGE_FORMATS];\t///< for GIF, TIF : 0=def.1=unc,2=fax3,3=fax4,4=pack,5=jpg\r\n\tRGBQUAD last_c;\t\t\t\t///< for GetNearestIndex optimization\r\n\tuint8_t\tlast_c_index;\r\n\tbool\tlast_c_isvalid;\r\n\tint32_t\tnNumLayers;\r\n\tuint32_t\tdwFlags;\t\t\t///< 0x??00000 = reserved, 0x00??0000 = blend mode, 0x0000???? = layer id - user flags\r\n\tuint8_t\tdispmeth;\r\n\tbool\tbGetAllFrames;\r\n\tbool\tbLittleEndianHost;\r\n\r\n#if CXIMAGE_SUPPORT_EXIF\r\n\tEXIFINFO ExifInfo;\r\n#endif\r\n\r\n} CXIMAGEINFO;\r\n\r\npublic:\r\n\t//public structures\r\nstruct rgb_color { uint8_t r,g,b; };\r\n\r\n#if CXIMAGE_SUPPORT_WINDOWS\r\n// <VATI> text placement data\r\n// members must be initialized with the InitTextInfo(&this) function.\r\ntypedef struct tagCxTextInfo\r\n{\r\n#if defined (_WIN32_WCE)\r\n\tTCHAR    text[256];  ///< text for windows CE\r\n#else\r\n\tTCHAR    text[4096]; ///< text (char -> TCHAR for UNICODE [Cesar M])\r\n#endif\r\n\tLOGFONT  lfont;      ///< font and codepage data\r\n    COLORREF fcolor;     ///< foreground color\r\n    int32_t     align;      ///< DT_CENTER, DT_RIGHT, DT_LEFT aligment for multiline text\r\n    uint8_t     smooth;     ///< text smoothing option. Default is false.\r\n    uint8_t     opaque;     ///< text has background or hasn't. Default is true.\r\n\t\t\t\t\t\t ///< data for background (ignored if .opaque==FALSE) \r\n    COLORREF bcolor;     ///< background color\r\n    float    b_opacity;  ///< opacity value for background between 0.0-1.0 Default is 0. (opaque)\r\n    uint8_t     b_outline;  ///< outline width for background (zero: no outline)\r\n    uint8_t     b_round;    ///< rounding radius for background rectangle. % of the height, between 0-50. Default is 10.\r\n                         ///< (backgr. always has a frame: width = 3 pixel + 10% of height by default.)\r\n} CXTEXTINFO;\r\n#endif\r\n\r\npublic:\r\n/** \\addtogroup Constructors */ //@{\r\n\tCxImage(uint32_t imagetype = 0);\r\n\tCxImage(uint32_t dwWidth, uint32_t dwHeight, uint32_t wBpp, uint32_t imagetype = 0);\r\n\tCxImage(const CxImage &src, bool copypixels = true, bool copyselection = true, bool copyalpha = true);\r\n#if CXIMAGE_SUPPORT_DECODE\r\n\tCxImage(const TCHAR * filename, uint32_t imagetype);\t// For UNICODE support: char -> TCHAR\r\n\tCxImage(FILE * stream, uint32_t imagetype);\r\n\tCxImage(CxFile * stream, uint32_t imagetype);\r\n\tCxImage(uint8_t * buffer, uint32_t size, uint32_t imagetype);\r\n#endif\r\n\tvirtual ~CxImage() { DestroyFrames(); Destroy(); };\r\n\tCxImage& operator = (const CxImage&);\r\n//@}\r\n\r\n/** \\addtogroup Initialization */ //@{\r\n\tvoid*\tCreate(uint32_t dwWidth, uint32_t dwHeight, uint32_t wBpp, uint32_t imagetype = 0);\r\n\tbool\tDestroy();\r\n\tbool\tDestroyFrames();\r\n\tvoid\tClear(uint8_t bval=0);\r\n\tvoid\tCopy(const CxImage &src, bool copypixels = true, bool copyselection = true, bool copyalpha = true);\r\n\tbool\tTransfer(CxImage &from, bool bTransferFrames = true);\r\n\tbool\tCreateFromArray(uint8_t* pArray,uint32_t dwWidth,uint32_t dwHeight,uint32_t dwBitsperpixel, uint32_t dwBytesperline, bool bFlipImage);\r\n\tbool\tCreateFromMatrix(uint8_t** ppMatrix,uint32_t dwWidth,uint32_t dwHeight,uint32_t dwBitsperpixel, uint32_t dwBytesperline, bool bFlipImage);\r\n\tvoid\tFreeMemory(void* memblock);\r\n\r\n\tuint32_t Dump(uint8_t * dst);\r\n\tuint32_t UnDump(const uint8_t * src);\r\n\tuint32_t DumpSize();\r\n\r\n//@}\r\n\r\n/** \\addtogroup Attributes */ //@{\r\n\tuint32_t\tGetSize();\r\n\tuint8_t*\tGetBits(uint32_t row = 0);\r\n\tuint8_t\tGetColorType();\r\n\tvoid*\tGetDIB() const;\r\n\tvoid*\tGetDIBLimit() const;\r\n\tuint32_t\tGetHeight() const;\r\n\tuint32_t\tGetWidth() const;\r\n\tuint32_t\tGetEffWidth() const;\r\n\tuint32_t\tGetNumColors() const;\r\n\tuint16_t\tGetBpp() const;\r\n\tuint32_t\tGetType() const;\r\n\tconst char*\tGetLastError();\r\n\tstatic const TCHAR* GetVersion();\r\n\tstatic const float GetVersionNumber();\r\n\r\n\tuint32_t\tGetFrameDelay() const;\r\n\tvoid\tSetFrameDelay(uint32_t d);\r\n\r\n\tvoid\tGetOffset(int32_t *x,int32_t *y);\r\n\tvoid\tSetOffset(int32_t x,int32_t y);\r\n\r\n\tuint8_t\tGetJpegQuality() const;\r\n\tvoid\tSetJpegQuality(uint8_t q);\r\n\tfloat\tGetJpegQualityF() const;\r\n\tvoid\tSetJpegQualityF(float q);\r\n\r\n\tuint8_t\tGetJpegScale() const;\r\n\tvoid\tSetJpegScale(uint8_t q);\r\n\r\n#if CXIMAGE_SUPPORT_EXIF\r\n\tEXIFINFO *GetExifInfo() {return &info.ExifInfo;};\r\n\tbool  GetExifThumbnail(const TCHAR *filename, const TCHAR *outname, int32_t imageType);\r\n  #if CXIMAGE_SUPPORT_TRANSFORMATION\r\n\tbool  RotateExif(int32_t orientation = 0);\r\n  #endif\r\n#endif\r\n\r\n\tint32_t\tGetXDPI() const;\r\n\tint32_t\tGetYDPI() const;\r\n\tvoid\tSetXDPI(int32_t dpi);\r\n\tvoid\tSetYDPI(int32_t dpi);\r\n\r\n\tuint32_t\tGetClrImportant() const;\r\n\tvoid\tSetClrImportant(uint32_t ncolors = 0);\r\n\r\n\tint32_t\tGetProgress() const;\r\n\tint32_t\tGetEscape() const;\r\n\tvoid\tSetProgress(int32_t p);\r\n\tvoid\tSetEscape(int32_t i);\r\n\r\n\tint32_t\tGetTransIndex() const;\r\n\tRGBQUAD\tGetTransColor();\r\n\tvoid\tSetTransIndex(int32_t idx);\r\n\tvoid\tSetTransColor(RGBQUAD rgb);\r\n\tbool\tIsTransparent() const;\r\n\r\n\tuint32_t\tGetCodecOption(uint32_t imagetype = 0);\r\n\tbool\tSetCodecOption(uint32_t opt, uint32_t imagetype = 0);\r\n\r\n\tuint32_t\tGetFlags() const;\r\n\tvoid\tSetFlags(uint32_t flags, bool bLockReservedFlags = true);\r\n\r\n\tuint8_t\tGetDisposalMethod() const;\r\n\tvoid\tSetDisposalMethod(uint8_t dm);\r\n\r\n\tbool\tSetType(uint32_t type);\r\n\r\n\tstatic uint32_t GetNumTypes();\r\n\tstatic uint32_t GetTypeIdFromName(const TCHAR* ext);\r\n\tstatic uint32_t GetTypeIdFromIndex(const uint32_t index);\r\n\tstatic uint32_t GetTypeIndexFromId(const uint32_t id);\r\n\r\n\tbool\tGetRetreiveAllFrames() const;\r\n\tvoid\tSetRetreiveAllFrames(bool flag);\r\n\tCxImage * GetFrame(int32_t nFrame) const;\r\n\r\n\t//void*\tGetUserData() const {return info.pUserData;}\r\n\t//void\tSetUserData(void* pUserData) {info.pUserData = pUserData;}\r\n//@}\r\n\r\n/** \\addtogroup Palette\r\n * These functions have no effects on RGB images and in this case the returned value is always 0.\r\n * @{ */\r\n\tbool\tIsGrayScale();\r\n\tbool\tIsIndexed() const;\r\n\tbool\tIsSamePalette(CxImage &img, bool bCheckAlpha = true);\r\n\tuint32_t\tGetPaletteSize();\r\n\tRGBQUAD* GetPalette() const;\r\n\tRGBQUAD GetPaletteColor(uint8_t idx);\r\n\tbool\tGetPaletteColor(uint8_t i, uint8_t* r, uint8_t* g, uint8_t* b);\r\n\tuint8_t\tGetNearestIndex(RGBQUAD c);\r\n\tvoid\tBlendPalette(COLORREF cr,int32_t perc);\r\n\tvoid\tSetGrayPalette();\r\n\tvoid\tSetPalette(uint32_t n, uint8_t *r, uint8_t *g, uint8_t *b);\r\n\tvoid\tSetPalette(RGBQUAD* pPal,uint32_t nColors=256);\r\n\tvoid\tSetPalette(rgb_color *rgb,uint32_t nColors=256);\r\n\tvoid\tSetPaletteColor(uint8_t idx, uint8_t r, uint8_t g, uint8_t b, uint8_t alpha=0);\r\n\tvoid\tSetPaletteColor(uint8_t idx, RGBQUAD c);\r\n\tvoid\tSetPaletteColor(uint8_t idx, COLORREF cr);\r\n\tvoid\tSwapIndex(uint8_t idx1, uint8_t idx2);\r\n\tvoid\tSwapRGB2BGR();\r\n\tvoid\tSetStdPalette();\r\n//@}\r\n\r\n/** \\addtogroup Pixel */ //@{\r\n\tbool\tIsInside(int32_t x, int32_t y);\r\n\tbool\tIsTransparent(int32_t x,int32_t y);\r\n\tbool\tGetTransparentMask(CxImage* iDst = 0);\r\n\tRGBQUAD GetPixelColor(int32_t x,int32_t y, bool bGetAlpha = true);\r\n\tuint8_t\tGetPixelIndex(int32_t x,int32_t y);\r\n\tuint8_t\tGetPixelGray(int32_t x, int32_t y);\r\n\tvoid\tSetPixelColor(int32_t x,int32_t y,RGBQUAD c, bool bSetAlpha = false);\r\n\tvoid\tSetPixelColor(int32_t x,int32_t y,COLORREF cr);\r\n\tvoid\tSetPixelIndex(int32_t x,int32_t y,uint8_t i);\r\n\tvoid\tDrawLine(int32_t StartX, int32_t EndX, int32_t StartY, int32_t EndY, RGBQUAD color, bool bSetAlpha=false);\r\n\tvoid\tDrawLine(int32_t StartX, int32_t EndX, int32_t StartY, int32_t EndY, COLORREF cr);\r\n\tvoid\tBlendPixelColor(int32_t x,int32_t y,RGBQUAD c, float blend, bool bSetAlpha = false);\r\n\tbool\tSetRectColor(int32_t left, int32_t top, int32_t right, int32_t bottom, RGBQUAD color, bool bSetAlpha = false);\r\n\tbool\tSetRectColor(RECT& rect, RGBQUAD color, bool bSetAlpha = false);\r\n//@}\r\n\r\nprotected:\r\n/** \\addtogroup Protected */ //@{\r\n\tuint8_t BlindGetPixelIndex(const int32_t x,const int32_t y);\r\n\tRGBQUAD BlindGetPixelColor(const int32_t x,const int32_t y, bool bGetAlpha = true);\r\n\tvoid *BlindGetPixelPointer(const int32_t x,const  int32_t y);\r\n\tvoid BlindSetPixelColor(int32_t x,int32_t y,RGBQUAD c, bool bSetAlpha = false);\r\n\tvoid BlindSetPixelIndex(int32_t x,int32_t y,uint8_t i);\r\n//@}\r\n\r\npublic:\r\n\r\n#if CXIMAGE_SUPPORT_INTERPOLATION\r\n/** \\addtogroup Interpolation */ //@{\r\n\t//overflow methods:\r\n\tenum OverflowMethod {\r\n\t\tOM_COLOR=1,\r\n\t\tOM_BACKGROUND=2,\r\n\t\tOM_TRANSPARENT=3,\r\n\t\tOM_WRAP=4,\r\n\t\tOM_REPEAT=5,\r\n\t\tOM_MIRROR=6\r\n\t};\r\n\tvoid OverflowCoordinates(float &x, float &y, OverflowMethod const ofMethod);\r\n\tvoid OverflowCoordinates(int32_t  &x, int32_t &y, OverflowMethod const ofMethod);\r\n\tRGBQUAD GetPixelColorWithOverflow(int32_t x, int32_t y, OverflowMethod const ofMethod=OM_BACKGROUND, RGBQUAD* const rplColor=0);\r\n\t//interpolation methods:\r\n\tenum InterpolationMethod {\r\n\t\tIM_NEAREST_NEIGHBOUR=1,\r\n\t\tIM_BILINEAR\t\t=2,\r\n\t\tIM_BSPLINE\t\t=3,\r\n\t\tIM_BICUBIC\t\t=4,\r\n\t\tIM_BICUBIC2\t\t=5,\r\n\t\tIM_LANCZOS\t\t=6,\r\n\t\tIM_BOX\t\t\t=7,\r\n\t\tIM_HERMITE\t\t=8,\r\n\t\tIM_HAMMING\t\t=9,\r\n\t\tIM_SINC\t\t\t=10,\r\n\t\tIM_BLACKMAN\t\t=11,\r\n\t\tIM_BESSEL\t\t=12,\r\n\t\tIM_GAUSSIAN\t\t=13,\r\n\t\tIM_QUADRATIC\t=14,\r\n\t\tIM_MITCHELL\t\t=15,\r\n\t\tIM_CATROM\t\t=16,\r\n\t\tIM_HANNING\t\t=17,\r\n\t\tIM_POWER\t\t=18\r\n\t};\r\n\tRGBQUAD GetPixelColorInterpolated(float x,float y, InterpolationMethod const inMethod=IM_BILINEAR, OverflowMethod const ofMethod=OM_BACKGROUND, RGBQUAD* const rplColor=0);\r\n\tRGBQUAD GetAreaColorInterpolated(float const xc, float const yc, float const w, float const h, InterpolationMethod const inMethod, OverflowMethod const ofMethod=OM_BACKGROUND, RGBQUAD* const rplColor=0);\r\n//@}\r\n\r\nprotected:\r\n/** \\addtogroup Protected */ //@{\r\n\tvoid  AddAveragingCont(RGBQUAD const &color, float const surf, float &rr, float &gg, float &bb, float &aa);\r\n//@}\r\n\r\n/** \\addtogroup Kernels */ //@{\r\npublic:\r\n\tstatic float KernelBSpline(const float x);\r\n\tstatic float KernelLinear(const float t);\r\n\tstatic float KernelCubic(const float t);\r\n\tstatic float KernelGeneralizedCubic(const float t, const float a=-1);\r\n\tstatic float KernelLanczosSinc(const float t, const float r = 3);\r\n\tstatic float KernelBox(const float x);\r\n\tstatic float KernelHermite(const float x);\r\n\tstatic float KernelHamming(const float x);\r\n\tstatic float KernelSinc(const float x);\r\n\tstatic float KernelBlackman(const float x);\r\n\tstatic float KernelBessel_J1(const float x);\r\n\tstatic float KernelBessel_P1(const float x);\r\n\tstatic float KernelBessel_Q1(const float x);\r\n\tstatic float KernelBessel_Order1(float x);\r\n\tstatic float KernelBessel(const float x);\r\n\tstatic float KernelGaussian(const float x);\r\n\tstatic float KernelQuadratic(const float x);\r\n\tstatic float KernelMitchell(const float x);\r\n\tstatic float KernelCatrom(const float x);\r\n\tstatic float KernelHanning(const float x);\r\n\tstatic float KernelPower(const float x, const float a = 2);\r\n//@}\r\n#endif //CXIMAGE_SUPPORT_INTERPOLATION\r\n\t\r\n/** \\addtogroup Painting */ //@{\r\n#if CXIMAGE_SUPPORT_WINDOWS\r\n\tint32_t\tBlt(HDC pDC, int32_t x=0, int32_t y=0);\r\n\tHBITMAP Draw2HBITMAP(HDC hdc, int32_t x, int32_t y, int32_t cx, int32_t cy, RECT* pClipRect, bool bSmooth);\r\n\tHBITMAP MakeBitmap(HDC hdc = NULL, bool bTransparency = false);\r\n\tHICON   MakeIcon(HDC hdc = NULL, bool bTransparency = false);\r\n\tHANDLE\tCopyToHandle();\r\n\tbool\tCreateFromHANDLE(HANDLE hMem);\t\t//Windows objects (clipboard)\r\n\tbool\tCreateFromHBITMAP(HBITMAP hbmp, HPALETTE hpal=0, bool bTransparency = false);\t//Windows resource\r\n\tbool\tCreateFromHICON(HICON hico, bool bTransparency = false);\r\n\tint32_t\tDraw(HDC hdc, int32_t x=0, int32_t y=0, int32_t cx = -1, int32_t cy = -1, RECT* pClipRect = 0, bool bSmooth = false, bool bFlipY = false);\r\n\tint32_t\tDraw(HDC hdc, const RECT& rect, RECT* pClipRect=NULL, bool bSmooth = false, bool bFlipY = false);\r\n\tint32_t\tStretch(HDC hdc, int32_t xoffset, int32_t yoffset, int32_t xsize, int32_t ysize, uint32_t dwRop = SRCCOPY);\r\n\tint32_t\tStretch(HDC hdc, const RECT& rect, uint32_t dwRop = SRCCOPY);\r\n\tint32_t\tTile(HDC hdc, RECT *rc);\r\n\tint32_t\tDraw2(HDC hdc, int32_t x=0, int32_t y=0, int32_t cx = -1, int32_t cy = -1);\r\n\tint32_t\tDraw2(HDC hdc, const RECT& rect);\r\n\t//int32_t\tDrawString(HDC hdc, int32_t x, int32_t y, const char* text, RGBQUAD color, const char* font, int32_t lSize=0, int32_t lWeight=400, uint8_t bItalic=0, uint8_t bUnderline=0, bool bSetAlpha=false);\r\n\tint32_t\tDrawString(HDC hdc, int32_t x, int32_t y, const TCHAR* text, RGBQUAD color, const TCHAR* font, int32_t lSize=0, int32_t lWeight=400, uint8_t bItalic=0, uint8_t bUnderline=0, bool bSetAlpha=false);\r\n\t// <VATI> extensions\r\n\tint32_t    DrawStringEx(HDC hdc, int32_t x, int32_t y, CXTEXTINFO *pTextType, bool bSetAlpha=false );\r\n\tvoid    InitTextInfo( CXTEXTINFO *txt );\r\nprotected:\r\n\tbool IsHBITMAPAlphaValid( HBITMAP hbmp );\r\npublic:\r\n#endif //CXIMAGE_SUPPORT_WINDOWS\r\n//@}\r\n\r\n\t// file operations\r\n#if CXIMAGE_SUPPORT_DECODE\r\n/** \\addtogroup Decode */ //@{\r\n#if defined(_WIN32) || defined (_WIN64)\r\n\t//bool Load(LPCWSTR filename, uint32_t imagetype=0);\r\n\tbool LoadResource(HRSRC hRes, uint32_t imagetype, HMODULE hModule=NULL);\r\n#endif\r\n\t// For UNICODE support: char -> TCHAR\r\n\tbool Load(const TCHAR* filename, uint32_t imagetype=0);\r\n\t//bool Load(const char * filename, uint32_t imagetype=0);\r\n\tbool Decode(FILE * hFile, uint32_t imagetype);\r\n\tbool Decode(CxFile * hFile, uint32_t imagetype);\r\n\tbool Decode(uint8_t * buffer, uint32_t size, uint32_t imagetype);\r\n\r\n\tbool CheckFormat(CxFile * hFile, uint32_t imagetype = 0);\r\n\tbool CheckFormat(uint8_t * buffer, uint32_t size, uint32_t imagetype = 0);\r\n//@}\r\n#endif //CXIMAGE_SUPPORT_DECODE\r\n\r\n#if CXIMAGE_SUPPORT_ENCODE\r\nprotected:\r\n/** \\addtogroup Protected */ //@{\r\n\tbool EncodeSafeCheck(CxFile *hFile);\r\n//@}\r\n\r\npublic:\r\n/** \\addtogroup Encode */ //@{\r\n#if defined(_WIN32) || defined (_WIN64)\r\n\t//bool Save(LPCWSTR filename, uint32_t imagetype=0);\r\n#endif\r\n\t// For UNICODE support: char -> TCHAR\r\n\tbool Save(const TCHAR* filename, uint32_t imagetype);\r\n\t//bool Save(const char * filename, uint32_t imagetype=0);\r\n\tbool Encode(FILE * hFile, uint32_t imagetype);\r\n\tbool Encode(CxFile * hFile, uint32_t imagetype);\r\n\tbool Encode(CxFile * hFile, CxImage ** pImages, int32_t pagecount, uint32_t imagetype);\r\n\tbool Encode(FILE *hFile, CxImage ** pImages, int32_t pagecount, uint32_t imagetype);\r\n\tbool Encode(uint8_t * &buffer, int32_t &size, uint32_t imagetype);\r\n\r\n\tbool Encode2RGBA(CxFile *hFile, bool bFlipY = false);\r\n\tbool Encode2RGBA(uint8_t * &buffer, int32_t &size, bool bFlipY = false);\r\n//@}\r\n#endif //CXIMAGE_SUPPORT_ENCODE\r\n\r\n/** \\addtogroup Attributes */ //@{\r\n\t//misc.\r\n\tbool IsValid() const;\r\n\tbool IsEnabled() const;\r\n\tvoid Enable(bool enable=true);\r\n\r\n\t// frame operations\r\n\tint32_t GetNumFrames() const;\r\n\tint32_t GetFrame() const;\r\n\tvoid SetFrame(int32_t nFrame);\r\n//@}\r\n\r\n#if CXIMAGE_SUPPORT_BASICTRANSFORMATIONS\r\n/** \\addtogroup BasicTransformations */ //@{\r\n\tbool GrayScale();\r\n\tbool Flip(bool bFlipSelection = false, bool bFlipAlpha = true);\r\n\tbool Mirror(bool bMirrorSelection = false, bool bMirrorAlpha = true);\r\n\tbool Negative();\r\n\tbool RotateLeft(CxImage* iDst = NULL);\r\n\tbool RotateRight(CxImage* iDst = NULL);\r\n\tbool IncreaseBpp(uint32_t nbit);\r\n//@}\r\n#endif //CXIMAGE_SUPPORT_BASICTRANSFORMATIONS\r\n\r\n#if CXIMAGE_SUPPORT_TRANSFORMATION\r\n/** \\addtogroup Transformations */ //@{\r\n\t// image operations\r\n\tbool Rotate(float angle, CxImage* iDst = NULL);\r\n\tbool Rotate2(float angle, CxImage *iDst = NULL, InterpolationMethod inMethod=IM_BILINEAR,\r\n                OverflowMethod ofMethod=OM_BACKGROUND, RGBQUAD *replColor=0,\r\n                bool const optimizeRightAngles=true, bool const bKeepOriginalSize=false);\r\n\tbool Rotate180(CxImage* iDst = NULL);\r\n\tbool Resample(int32_t newx, int32_t newy, int32_t mode = 1, CxImage* iDst = NULL);\r\n\tbool Resample2(int32_t newx, int32_t newy, InterpolationMethod const inMethod=IM_BICUBIC2,\r\n\t\t\t\tOverflowMethod const ofMethod=OM_REPEAT, CxImage* const iDst = NULL,\r\n\t\t\t\tbool const disableAveraging=false);\r\n\tbool DecreaseBpp(uint32_t nbit, bool errordiffusion, RGBQUAD* ppal = 0, uint32_t clrimportant = 0);\r\n\tbool Dither(int32_t method = 0);\r\n\tbool Crop(int32_t left, int32_t top, int32_t right, int32_t bottom, CxImage* iDst = NULL);\r\n\tbool Crop(const RECT& rect, CxImage* iDst = NULL);\r\n\tbool CropRotatedRectangle( int32_t topx, int32_t topy, int32_t width, int32_t height, float angle, CxImage* iDst = NULL);\r\n\tbool Skew(float xgain, float ygain, int32_t xpivot=0, int32_t ypivot=0, bool bEnableInterpolation = false);\r\n\tbool Expand(int32_t left, int32_t top, int32_t right, int32_t bottom, RGBQUAD canvascolor, CxImage* iDst = 0);\r\n\tbool Expand(int32_t newx, int32_t newy, RGBQUAD canvascolor, CxImage* iDst = 0);\r\n\tbool Thumbnail(int32_t newx, int32_t newy, RGBQUAD canvascolor, CxImage* iDst = 0);\r\n\tbool CircleTransform(int32_t type,int32_t rmax=0,float Koeff=1.0f);\r\n\tbool QIShrink(int32_t newx, int32_t newy, CxImage* const iDst = NULL, bool bChangeBpp = false);\r\n\r\n//@}\r\n#endif //CXIMAGE_SUPPORT_TRANSFORMATION\r\n\r\n#if CXIMAGE_SUPPORT_DSP\r\n/** \\addtogroup DSP */ //@{\r\n\tbool Contour();\r\n\tbool HistogramStretch(int32_t method = 0, double threshold = 0);\r\n\tbool HistogramEqualize();\r\n\tbool HistogramNormalize();\r\n\tbool HistogramRoot();\r\n\tbool HistogramLog();\r\n\tint32_t Histogram(int32_t* red, int32_t* green = 0, int32_t* blue = 0, int32_t* gray = 0, int32_t colorspace = 0);\r\n\tbool Jitter(int32_t radius=2);\r\n\tbool Repair(float radius = 0.25f, int32_t niterations = 1, int32_t colorspace = 0);\r\n\tbool Combine(CxImage* r,CxImage* g,CxImage* b,CxImage* a, int32_t colorspace = 0);\r\n\tbool FFT2(CxImage* srcReal, CxImage* srcImag, CxImage* dstReal, CxImage* dstImag, int32_t direction = 1, bool bForceFFT = true, bool bMagnitude = true);\r\n\tbool Noise(int32_t level);\r\n\tbool Median(int32_t Ksize=3);\r\n\tbool Gamma(float gamma);\r\n\tbool GammaRGB(float gammaR, float gammaG, float gammaB);\r\n\tbool ShiftRGB(int32_t r, int32_t g, int32_t b);\r\n\tbool Threshold(uint8_t level);\r\n\tbool Threshold(CxImage* pThresholdMask);\r\n\tbool Threshold2(uint8_t level, bool bDirection, RGBQUAD nBkgndColor, bool bSetAlpha = false);\r\n\tbool Colorize(uint8_t hue, uint8_t sat, float blend = 1.0f);\r\n\tbool Light(int32_t brightness, int32_t contrast = 0);\r\n\tfloat Mean();\r\n\tbool Filter(int32_t* kernel, int32_t Ksize, int32_t Kfactor, int32_t Koffset);\r\n\tbool Erode(int32_t Ksize=2);\r\n\tbool Dilate(int32_t Ksize=2);\r\n\tbool Edge(int32_t Ksize=2);\r\n\tvoid HuePalette(float correction=1);\r\n\tenum ImageOpType { OpAdd, OpAnd, OpXor, OpOr, OpMask, OpSrcCopy, OpDstCopy, OpSub, OpSrcBlend, OpScreen, OpAvg, OpBlendAlpha };\r\n\tvoid Mix(CxImage & imgsrc2, ImageOpType op, int32_t lXOffset = 0, int32_t lYOffset = 0, bool bMixAlpha = false);\r\n\tvoid MixFrom(CxImage & imagesrc2, int32_t lXOffset, int32_t lYOffset);\r\n\tbool UnsharpMask(float radius = 5.0f, float amount = 0.5f, int32_t threshold = 0);\r\n\tbool Lut(uint8_t* pLut);\r\n\tbool Lut(uint8_t* pLutR, uint8_t* pLutG, uint8_t* pLutB, uint8_t* pLutA = 0);\r\n\tbool GaussianBlur(float radius = 1.0f, CxImage* iDst = 0);\r\n\tbool TextBlur(uint8_t threshold = 100, uint8_t decay = 2, uint8_t max_depth = 5, bool bBlurHorizontal = true, bool bBlurVertical = true, CxImage* iDst = 0);\r\n\tbool SelectiveBlur(float radius = 1.0f, uint8_t threshold = 25, CxImage* iDst = 0);\r\n\tbool Solarize(uint8_t level = 128, bool bLinkedChannels = true);\r\n\tbool FloodFill(const int32_t xStart, const int32_t yStart, const RGBQUAD cFillColor, const uint8_t tolerance = 0,\r\n\t\t\t\t\tuint8_t nOpacity = 255, const bool bSelectFilledArea = false, const uint8_t nSelectionLevel = 255);\r\n\tbool Saturate(const int32_t saturation, const int32_t colorspace = 1);\r\n\tbool ConvertColorSpace(const int32_t dstColorSpace, const int32_t srcColorSpace);\r\n\tint32_t  OptimalThreshold(int32_t method = 0, RECT * pBox = 0, CxImage* pContrastMask = 0);\r\n\tbool AdaptiveThreshold(int32_t method = 0, int32_t nBoxSize = 64, CxImage* pContrastMask = 0, int32_t nBias = 0, float fGlobalLocalBalance = 0.5f);\r\n\tbool RedEyeRemove(float strength = 0.8f);\r\n\tbool Trace(RGBQUAD color_target, RGBQUAD color_trace);\r\n\r\n//@}\r\n\r\nprotected:\r\n/** \\addtogroup Protected */ //@{\r\n\tbool IsPowerof2(int32_t x);\r\n\tbool FFT(int32_t dir,int32_t m,double *x,double *y);\r\n\tbool DFT(int32_t dir,int32_t m,double *x1,double *y1,double *x2,double *y2);\r\n\tbool RepairChannel(CxImage *ch, float radius);\r\n\t// <nipper>\r\n\tint32_t gen_convolve_matrix (float radius, float **cmatrix_p);\r\n\tfloat* gen_lookup_table (float *cmatrix, int32_t cmatrix_length);\r\n\tvoid blur_line (float *ctable, float *cmatrix, int32_t cmatrix_length, uint8_t* cur_col, uint8_t* dest_col, int32_t y, int32_t bytes);\r\n\tvoid blur_text (uint8_t threshold, uint8_t decay, uint8_t max_depth, CxImage* iSrc, CxImage* iDst, uint8_t bytes);\r\n//@}\r\n\r\npublic:\r\n/** \\addtogroup ColorSpace */ //@{\r\n\tbool SplitRGB(CxImage* r,CxImage* g,CxImage* b);\r\n\tbool SplitYUV(CxImage* y,CxImage* u,CxImage* v);\r\n\tbool SplitHSL(CxImage* h,CxImage* s,CxImage* l);\r\n\tbool SplitYIQ(CxImage* y,CxImage* i,CxImage* q);\r\n\tbool SplitXYZ(CxImage* x,CxImage* y,CxImage* z);\r\n\tbool SplitCMYK(CxImage* c,CxImage* m,CxImage* y,CxImage* k);\r\n\tstatic RGBQUAD HSLtoRGB(COLORREF cHSLColor);\r\n\tstatic RGBQUAD RGBtoHSL(RGBQUAD lRGBColor);\r\n\tstatic RGBQUAD HSLtoRGB(RGBQUAD lHSLColor);\r\n\tstatic RGBQUAD YUVtoRGB(RGBQUAD lYUVColor);\r\n\tstatic RGBQUAD RGBtoYUV(RGBQUAD lRGBColor);\r\n\tstatic RGBQUAD YIQtoRGB(RGBQUAD lYIQColor);\r\n\tstatic RGBQUAD RGBtoYIQ(RGBQUAD lRGBColor);\r\n\tstatic RGBQUAD XYZtoRGB(RGBQUAD lXYZColor);\r\n\tstatic RGBQUAD RGBtoXYZ(RGBQUAD lRGBColor);\r\n#endif //CXIMAGE_SUPPORT_DSP\r\n\tstatic RGBQUAD RGBtoRGBQUAD(COLORREF cr);\r\n\tstatic COLORREF RGBQUADtoRGB (RGBQUAD c);\r\n//@}\r\n\r\n/** \\addtogroup Selection */ //@{\r\n\tbool SelectionIsValid();\r\n#if CXIMAGE_SUPPORT_SELECTION\r\n\tbool SelectionClear(uint8_t level = 0);\r\n\tbool SelectionCreate();\r\n\tbool SelectionDelete();\r\n\tbool SelectionInvert();\r\n\tbool SelectionMirror();\r\n\tbool SelectionFlip();\r\n\tbool SelectionAddRect(RECT r, uint8_t level = 255);\r\n\tbool SelectionAddEllipse(RECT r, uint8_t level = 255);\r\n\tbool SelectionAddPolygon(POINT *points, int32_t npoints, uint8_t level = 255);\r\n\tbool SelectionAddColor(RGBQUAD c, uint8_t level = 255);\r\n\tbool SelectionAddPixel(int32_t x, int32_t y, uint8_t level = 255);\r\n\tbool SelectionCopy(CxImage &from);\r\n\tbool SelectionIsInside(int32_t x, int32_t y);\r\n\tvoid SelectionGetBox(RECT& r);\r\n\tbool SelectionToHRGN(HRGN& region);\r\n\tbool SelectionSplit(CxImage *dest);\r\n\tuint8_t SelectionGet(const int32_t x,const int32_t y);\r\n\tbool SelectionSet(CxImage &from);\r\n\tvoid SelectionRebuildBox();\r\n\tuint8_t* SelectionGetPointer(const int32_t x = 0,const int32_t y = 0);\r\n//@}\r\n\r\nprotected:\r\n/** \\addtogroup Protected */ //@{\r\n\tbool BlindSelectionIsInside(int32_t x, int32_t y);\r\n\tuint8_t BlindSelectionGet(const int32_t x,const int32_t y);\r\n\tvoid SelectionSet(const int32_t x,const int32_t y,const uint8_t level);\r\n\r\npublic:\r\n\r\n#endif //CXIMAGE_SUPPORT_SELECTION\r\n//@}\r\n\r\n#if CXIMAGE_SUPPORT_ALPHA\r\n/** \\addtogroup Alpha */ //@{\r\n\tvoid AlphaClear();\r\n\tbool AlphaCreate();\r\n\tvoid AlphaDelete();\r\n\tvoid AlphaInvert();\r\n\tbool AlphaMirror();\r\n\tbool AlphaFlip();\r\n\tbool AlphaCopy(CxImage &from);\r\n\tbool AlphaSplit(CxImage *dest);\r\n\tvoid AlphaStrip();\r\n\tvoid AlphaSet(uint8_t level);\r\n\tbool AlphaSet(CxImage &from);\r\n\tvoid AlphaSet(const int32_t x,const int32_t y,const uint8_t level);\r\n\tuint8_t AlphaGet(const int32_t x,const int32_t y);\r\n\tuint8_t AlphaGetMax() const;\r\n\tvoid AlphaSetMax(uint8_t nAlphaMax);\r\n\tbool AlphaIsValid();\r\n\tuint8_t* AlphaGetPointer(const int32_t x = 0,const int32_t y = 0);\r\n\tbool AlphaFromTransparency();\r\n\r\n\tvoid AlphaPaletteClear();\r\n\tvoid AlphaPaletteEnable(bool enable=true);\r\n\tbool AlphaPaletteIsEnabled();\r\n\tbool AlphaPaletteIsValid();\r\n\tbool AlphaPaletteSplit(CxImage *dest);\r\n//@}\r\n\r\nprotected:\r\n/** \\addtogroup Protected */ //@{\r\n\tuint8_t BlindAlphaGet(const int32_t x,const int32_t y);\r\n//@}\r\n#endif //CXIMAGE_SUPPORT_ALPHA\r\n\r\npublic:\r\n#if CXIMAGE_SUPPORT_LAYERS\r\n/** \\addtogroup Layers */ //@{\r\n\tbool LayerCreate(int32_t position = -1);\r\n\tbool LayerDelete(int32_t position = -1);\r\n\tvoid LayerDeleteAll();\r\n\tCxImage* GetLayer(int32_t position);\r\n\tCxImage* GetParent() const;\r\n\tint32_t GetNumLayers() const;\r\n\tint32_t LayerDrawAll(HDC hdc, int32_t x=0, int32_t y=0, int32_t cx = -1, int32_t cy = -1, RECT* pClipRect = 0, bool bSmooth = false);\r\n\tint32_t LayerDrawAll(HDC hdc, const RECT& rect, RECT* pClipRect=NULL, bool bSmooth = false);\r\n//@}\r\n#endif //CXIMAGE_SUPPORT_LAYERS\r\n\r\nprotected:\r\n/** \\addtogroup Protected */ //@{\r\n\tvoid Startup(uint32_t imagetype = 0);\r\n\tvoid CopyInfo(const CxImage &src);\r\n\tvoid Ghost(const CxImage *src);\r\n\tvoid RGBtoBGR(uint8_t *buffer, int32_t length);\r\n\tstatic float HueToRGB(float n1,float n2, float hue);\r\n\tvoid Bitfield2RGB(uint8_t *src, uint32_t redmask, uint32_t greenmask, uint32_t bluemask, uint8_t bpp);\r\n\tstatic int32_t CompareColors(const void *elem1, const void *elem2);\r\n\tint16_t m_ntohs(const int16_t word);\r\n\tint32_t m_ntohl(const int32_t dword);\r\n\tvoid bihtoh(BITMAPINFOHEADER* bih);\r\n\r\n\tvoid*\t\t\t\tpDib; //contains the header, the palette, the pixels\r\n\tvoid*\t\t\t\tpDibLimit;\r\n\r\n    BITMAPINFOHEADER    head; //standard header\r\n\tCXIMAGEINFO\t\t\tinfo; //extended information\r\n\tuint8_t*\t\t\tpSelection;\t//selected region\r\n\tuint8_t*\t\t\tpAlpha; //alpha channel\r\n\tCxImage**\t\t\tppLayers; //generic layers\r\n\tCxImage**\t\t\tppFrames;\r\n//@}\r\n};\r\n////////////////////////////////////////////////////////////////////////////\r\n#endif // !defined(__CXIMAGE_H)\r\n", "\ufeff/*\r\n * File:\tximaico.cpp\r\n * Purpose:\tPlatform Independent ICON Image Class Loader and Writer (MS version)\r\n * 07/Aug/2001 Davide Pizzolato - www.xdp.it\r\n * CxImage version 7.0.2 07/Feb/2011\r\n */\r\n\r\n#include \"ximaico.h\"\r\n\r\n#if CXIMAGE_SUPPORT_ICO\r\n\r\n////////////////////////////////////////////////////////////////////////////////\r\n#if CXIMAGE_SUPPORT_DECODE\r\n////////////////////////////////////////////////////////////////////////////////\r\nbool CxImageICO::Decode(CxFile *hFile)\r\n{\r\n\tif (hFile==NULL) return false;\r\n\r\n\tuint32_t off = hFile->Tell(); //<yuandi>\r\n\tint32_t\tpage=info.nFrame;\t//internal icon structure indexes\r\n\r\n\t// read the first part of the header\r\n\tICONHEADER icon_header;\r\n\thFile->Read(&icon_header,sizeof(ICONHEADER),1);\r\n\r\n\ticon_header.idType = m_ntohs(icon_header.idType);\r\n\ticon_header.idCount = m_ntohs(icon_header.idCount);\r\n\r\n\t// check if it's an icon or a cursor\r\n\tif ((icon_header.idReserved == 0) && ((icon_header.idType == 1)||(icon_header.idType == 2))) {\r\n\r\n\t\tinfo.nNumFrames = icon_header.idCount;\r\n\r\n\t\t// load the icon descriptions\r\n\t\tICONDIRENTRY *icon_list = (ICONDIRENTRY *)malloc(icon_header.idCount * sizeof(ICONDIRENTRY));\r\n\t\tint32_t c;\r\n\t\tfor (c = 0; c < icon_header.idCount; c++) {\r\n\t\t\thFile->Read(icon_list + c, sizeof(ICONDIRENTRY), 1);\r\n\r\n\t\t\ticon_list[c].wPlanes = m_ntohs(icon_list[c].wPlanes);\r\n\t\t\ticon_list[c].wBitCount = m_ntohs(icon_list[c].wBitCount);\r\n\t\t\ticon_list[c].dwBytesInRes = m_ntohl(icon_list[c].dwBytesInRes);\r\n\t\t\ticon_list[c].dwImageOffset = m_ntohl(icon_list[c].dwImageOffset);\r\n\t\t}\r\n\r\n\t\tif ((page>=0)&&(page<icon_header.idCount)){\r\n\r\n\t\t\tif (info.nEscape == -1) {\r\n\t\t\t\t// Return output dimensions only\r\n\t\t\t\thead.biWidth = icon_list[page].bWidth;\r\n\t\t\t\thead.biHeight = icon_list[page].bHeight;\r\n#if CXIMAGE_SUPPORT_PNG\r\n\t\t\t\tif (head.biWidth==0 && head.biHeight==0)\r\n\t\t\t\t{\t// Vista icon support\r\n\t\t\t\t\thFile->Seek(off + icon_list[page].dwImageOffset, SEEK_SET);\r\n\t\t\t\t\tCxImage png;\r\n\t\t\t\t\tpng.SetEscape(-1);\r\n\t\t\t\t\tif (png.Decode(hFile,CXIMAGE_FORMAT_PNG)){\r\n\t\t\t\t\t\tTransfer(png);\r\n\t\t\t\t\t\tinfo.nNumFrames = icon_header.idCount;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n#endif //CXIMAGE_SUPPORT_PNG\r\n\t\t\t\tfree(icon_list);\r\n\t\t\t\tinfo.dwType = CXIMAGE_FORMAT_ICO;\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\r\n\t\t\t// get the bit count for the colors in the icon <CoreyRLucier>\r\n\t\t\tBITMAPINFOHEADER bih;\r\n\t\t\thFile->Seek(off + icon_list[page].dwImageOffset, SEEK_SET);\r\n\r\n\t\t\tif (icon_list[page].bWidth==0 && icon_list[page].bHeight==0)\r\n\t\t\t{\t// Vista icon support\r\n#if CXIMAGE_SUPPORT_PNG\r\n\t\t\t\tCxImage png;\r\n\t\t\t\tif (png.Decode(hFile,CXIMAGE_FORMAT_PNG)){\r\n\t\t\t\t\tTransfer(png);\r\n\t\t\t\t\tinfo.nNumFrames = icon_header.idCount;\r\n\t\t\t\t}\r\n\t\t\t\tSetType(CXIMAGE_FORMAT_ICO);\r\n#endif //CXIMAGE_SUPPORT_PNG\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\t// standard icon\r\n\t\t\t\thFile->Read(&bih,sizeof(BITMAPINFOHEADER),1);\r\n\r\n\t\t\t\tbihtoh(&bih);\r\n\r\n\t\t\t\tc = bih.biBitCount;\r\n\r\n\t\t\t\t// allocate memory for one icon\r\n\t\t\t\tCreate(icon_list[page].bWidth,icon_list[page].bHeight, c, CXIMAGE_FORMAT_ICO);\t//image creation\r\n\r\n\t\t\t\t// read the palette\r\n\t\t\t\tRGBQUAD pal[256];\r\n\t\t\t\tif (bih.biClrUsed)\r\n                {\r\n                    DWORD _count = bih.biClrUsed; if (_count > 256) _count = 256;\r\n                    hFile->Read(pal,_count*sizeof(RGBQUAD), 1);\r\n                }\r\n\t\t\t\telse\r\n                {\r\n                    DWORD _count = head.biClrUsed; if (_count > 256) _count = 256;\r\n                    hFile->Read(pal,_count*sizeof(RGBQUAD), 1);\r\n                }\r\n\r\n\t\t\t\tSetPalette(pal,head.biClrUsed);\t//palette assign\r\n\r\n\t\t\t\t//read the icon\r\n\t\t\t\tif (c<=24){\r\n\t\t\t\t\thFile->Read(info.pImage, head.biSizeImage, 1);\r\n\t\t\t\t} else { // 32 bit icon\r\n\t\t\t\t\tuint8_t* buf=(uint8_t*)malloc(4*head.biHeight*head.biWidth);\r\n\t\t\t\t\tuint8_t* src = buf;\r\n\t\t\t\t\thFile->Read(buf, 4*head.biHeight*head.biWidth, 1);\r\n#if CXIMAGE_SUPPORT_ALPHA\r\n\t\t\t\t\tif (!AlphaIsValid()) AlphaCreate();\r\n#endif //CXIMAGE_SUPPORT_ALPHA\r\n\t\t\t\t\tfor (int32_t y = 0; y < head.biHeight; y++) {\r\n\t\t\t\t\t\tuint8_t* dst = GetBits(y);\r\n\t\t\t\t\t\tfor(int32_t x=0;x<head.biWidth;x++){\r\n\t\t\t\t\t\t\t*dst++=src[0];\r\n\t\t\t\t\t\t\t*dst++=src[1];\r\n\t\t\t\t\t\t\t*dst++=src[2];\r\n#if CXIMAGE_SUPPORT_ALPHA\r\n\t\t\t\t\t\t\tAlphaSet(x,y,src[3]);\r\n#endif //CXIMAGE_SUPPORT_ALPHA\r\n\t\t\t\t\t\t\tsrc+=4;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tfree(buf);\r\n\t\t\t\t}\r\n\t\t\t\t// apply the AND and XOR masks\r\n\t\t\t\tint32_t maskwdt = ((head.biWidth+31) / 32) * 4;\t//line width of AND mask (always 1 Bpp)\r\n\t\t\t\tint32_t masksize = head.biHeight * maskwdt;\t\t\t\t//size of mask\r\n\t\t\t\tuint8_t *mask = (uint8_t *)malloc(masksize);\r\n\t\t\t\tif (hFile->Read(mask, masksize, 1)){\r\n\r\n\t\t\t\t\tbool bGoodMask=false;\r\n\t\t\t\t\tfor (int32_t im=0;im<masksize;im++){\r\n\t\t\t\t\t\tif (mask[im]!=255){\r\n\t\t\t\t\t\t\tbGoodMask=true;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (bGoodMask){\r\n\t\t\t\t\t\tint32_t x,y;\r\n#if CXIMAGE_SUPPORT_ALPHA\r\n\t\t\t\t\t\tbool bNeedAlpha = false;\r\n\t\t\t\t\t\tif (!AlphaIsValid()){\r\n\t\t\t\t\t\t\tAlphaCreate();\r\n\t\t\t\t\t\t} else { \r\n\t\t\t\t\t\t\tbNeedAlpha=true; //32bit icon\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tfor (y = 0; y < head.biHeight; y++) {\r\n\t\t\t\t\t\t\tfor (x = 0; x < head.biWidth; x++) {\r\n\t\t\t\t\t\t\t\tif (((mask[y*maskwdt+(x>>3)]>>(7-x%8))&0x01)){\r\n\t\t\t\t\t\t\t\t\tAlphaSet(x,y,0);\r\n\t\t\t\t\t\t\t\t\tbNeedAlpha=true;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (!bNeedAlpha) AlphaDelete();\r\n#endif //CXIMAGE_SUPPORT_ALPHA\r\n\r\n\t\t\t\t\t\t//check if there is only one transparent color\r\n\t\t\t\t\t\tRGBQUAD cc,ct;\r\n\t\t\t\t\t\tint32_t nTransColors=0;\r\n\t\t\t\t\t\tint32_t nTransIndex=0;\r\n\t\t\t\t\t\tfor (y = 0; y < head.biHeight; y++){\r\n\t\t\t\t\t\t\tfor (x = 0; x < head.biWidth; x++){\r\n\t\t\t\t\t\t\t\tif (((mask[y*maskwdt+(x>>3)] >> (7-x%8)) & 0x01)){\r\n\t\t\t\t\t\t\t\t\tcc = GetPixelColor(x,y,false);\r\n\t\t\t\t\t\t\t\t\tif (nTransColors==0){\r\n\t\t\t\t\t\t\t\t\t\tnTransIndex = GetPixelIndex(x,y);\r\n\t\t\t\t\t\t\t\t\t\tnTransColors++;\r\n\t\t\t\t\t\t\t\t\t\tct = cc;\r\n\t\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t\tif (memcmp(&cc, &ct, sizeof(RGBQUAD)) != 0){\r\n\t\t\t\t\t\t\t\t\t\t\tnTransColors++;\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (nTransColors==1 && c<=8){\r\n\t\t\t\t\t\t\tSetTransColor(ct);\r\n\t\t\t\t\t\t\tSetTransIndex(nTransIndex);\r\n#if CXIMAGE_SUPPORT_ALPHA\r\n\t\t\t\t\t\t\tAlphaDelete(); //because we have a unique transparent color in the image\r\n#endif //CXIMAGE_SUPPORT_ALPHA\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// <vho> - Transparency support w/o Alpha support\r\n\t\t\t\t\t\tif (c <= 8){ // only for icons with less than 256 colors (XP icons need alpha).\r\n\t\t\t\t\t\t\t  \r\n\t\t\t\t\t\t\t// find a color index, which is not used in the image\r\n\t\t\t\t\t\t\t// it is almost sure to find one, bcs. nobody uses all possible colors for an icon\r\n\r\n\t\t\t\t\t\t\tuint8_t colorsUsed[256];\r\n\t\t\t\t\t\t\tmemset(colorsUsed, 0, sizeof(colorsUsed));\r\n\r\n\t\t\t\t\t\t\tfor (y = 0; y < head.biHeight; y++){\r\n\t\t\t\t\t\t\t\tfor (x = 0; x < head.biWidth; x++){\r\n\t\t\t\t\t\t\t\t\tcolorsUsed[BlindGetPixelIndex(x,y)] = 1;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tint32_t iTransIdx = -1;\r\n\t\t\t\t\t\t\tfor (x = (int32_t)(head.biClrUsed-1); x>=0 ; x--){\r\n\t\t\t\t\t\t\t\tif (colorsUsed[x] == 0){\r\n\t\t\t\t\t\t\t\t\tiTransIdx = x; // this one is not in use. we may use it as transparent color\r\n\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t// Go thru image and set unused color as transparent index if needed\r\n\t\t\t\t\t\t\tif (iTransIdx >= 0){\r\n\t\t\t\t\t\t\t\tbool bNeedTrans = false;\r\n\t\t\t\t\t\t\t\tfor (y = 0; y < head.biHeight; y++){\r\n\t\t\t\t\t\t\t\t\tfor (x = 0; x < head.biWidth; x++){\r\n\t\t\t\t\t\t\t\t\t\t// AND mask (Each Byte represents 8 Pixels)\r\n\t\t\t\t\t\t\t\t\t\tif (((mask[y*maskwdt+(x>>3)] >> (7-x%8)) & 0x01)){\r\n\t\t\t\t\t\t\t\t\t\t\t// AND mask is set (!=0). This is a transparent part\r\n\t\t\t\t\t\t\t\t\t\t\tSetPixelIndex(x, y, (uint8_t)iTransIdx);\r\n\t\t\t\t\t\t\t\t\t\t\tbNeedTrans = true;\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t// set transparent index if needed\r\n\t\t\t\t\t\t\t\tif (bNeedTrans)\tSetTransIndex(iTransIdx);\r\n#if CXIMAGE_SUPPORT_ALPHA\r\n\t\t\t\t\t\t\t\tAlphaDelete(); //because we have a transparent color in the palette\r\n#endif //CXIMAGE_SUPPORT_ALPHA\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tSetTransIndex(0); //empty mask, set black as transparent color\r\n\t\t\t\t\t\tNegative();\r\n\t\t\t\t\t}\r\n\t\t\t\t} \r\n\t\t\t\tfree(mask);\r\n\t\t\t}\r\n\t\t\tfree(icon_list);\r\n\t\t\t// icon has been loaded successfully!\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\tfree(icon_list);\r\n\t}\r\n\treturn false;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n#endif //CXIMAGE_SUPPORT_DECODE\r\n////////////////////////////////////////////////////////////////////////////////\r\n#if CXIMAGE_SUPPORT_ENCODE\r\n////////////////////////////////////////////////////////////////////////////////\r\n// Thanks to <Alas>\r\nbool CxImageICO::Encode(CxFile * hFile, CxImage ** pImages, int32_t nPageCount)\r\n{\r\n  cx_try\r\n  {\r\n\tif (hFile==NULL) cx_throw(\"invalid file pointer\");\r\n\tif (pImages==NULL || nPageCount<=0) cx_throw(\"multipage ICO, no images!\");\r\n\r\n\tint32_t i;\r\n\tfor (i=0; i<nPageCount; i++){\r\n\t\tif (pImages[i]==NULL)\r\n\t\t\tcx_throw(\"Bad image pointer\");\r\n\t\tif (!(pImages[i]->IsValid()))\r\n\t\t\tcx_throw(\"Empty image\");\r\n\t}\r\n\r\n\tCxImageICO ghost;\r\n\tfor (i=0; i<nPageCount; i++){\t//write headers\r\n\t\tghost.Ghost(pImages[i]);\r\n\t\tghost.info.nNumFrames = nPageCount;\r\n\t\tif (i==0) {\r\n\t\t\tif (!ghost.Encode(hFile,false,nPageCount))\r\n\t\t\t\tcx_throw(\"Error writing ICO file header\");\r\n\t\t}\r\n\t\tif (!ghost.Encode(hFile,true,nPageCount)) \r\n\t\t\tcx_throw(\"Error saving ICO image header\");\r\n\t}\r\n\tfor (i=0; i<nPageCount; i++){\t//write bodies\r\n\t\tghost.Ghost(pImages[i]);\r\n\t\tghost.info.nNumFrames = nPageCount;\r\n\t\tif (!ghost.Encode(hFile,true,i)) \r\n\t\t\tcx_throw(\"Error saving ICO body\");\r\n\t}\r\n\r\n  } cx_catch {\r\n\t  if (strcmp(message,\"\")) strncpy(info.szLastError,message,255);\r\n\t  return false;\r\n  }\r\n\treturn true;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\nbool CxImageICO::Encode(CxFile * hFile, bool bAppend, int32_t nPageCount)\r\n{\r\n\tif (EncodeSafeCheck(hFile)) return false;\r\n\r\n#if CXIMAGE_SUPPORT_PNG == 0\r\n\t//check format limits\r\n\tif ((head.biWidth>255)||(head.biHeight>255)){\r\n\t\tstrcpy(info.szLastError,\"Can't save this image as icon\");\r\n\t\treturn false;\r\n\t}\r\n#endif\r\n\r\n\t//prepare the palette struct\r\n\tRGBQUAD* pal=GetPalette();\r\n\tif (head.biBitCount<=8 && pal==NULL) return false;\r\n\r\n\tint32_t maskwdt=((head.biWidth+31)/32)*4; //mask line width\r\n\tint32_t masksize=head.biHeight * maskwdt; //size of mask\r\n\tint32_t bitcount=head.biBitCount;\r\n\tint32_t imagesize=head.biSizeImage;\r\n#if CXIMAGE_SUPPORT_ALPHA\r\n\tif (AlphaIsValid() && head.biClrUsed==0){\r\n\t\tbitcount=32;\r\n\t\timagesize=4*head.biHeight*head.biWidth;\r\n\t}\r\n#endif\r\n\r\n\t//fill the icon headers\r\n\tint32_t nPages = nPageCount;\r\n\tif (nPages<1) nPages = 1;\r\n\r\n\tICONHEADER icon_header={0,1,(uint16_t)nPages};\r\n\r\n\tif (!bAppend)\r\n\t\tm_dwImageOffset = sizeof(ICONHEADER) + nPages * sizeof(ICONDIRENTRY);\r\n\r\n\tuint32_t dwBytesInRes = sizeof(BITMAPINFOHEADER)+head.biClrUsed*sizeof(RGBQUAD)+imagesize+masksize;\r\n\r\n\tICONDIRENTRY icon_list={\r\n\t\t(uint8_t)head.biWidth,\r\n\t\t(uint8_t)head.biHeight,\r\n\t\t(uint8_t)head.biClrUsed,\r\n\t\t0, 0,\r\n\t\t(uint16_t)bitcount,\r\n\t\tdwBytesInRes,\r\n\t\tm_dwImageOffset\r\n\t};\r\n\r\n\tBITMAPINFOHEADER bi={\r\n\t\tsizeof(BITMAPINFOHEADER),\r\n\t\thead.biWidth,\r\n\t\t2*head.biHeight,\r\n\t\t1,\r\n\t\t(uint16_t)bitcount,\r\n\t\t0, (uint32_t)imagesize,\r\n\t\t0, 0, 0, 0\r\n\t};\r\n\r\n#if CXIMAGE_SUPPORT_PNG // Vista icon support\r\n\tCxImage png(*this);\r\n\tCxMemFile memfile;\r\n\tif (head.biWidth>255 || head.biHeight>255){\r\n\t\ticon_list.bWidth = icon_list.bHeight = 0;\r\n\t\tmemfile.Open();\r\n\t\tpng.Encode(&memfile,CXIMAGE_FORMAT_PNG);\r\n\t\ticon_list.dwBytesInRes = dwBytesInRes = memfile.Size();\r\n\t}\r\n#endif //CXIMAGE_SUPPORT_PNG\r\n\r\n\tif (!bAppend){\r\n\t\ticon_header.idType = m_ntohs(icon_header.idType);\r\n\t\ticon_header.idCount = m_ntohs(icon_header.idCount);\r\n\t\thFile->Write(&icon_header,sizeof(ICONHEADER),1);\t//write the file header\r\n\t\ticon_header.idType = m_ntohs(icon_header.idType);\r\n\t\ticon_header.idCount = m_ntohs(icon_header.idCount);\r\n\t}\r\n\r\n\r\n\tif ((bAppend && nPageCount==info.nNumFrames) || (!bAppend && nPageCount==0)){\r\n\t\ticon_list.wPlanes = m_ntohs(icon_list.wPlanes);\r\n\t\ticon_list.wBitCount = m_ntohs(icon_list.wBitCount);\r\n\t\ticon_list.dwBytesInRes = m_ntohl(icon_list.dwBytesInRes);\r\n\t\ticon_list.dwImageOffset = m_ntohl(icon_list.dwImageOffset);\r\n\t\thFile->Write(&icon_list,sizeof(ICONDIRENTRY),1);\t//write the image entry\r\n\t\ticon_list.wPlanes = m_ntohs(icon_list.wPlanes);\r\n\t\ticon_list.wBitCount = m_ntohs(icon_list.wBitCount);\r\n\t\ticon_list.dwBytesInRes = m_ntohl(icon_list.dwBytesInRes);\r\n\t\ticon_list.dwImageOffset = m_ntohl(icon_list.dwImageOffset);\r\n\r\n\t\tm_dwImageOffset += dwBytesInRes;\t\t\t//update offset for next header\r\n\t}\r\n\r\n\tif ((bAppend && nPageCount<info.nNumFrames) || (!bAppend && nPageCount==0))\r\n\t{\r\n#if CXIMAGE_SUPPORT_PNG\r\n\t\tif (icon_list.bWidth==0 && icon_list.bHeight==0) {\t// Vista icon support\r\n\t\t\thFile->Write(memfile.GetBuffer(false),dwBytesInRes,1);\r\n\t\t} else\r\n#endif //CXIMAGE_SUPPORT_PNG\r\n\t\t{\t// standard icon\r\n\t\t\tbihtoh(&bi);\r\n\t\t\thFile->Write(&bi,sizeof(BITMAPINFOHEADER),1);\t\t\t//write the image header\r\n\t\t\tbihtoh(&bi);\r\n\r\n\t\t\tbool bTransparent = info.nBkgndIndex >= 0;\r\n\t\t\tRGBQUAD ct = GetTransColor();\r\n\t\t\tif (pal){\r\n\t\t\t\tif (bTransparent) SetPaletteColor((uint8_t)info.nBkgndIndex,0,0,0,0);\r\n\t\t\t \thFile->Write(pal,head.biClrUsed*sizeof(RGBQUAD),1); //write palette\r\n\t\t\t\tif (bTransparent) SetPaletteColor((uint8_t)info.nBkgndIndex,ct);\r\n\t\t\t}\r\n\r\n#if CXIMAGE_SUPPORT_ALPHA\r\n\t\t\tif (AlphaIsValid() && head.biClrUsed==0){\r\n\t\t\t\tuint8_t* buf=(uint8_t*)malloc(imagesize);\r\n\t\t\t\tuint8_t* dst = buf;\r\n\t\t\t\tfor (int32_t y = 0; y < head.biHeight; y++) {\r\n\t\t\t\t\tuint8_t* src = GetBits(y);\r\n\t\t\t\t\tfor(int32_t x=0;x<head.biWidth;x++){\r\n\t\t\t\t\t\t*dst++=*src++;\r\n\t\t\t\t\t\t*dst++=*src++;\r\n\t\t\t\t\t\t*dst++=*src++;\r\n\t\t\t\t\t\t*dst++=AlphaGet(x,y);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\thFile->Write(buf,imagesize, 1);\r\n\t\t\t\tfree(buf);\r\n\t\t\t} else {\r\n\t\t\t\thFile->Write(info.pImage,imagesize,1);\t//write image\r\n\t\t\t}\r\n#else\r\n\t\t\thFile->Write(info.pImage,imagesize,1);\t//write image\r\n#endif\r\n\r\n\t\t\t//save transparency mask\r\n\t\t\tuint8_t* mask=(uint8_t*)calloc(masksize,1);\t//create empty AND/XOR masks\r\n\t\t\tif (!mask) return false;\r\n\r\n\t\t\t//prepare the variables to build the mask\r\n\t\t\tuint8_t* iDst;\r\n\t\t\tint32_t pos,i;\r\n\t\t\tRGBQUAD c={0,0,0,0};\r\n\t\t\tint32_t* pc = (int32_t*)&c;\r\n\t\t\tint32_t* pct= (int32_t*)&ct;\r\n#if CXIMAGE_SUPPORT_ALPHA\r\n\t\t\tbool bAlphaPaletteIsValid = AlphaPaletteIsValid();\r\n\t\t\tbool bAlphaIsValid = AlphaIsValid();\r\n#endif\r\n\t\t\t//build the mask\r\n\t\t\tfor (int32_t y = 0; y < head.biHeight; y++) {\r\n\t\t\t\tfor (int32_t x = 0; x < head.biWidth; x++) {\r\n\t\t\t\t\ti=0;\r\n#if CXIMAGE_SUPPORT_ALPHA\r\n\t\t\t\t\tif (bAlphaIsValid && AlphaGet(x,y)==0) i=1;\r\n\t\t\t\t\tif (bAlphaPaletteIsValid && BlindGetPixelColor(x,y).rgbReserved==0) i=1;\r\n#endif\r\n\t\t\t\t\tc=GetPixelColor(x,y,false);\r\n\t\t\t\t\tif (bTransparent && *pc==*pct) i=1;\r\n\t\t\t\t\tiDst = mask + y*maskwdt + (x>>3);\r\n\t\t\t\t\tpos = 7-x%8;\r\n\t\t\t\t\t*iDst &= ~(0x01<<pos);\r\n\t\t\t\t\t*iDst |= ((i & 0x01)<<pos);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t//write AND/XOR masks\r\n\t\t\thFile->Write(mask,masksize,1);\r\n\t\t\tfree(mask);\r\n\t\t}\r\n\t}\r\n\r\n\treturn true;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n#endif // CXIMAGE_SUPPORT_ENCODE\r\n////////////////////////////////////////////////////////////////////////////////\r\n#endif // CXIMAGE_SUPPORT_ICO\r\n\r\n", "\ufeff// ximainfo.cpp : main attributes\r\n/* 03/10/2004 v1.00 - Davide Pizzolato - www.xdp.it\r\n * CxImage version 7.0.2 07/Feb/2011\r\n */\r\n\r\n#include \"ximage.h\"\r\n\r\n#if defined(_LINUX) || defined(__APPLE__)\r\n    #ifdef UNICODE\r\n        #define _tcsnicmp(a,b,c) wcscasecmp(a,b)\r\n    #else\r\n        #define _tcsnicmp(a,b,c) strcasecmp(a,b)\r\n    #endif\r\n#endif\r\n\r\n////////////////////////////////////////////////////////////////////////////////\r\n/**\r\n * \\return the color used for transparency, and/or for background color\r\n */\r\nRGBQUAD\tCxImage::GetTransColor()\r\n{\r\n\tif (head.biBitCount<24 && info.nBkgndIndex>=0) return GetPaletteColor((uint8_t)info.nBkgndIndex);\r\n\treturn info.nBkgndColor;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n/**\r\n * Gets the index used for transparency. Returns -1 for no transparancy.\r\n */\r\nint32_t CxImage::GetTransIndex() const\r\n{\r\n\treturn info.nBkgndIndex;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n/**\r\n * Sets the index used for transparency with 1, 4 and 8 bpp images. Set to -1 to remove the effect.\r\n */\r\nvoid CxImage::SetTransIndex(int32_t idx)\r\n{\r\n\tif (idx<(int32_t)head.biClrUsed)\r\n\t\tinfo.nBkgndIndex = idx;\r\n\telse \r\n\t\tinfo.nBkgndIndex = 0;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n/**\r\n * Sets the color used for transparency with 24 bpp images.\r\n * You must call SetTransIndex(0) to enable the effect, SetTransIndex(-1) to disable it.\r\n */\r\nvoid CxImage::SetTransColor(RGBQUAD rgb)\r\n{\r\n\trgb.rgbReserved=0;\r\n\tinfo.nBkgndColor = rgb;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\nbool CxImage::IsTransparent() const\r\n{\r\n\treturn info.nBkgndIndex>=0; // <vho>\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n/**\r\n * Returns true if the image has 256 colors or less.\r\n */\r\nbool CxImage::IsIndexed() const\r\n{\r\n\treturn head.biClrUsed!=0;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n/**\r\n * \\return 1 = indexed, 2 = RGB, 4 = RGBA\r\n */\r\nuint8_t CxImage::GetColorType()\r\n{\r\n\tuint8_t b = (uint8_t)((head.biBitCount>8) ? 2 /*COLORTYPE_COLOR*/ : 1 /*COLORTYPE_PALETTE*/);\r\n#if CXIMAGE_SUPPORT_ALPHA\r\n\tif (AlphaIsValid()) b = 4 /*COLORTYPE_ALPHA*/;\r\n#endif //CXIMAGE_SUPPORT_ALPHA\r\n\treturn b;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n/**\r\n * \\return Resolution for TIFF, JPEG, PNG and BMP formats.\r\n */\r\nint32_t CxImage::GetXDPI() const\r\n{\r\n\treturn info.xDPI;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n/**\r\n * \\return Resolution for TIFF, JPEG, PNG and BMP formats.\r\n */\r\nint32_t CxImage::GetYDPI() const\r\n{\r\n\treturn info.yDPI;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n/**\r\n * Set resolution for TIFF, JPEG, PNG and BMP formats.\r\n */\r\nvoid CxImage::SetXDPI(int32_t dpi)\r\n{\r\n\tif (dpi<=0) dpi = CXIMAGE_DEFAULT_DPI;\r\n\tinfo.xDPI = dpi;\r\n\thead.biXPelsPerMeter = (int32_t) floor(dpi * 10000.0 / 254.0 + 0.5);\r\n\tif (pDib) ((BITMAPINFOHEADER*)pDib)->biXPelsPerMeter = head.biXPelsPerMeter;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n/**\r\n * Set resolution for TIFF, JPEG, PNG and BMP formats.\r\n */\r\nvoid CxImage::SetYDPI(int32_t dpi)\r\n{\r\n\tif (dpi<=0) dpi = CXIMAGE_DEFAULT_DPI;\r\n\tinfo.yDPI = dpi;\r\n\thead.biYPelsPerMeter = (int32_t) floor(dpi * 10000.0 / 254.0 + 0.5);\r\n\tif (pDib) ((BITMAPINFOHEADER*)pDib)->biYPelsPerMeter = head.biYPelsPerMeter;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n/**\r\n * \\sa SetFlags\r\n */\r\nuint32_t CxImage::GetFlags() const\r\n{\r\n\treturn info.dwFlags;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n/**\r\n * Image flags, for future use\r\n * \\param flags\r\n *  - 0x??00000 = reserved for 16 bit, CMYK, multilayer\r\n *  - 0x00??0000 = blend modes\r\n *  - 0x0000???? = layer id or user flags\r\n *\r\n * \\param bLockReservedFlags protects the \"reserved\" and \"blend modes\" flags \r\n */\r\nvoid CxImage::SetFlags(uint32_t flags, bool bLockReservedFlags)\r\n{\r\n\tif (bLockReservedFlags) info.dwFlags = flags & 0x0000ffff;\r\n\telse info.dwFlags = flags;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n/**\r\n * \\sa SetCodecOption\r\n */\r\nuint32_t CxImage::GetCodecOption(uint32_t imagetype)\r\n{\r\n\timagetype = GetTypeIndexFromId(imagetype);\r\n\tif (imagetype==0){\r\n\t\timagetype = GetTypeIndexFromId(GetType());\r\n\t}\r\n\treturn info.dwCodecOpt[imagetype];\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n/**\r\n * Encode option for GIF, TIF, JPG, PNG and RAW\r\n * - GIF : 0 = LZW (default), 1 = none, 2 = RLE.\r\n * - TIF : 0 = automatic (default), or a valid compression code as defined in \"tiff.h\" (COMPRESSION_NONE = 1, COMPRESSION_CCITTRLE = 2, ...)\r\n * - JPG : valid values stored in enum CODEC_OPTION ( ENCODE_BASELINE = 0x01, ENCODE_PROGRESSIVE = 0x10, ...)\r\n * - PNG : combination of interlace option and compression option\r\n *         interlace option :  1 = interlace, 0 = no interlace\r\n *         compression option : 2 = no compression, 4 = best speed, 6 = best compression, 8 = default compression\r\n *         default is no interlace and default compression\r\n *         example : 5 = 1+4 = interlace + best speed\r\n * - RAW : valid values stored in enum CODEC_OPTION ( DECODE_QUALITY_LIN = 0x00, DECODE_QUALITY_VNG = 0x01, ...)\r\n *\r\n * \\return true if everything is ok\r\n */\r\nbool CxImage::SetCodecOption(uint32_t opt, uint32_t imagetype)\r\n{\r\n\timagetype = GetTypeIndexFromId(imagetype);\r\n\tif (imagetype==0){\r\n\t\timagetype = GetTypeIndexFromId(GetType());\r\n\t}\r\n\tinfo.dwCodecOpt[imagetype] = opt;\r\n\treturn true;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n/**\r\n * \\return internal hDib object..\r\n */\r\nvoid* CxImage::GetDIB() const\r\n{\r\n\treturn pDib;\r\n}\r\nvoid* CxImage::GetDIBLimit() const\r\n{\r\n    return pDibLimit;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\nuint32_t CxImage::GetHeight() const\r\n{\r\n\treturn head.biHeight;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\nuint32_t CxImage::GetWidth() const\r\n{\r\n\treturn head.biWidth;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n/**\r\n * \\return uint32_t aligned width of the image.\r\n */\r\nuint32_t CxImage::GetEffWidth() const\r\n{\r\n\treturn info.dwEffWidth;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n/**\r\n * \\return 2, 16, 256; 0 for RGB images.\r\n */\r\nuint32_t CxImage::GetNumColors() const\r\n{\r\n\treturn head.biClrUsed;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n/**\r\n * \\return: 1, 4, 8, 24.\r\n */\r\nuint16_t CxImage::GetBpp() const\r\n{\r\n\treturn head.biBitCount;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n/**\r\n * \\return original image format\r\n * \\sa ENUM_CXIMAGE_FORMATS.\r\n */\r\nuint32_t CxImage::GetType() const\r\n{\r\n\treturn info.dwType;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n/**\r\n * change image format identifier\r\n * \\sa ENUM_CXIMAGE_FORMATS.\r\n */\r\nbool CxImage::SetType(uint32_t type)\r\n{\r\n\tswitch (type){\r\n#if CXIMAGE_SUPPORT_BMP\r\n\tcase CXIMAGE_FORMAT_BMP:\r\n#endif\r\n#if CXIMAGE_SUPPORT_GIF\r\n\tcase CXIMAGE_FORMAT_GIF:\r\n#endif\r\n#if CXIMAGE_SUPPORT_JPG\r\n\tcase CXIMAGE_FORMAT_JPG:\r\n#endif\r\n#if CXIMAGE_SUPPORT_PNG\r\n\tcase CXIMAGE_FORMAT_PNG:\r\n#endif\r\n#if CXIMAGE_SUPPORT_MNG\r\n\tcase CXIMAGE_FORMAT_MNG:\r\n#endif\r\n#if CXIMAGE_SUPPORT_ICO\r\n\tcase CXIMAGE_FORMAT_ICO:\r\n#endif\r\n#if CXIMAGE_SUPPORT_TIF\r\n\tcase CXIMAGE_FORMAT_TIF:\r\n#endif\r\n#if CXIMAGE_SUPPORT_TGA\r\n\tcase CXIMAGE_FORMAT_TGA:\r\n#endif\r\n#if CXIMAGE_SUPPORT_PCX\r\n\tcase CXIMAGE_FORMAT_PCX:\r\n#endif\r\n#if CXIMAGE_SUPPORT_WBMP\r\n\tcase CXIMAGE_FORMAT_WBMP:\r\n#endif\r\n#if CXIMAGE_SUPPORT_WMF\r\n\tcase CXIMAGE_FORMAT_WMF:\r\n#endif\r\n#if CXIMAGE_SUPPORT_JBG\r\n\tcase CXIMAGE_FORMAT_JBG:\r\n#endif\r\n#if CXIMAGE_SUPPORT_JP2\r\n\tcase CXIMAGE_FORMAT_JP2:\r\n#endif\r\n#if CXIMAGE_SUPPORT_JPC\r\n\tcase CXIMAGE_FORMAT_JPC:\r\n#endif\r\n#if CXIMAGE_SUPPORT_PGX\r\n\tcase CXIMAGE_FORMAT_PGX:\r\n#endif\r\n#if CXIMAGE_SUPPORT_PNM\r\n\tcase CXIMAGE_FORMAT_PNM:\r\n#endif\r\n#if CXIMAGE_SUPPORT_RAS\r\n\tcase CXIMAGE_FORMAT_RAS:\r\n#endif\r\n#if CXIMAGE_SUPPORT_SKA\r\n\tcase CXIMAGE_FORMAT_SKA:\r\n#endif\r\n#if CXIMAGE_SUPPORT_RAW\r\n\tcase CXIMAGE_FORMAT_RAW:\r\n#endif\r\n#if CXIMAGE_SUPPORT_PSD\r\n\tcase CXIMAGE_FORMAT_PSD:\r\n#endif\r\n\t\tinfo.dwType = type;\r\n\t\treturn true;\r\n\tcase CXIMAGE_FORMAT_UNKNOWN:\r\n\tdefault:\r\n\t\tinfo.dwType = CXIMAGE_FORMAT_UNKNOWN;\r\n\t}\r\n\treturn false;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\nuint32_t CxImage::GetNumTypes()\r\n{\r\n\treturn CMAX_IMAGE_FORMATS-1;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\nuint32_t CxImage::GetTypeIdFromName(const TCHAR* ext)\r\n{\r\n#if CXIMAGE_SUPPORT_BMP\r\n\tif (_tcsnicmp(ext,_T(\"bmp\"),3)==0 )\t\treturn CXIMAGE_FORMAT_BMP;\r\n#endif\r\n#if CXIMAGE_SUPPORT_JPG\r\n\tif (_tcsnicmp(ext,_T(\"jpg\"),3)==0 ||\r\n\t\t_tcsnicmp(ext,_T(\"jpe\"),3)==0 ||\r\n\t\t_tcsnicmp(ext,_T(\"jfi\"),3)==0 )\t\treturn CXIMAGE_FORMAT_JPG;\r\n#endif\r\n#if CXIMAGE_SUPPORT_GIF\r\n\tif (_tcsnicmp(ext,_T(\"gif\"),3)==0 )\t\treturn CXIMAGE_FORMAT_GIF;\r\n#endif\r\n#if CXIMAGE_SUPPORT_PNG\r\n\tif (_tcsnicmp(ext,_T(\"png\"),3)==0 )\t\treturn CXIMAGE_FORMAT_PNG;\r\n#endif\r\n#if CXIMAGE_SUPPORT_ICO\r\n\tif (_tcsnicmp(ext,_T(\"ico\"),3)==0 ||\r\n\t\t_tcsnicmp(ext,_T(\"cur\"),3)==0 )\t\treturn CXIMAGE_FORMAT_ICO;\r\n#endif\r\n#if CXIMAGE_SUPPORT_TIF\r\n\tif (_tcsnicmp(ext,_T(\"tif\"),3)==0 )\t\treturn CXIMAGE_FORMAT_TIF;\r\n#endif\r\n#if CXIMAGE_SUPPORT_TGA\r\n\tif (_tcsnicmp(ext,_T(\"tga\"),3)==0 )\t\treturn CXIMAGE_FORMAT_TGA;\r\n#endif\r\n#if CXIMAGE_SUPPORT_PCX\r\n\tif (_tcsnicmp(ext,_T(\"pcx\"),3)==0 )\t\treturn CXIMAGE_FORMAT_PCX;\r\n#endif\r\n#if CXIMAGE_SUPPORT_WBMP\r\n\tif (_tcsnicmp(ext,_T(\"wbm\"),3)==0 )\t\treturn CXIMAGE_FORMAT_WBMP;\r\n#endif\r\n#if CXIMAGE_SUPPORT_WMF\r\n\tif (_tcsnicmp(ext,_T(\"wmf\"),3)==0 ||\r\n\t\t_tcsnicmp(ext,_T(\"emf\"),3)==0 )\t\treturn CXIMAGE_FORMAT_WMF;\r\n#endif\r\n#if CXIMAGE_SUPPORT_JP2\r\n\tif (_tcsnicmp(ext,_T(\"jp2\"),3)==0 ||\r\n\t\t_tcsnicmp(ext,_T(\"j2k\"),3)==0 )\t\treturn CXIMAGE_FORMAT_JP2;\r\n#endif\r\n#if CXIMAGE_SUPPORT_JPC\r\n\tif (_tcsnicmp(ext,_T(\"jpc\"),3)==0 ||\r\n\t\t_tcsnicmp(ext,_T(\"j2c\"),3)==0 )\t\treturn CXIMAGE_FORMAT_JPC;\r\n#endif\r\n#if CXIMAGE_SUPPORT_PGX\r\n\tif (_tcsnicmp(ext,_T(\"pgx\"),3)==0 )\t\treturn CXIMAGE_FORMAT_PGX;\r\n#endif\r\n#if CXIMAGE_SUPPORT_RAS\r\n\tif (_tcsnicmp(ext,_T(\"ras\"),3)==0 )\t\treturn CXIMAGE_FORMAT_RAS;\r\n#endif\r\n#if CXIMAGE_SUPPORT_PNM\r\n\tif (_tcsnicmp(ext,_T(\"pnm\"),3)==0 ||\r\n\t\t_tcsnicmp(ext,_T(\"pgm\"),3)==0 ||\r\n\t\t_tcsnicmp(ext,_T(\"ppm\"),3)==0 )\t\treturn CXIMAGE_FORMAT_PNM;\r\n#endif\r\n#if CXIMAGE_SUPPORT_JBG\r\n\tif (_tcsnicmp(ext,_T(\"jbg\"),3)==0 )\t\treturn CXIMAGE_FORMAT_JBG;\r\n#endif\r\n#if CXIMAGE_SUPPORT_MNG\r\n\tif (_tcsnicmp(ext,_T(\"mng\"),3)==0 ||\r\n\t\t_tcsnicmp(ext,_T(\"jng\"),3)==0 )\t\treturn CXIMAGE_FORMAT_MNG;\r\n#endif\r\n#if CXIMAGE_SUPPORT_SKA\r\n\tif (_tcsnicmp(ext,_T(\"ska\"),3)==0 )\t\treturn CXIMAGE_FORMAT_SKA;\r\n#endif\r\n#if CXIMAGE_SUPPORT_PSD\r\n\tif (_tcsnicmp(ext,_T(\"psd\"),3)==0 )\t\treturn CXIMAGE_FORMAT_PSD;\r\n#endif\r\n#if CXIMAGE_SUPPORT_RAW\r\n\tif (_tcsnicmp(ext,_T(\"nef\"),3)==0 ||\r\n\t\t_tcsnicmp(ext,_T(\"crw\"),3)==0 ||\r\n\t\t_tcsnicmp(ext,_T(\"cr2\"),3)==0 ||\r\n\t\t_tcsnicmp(ext,_T(\"dng\"),3)==0 ||\r\n\t\t_tcsnicmp(ext,_T(\"arw\"),3)==0 ||\r\n\t\t_tcsnicmp(ext,_T(\"erf\"),3)==0 ||\r\n\t\t_tcsnicmp(ext,_T(\"3fr\"),3)==0 ||\r\n\t\t_tcsnicmp(ext,_T(\"dcr\"),3)==0 ||\r\n\t\t_tcsnicmp(ext,_T(\"raw\"),3)==0 ||\r\n\t\t_tcsnicmp(ext,_T(\"x3f\"),3)==0 ||\r\n\t\t_tcsnicmp(ext,_T(\"mef\"),3)==0 ||\r\n\t\t_tcsnicmp(ext,_T(\"raf\"),3)==0 ||\r\n\t\t_tcsnicmp(ext,_T(\"mrw\"),3)==0 ||\r\n\t\t_tcsnicmp(ext,_T(\"pef\"),3)==0 ||\r\n\t\t_tcsnicmp(ext,_T(\"sr2\"),3)==0 ||\r\n\t\t_tcsnicmp(ext,_T(\"orf\"),3)==0 )\t\treturn CXIMAGE_FORMAT_RAW;\r\n#endif\r\n\r\n\treturn CXIMAGE_FORMAT_UNKNOWN;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\nuint32_t CxImage::GetTypeIdFromIndex(const uint32_t index)\r\n{\r\n\tuint32_t n;\r\n\r\n\tn=0; if (index == n) return CXIMAGE_FORMAT_UNKNOWN;\r\n#if CXIMAGE_SUPPORT_BMP\r\n\tn++; if (index == n) return CXIMAGE_FORMAT_BMP;\r\n#endif\r\n#if CXIMAGE_SUPPORT_GIF\r\n\tn++; if (index == n) return CXIMAGE_FORMAT_GIF;\r\n#endif\r\n#if CXIMAGE_SUPPORT_JPG\r\n\tn++; if (index == n) return CXIMAGE_FORMAT_JPG;\r\n#endif\r\n#if CXIMAGE_SUPPORT_PNG\r\n\tn++; if (index == n) return CXIMAGE_FORMAT_PNG;\r\n#endif\r\n#if CXIMAGE_SUPPORT_ICO\r\n\tn++; if (index == n) return CXIMAGE_FORMAT_ICO;\r\n#endif\r\n#if CXIMAGE_SUPPORT_TIF\r\n\tn++; if (index == n) return CXIMAGE_FORMAT_TIF;\r\n#endif\r\n#if CXIMAGE_SUPPORT_TGA\r\n\tn++; if (index == n) return CXIMAGE_FORMAT_TGA;\r\n#endif\r\n#if CXIMAGE_SUPPORT_PCX\r\n\tn++; if (index == n) return CXIMAGE_FORMAT_PCX;\r\n#endif\r\n#if CXIMAGE_SUPPORT_WBMP\r\n\tn++; if (index == n) return CXIMAGE_FORMAT_WBMP;\r\n#endif\r\n#if CXIMAGE_SUPPORT_WMF\r\n\tn++; if (index == n) return CXIMAGE_FORMAT_WMF;\r\n#endif\r\n#if CXIMAGE_SUPPORT_JP2\r\n\tn++; if (index == n) return CXIMAGE_FORMAT_JP2;\r\n#endif\r\n#if CXIMAGE_SUPPORT_JPC\r\n\tn++; if (index == n) return CXIMAGE_FORMAT_JPC;\r\n#endif\r\n#if CXIMAGE_SUPPORT_PGX\r\n\tn++; if (index == n) return CXIMAGE_FORMAT_PGX;\r\n#endif\r\n#if CXIMAGE_SUPPORT_PNM\r\n\tn++; if (index == n) return CXIMAGE_FORMAT_PNM;\r\n#endif\r\n#if CXIMAGE_SUPPORT_RAS\r\n\tn++; if (index == n) return CXIMAGE_FORMAT_RAS;\r\n#endif\r\n#if CXIMAGE_SUPPORT_JBG\r\n\tn++; if (index == n) return CXIMAGE_FORMAT_JBG;\r\n#endif\r\n#if CXIMAGE_SUPPORT_MNG\r\n\tn++; if (index == n) return CXIMAGE_FORMAT_MNG;\r\n#endif\r\n#if CXIMAGE_SUPPORT_SKA\r\n\tn++; if (index == n) return CXIMAGE_FORMAT_SKA;\r\n#endif\r\n#if CXIMAGE_SUPPORT_RAW\r\n\tn++; if (index == n) return CXIMAGE_FORMAT_RAW;\r\n#endif\r\n#if CXIMAGE_SUPPORT_PSD\r\n\tn++; if (index == n) return CXIMAGE_FORMAT_PSD;\r\n#endif\r\n\r\n\treturn CXIMAGE_FORMAT_UNKNOWN;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\nuint32_t CxImage::GetTypeIndexFromId(const uint32_t id)\r\n{\r\n\tuint32_t n;\r\n\r\n\tn=0; if (id == CXIMAGE_FORMAT_UNKNOWN) return n;\r\n#if CXIMAGE_SUPPORT_BMP\r\n\tn++; if (id == CXIMAGE_FORMAT_BMP) return n;\r\n#endif\r\n#if CXIMAGE_SUPPORT_GIF\r\n\tn++; if (id == CXIMAGE_FORMAT_GIF) return n;\r\n#endif\r\n#if CXIMAGE_SUPPORT_JPG\r\n\tn++; if (id == CXIMAGE_FORMAT_JPG) return n;\r\n#endif\r\n#if CXIMAGE_SUPPORT_PNG\r\n\tn++; if (id == CXIMAGE_FORMAT_PNG) return n;\r\n#endif\r\n#if CXIMAGE_SUPPORT_ICO\r\n\tn++; if (id == CXIMAGE_FORMAT_ICO) return n;\r\n#endif\r\n#if CXIMAGE_SUPPORT_TIF\r\n\tn++; if (id == CXIMAGE_FORMAT_TIF) return n;\r\n#endif\r\n#if CXIMAGE_SUPPORT_TGA\r\n\tn++; if (id == CXIMAGE_FORMAT_TGA) return n;\r\n#endif\r\n#if CXIMAGE_SUPPORT_PCX\r\n\tn++; if (id == CXIMAGE_FORMAT_PCX) return n;\r\n#endif\r\n#if CXIMAGE_SUPPORT_WBMP\r\n\tn++; if (id == CXIMAGE_FORMAT_WBMP) return n;\r\n#endif\r\n#if CXIMAGE_SUPPORT_WMF\r\n\tn++; if (id == CXIMAGE_FORMAT_WMF) return n;\r\n#endif\r\n#if CXIMAGE_SUPPORT_JP2\r\n\tn++; if (id == CXIMAGE_FORMAT_JP2) return n;\r\n#endif\r\n#if CXIMAGE_SUPPORT_JPC\r\n\tn++; if (id == CXIMAGE_FORMAT_JPC) return n;\r\n#endif\r\n#if CXIMAGE_SUPPORT_PGX\r\n\tn++; if (id == CXIMAGE_FORMAT_PGX) return n;\r\n#endif\r\n#if CXIMAGE_SUPPORT_PNM\r\n\tn++; if (id == CXIMAGE_FORMAT_PNM) return n;\r\n#endif\r\n#if CXIMAGE_SUPPORT_RAS\r\n\tn++; if (id == CXIMAGE_FORMAT_RAS) return n;\r\n#endif\r\n#if CXIMAGE_SUPPORT_JBG\r\n\tn++; if (id == CXIMAGE_FORMAT_JBG) return n;\r\n#endif\r\n#if CXIMAGE_SUPPORT_MNG\r\n\tn++; if (id == CXIMAGE_FORMAT_MNG) return n;\r\n#endif\r\n#if CXIMAGE_SUPPORT_SKA\r\n\tn++; if (id == CXIMAGE_FORMAT_SKA) return n;\r\n#endif\r\n#if CXIMAGE_SUPPORT_RAW\r\n\tn++; if (id == CXIMAGE_FORMAT_RAW) return n;\r\n#endif\r\n#if CXIMAGE_SUPPORT_PSD\r\n\tn++; if (id == CXIMAGE_FORMAT_PSD) return n;\r\n#endif\r\n\r\n\treturn 0;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n/**\r\n * \\return current frame delay in milliseconds. Only for GIF and MNG formats.\r\n */\r\nuint32_t CxImage::GetFrameDelay() const\r\n{\r\n\treturn info.dwFrameDelay;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n/**\r\n * Sets current frame delay. Only for GIF format.\r\n * \\param d = delay in milliseconds\r\n */\r\nvoid CxImage::SetFrameDelay(uint32_t d)\r\n{\r\n\tinfo.dwFrameDelay=d;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\nvoid CxImage::GetOffset(int32_t *x,int32_t *y)\r\n{\r\n\t*x=info.xOffset;\r\n\t*y=info.yOffset;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\nvoid CxImage::SetOffset(int32_t x,int32_t y)\r\n{\r\n\tinfo.xOffset=x;\r\n\tinfo.yOffset=y;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n/**\r\n * \\sa SetJpegQuality, GetJpegQualityF\r\n * \\author [DP]; changes [Stefan Sch\u044crmans]\r\n */\r\nuint8_t CxImage::GetJpegQuality() const\r\n{\r\n\treturn (uint8_t)(info.fQuality + 0.5f);\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n/**\r\n * \\sa SetJpegQuality, GetJpegQuality\r\n * \\author [Stefan Sch\u044crmans]\r\n */\r\nfloat CxImage::GetJpegQualityF() const\r\n{\r\n\treturn info.fQuality;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n/**\r\n * quality level for JPEG and JPEG2000\r\n * \\param q: can be from 0 to 100\r\n * \\author [DP]; changes [Stefan Sch\u044crmans]\r\n */\r\nvoid CxImage::SetJpegQuality(uint8_t q){\r\n\tinfo.fQuality = (float)q;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n/**\r\n * quality level for JPEG and JPEG2000\r\n * necessary for JPEG2000 when quality is between 0.0 and 1.0\r\n * \\param q: can be from 0.0 to 100.0\r\n * \\author [Stefan Sch\u044crmans]\r\n */\r\nvoid CxImage::SetJpegQualityF(float q){\r\n\tif (q>0) info.fQuality = q;\r\n\telse  info.fQuality = 0.0f;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n/**\r\n * \\sa SetJpegScale\r\n */\r\nuint8_t CxImage::GetJpegScale() const\r\n{\r\n\treturn info.nJpegScale;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n/**\r\n * scaling down during JPEG decoding valid numbers are 1, 2, 4, 8\r\n * \\author [ignacio]\r\n */\r\nvoid CxImage::SetJpegScale(uint8_t q){\r\n\tinfo.nJpegScale = q;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n/**\r\n * Used to monitor the slow loops.\r\n * \\return value is from 0 to 100.\r\n * \\sa SetProgress\r\n */\r\nint32_t CxImage::GetProgress() const\r\n{\r\n\treturn info.nProgress;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n/**\r\n * \\return the escape code.\r\n * \\sa SetEscape\r\n */\r\nint32_t CxImage::GetEscape() const\r\n{\r\n\treturn info.nEscape;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n/**\r\n * Forces the value of the internal progress variable.\r\n * \\param p should be from 0 to 100.\r\n * \\sa GetProgress\r\n */\r\nvoid CxImage::SetProgress(int32_t p)\r\n{\r\n\tinfo.nProgress = p;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n/**\r\n * Used to quit the slow loops or the codecs.\r\n * - SetEscape(-1) before Decode forces the function to exit, right after  \r\n *   the image width and height are available ( for bmp, jpg, gif, tif )\r\n */\r\nvoid CxImage::SetEscape(int32_t i)\r\n{\r\n\tinfo.nEscape = i;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n/**\r\n * Checks if the image is correctly initializated.\r\n */\r\nbool CxImage::IsValid() const\r\n{\r\n\treturn pDib!=0;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n/**\r\n * True if the image is enabled for painting.\r\n */\r\nbool CxImage::IsEnabled() const\r\n{\r\n\treturn info.bEnabled;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n/**\r\n * Enables/disables the image.\r\n */\r\nvoid CxImage::Enable(bool enable)\r\n{\r\n\tinfo.bEnabled=enable;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n/**\r\n * This function must be used after a Decode() / Load() call.\r\n * Use the sequence SetFrame(-1); Load(...); GetNumFrames();\r\n * to get the number of images without loading the first image.\r\n * \\return the number of images in the file.\r\n */\r\nint32_t CxImage::GetNumFrames() const\r\n{\r\n\treturn info.nNumFrames;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n/**\r\n * \\return the current selected image (zero-based index).\r\n */\r\nint32_t CxImage::GetFrame() const\r\n{\r\n\treturn info.nFrame;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n/**\r\n * Sets the image number that the next Decode() / Load() call will load\r\n */\r\nvoid CxImage::SetFrame(int32_t nFrame){\r\n\tinfo.nFrame=nFrame;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n/**\r\n * Sets the method for drawing the frame related to others\r\n * \\sa GetDisposalMethod\r\n */\r\nvoid CxImage::SetDisposalMethod(uint8_t dm)\r\n{\tinfo.dispmeth=dm; }\r\n////////////////////////////////////////////////////////////////////////////////\r\n/**\r\n * Gets the method for drawing the frame related to others\r\n * Values :    0 -   No disposal specified. The decoder is\r\n *                   not required to take any action.\r\n *             1 -   Do not dispose. The graphic is to be left\r\n *                   in place.\r\n *             2 -   Restore to background color. The area used by the\r\n *                   graphic must be restored to the background color.\r\n *             3 -   Restore to previous. The decoder is required to\r\n *                   restore the area overwritten by the graphic with\r\n *                   what was there prior to rendering the graphic.\r\n *             4-7 -    To be defined.\r\n */\r\nuint8_t CxImage::GetDisposalMethod() const\r\n{\treturn info.dispmeth; }\r\n////////////////////////////////////////////////////////////////////////////////\r\nbool CxImage::GetRetreiveAllFrames() const\r\n{\treturn info.bGetAllFrames; }\r\n////////////////////////////////////////////////////////////////////////////////\r\nvoid CxImage::SetRetreiveAllFrames(bool flag)\r\n{\tinfo.bGetAllFrames = flag; }\r\n////////////////////////////////////////////////////////////////////////////////\r\nCxImage * CxImage::GetFrame(int32_t nFrame) const\r\n{\r\n\tif ( ppFrames == NULL) return NULL;\r\n\tif ( info.nNumFrames == 0) return NULL;\r\n\tif ( nFrame >= info.nNumFrames ) return NULL;\r\n\tif ( nFrame < 0) nFrame = info.nNumFrames - 1;\r\n\treturn ppFrames[nFrame];\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\nint16_t CxImage::m_ntohs(const int16_t word)\r\n{\r\n\tif (info.bLittleEndianHost) return word;\r\n\treturn ( (word & 0xff) << 8 ) | ( (word >> 8) & 0xff );\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\nint32_t CxImage::m_ntohl(const int32_t dword)\r\n{\r\n\tif (info.bLittleEndianHost) return dword;\r\n\treturn  ((dword & 0xff) << 24 ) | ((dword & 0xff00) << 8 ) |\r\n\t\t\t((dword >> 8) & 0xff00) | ((dword >> 24) & 0xff);\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\nvoid CxImage::bihtoh(BITMAPINFOHEADER* bih)\r\n{\r\n\tbih->biSize = m_ntohl(bih->biSize);\r\n\tbih->biWidth = m_ntohl(bih->biWidth);\r\n\tbih->biHeight = m_ntohl(bih->biHeight);\r\n\tbih->biPlanes = m_ntohs(bih->biPlanes);\r\n\tbih->biBitCount = m_ntohs(bih->biBitCount);\r\n\tbih->biCompression = m_ntohl(bih->biCompression);\r\n\tbih->biSizeImage = m_ntohl(bih->biSizeImage);\r\n\tbih->biXPelsPerMeter = m_ntohl(bih->biXPelsPerMeter);\r\n\tbih->biYPelsPerMeter = m_ntohl(bih->biYPelsPerMeter);\r\n\tbih->biClrUsed = m_ntohl(bih->biClrUsed);\r\n\tbih->biClrImportant = m_ntohl(bih->biClrImportant);\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n/**\r\n * Returns the last reported error.\r\n */\r\nconst char* CxImage::GetLastError()\r\n{\r\n\treturn info.szLastError;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\nuint32_t CxImage::DumpSize()\r\n{\r\n\tuint32_t n;\r\n\tn = sizeof(BITMAPINFOHEADER) + sizeof(CXIMAGEINFO) + GetSize();\r\n\r\n#if CXIMAGE_SUPPORT_ALPHA\r\n\tif (pAlpha){\r\n\t\tn += 1 + head.biWidth * head.biHeight;\r\n\t} else n++;\r\n#endif\r\n\r\n#if CXIMAGE_SUPPORT_SELECTION\r\n\tif (pSelection){\r\n\t\tn += 1 + head.biWidth * head.biHeight;\r\n\t} else n++;\r\n#endif\r\n\r\n#if CXIMAGE_SUPPORT_LAYERS\r\n\tif (ppLayers){\r\n\t\tfor (int32_t m=0; m<GetNumLayers(); m++){\r\n\t\t\tif (GetLayer(m)){\r\n\t\t\t\tn += 1 + GetLayer(m)->DumpSize();\r\n\t\t\t}\r\n\t\t}\r\n\t} else n++;\r\n#endif\r\n\r\n\tif (ppFrames){\r\n\t\tfor (int32_t m=0; m<GetNumFrames(); m++){\r\n\t\t\tif (GetFrame(m)){\r\n\t\t\t\tn += 1 + GetFrame(m)->DumpSize();\r\n\t\t\t}\r\n\t\t}\r\n\t} else n++;\r\n\r\n\treturn n;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\nuint32_t CxImage::Dump(uint8_t * dst)\r\n{\r\n\tif (!dst) return 0;\r\n\r\n\tmemcpy(dst,&head,sizeof(BITMAPINFOHEADER));\r\n\tdst += sizeof(BITMAPINFOHEADER);\r\n\r\n\tmemcpy(dst,&info,sizeof(CXIMAGEINFO));\r\n\tdst += sizeof(CXIMAGEINFO);\r\n\r\n\tmemcpy(dst,pDib,GetSize());\r\n\tdst += GetSize();\r\n\r\n#if CXIMAGE_SUPPORT_ALPHA\r\n\tif (pAlpha){\r\n\t\tmemset(dst++, 1, 1);\r\n\t\tmemcpy(dst,pAlpha,head.biWidth * head.biHeight);\r\n\t\tdst += head.biWidth * head.biHeight;\r\n\t} else {\r\n\t\tmemset(dst++, 0, 1);\r\n\t}\r\n#endif\r\n\r\n#if CXIMAGE_SUPPORT_SELECTION\r\n\tif (pSelection){\r\n\t\tmemset(dst++, 1, 1);\r\n\t\tmemcpy(dst,pSelection,head.biWidth * head.biHeight);\r\n\t\tdst += head.biWidth * head.biHeight;\r\n\t} else {\r\n\t\tmemset(dst++, 0, 1);\r\n\t}\r\n#endif\r\n\r\n#if CXIMAGE_SUPPORT_LAYERS\r\n\tif (ppLayers){\r\n\t\tmemset(dst++, 1, 1);\r\n\t\tfor (int32_t m=0; m<GetNumLayers(); m++){\r\n\t\t\tif (GetLayer(m)){\r\n\t\t\t\tdst += GetLayer(m)->Dump(dst);\r\n\t\t\t}\r\n\t\t}\r\n\t} else {\r\n\t\tmemset(dst++, 0, 1);\r\n\t}\r\n#endif\r\n\r\n\tif (ppFrames){\r\n\t\tmemset(dst++, 1, 1);\r\n\t\tfor (int32_t m=0; m<GetNumFrames(); m++){\r\n\t\t\tif (GetFrame(m)){\r\n\t\t\t\tdst += GetFrame(m)->Dump(dst);\r\n\t\t\t}\r\n\t\t}\r\n\t} else {\r\n\t\tmemset(dst++, 0, 1);\r\n\t}\r\n\r\n\treturn DumpSize();\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\nuint32_t CxImage::UnDump(const uint8_t * src)\r\n{\r\n\tif (!src)\r\n\t\treturn 0;\r\n\tif (!Destroy())\r\n\t\treturn 0;\r\n\tif (!DestroyFrames())\r\n\t\treturn 0;\r\n\r\n\tuint32_t n = 0;\r\n\r\n\tmemcpy(&head,src,sizeof(BITMAPINFOHEADER));\r\n\tn += sizeof(BITMAPINFOHEADER);\r\n\r\n\tmemcpy(&info,&src[n],sizeof(CXIMAGEINFO));\r\n\tn += sizeof(CXIMAGEINFO);\r\n\r\n\tif (!Create(head.biWidth, head.biHeight, head.biBitCount, info.dwType))\r\n\t\treturn 0;\r\n\r\n\tmemcpy(pDib,&src[n],GetSize());\r\n\tn += GetSize();\r\n\r\n#if CXIMAGE_SUPPORT_ALPHA\r\n\tif (src[n++]){\r\n\t\tif (AlphaCreate()){\r\n\t\t\tmemcpy(pAlpha, &src[n], head.biWidth * head.biHeight);\r\n\t\t}\r\n\t\tn += head.biWidth * head.biHeight;\r\n\t}\r\n#endif\r\n\r\n#if CXIMAGE_SUPPORT_SELECTION\r\n\tif (src[n++]){\r\n\t\tRECT box = info.rSelectionBox;\r\n\t\tif (SelectionCreate()){\r\n\t\t\tinfo.rSelectionBox = box;\r\n\t\t\tmemcpy(pSelection, &src[n], head.biWidth * head.biHeight);\r\n\t\t}\r\n\t\tn += head.biWidth * head.biHeight;\r\n\t}\r\n#endif\r\n\r\n#if CXIMAGE_SUPPORT_LAYERS\r\n\tif (src[n++]){\r\n\t\tppLayers = new CxImage*[info.nNumLayers];\r\n\t\tfor (int32_t m=0; m<GetNumLayers(); m++){\r\n\t\t\tppLayers[m] = new CxImage();\r\n\t\t\tn += ppLayers[m]->UnDump(&src[n]);\r\n\t\t}\r\n\t}\r\n#endif\r\n\r\n\tif (src[n++]){\r\n\t\tppFrames = new CxImage*[info.nNumFrames];\r\n\t\tfor (int32_t m=0; m<GetNumFrames(); m++){\r\n\t\t\tppFrames[m] = new CxImage();\r\n\t\t\tn += ppFrames[m]->UnDump(&src[n]);\r\n\t\t}\r\n\t}\r\n\r\n\treturn n;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n/**\r\n * \\return A.BBCCCDDDD\r\n *  - A = main version\r\n *  - BB = main revision\r\n *  - CCC = minor revision (letter)\r\n *  - DDDD = experimental revision\r\n */\r\nconst float CxImage::GetVersionNumber()\r\n{\r\n\treturn 7.000020000f;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\nconst TCHAR* CxImage::GetVersion()\r\n{\r\n\tstatic const TCHAR CxImageVersion[] = _T(\"CxImage 7.0.2\");\r\n\treturn (CxImageVersion);\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n", "\ufeff/*\r\n * File:\tximapcx.cpp\r\n * Purpose:\tPlatform Independent PCX Image Class Loader and Writer\r\n * 05/Jan/2002 Davide Pizzolato - www.xdp.it\r\n * CxImage version 7.0.2 07/Feb/2011\r\n *\r\n * based on ppmtopcx.c - convert a portable pixmap to PCX\r\n * Copyright (C) 1994 by Ingo Wilken (Ingo.Wilken@informatik.uni-oldenburg.de)\r\n * based on ppmtopcx.c by Michael Davidson\r\n */\r\n\r\n#include \"ximapcx.h\"\r\n\r\n#if CXIMAGE_SUPPORT_PCX\r\n\r\n#include \"xmemfile.h\"\r\n\r\n#define PCX_MAGIC 0X0A  // PCX magic number\r\n#define PCX_256_COLORS 0X0C  // magic number for 256 colors\r\n#define PCX_HDR_SIZE 128  // size of PCX header\r\n#define PCX_MAXCOLORS 256\r\n#define PCX_MAXPLANES 4\r\n#define PCX_MAXVAL 255\r\n\r\n////////////////////////////////////////////////////////////////////////////////\r\n#if CXIMAGE_SUPPORT_DECODE\r\n////////////////////////////////////////////////////////////////////////////////\r\nbool CxImagePCX::Decode(CxFile *hFile)\r\n{\r\n\tif (hFile == NULL) return false;\r\n\r\n\tPCXHEADER pcxHeader;\r\n\tint32_t i, x, y, y2, nbytes, count, Height, Width;\r\n\tuint8_t c, ColorMap[PCX_MAXCOLORS][3];\r\n\tuint8_t *pcximage = NULL, *lpHead1 = NULL, *lpHead2 = NULL;\r\n\tuint8_t *pcxplanes, *pcxpixels;\r\n\r\n  cx_try\r\n  {\r\n\tif (hFile->Read(&pcxHeader,sizeof(PCXHEADER),1)==0) cx_throw(\"Can't read PCX image\");\r\n\r\n\tPCX_toh(&pcxHeader);\r\n\r\n    if (pcxHeader.Manufacturer != PCX_MAGIC) cx_throw(\"Error: Not a PCX file\");\r\n    // Check for PCX run length encoding\r\n    if (pcxHeader.Encoding != 1) cx_throw(\"PCX file has unknown encoding scheme\");\r\n \r\n    Width = (pcxHeader.Xmax - pcxHeader.Xmin) + 1;\r\n    Height = (pcxHeader.Ymax - pcxHeader.Ymin) + 1;\r\n\tinfo.xDPI = pcxHeader.Hres;\r\n\tinfo.yDPI = pcxHeader.Vres;\r\n\r\n    if (Width <= 0 || Height <= 0)\r\n        cx_throw(\"Error: Not a PCX file\");\r\n\r\n\tif (info.nEscape == -1){\r\n\t\thead.biWidth = Width;\r\n\t\thead.biHeight= Height;\r\n\t\tinfo.dwType = CXIMAGE_FORMAT_PCX;\r\n\t\treturn true;\r\n\t}\r\n\r\n    // Check that we can handle this image format\r\n    if (pcxHeader.ColorPlanes > 4)\r\n\t\tcx_throw(\"Can't handle image with more than 4 planes\");\r\n\r\n\t// Create the image\r\n\tif (pcxHeader.ColorPlanes >= 3 && pcxHeader.BitsPerPixel == 8){\r\n\t\tCreate (Width, Height, 24, CXIMAGE_FORMAT_PCX);\r\n#if CXIMAGE_SUPPORT_ALPHA\r\n\t\tif (pcxHeader.ColorPlanes==4) AlphaCreate();\r\n#endif //CXIMAGE_SUPPORT_ALPHA\r\n\t} else if (pcxHeader.ColorPlanes == 4 && pcxHeader.BitsPerPixel == 1)\r\n\t\tCreate (Width, Height, 4, CXIMAGE_FORMAT_PCX);\r\n\telse\r\n\t\tCreate (Width, Height, pcxHeader.BitsPerPixel, CXIMAGE_FORMAT_PCX);\r\n\r\n\tif (info.nEscape) cx_throw(\"Cancelled\"); // <vho> - cancel decoding\r\n\r\n\t//Read the image and check if it's ok\r\n    nbytes = pcxHeader.BytesPerLine * pcxHeader.ColorPlanes * Height;\r\n    uint32_t pcximage_size = nbytes;\r\n    lpHead1 = pcximage = (uint8_t*)malloc(nbytes);\r\n    if (!pcximage)\r\n        cx_throw(\"Cancelled\");\r\n\r\n    while (nbytes > 0){\r\n\t\tif (hFile == NULL || hFile->Eof()) cx_throw(\"corrupted PCX\");\r\n\r\n\t\thFile->Read(&c,1,1);\r\n\t\tif ((c & 0XC0) != 0XC0){ // Repeated group\r\n\t\t\t*pcximage++ = c;\r\n\t\t\t--nbytes;\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\tcount = c & 0X3F; // extract count\r\n\t\thFile->Read(&c,1,1);\r\n\t\tif (count > nbytes) cx_throw(\"repeat count spans end of image\");\r\n\r\n\t\tnbytes -= count;\r\n\t\twhile (--count >=0) *pcximage++ = c;\r\n\t}\r\n    pcximage = lpHead1;\r\n\r\n\t//store the palette\r\n    for (i = 0; i < 16; i++){\r\n\t\tColorMap[i][0] = pcxHeader.ColorMap[i][0];\r\n\t\tColorMap[i][1] = pcxHeader.ColorMap[i][1];\r\n\t\tColorMap[i][2] = pcxHeader.ColorMap[i][2];\r\n\t}\r\n    if (pcxHeader.BitsPerPixel == 8 && pcxHeader.ColorPlanes == 1){\r\n\t\thFile->Read(&c,1,1);\r\n\t\tif (c != PCX_256_COLORS) cx_throw(\"bad color map signature\");\r\n\t\t\r\n\t\tfor (i = 0; i < PCX_MAXCOLORS; i++){\r\n\t\t\thFile->Read(&ColorMap[i][0],1,1);\r\n\t\t\thFile->Read(&ColorMap[i][1],1,1);\r\n\t\t\thFile->Read(&ColorMap[i][2],1,1);\r\n\t\t}\r\n\t}\r\n    if (pcxHeader.BitsPerPixel == 1 && pcxHeader.ColorPlanes == 1){\r\n\t\tColorMap[0][0] = ColorMap[0][1] = ColorMap[0][2] = 0;\r\n\t\tColorMap[1][0] = ColorMap[1][1] = ColorMap[1][2] = 255;\r\n\t}\r\n\r\n\tfor (uint32_t idx=0; idx<head.biClrUsed; idx++) SetPaletteColor((uint8_t)idx,ColorMap[idx][0],ColorMap[idx][1],ColorMap[idx][2]);\r\n\r\n    lpHead2 = pcxpixels = (uint8_t *)malloc(Width + pcxHeader.BytesPerLine * 8);\r\n    if (!pcxpixels)\r\n        cx_throw(\"Cancelled\");\r\n\r\n    // Convert the image\r\n    for (y = 0; y < Height; y++){\r\n\r\n\t\tif (info.nEscape) cx_throw(\"Cancelled\"); // <vho> - cancel decoding\r\n\r\n\t\ty2=Height-1-y;\r\n\t\tpcxpixels = lpHead2;\r\n\t\tpcxplanes = pcximage + (y * pcxHeader.BytesPerLine * pcxHeader.ColorPlanes);\r\n\r\n\t\tif (pcxHeader.ColorPlanes == 3 && pcxHeader.BitsPerPixel == 8){\r\n\t\t\t// Deal with 24 bit color image\r\n\t\t\tfor (x = 0; x < Width; x++){\r\n\t\t\t\tSetPixelColor(x,y2,RGB(pcxplanes[x],pcxplanes[pcxHeader.BytesPerLine + x],pcxplanes[2*pcxHeader.BytesPerLine + x]));\r\n\t\t\t}\r\n\t\t\tcontinue;\r\n#if CXIMAGE_SUPPORT_ALPHA\r\n\t\t} else if (pcxHeader.ColorPlanes == 4 && pcxHeader.BitsPerPixel == 8){\r\n\t\t\tfor (x = 0; x < Width; x++){\r\n\t\t\t\tSetPixelColor(x,y2,RGB(pcxplanes[x],pcxplanes[pcxHeader.BytesPerLine + x],pcxplanes[2*pcxHeader.BytesPerLine + x]));\r\n\r\n                uint32_t alphaIndex = 3*pcxHeader.BytesPerLine + x;\r\n\r\n                if (alphaIndex < pcximage_size)\r\n                    AlphaSet(x,y2,pcxplanes[alphaIndex]);\r\n\t\t\t}\r\n\t\t\tcontinue;\r\n#endif //CXIMAGE_SUPPORT_ALPHA\r\n\t\t} else if (pcxHeader.ColorPlanes == 1) {\r\n\t\t\tif (!PCX_UnpackPixels(pcxpixels, pcxplanes, pcxHeader.BytesPerLine, pcxHeader.ColorPlanes, pcxHeader.BitsPerPixel)){\r\n\t\t\t\tcx_throw(\"PCX_UnpackPixels: Can't handle packed pixels with more than 1 plane\");\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tif (!PCX_PlanesToPixels(pcxpixels, pcxplanes, pcxHeader.BytesPerLine, pcxHeader.ColorPlanes, pcxHeader.BitsPerPixel)){\r\n\t\t\t\tcx_throw(\"PCX_PlanesToPixels: more than 4 planes or more than 1 bit per pixel\");\r\n\t\t\t}\r\n\t\t}\r\n\t\tfor (x = 0; x < Width; x++)\tSetPixelIndex(x,y2,pcxpixels[x]);\r\n\t}\r\n\r\n  } cx_catch {\r\n\tif (strcmp(message,\"\")) strncpy(info.szLastError,message,255);\r\n\tif (lpHead1){ free(lpHead1); lpHead1 = NULL; }\r\n    if (lpHead2){ free(lpHead2); lpHead2 = NULL; }\r\n\treturn false;\r\n  }\r\n\tif (lpHead1){ free(lpHead1); lpHead1 = NULL; }\r\n    if (lpHead2){ free(lpHead2); lpHead2 = NULL; }\r\n\treturn true;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n#endif //CXIMAGE_SUPPORT_DECODE\r\n////////////////////////////////////////////////////////////////////////////////\r\n#if CXIMAGE_SUPPORT_ENCODE\r\n////////////////////////////////////////////////////////////////////////////////\r\nbool CxImagePCX::Encode(CxFile * hFile)\r\n{\r\n\tif (EncodeSafeCheck(hFile)) return false;\r\n\r\n  cx_try\r\n  {\r\n\tPCXHEADER pcxHeader;\r\n\tmemset(&pcxHeader,0,sizeof(pcxHeader));\r\n\tpcxHeader.Manufacturer = PCX_MAGIC;\r\n\tpcxHeader.Version = 5;\r\n\tpcxHeader.Encoding = 1;\r\n\tpcxHeader.Xmin = 0;\r\n\tpcxHeader.Ymin = 0;\r\n\tpcxHeader.Xmax = (uint16_t)head.biWidth-1;\r\n\tpcxHeader.Ymax = (uint16_t)head.biHeight-1;\r\n\tpcxHeader.Hres = (uint16_t)info.xDPI;\r\n\tpcxHeader.Vres = (uint16_t)info.yDPI;\r\n\tpcxHeader.Reserved = 0;\r\n\tpcxHeader.PaletteType = head.biClrUsed==0;\r\n\r\n\tswitch(head.biBitCount){\r\n\tcase 24:\r\n\tcase 8:\r\n\t\t{\r\n\t\t\tpcxHeader.BitsPerPixel = 8;\r\n\t\t\tpcxHeader.ColorPlanes = head.biClrUsed==0 ? 3 : 1;\r\n#if CXIMAGE_SUPPORT_ALPHA\r\n\t\t\tif (AlphaIsValid() && head.biClrUsed==0) pcxHeader.ColorPlanes =4;\r\n#endif //CXIMAGE_SUPPORT_ALPHA\r\n\t\t\tpcxHeader.BytesPerLine = (uint16_t)head.biWidth;\r\n\t\t\tbreak;\r\n\t\t}\r\n\tdefault: //(4 1)\r\n\t\tpcxHeader.BitsPerPixel = 1;\r\n\t\tpcxHeader.ColorPlanes = head.biClrUsed==16 ? 4 : 1;\r\n\t\tpcxHeader.BytesPerLine = (uint16_t)((head.biWidth * pcxHeader.BitsPerPixel + 7)>>3);\r\n\t}\r\n\r\n    if (pcxHeader.BitsPerPixel == 1 && pcxHeader.ColorPlanes == 1){\r\n\t\tpcxHeader.ColorMap[0][0] = pcxHeader.ColorMap[0][1] = pcxHeader.ColorMap[0][2] = 0;\r\n\t\tpcxHeader.ColorMap[1][0] = pcxHeader.ColorMap[1][1] = pcxHeader.ColorMap[1][2] = 255;\r\n\t}\r\n\tif (pcxHeader.BitsPerPixel == 1 && pcxHeader.ColorPlanes == 4){\r\n\t\tRGBQUAD c;\r\n\t\tfor (int32_t i = 0; i < 16; i++){\r\n\t\t\tc=GetPaletteColor(i);\r\n\t\t\tpcxHeader.ColorMap[i][0] = c.rgbRed;\r\n\t\t\tpcxHeader.ColorMap[i][1] = c.rgbGreen;\r\n\t\t\tpcxHeader.ColorMap[i][2] = c.rgbBlue;\r\n\t\t}\r\n\t}\r\n\r\n\tpcxHeader.BytesPerLine = (pcxHeader.BytesPerLine + 1)&(~1);\r\n\r\n\tPCX_toh(&pcxHeader);\r\n\tif (hFile->Write(&pcxHeader, sizeof(pcxHeader), 1) == 0 )\r\n\t   cx_throw(\"cannot write PCX header\");\r\n\tPCX_toh(&pcxHeader);\r\n\r\n\tCxMemFile buffer;\r\n\tbuffer.Open();\r\n\r\n\tuint8_t c,n;\r\n\tint32_t x,y;\r\n\tif (head.biClrUsed==0){\r\n\t\tfor (y = head.biHeight-1; y >=0 ; y--){\r\n\t\t\tfor (int32_t p=0; p<pcxHeader.ColorPlanes; p++){\r\n\t\t\t\tc=n=0;\r\n\t\t\t\tfor (x = 0; x<head.biWidth; x++){\r\n\t\t\t\t\tif (p==0)\r\n\t\t\t\t\t\tPCX_PackPixels(BlindGetPixelColor(x,y).rgbRed,c,n,buffer);\r\n\t\t\t\t\telse if (p==1)\r\n\t\t\t\t\t\tPCX_PackPixels(BlindGetPixelColor(x,y).rgbGreen,c,n,buffer);\r\n\t\t\t\t\telse if (p==2)\r\n\t\t\t\t\t\tPCX_PackPixels(BlindGetPixelColor(x,y).rgbBlue,c,n,buffer);\r\n#if CXIMAGE_SUPPORT_ALPHA\r\n\t\t\t\t\telse if (p==3)\r\n\t\t\t\t\t\tPCX_PackPixels(BlindAlphaGet(x,y),c,n,buffer);\r\n#endif //CXIMAGE_SUPPORT_ALPHA\r\n\t\t\t\t}\r\n\t\t\t\tPCX_PackPixels(-1-(head.biWidth&0x1),c,n,buffer);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\thFile->Write(buffer.GetBuffer(false),buffer.Tell(),1);\r\n\r\n\t} else if (head.biBitCount==8) {\r\n\r\n\t\tfor (y = head.biHeight-1; y >=0 ; y--){\r\n\t\t\tc=n=0;\r\n\t\t\tfor (x = 0; x<head.biWidth; x++){\r\n\t\t\t\tPCX_PackPixels(GetPixelIndex(x,y),c,n,buffer);\r\n\t\t\t}\r\n\t\t\tPCX_PackPixels(-1-(head.biWidth&0x1),c,n,buffer);\r\n\t\t}\r\n\r\n\t\thFile->Write(buffer.GetBuffer(false),buffer.Tell(),1);\r\n\r\n\t\tif (head.biBitCount == 8){\r\n\t\t\thFile->PutC(0x0C);\r\n\t\t\tuint8_t* pal = (uint8_t*)malloc(768);\r\n\t\t\tRGBQUAD c;\r\n\t\t\tfor (int32_t i=0;i<256;i++){\r\n\t\t\t\tc=GetPaletteColor(i);\r\n\t\t\t\tpal[3*i+0] = c.rgbRed;\r\n\t\t\t\tpal[3*i+1] = c.rgbGreen;\r\n\t\t\t\tpal[3*i+2] = c.rgbBlue;\r\n\t\t\t}\r\n\t\t\thFile->Write(pal,768,1);\r\n\t\t\tfree(pal);\r\n\t\t}\r\n\t} else { //(head.biBitCount==4) || (head.biBitCount==1)\r\n\r\n\t\tRGBQUAD *rgb = GetPalette();\r\n\t\tbool binvert = false;\r\n\t\tif (CompareColors(&rgb[0],&rgb[1])>0) binvert=(head.biBitCount==1);\r\n\t\t\r\n\t\tuint8_t* plane = (uint8_t*)malloc(pcxHeader.BytesPerLine);\r\n\t\tuint8_t* raw = (uint8_t*)malloc(head.biWidth);\r\n\r\n\t\tfor(y = head.biHeight-1; y >=0 ; y--) {\r\n\r\n\t\t\tfor( x = 0; x < head.biWidth; x++)\traw[x] = (uint8_t)GetPixelIndex(x,y);\r\n\r\n\t\t\tif (binvert) for( x = 0; x < head.biWidth; x++)\traw[x] = 1-raw[x];\r\n\r\n\t\t\tfor( x = 0; x < pcxHeader.ColorPlanes; x++ ) {\r\n\t\t\t\tPCX_PixelsToPlanes(raw, head.biWidth, plane, x);\r\n\t\t\t\tPCX_PackPlanes(plane, pcxHeader.BytesPerLine, buffer);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfree(plane);\r\n\t\tfree(raw);\r\n\r\n\t\thFile->Write(buffer.GetBuffer(false),buffer.Tell(),1);\r\n\r\n\t}\r\n\r\n  } cx_catch {\r\n\tif (strcmp(message,\"\")) strncpy(info.szLastError,message,255);\r\n\treturn false;\r\n  }\r\n    return true;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n#endif // CXIMAGE_SUPPORT_ENCODE\r\n////////////////////////////////////////////////////////////////////////////////\r\n// Convert multi-plane format into 1 pixel per byte\r\n// from unpacked file data bitplanes[] into pixel row pixels[]\r\n// image Height rows, with each row having planes image planes each\r\n// bytesperline bytes\r\nbool CxImagePCX::PCX_PlanesToPixels(uint8_t * pixels, uint8_t * bitplanes, int16_t bytesperline, int16_t planes, int16_t bitsperpixel)\r\n{\r\n\tint32_t i, j, npixels;\r\n\tuint8_t * p;\r\n\tif (planes > 4) return false;\r\n\tif (bitsperpixel != 1) return false;\r\n\r\n\t// Clear the pixel buffer\r\n\tnpixels = (bytesperline * 8) / bitsperpixel;\r\n\tp = pixels;\r\n\twhile (--npixels >= 0) *p++ = 0;\r\n\r\n\t// Do the format conversion\r\n\tfor (i = 0; i < planes; i++){\r\n\t\tint32_t pixbit, bits, mask;\r\n\t\tp = pixels;\r\n\t\tpixbit = (1 << i);  // pixel bit for this plane\r\n\t\tfor (j = 0; j < bytesperline; j++){\r\n\t\t\tbits = *bitplanes++;\r\n\t\t\tfor (mask = 0X80; mask != 0; mask >>= 1, p++)\r\n\t\t\t\tif (bits & mask) *p |= pixbit;\r\n\t\t}\r\n\t}\r\n\treturn true;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n// convert packed pixel format into 1 pixel per byte\r\n// from unpacked file data bitplanes[] into pixel row pixels[]\r\n// image Height rows, with each row having planes image planes each\r\n// bytesperline bytes\r\nbool CxImagePCX::PCX_UnpackPixels(uint8_t * pixels, uint8_t * bitplanes, int16_t bytesperline, int16_t planes, int16_t bitsperpixel)\r\n{\r\n\tregister int32_t bits;\r\n\tif (planes != 1) return false;\r\n\t\r\n\tif (bitsperpixel == 8){  // 8 bits/pixels, no unpacking needed\r\n\t\twhile (bytesperline-- > 0) *pixels++ = *bitplanes++;\r\n\t} else if (bitsperpixel == 4){  // 4 bits/pixel, two pixels per byte\r\n\t\twhile (bytesperline-- > 0){\r\n\t\t\tbits = *bitplanes++;\r\n\t\t\t*pixels++ = (uint8_t)((bits >> 4) & 0X0F);\r\n\t\t\t*pixels++ = (uint8_t)((bits) & 0X0F);\r\n\t\t}\r\n\t} else if (bitsperpixel == 2){  // 2 bits/pixel, four pixels per byte\r\n\t\twhile (bytesperline-- > 0){\r\n\t\t\tbits = *bitplanes++;\r\n\t\t\t*pixels++ = (uint8_t)((bits >> 6) & 0X03);\r\n\t\t\t*pixels++ = (uint8_t)((bits >> 4) & 0X03);\r\n\t\t\t*pixels++ = (uint8_t)((bits >> 2) & 0X03);\r\n\t\t\t*pixels++ = (uint8_t)((bits) & 0X03);\r\n\t\t}\r\n\t} else if (bitsperpixel == 1){  // 1 bits/pixel, 8 pixels per byte\r\n\t\twhile (bytesperline-- > 0){\r\n\t\t\tbits = *bitplanes++;\r\n\t\t\t*pixels++ = ((bits & 0X80) != 0);\r\n\t\t\t*pixels++ = ((bits & 0X40) != 0);\r\n\t\t\t*pixels++ = ((bits & 0X20) != 0);\r\n\t\t\t*pixels++ = ((bits & 0X10) != 0);\r\n\t\t\t*pixels++ = ((bits & 0X08) != 0);\r\n\t\t\t*pixels++ = ((bits & 0X04) != 0);\r\n\t\t\t*pixels++ = ((bits & 0X02) != 0);\r\n\t\t\t*pixels++ = ((bits & 0X01) != 0);\r\n\t\t}\r\n\t}\r\n\treturn true;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n/* PCX_PackPixels(const int32_t p,uint8_t &c, uint8_t &n, int32_t &l, CxFile &f)\r\n * p = current pixel (-1 ends the line -2 ends odd line)\r\n * c = previous pixel\r\n * n = number of consecutive pixels\r\n */\r\nvoid CxImagePCX::PCX_PackPixels(const int32_t p,uint8_t &c, uint8_t &n, CxFile &f)\r\n{\r\n\tif (p!=c && n){\r\n\t\tif (n==1 && c<0xC0){\r\n\t\t\tf.PutC(c);\r\n\t\t} else {\r\n\t\t\tf.PutC(0xC0|n);\r\n\t\t\tf.PutC(c);\r\n\t\t}\r\n\t\tn=0;\r\n\t}\r\n\tif (n==0x3F) {\r\n\t\tf.PutC(0xFF);\r\n\t\tf.PutC(c);\r\n\t\tn=0;\r\n\t}\r\n\tif (p==-2) f.PutC(0);\r\n\tc=(uint8_t)p;\r\n\tn++;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\nvoid CxImagePCX::PCX_PackPlanes(uint8_t* buff, const int32_t size, CxFile &f)\r\n{\r\n    uint8_t *start,*end;\r\n    uint8_t c, previous, count;\r\n\r\n\tstart = buff;\r\n    end = buff + size;\r\n    previous = *start++;\r\n    count    = 1;\r\n\r\n    while (start < end) {\r\n        c = *start++;\r\n        if (c == previous && count < 63) {\r\n            ++count;\r\n            continue;\r\n        }\r\n\r\n        if (count > 1 || (previous & 0xc0) == 0xc0) {\r\n            f.PutC( count | 0xc0 );\r\n        }\r\n        f.PutC(previous);\r\n        previous = c;\r\n        count   = 1;\r\n    }\r\n\r\n    if (count > 1 || (previous & 0xc0) == 0xc0) {\r\n        count |= 0xc0;\r\n        f.PutC(count);\r\n    }\r\n    f.PutC(previous);\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\nvoid CxImagePCX::PCX_PixelsToPlanes(uint8_t* raw, int32_t width, uint8_t* buf, int32_t plane)\r\n{\r\n    int32_t cbit, x, mask;\r\n    uint8_t *cp = buf-1;\r\n\r\n    mask = 1 << plane;\r\n    cbit = -1;\r\n    for( x = 0; x < width; x++ ) {\r\n        if( cbit < 0 ) {\r\n            cbit = 7;\r\n            *++cp = 0;\r\n        }\r\n        if( raw[x] & mask )\r\n            *cp |= (1<<cbit);\r\n        --cbit;\r\n    }\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\nvoid CxImagePCX::PCX_toh(PCXHEADER* p)\r\n{\r\n\tp->Xmin = m_ntohs(p->Xmin);\r\n\tp->Ymin = m_ntohs(p->Ymin);\r\n\tp->Xmax = m_ntohs(p->Xmax);\r\n\tp->Ymax = m_ntohs(p->Ymax);\r\n\tp->Hres = m_ntohs(p->Hres);\r\n\tp->Vres = m_ntohs(p->Vres);\r\n\tp->BytesPerLine = m_ntohs(p->BytesPerLine);\r\n\tp->PaletteType = m_ntohs(p->PaletteType);\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n#endif // CXIMAGE_SUPPORT_PCX\r\n", "\ufeff/*\r\n * File:\tximatif.cpp\r\n * Purpose:\tPlatform Independent TIFF Image Class Loader and Writer\r\n * 07/Aug/2001 Davide Pizzolato - www.xdp.it\r\n * CxImage version 7.0.2 07/Feb/2011\r\n */\r\n\r\n#include \"ximatif.h\"\r\n\r\n#ifndef min\r\n#define min(a,b) (((a)<(b))?(a):(b))\r\n#endif\r\n#ifndef max\r\n#define max(a,b) (((a)>(b))?(a):(b))\r\n#endif\r\n\r\n\r\n#if CXIMAGE_SUPPORT_TIF\r\n\r\n#define FIX_16BPP_DARKIMG // + VK: if uncomment, dark 16bpp images are fixed\r\n\r\n#include \"../tiff/tiffio.h\"\r\n\r\n#define CVT(x)\t\t\t(((x) * 255L) / ((1L<<16)-1))\r\n#define\tSCALE(x)\t\t(((x)*((1L<<16)-1))/255)\r\n#define CalculateLine(width,bitdepth)\t(((width * bitdepth) + 7) / 8)\r\n#define CalculatePitch(line)\t(line + 3 & ~3)\r\n\r\nextern \"C\" TIFF* _TIFFOpenEx(CxFile* stream, const char* mode);\r\n\r\n////////////////////////////////////////////////////////////////////////////////\r\nCxImageTIF::~CxImageTIF()\r\n{\r\n\tif (m_tif2) TIFFClose(m_tif2);\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n#if CXIMAGE_SUPPORT_DECODE\r\n////////////////////////////////////////////////////////////////////////////////\r\nbool CxImageTIF::Decode(CxFile * hFile)\r\n{\r\n\t//Comment this line if you need more information on errors\r\n\t// TIFFSetErrorHandler(NULL);\t//<Patrick Hoffmann>\r\n\r\n\t//Open file and fill the TIFF structure\r\n\t// m_tif = TIFFOpen(imageFileName,\"rb\");\r\n\tTIFF* m_tif = _TIFFOpenEx(hFile, \"rb\");\r\n\r\n\tuint32 height=0;\r\n\tuint32 width=0;\r\n\tuint16 bitspersample=1;\r\n\tuint16 samplesperpixel=1;\r\n\tuint32 rowsperstrip=(uint32_t)-1;\r\n\tuint16 photometric=0;\r\n\tuint16 compression=1;\r\n\tuint16 orientation=ORIENTATION_TOPLEFT; //<vho>\r\n\tuint16 res_unit; //<Trifon>\r\n\tuint32 x, y;\r\n\tfloat resolution, offset;\r\n\tBOOL isRGB;\r\n\tuint8_t *bits;\t\t//pointer to source data\r\n\tuint8_t *bits2;\t//pointer to destination data\r\n\r\n  cx_try\r\n  {\r\n\t//check if it's a tiff file\r\n\tif (!m_tif)\r\n\t\tcx_throw(\"Error encountered while opening TIFF file\");\r\n\r\n\t// <Robert Abram> - 12/2002 : get NumFrames directly, instead of looping\r\n\t// info.nNumFrames=0;\r\n\t// while(TIFFSetDirectory(m_tif,(uint16)info.nNumFrames)) info.nNumFrames++;\r\n\tinfo.nNumFrames = TIFFNumberOfDirectories(m_tif);\r\n\r\n\tif (!TIFFSetDirectory(m_tif, (uint16)info.nFrame))\r\n\t\tcx_throw(\"Error: page not present in TIFF file\");\t\t\t\r\n\r\n\t//get image info\r\n\tTIFFGetField(m_tif, TIFFTAG_IMAGEWIDTH, &width);\r\n\tTIFFGetField(m_tif, TIFFTAG_IMAGELENGTH, &height);\r\n\tTIFFGetField(m_tif, TIFFTAG_SAMPLESPERPIXEL, &samplesperpixel);\r\n\tTIFFGetField(m_tif, TIFFTAG_BITSPERSAMPLE, &bitspersample);\r\n\tTIFFGetField(m_tif, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);   \r\n\tTIFFGetField(m_tif, TIFFTAG_PHOTOMETRIC, &photometric);\r\n\tTIFFGetField(m_tif, TIFFTAG_ORIENTATION, &orientation);\r\n\r\n\tif (info.nEscape == -1) {\r\n\t\t// Return output dimensions only\r\n\t\thead.biWidth = width;\r\n\t\thead.biHeight = height;\r\n\t\tinfo.dwType = CXIMAGE_FORMAT_TIF;\r\n\t\tcx_throw(\"output dimensions returned\");\r\n\t}\r\n\r\n\tTIFFGetFieldDefaulted(m_tif, TIFFTAG_RESOLUTIONUNIT, &res_unit);\r\n\tif (TIFFGetField(m_tif, TIFFTAG_XRESOLUTION, &resolution))\r\n\t{\r\n\t\tif (res_unit == RESUNIT_CENTIMETER) resolution = (float)(resolution*2.54f + 0.5f);\r\n\t\tSetXDPI((int32_t)resolution);\r\n\t}\r\n\tif (TIFFGetField(m_tif, TIFFTAG_YRESOLUTION, &resolution))\r\n\t{\r\n\t\tif (res_unit == RESUNIT_CENTIMETER) resolution = (float)(resolution*2.54f + 0.5f);\r\n\t\tSetYDPI((int32_t)resolution);\r\n\t}\r\n\r\n\tif (TIFFGetField(m_tif, TIFFTAG_XPOSITION, &offset))\tinfo.xOffset = (int32_t)offset;\r\n\tif (TIFFGetField(m_tif, TIFFTAG_YPOSITION, &offset))\tinfo.yOffset = (int32_t)offset;\r\n\r\n\thead.biClrUsed=0;\r\n\tinfo.nBkgndIndex =-1;\r\n\r\n\tif (rowsperstrip>height){\r\n\t\trowsperstrip=height;\r\n\t\tTIFFSetField(m_tif, TIFFTAG_ROWSPERSTRIP, rowsperstrip);\r\n\t}\r\n\r\n\tisRGB = /*(bitspersample >= 8) && (VK: it is possible so for RGB to have < 8 bpp!)*/\r\n\t\t(photometric == PHOTOMETRIC_RGB) ||\r\n\t\t(photometric == PHOTOMETRIC_YCBCR) ||\r\n\t\t(photometric == PHOTOMETRIC_SEPARATED) ||\r\n\t\t(photometric == PHOTOMETRIC_LOGL) ||\r\n\t\t(photometric == PHOTOMETRIC_LOGLUV);\r\n\r\n\tif (isRGB){\r\n\t\thead.biBitCount=24;\r\n\t}else{\r\n\t\tif ((photometric==PHOTOMETRIC_MINISBLACK)||(photometric==PHOTOMETRIC_MINISWHITE)||(photometric==PHOTOMETRIC_PALETTE)){\r\n\t\t\tif\t(bitspersample == 1){\r\n\t\t\t\thead.biBitCount=1;\t\t//B&W image\r\n\t\t\t\thead.biClrUsed =2;\r\n\t\t\t} else if (bitspersample == 4) {\r\n\t\t\t\thead.biBitCount=4;\t\t//16 colors gray scale\r\n\t\t\t\thead.biClrUsed =16;\r\n\t\t\t} else {\r\n\t\t\t\thead.biBitCount=8;\t\t//gray scale\r\n\t\t\t\thead.biClrUsed =256;\r\n\t\t\t}\r\n\t\t} else if (bitspersample == 4) {\r\n\t\t\thead.biBitCount=4;\t\t\t// 16 colors\r\n\t\t\thead.biClrUsed=16;\r\n\t\t} else {\r\n\t\t\thead.biBitCount=8;\t\t\t//256 colors\r\n\t\t\thead.biClrUsed=256;\r\n\t\t}\r\n\r\n\t\tif ((bitspersample > 8) && (photometric==PHOTOMETRIC_PALETTE))\t// + VK + (BIG palette! => convert to RGB)\r\n\t\t{\thead.biBitCount=24;\r\n\t\t\thead.biClrUsed =0;\r\n\t\t}\r\n\t}\r\n\r\n\tif (info.nEscape) cx_throw(\"Cancelled\"); // <vho> - cancel decoding\r\n\r\n\tCreate(width,height,head.biBitCount,CXIMAGE_FORMAT_TIF);\t//image creation\r\n\tif (!pDib) cx_throw(\"CxImageTIF can't create image\");\r\n\r\n#if CXIMAGE_SUPPORT_ALPHA\r\n\tif (samplesperpixel==4) AlphaCreate();\t//add alpha support for 32bpp tiffs\r\n\tif (samplesperpixel==2 && bitspersample==8) AlphaCreate();\t//add alpha support for 8bpp + alpha\r\n#endif //CXIMAGE_SUPPORT_ALPHA\r\n\r\n\tTIFFGetField(m_tif, TIFFTAG_COMPRESSION, &compression);\r\n\tSetCodecOption(compression); // <DPR> save original compression type\r\n\r\n\tif (isRGB) {\r\n\t\t// Read the whole image into one big RGBA buffer using\r\n\t\t// the traditional TIFFReadRGBAImage() API that we trust.\r\n\t\tuint32* raster;\t\t// retrieve RGBA image\r\n\t\tuint32 *row;\r\n\r\n\t\traster = (uint32*)_TIFFmalloc(width * height * sizeof (uint32));\r\n\t\tif (raster == NULL) cx_throw(\"No space for raster buffer\");\r\n\t\t\t\r\n\t\t// Read the image in one chunk into an RGBA array\r\n\t\tif(!TIFFReadRGBAImage(m_tif, width, height, raster, 1)) {\r\n\t\t\t\t_TIFFfree(raster);\r\n\t\t\t\tcx_throw(\"Corrupted TIFF file!\");\r\n\t\t}\r\n\r\n\t\t// read the raster lines and save them in the DIB\r\n\t\t// with RGB mode, we have to change the order of the 3 samples RGB\r\n\t\trow = &raster[0];\r\n\t\tbits2 = info.pImage;\r\n\t\tfor (y = 0; y < height; y++) {\r\n\r\n\t\t\tif (info.nEscape){ // <vho> - cancel decoding\r\n\t\t\t\t_TIFFfree(raster);\r\n\t\t\t\tcx_throw(\"Cancelled\");\r\n\t\t\t}\r\n\r\n\t\t\tbits = bits2;\r\n\t\t\tfor (x = 0; x < width; x++) {\r\n\t\t\t\t*bits++ = (uint8_t)TIFFGetB(row[x]);\r\n\t\t\t\t*bits++ = (uint8_t)TIFFGetG(row[x]);\r\n\t\t\t\t*bits++ = (uint8_t)TIFFGetR(row[x]);\r\n#if CXIMAGE_SUPPORT_ALPHA\r\n\t\t\t\tif (samplesperpixel==4) AlphaSet(x,y,(uint8_t)TIFFGetA(row[x]));\r\n#endif //CXIMAGE_SUPPORT_ALPHA\r\n\t\t\t}\r\n\t\t\trow += width;\r\n\t\t\tbits2 += info.dwEffWidth;\r\n\t\t}\r\n\t\t_TIFFfree(raster);\r\n\t} else {\r\n\t\tint32_t BIG_palette = (bitspersample > 8) &&\t// + VK\r\n\t\t\t\t\t\t  (photometric==PHOTOMETRIC_PALETTE);\t\t\r\n\t\tif (BIG_palette && (bitspersample > 24))\t// + VK\r\n\t\t\tcx_throw(\"Too big palette to handle\");\t\t// + VK\r\n\r\n\t\tRGBQUAD *pal;\r\n\t\tpal=(RGBQUAD*)calloc(BIG_palette ? 1<<bitspersample : 256,sizeof(RGBQUAD)); \r\n\t\t\t// ! VK: it coasts nothing but more correct to use 256 as temp palette storage\r\n\t\t\t// ! VK: but for case of BIG palette it just copied\r\n\t\tif (pal==NULL) cx_throw(\"Unable to allocate TIFF palette\");\r\n\r\n\t\tint32_t bpp = bitspersample <= 8 ? bitspersample : 8; // + VK (to use instead of bitspersample for case of > 8)\r\n\r\n\t\t// set up the colormap based on photometric\t\r\n\t\tswitch(photometric) {\r\n\t\t\tcase PHOTOMETRIC_MINISBLACK:\t// bitmap and greyscale image types\r\n\t\t\tcase PHOTOMETRIC_MINISWHITE:\r\n\t\t\t\tif (bitspersample == 1) {\t// Monochrome image\r\n\t\t\t\t\tif (photometric == PHOTOMETRIC_MINISBLACK) {\r\n\t\t\t\t\t\tpal[1].rgbRed = pal[1].rgbGreen = pal[1].rgbBlue = 255;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tpal[0].rgbRed = pal[0].rgbGreen = pal[0].rgbBlue = 255;\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\t\t// need to build the scale for greyscale images\r\n\t\t\t\t\tif (photometric == PHOTOMETRIC_MINISBLACK) {\r\n\t\t\t\t\t\tfor (int32_t i=0; i<(1<<bpp); i++){\r\n\t\t\t\t\t\t\tpal[i].rgbRed = pal[i].rgbGreen = pal[i].rgbBlue = (uint8_t)(i*(255/((1<<bpp)-1)));\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tfor (int32_t i=0; i<(1<<bpp); i++){\r\n\t\t\t\t\t\t\tpal[i].rgbRed = pal[i].rgbGreen = pal[i].rgbBlue = (uint8_t)(255-i*(255/((1<<bpp)-1)));\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase PHOTOMETRIC_PALETTE:\t// color map indexed\r\n\t\t\t\tuint16 *red;\r\n\t\t\t\tuint16 *green;\r\n\t\t\t\tuint16 *blue;\r\n\t\t\t\tTIFFGetField(m_tif, TIFFTAG_COLORMAP, &red, &green, &blue); \r\n\r\n\t\t\t\t// Is the palette 16 or 8 bits ?\r\n\t\t\t\tBOOL Palette16Bits = /*FALSE*/ BIG_palette;\r\n\t\t\t\tif (!BIG_palette) {\r\n\t\t\t\t\tint32_t n= 1<<bpp;\r\n\t\t\t\t\twhile (n-- > 0) {\r\n\t\t\t\t\t\tif (red[n] >= 256 || green[n] >= 256 || blue[n] >= 256) {\r\n\t\t\t\t\t\t\tPalette16Bits=TRUE;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// load the palette in the DIB\r\n\t\t\t\tfor (int32_t i = (1 << ( BIG_palette ? bitspersample : bpp )) - 1; i >= 0; i--) {\r\n\t\t\t\t\tif (Palette16Bits) {\r\n\t\t\t\t\t\tpal[i].rgbRed =(uint8_t) CVT(red[i]);\r\n\t\t\t\t\t\tpal[i].rgbGreen = (uint8_t) CVT(green[i]);\r\n\t\t\t\t\t\tpal[i].rgbBlue = (uint8_t) CVT(blue[i]);           \r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tpal[i].rgbRed = (uint8_t) red[i];\r\n\t\t\t\t\t\tpal[i].rgbGreen = (uint8_t) green[i];\r\n\t\t\t\t\t\tpal[i].rgbBlue = (uint8_t) blue[i];        \r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\t\tif (!BIG_palette) { // + VK (BIG palette is stored until image is ready)\r\n\t\t\tSetPalette(pal,/*head.biClrUsed*/ 1<<bpp);\t//palette assign // * VK\r\n\t\t\tfree(pal); \r\n\t\t\tpal = NULL; \r\n\t\t}\r\n\r\n\t\t// read the tiff lines and save them in the DIB\r\n\t\tuint32 nrow;\r\n\t\tuint32 ys;\r\n\t\tint32_t line = CalculateLine(width, bitspersample * samplesperpixel);\r\n\t\t\r\n\t\tint32_t bitsize = TIFFStripSize(m_tif);\r\n\t\t//verify bitsize: could be wrong if StripByteCounts is missing.\r\n\t\tif (bitsize>(int32_t)(head.biSizeImage*samplesperpixel))\r\n\t\t\tbitsize = head.biSizeImage*samplesperpixel;\r\n\t\tif (bitsize<(int32_t)(info.dwEffWidth*rowsperstrip))\r\n\t\t\tbitsize = info.dwEffWidth*rowsperstrip;\r\n\r\n\t\tif ((bitspersample > 8) && (bitspersample != 16))\t// + VK (for bitspersample == 9..15,17..32..64\r\n\t\t\tbitsize *= (bitspersample + 7)/8; \r\n\r\n\t\tint32_t tiled_image = TIFFIsTiled(m_tif);\r\n\t\tuint32 tw=0, tl=0;\r\n\t\tuint8_t* tilebuf=NULL;\r\n\t\tif (tiled_image){\r\n\t\t\tTIFFGetField(m_tif, TIFFTAG_TILEWIDTH, &tw);\r\n\t\t\tTIFFGetField(m_tif, TIFFTAG_TILELENGTH, &tl);\r\n\t\t\trowsperstrip = tl;\r\n\t\t\tbitsize = TIFFTileSize(m_tif) * (int32_t)(1+width/tw);\r\n\t\t\ttilebuf = (uint8_t*)malloc(TIFFTileSize(m_tif));\r\n\t\t}\r\n\t\t\r\n        int32_t bitsize_correct = bitspersample==16? bitsize*2 : bitsize;\r\n        bits = (uint8_t*)malloc(bitsize_correct); // * VK\r\n\t\tuint8_t * bits16 = NULL;\t\t\t\t\t\t\t\t\t\t  // + VK\r\n\t\tint32_t line16    = 0;\t\t\t\t\t\t\t\t\t\t\t  // + VK\r\n\r\n\t\tif (!tiled_image && bitspersample==16) {\t\t\t\t\t  // + VK +\r\n\t\t\tline16 = line;\r\n\t\t\tline   = CalculateLine(width, 8 * samplesperpixel);\r\n\t\t\tbits16 = bits;\r\n            bitsize_correct = bitsize;\r\n\t\t\tbits   = (uint8_t*)malloc(bitsize);\r\n\t\t}\r\n\r\n\t\tif (bits==NULL){\r\n\t\t\tif (bits16) free(bits16);\t\t\t\t\t\t\t\t  // + VK\r\n\t\t\tif (pal)\tfree(pal);\t\t\t\t\t\t\t\t\t  // + VK\r\n\t\t\tif (tilebuf)free(tilebuf);\t\t\t\t\t\t\t\t  // + VK\t\r\n\t\t\tcx_throw(\"CxImageTIF can't allocate memory\");\r\n\t\t}\r\n\r\n#ifdef FIX_16BPP_DARKIMG // + VK: for each line, store shift count bits used to fix it\r\n\t\tuint8_t* row_shifts = NULL;\r\n\t\tif (bits16) row_shifts = (uint8_t*)malloc(height); \r\n#endif\r\n\r\n\t\tfor (ys = 0; ys < height; ys += rowsperstrip) {\r\n\r\n\t\t\tif (info.nEscape){ // <vho> - cancel decoding\r\n\t\t\t\tfree(bits);\r\n\t\t\t\tcx_throw(\"Cancelled\");\r\n\t\t\t}\r\n\r\n\t\t\tnrow = (ys + rowsperstrip > height ? height - ys : rowsperstrip);\r\n\r\n\t\t\tif (tiled_image){\r\n\t\t\t\tuint32 imagew = TIFFScanlineSize(m_tif);\r\n\t\t\t\tuint32 tilew  = TIFFTileRowSize(m_tif);\r\n\t\t\t\tint32_t iskew = imagew - tilew;\r\n\t\t\t\tuint8* bufp = (uint8*) bits;\r\n\r\n\t\t\t\tuint32 colb = 0;\r\n\t\t\t\tfor (uint32 col = 0; col < width; col += tw) {\r\n\t\t\t\t\tif (TIFFReadTile(m_tif, tilebuf, col, ys, 0, 0) < 0){\r\n\t\t\t\t\t\tfree(tilebuf);\r\n\t\t\t\t\t\tfree(bits);\r\n\t\t\t\t\t\tcx_throw(\"Corrupted tiled TIFF file!\");\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (colb + tw > imagew) {\r\n\t\t\t\t\t\tuint32 owidth = imagew - colb;\r\n\t\t\t\t\t\tuint32 oskew = tilew - owidth;\r\n\t\t\t\t\t\tTileToStrip(bufp + colb, tilebuf, nrow, owidth, oskew + iskew, oskew );\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tTileToStrip(bufp + colb, tilebuf, nrow, tilew, iskew, 0);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tcolb += tilew;\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\t\t\t\tif (TIFFReadEncodedStrip(m_tif, TIFFComputeStrip(m_tif, ys, 0), \r\n\t\t\t\t\t(bits16? bits16 : bits), nrow * (bits16 ? line16 : line)) == -1) { // * VK\r\n\r\n#ifdef NOT_IGNORE_CORRUPTED\r\n\t\t\t\t\tfree(bits);\r\n\t\t\t\t\tif (bits16) free(bits16);  // + VK\r\n\t\t\t\t\tcx_throw(\"Corrupted TIFF file!\");\r\n#else\r\n\t\t\t\t\tbreak;\r\n#endif\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tfor (y = 0; y < nrow; y++) {\r\n\t\t\t\tint32_t offset=(nrow-y-1)*line;\r\n\t\t\t\tif ((bitspersample==16) && !BIG_palette) {\t// * VK\r\n\t\t\t\t\tint32_t offset16 = (nrow-y-1)*line16;\t\t// + VK\r\n\t\t\t\t\tif (bits16)\t{\t\t\t\t\t\t\t// + VK +\r\n#ifdef FIX_16BPP_DARKIMG\r\n\t\t\t\t\t\tint32_t the_shift;\r\n\t\t\t\t\t\tuint8_t hi_byte, hi_max=0;\r\n\t\t\t\t\t\tuint32_t xi;\r\n\t\t\t\t\t\tfor (xi=0;xi<(uint32)line;xi++) {\r\n\t\t\t\t\t\t\thi_byte = bits16[xi*2+offset16+1];\r\n\t\t\t\t\t\t\tif(hi_byte>hi_max)\r\n\t\t\t\t\t\t\t\thi_max = hi_byte;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tthe_shift = (hi_max == 0) ? 8 : 0;\r\n\t\t\t\t\t\tif (!the_shift)\r\n\t\t\t\t\t\t\twhile( ! (hi_max & 0x80) ) {\r\n\t\t\t\t\t\t\t\tthe_shift++;\r\n\t\t\t\t\t\t\t\thi_max <<= 1;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\trow_shifts[height-ys-nrow+y] = the_shift;\r\n\t\t\t\t\t\tthe_shift = 8 - the_shift;\r\n\t\t\t\t\t\tfor (xi=0;xi<(uint32)line;xi++) \r\n\t\t\t\t\t\t\tbits[xi+offset]= ((bits16[xi*2+offset16+1]<<8) | bits16[xi*2+offset16]) >> the_shift;\r\n#else\r\n\t\t\t\t\t\tfor (uint32_t xi=0;xi<(uint32)line;xi++) \r\n\t\t\t\t\t\t\tbits[xi+offset]=bits16[xi*2+offset16+1];\r\n#endif\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tfor (uint32_t xi=0;xi<width;xi++)\r\n\t\t\t\t\t\t\tbits[xi+offset]=bits[xi*2+offset+1];\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (samplesperpixel==1) { \r\n\t\t\t\t\tif (BIG_palette)\r\n\t\t\t\t\t\tif (bits16) {\r\n\t\t\t\t\t\t\tint32_t offset16 = (nrow-y-1)*line16;\t\t// + VK\r\n\t\t\t\t\t\t\tMoveBitsPal( info.pImage + info.dwEffWidth * (height-ys-nrow+y),\r\n\t\t\t\t\t\t\t\t\t bits16 + offset16, width, bitspersample, pal );\r\n\t\t\t\t\t\t} else\r\n\t\t\t\t\t\t\tMoveBitsPal( info.pImage + info.dwEffWidth * (height-ys-nrow+y),\r\n\t\t\t\t\t\t\t\t\t bits + offset, width, bitspersample, pal );\r\n\t\t\t\t\telse if ((bitspersample == head.biBitCount) || \r\n\t\t\t\t\t\t(bitspersample == 16))\t//simple 8bpp, 4bpp image or 16bpp\r\n\t\t\t\t\t\tmemcpy(info.pImage+info.dwEffWidth*(height-ys-nrow+y),bits+offset,min((unsigned)line, info.dwEffWidth));\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tMoveBits( info.pImage + info.dwEffWidth * (height-ys-nrow+y),\r\n\t\t\t\t\t\t\t\t  bits + offset, width, bitspersample );\r\n\t\t\t\t} else if (samplesperpixel==2) { //8bpp image with alpha layer\r\n\t\t\t\t\tint32_t xi=0;\r\n\t\t\t\t\tint32_t ii=0;\r\n\t\t\t\t\tint32_t yi=height-ys-nrow+y;\r\n#if CXIMAGE_SUPPORT_ALPHA\r\n\t\t\t\t\tif (!pAlpha) AlphaCreate();\t\t\t// + VK\r\n#endif //CXIMAGE_SUPPORT_ALPHA\r\n\t\t\t\t\twhile (ii<line){\r\n\t\t\t\t\t\tSetPixelIndex(xi,yi,bits[ii+offset]);\r\n#if CXIMAGE_SUPPORT_ALPHA\r\n\t\t\t\t\t\tAlphaSet(xi,yi,bits[ii+offset+1]);\r\n#endif //CXIMAGE_SUPPORT_ALPHA\r\n\t\t\t\t\t\tii+=2;\r\n\t\t\t\t\t\txi++;\r\n\t\t\t\t\t\tif (xi>=(int32_t)width){\r\n\t\t\t\t\t\t\tyi--;\r\n\t\t\t\t\t\t\txi=0;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t} else { //photometric==PHOTOMETRIC_CIELAB\r\n\t\t\t\t\tif (head.biBitCount!=24){ //fix image\r\n\t\t\t\t\t\tCreate(width,height,24,CXIMAGE_FORMAT_TIF);\r\n#if CXIMAGE_SUPPORT_ALPHA\r\n\t\t\t\t\t\tif (samplesperpixel==4) AlphaCreate();\r\n#endif //CXIMAGE_SUPPORT_ALPHA\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tint32_t xi=0;\r\n\t\t\t\t\tuint32 ii=0;\r\n\t\t\t\t\tint32_t yi=height-ys-nrow+y;\r\n\t\t\t\t\tRGBQUAD c;\r\n\t\t\t\t\tint32_t l,a,b,bitsoffset;\r\n\t\t\t\t\tdouble p,cx,cy,cz,cr,cg,cb;\r\n\t\t\t\t\twhile (ii</*line*/width){\t\t// * VK\r\n\t\t\t\t\t\tbitsoffset = ii*samplesperpixel+offset;\r\n                        if (bitsoffset + 2 < bitsize_correct)\r\n                        {\r\n                            l=bits[bitsoffset];\r\n                            a=bits[bitsoffset+1];\r\n                            b=bits[bitsoffset+2];\r\n                        }\r\n                        else\r\n                        {\r\n                            l=0;\r\n                            a=0;\r\n                            b=0;\r\n                        }\r\n\t\t\t\t\t\tif (a>127) a-=256;\r\n\t\t\t\t\t\tif (b>127) b-=256;\r\n\t\t\t\t\t\t// lab to xyz\r\n\t\t\t\t\t\tp = (l/2.55 + 16) / 116.0;\r\n\t\t\t\t\t\tcx = pow( p + a * 0.002, 3);\r\n\t\t\t\t\t\tcy = pow( p, 3);\r\n\t\t\t\t\t\tcz = pow( p - b * 0.005, 3);\r\n\t\t\t\t\t\t// white point\r\n\t\t\t\t\t\tcx*=0.95047;\r\n\t\t\t\t\t\t//cy*=1.000;\r\n\t\t\t\t\t\tcz*=1.0883;\r\n\t\t\t\t\t\t// xyz to rgb\r\n\t\t\t\t\t\tcr =  3.240479 * cx - 1.537150 * cy - 0.498535 * cz;\r\n\t\t\t\t\t\tcg = -0.969256 * cx + 1.875992 * cy + 0.041556 * cz;\r\n\t\t\t\t\t\tcb =  0.055648 * cx - 0.204043 * cy + 1.057311 * cz;\r\n\r\n\t\t\t\t\t\tif ( cr > 0.00304 ) cr = 1.055 * pow(cr,0.41667) - 0.055;\r\n\t\t\t\t\t\t\telse            cr = 12.92 * cr;\r\n\t\t\t\t\t\tif ( cg > 0.00304 ) cg = 1.055 * pow(cg,0.41667) - 0.055;\r\n\t\t\t\t\t\t\telse            cg = 12.92 * cg;\r\n\t\t\t\t\t\tif ( cb > 0.00304 ) cb = 1.055 * pow(cb,0.41667) - 0.055;\r\n\t\t\t\t\t\t\telse            cb = 12.92 * cb;\r\n\r\n\t\t\t\t\t\tc.rgbRed  =(uint8_t)max(0,min(255,(int32_t)(cr*255)));\r\n\t\t\t\t\t\tc.rgbGreen=(uint8_t)max(0,min(255,(int32_t)(cg*255)));\r\n\t\t\t\t\t\tc.rgbBlue =(uint8_t)max(0,min(255,(int32_t)(cb*255)));\r\n\r\n\t\t\t\t\t\tSetPixelColor(xi,yi,c);\r\n#if CXIMAGE_SUPPORT_ALPHA\r\n\t\t\t\t\t\tif (samplesperpixel==4) AlphaSet(xi,yi,bits[bitsoffset+3]);\r\n#endif //CXIMAGE_SUPPORT_ALPHA\r\n\t\t\t\t\t\tii++;\r\n\t\t\t\t\t\txi++;\r\n\t\t\t\t\t\tif (xi>=(int32_t)width){\r\n\t\t\t\t\t\t\tyi--;\r\n\t\t\t\t\t\t\txi=0;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tfree(bits);\r\n\t\tif (bits16) free(bits16);\r\n\r\n#ifdef FIX_16BPP_DARKIMG\r\n\t\tif (row_shifts && (samplesperpixel == 1) && (bitspersample==16) && !BIG_palette) {\r\n\t\t\t// 1. calculate maximum necessary shift\r\n\t\t\tint32_t min_row_shift = 8;\r\n\t\t\tfor( y=0; y<height; y++ ) {\r\n\t\t\t\tif (min_row_shift > row_shifts[y]) min_row_shift = row_shifts[y];\r\n\t\t\t}\r\n\t\t\t// 2. for rows having less shift value, correct such rows:\r\n\t\t\tfor( y=0; y<height; y++ ) {\r\n\t\t\t\tif (min_row_shift < row_shifts[y]) {\r\n\t\t\t\t\tint32_t need_shift = row_shifts[y] - min_row_shift;\r\n\t\t\t\t\tuint8_t* data = info.pImage + info.dwEffWidth * y;\r\n\t\t\t\t\tfor( x=0; x<width; x++, data++ )\r\n\t\t\t\t\t\t*data >>= need_shift;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (row_shifts)\tfree( row_shifts );\r\n#endif\r\n\r\n\t\tif (tiled_image) free(tilebuf);\r\n\t\tif (pal)\t\t free(pal);\r\n\r\n\t\tswitch(orientation){\r\n\t\tcase ORIENTATION_TOPRIGHT: /* row 0 top, col 0 rhs */\r\n\t\t\tMirror();\r\n\t\t\tbreak;\r\n\t\tcase ORIENTATION_BOTRIGHT: /* row 0 bottom, col 0 rhs */\r\n\t\t\tFlip();\r\n\t\t\tMirror();\r\n\t\t\tbreak;\r\n\t\tcase ORIENTATION_BOTLEFT: /* row 0 bottom, col 0 lhs */\r\n\t\t\tFlip();\r\n\t\t\tbreak;\r\n\t\tcase ORIENTATION_LEFTTOP: /* row 0 lhs, col 0 top */\r\n\t\t\tRotateRight();\r\n\t\t\tMirror();\r\n\t\t\tbreak;\r\n\t\tcase ORIENTATION_RIGHTTOP: /* row 0 rhs, col 0 top */\r\n\t\t\tRotateLeft();\r\n\t\t\tbreak;\r\n\t\tcase ORIENTATION_RIGHTBOT: /* row 0 rhs, col 0 bottom */\r\n\t\t\tRotateLeft();\r\n\t\t\tMirror();\r\n\t\t\tbreak;\r\n\t\tcase ORIENTATION_LEFTBOT: /* row 0 lhs, col 0 bottom */\r\n\t\t\tRotateRight();\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t}\r\n  } cx_catch {\r\n\t  if (strcmp(message,\"\")) strncpy(info.szLastError,message,255);\r\n\t  if (m_tif) TIFFClose(m_tif);\r\n\t  if (info.nEscape == -1 && info.dwType == CXIMAGE_FORMAT_TIF) return true;\r\n\t  return false;\r\n  }\r\n\tTIFFClose(m_tif);\r\n\treturn true;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n#endif //CXIMAGE_SUPPORT_DECODE\r\n////////////////////////////////////////////////////////////////////////////////\r\n#if CXIMAGE_SUPPORT_ENCODE\r\n////////////////////////////////////////////////////////////////////////////////\r\nbool CxImageTIF::Encode(CxFile * hFile, bool bAppend)\r\n{\r\n  cx_try\r\n  {\r\n\tif (hFile==NULL) cx_throw(CXIMAGE_ERR_NOFILE);\r\n\tif (pDib==NULL) cx_throw(CXIMAGE_ERR_NOIMAGE);\r\n\r\n\t// <RJ> replaced \"w+b\" with \"a\", to append an image directly on an existing file\r\n\tif (m_tif2==NULL) m_tif2=_TIFFOpenEx(hFile, \"a\");\r\n\tif (m_tif2==NULL) cx_throw(\"initialization fail\");\r\n\r\n\tif (bAppend || m_pages) m_multipage=true;\r\n\tm_pages++;\r\n\r\n\tif (!EncodeBody(m_tif2,m_multipage,m_pages,m_pages)) cx_throw(\"Error saving TIFF file\");\r\n\tif (bAppend) {\r\n\t\tif (!TIFFWriteDirectory(m_tif2)) cx_throw(\"Error saving TIFF directory\");\r\n\t}\r\n  } cx_catch {\r\n\t  if (strcmp(message,\"\")) strncpy(info.szLastError,message,255);\r\n\t  if (m_tif2){\r\n\t\t  TIFFClose(m_tif2);\r\n\t\t  m_tif2=NULL;\r\n\t\t  m_multipage=false;\r\n\t\t  m_pages=0;\r\n\t  }\r\n\t  return false;\r\n  }\r\n\tif (!bAppend){\r\n\t\tTIFFClose(m_tif2);\r\n\t\tm_tif2=NULL;\r\n\t\tm_multipage=false;\r\n\t\tm_pages=0;\r\n\t}\r\n\treturn true;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n// Thanks to Abe <God(dot)bless(at)marihuana(dot)com>\r\nbool CxImageTIF::Encode(CxFile * hFile, CxImage ** pImages, int32_t pagecount)\r\n{\r\n  cx_try\r\n  {\r\n\tif (hFile==NULL) cx_throw(\"invalid file pointer\");\r\n\tif (pImages==NULL || pagecount<=0) cx_throw(\"multipage TIFF, no images!\");\r\n\r\n\tint32_t i;\r\n\tfor (i=0; i<pagecount; i++){\r\n\t\tif (pImages[i]==NULL)\r\n\t\t\tcx_throw(\"Bad image pointer\");\r\n\t\tif (!(pImages[i]->IsValid()))\r\n\t\t\tcx_throw(\"Empty image\");\r\n\t}\r\n\r\n\tCxImageTIF ghost;\r\n\tfor (i=0; i<pagecount; i++){\r\n\t\tghost.Ghost(pImages[i]);\r\n\t\tif (!ghost.Encode(hFile,true)) cx_throw(\"Error saving TIFF file\");\r\n\t}\r\n  } cx_catch {\r\n\t  if (strcmp(message,\"\")) strncpy(info.szLastError,message,255);\r\n\t  return false;\r\n  }\r\n\treturn true;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\nbool CxImageTIF::EncodeBody(TIFF *m_tif, bool multipage, int32_t page, int32_t pagecount)\r\n{\r\n\tuint32 height=head.biHeight;\r\n\tuint32 width=head.biWidth;\r\n\tuint16 bitcount=head.biBitCount;\r\n\tuint16 bitspersample;\r\n\tuint16 samplesperpixel;\r\n\tuint16 photometric=0;\r\n\tuint16 compression;\r\n//\tuint16 pitch;\r\n//\tint32_t line;\r\n\tuint32 x, y;\r\n\r\n\tsamplesperpixel = ((bitcount == 24) || (bitcount == 32)) ? (uint8_t)3 : (uint8_t)1;\r\n#if CXIMAGE_SUPPORT_ALPHA\r\n\tif (bitcount==24 && AlphaIsValid()) { bitcount=32; samplesperpixel=4; }\r\n#endif //CXIMAGE_SUPPORT_ALPHA\r\n\r\n\tbitspersample = bitcount / samplesperpixel;\r\n\r\n\t//set the PHOTOMETRIC tag\r\n\tRGBQUAD *rgb = GetPalette();\r\n\tswitch (bitcount) {\r\n\t\tcase 1:\r\n\t\t\tif (CompareColors(&rgb[0],&rgb[1])<0) {\r\n\t\t\t\t/* <abe> some viewers do not handle PHOTOMETRIC_MINISBLACK:\r\n\t\t\t\t * let's transform the image in PHOTOMETRIC_MINISWHITE\r\n\t\t\t\t */\r\n\t\t\t\t//invert the colors\r\n\t\t\t\tRGBQUAD tempRGB=GetPaletteColor(0);\r\n\t\t\t\tSetPaletteColor(0,GetPaletteColor(1));\r\n\t\t\t\tSetPaletteColor(1,tempRGB);\r\n\t\t\t\t//invert the pixels\r\n\t\t\t\tuint8_t *iSrc=info.pImage;\r\n\t\t\t\tfor (uint32_t i=0;i<head.biSizeImage;i++){\r\n\t\t\t\t\t*iSrc=(uint8_t)~(*(iSrc));\r\n\t\t\t\t\tiSrc++;\r\n\t\t\t\t}\r\n\t\t\t\tphotometric = PHOTOMETRIC_MINISWHITE;\r\n\t\t\t\t//photometric = PHOTOMETRIC_MINISBLACK;\r\n\t\t\t} else {\r\n\t\t\t\tphotometric = PHOTOMETRIC_MINISWHITE;\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\tcase 4:\t// Check if the DIB has a color or a greyscale palette\r\n\t\tcase 8:\r\n\t\t\tphotometric = PHOTOMETRIC_MINISBLACK; //default to gray scale\r\n\t\t\tfor (x = 0; x < head.biClrUsed; x++) {\r\n\t\t\t\tif ((rgb->rgbRed != x)||(rgb->rgbRed != rgb->rgbGreen)||(rgb->rgbRed != rgb->rgbBlue)){\r\n\t\t\t\t\tphotometric = PHOTOMETRIC_PALETTE;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\trgb++;\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\tcase 24:\r\n\t\tcase 32:\r\n\t\t\tphotometric = PHOTOMETRIC_RGB;\t\t\t\r\n\t\t\tbreak;\r\n\t}\r\n\r\n#if CXIMAGE_SUPPORT_ALPHA\r\n\tif (AlphaIsValid() && bitcount==8) samplesperpixel=2; //8bpp + alpha layer\r\n#endif //CXIMAGE_SUPPORT_ALPHA\r\n\r\n//\tline = CalculateLine(width, bitspersample * samplesperpixel);\r\n//\tpitch = (uint16)CalculatePitch(line);\r\n\r\n\t//prepare the palette struct\r\n\tRGBQUAD pal[256];\r\n\tif (GetPalette()){\r\n\t\tuint8_t b;\r\n\t\tmemcpy(pal,GetPalette(),GetPaletteSize());\r\n\t\tfor(uint16_t a=0;a<head.biClrUsed;a++){\t//swap blue and red components\r\n\t\t\tb=pal[a].rgbBlue; pal[a].rgbBlue=pal[a].rgbRed; pal[a].rgbRed=b;\r\n\t\t}\r\n\t}\r\n\r\n\t// handle standard width/height/bpp stuff\r\n\tTIFFSetField(m_tif, TIFFTAG_IMAGEWIDTH, width);\r\n\tTIFFSetField(m_tif, TIFFTAG_IMAGELENGTH, height);\r\n\tTIFFSetField(m_tif, TIFFTAG_SAMPLESPERPIXEL, samplesperpixel);\r\n\tTIFFSetField(m_tif, TIFFTAG_BITSPERSAMPLE, bitspersample);\r\n\tTIFFSetField(m_tif, TIFFTAG_PHOTOMETRIC, photometric);\r\n\tTIFFSetField(m_tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\t// single image plane \r\n\tTIFFSetField(m_tif, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\r\n\r\n\tuint32 rowsperstrip = TIFFDefaultStripSize(m_tif, (uint32) -1);  //<REC> gives better compression\r\n\tTIFFSetField(m_tif, TIFFTAG_ROWSPERSTRIP, rowsperstrip);\r\n\r\n\t// handle metrics\r\n\tTIFFSetField(m_tif, TIFFTAG_RESOLUTIONUNIT, RESUNIT_INCH);\r\n\tTIFFSetField(m_tif, TIFFTAG_XRESOLUTION, (float)info.xDPI);\r\n\tTIFFSetField(m_tif, TIFFTAG_YRESOLUTION, (float)info.yDPI);\r\n//\tTIFFSetField(m_tif, TIFFTAG_XPOSITION, (float)info.xOffset);\r\n//\tTIFFSetField(m_tif, TIFFTAG_YPOSITION, (float)info.yOffset);\r\n\r\n\t// multi-paging - Thanks to Abe <God(dot)bless(at)marihuana(dot)com>\r\n\tif (multipage)\r\n\t{\r\n\t\tchar page_number[20];\r\n\t\tsprintf(page_number, \"Page %d\", page);\r\n\r\n\t\tTIFFSetField(m_tif, TIFFTAG_SUBFILETYPE, FILETYPE_PAGE);\r\n\t\tTIFFSetField(m_tif, TIFFTAG_PAGENUMBER, page,pagecount);\r\n\t\tTIFFSetField(m_tif, TIFFTAG_PAGENAME, page_number);\r\n\t} else {\r\n\t\tTIFFSetField(m_tif, TIFFTAG_SUBFILETYPE, 0);\r\n\t}\r\n\r\n\t// palettes (image colormaps are automatically scaled to 16-bits)\r\n\tif (photometric == PHOTOMETRIC_PALETTE) {\r\n\t\tuint16 *r, *g, *b;\r\n\t\tr = (uint16 *) _TIFFmalloc(sizeof(uint16) * 3 * 256);\r\n\t\tg = r + 256;\r\n\t\tb = g + 256;\r\n\r\n\t\tfor (int32_t i = 255; i >= 0; i--) {\r\n\t\t\tb[i] = (uint16)SCALE((uint16)pal[i].rgbRed);\r\n\t\t\tg[i] = (uint16)SCALE((uint16)pal[i].rgbGreen);\r\n\t\t\tr[i] = (uint16)SCALE((uint16)pal[i].rgbBlue);\r\n\t\t}\r\n\r\n\t\tTIFFSetField(m_tif, TIFFTAG_COLORMAP, r, g, b);\r\n\t\t_TIFFfree(r);\r\n\t}\r\n\r\n\t// compression\r\n\tif (GetCodecOption(CXIMAGE_FORMAT_TIF)) {\r\n\t\tcompression = (uint16_t)GetCodecOption(CXIMAGE_FORMAT_TIF);\r\n\t} else {\r\n\t\tswitch (bitcount) {\r\n\t\t\tcase 1 :\r\n\t\t\t\tcompression = COMPRESSION_CCITTFAX4;\r\n\t\t\t\tbreak;\r\n\t\t\tcase 4 :\r\n\t\t\tcase 8 :\r\n\t\t\t\tcompression = COMPRESSION_LZW;\r\n\t\t\t\tbreak;\r\n\t\t\tcase 24 :\r\n\t\t\tcase 32 :\r\n\t\t\t\tcompression = COMPRESSION_JPEG;\r\n\t\t\t\tbreak;\r\n\t\t\tdefault :\r\n\t\t\t\tcompression = COMPRESSION_NONE;\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\tTIFFSetField(m_tif, TIFFTAG_COMPRESSION, compression);\r\n\r\n\tswitch (compression) {\r\n\tcase COMPRESSION_JPEG:\r\n\t\tTIFFSetField(m_tif, TIFFTAG_JPEGQUALITY, GetJpegQuality());\r\n\t\tTIFFSetField(m_tif, TIFFTAG_ROWSPERSTRIP, ((7+rowsperstrip)>>3)<<3);\r\n   \t\tbreak;\r\n\tcase COMPRESSION_LZW:\r\n\t\tif (bitcount>=8) TIFFSetField(m_tif, TIFFTAG_PREDICTOR, 2);\r\n\t\tbreak;\r\n\t}\r\n\r\n\t// read the DIB lines from bottom to top and save them in the TIF\r\n\r\n\tuint8_t *bits;\r\n\tswitch(bitcount) {\t\t\t\t\r\n\t\tcase 1 :\r\n\t\tcase 4 :\r\n\t\tcase 8 :\r\n\t\t{\r\n\t\t\tif (samplesperpixel==1){\r\n\t\t\t\tbits = (uint8_t*)malloc(info.dwEffWidth);\r\n\t\t\t\tif (!bits) return false;\r\n\t\t\t\tfor (y = 0; y < height; y++) {\r\n\t\t\t\t\tmemcpy(bits,info.pImage + (height - y - 1)*info.dwEffWidth,info.dwEffWidth);\r\n\t\t\t\t\tif (TIFFWriteScanline(m_tif,bits, y, 0)==-1){\r\n\t\t\t\t\t\tfree(bits);\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tfree(bits);\r\n\t\t\t}\r\n#if CXIMAGE_SUPPORT_ALPHA\r\n\t\t\telse { //8bpp + alpha layer\r\n\t\t\t\tbits = (uint8_t*)malloc(2*width);\r\n\t\t\t\tif (!bits) return false;\r\n\t\t\t\tfor (y = 0; y < height; y++) {\r\n\t\t\t\t\tfor (x=0;x<width;x++){\r\n\t\t\t\t\t\tbits[2*x]=BlindGetPixelIndex(x,height - y - 1);\r\n\t\t\t\t\t\tbits[2*x+1]=AlphaGet(x,height - y - 1);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (TIFFWriteScanline(m_tif,bits, y, 0)==-1) {\r\n\t\t\t\t\t\tfree(bits);\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tfree(bits);\r\n\t\t\t}\r\n#endif //CXIMAGE_SUPPORT_ALPHA\r\n\t\t\tbreak;\r\n\t\t}\t\t\t\t\r\n\t\tcase 24:\r\n\t\t{\r\n\t\t\tuint8_t *buffer = (uint8_t *)malloc(info.dwEffWidth);\r\n\t\t\tif (!buffer) return false;\r\n\t\t\tfor (y = 0; y < height; y++) {\r\n\t\t\t\t// get a pointer to the scanline\r\n\t\t\t\tmemcpy(buffer, info.pImage + (height - y - 1)*info.dwEffWidth, info.dwEffWidth);\r\n\t\t\t\t// TIFFs store color data RGB instead of BGR\r\n\t\t\t\tuint8_t *pBuf = buffer;\r\n\t\t\t\tfor (x = 0; x < width; x++) {\r\n\t\t\t\t\tuint8_t tmp = pBuf[0];\r\n\t\t\t\t\tpBuf[0] = pBuf[2];\r\n\t\t\t\t\tpBuf[2] = tmp;\r\n\t\t\t\t\tpBuf += 3;\r\n\t\t\t\t}\r\n\t\t\t\t// write the scanline to disc\r\n\t\t\t\tif (TIFFWriteScanline(m_tif, buffer, y, 0)==-1){\r\n\t\t\t\t\tfree(buffer);\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tfree(buffer);\r\n\t\t\tbreak;\r\n\t\t}\t\t\t\t\r\n\t\tcase 32 :\r\n\t\t{\r\n#if CXIMAGE_SUPPORT_ALPHA\r\n\t\t\tuint8_t *buffer = (uint8_t *)malloc((info.dwEffWidth*4)/3);\r\n\t\t\tif (!buffer) return false;\r\n\t\t\tfor (y = 0; y < height; y++) {\r\n\t\t\t\t// get a pointer to the scanline\r\n\t\t\t\tmemcpy(buffer, info.pImage + (height - y - 1)*info.dwEffWidth, info.dwEffWidth);\r\n\t\t\t\t// TIFFs store color data RGB instead of BGR\r\n\t\t\t\tuint8_t *pSrc = buffer + 3 * width;\r\n\t\t\t\tuint8_t *pDst = buffer + 4 * width;\r\n\t\t\t\tfor (x = 0; x < width; x++) {\r\n\t\t\t\t\tpDst-=4;\r\n\t\t\t\t\tpSrc-=3;\r\n\t\t\t\t\tpDst[3] = AlphaGet(width-x-1,height-y-1);\r\n\t\t\t\t\tpDst[2] = pSrc[0];\r\n\t\t\t\t\tpDst[1] = pSrc[1];\r\n\t\t\t\t\tpDst[0] = pSrc[2];\r\n\t\t\t\t}\r\n\t\t\t\t// write the scanline to disc\r\n\t\t\t\tif (TIFFWriteScanline(m_tif, buffer, y, 0)==-1){\r\n\t\t\t\t\tfree(buffer);\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tfree(buffer);\r\n#endif //CXIMAGE_SUPPORT_ALPHA\r\n\t\t\tbreak;\r\n\t\t}\t\t\t\t\r\n\t}\r\n\treturn true;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n#endif // CXIMAGE_SUPPORT_ENCODE\r\n////////////////////////////////////////////////////////////////////////////////\r\nvoid CxImageTIF::TileToStrip(uint8* out, uint8* in,\tuint32 rows, uint32 cols, int32_t outskew, int32_t inskew)\r\n{\r\n\twhile (rows-- > 0) {\r\n\t\tuint32 j = cols;\r\n\t\twhile (j-- > 0)\r\n\t\t\t*out++ = *in++;\r\n\t\tout += outskew;\r\n\t\tin += inskew;\r\n\t}\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\nTIFF* CxImageTIF::TIFFOpenEx(CxFile * hFile)\r\n{\r\n\tif (hFile) return _TIFFOpenEx(hFile, \"rb\");\r\n\treturn NULL;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\nvoid CxImageTIF::TIFFCloseEx(TIFF* tif)\r\n{\r\n\tif (tif) TIFFClose(tif);\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\nvoid CxImageTIF::MoveBits( uint8_t* dest, uint8_t* from, int32_t count, int32_t bpp )\r\n{\tint32_t offbits = 0;\r\n\tuint16 w;\r\n\tuint32 d;\r\n\tif (bpp <= 8) {\r\n\t\twhile (count-- > 0) {\r\n\t\t\tif (offbits + bpp <= 8)\r\n\t\t\t\tw = *from >> (8 - offbits - bpp);\r\n\t\t\telse {\r\n\t\t        w = *from++ << (offbits + bpp - 8);\r\n\t\t\t\tw |= *from >> (16 - offbits - bpp);\r\n\t\t\t}\r\n\t\t\toffbits += bpp;\r\n\t\t\tif (offbits >= 8) {\r\n\t\t\t\toffbits -= 8;\r\n\t\t        if (offbits == 0) from++;\r\n\t\t\t}\t\r\n\t\t\t*dest++ = (uint8_t)w & ((1 << bpp)-1);\r\n\t\t}\r\n\t} else if (bpp < 16) {\r\n\t\twhile (count-- > 0) {\r\n\t\t\td = (*from << 24) | (from[1]<<16) | (from[2]<<8) | from[3];\r\n\t\t\td >>= (24 - offbits);\r\n\t\t\t*dest++ = (uint8_t) ( d );\r\n\t\t\toffbits += bpp;\r\n\t\t\twhile (offbits >= 8) {\r\n\t\t\t\tfrom++;\r\n\t\t\t\toffbits -= 8;\r\n\t\t\t}\r\n\t\t}\r\n\t} else if (bpp < 32) {\r\n\t\twhile (count-- > 0) {\r\n\t\t\td = (*from << 24) | (from[1]<<16) | (from[2]<<8) | from[3];\r\n\t\t\t//d = *(uint32*)from;\r\n\t\t\t*dest++ = (uint8_t) ( d >> (offbits + bpp - 8) );\r\n\t\t\toffbits += bpp;\r\n\t\t\twhile (offbits >= 8) {\r\n\t\t\t\tfrom++;\r\n\t\t\t\toffbits -= 8;\r\n\t\t\t}\r\n\t\t}\r\n\t} else {\r\n\t\twhile (count-- > 0) {\r\n\t\t\td = *(uint32*)from;\r\n\t\t\t*dest++ = (uint8_t) (d >> 24);\r\n\t\t\tfrom += 4;\r\n\t\t}\r\n\t}\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\nvoid CxImageTIF::MoveBitsPal( uint8_t* dest, uint8_t*from, int32_t count, int32_t bpp, RGBQUAD* pal )\r\n{\tint32_t offbits = 0;\r\n\tuint32 d;\r\n\tuint16 palidx;\r\n\twhile (count-- > 0) {\r\n\t\td = (*from << 24) | ( *( from + 1 ) << 16 )\r\n\t\t\t\t\t\t  | ( *( from + 2 ) << 8 )\r\n\t\t\t\t\t\t  | ( *( from + 3 ) );\r\n\t\tpalidx = (uint16) (d >> (32 - offbits - bpp));\r\n\t\tif (bpp < 16) {\r\n\t\t\tpalidx <<= 16-bpp;\r\n\t\t\tpalidx = (palidx >> 8) | (palidx <<8);\r\n\t\t\tpalidx >>= 16-bpp;\r\n\t\t} else palidx = (palidx >> 8) | (palidx << 8);\r\n\t\t*dest++ = pal[palidx].rgbBlue;\r\n\t\t*dest++ = pal[palidx].rgbGreen;\r\n\t\t*dest++ = pal[palidx].rgbRed;\r\n\t\toffbits += bpp;\r\n\t\twhile (offbits >= 8) {\r\n\t\t\tfrom++;\r\n\t\t\toffbits -= 8;\r\n\t\t}\r\n\t}\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n\r\n#endif // CXIMAGE_SUPPORT_TIF\r\n", "\ufeff#if !defined(__xiofile_h)\r\n#define __xiofile_h\r\n\r\n#include \"xfile.h\"\r\n#if !defined(_WIN32) && !defined (_WIN64)\r\n//#include \"../../../Common/DocxFormat/Source/Base/ASCString.h\"\r\n#endif\r\n//#include <TCHAR.h>\r\n\r\n/*\r\n#ifndef WIN32\r\n    #ifdef _UNICODE\r\n        typedef wchar_t TCHAR;\r\n    #else\r\n        typedef char TCHAR;\r\n    #endif\r\n#endif\r\n*/\r\n\r\nclass DLL_EXP CxIOFile : public CxFile\r\n\t{\r\npublic:\r\n\tCxIOFile(FILE* fp = NULL)\r\n\t{\r\n\t\tm_fp = fp;\r\n\t\tm_bCloseFile = (bool)(fp==0);\r\n\t}\r\n\r\n\t~CxIOFile()\r\n\t{\r\n\t\tClose();\r\n\t}\r\n//////////////////////////////////////////////////////////\r\n\tbool Open(const TCHAR * filename, const TCHAR * mode)\r\n\t{\r\n#ifdef CXIMAGE_DONT_USE_LOAD_SAVE\r\n    return false;\r\n#else\r\n#if defined(_WIN32) || defined (_WIN64)\r\n\t\tif (m_fp) return false;\t// Can't re-open without closing first\r\n\r\n\t\tm_fp = _tfopen(filename, mode);\r\n\t\tif (!m_fp) return false;\r\n\r\n\t\tm_bCloseFile = true;\r\n#endif\r\n\r\n\t\treturn true;\r\n#endif // #ifdef CXIMAGE_DONT_USE_LOAD_SAVE\r\n\t}\r\n//////////////////////////////////////////////////////////\r\n\tvirtual bool Close()\r\n\t{\r\n\t\tint32_t iErr = 0;\r\n\t\tif ( (m_fp) && (m_bCloseFile) ){ \r\n\t\t\tiErr = fclose(m_fp);\r\n\t\t\tm_fp = NULL;\r\n\t\t}\r\n\t\treturn (bool)(iErr==0);\r\n\t}\r\n//////////////////////////////////////////////////////////\r\n\tvirtual size_t\tRead(void *buffer, size_t size, size_t count, void* limit_start = NULL, void* limit_end = NULL)\r\n\t{\r\n\t\tif (!m_fp) return 0;\r\n\t\tclamp_buffer(buffer, size, limit_start, limit_end);\r\n\t\treturn fread(buffer, size, count, m_fp);\r\n\t}\r\n//////////////////////////////////////////////////////////\r\n\tvirtual size_t\tWrite(const void *buffer, size_t size, size_t count)\r\n\t{\r\n\t\tif (!m_fp) return 0;\r\n\t\treturn fwrite(buffer, size, count, m_fp);\r\n\t}\r\n//////////////////////////////////////////////////////////\r\n\tvirtual bool Seek(int32_t offset, int32_t origin)\r\n\t{\r\n\t\tif (!m_fp) return false;\r\n\t\treturn (bool)(fseek(m_fp, offset, origin) == 0);\r\n\t}\r\n//////////////////////////////////////////////////////////\r\n\tvirtual int32_t Tell()\r\n\t{\r\n\t\tif (!m_fp) return 0;\r\n\t\treturn ftell(m_fp);\r\n\t}\r\n//////////////////////////////////////////////////////////\r\n\tvirtual int32_t\tSize()\r\n\t{\r\n\t\tif (!m_fp) return -1;\r\n\t\tint32_t pos,size;\r\n\t\tpos = ftell(m_fp);\r\n\t\tfseek(m_fp, 0, SEEK_END);\r\n\t\tsize = ftell(m_fp);\r\n\t\tfseek(m_fp, pos,SEEK_SET);\r\n\t\treturn size;\r\n\t}\r\n//////////////////////////////////////////////////////////\r\n\tvirtual bool\tFlush()\r\n\t{\r\n\t\tif (!m_fp) return false;\r\n\t\treturn (bool)(fflush(m_fp) == 0);\r\n\t}\r\n//////////////////////////////////////////////////////////\r\n\tvirtual bool\tEof()\r\n\t{\r\n\t\tif (!m_fp) return true;\r\n\t\treturn (bool)(feof(m_fp) != 0);\r\n\t}\r\n//////////////////////////////////////////////////////////\r\n\tvirtual int32_t\tError()\r\n\t{\r\n\t\tif (!m_fp) return -1;\r\n\t\treturn ferror(m_fp);\r\n\t}\r\n//////////////////////////////////////////////////////////\r\n\tvirtual bool PutC(uint8_t c)\r\n\t{\r\n\t\tif (!m_fp) return false;\r\n\t\treturn (bool)(fputc(c, m_fp) == c);\r\n\t}\r\n//////////////////////////////////////////////////////////\r\n\tvirtual int32_t\tGetC()\r\n\t{\r\n\t\tif (!m_fp) return EOF;\r\n\t\treturn getc(m_fp);\r\n\t}\r\n//////////////////////////////////////////////////////////\r\n\tvirtual char *\tGetS(char *string, int32_t n)\r\n\t{\r\n\t\tif (!m_fp) return NULL;\r\n\t\treturn fgets(string,n,m_fp);\r\n\t}\r\n//////////////////////////////////////////////////////////\r\n\tvirtual int32_t\tScanf(const char *format, void* output)\r\n\t{\r\n\t\tif (!m_fp) return EOF;\r\n\t\treturn fscanf(m_fp, format, output);\r\n\t}\r\n//////////////////////////////////////////////////////////\r\nprotected:\r\n\tFILE *m_fp;\r\n\tbool m_bCloseFile;\r\n\t};\r\n\r\n#endif\r\n", "\ufeff#include \"xmemfile.h\"\r\n\r\n//////////////////////////////////////////////////////////\r\nCxMemFile::CxMemFile(uint8_t* pBuffer, uint32_t size)\r\n{\r\n\tm_pBuffer = pBuffer;\r\n\tm_Position = 0;\r\n\tm_Size = m_Edge = size;\r\n\tm_bFreeOnClose = (bool)(pBuffer==0);\r\n\tm_bEOF = false;\r\n}\r\n//////////////////////////////////////////////////////////\r\nCxMemFile::~CxMemFile()\r\n{\r\n\tClose();\r\n}\r\n//////////////////////////////////////////////////////////\r\nbool CxMemFile::Close()\r\n{\r\n\tif ( (m_pBuffer) && (m_bFreeOnClose) ){\r\n\t\tfree(m_pBuffer);\r\n\t\tm_pBuffer = NULL;\r\n\t\tm_Size = 0;\r\n\t}\r\n\treturn true;\r\n}\r\n//////////////////////////////////////////////////////////\r\nbool CxMemFile::Open()\r\n{\r\n\tif (m_pBuffer) return false;\t// Can't re-open without closing first\r\n\r\n\tm_Position = m_Size = m_Edge = 0;\r\n\tm_pBuffer=(uint8_t*)malloc(1);\r\n\tm_bFreeOnClose = true;\r\n\r\n\treturn (m_pBuffer!=0);\r\n}\r\n//////////////////////////////////////////////////////////\r\nuint8_t* CxMemFile::GetBuffer(bool bDetachBuffer)\r\n{\r\n\t//can only detach, avoid inadvertantly attaching to\r\n\t// memory that may not be ours [Jason De Arte]\r\n\tif( bDetachBuffer )\r\n\t\tm_bFreeOnClose = false;\r\n\treturn m_pBuffer;\r\n}\r\n//////////////////////////////////////////////////////////\r\nsize_t CxMemFile::Read(void *buffer, size_t size, size_t count, void* limit_start, void* limit_end)\r\n{\r\n\tif (buffer==NULL) return 0;\r\n\r\n\tif (m_pBuffer==NULL) return 0;\r\n\tif (m_Position >= (int32_t)m_Size){\r\n\t\tm_bEOF = true;\r\n\t\treturn 0;\r\n    }\r\n\r\n\tint32_t nCount = (int32_t)(count*size);\r\n\tif (nCount == 0) return 0;\r\n\r\n\tint32_t nRead;\r\n\tif (m_Position + nCount > (int32_t)m_Size){\r\n\t\tm_bEOF = true;\r\n\t\tnRead = (m_Size - m_Position);\r\n\t} else\r\n\t\tnRead = nCount;\r\n\r\n\tmemcpy(buffer, m_pBuffer + m_Position, nRead);\r\n\tm_Position += nRead;\r\n\r\n\treturn (size_t)(nRead/size);\r\n}\r\n//////////////////////////////////////////////////////////\r\nsize_t CxMemFile::Write(const void *buffer, size_t size, size_t count)\r\n{\r\n\tm_bEOF = false;\r\n\tif (m_pBuffer==NULL) return 0;\r\n\tif (buffer==NULL) return 0;\r\n\r\n\tint32_t nCount = (int32_t)(count*size);\r\n\tif (nCount == 0) return 0;\r\n\r\n\tif (m_Position + nCount > m_Edge){\r\n\t\tif (!Alloc(m_Position + nCount)){\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n\r\n\tmemcpy(m_pBuffer + m_Position, buffer, nCount);\r\n\r\n\tm_Position += nCount;\r\n\r\n\tif (m_Position > (int32_t)m_Size) m_Size = m_Position;\r\n\t\r\n\treturn count;\r\n}\r\n//////////////////////////////////////////////////////////\r\nbool CxMemFile::Seek(int32_t offset, int32_t origin)\r\n{\r\n\tm_bEOF = false;\r\n\tif (m_pBuffer==NULL) return false;\r\n\tint32_t lNewPos = m_Position;\r\n\r\n\tif (origin == SEEK_SET)\t\t lNewPos = offset;\r\n\telse if (origin == SEEK_CUR) lNewPos += offset;\r\n\telse if (origin == SEEK_END) lNewPos = m_Size + offset;\r\n\telse return false;\r\n\r\n\tif (lNewPos < 0) lNewPos = 0;\r\n\r\n\tm_Position = lNewPos;\r\n\treturn true;\r\n}\r\n//////////////////////////////////////////////////////////\r\nint32_t CxMemFile::Tell()\r\n{\r\n\tif (m_pBuffer==NULL) return -1;\r\n\treturn m_Position;\r\n}\r\n//////////////////////////////////////////////////////////\r\nint32_t CxMemFile::Size()\r\n{\r\n\tif (m_pBuffer==NULL) return -1;\r\n\treturn m_Size;\r\n}\r\n//////////////////////////////////////////////////////////\r\nbool CxMemFile::Flush()\r\n{\r\n\tif (m_pBuffer==NULL) return false;\r\n\treturn true;\r\n}\r\n//////////////////////////////////////////////////////////\r\nbool CxMemFile::Eof()\r\n{\r\n\tif (m_pBuffer==NULL) return true;\r\n\treturn m_bEOF;\r\n}\r\n//////////////////////////////////////////////////////////\r\nint32_t CxMemFile::Error()\r\n{\r\n\tif (m_pBuffer==NULL) return -1;\r\n\treturn (m_Position > (int32_t)m_Size);\r\n}\r\n//////////////////////////////////////////////////////////\r\nbool CxMemFile::PutC(uint8_t c)\r\n{\r\n\tm_bEOF = false;\r\n\tif (m_pBuffer==NULL) return false;\r\n\r\n\tif (m_Position >= m_Edge){\r\n\t\tif (!Alloc(m_Position + 1)){\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n\r\n\tm_pBuffer[m_Position++] = c;\r\n\r\n\tif (m_Position > (int32_t)m_Size) m_Size = m_Position;\r\n\t\r\n\treturn true;\r\n}\r\n//////////////////////////////////////////////////////////\r\nint32_t CxMemFile::GetC()\r\n{\r\n\tif (m_pBuffer==NULL || m_Position >= (int32_t)m_Size){\r\n\t\tm_bEOF = true;\r\n\t\treturn EOF;\r\n\t}\r\n\treturn *(uint8_t*)((uint8_t*)m_pBuffer + m_Position++);\r\n}\r\n//////////////////////////////////////////////////////////\r\nchar * CxMemFile::GetS(char *string, int32_t n)\r\n{\r\n\tn--;\r\n\tint32_t c,i=0;\r\n\twhile (i<n){\r\n\t\tc = GetC();\r\n\t\tif (c == EOF) return 0;\r\n\t\tstring[i++] = (char)c;\r\n\t\tif (c == '\\n') break;\r\n\t}\r\n\tstring[i] = 0;\r\n\treturn string;\r\n}\r\n//////////////////////////////////////////////////////////\r\nint32_t\tCxMemFile::Scanf(const char *format, void* output)\r\n{\r\n\treturn 0;\r\n}\r\n//////////////////////////////////////////////////////////\r\nbool CxMemFile::Alloc(uint32_t dwNewLen)\r\n{\r\n\tif (dwNewLen > (uint32_t)m_Edge)\r\n\t{\r\n\t\t// find new buffer size\r\n\t\tuint32_t dwNewBufferSize = (uint32_t)(((dwNewLen>>16)+1)<<16);\r\n\r\n\t\t// allocate new buffer\r\n\t\tif (m_pBuffer == NULL) m_pBuffer = (uint8_t*)malloc(dwNewBufferSize);\r\n\t\telse\tm_pBuffer = (uint8_t*)realloc(m_pBuffer, dwNewBufferSize);\r\n\t\t// I own this buffer now (caller knows nothing about it)\r\n\t\tm_bFreeOnClose = true;\r\n\r\n\t\tm_Edge = dwNewBufferSize;\r\n\t}\r\n\treturn (m_pBuffer!=0);\r\n}\r\n//////////////////////////////////////////////////////////\r\nvoid CxMemFile::Free()\r\n{\r\n\tClose();\r\n}\r\n//////////////////////////////////////////////////////////\r\n", "\ufeff#if !defined(__xmemfile_h)\r\n#define __xmemfile_h\r\n\r\n#include \"xfile.h\"\r\n\r\n//////////////////////////////////////////////////////////\r\nclass DLL_EXP CxMemFile : public CxFile\r\n{\r\npublic:\r\n\tCxMemFile(uint8_t* pBuffer = NULL, uint32_t size = 0);\r\n\t~CxMemFile();\r\n\r\n\tbool Open();\r\n\tuint8_t* GetBuffer(bool bDetachBuffer = true);\r\n\r\n\tvirtual bool\tClose();\r\n\tvirtual size_t\tRead(void *buffer, size_t size, size_t count, void* limit_start = NULL, void* limit_end = NULL);\r\n\tvirtual size_t\tWrite(const void *buffer, size_t size, size_t count);\r\n\tvirtual bool\tSeek(int32_t offset, int32_t origin);\r\n\tvirtual int32_t\tTell();\r\n\tvirtual int32_t\tSize();\r\n\tvirtual bool\tFlush();\r\n\tvirtual bool\tEof();\r\n\tvirtual int32_t\tError();\r\n\tvirtual bool\tPutC(uint8_t c);\r\n\tvirtual int32_t\tGetC();\r\n\tvirtual char *\tGetS(char *string, int32_t n);\r\n\tvirtual int32_t\tScanf(const char *format, void* output);\r\n\r\nprotected:\r\n\tbool\tAlloc(uint32_t nBytes);\r\n\tvoid\tFree();\r\n\r\n\tuint8_t*\tm_pBuffer;\r\n\tuint32_t\tm_Size;\r\n\tbool\tm_bFreeOnClose;\r\n\tint32_t\tm_Position;\t//current position\r\n\tint32_t\tm_Edge;\t\t//buffer size\r\n\tbool\tm_bEOF;\r\n};\r\n\r\n#endif\r\n", "/*\n * Copyright (c) 1999-2000 Image Power, Inc. and the University of\n *   British Columbia.\n * Copyright (c) 2001-2003 Michael David Adams.\n * All rights reserved.\n */\n\n/* __START_OF_JASPER_LICENSE__\n * \n * JasPer License Version 2.0\n * \n * Copyright (c) 2001-2006 Michael David Adams\n * Copyright (c) 1999-2000 Image Power, Inc.\n * Copyright (c) 1999-2000 The University of British Columbia\n * \n * All rights reserved.\n * \n * Permission is hereby granted, free of charge, to any person (the\n * \"User\") obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without restriction,\n * including without limitation the rights to use, copy, modify, merge,\n * publish, distribute, and/or sell copies of the Software, and to permit\n * persons to whom the Software is furnished to do so, subject to the\n * following conditions:\n * \n * 1.  The above copyright notices and this permission notice (which\n * includes the disclaimer below) shall be included in all copies or\n * substantial portions of the Software.\n * \n * 2.  The name of a copyright holder shall not be used to endorse or\n * promote products derived from the Software without specific prior\n * written permission.\n * \n * THIS DISCLAIMER OF WARRANTY CONSTITUTES AN ESSENTIAL PART OF THIS\n * LICENSE.  NO USE OF THE SOFTWARE IS AUTHORIZED HEREUNDER EXCEPT UNDER\n * THIS DISCLAIMER.  THE SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS\n * \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING\n * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n * PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY RIGHTS.  IN NO\n * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL\n * INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING\n * FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,\n * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION\n * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  NO ASSURANCES ARE\n * PROVIDED BY THE COPYRIGHT HOLDERS THAT THE SOFTWARE DOES NOT INFRINGE\n * THE PATENT OR OTHER INTELLECTUAL PROPERTY RIGHTS OF ANY OTHER ENTITY.\n * EACH COPYRIGHT HOLDER DISCLAIMS ANY LIABILITY TO THE USER FOR CLAIMS\n * BROUGHT BY ANY OTHER ENTITY BASED ON INFRINGEMENT OF INTELLECTUAL\n * PROPERTY RIGHTS OR OTHERWISE.  AS A CONDITION TO EXERCISING THE RIGHTS\n * GRANTED HEREUNDER, EACH USER HEREBY ASSUMES SOLE RESPONSIBILITY TO SECURE\n * ANY OTHER INTELLECTUAL PROPERTY RIGHTS NEEDED, IF ANY.  THE SOFTWARE\n * IS NOT FAULT-TOLERANT AND IS NOT INTENDED FOR USE IN MISSION-CRITICAL\n * SYSTEMS, SUCH AS THOSE USED IN THE OPERATION OF NUCLEAR FACILITIES,\n * AIRCRAFT NAVIGATION OR COMMUNICATION SYSTEMS, AIR TRAFFIC CONTROL\n * SYSTEMS, DIRECT LIFE SUPPORT MACHINES, OR WEAPONS SYSTEMS, IN WHICH\n * THE FAILURE OF THE SOFTWARE OR SYSTEM COULD LEAD DIRECTLY TO DEATH,\n * PERSONAL INJURY, OR SEVERE PHYSICAL OR ENVIRONMENTAL DAMAGE (\"HIGH\n * RISK ACTIVITIES\").  THE COPYRIGHT HOLDERS SPECIFICALLY DISCLAIM ANY\n * EXPRESS OR IMPLIED WARRANTY OF FITNESS FOR HIGH RISK ACTIVITIES.\n * \n * __END_OF_JASPER_LICENSE__\n */\n\n/*\n * $Id$\n */\n\n/******************************************************************************\\\n* Includes.\n\\******************************************************************************/\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n\n#include \"jasper/jas_types.h\"\n#include \"jasper/jas_math.h\"\n#include \"jasper/jas_tvp.h\"\n#include \"jasper/jas_malloc.h\"\n#include \"jasper/jas_debug.h\"\n\n#include \"jpc_fix.h\"\n#include \"jpc_dec.h\"\n#include \"jpc_cs.h\"\n#include \"jpc_mct.h\"\n#include \"jpc_t2dec.h\"\n#include \"jpc_t1dec.h\"\n#include \"jpc_math.h\"\n\n/******************************************************************************\\\n*\n\\******************************************************************************/\n\n#define\tJPC_MHSOC\t0x0001\n  /* In the main header, expecting a SOC marker segment. */\n#define\tJPC_MHSIZ\t0x0002\n  /* In the main header, expecting a SIZ marker segment. */\n#define\tJPC_MH\t\t0x0004\n  /* In the main header, expecting \"other\" marker segments. */\n#define\tJPC_TPHSOT\t0x0008\n  /* In a tile-part header, expecting a SOT marker segment. */\n#define\tJPC_TPH\t\t0x0010\n  /* In a tile-part header, expecting \"other\" marker segments. */\n#define\tJPC_MT\t\t0x0020\n  /* In the main trailer. */\n\ntypedef struct {\n\n\tuint_fast16_t id;\n\t/* The marker segment type. */\n\n\tint validstates;\n\t/* The states in which this type of marker segment can be\n\t  validly encountered. */\n\n\tint (*action)(jpc_dec_t *dec, jpc_ms_t *ms);\n\t/* The action to take upon encountering this type of marker segment. */\n\n} jpc_dec_mstabent_t;\n\n/******************************************************************************\\\n*\n\\******************************************************************************/\n\n/* COD/COC parameters have been specified. */\n#define\tJPC_CSET\t0x0001\n/* QCD/QCC parameters have been specified. */\n#define\tJPC_QSET\t0x0002\n/* COD/COC parameters set from a COC marker segment. */\n#define\tJPC_COC\t0x0004\n/* QCD/QCC parameters set from a QCC marker segment. */\n#define\tJPC_QCC\t0x0008\n\n/******************************************************************************\\\n* Local function prototypes.\n\\******************************************************************************/\n\nstatic int jpc_dec_dump(jpc_dec_t *dec, FILE *out);\n\njpc_ppxstab_t *jpc_ppxstab_create(void);\nvoid jpc_ppxstab_destroy(jpc_ppxstab_t *tab);\nint jpc_ppxstab_grow(jpc_ppxstab_t *tab, int maxents);\nint jpc_ppxstab_insert(jpc_ppxstab_t *tab, jpc_ppxstabent_t *ent);\njpc_streamlist_t *jpc_ppmstabtostreams(jpc_ppxstab_t *tab);\nint jpc_pptstabwrite(jas_stream_t *out, jpc_ppxstab_t *tab);\njpc_ppxstabent_t *jpc_ppxstabent_create(void);\nvoid jpc_ppxstabent_destroy(jpc_ppxstabent_t *ent);\n\nint jpc_streamlist_numstreams(jpc_streamlist_t *streamlist);\njpc_streamlist_t *jpc_streamlist_create(void);\nint jpc_streamlist_insert(jpc_streamlist_t *streamlist, int streamno,\n  jas_stream_t *stream);\njas_stream_t *jpc_streamlist_remove(jpc_streamlist_t *streamlist, int streamno);\nvoid jpc_streamlist_destroy(jpc_streamlist_t *streamlist);\njas_stream_t *jpc_streamlist_get(jpc_streamlist_t *streamlist, int streamno);\n\nstatic void jpc_dec_cp_resetflags(jpc_dec_cp_t *cp);\nstatic jpc_dec_cp_t *jpc_dec_cp_create(uint_fast16_t numcomps);\nstatic int jpc_dec_cp_isvalid(jpc_dec_cp_t *cp);\nstatic jpc_dec_cp_t *jpc_dec_cp_copy(jpc_dec_cp_t *cp);\nstatic int jpc_dec_cp_setfromcod(jpc_dec_cp_t *cp, jpc_cod_t *cod);\nstatic int jpc_dec_cp_setfromcoc(jpc_dec_cp_t *cp, jpc_coc_t *coc);\nstatic int jpc_dec_cp_setfromcox(jpc_dec_cp_t *cp, jpc_dec_ccp_t *ccp,\n  jpc_coxcp_t *compparms, int flags);\nstatic int jpc_dec_cp_setfromqcd(jpc_dec_cp_t *cp, jpc_qcd_t *qcd);\nstatic int jpc_dec_cp_setfromqcc(jpc_dec_cp_t *cp, jpc_qcc_t *qcc);\nstatic int jpc_dec_cp_setfromqcx(jpc_dec_cp_t *cp, jpc_dec_ccp_t *ccp,\n  jpc_qcxcp_t *compparms, int flags);\nstatic int jpc_dec_cp_setfromrgn(jpc_dec_cp_t *cp, jpc_rgn_t *rgn);\nstatic int jpc_dec_cp_prepare(jpc_dec_cp_t *cp);\nstatic void jpc_dec_cp_destroy(jpc_dec_cp_t *cp);\nstatic int jpc_dec_cp_setfrompoc(jpc_dec_cp_t *cp, jpc_poc_t *poc, int reset);\nstatic int jpc_pi_addpchgfrompoc(jpc_pi_t *pi, jpc_poc_t *poc);\n\nstatic int jpc_dec_decode(jpc_dec_t *dec);\nstatic jpc_dec_t *jpc_dec_create(jpc_dec_importopts_t *impopts, jas_stream_t *in);\nstatic void jpc_dec_destroy(jpc_dec_t *dec);\nstatic void jpc_dequantize(jas_matrix_t *x, jpc_fix_t absstepsize);\nstatic void jpc_undo_roi(jas_matrix_t *x, int roishift, int bgshift, int numbps);\nstatic jpc_fix_t jpc_calcabsstepsize(int stepsize, int numbits);\nstatic int jpc_dec_tiledecode(jpc_dec_t *dec, jpc_dec_tile_t *tile);\nstatic int jpc_dec_tileinit(jpc_dec_t *dec, jpc_dec_tile_t *tile);\nstatic int jpc_dec_tilefini(jpc_dec_t *dec, jpc_dec_tile_t *tile);\nstatic int jpc_dec_process_soc(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_sot(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_sod(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_eoc(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_siz(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_cod(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_coc(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_rgn(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_qcd(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_qcc(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_poc(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_ppm(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_ppt(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_com(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_unk(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_crg(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_parseopts(char *optstr, jpc_dec_importopts_t *opts);\n\nstatic jpc_dec_mstabent_t *jpc_dec_mstab_lookup(uint_fast16_t id);\n\n/******************************************************************************\\\n* Global data.\n\\******************************************************************************/\n\njpc_dec_mstabent_t jpc_dec_mstab[] = {\n\t{JPC_MS_SOC, JPC_MHSOC, jpc_dec_process_soc},\n\t{JPC_MS_SOT, JPC_MH | JPC_TPHSOT, jpc_dec_process_sot},\n\t{JPC_MS_SOD, JPC_TPH, jpc_dec_process_sod},\n\t{JPC_MS_EOC, JPC_TPHSOT, jpc_dec_process_eoc},\n\t{JPC_MS_SIZ, JPC_MHSIZ, jpc_dec_process_siz},\n\t{JPC_MS_COD, JPC_MH | JPC_TPH, jpc_dec_process_cod},\n\t{JPC_MS_COC, JPC_MH | JPC_TPH, jpc_dec_process_coc},\n\t{JPC_MS_RGN, JPC_MH | JPC_TPH, jpc_dec_process_rgn},\n\t{JPC_MS_QCD, JPC_MH | JPC_TPH, jpc_dec_process_qcd},\n\t{JPC_MS_QCC, JPC_MH | JPC_TPH, jpc_dec_process_qcc},\n\t{JPC_MS_POC, JPC_MH | JPC_TPH, jpc_dec_process_poc},\n\t{JPC_MS_TLM, JPC_MH, 0},\n\t{JPC_MS_PLM, JPC_MH, 0},\n\t{JPC_MS_PLT, JPC_TPH, 0},\n\t{JPC_MS_PPM, JPC_MH, jpc_dec_process_ppm},\n\t{JPC_MS_PPT, JPC_TPH, jpc_dec_process_ppt},\n\t{JPC_MS_SOP, 0, 0},\n\t{JPC_MS_CRG, JPC_MH, jpc_dec_process_crg},\n\t{JPC_MS_COM, JPC_MH | JPC_TPH, jpc_dec_process_com},\n\t{0, JPC_MH | JPC_TPH, jpc_dec_process_unk}\n};\n\n/******************************************************************************\\\n* The main entry point for the JPEG-2000 decoder.\n\\******************************************************************************/\n\njas_image_t *jpc_decode(jas_stream_t *in, char *optstr)\n{\n\tjpc_dec_importopts_t opts;\n\tjpc_dec_t *dec;\n\tjas_image_t *image;\n\n\tdec = 0;\n\n\tif (jpc_dec_parseopts(optstr, &opts)) {\n\t\tgoto error;\n\t}\n\n\tjpc_initluts();\n\n\tif (!(dec = jpc_dec_create(&opts, in))) {\n\t\tgoto error;\n\t}\n\n\t/* Do most of the work. */\n\tif (jpc_dec_decode(dec)) {\n\t\tgoto error;\n\t}\n\n\tif (jas_image_numcmpts(dec->image) >= 3) {\n\t\tjas_image_setclrspc(dec->image, JAS_CLRSPC_SRGB);\n\t\tjas_image_setcmpttype(dec->image, 0,\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_R));\n\t\tjas_image_setcmpttype(dec->image, 1,\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_G));\n\t\tjas_image_setcmpttype(dec->image, 2,\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_B));\n\t} else {\n\t\tjas_image_setclrspc(dec->image, JAS_CLRSPC_SGRAY);\n\t\tjas_image_setcmpttype(dec->image, 0,\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_GRAY_Y));\n\t}\n\n\t/* Save the return value. */\n\timage = dec->image;\n\n\t/* Stop the image from being discarded. */\n\tdec->image = 0;\n\n\t/* Destroy decoder. */\n\tjpc_dec_destroy(dec);\n\n\treturn image;\n\nerror:\n\tif (dec) {\n\t\tjpc_dec_destroy(dec);\n\t}\n\treturn 0;\n}\n\ntypedef enum {\n\tOPT_MAXLYRS,\n\tOPT_MAXPKTS,\n\tOPT_DEBUG\n} optid_t;\n\njas_taginfo_t decopts[] = {\n\t{OPT_MAXLYRS, \"maxlyrs\"},\n\t{OPT_MAXPKTS, \"maxpkts\"},\n\t{OPT_DEBUG, \"debug\"},\n\t{-1, 0}\n};\n\nstatic int jpc_dec_parseopts(char *optstr, jpc_dec_importopts_t *opts)\n{\n\tjas_tvparser_t *tvp;\n\n\topts->debug = 0;\n\topts->maxlyrs = JPC_MAXLYRS;\n\topts->maxpkts = -1;\n\n\tif (!(tvp = jas_tvparser_create(optstr ? optstr : \"\"))) {\n\t\treturn -1;\n\t}\n\n\twhile (!jas_tvparser_next(tvp)) {\n\t\tswitch (jas_taginfo_nonull(jas_taginfos_lookup(decopts,\n\t\t  jas_tvparser_gettag(tvp)))->id) {\n\t\tcase OPT_MAXLYRS:\n\t\t\topts->maxlyrs = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_DEBUG:\n\t\t\topts->debug = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_MAXPKTS:\n\t\t\topts->maxpkts = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tjas_eprintf(\"warning: ignoring invalid option %s\\n\",\n\t\t\t  jas_tvparser_gettag(tvp));\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tjas_tvparser_destroy(tvp);\n\n\treturn 0;\n}\n\n/******************************************************************************\\\n* Code for table-driven code stream decoder.\n\\******************************************************************************/\n\nstatic jpc_dec_mstabent_t *jpc_dec_mstab_lookup(uint_fast16_t id)\n{\n\tjpc_dec_mstabent_t *mstabent;\n\tfor (mstabent = jpc_dec_mstab; mstabent->id != 0; ++mstabent) {\n\t\tif (mstabent->id == id) {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn mstabent;\n}\n\nstatic int jpc_dec_decode(jpc_dec_t *dec)\n{\n\tjpc_ms_t *ms;\n\tjpc_dec_mstabent_t *mstabent;\n\tint ret;\n\tjpc_cstate_t *cstate;\n\n\tif (!(cstate = jpc_cstate_create())) {\n\t\treturn -1;\n\t}\n\tdec->cstate = cstate;\n\n\t/* Initially, we should expect to encounter a SOC marker segment. */\n\tdec->state = JPC_MHSOC;\n\n\tfor (;;) {\n\n\t\t/* Get the next marker segment in the code stream. */\n\t\tif (!(ms = jpc_getms(dec->in, cstate))) {\n\t\t\tjas_eprintf(\"cannot get marker segment\\n\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tmstabent = jpc_dec_mstab_lookup(ms->id);\n\t\tassert(mstabent);\n\n\t\t/* Ensure that this type of marker segment is permitted\n\t\t  at this point in the code stream. */\n\t\tif (!(dec->state & mstabent->validstates)) {\n\t\t\tjas_eprintf(\"unexpected marker segment type\\n\");\n\t\t\tjpc_ms_destroy(ms);\n\t\t\treturn -1;\n\t\t}\n\n\t\t/* Process the marker segment. */\n\t\tif (mstabent->action) {\n\t\t\tret = (*mstabent->action)(dec, ms);\n\t\t} else {\n\t\t\t/* No explicit action is required. */\n\t\t\tret = 0;\n\t\t}\n\n\t\t/* Destroy the marker segment. */\n\t\tjpc_ms_destroy(ms);\n\n\t\tif (ret < 0) {\n\t\t\treturn -1;\n\t\t} else if (ret > 0) {\n\t\t\tbreak;\n\t\t}\n\n\t}\n\n\treturn 0;\n}\n\nstatic int jpc_dec_process_crg(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tint cmptno;\n\tjpc_dec_cmpt_t *cmpt;\n\tjpc_crg_t *crg;\n\n\tcrg = &ms->parms.crg;\n\tfor (cmptno = 0, cmpt = dec->cmpts; cmptno < dec->numcomps; ++cmptno,\n\t  ++cmpt) {\n\t\t/* Ignore the information in the CRG marker segment for now.\n\t\t  This information serves no useful purpose for decoding anyhow.\n\t\t  Some other parts of the code need to be changed if these lines\n\t\t  are uncommented.\n\t\tcmpt->hsubstep = crg->comps[cmptno].hoff;\n\t\tcmpt->vsubstep = crg->comps[cmptno].voff;\n\t\t*/\n\t}\n\treturn 0;\n}\n\nstatic int jpc_dec_process_soc(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\t/* Eliminate warnings about unused variables. */\n\tms = 0;\n\n\t/* We should expect to encounter a SIZ marker segment next. */\n\tdec->state = JPC_MHSIZ;\n\n\treturn 0;\n}\n\nstatic int jpc_dec_process_sot(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tjpc_dec_tile_t *tile;\n\tjpc_sot_t *sot = &ms->parms.sot;\n\tjas_image_cmptparm_t *compinfos;\n\tjas_image_cmptparm_t *compinfo;\n\tjpc_dec_cmpt_t *cmpt;\n\tint cmptno;\n\n\tif (dec->state == JPC_MH) {\n\n\t\tcompinfos = jas_malloc(dec->numcomps * sizeof(jas_image_cmptparm_t));\n\t\tassert(compinfos);\n\t\tfor (cmptno = 0, cmpt = dec->cmpts, compinfo = compinfos;\n\t\t  cmptno < dec->numcomps; ++cmptno, ++cmpt, ++compinfo) {\n\t\t\tcompinfo->tlx = 0;\n\t\t\tcompinfo->tly = 0;\n\t\t\tcompinfo->prec = cmpt->prec;\n\t\t\tcompinfo->sgnd = cmpt->sgnd;\n\t\t\tcompinfo->width = cmpt->width;\n\t\t\tcompinfo->height = cmpt->height;\n\t\t\tcompinfo->hstep = cmpt->hstep;\n\t\t\tcompinfo->vstep = cmpt->vstep;\n\t\t}\n\n\t\tif (!(dec->image = jas_image_create(dec->numcomps, compinfos,\n\t\t  JAS_CLRSPC_UNKNOWN))) {\n\t\t\treturn -1;\n\t\t}\n\t\tjas_free(compinfos);\n\n\t\t/* Is the packet header information stored in PPM marker segments in\n\t\t  the main header? */\n\t\tif (dec->ppmstab) {\n\t\t\t/* Convert the PPM marker segment data into a collection of streams\n\t\t\t  (one stream per tile-part). */\n\t\t\tif (!(dec->pkthdrstreams = jpc_ppmstabtostreams(dec->ppmstab))) {\n\t\t\t\tabort();\n\t\t\t}\n\t\t\tjpc_ppxstab_destroy(dec->ppmstab);\n\t\t\tdec->ppmstab = 0;\n\t\t}\n\t}\n\n\tif (sot->len > 0) {\n\t\tdec->curtileendoff = jas_stream_getrwcount(dec->in) - ms->len -\n\t\t  4 + sot->len;\n\t} else {\n\t\tdec->curtileendoff = 0;\n\t}\n\n\tif (JAS_CAST(int, sot->tileno) > dec->numtiles) {\n\t\tjas_eprintf(\"invalid tile number in SOT marker segment\\n\");\n\t\treturn -1;\n\t}\n\t/* Set the current tile. */\n\tdec->curtile = &dec->tiles[sot->tileno];\n\ttile = dec->curtile;\n\t/* Ensure that this is the expected part number. */\n\tif (sot->partno != tile->partno) {\n\t\treturn -1;\n\t}\n\tif (tile->numparts > 0 && sot->partno >= tile->numparts) {\n\t\treturn -1;\n\t}\n\tif (!tile->numparts && sot->numparts > 0) {\n\t\ttile->numparts = sot->numparts;\n\t}\n\n\ttile->pptstab = 0;\n\n\tswitch (tile->state) {\n\tcase JPC_TILE_INIT:\n\t\t/* This is the first tile-part for this tile. */\n\t\ttile->state = JPC_TILE_ACTIVE;\n\t\tassert(!tile->cp);\n\t\tif (!(tile->cp = jpc_dec_cp_copy(dec->cp))) {\n\t\t\treturn -1;\n\t\t}\n\t\tjpc_dec_cp_resetflags(dec->cp);\n\t\tbreak;\n\tdefault:\n\t\tif (sot->numparts == sot->partno - 1) {\n\t\t\ttile->state = JPC_TILE_ACTIVELAST;\n\t\t}\n\t\tbreak;\n\t}\n\n\t/* Note: We do not increment the expected tile-part number until\n\t  all processing for this tile-part is complete. */\n\n\t/* We should expect to encounter other tile-part header marker\n\t  segments next. */\n\tdec->state = JPC_TPH;\n\n\treturn 0;\n}\n\nstatic int jpc_dec_process_sod(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tjpc_dec_tile_t *tile;\n\tint pos;\n\n\t/* Eliminate compiler warnings about unused variables. */\n\tms = 0;\n\n\tif (!(tile = dec->curtile)) {\n\t\treturn -1;\n\t}\n\n\tif (!tile->partno) {\n\t\tif (!jpc_dec_cp_isvalid(tile->cp)) {\n\t\t\treturn -1;\n\t\t}\n\t\tjpc_dec_cp_prepare(tile->cp);\n\t\tif (jpc_dec_tileinit(dec, tile)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t/* Are packet headers stored in the main header or tile-part header? */\n\tif (dec->pkthdrstreams) {\n\t\t/* Get the stream containing the packet header data for this\n\t\t  tile-part. */\n\t\tif (!(tile->pkthdrstream = jpc_streamlist_remove(dec->pkthdrstreams, 0))) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (tile->pptstab) {\n\t\tif (!tile->pkthdrstream) {\n\t\t\tif (!(tile->pkthdrstream = jas_stream_memopen(0, 0))) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tpos = jas_stream_tell(tile->pkthdrstream);\n\t\tjas_stream_seek(tile->pkthdrstream, 0, SEEK_END);\n\t\tif (jpc_pptstabwrite(tile->pkthdrstream, tile->pptstab)) {\n\t\t\treturn -1;\n\t\t}\n\t\tjas_stream_seek(tile->pkthdrstream, pos, SEEK_SET);\n\t\tjpc_ppxstab_destroy(tile->pptstab);\n\t\ttile->pptstab = 0;\n\t}\n\n\tif (jas_getdbglevel() >= 10) {\n\t\tjpc_dec_dump(dec, stderr);\n\t}\n\n\tif (jpc_dec_decodepkts(dec, (tile->pkthdrstream) ? tile->pkthdrstream :\n\t  dec->in, dec->in)) {\n\t\tjas_eprintf(\"jpc_dec_decodepkts failed\\n\");\n\t\treturn -1;\n\t}\n\n\t/* Gobble any unconsumed tile data. */\n\tif (dec->curtileendoff > 0) {\n\t\tlong curoff;\n\t\tuint_fast32_t n;\n\t\tcuroff = jas_stream_getrwcount(dec->in);\n\t\tif (curoff < dec->curtileendoff) {\n\t\t\tn = dec->curtileendoff - curoff;\n\t\t\tjas_eprintf(\"warning: ignoring trailing garbage (%lu bytes)\\n\",\n\t\t\t  (unsigned long) n);\n\n\t\t\twhile (n-- > 0) {\n\t\t\t\tif (jas_stream_getc(dec->in) == EOF) {\n\t\t\t\t\tjas_eprintf(\"read error\\n\");\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (curoff > dec->curtileendoff) {\n\t\t\tjas_eprintf(\"warning: not enough tile data (%lu bytes)\\n\",\n\t\t\t  (unsigned long) curoff - dec->curtileendoff);\n\t\t}\n\n\t}\n\n\tif (tile->numparts > 0 && tile->partno == tile->numparts - 1) {\n\t\tif (jpc_dec_tiledecode(dec, tile)) {\n\t\t\treturn -1;\n\t\t}\n\t\tjpc_dec_tilefini(dec, tile);\n\t}\n\n\tdec->curtile = 0;\n\n\t/* Increment the expected tile-part number. */\n\t++tile->partno;\n\n\t/* We should expect to encounter a SOT marker segment next. */\n\tdec->state = JPC_TPHSOT;\n\n\treturn 0;\n}\n\nstatic int jpc_dec_tileinit(jpc_dec_t *dec, jpc_dec_tile_t *tile)\n{\n\tjpc_dec_tcomp_t *tcomp;\n\tint compno;\n\tint rlvlno;\n\tjpc_dec_rlvl_t *rlvl;\n\tjpc_dec_band_t *band;\n\tjpc_dec_prc_t *prc;\n\tint bndno;\n\tjpc_tsfb_band_t *bnd;\n\tint bandno;\n\tjpc_dec_ccp_t *ccp;\n\tint prccnt;\n\tjpc_dec_cblk_t *cblk;\n\tint cblkcnt;\n\tuint_fast32_t tlprcxstart;\n\tuint_fast32_t tlprcystart;\n\tuint_fast32_t brprcxend;\n\tuint_fast32_t brprcyend;\n\tuint_fast32_t tlcbgxstart;\n\tuint_fast32_t tlcbgystart;\n\tuint_fast32_t brcbgxend;\n\tuint_fast32_t brcbgyend;\n\tuint_fast32_t cbgxstart;\n\tuint_fast32_t cbgystart;\n\tuint_fast32_t cbgxend;\n\tuint_fast32_t cbgyend;\n\tuint_fast32_t tlcblkxstart;\n\tuint_fast32_t tlcblkystart;\n\tuint_fast32_t brcblkxend;\n\tuint_fast32_t brcblkyend;\n\tuint_fast32_t cblkxstart;\n\tuint_fast32_t cblkystart;\n\tuint_fast32_t cblkxend;\n\tuint_fast32_t cblkyend;\n\tuint_fast32_t tmpxstart;\n\tuint_fast32_t tmpystart;\n\tuint_fast32_t tmpxend;\n\tuint_fast32_t tmpyend;\n\tjpc_dec_cp_t *cp;\n\tjpc_tsfb_band_t bnds[64];\n\tjpc_pchg_t *pchg;\n\tint pchgno;\n\tjpc_dec_cmpt_t *cmpt;\n\n\tcp = tile->cp;\n\ttile->realmode = 0;\n\tif (cp->mctid == JPC_MCT_ICT) {\n\t\ttile->realmode = 1;\n\t}\n\n\tfor (compno = 0, tcomp = tile->tcomps, cmpt = dec->cmpts; compno <\n\t  dec->numcomps; ++compno, ++tcomp, ++cmpt) {\n\t\tccp = &tile->cp->ccps[compno];\n\t\tif (ccp->qmfbid == JPC_COX_INS) {\n\t\t\ttile->realmode = 1;\n\t\t}\n\t\ttcomp->numrlvls = ccp->numrlvls;\n\t\tif (!(tcomp->rlvls = jas_malloc(tcomp->numrlvls *\n\t\t  sizeof(jpc_dec_rlvl_t)))) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (!(tcomp->data = jas_seq2d_create(JPC_CEILDIV(tile->xstart,\n\t\t  cmpt->hstep), JPC_CEILDIV(tile->ystart, cmpt->vstep),\n\t\t  JPC_CEILDIV(tile->xend, cmpt->hstep), JPC_CEILDIV(tile->yend,\n\t\t  cmpt->vstep)))) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (!(tcomp->tsfb = jpc_cod_gettsfb(ccp->qmfbid,\n\t\t  tcomp->numrlvls - 1))) {\n\t\t\treturn -1;\n\t\t}\n{\n\tjpc_tsfb_getbands(tcomp->tsfb, jas_seq2d_xstart(tcomp->data), jas_seq2d_ystart(tcomp->data), jas_seq2d_xend(tcomp->data), jas_seq2d_yend(tcomp->data), bnds);\n}\n\t\tfor (rlvlno = 0, rlvl = tcomp->rlvls; rlvlno < tcomp->numrlvls;\n\t\t  ++rlvlno, ++rlvl) {\nrlvl->bands = 0;\n\t\t\trlvl->xstart = JPC_CEILDIVPOW2(tcomp->xstart,\n\t\t\t  tcomp->numrlvls - 1 - rlvlno);\n\t\t\trlvl->ystart = JPC_CEILDIVPOW2(tcomp->ystart,\n\t\t\t  tcomp->numrlvls - 1 - rlvlno);\n\t\t\trlvl->xend = JPC_CEILDIVPOW2(tcomp->xend,\n\t\t\t  tcomp->numrlvls - 1 - rlvlno);\n\t\t\trlvl->yend = JPC_CEILDIVPOW2(tcomp->yend,\n\t\t\t  tcomp->numrlvls - 1 - rlvlno);\n\t\t\trlvl->prcwidthexpn = ccp->prcwidthexpns[rlvlno];\n\t\t\trlvl->prcheightexpn = ccp->prcheightexpns[rlvlno];\n\t\t\ttlprcxstart = JPC_FLOORDIVPOW2(rlvl->xstart,\n\t\t\t  rlvl->prcwidthexpn) << rlvl->prcwidthexpn;\n\t\t\ttlprcystart = JPC_FLOORDIVPOW2(rlvl->ystart,\n\t\t\t  rlvl->prcheightexpn) << rlvl->prcheightexpn;\n\t\t\tbrprcxend = JPC_CEILDIVPOW2(rlvl->xend,\n\t\t\t  rlvl->prcwidthexpn) << rlvl->prcwidthexpn;\n\t\t\tbrprcyend = JPC_CEILDIVPOW2(rlvl->yend,\n\t\t\t  rlvl->prcheightexpn) << rlvl->prcheightexpn;\n\t\t\trlvl->numhprcs = (brprcxend - tlprcxstart) >>\n\t\t\t  rlvl->prcwidthexpn;\n\t\t\trlvl->numvprcs = (brprcyend - tlprcystart) >>\n\t\t\t  rlvl->prcheightexpn;\n\t\t\trlvl->numprcs = rlvl->numhprcs * rlvl->numvprcs;\n\n\t\t\tif (rlvl->xstart >= rlvl->xend || rlvl->ystart >= rlvl->yend) {\n\t\t\t\trlvl->bands = 0;\n\t\t\t\trlvl->numprcs = 0;\n\t\t\t\trlvl->numhprcs = 0;\n\t\t\t\trlvl->numvprcs = 0;\n\t\t\t\tcontinue;\n\t\t\t}\t\n\t\t\tif (!rlvlno) {\n\t\t\t\ttlcbgxstart = tlprcxstart;\n\t\t\t\ttlcbgystart = tlprcystart;\n\t\t\t\tbrcbgxend = brprcxend;\n\t\t\t\tbrcbgyend = brprcyend;\n\t\t\t\trlvl->cbgwidthexpn = rlvl->prcwidthexpn;\n\t\t\t\trlvl->cbgheightexpn = rlvl->prcheightexpn;\n\t\t\t} else {\n\t\t\t\ttlcbgxstart = JPC_CEILDIVPOW2(tlprcxstart, 1);\n\t\t\t\ttlcbgystart = JPC_CEILDIVPOW2(tlprcystart, 1);\n\t\t\t\tbrcbgxend = JPC_CEILDIVPOW2(brprcxend, 1);\n\t\t\t\tbrcbgyend = JPC_CEILDIVPOW2(brprcyend, 1);\n\t\t\t\trlvl->cbgwidthexpn = rlvl->prcwidthexpn - 1;\n\t\t\t\trlvl->cbgheightexpn = rlvl->prcheightexpn - 1;\n\t\t\t}\n\t\t\trlvl->cblkwidthexpn = JAS_MIN(ccp->cblkwidthexpn,\n\t\t\t  rlvl->cbgwidthexpn);\n\t\t\trlvl->cblkheightexpn = JAS_MIN(ccp->cblkheightexpn,\n\t\t\t  rlvl->cbgheightexpn);\n\n\t\t\trlvl->numbands = (!rlvlno) ? 1 : 3;\n\t\t\tif (!(rlvl->bands = jas_malloc(rlvl->numbands *\n\t\t\t  sizeof(jpc_dec_band_t)))) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor (bandno = 0, band = rlvl->bands;\n\t\t\t  bandno < rlvl->numbands; ++bandno, ++band) {\n\t\t\t\tbndno = (!rlvlno) ? 0 : (3 * (rlvlno - 1) +\n\t\t\t\t  bandno + 1);\n\t\t\t\tbnd = &bnds[bndno];\n\n\t\t\t\tband->orient = bnd->orient;\n\t\t\t\tband->stepsize = ccp->stepsizes[bndno];\n\t\t\t\tband->analgain = JPC_NOMINALGAIN(ccp->qmfbid,\n\t\t\t\t  tcomp->numrlvls - 1, rlvlno, band->orient);\n\t\t\t\tband->absstepsize = jpc_calcabsstepsize(band->stepsize,\n\t\t\t\t  cmpt->prec + band->analgain);\n\t\t\t\tband->numbps = ccp->numguardbits +\n\t\t\t\t  JPC_QCX_GETEXPN(band->stepsize) - 1;\n\t\t\t\tband->roishift = (ccp->roishift + band->numbps >= JPC_PREC) ?\n\t\t\t\t  (JPC_PREC - 1 - band->numbps) : ccp->roishift;\n\t\t\t\tband->data = 0;\n\t\t\t\tband->prcs = 0;\n\t\t\t\tif (bnd->xstart == bnd->xend || bnd->ystart == bnd->yend) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (!(band->data = jas_seq2d_create(0, 0, 0, 0))) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tjas_seq2d_bindsub(band->data, tcomp->data, bnd->locxstart, bnd->locystart, bnd->locxend, bnd->locyend);\n\t\t\t\tjas_seq2d_setshift(band->data, bnd->xstart, bnd->ystart);\n\n\t\t\t\tassert(rlvl->numprcs);\n\n\t\t\t\tif (!(band->prcs = jas_malloc(rlvl->numprcs * sizeof(jpc_dec_prc_t)))) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\n/************************************************/\n\tcbgxstart = tlcbgxstart;\n\tcbgystart = tlcbgystart;\n\tfor (prccnt = rlvl->numprcs, prc = band->prcs;\n\t  prccnt > 0; --prccnt, ++prc) {\n\t\tcbgxend = cbgxstart + (1 << rlvl->cbgwidthexpn);\n\t\tcbgyend = cbgystart + (1 << rlvl->cbgheightexpn);\n\t\tprc->xstart = JAS_MAX(cbgxstart, JAS_CAST(uint_fast32_t, jas_seq2d_xstart(band->data)));\n\t\tprc->ystart = JAS_MAX(cbgystart, JAS_CAST(uint_fast32_t, jas_seq2d_ystart(band->data)));\n\t\tprc->xend = JAS_MIN(cbgxend, JAS_CAST(uint_fast32_t, jas_seq2d_xend(band->data)));\n\t\tprc->yend = JAS_MIN(cbgyend, JAS_CAST(uint_fast32_t, jas_seq2d_yend(band->data)));\n\t\tif (prc->xend > prc->xstart && prc->yend > prc->ystart) {\n\t\t\ttlcblkxstart = JPC_FLOORDIVPOW2(prc->xstart,\n\t\t\t  rlvl->cblkwidthexpn) << rlvl->cblkwidthexpn;\n\t\t\ttlcblkystart = JPC_FLOORDIVPOW2(prc->ystart,\n\t\t\t  rlvl->cblkheightexpn) << rlvl->cblkheightexpn;\n\t\t\tbrcblkxend = JPC_CEILDIVPOW2(prc->xend,\n\t\t\t  rlvl->cblkwidthexpn) << rlvl->cblkwidthexpn;\n\t\t\tbrcblkyend = JPC_CEILDIVPOW2(prc->yend,\n\t\t\t  rlvl->cblkheightexpn) << rlvl->cblkheightexpn;\n\t\t\tprc->numhcblks = (brcblkxend - tlcblkxstart) >>\n\t\t\t  rlvl->cblkwidthexpn;\n\t\t\tprc->numvcblks = (brcblkyend - tlcblkystart) >>\n\t\t\t  rlvl->cblkheightexpn;\n\t\t\tprc->numcblks = prc->numhcblks * prc->numvcblks;\n\t\t\tassert(prc->numcblks > 0);\n\n\t\t\tif (!(prc->incltagtree = jpc_tagtree_create(prc->numhcblks, prc->numvcblks))) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (!(prc->numimsbstagtree = jpc_tagtree_create(prc->numhcblks, prc->numvcblks))) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (!(prc->cblks = jas_malloc(prc->numcblks * sizeof(jpc_dec_cblk_t)))) {\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tcblkxstart = cbgxstart;\n\t\t\tcblkystart = cbgystart;\n\t\t\tfor (cblkcnt = prc->numcblks, cblk = prc->cblks; cblkcnt > 0;) {\n\t\t\t\tcblkxend = cblkxstart + (1 << rlvl->cblkwidthexpn);\n\t\t\t\tcblkyend = cblkystart + (1 << rlvl->cblkheightexpn);\n\t\t\t\ttmpxstart = JAS_MAX(cblkxstart, prc->xstart);\n\t\t\t\ttmpystart = JAS_MAX(cblkystart, prc->ystart);\n\t\t\t\ttmpxend = JAS_MIN(cblkxend, prc->xend);\n\t\t\t\ttmpyend = JAS_MIN(cblkyend, prc->yend);\n\t\t\t\tif (tmpxend > tmpxstart && tmpyend > tmpystart) {\n\t\t\t\t\tcblk->firstpassno = -1;\n\t\t\t\t\tcblk->mqdec = 0;\n\t\t\t\t\tcblk->nulldec = 0;\n\t\t\t\t\tcblk->flags = 0;\n\t\t\t\t\tcblk->numpasses = 0;\n\t\t\t\t\tcblk->segs.head = 0;\n\t\t\t\t\tcblk->segs.tail = 0;\n\t\t\t\t\tcblk->curseg = 0;\n\t\t\t\t\tcblk->numimsbs = 0;\n\t\t\t\t\tcblk->numlenbits = 3;\n\t\t\t\t\tcblk->flags = 0;\n\t\t\t\t\tif (!(cblk->data = jas_seq2d_create(0, 0, 0, 0))) {\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\t\tjas_seq2d_bindsub(cblk->data, band->data, tmpxstart, tmpystart, tmpxend, tmpyend);\n\t\t\t\t\t++cblk;\n\t\t\t\t\t--cblkcnt;\n\t\t\t\t}\n\t\t\t\tcblkxstart += 1 << rlvl->cblkwidthexpn;\n\t\t\t\tif (cblkxstart >= cbgxend) {\n\t\t\t\t\tcblkxstart = cbgxstart;\n\t\t\t\t\tcblkystart += 1 << rlvl->cblkheightexpn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t} else {\n\t\t\tprc->cblks = 0;\n\t\t\tprc->incltagtree = 0;\n\t\t\tprc->numimsbstagtree = 0;\n\t\t}\n\t\tcbgxstart += 1 << rlvl->cbgwidthexpn;\n\t\tif (cbgxstart >= brcbgxend) {\n\t\t\tcbgxstart = tlcbgxstart;\n\t\t\tcbgystart += 1 << rlvl->cbgheightexpn;\n\t\t}\n\n\t}\n/********************************************/\n\t\t\t}\n\t\t}\n\t}\n\nif (!(tile->pi = jpc_dec_pi_create(dec, tile)))\n{\n\treturn -1;\n}\n\n\tfor (pchgno = 0; pchgno < jpc_pchglist_numpchgs(tile->cp->pchglist);\n\t  ++pchgno) {\n\t\tpchg = jpc_pchg_copy(jpc_pchglist_get(tile->cp->pchglist, pchgno));\n\t\tassert(pchg);\n\t\tjpc_pi_addpchg(tile->pi, pchg);\n\t}\n\tjpc_pi_init(tile->pi);\n\n\treturn 0;\n}\n\nstatic int jpc_dec_tilefini(jpc_dec_t *dec, jpc_dec_tile_t *tile)\n{\n\tjpc_dec_tcomp_t *tcomp;\n\tint compno;\n\tint bandno;\n\tint rlvlno;\n\tjpc_dec_band_t *band;\n\tjpc_dec_rlvl_t *rlvl;\n\tint prcno;\n\tjpc_dec_prc_t *prc;\n\tjpc_dec_seg_t *seg;\n\tjpc_dec_cblk_t *cblk;\n\tint cblkno;\n\nif (tile->tcomps) {\n\n\tfor (compno = 0, tcomp = tile->tcomps; compno < dec->numcomps;\n\t  ++compno, ++tcomp) {\n\t\tfor (rlvlno = 0, rlvl = tcomp->rlvls; rlvlno < tcomp->numrlvls;\n\t\t  ++rlvlno, ++rlvl) {\nif (!rlvl->bands) {\n\tcontinue;\n}\n\t\t\tfor (bandno = 0, band = rlvl->bands; bandno < rlvl->numbands; ++bandno, ++band) {\nif (band->prcs) {\n\t\t\t\tfor (prcno = 0, prc = band->prcs; prcno <\n\t\t\t\t  rlvl->numprcs; ++prcno, ++prc) {\nif (!prc->cblks) {\n\tcontinue;\n}\n\t\t\t\t\tfor (cblkno = 0, cblk = prc->cblks; cblkno < prc->numcblks; ++cblkno, ++cblk) {\n\n\twhile (cblk->segs.head) {\n\t\tseg = cblk->segs.head;\n\t\tjpc_seglist_remove(&cblk->segs, seg);\n\t\tjpc_seg_destroy(seg);\n\t}\n\tjas_matrix_destroy(cblk->data);\n\tif (cblk->mqdec) {\n\t\tjpc_mqdec_destroy(cblk->mqdec);\n\t}\n\tif (cblk->nulldec) {\n\t\tjpc_bitstream_close(cblk->nulldec);\n\t}\n\tif (cblk->flags) {\n\t\tjas_matrix_destroy(cblk->flags);\n\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (prc->incltagtree) {\n\t\t\t\t\t\tjpc_tagtree_destroy(prc->incltagtree);\n\t\t\t\t\t}\n\t\t\t\t\tif (prc->numimsbstagtree) {\n\t\t\t\t\t\tjpc_tagtree_destroy(prc->numimsbstagtree);\n\t\t\t\t\t}\n\t\t\t\t\tif (prc->cblks) {\n\t\t\t\t\t\tjas_free(prc->cblks);\n\t\t\t\t\t}\n\t\t\t\t}\n}\n\t\t\t\tif (band->data) {\n\t\t\t\t\tjas_matrix_destroy(band->data);\n\t\t\t\t}\n\t\t\t\tif (band->prcs) {\n\t\t\t\t\tjas_free(band->prcs);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (rlvl->bands) {\n\t\t\t\tjas_free(rlvl->bands);\n\t\t\t}\n\t\t}\n\t\tif (tcomp->rlvls) {\n\t\t\tjas_free(tcomp->rlvls);\n\t\t}\n\t\tif (tcomp->data) {\n\t\t\tjas_matrix_destroy(tcomp->data);\n\t\t}\n\t\tif (tcomp->tsfb) {\n\t\t\tjpc_tsfb_destroy(tcomp->tsfb);\n\t\t}\n\t}\n}\n\tif (tile->cp) {\n\t\tjpc_dec_cp_destroy(tile->cp);\n\t\ttile->cp = 0;\n\t}\n\tif (tile->tcomps) {\n\t\tjas_free(tile->tcomps);\n\t\ttile->tcomps = 0;\n\t}\n\tif (tile->pi) {\n\t\tjpc_pi_destroy(tile->pi);\n\t\ttile->pi = 0;\n\t}\n\tif (tile->pkthdrstream) {\n\t\tjas_stream_close(tile->pkthdrstream);\n\t\ttile->pkthdrstream = 0;\n\t}\n\tif (tile->pptstab) {\n\t\tjpc_ppxstab_destroy(tile->pptstab);\n\t\ttile->pptstab = 0;\n\t}\n\n\ttile->state = JPC_TILE_DONE;\n\n\treturn 0;\n}\n\nstatic int jpc_dec_tiledecode(jpc_dec_t *dec, jpc_dec_tile_t *tile)\n{\n\tint i;\n\tint j;\n\tjpc_dec_tcomp_t *tcomp;\n\tjpc_dec_rlvl_t *rlvl;\n\tjpc_dec_band_t *band;\n\tint compno;\n\tint rlvlno;\n\tint bandno;\n\tint adjust;\n\tint v;\n\tjpc_dec_ccp_t *ccp;\n\tjpc_dec_cmpt_t *cmpt;\n\n\tif (jpc_dec_decodecblks(dec, tile)) {\n\t\tjas_eprintf(\"jpc_dec_decodecblks failed\\n\");\n\t\treturn -1;\n\t}\n\n\t/* Perform dequantization. */\n\tfor (compno = 0, tcomp = tile->tcomps; compno < dec->numcomps;\n\t  ++compno, ++tcomp) {\n\t\tccp = &tile->cp->ccps[compno];\n\t\tfor (rlvlno = 0, rlvl = tcomp->rlvls; rlvlno < tcomp->numrlvls;\n\t\t  ++rlvlno, ++rlvl) {\n\t\t\tif (!rlvl->bands) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (bandno = 0, band = rlvl->bands;\n\t\t\t  bandno < rlvl->numbands; ++bandno, ++band) {\n\t\t\t\tif (!band->data) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tjpc_undo_roi(band->data, band->roishift, ccp->roishift -\n\t\t\t\t  band->roishift, band->numbps);\n\t\t\t\tif (tile->realmode) {\n\t\t\t\t\tjas_matrix_asl(band->data, JPC_FIX_FRACBITS);\n\t\t\t\t\tjpc_dequantize(band->data, band->absstepsize);\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Apply an inverse wavelet transform if necessary. */\n\tfor (compno = 0, tcomp = tile->tcomps; compno < dec->numcomps;\n\t  ++compno, ++tcomp) {\n\t\tccp = &tile->cp->ccps[compno];\n\t\tjpc_tsfb_synthesize(tcomp->tsfb, tcomp->data);\n\t}\n\n\n\t/* Apply an inverse intercomponent transform if necessary. */\n\tswitch (tile->cp->mctid) {\n\tcase JPC_MCT_RCT:\n\t\tassert(dec->numcomps == 3);\n\t\tjpc_irct(tile->tcomps[0].data, tile->tcomps[1].data,\n\t\t  tile->tcomps[2].data);\n\t\tbreak;\n\tcase JPC_MCT_ICT:\n\t\tassert(dec->numcomps == 3);\n\t\tjpc_iict(tile->tcomps[0].data, tile->tcomps[1].data,\n\t\t  tile->tcomps[2].data);\n\t\tbreak;\n\t}\n\n\t/* Perform rounding and convert to integer values. */\n\tif (tile->realmode) {\n\t\tfor (compno = 0, tcomp = tile->tcomps; compno < dec->numcomps;\n\t\t  ++compno, ++tcomp) {\n\t\t\tfor (i = 0; i < jas_matrix_numrows(tcomp->data); ++i) {\n\t\t\t\tfor (j = 0; j < jas_matrix_numcols(tcomp->data); ++j) {\n\t\t\t\t\tv = jas_matrix_get(tcomp->data, i, j);\n\t\t\t\t\tv = jpc_fix_round(v);\n\t\t\t\t\tjas_matrix_set(tcomp->data, i, j, jpc_fixtoint(v));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Perform level shift. */\n\tfor (compno = 0, tcomp = tile->tcomps, cmpt = dec->cmpts; compno <\n\t  dec->numcomps; ++compno, ++tcomp, ++cmpt) {\n\t\tadjust = cmpt->sgnd ? 0 : (1 << (cmpt->prec - 1));\n\t\tfor (i = 0; i < jas_matrix_numrows(tcomp->data); ++i) {\n\t\t\tfor (j = 0; j < jas_matrix_numcols(tcomp->data); ++j) {\n\t\t\t\t*jas_matrix_getref(tcomp->data, i, j) += adjust;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Perform clipping. */\n\tfor (compno = 0, tcomp = tile->tcomps, cmpt = dec->cmpts; compno <\n\t  dec->numcomps; ++compno, ++tcomp, ++cmpt) {\n\t\tjpc_fix_t mn;\n\t\tjpc_fix_t mx;\n\t\tmn = cmpt->sgnd ? (-(1 << (cmpt->prec - 1))) : (0);\n\t\tmx = cmpt->sgnd ? ((1 << (cmpt->prec - 1)) - 1) : ((1 <<\n\t\t  cmpt->prec) - 1);\n\t\tjas_matrix_clip(tcomp->data, mn, mx);\n\t}\n\n\t/* XXX need to free tsfb struct */\n\n\t/* Write the data for each component of the image. */\n\tfor (compno = 0, tcomp = tile->tcomps, cmpt = dec->cmpts; compno <\n\t  dec->numcomps; ++compno, ++tcomp, ++cmpt) {\n\t\tif (jas_image_writecmpt(dec->image, compno, tcomp->xstart -\n\t\t  JPC_CEILDIV(dec->xstart, cmpt->hstep), tcomp->ystart -\n\t\t  JPC_CEILDIV(dec->ystart, cmpt->vstep), jas_matrix_numcols(\n\t\t  tcomp->data), jas_matrix_numrows(tcomp->data), tcomp->data)) {\n\t\t\tjas_eprintf(\"write component failed\\n\");\n\t\t\treturn -4;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int jpc_dec_process_eoc(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tint tileno;\n\tjpc_dec_tile_t *tile;\n\n\t/* Eliminate compiler warnings about unused variables. */\n\tms = 0;\n\n\tfor (tileno = 0, tile = dec->tiles; tileno < dec->numtiles; ++tileno,\n\t  ++tile) {\n\t\tif (tile->state == JPC_TILE_ACTIVE) {\n\t\t\tif (jpc_dec_tiledecode(dec, tile)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tjpc_dec_tilefini(dec, tile);\n\t}\n\n\t/* We are done processing the code stream. */\n\tdec->state = JPC_MT;\n\n\treturn 1;\n}\n\nstatic int jpc_dec_process_siz(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tjpc_siz_t *siz = &ms->parms.siz;\n\tint compno;\n\tint tileno;\n\tjpc_dec_tile_t *tile;\n\tjpc_dec_tcomp_t *tcomp;\n\tint htileno;\n\tint vtileno;\n\tjpc_dec_cmpt_t *cmpt;\n\n\tdec->xstart = siz->xoff;\n\tdec->ystart = siz->yoff;\n\tdec->xend = siz->width;\n\tdec->yend = siz->height;\n\tdec->tilewidth = siz->tilewidth;\n\tdec->tileheight = siz->tileheight;\n\tdec->tilexoff = siz->tilexoff;\n\tdec->tileyoff = siz->tileyoff;\n\tdec->numcomps = siz->numcomps;\n\tif (!(dec->cp = jpc_dec_cp_create(dec->numcomps))) {\n\t\treturn -1;\n\t}\n\n\tif (!(dec->cmpts = jas_malloc(dec->numcomps * sizeof(jpc_dec_cmpt_t)))) {\n\t\treturn -1;\n\t}\n\n\tfor (compno = 0, cmpt = dec->cmpts; compno < dec->numcomps; ++compno,\n\t  ++cmpt) {\n\t\tcmpt->prec = siz->comps[compno].prec;\n\t\tcmpt->sgnd = siz->comps[compno].sgnd;\n\t\tcmpt->hstep = siz->comps[compno].hsamp;\n\t\tcmpt->vstep = siz->comps[compno].vsamp;\n\t\tcmpt->width = JPC_CEILDIV(dec->xend, cmpt->hstep) -\n\t\t  JPC_CEILDIV(dec->xstart, cmpt->hstep);\n\t\tcmpt->height = JPC_CEILDIV(dec->yend, cmpt->vstep) -\n\t\t  JPC_CEILDIV(dec->ystart, cmpt->vstep);\n\t\tcmpt->hsubstep = 0;\n\t\tcmpt->vsubstep = 0;\n\t}\n\n\tdec->image = 0;\n\n\tdec->numhtiles = JPC_CEILDIV(dec->xend - dec->tilexoff, dec->tilewidth);\n\tdec->numvtiles = JPC_CEILDIV(dec->yend - dec->tileyoff, dec->tileheight);\n\tdec->numtiles = dec->numhtiles * dec->numvtiles;\n\tif (!(dec->tiles = jas_malloc(dec->numtiles * sizeof(jpc_dec_tile_t)))) {\n\t\treturn -1;\n\t}\n\n\tfor (tileno = 0, tile = dec->tiles; tileno < dec->numtiles; ++tileno,\n\t  ++tile) {\n\t\thtileno = tileno % dec->numhtiles;\n\t\tvtileno = tileno / dec->numhtiles;\n\t\ttile->realmode = 0;\n\t\ttile->state = JPC_TILE_INIT;\n\t\ttile->xstart = JAS_MAX(dec->tilexoff + htileno * dec->tilewidth,\n\t\t  dec->xstart);\n\t\ttile->ystart = JAS_MAX(dec->tileyoff + vtileno * dec->tileheight,\n\t\t  dec->ystart);\n\t\ttile->xend = JAS_MIN(dec->tilexoff + (htileno + 1) *\n\t\t  dec->tilewidth, dec->xend);\n\t\ttile->yend = JAS_MIN(dec->tileyoff + (vtileno + 1) *\n\t\t  dec->tileheight, dec->yend);\n\t\ttile->numparts = 0;\n\t\ttile->partno = 0;\n\t\ttile->pkthdrstream = 0;\n\t\ttile->pkthdrstreampos = 0;\n\t\ttile->pptstab = 0;\n\t\ttile->cp = 0;\n\t\tif (!(tile->tcomps = jas_malloc(dec->numcomps *\n\t\t  sizeof(jpc_dec_tcomp_t)))) {\n\t\t\treturn -1;\n\t\t}\n\t\tfor (compno = 0, cmpt = dec->cmpts, tcomp = tile->tcomps;\n\t\t  compno < dec->numcomps; ++compno, ++cmpt, ++tcomp) {\n\t\t\ttcomp->rlvls = 0;\n\t\t\ttcomp->data = 0;\n\t\t\ttcomp->xstart = JPC_CEILDIV(tile->xstart, cmpt->hstep);\n\t\t\ttcomp->ystart = JPC_CEILDIV(tile->ystart, cmpt->vstep);\n\t\t\ttcomp->xend = JPC_CEILDIV(tile->xend, cmpt->hstep);\n\t\t\ttcomp->yend = JPC_CEILDIV(tile->yend, cmpt->vstep);\n\t\t\ttcomp->tsfb = 0;\n\t\t}\n\t}\n\n\tdec->pkthdrstreams = 0;\n\n\t/* We should expect to encounter other main header marker segments\n\t  or an SOT marker segment next. */\n\tdec->state = JPC_MH;\n\n\treturn 0;\n}\n\nstatic int jpc_dec_process_cod(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tjpc_cod_t *cod = &ms->parms.cod;\n\tjpc_dec_tile_t *tile;\n\n\tswitch (dec->state) {\n\tcase JPC_MH:\n\t\tjpc_dec_cp_setfromcod(dec->cp, cod);\n\t\tbreak;\n\tcase JPC_TPH:\n\t\tif (!(tile = dec->curtile)) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (tile->partno != 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tjpc_dec_cp_setfromcod(tile->cp, cod);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_dec_process_coc(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tjpc_coc_t *coc = &ms->parms.coc;\n\tjpc_dec_tile_t *tile;\n\n\tif (JAS_CAST(int, coc->compno) > dec->numcomps) {\n\t\tjas_eprintf(\"invalid component number in COC marker segment\\n\");\n\t\treturn -1;\n\t}\n\tswitch (dec->state) {\n\tcase JPC_MH:\n\t\tjpc_dec_cp_setfromcoc(dec->cp, coc);\n\t\tbreak;\n\tcase JPC_TPH:\n\t\tif (!(tile = dec->curtile)) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (tile->partno > 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tjpc_dec_cp_setfromcoc(tile->cp, coc);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_dec_process_rgn(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tjpc_rgn_t *rgn = &ms->parms.rgn;\n\tjpc_dec_tile_t *tile;\n\n\tif (JAS_CAST(int, rgn->compno) > dec->numcomps) {\n\t\tjas_eprintf(\"invalid component number in RGN marker segment\\n\");\n\t\treturn -1;\n\t}\n\tswitch (dec->state) {\n\tcase JPC_MH:\n\t\tjpc_dec_cp_setfromrgn(dec->cp, rgn);\n\t\tbreak;\n\tcase JPC_TPH:\n\t\tif (!(tile = dec->curtile)) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (tile->partno > 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tjpc_dec_cp_setfromrgn(tile->cp, rgn);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int jpc_dec_process_qcd(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tjpc_qcd_t *qcd = &ms->parms.qcd;\n\tjpc_dec_tile_t *tile;\n\n\tswitch (dec->state) {\n\tcase JPC_MH:\n\t\tjpc_dec_cp_setfromqcd(dec->cp, qcd);\n\t\tbreak;\n\tcase JPC_TPH:\n\t\tif (!(tile = dec->curtile)) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (tile->partno > 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tjpc_dec_cp_setfromqcd(tile->cp, qcd);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_dec_process_qcc(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tjpc_qcc_t *qcc = &ms->parms.qcc;\n\tjpc_dec_tile_t *tile;\n\n\tif (JAS_CAST(int, qcc->compno) > dec->numcomps) {\n\t\tjas_eprintf(\"invalid component number in QCC marker segment\\n\");\n\t\treturn -1;\n\t}\n\tswitch (dec->state) {\n\tcase JPC_MH:\n\t\tjpc_dec_cp_setfromqcc(dec->cp, qcc);\n\t\tbreak;\n\tcase JPC_TPH:\n\t\tif (!(tile = dec->curtile)) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (tile->partno > 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tjpc_dec_cp_setfromqcc(tile->cp, qcc);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_dec_process_poc(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tjpc_poc_t *poc = &ms->parms.poc;\n\tjpc_dec_tile_t *tile;\n\tswitch (dec->state) {\n\tcase JPC_MH:\n\t\tif (jpc_dec_cp_setfrompoc(dec->cp, poc, 1)) {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tcase JPC_TPH:\n\t\tif (!(tile = dec->curtile)) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (!tile->partno) {\n\t\t\tif (jpc_dec_cp_setfrompoc(tile->cp, poc, (!tile->partno))) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t} else {\n\t\t\tjpc_pi_addpchgfrompoc(tile->pi, poc);\n\t\t}\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_dec_process_ppm(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tjpc_ppm_t *ppm = &ms->parms.ppm;\n\tjpc_ppxstabent_t *ppmstabent;\n\n\tif (!dec->ppmstab) {\n\t\tif (!(dec->ppmstab = jpc_ppxstab_create())) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (!(ppmstabent = jpc_ppxstabent_create())) {\n\t\treturn -1;\n\t}\n\tppmstabent->ind = ppm->ind;\n\tppmstabent->data = ppm->data;\n\tppm->data = 0;\n\tppmstabent->len = ppm->len;\n\tif (jpc_ppxstab_insert(dec->ppmstab, ppmstabent)) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_dec_process_ppt(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tjpc_ppt_t *ppt = &ms->parms.ppt;\n\tjpc_dec_tile_t *tile;\n\tjpc_ppxstabent_t *pptstabent;\n\n\ttile = dec->curtile;\n\tif (!tile->pptstab) {\n\t\tif (!(tile->pptstab = jpc_ppxstab_create())) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\tif (!(pptstabent = jpc_ppxstabent_create())) {\n\t\treturn -1;\n\t}\n\tpptstabent->ind = ppt->ind;\n\tpptstabent->data = ppt->data;\n\tppt->data = 0;\n\tpptstabent->len = ppt->len;\n\tif (jpc_ppxstab_insert(tile->pptstab, pptstabent)) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_dec_process_com(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\t/* Eliminate compiler warnings about unused variables. */\n\tdec = 0;\n\tms = 0;\n\n\treturn 0;\n}\n\nstatic int jpc_dec_process_unk(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\t/* Eliminate compiler warnings about unused variables. */\n\tdec = 0;\n\n\tjas_eprintf(\"warning: ignoring unknown marker segment\\n\");\n\tjpc_ms_dump(ms, stderr);\n\treturn 0;\n}\n\n/******************************************************************************\\\n*\n\\******************************************************************************/\n\nstatic jpc_dec_cp_t *jpc_dec_cp_create(uint_fast16_t numcomps)\n{\n\tjpc_dec_cp_t *cp;\n\tjpc_dec_ccp_t *ccp;\n\tint compno;\n\n\tif (!(cp = jas_malloc(sizeof(jpc_dec_cp_t)))) {\n\t\treturn 0;\n\t}\n\tcp->flags = 0;\n\tcp->numcomps = numcomps;\n\tcp->prgord = 0;\n\tcp->numlyrs = 0;\n\tcp->mctid = 0;\n\tcp->csty = 0;\n\tif (!(cp->ccps = jas_malloc(cp->numcomps * sizeof(jpc_dec_ccp_t)))) {\n\t\treturn 0;\n\t}\n\tif (!(cp->pchglist = jpc_pchglist_create())) {\n\t\tjas_free(cp->ccps);\n\t\treturn 0;\n\t}\n\tfor (compno = 0, ccp = cp->ccps; compno < cp->numcomps;\n\t  ++compno, ++ccp) {\n\t\tccp->flags = 0;\n\t\tccp->numrlvls = 0;\n\t\tccp->cblkwidthexpn = 0;\n\t\tccp->cblkheightexpn = 0;\n\t\tccp->qmfbid = 0;\n\t\tccp->numstepsizes = 0;\n\t\tccp->numguardbits = 0;\n\t\tccp->roishift = 0;\n\t\tccp->cblkctx = 0;\n\t}\n\treturn cp;\n}\n\nstatic jpc_dec_cp_t *jpc_dec_cp_copy(jpc_dec_cp_t *cp)\n{\n\tjpc_dec_cp_t *newcp;\n\tjpc_dec_ccp_t *newccp;\n\tjpc_dec_ccp_t *ccp;\n\tint compno;\n\n\tif (!(newcp = jpc_dec_cp_create(cp->numcomps))) {\n\t\treturn 0;\n\t}\n\tnewcp->flags = cp->flags;\n\tnewcp->prgord = cp->prgord;\n\tnewcp->numlyrs = cp->numlyrs;\n\tnewcp->mctid = cp->mctid;\n\tnewcp->csty = cp->csty;\n\tjpc_pchglist_destroy(newcp->pchglist);\n\tnewcp->pchglist = 0;\n\tif (!(newcp->pchglist = jpc_pchglist_copy(cp->pchglist))) {\n\t\tjas_free(newcp);\n\t\treturn 0;\n\t}\n\tfor (compno = 0, newccp = newcp->ccps, ccp = cp->ccps;\n\t  compno < cp->numcomps;\n\t  ++compno, ++newccp, ++ccp) {\n\t\t*newccp = *ccp;\n\t}\n\treturn newcp;\n}\n\nstatic void jpc_dec_cp_resetflags(jpc_dec_cp_t *cp)\n{\n\tint compno;\n\tjpc_dec_ccp_t *ccp;\n\tcp->flags &= (JPC_CSET | JPC_QSET);\n\tfor (compno = 0, ccp = cp->ccps; compno < cp->numcomps;\n\t  ++compno, ++ccp) {\n\t\tccp->flags = 0;\n\t}\n}\n\nstatic void jpc_dec_cp_destroy(jpc_dec_cp_t *cp)\n{\n\tif (cp->ccps) {\n\t\tjas_free(cp->ccps);\n\t}\n\tif (cp->pchglist) {\n\t\tjpc_pchglist_destroy(cp->pchglist);\n\t}\n\tjas_free(cp);\n}\n\nstatic int jpc_dec_cp_isvalid(jpc_dec_cp_t *cp)\n{\n\tuint_fast16_t compcnt;\n\tjpc_dec_ccp_t *ccp;\n\n\tif (!(cp->flags & JPC_CSET) || !(cp->flags & JPC_QSET)) {\n\t\treturn 0;\n\t}\n\tfor (compcnt = cp->numcomps, ccp = cp->ccps; compcnt > 0; --compcnt,\n\t  ++ccp) {\n\t\t/* Is there enough step sizes for the number of bands? */\n\t\tif ((ccp->qsty != JPC_QCX_SIQNT && JAS_CAST(int, ccp->numstepsizes) < 3 *\n\t\t  ccp->numrlvls - 2) || (ccp->qsty == JPC_QCX_SIQNT &&\n\t\t  ccp->numstepsizes != 1)) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}\n\nstatic void calcstepsizes(uint_fast16_t refstepsize, int numrlvls,\n  uint_fast16_t *stepsizes)\n{\n\tint bandno;\n\tint numbands;\n\tuint_fast16_t expn;\n\tuint_fast16_t mant;\n\texpn = JPC_QCX_GETEXPN(refstepsize);\n\tmant = JPC_QCX_GETMANT(refstepsize);\n\tnumbands = 3 * numrlvls - 2;\n\tfor (bandno = 0; bandno < numbands; ++bandno) {\n\t\tstepsizes[bandno] = JPC_QCX_MANT(mant) | JPC_QCX_EXPN(expn +\n\t\t  (numrlvls - 1) - (numrlvls - 1 - ((bandno > 0) ? ((bandno + 2) / 3) : (0))));\n\t}\n}\n\nstatic int jpc_dec_cp_prepare(jpc_dec_cp_t *cp)\n{\n\tjpc_dec_ccp_t *ccp;\n\tint compno;\n\tint i;\n\tfor (compno = 0, ccp = cp->ccps; compno < cp->numcomps;\n\t  ++compno, ++ccp) {\n\t\tif (!(ccp->csty & JPC_COX_PRT)) {\n\t\t\tfor (i = 0; i < JPC_MAXRLVLS; ++i) {\n\t\t\t\tccp->prcwidthexpns[i] = 15;\n\t\t\t\tccp->prcheightexpns[i] = 15;\n\t\t\t}\n\t\t}\n\t\tif (ccp->qsty == JPC_QCX_SIQNT) {\n\t\t\tcalcstepsizes(ccp->stepsizes[0], ccp->numrlvls, ccp->stepsizes);\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int jpc_dec_cp_setfromcod(jpc_dec_cp_t *cp, jpc_cod_t *cod)\n{\n\tjpc_dec_ccp_t *ccp;\n\tint compno;\n\tcp->flags |= JPC_CSET;\n\tcp->prgord = cod->prg;\n\tif (cod->mctrans) {\n\t\tcp->mctid = (cod->compparms.qmfbid == JPC_COX_INS) ? (JPC_MCT_ICT) : (JPC_MCT_RCT);\n\t} else {\n\t\tcp->mctid = JPC_MCT_NONE;\n\t}\n\tcp->numlyrs = cod->numlyrs;\n\tcp->csty = cod->csty & (JPC_COD_SOP | JPC_COD_EPH);\n\tfor (compno = 0, ccp = cp->ccps; compno < cp->numcomps;\n\t  ++compno, ++ccp) {\n\t\tjpc_dec_cp_setfromcox(cp, ccp, &cod->compparms, 0);\n\t}\n\tcp->flags |= JPC_CSET;\n\treturn 0;\n}\n\nstatic int jpc_dec_cp_setfromcoc(jpc_dec_cp_t *cp, jpc_coc_t *coc)\n{\n\tjpc_dec_cp_setfromcox(cp, &cp->ccps[coc->compno], &coc->compparms, JPC_COC);\n\treturn 0;\n}\n\nstatic int jpc_dec_cp_setfromcox(jpc_dec_cp_t *cp, jpc_dec_ccp_t *ccp,\n  jpc_coxcp_t *compparms, int flags)\n{\n\tint rlvlno;\n\n\t/* Eliminate compiler warnings about unused variables. */\n\tcp = 0;\n\n\tif ((flags & JPC_COC) || !(ccp->flags & JPC_COC)) {\n\t\tccp->numrlvls = compparms->numdlvls + 1;\n\t\tccp->cblkwidthexpn = JPC_COX_GETCBLKSIZEEXPN(\n\t\t  compparms->cblkwidthval);\n\t\tccp->cblkheightexpn = JPC_COX_GETCBLKSIZEEXPN(\n\t\t  compparms->cblkheightval);\n\t\tccp->qmfbid = compparms->qmfbid;\n\t\tccp->cblkctx = compparms->cblksty;\n\t\tccp->csty = compparms->csty & JPC_COX_PRT;\n\t\tfor (rlvlno = 0; rlvlno < compparms->numrlvls; ++rlvlno) {\n\t\t\tccp->prcwidthexpns[rlvlno] =\n\t\t\t  compparms->rlvls[rlvlno].parwidthval;\n\t\t\tccp->prcheightexpns[rlvlno] =\n\t\t\t  compparms->rlvls[rlvlno].parheightval;\n\t\t}\n\t\tccp->flags |= flags | JPC_CSET;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_dec_cp_setfromqcd(jpc_dec_cp_t *cp, jpc_qcd_t *qcd)\n{\n\tint compno;\n\tjpc_dec_ccp_t *ccp;\n\tfor (compno = 0, ccp = cp->ccps; compno < cp->numcomps;\n\t  ++compno, ++ccp) {\n\t\tjpc_dec_cp_setfromqcx(cp, ccp, &qcd->compparms, 0);\n\t}\n\tcp->flags |= JPC_QSET;\n\treturn 0;\n}\n\nstatic int jpc_dec_cp_setfromqcc(jpc_dec_cp_t *cp, jpc_qcc_t *qcc)\n{\n\treturn jpc_dec_cp_setfromqcx(cp, &cp->ccps[qcc->compno], &qcc->compparms, JPC_QCC);\n}\n\nstatic int jpc_dec_cp_setfromqcx(jpc_dec_cp_t *cp, jpc_dec_ccp_t *ccp,\n  jpc_qcxcp_t *compparms, int flags)\n{\n\tint bandno;\n\n\t/* Eliminate compiler warnings about unused variables. */\n\tcp = 0;\n\n\tif ((flags & JPC_QCC) || !(ccp->flags & JPC_QCC)) {\n\t\tccp->flags |= flags | JPC_QSET;\n\t\tfor (bandno = 0; bandno < compparms->numstepsizes; ++bandno) {\n\t\t\tccp->stepsizes[bandno] = compparms->stepsizes[bandno];\n\t\t}\n\t\tccp->numstepsizes = compparms->numstepsizes;\n\t\tccp->numguardbits = compparms->numguard;\n\t\tccp->qsty = compparms->qntsty;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_dec_cp_setfromrgn(jpc_dec_cp_t *cp, jpc_rgn_t *rgn)\n{\n\tjpc_dec_ccp_t *ccp;\n\tccp = &cp->ccps[rgn->compno];\n\tccp->roishift = rgn->roishift;\n\treturn 0;\n}\n\nstatic int jpc_pi_addpchgfrompoc(jpc_pi_t *pi, jpc_poc_t *poc)\n{\n\tint pchgno;\n\tjpc_pchg_t *pchg;\n\tfor (pchgno = 0; pchgno < poc->numpchgs; ++pchgno) {\n\t\tif (!(pchg = jpc_pchg_copy(&poc->pchgs[pchgno]))) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (jpc_pchglist_insert(pi->pchglist, -1, pchg)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int jpc_dec_cp_setfrompoc(jpc_dec_cp_t *cp, jpc_poc_t *poc, int reset)\n{\n\tint pchgno;\n\tjpc_pchg_t *pchg;\n\tif (reset) {\n\t\twhile (jpc_pchglist_numpchgs(cp->pchglist) > 0) {\n\t\t\tpchg = jpc_pchglist_remove(cp->pchglist, 0);\n\t\t\tjpc_pchg_destroy(pchg);\n\t\t}\n\t}\n\tfor (pchgno = 0; pchgno < poc->numpchgs; ++pchgno) {\n\t\tif (!(pchg = jpc_pchg_copy(&poc->pchgs[pchgno]))) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (jpc_pchglist_insert(cp->pchglist, -1, pchg)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic jpc_fix_t jpc_calcabsstepsize(int stepsize, int numbits)\n{\n\tjpc_fix_t absstepsize;\n\tint n;\n\n\tabsstepsize = jpc_inttofix(1);\n\tn = JPC_FIX_FRACBITS - 11;\n\tabsstepsize |= (n >= 0) ? (JPC_QCX_GETMANT(stepsize) << n) :\n\t  (JPC_QCX_GETMANT(stepsize) >> (-n));\n\tn = numbits - JPC_QCX_GETEXPN(stepsize);\n\tabsstepsize = (n >= 0) ? (absstepsize << n) : (absstepsize >> (-n));\n\treturn absstepsize;\n}\n\nstatic void jpc_dequantize(jas_matrix_t *x, jpc_fix_t absstepsize)\n{\n\tint i;\n\tint j;\n\tint t;\n\n\tassert(absstepsize >= 0);\n\tif (absstepsize == jpc_inttofix(1)) {\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < jas_matrix_numrows(x); ++i) {\n\t\tfor (j = 0; j < jas_matrix_numcols(x); ++j) {\n\t\t\tt = jas_matrix_get(x, i, j);\n\t\t\tif (t) {\n\t\t\t\tt = jpc_fix_mul(t, absstepsize);\n\t\t\t} else {\n\t\t\t\tt = 0;\n\t\t\t}\n\t\t\tjas_matrix_set(x, i, j, t);\n\t\t}\n\t}\n\n}\n\nstatic void jpc_undo_roi(jas_matrix_t *x, int roishift, int bgshift, int numbps)\n{\n\tint i;\n\tint j;\n\tint thresh;\n\tjpc_fix_t val;\n\tjpc_fix_t mag;\n\tbool warn;\n\tuint_fast32_t mask;\n\n\tif (roishift == 0 && bgshift == 0) {\n\t\treturn;\n\t}\n\tthresh = 1 << roishift;\n\n\twarn = false;\n\tfor (i = 0; i < jas_matrix_numrows(x); ++i) {\n\t\tfor (j = 0; j < jas_matrix_numcols(x); ++j) {\n\t\t\tval = jas_matrix_get(x, i, j);\n\t\t\tmag = JAS_ABS(val);\n\t\t\tif (mag >= thresh) {\n\t\t\t\t/* We are dealing with ROI data. */\n\t\t\t\tmag >>= roishift;\n\t\t\t\tval = (val < 0) ? (-mag) : mag;\n\t\t\t\tjas_matrix_set(x, i, j, val);\n\t\t\t} else {\n\t\t\t\t/* We are dealing with non-ROI (i.e., background) data. */\n\t\t\t\tmag <<= bgshift;\n\t\t\t\tmask = (1 << numbps) - 1;\n\t\t\t\t/* Perform a basic sanity check on the sample value. */\n\t\t\t\t/* Some implementations write garbage in the unused\n\t\t\t\t  most-significant bit planes introduced by ROI shifting.\n\t\t\t\t  Here we ensure that any such bits are masked off. */\n\t\t\t\tif (mag & (~mask)) {\n\t\t\t\t\tif (!warn) {\n\t\t\t\t\t\tjas_eprintf(\"warning: possibly corrupt code stream\\n\");\n\t\t\t\t\t\twarn = true;\n\t\t\t\t\t}\n\t\t\t\t\tmag &= mask;\n\t\t\t\t}\n\t\t\t\tval = (val < 0) ? (-mag) : mag;\n\t\t\t\tjas_matrix_set(x, i, j, val);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic jpc_dec_t *jpc_dec_create(jpc_dec_importopts_t *impopts, jas_stream_t *in)\n{\n\tjpc_dec_t *dec;\n\n\tif (!(dec = jas_malloc(sizeof(jpc_dec_t)))) {\n\t\treturn 0;\n\t}\n\n\tdec->image = 0;\n\tdec->xstart = 0;\n\tdec->ystart = 0;\n\tdec->xend = 0;\n\tdec->yend = 0;\n\tdec->tilewidth = 0;\n\tdec->tileheight = 0;\n\tdec->tilexoff = 0;\n\tdec->tileyoff = 0;\n\tdec->numhtiles = 0;\n\tdec->numvtiles = 0;\n\tdec->numtiles = 0;\n\tdec->tiles = 0;\n\tdec->curtile = 0;\n\tdec->numcomps = 0;\n\tdec->in = in;\n\tdec->cp = 0;\n\tdec->maxlyrs = impopts->maxlyrs;\n\tdec->maxpkts = impopts->maxpkts;\ndec->numpkts = 0;\n\tdec->ppmseqno = 0;\n\tdec->state = 0;\n\tdec->cmpts = 0;\n\tdec->pkthdrstreams = 0;\n\tdec->ppmstab = 0;\n\tdec->curtileendoff = 0;\n\n\treturn dec;\n}\n\nstatic void jpc_dec_destroy(jpc_dec_t *dec)\n{\n\tif (dec->cstate) {\n\t\tjpc_cstate_destroy(dec->cstate);\n\t}\n\tif (dec->pkthdrstreams) {\n\t\tjpc_streamlist_destroy(dec->pkthdrstreams);\n\t}\n\tif (dec->image) {\n\t\tjas_image_destroy(dec->image);\n\t}\n\n\tif (dec->cp) {\n\t\tjpc_dec_cp_destroy(dec->cp);\n\t}\n\n\tif (dec->cmpts) {\n\t\tjas_free(dec->cmpts);\n\t}\n\n\tif (dec->tiles) {\n\t\tjas_free(dec->tiles);\n\t}\n\n\tjas_free(dec);\n}\n\n/******************************************************************************\\\n*\n\\******************************************************************************/\n\nvoid jpc_seglist_insert(jpc_dec_seglist_t *list, jpc_dec_seg_t *ins, jpc_dec_seg_t *node)\n{\n\tjpc_dec_seg_t *prev;\n\tjpc_dec_seg_t *next;\n\n\tprev = ins;\n\tnode->prev = prev;\n\tnext = prev ? (prev->next) : 0;\n\tnode->prev = prev;\n\tnode->next = next;\n\tif (prev) {\n\t\tprev->next = node;\n\t} else {\n\t\tlist->head = node;\n\t}\n\tif (next) {\n\t\tnext->prev = node;\n\t} else {\n\t\tlist->tail = node;\n\t}\n}\n\nvoid jpc_seglist_remove(jpc_dec_seglist_t *list, jpc_dec_seg_t *seg)\n{\n\tjpc_dec_seg_t *prev;\n\tjpc_dec_seg_t *next;\n\n\tprev = seg->prev;\n\tnext = seg->next;\n\tif (prev) {\n\t\tprev->next = next;\n\t} else {\n\t\tlist->head = next;\n\t}\n\tif (next) {\n\t\tnext->prev = prev;\n\t} else {\n\t\tlist->tail = prev;\n\t}\n\tseg->prev = 0;\n\tseg->next = 0;\n}\n\njpc_dec_seg_t *jpc_seg_alloc()\n{\n\tjpc_dec_seg_t *seg;\n\n\tif (!(seg = jas_malloc(sizeof(jpc_dec_seg_t)))) {\n\t\treturn 0;\n\t}\n\tseg->prev = 0;\n\tseg->next = 0;\n\tseg->passno = -1;\n\tseg->numpasses = 0;\n\tseg->maxpasses = 0;\n\tseg->type = JPC_SEG_INVALID;\n\tseg->stream = 0;\n\tseg->cnt = 0;\n\tseg->complete = 0;\n\tseg->lyrno = -1;\n\treturn seg;\n}\n\nvoid jpc_seg_destroy(jpc_dec_seg_t *seg)\n{\n\tif (seg->stream) {\n\t\tjas_stream_close(seg->stream);\n\t}\n\tjas_free(seg);\n}\n\nstatic int jpc_dec_dump(jpc_dec_t *dec, FILE *out)\n{\n\tjpc_dec_tile_t *tile;\n\tint tileno;\n\tjpc_dec_tcomp_t *tcomp;\n\tint compno;\n\tjpc_dec_rlvl_t *rlvl;\n\tint rlvlno;\n\tjpc_dec_band_t *band;\n\tint bandno;\n\tjpc_dec_prc_t *prc;\n\tint prcno;\n\tjpc_dec_cblk_t *cblk;\n\tint cblkno;\n\n\tfor (tileno = 0, tile = dec->tiles; tileno < dec->numtiles;\n\t  ++tileno, ++tile) {\n\t\tfor (compno = 0, tcomp = tile->tcomps; compno < dec->numcomps;\n\t\t  ++compno, ++tcomp) {\n\t\t\tfor (rlvlno = 0, rlvl = tcomp->rlvls; rlvlno <\n\t\t\t  tcomp->numrlvls; ++rlvlno, ++rlvl) {\nfprintf(out, \"RESOLUTION LEVEL %d\\n\", rlvlno);\nfprintf(out, \"xs =%d, ys = %d, xe = %d, ye = %d, w = %d, h = %d\\n\",\n  rlvl->xstart, rlvl->ystart, rlvl->xend, rlvl->yend, rlvl->xend -\n  rlvl->xstart, rlvl->yend - rlvl->ystart);\n\t\t\t\tfor (bandno = 0, band = rlvl->bands;\n\t\t\t\t  bandno < rlvl->numbands; ++bandno, ++band) {\nfprintf(out, \"BAND %d\\n\", bandno);\nfprintf(out, \"xs =%d, ys = %d, xe = %d, ye = %d, w = %d, h = %d\\n\",\n  jas_seq2d_xstart(band->data), jas_seq2d_ystart(band->data), jas_seq2d_xend(band->data),\n  jas_seq2d_yend(band->data), jas_seq2d_xend(band->data) - jas_seq2d_xstart(band->data),\n  jas_seq2d_yend(band->data) - jas_seq2d_ystart(band->data));\n\t\t\t\t\tfor (prcno = 0, prc = band->prcs;\n\t\t\t\t\t  prcno < rlvl->numprcs; ++prcno,\n\t\t\t\t\t  ++prc) {\nfprintf(out, \"CODE BLOCK GROUP %d\\n\", prcno);\nfprintf(out, \"xs =%d, ys = %d, xe = %d, ye = %d, w = %d, h = %d\\n\",\n  prc->xstart, prc->ystart, prc->xend, prc->yend, prc->xend -\n  prc->xstart, prc->yend - prc->ystart);\n\t\t\t\t\t\tfor (cblkno = 0, cblk =\n\t\t\t\t\t\t  prc->cblks; cblkno <\n\t\t\t\t\t\t  prc->numcblks; ++cblkno,\n\t\t\t\t\t\t  ++cblk) {\nfprintf(out, \"CODE BLOCK %d\\n\", cblkno);\nfprintf(out, \"xs =%d, ys = %d, xe = %d, ye = %d, w = %d, h = %d\\n\",\n  jas_seq2d_xstart(cblk->data), jas_seq2d_ystart(cblk->data), jas_seq2d_xend(cblk->data),\n  jas_seq2d_yend(cblk->data), jas_seq2d_xend(cblk->data) - jas_seq2d_xstart(cblk->data),\n  jas_seq2d_yend(cblk->data) - jas_seq2d_ystart(cblk->data));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\njpc_streamlist_t *jpc_streamlist_create()\n{\n\tjpc_streamlist_t *streamlist;\n\tint i;\n\n\tif (!(streamlist = jas_malloc(sizeof(jpc_streamlist_t)))) {\n\t\treturn 0;\n\t}\n\tstreamlist->numstreams = 0;\n\tstreamlist->maxstreams = 100;\n\tif (!(streamlist->streams = jas_malloc(streamlist->maxstreams *\n\t  sizeof(jas_stream_t *)))) {\n\t\tjas_free(streamlist);\n\t\treturn 0;\n\t}\n\tfor (i = 0; i < streamlist->maxstreams; ++i) {\n\t\tstreamlist->streams[i] = 0;\n\t}\n\treturn streamlist;\n}\n\nint jpc_streamlist_insert(jpc_streamlist_t *streamlist, int streamno,\n  jas_stream_t *stream)\n{\n\tjas_stream_t **newstreams;\n\tint newmaxstreams;\n\tint i;\n\t/* Grow the array of streams if necessary. */\n\tif (streamlist->numstreams >= streamlist->maxstreams) {\n\t\tnewmaxstreams = streamlist->maxstreams + 1024;\n\t\tif (!(newstreams = jas_realloc(streamlist->streams,\n\t\t  (newmaxstreams + 1024) * sizeof(jas_stream_t *)))) {\n\t\t\treturn -1;\n\t\t}\n\t\tfor (i = streamlist->numstreams; i < streamlist->maxstreams; ++i) {\n\t\t\tstreamlist->streams[i] = 0;\n\t\t}\n\t\tstreamlist->maxstreams = newmaxstreams;\n\t\tstreamlist->streams = newstreams;\n\t}\n\tif (streamno != streamlist->numstreams) {\n\t\t/* Can only handle insertion at start of list. */\n\t\treturn -1;\n\t}\n\tstreamlist->streams[streamno] = stream;\n\t++streamlist->numstreams;\n\treturn 0;\n}\n\njas_stream_t *jpc_streamlist_remove(jpc_streamlist_t *streamlist, int streamno)\n{\n\tjas_stream_t *stream;\n\tint i;\n\tif (streamno >= streamlist->numstreams) {\n\t\tabort();\n\t}\n\tstream = streamlist->streams[streamno];\n\tfor (i = streamno + 1; i < streamlist->numstreams; ++i) {\n\t\tstreamlist->streams[i - 1] = streamlist->streams[i];\n\t}\n\t--streamlist->numstreams;\n\treturn stream;\n}\n\nvoid jpc_streamlist_destroy(jpc_streamlist_t *streamlist)\n{\n\tint streamno;\n\tif (streamlist->streams) {\n\t\tfor (streamno = 0; streamno < streamlist->numstreams;\n\t\t  ++streamno) {\n\t\t\tjas_stream_close(streamlist->streams[streamno]);\n\t\t}\n\t\tjas_free(streamlist->streams);\n\t}\n\tjas_free(streamlist);\n}\n\njas_stream_t *jpc_streamlist_get(jpc_streamlist_t *streamlist, int streamno)\n{\n\tassert(streamno < streamlist->numstreams);\n\treturn streamlist->streams[streamno];\n}\n\nint jpc_streamlist_numstreams(jpc_streamlist_t *streamlist)\n{\n\treturn streamlist->numstreams;\n}\n\njpc_ppxstab_t *jpc_ppxstab_create()\n{\n\tjpc_ppxstab_t *tab;\n\n\tif (!(tab = jas_malloc(sizeof(jpc_ppxstab_t)))) {\n\t\treturn 0;\n\t}\n\ttab->numents = 0;\n\ttab->maxents = 0;\n\ttab->ents = 0;\n\treturn tab;\n}\n\nvoid jpc_ppxstab_destroy(jpc_ppxstab_t *tab)\n{\n\tint i;\n\tfor (i = 0; i < tab->numents; ++i) {\n\t\tjpc_ppxstabent_destroy(tab->ents[i]);\n\t}\n\tif (tab->ents) {\n\t\tjas_free(tab->ents);\n\t}\n\tjas_free(tab);\n}\n\nint jpc_ppxstab_grow(jpc_ppxstab_t *tab, int maxents)\n{\n\tjpc_ppxstabent_t **newents;\n\tif (tab->maxents < maxents) {\n\t\tnewents = (tab->ents) ? jas_realloc(tab->ents, maxents *\n\t\t  sizeof(jpc_ppxstabent_t *)) : jas_malloc(maxents * sizeof(jpc_ppxstabent_t *));\n\t\tif (!newents) {\n\t\t\treturn -1;\n\t\t}\n\t\ttab->ents = newents;\n\t\ttab->maxents = maxents;\n\t}\n\treturn 0;\n}\n\nint jpc_ppxstab_insert(jpc_ppxstab_t *tab, jpc_ppxstabent_t *ent)\n{\n\tint inspt;\n\tint i;\n\n    // check on MAX_INT\n    int correct_num_ents = tab->numents;\n    if (correct_num_ents > 0x7FFFFFFE)\n        correct_num_ents = 0x7FFFFFFE;\n\n    for (i = 0; i < correct_num_ents; ++i) {\n\t\tif (tab->ents[i]->ind > ent->ind) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tinspt = i;\n\n\tif (tab->numents >= tab->maxents) {\n\t\tif (jpc_ppxstab_grow(tab, tab->maxents + 128)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tfor (i = tab->numents; i > inspt; --i) {\n\t\ttab->ents[i] = tab->ents[i - 1];\n\t}\n\ttab->ents[i] = ent;\n\t++tab->numents;\n\n\treturn 0;\n}\n\njpc_streamlist_t *jpc_ppmstabtostreams(jpc_ppxstab_t *tab)\n{\n\tjpc_streamlist_t *streams;\n\tuchar *dataptr;\n\tuint_fast32_t datacnt;\n\tuint_fast32_t tpcnt;\n\tjpc_ppxstabent_t *ent;\n\tint entno;\n\tjas_stream_t *stream;\n\tint n;\n\n\tif (!(streams = jpc_streamlist_create())) {\n\t\tgoto error;\n\t}\n\n\tif (!tab->numents) {\n\t\treturn streams;\n\t}\n\n\tentno = 0;\n\tent = tab->ents[entno];\n\tdataptr = ent->data;\n\tdatacnt = ent->len;\n\tfor (;;) {\n\n\t\t/* Get the length of the packet header data for the current\n\t\t  tile-part. */\n\t\tif (datacnt < 4) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (!(stream = jas_stream_memopen(0, 0))) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (jpc_streamlist_insert(streams, jpc_streamlist_numstreams(streams),\n\t\t  stream)) {\n\t\t\tgoto error;\n\t\t}\n\t\ttpcnt = (dataptr[0] << 24) | (dataptr[1] << 16) | (dataptr[2] << 8)\n\t\t  | dataptr[3];\n\t\tdatacnt -= 4;\n\t\tdataptr += 4;\n\n\t\t/* Get the packet header data for the current tile-part. */\n\t\twhile (tpcnt) {\n\t\t\tif (!datacnt) {\n\t\t\t\tif (++entno >= tab->numents) {\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t\tent = tab->ents[entno];\n\t\t\t\tdataptr = ent->data;\n\t\t\t\tdatacnt = ent->len;\n\t\t\t}\n\t\t\tn = JAS_MIN(tpcnt, datacnt);\n\t\t\tif (jas_stream_write(stream, dataptr, n) != n) {\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\ttpcnt -= n;\n\t\t\tdataptr += n;\n\t\t\tdatacnt -= n;\n\t\t}\n\t\tjas_stream_rewind(stream);\n\t\tif (!datacnt) {\n\t\t\tif (++entno >= tab->numents) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tent = tab->ents[entno];\n\t\t\tdataptr = ent->data;\n\t\t\tdatacnt = ent->len;\n\t\t}\n\t}\n\n\treturn streams;\n\nerror:\n\tjpc_streamlist_destroy(streams);\n\treturn 0;\n}\n\nint jpc_pptstabwrite(jas_stream_t *out, jpc_ppxstab_t *tab)\n{\n\tint i;\n\tjpc_ppxstabent_t *ent;\n\tfor (i = 0; i < tab->numents; ++i) {\n\t\tent = tab->ents[i];\n\t\tif (jas_stream_write(out, ent->data, ent->len) != JAS_CAST(int, ent->len)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n\njpc_ppxstabent_t *jpc_ppxstabent_create()\n{\n\tjpc_ppxstabent_t *ent;\n\tif (!(ent = jas_malloc(sizeof(jpc_ppxstabent_t)))) {\n\t\treturn 0;\n\t}\n\tent->data = 0;\n\tent->len = 0;\n\tent->ind = 0;\n\treturn ent;\n}\n\nvoid jpc_ppxstabent_destroy(jpc_ppxstabent_t *ent)\n{\n\tif (ent->data) {\n\t\tjas_free(ent->data);\n\t}\n\tjas_free(ent);\n}\n", "/*\r\n  libdcr version 0.1.8.93 03/May/2009\r\n\r\n  libdcr : copyright (C) 2007-2009, Davide Pizzolato\r\n\r\n  based on dcraw.c -- Dave Coffin's raw photo decoder\r\n  Copyright 1997-2009 by Dave Coffin, dcoffin a cybercom o net\r\n\r\n  Covered code is provided under this license on an \"as is\" basis, without warranty\r\n  of any kind, either expressed or implied, including, without limitation, warranties\r\n  that the covered code is free of defects, merchantable, fit for a particular purpose\r\n  or non-infringing. The entire risk as to the quality and performance of the covered\r\n  code is with you. Should any covered code prove defective in any respect, you (not\r\n  the initial developer or any other contributor) assume the cost of any necessary\r\n  servicing, repair or correction. This disclaimer of warranty constitutes an essential\r\n  part of this license. No use of any covered code is authorized hereunder except under\r\n  this disclaimer.\r\n\r\n  No license is required to download and use libdcr.  However,\r\n  to lawfully redistribute libdcr, you must either (a) offer, at\r\n  no extra charge, full source code for all executable files\r\n  containing RESTRICTED functions, (b) distribute this code under\r\n  the GPL Version 2 or later, (c) remove all RESTRICTED functions,\r\n  re-implement them, or copy them from an earlier, unrestricted\r\n  revision of dcraw.c, or (d) purchase a license from the author\r\n  of dcraw.c.\r\n\r\n  --------------------------------------------------------------------------------\r\n\r\n  dcraw.c home page: http://cybercom.net/~dcoffin/dcraw/\r\n  libdcr  home page: http://www.xdp.it/libdcr/\r\n\r\n */\r\n\r\n#define _GNU_SOURCE\r\n#define _USE_MATH_DEFINES\r\n#include <ctype.h>\r\n#include <errno.h>\r\n#include <fcntl.h>\r\n#include <float.h>\r\n#include <limits.h>\r\n#include <math.h>\r\n#include <setjmp.h>\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n#include <time.h>\r\n#include <sys/types.h>\r\n\r\n#include \"libdcr.h\"\r\n\r\n// XYZ from RGB\r\nconst double xyz_rgb[3][3] = {\r\n\t{ 0.412453, 0.357580, 0.180423 },\r\n\t{ 0.212671, 0.715160, 0.072169 },\r\n\t{ 0.019334, 0.119193, 0.950227 } };\r\n\r\nconst float d65_white[3] = { 0.950456f, 1.0f, 1.088754f };\r\n\r\nstatic int   dcr_sfile_read(dcr_stream_obj *obj, void *buf, int size, int cnt);\r\nstatic int   dcr_sfile_write(dcr_stream_obj *obj, void *buf, int size, int cnt);\r\nstatic long  dcr_sfile_seek(dcr_stream_obj *obj, long offset, int origin);\r\nstatic int   dcr_sfile_close(dcr_stream_obj *obj);\r\nstatic char* dcr_sfile_gets(dcr_stream_obj *obj, char *string, int n);\r\nstatic int   dcr_sfile_eof(dcr_stream_obj *obj);\r\nstatic long  dcr_sfile_tell(dcr_stream_obj *obj);\r\nstatic int   dcr_sfile_getc(dcr_stream_obj *obj);\r\nstatic int   dcr_sfile_scanf(dcr_stream_obj *obj,const char *format, void* output);\r\n\r\nstatic dcr_stream_ops dcr_stream_fileops = {\r\n\tdcr_sfile_read,\r\n\tdcr_sfile_write,\r\n\tdcr_sfile_seek,\r\n\tdcr_sfile_close,\r\n\tdcr_sfile_gets,\r\n\tdcr_sfile_eof,\r\n\tdcr_sfile_tell,\r\n\tdcr_sfile_getc,\r\n\tdcr_sfile_scanf\r\n};\r\n\r\n\t/*\r\n\tNO_JPEG disables decoding of compressed Kodak DC120 files.\r\n\tNO_LCMS disables the \"-p\" option.\r\n\t*/\r\n#ifndef NO_JPEG\r\n  #if defined(_WIN32) || defined (_WIN64)\r\n    #include \"../jpeg/jpeglib.h\"\r\n  #else\r\n    #include <jpeglib.h>\r\n  #endif\r\n#endif\r\n\r\n#ifndef NO_LCMS\r\n  #if defined(_WIN32) || defined (_WIN64)\r\n    #include \"../lcms/lcms.h\"\r\n  #else\r\n    #include <lcms.h>\r\n  #endif\r\n#endif\r\n\r\n#ifdef LOCALEDIR\r\n#include <libintl.h>\r\n#define _(String) gettext(String)\r\n#else\r\n#define _(String) (String)\r\n#endif\r\n\r\n#ifdef __CYGWIN__\r\n#include <io.h>\r\n#endif\r\n#if defined(_WIN32) || defined (_WIN64)\r\n#include <sys/utime.h>\r\n#include <winsock2.h>\r\n#pragma comment(lib, \"ws2_32.lib\")\r\n#if defined(_MSC_VER) && _MSC_VER < 1900\r\n#define snprintf _snprintf\r\n#endif\r\n#define strcasecmp _stricmp\r\n#define strncasecmp _strnicmp\r\n\ttypedef __int64 INT64;\r\n\ttypedef unsigned __int64 UINT64;\r\n#else\r\n#include <unistd.h>\r\n#include <utime.h>\r\n#include <netinet/in.h>\r\n\ttypedef long long INT64;\r\n\ttypedef unsigned long long UINT64;\r\n\t#define __int64\t\tlong long\r\n#endif\r\n\r\n#ifdef LJPEG_DECODE\r\n#error Please compile dcraw.c by itself.\r\n#error Do not link it with ljpeg_decode.\r\n#endif\r\n\r\n#ifndef max\r\n#define max(A,B) (((A)>(B))?(A):(B))\r\n#endif\r\n\r\n/*\r\n   In order to inline this calculation, I make the risky\r\n   assumption that all filter patterns can be described\r\n   by a repeating pattern of eight rows and two columns\r\n\r\n   Do not use the FC or BAYER macros with the Leaf CatchLight,\r\n   because its pattern is 16x16, not 2x8.\r\n\r\n   Return values are either 0/1/2/3 = G/M/C/Y or 0/1/2/3 = R/G1/B/G2\r\n\r\n\tPowerShot 600\tPowerShot A50\tPowerShot Pro70\tPro90 & G1\r\n\t0xe1e4e1e4:\t0x1b4e4b1e:\t0x1e4b4e1b:\t0xb4b4b4b4:\r\n\r\n\t  0 1 2 3 4 5\t  0 1 2 3 4 5\t  0 1 2 3 4 5\t  0 1 2 3 4 5\r\n\t0 G M G M G M\t0 C Y C Y C Y\t0 Y C Y C Y C\t0 G M G M G M\r\n\t1 C Y C Y C Y\t1 M G M G M G\t1 M G M G M G\t1 Y C Y C Y C\r\n\t2 M G M G M G\t2 Y C Y C Y C\t2 C Y C Y C Y\r\n\t3 C Y C Y C Y\t3 G M G M G M\t3 G M G M G M\r\n\t\t\t4 C Y C Y C Y\t4 Y C Y C Y C\r\n\tPowerShot A5\t5 G M G M G M\t5 G M G M G M\r\n\t0x1e4e1e4e:\t6 Y C Y C Y C\t6 C Y C Y C Y\r\n\t\t\t7 M G M G M G\t7 M G M G M G\r\n\t  0 1 2 3 4 5\r\n\t0 C Y C Y C Y\r\n\t1 G M G M G M\r\n\t2 C Y C Y C Y\r\n\t3 M G M G M G\r\n\r\n   All RGB cameras use one of these Bayer grids:\r\n\r\n\t0x16161616:\t0x61616161:\t0x49494949:\t0x94949494:\r\n\r\n\t  0 1 2 3 4 5\t  0 1 2 3 4 5\t  0 1 2 3 4 5\t  0 1 2 3 4 5\r\n\t0 B G B G B G\t0 G R G R G R\t0 G B G B G B\t0 R G R G R G\r\n\t1 G R G R G R\t1 B G B G B G\t1 R G R G R G\t1 G B G B G B\r\n\t2 B G B G B G\t2 G R G R G R\t2 G B G B G B\t2 R G R G R G\r\n\t3 G R G R G R\t3 B G B G B G\t3 R G R G R G\t3 G B G B G B\r\n */\r\n\r\n#define FC(row,col) \\\r\n\t(p->filters >> ((((row) << 1 & 14) + ((col) & 1)) << 1) & 3)\r\n\r\n#define BAYER(row,col) \\\r\n\tp->image[((row) >> p->shrink)*p->iwidth + ((col) >> p->shrink)][FC(row,col)]\r\n\r\n#define BAYER2(row,col) \\\r\n\tp->image[((row) >> p->shrink)*p->iwidth + ((col) >> p->shrink)][dcr_fc(p,row,col)]\r\n\r\nint DCR_CLASS dcr_fc (DCRAW* p, int row, int col)\r\n{\r\n\tstatic const char filter[16][16] =\r\n\t{ { 2,1,1,3,2,3,2,0,3,2,3,0,1,2,1,0 },\r\n\t{ 0,3,0,2,0,1,3,1,0,1,1,2,0,3,3,2 },\r\n\t{ 2,3,3,2,3,1,1,3,3,1,2,1,2,0,0,3 },\r\n\t{ 0,1,0,1,0,2,0,2,2,0,3,0,1,3,2,1 },\r\n\t{ 3,1,1,2,0,1,0,2,1,3,1,3,0,1,3,0 },\r\n\t{ 2,0,0,3,3,2,3,1,2,0,2,0,3,2,2,1 },\r\n\t{ 2,3,3,1,2,1,2,1,2,1,1,2,3,0,0,1 },\r\n\t{ 1,0,0,2,3,0,0,3,0,3,0,3,2,1,2,3 },\r\n\t{ 2,3,3,1,1,2,1,0,3,2,3,0,2,3,1,3 },\r\n\t{ 1,0,2,0,3,0,3,2,0,1,1,2,0,1,0,2 },\r\n\t{ 0,1,1,3,3,2,2,1,1,3,3,0,2,1,3,2 },\r\n\t{ 2,3,2,0,0,1,3,0,2,0,1,2,3,0,1,0 },\r\n\t{ 1,3,1,2,3,2,3,2,0,2,0,1,1,0,3,0 },\r\n\t{ 0,2,0,3,1,0,0,1,1,3,3,2,3,2,2,1 },\r\n\t{ 2,1,3,2,3,1,2,1,0,3,0,2,0,2,0,2 },\r\n\t{ 0,3,1,0,0,2,0,3,2,1,3,1,1,3,1,3 } };\r\n\r\n\tif (p->filters != 1) return FC(row,col);\r\n\treturn filter[(row+p->top_margin) & 15][(col+p->left_margin) & 15];\r\n}\r\n\r\n#ifndef __GLIBC__\r\nchar *dcr_memmem (char *haystack, size_t haystacklen,\r\n\tchar *needle, size_t needlelen)\r\n{\r\n\tchar *c;\r\n\tfor (c = haystack; c <= haystack + haystacklen - needlelen; c++)\r\n\t\tif (!memcmp (c, needle, needlelen))\r\n\t\t\treturn c;\r\n\t\treturn 0;\r\n}\r\n#define memmem dcr_memmem\r\n#endif\r\n\r\nvoid DCR_CLASS dcr_merror (DCRAW* p, void *ptr, char *where)\r\n{\r\n\tif (ptr) return;\r\n\tif (p->sz_error){\r\n\t\tsprintf (p->sz_error,_(\"%s: Out of memory in %s\\n\"), p->ifname, where);\r\n\t} else {\r\n\t\tfprintf (stderr,_(\"%s: Out of memory in %s\\n\"), p->ifname, where);\r\n\t}\r\n\tlongjmp (p->failure, 1);\r\n}\r\n\r\nvoid DCR_CLASS dcr_derror(DCRAW* p)\r\n{\r\n\tif (!p->data_error) {\r\n\t\tfprintf (stderr, \"%s: \", p->ifname);\r\n\t\tif (dcr_feof(p->obj_))\r\n\t\t\tfprintf (stderr,_(\"Unexpected end of file\\n\"));\r\n\t\telse\r\n\t\t\tfprintf (stderr,_(\"Corrupt data near 0x%llx\\n\"), (INT64) dcr_ftell(p->obj_));\r\n\t}\r\n\tp->data_error = 1;\r\n}\r\n\r\nushort DCR_CLASS dcr_sget2 (DCRAW* p,uchar *s)\r\n{\r\n\tif (p->order == 0x4949)\t\t/* \"II\" means little-endian */\r\n\t\treturn s[0] | s[1] << 8;\r\n\telse\t\t\t\t/* \"MM\" means big-endian */\r\n\t\treturn s[0] << 8 | s[1];\r\n}\r\n\r\nushort DCR_CLASS dcr_get2(DCRAW* p)\r\n{\r\n\tuchar str[2] = { 0xff,0xff };\r\n\tdcr_fread(p->obj_, str, 1, 2);\r\n\treturn dcr_sget2(p, str);\r\n}\r\n\r\nunsigned DCR_CLASS dcr_sget4 (DCRAW* p,uchar *s)\r\n{\r\n\tif (p->order == 0x4949)\r\n\t\treturn s[0] | s[1] << 8 | s[2] << 16 | s[3] << 24;\r\n\telse\r\n\t\treturn s[0] << 24 | s[1] << 16 | s[2] << 8 | s[3];\r\n}\r\n#define dcr_sget4(p, s) dcr_sget4(p, (uchar *)s)\r\n\r\nunsigned DCR_CLASS dcr_get4(DCRAW* p)\r\n{\r\n\tuchar str[4] = { 0xff,0xff,0xff,0xff };\r\n\tdcr_fread(p->obj_, str, 1, 4);\r\n\treturn dcr_sget4(p, str);\r\n}\r\n\r\nunsigned DCR_CLASS dcr_getint (DCRAW* p,int type)\r\n{\r\n\treturn type == 3 ? dcr_get2(p) : dcr_get4(p);\r\n}\r\n\r\nfloat DCR_CLASS dcr_int_to_float (int i)\r\n{\r\n\tunion { int i; float f; } u;\r\n\tu.i = i;\r\n\treturn u.f;\r\n}\r\n\r\ndouble DCR_CLASS dcr_getreal (DCRAW* p,int type)\r\n{\r\n\tunion { char c[8]; double d; } u;\r\n\tint i, rev;\r\n\r\n\tswitch (type) {\r\n\tcase 3: return (unsigned short) dcr_get2(p);\r\n\tcase 4: return (unsigned int) dcr_get4(p);\r\n\tcase 5:  u.d = (unsigned int) dcr_get4(p);\r\n\t\treturn u.d / (unsigned int) dcr_get4(p);\r\n\tcase 8: return (signed short) dcr_get2(p);\r\n\tcase 9: return (signed int) dcr_get4(p);\r\n\tcase 10: u.d = (signed int) dcr_get4(p);\r\n\t\treturn u.d / (signed int) dcr_get4(p);\r\n\tcase 11: return dcr_int_to_float (dcr_get4(p));\r\n\tcase 12:\r\n\t\trev = 7 * ((p->order == 0x4949) == (ntohs(0x1234) == 0x1234));\r\n\t\tfor (i=0; i < 8; i++)\r\n\t\t\tu.c[i ^ rev] = dcr_fgetc(p->obj_);\r\n\t\treturn u.d;\r\n\tdefault: return dcr_fgetc(p->obj_);\r\n\t}\r\n}\r\n\r\nvoid DCR_CLASS dcr_read_shorts (DCRAW* p,ushort *pixel, int count)\r\n{\r\n\tif ((int)dcr_fread(p->obj_, pixel, 2, count) < count) dcr_derror(p);\r\n\tif ((p->order == 0x4949) == (ntohs(0x1234) == 0x1234))\r\n\t\t_swab ((char*)pixel, (char*)pixel, count*2);\r\n}\r\n\r\nvoid DCR_CLASS dcr_canon_black (DCRAW* p, double dark[2])\r\n{\r\n  int c, diff, row, col;\r\n\r\n  if (p->raw_width < p->width+4) return;\r\n  FORC(2) dark[c] /= (p->raw_width-p->width-2) * p->height >> 1;\r\n  if ((diff = (int)(dark[0] - dark[1])))\r\n    for (row=0; row < p->height; row++)\r\n      for (col=1; col < p->width; col+=2)\r\n\tBAYER(row,col) += diff;\r\n  dark[1] += diff;\r\n  p->black = (unsigned int)((dark[0] + dark[1] + 1) / 2);\r\n}\r\n\r\nvoid DCR_CLASS dcr_canon_600_fixed_wb (DCRAW* p,int temp)\r\n{\r\n\tstatic const short mul[4][5] = {\r\n\t\t{  667, 358,397,565,452 },\r\n\t\t{  731, 390,367,499,517 },\r\n\t\t{ 1119, 396,348,448,537 },\r\n\t\t{ 1399, 485,431,508,688 } };\r\n\tint lo, hi, i;\r\n\tfloat frac=0;\r\n\r\n\tfor (lo=4; --lo; )\r\n\t\tif (*mul[lo] <= temp) break;\r\n\tfor (hi=0; hi < 3; hi++)\r\n\t\tif (*mul[hi] >= temp) break;\r\n\tif (lo != hi)\r\n\t\tfrac = (float) (temp - *mul[lo]) / (*mul[hi] - *mul[lo]);\r\n\tfor (i=1; i < 5; i++)\r\n\t\tp->pre_mul[i-1] = 1 / (frac * mul[hi][i] + (1-frac) * mul[lo][i]);\r\n}\r\n\r\n/* Return values:  0 = p->white  1 = near p->white  2 = not p->white */\r\nint DCR_CLASS dcr_canon_600_color (DCRAW* p,int ratio[2], int mar)\r\n{\r\n\tint clipped=0, target, miss;\r\n\r\n\tif (p->flash_used) {\r\n\t\tif (ratio[1] < -104)\r\n\t\t{ ratio[1] = -104; clipped = 1; }\r\n\t\tif (ratio[1] >   12)\r\n\t\t{ ratio[1] =   12; clipped = 1; }\r\n\t} else {\r\n\t\tif (ratio[1] < -264 || ratio[1] > 461) return 2;\r\n\t\tif (ratio[1] < -50)\r\n\t\t{ ratio[1] = -50; clipped = 1; }\r\n\t\tif (ratio[1] > 307)\r\n\t\t{ ratio[1] = 307; clipped = 1; }\r\n\t}\r\n\ttarget = p->flash_used || ratio[1] < 197\r\n\t\t? -38 - (398 * ratio[1] >> 10)\r\n\t\t: -123 + (48 * ratio[1] >> 10);\r\n\tif (target - mar <= ratio[0] &&\r\n\t\ttarget + 20  >= ratio[0] && !clipped) return 0;\r\n\tmiss = target - ratio[0];\r\n\tif (abs(miss) >= mar*4) return 2;\r\n\tif (miss < -20) miss = -20;\r\n\tif (miss > mar) miss = mar;\r\n\tratio[0] = target - miss;\r\n\treturn 1;\r\n}\r\n\r\nvoid DCR_CLASS dcr_canon_600_auto_wb(DCRAW* p)\r\n{\r\n\tint mar, row, col, i, j, st, count[] = { 0,0 };\r\n\tint test[8], total[2][8], ratio[2][2], stat[2];\r\n\r\n\tmemset (&total, 0, sizeof total);\r\n\ti = (int)(p->canon_ev + 0.5);\r\n\tif      (i < 10) mar = 150;\r\n\telse if (i > 12) mar = 20;\r\n\telse mar = 280 - 20 * i;\r\n\tif (p->flash_used) mar = 80;\r\n\tfor (row=14; row < p->height-14; row+=4)\r\n\t\tfor (col=10; col < p->width; col+=2) {\r\n\t\t\tfor (i=0; i < 8; i++)\r\n\t\t\t\ttest[(i & 4) + FC(row+(i >> 1),col+(i & 1))] =\r\n\t\t\t\tBAYER(row+(i >> 1),col+(i & 1));\r\n\t\t\tfor (i=0; i < 8; i++)\r\n\t\t\t\tif (test[i] < 150 || test[i] > 1500) goto next;\r\n\t\t\tfor (i=0; i < 4; i++)\r\n\t\t\t\tif (abs(test[i] - test[i+4]) > 50) goto next;\r\n\t\t\tfor (i=0; i < 2; i++) {\r\n\t\t\t\tfor (j=0; j < 4; j+=2)\r\n\t\t\t\t\tratio[i][j >> 1] = ((test[i*4+j+1]-test[i*4+j]) << 10) / test[i*4+j];\r\n\t\t\t\tstat[i] = dcr_canon_600_color (p,ratio[i], mar);\r\n\t\t\t}\r\n\t\t\tif ((st = stat[0] | stat[1]) > 1) goto next;\r\n\t\t\tfor (i=0; i < 2; i++)\r\n\t\t\t\tif (stat[i])\r\n\t\t\t\t\tfor (j=0; j < 2; j++)\r\n\t\t\t\t\t\ttest[i*4+j*2+1] = test[i*4+j*2] * (0x400 + ratio[i][j]) >> 10;\r\n\t\t\tfor (i=0; i < 8; i++)\r\n\t\t\t\ttotal[st][i] += test[i];\r\n\t\t\tcount[st]++;\r\nnext: ;\r\n\t\t}\r\n\tif (count[0] | count[1]) {\r\n\t\tst = count[0]*200 < count[1];\r\n\t\tfor (i=0; i < 4; i++)\r\n\t\t\tp->pre_mul[i] = 1.0f / (total[st][i] + total[st][i+4]);\r\n\t}\r\n}\r\n\r\nvoid DCR_CLASS dcr_canon_600_coeff(DCRAW* p)\r\n{\r\n\tstatic const short table[6][12] = {\r\n\t\t{ -190,702,-1878,2390,   1861,-1349,905,-393, -432,944,2617,-2105  },\r\n\t\t{ -1203,1715,-1136,1648, 1388,-876,267,245,  -1641,2153,3921,-3409 },\r\n\t\t{ -615,1127,-1563,2075,  1437,-925,509,3,     -756,1268,2519,-2007 },\r\n\t\t{ -190,702,-1886,2398,   2153,-1641,763,-251, -452,964,3040,-2528  },\r\n\t\t{ -190,702,-1878,2390,   1861,-1349,905,-393, -432,944,2617,-2105  },\r\n\t\t{ -807,1319,-1785,2297,  1388,-876,769,-257,  -230,742,2067,-1555  } };\r\n\tint t=0, i, c;\r\n\tfloat mc, yc;\r\n\r\n\tmc = p->pre_mul[1] / p->pre_mul[2];\r\n\tyc = p->pre_mul[3] / p->pre_mul[2];\r\n\tif (mc > 1 && mc <= 1.28 && yc < 0.8789) t=1;\r\n\tif (mc > 1.28 && mc <= 2) {\r\n\t\tif  (yc < 0.8789) t=3;\r\n\t\telse if (yc <= 2) t=4;\r\n\t}\r\n\tif (p->flash_used) t=5;\r\n\tfor (p->raw_color = i=0; i < 3; i++)\r\n\t\tFORCC(p) p->rgb_cam[i][c] = table[t][i*4 + c] / 1024.0f;\r\n}\r\n\r\nvoid DCR_CLASS dcr_canon_600_load_raw(DCRAW* p)\r\n{\r\n\tuchar  data[1120], *dp;\r\n\tushort pixel[896], *pix;\r\n\tint irow, row, col, val;\r\n\tstatic const short mul[4][2] =\r\n\t{ { 1141,1145 }, { 1128,1109 }, { 1178,1149 }, { 1128,1109 } };\r\n\r\n\tfor (irow=row=0; irow < p->height; irow++) {\r\n\t\tif ((long)dcr_fread(p->obj_, data, 1, p->raw_width*5/4) < (long)(p->raw_width*5/4)) dcr_derror(p);\r\n\t\tfor (dp=data, pix=pixel; dp < data+1120; dp+=10, pix+=8) {\r\n\t\t\tpix[0] = (dp[0] << 2) + (dp[1] >> 6    );\r\n\t\t\tpix[1] = (dp[2] << 2) + (dp[1] >> 4 & 3);\r\n\t\t\tpix[2] = (dp[3] << 2) + (dp[1] >> 2 & 3);\r\n\t\t\tpix[3] = (dp[4] << 2) + (dp[1]      & 3);\r\n\t\t\tpix[4] = (dp[5] << 2) + (dp[9]      & 3);\r\n\t\t\tpix[5] = (dp[6] << 2) + (dp[9] >> 2 & 3);\r\n\t\t\tpix[6] = (dp[7] << 2) + (dp[9] >> 4 & 3);\r\n\t\t\tpix[7] = (dp[8] << 2) + (dp[9] >> 6    );\r\n\t\t}\r\n\t\tfor (col=0; col < p->width; col++)\r\n\t\t\tBAYER(row,col) = pixel[col];\r\n\t\tfor (col=p->width; col < p->raw_width; col++)\r\n\t\t\tp->black += pixel[col];\r\n\t\tif ((row+=2) > p->height) row = 1;\r\n\t}\r\n\tif (p->raw_width > p->width)\r\n\t\tp->black = p->black / ((p->raw_width - p->width) * p->height) - 4;\r\n\tfor (row=0; row < p->height; row++)\r\n\t\tfor (col=0; col < p->width; col++) {\r\n\t\t\tif ((val = BAYER(row,col) - p->black) < 0) val = 0;\r\n\t\t\tval = val * mul[row & 3][col & 1] >> 9;\r\n\t\t\tBAYER(row,col) = val;\r\n\t\t}\r\n\tdcr_canon_600_fixed_wb(p,1311);\r\n\tdcr_canon_600_auto_wb(p);\r\n\tdcr_canon_600_coeff(p);\r\n\tp->maximum = (0x3ff - p->black) * 1109 >> 9;\r\n\tp->black = 0;\r\n}\r\n\r\nvoid DCR_CLASS dcr_remove_zeroes(DCRAW* p)\r\n{\r\n\tunsigned row, col, tot, n, r, c;\r\n\r\n\tfor (row=0; row < p->height; row++)\r\n\t\tfor (col=0; col < p->width; col++)\r\n\t\t\tif (BAYER(row,col) == 0) {\r\n\t\t\t\ttot = n = 0;\r\n\t\t\t\tfor (r = row-2; r <= row+2; r++)\r\n\t\t\t\t\tfor (c = col-2; c <= col+2; c++)\r\n\t\t\t\t\t\tif (r < p->height && c < p->width &&\r\n\t\t\t\t\t\t\tFC(r,c) == FC(row,col) && BAYER(r,c))\r\n\t\t\t\t\t\t\ttot += (n++,BAYER(r,c));\r\n\t\t\t\t\t\tif (n) BAYER(row,col) = tot/n;\r\n\t\t\t}\r\n}\r\n\r\nint DCR_CLASS dcr_canon_s2is(DCRAW* p)\r\n{\r\n\tunsigned row;\r\n\r\n\tfor (row=0; row < 100; row++) {\r\n\t\tdcr_fseek(p->obj_, row*3340 + 3284, SEEK_SET);\r\n\t\tif (dcr_fgetc(p->obj_) > 15) return 1;\r\n\t}\r\n\treturn 0;\r\n}\r\n\r\nvoid DCR_CLASS dcr_canon_a5_load_raw(DCRAW* p)\r\n{\r\n\tushort data[2565], *dp, pixel;\r\n\tint vbits=0, buf=0, row, col, bc=0;\r\n\r\n\tp->order = 0x4949;\r\n\tfor (row=-p->top_margin; row < p->raw_height-p->top_margin; row++) {\r\n\t\tdcr_read_shorts (p,dp=data, p->raw_width * 10 / 16);\r\n\t\tfor (col=-p->left_margin; col < p->raw_width-p->left_margin; col++) {\r\n\t\t\tif ((vbits -= 10) < 0)\r\n\t\t\t\tbuf = (vbits += 16, (buf << 16) + *dp++);\r\n\t\t\tpixel = buf >> vbits & 0x3ff;\r\n\t\t\tif ((unsigned) row < p->height && (unsigned) col < p->width)\r\n\t\t\t\tBAYER(row,col) = pixel;\r\n\t\t\telse if (col > 1-p->left_margin && col != p->width)\r\n\t\t\t\tp->black += (bc++,pixel);\r\n\t\t}\r\n\t}\r\n\tif (bc) p->black /= bc;\r\n\tp->maximum = 0x3ff;\r\n\tif (p->raw_width > 1600) dcr_remove_zeroes(p);\r\n}\r\n\r\n/*\r\ndcr_getbits(p, -1) initializes the buffer\r\ndcr_getbits(p, n) where 0 <= n <= 25 returns an n-bit integer\r\n*/\r\nunsigned DCR_CLASS dcr_getbits (DCRAW* p, int nbits)\r\n{\r\n\tstatic unsigned bitbuf=0;\r\n\tstatic int vbits=0, reset=0;\r\n\tunsigned c;\r\n\r\n\tif (nbits == -1)\r\n\t\treturn bitbuf = vbits = reset = 0;\r\n\tif (nbits == 0 || reset) return 0;\r\n\twhile (vbits < nbits) {\r\n\t\tif ((c = dcr_fgetc(p->obj_)) == EOF) dcr_derror(p);\r\n\t\tif ((reset = p->zero_after_ff && c == 0xff && dcr_fgetc(p->obj_))) return 0;\r\n\t\tbitbuf = (bitbuf << 8) + (uchar) c;\r\n\t\tvbits += 8;\r\n\t}\r\n\tvbits -= nbits;\r\n\treturn bitbuf << (32-nbits-vbits) >> (32-nbits);\r\n}\r\n\r\nvoid DCR_CLASS dcr_init_decoder(DCRAW* p)\r\n{\r\n\tmemset (p->first_decode, 0, sizeof p->first_decode);\r\n\tp->free_decode = p->first_decode;\r\n}\r\n\r\n/*\r\n   Construct a decode tree according the specification in *source.\r\n   The first 16 bytes specify how many codes should be 1-bit, 2-bit\r\n   3-bit, etc.  Bytes after that are the leaf values.\r\n\r\n   For example, if the source is\r\n\r\n    { 0,1,4,2,3,1,2,0,0,0,0,0,0,0,0,0,\r\n      0x04,0x03,0x05,0x06,0x02,0x07,0x01,0x08,0x09,0x00,0x0a,0x0b,0xff  },\r\n\r\n   then the code is\r\n\r\n\t00\t\t0x04\r\n\t010\t\t0x03\r\n\t011\t\t0x05\r\n\t100\t\t0x06\r\n\t101\t\t0x02\r\n\t1100\t\t0x07\r\n\t1101\t\t0x01\r\n\t11100\t\t0x08\r\n\t11101\t\t0x09\r\n\t11110\t\t0x00\r\n\t111110\t\t0x0a\r\n\t1111110\t\t0x0b\r\n\t1111111\t\t0xff\r\n */\r\nuchar * DCR_CLASS dcr_make_decoder (DCRAW* p, const uchar *source, int level)\r\n{\r\n\tstruct dcr_decode *cur;\r\n\tstatic int leaf;\r\n\tint i, next;\r\n\r\n\tif (level==0) leaf=0;\r\n\tcur = p->free_decode++;\r\n\tif (p->free_decode > p->first_decode+2048) {\r\n\t\tfprintf (stderr,_(\"%s: decoder table overflow\\n\"), p->ifname);\r\n\t\tlongjmp (p->failure, 2);\r\n\t}\r\n\tfor (i=next=0; i <= leaf && next < 16; )\r\n\t\ti += source[next++];\r\n\tif (i > leaf) {\r\n\t\tif (level < next) {\r\n\t\t\tcur->branch[0] = p->free_decode;\r\n\t\t\tdcr_make_decoder (p, source, level+1);\r\n\t\t\tcur->branch[1] = p->free_decode;\r\n\t\t\tdcr_make_decoder (p, source, level+1);\r\n\t\t} else\r\n\t\t\tcur->leaf = source[16 + leaf++];\r\n\t}\r\n\treturn (uchar *) source + 16 + leaf;\r\n}\r\n\r\nvoid DCR_CLASS dcr_crw_init_tables (DCRAW* p, unsigned table)\r\n{\r\n\tstatic const uchar first_tree[3][29] = {\r\n\t\t{ 0,1,4,2,3,1,2,0,0,0,0,0,0,0,0,0,\r\n\t\t\t0x04,0x03,0x05,0x06,0x02,0x07,0x01,0x08,0x09,0x00,0x0a,0x0b,0xff  },\r\n\t\t{ 0,2,2,3,1,1,1,1,2,0,0,0,0,0,0,0,\r\n\t\t0x03,0x02,0x04,0x01,0x05,0x00,0x06,0x07,0x09,0x08,0x0a,0x0b,0xff  },\r\n\t\t{ 0,0,6,3,1,1,2,0,0,0,0,0,0,0,0,0,\r\n\t\t0x06,0x05,0x07,0x04,0x08,0x03,0x09,0x02,0x00,0x0a,0x01,0x0b,0xff  },\r\n\t};\r\n\tstatic const uchar second_tree[3][180] = {\r\n\t\t{ 0,2,2,2,1,4,2,1,2,5,1,1,0,0,0,139,\r\n\t\t0x03,0x04,0x02,0x05,0x01,0x06,0x07,0x08,\r\n\t\t0x12,0x13,0x11,0x14,0x09,0x15,0x22,0x00,0x21,0x16,0x0a,0xf0,\r\n\t\t0x23,0x17,0x24,0x31,0x32,0x18,0x19,0x33,0x25,0x41,0x34,0x42,\r\n\t\t0x35,0x51,0x36,0x37,0x38,0x29,0x79,0x26,0x1a,0x39,0x56,0x57,\r\n\t\t0x28,0x27,0x52,0x55,0x58,0x43,0x76,0x59,0x77,0x54,0x61,0xf9,\r\n\t\t0x71,0x78,0x75,0x96,0x97,0x49,0xb7,0x53,0xd7,0x74,0xb6,0x98,\r\n\t\t0x47,0x48,0x95,0x69,0x99,0x91,0xfa,0xb8,0x68,0xb5,0xb9,0xd6,\r\n\t\t0xf7,0xd8,0x67,0x46,0x45,0x94,0x89,0xf8,0x81,0xd5,0xf6,0xb4,\r\n\t\t0x88,0xb1,0x2a,0x44,0x72,0xd9,0x87,0x66,0xd4,0xf5,0x3a,0xa7,\r\n\t\t0x73,0xa9,0xa8,0x86,0x62,0xc7,0x65,0xc8,0xc9,0xa1,0xf4,0xd1,\r\n\t\t0xe9,0x5a,0x92,0x85,0xa6,0xe7,0x93,0xe8,0xc1,0xc6,0x7a,0x64,\r\n\t\t0xe1,0x4a,0x6a,0xe6,0xb3,0xf1,0xd3,0xa5,0x8a,0xb2,0x9a,0xba,\r\n\t\t0x84,0xa4,0x63,0xe5,0xc5,0xf3,0xd2,0xc4,0x82,0xaa,0xda,0xe4,\r\n\t\t0xf2,0xca,0x83,0xa3,0xa2,0xc3,0xea,0xc2,0xe2,0xe3,0xff,0xff  },\r\n\t\t{ 0,2,2,1,4,1,4,1,3,3,1,0,0,0,0,140,\r\n\t\t0x02,0x03,0x01,0x04,0x05,0x12,0x11,0x06,\r\n\t\t0x13,0x07,0x08,0x14,0x22,0x09,0x21,0x00,0x23,0x15,0x31,0x32,\r\n\t\t0x0a,0x16,0xf0,0x24,0x33,0x41,0x42,0x19,0x17,0x25,0x18,0x51,\r\n\t\t0x34,0x43,0x52,0x29,0x35,0x61,0x39,0x71,0x62,0x36,0x53,0x26,\r\n\t\t0x38,0x1a,0x37,0x81,0x27,0x91,0x79,0x55,0x45,0x28,0x72,0x59,\r\n\t\t0xa1,0xb1,0x44,0x69,0x54,0x58,0xd1,0xfa,0x57,0xe1,0xf1,0xb9,\r\n\t\t0x49,0x47,0x63,0x6a,0xf9,0x56,0x46,0xa8,0x2a,0x4a,0x78,0x99,\r\n\t\t0x3a,0x75,0x74,0x86,0x65,0xc1,0x76,0xb6,0x96,0xd6,0x89,0x85,\r\n\t\t0xc9,0xf5,0x95,0xb4,0xc7,0xf7,0x8a,0x97,0xb8,0x73,0xb7,0xd8,\r\n\t\t0xd9,0x87,0xa7,0x7a,0x48,0x82,0x84,0xea,0xf4,0xa6,0xc5,0x5a,\r\n\t\t0x94,0xa4,0xc6,0x92,0xc3,0x68,0xb5,0xc8,0xe4,0xe5,0xe6,0xe9,\r\n\t\t0xa2,0xa3,0xe3,0xc2,0x66,0x67,0x93,0xaa,0xd4,0xd5,0xe7,0xf8,\r\n\t\t0x88,0x9a,0xd7,0x77,0xc4,0x64,0xe2,0x98,0xa5,0xca,0xda,0xe8,\r\n\t\t0xf3,0xf6,0xa9,0xb2,0xb3,0xf2,0xd2,0x83,0xba,0xd3,0xff,0xff  },\r\n\t\t{ 0,0,6,2,1,3,3,2,5,1,2,2,8,10,0,117,\r\n\t\t0x04,0x05,0x03,0x06,0x02,0x07,0x01,0x08,\r\n\t\t0x09,0x12,0x13,0x14,0x11,0x15,0x0a,0x16,0x17,0xf0,0x00,0x22,\r\n\t\t0x21,0x18,0x23,0x19,0x24,0x32,0x31,0x25,0x33,0x38,0x37,0x34,\r\n\t\t0x35,0x36,0x39,0x79,0x57,0x58,0x59,0x28,0x56,0x78,0x27,0x41,\r\n\t\t0x29,0x77,0x26,0x42,0x76,0x99,0x1a,0x55,0x98,0x97,0xf9,0x48,\r\n\t\t0x54,0x96,0x89,0x47,0xb7,0x49,0xfa,0x75,0x68,0xb6,0x67,0x69,\r\n\t\t0xb9,0xb8,0xd8,0x52,0xd7,0x88,0xb5,0x74,0x51,0x46,0xd9,0xf8,\r\n\t\t0x3a,0xd6,0x87,0x45,0x7a,0x95,0xd5,0xf6,0x86,0xb4,0xa9,0x94,\r\n\t\t0x53,0x2a,0xa8,0x43,0xf5,0xf7,0xd4,0x66,0xa7,0x5a,0x44,0x8a,\r\n\t\t0xc9,0xe8,0xc8,0xe7,0x9a,0x6a,0x73,0x4a,0x61,0xc7,0xf4,0xc6,\r\n\t\t0x65,0xe9,0x72,0xe6,0x71,0x91,0x93,0xa6,0xda,0x92,0x85,0x62,\r\n\t\t0xf3,0xc5,0xb2,0xa4,0x84,0xba,0x64,0xa5,0xb3,0xd2,0x81,0xe5,\r\n\t\t0xd3,0xaa,0xc4,0xca,0xf2,0xb1,0xe4,0xd1,0x83,0x63,0xea,0xc3,\r\n\t\t0xe2,0x82,0xf1,0xa3,0xc2,0xa1,0xc1,0xe3,0xa2,0xe1,0xff,0xff  }\r\n\t};\r\n\tif (table > 2) table = 2;\r\n\tdcr_init_decoder(p);\r\n\tdcr_make_decoder (p, first_tree[table], 0);\r\n\tp->second_decode = p->free_decode;\r\n\tdcr_make_decoder (p, second_tree[table], 0);\r\n}\r\n\r\n/*\r\nReturn 0 if the image starts with compressed data,\r\n1 if it starts with uncompressed low-order bits.\r\n\r\n  In Canon compressed data, 0xff is always followed by 0x00.\r\n*/\r\nint DCR_CLASS dcr_canon_has_lowbits(DCRAW* p)\r\n{\r\n\tuchar test[0x4000];\r\n\tint ret=1, i;\r\n\r\n\tdcr_fseek(p->obj_, 0, SEEK_SET);\r\n\tdcr_fread(p->obj_, test, 1, sizeof test);\r\n\tfor (i=540; i < sizeof test - 1; i++)\r\n\t\tif (test[i] == 0xff) {\r\n\t\t\tif (test[i+1]) return 1;\r\n\t\t\tret=0;\r\n\t\t}\r\n\treturn ret;\r\n}\r\n\r\nvoid DCR_CLASS dcr_canon_compressed_load_raw(DCRAW* p)\r\n{\r\n\tushort *pixel, *prow;\r\n\tint nblocks, lowbits, i, row, r, col, save, val;\r\n\tunsigned irow, icol;\r\n\tstruct dcr_decode *decode, *dindex;\r\n\tint block, diffbuf[64], leaf, len, diff, carry=0, pnum=0, base[2];\r\n\tdouble dark[2] = { 0,0 };\r\n\tuchar c;\r\n\r\n\tdcr_crw_init_tables (p, p->tiff_compress);\r\n\tpixel = (ushort *) calloc (p->raw_width*8, sizeof *pixel);\r\n\tdcr_merror (p, pixel, \"canon_compressed_load_raw()\");\r\n\tlowbits = dcr_canon_has_lowbits(p);\r\n\tif (!lowbits) p->maximum = 0x3ff;\r\n\tdcr_fseek(p->obj_, 540 + lowbits*p->raw_height*p->raw_width/4, SEEK_SET);\r\n\tp->zero_after_ff = 1;\r\n\tdcr_getbits(p, -1);\r\n\tfor (row=0; row < p->raw_height; row+=8) {\r\n\t\tnblocks = MIN (8, p->raw_height-row) * p->raw_width >> 6;\r\n\t\tfor (block=0; block < nblocks; block++) {\r\n\t\t\tmemset (diffbuf, 0, sizeof diffbuf);\r\n\t\t\tdecode = p->first_decode;\r\n\t\t\tfor (i=0; i < 64; i++ ) {\r\n\t\t\t\tfor (dindex=decode; dindex->branch[0]; )\r\n\t\t\t\t\tdindex = dindex->branch[dcr_getbits(p, 1)];\r\n\t\t\t\tleaf = dindex->leaf;\r\n\t\t\t\tdecode = p->second_decode;\r\n\t\t\t\tif (leaf == 0 && i) break;\r\n\t\t\t\tif (leaf == 0xff) continue;\r\n\t\t\t\ti  += leaf >> 4;\r\n\t\t\t\tlen = leaf & 15;\r\n\t\t\t\tif (len == 0) continue;\r\n\t\t\t\tdiff = dcr_getbits(p, len);\r\n\t\t\t\tif ((diff & (1 << (len-1))) == 0)\r\n\t\t\t\t\tdiff -= (1 << len) - 1;\r\n\t\t\t\tif (i < 64) diffbuf[i] = diff;\r\n\t\t\t}\r\n\t\t\tdiffbuf[0] += carry;\r\n\t\t\tcarry = diffbuf[0];\r\n\t\t\tfor (i=0; i < 64; i++ ) {\r\n\t\t\t\tif (pnum++ % p->raw_width == 0)\r\n\t\t\t\t\tbase[0] = base[1] = 512;\r\n\t\t\t\tif ((pixel[(block << 6) + i] = base[i & 1] += diffbuf[i]) >> 10)\r\n\t\t\t\t\tdcr_derror(p);\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (lowbits) {\r\n\t\t\tsave = dcr_ftell(p->obj_);\r\n\t\t\tdcr_fseek(p->obj_, 26 + row*p->raw_width/4, SEEK_SET);\r\n\t\t\tfor (prow=pixel, i=0; i < p->raw_width*2; i++) {\r\n\t\t\t\tc = dcr_fgetc(p->obj_);\r\n\t\t\t\tfor (r=0; r < 8; r+=2, prow++) {\r\n\t\t\t\t\tval = (*prow << 2) + ((c >> r) & 3);\r\n\t\t\t\t\tif (p->raw_width == 2672 && val < 512) val += 2;\r\n\t\t\t\t\t*prow = val;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tdcr_fseek(p->obj_, save, SEEK_SET);\r\n\t\t}\r\n\t\tfor (r=0; r < 8; r++) {\r\n\t\t\tirow = row - p->top_margin + r;\r\n\t\t\tif (irow >= p->height) continue;\r\n\t\t\tfor (col=0; col < p->raw_width; col++) {\r\n\t\t\t\ticol = col - p->left_margin;\r\n\t\t\t\tif (icol < p->width)\r\n\t\t\t\t\tBAYER(irow,icol) = pixel[r*p->raw_width+col];\r\n\t\t\t\telse if (col > 1)\r\n\t\t\t\t\tdark[icol & 1] += pixel[r*p->raw_width+col];\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tfree (pixel);\r\n\tdcr_canon_black (p, dark);\r\n}\r\n\r\n/*\r\nNot a full implementation of Lossless JPEG, just\r\nenough to decode Canon, Kodak and Adobe DNG images.\r\n*/\r\n\r\nint DCR_CLASS dcr_ljpeg_start (DCRAW* p, struct dcr_jhead *jh, int info_only)\r\n{\r\n\tint c, tag, len;\r\n\tuchar data[0x10000], *dp;\r\n\r\n\tif (!info_only) dcr_init_decoder(p);\r\n\tmemset (jh, 0, sizeof *jh);\r\n\tFORC(6) jh->huff[c] = p->free_decode;\r\n\tjh->restart = INT_MAX;\r\n\tdcr_fread(p->obj_, data, 2, 1);\r\n\tif (data[1] != 0xd8) return 0;\r\n\tdo {\r\n\t\tdcr_fread(p->obj_, data, 2, 2);\r\n\t\ttag =  data[0] << 8 | data[1];\r\n\t\tlen = (data[2] << 8 | data[3]) - 2;\r\n\t\tif (tag <= 0xff00) return 0;\r\n\t\tdcr_fread(p->obj_, data, 1, len);\r\n\t\tswitch (tag) {\r\n\t\tcase 0xffc3:\r\n\t\t\tjh->sraw = ((data[7] >> 4) * (data[7] & 15) - 1) & 3;\r\n\t\tcase 0xffc0:\r\n\t\t\tjh->bits = data[0];\r\n\t\t\tjh->high = data[1] << 8 | data[2];\r\n\t\t\tjh->wide = data[3] << 8 | data[4];\r\n\t\t\tjh->clrs = data[5] + jh->sraw;\r\n\t\t\tif (len == 9 && !p->dng_version) dcr_fgetc(p->obj_);\r\n\t\t\tbreak;\r\n\t\tcase 0xffc4:\r\n\t\t\tif (info_only) break;\r\n\t\t\tfor (dp = data; dp < data+len && *dp < 4; ) {\r\n\t\t\t\tjh->huff[*dp] = p->free_decode;\r\n\t\t\t\tdp = dcr_make_decoder (p, ++dp, 0);\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\tcase 0xffda:\r\n\t\t\tjh->psv = data[1+data[0]*2];\r\n\t\t\tjh->bits -= data[3+data[0]*2] & 15;\r\n\t\t\tbreak;\r\n\t\tcase 0xffdd:\r\n\t\t\tjh->restart = data[0] << 8 | data[1];\r\n\t\t}\r\n\t} while (tag != 0xffda);\r\n\tif (info_only) return 1;\r\n\tif (jh->sraw) {\r\n\t\tFORC(4)        jh->huff[2+c] = jh->huff[1];\r\n\t\tFORC(jh->sraw) jh->huff[1+c] = jh->huff[0];\r\n\t}\r\n\tjh->row = (ushort *) calloc (jh->wide*jh->clrs, 4);\r\n\tdcr_merror (p, jh->row, \"dcr_ljpeg_start()\");\r\n\treturn p->zero_after_ff = 1;\r\n}\r\n\r\nint DCR_CLASS dcr_ljpeg_diff (DCRAW* p, struct dcr_decode *dindex)\r\n{\r\n\tint len, diff;\r\n\r\n\twhile (dindex->branch[0])\r\n\t\tdindex = dindex->branch[dcr_getbits(p, 1)];\r\n\tlen = dindex->leaf;\r\n\tif (len == 16 && (!p->dng_version || p->dng_version >= 0x1010000))\r\n\t\treturn -32768;\r\n\tdiff = dcr_getbits(p, len);\r\n\tif ((diff & (1 << (len-1))) == 0)\r\n\t\tdiff -= (1 << len) - 1;\r\n\treturn diff;\r\n}\r\n\r\nushort * DCR_CLASS dcr_ljpeg_row (DCRAW* p, int jrow, struct dcr_jhead *jh)\r\n{\r\n\tint col, c, diff, pred, spred=0;\r\n\tushort mark=0, *row[3];\r\n\r\n\tif (jrow * jh->wide % jh->restart == 0) {\r\n\t\tFORC(6) jh->vpred[c] = 1 << (jh->bits-1);\r\n\t\tif (jrow)\r\n\t\t\tdo mark = (mark << 8) + (c = dcr_fgetc(p->obj_));\r\n\t\t\twhile (c != EOF && mark >> 4 != 0xffd);\r\n\t\t\tdcr_getbits(p, -1);\r\n\t}\r\n\tFORC3 row[c] = jh->row + jh->wide*jh->clrs*((jrow+c) & 1);\r\n\tfor (col=0; col < jh->wide; col++)\r\n\t\tFORC(jh->clrs) {\r\n\t\t\tdiff = dcr_ljpeg_diff (p, jh->huff[c]);\r\n\t\t\tif (jh->sraw && c <= jh->sraw && (col | c))\r\n\t\t\t\tpred = spred;\r\n\t\t\telse if (col) pred = row[0][-jh->clrs];\r\n\t\t\telse\t    pred = (jh->vpred[c] += diff) - diff;\r\n\t\t\tif (jrow && col) switch (jh->psv) {\r\n\t\t\t\tcase 1:\tbreak;\r\n\t\t\t\tcase 2: pred = row[1][0];\t\t\t\t\tbreak;\r\n\t\t\t\tcase 3: pred = row[1][-jh->clrs];\t\t\t\tbreak;\r\n\t\t\t\tcase 4: pred = pred +   row[1][0] - row[1][-jh->clrs];\t\tbreak;\r\n\t\t\t\tcase 5: pred = pred + ((row[1][0] - row[1][-jh->clrs]) >> 1);\tbreak;\r\n\t\t\t\tcase 6: pred = row[1][0] + ((pred - row[1][-jh->clrs]) >> 1);\tbreak;\r\n\t\t\t\tcase 7: pred = (pred + row[1][0]) >> 1;\t\t\t\tbreak;\r\n\t\t\t\tdefault: pred = 0;\r\n\t\t\t}\r\n\t\t\tif ((**row = pred + diff) >> jh->bits) dcr_derror(p);\r\n\t\t\tif (c <= jh->sraw) spred = **row;\r\n\t\t\trow[0]++; row[1]++;\r\n\t\t}\r\n\t\treturn row[2];\r\n}\r\n\r\nvoid DCR_CLASS dcr_lossless_jpeg_load_raw(DCRAW* p)\r\n{\r\n\tint jwide, jrow, jcol, val, jidx, i, j, row=0, col=0;\r\n\tdouble dark[2] = { 0,0 };\r\n\tstruct dcr_jhead jh;\r\n\tint min=INT_MAX;\r\n\tushort *rp;\r\n\r\n\tif (!dcr_ljpeg_start (p,&jh, 0)) return;\r\n\tjwide = jh.wide * jh.clrs;\r\n\r\n\tfor (jrow=0; jrow < jh.high; jrow++) {\r\n\t\trp = dcr_ljpeg_row (p, jrow, &jh);\r\n\t\tfor (jcol=0; jcol < jwide; jcol++) {\r\n\t\t\tval = *rp++;\r\n\t\t\tif (jh.bits <= 12)\r\n\t\t\t\tval = p->curve[val & 0xfff];\r\n\t\t\tif (p->cr2_slice[0]) {\r\n\t\t\t\tjidx = jrow*jwide + jcol;\r\n\t\t\t\ti = jidx / (p->cr2_slice[1]*jh.high);\r\n\t\t\t\tif ((j = i >= p->cr2_slice[0]))\r\n\t\t\t\t\ti  = p->cr2_slice[0];\r\n\t\t\t\tjidx -= i * (p->cr2_slice[1]*jh.high);\r\n\t\t\t\trow = jidx / p->cr2_slice[1+j];\r\n\t\t\t\tcol = jidx % p->cr2_slice[1+j] + i*p->cr2_slice[1];\r\n\t\t\t}\r\n\t\t\tif (p->raw_width == 3984 && (col -= 2) < 0)\r\n\t\t\t\tcol += (row--,p->raw_width);\r\n\t\t\tif ((unsigned) (row-p->top_margin) < p->height) {\r\n\t\t\t\tif ((unsigned) (col-p->left_margin) < p->width) {\r\n\t\t\t\t\tBAYER(row-p->top_margin,col-p->left_margin) = val;\r\n\t\t\t\t\tif (min > val) min = val;\r\n\t\t\t\t} else if (col > 1)\r\n\t\t\t\t\tdark[(col-p->left_margin) & 1] += val;\r\n\t\t\t}\r\n\t\t\tif (++col >= p->raw_width)\r\n\t\t\t\tcol = (row++,0);\r\n\t\t}\r\n\t}\r\n\tfree (jh.row);\r\n\tdcr_canon_black (p, dark);\r\n\tif (!strcasecmp(p->make,\"KODAK\"))\r\n\t\tp->black = min;\r\n}\r\n\r\nvoid DCR_CLASS dcr_canon_sraw_load_raw(DCRAW* p)\r\n{\r\n\tstruct dcr_jhead jh;\r\n\tshort *rp=0, (*ip)[4];\r\n\tint jwide, slice, scol, ecol, row, col, jrow=0, jcol=0, pix[3], c;\r\n\tint v[3]={0,0,0}, ver, hue;\r\n\tchar *cp;\r\n\t\r\n\tif (!dcr_ljpeg_start (p, &jh, 0)) return;\r\n\tjwide = (jh.wide >>= 1) * jh.clrs;\r\n\t\r\n\tfor (ecol=slice=0; slice <= p->cr2_slice[0]; slice++) {\r\n\t\tscol = ecol;\r\n\t\tecol += p->cr2_slice[1] * 2 / jh.clrs;\r\n\t\tif (!p->cr2_slice[0] || ecol > p->raw_width-1) ecol = p->raw_width & -2;\r\n\t\tfor (row=0; row < p->height; row += (jh.clrs >> 1) - 1) {\r\n\t\t\tip = (short (*)[4]) p->image + row*p->width;\r\n\t\t\tfor (col=scol; col < ecol; col+=2, jcol+=jh.clrs) {\r\n\t\t\t\tif ((jcol %= jwide) == 0)\r\n\t\t\t\t\trp = (short *) dcr_ljpeg_row (p, jrow++, &jh);\r\n\t\t\t\tif (col >= p->width) continue;\r\n\t\t\t\tFORC (jh.clrs-2)\r\n\t\t\t\t\tip[col + (c >> 1)*p->width + (c & 1)][0] = rp[jcol+c];\r\n\t\t\t\tip[col][1] = rp[jcol+jh.clrs-2] - 16384;\r\n\t\t\t\tip[col][2] = rp[jcol+jh.clrs-1] - 16384;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tfor (cp=p->model2; *cp && !isdigit(*cp); cp++);\r\n\tsscanf (cp, \"%d.%d.%d\", v, v+1, v+2);\r\n\tver = (v[0]*1000 + v[1])*1000 + v[2];\r\n\thue = (jh.sraw+1) << 2;\r\n\tif (p->unique_id == 0x80000218 && ver > 1000006 && ver < 3000000)\r\n\t\thue = jh.sraw << 1;\r\n\tip = (short (*)[4]) p->image;\r\n\trp = ip[0];\r\n\tfor (row=0; row < p->height; row++, ip+=p->width) {\r\n\t\tif (row & (jh.sraw >> 1))\r\n\t\t\tfor (col=0; col < p->width; col+=2)\r\n\t\t\t\tfor (c=1; c < 3; c++)\r\n\t\t\t\t\tif (row == p->height-1)\r\n\t\t\t\t\t\tip[col][c] =  ip[col-p->width][c];\r\n\t\t\t\t\telse ip[col][c] = (ip[col-p->width][c] + ip[col+p->width][c] + 1) >> 1;\r\n\t\t\t\t\tfor (col=1; col < p->width; col+=2)\r\n\t\t\t\t\t\tfor (c=1; c < 3; c++)\r\n\t\t\t\t\t\t\tif (col == p->width-1)\r\n\t\t\t\t\t\t\t\tip[col][c] =  ip[col-1][c];\r\n\t\t\t\t\t\t\telse ip[col][c] = (ip[col-1][c] + ip[col+1][c] + 1) >> 1;\r\n\t}\r\n\tfor ( ; rp < ip[0]; rp+=4) {\r\n\t\tif (p->unique_id < 0x80000200) {\r\n\t\t\tpix[0] = rp[0] + rp[2] - 512;\r\n\t\t\tpix[2] = rp[0] + rp[1] - 512;\r\n\t\t\tpix[1] = rp[0] + ((-778*rp[1] - (rp[2] << 11)) >> 12) - 512;\r\n\t\t} else {\r\n\t\t\trp[1] = (rp[1] << 2) + hue;\r\n\t\t\trp[2] = (rp[2] << 2) + hue;\r\n\t\t\tpix[0] = rp[0] + ((  200*rp[1] + 22929*rp[2]) >> 14);\r\n\t\t\tpix[1] = rp[0] + ((-5640*rp[1] - 11751*rp[2]) >> 14);\r\n\t\t\tpix[2] = rp[0] + ((29040*rp[1] -   101*rp[2]) >> 14);\r\n\t\t}\r\n\t\tFORC3 rp[c] = CLIP(pix[c] * p->sraw_mul[c] >> 10);\r\n\t}\r\n\tfree (jh.row);\r\n\tp->maximum = 0x3fff;\r\n}\r\n\r\nvoid DCR_CLASS dcr_adobe_copy_pixel (DCRAW* p, int row, int col, ushort **rp)\r\n{\r\n\tunsigned r, c;\r\n\r\n\tr = row -= p->top_margin;\r\n\tc = col -= p->left_margin;\r\n\tif (p->is_raw == 2 && p->opt.shot_select) (*rp)++;\r\n\tif (p->filters) {\r\n\t\tif (p->fuji_width) {\r\n\t\t\tr = row + p->fuji_width - 1 - (col >> 1);\r\n\t\t\tc = row + ((col+1) >> 1);\r\n\t\t}\r\n\t\tif (r < p->height && c < p->width)\r\n\t\t\tBAYER(r,c) = **rp < 0x1000 ? p->curve[**rp] : **rp;\r\n\t\t*rp += p->is_raw;\r\n\t} else {\r\n\t\tif (r < p->height && c < p->width)\r\n\t\t\tFORC(p->tiff_samples)\r\n\t\t\t\tp->image[row*p->width+col][c] = (*rp)[c] < 0x1000 ? p->curve[(*rp)[c]]:(*rp)[c];\r\n\t\t\t*rp += p->tiff_samples;\r\n\t}\r\n\tif (p->is_raw == 2 && p->opt.shot_select) (*rp)--;\r\n}\r\n\r\nvoid DCR_CLASS dcr_adobe_dng_load_raw_lj(DCRAW* p)\r\n{\r\n\tunsigned save, trow=0, tcol=0, jwide, jrow, jcol, row, col;\r\n\tstruct dcr_jhead jh;\r\n\tushort *rp;\r\n\r\n\twhile (trow < p->raw_height) {\r\n\t\tsave = dcr_ftell(p->obj_);\r\n\t\tif (p->tile_length < INT_MAX)\r\n\t\t\tdcr_fseek(p->obj_, dcr_get4(p), SEEK_SET);\r\n\t\tif (!dcr_ljpeg_start (p,&jh, 0)) break;\r\n\t\tjwide = jh.wide;\r\n\t\tif (p->filters) jwide *= jh.clrs;\r\n\t\tjwide /= p->is_raw;\r\n\t\tfor (row=col=jrow=0; (int)jrow < jh.high; jrow++) {\r\n\t\t\trp = dcr_ljpeg_row (p, jrow, &jh);\r\n\t\t\tfor (jcol=0; jcol < jwide; jcol++) {\r\n\t\t\t\tdcr_adobe_copy_pixel (p,trow+row, tcol+col, &rp);\r\n\t\t\t\tif (++col >= p->tile_width || col >= p->raw_width)\r\n\t\t\t\t\trow += 1 + (col = 0);\r\n\t\t\t}\r\n\t\t}\r\n\t\tdcr_fseek(p->obj_, save+4, SEEK_SET);\r\n\t\tif ((tcol += p->tile_width) >= p->raw_width)\r\n\t\t\ttrow += p->tile_length + (tcol = 0);\r\n\t\tfree (jh.row);\r\n\t}\r\n}\r\n\r\nvoid DCR_CLASS dcr_adobe_dng_load_raw_nc(DCRAW* p)\r\n{\r\n\tushort *pixel, *rp;\r\n\tunsigned int row, col;\r\n\r\n\tpixel = (ushort *) calloc (p->raw_width * p->tiff_samples, sizeof *pixel);\r\n\tdcr_merror (p, pixel, \"adobe_dng_load_raw_nc()\");\r\n\tfor (row=0; row < p->raw_height; row++) {\r\n\t\tif (p->tiff_bps == 16)\r\n\t\t\tdcr_read_shorts (p, pixel, p->raw_width * p->tiff_samples);\r\n\t\telse {\r\n\t\t\tdcr_getbits(p, -1);\r\n\t\t\tfor (col=0; col < p->raw_width * p->tiff_samples; col++)\r\n\t\t\t\tpixel[col] = dcr_getbits(p, p->tiff_bps);\r\n\t\t}\r\n\t\tfor (rp=pixel, col=0; col < p->raw_width; col++)\r\n\t\t\tdcr_adobe_copy_pixel (p,row, col, &rp);\r\n\t}\r\n\tfree (pixel);\r\n}\r\n\r\nvoid DCR_CLASS dcr_pentax_tree(DCRAW* p)\r\n{\r\n  ushort bit[2][13];\r\n  struct dcr_decode *cur;\r\n  int c, i, j;\r\n\r\n  dcr_init_decoder(p);\r\n  FORC(13) bit[0][c] = dcr_get2(p);\r\n  FORC(13) bit[1][c] = dcr_fgetc(p->obj_) & 15;\r\n  FORC(13) {\r\n    cur = p->first_decode;\r\n    for (i=0; i < bit[1][c]; i++) {\r\n      j = bit[0][c] >> (11-i) & 1;\r\n      if (!cur->branch[j]) cur->branch[j] = ++p->free_decode;\r\n      cur = cur->branch[j];\r\n    }\r\n    cur->leaf = c;\r\n  }\r\n}\r\n\r\nvoid DCR_CLASS dcr_pentax_k10_load_raw(DCRAW* p)\r\n{\r\n\tint row, col, diff;\r\n\tushort vpred[2][2] = {{0,0},{0,0}}, hpred[2];\r\n\r\n\tdcr_getbits(p, -1);\r\n\tfor (row=0; row < p->height; row++)\r\n\t\tfor (col=0; col < p->raw_width; col++) {\r\n\t\t\tdiff = dcr_ljpeg_diff (p, p->first_decode);\r\n\t\t\tif (col < 2) hpred[col] = vpred[row & 1][col] += diff;\r\n\t\t\telse\t   hpred[col & 1] += diff;\r\n\t\t\tif (col < p->width)\r\n\t\t\t\tBAYER(row,col) = hpred[col & 1];\r\n\t\t\tif (hpred[col & 1] >> 12) dcr_derror(p);\r\n\t\t}\r\n}\r\n\r\nvoid DCR_CLASS dcr_nikon_compressed_load_raw(DCRAW* p)\r\n{\r\n\tstatic const uchar nikon_tree[][32] = {\r\n\t\t{ 0,1,5,1,1,1,1,1,1,2,0,0,0,0,0,0,\t/* 12-bit lossy */\r\n\t\t\t5,4,3,6,2,7,1,0,8,9,11,10,12 },\r\n\t\t{ 0,1,5,1,1,1,1,1,1,2,0,0,0,0,0,0,\t/* 12-bit lossy after split */\r\n\t\t0x39,0x5a,0x38,0x27,0x16,5,4,3,2,1,0,11,12,12 },\r\n\t\t{ 0,1,4,2,3,1,2,0,0,0,0,0,0,0,0,0,  /* 12-bit lossless */\r\n\t\t5,4,6,3,7,2,8,1,9,0,10,11,12 },\r\n\t\t{ 0,1,4,3,1,1,1,1,1,2,0,0,0,0,0,0,\t/* 14-bit lossy */\r\n\t\t5,6,4,7,8,3,9,2,1,0,10,11,12,13,14 },\r\n\t\t{ 0,1,5,1,1,1,1,1,1,1,2,0,0,0,0,0,\t/* 14-bit lossy after split */\r\n\t\t8,0x5c,0x4b,0x3a,0x29,7,6,5,4,3,2,1,0,13,14 },\r\n\t\t{ 0,1,4,2,2,3,1,2,0,0,0,0,0,0,0,0,\t/* 14-bit lossless */\r\n\t\t7,6,8,5,9,4,10,3,11,12,2,0,1,13,14 } };\r\n\tstruct dcr_decode *dindex;\r\n\tushort ver0, ver1, vpred[2][2], hpred[2], csize;\r\n\tint i, min, max, step=0, huff=0, split=0, row, col, len, shl, diff;\r\n\r\n\tdcr_fseek(p->obj_, p->meta_offset, SEEK_SET);\r\n\tver0 = dcr_fgetc(p->obj_);\r\n\tver1 = dcr_fgetc(p->obj_);\r\n\tif (ver0 == 0x49 || ver1 == 0x58)\r\n\t\tdcr_fseek(p->obj_, 2110, SEEK_CUR);\r\n\tif (ver0 == 0x46) huff = 2;\r\n\tif (p->tiff_bps == 14) huff += 3;\r\n\tdcr_read_shorts (p, vpred[0], 4);\r\n\tmax = 1 << p->tiff_bps & 0x7fff;\r\n\tif ((csize = dcr_get2(p)) > 1)\r\n\t\tstep = max / (csize-1);\r\n\tif (ver0 == 0x44 && ver1 == 0x20 && step > 0) {\r\n\t\tfor (i=0; i < csize; i++)\r\n\t\t\tp->curve[i*step] = dcr_get2(p);\r\n\t\tfor (i=0; i < max; i++)\r\n\t\t\tp->curve[i] = ( p->curve[i-i%step]*(step-i%step) +\r\n\t\t\tp->curve[i-i%step+step]*(i%step) ) / step;\r\n\t\tdcr_fseek(p->obj_, p->meta_offset+562, SEEK_SET);\r\n\t\tsplit = dcr_get2(p);\r\n\t} else if (ver0 != 0x46 && csize <= 0x4001)\r\n\t\tdcr_read_shorts (p, p->curve, max=csize);\r\n\twhile (p->curve[max-2] == p->curve[max-1]) max--;\r\n\tdcr_init_decoder(p);\r\n\tdcr_make_decoder (p, nikon_tree[huff], 0);\r\n\tdcr_fseek(p->obj_, p->data_offset, SEEK_SET);\r\n\tdcr_getbits(p, -1);\r\n\tfor (min=row=0; row < p->height; row++) {\r\n\t\tif (split && row == split) {\r\n\t\t\tdcr_init_decoder(p);\r\n\t\t\tdcr_make_decoder (p, nikon_tree[huff+1], 0);\r\n\t\t\tmax += (min = 16) << 1;\r\n\t\t}\r\n\t\tfor (col=0; col < p->raw_width; col++) {\r\n\t\t\tfor (dindex=p->first_decode; dindex->branch[0]; )\r\n\t\t\t\tdindex = dindex->branch[dcr_getbits(p, 1)];\r\n\t\t\tlen = dindex->leaf & 15;\r\n\t\t\tshl = dindex->leaf >> 4;\r\n\t\t\tdiff = ((dcr_getbits(p, len-shl) << 1) + 1) << shl >> 1;\r\n\t\t\tif ((diff & (1 << (len-1))) == 0)\r\n\t\t\t\tdiff -= (1 << len) - !shl;\r\n\t\t\tif (col < 2) hpred[col] = vpred[row & 1][col] += diff;\r\n\t\t\telse\t   hpred[col & 1] += diff;\r\n\t\t\tif ((ushort)(hpred[col & 1] + min) >= max) dcr_derror(p);\r\n\t\t\tif ((unsigned) (col-p->left_margin) < p->width)\r\n\t\t\t\tBAYER(row,col-p->left_margin) = p->curve[LIM((short)hpred[col & 1],0,0x3fff)];\r\n\t\t}\r\n\t}\r\n}\r\n\r\n/*\r\nFigure out if a NEF file is compressed.  These fancy heuristics\r\nare only needed for the D100, thanks to a bug in some cameras\r\nthat tags all images as \"compressed\".\r\n*/\r\nint DCR_CLASS dcr_nikon_is_compressed(DCRAW* p)\r\n{\r\n\tuchar test[256];\r\n\tint i;\r\n\r\n\tdcr_fseek(p->obj_, p->data_offset, SEEK_SET);\r\n\tdcr_fread(p->obj_, test, 1, 256);\r\n\tfor (i=15; i < 256; i+=16)\r\n\t\tif (test[i]) return 1;\r\n\t\treturn 0;\r\n}\r\n\r\n/*\r\nReturns 1 for a Coolpix 995, 0 for anything else.\r\n*/\r\nint DCR_CLASS dcr_nikon_e995(DCRAW* p)\r\n{\r\n\tint i, histo[256];\r\n\tconst uchar often[] = { 0x00, 0x55, 0xaa, 0xff };\r\n\r\n\tmemset (histo, 0, sizeof histo);\r\n\tdcr_fseek(p->obj_, -2000, SEEK_END);\r\n\tfor (i=0; i < 2000; i++)\r\n\t\thisto[dcr_fgetc(p->obj_)]++;\r\n\tfor (i=0; i < 4; i++)\r\n\t\tif (histo[often[i]] < 200)\r\n\t\t\treturn 0;\r\n\t\treturn 1;\r\n}\r\n\r\n/*\r\nReturns 1 for a Coolpix 2100, 0 for anything else.\r\n*/\r\nint DCR_CLASS dcr_nikon_e2100(DCRAW* p)\r\n{\r\n\tuchar t[12];\r\n\tint i;\r\n\r\n\tdcr_fseek(p->obj_, 0, SEEK_SET);\r\n\tfor (i=0; i < 1024; i++) {\r\n\t\tdcr_fread(p->obj_, t, 1, 12);\r\n\t\tif (((t[2] & t[4] & t[7] & t[9]) >> 4\r\n\t\t\t& t[1] & t[6] & t[8] & t[11] & 3) != 3)\r\n\t\t\treturn 0;\r\n\t}\r\n\treturn 1;\r\n}\r\n\r\nvoid DCR_CLASS dcr_nikon_3700(DCRAW* p)\r\n{\r\n\tint bits, i;\r\n\tuchar dp[24];\r\n\tconst struct {\r\n\t\tint bits;\r\n\t\tchar make[12], model[15];\r\n\t} table[] = {\r\n\t\t{ 0x00, \"PENTAX\",  \"Optio 33WR\" },\r\n\t\t{ 0x03, \"NIKON\",   \"E3200\" },\r\n\t\t{ 0x32, \"NIKON\",   \"E3700\" },\r\n\t\t{ 0x33, \"OLYMPUS\", \"C740UZ\" } };\r\n\r\n\tdcr_fseek(p->obj_, 3072, SEEK_SET);\r\n\tdcr_fread(p->obj_, dp, 1, 24);\r\n\tbits = (dp[8] & 3) << 4 | (dp[20] & 3);\r\n\tfor (i=0; i < sizeof table / sizeof *table; i++)\r\n\t\tif (bits == table[i].bits) {\r\n\t\t\tstrcpy (p->make,  table[i].make );\r\n\t\t\tstrcpy (p->model, table[i].model);\r\n\t\t}\r\n}\r\n\r\n/*\r\nSeparates a Minolta DiMAGE Z2 from a Nikon E4300.\r\n*/\r\nint DCR_CLASS dcr_minolta_z2(DCRAW* p)\r\n{\r\n\tint i, nz;\r\n\tchar tail[424];\r\n\r\n\tdcr_fseek(p->obj_, -(long)(sizeof tail), SEEK_END);\r\n\tdcr_fread(p->obj_, tail, 1, sizeof tail);\r\n\tfor (nz=i=0; i < sizeof tail; i++)\r\n\t\tif (tail[i]) nz++;\r\n\treturn nz > 20;\r\n}\r\n\r\n/* Here p->raw_width is in bytes, not pixels. */\r\nvoid DCR_CLASS dcr_nikon_e900_load_raw(DCRAW* p)\r\n{\r\n\tint offset=0, irow, row, col;\r\n\r\n\tfor (irow=0; irow < p->height; irow++) {\r\n\t\trow = irow * 2 % p->height;\r\n\t\tif (row == 1)\r\n\t\t\toffset = - (-offset & -4096);\r\n\t\tdcr_fseek(p->obj_, offset, SEEK_SET);\r\n\t\toffset += p->raw_width;\r\n\t\tdcr_getbits(p, -1);\r\n\t\tfor (col=0; col < p->width; col++)\r\n\t\t\tBAYER(row,col) = dcr_getbits(p, 10);\r\n\t}\r\n}\r\n\r\n/*\r\nThe Fuji Super CCD is just a Bayer grid rotated 45 degrees.\r\n*/\r\nvoid DCR_CLASS dcr_fuji_load_raw(DCRAW* p)\r\n{\r\n\tushort *pixel;\r\n\tint wide, row, col, r, c;\r\n\r\n\tdcr_fseek(p->obj_, (p->top_margin*p->raw_width + p->left_margin) * 2, SEEK_CUR);\r\n\twide = p->fuji_width << !p->fuji_layout;\r\n\tpixel = (ushort *) calloc (wide, sizeof *pixel);\r\n\tdcr_merror (p, pixel, \"fuji_load_raw()\");\r\n\tfor (row=0; row < p->raw_height; row++) {\r\n\t\tdcr_read_shorts (p, pixel, wide);\r\n\t\tdcr_fseek(p->obj_, 2*(p->raw_width - wide), SEEK_CUR);\r\n\t\tfor (col=0; col < wide; col++) {\r\n\t\t\tif (p->fuji_layout) {\r\n\t\t\t\tr = p->fuji_width - 1 - col + (row >> 1);\r\n\t\t\t\tc = col + ((row+1) >> 1);\r\n\t\t\t} else {\r\n\t\t\t\tr = p->fuji_width - 1 + row - (col >> 1);\r\n\t\t\t\tc = row + ((col+1) >> 1);\r\n\t\t\t}\r\n\t\t\tBAYER(r,c) = pixel[col];\r\n\t\t}\r\n\t}\r\n\tfree (pixel);\r\n}\r\n\r\nvoid DCR_CLASS dcr_jpeg_thumb (DCRAW* p, FILE *tfp);\r\n\r\nvoid DCR_CLASS dcr_ppm_thumb (DCRAW* p, FILE *tfp)\r\n{\r\n\tchar *thumb;\r\n\tp->thumb_length = p->thumb_width*p->thumb_height*3;\r\n\tthumb = (char *) malloc (p->thumb_length);\r\n\tdcr_merror (p, thumb, \"ppm_thumb()\");\r\n\tfprintf (tfp, \"P6\\n%d %d\\n255\\n\", p->thumb_width, p->thumb_height);\r\n\tdcr_fread(p->obj_, thumb, 1, p->thumb_length);\r\n\tfwrite (thumb, 1, p->thumb_length, tfp);\r\n\tfree (thumb);\r\n}\r\n\r\nvoid DCR_CLASS dcr_layer_thumb (DCRAW* p, FILE *tfp)\r\n{\r\n\tint i, c;\r\n\tchar *thumb, map[][4] = { \"012\",\"102\" };\r\n\r\n\tp->colors = p->thumb_misc >> 5 & 7;\r\n\tp->thumb_length = p->thumb_width*p->thumb_height;\r\n\tthumb = (char *) calloc (p->colors, p->thumb_length);\r\n\tdcr_merror (p, thumb, \"layer_thumb()\");\r\n\tfprintf (tfp, \"P%d\\n%d %d\\n255\\n\",\r\n\t\t5 + (p->colors >> 1), p->thumb_width, p->thumb_height);\r\n\tdcr_fread(p->obj_, thumb, p->thumb_length, p->colors);\r\n\tfor (i=0; i < (int)p->thumb_length; i++)\r\n\t\tFORCC(p) putc (thumb[i+p->thumb_length*(map[p->thumb_misc >> 8][c]-'0')], tfp);\r\n\tfree (thumb);\r\n}\r\n\r\nvoid DCR_CLASS dcr_rollei_thumb (DCRAW* p, FILE *tfp)\r\n{\r\n\tunsigned i;\r\n\tushort *thumb;\r\n\r\n\tp->thumb_length = p->thumb_width * p->thumb_height;\r\n\tthumb = (ushort *) calloc (p->thumb_length, 2);\r\n\tdcr_merror (p, thumb, \"rollei_thumb()\");\r\n\tfprintf (tfp, \"P6\\n%d %d\\n255\\n\", p->thumb_width, p->thumb_height);\r\n\tdcr_read_shorts (p, thumb, p->thumb_length);\r\n\tfor (i=0; i < p->thumb_length; i++) {\r\n\t\tputc (thumb[i] << 3, tfp);\r\n\t\tputc (thumb[i] >> 5  << 2, tfp);\r\n\t\tputc (thumb[i] >> 11 << 3, tfp);\r\n\t}\r\n\tfree (thumb);\r\n}\r\n\r\nvoid DCR_CLASS dcr_rollei_load_raw(DCRAW* p)\r\n{\r\n\tuchar pixel[10];\r\n\tunsigned iten=0, isix, i, buffer=0, row, col, todo[16];\r\n\r\n\tisix = p->raw_width * p->raw_height * 5 / 8;\r\n\twhile (dcr_fread(p->obj_, pixel, 1, 10) == 10) {\r\n\t\tfor (i=0; i < 10; i+=2) {\r\n\t\t\ttodo[i]   = iten++;\r\n\t\t\ttodo[i+1] = pixel[i] << 8 | pixel[i+1];\r\n\t\t\tbuffer    = pixel[i] >> 2 | buffer << 6;\r\n\t\t}\r\n\t\tfor (   ; i < 16; i+=2) {\r\n\t\t\ttodo[i]   = isix++;\r\n\t\t\ttodo[i+1] = buffer >> (14-i)*5;\r\n\t\t}\r\n\t\tfor (i=0; i < 16; i+=2) {\r\n\t\t\trow = todo[i] / p->raw_width - p->top_margin;\r\n\t\t\tcol = todo[i] % p->raw_width - p->left_margin;\r\n\t\t\tif (row < p->height && col < p->width)\r\n\t\t\t\tBAYER(row,col) = (todo[i+1] & 0x3ff);\r\n\t\t}\r\n\t}\r\n\tp->maximum = 0x3ff;\r\n}\r\n\r\nint DCR_CLASS dcr_bayer (DCRAW* p, unsigned row, unsigned col)\r\n{\r\n\treturn (row < p->height && col < p->width) ? BAYER(row,col) : 0;\r\n}\r\n\r\nvoid DCR_CLASS dcr_phase_one_flat_field (DCRAW* p, int is_float, int nc)\r\n{\r\n\tushort head[8];\r\n\tunsigned wide, y, x, rend, cend, row, col;\r\n\tint c;\r\n\tfloat *mrow, num, mult[4];\r\n\r\n\tdcr_read_shorts (p, head, 8);\r\n\twide = head[2] / head[4];\r\n\tmrow = (float *) calloc (nc*wide, sizeof *mrow);\r\n\tdcr_merror (p, mrow, \"phase_one_flat_field()\");\r\n\tfor (y=0; y < (unsigned int)(head[3] / head[5]); y++) {\r\n\t\tfor (x=0; x < wide; x++)\r\n\t\t\tfor (c=0; c < nc; c+=2) {\r\n\t\t\t\tnum = is_float ? (float)dcr_getreal(p, 11) : dcr_get2(p)/32768.0f;\r\n\t\t\t\tif (y==0) mrow[c*wide+x] = num;\r\n\t\t\t\telse mrow[(c+1)*wide+x] = (num - mrow[c*wide+x]) / head[5];\r\n\t\t\t}\r\n\t\tif (y==0) continue;\r\n\t\trend = head[1]-p->top_margin + y*head[5];\r\n\t\tfor (row = rend-head[5]; row < p->height && row < rend; row++) {\r\n\t\t\tfor (x=1; x < wide; x++) {\r\n\t\t\t\tfor (c=0; c < nc; c+=2) {\r\n\t\t\t\t\tmult[c] = mrow[c*wide+x-1];\r\n\t\t\t\t\tmult[c+1] = (mrow[c*wide+x] - mult[c]) / head[4];\r\n\t\t\t\t}\r\n\t\t\t\tcend = head[0]-p->left_margin + x*head[4];\r\n\t\t\t\tfor (col = cend-head[4]; col < p->width && col < cend; col++) {\r\n\t\t\t\t\tc = nc > 2 ? FC(row,col) : 0;\r\n\t\t\t\t\tif (!(c & 1)) {\r\n\t\t\t\t\t\tc = (int)(BAYER(row,col) * mult[c]);\r\n\t\t\t\t\t\tBAYER(row,col) = LIM(c,0,65535);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tfor (c=0; c < nc; c+=2)\r\n\t\t\t\t\t\tmult[c] += mult[c+1];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tfor (x=0; x < wide; x++)\r\n\t\t\t\tfor (c=0; c < nc; c+=2)\r\n\t\t\t\t\tmrow[c*wide+x] += mrow[(c+1)*wide+x];\r\n\t\t}\r\n\t}\r\n\tfree (mrow);\r\n}\r\n\r\nvoid DCR_CLASS dcr_phase_one_correct(DCRAW* p)\r\n{\r\n\tunsigned entries, tag, data, save, col, row, type;\r\n\tint len, i, j, k, cip, val[4], dev[4], sum, max;\r\n\tint head[9], diff, mindiff=INT_MAX, off_412=0;\r\n\tstatic const signed char dir[12][2] =\r\n\t{ {-1,-1}, {-1,1}, {1,-1}, {1,1}, {-2,0}, {0,-2}, {0,2}, {2,0},\r\n\t{-2,-2}, {-2,2}, {2,-2}, {2,2} };\r\n\tfloat poly[8], num, cfrac, frac, mult[2], *yval[2];\r\n\tushort curve[0x10000], *xval[2];\r\n\r\n\tif (p->opt.half_size || !p->meta_length) return;\r\n\tif (p->opt.verbose) fprintf (stderr,_(\"Phase One correction...\\n\"));\r\n\tdcr_fseek(p->obj_, p->meta_offset, SEEK_SET);\r\n\tp->order = dcr_get2(p);\r\n\tdcr_fseek(p->obj_, 6, SEEK_CUR);\r\n\tdcr_fseek(p->obj_, p->meta_offset+dcr_get4(p), SEEK_SET);\r\n\tentries = dcr_get4(p);  dcr_get4(p);\r\n\twhile (entries--) {\r\n\t\ttag  = dcr_get4(p);\r\n\t\tlen  = dcr_get4(p);\r\n\t\tdata = dcr_get4(p);\r\n\t\tsave = dcr_ftell(p->obj_);\r\n\t\tdcr_fseek(p->obj_, p->meta_offset+data, SEEK_SET);\r\n\t\tif (tag == 0x419) {\t\t\t\t/* Polynomial curve */\r\n\t\t\tfor (dcr_get4(p), i=0; i < 8; i++)\r\n\t\t\t\tpoly[i] = (float)dcr_getreal(p, 11);\r\n\t\t\tpoly[3] += (p->ph1.tag_210 - poly[7]) * poly[6] + 1;\r\n\t\t\tfor (i=0; i < 0x10000; i++) {\r\n\t\t\t\tnum = (poly[5]*i + poly[3])*i + poly[1];\r\n\t\t\t\tcurve[i] = (unsigned short)LIM(num,0,65535);\r\n\t\t\t} goto apply;\t\t\t\t/* apply to right half */\r\n\t\t} else if (tag == 0x41a) {\t\t\t/* Polynomial curve */\r\n\t\t\tfor (i=0; i < 4; i++)\r\n\t\t\t\tpoly[i] = (float)dcr_getreal(p, 11);\r\n\t\t\tfor (i=0; i < 0x10000; i++) {\r\n\t\t\t\tfor (num=0, j=4; j--; )\r\n\t\t\t\t\tnum = num * i + poly[j];\r\n\t\t\t\tcurve[i] = (unsigned short)LIM(num+i,0,65535);\r\n\t\t\t} apply:\t\t\t\t\t/* apply to whole image */\r\n\t\t\tfor (row=0; row < p->height; row++)\r\n\t\t\t\tfor (col = (tag & 1)*p->ph1.split_col; col < p->width; col++)\r\n\t\t\t\t\tBAYER(row,col) = curve[BAYER(row,col)];\r\n\t\t} else if (tag == 0x400) {\t\t\t/* Sensor defects */\r\n\t\t\twhile ((len -= 8) >= 0) {\r\n\t\t\t\tcol  = dcr_get2(p) - p->left_margin;\r\n\t\t\t\trow  = dcr_get2(p) - p->top_margin;\r\n\t\t\t\ttype = dcr_get2(p); dcr_get2(p);\r\n\t\t\t\tif (col >= p->width) continue;\r\n\t\t\t\tif (type == 131)\t\t\t/* Bad column */\r\n\t\t\t\t\tfor (row=0; row < p->height; row++)\r\n\t\t\t\t\t\tif (FC(row,col) == 1) {\r\n\t\t\t\t\t\t\tfor (sum=i=0; i < 4; i++)\r\n\t\t\t\t\t\t\t\tsum += val[i] = dcr_bayer (p, row+dir[i][0], col+dir[i][1]);\r\n\t\t\t\t\t\t\tfor (max=i=0; i < 4; i++) {\r\n\t\t\t\t\t\t\t\tdev[i] = abs((val[i] << 2) - sum);\r\n\t\t\t\t\t\t\t\tif (dev[max] < dev[i]) max = i;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tBAYER(row,col) = (unsigned short)((sum - val[max])/3.0 + 0.5);\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tfor (sum=0, i=8; i < 12; i++)\r\n\t\t\t\t\t\t\t\tsum += dcr_bayer (p, row+dir[i][0], col+dir[i][1]);\r\n\t\t\t\t\t\t\tBAYER(row,col) = (unsigned short)(0.5 + sum * 0.0732233 +\r\n\t\t\t\t\t\t\t\t(dcr_bayer(p, row,col-2) + dcr_bayer(p, row,col+2)) * 0.3535534);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse if (type == 129) {\t\t\t/* Bad pixel */\r\n\t\t\t\t\t\t\tif (row >= p->height) continue;\r\n\t\t\t\t\t\t\tj = (FC(row,col) != 1) * 4;\r\n\t\t\t\t\t\t\tfor (sum=0, i=j; i < j+8; i++)\r\n\t\t\t\t\t\t\t\tsum += dcr_bayer (p, row+dir[i][0], col+dir[i][1]);\r\n\t\t\t\t\t\t\tBAYER(row,col) = (sum + 4) >> 3;\r\n\t\t\t\t\t\t}\r\n\t\t\t}\r\n\t\t} else if (tag == 0x401) {\t\t\t/* All-color flat fields */\r\n\t\t\tdcr_phase_one_flat_field (p, 1, 2);\r\n\t\t} else if (tag == 0x416 || tag == 0x410) {\r\n\t\t\tdcr_phase_one_flat_field (p, 0, 2);\r\n\t\t} else if (tag == 0x40b) {\t\t\t/* Red+blue flat field */\r\n\t\t\tdcr_phase_one_flat_field (p, 0, 4);\r\n\t\t} else if (tag == 0x412) {\r\n\t\t\tdcr_fseek(p->obj_, 36, SEEK_CUR);\r\n\t\t\tdiff = abs (dcr_get2(p) - p->ph1.tag_21a);\r\n\t\t\tif (mindiff > diff) {\r\n\t\t\t\tmindiff = diff;\r\n\t\t\t\toff_412 = dcr_ftell(p->obj_) - 38;\r\n\t\t\t}\r\n\t\t}\r\n\t\tdcr_fseek(p->obj_, save, SEEK_SET);\r\n\t}\r\n\tif (off_412) {\r\n\t\tdcr_fseek(p->obj_, off_412, SEEK_SET);\r\n\t\tfor (i=0; i < 9; i++) head[i] = dcr_get4(p) & 0x7fff;\r\n\t\tyval[0] = (float *) calloc (head[1]*head[3] + head[2]*head[4], 6);\r\n\t\tdcr_merror (p, yval[0], \"phase_one_correct()\");\r\n\t\tyval[1] = (float  *) (yval[0] + head[1]*head[3]);\r\n\t\txval[0] = (ushort *) (yval[1] + head[2]*head[4]);\r\n\t\txval[1] = (ushort *) (xval[0] + head[1]*head[3]);\r\n\t\tdcr_get2(p);\r\n\t\tfor (i=0; i < 2; i++)\r\n\t\t\tfor (j=0; j < head[i+1]*head[i+3]; j++)\r\n\t\t\t\tyval[i][j] = (float)dcr_getreal(p, 11);\r\n\t\tfor (i=0; i < 2; i++)\r\n\t\t\tfor (j=0; j < head[i+1]*head[i+3]; j++)\r\n\t\t\t\txval[i][j] = dcr_get2(p);\r\n\t\tfor (row=0; row < p->height; row++)\r\n\t\t\tfor (col=0; col < p->width; col++) {\r\n\t\t\t\tcfrac = (float) col * head[3] / p->raw_width;\r\n\t\t\t\tcfrac -= cip = (int)cfrac;\r\n\t\t\t\tnum = (float)(BAYER(row,col) * 0.5);\r\n\t\t\t\tfor (i=cip; i < cip+2; i++) {\r\n\t\t\t\t\tfor (k=j=0; j < head[1]; j++)\r\n\t\t\t\t\t\tif (num < xval[0][k = head[1]*i+j]) break;\r\n\t\t\t\t\t\tfrac = (j == 0 || j == head[1]) ? 0 :\r\n\t\t\t\t\t\t(xval[0][k] - num) / (xval[0][k] - xval[0][k-1]);\r\n\t\t\t\t\t\tmult[i-cip] = yval[0][k-1] * frac + yval[0][k] * (1-frac);\r\n\t\t\t\t}\r\n\t\t\t\ti = (int)(((mult[0] * (1-cfrac) + mult[1] * cfrac)\r\n\t\t\t\t\t* (row + p->top_margin) + num) * 2);\r\n\t\t\t\tBAYER(row,col) = LIM(i,0,65535);\r\n\t\t\t}\r\n\t\tfree (yval[0]);\r\n\t}\r\n}\r\n\r\nvoid DCR_CLASS dcr_phase_one_load_raw(DCRAW* p)\r\n{\r\n\tint row, col, a, b;\r\n\tushort *pixel, akey, bkey, mask;\r\n\r\n\tdcr_fseek(p->obj_, p->ph1.key_off, SEEK_SET);\r\n\takey = dcr_get2(p);\r\n\tbkey = dcr_get2(p);\r\n\tmask = p->ph1.format == 1 ? 0x5555:0x1354;\r\n\tdcr_fseek(p->obj_, p->data_offset + p->top_margin*p->raw_width*2, SEEK_SET);\r\n\tpixel = (ushort *) calloc (p->raw_width, sizeof *pixel);\r\n\tdcr_merror (p, pixel, \"phase_one_load_raw()\");\r\n\tfor (row=0; row < p->height; row++) {\r\n\t\tdcr_read_shorts (p, pixel, p->raw_width);\r\n\t\tfor (col=0; col < p->raw_width; col+=2) {\r\n\t\t\ta = pixel[col+0] ^ akey;\r\n\t\t\tb = pixel[col+1] ^ bkey;\r\n\t\t\tpixel[col+0] = (a & mask) | (b & ~mask);\r\n\t\t\tpixel[col+1] = (b & mask) | (a & ~mask);\r\n\t\t}\r\n\t\tfor (col=0; col < p->width; col++)\r\n\t\t\tBAYER(row,col) = pixel[col+p->left_margin];\r\n\t}\r\n\tfree (pixel);\r\n\tdcr_phase_one_correct(p);\r\n}\r\n\r\nunsigned DCR_CLASS dcr_ph1_bits (DCRAW* p,int nbits)\r\n{\r\n\tstatic UINT64 bitbuf=0;\r\n\tstatic int vbits=0;\r\n\r\n\tif (nbits == -1)\r\n\t\treturn (unsigned int)(bitbuf = vbits = 0);\r\n\tif (nbits == 0) return 0;\r\n\tif ((vbits -= nbits) < 0) {\r\n\t\tbitbuf = bitbuf << 32 | dcr_get4(p);\r\n\t\tvbits += 32;\r\n\t}\r\n\treturn (unsigned int)(bitbuf << (64-nbits-vbits) >> (64-nbits));\r\n}\r\n\r\nvoid DCR_CLASS dcr_phase_one_load_raw_c(DCRAW* p)\r\n{\r\n\tstatic const int length[] = { 8,7,6,9,11,10,5,12,14,13 };\r\n\tint *offset, len[2], pred[2], row, col, i, j;\r\n\tushort *pixel;\r\n\tshort (*black)[2];\r\n\r\n\tpixel = (ushort *) calloc (p->raw_width + p->raw_height*4, 2);\r\n\tdcr_merror (p, pixel, \"phase_one_load_raw_c()\");\r\n\toffset = (int *) (pixel + p->raw_width);\r\n\tdcr_fseek(p->obj_, p->strip_offset, SEEK_SET);\r\n\tfor (row=0; row < p->raw_height; row++)\r\n\t\toffset[row] = dcr_get4(p);\r\n\tblack = (short (*)[2]) offset + p->raw_height;\r\n\tdcr_fseek(p->obj_, p->ph1.black_off, SEEK_SET);\r\n\tif (p->ph1.black_off)\r\n\t\tdcr_read_shorts (p, (ushort *) black[0], p->raw_height*2);\r\n\tfor (i=0; i < 256; i++)\r\n\t\tp->curve[i] = (unsigned short)(i*i / 3.969 + 0.5);\r\n\tfor (row=0; row < p->raw_height; row++) {\r\n\t\tdcr_fseek(p->obj_, p->data_offset + offset[row], SEEK_SET);\r\n\t\tdcr_ph1_bits(p,-1);\r\n\t\tpred[0] = pred[1] = 0;\r\n\t\tfor (col=0; col < p->raw_width; col++) {\r\n\t\t\tif (col >= (p->raw_width & -8))\r\n\t\t\t\tlen[0] = len[1] = 14;\r\n\t\t\telse if ((col & 7) == 0)\r\n\t\t\t\tfor (i=0; i < 2; i++) {\r\n\t\t\t\t\tfor (j=0; j < 5 && !dcr_ph1_bits(p,1); j++);\r\n\t\t\t\t\tif (j--) len[i] = length[j*2 + dcr_ph1_bits(p,1)];\r\n\t\t\t\t}\r\n\t\t\t\tif ((i = len[col & 1]) == 14)\r\n\t\t\t\t\tpixel[col] = pred[col & 1] = dcr_ph1_bits(p,16);\r\n\t\t\t\telse\r\n\t\t\t\t\tpixel[col] = pred[col & 1] += dcr_ph1_bits(p,i) + 1 - (1 << (i - 1));\r\n\t\t\t\tif (pred[col & 1] >> 16) dcr_derror(p);\r\n\t\t\t\tif (p->ph1.format == 5 && pixel[col] < 256)\r\n\t\t\t\t\tpixel[col] = p->curve[pixel[col]];\r\n\t\t}\r\n\t\tif ((unsigned) (row-p->top_margin) < p->height)\r\n\t\t\tfor (col=0; col < p->width; col++) {\r\n\t\t\t\ti = (pixel[col+p->left_margin] << 2)\r\n\t\t\t\t\t- p->ph1.black + black[row][col >= p->ph1.split_col];\r\n\t\t\t\tif (i > 0) BAYER(row-p->top_margin,col) = i;\r\n\t\t\t}\r\n\t}\r\n\tfree (pixel);\r\n\tdcr_phase_one_correct(p);\r\n\tp->maximum = 0xfffc - p->ph1.black;\r\n}\r\n\r\nvoid DCR_CLASS dcr_hasselblad_load_raw(DCRAW* p)\r\n{\r\n\tstruct dcr_jhead jh;\r\n\tstruct dcr_decode *dindex;\r\n\tint row, col, pred[2], len[2], diff, i;\r\n\r\n\tif (!dcr_ljpeg_start (p,&jh, 0)) return;\r\n\tfree (jh.row);\r\n\tp->order = 0x4949;\r\n\tdcr_ph1_bits(p,-1);\r\n\tfor (row=-p->top_margin; row < p->height; row++) {\r\n\t\tpred[0] = pred[1] = 0x8000;\r\n\t\tfor (col=-p->left_margin; col < p->raw_width-p->left_margin; col+=2) {\r\n\t\t\tfor (i=0; i < 2; i++) {\r\n\t\t\t\tfor (dindex=jh.huff[0]; dindex->branch[0]; )\r\n\t\t\t\t\tdindex = dindex->branch[dcr_ph1_bits(p,1)];\r\n\t\t\t\tlen[i] = dindex->leaf;\r\n\t\t\t}\r\n\t\t\tfor (i=0; i < 2; i++) {\r\n\t\t\t\tdiff = dcr_ph1_bits(p,len[i]);\r\n\t\t\t\tif ((diff & (1 << (len[i]-1))) == 0)\r\n\t\t\t\t\tdiff -= (1 << len[i]) - 1;\r\n\t\t\t\tif (diff == 65535) diff = -32768;\r\n\t\t\t\tpred[i] += diff;\r\n\t\t\t\tif (row >= 0 && (unsigned)(col+i) < p->width)\r\n\t\t\t\t\tBAYER(row,col+i) = pred[i];\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tp->maximum = 0xffff;\r\n}\r\n\r\nvoid DCR_CLASS dcr_leaf_hdr_load_raw(DCRAW* p)\r\n{\r\n\tushort *pixel;\r\n\tunsigned tile=0, r, c, row, col;\r\n\r\n\tpixel = (ushort *) calloc (p->raw_width, sizeof *pixel);\r\n\tdcr_merror (p, pixel, \"leaf_hdr_load_raw()\");\r\n\tFORC(p->tiff_samples) {\r\n\t\tfor (r=0; r < p->raw_height; r++) {\r\n\t\t\tif (r % p->tile_length == 0) {\r\n\t\t\t\tdcr_fseek(p->obj_, p->data_offset + 4*tile++, SEEK_SET);\r\n\t\t\t\tdcr_fseek(p->obj_, dcr_get4(p) + 2*p->left_margin, SEEK_SET);\r\n\t\t\t}\r\n\t\t\tif (p->filters && c != p->opt.shot_select) continue;\r\n\t\t\tdcr_read_shorts (p, pixel, p->raw_width);\r\n\t\t\tif ((row = r - p->top_margin) >= p->height) continue;\r\n\t\t\tfor (col=0; col < p->width; col++)\r\n\t\t\t\tif (p->filters)  BAYER(row,col) = pixel[col];\r\n\t\t\t\telse p->image[row*p->width+col][c] = pixel[col];\r\n\t\t}\r\n\t}\r\n\tfree (pixel);\r\n\tif (!p->filters) {\r\n\t\tp->maximum = 0xffff;\r\n\t\tp->raw_color = 1;\r\n\t}\r\n}\r\n\r\nvoid DCR_CLASS dcr_sinar_4shot_load_raw(DCRAW* p)\r\n{\r\n\tushort *pixel;\r\n\tunsigned shot, row, col, r, c;\r\n\r\n\tif ((shot = p->opt.shot_select) || p->opt.half_size) {\r\n\t\tif (shot) shot--;\r\n\t\tif (shot > 3) shot = 3;\r\n\t\tdcr_fseek(p->obj_, p->data_offset + shot*4, SEEK_SET);\r\n\t\tdcr_fseek(p->obj_, dcr_get4(p), SEEK_SET);\r\n\t\tdcr_unpacked_load_raw(p);\r\n\t\treturn;\r\n\t}\r\n\tfree (p->image);\r\n\tp->image = (ushort (*)[4])\r\n\t\tcalloc ((p->iheight=p->height)*(p->iwidth=p->width), sizeof *p->image);\r\n\tdcr_merror (p, p->image, \"sinar_4shot_load_raw()\");\r\n\tpixel = (ushort *) calloc (p->raw_width, sizeof *pixel);\r\n\tdcr_merror (p, pixel, \"sinar_4shot_load_raw()\");\r\n\tfor (shot=0; shot < 4; shot++) {\r\n\t\tdcr_fseek(p->obj_, p->data_offset + shot*4, SEEK_SET);\r\n\t\tdcr_fseek(p->obj_, dcr_get4(p), SEEK_SET);\r\n\t\tfor (row=0; row < p->raw_height; row++) {\r\n\t\t\tdcr_read_shorts (p, pixel, p->raw_width);\r\n\t\t\tif ((r = row-p->top_margin - (shot >> 1 & 1)) >= p->height) continue;\r\n\t\t\tfor (col=0; col < p->raw_width; col++) {\r\n\t\t\t\tif ((c = col-p->left_margin - (shot & 1)) >= p->width) continue;\r\n\t\t\t\tp->image[r*p->width+c][FC(row,col)] = pixel[col];\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tfree (pixel);\r\n\tp->shrink = p->filters = 0;\r\n}\r\n\r\nvoid DCR_CLASS dcr_imacon_full_load_raw(DCRAW* p)\r\n{\r\n\tint row, col;\r\n\r\n\tfor (row=0; row < p->height; row++)\r\n\t\tfor (col=0; col < p->width; col++)\r\n\t\t\tdcr_read_shorts (p, p->image[row*p->width+col], 3);\r\n}\r\n\r\nvoid DCR_CLASS dcr_packed_12_load_raw(DCRAW* p)\r\n{\r\n\tint vbits=0, rbits=0, irow, row, col;\r\n\tUINT64 bitbuf=0;\r\n\r\n\tif (p->raw_width * 2 >= p->width * 3) {\t/* If raw_width is in bytes, */\r\n\t\trbits = p->raw_width * 8;\r\n\t\tp->raw_width = p->raw_width * 2 / 3;\t/* convert it to pixels and  */\r\n\t\trbits -= p->raw_width * 12;\t\t/* save the remainder.       */\r\n\t}\r\n\tp->order = p->load_flags & 1 ? 0x4949 : 0x4d4d;\r\n\tfor (irow=0; irow < p->height; irow++) {\r\n\t\trow = irow;\r\n\t\tif (p->load_flags & 2 &&\r\n\t\t\t(row = irow * 2 % p->height + irow / (p->height/2)) == 1 &&\r\n\t\t\tp->load_flags & 4) {\r\n\t\t\tif (vbits=0, p->tiff_compress)\r\n\t\t\t\tdcr_fseek(p->obj_, p->data_offset - (-p->width*p->height*3/4 & -2048), SEEK_SET);\r\n\t\t\telse {\r\n\t\t\t\tdcr_fseek(p->obj_, 0, SEEK_END);\r\n\t\t\t\tdcr_fseek(p->obj_, dcr_ftell(p->obj_)/2, SEEK_SET);\r\n\t\t\t}\r\n\t\t}\r\n\t\tfor (col=0; col < p->raw_width; col++) {\r\n\t\t\tif ((vbits -= 12) < 0) {\r\n\t\t\t\tbitbuf = bitbuf << 32 | dcr_get4(p);\r\n\t\t\t\tvbits += 32;\r\n\t\t\t}\r\n\t\t\tif ((unsigned) (col-p->left_margin) < p->width)\r\n\t\t\t\tBAYER(row,col-p->left_margin) = (unsigned short)(bitbuf << (52-vbits) >> 52);\r\n\t\t\tif (p->load_flags & 8 && (col % 10) == 9)\r\n\t\t\t\tif (vbits=0, bitbuf & 255) dcr_derror(p);\r\n\t\t}\r\n\t\tvbits -= rbits;\r\n\t}\r\n\tif (!strcmp(p->make,\"OLYMPUS\")) p->black >>= 4;\r\n}\r\n\r\nvoid DCR_CLASS dcr_unpacked_load_raw(DCRAW* p)\r\n{\r\n\tushort *pixel;\r\n\tint row, col, bits=0;\r\n\r\n\twhile (1 << ++bits < (int)p->maximum);\r\n\tdcr_fseek(p->obj_, (p->top_margin*p->raw_width + p->left_margin) * 2, SEEK_CUR);\r\n\tpixel = (ushort *) calloc (p->width, sizeof *pixel);\r\n\tdcr_merror (p, pixel, \"unpacked_load_raw()\");\r\n\tfor (row=0; row < p->height; row++) {\r\n\t\tdcr_read_shorts (p, pixel, p->width);\r\n\t\tdcr_fseek(p->obj_, 2*(p->raw_width - p->width), SEEK_CUR);\r\n\t\tfor (col=0; col < p->width; col++)\r\n\t\t\tif ((BAYER2(row,col) = pixel[col]) >> bits) dcr_derror(p);\r\n\t}\r\n\tfree (pixel);\r\n}\r\n\r\nvoid DCR_CLASS nokia_load_raw(DCRAW* p)\r\n{\r\n  uchar  *data,  *dp;\r\n  ushort *pixel, *pix;\r\n  int dwide, row, c;\r\n\r\n  dwide = p->raw_width * 5 / 4;\r\n  data = (uchar *) malloc (dwide + p->raw_width*2);\r\n  dcr_merror (p,data, \"nokia_load_raw()\");\r\n  pixel = (ushort *) (data + dwide);\r\n  for (row=0; row < p->raw_height; row++) {\r\n    if (dcr_fread(p->obj_, data, 1, dwide) < dwide) dcr_derror(p);\r\n    for (dp=data, pix=pixel; pix < pixel+p->raw_width; dp+=5, pix+=4)\r\n      FORC4 pix[c] = (dp[c] << 2) | (dp[4] >> (c << 1) & 3);\r\n    if (row < p->top_margin)\r\n      FORC(p->width) p->black += pixel[c];\r\n    else\r\n      FORC(p->width) BAYER(row-p->top_margin,c) = pixel[c];\r\n  }\r\n  free (data);\r\n  if (p->top_margin) p->black /= p->top_margin * p->width;\r\n  p->maximum = 0x3ff;\r\n}\r\n\r\nunsigned DCR_CLASS dcr_pana_bits (DCRAW* p,int nbits)\r\n{\r\n  static uchar buf[0x4000];\r\n  static int vbits;\r\n  int byte;\r\n\r\n  if (!nbits) return vbits=0;\r\n  if (!vbits) {\r\n    dcr_fread(p->obj_, buf+p->load_flags, 1, 0x4000-p->load_flags);\r\n    dcr_fread(p->obj_, buf, 1, p->load_flags);\r\n  }\r\n  vbits = (vbits - nbits) & 0x1ffff;\r\n  byte = vbits >> 3 ^ 0x3ff0;\r\n  return (buf[byte] | buf[byte+1] << 8) >> (vbits & 7) & ~(-1 << nbits);\r\n}\r\n\r\nvoid DCR_CLASS dcr_panasonic_load_raw(DCRAW* p)\r\n{\r\n  int row, col, i, j, sh=0, pred[2], nonz[2];\r\n\r\n  dcr_pana_bits(p,0);\r\n  for (row=0; row < p->height; row++)\r\n    for (col=0; col < p->raw_width; col++) {\r\n      if ((i = col % 14) == 0)\r\n\tpred[0] = pred[1] = nonz[0] = nonz[1] = 0;\r\n      if (i % 3 == 2) sh = 4 >> (3 - dcr_pana_bits(p,2));\r\n      if (nonz[i & 1]) {\r\n\tif ((j = dcr_pana_bits(p,8))) {\r\n\t  if ((pred[i & 1] -= 0x80 << sh) < 0 || sh == 4)\r\n\t       pred[i & 1] &= ~(-1 << sh);\r\n\t  pred[i & 1] += j << sh;\r\n\t}\r\n      } else if ((nonz[i & 1] = dcr_pana_bits(p,8)) || i > 11)\r\n\tpred[i & 1] = nonz[i & 1] << 4 | dcr_pana_bits(p,4);\r\n      if (col < p->width)\r\n\tif ((BAYER(row,col) = pred[col & 1]) > 4098) dcr_derror(p);\r\n    }\r\n}\r\n\r\nvoid DCR_CLASS dcr_olympus_e300_load_raw(DCRAW* p)\r\n{\r\n\tuchar  *data,  *dp;\r\n\tushort *pixel, *pix;\r\n\tint dwide, row, col;\r\n\r\n\tdwide = p->raw_width * 16 / 10;\r\n\tdcr_fseek(p->obj_, dwide*p->top_margin, SEEK_CUR);\r\n\tdata = (uchar *) malloc (dwide + p->raw_width*2);\r\n\tdcr_merror (p, data, \"olympus_e300_load_raw()\");\r\n\tpixel = (ushort *) (data + dwide);\r\n\tfor (row=0; row < p->height; row++) {\r\n\t\tif ((int)dcr_fread(p->obj_, data, 1, dwide) < dwide) dcr_derror(p);\r\n\t\tfor (dp=data, pix=pixel; pix < pixel+p->raw_width; dp+=3, pix+=2) {\r\n\t\t\tif (((dp-data) & 15) == 15)\r\n\t\t\t\tif (*dp++ && pix < pixel+p->width+p->left_margin) dcr_derror(p);\r\n\t\t\t\tpix[0] = dp[1] << 8 | dp[0];\r\n\t\t\t\tpix[1] = dp[2] << 4 | dp[1] >> 4;\r\n\t\t}\r\n\t\tfor (col=0; col < p->width; col++)\r\n\t\t\tBAYER(row,col) = (pixel[col+p->left_margin] & 0xfff);\r\n\t}\r\n\tfree (data);\r\n\tp->maximum >>= 4;\r\n\tp->black >>= 4;\r\n}\r\n\r\nvoid DCR_CLASS dcr_olympus_e410_load_raw(DCRAW* p)\r\n{\r\n\tint row, col, nbits, sign, low, high, i, w, n, nw;\r\n\tint acarry[2][3], *carry, pred, diff;\r\n\r\n\tdcr_fseek(p->obj_, 7, SEEK_CUR);\r\n\tdcr_getbits(p, -1);\r\n\tfor (row=0; row < p->height; row++) {\r\n\t\tmemset (acarry, 0, sizeof acarry);\r\n\t\tfor (col=0; col < p->width; col++) {\r\n\t\t\tcarry = acarry[col & 1];\r\n\t\t\ti = 2 * (carry[2] < 3);\r\n\t\t\tfor (nbits=2+i; (ushort) carry[0] >> (nbits+i); nbits++);\r\n\t\t\tsign = dcr_getbits(p, 1) * -1;\r\n\t\t\tlow  = dcr_getbits(p, 2);\r\n\t\t\tfor (high=0; high < 12; high++)\r\n\t\t\t\tif (dcr_getbits(p, 1)) break;\r\n\t\t\t\tif (high == 12)\r\n\t\t\t\t\thigh = dcr_getbits(p, 16-nbits) >> 1;\r\n\t\t\t\tcarry[0] = (high << nbits) | dcr_getbits(p, nbits);\r\n\t\t\t\tdiff = (carry[0] ^ sign) + carry[1];\r\n\t\t\t\tcarry[1] = (diff*3 + carry[1]) >> 5;\r\n\t\t\t\tcarry[2] = carry[0] > 16 ? 0 : carry[2]+1;\r\n\t\t\t\tif (row < 2 && col < 2) pred = 0;\r\n\t\t\t\telse if (row < 2) pred = BAYER(row,col-2);\r\n\t\t\t\telse if (col < 2) pred = BAYER(row-2,col);\r\n\t\t\t\telse {\r\n\t\t\t\t\tw  = BAYER(row,col-2);\r\n\t\t\t\t\tn  = BAYER(row-2,col);\r\n\t\t\t\t\tnw = BAYER(row-2,col-2);\r\n\t\t\t\t\tif ((w < nw && nw < n) || (n < nw && nw < w)) {\r\n\t\t\t\t\t\tif (ABS(w-nw) > 32 || ABS(n-nw) > 32)\r\n\t\t\t\t\t\t\tpred = w + n - nw;\r\n\t\t\t\t\t\telse pred = (w + n) >> 1;\r\n\t\t\t\t\t} else pred = ABS(w-nw) > ABS(n-nw) ? w : n;\r\n\t\t\t\t}\r\n\t\t\t\tif ((BAYER(row,col) = pred + ((diff << 2) | low)) >> 12) dcr_derror(p);\r\n\t\t}\r\n\t}\r\n}\r\n\r\nvoid DCR_CLASS dcr_minolta_rd175_load_raw(DCRAW* p)\r\n{\r\n\tuchar pixel[768];\r\n\tunsigned irow, box, row, col;\r\n\r\n\tfor (irow=0; irow < 1481; irow++) {\r\n\t\tif (dcr_fread(p->obj_, pixel, 1, 768) < 768) dcr_derror(p);\r\n\t\tbox = irow / 82;\r\n\t\trow = irow % 82 * 12 + ((box < 12) ? box | 1 : (box-12)*2);\r\n\t\tswitch (irow) {\r\n\t\tcase 1477: case 1479: continue;\r\n\t\tcase 1476: row = 984; break;\r\n\t\tcase 1480: row = 985; break;\r\n\t\tcase 1478: row = 985; box = 1;\r\n\t\t}\r\n\t\tif ((box < 12) && (box & 1)) {\r\n\t\t\tfor (col=0; col < 1533; col++, row ^= 1)\r\n\t\t\t\tif (col != 1) BAYER(row,col) = (col+1) & 2 ?\r\n\t\t\t\t\tpixel[col/2-1] + pixel[col/2+1] : pixel[col/2] << 1;\r\n\t\t\t\tBAYER(row,1)    = pixel[1]   << 1;\r\n\t\t\t\tBAYER(row,1533) = pixel[765] << 1;\r\n\t\t} else\r\n\t\t\tfor (col=row & 1; col < 1534; col+=2)\r\n\t\t\t\tBAYER(row,col) = pixel[col/2] << 1;\r\n\t}\r\n\tp->maximum = 0xff << 1;\r\n}\r\n\r\nvoid DCR_CLASS dcr_casio_qv5700_load_raw(DCRAW* p)\r\n{\r\n\tuchar  data[3232],  *dp;\r\n\tushort pixel[2576], *pix;\r\n\tint row, col;\r\n\r\n\tfor (row=0; row < p->height; row++) {\r\n\t\tdcr_fread(p->obj_, data, 1, 3232);\r\n\t\tfor (dp=data, pix=pixel; dp < data+3220; dp+=5, pix+=4) {\r\n\t\t\tpix[0] = (dp[0] << 2) + (dp[1] >> 6);\r\n\t\t\tpix[1] = (dp[1] << 4) + (dp[2] >> 4);\r\n\t\t\tpix[2] = (dp[2] << 6) + (dp[3] >> 2);\r\n\t\t\tpix[3] = (dp[3] << 8) + (dp[4]     );\r\n\t\t}\r\n\t\tfor (col=0; col < p->width; col++)\r\n\t\t\tBAYER(row,col) = (pixel[col] & 0x3ff);\r\n\t}\r\n\tp->maximum = 0x3fc;\r\n}\r\n\r\nvoid DCR_CLASS dcr_quicktake_100_load_raw(DCRAW* p)\r\n{\r\n\tuchar pixel[484][644];\r\n\tstatic const short gstep[16] =\r\n\t{ -89,-60,-44,-32,-22,-15,-8,-2,2,8,15,22,32,44,60,89 };\r\n\tstatic const short rstep[6][4] =\r\n\t{ {  -3,-1,1,3  }, {  -5,-1,1,5  }, {  -8,-2,2,8  },\r\n    { -13,-3,3,13 }, { -19,-4,4,19 }, { -28,-6,6,28 } };\r\n\tstatic const short curve[256] =\r\n\t{ 0,1,2,3,4,5,6,7,8,9,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,\r\n    28,29,30,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,53,\r\n    54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,74,75,76,77,78,\r\n    79,80,81,82,83,84,86,88,90,92,94,97,99,101,103,105,107,110,112,114,116,\r\n    118,120,123,125,127,129,131,134,136,138,140,142,144,147,149,151,153,155,\r\n    158,160,162,164,166,168,171,173,175,177,179,181,184,186,188,190,192,195,\r\n    197,199,201,203,205,208,210,212,214,216,218,221,223,226,230,235,239,244,\r\n    248,252,257,261,265,270,274,278,283,287,291,296,300,305,309,313,318,322,\r\n    326,331,335,339,344,348,352,357,361,365,370,374,379,383,387,392,396,400,\r\n    405,409,413,418,422,426,431,435,440,444,448,453,457,461,466,470,474,479,\r\n    483,487,492,496,500,508,519,531,542,553,564,575,587,598,609,620,631,643,\r\n    654,665,676,687,698,710,721,732,743,754,766,777,788,799,810,822,833,844,\r\n    855,866,878,889,900,911,922,933,945,956,967,978,989,1001,1012,1023 };\r\n\tint rb, row, col, sharp, val=0;\r\n\r\n\tdcr_getbits(p, -1);\r\n\tmemset (pixel, 0x80, sizeof pixel);\r\n\tfor (row=2; row < p->height+2; row++) {\r\n\t\tfor (col=2+(row & 1); col < p->width+2; col+=2) {\r\n\t\t\tval = ((pixel[row-1][col-1] + 2*pixel[row-1][col+1] +\r\n\t\t\t\tpixel[row][col-2]) >> 2) + gstep[dcr_getbits(p, 4)];\r\n\t\t\tpixel[row][col] = val = LIM(val,0,255);\r\n\t\t\tif (col < 4)\r\n\t\t\t\tpixel[row][col-2] = pixel[row+1][~row & 1] = val;\r\n\t\t\tif (row == 2)\r\n\t\t\t\tpixel[row-1][col+1] = pixel[row-1][col+3] = val;\r\n\t\t}\r\n\t\tpixel[row][col] = val;\r\n\t}\r\n\tfor (rb=0; rb < 2; rb++)\r\n\t\tfor (row=2+rb; row < p->height+2; row+=2)\r\n\t\t\tfor (col=3-(row & 1); col < p->width+2; col+=2) {\r\n\t\t\t\tif (row < 4 || col < 4) sharp = 2;\r\n\t\t\t\telse {\r\n\t\t\t\t\tval = ABS(pixel[row-2][col] - pixel[row][col-2])\r\n\t\t\t\t\t\t+ ABS(pixel[row-2][col] - pixel[row-2][col-2])\r\n\t\t\t\t\t\t+ ABS(pixel[row][col-2] - pixel[row-2][col-2]);\r\n\t\t\t\t\tsharp = val <  4 ? 0 : val <  8 ? 1 : val < 16 ? 2 :\r\n\t\t\t\t\tval < 32 ? 3 : val < 48 ? 4 : 5;\r\n\t\t\t\t}\r\n\t\t\t\tval = ((pixel[row-2][col] + pixel[row][col-2]) >> 1)\r\n\t\t\t\t\t+ rstep[sharp][dcr_getbits(p, 2)];\r\n\t\t\t\tpixel[row][col] = val = LIM(val,0,255);\r\n\t\t\t\tif (row < 4) pixel[row-2][col+2] = val;\r\n\t\t\t\tif (col < 4) pixel[row+2][col-2] = val;\r\n\t\t\t}\r\n\tfor (row=2; row < p->height+2; row++)\r\n\t\tfor (col=3-(row & 1); col < p->width+2; col+=2) {\r\n\t\t\tval = ((pixel[row][col-1] + (pixel[row][col] << 2) +\r\n\t\t\t\tpixel[row][col+1]) >> 1) - 0x100;\r\n\t\t\tpixel[row][col] = LIM(val,0,255);\r\n\t\t}\r\n\tfor (row=0; row < p->height; row++)\r\n\t\tfor (col=0; col < p->width; col++)\r\n\t\t\tBAYER(row,col) = curve[pixel[row+2][col+2]];\r\n\tp->maximum = 0x3ff;\r\n}\r\n\r\nconst int * DCR_CLASS dcr_make_decoder_int (DCRAW* p, const int *source, int level)\r\n{\r\n\tstruct dcr_decode *cur;\r\n\r\n\tcur = p->free_decode++;\r\n\tif (level < source[0]) {\r\n\t\tcur->branch[0] = p->free_decode;\r\n\t\tsource = dcr_make_decoder_int (p, source, level+1);\r\n\t\tcur->branch[1] = p->free_decode;\r\n\t\tsource = dcr_make_decoder_int (p, source, level+1);\r\n\t} else {\r\n\t\tcur->leaf = source[1];\r\n\t\tsource += 2;\r\n\t}\r\n\treturn source;\r\n}\r\n\r\nint DCR_CLASS dcr_radc_token (DCRAW* p, int tree)\r\n{\r\n\tint t;\r\n\tstatic struct dcr_decode *dstart[18], *dindex;\r\n\tstatic const int *s, source[] = {\r\n\t\t1,1, 2,3, 3,4, 4,2, 5,7, 6,5, 7,6, 7,8,\r\n\t\t1,0, 2,1, 3,3, 4,4, 5,2, 6,7, 7,6, 8,5, 8,8,\r\n\t\t2,1, 2,3, 3,0, 3,2, 3,4, 4,6, 5,5, 6,7, 6,8,\r\n\t\t2,0, 2,1, 2,3, 3,2, 4,4, 5,6, 6,7, 7,5, 7,8,\r\n\t\t2,1, 2,4, 3,0, 3,2, 3,3, 4,7, 5,5, 6,6, 6,8,\r\n\t\t2,3, 3,1, 3,2, 3,4, 3,5, 3,6, 4,7, 5,0, 5,8,\r\n\t\t2,3, 2,6, 3,0, 3,1, 4,4, 4,5, 4,7, 5,2, 5,8,\r\n\t\t2,4, 2,7, 3,3, 3,6, 4,1, 4,2, 4,5, 5,0, 5,8,\r\n\t\t2,6, 3,1, 3,3, 3,5, 3,7, 3,8, 4,0, 5,2, 5,4,\r\n\t\t2,0, 2,1, 3,2, 3,3, 4,4, 4,5, 5,6, 5,7, 4,8,\r\n\t\t1,0, 2,2, 2,-2,\r\n\t\t1,-3, 1,3,\r\n\t\t2,-17, 2,-5, 2,5, 2,17,\r\n\t\t2,-7, 2,2, 2,9, 2,18,\r\n\t\t2,-18, 2,-9, 2,-2, 2,7,\r\n\t\t2,-28, 2,28, 3,-49, 3,-9, 3,9, 4,49, 5,-79, 5,79,\r\n\t\t2,-1, 2,13, 2,26, 3,39, 4,-16, 5,55, 6,-37, 6,76,\r\n\t\t2,-26, 2,-13, 2,1, 3,-39, 4,16, 5,-55, 6,-76, 6,37\r\n\t};\r\n\r\n\tif (p->free_decode == p->first_decode)\r\n\t\tfor (s=source, t=0; t < 18; t++) {\r\n\t\t\tdstart[t] = p->free_decode;\r\n\t\t\ts = dcr_make_decoder_int (p, s, 0);\r\n\t\t}\r\n\tif (tree == 18) {\r\n\t\tif (p->kodak_cbpp == 243)\r\n\t\t\treturn (dcr_getbits(p, 6) << 2) + 2;\t/* most DC50 photos */\r\n\t\telse\r\n\t\t\treturn (dcr_getbits(p, 5) << 3) + 4;\t/* DC40, Fotoman Pixtura */\r\n\t}\r\n\tfor (dindex = dstart[tree]; dindex->branch[0]; )\r\n\t\tdindex = dindex->branch[dcr_getbits(p, 1)];\r\n\treturn dindex->leaf;\r\n}\r\n\r\n#define FORYX for (y=1; y < 3; y++) for (x=col+1; x >= col; x--)\r\n\r\n#define PREDICTOR (c ? (buf[c][y-1][x] + buf[c][y][x+1]) / 2 \\\r\n: (buf[c][y-1][x+1] + 2*buf[c][y-1][x] + buf[c][y][x+1]) / 4)\r\n\r\nvoid DCR_CLASS dcr_kodak_radc_load_raw(DCRAW* p)\r\n{\r\n\tint row, col, tree, nreps, rep, step, i, c, s, r, x, y, val;\r\n\tshort last[3] = { 16,16,16 }, mul[3], buf[3][3][386];\r\n\r\n\tdcr_init_decoder(p);\r\n\tdcr_getbits(p, -1);\r\n\tfor (i=0; i < sizeof(buf)/sizeof(short); i++)\r\n\t\tbuf[0][0][i] = 2048;\r\n\tfor (row=0; row < p->height; row+=4) {\r\n\t\tFORC3 mul[c] = dcr_getbits(p, 6);\r\n\t\tFORC3 {\r\n\t\t\tval = ((0x1000000/last[c] + 0x7ff) >> 12) * mul[c];\r\n\t\t\ts = val > 65564 ? 10:12;\r\n\t\t\tx = ~(-1 << (s-1));\r\n\t\t\tval <<= 12-s;\r\n\t\t\tfor (i=0; i < sizeof(buf[0])/sizeof(short); i++)\r\n\t\t\t\tbuf[c][0][i] = (buf[c][0][i] * val + x) >> s;\r\n\t\t\tlast[c] = mul[c];\r\n\t\t\tfor (r=0; r <= !c; r++) {\r\n\t\t\t\tbuf[c][1][p->width/2] = buf[c][2][p->width/2] = mul[c] << 7;\r\n\t\t\t\tfor (tree=1, col=p->width/2; col > 0; ) {\r\n\t\t\t\t\tif ((tree = dcr_radc_token(p,tree))) {\r\n\t\t\t\t\t\tcol -= 2;\r\n\t\t\t\t\t\tif (tree == 8)\r\n\t\t\t\t\t\t\tFORYX buf[c][y][x] = dcr_radc_token(p,tree+10) * mul[c];\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\tFORYX buf[c][y][x] = dcr_radc_token(p,tree+10) * 16 + PREDICTOR;\r\n\t\t\t\t\t} else\r\n\t\t\t\t\t\tdo {\r\n\t\t\t\t\t\t\tnreps = (col > 2) ? dcr_radc_token(p,9) + 1 : 1;\r\n\t\t\t\t\t\t\tfor (rep=0; rep < 8 && rep < nreps && col > 0; rep++) {\r\n\t\t\t\t\t\t\t\tcol -= 2;\r\n\t\t\t\t\t\t\t\tFORYX buf[c][y][x] = PREDICTOR;\r\n\t\t\t\t\t\t\t\tif (rep & 1) {\r\n\t\t\t\t\t\t\t\t\tstep = dcr_radc_token(p,10) << 4;\r\n\t\t\t\t\t\t\t\t\tFORYX buf[c][y][x] += step;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} while (nreps == 9);\r\n\t\t\t\t}\r\n\t\t\t\tfor (y=0; y < 2; y++)\r\n\t\t\t\t\tfor (x=0; x < p->width/2; x++) {\r\n\t\t\t\t\t\tval = (buf[c][y+1][x] << 4) / mul[c];\r\n\t\t\t\t\t\tif (val < 0) val = 0;\r\n\t\t\t\t\t\tif (c) BAYER(row+y*2+c-1,x*2+2-c) = val;\r\n\t\t\t\t\t\telse   BAYER(row+r*2+y,x*2+y) = val;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tmemcpy (buf[c][0]+!c, buf[c][2], sizeof buf[c][0]-2*!c);\r\n\t\t\t}\r\n\t\t}\r\n\t\tfor (y=row; y < row+4; y++)\r\n\t\t\tfor (x=0; x < p->width; x++)\r\n\t\t\t\tif ((x+y) & 1) {\r\n\t\t\t\t\tr = x ? x-1 : x+1;\r\n\t\t\t\t\ts = x+1 < p->width ? x+1 : x-1;\r\n\t\t\t\t\tval = (BAYER(y,x)-2048)*2 + (BAYER(y,r)+BAYER(y,s))/2;\r\n\t\t\t\t\tif (val < 0) val = 0;\r\n\t\t\t\t\tBAYER(y,x) = val;\r\n\t\t\t\t}\r\n\t}\r\n\tp->maximum = 0xfff;\r\n\tp->use_gamma = 0;\r\n}\r\n\r\n#undef FORYX\r\n#undef PREDICTOR\r\n\r\n#ifdef NO_JPEG\r\nvoid DCR_CLASS dcr_kodak_jpeg_load_raw(DCRAW* p) {}\r\n#else\r\n\r\nMETHODDEF(boolean)\r\nfill_input_buffer (j_decompress_ptr cinfo)\r\n{\r\n\tstatic uchar jpeg_buffer[4096];\r\n\tsize_t nbytes;\r\n\r\n\t//nbytes = dcr_fread(p->obj_, jpeg_buffer, 1, 4096);\r\n\tnbytes = fread (jpeg_buffer, 1, 4096, ifp);\r\n\t_swab (jpeg_buffer, jpeg_buffer, nbytes);\r\n\tcinfo->src->next_input_byte = jpeg_buffer;\r\n\tcinfo->src->bytes_in_buffer = nbytes;\r\n\treturn TRUE;\r\n}\r\n\r\nvoid DCR_CLASS dcr_kodak_jpeg_load_raw(DCRAW* p)\r\n{\r\n\tstruct jpeg_decompress_struct cinfo;\r\n\tstruct jpeg_error_mgr jerr;\r\n\tJSAMPARRAY buf;\r\n\tJSAMPLE (*pixel)[3];\r\n\tint row, col;\r\n\r\n\tcinfo.err = jpeg_std_error (&jerr);\r\n\tjpeg_create_decompress (&cinfo);\r\n\tjpeg_stdio_src (&cinfo);\r\n\tcinfo.src->fill_input_buffer = fill_input_buffer;\r\n\tjpeg_read_header (&cinfo, TRUE);\r\n\tjpeg_start_decompress (&cinfo);\r\n\tif ((cinfo.output_width      != p->width  ) ||\r\n\t\t(cinfo.output_height*2   != p->height ) ||\r\n\t\t(cinfo.output_components != 3      )) {\r\n\t\tfprintf (stderr,_(\"%s: incorrect JPEG dimensions\\n\"), p->ifname);\r\n\t\tjpeg_destroy_decompress (&cinfo);\r\n\t\tlongjmp (p->failure, 3);\r\n\t}\r\n\tbuf = (*cinfo.mem->alloc_sarray)\r\n\t\t((j_common_ptr) &cinfo, JPOOL_IMAGE, p->width*3, 1);\r\n\r\n\twhile (cinfo.output_scanline < cinfo.output_height) {\r\n\t\trow = cinfo.output_scanline * 2;\r\n\t\tjpeg_read_scanlines (&cinfo, buf, 1);\r\n\t\tpixel = (JSAMPLE (*)[3]) buf[0];\r\n\t\tfor (col=0; col < p->width; col+=2) {\r\n\t\t\tBAYER(row+0,col+0) = pixel[col+0][1] << 1;\r\n\t\t\tBAYER(row+1,col+1) = pixel[col+1][1] << 1;\r\n\t\t\tBAYER(row+0,col+1) = pixel[col][0] + pixel[col+1][0];\r\n\t\t\tBAYER(row+1,col+0) = pixel[col][2] + pixel[col+1][2];\r\n\t\t}\r\n\t}\r\n\tjpeg_finish_decompress (&cinfo);\r\n\tjpeg_destroy_decompress (&cinfo);\r\n\tp->maximum = 0xff << 1;\r\n}\r\n#endif\r\n\r\nvoid DCR_CLASS dcr_kodak_dc120_load_raw(DCRAW* p)\r\n{\r\n\tstatic const int mul[4] = { 162, 192, 187,  92 };\r\n\tstatic const int add[4] = {   0, 636, 424, 212 };\r\n\tuchar pixel[848];\r\n\tint row, shift, col;\r\n\r\n\tfor (row=0; row < p->height; row++) {\r\n\t\tif (dcr_fread(p->obj_, pixel, 1, 848) < 848) dcr_derror(p);\r\n\t\tshift = row * mul[row & 3] + add[row & 3];\r\n\t\tfor (col=0; col < p->width; col++)\r\n\t\t\tBAYER(row,col) = (ushort) pixel[(col + shift) % 848];\r\n\t}\r\n\tp->maximum = 0xff;\r\n}\r\n\r\nvoid DCR_CLASS dcr_eight_bit_load_raw(DCRAW* p)\r\n{\r\n\tuchar *pixel;\r\n\tunsigned row, col, val, lblack=0;\r\n\r\n\tpixel = (uchar *) calloc (p->raw_width, sizeof *pixel);\r\n\tdcr_merror (p, pixel, \"eight_bit_load_raw()\");\r\n\tdcr_fseek(p->obj_, p->top_margin*p->raw_width, SEEK_CUR);\r\n\tfor (row=0; row < p->height; row++) {\r\n\t\tif (dcr_fread(p->obj_, pixel, 1, p->raw_width) < p->raw_width) dcr_derror(p);\r\n\t\tfor (col=0; col < p->raw_width; col++) {\r\n\t\t\tval = p->curve[pixel[col]];\r\n\t\t\tif ((unsigned) (col-p->left_margin) < p->width)\r\n\t\t\t\tBAYER(row,col-p->left_margin) = val;\r\n\t\t\telse lblack += val;\r\n\t\t}\r\n\t}\r\n\tfree (pixel);\r\n\tif (p->raw_width > p->width+1)\r\n\t\tp->black = lblack / ((p->raw_width - p->width) * p->height);\r\n\tif (!strncmp(p->model,\"DC2\",3))\r\n\t\tp->black = 0;\r\n\tp->maximum = p->curve[0xff];\r\n}\r\n\r\nvoid DCR_CLASS dcr_kodak_yrgb_load_raw(DCRAW* p)\r\n{\r\n  uchar *pixel;\r\n  int row, col, y, cb, cr, rgb[3], c;\r\n\r\n  pixel = (uchar *) calloc (p->raw_width, 3*sizeof *pixel);\r\n  dcr_merror (p, pixel, \"kodak_yrgb_load_raw()\");\r\n  for (row=0; row < p->height; row++) {\r\n    if (~row & 1)\r\n      if (dcr_fread(p->obj_, pixel, p->raw_width, 3) < 3) dcr_derror(p);\r\n    for (col=0; col < p->raw_width; col++) {\r\n      y  = pixel[p->width*2*(row & 1) + col];\r\n      cb = pixel[p->width + (col & -2)]   - 128;\r\n      cr = pixel[p->width + (col & -2)+1] - 128;\r\n      rgb[1] = y-((cb + cr + 2) >> 2);\r\n      rgb[2] = rgb[1] + cb;\r\n      rgb[0] = rgb[1] + cr;\r\n      FORC3 p->image[row*p->width+col][c] = LIM(rgb[c],0,255);\r\n    }\r\n  }\r\n  free (pixel);\r\n  p->use_gamma = 0;\r\n}\r\n\r\nvoid DCR_CLASS dcr_kodak_262_load_raw(DCRAW* p)\r\n{\r\n\tstatic const uchar kodak_tree[2][26] =\r\n\t{ { 0,1,5,1,1,2,0,0,0,0,0,0,0,0,0,0, 0,1,2,3,4,5,6,7,8,9 },\r\n    { 0,3,1,1,1,1,1,2,0,0,0,0,0,0,0,0, 0,1,2,3,4,5,6,7,8,9 } };\r\n\tstruct dcr_decode *decode[2];\r\n\tuchar *pixel;\r\n\tint *strip, ns, i, row, col, chess, pi=0, pi1, pi2, pred, val;\r\n\r\n\tdcr_init_decoder(p);\r\n\tfor (i=0; i < 2; i++) {\r\n\t\tdecode[i] = p->free_decode;\r\n\t\tdcr_make_decoder (p, kodak_tree[i], 0);\r\n\t}\r\n\tns = (p->raw_height+63) >> 5;\r\n\tpixel = (uchar *) malloc (p->raw_width*32 + ns*4);\r\n\tdcr_merror (p, pixel, \"kodak_262_load_raw()\");\r\n\tstrip = (int *) (pixel + p->raw_width*32);\r\n\tp->order = 0x4d4d;\r\n\tfor (i=0; i < ns; i++)\r\n\t\tstrip[i] = dcr_get4(p);\r\n\tfor (row=0; row < p->raw_height; row++) {\r\n\t\tif ((row & 31) == 0) {\r\n\t\t\tdcr_fseek(p->obj_, strip[row >> 5], SEEK_SET);\r\n\t\t\tdcr_getbits(p, -1);\r\n\t\t\tpi = 0;\r\n\t\t}\r\n\t\tfor (col=0; col < p->raw_width; col++) {\r\n\t\t\tchess = (row + col) & 1;\r\n\t\t\tpi1 = chess ? pi-2           : pi-p->raw_width-1;\r\n\t\t\tpi2 = chess ? pi-2*p->raw_width : pi-p->raw_width+1;\r\n\t\t\tif (col <= chess) pi1 = -1;\r\n\t\t\tif (pi1 < 0) pi1 = pi2;\r\n\t\t\tif (pi2 < 0) pi2 = pi1;\r\n\t\t\tif (pi1 < 0 && col > 1) pi1 = pi2 = pi-2;\r\n\t\t\tpred = (pi1 < 0) ? 0 : (pixel[pi1] + pixel[pi2]) >> 1;\r\n\t\t\tpixel[pi] = val = pred + dcr_ljpeg_diff (p, decode[chess]);\r\n\t\t\tif (val >> 8) dcr_derror(p);\r\n\t\t\tval = p->curve[pixel[pi++]];\r\n\t\t\tif ((unsigned) (col-p->left_margin) < p->width)\r\n\t\t\t\tBAYER(row,col-p->left_margin) = val;\r\n\t\t\telse p->black += val;\r\n\t\t}\r\n\t}\r\n\tfree (pixel);\r\n\tif (p->raw_width > p->width)\r\n\t\tp->black /= (p->raw_width - p->width) * p->height;\r\n}\r\n\r\nint DCR_CLASS dcr_kodak_65000_decode (DCRAW* p, short *out, int bsize)\r\n{\r\n\tuchar c, blen[768];\r\n\tushort raw[6];\r\n\tINT64 bitbuf=0;\r\n\tint save, bits=0, i, j, len, diff;\r\n\r\n\tsave = dcr_ftell(p->obj_);\r\n\tbsize = (bsize + 3) & -4;\r\n\tfor (i=0; i < bsize; i+=2) {\r\n\t\tc = dcr_fgetc(p->obj_);\r\n\t\tif ((blen[i  ] = c & 15) > 12 ||\r\n\t\t\t(blen[i+1] = c >> 4) > 12 ) {\r\n\t\t\tdcr_fseek(p->obj_, save, SEEK_SET);\r\n\t\t\tfor (i=0; i < bsize; i+=8) {\r\n\t\t\t\tdcr_read_shorts (p, raw, 6);\r\n\t\t\t\tout[i  ] = raw[0] >> 12 << 8 | raw[2] >> 12 << 4 | raw[4] >> 12;\r\n\t\t\t\tout[i+1] = raw[1] >> 12 << 8 | raw[3] >> 12 << 4 | raw[5] >> 12;\r\n\t\t\t\tfor (j=0; j < 6; j++)\r\n\t\t\t\t\tout[i+2+j] = raw[j] & 0xfff;\r\n\t\t\t}\r\n\t\t\treturn 1;\r\n\t\t}\r\n\t}\r\n\tif ((bsize & 7) == 4) {\r\n\t\tbitbuf  = dcr_fgetc(p->obj_) << 8;\r\n\t\tbitbuf += dcr_fgetc(p->obj_);\r\n\t\tbits = 16;\r\n\t}\r\n\tfor (i=0; i < bsize; i++) {\r\n\t\tlen = blen[i];\r\n\t\tif (bits < len) {\r\n\t\t\tfor (j=0; j < 32; j+=8)\r\n\t\t\t\tbitbuf += (INT64) dcr_fgetc(p->obj_) << (bits+(j^8));\r\n\t\t\tbits += 32;\r\n\t\t}\r\n\t\tdiff = (int)(bitbuf & (0xffff >> (16-len)));\r\n\t\tbitbuf >>= len;\r\n\t\tbits -= len;\r\n\t\tif ((diff & (1 << (len-1))) == 0)\r\n\t\t\tdiff -= (1 << len) - 1;\r\n\t\tout[i] = diff;\r\n\t}\r\n\treturn 0;\r\n}\r\n\r\nvoid DCR_CLASS dcr_kodak_65000_load_raw(DCRAW* p)\r\n{\r\n\tshort buf[256];\r\n\tint row, col, len, pred[2], ret, i;\r\n\r\n\tfor (row=0; row < p->height; row++)\r\n\t\tfor (col=0; col < p->width; col+=256) {\r\n\t\t\tpred[0] = pred[1] = 0;\r\n\t\t\tlen = MIN (256, p->width-col);\r\n\t\t\tret = dcr_kodak_65000_decode (p, buf, len);\r\n\t\t\tfor (i=0; i < len; i++)\r\n\t\t\t\tif ((BAYER(row,col+i) =\tp->curve[ret ? buf[i] :\r\n\t\t\t\t(pred[i & 1] += buf[i])]) >> 12) dcr_derror(p);\r\n\t\t}\r\n}\r\n\r\nvoid DCR_CLASS dcr_kodak_ycbcr_load_raw(DCRAW* p)\r\n{\r\n\tshort buf[384], *bp;\r\n\tint row, col, len, c, i, j, k, y[2][2], cb, cr, rgb[3];\r\n\tushort *ip;\r\n\r\n\tfor (row=0; row < p->height; row+=2)\r\n\t\tfor (col=0; col < p->width; col+=128) {\r\n\t\t\tlen = MIN (128, p->width-col);\r\n\t\t\tdcr_kodak_65000_decode (p, buf, len*3);\r\n\t\t\ty[0][1] = y[1][1] = cb = cr = 0;\r\n\t\t\tfor (bp=buf, i=0; i < len; i+=2, bp+=2) {\r\n\t\t\t\tcb += bp[4];\r\n\t\t\t\tcr += bp[5];\r\n\t\t\t\trgb[1] = -((cb + cr + 2) >> 2);\r\n\t\t\t\trgb[2] = rgb[1] + cb;\r\n\t\t\t\trgb[0] = rgb[1] + cr;\r\n\t\t\t\tfor (j=0; j < 2; j++)\r\n\t\t\t\t\tfor (k=0; k < 2; k++) {\r\n\t\t\t\t\t\tif ((y[j][k] = y[j][k^1] + *bp++) >> 10) dcr_derror(p);\r\n\t\t\t\t\t\tip = p->image[(row+j)*p->width + col+i+k];\r\n\t\t\t\t\t\tFORC3 ip[c] = p->curve[LIM(y[j][k]+rgb[c], 0, 0xfff)];\r\n\t\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n}\r\n\r\nvoid DCR_CLASS dcr_kodak_rgb_load_raw(DCRAW* p)\r\n{\r\n\tshort buf[768], *bp;\r\n\tint row, col, len, c, i, rgb[3];\r\n\tushort *ip=p->image[0];\r\n\r\n\tfor (row=0; row < p->height; row++)\r\n\t\tfor (col=0; col < p->width; col+=256) {\r\n\t\t\tlen = MIN (256, p->width-col);\r\n\t\t\tdcr_kodak_65000_decode (p, buf, len*3);\r\n\t\t\tmemset (rgb, 0, sizeof rgb);\r\n\t\t\tfor (bp=buf, i=0; i < len; i++, ip+=4)\r\n\t\t\t\tFORC3 if ((ip[c] = rgb[c] += *bp++) >> 12) dcr_derror(p);\r\n\t\t}\r\n}\r\n\r\nvoid DCR_CLASS dcr_kodak_thumb_load_raw(DCRAW* p)\r\n{\r\n\tint row, col;\r\n\tp->colors = p->thumb_misc >> 5;\r\n\tfor (row=0; row < p->height; row++)\r\n\t\tfor (col=0; col < p->width; col++)\r\n\t\t\tdcr_read_shorts (p, p->image[row*p->width+col], p->colors);\r\n\t\tp->maximum = (1 << (p->thumb_misc & 31)) - 1;\r\n}\r\n\r\nvoid DCR_CLASS dcr_sony_decrypt (unsigned *data, int len, int start, int key)\r\n{\r\n\tstatic unsigned pad[128], p;\r\n\r\n\tif (start) {\r\n\t\tfor (p=0; p < 4; p++)\r\n\t\t\tpad[p] = key = key * 48828125 + 1;\r\n\t\tpad[3] = pad[3] << 1 | (pad[0]^pad[2]) >> 31;\r\n\t\tfor (p=4; p < 127; p++)\r\n\t\t\tpad[p] = (pad[p-4]^pad[p-2]) << 1 | (pad[p-3]^pad[p-1]) >> 31;\r\n\t\tfor (p=0; p < 127; p++)\r\n\t\t\tpad[p] = htonl(pad[p]);\r\n\t}\r\n\twhile (len--)\r\n\t\t*data++ ^= pad[p++ & 127] = pad[(p+1) & 127] ^ pad[(p+65) & 127];\r\n}\r\n\r\nvoid DCR_CLASS dcr_sony_load_raw(DCRAW* p)\r\n{\r\n\tuchar head[40];\r\n\tushort *pixel;\r\n\tunsigned i, key, row, col;\r\n\r\n\tdcr_fseek(p->obj_, 200896, SEEK_SET);\r\n\tdcr_fseek(p->obj_, (unsigned) dcr_fgetc(p->obj_)*4 - 1, SEEK_CUR);\r\n\tp->order = 0x4d4d;\r\n\tkey = dcr_get4(p);\r\n\tdcr_fseek(p->obj_, 164600, SEEK_SET);\r\n\tdcr_fread(p->obj_, head, 1, 40);\r\n\tdcr_sony_decrypt ((unsigned int *) head, 10, 1, key);\r\n\tfor (i=26; i-- > 22; )\r\n\t\tkey = key << 8 | head[i];\r\n\tdcr_fseek(p->obj_, p->data_offset, SEEK_SET);\r\n\tpixel = (ushort *) calloc (p->raw_width, sizeof *pixel);\r\n\tdcr_merror (p, pixel, \"sony_load_raw()\");\r\n\tfor (row=0; row < p->height; row++) {\r\n\t\tif (dcr_fread(p->obj_, pixel, 2, p->raw_width) < p->raw_width) dcr_derror(p);\r\n\t\tdcr_sony_decrypt ((unsigned int *) pixel, p->raw_width/2, !row, key);\r\n\t\tfor (col=9; col < p->left_margin; col++)\r\n\t\t\tp->black += ntohs(pixel[col]);\r\n\t\tfor (col=0; col < p->width; col++)\r\n\t\t\tif ((BAYER(row,col) = ntohs(pixel[col+p->left_margin])) >> 14)\r\n\t\t\t\tdcr_derror(p);\r\n\t}\r\n\tfree (pixel);\r\n\tif (p->left_margin > 9)\r\n\t\tp->black /= (p->left_margin-9) * p->height;\r\n\tp->maximum = 0x3ff0;\r\n}\r\n\r\nvoid DCR_CLASS dcr_sony_arw_load_raw(DCRAW* p)\r\n{\r\n\tint col, row, len, diff, sum=0;\r\n\r\n\tdcr_getbits(p, -1);\r\n\tfor (col = p->raw_width; col--; )\r\n\t\tfor (row=0; row < p->raw_height+1; row+=2) {\r\n\t\t\tif (row == p->raw_height) row = 1;\r\n\t\t\tlen = 4 - dcr_getbits(p, 2);\r\n\t\t\tif (len == 3 && dcr_getbits(p, 1)) len = 0;\r\n\t\t\tif (len == 4)\r\n\t\t\t\twhile (len < 17 && !dcr_getbits(p, 1)) len++;\r\n\t\t\t\tdiff = dcr_getbits(p, len);\r\n\t\t\t\tif ((diff & (1 << (len-1))) == 0)\r\n\t\t\t\t\tdiff -= (1 << len) - 1;\r\n\t\t\t\tif ((sum += diff) >> 12) dcr_derror(p);\r\n\t\t\t\tif (row < p->height) BAYER(row,col) = sum;\r\n\t\t}\r\n}\r\n\r\nvoid DCR_CLASS dcr_sony_arw2_load_raw(DCRAW* p)\r\n{\r\n\tuchar *data, *dp;\r\n\tushort pix[16];\r\n\tint row, col, val, max, min, imax, imin, sh, bit, i;\r\n\r\n\tdata = (uchar *) malloc (p->raw_width*p->tiff_bps >> 3);\r\n\tdcr_merror (p, data, \"sony_arw2_load_raw()\");\r\n\tfor (row=0; row < p->height; row++) {\r\n\t\tdcr_fread(p->obj_, data, 1, p->raw_width*p->tiff_bps >> 3);\r\n\t\tif (p->tiff_bps == 8) {\r\n\t\t\tfor (dp=data, col=0; col < p->width-30; dp+=16) {\r\n\t\t\t\tmax = 0x7ff & (val = dcr_sget4(p, dp));\r\n\t\t\t\tmin = 0x7ff & val >> 11;\r\n\t\t\t\timax = 0x0f & val >> 22;\r\n\t\t\t\timin = 0x0f & val >> 26;\r\n\t\t\t\tfor (sh=0; sh < 4 && 0x80 << sh <= max-min; sh++);\r\n\t\t\t\tfor (bit=30, i=0; i < 16; i++)\r\n\t\t\t\t\tif      (i == imax) pix[i] = max;\r\n\t\t\t\t\telse if (i == imin) pix[i] = min;\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tpix[i] = ((dcr_sget2(p, dp+(bit >> 3)) >> (bit & 7) & 0x7f) << sh) + min;\r\n\t\t\t\t\t\tif (pix[i] > 0x7ff) pix[i] = 0x7ff;\r\n\t\t\t\t\t\tbit += 7;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tfor (i=0; i < 16; i++, col+=2)\r\n\t\t\t\t\t\tBAYER(row,col) = p->curve[pix[i] << 1] >> 1;\r\n\t\t\t\t\tcol -= col & 1 ? 1:31;\r\n\t\t\t}\r\n\t\t} else if (p->tiff_bps == 12)\r\n\t\t\tfor (dp=data, col=0; col < p->width; dp+=3, col+=2) {\r\n\t\t\t\tBAYER(row,col)   = ((dp[1] << 8 | dp[0]) & 0xfff) << 1;\r\n\t\t\t\tBAYER(row,col+1) =  (dp[2] << 4 | dp[1] >> 4) << 1;\r\n\t\t\t}\r\n\t}\r\n\tfree (data);\r\n}\r\n\r\n#define HOLE(row) ((holes >> (((row) - p->raw_height) & 7)) & 1)\r\n\r\n/* Kudos to Rich Taylor for figuring out SMaL's compression algorithm. */\r\nvoid DCR_CLASS dcr_smal_decode_segment (DCRAW* p, unsigned seg[2][2], int holes)\r\n{\r\n\tuchar hist[3][13] = {\r\n\t\t{ 7, 7, 0, 0, 63, 55, 47, 39, 31, 23, 15, 7, 0 },\r\n\t\t{ 7, 7, 0, 0, 63, 55, 47, 39, 31, 23, 15, 7, 0 },\r\n\t\t{ 3, 3, 0, 0, 63,     47,     31,     15,    0 } };\r\n\tint low, high=0xff, carry=0, nbits=8;\r\n\tint s, count, bin, next, i, sym[3];\r\n\tuchar diff, pred[]={0,0};\r\n\tushort data=0, range=0;\r\n\tunsigned pix, row, col;\r\n\r\n\tdcr_fseek(p->obj_, seg[0][1]+1, SEEK_SET);\r\n\tdcr_getbits(p, -1);\r\n\tfor (pix=seg[0][0]; pix < seg[1][0]; pix++) {\r\n\t\tfor (s=0; s < 3; s++) {\r\n\t\t\tdata = data << nbits | dcr_getbits(p, nbits);\r\n\t\t\tif (carry < 0)\r\n\t\t\t\tcarry = (nbits += carry+1) < 1 ? nbits-1 : 0;\r\n\t\t\twhile (--nbits >= 0)\r\n\t\t\t\tif ((data >> nbits & 0xff) == 0xff) break;\r\n\t\t\t\tif (nbits > 0)\r\n\t\t\t\t\tdata = ((data & ((1 << (nbits-1)) - 1)) << 1) |\r\n\t\t\t\t\t((data + (((data & (1 << (nbits-1)))) << 1)) & (-1 << nbits));\r\n\t\t\t\tif (nbits >= 0) {\r\n\t\t\t\t\tdata += dcr_getbits(p, 1);\r\n\t\t\t\t\tcarry = nbits - 8;\r\n\t\t\t\t}\r\n\t\t\t\tcount = ((((data-range+1) & 0xffff) << 2) - 1) / (high >> 4);\r\n\t\t\t\tfor (bin=0; hist[s][bin+5] > count; bin++);\r\n\t\t\t\tlow = hist[s][bin+5] * (high >> 4) >> 2;\r\n\t\t\t\tif (bin) high = hist[s][bin+4] * (high >> 4) >> 2;\r\n\t\t\t\thigh -= low;\r\n\t\t\t\tfor (nbits=0; high << nbits < 128; nbits++);\r\n\t\t\t\trange = (range+low) << nbits;\r\n\t\t\t\thigh <<= nbits;\r\n\t\t\t\tnext = hist[s][1];\r\n\t\t\t\tif (++hist[s][2] > hist[s][3]) {\r\n\t\t\t\t\tnext = (next+1) & hist[s][0];\r\n\t\t\t\t\thist[s][3] = (hist[s][next+4] - hist[s][next+5]) >> 2;\r\n\t\t\t\t\thist[s][2] = 1;\r\n\t\t\t\t}\r\n\t\t\t\tif (hist[s][hist[s][1]+4] - hist[s][hist[s][1]+5] > 1) {\r\n\t\t\t\t\tif (bin < hist[s][1])\r\n\t\t\t\t\t\tfor (i=bin; i < hist[s][1]; i++) hist[s][i+5]--;\r\n\t\t\t\t\t\telse if (next <= bin)\r\n\t\t\t\t\t\t\tfor (i=hist[s][1]; i < bin; i++) hist[s][i+5]++;\r\n\t\t\t\t}\r\n\t\t\t\thist[s][1] = next;\r\n\t\t\t\tsym[s] = bin;\r\n\t\t}\r\n\t\tdiff = sym[2] << 5 | sym[1] << 2 | (sym[0] & 3);\r\n\t\tif (sym[0] & 4)\r\n\t\t\tdiff = diff ? -diff : 0x80;\r\n\t\tif (dcr_ftell(p->obj_) + 12 >= (long)seg[1][1])\r\n\t\t\tdiff = 0;\r\n\t\tpred[pix & 1] += diff;\r\n\t\trow = pix / p->raw_width - p->top_margin;\r\n\t\tcol = pix % p->raw_width - p->left_margin;\r\n\t\tif (row < p->height && col < p->width)\r\n\t\t\tBAYER(row,col) = pred[pix & 1];\r\n\t\tif (!(pix & 1) && HOLE(row)) pix += 2;\r\n\t}\r\n\tp->maximum = 0xff;\r\n}\r\n\r\nvoid DCR_CLASS dcr_smal_v6_load_raw(DCRAW* p)\r\n{\r\n\tunsigned seg[2][2];\r\n\r\n\tdcr_fseek(p->obj_, 16, SEEK_SET);\r\n\tseg[0][0] = 0;\r\n\tseg[0][1] = dcr_get2(p);\r\n\tseg[1][0] = p->raw_width * p->raw_height;\r\n\tseg[1][1] = INT_MAX;\r\n\tdcr_smal_decode_segment (p,seg, 0);\r\n\tp->use_gamma = 0;\r\n}\r\n\r\nint DCR_CLASS dcr_median4 (int *p)\r\n{\r\n\tint min, max, sum, i;\r\n\r\n\tmin = max = sum = p[0];\r\n\tfor (i=1; i < 4; i++) {\r\n\t\tsum += p[i];\r\n\t\tif (min > p[i]) min = p[i];\r\n\t\tif (max < p[i]) max = p[i];\r\n\t}\r\n\treturn (sum - min - max) >> 1;\r\n}\r\n\r\nvoid DCR_CLASS dcr_fill_holes (DCRAW* p, int holes)\r\n{\r\n\tint row, col, val[4];\r\n\r\n\tfor (row=2; row < p->height-2; row++) {\r\n\t\tif (!HOLE(row)) continue;\r\n\t\tfor (col=1; col < p->width-1; col+=4) {\r\n\t\t\tval[0] = BAYER(row-1,col-1);\r\n\t\t\tval[1] = BAYER(row-1,col+1);\r\n\t\t\tval[2] = BAYER(row+1,col-1);\r\n\t\t\tval[3] = BAYER(row+1,col+1);\r\n\t\t\tBAYER(row,col) = dcr_median4(val);\r\n\t\t}\r\n\t\tfor (col=2; col < p->width-2; col+=4)\r\n\t\t\tif (HOLE(row-2) || HOLE(row+2))\r\n\t\t\t\tBAYER(row,col) = (BAYER(row,col-2) + BAYER(row,col+2)) >> 1;\r\n\t\t\telse {\r\n\t\t\t\tval[0] = BAYER(row,col-2);\r\n\t\t\t\tval[1] = BAYER(row,col+2);\r\n\t\t\t\tval[2] = BAYER(row-2,col);\r\n\t\t\t\tval[3] = BAYER(row+2,col);\r\n\t\t\t\tBAYER(row,col) = dcr_median4(val);\r\n\t\t\t}\r\n\t}\r\n}\r\n\r\nvoid DCR_CLASS dcr_smal_v9_load_raw(DCRAW* p)\r\n{\r\n\tunsigned seg[256][2], offset, nseg, holes, i;\r\n\r\n\tdcr_fseek(p->obj_, 67, SEEK_SET);\r\n\toffset = dcr_get4(p);\r\n\tnseg = dcr_fgetc(p->obj_);\r\n\tdcr_fseek(p->obj_, offset, SEEK_SET);\r\n\tfor (i=0; i < nseg*2; i++)\r\n\t\tseg[0][i] = dcr_get4(p) + p->data_offset*(i & 1);\r\n\tdcr_fseek(p->obj_, 78, SEEK_SET);\r\n\tholes = dcr_fgetc(p->obj_);\r\n\tdcr_fseek(p->obj_, 88, SEEK_SET);\r\n\tseg[nseg][0] = p->raw_height * p->raw_width;\r\n\tseg[nseg][1] = dcr_get4(p) + p->data_offset;\r\n\tfor (i=0; i < nseg; i++)\r\n\t\tdcr_smal_decode_segment (p,seg+i, holes);\r\n\tif (holes) dcr_fill_holes (p,holes);\r\n}\r\n\r\n/* RESTRICTED code starts here */\r\n#if RESTRICTED\r\n\r\nvoid DCR_CLASS dcr_foveon_decoder (DCRAW* p, unsigned size, unsigned code)\r\n{\r\n\tstatic unsigned huff[1024];\r\n\tstruct dcr_decode *cur;\r\n\tint i, len;\r\n\r\n\tif (!code) {\r\n\t\tfor (i=0; i < (int)size; i++)\r\n\t\t\thuff[i] = dcr_get4(p);\r\n\t\tdcr_init_decoder(p);\r\n\t}\r\n\tcur = p->free_decode++;\r\n\tif (p->free_decode > p->first_decode+2048) {\r\n\t\tfprintf (stderr,_(\"%s: decoder table overflow\\n\"), p->ifname);\r\n\t\tlongjmp (p->failure, 2);\r\n\t}\r\n\tif (code)\r\n\t\tfor (i=0; i < (int)size; i++)\r\n\t\t\tif (huff[i] == code) {\r\n\t\t\t\tcur->leaf = i;\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\tif ((len = code >> 27) > 26) return;\r\n\tcode = (len+1) << 27 | (code & 0x3ffffff) << 1;\r\n\r\n\tcur->branch[0] = p->free_decode;\r\n\tdcr_foveon_decoder (p,size, code);\r\n\tcur->branch[1] = p->free_decode;\r\n\tdcr_foveon_decoder (p,size, code+1);\r\n}\r\n\r\nvoid DCR_CLASS dcr_foveon_thumb (DCRAW* p, FILE *tfp)\r\n{\r\n\tunsigned bwide, row, col, bitbuf=0, bit=1, c, i;\r\n\tchar *buf;\r\n\tstruct dcr_decode *dindex;\r\n\tshort pred[3];\r\n\r\n\tbwide = dcr_get4(p);\r\n\tfprintf (tfp, \"P6\\n%d %d\\n255\\n\", p->thumb_width, p->thumb_height);\r\n\tif (bwide > 0) {\r\n\t\tif (bwide < (unsigned int)(p->thumb_width*3)) return;\r\n\t\tbuf = (char *) malloc (bwide);\r\n\t\tdcr_merror (p, buf, \"foveon_thumb()\");\r\n\t\tfor (row=0; row < p->thumb_height; row++) {\r\n\t\t\tdcr_fread(p->obj_, buf, 1, bwide);\r\n\t\t\tfwrite (buf, 3, p->thumb_width, tfp);\r\n\t\t}\r\n\t\tfree (buf);\r\n\t\treturn;\r\n\t}\r\n\tdcr_foveon_decoder (p,256, 0);\r\n\r\n\tfor (row=0; row < p->thumb_height; row++) {\r\n\t\tmemset (pred, 0, sizeof pred);\r\n\t\tif (!bit) dcr_get4(p);\r\n\t\tfor (bit=col=0; col < p->thumb_width; col++)\r\n\t\t\tFORC3 {\r\n\t\t\tfor (dindex=p->first_decode; dindex->branch[0]; ) {\r\n\t\t\t\tif ((bit = (bit-1) & 31) == 31)\r\n\t\t\t\t\tfor (i=0; i < 4; i++)\r\n\t\t\t\t\t\tbitbuf = (bitbuf << 8) + dcr_fgetc(p->obj_);\r\n\t\t\t\t\tdindex = dindex->branch[bitbuf >> bit & 1];\r\n\t\t\t}\r\n\t\t\tpred[c] += dindex->leaf;\r\n\t\t\tfputc (pred[c], tfp);\r\n\t\t}\r\n\t}\r\n}\r\n\r\nvoid DCR_CLASS dcr_foveon_load_camf(DCRAW* p)\r\n{\r\n\tunsigned key, i, val;\r\n\r\n\tdcr_fseek(p->obj_, p->meta_offset, SEEK_SET);\r\n\tkey = dcr_get4(p);\r\n\tdcr_fread(p->obj_, p->meta_data, 1, p->meta_length);\r\n\tfor (i=0; i < p->meta_length; i++) {\r\n\t\tkey = (key * 1597 + 51749) % 244944;\r\n\t\tval = (unsigned int)(key * (INT64) 301593171 >> 24);\r\n\t\tp->meta_data[i] ^= ((((key << 8) - val) >> 1) + val) >> 17;\r\n\t}\r\n}\r\n\r\nvoid DCR_CLASS dcr_foveon_load_raw(DCRAW* p)\r\n{\r\n\tstruct dcr_decode *dindex;\r\n\tshort diff[1024];\r\n\tunsigned bitbuf=0;\r\n\tint pred[3], fixed, row, col, bit=-1, c, i;\r\n\r\n\tfixed = dcr_get4(p);\r\n\tdcr_read_shorts (p, (ushort *) diff, 1024);\r\n\tif (!fixed) dcr_foveon_decoder (p, 1024, 0);\r\n\r\n\tfor (row=0; row < p->height; row++) {\r\n\t\tmemset (pred, 0, sizeof pred);\r\n\t\tif (!bit && !fixed && atoi(p->model+2) < 14) dcr_get4(p);\r\n\t\tfor (col=bit=0; col < p->width; col++) {\r\n\t\t\tif (fixed) {\r\n\t\t\t\tbitbuf = dcr_get4(p);\r\n\t\t\t\tFORC3 pred[2-c] += diff[bitbuf >> c*10 & 0x3ff];\r\n\t\t\t}\r\n\t\t\telse FORC3 {\r\n\t\t\t\tfor (dindex=p->first_decode; dindex->branch[0]; ) {\r\n\t\t\t\t\tif ((bit = (bit-1) & 31) == 31)\r\n\t\t\t\t\t\tfor (i=0; i < 4; i++)\r\n\t\t\t\t\t\t\tbitbuf = (bitbuf << 8) + dcr_fgetc(p->obj_);\r\n\t\t\t\t\t\tdindex = dindex->branch[bitbuf >> bit & 1];\r\n\t\t\t\t}\r\n\t\t\t\tpred[c] += diff[dindex->leaf];\r\n\t\t\t\tif (pred[c] >> 16 && ~pred[c] >> 16) dcr_derror(p);\r\n\t\t\t}\r\n\t\t\tFORC3 p->image[row*p->width+col][c] = pred[c];\r\n\t\t}\r\n\t}\r\n\tif (p->opt.document_mode)\r\n\t\tfor (i=0; i < p->height*p->width*4; i++)\r\n\t\t\tif ((short) p->image[0][i] < 0) p->image[0][i] = 0;\r\n\t\t\tdcr_foveon_load_camf(p);\r\n}\r\n\r\nconst char * DCR_CLASS dcr_foveon_camf_param (DCRAW* p, const char *block, const char *param)\r\n{\r\n\tunsigned idx, num;\r\n\tchar *pos, *cp, *dp;\r\n\r\n\tfor (idx=0; idx < p->meta_length; idx += dcr_sget4(p, pos+8)) {\r\n\t\tpos = p->meta_data + idx;\r\n\t\tif (strncmp (pos, \"CMb\", 3)) break;\r\n\t\tif (pos[3] != 'P') continue;\r\n\t\tif (strcmp (block, pos+dcr_sget4(p, pos+12))) continue;\r\n\t\tcp = pos + dcr_sget4(p, pos+16);\r\n\t\tnum = dcr_sget4(p, cp);\r\n\t\tdp = pos + dcr_sget4(p, cp+4);\r\n\t\twhile (num--) {\r\n\t\t\tcp += 8;\r\n\t\t\tif (!strcmp (param, dp+dcr_sget4(p, cp)))\r\n\t\t\t\treturn dp+dcr_sget4(p, cp+4);\r\n\t\t}\r\n\t}\r\n\treturn 0;\r\n}\r\n\r\nvoid * DCR_CLASS dcr_foveon_camf_matrix (DCRAW* p, unsigned dim[3], const char *name)\r\n{\r\n\tunsigned i, idx, type, ndim, size, *mat;\r\n\tchar *pos, *cp, *dp;\r\n\tdouble dsize;\r\n\r\n\tfor (idx=0; idx < p->meta_length; idx += dcr_sget4(p, pos+8)) {\r\n\t\tpos = p->meta_data + idx;\r\n\t\tif (strncmp (pos, \"CMb\", 3)) break;\r\n\t\tif (pos[3] != 'M') continue;\r\n\t\tif (strcmp (name, pos+dcr_sget4(p, pos+12))) continue;\r\n\t\tdim[0] = dim[1] = dim[2] = 1;\r\n\t\tcp = pos + dcr_sget4(p, pos+16);\r\n\t\ttype = dcr_sget4(p, cp);\r\n\t\tif ((ndim = dcr_sget4(p, cp+4)) > 3) break;\r\n\t\tdp = pos + dcr_sget4(p, cp+8);\r\n\t\tfor (i=ndim; i--; ) {\r\n\t\t\tcp += 12;\r\n\t\t\tdim[i] = dcr_sget4(p, cp);\r\n\t\t}\r\n\t\tif ((dsize = (double) dim[0]*dim[1]*dim[2]) > p->meta_length/4) break;\r\n\t\tmat = (unsigned *) malloc ((size = (unsigned int)dsize) * 4);\r\n\t\tdcr_merror (p, mat, \"dcr_foveon_camf_matrix()\");\r\n\t\tfor (i=0; i < size; i++)\r\n\t\t\tif (type && type != 6)\r\n\t\t\t\tmat[i] = dcr_sget4(p, dp + i*4);\r\n\t\t\telse\r\n\t\t\t\tmat[i] = dcr_sget4(p, dp + i*2) & 0xffff;\r\n\t\t\treturn mat;\r\n\t}\r\n\tfprintf (stderr,_(\"%s: \\\"%s\\\" matrix not found!\\n\"), p->ifname, name);\r\n\treturn 0;\r\n}\r\n\r\nint DCR_CLASS dcr_foveon_fixed (DCRAW* p, void *ptr, int size, const char *name)\r\n{\r\n\tvoid *dp;\r\n\tunsigned dim[3];\r\n\r\n\tdp = dcr_foveon_camf_matrix (p,dim, name);\r\n\tif (!dp) return 0;\r\n\tmemcpy (ptr, dp, size*4);\r\n\tfree (dp);\r\n\treturn 1;\r\n}\r\n\r\nfloat DCR_CLASS dcr_foveon_avg (short *pix, int range[2], float cfilt)\r\n{\r\n\tint i;\r\n\tfloat val, min=FLT_MAX, max=-FLT_MAX, sum=0;\r\n\r\n\tfor (i=range[0]; i <= range[1]; i++) {\r\n\t\tsum += val = pix[i*4] + (pix[i*4]-pix[(i-1)*4]) * cfilt;\r\n\t\tif (min > val) min = val;\r\n\t\tif (max < val) max = val;\r\n\t}\r\n\tif (range[1] - range[0] == 1) return sum/2;\r\n\treturn (sum - min - max) / (range[1] - range[0] - 1);\r\n}\r\n\r\nshort * DCR_CLASS dcr_foveon_make_curve (DCRAW* p, double max, double mul, double filt)\r\n{\r\n\tshort *curve;\r\n\tunsigned i, size;\r\n\tdouble x;\r\n\r\n\tif (!filt) filt = 0.8;\r\n\tsize = (unsigned int)(4*M_PI*max / filt);\r\n\tif (size == UINT_MAX) size--;\r\n\tcurve = (short *) calloc (size+1, sizeof *curve);\r\n\tdcr_merror (p, p->curve, \"foveon_make_curve()\");\r\n\tp->curve[0] = size;\r\n\tfor (i=0; i < size; i++) {\r\n\t\tx = i*filt/max/4;\r\n\t\tp->curve[i+1] = (short)((cos(x)+1)/2 * tanh(i*filt/mul) * mul + 0.5);\r\n\t}\r\n\treturn curve;\r\n}\r\n\r\nvoid DCR_CLASS dcr_foveon_make_curves\r\n(DCRAW* p, short **curvep, float dq[3], float div[3], float filt)\r\n{\r\n\tdouble mul[3], max=0;\r\n\tint c;\r\n\r\n\tFORC3 mul[c] = dq[c]/div[c];\r\n\tFORC3 if (max < mul[c]) max = mul[c];\r\n\tFORC3 curvep[c] = dcr_foveon_make_curve (p,max, mul[c], filt);\r\n}\r\n\r\nint DCR_CLASS dcr_foveon_apply_curve (short *curve, int i)\r\n{\r\n\tif (abs(i) >= curve[0]) return 0;\r\n\treturn i < 0 ? -curve[1-i] : curve[1+i];\r\n}\r\n\r\n#define image4 ((short (*)[4]) p->image)\r\n\r\nvoid DCR_CLASS dcr_foveon_interpolate(DCRAW* p)\r\n{\r\n\tstatic const short hood[] = { -1,-1, -1,0, -1,1, 0,-1, 0,1, 1,-1, 1,0, 1,1 };\r\n\tshort *pix, prev[3], *curve[8], (*shrink)[3];\r\n\tfloat cfilt=0, ddft[3][3][2], ppm[3][3][3];\r\n\tfloat cam_xyz[3][3], correct[3][3], last[3][3], trans[3][3];\r\n\tfloat chroma_dq[3], color_dq[3], diag[3][3], div[3];\r\n\tfloat (*black)[3], (*sgain)[3], (*sgrow)[3];\r\n\tfloat fsum[3], val, frow, num;\r\n\tint row, col, c, i, j, diff, sgx, irow, sum, min, max, limit;\r\n\tint dscr[2][2], dstb[4], (*smrow[7])[3], total[4], ipix[3];\r\n\tint work[3][3], smlast, smred, smred_p=0, dev[3];\r\n\tint satlev[3], keep[4], active[4];\r\n\tunsigned dim[3], *badpix;\r\n\tdouble dsum=0, trsum[3];\r\n\tchar str[128];\r\n\tconst char* cp;\r\n\r\n\tif (p->opt.verbose)\r\n\t\tfprintf (stderr,_(\"Foveon interpolation...\\n\"));\r\n\r\n\tdcr_foveon_fixed (p, dscr, 4, \"DarkShieldColRange\");\r\n\tdcr_foveon_fixed (p, ppm[0][0], 27, \"PostPolyMatrix\");\r\n\tdcr_foveon_fixed (p, satlev, 3, \"SaturationLevel\");\r\n\tdcr_foveon_fixed (p, keep, 4, \"KeepImageArea\");\r\n\tdcr_foveon_fixed (p, active, 4, \"ActiveImageArea\");\r\n\tdcr_foveon_fixed (p, chroma_dq, 3, \"ChromaDQ\");\r\n\tdcr_foveon_fixed (p, color_dq, 3,\r\n\t\tdcr_foveon_camf_param (p, \"IncludeBlocks\", \"ColorDQ\") ?\r\n\t\t\"ColorDQ\" : \"ColorDQCamRGB\");\r\n\tif (dcr_foveon_camf_param (p, \"IncludeBlocks\", \"ColumnFilter\"))\r\n\t\tdcr_foveon_fixed (p, &cfilt, 1, \"ColumnFilter\");\r\n\r\n\tmemset (ddft, 0, sizeof ddft);\r\n\tif (!dcr_foveon_camf_param (p, \"IncludeBlocks\", \"DarkDrift\")\r\n\t\t|| !dcr_foveon_fixed (p, ddft[1][0], 12, \"DarkDrift\"))\r\n\t\tfor (i=0; i < 2; i++) {\r\n\t\t\tdcr_foveon_fixed (p, dstb, 4, i ? \"DarkShieldBottom\":\"DarkShieldTop\");\r\n\t\t\tfor (row = dstb[1]; row <= dstb[3]; row++)\r\n\t\t\t\tfor (col = dstb[0]; col <= dstb[2]; col++)\r\n\t\t\t\t\tFORC3 ddft[i+1][c][1] += (short) image4[row*p->width+col][c];\r\n\t\t\t\tFORC3 ddft[i+1][c][1] /= (dstb[3]-dstb[1]+1) * (dstb[2]-dstb[0]+1);\r\n\t\t}\r\n\r\n\tif (!(cp = dcr_foveon_camf_param (p, \"WhiteBalanceIlluminants\", p->model2)))\r\n\t{ fprintf (stderr,_(\"%s: Invalid p->white balance \\\"%s\\\"\\n\"), p->ifname, p->model2);\r\n\treturn; }\r\n\tdcr_foveon_fixed (p, cam_xyz, 9, cp);\r\n\tdcr_foveon_fixed (p, correct, 9,\r\n\t\tdcr_foveon_camf_param (p, \"WhiteBalanceCorrections\", p->model2));\r\n\tmemset (last, 0, sizeof last);\r\n\tfor (i=0; i < 3; i++)\r\n\t\tfor (j=0; j < 3; j++)\r\n\t\t\tFORC3 last[i][j] += correct[i][c] * cam_xyz[c][j];\r\n\r\n#define LAST(x,y) last[(i+x)%3][(c+y)%3]\r\n\tfor (i=0; i < 3; i++)\r\n\t\tFORC3 diag[c][i] = LAST(1,1)*LAST(2,2) - LAST(1,2)*LAST(2,1);\r\n#undef LAST\r\n\tFORC3 div[c] = diag[c][0]*0.3127f + diag[c][1]*0.329f + diag[c][2]*0.3583f;\r\n\tsprintf (str, \"%sRGBNeutral\", p->model2);\r\n\tif (dcr_foveon_camf_param (p, \"IncludeBlocks\", str))\r\n\t\tdcr_foveon_fixed (p, div, 3, str);\r\n\tnum = 0;\r\n\tFORC3 if (num < div[c]) num = div[c];\r\n\tFORC3 div[c] /= num;\r\n\r\n\tmemset (trans, 0, sizeof trans);\r\n\tfor (i=0; i < 3; i++)\r\n\t\tfor (j=0; j < 3; j++)\r\n\t\t\tFORC3 trans[i][j] += p->rgb_cam[i][c] * last[c][j] * div[j];\r\n\tFORC3 trsum[c] = trans[c][0] + trans[c][1] + trans[c][2];\r\n\tdsum = (6*trsum[0] + 11*trsum[1] + 3*trsum[2]) / 20;\r\n\tfor (i=0; i < 3; i++)\r\n\t\tFORC3 last[i][c] = (float)(trans[i][c] * dsum / trsum[i]);\r\n\tmemset (trans, 0, sizeof trans);\r\n\tfor (i=0; i < 3; i++)\r\n\t\tfor (j=0; j < 3; j++)\r\n\t\t\tFORC3 trans[i][j] += (i==c ? 32 : -1) * last[c][j] / 30;\r\n\r\n\tdcr_foveon_make_curves (p, curve, color_dq, div, cfilt);\r\n\tFORC3 chroma_dq[c] /= 3;\r\n\tdcr_foveon_make_curves (p, curve+3, chroma_dq, div, cfilt);\r\n\tFORC3 dsum += chroma_dq[c] / div[c];\r\n\tcurve[6] = dcr_foveon_make_curve (p, dsum, dsum, cfilt);\r\n\tcurve[7] = dcr_foveon_make_curve (p, dsum*2, dsum*2, cfilt);\r\n\r\n\tsgain = (float (*)[3]) dcr_foveon_camf_matrix (p, dim, \"SpatialGain\");\r\n\tif (!sgain) return;\r\n\tsgrow = (float (*)[3]) calloc (dim[1], sizeof *sgrow);\r\n\tsgx = (p->width + dim[1]-2) / (dim[1]-1);\r\n\r\n\tblack = (float (*)[3]) calloc (p->height, sizeof *black);\r\n\tfor (row=0; row < p->height; row++) {\r\n\t\tfor (i=0; i < 6; i++)\r\n\t\t\tddft[0][0][i] = (float)(ddft[1][0][i] +\r\n\t\t\trow / (p->height-1.0) * (ddft[2][0][i] - ddft[1][0][i]));\r\n\t\tFORC3 black[row][c] =\r\n\t\t\t( dcr_foveon_avg (p->image[row*p->width]+c, dscr[0], cfilt) +\r\n\t\t\tdcr_foveon_avg (p->image[row*p->width]+c, dscr[1], cfilt) * 3\r\n\t\t\t- ddft[0][c][0] ) / 4 - ddft[0][c][1];\r\n\t}\r\n\tmemcpy (black, black+8, sizeof *black*8);\r\n\tmemcpy (black+p->height-11, black+p->height-22, 11*sizeof *black);\r\n\tmemcpy (last, black, sizeof last);\r\n\r\n\tfor (row=1; row < p->height-1; row++) {\r\n\t\tFORC3 if (last[1][c] > last[0][c]) {\r\n\t\t\tif (last[1][c] > last[2][c])\r\n\t\t\t\tblack[row][c] = (last[0][c] > last[2][c]) ? last[0][c]:last[2][c];\r\n\t\t} else\r\n\t\t\tif (last[1][c] < last[2][c])\r\n\t\t\t\tblack[row][c] = (last[0][c] < last[2][c]) ? last[0][c]:last[2][c];\r\n\t\t\tmemmove (last, last+1, 2*sizeof last[0]);\r\n\t\t\tmemcpy (last[2], black[row+1], sizeof last[2]);\r\n\t}\r\n\tFORC3 black[row][c] = (last[0][c] + last[1][c])/2;\r\n\tFORC3 black[0][c] = (black[1][c] + black[3][c])/2;\r\n\r\n\tval = (float)(1 - exp(-1/24.0));\r\n\tmemcpy (fsum, black, sizeof fsum);\r\n\tfor (row=1; row < p->height; row++)\r\n\t\tFORC3 fsum[c] += black[row][c] =\r\n\t\t(black[row][c] - black[row-1][c])*val + black[row-1][c];\r\n\tmemcpy (last[0], black[p->height-1], sizeof last[0]);\r\n\tFORC3 fsum[c] /= p->height;\r\n\tfor (row = p->height; row--; )\r\n\t\tFORC3 last[0][c] = black[row][c] =\r\n\t\t(black[row][c] - fsum[c] - last[0][c])*val + last[0][c];\r\n\r\n\tmemset (total, 0, sizeof total);\r\n\tfor (row=2; row < p->height; row+=4)\r\n\t\tfor (col=2; col < p->width; col+=4) {\r\n\t\t\tFORC3 total[c] += (short) p->image[row*p->width+col][c];\r\n\t\t\ttotal[3]++;\r\n\t\t}\r\n\tfor (row=0; row < p->height; row++)\r\n\t\tFORC3 black[row][c] += fsum[c]/2 + total[c]/(total[3]*100.0f);\r\n\r\n\tfor (row=0; row < p->height; row++) {\r\n\t\tfor (i=0; i < 6; i++)\r\n\t\t\tddft[0][0][i] = (float)(ddft[1][0][i] +\r\n\t\t\trow / (p->height-1.0) * (ddft[2][0][i] - ddft[1][0][i]));\r\n\t\tpix = p->image[row*p->width];\r\n\t\tmemcpy (prev, pix, sizeof prev);\r\n\t\tfrow = (float)(row / (p->height-1.0) * (dim[2]-1));\r\n\t\tif ((irow = (int)frow) == (int)(dim[2]-1)) irow--;\r\n\t\tfrow -= irow;\r\n\t\tfor (i=0; i < (int)dim[1]; i++)\r\n\t\t\tFORC3 sgrow[i][c] = sgain[ irow   *dim[1]+i][c] * (1-frow) +\r\n\t\t\tsgain[(irow+1)*dim[1]+i][c] *    frow;\r\n\t\tfor (col=0; col < p->width; col++) {\r\n\t\t\tFORC3 {\r\n\t\t\t\tdiff = pix[c] - prev[c];\r\n\t\t\t\tprev[c] = pix[c];\r\n\t\t\t\tipix[c] = (int)( pix[c] + floor ((diff + (diff*diff >> 14)) * cfilt\r\n\t\t\t\t\t- ddft[0][c][1] - ddft[0][c][0] * ((float) col/p->width - 0.5)\r\n\t\t\t\t\t- black[row][c] ));\r\n\t\t\t}\r\n\t\t\tFORC3 {\r\n\t\t\t\twork[0][c] = ipix[c] * ipix[c] >> 14;\r\n\t\t\t\twork[2][c] = ipix[c] * work[0][c] >> 14;\r\n\t\t\t\twork[1][2-c] = ipix[(c+1) % 3] * ipix[(c+2) % 3] >> 14;\r\n\t\t\t}\r\n\t\t\tFORC3 {\r\n\t\t\t\tfor (val=0, i=0; i < 3; i++)\r\n\t\t\t\t\tfor (  j=0; j < 3; j++)\r\n\t\t\t\t\t\tval += ppm[c][i][j] * work[i][j];\r\n\t\t\t\t\tipix[c] = (int)(floor ((ipix[c] + floor(val)) *\r\n\t\t\t\t\t\t( sgrow[col/sgx  ][c] * (sgx - col%sgx) +\r\n\t\t\t\t\t\tsgrow[col/sgx+1][c] * (col%sgx) ) / sgx / div[c]));\r\n\t\t\t\t\tif (ipix[c] > 32000) ipix[c] = 32000;\r\n\t\t\t\t\tpix[c] = ipix[c];\r\n\t\t\t}\r\n\t\t\tpix += 4;\r\n\t\t}\r\n\t}\r\n\tfree (black);\r\n\tfree (sgrow);\r\n\tfree (sgain);\r\n\r\n\tif ((badpix = (unsigned int *) dcr_foveon_camf_matrix (p, dim, \"BadPixels\"))) {\r\n\t\tfor (i=0; i < (int)dim[0]; i++) {\r\n\t\t\tcol = (badpix[i] >> 8 & 0xfff) - keep[0];\r\n\t\t\trow = (badpix[i] >> 20       ) - keep[1];\r\n\t\t\tif ((int)(row-1) > p->height-3 || (int)(col-1) > p->width-3)\r\n\t\t\t\tcontinue;\r\n\t\t\tmemset (fsum, 0, sizeof fsum);\r\n\t\t\tfor (sum=j=0; j < 8; j++)\r\n\t\t\t\tif (badpix[i] & (1 << j)) {\r\n\t\t\t\t\tFORC3 fsum[c] += (short)\r\n\t\t\t\t\t\tp->image[(row+hood[j*2])*p->width+col+hood[j*2+1]][c];\r\n\t\t\t\t\tsum++;\r\n\t\t\t\t}\r\n\t\t\t\tif (sum) FORC3 p->image[row*p->width+col][c] = (unsigned short)(fsum[c]/sum);\r\n\t\t}\r\n\t\tfree (badpix);\r\n\t}\r\n\r\n\t/* Array for 5x5 Gaussian averaging of red values */\r\n\tsmrow[6] = (int (*)[3]) calloc (p->width*5, sizeof **smrow);\r\n\tdcr_merror (p, smrow[6], \"foveon_interpolate()\");\r\n\tfor (i=0; i < 5; i++)\r\n\t\tsmrow[i] = smrow[6] + i*p->width;\r\n\r\n\t/* Sharpen the reds against these Gaussian averages */\r\n\tfor (smlast=-1, row=2; row < p->height-2; row++) {\r\n\t\twhile (smlast < row+2) {\r\n\t\t\tfor (i=0; i < 6; i++)\r\n\t\t\t\tsmrow[(i+5) % 6] = smrow[i];\r\n\t\t\tpix = p->image[++smlast*p->width+2];\r\n\t\t\tfor (col=2; col < p->width-2; col++) {\r\n\t\t\t\tsmrow[4][col][0] =\r\n\t\t\t\t\t(pix[0]*6 + (pix[-4]+pix[4])*4 + pix[-8]+pix[8] + 8) >> 4;\r\n\t\t\t\tpix += 4;\r\n\t\t\t}\r\n\t\t}\r\n\t\tpix = p->image[row*p->width+2];\r\n\t\tfor (col=2; col < p->width-2; col++) {\r\n\t\t\tsmred = ( 6 *  smrow[2][col][0]\r\n\t\t\t\t+ 4 * (smrow[1][col][0] + smrow[3][col][0])\r\n\t\t\t\t+      smrow[0][col][0] + smrow[4][col][0] + 8 ) >> 4;\r\n\t\t\tif (col == 2)\r\n\t\t\t\tsmred_p = smred;\r\n\t\t\ti = pix[0] + ((pix[0] - ((smred*7 + smred_p) >> 3)) >> 3);\r\n\t\t\tif (i > 32000) i = 32000;\r\n\t\t\tpix[0] = i;\r\n\t\t\tsmred_p = smred;\r\n\t\t\tpix += 4;\r\n\t\t}\r\n\t}\r\n\r\n\t/* Adjust the brighter pixels for better linearity */\r\n\tmin = 0xffff;\r\n\tFORC3 {\r\n\t\ti = (int)(satlev[c] / div[c]);\r\n\t\tif (min > i) min = i;\r\n\t}\r\n\tlimit = min * 9 >> 4;\r\n\tfor (pix=p->image[0]; pix < p->image[p->height*p->width]; pix+=4) {\r\n\t\tif (pix[0] <= limit || pix[1] <= limit || pix[2] <= limit)\r\n\t\t\tcontinue;\r\n\t\tmin = max = pix[0];\r\n\t\tfor (c=1; c < 3; c++) {\r\n\t\t\tif (min > pix[c]) min = pix[c];\r\n\t\t\tif (max < pix[c]) max = pix[c];\r\n\t\t}\r\n\t\tif (min >= limit*2) {\r\n\t\t\tpix[0] = pix[1] = pix[2] = max;\r\n\t\t} else {\r\n\t\t\ti = 0x4000 - ((min - limit) << 14) / limit;\r\n\t\t\ti = 0x4000 - (i*i >> 14);\r\n\t\t\ti = i*i >> 14;\r\n\t\t\tFORC3 pix[c] += (max - pix[c]) * i >> 14;\r\n\t\t}\r\n\t}\r\n\t/*\r\n\tBecause photons that miss one detector often hit another,\r\n\tthe sum R+G+B is much less noisy than the individual p->colors.\r\n\tSo smooth the hues without smoothing the total.\r\n\t*/\r\n\tfor (smlast=-1, row=2; row < p->height-2; row++) {\r\n\t\twhile (smlast < row+2) {\r\n\t\t\tfor (i=0; i < 6; i++)\r\n\t\t\t\tsmrow[(i+5) % 6] = smrow[i];\r\n\t\t\tpix = p->image[++smlast*p->width+2];\r\n\t\t\tfor (col=2; col < p->width-2; col++) {\r\n\t\t\t\tFORC3 smrow[4][col][c] = (pix[c-4]+2*pix[c]+pix[c+4]+2) >> 2;\r\n\t\t\t\tpix += 4;\r\n\t\t\t}\r\n\t\t}\r\n\t\tpix = p->image[row*p->width+2];\r\n\t\tfor (col=2; col < p->width-2; col++) {\r\n\t\t\tFORC3 dev[c] = -dcr_foveon_apply_curve (curve[7], pix[c] -\r\n\t\t\t\t((smrow[1][col][c] + 2*smrow[2][col][c] + smrow[3][col][c]) >> 2));\r\n\t\t\tsum = (dev[0] + dev[1] + dev[2]) >> 3;\r\n\t\t\tFORC3 pix[c] += dev[c] - sum;\r\n\t\t\tpix += 4;\r\n\t\t}\r\n\t}\r\n\tfor (smlast=-1, row=2; row < p->height-2; row++) {\r\n\t\twhile (smlast < row+2) {\r\n\t\t\tfor (i=0; i < 6; i++)\r\n\t\t\t\tsmrow[(i+5) % 6] = smrow[i];\r\n\t\t\tpix = p->image[++smlast*p->width+2];\r\n\t\t\tfor (col=2; col < p->width-2; col++) {\r\n\t\t\t\tFORC3 smrow[4][col][c] =\r\n\t\t\t\t\t(pix[c-8]+pix[c-4]+pix[c]+pix[c+4]+pix[c+8]+2) >> 2;\r\n\t\t\t\tpix += 4;\r\n\t\t\t}\r\n\t\t}\r\n\t\tpix = p->image[row*p->width+2];\r\n\t\tfor (col=2; col < p->width-2; col++) {\r\n\t\t\tfor (total[3]=375, sum=60, c=0; c < 3; c++) {\r\n\t\t\t\tfor (total[c]=i=0; i < 5; i++)\r\n\t\t\t\t\ttotal[c] += smrow[i][col][c];\r\n\t\t\t\ttotal[3] += total[c];\r\n\t\t\t\tsum += pix[c];\r\n\t\t\t}\r\n\t\t\tif (sum < 0) sum = 0;\r\n\t\t\tj = total[3] > 375 ? (sum << 16) / total[3] : sum * 174;\r\n\t\t\tFORC3 pix[c] += dcr_foveon_apply_curve (curve[6],\r\n\t\t\t\t((j*total[c] + 0x8000) >> 16) - pix[c]);\r\n\t\t\tpix += 4;\r\n\t\t}\r\n\t}\r\n\r\n\t/* Transform the image to a different colorspace */\r\n\tfor (pix=p->image[0]; pix < p->image[p->height*p->width]; pix+=4) {\r\n\t\tFORC3 pix[c] -= dcr_foveon_apply_curve (curve[c], pix[c]);\r\n\t\tsum = (pix[0]+pix[1]+pix[1]+pix[2]) >> 2;\r\n\t\tFORC3 pix[c] -= dcr_foveon_apply_curve (curve[c], pix[c]-sum);\r\n\t\tFORC3 {\r\n\t\t\tfor (dsum=i=0; i < 3; i++)\r\n\t\t\t\tdsum += trans[c][i] * pix[i];\r\n\t\t\tif (dsum < 0)  dsum = 0;\r\n\t\t\tif (dsum > 24000) dsum = 24000;\r\n\t\t\tipix[c] = (int)(dsum + 0.5);\r\n\t\t}\r\n\t\tFORC3 pix[c] = ipix[c];\r\n\t}\r\n\r\n\t/* Smooth the image bottom-to-top and save at 1/4 scale */\r\n\tshrink = (short (*)[3]) calloc ((p->width/4) * (p->height/4), sizeof *shrink);\r\n\tdcr_merror (p, shrink, \"foveon_interpolate()\");\r\n\tfor (row = p->height/4; row--; )\r\n\t\tfor (col=0; col < p->width/4; col++) {\r\n\t\t\tipix[0] = ipix[1] = ipix[2] = 0;\r\n\t\t\tfor (i=0; i < 4; i++)\r\n\t\t\t\tfor (j=0; j < 4; j++)\r\n\t\t\t\t\tFORC3 ipix[c] += p->image[(row*4+i)*p->width+col*4+j][c];\r\n\t\t\t\tFORC3\r\n\t\t\t\t\tif (row+2 > p->height/4)\r\n\t\t\t\t\t\tshrink[row*(p->width/4)+col][c] = ipix[c] >> 4;\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tshrink[row*(p->width/4)+col][c] =\r\n\t\t\t\t\t\t(shrink[(row+1)*(p->width/4)+col][c]*1840 + ipix[c]*141 + 2048) >> 12;\r\n\t\t}\r\n\t/* From the 1/4-scale image, smooth right-to-left */\r\n\tfor (row=0; row < (p->height & ~3); row++) {\r\n\t\tipix[0] = ipix[1] = ipix[2] = 0;\r\n\t\tif ((row & 3) == 0)\r\n\t\t\tfor (col = p->width & ~3 ; col--; )\r\n\t\t\t\tFORC3 smrow[0][col][c] = ipix[c] =\r\n\t\t\t\t(shrink[(row/4)*(p->width/4)+col/4][c]*1485 + ipix[c]*6707 + 4096) >> 13;\r\n\r\n\t\t/* Then smooth left-to-right */\r\n\t\tipix[0] = ipix[1] = ipix[2] = 0;\r\n\t\tfor (col=0; col < (p->width & ~3); col++)\r\n\t\t\tFORC3 smrow[1][col][c] = ipix[c] =\r\n\t\t\t(smrow[0][col][c]*1485 + ipix[c]*6707 + 4096) >> 13;\r\n\r\n\t\t/* Smooth top-to-bottom */\r\n\t\tif (row == 0)\r\n\t\t\tmemcpy (smrow[2], smrow[1], sizeof **smrow * p->width);\r\n\t\telse\r\n\t\t\tfor (col=0; col < (p->width & ~3); col++)\r\n\t\t\t\tFORC3 smrow[2][col][c] =\r\n\t\t\t\t(smrow[2][col][c]*6707 + smrow[1][col][c]*1485 + 4096) >> 13;\r\n\r\n\t\t\t/* Adjust the chroma toward the smooth values */\r\n\t\t\tfor (col=0; col < (p->width & ~3); col++) {\r\n\t\t\t\tfor (i=j=30, c=0; c < 3; c++) {\r\n\t\t\t\t\ti += smrow[2][col][c];\r\n\t\t\t\t\tj += p->image[row*p->width+col][c];\r\n\t\t\t\t}\r\n\t\t\t\tj = (j << 16) / i;\r\n\t\t\t\tfor (sum=c=0; c < 3; c++) {\r\n\t\t\t\t\tipix[c] = dcr_foveon_apply_curve (curve[c+3],\r\n\t\t\t\t\t\t((smrow[2][col][c] * j + 0x8000) >> 16) - p->image[row*p->width+col][c]);\r\n\t\t\t\t\tsum += ipix[c];\r\n\t\t\t\t}\r\n\t\t\t\tsum >>= 3;\r\n\t\t\t\tFORC3 {\r\n\t\t\t\t\ti = p->image[row*p->width+col][c] + ipix[c] - sum;\r\n\t\t\t\t\tif (i < 0) i = 0;\r\n\t\t\t\t\tp->image[row*p->width+col][c] = i;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t}\r\n\tfree (shrink);\r\n\tfree (smrow[6]);\r\n\tfor (i=0; i < 8; i++)\r\n\t\tfree (curve[i]);\r\n\r\n\t/* Trim off the black border */\r\n\tactive[1] -= keep[1];\r\n\tactive[3] -= 2;\r\n\ti = active[2] - active[0];\r\n\tfor (row=0; row < active[3]-active[1]; row++)\r\n\t\tmemcpy (p->image[row*i], p->image[(row+active[1])*p->width+active[0]],\r\n\t\ti * sizeof *p->image);\r\n\tp->width = i;\r\n\tp->height = row;\r\n}\r\n//#undef image\r\n#endif //RESTRICTED\r\n/* RESTRICTED code ends here */\r\n\r\n/*\r\nSeach from the current directory up to the root looking for\r\na \".badpixels\" file, and fix those pixels now.\r\n*/\r\nvoid DCR_CLASS dcr_bad_pixels(DCRAW* p, char *fname)\r\n{\r\n\tFILE *fp=0;\r\n\tchar *cp, line[128];\r\n\tint len, time, row, col, r, c, rad, tot, n, fixed=0;\r\n\r\n\tif (!p->filters) return;\r\n\tif (fname)\r\n\t\tfp = fopen (fname, \"r\");\r\n\telse {\r\n\t\tfor (len=32 ; ; len *= 2) {\r\n\t\t\tfname = (char *) malloc (len);\r\n\t\t\tif (!fname) return;\r\n\t\t\tif (_getcwd (fname, len-16)) break;\r\n\t\t\tfree (fname);\r\n\t\t\tif (errno != ERANGE) return;\r\n\t\t}\r\n#if defined(WIN32) || defined(DJGPP)\r\n\t\tif (fname[1] == ':')\r\n\t\t\tmemmove (fname, fname+2, len-2);\r\n\t\tfor (cp=fname; *cp; cp++)\r\n\t\t\tif (*cp == '\\\\') *cp = '/';\r\n#endif\r\n\t\tcp = fname + strlen(fname);\r\n\t\tif (cp[-1] == '/') cp--;\r\n\t\twhile (*fname == '/') {\r\n\t\t\tstrcpy (cp, \"/.badpixels\");\r\n\t\t\tif ((fp = fopen (fname, \"r\"))) break;\r\n\t\t\tif (cp == fname) break;\r\n\t\t\twhile (*--cp != '/');\r\n\t\t}\r\n\t\tfree (fname);\r\n\t}\r\n\tif (!fp) return;\r\n\twhile (fgets (line, 128, fp)) {\r\n\t\tcp = strchr (line, '#');\r\n\t\tif (cp) *cp = 0;\r\n\t\tif (sscanf (line, \"%d %d %d\", &col, &row, &time) != 3) continue;\r\n\t\tif ((unsigned) col >= p->width || (unsigned) row >= p->height) continue;\r\n\t\tif (time > p->timestamp) continue;\r\n\t\tfor (tot=n=0, rad=1; rad < 3 && n==0; rad++)\r\n\t\t\tfor (r = row-rad; r <= row+rad; r++)\r\n\t\t\t\tfor (c = col-rad; c <= col+rad; c++)\r\n\t\t\t\t\tif ((unsigned) r < p->height && (unsigned) c < p->width &&\r\n\t\t\t\t\t\t(r != row || c != col) && dcr_fc(p,r,c) == dcr_fc(p,row,col)) {\r\n\t\t\t\t\t\ttot += BAYER2(r,c);\r\n\t\t\t\t\t\tn++;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tBAYER2(row,col) = tot/n;\r\n\t\t\t\t\tif (p->opt.verbose) {\r\n\t\t\t\t\t\tif (!fixed++)\r\n\t\t\t\t\t\t\tfprintf (stderr,_(\"Fixed dead pixels at:\"));\r\n\t\t\t\t\t\tfprintf (stderr, \" %d,%d\", col, row);\r\n\t\t\t\t\t}\r\n\t}\r\n\tif (fixed) fputc ('\\n', stderr);\r\n\tfclose (fp);\r\n}\r\n\r\nvoid DCR_CLASS dcr_subtract (DCRAW* p,char *fname)\r\n{\r\n\tFILE *fp;\r\n\tint dim[3]={0,0,0}, comment=0, number=0, error=0, nd=0, c, row, col;\r\n\tushort *pixel;\r\n\r\n\tif (!(fp = fopen (fname, \"rb\"))) {\r\n\t\tperror (fname);  return;\r\n\t}\r\n\tif (fgetc(fp) != 'P' || fgetc(fp) != '5') error = 1;\r\n\twhile (!error && nd < 3 && (c = fgetc(fp)) != EOF) {\r\n\t\tif (c == '#')  comment = 1;\r\n\t\tif (c == '\\n') comment = 0;\r\n\t\tif (comment) continue;\r\n\t\tif (isdigit(c)) number = 1;\r\n\t\tif (number) {\r\n\t\t\tif (isdigit(c)) dim[nd] = dim[nd]*10 + c -'0';\r\n\t\t\telse if (isspace(c)) {\r\n\t\t\t\tnumber = 0;  nd++;\r\n\t\t\t} else error = 1;\r\n\t\t}\r\n\t}\r\n\tif (error || nd < 3) {\r\n\t\tfprintf (stderr,_(\"%s is not a valid PGM file!\\n\"), fname);\r\n\t\tfclose (fp);  return;\r\n\t} else if (dim[0] != p->width || dim[1] != p->height || dim[2] != 65535) {\r\n\t\tfprintf (stderr,_(\"%s has the wrong dimensions!\\n\"), fname);\r\n\t\tfclose (fp);  return;\r\n\t}\r\n\tpixel = (ushort *) calloc (p->width, sizeof *pixel);\r\n\tdcr_merror (p, pixel, \"subtract()\");\r\n\tfor (row=0; row < p->height; row++) {\r\n\t\tfread (pixel, 2, p->width, fp);\r\n\t\tfor (col=0; col < p->width; col++)\r\n\t\t\tBAYER(row,col) = MAX (BAYER(row,col) - ntohs(pixel[col]), 0);\r\n\t}\r\n\tfclose (fp);\r\n\tfree (pixel);\r\n\tp->black = 0;\r\n}\r\n\r\nvoid DCR_CLASS dcr_pseudoinverse (double (*in)[3], double (*out)[3], int size)\r\n{\r\n\tdouble work[3][6], num;\r\n\tint i, j, k;\r\n\r\n\tfor (i=0; i < 3; i++) {\r\n\t\tfor (j=0; j < 6; j++)\r\n\t\t\twork[i][j] = j == i+3;\r\n\t\tfor (j=0; j < 3; j++)\r\n\t\t\tfor (k=0; k < size; k++)\r\n\t\t\t\twork[i][j] += in[k][i] * in[k][j];\r\n\t}\r\n\tfor (i=0; i < 3; i++) {\r\n\t\tnum = work[i][i];\r\n\t\tfor (j=0; j < 6; j++)\r\n\t\t\twork[i][j] /= num;\r\n\t\tfor (k=0; k < 3; k++) {\r\n\t\t\tif (k==i) continue;\r\n\t\t\tnum = work[k][i];\r\n\t\t\tfor (j=0; j < 6; j++)\r\n\t\t\t\twork[k][j] -= work[i][j] * num;\r\n\t\t}\r\n\t}\r\n\tfor (i=0; i < size; i++)\r\n\t\tfor (j=0; j < 3; j++)\r\n\t\t\tfor (out[i][j]=k=0; k < 3; k++)\r\n\t\t\t\tout[i][j] += work[j][k+3] * in[i][k];\r\n}\r\n\r\nvoid DCR_CLASS dcr_cam_xyz_coeff (DCRAW* p, double cam_xyz[4][3])\r\n{\r\n\tdouble cam_rgb[4][3], inverse[4][3], num;\r\n\tint i, j, k;\r\n    int max_colors = p->colors;\r\n    if (max_colors > 4) max_colors = 4;\r\n    for (i=0; i < max_colors; i++)\t\t/* Multiply out XYZ colorspace */\r\n\t\tfor (j=0; j < 3; j++)\r\n\t\t\tfor (cam_rgb[i][j] = k=0; k < 3; k++)\r\n\t\t\t\tcam_rgb[i][j] += cam_xyz[i][k] * xyz_rgb[k][j];\r\n\r\n    for (i=0; i < max_colors; i++) {\t\t/* Normalize cam_rgb so that */\r\n\t\tfor (num=j=0; j < 3; j++)\t\t/* cam_rgb * (1,1,1) is (1,1,1,1) */\r\n\t\t\tnum += cam_rgb[i][j];\r\n\t\tfor (j=0; j < 3; j++)\r\n\t\t\tcam_rgb[i][j] /= num;\r\n\t\tp->pre_mul[i] = 1 / (float)num;\r\n\t}\r\n    dcr_pseudoinverse (cam_rgb, inverse, max_colors);\r\n\tfor (p->raw_color = i=0; i < 3; i++)\r\n\t\tfor (j=0; j < p->colors; j++)\r\n\t\t\tp->rgb_cam[i][j] = (float)inverse[j][i];\r\n}\r\n\r\n#ifdef COLORCHECK\r\nvoid DCR_CLASS dcr_colorcheck(DCRAW* p)\r\n{\r\n#define NSQ 24\r\n\t// Coordinates of the GretagMacbeth ColorChecker squares\r\n\t// p->width, p->height, 1st_column, 1st_row\r\n\tstatic const int cut[NSQ][4] = {\r\n\t\t{ 241, 231, 234, 274 },\r\n\t\t{ 251, 235, 534, 274 },\r\n\t\t{ 255, 239, 838, 272 },\r\n\t\t{ 255, 240, 1146, 274 },\r\n\t\t{ 251, 237, 1452, 278 },\r\n\t\t{ 243, 238, 1758, 288 },\r\n\t\t{ 253, 253, 218, 558 },\r\n\t\t{ 255, 249, 524, 562 },\r\n\t\t{ 261, 253, 830, 562 },\r\n\t\t{ 260, 255, 1144, 564 },\r\n\t\t{ 261, 255, 1450, 566 },\r\n\t\t{ 247, 247, 1764, 576 },\r\n\t\t{ 255, 251, 212, 862 },\r\n\t\t{ 259, 259, 518, 862 },\r\n\t\t{ 263, 261, 826, 864 },\r\n\t\t{ 265, 263, 1138, 866 },\r\n\t\t{ 265, 257, 1450, 872 },\r\n\t\t{ 257, 255, 1762, 874 },\r\n\t\t{ 257, 253, 212, 1164 },\r\n\t\t{ 262, 251, 516, 1172 },\r\n\t\t{ 263, 257, 826, 1172 },\r\n\t\t{ 263, 255, 1136, 1176 },\r\n\t\t{ 255, 252, 1452, 1182 },\r\n\t\t{ 257, 253, 1760, 1180 } };\r\n\t// ColorChecker Chart under 6500-kelvin illumination\r\n\tstatic const double gmb_xyY[NSQ][3] = {\r\n\t\t{ 0.400, 0.350, 10.1 },\t\t// Dark Skin\r\n\t\t{ 0.377, 0.345, 35.8 },\t\t// Light Skin\r\n\t\t{ 0.247, 0.251, 19.3 },\t\t// Blue Sky\r\n\t\t{ 0.337, 0.422, 13.3 },\t\t// Foliage\r\n\t\t{ 0.265, 0.240, 24.3 },\t\t// Blue Flower\r\n\t\t{ 0.261, 0.343, 43.1 },\t\t// Bluish Green\r\n\t\t{ 0.506, 0.407, 30.1 },\t\t// Orange\r\n\t\t{ 0.211, 0.175, 12.0 },\t\t// Purplish Blue\r\n\t\t{ 0.453, 0.306, 19.8 },\t\t// Moderate Red\r\n\t\t{ 0.285, 0.202, 6.6 },\t\t// Purple\r\n\t\t{ 0.380, 0.489, 44.3 },\t\t// Yellow Green\r\n\t\t{ 0.473, 0.438, 43.1 },\t\t// Orange Yellow\r\n\t\t{ 0.187, 0.129, 6.1 },\t\t// Blue\r\n\t\t{ 0.305, 0.478, 23.4 },\t\t// Green\r\n\t\t{ 0.539, 0.313, 12.0 },\t\t// Red\r\n\t\t{ 0.448, 0.470, 59.1 },\t\t// Yellow\r\n\t\t{ 0.364, 0.233, 19.8 },\t\t// Magenta\r\n\t\t{ 0.196, 0.252, 19.8 },\t\t// Cyan\r\n\t\t{ 0.310, 0.316, 90.0 },\t\t// White\r\n\t\t{ 0.310, 0.316, 59.1 },\t\t// Neutral 8\r\n\t\t{ 0.310, 0.316, 36.2 },\t\t// Neutral 6.5\r\n\t\t{ 0.310, 0.316, 19.8 },\t\t// Neutral 5\r\n\t\t{ 0.310, 0.316, 9.0 },\t\t// Neutral 3.5\r\n\t\t{ 0.310, 0.316, 3.1 } };\t\t// Black\r\n\tdouble gmb_cam[NSQ][4], gmb_xyz[NSQ][3];\r\n\tdouble inverse[NSQ][3], cam_xyz[4][3], num;\r\n\tint c, i, j, k, sq, row, col, count[4];\r\n\r\n\tmemset (gmb_cam, 0, sizeof gmb_cam);\r\n\tfor (sq=0; sq < NSQ; sq++) {\r\n\t\tFORCC(p) count[c] = 0;\r\n\t\tfor   (row=cut[sq][3]; row < cut[sq][3]+cut[sq][1]; row++)\r\n\t\t\tfor (col=cut[sq][2]; col < cut[sq][2]+cut[sq][0]; col++) {\r\n\t\t\t\tc = FC(row,col);\r\n\t\t\t\tif (c >= p->colors) c -= 2;\r\n\t\t\t\tgmb_cam[sq][c] += BAYER(row,col);\r\n\t\t\t\tcount[c]++;\r\n\t\t\t}\r\n\t\t\tFORCC(p) gmb_cam[sq][c] = gmb_cam[sq][c]/count[c] - p->black;\r\n\t\t\tgmb_xyz[sq][0] = gmb_xyY[sq][2] * gmb_xyY[sq][0] / gmb_xyY[sq][1];\r\n\t\t\tgmb_xyz[sq][1] = gmb_xyY[sq][2];\r\n\t\t\tgmb_xyz[sq][2] = gmb_xyY[sq][2] *\r\n\t\t\t\t(1 - gmb_xyY[sq][0] - gmb_xyY[sq][1]) / gmb_xyY[sq][1];\r\n\t}\r\n\tdcr_pseudoinverse (gmb_xyz, inverse, NSQ);\r\n\tfor (i=0; i < p->colors; i++)\r\n\t\tfor (j=0; j < 3; j++)\r\n\t\t\tfor (cam_xyz[i][j] = k=0; k < NSQ; k++)\r\n\t\t\t\tcam_xyz[i][j] += gmb_cam[k][i] * inverse[k][j];\r\n\tdcr_cam_xyz_coeff (p, cam_xyz);\r\n\tif (p->opt.verbose) {\r\n\t\tprintf (\"    { \\\"%s %s\\\", %d,\\n\\t{\", p->make, p->model, p->black);\r\n\t\tnum = 10000 / (cam_xyz[1][0] + cam_xyz[1][1] + cam_xyz[1][2]);\r\n\t\tFORCC(p) for (j=0; j < 3; j++)\r\n\t\t\tprintf (\"%c%d\", (c | j) ? ',':' ', (int) (cam_xyz[c][j] * num + 0.5));\r\n\t\tputs (\" } },\");\r\n\t}\r\n#undef NSQ\r\n}\r\n#endif\r\n\r\nvoid DCR_CLASS dcr_hat_transform (float *temp, float *base, int st, int size, int sc)\r\n{\r\n\tint i;\r\n\tfor (i=0; i < sc; i++)\r\n\t\ttemp[i] = 2*base[st*i] + base[st*(sc-i)] + base[st*(i+sc)];\r\n\tfor (; i+sc < size; i++)\r\n\t\ttemp[i] = 2*base[st*i] + base[st*(i-sc)] + base[st*(i+sc)];\r\n\tfor (; i < size; i++)\r\n\t\ttemp[i] = 2*base[st*i] + base[st*(i-sc)] + base[st*(2*size-2-(i+sc))];\r\n}\r\n\r\nvoid DCR_CLASS dcr_wavelet_denoise(DCRAW* p)\r\n{\r\n\tfloat *fimg=0, *temp, thold, mul[2], avg, diff;\r\n\tint scale=1, size, lev, hpass, lpass, row, col, nc, c, i, wlast;\r\n\tushort *window[4];\r\n\tstatic const float noise[] =\r\n\t{ 0.8002f,0.2735f,0.1202f,0.0585f,0.0291f,0.0152f,0.0080f,0.0044f };\r\n\r\n\tif (p->opt.verbose) fprintf (stderr,_(\"Wavelet denoising...\\n\"));\r\n\r\n\twhile (p->maximum << scale < 0x10000) scale++;\r\n\tp->maximum <<= --scale;\r\n\tp->black <<= scale;\r\n\tif ((size = p->iheight*p->iwidth) < 0x15550000)\r\n\t\tfimg = (float *) malloc ((size*3 + p->iheight + p->iwidth) * sizeof *fimg);\r\n\tdcr_merror (p, fimg, \"wavelet_denoise()\");\r\n\ttemp = fimg + size*3;\r\n\tif ((nc = p->colors) == 3 && p->filters) nc++;\r\n\tFORC(nc) {\t/* denoise R,G1,B,G3 individually */\r\n\t\tfor (i=0; i < size; i++)\r\n\t\t\tfimg[i] = 256 * (float)sqrt(p->image[i][c] << scale);\r\n\t\tfor (hpass=lev=0; lev < 5; lev++) {\r\n\t\t\tlpass = size*((lev & 1)+1);\r\n\t\t\tfor (row=0; row < p->iheight; row++) {\r\n\t\t\t\tdcr_hat_transform (temp, fimg+hpass+row*p->iwidth, 1, p->iwidth, 1 << lev);\r\n\t\t\t\tfor (col=0; col < p->iwidth; col++)\r\n\t\t\t\t\tfimg[lpass + row*p->iwidth + col] = temp[col] * 0.25f;\r\n\t\t\t}\r\n\t\t\tfor (col=0; col < p->iwidth; col++) {\r\n\t\t\t\tdcr_hat_transform (temp, fimg+lpass+col, p->iwidth, p->iheight, 1 << lev);\r\n\t\t\t\tfor (row=0; row < p->iheight; row++)\r\n\t\t\t\t\tfimg[lpass + row*p->iwidth + col] = temp[row] * 0.25f;\r\n\t\t\t}\r\n\t\t\tthold = p->opt.threshold * noise[lev];\r\n\t\t\tfor (i=0; i < size; i++) {\r\n\t\t\t\tfimg[hpass+i] -= fimg[lpass+i];\r\n\t\t\t\tif\t(fimg[hpass+i] < -thold) fimg[hpass+i] += thold;\r\n\t\t\t\telse if (fimg[hpass+i] >  thold) fimg[hpass+i] -= thold;\r\n\t\t\t\telse\t fimg[hpass+i] = 0;\r\n\t\t\t\tif (hpass) fimg[i] += fimg[hpass+i];\r\n\t\t\t}\r\n\t\t\thpass = lpass;\r\n\t\t}\r\n\t\tfor (i=0; i < size; i++)\r\n\t\t\tp->image[i][c] = (unsigned short)(CLIP(SQR(fimg[i]+fimg[lpass+i])/0x10000));\r\n\t}\r\n\tif (p->filters && p->colors == 3) {  /* pull G1 and G3 closer together */\r\n\t\tfor (row=0; row < 2; row++)\r\n\t\t\tmul[row] = 0.125f * p->pre_mul[FC(row+1,0) | 1] / p->pre_mul[FC(row,0) | 1];\r\n\t\tfor (i=0; i < 4; i++)\r\n\t\t\twindow[i] = (ushort *) fimg + p->width*i;\r\n\t\tfor (wlast=-1, row=1; row < p->height-1; row++) {\r\n\t\t\twhile (wlast < row+1) {\r\n\t\t\t\tfor (wlast++, i=0; i < 4; i++)\r\n\t\t\t\t\twindow[(i+3) & 3] = window[i];\r\n\t\t\t\tfor (col = FC(wlast,1) & 1; col < p->width; col+=2)\r\n\t\t\t\t\twindow[2][col] = BAYER(wlast,col);\r\n\t\t\t}\r\n\t\t\tthold = p->opt.threshold/512;\r\n\t\t\tfor (col = (FC(row,0) & 1)+1; col < p->width-1; col+=2) {\r\n\t\t\t\tavg = ( window[0][col-1] + window[0][col+1] +\r\n\t\t\t\t\twindow[2][col-1] + window[2][col+1] - p->black*4 )\r\n\t\t\t\t\t* mul[row & 1] + (window[1][col] - p->black) * 0.5f + p->black;\r\n\t\t\t\tavg = avg < 0 ? 0 : (float)sqrt(avg);\r\n\t\t\t\tdiff = (float)sqrt(BAYER(row,col)) - avg;\r\n\t\t\t\tif      (diff < -thold) diff += thold;\r\n\t\t\t\telse if (diff >  thold) diff -= thold;\r\n\t\t\t\telse diff = 0;\r\n\t\t\t\tBAYER(row,col) = (unsigned short)(CLIP(SQR(avg+diff) + 0.5f));\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tfree (fimg);\r\n}\r\n\r\nvoid DCR_CLASS dcr_scale_colors(DCRAW* p)\r\n{\r\n\tunsigned bottom, right, size, row, col, ur, uc, i, x, y, c, sum[8];\r\n\tint val, dark, sat;\r\n\tdouble dsum[8], dmin, dmax;\r\n\tfloat scale_mul[4], fr, fc;\r\n\tushort *img=0, *pix;\r\n\r\n\tif (p->opt.user_mul[0])\r\n\t\tmemcpy (p->pre_mul, p->opt.user_mul, sizeof p->pre_mul);\r\n\tif (p->opt.use_auto_wb || (p->opt.use_camera_wb && p->cam_mul[0] == -1)) {\r\n\t\tmemset (dsum, 0, sizeof dsum);\r\n\t\tbottom = MIN (p->opt.greybox[1]+p->opt.greybox[3], p->height);\r\n\t\tright  = MIN (p->opt.greybox[0]+p->opt.greybox[2], p->width);\r\n\t\tfor (row=p->opt.greybox[1]; row < bottom; row += 8)\r\n\t\t\tfor (col=p->opt.greybox[0]; col < right; col += 8) {\r\n\t\t\t\tmemset (sum, 0, sizeof sum);\r\n\t\t\t\tfor (y=row; y < row+8 && y < bottom; y++)\r\n\t\t\t\t\tfor (x=col; x < col+8 && x < right; x++)\r\n\t\t\t\t\t\tFORC4 {\r\n\t\t\t\t\t\tif (p->filters) {\r\n\t\t\t\t\t\t\tc = FC(y,x);\r\n\t\t\t\t\t\t\tval = BAYER(y,x);\r\n\t\t\t\t\t\t} else\r\n\t\t\t\t\t\t\tval = p->image[y*p->width+x][c];\r\n\t\t\t\t\t\tif (val > (int)p->maximum-25) goto skip_block;\r\n\t\t\t\t\t\tif ((val -= p->black) < 0) val = 0;\r\n\t\t\t\t\t\tsum[c] += val;\r\n\t\t\t\t\t\tsum[c+4]++;\r\n\t\t\t\t\t\tif (p->filters) break;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tFORC(8) dsum[c] += sum[c];\r\nskip_block: ;\r\n\t\t\t}\r\n\t\t\tFORC4 if (dsum[c]) p->pre_mul[c] = (float)(dsum[c+4] / dsum[c]);\r\n\t}\r\n\tif (p->opt.use_camera_wb && p->cam_mul[0] != -1) {\r\n\t\tmemset (sum, 0, sizeof sum);\r\n\t\tfor (row=0; row < 8; row++)\r\n\t\t\tfor (col=0; col < 8; col++) {\r\n\t\t\t\tc = FC(row,col);\r\n\t\t\t\tif ((val = p->white[row][col] - p->black) > 0)\r\n\t\t\t\t\tsum[c] += val;\r\n\t\t\t\tsum[c+4]++;\r\n\t\t\t}\r\n\t\t\tif (sum[0] && sum[1] && sum[2] && sum[3])\r\n\t\t\t\tFORC4 p->pre_mul[c] = (float) sum[c+4] / sum[c];\r\n\t\t\telse if (p->cam_mul[0] && p->cam_mul[2])\r\n\t\t\t\tmemcpy (p->pre_mul, p->cam_mul, sizeof p->pre_mul);\r\n\t\t\telse\r\n\t\t\t\tfprintf (stderr,_(\"%s: Cannot use camera p->white balance.\\n\"), p->ifname);\r\n\t}\r\n\tif (p->pre_mul[3] == 0) p->pre_mul[3] = p->colors < 4 ? p->pre_mul[1] : 1;\r\n\tdark = p->black;\r\n\tsat = p->maximum;\r\n\tif (p->opt.threshold) dcr_wavelet_denoise(p);\r\n\tp->maximum -= p->black;\r\n\tfor (dmin=DBL_MAX, dmax=c=0; c < 4; c++) {\r\n\t\tif (dmin > p->pre_mul[c])\r\n\t\t\tdmin = p->pre_mul[c];\r\n\t\tif (dmax < p->pre_mul[c])\r\n\t\t\tdmax = p->pre_mul[c];\r\n\t}\r\n\tif (!p->opt.highlight) dmax = dmin;\r\n\tFORC4 scale_mul[c] = (float)((p->pre_mul[c] /= (float)dmax) * 65535.0f / p->maximum);\r\n\tif (p->opt.verbose) {\r\n\t\tfprintf (stderr,_(\"Scaling with darkness %d, saturation %d, and\\nmultipliers\"), dark, sat);\r\n\t\tFORC4 fprintf (stderr, \" %f\", p->pre_mul[c]);\r\n\t\tfputc ('\\n', stderr);\r\n\t}\r\n\tsize = p->iheight*p->iwidth;\r\n\tfor (i=0; i < size*4; i++) {\r\n\t\tval = p->image[0][i];\r\n\t\tif (!val) continue;\r\n\t\tval -= p->black;\r\n\t\tval = (int)(val * scale_mul[i & 3]);\r\n\t\tp->image[0][i] = CLIP(val);\r\n\t}\r\n\tif ((p->opt.aber[0] != 1 || p->opt.aber[2] != 1) && p->colors == 3) {\r\n\t\tif (p->opt.verbose)\r\n\t\t\tfprintf (stderr,_(\"Correcting chromatic aberration...\\n\"));\r\n\t\tfor (c=0; c < 4; c+=2) {\r\n\t\t\tif (p->opt.aber[c] == 1) continue;\r\n\t\t\timg = (ushort *) malloc (size * sizeof *img);\r\n\t\t\tdcr_merror (p, img, \"scale_colors()\");\r\n\t\t\tfor (i=0; i < size; i++)\r\n\t\t\t\timg[i] = p->image[i][c];\r\n\t\t\tfor (row=0; row < p->iheight; row++) {\r\n\t\t\t\tfr = (float)((row - p->iheight*0.5) * p->opt.aber[c] + p->iheight*0.5);\r\n\t\t\t\tur = (unsigned int)fr;\r\n\t\t\t\tif ((int)ur > p->iheight-2) continue;\r\n\t\t\t\tfr -= ur;\r\n\t\t\t\tfor (col=0; col < p->iwidth; col++) {\r\n\t\t\t\t\tfc = (float)((col - p->iwidth*0.5) * p->opt.aber[c] + p->iwidth*0.5);\r\n\t\t\t\t\tuc = (unsigned int)fc;\r\n\t\t\t\t\tif ((int)uc > p->iwidth-2) continue;\r\n\t\t\t\t\tfc -= uc;\r\n\t\t\t\t\tpix = img + ur*p->iwidth + uc;\r\n\t\t\t\t\tp->image[row*p->iwidth+col][c] = (unsigned short)(\r\n\t\t\t\t\t\t(pix[     0]*(1-fc) + pix[       1]*fc) * (1-fr) +\r\n\t\t\t\t\t\t(pix[p->iwidth]*(1-fc) + pix[p->iwidth+1]*fc) * fr);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tfree(img);\r\n\t\t}\r\n\t}\r\n}\r\n\r\nvoid DCR_CLASS dcr_pre_interpolate(DCRAW* p)\r\n{\r\n\tushort (*img)[4];\r\n\tint row, col, c;\r\n\r\n\tif (p->shrink) {\r\n\t\tif (p->opt.half_size) {\r\n\t\t\tp->height = p->iheight;\r\n\t\t\tp->width  = p->iwidth;\r\n\t\t} else {\r\n\t\t\timg = (ushort (*)[4]) calloc (p->height*p->width, sizeof *img);\r\n\t\t\tdcr_merror (p, img, \"pre_interpolate()\");\r\n\t\t\tfor (row=0; row < p->height; row++)\r\n\t\t\t\tfor (col=0; col < p->width; col++) {\r\n\t\t\t\t\tc = dcr_fc(p,row,col);\r\n\t\t\t\t\timg[row*p->width+col][c] = p->image[(row >> 1)*p->iwidth+(col >> 1)][c];\r\n\t\t\t\t}\r\n\t\t\t\tfree (p->image);\r\n\t\t\t\tp->image = img;\r\n\t\t\t\tp->shrink = 0;\r\n\t\t}\r\n\t}\r\n\tif (p->filters && p->colors == 3) {\r\n\t\tif ((p->mix_green = p->opt.four_color_rgb)) p->colors++;\r\n\t\telse {\r\n\t\t\tfor (row = FC(1,0) >> 1; row < p->height; row+=2)\r\n\t\t\t\tfor (col = FC(row,1) & 1; col < p->width; col+=2)\r\n\t\t\t\t\tp->image[row*p->width+col][1] = p->image[row*p->width+col][3];\r\n\t\t\t\tp->filters &= ~((p->filters & 0x55555555) << 1);\r\n\t\t}\r\n\t}\r\n\tif (p->opt.half_size) p->filters = 0;\r\n}\r\n\r\nvoid DCR_CLASS dcr_border_interpolate (DCRAW* p, int border)\r\n{\r\n\tunsigned row, col, y, x, f, sum[8];\r\n\tint c;\r\n\r\n\tfor (row=0; row < p->height; row++)\r\n\t\tfor (col=0; col < p->width; col++) {\r\n\t\t\tif (col==(unsigned int)border && row >= (unsigned int)border && row < p->height-(unsigned int)border)\r\n\t\t\t\tcol = p->width-border;\r\n\t\t\tmemset (sum, 0, sizeof sum);\r\n\t\t\tfor (y=row-1; y != row+2; y++)\r\n\t\t\t\tfor (x=col-1; x != col+2; x++)\r\n\t\t\t\t\tif (y < p->height && x < p->width) {\r\n\t\t\t\t\t\tf = dcr_fc(p,y,x);\r\n\t\t\t\t\t\tsum[f] += p->image[y*p->width+x][f];\r\n\t\t\t\t\t\tsum[f+4]++;\r\n\t\t\t\t\t}\r\n\t\t\tf = dcr_fc(p,row,col);\r\n\t\t\tFORCC(p) if ((unsigned int)c != f && sum[c+4])\r\n\t\t\t\tp->image[row*p->width+col][c] = sum[c] / sum[c+4];\r\n\t\t}\r\n}\r\n\r\nvoid DCR_CLASS dcr_lin_interpolate(DCRAW* p)\r\n{\r\n\tint code[16][16][32], *ip, sum[4];\r\n\tint c, i, x, y, row, col, shift, color;\r\n\tushort *pix;\r\n\r\n\tif (p->opt.verbose) fprintf (stderr,_(\"Bilinear interpolation...\\n\"));\r\n\r\n\tdcr_border_interpolate(p,1);\r\n\tfor (row=0; row < 16; row++)\r\n\t\tfor (col=0; col < 16; col++) {\r\n\t\t\tip = code[row][col];\r\n\t\t\tmemset (sum, 0, sizeof sum);\r\n\t\t\tfor (y=-1; y <= 1; y++)\r\n\t\t\t\tfor (x=-1; x <= 1; x++) {\r\n\t\t\t\t\tshift = (y==0) + (x==0);\r\n\t\t\t\t\tif (shift == 2) continue;\r\n\t\t\t\t\tcolor = dcr_fc(p,row+y,col+x);\r\n\t\t\t\t\t*ip++ = (p->width*y + x)*4 + color;\r\n\t\t\t\t\t*ip++ = shift;\r\n\t\t\t\t\t*ip++ = color;\r\n\t\t\t\t\tsum[color] += 1 << shift;\r\n\t\t\t\t}\r\n\t\t\t\tFORCC(p)\r\n\t\t\t\t\tif (c != dcr_fc(p,row,col)) {\r\n\t\t\t\t\t\t*ip++ = c;\r\n\t\t\t\t\t\t*ip++ = 256 / sum[c];\r\n\t\t\t\t\t}\r\n\t\t}\r\n\tfor (row=1; row < p->height-1; row++)\r\n\t\tfor (col=1; col < p->width-1; col++) {\r\n\t\t\tpix = p->image[row*p->width+col];\r\n\t\t\tip = code[row & 15][col & 15];\r\n\t\t\tmemset (sum, 0, sizeof sum);\r\n\t\t\tfor (i=8; i--; ip+=3)\r\n\t\t\t\tsum[ip[2]] += pix[ip[0]] << ip[1];\r\n\t\t\tfor (i=p->colors; --i; ip+=2)\r\n\t\t\t\tpix[ip[0]] = sum[ip[0]] * ip[1] >> 8;\r\n\t\t}\r\n}\r\n\r\n/*\r\nThis algorithm is officially called:\r\n\r\n  \"Interpolation using a Threshold-based variable number of gradients\"\r\n\r\n\tdescribed in http://scien.stanford.edu/class/psych221/projects/99/tingchen/algodep/vargra.html\r\n\r\n\t  I've extended the basic idea to work with non-Bayer filter arrays.\r\n\t  Gradients are numbered clockwise from NW=0 to W=7.\r\n*/\r\nvoid DCR_CLASS dcr_vng_interpolate(DCRAW* p)\r\n{\r\n\tstatic const signed char *cp, terms[] = {\r\n\t\t-2,-2,+0,-1,0,0x01, -2,-2,+0,+0,1,0x01, -2,-1,-1,+0,0,0x01,\r\n\t\t-2,-1,+0,-1,0,0x02, -2,-1,+0,+0,0,0x03, -2,-1,+0,+1,1,0x01,\r\n\t\t-2,+0,+0,-1,0,0x06, -2,+0,+0,+0,1,0x02, -2,+0,+0,+1,0,0x03,\r\n\t\t-2,+1,-1,+0,0,0x04, -2,+1,+0,-1,1,0x04, -2,+1,+0,+0,0,0x06,\r\n\t\t-2,+1,+0,+1,0,0x02, -2,+2,+0,+0,1,0x04, -2,+2,+0,+1,0,0x04,\r\n\t\t-1,-2,-1,+0,0,(const signed char)0x80, -1,-2,+0,-1,0,0x01, -1,-2,+1,-1,0,0x01,\r\n\t\t-1,-2,+1,+0,1,0x01, -1,-1,-1,+1,0,(const signed char)0x88, -1,-1,+1,-2,0,0x40,\r\n\t\t-1,-1,+1,-1,0,0x22, -1,-1,+1,+0,0,0x33, -1,-1,+1,+1,1,0x11,\r\n\t\t-1,+0,-1,+2,0,0x08, -1,+0,+0,-1,0,0x44, -1,+0,+0,+1,0,0x11,\r\n\t\t-1,+0,+1,-2,1,0x40, -1,+0,+1,-1,0,0x66, -1,+0,+1,+0,1,0x22,\r\n\t\t-1,+0,+1,+1,0,0x33, -1,+0,+1,+2,1,0x10, -1,+1,+1,-1,1,0x44,\r\n\t\t-1,+1,+1,+0,0,0x66, -1,+1,+1,+1,0,0x22, -1,+1,+1,+2,0,0x10,\r\n\t\t-1,+2,+0,+1,0,0x04, -1,+2,+1,+0,1,0x04, -1,+2,+1,+1,0,0x04,\r\n\t\t+0,-2,+0,+0,1,(const signed char)0x80, +0,-1,+0,+1,1,(const signed char)0x88, +0,-1,+1,-2,0,0x40,\r\n\t\t+0,-1,+1,+0,0,0x11, +0,-1,+2,-2,0,0x40, +0,-1,+2,-1,0,0x20,\r\n\t\t+0,-1,+2,+0,0,0x30, +0,-1,+2,+1,1,0x10, +0,+0,+0,+2,1,0x08,\r\n\t\t+0,+0,+2,-2,1,0x40, +0,+0,+2,-1,0,0x60, +0,+0,+2,+0,1,0x20,\r\n\t\t+0,+0,+2,+1,0,0x30, +0,+0,+2,+2,1,0x10, +0,+1,+1,+0,0,0x44,\r\n\t\t+0,+1,+1,+2,0,0x10, +0,+1,+2,-1,1,0x40, +0,+1,+2,+0,0,0x60,\r\n\t\t+0,+1,+2,+1,0,0x20, +0,+1,+2,+2,0,0x10, +1,-2,+1,+0,0,(const signed char)0x80,\r\n\t\t+1,-1,+1,+1,0,(const signed char)0x88, +1,+0,+1,+2,0,0x08, +1,+0,+2,-1,0,0x40,\r\n\t\t+1,+0,+2,+1,0,0x10\r\n\t}, chood[] = { -1,-1, -1,0, -1,+1, 0,+1, +1,+1, +1,0, +1,-1, 0,-1 };\r\n\tushort (*brow[5])[4], *pix;\r\n\tint prow=7, pcol=1, *ip, *code[16][16], gval[8], gmin, gmax, sum[4];\r\n\tint row, col, x, y, x1, x2, y1, y2, t, weight, grads, color, diag;\r\n\tint g, diff, thold, num, c;\r\n\r\n\tdcr_lin_interpolate(p);\r\n\tif (p->opt.verbose) fprintf (stderr,_(\"VNG interpolation...\\n\"));\r\n\r\n\tif (p->filters == 1) prow = pcol = 15;\r\n\tip = (int *) calloc ((prow+1)*(pcol+1), 1280);\r\n\tdcr_merror (p, ip, \"vng_interpolate()\");\r\n\tfor (row=0; row <= prow; row++)\t\t/* Precalculate for VNG */\r\n\t\tfor (col=0; col <= pcol; col++) {\r\n\t\t\tcode[row][col] = ip;\r\n\t\t\tfor (cp=terms, t=0; t < 64; t++) {\r\n\t\t\t\ty1 = *cp++;  x1 = *cp++;\r\n\t\t\t\ty2 = *cp++;  x2 = *cp++;\r\n\t\t\t\tweight = *cp++;\r\n\t\t\t\tgrads = *cp++;\r\n\t\t\t\tcolor = dcr_fc(p, row+y1,col+x1);\r\n\t\t\t\tif (dcr_fc(p, row+y2,col+x2) != color) continue;\r\n\t\t\t\tdiag = (dcr_fc(p, row,col+1) == color && dcr_fc(p, row+1,col) == color) ? 2:1;\r\n\t\t\t\tif (abs(y1-y2) == diag && abs(x1-x2) == diag) continue;\r\n\t\t\t\t*ip++ = (y1*p->width + x1)*4 + color;\r\n\t\t\t\t*ip++ = (y2*p->width + x2)*4 + color;\r\n\t\t\t\t*ip++ = weight;\r\n\t\t\t\tfor (g=0; g < 8; g++)\r\n\t\t\t\t\tif (grads & 1<<g) *ip++ = g;\r\n\t\t\t\t\t*ip++ = -1;\r\n\t\t\t}\r\n\t\t\t*ip++ = INT_MAX;\r\n\t\t\tfor (cp=chood, g=0; g < 8; g++) {\r\n\t\t\t\ty = *cp++;  x = *cp++;\r\n\t\t\t\t*ip++ = (y*p->width + x) * 4;\r\n\t\t\t\tcolor = dcr_fc(p, row,col);\r\n\t\t\t\tif (dcr_fc(p, row+y,col+x) != color && dcr_fc(p, row+y*2,col+x*2) == color)\r\n\t\t\t\t\t*ip++ = (y*p->width + x) * 8 + color;\r\n\t\t\t\telse\r\n\t\t\t\t\t*ip++ = 0;\r\n\t\t\t}\r\n\t\t}\r\n\tbrow[4] = (ushort (*)[4]) calloc (p->width*3, sizeof **brow);\r\n\tdcr_merror (p, brow[4], \"vng_interpolate()\");\r\n\tfor (row=0; row < 3; row++)\r\n\t\tbrow[row] = brow[4] + row*p->width;\r\n\tfor (row=2; row < p->height-2; row++) {\t\t/* Do VNG interpolation */\r\n\t\tfor (col=2; col < p->width-2; col++) {\r\n\t\t\tpix = p->image[row*p->width+col];\r\n\t\t\tip = code[row & prow][col & pcol];\r\n\t\t\tmemset (gval, 0, sizeof gval);\r\n\t\t\twhile ((g = ip[0]) != INT_MAX) {\t\t/* Calculate gradients */\r\n\t\t\t\tdiff = ABS(pix[g] - pix[ip[1]]) << ip[2];\r\n\t\t\t\tgval[ip[3]] += diff;\r\n\t\t\t\tip += 5;\r\n\t\t\t\tif ((g = ip[-1]) == -1) continue;\r\n\t\t\t\tgval[g] += diff;\r\n\t\t\t\twhile ((g = *ip++) != -1)\r\n\t\t\t\t\tgval[g] += diff;\r\n\t\t\t}\r\n\t\t\tip++;\r\n\t\t\tgmin = gmax = gval[0];\t\t\t/* Choose a p->opt.threshold */\r\n\t\t\tfor (g=1; g < 8; g++) {\r\n\t\t\t\tif (gmin > gval[g]) gmin = gval[g];\r\n\t\t\t\tif (gmax < gval[g]) gmax = gval[g];\r\n\t\t\t}\r\n\t\t\tif (gmax == 0) {\r\n\t\t\t\tmemcpy (brow[2][col], pix, sizeof *p->image);\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tthold = gmin + (gmax >> 1);\r\n\t\t\tmemset (sum, 0, sizeof sum);\r\n\t\t\tcolor = dcr_fc(p, row,col);\r\n\t\t\tfor (num=g=0; g < 8; g++,ip+=2) {\t\t/* Average the neighbors */\r\n\t\t\t\tif (gval[g] <= thold) {\r\n\t\t\t\t\tFORCC(p)\r\n\t\t\t\t\t\tif (c == color && ip[1])\r\n\t\t\t\t\t\t\tsum[c] += (pix[c] + pix[ip[1]]) >> 1;\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\tsum[c] += pix[ip[0] + c];\r\n\t\t\t\t\t\tnum++;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tFORCC(p) {\t\t\t\t\t/* Save to buffer */\r\n\t\t\t\tt = pix[color];\r\n\t\t\t\tif (c != color)\r\n\t\t\t\t\tt += (sum[c] - sum[color]) / num;\r\n\t\t\t\tbrow[2][col][c] = CLIP(t);\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (row > 3)\t\t\t\t/* Write buffer to image */\r\n\t\t\tmemcpy (p->image[(row-2)*p->width+2], brow[0]+2, (p->width-4)*sizeof *p->image);\r\n\t\tfor (g=0; g < 4; g++)\r\n\t\t\tbrow[(g-1) & 3] = brow[g];\r\n\t}\r\n\tmemcpy (p->image[(row-2)*p->width+2], brow[0]+2, (p->width-4)*sizeof *p->image);\r\n\tmemcpy (p->image[(row-1)*p->width+2], brow[1]+2, (p->width-4)*sizeof *p->image);\r\n\tfree (brow[4]);\r\n\tfree (code[0][0]);\r\n}\r\n\r\n/*\r\nPatterned Pixel Grouping Interpolation by Alain Desbiolles\r\n*/\r\nvoid DCR_CLASS dcr_ppg_interpolate(DCRAW* p)\r\n{\r\n\tint dir[5] = { 1, p->width, -1, -p->width, 1 };\r\n\tint row, col, diff[2], guess[2], c, d, i;\r\n\tushort (*pix)[4];\r\n\r\n\tdcr_border_interpolate(p,3);\r\n\tif (p->opt.verbose) fprintf (stderr,_(\"PPG interpolation...\\n\"));\r\n\r\n\t/*  Fill in the green layer with gradients and pattern recognition: */\r\n\tfor (row=3; row < p->height-3; row++)\r\n\t\tfor (col=3+(FC(row,3) & 1), c=FC(row,col); col < p->width-3; col+=2) {\r\n\t\t\tpix = p->image + row*p->width+col;\r\n\t\t\tfor (i=0; (d=dir[i]) > 0; i++) {\r\n\t\t\t\tguess[i] = (pix[-d][1] + pix[0][c] + pix[d][1]) * 2\r\n\t\t\t\t\t- pix[-2*d][c] - pix[2*d][c];\r\n\t\t\t\tdiff[i] = ( ABS(pix[-2*d][c] - pix[ 0][c]) +\r\n\t\t\t\t\tABS(pix[ 2*d][c] - pix[ 0][c]) +\r\n\t\t\t\t\tABS(pix[  -d][1] - pix[ d][1]) ) * 3 +\r\n\t\t\t\t\t( ABS(pix[ 3*d][1] - pix[ d][1]) +\r\n\t\t\t\t\tABS(pix[-3*d][1] - pix[-d][1]) ) * 2;\r\n\t\t\t}\r\n\t\t\td = dir[i = diff[0] > diff[1]];\r\n\t\t\tpix[0][1] = ULIM(guess[i] >> 2, pix[d][1], pix[-d][1]);\r\n\t\t}\r\n\t\t/*  Calculate red and blue for each green pixel:\t\t*/\r\n\t\tfor (row=1; row < p->height-1; row++)\r\n\t\t\tfor (col=1+(FC(row,2) & 1), c=FC(row,col+1); col < p->width-1; col+=2) {\r\n\t\t\t\tpix = p->image + row*p->width+col;\r\n\t\t\t\tfor (i=0; (d=dir[i]) > 0; c=2-c, i++)\r\n\t\t\t\t\tpix[0][c] = CLIP((pix[-d][c] + pix[d][c] + 2*pix[0][1]\r\n\t\t\t\t\t- pix[-d][1] - pix[d][1]) >> 1);\r\n\t\t\t}\r\n\t\t/*  Calculate blue for red pixels and vice versa:\t\t*/\r\n\t\tfor (row=1; row < p->height-1; row++)\r\n\t\t\tfor (col=1+(FC(row,1) & 1), c=2-FC(row,col); col < p->width-1; col+=2) {\r\n\t\t\t\tpix = p->image + row*p->width+col;\r\n\t\t\t\tfor (i=0; (d=dir[i]+dir[i+1]) > 0; i++) {\r\n\t\t\t\t\tdiff[i] = ABS(pix[-d][c] - pix[d][c]) +\r\n\t\t\t\t\t\tABS(pix[-d][1] - pix[0][1]) +\r\n\t\t\t\t\t\tABS(pix[ d][1] - pix[0][1]);\r\n\t\t\t\t\tguess[i] = pix[-d][c] + pix[d][c] + 2*pix[0][1]\r\n\t\t\t\t\t\t- pix[-d][1] - pix[d][1];\r\n\t\t\t\t}\r\n\t\t\t\tif (diff[0] != diff[1])\r\n\t\t\t\t\tpix[0][c] = CLIP(guess[diff[0] > diff[1]] >> 1);\r\n\t\t\t\telse\r\n\t\t\t\t\tpix[0][c] = CLIP((guess[0]+guess[1]) >> 2);\r\n\t\t\t}\r\n}\r\n\r\n/*\r\nAdaptive Homogeneity-Directed interpolation is based on\r\nthe work of Keigo Hirakawa, Thomas Parks, and Paul Lee.\r\n*/\r\n#define TS 256\t\t/* Tile Size */\r\n\r\nvoid DCR_CLASS dcr_ahd_interpolate(DCRAW* p)\r\n{\r\n\tint i, j, k, top, left, row, col, tr, tc, c, d, val, hm[2];\r\n\tushort (*pix)[4], (*rix)[3];\r\n\tstatic const int dir[4] = { -1, 1, -TS, TS };\r\n\tunsigned ldiff[2][4], abdiff[2][4], leps, abeps;\r\n\tfloat r, cbrt[0x10000], xyz[3], xyz_cam[3][4];\r\n\tushort (*rgb)[TS][TS][3];\r\n\tshort (*lab)[TS][TS][3], (*lix)[3];\r\n\tchar (*homo)[TS][TS], *buffer;\r\n\r\n\tif (p->opt.verbose) fprintf (stderr,_(\"AHD interpolation...\\n\"));\r\n\r\n\tfor (i=0; i < 0x10000; i++) {\r\n\t\tr = i / 65535.0f;\r\n\t\tcbrt[i] = r > 0.008856f ? (float)pow(r,1/3.0f) : 7.787f*r + 16/116.0f;\r\n\t}\r\n\tfor (i=0; i < 3; i++)\r\n\t\tfor (j=0; j < p->colors; j++)\r\n\t\t\tfor (xyz_cam[i][j] =0, k=0; k < 3; k++)\r\n\t\t\t\txyz_cam[i][j] += (float)(xyz_rgb[i][k] * p->rgb_cam[k][j] / d65_white[i]);\r\n\r\n\t\tdcr_border_interpolate(p,5);\r\n\t\tbuffer = (char *) malloc (26*TS*TS);\t\t/* 1664 kB */\r\n\t\tdcr_merror (p, buffer, \"ahd_interpolate()\");\r\n\t\trgb  = (ushort(*)[TS][TS][3]) buffer;\r\n\t\tlab  = (short (*)[TS][TS][3])(buffer + 12*TS*TS);\r\n\t\thomo = (char  (*)[TS][TS])   (buffer + 24*TS*TS);\r\n\r\n\t\tfor (top=2; top < p->height-5; top += TS-6)\r\n\t\t\tfor (left=2; left < p->width-5; left += TS-6) {\r\n\r\n\t\t\t\t/*  Interpolate green horizontally and vertically:\t\t*/\r\n\t\t\t\tfor (row = top; row < top+TS && row < p->height-2; row++) {\r\n\t\t\t\t\tcol = left + (FC(row,left) & 1);\r\n\t\t\t\t\tfor (c = FC(row,col); col < left+TS && col < p->width-2; col+=2) {\r\n\t\t\t\t\t\tpix = p->image + row*p->width+col;\r\n\t\t\t\t\t\tval = ((pix[-1][1] + pix[0][c] + pix[1][1]) * 2\r\n\t\t\t\t\t\t\t- pix[-2][c] - pix[2][c]) >> 2;\r\n\t\t\t\t\t\trgb[0][row-top][col-left][1] = ULIM(val,pix[-1][1],pix[1][1]);\r\n\t\t\t\t\t\tval = ((pix[-p->width][1] + pix[0][c] + pix[p->width][1]) * 2\r\n\t\t\t\t\t\t\t- pix[-2*p->width][c] - pix[2*p->width][c]) >> 2;\r\n\t\t\t\t\t\trgb[1][row-top][col-left][1] = ULIM(val,pix[-p->width][1],pix[p->width][1]);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t/*  Interpolate red and blue, and convert to CIELab:\t\t*/\r\n\t\t\t\tfor (d=0; d < 2; d++)\r\n\t\t\t\t\tfor (row=top+1; row < top+TS-1 && row < p->height-3; row++)\r\n\t\t\t\t\t\tfor (col=left+1; col < left+TS-1 && col < p->width-3; col++) {\r\n\t\t\t\t\t\t\tpix = p->image + row*p->width+col;\r\n\t\t\t\t\t\t\trix = &rgb[d][row-top][col-left];\r\n\t\t\t\t\t\t\tlix = &lab[d][row-top][col-left];\r\n\t\t\t\t\t\t\tif ((c = 2 - FC(row,col)) == 1) {\r\n\t\t\t\t\t\t\t\tc = FC(row+1,col);\r\n\t\t\t\t\t\t\t\tval = pix[0][1] + (( pix[-1][2-c] + pix[1][2-c]\r\n\t\t\t\t\t\t\t\t\t- rix[-1][1] - rix[1][1] ) >> 1);\r\n\t\t\t\t\t\t\t\trix[0][2-c] = CLIP(val);\r\n\t\t\t\t\t\t\t\tval = pix[0][1] + (( pix[-p->width][c] + pix[p->width][c]\r\n\t\t\t\t\t\t\t\t\t- rix[-TS][1] - rix[TS][1] ) >> 1);\r\n\t\t\t\t\t\t\t} else\r\n\t\t\t\t\t\t\t\tval = rix[0][1] + (( pix[-p->width-1][c] + pix[-p->width+1][c]\r\n\t\t\t\t\t\t\t\t+ pix[+p->width-1][c] + pix[+p->width+1][c]\r\n\t\t\t\t\t\t\t\t- rix[-TS-1][1] - rix[-TS+1][1]\r\n\t\t\t\t\t\t\t\t- rix[+TS-1][1] - rix[+TS+1][1] + 1) >> 2);\r\n\t\t\t\t\t\t\trix[0][c] = CLIP(val);\r\n\t\t\t\t\t\t\tc = FC(row,col);\r\n\t\t\t\t\t\t\trix[0][c] = pix[0][c];\r\n\t\t\t\t\t\t\txyz[0] = xyz[1] = xyz[2] = 0.5;\r\n\t\t\t\t\t\t\tFORCC(p) {\r\n\t\t\t\t\t\t\t\txyz[0] += xyz_cam[0][c] * rix[0][c];\r\n\t\t\t\t\t\t\t\txyz[1] += xyz_cam[1][c] * rix[0][c];\r\n\t\t\t\t\t\t\t\txyz[2] += xyz_cam[2][c] * rix[0][c];\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\txyz[0] = cbrt[CLIP((int) xyz[0])];\r\n\t\t\t\t\t\t\txyz[1] = cbrt[CLIP((int) xyz[1])];\r\n\t\t\t\t\t\t\txyz[2] = cbrt[CLIP((int) xyz[2])];\r\n\t\t\t\t\t\t\tlix[0][0] = (short)(64 * (116 * xyz[1] - 16));\r\n\t\t\t\t\t\t\tlix[0][1] = (short)(64 * 500 * (xyz[0] - xyz[1]));\r\n\t\t\t\t\t\t\tlix[0][2] = (short)(64 * 200 * (xyz[1] - xyz[2]));\r\n\t\t\t\t\t\t}\r\n\t\t\t\t/*  Build homogeneity maps from the CIELab images:\t\t*/\r\n\t\t\t\tmemset (homo, 0, 2*TS*TS);\r\n\t\t\t\tfor (row=top+2; row < top+TS-2 && row < p->height-4; row++) {\r\n\t\t\t\t\ttr = row-top;\r\n\t\t\t\t\tfor (col=left+2; col < left+TS-2 && col < p->width-4; col++) {\r\n\t\t\t\t\t\ttc = col-left;\r\n\t\t\t\t\t\tfor (d=0; d < 2; d++) {\r\n\t\t\t\t\t\t\tlix = &lab[d][tr][tc];\r\n\t\t\t\t\t\t\tfor (i=0; i < 4; i++) {\r\n\t\t\t\t\t\t\t\tldiff[d][i] = ABS(lix[0][0]-lix[dir[i]][0]);\r\n\t\t\t\t\t\t\t\tabdiff[d][i] = SQR(lix[0][1]-lix[dir[i]][1])\r\n\t\t\t\t\t\t\t\t\t+ SQR(lix[0][2]-lix[dir[i]][2]);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tleps = MIN(MAX(ldiff[0][0],ldiff[0][1]),\r\n\t\t\t\t\t\t\tMAX(ldiff[1][2],ldiff[1][3]));\r\n\t\t\t\t\t\tabeps = MIN(MAX(abdiff[0][0],abdiff[0][1]),\r\n\t\t\t\t\t\t\tMAX(abdiff[1][2],abdiff[1][3]));\r\n\t\t\t\t\t\tfor (d=0; d < 2; d++)\r\n\t\t\t\t\t\t\tfor (i=0; i < 4; i++)\r\n\t\t\t\t\t\t\t\tif (ldiff[d][i] <= leps && abdiff[d][i] <= abeps)\r\n\t\t\t\t\t\t\t\t\thomo[d][tr][tc]++;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t/*  Combine the most homogenous pixels for the final result:\t*/\r\n\t\t\t\tfor (row=top+3; row < top+TS-3 && row < p->height-5; row++) {\r\n\t\t\t\t\ttr = row-top;\r\n\t\t\t\t\tfor (col=left+3; col < left+TS-3 && col < p->width-5; col++) {\r\n\t\t\t\t\t\ttc = col-left;\r\n\t\t\t\t\t\tfor (d=0; d < 2; d++)\r\n\t\t\t\t\t\t\tfor (hm[d]=0, i=tr-1; i <= tr+1; i++)\r\n\t\t\t\t\t\t\t\tfor (j=tc-1; j <= tc+1; j++)\r\n\t\t\t\t\t\t\t\t\thm[d] += homo[d][i][j];\r\n\t\t\t\t\t\t\t\tif (hm[0] != hm[1])\r\n\t\t\t\t\t\t\t\t\tFORC3 p->image[row*p->width+col][c] = rgb[hm[1] > hm[0]][tr][tc][c];\r\n\t\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t\t\tFORC3 p->image[row*p->width+col][c] =\r\n\t\t\t\t\t\t\t\t\t(rgb[0][tr][tc][c] + rgb[1][tr][tc][c]) >> 1;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tfree (buffer);\r\n}\r\n#undef TS\r\n\r\nvoid DCR_CLASS dcr_median_filter(DCRAW* p)\r\n{\r\n\tushort (*pix)[4];\r\n\tint pass, c, i, j, k, med[9];\r\n\tstatic const uchar opt[] =\t/* Optimal 9-element median search */\r\n\t{ 1,2, 4,5, 7,8, 0,1, 3,4, 6,7, 1,2, 4,5, 7,8,\r\n    0,3, 5,8, 4,7, 3,6, 1,4, 2,5, 4,7, 4,2, 6,4, 4,2 };\r\n\r\n\tfor (pass=1; pass <= p->opt.med_passes; pass++) {\r\n\t\tif (p->opt.verbose)\r\n\t\t\tfprintf (stderr,_(\"Median filter pass %d...\\n\"), pass);\r\n\t\tfor (c=0; c < 3; c+=2) {\r\n\t\t\tfor (pix = p->image; pix < p->image+p->width*p->height; pix++)\r\n\t\t\t\tpix[0][3] = pix[0][c];\r\n\t\t\tfor (pix = p->image+p->width; pix < p->image+p->width*(p->height-1); pix++) {\r\n\t\t\t\tif ((pix-p->image+1) % p->width < 2) continue;\r\n\t\t\t\tfor (k=0, i = -p->width; i <= p->width; i += p->width)\r\n\t\t\t\t\tfor (j = i-1; j <= i+1; j++)\r\n\t\t\t\t\t\tmed[k++] = pix[j][3] - pix[j][1];\r\n\t\t\t\t\tfor (i=0; i < sizeof opt; i+=2)\r\n\t\t\t\t\t\tif     (med[opt[i]] > med[opt[i+1]])\r\n\t\t\t\t\t\t\tSWAP (med[opt[i]] , med[opt[i+1]]);\r\n\t\t\t\t\t\tpix[0][c] = CLIP(med[4] + pix[0][1]);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\nvoid DCR_CLASS dcr_blend_highlights(DCRAW* p)\r\n{\r\n\tint clip=INT_MAX, row, col, c, i, j;\r\n\tstatic const float trans[2][4][4] =\r\n\t{ { { 1,1,1 }, { 1.7320508f,-1.7320508f,0 }, { -1,-1,2 } },\r\n    { { 1,1,1,1 }, { 1,-1,1,-1 }, { 1,1,-1,-1 }, { 1,-1,-1,1 } } };\r\n\tstatic const float itrans[2][4][4] =\r\n\t{ { { 1,0.8660254f,-0.5f }, { 1,-0.8660254f,-0.5f }, { 1,0,1 } },\r\n    { { 1,1,1,1 }, { 1,-1,1,-1 }, { 1,1,-1,-1 }, { 1,-1,-1,1 } } };\r\n\tfloat cam[2][4], lab[2][4], sum[2], chratio;\r\n\r\n\tif ((unsigned) (p->colors-3) > 1) return;\r\n\tif (p->opt.verbose) fprintf (stderr,_(\"Blending highlights...\\n\"));\r\n\tFORCC(p) if (clip > (i = (int)(65535*p->pre_mul[c]))) clip = i;\r\n\tfor (row=0; row < p->height; row++)\r\n\t\tfor (col=0; col < p->width; col++) {\r\n\t\t\tFORCC(p) if (p->image[row*p->width+col][c] > clip) break;\r\n\t\t\tif (c == p->colors) continue;\r\n\t\t\tFORCC(p) {\r\n\t\t\t\tcam[0][c] = p->image[row*p->width+col][c];\r\n\t\t\t\tcam[1][c] = MIN(cam[0][c],clip);\r\n\t\t\t}\r\n\t\t\tfor (i=0; i < 2; i++) {\r\n\t\t\t\tFORCC(p) for (lab[i][c]=0, j=0; j < p->colors; j++)\r\n\t\t\t\t\tlab[i][c] += trans[p->colors-3][c][j] * cam[i][j];\r\n\t\t\t\tfor (sum[i]=0,c=1; c < p->colors; c++)\r\n\t\t\t\t\tsum[i] += SQR(lab[i][c]);\r\n\t\t\t}\r\n\t\t\tchratio = (float)sqrt(sum[1]/sum[0]);\r\n\t\t\tfor (c=1; c < p->colors; c++)\r\n\t\t\t\tlab[0][c] *= chratio;\r\n\t\t\tFORCC(p) for (cam[0][c]=0, j=0; j < p->colors; j++)\r\n\t\t\t\tcam[0][c] += itrans[p->colors-3][c][j] * lab[0][j];\r\n\t\t\tFORCC(p) p->image[row*p->width+col][c] = (unsigned short)(cam[0][c] / p->colors);\r\n\t\t}\r\n}\r\n\r\n#define SCALE (4 >> p->shrink)\r\nvoid DCR_CLASS dcr_recover_highlights(DCRAW* p)\r\n{\r\n\tfloat *map, sum, wgt, grow;\r\n\tint hsat[4], count, spread, change, val, i, c;\r\n\tunsigned high, wide, mrow, mcol, row, col, kc, d, y, x;\r\n\tushort *pixel;\r\n\tstatic const signed char dir[8][2] =\r\n    { {-1,-1}, {-1,0}, {-1,1}, {0,1}, {1,1}, {1,0}, {1,-1}, {0,-1} };\r\n\r\n\tif (p->opt.verbose) fprintf (stderr,_(\"Rebuilding highlights...\\n\"));\r\n\r\n\tgrow = (float)pow (2, 4-p->opt.highlight);\r\n\tFORCC(p) hsat[c] = (int)(32000 * p->pre_mul[c]);\r\n\tfor (kc=0, c=1; (int)c < p->colors; c++)\r\n\t\tif (p->pre_mul[kc] < p->pre_mul[c]) kc = c;\r\n\t\thigh = p->height / SCALE;\r\n\t\twide =  p->width / SCALE;\r\n\t\tmap = (float *) calloc (high*wide, sizeof *map);\r\n\t\tdcr_merror (p, map, \"recover_highlights()\");\r\n\t\tFORCC(p) if ((unsigned int)c != kc) {\r\n\t\t\tmemset (map, 0, high*wide*sizeof *map);\r\n\t\t\tfor (mrow=0; mrow < high; mrow++)\r\n\t\t\t\tfor (mcol=0; mcol < wide; mcol++) {\r\n\t\t\t\t\tsum = wgt = 0;\r\n\t\t\t\t\tcount = 0;\r\n\t\t\t\t\tfor (row = mrow*SCALE; row < (mrow+1)*SCALE; row++)\r\n\t\t\t\t\t\tfor (col = mcol*SCALE; col < (mcol+1)*SCALE; col++) {\r\n\t\t\t\t\t\t\tpixel = p->image[row*p->width+col];\r\n\t\t\t\t\t\t\tif (pixel[c] / hsat[c] == 1 && pixel[kc] > 24000) {\r\n\t\t\t\t\t\t\t\tsum += pixel[c];\r\n\t\t\t\t\t\t\t\twgt += pixel[kc];\r\n\t\t\t\t\t\t\t\tcount++;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (count == SCALE*SCALE)\r\n\t\t\t\t\t\t\tmap[mrow*wide+mcol] = sum / wgt;\r\n\t\t\t\t}\r\n\t\t\tfor (spread = (int)(32/grow); spread--; ) {\r\n\t\t\t\tfor (mrow=0; mrow < high; mrow++)\r\n\t\t\t\t\tfor (mcol=0; mcol < wide; mcol++) {\r\n\t\t\t\t\t\tif (map[mrow*wide+mcol]) continue;\r\n\t\t\t\t\t\tsum = 0;\r\n\t\t\t\t\t\tcount = 0;\r\n\t\t\t\t\t\tfor (d=0; d < 8; d++) {\r\n\t\t\t\t\t\t\ty = mrow + dir[d][0];\r\n\t\t\t\t\t\t\tx = mcol + dir[d][1];\r\n\t\t\t\t\t\t\tif (y < high && x < wide && map[y*wide+x] > 0) {\r\n\t\t\t\t\t\t\t\tsum  += (1 + (d & 1)) * map[y*wide+x];\r\n\t\t\t\t\t\t\t\tcount += 1 + (d & 1);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (count > 3)\r\n\t\t\t\t\t\t\tmap[mrow*wide+mcol] = - (sum+grow) / (count+grow);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tfor (change=i=0; i < (int)(high*wide); i++)\r\n\t\t\t\t\t\tif (map[i] < 0) {\r\n\t\t\t\t\t\t\tmap[i] = -map[i];\r\n\t\t\t\t\t\t\tchange = 1;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (!change) break;\r\n\t\t\t}\r\n\t\t\tfor (i=0; i < (int)(high*wide); i++)\r\n\t\t\t\tif (map[i] == 0) map[i] = 1;\r\n\t\t\tfor (mrow=0; mrow < high; mrow++)\r\n\t\t\t\tfor (mcol=0; mcol < wide; mcol++) {\r\n\t\t\t\t\tfor (row = mrow*SCALE; row < (mrow+1)*SCALE; row++)\r\n\t\t\t\t\t\tfor (col = mcol*SCALE; col < (mcol+1)*SCALE; col++) {\r\n\t\t\t\t\t\t\tpixel = p->image[row*p->width+col];\r\n\t\t\t\t\t\t\tif (pixel[c] / hsat[c] > 1) {\r\n\t\t\t\t\t\t\t\tval = (int)(pixel[kc] * map[mrow*wide+mcol]);\r\n\t\t\t\t\t\t\t\tif (pixel[c] < val) pixel[c] = CLIP(val);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t}\r\n\t\tfree (map);\r\n}\r\n#undef SCALE\r\n\r\nvoid DCR_CLASS dcr_tiff_get (DCRAW* p, unsigned base,\r\n\t\t\t\t\t\t\t unsigned *tag, unsigned *type, unsigned *len, unsigned *save)\r\n{\r\n\t*tag  = dcr_get2(p);\r\n\t*type = dcr_get2(p);\r\n\t*len  = dcr_get4(p);\r\n\t*save = dcr_ftell(p->obj_) + 4;\r\n\tif (*len * (\"11124811248488\"[*type < 14 ? *type:0]-'0') > 4)\r\n\t\tdcr_fseek(p->obj_, dcr_get4(p)+base, SEEK_SET);\r\n}\r\n\r\nvoid DCR_CLASS dcr_parse_thumb_note (DCRAW* p, int base, unsigned toff, unsigned tlen)\r\n{\r\n\tunsigned entries, tag, type, len, save;\r\n\r\n\tentries = dcr_get2(p);\r\n\twhile (entries--) {\r\n\t\tdcr_tiff_get (p, base, &tag, &type, &len, &save);\r\n\t\tif (tag == toff) p->thumb_offset = dcr_get4(p)+base;\r\n\t\tif (tag == tlen) p->thumb_length = dcr_get4(p);\r\n\t\tdcr_fseek(p->obj_, save, SEEK_SET);\r\n\t}\r\n}\r\n\r\nint DCR_CLASS dcr_parse_tiff_ifd (DCRAW* p, int base);\r\n\r\nvoid DCR_CLASS dcr_parse_makernote (DCRAW* p, int base, int uptag)\r\n{\r\n\tstatic const uchar xlat[2][256] = {\r\n\t\t{ 0xc1,0xbf,0x6d,0x0d,0x59,0xc5,0x13,0x9d,0x83,0x61,0x6b,0x4f,0xc7,0x7f,0x3d,0x3d,\r\n\t\t0x53,0x59,0xe3,0xc7,0xe9,0x2f,0x95,0xa7,0x95,0x1f,0xdf,0x7f,0x2b,0x29,0xc7,0x0d,\r\n\t\t0xdf,0x07,0xef,0x71,0x89,0x3d,0x13,0x3d,0x3b,0x13,0xfb,0x0d,0x89,0xc1,0x65,0x1f,\r\n\t\t0xb3,0x0d,0x6b,0x29,0xe3,0xfb,0xef,0xa3,0x6b,0x47,0x7f,0x95,0x35,0xa7,0x47,0x4f,\r\n\t\t0xc7,0xf1,0x59,0x95,0x35,0x11,0x29,0x61,0xf1,0x3d,0xb3,0x2b,0x0d,0x43,0x89,0xc1,\r\n\t\t0x9d,0x9d,0x89,0x65,0xf1,0xe9,0xdf,0xbf,0x3d,0x7f,0x53,0x97,0xe5,0xe9,0x95,0x17,\r\n\t\t0x1d,0x3d,0x8b,0xfb,0xc7,0xe3,0x67,0xa7,0x07,0xf1,0x71,0xa7,0x53,0xb5,0x29,0x89,\r\n\t\t0xe5,0x2b,0xa7,0x17,0x29,0xe9,0x4f,0xc5,0x65,0x6d,0x6b,0xef,0x0d,0x89,0x49,0x2f,\r\n\t\t0xb3,0x43,0x53,0x65,0x1d,0x49,0xa3,0x13,0x89,0x59,0xef,0x6b,0xef,0x65,0x1d,0x0b,\r\n\t\t0x59,0x13,0xe3,0x4f,0x9d,0xb3,0x29,0x43,0x2b,0x07,0x1d,0x95,0x59,0x59,0x47,0xfb,\r\n\t\t0xe5,0xe9,0x61,0x47,0x2f,0x35,0x7f,0x17,0x7f,0xef,0x7f,0x95,0x95,0x71,0xd3,0xa3,\r\n\t\t0x0b,0x71,0xa3,0xad,0x0b,0x3b,0xb5,0xfb,0xa3,0xbf,0x4f,0x83,0x1d,0xad,0xe9,0x2f,\r\n\t\t0x71,0x65,0xa3,0xe5,0x07,0x35,0x3d,0x0d,0xb5,0xe9,0xe5,0x47,0x3b,0x9d,0xef,0x35,\r\n\t\t0xa3,0xbf,0xb3,0xdf,0x53,0xd3,0x97,0x53,0x49,0x71,0x07,0x35,0x61,0x71,0x2f,0x43,\r\n\t\t0x2f,0x11,0xdf,0x17,0x97,0xfb,0x95,0x3b,0x7f,0x6b,0xd3,0x25,0xbf,0xad,0xc7,0xc5,\r\n\t\t0xc5,0xb5,0x8b,0xef,0x2f,0xd3,0x07,0x6b,0x25,0x49,0x95,0x25,0x49,0x6d,0x71,0xc7 },\r\n\t\t{ 0xa7,0xbc,0xc9,0xad,0x91,0xdf,0x85,0xe5,0xd4,0x78,0xd5,0x17,0x46,0x7c,0x29,0x4c,\r\n\t\t0x4d,0x03,0xe9,0x25,0x68,0x11,0x86,0xb3,0xbd,0xf7,0x6f,0x61,0x22,0xa2,0x26,0x34,\r\n\t\t0x2a,0xbe,0x1e,0x46,0x14,0x68,0x9d,0x44,0x18,0xc2,0x40,0xf4,0x7e,0x5f,0x1b,0xad,\r\n\t\t0x0b,0x94,0xb6,0x67,0xb4,0x0b,0xe1,0xea,0x95,0x9c,0x66,0xdc,0xe7,0x5d,0x6c,0x05,\r\n\t\t0xda,0xd5,0xdf,0x7a,0xef,0xf6,0xdb,0x1f,0x82,0x4c,0xc0,0x68,0x47,0xa1,0xbd,0xee,\r\n\t\t0x39,0x50,0x56,0x4a,0xdd,0xdf,0xa5,0xf8,0xc6,0xda,0xca,0x90,0xca,0x01,0x42,0x9d,\r\n\t\t0x8b,0x0c,0x73,0x43,0x75,0x05,0x94,0xde,0x24,0xb3,0x80,0x34,0xe5,0x2c,0xdc,0x9b,\r\n\t\t0x3f,0xca,0x33,0x45,0xd0,0xdb,0x5f,0xf5,0x52,0xc3,0x21,0xda,0xe2,0x22,0x72,0x6b,\r\n\t\t0x3e,0xd0,0x5b,0xa8,0x87,0x8c,0x06,0x5d,0x0f,0xdd,0x09,0x19,0x93,0xd0,0xb9,0xfc,\r\n\t\t0x8b,0x0f,0x84,0x60,0x33,0x1c,0x9b,0x45,0xf1,0xf0,0xa3,0x94,0x3a,0x12,0x77,0x33,\r\n\t\t0x4d,0x44,0x78,0x28,0x3c,0x9e,0xfd,0x65,0x57,0x16,0x94,0x6b,0xfb,0x59,0xd0,0xc8,\r\n\t\t0x22,0x36,0xdb,0xd2,0x63,0x98,0x43,0xa1,0x04,0x87,0x86,0xf7,0xa6,0x26,0xbb,0xd6,\r\n\t\t0x59,0x4d,0xbf,0x6a,0x2e,0xaa,0x2b,0xef,0xe6,0x78,0xb6,0x4e,0xe0,0x2f,0xdc,0x7c,\r\n\t\t0xbe,0x57,0x19,0x32,0x7e,0x2a,0xd0,0xb8,0xba,0x29,0x00,0x3c,0x52,0x7d,0xa8,0x49,\r\n\t\t0x3b,0x2d,0xeb,0x25,0x49,0xfa,0xa3,0xaa,0x39,0xa7,0xc5,0xa7,0x50,0x11,0x36,0xfb,\r\n\t\t0xc6,0x67,0x4a,0xf5,0xa5,0x12,0x65,0x7e,0xb0,0xdf,0xaf,0x4e,0xb3,0x61,0x7f,0x2f } };\r\n\tunsigned offset=0, entries, tag, type, len, save, c;\r\n\tunsigned ver97=0, serial=0, i, wbi=0, wb[4]={0,0,0,0};\r\n\tuchar buf97[324], ci, cj, ck;\r\n\tshort sorder=p->order;\r\n\tchar buf[10];\r\n\t/*\r\n\tThe MakerNote might have its own TIFF header (possibly with\r\n\tits own byte-order!), or it might just be a table.\r\n\t*/\r\n\tdcr_fread(p->obj_, buf, 1, 10);\r\n\tif (!strncmp (buf,\"KDK\" ,3) ||\t/* these aren't TIFF tables */\r\n\t\t!strncmp (buf,\"VER\" ,3) ||\r\n\t\t!strncmp (buf,\"IIII\",4) ||\r\n\t\t!strncmp (buf,\"MMMM\",4)) return;\r\n\tif (!strncmp (buf,\"KC\"  ,2) ||\t/* Konica KD-400Z, KD-510Z */\r\n\t\t!strncmp (buf,\"MLY\" ,3)) {\t/* Minolta DiMAGE G series */\r\n\t\tp->order = 0x4d4d;\r\n\t\twhile ((long)(i=dcr_ftell(p->obj_)) < p->data_offset && i < 16384) {\r\n\t\t\twb[0] = wb[2];  wb[2] = wb[1];  wb[1] = wb[3];\r\n\t\t\twb[3] = dcr_get2(p);\r\n\t\t\tif (wb[1] == 256 && wb[3] == 256 &&\r\n\t\t\t\twb[0] > 256 && wb[0] < 640 && wb[2] > 256 && wb[2] < 640)\r\n\t\t\t\tFORC4 p->cam_mul[c] = (float)wb[c];\r\n\t\t}\r\n\t\tgoto quit;\r\n\t}\r\n\tif (!strcmp (buf,\"Nikon\")) {\r\n\t\tbase = dcr_ftell(p->obj_);\r\n\t\tp->order = dcr_get2(p);\r\n\t\tif (dcr_get2(p) != 42) goto quit;\r\n\t\toffset = dcr_get4(p);\r\n\t\tdcr_fseek(p->obj_, offset-8, SEEK_CUR);\r\n\t} else if (!strcmp (buf,\"OLYMPUS\")) {\r\n\t\tbase = dcr_ftell(p->obj_)-10;\r\n\t\tdcr_fseek(p->obj_, -2, SEEK_CUR);\r\n\t\tp->order = dcr_get2(p);  dcr_get2(p);\r\n\t} else if (!strncmp (buf,\"FUJIFILM\",8) ||\r\n\t\t!strncmp (buf,\"SONY\",4) ||\r\n\t\t!strcmp  (buf,\"Panasonic\")) {\r\n\t\tp->order = 0x4949;\r\n\t\tdcr_fseek(p->obj_,  2, SEEK_CUR);\r\n\t} else if (!strcmp (buf,\"OLYMP\") ||\r\n\t\t!strcmp (buf,\"LEICA\") ||\r\n\t\t!strcmp (buf,\"Ricoh\") ||\r\n\t\t!strcmp (buf,\"EPSON\"))\r\n\t\tdcr_fseek(p->obj_, -2, SEEK_CUR);\r\n\telse if (!strcmp (buf,\"AOC\") ||\r\n\t\t!strcmp (buf,\"QVC\"))\r\n\t\tdcr_fseek(p->obj_, -4, SEEK_CUR);\r\n\telse dcr_fseek(p->obj_, -10, SEEK_CUR);\r\n\r\n\tentries = dcr_get2(p);\r\n\tif (entries > 1000) return;\r\n\twhile (entries--) {\r\n\t\tdcr_tiff_get (p, base, &tag, &type, &len, &save);\r\n\t\ttag |= uptag << 16;\r\n\t\tif (tag == 2 && strstr(p->make,\"NIKON\"))\r\n\t\t\tp->iso_speed = (dcr_get2(p),dcr_get2(p));\r\n\t\tif (tag == 4 && len > 26 && len < 35) {\r\n\t\t\tif ((i=(dcr_get4(p),dcr_get2(p))) != 0x7fff && !p->iso_speed)\r\n\t\t\t\tp->iso_speed = 50 * (float)pow (2, i/32.0 - 4);\r\n\t\t\tif ((i=(dcr_get2(p),dcr_get2(p))) != 0x7fff && !p->aperture)\r\n\t\t\t\tp->aperture = (float)pow (2, i/64.0);\r\n\t\t\tif ((i=dcr_get2(p)) != 0xffff && !p->shutter)\r\n\t\t\t\tp->shutter = (float)pow (2, (short) i/-32.0);\r\n\t\t\twbi = (dcr_get2(p),dcr_get2(p));\r\n\t\t\tp->shot_order = (dcr_get2(p),dcr_get2(p));\r\n\t\t}\r\n\t\tif (tag == 7 && type == 2 && len > 20)\r\n\t\t\tdcr_fgets (p->obj_, p->model2, 64);\r\n\t\tif (tag == 8 && type == 4)\r\n\t\t\tp->shot_order = dcr_get4(p);\r\n\t\tif (tag == 9 && !strcmp(p->make,\"Canon\"))\r\n\t\t\tdcr_fread(p->obj_, p->artist, 64, 1);\r\n\t\tif (tag == 0xc && len == 4) {\r\n\t\t\tp->cam_mul[0] = (float)dcr_getreal(p,type);\r\n\t\t\tp->cam_mul[2] = (float)dcr_getreal(p,type);\r\n\t\t}\r\n\t\tif (tag == 0x10 && type == 4)\r\n\t\t\tp->unique_id = dcr_get4(p);\r\n\t\tif (tag == 0x11 && p->is_raw && !strncmp(p->make,\"NIKON\",5)) {\r\n\t\t\tdcr_fseek(p->obj_, dcr_get4(p)+base, SEEK_SET);\r\n\t\t\tdcr_parse_tiff_ifd (p, base);\r\n\t\t}\r\n\t\tif (tag == 0x14 && len == 2560 && type == 7) {\r\n\t\t\tdcr_fseek(p->obj_, 1248, SEEK_CUR);\r\n\t\t\tgoto get2_256;\r\n\t\t}\r\n\t\tif (tag == 0x15 && type == 2 && p->is_raw)\r\n\t\t\tdcr_fread(p->obj_, p->model, 64, 1);\r\n\t\tif (strstr(p->make,\"PENTAX\")) {\r\n\t\t\tif (tag == 0x1b) tag = 0x1018;\r\n\t\t\tif (tag == 0x1c) tag = 0x1017;\r\n\t\t}\r\n\t\tif (tag == 0x1d)\r\n\t\t\twhile ((c = dcr_fgetc(p->obj_)) && c != EOF)\r\n\t\t\t\tserial = serial*10 + (isdigit(c) ? c - '0' : c % 10);\r\n\t\tif (tag == 0x81 && type == 4) {\r\n\t\t\tp->data_offset = dcr_get4(p);\r\n\t\t\tdcr_fseek(p->obj_, p->data_offset + 41, SEEK_SET);\r\n\t\t\tp->raw_height = dcr_get2(p) * 2;\r\n\t\t\tp->raw_width  = dcr_get2(p);\r\n\t\t\tp->filters = 0x61616161;\r\n\t\t}\r\n\t\tif (tag == 0x29 && type == 1) {\r\n\t\t\tc = wbi < 18 ? \"012347800000005896\"[wbi]-'0' : 0;\r\n\t\t\tdcr_fseek(p->obj_, 8 + c*32, SEEK_CUR);\r\n\t\t\tFORC4 p->cam_mul[c ^ (c >> 1) ^ 1] = (float)dcr_get4(p);\r\n\t\t}\r\n\t\tif ((tag == 0x81  && type == 7) ||\r\n\t\t\t(tag == 0x100 && type == 7) ||\r\n\t\t\t(tag == 0x280 && type == 1)) {\r\n\t\t\tp->thumb_offset = dcr_ftell(p->obj_);\r\n\t\t\tp->thumb_length = len;\r\n\t\t}\r\n\t\tif (tag == 0x88 && type == 4 && (p->thumb_offset = dcr_get4(p)))\r\n\t\t\tp->thumb_offset += base;\r\n\t\tif (tag == 0x89 && type == 4)\r\n\t\t\tp->thumb_length = dcr_get4(p);\r\n\t\tif (tag == 0x8c || tag == 0x96)\r\n\t\t\tp->meta_offset = dcr_ftell(p->obj_);\r\n\t\tif (tag == 0x97) {\r\n\t\t\tfor (i=0; i < 4; i++)\r\n\t\t\t\tver97 = ver97 * 10 + dcr_fgetc(p->obj_)-'0';\r\n\t\t\tswitch (ver97) {\r\n\t\t\tcase 100:\r\n\t\t\t\tdcr_fseek(p->obj_, 68, SEEK_CUR);\r\n\t\t\t\tFORC4 p->cam_mul[(c >> 1) | ((c & 1) << 1)] = dcr_get2(p);\r\n\t\t\t\tbreak;\r\n\t\t\tcase 102:\r\n\t\t\t\tdcr_fseek(p->obj_, 6, SEEK_CUR);\r\n\t\t\t\tgoto get2_rggb;\r\n\t\t\tcase 103:\r\n\t\t\t\tdcr_fseek(p->obj_, 16, SEEK_CUR);\r\n\t\t\t\tFORC4 p->cam_mul[c] = dcr_get2(p);\r\n\t\t\t}\r\n\t\t\tif (ver97 >= 200) {\r\n\t\t\t\tif (ver97 != 205) dcr_fseek(p->obj_, 280, SEEK_CUR);\r\n\t\t\t\tdcr_fread(p->obj_, buf97, 324, 1);\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (tag == 0xa4 && type == 3) {\r\n\t\t\tdcr_fseek(p->obj_, wbi*48, SEEK_CUR);\r\n\t\t\tFORC3 p->cam_mul[c] = dcr_get2(p);\r\n\t\t}\r\n\t\tif (tag == 0xa7 && (unsigned) (ver97-200) < 12 && !p->cam_mul[0]) {\r\n\t\t\tci = xlat[0][serial & 0xff];\r\n\t\t\tcj = xlat[1][dcr_fgetc(p->obj_)^dcr_fgetc(p->obj_)^dcr_fgetc(p->obj_)^dcr_fgetc(p->obj_)];\r\n\t\t\tck = 0x60;\r\n\t\t\tfor (i=0; i < 324; i++)\r\n\t\t\t\tbuf97[i] ^= (cj += ci * ck++);\r\n\t\t\ti = \"66666>666;6A\"[ver97-200] - '0';\r\n\t\t\tFORC4 p->cam_mul[c ^ (c >> 1) ^ (i & 1)] =\r\n\t\t\t\tdcr_sget2 (p, buf97 + (i & -2) + c*2);\r\n\t\t}\r\n\t\tif (tag == 0x200 && len == 3)\r\n\t\t\tp->shot_order = (dcr_get4(p),dcr_get4(p));\r\n\t\tif (tag == 0x200 && len == 4)\r\n\t\t\tp->black = (dcr_get2(p)+dcr_get2(p)+dcr_get2(p)+dcr_get2(p))/4;\r\n\t\tif (tag == 0x201 && len == 4)\r\n\t\t\tgoto get2_rggb;\r\n\t\tif (tag == 0x220 && len == 53) {\r\n\t\t\tdcr_fseek (p->obj_, 14, SEEK_CUR);\r\n\t\t\tdcr_pentax_tree(p);\r\n\t\t}\r\n\t\tif (tag == 0x401 && len == 4) {\r\n\t\t\tp->black = (dcr_get4(p)+dcr_get4(p)+dcr_get4(p)+dcr_get4(p))/4;\r\n\t\t}\r\n\t\tif (tag == 0xe01) {\t\t/* Nikon Capture Note */\r\n\t\t\ttype = p->order;\r\n\t\t\tp->order = 0x4949;\r\n\t\t\tdcr_fseek(p->obj_, 22, SEEK_CUR);\r\n\t\t\tfor (offset=22; offset+22 < len; offset += 22+i) {\r\n\t\t\t\ttag = dcr_get4(p);\r\n\t\t\t\tdcr_fseek(p->obj_, 14, SEEK_CUR);\r\n\t\t\t\ti = dcr_get4(p)-4;\r\n\t\t\t\tif (tag == 0x76a43207) p->flip = dcr_get2(p);\r\n\t\t\t\telse dcr_fseek(p->obj_, i, SEEK_CUR);\r\n\t\t\t}\r\n\t\t\tp->order = type;\r\n\t\t}\r\n\t\tif (tag == 0xe80 && len == 256 && type == 7) {\r\n\t\t\tdcr_fseek(p->obj_, 48, SEEK_CUR);\r\n\t\t\tp->cam_mul[0] = dcr_get2(p) * 508 * 1.078f / 0x10000;\r\n\t\t\tp->cam_mul[2] = dcr_get2(p) * 382 * 1.173f / 0x10000;\r\n\t\t}\r\n\t\tif (tag == 0xf00 && type == 7) {\r\n\t\t\tif (len == 614)\r\n\t\t\t\tdcr_fseek(p->obj_, 176, SEEK_CUR);\r\n\t\t\telse if (len == 734 || len == 1502)\r\n\t\t\t\tdcr_fseek(p->obj_, 148, SEEK_CUR);\r\n\t\t\telse goto next;\r\n\t\t\tgoto get2_256;\r\n\t\t}\r\n\t\tif ((tag == 0x1011 && len == 9) || tag == 0x20400200)\r\n\t\t\tfor (i=0; i < 3; i++)\r\n\t\t\t\tFORC3 p->cmatrix[i][c] = ((short) dcr_get2(p)) / 256.0f;\r\n\t\tif ((tag == 0x1012 || tag == 0x20400600) && len == 4)\r\n\t\t\tfor (p->black = i=0; i < 4; i++)\r\n\t\t\t\tp->black += dcr_get2(p) << 2;\r\n\t\tif (tag == 0x1017 || tag == 0x20400100)\r\n\t\t\tp->cam_mul[0] = dcr_get2(p) / 256.0f;\r\n\t\tif (tag == 0x1018 || tag == 0x20400100)\r\n\t\t\tp->cam_mul[2] = dcr_get2(p) / 256.0f;\r\n\t\tif (tag == 0x2011 && len == 2) {\r\nget2_256:\r\n\t\tp->order = 0x4d4d;\r\n\t\tp->cam_mul[0] = dcr_get2(p) / 256.0f;\r\n\t\tp->cam_mul[2] = dcr_get2(p) / 256.0f;\r\n\t\t}\r\n\t\tif ((tag | 0x70) == 0x2070 && type == 4)\r\n\t\t\tdcr_fseek(p->obj_, dcr_get4(p)+base, SEEK_SET);\r\n\t\tif (tag == 0x2010 && type != 7)\r\n\t\t\tp->load_raw = &DCR_CLASS dcr_olympus_e410_load_raw;\r\n\t\tif (tag == 0x2020)\r\n\t\t\tdcr_parse_thumb_note (p, base, 257, 258);\r\n\t\tif (tag == 0x2040)\r\n\t\t\tdcr_parse_makernote (p, base, 0x2040);\r\n\t\tif (tag == 0xb028) {\r\n\t\t\tdcr_fseek(p->obj_, dcr_get4(p), SEEK_SET);\r\n\t\t\tdcr_parse_thumb_note (p, base, 136, 137);\r\n\t\t}\r\n\t\tif (tag == 0x4001 && len > 500) {\r\n\t\t\ti = len == 582 ? 50 : len == 653 ? 68 : len == 5120 ? 142 : 126;\r\n\t\t\tdcr_fseek(p->obj_, i, SEEK_CUR);\r\nget2_rggb:\r\n\t\t\tFORC4 p->cam_mul[c ^ (c >> 1)] = dcr_get2(p);\r\n\t\t\tdcr_fseek(p->obj_, 22, SEEK_CUR);\r\n\t\t\tFORC4 p->sraw_mul[c ^ (c >> 1)] = dcr_get2(p);\r\n\t\t}\r\nnext:\r\n\t\tdcr_fseek(p->obj_, save, SEEK_SET);\r\n  }\r\nquit:\r\n  p->order = sorder;\r\n}\r\n\r\n/*\r\nSince the TIFF DateTime string has no timezone information,\r\nassume that the camera's clock was set to Universal Time.\r\n*/\r\nvoid DCR_CLASS dcr_get_timestamp (DCRAW* p, int reversed)\r\n{\r\n\tstruct tm t;\r\n\tchar str[20];\r\n\tint i;\r\n\r\n\tstr[19] = 0;\r\n\tif (reversed)\r\n\t\tfor (i=19; i--; ) str[i] = dcr_fgetc(p->obj_);\r\n\telse\r\n\t\tdcr_fread(p->obj_, str, 19, 1);\r\n\tmemset (&t, 0, sizeof t);\r\n\tif (sscanf (str, \"%d:%d:%d %d:%d:%d\", &t.tm_year, &t.tm_mon,\r\n\t\t&t.tm_mday, &t.tm_hour, &t.tm_min, &t.tm_sec) != 6)\r\n\t\treturn;\r\n\tt.tm_year -= 1900;\r\n\tt.tm_mon -= 1;\r\n\tif (mktime(&t) > 0)\r\n\t\tp->timestamp = mktime(&t);\r\n}\r\n\r\nvoid DCR_CLASS dcr_parse_exif (DCRAW* p, int base)\r\n{\r\n\tunsigned kodak, entries, tag, type, len, save, c;\r\n\tdouble expo;\r\n\r\n\tkodak = !strncmp(p->make,\"EASTMAN\",7);\r\n\tentries = dcr_get2(p);\r\n\twhile (entries--) {\r\n\t\tdcr_tiff_get (p, base, &tag, &type, &len, &save);\r\n\t\tswitch (tag) {\r\n\t\tcase 33434:  p->shutter = (float)dcr_getreal(p,type);\t\t\tbreak;\r\n\t\tcase 33437:  p->aperture = (float)dcr_getreal(p,type);\t\t\tbreak;\r\n\t\tcase 34855:  p->iso_speed = dcr_get2(p);\t\t\tbreak;\r\n\t\tcase 36867:\r\n\t\tcase 36868:  dcr_get_timestamp(p,0);\t\t\tbreak;\r\n\t\tcase 37377:  if ((expo = -dcr_getreal(p,type)) < 128)\r\n\t\t\t\t\t\t p->shutter = (float)pow (2, expo);\t\tbreak;\r\n\t\tcase 37378:  p->aperture = (float)pow (2, dcr_getreal(p,type)/2);\tbreak;\r\n\t\tcase 37386:  p->focal_len = (float)dcr_getreal(p,type);\t\tbreak;\r\n\t\tcase 37500:  dcr_parse_makernote (p,base, 0);\t\tbreak;\r\n\t\tcase 40962:  if (kodak) p->raw_width  = dcr_get4(p);\tbreak;\r\n\t\tcase 40963:  if (kodak) p->raw_height = dcr_get4(p);\tbreak;\r\n\t\tcase 41730:\r\n\t\t\tif (dcr_get4(p) == 0x20002)\r\n\t\t\t\tfor (p->exif_cfa=c=0; c < 8; c+=2)\r\n\t\t\t\t\tp->exif_cfa |= dcr_fgetc(p->obj_) * 0x01010101 << c;\r\n\t\t}\r\n\t\tdcr_fseek(p->obj_, save, SEEK_SET);\r\n\t}\r\n}\r\n\r\nvoid DCR_CLASS dcr_parse_gps (DCRAW* p, int base)\r\n{\r\n  unsigned entries, tag, type, len, save, c;\r\n\r\n  entries = dcr_get2(p);\r\n  while (entries--) {\r\n    dcr_tiff_get (p, base, &tag, &type, &len, &save);\r\n    switch (tag) {\r\n    case 1: case 3: case 5:\r\n\t  p->gpsdata[29+tag/2] = dcr_fgetc(p->obj_);\tbreak;\r\n    case 2: case 4: case 7:\r\n\t  FORC(6) p->gpsdata[tag/3*6+c] = dcr_get4(p);\tbreak;\r\n    case 6:\r\n\t  FORC(2) p->gpsdata[18+c] = dcr_get4(p);\t\tbreak;\r\n    case 18: case 29:\r\n\t  dcr_fgets(p->obj_, (char *) (p->gpsdata+14+tag/3), MIN(len,12));\r\n    }\r\n    dcr_fseek(p->obj_, save, SEEK_SET);\r\n  }\r\n}\r\n\r\nvoid DCR_CLASS dcr_romm_coeff (DCRAW* p, float romm_cam[3][3])\r\n{\r\n\tstatic const float rgb_romm[3][3] =\t/* ROMM == Kodak ProPhoto */\r\n\t{ {  2.034193f, -0.727420f, -0.306766f },\r\n    { -0.228811f,  1.231729f, -0.002922f },\r\n    { -0.008565f, -0.153273f,  1.161839f } };\r\n\tint i, j, k;\r\n\r\n\tfor (i=0; i < 3; i++)\r\n\t\tfor (j=0; j < 3; j++)\r\n\t\t\tfor (p->cmatrix[i][j]=0, k=0; k < 3; k++)\r\n\t\t\t\tp->cmatrix[i][j] += rgb_romm[i][k] * romm_cam[k][j];\r\n}\r\n\r\nvoid DCR_CLASS dcr_parse_mos (DCRAW* p, int offset)\r\n{\r\n\tchar data[40];\r\n\tint skip, from, i=0, c, neut[4], planes=0, frot=0;\r\n\tstatic const char *mod[] =\r\n\t{ \"\",\"DCB2\",\"Volare\",\"Cantare\",\"CMost\",\"Valeo 6\",\"Valeo 11\",\"Valeo 22\",\r\n    \"Valeo 11p\",\"Valeo 17\",\"\",\"Aptus 17\",\"Aptus 22\",\"Aptus 75\",\"Aptus 65\",\r\n    \"Aptus 54S\",\"Aptus 65S\",\"Aptus 75S\",\"AFi 5\",\"AFi 6\",\"AFi 7\" };\r\n\tfloat romm_cam[3][3];\r\n\r\n\tdcr_fseek(p->obj_, offset, SEEK_SET);\r\n\twhile (1) {\r\n\t\tif (dcr_get4(p) != 0x504b5453) break;\r\n\t\tdcr_get4(p);\r\n\t\tdcr_fread(p->obj_, data, 1, 40);\r\n\t\tskip = dcr_get4(p);\r\n\t\tfrom = dcr_ftell(p->obj_);\r\n\t\tif (!strcmp(data,\"JPEG_preview_data\")) {\r\n\t\t\tp->thumb_offset = from;\r\n\t\t\tp->thumb_length = skip;\r\n\t\t}\r\n\t\tif (!strcmp(data,\"icc_camera_profile\")) {\r\n\t\t\tp->profile_offset = from;\r\n\t\t\tp->profile_length = skip;\r\n\t\t}\r\n\t\tif (!strcmp(data,\"ShootObj_back_type\")) {\r\n\t\t\tdcr_fscanf(p->obj_, \"%d\", &i);\r\n\t\t\tif ((unsigned) i < sizeof mod / sizeof (*mod))\r\n\t\t\t\tstrcpy (p->model, mod[i]);\r\n\t\t}\r\n\t\tif (!strcmp(data,\"icc_camera_to_tone_matrix\")) {\r\n\t\t\tfor (i=0; i < 9; i++)\r\n\t\t\t\tromm_cam[0][i] = dcr_int_to_float(dcr_get4(p));\r\n\t\t\tdcr_romm_coeff (p,romm_cam);\r\n\t\t}\r\n\t\tif (!strcmp(data,\"CaptProf_color_matrix\")) {\r\n\t\t\tfor (i=0; i < 9; i++)\r\n\t\t\t\tdcr_fscanf(p->obj_, \"%f\", &romm_cam[0][i]);\r\n\t\t\tdcr_romm_coeff (p,romm_cam);\r\n\t\t}\r\n\t\tif (!strcmp(data,\"CaptProf_number_of_planes\"))\r\n\t\t\tdcr_fscanf(p->obj_, \"%d\", &planes);\r\n\t\tif (!strcmp(data,\"CaptProf_raw_data_rotation\"))\r\n\t\t\tdcr_fscanf(p->obj_, \"%d\", &p->flip);\r\n\t\tif (!strcmp(data,\"CaptProf_mosaic_pattern\"))\r\n\t\t\tFORC4 {\r\n\t\t\tdcr_fscanf(p->obj_, \"%d\", &i);\r\n\t\t\tif (i == 1) frot = c ^ (c >> 1);\r\n\t\t}\r\n\t\tif (!strcmp(data,\"ImgProf_rotation_angle\")) {\r\n\t\t\tdcr_fscanf(p->obj_, \"%d\", &i);\r\n\t\t\tp->flip = i - p->flip;\r\n\t\t}\r\n\t\tif (!strcmp(data,\"NeutObj_neutrals\") && !p->cam_mul[0]) {\r\n\t\t\tFORC4 dcr_fscanf(p->obj_, \"%d\", neut+c);\r\n\t\t\tFORC3 p->cam_mul[c] = (neut[c+1] ? (float) neut[0] / neut[c+1] : 0);\r\n\t\t}\r\n\t\tdcr_parse_mos (p,from);\r\n\t\tdcr_fseek(p->obj_, skip+from, SEEK_SET);\r\n\t}\r\n\tif (planes)\r\n\t\tp->filters = (planes == 1) * 0x01010101 *\r\n\t\t(uchar) \"\\x94\\x61\\x16\\x49\"[(p->flip/90 + frot) & 3];\r\n}\r\n\r\nvoid DCR_CLASS dcr_linear_table (DCRAW* p, unsigned len)\r\n{\r\n\tint i;\r\n\tif (len > 0x1000) len = 0x1000;\r\n\tdcr_read_shorts (p, p->curve, len);\r\n\tfor (i=len; i < 0x1000; i++)\r\n\t\tp->curve[i] = p->curve[i-1];\r\n\tp->maximum = p->curve[0xfff];\r\n}\r\n\r\nvoid DCR_CLASS dcr_parse_kodak_ifd (DCRAW* p, int base)\r\n{\r\n\tunsigned entries, tag, type, len, save;\r\n\tint i, c, wbi=-2, wbtemp=6500;\r\n\tfloat mul[3], num;\r\n\r\n\tentries = dcr_get2(p);\r\n\tif (entries > 1024) return;\r\n\twhile (entries--) {\r\n\t\tdcr_tiff_get (p, base, &tag, &type, &len, &save);\r\n\t\tif (tag == 1020) wbi = dcr_getint(p, type);\r\n\t\tif (tag == 1021 && len == 72) {\t\t/* WB set in software */\r\n\t\t\tdcr_fseek(p->obj_, 40, SEEK_CUR);\r\n\t\t\tFORC3 p->cam_mul[c] = 2048.0f / dcr_get2(p);\r\n\t\t\twbi = -2;\r\n\t\t}\r\n\t\tif (tag == (unsigned int)2118) wbtemp = dcr_getint(p, type);\r\n\t\tif (tag == (unsigned int)2130 + wbi)\r\n\t\t\tFORC3 mul[c] = (float)dcr_getreal(p, type);\r\n\t\tif (tag == (unsigned int)2140 + wbi && wbi >= 0)\r\n\t\t\tFORC3 {\r\n\t\t\tfor (num=0.0f, i=0; i < 4; i++)\r\n\t\t\t\tnum += (float)(dcr_getreal(p, type) * pow (wbtemp/100.0, i));\r\n\t\t\tp->cam_mul[c] = 2048 / (num * mul[c]);\r\n\t\t}\r\n\t\tif (tag == 2317) dcr_linear_table (p,len);\r\n\t\tif (tag == 6020) p->iso_speed = (float)dcr_getint(p, type);\r\n\t\tdcr_fseek(p->obj_, save, SEEK_SET);\r\n\t}\r\n}\r\n\r\nvoid DCR_CLASS dcr_parse_minolta (DCRAW* p, int base);\r\n\r\nint DCR_CLASS dcr_parse_tiff_ifd (DCRAW* p, int base)\r\n{\r\n\tunsigned entries, tag, type, len, plen=16, save;\r\n\tint ifd, use_cm=0, cfa, i, j, c, ima_len=0;\r\n\tchar software[64], *cbuf, *cp;\r\n\tuchar cfa_pat[16], cfa_pc[] = { 0,1,2,3 }, tab[256];\r\n\tdouble dblack, cc[4][4], cm[4][3], cam_xyz[4][3], num;\r\n\tdouble ab[]={ 1,1,1,1 }, asn[] = { 0,0,0,0 }, xyz[] = { 1,1,1 };\r\n\tunsigned sony_curve[] = { 0,0,0,0,0,4095 };\r\n\tunsigned *buf, sony_offset=0, sony_length=0, sony_key=0;\r\n\tstruct dcr_jhead jh;\r\n\r\n\tif (p->tiff_nifds >= sizeof p->tiff_ifd / sizeof p->tiff_ifd[0])\r\n\t\treturn 1;\r\n\tifd = p->tiff_nifds++;\r\n\tfor (j=0; j < 4; j++)\r\n\t\tfor (i=0; i < 4; i++)\r\n\t\t\tcc[j][i] = i == j;\r\n\tentries = dcr_get2(p);\r\n\tif (entries > 512) return 1;\r\n\twhile (entries--) {\r\n\t\tdcr_tiff_get (p, base, &tag, &type, &len, &save);\r\n\t\tswitch (tag) {\r\n\t\tcase 17: case 18:\r\n\t\t\tif (type == 3 && len == 1)\r\n\t\t\t\tp->cam_mul[(tag-17)*2] = dcr_get2(p) / 256.0f;\r\n\t\t\tbreak;\r\n\t\tcase 23:\r\n\t\t\tif (type == 3) p->iso_speed = dcr_get2(p);\r\n\t\t\tbreak;\r\n\t\tcase 36: case 37: case 38:\r\n\t\t\tp->cam_mul[tag-0x24] = dcr_get2(p);\r\n\t\t\tbreak;\r\n\t\tcase 39:\r\n\t\t\tif (len < 50 || p->cam_mul[0]) break;\r\n\t\t\tdcr_fseek(p->obj_, 12, SEEK_CUR);\r\n\t\t\tFORC3 p->cam_mul[c] = dcr_get2(p);\r\n\t\t\tbreak;\r\n\t\tcase 46:\r\n\t\t\tif (type != 7 || dcr_fgetc(p->obj_) != 0xff || dcr_fgetc(p->obj_) != 0xd8) break;\r\n\t\t\tp->thumb_offset = dcr_ftell(p->obj_) - 2;\r\n\t\t\tp->thumb_length = len;\r\n\t\t\tbreak;\r\n\t\tcase 2: case 256:\t\t\t/* ImageWidth */\r\n\t\t\tp->tiff_ifd[ifd].width = dcr_getint(p, type);\r\n\t\t\tbreak;\r\n\t\tcase 3: case 257:\t\t\t/* ImageHeight */\r\n\t\t\tp->tiff_ifd[ifd].height = dcr_getint(p, type);\r\n\t\t\tbreak;\r\n\t\tcase 258:\t\t\t\t/* BitsPerSample */\r\n\t\t\tp->tiff_ifd[ifd].samples = len & 7;\r\n\t\t\tp->tiff_ifd[ifd].bps = dcr_get2(p);\r\n\t\t\tbreak;\r\n\t\tcase 259:\t\t\t\t/* Compression */\r\n\t\t\tp->tiff_ifd[ifd].comp = dcr_get2(p);\r\n\t\t\tbreak;\r\n\t\tcase 262:\t\t\t\t/* PhotometricInterpretation */\r\n\t\t\tp->tiff_ifd[ifd].phint = dcr_get2(p);\r\n\t\t\tbreak;\r\n\t\tcase 270:\t\t\t\t/* ImageDescription */\r\n\t\t\tdcr_fread(p->obj_, p->desc, 512, 1);\r\n\t\t\tbreak;\r\n\t\tcase 271:\t\t\t\t/* Make */\r\n\t\t\tdcr_fgets(p->obj_, p->make, 64);\r\n\t\t\tbreak;\r\n\t\tcase 272:\t\t\t\t/* Model */\r\n\t\t\tdcr_fgets(p->obj_, p->model, 64);\r\n\t\t\tbreak;\r\n\t\tcase 280:\t\t\t\t/* Panasonic RW2 offset */\r\n\t\t\tif (type != 4) break;\r\n\t\t\tp->load_raw = &DCR_CLASS dcr_panasonic_load_raw;\r\n\t\t\tp->load_flags = 0x2008;\r\n\t\tcase 273:\t\t\t\t/* StripOffset */\r\n\t\tcase 513:\r\n\t\t\tp->tiff_ifd[ifd].offset = dcr_get4(p)+base;\r\n\t\t\tif (!p->tiff_ifd[ifd].bps) {\r\n\t\t\t\tdcr_fseek(p->obj_, p->tiff_ifd[ifd].offset, SEEK_SET);\r\n\t\t\t\tif (dcr_ljpeg_start (p,&jh, 1)) {\r\n\t\t\t\t\tp->tiff_ifd[ifd].comp    = 6;\r\n\t\t\t\t\tp->tiff_ifd[ifd].width   = jh.wide << (jh.clrs == 2);\r\n\t\t\t\t\tp->tiff_ifd[ifd].height  = jh.high;\r\n\t\t\t\t\tp->tiff_ifd[ifd].bps     = jh.bits;\r\n\t\t\t\t\tp->tiff_ifd[ifd].samples = jh.clrs;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\tcase 274:\t\t\t\t/* Orientation */\r\n\t\t\tp->tiff_ifd[ifd].flip = \"50132467\"[dcr_get2(p) & 7]-'0';\r\n\t\t\tbreak;\r\n\t\tcase 277:\t\t\t\t/* SamplesPerPixel */\r\n\t\t\tp->tiff_ifd[ifd].samples = dcr_getint(p, type) & 7;\r\n\t\t\tbreak;\r\n\t\tcase 279:\t\t\t\t/* StripByteCounts */\r\n\t\tcase 514:\r\n\t\t\tp->tiff_ifd[ifd].bytes = dcr_get4(p);\r\n\t\t\tbreak;\r\n\t\tcase 305:  case 11:\t\t/* Software */\r\n\t\t\tdcr_fgets(p->obj_, software, 64);\r\n\t\t\tif (!strncmp(software,\"Adobe\",5) ||\r\n\t\t\t\t!strncmp(software,\"dcraw\",5) ||\r\n\t\t\t\t!strncmp(software,\"UFRaw\",5) ||\r\n\t\t\t\t!strncmp(software,\"Bibble\",6) ||\r\n\t\t\t\t!strncmp(software,\"Nikon Scan\",10) ||\r\n\t\t\t\t!strcmp (software,\"Digital Photo Professional\"))\r\n\t\t\t\tp->is_raw = 0;\r\n\t\t\tbreak;\r\n\t\tcase 306:\t\t\t\t/* DateTime */\r\n\t\t\tdcr_get_timestamp(p,0);\r\n\t\t\tbreak;\r\n\t\tcase 315:\t\t\t\t/* Artist */\r\n\t\t\tdcr_fread(p->obj_, p->artist, 64, 1);\r\n\t\t\tbreak;\r\n\t\tcase 322:\t\t\t\t/* TileWidth */\r\n\t\t\tp->tile_width = dcr_getint(p, type);\r\n\t\t\tbreak;\r\n\t\tcase 323:\t\t\t\t/* TileLength */\r\n\t\t\tp->tile_length = dcr_getint(p, type);\r\n\t\t\tbreak;\r\n\t\tcase 324:\t\t\t\t/* TileOffsets */\r\n\t\t\tp->tiff_ifd[ifd].offset = len > 1 ? dcr_ftell(p->obj_) : dcr_get4(p);\r\n\t\t\tif (len == 4) {\r\n\t\t\t\tp->load_raw = &DCR_CLASS dcr_sinar_4shot_load_raw;\r\n\t\t\t\tp->is_raw = 5;\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\tcase 330:\t\t\t\t/* SubIFDs */\r\n\t\t\tif (!strcmp(p->model,\"DSLR-A100\") && p->tiff_ifd[ifd].width == 3872) {\r\n\t\t\t\tp->load_raw = &DCR_CLASS dcr_sony_arw_load_raw;\r\n\t\t\t\tp->data_offset = dcr_get4(p)+base;\r\n\t\t\t\tifd++;  break;\r\n\t\t\t}\r\n\t\t\twhile (len--) {\r\n\t\t\t\ti = dcr_ftell(p->obj_);\r\n\t\t\t\tdcr_fseek(p->obj_, dcr_get4(p)+base, SEEK_SET);\r\n\t\t\t\tif (dcr_parse_tiff_ifd (p, base)) break;\r\n\t\t\t\tdcr_fseek(p->obj_, i+4, SEEK_SET);\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\tcase 400:\r\n\t\t\tstrcpy (p->make, \"Sarnoff\");\r\n\t\t\tp->maximum = 0xfff;\r\n\t\t\tbreak;\r\n\t\tcase 28688:\r\n\t\t\tFORC4 sony_curve[c+1] = dcr_get2(p) >> 2 & 0xfff;\r\n\t\t\tfor (i=0; i < 5; i++)\r\n\t\t\t\tfor (j = sony_curve[i]+1; j <= (int)sony_curve[i+1]; j++)\r\n\t\t\t\t\tp->curve[j] = p->curve[j-1] + (1 << i);\r\n\t\t\t\tbreak;\r\n\t\tcase 29184: sony_offset = dcr_get4(p);  break;\r\n\t\tcase 29185: sony_length = dcr_get4(p);  break;\r\n\t\tcase 29217: sony_key    = dcr_get4(p);  break;\r\n\t\tcase 29264:\r\n\t\t\tdcr_parse_minolta (p, dcr_ftell(p->obj_));\r\n\t\t\tp->raw_width = 0;\r\n\t\t\tbreak;\r\n\t\tcase 29443:\r\n\t\t\tFORC4 p->cam_mul[c ^ (c < 2)] = dcr_get2(p);\r\n\t\t\tbreak;\r\n\t\tcase 29459:\r\n\t\t\tFORC4 p->cam_mul[c ^ (c >> 1)] = dcr_get2(p);\r\n\t\t\tbreak;\r\n\t\tcase 33405:\t\t\t/* Model2 */\r\n\t\t\tdcr_fgets(p->obj_, p->model2, 64);\r\n\t\t\tbreak;\r\n\t\tcase 33422:\t\t\t/* CFAPattern */\r\n\t\tcase 64777:\t\t\t/* Kodak P-series */\r\n\t\t\tif ((plen=len) > 16) plen = 16;\r\n\t\t\tdcr_fread(p->obj_, cfa_pat, 1, plen);\r\n\t\t\tfor (p->colors=cfa=i=0; i < (int)plen; i++) {\r\n\t\t\t\tp->colors += !(cfa & (1 << cfa_pat[i]));\r\n\t\t\t\tcfa |= 1 << cfa_pat[i];\r\n\t\t\t}\r\n\t\t\tif (cfa == 070) memcpy (cfa_pc,\"\\003\\004\\005\",3);\t/* CMY */\r\n\t\t\tif (cfa == 072) memcpy (cfa_pc,\"\\005\\003\\004\\001\",4);\t/* GMCY */\r\n\t\t\tgoto guess_cfa_pc;\r\n\t\tcase 33424:\r\n\t\t\tdcr_fseek(p->obj_, dcr_get4(p)+base, SEEK_SET);\r\n\t\t\tdcr_parse_kodak_ifd (p,base);\r\n\t\t\tbreak;\r\n\t\tcase 33434:\t\t\t/* ExposureTime */\r\n\t\t\tp->shutter = (float)dcr_getreal(p,type);\r\n\t\t\tbreak;\r\n\t\tcase 33437:\t\t\t/* FNumber */\r\n\t\t\tp->aperture = (float)dcr_getreal(p,type);\r\n\t\t\tbreak;\r\n\t\tcase 34306:\t\t\t/* Leaf p->white balance */\r\n\t\t\tFORC4 p->cam_mul[c ^ 1] = 4096.0f / dcr_get2(p);\r\n\t\t\tbreak;\r\n\t\tcase 34307:\t\t\t/* Leaf CatchLight color matrix */\r\n\t\t\tdcr_fread(p->obj_, software, 1, 7);\r\n\t\t\tif (strncmp(software,\"MATRIX\",6)) break;\r\n\t\t\tp->colors = 4;\r\n\t\t\tfor (p->raw_color = i=0; i < 3; i++) {\r\n\t\t\t\tFORC4 dcr_fscanf(p->obj_, \"%f\", &p->rgb_cam[i][c^1]);\r\n\t\t\t\tif (!p->opt.use_camera_wb) continue;\r\n\t\t\t\tnum = 0;\r\n\t\t\t\tFORC4 num += p->rgb_cam[i][c];\r\n\t\t\t\tFORC4 p->rgb_cam[i][c] /= (float)num;\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\tcase 34310:\t\t\t/* Leaf metadata */\r\n\t\t\tdcr_parse_mos (p,dcr_ftell(p->obj_));\r\n\t\tcase 34303:\r\n\t\t\tstrcpy (p->make, \"Leaf\");\r\n\t\t\tbreak;\r\n\t\tcase 34665:\t\t\t/* EXIF tag */\r\n\t\t\tdcr_fseek(p->obj_, dcr_get4(p)+base, SEEK_SET);\r\n\t\t\tdcr_parse_exif (p,base);\r\n\t\t\tbreak;\r\n\t\tcase 34853:\t\t\t/* GPSInfo tag */\r\n\t\t\tdcr_fseek(p->obj_, dcr_get4(p)+base, SEEK_SET);\r\n\t\t\tdcr_parse_gps (p,base);\r\n\t\t\tbreak;\r\n\t\tcase 34675:\t\t\t/* InterColorProfile */\r\n\t\tcase 50831:\t\t\t/* AsShotICCProfile */\r\n\t\t\tp->profile_offset = dcr_ftell(p->obj_);\r\n\t\t\tp->profile_length = len;\r\n\t\t\tbreak;\r\n\t\tcase 37122:\t\t\t/* CompressedBitsPerPixel */\r\n\t\t\tp->kodak_cbpp = dcr_get4(p);\r\n\t\t\tbreak;\r\n\t\tcase 37386:\t\t\t/* FocalLength */\r\n\t\t\tp->focal_len = (float)dcr_getreal(p,type);\r\n\t\t\tbreak;\r\n\t\tcase 37393:\t\t\t/* ImageNumber */\r\n\t\t\tp->shot_order = dcr_getint(p, type);\r\n\t\t\tbreak;\r\n\t\tcase 37400:\t\t\t/* old Kodak KDC tag */\r\n\t\t\tfor (p->raw_color = i=0; i < 3; i++) {\r\n\t\t\t\tdcr_getreal(p,type);\r\n\t\t\t\tFORC3 p->rgb_cam[i][c] = (float)dcr_getreal(p,type);\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\tcase 46275:\t\t\t/* Imacon tags */\r\n\t\t\tstrcpy (p->make, \"Imacon\");\r\n\t\t\tp->data_offset = dcr_ftell(p->obj_);\r\n\t\t\tima_len = len;\r\n\t\t\tbreak;\r\n\t\tcase 46279:\r\n\t\t\tif (!ima_len) break;\r\n\t\t\tdcr_fseek(p->obj_, 78, SEEK_CUR);\r\n\t\t\tp->raw_width  = dcr_get4(p);\r\n\t\t\tp->raw_height = dcr_get4(p);\r\n\t\t\tp->left_margin = dcr_get4(p) & 7;\r\n\t\t\tp->width = p->raw_width - p->left_margin - (dcr_get4(p) & 7);\r\n\t\t\tp->top_margin = dcr_get4(p) & 7;\r\n\t\t\tp->height = p->raw_height - p->top_margin - (dcr_get4(p) & 7);\r\n\t\t\tif (p->raw_width == 7262) {\r\n\t\t\t\tp->height = 5444;\r\n\t\t\t\tp->width  = 7244;\r\n\t\t\t\tp->left_margin = 7;\r\n\t\t\t}\r\n\t\t\tdcr_fseek(p->obj_, 52, SEEK_CUR);\r\n\t\t\tFORC3 p->cam_mul[c] = (float)dcr_getreal(p, 11);\r\n\t\t\tdcr_fseek(p->obj_, 114, SEEK_CUR);\r\n\t\t\tp->flip = (dcr_get2(p) >> 7) * 90;\r\n\t\t\tif (p->width * p->height * 6 == ima_len) {\r\n\t\t\t\tif (p->flip % 180 == 90) SWAP(p->width,p->height);\r\n\t\t\t\tp->filters = p->flip = 0;\r\n\t\t\t}\r\n\t\t\tsprintf (p->model, \"Ixpress %d-Mp\", p->height*p->width/1000000);\r\n\t\t\tp->load_raw = &DCR_CLASS dcr_imacon_full_load_raw;\r\n\t\t\tif (p->filters) {\r\n\t\t\t\tif (p->left_margin & 1) p->filters = 0x61616161;\r\n\t\t\t\tp->load_raw = &DCR_CLASS dcr_unpacked_load_raw;\r\n\t\t\t}\r\n\t\t\tp->maximum = 0xffff;\r\n\t\t\tbreak;\r\n\t\tcase 50454:\t\t\t/* Sinar tag */\r\n\t\tcase 50455:\r\n\t\t\tif (!(cbuf = (char *) malloc(len))) break;\r\n\t\t\tdcr_fread(p->obj_, cbuf, 1, len);\r\n\t\t\tfor (cp = cbuf-1; cp && cp < cbuf+len; cp = strchr(cp,'\\n'))\r\n\t\t\t\tif (!strncmp (++cp,\"Neutral \",8))\r\n\t\t\t\t\tsscanf (cp+8, \"%f %f %f\", p->cam_mul, p->cam_mul+1, p->cam_mul+2);\r\n\t\t\tfree (cbuf);\r\n\t\t\tbreak;\r\n\t\tcase 50458:\r\n\t\t\tif (!p->make[0]) strcpy (p->make, \"Hasselblad\");\r\n\t\t\tbreak;\r\n\t\tcase 50459:\t\t\t/* Hasselblad tag */\r\n\t\t\ti = p->order;\r\n\t\t\tj = dcr_ftell(p->obj_);\r\n\t\t\tc = p->tiff_nifds;\r\n\t\t\tp->order = dcr_get2(p);\r\n\t\t\tdcr_fseek(p->obj_, j+(dcr_get2(p),dcr_get4(p)), SEEK_SET);\r\n\t\t\tdcr_parse_tiff_ifd (p, j);\r\n\t\t\tp->maximum = 0xffff;\r\n\t\t\tp->tiff_nifds = c;\r\n\t\t\tp->order = i;\r\n\t\t\tbreak;\r\n\t\tcase 50706:\t\t\t/* DNGVersion */\r\n\t\t\tFORC4 p->dng_version = (p->dng_version << 8) + dcr_fgetc(p->obj_);\r\n\t\t\tif (!p->make[0]) strcpy (p->make, \"DNG\");\r\n\t\t\tp->is_raw = 1;\r\n\t\t\tbreak;\r\n\t\tcase 50710:\t\t\t/* CFAPlaneColor */\r\n\t\t\tif (len > 4) len = 4;\r\n\t\t\tp->colors = len;\r\n\t\t\tdcr_fread(p->obj_, cfa_pc, 1, p->colors);\r\nguess_cfa_pc:\r\n\t\t\tFORCC(p) tab[cfa_pc[c]] = c;\r\n\t\t\tp->cdesc[c] = 0;\r\n\t\t\tfor (i=16; i--; )\r\n\t\t\t\tp->filters = p->filters << 2 | tab[cfa_pat[i % plen]];\r\n\t\t\tbreak;\r\n\t\tcase 50711:\t\t\t/* CFALayout */\r\n\t\t\tif (dcr_get2(p) == 2) {\r\n\t\t\t\tp->fuji_width = 1;\r\n\t\t\t\tp->filters = 0x49494949;\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\tcase 291:\r\n\t\tcase 50712:\t\t\t/* LinearizationTable */\r\n\t\t\tdcr_linear_table (p,len);\r\n\t\t\tbreak;\r\n\t\tcase 50714:\t\t\t/* BlackLevel */\r\n\t\tcase 50715:\t\t\t/* BlackLevelDeltaH */\r\n\t\tcase 50716:\t\t\t/* BlackLevelDeltaV */\r\n\t\t\tfor (dblack=i=0; i < (int)len; i++)\r\n\t\t\t\tdblack += dcr_getreal(p, type);\r\n\t\t\tp->black += (unsigned int)(dblack/len + 0.5);\r\n\t\t\tbreak;\r\n\t\tcase 50717:\t\t\t/* WhiteLevel */\r\n\t\t\tp->maximum = dcr_getint(p, type);\r\n\t\t\tbreak;\r\n\t\tcase 50718:\t\t\t/* DefaultScale */\r\n\t\t\tp->pixel_aspect  = dcr_getreal(p,type);\r\n\t\t\tp->pixel_aspect /= dcr_getreal(p,type);\r\n\t\t\tbreak;\r\n\t\tcase 50721:\t\t\t/* ColorMatrix1 */\r\n\t\tcase 50722:\t\t\t/* ColorMatrix2 */\r\n\t\t\tFORCC(p) for (j=0; j < 3; j++)\r\n\t\t\t\tcm[c][j] = dcr_getreal(p,type);\r\n\t\t\tuse_cm = 1;\r\n\t\t\tbreak;\r\n\t\tcase 50723:\t\t\t/* CameraCalibration1 */\r\n\t\tcase 50724:\t\t\t/* CameraCalibration2 */\r\n\t\t\tfor (i=0; i < p->colors; i++)\r\n\t\t\t\tFORCC(p) cc[i][c] = dcr_getreal(p,type);\r\n\t\tcase 50727:\t\t\t/* AnalogBalance */\r\n\t\t\tFORCC(p) ab[c] = dcr_getreal(p,type);\r\n\t\t\tbreak;\r\n\t\tcase 50728:\t\t\t/* AsShotNeutral */\r\n\t\t\tFORCC(p) asn[c] = dcr_getreal(p, type);\r\n\t\t\tbreak;\r\n\t\tcase 50729:\t\t\t/* AsShotWhiteXY */\r\n\t\t\txyz[0] = dcr_getreal(p,type);\r\n\t\t\txyz[1] = dcr_getreal(p,type);\r\n\t\t\txyz[2] = 1 - xyz[0] - xyz[1];\r\n\t\t\tFORC3 xyz[c] /= d65_white[c];\r\n\t\t\tbreak;\r\n\t\tcase 50740:\t\t\t/* DNGPrivateData */\r\n\t\t\tif (p->dng_version) break;\r\n\t\t\tdcr_parse_minolta (p, j = dcr_get4(p)+base);\r\n\t\t\tdcr_fseek(p->obj_, j, SEEK_SET);\r\n\t\t\tdcr_parse_tiff_ifd (p, base);\r\n\t\t\tbreak;\r\n\t\tcase 50752:\r\n\t\t\tdcr_read_shorts (p, p->cr2_slice, 3);\r\n\t\t\tbreak;\r\n\t\tcase 50829:\t\t\t/* ActiveArea */\r\n\t\t\tp->top_margin = dcr_getint(p, type);\r\n\t\t\tp->left_margin = dcr_getint(p, type);\r\n\t\t\tp->height = dcr_getint(p, type) - p->top_margin;\r\n\t\t\tp->width = dcr_getint(p, type) - p->left_margin;\r\n\t\t\tbreak;\r\n\t\tcase 64772:\t\t\t/* Kodak P-series */\r\n\t\t\tdcr_fseek(p->obj_, 16, SEEK_CUR);\r\n\t\t\tp->data_offset = dcr_get4(p);\r\n\t\t\tdcr_fseek(p->obj_, 28, SEEK_CUR);\r\n\t\t\tp->data_offset += dcr_get4(p);\r\n\t\t\tp->load_raw = &DCR_CLASS dcr_packed_12_load_raw;\r\n    }\r\n    dcr_fseek(p->obj_, save, SEEK_SET);\r\n  }\r\n  if (sony_length && (buf = (unsigned *) malloc(sony_length))) {\r\n\t  dcr_stream_ops *sops_;\r\n\t  dcr_stream_obj *sobj_;\r\n\t  dcr_fseek(p->obj_, sony_offset, SEEK_SET);\r\n\t  dcr_fread(p->obj_, buf, sony_length, 1);\r\n\t  dcr_sony_decrypt (buf, sony_length/4, 1, sony_key);\r\n\r\n\t  sops_ = p->ops_;\r\n\t  sobj_ = p->obj_;\r\n  \t  p->ops_ = &dcr_stream_fileops;\r\n\t  if ((p->obj_ = tmpfile())) {\r\n\t\t  dcr_fwrite(p->obj_, buf, sony_length, 1);\r\n\t\t  dcr_fseek(p->obj_, 0, SEEK_SET);\r\n\t\t  dcr_parse_tiff_ifd (p, -(int)sony_offset);\r\n\t\t  dcr_fclose(p->obj_);\r\n\t  }\r\n\t  p->ops_ = sops_;\r\n\t  p->obj_ = sobj_;\r\n\r\n\t  free (buf);\r\n  }\r\n  for (i=0; i < p->colors; i++)\r\n\t  FORCC(p) cc[i][c] *= ab[i];\r\n  if (use_cm) {\r\n\t  FORCC(p) for (i=0; i < 3; i++)\r\n\t\t  for (cam_xyz[c][i]=j=0; j < p->colors; j++)\r\n\t\t\t  cam_xyz[c][i] += cc[c][j] * cm[j][i] * xyz[i];\r\n\t\t  dcr_cam_xyz_coeff (p, cam_xyz);\r\n  }\r\n  if (asn[0]) {\r\n\t  p->cam_mul[3] = 0;\r\n\t  FORCC(p) p->cam_mul[c] = 1.0f / (float)asn[c];\r\n  }\r\n  if (!use_cm)\r\n\t  FORCC(p) p->pre_mul[c] /= (float)cc[c][c];\r\n  return 0;\r\n}\r\n\r\nvoid DCR_CLASS dcr_parse_tiff (DCRAW* p, int base)\r\n{\r\n\tint doff, max_samp=0, raw=-1, thm=-1, i;\r\n\tstruct dcr_jhead jh;\r\n\r\n\tdcr_fseek(p->obj_, base, SEEK_SET);\r\n\tp->order = dcr_get2(p);\r\n\tif (p->order != 0x4949 && p->order != 0x4d4d) return;\r\n\tdcr_get2(p);\r\n\tmemset (p->tiff_ifd, 0, sizeof p->tiff_ifd);\r\n\tp->tiff_nifds = 0;\r\n\twhile ((doff = dcr_get4(p))) {\r\n\t\tdcr_fseek(p->obj_, doff+base, SEEK_SET);\r\n\t\tif (dcr_parse_tiff_ifd (p, base)) break;\r\n\t}\r\n\tp->thumb_misc = 16;\r\n\tif (p->thumb_offset) {\r\n\t\tdcr_fseek(p->obj_, p->thumb_offset, SEEK_SET);\r\n\t\tif (dcr_ljpeg_start (p,&jh, 1)) {\r\n\t\t\tp->thumb_misc   = jh.bits;\r\n\t\t\tp->thumb_width  = jh.wide;\r\n\t\t\tp->thumb_height = jh.high;\r\n\t\t}\r\n\t}\r\n\tfor (i=0; i < (int)p->tiff_nifds; i++) {\r\n\t\tif (max_samp < p->tiff_ifd[i].samples)\r\n\t\t\tmax_samp = p->tiff_ifd[i].samples;\r\n\t\tif (max_samp > 3) max_samp = 3;\r\n\t\tif ((p->tiff_ifd[i].comp != 6 || p->tiff_ifd[i].samples != 3) &&\r\n\t\t\tp->tiff_ifd[i].width*p->tiff_ifd[i].height > p->raw_width*p->raw_height) {\r\n\t\t\tp->raw_width     = p->tiff_ifd[i].width;\r\n\t\t\tp->raw_height    = p->tiff_ifd[i].height;\r\n\t\t\tp->tiff_bps      = p->tiff_ifd[i].bps;\r\n\t\t\tp->tiff_compress = p->tiff_ifd[i].comp;\r\n\t\t\tp->data_offset   = p->tiff_ifd[i].offset;\r\n\t\t\tp->tiff_flip     = p->tiff_ifd[i].flip;\r\n\t\t\tp->tiff_samples  = p->tiff_ifd[i].samples;\r\n\t\t\traw = i;\r\n\t\t}\r\n\t}\r\n\tp->fuji_width *= (p->raw_width+1)/2;\r\n\tif (p->tiff_ifd[0].flip) p->tiff_flip = p->tiff_ifd[0].flip;\r\n\tif (raw >= 0 && !p->load_raw)\r\n\t\tswitch (p->tiff_compress) {\r\n\tcase 0:  case 1:\r\n\t\tswitch (p->tiff_bps) {\r\n\t\tcase  8: p->load_raw = &DCR_CLASS dcr_eight_bit_load_raw;\tbreak;\r\n\t\tcase 12: p->load_raw = &DCR_CLASS dcr_packed_12_load_raw;\r\n\t\t\tif (p->tiff_ifd[raw].phint == 2)\r\n\t\t\t\tp->load_flags = 6;\r\n\t\t\tif (strncmp(p->make,\"PENTAX\",6)) break;\r\n\t\tcase 14:\r\n\t\tcase 16: p->load_raw = &DCR_CLASS dcr_unpacked_load_raw;\t\tbreak;\r\n\t\t}\r\n\t\tif (p->tiff_ifd[raw].bytes*5 == p->raw_width*p->raw_height*8)\r\n\t\t\tp->load_raw = &DCR_CLASS dcr_olympus_e300_load_raw;\r\n\t\tbreak;\r\n\t\tcase 6:  case 7:  case 99:\r\n\t\t\tp->load_raw = &DCR_CLASS dcr_lossless_jpeg_load_raw;\t\tbreak;\r\n\t\tcase 262:\r\n\t\t\tp->load_raw = &DCR_CLASS dcr_kodak_262_load_raw;\t\t\tbreak;\r\n\t\tcase 32767:\r\n\t\t\tp->load_raw = &DCR_CLASS dcr_sony_arw2_load_raw;\r\n\t\t\tif (p->tiff_ifd[raw].bytes*8 == (int)(p->raw_width*p->raw_height*p->tiff_bps))\r\n\t\t\t\tbreak;\r\n\t\t\tp->raw_height += 8;\r\n\t\t\tp->load_raw = &DCR_CLASS dcr_sony_arw_load_raw;\t\t\tbreak;\r\n\t\tcase 32769:\r\n\t\t\tp->load_flags = 8;\r\n\t\tcase 32773:\r\n\t\t\tp->load_raw = &DCR_CLASS dcr_packed_12_load_raw;\t\t\tbreak;\r\n\t\tcase 34713:\r\n\t\t\tp->load_raw = &DCR_CLASS dcr_nikon_compressed_load_raw;\t\tbreak;\r\n\t\tcase 65535:\r\n\t\t\tp->load_raw = &DCR_CLASS dcr_pentax_k10_load_raw;\t\t\tbreak;\r\n\t\tcase 65000:\r\n\t\t\tswitch (p->tiff_ifd[raw].phint) {\r\n\t\t\tcase 2: p->load_raw = &DCR_CLASS dcr_kodak_rgb_load_raw;   p->filters = 0;  break;\r\n\t\t\tcase 6: p->load_raw = &DCR_CLASS dcr_kodak_ycbcr_load_raw; p->filters = 0;  break;\r\n\t\t\tcase 32803: p->load_raw = &DCR_CLASS dcr_kodak_65000_load_raw;\r\n\t\t\t}\r\n\t\t\tcase 32867: break;\r\n\t\t\tdefault: p->is_raw = 0;\r\n    }\r\n\tif (!p->dng_version && p->tiff_samples == 3)\r\n\t\tif (p->tiff_ifd[raw].bytes && p->tiff_bps != 14 && p->tiff_bps != 2048)\r\n\t\t\tp->is_raw = 0;\r\n\tif (!p->dng_version && p->tiff_bps == 8 && p->tiff_compress == 1 &&\r\n\t\tp->tiff_ifd[raw].phint == 1) p->is_raw = 0;\r\n\tif (p->tiff_bps == 8 && p->tiff_samples == 4) p->is_raw = 0;\r\n\tfor (i=0; i < (int)p->tiff_nifds; i++)\r\n    {\r\n        int sqr_1 = SQR(p->tiff_ifd[i].bps+1); if (sqr_1 == 0) sqr_1 = 1;\r\n        int sqr_2 = SQR(p->thumb_misc+1); if (sqr_2 == 0) sqr_2 = 1;\r\n\t\tif (i != raw && p->tiff_ifd[i].samples == max_samp &&\r\n            p->tiff_ifd[i].width * p->tiff_ifd[i].height / sqr_1 >\r\n            (int)(p->thumb_width *       p->thumb_height / sqr_2)) {\r\n\t\t\tp->thumb_width  = p->tiff_ifd[i].width;\r\n\t\t\tp->thumb_height = p->tiff_ifd[i].height;\r\n\t\t\tp->thumb_offset = p->tiff_ifd[i].offset;\r\n\t\t\tp->thumb_length = p->tiff_ifd[i].bytes;\r\n\t\t\tp->thumb_misc   = p->tiff_ifd[i].bps;\r\n\t\t\tthm = i;\r\n\t\t}\r\n    }\r\n\tif (thm >= 0) {\r\n\t\tp->thumb_misc |= p->tiff_ifd[thm].samples << 5;\r\n\t\tswitch (p->tiff_ifd[thm].comp) {\r\n\t\tcase 0:\r\n\t\t\tp->write_thumb = &DCR_CLASS dcr_layer_thumb;\r\n\t\t\tbreak;\r\n\t\tcase 1:\r\n\t\t\tif (p->tiff_ifd[thm].bps > 8)\r\n\t\t\t\tp->thumb_load_raw = &DCR_CLASS dcr_kodak_thumb_load_raw;\r\n\t\t\telse\r\n\t\t\t\tp->write_thumb = &DCR_CLASS dcr_ppm_thumb;\r\n\t\t\tbreak;\r\n\t\tcase 65000:\r\n\t\t\tp->thumb_load_raw = p->tiff_ifd[thm].phint == 6 ?\r\n\t\t\t\t&DCR_CLASS dcr_kodak_ycbcr_load_raw : &DCR_CLASS dcr_kodak_rgb_load_raw;\r\n\t\t}\r\n\t}\r\n}\r\n\r\nvoid DCR_CLASS dcr_parse_minolta (DCRAW* p, int base)\r\n{\r\n\tint save, tag, len, offset, high=0, wide=0, i, c;\r\n\tshort sorder=p->order;\r\n\r\n\tdcr_fseek(p->obj_, base, SEEK_SET);\r\n\tif (dcr_fgetc(p->obj_) || dcr_fgetc(p->obj_)-'M' || dcr_fgetc(p->obj_)-'R') return;\r\n\tp->order = dcr_fgetc(p->obj_) * 0x101;\r\n\toffset = base + dcr_get4(p) + 8;\r\n\twhile ((save=dcr_ftell(p->obj_)) < offset) {\r\n\t\tfor (tag=i=0; i < 4; i++)\r\n\t\t\ttag = tag << 8 | dcr_fgetc(p->obj_);\r\n\t\tlen = dcr_get4(p);\r\n\t\tswitch (tag) {\r\n\t\tcase 0x505244:\t\t\t\t/* PRD */\r\n\t\t\tdcr_fseek(p->obj_, 8, SEEK_CUR);\r\n\t\t\thigh = dcr_get2(p);\r\n\t\t\twide = dcr_get2(p);\r\n\t\t\tbreak;\r\n\t\tcase 0x574247:\t\t\t\t/* WBG */\r\n\t\t\tdcr_get4(p);\r\n\t\t\ti = strcmp(p->model,\"DiMAGE A200\") ? 0:3;\r\n\t\t\tFORC4 p->cam_mul[c ^ (c >> 1) ^ i] = dcr_get2(p);\r\n\t\t\tbreak;\r\n\t\tcase 0x545457:\t\t\t\t/* TTW */\r\n\t\t\tdcr_parse_tiff (p, dcr_ftell(p->obj_));\r\n\t\t\tp->data_offset = offset;\r\n\t\t}\r\n\t\tdcr_fseek(p->obj_, save+len+8, SEEK_SET);\r\n\t}\r\n\tp->raw_height = high;\r\n\tp->raw_width  = wide;\r\n\tp->order = sorder;\r\n}\r\n\r\n/*\r\nMany cameras have a \"debug mode\" that writes JPEG and raw\r\nat the same time.  The raw file has no header, so try to\r\nto open the matching JPEG file and read its metadata.\r\n*/\r\nvoid DCR_CLASS dcr_parse_external_jpeg(DCRAW* p)\r\n{\r\n\tchar *file, *ext, *jname, *jfile, *jext;\r\n\tdcr_stream_ops *sops_;\r\n\tdcr_stream_obj *sobj_;\r\n\r\n\text  = strrchr (p->ifname, '.');\r\n\tfile = strrchr (p->ifname, '/');\r\n\tif (!file) file = strrchr (p->ifname, '\\\\');\r\n\tif (!file) file = p->ifname-1;\r\n\tfile++;\r\n\tif (!ext || strlen(ext) != 4 || ext-file != 8) return;\r\n\tjname = (char *) malloc (strlen(p->ifname) + 1);\r\n\tdcr_merror (p, jname, \"parse_external_jpeg()\");\r\n\tstrcpy (jname, p->ifname);\r\n\tjfile = file - p->ifname + jname;\r\n\tjext  = ext  - p->ifname + jname;\r\n\tif (strcasecmp (ext, \".jpg\")) {\r\n\t\tstrcpy (jext, isupper(ext[1]) ? \".JPG\":\".jpg\");\r\n\t\tif (isdigit(*file)) {\r\n\t\t\tmemcpy (jfile, file+4, 4);\r\n\t\t\tmemcpy (jfile+4, file, 4);\r\n\t\t}\r\n\t} else\r\n\t\twhile (isdigit(*--jext)) {\r\n\t\t\tif (*jext != '9') {\r\n\t\t\t\t(*jext)++;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\t*jext = '0';\r\n\t\t}\r\n\tif (strcmp (jname, p->ifname)) {\r\n\r\n\t\tsops_ = p->ops_;\r\n\t\tsobj_ = p->obj_;\r\n  \t\tp->ops_ = &dcr_stream_fileops;\r\n\r\n\t\tif ((p->obj_ = fopen (jname, \"rb\"))) {\r\n\t\t\tif (p->opt.verbose)\r\n\t\t\t\tfprintf (stderr,_(\"Reading metadata from %s ...\\n\"), jname);\r\n\t\t\tdcr_parse_tiff (p, 12);\r\n\t\t\tp->thumb_offset = 0;\r\n\t\t\tp->is_raw = 1;\r\n\t\t\tdcr_fclose(p->obj_);\r\n\t\t}\r\n\r\n\t\tp->ops_ = sops_;\r\n\t\tp->obj_ = sobj_;\r\n\r\n\t}\r\n\tif (!p->timestamp)\r\n\t\tfprintf (stderr,_(\"Failed to read metadata from %s\\n\"), jname);\r\n\tfree (jname);\r\n}\r\n\r\n/*\r\nCIFF block 0x1030 contains an 8x8 p->white sample.\r\nLoad this into p->white[][] for use in scale_colors().\r\n*/\r\nvoid DCR_CLASS dcr_ciff_block_1030(DCRAW* p)\r\n{\r\n\tstatic const ushort key[] = { 0x410, 0x45f3 };\r\n\tint i, bpp, row, col, vbits=0;\r\n\tunsigned long bitbuf=0;\r\n\r\n\tif ((dcr_get2(p),dcr_get4(p)) != 0x80008 || !dcr_get4(p)) return;\r\n\tbpp = dcr_get2(p);\r\n\tif (bpp != 10 && bpp != 12) return;\r\n\tfor (i=row=0; row < 8; row++)\r\n\t\tfor (col=0; col < 8; col++) {\r\n\t\t\tif (vbits < bpp) {\r\n\t\t\t\tbitbuf = bitbuf << 16 | (dcr_get2(p) ^ key[i++ & 1]);\r\n\t\t\t\tvbits += 16;\r\n\t\t\t}\r\n\t\t\tp->white[row][col] = (unsigned short)(\r\n\t\t\t\tbitbuf << (LONG_BIT - vbits) >> (LONG_BIT - bpp));\r\n\t\t\tvbits -= bpp;\r\n\t\t}\r\n}\r\n\r\n/*\r\nParse a CIFF file, better known as Canon CRW format.\r\n*/\r\nvoid DCR_CLASS dcr_parse_ciff (DCRAW* p, int offset, int length)\r\n{\r\n\tint tboff, nrecs, c, type, len, save, wbi=-1;\r\n\tushort key[] = { 0x410, 0x45f3 };\r\n\r\n\tdcr_fseek(p->obj_, offset+length-4, SEEK_SET);\r\n\ttboff = dcr_get4(p) + offset;\r\n\tdcr_fseek(p->obj_, tboff, SEEK_SET);\r\n\tnrecs = dcr_get2(p);\r\n\tif (nrecs > 100) return;\r\n\twhile (nrecs--) {\r\n\t\ttype = dcr_get2(p);\r\n\t\tlen  = dcr_get4(p);\r\n\t\tsave = dcr_ftell(p->obj_) + 4;\r\n\t\tdcr_fseek(p->obj_, offset+dcr_get4(p), SEEK_SET);\r\n\t\tif ((((type >> 8) + 8) | 8) == 0x38)\r\n\t\t\tdcr_parse_ciff (p,dcr_ftell(p->obj_), len);\t/* Parse a sub-table */\r\n\r\n\t\tif (type == 0x0810)\r\n\t\t\tdcr_fread(p->obj_, p->artist, 64, 1);\r\n\t\tif (type == 0x080a) {\r\n\t\t\tdcr_fread(p->obj_, p->make, 64, 1);\r\n\t\t\tdcr_fseek(p->obj_, strlen(p->make) - 63, SEEK_CUR);\r\n\t\t\tdcr_fread(p->obj_, p->model, 64, 1);\r\n\t\t}\r\n\t\tif (type == 0x1810) {\r\n\t\t\tdcr_fseek(p->obj_, 12, SEEK_CUR);\r\n\t\t\tp->flip = dcr_get4(p);\r\n\t\t}\r\n\t\tif (type == 0x1835)\t\t\t/* Get the decoder table */\r\n\t\t\tp->tiff_compress = dcr_get4(p);\r\n\t\tif (type == 0x2007) {\r\n\t\t\tp->thumb_offset = dcr_ftell(p->obj_);\r\n\t\t\tp->thumb_length = len;\r\n\t\t}\r\n\t\tif (type == 0x1818) {\r\n\t\t\tp->shutter = (float)pow (2, -dcr_int_to_float((dcr_get4(p),dcr_get4(p))));\r\n\t\t\tp->aperture = (float)pow (2, dcr_int_to_float(dcr_get4(p))/2);\r\n\t\t}\r\n\t\tif (type == 0x102a) {\r\n\t\t\tp->iso_speed = (float)pow (2, (dcr_get4(p),dcr_get2(p))/32.0f - 4) * 50;\r\n\t\t\tp->aperture  = (float)pow (2, (dcr_get2(p),(short)dcr_get2(p))/64.0f);\r\n\t\t\tp->shutter   = (float)pow (2,-((short)dcr_get2(p))/32.0f);\r\n\t\t\twbi = (dcr_get2(p),dcr_get2(p));\r\n\t\t\tif (wbi > 17) wbi = 0;\r\n\t\t\tdcr_fseek(p->obj_, 32, SEEK_CUR);\r\n\t\t\tif (p->shutter > 1e6) p->shutter = dcr_get2(p)/10.0f;\r\n\t\t}\r\n\t\tif (type == 0x102c) {\r\n\t\t\tif (dcr_get2(p) > 512) {\t\t/* Pro90, G1 */\r\n\t\t\t\tdcr_fseek(p->obj_, 118, SEEK_CUR);\r\n\t\t\t\tFORC4 p->cam_mul[c ^ 2] = dcr_get2(p);\r\n\t\t\t} else {\t\t\t\t/* G2, S30, S40 */\r\n\t\t\t\tdcr_fseek(p->obj_, 98, SEEK_CUR);\r\n\t\t\t\tFORC4 p->cam_mul[c ^ (c >> 1) ^ 1] = dcr_get2(p);\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (type == 0x0032) {\r\n\t\t\tif (len == 768) {\t\t\t/* EOS D30 */\r\n\t\t\t\tdcr_fseek(p->obj_, 72, SEEK_CUR);\r\n\t\t\t\tFORC4 p->cam_mul[c ^ (c >> 1)] = 1024.0f / dcr_get2(p);\r\n\t\t\t\tif (!wbi) p->cam_mul[0] = -1;\t/* use my auto p->white balance */\r\n\t\t\t} else if (!p->cam_mul[0]) {\r\n\t\t\t\tif (dcr_get2(p) == key[0])\t\t/* Pro1, G6, S60, S70 */\r\n\t\t\t\t\tc = (strstr(p->model,\"Pro1\") ?\r\n\t\t\t\t\t\"012346000000000000\":\"01345:000000006008\")[wbi]-'0'+ 2;\r\n\t\t\t\telse {\t\t\t\t/* G3, G5, S45, S50 */\r\n\t\t\t\t\tc = \"023457000000006000\"[wbi]-'0';\r\n\t\t\t\t\tkey[0] = key[1] = 0;\r\n\t\t\t\t}\r\n\t\t\t\tdcr_fseek(p->obj_, 78 + c*8, SEEK_CUR);\r\n\t\t\t\tFORC4 p->cam_mul[c ^ (c >> 1) ^ 1] = (float)(dcr_get2(p) ^ key[c & 1]);\r\n\t\t\t\tif (!wbi) p->cam_mul[0] = -1;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (type == 0x10a9) {\t\t/* D60, 10D, 300D, and clones */\r\n\t\t\tif (len > 66) wbi = \"0134567028\"[wbi]-'0';\r\n\t\t\tdcr_fseek(p->obj_, 2 + wbi*8, SEEK_CUR);\r\n\t\t\tFORC4 p->cam_mul[c ^ (c >> 1)] = dcr_get2(p);\r\n\t\t}\r\n\t\tif (type == 0x1030 && (0x18040 >> wbi & 1))\r\n\t\t\tdcr_ciff_block_1030(p);\t\t/* all that don't have 0x10a9 */\r\n\t\tif (type == 0x1031) {\r\n\t\t\tp->raw_width = (dcr_get2(p),dcr_get2(p));\r\n\t\t\tp->raw_height = dcr_get2(p);\r\n\t\t}\r\n\t\tif (type == 0x5029) {\r\n\t\t\tp->focal_len = (float)(len >> 16);\r\n\t\t\tif ((len & 0xffff) == 2) p->focal_len /= 32;\r\n\t\t}\r\n\t\tif (type == 0x5813) p->flash_used = dcr_int_to_float(len);\r\n\t\tif (type == 0x5814) p->canon_ev   = dcr_int_to_float(len);\r\n\t\tif (type == 0x5817) p->shot_order = len;\r\n\t\tif (type == 0x5834) p->unique_id  = len;\r\n\t\tif (type == 0x580e) p->timestamp  = len;\r\n\t\tif (type == 0x180e) p->timestamp  = dcr_get4(p);\r\n#ifdef LOCALTIME\r\n\t\tif ((type | 0x4000) == 0x580e)\r\n\t\t\tp->timestamp = mktime (gmtime (&p->timestamp));\r\n#endif\r\n\t\tdcr_fseek(p->obj_, save, SEEK_SET);\r\n\t}\r\n}\r\n\r\nvoid DCR_CLASS dcr_parse_rollei(DCRAW* p)\r\n{\r\n\tchar line[128], *val;\r\n\tstruct tm t;\r\n\r\n\tdcr_fseek(p->obj_, 0, SEEK_SET);\r\n\tmemset (&t, 0, sizeof t);\r\n\tdo {\r\n\t\tdcr_fgets(p->obj_, line, 128);\r\n\t\tif ((val = strchr(line,'=')))\r\n\t\t\t*val++ = 0;\r\n\t\telse\r\n\t\t\tval = line + strlen(line);\r\n\t\tif (!strcmp(line,\"DAT\"))\r\n\t\t\tsscanf (val, \"%d.%d.%d\", &t.tm_mday, &t.tm_mon, &t.tm_year);\r\n\t\tif (!strcmp(line,\"TIM\"))\r\n\t\t\tsscanf (val, \"%d:%d:%d\", &t.tm_hour, &t.tm_min, &t.tm_sec);\r\n\t\tif (!strcmp(line,\"HDR\"))\r\n\t\t\tp->thumb_offset = atoi(val);\r\n\t\tif (!strcmp(line,\"X  \"))\r\n\t\t\tp->raw_width = atoi(val);\r\n\t\tif (!strcmp(line,\"Y  \"))\r\n\t\t\tp->raw_height = atoi(val);\r\n\t\tif (!strcmp(line,\"TX \"))\r\n\t\t\tp->thumb_width = atoi(val);\r\n\t\tif (!strcmp(line,\"TY \"))\r\n\t\t\tp->thumb_height = atoi(val);\r\n\t} while (strncmp(line,\"EOHD\",4));\r\n\tp->data_offset = p->thumb_offset + p->thumb_width * p->thumb_height * 2;\r\n\tt.tm_year -= 1900;\r\n\tt.tm_mon -= 1;\r\n\tif (mktime(&t) > 0)\r\n\t\tp->timestamp = mktime(&t);\r\n\tstrcpy (p->make, \"Rollei\");\r\n\tstrcpy (p->model,\"d530flex\");\r\n\tp->write_thumb = &DCR_CLASS dcr_rollei_thumb;\r\n}\r\n\r\nvoid DCR_CLASS dcr_parse_sinar_ia(DCRAW* p)\r\n{\r\n\tint entries, off;\r\n\tchar str[8], *cp;\r\n\r\n\tp->order = 0x4949;\r\n\tdcr_fseek(p->obj_, 4, SEEK_SET);\r\n\tentries = dcr_get4(p);\r\n\tdcr_fseek(p->obj_, dcr_get4(p), SEEK_SET);\r\n\twhile (entries--) {\r\n\t\toff = dcr_get4(p); dcr_get4(p);\r\n\t\tdcr_fread(p->obj_, str, 8, 1);\r\n\t\tif (!strcmp(str,\"META\"))   p->meta_offset = off;\r\n\t\tif (!strcmp(str,\"THUMB\")) p->thumb_offset = off;\r\n\t\tif (!strcmp(str,\"RAW0\"))   p->data_offset = off;\r\n\t}\r\n\tdcr_fseek(p->obj_, p->meta_offset+20, SEEK_SET);\r\n\tdcr_fread(p->obj_, p->make, 64, 1);\r\n\tp->make[63] = 0;\r\n\tif ((cp = strchr(p->make,' '))) {\r\n\t\tstrcpy (p->model, cp+1);\r\n\t\t*cp = 0;\r\n\t}\r\n\tp->raw_width  = dcr_get2(p);\r\n\tp->raw_height = dcr_get2(p);\r\n\tp->load_raw = &DCR_CLASS dcr_unpacked_load_raw;\r\n\tp->thumb_width = (dcr_get4(p),dcr_get2(p));\r\n\tp->thumb_height = dcr_get2(p);\r\n\tp->write_thumb = &DCR_CLASS dcr_ppm_thumb;\r\n\tp->maximum = 0x3fff;\r\n}\r\n\r\nvoid DCR_CLASS dcr_parse_phase_one (DCRAW* p, int base)\r\n{\r\n\tunsigned entries, tag, type, len, data, save, i, c;\r\n\tfloat romm_cam[3][3];\r\n\tchar *cp;\r\n\r\n\tmemset (&p->ph1, 0, sizeof p->ph1);\r\n\tdcr_fseek(p->obj_, base, SEEK_SET);\r\n\tp->order = dcr_get4(p) & 0xffff;\r\n\tif (dcr_get4(p) >> 8 != 0x526177) return;\t\t/* \"Raw\" */\r\n\tdcr_fseek(p->obj_, dcr_get4(p)+base, SEEK_SET);\r\n\tentries = dcr_get4(p);\r\n\tdcr_get4(p);\r\n\twhile (entries--) {\r\n\t\ttag  = dcr_get4(p);\r\n\t\ttype = dcr_get4(p);\r\n\t\tlen  = dcr_get4(p);\r\n\t\tdata = dcr_get4(p);\r\n\t\tsave = dcr_ftell(p->obj_);\r\n\t\tdcr_fseek(p->obj_, base+data, SEEK_SET);\r\n\t\tswitch (tag) {\r\n\t\tcase 0x100:  p->flip = \"0653\"[data & 3]-'0';  break;\r\n\t\tcase 0x106:\r\n\t\t\tfor (i=0; i < 9; i++)\r\n\t\t\t\tromm_cam[0][i] = (float)dcr_getreal(p, 11);\r\n\t\t\tdcr_romm_coeff (p,romm_cam);\r\n\t\t\tbreak;\r\n\t\tcase 0x107:\r\n\t\t\tFORC3 p->cam_mul[c] = (float)dcr_getreal(p, 11);\r\n\t\t\tbreak;\r\n\t\tcase 0x108:  p->raw_width     = data;\tbreak;\r\n\t\tcase 0x109:  p->raw_height    = data;\tbreak;\r\n\t\tcase 0x10a:  p->left_margin   = data;\tbreak;\r\n\t\tcase 0x10b:  p->top_margin    = data;\tbreak;\r\n\t\tcase 0x10c:  p->width         = data;\tbreak;\r\n\t\tcase 0x10d:  p->height        = data;\tbreak;\r\n\t\tcase 0x10e:  p->ph1.format    = data;\tbreak;\r\n\t\tcase 0x10f:  p->data_offset   = data+base;\tbreak;\r\n\t\tcase 0x110:  p->meta_offset   = data+base;\r\n\t\t\tp->meta_length   = len;\t\t\tbreak;\r\n\t\tcase 0x112:  p->ph1.key_off   = save - 4;\t\tbreak;\r\n\t\tcase 0x210:  p->ph1.tag_210   = dcr_int_to_float(data);\tbreak;\r\n\t\tcase 0x21a:  p->ph1.tag_21a   = data;\t\tbreak;\r\n\t\tcase 0x21c:  p->strip_offset  = data+base;\t\tbreak;\r\n\t\tcase 0x21d:  p->ph1.black     = data;\t\tbreak;\r\n\t\tcase 0x222:  p->ph1.split_col = data - p->left_margin;\tbreak;\r\n\t\tcase 0x223:  p->ph1.black_off = data+base;\t\tbreak;\r\n\t\tcase 0x301:\r\n\t\t\tp->model[63] = 0;\r\n\t\t\tdcr_fread(p->obj_, p->model, 1, 63);\r\n\t\t\tif ((cp = strstr(p->model,\" camera\"))) *cp = 0;\r\n\t\t}\r\n\t\tdcr_fseek(p->obj_, save, SEEK_SET);\r\n\t}\r\n\tp->load_raw = p->ph1.format < 3 ?\r\n\t\t&DCR_CLASS dcr_phase_one_load_raw : &DCR_CLASS dcr_phase_one_load_raw_c;\r\n\tp->maximum = 0xffff;\r\n\tstrcpy (p->make, \"Phase One\");\r\n\tif (p->model[0]) return;\r\n\tswitch (p->raw_height) {\r\n    case 2060: strcpy (p->model,\"LightPhase\");\tbreak;\r\n    case 2682: strcpy (p->model,\"H 10\");\t\tbreak;\r\n    case 4128: strcpy (p->model,\"H 20\");\t\tbreak;\r\n    case 5488: strcpy (p->model,\"H 25\");\t\tbreak;\r\n\t}\r\n}\r\n\r\nvoid DCR_CLASS dcr_parse_fuji (DCRAW* p, int offset)\r\n{\r\n\tunsigned entries, tag, len, save, c;\r\n\r\n\tdcr_fseek(p->obj_, offset, SEEK_SET);\r\n\tentries = dcr_get4(p);\r\n\tif (entries > 255) return;\r\n\twhile (entries--) {\r\n\t\ttag = dcr_get2(p);\r\n\t\tlen = dcr_get2(p);\r\n\t\tsave = dcr_ftell(p->obj_);\r\n\t\tif (tag == 0x100) {\r\n\t\t\tp->raw_height = dcr_get2(p);\r\n\t\t\tp->raw_width  = dcr_get2(p);\r\n\t\t} else if (tag == 0x121) {\r\n\t\t\tp->height = dcr_get2(p);\r\n\t\t\tif ((p->width = dcr_get2(p)) == 4284) p->width += 3;\r\n\t\t} else if (tag == 0x130)\r\n\t\t\tp->fuji_layout = dcr_fgetc(p->obj_) >> 7;\r\n\t\tif (tag == 0x2ff0)\r\n\t\t\tFORC4 p->cam_mul[c ^ 1] = dcr_get2(p);\r\n\t\tdcr_fseek(p->obj_, save+len, SEEK_SET);\r\n\t}\r\n\tp->height <<= p->fuji_layout;\r\n\tp->width  >>= p->fuji_layout;\r\n}\r\n\r\nint DCR_CLASS dcr_parse_jpeg (DCRAW* p, int offset)\r\n{\r\n\tint len, save, hlen, mark;\r\n\r\n\tdcr_fseek(p->obj_, offset, SEEK_SET);\r\n\tif (dcr_fgetc(p->obj_) != 0xff || dcr_fgetc(p->obj_) != 0xd8) return 0;\r\n\r\n\twhile (dcr_fgetc(p->obj_) == 0xff && (mark = dcr_fgetc(p->obj_)) != 0xda) {\r\n\t\tp->order = 0x4d4d;\r\n\t\tlen   = dcr_get2(p) - 2;\r\n\t\tsave  = dcr_ftell(p->obj_);\r\n\t\tif (mark == 0xc0 || mark == 0xc3) {\r\n\t\t\tdcr_fgetc(p->obj_);\r\n\t\t\tp->raw_height = dcr_get2(p);\r\n\t\t\tp->raw_width  = dcr_get2(p);\r\n\t\t}\r\n\t\tp->order = dcr_get2(p);\r\n\t\thlen  = dcr_get4(p);\r\n\t\tif (dcr_get4(p) == 0x48454150)\t\t/* \"HEAP\" */\r\n\t\t\tdcr_parse_ciff (p,save+hlen, len-hlen);\r\n\t\tdcr_parse_tiff (p, save+6);\r\n\t\tdcr_fseek(p->obj_, save+len, SEEK_SET);\r\n\t}\r\n\treturn 1;\r\n}\r\n\r\nvoid DCR_CLASS dcr_parse_riff(DCRAW* p)\r\n{\r\n\tunsigned i, size, end;\r\n\tchar tag[4], date[64], month[64];\r\n\tstatic const char mon[12][4] =\r\n\t{ \"Jan\",\"Feb\",\"Mar\",\"Apr\",\"May\",\"Jun\",\"Jul\",\"Aug\",\"Sep\",\"Oct\",\"Nov\",\"Dec\" };\r\n\tstruct tm t;\r\n\r\n    if (dcr_feof(p->obj_))\r\n    {\r\n        fprintf (stderr,_(\"Unexpected end of file\\n\"));\r\n        return;\r\n    }\r\n\r\n\tp->order = 0x4949;\r\n\tdcr_fread(p->obj_, tag, 4, 1);\r\n\tsize = dcr_get4(p);\r\n    end = dcr_ftell(p->obj_) + size;\r\n\tif (!memcmp(tag,\"RIFF\",4) || !memcmp(tag,\"LIST\",4)) {\r\n\t\tdcr_get4(p);\r\n\t\twhile (dcr_ftell(p->obj_)+7 < (long)end)\r\n\t\t\tdcr_parse_riff(p);\r\n\t} else if (!memcmp(tag,\"nctg\",4)) {\r\n\t\twhile (dcr_ftell(p->obj_)+7 < (long)end) {\r\n\t\t\ti = dcr_get2(p);\r\n\t\t\tsize = dcr_get2(p);\r\n\t\t\tif ((i+1) >> 1 == 10 && size == 20)\r\n\t\t\t\tdcr_get_timestamp(p,0);\r\n\t\t\telse dcr_fseek(p->obj_, size, SEEK_CUR);\r\n\t\t}\r\n\t} else if (!memcmp(tag,\"IDIT\",4) && size < 64) {\r\n\t\tdcr_fread(p->obj_, date, 64, 1);\r\n\t\tdate[size] = 0;\r\n\t\tmemset (&t, 0, sizeof t);\r\n\t\tif (sscanf (date, \"%*s %s %d %d:%d:%d %d\", month, &t.tm_mday,\r\n\t\t\t&t.tm_hour, &t.tm_min, &t.tm_sec, &t.tm_year) == 6) {\r\n\t\t\tfor (i=0; i < 12 && strcasecmp(mon[i],month); i++);\r\n\t\t\tt.tm_mon = i;\r\n\t\t\tt.tm_year -= 1900;\r\n\t\t\tif (mktime(&t) > 0)\r\n\t\t\t\tp->timestamp = mktime(&t);\r\n\t\t}\r\n\t} else\r\n\t\tdcr_fseek(p->obj_, size, SEEK_CUR);\r\n}\r\n\r\nvoid DCR_CLASS dcr_parse_smal (DCRAW* p, int offset, int fsize)\r\n{\r\n\tint ver;\r\n\r\n\tdcr_fseek(p->obj_, offset+2, SEEK_SET);\r\n\tp->order = 0x4949;\r\n\tver = dcr_fgetc(p->obj_);\r\n\tif (ver == 6)\r\n\t\tdcr_fseek(p->obj_, 5, SEEK_CUR);\r\n\tif ((int)dcr_get4(p) != fsize) return;\r\n\tif (ver > 6) p->data_offset = dcr_get4(p);\r\n\tp->raw_height = p->height = dcr_get2(p);\r\n\tp->raw_width  = p->width  = dcr_get2(p);\r\n\tstrcpy (p->make, \"SMaL\");\r\n\tsprintf (p->model, \"v%d %dx%d\", ver, p->width, p->height);\r\n\tif (ver == 6) p->load_raw = &DCR_CLASS dcr_smal_v6_load_raw;\r\n\tif (ver == 9) p->load_raw = &DCR_CLASS dcr_smal_v9_load_raw;\r\n}\r\n\r\nvoid DCR_CLASS dcr_parse_cine(DCRAW* p)\r\n{\r\n\tunsigned off_head, off_setup, off_image, i;\r\n\r\n\tp->order = 0x4949;\r\n\tdcr_fseek(p->obj_, 4, SEEK_SET);\r\n\tp->is_raw = dcr_get2(p) == 2;\r\n\tdcr_fseek(p->obj_, 14, SEEK_CUR);\r\n\tp->is_raw *= dcr_get4(p);\r\n\toff_head = dcr_get4(p);\r\n\toff_setup = dcr_get4(p);\r\n\toff_image = dcr_get4(p);\r\n\tp->timestamp = dcr_get4(p);\r\n\tif ((i = dcr_get4(p))) p->timestamp = i;\r\n\tdcr_fseek(p->obj_, off_head+4, SEEK_SET);\r\n\tp->raw_width = dcr_get4(p);\r\n\tp->raw_height = dcr_get4(p);\r\n\tswitch (dcr_get2(p),dcr_get2(p)) {\r\n    case  8:  p->load_raw = &DCR_CLASS dcr_eight_bit_load_raw;  break;\r\n    case 16:  p->load_raw = &DCR_CLASS dcr_unpacked_load_raw;\r\n\t}\r\n\tdcr_fseek(p->obj_, off_setup+792, SEEK_SET);\r\n\tstrcpy (p->make, \"CINE\");\r\n\tsprintf (p->model, \"%d\", dcr_get4(p));\r\n\tdcr_fseek(p->obj_, 12, SEEK_CUR);\r\n\tswitch ((i=dcr_get4(p)) & 0xffffff) {\r\n    case  3:  p->filters = 0x94949494;  break;\r\n    case  4:  p->filters = 0x49494949;  break;\r\n    default:  p->is_raw = 0;\r\n\t}\r\n\tdcr_fseek(p->obj_, 72, SEEK_CUR);\r\n\tswitch ((dcr_get4(p)+3600) % 360) {\r\n    case 270:  p->flip = 4;  break;\r\n    case 180:  p->flip = 1;  break;\r\n    case  90:  p->flip = 7;  break;\r\n    case   0:  p->flip = 2;\r\n\t}\r\n\tp->cam_mul[0] = (float)dcr_getreal(p, 11);\r\n\tp->cam_mul[2] = (float)dcr_getreal(p, 11);\r\n\tp->maximum = ~(-1 << dcr_get4(p));\r\n\tdcr_fseek(p->obj_, 668, SEEK_CUR);\r\n\tp->shutter = dcr_get4(p)/1000000000.0f;\r\n\tdcr_fseek(p->obj_, off_image, SEEK_SET);\r\n\tif (p->opt.shot_select < p->is_raw)\r\n\t\tdcr_fseek(p->obj_, p->opt.shot_select*8, SEEK_CUR);\r\n\tp->data_offset  = (off_t) dcr_get4(p) + 8;\r\n\tp->data_offset += (off_t) ((__int64)dcr_get4(p) << 32);\r\n}\r\n\r\nchar * DCR_CLASS dcr_foveon_gets (DCRAW* p, int offset, char *str, int len)\r\n{\r\n\tint i;\r\n\tdcr_fseek(p->obj_, offset, SEEK_SET);\r\n\tfor (i=0; i < len-1; i++)\r\n\t\tif ((str[i] = (char)dcr_get2(p)) == 0) break;\r\n\tstr[i] = 0;\r\n\treturn str;\r\n}\r\n\r\nvoid DCR_CLASS dcr_parse_foveon(DCRAW* p)\r\n{\r\n\tint entries, img=0, off, len, tag, save, i, wide, high, pent, poff[256][2];\r\n\tchar name[64], value[64];\r\n\r\n\tp->order = 0x4949;\t\t\t/* Little-endian */\r\n\tdcr_fseek(p->obj_, 36, SEEK_SET);\r\n\tp->flip = dcr_get4(p);\r\n\tdcr_fseek(p->obj_, -4, SEEK_END);\r\n\tdcr_fseek(p->obj_, dcr_get4(p), SEEK_SET);\r\n\tif (dcr_get4(p) != 0x64434553) return;\t/* SECd */\r\n\tentries = (dcr_get4(p),dcr_get4(p));\r\n\twhile (entries--) {\r\n\t\toff = dcr_get4(p);\r\n\t\tlen = dcr_get4(p);\r\n\t\ttag = dcr_get4(p);\r\n\t\tsave = dcr_ftell(p->obj_);\r\n\t\tdcr_fseek(p->obj_, off, SEEK_SET);\r\n\t\tif (dcr_get4(p) != (unsigned int)(0x20434553 | (tag << 24))) return;\r\n\t\tswitch (tag) {\r\n\t\tcase 0x47414d49:\t\t\t/* IMAG */\r\n\t\tcase 0x32414d49:\t\t\t/* IMA2 */\r\n\t\t\tdcr_fseek(p->obj_, 12, SEEK_CUR);\r\n\t\t\twide = dcr_get4(p);\r\n\t\t\thigh = dcr_get4(p);\r\n\t\t\tif (wide > p->raw_width && high > p->raw_height) {\r\n\t\t\t\tp->raw_width  = wide;\r\n\t\t\t\tp->raw_height = high;\r\n\t\t\t\tp->data_offset = off+24;\r\n\t\t\t}\r\n\t\t\tdcr_fseek(p->obj_, off+28, SEEK_SET);\r\n\t\t\tif (dcr_fgetc(p->obj_) == 0xff && dcr_fgetc(p->obj_) == 0xd8\r\n\t\t\t\t&& (int)p->thumb_length < len-28) {\r\n\t\t\t\tp->thumb_offset = off+28;\r\n\t\t\t\tp->thumb_length = len-28;\r\n\t\t\t\tp->write_thumb = &DCR_CLASS dcr_jpeg_thumb;\r\n\t\t\t}\r\n\t\t\tif (++img == 2 && !p->thumb_length) {\r\n#if RESTRICTED\r\n\t\t\t\tp->thumb_offset = off+24;\r\n\t\t\t\tp->thumb_width = wide;\r\n\t\t\t\tp->thumb_height = high;\r\n\t\t\t\tp->write_thumb = &DCR_CLASS dcr_foveon_thumb;\r\n#endif //RESTRICTED\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\tcase 0x464d4143:\t\t\t/* CAMF */\r\n\t\t\tp->meta_offset = off+24;\r\n\t\t\tp->meta_length = len-28;\r\n\t\t\tif (p->meta_length > 0x20000)\r\n\t\t\t\tp->meta_length = 0x20000;\r\n\t\t\tbreak;\r\n\t\tcase 0x504f5250:\t\t\t/* PROP */\r\n\t\t\tpent = (dcr_get4(p),dcr_get4(p));\r\n\t\t\tdcr_fseek(p->obj_, 12, SEEK_CUR);\r\n\t\t\toff += pent*8 + 24;\r\n\t\t\tif ((unsigned) pent > 256) pent=256;\r\n\t\t\tfor (i=0; i < pent*2; i++)\r\n\t\t\t\tpoff[0][i] = off + dcr_get4(p)*2;\r\n\t\t\tfor (i=0; i < pent; i++) {\r\n\t\t\t\tdcr_foveon_gets (p, poff[i][0], name, 64);\r\n\t\t\t\tdcr_foveon_gets (p, poff[i][1], value, 64);\r\n\t\t\t\tif (!strcmp (name, \"ISO\"))\r\n\t\t\t\t\tp->iso_speed = (float)atoi(value);\r\n\t\t\t\tif (!strcmp (name, \"CAMMANUF\"))\r\n\t\t\t\t\tstrcpy (p->make, value);\r\n\t\t\t\tif (!strcmp (name, \"CAMMODEL\"))\r\n\t\t\t\t\tstrcpy (p->model, value);\r\n\t\t\t\tif (!strcmp (name, \"WB_DESC\"))\r\n\t\t\t\t\tstrcpy (p->model2, value);\r\n\t\t\t\tif (!strcmp (name, \"TIME\"))\r\n\t\t\t\t\tp->timestamp = atoi(value);\r\n\t\t\t\tif (!strcmp (name, \"EXPTIME\"))\r\n\t\t\t\t\tp->shutter = atoi(value) / 1000000.0f;\r\n\t\t\t\tif (!strcmp (name, \"APERTURE\"))\r\n\t\t\t\t\tp->aperture = (float)atof(value);\r\n\t\t\t\tif (!strcmp (name, \"FLENGTH\"))\r\n\t\t\t\t\tp->focal_len = (float)atof(value);\r\n\t\t\t}\r\n#ifdef LOCALTIME\r\n\t\t\tp->timestamp = mktime (gmtime (&p->timestamp));\r\n#endif\r\n\t\t}\r\n\t\tdcr_fseek(p->obj_, save, SEEK_SET);\r\n\t}\r\n\tp->is_foveon = 1;\r\n}\r\n\r\n/*\r\nThanks to Adobe for providing these excellent CAM -> XYZ matrices!\r\n*/\r\nvoid DCR_CLASS dcr_adobe_coeff (DCRAW* p, char *make, char *model)\r\n{\r\n\tstatic const struct {\r\n\t\tconst char *prefix;\r\n\t\tshort black, maximum, trans[12];\r\n\t} table[] = {\r\n    { \"Apple QuickTake\", 0, 0,\t\t/* DJC */\r\n\t{ 17576,-3191,-3318,5210,6733,-1942,9031,1280,-124 } },\r\n    { \"Canon EOS D2000\", 0, 0,\r\n\t{ 24542,-10860,-3401,-1490,11370,-297,2858,-605,3225 } },\r\n    { \"Canon EOS D6000\", 0, 0,\r\n\t{ 20482,-7172,-3125,-1033,10410,-285,2542,226,3136 } },\r\n    { \"Canon EOS D30\", 0, 0,\r\n\t{ 9805,-2689,-1312,-5803,13064,3068,-2438,3075,8775 } },\r\n    { \"Canon EOS D60\", 0, 0xfa0,\r\n\t{ 6188,-1341,-890,-7168,14489,2937,-2640,3228,8483 } },\r\n    { \"Canon EOS 5D Mark II\", 0, 0x3cf0,\r\n\t{ 4716,603,-830,-7798,15474,2480,-1496,1937,6651 } },\r\n    { \"Canon EOS 5D\", 0, 0xe6c,\r\n\t{ 6347,-479,-972,-8297,15954,2480,-1968,2131,7649 } },\r\n    { \"Canon EOS 10D\", 0, 0xfa0,\r\n\t{ 8197,-2000,-1118,-6714,14335,2592,-2536,3178,8266 } },\r\n    { \"Canon EOS 20Da\", 0, 0,\r\n\t{ 14155,-5065,-1382,-6550,14633,2039,-1623,1824,6561 } },\r\n    { \"Canon EOS 20D\", 0, 0xfff,\r\n\t{ 6599,-537,-891,-8071,15783,2424,-1983,2234,7462 } },\r\n    { \"Canon EOS 30D\", 0, 0,\r\n\t{ 6257,-303,-1000,-7880,15621,2396,-1714,1904,7046 } },\r\n    { \"Canon EOS 40D\", 0, 0x3f60,\r\n\t{ 6071,-747,-856,-7653,15365,2441,-2025,2553,7315 } },\r\n    { \"Canon EOS 50D\", 0, 0x3d93,\r\n\t{ 4920,616,-593,-6493,13964,2784,-1774,3178,7005 } },\r\n    { \"Canon EOS 300D\", 0, 0xfa0,\r\n\t{ 8197,-2000,-1118,-6714,14335,2592,-2536,3178,8266 } },\r\n    { \"Canon EOS 350D\", 0, 0xfff,\r\n\t{ 6018,-617,-965,-8645,15881,2975,-1530,1719,7642 } },\r\n    { \"Canon EOS 400D\", 0, 0xe8e,\r\n\t{ 7054,-1501,-990,-8156,15544,2812,-1278,1414,7796 } },\r\n    { \"Canon EOS 450D\", 0, 0x390d,\r\n\t{ 5784,-262,-821,-7539,15064,2672,-1982,2681,7427 } },\r\n    { \"Canon EOS 1000D\", 0, 0xe43,\r\n\t{ 6771,-1139,-977,-7818,15123,2928,-1244,1437,7533 } },\r\n    { \"Canon EOS-1Ds Mark III\", 0, 0x3bb0,\r\n\t{ 5859,-211,-930,-8255,16017,2353,-1732,1887,7448 } },\r\n    { \"Canon EOS-1Ds Mark II\", 0, 0xe80,\r\n\t{ 6517,-602,-867,-8180,15926,2378,-1618,1771,7633 } },\r\n    { \"Canon EOS-1D Mark II N\", 0, 0xe80,\r\n\t{ 6240,-466,-822,-8180,15825,2500,-1801,1938,8042 } },\r\n    { \"Canon EOS-1D Mark III\", 0, 0x3bb0,\r\n\t{ 6291,-540,-976,-8350,16145,2311,-1714,1858,7326 } },\r\n    { \"Canon EOS-1D Mark II\", 0, 0xe80,\r\n\t{ 6264,-582,-724,-8312,15948,2504,-1744,1919,8664 } },\r\n    { \"Canon EOS-1DS\", 0, 0xe20,\r\n\t{ 4374,3631,-1743,-7520,15212,2472,-2892,3632,8161 } },\r\n    { \"Canon EOS-1D\", 0, 0xe20,\r\n\t{ 6806,-179,-1020,-8097,16415,1687,-3267,4236,7690 } },\r\n    { \"Canon EOS\", 0, 0,\r\n\t{ 8197,-2000,-1118,-6714,14335,2592,-2536,3178,8266 } },\r\n    { \"Canon PowerShot A50\", 0, 0,\r\n\t{ -5300,9846,1776,3436,684,3939,-5540,9879,6200,-1404,11175,217 } },\r\n    { \"Canon PowerShot A5\", 0, 0,\r\n\t{ -4801,9475,1952,2926,1611,4094,-5259,10164,5947,-1554,10883,547 } },\r\n    { \"Canon PowerShot G10\", 0, 0,\r\n\t{ 11093,-3906,-1028,-5047,12492,2879,-1003,1750,5561 } },\r\n    { \"Canon PowerShot G1\", 0, 0,\r\n\t{ -4778,9467,2172,4743,-1141,4344,-5146,9908,6077,-1566,11051,557 } },\r\n    { \"Canon PowerShot G2\", 0, 0,\r\n\t{ 9087,-2693,-1049,-6715,14382,2537,-2291,2819,7790 } },\r\n    { \"Canon PowerShot G3\", 0, 0,\r\n\t{ 9212,-2781,-1073,-6573,14189,2605,-2300,2844,7664 } },\r\n    { \"Canon PowerShot G5\", 0, 0,\r\n\t{ 9757,-2872,-933,-5972,13861,2301,-1622,2328,7212 } },\r\n    { \"Canon PowerShot G6\", 0, 0,\r\n\t{ 9877,-3775,-871,-7613,14807,3072,-1448,1305,7485 } },\r\n    { \"Canon PowerShot G9\", 0, 0,\r\n\t{ 7368,-2141,-598,-5621,13254,2625,-1418,1696,5743 } },\r\n    { \"Canon PowerShot Pro1\", 0, 0,\r\n\t{ 10062,-3522,-999,-7643,15117,2730,-765,817,7323 } },\r\n    { \"Canon PowerShot Pro70\", 34, 0,\r\n\t{ -4155,9818,1529,3939,-25,4522,-5521,9870,6610,-2238,10873,1342 } },\r\n    { \"Canon PowerShot Pro90\", 0, 0,\r\n\t{ -4963,9896,2235,4642,-987,4294,-5162,10011,5859,-1770,11230,577 } },\r\n    { \"Canon PowerShot S30\", 0, 0,\r\n\t{ 10566,-3652,-1129,-6552,14662,2006,-2197,2581,7670 } },\r\n    { \"Canon PowerShot S40\", 0, 0,\r\n\t{ 8510,-2487,-940,-6869,14231,2900,-2318,2829,9013 } },\r\n    { \"Canon PowerShot S45\", 0, 0,\r\n\t{ 8163,-2333,-955,-6682,14174,2751,-2077,2597,8041 } },\r\n    { \"Canon PowerShot S50\", 0, 0,\r\n\t{ 8882,-2571,-863,-6348,14234,2288,-1516,2172,6569 } },\r\n    { \"Canon PowerShot S60\", 0, 0,\r\n\t{ 8795,-2482,-797,-7804,15403,2573,-1422,1996,7082 } },\r\n    { \"Canon PowerShot S70\", 0, 0,\r\n\t{ 9976,-3810,-832,-7115,14463,2906,-901,989,7889 } },\r\n    { \"Canon PowerShot A610\", 0, 0,\t/* DJC */\r\n\t{ 15591,-6402,-1592,-5365,13198,2168,-1300,1824,5075 } },\r\n    { \"Canon PowerShot A620\", 0, 0,\t/* DJC */\r\n\t{ 15265,-6193,-1558,-4125,12116,2010,-888,1639,5220 } },\r\n    { \"Canon PowerShot A630\", 0, 0,\t/* DJC */\r\n\t{ 14201,-5308,-1757,-6087,14472,1617,-2191,3105,5348 } },\r\n    { \"Canon PowerShot A640\", 0, 0,\t/* DJC */\r\n\t{ 13124,-5329,-1390,-3602,11658,1944,-1612,2863,4885 } },\r\n    { \"Canon PowerShot A650\", 0, 0,\t/* DJC */\r\n\t{ 9427,-3036,-959,-2581,10671,1911,-1039,1982,4430 } },\r\n    { \"Canon PowerShot A720\", 0, 0,\t/* DJC */\r\n\t{ 14573,-5482,-1546,-1266,9799,1468,-1040,1912,3810 } },\r\n    { \"Canon PowerShot S3 IS\", 0, 0,\t/* DJC */\r\n\t{ 14062,-5199,-1446,-4712,12470,2243,-1286,2028,4836 } },\r\n    { \"CINE 650\", 0, 0,\r\n\t{ 3390,480,-500,-800,3610,340,-550,2336,1192 } },\r\n    { \"CINE 660\", 0, 0,\r\n\t{ 3390,480,-500,-800,3610,340,-550,2336,1192 } },\r\n    { \"CINE\", 0, 0,\r\n\t{ 20183,-4295,-423,-3940,15330,3985,-280,4870,9800 } },\r\n    { \"Contax N Digital\", 0, 0xf1e,\r\n\t{ 7777,1285,-1053,-9280,16543,2916,-3677,5679,7060 } },\r\n    { \"EPSON R-D1\", 0, 0,\r\n\t{ 6827,-1878,-732,-8429,16012,2564,-704,592,7145 } },\r\n    { \"FUJIFILM FinePix E550\", 0, 0,\r\n\t{ 11044,-3888,-1120,-7248,15168,2208,-1531,2277,8069 } },\r\n    { \"FUJIFILM FinePix E900\", 0, 0,\r\n\t{ 9183,-2526,-1078,-7461,15071,2574,-2022,2440,8639 } },\r\n    { \"FUJIFILM FinePix F8\", 0, 0,\r\n\t{ 11044,-3888,-1120,-7248,15168,2208,-1531,2277,8069 } },\r\n    { \"FUJIFILM FinePix F7\", 0, 0,\r\n\t{ 10004,-3219,-1201,-7036,15047,2107,-1863,2565,7736 } },\r\n    { \"FUJIFILM FinePix S100FS\", 514, 0,\r\n\t{ 11521,-4355,-1065,-6524,13767,3058,-1466,1984,6045 } },\r\n    { \"FUJIFILM FinePix S20Pro\", 0, 0,\r\n\t{ 10004,-3219,-1201,-7036,15047,2107,-1863,2565,7736 } },\r\n    { \"FUJIFILM FinePix S2Pro\", 128, 0,\r\n\t{ 12492,-4690,-1402,-7033,15423,1647,-1507,2111,7697 } },\r\n    { \"FUJIFILM FinePix S3Pro\", 0, 0,\r\n\t{ 11807,-4612,-1294,-8927,16968,1988,-2120,2741,8006 } },\r\n    { \"FUJIFILM FinePix S5Pro\", 0, 0,\r\n\t{ 12300,-5110,-1304,-9117,17143,1998,-1947,2448,8100 } },\r\n    { \"FUJIFILM FinePix S5000\", 0, 0,\r\n\t{ 8754,-2732,-1019,-7204,15069,2276,-1702,2334,6982 } },\r\n    { \"FUJIFILM FinePix S5100\", 0, 0x3e00,\r\n\t{ 11940,-4431,-1255,-6766,14428,2542,-993,1165,7421 } },\r\n    { \"FUJIFILM FinePix S5500\", 0, 0x3e00,\r\n\t{ 11940,-4431,-1255,-6766,14428,2542,-993,1165,7421 } },\r\n    { \"FUJIFILM FinePix S5200\", 0, 0,\r\n\t{ 9636,-2804,-988,-7442,15040,2589,-1803,2311,8621 } },\r\n    { \"FUJIFILM FinePix S5600\", 0, 0,\r\n\t{ 9636,-2804,-988,-7442,15040,2589,-1803,2311,8621 } },\r\n    { \"FUJIFILM FinePix S6\", 0, 0,\r\n\t{ 12628,-4887,-1401,-6861,14996,1962,-2198,2782,7091 } },\r\n    { \"FUJIFILM FinePix S7000\", 0, 0,\r\n\t{ 10190,-3506,-1312,-7153,15051,2238,-2003,2399,7505 } },\r\n    { \"FUJIFILM FinePix S9000\", 0, 0,\r\n\t{ 10491,-3423,-1145,-7385,15027,2538,-1809,2275,8692 } },\r\n    { \"FUJIFILM FinePix S9500\", 0, 0,\r\n\t{ 10491,-3423,-1145,-7385,15027,2538,-1809,2275,8692 } },\r\n    { \"FUJIFILM FinePix S9100\", 0, 0,\r\n\t{ 12343,-4515,-1285,-7165,14899,2435,-1895,2496,8800 } },\r\n    { \"FUJIFILM FinePix S9600\", 0, 0,\r\n\t{ 12343,-4515,-1285,-7165,14899,2435,-1895,2496,8800 } },\r\n    { \"FUJIFILM IS-1\", 0, 0,\r\n\t{ 21461,-10807,-1441,-2332,10599,1999,289,875,7703 } },\r\n    { \"FUJIFILM IS Pro\", 0, 0,\r\n\t{ 12300,-5110,-1304,-9117,17143,1998,-1947,2448,8100 } },\r\n    { \"Imacon Ixpress\", 0, 0,\t\t/* DJC */\r\n\t{ 7025,-1415,-704,-5188,13765,1424,-1248,2742,6038 } },\r\n    { \"KODAK NC2000\", 0, 0,\r\n\t{ 13891,-6055,-803,-465,9919,642,2121,82,1291 } },\r\n    { \"Kodak DCS315C\", 8, 0,\r\n\t{ 17523,-4827,-2510,756,8546,-137,6113,1649,2250 } },\r\n    { \"Kodak DCS330C\", 8, 0,\r\n\t{ 20620,-7572,-2801,-103,10073,-396,3551,-233,2220 } },\r\n    { \"KODAK DCS420\", 0, 0,\r\n\t{ 10868,-1852,-644,-1537,11083,484,2343,628,2216 } },\r\n    { \"KODAK DCS460\", 0, 0,\r\n\t{ 10592,-2206,-967,-1944,11685,230,2206,670,1273 } },\r\n    { \"KODAK EOSDCS1\", 0, 0,\r\n\t{ 10592,-2206,-967,-1944,11685,230,2206,670,1273 } },\r\n    { \"KODAK EOSDCS3B\", 0, 0,\r\n\t{ 9898,-2700,-940,-2478,12219,206,1985,634,1031 } },\r\n    { \"Kodak DCS520C\", 180, 0,\r\n\t{ 24542,-10860,-3401,-1490,11370,-297,2858,-605,3225 } },\r\n    { \"Kodak DCS560C\", 188, 0,\r\n\t{ 20482,-7172,-3125,-1033,10410,-285,2542,226,3136 } },\r\n    { \"Kodak DCS620C\", 180, 0,\r\n\t{ 23617,-10175,-3149,-2054,11749,-272,2586,-489,3453 } },\r\n    { \"Kodak DCS620X\", 185, 0,\r\n\t{ 13095,-6231,154,12221,-21,-2137,895,4602,2258 } },\r\n    { \"Kodak DCS660C\", 214, 0,\r\n\t{ 18244,-6351,-2739,-791,11193,-521,3711,-129,2802 } },\r\n    { \"Kodak DCS720X\", 0, 0,\r\n\t{ 11775,-5884,950,9556,1846,-1286,-1019,6221,2728 } },\r\n    { \"Kodak DCS760C\", 0, 0,\r\n\t{ 16623,-6309,-1411,-4344,13923,323,2285,274,2926 } },\r\n    { \"Kodak DCS Pro SLR\", 0, 0,\r\n\t{ 5494,2393,-232,-6427,13850,2846,-1876,3997,5445 } },\r\n    { \"Kodak DCS Pro 14nx\", 0, 0,\r\n\t{ 5494,2393,-232,-6427,13850,2846,-1876,3997,5445 } },\r\n    { \"Kodak DCS Pro 14\", 0, 0,\r\n\t{ 7791,3128,-776,-8588,16458,2039,-2455,4006,6198 } },\r\n    { \"Kodak ProBack645\", 0, 0,\r\n\t{ 16414,-6060,-1470,-3555,13037,473,2545,122,4948 } },\r\n    { \"Kodak ProBack\", 0, 0,\r\n\t{ 21179,-8316,-2918,-915,11019,-165,3477,-180,4210 } },\r\n    { \"KODAK P712\", 0, 0,\r\n\t{ 9658,-3314,-823,-5163,12695,2768,-1342,1843,6044 } },\r\n    { \"KODAK P850\", 0, 0xf7c,\r\n\t{ 10511,-3836,-1102,-6946,14587,2558,-1481,1792,6246 } },\r\n    { \"KODAK P880\", 0, 0xfff,\r\n\t{ 12805,-4662,-1376,-7480,15267,2360,-1626,2194,7904 } },\r\n    { \"Leaf CMost\", 0, 0,\r\n\t{ 3952,2189,449,-6701,14585,2275,-4536,7349,6536 } },\r\n    { \"Leaf Valeo 6\", 0, 0,\r\n\t{ 3952,2189,449,-6701,14585,2275,-4536,7349,6536 } },\r\n    { \"Leaf Aptus 54S\", 0, 0,\r\n\t{ 8236,1746,-1314,-8251,15953,2428,-3673,5786,5771 } },\r\n    { \"Leaf Aptus 65\", 0, 0,\r\n\t{ 7914,1414,-1190,-8777,16582,2280,-2811,4605,5562 } },\r\n    { \"Leaf Aptus 75\", 0, 0,\r\n\t{ 7914,1414,-1190,-8777,16582,2280,-2811,4605,5562 } },\r\n    { \"Leaf\", 0, 0,\r\n\t{ 8236,1746,-1314,-8251,15953,2428,-3673,5786,5771 } },\r\n    { \"Mamiya ZD\", 0, 0,\r\n\t{ 7645,2579,-1363,-8689,16717,2015,-3712,5941,5961 } },\r\n    { \"Micron 2010\", 110, 0,\t\t/* DJC */\r\n\t{ 16695,-3761,-2151,155,9682,163,3433,951,4904 } },\r\n    { \"Minolta DiMAGE 5\", 0, 0xf7d,\r\n\t{ 8983,-2942,-963,-6556,14476,2237,-2426,2887,8014 } },\r\n    { \"Minolta DiMAGE 7Hi\", 0, 0xf7d,\r\n\t{ 11368,-3894,-1242,-6521,14358,2339,-2475,3056,7285 } },\r\n    { \"Minolta DiMAGE 7\", 0, 0xf7d,\r\n\t{ 9144,-2777,-998,-6676,14556,2281,-2470,3019,7744 } },\r\n    { \"Minolta DiMAGE A1\", 0, 0xf8b,\r\n\t{ 9274,-2547,-1167,-8220,16323,1943,-2273,2720,8340 } },\r\n    { \"MINOLTA DiMAGE A200\", 0, 0,\r\n\t{ 8560,-2487,-986,-8112,15535,2771,-1209,1324,7743 } },\r\n    { \"Minolta DiMAGE A2\", 0, 0xf8f,\r\n\t{ 9097,-2726,-1053,-8073,15506,2762,-966,981,7763 } },\r\n    { \"Minolta DiMAGE Z2\", 0, 0,\t/* DJC */\r\n\t{ 11280,-3564,-1370,-4655,12374,2282,-1423,2168,5396 } },\r\n    { \"MINOLTA DYNAX 5\", 0, 0xffb,\r\n\t{ 10284,-3283,-1086,-7957,15762,2316,-829,882,6644 } },\r\n    { \"MINOLTA DYNAX 7\", 0, 0xffb,\r\n\t{ 10239,-3104,-1099,-8037,15727,2451,-927,925,6871 } },\r\n    { \"NIKON D100\", 0, 0,\r\n\t{ 5902,-933,-782,-8983,16719,2354,-1402,1455,6464 } },\r\n    { \"NIKON D1H\", 0, 0,\r\n\t{ 7577,-2166,-926,-7454,15592,1934,-2377,2808,8606 } },\r\n    { \"NIKON D1X\", 0, 0,\r\n\t{ 7702,-2245,-975,-9114,17242,1875,-2679,3055,8521 } },\r\n    { \"NIKON D1\", 0, 0, /* multiplied by 2.218750, 1.0, 1.148438 */\r\n\t{ 16772,-4726,-2141,-7611,15713,1972,-2846,3494,9521 } },\r\n    { \"NIKON D2H\", 0, 0,\r\n\t{ 5710,-901,-615,-8594,16617,2024,-2975,4120,6830 } },\r\n    { \"NIKON D2X\", 0, 0,\r\n\t{ 10231,-2769,-1255,-8301,15900,2552,-797,680,7148 } },\r\n    { \"NIKON D40X\", 0, 0,\r\n\t{ 8819,-2543,-911,-9025,16928,2151,-1329,1213,8449 } },\r\n    { \"NIKON D40\", 0, 0,\r\n\t{ 6992,-1668,-806,-8138,15748,2543,-874,850,7897 } },\r\n    { \"NIKON D50\", 0, 0,\r\n\t{ 7732,-2422,-789,-8238,15884,2498,-859,783,7330 } },\r\n    { \"NIKON D60\", 0, 0,\r\n\t{ 8736,-2458,-935,-9075,16894,2251,-1354,1242,8263 } },\r\n    { \"NIKON D700\", 0, 0,\r\n\t{ 8139,-2171,-663,-8747,16541,2295,-1925,2008,8093 } },\r\n    { \"NIKON D70\", 0, 0,\r\n\t{ 7732,-2422,-789,-8238,15884,2498,-859,783,7330 } },\r\n    { \"NIKON D80\", 0, 0,\r\n\t{ 8629,-2410,-883,-9055,16940,2171,-1490,1363,8520 } },\r\n    { \"NIKON D90\", 0, 0xf00,\r\n\t{ 7309,-1403,-519,-8474,16008,2622,-2434,2826,8064 } },\r\n    { \"NIKON D200\", 0, 0xfbc,\r\n\t{ 8367,-2248,-763,-8758,16447,2422,-1527,1550,8053 } },\r\n    { \"NIKON D300\", 0, 0,\r\n\t{ 9030,-1992,-715,-8465,16302,2255,-2689,3217,8069 } },\r\n    { \"NIKON D3\", 0, 0,\r\n\t{ 8139,-2171,-663,-8747,16541,2295,-1925,2008,8093 } },\r\n    { \"NIKON E950\", 0, 0x3dd,\t\t/* DJC */\r\n\t{ -3746,10611,1665,9621,-1734,2114,-2389,7082,3064,3406,6116,-244 } },\r\n    { \"NIKON E995\", 0, 0,\t/* copied from E5000 */\r\n\t{ -5547,11762,2189,5814,-558,3342,-4924,9840,5949,688,9083,96 } },\r\n    { \"NIKON E2100\", 0, 0,\t/* copied from Z2, new white balance */\r\n\t{ 13142,-4152,-1596,-4655,12374,2282,-1769,2696,6711} },\r\n    { \"NIKON E2500\", 0, 0,\r\n\t{ -5547,11762,2189,5814,-558,3342,-4924,9840,5949,688,9083,96 } },\r\n    { \"NIKON E4300\", 0, 0,\t/* copied from Minolta DiMAGE Z2 */\r\n\t{ 11280,-3564,-1370,-4655,12374,2282,-1423,2168,5396 } },\r\n    { \"NIKON E4500\", 0, 0,\r\n\t{ -5547,11762,2189,5814,-558,3342,-4924,9840,5949,688,9083,96 } },\r\n    { \"NIKON E5000\", 0, 0,\r\n\t{ -5547,11762,2189,5814,-558,3342,-4924,9840,5949,688,9083,96 } },\r\n    { \"NIKON E5400\", 0, 0,\r\n\t{ 9349,-2987,-1001,-7919,15766,2266,-2098,2680,6839 } },\r\n    { \"NIKON E5700\", 0, 0,\r\n\t{ -5368,11478,2368,5537,-113,3148,-4969,10021,5782,778,9028,211 } },\r\n    { \"NIKON E8400\", 0, 0,\r\n\t{ 7842,-2320,-992,-8154,15718,2599,-1098,1342,7560 } },\r\n    { \"NIKON E8700\", 0, 0,\r\n\t{ 8489,-2583,-1036,-8051,15583,2643,-1307,1407,7354 } },\r\n    { \"NIKON E8800\", 0, 0,\r\n\t{ 7971,-2314,-913,-8451,15762,2894,-1442,1520,7610 } },\r\n    { \"NIKON COOLPIX P6000\", 0, 0,\r\n\t{ 9698,-3367,-914,-4706,12584,2368,-837,968,5801 } },\r\n    { \"OLYMPUS C5050\", 0, 0,\r\n\t{ 10508,-3124,-1273,-6079,14294,1901,-1653,2306,6237 } },\r\n    { \"OLYMPUS C5060\", 0, 0,\r\n\t{ 10445,-3362,-1307,-7662,15690,2058,-1135,1176,7602 } },\r\n    { \"OLYMPUS C7070\", 0, 0,\r\n\t{ 10252,-3531,-1095,-7114,14850,2436,-1451,1723,6365 } },\r\n    { \"OLYMPUS C70\", 0, 0,\r\n\t{ 10793,-3791,-1146,-7498,15177,2488,-1390,1577,7321 } },\r\n    { \"OLYMPUS C80\", 0, 0,\r\n\t{ 8606,-2509,-1014,-8238,15714,2703,-942,979,7760 } },\r\n    { \"OLYMPUS E-10\", 0, (short)0xffc0,\r\n\t{ 12745,-4500,-1416,-6062,14542,1580,-1934,2256,6603 } },\r\n    { \"OLYMPUS E-1\", 0, (short)0xfff0,\r\n\t{ 11846,-4767,-945,-7027,15878,1089,-2699,4122,8311 } },\r\n    { \"OLYMPUS E-20\", 0, (short)0xffc0,\r\n\t{ 13173,-4732,-1499,-5807,14036,1895,-2045,2452,7142 } },\r\n    { \"OLYMPUS E-300\", 0, 0,\r\n\t{ 7828,-1761,-348,-5788,14071,1830,-2853,4518,6557 } },\r\n    { \"OLYMPUS E-330\", 0, 0,\r\n\t{ 8961,-2473,-1084,-7979,15990,2067,-2319,3035,8249 } },\r\n    { \"OLYMPUS E-3\", 0, 0xf99,\r\n\t{ 9487,-2875,-1115,-7533,15606,2010,-1618,2100,7389 } },\r\n    { \"OLYMPUS E-400\", 0, (short)0xfff0,\r\n\t{ 6169,-1483,-21,-7107,14761,2536,-2904,3580,8568 } },\r\n    { \"OLYMPUS E-410\", 0, 0xf6a,\r\n\t{ 8856,-2582,-1026,-7761,15766,2082,-2009,2575,7469 } },\r\n    { \"OLYMPUS E-420\", 0, 0xfd7,\r\n\t{ 8746,-2425,-1095,-7594,15612,2073,-1780,2309,7416 } },\r\n    { \"OLYMPUS E-500\", 0, 0,\r\n\t{ 8136,-1968,-299,-5481,13742,1871,-2556,4205,6630 } },\r\n    { \"OLYMPUS E-510\", 0, 0xf6a,\r\n\t{ 8785,-2529,-1033,-7639,15624,2112,-1783,2300,7817 } },\r\n    { \"OLYMPUS E-520\", 0, 0xfd2,\r\n\t{ 8344,-2322,-1020,-7596,15635,2048,-1748,2269,7287 } },\r\n    { \"OLYMPUS SP350\", 0, 0,\r\n\t{ 12078,-4836,-1069,-6671,14306,2578,-786,939,7418 } },\r\n    { \"OLYMPUS SP3\", 0, 0,\r\n\t{ 11766,-4445,-1067,-6901,14421,2707,-1029,1217,7572 } },\r\n    { \"OLYMPUS SP500UZ\", 0, 0xfff,\r\n\t{ 9493,-3415,-666,-5211,12334,3260,-1548,2262,6482 } },\r\n    { \"OLYMPUS SP510UZ\", 0, 0xffe,\r\n\t{ 10593,-3607,-1010,-5881,13127,3084,-1200,1805,6721 } },\r\n    { \"OLYMPUS SP550UZ\", 0, 0xffe,\r\n\t{ 11597,-4006,-1049,-5432,12799,2957,-1029,1750,6516 } },\r\n    { \"OLYMPUS SP560UZ\", 0, 0xff9,\r\n\t{ 10915,-3677,-982,-5587,12986,2911,-1168,1968,6223 } },\r\n    { \"OLYMPUS SP570UZ\", 0, 0,\r\n\t{ 11522,-4044,-1146,-4736,12172,2904,-988,1829,6039 } },\r\n    { \"PENTAX *ist DL2\", 0, 0,\r\n\t{ 10504,-2438,-1189,-8603,16207,2531,-1022,863,12242 } },\r\n    { \"PENTAX *ist DL\", 0, 0,\r\n\t{ 10829,-2838,-1115,-8339,15817,2696,-837,680,11939 } },\r\n    { \"PENTAX *ist DS2\", 0, 0,\r\n\t{ 10504,-2438,-1189,-8603,16207,2531,-1022,863,12242 } },\r\n    { \"PENTAX *ist DS\", 0, 0,\r\n\t{ 10371,-2333,-1206,-8688,16231,2602,-1230,1116,11282 } },\r\n    { \"PENTAX *ist D\", 0, 0,\r\n\t{ 9651,-2059,-1189,-8881,16512,2487,-1460,1345,10687 } },\r\n    { \"PENTAX K10D\", 0, 0,\r\n\t{ 9566,-2863,-803,-7170,15172,2112,-818,803,9705 } },\r\n    { \"PENTAX K1\", 0, 0,\r\n\t{ 11095,-3157,-1324,-8377,15834,2720,-1108,947,11688 } },\r\n    { \"PENTAX K20D\", 0, 0,\r\n\t{ 9427,-2714,-868,-7493,16092,1373,-2199,3264,7180 } },\r\n    { \"PENTAX K200D\", 0, 0,\r\n\t{ 9186,-2678,-907,-8693,16517,2260,-1129,1094,8524 } },\r\n    { \"PENTAX K2000\", 0, 0,\r\n\t{ 11057,-3604,-1155,-5152,13046,2329,-282,375,8104 } },\r\n    { \"PENTAX K-m\", 0, 0,\r\n\t{ 11057,-3604,-1155,-5152,13046,2329,-282,375,8104 } },\r\n    { \"Panasonic DMC-FZ8\", 0, (short)0xf7f0,\r\n\t{ 8986,-2755,-802,-6341,13575,3077,-1476,2144,6379 } },\r\n    { \"Panasonic DMC-FZ18\", 0, 0,\r\n\t{ 9932,-3060,-935,-5809,13331,2753,-1267,2155,5575 } },\r\n    { \"Panasonic DMC-FZ28\", 15, 0xfff,\r\n\t{ 10109,-3488,-993,-5412,12812,2916,-1305,2140,5543 } },\r\n    { \"Panasonic DMC-FZ30\", 0, (short)0xf94c,\r\n\t{ 10976,-4029,-1141,-7918,15491,2600,-1670,2071,8246 } },\r\n    { \"Panasonic DMC-FZ50\", 0, (short)0xfff0,\t/* aka \"LEICA V-LUX1\" */\r\n\t{ 7906,-2709,-594,-6231,13351,3220,-1922,2631,6537 } },\r\n    { \"Panasonic DMC-L10\", 15, 0xf96,\r\n\t{ 8025,-1942,-1050,-7920,15904,2100,-2456,3005,7039 } },\r\n    { \"Panasonic DMC-L1\", 0, (short)0xf7fc,\t/* aka \"LEICA DIGILUX 3\" */\r\n\t{ 8054,-1885,-1025,-8349,16367,2040,-2805,3542,7629 } },\r\n    { \"Panasonic DMC-LC1\", 0, 0,\t/* aka \"LEICA DIGILUX 2\" */\r\n\t{ 11340,-4069,-1275,-7555,15266,2448,-2960,3426,7685 } },\r\n    { \"Panasonic DMC-LX1\", 0, (short)0xf7f0,\t/* aka \"LEICA D-LUX2\" */\r\n\t{ 10704,-4187,-1230,-8314,15952,2501,-920,945,8927 } },\r\n    { \"Panasonic DMC-LX2\", 0, 0,\t/* aka \"LEICA D-LUX3\" */\r\n\t{ 8048,-2810,-623,-6450,13519,3272,-1700,2146,7049 } },\r\n    { \"Panasonic DMC-LX3\", 15, 0xfff,\t/* aka \"LEICA D-LUX4\" */\r\n\t{ 8128,-2668,-655,-6134,13307,3161,-1782,2568,6083 } },\r\n    { \"Panasonic DMC-FX150\", 15, 0xfff,\r\n\t{ 9082,-2907,-925,-6119,13377,3058,-1797,2641,5609 } },\r\n    { \"Panasonic DMC-G1\", 15, 0xfff,\r\n\t{ 8199,-2065,-1056,-8124,16156,2033,-2458,3022,7220 } },\r\n    { \"Phase One H 20\", 0, 0,\t\t/* DJC */\r\n\t{ 1313,1855,-109,-6715,15908,808,-327,1840,6020 } },\r\n    { \"Phase One P 2\", 0, 0,\r\n\t{ 2905,732,-237,-8134,16626,1476,-3038,4253,7517 } },\r\n    { \"Phase One P 30\", 0, 0,\r\n\t{ 4516,-245,-37,-7020,14976,2173,-3206,4671,7087 } },\r\n    { \"Phase One P 45\", 0, 0,\r\n\t{ 5053,-24,-117,-5684,14076,1702,-2619,4492,5849 } },\r\n    { \"SAMSUNG GX-1\", 0, 0,\r\n\t{ 10504,-2438,-1189,-8603,16207,2531,-1022,863,12242 } },\r\n    { \"Sinar\", 0, 0,\t\t\t/* DJC */\r\n\t{ 16442,-2956,-2422,-2877,12128,750,-1136,6066,4559 } },\r\n    { \"SONY DSC-F828\", 491, 0,\r\n\t{ 7924,-1910,-777,-8226,15459,2998,-1517,2199,6818,-7242,11401,3481 } },\r\n    { \"SONY DSC-R1\", 512, 0,\r\n\t{ 8512,-2641,-694,-8042,15670,2526,-1821,2117,7414 } },\r\n    { \"SONY DSC-V3\", 0, 0,\r\n\t{ 7511,-2571,-692,-7894,15088,3060,-948,1111,8128 } },\r\n    { \"SONY DSLR-A100\", 0, 0xfeb,\r\n\t{ 9437,-2811,-774,-8405,16215,2290,-710,596,7181 } },\r\n    { \"SONY DSLR-A200\", 0, 0,\r\n\t{ 9847,-3091,-928,-8485,16345,2225,-715,595,7103 } },\r\n    { \"SONY DSLR-A300\", 0, 0,\r\n\t{ 9847,-3091,-928,-8485,16345,2225,-715,595,7103 } },\r\n    { \"SONY DSLR-A350\", 0, 0xffc,\r\n\t{ 6038,-1484,-578,-9146,16746,2513,-875,746,7217 } },\r\n    { \"SONY DSLR-A700\", 254, 0x1ffe,\r\n\t{ 5775,-805,-359,-8574,16295,2391,-1943,2341,7249 } },\r\n    { \"SONY DSLR-A900\", 254, 0x1ffe,\r\n\t{ 5209,-1072,-397,-8845,16120,2919,-1618,1803,8654 } }\r\n  };\r\n  double cam_xyz[4][3];\r\n  char name[130];\r\n  int i, j;\r\n\r\n  sprintf (name, \"%s %s\", make, model);\r\n  for (i=0; i < sizeof table / sizeof *table; i++)\r\n\t  if (!strncmp (name, table[i].prefix, strlen(table[i].prefix))) {\r\n\t\t  if (table[i].black)   p->black = (ushort) table[i].black;\r\n\t\t  if (table[i].maximum) p->maximum = (ushort) table[i].maximum;\r\n\t\t  for (j=0; j < 12; j++)\r\n\t\t\t  cam_xyz[0][j] = table[i].trans[j] / 10000.0;\r\n\t\t  dcr_cam_xyz_coeff (p, cam_xyz);\r\n\t\t  break;\r\n\t  }\r\n}\r\n\r\nvoid DCR_CLASS dcr_simple_coeff (DCRAW* p, int index)\r\n{\r\n\tstatic const float table[][12] = {\r\n\t\t/* index 0 -- all Foveon cameras */\r\n\t\t{ 1.4032f,-0.2231f,-0.1016f,-0.5263f,1.4816f,0.017f,-0.0112f,0.0183f,0.9113f },\r\n\t\t\t/* index 1 -- Kodak DC20 and DC25 */\r\n\t\t{ 2.25f,0.75f,-1.75f,-0.25f,-0.25f,0.75f,0.75f,-0.25f,-0.25f,-1.75f,0.75f,2.25f },\r\n\t\t/* index 2 -- Logitech Fotoman Pixtura */\r\n\t\t{ 1.893f,-0.418f,-0.476f,-0.495f,1.773f,-0.278f,-1.017f,-0.655f,2.672f },\r\n\t\t/* index 3 -- Nikon E880, E900, and E990 */\r\n\t\t{ -1.936280f,  1.800443f, -1.448486f,  2.584324f,\r\n\t\t1.405365f, -0.524955f, -0.289090f,  0.408680f,\r\n\t\t-1.204965f,  1.082304f,  2.941367f, -1.818705f }\r\n\t};\r\n\tint i, c;\r\n\r\n\tfor (p->raw_color = i=0; i < 3; i++)\r\n\t\tFORCC(p) p->rgb_cam[i][c] = table[index][i*p->colors+c];\r\n}\r\n\r\nshort DCR_CLASS dcr_guess_byte_order (DCRAW* p, int words)\r\n{\r\n\tuchar test[4][2];\r\n\tint t=2, msb;\r\n\tdouble diff, sum[2] = {0,0};\r\n\r\n\tdcr_fread(p->obj_, test[0], 2, 2);\r\n\tfor (words-=2; words--; ) {\r\n\t\tdcr_fread(p->obj_, test[t], 2, 1);\r\n\t\tfor (msb=0; msb < 2; msb++) {\r\n\t\t\tdiff = (test[t^2][msb] << 8 | test[t^2][!msb])\r\n\t\t\t\t- (test[t  ][msb] << 8 | test[t  ][!msb]);\r\n\t\t\tsum[msb] += diff*diff;\r\n\t\t}\r\n\t\tt = (t+1) & 3;\r\n\t}\r\n\treturn sum[0] < sum[1] ? 0x4d4d : 0x4949;\r\n}\r\n\r\n/*\r\nIdentify which camera created this file, and set global variables\r\naccordingly.\r\n*/\r\nvoid DCR_CLASS dcr_identify(DCRAW* p)\r\n{\r\n\tchar head[32], *cp;\r\n\tunsigned hlen, fsize, i, c, is_canon;\r\n\tstruct dcr_jhead jh;\r\n\tstatic const struct {\r\n\t\tint fsize;\r\n\t\tchar make[12], model[19], withjpeg;\r\n\t} table[] = {\r\n\t\t{    62464, \"Kodak\",    \"DC20\"            ,0 },\r\n\t\t{   124928, \"Kodak\",    \"DC20\"            ,0 },\r\n\t\t{  1652736, \"Kodak\",    \"DCS200\"          ,0 },\r\n\t\t{  4159302, \"Kodak\",    \"C330\"            ,0 },\r\n\t\t{  4162462, \"Kodak\",    \"C330\"            ,0 },\r\n\t\t{   460800, \"Kodak\",    \"C603v\"           ,0 },\r\n\t\t{   614400, \"Kodak\",    \"C603v\"           ,0 },\r\n\t\t{  6163328, \"Kodak\",    \"C603\"            ,0 },\r\n\t\t{  6166488, \"Kodak\",    \"C603\"            ,0 },\r\n\t\t{  9116448, \"Kodak\",    \"C603y\"           ,0 },\r\n\t\t{   311696, \"ST Micro\", \"STV680 VGA\"      ,0 },  /* SPYz */\r\n\t\t{   614400, \"Kodak\",    \"KAI-0340\"        ,0 },\r\n\t\t{   787456, \"Creative\", \"PC-CAM 600\"      ,0 },\r\n\t\t{  1138688, \"Minolta\",  \"RD175\"           ,0 },\r\n\t\t{  3840000, \"Foculus\",  \"531C\"            ,0 },\r\n\t\t{   786432, \"AVT\",      \"F-080C\"          ,0 },\r\n\t\t{  1447680, \"AVT\",      \"F-145C\"          ,0 },\r\n\t\t{  1920000, \"AVT\",      \"F-201C\"          ,0 },\r\n\t\t{  5067304, \"AVT\",      \"F-510C\"          ,0 },\r\n\t\t{ 10134608, \"AVT\",      \"F-510C\"          ,0 },\r\n\t\t{ 16157136, \"AVT\",      \"F-810C\"          ,0 },\r\n\t\t{  1409024, \"Sony\",     \"XCD-SX910CR\"     ,0 },\r\n\t\t{  2818048, \"Sony\",     \"XCD-SX910CR\"     ,0 },\r\n\t\t{  3884928, \"Micron\",   \"2010\"            ,0 },\r\n\t\t{  6624000, \"Pixelink\", \"A782\"            ,0 },\r\n\t\t{ 13248000, \"Pixelink\", \"A782\"            ,0 },\r\n\t\t{  6291456, \"RoverShot\",\"3320AF\"          ,0 },\r\n\t\t{  6553440, \"Canon\",    \"PowerShot A460\"  ,0 },\r\n\t\t{  6653280, \"Canon\",    \"PowerShot A530\"  ,0 },\r\n\t\t{  6573120, \"Canon\",    \"PowerShot A610\"  ,0 },\r\n\t\t{  9219600, \"Canon\",    \"PowerShot A620\"  ,0 },\r\n\t\t{ 10341600, \"Canon\",    \"PowerShot A720\"  ,0 },\r\n\t\t{ 10383120, \"Canon\",    \"PowerShot A630\"  ,0 },\r\n\t\t{ 12945240, \"Canon\",    \"PowerShot A640\"  ,0 },\r\n\t\t{ 15636240, \"Canon\",    \"PowerShot A650\"  ,0 },\r\n\t\t{  5298000, \"Canon\",    \"PowerShot SD300\" ,0 },\r\n\t\t{  7710960, \"Canon\",    \"PowerShot S3 IS\" ,0 },\r\n\t\t{  5939200, \"OLYMPUS\",  \"C770UZ\"          ,0 },\r\n\t\t{  1581060, \"NIKON\",    \"E900\"            ,1 },  /* or E900s,E910 */\r\n\t\t{  2465792, \"NIKON\",    \"E950\"            ,1 },  /* or E800,E700 */\r\n\t\t{  2940928, \"NIKON\",    \"E2100\"           ,1 },  /* or E2500 */\r\n\t\t{  4771840, \"NIKON\",    \"E990\"            ,1 },  /* or E995, Oly C3030Z */\r\n\t\t{  4775936, \"NIKON\",    \"E3700\"           ,1 },  /* or Optio 33WR */\r\n\t\t{  5869568, \"NIKON\",    \"E4300\"           ,1 },  /* or DiMAGE Z2 */\r\n\t\t{  5865472, \"NIKON\",    \"E4500\"           ,1 },\r\n\t\t{  7438336, \"NIKON\",    \"E5000\"           ,1 },  /* or E5700 */\r\n\t\t{  8998912, \"NIKON\",    \"COOLPIX S6\"      ,1 },\r\n\t\t{  1976352, \"CASIO\",    \"QV-2000UX\"       ,1 },\r\n\t\t{  3217760, \"CASIO\",    \"QV-3*00EX\"       ,1 },\r\n\t\t{  6218368, \"CASIO\",    \"QV-5700\"         ,1 },\r\n\t\t{  6054400, \"CASIO\",    \"QV-R41\"          ,1 },\r\n\t\t{  7530816, \"CASIO\",    \"QV-R51\"          ,1 },\r\n\t\t{  7684000, \"CASIO\",    \"QV-4000\"         ,1 },\r\n\t\t{  4948608, \"CASIO\",    \"EX-S100\"         ,1 },\r\n\t\t{  7542528, \"CASIO\",    \"EX-Z50\"          ,1 },\r\n\t\t{  7753344, \"CASIO\",    \"EX-Z55\"          ,1 },\r\n\t\t{  7426656, \"CASIO\",    \"EX-P505\"         ,1 },\r\n\t\t{  9313536, \"CASIO\",    \"EX-P600\"         ,1 },\r\n\t\t{ 10979200, \"CASIO\",    \"EX-P700\"         ,1 },\r\n\t\t{  3178560, \"PENTAX\",   \"Optio S\"         ,1 },\r\n\t\t{  4841984, \"PENTAX\",   \"Optio S\"         ,1 },\r\n\t\t{  6114240, \"PENTAX\",   \"Optio S4\"        ,1 },  /* or S4i, CASIO EX-Z4 */\r\n\t\t{ 10702848, \"PENTAX\",   \"Optio 750Z\"      ,1 },\r\n\t\t{ 16098048, \"SAMSUNG\",  \"S85\"             ,1 },\r\n\t\t{ 16215552, \"SAMSUNG\",  \"S85\"             ,1 },\r\n\t\t{ 12582980, \"Sinar\",    \"\"                ,0 },\r\n\t\t{ 33292868, \"Sinar\",    \"\"                ,0 },\r\n\t\t{ 44390468, \"Sinar\",    \"\"                ,0 } };\r\n\tstatic const char *corp[] =\r\n\t\t{ \"Canon\", \"NIKON\", \"EPSON\", \"KODAK\", \"Kodak\", \"OLYMPUS\", \"PENTAX\",\r\n\t\t\"MINOLTA\", \"Minolta\", \"Konica\", \"CASIO\", \"Sinar\", \"Phase One\",\r\n\t\t\"SAMSUNG\", \"Mamiya\" };\r\n\r\n\tp->tiff_flip = p->flip = p->filters = -1;\t/* 0 is valid, so -1 is unknown */\r\n\tp->raw_height = p->raw_width = p->fuji_width = p->fuji_layout = p->cr2_slice[0] = 0;\r\n\tp->maximum = p->height = p->width = p->top_margin = p->left_margin = 0;\r\n\tp->cdesc[0] = p->desc[0] = p->artist[0] = p->make[0] = p->model[0] = p->model2[0] = 0;\r\n\tp->iso_speed = p->shutter = p->aperture = p->focal_len = 0.0f; p->unique_id = 0;\r\n\tmemset (p->gpsdata, 0, sizeof p->gpsdata);\r\n\tmemset (p->white, 0, sizeof p->white);\r\n\tp->thumb_offset = p->thumb_length = p->thumb_width = p->thumb_height = 0;\r\n\tp->load_raw = p->thumb_load_raw = 0;\r\n\tp->write_thumb = &DCR_CLASS dcr_jpeg_thumb;\r\n\tp->data_offset = p->meta_length = p->tiff_bps = p->tiff_compress = 0;\r\n\tp->kodak_cbpp = p->zero_after_ff = p->dng_version = p->load_flags = 0;\r\n\tp->timestamp = p->shot_order = p->tiff_samples = p->black = p->is_foveon = 0;\r\n\tp->mix_green = p->profile_length = p->data_error = p->zero_is_bad = 0;\r\n\tp->pixel_aspect = p->is_raw = p->raw_color = p->use_gamma = 1;\r\n\tp->tile_width = p->tile_length = INT_MAX;\r\n\tfor (i=0; i < 4; i++) {\r\n\t\tp->cam_mul[i] = (float)(i == 1);\r\n\t\tp->pre_mul[i] = (float)(i < 3);\r\n\t\tFORC3 p->cmatrix[c][i] = 0.0f;\r\n\t\tFORC3 p->rgb_cam[c][i] = (float)(c == i);\r\n\t}\r\n\tp->colors = 3;\r\n\tp->tiff_bps = 12;\r\n\tfor (i=0; i < 0x4000; i++) p->curve[i] = i;\r\n\r\n\tp->order = dcr_get2(p);\r\n\thlen = dcr_get4(p);\r\n\tdcr_fseek(p->obj_, 0, SEEK_SET);\r\n\tdcr_fread(p->obj_, head, 1, 32);\r\n\tdcr_fseek(p->obj_, 0, SEEK_END);\r\n\tfsize = dcr_ftell(p->obj_);\r\n\tif ((cp = (char *) memmem (head, 32, \"MMMM\", 4)) ||\r\n\t\t(cp = (char *) memmem (head, 32, \"IIII\", 4))) {\r\n\t\tdcr_parse_phase_one (p,cp-head);\r\n\t\tif (cp-head) dcr_parse_tiff(p,0);\r\n\t} else if (p->order == 0x4949 || p->order == 0x4d4d) {\r\n\t\tif (!memcmp (head+6,\"HEAPCCDR\",8)) {\r\n\t\t\tp->data_offset = hlen;\r\n\t\t\tdcr_parse_ciff (p,hlen, fsize - hlen);\r\n\t\t} else {\r\n\t\t\tdcr_parse_tiff(p,0);\r\n\t\t}\r\n\t} else if (!memcmp (head,\"\\xff\\xd8\\xff\\xe1\",4) &&\r\n\t\t!memcmp (head+6,\"Exif\",4)) {\r\n\t\tdcr_fseek(p->obj_, 4, SEEK_SET);\r\n\t\tp->data_offset = 4 + dcr_get2(p);\r\n\t\tdcr_fseek(p->obj_, p->data_offset, SEEK_SET);\r\n\t\tif (dcr_fgetc(p->obj_) != 0xff)\r\n\t\t\tdcr_parse_tiff(p,12);\r\n\t\tp->thumb_offset = 0;\r\n\t} else if (!memcmp (head+25,\"ARECOYK\",7)) {\r\n\t\tstrcpy (p->make, \"Contax\");\r\n\t\tstrcpy (p->model,\"N Digital\");\r\n\t\tdcr_fseek(p->obj_, 33, SEEK_SET);\r\n\t\tdcr_get_timestamp(p,1);\r\n\t\tdcr_fseek(p->obj_, 60, SEEK_SET);\r\n\t\tFORC4 p->cam_mul[c ^ (c >> 1)] = (float)dcr_get4(p);\r\n\t} else if (!strcmp (head, \"PXN\")) {\r\n\t\tstrcpy (p->make, \"Logitech\");\r\n\t\tstrcpy (p->model,\"Fotoman Pixtura\");\r\n\t} else if (!strcmp (head, \"qktk\")) {\r\n\t\tstrcpy (p->make, \"Apple\");\r\n\t\tstrcpy (p->model,\"QuickTake 100\");\r\n\t} else if (!strcmp (head, \"qktn\")) {\r\n\t\tstrcpy (p->make, \"Apple\");\r\n\t\tstrcpy (p->model,\"QuickTake 150\");\r\n\t} else if (!memcmp (head,\"FUJIFILM\",8)) {\r\n\t\tdcr_fseek(p->obj_, 84, SEEK_SET);\r\n\t\tp->thumb_offset = dcr_get4(p);\r\n\t\tp->thumb_length = dcr_get4(p);\r\n\t\tdcr_fseek(p->obj_, 92, SEEK_SET);\r\n\t\tdcr_parse_fuji (p,dcr_get4(p));\r\n\t\tif (p->thumb_offset > 120) {\r\n\t\t\tdcr_fseek(p->obj_, 120, SEEK_SET);\r\n\t\t\tp->is_raw += (i = dcr_get4(p)) && 1;\r\n\t\t\tif (p->is_raw == 2 && p->opt.shot_select)\r\n\t\t\t\tdcr_parse_fuji (p,i);\r\n\t\t}\r\n\t\tdcr_fseek(p->obj_, 100, SEEK_SET);\r\n\t\tp->data_offset = dcr_get4(p);\r\n\t\tdcr_parse_tiff (p, p->thumb_offset+12);\r\n\t} else if (!memcmp (head,\"RIFF\",4)) {\r\n\t\tdcr_fseek(p->obj_, 0, SEEK_SET);\r\n\t\tdcr_parse_riff(p);\r\n\t} else if (!memcmp (head,\"\\0\\001\\0\\001\\0@\",6)) {\r\n\t\tdcr_fseek(p->obj_, 6, SEEK_SET);\r\n\t\tdcr_fread(p->obj_, p->make, 1, 8);\r\n\t\tdcr_fread(p->obj_, p->model, 1, 8);\r\n\t\tdcr_fread(p->obj_, p->model2, 1, 16);\r\n\t\tp->data_offset = dcr_get2(p);\r\n\t\tdcr_get2(p);\r\n\t\tp->raw_width = dcr_get2(p);\r\n\t\tp->raw_height = dcr_get2(p);\r\n\t\tp->load_raw = &DCR_CLASS nokia_load_raw;\r\n\t\tp->filters = 0x61616161;\r\n\t} else if (!memcmp (head,\"DSC-Image\",9))\r\n\t\tdcr_parse_rollei(p);\r\n\telse if (!memcmp (head,\"PWAD\",4))\r\n\t\tdcr_parse_sinar_ia(p);\r\n\telse if (!memcmp (head,\"\\0MRM\",4))\r\n\t\tdcr_parse_minolta(p, 0);\r\n\telse if (!memcmp (head,\"FOVb\",4))\r\n\t\tdcr_parse_foveon(p);\r\n\telse if (!memcmp (head,\"CI\",2))\r\n\t\tdcr_parse_cine(p);\r\n\telse\r\n\t\tfor (i=0; i < sizeof table / sizeof *table; i++)\r\n\t\t\tif ((int)fsize == table[i].fsize) {\r\n\t\t\t\tstrcpy (p->make,  table[i].make );\r\n\t\t\t\tstrcpy (p->model, table[i].model);\r\n\t\t\t\tif (table[i].withjpeg)\r\n\t\t\t\t\tdcr_parse_external_jpeg(p);\r\n\t\t\t}\r\n\tif (p->make[0] == 0) dcr_parse_smal (p,0, fsize);\r\n\tif (p->make[0] == 0) dcr_parse_jpeg (p,p->is_raw = 0);\r\n\r\n\tfor (i=0; i < sizeof corp / sizeof *corp; i++)\r\n\t\tif (strstr (p->make, corp[i]))\t\t/* Simplify company names */\r\n\t\t\tstrcpy (p->make, corp[i]);\r\n\tif (!strncmp (p->make,\"KODAK\",5))\r\n\t\tp->make[16] = p->model[16] = 0;\r\n\tcp = p->make + strlen(p->make);\t\t/* Remove trailing spaces */\r\n\twhile (*--cp == ' ') *cp = 0;\r\n\tcp = p->model + strlen(p->model);\r\n\twhile (*--cp == ' ') *cp = 0;\r\n\ti = strlen(p->make);\t\t\t/* Remove p->make from p->model */\r\n\tif (!strncasecmp (p->model, p->make, i) && p->model[i++] == ' ')\r\n\t\tmemmove (p->model, p->model+i, 64-i);\r\n\tif (!strncmp (p->model,\"Digital Camera \",15))\r\n\t\tstrcpy (p->model, p->model+15);\r\n\tp->desc[511] = p->artist[63] = p->make[63] = p->model[63] = p->model2[63] = 0;\r\n\tif (!p->is_raw) goto notraw;\r\n\r\n\tif (!p->maximum) p->maximum = (1 << p->tiff_bps) - 1;\r\n\tif (!p->height) p->height = p->raw_height;\r\n\tif (!p->width)  p->width  = p->raw_width;\r\n\tif (p->fuji_width) {\r\n\t\tp->width = p->height + p->fuji_width;\r\n\t\tp->height = p->width - 1;\r\n\t\tp->pixel_aspect = 1;\r\n\t}\r\n\tif (p->height == 2624 && p->width == 3936)  /* Pentax K10D and Samsung GX10 */\r\n\t{   p->height  = 2616;   p->width  = 3896; }\r\n\tif (p->height == 3136 && p->width == 4864)\t/* Pentax K20D */\r\n\t{   p->height  = 3124;   p->width  = 4688; }\r\n\tif (p->height == 3014 && p->width == 4096)\t/* Ricoh GX200 */\r\n\t\tp->width  = 4014;\r\n\tif (p->dng_version) {\r\n\t\tif (p->filters == UINT_MAX) p->filters = 0;\r\n\t\tif (p->filters) p->is_raw = p->tiff_samples;\r\n\t\telse\t p->colors = p->tiff_samples;\r\n\t\tif (p->tiff_compress == 1)\r\n\t\t\tp->load_raw = &DCR_CLASS dcr_adobe_dng_load_raw_nc;\r\n\t\tif (p->tiff_compress == 7)\r\n\t\t\tp->load_raw = &DCR_CLASS dcr_adobe_dng_load_raw_lj;\r\n\t\tgoto dng_skip;\r\n\t}\r\n\tif ((is_canon = !strcmp(p->make,\"Canon\")))\r\n\t\tp->load_raw = memcmp (head+6,\"HEAPCCDR\",8) ?\r\n\t\t\t&DCR_CLASS dcr_lossless_jpeg_load_raw : &DCR_CLASS dcr_canon_compressed_load_raw;\r\n\tif (!strcmp(p->make,\"NIKON\")) {\r\n\t\tif (!p->load_raw)\r\n\t\t\tp->load_raw = &DCR_CLASS dcr_packed_12_load_raw;\r\n\t\tif (p->model[0] == 'E')\r\n\t\t\tp->load_flags |= !p->data_offset << 2 | 2;\r\n\t}\r\n\tif (!strcmp(p->make,\"CASIO\")) {\r\n\t\tp->load_raw = &DCR_CLASS dcr_packed_12_load_raw;\r\n\t\tp->maximum = 0xf7f;\r\n\t}\r\n\r\n\t/* Set parameters based on camera name (for non-DNG files). */\r\n\r\n\tif (p->is_foveon) {\r\n#if RESTRICTED\r\n\t\tif (p->height*2 < p->width) p->pixel_aspect = 0.5;\r\n\t\tif (p->height   > p->width) p->pixel_aspect = 2;\r\n\t\tp->filters = 0;\r\n\t\tp->load_raw = &DCR_CLASS dcr_foveon_load_raw;\r\n\t\tdcr_simple_coeff(p, 0);\r\n#endif //RESTRICTED\r\n\t} else if (is_canon && p->tiff_bps == 15) {\r\n\t\tswitch (p->width) {\r\n\t\tcase 3344: p->width -= 66;\r\n\t\tcase 3872: p->width -= 6;\r\n\t\t}\r\n\t\tp->filters = 0;\r\n\t\tp->load_raw = &DCR_CLASS dcr_canon_sraw_load_raw;\r\n\t} else if (!strcmp(p->model,\"PowerShot 600\")) {\r\n\t\tp->height = 613;\r\n\t\tp->width  = 854;\r\n\t\tp->raw_width = 896;\r\n\t\tp->pixel_aspect = 607/628.0;\r\n\t\tp->colors = 4;\r\n\t\tp->filters = 0xe1e4e1e4;\r\n\t\tp->load_raw = &DCR_CLASS dcr_canon_600_load_raw;\r\n\t} else if (!strcmp(p->model,\"PowerShot A5\") ||\r\n\t\t!strcmp(p->model,\"PowerShot A5 Zoom\")) {\r\n\t\tp->height = 773;\r\n\t\tp->width  = 960;\r\n\t\tp->raw_width = 992;\r\n\t\tp->pixel_aspect = 256/235.0;\r\n\t\tp->colors = 4;\r\n\t\tp->filters = 0x1e4e1e4e;\r\n\t\tp->load_raw = &DCR_CLASS dcr_canon_a5_load_raw;\r\n\t} else if (!strcmp(p->model,\"PowerShot A50\")) {\r\n\t\tp->height =  968;\r\n\t\tp->width  = 1290;\r\n\t\tp->raw_width = 1320;\r\n\t\tp->colors = 4;\r\n\t\tp->filters = 0x1b4e4b1e;\r\n\t\tp->load_raw = &DCR_CLASS dcr_canon_a5_load_raw;\r\n\t} else if (!strcmp(p->model,\"PowerShot Pro70\")) {\r\n\t\tp->height = 1024;\r\n\t\tp->width  = 1552;\r\n\t\tp->colors = 4;\r\n\t\tp->filters = 0x1e4b4e1b;\r\n\t\tp->load_raw = &DCR_CLASS dcr_canon_a5_load_raw;\r\n\t} else if (!strcmp(p->model,\"PowerShot SD300\")) {\r\n\t\tp->height = 1752;\r\n\t\tp->width  = 2344;\r\n\t\tp->raw_height = 1766;\r\n\t\tp->raw_width  = 2400;\r\n\t\tp->top_margin  = 12;\r\n\t\tp->left_margin = 12;\r\n\t\tp->load_raw = &DCR_CLASS dcr_canon_a5_load_raw;\r\n\t} else if (!strcmp(p->model,\"PowerShot A460\")) {\r\n\t\tp->height = 1960;\r\n\t\tp->width  = 2616;\r\n\t\tp->raw_height = 1968;\r\n\t\tp->raw_width  = 2664;\r\n\t\tp->top_margin  = 4;\r\n\t\tp->left_margin = 4;\r\n\t\tp->load_raw = &DCR_CLASS dcr_canon_a5_load_raw;\r\n\t} else if (!strcmp(p->model,\"PowerShot A530\")) {\r\n\t\tp->height = 1984;\r\n\t\tp->width  = 2620;\r\n\t\tp->raw_height = 1992;\r\n\t\tp->raw_width  = 2672;\r\n\t\tp->top_margin  = 6;\r\n\t\tp->left_margin = 10;\r\n\t\tp->load_raw = &DCR_CLASS dcr_canon_a5_load_raw;\r\n\t\tp->raw_color = 0;\r\n\t} else if (!strcmp(p->model,\"PowerShot A610\")) {\r\n\t\tif (dcr_canon_s2is(p)) strcpy (p->model+10, \"S2 IS\");\r\n\t\tp->height = 1960;\r\n\t\tp->width  = 2616;\r\n\t\tp->raw_height = 1968;\r\n\t\tp->raw_width  = 2672;\r\n\t\tp->top_margin  = 8;\r\n\t\tp->left_margin = 12;\r\n\t\tp->load_raw = &DCR_CLASS dcr_canon_a5_load_raw;\r\n\t} else if (!strcmp(p->model,\"PowerShot A620\")) {\r\n\t\tp->height = 2328;\r\n\t\tp->width  = 3112;\r\n\t\tp->raw_height = 2340;\r\n\t\tp->raw_width  = 3152;\r\n\t\tp->top_margin  = 12;\r\n\t\tp->left_margin = 36;\r\n\t\tp->load_raw = &DCR_CLASS dcr_canon_a5_load_raw;\r\n\t} else if (!strcmp(p->model,\"PowerShot A720\")) {\r\n\t\tp->height = 2472;\r\n\t\tp->width  = 3298;\r\n\t\tp->raw_height = 2480;\r\n\t\tp->raw_width  = 3336;\r\n\t\tp->top_margin  = 5;\r\n\t\tp->left_margin = 6;\r\n\t\tp->load_raw = &DCR_CLASS dcr_canon_a5_load_raw;\r\n\t} else if (!strcmp(p->model,\"PowerShot A630\")) {\r\n\t\tp->height = 2472;\r\n\t\tp->width  = 3288;\r\n\t\tp->raw_height = 2484;\r\n\t\tp->raw_width  = 3344;\r\n\t\tp->top_margin  = 6;\r\n\t\tp->left_margin = 12;\r\n\t\tp->load_raw = &DCR_CLASS dcr_canon_a5_load_raw;\r\n\t} else if (!strcmp(p->model,\"PowerShot A640\")) {\r\n\t\tp->height = 2760;\r\n\t\tp->width  = 3672;\r\n\t\tp->raw_height = 2772;\r\n\t\tp->raw_width  = 3736;\r\n\t\tp->top_margin  = 6;\r\n\t\tp->left_margin = 12;\r\n\t\tp->load_raw = &DCR_CLASS dcr_canon_a5_load_raw;\r\n\t} else if (!strcmp(p->model,\"PowerShot A650\")) {\r\n\t\tp->height = 3024;\r\n\t\tp->width  = 4032;\r\n\t\tp->raw_height = 3048;\r\n\t\tp->raw_width  = 4104;\r\n\t\tp->top_margin  = 12;\r\n\t\tp->left_margin = 48;\r\n\t\tp->load_raw = &DCR_CLASS dcr_canon_a5_load_raw;\r\n\t} else if (!strcmp(p->model,\"PowerShot S3 IS\")) {\r\n\t\tp->height = 2128;\r\n\t\tp->width  = 2840;\r\n\t\tp->raw_height = 2136;\r\n\t\tp->raw_width  = 2888;\r\n\t\tp->top_margin  = 8;\r\n\t\tp->left_margin = 44;\r\n\t\tp->load_raw = &DCR_CLASS dcr_canon_a5_load_raw;\r\n\t} else if (!strcmp(p->model,\"PowerShot Pro90 IS\")) {\r\n\t\tp->width  = 1896;\r\n\t\tp->colors = 4;\r\n\t\tp->filters = 0xb4b4b4b4;\r\n\t} else if (is_canon && p->raw_width == 2144) {\r\n\t\tp->height = 1550;\r\n\t\tp->width  = 2088;\r\n\t\tp->top_margin  = 8;\r\n\t\tp->left_margin = 4;\r\n\t\tif (!strcmp(p->model,\"PowerShot G1\")) {\r\n\t\t\tp->colors = 4;\r\n\t\t\tp->filters = 0xb4b4b4b4;\r\n\t\t}\r\n\t} else if (is_canon && p->raw_width == 2224) {\r\n\t\tp->height = 1448;\r\n\t\tp->width  = 2176;\r\n\t\tp->top_margin  = 6;\r\n\t\tp->left_margin = 48;\r\n\t} else if (is_canon && p->raw_width == 2376) {\r\n\t\tp->height = 1720;\r\n\t\tp->width  = 2312;\r\n\t\tp->top_margin  = 6;\r\n\t\tp->left_margin = 12;\r\n\t} else if (is_canon && p->raw_width == 2672) {\r\n\t\tp->height = 1960;\r\n\t\tp->width  = 2616;\r\n\t\tp->top_margin  = 6;\r\n\t\tp->left_margin = 12;\r\n\t} else if (is_canon && p->raw_width == 3152) {\r\n\t\tp->height = 2056;\r\n\t\tp->width  = 3088;\r\n\t\tp->top_margin  = 12;\r\n\t\tp->left_margin = 64;\r\n\t\tif (p->unique_id == 0x80000170)\r\n\t\t\tdcr_adobe_coeff (p, \"Canon\",\"EOS 300D\");\r\n\t} else if (is_canon && p->raw_width == 3160) {\r\n\t\tp->height = 2328;\r\n\t\tp->width  = 3112;\r\n\t\tp->top_margin  = 12;\r\n\t\tp->left_margin = 44;\r\n\t} else if (is_canon && p->raw_width == 3344) {\r\n\t\tp->height = 2472;\r\n\t\tp->width  = 3288;\r\n\t\tp->top_margin  = 6;\r\n\t\tp->left_margin = 4;\r\n\t} else if (!strcmp(p->model,\"EOS D2000C\")) {\r\n\t\tp->filters = 0x61616161;\r\n\t\tp->black = p->curve[200];\r\n\t} else if (is_canon && p->raw_width == 3516) {\r\n\t\tp->top_margin  = 14;\r\n\t\tp->left_margin = 42;\r\n\t\tif (p->unique_id == 0x80000189)\r\n\t\t\tdcr_adobe_coeff (p, \"Canon\",\"EOS 350D\");\r\n\t\tgoto canon_cr2;\r\n\t} else if (is_canon && p->raw_width == 3596) {\r\n\t\tp->top_margin  = 12;\r\n\t\tp->left_margin = 74;\r\n\t\tgoto canon_cr2;\r\n\t} else if (is_canon && p->raw_width == 3944) {\r\n\t\tp->height = 2602;\r\n\t\tp->width  = 3908;\r\n\t\tp->top_margin  = 18;\r\n\t\tp->left_margin = 30;\r\n\t} else if (is_canon && p->raw_width == 3948) {\r\n\t\tp->top_margin  = 18;\r\n\t\tp->left_margin = 42;\r\n\t\tp->height -= 2;\r\n\t\tif (p->unique_id == 0x80000236)\r\n\t\t\tdcr_adobe_coeff (p, \"Canon\",\"EOS 400D\");\r\n\t\tif (p->unique_id == 0x80000254)\r\n\t\t\tdcr_adobe_coeff (p, \"Canon\",\"EOS 1000D\");\r\n\t\tgoto canon_cr2;\r\n\t} else if (is_canon && p->raw_width == 3984) {\r\n\t\tp->top_margin  = 20;\r\n\t\tp->left_margin = 76;\r\n\t\tp->height -= 2;\r\n\t\tgoto canon_cr2;\r\n\t} else if (is_canon && p->raw_width == 4104) {\r\n\t\tp->height = 3024;\r\n\t\tp->width  = 4032;\r\n\t\tp->top_margin  = 12;\r\n\t\tp->left_margin = 48;\r\n\t} else if (is_canon && p->raw_width == 4312) {\r\n\t\tp->top_margin  = 18;\r\n\t\tp->left_margin = 22;\r\n\t\tp->height -= 2;\r\n\t\tif (p->unique_id == 0x80000176)\r\n\t\t\tdcr_adobe_coeff (p, \"Canon\",\"EOS 450D\");\r\n\t\tgoto canon_cr2;\r\n\t} else if (is_canon && p->raw_width == 4476) {\r\n\t\tp->top_margin  = 34;\r\n\t\tp->left_margin = 90;\r\n\t\tgoto canon_cr2;\r\n\t} else if (is_canon && p->raw_width == 4480) {\r\n\t\tp->height = 3326;\r\n\t\tp->width  = 4432;\r\n\t\tp->top_margin  = 10;\r\n\t\tp->left_margin = 12;\r\n\t\tp->filters = 0x49494949;\r\n\t} else if (is_canon && p->raw_width == 1208) {\r\n\t\tp->top_margin  = 51;\r\n\t\tp->left_margin = 62;\r\n\t\tp->raw_width = p->width *= 4;\r\n\t\tgoto canon_cr2;\r\n\t} else if (is_canon && p->raw_width == 1448) {\r\n\t\tp->top_margin  = 51;\r\n\t\tp->left_margin = 158;\r\n\t\tp->raw_width = p->width *= 4;\r\n\t\tgoto canon_cr2;\r\n\t} else if (is_canon && p->raw_width == 5108) {\r\n\t\tp->top_margin  = 13;\r\n\t\tp->left_margin = 98;\r\ncanon_cr2:\r\n\t\tp->height -= p->top_margin;\r\n\t\tp->width  -= p->left_margin;\r\n\t} else if (is_canon && p->raw_width == 5712) {\r\n\t\tp->height = 3752;\r\n\t\tp->width  = 5640;\r\n\t\tp->top_margin  = 20;\r\n\t\tp->left_margin = 62;\r\n\t} else if (!strcmp(p->model,\"D1\")) {\r\n\t\tp->cam_mul[0] *= 256/527.0f;\r\n\t\tp->cam_mul[2] *= 256/317.0f;\r\n\t} else if (!strcmp(p->model,\"D1X\")) {\r\n\t\tp->width -= 4;\r\n\t\tp->pixel_aspect = 0.5;\r\n\t} else if (!strcmp(p->model,\"D40X\") ||\r\n\t\t!strcmp(p->model,\"D60\")  ||\r\n\t\t!strcmp(p->model,\"D80\")) {\r\n\t\tp->height -= 3;\r\n\t\tp->width  -= 4;\r\n\t} else if (!strcmp(p->model,\"D3\")   ||\r\n\t\t!strcmp(p->model,\"D700\")) {\r\n\t\tp->width -= 4;\r\n\t\tp->left_margin = 2;\r\n\t} else if (!strncmp(p->model,\"D40\",3) ||\r\n\t\t!strncmp(p->model,\"D50\",3) ||\r\n\t\t!strncmp(p->model,\"D70\",3)) {\r\n\t\tp->width--;\r\n\t} else if (!strcmp(p->model,\"D90\")) {\r\n\t\tp->width -= 42;\r\n\t} else if (!strcmp(p->model,\"D100\")) {\r\n\t\tif (p->tiff_compress == 34713 && !dcr_nikon_is_compressed(p)) {\r\n\t\t\tp->load_raw = &DCR_CLASS dcr_packed_12_load_raw;\r\n\t\t\tp->load_flags |= 8;\r\n\t\t\tp->raw_width = (p->width += 3) + 3;\r\n\t\t}\r\n\t} else if (!strcmp(p->model,\"D200\")) {\r\n\t\tp->left_margin = 1;\r\n\t\tp->width -= 4;\r\n\t\tp->filters = 0x94949494;\r\n\t} else if (!strncmp(p->model,\"D2H\",3)) {\r\n\t\tp->left_margin = 6;\r\n\t\tp->width -= 14;\r\n\t} else if (!strncmp(p->model,\"D2X\",3)) {\r\n\t\tif (p->width == 3264) p->width -= 32;\r\n\t\telse p->width -= 8;\r\n\t} else if (!strcmp(p->model,\"D300\")) {\r\n\t\tp->width -= 32;\r\n\t} else if (!strcmp(p->model,\"COOLPIX P6000\")) {\r\n\t\tp->load_flags = 1;\r\n\t\tp->filters = 0x94949494;\r\n\t} else if (fsize == 1581060) {\r\n\t\tp->height = 963;\r\n\t\tp->width = 1287;\r\n\t\tp->raw_width = 1632;\r\n\t\tp->load_raw = &DCR_CLASS dcr_nikon_e900_load_raw;\r\n\t\tp->maximum = 0x3f4;\r\n\t\tp->colors = 4;\r\n\t\tp->filters = 0x1e1e1e1e;\r\n\t\tdcr_simple_coeff(p, 3);\r\n\t\tp->pre_mul[0] = 1.2085f;\r\n\t\tp->pre_mul[1] = 1.0943f;\r\n\t\tp->pre_mul[3] = 1.1103f;\r\n\t} else if (fsize == 2465792) {\r\n\t\tp->height = 1203;\r\n\t\tp->width  = 1616;\r\n\t\tp->raw_width = 2048;\r\n\t\tp->load_raw = &DCR_CLASS dcr_nikon_e900_load_raw;\r\n\t\tp->colors = 4;\r\n\t\tp->filters = 0x4b4b4b4b;\r\n\t\tdcr_adobe_coeff (p, \"NIKON\",\"E950\");\r\n\t} else if (fsize == 4771840) {\r\n\t\tp->height = 1540;\r\n\t\tp->width  = 2064;\r\n\t\tp->colors = 4;\r\n\t\tp->filters = 0xe1e1e1e1;\r\n\t\tp->load_raw = &DCR_CLASS dcr_packed_12_load_raw;\r\n\t\tp->load_flags = 6;\r\n\t\tif (!p->timestamp && dcr_nikon_e995(p))\r\n\t\t\tstrcpy (p->model, \"E995\");\r\n\t\tif (strcmp(p->model,\"E995\")) {\r\n\t\t\tp->filters = 0xb4b4b4b4;\r\n\t\t\tdcr_simple_coeff(p, 3);\r\n\t\t\tp->pre_mul[0] = 1.196f;\r\n\t\t\tp->pre_mul[1] = 1.246f;\r\n\t\t\tp->pre_mul[2] = 1.018f;\r\n\t\t}\r\n\t} else if (!strcmp(p->model,\"E2100\")) {\r\n\t\tif (!p->timestamp && !dcr_nikon_e2100(p)) goto cp_e2500;\r\n\t\tp->height = 1206;\r\n\t\tp->width  = 1616;\r\n\t\tp->load_flags = 7;\r\n\t} else if (!strcmp(p->model,\"E2500\")) {\r\ncp_e2500:\r\n\tstrcpy (p->model, \"E2500\");\r\n\tp->height = 1204;\r\n\tp->width  = 1616;\r\n\tp->colors = 4;\r\n\tp->filters = 0x4b4b4b4b;\r\n\t} else if (fsize == 4775936) {\r\n\t\tp->height = 1542;\r\n\t\tp->width  = 2064;\r\n\t\tp->load_raw = &DCR_CLASS dcr_packed_12_load_raw;\r\n\t\tp->load_flags = 7;\r\n\t\tp->pre_mul[0] = 1.818f;\r\n\t\tp->pre_mul[2] = 1.618f;\r\n\t\tif (!p->timestamp) dcr_nikon_3700(p);\r\n\t\tif (p->model[0] == 'E' && atoi(p->model+1) < 3700)\r\n\t\t\tp->filters = 0x49494949;\r\n\t\tif (!strcmp(p->model,\"Optio 33WR\")) {\r\n\t\t\tp->flip = 1;\r\n\t\t\tp->filters = 0x16161616;\r\n\t\t\tp->pre_mul[0] = 1.331f;\r\n\t\t\tp->pre_mul[2] = 1.820f;\r\n\t\t}\r\n\t} else if (fsize == 5869568) {\r\n\t\tp->height = 1710;\r\n\t\tp->width  = 2288;\r\n\t\tp->filters = 0x16161616;\r\n\t\tif (!p->timestamp && dcr_minolta_z2(p)) {\r\n\t\t\tstrcpy (p->make, \"Minolta\");\r\n\t\t\tstrcpy (p->model,\"DiMAGE Z2\");\r\n\t\t}\r\n\t\tp->load_raw = &DCR_CLASS dcr_packed_12_load_raw;\r\n\t\tp->load_flags = 6 + (p->make[0] == 'M');\r\n\t} else if (!strcmp(p->model,\"E4500\")) {\r\n\t\tp->height = 1708;\r\n\t\tp->width  = 2288;\r\n\t\tp->colors = 4;\r\n\t\tp->filters = 0xb4b4b4b4;\r\n\t} else if (fsize == 7438336) {\r\n\t\tp->height = 1924;\r\n\t\tp->width  = 2576;\r\n\t\tp->colors = 4;\r\n\t\tp->filters = 0xb4b4b4b4;\r\n\t} else if (fsize == 8998912) {\r\n\t\tp->height = 2118;\r\n\t\tp->width  = 2832;\r\n\t\tp->maximum = 0xf83;\r\n\t\tp->load_raw = &DCR_CLASS dcr_packed_12_load_raw;\r\n\t\tp->load_flags = 7;\r\n\t} else if (!strcmp(p->model,\"FinePix S5100\") ||\r\n\t\t!strcmp(p->model,\"FinePix S5500\")) {\r\n\t\tp->load_raw = &DCR_CLASS dcr_unpacked_load_raw;\r\n\t} else if (!strcmp(p->make,\"FUJIFILM\")) {\r\n\t\tif (!strcmp(p->model+7,\"S2Pro\")) {\r\n\t\t\tstrcpy (p->model+7,\" S2Pro\");\r\n\t\t\tp->height = 2144;\r\n\t\t\tp->width  = 2880;\r\n\t\t\tp->flip = 6;\r\n\t\t} else\r\n\t\t\tp->maximum = 0x3e00;\r\n\t\tif (p->is_raw == 2 && p->opt.shot_select)\r\n\t\t\tp->maximum = 0x2f00;\r\n\t\tp->top_margin = (p->raw_height - p->height)/2;\r\n\t\tp->left_margin = (p->raw_width - p->width )/2;\r\n\t\tif (p->is_raw == 2)\r\n\t\t\tp->data_offset += (p->opt.shot_select > 0) * ( p->fuji_layout ?\r\n\t\t\t(p->raw_width *= 2) : p->raw_height*p->raw_width*2 );\r\n\t\tp->fuji_width = p->width >> !p->fuji_layout;\r\n\t\tp->width = (p->height >> p->fuji_layout) + p->fuji_width;\r\n\t\tp->raw_height = p->height;\r\n\t\tp->height = p->width - 1;\r\n\t\tp->load_raw = &DCR_CLASS dcr_fuji_load_raw;\r\n\t\tif (!(p->fuji_width & 1)) p->filters = 0x49494949;\r\n\t} else if (!strcmp(p->model,\"RD175\")) {\r\n\t\tp->height = 986;\r\n\t\tp->width = 1534;\r\n\t\tp->data_offset = 513;\r\n\t\tp->filters = 0x61616161;\r\n\t\tp->load_raw = &DCR_CLASS dcr_minolta_rd175_load_raw;\r\n\t} else if (!strcmp(p->model,\"KD-400Z\")) {\r\n\t\tp->height = 1712;\r\n\t\tp->width  = 2312;\r\n\t\tp->raw_width = 2336;\r\n\t\tgoto konica_400z;\r\n\t} else if (!strcmp(p->model,\"KD-510Z\")) {\r\n\t\tgoto konica_510z;\r\n\t} else if (!strcasecmp(p->make,\"MINOLTA\")) {\r\n\t\tp->load_raw = &DCR_CLASS dcr_unpacked_load_raw;\r\n\t\tif (!strncmp(p->model,\"DiMAGE A\",8)) {\r\n\t\t\tif (!strcmp(p->model,\"DiMAGE A200\"))\r\n\t\t\t\tp->filters = 0x49494949;\r\n\t\t\tp->load_raw = &DCR_CLASS dcr_packed_12_load_raw;\r\n\t\t} else if (!strncmp(p->model,\"ALPHA\",5) ||\r\n\t\t\t!strncmp(p->model,\"DYNAX\",5) ||\r\n\t\t\t!strncmp(p->model,\"MAXXUM\",6)) {\r\n\t\t\tsprintf (p->model+20, \"DYNAX %-10s\", p->model+6+(p->model[0]=='M'));\r\n\t\t\tdcr_adobe_coeff (p, p->make, p->model+20);\r\n\t\t\tp->load_raw = &DCR_CLASS dcr_packed_12_load_raw;\r\n\t\t} else if (!strncmp(p->model,\"DiMAGE G\",8)) {\r\n\t\t\tif (p->model[8] == '4') {\r\n\t\t\t\tp->height = 1716;\r\n\t\t\t\tp->width  = 2304;\r\n\t\t\t} else if (p->model[8] == '5') {\r\nkonica_510z:\r\n\t\t\tp->height = 1956;\r\n\t\t\tp->width  = 2607;\r\n\t\t\tp->raw_width = 2624;\r\n\t\t\t} else if (p->model[8] == '6') {\r\n\t\t\t\tp->height = 2136;\r\n\t\t\t\tp->width  = 2848;\r\n\t\t\t}\r\n\t\t\tp->data_offset += 14;\r\n\t\t\tp->filters = 0x61616161;\r\nkonica_400z:\r\n\t\t\tp->load_raw = &DCR_CLASS dcr_unpacked_load_raw;\r\n\t\t\tp->maximum = 0x3df;\r\n\t\t\tp->order = 0x4d4d;\r\n\t\t}\r\n\t} else if (!strcmp(p->model,\"*ist DS\")) {\r\n\t\tp->height -= 2;\r\n\t} else if (!strcmp(p->model,\"K20D\")) {\r\n\t\tp->filters = 0x16161616;\r\n\t} else if (!strcmp(p->model,\"Optio S\")) {\r\n\t\tif (fsize == 3178560) {\r\n\t\t\tp->height = 1540;\r\n\t\t\tp->width  = 2064;\r\n\t\t\tp->load_raw = &DCR_CLASS dcr_eight_bit_load_raw;\r\n\t\t\tp->cam_mul[0] *= 4;\r\n\t\t\tp->cam_mul[2] *= 4;\r\n\t\t\tp->pre_mul[0] = 1.391f;\r\n\t\t\tp->pre_mul[2] = 1.188f;\r\n\t\t} else {\r\n\t\t\tp->height = 1544;\r\n\t\t\tp->width  = 2068;\r\n\t\t\tp->raw_width = 3136;\r\n\t\t\tp->load_raw = &DCR_CLASS dcr_packed_12_load_raw;\r\n\t\t\tp->maximum = 0xf7c;\r\n\t\t\tp->pre_mul[0] = 1.137f;\r\n\t\t\tp->pre_mul[2] = 1.453f;\r\n\t\t}\r\n\t} else if (fsize == 6114240) {\r\n\t\tp->height = 1737;\r\n\t\tp->width  = 2324;\r\n\t\tp->raw_width = 3520;\r\n\t\tp->load_raw = &DCR_CLASS dcr_packed_12_load_raw;\r\n\t\tp->maximum = 0xf7a;\r\n\t\tp->pre_mul[0] = 1.980f;\r\n\t\tp->pre_mul[2] = 1.570f;\r\n\t} else if (!strcmp(p->model,\"Optio 750Z\")) {\r\n\t\tp->height = 2302;\r\n\t\tp->width  = 3072;\r\n\t\tp->load_raw = &DCR_CLASS dcr_packed_12_load_raw;\r\n\t\tp->load_flags = 7;\r\n\t} else if (!strcmp(p->model,\"S85\")) {\r\n\t\tp->height = 2448;\r\n\t\tp->width  = 3264;\r\n\t\tp->raw_width = fsize/p->height/2;\r\n\t\tp->order = 0x4d4d;\r\n\t\tp->load_raw = &DCR_CLASS dcr_unpacked_load_raw;\r\n\t\tp->maximum = 0xffff;\r\n\t} else if (!strcmp(p->model,\"STV680 VGA\")) {\r\n\t\tp->height = 484;\r\n\t\tp->width  = 644;\r\n\t\tp->load_raw = &DCR_CLASS dcr_eight_bit_load_raw;\r\n\t\tp->flip = 2;\r\n\t\tp->filters = 0x16161616;\r\n\t\tp->black = 16;\r\n\t\tp->pre_mul[0] = 1.097f;\r\n\t\tp->pre_mul[2] = 1.128f;\r\n\t} else if (!strcmp(p->model,\"KAI-0340\")) {\r\n\t\tp->height = 477;\r\n\t\tp->width  = 640;\r\n\t\tp->order = 0x4949;\r\n\t\tp->data_offset = 3840;\r\n\t\tp->load_raw = &DCR_CLASS dcr_unpacked_load_raw;\r\n\t\tp->pre_mul[0] = 1.561f;\r\n\t\tp->pre_mul[2] = 2.454f;\r\n\t} else if (!strcmp(p->model,\"N95\")) {\r\n\t\tp->height = p->raw_height - (p->top_margin = 2);\r\n\t} else if (!strcmp(p->model,\"531C\")) {\r\n\t\tp->height = 1200;\r\n\t\tp->width  = 1600;\r\n\t\tp->load_raw = &DCR_CLASS dcr_unpacked_load_raw;\r\n\t\tp->filters = 0x49494949;\r\n\t\tp->pre_mul[1] = 1.218f;\r\n\t} else if (!strcmp(p->model,\"F-080C\")) {\r\n\t\tp->height = 768;\r\n\t\tp->width  = 1024;\r\n\t\tp->load_raw = &DCR_CLASS dcr_eight_bit_load_raw;\r\n\t} else if (!strcmp(p->model,\"F-145C\")) {\r\n\t\tp->height = 1040;\r\n\t\tp->width  = 1392;\r\n\t\tp->load_raw = &DCR_CLASS dcr_eight_bit_load_raw;\r\n\t} else if (!strcmp(p->model,\"F-201C\")) {\r\n\t\tp->height = 1200;\r\n\t\tp->width  = 1600;\r\n\t\tp->load_raw = &DCR_CLASS dcr_eight_bit_load_raw;\r\n\t} else if (!strcmp(p->model,\"F-510C\")) {\r\n\t\tp->height = 1958;\r\n\t\tp->width  = 2588;\r\n\t\tp->load_raw = fsize < 7500000 ?\r\n\t\t\t&DCR_CLASS dcr_eight_bit_load_raw : &DCR_CLASS dcr_unpacked_load_raw;\r\n\t\tp->maximum = 0xfff0;\r\n\t} else if (!strcmp(p->model,\"F-810C\")) {\r\n\t\tp->height = 2469;\r\n\t\tp->width  = 3272;\r\n\t\tp->load_raw = &DCR_CLASS dcr_unpacked_load_raw;\r\n\t\tp->maximum = 0xfff0;\r\n\t} else if (!strcmp(p->model,\"XCD-SX910CR\")) {\r\n\t\tp->height = 1024;\r\n\t\tp->width  = 1375;\r\n\t\tp->raw_width = 1376;\r\n\t\tp->filters = 0x49494949;\r\n\t\tp->maximum = 0x3ff;\r\n\t\tp->load_raw = fsize < 2000000 ?\r\n\t\t\t&DCR_CLASS dcr_eight_bit_load_raw : &DCR_CLASS dcr_unpacked_load_raw;\r\n\t} else if (!strcmp(p->model,\"2010\")) {\r\n\t\tp->height = 1207;\r\n\t\tp->width  = 1608;\r\n\t\tp->order = 0x4949;\r\n\t\tp->filters = 0x16161616;\r\n\t\tp->data_offset = 3212;\r\n\t\tp->maximum = 0x3ff;\r\n\t\tp->load_raw = &DCR_CLASS dcr_unpacked_load_raw;\r\n\t} else if (!strcmp(p->model,\"A782\")) {\r\n\t\tp->height = 3000;\r\n\t\tp->width  = 2208;\r\n\t\tp->filters = 0x61616161;\r\n\t\tp->load_raw = fsize < 10000000 ?\r\n\t\t\t&DCR_CLASS dcr_eight_bit_load_raw : &DCR_CLASS dcr_unpacked_load_raw;\r\n\t\tp->maximum = 0xffc0;\r\n\t} else if (!strcmp(p->model,\"3320AF\")) {\r\n\t\tp->height = 1536;\r\n\t\tp->raw_width = p->width = 2048;\r\n\t\tp->filters = 0x61616161;\r\n\t\tp->load_raw = &DCR_CLASS dcr_unpacked_load_raw;\r\n\t\tp->maximum = 0x3ff;\r\n\t\tp->pre_mul[0] = 1.717f;\r\n\t\tp->pre_mul[2] = 1.138f;\r\n\t\tdcr_fseek(p->obj_, 0x300000, SEEK_SET);\r\n\t\tif ((p->order = dcr_guess_byte_order(p, 0x10000)) == 0x4d4d) {\r\n\t\t\tp->height -= (p->top_margin = 16);\r\n\t\t\tp->width -= (p->left_margin = 28);\r\n\t\t\tp->maximum = 0xf5c0;\r\n\t\t\tstrcpy (p->make, \"ISG\");\r\n\t\t\tp->model[0] = 0;\r\n\t\t}\r\n\t} else if (!strcmp(p->make,\"Hasselblad\")) {\r\n\t\tif (p->load_raw == &DCR_CLASS dcr_lossless_jpeg_load_raw)\r\n\t\t\tp->load_raw = &DCR_CLASS dcr_hasselblad_load_raw;\r\n\t\tif (p->raw_width == 7262) {\r\n\t\t\tp->height = 5444;\r\n\t\t\tp->width  = 7248;\r\n\t\t\tp->top_margin  = 4;\r\n\t\t\tp->left_margin = 7;\r\n\t\t\tp->filters = 0x61616161;\r\n\t\t} else if (p->raw_width == 4090) {\r\n\t\t\tstrcpy (p->model, \"V96C\");\r\n\t\t\tp->height -= (p->top_margin = 6);\r\n\t\t\tp->width -= (p->left_margin = 3) + 7;\r\n\t\t\tp->filters = 0x61616161;\r\n\t\t}\r\n\t} else if (!strcmp(p->make,\"Sinar\")) {\r\n\t\tif (!memcmp(head,\"8BPS\",4)) {\r\n\t\t\tdcr_fseek(p->obj_, 14, SEEK_SET);\r\n\t\t\tp->height = dcr_get4(p);\r\n\t\t\tp->width  = dcr_get4(p);\r\n\t\t\tp->filters = 0x61616161;\r\n\t\t\tp->data_offset = 68;\r\n\t\t}\r\n\t\tif (!p->load_raw) p->load_raw = &DCR_CLASS dcr_unpacked_load_raw;\r\n\t\tp->maximum = 0x3fff;\r\n\t} else if (!strcmp(p->make,\"Leaf\")) {\r\n\t\tp->maximum = 0x3fff;\r\n\t\tdcr_fseek(p->obj_, p->data_offset, SEEK_SET);\r\n\t\tif (dcr_ljpeg_start (p, &jh, 1) && jh.bits == 15)\r\n\t\t\tp->maximum = 0x1fff;\r\n\t\tif (p->tiff_samples > 1) p->filters = 0;\r\n\t\tif (p->tiff_samples > 1 || p->tile_length < p->raw_height)\r\n\t\t\tp->load_raw = &DCR_CLASS dcr_leaf_hdr_load_raw;\r\n\t\tif ((p->width | p->height) == 2048) {\r\n\t\t\tif (p->tiff_samples == 1) {\r\n\t\t\t\tp->filters = 1;\r\n\t\t\t\tstrcpy (p->cdesc, \"RBTG\");\r\n\t\t\t\tstrcpy (p->model, \"CatchLight\");\r\n\t\t\t\tp->top_margin =  8; p->left_margin = 18; p->height = 2032; p->width = 2016;\r\n\t\t\t} else {\r\n\t\t\t\tstrcpy (p->model, \"DCB2\");\r\n\t\t\t\tp->top_margin = 10; p->left_margin = 16; p->height = 2028; p->width = 2022;\r\n\t\t\t}\r\n\t\t} else if (p->width+p->height == 3144+2060) {\r\n\t\t\tif (!p->model[0]) strcpy (p->model, \"Cantare\");\r\n\t\t\tif (p->width > p->height) {\r\n\t\t\t\tp->top_margin = 6; p->left_margin = 32; p->height = 2048;  p->width = 3072;\r\n\t\t\t\tp->filters = 0x61616161;\r\n\t\t\t} else {\r\n\t\t\t\tp->left_margin = 6;  p->top_margin = 32;  p->width = 2048; p->height = 3072;\r\n\t\t\t\tp->filters = 0x16161616;\r\n\t\t\t}\r\n\t\t\tif (!p->cam_mul[0] || p->model[0] == 'V') p->filters = 0;\r\n\t\t\telse p->is_raw = p->tiff_samples;\r\n\t\t} else if (p->width == 2116) {\r\n\t\t\tstrcpy (p->model, \"Valeo 6\");\r\n\t\t\tp->height -= 2 * (p->top_margin = 30);\r\n\t\t\tp->width -= 2 * (p->left_margin = 55);\r\n\t\t\tp->filters = 0x49494949;\r\n\t\t} else if (p->width == 3171) {\r\n\t\t\tstrcpy (p->model, \"Valeo 6\");\r\n\t\t\tp->height -= 2 * (p->top_margin = 24);\r\n\t\t\tp->width -= 2 * (p->left_margin = 24);\r\n\t\t\tp->filters = 0x16161616;\r\n\t\t}\r\n\t} else if (!strcmp(p->make,\"LEICA\") || !strcmp(p->make,\"Panasonic\")) {\r\n\t\tp->maximum = 0xfff0;\r\n        if ((fsize-p->data_offset) / max(1, p->width*8/7) == p->height)\r\n\t\t\tp->load_raw = &DCR_CLASS dcr_panasonic_load_raw;\r\n\t\tif (!p->load_raw) p->load_raw = &DCR_CLASS dcr_unpacked_load_raw;\r\n\t\tswitch (p->width) {\r\n\t\tcase 2568:\r\n\t\t\tdcr_adobe_coeff (p, \"Panasonic\",\"DMC-LC1\");  break;\r\n\t\tcase 3130:\r\n\t\t\tp->left_margin = -14;\r\n\t\tcase 3170:\r\n\t\t\tp->left_margin += 18;\r\n\t\t\tp->width = 3096;\r\n\t\t\tif (p->height > 2326) {\r\n\t\t\t\tp->height = 2326;\r\n\t\t\t\tp->top_margin = 13;\r\n\t\t\t\tp->filters = 0x49494949;\r\n\t\t\t}\r\n\t\t\tp->zero_is_bad = 1;\r\n\t\t\tdcr_adobe_coeff (p, \"Panasonic\",\"DMC-FZ8\");  break;\r\n\t\tcase 3213:\r\n\t\t\tp->width -= 27;\r\n\t\tcase 3177:\r\n\t\t\tp->width -= 10;\r\n\t\t\tp->filters = 0x49494949;\r\n\t\t\tp->zero_is_bad = 1;\r\n\t\t\tdcr_adobe_coeff (p, \"Panasonic\",\"DMC-L1\");  break;\r\n\t\tcase 3304:\r\n\t\t\tp->width -= 17;\r\n\t\t\tp->zero_is_bad = 1;\r\n\t\t\tdcr_adobe_coeff (p, \"Panasonic\",\"DMC-FZ30\");  break;\r\n\t\tcase 3330:\r\n\t\t\tp->width += 43;\r\n\t\t\tp->left_margin = -6;\r\n\t\t\tp->maximum = 0xf7f0;\r\n\t\tcase 3370:\r\n\t\t\tp->width -= 82;\r\n\t\t\tp->left_margin += 15;\r\n\t\t\tif (p->height > 2480)\r\n\t\t\t\tp->height = 2480 - (p->top_margin = 10);\r\n\t\t\tp->filters = 0x49494949;\r\n\t\t\tp->zero_is_bad = 1;\r\n\t\t\tdcr_adobe_coeff (p, \"Panasonic\",\"DMC-FZ18\");  break;\r\n\t\tcase 3690:\r\n\t\t\tp->height -= 2;\r\n\t\t\tp->left_margin = -14;\r\n\t\t\tp->maximum = 0xf7f0;\r\n\t\tcase 3770:\r\n\t\t\tp->width = 3672;\r\n\t\t\tif (--p->height == 2798 && (p->height = 2760))\r\n\t\t\t\tp->top_margin = 15;\r\n\t\t\telse p->filters = 0x49494949;\r\n\t\t\tp->left_margin += 17;\r\n\t\t\tp->zero_is_bad = 1;\r\n\t\t\tdcr_adobe_coeff (p, \"Panasonic\",\"DMC-FZ50\");  break;\r\n\t\tcase 3710:\r\n\t\t\tp->width = 3682;\r\n\t\t\tp->filters = 0x49494949;\r\n\t\t\tdcr_adobe_coeff (p, \"Panasonic\",\"DMC-L10\");  break;\r\n\t\tcase 3724:\r\n\t\t\tp->width -= 14;\r\n\t\tcase 3836:\r\n\t\t\tp->width -= 42;\r\nlx3:\tp->filters = 0x16161616;\r\n\t\tif (p->make[0] != 'P')\r\n\t\t\tdcr_adobe_coeff (p, \"Panasonic\",\"DMC-LX3\");\r\n\t\tbreak;\r\n\t\tcase 3880:\r\n\t\t\tp->width -= 22;\r\n\t\t\tp->left_margin = 6;\r\n\t\t\tp->zero_is_bad = 1;\r\n\t\t\tdcr_adobe_coeff (p, \"Panasonic\",\"DMC-LX1\");  break;\r\n\t\tcase 4060:\r\n\t\t\tp->width = 3982;\r\n\t\t\tif (p->height == 2250) goto lx3;\r\n\t\t\tp->width = 4018;\r\n\t\t\tp->filters = 0x49494949;\r\n\t\t\tp->zero_is_bad = 1;\r\n\t\t\tdcr_adobe_coeff (p, \"Panasonic\",\"DMC-G1\");  break;\r\n\t\tcase 4290:\r\n\t\t\tp->height += 38;\r\n\t\t\tp->left_margin = -14;\r\n\t\t\tp->filters = 0x49494949;\r\n\t\tcase 4330:\r\n\t\t\tp->width = 4248;\r\n\t\t\tif ((p->height -= 39) == 2400)\r\n\t\t\t\tp->top_margin = 15;\r\n\t\t\tp->left_margin += 17;\r\n\t\t\tdcr_adobe_coeff (p, \"Panasonic\",\"DMC-LX2\");  break;\r\n\t\tcase 4508:\r\n\t\t\tp->height -= 6;\r\n\t\t\tp->width = 4429;\r\n\t\t\tp->filters = 0x16161616;\r\n\t\t\tdcr_adobe_coeff (p, \"Panasonic\",\"DMC-FX150\");  break;\r\n\t\t}\r\n\t} else if (!strcmp(p->model,\"C770UZ\")) {\r\n\t\tp->height = 1718;\r\n\t\tp->width  = 2304;\r\n\t\tp->filters = 0x16161616;\r\n\t\tp->load_raw = &DCR_CLASS dcr_packed_12_load_raw;\r\n\t\tp->load_flags = 7;\r\n\t} else if (!strcmp(p->make,\"OLYMPUS\")) {\r\n\t\tp->height += p->height & 1;\r\n\t\tp->filters = p->exif_cfa;\r\n\t\tif (p->load_raw == &DCR_CLASS dcr_olympus_e410_load_raw) {\r\n\t\t\tp->black >>= 4;\r\n\t\t} else if (!strcmp(p->model,\"E-10\") ||\r\n\t\t\t!strncmp(p->model,\"E-20\",4)) {\r\n\t\t\tp->black <<= 2;\r\n\t\t} else if (!strcmp(p->model,\"E-300\") ||\r\n\t\t\t!strcmp(p->model,\"E-500\")) {\r\n\t\t\tp->width -= 20;\r\n\t\t\tif (p->load_raw == &DCR_CLASS dcr_unpacked_load_raw) {\r\n\t\t\t\tp->maximum = 0xfc30;\r\n\t\t\t\tp->black = 0;\r\n\t\t\t}\r\n\t\t} else if (!strcmp(p->model,\"E-330\")) {\r\n\t\t\tp->width -= 30;\r\n\t\t\tif (p->load_raw == &DCR_CLASS dcr_unpacked_load_raw)\r\n\t\t\t\tp->maximum = 0xf790;\r\n\t\t} else if (!strcmp(p->model,\"SP550UZ\")) {\r\n\t\t\tp->thumb_length = fsize - (p->thumb_offset = 0xa39800);\r\n\t\t\tp->thumb_height = 480;\r\n\t\t\tp->thumb_width  = 640;\r\n\t\t}\r\n\t} else if (!strcmp(p->model,\"N Digital\")) {\r\n\t\tp->height = 2047;\r\n\t\tp->width  = 3072;\r\n\t\tp->filters = 0x61616161;\r\n\t\tp->data_offset = 0x1a00;\r\n\t\tp->load_raw = &DCR_CLASS dcr_packed_12_load_raw;\r\n\t} else if (!strcmp(p->model,\"DSC-F828\")) {\r\n\t\tp->width = 3288;\r\n\t\tp->left_margin = 5;\r\n\t\tp->data_offset = 862144;\r\n\t\tp->load_raw = &DCR_CLASS dcr_sony_load_raw;\r\n\t\tp->filters = 0x9c9c9c9c;\r\n\t\tp->colors = 4;\r\n\t\tstrcpy (p->cdesc, \"RGBE\");\r\n\t} else if (!strcmp(p->model,\"DSC-V3\")) {\r\n\t\tp->width = 3109;\r\n\t\tp->left_margin = 59;\r\n\t\tp->data_offset = 787392;\r\n\t\tp->load_raw = &DCR_CLASS dcr_sony_load_raw;\r\n\t} else if (!strcmp(p->make,\"SONY\") && p->raw_width == 3984) {\r\n\t\tdcr_adobe_coeff (p, \"SONY\",\"DSC-R1\");\r\n\t\tp->width = 3925;\r\n\t\tp->order = 0x4d4d;\r\n\t} else if (!strcmp(p->model,\"DSLR-A100\")) {\r\n\t\tp->height--;\r\n\t} else if (!strcmp(p->model,\"DSLR-A350\")) {\r\n\t\tp->height -= 4;\r\n\t} else if (!strcmp(p->model,\"C603v\")) {\r\n\t\tp->height = 480;\r\n\t\tp->width  = 640;\r\n\t\tgoto c603v;\r\n\t} else if (!strcmp(p->model,\"C603y\")) {\r\n\t\tp->height = 2134;\r\n\t\tp->width  = 2848;\r\nc603v:\r\n\t\tp->filters = 0;\r\n\t\tp->load_raw = &DCR_CLASS dcr_kodak_yrgb_load_raw;\r\n\t} else if (!strcmp(p->model,\"C603\")) {\r\n\t\tp->raw_height = p->height = 2152;\r\n\t\tp->raw_width  = p->width  = 2864;\r\n\t\tgoto c603;\r\n\t} else if (!strcmp(p->model,\"C330\")) {\r\n\t\tp->height = 1744;\r\n\t\tp->width  = 2336;\r\n\t\tp->raw_height = 1779;\r\n\t\tp->raw_width  = 2338;\r\n\t\tp->top_margin = 33;\r\n\t\tp->left_margin = 1;\r\nc603:\r\n\t\tp->order = 0x4949;\r\n\t\tif ((p->data_offset = fsize - p->raw_height*p->raw_width)) {\r\n\t\t\tdcr_fseek(p->obj_, 168, SEEK_SET);\r\n\t\t\tdcr_read_shorts (p, p->curve, 256);\r\n\t\t} else p->use_gamma = 0;\r\n\t\tp->load_raw = &DCR_CLASS dcr_eight_bit_load_raw;\r\n\t} else if (!strcasecmp(p->make,\"KODAK\")) {\r\n\t\tif (p->filters == UINT_MAX) p->filters = 0x61616161;\r\n\t\tif (!strncmp(p->model,\"NC2000\",6)) {\r\n\t\t\tp->width -= 4;\r\n\t\t\tp->left_margin = 2;\r\n\t\t} else if (!strcmp(p->model,\"EOSDCS3B\")) {\r\n\t\t\tp->width -= 4;\r\n\t\t\tp->left_margin = 2;\r\n\t\t} else if (!strcmp(p->model,\"EOSDCS1\")) {\r\n\t\t\tp->width -= 4;\r\n\t\t\tp->left_margin = 2;\r\n\t\t} else if (!strcmp(p->model,\"DCS420\")) {\r\n\t\t\tp->width -= 4;\r\n\t\t\tp->left_margin = 2;\r\n\t\t} else if (!strcmp(p->model,\"DCS460\")) {\r\n\t\t\tp->width -= 4;\r\n\t\t\tp->left_margin = 2;\r\n\t\t} else if (!strcmp(p->model,\"DCS460A\")) {\r\n\t\t\tp->width -= 4;\r\n\t\t\tp->left_margin = 2;\r\n\t\t\tp->colors = 1;\r\n\t\t\tp->filters = 0;\r\n\t\t} else if (!strcmp(p->model,\"DCS660M\")) {\r\n\t\t\tp->black = 214;\r\n\t\t\tp->colors = 1;\r\n\t\t\tp->filters = 0;\r\n\t\t} else if (!strcmp(p->model,\"DCS760M\")) {\r\n\t\t\tp->colors = 1;\r\n\t\t\tp->filters = 0;\r\n\t\t}\r\n\t\tif (!strcmp(p->model+4,\"20X\"))\r\n\t\t\tstrcpy (p->cdesc, \"MYCY\");\r\n\t\tif (strstr(p->model,\"DC25\")) {\r\n\t\t\tstrcpy (p->model, \"DC25\");\r\n\t\t\tp->data_offset = 15424;\r\n\t\t}\r\n\t\tif (!strncmp(p->model,\"DC2\",3)) {\r\n\t\t\tp->height = 242;\r\n\t\t\tif (fsize < 100000) {\r\n\t\t\t\tp->raw_width = 256; p->width = 249;\r\n\t\t\t\tp->pixel_aspect = (4.0*p->height) / (3.0*p->width);\r\n\t\t\t} else {\r\n\t\t\t\tp->raw_width = 512; p->width = 501;\r\n\t\t\t\tp->pixel_aspect = (493.0*p->height) / (373.0*p->width);\r\n\t\t\t}\r\n\t\t\tp->data_offset += p->raw_width + 1;\r\n\t\t\tp->colors = 4;\r\n\t\t\tp->filters = 0x8d8d8d8d;\r\n\t\t\tdcr_simple_coeff(p, 1);\r\n\t\t\tp->pre_mul[1] = 1.179f;\r\n\t\t\tp->pre_mul[2] = 1.209f;\r\n\t\t\tp->pre_mul[3] = 1.036f;\r\n\t\t\tp->load_raw = &DCR_CLASS dcr_eight_bit_load_raw;\r\n\t\t} else if (!strcmp(p->model,\"40\")) {\r\n\t\t\tstrcpy (p->model, \"DC40\");\r\n\t\t\tp->height = 512;\r\n\t\t\tp->width  = 768;\r\n\t\t\tp->data_offset = 1152;\r\n\t\t\tp->load_raw = &DCR_CLASS dcr_kodak_radc_load_raw;\r\n\t\t} else if (strstr(p->model,\"DC50\")) {\r\n\t\t\tstrcpy (p->model, \"DC50\");\r\n\t\t\tp->height = 512;\r\n\t\t\tp->width  = 768;\r\n\t\t\tp->data_offset = 19712;\r\n\t\t\tp->load_raw = &DCR_CLASS dcr_kodak_radc_load_raw;\r\n\t\t} else if (strstr(p->model,\"DC120\")) {\r\n\t\t\tstrcpy (p->model, \"DC120\");\r\n\t\t\tp->height = 976;\r\n\t\t\tp->width  = 848;\r\n\t\t\tp->pixel_aspect = p->height/0.75/p->width;\r\n\t\t\tp->load_raw = p->tiff_compress == 7 ?\r\n\t\t\t\t&DCR_CLASS dcr_kodak_jpeg_load_raw : &DCR_CLASS dcr_kodak_dc120_load_raw;\r\n\t\t} else if (!strcmp(p->model,\"DCS200\")) {\r\n\t\t\tp->thumb_height = 128;\r\n\t\t\tp->thumb_width  = 192;\r\n\t\t\tp->thumb_offset = 6144;\r\n\t\t\tp->thumb_misc   = 360;\r\n\t\t\tp->write_thumb = &DCR_CLASS dcr_layer_thumb;\r\n\t\t\tp->height = 1024;\r\n\t\t\tp->width  = 1536;\r\n\t\t\tp->data_offset = 79872;\r\n\t\t\tp->load_raw = &DCR_CLASS dcr_eight_bit_load_raw;\r\n\t\t\tp->black = 17;\r\n\t\t}\r\n\t} else if (!strcmp(p->model,\"Fotoman Pixtura\")) {\r\n\t\tp->height = 512;\r\n\t\tp->width  = 768;\r\n\t\tp->data_offset = 3632;\r\n\t\tp->load_raw = &DCR_CLASS dcr_kodak_radc_load_raw;\r\n\t\tp->filters = 0x61616161;\r\n\t\tdcr_simple_coeff(p, 2);\r\n\t} else if (!strcmp(p->model,\"QuickTake 100\")) {\r\n\t\tdcr_fseek(p->obj_, 544, SEEK_SET);\r\n\t\tp->height = dcr_get2(p);\r\n\t\tp->width  = dcr_get2(p);\r\n\t\tp->data_offset = (dcr_get4(p),dcr_get2(p)) == 30 ? 738:736;\r\n\t\tif (p->height > p->width) {\r\n\t\t\tSWAP(p->height,p->width);\r\n\t\t\tdcr_fseek(p->obj_, p->data_offset-6, SEEK_SET);\r\n\t\t\tp->flip = ~dcr_get2(p) & 3 ? 5:6;\r\n\t\t}\r\n\t\tp->load_raw = &DCR_CLASS dcr_quicktake_100_load_raw;\r\n\t\tp->filters = 0x61616161;\r\n\t} else if (!strcmp(p->model,\"QuickTake 150\")) {\r\n\t\tp->data_offset = 738 - head[5];\r\n\t\tif (head[5]) strcpy (p->model+10, \"200\");\r\n\t\tp->load_raw = &DCR_CLASS dcr_kodak_radc_load_raw;\r\n\t\tp->height = 480;\r\n\t\tp->width  = 640;\r\n\t\tp->filters = 0x61616161;\r\n\t} else if (!strcmp(p->make,\"Rollei\") && !p->load_raw) {\r\n\t\tswitch (p->raw_width) {\r\n\t\tcase 1316:\r\n\t\t\tp->height = 1030;\r\n\t\t\tp->width  = 1300;\r\n\t\t\tp->top_margin  = 1;\r\n\t\t\tp->left_margin = 6;\r\n\t\t\tbreak;\r\n\t\tcase 2568:\r\n\t\t\tp->height = 1960;\r\n\t\t\tp->width  = 2560;\r\n\t\t\tp->top_margin  = 2;\r\n\t\t\tp->left_margin = 8;\r\n\t\t}\r\n\t\tp->filters = 0x16161616;\r\n\t\tp->load_raw = &DCR_CLASS dcr_rollei_load_raw;\r\n\t\tp->pre_mul[0] = 1.8f;\r\n\t\tp->pre_mul[2] = 1.3f;\r\n\t} else if (!strcmp(p->model,\"PC-CAM 600\")) {\r\n\t\tp->height = 768;\r\n\t\tp->data_offset = p->width = 1024;\r\n\t\tp->filters = 0x49494949;\r\n\t\tp->load_raw = &DCR_CLASS dcr_eight_bit_load_raw;\r\n\t\tp->pre_mul[0] = 1.14f;\r\n\t\tp->pre_mul[2] = 2.73f;\r\n\t} else if (!strcmp(p->model,\"QV-2000UX\")) {\r\n\t\tp->height = 1208;\r\n\t\tp->width  = 1632;\r\n\t\tp->data_offset = p->width * 2;\r\n\t\tp->load_raw = &DCR_CLASS dcr_eight_bit_load_raw;\r\n\t} else if (fsize == 3217760) {\r\n\t\tp->height = 1546;\r\n\t\tp->width  = 2070;\r\n\t\tp->raw_width = 2080;\r\n\t\tp->load_raw = &DCR_CLASS dcr_eight_bit_load_raw;\r\n\t} else if (!strcmp(p->model,\"QV-4000\")) {\r\n\t\tp->height = 1700;\r\n\t\tp->width  = 2260;\r\n\t\tp->load_raw = &DCR_CLASS dcr_unpacked_load_raw;\r\n\t\tp->maximum = 0xffff;\r\n\t} else if (!strcmp(p->model,\"QV-5700\")) {\r\n\t\tp->height = 1924;\r\n\t\tp->width  = 2576;\r\n\t\tp->load_raw = &DCR_CLASS dcr_casio_qv5700_load_raw;\r\n\t} else if (!strcmp(p->model,\"QV-R41\")) {\r\n\t\tp->height = 1720;\r\n\t\tp->width  = 2312;\r\n\t\tp->raw_width = 3520;\r\n\t\tp->left_margin = 2;\r\n\t} else if (!strcmp(p->model,\"QV-R51\")) {\r\n\t\tp->height = 1926;\r\n\t\tp->width  = 2580;\r\n\t\tp->raw_width = 3904;\r\n\t\tp->pre_mul[0] = 1.340f;\r\n\t\tp->pre_mul[2] = 1.672f;\r\n\t} else if (!strcmp(p->model,\"EX-S100\")) {\r\n\t\tp->height = 1544;\r\n\t\tp->width  = 2058;\r\n\t\tp->raw_width = 3136;\r\n\t\tp->pre_mul[0] = 1.631f;\r\n\t\tp->pre_mul[2] = 1.106f;\r\n\t} else if (!strcmp(p->model,\"EX-Z50\")) {\r\n\t\tp->height = 1931;\r\n\t\tp->width  = 2570;\r\n\t\tp->raw_width = 3904;\r\n\t\tp->pre_mul[0] = 2.529f;\r\n\t\tp->pre_mul[2] = 1.185f;\r\n\t} else if (!strcmp(p->model,\"EX-Z55\")) {\r\n\t\tp->height = 1960;\r\n\t\tp->width  = 2570;\r\n\t\tp->raw_width = 3904;\r\n\t\tp->pre_mul[0] = 1.520f;\r\n\t\tp->pre_mul[2] = 1.316f;\r\n\t} else if (!strcmp(p->model,\"EX-P505\")) {\r\n\t\tp->height = 1928;\r\n\t\tp->width  = 2568;\r\n\t\tp->raw_width = 3852;\r\n\t\tp->maximum = 0xfff;\r\n\t\tp->pre_mul[0] = 2.07f;\r\n\t\tp->pre_mul[2] = 1.88f;\r\n\t} else if (fsize == 9313536) {\t/* EX-P600 or QV-R61 */\r\n\t\tp->height = 2142;\r\n\t\tp->width  = 2844;\r\n\t\tp->raw_width = 4288;\r\n\t\tp->pre_mul[0] = 1.797f;\r\n\t\tp->pre_mul[2] = 1.219f;\r\n\t} else if (!strcmp(p->model,\"EX-P700\")) {\r\n\t\tp->height = 2318;\r\n\t\tp->width  = 3082;\r\n\t\tp->raw_width = 4672;\r\n\t\tp->pre_mul[0] = 1.758f;\r\n\t\tp->pre_mul[2] = 1.504f;\r\n\t}\r\n\tif (!p->model[0])\r\n\t\tsprintf (p->model, \"%dx%d\", p->width, p->height);\r\n\tif (p->filters == UINT_MAX) p->filters = 0x94949494;\r\n\tif (p->raw_color) dcr_adobe_coeff (p, p->make, p->model);\r\n\tif (p->thumb_offset && !p->thumb_height) {\r\n\t\tdcr_fseek(p->obj_, p->thumb_offset, SEEK_SET);\r\n\t\tif (dcr_ljpeg_start (p,&jh, 1)) {\r\n\t\t\tp->thumb_width  = jh.wide;\r\n\t\t\tp->thumb_height = jh.high;\r\n\t\t}\r\n\t}\r\ndng_skip:\r\n\tif (!p->load_raw || p->height < 22) p->is_raw = 0;\r\n#ifdef NO_JPEG\r\n\tif (p->load_raw == &DCR_CLASS dcr_kodak_jpeg_load_raw) {\r\n\t\tfprintf (stderr,_(\"%s: You must link dcraw with libjpeg!!\\n\"), p->ifname);\r\n\t\tp->is_raw = 0;\r\n\t}\r\n#endif\r\n\tif (!p->cdesc[0])\r\n\t\tstrcpy (p->cdesc, p->colors == 3 ? \"RGB\":\"GMCY\");\r\n\tif (!p->raw_height) p->raw_height = p->height;\r\n\tif (!p->raw_width ) p->raw_width  = p->width;\r\n\tif (p->filters && p->colors == 3)\r\n\t\tfor (i=0; i < 32; i+=4) {\r\n\t\t\tif ((p->filters >> i & 15) == 9)\r\n\t\t\t\tp->filters |= 2 << i;\r\n\t\t\tif ((p->filters >> i & 15) == 6)\r\n\t\t\t\tp->filters |= 8 << i;\r\n\t\t}\r\nnotraw:\r\n\t\tif (p->flip == -1) p->flip = p->tiff_flip;\r\n\t\tif (p->flip == -1) p->flip = 0;\r\n}\r\n\r\n#ifndef NO_LCMS\r\nvoid DCR_CLASS dcr_apply_profile (DCRAW* p, char *input, char *output)\r\n{\r\n\tchar *prof;\r\n\tcmsHPROFILE hInProfile=0, hOutProfile=0;\r\n\tcmsHTRANSFORM hTransform;\r\n\tFILE *fp;\r\n\tunsigned size;\r\n\r\n\tcmsErrorAction (LCMS_ERROR_SHOW);\r\n\tif (strcmp (input, \"embed\"))\r\n\t\thInProfile = cmsOpenProfileFromFile (input, \"r\");\r\n\telse if (p->profile_length) {\r\n\t\tprof = (char *) malloc (p->profile_length);\r\n\t\tdcr_merror (p, prof, \"apply_profile()\");\r\n\t\tdcr_fseek(p->obj_, p->profile_offset, SEEK_SET);\r\n\t\tdcr_fread(p->obj_, prof, 1, p->profile_length);\r\n\t\thInProfile = cmsOpenProfileFromMem (prof, p->profile_length);\r\n\t\tfree (prof);\r\n\t} else\r\n\t\tfprintf (stderr,_(\"%s has no embedded profile.\\n\"), p->ifname);\r\n\tif (!hInProfile) return;\r\n\tif (!output)\r\n\t\thOutProfile = cmsCreate_sRGBProfile();\r\n\telse if ((fp = fopen (output, \"rb\"))) {\r\n\t\tdcr_fread(p->obj_, &size, 4, 1);\r\n\t\tfseek (fp, 0, SEEK_SET);\r\n\t\tp->oprof = (unsigned *) malloc (size = ntohl(size));\r\n\t\tdcr_merror (p, p->oprof, \"apply_profile()\");\r\n\t\tdcr_fread(p->obj_, p->oprof, 1, size);\r\n\t\tfclose (fp);\r\n\t\tif (!(hOutProfile = cmsOpenProfileFromMem (p->oprof, size))) {\r\n\t\t\tfree (p->oprof);\r\n\t\t\tp->oprof = 0;\r\n\t\t}\r\n\t} else\r\n\t\tfprintf (stderr,_(\"Cannot open file %s!\\n\"), output);\r\n\tif (!hOutProfile) goto quit;\r\n\tif (p->opt.verbose)\r\n\t\tfprintf (stderr,_(\"Applying color profile...\\n\"));\r\n\thTransform = cmsCreateTransform (hInProfile, TYPE_RGBA_16,\r\n\t\thOutProfile, TYPE_RGBA_16, INTENT_PERCEPTUAL, 0);\r\n\tcmsDoTransform (hTransform, p->image, p->image, p->width*p->height);\r\n\tp->raw_color = 1;\t\t/* Don't use rgb_cam with a profile */\r\n\tcmsDeleteTransform (hTransform);\r\n\tcmsCloseProfile (hOutProfile);\r\nquit:\r\n\tcmsCloseProfile (hInProfile);\r\n}\r\n#endif\r\n\r\nvoid DCR_CLASS dcr_convert_to_rgb(DCRAW* p)\r\n{\r\n\tint row, col, c, i, j, k;\r\n\tushort *img;\r\n\tfloat out[3], out_cam[3][4];\r\n\tdouble num, inverse[3][3], bnd[2]={0,0};\r\n\tstatic const double xyzd50_srgb[3][3] =\r\n\t{ { 0.436083, 0.385083, 0.143055 },\r\n    { 0.222507, 0.716888, 0.060608 },\r\n    { 0.013930, 0.097097, 0.714022 } };\r\n\tstatic const double rgb_rgb[3][3] =\r\n\t{ { 1,0,0 }, { 0,1,0 }, { 0,0,1 } };\r\n\tstatic const double adobe_rgb[3][3] =\r\n\t{ { 0.715146, 0.284856, 0.000000 },\r\n    { 0.000000, 1.000000, 0.000000 },\r\n    { 0.000000, 0.041166, 0.958839 } };\r\n\tstatic const double wide_rgb[3][3] =\r\n\t{ { 0.593087, 0.404710, 0.002206 },\r\n    { 0.095413, 0.843149, 0.061439 },\r\n    { 0.011621, 0.069091, 0.919288 } };\r\n\tstatic const double prophoto_rgb[3][3] =\r\n\t{ { 0.529317, 0.330092, 0.140588 },\r\n    { 0.098368, 0.873465, 0.028169 },\r\n    { 0.016879, 0.117663, 0.865457 } };\r\n\r\n\tstatic const double (*out_rgb[])[3] =\r\n\t{ rgb_rgb, adobe_rgb, wide_rgb, prophoto_rgb, xyz_rgb };\r\n\tstatic const char *name[] =\r\n\t{ \"sRGB\", \"Adobe RGB (1998)\", \"WideGamut D65\", \"ProPhoto D65\", \"XYZ\" };\r\n\tstatic const unsigned phead[] =\r\n\t{ 1024, 0, 0x2100000, 0x6d6e7472, 0x52474220, 0x58595a20, 0, 0, 0,\r\n    0x61637370, 0, 0, 0x6e6f6e65, 0, 0, 0, 0, 0xf6d6, 0x10000, 0xd32d };\r\n\tunsigned pbody[] =\r\n\t{ 10, 0x63707274, 0, 36,\t/* cprt */\r\n\t0x64657363, 0, 40,\t/* desc */\r\n\t0x77747074, 0, 20,\t/* wtpt */\r\n\t0x626b7074, 0, 20,\t/* bkpt */\r\n\t0x72545243, 0, 14,\t/* rTRC */\r\n\t0x67545243, 0, 14,\t/* gTRC */\r\n\t0x62545243, 0, 14,\t/* bTRC */\r\n\t0x7258595a, 0, 20,\t/* rXYZ */\r\n\t0x6758595a, 0, 20,\t/* gXYZ */\r\n\t0x6258595a, 0, 20 };\t/* bXYZ */\r\n\tstatic const unsigned pwhite[] = { 0xf351, 0x10000, 0x116cc };\r\n\tunsigned pcurve[] = { 0x63757276, 0, 1, 0x1000000 };\r\n\r\n\tbnd[p->opt.gamm[1] >= 1] = 1;\r\n\tif (p->opt.gamm[1] && (p->opt.gamm[1]-1)*(p->opt.gamm[0]-1) <= 0) {\r\n\t\tfor (i=0; i < 36; i++) {\r\n\t\t\tp->opt.gamm[2] = (bnd[0] + bnd[1])/2;\r\n\t\t\tbnd[(pow(p->opt.gamm[2]/p->opt.gamm[1],-p->opt.gamm[0])-1)/p->opt.gamm[0]-1/p->opt.gamm[2] > -1] = p->opt.gamm[2];\r\n\t\t}\r\n\t\tp->opt.gamm[3] = p->opt.gamm[2]*(1/p->opt.gamm[0]-1);\r\n\t\tp->opt.gamm[2] /= p->opt.gamm[1];\r\n\t}\r\n\tp->opt.gamm[4] = 1 / (p->opt.gamm[1]/2*SQR(p->opt.gamm[2]) - p->opt.gamm[3]*(1-p->opt.gamm[2]) +\r\n\t\t(1-pow(p->opt.gamm[2],1+p->opt.gamm[0]))*(1+p->opt.gamm[3])/(1+p->opt.gamm[0])) - 1;\r\n\r\n\tmemcpy (out_cam, p->rgb_cam, sizeof out_cam);\r\n\tp->raw_color |= p->colors == 1 || p->opt.document_mode ||\r\n\t\tp->opt.output_color < 1 || p->opt.output_color > 5;\r\n\tif (!p->raw_color) {\r\n\t\tp->oprof = (unsigned *) calloc (phead[0], 1);\r\n\t\tdcr_merror (p, p->oprof, \"convert_to_rgb()\");\r\n\t\tmemcpy (p->oprof, phead, sizeof phead);\r\n\t\tif (p->opt.output_color == 5) p->oprof[4] = p->oprof[5];\r\n\t\tp->oprof[0] = 132 + 12*pbody[0];\r\n\t\tfor (i=0; i < (int)pbody[0]; i++) {\r\n\t\t\tp->oprof[p->oprof[0]/4] = i ? (i > 1 ? 0x58595a20 : 0x64657363) : 0x74657874;\r\n\t\t\tpbody[i*3+2] = p->oprof[0];\r\n\t\t\tp->oprof[0] += (pbody[i*3+3] + 3) & -4;\r\n\t\t}\r\n\t\tmemcpy (p->oprof+32, pbody, sizeof pbody);\r\n\t\tp->oprof[pbody[5]/4+2] = strlen(name[p->opt.output_color-1]) + 1;\r\n\t\tmemcpy ((char *)p->oprof+pbody[8]+8, pwhite, sizeof pwhite);\r\n\t\tif (p->opt.output_bps == 8)\r\n\t\t\tpcurve[3] = (short)(256/p->opt.gamm[4]+0.5) << 16;\r\n\t\tfor (i=4; i < 7; i++)\r\n\t\t\tmemcpy ((char *)p->oprof+pbody[i*3+2], pcurve, sizeof pcurve);\r\n\t\tdcr_pseudoinverse ((double (*)[3]) out_rgb[p->opt.output_color-1], inverse, 3);\r\n\t\tfor (i=0; i < 3; i++)\r\n\t\t\tfor (j=0; j < 3; j++) {\r\n\t\t\t\tfor (num = k=0; k < 3; k++)\r\n\t\t\t\t\tnum += xyzd50_srgb[i][k] * inverse[j][k];\r\n\t\t\t\tp->oprof[pbody[j*3+23]/4+i+2] = (unsigned int)(num * 0x10000 + 0.5);\r\n\t\t\t}\r\n\t\t\tfor (i=0; i < (int)(phead[0]/4); i++)\r\n\t\t\t\tp->oprof[i] = htonl(p->oprof[i]);\r\n\t\t\tstrcpy ((char *)p->oprof+pbody[2]+8, \"auto-generated by dcraw\");\r\n\t\t\tstrcpy ((char *)p->oprof+pbody[5]+12, name[p->opt.output_color-1]);\r\n\t\t\tfor (i=0; i < 3; i++)\r\n\t\t\t\tfor (j=0; j < p->colors; j++)\r\n                    for (out_cam[i][j] = 0, k=0; k < 3; k++)\r\n\t\t\t\t\t\tout_cam[i][j] += (float)out_rgb[p->opt.output_color-1][i][k] * p->rgb_cam[k][j];\r\n\t}\r\n\tif (p->opt.verbose)\r\n\t\tfprintf (stderr, p->raw_color ? _(\"Building histograms...\\n\") :\r\n\t_(\"Converting to %s colorspace...\\n\"), name[p->opt.output_color-1]);\r\n\r\n\tmemset (p->histogram, 0, sizeof p->histogram);\r\n\tfor (img=p->image[0], row=0; row < p->height; row++)\r\n\t\tfor (col=0; col < p->width; col++, img+=4) {\r\n\t\t\tif (!p->raw_color) {\r\n\t\t\t\tout[0] = out[1] = out[2] = 0;\r\n\t\t\t\tFORCC(p) {\r\n\t\t\t\t\tout[0] += out_cam[0][c] * img[c];\r\n\t\t\t\t\tout[1] += out_cam[1][c] * img[c];\r\n\t\t\t\t\tout[2] += out_cam[2][c] * img[c];\r\n\t\t\t\t}\r\n\t\t\t\tFORC3 img[c] = CLIP((int) out[c]);\r\n\t\t\t}\r\n\t\t\telse if (p->opt.document_mode)\r\n\t\t\t\timg[0] = img[FC(row,col)];\r\n\t\t\tFORCC(p) p->histogram[c][img[c] >> 3]++;\r\n\t\t}\r\n\tif (p->colors == 4 && p->opt.output_color) p->colors = 3;\r\n\tif (p->opt.document_mode && p->filters) p->colors = 1;\r\n}\r\n\r\nvoid DCR_CLASS dcr_fuji_rotate(DCRAW* p)\r\n{\r\n\tint i, row, col;\r\n\tdouble step;\r\n\tfloat r, c, fr, fc;\r\n\tunsigned ur, uc;\r\n\tushort wide, high, (*img)[4], (*pix)[4];\r\n\r\n\tif (!p->fuji_width) return;\r\n\tif (p->opt.verbose)\r\n\t\tfprintf (stderr,_(\"Rotating image 45 degrees...\\n\"));\r\n\tp->fuji_width = (p->fuji_width - 1 + p->shrink) >> p->shrink;\r\n\tstep = sqrt(0.5);\r\n\twide = (unsigned short)(p->fuji_width / step);\r\n\thigh = (unsigned short)((p->height - p->fuji_width) / step);\r\n\timg = (ushort (*)[4]) calloc (wide*high, sizeof *img);\r\n\tdcr_merror (p, img, \"fuji_rotate()\");\r\n\r\n\tfor (row=0; row < high; row++)\r\n\t\tfor (col=0; col < wide; col++) {\r\n\t\t\tr = (float)(p->fuji_width + (row-col)*step);\r\n\t\t\tur = (unsigned int)r;\r\n\t\t\tc = (float)((row+col)*step);\r\n\t\t\tuc = (unsigned int)c;\r\n\t\t\tif ((int)ur > (int)(p->height-2) || (int)uc > (int)(p->width-2)) continue;\r\n\t\t\tfr = r - ur;\r\n\t\t\tfc = c - uc;\r\n\t\t\tpix = p->image + ur*p->width + uc;\r\n\t\t\tfor (i=0; i < p->colors; i++)\r\n\t\t\t\timg[row*wide+col][i] = (unsigned short)(\r\n\t\t\t\t(pix[    0][i]*(1-fc) + pix[      1][i]*fc) * (1-fr) +\r\n\t\t\t\t(pix[p->width][i]*(1-fc) + pix[p->width+1][i]*fc) * fr);\r\n\t\t}\r\n\tfree (p->image);\r\n\tp->width  = wide;\r\n\tp->height = high;\r\n\tp->image  = img;\r\n\tp->fuji_width = 0;\r\n}\r\n\r\nvoid DCR_CLASS dcr_stretch(DCRAW* p)\r\n{\r\n\tushort newdim, (*img)[4], *pix0, *pix1;\r\n\tint row, col, c;\r\n\tdouble rc, frac;\r\n\r\n\tif (p->pixel_aspect == 1) return;\r\n\tif (p->opt.verbose) fprintf (stderr,_(\"Stretching the image...\\n\"));\r\n\tif (p->pixel_aspect < 1) {\r\n\t\tnewdim = (unsigned short)(p->height / p->pixel_aspect + 0.5);\r\n\t\timg = (ushort (*)[4]) calloc (p->width*newdim, sizeof *img);\r\n\t\tdcr_merror (p, img, \"stretch()\");\r\n\t\tfor (rc=row=0; row < newdim; row++, rc+=p->pixel_aspect) {\r\n\t\t\tfrac = rc - (c = (int)rc);\r\n\t\t\tpix0 = pix1 = p->image[c*p->width];\r\n\t\t\tif (c+1 < p->height) pix1 += p->width*4;\r\n\t\t\tfor (col=0; col < p->width; col++, pix0+=4, pix1+=4)\r\n\t\t\t\tFORCC(p) img[row*p->width+col][c] = (unsigned short)(pix0[c]*(1-frac) + pix1[c]*frac + 0.5);\r\n\t\t}\r\n\t\tp->height = newdim;\r\n\t} else {\r\n\t\tnewdim = (unsigned short)(p->width * p->pixel_aspect + 0.5);\r\n\t\timg = (ushort (*)[4]) calloc (p->height*newdim, sizeof *img);\r\n\t\tdcr_merror (p, img, \"stretch()\");\r\n\t\tfor (rc=col=0; col < newdim; col++, rc+=1/p->pixel_aspect) {\r\n\t\t\tfrac = rc - (c = (int)rc);\r\n\t\t\tpix0 = pix1 = p->image[c];\r\n\t\t\tif (c+1 < p->width) pix1 += 4;\r\n\t\t\tfor (row=0; row < p->height; row++, pix0+=p->width*4, pix1+=p->width*4)\r\n\t\t\t\tFORCC(p) img[row*newdim+col][c] = (unsigned short)(pix0[c]*(1-frac) + pix1[c]*frac + 0.5);\r\n\t\t}\r\n\t\tp->width = newdim;\r\n\t}\r\n\tfree (p->image);\r\n\tp->image = img;\r\n}\r\n\r\nint DCR_CLASS dcr_flip_index (DCRAW* p, int row, int col)\r\n{\r\n\tif (p->flip & 4) SWAP(row,col);\r\n\tif (p->flip & 2) row = p->iheight - 1 - row;\r\n\tif (p->flip & 1) col = p->iwidth  - 1 - col;\r\n\treturn row * p->iwidth + col;\r\n}\r\n\r\nvoid DCR_CLASS dcr_gamma_lut (DCRAW* p, uchar lut[0x10000])\r\n{\r\n\tint perc, c, val, total, i;\r\n\tfloat white=0, r;\r\n\r\n\tperc = (int)(p->width * p->height * 0.01);\t\t/* 99th percentile white level */\r\n\tif (p->fuji_width) perc /= 2;\r\n\tif ((p->opt.highlight & ~2) || p->opt.no_auto_bright) perc = -1;\r\n\tFORCC(p) {\r\n\t\tfor (val=0x2000, total=0; --val > 32; )\r\n\t\t\tif ((total += p->histogram[c][val]) > perc) break;\r\n\t\t\tif (white < val) white = (float)val;\r\n\t}\r\n\twhite *= 8 / p->opt.bright;\r\n\tfor (i=0; i < 0x10000; i++) {\r\n\t\tr = i / white;\r\n\t\tval = (int)(256 * ( !p->use_gamma ? r :\r\n\t\tr <= p->opt.gamm[2] ? r*p->opt.gamm[1] : pow(r,p->opt.gamm[0])*(1+p->opt.gamm[3])-p->opt.gamm[3]));\r\n\t\tif (val > 255) val = 255;\r\n\t\tlut[i] = val;\r\n\t}\r\n}\r\n\r\nvoid DCR_CLASS dcr_tiff_set (ushort *ntag,\r\n\t\t\t\t\t\t\t ushort tag, ushort type, int count, int val)\r\n{\r\n\tstruct dcr_tiff_tag *tt;\r\n\tint c;\r\n\r\n\ttt = (struct dcr_tiff_tag *)(ntag+1) + (*ntag)++;\r\n\ttt->tag = tag;\r\n\ttt->type = type;\r\n\ttt->count = count;\r\n\tif (type < 3 && count <= 4)\r\n\t\tFORC(4) tt->val.c[c] = val >> (c << 3);\r\n\telse if (type == 3 && count <= 2)\r\n\t\tFORC(2) tt->val.s[c] = val >> (c << 4);\r\n\telse tt->val.i = val;\r\n}\r\n\r\n#define TOFF(ptr) ((char *)(&(ptr)) - (char *)th)\r\n\r\nvoid DCR_CLASS dcr_tiff_head (DCRAW* p, struct dcr_tiff_hdr *th, int full)\r\n{\r\n\tint c, psize=0;\r\n\tstruct tm *t;\r\n\r\n\tmemset (th, 0, sizeof *th);\r\n\tth->order = (unsigned short)(htonl(0x4d4d4949) >> 16);\r\n\tth->magic = 42;\r\n\tth->ifd = 10;\r\n\tif (full) {\r\n\t\tdcr_tiff_set (&th->ntag, 254, 4, 1, 0);\r\n\t\tdcr_tiff_set (&th->ntag, 256, 4, 1, p->width);\r\n\t\tdcr_tiff_set (&th->ntag, 257, 4, 1, p->height);\r\n\t\tdcr_tiff_set (&th->ntag, 258, 3, p->colors, p->opt.output_bps);\r\n\t\tif (p->colors > 2)\r\n\t\t\tth->tag[th->ntag-1].val.i = TOFF(th->bps);\r\n\t\tFORC4 th->bps[c] = p->opt.output_bps;\r\n\t\tdcr_tiff_set (&th->ntag, 259, 3, 1, 1);\r\n\t\tdcr_tiff_set (&th->ntag, 262, 3, 1, 1 + (p->colors > 1));\r\n\t}\r\n\tdcr_tiff_set (&th->ntag, 270, 2, 512, TOFF(th->desc));\r\n\tdcr_tiff_set (&th->ntag, 271, 2, 64, TOFF(th->make));\r\n\tdcr_tiff_set (&th->ntag, 272, 2, 64, TOFF(th->model));\r\n\tif (full) {\r\n\t\tif (p->oprof) psize = ntohl(p->oprof[0]);\r\n\t\tdcr_tiff_set (&th->ntag, 273, 4, 1, sizeof *th + psize);\r\n\t\tdcr_tiff_set (&th->ntag, 277, 3, 1, p->colors);\r\n\t\tdcr_tiff_set (&th->ntag, 278, 4, 1, p->height);\r\n\t\tdcr_tiff_set (&th->ntag, 279, 4, 1, p->height*p->width*p->colors*p->opt.output_bps/8);\r\n\t} else\r\n\t\tdcr_tiff_set (&th->ntag, 274, 3, 1, \"12435867\"[p->flip]-'0');\r\n\tdcr_tiff_set (&th->ntag, 282, 5, 1, TOFF(th->rat[0]));\r\n\tdcr_tiff_set (&th->ntag, 283, 5, 1, TOFF(th->rat[2]));\r\n\tdcr_tiff_set (&th->ntag, 284, 3, 1, 1);\r\n\tdcr_tiff_set (&th->ntag, 296, 3, 1, 2);\r\n\tdcr_tiff_set (&th->ntag, 305, 2, 32, TOFF(th->soft));\r\n\tdcr_tiff_set (&th->ntag, 306, 2, 20, TOFF(th->date));\r\n\tdcr_tiff_set (&th->ntag, 315, 2, 64, TOFF(th->artist));\r\n\tdcr_tiff_set (&th->ntag, 34665, 4, 1, TOFF(th->nexif));\r\n\tif (psize) dcr_tiff_set (&th->ntag, 34675, 7, psize, sizeof *th);\r\n\tdcr_tiff_set (&th->nexif, 33434, 5, 1, TOFF(th->rat[4]));\r\n\tdcr_tiff_set (&th->nexif, 33437, 5, 1, TOFF(th->rat[6]));\r\n\tdcr_tiff_set (&th->nexif, 34855, 3, 1, (int)p->iso_speed);\r\n\tdcr_tiff_set (&th->nexif, 37386, 5, 1, TOFF(th->rat[8]));\r\n\tif (p->gpsdata[1]) {\r\n\t\tdcr_tiff_set (&th->ntag, 34853, 4, 1, TOFF(th->ngps));\r\n\t\tdcr_tiff_set (&th->ngps,  0, 1,  4, 0x202);\r\n\t\tdcr_tiff_set (&th->ngps,  1, 2,  2, p->gpsdata[29]);\r\n\t\tdcr_tiff_set (&th->ngps,  2, 5,  3, TOFF(th->gps[0]));\r\n\t\tdcr_tiff_set (&th->ngps,  3, 2,  2, p->gpsdata[30]);\r\n\t\tdcr_tiff_set (&th->ngps,  4, 5,  3, TOFF(th->gps[6]));\r\n\t\tdcr_tiff_set (&th->ngps,  5, 1,  1, p->gpsdata[31]);\r\n\t\tdcr_tiff_set (&th->ngps,  6, 5,  1, TOFF(th->gps[18]));\r\n\t\tdcr_tiff_set (&th->ngps,  7, 5,  3, TOFF(th->gps[12]));\r\n\t\tdcr_tiff_set (&th->ngps, 18, 2, 12, TOFF(th->gps[20]));\r\n\t\tdcr_tiff_set (&th->ngps, 29, 2, 12, TOFF(th->gps[23]));\r\n\t\tmemcpy (th->gps, p->gpsdata, sizeof th->gps);\r\n\t}\r\n\tth->rat[0] = th->rat[2] = 300;\r\n\tth->rat[1] = th->rat[3] = 1;\r\n\tFORC(6) th->rat[4+c] = 1000000;\r\n\tth->rat[4] = (int)(th->rat[4] * p->shutter);\r\n\tth->rat[6] = (int)(th->rat[6] * p->aperture);\r\n\tth->rat[8] = (int)(th->rat[8] * p->focal_len);\r\n\tstrncpy (th->desc, p->desc, 512);\r\n\tstrncpy (th->make, p->make, 64);\r\n\tstrncpy (th->model, p->model, 64);\r\n\tstrcpy (th->soft, \"dcraw v\"DCR_VERSION);\r\n\tt = gmtime (&p->timestamp);\r\n\tsprintf (th->date, \"%04d:%02d:%02d %02d:%02d:%02d\",\r\n\t\tt->tm_year+1900,t->tm_mon+1,t->tm_mday,t->tm_hour,t->tm_min,t->tm_sec);\r\n\tstrncpy (th->artist, p->artist, 64);\r\n}\r\n\r\nvoid DCR_CLASS dcr_jpeg_thumb (DCRAW* p, FILE *tfp)\r\n{\r\n\tchar *thumb;\r\n\tushort exif[5];\r\n\tstruct dcr_tiff_hdr th;\r\n\r\n\tthumb = (char *) malloc (p->thumb_length);\r\n\tdcr_merror (p, thumb, \"jpeg_thumb()\");\r\n\tdcr_fread(p->obj_, thumb, 1, p->thumb_length);\r\n\tfputc (0xff, tfp);\r\n\tfputc (0xd8, tfp);\r\n\tif (strcmp (thumb+6, \"Exif\")) {\r\n\t\tmemcpy (exif, \"\\xff\\xe1  Exif\\0\\0\", 10);\r\n\t\texif[1] = htons (8 + sizeof th);\r\n\t\tfwrite (exif, 1, sizeof exif, tfp);\r\n\t\tdcr_tiff_head (p,&th, 0);\r\n\t\tfwrite (&th, 1, sizeof th, tfp);\r\n\t}\r\n\tfwrite (thumb+2, 1, p->thumb_length-2, tfp);\r\n\tfree (thumb);\r\n}\r\n\r\nvoid DCR_CLASS dcr_write_ppm_tiff (DCRAW* p, FILE *ofp)\r\n{\r\n\tstruct dcr_tiff_hdr th;\r\n\tuchar *ppm, lut[0x10000];\r\n\tushort *ppm2;\r\n\tint c, row, col, soff, rstep, cstep;\r\n\r\n\tp->iheight = p->height;\r\n\tp->iwidth  = p->width;\r\n\tif (p->flip & 4) SWAP(p->height,p->width);\r\n\tppm = (uchar *) calloc (p->width, p->colors*p->opt.output_bps/8);\r\n\tppm2 = (ushort *) ppm;\r\n\tdcr_merror (p, ppm, \"write_ppm_tiff()\");\r\n\tif (p->opt.output_tiff) {\r\n\t\tdcr_tiff_head (p, &th, 1);\r\n\t\tfwrite (&th, sizeof th, 1, ofp);\r\n\t\tif (p->oprof)\r\n\t\t\tfwrite (p->oprof, ntohl(p->oprof[0]), 1, ofp);\r\n\t} else if (p->colors > 3)\r\n\t\tfprintf (ofp,\r\n\t\t\"P7\\nWIDTH %d\\nHEIGHT %d\\nDEPTH %d\\nMAXVAL %d\\nTUPLTYPE %s\\nENDHDR\\n\",\r\n\t\tp->width, p->height, p->colors, (1 << p->opt.output_bps)-1, p->cdesc);\r\n\telse\r\n\t\tfprintf (ofp, \"P%d\\n%d %d\\n%d\\n\",\r\n\t\tp->colors/2+5, p->width, p->height, (1 << p->opt.output_bps)-1);\r\n\r\n\tif (p->opt.output_bps == 8) dcr_gamma_lut (p, lut);\r\n\tsoff  = dcr_flip_index (p, 0, 0);\r\n\tcstep = dcr_flip_index (p, 0, 1) - soff;\r\n\trstep = dcr_flip_index (p, 1, 0) - dcr_flip_index (p, 0, p->width);\r\n\tfor (row=0; row < p->height; row++, soff += rstep) {\r\n\t\tfor (col=0; col < p->width; col++, soff += cstep){\r\n\t\t\tif (p->opt.output_bps == 8)\r\n\t\t\t\tFORCC(p) ppm [col*p->colors+c] = lut[p->image[soff][c]];\r\n\t\t\telse\r\n\t\t\t\tFORCC(p) ppm2[col*p->colors+c] =     p->image[soff][c];\r\n\t\t}\r\n\t\tif (p->opt.output_bps == 16 && !p->opt.output_tiff && htons(0x55aa) != 0x55aa)\r\n\t\t\t_swab ((char*)ppm2, (char*)ppm2, p->width*p->colors*2);\r\n\t\tfwrite (ppm, p->colors*p->opt.output_bps/8, p->width, ofp);\r\n\t}\r\n\tfree (ppm);\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////////\r\n\r\n\r\n\r\n\r\nstatic int dcr_sfile_read(dcr_stream_obj *obj, void *buf, int size, int cnt)\r\n{\r\n\treturn fread(buf, size, cnt, (FILE *)obj);\r\n}\r\n\r\nstatic int dcr_sfile_write(dcr_stream_obj *obj, void *buf, int size, int cnt)\r\n{\r\n\treturn fwrite(buf, size, cnt, (FILE *)obj);\r\n}\r\n\r\nstatic long dcr_sfile_seek(dcr_stream_obj *obj, long offset, int origin)\r\n{\r\n\treturn fseek((FILE *)obj, offset, origin);\r\n}\r\n\r\nstatic int dcr_sfile_close(dcr_stream_obj *obj)\r\n{\r\n\treturn fclose((FILE *)obj);\r\n}\r\n\r\nstatic char* dcr_sfile_gets(dcr_stream_obj *obj, char *string, int n)\r\n{\r\n\treturn fgets(string,n,(FILE *)obj);\r\n}\r\n\r\nstatic int   dcr_sfile_eof(dcr_stream_obj *obj)\r\n{\r\n\treturn feof((FILE *)obj);\r\n}\r\n\r\nstatic long  dcr_sfile_tell(dcr_stream_obj *obj)\r\n{\r\n\treturn ftell((FILE *)obj);\r\n}\r\n\r\nstatic int   dcr_sfile_getc(dcr_stream_obj *obj)\r\n{\r\n\treturn fgetc((FILE *)obj);\r\n}\r\n\r\nstatic int   dcr_sfile_scanf(dcr_stream_obj *obj,const char *format, void* output)\r\n{\r\n\treturn fscanf((FILE *)obj, format, output);\r\n}\r\n\r\n\r\n///////////////////////////////////////////////////////////////////////////////\r\n\r\n\r\nvoid DCR_CLASS dcr_init_dcraw(DCRAW* p)\r\n{\r\n\tmemset(p,0,sizeof(DCRAW));\r\n\r\n\tp->ops_ = &dcr_stream_fileops;\r\n\r\n\tp->opt.dark_frame = NULL;\r\n\tp->opt.bpfile     = NULL;\r\n\tp->opt.user_flip  = -1;\r\n\tp->opt.user_black = -1;\r\n\tp->opt.user_qual  = -1;\r\n\tp->opt.user_sat   = -1;\r\n\tp->opt.timestamp_only = 0;\r\n\tp->opt.thumbnail_only = 0;\r\n\tp->opt.identify_only  = 0;\r\n\tp->opt.use_fuji_rotate = 1;\r\n\tp->opt.write_to_stdout = 0;\r\n\tp->opt.bright = 1;\r\n\tp->opt.aber[0] = p->opt.aber[1] = p->opt.aber[2] = p->opt.aber[3] = 1;\r\n\tp->opt.gamm[0] = 0.45;\r\n\tp->opt.gamm[1] = 4.5;\r\n\tp->opt.gamm[2] = p->opt.gamm[3] = p->opt.gamm[4] = 0;\r\n\tp->opt.output_color = 1;\r\n\tp->opt.output_bps =8;\r\n\tp->opt.greybox[0] = p->opt.greybox[1] = 0;\r\n\tp->opt.greybox[2] = p->opt.greybox[3] = UINT_MAX;\r\n\tp->opt.use_camera_matrix = -1;\r\n\r\n}\r\n\r\nvoid\tDCR_CLASS dcr_cleanup_dcraw(DCRAW* p)\r\n{\r\n\tif (p->meta_data) free (p->meta_data);\r\n\tif (p->oprof) free (p->oprof);\r\n\tif (p->image) free (p->image);\r\n}\r\n\r\nvoid DCR_CLASS dcr_print_manual(int argc, char **argv)\r\n{\r\n\tprintf(_(\"\\nRaw photo decoder \\\"dcraw\\\" v%s\"), DCR_VERSION);\r\n    printf(_(\"\\nby Dave Coffin, dcoffin a cybercom o net\\n\"));\r\n    printf(_(\"\\nUsage:  %s [OPTION]... [FILE]...\\n\\n\"), argv[0]);\r\n    puts(_(\"-v        Print verbose messages\"));\r\n    puts(_(\"-c        Write image data to standard output\"));\r\n    puts(_(\"-e        Extract embedded thumbnail image\"));\r\n    puts(_(\"-i        Identify files without decoding them\"));\r\n    puts(_(\"-i -v     Identify files and show metadata\"));\r\n    puts(_(\"-z        Change file dates to camera timestamp\"));\r\n    puts(_(\"-w        Use camera white balance, if possible\"));\r\n    puts(_(\"-a        Average the whole image for white balance\"));\r\n    puts(_(\"-A <x y w h> Average a grey box for white balance\"));\r\n    puts(_(\"-r <r g b g> Set custom white balance\"));\r\n    puts(_(\"+M/-M     Use/don't use an embedded color matrix\"));\r\n    puts(_(\"-C <r b>  Correct chromatic aberration\"));\r\n    puts(_(\"-P <file> Fix the dead pixels listed in this file\"));\r\n    puts(_(\"-K <file> Subtract dark frame (16-bit raw PGM)\"));\r\n    puts(_(\"-k <num>  Set the darkness level\"));\r\n    puts(_(\"-S <num>  Set the saturation level\"));\r\n    puts(_(\"-n <num>  Set threshold for wavelet denoising\"));\r\n    puts(_(\"-H [0-9]  Highlight mode (0=clip, 1=unclip, 2=blend, 3+=rebuild)\"));\r\n    puts(_(\"-t [0-7]  Flip image (0=none, 3=180, 5=90CCW, 6=90CW)\"));\r\n    puts(_(\"-o [0-5]  Output colorspace (raw,sRGB,Adobe,Wide,ProPhoto,XYZ)\"));\r\n#ifndef NO_LCMS\r\n    puts(_(\"-o <file> Apply output ICC profile from file\"));\r\n    puts(_(\"-p <file> Apply camera ICC profile from file or \\\"embed\\\"\"));\r\n#endif\r\n    puts(_(\"-d        Document mode (no color, no interpolation)\"));\r\n    puts(_(\"-D        Document mode without scaling (totally raw)\"));\r\n    puts(_(\"-j        Don't stretch or rotate raw pixels\"));\r\n    puts(_(\"-W        Don't automatically brighten the image\"));\r\n    puts(_(\"-b <num>  Adjust brightness (default = 1.0)\"));\r\n\tputs(_(\"-g <p ts> Set custom gamma curve (default = 2.222 4.5)\"));\r\n    puts(_(\"-q [0-3]  Set the interpolation quality\"));\r\n    puts(_(\"-h        Half-size color image (twice as fast as \\\"-q 0\\\")\"));\r\n    puts(_(\"-f        Interpolate RGGB as four colors\"));\r\n    puts(_(\"-m <num>  Apply a 3x3 median filter to R-G and B-G\"));\r\n    puts(_(\"-s [0..N-1] Select one raw image or \\\"all\\\" from each file\"));\r\n    puts(_(\"-4        Write 16-bit linear instead of 8-bit with gamma\"));\r\n    puts(_(\"-T        Write TIFF instead of PPM\"));\r\n    puts(\"\");\r\n}\r\n\r\nint DCR_CLASS dcr_parse_command_line_options(DCRAW* p, int argc, char **argv, int *arg)\r\n{\r\n\tchar opm, opt, *sp, *cp;\r\n\tint i, c;\r\n\r\n\tif (argv && arg) {\r\n\t\targv[argc] = \"\";\r\n\t\tfor (*arg=1; (((opm = argv[*arg][0]) - 2) | 2) == '+'; ) {\r\n\r\n\t\t\topt = argv[(*arg)++][1];\r\n\t\t\tif ((cp = strchr (sp=\"nbrkStqmHACg\", opt)))\r\n\t\t\t\tfor (i=0;    i < \"114111111422\"[cp-sp]-'0'; i++)\r\n\t\t\t\t\tif (!isdigit(argv[(*arg)+i][0])) {\r\n\t\t\t\t\t\tfprintf (stderr,_(\"Non-numeric argument to \\\"-%c\\\"\\n\"), opt);\r\n\t\t\t\t\t\treturn 1;\r\n\t\t\t\t\t}\r\n\r\n\t\t\tswitch (opt) {\r\n\t\t\tcase 'n':  p->opt.threshold   = (float)atof(argv[(*arg)++]);  break;\r\n\t\t\tcase 'b':  p->opt.bright      = (float)atof(argv[(*arg)++]);  break;\r\n\t\t\tcase 'r':  FORC4 p->opt.user_mul[c] = (float)atof(argv[(*arg)++]);  break;\r\n\t\t\tcase 'C':  p->opt.aber[0]     = 1 / atof(argv[(*arg)++]);\r\n\t\t\t\t\t   p->opt.aber[2]     = 1 / atof(argv[(*arg)++]);  break;\r\n\t\t\tcase 'g':  p->opt.gamm[0]     = 1 / atof(argv[(*arg)++]);\r\n\t\t\t\t\t   p->opt.gamm[1]     =     atof(argv[(*arg)++]);  break;\r\n\t\t\tcase 'k':  p->opt.user_black  = atoi(argv[(*arg)++]);  break;\r\n\t\t\tcase 'S':  p->opt.user_sat    = atoi(argv[(*arg)++]);  break;\r\n\t\t\tcase 't':  p->opt.user_flip   = atoi(argv[(*arg)++]);  break;\r\n\t\t\tcase 'q':  p->opt.user_qual   = atoi(argv[(*arg)++]);  break;\r\n\t\t\tcase 'm':  p->opt.med_passes  = atoi(argv[(*arg)++]);  break;\r\n\t\t\tcase 'H':  p->opt.highlight   = atoi(argv[(*arg)++]);  break;\r\n\t\t\tcase 's':\r\n\t\t\t\t\t   p->opt.shot_select = abs(atoi(argv[*arg]));\r\n\t\t\t\t\t   p->opt.multi_out = !strcmp(argv[(*arg)++],\"all\");\r\n\t\t\t\t\t   break;\r\n\t\t\tcase 'o':\r\n\t\t\t\t\t   if (isdigit(argv[*arg][0]) && !argv[*arg][1])\r\n\t\t\t\t\t\t   p->opt.output_color = atoi(argv[(*arg)++]);\r\n#ifndef NO_LCMS\r\n\t\t\t\t\t\telse p->opt.out_profile = argv[(*arg)++];\r\n\t\t\t\t\t\tbreak;\r\n\t\t\tcase 'p':  p->opt.cam_profile = argv[(*arg)++];\r\n#endif\r\n\t\t\t\t\t   break;\r\n\t\t\tcase 'P':  p->opt.bpfile     = argv[(*arg)++];  break;\r\n\t\t\tcase 'K':  p->opt.dark_frame = argv[(*arg)++];  break;\r\n\t\t\tcase 'z':  p->opt.timestamp_only    = 1;  break;\r\n\t\t\tcase 'e':  p->opt.thumbnail_only    = 1;  break;\r\n\t\t\tcase 'i':  p->opt.identify_only     = 1;  break;\r\n\t\t\tcase 'c':  p->opt.write_to_stdout   = 1;  break;\r\n\t\t\tcase 'v':  p->opt.verbose           = 1;  break;\r\n\t\t\tcase 'h':  p->opt.half_size         = 1;\t\t/* \"-h\" implies \"-f\" */\r\n\t\t\tcase 'f':  p->opt.four_color_rgb    = 1;  break;\r\n\t\t\tcase 'A':  FORC4 p->opt.greybox[c]  = atoi(argv[(*arg)++]);\r\n\t\t\tcase 'a':  p->opt.use_auto_wb       = 1;  break;\r\n\t\t\tcase 'w':  p->opt.use_camera_wb     = 1;  break;\r\n\t\t\tcase 'M':  p->opt.use_camera_matrix = (opm == '+');  break;\r\n\t\t\tcase 'D':\r\n\t\t\tcase 'd':  p->opt.document_mode = 1 + (opt == 'D');\r\n\t\t\tcase 'j':  p->opt.use_fuji_rotate   = 0;  break;\r\n\t\t\tcase 'W':  p->opt.no_auto_bright    = 1;  break;\r\n\t\t\tcase 'T':  p->opt.output_tiff       = 1;  break;\r\n\t\t\tcase '4':  p->opt.output_bps       = 16;  break;\r\n\t\t\tdefault:\r\n\t\t\t\tfprintf (stderr,_(\"Unknown option \\\"-%c\\\".\\n\"), opt);\r\n\t\t\t\treturn 1;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tif (p->opt.use_camera_matrix < 0)\r\n\t\tp->opt.use_camera_matrix = p->opt.use_camera_wb;\r\n\r\n\treturn 0;\r\n}\r\n", "/* $Id: tif_dirread.c,v 1.92.2.9 2010-06-14 00:21:46 fwarmerdam Exp $ */\n\n/*\n * Copyright (c) 1988-1997 Sam Leffler\n * Copyright (c) 1991-1997 Silicon Graphics, Inc.\n *\n * Permission to use, copy, modify, distribute, and sell this software and \n * its documentation for any purpose is hereby granted without fee, provided\n * that (i) the above copyright notices and this permission notice appear in\n * all copies of the software and related documentation, and (ii) the names of\n * Sam Leffler and Silicon Graphics may not be used in any advertising or\n * publicity relating to the software without the specific, prior written\n * permission of Sam Leffler and Silicon Graphics.\n * \n * THE SOFTWARE IS PROVIDED \"AS-IS\" AND WITHOUT WARRANTY OF ANY KIND, \n * EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY \n * WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  \n * \n * IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR\n * ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND,\n * OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,\n * WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF \n * LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE \n * OF THIS SOFTWARE.\n */\n\n/*\n * TIFF Library.\n *\n * Directory Read Support Routines.\n */\n#include \"tiffiop.h\"\n\n#define\tIGNORE\t0\t\t/* tag placeholder used below */\n\n#ifdef HAVE_IEEEFP\n# define\tTIFFCvtIEEEFloatToNative(tif, n, fp)\n# define\tTIFFCvtIEEEDoubleToNative(tif, n, dp)\n#else\nextern\tvoid TIFFCvtIEEEFloatToNative(TIFF*, uint32, float*);\nextern\tvoid TIFFCvtIEEEDoubleToNative(TIFF*, uint32, double*);\n#endif\n\nstatic  TIFFDirEntry* TIFFReadDirectoryFind(TIFFDirEntry* dir,\n\t\t\t\t\t    uint16 dircount, uint16 tagid);\nstatic\tint EstimateStripByteCounts(TIFF*, TIFFDirEntry*, uint16);\nstatic\tvoid MissingRequired(TIFF*, const char*);\nstatic\tint TIFFCheckDirOffset(TIFF*, toff_t);\nstatic\tint CheckDirCount(TIFF*, TIFFDirEntry*, uint32);\nstatic\tuint16 TIFFFetchDirectory(TIFF*, toff_t, TIFFDirEntry**, toff_t *);\nstatic\ttsize_t TIFFFetchData(TIFF*, TIFFDirEntry*, char*);\nstatic\ttsize_t TIFFFetchString(TIFF*, TIFFDirEntry*, char*);\nstatic\tfloat TIFFFetchRational(TIFF*, TIFFDirEntry*);\nstatic\tint TIFFFetchNormalTag(TIFF*, TIFFDirEntry*);\nstatic\tint TIFFFetchPerSampleShorts(TIFF*, TIFFDirEntry*, uint16*);\nstatic\tint TIFFFetchPerSampleLongs(TIFF*, TIFFDirEntry*, uint32*);\nstatic\tint TIFFFetchPerSampleAnys(TIFF*, TIFFDirEntry*, double*);\nstatic\tint TIFFFetchShortArray(TIFF*, TIFFDirEntry*, uint16*);\nstatic\tint TIFFFetchStripThing(TIFF*, TIFFDirEntry*, long, uint32**);\nstatic\tint TIFFFetchRefBlackWhite(TIFF*, TIFFDirEntry*);\nstatic\tint TIFFFetchSubjectDistance(TIFF*, TIFFDirEntry*);\nstatic\tfloat TIFFFetchFloat(TIFF*, TIFFDirEntry*);\nstatic\tint TIFFFetchFloatArray(TIFF*, TIFFDirEntry*, float*);\nstatic\tint TIFFFetchDoubleArray(TIFF*, TIFFDirEntry*, double*);\nstatic\tint TIFFFetchAnyArray(TIFF*, TIFFDirEntry*, double*);\nstatic\tint TIFFFetchShortPair(TIFF*, TIFFDirEntry*);\nstatic\tvoid ChopUpSingleUncompressedStrip(TIFF*);\n\n/*\n * Read the next TIFF directory from a file and convert it to the internal\n * format. We read directories sequentially.\n */\nint\nTIFFReadDirectory(TIFF* tif)\n{\n\tstatic const char module[] = \"TIFFReadDirectory\";\n\n\tint n;\n\tTIFFDirectory* td;\n\tTIFFDirEntry *dp, *dir = NULL;\n\tuint16 iv;\n\tuint32 v;\n\tconst TIFFFieldInfo* fip;\n\tsize_t fix;\n\tuint16 dircount;\n\tint diroutoforderwarning = 0, compressionknown = 0;\n\tint haveunknowntags = 0;\n\n\ttif->tif_diroff = tif->tif_nextdiroff;\n\t/*\n\t * Check whether we have the last offset or bad offset (IFD looping).\n\t */\n\tif (!TIFFCheckDirOffset(tif, tif->tif_nextdiroff))\n\t\treturn 0;\n\t/*\n\t * Cleanup any previous compression state.\n\t */\n\t(*tif->tif_cleanup)(tif);\n\ttif->tif_curdir++;\n\tdircount = TIFFFetchDirectory(tif, tif->tif_nextdiroff,\n\t\t\t\t      &dir, &tif->tif_nextdiroff);\n\tif (!dircount) {\n\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t     \"%s: Failed to read directory at offset %u\",\n\t\t\t     tif->tif_name, tif->tif_nextdiroff);\n\t\treturn 0;\n\t}\n\n\ttif->tif_flags &= ~TIFF_BEENWRITING;\t/* reset before new dir */\n\t/*\n\t * Setup default value and then make a pass over\n\t * the fields to check type and tag information,\n\t * and to extract info required to size data\n\t * structures.  A second pass is made afterwards\n\t * to read in everthing not taken in the first pass.\n\t */\n\ttd = &tif->tif_dir;\n\t/* free any old stuff and reinit */\n\tTIFFFreeDirectory(tif);\n\tTIFFDefaultDirectory(tif);\n\t/*\n\t * Electronic Arts writes gray-scale TIFF files\n\t * without a PlanarConfiguration directory entry.\n\t * Thus we setup a default value here, even though\n\t * the TIFF spec says there is no default value.\n\t */\n\tTIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n\n\t/*\n\t * Sigh, we must make a separate pass through the\n\t * directory for the following reason:\n\t *\n\t * We must process the Compression tag in the first pass\n\t * in order to merge in codec-private tag definitions (otherwise\n\t * we may get complaints about unknown tags).  However, the\n\t * Compression tag may be dependent on the SamplesPerPixel\n\t * tag value because older TIFF specs permited Compression\n\t * to be written as a SamplesPerPixel-count tag entry.\n\t * Thus if we don't first figure out the correct SamplesPerPixel\n\t * tag value then we may end up ignoring the Compression tag\n\t * value because it has an incorrect count value (if the\n\t * true value of SamplesPerPixel is not 1).\n\t *\n\t * It sure would have been nice if Aldus had really thought\n\t * this stuff through carefully.\n\t */\n\tfor (dp = dir, n = dircount; n > 0; n--, dp++) {\n\t\tif (tif->tif_flags & TIFF_SWAB) {\n\t\t\tTIFFSwabArrayOfShort(&dp->tdir_tag, 2);\n\t\t\tTIFFSwabArrayOfLong(&dp->tdir_count, 2);\n\t\t}\n\t\tif (dp->tdir_tag == TIFFTAG_SAMPLESPERPIXEL) {\n\t\t\tif (!TIFFFetchNormalTag(tif, dp))\n\t\t\t\tgoto bad;\n\t\t\tdp->tdir_tag = IGNORE;\n\t\t}\n\t}\n\t/*\n\t * First real pass over the directory.\n\t */\n\tfix = 0;\n\tfor (dp = dir, n = dircount; n > 0; n--, dp++) {\n\n\t\tif (dp->tdir_tag == IGNORE)\n\t\t\tcontinue;\n\t\tif (fix >= tif->tif_nfields)\n\t\t\tfix = 0;\n\n\t\t/*\n\t\t * Silicon Beach (at least) writes unordered\n\t\t * directory tags (violating the spec).  Handle\n\t\t * it here, but be obnoxious (maybe they'll fix it?).\n\t\t */\n\t\tif (dp->tdir_tag < tif->tif_fieldinfo[fix]->field_tag) {\n\t\t\tif (!diroutoforderwarning) {\n\t\t\t\tTIFFWarningExt(tif->tif_clientdata, module,\n\t\"%s: invalid TIFF directory; tags are not sorted in ascending order\",\n\t\t\t\t\t    tif->tif_name);\n\t\t\t\tdiroutoforderwarning = 1;\n\t\t\t}\n\t\t\tfix = 0;\t\t\t/* O(n^2) */\n\t\t}\n\t\twhile (fix < tif->tif_nfields &&\n\t\t    tif->tif_fieldinfo[fix]->field_tag < dp->tdir_tag)\n\t\t\tfix++;\n\t\tif (fix >= tif->tif_nfields ||\n\t\t    tif->tif_fieldinfo[fix]->field_tag != dp->tdir_tag) {\n\t\t\t/* Unknown tag ... we'll deal with it below */\n\t\t\thaveunknowntags = 1;\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * Null out old tags that we ignore.\n\t\t */\n\t\tif (tif->tif_fieldinfo[fix]->field_bit == FIELD_IGNORE) {\n\tignore:\n\t\t\tdp->tdir_tag = IGNORE;\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * Check data type.\n\t\t */\n\t\tfip = tif->tif_fieldinfo[fix];\n\t\twhile (dp->tdir_type != (unsigned short) fip->field_type\n\t\t    && fix < tif->tif_nfields) {\n\t\t\tif (fip->field_type == TIFF_ANY)\t/* wildcard */\n\t\t\t\tbreak;\n            ++fix; fip = (fix >= tif->tif_nfields) ? 0 : tif->tif_fieldinfo[++fix];\n\t\t\tif (fix >= tif->tif_nfields ||\n\t\t\t    fip->field_tag != dp->tdir_tag) {\n\t\t\t\tTIFFWarningExt(tif->tif_clientdata, module,\n\t\t\t\"%s: wrong data type %d for \\\"%s\\\"; tag ignored\",\n\t\t\t\t\t    tif->tif_name, dp->tdir_type,\n\t\t\t\t\t    tif->tif_fieldinfo[fix-1]->field_name);\n\t\t\t\tgoto ignore;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * Check count if known in advance.\n\t\t */\n\t\tif (fip->field_readcount != TIFF_VARIABLE\n\t\t    && fip->field_readcount != TIFF_VARIABLE2) {\n\t\t\tuint32 expected = (fip->field_readcount == TIFF_SPP) ?\n\t\t\t    (uint32) td->td_samplesperpixel :\n\t\t\t    (uint32) fip->field_readcount;\n\t\t\tif (!CheckDirCount(tif, dp, expected))\n\t\t\t\tgoto ignore;\n\t\t}\n\n\t\tswitch (dp->tdir_tag) {\n\t\tcase TIFFTAG_COMPRESSION:\n\t\t\t/*\n\t\t\t * The 5.0 spec says the Compression tag has\n\t\t\t * one value, while earlier specs say it has\n\t\t\t * one value per sample.  Because of this, we\n\t\t\t * accept the tag if one value is supplied.\n\t\t\t */\n\t\t\tif (dp->tdir_count == 1) {\n\t\t\t\tv = TIFFExtractData(tif,\n\t\t\t\t    dp->tdir_type, dp->tdir_offset);\n\t\t\t\tif (!TIFFSetField(tif, dp->tdir_tag, (uint16)v))\n\t\t\t\t\tgoto bad;\n\t\t\t\telse\n\t\t\t\t\tcompressionknown = 1;\n\t\t\t\tbreak;\n\t\t\t/* XXX: workaround for broken TIFFs */\n\t\t\t} else if (dp->tdir_type == TIFF_LONG) {\n\t\t\t\tif (!TIFFFetchPerSampleLongs(tif, dp, &v) ||\n\t\t\t\t    !TIFFSetField(tif, dp->tdir_tag, (uint16)v))\n\t\t\t\t\tgoto bad;\n\t\t\t} else {\n\t\t\t\tif (!TIFFFetchPerSampleShorts(tif, dp, &iv)\n\t\t\t\t    || !TIFFSetField(tif, dp->tdir_tag, iv))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tdp->tdir_tag = IGNORE;\n\t\t\tbreak;\n\t\tcase TIFFTAG_STRIPOFFSETS:\n\t\tcase TIFFTAG_STRIPBYTECOUNTS:\n\t\tcase TIFFTAG_TILEOFFSETS:\n\t\tcase TIFFTAG_TILEBYTECOUNTS:\n\t\t\tTIFFSetFieldBit(tif, fip->field_bit);\n\t\t\tbreak;\n\t\tcase TIFFTAG_IMAGEWIDTH:\n\t\tcase TIFFTAG_IMAGELENGTH:\n\t\tcase TIFFTAG_IMAGEDEPTH:\n\t\tcase TIFFTAG_TILELENGTH:\n\t\tcase TIFFTAG_TILEWIDTH:\n\t\tcase TIFFTAG_TILEDEPTH:\n\t\tcase TIFFTAG_PLANARCONFIG:\n\t\tcase TIFFTAG_ROWSPERSTRIP:\n\t\tcase TIFFTAG_EXTRASAMPLES:\n\t\t\tif (!TIFFFetchNormalTag(tif, dp))\n\t\t\t\tgoto bad;\n\t\t\tdp->tdir_tag = IGNORE;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*\n\t * If we saw any unknown tags, make an extra pass over the directory\n\t * to deal with them.  This must be done separately because the tags\n\t * could have become known when we registered a codec after finding\n\t * the Compression tag.  In a correctly-sorted directory there's\n\t * no problem because Compression will come before any codec-private\n\t * tags, but if the sorting is wrong that might not hold.\n\t */\n\tif (haveunknowntags) {\n\t    fix = 0;\n\t    for (dp = dir, n = dircount; n > 0; n--, dp++) {\n\t\tif (dp->tdir_tag == IGNORE)\n\t\t\tcontinue;\n\t\tif (fix >= tif->tif_nfields ||\n\t\t    dp->tdir_tag < tif->tif_fieldinfo[fix]->field_tag)\n\t\t\tfix = 0;\t\t\t/* O(n^2) */\n\t\twhile (fix < tif->tif_nfields &&\n\t\t    tif->tif_fieldinfo[fix]->field_tag < dp->tdir_tag)\n\t\t\tfix++;\n\t\tif (fix >= tif->tif_nfields ||\n\t\t    tif->tif_fieldinfo[fix]->field_tag != dp->tdir_tag) {\n\n\t\t\t\t\tTIFFWarningExt(tif->tif_clientdata,\n\t\t\t\t\t\t       module,\n                        \"%s: unknown field with tag %d (0x%x) encountered\",\n\t\t\t\t\t\t       tif->tif_name,\n\t\t\t\t\t\t       dp->tdir_tag,\n\t\t\t\t\t\t       dp->tdir_tag);\n\n\t\t\t\t\tif (!_TIFFMergeFieldInfo(tif,\n\t\t\t\t\t\t_TIFFCreateAnonFieldInfo(tif,\n\t\t\t\t\t\tdp->tdir_tag,\n\t\t\t\t\t\t(TIFFDataType) dp->tdir_type),\n\t\t\t\t\t\t1))\n\t\t\t\t\t{\n\t\t\t\t\tTIFFWarningExt(tif->tif_clientdata,\n\t\t\t\t\t\t       module,\n\t\t\t\"Registering anonymous field with tag %d (0x%x) failed\",\n\t\t\t\t\t\t       dp->tdir_tag,\n\t\t\t\t\t\t       dp->tdir_tag);\n\t\t\t\t\tdp->tdir_tag = IGNORE;\n\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\tfix = 0;\n\t\t\twhile (fix < tif->tif_nfields &&\n\t\t\t       tif->tif_fieldinfo[fix]->field_tag < dp->tdir_tag)\n\t\t\t\tfix++;\n\t\t}\n\t\t/*\n\t\t * Check data type.\n\t\t */\n\t\tfip = tif->tif_fieldinfo[fix];\n\t\twhile (dp->tdir_type != (unsigned short) fip->field_type\n\t\t    && fix < tif->tif_nfields) {\n\t\t\tif (fip->field_type == TIFF_ANY)\t/* wildcard */\n\t\t\t\tbreak;\n            ++fix; fip = (fix >= tif->tif_nfields) ? 0 : tif->tif_fieldinfo[++fix];\n\t\t\tif (fix >= tif->tif_nfields ||\n\t\t\t    fip->field_tag != dp->tdir_tag) {\n\t\t\t\tTIFFWarningExt(tif->tif_clientdata, module,\n\t\t\t\"%s: wrong data type %d for \\\"%s\\\"; tag ignored\",\n\t\t\t\t\t    tif->tif_name, dp->tdir_type,\n\t\t\t\t\t    tif->tif_fieldinfo[fix-1]->field_name);\n\t\t\t\tdp->tdir_tag = IGNORE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t    }\n\t}\n\n\t/*\n\t * XXX: OJPEG hack.\n\t * If a) compression is OJPEG, b) planarconfig tag says it's separate,\n\t * c) strip offsets/bytecounts tag are both present and\n\t * d) both contain exactly one value, then we consistently find\n\t * that the buggy implementation of the buggy compression scheme\n\t * matches contig planarconfig best. So we 'fix-up' the tag here\n\t */\n\tif ((td->td_compression==COMPRESSION_OJPEG) &&\n\t    (td->td_planarconfig==PLANARCONFIG_SEPARATE)) {\n\t\tdp = TIFFReadDirectoryFind(dir,dircount,TIFFTAG_STRIPOFFSETS);\n\t\tif ((dp!=0) && (dp->tdir_count==1)) {\n\t\t\tdp = TIFFReadDirectoryFind(dir, dircount,\n\t\t\t\t\t\t   TIFFTAG_STRIPBYTECOUNTS);\n\t\t\tif ((dp!=0) && (dp->tdir_count==1)) {\n\t\t\t\ttd->td_planarconfig=PLANARCONFIG_CONTIG;\n\t\t\t\tTIFFWarningExt(tif->tif_clientdata,\n\t\t\t\t\t       \"TIFFReadDirectory\",\n\t\t\t\t\"Planarconfig tag value assumed incorrect, \"\n\t\t\t\t\"assuming data is contig instead of chunky\");\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Allocate directory structure and setup defaults.\n\t */\n\tif (!TIFFFieldSet(tif, FIELD_IMAGEDIMENSIONS)) {\n\t\tMissingRequired(tif, \"ImageLength\");\n\t\tgoto bad;\n\t}\n\t/* \n\t * Setup appropriate structures (by strip or by tile)\n\t */\n\tif (!TIFFFieldSet(tif, FIELD_TILEDIMENSIONS)) {\n\t\ttd->td_nstrips = TIFFNumberOfStrips(tif);\n\t\ttd->td_tilewidth = td->td_imagewidth;\n\t\ttd->td_tilelength = td->td_rowsperstrip;\n\t\ttd->td_tiledepth = td->td_imagedepth;\n\t\ttif->tif_flags &= ~TIFF_ISTILED;\n\t} else {\n\t\ttd->td_nstrips = TIFFNumberOfTiles(tif);\n\t\ttif->tif_flags |= TIFF_ISTILED;\n\t}\n\tif (!td->td_nstrips) {\n\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t     \"%s: cannot handle zero number of %s\",\n\t\t\t     tif->tif_name, isTiled(tif) ? \"tiles\" : \"strips\");\n\t\tgoto bad;\n\t}\n\ttd->td_stripsperimage = td->td_nstrips;\n\tif (td->td_planarconfig == PLANARCONFIG_SEPARATE)\n\t\ttd->td_stripsperimage /= td->td_samplesperpixel;\n\tif (!TIFFFieldSet(tif, FIELD_STRIPOFFSETS)) {\n\t\tif ((td->td_compression==COMPRESSION_OJPEG) &&\n\t\t    (isTiled(tif)==0) &&\n\t\t    (td->td_nstrips==1)) {\n\t\t\t/*\n\t\t\t * XXX: OJPEG hack.\n\t\t\t * If a) compression is OJPEG, b) it's not a tiled TIFF,\n\t\t\t * and c) the number of strips is 1,\n\t\t\t * then we tolerate the absence of stripoffsets tag,\n\t\t\t * because, presumably, all required data is in the\n\t\t\t * JpegInterchangeFormat stream.\n\t\t\t */\n\t\t\tTIFFSetFieldBit(tif, FIELD_STRIPOFFSETS);\n\t\t} else {\n\t\t\tMissingRequired(tif,\n\t\t\t\tisTiled(tif) ? \"TileOffsets\" : \"StripOffsets\");\n\t\t\tgoto bad;\n\t\t}\n\t}\n\n\t/*\n\t * Second pass: extract other information.\n\t */\n\tfor (dp = dir, n = dircount; n > 0; n--, dp++) {\n\t\tif (dp->tdir_tag == IGNORE)\n\t\t\tcontinue;\n\t\tswitch (dp->tdir_tag) {\n\t\tcase TIFFTAG_MINSAMPLEVALUE:\n\t\tcase TIFFTAG_MAXSAMPLEVALUE:\n\t\tcase TIFFTAG_BITSPERSAMPLE:\n\t\tcase TIFFTAG_DATATYPE:\n\t\tcase TIFFTAG_SAMPLEFORMAT:\n\t\t\t/*\n\t\t\t * The 5.0 spec says the Compression tag has\n\t\t\t * one value, while earlier specs say it has\n\t\t\t * one value per sample.  Because of this, we\n\t\t\t * accept the tag if one value is supplied.\n\t\t\t *\n\t\t\t * The MinSampleValue, MaxSampleValue, BitsPerSample\n\t\t\t * DataType and SampleFormat tags are supposed to be\n\t\t\t * written as one value/sample, but some vendors\n\t\t\t * incorrectly write one value only -- so we accept\n\t\t\t * that as well (yech). Other vendors write correct\n\t\t\t * value for NumberOfSamples, but incorrect one for\n\t\t\t * BitsPerSample and friends, and we will read this\n\t\t\t * too.\n\t\t\t */\n\t\t\tif (dp->tdir_count == 1) {\n\t\t\t\tv = TIFFExtractData(tif,\n\t\t\t\t    dp->tdir_type, dp->tdir_offset);\n\t\t\t\tif (!TIFFSetField(tif, dp->tdir_tag, (uint16)v))\n\t\t\t\t\tgoto bad;\n\t\t\t/* XXX: workaround for broken TIFFs */\n\t\t\t} else if (dp->tdir_tag == TIFFTAG_BITSPERSAMPLE\n\t\t\t\t   && dp->tdir_type == TIFF_LONG) {\n\t\t\t\tif (!TIFFFetchPerSampleLongs(tif, dp, &v) ||\n\t\t\t\t    !TIFFSetField(tif, dp->tdir_tag, (uint16)v))\n\t\t\t\t\tgoto bad;\n\t\t\t} else {\n\t\t\t\tif (!TIFFFetchPerSampleShorts(tif, dp, &iv) ||\n\t\t\t\t    !TIFFSetField(tif, dp->tdir_tag, iv))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFFTAG_SMINSAMPLEVALUE:\n\t\tcase TIFFTAG_SMAXSAMPLEVALUE:\n\t\t\t{\n\t\t\t\tdouble dv = 0.0;\n\t\t\t\tif (!TIFFFetchPerSampleAnys(tif, dp, &dv) ||\n\t\t\t\t    !TIFFSetField(tif, dp->tdir_tag, dv))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFFTAG_STRIPOFFSETS:\n\t\tcase TIFFTAG_TILEOFFSETS:\n\t\t\tif (!TIFFFetchStripThing(tif, dp,\n\t\t\t    td->td_nstrips, &td->td_stripoffset))\n\t\t\t\tgoto bad;\n\t\t\tbreak;\n\t\tcase TIFFTAG_STRIPBYTECOUNTS:\n\t\tcase TIFFTAG_TILEBYTECOUNTS:\n\t\t\tif (!TIFFFetchStripThing(tif, dp,\n\t\t\t    td->td_nstrips, &td->td_stripbytecount))\n\t\t\t\tgoto bad;\n\t\t\tbreak;\n\t\tcase TIFFTAG_COLORMAP:\n\t\tcase TIFFTAG_TRANSFERFUNCTION:\n\t\t\t{\n\t\t\t\tchar* cp;\n\t\t\t\t/*\n\t\t\t\t * TransferFunction can have either 1x or 3x\n\t\t\t\t * data values; Colormap can have only 3x\n\t\t\t\t * items.\n\t\t\t\t */\n\t\t\t\tv = 1L<<td->td_bitspersample;\n\t\t\t\tif (dp->tdir_tag == TIFFTAG_COLORMAP ||\n\t\t\t\t    dp->tdir_count != v) {\n\t\t\t\t\tif (!CheckDirCount(tif, dp, 3 * v))\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tv *= sizeof(uint16);\n\t\t\t\tcp = (char *)_TIFFCheckMalloc(tif,\n\t\t\t\t\t\t\t      dp->tdir_count,\n\t\t\t\t\t\t\t      sizeof (uint16),\n\t\t\t\t\t\"to read \\\"TransferFunction\\\" tag\");\n\t\t\t\tif (cp != NULL) {\n\t\t\t\t\tif (TIFFFetchData(tif, dp, cp)) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * This deals with there being\n\t\t\t\t\t\t * only one array to apply to\n\t\t\t\t\t\t * all samples.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tuint32 c = 1L << td->td_bitspersample;\n\t\t\t\t\t\tif (dp->tdir_count == c)\n\t\t\t\t\t\t\tv = 0L;\n\t\t\t\t\t\tTIFFSetField(tif, dp->tdir_tag,\n\t\t\t\t\t\t    cp, cp+v, cp+2*v);\n\t\t\t\t\t}\n\t\t\t\t\t_TIFFfree(cp);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\tcase TIFFTAG_PAGENUMBER:\n\t\tcase TIFFTAG_HALFTONEHINTS:\n\t\tcase TIFFTAG_YCBCRSUBSAMPLING:\n\t\tcase TIFFTAG_DOTRANGE:\n\t\t\t(void) TIFFFetchShortPair(tif, dp);\n\t\t\tbreak;\n\t\tcase TIFFTAG_REFERENCEBLACKWHITE:\n\t\t\t(void) TIFFFetchRefBlackWhite(tif, dp);\n\t\t\tbreak;\n/* BEGIN REV 4.0 COMPATIBILITY */\n\t\tcase TIFFTAG_OSUBFILETYPE:\n\t\t\tv = 0L;\n\t\t\tswitch (TIFFExtractData(tif, dp->tdir_type,\n\t\t\t    dp->tdir_offset)) {\n\t\t\tcase OFILETYPE_REDUCEDIMAGE:\n\t\t\t\tv = FILETYPE_REDUCEDIMAGE;\n\t\t\t\tbreak;\n\t\t\tcase OFILETYPE_PAGE:\n\t\t\t\tv = FILETYPE_PAGE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (v)\n\t\t\t\tTIFFSetField(tif, TIFFTAG_SUBFILETYPE, v);\n\t\t\tbreak;\n/* END REV 4.0 COMPATIBILITY */\n\t\tdefault:\n\t\t\t(void) TIFFFetchNormalTag(tif, dp);\n\t\t\tbreak;\n\t\t}\n\t}\n\t/*\n\t * OJPEG hack:\n\t * - If a) compression is OJPEG, and b) photometric tag is missing,\n\t * then we consistently find that photometric should be YCbCr\n\t * - If a) compression is OJPEG, and b) photometric tag says it's RGB,\n\t * then we consistently find that the buggy implementation of the\n\t * buggy compression scheme matches photometric YCbCr instead.\n\t * - If a) compression is OJPEG, and b) bitspersample tag is missing,\n\t * then we consistently find bitspersample should be 8.\n\t * - If a) compression is OJPEG, b) samplesperpixel tag is missing,\n\t * and c) photometric is RGB or YCbCr, then we consistently find\n\t * samplesperpixel should be 3\n\t * - If a) compression is OJPEG, b) samplesperpixel tag is missing,\n\t * and c) photometric is MINISWHITE or MINISBLACK, then we consistently\n\t * find samplesperpixel should be 3\n\t */\n\tif (td->td_compression==COMPRESSION_OJPEG)\n\t{\n\t\tif (!TIFFFieldSet(tif,FIELD_PHOTOMETRIC))\n\t\t{\n\t\t\tTIFFWarningExt(tif->tif_clientdata, \"TIFFReadDirectory\",\n\t\t\t\"Photometric tag is missing, assuming data is YCbCr\");\n\t\t\tif (!TIFFSetField(tif,TIFFTAG_PHOTOMETRIC,PHOTOMETRIC_YCBCR))\n\t\t\t\tgoto bad;\n\t\t}\n\t\telse if (td->td_photometric==PHOTOMETRIC_RGB)\n\t\t{\n\t\t\ttd->td_photometric=PHOTOMETRIC_YCBCR;\n\t\t\tTIFFWarningExt(tif->tif_clientdata, \"TIFFReadDirectory\",\n\t\t\t\"Photometric tag value assumed incorrect, \"\n\t\t\t\"assuming data is YCbCr instead of RGB\");\n\t\t}\n\t\tif (!TIFFFieldSet(tif,FIELD_BITSPERSAMPLE))\n\t\t{\n\t\t\tTIFFWarningExt(tif->tif_clientdata,\"TIFFReadDirectory\",\n\t\t\"BitsPerSample tag is missing, assuming 8 bits per sample\");\n\t\t\tif (!TIFFSetField(tif,TIFFTAG_BITSPERSAMPLE,8))\n\t\t\t\tgoto bad;\n\t\t}\n\t\tif (!TIFFFieldSet(tif,FIELD_SAMPLESPERPIXEL))\n\t\t{\n\t\t\tif ((td->td_photometric==PHOTOMETRIC_RGB)\n\t\t\t    || (td->td_photometric==PHOTOMETRIC_YCBCR))\n\t\t\t{\n\t\t\t\tTIFFWarningExt(tif->tif_clientdata,\n\t\t\t\t\t       \"TIFFReadDirectory\",\n\t\t\t\t\"SamplesPerPixel tag is missing, \"\n\t\t\t\t\"assuming correct SamplesPerPixel value is 3\");\n\t\t\t\tif (!TIFFSetField(tif,TIFFTAG_SAMPLESPERPIXEL,3))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\telse if ((td->td_photometric==PHOTOMETRIC_MINISWHITE)\n\t\t\t\t || (td->td_photometric==PHOTOMETRIC_MINISBLACK))\n\t\t\t{\n\t\t\t\tTIFFWarningExt(tif->tif_clientdata,\n\t\t\t\t\t       \"TIFFReadDirectory\",\n\t\t\t\t\"SamplesPerPixel tag is missing, \"\n\t\t\t\t\"assuming correct SamplesPerPixel value is 1\");\n\t\t\t\tif (!TIFFSetField(tif,TIFFTAG_SAMPLESPERPIXEL,1))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\t * Verify Palette image has a Colormap.\n\t */\n\tif (td->td_photometric == PHOTOMETRIC_PALETTE &&\n\t    !TIFFFieldSet(tif, FIELD_COLORMAP)) {\n\t\tMissingRequired(tif, \"Colormap\");\n\t\tgoto bad;\n\t}\n\t/*\n\t * OJPEG hack:\n\t * We do no further messing with strip/tile offsets/bytecounts in OJPEG\n\t * TIFFs\n\t */\n\tif (td->td_compression!=COMPRESSION_OJPEG)\n\t{\n\t\t/*\n\t\t * Attempt to deal with a missing StripByteCounts tag.\n\t\t */\n\t\tif (!TIFFFieldSet(tif, FIELD_STRIPBYTECOUNTS)) {\n\t\t\t/*\n\t\t\t * Some manufacturers violate the spec by not giving\n\t\t\t * the size of the strips.  In this case, assume there\n\t\t\t * is one uncompressed strip of data.\n\t\t\t */\n\t\t\tif ((td->td_planarconfig == PLANARCONFIG_CONTIG &&\n\t\t\t    td->td_nstrips > 1) ||\n\t\t\t    (td->td_planarconfig == PLANARCONFIG_SEPARATE &&\n\t\t\t     td->td_nstrips != td->td_samplesperpixel)) {\n\t\t\t    MissingRequired(tif, \"StripByteCounts\");\n\t\t\t    goto bad;\n\t\t\t}\n\t\t\tTIFFWarningExt(tif->tif_clientdata, module,\n\t\t\t\t\"%s: TIFF directory is missing required \"\n\t\t\t\t\"\\\"%s\\\" field, calculating from imagelength\",\n\t\t\t\ttif->tif_name,\n\t\t\t\t_TIFFFieldWithTag(tif,TIFFTAG_STRIPBYTECOUNTS)->field_name);\n\t\t\tif (EstimateStripByteCounts(tif, dir, dircount) < 0)\n\t\t\t    goto bad;\n\t\t/*\n\t\t * Assume we have wrong StripByteCount value (in case\n\t\t * of single strip) in following cases:\n\t\t *   - it is equal to zero along with StripOffset;\n\t\t *   - it is larger than file itself (in case of uncompressed\n\t\t *     image);\n\t\t *   - it is smaller than the size of the bytes per row\n\t\t *     multiplied on the number of rows.  The last case should\n\t\t *     not be checked in the case of writing new image,\n\t\t *     because we may do not know the exact strip size\n\t\t *     until the whole image will be written and directory\n\t\t *     dumped out.\n\t\t */\n\t\t#define\tBYTECOUNTLOOKSBAD \\\n\t\t    ( (td->td_stripbytecount[0] == 0 && td->td_stripoffset[0] != 0) || \\\n\t\t      (td->td_compression == COMPRESSION_NONE && \\\n\t\t       td->td_stripbytecount[0] > TIFFGetFileSize(tif) - td->td_stripoffset[0]) || \\\n\t\t      (tif->tif_mode == O_RDONLY && \\\n\t\t       td->td_compression == COMPRESSION_NONE && \\\n\t\t       td->td_stripbytecount[0] < TIFFScanlineSize(tif) * td->td_imagelength) )\n\n\t\t} else if (td->td_nstrips == 1\n\t\t\t   && td->td_stripoffset[0] != 0\n\t\t\t   && BYTECOUNTLOOKSBAD) {\n\t\t\t/*\n\t\t\t * XXX: Plexus (and others) sometimes give a value of\n\t\t\t * zero for a tag when they don't know what the\n\t\t\t * correct value is!  Try and handle the simple case\n\t\t\t * of estimating the size of a one strip image.\n\t\t\t */\n\t\t\tTIFFWarningExt(tif->tif_clientdata, module,\n\t\"%s: Bogus \\\"%s\\\" field, ignoring and calculating from imagelength\",\n\t\t\t\t    tif->tif_name,\n\t\t\t\t    _TIFFFieldWithTag(tif,TIFFTAG_STRIPBYTECOUNTS)->field_name);\n\t\t\tif(EstimateStripByteCounts(tif, dir, dircount) < 0)\n\t\t\t    goto bad;\n\t\t} else if (td->td_planarconfig == PLANARCONFIG_CONTIG\n\t\t\t   && td->td_nstrips > 2\n\t\t\t   && td->td_compression == COMPRESSION_NONE\n\t\t\t   && td->td_stripbytecount[0] != td->td_stripbytecount[1]\n                           && td->td_stripbytecount[0] != 0 \n                           && td->td_stripbytecount[1] != 0 ) {\n\t\t\t/*\n\t\t\t * XXX: Some vendors fill StripByteCount array with \n                         * absolutely wrong values (it can be equal to \n                         * StripOffset array, for example). Catch this case \n                         * here.\n\t\t\t */\n\t\t\tTIFFWarningExt(tif->tif_clientdata, module,\n\t\"%s: Wrong \\\"%s\\\" field, ignoring and calculating from imagelength\",\n\t\t\t\t    tif->tif_name,\n\t\t\t\t    _TIFFFieldWithTag(tif,TIFFTAG_STRIPBYTECOUNTS)->field_name);\n\t\t\tif (EstimateStripByteCounts(tif, dir, dircount) < 0)\n\t\t\t    goto bad;\n\t\t}\n\t}\n\tif (dir) {\n\t\t_TIFFfree((char *)dir);\n\t\tdir = NULL;\n\t}\n\tif (!TIFFFieldSet(tif, FIELD_MAXSAMPLEVALUE))\n\t\ttd->td_maxsamplevalue = (uint16)((1L<<td->td_bitspersample)-1);\n\t/*\n\t * Setup default compression scheme.\n\t */\n\n\t/*\n\t * XXX: We can optimize checking for the strip bounds using the sorted\n\t * bytecounts array. See also comments for TIFFAppendToStrip()\n\t * function in tif_write.c.\n\t */\n\tif (td->td_nstrips > 1) {\n\t\ttstrip_t strip;\n\n\t\ttd->td_stripbytecountsorted = 1;\n\t\tfor (strip = 1; strip < td->td_nstrips; strip++) {\n\t\t\tif (td->td_stripoffset[strip - 1] >\n\t\t\t    td->td_stripoffset[strip]) {\n\t\t\t\ttd->td_stripbytecountsorted = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!TIFFFieldSet(tif, FIELD_COMPRESSION))\n\t\tTIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_NONE);\n\t/*\n\t * Some manufacturers make life difficult by writing\n\t * large amounts of uncompressed data as a single strip.\n\t * This is contrary to the recommendations of the spec.\n\t * The following makes an attempt at breaking such images\n\t * into strips closer to the recommended 8k bytes.  A\n\t * side effect, however, is that the RowsPerStrip tag\n\t * value may be changed.\n\t */\n\tif (td->td_nstrips == 1 && td->td_compression == COMPRESSION_NONE &&\n\t    (tif->tif_flags & (TIFF_STRIPCHOP|TIFF_ISTILED)) == TIFF_STRIPCHOP)\n\t\tChopUpSingleUncompressedStrip(tif);\n\n\t/*\n\t * Reinitialize i/o since we are starting on a new directory.\n\t */\n\ttif->tif_row = (uint32) -1;\n\ttif->tif_curstrip = (tstrip_t) -1;\n\ttif->tif_col = (uint32) -1;\n\ttif->tif_curtile = (ttile_t) -1;\n\ttif->tif_tilesize = (tsize_t) -1;\n\n\ttif->tif_scanlinesize = TIFFScanlineSize(tif);\n\tif (!tif->tif_scanlinesize) {\n\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t     \"%s: cannot handle zero scanline size\",\n\t\t\t     tif->tif_name);\n\t\treturn (0);\n\t}\n\n\tif (isTiled(tif)) {\n\t\ttif->tif_tilesize = TIFFTileSize(tif);\n\t\tif (!tif->tif_tilesize) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t     \"%s: cannot handle zero tile size\",\n\t\t\t\t     tif->tif_name);\n\t\t\treturn (0);\n\t\t}\n\t} else {\n\t\tif (!TIFFStripSize(tif)) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t     \"%s: cannot handle zero strip size\",\n\t\t\t\t     tif->tif_name);\n\t\t\treturn (0);\n\t\t}\n\t}\n\treturn (1);\nbad:\n\tif (dir)\n\t\t_TIFFfree(dir);\n\treturn (0);\n}\n\nstatic TIFFDirEntry*\nTIFFReadDirectoryFind(TIFFDirEntry* dir, uint16 dircount, uint16 tagid)\n{\n\tTIFFDirEntry* m;\n\tuint16 n;\n\tfor (m=dir, n=0; n<dircount; m++, n++)\n\t{\n\t\tif (m->tdir_tag==tagid)\n\t\t\treturn(m);\n\t}\n\treturn(0);\n}\n\n/*\n * Read custom directory from the arbitarry offset.\n * The code is very similar to TIFFReadDirectory().\n */\nint\nTIFFReadCustomDirectory(TIFF* tif, toff_t diroff,\n\t\t\tconst TIFFFieldInfo info[], size_t n)\n{\n\tstatic const char module[] = \"TIFFReadCustomDirectory\";\n\n\tTIFFDirectory* td = &tif->tif_dir;\n\tTIFFDirEntry *dp, *dir = NULL;\n\tconst TIFFFieldInfo* fip;\n\tsize_t fix;\n\tuint16 i, dircount;\n\n\t_TIFFSetupFieldInfo(tif, info, n);\n\n\tdircount = TIFFFetchDirectory(tif, diroff, &dir, NULL);\n\tif (!dircount) {\n\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\"%s: Failed to read custom directory at offset %u\",\n\t\t\t     tif->tif_name, diroff);\n\t\treturn 0;\n\t}\n\n\tTIFFFreeDirectory(tif);\n        _TIFFmemset(&tif->tif_dir, 0, sizeof(TIFFDirectory));\n\n\tfix = 0;\n\tfor (dp = dir, i = dircount; i > 0; i--, dp++) {\n\t\tif (tif->tif_flags & TIFF_SWAB) {\n\t\t\tTIFFSwabArrayOfShort(&dp->tdir_tag, 2);\n\t\t\tTIFFSwabArrayOfLong(&dp->tdir_count, 2);\n\t\t}\n\n\t\tif (fix >= tif->tif_nfields || dp->tdir_tag == IGNORE)\n\t\t\tcontinue;\n\n\t\twhile (fix < tif->tif_nfields &&\n\t\t       tif->tif_fieldinfo[fix]->field_tag < dp->tdir_tag)\n\t\t\tfix++;\n\n\t\tif (fix >= tif->tif_nfields ||\n\t\t    tif->tif_fieldinfo[fix]->field_tag != dp->tdir_tag) {\n\n\t\t\tTIFFWarningExt(tif->tif_clientdata, module,\n                        \"%s: unknown field with tag %d (0x%x) encountered\",\n\t\t\t\t    tif->tif_name, dp->tdir_tag, dp->tdir_tag);\n\t\t\tif (!_TIFFMergeFieldInfo(tif,\n\t\t\t\t\t\t _TIFFCreateAnonFieldInfo(tif,\n\t\t\t\t\t\t dp->tdir_tag,\n\t\t\t\t\t\t (TIFFDataType) dp->tdir_type),\n\t\t\t\t\t\t 1))\n\t\t\t{\n\t\t\t\tTIFFWarningExt(tif->tif_clientdata, module,\n\t\t\t\"Registering anonymous field with tag %d (0x%x) failed\",\n\t\t\t\t\t\tdp->tdir_tag, dp->tdir_tag);\n\t\t\t\tgoto ignore;\n\t\t\t}\n\n\t\t\tfix = 0;\n\t\t\twhile (fix < tif->tif_nfields &&\n\t\t\t       tif->tif_fieldinfo[fix]->field_tag < dp->tdir_tag)\n\t\t\t\tfix++;\n\t\t}\n\t\t/*\n\t\t * Null out old tags that we ignore.\n\t\t */\n\t\tif (tif->tif_fieldinfo[fix]->field_bit == FIELD_IGNORE) {\n\tignore:\n\t\t\tdp->tdir_tag = IGNORE;\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * Check data type.\n\t\t */\n\t\tfip = tif->tif_fieldinfo[fix];\n\t\twhile (dp->tdir_type != (unsigned short) fip->field_type\n                       && fix < tif->tif_nfields) {\n\t\t\tif (fip->field_type == TIFF_ANY)\t/* wildcard */\n\t\t\t\tbreak;\n            ++fix; fip = (fix >= tif->tif_nfields) ? 0 : tif->tif_fieldinfo[++fix];\n\t\t\tif (fix >= tif->tif_nfields ||\n\t\t\t    fip->field_tag != dp->tdir_tag) {\n\t\t\t\tTIFFWarningExt(tif->tif_clientdata, module,\n\t\t\t\"%s: wrong data type %d for \\\"%s\\\"; tag ignored\",\n\t\t\t\t\t    tif->tif_name, dp->tdir_type,\n\t\t\t\t\t    tif->tif_fieldinfo[fix-1]->field_name);\n\t\t\t\tgoto ignore;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * Check count if known in advance.\n\t\t */\n\t\tif (fip->field_readcount != TIFF_VARIABLE\n\t\t    && fip->field_readcount != TIFF_VARIABLE2) {\n\t\t\tuint32 expected = (fip->field_readcount == TIFF_SPP) ?\n\t\t\t    (uint32) td->td_samplesperpixel :\n\t\t\t    (uint32) fip->field_readcount;\n\t\t\tif (!CheckDirCount(tif, dp, expected))\n\t\t\t\tgoto ignore;\n\t\t}\n\n\t\t/*\n\t\t * EXIF tags which need to be specifically processed.\n\t\t */\n\t\tswitch (dp->tdir_tag) {\n\t\t\tcase EXIFTAG_SUBJECTDISTANCE:\n\t\t\t\t(void) TIFFFetchSubjectDistance(tif, dp);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t(void) TIFFFetchNormalTag(tif, dp);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tif (dir)\n\t\t_TIFFfree(dir);\n\treturn 1;\n}\n\n/*\n * EXIF is important special case of custom IFD, so we have a special\n * function to read it.\n */\nint\nTIFFReadEXIFDirectory(TIFF* tif, toff_t diroff)\n{\n\tsize_t exifFieldInfoCount;\n\tconst TIFFFieldInfo *exifFieldInfo =\n\t\t_TIFFGetExifFieldInfo(&exifFieldInfoCount);\n\treturn TIFFReadCustomDirectory(tif, diroff, exifFieldInfo,\n\t\t\t\t       exifFieldInfoCount);\n}\n\nstatic int\nEstimateStripByteCounts(TIFF* tif, TIFFDirEntry* dir, uint16 dircount)\n{\n\tstatic const char module[] = \"EstimateStripByteCounts\";\n\n\tTIFFDirEntry *dp;\n\tTIFFDirectory *td = &tif->tif_dir;\n\tuint32 strip;\n\n\tif (td->td_stripbytecount)\n\t\t_TIFFfree(td->td_stripbytecount);\n\ttd->td_stripbytecount = (uint32*)\n\t    _TIFFCheckMalloc(tif, td->td_nstrips, sizeof (uint32),\n\t\t\"for \\\"StripByteCounts\\\" array\");\n        if( td->td_stripbytecount == NULL )\n            return -1;\n\n\tif (td->td_compression != COMPRESSION_NONE) {\n\t\tuint32 space = (uint32)(sizeof (TIFFHeader)\n\t\t    + sizeof (uint16)\n\t\t    + (dircount * sizeof (TIFFDirEntry))\n\t\t    + sizeof (uint32));\n\t\ttoff_t filesize = TIFFGetFileSize(tif);\n\t\tuint16 n;\n\n\t\t/* calculate amount of space used by indirect values */\n\t\tfor (dp = dir, n = dircount; n > 0; n--, dp++)\n\t\t{\n\t\t\tuint32 cc = TIFFDataWidth((TIFFDataType) dp->tdir_type);\n\t\t\tif (cc == 0) {\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\"%s: Cannot determine size of unknown tag type %d\",\n\t\t\t\t\t  tif->tif_name, dp->tdir_type);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tcc = cc * dp->tdir_count;\n\t\t\tif (cc > sizeof (uint32))\n\t\t\t\tspace += cc;\n\t\t}\n\t\tspace = filesize - space;\n\t\tif (td->td_planarconfig == PLANARCONFIG_SEPARATE)\n\t\t\tspace /= td->td_samplesperpixel;\n\t\tfor (strip = 0; strip < td->td_nstrips; strip++)\n\t\t\ttd->td_stripbytecount[strip] = space;\n\t\t/*\n\t\t * This gross hack handles the case were the offset to\n\t\t * the last strip is past the place where we think the strip\n\t\t * should begin.  Since a strip of data must be contiguous,\n\t\t * it's safe to assume that we've overestimated the amount\n\t\t * of data in the strip and trim this number back accordingly.\n\t\t */ \n\t\tstrip--;\n\t\tif (((toff_t)(td->td_stripoffset[strip]+\n\t\t\t      td->td_stripbytecount[strip])) > filesize)\n\t\t\ttd->td_stripbytecount[strip] =\n\t\t\t    filesize - td->td_stripoffset[strip];\n\t} else if (isTiled(tif)) {\n\t\tuint32 bytespertile = TIFFTileSize(tif);\n\n\t\tfor (strip = 0; strip < td->td_nstrips; strip++)\n                    td->td_stripbytecount[strip] = bytespertile;\n\t} else {\n\t\tuint32 rowbytes = TIFFScanlineSize(tif);\n\t\tuint32 rowsperstrip = td->td_imagelength/td->td_stripsperimage;\n\t\tfor (strip = 0; strip < td->td_nstrips; strip++)\n\t\t\ttd->td_stripbytecount[strip] = rowbytes * rowsperstrip;\n\t}\n\tTIFFSetFieldBit(tif, FIELD_STRIPBYTECOUNTS);\n\tif (!TIFFFieldSet(tif, FIELD_ROWSPERSTRIP))\n\t\ttd->td_rowsperstrip = td->td_imagelength;\n\treturn 1;\n}\n\nstatic void\nMissingRequired(TIFF* tif, const char* tagname)\n{\n\tstatic const char module[] = \"MissingRequired\";\n\n\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t  \"%s: TIFF directory is missing required \\\"%s\\\" field\",\n\t\t  tif->tif_name, tagname);\n}\n\n/*\n * Check the directory offset against the list of already seen directory\n * offsets. This is a trick to prevent IFD looping. The one can create TIFF\n * file with looped directory pointers. We will maintain a list of already\n * seen directories and check every IFD offset against that list.\n */\nstatic int\nTIFFCheckDirOffset(TIFF* tif, toff_t diroff)\n{\n\tuint16 n;\n\n\tif (diroff == 0)\t\t\t/* no more directories */\n\t\treturn 0;\n\n\tfor (n = 0; n < tif->tif_dirnumber && tif->tif_dirlist; n++) {\n\t\tif (tif->tif_dirlist[n] == diroff)\n\t\t\treturn 0;\n\t}\n\n\ttif->tif_dirnumber++;\n\n\tif (tif->tif_dirnumber > tif->tif_dirlistsize) {\n\t\ttoff_t* new_dirlist;\n\n\t\t/*\n\t\t * XXX: Reduce memory allocation granularity of the dirlist\n\t\t * array.\n\t\t */\n\t\tnew_dirlist = (toff_t *)_TIFFCheckRealloc(tif,\n\t\t\t\t\t\t\t  tif->tif_dirlist,\n\t\t\t\t\t\t\t  tif->tif_dirnumber,\n\t\t\t\t\t\t\t  2 * sizeof(toff_t),\n\t\t\t\t\t\t\t  \"for IFD list\");\n\t\tif (!new_dirlist)\n\t\t\treturn 0;\n\t\ttif->tif_dirlistsize = 2 * tif->tif_dirnumber;\n\t\ttif->tif_dirlist = new_dirlist;\n\t}\n\n\ttif->tif_dirlist[tif->tif_dirnumber - 1] = diroff;\n\n\treturn 1;\n}\n\n/*\n * Check the count field of a directory entry against a known value.  The\n * caller is expected to skip/ignore the tag if there is a mismatch.\n */\nstatic int\nCheckDirCount(TIFF* tif, TIFFDirEntry* dir, uint32 count)\n{\n\tif (count > dir->tdir_count) {\n\t\tTIFFWarningExt(tif->tif_clientdata, tif->tif_name,\n\t\"incorrect count for field \\\"%s\\\" (%u, expecting %u); tag ignored\",\n\t\t    _TIFFFieldWithTag(tif, dir->tdir_tag)->field_name,\n\t\t    dir->tdir_count, count);\n\t\treturn (0);\n\t} else if (count < dir->tdir_count) {\n\t\tTIFFWarningExt(tif->tif_clientdata, tif->tif_name,\n\t\"incorrect count for field \\\"%s\\\" (%u, expecting %u); tag trimmed\",\n\t\t    _TIFFFieldWithTag(tif, dir->tdir_tag)->field_name,\n\t\t    dir->tdir_count, count);\n\t\treturn (1);\n\t}\n\treturn (1);\n}\n\n/*\n * Read IFD structure from the specified offset. If the pointer to\n * nextdiroff variable has been specified, read it too. Function returns a\n * number of fields in the directory or 0 if failed.\n */\nstatic uint16\nTIFFFetchDirectory(TIFF* tif, toff_t diroff, TIFFDirEntry **pdir,\n\t\t   toff_t *nextdiroff)\n{\n\tstatic const char module[] = \"TIFFFetchDirectory\";\n\n\tTIFFDirEntry *dir;\n\tuint16 dircount;\n\n\tassert(pdir);\n\n\ttif->tif_diroff = diroff;\n\tif (nextdiroff)\n\t\t*nextdiroff = 0;\n\tif (!isMapped(tif)) {\n\t\tif (!SeekOK(tif, tif->tif_diroff)) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t\"%s: Seek error accessing TIFF directory\",\n\t\t\t\ttif->tif_name);\n\t\t\treturn 0;\n\t\t}\n\t\tif (!ReadOK(tif, &dircount, sizeof (uint16))) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t\"%s: Can not read TIFF directory count\",\n\t\t\t\ttif->tif_name);\n\t\t\treturn 0;\n\t\t}\n\t\tif (tif->tif_flags & TIFF_SWAB)\n\t\t\tTIFFSwabShort(&dircount);\n\t\tdir = (TIFFDirEntry *)_TIFFCheckMalloc(tif, dircount,\n\t\t\t\t\t\tsizeof (TIFFDirEntry),\n\t\t\t\t\t\t\"to read TIFF directory\");\n\t\tif (dir == NULL)\n\t\t\treturn 0;\n\t\tif (!ReadOK(tif, dir, dircount*sizeof (TIFFDirEntry))) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t\"%.100s: Can not read TIFF directory\",\n\t\t\t\ttif->tif_name);\n\t\t\t_TIFFfree(dir);\n\t\t\treturn 0;\n\t\t}\n\t\t/*\n\t\t * Read offset to next directory for sequential scans if\n\t\t * needed.\n\t\t */\n\t\tif (nextdiroff)\n\t\t\t(void) ReadOK(tif, nextdiroff, sizeof(uint32));\n\t} else {\n\t\ttoff_t off = tif->tif_diroff;\n\n\t\t/*\n\t\t * Check for integer overflow when validating the dir_off,\n\t\t * otherwise a very high offset may cause an OOB read and\n\t\t * crash the client. Make two comparisons instead of\n\t\t *\n\t\t *  off + sizeof(uint16) > tif->tif_size\n\t\t *\n\t\t * to avoid overflow.\n\t\t */\n\t\tif (tif->tif_size < sizeof (uint16) ||\n\t\t    off > tif->tif_size - sizeof(uint16)) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t\"%s: Can not read TIFF directory count\",\n\t\t\t\ttif->tif_name);\n\t\t\treturn 0;\n\t\t} else {\n\t\t\t_TIFFmemcpy(&dircount, tif->tif_base + off,\n\t\t\t\t    sizeof(uint16));\n\t\t}\n\t\toff += sizeof (uint16);\n\t\tif (tif->tif_flags & TIFF_SWAB)\n\t\t\tTIFFSwabShort(&dircount);\n\t\tdir = (TIFFDirEntry *)_TIFFCheckMalloc(tif, dircount,\n\t\t\t\t\t\tsizeof(TIFFDirEntry),\n\t\t\t\t\t\t\"to read TIFF directory\");\n\t\tif (dir == NULL)\n\t\t\treturn 0;\n\t\tif (off + dircount * sizeof (TIFFDirEntry) > tif->tif_size) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t     \"%s: Can not read TIFF directory\",\n\t\t\t\t     tif->tif_name);\n\t\t\t_TIFFfree(dir);\n\t\t\treturn 0;\n\t\t} else {\n\t\t\t_TIFFmemcpy(dir, tif->tif_base + off,\n\t\t\t\t    dircount * sizeof(TIFFDirEntry));\n\t\t}\n\t\tif (nextdiroff) {\n\t\t\toff += dircount * sizeof (TIFFDirEntry);\n\t\t\tif (off + sizeof (uint32) <= tif->tif_size) {\n\t\t\t\t_TIFFmemcpy(nextdiroff, tif->tif_base + off,\n\t\t\t\t\t    sizeof (uint32));\n\t\t\t}\n\t\t}\n\t}\n\tif (nextdiroff && tif->tif_flags & TIFF_SWAB)\n\t\tTIFFSwabLong(nextdiroff);\n\t*pdir = dir;\n\treturn dircount;\n}\n\n/*\n * Fetch a contiguous directory item.\n */\nstatic tsize_t\nTIFFFetchData(TIFF* tif, TIFFDirEntry* dir, char* cp)\n{\n\tuint32 w = TIFFDataWidth((TIFFDataType) dir->tdir_type);\n\t/* \n\t * FIXME: butecount should have tsize_t type, but for now libtiff\n\t * defines tsize_t as a signed 32-bit integer and we are losing\n\t * ability to read arrays larger than 2^31 bytes. So we are using\n\t * uint32 instead of tsize_t here.\n\t */\n\tuint32 cc = dir->tdir_count * w;\n\n\t/* Check for overflow. */\n\tif (!dir->tdir_count || !w || cc / w != dir->tdir_count)\n\t\tgoto bad;\n\n\tif (!isMapped(tif)) {\n\t\tif (!SeekOK(tif, dir->tdir_offset))\n\t\t\tgoto bad;\n\t\tif (!ReadOK(tif, cp, cc))\n\t\t\tgoto bad;\n\t} else {\n\t\t/* Check for overflow. */\n\t\tif (dir->tdir_offset + cc < dir->tdir_offset\n\t\t    || dir->tdir_offset + cc < cc\n\t\t    || dir->tdir_offset + cc > tif->tif_size)\n\t\t\tgoto bad;\n\t\t_TIFFmemcpy(cp, tif->tif_base + dir->tdir_offset, cc);\n\t}\n\tif (tif->tif_flags & TIFF_SWAB) {\n\t\tswitch (dir->tdir_type) {\n\t\tcase TIFF_SHORT:\n\t\tcase TIFF_SSHORT:\n\t\t\tTIFFSwabArrayOfShort((uint16*) cp, dir->tdir_count);\n\t\t\tbreak;\n\t\tcase TIFF_LONG:\n\t\tcase TIFF_SLONG:\n\t\tcase TIFF_FLOAT:\n\t\t\tTIFFSwabArrayOfLong((uint32*) cp, dir->tdir_count);\n\t\t\tbreak;\n\t\tcase TIFF_RATIONAL:\n\t\tcase TIFF_SRATIONAL:\n\t\t\tTIFFSwabArrayOfLong((uint32*) cp, 2*dir->tdir_count);\n\t\t\tbreak;\n\t\tcase TIFF_DOUBLE:\n\t\t\tTIFFSwabArrayOfDouble((double*) cp, dir->tdir_count);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn (cc);\nbad:\n\tTIFFErrorExt(tif->tif_clientdata, tif->tif_name,\n\t\t     \"Error fetching data for field \\\"%s\\\"\",\n\t\t     _TIFFFieldWithTag(tif, dir->tdir_tag)->field_name);\n\treturn (tsize_t) 0;\n}\n\n/*\n * Fetch an ASCII item from the file.\n */\nstatic tsize_t\nTIFFFetchString(TIFF* tif, TIFFDirEntry* dir, char* cp)\n{\n\tif (dir->tdir_count <= 4) {\n\t\tuint32 l = dir->tdir_offset;\n\t\tif (tif->tif_flags & TIFF_SWAB)\n\t\t\tTIFFSwabLong(&l);\n\t\t_TIFFmemcpy(cp, &l, dir->tdir_count);\n\t\treturn (1);\n\t}\n\treturn (TIFFFetchData(tif, dir, cp));\n}\n\n/*\n * Convert numerator+denominator to float.\n */\nstatic int\ncvtRational(TIFF* tif, TIFFDirEntry* dir, uint32 num, uint32 denom, float* rv)\n{\n\tif (denom == 0) {\n\t\tTIFFErrorExt(tif->tif_clientdata, tif->tif_name,\n\t\t    \"%s: Rational with zero denominator (num = %u)\",\n\t\t    _TIFFFieldWithTag(tif, dir->tdir_tag)->field_name, num);\n\t\treturn (0);\n\t} else {\n\t\tif (dir->tdir_type == TIFF_RATIONAL)\n\t\t\t*rv = ((float)num / (float)denom);\n\t\telse\n\t\t\t*rv = ((float)(int32)num / (float)(int32)denom);\n\t\treturn (1);\n\t}\n}\n\n/*\n * Fetch a rational item from the file at offset off and return the value as a\n * floating point number.\n */\nstatic float\nTIFFFetchRational(TIFF* tif, TIFFDirEntry* dir)\n{\n\tuint32 l[2];\n\tfloat v;\n\n\treturn (!TIFFFetchData(tif, dir, (char *)l) ||\n\t    !cvtRational(tif, dir, l[0], l[1], &v) ? 1.0f : v);\n}\n\n/*\n * Fetch a single floating point value from the offset field and return it as\n * a native float.\n */\nstatic float\nTIFFFetchFloat(TIFF* tif, TIFFDirEntry* dir)\n{\n\tfloat v;\n\tint32 l = TIFFExtractData(tif, dir->tdir_type, dir->tdir_offset);\n        _TIFFmemcpy(&v, &l, sizeof(float));\n\tTIFFCvtIEEEFloatToNative(tif, 1, &v);\n\treturn (v);\n}\n\n/*\n * Fetch an array of BYTE or SBYTE values.\n */\nstatic int\nTIFFFetchByteArray(TIFF* tif, TIFFDirEntry* dir, uint8* v)\n{\n    if (dir->tdir_count <= 4) {\n        /*\n         * Extract data from offset field.\n         */\n        if (tif->tif_header.tiff_magic == TIFF_BIGENDIAN) {\n\t    if (dir->tdir_type == TIFF_SBYTE)\n                switch (dir->tdir_count) {\n                    case 4: v[3] = dir->tdir_offset & 0xff;\n                    case 3: v[2] = (dir->tdir_offset >> 8) & 0xff;\n                    case 2: v[1] = (dir->tdir_offset >> 16) & 0xff;\n\t\t    case 1: v[0] = dir->tdir_offset >> 24;\n                }\n\t    else\n                switch (dir->tdir_count) {\n                    case 4: v[3] = dir->tdir_offset & 0xff;\n                    case 3: v[2] = (dir->tdir_offset >> 8) & 0xff;\n                    case 2: v[1] = (dir->tdir_offset >> 16) & 0xff;\n\t\t    case 1: v[0] = dir->tdir_offset >> 24;\n                }\n\t} else {\n\t    if (dir->tdir_type == TIFF_SBYTE)\n                switch (dir->tdir_count) {\n                    case 4: v[3] = dir->tdir_offset >> 24;\n                    case 3: v[2] = (dir->tdir_offset >> 16) & 0xff;\n                    case 2: v[1] = (dir->tdir_offset >> 8) & 0xff;\n                    case 1: v[0] = dir->tdir_offset & 0xff;\n\t\t}\n\t    else\n                switch (dir->tdir_count) {\n                    case 4: v[3] = dir->tdir_offset >> 24;\n                    case 3: v[2] = (dir->tdir_offset >> 16) & 0xff;\n                    case 2: v[1] = (dir->tdir_offset >> 8) & 0xff;\n                    case 1: v[0] = dir->tdir_offset & 0xff;\n\t\t}\n\t}\n        return (1);\n    } else\n        return (TIFFFetchData(tif, dir, (char*) v) != 0);\t/* XXX */\n}\n\n/*\n * Fetch an array of SHORT or SSHORT values.\n */\nstatic int\nTIFFFetchShortArray(TIFF* tif, TIFFDirEntry* dir, uint16* v)\n{\n\tif (dir->tdir_count <= 2) {\n\t\tif (tif->tif_header.tiff_magic == TIFF_BIGENDIAN) {\n\t\t\tswitch (dir->tdir_count) {\n\t\t\tcase 2: v[1] = (uint16) (dir->tdir_offset & 0xffff);\n\t\t\tcase 1: v[0] = (uint16) (dir->tdir_offset >> 16);\n\t\t\t}\n\t\t} else {\n\t\t\tswitch (dir->tdir_count) {\n\t\t\tcase 2: v[1] = (uint16) (dir->tdir_offset >> 16);\n\t\t\tcase 1: v[0] = (uint16) (dir->tdir_offset & 0xffff);\n\t\t\t}\n\t\t}\n\t\treturn (1);\n\t} else\n\t\treturn (TIFFFetchData(tif, dir, (char *)v) != 0);\n}\n\n/*\n * Fetch a pair of SHORT or BYTE values. Some tags may have either BYTE\n * or SHORT type and this function works with both ones.\n */\nstatic int\nTIFFFetchShortPair(TIFF* tif, TIFFDirEntry* dir)\n{\n\t/*\n\t * Prevent overflowing the v stack arrays below by performing a sanity\n\t * check on tdir_count, this should never be greater than two.\n\t */\n\tif (dir->tdir_count > 2) {\n\t\tTIFFWarningExt(tif->tif_clientdata, tif->tif_name,\n\t\t\"unexpected count for field \\\"%s\\\", %u, expected 2; ignored\",\n\t\t\t_TIFFFieldWithTag(tif, dir->tdir_tag)->field_name,\n\t\t\tdir->tdir_count);\n\t\treturn 0;\n\t}\n\n\tswitch (dir->tdir_type) {\n\t\tcase TIFF_BYTE:\n\t\tcase TIFF_SBYTE:\n\t\t\t{\n\t\t\tuint8 v[4];\n\t\t\treturn TIFFFetchByteArray(tif, dir, v)\n\t\t\t\t&& TIFFSetField(tif, dir->tdir_tag, v[0], v[1]);\n\t\t\t}\n\t\tcase TIFF_SHORT:\n\t\tcase TIFF_SSHORT:\n\t\t\t{\n\t\t\tuint16 v[2];\n\t\t\treturn TIFFFetchShortArray(tif, dir, v)\n\t\t\t\t&& TIFFSetField(tif, dir->tdir_tag, v[0], v[1]);\n\t\t\t}\n\t\tdefault:\n\t\t\treturn 0;\n\t}\n}\n\n/*\n * Fetch an array of LONG or SLONG values.\n */\nstatic int\nTIFFFetchLongArray(TIFF* tif, TIFFDirEntry* dir, uint32* v)\n{\n\tif (dir->tdir_count == 1) {\n\t\tv[0] = dir->tdir_offset;\n\t\treturn (1);\n\t} else\n\t\treturn (TIFFFetchData(tif, dir, (char*) v) != 0);\n}\n\n/*\n * Fetch an array of RATIONAL or SRATIONAL values.\n */\nstatic int\nTIFFFetchRationalArray(TIFF* tif, TIFFDirEntry* dir, float* v)\n{\n\tint ok = 0;\n\tuint32* l;\n\n\tl = (uint32*)_TIFFCheckMalloc(tif,\n\t    dir->tdir_count, TIFFDataWidth((TIFFDataType) dir->tdir_type),\n\t    \"to fetch array of rationals\");\n\tif (l) {\n\t\tif (TIFFFetchData(tif, dir, (char *)l)) {\n\t\t\tuint32 i;\n\t\t\tfor (i = 0; i < dir->tdir_count; i++) {\n\t\t\t\tok = cvtRational(tif, dir,\n\t\t\t\t    l[2*i+0], l[2*i+1], &v[i]);\n\t\t\t\tif (!ok)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t_TIFFfree((char *)l);\n\t}\n\treturn (ok);\n}\n\n/*\n * Fetch an array of FLOAT values.\n */\nstatic int\nTIFFFetchFloatArray(TIFF* tif, TIFFDirEntry* dir, float* v)\n{\n\n\tif (dir->tdir_count == 1) {\n\t        union\n\t\t{\n\t\t  float  f;\n\t\t  uint32 i;\n\t\t} float_union;\n\n\t\tfloat_union.i=dir->tdir_offset;\n\t\tv[0]=float_union.f;\n\t\tTIFFCvtIEEEFloatToNative(tif, dir->tdir_count, v);\n\t\treturn (1);\n\t} else\tif (TIFFFetchData(tif, dir, (char*) v)) {\n\t\tTIFFCvtIEEEFloatToNative(tif, dir->tdir_count, v);\n\t\treturn (1);\n\t} else\n\t\treturn (0);\n}\n\n/*\n * Fetch an array of DOUBLE values.\n */\nstatic int\nTIFFFetchDoubleArray(TIFF* tif, TIFFDirEntry* dir, double* v)\n{\n\tif (TIFFFetchData(tif, dir, (char*) v)) {\n\t\tTIFFCvtIEEEDoubleToNative(tif, dir->tdir_count, v);\n\t\treturn (1);\n\t} else\n\t\treturn (0);\n}\n\n/*\n * Fetch an array of ANY values.  The actual values are returned as doubles\n * which should be able hold all the types.  Yes, there really should be an\n * tany_t to avoid this potential non-portability ...  Note in particular that\n * we assume that the double return value vector is large enough to read in\n * any fundamental type.  We use that vector as a buffer to read in the base\n * type vector and then convert it in place to double (from end to front of\n * course).\n */\nstatic int\nTIFFFetchAnyArray(TIFF* tif, TIFFDirEntry* dir, double* v)\n{\n\tint i;\n\n\tswitch (dir->tdir_type) {\n\tcase TIFF_BYTE:\n\tcase TIFF_SBYTE:\n\t\tif (!TIFFFetchByteArray(tif, dir, (uint8*) v))\n\t\t\treturn (0);\n\t\tif (dir->tdir_type == TIFF_BYTE) {\n\t\t\tuint8* vp = (uint8*) v;\n\t\t\tfor (i = dir->tdir_count-1; i >= 0; i--)\n\t\t\t\tv[i] = vp[i];\n\t\t} else {\n\t\t\tint8* vp = (int8*) v;\n\t\t\tfor (i = dir->tdir_count-1; i >= 0; i--)\n\t\t\t\tv[i] = vp[i];\n\t\t}\n\t\tbreak;\n\tcase TIFF_SHORT:\n\tcase TIFF_SSHORT:\n\t\tif (!TIFFFetchShortArray(tif, dir, (uint16*) v))\n\t\t\treturn (0);\n\t\tif (dir->tdir_type == TIFF_SHORT) {\n\t\t\tuint16* vp = (uint16*) v;\n\t\t\tfor (i = dir->tdir_count-1; i >= 0; i--)\n\t\t\t\tv[i] = vp[i];\n\t\t} else {\n\t\t\tint16* vp = (int16*) v;\n\t\t\tfor (i = dir->tdir_count-1; i >= 0; i--)\n\t\t\t\tv[i] = vp[i];\n\t\t}\n\t\tbreak;\n\tcase TIFF_LONG:\n\tcase TIFF_SLONG:\n\t\tif (!TIFFFetchLongArray(tif, dir, (uint32*) v))\n\t\t\treturn (0);\n\t\tif (dir->tdir_type == TIFF_LONG) {\n\t\t\tuint32* vp = (uint32*) v;\n\t\t\tfor (i = dir->tdir_count-1; i >= 0; i--)\n\t\t\t\tv[i] = vp[i];\n\t\t} else {\n\t\t\tint32* vp = (int32*) v;\n\t\t\tfor (i = dir->tdir_count-1; i >= 0; i--)\n\t\t\t\tv[i] = vp[i];\n\t\t}\n\t\tbreak;\n\tcase TIFF_RATIONAL:\n\tcase TIFF_SRATIONAL:\n\t\tif (!TIFFFetchRationalArray(tif, dir, (float*) v))\n\t\t\treturn (0);\n\t\t{ float* vp = (float*) v;\n\t\t  for (i = dir->tdir_count-1; i >= 0; i--)\n\t\t\tv[i] = vp[i];\n\t\t}\n\t\tbreak;\n\tcase TIFF_FLOAT:\n\t\tif (!TIFFFetchFloatArray(tif, dir, (float*) v))\n\t\t\treturn (0);\n\t\t{ float* vp = (float*) v;\n\t\t  for (i = dir->tdir_count-1; i >= 0; i--)\n\t\t\tv[i] = vp[i];\n\t\t}\n\t\tbreak;\n\tcase TIFF_DOUBLE:\n\t\treturn (TIFFFetchDoubleArray(tif, dir, (double*) v));\n\tdefault:\n\t\t/* TIFF_NOTYPE */\n\t\t/* TIFF_ASCII */\n\t\t/* TIFF_UNDEFINED */\n\t\tTIFFErrorExt(tif->tif_clientdata, tif->tif_name,\n\t\t\t     \"cannot read TIFF_ANY type %d for field \\\"%s\\\"\",\n\t\t\t     dir->tdir_type,\n\t\t\t     _TIFFFieldWithTag(tif, dir->tdir_tag)->field_name);\n\t\treturn (0);\n\t}\n\treturn (1);\n}\n\n/*\n * Fetch a tag that is not handled by special case code.\n */\nstatic int\nTIFFFetchNormalTag(TIFF* tif, TIFFDirEntry* dp)\n{\n\tstatic const char mesg[] = \"to fetch tag value\";\n\tint ok = 0;\n\tconst TIFFFieldInfo* fip = _TIFFFieldWithTag(tif, dp->tdir_tag);\n\n\tif (dp->tdir_count > 1) {\t\t/* array of values */\n\t\tchar* cp = NULL;\n\n\t\tswitch (dp->tdir_type) {\n\t\tcase TIFF_BYTE:\n\t\tcase TIFF_SBYTE:\n\t\t\tcp = (char *)_TIFFCheckMalloc(tif,\n\t\t\t    dp->tdir_count, sizeof (uint8), mesg);\n\t\t\tok = cp && TIFFFetchByteArray(tif, dp, (uint8*) cp);\n\t\t\tbreak;\n\t\tcase TIFF_SHORT:\n\t\tcase TIFF_SSHORT:\n\t\t\tcp = (char *)_TIFFCheckMalloc(tif,\n\t\t\t    dp->tdir_count, sizeof (uint16), mesg);\n\t\t\tok = cp && TIFFFetchShortArray(tif, dp, (uint16*) cp);\n\t\t\tbreak;\n\t\tcase TIFF_LONG:\n\t\tcase TIFF_SLONG:\n\t\t\tcp = (char *)_TIFFCheckMalloc(tif,\n\t\t\t    dp->tdir_count, sizeof (uint32), mesg);\n\t\t\tok = cp && TIFFFetchLongArray(tif, dp, (uint32*) cp);\n\t\t\tbreak;\n\t\tcase TIFF_RATIONAL:\n\t\tcase TIFF_SRATIONAL:\n\t\t\tcp = (char *)_TIFFCheckMalloc(tif,\n\t\t\t    dp->tdir_count, sizeof (float), mesg);\n\t\t\tok = cp && TIFFFetchRationalArray(tif, dp, (float*) cp);\n\t\t\tbreak;\n\t\tcase TIFF_FLOAT:\n\t\t\tcp = (char *)_TIFFCheckMalloc(tif,\n\t\t\t    dp->tdir_count, sizeof (float), mesg);\n\t\t\tok = cp && TIFFFetchFloatArray(tif, dp, (float*) cp);\n\t\t\tbreak;\n\t\tcase TIFF_DOUBLE:\n\t\t\tcp = (char *)_TIFFCheckMalloc(tif,\n\t\t\t    dp->tdir_count, sizeof (double), mesg);\n\t\t\tok = cp && TIFFFetchDoubleArray(tif, dp, (double*) cp);\n\t\t\tbreak;\n\t\tcase TIFF_ASCII:\n\t\tcase TIFF_UNDEFINED:\t\t/* bit of a cheat... */\n\t\t\t/*\n\t\t\t * Some vendors write strings w/o the trailing\n\t\t\t * NULL byte, so always append one just in case.\n\t\t\t */\n\t\t\tcp = (char *)_TIFFCheckMalloc(tif, dp->tdir_count + 1,\n\t\t\t\t\t\t      1, mesg);\n\t\t\tif( (ok = (cp && TIFFFetchString(tif, dp, cp))) != 0 )\n\t\t\t\tcp[dp->tdir_count] = '\\0';\t/* XXX */\n\t\t\tbreak;\n\t\t}\n\t\tif (ok) {\n\t\t\tok = (fip->field_passcount ?\n\t\t\t    TIFFSetField(tif, dp->tdir_tag, dp->tdir_count, cp)\n\t\t\t  : TIFFSetField(tif, dp->tdir_tag, cp));\n\t\t}\n\t\tif (cp != NULL)\n\t\t\t_TIFFfree(cp);\n\t} else if (CheckDirCount(tif, dp, 1)) {\t/* singleton value */\n\t\tswitch (dp->tdir_type) {\n\t\tcase TIFF_BYTE:\n\t\tcase TIFF_SBYTE:\n\t\tcase TIFF_SHORT:\n\t\tcase TIFF_SSHORT:\n\t\t\t/*\n\t\t\t * If the tag is also acceptable as a LONG or SLONG\n\t\t\t * then TIFFSetField will expect an uint32 parameter\n\t\t\t * passed to it (through varargs).  Thus, for machines\n\t\t\t * where sizeof (int) != sizeof (uint32) we must do\n\t\t\t * a careful check here.  It's hard to say if this\n\t\t\t * is worth optimizing.\n\t\t\t *\n\t\t\t * NB: We use TIFFFieldWithTag here knowing that\n\t\t\t *     it returns us the first entry in the table\n\t\t\t *     for the tag and that that entry is for the\n\t\t\t *     widest potential data type the tag may have.\n\t\t\t */\n\t\t\t{ TIFFDataType type = fip->field_type;\n\t\t\t  if (type != TIFF_LONG && type != TIFF_SLONG) {\n\t\t\t\tuint16 v = (uint16)\n\t\t\t   TIFFExtractData(tif, dp->tdir_type, dp->tdir_offset);\n\t\t\t\tok = (fip->field_passcount ?\n\t\t\t\t    TIFFSetField(tif, dp->tdir_tag, 1, &v)\n\t\t\t\t  : TIFFSetField(tif, dp->tdir_tag, v));\n\t\t\t\tbreak;\n\t\t\t  }\n\t\t\t}\n\t\t\t/* fall thru... */\n\t\tcase TIFF_LONG:\n\t\tcase TIFF_SLONG:\n\t\t\t{ uint32 v32 =\n\t\t    TIFFExtractData(tif, dp->tdir_type, dp->tdir_offset);\n\t\t\t  ok = (fip->field_passcount ? \n\t\t\t      TIFFSetField(tif, dp->tdir_tag, 1, &v32)\n\t\t\t    : TIFFSetField(tif, dp->tdir_tag, v32));\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_RATIONAL:\n\t\tcase TIFF_SRATIONAL:\n\t\tcase TIFF_FLOAT:\n\t\t\t{ float v = (dp->tdir_type == TIFF_FLOAT ? \n\t\t\t      TIFFFetchFloat(tif, dp)\n\t\t\t    : TIFFFetchRational(tif, dp));\n\t\t\t  ok = (fip->field_passcount ?\n\t\t\t      TIFFSetField(tif, dp->tdir_tag, 1, &v)\n\t\t\t    : TIFFSetField(tif, dp->tdir_tag, v));\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_DOUBLE:\n\t\t\t{ double v;\n\t\t\t  ok = (TIFFFetchDoubleArray(tif, dp, &v) &&\n\t\t\t    (fip->field_passcount ?\n\t\t\t      TIFFSetField(tif, dp->tdir_tag, 1, &v)\n\t\t\t    : TIFFSetField(tif, dp->tdir_tag, v))\n\t\t\t  );\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_ASCII:\n\t\tcase TIFF_UNDEFINED:\t\t/* bit of a cheat... */\n\t\t\t{ char c[2];\n\t\t\t  if( (ok = (TIFFFetchString(tif, dp, c) != 0)) != 0 ) {\n\t\t\t\tc[1] = '\\0';\t\t/* XXX paranoid */\n\t\t\t\tok = (fip->field_passcount ?\n\t\t\t\t\tTIFFSetField(tif, dp->tdir_tag, 1, c)\n\t\t\t\t      : TIFFSetField(tif, dp->tdir_tag, c));\n\t\t\t  }\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn (ok);\n}\n\n#define\tNITEMS(x)\t(sizeof (x) / sizeof (x[0]))\n/*\n * Fetch samples/pixel short values for \n * the specified tag and verify that\n * all values are the same.\n */\nstatic int\nTIFFFetchPerSampleShorts(TIFF* tif, TIFFDirEntry* dir, uint16* pl)\n{\n    uint16 samples = tif->tif_dir.td_samplesperpixel;\n    int status = 0;\n\n    if (CheckDirCount(tif, dir, (uint32) samples)) {\n        uint16 buf[10];\n        uint16* v = buf;\n\n        if (dir->tdir_count > NITEMS(buf))\n            v = (uint16*) _TIFFCheckMalloc(tif, dir->tdir_count, sizeof(uint16),\n                                      \"to fetch per-sample values\");\n        if (v && TIFFFetchShortArray(tif, dir, v)) {\n            uint16 i;\n            int check_count = dir->tdir_count;\n            if( samples < check_count )\n                check_count = samples;\n\n            for (i = 1; i < check_count; i++)\n                if (v[i] != v[0]) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, tif->tif_name,\n                \"Cannot handle different per-sample values for field \\\"%s\\\"\",\n\t\t\t_TIFFFieldWithTag(tif, dir->tdir_tag)->field_name);\n\t\t\tgoto bad;\n                }\n            *pl = v[0];\n            status = 1;\n        }\n      bad:\n        if (v && v != buf)\n            _TIFFfree(v);\n    }\n    return (status);\n}\n\n/*\n * Fetch samples/pixel long values for \n * the specified tag and verify that\n * all values are the same.\n */\nstatic int\nTIFFFetchPerSampleLongs(TIFF* tif, TIFFDirEntry* dir, uint32* pl)\n{\n    uint16 samples = tif->tif_dir.td_samplesperpixel;\n    int status = 0;\n\n    if (CheckDirCount(tif, dir, (uint32) samples)) {\n        uint32 buf[10];\n        uint32* v = buf;\n\n        if (dir->tdir_count > NITEMS(buf))\n            v = (uint32*) _TIFFCheckMalloc(tif, dir->tdir_count, sizeof(uint32),\n                                      \"to fetch per-sample values\");\n        if (v && TIFFFetchLongArray(tif, dir, v)) {\n            uint16 i;\n            int check_count = dir->tdir_count;\n\n            if( samples < check_count )\n                check_count = samples;\n            for (i = 1; i < check_count; i++)\n                if (v[i] != v[0]) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, tif->tif_name,\n                \"Cannot handle different per-sample values for field \\\"%s\\\"\",\n\t\t\t_TIFFFieldWithTag(tif, dir->tdir_tag)->field_name);\n\t\t\tgoto bad;\n                }\n            *pl = v[0];\n            status = 1;\n        }\n      bad:\n        if (v && v != buf)\n            _TIFFfree(v);\n    }\n    return (status);\n}\n\n/*\n * Fetch samples/pixel ANY values for the specified tag and verify that all\n * values are the same.\n */\nstatic int\nTIFFFetchPerSampleAnys(TIFF* tif, TIFFDirEntry* dir, double* pl)\n{\n    uint16 samples = tif->tif_dir.td_samplesperpixel;\n    int status = 0;\n\n    if (CheckDirCount(tif, dir, (uint32) samples)) {\n        double buf[10];\n        double* v = buf;\n\n        if (dir->tdir_count > NITEMS(buf))\n            v = (double*) _TIFFCheckMalloc(tif, dir->tdir_count, sizeof (double),\n                                      \"to fetch per-sample values\");\n        if (v && TIFFFetchAnyArray(tif, dir, v)) {\n            uint16 i;\n            int check_count = dir->tdir_count;\n            if( samples < check_count )\n                check_count = samples;\n\n            for (i = 1; i < check_count; i++)\n                if (v[i] != v[0]) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, tif->tif_name,\n\t\t\"Cannot handle different per-sample values for field \\\"%s\\\"\",\n\t\t\t_TIFFFieldWithTag(tif, dir->tdir_tag)->field_name);\n\t\t\tgoto bad;\n                }\n            *pl = v[0];\n            status = 1;\n        }\n      bad:\n        if (v && v != buf)\n            _TIFFfree(v);\n    }\n    return (status);\n}\n#undef NITEMS\n\n/*\n * Fetch a set of offsets or lengths.\n * While this routine says \"strips\", in fact it's also used for tiles.\n */\nstatic int\nTIFFFetchStripThing(TIFF* tif, TIFFDirEntry* dir, long nstrips, uint32** lpp)\n{\n\tregister uint32* lp;\n\tint status;\n\n        CheckDirCount(tif, dir, (uint32) nstrips);\n\n\t/*\n\t * Allocate space for strip information.\n\t */\n\tif (*lpp == NULL &&\n\t    (*lpp = (uint32 *)_TIFFCheckMalloc(tif,\n\t      nstrips, sizeof (uint32), \"for strip array\")) == NULL)\n\t\treturn (0);\n\tlp = *lpp;\n        _TIFFmemset( lp, 0, sizeof(uint32) * nstrips );\n\n\tif (dir->tdir_type == (int)TIFF_SHORT) {\n\t\t/*\n\t\t * Handle uint16->uint32 expansion.\n\t\t */\n\t\tuint16* dp = (uint16*) _TIFFCheckMalloc(tif,\n\t\t    dir->tdir_count, sizeof (uint16), \"to fetch strip tag\");\n\t\tif (dp == NULL)\n\t\t\treturn (0);\n\t\tif( (status = TIFFFetchShortArray(tif, dir, dp)) != 0 ) {\n                    int i;\n                    \n                    for( i = 0; i < nstrips && i < (int) dir->tdir_count; i++ )\n                    {\n                        lp[i] = dp[i];\n                    }\n\t\t}\n\t\t_TIFFfree((char*) dp);\n\n        } else if( nstrips != (int) dir->tdir_count ) {\n            /* Special case to correct length */\n\n            uint32* dp = (uint32*) _TIFFCheckMalloc(tif,\n\t\t    dir->tdir_count, sizeof (uint32), \"to fetch strip tag\");\n            if (dp == NULL)\n                return (0);\n\n            status = TIFFFetchLongArray(tif, dir, dp);\n            if( status != 0 ) {\n                int i;\n\n                for( i = 0; i < nstrips && i < (int) dir->tdir_count; i++ )\n                {\n                    lp[i] = dp[i];\n                }\n            }\n\n            _TIFFfree( (char *) dp );\n\t} else\n            status = TIFFFetchLongArray(tif, dir, lp);\n        \n\treturn (status);\n}\n\n/*\n * Fetch and set the RefBlackWhite tag.\n */\nstatic int\nTIFFFetchRefBlackWhite(TIFF* tif, TIFFDirEntry* dir)\n{\n\tstatic const char mesg[] = \"for \\\"ReferenceBlackWhite\\\" array\";\n\tchar* cp;\n\tint ok;\n\n\tif (dir->tdir_type == TIFF_RATIONAL)\n\t\treturn (TIFFFetchNormalTag(tif, dir));\n\t/*\n\t * Handle LONG's for backward compatibility.\n\t */\n\tcp = (char *)_TIFFCheckMalloc(tif, dir->tdir_count,\n\t\t\t\t      sizeof (uint32), mesg);\n\tif( (ok = (cp && TIFFFetchLongArray(tif, dir, (uint32*) cp))) != 0) {\n\t\tfloat* fp = (float*)\n\t\t    _TIFFCheckMalloc(tif, dir->tdir_count, sizeof (float), mesg);\n\t\tif( (ok = (fp != NULL)) != 0 ) {\n\t\t\tuint32 i;\n\t\t\tfor (i = 0; i < dir->tdir_count; i++)\n\t\t\t\tfp[i] = (float)((uint32*) cp)[i];\n\t\t\tok = TIFFSetField(tif, dir->tdir_tag, fp);\n\t\t\t_TIFFfree((char*) fp);\n\t\t}\n\t}\n\tif (cp)\n\t\t_TIFFfree(cp);\n\treturn (ok);\n}\n\n/*\n * Fetch and set the SubjectDistance EXIF tag.\n */\nstatic int\nTIFFFetchSubjectDistance(TIFF* tif, TIFFDirEntry* dir)\n{\n\tuint32 l[2];\n\tfloat v;\n\tint ok = 0;\n\n    if( dir->tdir_count != 1 || dir->tdir_type != TIFF_RATIONAL )\n    {\n\t\tTIFFWarningExt(tif->tif_clientdata, tif->tif_name,\n                       \"incorrect count or type for SubjectDistance, tag ignored\" );\n\t\treturn (0);\n    }\n\n\tif (TIFFFetchData(tif, dir, (char *)l)\n\t    && cvtRational(tif, dir, l[0], l[1], &v)) {\n\t\t/*\n\t\t * XXX: Numerator 0xFFFFFFFF means that we have infinite\n\t\t * distance. Indicate that with a negative floating point\n\t\t * SubjectDistance value.\n\t\t */\n\t\tok = TIFFSetField(tif, dir->tdir_tag,\n\t\t\t\t  (l[0] != 0xFFFFFFFF) ? v : -v);\n\t}\n\n\treturn ok;\n}\n\n/*\n * Replace a single strip (tile) of uncompressed data by multiple strips\n * (tiles), each approximately STRIP_SIZE_DEFAULT bytes. This is useful for\n * dealing with large images or for dealing with machines with a limited\n * amount memory.\n */\nstatic void\nChopUpSingleUncompressedStrip(TIFF* tif)\n{\n\tregister TIFFDirectory *td = &tif->tif_dir;\n\tuint32 bytecount = td->td_stripbytecount[0];\n\tuint32 offset = td->td_stripoffset[0];\n\ttsize_t rowbytes = TIFFVTileSize(tif, 1), stripbytes;\n\ttstrip_t strip, nstrips, rowsperstrip;\n\tuint32* newcounts;\n\tuint32* newoffsets;\n\n\t/*\n\t * Make the rows hold at least one scanline, but fill specified amount\n\t * of data if possible.\n\t */\n\tif (rowbytes > STRIP_SIZE_DEFAULT) {\n\t\tstripbytes = rowbytes;\n\t\trowsperstrip = 1;\n\t} else if (rowbytes > 0 ) {\n\t\trowsperstrip = STRIP_SIZE_DEFAULT / rowbytes;\n\t\tstripbytes = rowbytes * rowsperstrip;\n\t}\n        else\n            return;\n\n\t/* \n\t * never increase the number of strips in an image\n\t */\n\tif (rowsperstrip >= td->td_rowsperstrip)\n\t\treturn;\n\tnstrips = (tstrip_t) TIFFhowmany(bytecount, stripbytes);\n        if( nstrips == 0 ) /* something is wonky, do nothing. */\n            return;\n\n\tnewcounts = (uint32*) _TIFFCheckMalloc(tif, nstrips, sizeof (uint32),\n\t\t\t\t\"for chopped \\\"StripByteCounts\\\" array\");\n\tnewoffsets = (uint32*) _TIFFCheckMalloc(tif, nstrips, sizeof (uint32),\n\t\t\t\t\"for chopped \\\"StripOffsets\\\" array\");\n\tif (newcounts == NULL || newoffsets == NULL) {\n\t        /*\n\t\t * Unable to allocate new strip information, give up and use\n\t\t * the original one strip information.\n\t\t */\n\t\tif (newcounts != NULL)\n\t\t\t_TIFFfree(newcounts);\n\t\tif (newoffsets != NULL)\n\t\t\t_TIFFfree(newoffsets);\n\t\treturn;\n\t}\n\t/*\n\t * Fill the strip information arrays with new bytecounts and offsets\n\t * that reflect the broken-up format.\n\t */\n\tfor (strip = 0; strip < nstrips; strip++) {\n\t\tif ((uint32)stripbytes > bytecount)\n\t\t\tstripbytes = bytecount;\n\t\tnewcounts[strip] = stripbytes;\n\t\tnewoffsets[strip] = offset;\n\t\toffset += stripbytes;\n\t\tbytecount -= stripbytes;\n\t}\n\t/*\n\t * Replace old single strip info with multi-strip info.\n\t */\n\ttd->td_stripsperimage = td->td_nstrips = nstrips;\n\tTIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, rowsperstrip);\n\n\t_TIFFfree(td->td_stripbytecount);\n\t_TIFFfree(td->td_stripoffset);\n\ttd->td_stripbytecount = newcounts;\n\ttd->td_stripoffset = newoffsets;\n\ttd->td_stripbytecountsorted = 1;\n}\n\n/* vim: set ts=8 sts=8 sw=8 noet: */\n/*\n * Local Variables:\n * mode: c\n * c-basic-offset: 8\n * fill-column: 78\n * End:\n */\n", "/* $Id: tif_ojpeg.c,v 1.24.2.6 2010-06-08 23:29:51 bfriesen Exp $ */\n\n/* WARNING: The type of JPEG encapsulation defined by the TIFF Version 6.0\n   specification is now totally obsolete and deprecated for new applications and\n   images. This file was was created solely in order to read unconverted images\n   still present on some users' computer systems. It will never be extended\n   to write such files. Writing new-style JPEG compressed TIFFs is implemented\n   in tif_jpeg.c.\n\n   The code is carefully crafted to robustly read all gathered JPEG-in-TIFF\n   testfiles, and anticipate as much as possible all other... But still, it may\n   fail on some. If you encounter problems, please report them on the TIFF\n   mailing list and/or to Joris Van Damme <info@awaresystems.be>.\n\n   Please read the file called \"TIFF Technical Note #2\" if you need to be\n   convinced this compression scheme is bad and breaks TIFF. That document\n   is linked to from the LibTiff site <http://www.remotesensing.org/libtiff/>\n   and from AWare Systems' TIFF section\n   <http://www.awaresystems.be/imaging/tiff.html>. It is also absorbed\n   in Adobe's specification supplements, marked \"draft\" up to this day, but\n   supported by the TIFF community.\n\n   This file interfaces with Release 6B of the JPEG Library written by the\n   Independent JPEG Group. Previous versions of this file required a hack inside\n   the LibJpeg library. This version no longer requires that. Remember to\n   remove the hack if you update from the old version.\n\n   Copyright (c) Joris Van Damme <info@awaresystems.be>\n   Copyright (c) AWare Systems <http://www.awaresystems.be/>\n\n   The licence agreement for this file is the same as the rest of the LibTiff\n   library.\n\n   IN NO EVENT SHALL JORIS VAN DAMME OR AWARE SYSTEMS BE LIABLE FOR\n   ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND,\n   OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,\n   WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF\n   LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE\n   OF THIS SOFTWARE.\n\n   Joris Van Damme and/or AWare Systems may be available for custom\n   developement. If you like what you see, and need anything similar or related,\n   contact <info@awaresystems.be>.\n*/\n\n/* What is what, and what is not?\n\n   This decoder starts with an input stream, that is essentially the JpegInterchangeFormat\n   stream, if any, followed by the strile data, if any. This stream is read in\n   OJPEGReadByte and related functions.\n\n   It analyzes the start of this stream, until it encounters non-marker data, i.e.\n   compressed image data. Some of the header markers it sees have no actual content,\n   like the SOI marker, and APP/COM markers that really shouldn't even be there. Some\n   other markers do have content, and the valuable bits and pieces of information\n   in these markers are saved, checking all to verify that the stream is more or\n   less within expected bounds. This happens inside the OJPEGReadHeaderInfoSecStreamXxx\n   functions.\n\n   Some OJPEG imagery contains no valid JPEG header markers. This situation is picked\n   up on if we've seen no SOF marker when we're at the start of the compressed image\n   data. In this case, the tables are read from JpegXxxTables tags, and the other\n   bits and pieces of information is initialized to its most basic value. This is\n   implemented in the OJPEGReadHeaderInfoSecTablesXxx functions.\n\n   When this is complete, a good and valid JPEG header can be assembled, and this is\n   passed through to LibJpeg. When that's done, the remainder of the input stream, i.e.\n   the compressed image data, can be passed through unchanged. This is done in\n   OJPEGWriteStream functions.\n\n   LibTiff rightly expects to know the subsampling values before decompression. Just like\n   in new-style JPEG-in-TIFF, though, or even more so, actually, the YCbCrsubsampling\n   tag is notoriously unreliable. To correct these tag values with the ones inside\n   the JPEG stream, the first part of the input stream is pre-scanned in\n   OJPEGSubsamplingCorrect, making no note of any other data, reporting no warnings\n   or errors, up to the point where either these values are read, or it's clear they\n   aren't there. This means that some of the data is read twice, but we feel speed\n   in correcting these values is important enough to warrant this sacrifice. Allthough\n   there is currently no define or other configuration mechanism to disable this behaviour,\n   the actual header scanning is build to robustly respond with error report if it\n   should encounter an uncorrected mismatch of subsampling values. See\n   OJPEGReadHeaderInfoSecStreamSof.\n\n   The restart interval and restart markers are the most tricky part... The restart\n   interval can be specified in a tag. It can also be set inside the input JPEG stream.\n   It can be used inside the input JPEG stream. If reading from strile data, we've\n   consistenly discovered the need to insert restart markers in between the different\n   striles, as is also probably the most likely interpretation of the original TIFF 6.0\n   specification. With all this setting of interval, and actual use of markers that is not\n   predictable at the time of valid JPEG header assembly, the restart thing may turn\n   out the Achilles heel of this implementation. Fortunately, most OJPEG writer vendors\n   succeed in reading back what they write, which may be the reason why we've been able\n   to discover ways that seem to work.\n\n   Some special provision is made for planarconfig separate OJPEG files. These seem\n   to consistently contain header info, a SOS marker, a plane, SOS marker, plane, SOS,\n   and plane. This may or may not be a valid JPEG configuration, we don't know and don't\n   care. We want LibTiff to be able to access the planes individually, without huge\n   buffering inside LibJpeg, anyway. So we compose headers to feed to LibJpeg, in this\n   case, that allow us to pass a single plane such that LibJpeg sees a valid\n   single-channel JPEG stream. Locating subsequent SOS markers, and thus subsequent\n   planes, is done inside OJPEGReadSecondarySos.\n\n   The benefit of the scheme is... that it works, basically. We know of no other that\n   does. It works without checking software tag, or otherwise going about things in an\n   OJPEG flavor specific manner. Instead, it is a single scheme, that covers the cases\n   with and without JpegInterchangeFormat, with and without striles, with part of\n   the header in JpegInterchangeFormat and remainder in first strile, etc. It is forgiving\n   and robust, may likely work with OJPEG flavors we've not seen yet, and makes most out\n   of the data.\n\n   Another nice side-effect is that a complete JPEG single valid stream is build if\n   planarconfig is not separate (vast majority). We may one day use that to build\n   converters to JPEG, and/or to new-style JPEG compression inside TIFF.\n\n   A dissadvantage is the lack of random access to the individual striles. This is the\n   reason for much of the complicated restart-and-position stuff inside OJPEGPreDecode.\n   Applications would do well accessing all striles in order, as this will result in\n   a single sequential scan of the input stream, and no restarting of LibJpeg decoding\n   session.\n*/\n\n\n#include \"tiffiop.h\"\n#ifdef OJPEG_SUPPORT\n\n/* Configuration defines here are:\n * JPEG_ENCAP_EXTERNAL: The normal way to call libjpeg, uses longjump. In some environments,\n * \tlike eg LibTiffDelphi, this is not possible. For this reason, the actual calls to\n * \tlibjpeg, with longjump stuff, are encapsulated in dedicated functions. When\n * \tJPEG_ENCAP_EXTERNAL is defined, these encapsulating functions are declared external\n * \tto this unit, and can be defined elsewhere to use stuff other then longjump.\n * \tThe default mode, without JPEG_ENCAP_EXTERNAL, implements the call encapsulators\n * \there, internally, with normal longjump.\n * SETJMP, LONGJMP, JMP_BUF: On some machines/environments a longjump equivalent is\n * \tconviniently available, but still it may be worthwhile to use _setjmp or sigsetjmp\n * \tin place of plain setjmp. These macros will make it easier. It is useless\n * \tto fiddle with these if you define JPEG_ENCAP_EXTERNAL.\n * OJPEG_BUFFER: Define the size of the desired buffer here. Should be small enough so as to guarantee\n * \tinstant processing, optimal streaming and optimal use of processor cache, but also big\n * \tenough so as to not result in significant call overhead. It should be at least a few\n * \tbytes to accomodate some structures (this is verified in asserts), but it would not be\n * \tsensible to make it this small anyway, and it should be at most 64K since it is indexed\n * \twith uint16. We recommend 2K.\n * EGYPTIANWALK: You could also define EGYPTIANWALK here, but it is not used anywhere and has\n * \tabsolutely no effect. That is why most people insist the EGYPTIANWALK is a bit silly.\n */\n\n/* #define LIBJPEG_ENCAP_EXTERNAL */\n#define SETJMP(jbuf) setjmp(jbuf)\n#define LONGJMP(jbuf,code) longjmp(jbuf,code)\n#define JMP_BUF jmp_buf\n#define OJPEG_BUFFER 2048\n/* define EGYPTIANWALK */\n\n#define JPEG_MARKER_SOF0 0xC0\n#define JPEG_MARKER_SOF1 0xC1\n#define JPEG_MARKER_SOF3 0xC3\n#define JPEG_MARKER_DHT 0xC4\n#define JPEG_MARKER_RST0 0XD0\n#define JPEG_MARKER_SOI 0xD8\n#define JPEG_MARKER_EOI 0xD9\n#define JPEG_MARKER_SOS 0xDA\n#define JPEG_MARKER_DQT 0xDB\n#define JPEG_MARKER_DRI 0xDD\n#define JPEG_MARKER_APP0 0xE0\n#define JPEG_MARKER_COM 0xFE\n\n#define FIELD_OJPEG_JPEGINTERCHANGEFORMAT (FIELD_CODEC+0)\n#define FIELD_OJPEG_JPEGINTERCHANGEFORMATLENGTH (FIELD_CODEC+1)\n#define FIELD_OJPEG_JPEGQTABLES (FIELD_CODEC+2)\n#define FIELD_OJPEG_JPEGDCTABLES (FIELD_CODEC+3)\n#define FIELD_OJPEG_JPEGACTABLES (FIELD_CODEC+4)\n#define FIELD_OJPEG_JPEGPROC (FIELD_CODEC+5)\n#define FIELD_OJPEG_JPEGRESTARTINTERVAL (FIELD_CODEC+6)\n#define FIELD_OJPEG_COUNT 7\n\nstatic const TIFFFieldInfo ojpeg_field_info[] = {\n\t{TIFFTAG_JPEGIFOFFSET,1,1,TIFF_LONG,FIELD_OJPEG_JPEGINTERCHANGEFORMAT,TRUE,FALSE,\"JpegInterchangeFormat\"},\n\t{TIFFTAG_JPEGIFBYTECOUNT,1,1,TIFF_LONG,FIELD_OJPEG_JPEGINTERCHANGEFORMATLENGTH,TRUE,FALSE,\"JpegInterchangeFormatLength\"},\n\t{TIFFTAG_JPEGQTABLES,TIFF_VARIABLE,TIFF_VARIABLE,TIFF_LONG,FIELD_OJPEG_JPEGQTABLES,FALSE,TRUE,\"JpegQTables\"},\n\t{TIFFTAG_JPEGDCTABLES,TIFF_VARIABLE,TIFF_VARIABLE,TIFF_LONG,FIELD_OJPEG_JPEGDCTABLES,FALSE,TRUE,\"JpegDcTables\"},\n\t{TIFFTAG_JPEGACTABLES,TIFF_VARIABLE,TIFF_VARIABLE,TIFF_LONG,FIELD_OJPEG_JPEGACTABLES,FALSE,TRUE,\"JpegAcTables\"},\n\t{TIFFTAG_JPEGPROC,1,1,TIFF_SHORT,FIELD_OJPEG_JPEGPROC,FALSE,FALSE,\"JpegProc\"},\n\t{TIFFTAG_JPEGRESTARTINTERVAL,1,1,TIFF_SHORT,FIELD_OJPEG_JPEGRESTARTINTERVAL,FALSE,FALSE,\"JpegRestartInterval\"},\n};\n\n#ifndef LIBJPEG_ENCAP_EXTERNAL\n#include <setjmp.h>\n#endif\n\n#include \"../jpeg/jpeglib.h\"\n#include \"../jpeg/jerror.h\"\n\ntypedef struct jpeg_error_mgr jpeg_error_mgr;\ntypedef struct jpeg_common_struct jpeg_common_struct;\ntypedef struct jpeg_decompress_struct jpeg_decompress_struct;\ntypedef struct jpeg_source_mgr jpeg_source_mgr;\n\ntypedef enum {\n\tosibsNotSetYet,\n\tosibsJpegInterchangeFormat,\n\tosibsStrile,\n\tosibsEof\n} OJPEGStateInBufferSource;\n\ntypedef enum {\n\tososSoi,\n\tososQTable0,ososQTable1,ososQTable2,ososQTable3,\n\tososDcTable0,ososDcTable1,ososDcTable2,ososDcTable3,\n\tososAcTable0,ososAcTable1,ososAcTable2,ososAcTable3,\n\tososDri,\n\tososSof,\n\tososSos,\n\tososCompressed,\n\tososRst,\n\tososEoi\n} OJPEGStateOutState;\n\ntypedef struct {\n\tTIFF* tif;\n\t#ifndef LIBJPEG_ENCAP_EXTERNAL\n\tJMP_BUF exit_jmpbuf;\n\t#endif\n\tTIFFVGetMethod vgetparent;\n\tTIFFVSetMethod vsetparent;\n\ttoff_t file_size;\n\tuint32 image_width;\n\tuint32 image_length;\n\tuint32 strile_width;\n\tuint32 strile_length;\n\tuint32 strile_length_total;\n\tuint8 samples_per_pixel;\n\tuint8 plane_sample_offset;\n\tuint8 samples_per_pixel_per_plane;\n\ttoff_t jpeg_interchange_format;\n\ttoff_t jpeg_interchange_format_length;\n\tuint8 jpeg_proc;\n\tuint8 subsamplingcorrect;\n\tuint8 subsamplingcorrect_done;\n\tuint8 subsampling_tag;\n\tuint8 subsampling_hor;\n\tuint8 subsampling_ver;\n\tuint8 subsampling_force_desubsampling_inside_decompression;\n\tuint8 qtable_offset_count;\n\tuint8 dctable_offset_count;\n\tuint8 actable_offset_count;\n\ttoff_t qtable_offset[3];\n\ttoff_t dctable_offset[3];\n\ttoff_t actable_offset[3];\n\tuint8* qtable[4];\n\tuint8* dctable[4];\n\tuint8* actable[4];\n\tuint16 restart_interval;\n\tuint8 restart_index;\n\tuint8 sof_log;\n\tuint8 sof_marker_id;\n\tuint32 sof_x;\n\tuint32 sof_y;\n\tuint8 sof_c[3];\n\tuint8 sof_hv[3];\n\tuint8 sof_tq[3];\n\tuint8 sos_cs[3];\n\tuint8 sos_tda[3];\n\tstruct {\n\t\tuint8 log;\n\t\tOJPEGStateInBufferSource in_buffer_source;\n\t\ttstrile_t in_buffer_next_strile;\n\t\ttoff_t in_buffer_file_pos;\n\t\ttoff_t in_buffer_file_togo;\n\t} sos_end[3];\n\tuint8 readheader_done;\n\tuint8 writeheader_done;\n\ttsample_t write_cursample;\n\ttstrile_t write_curstrile;\n\tuint8 libjpeg_session_active;\n\tuint8 libjpeg_jpeg_query_style;\n\tjpeg_error_mgr libjpeg_jpeg_error_mgr;\n\tjpeg_decompress_struct libjpeg_jpeg_decompress_struct;\n\tjpeg_source_mgr libjpeg_jpeg_source_mgr;\n\tuint8 subsampling_convert_log;\n\tuint32 subsampling_convert_ylinelen;\n\tuint32 subsampling_convert_ylines;\n\tuint32 subsampling_convert_clinelen;\n\tuint32 subsampling_convert_clines;\n\tuint32 subsampling_convert_ybuflen;\n\tuint32 subsampling_convert_cbuflen;\n\tuint32 subsampling_convert_ycbcrbuflen;\n\tuint8* subsampling_convert_ycbcrbuf;\n\tuint8* subsampling_convert_ybuf;\n\tuint8* subsampling_convert_cbbuf;\n\tuint8* subsampling_convert_crbuf;\n\tuint32 subsampling_convert_ycbcrimagelen;\n\tuint8** subsampling_convert_ycbcrimage;\n\tuint32 subsampling_convert_clinelenout;\n\tuint32 subsampling_convert_state;\n\tuint32 bytes_per_line;   /* if the codec outputs subsampled data, a 'line' in bytes_per_line */\n\tuint32 lines_per_strile; /* and lines_per_strile means subsampling_ver desubsampled rows     */\n\tOJPEGStateInBufferSource in_buffer_source;\n\ttstrile_t in_buffer_next_strile;\n\ttstrile_t in_buffer_strile_count;\n\ttoff_t in_buffer_file_pos;\n\tuint8 in_buffer_file_pos_log;\n\ttoff_t in_buffer_file_togo;\n\tuint16 in_buffer_togo;\n\tuint8* in_buffer_cur;\n\tuint8 in_buffer[OJPEG_BUFFER];\n\tOJPEGStateOutState out_state;\n\tuint8 out_buffer[OJPEG_BUFFER];\n\tuint8* skip_buffer;\n} OJPEGState;\n\nstatic int OJPEGVGetField(TIFF* tif, ttag_t tag, va_list ap);\nstatic int OJPEGVSetField(TIFF* tif, ttag_t tag, va_list ap);\nstatic void OJPEGPrintDir(TIFF* tif, FILE* fd, long flags);\n\nstatic int OJPEGSetupDecode(TIFF* tif);\nstatic int OJPEGPreDecode(TIFF* tif, tsample_t s);\nstatic int OJPEGPreDecodeSkipRaw(TIFF* tif);\nstatic int OJPEGPreDecodeSkipScanlines(TIFF* tif);\nstatic int OJPEGDecode(TIFF* tif, tidata_t buf, tsize_t cc, tsample_t s);\nstatic int OJPEGDecodeRaw(TIFF* tif, tidata_t buf, tsize_t cc);\nstatic int OJPEGDecodeScanlines(TIFF* tif, tidata_t buf, tsize_t cc);\nstatic void OJPEGPostDecode(TIFF* tif, tidata_t buf, tsize_t cc);\nstatic int OJPEGSetupEncode(TIFF* tif);\nstatic int OJPEGPreEncode(TIFF* tif, tsample_t s);\nstatic int OJPEGEncode(TIFF* tif, tidata_t buf, tsize_t cc, tsample_t s);\nstatic int OJPEGPostEncode(TIFF* tif);\nstatic void OJPEGCleanup(TIFF* tif);\n\nstatic void OJPEGSubsamplingCorrect(TIFF* tif);\nstatic int OJPEGReadHeaderInfo(TIFF* tif);\nstatic int OJPEGReadSecondarySos(TIFF* tif, tsample_t s);\nstatic int OJPEGWriteHeaderInfo(TIFF* tif);\nstatic void OJPEGLibjpegSessionAbort(TIFF* tif);\n\nstatic int OJPEGReadHeaderInfoSec(TIFF* tif);\nstatic int OJPEGReadHeaderInfoSecStreamDri(TIFF* tif);\nstatic int OJPEGReadHeaderInfoSecStreamDqt(TIFF* tif);\nstatic int OJPEGReadHeaderInfoSecStreamDht(TIFF* tif);\nstatic int OJPEGReadHeaderInfoSecStreamSof(TIFF* tif, uint8 marker_id);\nstatic int OJPEGReadHeaderInfoSecStreamSos(TIFF* tif);\nstatic int OJPEGReadHeaderInfoSecTablesQTable(TIFF* tif);\nstatic int OJPEGReadHeaderInfoSecTablesDcTable(TIFF* tif);\nstatic int OJPEGReadHeaderInfoSecTablesAcTable(TIFF* tif);\n\nstatic int OJPEGReadBufferFill(OJPEGState* sp);\nstatic int OJPEGReadByte(OJPEGState* sp, uint8* byte);\nstatic int OJPEGReadBytePeek(OJPEGState* sp, uint8* byte);\nstatic void OJPEGReadByteAdvance(OJPEGState* sp);\nstatic int OJPEGReadWord(OJPEGState* sp, uint16* word);\nstatic int OJPEGReadBlock(OJPEGState* sp, uint16 len, void* mem);\nstatic void OJPEGReadSkip(OJPEGState* sp, uint16 len);\n\nstatic int OJPEGWriteStream(TIFF* tif, void** mem, uint32* len);\nstatic void OJPEGWriteStreamSoi(TIFF* tif, void** mem, uint32* len);\nstatic void OJPEGWriteStreamQTable(TIFF* tif, uint8 table_index, void** mem, uint32* len);\nstatic void OJPEGWriteStreamDcTable(TIFF* tif, uint8 table_index, void** mem, uint32* len);\nstatic void OJPEGWriteStreamAcTable(TIFF* tif, uint8 table_index, void** mem, uint32* len);\nstatic void OJPEGWriteStreamDri(TIFF* tif, void** mem, uint32* len);\nstatic void OJPEGWriteStreamSof(TIFF* tif, void** mem, uint32* len);\nstatic void OJPEGWriteStreamSos(TIFF* tif, void** mem, uint32* len);\nstatic int OJPEGWriteStreamCompressed(TIFF* tif, void** mem, uint32* len);\nstatic void OJPEGWriteStreamRst(TIFF* tif, void** mem, uint32* len);\nstatic void OJPEGWriteStreamEoi(TIFF* tif, void** mem, uint32* len);\n\n#ifdef LIBJPEG_ENCAP_EXTERNAL\nextern int jpeg_create_decompress_encap(OJPEGState* sp, jpeg_decompress_struct* cinfo);\nextern int jpeg_read_header_encap(OJPEGState* sp, jpeg_decompress_struct* cinfo, uint8 require_image);\nextern int jpeg_start_decompress_encap(OJPEGState* sp, jpeg_decompress_struct* cinfo);\nextern int jpeg_read_scanlines_encap(OJPEGState* sp, jpeg_decompress_struct* cinfo, void* scanlines, uint32 max_lines);\nextern int jpeg_read_raw_data_encap(OJPEGState* sp, jpeg_decompress_struct* cinfo, void* data, uint32 max_lines);\nextern void jpeg_encap_unwind(TIFF* tif);\n#else\nstatic int jpeg_create_decompress_encap(OJPEGState* sp, jpeg_decompress_struct* j);\nstatic int jpeg_read_header_encap(OJPEGState* sp, jpeg_decompress_struct* cinfo, uint8 require_image);\nstatic int jpeg_start_decompress_encap(OJPEGState* sp, jpeg_decompress_struct* cinfo);\nstatic int jpeg_read_scanlines_encap(OJPEGState* sp, jpeg_decompress_struct* cinfo, void* scanlines, uint32 max_lines);\nstatic int jpeg_read_raw_data_encap(OJPEGState* sp, jpeg_decompress_struct* cinfo, void* data, uint32 max_lines);\nstatic void jpeg_encap_unwind(TIFF* tif);\n#endif\n\nstatic void OJPEGLibjpegJpegErrorMgrOutputMessage(jpeg_common_struct* cinfo);\nstatic void OJPEGLibjpegJpegErrorMgrErrorExit(jpeg_common_struct* cinfo);\nstatic void OJPEGLibjpegJpegSourceMgrInitSource(jpeg_decompress_struct* cinfo);\nstatic boolean OJPEGLibjpegJpegSourceMgrFillInputBuffer(jpeg_decompress_struct* cinfo);\nstatic void OJPEGLibjpegJpegSourceMgrSkipInputData(jpeg_decompress_struct* cinfo, long num_bytes);\nstatic boolean OJPEGLibjpegJpegSourceMgrResyncToRestart(jpeg_decompress_struct* cinfo, int desired);\nstatic void OJPEGLibjpegJpegSourceMgrTermSource(jpeg_decompress_struct* cinfo);\n\nint\nTIFFInitOJPEG(TIFF* tif, int scheme)\n{\n\tstatic const char module[]=\"TIFFInitOJPEG\";\n\tOJPEGState* sp;\n\n\tassert(scheme==COMPRESSION_OJPEG);\n\n        /*\n\t * Merge codec-specific tag information.\n\t */\n\tif (!_TIFFMergeFieldInfo(tif,ojpeg_field_info,FIELD_OJPEG_COUNT)) {\n\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t     \"Merging Old JPEG codec-specific tags failed\");\n\t\treturn 0;\n\t}\n\n\t/* state block */\n\tsp=_TIFFmalloc(sizeof(OJPEGState));\n\tif (sp==NULL)\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata,module,\"No space for OJPEG state block\");\n\t\treturn(0);\n\t}\n\t_TIFFmemset(sp,0,sizeof(OJPEGState));\n\tsp->tif=tif;\n\tsp->jpeg_proc=1;\n\tsp->subsampling_hor=2;\n\tsp->subsampling_ver=2;\n\tTIFFSetField(tif,TIFFTAG_YCBCRSUBSAMPLING,2,2);\n\t/* tif codec methods */\n\ttif->tif_setupdecode=OJPEGSetupDecode;\n\ttif->tif_predecode=OJPEGPreDecode;\n\ttif->tif_postdecode=OJPEGPostDecode;\n\ttif->tif_decoderow=OJPEGDecode;\n\ttif->tif_decodestrip=OJPEGDecode;\n\ttif->tif_decodetile=OJPEGDecode;\n\ttif->tif_setupencode=OJPEGSetupEncode;\n\ttif->tif_preencode=OJPEGPreEncode;\n\ttif->tif_postencode=OJPEGPostEncode;\n\ttif->tif_encoderow=OJPEGEncode;\n\ttif->tif_encodestrip=OJPEGEncode;\n\ttif->tif_encodetile=OJPEGEncode;\n\ttif->tif_cleanup=OJPEGCleanup;\n\ttif->tif_data=(tidata_t)sp;\n\t/* tif tag methods */\n\tsp->vgetparent=tif->tif_tagmethods.vgetfield;\n\ttif->tif_tagmethods.vgetfield=OJPEGVGetField;\n\tsp->vsetparent=tif->tif_tagmethods.vsetfield;\n\ttif->tif_tagmethods.vsetfield=OJPEGVSetField;\n\ttif->tif_tagmethods.printdir=OJPEGPrintDir;\n\t/* Some OJPEG files don't have strip or tile offsets or bytecounts tags.\n\t   Some others do, but have totally meaningless or corrupt values\n\t   in these tags. In these cases, the JpegInterchangeFormat stream is\n\t   reliable. In any case, this decoder reads the compressed data itself,\n\t   from the most reliable locations, and we need to notify encapsulating\n\t   LibTiff not to read raw strips or tiles for us. */\n\ttif->tif_flags|=TIFF_NOREADRAW;\n\treturn(1);\n}\n\nstatic int\nOJPEGVGetField(TIFF* tif, ttag_t tag, va_list ap)\n{\n\tOJPEGState* sp=(OJPEGState*)tif->tif_data;\n\tswitch(tag)\n\t{\n\t\tcase TIFFTAG_JPEGIFOFFSET:\n\t\t\t*va_arg(ap,uint32*)=(uint32)sp->jpeg_interchange_format;\n\t\t\tbreak;\n\t\tcase TIFFTAG_JPEGIFBYTECOUNT:\n\t\t\t*va_arg(ap,uint32*)=(uint32)sp->jpeg_interchange_format_length;\n\t\t\tbreak;\n\t\tcase TIFFTAG_YCBCRSUBSAMPLING:\n\t\t\tif (sp->subsamplingcorrect_done==0)\n\t\t\t\tOJPEGSubsamplingCorrect(tif);\n\t\t\t*va_arg(ap,uint16*)=(uint16)sp->subsampling_hor;\n\t\t\t*va_arg(ap,uint16*)=(uint16)sp->subsampling_ver;\n\t\t\tbreak;\n\t\tcase TIFFTAG_JPEGQTABLES:\n\t\t\t*va_arg(ap,uint32*)=(uint32)sp->qtable_offset_count;\n\t\t\t*va_arg(ap,void**)=(void*)sp->qtable_offset;\n\t\t\tbreak;\n\t\tcase TIFFTAG_JPEGDCTABLES:\n\t\t\t*va_arg(ap,uint32*)=(uint32)sp->dctable_offset_count;\n\t\t\t*va_arg(ap,void**)=(void*)sp->dctable_offset;\n\t\t\tbreak;\n\t\tcase TIFFTAG_JPEGACTABLES:\n\t\t\t*va_arg(ap,uint32*)=(uint32)sp->actable_offset_count;\n\t\t\t*va_arg(ap,void**)=(void*)sp->actable_offset;\n\t\t\tbreak;\n\t\tcase TIFFTAG_JPEGPROC:\n\t\t\t*va_arg(ap,uint16*)=(uint16)sp->jpeg_proc;\n\t\t\tbreak;\n\t\tcase TIFFTAG_JPEGRESTARTINTERVAL:\n\t\t\t*va_arg(ap,uint16*)=sp->restart_interval;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn (*sp->vgetparent)(tif,tag,ap);\n\t}\n\treturn (1);\n}\n\nstatic int\nOJPEGVSetField(TIFF* tif, ttag_t tag, va_list ap)\n{\n\tstatic const char module[]=\"OJPEGVSetField\";\n\tOJPEGState* sp=(OJPEGState*)tif->tif_data;\n\tuint32 ma;\n\tuint32* mb;\n\tuint32 n;\n\tswitch(tag)\n\t{\n\t\tcase TIFFTAG_JPEGIFOFFSET:\n\t\t\tsp->jpeg_interchange_format=(toff_t)va_arg(ap,uint32);  \n\t\t\tbreak;\n\t\tcase TIFFTAG_JPEGIFBYTECOUNT:\n\t\t\tsp->jpeg_interchange_format_length=(toff_t)va_arg(ap,uint32);  \n\t\t\tbreak;\n\t\tcase TIFFTAG_YCBCRSUBSAMPLING:\n\t\t\tsp->subsampling_tag=1;\n\t\t\tsp->subsampling_hor=(uint8)va_arg(ap,int);\n\t\t\tsp->subsampling_ver=(uint8)va_arg(ap,int);\n\t\t\ttif->tif_dir.td_ycbcrsubsampling[0]=sp->subsampling_hor;\n\t\t\ttif->tif_dir.td_ycbcrsubsampling[1]=sp->subsampling_ver;\n\t\t\tbreak;\n\t\tcase TIFFTAG_JPEGQTABLES:\n\t\t\tma=va_arg(ap,uint32);\n\t\t\tif (ma!=0)\n\t\t\t{\n\t\t\t\tif (ma>3)\n\t\t\t\t{\n\t\t\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"JpegQTables tag has incorrect count\");\n\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t\tsp->qtable_offset_count=(uint8)ma;\n\t\t\t\tmb=va_arg(ap,uint32*);\n\t\t\t\tfor (n=0; n<ma; n++)\n\t\t\t\t\tsp->qtable_offset[n]=(toff_t)mb[n];\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFFTAG_JPEGDCTABLES:\n\t\t\tma=va_arg(ap,uint32);\n\t\t\tif (ma!=0)\n\t\t\t{\n\t\t\t\tif (ma>3)\n\t\t\t\t{\n\t\t\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"JpegDcTables tag has incorrect count\");\n\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t\tsp->dctable_offset_count=(uint8)ma;\n\t\t\t\tmb=va_arg(ap,uint32*);\n\t\t\t\tfor (n=0; n<ma; n++)\n\t\t\t\t\tsp->dctable_offset[n]=(toff_t)mb[n];\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFFTAG_JPEGACTABLES:\n\t\t\tma=va_arg(ap,uint32);\n\t\t\tif (ma!=0)\n\t\t\t{\n\t\t\t\tif (ma>3)\n\t\t\t\t{\n\t\t\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"JpegAcTables tag has incorrect count\");\n\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t\tsp->actable_offset_count=(uint8)ma;\n\t\t\t\tmb=va_arg(ap,uint32*);\n\t\t\t\tfor (n=0; n<ma; n++)\n\t\t\t\t\tsp->actable_offset[n]=(toff_t)mb[n];\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFFTAG_JPEGPROC:\n\t\t\tsp->jpeg_proc=(uint8)va_arg(ap,uint32);\n\t\t\tbreak;\n\t\tcase TIFFTAG_JPEGRESTARTINTERVAL:\n\t\t\tsp->restart_interval=(uint16)va_arg(ap,uint32);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn (*sp->vsetparent)(tif,tag,ap);\n\t}\n\tTIFFSetFieldBit(tif,_TIFFFieldWithTag(tif,tag)->field_bit);\n\ttif->tif_flags|=TIFF_DIRTYDIRECT;\n\treturn(1);\n}\n\nstatic void\nOJPEGPrintDir(TIFF* tif, FILE* fd, long flags)\n{\n\tOJPEGState* sp=(OJPEGState*)tif->tif_data;\n\tuint8 m;\n\t(void)flags;\n\tassert(sp!=NULL);\n\tif (TIFFFieldSet(tif,FIELD_OJPEG_JPEGINTERCHANGEFORMAT))\n\t\tfprintf(fd,\"  JpegInterchangeFormat: %lu\\n\",(unsigned long)sp->jpeg_interchange_format);\n\tif (TIFFFieldSet(tif,FIELD_OJPEG_JPEGINTERCHANGEFORMATLENGTH))\n\t\tfprintf(fd,\"  JpegInterchangeFormatLength: %lu\\n\",(unsigned long)sp->jpeg_interchange_format_length);\n\tif (TIFFFieldSet(tif,FIELD_OJPEG_JPEGQTABLES))\n\t{\n\t\tfprintf(fd,\"  JpegQTables:\");\n\t\tfor (m=0; m<sp->qtable_offset_count; m++)\n\t\t\tfprintf(fd,\" %lu\",(unsigned long)sp->qtable_offset[m]);\n\t\tfprintf(fd,\"\\n\");\n\t}\n\tif (TIFFFieldSet(tif,FIELD_OJPEG_JPEGDCTABLES))\n\t{\n\t\tfprintf(fd,\"  JpegDcTables:\");\n\t\tfor (m=0; m<sp->dctable_offset_count; m++)\n\t\t\tfprintf(fd,\" %lu\",(unsigned long)sp->dctable_offset[m]);\n\t\tfprintf(fd,\"\\n\");\n\t}\n\tif (TIFFFieldSet(tif,FIELD_OJPEG_JPEGACTABLES))\n\t{\n\t\tfprintf(fd,\"  JpegAcTables:\");\n\t\tfor (m=0; m<sp->actable_offset_count; m++)\n\t\t\tfprintf(fd,\" %lu\",(unsigned long)sp->actable_offset[m]);\n\t\tfprintf(fd,\"\\n\");\n\t}\n\tif (TIFFFieldSet(tif,FIELD_OJPEG_JPEGPROC))\n\t\tfprintf(fd,\"  JpegProc: %u\\n\",(unsigned int)sp->jpeg_proc);\n\tif (TIFFFieldSet(tif,FIELD_OJPEG_JPEGRESTARTINTERVAL))\n\t\tfprintf(fd,\"  JpegRestartInterval: %u\\n\",(unsigned int)sp->restart_interval);\n}\n\nstatic int\nOJPEGSetupDecode(TIFF* tif)\n{\n\tstatic const char module[]=\"OJPEGSetupDecode\";\n\tTIFFWarningExt(tif->tif_clientdata,module,\"Depreciated and troublesome old-style JPEG compression mode, please convert to new-style JPEG compression and notify vendor of writing software\");\n\treturn(1);\n}\n\nstatic int\nOJPEGPreDecode(TIFF* tif, tsample_t s)\n{\n\tOJPEGState* sp=(OJPEGState*)tif->tif_data;\n\ttstrile_t m;\n\tif (sp->subsamplingcorrect_done==0)\n\t\tOJPEGSubsamplingCorrect(tif);\n\tif (sp->readheader_done==0)\n\t{\n\t\tif (OJPEGReadHeaderInfo(tif)==0)\n\t\t\treturn(0);\n\t}\n\tif (sp->sos_end[s].log==0)\n\t{\n\t\tif (OJPEGReadSecondarySos(tif,s)==0)\n\t\t\treturn(0);\n\t}\n\tif isTiled(tif)\n\t\tm=(tstrile_t)tif->tif_curtile;\n\telse\n\t\tm=(tstrile_t)tif->tif_curstrip;\n\tif ((sp->writeheader_done!=0) && ((sp->write_cursample!=s) || (sp->write_curstrile>m)))\n\t{\n\t\tif (sp->libjpeg_session_active!=0)\n\t\t\tOJPEGLibjpegSessionAbort(tif);\n\t\tsp->writeheader_done=0;\n\t}\n\tif (sp->writeheader_done==0)\n\t{\n\t\tsp->plane_sample_offset=(uint8)s;\n\t\tsp->write_cursample=s;\n\t\tsp->write_curstrile=s*tif->tif_dir.td_stripsperimage;\n\t\tif ((sp->in_buffer_file_pos_log==0) ||\n\t\t    (sp->in_buffer_file_pos-sp->in_buffer_togo!=sp->sos_end[s].in_buffer_file_pos))\n\t\t{\n\t\t\tsp->in_buffer_source=sp->sos_end[s].in_buffer_source;\n\t\t\tsp->in_buffer_next_strile=sp->sos_end[s].in_buffer_next_strile;\n\t\t\tsp->in_buffer_file_pos=sp->sos_end[s].in_buffer_file_pos;\n\t\t\tsp->in_buffer_file_pos_log=0;\n\t\t\tsp->in_buffer_file_togo=sp->sos_end[s].in_buffer_file_togo;\n\t\t\tsp->in_buffer_togo=0;\n\t\t\tsp->in_buffer_cur=0;\n\t\t}\n\t\tif (OJPEGWriteHeaderInfo(tif)==0)\n\t\t\treturn(0);\n\t}\n\twhile (sp->write_curstrile<m)          \n\t{\n\t\tif (sp->libjpeg_jpeg_query_style==0)\n\t\t{\n\t\t\tif (OJPEGPreDecodeSkipRaw(tif)==0)\n\t\t\t\treturn(0);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (OJPEGPreDecodeSkipScanlines(tif)==0)\n\t\t\t\treturn(0);\n\t\t}\n\t\tsp->write_curstrile++;\n\t}\n\treturn(1);\n}\n\nstatic int\nOJPEGPreDecodeSkipRaw(TIFF* tif)\n{\n\tOJPEGState* sp=(OJPEGState*)tif->tif_data;\n\tuint32 m;\n\tm=sp->lines_per_strile;\n\tif (sp->subsampling_convert_state!=0)\n\t{\n\t\tif (sp->subsampling_convert_clines-sp->subsampling_convert_state>=m)\n\t\t{\n\t\t\tsp->subsampling_convert_state+=m;\n\t\t\tif (sp->subsampling_convert_state==sp->subsampling_convert_clines)\n\t\t\t\tsp->subsampling_convert_state=0;\n\t\t\treturn(1);\n\t\t}\n\t\tm-=sp->subsampling_convert_clines-sp->subsampling_convert_state;\n\t\tsp->subsampling_convert_state=0;\n\t}\n\twhile (m>=sp->subsampling_convert_clines)\n\t{\n\t\tif (jpeg_read_raw_data_encap(sp,&(sp->libjpeg_jpeg_decompress_struct),sp->subsampling_convert_ycbcrimage,sp->subsampling_ver*8)==0)\n\t\t\treturn(0);\n\t\tm-=sp->subsampling_convert_clines;\n\t}\n\tif (m>0)\n\t{\n\t\tif (jpeg_read_raw_data_encap(sp,&(sp->libjpeg_jpeg_decompress_struct),sp->subsampling_convert_ycbcrimage,sp->subsampling_ver*8)==0)\n\t\t\treturn(0);\n\t\tsp->subsampling_convert_state=m;\n\t}\n\treturn(1);\n}\n\nstatic int\nOJPEGPreDecodeSkipScanlines(TIFF* tif)\n{\n\tstatic const char module[]=\"OJPEGPreDecodeSkipScanlines\";\n\tOJPEGState* sp=(OJPEGState*)tif->tif_data;\n\tuint32 m;\n\tif (sp->skip_buffer==NULL)\n\t{\n\t\tsp->skip_buffer=_TIFFmalloc(sp->bytes_per_line);\n\t\tif (sp->skip_buffer==NULL)\n\t\t{\n\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Out of memory\");\n\t\t\treturn(0);\n\t\t}\n\t}\n\tfor (m=0; m<sp->lines_per_strile; m++)\n\t{\n\t\tif (jpeg_read_scanlines_encap(sp,&(sp->libjpeg_jpeg_decompress_struct),&sp->skip_buffer,1)==0)\n\t\t\treturn(0);\n\t}\n\treturn(1);\n}\n\nstatic int\nOJPEGDecode(TIFF* tif, tidata_t buf, tsize_t cc, tsample_t s)\n{\n\tOJPEGState* sp=(OJPEGState*)tif->tif_data;\n\t(void)s;\n\tif (sp->libjpeg_jpeg_query_style==0)\n\t{\n\t\tif (OJPEGDecodeRaw(tif,buf,cc)==0)\n\t\t\treturn(0);\n\t}\n\telse\n\t{\n\t\tif (OJPEGDecodeScanlines(tif,buf,cc)==0)\n\t\t\treturn(0);\n\t}\n\treturn(1);\n}\n\nstatic int\nOJPEGDecodeRaw(TIFF* tif, tidata_t buf, tsize_t cc)\n{\n\tstatic const char module[]=\"OJPEGDecodeRaw\";\n\tOJPEGState* sp=(OJPEGState*)tif->tif_data;\n\tuint8* m;\n\tuint32 n;\n\tuint8* oy;\n\tuint8* ocb;\n\tuint8* ocr;\n\tuint8* p;\n\tuint32 q;\n\tuint8* r;\n\tuint8 sx,sy;\n\tif (cc%sp->bytes_per_line!=0)\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Fractional scanline not read\");\n\t\treturn(0);\n\t}\n\tassert(cc>0);\n\tm=buf;\n\tn=cc;\n\tdo\n\t{\n\t\tif (sp->subsampling_convert_state==0)\n\t\t{\n\t\t\tif (jpeg_read_raw_data_encap(sp,&(sp->libjpeg_jpeg_decompress_struct),sp->subsampling_convert_ycbcrimage,sp->subsampling_ver*8)==0)\n\t\t\t\treturn(0);\n\t\t}\n\t\toy=sp->subsampling_convert_ybuf+sp->subsampling_convert_state*sp->subsampling_ver*sp->subsampling_convert_ylinelen;\n\t\tocb=sp->subsampling_convert_cbbuf+sp->subsampling_convert_state*sp->subsampling_convert_clinelen;\n\t\tocr=sp->subsampling_convert_crbuf+sp->subsampling_convert_state*sp->subsampling_convert_clinelen;\n\t\tp=m;\n\t\tfor (q=0; q<sp->subsampling_convert_clinelenout; q++)\n\t\t{\n\t\t\tr=oy;\n\t\t\tfor (sy=0; sy<sp->subsampling_ver; sy++)\n\t\t\t{\n\t\t\t\tfor (sx=0; sx<sp->subsampling_hor; sx++)\n\t\t\t\t\t*p++=*r++;\n\t\t\t\tr+=sp->subsampling_convert_ylinelen-sp->subsampling_hor;\n\t\t\t}\n\t\t\toy+=sp->subsampling_hor;\n\t\t\t*p++=*ocb++;\n\t\t\t*p++=*ocr++;\n\t\t}\n\t\tsp->subsampling_convert_state++;\n\t\tif (sp->subsampling_convert_state==sp->subsampling_convert_clines)\n\t\t\tsp->subsampling_convert_state=0;\n\t\tm+=sp->bytes_per_line;\n\t\tn-=sp->bytes_per_line;\n\t} while(n>0);\n\treturn(1);\n}\n\nstatic int\nOJPEGDecodeScanlines(TIFF* tif, tidata_t buf, tsize_t cc)\n{\n\tstatic const char module[]=\"OJPEGDecodeScanlines\";\n\tOJPEGState* sp=(OJPEGState*)tif->tif_data;\n\tuint8* m;\n\tuint32 n;\n\tif (cc%sp->bytes_per_line!=0)\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Fractional scanline not read\");\n\t\treturn(0);\n\t}\n\tassert(cc>0);\n\tm=buf;\n\tn=cc;\n\tdo\n\t{\n\t\tif (jpeg_read_scanlines_encap(sp,&(sp->libjpeg_jpeg_decompress_struct),&m,1)==0)\n\t\t\treturn(0);\n\t\tm+=sp->bytes_per_line;\n\t\tn-=sp->bytes_per_line;\n\t} while(n>0);\n\treturn(1);\n}\n\nstatic void\nOJPEGPostDecode(TIFF* tif, tidata_t buf, tsize_t cc)\n{\n\tOJPEGState* sp=(OJPEGState*)tif->tif_data;\n\t(void)buf;\n\t(void)cc;\n\tsp->write_curstrile++;\n\tif (sp->write_curstrile%tif->tif_dir.td_stripsperimage==0)\n\t{\n\t\tassert(sp->libjpeg_session_active!=0);\n\t\tOJPEGLibjpegSessionAbort(tif);\n\t\tsp->writeheader_done=0;\n\t}\n}\n\nstatic int\nOJPEGSetupEncode(TIFF* tif)\n{\n\tstatic const char module[]=\"OJPEGSetupEncode\";\n\tTIFFErrorExt(tif->tif_clientdata,module,\"OJPEG encoding not supported; use new-style JPEG compression instead\");\n\treturn(0);\n}\n\nstatic int\nOJPEGPreEncode(TIFF* tif, tsample_t s)\n{\n\tstatic const char module[]=\"OJPEGPreEncode\";\n\t(void)s;\n\tTIFFErrorExt(tif->tif_clientdata,module,\"OJPEG encoding not supported; use new-style JPEG compression instead\");\n\treturn(0);\n}\n\nstatic int\nOJPEGEncode(TIFF* tif, tidata_t buf, tsize_t cc, tsample_t s)\n{\n\tstatic const char module[]=\"OJPEGEncode\";\n\t(void)buf;\n\t(void)cc;\n\t(void)s;\n\tTIFFErrorExt(tif->tif_clientdata,module,\"OJPEG encoding not supported; use new-style JPEG compression instead\");\n\treturn(0);\n}\n\nstatic int\nOJPEGPostEncode(TIFF* tif)\n{\n\tstatic const char module[]=\"OJPEGPostEncode\";\n\tTIFFErrorExt(tif->tif_clientdata,module,\"OJPEG encoding not supported; use new-style JPEG compression instead\");\n\treturn(0);\n}\n\nstatic void\nOJPEGCleanup(TIFF* tif)\n{\n\tOJPEGState* sp=(OJPEGState*)tif->tif_data;\n\tif (sp!=0)\n\t{\n\t\ttif->tif_tagmethods.vgetfield=sp->vgetparent;\n\t\ttif->tif_tagmethods.vsetfield=sp->vsetparent;\n\t\tif (sp->qtable[0]!=0)\n\t\t\t_TIFFfree(sp->qtable[0]);\n\t\tif (sp->qtable[1]!=0)\n\t\t\t_TIFFfree(sp->qtable[1]);\n\t\tif (sp->qtable[2]!=0)\n\t\t\t_TIFFfree(sp->qtable[2]);\n\t\tif (sp->qtable[3]!=0)\n\t\t\t_TIFFfree(sp->qtable[3]);\n\t\tif (sp->dctable[0]!=0)\n\t\t\t_TIFFfree(sp->dctable[0]);\n\t\tif (sp->dctable[1]!=0)\n\t\t\t_TIFFfree(sp->dctable[1]);\n\t\tif (sp->dctable[2]!=0)\n\t\t\t_TIFFfree(sp->dctable[2]);\n\t\tif (sp->dctable[3]!=0)\n\t\t\t_TIFFfree(sp->dctable[3]);\n\t\tif (sp->actable[0]!=0)\n\t\t\t_TIFFfree(sp->actable[0]);\n\t\tif (sp->actable[1]!=0)\n\t\t\t_TIFFfree(sp->actable[1]);\n\t\tif (sp->actable[2]!=0)\n\t\t\t_TIFFfree(sp->actable[2]);\n\t\tif (sp->actable[3]!=0)\n\t\t\t_TIFFfree(sp->actable[3]);\n\t\tif (sp->libjpeg_session_active!=0)\n\t\t\tOJPEGLibjpegSessionAbort(tif);\n\t\tif (sp->subsampling_convert_ycbcrbuf!=0)\n\t\t\t_TIFFfree(sp->subsampling_convert_ycbcrbuf);\n\t\tif (sp->subsampling_convert_ycbcrimage!=0)\n\t\t\t_TIFFfree(sp->subsampling_convert_ycbcrimage);\n\t\tif (sp->skip_buffer!=0)\n\t\t\t_TIFFfree(sp->skip_buffer);\n\t\t_TIFFfree(sp);\n\t\ttif->tif_data=NULL;\n\t\t_TIFFSetDefaultCompressionState(tif);\n\t}\n}\n\nstatic void\nOJPEGSubsamplingCorrect(TIFF* tif)\n{\n\tstatic const char module[]=\"OJPEGSubsamplingCorrect\";\n\tOJPEGState* sp=(OJPEGState*)tif->tif_data;\n\tuint8 mh;\n\tuint8 mv;\n\tassert(sp->subsamplingcorrect_done==0);\n\tif ((tif->tif_dir.td_samplesperpixel!=3) || ((tif->tif_dir.td_photometric!=PHOTOMETRIC_YCBCR) &&\n\t    (tif->tif_dir.td_photometric!=PHOTOMETRIC_ITULAB)))\n\t{\n\t\tif (sp->subsampling_tag!=0)\n\t\t\tTIFFWarningExt(tif->tif_clientdata,module,\"Subsampling tag not appropriate for this Photometric and/or SamplesPerPixel\");\n\t\tsp->subsampling_hor=1;\n\t\tsp->subsampling_ver=1;\n\t\tsp->subsampling_force_desubsampling_inside_decompression=0;\n\t}\n\telse\n\t{\n\t\tsp->subsamplingcorrect_done=1;\n\t\tmh=sp->subsampling_hor;\n\t\tmv=sp->subsampling_ver;\n\t\tsp->subsamplingcorrect=1;\n\t\tOJPEGReadHeaderInfoSec(tif);\n\t\tif (sp->subsampling_force_desubsampling_inside_decompression!=0)\n\t\t{\n\t\t\tsp->subsampling_hor=1;\n\t\t\tsp->subsampling_ver=1;\n\t\t}\n\t\tsp->subsamplingcorrect=0;\n\t\tif (((sp->subsampling_hor!=mh) || (sp->subsampling_ver!=mv)) && (sp->subsampling_force_desubsampling_inside_decompression==0))\n\t\t{\n\t\t\tif (sp->subsampling_tag==0)\n\t\t\t\tTIFFWarningExt(tif->tif_clientdata,module,\"Subsampling tag is not set, yet subsampling inside JPEG data [%d,%d] does not match default values [2,2]; assuming subsampling inside JPEG data is correct\",sp->subsampling_hor,sp->subsampling_ver);\n\t\t\telse\n\t\t\t\tTIFFWarningExt(tif->tif_clientdata,module,\"Subsampling inside JPEG data [%d,%d] does not match subsampling tag values [%d,%d]; assuming subsampling inside JPEG data is correct\",sp->subsampling_hor,sp->subsampling_ver,mh,mv);\n\t\t}\n\t\tif (sp->subsampling_force_desubsampling_inside_decompression!=0)\n\t\t{\n\t\t\tif (sp->subsampling_tag==0)\n\t\t\t\tTIFFWarningExt(tif->tif_clientdata,module,\"Subsampling tag is not set, yet subsampling inside JPEG data does not match default values [2,2] (nor any other values allowed in TIFF); assuming subsampling inside JPEG data is correct and desubsampling inside JPEG decompression\");\n\t\t\telse\n\t\t\t\tTIFFWarningExt(tif->tif_clientdata,module,\"Subsampling inside JPEG data does not match subsampling tag values [%d,%d] (nor any other values allowed in TIFF); assuming subsampling inside JPEG data is correct and desubsampling inside JPEG decompression\",mh,mv);\n\t\t}\n\t\tif (sp->subsampling_force_desubsampling_inside_decompression==0)\n\t\t{\n\t\t\tif (sp->subsampling_hor<sp->subsampling_ver)\n\t\t\t\tTIFFWarningExt(tif->tif_clientdata,module,\"Subsampling values [%d,%d] are not allowed in TIFF\",sp->subsampling_hor,sp->subsampling_ver);\n\t\t}\n\t}\n\tsp->subsamplingcorrect_done=1;\n}\n\nstatic int\nOJPEGReadHeaderInfo(TIFF* tif)\n{\n\tstatic const char module[]=\"OJPEGReadHeaderInfo\";\n\tOJPEGState* sp=(OJPEGState*)tif->tif_data;\n\tassert(sp->readheader_done==0);\n\tsp->image_width=tif->tif_dir.td_imagewidth;\n\tsp->image_length=tif->tif_dir.td_imagelength;\n\tif isTiled(tif)\n\t{\n\t\tsp->strile_width=tif->tif_dir.td_tilewidth;\n\t\tsp->strile_length=tif->tif_dir.td_tilelength;\n\t\tsp->strile_length_total=((sp->image_length+sp->strile_length-1)/sp->strile_length)*sp->strile_length;\n\t}\n\telse\n\t{\n\t\tsp->strile_width=sp->image_width;\n\t\tsp->strile_length=tif->tif_dir.td_rowsperstrip;\n\t\tsp->strile_length_total=sp->image_length;\n\t}\n\tsp->samples_per_pixel=(uint8)tif->tif_dir.td_samplesperpixel;\n\tif (sp->samples_per_pixel==1)\n\t{\n\t\tsp->plane_sample_offset=0;\n\t\tsp->samples_per_pixel_per_plane=sp->samples_per_pixel;\n\t\tsp->subsampling_hor=1;\n\t\tsp->subsampling_ver=1;\n\t}\n\telse\n\t{\n\t\tif (sp->samples_per_pixel!=3)\n\t\t{\n\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"SamplesPerPixel %d not supported for this compression scheme\",sp->samples_per_pixel);\n\t\t\treturn(0);\n\t\t}\n\t\tsp->plane_sample_offset=0;\n\t\tif (tif->tif_dir.td_planarconfig==PLANARCONFIG_CONTIG)\n\t\t\tsp->samples_per_pixel_per_plane=3;\n\t\telse\n\t\t\tsp->samples_per_pixel_per_plane=1;\n\t}\n\tif (sp->strile_length<sp->image_length)\n\t{\n\t\tif (sp->strile_length%(sp->subsampling_ver*8)!=0)\n\t\t{\n\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Incompatible vertical subsampling and image strip/tile length\");\n\t\t\treturn(0);\n\t\t}\n\t\tsp->restart_interval=((sp->strile_width+sp->subsampling_hor*8-1)/(sp->subsampling_hor*8))*(sp->strile_length/(sp->subsampling_ver*8));\n\t}\n\tif (OJPEGReadHeaderInfoSec(tif)==0)\n\t\treturn(0);\n\tsp->sos_end[0].log=1;\n\tsp->sos_end[0].in_buffer_source=sp->in_buffer_source;\n\tsp->sos_end[0].in_buffer_next_strile=sp->in_buffer_next_strile;\n\tsp->sos_end[0].in_buffer_file_pos=sp->in_buffer_file_pos-sp->in_buffer_togo;\n\tsp->sos_end[0].in_buffer_file_togo=sp->in_buffer_file_togo+sp->in_buffer_togo;\n\tsp->readheader_done=1;\n\treturn(1);\n}\n\nstatic int\nOJPEGReadSecondarySos(TIFF* tif, tsample_t s)\n{\n\tOJPEGState* sp=(OJPEGState*)tif->tif_data;\n\tuint8 m;\n\tassert(s>0);\n\tassert(s<3);\n\tassert(sp->sos_end[0].log!=0);\n\tassert(sp->sos_end[s].log==0);\n\tsp->plane_sample_offset=s-1;\n\twhile(sp->sos_end[sp->plane_sample_offset].log==0)\n\t\tsp->plane_sample_offset--;\n\tsp->in_buffer_source=sp->sos_end[sp->plane_sample_offset].in_buffer_source;\n\tsp->in_buffer_next_strile=sp->sos_end[sp->plane_sample_offset].in_buffer_next_strile;\n\tsp->in_buffer_file_pos=sp->sos_end[sp->plane_sample_offset].in_buffer_file_pos;  \n\tsp->in_buffer_file_pos_log=0;\n\tsp->in_buffer_file_togo=sp->sos_end[sp->plane_sample_offset].in_buffer_file_togo;\n\tsp->in_buffer_togo=0;\n\tsp->in_buffer_cur=0;\n\twhile(sp->plane_sample_offset<s)\n\t{\n\t\tdo\n\t\t{\n\t\t\tif (OJPEGReadByte(sp,&m)==0)\n\t\t\t\treturn(0);\n\t\t\tif (m==255)\n\t\t\t{\n\t\t\t\tdo\n\t\t\t\t{\n\t\t\t\t\tif (OJPEGReadByte(sp,&m)==0)\n\t\t\t\t\t\treturn(0);\n\t\t\t\t\tif (m!=255)\n\t\t\t\t\t\tbreak;\n\t\t\t\t} while(1);\n\t\t\t\tif (m==JPEG_MARKER_SOS)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t} while(1);\n\t\tsp->plane_sample_offset++;\n\t\tif (OJPEGReadHeaderInfoSecStreamSos(tif)==0)\n\t\t\treturn(0);\n\t\tsp->sos_end[sp->plane_sample_offset].log=1;\n\t\tsp->sos_end[sp->plane_sample_offset].in_buffer_source=sp->in_buffer_source;\n\t\tsp->sos_end[sp->plane_sample_offset].in_buffer_next_strile=sp->in_buffer_next_strile;\n\t\tsp->sos_end[sp->plane_sample_offset].in_buffer_file_pos=sp->in_buffer_file_pos-sp->in_buffer_togo;\n\t\tsp->sos_end[sp->plane_sample_offset].in_buffer_file_togo=sp->in_buffer_file_togo+sp->in_buffer_togo;\n\t}\n\treturn(1);\n}\n\nstatic int\nOJPEGWriteHeaderInfo(TIFF* tif)\n{\n\tstatic const char module[]=\"OJPEGWriteHeaderInfo\";\n\tOJPEGState* sp=(OJPEGState*)tif->tif_data;\n\tuint8** m;\n\tuint32 n;\n\tassert(sp->libjpeg_session_active==0);\n\tsp->out_state=ososSoi;\n\tsp->restart_index=0;\n\tjpeg_std_error(&(sp->libjpeg_jpeg_error_mgr));\n\tsp->libjpeg_jpeg_error_mgr.output_message=OJPEGLibjpegJpegErrorMgrOutputMessage;\n\tsp->libjpeg_jpeg_error_mgr.error_exit=OJPEGLibjpegJpegErrorMgrErrorExit;\n\tsp->libjpeg_jpeg_decompress_struct.err=&(sp->libjpeg_jpeg_error_mgr);\n\tsp->libjpeg_jpeg_decompress_struct.client_data=(void*)tif;\n\tif (jpeg_create_decompress_encap(sp,&(sp->libjpeg_jpeg_decompress_struct))==0)\n\t\treturn(0);\n\tsp->libjpeg_session_active=1;\n\tsp->libjpeg_jpeg_source_mgr.bytes_in_buffer=0;\n\tsp->libjpeg_jpeg_source_mgr.init_source=OJPEGLibjpegJpegSourceMgrInitSource;\n\tsp->libjpeg_jpeg_source_mgr.fill_input_buffer=OJPEGLibjpegJpegSourceMgrFillInputBuffer;\n\tsp->libjpeg_jpeg_source_mgr.skip_input_data=OJPEGLibjpegJpegSourceMgrSkipInputData;\n\tsp->libjpeg_jpeg_source_mgr.resync_to_restart=OJPEGLibjpegJpegSourceMgrResyncToRestart;\n\tsp->libjpeg_jpeg_source_mgr.term_source=OJPEGLibjpegJpegSourceMgrTermSource;\n\tsp->libjpeg_jpeg_decompress_struct.src=&(sp->libjpeg_jpeg_source_mgr);\n\tif (jpeg_read_header_encap(sp,&(sp->libjpeg_jpeg_decompress_struct),1)==0)\n\t\treturn(0);\n\tif ((sp->subsampling_force_desubsampling_inside_decompression==0) && (sp->samples_per_pixel_per_plane>1))\n\t{\n\t\tsp->libjpeg_jpeg_decompress_struct.raw_data_out=1;\n#if JPEG_LIB_VERSION >= 70\n\t\tsp->libjpeg_jpeg_decompress_struct.do_fancy_upsampling=FALSE;\n#endif\n\t\tsp->libjpeg_jpeg_query_style=0;\n\t\tif (sp->subsampling_convert_log==0)\n\t\t{\n\t\t\tassert(sp->subsampling_convert_ycbcrbuf==0);\n\t\t\tassert(sp->subsampling_convert_ycbcrimage==0);\n\t\t\tsp->subsampling_convert_ylinelen=((sp->strile_width+sp->subsampling_hor*8-1)/(sp->subsampling_hor*8)*sp->subsampling_hor*8);\n\t\t\tsp->subsampling_convert_ylines=sp->subsampling_ver*8;\n\t\t\tsp->subsampling_convert_clinelen=sp->subsampling_convert_ylinelen/sp->subsampling_hor;\n\t\t\tsp->subsampling_convert_clines=8;\n\t\t\tsp->subsampling_convert_ybuflen=sp->subsampling_convert_ylinelen*sp->subsampling_convert_ylines;\n\t\t\tsp->subsampling_convert_cbuflen=sp->subsampling_convert_clinelen*sp->subsampling_convert_clines;\n\t\t\tsp->subsampling_convert_ycbcrbuflen=sp->subsampling_convert_ybuflen+2*sp->subsampling_convert_cbuflen;\n\t\t\tsp->subsampling_convert_ycbcrbuf=_TIFFmalloc(sp->subsampling_convert_ycbcrbuflen);\n\t\t\tif (sp->subsampling_convert_ycbcrbuf==0)\n\t\t\t{\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Out of memory\");\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tsp->subsampling_convert_ybuf=sp->subsampling_convert_ycbcrbuf;\n\t\t\tsp->subsampling_convert_cbbuf=sp->subsampling_convert_ybuf+sp->subsampling_convert_ybuflen;\n\t\t\tsp->subsampling_convert_crbuf=sp->subsampling_convert_cbbuf+sp->subsampling_convert_cbuflen;\n\t\t\tsp->subsampling_convert_ycbcrimagelen=3+sp->subsampling_convert_ylines+2*sp->subsampling_convert_clines;\n\t\t\tsp->subsampling_convert_ycbcrimage=_TIFFmalloc(sp->subsampling_convert_ycbcrimagelen*sizeof(uint8*));\n\t\t\tif (sp->subsampling_convert_ycbcrimage==0)\n\t\t\t{\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Out of memory\");\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tm=sp->subsampling_convert_ycbcrimage;\n\t\t\t*m++=(uint8*)(sp->subsampling_convert_ycbcrimage+3);\n\t\t\t*m++=(uint8*)(sp->subsampling_convert_ycbcrimage+3+sp->subsampling_convert_ylines);\n\t\t\t*m++=(uint8*)(sp->subsampling_convert_ycbcrimage+3+sp->subsampling_convert_ylines+sp->subsampling_convert_clines);\n\t\t\tfor (n=0; n<sp->subsampling_convert_ylines; n++)\n\t\t\t\t*m++=sp->subsampling_convert_ybuf+n*sp->subsampling_convert_ylinelen;\n\t\t\tfor (n=0; n<sp->subsampling_convert_clines; n++)\n\t\t\t\t*m++=sp->subsampling_convert_cbbuf+n*sp->subsampling_convert_clinelen;\n\t\t\tfor (n=0; n<sp->subsampling_convert_clines; n++)\n\t\t\t\t*m++=sp->subsampling_convert_crbuf+n*sp->subsampling_convert_clinelen;\n\t\t\tsp->subsampling_convert_clinelenout=((sp->strile_width+sp->subsampling_hor-1)/sp->subsampling_hor);\n\t\t\tsp->subsampling_convert_state=0;\n\t\t\tsp->bytes_per_line=sp->subsampling_convert_clinelenout*(sp->subsampling_ver*sp->subsampling_hor+2);\n\t\t\tsp->lines_per_strile=((sp->strile_length+sp->subsampling_ver-1)/sp->subsampling_ver);\n\t\t\tsp->subsampling_convert_log=1;\n\t\t}\n\t}\n\telse\n\t{\n\t\tsp->libjpeg_jpeg_decompress_struct.jpeg_color_space=JCS_UNKNOWN;\n\t\tsp->libjpeg_jpeg_decompress_struct.out_color_space=JCS_UNKNOWN;\n\t\tsp->libjpeg_jpeg_query_style=1;\n\t\tsp->bytes_per_line=sp->samples_per_pixel_per_plane*sp->strile_width;\n\t\tsp->lines_per_strile=sp->strile_length;\n\t}\n\tif (jpeg_start_decompress_encap(sp,&(sp->libjpeg_jpeg_decompress_struct))==0)\n\t\treturn(0);\n\tsp->writeheader_done=1;\n\treturn(1);\n}\n\nstatic void\nOJPEGLibjpegSessionAbort(TIFF* tif)\n{\n\tOJPEGState* sp=(OJPEGState*)tif->tif_data;\n\tassert(sp->libjpeg_session_active!=0);\n\tjpeg_destroy((jpeg_common_struct*)(&(sp->libjpeg_jpeg_decompress_struct)));\n\tsp->libjpeg_session_active=0;\n}\n\nstatic int\nOJPEGReadHeaderInfoSec(TIFF* tif)\n{\n\tstatic const char module[]=\"OJPEGReadHeaderInfoSec\";\n\tOJPEGState* sp=(OJPEGState*)tif->tif_data;\n\tuint8 m;\n\tuint16 n;\n\tuint8 o;\n\tif (sp->file_size==0)\n\t\tsp->file_size=TIFFGetFileSize(tif);\n\tif (sp->jpeg_interchange_format!=0)\n\t{\n\t\tif (sp->jpeg_interchange_format>=sp->file_size)\n\t\t{\n\t\t\tsp->jpeg_interchange_format=0;\n\t\t\tsp->jpeg_interchange_format_length=0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif ((sp->jpeg_interchange_format_length==0) || (sp->jpeg_interchange_format+sp->jpeg_interchange_format_length>sp->file_size))\n\t\t\t\tsp->jpeg_interchange_format_length=sp->file_size-sp->jpeg_interchange_format;\n\t\t}\n\t}\n\tsp->in_buffer_source=osibsNotSetYet;\n\tsp->in_buffer_next_strile=0;\n\tsp->in_buffer_strile_count=tif->tif_dir.td_nstrips;   \n\tsp->in_buffer_file_togo=0;\n\tsp->in_buffer_togo=0;\n\tdo\n\t{\n\t\tif (OJPEGReadBytePeek(sp,&m)==0)\n\t\t\treturn(0);\n\t\tif (m!=255)\n\t\t\tbreak;\n\t\tOJPEGReadByteAdvance(sp);\n\t\tdo\n\t\t{\n\t\t\tif (OJPEGReadByte(sp,&m)==0)\n\t\t\t\treturn(0);\n\t\t} while(m==255);\n\t\tswitch(m)\n\t\t{\n\t\t\tcase JPEG_MARKER_SOI:\n\t\t\t\t/* this type of marker has no data, and should be skipped */\n\t\t\t\tbreak;\n\t\t\tcase JPEG_MARKER_COM:\n\t\t\tcase JPEG_MARKER_APP0:\n\t\t\tcase JPEG_MARKER_APP0+1:\n\t\t\tcase JPEG_MARKER_APP0+2:\n\t\t\tcase JPEG_MARKER_APP0+3:\n\t\t\tcase JPEG_MARKER_APP0+4:\n\t\t\tcase JPEG_MARKER_APP0+5:\n\t\t\tcase JPEG_MARKER_APP0+6:\n\t\t\tcase JPEG_MARKER_APP0+7:\n\t\t\tcase JPEG_MARKER_APP0+8:\n\t\t\tcase JPEG_MARKER_APP0+9:\n\t\t\tcase JPEG_MARKER_APP0+10:\n\t\t\tcase JPEG_MARKER_APP0+11:\n\t\t\tcase JPEG_MARKER_APP0+12:\n\t\t\tcase JPEG_MARKER_APP0+13:\n\t\t\tcase JPEG_MARKER_APP0+14:\n\t\t\tcase JPEG_MARKER_APP0+15:\n\t\t\t\t/* this type of marker has data, but it has no use to us (and no place here) and should be skipped */\n\t\t\t\tif (OJPEGReadWord(sp,&n)==0)\n\t\t\t\t\treturn(0);\n\t\t\t\tif (n<2)\n\t\t\t\t{\n\t\t\t\t\tif (sp->subsamplingcorrect==0)\n\t\t\t\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Corrupt JPEG data\");\n\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t\tif (n>2)\n\t\t\t\t\tOJPEGReadSkip(sp,(uint16)(n-2));\n\t\t\t\tbreak;\n\t\t\tcase JPEG_MARKER_DRI:\n\t\t\t\tif (OJPEGReadHeaderInfoSecStreamDri(tif)==0)\n\t\t\t\t\treturn(0);\n\t\t\t\tbreak;\n\t\t\tcase JPEG_MARKER_DQT:\n\t\t\t\tif (OJPEGReadHeaderInfoSecStreamDqt(tif)==0)\n\t\t\t\t\treturn(0);\n\t\t\t\tbreak;\n\t\t\tcase JPEG_MARKER_DHT:\n\t\t\t\tif (OJPEGReadHeaderInfoSecStreamDht(tif)==0)\n\t\t\t\t\treturn(0);\n\t\t\t\tbreak;\n\t\t\tcase JPEG_MARKER_SOF0:\n\t\t\tcase JPEG_MARKER_SOF1:\n\t\t\tcase JPEG_MARKER_SOF3:\n\t\t\t\tif (OJPEGReadHeaderInfoSecStreamSof(tif,m)==0)\n\t\t\t\t\treturn(0);\n\t\t\t\tif (sp->subsamplingcorrect!=0)\n\t\t\t\t\treturn(1);\n\t\t\t\tbreak;\n\t\t\tcase JPEG_MARKER_SOS:\n\t\t\t\tif (sp->subsamplingcorrect!=0)\n\t\t\t\t\treturn(1);\n\t\t\t\tassert(sp->plane_sample_offset==0);\n\t\t\t\tif (OJPEGReadHeaderInfoSecStreamSos(tif)==0)\n\t\t\t\t\treturn(0);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Unknown marker type %d in JPEG data\",m);\n\t\t\t\treturn(0);\n\t\t}\n\t} while(m!=JPEG_MARKER_SOS);\n\tif (sp->subsamplingcorrect)\n\t\treturn(1);\n\tif (sp->sof_log==0)\n\t{\n\t\tif (OJPEGReadHeaderInfoSecTablesQTable(tif)==0)\n\t\t\treturn(0);\n\t\tsp->sof_marker_id=JPEG_MARKER_SOF0;\n\t\tfor (o=0; o<sp->samples_per_pixel; o++)\n\t\t\tsp->sof_c[o]=o;\n\t\tsp->sof_hv[0]=((sp->subsampling_hor<<4)|sp->subsampling_ver);\n\t\tfor (o=1; o<sp->samples_per_pixel; o++)\n\t\t\tsp->sof_hv[o]=17;\n\t\tsp->sof_x=sp->strile_width;\n\t\tsp->sof_y=sp->strile_length_total;\n\t\tsp->sof_log=1;\n\t\tif (OJPEGReadHeaderInfoSecTablesDcTable(tif)==0)\n\t\t\treturn(0);\n\t\tif (OJPEGReadHeaderInfoSecTablesAcTable(tif)==0)\n\t\t\treturn(0);\n\t\tfor (o=1; o<sp->samples_per_pixel; o++)\n\t\t\tsp->sos_cs[o]=o;\n\t}\n\treturn(1);\n}\n\nstatic int\nOJPEGReadHeaderInfoSecStreamDri(TIFF* tif)\n{\n\t/* this could easilly cause trouble in some cases... but no such cases have occured sofar */\n\tstatic const char module[]=\"OJPEGReadHeaderInfoSecStreamDri\";\n\tOJPEGState* sp=(OJPEGState*)tif->tif_data;\n\tuint16 m;\n\tif (OJPEGReadWord(sp,&m)==0)\n\t\treturn(0);\n\tif (m!=4)\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Corrupt DRI marker in JPEG data\");\n\t\treturn(0);\n\t}\n\tif (OJPEGReadWord(sp,&m)==0)\n\t\treturn(0);\n\tsp->restart_interval=m;\n\treturn(1);\n}\n\nstatic int\nOJPEGReadHeaderInfoSecStreamDqt(TIFF* tif)\n{\n\t/* this is a table marker, and it is to be saved as a whole for exact pushing on the jpeg stream later on */\n\tstatic const char module[]=\"OJPEGReadHeaderInfoSecStreamDqt\";\n\tOJPEGState* sp=(OJPEGState*)tif->tif_data;\n\tuint16 m;\n\tuint32 na;\n\tuint8* nb;\n\tuint8 o;\n\tif (OJPEGReadWord(sp,&m)==0)\n\t\treturn(0);\n\tif (m<=2)\n\t{\n\t\tif (sp->subsamplingcorrect==0)\n\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Corrupt DQT marker in JPEG data\");\n\t\treturn(0);\n\t}\n\tif (sp->subsamplingcorrect!=0)\n\t\tOJPEGReadSkip(sp,(uint16)(m-2));\n\telse\n\t{\n\t\tm-=2;\n\t\tdo\n\t\t{\n\t\t\tif (m<65)\n\t\t\t{\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Corrupt DQT marker in JPEG data\");\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tna=sizeof(uint32)+69;\n\t\t\tnb=_TIFFmalloc(na);\n\t\t\tif (nb==0)\n\t\t\t{\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Out of memory\");\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\t*(uint32*)nb=na;\n\t\t\tnb[sizeof(uint32)]=255;\n\t\t\tnb[sizeof(uint32)+1]=JPEG_MARKER_DQT;\n\t\t\tnb[sizeof(uint32)+2]=0;\n\t\t\tnb[sizeof(uint32)+3]=67;\n\t\t\tif (OJPEGReadBlock(sp,65,&nb[sizeof(uint32)+4])==0)\n\t\t\t\treturn(0);\n\t\t\to=nb[sizeof(uint32)+4]&15;\n\t\t\tif (3<o)\n\t\t\t{\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Corrupt DQT marker in JPEG data\");\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tif (sp->qtable[o]!=0)\n\t\t\t\t_TIFFfree(sp->qtable[o]);\n\t\t\tsp->qtable[o]=nb;\n\t\t\tm-=65;\n\t\t} while(m>0);\n\t}\n\treturn(1);\n}\n\nstatic int\nOJPEGReadHeaderInfoSecStreamDht(TIFF* tif)\n{\n\t/* this is a table marker, and it is to be saved as a whole for exact pushing on the jpeg stream later on */\n\t/* TODO: the following assumes there is only one table in this marker... but i'm not quite sure that assumption is guaranteed correct */\n\tstatic const char module[]=\"OJPEGReadHeaderInfoSecStreamDht\";\n\tOJPEGState* sp=(OJPEGState*)tif->tif_data;\n\tuint16 m;\n\tuint32 na;\n\tuint8* nb;\n\tuint8 o;\n\tif (OJPEGReadWord(sp,&m)==0)\n\t\treturn(0);\n\tif (m<=2)\n\t{\n\t\tif (sp->subsamplingcorrect==0)\n\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Corrupt DHT marker in JPEG data\");\n\t\treturn(0);\n\t}\n\tif (sp->subsamplingcorrect!=0)\n\t{\n\t\tOJPEGReadSkip(sp,(uint16)(m-2));\n\t}\n\telse\n\t{\n\t\tna=sizeof(uint32)+2+m;\n\t\tnb=_TIFFmalloc(na);\n\t\tif (nb==0)\n\t\t{\n\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Out of memory\");\n\t\t\treturn(0);\n\t\t}\n\t\t*(uint32*)nb=na;\n\t\tnb[sizeof(uint32)]=255;\n\t\tnb[sizeof(uint32)+1]=JPEG_MARKER_DHT;\n\t\tnb[sizeof(uint32)+2]=(m>>8);\n\t\tnb[sizeof(uint32)+3]=(m&255);\n\t\tif (OJPEGReadBlock(sp,(uint16)(m-2),&nb[sizeof(uint32)+4])==0)\n\t\t\treturn(0);\n\t\to=nb[sizeof(uint32)+4];\n\t\tif ((o&240)==0)\n\t\t{\n\t\t\tif (3<o)\n\t\t\t{\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Corrupt DHT marker in JPEG data\");\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tif (sp->dctable[o]!=0)\n\t\t\t\t_TIFFfree(sp->dctable[o]);\n\t\t\tsp->dctable[o]=nb;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif ((o&240)!=16)\n\t\t\t{\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Corrupt DHT marker in JPEG data\");\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\to&=15;\n\t\t\tif (3<o)\n\t\t\t{\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Corrupt DHT marker in JPEG data\");\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tif (sp->actable[o]!=0)\n\t\t\t\t_TIFFfree(sp->actable[o]);\n\t\t\tsp->actable[o]=nb;\n\t\t}\n\t}\n\treturn(1);\n}\n\nstatic int\nOJPEGReadHeaderInfoSecStreamSof(TIFF* tif, uint8 marker_id)\n{\n\t/* this marker needs to be checked, and part of its data needs to be saved for regeneration later on */\n\tstatic const char module[]=\"OJPEGReadHeaderInfoSecStreamSof\";\n\tOJPEGState* sp=(OJPEGState*)tif->tif_data;\n\tuint16 m;\n\tuint16 n;\n\tuint8 o;\n\tuint16 p;\n\tuint16 q;\n\tif (sp->sof_log!=0)\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Corrupt JPEG data\");\n\t\treturn(0);\n\t}\n\tif (sp->subsamplingcorrect==0)\n\t\tsp->sof_marker_id=marker_id;\n\t/* Lf: data length */\n\tif (OJPEGReadWord(sp,&m)==0)\n\t\treturn(0);\n\tif (m<11)\n\t{\n\t\tif (sp->subsamplingcorrect==0)\n\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Corrupt SOF marker in JPEG data\");\n\t\treturn(0);\n\t}\n\tm-=8;\n\tif (m%3!=0)\n\t{\n\t\tif (sp->subsamplingcorrect==0)\n\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Corrupt SOF marker in JPEG data\");\n\t\treturn(0);\n\t}\n\tn=m/3;\n\tif (sp->subsamplingcorrect==0)\n\t{\n\t\tif (n!=sp->samples_per_pixel)\n\t\t{\n\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"JPEG compressed data indicates unexpected number of samples\");\n\t\t\treturn(0);\n\t\t}\n\t}\n\t/* P: Sample precision */\n\tif (OJPEGReadByte(sp,&o)==0)\n\t\treturn(0);\n\tif (o!=8)\n\t{\n\t\tif (sp->subsamplingcorrect==0)\n\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"JPEG compressed data indicates unexpected number of bits per sample\");\n\t\treturn(0);\n\t}\n\t/* Y: Number of lines, X: Number of samples per line */\n\tif (sp->subsamplingcorrect)\n\t\tOJPEGReadSkip(sp,4);\n\telse\n\t{\n\t\t/* TODO: probably best to also add check on allowed upper bound, especially x, may cause buffer overflow otherwise i think */\n\t\t/* Y: Number of lines */\n\t\tif (OJPEGReadWord(sp,&p)==0)\n\t\t\treturn(0);\n\t\tif ((p<sp->image_length) && (p<sp->strile_length_total))\n\t\t{\n\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"JPEG compressed data indicates unexpected height\");\n\t\t\treturn(0);\n\t\t}\n\t\tsp->sof_y=p;\n\t\t/* X: Number of samples per line */\n\t\tif (OJPEGReadWord(sp,&p)==0)\n\t\t\treturn(0);\n\t\tif ((p<sp->image_width) && (p<sp->strile_width))\n\t\t{\n\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"JPEG compressed data indicates unexpected width\");\n\t\t\treturn(0);\n\t\t}\n\t\tsp->sof_x=p;\n\t}\n\t/* Nf: Number of image components in frame */\n\tif (OJPEGReadByte(sp,&o)==0)\n\t\treturn(0);\n\tif (o!=n)\n\t{\n\t\tif (sp->subsamplingcorrect==0)\n\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Corrupt SOF marker in JPEG data\");\n\t\treturn(0);\n\t}\n\t/* per component stuff */\n\t/* TODO: double-check that flow implies that n cannot be as big as to make us overflow sof_c, sof_hv and sof_tq arrays */\n\tfor (q=0; q<n; q++)\n\t{\n\t\t/* C: Component identifier */\n\t\tif (OJPEGReadByte(sp,&o)==0)\n\t\t\treturn(0);\n\t\tif (sp->subsamplingcorrect==0)\n\t\t\tsp->sof_c[q]=o;\n\t\t/* H: Horizontal sampling factor, and V: Vertical sampling factor */\n\t\tif (OJPEGReadByte(sp,&o)==0)\n\t\t\treturn(0);\n\t\tif (sp->subsamplingcorrect!=0)\n\t\t{\n\t\t\tif (q==0)\n\t\t\t{\n\t\t\t\tsp->subsampling_hor=(o>>4);\n\t\t\t\tsp->subsampling_ver=(o&15);\n\t\t\t\tif (((sp->subsampling_hor!=1) && (sp->subsampling_hor!=2) && (sp->subsampling_hor!=4)) ||\n\t\t\t\t\t((sp->subsampling_ver!=1) && (sp->subsampling_ver!=2) && (sp->subsampling_ver!=4)))\n\t\t\t\t\tsp->subsampling_force_desubsampling_inside_decompression=1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (o!=17)\n\t\t\t\t\tsp->subsampling_force_desubsampling_inside_decompression=1;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsp->sof_hv[q]=o;\n\t\t\tif (sp->subsampling_force_desubsampling_inside_decompression==0)\n\t\t\t{\n\t\t\t\tif (q==0)\n\t\t\t\t{\n\t\t\t\t\tif (o!=((sp->subsampling_hor<<4)|sp->subsampling_ver))\n\t\t\t\t\t{\n\t\t\t\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"JPEG compressed data indicates unexpected subsampling values\");\n\t\t\t\t\t\treturn(0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (o!=17)\n\t\t\t\t\t{\n\t\t\t\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"JPEG compressed data indicates unexpected subsampling values\");\n\t\t\t\t\t\treturn(0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/* Tq: Quantization table destination selector */\n\t\tif (OJPEGReadByte(sp,&o)==0)\n\t\t\treturn(0);\n\t\tif (sp->subsamplingcorrect==0)\n\t\t\tsp->sof_tq[q]=o;\n\t}\n\tif (sp->subsamplingcorrect==0)\n\t\tsp->sof_log=1;\n\treturn(1);\n}\n\nstatic int\nOJPEGReadHeaderInfoSecStreamSos(TIFF* tif)\n{\n\t/* this marker needs to be checked, and part of its data needs to be saved for regeneration later on */\n\tstatic const char module[]=\"OJPEGReadHeaderInfoSecStreamSos\";\n\tOJPEGState* sp=(OJPEGState*)tif->tif_data;\n\tuint16 m;\n\tuint8 n;\n\tuint8 o;\n\tassert(sp->subsamplingcorrect==0);\n\tif (sp->sof_log==0)\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Corrupt SOS marker in JPEG data\");\n\t\treturn(0);\n\t}\n\t/* Ls */\n\tif (OJPEGReadWord(sp,&m)==0)\n\t\treturn(0);\n\tif (m!=6+sp->samples_per_pixel_per_plane*2)\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Corrupt SOS marker in JPEG data\");\n\t\treturn(0);\n\t}\n\t/* Ns */\n\tif (OJPEGReadByte(sp,&n)==0)\n\t\treturn(0);\n\tif (n!=sp->samples_per_pixel_per_plane)\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Corrupt SOS marker in JPEG data\");\n\t\treturn(0);\n\t}\n\t/* Cs, Td, and Ta */\n\tfor (o=0; o<sp->samples_per_pixel_per_plane; o++)\n\t{\n\t\t/* Cs */\n\t\tif (OJPEGReadByte(sp,&n)==0)\n\t\t\treturn(0);\n\t\tsp->sos_cs[sp->plane_sample_offset+o]=n;\n\t\t/* Td and Ta */\n\t\tif (OJPEGReadByte(sp,&n)==0)\n\t\t\treturn(0);\n\t\tsp->sos_tda[sp->plane_sample_offset+o]=n;\n\t}\n\t/* skip Ss, Se, Ah, en Al -> no check, as per Tom Lane recommendation, as per LibJpeg source */\n\tOJPEGReadSkip(sp,3);\n\treturn(1);\n}\n\nstatic int\nOJPEGReadHeaderInfoSecTablesQTable(TIFF* tif)\n{\n\tstatic const char module[]=\"OJPEGReadHeaderInfoSecTablesQTable\";\n\tOJPEGState* sp=(OJPEGState*)tif->tif_data;\n\tuint8 m;\n\tuint8 n;\n\tuint32 oa;\n\tuint8* ob;\n\tuint32 p;\n\tif (sp->qtable_offset[0]==0)\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Missing JPEG tables\");\n\t\treturn(0);\n\t}\n\tsp->in_buffer_file_pos_log=0;\n\tfor (m=0; m<sp->samples_per_pixel; m++)\n\t{\n\t\tif ((sp->qtable_offset[m]!=0) && ((m==0) || (sp->qtable_offset[m]!=sp->qtable_offset[m-1])))\n\t\t{\n\t\t\tfor (n=0; n<m-1; n++)\n\t\t\t{\n\t\t\t\tif (sp->qtable_offset[m]==sp->qtable_offset[n])\n\t\t\t\t{\n\t\t\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Corrupt JpegQTables tag value\");\n\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\toa=sizeof(uint32)+69;\n\t\t\tob=_TIFFmalloc(oa);\n\t\t\tif (ob==0)\n\t\t\t{\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Out of memory\");\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\t*(uint32*)ob=oa;\n\t\t\tob[sizeof(uint32)]=255;\n\t\t\tob[sizeof(uint32)+1]=JPEG_MARKER_DQT;\n\t\t\tob[sizeof(uint32)+2]=0;\n\t\t\tob[sizeof(uint32)+3]=67;\n\t\t\tob[sizeof(uint32)+4]=m;\n\t\t\tTIFFSeekFile(tif,sp->qtable_offset[m],SEEK_SET);\n\t\t\tp=TIFFReadFile(tif,&ob[sizeof(uint32)+5],64);\n\t\t\tif (p!=64)\n\t\t\t\treturn(0);\n\t\t\tsp->qtable[m]=ob;\n\t\t\tsp->sof_tq[m]=m;\n\t\t}\n\t\telse\n\t\t\tsp->sof_tq[m]=sp->sof_tq[m-1];\n\t}\n\treturn(1);\n}\n\nstatic int\nOJPEGReadHeaderInfoSecTablesDcTable(TIFF* tif)\n{\n\tstatic const char module[]=\"OJPEGReadHeaderInfoSecTablesDcTable\";\n\tOJPEGState* sp=(OJPEGState*)tif->tif_data;\n\tuint8 m;\n\tuint8 n;\n\tuint8 o[16];\n\tuint32 p;\n\tuint32 q;\n\tuint32 ra;\n\tuint8* rb;\n\tif (sp->dctable_offset[0]==0)\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Missing JPEG tables\");\n\t\treturn(0);\n\t}\n\tsp->in_buffer_file_pos_log=0;\n\tfor (m=0; m<sp->samples_per_pixel; m++)\n\t{\n\t\tif ((sp->dctable_offset[m]!=0) && ((m==0) || (sp->dctable_offset[m]!=sp->dctable_offset[m-1])))\n\t\t{\n\t\t\tfor (n=0; n<m-1; n++)\n\t\t\t{\n\t\t\t\tif (sp->dctable_offset[m]==sp->dctable_offset[n])\n\t\t\t\t{\n\t\t\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Corrupt JpegDcTables tag value\");\n\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tTIFFSeekFile(tif,sp->dctable_offset[m],SEEK_SET);\n\t\t\tp=TIFFReadFile(tif,o,16);\n\t\t\tif (p!=16)\n\t\t\t\treturn(0);\n\t\t\tq=0;\n\t\t\tfor (n=0; n<16; n++)\n\t\t\t\tq+=o[n];\n\t\t\tra=sizeof(uint32)+21+q;\n\t\t\trb=_TIFFmalloc(ra);\n\t\t\tif (rb==0)\n\t\t\t{\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Out of memory\");\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\t*(uint32*)rb=ra;\n\t\t\trb[sizeof(uint32)]=255;\n\t\t\trb[sizeof(uint32)+1]=JPEG_MARKER_DHT;\n\t\t\trb[sizeof(uint32)+2]=((19+q)>>8);\n\t\t\trb[sizeof(uint32)+3]=((19+q)&255);\n\t\t\trb[sizeof(uint32)+4]=m;\n\t\t\tfor (n=0; n<16; n++)\n\t\t\t\trb[sizeof(uint32)+5+n]=o[n];\n\t\t\tp=TIFFReadFile(tif,&(rb[sizeof(uint32)+21]),q);\n\t\t\tif (p!=q)\n\t\t\t\treturn(0);\n\t\t\tsp->dctable[m]=rb;\n\t\t\tsp->sos_tda[m]=(m<<4);\n\t\t}\n\t\telse\n\t\t\tsp->sos_tda[m]=sp->sos_tda[m-1];\n\t}\n\treturn(1);\n}\n\nstatic int\nOJPEGReadHeaderInfoSecTablesAcTable(TIFF* tif)\n{\n\tstatic const char module[]=\"OJPEGReadHeaderInfoSecTablesAcTable\";\n\tOJPEGState* sp=(OJPEGState*)tif->tif_data;\n\tuint8 m;\n\tuint8 n;\n\tuint8 o[16];\n\tuint32 p;\n\tuint32 q;\n\tuint32 ra;\n\tuint8* rb;\n\tif (sp->actable_offset[0]==0)\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Missing JPEG tables\");\n\t\treturn(0);\n\t}\n\tsp->in_buffer_file_pos_log=0;\n\tfor (m=0; m<sp->samples_per_pixel; m++)\n\t{\n\t\tif ((sp->actable_offset[m]!=0) && ((m==0) || (sp->actable_offset[m]!=sp->actable_offset[m-1])))\n\t\t{\n\t\t\tfor (n=0; n<m-1; n++)\n\t\t\t{\n\t\t\t\tif (sp->actable_offset[m]==sp->actable_offset[n])\n\t\t\t\t{\n\t\t\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Corrupt JpegAcTables tag value\");\n\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tTIFFSeekFile(tif,sp->actable_offset[m],SEEK_SET);\n\t\t\tp=TIFFReadFile(tif,o,16);\n\t\t\tif (p!=16)\n\t\t\t\treturn(0);\n\t\t\tq=0;\n\t\t\tfor (n=0; n<16; n++)\n\t\t\t\tq+=o[n];\n\t\t\tra=sizeof(uint32)+21+q;\n\t\t\trb=_TIFFmalloc(ra);\n\t\t\tif (rb==0)\n\t\t\t{\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Out of memory\");\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\t*(uint32*)rb=ra;\n\t\t\trb[sizeof(uint32)]=255;\n\t\t\trb[sizeof(uint32)+1]=JPEG_MARKER_DHT;\n\t\t\trb[sizeof(uint32)+2]=((19+q)>>8);\n\t\t\trb[sizeof(uint32)+3]=((19+q)&255);\n\t\t\trb[sizeof(uint32)+4]=(16|m);\n\t\t\tfor (n=0; n<16; n++)\n\t\t\t\trb[sizeof(uint32)+5+n]=o[n];\n\t\t\tp=TIFFReadFile(tif,&(rb[sizeof(uint32)+21]),q);\n\t\t\tif (p!=q)\n\t\t\t\treturn(0);\n\t\t\tsp->actable[m]=rb;\n\t\t\tsp->sos_tda[m]=(sp->sos_tda[m]|m);\n\t\t}\n\t\telse\n\t\t\tsp->sos_tda[m]=(sp->sos_tda[m]|(sp->sos_tda[m-1]&15));\n\t}\n\treturn(1);\n}\n\nstatic int\nOJPEGReadBufferFill(OJPEGState* sp)\n{\n\tuint16 m;\n\ttsize_t n;\n\t/* TODO: double-check: when subsamplingcorrect is set, no call to TIFFErrorExt or TIFFWarningExt should be made\n\t * in any other case, seek or read errors should be passed through */\n\tdo\n\t{\n\t\tif (sp->in_buffer_file_togo!=0)\n\t\t{\n\t\t\tif (sp->in_buffer_file_pos_log==0)\n\t\t\t{\n\t\t\t\tTIFFSeekFile(sp->tif,sp->in_buffer_file_pos,SEEK_SET);\n\t\t\t\tsp->in_buffer_file_pos_log=1;\n\t\t\t}\n\t\t\tm=OJPEG_BUFFER;\n\t\t\tif (m>sp->in_buffer_file_togo)\n\t\t\t\tm=(uint16)sp->in_buffer_file_togo;\n\t\t\tn=TIFFReadFile(sp->tif,sp->in_buffer,(tsize_t)m);\n\t\t\tif (n==0)\n\t\t\t\treturn(0);\n\t\t\tassert(n>0);\n\t\t\tassert(n<=OJPEG_BUFFER);\n\t\t\tassert(n<65536);\n\t\t\tassert((uint16)n<=sp->in_buffer_file_togo);\n\t\t\tm=(uint16)n;\n\t\t\tsp->in_buffer_togo=m;\n\t\t\tsp->in_buffer_cur=sp->in_buffer;\n\t\t\tsp->in_buffer_file_togo-=m;\n\t\t\tsp->in_buffer_file_pos+=m;\n\t\t\tbreak;\n\t\t}\n\t\tsp->in_buffer_file_pos_log=0;\n\t\tswitch(sp->in_buffer_source)\n\t\t{\n\t\t\tcase osibsNotSetYet:\n\t\t\t\tif (sp->jpeg_interchange_format!=0)\n\t\t\t\t{\n\t\t\t\t\tsp->in_buffer_file_pos=sp->jpeg_interchange_format;\n\t\t\t\t\tsp->in_buffer_file_togo=sp->jpeg_interchange_format_length;\n\t\t\t\t}\n\t\t\t\tsp->in_buffer_source=osibsJpegInterchangeFormat;\n\t\t\t\tbreak;\n\t\t\tcase osibsJpegInterchangeFormat:\n\t\t\t\tsp->in_buffer_source=osibsStrile;\n\t\t\tcase osibsStrile:\n\t\t\t\tif (sp->in_buffer_next_strile==sp->in_buffer_strile_count)  \n\t\t\t\t\tsp->in_buffer_source=osibsEof;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (sp->tif->tif_dir.td_stripoffset == 0) {\n\t\t\t\t\t\tTIFFErrorExt(sp->tif->tif_clientdata,sp->tif->tif_name,\"Strip offsets are missing\");\n\t\t\t\t\t\treturn(0);\n\t\t\t\t\t}\n\t\t\t\t\tsp->in_buffer_file_pos=sp->tif->tif_dir.td_stripoffset[sp->in_buffer_next_strile];  \n\t\t\t\t\tif (sp->in_buffer_file_pos!=0)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (sp->in_buffer_file_pos>=sp->file_size)\n\t\t\t\t\t\t\tsp->in_buffer_file_pos=0;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n                            sp->in_buffer_file_togo=0;\n                            if (sp->tif->tif_dir.td_stripbytecount)\n                                sp->in_buffer_file_togo=sp->tif->tif_dir.td_stripbytecount[sp->in_buffer_next_strile];\n\t\t\t\t\t\t\tif (sp->in_buffer_file_togo==0)\n\t\t\t\t\t\t\t\tsp->in_buffer_file_pos=0;\n\t\t\t\t\t\t\telse if (sp->in_buffer_file_pos+sp->in_buffer_file_togo>sp->file_size)\n\t\t\t\t\t\t\t\tsp->in_buffer_file_togo=sp->file_size-sp->in_buffer_file_pos;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tsp->in_buffer_next_strile++;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn(0);\n\t\t}\n\t} while (1);\n\treturn(1);\n}\n\nstatic int\nOJPEGReadByte(OJPEGState* sp, uint8* byte)\n{\n\tif (sp->in_buffer_togo==0)\n\t{\n\t\tif (OJPEGReadBufferFill(sp)==0)\n\t\t\treturn(0);\n\t\tassert(sp->in_buffer_togo>0);\n\t}\n\t*byte=*(sp->in_buffer_cur);\n\tsp->in_buffer_cur++;\n\tsp->in_buffer_togo--;\n\treturn(1);\n}\n\nstatic int\nOJPEGReadBytePeek(OJPEGState* sp, uint8* byte)\n{\n\tif (sp->in_buffer_togo==0)\n\t{\n\t\tif (OJPEGReadBufferFill(sp)==0)\n\t\t\treturn(0);\n\t\tassert(sp->in_buffer_togo>0);\n\t}\n\t*byte=*(sp->in_buffer_cur);\n\treturn(1);\n}\n\nstatic void\nOJPEGReadByteAdvance(OJPEGState* sp)\n{\n\tassert(sp->in_buffer_togo>0);\n\tsp->in_buffer_cur++;\n\tsp->in_buffer_togo--;\n}\n\nstatic int\nOJPEGReadWord(OJPEGState* sp, uint16* word)\n{\n\tuint8 m;\n\tif (OJPEGReadByte(sp,&m)==0)\n\t\treturn(0);\n\t*word=(m<<8);\n\tif (OJPEGReadByte(sp,&m)==0)\n\t\treturn(0);\n\t*word|=m;\n\treturn(1);\n}\n\nstatic int\nOJPEGReadBlock(OJPEGState* sp, uint16 len, void* mem)\n{\n\tuint16 mlen;\n\tuint8* mmem;\n\tuint16 n;\n\tassert(len>0);\n\tmlen=len;\n\tmmem=mem;\n\tdo\n\t{\n\t\tif (sp->in_buffer_togo==0)\n\t\t{\n\t\t\tif (OJPEGReadBufferFill(sp)==0)\n\t\t\t\treturn(0);\n\t\t\tassert(sp->in_buffer_togo>0);\n\t\t}\n\t\tn=mlen;\n\t\tif (n>sp->in_buffer_togo)\n\t\t\tn=sp->in_buffer_togo;\n\t\t_TIFFmemcpy(mmem,sp->in_buffer_cur,n);\n\t\tsp->in_buffer_cur+=n;\n\t\tsp->in_buffer_togo-=n;\n\t\tmlen-=n;\n\t\tmmem+=n;\n\t} while(mlen>0);\n\treturn(1);\n}\n\nstatic void\nOJPEGReadSkip(OJPEGState* sp, uint16 len)\n{\n\tuint16 m;\n\tuint16 n;\n\tm=len;\n\tn=m;\n\tif (n>sp->in_buffer_togo)\n\t\tn=sp->in_buffer_togo;\n\tsp->in_buffer_cur+=n;\n\tsp->in_buffer_togo-=n;\n\tm-=n;\n\tif (m>0)\n\t{\n\t\tassert(sp->in_buffer_togo==0);\n\t\tn=m;\n\t\tif (n>sp->in_buffer_file_togo)\n\t\t\tn=sp->in_buffer_file_togo;\n\t\tsp->in_buffer_file_pos+=n;\n\t\tsp->in_buffer_file_togo-=n;\n\t\tsp->in_buffer_file_pos_log=0;\n\t\t/* we don't skip past jpeginterchangeformat/strile block...\n\t\t * if that is asked from us, we're dealing with totally bazurk\n\t\t * data anyway, and we've not seen this happening on any\n\t\t * testfile, so we might as well likely cause some other\n\t\t * meaningless error to be passed at some later time\n\t\t */\n\t}\n}\n\nstatic int\nOJPEGWriteStream(TIFF* tif, void** mem, uint32* len)\n{\n\tOJPEGState* sp=(OJPEGState*)tif->tif_data;\n\t*len=0;\n\tdo\n\t{\n\t\tassert(sp->out_state<=ososEoi);\n\t\tswitch(sp->out_state)\n\t\t{\n\t\t\tcase ososSoi:\n\t\t\t\tOJPEGWriteStreamSoi(tif,mem,len);\n\t\t\t\tbreak;\n\t\t\tcase ososQTable0:\n\t\t\t\tOJPEGWriteStreamQTable(tif,0,mem,len);\n\t\t\t\tbreak;\n\t\t\tcase ososQTable1:\n\t\t\t\tOJPEGWriteStreamQTable(tif,1,mem,len);\n\t\t\t\tbreak;\n\t\t\tcase ososQTable2:\n\t\t\t\tOJPEGWriteStreamQTable(tif,2,mem,len);\n\t\t\t\tbreak;\n\t\t\tcase ososQTable3:\n\t\t\t\tOJPEGWriteStreamQTable(tif,3,mem,len);\n\t\t\t\tbreak;\n\t\t\tcase ososDcTable0:\n\t\t\t\tOJPEGWriteStreamDcTable(tif,0,mem,len);\n\t\t\t\tbreak;\n\t\t\tcase ososDcTable1:\n\t\t\t\tOJPEGWriteStreamDcTable(tif,1,mem,len);\n\t\t\t\tbreak;\n\t\t\tcase ososDcTable2:\n\t\t\t\tOJPEGWriteStreamDcTable(tif,2,mem,len);\n\t\t\t\tbreak;\n\t\t\tcase ososDcTable3:\n\t\t\t\tOJPEGWriteStreamDcTable(tif,3,mem,len);\n\t\t\t\tbreak;\n\t\t\tcase ososAcTable0:\n\t\t\t\tOJPEGWriteStreamAcTable(tif,0,mem,len);\n\t\t\t\tbreak;\n\t\t\tcase ososAcTable1:\n\t\t\t\tOJPEGWriteStreamAcTable(tif,1,mem,len);\n\t\t\t\tbreak;\n\t\t\tcase ososAcTable2:\n\t\t\t\tOJPEGWriteStreamAcTable(tif,2,mem,len);\n\t\t\t\tbreak;\n\t\t\tcase ososAcTable3:\n\t\t\t\tOJPEGWriteStreamAcTable(tif,3,mem,len);\n\t\t\t\tbreak;\n\t\t\tcase ososDri:\n\t\t\t\tOJPEGWriteStreamDri(tif,mem,len);\n\t\t\t\tbreak;\n\t\t\tcase ososSof:\n\t\t\t\tOJPEGWriteStreamSof(tif,mem,len);\n\t\t\t\tbreak;\n\t\t\tcase ososSos:\n\t\t\t\tOJPEGWriteStreamSos(tif,mem,len);\n\t\t\t\tbreak;\n\t\t\tcase ososCompressed:\n\t\t\t\tif (OJPEGWriteStreamCompressed(tif,mem,len)==0)\n\t\t\t\t\treturn(0);\n\t\t\t\tbreak;\n\t\t\tcase ososRst:\n\t\t\t\tOJPEGWriteStreamRst(tif,mem,len);\n\t\t\t\tbreak;\n\t\t\tcase ososEoi:\n\t\t\t\tOJPEGWriteStreamEoi(tif,mem,len);\n\t\t\t\tbreak;\n\t\t}\n\t} while (*len==0);\n\treturn(1);\n}\n\nstatic void\nOJPEGWriteStreamSoi(TIFF* tif, void** mem, uint32* len)\n{\n\tOJPEGState* sp=(OJPEGState*)tif->tif_data;\n\tassert(OJPEG_BUFFER>=2);\n\tsp->out_buffer[0]=255;\n\tsp->out_buffer[1]=JPEG_MARKER_SOI;\n\t*len=2;\n\t*mem=(void*)sp->out_buffer;\n\tsp->out_state++;\n}\n\nstatic void\nOJPEGWriteStreamQTable(TIFF* tif, uint8 table_index, void** mem, uint32* len)\n{\n\tOJPEGState* sp=(OJPEGState*)tif->tif_data;\n\tif (sp->qtable[table_index]!=0)\n\t{\n\t\t*mem=(void*)(sp->qtable[table_index]+sizeof(uint32));\n\t\t*len=*((uint32*)sp->qtable[table_index])-sizeof(uint32);\n\t}\n\tsp->out_state++;\n}\n\nstatic void\nOJPEGWriteStreamDcTable(TIFF* tif, uint8 table_index, void** mem, uint32* len)\n{\n\tOJPEGState* sp=(OJPEGState*)tif->tif_data;\n\tif (sp->dctable[table_index]!=0)\n\t{\n\t\t*mem=(void*)(sp->dctable[table_index]+sizeof(uint32));\n\t\t*len=*((uint32*)sp->dctable[table_index])-sizeof(uint32);\n\t}\n\tsp->out_state++;\n}\n\nstatic void\nOJPEGWriteStreamAcTable(TIFF* tif, uint8 table_index, void** mem, uint32* len)\n{\n\tOJPEGState* sp=(OJPEGState*)tif->tif_data;\n\tif (sp->actable[table_index]!=0)\n\t{\n\t\t*mem=(void*)(sp->actable[table_index]+sizeof(uint32));\n\t\t*len=*((uint32*)sp->actable[table_index])-sizeof(uint32);\n\t}\n\tsp->out_state++;\n}\n\nstatic void\nOJPEGWriteStreamDri(TIFF* tif, void** mem, uint32* len)\n{\n\tOJPEGState* sp=(OJPEGState*)tif->tif_data;\n\tassert(OJPEG_BUFFER>=6);\n\tif (sp->restart_interval!=0)\n\t{\n\t\tsp->out_buffer[0]=255;\n\t\tsp->out_buffer[1]=JPEG_MARKER_DRI;\n\t\tsp->out_buffer[2]=0;\n\t\tsp->out_buffer[3]=4;\n\t\tsp->out_buffer[4]=(sp->restart_interval>>8);\n\t\tsp->out_buffer[5]=(sp->restart_interval&255);\n\t\t*len=6;\n\t\t*mem=(void*)sp->out_buffer;\n\t}\n\tsp->out_state++;\n}\n\nstatic void\nOJPEGWriteStreamSof(TIFF* tif, void** mem, uint32* len)\n{\n\tOJPEGState* sp=(OJPEGState*)tif->tif_data;\n\tuint8 m;\n\tassert(OJPEG_BUFFER>=2+8+sp->samples_per_pixel_per_plane*3);\n\tassert(255>=8+sp->samples_per_pixel_per_plane*3);\n\tsp->out_buffer[0]=255;\n\tsp->out_buffer[1]=sp->sof_marker_id;\n\t/* Lf */\n\tsp->out_buffer[2]=0;\n\tsp->out_buffer[3]=8+sp->samples_per_pixel_per_plane*3;\n\t/* P */\n\tsp->out_buffer[4]=8;\n\t/* Y */\n\tsp->out_buffer[5]=(sp->sof_y>>8);\n\tsp->out_buffer[6]=(sp->sof_y&255);\n\t/* X */\n\tsp->out_buffer[7]=(sp->sof_x>>8);\n\tsp->out_buffer[8]=(sp->sof_x&255);\n\t/* Nf */\n\tsp->out_buffer[9]=sp->samples_per_pixel_per_plane;\n\tfor (m=0; m<sp->samples_per_pixel_per_plane; m++)\n\t{\n\t\t/* C */\n\t\tsp->out_buffer[10+m*3]=sp->sof_c[sp->plane_sample_offset+m];\n\t\t/* H and V */\n\t\tsp->out_buffer[10+m*3+1]=sp->sof_hv[sp->plane_sample_offset+m];\n\t\t/* Tq */\n\t\tsp->out_buffer[10+m*3+2]=sp->sof_tq[sp->plane_sample_offset+m];\n\t}\n\t*len=10+sp->samples_per_pixel_per_plane*3;\n\t*mem=(void*)sp->out_buffer;\n\tsp->out_state++;\n}\n\nstatic void\nOJPEGWriteStreamSos(TIFF* tif, void** mem, uint32* len)\n{\n\tOJPEGState* sp=(OJPEGState*)tif->tif_data;\n\tuint8 m;\n\tassert(OJPEG_BUFFER>=2+6+sp->samples_per_pixel_per_plane*2);\n\tassert(255>=6+sp->samples_per_pixel_per_plane*2);\n\tsp->out_buffer[0]=255;\n\tsp->out_buffer[1]=JPEG_MARKER_SOS;\n\t/* Ls */\n\tsp->out_buffer[2]=0;\n\tsp->out_buffer[3]=6+sp->samples_per_pixel_per_plane*2;\n\t/* Ns */\n\tsp->out_buffer[4]=sp->samples_per_pixel_per_plane;\n\tfor (m=0; m<sp->samples_per_pixel_per_plane; m++)\n\t{\n\t\t/* Cs */\n\t\tsp->out_buffer[5+m*2]=sp->sos_cs[sp->plane_sample_offset+m];\n\t\t/* Td and Ta */\n\t\tsp->out_buffer[5+m*2+1]=sp->sos_tda[sp->plane_sample_offset+m];\n\t}\n\t/* Ss */\n\tsp->out_buffer[5+sp->samples_per_pixel_per_plane*2]=0;\n\t/* Se */\n\tsp->out_buffer[5+sp->samples_per_pixel_per_plane*2+1]=63;\n\t/* Ah and Al */\n\tsp->out_buffer[5+sp->samples_per_pixel_per_plane*2+2]=0;\n\t*len=8+sp->samples_per_pixel_per_plane*2;\n\t*mem=(void*)sp->out_buffer;\n\tsp->out_state++;\n}\n\nstatic int\nOJPEGWriteStreamCompressed(TIFF* tif, void** mem, uint32* len)\n{\n\tOJPEGState* sp=(OJPEGState*)tif->tif_data;\n\tif (sp->in_buffer_togo==0)\n\t{\n\t\tif (OJPEGReadBufferFill(sp)==0)\n\t\t\treturn(0);\n\t\tassert(sp->in_buffer_togo>0);\n\t}\n\t*len=sp->in_buffer_togo;\n\t*mem=(void*)sp->in_buffer_cur;\n\tsp->in_buffer_togo=0;\n\tif (sp->in_buffer_file_togo==0)\n\t{\n\t\tswitch(sp->in_buffer_source)\n\t\t{\n\t\t\tcase osibsStrile:\n\t\t\t\tif (sp->in_buffer_next_strile<sp->in_buffer_strile_count)  \n\t\t\t\t\tsp->out_state=ososRst;\n\t\t\t\telse\n\t\t\t\t\tsp->out_state=ososEoi;\n\t\t\t\tbreak;\n\t\t\tcase osibsEof:\n\t\t\t\tsp->out_state=ososEoi;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn(1);\n}\n\nstatic void\nOJPEGWriteStreamRst(TIFF* tif, void** mem, uint32* len)\n{\n\tOJPEGState* sp=(OJPEGState*)tif->tif_data;\n\tassert(OJPEG_BUFFER>=2);\n\tsp->out_buffer[0]=255;\n\tsp->out_buffer[1]=JPEG_MARKER_RST0+sp->restart_index;\n\tsp->restart_index++;\n\tif (sp->restart_index==8)\n\t\tsp->restart_index=0;\n\t*len=2;\n\t*mem=(void*)sp->out_buffer;\n\tsp->out_state=ososCompressed;\n}\n\nstatic void\nOJPEGWriteStreamEoi(TIFF* tif, void** mem, uint32* len)\n{\n\tOJPEGState* sp=(OJPEGState*)tif->tif_data;\n\tassert(OJPEG_BUFFER>=2);\n\tsp->out_buffer[0]=255;\n\tsp->out_buffer[1]=JPEG_MARKER_EOI;\n\t*len=2;\n\t*mem=(void*)sp->out_buffer;\n}\n\n#ifndef LIBJPEG_ENCAP_EXTERNAL\nstatic int\njpeg_create_decompress_encap(OJPEGState* sp, jpeg_decompress_struct* cinfo)\n{\n\treturn(SETJMP(sp->exit_jmpbuf)?0:(jpeg_create_decompress(cinfo),1));\n}\n#endif\n\n#ifndef LIBJPEG_ENCAP_EXTERNAL\nstatic int\njpeg_read_header_encap(OJPEGState* sp, jpeg_decompress_struct* cinfo, uint8 require_image)\n{\n\treturn(SETJMP(sp->exit_jmpbuf)?0:(jpeg_read_header(cinfo,require_image),1));\n}\n#endif\n\n#ifndef LIBJPEG_ENCAP_EXTERNAL\nstatic int\njpeg_start_decompress_encap(OJPEGState* sp, jpeg_decompress_struct* cinfo)\n{\n\treturn(SETJMP(sp->exit_jmpbuf)?0:(jpeg_start_decompress(cinfo),1));\n}\n#endif\n\n#ifndef LIBJPEG_ENCAP_EXTERNAL\nstatic int\njpeg_read_scanlines_encap(OJPEGState* sp, jpeg_decompress_struct* cinfo, void* scanlines, uint32 max_lines)\n{\n\treturn(SETJMP(sp->exit_jmpbuf)?0:(jpeg_read_scanlines(cinfo,scanlines,max_lines),1));\n}\n#endif\n\n#ifndef LIBJPEG_ENCAP_EXTERNAL\nstatic int\njpeg_read_raw_data_encap(OJPEGState* sp, jpeg_decompress_struct* cinfo, void* data, uint32 max_lines)\n{\n\treturn(SETJMP(sp->exit_jmpbuf)?0:(jpeg_read_raw_data(cinfo,data,max_lines),1));\n}\n#endif\n\n#ifndef LIBJPEG_ENCAP_EXTERNAL\nstatic void\njpeg_encap_unwind(TIFF* tif)\n{\n\tOJPEGState* sp=(OJPEGState*)tif->tif_data;\n\tLONGJMP(sp->exit_jmpbuf,1);\n}\n#endif\n\nstatic void\nOJPEGLibjpegJpegErrorMgrOutputMessage(jpeg_common_struct* cinfo)\n{\n\tchar buffer[JMSG_LENGTH_MAX];\n\t(*cinfo->err->format_message)(cinfo,buffer);\n\tTIFFWarningExt(((TIFF*)(cinfo->client_data))->tif_clientdata,\"LibJpeg\", \"%s\", buffer);\n}\n\nstatic void\nOJPEGLibjpegJpegErrorMgrErrorExit(jpeg_common_struct* cinfo)\n{\n\tchar buffer[JMSG_LENGTH_MAX];\n\t(*cinfo->err->format_message)(cinfo,buffer);\n\tTIFFErrorExt(((TIFF*)(cinfo->client_data))->tif_clientdata,\"LibJpeg\", \"%s\", buffer);\n\tjpeg_encap_unwind((TIFF*)(cinfo->client_data));\n}\n\nstatic void\nOJPEGLibjpegJpegSourceMgrInitSource(jpeg_decompress_struct* cinfo)\n{\n\t(void)cinfo;\n}\n\nstatic boolean\nOJPEGLibjpegJpegSourceMgrFillInputBuffer(jpeg_decompress_struct* cinfo)\n{\n\tTIFF* tif=(TIFF*)cinfo->client_data;\n\tOJPEGState* sp=(OJPEGState*)tif->tif_data;\n\tvoid* mem=0;\n\tuint32 len=0;\n\tif (OJPEGWriteStream(tif,&mem,&len)==0)\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata,\"LibJpeg\",\"Premature end of JPEG data\");\n\t\tjpeg_encap_unwind(tif);\n\t}\n\tsp->libjpeg_jpeg_source_mgr.bytes_in_buffer=len;\n\tsp->libjpeg_jpeg_source_mgr.next_input_byte=mem;\n\treturn(1);\n}\n\nstatic void\nOJPEGLibjpegJpegSourceMgrSkipInputData(jpeg_decompress_struct* cinfo, long num_bytes)\n{\n\tTIFF* tif=(TIFF*)cinfo->client_data;\n\t(void)num_bytes;\n\tTIFFErrorExt(tif->tif_clientdata,\"LibJpeg\",\"Unexpected error\");\n\tjpeg_encap_unwind(tif);\n}\n\nstatic boolean\nOJPEGLibjpegJpegSourceMgrResyncToRestart(jpeg_decompress_struct* cinfo, int desired)\n{\n\tTIFF* tif=(TIFF*)cinfo->client_data;\n\t(void)desired;\n\tTIFFErrorExt(tif->tif_clientdata,\"LibJpeg\",\"Unexpected error\");\n\tjpeg_encap_unwind(tif);\n\treturn(0);\n}\n\nstatic void\nOJPEGLibjpegJpegSourceMgrTermSource(jpeg_decompress_struct* cinfo)\n{\n\t(void)cinfo;\n}\n\n#endif\n\n\n/*\n * Local Variables:\n * mode: c\n * c-basic-offset: 8\n * fill-column: 78\n * End:\n */\n", "\ufeff/*\n * (c) Copyright Ascensio System SIA 2010-2019\n *\n * This program is a free software product. You can redistribute it and/or\n * modify it under the terms of the GNU Affero General Public License (AGPL)\n * version 3 as published by the Free Software Foundation. In accordance with\n * Section 7(a) of the GNU AGPL its Section 15 shall be amended to the effect\n * that Ascensio System SIA expressly excludes the warranty of non-infringement\n * of any third-party rights.\n *\n * This program is distributed WITHOUT ANY WARRANTY; without even the implied\n * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR  PURPOSE. For\n * details, see the GNU AGPL at: http://www.gnu.org/licenses/agpl-3.0.html\n *\n * You can contact Ascensio System SIA at 20A-12 Ernesta Birznieka-Upisha\n * street, Riga, Latvia, EU, LV-1050.\n *\n * The  interactive user interfaces in modified source and object code versions\n * of the Program must display Appropriate Legal Notices, as required under\n * Section 5 of the GNU AGPL version 3.\n *\n * Pursuant to Section 7(b) of the License you must retain the original Product\n * logo when distributing the program. Pursuant to Section 7(e) we decline to\n * grant you any rights under trademark law for use of our trademarks.\n *\n * All the Product's GUI elements, including illustrations and icon sets, as\n * well as technical writing content are licensed under the terms of the\n * Creative Commons Attribution-ShareAlike 4.0 International. See the License\n * terms at http://creativecommons.org/licenses/by-sa/4.0/legalcode\n *\n */\n#include <stdlib.h>\n#include <string.h>\n#include \"MemoryUtils.h\"\n#include \"FontFileEncodings.h\"\n#include \"FontFileType1.h\"\n\nnamespace NSFontConverter\n{\n    #define LINESIZE 1024\n\n    #define PFB_MARKER 128\n    #define PFB_ASCII    1\n    #define PFB_BINARY   2\n    #define PFB_DONE     3\n\n\n    #define IS_PS_NEWLINE( ch ) \\\n      ( (ch) == '\\r' ||         \\\n        (ch) == '\\n' )\n\n    #define IS_PS_SPACE( ch )  \\\n      ( (ch) == ' '         || \\\n        IS_PS_NEWLINE( ch ) || \\\n        (ch) == '\\t'        || \\\n        (ch) == '\\f'        || \\\n        (ch) == '\\0' )\n\n    // \u0422\u0430\u0431\u043b\u0438\u0446\u0430 \u0434\u043b\u044f \u0431\u044b\u0441\u0442\u0440\u043e\u0433\u043e \u043a\u043e\u043d\u0432\u0435\u0440\u0442\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u0446\u0438\u0444\u0440 (\u0434\u0435\u0441\u044f\u0442\u0438\u0447\u043d\u044b\u0445 \u0438 \u043d\u0435 \u0434\u0435\u0441\u044f\u0442\u0438\u0447\u043d\u044b\u0445) \u0432 \u0447\u0438\u0441\u043b\u0430\n    static const signed char c_arrCharTable[128] =\n    {\n        /* 0x00 */\n        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n         0,  1,  2,  3,  4,  5,  6,  7,  8,  9, -1, -1, -1, -1, -1, -1,\n        -1, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, -1, -1, -1, -1, -1,\n        -1, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, -1, -1, -1, -1, -1,\n    };\n\n    // \u041d\u0438 \u043e\u0434\u0438\u043d \u0441\u0438\u043c\u0432\u043e\u043b \u0431\u043e\u043b\u044c\u0448\u0435 >= 0x80 \u043d\u0435 \u043c\u043e\u0436\u0435\u0442 \u043f\u0440\u0435\u0434\u0441\u0442\u0430\u0432\u043b\u044f\u0442\u044c \u0447\u0438\u0441\u043b\u043e\n    #define OP  >=\n\n    #define WriteChar(Value) \\\n        nChar = (char)(Value);\\\n        pOutputFunc( pOutputStream, &nChar, 1 );\n\n    unsigned int EexecDecode   (unsigned char** cursor, unsigned char* limit, unsigned char* buffer, unsigned int n, unsigned short* seed )\n    {\n        unsigned char*  p;\n        unsigned int r;\n        unsigned int s = *seed;\n\n        p = *cursor;\n        if ( n > (unsigned int)(limit - p) )\n          n = (unsigned int)(limit - p);\n\n        for ( r = 0; r < n; r++ )\n        {\n          unsigned int  val = p[r];\n          unsigned int  b   = ( val ^ ( s >> 8 ) );\n\n\n          s         = ( (val + s)*52845U + 22719 ) & 0xFFFFU;\n          buffer[r] = (unsigned char) b;\n        }\n\n        *cursor = p + n;\n        *seed   = (unsigned short)s;\n\n        return r;\n      }\n\n    unsigned int ASCIIHexDecode(unsigned char** cursor, unsigned char* limit, unsigned char* buffer, unsigned int n)\n    {\n        unsigned char*  p;\n        unsigned int  r   = 0;\n        unsigned int  w   = 0;\n        unsigned int  pad = 0x01;\n\n\n        n *= 2;\n\n        p  = *cursor;\n        if ( n > (unsigned int)( limit - p ) )\n          n = (unsigned int)( limit - p );\n\n        /* we try to process two nibbles at a time to be as fast as possible */\n        for ( ; r < n; r++ )\n        {\n          FT_UInt  c = p[r];\n\n\n          if ( IS_PS_SPACE( c ) )\n            continue;\n\n          if ( c OP 0x80 )\n            break;\n\n          c = c_arrCharTable[c & 0x7F];\n          if ( (unsigned)c >= 16 )\n            break;\n\n          pad = ( pad << 4 ) | c;\n          if ( pad & 0x100 )\n          {\n            buffer[w++] = (FT_Byte)pad;\n            pad         = 0x01;\n          }\n        }\n\n        if ( pad != 0x01 )\n          buffer[w++] = (FT_Byte)( pad << 4 );\n\n        *cursor = p + r;\n\n        return w;\n      }\n    //------------------------------------------------------------------------\n    // CFontFileType1\n    //------------------------------------------------------------------------\n\n    CFontFileType1 *CFontFileType1::LoadFromBuffer(char *sBuffer, int nLen)\n    {\n        return new CFontFileType1(sBuffer, nLen, false);\n    }\n\n    CFontFileType1 *CFontFileType1::LoadFromFile(const wchar_t *wsFileName)\n    {\n        char *sBuffer;\n        int nLen = 0;\n\n        if ( !( sBuffer = CFontFileBase::ReadFile(wsFileName, &nLen) ) )\n            return NULL;\n\n        return new CFontFileType1(sBuffer, nLen, true);\n    }\n\n    CFontFileType1::CFontFileType1(char *sBuffer, int nLen, bool bFreeData):\n    CFontFileBase(sBuffer, nLen, bFreeData)\n    {\n        m_sName = NULL;\n        m_arrEncoding = NULL;\n\n        Parse();\n        m_bParsed = false;\n    }\n\n    CFontFileType1::~CFontFileType1()\n    {\n        if (m_sName)\n            MemUtilsFree(m_sName);\n\n        if ( m_arrEncoding && m_arrEncoding != c_arrsFontFileType1StandardEncoding )\n        {\n            for (int nIndex = 0; nIndex < 256; ++nIndex )\n            {\n                MemUtilsFree( m_arrEncoding[nIndex] );\n            }\n            MemUtilsFree(m_arrEncoding);\n        }\n    }\n\n    char *CFontFileType1::GetName()\n    {\n        if ( !m_bParsed )\n            Parse();\n\n        return m_sName;\n    }\n\n    char **CFontFileType1::GetEncoding()\n    {\n        if (!m_bParsed)\n            Parse();\n\n        return m_arrEncoding;\n    }\n\n    void CFontFileType1::WriteEncoded(char **ppNewEncoding, FontFileOutputFunc pOutputFunc, void *pOutputStream)\n    {\n        char sBuffer[512];\n        char *sLine, *sLine2, *sCurChar;\n\n        // \u043a\u043e\u043f\u0438\u0440\u0443\u0435\u043c \u0432\u0441\u0435 \u0434\u043e \u0441\u0442\u0440\u043e\u0447\u043a\u0438 /Encoding\n        for ( sLine = (char *)m_sFile; sLine && strncmp( sLine, \"/Encoding\", 9); sLine = GetNextLine(sLine) );\n        if ( !sLine )\n        {\n            // \u043d\u0435 \u043d\u0430\u0448\u043b\u0438 \u043a\u043e\u0434\u0438\u0440\u043e\u0432\u043a\u0443, \u0442\u043e\u0433\u0434\u0430 \u043a\u043e\u043f\u0438\u0440\u0443\u0435\u043c \u0446\u0435\u043b\u0438\u043a\u043e\u043c \u0444\u043e\u043d\u0442 \u0444\u0430\u0439\u043b\n            (*pOutputFunc)( pOutputStream, (char *)m_sFile, m_nLen);\n            return;\n        }\n        (*pOutputFunc)( pOutputStream, (char *)m_sFile, sLine - (char *)m_sFile);\n\n        // \u043f\u0438\u0448\u0435\u043c \u043d\u043e\u0432\u0443\u044e \u043a\u043e\u0434\u0438\u0440\u043e\u0432\u043a\u0443\n        (*pOutputFunc)( pOutputStream, \"/Encoding 256 array\\n\", 20);\n        (*pOutputFunc)( pOutputStream, \"0 1 255 {1 index exch /.notdef put} for\\n\", 40);\n        for ( int nIndex = 0; nIndex < 256; ++nIndex )\n        {\n            if (ppNewEncoding[nIndex])\n            {\n                sprintf( sBuffer, \"dup %d /%s put\\n\", nIndex, ppNewEncoding[nIndex]);\n                (*pOutputFunc)( pOutputStream, sBuffer, strlen( sBuffer ));\n            }\n        }\n        (*pOutputFunc)( pOutputStream, \"readonly def\\n\", 13);\n\n        if ( !strncmp( sLine, \"/Encoding StandardEncoding def\", 30) )\n        {\n            sLine = GetNextLine(sLine);\n        }\n        else\n        {\n            sCurChar = sLine + 10;\n            sLine = NULL;\n            for (; sCurChar < (char *)m_sFile + m_nLen; ++sCurChar)\n            {\n                if ((*sCurChar == ' ' || *sCurChar == '\\t' || *sCurChar == '\\x0a' || *sCurChar == '\\x0d' || *sCurChar == '\\x0c' || *sCurChar == '\\0') && sCurChar + 4 <= (char *)m_sFile + m_nLen && !strncmp(sCurChar + 1, \"def\", 3) )\n                {\n                    sLine = sCurChar + 4;\n                    break;\n                }\n            }\n        }\n\n        // \u0423 \u043d\u0435\u043a\u043e\u0442\u043e\u0440\u044b\u0445 \u0444\u043e\u043d\u0442\u043e\u0432 \u0434\u0432\u0435 \u0437\u0430\u043f\u0438\u0441\u0438 /Encoding, \u043f\u043e\u044d\u0442\u043e\u043c\u0443 \u043f\u0440\u043e\u0432\u0435\u0440\u044f\u0435\u043c \u043d\u0430\u043b\u0438\u0447\u0438\u0435 \u0432\u0442\u043e\u0440\u043e\u0439 \u0437\u0430\u043f\u0438\u0441\u0438\n        if ( sLine )\n        {\n            int nIndex;\n            for ( sLine2 = sLine, nIndex = 0; nIndex < 20 && sLine2 && strncmp(sLine2, \"/Encoding\", 9); sLine2 = GetNextLine(sLine2), ++nIndex) ;\n            if ( nIndex < 20 && sLine2 )\n            {\n                (*pOutputFunc)( pOutputStream, sLine, sLine2 - sLine);\n                if ( !strncmp(sLine2, \"/Encoding StandardEncoding def\", 30) )\n                {\n                    sLine = GetNextLine( sLine2 );\n                }\n                else\n                {\n                    sCurChar = sLine2 + 10;\n                    sLine = NULL;\n                    for (; sCurChar < (char *)m_sFile + m_nLen; ++sCurChar)\n                    {\n                        if ((*sCurChar == ' ' || *sCurChar == '\\t' || *sCurChar == '\\x0a' || *sCurChar == '\\x0d' || *sCurChar == '\\x0c' || *sCurChar == '\\0') && sCurChar + 4 <= (char *)m_sFile + m_nLen && !strncmp(sCurChar + 1, \"def\", 3) )\n                        {\n                            sLine = sCurChar + 4;\n                            break;\n                        }\n                    }\n                }\n            }\n\n            // \u043a\u043e\u043f\u0438\u0440\u0443\u0435\u043c \u0432\u0441\u0435 \u043f\u043e\u0441\u043b\u0435 \u043a\u043e\u0434\u0438\u0440\u043e\u0432\u043a\u0438\n            if ( sLine )\n            {\n                (*pOutputFunc)( pOutputStream, sLine, ((char *)m_sFile + m_nLen) - sLine );\n            }\n        }\n    }\n\n    char *CFontFileType1::GetNextLine(char *sLine)\n    {\n        while ( sLine < (char *)m_sFile + m_nLen && *sLine != '\\x0a' && *sLine != '\\x0d')\n            ++sLine;\n\n        if ( sLine < (char *)m_sFile + m_nLen && *sLine == '\\x0d')\n            ++sLine;\n\n        if ( sLine < (char *)m_sFile + m_nLen && *sLine == '\\x0a')\n            ++sLine;\n\n        if ( sLine >= (char *)m_sFile + m_nLen )\n            return NULL;\n\n        return sLine;\n    }\n\n    void CFontFileType1::Parse()\n    {\n        // \u0421\u043d\u0430\u0447\u0430\u043b\u0430 \u043f\u0440\u043e\u0432\u0435\u0440\u0438\u043c, \u0435\u0441\u043b\u0438 \u044d\u0442\u043e pfb \u0444\u0430\u0439\u043b, \u0442\u043e\u0433\u0434\u0430 \u0438\u0437\u0431\u0430\u0432\u0438\u043c\u0441\u044f \u043e\u0442 \u0432\u0441\u0435\u0445 \u0435\u0433\u043e \u043c\u0430\u0440\u043a\u0435\u0440\u043e\u0432.\n        Reset();\n\n        while( m_nPos < m_nLen && ( ' ' == m_sFile[m_nPos] || '\\t' == m_sFile[m_nPos] || '\\r' == m_sFile[m_nPos] || '\\n' == m_sFile[m_nPos] ) )\n            ++m_nPos;\n\n        bool bSuccess = true;\n        int nChar = GetU8( m_nPos, &bSuccess );\n        if ( !bSuccess || ( PFB_MARKER != nChar && '%' != nChar ) )\n            return;\n        else if ( PFB_MARKER == nChar )\n        {\n            if ( !RemovePfbMarkers() )\n                return;\n        }\n\n        char *sLine, *sLine1, *pCur, *pTemp;\n        char sBuffer[256];\n        int nCount, nCode;\n        int nIndex = 0;\n        unsigned char *sEexec = NULL;\n\n        m_oTopDict.arrdFontBBox[0] = 0; m_oTopDict.arrdFontBBox[1] = 0;\n        m_oTopDict.arrdFontBBox[2] = 0; m_oTopDict.arrdFontBBox[3] = 0;\n\n        m_oTopDict.arrdFontMatrix[0] = 0.001; m_oTopDict.arrdFontMatrix[1] = 0;\n        m_oTopDict.arrdFontMatrix[2] = 0;     m_oTopDict.arrdFontMatrix[3] = 0.001;\n        m_oTopDict.arrdFontMatrix[4] = 0;     m_oTopDict.arrdFontMatrix[5] = 0;\n\n        for (nIndex = 1, sLine = (char *)m_sFile; nIndex <= 100 && sLine && (!m_sName || !m_arrEncoding); ++nIndex )\n        {\n            if ( !m_sName && !strncmp( sLine, \"/FontName\", 9) )\n            {\n                strncpy( sBuffer, sLine, 255);\n                sBuffer[255] = '\\0';\n                if ( ( pCur = strchr( sBuffer + 9, '/' ) ) && ( pCur = strtok( pCur + 1, \" \\t\\n\\r\" ) ) )\n                {\n                    m_sName = CopyString( pCur );\n                }\n                sLine = GetNextLine(sLine);\n\n            }\n            else if ( !strncmp( sLine, \"/FontMatrix\", 11 ) )\n            {\n                strncpy( sBuffer, sLine, 255);\n                sBuffer[255] = '\\0';\n\n                ReadDoubleArray<6>( (unsigned char*)(sBuffer + 11), 244, m_oTopDict.arrdFontMatrix );\n                sLine = GetNextLine( sLine );\n            }\n            else if ( !strncmp( sLine, \"/FontBBox\", 9 ) )\n            {\n                strncpy( sBuffer, sLine, 255);\n                sBuffer[255] = '\\0';\n\n                ReadDoubleArray<4>( (unsigned char*)(sBuffer + 9), 246, m_oTopDict.arrdFontBBox );\n                sLine = GetNextLine( sLine );\n            }\n            else if (!m_arrEncoding && !strncmp( sLine, \"/Encoding StandardEncoding def\", 30))\n            {\n                m_arrEncoding = c_arrsFontFileType1StandardEncoding;\n            }\n            else if (!m_arrEncoding && !strncmp( sLine, \"/Encoding 256 array\", 19))\n            {\n                m_arrEncoding = (char **)MemUtilsMallocArray(256, sizeof(char *));\n                int nJ = 0;\n                for (nJ = 0; nJ < 256; ++nJ )\n                {\n                    m_arrEncoding[nJ] = NULL;\n                }\n                for (nJ = 0, sLine = GetNextLine(sLine); nJ < 300 && sLine && ( sLine1 = GetNextLine( sLine )); ++nJ, sLine = sLine1)\n                {\n                    if ( ( nCount = sLine1 - sLine ) > 255 )\n                    {\n                        nCount = 255;\n                    }\n                    strncpy( sBuffer, sLine, nCount);\n                    sBuffer[ nCount ] = '\\0';\n                    for ( pCur = sBuffer; *pCur == ' ' || *pCur == '\\t'; ++pCur );\n                    if ( !strncmp( pCur, \"dup\", 3 ) )\n                    {\n                        for ( pCur += 3; *pCur == ' ' || *pCur == '\\t'; ++pCur ) ;\n                        for ( pTemp = pCur; *pTemp >= '0' && *pTemp <= '9'; ++pTemp ) ;\n                        if ( *pTemp )\n                        {\n                            char nChar = *pTemp;\n                            *pTemp = '\\0';\n                            nCode = atoi( pCur );\n\t\t\t\t\t\t\tif (nCode < 0) nCode = 0;\t\t\t\t\t\t\t\t\n                            *pTemp = nChar;\n                            if ( nCode == 8 && *pTemp == '#')\n                            {\n                                nCode = 0;\n                                for (++pTemp; *pTemp >= '0' && *pTemp <= '7'; ++pTemp)\n                                {\n                                    nCode = nCode * 8 + (*pTemp - '0');\n                                }\n                            }\n                            if ( nCode < 256 )\n                            {\n                                for ( pCur = pTemp; *pCur == ' ' || *pCur == '\\t'; ++pCur ) ;\n                                if ( *pCur == '/')\n                                {\n                                    ++pCur;\n                                    for ( pTemp = pCur; *pTemp && *pTemp != ' ' && *pTemp != '\\t'; ++pTemp ) ;\n                                    *pTemp = '\\0';\n                                    m_arrEncoding[ nCode ] = CopyString( pCur );\n                                }\n                            }\n                        }\n                    }\n                    else\n                    {\n                        if ( strtok( sBuffer, \" \\t\") && ( pCur = strtok(NULL, \" \\t\\n\\r\")) && !strcmp( pCur, \"def\"))\n                        {\n                            break;\n                        }\n                    }\n                }\n            }\n            else\n            {\n                if ( !sEexec )\n                    sEexec = (unsigned char*)strstr( sLine, \"currentfile eexec\" );\n\n                sLine = GetNextLine(sLine);\n            }\n        }\n\n        if ( NULL != sEexec )\n        {\n            unsigned char* sTemp = sEexec;\n            while ( sTemp != (unsigned char*)strstr( (char*)sTemp, \"cleartomark\" ) && sTemp < m_sFile + m_nLen )\n                sTemp++;\n\n            int nBufferLen = sTemp - ( sEexec + 17 );\n            unsigned char *sEexecBuffer = (unsigned char*)MemUtilsMalloc( nBufferLen );\n            if ( !sEexecBuffer )\n                return;\n\n            memcpy( sEexecBuffer, sEexec + 17, nBufferLen );\n            DecryptEexec( &sEexecBuffer, nBufferLen );\n\n            sEexec = sEexecBuffer + 4; // \u041f\u0435\u0440\u0432\u044b\u0435 \u0447\u0435\u0442\u044b\u0440\u0435 \u0431\u0430\u0439\u0442\u0430 \u0431\u044b\u043b\u0438 \u0441\u043b\u0443\u0447\u0430\u0439\u043d\u044b\u043c\u0438\n            int nEexecLen = nBufferLen - 4;\n\n            // \u0422\u0435\u043f\u0435\u0440\u044c \u043f\u0440\u043e\u0447\u0438\u0442\u0430\u0435\u043c \u0441\u043e\u0434\u0435\u0440\u0436\u0438\u043c\u043e\u0435 Private Dict\n            bool bGlyphsSection = false, bSubrsSection = false;\n            //unsigned short ushChar = '';\n            std::wstring sToken, sGlyph;\n            int nLength = 0;\n\n            // \u0412\u044b\u0441\u0442\u0430\u0432\u043b\u044f\u0435\u043c \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f \u043f\u043e \u0443\u043c\u043e\u043b\u0447\u0430\u043d\u0438\u044e \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u043e\u0432 Private Dict\n            m_oPrivateDict.nBlueValues       = 0;\n            m_oPrivateDict.nOtherBlues       = 0;\n            m_oPrivateDict.nFamilyBlues      = 0;\n            m_oPrivateDict.nFamilyOtherBlues = 0;\n            m_oPrivateDict.dBlueScale        = 0.039625;\n            m_oPrivateDict.nBlueShift        = 7;\n            m_oPrivateDict.nBlueFuzz         = 1;\n            m_oPrivateDict.bHasStdHW         = false;\n            m_oPrivateDict.bHasStdVW         = false;\n            m_oPrivateDict.nStemSnapH        = 0;\n            m_oPrivateDict.nStemSnapV        = 0;\n            m_oPrivateDict.bHasForceBold     = false;\n            m_oPrivateDict.nLanguageGroup    = 0;\n            m_oPrivateDict.nLenIV            = 4;\n            m_oPrivateDict.dExpansionFactor  = 0.06;\n\n            for ( int nIndex = 0; nIndex < nEexecLen; nIndex++ )\n            {\n                unsigned char nChar = sEexec[nIndex];\n\n                if ( ( bGlyphsSection || bSubrsSection ) && 'R' == nChar && nLength > 0 )\n                {\n                    unsigned char *sData = new unsigned char[nLength];\n                    if ( sData )\n                    {\n                        memcpy( sData, sEexec + nIndex + 3, nLength );\n                        unsigned short unKey = 4330U;\n                        unsigned char *sCur = sData;\n                        EexecDecode( &sCur, sCur + nLength, sCur, nLength, &unKey );\n\n                        if ( m_oPrivateDict.nLenIV > 0 && m_oPrivateDict.nLenIV < nLength )\n                        {\n                            Type1Charstring oCharstring = DecodeCharString( sData + m_oPrivateDict.nLenIV, nLength - m_oPrivateDict.nLenIV );\n                            if ( bGlyphsSection )\n                            {\n                                int nUnicode = Type1NameToUnicodeW( sGlyph.c_str() );\n\n                                if ( 0 != nUnicode )\n                                    m_arrCharstrings.Add( Type1Glyph( sGlyph, nUnicode, oCharstring )  );\n                            }\n                            else // if ( bSubrsSection )\n                            {\n                                m_arrSubrs.Add( oCharstring );\n                            }\n                        }\n\n                        delete []sData;\n                    }\n\n                    nIndex += nLength + 3;\n                }\n                else if ( IS_PS_SPACE( nChar ) )\n                {\n                    nLength = Utils::GetInteger( sToken );\n                    sToken.clear();\n                }\n                else\n                {\n                    sToken.push_back( (wchar_t)nChar );\n                    if ( !bGlyphsSection && '/' == sToken[0] )\n                    {\n                        int nTempChar = sToken[1];\n                        switch (nTempChar)\n                        {\n                        case 'B':\n                            {\n                                if ( L\"/BlueValues\" == sToken )\n                                    m_oPrivateDict.nBlueValues = ReadIntArray<type1MaxBlueValues>( sEexec + nIndex + 2, nEexecLen - nIndex - 2, m_oPrivateDict.arrnBlueValues );\n                                else if ( L\"/BlueScale\" == sToken )\n                                    m_oPrivateDict.dBlueScale  = ReadDouble( sEexec + nIndex + 1, nEexecLen - nIndex - 1 );\n                                else if ( L\"/BlueShift\" == sToken )\n                                    m_oPrivateDict.nBlueShift  = ReadInt( sEexec + nIndex + 1, nEexecLen - nIndex - 1 );\n                                else if ( L\"/BlueFuzz\" == sToken )\n                                    m_oPrivateDict.nBlueFuzz   = ReadInt( sEexec + nIndex + 1, nEexecLen - nIndex - 1 );\n\n                                break;\n                            }\n                        case 'C':\n                            {\n                                if ( L\"/CharString\" == sToken )\n                                    bGlyphsSection = true;\n\n                                break;\n                            }\n                        case 'E':\n                            {\n                                if ( L\"/ExpansionFactor\" == sToken )\n                                    m_oPrivateDict.dExpansionFactor = ReadDouble( sEexec + nIndex + 1, nEexecLen - nIndex - 1 );\n\n                                break;\n                            }\n                        case 'F':\n                            {\n                                if ( L\"/FamilyBlues\" == sToken )\n                                    m_oPrivateDict.nFamilyBlues = ReadIntArray<type1MaxBlueValues>( sEexec + nIndex + 2, nEexecLen - nIndex - 2, m_oPrivateDict.arrnFamilyBlues );\n                                else if ( L\"/FamilyOtherBlues\" == sToken )\n                                    m_oPrivateDict.nFamilyOtherBlues = ReadIntArray<type1MaxOtherBlues>( sEexec + nIndex + 2, nEexecLen - nIndex - 2, m_oPrivateDict.arrnFamilyOtherBlues );\n                                else if ( L\"/ForceBold\" == sToken )\n                                {\n                                    m_oPrivateDict.bHasForceBold = true;\n                                    m_oPrivateDict.bForceBold = ReadBool( sEexec + nIndex + 1, nEexecLen - nIndex - 1 );\n                                }\n\n                                break;\n                            }\n                        case 'L':\n                            {\n                                if ( L\"/LanguageGroup\" == sToken )\n                                    m_oPrivateDict.nLanguageGroup = ReadInt( sEexec + nIndex + 1, nEexecLen - nIndex - 1 );\n                                else if ( L\"/lenIV\" == sToken )\n                                    m_oPrivateDict.nLenIV = ReadInt( sEexec + nIndex + 1, nEexecLen - nIndex - 1 );\n\n                                break;\n                            }\n                        case 'S':\n                            {\n                                if ( L\"/Subrs\" == sToken )\n                                    bSubrsSection = true;\n                                else if ( L\"/StemSnapH\" == sToken )\n                                    m_oPrivateDict.nStemSnapH = ReadDoubleArray<type1MaxStemSnap>( sEexec + nIndex + 2, nEexecLen - nIndex - 2, m_oPrivateDict.arrdStemSnapH );\n                                else if ( L\"/StemSnapV\" == sToken )\n                                    m_oPrivateDict.nStemSnapV = ReadDoubleArray<type1MaxStemSnap>( sEexec + nIndex + 2, nEexecLen - nIndex - 2, m_oPrivateDict.arrdStemSnapV );\n                                else if ( L\"/StdHW\" == sToken )\n                                {\n                                    // \u0417\u0434\u0435\u0441\u044c \u0441\u043e\u0434\u0435\u0440\u0436\u0438\u0442\u0441\u044f \u043c\u0430\u0441\u0441\u0438\u0432 \u0441 \u043e\u0434\u043d\u0438\u043c \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435\u043c\n                                    double dTemp[1];\n\n                                    if ( ReadDoubleArray<1>( sEexec + nIndex + 2, nEexecLen - nIndex - 2, dTemp ) > 0 )\n                                    {\n                                        m_oPrivateDict.bHasStdHW = true;\n                                        m_oPrivateDict.dStdHW = dTemp[0];\n                                    }\n                                }\n                                else if ( L\"/StdVW\" == sToken )\n                                {\n                                    // \u0417\u0434\u0435\u0441\u044c \u0441\u043e\u0434\u0435\u0440\u0436\u0438\u0442\u0441\u044f \u043c\u0430\u0441\u0441\u0438\u0432 \u0441 \u043e\u0434\u043d\u0438\u043c \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435\u043c\n                                    double dTemp[1];\n                                    if ( ReadDoubleArray<1>( sEexec + nIndex + 2, nEexecLen - nIndex - 2, dTemp ) > 0 )\n                                    {\n                                        m_oPrivateDict.bHasStdHW = true;\n                                        m_oPrivateDict.dStdVW = dTemp[0];\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    else if ( '/' == nChar  )\n                    {\n                        sToken.clear();\n                        sGlyph.clear();\n\n                        while ( nIndex < nEexecLen && ( nChar = sEexec[++nIndex] ) != ' ' )\n                            sGlyph.push_back( (wchar_t)nChar );\n                    }\n                }\n            }\n            MemUtilsFree( sEexecBuffer );\n\n            // \u041f\u0440\u043e\u0432\u0435\u0434\u0435\u043c \u0441\u043e\u0440\u0442\u0438\u0440\u043e\u0432\u043a\u0443 \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u043e\u0432 m_arrCharstrings \u043f\u043e \u044e\u043d\u0438\u043a\u043e\u0434\u043d\u043e\u043c\u0443 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044e\n            qsort( m_arrCharstrings.GetData(), m_arrCharstrings.GetSize(), sizeof(Type1Glyph), CompareType1Glyph );\n        }\n\n        m_bParsed = true;\n    }\n\n    void CFontFileType1::DecryptEexec(unsigned char** ppEexecBuffer, int nLen)\n    {\n        // \u0421\u043e\u0433\u043b\u0430\u0441\u043d\u043e \u0441\u043f\u0435\u0446\u0438\u0444\u0438\u043a\u0430\u0446\u0438\u0438 Type1, \u043f\u0435\u0440\u0432\u044b\u0439 \u0431\u0430\u0439\u0442 \u043d\u0435 \u0434\u043e\u043b\u0436\u0435\u043d \u0431\u044b\u0442\u044c ASCII \u043f\u0440\u043e\u0431\u0435\u043b\u043e\u043c\n        // (\u043f\u0440\u043e\u0431\u0435\u043b, \u0442\u0430\u0431, \u043f\u0435\u0440\u0435\u043d\u043e\u0441 \u043a\u0430\u0440\u0435\u0442\u043a\u0438 \u0438\u043b\u0438 \u043f\u0435\u0440\u0435\u043d\u043e\u0441 \u0441\u0442\u0440\u043e\u043a\u0438).\n        unsigned char *sCur = (unsigned char*)(*ppEexecBuffer);\n        while( sCur < (unsigned char*)(*ppEexecBuffer) + nLen && ( ' ' == *sCur || '\\t' == *sCur || '\\r' == *sCur || '\\n' == *sCur ) )\n        {\n            ++sCur;\n            --nLen;\n        }\n\n        // \u0422\u0435\u043f\u0435\u0440\u044c \u043d\u0430\u043c \u043d\u0430\u0434\u043e \u043e\u043f\u0440\u0435\u0434\u0435\u043b\u0438\u0442\u044c \u0432 \u043a\u0430\u043a\u043e\u043c \u0444\u043e\u0440\u043c\u0430\u0442\u0435 \u0443 \u043d\u0430\u0441 \u0434\u0430\u043d\u043d\u044b\u0435: ASKII \u0438\u043b\u0438 \u0431\u0438\u043d\u0430\u0440\u043d\u044b\u0435 \u0434\u0430\u043d\u043d\u044b\u0435.\n        // \u0415\u0441\u043b\u0438 \u043f\u0435\u0440\u0432\u044b\u0435 \u0447\u0435\u0442\u044b\u0440\u0435 \u0431\u0430\u0439\u0442\u0430 \u044f\u0432\u043b\u044f\u044e\u0442\u0441\u044f \u0448\u0435\u0441\u0442\u043d\u0430\u0434\u0446\u0430\u0442\u0438\u0440\u0438\u0447\u043d\u044b\u043c\u0438 \u0441\u0438\u043c\u0432\u043e\u043b\u0430\u043c\u0438, \u0437\u043d\u0430\u0447\u0438\u0442, \u043a\u043e\u0434\u0438\u0440\u043e\u0432\u043a\u0430 ASCII.\n        bool bASCII = false;\n\n        if ( nLen > 3 && isxdigit( sCur[0] ) && isxdigit( sCur[1] ) && isxdigit( sCur[2] ) && isxdigit( sCur[3] ) )\n            bASCII = true;\n\n        if ( bASCII )\n            ASCIIHexDecode( &sCur, sCur + nLen, sCur, nLen );\n\n        unsigned short ushKey = 55665U;\n        EexecDecode( &sCur, *ppEexecBuffer + nLen, sCur, nLen, &ushKey );\n    }\n    bool CFontFileType1::RemovePfbMarkers()\n    {\n        bool bSuccess = true;\n\n        int nBlockType = 0;\n        int nBlockLen  = 0;\n        int nChar = 0;\n\n        unsigned char *sBuffer = NULL;\n        unsigned int nBufLen = 0;\n\n        while ( nBlockType != PFB_DONE )\n        {\n            while ( 0 == nBlockLen )\n            {\n                nChar = ReadU8( &bSuccess );\n                if ( !bSuccess )\n                    return false;\n\n                nBlockType = ReadU8( &bSuccess );\n                if ( !bSuccess || PFB_MARKER != nChar || ( PFB_ASCII != nBlockType && PFB_BINARY != nBlockType && PFB_DONE != nBlockType ) )\n                    return false;\n\n                if ( PFB_DONE == nBlockType )\n                    break;\n\n                nBlockLen = ReadU32LE( &bSuccess );\n                if ( !bSuccess )\n                    return false;\n            }\n\n            // \u0427\u0438\u0442\u0430\u0435\u043c \u0441\u0430\u043c \u0431\u043b\u043e\u043a \u0434\u0430\u043d\u043d\u044b\u0445\n            if ( nBlockLen > 0 )\n            {\n                if ( !sBuffer )\n                {\n                    sBuffer = (unsigned char*)MemUtilsMalloc( nBlockLen );\n                    if ( !sBuffer )\n                        return false;\n                }\n                else\n                    sBuffer = (unsigned char*)MemUtilsRealloc( sBuffer, nBufLen + nBlockLen );\n\n                Read( sBuffer + nBufLen, nBlockLen );\n                nBufLen += nBlockLen;\n            }\n            nBlockLen = 0;\n        }\n\n        if ( m_bFreeFileData )\n            MemUtilsFree( m_sFile );\n\n        m_bFreeFileData = true;\n        m_sFile         = (unsigned char*)sBuffer;\n        m_sFileData     = m_sFile;\n        m_nLen          = nBufLen;\n        m_nPos          = 0;\n\n        return true;\n    }\n\n    Type1Charstring CFontFileType1::DecodeCharString(unsigned char *sString, int nLen)\n    {\n        CArray<Type1CharstringItem> sCharString;\n\n        int nLSB = 0, nWidth = 0;\n\n        for ( int nIndex = 0; nIndex < nLen; nIndex++ )\n        {\n            int nValue = sString[nIndex];\n\n            if ( nValue < 32 ) // \u043a\u043e\u043c\u0430\u043d\u0434\u0430\n            {\n                int nCommand = 0;\n\n                if ( 12 == nValue )\n                {\n                    int nNextValue = sString[++nIndex];\n\n                    if ( 16 == nNextValue )\n                    {\n                        if ( sCharString.GetSize() <= 0 )\n                            continue;\n\n                        int nInd = sCharString[sCharString.GetSize() - 1].nValue;\n                        sCharString.RemoveAt( sCharString.GetSize() - 1 );\n\n                        while ( sCharString.GetSize() > 0 && false == sCharString[sCharString.GetSize() - 1].bCommand )\n                            sCharString.RemoveAt( sCharString.GetSize() - 1 );\n\n                        // If the flex mechanishm is not used in a font program, Adobe\n                        // state that that entries 0, 1 and 2 can simply be replace by\n                        // {}, which means that we can simply ignore them.\n                        if ( nInd < 3 )\n                            continue;\n\n                        // This is the same things about hint replacement, if it is not used\n                        // entry 3 can be replaced by {3}\n                        if ( 3 == nInd )\n                        {\n                            sCharString.Add( Type1CharstringItem( 3, true ) );\n                            nIndex++;\n                            continue;\n                        }\n                    }\n\n                    nCommand = 12 + ( nNextValue << 8 );\n                }\n                else\n                {\n                    if ( 13 == nValue )\n                    {\n                        if ( 2 == sCharString.GetSize() )\n                            nWidth = sCharString[1].nValue;\n                        else if ( 4 == sCharString.GetSize() && 0x0C0C == sCharString[3].nValue && sCharString[3].bCommand )\n                            nWidth = sCharString[1].nValue / sCharString[2].nValue;\n                        else\n                        {\n                            // TO DO: \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u0430\u0442\u044c \u043e\u0448\u0438\u0431\u043a\u0443\n                            nWidth = 0;\n                        }\n\n                        if ( sCharString.GetSize() > 0 )\n                        {\n                            nLSB = sCharString[0].nValue;\n                            sCharString.Add( Type1CharstringItem( nLSB, false ) );\n                            sCharString.Add( Type1CharstringItem( c_nType1hmoveto, true ) );\n                            sCharString.RemoveAt( 0 );\n                        }\n                        else\n                        {\n                            nLSB = 0;\n                            sCharString.Add( Type1CharstringItem( nLSB, false ) );\n                            sCharString.Add( Type1CharstringItem( c_nType1hmoveto, true ) );\n                        }\n\n                        continue;\n                    }\n\n                    nCommand = nValue;\n                }\n\n                // Some charstring commands are meaningless in Type2 and will return\n                // a null, let's just ignored them\n                if ( !nCommand && nIndex < nLen )\n                    continue;\n                else if ( !nCommand )\n                    break;\n                else if ( c_nType1seac == nCommand || c_nType1sbw == nCommand )\n                {\n                    // TO DO: \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u0430\u0442\u044c \u043e\u0448\u0438\u0431\u043a\u0443\n                }\n\n                sCharString.Add( Type1CharstringItem( nCommand, true ) );\n            }\n            else\n            {\n                if ( nValue <= 246 )\n                    nValue = nValue - 139;\n                else if ( nValue <= 250 )\n                    nValue =  ( ( nValue - 247 ) * 256 ) + (int)( sString[++nIndex] ) + 108;\n                else if ( nValue <= 254 )\n                    nValue = -( ( nValue - 251 ) * 256 ) - (int)( sString[++nIndex] ) - 108;\n                else\n                    nValue = ( sString[++nIndex] & 0xff ) << 24 | ( sString[++nIndex] & 0xff ) << 16 | ( sString[++nIndex] & 0xff ) << 8 | ( sString[++nIndex] & 0xff ) << 0;\n\n                sCharString.Add( Type1CharstringItem( nValue, false ) );\n            }\n        }\n\n        return Type1Charstring( sCharString, nWidth, nLSB );\n    }\n    Type1Charstring CFontFileType1::FlattenCharstring(Type1Charstring& oCharstring, int nBias)\n    {\n        Type1Charstring oNew;\n        oNew.nLSB   = oCharstring.nLSB;\n        oNew.nWidth = oCharstring.nWidth;\n\n        for ( int nIndex = 0; nIndex < oCharstring.arrCharstring.GetSize(); nIndex++ )\n        {\n            Type1CharstringItem oItem = oCharstring.arrCharstring[nIndex];\n            int nValue = oItem.nValue;\n            if ( oItem.bCommand )\n            {\n                if ( nValue == c_nType1sub )\n                {\n                    oNew.arrCharstring.Add( Type1CharstringItem( 12, true ) );\n                    oNew.arrCharstring.Add( Type1CharstringItem( 11, true ) );\n                }\n                else if ( nValue == c_nType1div )\n                {\n                    oNew.arrCharstring.Add( Type1CharstringItem( 12, true ) );\n                    oNew.arrCharstring.Add( Type1CharstringItem( 12, true ) );\n                }\n                else if ( nValue == c_nType1pop )\n                {\n                    //oNew.arrCharstring.Add( Type1CharstringItem( 1, true ) );\n                    oNew.arrCharstring.Add( Type1CharstringItem( 12, true ) );\n                    oNew.arrCharstring.Add( Type1CharstringItem( 18, true ) );\n                }\n                else if ( nValue == c_nType1callsubr  )\n                {\n                    //int nTempLen = oNew.arrCharstring.GetSize();\n                    //int nT1 = oNew.arrCharstring[nTempLen - 2].nValue;\n                    //int nT2 = oNew.arrCharstring[nTempLen - 1].nValue;\n                    //int nInd = nT1 << 8 | nT2;\n\n                    //if ( 107 == nBias )\n                    //{\n                    //\tif ( nInd <= 215 )\n                    //\t{\n                    //\t\toNew.arrCharstring.RemoveAt( nTempLen - 1 );\n                    //\t\toNew.arrCharstring.RemoveAt( nTempLen - 2 );\n\n                    //\t\toNew.arrCharstring[nTempLen - 3].nValue = nInd - nBias + 139;\n                    //\t\toNew.arrCharstring.Add( Type1CharstringItem( oItem.nValue, true ) );\n                    //\t}\n                    //\telse\n                    //\t{\n                    //\t\toNew.arrCharstring.RemoveAt( nTempLen - 1 );\n\n                    //\t\toNew.arrCharstring[nTempLen - 3].nValue = ((nInd - nBias) - 108) / 256 + 247;\n                    //\t\toNew.arrCharstring[nTempLen - 2].nValue = ((nInd - nBias) - 108) - (oNew.arrCharstring[nTempLen - 3].nValue - 247) * 256;\n                    //\t\toNew.arrCharstring.Add( Type1CharstringItem( oItem.nValue, true ) );\n                    //\t}\n                    //}\n                    //else\n                    //{\n\n                    //\tnInd -= nBias;\n                    //\toNew.arrCharstring[nTempLen - 2].nValue = nInd >> 8;\n                    //\toNew.arrCharstring[nTempLen - 1].nValue = nInd & 0xFF;\n                    //\toNew.arrCharstring.Add( Type1CharstringItem( oItem.nValue, true ) );\n                    //}\n                    oNew.arrCharstring.Add( Type1CharstringItem( oItem.nValue, true ) );\n                }\n                else\n                    oNew.arrCharstring.Add( Type1CharstringItem( oItem.nValue, true ) );\n            }\n            else\n            {\n                // Type1 charstrings \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u044e\u0442 \u0434\u0435\u043b\u0435\u043d\u0438\u044f \u0434\u043b\u044f \u0447\u0438\u0441\u0435\u043b \u0431\u043e\u043b\u044c\u0448\u0438\u0445 32000\n                if ( oItem.nValue > 32000 )\n                {\n                    int nDivisor = oCharstring.arrCharstring[nIndex + 1].nValue;\n                    if ( 0 != nDivisor )\n                        nValue /= nDivisor;\n                }\n                oNew.arrCharstring.Add( Type1CharstringItem( 28, true ) );\n                oNew.arrCharstring.Add( Type1CharstringItem( nValue >> 8, false ) );\n                oNew.arrCharstring.Add( Type1CharstringItem( nValue & 0xFF, false ) );\n            }\n        }\n\n        return oNew;\n    }\n    void CFontFileType1::CFFCreateIndexHeader(FontFileOutputFunc pOutputFunc, void *pOutputStream, CArray<std::wstring> aObjects)\n    {\n        char nChar;\n        int nCount = aObjects.GetSize();\n        if ( 0 == nCount )\n        {\n            pOutputFunc( pOutputStream, \"\\x00\\x00\\x00\", 3 );\n            return;\n        }\n\n        // \u041f\u0435\u0440\u0432\u044b\u0435 \u0434\u0432\u0430 \u0431\u0430\u0439\u0442\u0430 - \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u043e\u0432\n        WriteChar( nCount >> 8 );\n        WriteChar( nCount & 0xFF );\n        // \u0420\u0430\u0437\u043c\u0435\u0440 \u0441\u0434\u0432\u0438\u0433\u043e\u0432, \u0441\u0442\u0430\u0432\u0438\u043c \u043f\u043e \u043c\u0430\u043a\u0441\u0438\u043c\u0443\u043c\u0443\n        WriteChar( 0x04 );\n\n        int nRelativeOffset = 1;\n        for ( int nIndex = 0; nIndex < nCount + 1; nIndex++ )\n        {\n            WriteChar( (nRelativeOffset >> 24) & 0xFF );\n            WriteChar( (nRelativeOffset >> 16) & 0xFF );\n            WriteChar( (nRelativeOffset >>  8) & 0xFF );\n            WriteChar( (nRelativeOffset)       & 0xFF );\n\n            if ( nIndex < nCount )\n                nRelativeOffset += aObjects[nIndex].length();\n        }\n\n        for ( int nIndex = 0; nIndex < nCount; nIndex++ )\n        {\n            std::string sCur = U_TO_UTF8((aObjects[nIndex]));\n            pOutputFunc( pOutputStream, sCur.c_str(), sCur.length() );\n        }\n    }\n    void CFontFileType1::CFFCreateIndexHeader(FontFileOutputFunc pOutputFunc, void *pOutputStream, CArray<Type1Charstring> aObjects)\n    {\n        char nChar;\n        int nCount = aObjects.GetSize();\n        if ( 0 == nCount )\n        {\n            pOutputFunc( pOutputStream, \"\\x00\\x00\\x00\", 3 );\n            return;\n        }\n\n        // \u041f\u0435\u0440\u0432\u044b\u0435 \u0434\u0432\u0430 \u0431\u0430\u0439\u0442\u0430 - \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u043e\u0432\n        WriteChar( nCount >> 8 );\n        WriteChar( nCount & 0xFF );\n        // \u0420\u0430\u0437\u043c\u0435\u0440 \u0441\u0434\u0432\u0438\u0433\u043e\u0432, \u0441\u0442\u0430\u0432\u0438\u043c \u043f\u043e \u043c\u0430\u043a\u0441\u0438\u043c\u0443\u043c\u0443\n        WriteChar( 0x04 );\n\n        int nRelativeOffset = 1;\n        for ( int nIndex = 0; nIndex < nCount + 1; nIndex++ )\n        {\n            WriteChar( (nRelativeOffset >> 24) & 0xFF );\n            WriteChar( (nRelativeOffset >> 16) & 0xFF );\n            WriteChar( (nRelativeOffset >>  8) & 0xFF );\n            WriteChar( (nRelativeOffset)       & 0xFF );\n\n            if ( nIndex < nCount )\n                nRelativeOffset += aObjects[nIndex].arrCharstring.GetSize();\n        }\n\n        for ( int nI = 0; nI < nCount; nI++ )\n        {\n            for ( int nJ = 0; nJ < aObjects[nI].arrCharstring.GetSize(); nJ++ )\n            {\n                WriteChar( aObjects[nI].arrCharstring[nJ].nValue & 0xFF );\n            }\n        }\n    }\n    void CFontFileType1::CFFEncodeNumber(FontFileOutputFunc pOutputFunc, void *pOutputStream, int nValue, bool bForceLong)\n    {\n        char nChar;\n        if ( !bForceLong && nValue >= -32768 && nValue <= 32767 )\n        {\n            WriteChar( 0x1c );\n            WriteChar( ( nValue >> 8 ) & 0xFF );\n            WriteChar( nValue & 0xFF );\n        }\n        else // if ( nValue >= (-2147483648) && nValue <= 2147483647 )\n        {\n            WriteChar( 0x1d );\n            WriteChar( ( nValue >> 24 ) & 0xFF );\n            WriteChar( ( nValue >> 16 ) & 0xFF );\n            WriteChar( ( nValue >>  8 ) & 0xFF );\n            WriteChar( nValue & 0xFF );\n        }\n    }\n    void CFontFileType1::CFFEncodeNumber(FontFileOutputFunc pOutputFunc, void *pOutputStream, double dValue)\n    {\n        char nChar = 0;\n\n        WriteChar( 0x1e ); // \u043d\u0430\u0447\u0430\u043b\u043e \u0434\u0435\u0441\u044f\u0442\u0438\u0447\u043d\u043e\u0433\u043e \u0447\u0438\u0441\u043b\u0430\n\n        std::wstring sValue = std::to_wstring(dValue);\n        bool bFirstNibble = true;\n        for ( int nIndex = 0; nIndex < sValue.length(); nIndex++ )\n        {\n            int nCurChar = sValue.c_str()[ nIndex ];\n            if ( '0' <= nCurChar && nCurChar <= '9' )\n                nCurChar -= (int)('0');\n            else if ( '.' == nCurChar )\n                nCurChar = 0x0a;\n            else if ( '-' == nCurChar )\n                nCurChar = 0x0e;\n            else\n                continue;\n\n            if ( bFirstNibble )\n                nChar = nCurChar << 4;\n            else\n            {\n                nChar += nCurChar;\n                WriteChar( nChar );\n            }\n\n            bFirstNibble = !bFirstNibble;\n        }\n\n        // \u0417\u0430\u043f\u0438\u0441\u044b\u0432\u0430\u0435\u043c \u043e\u043a\u043e\u043d\u0447\u0430\u043d\u0438\u0435\u0434\u0435\u0441\u044f\u0442\u0438\u0447\u043d\u043e\u0433\u043e \u0447\u0438\u0441\u043b\u0430\n        if ( bFirstNibble )\n            nChar = (char)0xff;\n        else\n            nChar += 0x0f;\n\n        WriteChar( nChar );\n    }\n    void CFontFileType1::ToCFF(FontFileOutputFunc pOutputFunc, void *pOutputStream)\n    {\n        std::wstring sFontName = NSFile::CUtf8Converter::GetUnicodeFromCharPtr( m_sName, (LONG)strlen(m_sName) );\n        CArray<std::wstring> aString;\n\n        int nBias = 0;\n        int nSubrsLen = m_arrSubrs.GetSize();\n        if ( nSubrsLen < 1240 )\n            nBias = 107;\n        else if ( nSubrsLen < 33900 )\n            nBias = 1131;\n        else\n            nBias = 32768;\n\n        CArray<Type1Charstring> arrType2Charstrings;\n        Type1Charstring oFirstCharstring;\n        oFirstCharstring.arrCharstring.Add( Type1CharstringItem( 0x8B, false ) );\n        oFirstCharstring.arrCharstring.Add( Type1CharstringItem( 0x0E, false ) );\n        arrType2Charstrings.Add( oFirstCharstring );\n        for ( int nIndex = 0; nIndex < m_arrCharstrings.GetSize(); nIndex++ )\n        {\n            std::wstring sG = m_arrCharstrings[nIndex].sGlyph;\n            if ( L\"afii10090\" == sG )\n                int k = 10;\n            arrType2Charstrings.Add( FlattenCharstring( m_arrCharstrings[nIndex].oData, nBias ) );\n        }\n\n        CArray<Type1Charstring> arrType2Subrs;\n\n        //Type1Charstring oBias;\n        ////oBias.arrCharstring.Add( Type1CharstringItem( 0x0B, false ) );\n        //oBias.arrCharstring.Add( Type1CharstringItem( 0x0E, false ) );\n        //for ( int nIndex = 0; nIndex < nBias; nIndex++ )\n        //\tarrType2Subrs.Add( oBias );\n\n        for ( int nIndex = 0; nIndex < nSubrsLen; nIndex++ )\n        {\n            //if ( nIndex == 256 )\n            //{\n            //\tType1Charstring oBias;\n            //\toBias.arrCharstring.Add( Type1CharstringItem( 0x0B, false ) );\n            //\tfor ( int nIndex = 0; nIndex < nBias; nIndex++ )\n            //\t\tarrType2Subrs.Add( oBias );\n            //}\n            arrType2Subrs.Add( FlattenCharstring( m_arrSubrs[nIndex], 0 ) );\n        }\n\n        // Header\n        TCharBuffer oHeader;\n        oHeader.Write( \"\\x01\\x00\\x04\\x04\", 4 );\n\n        // Name\n        TCharBuffer oName;\n        aString.RemoveAll();\n        aString.Add( sFontName );\n        CFFCreateIndexHeader( CharBufferWrite, &oName, aString );\n\n        // Strings\n        TCharBuffer oStrings;\n        aString.RemoveAll();\n        int nNewSID = CFF_STANDARD_STRINGS_COUNT;\n        aString.Add( L\"Version 0.11\" );        nNewSID++; // Version\n        aString.Add( L\"See original notice\" ); nNewSID++; // Notice\n        aString.Add( sFontName );                 nNewSID++; // FullName\n        aString.Add( sFontName );                 nNewSID++; // FamilyName\n        aString.Add( L\"Medium\" );              nNewSID++; // Weight\n\n        for ( int nIndex = 0; nIndex < m_arrCharstrings.GetSize(); nIndex++ )\n        {\n            int nSID = GetCFFStringIndex( m_arrCharstrings[nIndex].sGlyph.c_str() );\n            if ( nSID < 0 )\n            {\n                aString.Add( m_arrCharstrings[nIndex].sGlyph );\n                nSID = nNewSID;\n                nNewSID++;\n            }\n\n            m_arrCharstrings[nIndex].nReserved = nSID;\n        }\n\n        CFFCreateIndexHeader( CharBufferWrite, &oStrings, aString );\n\n        // GlobalSubrs\n        TCharBuffer oGlobalSubrs;\n        aString.RemoveAll(); // \u0417\u0430\u043f\u0438\u0441\u044b\u0432\u0430\u0435\u043c \u043f\u0443\u0441\u0442\u043e\u0439 \u043c\u0430\u0441\u0441\u0438\u0432\n        CFFCreateIndexHeader( CharBufferWrite, &oGlobalSubrs, aString );\n\n        // Charset\n        TCharBuffer oCharset;\n        oCharset.Write( (char)0x00 ); // Encoding\n\n        int nGlyphsCount = m_arrCharstrings.GetSize();\n        for ( int nIndex = 0; nIndex < nGlyphsCount; nIndex++ )\n        {\n            int nSID = m_arrCharstrings[nIndex].nReserved;\n            oCharset.Write( (char)(nSID >> 8) );\n            oCharset.Write( (char)(nSID & 0xFF) );\n        }\n\n        // Charstrings\n        TCharBuffer oCharstrings;\n        CFFCreateIndexHeader( NSFontConverter::CharBufferWrite, &oCharstrings, arrType2Charstrings );\n\n        // Private\n        TCharBuffer oPrivate;\n        oPrivate.Write( \"\\x8b\\x14\", 2 ); // defaultWidth\n        oPrivate.Write( \"\\x8b\\x15\", 2 ); // nominalWidth\n\n        // Private: BlueValues\n        if ( m_oPrivateDict.nBlueValues > 0 )\n        {\n            CFFEncodeNumber( CharBufferWrite, &oPrivate, m_oPrivateDict.arrnBlueValues[0] );\n            for ( int nIndex = 1; nIndex < m_oPrivateDict.nBlueValues; nIndex++ )\n                CFFEncodeNumber( CharBufferWrite, &oPrivate, m_oPrivateDict.arrnBlueValues[nIndex] - m_oPrivateDict.arrnBlueValues[nIndex - 1] );\n\n            oPrivate.Write( (char)0x06 );\n        }\n\n        // Private: OtherBlues\n        if ( m_oPrivateDict.nOtherBlues > 0 )\n        {\n            CFFEncodeNumber( CharBufferWrite, &oPrivate, m_oPrivateDict.arrnOtherBlues[0] );\n            for ( int nIndex = 1; nIndex < m_oPrivateDict.nOtherBlues; nIndex++ )\n                CFFEncodeNumber( CharBufferWrite, &oPrivate, m_oPrivateDict.arrnOtherBlues[nIndex] - m_oPrivateDict.arrnOtherBlues[nIndex - 1] );\n\n            oPrivate.Write( (char)0x07 );\n        }\n\n        // Private: FamilyBlues\n        if ( m_oPrivateDict.nFamilyBlues > 0 )\n        {\n            CFFEncodeNumber( CharBufferWrite, &oPrivate, m_oPrivateDict.arrnFamilyBlues[0] );\n            for ( int nIndex = 1; nIndex < m_oPrivateDict.nFamilyBlues; nIndex++ )\n                CFFEncodeNumber( CharBufferWrite, &oPrivate, m_oPrivateDict.arrnFamilyBlues[nIndex] - m_oPrivateDict.arrnFamilyBlues[nIndex - 1] );\n\n            oPrivate.Write( (char)0x08 );\n        }\n\n        // Private: FamilyOtherBlues\n        if ( m_oPrivateDict.nFamilyOtherBlues > 0 )\n        {\n            CFFEncodeNumber( CharBufferWrite, &oPrivate, m_oPrivateDict.arrnFamilyOtherBlues[0] );\n            for ( int nIndex = 1; nIndex < m_oPrivateDict.nFamilyOtherBlues; nIndex++ )\n                CFFEncodeNumber( CharBufferWrite, &oPrivate, m_oPrivateDict.arrnFamilyOtherBlues[nIndex] - m_oPrivateDict.arrnFamilyOtherBlues[nIndex - 1] );\n\n            oPrivate.Write( (char)0x09 );\n        }\n\n        // Private: StemSnapH\n        if ( m_oPrivateDict.nStemSnapH > 0 )\n        {\n            CFFEncodeNumber( CharBufferWrite, &oPrivate, m_oPrivateDict.arrdStemSnapH[0] );\n            for ( int nIndex = 1; nIndex < m_oPrivateDict.nStemSnapH; nIndex++ )\n                CFFEncodeNumber( CharBufferWrite, &oPrivate, m_oPrivateDict.arrdStemSnapH[nIndex] - m_oPrivateDict.arrdStemSnapH[nIndex - 1] );\n\n            oPrivate.Write( \"\\x0c\\x0c\" , 2);\n        }\n\n        // Private: StemSnapV\n        if ( m_oPrivateDict.nStemSnapV > 0 )\n        {\n            CFFEncodeNumber( CharBufferWrite, &oPrivate, m_oPrivateDict.arrdStemSnapV[0] );\n            for ( int nIndex = 1; nIndex < m_oPrivateDict.nStemSnapV; nIndex++ )\n                CFFEncodeNumber( CharBufferWrite, &oPrivate, m_oPrivateDict.arrdStemSnapV[nIndex] - m_oPrivateDict.arrdStemSnapV[nIndex - 1] );\n\n            oPrivate.Write( \"\\x0c\\x0d\" , 2);\n        }\n\n        // Private: BlueShift\n        CFFEncodeNumber( CharBufferWrite, &oPrivate, m_oPrivateDict.nBlueShift );\n        oPrivate.Write( \"\\x0c\\x0a\", 2 );\n\n        // Private: BlueFuzz\n        CFFEncodeNumber( CharBufferWrite, &oPrivate, m_oPrivateDict.nBlueFuzz );\n        oPrivate.Write( \"\\x0c\\x0b\", 2 );\n\n        // Private: BlueScale\n        CFFEncodeNumber( CharBufferWrite, &oPrivate, m_oPrivateDict.dBlueScale );\n        oPrivate.Write( \"\\x0c\\x09\", 2 );\n\n        // Private: LanguageGroup\n        CFFEncodeNumber( CharBufferWrite, &oPrivate, m_oPrivateDict.nLanguageGroup );\n        oPrivate.Write( \"\\x0c\\x11\", 2 );\n\n        // Private: ExpansionFactor\n        CFFEncodeNumber( CharBufferWrite, &oPrivate, m_oPrivateDict.dExpansionFactor );\n        oPrivate.Write( \"\\x0c\\x18\", 2 );\n\n        // Private: Subrs\n        int nPrivateLen = oPrivate.nLen + (5 + 1);\n        CFFEncodeNumber( CharBufferWrite, &oPrivate, nPrivateLen, true );\n        oPrivate.Write( \"\\x13\", 1 );\n\n        // LocalSubrs\n        TCharBuffer oLocalSubrs;\n        CFFCreateIndexHeader( CharBufferWrite, &oLocalSubrs, arrType2Subrs );\n\n        // Top Dict\n        TCharBuffer oTopDict;\n        oTopDict.Write( \"\\x00\\x01\\x04\\x00\\x00\\x00\\x01\\x00\\x00\\0x00\\x00\", 11 );\n        oTopDict.Write( \"\\xf8\\x1b\\x00\", 3 ); // Version\n        oTopDict.Write( \"\\xf8\\x1c\\x01\", 3 ); // Notice\n        oTopDict.Write( \"\\xf8\\x1d\\x02\", 3 ); // FullName\n        oTopDict.Write( \"\\xf8\\x1e\\x03\", 3 ); // FamilyName\n        oTopDict.Write( \"\\xf8\\x1f\\x04\", 3 ); // Weight\n        oTopDict.Write( \"\\x1c\\x00\\x00\\x10\", 4 ); // Encoding\n\n        // BBox\n        CFFEncodeNumber( CharBufferWrite, &oTopDict, m_oTopDict.arrdFontBBox[0] );\n        CFFEncodeNumber( CharBufferWrite, &oTopDict, m_oTopDict.arrdFontBBox[1] );\n        CFFEncodeNumber( CharBufferWrite, &oTopDict, m_oTopDict.arrdFontBBox[2] );\n        CFFEncodeNumber( CharBufferWrite, &oTopDict, m_oTopDict.arrdFontBBox[3] );\n        oTopDict.Write( \"\\x05\", 1 );\n\n        // \u0422\u0435\u043f\u0435\u0440\u044c \u043e\u0446\u0435\u043d\u0438\u043c \u0440\u0430\u0437\u043c\u0435\u0440 TopDict: \u0412\u043e\u0437\u044c\u043c\u0435\u043c \u0442\u0435\u043a\u0443\u0449\u0443\u044e \u0434\u043b\u0438\u043d\u0443, \u0434\u043e\u0431\u0430\u0432\u0438\u043c \u043a \u043d\u0435\u0439 (4 * 5 + 3)\n        // ( 4 \u0447\u0438\u0441\u043b\u0430, \u043a\u043e\u0442\u043e\u0440\u044b\u0435 \u043f\u0438\u0448\u0435\u043c \u043f\u043e 5 \u0431\u0430\u0439\u0442 + 3 \u0431\u0430\u0439\u0442\u0430 \u043d\u0430 3 \u043a\u043e\u043c\u0430\u043d\u0434\u044b)\n        int nTopDictLen = oTopDict.nLen + ( 4 * 5 + 3);\n\n        int nOffset = oHeader.nLen + oName.nLen + nTopDictLen + oStrings.nLen + oGlobalSubrs.nLen;\n        CFFEncodeNumber( CharBufferWrite, &oTopDict, nOffset, true );\n        oTopDict.Write( \"\\x0f\", 1 ); // Charset\n\n        nOffset += oCharset.nLen;//( arrType2Charstrings.GetSize() * 2 ) + 1;\n        CFFEncodeNumber( CharBufferWrite, &oTopDict, nOffset, true );\n        oTopDict.Write( \"\\x11\", 1 ); // Charstrings\n\n        CFFEncodeNumber( CharBufferWrite, &oTopDict, oPrivate.nLen, true );\n        nOffset += oCharstrings.nLen;\n        CFFEncodeNumber( CharBufferWrite, &oTopDict, nOffset, true );\n        oTopDict.Write( \"\\x12\", 1 ); // Private\n\n        // \u0422\u0435\u043f\u0435\u0440\u044c \u0437\u0430\u043f\u0438\u0448\u0435\u043c \u0440\u0435\u0430\u043b\u044c\u043d\u044b\u0439 \u0440\u0430\u0437\u043c\u0435\u0440 TopDict\n        int nTopDictDataLen = nTopDictLen - 10;\n        oTopDict.sBuffer[7]  = ( nTopDictDataLen >> 24 ) & 0xFF;\n        oTopDict.sBuffer[8]  = ( nTopDictDataLen >> 16 ) & 0xFF;\n        oTopDict.sBuffer[9]  = ( nTopDictDataLen >> 8  ) & 0xFF;\n        oTopDict.sBuffer[10] = nTopDictDataLen & 0xFF;\n\n        // \u0417\u0430\u043f\u0438\u0441\u044b\u0432\u0430\u0435\u043c \u0432\u0441\u0435 \u0432 \u0444\u0430\u0439\u043b\n        pOutputFunc( pOutputStream, oHeader.sBuffer,      oHeader.nLen      );\n        pOutputFunc( pOutputStream, oName.sBuffer,        oName.nLen        );\n        pOutputFunc( pOutputStream, oTopDict.sBuffer,     oTopDict.nLen     );\n        pOutputFunc( pOutputStream, oStrings.sBuffer,     oStrings.nLen     );\n        pOutputFunc( pOutputStream, oGlobalSubrs.sBuffer, oGlobalSubrs.nLen );\n        pOutputFunc( pOutputStream, oCharset.sBuffer,     oCharset.nLen     );\n        pOutputFunc( pOutputStream, oCharstrings.sBuffer, oCharstrings.nLen );\n        pOutputFunc( pOutputStream, oPrivate.sBuffer,     oPrivate.nLen     );\n        pOutputFunc( pOutputStream, oLocalSubrs.sBuffer,  oLocalSubrs.nLen  );\n    }\n}\n", "\ufeff/*\n * (c) Copyright Ascensio System SIA 2010-2019\n *\n * This program is a free software product. You can redistribute it and/or\n * modify it under the terms of the GNU Affero General Public License (AGPL)\n * version 3 as published by the Free Software Foundation. In accordance with\n * Section 7(a) of the GNU AGPL its Section 15 shall be amended to the effect\n * that Ascensio System SIA expressly excludes the warranty of non-infringement\n * of any third-party rights.\n *\n * This program is distributed WITHOUT ANY WARRANTY; without even the implied\n * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR  PURPOSE. For\n * details, see the GNU AGPL at: http://www.gnu.org/licenses/agpl-3.0.html\n *\n * You can contact Ascensio System SIA at 20A-12 Ernesta Birznieka-Upisha\n * street, Riga, Latvia, EU, LV-1050.\n *\n * The  interactive user interfaces in modified source and object code versions\n * of the Program must display Appropriate Legal Notices, as required under\n * Section 5 of the GNU AGPL version 3.\n *\n * Pursuant to Section 7(b) of the License you must retain the original Product\n * logo when distributing the program. Pursuant to Section 7(e) we decline to\n * grant you any rights under trademark law for use of our trademarks.\n *\n * All the Product's GUI elements, including illustrations and icon sets, as\n * well as technical writing content are licensed under the terms of the\n * Creative Commons Attribution-ShareAlike 4.0 International. See the License\n * terms at http://creativecommons.org/licenses/by-sa/4.0/legalcode\n *\n */\n#ifndef _ASC_FONTCONVERTER_FONT_FILE_TYPE1_H\n#define _ASC_FONTCONVERTER_FONT_FILE_TYPE1_H\n\n#include \"Utils.h\"\n#include \"FontFileBase.h\"\n#include \"FontFileEncodings.h\"\n#include \"../../common/Array.h\"\n\nnamespace NSFontConverter\n{\n    #define type1MaxBlueValues 14 // 7 \u043f\u0430\u0440\n    #define type1MaxOtherBlues 10 // 5 \u043f\u0430\u0440\n    #define type1MaxStemSnap   12\n\n    struct Type1PrivateDict\n    {\n        int    arrnBlueValues[type1MaxBlueValues];\n        int    nBlueValues;\n        int    arrnOtherBlues[type1MaxOtherBlues];\n        int    nOtherBlues;\n        int    arrnFamilyBlues[type1MaxBlueValues];\n        int    nFamilyBlues;\n        int    arrnFamilyOtherBlues[type1MaxOtherBlues];\n        int    nFamilyOtherBlues;\n        double dBlueScale;\n        int    nBlueShift;\n        int    nBlueFuzz;\n        double dStdHW;\n        bool   bHasStdHW;\n        double dStdVW;\n        bool   bHasStdVW;\n        double arrdStemSnapH[type1MaxStemSnap];\n        int    nStemSnapH;\n        double arrdStemSnapV[type1MaxStemSnap];\n        int    nStemSnapV;\n        bool   bHasForceBold;\n        bool   bForceBold;\n        int    nLanguageGroup;\n        int    nLenIV;\n        double dExpansionFactor;\n    };\n\n    struct Type1TopDict\n    {\n        // TO DO: \u0434\u043e\u043f\u043e\u043b\u043d\u0438\u0442\u044c \u0434\u0430\u043d\u043d\u0443\u044e \u0441\u0442\u0440\u0443\u043a\u0442\u0443\u0440\u0443\n        double arrdFontMatrix[6];\n        double arrdFontBBox[4];\n    };\n\n    // \u043a\u043e\u043c\u0430\u043d\u0434\u044b\n    const int c_nType1hstem\t\t\t\t= 0x0001; // 'hstem'\n    const int c_nType1vstem\t\t\t\t= 0x0003; // 'vstem'\n    const int c_nType1vmoveto\t\t\t= 0x0004; // 'vmoveto'\n    const int c_nType1rlineto\t\t\t= 0x0005; // 'rlineto'\n    const int c_nType1hlineto\t\t\t= 0x0006; // 'hlineto'\n    const int c_nType1vlineto\t\t\t= 0x0007; // 'vlineto'\n    const int c_nType1rrcurveto\t\t\t= 0x0008; // 'rrcurveto'\n    const int c_nType1closepath\t\t\t= 0x0009; // 'closepath' \u043d\u0435 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u0442\u0441\u044f \u0432 Type2\n    const int c_nType1callsubr\t\t\t= 0x000A; // 'callsubr\n    const int c_nType1return\t\t\t= 0x000B; // 'return'\n    const int c_nType1dotsection\t\t= 0x000C; // 'dotsection' \u043d\u0435 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u0442\u0441\u044f \u0432 Type2\n    const int c_nType1vstem3\t\t\t= 0x010C; // 'vstem'\n    const int c_nType1hstem3\t\t\t= 0x020C; // 'hstem'\n    const int c_nType1seac\t\t\t\t= 0x060C; // 'seac' Type1 only\n    const int c_nType1sbw\t\t\t\t= 0x070C; // 'sbw'  Type1 only\n    const int c_nType1sub\t\t\t\t= 0x0B0C; // 'sub'\n    const int c_nType1div\t\t\t\t= 0x0C0C; // 'div'\n    const int c_nType1callothersubr\t\t= 0x100C; // 'callothersubr'\n    const int c_nType1pop\t\t\t\t= 0x110C; // 'pop'\n    const int c_nType1setcurrentpoint\t= 0x210C; // 'setcurrentpoint' \u043d\u0435 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u0442\u0441\u044f \u0432 Type2\n    const int c_nType1hsbw\t\t\t\t= 0x000D; // 'hsbw'\n    const int c_nType1endchar\t\t\t= 0x000E; // 'endchar'\n    const int c_nType1rmoveto\t\t\t= 0x0015; // 'rmoveto'\n    const int c_nType1hmoveto\t\t\t= 0x0016; // 'hmoveto'\n    const int c_nType1vhcurveto\t\t\t= 0x001E; // 'vhcurveto'\n    const int c_nType1hvcurveto\t\t\t= 0x001F; // 'hvcurveto'\n\n    struct Type1CharstringItem\n    {\n        int  nValue;   // \u0417\u043d\u0430\u0447\u0435\u043d\u0438\u0435\n        bool bCommand; // TRUE: \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435 - \u043d\u043e\u043c\u0435\u0440 \u043a\u043e\u043c\u0430\u043d\u0434\u044b, FALSE: \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435 - \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440 \u043a\u043e\u043c\u0430\u043d\u0434\u044b\n\n        Type1CharstringItem(int nVal, bool bCom)\n        {\n            nValue   = nVal;\n            bCommand = bCom;\n        }\n        Type1CharstringItem()\n        {\n            nValue   = 0;\n            bCommand = false;\n        }\n    };\n\n    struct Type1Charstring\n    {\n        CArray<Type1CharstringItem> arrCharstring;\n        int                               nWidth;\n        int                               nLSB;\n\n        Type1Charstring()\n        {\n            nWidth    = 0;\n            nLSB      = 0;\n        }\n\n        Type1Charstring(CArray<Type1CharstringItem> &arrCs, int nW, int nL)\n        {\n            arrCharstring = arrCs;\n            nWidth        = nW;\n            nLSB          = nL;\n        }\n    };\n\n\n    struct Type1Glyph\n    {\n        std::wstring    sGlyph;    // Type1 \u0438\u043c\u044f \u0433\u043b\u0438\u0444\u0430\n        int             nUnicode;  // \u042e\u043d\u0438\u043a\u043e\u0434\u043d\u043e\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435 \u0433\u043b\u0438\u0444\u0430\n        Type1Charstring oData;\n        int             nReserved; // \u0418\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u043c \u0434\u043b\u044f SID \u043f\u0440\u0438 \u043a\u043e\u043d\u0432\u0435\u0440\u0442\u0430\u0446\u0438\u0438 Type1->Type2\n\n        Type1Glyph(std::wstring& sGlyf, int nUni, Type1Charstring &oCharstring)\n        {\n            sGlyph    = sGlyf;\n            nUnicode  = nUni;\n            oData     = oCharstring;\n            nReserved = 0;\n        }\n        Type1Glyph()\n        {\n            nUnicode  = 0;\n            nReserved = 0;\n        }\n    };\n\n    static int CompareType1Glyph(const void *pGlyph1, const void *pGlyph2)\n    {\n        Type1Glyph *pGlyf1 = (Type1Glyph *)pGlyph1;\n        Type1Glyph *pGlyf2 = (Type1Glyph *)pGlyph2;\n\n        return pGlyf1->nUnicode - pGlyf2->nUnicode;\n    }\n\n\n    //------------------------------------------------------------------------\n    // CFontFileType1\n    //------------------------------------------------------------------------\n\n    class CFontFileType1: public CFontFileBase\n    {\n    public:\n\n        static CFontFileType1 *LoadFromBuffer(char *sBuffer, int nLen);\n        static CFontFileType1 *LoadFromFile(const wchar_t *wsFileName);\n\n        virtual ~CFontFileType1();\n\n        char *GetName();\n\n        char **GetEncoding();\n\n        void WriteEncoded(char **ppNewEncoding, FontFileOutputFunc pOutputFunc, void *pOutputStream);\n        void ToCFF(FontFileOutputFunc pOutputFunc, void *pOutputStream);\n\n    private:\n\n        CFontFileType1(char *sBuffer, int nLen, bool bFreeData);\n        void Parse();\n        void DecryptEexec(unsigned char** ppEexecBuffer, int nLen);\n        Type1Charstring DecodeCharString(unsigned char *sString, int nLen);\n        char *GetNextLine(char *sLine);\n        bool RemovePfbMarkers();\n        template<int nMax>\n        int    ReadDoubleArray(unsigned char *sString, int nLen, double (&pArray)[nMax])\n        {\n            int nStart = 0;\n            while( sString[nStart] != '[' )\n            {\n                nStart++;\n                if ( nStart >= nLen )\n                    return 0;\n            }\n\n            int nEnd = ++nStart;\n            while ( sString[nEnd] != ']' )\n            {\n                nEnd++;\n                if ( nEnd >= nLen )\n                    return 0;\n            }\n\n            sString = sString + nStart;\n            nLen    = nEnd - nStart;\n\n\n            int nCount = 0;\n            const int c_nNumLimit = 32;\n            unsigned char sBuffer[c_nNumLimit];\n            int nBufPos = 0;\n            bool bNewItem = true;\n\n            for ( int nIndex = 0; nIndex < nLen; ++nIndex )\n            {\n                unsigned char unChar = sString[nIndex];\n                if ( ' ' == unChar )\n                {\n                    if ( !bNewItem )\n                        bNewItem = true;\n\n                    continue;\n                }\n\n                if ( bNewItem )\n                {\n                    if ( nCount >= nMax )\n                        break;\n\n                    // \u0414\u043e\u0431\u0430\u0432\u043b\u044f\u0435\u043c \u043f\u0440\u0435\u0434\u044b\u0434\u0443\u0449\u0435\u0435 \u0447\u0438\u0441\u043b\u043e \u0432 \u043c\u0430\u0441\u0441\u0438\u0432\n                    if ( nCount > 0 )\n                        pArray[nCount - 1] = Utils::GetDouble( (const char *)sBuffer );\n\n                    memset( sBuffer, 0x00, c_nNumLimit );\n                    nBufPos = 0;\n\n                    bNewItem = false;\n                    nCount++;\n                }\n\n                sBuffer[nBufPos++] = unChar;\n                if (nBufPos >= c_nNumLimit)\n                    break;\n            }\n\n            if ( 0 != sBuffer[0] && nCount > 0 )\n                pArray[nCount - 1] = Utils::GetDouble( (const char *)sBuffer );\n\n            return nCount;\n        }\n\n        template<int nMax>\n        int    ReadIntArray   (unsigned char *sString, int nLen, int (&pArray)[nMax])\n        {\n            int nStart = 0;\n            while( sString[nStart] != '[' )\n            {\n                nStart++;\n                if ( nStart >= nLen )\n                    return 0;\n            }\n\n            int nEnd = ++nStart;\n            while ( sString[nEnd] != ']' )\n            {\n                nEnd++;\n                if ( nEnd >= nLen )\n                    return 0;\n            }\n\n            sString = sString + nStart;\n            nLen    = nEnd - nStart;\n\n            int nCount = 0;\n            const int c_nNumLimit = 32;\n            unsigned char sBuffer[c_nNumLimit];\n            int nBufPos = 0;\n            bool bNewItem = true;\n\n            for ( int nIndex = 0; nIndex < nLen; ++nIndex )\n            {\n                unsigned char unChar = sString[nIndex];\n                if ( ' ' == unChar )\n                {\n                    if ( !bNewItem )\n                        bNewItem = true;\n\n                    continue;\n                }\n\n                if ( bNewItem )\n                {\n                    if ( nCount >= nMax )\n                        break;\n\n                    // \u0414\u043e\u0431\u0430\u0432\u043b\u044f\u0435\u043c \u043f\u0440\u0435\u0434\u044b\u0434\u0443\u0449\u0435\u0435 \u0447\u0438\u0441\u043b\u043e \u0432 \u043c\u0430\u0441\u0441\u0438\u0432\n                    if ( nCount > 0 )\n                        pArray[nCount - 1] = Utils::GetInteger( (const char *)sBuffer );\n\n                    memset( sBuffer, 0x00, c_nNumLimit );\n                    nBufPos = 0;\n\n                    bNewItem = false;\n                    nCount++;\n                }\n\n                sBuffer[nBufPos++] = unChar;\n            }\n\n            if ( 0 != sBuffer[0] && nCount > 0 )\n                pArray[nCount - 1] = Utils::GetInteger( (const char *)sBuffer );\n\n            return nCount;\n        }\n\n        double ReadDouble     (unsigned char *sString, int nMaxLen)\n        {\n            // \u0421\u043c\u0435\u0449\u0430\u0435\u043c\u0441\u044f \u043a \u043f\u0435\u0440\u0432\u043e\u043c\u0443 \u043f\u0440\u043e\u0431\u0435\u043b\u0443 (\u043f\u043e\u0441\u043b\u0435 \u043d\u0435\u0433\u043e \u0438\u0434\u0435\u0442 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435)\n            int nPos = 0;\n            while ( ' ' == sString[nPos] && nPos < nMaxLen )\n                nPos++;\n\n            return Utils::GetDouble( (const char*)( sString + nPos ) );\n        }\n        int    ReadInt        (unsigned char *sString, int nMaxLen)\n        {\n            int nPos = 0;\n            while ( ' ' == sString[nPos] && nPos < nMaxLen )\n                nPos++;\n\n            return Utils::GetInteger( (const char*)( sString + nPos ) );\n        }\n\n        bool   ReadBool       (unsigned char *sString, int nMaxLen)\n        {\n            int nStartPos = 0;\n            while ( ' ' == sString[nStartPos] && nStartPos < nMaxLen )\n                nStartPos++;\n\n            if ( nStartPos >= nMaxLen - 4 )\n                return false;\n\n            if ( 't' == sString[nStartPos + 0] &&\n                 'r' == sString[nStartPos + 1] &&\n                 'u' == sString[nStartPos + 2] &&\n                 'e' == sString[nStartPos + 3] )\n                return true;\n\n            return false;\n        }\n\n        Type1Charstring FlattenCharstring(Type1Charstring& oCharstring, int nBias = 0);\n        void   CFFCreateIndexHeader(FontFileOutputFunc pOutputFunc, void *pOutputStream, CArray<std::wstring> aObjects);\n        void   CFFCreateIndexHeader(FontFileOutputFunc pOutputFunc, void *pOutputStream, CArray<Type1Charstring> aObjects);\n        void   CFFEncodeNumber     (FontFileOutputFunc pOutputFunc, void *pOutputStream, int nValue, bool bForceLong = false);\n        void   CFFEncodeNumber     (FontFileOutputFunc pOutputFunc, void *pOutputStream, double dValue);\n\n    private:\n\n        char                         *m_sName;\n        char                        **m_arrEncoding;\n        bool                          m_bParsed;\n\n        Type1PrivateDict              m_oPrivateDict;\n        Type1TopDict                  m_oTopDict;\n\n        CArray<Type1Glyph>      m_arrCharstrings;\n        CArray<Type1Charstring> m_arrSubrs;\n    };\n}\n\n#endif /* _ASC_FONTCONVERTER_FONT_FILE_TYPE1_H */\n"], "filenames": ["DesktopEditor/common/File.cpp", "DesktopEditor/cximage/CxImage/xfile.h", "DesktopEditor/cximage/CxImage/ximabmp.cpp", "DesktopEditor/cximage/CxImage/ximage.cpp", "DesktopEditor/cximage/CxImage/ximage.h", "DesktopEditor/cximage/CxImage/ximaico.cpp", "DesktopEditor/cximage/CxImage/ximainfo.cpp", "DesktopEditor/cximage/CxImage/ximapcx.cpp", "DesktopEditor/cximage/CxImage/ximatif.cpp", "DesktopEditor/cximage/CxImage/xiofile.h", "DesktopEditor/cximage/CxImage/xmemfile.cpp", "DesktopEditor/cximage/CxImage/xmemfile.h", "DesktopEditor/cximage/jasper/jpc/jpc_dec.c", "DesktopEditor/cximage/raw/libdcr.c", "DesktopEditor/cximage/tiff/tif_dirread.c", "DesktopEditor/cximage/tiff/tif_ojpeg.c", "DesktopEditor/fontengine/fontconverter/FontFileType1.cpp", "DesktopEditor/fontengine/fontconverter/FontFileType1.h"], "buggy_code_start_loc": [162, 52, 136, 24, 292, 98, 182, 52, 304, 62, 48, 17, 2174, 3521, 208, 1923, 635, 261], "buggy_code_end_loc": [303, 74, 359, 354, 798, 101, 182, 142, 460, 64, 57, 18, 2175, 5852, 891, 1924, 643, 261], "fixing_code_start_loc": [162, 52, 136, 24, 292, 98, 183, 53, 304, 62, 48, 17, 2174, 3521, 208, 1923, 636, 262], "fixing_code_end_loc": [358, 98, 359, 361, 802, 107, 187, 156, 471, 66, 57, 18, 2180, 5863, 891, 1926, 646, 264], "type": "CWE-787", "message": "Onlyoffice Document Server v6.0.0 and below and Core 6.1.0.26 and below were discovered to contain a stack overflow via the component DesktopEditor/common/File.cpp.", "other": {"cve": {"id": "CVE-2022-29776", "sourceIdentifier": "cve@mitre.org", "published": "2022-06-02T14:15:51.077", "lastModified": "2022-12-09T19:31:36.280", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Onlyoffice Document Server v6.0.0 and below and Core 6.1.0.26 and below were discovered to contain a stack overflow via the component DesktopEditor/common/File.cpp."}, {"lang": "es", "value": "Se ha detectado que Onlyoffice Document Server versiones v6.0.0 y anteriores y Core versiones 6.1.0.26 y anteriores, conten\u00edan un desbordamiento de pila por medio del componente DesktopEditor/common/File.cpp"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:onlyoffice:core:*:*:*:*:*:*:*:*", "versionEndIncluding": "6.1.0.26", "matchCriteriaId": "4D7538B8-3720-42EB-BE17-C272DFCEA122"}, {"vulnerable": true, "criteria": "cpe:2.3:a:onlyoffice:document_server:*:*:*:*:*:*:*:*", "versionEndIncluding": "6.0.0", "matchCriteriaId": "5398FF95-A6B1-4BE0-8A46-1FD03FDDE7D2"}]}]}], "references": [{"url": "https://github.com/ONLYOFFICE/DocumentServer/blob/master/CHANGELOG.md#601", "source": "cve@mitre.org", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/ONLYOFFICE/core/commit/88cf60a3ed4a2b40d71a1c2ced72fa3902a30967", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/moehw/poc_exploits/tree/master/CVE-2022-29776", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/ONLYOFFICE/core/commit/88cf60a3ed4a2b40d71a1c2ced72fa3902a30967"}}