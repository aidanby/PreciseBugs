{"buggy_code": ["\ufeff\n/*\nCopyright (c) 2012-present Maximus5\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions\nare met:\n1. Redistributions of source code must retain the above copyright\n   notice, this list of conditions and the following disclaimer.\n2. Redistributions in binary form must reproduce the above copyright\n   notice, this list of conditions and the following disclaimer in the\n   documentation and/or other materials provided with the distribution.\n3. The name of the authors may not be used to endorse or promote products\n   derived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE AUTHOR ''AS IS'' AND ANY EXPRESS OR\nIMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\nOF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\nIN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,\nINCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\nNOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\nTHIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n\n#include \"ConsoleMain.h\"\n#include <winerror.h>\n#include <winnt.h>\n#include <tchar.h>\n#include <limits>\n#include \"../common/Common.h\"\n#include \"../common/ConEmuCheck.h\"\n#include \"../common/CmdLine.h\"\n#include \"../common/WConsole.h\"\n#include \"../ConEmu/version.h\"\n\n#include \"ConAnsiImpl.h\"\n#include \"ConEmuSrv.h\"\n#include \"ConsoleState.h\"\n\n#ifdef _DEBUG\n\t#define DUMP_CONSOLE_OUTPUT\n#endif\n\n\n\n#ifdef _DEBUG\n#define DebugString(x) OutputDebugString(x)\n#define DebugStringA(x) OutputDebugStringA(x)\n#else\n#define DebugString(x) //OutputDebugString(x)\n#define DebugStringA(x) //OutputDebugStringA(x)\n#endif\n\n#ifdef DUMP_UNKNOWN_ESCAPES\n#define DumpUnknownEscape(buf, cchLen) m_Owner->DumpEscape(buf, cchLen, SrvAnsi::de_Unknown)\n#define DumpKnownEscape(buf, cchLen, eType) m_Owner->DumpEscape(buf, cchLen, eType)\n#else\n#define DumpUnknownEscape(buf,cchLen)\n#define DumpKnownEscape(buf, cchLen, eType)\n#endif\n\n\n\nSrvAnsiImpl::SrvAnsiImpl(SrvAnsi* _owner, condata::Table* _table)\n\t: m_UseLock(_owner->m_UseMutex)\n\t, m_Owner(_owner)\n\t, m_Table(_table)\n{\n\tm_Owner->GetFeatures(nullptr, &m_Owner->mb_SuppressBells);\n}\n\nSrvAnsiImpl::~SrvAnsiImpl()\n{\n}\n\n\nbool SrvAnsiImpl::OurWriteConsole(const wchar_t* lpBuffer, DWORD nNumberOfCharsToWrite, LPDWORD lpNumberOfCharsWritten)\n{\n\tbool lbRc = false;\n\n\t// For debugger breakpoint\n\tm_Owner->FirstAnsiCall((const BYTE*)lpBuffer, nNumberOfCharsToWrite);\n\t// In debug builds: Write to debug console all console Output\n\tDumpKnownEscape((wchar_t*)lpBuffer, nNumberOfCharsToWrite, SrvAnsi::de_Normal);\n\n\t// Logging?\n\tif (lpBuffer && nNumberOfCharsToWrite && m_Owner->ghAnsiLogFile)\n\t{\n\t\tm_Owner->WriteAnsiLogW(lpBuffer, nNumberOfCharsToWrite);\n\t}\n\n\tCEStr CpCvt;\n\n\tif (lpBuffer && nNumberOfCharsToWrite)\n\t{\n\t\t// if that was API call of WriteConsoleW\n\t\tif (m_Owner->gCpConv.nFromCP && m_Owner->gCpConv.nToCP)\n\t\t{\n\t\t\t// Convert from Unicode to MBCS\n\t\t\tint iMBCSLen = WideCharToMultiByte(m_Owner->gCpConv.nFromCP, 0, (LPCWSTR)lpBuffer, nNumberOfCharsToWrite, nullptr, 0, nullptr, nullptr);\n\t\t\tif (iMBCSLen > 0)\n\t\t\t{\n\t\t\t\tCEStrA szTemp;\n\t\t\t\tif (char* pszTemp = szTemp.GetBuffer(iMBCSLen))\n\t\t\t\t{\n\t\t\t\t\tBOOL bFailed = FALSE; // Do not do conversion if some chars can't be mapped\n\t\t\t\t\tiMBCSLen = WideCharToMultiByte(m_Owner->gCpConv.nFromCP, 0, (LPCWSTR)lpBuffer, nNumberOfCharsToWrite, pszTemp, iMBCSLen, nullptr, &bFailed);\n\t\t\t\t\tif ((iMBCSLen > 0) && !bFailed)\n\t\t\t\t\t{\n\t\t\t\t\t\tint iWideLen = MultiByteToWideChar(m_Owner->gCpConv.nToCP, 0, pszTemp, iMBCSLen, nullptr, 0);\n\t\t\t\t\t\tif (iWideLen > 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (wchar_t* ptrBuf = CpCvt.GetBuffer(iWideLen))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tiWideLen = MultiByteToWideChar(m_Owner->gCpConv.nToCP, 0, pszTemp, iMBCSLen, ptrBuf, iWideLen);\n\t\t\t\t\t\t\t\tif (iWideLen > 0)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tlpBuffer = ptrBuf;\n\t\t\t\t\t\t\t\t\tnNumberOfCharsToWrite = iWideLen;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t_ASSERTE(m_Owner->m_BellsCounter == 0);\n\tm_Owner->m_BellsCounter = 0;\n\n\t// The output\n\tlbRc = WriteAnsiCodes(lpBuffer, nNumberOfCharsToWrite, lpNumberOfCharsWritten);\n\n\t// Bells counter?\n\tif (m_Owner->m_BellsCounter)\n\t{\n\t\t// User may disable flashing in ConEmu settings\n\t\tCESERVER_REQ *pIn = ExecuteNewCmd(CECMD_FLASHWINDOW, sizeof(CESERVER_REQ_HDR)+sizeof(CESERVER_REQ_FLASHWINFO));\n\t\tif (pIn)\n\t\t{\n\t\t\tExecutePrepareCmd(pIn, CECMD_FLASHWINDOW, sizeof(CESERVER_REQ_HDR)+sizeof(CESERVER_REQ_FLASHWINFO)); //-V119\n\t\t\tpIn->Flash.fType = eFlashBeep;\n\t\t\tpIn->Flash.hWnd = gState.realConWnd_;\n\t\t\tpIn->Flash.bInvert = FALSE;\n\t\t\tpIn->Flash.dwFlags = FLASHW_ALL;\n\t\t\tpIn->Flash.uCount = 1;\n\t\t\tpIn->Flash.dwTimeout = 0;\n\t\t\tauto pOut = ExecuteGuiCmd(gState.realConWnd_, pIn, gState.realConWnd_);\n\t\t\tif (pOut) ExecuteFreeResult(pOut);\n\t\t\tExecuteFreeResult(pIn);\n\t\t}\n\t\tm_Owner->m_BellsCounter = 0;\n\t}\n\treturn lbRc;\n}\n\nbool SrvAnsiImpl::WriteText(LPCWSTR lpBuffer, DWORD nNumberOfCharsToWrite, LPDWORD lpNumberOfCharsWritten)\n{\n\tDWORD /*nWritten = 0,*/ nTotalWritten = 0;\n\n\tif (lpBuffer && nNumberOfCharsToWrite)\n\t\tm_Owner->m_LastWrittenChar = lpBuffer[nNumberOfCharsToWrite-1];\n\n\tLPCWSTR pszSrcBuffer = lpBuffer;\n\twchar_t cvtBuf[400], *pcvtBuf = nullptr; CEStr szTemp;\n\tif (m_Owner->mCharSet && lpBuffer && nNumberOfCharsToWrite)\n\t{\n\t\tstatic wchar_t G0_DRAWING[31] = {\n\t\t\t0x2666 /*\u2666*/, 0x2592 /*\u2592*/, 0x2192 /*\u2192*/, 0x21A8 /*\u21a8*/, 0x2190 /*\u2190*/, 0x2193 /*\u2193*/, 0x00B0 /*\u00b0*/, 0x00B1 /*\u00b1*/,\n\t\t\t0x00B6 /*\u00b6*/, 0x2195 /*\u2195*/, 0x2518 /*\u2518*/, 0x2510 /*\u2510*/, 0x250C /*\u250c*/, 0x2514 /*\u2514*/, 0x253C /*\u253c*/, 0x203E /*\u203e*/,\n\t\t\t0x207B /*\u207b*/, 0x2500 /*\u2500*/, 0x208B /*\u208b*/, 0x005F /*_*/, 0x251C /*\u251c*/, 0x2524 /*\u2524*/, 0x2534 /*\u2534*/, 0x252C /*\u252c*/,\n\t\t\t0x2502 /*\u2502*/, 0x2264 /*\u2264*/, 0x2265 /*\u2265*/, 0x03C0 /*\u03c0*/, 0x2260 /*\u2260*/, 0x00A3 /*\u00a3*/, 0x00B7 /*\u00b7*/\n\t\t};\n\t\tLPCWSTR pszMap = nullptr;\n\t\t// ReSharper disable once CppIncompleteSwitchStatement\n\t\tswitch (m_Owner->mCharSet)\n\t\t{\n\t\tcase SrvAnsi::VTCS_DRAWING:\n\t\t\tpszMap = G0_DRAWING;\n\t\t\tbreak;\n\t\t}\n\t\tif (pszMap)\n\t\t{\n\t\t\twchar_t* dst = nullptr;\n\t\t\tfor (DWORD i = 0; i < nNumberOfCharsToWrite; ++i)\n\t\t\t{\n\t\t\t\tif (pszSrcBuffer[i] >= 0x60 && pszSrcBuffer[i] < 0x7F)\n\t\t\t\t{\n\t\t\t\t\tif (!pcvtBuf)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (nNumberOfCharsToWrite <= countof(cvtBuf))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tpcvtBuf = cvtBuf;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (!((pcvtBuf = szTemp.GetBuffer(nNumberOfCharsToWrite))))\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlpBuffer = pcvtBuf;\n\t\t\t\t\t\tdst = pcvtBuf;\n\t\t\t\t\t\tif (i)\n\t\t\t\t\t\t\tmemmove_s(dst, nNumberOfCharsToWrite * sizeof(*dst), pszSrcBuffer, i * sizeof(*dst));\n\t\t\t\t\t}\n\t\t\t\t\tdst[i] = pszMap[pszSrcBuffer[i] - 0x60];\n\t\t\t\t}\n\t\t\t\telse if (dst)\n\t\t\t\t{\n\t\t\t\t\tdst[i] = pszSrcBuffer[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tm_Table->Write(lpBuffer, nNumberOfCharsToWrite);\n\n\tif (lpNumberOfCharsWritten)\n\t\t*lpNumberOfCharsWritten = nNumberOfCharsToWrite;\n\n\treturn true;\n}\n\n//struct AnsiEscCode\n//{\n//\twchar_t  First;  // ESC (27)\n//\twchar_t  Second; // any of 64 to 95 ('@' to '_')\n//\twchar_t  Action; // any of 64 to 126 (@ to ~). this is terminator\n//\twchar_t  Skip;   // \u0415\u0441\u043b\u0438 !=0 - \u0442\u043e \u044d\u0442\u0443 \u043f\u043e\u0441\u043b\u0435\u0434\u043e\u0432\u0430\u0442\u0435\u043b\u044c\u043d\u043e\u0441\u0442\u044c \u043d\u0443\u0436\u043d\u043e \u043f\u0440\u043e\u043f\u0443\u0441\u0442\u0438\u0442\u044c\n//\tint      ArgC;\n//\tint      ArgV[16];\n//\tLPCWSTR  ArgSZ; // Reserved for key mapping\n//\tsize_t   cchArgSZ;\n//\n//#ifdef _DEBUG\n//\tLPCWSTR  pszEscStart;\n//\tsize_t   nTotalLen;\n//#endif\n//\n//\tint      PvtLen;\n//\twchar_t  Pvt[16];\n//};\n\n\n// 0 - \u043d\u0435\u0442 (\u0432 lpBuffer \u0442\u043e\u043b\u044c\u043a\u043e \u0442\u0435\u043a\u0441\u0442)\n// 1 - \u0432 Code \u043f\u043e\u043c\u0435\u0449\u0435\u043d\u0430 Esc \u043f\u043e\u0441\u043b\u0435\u0434\u043e\u0432\u0430\u0442\u0435\u043b\u044c\u043d\u043e\u0441\u0442\u044c (\u043c\u043e\u0436\u0435\u0442 \u0431\u044b\u0442\u044c \u043f\u0440\u043e\u0441\u0442\u043e\u0439 \u0442\u0435\u043a\u0441\u0442 \u0414\u041e \u043d\u0435\u0435)\n// 2 - \u043d\u0435\u0442, \u043d\u043e \u043a\u0443\u0441\u043e\u043a \u043f\u043e\u0441\u043b\u0435\u0434\u043e\u0432\u0430\u0442\u0435\u043b\u044c\u043d\u043e\u0441\u0442\u0438 \u0441\u043e\u0445\u0440\u0430\u043d\u0435\u043d \u0432 gsPrevAnsiPart\nint SrvAnsiImpl::NextEscCode(LPCWSTR lpBuffer, LPCWSTR lpEnd, wchar_t (&szPreDump)[SrvAnsi::CEAnsi_MaxPrevPart], DWORD& cchPrevPart, LPCWSTR& lpStart, LPCWSTR& lpNext, SrvAnsiImpl::AnsiEscCode& Code, bool ReEntrance /*= FALSE*/)\n{\n\tint iRc = 0;\n\twchar_t wc;\n\n\tLPCWSTR lpSaveStart = lpBuffer;\n\tlpStart = lpBuffer;\n\n\t_ASSERTEX(cchPrevPart==0);\n\n\tauto& gsPrevAnsiPart = m_Owner->gsPrevAnsiPart;\n\tauto& gnPrevAnsiPart = m_Owner->gnPrevAnsiPart;\n\tauto& gsPrevAnsiPart2 = m_Owner->gsPrevAnsiPart2;\n\tauto& gnPrevAnsiPart2 = m_Owner->gnPrevAnsiPart2;\n\n\tif (gnPrevAnsiPart && !ReEntrance)\n\t{\n\t\tif (*gsPrevAnsiPart == 27)\n\t\t{\n\t\t\t_ASSERTEX(gnPrevAnsiPart < 79);\n\t\t\tssize_t nCurPrevLen = gnPrevAnsiPart;\n\t\t\tssize_t nAdd = std::min((lpEnd-lpBuffer),(ssize_t)countof(gsPrevAnsiPart)-nCurPrevLen-1);\n\t\t\t// Need to check buffer overflow!!!\n\t\t\t_ASSERTEX((ssize_t)countof(gsPrevAnsiPart)>(nCurPrevLen+nAdd));\n\t\t\twmemcpy(gsPrevAnsiPart+nCurPrevLen, lpBuffer, nAdd);\n\t\t\tgsPrevAnsiPart[nCurPrevLen+nAdd] = 0;\n\n\t\t\tWARNING(\"\u041f\u0440\u043e\u0432\u0435\u0440\u0438\u0442\u044c!!!\");\n\t\t\tLPCWSTR lpReStart, lpReNext;\n\t\t\tint iCall = NextEscCode(gsPrevAnsiPart, gsPrevAnsiPart+nAdd+gnPrevAnsiPart, szPreDump, cchPrevPart, lpReStart, lpReNext, Code, TRUE);\n\t\t\tif (iCall == 1)\n\t\t\t{\n\t\t\t\tif ((lpReNext - gsPrevAnsiPart) >= gnPrevAnsiPart)\n\t\t\t\t{\n\t\t\t\t\t// Bypass unrecognized ESC sequences to screen?\n\t\t\t\t\tif (lpReStart > gsPrevAnsiPart)\n\t\t\t\t\t{\n\t\t\t\t\t\tssize_t nSkipLen = (lpReStart - gsPrevAnsiPart); //DWORD nWritten;\n\t\t\t\t\t\t_ASSERTEX(nSkipLen>0 && nSkipLen<=countof(gsPrevAnsiPart) && nSkipLen<=gnPrevAnsiPart);\n\t\t\t\t\t\tDumpUnknownEscape(gsPrevAnsiPart, nSkipLen);\n\n\t\t\t\t\t\t//WriteText(gsPrevAnsiPart, nSkipLen, &nWritten);\n\t\t\t\t\t\t_ASSERTEX(nSkipLen <= ((int)SrvAnsi::CEAnsi_MaxPrevPart - (int)cchPrevPart));\n\t\t\t\t\t\tmemmove(szPreDump, gsPrevAnsiPart, nSkipLen);\n\t\t\t\t\t\tcchPrevPart += int(nSkipLen);\n\n\t\t\t\t\t\tif (nSkipLen < gnPrevAnsiPart)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tmemmove(gsPrevAnsiPart, lpReStart, (gnPrevAnsiPart - nSkipLen)*sizeof(*gsPrevAnsiPart));\n\t\t\t\t\t\t\tgnPrevAnsiPart -= nSkipLen;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t_ASSERTEX(nSkipLen == gnPrevAnsiPart);\n\t\t\t\t\t\t\t*gsPrevAnsiPart = 0;\n\t\t\t\t\t\t\tgnPrevAnsiPart = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlpReStart = gsPrevAnsiPart;\n\t\t\t\t\t}\n\t\t\t\t\t_ASSERTEX(lpReStart == gsPrevAnsiPart);\n\t\t\t\t\tlpStart = lpBuffer; // nothing to dump before Esc-sequence\n\t\t\t\t\t_ASSERTEX((lpReNext - gsPrevAnsiPart) >= gnPrevAnsiPart);\n\t\t\t\t\tWARNING(\"\u041f\u0440\u043e\u0432\u0435\u0440\u0438\u0442\u044c!!!\");\n\t\t\t\t\tlpNext = lpBuffer + (lpReNext - gsPrevAnsiPart - gnPrevAnsiPart);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t_ASSERTEX((lpReNext - gsPrevAnsiPart) >= gnPrevAnsiPart);\n\t\t\t\t\tlpStart = lpNext = lpBuffer;\n\t\t\t\t}\n\t\t\t\tgnPrevAnsiPart = 0;\n\t\t\t\tgsPrevAnsiPart[0] = 0;\n\t\t\t\tiRc = 1;\n\t\t\t\tgoto wrap2;\n\t\t\t}\n\t\t\telse if (iCall == 2)\n\t\t\t{\n\t\t\t\tgnPrevAnsiPart = nCurPrevLen+nAdd;\n\t\t\t\t_ASSERTEX(gsPrevAnsiPart[nCurPrevLen+nAdd] == 0);\n\t\t\t\tiRc = 2;\n\t\t\t\tgoto wrap;\n\t\t\t}\n\n\t\t\t_ASSERTEX((iCall == 1) && \"Invalid esc sequence, need dump to screen?\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\t_ASSERTEX(*gsPrevAnsiPart == 27);\n\t\t}\n\t}\n\n\n\twhile (lpBuffer < lpEnd)\n\t{\n\t\tswitch (*lpBuffer)\n\t\t{\n\t\tcase 27:\n\t\t\t{\n\t\t\t\tssize_t nLeft;\n\t\t\t\tLPCWSTR lpEscStart = lpBuffer;\n\n\t\t\t\t#ifdef _DEBUG\n\t\t\t\tCode.pszEscStart = lpBuffer;\n\t\t\t\tCode.nTotalLen = 0;\n\t\t\t\t#endif\n\n\t\t\t\t// Special one char codes? Like \"ESC 7\" and so on...\n\t\t\t\tif ((lpBuffer + 1) < lpEnd)\n\t\t\t\t{\n\t\t\t\t\t// But it may be some \"special\" codes\n\t\t\t\t\tswitch (lpBuffer[1])\n\t\t\t\t\t{\n\t\t\t\t\tcase L'7': // Save xterm cursor\n\t\t\t\t\tcase L'8': // Restore xterm cursor\n\t\t\t\t\tcase L'c': // Full reset\n\t\t\t\t\tcase L'g': // Visual Bell\n\t\t\t\t\tcase L'=':\n\t\t\t\t\tcase L'>':\n\t\t\t\t\tcase L'H': // Horizontal Tab Set\n\t\t\t\t\tcase L'M': // Reverse LF\n\t\t\t\t\tcase L'E': // CR-LF\n\t\t\t\t\tcase L'D': // LF\n\t\t\t\t\t\t// xterm?\n\t\t\t\t\t\tlpStart = lpEscStart;\n\t\t\t\t\t\tCode.First = 27;\n\t\t\t\t\t\tCode.Second = *(++lpBuffer);\n\t\t\t\t\t\tCode.ArgC = 0;\n\t\t\t\t\t\tCode.PvtLen = 0;\n\t\t\t\t\t\tCode.Pvt[0] = 0;\n\t\t\t\t\t\tlpEnd = (++lpBuffer);\n\t\t\t\t\t\tiRc = 1;\n\t\t\t\t\t\tgoto wrap;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// If tail is larger than 2 chars, continue\n\t\t\t\tif ((lpBuffer + 2) < lpEnd)\n\t\t\t\t{\n\t\t\t\t\t// Set lpSaveStart to current start of Esc sequence, it was set to beginning of buffer\n\t\t\t\t\t_ASSERTEX(lpSaveStart <= lpBuffer);\n\t\t\t\t\tlpSaveStart = lpBuffer;\n\t\t\t\t\t_ASSERTEX(lpSaveStart == lpEscStart);\n\n\t\t\t\t\tCode.First = 27;\n\t\t\t\t\tCode.Second = *(++lpBuffer);\n\t\t\t\t\tCode.ArgC = 0;\n\t\t\t\t\tCode.PvtLen = 0;\n\t\t\t\t\tCode.Pvt[0] = 0;\n\n\t\t\t\t\tTODO(\"Bypass unrecognized ESC sequences to screen? Don't try to eliminate 'Possible' sequences?\");\n\t\t\t\t\t//if (((Code.Second < 64) || (Code.Second > 95)) && (Code.Second != 124/* '|' - vim-xterm-emulation */))\n\t\t\t\t\tif (!wcschr(L\"[]|()%\", Code.Second))\n\t\t\t\t\t{\n\t\t\t\t\t\t// Don't assert on rawdump of KeyEvents.exe Esc key presses\n\t\t\t\t\t\t// 10:00:00 KEY_EVENT_RECORD: Dn, 1, Vk=\"VK_ESCAPE\" [27/0x001B], Scan=0x0001 uChar=[U='\\x1b' (0x001B): A='\\x1b' (0x1B)]\n\t\t\t\t\t\tbool bStandaloneEscChar = (lpStart < lpSaveStart) && ((*(lpSaveStart-1) == L'\\'' && Code.Second == L'\\'') || (*(lpSaveStart-1) == L' ' && Code.Second == L' '));\n\t\t\t\t\t\t//_ASSERTEX(bStandaloneEscChar && \"Unsupported control sequence?\");\n\t\t\t\t\t\tif (!bStandaloneEscChar)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, std::min<size_t>(Code.nTotalLen, 32), SrvAnsi::de_UnkControl);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue; // invalid code\n\t\t\t\t\t}\n\n\t\t\t\t\t// \u0422\u0435\u043f\u0435\u0440\u044c \u0438\u0434\u0443\u0442 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b.\n\t\t\t\t\t++lpBuffer; // \u043f\u0435\u0440\u0435\u043c\u0435\u0441\u0442\u0438\u043c \u0443\u043a\u0430\u0437\u0430\u0442\u0435\u043b\u044c \u043d\u0430 \u043f\u0435\u0440\u0432\u044b\u0439 \u0441\u0438\u043c\u0432\u043e\u043b \u0417\u0410 CSI (\u043f\u043e\u0441\u043b\u0435 '[')\n\n\t\t\t\t\tauto parseNumArgs = [&Code, lpSaveStart](const wchar_t* &lpBuffer, const wchar_t* lpSeqEnd, bool saveAction) -> bool\n\t\t\t\t\t{\n\t\t\t\t\t\twchar_t wc;\n\t\t\t\t\t\tint nValue = 0, nDigits = 0;\n\t\t\t\t\t\tCode.ArgC = 0;\n\n\t\t\t\t\t\twhile (lpBuffer < lpSeqEnd)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tswitch (*lpBuffer)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcase L'0': case L'1': case L'2': case L'3': case L'4':\n\t\t\t\t\t\t\tcase L'5': case L'6': case L'7': case L'8': case L'9':\n\t\t\t\t\t\t\t\tnValue = (nValue * 10) + (((int)*lpBuffer) - L'0');\n\t\t\t\t\t\t\t\t++nDigits;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase L';':\n\t\t\t\t\t\t\t\t// \u0414\u0430\u0436\u0435 \u0435\u0441\u043b\u0438 \u0446\u0438\u0444\u0440 \u043d\u0435 \u0431\u044b\u043b\u043e - default \"0\"\n\t\t\t\t\t\t\t\tif (Code.ArgC < (int)countof(Code.ArgV))\n\t\t\t\t\t\t\t\t\tCode.ArgV[Code.ArgC++] = nValue; // save argument\n\t\t\t\t\t\t\t\tnDigits = nValue = 0;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tif (Code.Second == L']')\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t// OSC specific, stop on first non-digit/non-semicolon\n\t\t\t\t\t\t\t\t\tif (nDigits && (Code.ArgC < (int)countof(Code.ArgV)))\n\t\t\t\t\t\t\t\t\t\tCode.ArgV[Code.ArgC++] = nValue;\n\t\t\t\t\t\t\t\t\treturn (Code.ArgC > 0);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse if (((wc = *lpBuffer) >= 64) && (wc <= 126))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t// Fin\n\t\t\t\t\t\t\t\t\tif (saveAction)\n\t\t\t\t\t\t\t\t\t\tCode.Action = wc;\n\t\t\t\t\t\t\t\t\tif (nDigits && (Code.ArgC < (int)countof(Code.ArgV)))\n\t\t\t\t\t\t\t\t\t\tCode.ArgV[Code.ArgC++] = nValue;\n\t\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tif ((size_t(Code.PvtLen) + 2) < countof(Code.Pvt))\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tCode.Pvt[Code.PvtLen++] = wc; // Skip private symbols\n\t\t\t\t\t\t\t\t\t\tCode.Pvt[Code.PvtLen] = 0;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t++lpBuffer;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (nDigits && (Code.ArgC < (int)countof(Code.ArgV)))\n\t\t\t\t\t\t\tCode.ArgV[Code.ArgC++] = nValue;\n\t\t\t\t\t\treturn (Code.Second == L']');\n\t\t\t\t\t};\n\n\t\t\t\t\tswitch (Code.Second)\n\t\t\t\t\t{\n\t\t\t\t\tcase L'(':\n\t\t\t\t\tcase L')':\n\t\t\t\t\tcase L'%':\n\t\t\t\t\t//case L'#':\n\t\t\t\t\t//case L'*':\n\t\t\t\t\t//case L'+':\n\t\t\t\t\t//case L'-':\n\t\t\t\t\t//case L'.':\n\t\t\t\t\t//case L'/':\n\t\t\t\t\t\t// VT G0/G1/G2/G3 character sets\n\t\t\t\t\t\tlpStart = lpSaveStart;\n\t\t\t\t\t\tCode.Action = *(lpBuffer++);\n\t\t\t\t\t\tCode.Skip = 0;\n\t\t\t\t\t\tCode.ArgSZ = nullptr;\n\t\t\t\t\t\tCode.cchArgSZ = 0;\n\t\t\t\t\t\tlpEnd = lpBuffer;\n\t\t\t\t\t\tiRc = 1;\n\t\t\t\t\t\tgoto wrap;\n\t\t\t\t\tcase L'|':\n\t\t\t\t\t\t// vim-xterm-emulation\n\t\t\t\t\tcase L'[':\n\t\t\t\t\t\t// Standard\n\t\t\t\t\t\tCode.Skip = 0;\n\t\t\t\t\t\tCode.ArgSZ = nullptr;\n\t\t\t\t\t\tCode.cchArgSZ = 0;\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t#ifdef _DEBUG\n\t\t\t\t\t\t\tLPCWSTR pszSaveStart = lpBuffer;\n\t\t\t\t\t\t\t#endif\n\n\t\t\t\t\t\t\tif (parseNumArgs(lpBuffer, lpEnd, true))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tlpStart = lpSaveStart;\n\t\t\t\t\t\t\t\tlpEnd = lpBuffer+1;\n\t\t\t\t\t\t\t\tiRc = 1;\n\t\t\t\t\t\t\t\tgoto wrap;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// \u0412 \u0434\u0430\u043d\u043d\u043e\u043c \u0437\u0430\u043f\u0440\u043e\u0441\u0435 (\u043d\u0430 \u0437\u0430\u043f\u0438\u0441\u044c) \u043a\u043e\u043d\u0446\u0430 \u043f\u043e\u0441\u043b\u0435\u0434\u043e\u0432\u0430\u0442\u0435\u043b\u044c\u043d\u043e\u0441\u0442\u0438 \u043d\u0435\u0442,\n\t\t\t\t\t\t// \u043e\u0441\u0442\u0430\u0432\u0448\u0438\u0439\u0441\u044f \u0445\u0432\u043e\u0441\u0442 \u043d\u0443\u0436\u043d\u043e \u0441\u043e\u0445\u0440\u0430\u043d\u0438\u0442\u044c \u0432 \u0431\u0443\u0444\u0435\u0440\u0435, \u0434\u043b\u044f \u0441\u043b\u0435\u0434\u0443\u044e\u0449\u0435\u0433\u043e \u0437\u0430\u043f\u0440\u043e\u0441\u0430\n\t\t\t\t\t\t// \u041d\u0438\u0436\u0435\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase L']':\n\t\t\t\t\t\t// Finalizing (ST) with \"\\x1B\\\\\" or \"\\x07\"\n\t\t\t\t\t\t// \"%]4;16;rgb:00/00/00%\\\" - \"%\" is ESC\n\t\t\t\t\t\t// \"%]0;this is the window titleBEL\"\n\t\t\t\t\t\t// ESC ] 0 ; txt ST        Set icon name and window title to txt.\n\t\t\t\t\t\t// ESC ] 1 ; txt ST        Set icon name to txt.\n\t\t\t\t\t\t// ESC ] 2 ; txt ST        Set window title to txt.\n\t\t\t\t\t\t// ESC ] 4 ; num; txt ST   Set ANSI color num to txt.\n\t\t\t\t\t\t// ESC ] 10 ; txt ST       Set dynamic text color to txt.\n\t\t\t\t\t\t// ESC ] 4 6 ; name ST     Change log file to name (normally disabled\n\t\t\t\t\t\t//\t\t\t\t\t       by a compile-time option)\n\t\t\t\t\t\t// ESC ] 5 0 ; fn ST       Set font to fn.\n\t\t\t\t\t\t//Following 2 codes - from linux terminal\n\t\t\t\t\t\t// ESC ] P nrrggbb         Set palette, with parameter given in 7\n                        //                         hexadecimal digits after the final P :-(.\n\t\t\t\t\t\t//                         Here n is the color (0-15), and rrggbb indicates\n\t\t\t\t\t\t//                         the red/green/blue values (0-255).\n\t\t\t\t\t\t// ESC ] R                 reset palette\n\n\t\t\t\t\t\t// ConEmu specific\n\t\t\t\t\t\t// ESC ] 9 ; 1 ; ms ST           Sleep. ms - milliseconds\n\t\t\t\t\t\t// ESC ] 9 ; 2 ; \"txt\" ST        Show GUI MessageBox ( txt ) for dubug purposes\n\t\t\t\t\t\t// ESC ] 9 ; 3 ; \"txt\" ST        Set TAB text\n\t\t\t\t\t\t// ESC ] 9 ; 4 ; st ; pr ST      When _st_ is 0: remove progress. When _st_ is 1: set progress value to _pr_ (number, 0-100). When _st_ is 2: set error state in progress on Windows 7 taskbar\n\t\t\t\t\t\t// ESC ] 9 ; 5 ST                Wait for ENTER/SPACE/ESC. Set EnvVar \"ConEmuWaitKey\" to ENTER/SPACE/ESC on exit.\n\t\t\t\t\t\t// ESC ] 9 ; 6 ; \"txt\" ST        Execute GuiMacro. Set EnvVar \"ConEmuMacroResult\" on exit.\n\t\t\t\t\t\t// and others... look at SrvAnsiImpl::WriteAnsiCode_OSC\n\n\t\t\t\t\t\tCode.ArgSZ = lpBuffer;\n\t\t\t\t\t\tCode.cchArgSZ = 0;\n\t\t\t\t\t\t//Code.Skip = Code.Second;\n\n\t\t\t\t\t\twhile (lpBuffer < lpEnd)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif ((lpBuffer[0] == 7) ||\n\t\t\t\t\t\t\t\t(lpBuffer[0] == 27) /* we'll check the proper terminator below */)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tCode.Action = *Code.ArgSZ; // \u043f\u0435\u0440\u0432\u044b\u0439 \u0441\u0438\u043c\u0432\u043e\u043b \u043f\u043e\u0441\u043b\u0435\u0434\u043e\u0432\u0430\u0442\u0435\u043b\u044c\u043d\u043e\u0441\u0442\u0438\n\t\t\t\t\t\t\t\tCode.cchArgSZ = (lpBuffer - Code.ArgSZ);\n\t\t\t\t\t\t\t\tlpStart = lpSaveStart;\n\t\t\t\t\t\t\t\tconst wchar_t* lpBufferPtr = Code.ArgSZ;\n\t\t\t\t\t\t\t\tif (lpBuffer[0] == 27)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tif ((lpBuffer + 1) >= lpEnd)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t// Sequence is not complete yet!\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse if (lpBuffer[1] == L'\\\\')\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tlpEnd = lpBuffer + 2;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tlpEnd = lpBuffer - 1;\n\t\t\t\t\t\t\t\t\t\t_ASSERTE(*(lpEnd+1) == 27);\n\t\t\t\t\t\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t\t\t\t\t\t\t\t\tiRc = 0;\n\t\t\t\t\t\t\t\t\t\tgoto wrap;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tlpEnd = lpBuffer + 1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tparseNumArgs(lpBufferPtr, lpBuffer, false);\n\t\t\t\t\t\t\t\tiRc = 1;\n\t\t\t\t\t\t\t\tgoto wrap;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t++lpBuffer;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Sequence is not complete, we have to store it to concatenate\n\t\t\t\t\t\t// and check on future write call. Below.\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t// Unknown sequence, use common termination rules\n\t\t\t\t\t\tCode.Skip = Code.Second;\n\t\t\t\t\t\tCode.ArgSZ = lpBuffer;\n\t\t\t\t\t\tCode.cchArgSZ = 0;\n\t\t\t\t\t\twhile (lpBuffer < lpEnd)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// Terminator ASCII symbol: from `@` to `~`\n\t\t\t\t\t\t\tif (((wc = *lpBuffer) >= 64) && (wc <= 126))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tCode.Action = wc;\n\t\t\t\t\t\t\t\tlpStart = lpSaveStart;\n\t\t\t\t\t\t\t\tlpEnd = lpBuffer+1;\n\t\t\t\t\t\t\t\tiRc = 1;\n\t\t\t\t\t\t\t\tgoto wrap;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t++lpBuffer;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} // end of \"switch (Code.Second)\"\n\t\t\t\t} // end of minimal length check\n\n\t\t\t\tif ((nLeft = (lpEnd - lpEscStart)) <= SrvAnsi::CEAnsi_MaxPrevAnsiPart)\n\t\t\t\t{\n\t\t\t\t\tif (ReEntrance)\n\t\t\t\t\t{\n\t\t\t\t\t\t//_ASSERTEX(!ReEntrance && \"Need to be checked!\"); -- seems to be OK\n\n\t\t\t\t\t\t// gsPrevAnsiPart2 stored for debug purposes only (fully excess)\n\t\t\t\t\t\twmemmove(gsPrevAnsiPart2, lpEscStart, nLeft);\n\t\t\t\t\t\tgsPrevAnsiPart2[nLeft] = 0;\n\t\t\t\t\t\tgnPrevAnsiPart2 = nLeft;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\twmemmove(gsPrevAnsiPart, lpEscStart, nLeft);\n\t\t\t\t\t\tgsPrevAnsiPart[nLeft] = 0;\n\t\t\t\t\t\tgnPrevAnsiPart = nLeft;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t_ASSERTEX(FALSE && \"Too long Esc-sequence part, Need to be checked!\");\n\t\t\t\t}\n\n\t\t\t\tlpStart = lpEscStart;\n\n\t\t\t\tiRc = 2;\n\t\t\t\tgoto wrap;\n\t\t\t} // end of \"case 27:\"\n\t\t\tbreak;\n\t\t} // end of \"switch (*lpBuffer)\"\n\n\t\t++lpBuffer;\n\t} // end of \"while (lpBuffer < lpEnd)\"\n\nwrap:\n\tlpNext = lpEnd;\n\n\t#ifdef _DEBUG\n\tif (iRc == 1)\n\t\tCode.nTotalLen = (lpEnd - Code.pszEscStart);\n\t#endif\nwrap2:\n\t_ASSERTEX((iRc==0) || (lpStart>=lpSaveStart && lpStart<lpEnd));\n\treturn iRc;\n}\n\nbool SrvAnsiImpl::FullReset()\n{\n\tm_Owner->gDisplayParm.Reset(true);\n\tm_Table->Reset(m_Owner->GetDefaultAttr());\n\treturn TRUE;\n}\n\nstatic bool GetConsoleScreenBufferInfoCached(CONSOLE_SCREEN_BUFFER_INFO* csbi)\n{\n\t// #condata need to implement\n\tthrow;\n\treturn false;\n}\n\nvoid SrvAnsiImpl::ForwardLF()\n{\n\tm_Table->LineFeed(false);\n\tm_Table->PromptPosReset();\n}\n\nvoid SrvAnsiImpl::ForwardCRLF()\n{\n\tm_Table->Write(L\"\\r\\n\", 2);\n}\n\nvoid SrvAnsiImpl::ReverseLF()\n{\n\tconst auto cur = m_Table->GetCursor();\n\tif (cur.y <= 0)\n\t{\n\t\tm_Table->InsertRow();\n\t}\n\telse\n\t{\n\t\t// Just move cursor upwards\n\t\tm_Table->SetCursor({cur.x, cur.y - 1});\n\t}\n\tm_Table->PromptPosReset();\n}\n\nint SrvAnsiImpl::NextNumber(LPCWSTR& asMS)\n{\n\twchar_t wc;\n\tint ms = 0;\n\twhile (((wc = *(asMS++)) >= L'0') && (wc <= L'9'))\n\t\tms = (ms * 10) + (int)(wc - L'0');\n\treturn ms;\n}\n\n// ESC ] 9 ; 1 ; ms ST           Sleep. ms - milliseconds\nvoid SrvAnsiImpl::DoSleep(LPCWSTR asMS)\n{\n\tint ms = NextNumber(asMS);\n\tif (!ms)\n\t\tms = 100;\n\telse if (ms > 10000)\n\t\tms = 10000;\n\t// Delay\n\tSleep(ms);\n}\n\nvoid SrvAnsiImpl::EscCopyCtrlString(wchar_t* pszDst, LPCWSTR asMsg, ssize_t cchMaxLen)\n{\n\tif (!pszDst)\n\t{\n\t\t_ASSERTEX(pszDst!=nullptr);\n\t\treturn;\n\t}\n\n\tif (cchMaxLen < 0)\n\t{\n\t\t_ASSERTEX(cchMaxLen >= 0);\n\t\tcchMaxLen = 0;\n\t}\n\tif (cchMaxLen > 1)\n\t{\n\t\tif ((asMsg[0] == L'\"') && (asMsg[cchMaxLen-1] == L'\"'))\n\t\t{\n\t\t\tasMsg++;\n\t\t\tcchMaxLen -= 2;\n\t\t}\n\t}\n\n\tif (cchMaxLen > 0)\n\t\twmemmove(pszDst, asMsg, cchMaxLen);\n\tpszDst[std::max<ssize_t>(cchMaxLen, 0)] = 0;\n}\n\n// ESC ] 9 ; 2 ; \"txt\" ST          Show GUI MessageBox ( txt ) for dubug purposes\nvoid SrvAnsiImpl::DoMessage(LPCWSTR asMsg, ssize_t cchLen)\n{\n\twchar_t* pszText = (wchar_t*)malloc((cchLen+1)*sizeof(*pszText));\n\n\tif (pszText)\n\t{\n\t\tEscCopyCtrlString(pszText, asMsg, cchLen);\n\t\t//if (cchLen > 0)\n\t\t//\twmemmove(pszText, asMsg, cchLen);\n\t\t//pszText[cchLen] = 0;\n\n\t\twchar_t szExe[MAX_PATH] = {};\n\t\tGetModuleFileName(nullptr, szExe, countof(szExe));\n\t\twchar_t szTitle[MAX_PATH+64];\n\t\tmsprintf(szTitle, countof(szTitle), L\"PID=%u, %s\", GetCurrentProcessId(), PointToName(szExe));\n\n\t\tGuiMessageBox(gState.conemuWnd_, pszText, szTitle, MB_ICONINFORMATION|MB_SYSTEMMODAL);\n\n\t\tfree(pszText);\n\t}\n}\n\nbool SrvAnsiImpl::IsAnsiExecAllowed(LPCWSTR asCmd)\n{\n\t// Invalid command or macro?\n\tif (!asCmd || !*asCmd)\n\t\treturn false;\n\n\t// We need to check settings\n\tCESERVER_CONSOLE_MAPPING_HDR* pMap = m_Owner->GetConMap();\n\tif (!pMap)\n\t\treturn false;\n\n\tif ((pMap->Flags & ConEmu::ConsoleFlags::AnsiExecAny) != 0)\n\t{\n\t\t// Allowed in any process\n\t}\n\telse if ((pMap->Flags & ConEmu::ConsoleFlags::AnsiExecCmd) != 0)\n\t{\n\t\t// #condata Allowed in Cmd.exe only\n\t\t// if (!gbIsCmdProcess)\n\t\treturn false;\n\t}\n\telse\n\t{\n\t\t// Disallowed everywhere\n\t\treturn false;\n\t}\n\n\t// Now we need to ask GUI, if the command (asCmd) is allowed\n\tbool bAllowed = false;\n\tssize_t cchLen = wcslen(asCmd) + 1;\n\tCESERVER_REQ* pOut = nullptr;\n\tCESERVER_REQ* pIn = ExecuteNewCmd(CECMD_ALLOWANSIEXEC, sizeof(CESERVER_REQ_HDR)+sizeof(wchar_t)*cchLen);\n\n\tif (pIn)\n\t{\n\t\t_ASSERTE(sizeof(pIn->wData[0])==sizeof(*asCmd));\n\t\tmemmove(pIn->wData, asCmd, cchLen*sizeof(pIn->wData[0]));\n\n\t\tpOut = ExecuteGuiCmd(gState.realConWnd_, pIn, gState.realConWnd_);\n\t\tif (pOut && (pOut->DataSize() == sizeof(pOut->dwData[0])))\n\t\t{\n\t\t\tbAllowed = (pOut->dwData[0] == TRUE);\n\t\t}\n\t}\n\n\tExecuteFreeResult(pOut);\n\tExecuteFreeResult(pIn);\n\n\treturn bAllowed;\n}\n\n// ESC ] 9 ; 6 ; \"macro\" ST        Execute some GuiMacro\nvoid SrvAnsiImpl::DoGuiMacro(LPCWSTR asCmd, ssize_t cchLen)\n{\n\tCESERVER_REQ* pOut = nullptr;\n\tCESERVER_REQ* pIn = ExecuteNewCmd(CECMD_GUIMACRO, sizeof(CESERVER_REQ_HDR)+sizeof(CESERVER_REQ_GUIMACRO)+sizeof(wchar_t)*(cchLen + 1));\n\n\tif (pIn)\n\t{\n\t\tEscCopyCtrlString(pIn->GuiMacro.sMacro, asCmd, cchLen);\n\n\t\tif (IsAnsiExecAllowed(pIn->GuiMacro.sMacro))\n\t\t{\n\t\t\tpOut = ExecuteGuiCmd(gState.realConWnd_, pIn, gState.realConWnd_);\n\t\t}\n\t}\n\n\t// EnvVar \"ConEmuMacroResult\"\n\tSetEnvironmentVariable(CEGUIMACRORETENVVAR, pOut && pOut->GuiMacro.nSucceeded ? pOut->GuiMacro.sMacro : nullptr);\n\n\tExecuteFreeResult(pOut);\n\tExecuteFreeResult(pIn);\n}\n\n// ESC ] 9 ; 7 ; \"cmd\" ST        Run some process with arguments\nvoid SrvAnsiImpl::DoProcess(LPCWSTR asCmd, ssize_t cchLen)\n{\n\t// We need zero-terminated string\n\twchar_t* pszCmdLine = (wchar_t*)malloc((cchLen + 1)*sizeof(*asCmd));\n\n\tif (pszCmdLine)\n\t{\n\t\tEscCopyCtrlString(pszCmdLine, asCmd, cchLen);\n\n\t\tif (IsAnsiExecAllowed(pszCmdLine))\n\t\t{\n\t\t\tSTARTUPINFO si = {};\n\t\t\tsi.cb = sizeof(si);\n\t\t\tPROCESS_INFORMATION pi = {};\n\n\t\t\tconst bool bCreated = CreateProcessW(nullptr, pszCmdLine, nullptr, nullptr, FALSE, 0, nullptr, nullptr, &si, &pi);\n\t\t\tif (bCreated)\n\t\t\t{\n\t\t\t\tWaitForSingleObject(pi.hProcess, INFINITE);\n\t\t\t\tCloseHandle(pi.hProcess);\n\t\t\t\tCloseHandle(pi.hThread);\n\t\t\t}\n\t\t}\n\n\t\tfree(pszCmdLine);\n\t}\n}\n\n// ESC ] 9 ; 8 ; \"env\" ST        Output value of environment variable\nvoid SrvAnsiImpl::DoPrintEnv(LPCWSTR asCmd, ssize_t cchLen)\n{\n\t// We need zero-terminated string\n\twchar_t* pszVarName = (wchar_t*)malloc((cchLen + 1)*sizeof(*asCmd));\n\n\tif (pszVarName)\n\t{\n\t\tEscCopyCtrlString(pszVarName, asCmd, cchLen);\n\n\t\twchar_t szValue[MAX_PATH];\n\t\twchar_t* pszValue = szValue;\n\t\tDWORD cchMax = countof(szValue);\n\t\tDWORD nMax = GetEnvironmentVariable(pszVarName, pszValue, cchMax);\n\n\t\t// Some predefined as `time`, `date`, `cd`, ...\n\t\tif (!nMax)\n\t\t{\n\t\t\tif ((lstrcmpi(pszVarName, L\"date\") == 0)\n\t\t\t\t|| (lstrcmpi(pszVarName, L\"time\") == 0))\n\t\t\t{\n\t\t\t\tSYSTEMTIME st = {}; GetLocalTime(&st);\n\t\t\t\tif (lstrcmpi(pszVarName, L\"date\") == 0)\n\t\t\t\t\tswprintf_c(szValue, L\"%u-%02u-%02u\", st.wYear, st.wMonth, st.wDay);\n\t\t\t\telse\n\t\t\t\t\tswprintf_c(szValue, L\"%u:%02u:%02u.%03u\", st.wHour, st.wMinute, st.wSecond, st.wMilliseconds);\n\t\t\t\tnMax = lstrlen(szValue);\n\t\t\t}\n\t\t\t#if 0\n\t\t\telse if (lstrcmpi(pszVarName, L\"cd\") == 0)\n\t\t\t{\n\t\t\t\t//TODO: If possible\n\t\t\t}\n\t\t\t#endif\n\t\t}\n\n\t\tif (nMax >= cchMax)\n\t\t{\n\t\t\tcchMax = nMax+1;\n\t\t\tpszValue = (wchar_t*)malloc(cchMax*sizeof(*pszValue));\n\t\t\tnMax = pszValue ? GetEnvironmentVariable(pszVarName, szValue, countof(szValue)) : 0;\n\t\t}\n\n\t\tif (nMax)\n\t\t{\n\t\t\tTODO(\"Process here ANSI colors TOO! But now it will be 'reentrance'?\");\n\t\t\tWriteText(pszValue, nMax, &cchMax);\n\t\t}\n\n\t\tif (pszValue && pszValue != szValue)\n\t\t\tfree(pszValue);\n\t\tfree(pszVarName);\n\t}\n}\n\n// ESC ] 9 ; 9 ; \"cwd\" ST        Inform ConEmu about shell current working directory\nvoid SrvAnsiImpl::DoSendCWD(LPCWSTR asCmd, ssize_t cchLen)\n{\n\t// We need zero-terminated string\n\twchar_t* pszCWD = (wchar_t*)malloc((cchLen + 1)*sizeof(*asCmd));\n\n\tif (pszCWD)\n\t{\n\t\tEscCopyCtrlString(pszCWD, asCmd, cchLen);\n\n\t\t// Sends CECMD_STORECURDIR into RConServer\n\t\tSendCurrentDirectory(gState.realConWnd_, pszCWD);\n\n\t\tfree(pszCWD);\n\t}\n}\n\n// When _st_ is 0: remove progress.\n// When _st_ is 1: set progress value to _pr_ (number, 0-100).\n// When _st_ is 2: set error state in progress on Windows 7 taskbar\nvoid SrvAnsiImpl::DoSetProgress(const AnsiProgressStatus st, const WORD pr, LPCWSTR pszName /*= nullptr*/)\n{\n\tint nLen = pszName ? (lstrlen(pszName) + 1) : 1;\n\tCESERVER_REQ* pIn = ExecuteNewCmd(CECMD_SETPROGRESS, sizeof(CESERVER_REQ_HDR) + sizeof(WORD) * (2 + nLen));\n\tif (pIn)\n\t{\n\t\tpIn->wData[0] = static_cast<WORD>(st);\n\t\tpIn->wData[1] = pr;  // NOLINT(clang-diagnostic-array-bounds)\n\t\tif (pszName)\n\t\t{\n\t\t\tlstrcpy((wchar_t*)(pIn->wData+2), pszName);\n\t\t}\n\n\t\tCESERVER_REQ* pOut = ExecuteGuiCmd(gState.realConWnd_, pIn, gState.realConWnd_);\n\t\tExecuteFreeResult(pIn);\n\t\tExecuteFreeResult(pOut);\n\t}\n}\n\n\nbool SrvAnsiImpl::ReportString(LPCWSTR asRet)\n{\n\tif (!asRet || !*asRet)\n\t\treturn FALSE;\n\tINPUT_RECORD ir[16] = {};\n\tint nLen = lstrlen(asRet);\n\tINPUT_RECORD* pir = (nLen <= (int)countof(ir)) ? ir : (INPUT_RECORD*)calloc(nLen,sizeof(INPUT_RECORD));\n\tif (!pir)\n\t\treturn FALSE;\n\n\tINPUT_RECORD* p = pir;\n\tLPCWSTR pc = asRet;\n\tfor (int i = 0; i < nLen; i++, p++, pc++)\n\t{\n\t\tconst char ch = *pc >= 0x20 ? *pc : L' ';\n\t\tp->EventType = KEY_EVENT;\n\t\tp->Event.KeyEvent.bKeyDown = TRUE;\n\t\tp->Event.KeyEvent.wRepeatCount = 1;\n\t\tp->Event.KeyEvent.uChar.UnicodeChar = ch;\n\t}\n\n\tDumpKnownEscape(asRet, nLen, SrvAnsi::de_Report);\n\n\tDWORD nWritten = 0;\n\tHANDLE hIn = GetStdHandle(STD_INPUT_HANDLE);\n\tbool bSuccess = WriteConsoleInput(hIn, pir, nLen, &nWritten) && (nWritten == nLen);\n\n\tif (pir != ir)\n\t\tfree(pir);\n\treturn bSuccess;\n}\n\nvoid SrvAnsiImpl::ReportConsoleTitle()\n{\n\twchar_t sTitle[MAX_PATH*2+6] = L\"\\x1B]l\";\n\twchar_t* p = sTitle+3;\n\t_ASSERTEX(lstrlen(sTitle)==3);\n\n\tDWORD nTitle = GetConsoleTitle(sTitle+3, MAX_PATH*2);\n\tp = sTitle + 3 + std::min<DWORD>(nTitle, MAX_PATH*2);\n\t*(p++) = L'\\x1B';\n\t*(p++) = L'\\\\';\n\t*(p++) = 0;\n\n\tReportString(sTitle);\n}\n\nvoid SrvAnsiImpl::ReportTerminalPixelSize()\n{\n\t// `CSI 4 ; height ; width t`\n\twchar_t szReport[64];\n\tint width = 0, height = 0;\n\tRECT rcWnd = {};\n\n\tif (gState.conemuWndDC_ && GetClientRect(gState.conemuWndDC_, &rcWnd))\n\t{\n\t\twidth = RectWidth(rcWnd);\n\t\theight = RectHeight(rcWnd);\n\t}\n\n\tif ((width <= 0 || height <= 0) && gState.realConWnd_ && GetClientRect(gState.realConWnd_, &rcWnd))\n\t{\n\t\twidth = RectWidth(rcWnd);\n\t\theight = RectHeight(rcWnd);\n\t}\n\n\tif (width <= 0 || height <= 0)\n\t{\n\t\t_ASSERTE(width > 0 && height > 0);\n\t\t// Both DC and RealConsole windows were failed?\n\t\tconst auto size = m_Table->GetSize();\n\t\t_ASSERTE(size.x > 0 && size.y > 0);\n\t\tconst int defCharWidth = 8, defCharHeight = 14;\n\t\twidth = size.x * defCharWidth;\n\t\theight = size.y * defCharHeight;\n\t}\n\n\tif (width > 0 && height > 0)\n\t{\n\t\tswprintf_c(szReport, L\"\\x1B[4;%u;%ut\", (uint32_t)height, (uint32_t)width);\n\t\tReportString(szReport);\n\t}\n}\n\nvoid SrvAnsiImpl::ReportTerminalCharSize(int code)\n{\n\tCONSOLE_SCREEN_BUFFER_INFO csbi = {};\n\tif (GetConsoleScreenBufferInfoCached(&csbi))\n\t{\n\t\twchar_t sCurInfo[64];\n\t\tmsprintf(sCurInfo, countof(sCurInfo),\n\t\t\tL\"\\x1B[%u;%u;%ut\",\n\t\t\tcode == 18 ? 8 : 9,\n\t\t\tcsbi.srWindow.Bottom-csbi.srWindow.Top+1, csbi.srWindow.Right-csbi.srWindow.Left+1);\n\t\tReportString(sCurInfo);\n\t}\n}\n\nvoid SrvAnsiImpl::ReportCursorPosition()\n{\n\tCONSOLE_SCREEN_BUFFER_INFO csbi = {};\n\tif (GetConsoleScreenBufferInfoCached(&csbi))\n\t{\n\t\twchar_t sCurInfo[32];\n\t\tmsprintf(sCurInfo, countof(sCurInfo),\n\t\t\tL\"\\x1B[%u;%uR\",\n\t\t\tcsbi.dwCursorPosition.Y-csbi.srWindow.Top+1, csbi.dwCursorPosition.X-csbi.srWindow.Left+1);\n\t\tReportString(sCurInfo);\n\t}\n}\n\nbool SrvAnsiImpl::WriteAnsiCodes(LPCWSTR lpBuffer, DWORD nNumberOfCharsToWrite, LPDWORD lpNumberOfCharsWritten)\n{\n\tbool lbRc = TRUE;\n\tLPCWSTR lpEnd = (lpBuffer + nNumberOfCharsToWrite);\n\tAnsiEscCode Code = {};\n\twchar_t szPreDump[SrvAnsi::CEAnsi_MaxPrevPart];\n\tDWORD cchPrevPart;\n\n\t//ExtWriteTextParm write = {sizeof(write), ewtf_Current};\n\t//write.Private = _WriteConsoleW;\n\n\twhile (lpBuffer < lpEnd)\n\t{\n\t\tLPCWSTR lpStart = nullptr, lpNext = nullptr; // Required to be nullptr-initialized\n\n\t\t// '^' is ESC\n\t\t// ^[0;31;47m   $E[31;47m   ^[0m ^[0;1;31;47m  $E[1;31;47m  ^[0m\n\n\t\tcchPrevPart = 0;\n\n\t\tint iEsc = NextEscCode(lpBuffer, lpEnd, szPreDump, cchPrevPart, lpStart, lpNext, Code);\n\n\t\tif (cchPrevPart)\n\t\t{\n\t\t\tm_Owner->ApplyDisplayParm();\n\n\t\t\tlbRc = WriteText(szPreDump, cchPrevPart, lpNumberOfCharsWritten);\n\t\t\tif (!lbRc)\n\t\t\t\tgoto wrap;\n\t\t}\n\n\t\tif (iEsc != 0)\n\t\t{\n\t\t\tif (lpStart > lpBuffer)\n\t\t\t{\n\t\t\t\t_ASSERTEX((lpStart-lpBuffer) < (ssize_t)nNumberOfCharsToWrite);\n\n\t\t\t\tm_Owner->ApplyDisplayParm();\n\n\t\t\t\tDWORD nWrite = (DWORD)(lpStart - lpBuffer);\n\t\t\t\t//lbRc = WriteText(lpBuffer, nWrite, lpNumberOfCharsWritten);\n\t\t\t\tlbRc = WriteText(lpBuffer, nWrite, lpNumberOfCharsWritten);\n\t\t\t\tif (!lbRc)\n\t\t\t\t\tgoto wrap;\n\t\t\t\t//write.Buffer = lpBuffer;\n\t\t\t\t//write.NumberOfCharsToWrite = nWrite;\n\t\t\t\t//lbRc = ExtWriteText(&write);\n\t\t\t\t//if (!lbRc)\n\t\t\t\t//\tgoto wrap;\n\t\t\t\t//else\n\t\t\t\t//{\n\t\t\t\t//\tif (lpNumberOfCharsWritten)\n\t\t\t\t//\t\t*lpNumberOfCharsWritten = write.NumberOfCharsWritten;\n\t\t\t\t//\tif (write.ScrolledRowsUp > 0)\n\t\t\t\t//\t\tgDisplayCursor.StoredCursorPos.Y = std::max(0,((int)gDisplayCursor.StoredCursorPos.Y - (int)write.ScrolledRowsUp));\n\t\t\t\t//}\n\t\t\t}\n\n\t\t\tif (iEsc == 1)\n\t\t\t{\n\t\t\t\tif (Code.Skip)\n\t\t\t\t{\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tswitch (Code.Second)\n\t\t\t\t\t{\n\t\t\t\t\tcase L'[':  // ESC [ xxx\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tWriteAnsiCode_CSI(Code);\n\n\t\t\t\t\t\t} // case L'[':\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase L']': // ESC ] xxx \\ESC\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tWriteAnsiCode_OSC(Code);\n\n\t\t\t\t\t\t} // case L']':\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase L'|': // ESC | xxx\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// vim-xterm-emulation\n\t\t\t\t\t\t\tWriteAnsiCode_VIM(Code);\n\t\t\t\t\t\t} // case L'|':\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase L'7': // ESC 7\n\t\t\t\t\tcase L'8': // ESC 8\n\t\t\t\t\t\t//TODO: 7 - Save Cursor and _Attributes_\n\t\t\t\t\t\t//TODO: 8 - Restore Cursor and _Attributes_\n\t\t\t\t\t\tXTermSaveRestoreCursor((Code.Second == L'7'));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase L'c': // ESC c\n\t\t\t\t\t\t// Full reset\n\t\t\t\t\t\tFullReset();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase L'g':\n\t\t\t\t\t\t// User may disable flashing in ConEmu settings\n\t\t\t\t\t\t// #ANSI Implement GuiFlashWindow in common\n\t\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored);\n\t\t\t\t\t\t// GuiFlashWindow(eFlashBeep, gState.realConWnd, FALSE, FLASHW_ALL, 1, 0);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase L'H':\n\t\t\t\t\t\t// #ANSI gh-1827: support 'H' to set tab stops\n\t\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase L'M': // ESC M\n\t\t\t\t\t\tReverseLF();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase L'E': // ESC E\n\t\t\t\t\t\tForwardCRLF();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase L'D': // ESC D\n\t\t\t\t\t\tForwardLF();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase L'=': // ESC =\n\t\t\t\t\tcase L'>': // ESC >\n\t\t\t\t\t\t// xterm \"ESC =\" - Application Keypad (DECKPAM)\n\t\t\t\t\t\t// xterm \"ESC >\" - Normal Keypad (DECKPNM)\n\t\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, SrvAnsi::de_Ignored);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase L'(': // ESC (\n\t\t\t\t\t\t// xterm G0..G3?\n\t\t\t\t\t\tswitch (Code.Action)\n\t\t\t\t\t\t{\n\t\t\t\t\t\tcase L'0':\n\t\t\t\t\t\t\tm_Owner->mCharSet = SrvAnsi::VTCS_DRAWING;\n\t\t\t\t\t\t\t//DumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Comment);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase L'B':\n\t\t\t\t\t\t\tm_Owner->mCharSet = SrvAnsi::VTCS_DEFAULT;\n\t\t\t\t\t\t\t//DumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Comment);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tm_Owner->mCharSet = SrvAnsi::VTCS_DEFAULT;\n\t\t\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, SrvAnsi::de_Ignored);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse //if (iEsc != 2) // 2 - means \"Esc part stored in buffer\"\n\t\t{\n\t\t\t_ASSERTEX(iEsc == 0);\n\t\t\tif (lpNext > lpBuffer)\n\t\t\t{\n\t\t\t\tm_Owner->ApplyDisplayParm();\n\n\t\t\t\tDWORD nWrite = (DWORD)(lpNext - lpBuffer);\n\t\t\t\t//lbRc = WriteText(lpBuffer, nWrite, lpNumberOfCharsWritten);\n\t\t\t\tlbRc = WriteText(lpBuffer, nWrite, lpNumberOfCharsWritten);\n\t\t\t\tif (!lbRc)\n\t\t\t\t\tgoto wrap;\n\t\t\t\t//write.Buffer = lpBuffer;\n\t\t\t\t//write.NumberOfCharsToWrite = nWrite;\n\t\t\t\t//lbRc = ExtWriteText(&write);\n\t\t\t\t//if (!lbRc)\n\t\t\t\t//\tgoto wrap;\n\t\t\t\t//else\n\t\t\t\t//{\n\t\t\t\t//\tif (lpNumberOfCharsWritten)\n\t\t\t\t//\t\t*lpNumberOfCharsWritten = write.NumberOfCharsWritten;\n\t\t\t\t//\tif (write.ScrolledRowsUp > 0)\n\t\t\t\t//\t\tgDisplayCursor.StoredCursorPos.Y = std::max(0,((int)gDisplayCursor.StoredCursorPos.Y - (int)write.ScrolledRowsUp));\n\t\t\t\t//}\n\t\t\t}\n\t\t}\n\n\t\tif (lpNext > lpBuffer)\n\t\t{\n\t\t\tlpBuffer = lpNext;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t_ASSERTEX(lpNext > lpBuffer || lpNext == nullptr);\n\t\t\t++lpBuffer;\n\t\t}\n\t}\n\n\tif (lbRc && lpNumberOfCharsWritten)\n\t\t*lpNumberOfCharsWritten = nNumberOfCharsToWrite;\n\nwrap:\n\tm_Owner->ApplyDisplayParm();\n\treturn lbRc;\n}\n\nvoid SrvAnsiImpl::WriteAnsiCode_CSI(AnsiEscCode& Code)\n{\n\t/*\n\nCSI ? P m h\t\t\tDEC Private Mode Set (DECSET)\n\tP s = 4 7 \u2192 Use Alternate Screen Buffer (unless disabled by the titeInhibit resource)\n\tP s = 1 0 4 7 \u2192 Use Alternate Screen Buffer (unless disabled by the titeInhibit resource)\n\tP s = 1 0 4 8 \u2192 Save cursor as in DECSC (unless disabled by the titeInhibit resource)\n\tP s = 1 0 4 9 \u2192 Save cursor as in DECSC and use Alternate Screen Buffer, clearing it first (unless disabled by the titeInhibit resource). This combines the effects of the 1 0 4 7 and 1 0 4 8 modes. Use this with terminfo-based applications rather than the 4 7 mode.\n\nCSI ? P m l\t\t\tDEC Private Mode Reset (DECRST)\n\tP s = 4 7 \u2192 Use Normal Screen Buffer\n\tP s = 1 0 4 7 \u2192 Use Normal Screen Buffer, clearing screen first if in the Alternate Screen (unless disabled by the titeInhibit resource)\n\tP s = 1 0 4 8 \u2192 Restore cursor as in DECRC (unless disabled by the titeInhibit resource)\n\tP s = 1 0 4 9 \u2192 Use Normal Screen Buffer and restore cursor as in DECRC (unless disabled by the titeInhibit resource). This combines the effects of the 1 0 4 7 and 1 0 4 8 modes. Use this with terminfo-based applications rather than the 4 7 mode.\n\n\nCSI P s @\t\t\tInsert P s (Blank) Character(s) (default = 1) (ICH)\n\n\t*/\n\tswitch (Code.Action) // case sensitive\n\t{\n\tcase L's':\n\t\t// Save cursor position (can not be nested)\n\t\tXTermSaveRestoreCursor(true);\n\t\tbreak;\n\n\tcase L'u':\n\t\t// Restore cursor position\n\t\tXTermSaveRestoreCursor(false);\n\t\tbreak;\n\n\tcase L'H': // Set cursor position (1-based)\n\tcase L'f': // Same as 'H'\n\tcase L'A': // Cursor up by N rows\n\tcase L'B': // Cursor down by N rows\n\tcase L'C': // Cursor right by N cols\n\tcase L'D': // Cursor left by N cols\n\tcase L'E': // Moves cursor to beginning of the line n (default 1) lines down.\n\tcase L'F': // Moves cursor to beginning of the line n (default 1) lines up.\n\tcase L'G': // Moves the cursor to column n.\n\tcase L'd': // Moves the cursor to line n.\n\t\t// Change cursor position\n\t\t{\n\t\t\t//if (gbIsVimProcess)\n\t\t\t//\tgbIsVimAnsi = true;\n\n\t\t\tstruct PointXY {int X,Y;};\n\t\t\tconst auto& workSize = m_Table->GetSize();\n\t\t\tconst struct {int left, top, right, bottom;} workRgn = {0, 0, (int)workSize.x - 1, workSize.y - 1};\n\t\t\t_ASSERTEX(workRgn.left <= workRgn.right && workRgn.top <= workRgn.bottom);\n\t\t\tconst auto& clipRgn = m_Table->GetScrollRegion();\n\t\t\tconst auto cur = PointXY{(int)m_Table->GetCursor().x, m_Table->GetCursor().y};\n\t\t\tPointXY crNewPos = cur;\n\t\t\tenum class Direction { kAbsolute, kCompatible, kRelative };\n\n\t\t\tauto set_y = [&crNewPos, &workRgn, &clipRgn, &cur](Direction direction, int value)\n\t\t\t{\n\t\t\t\tconst int kLegacyY = 9999;\n\t\t\t\tif (direction == Direction::kCompatible && value >= std::min(kLegacyY, workRgn.bottom))\n\t\t\t\t\t// #XTERM_256 Allow to put cursor into the legacy true-color area\n\t\t\t\t\tcrNewPos.Y = workRgn.bottom;\n\t\t\t\telse if (direction == Direction::kAbsolute || direction == Direction::kCompatible)\n\t\t\t\t\tcrNewPos.Y = std::max(workRgn.top, std::min(workRgn.bottom, value));\n\t\t\t\telse if (value < 0 && cur.Y >= (int)clipRgn.Top)\n\t\t\t\t\tcrNewPos.Y = std::max<int>(clipRgn.Top, std::min(workRgn.bottom, cur.Y + value));\n\t\t\t\telse if (value > 0 && cur.Y <= (int)clipRgn.Bottom)\n\t\t\t\t\tcrNewPos.Y = std::max(workRgn.top, std::min<int>(clipRgn.Bottom, cur.Y + value));\n\t\t\t\telse\n\t\t\t\t\tcrNewPos.Y = std::max(workRgn.top, std::min(workRgn.bottom, cur.Y + value));\n\t\t\t};\n\t\t\tauto set_x = [&crNewPos, &workRgn, &clipRgn, &cur](Direction direction, int value)\n\t\t\t{\n\t\t\t\tif (direction == Direction::kAbsolute || direction == Direction::kCompatible)\n\t\t\t\t\tcrNewPos.X = std::max(workRgn.left, std::min(workRgn.right, value));\n\t\t\t\telse\n\t\t\t\t\tcrNewPos.X = std::max(workRgn.left, std::min(workRgn.right, cur.X + value));\n\t\t\t};\n\n\t\t\tswitch (Code.Action)\n\t\t\t{\n\t\t\tcase L'H':\n\t\t\t\t// Set cursor position (ANSI values are 1-based)\n\t\t\t\tset_y(Direction::kCompatible, (Code.ArgC > 0 && Code.ArgV[0]) ? (Code.ArgV[0] - 1) : 0);\n\t\t\t\tset_x(Direction::kAbsolute, (Code.ArgC > 1 && Code.ArgV[1]) ? (Code.ArgV[1] - 1) : 0);\n\t\t\t\tbreak;\n\t\t\tcase L'f':\n\t\t\t\t// Set cursor position (ANSI values are 1-based)\n\t\t\t\tset_y(Direction::kAbsolute, (Code.ArgC > 0 && Code.ArgV[0]) ? (Code.ArgV[0] - 1) : 0);\n\t\t\t\tset_x(Direction::kAbsolute, (Code.ArgC > 1 && Code.ArgV[1]) ? (Code.ArgV[1] - 1) : 0);\n\t\t\t\tbreak;\n\t\t\tcase L'A':\n\t\t\t\t// Cursor up by N rows\n\t\t\t\tset_y(Direction::kRelative, -((Code.ArgC > 0 && Code.ArgV[0]) ? Code.ArgV[0] : 1));\n\t\t\t\tbreak;\n\t\t\tcase L'B':\n\t\t\t\t// Cursor down by N rows\n\t\t\t\tset_y(Direction::kRelative, +((Code.ArgC > 0 && Code.ArgV[0]) ? Code.ArgV[0] : 1));\n\t\t\t\tbreak;\n\t\t\tcase L'C':\n\t\t\t\t// Cursor right by N cols\n\t\t\t\tset_x(Direction::kRelative, +((Code.ArgC > 0 && Code.ArgV[0]) ? Code.ArgV[0] : 1));\n\t\t\t\tbreak;\n\t\t\tcase L'D':\n\t\t\t\t// Cursor left by N cols\n\t\t\t\tset_x(Direction::kRelative, -((Code.ArgC > 0 && Code.ArgV[0]) ? Code.ArgV[0] : 1));\n\t\t\t\tbreak;\n\t\t\tcase L'E':\n\t\t\t\t// Moves cursor to beginning of the line n (default 1) lines down.\n\t\t\t\tset_y(Direction::kRelative, +((Code.ArgC > 0 && Code.ArgV[0]) ? Code.ArgV[0] : 1));\n\t\t\t\tset_x(Direction::kAbsolute, 0);\n\t\t\t\tbreak;\n\t\t\tcase L'F':\n\t\t\t\t// Moves cursor to beginning of the line n (default 1) lines up.\n\t\t\t\tset_y(Direction::kRelative, -((Code.ArgC > 0 && Code.ArgV[0]) ? Code.ArgV[0] : 1));\n\t\t\t\tset_x(Direction::kAbsolute, 0);\n\t\t\t\tbreak;\n\t\t\tcase L'G':\n\t\t\t\t// Moves the cursor to column n.\n\t\t\t\tset_x(Direction::kAbsolute, (Code.ArgC > 0) ? (Code.ArgV[0] - 1) : 0);\n\t\t\t\tbreak;\n\t\t\tcase L'd':\n\t\t\t\t// Moves the cursor to line n (almost the same as 'H', but leave X unchanged).\n\t\t\t\tset_y(Direction::kAbsolute, (Code.ArgC > 0) ? (Code.ArgV[0] - 1) : 0);\n\t\t\t\tbreak;\n\t\t\t#ifdef _DEBUG\n\t\t\tdefault:\n\t\t\t\t_ASSERTEX(FALSE && \"Missed (sub)case value!\");\n\t\t\t#endif\n\t\t\t}\n\n\t\t\t// Goto\n\t\t\tm_Table->SetCursor({unsigned(crNewPos.X), crNewPos.Y});\n\n\t\t} // case 'H', 'f', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'd'\n\t\tbreak;\n\n\tcase L'J': // Clears part of the screen\n\t\t// Clears the screen and moves the cursor to the home position (line 0, column 0).\n\t\t{\n\t\t\tm_Owner->ApplyDisplayParm();\n\n\t\t\tint nCmd = (Code.ArgC > 0) ? Code.ArgV[0] : 0;\n\t\t\tcondata::Coord cur_pos = {};\n\t\t\tint from_row = -1, to_row = 0;\n\n\t\t\tswitch (nCmd)\n\t\t\t{\n\t\t\tcase 0:\n\t\t\t\t// clear from cursor to end of screen\n\t\t\t\tcur_pos = m_Table->GetCursor();\n\t\t\t\tfrom_row = cur_pos.y;\n\t\t\t\tto_row = m_Table->GetSize().y - 1;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\t// clear from cursor to beginning of the screen\n\t\t\t\tcur_pos = m_Table->GetCursor();\n\t\t\t\tfrom_row = 0;\n\t\t\t\tto_row = cur_pos.y;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\t// clear entire screen\n\t\t\t\tm_Table->ClearWorkspace();\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\t// xterm: clear scrollback buffer entirely\n\t\t\t\tm_Table->ClearBackscroll();\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t\t}\n\n\t\t\t// Clears only part of working area\n\t\t\tif (from_row >= 0)\n\t\t\t{\n\t\t\t\t_ASSERTE(to_row >= from_row);\n\t\t\t\tconst auto attr = m_Table->GetAttr();\n\t\t\t\tfor (int row = to_row; row >= from_row; --row)\n\t\t\t\t{\n\t\t\t\t\tif (row != cur_pos.y)\n\t\t\t\t\t\tm_Table->GetRow((unsigned)row)->Reset(attr);\n\t\t\t\t}\n\n\t\t\t\tauto row = m_Table->CurrentRow();\n\t\t\t\tswitch (nCmd)\n\t\t\t\t{\n\t\t\t\tcase 0:\n\t\t\t\t\t// clear from cursor to end of screen\n\t\t\t\t\trow->Delete(cur_pos.x, row->GetLength() - cur_pos.x);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\t// clear from cursor to beginning of the screen\n\t\t\t\t\trow->Delete(0, cur_pos.x + 1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t} // case L'J':\n\t\tbreak;\n\n\tcase L'b': // repeat output of the last written char N times\n\t\tif (!Code.PvtLen)\n\t\t{\n\t\t\tint repeat = (Code.ArgC > 0) ? Code.ArgV[0] : 1;\n\t\t\tif (m_Owner->m_LastWrittenChar && repeat > 0)\n\t\t\t{\n\t\t\t\tCEStr buffer;\n\t\t\t\tif (wchar_t* ptr = buffer.GetBuffer(repeat))\n\t\t\t\t{\n\t\t\t\t\tfor (int i = 0; i < repeat; ++i)\n\t\t\t\t\t\tptr[i] = m_Owner->m_LastWrittenChar;\n\t\t\t\t\tWriteText(ptr, repeat, nullptr);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\tbreak; // case L'b'\n\n\tcase L'K': // Erases part of the line\n\t\t{\n\t\t\tm_Owner->ApplyDisplayParm();\n\n\t\t\tint nCmd = (Code.ArgC > 0) ? Code.ArgV[0] : 0;\n\t\t\tconst auto cur = m_Table->GetCursor();\n\t\t\tauto row = m_Table->CurrentRow();\n\n\t\t\tswitch (nCmd)\n\t\t\t{\n\t\t\tcase 0: // clear from cursor to the end of the line (including char under the cursor)\n\t\t\t\trow->Delete(cur.x, row->GetLength() - cur.x);\n\t\t\t\tbreak;\n\t\t\tcase 1: // clear from cursor to beginning of the line (including char under the cursor)\n\t\t\t\trow->Write(0, m_Table->GetAttr(), L' ', cur.x + 1);\n\t\t\t\tbreak;\n\t\t\tcase 2: // clear entire line\n\t\t\t\t*row = condata::Row(m_Table->GetAttr());\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t\t}\n\t\t}\n\t\tbreak; // case L'K':\n\n\tcase L'r':\n\t\t//\\027[Pt;Pbr\n\t\t//\n\t\t// Pt is the number of the top line of the scrolling region;\n\t\t// Pb is the number of the bottom line of the scrolling region\n\t\t//  and must be greater than Pt.\n\t\t// (The default for Pt is line 1, the default for Pb is the end\n\t\t// of the screen)\n\t\t//\n\t\t// Values are 1-based\n\t\tif ((Code.ArgC >= 2) && (Code.ArgV[0] >= 0) && (Code.ArgV[1] >= Code.ArgV[0]))\n\t\t\tSetScrollRegion(true, Code.ArgV[0], Code.ArgV[1]);\n\t\telse\n\t\t\tSetScrollRegion(false);\n\t\tbreak; // L'r'\n\n\tcase L'L':\n\t\t// Insert P s Line(s) (default = 1) (IL).\n\t\tm_Owner->ApplyDisplayParm();\n\t\tm_Table->InsertRow((Code.ArgC > 0 && Code.ArgV[0] > 0) ? Code.ArgV[0] : 1);\n\t\tbreak;\n\n\tcase L'M':\n\t\t// Delete N Line(s) (default = 1) (DL).\n\t\t// This is actually \"Scroll UP N line(s) inside defined scrolling region\"\n\t\tm_Owner->ApplyDisplayParm();\n\t\tm_Table->DeleteRow((Code.ArgC > 0 && Code.ArgV[0] > 0) ? Code.ArgV[0] : 1);\n\t\tbreak;\n\n\tcase L'@':\n\t\t// Insert P s (Blank) Character(s) (default = 1) (ICH).\n\t\tm_Owner->ApplyDisplayParm();\n\t\tm_Table->InsertCell((Code.ArgC > 0 && Code.ArgV[0] > 0) ? Code.ArgV[0] : 1);\n\t\tbreak;\n\tcase L'P':\n\t\t// Delete P s Character(s) (default = 1) (DCH).\n\t\tm_Owner->ApplyDisplayParm();\n\t\tm_Table->DeleteCell((Code.ArgC > 0 && Code.ArgV[0] > 0) ? Code.ArgV[0] : 1);\n\t\tbreak;\n\n\tcase L'S':\n\t\t// Scroll whole page up by n (default 1) lines. New lines are added at the bottom.\n\t\tm_Owner->ApplyDisplayParm();\n\t\tm_Table->Scroll((Code.ArgC > 0 && Code.ArgV[0] > 0) ? -Code.ArgV[0] : -1);\n\t\tbreak;\n\n\tcase L'T':\n\t\t// Scroll whole page down by n (default 1) lines. New lines are added at the top.\n\t\tm_Owner->ApplyDisplayParm();\n\t\tm_Table->Scroll((Code.ArgC > 0 && Code.ArgV[0] > 0) ? Code.ArgV[0] : 1);\n\t\tbreak;\n\n\tcase L'h':\n\tcase L'l':\n\t\t// Set/ReSet Mode\n\t\tif (Code.ArgC > 0)\n\t\t{\n\t\t\t//ESC [ 3 h\n\t\t\t//       DECCRM (default off): Display control chars.\n\n\t\t\t//ESC [ 4 h\n\t\t\t//       DECIM (default off): Set insert mode.\n\n\t\t\t//ESC [ 20 h\n\t\t\t//       LF/NL (default off): Automatically follow echo of LF, VT or FF with CR.\n\n\t\t\t//ESC [ ? 1 h\n\t\t\t//\t  DECCKM (default off): When set, the cursor keys send an ESC O prefix,\n\t\t\t//\t  rather than ESC [.\n\n\t\t\t//ESC [ ? 3 h\n\t\t\t//\t  DECCOLM (default off = 80 columns): 80/132 col mode switch.  The driver\n\t\t\t//\t  sources note that this alone does not suffice; some user-mode utility\n\t\t\t//\t  such as resizecons(8) has to change the hardware registers on the\n\t\t\t//\t  console video card.\n\n\t\t\t//ESC [ ? 5 h\n\t\t\t//\t  DECSCNM (default off): Set reverse-video mode.\n\n\t\t\t//ESC [ ? 6 h\n\t\t\t//\t  DECOM (default off): When set, cursor addressing is relative to the\n\t\t\t//\t  upper left corner of the scrolling region.\n\n\n\t\t\t//ESC [ ? 8 h\n\t\t\t//\t  DECARM (default on): Set keyboard autorepeat on.\n\n\t\t\t//ESC [ ? 9 h\n\t\t\t//\t  X10 Mouse Reporting (default off): Set reporting mode to 1 (or reset to\n\t\t\t//\t  0) -- see below.\n\n\t\t\t//ESC [ ? 1000 h\n\t\t\t//\t  X11 Mouse Reporting (default off): Set reporting mode to 2 (or reset to\n\t\t\t//\t  0) -- see below.\n\n\t\t\t//ESC [ ? 7711 h\n\t\t\t//    mimic mintty code, same as \"ESC ] 9 ; 12 ST\"\n\n\t\t\tswitch (Code.ArgV[0])\n\t\t\t{\n\t\t\tcase 1:\n\t\t\t\tif ((Code.PvtLen == 1) && (Code.Pvt[0] == L'?'))\n\t\t\t\t{\n\t\t\t\t\tm_Owner->gDisplayCursor.CursorKeysApp = (Code.Action == L'h');\n\n\t\t\t\t\t#if 0\n\t\t\t\t\tif (gbIsVimProcess)\n\t\t\t\t\t{\n\t\t\t\t\t\tTODO(\"Need to find proper way for activation alternative buffer from ViM?\");\n\t\t\t\t\t\tif (Code.Action == L'h')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tStartVimTerm(false);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tStopVimTerm();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t#endif\n\n\t\t\t\t\tm_Owner->ChangeTermMode(tmc_AppCursorKeys, (Code.Action == L'h'));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart, Code.nTotalLen);\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tm_Owner->gDisplayOpt.ShowRawAnsi = (Code.Action == L'h');\n\t\t\t\tbreak;\n\t\t\tcase 7:\n\t\t\t\t//ESC [ ? 7 h\n\t\t\t\t//\t  DECAWM (default off): Set autowrap on.  In this mode, a graphic\n\t\t\t\t//\t  character emitted after column 80 (or column 132 of DECCOLM is on)\n\t\t\t\t//\t  forces a wrap to the beginning of the following line first.\n\t\t\t\t//ESC [ = 7 h\n\t\t\t\t//    Enables line wrapping\n\t\t\t\t//ESC [ 7 ; _col_ h\n\t\t\t\t//    Our extension. _col_ - wrap at column (1-based), default = 80\n\t\t\t\tif ((m_Owner->gDisplayOpt.WrapWasSet = (Code.Action == L'h')))\n\t\t\t\t{\n\t\t\t\t\tm_Owner->gDisplayOpt.WrapAt = ((Code.ArgC > 1) && (Code.ArgV[1] > 0)) ? Code.ArgV[1] : 80;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 20:\n\t\t\t\tif (Code.PvtLen == 0)\n\t\t\t\t{\n\t\t\t\t\tm_Owner->gDisplayOpt.AutoLfNl = (Code.Action == L'h');\n\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, SrvAnsi::de_Ignored);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart, Code.nTotalLen);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t//ESC [ ? 12 h\n\t\t\t//\t  Start Blinking Cursor (att610)\n\t\t\tcase 12:\n\t\t\t//ESC [ ? 25 h\n\t\t\t//\t  DECTECM (default on): Make cursor visible.\n\t\t\tcase 25:\n\t\t\t\tif ((Code.PvtLen == 1) && (Code.Pvt[0] == L'?'))\n\t\t\t\t{\n\t\t\t\t\tbool unknown = false;\n\t\t\t\t\tfor (int i = 0; i < Code.ArgC; ++i)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (Code.ArgV[i] == 25)\n\t\t\t\t\t\t\tm_Owner->SetCursorVisibility((Code.Action == L'h'));\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tunknown = true;\n\t\t\t\t\t}\n\t\t\t\t\tif (unknown)\n\t\t\t\t\t{\n\t\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, SrvAnsi::de_Ignored);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart, Code.nTotalLen);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tif (Code.PvtLen == 0)\n\t\t\t\t{\n\t\t\t\t\t/* h=Insert Mode (IRM), l=Replace Mode (IRM) */\n\t\t\t\t\t// Nano posts the `ESC [ 4 l` on start, but do not post `ESC [ 4 h` on exit, that is strange...\n\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, SrvAnsi::de_Ignored); // ignored for now\n\t\t\t\t}\n\t\t\t\telse if ((Code.PvtLen == 1) && (Code.Pvt[0] == L'?'))\n\t\t\t\t{\n\t\t\t\t\t/* h=Smooth (slow) scroll, l=Jump (fast) scroll */\n\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, SrvAnsi::de_Ignored); // ignored for now\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart, Code.nTotalLen);\n\t\t\t\tbreak;\n\t\t\tcase 9:    /* X10_MOUSE */\n\t\t\tcase 1000: /* VT200_MOUSE */\n\t\t\tcase 1002: /* BTN_EVENT_MOUSE */\n\t\t\tcase 1003: /* ANY_EVENT_MOUSE */\n\t\t\tcase 1004: /* FOCUS_EVENT_MOUSE */\n\t\t\tcase 1005: /* Xterm's UTF8 encoding for mouse positions */\n\t\t\tcase 1006: /* Xterm's CSI-style mouse encoding */\n\t\t\tcase 1015: /* Urxvt's CSI-style mouse encoding */\n\t\t\t\tif ((Code.PvtLen == 1) && (Code.Pvt[0] == L'?'))\n\t\t\t\t{\n\t\t\t\t\tstatic DWORD LastMode = 0;\n\t\t\t\t\tTermMouseMode ModeMask = (Code.ArgV[0] == 9) ? tmm_X10\n\t\t\t\t\t\t: (Code.ArgV[0] == 1000) ? tmm_VT200\n\t\t\t\t\t\t: (Code.ArgV[0] == 1002) ? tmm_BTN\n\t\t\t\t\t\t: (Code.ArgV[0] == 1003) ? tmm_ANY\n\t\t\t\t\t\t: (Code.ArgV[0] == 1004) ? tmm_FOCUS\n\t\t\t\t\t\t: (Code.ArgV[0] == 1005) ? tmm_UTF8\n\t\t\t\t\t\t: (Code.ArgV[0] == 1006) ? tmm_XTERM\n\t\t\t\t\t\t: (Code.ArgV[0] == 1015) ? tmm_URXVT\n\t\t\t\t\t\t: tmm_None;\n\t\t\t\t\tDWORD Mode = (Code.Action == L'h')\n\t\t\t\t\t\t? (LastMode | ModeMask)\n\t\t\t\t\t\t: (LastMode & ~ModeMask);\n\t\t\t\t\tLastMode = Mode;\n\t\t\t\t\tm_Owner->ChangeTermMode(tmc_MouseMode, Mode);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart, Code.nTotalLen);\n\t\t\t\tbreak;\n\t\t\tcase 7786: /* 'V': Mousewheel reporting */\n\t\t\tcase 7787: /* 'W': Application mousewheel mode */\n\t\t\t\tif ((Code.PvtLen == 1) && (Code.Pvt[0] == L'?'))\n\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, SrvAnsi::de_Ignored); // ignored for now\n\t\t\t\telse\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart, Code.nTotalLen);\n\t\t\t\tbreak;\n\t\t\tcase 1034:\n\t\t\t\t// Interpret \"meta\" key, sets eighth bit. (enables/disables the eightBitInput resource).\n\t\t\t\tif ((Code.PvtLen == 1) && (Code.Pvt[0] == L'?'))\n\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, SrvAnsi::de_Ignored);\n\t\t\t\telse\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart, Code.nTotalLen);\n\t\t\t\tbreak;\n\t\t\tcase 47:   /* alternate screen */\n\t\t\tcase 1047: /* alternate screen */\n\t\t\tcase 1049: /* cursor & alternate screen */\n\t\t\t\t// xmux/screen: Alternate screen\n\t\t\t\tif ((Code.PvtLen == 1) && (Code.Pvt[0] == L'?'))\n\t\t\t\t{\n\t\t\t\t\tm_Owner->ApplyDisplayParm();\n\n\t\t\t\t\t// \\e[?1049h: save cursor pos\n\t\t\t\t\tif ((Code.ArgV[0] == 1049) && (Code.Action == L'h'))\n\t\t\t\t\t\tXTermSaveRestoreCursor(true);\n\t\t\t\t\t// h: switch to alternative buffer without backscroll\n\t\t\t\t\t// l: restore saved scrollback buffer\n\t\t\t\t\tXTermAltBuffer((Code.Action == L'h'));\n\t\t\t\t\t// \\e[?1049l - restore cursor pos\n\t\t\t\t\tif ((Code.ArgV[0] == 1049) && (Code.Action == L'l'))\n\t\t\t\t\t\tXTermSaveRestoreCursor(false);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart, Code.nTotalLen);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 1048: /* save/restore cursor */\n\t\t\t\tif ((Code.PvtLen == 1) && (Code.Pvt[0] == L'?'))\n\t\t\t\t\tXTermSaveRestoreCursor((Code.Action == L'h'));\n\t\t\t\telse\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart, Code.nTotalLen);\n\t\t\t\tbreak;\n\t\t\tcase 2004: /* bracketed paste */\n\t\t\t\t/* All \"pasted\" text will be wrapped in `\\e[200~ ... \\e[201~` */\n\t\t\t\tif ((Code.PvtLen == 1) && (Code.Pvt[0] == L'?'))\n\t\t\t\t\tm_Owner->ChangeTermMode(tmc_BracketedPaste, (Code.Action == L'h'));\n\t\t\t\telse\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart, Code.nTotalLen);\n\t\t\t\tbreak;\n\t\t\tcase 7711:\n\t\t\t\tif ((Code.Action == L'h') && (Code.PvtLen == 1) && (Code.Pvt[0] == L'?'))\n\t\t\t\t{\n\t\t\t\t\t//ESC [ ? 7711 h\n\t\t\t\t\t//    mimic mintty code, same as \"ESC ] 9 ; 12 ST\"\n\t\t\t\t\tm_Table->PromptPosStore();\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart, Code.nTotalLen);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t\t}\n\n\t\t\t//switch (Code.ArgV[0])\n\t\t\t//{\n\t\t\t//case 0: case 1:\n\t\t\t//\t// 40x25\n\t\t\t//\tif ((m_Owner->gDisplayOpt.WrapWasSet = (Code.Action == L'h')))\n\t\t\t//\t{\n\t\t\t//\t\tm_Owner->gDisplayOpt.WrapAt = 40;\n\t\t\t//\t}\n\t\t\t//\tbreak;\n\t\t\t//case 2: case 3:\n\t\t\t//\t// 80x25\n\t\t\t//\tif ((m_Owner->gDisplayOpt.WrapWasSet = (Code.Action == L'h')))\n\t\t\t//\t{\n\t\t\t//\t\tm_Owner->gDisplayOpt.WrapAt = 80;\n\t\t\t//\t}\n\t\t\t//\tbreak;\n\t\t\t//case 7:\n\t\t\t//\t{\n\t\t\t//\t\tDWORD Mode = 0;\n\t\t\t//\t\tGetConsoleMode(&Mode);\n\t\t\t//\t\tif (Code.Action == L'h')\n\t\t\t//\t\t\tMode |= ENABLE_WRAP_AT_EOL_OUTPUT;\n\t\t\t//\t\telse\n\t\t\t//\t\t\tMode &= ~ENABLE_WRAP_AT_EOL_OUTPUT;\n\t\t\t//\t\tSetConsoleMode(Mode);\n\t\t\t//\t} // enable/disable line wrapping\n\t\t\t//\tbreak;\n\t\t\t//}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t}\n\t\tbreak; // case L'h': case L'l':\n\n\tcase L'n':\n\t\tif (Code.ArgC > 0)\n\t\t{\n\t\t\tswitch (*Code.ArgV)\n\t\t\t{\n\t\t\tcase 5:\n\t\t\t\t//ESC [ 5 n\n\t\t\t\t//      Device status report (DSR): Answer is ESC [ 0 n (Terminal OK).\n\t\t\t\t//\n\t\t\t\tReportString(L\"\\x1B[0n\");\n\t\t\t\tbreak;\n\t\t\tcase 6:\n\t\t\t\t//ESC [ 6 n\n\t\t\t\t//      Cursor position report (CPR): Answer is ESC [ y ; x R, where x,y is the\n\t\t\t\t//      cursor location.\n\t\t\t\tReportCursorPosition();\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t}\n\t\tbreak;\n\n\tcase L'm':\n\t\tif (Code.PvtLen > 0)\n\t\t{\n\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, SrvAnsi::de_Ignored);\n\t\t}\n\t\t// Set display mode (colors, fonts, etc.)\n\t\telse if (!Code.ArgC)\n\t\t{\n\t\t\tm_Owner->ReSetDisplayParm(TRUE, FALSE);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor (int i = 0; i < Code.ArgC; i++)\n\t\t\t{\n\t\t\t\tswitch (Code.ArgV[i])\n\t\t\t\t{\n\t\t\t\tcase 0:\n\t\t\t\t\tm_Owner->ReSetDisplayParm(TRUE, FALSE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\t// Bold\n\t\t\t\t\tm_Owner->gDisplayParm.setBrightOrBold(TRUE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\t// Faint, decreased intensity (ISO 6429)\n\t\t\t\tcase 22:\n\t\t\t\t\t// Normal (neither bold nor faint).\n\t\t\t\t\tm_Owner->gDisplayParm.setBrightOrBold(FALSE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3:\n\t\t\t\t\t// Italic\n\t\t\t\t\tm_Owner->gDisplayParm.setItalic(TRUE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 23:\n\t\t\t\t\t// Not italic\n\t\t\t\t\tm_Owner->gDisplayParm.setItalic(FALSE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 5: // #TODO ANSI Slow Blink (less than 150 per minute)\n\t\t\t\tcase 6: // #TODO ANSI Rapid Blink (150+ per minute)\n\t\t\t\tcase 25: // #TODO ANSI Blink Off\n\t\t\t\t\tDumpKnownEscape(Code.pszEscStart,Code.nTotalLen,SrvAnsi::de_Ignored);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 4: // Underlined\n\t\t\t\t\tm_Owner->gDisplayParm.setUnderline(TRUE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 24:\n\t\t\t\t\t// Not underlined\n\t\t\t\t\tm_Owner->gDisplayParm.setUnderline(FALSE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 7:\n\t\t\t\t\t// Reverse video\n\t\t\t\t\tm_Owner->gDisplayParm.setInverse(TRUE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 27:\n\t\t\t\t\t// Positive (not inverse)\n\t\t\t\t\tm_Owner->gDisplayParm.setInverse(FALSE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 30: case 31: case 32: case 33: case 34: case 35: case 36: case 37:\n\t\t\t\t\tm_Owner->gDisplayParm.setTextColor(Code.ArgV[i] - 30);\n\t\t\t\t\tm_Owner->gDisplayParm.setBrightFore(FALSE);\n\t\t\t\t\tm_Owner->gDisplayParm.setText256(SrvAnsi::clr4b);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 38:\n\t\t\t\t\t// xterm-256 colors\n\t\t\t\t\t// ESC [ 38 ; 5 ; I m -- set foreground to I (0..255) color from xterm palette\n\t\t\t\t\tif (((i+2) < Code.ArgC) && (Code.ArgV[i+1] == 5))\n\t\t\t\t\t{\n\t\t\t\t\t\tm_Owner->gDisplayParm.setTextColor(Code.ArgV[i+2] & 0xFF);\n\t\t\t\t\t\tm_Owner->gDisplayParm.setText256(SrvAnsi::clr8b);\n\t\t\t\t\t\ti += 2;\n\t\t\t\t\t}\n\t\t\t\t\t// xterm-256 colors\n\t\t\t\t\t// ESC [ 38 ; 2 ; R ; G ; B m -- set foreground to RGB(R,G,B) 24-bit color\n\t\t\t\t\telse if (((i+4) < Code.ArgC) && (Code.ArgV[i+1] == 2))\n\t\t\t\t\t{\n\t\t\t\t\t\tm_Owner->gDisplayParm.setTextColor(RGB((Code.ArgV[i+2] & 0xFF),(Code.ArgV[i+3] & 0xFF),(Code.ArgV[i+4] & 0xFF)));\n\t\t\t\t\t\tm_Owner->gDisplayParm.setText256(SrvAnsi::clr24b);\n\t\t\t\t\t\ti += 4;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 39:\n\t\t\t\t\t// Reset\n\t\t\t\t\tm_Owner->gDisplayParm.setTextColor(CONFORECOLOR(SrvAnsi::GetDefaultAnsiAttr()));\n\t\t\t\t\tm_Owner->gDisplayParm.setBrightFore(FALSE);\n\t\t\t\t\tm_Owner->gDisplayParm.setText256(SrvAnsi::clr4b);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 40: case 41: case 42: case 43: case 44: case 45: case 46: case 47:\n\t\t\t\t\tm_Owner->gDisplayParm.setBackColor(Code.ArgV[i] - 40);\n\t\t\t\t\tm_Owner->gDisplayParm.setBrightBack(FALSE);\n\t\t\t\t\tm_Owner->gDisplayParm.setBack256(SrvAnsi::clr4b);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 48:\n\t\t\t\t\t// xterm-256 colors\n\t\t\t\t\t// ESC [ 48 ; 5 ; I m -- set background to I (0..255) color from xterm palette\n\t\t\t\t\tif (((i+2) < Code.ArgC) && (Code.ArgV[i+1] == 5))\n\t\t\t\t\t{\n\t\t\t\t\t\tm_Owner->gDisplayParm.setBackColor(Code.ArgV[i+2] & 0xFF);\n\t\t\t\t\t\tm_Owner->gDisplayParm.setBack256(SrvAnsi::clr8b);\n\t\t\t\t\t\ti += 2;\n\t\t\t\t\t}\n\t\t\t\t\t// xterm-256 colors\n\t\t\t\t\t// ESC [ 48 ; 2 ; R ; G ; B m -- set background to RGB(R,G,B) 24-bit color\n\t\t\t\t\telse if (((i+4) < Code.ArgC) && (Code.ArgV[i+1] == 2))\n\t\t\t\t\t{\n\t\t\t\t\t\tm_Owner->gDisplayParm.setBackColor(RGB((Code.ArgV[i+2] & 0xFF),(Code.ArgV[i+3] & 0xFF),(Code.ArgV[i+4] & 0xFF)));\n\t\t\t\t\t\tm_Owner->gDisplayParm.setBack256(SrvAnsi::clr24b);\n\t\t\t\t\t\ti += 4;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 49:\n\t\t\t\t\t// Reset\n\t\t\t\t\tm_Owner->gDisplayParm.setBackColor(CONBACKCOLOR(SrvAnsi::GetDefaultAnsiAttr()));\n\t\t\t\t\tm_Owner->gDisplayParm.setBrightBack(FALSE);\n\t\t\t\t\tm_Owner->gDisplayParm.setBack256(SrvAnsi::clr4b);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 90: case 91: case 92: case 93: case 94: case 95: case 96: case 97:\n\t\t\t\t\tm_Owner->gDisplayParm.setTextColor((Code.ArgV[i] - 90) | 0x8);\n\t\t\t\t\tm_Owner->gDisplayParm.setText256(SrvAnsi::clr4b);\n\t\t\t\t\tm_Owner->gDisplayParm.setBrightFore(TRUE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 100: case 101: case 102: case 103: case 104: case 105: case 106: case 107:\n\t\t\t\t\tm_Owner->gDisplayParm.setBackColor((Code.ArgV[i] - 100) | 0x8);\n\t\t\t\t\tm_Owner->gDisplayParm.setBack256(SrvAnsi::clr4b);\n\t\t\t\t\tm_Owner->gDisplayParm.setBrightBack(TRUE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 10:\n\t\t\t\t\t// Something strange and unknown... (received from ssh)\n\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, SrvAnsi::de_Ignored);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 312:\n\t\t\t\tcase 315:\n\t\t\t\tcase 414:\n\t\t\t\tcase 3130:\n\t\t\t\t\t// Something strange and unknown... (received from vim on WSL)\n\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, SrvAnsi::de_Ignored);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak; // \"[...m\"\n\n\tcase L'p':\n\t\tif (Code.ArgC == 0 && Code.PvtLen == 1 && Code.Pvt[0] == L'!')\n\t\t{\n\t\t\tFullReset();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t}\n\t\tbreak; // \"[!p\"\n\n\tcase L'q':\n\t\tif ((Code.PvtLen == 1) && (Code.Pvt[0] == L' '))\n\t\t{\n\t\t\t/*\n\t\t\tCSI Ps SP q\n\t\t\t\tSet cursor style (DECSCUSR, VT520).\n\t\t\t\t\tPs = 0  -> ConEmu's default.\n\t\t\t\t\tPs = 1  -> blinking block.\n\t\t\t\t\tPs = 2  -> steady block.\n\t\t\t\t\tPs = 3  -> blinking underline.\n\t\t\t\t\tPs = 4  -> steady underline.\n\t\t\t\t\tPs = 5  -> blinking bar (xterm).\n\t\t\t\t\tPs = 6  -> steady bar (xterm).\n\t\t\t*/\n\t\t\tunsigned nStyle = ((Code.ArgC == 0) || (Code.ArgV[0] < 0) || (Code.ArgV[0] > 6))\n\t\t\t\t? 0 : Code.ArgV[0];\n\t\t\tm_Owner->SetCursorShape(nStyle);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t}\n\t\tbreak; // \"[...q\"\n\n\tcase L't':\n\t\tif (Code.ArgC > 0 && Code.ArgC <= 3)\n\t\t{\n\t\t\tfor (int i = 0; i < Code.ArgC; i++)\n\t\t\t{\n\t\t\t\tswitch (Code.ArgV[i])\n\t\t\t\t{\n\t\t\t\tcase 8:\n\t\t\t\t\t// `ESC [ 8 ; height ; width t` --> Resize the text area to [height;width] in characters.\n\t\t\t\t\t{\n\t\t\t\t\t\tint height = -1, width = -1;\n\t\t\t\t\t\tif (i < Code.ArgC)\n\t\t\t\t\t\t\theight = Code.ArgV[++i];\n\t\t\t\t\t\tif (i < Code.ArgC)\n\t\t\t\t\t\t\twidth = Code.ArgV[++i];\n\t\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, SrvAnsi::de_Ignored);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 14:\n\t\t\t\t\t// `ESC [ 1 4 t` --> Reports terminal window size in pixels as `CSI 4 ; height ; width t`.\n\t\t\t\t\tReportTerminalPixelSize();\n\t\t\t\t\tbreak;\n\t\t\t\tcase 18:\n\t\t\t\tcase 19:\n\t\t\t\t\t// `ESC [ 1 8 t` --> Report the size of the text area in characters as `CSI 8 ; height ; width t`\n\t\t\t\t\t// `ESC [ 1 9 t` --> Report the size of the screen in characters as `CSI 9 ; height ; width t`\n\t\t\t\t\tReportTerminalCharSize(Code.ArgV[i]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 21:\n\t\t\t\t\t// `ESC [ 2 1 t` --> Report terminal window title as `OSC l title ST`\n\t\t\t\t\tReportConsoleTitle();\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tTODO(\"ANSI: xterm window manipulation\");\n\t\t\t\t\t//Window manipulation (from dtterm, as well as extensions). These controls may be disabled using the allowWindowOps resource. Valid values for the first (and any additional parameters) are:\n\t\t\t\t\t// 1 --> De-iconify window.\n\t\t\t\t\t// 2 --> Iconify window.\n\t\t\t\t\t// 3 ; x ; y --> Move window to [x, y].\n\t\t\t\t\t// 4 ; height ; width --> Resize the xterm window to height and width in pixels.\n\t\t\t\t\t// 5 --> Raise the xterm window to the front of the stacking order.\n\t\t\t\t\t// 6 --> Lower the xterm window to the bottom of the stacking order.\n\t\t\t\t\t// 7 --> Refresh the xterm window.\n\t\t\t\t\t// 8 ; height ; width --> Resize the text area to [height;width] in characters.\n\t\t\t\t\t// 9 ; 0 --> Restore maximized window.\n\t\t\t\t\t// 9 ; 1 --> Maximize window (i.e., resize to screen size).\n\t\t\t\t\t// 1 1 --> Report xterm window state. If the xterm window is open (non-iconified), it returns CSI 1 t . If the xterm window is iconified, it returns CSI 2 t .\n\t\t\t\t\t// 1 3 --> Report xterm window position as CSI 3 ; x; y t\n\t\t\t\t\t// 1 4 --> Report xterm window in pixels as CSI 4 ; height ; width t\n\t\t\t\t\t// 2 0 --> Report xterm window\ufffds icon label as OSC L label ST\n\t\t\t\t\t// >= 2 4 --> Resize to P s lines (DECSLPP)\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t}\n\t\tbreak;\n\n\tcase L'c':\n\t\t// echo -e \"\\e[>c\"\n\t\tif ((Code.PvtLen == 1) && (Code.Pvt[0] == L'>')\n\t\t\t&& ((Code.ArgC < 1) || (Code.ArgV[0] == 0)))\n\t\t{\n\t\t\t// P s = 0 or omitted -> request the terminal's identification code.\n\t\t\twchar_t szVerInfo[64];\n\t\t\t// this will be \"ESC > 67 ; build ; 0 c\"\n\t\t\t// 67 is ASCII code of 'C' (ConEmu, yeah)\n\t\t\t// Other terminals report examples: MinTTY -> 77, rxvt -> 82, screen -> 83\n\t\t\t// msprintf(szVerInfo, countof(szVerInfo), L\"\\x1B>%u;%u;0c\", (int)'C', MVV_1*10000+MVV_2*100+MVV_3);\n\t\t\t// Emulate xterm version 136?\n\t\t\twcscpy_c(szVerInfo, L\"\\x1B[>0;136;0c\");\n\t\t\tReportString(szVerInfo);\n\t\t}\n\t\t// echo -e \"\\e[c\"\n\t\telse if ((Code.ArgC < 1) || (Code.ArgV[0] == 0))\n\t\t{\n\t\t\t// Report \"VT100 with Advanced Video Option\"\n\t\t\tReportString(L\"\\x1B[?1;2c\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t}\n\t\tbreak;\n\n\tcase L'X':\n\t\t// CSI P s X:  Erase P s Character(s) (default = 1) (ECH)\n\t\t{\n\t\t\tm_Owner->ApplyDisplayParm();\n\t\t\tconst auto cur = m_Table->GetCursor();\n\t\t\tauto row = m_Table->CurrentRow();\n\t\t\tconst unsigned nCount = (Code.ArgC > 0) ? unsigned(Code.ArgV[0]) : 1;\n\t\t\tconst unsigned nMax = row->GetLength();\n\t\t\trow->Write(cur.x, m_Table->GetAttr(), L' ', std::min(nCount, (nMax > cur.x) ? (nMax - cur.x) : 0));\n\t\t} // case L'X':\n\t\tbreak;\n\n\tdefault:\n\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t} // switch (Code.Action)\n}\n\nvoid SrvAnsiImpl::WriteAnsiCode_OSC(AnsiEscCode& Code)\n{\n\tif (!Code.ArgSZ)\n\t{\n\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\treturn;\n\t}\n\n\t// Finalizing (ST) with \"\\x1B\\\\\" or \"\\x07\"\n\n\t// #condata ESC ] 10 ; txt ST       Set dynamic text color to txt.\n\t// #condata ESC ] 4 6 ; name ST     Change log file to name (normally disabled by a compile-time option)\n\t// #condata ESC ] 5 0 ; fn ST       Set font to fn.\n\n\tswitch (*Code.ArgSZ)\n\t{\n\tcase L'0':\n\tcase L'1':\n\tcase L'2':\n\t\t//ESC ] 0 ; txt ST        Set icon name and window title to txt.\n\t\t//ESC ] 1 ; txt ST        Set icon name to txt.\n\t\t//ESC ] 2 ; txt ST        Set window title to txt.\n\t\tif (Code.ArgSZ[1] == L';' && Code.ArgSZ[2])\n\t\t{\n\t\t\twchar_t* pszNewTitle = (wchar_t*)malloc(sizeof(wchar_t)*(Code.cchArgSZ));\n\t\t\tif (pszNewTitle)\n\t\t\t{\n\t\t\t\tEscCopyCtrlString(pszNewTitle, Code.ArgSZ+2, Code.cchArgSZ-2);\n\t\t\t\tSetConsoleTitle(*pszNewTitle ? pszNewTitle : m_Owner->gsInitConTitle);\n\t\t\t\tfree(pszNewTitle);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase L'4':\n\t\t// ESC ] 4 ; num; txt ST   Set ANSI color num to txt.\n\t\t// #condata the following is suggestion for exact palette colors\n\t\t// #condata but are using standard xterm palette or truecolor 24bit palette\n\t\t_ASSERTEX(Code.ArgSZ[1] == L';');\n\t\tbreak;\n\n\tcase L'9':\n\t\t// ConEmu specific\n\t\t// ESC ] 9 ; 1 ; ms ST           Sleep. ms - milliseconds\n\t\t// ESC ] 9 ; 2 ; \"txt\" ST        Show GUI MessageBox ( txt ) for dubug purposes\n\t\t// ESC ] 9 ; 3 ; \"txt\" ST        Set TAB text\n\t\t// ESC ] 9 ; 4 ; st ; pr ST      When _st_ is 0: remove progress. When _st_ is 1: set progress value to _pr_ (number, 0-100).\n\t\t//                               When _st_ is 2: set error state in progress on Windows 7 taskbar, _pr_ is optional.\n\t\t//                               When _st_ is 3: set indeterminate state. When _st_ is 4: set paused state, _pr_ is optional.\n\t\t// ESC ] 9 ; 5 ST                Wait for ENTER/SPACE/ESC. Set EnvVar \"ConEmuWaitKey\" to ENTER/SPACE/ESC on exit.\n\t\t// ESC ] 9 ; 6 ; \"txt\" ST        Execute GuiMacro. Set EnvVar \"ConEmuMacroResult\" on exit.\n\t\t// ESC ] 9 ; 7 ; \"cmd\" ST        Run some process with arguments\n\t\t// ESC ] 9 ; 8 ; \"env\" ST        Output value of environment variable\n\t\t// ESC ] 9 ; 9 ; \"cwd\" ST        Inform ConEmu about shell current working directory\n\t\t// ESC ] 9 ; 10 ; p ST           Request xterm keyboard emulation\n\t\t// ESC ] 9 ; 11; \"*txt*\" ST      Just a \u2018comment\u2019, skip it.\n\t\t// ESC ] 9 ; 12 ST               Let ConEmu treat current cursor position as prompt start. Useful with `PS1`.\n\t\tif (Code.ArgSZ[1] == L';')\n\t\t{\n\t\t\tif (Code.ArgSZ[2] == L'1')\n\t\t\t{\n\t\t\t\tif (Code.ArgSZ[3] == L';')\n\t\t\t\t{\n\t\t\t\t\t// ESC ] 9 ; 1 ; ms ST\n\t\t\t\t\tDoSleep(Code.ArgSZ+4);\n\t\t\t\t}\n\t\t\t\telse if (Code.ArgC >= 2 && Code.ArgV[1] == 10)\n\t\t\t\t{\n\t\t\t\t\t// ESC ] 9 ; 10 ST\n\t\t\t\t\t// ESC ] 9 ; 10 ; 1 ST\n\t\t\t\t\tif (!m_Owner->gbIsXTermOutput && (Code.ArgC == 2 || Code.ArgV[2] == 1))\n\t\t\t\t\t\tm_Owner->StartXTermMode(true);\n\t\t\t\t\t// ESC ] 9 ; 10 ; 0 ST\n\t\t\t\t\telse if (Code.ArgC >= 3 || Code.ArgV[2] == 0)\n\t\t\t\t\t\tm_Owner->StartXTermMode(false);\n\t\t\t\t\t// ESC ] 9 ; 10 ; 3 ST\n\t\t\t\t\telse if (Code.ArgC >= 3 || Code.ArgV[2] == 3)\n\t\t\t\t\t\tm_Owner->StartXTermOutput(true);\n\t\t\t\t\t// ESC ] 9 ; 10 ; 2 ST\n\t\t\t\t\telse if (Code.ArgC >= 3 || Code.ArgV[2] == 2)\n\t\t\t\t\t\tm_Owner->StartXTermOutput(false);\n\t\t\t\t}\n\t\t\t\telse if (Code.ArgSZ[3] == L'1' && Code.ArgSZ[4] == L';')\n\t\t\t\t{\n\t\t\t\t\t// ESC ] 9 ; 11; \"*txt*\" ST - Just a \u2018comment\u2019, skip it.\n\t\t\t\t\tDumpKnownEscape(Code.ArgSZ+5, lstrlen(Code.ArgSZ+5), SrvAnsi::de_Comment);\n\t\t\t\t}\n\t\t\t\telse if (Code.ArgSZ[3] == L'2')\n\t\t\t\t{\n\t\t\t\t\t// ESC ] 9 ; 12 ST\n\t\t\t\t\tm_Table->PromptPosStore();\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (Code.ArgSZ[2] == L'2' && Code.ArgSZ[3] == L';')\n\t\t\t{\n\t\t\t\tDoMessage(Code.ArgSZ+4, Code.cchArgSZ - 4);\n\t\t\t}\n\t\t\telse if (Code.ArgSZ[2] == L'3' && Code.ArgSZ[3] == L';')\n\t\t\t{\n\t\t\t\tCESERVER_REQ* pIn = ExecuteNewCmd(CECMD_SETTABTITLE, sizeof(CESERVER_REQ_HDR)+sizeof(wchar_t)*(Code.cchArgSZ));\n\t\t\t\tif (pIn)\n\t\t\t\t{\n\t\t\t\t\tEscCopyCtrlString((wchar_t*)pIn->wData, Code.ArgSZ+4, Code.cchArgSZ-4);\n\t\t\t\t\tCESERVER_REQ* pOut = ExecuteGuiCmd(gState.realConWnd_, pIn, gState.realConWnd_);\n\t\t\t\t\tExecuteFreeResult(pIn);\n\t\t\t\t\tExecuteFreeResult(pOut);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (Code.ArgSZ[2] == L'4')\n\t\t\t{\n\t\t\t\tAnsiProgressStatus st = AnsiProgressStatus::None;\n\t\t\t\tWORD pr = 0;\n\t\t\t\tconst wchar_t* pszName = nullptr;\n\t\t\t\tif (Code.ArgSZ[3] == L';')\n\t\t\t\t{\n\t\t\t\t\tswitch (Code.ArgSZ[4])\n\t\t\t\t\t{\n\t\t\t\t\tcase L'0':\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase L'1':\n\t\t\t\t\t\tst = AnsiProgressStatus::Running; break;\n\t\t\t\t\tcase L'2':\n\t\t\t\t\t\tst = AnsiProgressStatus::Error; break;\n\t\t\t\t\tcase L'3':\n\t\t\t\t\t\tst = AnsiProgressStatus::Indeterminate; break;\n\t\t\t\t\tcase L'4':\n\t\t\t\t\t\tst = AnsiProgressStatus::Paused; break;\n\t\t\t\t\tcase L'5': // reserved for future use\n\t\t\t\t\t\tst = AnsiProgressStatus::LongRunStart; break;\n\t\t\t\t\tcase L'6': // reserved for future use\n\t\t\t\t\t\tst = AnsiProgressStatus::LongRunStop; break;\n\t\t\t\t\t}\n\t\t\t\t\tif (st == AnsiProgressStatus::Running || st == AnsiProgressStatus::Error || st == AnsiProgressStatus::Paused)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (Code.ArgSZ[5] == L';')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tLPCWSTR pszValue = Code.ArgSZ + 6;\n\t\t\t\t\t\t\tpr = NextNumber(pszValue);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (st == AnsiProgressStatus::LongRunStart || st == AnsiProgressStatus::LongRunStop)\n\t\t\t\t\t{\n\t\t\t\t\t\tpszName = (Code.ArgSZ[5] == L';') ? (Code.ArgSZ + 6) : nullptr;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tDoSetProgress(st, pr, pszName);\n\t\t\t}\n\t\t\telse if (Code.ArgSZ[2] == L'5')\n\t\t\t{\n\t\t\t\t//int s = 0;\n\t\t\t\t//if (Code.ArgSZ[3] == L';')\n\t\t\t\t//\ts = NextNumber(Code.ArgSZ+4);\n\t\t\t\tbool bSucceeded = FALSE;\n\t\t\t\tDWORD nRead = 0;\n\t\t\t\tINPUT_RECORD r = {};\n\t\t\t\tHANDLE hIn = GetStdHandle(STD_INPUT_HANDLE);\n\t\t\t\t//DWORD nStartTick = GetTickCount();\n\t\t\t\twhile ((bSucceeded = ReadConsoleInput(hIn, &r, 1, &nRead)) && nRead)\n\t\t\t\t{\n\t\t\t\t\tif ((r.EventType == KEY_EVENT) && r.Event.KeyEvent.bKeyDown)\n\t\t\t\t\t{\n\t\t\t\t\t\tif ((r.Event.KeyEvent.wVirtualKeyCode == VK_RETURN)\n\t\t\t\t\t\t\t|| (r.Event.KeyEvent.wVirtualKeyCode == VK_SPACE)\n\t\t\t\t\t\t\t|| (r.Event.KeyEvent.wVirtualKeyCode == VK_ESCAPE))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (bSucceeded && ((r.Event.KeyEvent.wVirtualKeyCode == VK_RETURN)\n\t\t\t\t\t\t\t|| (r.Event.KeyEvent.wVirtualKeyCode == VK_SPACE)\n\t\t\t\t\t\t\t|| (r.Event.KeyEvent.wVirtualKeyCode == VK_ESCAPE)))\n\t\t\t\t{\n\t\t\t\t\tSetEnvironmentVariable(ENV_CONEMU_WAITKEY_W,\n\t\t\t\t\t\t(r.Event.KeyEvent.wVirtualKeyCode == VK_RETURN) ? L\"RETURN\" :\n\t\t\t\t\t\t(r.Event.KeyEvent.wVirtualKeyCode == VK_SPACE)  ? L\"SPACE\" :\n\t\t\t\t\t\t(r.Event.KeyEvent.wVirtualKeyCode == VK_ESCAPE) ? L\"ESC\" :\n\t\t\t\t\t\tL\"???\");\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSetEnvironmentVariable(ENV_CONEMU_WAITKEY_W, L\"\");\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (Code.ArgSZ[2] == L'6' && Code.ArgSZ[3] == L';')\n\t\t\t{\n\t\t\t\tDoGuiMacro(Code.ArgSZ+4, Code.cchArgSZ - 4);\n\t\t\t}\n\t\t\telse if (Code.ArgSZ[2] == L'7' && Code.ArgSZ[3] == L';')\n\t\t\t{\n\t\t\t\tDoProcess(Code.ArgSZ+4, Code.cchArgSZ - 4);\n\t\t\t}\n\t\t\telse if (Code.ArgSZ[2] == L'8' && Code.ArgSZ[3] == L';')\n\t\t\t{\n\t\t\t\tm_Owner->ApplyDisplayParm();\n\t\t\t\tDoPrintEnv(Code.ArgSZ+4, Code.cchArgSZ - 4);\n\t\t\t}\n\t\t\telse if (Code.ArgSZ[2] == L'9' && Code.ArgSZ[3] == L';')\n\t\t\t{\n\t\t\t\tDoSendCWD(Code.ArgSZ+4, Code.cchArgSZ - 4);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t}\n}\n\nvoid SrvAnsiImpl::WriteAnsiCode_VIM(AnsiEscCode& Code)\n{\n\t/*\n\tif (!m_Owner->gbIsXTermOutput && !gnWriteProcessed)\n\t{\n\t\tSrvAnsiImpl::StartXTermMode(true);\n\t}\n\t*/\n\n\tswitch (Code.Action)\n\t{\n\tcase L'm':\n\t\t// Set xterm display modes (colors, fonts, etc.)\n\t\tif (!Code.ArgC)\n\t\t{\n\t\t\t//m_Owner->ReSetDisplayParm(TRUE, FALSE);\n\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor (int i = 0; i < Code.ArgC; i++)\n\t\t\t{\n\t\t\t\tswitch (Code.ArgV[i])\n\t\t\t\t{\n\t\t\t\tcase 7:\n\t\t\t\t\tm_Owner->gDisplayParm.setBrightOrBold(FALSE);\n\t\t\t\t\tm_Owner->gDisplayParm.setItalic(FALSE);\n\t\t\t\t\tm_Owner->gDisplayParm.setUnderline(FALSE);\n\t\t\t\t\tm_Owner->gDisplayParm.setBrightFore(FALSE);\n\t\t\t\t\tm_Owner->gDisplayParm.setBrightBack(FALSE);\n\t\t\t\t\tm_Owner->gDisplayParm.setInverse(FALSE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 15:\n\t\t\t\t\tm_Owner->gDisplayParm.setBrightOrBold(TRUE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 112:\n\t\t\t\t\tm_Owner->gDisplayParm.setInverse(TRUE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 143:\n\t\t\t\t\t// What is this?\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak; // \"|...m\"\n\t}\n}\n\n// Values are 1-based\nvoid SrvAnsiImpl::SetScrollRegion(bool bRegion, int nStart, int nEnd)\n{\n\tif (bRegion)\n\t{\n\t\t// note: the '\\e[0;35r' shall be treated as '\\e[1;35r'\n\t\t_ASSERTE(nStart >= 0 && nEnd >= nStart);\n\t\tm_Table->SetScrollRegion(true, std::max(0, nStart - 1), std::max(0, nEnd - 1));\n\t}\n\telse\n\t{\n\t\tm_Table->SetScrollRegion(false);\n\t}\n}\n\nvoid SrvAnsiImpl::XTermSaveRestoreCursor(bool bSaveCursor)\n{\n\tif (bSaveCursor)\n\t{\n\t\tm_Owner->gDisplayCursor.bCursorPosStored = true;\n\t\tm_Owner->gDisplayCursor.StoredCursorPos = m_Table->GetCursor();\n\t}\n\telse\n\t{\n\t\t// Restore cursor position\n\t\tm_Table->SetCursor(m_Owner->gDisplayCursor.bCursorPosStored ? m_Owner->gDisplayCursor.StoredCursorPos : condata::Coord{});\n\t}\n}\n\n/// Change current buffer\n/// Alternative buffer in XTerm is used to \"fullscreen\"\n/// applications like Vim. There is no scrolling and this\n/// mode is used to save current backscroll contents and\n/// restore it when application exits\nvoid SrvAnsiImpl::XTermAltBuffer(bool bSetAltBuffer/*, condata::TablePtr& table*/)\n{\n\tif (bSetAltBuffer)\n\t{\n\t\t// Once!\n\t\tif (!m_Owner->m_UsePrimary)\n\t\t\treturn;\n\n\t\tconst auto attr = m_Table->GetAttr();\n\t\tm_Table = m_Owner->GetTable(SrvAnsi::GetTableEnum::alternative);\n\t\tm_Table->Reset(attr);\n\n\t\t// #condata Save gDisplayCursor.StoredCursorPos separately by primary/alternative\n\n\t}\n\telse\n\t{\n\t\tif (m_Owner->m_UsePrimary)\n\t\t\treturn;\n\n\t\tm_Table->Reset({});\n\n\t\tm_Table = m_Owner->GetTable(SrvAnsi::GetTableEnum::primary);\n\n\t\t// #condata Save gDisplayCursor.StoredCursorPos separately by primary/alternative\n\n\t}\n}\n\n", "\ufeff\n/*\nCopyright (c) 2012-present Maximus5\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions\nare met:\n1. Redistributions of source code must retain the above copyright\n   notice, this list of conditions and the following disclaimer.\n2. Redistributions in binary form must reproduce the above copyright\n   notice, this list of conditions and the following disclaimer in the\n   documentation and/or other materials provided with the distribution.\n3. The name of the authors may not be used to endorse or promote products\n   derived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE AUTHOR ''AS IS'' AND ANY EXPRESS OR\nIMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\nOF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\nIN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,\nINCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\nNOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\nTHIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n// #ANSI This file is expected to be moved almost completely to ConEmuCD\n\n#include \"../common/defines.h\"\n#include <winerror.h>\n#include <winnt.h>\n#include <tchar.h>\n#include <limits>\n#include <chrono>\n#include <tuple>\n#include <atomic>\n#include \"../common/Common.h\"\n#include \"../common/ConEmuCheck.h\"\n#include \"../common/ConsoleMixAttr.h\"\n#include \"../common/CmdLine.h\"\n#include \"../common/HandleKeeper.h\"\n#include \"../common/MConHandle.h\"\n#include \"../common/MRect.h\"\n#include \"../common/MSectionSimple.h\"\n#include \"../common/UnicodeChars.h\"\n#include \"../common/WConsole.h\"\n#include \"../common/WErrGuard.h\"\n#include \"../common/MAtomic.h\"\n\n#include \"Connector.h\"\n#include \"ExtConsole.h\"\n#include \"hlpConsole.h\"\n#include \"hlpProcess.h\"\n#include \"SetHook.h\"\n\n#include \"hkConsole.h\"\n#include \"hkStdIO.h\"\n#include \"hkWindow.h\"\n\n///* ***************** */\n#include \"Ansi.h\"\n\n#include \"../common/MHandle.h\"\nstatic DWORD gAnsiTlsIndex = 0;\n\n#include \"DllOptions.h\"\n#include \"../common/WObjects.h\"\n///* ***************** */\n\n#ifdef _DEBUG\n#define GH_1402\n#endif\n\n#undef isPressed\n#define isPressed(inp) ((GetKeyState(inp) & 0x8000) == 0x8000)\n\n#define ANSI_MAP_CHECK_TIMEOUT 1000 // 1sec\n\n#ifdef _DEBUG\n#define DebugString(x) OutputDebugString(x)\n#define DebugStringA(x) OutputDebugStringA(x)\n#define DBG_XTERM(x) //CEAnsi::DebugXtermOutput(x)\n#else\n#define DebugString(x) //OutputDebugString(x)\n#define DebugStringA(x) //OutputDebugStringA(x)\n#define DBG_XTERM(x) //CEAnsi::DebugXtermOutput(x)\n#endif\n\n/* ************ Globals ************ */\n// extern HMODULE ghOurModule; // \u0425\u044d\u043d\u0434\u043b \u043d\u0430\u0448\u0435\u0439 dll'\u043a\u0438 (\u0437\u0434\u0435\u0441\u044c \u0445\u0443\u043a\u0438 \u043d\u0435 \u0441\u0442\u0430\u0432\u044f\u0442\u0441\u044f)\n#include \"MainThread.h\"\n\n/* ************ Globals for SetHook ************ */\nextern HWND    ghConWnd;      // RealConsole  // NOLINT(readability-redundant-declaration)\nextern HWND    ghConEmuWnd;   // Root! ConEmu window  // NOLINT(readability-redundant-declaration)\n// ReSharper disable once CppInconsistentNaming\nextern HWND    ghConEmuWndDC; // ConEmu DC window  // NOLINT(readability-redundant-declaration)\n// ReSharper disable once CppInconsistentNaming\nextern DWORD   gnGuiPID;  // NOLINT(readability-redundant-declaration)\n// extern wchar_t gsInitConTitle[512];\n/* ************ Globals for SetHook ************ */\n\n/* ************ Globals for xTerm/ViM ************ */\nTODO(\"BufferWidth\")\ntypedef DWORD XTermAltBufferFlags;\nconst XTermAltBufferFlags\n\txtb_AltBuffer          = 0x0001,\n\txtb_StoredCursor       = 0x0002,\n\txtb_StoredScrollRegion = 0x0004,\n\txtb_None               = 0;\nstatic struct XTermAltBufferData\n{\n\tXTermAltBufferFlags Flags;\n\tint    BufferSize;\n\tCOORD  CursorPos;\n\tSHORT  ScrollStart, ScrollEnd;\n} gXTermAltBuffer = {};\n/* ************ Globals for xTerm/ViM ************ */\n\nBOOL WINAPI OnCreateProcessW(LPCWSTR lpApplicationName, LPWSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCWSTR lpCurrentDirectory, LPSTARTUPINFOW lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation);\n\n// These handles must be registered and released in OnCloseHandle.\nHANDLE CEAnsi::ghAnsiLogFile = nullptr;\nbool CEAnsi::gbAnsiLogCodes = false;\nLONG CEAnsi::gnEnterPressed = 0;\nbool CEAnsi::gbAnsiLogNewLine = false;\nbool CEAnsi::gbAnsiWasNewLine = false;\nMSectionSimple* CEAnsi::gcsAnsiLogFile = nullptr;\n\n// VIM, etc. Some programs waiting control keys as xterm sequences. Need to inform ConEmu GUI.\nbool CEAnsi::gbIsXTermOutput = false;\n// On Windows 10 we have ENABLE_VIRTUAL_TERMINAL_PROCESSING which implies XTerm mode\nDWORD CEAnsi::gPrevConOutMode = 0;\n// Let RefreshXTermModes() know what to restore\nCEAnsi::TermModeSet CEAnsi::gWasXTermModeSet[tmc_Last] = {};\n\nstatic MConHandle ghConOut(L\"CONOUT$\"), ghStdOut(L\"\"), ghStdErr(L\"\");  // NOLINT(clang-diagnostic-exit-time-destructors)\n\n/* ************ Export ANSI printings ************ */\nLONG gnWriteProcessed = 0;\nFARPROC CallWriteConsoleW = nullptr;\nBOOL WINAPI WriteProcessed3(LPCWSTR lpBuffer, DWORD nNumberOfCharsToWrite, LPDWORD lpNumberOfCharsWritten, HANDLE hConsoleOutput)\n{\n\tInterlockedIncrement(&gnWriteProcessed);\n\tDWORD nNumberOfCharsWritten = 0;\n\tif ((nNumberOfCharsToWrite == static_cast<DWORD>(-1)) && lpBuffer)\n\t{\n\t\tnNumberOfCharsToWrite = lstrlen(lpBuffer);\n\t}\n\tconst BOOL bRc = CEAnsi::OurWriteConsoleW(hConsoleOutput, lpBuffer, nNumberOfCharsToWrite, &nNumberOfCharsWritten, nullptr);\n\tif (lpNumberOfCharsWritten) *lpNumberOfCharsWritten = nNumberOfCharsWritten;\n\tInterlockedDecrement(&gnWriteProcessed);\n\treturn bRc;\n}\n\nHANDLE GetStreamHandle(WriteProcessedStream Stream)\n{\n\tHANDLE hConsoleOutput;\n\tswitch (Stream)  // NOLINT(clang-diagnostic-switch-enum)\n\t{\n\tcase wps_Output:\n\t\thConsoleOutput = GetStdHandle(STD_OUTPUT_HANDLE); break;\n\tcase wps_Error:\n\t\thConsoleOutput = GetStdHandle(STD_ERROR_HANDLE); break;\n\tdefault:\n\t\tSetLastError(ERROR_INVALID_PARAMETER);\n\t\treturn nullptr;\n\t}\n\treturn hConsoleOutput;\n}\nBOOL WINAPI WriteProcessed2(LPCWSTR lpBuffer, DWORD nNumberOfCharsToWrite, LPDWORD lpNumberOfCharsWritten, WriteProcessedStream Stream)\n{\n\t// ReSharper disable once CppLocalVariableMayBeConst\n\tHANDLE hConsoleOutput = GetStreamHandle(Stream);\n\tif (!hConsoleOutput || (hConsoleOutput == INVALID_HANDLE_VALUE))\n\t\treturn FALSE;\n\treturn WriteProcessed3(lpBuffer, nNumberOfCharsToWrite, lpNumberOfCharsWritten, hConsoleOutput);\n}\nBOOL WINAPI WriteProcessed(LPCWSTR lpBuffer, DWORD nNumberOfCharsToWrite, LPDWORD lpNumberOfCharsWritten)\n{\n\treturn WriteProcessed2(lpBuffer, nNumberOfCharsToWrite, lpNumberOfCharsWritten, wps_Output);\n}\nBOOL WINAPI WriteProcessedA(LPCSTR lpBuffer, DWORD nNumberOfCharsToWrite, LPDWORD lpNumberOfCharsWritten, WriteProcessedStream Stream)\n{\n\tBOOL lbRc = FALSE;\n\tCEAnsi* pObj = nullptr;\n\n\tORIGINAL_KRNL(WriteConsoleA);\n\n\tif ((nNumberOfCharsToWrite == static_cast<DWORD>(-1)) && lpBuffer)\n\t{\n\t\tnNumberOfCharsToWrite = lstrlenA(lpBuffer);\n\t}\n\n\t// Nothing to write? Or flush buffer?\n\tif (!lpBuffer || !nNumberOfCharsToWrite || Stream == wps_None)\n\t{\n\t\tif (lpNumberOfCharsWritten)\n\t\t\t*lpNumberOfCharsWritten = 0;\n\t\tlbRc = TRUE;\n\t\tgoto fin;\n\t}\n\n\tpObj = CEAnsi::Object();\n\n\tif (pObj)\n\t\tlbRc = pObj->OurWriteConsoleA(GetStreamHandle(Stream), lpBuffer, nNumberOfCharsToWrite, lpNumberOfCharsWritten);\n\telse\n\t\tlbRc = F(WriteConsoleA)(GetStreamHandle(Stream), lpBuffer, nNumberOfCharsToWrite, lpNumberOfCharsWritten, nullptr);\n\nfin:\n\treturn lbRc;\n}\n/* ************ Export ANSI printings ************ */\n\nvoid DebugStringUtf8(LPCWSTR asMessage)\n{\n\t#ifdef _DEBUG\n\tif (!asMessage || !*asMessage)\n\t\treturn;\n\t// Only ConEmuC debugger is able to show Utf-8 encoded debug strings\n\t// So, set bUseUtf8 to false if VS debugger is required\n\tstatic bool bUseUtf8 = false;\n\tif (!bUseUtf8)\n\t{\n\t\tDebugString(asMessage);\n\t\treturn;\n\t}\n\tconst int iLen = lstrlen(asMessage);\n\tchar szUtf8[200];\n\tCEStrA buffer;\n\tchar* pszUtf8 = ((iLen * 3 + 5) < static_cast<int>(countof(szUtf8))) ? szUtf8 : buffer.GetBuffer(iLen * 3 + 5);\n\tif (!pszUtf8)\n\t\treturn;\n\tpszUtf8[0] = '\\xEF'; pszUtf8[1] = '\\xBB'; pszUtf8[2] = '\\xBF';\n\tconst int iCvt = WideCharToMultiByte(CP_UTF8, 0, asMessage, iLen, pszUtf8+3, iLen*3+1, nullptr, nullptr);\n\tif (iCvt > 0)\n\t{\n\t\t_ASSERTE(iCvt < (iLen*3+2));\n\t\tpszUtf8[iCvt+3] = 0;\n\t\tDebugStringA(pszUtf8);\n\t}\n\t#endif\n}\n\nvoid CEAnsi::InitAnsiLog(LPCWSTR asFilePath, const bool LogAnsiCodes)\n{\n\tgbAnsiLogCodes = LogAnsiCodes;\n\n\t// Already initialized?\n\tif (ghAnsiLogFile)\n\t\treturn;\n\n\tScopedObject(CLastErrorGuard);\n\n\tgcsAnsiLogFile = new MSectionSimple(true);\n\t// ReSharper disable once CppLocalVariableMayBeConst\n\tHANDLE hLog = CreateFile(asFilePath, GENERIC_WRITE, FILE_SHARE_READ|FILE_SHARE_WRITE, nullptr, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, nullptr);\n\tif (hLog && (hLog != INVALID_HANDLE_VALUE))\n\t{\n\t\t// Succeeded\n\t\tghAnsiLogFile = hLog;\n\t}\n\telse\n\t{\n\t\tSafeDelete(gcsAnsiLogFile);\n\t}\n}\n\nvoid CEAnsi::DoneAnsiLog(bool bFinal)\n{\n\tif (!ghAnsiLogFile)\n\t\treturn;\n\n\tif (gbAnsiLogNewLine || (gnEnterPressed > 0))\n\t{\n\t\tCEAnsi::WriteAnsiLogUtf8(\"\\n\", 1);\n\t}\n\n\tif (!bFinal)\n\t{\n\t\tFlushFileBuffers(ghAnsiLogFile);\n\t}\n\telse\n\t{\n\t\t// ReSharper disable once CppLocalVariableMayBeConst\n\t\tHANDLE h = ghAnsiLogFile;\n\t\tghAnsiLogFile = nullptr;\n\t\tCloseHandle(h);\n\t\tSafeDelete(gcsAnsiLogFile);\n\t}\n}\n\nUINT CEAnsi::GetCodePage()\n{\n\tconst UINT cp = gCpConv.nDefaultCP ? gCpConv.nDefaultCP : GetConsoleOutputCP();\n\treturn cp;\n}\n\n// Intended to log some WinAPI functions\nvoid CEAnsi::WriteAnsiLogFormat(const char* format, ...)\n{\n\tif (!ghAnsiLogFile || !gbAnsiLogCodes || !format)\n\t\treturn;\n\tScopedObject(CLastErrorGuard);\n\n\tWriteAnsiLogTime();\n\n\tva_list argList;\n\tva_start(argList, format);\n\tchar func_buffer[200] = \"\";\n\tif (S_OK == StringCchVPrintfA(func_buffer, countof(func_buffer), format, argList))\n\t{\n\t\tstatic char s_ExeName[80] = \"\";\n\t\tif (!*s_ExeName)\n\t\t\tWideCharToMultiByte(CP_UTF8, 0, gsExeName, -1, s_ExeName, countof(s_ExeName)-1, nullptr, nullptr);\n\n\t\tchar log_string[300] = \"\";\n\t\tmsprintf(log_string, countof(log_string), \"\\x1B]9;11;\\\"%s: %s\\\"\\x7\", s_ExeName, func_buffer);\n\t\tWriteAnsiLogUtf8(log_string, static_cast<DWORD>(strlen(log_string)));\n\t}\n\tva_end(argList);\n}\n\nvoid CEAnsi::WriteAnsiLogTime()\n{\n\tif (!ghAnsiLogFile || !gbAnsiLogCodes)\n\t\treturn;\n\tstatic DWORD last_write_tick_ = 0;\n\n\tconst DWORD min_diff = 500;\n\tconst DWORD cur_tick = GetTickCount();\n\tconst DWORD cur_diff = cur_tick - last_write_tick_;\n\n\tif (!last_write_tick_ || (cur_diff >= min_diff))\n\t{\n\t\tlast_write_tick_ = cur_tick;\n\t\tSYSTEMTIME st = {};\n\t\tGetLocalTime(&st);\n\t\tchar time_str[40];\n\t\t// We should NOT use WriteAnsiLogFormat here!\n\t\tmsprintf(time_str, std::size(time_str), \"\\x1B]9;11;\\\"%02u:%02u:%02u.%03u\\\"\\x7\",\n\t\t\tst.wHour, st.wMinute, st.wSecond, st.wMilliseconds);\n\t\tWriteAnsiLogUtf8(time_str, static_cast<DWORD>(strlen(time_str)));\n\t}\n}\n\nBOOL CEAnsi::WriteAnsiLogUtf8(const char* lpBuffer, DWORD nChars)\n{\n\tif (!ghAnsiLogFile || !lpBuffer || !nChars)\n\t\treturn FALSE;\n\t// Handle multi-thread writers\n\t// But multi-process writers can't be handled correctly\n\tMSectionLockSimple lock; lock.Lock(gcsAnsiLogFile, 500);\n\tSetFilePointer(ghAnsiLogFile, 0, nullptr, FILE_END);\n\tORIGINAL_KRNL(WriteFile);\n\tDWORD nWritten = 0;\n\tconst BOOL bWrite = F(WriteFile)(ghAnsiLogFile, lpBuffer, nChars, &nWritten, nullptr);\n\tUNREFERENCED_PARAMETER(nWritten);\n\tgnEnterPressed = 0; gbAnsiLogNewLine = false;\n\tgbAnsiWasNewLine = (lpBuffer[nChars-1] == '\\n');\n\treturn bWrite;\n}\n\n// This may be called to log ReadConsoleA result\nvoid CEAnsi::WriteAnsiLogA(LPCSTR lpBuffer, DWORD nChars)\n{\n\tif (!ghAnsiLogFile || !lpBuffer || !nChars)\n\t\treturn;\n\n\tScopedObject(CLastErrorGuard);\n\n\tconst UINT cp = GetCodePage();\n\tif (cp == CP_UTF8)\n\t{\n\t\tbool writeLineFeed = false;\n\t\tif (gbAnsiLogNewLine)\n\t\t{\n\t\t\tif ((lpBuffer[0] == '\\n') || ((nChars > 1) && (lpBuffer[0] == '\\r') && (lpBuffer[1] == '\\n')))\n\t\t\t{\n\t\t\t\tgbAnsiLogNewLine = false;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\twriteLineFeed = true;\n\t\t\t}\n\t\t}\n\n\t\tWriteAnsiLogTime();\n\t\tif (writeLineFeed)\n\t\t\tWriteAnsiLogUtf8(\"\\n\", 1);\n\t\tWriteAnsiLogUtf8(lpBuffer, nChars);\n\t}\n\telse\n\t{\n\t\t// We don't check here for gbAnsiLogNewLine, because some codepages may even has different codes for CR+LF\n\t\twchar_t sBuf[80 * 3];\n\t\tCEStr buffer;\n\t\tconst int nNeed = MultiByteToWideChar(cp, 0, lpBuffer, nChars, nullptr, 0);\n\t\tif (nNeed < 1)\n\t\t\treturn;\n\t\twchar_t* pszBuf = (nNeed <= static_cast<int>(countof(sBuf))) ? sBuf : buffer.GetBuffer(nNeed);\n\t\tif (!pszBuf)\n\t\t\treturn;\n\t\tconst int nLen = MultiByteToWideChar(cp, 0, lpBuffer, nChars, pszBuf, nNeed);\n\t\t// Must be OK, but check it\n\t\tif (nLen > 0 && nLen <= nNeed)\n\t\t{\n\t\t\tWriteAnsiLogW(pszBuf, nLen);\n\t\t}\n\t}\n}\n\nvoid CEAnsi::WriteAnsiLogW(LPCWSTR lpBuffer, DWORD nChars)\n{\n\tif (!ghAnsiLogFile || !lpBuffer || !nChars)\n\t\treturn;\n\n\tScopedObject(CLastErrorGuard);\n\n\tWriteAnsiLogTime();\n\n\t// Cygwin (in RealConsole mode, not connector) don't write CR+LF to screen,\n\t// it uses SetConsoleCursorPosition instead after receiving '\\n' from readline\n\tint iEnterShift = 0;\n\tif (gbAnsiLogNewLine)\n\t{\n\t\tif ((lpBuffer[0] == '\\n') || ((nChars > 1) && (lpBuffer[0] == '\\r') && (lpBuffer[1] == '\\n')))\n\t\t\tgbAnsiLogNewLine = false;\n\t\telse\n\t\t\tiEnterShift = 1;\n\t}\n\n\tchar sBuf[80 * 3]; // Will be enough for most cases\n\tCEStrA buffer;\n\tBOOL bWrite = FALSE;\n\tconst int nNeed = WideCharToMultiByte(CP_UTF8, 0, lpBuffer, nChars, nullptr, 0, nullptr, nullptr);\n\tif (nNeed < 1)\n\t\treturn;\n\tchar* pszBuf = ((nNeed + iEnterShift + 1) <= static_cast<int>(countof(sBuf))) ? sBuf : buffer.GetBuffer(nNeed + iEnterShift + 1);\n\tif (!pszBuf)\n\t\treturn;\n\tif (iEnterShift)\n\t\tpszBuf[0] = '\\n';\n\tconst int nLen = WideCharToMultiByte(CP_UTF8, 0, lpBuffer, nChars, pszBuf+iEnterShift, nNeed, nullptr, nullptr);\n\t// Must be OK, but check it\n\tif (nLen > 0 && nLen <= nNeed)\n\t{\n\t\tpszBuf[iEnterShift+nNeed] = 0;\n\t\tbWrite = WriteAnsiLogUtf8(pszBuf, nLen+iEnterShift);\n\t}\n\tstd::ignore = bWrite;\n}\n\nvoid CEAnsi::WriteAnsiLogFarPrompt()\n{\n\t_ASSERTE(ghAnsiLogFile!=nullptr && \"Caller must check this\");\n\t// ReSharper disable once CppLocalVariableMayBeConst\n\tHANDLE hCon = GetStdHandle(STD_OUTPUT_HANDLE);\n\tCONSOLE_SCREEN_BUFFER_INFO csbi = {};\n\tif (!GetConsoleScreenBufferInfo(hCon, &csbi))\n\t\treturn;\n\tCEStr buffer;\n\tDWORD nChars = csbi.dwSize.X;\n\tif (!buffer.GetBuffer(csbi.dwSize.X + 2))\n\t\treturn;\n\t// We expect Far has already put \"black user screen\" and do CR/LF\n\t// if Far's keybar is hidden, we are on (csbi.dwSize.Y-1), otherwise - (csbi.dwSize.Y-2)\n\t_ASSERTE(csbi.dwCursorPosition.Y >= (csbi.dwSize.Y-2) && csbi.dwCursorPosition.Y <= (csbi.dwSize.Y-1));\n\tconst COORD crFrom = {0, static_cast<SHORT>(csbi.dwCursorPosition.Y - 1)};\n\tif (ReadConsoleOutputCharacterW(hCon, buffer.data(), nChars, crFrom, &nChars)\n\t\t&& nChars)\n\t{\n\t\twchar_t* pszBuf = buffer.data();\n\t\t// Do RTrim first\n\t\twhile (nChars && (pszBuf[nChars - 1] == L' '))\n\t\t\tnChars--;\n\t\t// Add CR+LF\n\t\tpszBuf[nChars++] = L'\\r'; pszBuf[nChars++] = L'\\n';\n\t\t// And do the logging\n\t\tWriteAnsiLogW(pszBuf, nChars);\n\t}\n}\n\nvoid CEAnsi::AnsiLogEnterPressed()\n{\n\tif (!ghAnsiLogFile)\n\t\treturn;\n\tInterlockedIncrement(&gnEnterPressed);\n\tgbAnsiLogNewLine = true;\n}\n\nbool CEAnsi::GetFeatures(ConEmu::ConsoleFlags& features)\n{\n\tstruct FeaturesCache\n\t{\n\t\tConEmu::ConsoleFlags features;\n\t\tBOOL result;\n\t};\n\tstatic FeaturesCache featuresCache{};\n\t// Don't use system_clock here, it fails in some cases during DllLoad (segment is not ready somehow)\n\tstatic DWORD nLastCheck{ 0 };\n\n\tif (!nLastCheck || (GetTickCount() - nLastCheck) > ANSI_MAP_CHECK_TIMEOUT)\n\t{\n\t\tCESERVER_CONSOLE_MAPPING_HDR* pMap = GetConMap();\n\t\t//\t(CESERVER_CONSOLE_MAPPING_HDR*)malloc(sizeof(CESERVER_CONSOLE_MAPPING_HDR));\n\t\tif (pMap)\n\t\t{\n\t\t\t// bAnsiAllowed = ((pMap != nullptr) && (pMap->Flags & ConEmu::ConsoleFlags::ProcessAnsi));\n\t\t\t// bSuppressBells = ((pMap != nullptr) && (pMap->Flags & ConEmu::ConsoleFlags::SuppressBells));\n\t\t\t// Well, it's not so atomic as could be, but here we care only on proper features value\n\t\t\t// and we can't use std::atomic here because function is called during DllLoad\n\t\t\tInterlockedExchange(reinterpret_cast<LONG*>(&featuresCache.features), static_cast<LONG>(pMap->Flags));\n\t\t\tInterlockedExchange(reinterpret_cast<LONG*>(&featuresCache.result), static_cast<LONG>(true));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tInterlockedExchange(reinterpret_cast<LONG*>(&featuresCache.features), 0);\n\t\t\tInterlockedExchange(reinterpret_cast<LONG*>(&featuresCache.result), 0);\n\t\t}\n\t\tnLastCheck = GetTickCount();\n\t}\n\n\tfeatures = static_cast<ConEmu::ConsoleFlags>(InterlockedCompareExchange(reinterpret_cast<LONG*>(&featuresCache.features), 0, 0));\n\tconst bool result = InterlockedCompareExchange(reinterpret_cast<LONG*>(&featuresCache.result), 0, 0);\n\treturn result;\n}\n\nvoid CEAnsi::ReloadFeatures()\n{\n\tConEmu::ConsoleFlags features = ConEmu::ConsoleFlags::Empty;\n\tGetFeatures(features);\n\tmb_SuppressBells = (features & ConEmu::ConsoleFlags::SuppressBells);\n}\n\n\n\n\n//struct DisplayParm\n//{\n//\tBOOL WasSet;\n//\tBOOL BrightOrBold;     // 1\n//\tBOOL Italic;           // 3\n//\tBOOL Underline;        // 4\n//\tBOOL BrightFore;       // 90-97\n//\tBOOL BrightBack;       // 100-107\n//\tint  TextColor;        // 30-37,38,39\n//\tBOOL Text256;          // 38\n//    int  BackColor;        // 40-47,48,49\n//    BOOL Back256;          // 48\n//\t// xterm\n//\tBOOL Inverse;\n//} gDisplayParm = {};\n\nCEAnsi::DisplayParm CEAnsi::gDisplayParm = {};\n\n// void CEAnsi::DisplayParm::setWasSet(...) -- intentionally is not defined\n\nvoid CEAnsi::DisplayParm::Reset(const bool full)\n{\n\tif (full)\n\t\t*this = DisplayParm{};\n\n\tconst WORD nDefColors = CEAnsi::GetDefaultTextAttr();\n\t_TextColor = CONFORECOLOR(nDefColors);\n\t_BackColor = CONBACKCOLOR(nDefColors);\n\t_WasSet = TRUE;\n}\nvoid CEAnsi::DisplayParm::setBrightOrBold(const bool val)\n{\n\tif (!_WasSet)\n\t\tReset(false);\n\t_BrightOrBold = val;\n\t_ASSERTE(_WasSet==TRUE);\n}\nvoid CEAnsi::DisplayParm::setItalic(const bool val)\n{\n\tif (!_WasSet)\n\t\tReset(false);\n\t_Italic = val;\n\t_ASSERTE(_WasSet==TRUE);\n}\nvoid CEAnsi::DisplayParm::setUnderline(const bool val)\n{\n\tif (!_WasSet)\n\t\tReset(false);\n\t_Underline = val;\n\t_ASSERTE(_WasSet==TRUE);\n}\nvoid CEAnsi::DisplayParm::setBrightFore(const bool val)\n{\n\tif (!_WasSet)\n\t\tReset(false);\n\t_BrightFore = val;\n\t_ASSERTE(_WasSet==TRUE);\n}\nvoid CEAnsi::DisplayParm::setBrightBack(const bool val)\n{\n\tif (!_WasSet)\n\t\tReset(false);\n\t_BrightBack = val;\n\t_ASSERTE(_WasSet==TRUE);\n}\nvoid CEAnsi::DisplayParm::setTextColor(const int val)\n{\n\tif (!_WasSet)\n\t\tReset(false);\n\t_TextColor = val;\n\t_ASSERTE(_WasSet==TRUE);\n}\nvoid CEAnsi::DisplayParm::setText256(const cbit val)\n{\n\tif (!_WasSet)\n\t\tReset(false);\n\t_Text256 = val;\n\t_ASSERTE(_WasSet==TRUE);\n}\nvoid CEAnsi::DisplayParm::setBackColor(const int val)\n{\n\tif (!_WasSet)\n\t\tReset(false);\n\t_BackColor = val;\n\t_ASSERTE(_WasSet==TRUE);\n}\nvoid CEAnsi::DisplayParm::setBack256(const cbit val)\n{\n\tif (!_WasSet)\n\t\tReset(false);\n\t_Back256 = val;\n\t_ASSERTE(_WasSet==TRUE);\n}\nvoid CEAnsi::DisplayParm::setInverse(const bool val)\n{\n\tif (!_WasSet)\n\t\tReset(false);\n\t_Inverse = val;\n\t_ASSERTE(_WasSet==TRUE);\n}\nvoid CEAnsi::DisplayParm::setCrossed(const bool val)\n{\n\tif (!_WasSet)\n\t\tReset(false);\n\t_Crossed = val;\n\t_ASSERTE(_WasSet==TRUE);\n}\n\n//struct DisplayCursorPos\n//{\n//    // Internal\n//    COORD StoredCursorPos;\n//\t// Esc[?1h \tSet cursor key to application \tDECCKM\n//\t// Esc[?1l \tSet cursor key to cursor \tDECCKM\n//\tBOOL CursorKeysApp; // \"1h\"\n//} gDisplayCursor = {};\n\nCEAnsi::DisplayCursorPos CEAnsi::gDisplayCursor = {};\n\n//struct DisplayOpt\n//{\n//\tBOOL  WrapWasSet;\n//\tSHORT WrapAt; // Rightmost X coord (1-based)\n//\t//\n//\tBOOL  AutoLfNl; // LF/NL (default off): Automatically follow echo of LF, VT or FF with CR.\n//\t//\n//\tBOOL  ScrollRegion;\n//\tSHORT ScrollStart, ScrollEnd; // 0-based absolute line indexes\n//\t//\n//\tBOOL  ShowRawAnsi; // \\e[3h display ANSI control characters (TRUE), \\e[3l process ANSI (FALSE, normal mode)\n//} gDisplayOpt;\n\nCEAnsi::DisplayOpt CEAnsi::gDisplayOpt = {};\n\n//const size_t cchMaxPrevPart = 160;\n//static wchar_t gsPrevAnsiPart[cchMaxPrevPart] = {};\n//static INT_PTR gnPrevAnsiPart = 0;\n//static wchar_t gsPrevAnsiPart2[cchMaxPrevPart] = {};\n//static INT_PTR gnPrevAnsiPart2 = 0;\n//const  INT_PTR MaxPrevAnsiPart = 80;\n\n#ifdef _DEBUG\nstatic const wchar_t szAnalogues[32] =\n{\n\t32, 9786, 9787, 9829, 9830, 9827, 9824, 8226, 9688, 9675, 9689, 9794, 9792, 9834, 9835, 9788,\n\t9658, 9668, 8597, 8252,  182,  167, 9632, 8616, 8593, 8595, 8594, 8592, 8735, 8596, 9650, 9660\n};\n#endif\n\n/*static*/ SHORT CEAnsi::GetDefaultTextAttr()\n{\n\t// Default console colors\n\tstatic SHORT clrDefault = 0;\n\tif (clrDefault)\n\t\treturn clrDefault;\n\n\t// ReSharper disable once CppLocalVariableMayBeConst\n\tHANDLE hIn = GetStdHandle(STD_OUTPUT_HANDLE);\n\tCONSOLE_SCREEN_BUFFER_INFO csbi = {};\n\tif (!GetConsoleScreenBufferInfo(hIn, &csbi))\n\t\treturn (clrDefault = 7);\n\n\tstatic SHORT Con2Ansi[16] = {0,4,2,6,1,5,3,7,8|0,8|4,8|2,8|6,8|1,8|5,8|3,8|7};\n\tclrDefault = Con2Ansi[CONFORECOLOR(csbi.wAttributes)]\n\t\t| static_cast<SHORT>(Con2Ansi[CONBACKCOLOR(csbi.wAttributes)] << 4);\n\n\treturn clrDefault;\n}\n\n\nconst CEAnsi::DisplayParm& CEAnsi::getDisplayParm()\n{\n\treturn gDisplayParm;\n}\n\n// static\nvoid CEAnsi::ReSetDisplayParm(HANDLE hConsoleOutput, BOOL bReset, BOOL bApply)\n{\n\tWARNING(\"\u042d\u0442\u0443 \u0444\u0443\u043d\u043a\u0443 \u043d\u0443\u0436\u043d\u043e \u0434\u0435\u0440\u0433\u0430\u0442\u044c \u043f\u0440\u0438 \u0441\u043c\u0435\u043d\u0435 \u0431\u0443\u0444\u0435\u0440\u043e\u0432, \u0437\u0430\u043a\u0440\u044b\u0442\u0438\u0438 \u0434\u0435\u0441\u043a\u0440\u0438\u043f\u0442\u043e\u0440\u043e\u0432, \u0438 \u0442.\u043f.\");\n\n\tif (bReset || !gDisplayParm.getWasSet())\n\t{\n\t\tgDisplayParm.Reset(bReset);\n\t}\n\n\tif (bApply)\n\t{\n\t\t// to display\n\t\tExtAttributesParm attr{};\n\t\tattr.StructSize = sizeof(attr);\n\t\tattr.ConsoleOutput = hConsoleOutput;\n\t\t//DWORD wAttrs = 0;\n\n\t\t// Ansi colors\n\t\tstatic DWORD ClrMap[8] = {0,4,2,6,1,5,3,7};\n\t\t// XTerm-256 colors\n\t\tstatic DWORD RgbMap[256] = {0,4,2,6,1,5,3,7, 8+0,8+4,8+2,8+6,8+1,8+5,8+3,8+7, // System Ansi colors\n\t\t\t/*16*/0x000000, /*17*/0x5f0000, /*18*/0x870000, /*19*/0xaf0000, /*20*/0xd70000, /*21*/0xff0000, /*22*/0x005f00, /*23*/0x5f5f00, /*24*/0x875f00, /*25*/0xaf5f00, /*26*/0xd75f00, /*27*/0xff5f00,\n\t\t\t/*28*/0x008700, /*29*/0x5f8700, /*30*/0x878700, /*31*/0xaf8700, /*32*/0xd78700, /*33*/0xff8700, /*34*/0x00af00, /*35*/0x5faf00, /*36*/0x87af00, /*37*/0xafaf00, /*38*/0xd7af00, /*39*/0xffaf00,\n\t\t\t/*40*/0x00d700, /*41*/0x5fd700, /*42*/0x87d700, /*43*/0xafd700, /*44*/0xd7d700, /*45*/0xffd700, /*46*/0x00ff00, /*47*/0x5fff00, /*48*/0x87ff00, /*49*/0xafff00, /*50*/0xd7ff00, /*51*/0xffff00,\n\t\t\t/*52*/0x00005f, /*53*/0x5f005f, /*54*/0x87005f, /*55*/0xaf005f, /*56*/0xd7005f, /*57*/0xff005f, /*58*/0x005f5f, /*59*/0x5f5f5f, /*60*/0x875f5f, /*61*/0xaf5f5f, /*62*/0xd75f5f, /*63*/0xff5f5f,\n\t\t\t/*64*/0x00875f, /*65*/0x5f875f, /*66*/0x87875f, /*67*/0xaf875f, /*68*/0xd7875f, /*69*/0xff875f, /*70*/0x00af5f, /*71*/0x5faf5f, /*72*/0x87af5f, /*73*/0xafaf5f, /*74*/0xd7af5f, /*75*/0xffaf5f,\n\t\t\t/*76*/0x00d75f, /*77*/0x5fd75f, /*78*/0x87d75f, /*79*/0xafd75f, /*80*/0xd7d75f, /*81*/0xffd75f, /*82*/0x00ff5f, /*83*/0x5fff5f, /*84*/0x87ff5f, /*85*/0xafff5f, /*86*/0xd7ff5f, /*87*/0xffff5f,\n\t\t\t/*88*/0x000087, /*89*/0x5f0087, /*90*/0x870087, /*91*/0xaf0087, /*92*/0xd70087, /*93*/0xff0087, /*94*/0x005f87, /*95*/0x5f5f87, /*96*/0x875f87, /*97*/0xaf5f87, /*98*/0xd75f87, /*99*/0xff5f87,\n\t\t\t/*100*/0x008787, /*101*/0x5f8787, /*102*/0x878787, /*103*/0xaf8787, /*104*/0xd78787, /*105*/0xff8787, /*106*/0x00af87, /*107*/0x5faf87, /*108*/0x87af87, /*109*/0xafaf87, /*110*/0xd7af87, /*111*/0xffaf87,\n\t\t\t/*112*/0x00d787, /*113*/0x5fd787, /*114*/0x87d787, /*115*/0xafd787, /*116*/0xd7d787, /*117*/0xffd787, /*118*/0x00ff87, /*119*/0x5fff87, /*120*/0x87ff87, /*121*/0xafff87, /*122*/0xd7ff87, /*123*/0xffff87,\n\t\t\t/*124*/0x0000af, /*125*/0x5f00af, /*126*/0x8700af, /*127*/0xaf00af, /*128*/0xd700af, /*129*/0xff00af, /*130*/0x005faf, /*131*/0x5f5faf, /*132*/0x875faf, /*133*/0xaf5faf, /*134*/0xd75faf, /*135*/0xff5faf,\n\t\t\t/*136*/0x0087af, /*137*/0x5f87af, /*138*/0x8787af, /*139*/0xaf87af, /*140*/0xd787af, /*141*/0xff87af, /*142*/0x00afaf, /*143*/0x5fafaf, /*144*/0x87afaf, /*145*/0xafafaf, /*146*/0xd7afaf, /*147*/0xffafaf,\n\t\t\t/*148*/0x00d7af, /*149*/0x5fd7af, /*150*/0x87d7af, /*151*/0xafd7af, /*152*/0xd7d7af, /*153*/0xffd7af, /*154*/0x00ffaf, /*155*/0x5fffaf, /*156*/0x87ffaf, /*157*/0xafffaf, /*158*/0xd7ffaf, /*159*/0xffffaf,\n\t\t\t/*160*/0x0000d7, /*161*/0x5f00d7, /*162*/0x8700d7, /*163*/0xaf00d7, /*164*/0xd700d7, /*165*/0xff00d7, /*166*/0x005fd7, /*167*/0x5f5fd7, /*168*/0x875fd7, /*169*/0xaf5fd7, /*170*/0xd75fd7, /*171*/0xff5fd7,\n\t\t\t/*172*/0x0087d7, /*173*/0x5f87d7, /*174*/0x8787d7, /*175*/0xaf87d7, /*176*/0xd787d7, /*177*/0xff87d7, /*178*/0x00afd7, /*179*/0x5fafd7, /*180*/0x87afd7, /*181*/0xafafd7, /*182*/0xd7afd7, /*183*/0xffafd7,\n\t\t\t/*184*/0x00d7d7, /*185*/0x5fd7d7, /*186*/0x87d7d7, /*187*/0xafd7d7, /*188*/0xd7d7d7, /*189*/0xffd7d7, /*190*/0x00ffd7, /*191*/0x5fffd7, /*192*/0x87ffd7, /*193*/0xafffd7, /*194*/0xd7ffd7, /*195*/0xffffd7,\n\t\t\t/*196*/0x0000ff, /*197*/0x5f00ff, /*198*/0x8700ff, /*199*/0xaf00ff, /*200*/0xd700ff, /*201*/0xff00ff, /*202*/0x005fff, /*203*/0x5f5fff, /*204*/0x875fff, /*205*/0xaf5fff, /*206*/0xd75fff, /*207*/0xff5fff,\n\t\t\t/*208*/0x0087ff, /*209*/0x5f87ff, /*210*/0x8787ff, /*211*/0xaf87ff, /*212*/0xd787ff, /*213*/0xff87ff, /*214*/0x00afff, /*215*/0x5fafff, /*216*/0x87afff, /*217*/0xafafff, /*218*/0xd7afff, /*219*/0xffafff,\n\t\t\t/*220*/0x00d7ff, /*221*/0x5fd7ff, /*222*/0x87d7ff, /*223*/0xafd7ff, /*224*/0xd7d7ff, /*225*/0xffd7ff, /*226*/0x00ffff, /*227*/0x5fffff, /*228*/0x87ffff, /*229*/0xafffff, /*230*/0xd7ffff, /*231*/0xffffff,\n\t\t\t/*232*/0x080808, /*233*/0x121212, /*234*/0x1c1c1c, /*235*/0x262626, /*236*/0x303030, /*237*/0x3a3a3a, /*238*/0x444444, /*239*/0x4e4e4e, /*240*/0x585858, /*241*/0x626262, /*242*/0x6c6c6c, /*243*/0x767676,\n\t\t\t/*244*/0x808080, /*245*/0x8a8a8a, /*246*/0x949494, /*247*/0x9e9e9e, /*248*/0xa8a8a8, /*249*/0xb2b2b2, /*250*/0xbcbcbc, /*251*/0xc6c6c6, /*252*/0xd0d0d0, /*253*/0xdadada, /*254*/0xe4e4e4, /*255*/0xeeeeee\n\t\t};\n\n\t\tconst auto& TextColor = gDisplayParm.getTextColor();   // 30-37,38,39\n\t\tconst auto& Text256 = gDisplayParm.getText256();       // 38\n\t\tconst auto& BackColor = gDisplayParm.getBackColor();   // 40-47,48,49\n\t\tconst auto& Back256 = gDisplayParm.getBack256();       // 48\n\n\t\tif (Text256)\n\t\t{\n\t\t\tif (Text256 == clr24b)\n\t\t\t{\n\t\t\t\tattr.Attributes.Flags |= ConEmu::ColorFlags::Fg24Bit;\n\t\t\t\tattr.Attributes.ForegroundColor = TextColor&0xFFFFFF;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (TextColor > 15)\n\t\t\t\t\tattr.Attributes.Flags |= ConEmu::ColorFlags::Fg24Bit;\n\t\t\t\tattr.Attributes.ForegroundColor = RgbMap[TextColor&0xFF];\n\t\t\t}\n\t\t}\n\t\telse if (TextColor & 0x8)\n\t\t{\n\t\t\t// Comes from CONSOLE_SCREEN_BUFFER_INFO::wAttributes\n\t\t\tattr.Attributes.ForegroundColor |= ClrMap[TextColor&0x7]\n\t\t\t\t| 0x08;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tattr.Attributes.ForegroundColor |= ClrMap[TextColor&0x7]\n\t\t\t\t| ((gDisplayParm.getBrightFore() || (gDisplayParm.getBrightOrBold() && !gDisplayParm.getBrightBack())) ? 0x08 : 0);\n\t\t}\n\n\t\tif (gDisplayParm.getBrightOrBold() && (Text256 || gDisplayParm.getBrightFore() || gDisplayParm.getBrightBack()))\n\t\t\tattr.Attributes.Flags |= ConEmu::ColorFlags::Bold;\n\t\tif (gDisplayParm.getItalic())\n\t\t\tattr.Attributes.Flags |= ConEmu::ColorFlags::Italic;\n\t\tif (gDisplayParm.getUnderline())\n\t\t\tattr.Attributes.Flags |= ConEmu::ColorFlags::Underline;\n\t\tif (gDisplayParm.getCrossed())\n\t\t\tattr.Attributes.Flags |= ConEmu::ColorFlags::Crossed;\n\t\tif (gDisplayParm.getInverse())\n\t\t\tattr.Attributes.Flags |= ConEmu::ColorFlags::Reverse;\n\n\t\tif (Back256)\n\t\t{\n\t\t\tif (Back256 == clr24b)\n\t\t\t{\n\t\t\t\tattr.Attributes.Flags |= ConEmu::ColorFlags::Bg24Bit;\n\t\t\t\tattr.Attributes.BackgroundColor = BackColor&0xFFFFFF;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (BackColor > 15)\n\t\t\t\t\tattr.Attributes.Flags |= ConEmu::ColorFlags::Bg24Bit;\n\t\t\t\tattr.Attributes.BackgroundColor = RgbMap[BackColor&0xFF];\n\t\t\t}\n\t\t}\n\t\telse if (BackColor & 0x8)\n\t\t{\n\t\t\t// Comes from CONSOLE_SCREEN_BUFFER_INFO::wAttributes\n\t\t\tattr.Attributes.BackgroundColor |= ClrMap[BackColor&0x7]\n\t\t\t\t| 0x8;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tattr.Attributes.BackgroundColor |= ClrMap[BackColor&0x7]\n\t\t\t\t| (gDisplayParm.getBrightBack() ? 0x8 : 0);\n\t\t}\n\n\n\t\t//SetConsoleTextAttribute(hConsoleOutput, (WORD)wAttrs);\n\t\tExtSetAttributes(&attr);\n\t}\n}\n\n\n#if defined(DUMP_UNKNOWN_ESCAPES) || defined(DUMP_WRITECONSOLE_LINES)\nstatic MAtomic<int32_t> nWriteCallNo{ 0 };\n#endif\n\nint CEAnsi::DumpEscape(LPCWSTR buf, size_t cchLen, DumpEscapeCodes iUnknown)\n{\n\tint result = 0;\n#if defined(DUMP_UNKNOWN_ESCAPES) || defined(DUMP_WRITECONSOLE_LINES)\n\tif (!buf || !cchLen)\n\t{\n\t\t// There are programs which try to write empty strings\n\t\t// e.g. clink, perl, ...\n\t\t//_ASSERTEX((buf && cchLen) || (gszClinkCmdLine && buf));\n\t}\n\n\twchar_t szDbg[200];\n\tsize_t nLen = cchLen;\n\n\tswitch (iUnknown)  // NOLINT(clang-diagnostic-switch-enum)\n\t{\n\tcase de_Unknown/*1*/:\n\t\tmsprintf(szDbg, countof(szDbg), L\"[%u] ###Unknown Esc Sequence: \", GetCurrentThreadId());\n\t\tbreak;\n\tcase de_BadUnicode/*2*/:\n\t\tmsprintf(szDbg, countof(szDbg), L\"[%u] ###Bad Unicode Translation: \", GetCurrentThreadId());\n\t\tbreak;\n\tcase de_Ignored/*3*/:\n\t\tmsprintf(szDbg, countof(szDbg), L\"[%u] ###Ignored Esc Sequence: \", GetCurrentThreadId());\n\t\tbreak;\n\tcase de_UnkControl/*4*/:\n\t\tmsprintf(szDbg, countof(szDbg), L\"[%u] ###Unknown Esc Control: \", GetCurrentThreadId());\n\t\tbreak;\n\tcase de_Report/*5*/:\n\t\tmsprintf(szDbg, countof(szDbg), L\"[%u] ###Back Report: \", GetCurrentThreadId());\n\t\tbreak;\n\tcase de_ScrollRegion/*6*/:\n\t\tmsprintf(szDbg, countof(szDbg), L\"[%u] ###Scroll region: \", GetCurrentThreadId());\n\t\tbreak;\n\tcase de_Comment/*7*/:\n\t\tmsprintf(szDbg, countof(szDbg), L\"[%u] ###Internal comment: \", GetCurrentThreadId());\n\t\tbreak;\n\tdefault:\n\t\tresult = nWriteCallNo.inc();\n\t\tmsprintf(szDbg, countof(szDbg), L\"[%u] AnsiDump #%u: \", GetCurrentThreadId(), result);\n\t}\n\n\tconst size_t nStart = lstrlenW(szDbg);\n\twchar_t* pszDst = szDbg + nStart;\n\twchar_t* pszFrom = szDbg;\n\n\tif (buf && cchLen)\n\t{\n\t\tconst wchar_t* pszSrc = static_cast<const wchar_t*>(buf);\n\t\tsize_t nCur = 0;\n\t\twhile (nLen)\n\t\t{\n\t\t\tswitch (*pszSrc)\n\t\t\t{\n\t\t\tcase L'\\r':\n\t\t\t\t*(pszDst++) = L'\\\\'; *(pszDst++) = L'r';\n\t\t\t\tbreak;\n\t\t\tcase L'\\n':\n\t\t\t\t*(pszDst++) = L'\\\\'; *(pszDst++) = L'n';\n\t\t\t\tbreak;\n\t\t\tcase L'\\t':\n\t\t\t\t*(pszDst++) = L'\\\\'; *(pszDst++) = L't';\n\t\t\t\tbreak;\n\t\t\tcase L'\\x1B':\n\t\t\t\t*(pszDst++) = szAnalogues[0x1B];\n\t\t\t\tbreak;\n\t\t\tcase 0:\n\t\t\t\t*(pszDst++) = L'\\\\'; *(pszDst++) = L'0';\n\t\t\t\tbreak;\n\t\t\tcase 7:\n\t\t\t\t*(pszDst++) = L'\\\\'; *(pszDst++) = L'a';\n\t\t\t\tbreak;\n\t\t\tcase 8:\n\t\t\t\t*(pszDst++) = L'\\\\'; *(pszDst++) = L'b';\n\t\t\t\tbreak;\n\t\t\tcase 0x7F:\n\t\t\t\t*(pszDst++) = '\\\\'; *(pszDst++) = 'x'; *(pszDst++) = '7'; *(pszDst++) = 'F';\n\t\t\t\tbreak;\n\t\t\tcase L'\\\\':\n\t\t\t\t*(pszDst++) = L'\\\\'; *(pszDst++) = L'\\\\';\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t*(pszDst++) = *pszSrc;\n\t\t\t}\n\t\t\tpszSrc++;\n\t\t\tnLen--;\n\t\t\tnCur++;\n\n\t\t\tif (nCur >= 80)\n\t\t\t{\n\t\t\t\t*(pszDst++) = 0xB6; // L'\u00b6';\n\t\t\t\t*(pszDst++) = L'\\n';\n\t\t\t\t*pszDst = 0;\n\t\t\t\t// Try to pass UTF-8 encoded strings to debugger\n\t\t\t\tDebugStringUtf8(szDbg);\n\t\t\t\twmemset(szDbg, L' ', nStart);\n\t\t\t\tnCur = 0;\n\t\t\t\tpszFrom = pszDst = szDbg + nStart;\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tpszDst -= 2;\n\t\tconst wchar_t* psEmptyMessage = L\" - <empty sequence>\";\n\t\tconst size_t nMsgLen = lstrlenW(psEmptyMessage);\n\t\twmemcpy(pszDst, psEmptyMessage, nMsgLen);\n\t\tpszDst += nMsgLen;\n\t}\n\n\tif (pszDst > pszFrom)\n\t{\n\t\t*(pszDst++) = 0xB6; // L'\u00b6';\n\t\t*(pszDst++) = L'\\n';\n\t\t*pszDst = 0;\n\t\t// Try to pass UTF-8 encoded strings to debugger\n\t\tDebugStringUtf8(szDbg);\n\t}\n\n\tif (iUnknown == 1)\n\t{\n\t\t_ASSERTEX(FALSE && \"Unknown Esc Sequence!\");\n\t}\n#endif\n\treturn result;\n}\n\n#ifdef DUMP_UNKNOWN_ESCAPES\n#define DumpUnknownEscape(buf, cchLen) DumpEscape(buf, cchLen, de_Unknown)\n#define DumpKnownEscape(buf, cchLen, eType) DumpEscape(buf, cchLen, eType)\n#else\n#define DumpUnknownEscape(buf,cchLen) (0)\n#define DumpKnownEscape(buf, cchLen, eType) (0)\n#endif\n\nstatic MAtomic<uint32_t> gnLastReadId{ 0 };\n\n// When user type something in the prompt, screen buffer may be scrolled\n// It would be nice to do the same in \"ConEmuC -StoreCWD\"\nvoid CEAnsi::OnReadConsoleBefore(HANDLE hConOut, const CONSOLE_SCREEN_BUFFER_INFO& csbi)\n{\n\tCEAnsi* pObj = CEAnsi::Object();\n\tif (!pObj)\n\t\treturn;\n\n\tif (!gnLastReadId.load())\n\t\tgnLastReadId.store(GetCurrentProcessId());\n\n\tWORD newRowId = 0;\n\tCEConsoleMark Test = {};\n\n\tCOORD crPos[] = { {4,static_cast<SHORT>(csbi.dwCursorPosition.Y - 1)}, csbi.dwCursorPosition };\n\t_ASSERTEX(countof(crPos) == countof(pObj->m_RowMarks.SaveRow) && countof(crPos) == countof(pObj->m_RowMarks.RowId));\n\n\tpObj->m_RowMarks.csbi = csbi;\n\n\tfor (int i = 0; i < 2; i++)\n\t{\n\t\tpObj->m_RowMarks.SaveRow[i] = -1;\n\t\tpObj->m_RowMarks.RowId[i] = 0;\n\n\t\tif (crPos[i].X < 4 || crPos[i].Y < 0)\n\t\t\tcontinue;\n\n\t\tif (ReadConsoleRowId(hConOut, crPos[i].Y, &Test))\n\t\t{\n\t\t\tpObj->m_RowMarks.SaveRow[i] = crPos[i].Y;\n\t\t\tpObj->m_RowMarks.RowId[i] = Test.RowId;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// ReSharper disable once CppJoinDeclarationAndAssignment\n\t\t\tnewRowId = LOWORD(gnLastReadId.inc());\n\t\t\tif (!newRowId)\n\t\t\t\tnewRowId = LOWORD(gnLastReadId.inc());\n\n\t\t\tif (WriteConsoleRowId(hConOut, crPos[i].Y, newRowId))\n\t\t\t{\n\t\t\t\tpObj->m_RowMarks.SaveRow[i] = crPos[i].Y;\n\t\t\t\tpObj->m_RowMarks.RowId[i] = newRowId;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Successful mark?\n\t_ASSERTEX(((pObj->m_RowMarks.RowId[0] || pObj->m_RowMarks.RowId[1]) && (pObj->m_RowMarks.RowId[0] != pObj->m_RowMarks.RowId[1])) || (!csbi.dwCursorPosition.X && !csbi.dwCursorPosition.Y));\n\n\t// Store info in MAPPING\n\tCESERVER_CONSOLE_APP_MAPPING* pAppMap = gpAppMap ? gpAppMap->Ptr() : nullptr;\n\tif (pAppMap)\n\t{\n\t\tpAppMap->csbiPreRead = csbi;\n\t\tpAppMap->nPreReadRowID[0] = pObj->m_RowMarks.RowId[0];\n\t\tpAppMap->nPreReadRowID[1] = pObj->m_RowMarks.RowId[1];\n\t}\n}\nvoid CEAnsi::OnReadConsoleAfter(bool bFinal, bool bNoLineFeed)\n{\n\tCEAnsi* pObj = CEAnsi::Object();\n\tif (!pObj)\n\t\treturn;\n\n\tif (pObj->m_RowMarks.SaveRow[0] < 0 && pObj->m_RowMarks.SaveRow[1] < 0)\n\t\treturn;\n\n\tCONSOLE_SCREEN_BUFFER_INFO csbi = {};\n\t// ReSharper disable once CppLocalVariableMayBeConst\n\tHANDLE hConOut = GetStdHandle(STD_OUTPUT_HANDLE);\n\tSHORT nMarkedRow = -1;\n\tCEConsoleMark Test = {};\n\n\tif (!GetConsoleScreenBufferInfo(hConOut, &csbi))\n\t\tgoto wrap;\n\n\tif (!FindConsoleRowId(hConOut, csbi.dwCursorPosition.Y, true, &nMarkedRow, &Test))\n\t\tgoto wrap;\n\n\tfor (int i = 1; i >= 0; i--)\n\t{\n\t\tif ((pObj->m_RowMarks.SaveRow[i] >= 0) && (pObj->m_RowMarks.RowId[i] == Test.RowId))\n\t\t{\n\t\t\tif (pObj->m_RowMarks.SaveRow[i] == nMarkedRow)\n\t\t\t{\n\t\t\t\t_ASSERTEX(\n\t\t\t\t\t((pObj->m_RowMarks.csbi.dwCursorPosition.Y < (pObj->m_RowMarks.csbi.dwSize.Y-1))\n\t\t\t\t\t\t|| (bNoLineFeed && (pObj->m_RowMarks.csbi.dwCursorPosition.Y == (pObj->m_RowMarks.csbi.dwSize.Y-1))))\n\t\t\t\t\t&& \"Nothing was changed? Strange, scrolling was expected\");\n\t\t\t\tgoto wrap;\n\t\t\t}\n\t\t\t// Well, we get scroll distance\n\t\t\t_ASSERTEX(nMarkedRow < pObj->m_RowMarks.SaveRow[i]); // Upside scroll expected\n\t\t\tExtScrollScreenParm scrl = {sizeof(scrl), essf_ExtOnly, hConOut, nMarkedRow - pObj->m_RowMarks.SaveRow[i], {}, 0, {}};\n\t\t\tExtScrollScreen(&scrl);\n\t\t\tgoto wrap;\n\t\t}\n\t}\n\nwrap:\n\t// Clear it\n\tfor (int i = 0; i < 2; i++)\n\t{\n\t\tpObj->m_RowMarks.SaveRow[i] = -1;\n\t\tpObj->m_RowMarks.RowId[i] = 0;\n\t}\n}\n\n\nBOOL CEAnsi::WriteText(OnWriteConsoleW_t writeConsoleW, HANDLE hConsoleOutput, LPCWSTR lpBuffer, DWORD nNumberOfCharsToWrite, LPDWORD lpNumberOfCharsWritten, BOOL abCommit /*= FALSE*/, EXTREADWRITEFLAGS AddFlags /*= ewtf_None*/)\n{\n\tBOOL lbRc = FALSE;\n\tDWORD /*nWritten = 0,*/ nTotalWritten = 0;\n\n\t#ifdef _DEBUG\n\tORIGINAL_KRNL(WriteConsoleW);\n\tOnWriteConsoleW_t pfnDbgWriteConsoleW = F(WriteConsoleW);\n\t_ASSERTE(((writeConsoleW == pfnDbgWriteConsoleW) || !HooksWereSet) && \"It must point to CallPointer for 'unhooked' call\");\n\t#endif\n\n\tif (lpBuffer && nNumberOfCharsToWrite)\n\t\tm_LastWrittenChar = lpBuffer[nNumberOfCharsToWrite-1];\n\n\tExtWriteTextParm write{};\n\twrite.StructSize = sizeof(write);\n\twrite.Flags = ewtf_Current | AddFlags;\n\twrite.ConsoleOutput = hConsoleOutput;\n\twrite.Private = reinterpret_cast<void*>(writeConsoleW);\n\n\tLPCWSTR pszSrcBuffer = lpBuffer;\n\twchar_t cvtBuf[80];\n\twchar_t* pCvtBuf = nullptr;\n\tCEStr buffer;\n\tif (mCharSet && lpBuffer && nNumberOfCharsToWrite)\n\t{\n\t\tstatic wchar_t G0_DRAWING[31] = {\n\t\t\t0x2666 /*\u2666*/, 0x2592 /*\u2592*/, 0x2192 /*\u2192*/, 0x21A8 /*\u21a8*/, 0x2190 /*\u2190*/, 0x2193 /*\u2193*/, 0x00B0 /*\u00b0*/, 0x00B1 /*\u00b1*/,\n\t\t\t0x00B6 /*\u00b6*/, 0x2195 /*\u2195*/, 0x2518 /*\u2518*/, 0x2510 /*\u2510*/, 0x250C /*\u250c*/, 0x2514 /*\u2514*/, 0x253C /*\u253c*/, 0x203E /*\u203e*/,\n\t\t\t0x207B /*\u207b*/, 0x2500 /*\u2500*/, 0x208B /*\u208b*/, 0x005F /*_*/, 0x251C /*\u251c*/, 0x2524 /*\u2524*/, 0x2534 /*\u2534*/, 0x252C /*\u252c*/,\n\t\t\t0x2502 /*\u2502*/, 0x2264 /*\u2264*/, 0x2265 /*\u2265*/, 0x03C0 /*\u03c0*/, 0x2260 /*\u2260*/, 0x00A3 /*\u00a3*/, 0x00B7 /*\u00b7*/\n\t\t};\n\t\tLPCWSTR pszMap = nullptr;\n\t\t// ReSharper disable once CppIncompleteSwitchStatement\n\t\tswitch (mCharSet)  // NOLINT(clang-diagnostic-switch)\n\t\t{\n\t\tcase VTCS_DRAWING:\n\t\t\tpszMap = G0_DRAWING;\n\t\t\tbreak;\n\t\t}\n\t\tif (pszMap)\n\t\t{\n\t\t\twchar_t* dst = nullptr;\n\t\t\tfor (DWORD i = 0; i < nNumberOfCharsToWrite; ++i)\n\t\t\t{\n\t\t\t\tif (pszSrcBuffer[i] >= 0x60 && pszSrcBuffer[i] < 0x7F)\n\t\t\t\t{\n\t\t\t\t\tif (!pCvtBuf)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (nNumberOfCharsToWrite <= countof(cvtBuf))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tpCvtBuf = cvtBuf;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (!((pCvtBuf = buffer.GetBuffer(nNumberOfCharsToWrite))))\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlpBuffer = pCvtBuf;\n\t\t\t\t\t\tdst = pCvtBuf;\n\t\t\t\t\t\tif (i)\n\t\t\t\t\t\t\tmemmove(dst, pszSrcBuffer, i * sizeof(*dst));\n\t\t\t\t\t}\n\t\t\t\t\tdst[i] = pszMap[pszSrcBuffer[i] - 0x60];\n\t\t\t\t}\n\t\t\t\telse if (dst)\n\t\t\t\t{\n\t\t\t\t\tdst[i] = pszSrcBuffer[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tReloadFeatures();\n\tif (mb_SuppressBells)\n\t{\n\t\twrite.Flags |= ewtf_NoBells;\n\t}\n\n\tif (gDisplayOpt.WrapWasSet && (gDisplayOpt.WrapAt > 0))\n\t{\n\t\twrite.Flags |= ewtf_WrapAt;\n\t\twrite.WrapAtCol = gDisplayOpt.WrapAt;\n\t}\n\n\tif (gDisplayOpt.ScrollRegion)\n\t{\n\t\twrite.Flags |= ewtf_Region;\n\t\t_ASSERTEX(gDisplayOpt.ScrollStart >= 0 && gDisplayOpt.ScrollEnd >= gDisplayOpt.ScrollStart);\n\t\twrite.Region.top = gDisplayOpt.ScrollStart;\n\t\twrite.Region.bottom = gDisplayOpt.ScrollEnd;\n\t\twrite.Region.left = write.Region.right = -1; // not used yet\n\t}\n\n\tif (!IsAutoLfNl())\n\t\twrite.Flags |= ewtf_NoLfNl;\n\n\tDWORD nWriteFrom = 0, nWriteTo = nNumberOfCharsToWrite;\n\n\t#ifdef GH_1402\n\tstatic bool fishLineFeed = false;\n\tstruct ExtWriteTextCalls { const wchar_t* buffer; size_t count; };\n\tconst size_t ext_calls_max = 16;\n\tstatic ExtWriteTextCalls ext_calls[ext_calls_max] = {};\n\tstatic size_t ext_calls_count = 0;\n\n\tauto count_chars = [&](const wchar_t test) -> unsigned {\n\t\tunsigned count = 0;\n\t\tfor (DWORD n = nWriteFrom; n < nWriteTo; ++n)\n\t\t{\n\t\t\tif (lpBuffer[n] == test)\n\t\t\t\t++count;\n\t\t}\n\t\treturn count;\n\t};\n\t#endif\n\n\tif ((nNumberOfCharsToWrite == 1) && isConsoleBadDBCS())\n\t{\n\t\tif (lpBuffer[0] == ucLineFeed)\n\t\t{\n\t\t\tstatic wchar_t dummy_buf[2] = L\"%\";\n\t\t\tlpBuffer = dummy_buf;\n\t\t}\n\t}\n\n\twhile (nWriteTo > nWriteFrom && nWriteFrom < nNumberOfCharsToWrite)\n\t{\n\t\t#ifdef GH_1402\n\t\tbool curFishLineFeed = false;\n\t\tif (count_chars(ucLineFeed) > 0)\n\t\t{\n\t\t\tif (!gbIsXTermOutput)\n\t\t\t{\n\t\t\t\t_ASSERTE(FALSE && \"XTerm mode was not enabled!\");\n\t\t\t\tDBG_XTERM(L\"xTermOutput=ON due gh-1402 LineFeed\");\n\t\t\t\tSetIsXTermOutput(true);\n\t\t\t}\n\t\t\tcurFishLineFeed = true;\n\t\t}\n\t\t#endif\n\n\t\t// for debug purposes insert \"\\x1B]9;10\\x1B\\\" at the beginning of connector-*-out.log\n\t\tif (gbIsXTermOutput)\n\t\t{\n\t\t\t// On Win10 we may utilize DISABLE_NEWLINE_AUTO_RETURN flag, but it would\n\t\t\t// complicate our code, because ConEmu support older Windows versions\n\t\t\twrite.Flags &= ~ewtf_DontWrap;\n\t\t\t// top:  writes all lines using full console width\n\t\t\t//       and thereafter some ANSI-s and \"\\r\\n\"\n\t\t\t// fish: writes in one call \"(Width-1)*Spaces,\\r,Space,\\r\"\n\t\t\tDWORD ChrSet = (lpBuffer[nWriteFrom] == L'\\r' || lpBuffer[nWriteFrom] == L'\\n') ? 1 : 2;\n\t\t\tfor (DWORD n = nWriteFrom+1; (n < nWriteTo); n++)\n\t\t\t{\n\t\t\t\tDWORD AddChrSet = (lpBuffer[n] == L'\\r' || lpBuffer[n] == L'\\n') ? 1 : 2;\n\t\t\t\tif (ChrSet != AddChrSet)\n\t\t\t\t{\n\t\t\t\t\t// If only printable chars are written\n\t\t\t\t\t// ExtWriteText will check (AI) if it must not wrap&scroll\n\t\t\t\t\tif (ChrSet == 2)\n\t\t\t\t\t\twrite.Flags |= ewtf_DontWrap;\n\t\t\t\t\tnWriteTo = n;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t// Expected to be the same\n\t\t\t\t_ASSERTE(ChrSet == AddChrSet);\n\t\t\t\tChrSet |= AddChrSet;\n\t\t\t}\n\t\t\t// Perhaps, we shall do that always\n\t\t\tif (ChrSet == 2)\n\t\t\t\twrite.Flags |= ewtf_DontWrap;\n\t\t}\n\t\t_ASSERTE(nWriteTo<=nNumberOfCharsToWrite);\n\n\t\t//lbRc = writeConsoleW(hConsoleOutput, lpBuffer, nNumberOfCharsToWrite, &nTotalWritten, nullptr);\n\t\twrite.Buffer = lpBuffer + nWriteFrom;\n\t\twrite.NumberOfCharsToWrite = nWriteTo - nWriteFrom;\n\n\t\t#ifdef GH_1402\n\t\t// For debugging purposes, we store ext_calls_max latest outputs\n\t\tauto& ext_call = ext_calls[(ext_calls_count++) % ext_calls_max];\n\t\text_call.buffer = write.Buffer;\n\t\text_call.count = write.NumberOfCharsToWrite;\n\t\t// Ensure we don't write more than a one LF character\n\t\tif (curFishLineFeed)\n\t\t{\n\t\t\tunsigned ulf_chars = count_chars(ucLineFeed);\n\t\t\t_ASSERTE(ulf_chars <= 1);\n\t\t\tunsigned cr_chars = count_chars(L'\\r');\n\t\t\tunsigned lf_chars = count_chars(L'\\n');\n\t\t\tif (ulf_chars)\n\t\t\t\t_ASSERTE((ulf_chars > 0) != ((cr_chars+lf_chars) > 0));\n\t\t\tif (fishLineFeed && (count_chars(L' ') > 0))\n\t\t\t\t_ASSERTE((write.Flags & ewtf_DontWrap) != 0);\n\t\t\tif (ulf_chars > 0)\n\t\t\t\tfishLineFeed = true;\n\t\t\tif (cr_chars > 0)\n\t\t\t\tfishLineFeed = false;\n\t\t}\n\t\t#endif\n\n\t\tlbRc = ExtWriteText(&write);\n\t\tif (lbRc)\n\t\t{\n\t\t\tif (write.NumberOfCharsWritten)\n\t\t\t{\n\t\t\t\tnTotalWritten += write.NumberOfCharsWritten;\n\t\t\t}\n\t\t\tif (write.ScrolledRowsUp > 0)\n\t\t\t{\n\t\t\t\tconst int right = static_cast<int>(gDisplayCursor.StoredCursorPos.Y) - static_cast<int>(write.ScrolledRowsUp);\n\t\t\t\tgDisplayCursor.StoredCursorPos.Y = static_cast<SHORT>(std::max(0, right));\n\t\t\t}\n\t\t}\n\n\t\tnWriteFrom = nWriteTo; nWriteTo = nNumberOfCharsToWrite;\n\t}\n\n\tif (lpNumberOfCharsWritten)\n\t\t*lpNumberOfCharsWritten = nTotalWritten;\n\n\treturn lbRc;\n}\n\n// NON-static, because we need to \u2018cache\u2019 parts of non-translated MBCS chars (one UTF-8 symbol may be transmitted by up to *three* parts)\nBOOL CEAnsi::OurWriteConsoleA(HANDLE hConsoleOutput, const char *lpBuffer, DWORD nNumberOfCharsToWrite, LPDWORD lpNumberOfCharsWritten)\n{\n\t_ASSERTE(this != nullptr);\n\tBOOL lbRc = FALSE;\n\twchar_t* buf = nullptr;\n\twchar_t szTemp[280]; // would be enough in most cases\n\tCEStr ptrTemp;\n\tINT_PTR bufMax;\n\t// ReSharper disable once CppJoinDeclarationAndAssignment\n\tDWORD cp;\n\t// ReSharper disable once CppJoinDeclarationAndAssignment\n\tCpCvtResult cvt{};\n\tconst char* pSrc = nullptr;\n\tconst char* pTokenStart = nullptr;\n\twchar_t* pDst = nullptr;\n\twchar_t* pDstEnd = nullptr;\n\tDWORD nWritten = 0;\n\tDWORD nTotalWritten = 0;\n\n\tORIGINAL_KRNL(WriteConsoleA);\n\n\t// Nothing to write? Or flush buffer?\n\tif (!lpBuffer || !nNumberOfCharsToWrite || !hConsoleOutput || (hConsoleOutput == INVALID_HANDLE_VALUE))\n\t{\n\t\tif (lpNumberOfCharsWritten)\n\t\t\t*lpNumberOfCharsWritten = 0;\n\t\tlbRc = TRUE;\n\t\tgoto fin;\n\t}\n\n\tif ((nNumberOfCharsToWrite + 3) >= countof(szTemp))\n\t{\n\t\tbufMax = nNumberOfCharsToWrite + 3;\n\t\tbuf = ptrTemp.GetBuffer(bufMax);\n\t}\n\telse\n\t{\n\t\tbuf = szTemp;\n\t\tbufMax = countof(szTemp);\n\t}\n\tif (!buf)\n\t{\n\t\tSetLastError(ERROR_NOT_ENOUGH_MEMORY);\n\t\tgoto fin;\n\t}\n\n\tcp = GetCodePage();\n\tm_Cvt.SetCP(cp);\n\n\tlbRc = TRUE;\n\tpSrc = pTokenStart = lpBuffer;\n\tpDst = buf; pDstEnd = buf + bufMax - 3;\n\tfor (DWORD n = 0; n < nNumberOfCharsToWrite; n++, pSrc++)\n\t{\n\t\tif (pDst >= pDstEnd)\n\t\t{\n\t\t\t_ASSERTE((pDst < (buf+bufMax)) && \"wchar_t buffer overflow while converting\");\n\t\t\tbuf[(pDst - buf)] = 0; // It's not required, just to easify debugging\n\t\t\tlbRc = OurWriteConsoleW(hConsoleOutput, buf, static_cast<DWORD>(pDst - buf), &nWritten, nullptr);\n\t\t\tif (lbRc) nTotalWritten += nWritten;\n\t\t\tpDst = buf;\n\t\t}\n\t\tcvt = m_Cvt.Convert(*pSrc, *pDst);\n\t\tswitch (cvt)  // NOLINT(clang-diagnostic-switch-enum)\n\t\t{\n\t\tcase ccr_OK:\n\t\tcase ccr_BadUnicode:\n\t\t\tpDst++;\n\t\t\tbreak;\n\t\tcase ccr_Surrogate:\n\t\tcase ccr_BadTail:\n\t\tcase ccr_DoubleBad:\n\t\t\tm_Cvt.GetTail(*(++pDst));\n\t\t\tpDst++;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (pDst > buf)\n\t{\n\t\t_ASSERTE((pDst < (buf+bufMax)) && \"wchar_t buffer overflow while converting\");\n\t\tbuf[(pDst - buf)] = 0; // It's not required, just to easify debugging\n\t\tlbRc = OurWriteConsoleW(hConsoleOutput, buf, static_cast<DWORD>(pDst - buf), &nWritten, nullptr);\n\t\tif (lbRc)\n\t\t\tnTotalWritten += nWritten;\n\t}\n\n\t// Issue 1291:\tPython fails to print string sequence with ASCII character followed by Chinese character.\n\tif (lpNumberOfCharsWritten && lbRc)\n\t{\n\t\t*lpNumberOfCharsWritten = nNumberOfCharsToWrite;\n\t}\n\nfin:\n\tstd::ignore = pTokenStart;\n\tstd::ignore = nTotalWritten;\n\treturn lbRc;\n}\n\nBOOL CEAnsi::OurWriteConsoleW(HANDLE hConsoleOutput, const VOID *lpBuffer, DWORD nNumberOfCharsToWrite, LPDWORD lpNumberOfCharsWritten, LPVOID lpReserved, bool bInternal /*= false*/)\n{\n\tORIGINAL_KRNL(WriteConsoleW);\n\tBOOL lbRc = FALSE;\n\t//ExtWriteTextParm wrt = {sizeof(wrt), ewtf_None, hConsoleOutput};\n\tbool bIsConOut = false;\n\tbool bIsAnsi = false;\n\n\tFIRST_ANSI_CALL(static_cast<const BYTE*>(lpBuffer), nNumberOfCharsToWrite);\n\n#if 0\n\t// Store prompt(?) for clink 0.1.1\n\tif ((gnAllowClinkUsage == 1) && nNumberOfCharsToWrite && lpBuffer && gpszLastWriteConsole && gcchLastWriteConsoleMax)\n\t{\n\t\tsize_t cchMax = std::min(gcchLastWriteConsoleMax-1,nNumberOfCharsToWrite);\n\t\tgpszLastWriteConsole[cchMax] = 0;\n\t\twmemmove(gpszLastWriteConsole, (const wchar_t*)lpBuffer, cchMax);\n\t}\n#endif\n\n\t// In debug builds: Write to debug console all console Output\n\tconst auto ansiIndex = DumpKnownEscape(static_cast<const wchar_t*>(lpBuffer), nNumberOfCharsToWrite, de_Normal);\n\n#ifdef _DEBUG\n\tstruct AnsiDuration  // NOLINT(cppcoreguidelines-special-member-functions)\n\t{\n\t\tconst int ansiIndex_;\n\t\tconst std::chrono::steady_clock::time_point startTime_;\n\n\t\tAnsiDuration(const int ansiIndex)\n\t\t\t: ansiIndex_(ansiIndex), startTime_(std::chrono::steady_clock::now())\n\t\t{\n\t\t}\n\n\t\t~AnsiDuration()\n\t\t{\n\t\t\tconst auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::steady_clock::now() - startTime_);\n\t\t\twchar_t info[80] = L\"\";\n\t\t\tmsprintf(info, countof(info), L\"[%u] AnsiDump #%u duration(ms): %u\\n\", GetCurrentThreadId(), ansiIndex_, duration.count());\n\t\t\tOutputDebugStringW(info);\n\t\t}\n\t};\n\tAnsiDuration duration(ansiIndex);\n#endif\n\n\tCEAnsi* pObj = nullptr;\n\tCEStr cpCvtBuffer;\n\n\tif (lpBuffer && nNumberOfCharsToWrite && hConsoleOutput)\n\t{\n\t\tbIsAnsi = HandleKeeper::IsAnsiCapable(hConsoleOutput, &bIsConOut);\n\n\t\tif (ghAnsiLogFile && bIsConOut)\n\t\t{\n\t\t\tCEAnsi::WriteAnsiLogW(static_cast<LPCWSTR>(lpBuffer), nNumberOfCharsToWrite);\n\t\t}\n\t}\n\n\tif (lpBuffer && nNumberOfCharsToWrite && hConsoleOutput && bIsAnsi)\n\t{\n\t\t// if that was API call of WriteConsoleW\n\t\tif (!bInternal && gCpConv.nFromCP && gCpConv.nToCP)\n\t\t{\n\t\t\t// Convert from unicode to MBCS\n\t\t\tCEStrA pszTemp;\n\t\t\tint iMbcsLen = WideCharToMultiByte(gCpConv.nFromCP, 0, static_cast<LPCWSTR>(lpBuffer), nNumberOfCharsToWrite, nullptr, 0, nullptr, nullptr);\n\t\t\tif ((iMbcsLen > 0) && ((pszTemp.GetBuffer(iMbcsLen)) != nullptr))\n\t\t\t{\n\t\t\t\tBOOL bFailed = FALSE; // Do not do conversion if some chars can't be mapped\n\t\t\t\tiMbcsLen = WideCharToMultiByte(gCpConv.nFromCP, 0, static_cast<LPCWSTR>(lpBuffer), nNumberOfCharsToWrite, pszTemp.data(), iMbcsLen, nullptr, &bFailed);\n\t\t\t\tif ((iMbcsLen > 0) && !bFailed)\n\t\t\t\t{\n\t\t\t\t\tint iWideLen = MultiByteToWideChar(gCpConv.nToCP, 0, pszTemp, iMbcsLen, nullptr, 0);\n\t\t\t\t\tif (iWideLen > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\twchar_t* ptrBuf = cpCvtBuffer.GetBuffer(iWideLen);\n\t\t\t\t\t\tif (ptrBuf)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tiWideLen = MultiByteToWideChar(gCpConv.nToCP, 0, pszTemp, iMbcsLen, ptrBuf, iWideLen);\n\t\t\t\t\t\t\tif (iWideLen > 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tlpBuffer = ptrBuf;\n\t\t\t\t\t\t\t\tnNumberOfCharsToWrite = iWideLen;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpObj = CEAnsi::Object();\n\t\tif (pObj)\n\t\t{\n\t\t\tif (pObj->gnPrevAnsiPart || gDisplayOpt.WrapWasSet)\n\t\t\t{\n\t\t\t\t// \u0415\u0441\u043b\u0438 \u043e\u0441\u0442\u0430\u043b\u0441\u044f \"\u0445\u0432\u043e\u0441\u0442\" \u043e\u0442 \u043f\u0440\u0435\u0434\u0443\u0449\u0435\u0439 \u0437\u0430\u043f\u0438\u0441\u0438 - \u0441\u0440\u0430\u0437\u0443, \u0431\u0435\u0437 \u043f\u0440\u043e\u0432\u0435\u0440\u043e\u043a\n\t\t\t\tlbRc = pObj->WriteAnsiCodes(F(WriteConsoleW), hConsoleOutput, static_cast<const wchar_t*>(lpBuffer), nNumberOfCharsToWrite, lpNumberOfCharsWritten);\n\t\t\t\tgoto ansidone;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t_ASSERTEX(ESC==27 && BEL==7 && DSC==0x90);\n\t\t\t\tconst wchar_t* pch = static_cast<const wchar_t*>(lpBuffer);\n\t\t\t\tfor (size_t i = nNumberOfCharsToWrite; i--; pch++)\n\t\t\t\t{\n\t\t\t\t\t// \u0415\u0441\u043b\u0438 \u0432 \u0432\u044b\u0432\u043e\u0434\u0438\u043c\u043e\u0439 \u0441\u0442\u0440\u043e\u043a\u0435 \u0432\u0441\u0442\u0440\u0435\u0447\u0430\u0435\u0442\u0441\u044f \"Ansi ESC Code\" - \u0432\u044b\u0432\u043e\u0434\u0438\u043c \u0441\u0430\u043c\u0438\n\t\t\t\t\tTODO(\"Non-CSI codes, like as BEL, BS, CR, LF, FF, TAB, VT, SO, SI\");\n\t\t\t\t\tif (*pch == ESC /*|| *pch == BEL*/ /*|| *pch == ENQ*/)\n\t\t\t\t\t{\n\t\t\t\t\t\tlbRc = pObj->WriteAnsiCodes(F(WriteConsoleW), hConsoleOutput, static_cast<const wchar_t*>(lpBuffer), nNumberOfCharsToWrite, lpNumberOfCharsWritten);\n\t\t\t\t\t\tgoto ansidone;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!bIsAnsi || ((pObj = CEAnsi::Object()) == nullptr))\n\t{\n\t\tlbRc = F(WriteConsoleW)(hConsoleOutput, lpBuffer, nNumberOfCharsToWrite, lpNumberOfCharsWritten, lpReserved);\n\t}\n\telse\n\t{\n\t\tlbRc = pObj->WriteText(F(WriteConsoleW), hConsoleOutput, static_cast<LPCWSTR>(lpBuffer), nNumberOfCharsToWrite, lpNumberOfCharsWritten, TRUE);\n\t\t//wrt.Flags = ewtf_Current|ewtf_Commit;\n\t\t//wrt.Buffer = (const wchar_t*)lpBuffer;\n\t\t//wrt.NumberOfCharsToWrite = nNumberOfCharsToWrite;\n\t\t//wrt.Private = F(WriteConsoleW);\n\t\t//lbRc = ExtWriteText(&wrt);\n\t\t//if (lbRc)\n\t\t//{\n\t\t//\tif (lpNumberOfCharsWritten)\n\t\t//\t\t*lpNumberOfCharsWritten = wrt.NumberOfCharsWritten;\n\t\t//\tif (wrt.ScrolledRowsUp > 0)\n\t\t//\t\tgDisplayCursor.StoredCursorPos.Y = std::max(0,((int)gDisplayCursor.StoredCursorPos.Y - (int)wrt.ScrolledRowsUp));\n\t\t//}\n\t}\n\tgoto wrap;\n\nansidone:\n\t{\n\t\tExtCommitParm cmt = {sizeof(cmt), hConsoleOutput};\n\t\tExtCommit(&cmt);\n\t}\nwrap:\n\treturn lbRc;\n}\n\n//struct AnsiEscCode\n//{\n//\twchar_t  First;  // ESC (27)\n//\twchar_t  Second; // any of 64 to 95 ('@' to '_')\n//\twchar_t  Action; // any of 64 to 126 (@ to ~). this is terminator\n//\twchar_t  Skip;   // \u0415\u0441\u043b\u0438 !=0 - \u0442\u043e \u044d\u0442\u0443 \u043f\u043e\u0441\u043b\u0435\u0434\u043e\u0432\u0430\u0442\u0435\u043b\u044c\u043d\u043e\u0441\u0442\u044c \u043d\u0443\u0436\u043d\u043e \u043f\u0440\u043e\u043f\u0443\u0441\u0442\u0438\u0442\u044c\n//\tint      ArgC;\n//\tint      ArgV[16];\n//\tLPCWSTR  ArgSZ; // Reserved for key mapping\n//\tsize_t   cchArgSZ;\n//\n//#ifdef _DEBUG\n//\tLPCWSTR  pszEscStart;\n//\tsize_t   nTotalLen;\n//#endif\n//\n//\tint      PvtLen;\n//\twchar_t  Pvt[16];\n//};\n\n\n// 0 - \u043d\u0435\u0442 (\u0432 lpBuffer \u0442\u043e\u043b\u044c\u043a\u043e \u0442\u0435\u043a\u0441\u0442)\n// 1 - \u0432 Code \u043f\u043e\u043c\u0435\u0449\u0435\u043d\u0430 Esc \u043f\u043e\u0441\u043b\u0435\u0434\u043e\u0432\u0430\u0442\u0435\u043b\u044c\u043d\u043e\u0441\u0442\u044c (\u043c\u043e\u0436\u0435\u0442 \u0431\u044b\u0442\u044c \u043f\u0440\u043e\u0441\u0442\u043e\u0439 \u0442\u0435\u043a\u0441\u0442 \u0414\u041e \u043d\u0435\u0435)\n// 2 - \u043d\u0435\u0442, \u043d\u043e \u043a\u0443\u0441\u043e\u043a \u043f\u043e\u0441\u043b\u0435\u0434\u043e\u0432\u0430\u0442\u0435\u043b\u044c\u043d\u043e\u0441\u0442\u0438 \u0441\u043e\u0445\u0440\u0430\u043d\u0435\u043d \u0432 gsPrevAnsiPart\nint CEAnsi::NextEscCode(LPCWSTR lpBuffer, LPCWSTR lpEnd, wchar_t (&szPreDump)[CEAnsi_MaxPrevPart], DWORD& cchPrevPart, LPCWSTR& lpStart, LPCWSTR& lpNext, CEAnsi::AnsiEscCode& Code, BOOL ReEntrance /*= FALSE*/)\n{\n\tint iRc = 0;\n\twchar_t wc;\n\n\tLPCWSTR lpSaveStart = lpBuffer;\n\tlpStart = lpBuffer;\n\n\t_ASSERTEX(cchPrevPart==0);\n\n\tif (gnPrevAnsiPart && !ReEntrance)\n\t{\n\t\tif (*gsPrevAnsiPart == 27)\n\t\t{\n\t\t\t_ASSERTEX(gnPrevAnsiPart < 79);\n\t\t\tconst INT_PTR nCurPrevLen = gnPrevAnsiPart;\n\t\t\tconst INT_PTR nAdd = std::min((lpEnd-lpBuffer),static_cast<INT_PTR>(countof(gsPrevAnsiPart))-nCurPrevLen-1);\n\t\t\t// Need to check buffer overflow!!!\n\t\t\t_ASSERTEX(static_cast<INT_PTR>(countof(gsPrevAnsiPart)) > (nCurPrevLen + nAdd));\n\t\t\twmemcpy(gsPrevAnsiPart+nCurPrevLen, lpBuffer, nAdd);\n\t\t\tgsPrevAnsiPart[nCurPrevLen+nAdd] = 0;\n\n\t\t\tWARNING(\"\u041f\u0440\u043e\u0432\u0435\u0440\u0438\u0442\u044c!!!\");\n\t\t\tLPCWSTR lpReStart, lpReNext;\n\t\t\tconst int iCall = NextEscCode(gsPrevAnsiPart, gsPrevAnsiPart + nAdd + gnPrevAnsiPart, szPreDump, cchPrevPart, lpReStart, lpReNext, Code, TRUE);\n\t\t\tif (iCall == 1)\n\t\t\t{\n\t\t\t\tif ((lpReNext - gsPrevAnsiPart) >= gnPrevAnsiPart)\n\t\t\t\t{\n\t\t\t\t\t// Bypass unrecognized ESC sequences to screen?\n\t\t\t\t\tif (lpReStart > gsPrevAnsiPart)\n\t\t\t\t\t{\n\t\t\t\t\t\tconst INT_PTR nSkipLen = (lpReStart - gsPrevAnsiPart); //DWORD nWritten;\n\t\t\t\t\t\t_ASSERTEX(nSkipLen > 0 && nSkipLen <= static_cast<INT_PTR>(countof(gsPrevAnsiPart)) && nSkipLen <= gnPrevAnsiPart);\n\t\t\t\t\t\tDumpUnknownEscape(gsPrevAnsiPart, nSkipLen);\n\n\t\t\t\t\t\t//WriteText(writeConsoleW, hConsoleOutput, gsPrevAnsiPart, nSkipLen, &nWritten);\n\t\t\t\t\t\t_ASSERTEX(nSkipLen <= (static_cast<int>(CEAnsi_MaxPrevPart) - static_cast<int>(cchPrevPart)));\n\t\t\t\t\t\tmemmove(szPreDump, gsPrevAnsiPart, nSkipLen);\n\t\t\t\t\t\tcchPrevPart += static_cast<int>(nSkipLen);\n\n\t\t\t\t\t\tif (nSkipLen < gnPrevAnsiPart)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tmemmove(gsPrevAnsiPart, lpReStart, (gnPrevAnsiPart - nSkipLen)*sizeof(*gsPrevAnsiPart));\n\t\t\t\t\t\t\tgnPrevAnsiPart -= nSkipLen;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t_ASSERTEX(nSkipLen == gnPrevAnsiPart);\n\t\t\t\t\t\t\t*gsPrevAnsiPart = 0;\n\t\t\t\t\t\t\tgnPrevAnsiPart = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlpReStart = gsPrevAnsiPart;\n\t\t\t\t\t}\n\t\t\t\t\t_ASSERTEX(lpReStart == gsPrevAnsiPart);\n\t\t\t\t\tlpStart = lpBuffer; // nothing to dump before Esc-sequence\n\t\t\t\t\t_ASSERTEX((lpReNext - gsPrevAnsiPart) >= gnPrevAnsiPart);\n\t\t\t\t\tWARNING(\"\u041f\u0440\u043e\u0432\u0435\u0440\u0438\u0442\u044c!!!\");\n\t\t\t\t\tlpNext = lpBuffer + (lpReNext - gsPrevAnsiPart - gnPrevAnsiPart);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t_ASSERTEX((lpReNext - gsPrevAnsiPart) >= gnPrevAnsiPart);\n\t\t\t\t\tlpStart = lpNext = lpBuffer;\n\t\t\t\t}\n\t\t\t\tgnPrevAnsiPart = 0;\n\t\t\t\tgsPrevAnsiPart[0] = 0;\n\t\t\t\tiRc = 1;\n\t\t\t\tgoto wrap2;\n\t\t\t}\n\t\t\telse if (iCall == 2)\n\t\t\t{\n\t\t\t\tgnPrevAnsiPart = nCurPrevLen+nAdd;\n\t\t\t\t_ASSERTEX(gsPrevAnsiPart[nCurPrevLen+nAdd] == 0);\n\t\t\t\tiRc = 2;\n\t\t\t\tgoto wrap;\n\t\t\t}\n\n\t\t\t_ASSERTEX((iCall == 1) && \"Invalid esc sequence, need dump to screen?\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\t_ASSERTEX(*gsPrevAnsiPart == 27);\n\t\t}\n\t}\n\n\n\twhile (lpBuffer < lpEnd)\n\t{\n\t\tswitch (*lpBuffer)\n\t\t{\n\t\tcase 27:\n\t\t\t{\n\t\t\t\tINT_PTR nLeft;\n\t\t\t\t// ReSharper disable once CppLocalVariableMayBeConst\n\t\t\t\tLPCWSTR lpEscStart = lpBuffer;\n\n\t\t\t\t#ifdef _DEBUG\n\t\t\t\tCode.pszEscStart = lpBuffer;\n\t\t\t\tCode.nTotalLen = 0;\n\t\t\t\t#endif\n\n\t\t\t\t// Special one char codes? Like \"ESC 7\" and so on...\n\t\t\t\tif ((lpBuffer + 1) < lpEnd)\n\t\t\t\t{\n\t\t\t\t\t// But it may be some \"special\" codes\n\t\t\t\t\tswitch (lpBuffer[1])\n\t\t\t\t\t{\n\t\t\t\t\tcase L'7': // Save xterm cursor\n\t\t\t\t\tcase L'8': // Restore xterm cursor\n\t\t\t\t\tcase L'c': // Full reset\n\t\t\t\t\tcase L'g': // Visual Bell\n\t\t\t\t\tcase L'=':\n\t\t\t\t\tcase L'>':\n\t\t\t\t\tcase L'H': // Horizontal Tab Set\n\t\t\t\t\tcase L'M': // Reverse LF\n\t\t\t\t\tcase L'E': // CR-LF\n\t\t\t\t\tcase L'D': // LF\n\t\t\t\t\t\t// xterm?\n\t\t\t\t\t\tlpStart = lpEscStart;\n\t\t\t\t\t\tCode.First = 27;\n\t\t\t\t\t\tCode.Second = *(++lpBuffer);\n\t\t\t\t\t\tCode.ArgC = 0;\n\t\t\t\t\t\tCode.PvtLen = 0;\n\t\t\t\t\t\tCode.Pvt[0] = 0;\n\t\t\t\t\t\tlpEnd = (++lpBuffer);\n\t\t\t\t\t\tiRc = 1;\n\t\t\t\t\t\tgoto wrap;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// If tail is larger than 2 chars, continue\n\t\t\t\tif ((lpBuffer + 2) < lpEnd)\n\t\t\t\t{\n\t\t\t\t\t// Set lpSaveStart to current start of Esc sequence, it was set to beginning of buffer\n\t\t\t\t\t_ASSERTEX(lpSaveStart <= lpBuffer);\n\t\t\t\t\tlpSaveStart = lpBuffer;\n\t\t\t\t\t_ASSERTEX(lpSaveStart == lpEscStart);\n\n\t\t\t\t\tCode.First = 27;\n\t\t\t\t\tCode.Second = *(++lpBuffer);\n\t\t\t\t\tCode.ArgC = 0;\n\t\t\t\t\tCode.PvtLen = 0;\n\t\t\t\t\tCode.Pvt[0] = 0;\n\n\t\t\t\t\tTODO(\"Bypass unrecognized ESC sequences to screen? Don't try to eliminate 'Possible' sequences?\");\n\t\t\t\t\t//if (((Code.Second < 64) || (Code.Second > 95)) && (Code.Second != 124/* '|' - vim-xterm-emulation */))\n\t\t\t\t\tif (!wcschr(L\"[]|()%\", Code.Second))\n\t\t\t\t\t{\n\t\t\t\t\t\t// Don't assert on rawdump of KeyEvents.exe Esc key presses\n\t\t\t\t\t\t// 10:00:00 KEY_EVENT_RECORD: Dn, 1, Vk=\"VK_ESCAPE\" [27/0x001B], Scan=0x0001 uChar=[U='\\x1b' (0x001B): A='\\x1b' (0x1B)]\n\t\t\t\t\t\tconst bool bStandaloneEscChar = (lpStart < lpSaveStart) && ((*(lpSaveStart - 1) == L'\\'' && Code.Second == L'\\'') || (*(lpSaveStart - 1) == L' ' && Code.Second == L' '));\n\t\t\t\t\t\t//_ASSERTEX(bStandaloneEscChar && \"Unsupported control sequence?\");\n\t\t\t\t\t\tif (!bStandaloneEscChar)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, std::min<size_t>(Code.nTotalLen, 32), de_UnkControl);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue; // invalid code\n\t\t\t\t\t}\n\n\t\t\t\t\t// Now parameters go\n\t\t\t\t\t++lpBuffer; // move pointer to the first char beyond CSI (after '[')\n\n\t\t\t\t\tauto parseNumArgs = [&Code](const wchar_t* &lpBufferParam, const wchar_t* lpSeqEnd, bool saveAction) -> bool\n\t\t\t\t\t{\n\t\t\t\t\t\twchar_t wcSave;\n\t\t\t\t\t\tint nValue = 0, nDigits = 0;\n\t\t\t\t\t\tCode.ArgC = 0;\n\n\t\t\t\t\t\twhile (lpBufferParam < lpSeqEnd)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tswitch (*lpBufferParam)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcase L'0': case L'1': case L'2': case L'3': case L'4':\n\t\t\t\t\t\t\tcase L'5': case L'6': case L'7': case L'8': case L'9':\n\t\t\t\t\t\t\t\tnValue = (nValue * 10) + (static_cast<int>(*lpBufferParam) - L'0');\n\t\t\t\t\t\t\t\t++nDigits;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase L';':\n\t\t\t\t\t\t\t\t// Even if there were no digits - default is \"0\"\n\t\t\t\t\t\t\t\tif (Code.ArgC < static_cast<int>(countof(Code.ArgV)))\n\t\t\t\t\t\t\t\t\tCode.ArgV[Code.ArgC++] = nValue; // save argument\n\t\t\t\t\t\t\t\tnDigits = nValue = 0;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tif (Code.Second == L']')\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t// OSC specific, stop on first non-digit/non-semicolon\n\t\t\t\t\t\t\t\t\tif (nDigits && (Code.ArgC < static_cast<int>(countof(Code.ArgV))))\n\t\t\t\t\t\t\t\t\t\tCode.ArgV[Code.ArgC++] = nValue;\n\t\t\t\t\t\t\t\t\treturn (Code.ArgC > 0);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (((wcSave = *lpBufferParam) >= 64) && (wcSave <= 126))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t// Fin\n\t\t\t\t\t\t\t\t\tif (saveAction)\n\t\t\t\t\t\t\t\t\t\tCode.Action = wcSave;\n\t\t\t\t\t\t\t\t\tif (nDigits && (Code.ArgC < static_cast<int>(countof(Code.ArgV))))\n\t\t\t\t\t\t\t\t\t\tCode.ArgV[Code.ArgC++] = nValue;\n\t\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif ((static_cast<size_t>(Code.PvtLen) + 2) < countof(Code.Pvt))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tCode.Pvt[Code.PvtLen++] = wcSave; // Skip private symbols\n\t\t\t\t\t\t\t\t\tCode.Pvt[Code.PvtLen] = 0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t++lpBufferParam;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (nDigits && (Code.ArgC < static_cast<int>(countof(Code.ArgV))))\n\t\t\t\t\t\t\tCode.ArgV[Code.ArgC++] = nValue;\n\t\t\t\t\t\treturn (Code.Second == L']');\n\t\t\t\t\t};\n\n\t\t\t\t\tswitch (Code.Second)\n\t\t\t\t\t{\n\t\t\t\t\tcase L'(':\n\t\t\t\t\tcase L')':\n\t\t\t\t\tcase L'%':\n\t\t\t\t\t//case L'#':\n\t\t\t\t\t//case L'*':\n\t\t\t\t\t//case L'+':\n\t\t\t\t\t//case L'-':\n\t\t\t\t\t//case L'.':\n\t\t\t\t\t//case L'/':\n\t\t\t\t\t\t// VT G0/G1/G2/G3 character sets\n\t\t\t\t\t\tlpStart = lpSaveStart;\n\t\t\t\t\t\tCode.Action = *(lpBuffer++);\n\t\t\t\t\t\tCode.Skip = 0;\n\t\t\t\t\t\tCode.ArgSZ = nullptr;\n\t\t\t\t\t\tCode.cchArgSZ = 0;\n\t\t\t\t\t\tlpEnd = lpBuffer;\n\t\t\t\t\t\tiRc = 1;\n\t\t\t\t\t\tgoto wrap;\n\t\t\t\t\tcase L'|':\n\t\t\t\t\t\t// vim-xterm-emulation\n\t\t\t\t\tcase L'[':\n\t\t\t\t\t\t// Standard\n\t\t\t\t\t\tCode.Skip = 0;\n\t\t\t\t\t\tCode.ArgSZ = nullptr;\n\t\t\t\t\t\tCode.cchArgSZ = 0;\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t#ifdef _DEBUG\n\t\t\t\t\t\t\t// ReSharper disable once CppDeclaratorNeverUsed\n\t\t\t\t\t\t\tLPCWSTR pszSaveStart = lpBuffer;\n\t\t\t\t\t\t\t#endif\n\n\t\t\t\t\t\t\tif (parseNumArgs(lpBuffer, lpEnd, true))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tlpStart = lpSaveStart;\n\t\t\t\t\t\t\t\tlpEnd = lpBuffer+1;\n\t\t\t\t\t\t\t\tiRc = 1;\n\t\t\t\t\t\t\t\tgoto wrap;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// \u0412 \u0434\u0430\u043d\u043d\u043e\u043c \u0437\u0430\u043f\u0440\u043e\u0441\u0435 (\u043d\u0430 \u0437\u0430\u043f\u0438\u0441\u044c) \u043a\u043e\u043d\u0446\u0430 \u043f\u043e\u0441\u043b\u0435\u0434\u043e\u0432\u0430\u0442\u0435\u043b\u044c\u043d\u043e\u0441\u0442\u0438 \u043d\u0435\u0442,\n\t\t\t\t\t\t// \u043e\u0441\u0442\u0430\u0432\u0448\u0438\u0439\u0441\u044f \u0445\u0432\u043e\u0441\u0442 \u043d\u0443\u0436\u043d\u043e \u0441\u043e\u0445\u0440\u0430\u043d\u0438\u0442\u044c \u0432 \u0431\u0443\u0444\u0435\u0440\u0435, \u0434\u043b\u044f \u0441\u043b\u0435\u0434\u0443\u044e\u0449\u0435\u0433\u043e \u0437\u0430\u043f\u0440\u043e\u0441\u0430\n\t\t\t\t\t\t// \u041d\u0438\u0436\u0435\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase L']':\n\t\t\t\t\t\t// Finalizing (ST) with \"\\x1B\\\\\" or \"\\x07\"\n\t\t\t\t\t\t// \"%]4;16;rgb:00/00/00%\\\" - \"%\" is ESC\n\t\t\t\t\t\t// \"%]0;this is the window titleBEL\"\n\t\t\t\t\t\t// ESC ] 0 ; txt ST        Set icon name and window title to txt.\n\t\t\t\t\t\t// ESC ] 1 ; txt ST        Set icon name to txt.\n\t\t\t\t\t\t// ESC ] 2 ; txt ST        Set window title to txt.\n\t\t\t\t\t\t// ESC ] 4 ; num; txt ST   Set ANSI color num to txt.\n\t\t\t\t\t\t// ESC ] 10 ; txt ST       Set dynamic text color to txt.\n\t\t\t\t\t\t// ESC ] 4 6 ; name ST     Change log file to name (normally disabled\n\t\t\t\t\t\t//\t\t\t\t\t       by a compile-time option)\n\t\t\t\t\t\t// ESC ] 5 0 ; fn ST       Set font to fn.\n\t\t\t\t\t\t//Following 2 codes - from linux terminal\n\t\t\t\t\t\t// ESC ] P nrrggbb         Set palette, with parameter given in 7\n                        //                         hexadecimal digits after the final P :-(.\n\t\t\t\t\t\t//                         Here n is the color (0-15), and rrggbb indicates\n\t\t\t\t\t\t//                         the red/green/blue values (0-255).\n\t\t\t\t\t\t// ESC ] R                 reset palette\n\n\t\t\t\t\t\t// ConEmu specific\n\t\t\t\t\t\t// ESC ] 9 ; 1 ; ms ST           Sleep. ms - milliseconds\n\t\t\t\t\t\t// ESC ] 9 ; 2 ; \"txt\" ST        Show GUI MessageBox ( txt ) for dubug purposes\n\t\t\t\t\t\t// ESC ] 9 ; 3 ; \"txt\" ST        Set TAB text\n\t\t\t\t\t\t// ESC ] 9 ; 4 ; st ; pr ST      When _st_ is 0: remove progress. When _st_ is 1: set progress value to _pr_ (number, 0-100). When _st_ is 2: set error state in progress on Windows 7 taskbar\n\t\t\t\t\t\t// ESC ] 9 ; 5 ST                Wait for ENTER/SPACE/ESC. Set EnvVar \"ConEmuWaitKey\" to ENTER/SPACE/ESC on exit.\n\t\t\t\t\t\t// ESC ] 9 ; 6 ; \"txt\" ST        Execute GuiMacro. Set EnvVar \"ConEmuMacroResult\" on exit.\n\t\t\t\t\t\t// and others... look at CEAnsi::WriteAnsiCode_OSC\n\n\t\t\t\t\t\tCode.ArgSZ = lpBuffer;\n\t\t\t\t\t\tCode.cchArgSZ = 0;\n\t\t\t\t\t\t//Code.Skip = Code.Second;\n\n\t\t\t\t\t\twhile (lpBuffer < lpEnd)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif ((lpBuffer[0] == 7) ||\n\t\t\t\t\t\t\t\t(lpBuffer[0] == 27) /* we'll check the proper terminator below */)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tCode.Action = *Code.ArgSZ; // \u043f\u0435\u0440\u0432\u044b\u0439 \u0441\u0438\u043c\u0432\u043e\u043b \u043f\u043e\u0441\u043b\u0435\u0434\u043e\u0432\u0430\u0442\u0435\u043b\u044c\u043d\u043e\u0441\u0442\u0438\n\t\t\t\t\t\t\t\tCode.cchArgSZ = (lpBuffer - Code.ArgSZ);\n\t\t\t\t\t\t\t\tlpStart = lpSaveStart;\n\t\t\t\t\t\t\t\tconst wchar_t* lpBufferPtr = Code.ArgSZ;\n\t\t\t\t\t\t\t\tif (lpBuffer[0] == 27)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tif ((lpBuffer + 1) >= lpEnd)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t// Sequence is not complete yet!\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse if (lpBuffer[1] == L'\\\\')\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tlpEnd = lpBuffer + 2;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tlpEnd = lpBuffer - 1;\n\t\t\t\t\t\t\t\t\t\t_ASSERTE(*(lpEnd+1) == 27);\n\t\t\t\t\t\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t\t\t\t\t\t\t\t\tiRc = 0;\n\t\t\t\t\t\t\t\t\t\tgoto wrap;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tlpEnd = lpBuffer + 1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tparseNumArgs(lpBufferPtr, lpBuffer, false);\n\t\t\t\t\t\t\t\tiRc = 1;\n\t\t\t\t\t\t\t\tgoto wrap;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t++lpBuffer;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Sequence is not complete, we have to store it to concatenate\n\t\t\t\t\t\t// and check on future write call. Below.\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t// Unknown sequence, use common termination rules\n\t\t\t\t\t\tCode.Skip = Code.Second;\n\t\t\t\t\t\tCode.ArgSZ = lpBuffer;\n\t\t\t\t\t\tCode.cchArgSZ = 0;\n\t\t\t\t\t\twhile (lpBuffer < lpEnd)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// Terminator ASCII symbol: from `@` to `~`\n\t\t\t\t\t\t\tif (((wc = *lpBuffer) >= 64) && (wc <= 126))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tCode.Action = wc;\n\t\t\t\t\t\t\t\tlpStart = lpSaveStart;\n\t\t\t\t\t\t\t\tlpEnd = lpBuffer+1;\n\t\t\t\t\t\t\t\tiRc = 1;\n\t\t\t\t\t\t\t\tgoto wrap;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t++lpBuffer;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} // end of \"switch (Code.Second)\"\n\t\t\t\t} // end of minimal length check\n\n\t\t\t\tif ((nLeft = (lpEnd - lpEscStart)) <= CEAnsi_MaxPrevAnsiPart)\n\t\t\t\t{\n\t\t\t\t\tif (ReEntrance)\n\t\t\t\t\t{\n\t\t\t\t\t\t//_ASSERTEX(!ReEntrance && \"Need to be checked!\"); -- seems to be OK\n\n\t\t\t\t\t\t// gsPrevAnsiPart2 stored for debug purposes only (fully excess)\n\t\t\t\t\t\twmemmove(gsPrevAnsiPart2, lpEscStart, nLeft);\n\t\t\t\t\t\tgsPrevAnsiPart2[nLeft] = 0;\n\t\t\t\t\t\tgnPrevAnsiPart2 = nLeft;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\twmemmove(gsPrevAnsiPart, lpEscStart, nLeft);\n\t\t\t\t\t\tgsPrevAnsiPart[nLeft] = 0;\n\t\t\t\t\t\tgnPrevAnsiPart = nLeft;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t_ASSERTEX(FALSE && \"Too long Esc-sequence part, Need to be checked!\");\n\t\t\t\t}\n\n\t\t\t\tlpStart = lpEscStart;\n\n\t\t\t\tiRc = 2;\n\t\t\t\tgoto wrap;\n\t\t\t} // end of \"case 27:\"\n\t\t} // end of \"switch (*lpBuffer)\"\n\n\t\t++lpBuffer;\n\t} // end of \"while (lpBuffer < lpEnd)\"\n\nwrap:\n\tlpNext = lpEnd;\n\n\t#ifdef _DEBUG\n\tif (iRc == 1)\n\t\tCode.nTotalLen = (lpEnd - Code.pszEscStart);\n\t#endif\nwrap2:\n\t_ASSERTEX((iRc==0) || (lpStart>=lpSaveStart && lpStart<lpEnd));\n\treturn iRc;\n}\n\n// From the cursor position!\nBOOL CEAnsi::ScrollLine(HANDLE hConsoleOutput, int nDir)\n{\n\tExtScrollScreenParm scroll = {sizeof(scroll), essf_Current|essf_Commit, hConsoleOutput, nDir, {}, L' ', {}};\n\tconst BOOL lbRc = ExtScrollLine(&scroll);\n\treturn lbRc;\n}\n\nBOOL CEAnsi::ScrollScreen(HANDLE hConsoleOutput, const int nDir) const\n{\n\tauto srView = GetWorkingRegion(hConsoleOutput, true);\n\n\tif (gDisplayOpt.ScrollRegion)\n\t{\n\t\t_ASSERTEX(gDisplayOpt.ScrollStart >= 0 && gDisplayOpt.ScrollEnd >= gDisplayOpt.ScrollStart);\n\t\tsrView.Top = gDisplayOpt.ScrollStart;\n\t\tsrView.Bottom = gDisplayOpt.ScrollEnd;\n\t}\n\n\treturn ScrollScreen(hConsoleOutput, nDir, false , srView);\n}\n\nBOOL CEAnsi::ScrollScreen(HANDLE hConsoleOutput, const int nDir, bool global, const SMALL_RECT& scrollRect) const\n{\n\tExtScrollScreenParm scroll = {\n\t\tsizeof(scroll),\n\t\tessf_Current | essf_Commit | essf_Region | (global ? essf_Global : essf_None),\n\t\thConsoleOutput, nDir, {}, L' ',\n\t\tRECT{ scrollRect.Left, scrollRect.Top, scrollRect.Right, scrollRect.Bottom } };\n\n\tconst BOOL lbRc = ExtScrollScreen(&scroll);\n\n\treturn lbRc;\n}\n\nBOOL CEAnsi::FullReset(HANDLE hConsoleOutput) const\n{\n\tCONSOLE_SCREEN_BUFFER_INFO csbi = {};\n\tif (!GetConsoleScreenBufferInfoCached(hConsoleOutput, &csbi))\n\t\treturn FALSE;\n\n\tReSetDisplayParm(hConsoleOutput, TRUE, TRUE);\n\n\t// Easy way to drop all lines\n\tScrollScreen(hConsoleOutput, -csbi.dwSize.Y);\n\n\t// Reset cursor\n\tSetConsoleCursorPosition(hConsoleOutput, {});\n\n\t//TODO? Saved cursor position?\n\n\treturn TRUE;\n}\n\nBOOL CEAnsi::ForwardLF(HANDLE hConsoleOutput, BOOL& bApply)\n{\n\tCONSOLE_SCREEN_BUFFER_INFO csbi = {};\n\tif (!GetConsoleScreenBufferInfoCached(hConsoleOutput, &csbi))\n\t\treturn FALSE;\n\n\tif (bApply)\n\t{\n\t\tReSetDisplayParm(hConsoleOutput, FALSE, TRUE);\n\t\tbApply = FALSE;\n\t}\n\n\tif (csbi.dwCursorPosition.Y == (csbi.dwSize.Y - 1))\n\t{\n\t\tWriteText(pfnWriteConsoleW, hConsoleOutput, L\"\\n\", 1, nullptr);\n\t\tSetConsoleCursorPosition(hConsoleOutput, csbi.dwCursorPosition);\n\t}\n\telse if (csbi.dwCursorPosition.Y < (csbi.dwSize.Y - 1))\n\t{\n\t\tconst COORD cr = {csbi.dwCursorPosition.X, static_cast<SHORT>(csbi.dwCursorPosition.Y + 1)};\n\t\tSetConsoleCursorPosition(hConsoleOutput, cr);\n\t\tif (cr.Y > csbi.srWindow.Bottom)\n\t\t{\n\t\t\tSMALL_RECT rcNew = csbi.srWindow;\n\t\t\trcNew.Bottom = cr.Y;\n\t\t\trcNew.Top = cr.Y - (csbi.srWindow.Bottom - csbi.srWindow.Top);\n\t\t\t_ASSERTE(rcNew.Top >= 0);\n\t\t\tSetConsoleWindowInfo(hConsoleOutput, TRUE, &rcNew);\n\t\t}\n\t}\n\telse\n\t{\n\t\t_ASSERTE(csbi.dwCursorPosition.Y > 0);\n\t}\n\n\treturn TRUE;\n}\n\nBOOL CEAnsi::ReverseLF(HANDLE hConsoleOutput, BOOL& bApply) const\n{\n\tCONSOLE_SCREEN_BUFFER_INFO csbi = {};\n\tif (!GetConsoleScreenBufferInfoCached(hConsoleOutput, &csbi))\n\t\treturn FALSE;\n\n\tif (bApply)\n\t{\n\t\tReSetDisplayParm(hConsoleOutput, FALSE, TRUE);\n\t\tbApply = FALSE;\n\t}\n\n\tif ((csbi.dwCursorPosition.Y == csbi.srWindow.Top)\n\t\t|| (gDisplayOpt.ScrollRegion && csbi.dwCursorPosition.Y == gDisplayOpt.ScrollStart))\n\t{\n\t\tLinesInsert(hConsoleOutput, 1);\n\t}\n\telse if (csbi.dwCursorPosition.Y > 0)\n\t{\n\t\tconst COORD cr = {csbi.dwCursorPosition.X, static_cast<SHORT>(csbi.dwCursorPosition.Y - 1)};\n\t\tSetConsoleCursorPosition(hConsoleOutput, cr);\n\t}\n\telse\n\t{\n\t\t_ASSERTE(csbi.dwCursorPosition.Y > 0);\n\t}\n\n\treturn TRUE;\n}\n\nBOOL CEAnsi::LinesInsert(HANDLE hConsoleOutput, const unsigned linesCount) const\n{\n\tCONSOLE_SCREEN_BUFFER_INFO csbi = {};\n\tif (!GetConsoleScreenBufferInfoCached(hConsoleOutput, &csbi))\n\t{\n\t\t_ASSERTEX(FALSE && \"GetConsoleScreenBufferInfoCached failed\");\n\t\treturn FALSE;\n\t}\n\n\t// Apply default color before scrolling!\n\tReSetDisplayParm(hConsoleOutput, FALSE, TRUE);\n\n\tif (static_cast<int>(linesCount) <= 0)\n\t{\n\t\t_ASSERTEX(static_cast<int>(linesCount) >= 0);\n\t\treturn FALSE;\n\t}\n\n\tBOOL lbRc = FALSE;\n\n\tint TopLine, BottomLine;\n\tif (gDisplayOpt.ScrollRegion)\n\t{\n\t\t_ASSERTEX(gDisplayOpt.ScrollStart>=0 && gDisplayOpt.ScrollEnd>=gDisplayOpt.ScrollStart);\n\t\tif (csbi.dwCursorPosition.Y < gDisplayOpt.ScrollStart || csbi.dwCursorPosition.Y > gDisplayOpt.ScrollEnd)\n\t\t\treturn TRUE;\n\t\tTopLine = csbi.dwCursorPosition.Y;\n\t\tBottomLine = std::max<int>(gDisplayOpt.ScrollEnd, 0);\n\n\t\tif (static_cast<int>(linesCount) <= (BottomLine - TopLine))\n\t\t{\n\t\t\tExtScrollScreenParm scroll = {\n\t\t\t\tsizeof(scroll), essf_Current|essf_Commit|essf_Region, hConsoleOutput,\n\t\t\t\tstatic_cast<int>(linesCount), {}, L' ',\n\t\t\t\t// region to be scrolled (that is not a clipping region)\n\t\t\t\t{0, TopLine, csbi.dwSize.X - 1, BottomLine}};\n\t\t\tlbRc |= ExtScrollScreen(&scroll);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tExtFillOutputParm fill = {\n\t\t\t\tsizeof(fill), efof_Attribute|efof_Character, hConsoleOutput,\n\t\t\t\t{}, L' ', {0, MakeShort(TopLine)}, csbi.dwSize.X * linesCount};\n\t\t\tlbRc |= ExtFillOutput(&fill);\n\t\t}\n\t}\n\telse\n\t{\n\t\t// What we need to scroll? Buffer or visible rect?\n\t\tTopLine = csbi.dwCursorPosition.Y;\n\t\tBottomLine = (csbi.dwCursorPosition.Y <= csbi.srWindow.Bottom)\n\t\t\t? csbi.srWindow.Bottom\n\t\t\t: csbi.dwSize.Y - 1;\n\n\t\tExtScrollScreenParm scroll = {\n\t\t\tsizeof(scroll), essf_Current|essf_Commit|essf_Region, hConsoleOutput,\n\t\t\tstatic_cast<int>(linesCount), {}, L' ', {0, TopLine, csbi.dwSize.X-1, BottomLine}};\n\t\tlbRc |= ExtScrollScreen(&scroll);\n\t}\n\n\treturn lbRc;\n}\n\nBOOL CEAnsi::LinesDelete(HANDLE hConsoleOutput, const unsigned linesCount)\n{\n\tCONSOLE_SCREEN_BUFFER_INFO csbi = {};\n\tif (!GetConsoleScreenBufferInfoCached(hConsoleOutput, &csbi))\n\t{\n\t\t_ASSERTEX(FALSE && \"GetConsoleScreenBufferInfoCached failed\");\n\t\treturn FALSE;\n\t}\n\n\t// Apply default color before scrolling!\n\tReSetDisplayParm(hConsoleOutput, FALSE, TRUE);\n\n\tBOOL lbRc = FALSE;\n\n\tint TopLine, BottomLine;\n\tif (gDisplayOpt.ScrollRegion)\n\t{\n\t\t_ASSERTEX(gDisplayOpt.ScrollStart>=0 && gDisplayOpt.ScrollEnd>gDisplayOpt.ScrollStart);\n\t\t// ScrollStart & ScrollEnd are 0-based absolute line indexes\n\t\t// relative to VISIBLE area, these are not absolute buffer coords\n\t\tif (((csbi.dwCursorPosition.Y + static_cast<int>(linesCount)) <= gDisplayOpt.ScrollStart)\n\t\t\t|| (csbi.dwCursorPosition.Y > gDisplayOpt.ScrollEnd))\n\t\t{\n\t\t\treturn TRUE; // Nothing to scroll\n\t\t}\n\t\tTopLine = csbi.dwCursorPosition.Y;\n\t\tBottomLine = gDisplayOpt.ScrollEnd;\n\n\t\tconst int negateLinesCount = -static_cast<int>(linesCount);\n\t\tExtScrollScreenParm scrl = {\n\t\t\tsizeof(scrl), essf_Current | essf_Commit | essf_Region, hConsoleOutput,\n\t\t\tnegateLinesCount, {}, L' ', {0, TopLine, csbi.dwSize.X - 1, BottomLine} };\n\t\tif (scrl.Region.top < gDisplayOpt.ScrollStart)\n\t\t{\n\t\t\tscrl.Region.top = gDisplayOpt.ScrollStart;\n\t\t\tscrl.Dir += (gDisplayOpt.ScrollStart - TopLine);\n\t\t}\n\t\tif ((scrl.Dir < 0) && (scrl.Region.top <= scrl.Region.bottom))\n\t\t{\n\t\t\tlbRc |= ExtScrollScreen(&scrl);\n\t\t}\n\t}\n\telse\n\t{\n\t\t// What we need to scroll? Buffer or visible rect?\n\t\tTopLine = csbi.dwCursorPosition.Y;\n\t\tBottomLine = (csbi.dwCursorPosition.Y <= csbi.srWindow.Bottom)\n\t\t\t? csbi.srWindow.Bottom\n\t\t\t: csbi.dwSize.Y - 1;\n\n\t\tif (BottomLine < TopLine)\n\t\t{\n\t\t\t_ASSERTEX(FALSE && \"Invalid (empty) scroll region\");\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tconst int negateLinesCount = -static_cast<int>(linesCount);\n\t\tExtScrollScreenParm scrl = {\n\t\t\tsizeof(scrl), essf_Current | essf_Commit | essf_Region, hConsoleOutput,\n\t\t\tnegateLinesCount, {}, L' ', {0, TopLine, csbi.dwSize.X - 1, BottomLine} };\n\t\tlbRc |= ExtScrollScreen(&scrl);\n\t}\n\n\treturn lbRc;\n}\n\nint CEAnsi::NextNumber(LPCWSTR& asMS)\n{\n\twchar_t wc;\n\tint ms = 0;\n\twhile (((wc = *(asMS++)) >= L'0') && (wc <= L'9'))\n\t\tms = (ms * 10) + static_cast<int>(wc - L'0');\n\treturn ms;\n}\n\n// ESC ] 9 ; 1 ; ms ST           Sleep. ms - milliseconds\n// ReSharper disable once CppMemberFunctionMayBeStatic\nvoid CEAnsi::DoSleep(LPCWSTR asMS)\n{\n\tint ms = NextNumber(asMS);\n\tif (!ms)\n\t\tms = 100;\n\telse if (ms > 10000)\n\t\tms = 10000;\n\t// Delay\n\tSleep(ms);\n}\n\nvoid CEAnsi::EscCopyCtrlString(wchar_t* pszDst, LPCWSTR asMsg, INT_PTR cchMaxLen) const\n{\n\tif (!pszDst)\n\t{\n\t\t_ASSERTEX(pszDst!=nullptr);\n\t\treturn;\n\t}\n\n\tif (cchMaxLen < 0)\n\t{\n\t\t_ASSERTEX(cchMaxLen >= 0);\n\t\tcchMaxLen = 0;\n\t}\n\tif (cchMaxLen > 1)\n\t{\n\t\tif ((asMsg[0] == L'\"') && (asMsg[cchMaxLen-1] == L'\"'))\n\t\t{\n\t\t\tasMsg++;\n\t\t\tcchMaxLen -= 2;\n\t\t}\n\t}\n\n\tif (cchMaxLen > 0)\n\t\twmemmove(pszDst, asMsg, cchMaxLen);\n\tpszDst[std::max<ssize_t>(cchMaxLen, 0)] = 0;\n}\n\n// ESC ] 9 ; 2 ; \"txt\" ST          Show GUI MessageBox ( txt ) for dubug purposes\nvoid CEAnsi::DoMessage(LPCWSTR asMsg, INT_PTR cchLen) const\n{\n\tCEStr pszText;\n\n\tif (pszText.GetBuffer(cchLen))\n\t{\n\t\tEscCopyCtrlString(pszText.data(), asMsg, cchLen);\n\t\t//if (cchLen > 0)\n\t\t//\twmemmove(pszText, asMsg, cchLen);\n\t\t//pszText[cchLen] = 0;\n\n\t\twchar_t szExe[MAX_PATH] = {};\n\t\tGetModuleFileName(nullptr, szExe, countof(szExe));\n\t\twchar_t szTitle[MAX_PATH+64];\n\t\tmsprintf(szTitle, countof(szTitle), L\"PID=%u, %s\", GetCurrentProcessId(), PointToName(szExe));\n\n\t\tGuiMessageBox(ghConEmuWnd, pszText, szTitle, MB_ICONINFORMATION|MB_SYSTEMMODAL);\n\t}\n}\n\nbool CEAnsi::IsAnsiExecAllowed(LPCWSTR asCmd) const\n{\n\t// Invalid command or macro?\n\tif (!asCmd || !*asCmd)\n\t\treturn false;\n\n\t// We need to check settings\n\tCESERVER_CONSOLE_MAPPING_HDR* pMap = GetConMap();\n\tif (!pMap)\n\t\treturn false;\n\n\tif ((pMap->Flags & ConEmu::ConsoleFlags::AnsiExecAny))\n\t{\n\t\t// Allowed in any process\n\t}\n\telse if ((pMap->Flags & ConEmu::ConsoleFlags::AnsiExecCmd))\n\t{\n\t\t// Allowed in Cmd.exe only\n\t\tif (!gbIsCmdProcess)\n\t\t\treturn false;\n\t}\n\telse\n\t{\n\t\t// Disallowed everywhere\n\t\treturn false;\n\t}\n\n\t// Now we need to ask GUI, if the command (asCmd) is allowed\n\tbool bAllowed = false;\n\tconst INT_PTR cchLen = wcslen(asCmd) + 1;\n\tCESERVER_REQ* pOut = nullptr;\n\tCESERVER_REQ* pIn = ExecuteNewCmd(CECMD_ALLOWANSIEXEC, sizeof(CESERVER_REQ_HDR)+sizeof(wchar_t)*cchLen);\n\n\tif (pIn)\n\t{\n\t\t_ASSERTE(sizeof(pIn->wData[0])==sizeof(*asCmd));\n\t\tmemmove(pIn->wData, asCmd, cchLen*sizeof(pIn->wData[0]));\n\n\t\tpOut = ExecuteGuiCmd(ghConWnd, pIn, ghConWnd);\n\t\tif (pOut && (pOut->DataSize() == sizeof(pOut->dwData[0])))\n\t\t{\n\t\t\tbAllowed = (pOut->dwData[0] == TRUE);\n\t\t}\n\t}\n\n\tExecuteFreeResult(pOut);\n\tExecuteFreeResult(pIn);\n\n\treturn bAllowed;\n}\n\n// ESC ] 9 ; 6 ; \"macro\" ST        Execute some GuiMacro\nvoid CEAnsi::DoGuiMacro(LPCWSTR asCmd, INT_PTR cchLen) const\n{\n\tCESERVER_REQ* pOut = nullptr;\n\tCESERVER_REQ* pIn = ExecuteNewCmd(CECMD_GUIMACRO, sizeof(CESERVER_REQ_HDR)+sizeof(CESERVER_REQ_GUIMACRO)+sizeof(wchar_t)*(cchLen + 1));\n\n\tif (pIn)\n\t{\n\t\tEscCopyCtrlString(pIn->GuiMacro.sMacro, asCmd, cchLen);\n\n\t\tif (IsAnsiExecAllowed(pIn->GuiMacro.sMacro))\n\t\t{\n\t\t\tpOut = ExecuteGuiCmd(ghConWnd, pIn, ghConWnd);\n\t\t}\n\t}\n\n\t// EnvVar \"ConEmuMacroResult\"\n\tSetEnvironmentVariable(CEGUIMACRORETENVVAR, pOut && pOut->GuiMacro.nSucceeded ? pOut->GuiMacro.sMacro : nullptr);\n\n\tExecuteFreeResult(pOut);\n\tExecuteFreeResult(pIn);\n}\n\n// ESC ] 9 ; 7 ; \"cmd\" ST        Run some process with arguments\nvoid CEAnsi::DoProcess(LPCWSTR asCmd, INT_PTR cchLen) const\n{\n\t// We need zero-terminated string\n\tCEStr pszCmdLine;\n\n\tif (pszCmdLine.GetBuffer(cchLen))\n\t{\n\t\tEscCopyCtrlString(pszCmdLine.data(), asCmd, cchLen);\n\n\t\tif (IsAnsiExecAllowed(pszCmdLine))\n\t\t{\n\t\t\tSTARTUPINFO si{};\n\t\t\tsi.cb = sizeof(si);\n\t\t\tPROCESS_INFORMATION pi{};\n\n\t\t\tconst BOOL bCreated = OnCreateProcessW(\n\t\t\t\tnullptr, pszCmdLine.data(), nullptr, nullptr,\n\t\t\t\tFALSE, 0, nullptr, nullptr, &si, &pi);\n\t\t\tif (bCreated)\n\t\t\t{\n\t\t\t\tif (pi.hProcess)\n\t\t\t\t{\n\t\t\t\t\tWaitForSingleObject(pi.hProcess, INFINITE);\n\t\t\t\t\tCloseHandle(pi.hProcess);\n\t\t\t\t}\n\t\t\t\tif (pi.hThread)\n\t\t\t\t{\n\t\t\t\t\tCloseHandle(pi.hThread);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// ESC ] 9 ; 8 ; \"env\" ST        Output value of environment variable\nvoid CEAnsi::DoPrintEnv(LPCWSTR asCmd, INT_PTR cchLen)\n{\n\tif (!pfnWriteConsoleW)\n\t\treturn;\n\n\t// We need zero-terminated string\n\tCEStr pszVarName;\n\n\tif (pszVarName.GetBuffer(cchLen))\n\t{\n\t\tEscCopyCtrlString(pszVarName.data(), asCmd, cchLen);\n\n\t\twchar_t szValue[MAX_PATH];\n\t\twchar_t* pszValue = szValue;\n\t\tCEStr valueBuffer;\n\t\tDWORD cchMax = countof(szValue);\n\t\tDWORD nMax = GetEnvironmentVariable(pszVarName, pszValue, cchMax);\n\n\t\t// Some predefined as `time`, `date`, `cd`, ...\n\t\tif (!nMax)\n\t\t{\n\t\t\tif ((lstrcmpi(pszVarName, L\"date\") == 0)\n\t\t\t\t|| (lstrcmpi(pszVarName, L\"time\") == 0))\n\t\t\t{\n\t\t\t\tSYSTEMTIME st = {}; GetLocalTime(&st);\n\t\t\t\tif (lstrcmpi(pszVarName, L\"date\") == 0)\n\t\t\t\t\tswprintf_c(szValue, L\"%u-%02u-%02u\", st.wYear, st.wMonth, st.wDay);\n\t\t\t\telse\n\t\t\t\t\tswprintf_c(szValue, L\"%u:%02u:%02u.%03u\", st.wHour, st.wMinute, st.wSecond, st.wMilliseconds);\n\t\t\t\tnMax = lstrlen(szValue);\n\t\t\t}\n\t\t\t#if 0\n\t\t\telse if (lstrcmpi(pszVarName, L\"cd\") == 0)\n\t\t\t{\n\t\t\t\t//TODO: If possible\n\t\t\t}\n\t\t\t#endif\n\t\t}\n\n\t\tif (nMax >= cchMax)\n\t\t{\n\t\t\tcchMax = nMax+1;\n\t\t\tpszValue = valueBuffer.GetBuffer(cchMax);\n\t\t\tnMax = pszValue ? GetEnvironmentVariable(pszVarName, szValue, countof(szValue)) : 0;\n\t\t}\n\n\t\tif (nMax)\n\t\t{\n\t\t\tTODO(\"Process here ANSI colors TOO! But now it will be 'reentrance'?\");\n\t\t\tWriteText(pfnWriteConsoleW, mh_WriteOutput, pszValue, nMax, &cchMax);\n\t\t}\n\t}\n}\n\n// ESC ] 9 ; 9 ; \"cwd\" ST        Inform ConEmu about shell current working directory\nvoid CEAnsi::DoSendCWD(LPCWSTR asCmd, INT_PTR cchLen) const\n{\n\t// We need zero-terminated string\n\tCEStr pszCWD;\n\n\tif (pszCWD.GetBuffer(cchLen))\n\t{\n\t\tEscCopyCtrlString(pszCWD.data(), asCmd, cchLen);\n\n\t\t// Sends CECMD_STORECURDIR into RConServer\n\t\tSendCurrentDirectory(ghConWnd, pszCWD);\n\t}\n}\n\n\n// ReSharper disable once CppMemberFunctionMayBeStatic\nBOOL CEAnsi::ReportString(LPCWSTR asRet)\n{\n\tif (!asRet || !*asRet)\n\t\treturn FALSE;\n\tINPUT_RECORD ir[16] = {};\n\tconst size_t nLen = wcslen(asRet);\n\tif (nLen > std::numeric_limits<DWORD>::max())\n\t\treturn false;\n\tINPUT_RECORD* pir = (nLen <= static_cast<int>(countof(ir))) ? ir : static_cast<INPUT_RECORD*>(calloc(nLen, sizeof(INPUT_RECORD)));\n\tif (!pir)\n\t\treturn FALSE;\n\n\tINPUT_RECORD* p = pir;\n\tLPCWSTR pc = asRet;\n\tfor (size_t i = 0; i < nLen; i++, p++, pc++)\n\t{\n\t\tconst char ch = *pc >= 0x20 ? *pc : L' ';\n\t\tp->EventType = KEY_EVENT;\n\t\tp->Event.KeyEvent.bKeyDown = TRUE;\n\t\tp->Event.KeyEvent.wRepeatCount = 1;\n\t\tp->Event.KeyEvent.uChar.UnicodeChar = ch;\n\t}\n\n\tDumpKnownEscape(asRet, nLen, de_Report);\n\n\tDWORD nWritten = 0;\n\t// ReSharper disable once CppLocalVariableMayBeConst\n\tHANDLE hIn = GetStdHandle(STD_INPUT_HANDLE);\n\tconst BOOL bSuccess = WriteConsoleInput(hIn, pir, static_cast<DWORD>(nLen), &nWritten) && (nWritten == nLen);\n\n\tif (pir != ir)\n\t\tfree(pir);\n\treturn bSuccess;\n}\n\nvoid CEAnsi::ReportConsoleTitle()\n{\n\twchar_t sTitle[MAX_PATH*2+6] = L\"\\x1B]l\";\n\twchar_t* p = sTitle+3;\n\t_ASSERTEX(lstrlen(sTitle)==3);\n\n\tconst DWORD nTitle = GetConsoleTitle(sTitle+3, MAX_PATH*2);\n\tp = sTitle + 3 + std::min<DWORD>(nTitle, MAX_PATH*2);\n\t*(p++) = L'\\x1B';\n\t*(p++) = L'\\\\';\n\t*(p) = 0;\n\n\tReportString(sTitle);\n}\n\nvoid CEAnsi::ReportTerminalPixelSize()\n{\n\t// `CSI 4 ; height ; width t`\n\twchar_t szReport[64];\n\tint width = 0, height = 0;\n\tRECT rcWnd = {};\n\tCONSOLE_SCREEN_BUFFER_INFO csbi = {};\n\n\tif (ghConEmuWndDC && GetClientRect(ghConEmuWndDC, &rcWnd))\n\t{\n\t\twidth = RectWidth(rcWnd);\n\t\theight = RectHeight(rcWnd);\n\t}\n\n\tif ((width <= 0 || height <= 0) && ghConWnd && GetClientRect(ghConWnd, &rcWnd))\n\t{\n\t\twidth = RectWidth(rcWnd);\n\t\theight = RectHeight(rcWnd);\n\t}\n\n\tif (width <= 0 || height <= 0)\n\t{\n\t\t_ASSERTE(width > 0 && height > 0);\n\t\t// Both DC and RealConsole windows were failed?\n\t\tif (GetConsoleScreenBufferInfoCached(GetStdHandle(STD_OUTPUT_HANDLE), &csbi))\n\t\t{\n\t\t\tconst int defCharWidth = 8, defCharHeight = 14;\n\t\t\twidth = (csbi.srWindow.Right - csbi.srWindow.Left + 1) * defCharWidth;\n\t\t\theight = (csbi.srWindow.Bottom - csbi.srWindow.Top + 1) * defCharHeight;\n\t\t}\n\t}\n\n\tif (width > 0 && height > 0)\n\t{\n\t\tswprintf_c(szReport, L\"\\x1B[4;%u;%ut\", static_cast<uint32_t>(height), static_cast<uint32_t>(width));\n\t\tReportString(szReport);\n\t}\n}\n\nvoid CEAnsi::ReportTerminalCharSize(HANDLE hConsoleOutput, int code)\n{\n\tCONSOLE_SCREEN_BUFFER_INFO csbi = {};\n\tif (GetConsoleScreenBufferInfoCached(hConsoleOutput, &csbi))\n\t{\n\t\twchar_t sCurInfo[64];\n\t\tmsprintf(sCurInfo, countof(sCurInfo),\n\t\t\tL\"\\x1B[%u;%u;%ut\",\n\t\t\tcode == 18 ? 8 : 9,\n\t\t\tcsbi.srWindow.Bottom-csbi.srWindow.Top+1, csbi.srWindow.Right-csbi.srWindow.Left+1);\n\t\tReportString(sCurInfo);\n\t}\n}\n\nvoid CEAnsi::ReportCursorPosition(HANDLE hConsoleOutput)\n{\n\tCONSOLE_SCREEN_BUFFER_INFO csbi = {};\n\tif (GetConsoleScreenBufferInfoCached(hConsoleOutput, &csbi))\n\t{\n\t\twchar_t sCurInfo[32];\n\t\tmsprintf(sCurInfo, countof(sCurInfo),\n\t\t\tL\"\\x1B[%u;%uR\",\n\t\t\tcsbi.dwCursorPosition.Y-csbi.srWindow.Top+1, csbi.dwCursorPosition.X-csbi.srWindow.Left+1);\n\t\tReportString(sCurInfo);\n\t}\n}\n\nBOOL CEAnsi::WriteAnsiCodes(OnWriteConsoleW_t writeConsoleW, HANDLE hConsoleOutput, LPCWSTR lpBuffer, DWORD nNumberOfCharsToWrite, LPDWORD lpNumberOfCharsWritten)\n{\n\tBOOL lbRc = TRUE, lbApply = FALSE;\n\t// ReSharper disable once CppLocalVariableMayBeConst\n\tLPCWSTR lpEnd = (lpBuffer + nNumberOfCharsToWrite);\n\tAnsiEscCode Code = {};\n\twchar_t szPreDump[CEAnsi_MaxPrevPart];\n\t// ReSharper disable once CppJoinDeclarationAndAssignment\n\tDWORD cchPrevPart;\n\n\tReloadFeatures();\n\n\t// Store this pointer\n\tpfnWriteConsoleW = writeConsoleW;\n\t// Ans current output handle\n\tmh_WriteOutput = hConsoleOutput;\n\n\t//ExtWriteTextParm write = {sizeof(write), ewtf_Current, hConsoleOutput};\n\t//write.Private = writeConsoleW;\n\n\twhile (lpBuffer < lpEnd)\n\t{\n\t\tLPCWSTR lpStart = nullptr, lpNext = nullptr; // Required to be nullptr-initialized\n\n\t\t// '^' is ESC\n\t\t// ^[0;31;47m   $E[31;47m   ^[0m ^[0;1;31;47m  $E[1;31;47m  ^[0m\n\n\t\tcchPrevPart = 0;\n\n\t\tconst int iEsc = NextEscCode(lpBuffer, lpEnd, szPreDump, cchPrevPart, lpStart, lpNext, Code);\n\n\t\tif (cchPrevPart)\n\t\t{\n\t\t\tif (lbApply)\n\t\t\t{\n\t\t\t\tReSetDisplayParm(hConsoleOutput, FALSE, TRUE);\n\t\t\t\tlbApply = FALSE;\n\t\t\t}\n\n\t\t\tlbRc = WriteText(writeConsoleW, hConsoleOutput, szPreDump, cchPrevPart, lpNumberOfCharsWritten);\n\t\t\tif (!lbRc)\n\t\t\t\tgoto wrap;\n\t\t}\n\n\t\tif (iEsc != 0)\n\t\t{\n\t\t\tif (lpStart > lpBuffer)\n\t\t\t{\n\t\t\t\t_ASSERTEX((lpStart-lpBuffer) < static_cast<INT_PTR>(nNumberOfCharsToWrite));\n\n\t\t\t\tif (lbApply)\n\t\t\t\t{\n\t\t\t\t\tReSetDisplayParm(hConsoleOutput, FALSE, TRUE);\n\t\t\t\t\tlbApply = FALSE;\n\t\t\t\t}\n\n\t\t\t\tconst DWORD nWrite = static_cast<DWORD>(lpStart - lpBuffer);\n\t\t\t\t//lbRc = WriteText(writeConsoleW, hConsoleOutput, lpBuffer, nWrite, lpNumberOfCharsWritten);\n\t\t\t\tlbRc = WriteText(writeConsoleW, hConsoleOutput, lpBuffer, nWrite, lpNumberOfCharsWritten, FALSE);\n\t\t\t\tif (!lbRc)\n\t\t\t\t\tgoto wrap;\n\t\t\t\t//write.Buffer = lpBuffer;\n\t\t\t\t//write.NumberOfCharsToWrite = nWrite;\n\t\t\t\t//lbRc = ExtWriteText(&write);\n\t\t\t\t//if (!lbRc)\n\t\t\t\t//\tgoto wrap;\n\t\t\t\t//else\n\t\t\t\t//{\n\t\t\t\t//\tif (lpNumberOfCharsWritten)\n\t\t\t\t//\t\t*lpNumberOfCharsWritten = write.NumberOfCharsWritten;\n\t\t\t\t//\tif (write.ScrolledRowsUp > 0)\n\t\t\t\t//\t\tgDisplayCursor.StoredCursorPos.Y = std::max(0,((int)gDisplayCursor.StoredCursorPos.Y - (int)write.ScrolledRowsUp));\n\t\t\t\t//}\n\t\t\t}\n\n\t\t\tif (iEsc == 1)\n\t\t\t{\n\t\t\t\tif (Code.Skip)\n\t\t\t\t{\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tswitch (Code.Second)\n\t\t\t\t\t{\n\t\t\t\t\tcase L'[':\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlbApply = TRUE;\n\t\t\t\t\t\t\tWriteAnsiCode_CSI(writeConsoleW, hConsoleOutput, Code, lbApply);\n\n\t\t\t\t\t\t} // case L'[':\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase L']':\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlbApply = TRUE;\n\t\t\t\t\t\t\tWriteAnsiCode_OSC(writeConsoleW, hConsoleOutput, Code, lbApply);\n\n\t\t\t\t\t\t} // case L']':\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase L'|':\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// vim-xterm-emulation\n\t\t\t\t\t\t\tlbApply = TRUE;\n\t\t\t\t\t\t\tWriteAnsiCode_VIM(writeConsoleW, hConsoleOutput, Code, lbApply);\n\t\t\t\t\t\t} // case L'|':\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase L'7':\n\t\t\t\t\tcase L'8':\n\t\t\t\t\t\t//TODO: 7 - Save Cursor and _Attributes_\n\t\t\t\t\t\t//TODO: 8 - Restore Cursor and _Attributes_\n\t\t\t\t\t\tXTermSaveRestoreCursor((Code.Second == L'7'), hConsoleOutput);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase L'c':\n\t\t\t\t\t\t// Full reset\n\t\t\t\t\t\tFullReset(hConsoleOutput);\n\t\t\t\t\t\tlbApply = FALSE;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase L'g':\n\t\t\t\t\t\t// User may disable flashing in ConEmu settings\n\t\t\t\t\t\tGuiFlashWindow(eFlashBeep, ghConWnd, FALSE, FLASHW_ALL, 1, 0);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase L'H':\n\t\t\t\t\t\t// #ANSI gh-1827: support 'H' to set tab stops\n\t\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase L'M':\n\t\t\t\t\t\tReverseLF(hConsoleOutput, lbApply);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase L'E':\n\t\t\t\t\t\tWriteText(writeConsoleW, hConsoleOutput, L\"\\r\\n\", 2, nullptr);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase L'D':\n\t\t\t\t\t\tForwardLF(hConsoleOutput, lbApply);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase L'=':\n\t\t\t\t\tcase L'>':\n\t\t\t\t\t\t// xterm \"ESC =\" - Application Keypad (DECKPAM)\n\t\t\t\t\t\t// xterm \"ESC >\" - Normal Keypad (DECKPNM)\n\t\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase L'(':\n\t\t\t\t\t\t// xterm G0..G3?\n\t\t\t\t\t\tswitch (Code.Action)\n\t\t\t\t\t\t{\n\t\t\t\t\t\tcase L'0':\n\t\t\t\t\t\t\tmCharSet = VTCS_DRAWING;\n\t\t\t\t\t\t\t//DumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Comment);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase L'B':\n\t\t\t\t\t\t\tmCharSet = VTCS_DEFAULT;\n\t\t\t\t\t\t\t//DumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Comment);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tmCharSet = VTCS_DEFAULT;\n\t\t\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse //if (iEsc != 2) // 2 - means \"Esc part stored in buffer\"\n\t\t{\n\t\t\t_ASSERTEX(iEsc == 0);\n\t\t\tif (lpNext > lpBuffer)\n\t\t\t{\n\t\t\t\tif (lbApply)\n\t\t\t\t{\n\t\t\t\t\tReSetDisplayParm(hConsoleOutput, FALSE, TRUE);\n\t\t\t\t\tlbApply = FALSE;\n\t\t\t\t}\n\n\t\t\t\tconst DWORD nWrite = static_cast<DWORD>(lpNext - lpBuffer);\n\t\t\t\t//lbRc = WriteText(writeConsoleW, hConsoleOutput, lpBuffer, nWrite, lpNumberOfCharsWritten);\n\t\t\t\tlbRc = WriteText(writeConsoleW, hConsoleOutput, lpBuffer, nWrite, lpNumberOfCharsWritten);\n\t\t\t\tif (!lbRc)\n\t\t\t\t\tgoto wrap;\n\t\t\t\t//write.Buffer = lpBuffer;\n\t\t\t\t//write.NumberOfCharsToWrite = nWrite;\n\t\t\t\t//lbRc = ExtWriteText(&write);\n\t\t\t\t//if (!lbRc)\n\t\t\t\t//\tgoto wrap;\n\t\t\t\t//else\n\t\t\t\t//{\n\t\t\t\t//\tif (lpNumberOfCharsWritten)\n\t\t\t\t//\t\t*lpNumberOfCharsWritten = write.NumberOfCharsWritten;\n\t\t\t\t//\tif (write.ScrolledRowsUp > 0)\n\t\t\t\t//\t\tgDisplayCursor.StoredCursorPos.Y = std::max(0,((int)gDisplayCursor.StoredCursorPos.Y - (int)write.ScrolledRowsUp));\n\t\t\t\t//}\n\t\t\t}\n\t\t}\n\n\t\tif (lpNext > lpBuffer)\n\t\t{\n\t\t\tlpBuffer = lpNext;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t_ASSERTEX(lpNext > lpBuffer || lpNext == nullptr);\n\t\t\t++lpBuffer;\n\t\t}\n\t}\n\n\tif (lbRc && lpNumberOfCharsWritten)\n\t\t*lpNumberOfCharsWritten = nNumberOfCharsToWrite;\n\nwrap:\n\tif (lbApply)\n\t{\n\t\tReSetDisplayParm(hConsoleOutput, FALSE, TRUE);\n\t\tlbApply = FALSE;\n\t}\n\treturn lbRc;\n}\n\nvoid CEAnsi::WriteAnsiCode_CSI(OnWriteConsoleW_t writeConsoleW, HANDLE& hConsoleOutput, AnsiEscCode& Code, BOOL& lbApply)\n{\n\t/*\n\nCSI ? P m h\t\t\tDEC Private Mode Set (DECSET)\n\tP s = 4 7 \u2192 Use Alternate Screen Buffer (unless disabled by the titeInhibit resource)\n\tP s = 1 0 4 7 \u2192 Use Alternate Screen Buffer (unless disabled by the titeInhibit resource)\n\tP s = 1 0 4 8 \u2192 Save cursor as in DECSC (unless disabled by the titeInhibit resource)\n\tP s = 1 0 4 9 \u2192 Save cursor as in DECSC and use Alternate Screen Buffer, clearing it first (unless disabled by the titeInhibit resource). This combines the effects of the 1 0 4 7 and 1 0 4 8 modes. Use this with terminfo-based applications rather than the 4 7 mode.\n\nCSI ? P m l\t\t\tDEC Private Mode Reset (DECRST)\n\tP s = 4 7 \u2192 Use Normal Screen Buffer\n\tP s = 1 0 4 7 \u2192 Use Normal Screen Buffer, clearing screen first if in the Alternate Screen (unless disabled by the titeInhibit resource)\n\tP s = 1 0 4 8 \u2192 Restore cursor as in DECRC (unless disabled by the titeInhibit resource)\n\tP s = 1 0 4 9 \u2192 Use Normal Screen Buffer and restore cursor as in DECRC (unless disabled by the titeInhibit resource). This combines the effects of the 1 0 4 7 and 1 0 4 8 modes. Use this with terminfo-based applications rather than the 4 7 mode.\n\n\nCSI P s @\t\t\tInsert P s (Blank) Character(s) (default = 1) (ICH)\n\n\t*/\n\tCONSOLE_SCREEN_BUFFER_INFO csbi = {};\n\n\tswitch (Code.Action) // case sensitive\n\t{\n\tcase L's':\n\t\t// Save cursor position (can not be nested)\n\t\tXTermSaveRestoreCursor(true, hConsoleOutput);\n\t\tbreak;\n\n\tcase L'u':\n\t\t// Restore cursor position\n\t\tXTermSaveRestoreCursor(false, hConsoleOutput);\n\t\tbreak;\n\n\tcase L'H': // Set cursor position (1-based)\n\tcase L'f': // Same as 'H'\n\tcase L'A': // Cursor up by N rows\n\tcase L'B': // Cursor down by N rows\n\tcase L'C': // Cursor right by N cols\n\tcase L'D': // Cursor left by N cols\n\tcase L'E': // Moves cursor to beginning of the line n (default 1) lines down.\n\tcase L'F': // Moves cursor to beginning of the line n (default 1) lines up.\n\tcase L'G': // Moves the cursor to column n.\n\tcase L'd': // Moves the cursor to line n.\n\t\t// Change cursor position\n\t\tif (GetConsoleScreenBufferInfoCached(hConsoleOutput, &csbi))\n\t\t{\n\t\t\tstruct PointXY {int X,Y;};\n\t\t\tauto get_scroll_region = [&csbi]()\n\t\t\t{\n\t\t\t\tconst auto& srw = csbi.srWindow;\n\t\t\t\tSMALL_RECT clipRgn = MakeSmallRect(0, 0, srw.Right - srw.Left, srw.Bottom - srw.Top);\n\t\t\t\tif (gDisplayOpt.ScrollRegion)\n\t\t\t\t{\n\t\t\t\t\tclipRgn.Top = std::max<SHORT>(0, std::min<SHORT>(gDisplayOpt.ScrollStart, csbi.dwSize.Y-1));\n\t\t\t\t\tclipRgn.Bottom = std::max<SHORT>(0, std::min<SHORT>(gDisplayOpt.ScrollEnd, csbi.dwSize.Y-1));\n\t\t\t\t}\n\t\t\t\treturn clipRgn;\n\t\t\t};\n\t\t\tauto get_cursor = [&csbi]()\n\t\t\t{\n\t\t\t\tconst auto& srw = csbi.srWindow;\n\t\t\t\tconst int visible_rows = srw.Bottom - srw.Top;\n\t\t\t\treturn PointXY{\n\t\t\t\t\tcsbi.dwCursorPosition.X,\n\t\t\t\t\tstd::max(0, std::min(visible_rows, csbi.dwCursorPosition.Y - srw.Top))\n\t\t\t\t};\n\t\t\t};\n\t\t\tconst struct {int left, top, right, bottom;} workRgn = {0, 0, csbi.dwSize.X - 1, csbi.dwSize.Y - 1};\n\t\t\t_ASSERTEX(workRgn.left <= workRgn.right && workRgn.top <= workRgn.bottom);\n\t\t\tconst auto& clipRgn = get_scroll_region();\n\t\t\tconst auto cur = get_cursor();\n\t\t\tPointXY crNewPos = cur;\n\n\t\t\tenum class Direction { kAbsolute, kCompatible, kRelative };\n\n\t\t\tauto set_y = [&crNewPos, &workRgn, &clipRgn, &cur](Direction direction, int value)\n\t\t\t{\n\t\t\t\tconst int kLegacyY = 9999;\n\t\t\t\tif (direction == Direction::kCompatible && value >= std::min(kLegacyY, workRgn.bottom))\n\t\t\t\t\t// #XTERM_256 Allow to put cursor into the legacy true-color area\n\t\t\t\t\tcrNewPos.Y = workRgn.bottom;\n\t\t\t\telse if (direction == Direction::kAbsolute || direction == Direction::kCompatible)\n\t\t\t\t\tcrNewPos.Y = std::max(workRgn.top, std::min(workRgn.bottom, value));\n\t\t\t\telse if (value < 0 && cur.Y >= clipRgn.Top)\n\t\t\t\t\tcrNewPos.Y = std::max<int>(clipRgn.Top, std::min(workRgn.bottom, cur.Y + value));\n\t\t\t\telse if (value > 0 && cur.Y <= clipRgn.Bottom)\n\t\t\t\t\tcrNewPos.Y = std::max(workRgn.top, std::min<int>(clipRgn.Bottom, cur.Y + value));\n\t\t\t\telse\n\t\t\t\t\tcrNewPos.Y = std::max(workRgn.top, std::min(workRgn.bottom, cur.Y + value));\n\t\t\t};\n\t\t\tauto set_x = [&crNewPos, &workRgn, &cur](Direction direction, int value)\n\t\t\t{\n\t\t\t\tif (direction == Direction::kAbsolute || direction == Direction::kCompatible)\n\t\t\t\t\tcrNewPos.X = std::max(workRgn.left, std::min(workRgn.right, value));\n\t\t\t\telse\n\t\t\t\t\tcrNewPos.X = std::max(workRgn.left, std::min(workRgn.right, cur.X + value));\n\t\t\t};\n\n\t\t\tswitch (Code.Action)\n\t\t\t{\n\t\t\tcase L'H':\n\t\t\t\t// Set cursor position (ANSI values are 1-based)\n\t\t\t\tset_y(Direction::kCompatible, (Code.ArgC > 0 && Code.ArgV[0]) ? (Code.ArgV[0] - 1) : 0);\n\t\t\t\tset_x(Direction::kAbsolute, (Code.ArgC > 1 && Code.ArgV[1]) ? (Code.ArgV[1] - 1) : 0);\n\t\t\t\tbreak;\n\t\t\tcase L'f':\n\t\t\t\t// Set cursor position (ANSI values are 1-based)\n\t\t\t\tset_y(Direction::kAbsolute, (Code.ArgC > 0 && Code.ArgV[0]) ? (Code.ArgV[0] - 1) : 0);\n\t\t\t\tset_x(Direction::kAbsolute, (Code.ArgC > 1 && Code.ArgV[1]) ? (Code.ArgV[1] - 1) : 0);\n\t\t\t\tbreak;\n\t\t\tcase L'A':\n\t\t\t\t// Cursor up by N rows\n\t\t\t\tset_y(Direction::kRelative, -((Code.ArgC > 0 && Code.ArgV[0]) ? Code.ArgV[0] : 1));\n\t\t\t\tbreak;\n\t\t\tcase L'B':\n\t\t\t\t// Cursor down by N rows\n\t\t\t\tset_y(Direction::kRelative, +((Code.ArgC > 0 && Code.ArgV[0]) ? Code.ArgV[0] : 1));\n\t\t\t\tbreak;\n\t\t\tcase L'C':\n\t\t\t\t// Cursor right by N cols\n\t\t\t\tset_x(Direction::kRelative, +((Code.ArgC > 0 && Code.ArgV[0]) ? Code.ArgV[0] : 1));\n\t\t\t\tbreak;\n\t\t\tcase L'D':\n\t\t\t\t// Cursor left by N cols\n\t\t\t\tset_x(Direction::kRelative, -((Code.ArgC > 0 && Code.ArgV[0]) ? Code.ArgV[0] : 1));\n\t\t\t\tbreak;\n\t\t\tcase L'E':\n\t\t\t\t// Moves cursor to beginning of the line n (default 1) lines down.\n\t\t\t\tset_y(Direction::kRelative, +((Code.ArgC > 0 && Code.ArgV[0]) ? Code.ArgV[0] : 1));\n\t\t\t\tset_x(Direction::kAbsolute, 0);\n\t\t\t\tbreak;\n\t\t\tcase L'F':\n\t\t\t\t// Moves cursor to beginning of the line n (default 1) lines up.\n\t\t\t\tset_y(Direction::kRelative, -((Code.ArgC > 0 && Code.ArgV[0]) ? Code.ArgV[0] : 1));\n\t\t\t\tset_x(Direction::kAbsolute, 0);\n\t\t\t\tbreak;\n\t\t\tcase L'G':\n\t\t\t\t// Moves the cursor to column n.\n\t\t\t\tset_x(Direction::kAbsolute, (Code.ArgC > 0) ? (Code.ArgV[0] - 1) : 0);\n\t\t\t\tbreak;\n\t\t\tcase L'd':\n\t\t\t\t// Moves the cursor to line n (almost the same as 'H', but leave X unchanged).\n\t\t\t\tset_y(Direction::kAbsolute, (Code.ArgC > 0) ? (Code.ArgV[0] - 1) : 0);\n\t\t\t\tbreak;\n\t\t\t#ifdef _DEBUG\n\t\t\tdefault:\n\t\t\t\t_ASSERTEX(FALSE && \"Missed (sub)case value!\");\n\t\t\t#endif\n\t\t\t}\n\n\t\t\t// Goto\n\t\t\tORIGINAL_KRNL(SetConsoleCursorPosition);\n\t\t\t{\n\t\t\tconst auto& srw = csbi.srWindow;\n\t\t\tCOORD crNewPosAPI = {\n\t\t\t\tstatic_cast<SHORT>(crNewPos.X),\n\t\t\t\tstatic_cast<SHORT>(std::min<int>(csbi.dwSize.Y - 1, srw.Top + crNewPos.Y))\n\t\t\t};\n\t\t\t_ASSERTE(crNewPosAPI.X == crNewPos.X);\n\t\t\tF(SetConsoleCursorPosition)(hConsoleOutput, crNewPosAPI);\n\t\t\t}\n\n\t\t\tif (gbIsVimProcess)\n\t\t\t\tgbIsVimAnsi = true;\n\t\t} // case 'H', 'f', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'd'\n\t\tbreak;\n\n\tcase L'J': // Clears part of the screen\n\t\t// Clears the screen and moves the cursor to the home position (line 0, column 0).\n\t\tif (GetConsoleScreenBufferInfoCached(hConsoleOutput, &csbi))\n\t\t{\n\t\t\tif (lbApply)\n\t\t\t{\n\t\t\t\t// Apply default color before scrolling!\n\t\t\t\t// ViM: need to fill whole screen with selected background color, so Apply attributes\n\t\t\t\tReSetDisplayParm(hConsoleOutput, FALSE, TRUE);\n\t\t\t\tlbApply = FALSE;\n\t\t\t}\n\n\t\t\tint nCmd = (Code.ArgC > 0) ? Code.ArgV[0] : 0;\n\t\t\tbool resetCursor = false;\n\t\t\tCOORD cr0 = {0, csbi.srWindow.Top};\n\t\t\tint nChars = 0;\n\n\t\t\tswitch (nCmd)\n\t\t\t{\n\t\t\tcase 0:\n\t\t\t\t// clear from cursor to end of screen\n\t\t\t\tcr0 = csbi.dwCursorPosition;\n\t\t\t\tnChars = (csbi.dwSize.X - csbi.dwCursorPosition.X)\n\t\t\t\t\t+ csbi.dwSize.X * (csbi.srWindow.Bottom - csbi.dwCursorPosition.Y);\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\t// clear from cursor to beginning of the screen\n\t\t\t\tnChars = csbi.dwCursorPosition.X + 1\n\t\t\t\t\t+ csbi.dwSize.X * (csbi.dwCursorPosition.Y - csbi.srWindow.Top);\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\t// clear viewport and moves cursor to viewport's upper left\n\t\t\t\tnChars = csbi.dwSize.X * (csbi.srWindow.Bottom - csbi.srWindow.Top + 1);\n\t\t\t\tresetCursor = true;\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\t// xterm: clear scrollback buffer entirely\n\t\t\t\tif (csbi.srWindow.Top > 0)\n\t\t\t\t{\n\t\t\t\t\tcr0.X = csbi.dwCursorPosition.X;\n\t\t\t\t\tcr0.Y = static_cast<SHORT>(std::max(0, (csbi.dwCursorPosition.Y - csbi.srWindow.Top)));\n\t\t\t\t\tresetCursor = true;\n\n\t\t\t\t\tSMALL_RECT scroll{ 0, 0, static_cast<SHORT>(csbi.dwSize.X - 1),\n\t\t\t\t\t\tstatic_cast<SHORT>(csbi.dwSize.Y - 1) };\n\t\t\t\t\tScrollScreen(hConsoleOutput, -csbi.srWindow.Top, true, scroll);\n\n\t\t\t\t\tSMALL_RECT topLeft = { 0, 0, scroll.Right,\n\t\t\t\t\t\tstatic_cast<SHORT>(csbi.srWindow.Bottom - csbi.srWindow.Top) };\n\t\t\t\t\tSetConsoleWindowInfo(hConsoleOutput, TRUE, &topLeft);\n\n\t\t\t\t\tUpdateAppMapRows(0, true);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tDumpUnknownEscape(Code.pszEscStart, Code.nTotalLen);\n\t\t\t}\n\n\t\t\tif (nChars > 0)\n\t\t\t{\n\t\t\t\tExtFillOutputParm fill = {sizeof(fill), efof_Current|efof_Attribute|efof_Character,\n\t\t\t\t\thConsoleOutput, {}, L' ', cr0, static_cast<DWORD>(nChars)};\n\t\t\t\tExtFillOutput(&fill);\n\t\t\t}\n\n\t\t\tif (resetCursor)\n\t\t\t{\n\t\t\t\tSetConsoleCursorPosition(hConsoleOutput, cr0);\n\t\t\t}\n\n\t\t} // case L'J':\n\t\tbreak;\n\n\tcase L'b':\n\t\tif (!Code.PvtLen)\n\t\t{\n\t\t\tint repeat = (Code.ArgC > 0) ? Code.ArgV[0] : 1;\n\t\t\tif (m_LastWrittenChar && repeat > 0)\n\t\t\t{\n\t\t\t\tCEStr buffer;\n\t\t\t\tif (wchar_t* ptr = buffer.GetBuffer(repeat))\n\t\t\t\t{\n\t\t\t\t\tfor (int i = 0; i < repeat; ++i)\n\t\t\t\t\t\tptr[i] = m_LastWrittenChar;\n\t\t\t\t\tWriteText(writeConsoleW, hConsoleOutput, ptr, repeat, nullptr);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\tbreak; // case L'b'\n\n\tcase L'K': // Erases part of the line\n\t\t// Clears all characters from the cursor position to the end of the line\n\t\t// (including the character at the cursor position).\n\t\tif (GetConsoleScreenBufferInfoCached(hConsoleOutput, &csbi))\n\t\t{\n\t\t\tif (lbApply)\n\t\t\t{\n\t\t\t\t// Apply default color before scrolling!\n\t\t\t\tReSetDisplayParm(hConsoleOutput, FALSE, TRUE);\n\t\t\t\tlbApply = FALSE;\n\t\t\t}\n\n\t\t\tTODO(\"Need to clear attributes?\");\n\t\t\tint nChars = 0;\n\t\t\tint nCmd = (Code.ArgC > 0) ? Code.ArgV[0] : 0;\n\t\t\tCOORD cr0 = csbi.dwCursorPosition;\n\n\t\t\tswitch (nCmd)\n\t\t\t{\n\t\t\tcase 0: // clear from cursor to the end of the line\n\t\t\t\tnChars = csbi.dwSize.X - csbi.dwCursorPosition.X;\n\t\t\t\tbreak;\n\t\t\tcase 1: // clear from cursor to beginning of the line\n\t\t\t\tcr0.X = 0;\n\t\t\t\tnChars = csbi.dwCursorPosition.X + 1;\n\t\t\t\tbreak;\n\t\t\tcase 2: // clear entire line\n\t\t\t\tcr0.X = 0;\n\t\t\t\tnChars = csbi.dwSize.X;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t\t}\n\n\n\t\t\tif (nChars > 0)\n\t\t\t{\n\t\t\t\tExtFillOutputParm fill = { sizeof(fill), efof_Current | efof_Attribute | efof_Character,\n\t\t\t\t\thConsoleOutput, {}, L' ', cr0, static_cast<DWORD>(nChars) };\n\t\t\t\tExtFillOutput(&fill);\n\t\t\t}\n\t\t} // case L'K':\n\t\tbreak;\n\n\tcase L'r':\n\t\t//\\027[Pt;Pbr\n\t\t//\n\t\t//Pt is the number of the top line of the scrolling region;\n\t\t//Pb is the number of the bottom line of the scrolling region\n\t\t// and must be greater than Pt.\n\t\t//(The default for Pt is line 1, the default for Pb is the end\n\t\t// of the screen)\n\t\t//\n\t\tif ((Code.ArgC >= 2) && (Code.ArgV[0] >= 0) && (Code.ArgV[1] >= Code.ArgV[0]))\n\t\t{\n\t\t\t// Values are 1-based\n\t\t\tSetScrollRegion(true, true, Code.ArgV[0], Code.ArgV[1], hConsoleOutput);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tSetScrollRegion(false);\n\t\t}\n\t\tbreak;\n\n\tcase L'S':\n\t\t// Scroll whole page up by n (default 1) lines. New lines are added at the bottom.\n\t\tif (lbApply)\n\t\t{\n\t\t\t// Apply default color before scrolling!\n\t\t\tReSetDisplayParm(hConsoleOutput, FALSE, TRUE);\n\t\t\tlbApply = FALSE;\n\t\t}\n\t\tScrollScreen(hConsoleOutput, (Code.ArgC > 0 && Code.ArgV[0] > 0) ? -Code.ArgV[0] : -1);\n\t\tbreak;\n\n\tcase L'L':\n\t\t// Insert P s Line(s) (default = 1) (IL).\n\t\tLinesInsert(hConsoleOutput, (Code.ArgC > 0 && Code.ArgV[0] > 0) ? Code.ArgV[0] : 1);\n\t\tbreak;\n\tcase L'M':\n\t\t// Delete N Line(s) (default = 1) (DL).\n\t\t// This is actually \"Scroll UP N line(s) inside defined scrolling region\"\n\t\tLinesDelete(hConsoleOutput, (Code.ArgC > 0 && Code.ArgV[0] > 0) ? Code.ArgV[0] : 1);\n\t\tbreak;\n\n\tcase L'@':\n\t\t// Insert P s (Blank) Character(s) (default = 1) (ICH).\n\t\tScrollLine(hConsoleOutput, ((Code.ArgC > 0 && Code.ArgV[0] > 0) ? Code.ArgV[0] : 1));\n\t\tbreak;\n\tcase L'P':\n\t\t// Delete P s Character(s) (default = 1) (DCH).\n\t\tScrollLine(hConsoleOutput, -((Code.ArgC > 0 && Code.ArgV[0] > 0) ? Code.ArgV[0] : 1));\n\t\tbreak;\n\n\tcase L'T':\n\t\t// Scroll whole page down by n (default 1) lines. New lines are added at the top.\n\t\tif (lbApply)\n\t\t{\n\t\t\t// Apply default color before scrolling!\n\t\t\tReSetDisplayParm(hConsoleOutput, FALSE, TRUE);\n\t\t}\n\t\tTODO(\"Define scrolling region\");\n\t\tScrollScreen(hConsoleOutput, (Code.ArgC > 0 && Code.ArgV[0] > 0) ? Code.ArgV[0] : 1);\n\t\tbreak;\n\n\tcase L'h':\n\tcase L'l':\n\t\t// Set/ReSet Mode\n\t\tif (Code.ArgC > 0)\n\t\t{\n\t\t\t//ESC [ 3 h\n\t\t\t//       DECCRM (default off): Display control chars.\n\n\t\t\t//ESC [ 4 h\n\t\t\t//       DECIM (default off): Set insert mode.\n\n\t\t\t//ESC [ 20 h\n\t\t\t//       LF/NL (default off): Automatically follow echo of LF, VT or FF with CR.\n\n\t\t\t//ESC [ ? 1 h\n\t\t\t//\t  DECCKM (default off): When set, the cursor keys send an ESC O prefix,\n\t\t\t//\t  rather than ESC [.\n\n\t\t\t//ESC [ ? 3 h\n\t\t\t//\t  DECCOLM (default off = 80 columns): 80/132 col mode switch.  The driver\n\t\t\t//\t  sources note that this alone does not suffice; some user-mode utility\n\t\t\t//\t  such as resizecons(8) has to change the hardware registers on the\n\t\t\t//\t  console video card.\n\n\t\t\t//ESC [ ? 5 h\n\t\t\t//\t  DECSCNM (default off): Set reverse-video mode.\n\n\t\t\t//ESC [ ? 6 h\n\t\t\t//\t  DECOM (default off): When set, cursor addressing is relative to the\n\t\t\t//\t  upper left corner of the scrolling region.\n\n\n\t\t\t//ESC [ ? 8 h\n\t\t\t//\t  DECARM (default on): Set keyboard autorepeat on.\n\n\t\t\t//ESC [ ? 9 h\n\t\t\t//\t  X10 Mouse Reporting (default off): Set reporting mode to 1 (or reset to\n\t\t\t//\t  0) -- see below.\n\n\t\t\t//ESC [ ? 1000 h\n\t\t\t//\t  X11 Mouse Reporting (default off): Set reporting mode to 2 (or reset to\n\t\t\t//\t  0) -- see below.\n\n\t\t\t//ESC [ ? 7711 h\n\t\t\t//    mimic mintty code, same as \"ESC ] 9 ; 12 ST\"\n\n\t\t\tswitch (Code.ArgV[0])\n\t\t\t{\n\t\t\tcase 1:\n\t\t\t\tif ((Code.PvtLen == 1) && (Code.Pvt[0] == L'?'))\n\t\t\t\t{\n\t\t\t\t\tgDisplayCursor.CursorKeysApp = (Code.Action == L'h');\n\n\t\t\t\t\tif (gbIsVimProcess)\n\t\t\t\t\t{\n\t\t\t\t\t\tTODO(\"Need to find proper way for activation alternative buffer from ViM?\");\n\t\t\t\t\t\tif (Code.Action == L'h')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\thConsoleOutput = StartVimTerm(false);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\thConsoleOutput = StopVimTerm();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tChangeTermMode(tmc_AppCursorKeys, (Code.Action == L'h'));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart, Code.nTotalLen);\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tgDisplayOpt.ShowRawAnsi = (Code.Action == L'h');\n\t\t\t\tbreak;\n\t\t\tcase 7:\n\t\t\t\t//ESC [ ? 7 h\n\t\t\t\t//\t  DECAWM (default off): Set autowrap on.  In this mode, a graphic\n\t\t\t\t//\t  character emitted after column 80 (or column 132 of DECCOLM is on)\n\t\t\t\t//\t  forces a wrap to the beginning of the following line first.\n\t\t\t\t//ESC [ = 7 h\n\t\t\t\t//    Enables line wrapping\n\t\t\t\t//ESC [ 7 ; _col_ h\n\t\t\t\t//    Our extension. _col_ - wrap at column (1-based), default = 80\n\t\t\t\tif ((gDisplayOpt.WrapWasSet = (Code.Action == L'h')))\n\t\t\t\t{\n\t\t\t\t\tgDisplayOpt.WrapAt = ((Code.ArgC > 1) && (Code.ArgV[1] > 0)) ? static_cast<SHORT>(Code.ArgV[1]) : 80;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 20:\n\t\t\t\tif (Code.PvtLen == 0)\n\t\t\t\t{\n\t\t\t\t\tSetAutoLfNl(Code.Action == L'h');\n\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart, Code.nTotalLen);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t//ESC [ ? 12 h\n\t\t\t//\t  Start Blinking Cursor (att610)\n\t\t\tcase 12:\n\t\t\t//ESC [ ? 25 h\n\t\t\t//\t  DECTECM (default on): Make cursor visible.\n\t\t\tcase 25:\n\t\t\t\tif ((Code.PvtLen == 1) && (Code.Pvt[0] == L'?'))\n\t\t\t\t{\n\t\t\t\t\tfor (int i = 0; i < Code.ArgC; ++i)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (Code.ArgV[i] == 25)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tCONSOLE_CURSOR_INFO ci = {};\n\t\t\t\t\t\t\tif (GetConsoleCursorInfo(hConsoleOutput, &ci))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tci.bVisible = (Code.Action == L'h');\n\t\t\t\t\t\t\t\tSetConsoleCursorInfo(hConsoleOutput, &ci);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// DumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart, Code.nTotalLen);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tif (Code.PvtLen == 0)\n\t\t\t\t{  // NOLINT(bugprone-branch-clone)\n\t\t\t\t\t/* h=Insert Mode (IRM), l=Replace Mode (IRM) */\n\t\t\t\t\t// Nano posts the `ESC [ 4 l` on start, but do not post `ESC [ 4 h` on exit, that is strange...\n\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored); // ignored for now\n\t\t\t\t}\n\t\t\t\telse if ((Code.PvtLen == 1) && (Code.Pvt[0] == L'?'))\n\t\t\t\t{\n\t\t\t\t\t/* h=Smooth (slow) scroll, l=Jump (fast) scroll */\n\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored); // ignored for now\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart, Code.nTotalLen);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 9:    /* X10_MOUSE */\n\t\t\tcase 1000: /* VT200_MOUSE */\n\t\t\tcase 1002: /* BTN_EVENT_MOUSE */\n\t\t\tcase 1003: /* ANY_EVENT_MOUSE */\n\t\t\tcase 1004: /* FOCUS_EVENT_MOUSE */\n\t\t\tcase 1005: /* Xterm's UTF8 encoding for mouse positions */\n\t\t\tcase 1006: /* Xterm's CSI-style mouse encoding */\n\t\t\tcase 1015: /* Urxvt's CSI-style mouse encoding */\n\t\t\t\tif ((Code.PvtLen == 1) && (Code.Pvt[0] == L'?'))\n\t\t\t\t{\n\t\t\t\t\tstatic DWORD LastMode = 0;\n\t\t\t\t\tTermMouseMode ModeMask = (Code.ArgV[0] == 9) ? tmm_X10\n\t\t\t\t\t\t: (Code.ArgV[0] == 1000) ? tmm_VT200\n\t\t\t\t\t\t: (Code.ArgV[0] == 1002) ? tmm_BTN\n\t\t\t\t\t\t: (Code.ArgV[0] == 1003) ? tmm_ANY\n\t\t\t\t\t\t: (Code.ArgV[0] == 1004) ? tmm_FOCUS\n\t\t\t\t\t\t: (Code.ArgV[0] == 1005) ? tmm_UTF8\n\t\t\t\t\t\t: (Code.ArgV[0] == 1006) ? tmm_XTERM\n\t\t\t\t\t\t: (Code.ArgV[0] == 1015) ? tmm_URXVT\n\t\t\t\t\t\t: tmm_None;\n\t\t\t\t\tDWORD Mode = (Code.Action == L'h')\n\t\t\t\t\t\t? (LastMode | ModeMask)\n\t\t\t\t\t\t: (LastMode & ~ModeMask);\n\t\t\t\t\tLastMode = Mode;\n\t\t\t\t\tChangeTermMode(tmc_MouseMode, Mode);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart, Code.nTotalLen);\n\t\t\t\tbreak;\n\t\t\tcase 7786: /* 'V': Mouse wheel reporting */\n\t\t\tcase 7787: /* 'W': Application mouse wheel mode */\n\t\t\tcase 1034: // Interpret \"meta\" key, sets eighth bit. (enables/disables the eightBitInput resource).\n\t\t\t\tif ((Code.PvtLen == 1) && (Code.Pvt[0] == L'?'))\n\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored);\n\t\t\t\telse\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart, Code.nTotalLen);\n\t\t\t\tbreak;\n\t\t\tcase 47:   /* alternate screen */\n\t\t\tcase 1047: /* alternate screen */\n\t\t\tcase 1049: /* cursor & alternate screen */\n\t\t\t\t// xmux/screen: Alternate screen\n\t\t\t\tif ((Code.PvtLen == 1) && (Code.Pvt[0] == L'?'))\n\t\t\t\t{\n\t\t\t\t\tif (lbApply)\n\t\t\t\t\t{\n\t\t\t\t\t\tReSetDisplayParm(hConsoleOutput, FALSE, TRUE);\n\t\t\t\t\t\tlbApply = FALSE;\n\t\t\t\t\t}\n\n\t\t\t\t\t// \\e[?1049h: save cursor pos\n\t\t\t\t\tif ((Code.ArgV[0] == 1049) && (Code.Action == L'h'))\n\t\t\t\t\t\tXTermSaveRestoreCursor(true, hConsoleOutput);\n\t\t\t\t\t// h: switch to alternative buffer without backscroll\n\t\t\t\t\t// l: restore saved scrollback buffer\n\t\t\t\t\thConsoleOutput = XTermAltBuffer((Code.Action == L'h'), Code.ArgV[0]);\n\t\t\t\t\t// \\e[?1049l - restore cursor pos\n\t\t\t\t\tif ((Code.ArgV[0] == 1049) && (Code.Action == L'l'))\n\t\t\t\t\t\tXTermSaveRestoreCursor(false, hConsoleOutput);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart, Code.nTotalLen);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 1048: /* save/restore cursor */\n\t\t\t\tif ((Code.PvtLen == 1) && (Code.Pvt[0] == L'?'))\n\t\t\t\t\tXTermSaveRestoreCursor((Code.Action == L'h'), hConsoleOutput);\n\t\t\t\telse\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart, Code.nTotalLen);\n\t\t\t\tbreak;\n\t\t\tcase 2004: /* bracketed paste */\n\t\t\t\t/* All \"pasted\" text will be wrapped in `\\e[200~ ... \\e[201~` */\n\t\t\t\tif ((Code.PvtLen == 1) && (Code.Pvt[0] == L'?'))\n\t\t\t\t\tChangeTermMode(tmc_BracketedPaste, (Code.Action == L'h'));\n\t\t\t\telse\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart, Code.nTotalLen);\n\t\t\t\tbreak;\n\t\t\tcase 7711:\n\t\t\t\tif ((Code.Action == L'h') && (Code.PvtLen == 1) && (Code.Pvt[0] == L'?'))\n\t\t\t\t{\n\t\t\t\t\tStorePromptBegin();\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart, Code.nTotalLen);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t\t}\n\n\t\t\t//switch (Code.ArgV[0])\n\t\t\t//{\n\t\t\t//case 0: case 1:\n\t\t\t//\t// 40x25\n\t\t\t//\tif ((gDisplayOpt.WrapWasSet = (Code.Action == L'h')))\n\t\t\t//\t{\n\t\t\t//\t\tgDisplayOpt.WrapAt = 40;\n\t\t\t//\t}\n\t\t\t//\tbreak;\n\t\t\t//case 2: case 3:\n\t\t\t//\t// 80x25\n\t\t\t//\tif ((gDisplayOpt.WrapWasSet = (Code.Action == L'h')))\n\t\t\t//\t{\n\t\t\t//\t\tgDisplayOpt.WrapAt = 80;\n\t\t\t//\t}\n\t\t\t//\tbreak;\n\t\t\t//case 7:\n\t\t\t//\t{\n\t\t\t//\t\tDWORD Mode = 0;\n\t\t\t//\t\tGetConsoleMode(hConsoleOutput, &Mode);\n\t\t\t//\t\tif (Code.Action == L'h')\n\t\t\t//\t\t\tMode |= ENABLE_WRAP_AT_EOL_OUTPUT;\n\t\t\t//\t\telse\n\t\t\t//\t\t\tMode &= ~ENABLE_WRAP_AT_EOL_OUTPUT;\n\t\t\t//\t\tSetConsoleMode(hConsoleOutput, Mode);\n\t\t\t//\t} // enable/disable line wrapping\n\t\t\t//\tbreak;\n\t\t\t//}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t}\n\t\tbreak; // case L'h': case L'l':\n\n\tcase L'n':\n\t\tif (Code.ArgC > 0)\n\t\t{\n\t\t\tswitch (*Code.ArgV)\n\t\t\t{\n\t\t\tcase 5:\n\t\t\t\t//ESC [ 5 n\n\t\t\t\t//      Device status report (DSR): Answer is ESC [ 0 n (Terminal OK).\n\t\t\t\t//\n\t\t\t\tReportString(L\"\\x1B[0n\");\n\t\t\t\tbreak;\n\t\t\tcase 6:\n\t\t\t\t//ESC [ 6 n\n\t\t\t\t//      Cursor position report (CPR): Answer is ESC [ y ; x R, where x,y is the\n\t\t\t\t//      cursor location.\n\t\t\t\tReportCursorPosition(hConsoleOutput);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t}\n\t\tbreak;\n\n\tcase L'm':\n\t\tif (Code.PvtLen > 0)\n\t\t{\n\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored);\n\t\t}\n\t\t// Set display mode (colors, fonts, etc.)\n\t\telse if (!Code.ArgC)\n\t\t{\n\t\t\tReSetDisplayParm(hConsoleOutput, TRUE, FALSE);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor (int i = 0; i < Code.ArgC; i++)\n\t\t\t{\n\t\t\t\tswitch (Code.ArgV[i])\n\t\t\t\t{\n\t\t\t\tcase 0:\n\t\t\t\t\tReSetDisplayParm(hConsoleOutput, TRUE, FALSE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\t// Bold\n\t\t\t\t\tgDisplayParm.setBrightOrBold(TRUE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\t// Faint, decreased intensity (ISO 6429)\n\t\t\t\tcase 22:\n\t\t\t\t\t// Normal (neither bold nor faint).\n\t\t\t\t\tgDisplayParm.setBrightOrBold(FALSE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3:\n\t\t\t\t\t// Italic\n\t\t\t\t\tgDisplayParm.setItalic(TRUE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 23:\n\t\t\t\t\t// Not italic\n\t\t\t\t\tgDisplayParm.setItalic(FALSE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 5: // #TODO ANSI Slow Blink (less than 150 per minute)\n\t\t\t\tcase 6: // #TODO ANSI Rapid Blink (150+ per minute)\n\t\t\t\tcase 25: // #TODO ANSI Blink Off\n\t\t\t\t\tDumpKnownEscape(Code.pszEscStart,Code.nTotalLen,de_Ignored);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 4: // Underlined\n\t\t\t\t\tgDisplayParm.setUnderline(true);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 24:\n\t\t\t\t\t// Not underlined\n\t\t\t\t\tgDisplayParm.setUnderline(false);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 7:\n\t\t\t\t\t// Reverse video\n\t\t\t\t\tgDisplayParm.setInverse(TRUE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 27:\n\t\t\t\t\t// Positive (not inverse)\n\t\t\t\t\tgDisplayParm.setInverse(FALSE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 9:\n\t\t\t\t\t// Crossed-out / strikethrough\n\t\t\t\t\tgDisplayParm.setCrossed(true);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 29:\n\t\t\t\t\t// Not Crossed-out / Not strikethrough\n\t\t\t\t\tgDisplayParm.setCrossed(false);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 30: case 31: case 32: case 33: case 34: case 35: case 36: case 37:\n\t\t\t\t\tgDisplayParm.setTextColor(Code.ArgV[i] - 30);\n\t\t\t\t\tgDisplayParm.setBrightFore(FALSE);\n\t\t\t\t\tgDisplayParm.setText256(clr4b);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 38:\n\t\t\t\t\t// xterm-256 colors\n\t\t\t\t\t// ESC [ 38 ; 5 ; I m -- set foreground to I (0..255) color from xterm palette\n\t\t\t\t\tif (((i+2) < Code.ArgC) && (Code.ArgV[i+1] == 5))\n\t\t\t\t\t{\n\t\t\t\t\t\tgDisplayParm.setTextColor(Code.ArgV[i+2] & 0xFF);\n\t\t\t\t\t\tgDisplayParm.setText256(clr8b);\n\t\t\t\t\t\ti += 2;\n\t\t\t\t\t}\n\t\t\t\t\t// xterm-256 colors\n\t\t\t\t\t// ESC [ 38 ; 2 ; R ; G ; B m -- set foreground to RGB(R,G,B) 24-bit color\n\t\t\t\t\telse if (((i+4) < Code.ArgC) && (Code.ArgV[i+1] == 2))\n\t\t\t\t\t{\n\t\t\t\t\t\tgDisplayParm.setTextColor(RGB((Code.ArgV[i+2] & 0xFF),(Code.ArgV[i+3] & 0xFF),(Code.ArgV[i+4] & 0xFF)));\n\t\t\t\t\t\tgDisplayParm.setText256(clr24b);\n\t\t\t\t\t\ti += 4;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 39:\n\t\t\t\t\t// Reset\n\t\t\t\t\tgDisplayParm.setTextColor(CONFORECOLOR(GetDefaultTextAttr()));\n\t\t\t\t\tgDisplayParm.setBrightFore(FALSE);\n\t\t\t\t\tgDisplayParm.setText256(clr4b);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 40: case 41: case 42: case 43: case 44: case 45: case 46: case 47:\n\t\t\t\t\tgDisplayParm.setBackColor(Code.ArgV[i] - 40);\n\t\t\t\t\tgDisplayParm.setBrightBack(FALSE);\n\t\t\t\t\tgDisplayParm.setBack256(clr4b);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 48:\n\t\t\t\t\t// xterm-256 colors\n\t\t\t\t\t// ESC [ 48 ; 5 ; I m -- set background to I (0..255) color from xterm palette\n\t\t\t\t\tif (((i+2) < Code.ArgC) && (Code.ArgV[i+1] == 5))\n\t\t\t\t\t{\n\t\t\t\t\t\tgDisplayParm.setBackColor(Code.ArgV[i+2] & 0xFF);\n\t\t\t\t\t\tgDisplayParm.setBack256(clr8b);\n\t\t\t\t\t\ti += 2;\n\t\t\t\t\t}\n\t\t\t\t\t// xterm-256 colors\n\t\t\t\t\t// ESC [ 48 ; 2 ; R ; G ; B m -- set background to RGB(R,G,B) 24-bit color\n\t\t\t\t\telse if (((i+4) < Code.ArgC) && (Code.ArgV[i+1] == 2))\n\t\t\t\t\t{\n\t\t\t\t\t\tgDisplayParm.setBackColor(RGB((Code.ArgV[i+2] & 0xFF),(Code.ArgV[i+3] & 0xFF),(Code.ArgV[i+4] & 0xFF)));\n\t\t\t\t\t\tgDisplayParm.setBack256(clr24b);\n\t\t\t\t\t\ti += 4;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 49:\n\t\t\t\t\t// Reset\n\t\t\t\t\tgDisplayParm.setBackColor(CONBACKCOLOR(GetDefaultTextAttr()));\n\t\t\t\t\tgDisplayParm.setBrightBack(FALSE);\n\t\t\t\t\tgDisplayParm.setBack256(clr4b);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 90: case 91: case 92: case 93: case 94: case 95: case 96: case 97:\n\t\t\t\t\tgDisplayParm.setTextColor((Code.ArgV[i] - 90) | 0x8);\n\t\t\t\t\tgDisplayParm.setText256(clr4b);\n\t\t\t\t\tgDisplayParm.setBrightFore(TRUE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 100: case 101: case 102: case 103: case 104: case 105: case 106: case 107:\n\t\t\t\t\tgDisplayParm.setBackColor((Code.ArgV[i] - 100) | 0x8);\n\t\t\t\t\tgDisplayParm.setBack256(clr4b);\n\t\t\t\t\tgDisplayParm.setBrightBack(TRUE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 10:  // NOLINT(bugprone-branch-clone)\n\t\t\t\t\t// Something strange and unknown... (received from ssh)\n\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 312:\n\t\t\t\tcase 315:\n\t\t\t\tcase 414:\n\t\t\t\tcase 3130:\n\t\t\t\t\t// Something strange and unknown... (received from vim on WSL)\n\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak; // \"[...m\"\n\n\tcase L'p':\n\t\tif (Code.ArgC == 0 && Code.PvtLen == 1 && Code.Pvt[0] == L'!')\n\t\t{\n\t\t\tFullReset(hConsoleOutput);\n\t\t\tlbApply = FALSE;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t}\n\t\tbreak; // \"[!p\"\n\n\tcase L'q':\n\t\tif ((Code.PvtLen == 1) && (Code.Pvt[0] == L' '))\n\t\t{\n\t\t\t/*\n\t\t\tCSI Ps SP q\n\t\t\t\tSet cursor style (DECSCUSR, VT520).\n\t\t\t\t\tPs = 0  -> ConEmu's default.\n\t\t\t\t\tPs = 1  -> blinking block.\n\t\t\t\t\tPs = 2  -> steady block.\n\t\t\t\t\tPs = 3  -> blinking underline.\n\t\t\t\t\tPs = 4  -> steady underline.\n\t\t\t\t\tPs = 5  -> blinking bar (xterm).\n\t\t\t\t\tPs = 6  -> steady bar (xterm).\n\t\t\t*/\n\t\t\tDWORD nStyle = ((Code.ArgC == 0) || (Code.ArgV[0] < 0) || (Code.ArgV[0] > 6))\n\t\t\t\t? 0 : Code.ArgV[0];\n\t\t\tCONSOLE_CURSOR_INFO ci = {};\n\t\t\tif (GetConsoleCursorInfo(hConsoleOutput, &ci))\n\t\t\t{\n\t\t\t\t// We can't implement all possible styles in RealConsole,\n\t\t\t\t// but we can use \"Block/Underline\" shapes...\n\t\t\t\tci.dwSize = (nStyle == 1 || nStyle == 2) ? 100 : 15;\n\t\t\t\tSetConsoleCursorInfo(hConsoleOutput, &ci);\n\t\t\t}\n\t\t\tChangeTermMode(tmc_CursorShape, nStyle);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t}\n\t\tbreak; // \"[...q\"\n\n\tcase L't':\n\t\tif (Code.ArgC > 0 && Code.ArgC <= 3)\n\t\t{\n\t\t\tfor (int i = 0; i < Code.ArgC; i++)\n\t\t\t{\n\t\t\t\tswitch (Code.ArgV[i])\n\t\t\t\t{\n\t\t\t\tcase 8:\n\t\t\t\t\t// `ESC [ 8 ; height ; width t` --> Resize the text area to [height;width] in characters.\n\t\t\t\t\t{\n\t\t\t\t\t\tint height = -1, width = -1;\n\t\t\t\t\t\tif (i < Code.ArgC)\n\t\t\t\t\t\t\theight = Code.ArgV[++i];\n\t\t\t\t\t\tif (i < Code.ArgC)\n\t\t\t\t\t\t\twidth = Code.ArgV[++i];\n\t\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored);\n\t\t\t\t\t\tstd::ignore = height;\n\t\t\t\t\t\tstd::ignore = width;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 14:\n\t\t\t\t\t// `ESC [ 1 4 t` --> Reports terminal window size in pixels as `CSI 4 ; height ; width t`.\n\t\t\t\t\tReportTerminalPixelSize();\n\t\t\t\t\tbreak;\n\t\t\t\tcase 18:\n\t\t\t\tcase 19:\n\t\t\t\t\t// `ESC [ 1 8 t` --> Report the size of the text area in characters as `CSI 8 ; height ; width t`\n\t\t\t\t\t// `ESC [ 1 9 t` --> Report the size of the screen in characters as `CSI 9 ; height ; width t`\n\t\t\t\t\tReportTerminalCharSize(hConsoleOutput, Code.ArgV[i]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 21:\n\t\t\t\t\t// `ESC [ 2 1 t` --> Report terminal window title as `OSC l title ST`\n\t\t\t\t\tReportConsoleTitle();\n\t\t\t\t\tbreak;\n\t\t\t\tcase 22:\n\t\t\t\tcase 23:\n\t\t\t\t\t// `ESC [ 2 2 ; 0 t` --> Save xterm icon and window title on stack.\n\t\t\t\t\t// `ESC [ 2 2 ; 1 t` --> Save xterm icon title on stack.\n\t\t\t\t\t// `ESC [ 2 2 ; 2 t` --> Save xterm window title on stack.\n\t\t\t\t\t// `ESC [ 2 3 ; 0 t` --> Restore xterm icon and window title from stack.\n\t\t\t\t\t// `ESC [ 2 3 ; 1 t` --> Restore xterm icon title from stack.\n\t\t\t\t\t// `ESC [ 2 3 ; 2 t` --> Restore xterm window title from stack.\n\t\t\t\t\tif (i < Code.ArgC)\n\t\t\t\t\t\t++i; // subcommand\n\t\t\t\t\tif (i < Code.ArgC && !Code.ArgV[i])\n\t\t\t\t\t\t++i; // strange sequence 22;0;0t\n\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tTODO(\"ANSI: xterm window manipulation\");\n\t\t\t\t\t//Window manipulation (from dtterm, as well as extensions). These controls may be disabled using the allowWindowOps resource. Valid values for the first (and any additional parameters) are:\n\t\t\t\t\t// 1 --> De-iconify window.\n\t\t\t\t\t// 2 --> Iconify window.\n\t\t\t\t\t// 3 ; x ; y --> Move window to [x, y].\n\t\t\t\t\t// 4 ; height ; width --> Resize the xterm window to height and width in pixels.\n\t\t\t\t\t// 5 --> Raise the xterm window to the front of the stacking order.\n\t\t\t\t\t// 6 --> Lower the xterm window to the bottom of the stacking order.\n\t\t\t\t\t// 7 --> Refresh the xterm window.\n\t\t\t\t\t// 8 ; height ; width --> Resize the text area to [height;width] in characters.\n\t\t\t\t\t// 9 ; 0 --> Restore maximized window.\n\t\t\t\t\t// 9 ; 1 --> Maximize window (i.e., resize to screen size).\n\t\t\t\t\t// 1 1 --> Report xterm window state. If the xterm window is open (non-iconified), it returns CSI 1 t . If the xterm window is iconified, it returns CSI 2 t .\n\t\t\t\t\t// 1 3 --> Report xterm window position as CSI 3 ; x; y t\n\t\t\t\t\t// 1 4 --> Report xterm window in pixels as CSI 4 ; height ; width t\n\t\t\t\t\t// 2 0 --> Report xterm window\ufffds icon label as OSC L label ST\n\t\t\t\t\t// >= 2 4 --> Resize to P s lines (DECSLPP)\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t}\n\t\tbreak;\n\n\tcase L'c':\n\t\t// echo -e \"\\e[>c\"\n\t\tif ((Code.PvtLen == 1) && (Code.Pvt[0] == L'>')\n\t\t\t&& ((Code.ArgC < 1) || (Code.ArgV[0] == 0)))\n\t\t{\n\t\t\t// P s = 0 or omitted -> request the terminal's identification code.\n\t\t\twchar_t szVerInfo[64];\n\t\t\t// this will be \"ESC > 67 ; build ; 0 c\"\n\t\t\t// 67 is ASCII code of 'C' (ConEmu, yeah)\n\t\t\t// Other terminals report examples: MinTTY -> 77, rxvt -> 82, screen -> 83\n\t\t\t// msprintf(szVerInfo, countof(szVerInfo), L\"\\x1B>%u;%u;0c\", (int)'C', MVV_1*10000+MVV_2*100+MVV_3);\n\t\t\t// Emulate xterm version 136?\n\t\t\twcscpy_c(szVerInfo, L\"\\x1B[>0;136;0c\");\n\t\t\tReportString(szVerInfo);\n\t\t}\n\t\t// echo -e \"\\e[c\"\n\t\telse if ((Code.ArgC < 1) || (Code.ArgV[0] == 0))\n\t\t{\n\t\t\t// Report \"VT100 with Advanced Video Option\"\n\t\t\tReportString(L\"\\x1B[?1;2c\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t}\n\t\tbreak;\n\n\tcase L'X':\n\t\t// CSI P s X:  Erase P s Character(s) (default = 1) (ECH)\n\t\tif (GetConsoleScreenBufferInfoCached(hConsoleOutput, &csbi))\n\t\t{\n\t\t\tif (lbApply)\n\t\t\t{\n\t\t\t\t// Apply default color before scrolling!\n\t\t\t\tReSetDisplayParm(hConsoleOutput, FALSE, TRUE);\n\t\t\t\tlbApply = FALSE;\n\t\t\t}\n\n\t\t\tint nCount = (Code.ArgC > 0) ? Code.ArgV[0] : 1;\n\t\t\tint nScreenLeft = csbi.dwSize.X - csbi.dwCursorPosition.X - 1 + (csbi.dwSize.X * (csbi.dwSize.Y - csbi.dwCursorPosition.Y - 1));\n\t\t\tint nChars = std::min(nCount,nScreenLeft);\n\t\t\tCOORD cr0 = csbi.dwCursorPosition;\n\n\t\t\tif (nChars > 0)\n\t\t\t{\n\t\t\t\tExtFillOutputParm fill = { sizeof(fill), efof_Current | efof_Attribute | efof_Character,\n\t\t\t\t\thConsoleOutput, {}, L' ', cr0, static_cast<DWORD>(nChars) };\n\t\t\t\tExtFillOutput(&fill);\n\t\t\t}\n\t\t} // case L'X':\n\t\tbreak;\n\n\tdefault:\n\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t} // switch (Code.Action)\n}\n\nvoid CEAnsi::WriteAnsiCode_OSC(OnWriteConsoleW_t writeConsoleW, HANDLE hConsoleOutput, AnsiEscCode& Code, BOOL& lbApply)\n{\n\tif (!Code.ArgSZ)\n\t{\n\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\treturn;\n\t}\n\n\t// Finalizing (ST) with \"\\x1B\\\\\" or \"\\x07\"\n\t//ESC ] 0 ; txt ST        Set icon name and window title to txt.\n\t//ESC ] 1 ; txt ST        Set icon name to txt.\n\t//ESC ] 2 ; txt ST        Set window title to txt.\n\t//ESC ] 4 ; num; txt ST   Set ANSI color num to txt.\n\t//ESC ] 9 ... ST          ConEmu specific\n\t//ESC ] 10 ; txt ST       Set dynamic text color to txt.\n\t//ESC ] 4 6 ; name ST     Change log file to name (normally disabled\n\t//\t\t\t\t\t      by a compile-time option)\n\t//ESC ] 5 0 ; fn ST       Set font to fn.\n\n\tswitch (*Code.ArgSZ)\n\t{\n\tcase L'0':\n\tcase L'1':\n\tcase L'2':\n\t\tif (Code.ArgSZ[1] == L';' && Code.ArgSZ[2])\n\t\t{\n\t\t\tCEStr pszNewTitle;\n\t\t\tif (pszNewTitle.GetBuffer(Code.cchArgSZ))\n\t\t\t{\n\t\t\t\tEscCopyCtrlString(pszNewTitle.data(), Code.ArgSZ + 2, Code.cchArgSZ - 2);\n\t\t\t\tSetConsoleTitle(pszNewTitle.c_str(gsInitConTitle));\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase L'4':\n\t\t// TODO: the following is suggestion for exact palette colors\n\t\t// TODO: but we are using standard xterm palette or truecolor 24bit palette\n\t\t_ASSERTEX(Code.ArgSZ[1] == L';');\n\t\tbreak;\n\n\tcase L'9':\n\t\t// ConEmu specific\n\t\t// ESC ] 9 ; 1 ; ms ST           Sleep. ms - milliseconds\n\t\t// ESC ] 9 ; 2 ; \"txt\" ST        Show GUI MessageBox ( txt ) for dubug purposes\n\t\t// ESC ] 9 ; 3 ; \"txt\" ST        Set TAB text\n\t\t// ESC ] 9 ; 4 ; st ; pr ST      When _st_ is 0: remove progress. When _st_ is 1: set progress value to _pr_ (number, 0-100).\n\t\t//                               When _st_ is 2: set error state in progress on Windows 7 taskbar, _pr_ is optional.\n\t\t//                               When _st_ is 3: set indeterminate state. When _st_ is 4: set paused state, _pr_ is optional.\n\t\t// ESC ] 9 ; 5 ST                Wait for ENTER/SPACE/ESC. Set EnvVar \"ConEmuWaitKey\" to ENTER/SPACE/ESC on exit.\n\t\t// ESC ] 9 ; 6 ; \"txt\" ST        Execute GuiMacro. Set EnvVar \"ConEmuMacroResult\" on exit.\n\t\t// ESC ] 9 ; 7 ; \"cmd\" ST        Run some process with arguments\n\t\t// ESC ] 9 ; 8 ; \"env\" ST        Output value of environment variable\n\t\t// ESC ] 9 ; 9 ; \"cwd\" ST        Inform ConEmu about shell current working directory\n\t\t// ESC ] 9 ; 10 ; p ST           Request xterm keyboard/output emulation\n\t\t// ESC ] 9 ; 11; \"*txt*\" ST      Just a \u2018comment\u2019, skip it.\n\t\t// ESC ] 9 ; 12 ST               Let ConEmu treat current cursor position as prompt start. Useful with `PS1`.\n\t\tif (Code.ArgSZ[1] == L';')\n\t\t{\n\t\t\tif (Code.ArgSZ[2] == L'1')\n\t\t\t{\n\t\t\t\tif (Code.ArgSZ[3] == L';')\n\t\t\t\t{\n\t\t\t\t\t// ESC ] 9 ; 1 ; ms ST\n\t\t\t\t\tDoSleep(Code.ArgSZ+4);\n\t\t\t\t}\n\t\t\t\telse if (Code.ArgC >= 2 && Code.ArgV[1] == 10)\n\t\t\t\t{\n\t\t\t\t\t// ESC ] 9 ; 10 ST\n\t\t\t\t\t// ESC ] 9 ; 10 ; 1 ST\n\t\t\t\t\tif (!gbIsXTermOutput && (Code.ArgC == 2 || Code.ArgV[2] == 1))\n\t\t\t\t\t{\n\t\t\t\t\t\tDBG_XTERM(L\"xTermOutput=ON due ESC]9;10;1ST\");\n\t\t\t\t\t\tDBG_XTERM(L\"AutoLfNl=OFF due ESC]9;10;1ST\");\n\t\t\t\t\t\tDBG_XTERM(L\"term=XTerm due ESC]9;10;1ST\");\n\t\t\t\t\t\tCEAnsi::StartXTermMode(true);\n\t\t\t\t\t}\n\t\t\t\t\t// ESC ] 9 ; 10 ; 0 ST\n\t\t\t\t\telse if (Code.ArgC >= 3 || Code.ArgV[2] == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tDBG_XTERM(L\"xTermOutput=OFF due ESC]9;10;0ST\");\n\t\t\t\t\t\tDBG_XTERM(L\"AutoLfNl=ON due ESC]9;10;0ST\");\n\t\t\t\t\t\tDBG_XTERM(L\"term=Win32 due ESC]9;10;0ST\");\n\t\t\t\t\t\tCEAnsi::StartXTermMode(false);\n\t\t\t\t\t}\n\t\t\t\t\t// ESC ] 9 ; 10 ; 3 ST\n\t\t\t\t\telse if (Code.ArgC >= 3 || Code.ArgV[2] == 3)\n\t\t\t\t\t{\n\t\t\t\t\t\tDBG_XTERM(L\"xTermOutput=ON due ESC]9;10;3ST\");\n\t\t\t\t\t\tDBG_XTERM(L\"AutoLfNl=OFF due ESC]9;10;3ST\");\n\t\t\t\t\t\tCEAnsi::StartXTermOutput(true);\n\t\t\t\t\t}\n\t\t\t\t\t// ESC ] 9 ; 10 ; 2 ST\n\t\t\t\t\telse if (Code.ArgC >= 3 || Code.ArgV[2] == 2)\n\t\t\t\t\t{\n\t\t\t\t\t\tDBG_XTERM(L\"xTermOutput=OFF due ESC]9;10;2ST\");\n\t\t\t\t\t\tDBG_XTERM(L\"AutoLfNl=ON due ESC]9;10;2ST\");\n\t\t\t\t\t\tCEAnsi::StartXTermOutput(false);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (Code.ArgSZ[3] == L'1' && Code.ArgSZ[4] == L';')\n\t\t\t\t{\n\t\t\t\t\t// ESC ] 9 ; 11; \"*txt*\" ST - Just a \u2018comment\u2019, skip it.\n\t\t\t\t\tDumpKnownEscape(Code.ArgSZ+5, lstrlen(Code.ArgSZ+5), de_Comment);\n\t\t\t\t}\n\t\t\t\telse if (Code.ArgSZ[3] == L'2')\n\t\t\t\t{\n\t\t\t\t\t// ESC ] 9 ; 12 ST\n\t\t\t\t\tStorePromptBegin();\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (Code.ArgSZ[2] == L'2' && Code.ArgSZ[3] == L';')\n\t\t\t{\n\t\t\t\tDoMessage(Code.ArgSZ+4, Code.cchArgSZ - 4);\n\t\t\t}\n\t\t\telse if (Code.ArgSZ[2] == L'3' && Code.ArgSZ[3] == L';')\n\t\t\t{\n\t\t\t\tCESERVER_REQ* pIn = ExecuteNewCmd(CECMD_SETTABTITLE, sizeof(CESERVER_REQ_HDR)+sizeof(wchar_t)*(Code.cchArgSZ));\n\t\t\t\tif (pIn)\n\t\t\t\t{\n\t\t\t\t\tEscCopyCtrlString(reinterpret_cast<wchar_t*>(pIn->wData), Code.ArgSZ+4, Code.cchArgSZ-4);\n\t\t\t\t\tCESERVER_REQ* pOut = ExecuteGuiCmd(ghConWnd, pIn, ghConWnd);\n\t\t\t\t\tExecuteFreeResult(pIn);\n\t\t\t\t\tExecuteFreeResult(pOut);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (Code.ArgSZ[2] == L'4')\n\t\t\t{\n\t\t\t\tAnsiProgressStatus st = AnsiProgressStatus::None;\n\t\t\t\tWORD pr = 0;\n\t\t\t\tconst wchar_t* pszName = nullptr;\n\t\t\t\tif (Code.ArgSZ[3] == L';')\n\t\t\t\t{\n\t\t\t\t\tswitch (Code.ArgSZ[4])\n\t\t\t\t\t{\n\t\t\t\t\tcase L'0':\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase L'1':\n\t\t\t\t\t\tst = AnsiProgressStatus::Running; break;\n\t\t\t\t\tcase L'2':\n\t\t\t\t\t\tst = AnsiProgressStatus::Error; break;\n\t\t\t\t\tcase L'3':\n\t\t\t\t\t\tst = AnsiProgressStatus::Indeterminate; break;\n\t\t\t\t\tcase L'4':\n\t\t\t\t\t\tst = AnsiProgressStatus::Paused; break;\n\t\t\t\t\tcase L'5': // reserved for future use\n\t\t\t\t\t\tst = AnsiProgressStatus::LongRunStart; break;\n\t\t\t\t\tcase L'6': // reserved for future use\n\t\t\t\t\t\tst = AnsiProgressStatus::LongRunStop; break;\n\t\t\t\t\t}\n\t\t\t\t\tif (st == AnsiProgressStatus::Running || st == AnsiProgressStatus::Error || st == AnsiProgressStatus::Paused)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (Code.ArgSZ[5] == L';')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tLPCWSTR pszValue = Code.ArgSZ + 6;\n\t\t\t\t\t\t\tpr = NextNumber(pszValue);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (st == AnsiProgressStatus::LongRunStart || st == AnsiProgressStatus::LongRunStop)\n\t\t\t\t\t{\n\t\t\t\t\t\tpszName = (Code.ArgSZ[5] == L';') ? (Code.ArgSZ + 6) : nullptr;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tGuiSetProgress(st, pr, pszName);\n\t\t\t}\n\t\t\telse if (Code.ArgSZ[2] == L'5')\n\t\t\t{\n\t\t\t\t//int s = 0;\n\t\t\t\t//if (Code.ArgSZ[3] == L';')\n\t\t\t\t//\ts = NextNumber(Code.ArgSZ+4);\n\t\t\t\tBOOL bSucceeded = FALSE;\n\t\t\t\tDWORD nRead = 0;\n\t\t\t\tINPUT_RECORD r = {};\n\t\t\t\t// ReSharper disable once CppLocalVariableMayBeConst\n\t\t\t\tHANDLE hIn = GetStdHandle(STD_INPUT_HANDLE);\n\t\t\t\t//DWORD nStartTick = GetTickCount();\n\t\t\t\twhile (((bSucceeded = ReadConsoleInput(hIn, &r, 1, &nRead))) && nRead)\n\t\t\t\t{\n\t\t\t\t\tif ((r.EventType == KEY_EVENT) && r.Event.KeyEvent.bKeyDown)\n\t\t\t\t\t{\n\t\t\t\t\t\tif ((r.Event.KeyEvent.wVirtualKeyCode == VK_RETURN)\n\t\t\t\t\t\t\t|| (r.Event.KeyEvent.wVirtualKeyCode == VK_SPACE)\n\t\t\t\t\t\t\t|| (r.Event.KeyEvent.wVirtualKeyCode == VK_ESCAPE))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (bSucceeded && ((r.Event.KeyEvent.wVirtualKeyCode == VK_RETURN)\n\t\t\t\t\t\t\t|| (r.Event.KeyEvent.wVirtualKeyCode == VK_SPACE)\n\t\t\t\t\t\t\t|| (r.Event.KeyEvent.wVirtualKeyCode == VK_ESCAPE)))\n\t\t\t\t{\n\t\t\t\t\tSetEnvironmentVariable(ENV_CONEMU_WAITKEY_W,\n\t\t\t\t\t\t(r.Event.KeyEvent.wVirtualKeyCode == VK_RETURN) ? L\"RETURN\" :\n\t\t\t\t\t\t(r.Event.KeyEvent.wVirtualKeyCode == VK_SPACE)  ? L\"SPACE\" :\n\t\t\t\t\t\t(r.Event.KeyEvent.wVirtualKeyCode == VK_ESCAPE) ? L\"ESC\" :\n\t\t\t\t\t\tL\"???\");\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSetEnvironmentVariable(ENV_CONEMU_WAITKEY_W, L\"\");\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (Code.ArgSZ[2] == L'6' && Code.ArgSZ[3] == L';')\n\t\t\t{\n\t\t\t\tDoGuiMacro(Code.ArgSZ+4, Code.cchArgSZ - 4);\n\t\t\t}\n\t\t\telse if (Code.ArgSZ[2] == L'7' && Code.ArgSZ[3] == L';')\n\t\t\t{\n\t\t\t\tDoProcess(Code.ArgSZ+4, Code.cchArgSZ - 4);\n\t\t\t}\n\t\t\telse if (Code.ArgSZ[2] == L'8' && Code.ArgSZ[3] == L';')\n\t\t\t{\n\t\t\t\tif (lbApply)\n\t\t\t\t{\n\t\t\t\t\tReSetDisplayParm(hConsoleOutput, FALSE, TRUE);\n\t\t\t\t\tlbApply = FALSE;\n\t\t\t\t}\n\t\t\t\tDoPrintEnv(Code.ArgSZ+4, Code.cchArgSZ - 4);\n\t\t\t}\n\t\t\telse if (Code.ArgSZ[2] == L'9' && Code.ArgSZ[3] == L';')\n\t\t\t{\n\t\t\t\tDoSendCWD(Code.ArgSZ+4, Code.cchArgSZ - 4);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t}\n}\n\nvoid CEAnsi::WriteAnsiCode_VIM(OnWriteConsoleW_t writeConsoleW, HANDLE hConsoleOutput, AnsiEscCode& Code, BOOL& lbApply)\n{\n\tif (!gbIsXTermOutput && !gnWriteProcessed)\n\t{\n\t\tDBG_XTERM(L\"xTermOutput=ON due Vim start\");\n\t\tDBG_XTERM(L\"AutoLfNl=OFF due Vim start\");\n\t\tDBG_XTERM(L\"term=XTerm due Vim start\");\n\t\tCEAnsi::StartXTermMode(true);\n\t}\n\n\tswitch (Code.Action)\n\t{\n\tcase L'm':\n\t\t// Set xterm display modes (colors, fonts, etc.)\n\t\tif (!Code.ArgC)\n\t\t{\n\t\t\t//ReSetDisplayParm(hConsoleOutput, TRUE, FALSE);\n\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor (int i = 0; i < Code.ArgC; i++)\n\t\t\t{\n\t\t\t\tswitch (Code.ArgV[i])\n\t\t\t\t{\n\t\t\t\tcase 7:\n\t\t\t\t\tgDisplayParm.setBrightOrBold(FALSE);\n\t\t\t\t\tgDisplayParm.setItalic(FALSE);\n\t\t\t\t\tgDisplayParm.setUnderline(FALSE);\n\t\t\t\t\tgDisplayParm.setBrightFore(FALSE);\n\t\t\t\t\tgDisplayParm.setBrightBack(FALSE);\n\t\t\t\t\tgDisplayParm.setInverse(FALSE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 15:\n\t\t\t\t\tgDisplayParm.setBrightOrBold(TRUE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 112:\n\t\t\t\t\tgDisplayParm.setInverse(TRUE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 143:\n\t\t\t\t\t// What is this?\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak; // \"|...m\"\n\t}\n}\n\n/// Returns coordinates of either working area (viewPort) or full backscroll buffer\n/// @param hConsoleOutput   if nullptr we process STD_OUTPUT_HANDLE\n/// @param viewPort         if true - returns srWindow, false - full backscroll buffer\n/// @result valid SMALL_RECT\nSMALL_RECT CEAnsi::GetWorkingRegion(HANDLE hConsoleOutput, bool viewPort) const\n{\n\tconst short kFallback = 9999;\n\tSMALL_RECT region = {0, 0, kFallback, kFallback};\n\t// ReSharper disable once CppLocalVariableMayBeConst\n\tHANDLE hConOut = hConsoleOutput ? hConsoleOutput : GetStdHandle(STD_OUTPUT_HANDLE);\n\tCONSOLE_SCREEN_BUFFER_INFO csbi = {};\n\t// If function fails, we return {kFallback, kFallback}\n\tif (GetConsoleScreenBufferInfoCached(hConOut, &csbi, TRUE))\n\t{\n\t\tif (viewPort)\n\t\t{\n\t\t\t// Trick to avoid overflow of SHORT\n\t\t\tregion = MakeSmallRect(\n\t\t\t\tstd::min<WORD>(static_cast<WORD>(csbi.srWindow.Left), std::numeric_limits<SHORT>::max()),\n\t\t\t\tstd::min<WORD>(static_cast<WORD>(csbi.srWindow.Top), std::numeric_limits<SHORT>::max()),\n\t\t\t\tstd::min<WORD>(static_cast<WORD>(csbi.srWindow.Right), std::numeric_limits<SHORT>::max()),\n\t\t\t\tstd::min<WORD>(static_cast<WORD>(csbi.srWindow.Bottom), std::numeric_limits<SHORT>::max())\n\t\t\t);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tregion = MakeSmallRect(\n\t\t\t\t0,\n\t\t\t\t0,\n\t\t\t\tstd::min<WORD>(static_cast<WORD>(csbi.dwSize.X - 1), std::numeric_limits<SHORT>::max()),\n\t\t\t\tstd::min<WORD>(static_cast<WORD>(csbi.dwSize.Y - 1), std::numeric_limits<SHORT>::max())\n\t\t\t);\n\t\t}\n\t\t// Last checks\n\t\tif (region.Right < region.Left)\n\t\t\tregion.Right = region.Left;\n\t\tif (region.Bottom < region.Top)\n\t\t\tregion.Bottom = region.Top;\n\t}\n\treturn region;\n}\n\nvoid CEAnsi::SetScrollRegion(bool bRegion, bool bRelative, int nStart, int nEnd, HANDLE hConsoleOutput) const\n{\n\tif (bRegion && (nStart >= 0) && (nStart <= nEnd))\n\t{\n\t\t// note: the '\\e[0;35r' shall be treated as '\\e[1;35r'\n\t\t_ASSERTE(nStart >= 0 && nEnd >= nStart);\n\t\tconst SMALL_RECT working = GetWorkingRegion(hConsoleOutput, bRelative);\n\t\t_ASSERTE(working.Top>=0 && working.Left>=0 && working.Bottom>=working.Top && working.Right>=working.Left);\n\t\tif (bRelative)\n\t\t{\n\t\t\tnStart += working.Top;\n\t\t\tnEnd += working.Top;\n\t\t}\n\t\t// We need 0-based absolute values\n\t\tgDisplayOpt.ScrollStart = static_cast<SHORT>(std::max<int>(working.Top, std::min<int>(nStart - 1, working.Bottom)));\n\t\tgDisplayOpt.ScrollEnd = static_cast<SHORT>(std::max<int>(working.Top, std::min<int>(nEnd - 1, working.Bottom)));\n\t\t// Validate\n\t\tif (!((gDisplayOpt.ScrollRegion = (gDisplayOpt.ScrollStart>=0 && gDisplayOpt.ScrollEnd>=gDisplayOpt.ScrollStart))))\n\t\t{\n\t\t\t_ASSERTEX(gDisplayOpt.ScrollStart>=0 && gDisplayOpt.ScrollEnd>=gDisplayOpt.ScrollStart);\n\t\t}\n\t\twchar_t szLog[40]; msprintf(szLog, countof(szLog), L\"{%i,%i}\", gDisplayOpt.ScrollStart, gDisplayOpt.ScrollEnd);\n\t}\n\telse\n\t{\n\t\tgDisplayOpt.ScrollRegion = FALSE;\n\t\tDumpKnownEscape(L\"<Disabled>\", 10, de_ScrollRegion);\n\t}\n}\n\nvoid CEAnsi::XTermSaveRestoreCursor(bool bSaveCursor, HANDLE hConsoleOutput /*= nullptr*/)\n{\n\tCONSOLE_SCREEN_BUFFER_INFO csbi = {};\n\t// ReSharper disable once CppLocalVariableMayBeConst\n\tHANDLE hConOut = hConsoleOutput ? hConsoleOutput : GetStdHandle(STD_OUTPUT_HANDLE);\n\n\tif (bSaveCursor)\n\t{\n\t\t// Save cursor position (can not be nested)\n\t\tif (GetConsoleScreenBufferInfoCached(hConOut, &csbi))\n\t\t{\n\t\t\tgDisplayCursor.StoredCursorPos = csbi.dwCursorPosition;\n\t\t\tgDisplayCursor.bCursorPosStored = TRUE;\n\t\t}\n\t}\n\telse\n\t{\n\t\t// Restore cursor position\n\t\tSetConsoleCursorPosition(hConOut, gDisplayCursor.StoredCursorPos);\n\t}\n}\n\nHANDLE CEAnsi::XTermBufferConEmuAlternative()\n{\n\tCONSOLE_SCREEN_BUFFER_INFO csbi1 = {}, csbi2 = {};\n\tHANDLE hOut = GetStdHandle(STD_OUTPUT_HANDLE);\n\t// ReSharper disable once CppLocalVariableMayBeConst\n\tHANDLE hErr = GetStdHandle(STD_ERROR_HANDLE);\n\tghStdOut.SetHandle(hOut, MConHandle::StdMode::Output);\n\tghStdErr.SetHandle(hErr, MConHandle::StdMode::Output);\n\tif (GetConsoleScreenBufferInfoCached(hOut, &csbi1, TRUE))\n\t{\n\t\t// -- Turn on \"alternative\" buffer even if not scrolling exist now\n\t\t//if (csbi.dwSize.Y > (csbi.srWindow.Bottom - csbi.srWindow.Top + 1))\n\t\t{\n\t\t\tCESERVER_REQ *pIn = nullptr, *pOut = nullptr;\n\t\t\tpIn = ExecuteNewCmd(CECMD_ALTBUFFER,sizeof(CESERVER_REQ_HDR)+sizeof(CESERVER_REQ_ALTBUFFER));\n\t\t\tif (pIn)\n\t\t\t{\n\t\t\t\tpIn->AltBuf.AbFlags = abf_BufferOff | abf_SaveContents;\n\t\t\t\tif (isConnectorStarted())\n\t\t\t\t\tpIn->AltBuf.AbFlags |= abf_Connector;\n\t\t\t\t// support \"virtual\" dynamic console buffer height\n\t\t\t\tif (CESERVER_CONSOLE_APP_MAPPING* pAppMap = gpAppMap ? gpAppMap->Ptr() : nullptr)\n\t\t\t\t\tpIn->AltBuf.BufferHeight = std::max(static_cast<SHORT>(pAppMap->nLastConsoleRow), csbi1.srWindow.Bottom);\n\t\t\t\telse\n\t\t\t\t\tpIn->AltBuf.BufferHeight = csbi1.srWindow.Bottom;\n\t\t\t\tpOut = ExecuteSrvCmd(gnServerPID, pIn, ghConWnd);\n\t\t\t\tif (pOut)\n\t\t\t\t{\n\t\t\t\t\tif (!IsWin7Eql())\n\t\t\t\t\t{\n\t\t\t\t\t\tghConOut.Close();\n\t\t\t\t\t\t// ReSharper disable once CppLocalVariableMayBeConst\n\t\t\t\t\t\tHANDLE hNewOut = ghConOut.GetHandle();\n\t\t\t\t\t\tif (hNewOut && hNewOut != INVALID_HANDLE_VALUE)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\thOut = hNewOut;\n\t\t\t\t\t\t\tSetStdHandle(STD_OUTPUT_HANDLE, hNewOut);\n\t\t\t\t\t\t\tSetStdHandle(STD_ERROR_HANDLE, hNewOut);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Ensure we have fresh information (size was changed)\n\t\t\t\t\tGetConsoleScreenBufferInfoCached(hOut, &csbi2, TRUE);\n\n\t\t\t\t\t// Clear current screen contents, don't move cursor position\n\t\t\t\t\tconst DWORD nChars = csbi2.dwSize.X * csbi2.dwSize.Y;\n\t\t\t\t\tExtFillOutputParm fill = {sizeof(fill), efof_Current|efof_Attribute|efof_Character,\n\t\t\t\t\t\thOut, {}, L' ', {}, static_cast<DWORD>(nChars) };\n\t\t\t\t\tExtFillOutput(&fill);\n\n\t\t\t\t\tTODO(\"BufferWidth\");\n\t\t\t\t\tif (!(gXTermAltBuffer.Flags & xtb_AltBuffer))\n\t\t\t\t\t{\n\t\t\t\t\t\t// Backscroll length\n\t\t\t\t\t\tgXTermAltBuffer.BufferSize = (csbi1.dwSize.Y > (csbi1.srWindow.Bottom - csbi1.srWindow.Top + 1))\n\t\t\t\t\t\t\t? csbi1.dwSize.Y : 0;\n\t\t\t\t\t\tgXTermAltBuffer.Flags = xtb_AltBuffer;\n\t\t\t\t\t\t// Stored cursor pos\n\t\t\t\t\t\tif (gDisplayCursor.bCursorPosStored)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tgXTermAltBuffer.CursorPos = gDisplayCursor.StoredCursorPos;\n\t\t\t\t\t\t\tgXTermAltBuffer.Flags |= xtb_StoredCursor;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Stored scroll region\n\t\t\t\t\t\tif (gDisplayOpt.ScrollRegion)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tgXTermAltBuffer.ScrollStart = gDisplayOpt.ScrollStart;\n\t\t\t\t\t\t\tgXTermAltBuffer.ScrollEnd = gDisplayOpt.ScrollEnd;\n\t\t\t\t\t\t\tgXTermAltBuffer.Flags |= xtb_StoredScrollRegion;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tExecuteFreeResult(pIn);\n\t\t\t\tExecuteFreeResult(pOut);\n\t\t\t}\n\t\t}\n\t}\n\treturn hOut;\n}\n\nHANDLE CEAnsi::XTermBufferConEmuPrimary()\n{\n\t// \u0421\u0431\u0440\u043e\u0441 \u0440\u0430\u0441\u0448\u0438\u0440\u0435\u043d\u043d\u044b\u0445 \u0430\u0442\u0440\u0438\u0431\u0443\u0442\u043e\u0432!\n\tCONSOLE_SCREEN_BUFFER_INFO csbi = {};\n\tHANDLE hOut = GetStdHandle(STD_OUTPUT_HANDLE);\n\tif (GetConsoleScreenBufferInfoCached(hOut, &csbi, TRUE))\n\t{\n\t\tconst WORD nDefAttr = GetDefaultTextAttr();\n\t\t// \u0421\u0431\u0440\u043e\u0441 \u0442\u043e\u043b\u044c\u043a\u043e \u0440\u0430\u0441\u0448\u0438\u0440\u0435\u043d\u043d\u044b\u0445 \u0430\u0442\u0440\u0438\u0431\u0443\u0442\u043e\u0432\n\t\tExtFillOutputParm fill = {sizeof(fill), /*efof_ResetExt|*/efof_Attribute/*|efof_Character*/, hOut,\n\t\t\t{ConEmu::ColorFlags::None, CONFORECOLOR(nDefAttr), CONBACKCOLOR(nDefAttr)},\n\t\t\tL' ', {0,0}, static_cast<DWORD>(csbi.dwSize.X * csbi.dwSize.Y)};\n\t\tExtFillOutput(&fill);\n\t\tCEAnsi* pObj = CEAnsi::Object();\n\t\tif (pObj)\n\t\t\tpObj->ReSetDisplayParm(hOut, TRUE, TRUE);\n\t\telse\n\t\t\tSetConsoleTextAttribute(hOut, nDefAttr);\n\t}\n\n\tif (!IsWin7Eql() && ghStdOut.HasHandle())\n\t{\n\t\tSetStdHandle(STD_OUTPUT_HANDLE, ghStdOut);\n\t\tSetStdHandle(STD_ERROR_HANDLE, ghStdErr);\n\t\thOut = ghStdOut.Release();\n\t\tghConOut.Close();\n\t}\n\n\t// restore backscroll size and data\n\tCESERVER_REQ *pIn = nullptr, *pOut = nullptr;\n\tpIn = ExecuteNewCmd(CECMD_ALTBUFFER,sizeof(CESERVER_REQ_HDR)+sizeof(CESERVER_REQ_ALTBUFFER));\n\tif (pIn)\n\t{\n\t\tTODO(\"BufferWidth\");\n\t\tpIn->AltBuf.AbFlags = abf_BufferOn | abf_RestoreContents;\n\t\tif (!gXTermAltBuffer.BufferSize)\n\t\t\tpIn->AltBuf.AbFlags |= abf_BufferOff;\n\t\tif (isConnectorStarted())\n\t\t\tpIn->AltBuf.AbFlags |= abf_Connector;\n\t\tpIn->AltBuf.BufferHeight = static_cast<USHORT>(gXTermAltBuffer.BufferSize);\n\t\t// Async - is not allowed. Otherwise current application (cmd.exe for example)\n\t\t// may start printing before server finishes buffer restoration\n\t\tpOut = ExecuteSrvCmd(gnServerPID, pIn, ghConWnd);\n\t\tExecuteFreeResult(pIn);\n\t\tExecuteFreeResult(pOut);\n\t\t// Restore saved states\n\t\tif ((gDisplayCursor.bCursorPosStored = !!(gXTermAltBuffer.Flags & xtb_StoredCursor)))\n\t\t{\n\t\t\tgDisplayCursor.StoredCursorPos = gXTermAltBuffer.CursorPos;\n\t\t}\n\t\tif ((gDisplayOpt.ScrollRegion = !!(gXTermAltBuffer.Flags & xtb_StoredScrollRegion)))\n\t\t{\n\t\t\tgDisplayOpt.ScrollStart = gXTermAltBuffer.ScrollStart;\n\t\t\tgDisplayOpt.ScrollEnd = gXTermAltBuffer.ScrollEnd;\n\t\t}\n\t}\n\treturn hOut;\n}\n\n#if 0\nHANDLE CEAnsi::XTermBufferWin10(const int mode, const bool bSetAltBuffer)\n{\n\tORIGINAL_KRNL(WriteFile);\n\tconst HANDLE std_out = GetStdHandle(STD_OUTPUT_HANDLE);\n\tchar ansi_seq[32];\n\tsprintf_c(ansi_seq, \"\\x1b[?%i%c\", mode, bSetAltBuffer ? 'h' : 'l');\n\tconst DWORD write_len = static_cast<DWORD>(strlen(ansi_seq));\n\tDWORD written = 0;\n\tconst auto rc = F(WriteFile)(std_out, ansi_seq, write_len, &written, nullptr);\n\t_ASSERTEX(rc && written == write_len);\n\treturn std_out;\n}\n#endif\n\n/// Change current buffer\n/// Alternative buffer in XTerm is used to \"fullscreen\"\n/// applications like Vim. There is no scrolling and this\n/// mode is used to save current backscroll contents and\n/// restore it when application exits\nHANDLE CEAnsi::XTermAltBuffer(const bool bSetAltBuffer, const int mode)\n{\n\tif (bSetAltBuffer)\n\t{\n\t\t// Once!\n\t\tif ((gXTermAltBuffer.Flags & xtb_AltBuffer))\n\t\t\treturn GetStdHandle(STD_OUTPUT_HANDLE);\n\n\t\t#if 0\n\t\t// Can utilize Conhost V2 ANSI?\n\t\tif (gbIsSshProcess && IsWin10())\n\t\t{\n\t\t\tgXTermAltBuffer.Flags |= xtb_AltBuffer;\n\t\t\treturn XTermBufferWin10(mode, bSetAltBuffer);\n\t\t}\n\t\t#endif\n\n\t\treturn XTermBufferConEmuAlternative();\n\t}\n\telse\n\t{\n\t\tif (!(gXTermAltBuffer.Flags & xtb_AltBuffer))\n\t\t\treturn GetStdHandle(STD_OUTPUT_HANDLE);\n\n\t\t// Once!\n\t\tgXTermAltBuffer.Flags &= ~xtb_AltBuffer;\n\n\t\t#if 0\n\t\t// Can utilize Conhost V2 ANSI?\n\t\tif (gbIsSshProcess && IsWin10())\n\t\t\treturn XTermBufferWin10(mode, bSetAltBuffer);\n\t\t#endif\n\n\t\treturn XTermBufferConEmuPrimary();\n\t}\n}\n\n/*\nViM need some hacks in current ConEmu versions\nThis is because\n1) 256 colors mode requires NO scroll buffer\n2) can't find ATM legal way to switch Alternative/Primary buffer by request from ViM\n*/\n\nHANDLE CEAnsi::StartVimTerm(bool bFromDllStart)\n{\n\t// Only certain versions of Vim able to use xterm-256 in ConEmu\n\tif (gnExeFlags & (caf_Cygwin1|caf_Msys1|caf_Msys2))\n\t\treturn GetStdHandle(STD_OUTPUT_HANDLE);\n\n\t// For native vim - don't handle \"--help\" and \"--version\" switches\n\t// Has no sense for cygwin/msys, but they are skipped above\n\tCmdArg lsArg;\n\tLPCWSTR pszCmdLine = GetCommandLineW();\n\tLPCWSTR pszCompare[] = {L\"--help\", L\"-h\", L\"--version\", nullptr};\n\twhile ((pszCmdLine = NextArg(pszCmdLine, lsArg)))\n\t{\n\t\tfor (INT_PTR i = 0; pszCompare[i]; i++)\n\t\t{\n\t\t\tif (wcscmp(lsArg, pszCompare[i]) == 0)\n\t\t\t\treturn GetStdHandle(STD_OUTPUT_HANDLE);\n\t\t}\n\t}\n\n\treturn XTermAltBuffer(true);\n}\n\nHANDLE CEAnsi::StopVimTerm()\n{\n\tif (gbIsXTermOutput)\n\t{\n\t\tDBG_XTERM(L\"xTermOutput=OFF due Vim stop\");\n\t\tDBG_XTERM(L\"AutoLfNl=ON due Vim stop\");\n\t\tDBG_XTERM(L\"term=Win32 due Vim stop\");\n\t\tCEAnsi::StartXTermMode(false);\n\t}\n\n\treturn XTermAltBuffer(false);\n}\n\nvoid CEAnsi::InitTermMode()\n{\n\tbool needSetXterm = false;\n\n\tif (IsWin10())\n\t{\n\t\tconst MHandle hOut{ GetStdHandle(STD_OUTPUT_HANDLE) };\n\t\tgPrevConOutMode = 0;\n\t\tif (GetConsoleMode(hOut, &gPrevConOutMode))\n\t\t{\n\t\t\tif (gPrevConOutMode & ENABLE_VIRTUAL_TERMINAL_PROCESSING)\n\t\t\t{\n\t\t\t\tneedSetXterm = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (gbIsVimProcess)\n\t{\n\t\tStartVimTerm(true);\n\t\t_ASSERTE(CEAnsi::gbIsXTermOutput == true);\n\t}\n\n\tif (needSetXterm)\n\t{\n\t\tDBG_XTERM(L\"xTermOutput=ON due ENABLE_VIRTUAL_TERMINAL_PROCESSING in InitTermMode\");\n\t\tDBG_XTERM(L\"AutoLfNl=OFF due ENABLE_VIRTUAL_TERMINAL_PROCESSING in InitTermMode\");\n\t\tDBG_XTERM(L\"term=XTerm due ENABLE_VIRTUAL_TERMINAL_PROCESSING in InitTermMode\");\n\t\tStartXTermMode(true);\n\t}\n\n\tif (CEAnsi::gbIsXTermOutput && gPrevConOutMode)\n\t{\n\t\tconst bool autoLfNl = (gPrevConOutMode & DISABLE_NEWLINE_AUTO_RETURN) == 0;\n\t\tif (CEAnsi::IsAutoLfNl() != autoLfNl)\n\t\t{\n\t\t\tCEAnsi::SetAutoLfNl(autoLfNl);\n\t\t}\n\t}\n}\n\nvoid CEAnsi::DoneTermMode()\n{\n\tif (gbIsXTermOutput && (gPrevConOutMode & ENABLE_VIRTUAL_TERMINAL_PROCESSING))\n\t{\n\t\t// If XTerm was enabled already before process start, no need to disable it\n\t\tDBG_XTERM(L\"xTermOutput=OFF due previous !ENABLE_VIRTUAL_TERMINAL_PROCESSING in DoneTermMode\");\n\t\tSetIsXTermOutput(false); // just reset\n\t}\n\n\tif (gbIsVimProcess)\n\t{\n\t\tDBG_XTERM(L\"StopVimTerm in DoneTermMode\");\n\t\tStopVimTerm();\n\t}\n\telse if (CEAnsi::gbIsXTermOutput)\n\t{\n\t\tDBG_XTERM(L\"xTermOutput=OFF in DoneTermMode\");\n\t\tDBG_XTERM(L\"AutoLfNl=ON in DoneTermMode\");\n\t\tDBG_XTERM(L\"term=Win32 in DoneTermMode\");\n\t\tStartXTermMode(false);\n\t}\n}\n\nvoid CEAnsi::ChangeTermMode(TermModeCommand mode, DWORD value, DWORD nPID /*= 0*/)\n{\n\tCESERVER_REQ* pIn = ExecuteNewCmd(CECMD_STARTXTERM, sizeof(CESERVER_REQ_HDR) + 3 * sizeof(DWORD));\n\tif (pIn)\n\t{\n\t\tpIn->dwData[0] = mode;\n\t\tpIn->dwData[1] = value;  // NOLINT(clang-diagnostic-array-bounds)\n\t\tpIn->dwData[2] = nPID ? nPID : GetCurrentProcessId();  // NOLINT(clang-diagnostic-array-bounds)\n\t\tCESERVER_REQ* pOut = ExecuteSrvCmd(gnServerPID, pIn, ghConWnd);\n\t\tExecuteFreeResult(pIn);\n\t\tExecuteFreeResult(pOut);\n\t}\n\n\tif (mode < countof(gWasXTermModeSet))\n\t{\n\t\tgWasXTermModeSet[mode] = { value, nPID ? nPID : GetCurrentProcessId() };\n\t}\n}\n\nvoid CEAnsi::StartXTermMode(const bool bStart)\n{\n\t// May be triggered by connector, official Vim builds, ENABLE_VIRTUAL_TERMINAL_INPUT, \"ESC ] 9 ; 10 ; 1 ST\"\n\t_ASSERTEX(gbIsXTermOutput != bStart);\n\n\tStartXTermOutput(bStart);\n\n\t// Remember last mode and pass to server\n\tChangeTermMode(tmc_TerminalType, bStart ? te_xterm : te_win32);\n}\n\nvoid CEAnsi::SetIsXTermOutput(const bool value)\n{\n\tif (gbIsXTermOutput != value)\n\t{\n\t\tgbIsXTermOutput = value;\n\t}\n}\n\nvoid CEAnsi::DebugXtermOutput(const wchar_t* message)\n{\n#ifdef _DEBUG\n\twchar_t dbgOut[512];\n\tmsprintf(dbgOut, countof(dbgOut), L\"XTerm: %s PID=%u TID=%u: %s\\n\",\n\t\tgsExeName, GetCurrentProcessId(), GetCurrentThreadId(), message);\n\tOutputDebugStringW(dbgOut);\n#endif\n}\n\nvoid CEAnsi::StartXTermOutput(const bool bStart)\n{\n\t// Remember last mode\n\tSetIsXTermOutput(bStart);\n\t// Set AutoLfNl according to mode\n\tSetAutoLfNl(bStart ? false : true);\n}\n\nvoid CEAnsi::RefreshXTermModes()\n{\n\tif (!gbIsXTermOutput)\n\t\treturn;\n\tfor (int i = 0; i < static_cast<int>(countof(gWasXTermModeSet)); ++i)\n\t{\n\t\tif (!gWasXTermModeSet[i].pid)\n\t\t\tcontinue;\n\t\t_ASSERTE(i != tmc_ConInMode);\n\t\tChangeTermMode(static_cast<TermModeCommand>(i), gWasXTermModeSet[i].value, gWasXTermModeSet[i].pid);\n\t}\n}\n\nvoid CEAnsi::SetAutoLfNl(const bool autoLfNl)\n{\n\tif (static_cast<bool>(gDisplayOpt.AutoLfNl) != autoLfNl)\n\t{\n\t\tgDisplayOpt.AutoLfNl = autoLfNl;\n\t}\n}\n\nbool CEAnsi::IsAutoLfNl()\n{\n\t// #TODO check for gbIsXTermOutput?\n\treturn gDisplayOpt.AutoLfNl;\n}\n\n// This is useful when user press Shift+Home,\n// we'll select only \"typed command\" part, without \"prompt\"\nvoid CEAnsi::StorePromptBegin()\n{\n\tCONSOLE_SCREEN_BUFFER_INFO csbi = {};\n\t// ReSharper disable once CppLocalVariableMayBeConst\n\tHANDLE hConOut = GetStdHandle(STD_OUTPUT_HANDLE);\n\tif (GetConsoleScreenBufferInfo(hConOut, &csbi))\n\t{\n\t\tOnReadConsoleBefore(hConOut, csbi);\n\t}\n}\n\nvoid CEAnsi::StorePromptReset()\n{\n\tCESERVER_CONSOLE_APP_MAPPING* pAppMap = gpAppMap ? gpAppMap->Ptr() : nullptr;\n\tif (pAppMap)\n\t{\n\t\tpAppMap->csbiPreRead.dwCursorPosition = COORD{0, 0};\n\t}\n}\n\n\n//static, thread local singleton\nCEAnsi* CEAnsi::Object()\n{\n\tCLastErrorGuard errGuard;\n\n\tif (!gAnsiTlsIndex)\n\t{\n\t\tgAnsiTlsIndex = TlsAlloc();\n\t}\n\n\tif ((!gAnsiTlsIndex) || (gAnsiTlsIndex == TLS_OUT_OF_INDEXES))\n\t{\n\t\t_ASSERTEX(gAnsiTlsIndex && gAnsiTlsIndex != TLS_OUT_OF_INDEXES);\n\t\treturn nullptr;\n\t}\n\n\t// Don't use thread_local, it doesn't work in WinXP in dynamically loaded dlls\n\tCEAnsi* obj = static_cast<CEAnsi*>(TlsGetValue(gAnsiTlsIndex));\n\tif (!obj)\n\t{\n\t\tobj = new CEAnsi;\n\t\tif (obj)\n\t\t\tobj->GetDefaultTextAttr(); // Initialize \"default attributes\"\n\t\tTlsSetValue(gAnsiTlsIndex, obj);\n\t}\n\n\treturn obj;\n}\n\n//static\nvoid CEAnsi::Release()\n{\n\tif (gAnsiTlsIndex && (gAnsiTlsIndex != TLS_OUT_OF_INDEXES))\n\t{\n\t\tCEAnsi* p = static_cast<CEAnsi*>(TlsGetValue(gAnsiTlsIndex));\n\t\tif (p)\n\t\t{\n\t\t\tif (IsHeapInitialized())\n\t\t\t{\n\t\t\t\tdelete p;\n\t\t\t}\n\t\t\tTlsSetValue(gAnsiTlsIndex, nullptr);\n\t\t}\n\t}\n}\n"], "fixing_code": ["\ufeff\n/*\nCopyright (c) 2012-present Maximus5\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions\nare met:\n1. Redistributions of source code must retain the above copyright\n   notice, this list of conditions and the following disclaimer.\n2. Redistributions in binary form must reproduce the above copyright\n   notice, this list of conditions and the following disclaimer in the\n   documentation and/or other materials provided with the distribution.\n3. The name of the authors may not be used to endorse or promote products\n   derived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE AUTHOR ''AS IS'' AND ANY EXPRESS OR\nIMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\nOF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\nIN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,\nINCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\nNOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\nTHIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n\n#include \"ConsoleMain.h\"\n#include <winerror.h>\n#include <winnt.h>\n#include <tchar.h>\n#include <limits>\n#include \"../common/Common.h\"\n#include \"../common/ConEmuCheck.h\"\n#include \"../common/CmdLine.h\"\n#include \"../common/WConsole.h\"\n#include \"../ConEmu/version.h\"\n\n#include \"ConAnsiImpl.h\"\n#include \"ConEmuSrv.h\"\n#include \"ConsoleState.h\"\n\n#ifdef _DEBUG\n\t#define DUMP_CONSOLE_OUTPUT\n#endif\n\n\n\n#ifdef _DEBUG\n#define DebugString(x) OutputDebugString(x)\n#define DebugStringA(x) OutputDebugStringA(x)\n#else\n#define DebugString(x) //OutputDebugString(x)\n#define DebugStringA(x) //OutputDebugStringA(x)\n#endif\n\n#ifdef DUMP_UNKNOWN_ESCAPES\n#define DumpUnknownEscape(buf, cchLen) m_Owner->DumpEscape(buf, cchLen, SrvAnsi::de_Unknown)\n#define DumpKnownEscape(buf, cchLen, eType) m_Owner->DumpEscape(buf, cchLen, eType)\n#else\n#define DumpUnknownEscape(buf,cchLen)\n#define DumpKnownEscape(buf, cchLen, eType)\n#endif\n\n\n\nSrvAnsiImpl::SrvAnsiImpl(SrvAnsi* _owner, condata::Table* _table)\n\t: m_UseLock(_owner->m_UseMutex)\n\t, m_Owner(_owner)\n\t, m_Table(_table)\n{\n\tm_Owner->GetFeatures(nullptr, &m_Owner->mb_SuppressBells);\n}\n\nSrvAnsiImpl::~SrvAnsiImpl()\n{\n}\n\n\nbool SrvAnsiImpl::OurWriteConsole(const wchar_t* lpBuffer, DWORD nNumberOfCharsToWrite, LPDWORD lpNumberOfCharsWritten)\n{\n\tbool lbRc = false;\n\n\t// For debugger breakpoint\n\tm_Owner->FirstAnsiCall((const BYTE*)lpBuffer, nNumberOfCharsToWrite);\n\t// In debug builds: Write to debug console all console Output\n\tDumpKnownEscape((wchar_t*)lpBuffer, nNumberOfCharsToWrite, SrvAnsi::de_Normal);\n\n\t// Logging?\n\tif (lpBuffer && nNumberOfCharsToWrite && m_Owner->ghAnsiLogFile)\n\t{\n\t\tm_Owner->WriteAnsiLogW(lpBuffer, nNumberOfCharsToWrite);\n\t}\n\n\tCEStr CpCvt;\n\n\tif (lpBuffer && nNumberOfCharsToWrite)\n\t{\n\t\t// if that was API call of WriteConsoleW\n\t\tif (m_Owner->gCpConv.nFromCP && m_Owner->gCpConv.nToCP)\n\t\t{\n\t\t\t// Convert from Unicode to MBCS\n\t\t\tint iMBCSLen = WideCharToMultiByte(m_Owner->gCpConv.nFromCP, 0, (LPCWSTR)lpBuffer, nNumberOfCharsToWrite, nullptr, 0, nullptr, nullptr);\n\t\t\tif (iMBCSLen > 0)\n\t\t\t{\n\t\t\t\tCEStrA szTemp;\n\t\t\t\tif (char* pszTemp = szTemp.GetBuffer(iMBCSLen))\n\t\t\t\t{\n\t\t\t\t\tBOOL bFailed = FALSE; // Do not do conversion if some chars can't be mapped\n\t\t\t\t\tiMBCSLen = WideCharToMultiByte(m_Owner->gCpConv.nFromCP, 0, (LPCWSTR)lpBuffer, nNumberOfCharsToWrite, pszTemp, iMBCSLen, nullptr, &bFailed);\n\t\t\t\t\tif ((iMBCSLen > 0) && !bFailed)\n\t\t\t\t\t{\n\t\t\t\t\t\tint iWideLen = MultiByteToWideChar(m_Owner->gCpConv.nToCP, 0, pszTemp, iMBCSLen, nullptr, 0);\n\t\t\t\t\t\tif (iWideLen > 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (wchar_t* ptrBuf = CpCvt.GetBuffer(iWideLen))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tiWideLen = MultiByteToWideChar(m_Owner->gCpConv.nToCP, 0, pszTemp, iMBCSLen, ptrBuf, iWideLen);\n\t\t\t\t\t\t\t\tif (iWideLen > 0)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tlpBuffer = ptrBuf;\n\t\t\t\t\t\t\t\t\tnNumberOfCharsToWrite = iWideLen;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t_ASSERTE(m_Owner->m_BellsCounter == 0);\n\tm_Owner->m_BellsCounter = 0;\n\n\t// The output\n\tlbRc = WriteAnsiCodes(lpBuffer, nNumberOfCharsToWrite, lpNumberOfCharsWritten);\n\n\t// Bells counter?\n\tif (m_Owner->m_BellsCounter)\n\t{\n\t\t// User may disable flashing in ConEmu settings\n\t\tCESERVER_REQ *pIn = ExecuteNewCmd(CECMD_FLASHWINDOW, sizeof(CESERVER_REQ_HDR)+sizeof(CESERVER_REQ_FLASHWINFO));\n\t\tif (pIn)\n\t\t{\n\t\t\tExecutePrepareCmd(pIn, CECMD_FLASHWINDOW, sizeof(CESERVER_REQ_HDR)+sizeof(CESERVER_REQ_FLASHWINFO)); //-V119\n\t\t\tpIn->Flash.fType = eFlashBeep;\n\t\t\tpIn->Flash.hWnd = gState.realConWnd_;\n\t\t\tpIn->Flash.bInvert = FALSE;\n\t\t\tpIn->Flash.dwFlags = FLASHW_ALL;\n\t\t\tpIn->Flash.uCount = 1;\n\t\t\tpIn->Flash.dwTimeout = 0;\n\t\t\tauto pOut = ExecuteGuiCmd(gState.realConWnd_, pIn, gState.realConWnd_);\n\t\t\tif (pOut) ExecuteFreeResult(pOut);\n\t\t\tExecuteFreeResult(pIn);\n\t\t}\n\t\tm_Owner->m_BellsCounter = 0;\n\t}\n\treturn lbRc;\n}\n\nbool SrvAnsiImpl::WriteText(LPCWSTR lpBuffer, DWORD nNumberOfCharsToWrite, LPDWORD lpNumberOfCharsWritten)\n{\n\tDWORD /*nWritten = 0,*/ nTotalWritten = 0;\n\n\tif (lpBuffer && nNumberOfCharsToWrite)\n\t\tm_Owner->m_LastWrittenChar = lpBuffer[nNumberOfCharsToWrite-1];\n\n\tLPCWSTR pszSrcBuffer = lpBuffer;\n\twchar_t cvtBuf[400], *pcvtBuf = nullptr; CEStr szTemp;\n\tif (m_Owner->mCharSet && lpBuffer && nNumberOfCharsToWrite)\n\t{\n\t\tstatic wchar_t G0_DRAWING[31] = {\n\t\t\t0x2666 /*\u2666*/, 0x2592 /*\u2592*/, 0x2192 /*\u2192*/, 0x21A8 /*\u21a8*/, 0x2190 /*\u2190*/, 0x2193 /*\u2193*/, 0x00B0 /*\u00b0*/, 0x00B1 /*\u00b1*/,\n\t\t\t0x00B6 /*\u00b6*/, 0x2195 /*\u2195*/, 0x2518 /*\u2518*/, 0x2510 /*\u2510*/, 0x250C /*\u250c*/, 0x2514 /*\u2514*/, 0x253C /*\u253c*/, 0x203E /*\u203e*/,\n\t\t\t0x207B /*\u207b*/, 0x2500 /*\u2500*/, 0x208B /*\u208b*/, 0x005F /*_*/, 0x251C /*\u251c*/, 0x2524 /*\u2524*/, 0x2534 /*\u2534*/, 0x252C /*\u252c*/,\n\t\t\t0x2502 /*\u2502*/, 0x2264 /*\u2264*/, 0x2265 /*\u2265*/, 0x03C0 /*\u03c0*/, 0x2260 /*\u2260*/, 0x00A3 /*\u00a3*/, 0x00B7 /*\u00b7*/\n\t\t};\n\t\tLPCWSTR pszMap = nullptr;\n\t\t// ReSharper disable once CppIncompleteSwitchStatement\n\t\tswitch (m_Owner->mCharSet)\n\t\t{\n\t\tcase SrvAnsi::VTCS_DRAWING:\n\t\t\tpszMap = G0_DRAWING;\n\t\t\tbreak;\n\t\t}\n\t\tif (pszMap)\n\t\t{\n\t\t\twchar_t* dst = nullptr;\n\t\t\tfor (DWORD i = 0; i < nNumberOfCharsToWrite; ++i)\n\t\t\t{\n\t\t\t\tif (pszSrcBuffer[i] >= 0x60 && pszSrcBuffer[i] < 0x7F)\n\t\t\t\t{\n\t\t\t\t\tif (!pcvtBuf)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (nNumberOfCharsToWrite <= countof(cvtBuf))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tpcvtBuf = cvtBuf;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (!((pcvtBuf = szTemp.GetBuffer(nNumberOfCharsToWrite))))\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlpBuffer = pcvtBuf;\n\t\t\t\t\t\tdst = pcvtBuf;\n\t\t\t\t\t\tif (i)\n\t\t\t\t\t\t\tmemmove_s(dst, nNumberOfCharsToWrite * sizeof(*dst), pszSrcBuffer, i * sizeof(*dst));\n\t\t\t\t\t}\n\t\t\t\t\tdst[i] = pszMap[pszSrcBuffer[i] - 0x60];\n\t\t\t\t}\n\t\t\t\telse if (dst)\n\t\t\t\t{\n\t\t\t\t\tdst[i] = pszSrcBuffer[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tm_Table->Write(lpBuffer, nNumberOfCharsToWrite);\n\n\tif (lpNumberOfCharsWritten)\n\t\t*lpNumberOfCharsWritten = nNumberOfCharsToWrite;\n\n\treturn true;\n}\n\n//struct AnsiEscCode\n//{\n//\twchar_t  First;  // ESC (27)\n//\twchar_t  Second; // any of 64 to 95 ('@' to '_')\n//\twchar_t  Action; // any of 64 to 126 (@ to ~). this is terminator\n//\twchar_t  Skip;   // \u0415\u0441\u043b\u0438 !=0 - \u0442\u043e \u044d\u0442\u0443 \u043f\u043e\u0441\u043b\u0435\u0434\u043e\u0432\u0430\u0442\u0435\u043b\u044c\u043d\u043e\u0441\u0442\u044c \u043d\u0443\u0436\u043d\u043e \u043f\u0440\u043e\u043f\u0443\u0441\u0442\u0438\u0442\u044c\n//\tint      ArgC;\n//\tint      ArgV[16];\n//\tLPCWSTR  ArgSZ; // Reserved for key mapping\n//\tsize_t   cchArgSZ;\n//\n//#ifdef _DEBUG\n//\tLPCWSTR  pszEscStart;\n//\tsize_t   nTotalLen;\n//#endif\n//\n//\tint      PvtLen;\n//\twchar_t  Pvt[16];\n//};\n\n\n// 0 - \u043d\u0435\u0442 (\u0432 lpBuffer \u0442\u043e\u043b\u044c\u043a\u043e \u0442\u0435\u043a\u0441\u0442)\n// 1 - \u0432 Code \u043f\u043e\u043c\u0435\u0449\u0435\u043d\u0430 Esc \u043f\u043e\u0441\u043b\u0435\u0434\u043e\u0432\u0430\u0442\u0435\u043b\u044c\u043d\u043e\u0441\u0442\u044c (\u043c\u043e\u0436\u0435\u0442 \u0431\u044b\u0442\u044c \u043f\u0440\u043e\u0441\u0442\u043e\u0439 \u0442\u0435\u043a\u0441\u0442 \u0414\u041e \u043d\u0435\u0435)\n// 2 - \u043d\u0435\u0442, \u043d\u043e \u043a\u0443\u0441\u043e\u043a \u043f\u043e\u0441\u043b\u0435\u0434\u043e\u0432\u0430\u0442\u0435\u043b\u044c\u043d\u043e\u0441\u0442\u0438 \u0441\u043e\u0445\u0440\u0430\u043d\u0435\u043d \u0432 gsPrevAnsiPart\nint SrvAnsiImpl::NextEscCode(LPCWSTR lpBuffer, LPCWSTR lpEnd, wchar_t (&szPreDump)[SrvAnsi::CEAnsi_MaxPrevPart], DWORD& cchPrevPart, LPCWSTR& lpStart, LPCWSTR& lpNext, SrvAnsiImpl::AnsiEscCode& Code, bool ReEntrance /*= FALSE*/)\n{\n\tint iRc = 0;\n\twchar_t wc;\n\n\tLPCWSTR lpSaveStart = lpBuffer;\n\tlpStart = lpBuffer;\n\n\t_ASSERTEX(cchPrevPart==0);\n\n\tauto& gsPrevAnsiPart = m_Owner->gsPrevAnsiPart;\n\tauto& gnPrevAnsiPart = m_Owner->gnPrevAnsiPart;\n\tauto& gsPrevAnsiPart2 = m_Owner->gsPrevAnsiPart2;\n\tauto& gnPrevAnsiPart2 = m_Owner->gnPrevAnsiPart2;\n\n\tif (gnPrevAnsiPart && !ReEntrance)\n\t{\n\t\tif (*gsPrevAnsiPart == 27)\n\t\t{\n\t\t\t_ASSERTEX(gnPrevAnsiPart < 79);\n\t\t\tssize_t nCurPrevLen = gnPrevAnsiPart;\n\t\t\tssize_t nAdd = std::min((lpEnd-lpBuffer),(ssize_t)countof(gsPrevAnsiPart)-nCurPrevLen-1);\n\t\t\t// Need to check buffer overflow!!!\n\t\t\t_ASSERTEX((ssize_t)countof(gsPrevAnsiPart)>(nCurPrevLen+nAdd));\n\t\t\twmemcpy(gsPrevAnsiPart+nCurPrevLen, lpBuffer, nAdd);\n\t\t\tgsPrevAnsiPart[nCurPrevLen+nAdd] = 0;\n\n\t\t\tWARNING(\"\u041f\u0440\u043e\u0432\u0435\u0440\u0438\u0442\u044c!!!\");\n\t\t\tLPCWSTR lpReStart, lpReNext;\n\t\t\tint iCall = NextEscCode(gsPrevAnsiPart, gsPrevAnsiPart+nAdd+gnPrevAnsiPart, szPreDump, cchPrevPart, lpReStart, lpReNext, Code, TRUE);\n\t\t\tif (iCall == 1)\n\t\t\t{\n\t\t\t\tif ((lpReNext - gsPrevAnsiPart) >= gnPrevAnsiPart)\n\t\t\t\t{\n\t\t\t\t\t// Bypass unrecognized ESC sequences to screen?\n\t\t\t\t\tif (lpReStart > gsPrevAnsiPart)\n\t\t\t\t\t{\n\t\t\t\t\t\tssize_t nSkipLen = (lpReStart - gsPrevAnsiPart); //DWORD nWritten;\n\t\t\t\t\t\t_ASSERTEX(nSkipLen>0 && nSkipLen<=countof(gsPrevAnsiPart) && nSkipLen<=gnPrevAnsiPart);\n\t\t\t\t\t\tDumpUnknownEscape(gsPrevAnsiPart, nSkipLen);\n\n\t\t\t\t\t\t//WriteText(gsPrevAnsiPart, nSkipLen, &nWritten);\n\t\t\t\t\t\t_ASSERTEX(nSkipLen <= ((int)SrvAnsi::CEAnsi_MaxPrevPart - (int)cchPrevPart));\n\t\t\t\t\t\tmemmove(szPreDump, gsPrevAnsiPart, nSkipLen);\n\t\t\t\t\t\tcchPrevPart += int(nSkipLen);\n\n\t\t\t\t\t\tif (nSkipLen < gnPrevAnsiPart)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tmemmove(gsPrevAnsiPart, lpReStart, (gnPrevAnsiPart - nSkipLen)*sizeof(*gsPrevAnsiPart));\n\t\t\t\t\t\t\tgnPrevAnsiPart -= nSkipLen;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t_ASSERTEX(nSkipLen == gnPrevAnsiPart);\n\t\t\t\t\t\t\t*gsPrevAnsiPart = 0;\n\t\t\t\t\t\t\tgnPrevAnsiPart = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlpReStart = gsPrevAnsiPart;\n\t\t\t\t\t}\n\t\t\t\t\t_ASSERTEX(lpReStart == gsPrevAnsiPart);\n\t\t\t\t\tlpStart = lpBuffer; // nothing to dump before Esc-sequence\n\t\t\t\t\t_ASSERTEX((lpReNext - gsPrevAnsiPart) >= gnPrevAnsiPart);\n\t\t\t\t\tWARNING(\"\u041f\u0440\u043e\u0432\u0435\u0440\u0438\u0442\u044c!!!\");\n\t\t\t\t\tlpNext = lpBuffer + (lpReNext - gsPrevAnsiPart - gnPrevAnsiPart);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t_ASSERTEX((lpReNext - gsPrevAnsiPart) >= gnPrevAnsiPart);\n\t\t\t\t\tlpStart = lpNext = lpBuffer;\n\t\t\t\t}\n\t\t\t\tgnPrevAnsiPart = 0;\n\t\t\t\tgsPrevAnsiPart[0] = 0;\n\t\t\t\tiRc = 1;\n\t\t\t\tgoto wrap2;\n\t\t\t}\n\t\t\telse if (iCall == 2)\n\t\t\t{\n\t\t\t\tgnPrevAnsiPart = nCurPrevLen+nAdd;\n\t\t\t\t_ASSERTEX(gsPrevAnsiPart[nCurPrevLen+nAdd] == 0);\n\t\t\t\tiRc = 2;\n\t\t\t\tgoto wrap;\n\t\t\t}\n\n\t\t\t_ASSERTEX((iCall == 1) && \"Invalid esc sequence, need dump to screen?\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\t_ASSERTEX(*gsPrevAnsiPart == 27);\n\t\t}\n\t}\n\n\n\twhile (lpBuffer < lpEnd)\n\t{\n\t\tswitch (*lpBuffer)\n\t\t{\n\t\tcase 27:\n\t\t\t{\n\t\t\t\tssize_t nLeft;\n\t\t\t\tLPCWSTR lpEscStart = lpBuffer;\n\n\t\t\t\t#ifdef _DEBUG\n\t\t\t\tCode.pszEscStart = lpBuffer;\n\t\t\t\tCode.nTotalLen = 0;\n\t\t\t\t#endif\n\n\t\t\t\t// Special one char codes? Like \"ESC 7\" and so on...\n\t\t\t\tif ((lpBuffer + 1) < lpEnd)\n\t\t\t\t{\n\t\t\t\t\t// But it may be some \"special\" codes\n\t\t\t\t\tswitch (lpBuffer[1])\n\t\t\t\t\t{\n\t\t\t\t\tcase L'7': // Save xterm cursor\n\t\t\t\t\tcase L'8': // Restore xterm cursor\n\t\t\t\t\tcase L'c': // Full reset\n\t\t\t\t\tcase L'g': // Visual Bell\n\t\t\t\t\tcase L'=':\n\t\t\t\t\tcase L'>':\n\t\t\t\t\tcase L'H': // Horizontal Tab Set\n\t\t\t\t\tcase L'M': // Reverse LF\n\t\t\t\t\tcase L'E': // CR-LF\n\t\t\t\t\tcase L'D': // LF\n\t\t\t\t\t\t// xterm?\n\t\t\t\t\t\tlpStart = lpEscStart;\n\t\t\t\t\t\tCode.First = 27;\n\t\t\t\t\t\tCode.Second = *(++lpBuffer);\n\t\t\t\t\t\tCode.ArgC = 0;\n\t\t\t\t\t\tCode.PvtLen = 0;\n\t\t\t\t\t\tCode.Pvt[0] = 0;\n\t\t\t\t\t\tlpEnd = (++lpBuffer);\n\t\t\t\t\t\tiRc = 1;\n\t\t\t\t\t\tgoto wrap;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// If tail is larger than 2 chars, continue\n\t\t\t\tif ((lpBuffer + 2) < lpEnd)\n\t\t\t\t{\n\t\t\t\t\t// Set lpSaveStart to current start of Esc sequence, it was set to beginning of buffer\n\t\t\t\t\t_ASSERTEX(lpSaveStart <= lpBuffer);\n\t\t\t\t\tlpSaveStart = lpBuffer;\n\t\t\t\t\t_ASSERTEX(lpSaveStart == lpEscStart);\n\n\t\t\t\t\tCode.First = 27;\n\t\t\t\t\tCode.Second = *(++lpBuffer);\n\t\t\t\t\tCode.ArgC = 0;\n\t\t\t\t\tCode.PvtLen = 0;\n\t\t\t\t\tCode.Pvt[0] = 0;\n\n\t\t\t\t\tTODO(\"Bypass unrecognized ESC sequences to screen? Don't try to eliminate 'Possible' sequences?\");\n\t\t\t\t\t//if (((Code.Second < 64) || (Code.Second > 95)) && (Code.Second != 124/* '|' - vim-xterm-emulation */))\n\t\t\t\t\tif (!wcschr(L\"[]|()%\", Code.Second))\n\t\t\t\t\t{\n\t\t\t\t\t\t// Don't assert on rawdump of KeyEvents.exe Esc key presses\n\t\t\t\t\t\t// 10:00:00 KEY_EVENT_RECORD: Dn, 1, Vk=\"VK_ESCAPE\" [27/0x001B], Scan=0x0001 uChar=[U='\\x1b' (0x001B): A='\\x1b' (0x1B)]\n\t\t\t\t\t\tbool bStandaloneEscChar = (lpStart < lpSaveStart) && ((*(lpSaveStart-1) == L'\\'' && Code.Second == L'\\'') || (*(lpSaveStart-1) == L' ' && Code.Second == L' '));\n\t\t\t\t\t\t//_ASSERTEX(bStandaloneEscChar && \"Unsupported control sequence?\");\n\t\t\t\t\t\tif (!bStandaloneEscChar)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, std::min<size_t>(Code.nTotalLen, 32), SrvAnsi::de_UnkControl);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue; // invalid code\n\t\t\t\t\t}\n\n\t\t\t\t\t// \u0422\u0435\u043f\u0435\u0440\u044c \u0438\u0434\u0443\u0442 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b.\n\t\t\t\t\t++lpBuffer; // \u043f\u0435\u0440\u0435\u043c\u0435\u0441\u0442\u0438\u043c \u0443\u043a\u0430\u0437\u0430\u0442\u0435\u043b\u044c \u043d\u0430 \u043f\u0435\u0440\u0432\u044b\u0439 \u0441\u0438\u043c\u0432\u043e\u043b \u0417\u0410 CSI (\u043f\u043e\u0441\u043b\u0435 '[')\n\n\t\t\t\t\tauto parseNumArgs = [&Code, lpSaveStart](const wchar_t* &lpBuffer, const wchar_t* lpSeqEnd, bool saveAction) -> bool\n\t\t\t\t\t{\n\t\t\t\t\t\twchar_t wc;\n\t\t\t\t\t\tint nValue = 0, nDigits = 0;\n\t\t\t\t\t\tCode.ArgC = 0;\n\n\t\t\t\t\t\twhile (lpBuffer < lpSeqEnd)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tswitch (*lpBuffer)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcase L'0': case L'1': case L'2': case L'3': case L'4':\n\t\t\t\t\t\t\tcase L'5': case L'6': case L'7': case L'8': case L'9':\n\t\t\t\t\t\t\t\tnValue = (nValue * 10) + (((int)*lpBuffer) - L'0');\n\t\t\t\t\t\t\t\t++nDigits;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase L';':\n\t\t\t\t\t\t\t\t// \u0414\u0430\u0436\u0435 \u0435\u0441\u043b\u0438 \u0446\u0438\u0444\u0440 \u043d\u0435 \u0431\u044b\u043b\u043e - default \"0\"\n\t\t\t\t\t\t\t\tif (Code.ArgC < (int)countof(Code.ArgV))\n\t\t\t\t\t\t\t\t\tCode.ArgV[Code.ArgC++] = nValue; // save argument\n\t\t\t\t\t\t\t\tnDigits = nValue = 0;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tif (Code.Second == L']')\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t// OSC specific, stop on first non-digit/non-semicolon\n\t\t\t\t\t\t\t\t\tif (nDigits && (Code.ArgC < (int)countof(Code.ArgV)))\n\t\t\t\t\t\t\t\t\t\tCode.ArgV[Code.ArgC++] = nValue;\n\t\t\t\t\t\t\t\t\treturn (Code.ArgC > 0);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse if (((wc = *lpBuffer) >= 64) && (wc <= 126))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t// Fin\n\t\t\t\t\t\t\t\t\tif (saveAction)\n\t\t\t\t\t\t\t\t\t\tCode.Action = wc;\n\t\t\t\t\t\t\t\t\tif (nDigits && (Code.ArgC < (int)countof(Code.ArgV)))\n\t\t\t\t\t\t\t\t\t\tCode.ArgV[Code.ArgC++] = nValue;\n\t\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tif ((size_t(Code.PvtLen) + 2) < countof(Code.Pvt))\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tCode.Pvt[Code.PvtLen++] = wc; // Skip private symbols\n\t\t\t\t\t\t\t\t\t\tCode.Pvt[Code.PvtLen] = 0;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t++lpBuffer;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (nDigits && (Code.ArgC < (int)countof(Code.ArgV)))\n\t\t\t\t\t\t\tCode.ArgV[Code.ArgC++] = nValue;\n\t\t\t\t\t\treturn (Code.Second == L']');\n\t\t\t\t\t};\n\n\t\t\t\t\tswitch (Code.Second)\n\t\t\t\t\t{\n\t\t\t\t\tcase L'(':\n\t\t\t\t\tcase L')':\n\t\t\t\t\tcase L'%':\n\t\t\t\t\t//case L'#':\n\t\t\t\t\t//case L'*':\n\t\t\t\t\t//case L'+':\n\t\t\t\t\t//case L'-':\n\t\t\t\t\t//case L'.':\n\t\t\t\t\t//case L'/':\n\t\t\t\t\t\t// VT G0/G1/G2/G3 character sets\n\t\t\t\t\t\tlpStart = lpSaveStart;\n\t\t\t\t\t\tCode.Action = *(lpBuffer++);\n\t\t\t\t\t\tCode.Skip = 0;\n\t\t\t\t\t\tCode.ArgSZ = nullptr;\n\t\t\t\t\t\tCode.cchArgSZ = 0;\n\t\t\t\t\t\tlpEnd = lpBuffer;\n\t\t\t\t\t\tiRc = 1;\n\t\t\t\t\t\tgoto wrap;\n\t\t\t\t\tcase L'|':\n\t\t\t\t\t\t// vim-xterm-emulation\n\t\t\t\t\tcase L'[':\n\t\t\t\t\t\t// Standard\n\t\t\t\t\t\tCode.Skip = 0;\n\t\t\t\t\t\tCode.ArgSZ = nullptr;\n\t\t\t\t\t\tCode.cchArgSZ = 0;\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t#ifdef _DEBUG\n\t\t\t\t\t\t\tLPCWSTR pszSaveStart = lpBuffer;\n\t\t\t\t\t\t\t#endif\n\n\t\t\t\t\t\t\tif (parseNumArgs(lpBuffer, lpEnd, true))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tlpStart = lpSaveStart;\n\t\t\t\t\t\t\t\tlpEnd = lpBuffer+1;\n\t\t\t\t\t\t\t\tiRc = 1;\n\t\t\t\t\t\t\t\tgoto wrap;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// \u0412 \u0434\u0430\u043d\u043d\u043e\u043c \u0437\u0430\u043f\u0440\u043e\u0441\u0435 (\u043d\u0430 \u0437\u0430\u043f\u0438\u0441\u044c) \u043a\u043e\u043d\u0446\u0430 \u043f\u043e\u0441\u043b\u0435\u0434\u043e\u0432\u0430\u0442\u0435\u043b\u044c\u043d\u043e\u0441\u0442\u0438 \u043d\u0435\u0442,\n\t\t\t\t\t\t// \u043e\u0441\u0442\u0430\u0432\u0448\u0438\u0439\u0441\u044f \u0445\u0432\u043e\u0441\u0442 \u043d\u0443\u0436\u043d\u043e \u0441\u043e\u0445\u0440\u0430\u043d\u0438\u0442\u044c \u0432 \u0431\u0443\u0444\u0435\u0440\u0435, \u0434\u043b\u044f \u0441\u043b\u0435\u0434\u0443\u044e\u0449\u0435\u0433\u043e \u0437\u0430\u043f\u0440\u043e\u0441\u0430\n\t\t\t\t\t\t// \u041d\u0438\u0436\u0435\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase L']':\n\t\t\t\t\t\t// Finalizing (ST) with \"\\x1B\\\\\" or \"\\x07\"\n\t\t\t\t\t\t// \"%]4;16;rgb:00/00/00%\\\" - \"%\" is ESC\n\t\t\t\t\t\t// \"%]0;this is the window titleBEL\"\n\t\t\t\t\t\t// ESC ] 0 ; txt ST        Set icon name and window title to txt.\n\t\t\t\t\t\t// ESC ] 1 ; txt ST        Set icon name to txt.\n\t\t\t\t\t\t// ESC ] 2 ; txt ST        Set window title to txt.\n\t\t\t\t\t\t// ESC ] 4 ; num; txt ST   Set ANSI color num to txt.\n\t\t\t\t\t\t// ESC ] 10 ; txt ST       Set dynamic text color to txt.\n\t\t\t\t\t\t// ESC ] 4 6 ; name ST     Change log file to name (normally disabled\n\t\t\t\t\t\t//\t\t\t\t\t       by a compile-time option)\n\t\t\t\t\t\t// ESC ] 5 0 ; fn ST       Set font to fn.\n\t\t\t\t\t\t//Following 2 codes - from linux terminal\n\t\t\t\t\t\t// ESC ] P nrrggbb         Set palette, with parameter given in 7\n                        //                         hexadecimal digits after the final P :-(.\n\t\t\t\t\t\t//                         Here n is the color (0-15), and rrggbb indicates\n\t\t\t\t\t\t//                         the red/green/blue values (0-255).\n\t\t\t\t\t\t// ESC ] R                 reset palette\n\n\t\t\t\t\t\t// ConEmu specific\n\t\t\t\t\t\t// ESC ] 9 ; 1 ; ms ST           Sleep. ms - milliseconds\n\t\t\t\t\t\t// ESC ] 9 ; 2 ; \"txt\" ST        Show GUI MessageBox ( txt ) for dubug purposes\n\t\t\t\t\t\t// ESC ] 9 ; 3 ; \"txt\" ST        Set TAB text\n\t\t\t\t\t\t// ESC ] 9 ; 4 ; st ; pr ST      When _st_ is 0: remove progress. When _st_ is 1: set progress value to _pr_ (number, 0-100). When _st_ is 2: set error state in progress on Windows 7 taskbar\n\t\t\t\t\t\t// ESC ] 9 ; 5 ST                Wait for ENTER/SPACE/ESC. Set EnvVar \"ConEmuWaitKey\" to ENTER/SPACE/ESC on exit.\n\t\t\t\t\t\t// ESC ] 9 ; 6 ; \"txt\" ST        Execute GuiMacro. Set EnvVar \"ConEmuMacroResult\" on exit.\n\t\t\t\t\t\t// and others... look at SrvAnsiImpl::WriteAnsiCode_OSC\n\n\t\t\t\t\t\tCode.ArgSZ = lpBuffer;\n\t\t\t\t\t\tCode.cchArgSZ = 0;\n\t\t\t\t\t\t//Code.Skip = Code.Second;\n\n\t\t\t\t\t\twhile (lpBuffer < lpEnd)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif ((lpBuffer[0] == 7) ||\n\t\t\t\t\t\t\t\t(lpBuffer[0] == 27) /* we'll check the proper terminator below */)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tCode.Action = *Code.ArgSZ; // \u043f\u0435\u0440\u0432\u044b\u0439 \u0441\u0438\u043c\u0432\u043e\u043b \u043f\u043e\u0441\u043b\u0435\u0434\u043e\u0432\u0430\u0442\u0435\u043b\u044c\u043d\u043e\u0441\u0442\u0438\n\t\t\t\t\t\t\t\tCode.cchArgSZ = (lpBuffer - Code.ArgSZ);\n\t\t\t\t\t\t\t\tlpStart = lpSaveStart;\n\t\t\t\t\t\t\t\tconst wchar_t* lpBufferPtr = Code.ArgSZ;\n\t\t\t\t\t\t\t\tif (lpBuffer[0] == 27)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tif ((lpBuffer + 1) >= lpEnd)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t// Sequence is not complete yet!\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse if (lpBuffer[1] == L'\\\\')\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tlpEnd = lpBuffer + 2;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tlpEnd = lpBuffer - 1;\n\t\t\t\t\t\t\t\t\t\t_ASSERTE(*(lpEnd+1) == 27);\n\t\t\t\t\t\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t\t\t\t\t\t\t\t\tiRc = 0;\n\t\t\t\t\t\t\t\t\t\tgoto wrap;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tlpEnd = lpBuffer + 1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tparseNumArgs(lpBufferPtr, lpBuffer, false);\n\t\t\t\t\t\t\t\tiRc = 1;\n\t\t\t\t\t\t\t\tgoto wrap;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t++lpBuffer;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Sequence is not complete, we have to store it to concatenate\n\t\t\t\t\t\t// and check on future write call. Below.\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t// Unknown sequence, use common termination rules\n\t\t\t\t\t\tCode.Skip = Code.Second;\n\t\t\t\t\t\tCode.ArgSZ = lpBuffer;\n\t\t\t\t\t\tCode.cchArgSZ = 0;\n\t\t\t\t\t\twhile (lpBuffer < lpEnd)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// Terminator ASCII symbol: from `@` to `~`\n\t\t\t\t\t\t\tif (((wc = *lpBuffer) >= 64) && (wc <= 126))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tCode.Action = wc;\n\t\t\t\t\t\t\t\tlpStart = lpSaveStart;\n\t\t\t\t\t\t\t\tlpEnd = lpBuffer+1;\n\t\t\t\t\t\t\t\tiRc = 1;\n\t\t\t\t\t\t\t\tgoto wrap;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t++lpBuffer;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} // end of \"switch (Code.Second)\"\n\t\t\t\t} // end of minimal length check\n\n\t\t\t\tif ((nLeft = (lpEnd - lpEscStart)) <= SrvAnsi::CEAnsi_MaxPrevAnsiPart)\n\t\t\t\t{\n\t\t\t\t\tif (ReEntrance)\n\t\t\t\t\t{\n\t\t\t\t\t\t//_ASSERTEX(!ReEntrance && \"Need to be checked!\"); -- seems to be OK\n\n\t\t\t\t\t\t// gsPrevAnsiPart2 stored for debug purposes only (fully excess)\n\t\t\t\t\t\twmemmove(gsPrevAnsiPart2, lpEscStart, nLeft);\n\t\t\t\t\t\tgsPrevAnsiPart2[nLeft] = 0;\n\t\t\t\t\t\tgnPrevAnsiPart2 = nLeft;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\twmemmove(gsPrevAnsiPart, lpEscStart, nLeft);\n\t\t\t\t\t\tgsPrevAnsiPart[nLeft] = 0;\n\t\t\t\t\t\tgnPrevAnsiPart = nLeft;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t_ASSERTEX(FALSE && \"Too long Esc-sequence part, Need to be checked!\");\n\t\t\t\t}\n\n\t\t\t\tlpStart = lpEscStart;\n\n\t\t\t\tiRc = 2;\n\t\t\t\tgoto wrap;\n\t\t\t} // end of \"case 27:\"\n\t\t\tbreak;\n\t\t} // end of \"switch (*lpBuffer)\"\n\n\t\t++lpBuffer;\n\t} // end of \"while (lpBuffer < lpEnd)\"\n\nwrap:\n\tlpNext = lpEnd;\n\n\t#ifdef _DEBUG\n\tif (iRc == 1)\n\t\tCode.nTotalLen = (lpEnd - Code.pszEscStart);\n\t#endif\nwrap2:\n\t_ASSERTEX((iRc==0) || (lpStart>=lpSaveStart && lpStart<lpEnd));\n\treturn iRc;\n}\n\nbool SrvAnsiImpl::FullReset()\n{\n\tm_Owner->gDisplayParm.Reset(true);\n\tm_Table->Reset(m_Owner->GetDefaultAttr());\n\treturn TRUE;\n}\n\nstatic bool GetConsoleScreenBufferInfoCached(CONSOLE_SCREEN_BUFFER_INFO* csbi)\n{\n\t// #condata need to implement\n\tthrow;\n\treturn false;\n}\n\nvoid SrvAnsiImpl::ForwardLF()\n{\n\tm_Table->LineFeed(false);\n\tm_Table->PromptPosReset();\n}\n\nvoid SrvAnsiImpl::ForwardCRLF()\n{\n\tm_Table->Write(L\"\\r\\n\", 2);\n}\n\nvoid SrvAnsiImpl::ReverseLF()\n{\n\tconst auto cur = m_Table->GetCursor();\n\tif (cur.y <= 0)\n\t{\n\t\tm_Table->InsertRow();\n\t}\n\telse\n\t{\n\t\t// Just move cursor upwards\n\t\tm_Table->SetCursor({cur.x, cur.y - 1});\n\t}\n\tm_Table->PromptPosReset();\n}\n\nint SrvAnsiImpl::NextNumber(LPCWSTR& asMS)\n{\n\twchar_t wc;\n\tint ms = 0;\n\twhile (((wc = *(asMS++)) >= L'0') && (wc <= L'9'))\n\t\tms = (ms * 10) + (int)(wc - L'0');\n\treturn ms;\n}\n\n// ESC ] 9 ; 1 ; ms ST           Sleep. ms - milliseconds\nvoid SrvAnsiImpl::DoSleep(LPCWSTR asMS)\n{\n\tint ms = NextNumber(asMS);\n\tif (!ms)\n\t\tms = 100;\n\telse if (ms > 10000)\n\t\tms = 10000;\n\t// Delay\n\tSleep(ms);\n}\n\nvoid SrvAnsiImpl::EscCopyCtrlString(wchar_t* pszDst, LPCWSTR asMsg, ssize_t cchMaxLen)\n{\n\tif (!pszDst)\n\t{\n\t\t_ASSERTEX(pszDst!=nullptr);\n\t\treturn;\n\t}\n\n\tif (cchMaxLen < 0)\n\t{\n\t\t_ASSERTEX(cchMaxLen >= 0);\n\t\tcchMaxLen = 0;\n\t}\n\tif (cchMaxLen > 1)\n\t{\n\t\tif ((asMsg[0] == L'\"') && (asMsg[cchMaxLen-1] == L'\"'))\n\t\t{\n\t\t\tasMsg++;\n\t\t\tcchMaxLen -= 2;\n\t\t}\n\t}\n\n\tif (cchMaxLen > 0)\n\t\twmemmove(pszDst, asMsg, cchMaxLen);\n\tpszDst[std::max<ssize_t>(cchMaxLen, 0)] = 0;\n}\n\n// ESC ] 9 ; 2 ; \"txt\" ST          Show GUI MessageBox ( txt ) for dubug purposes\nvoid SrvAnsiImpl::DoMessage(LPCWSTR asMsg, ssize_t cchLen)\n{\n\twchar_t* pszText = (wchar_t*)malloc((cchLen+1)*sizeof(*pszText));\n\n\tif (pszText)\n\t{\n\t\tEscCopyCtrlString(pszText, asMsg, cchLen);\n\t\t//if (cchLen > 0)\n\t\t//\twmemmove(pszText, asMsg, cchLen);\n\t\t//pszText[cchLen] = 0;\n\n\t\twchar_t szExe[MAX_PATH] = {};\n\t\tGetModuleFileName(nullptr, szExe, countof(szExe));\n\t\twchar_t szTitle[MAX_PATH+64];\n\t\tmsprintf(szTitle, countof(szTitle), L\"PID=%u, %s\", GetCurrentProcessId(), PointToName(szExe));\n\n\t\tGuiMessageBox(gState.conemuWnd_, pszText, szTitle, MB_ICONINFORMATION|MB_SYSTEMMODAL);\n\n\t\tfree(pszText);\n\t}\n}\n\nbool SrvAnsiImpl::IsAnsiExecAllowed(LPCWSTR asCmd)\n{\n\t// Invalid command or macro?\n\tif (!asCmd || !*asCmd)\n\t\treturn false;\n\n\t// We need to check settings\n\tCESERVER_CONSOLE_MAPPING_HDR* pMap = m_Owner->GetConMap();\n\tif (!pMap)\n\t\treturn false;\n\n\tif ((pMap->Flags & ConEmu::ConsoleFlags::AnsiExecAny) != 0)\n\t{\n\t\t// Allowed in any process\n\t}\n\telse if ((pMap->Flags & ConEmu::ConsoleFlags::AnsiExecCmd) != 0)\n\t{\n\t\t// #condata Allowed in Cmd.exe only\n\t\t// if (!gbIsCmdProcess)\n\t\treturn false;\n\t}\n\telse\n\t{\n\t\t// Disallowed everywhere\n\t\treturn false;\n\t}\n\n\t// Now we need to ask GUI, if the command (asCmd) is allowed\n\tbool bAllowed = false;\n\tssize_t cchLen = wcslen(asCmd) + 1;\n\tCESERVER_REQ* pOut = nullptr;\n\tCESERVER_REQ* pIn = ExecuteNewCmd(CECMD_ALLOWANSIEXEC, sizeof(CESERVER_REQ_HDR)+sizeof(wchar_t)*cchLen);\n\n\tif (pIn)\n\t{\n\t\t_ASSERTE(sizeof(pIn->wData[0])==sizeof(*asCmd));\n\t\tmemmove(pIn->wData, asCmd, cchLen*sizeof(pIn->wData[0]));\n\n\t\tpOut = ExecuteGuiCmd(gState.realConWnd_, pIn, gState.realConWnd_);\n\t\tif (pOut && (pOut->DataSize() == sizeof(pOut->dwData[0])))\n\t\t{\n\t\t\tbAllowed = (pOut->dwData[0] == TRUE);\n\t\t}\n\t}\n\n\tExecuteFreeResult(pOut);\n\tExecuteFreeResult(pIn);\n\n\treturn bAllowed;\n}\n\n// ESC ] 9 ; 6 ; \"macro\" ST        Execute some GuiMacro\nvoid SrvAnsiImpl::DoGuiMacro(LPCWSTR asCmd, ssize_t cchLen)\n{\n\tCESERVER_REQ* pOut = nullptr;\n\tCESERVER_REQ* pIn = ExecuteNewCmd(CECMD_GUIMACRO, sizeof(CESERVER_REQ_HDR)+sizeof(CESERVER_REQ_GUIMACRO)+sizeof(wchar_t)*(cchLen + 1));\n\n\tif (pIn)\n\t{\n\t\tEscCopyCtrlString(pIn->GuiMacro.sMacro, asCmd, cchLen);\n\n\t\tif (IsAnsiExecAllowed(pIn->GuiMacro.sMacro))\n\t\t{\n\t\t\tpOut = ExecuteGuiCmd(gState.realConWnd_, pIn, gState.realConWnd_);\n\t\t}\n\t}\n\n\t// EnvVar \"ConEmuMacroResult\"\n\tSetEnvironmentVariable(CEGUIMACRORETENVVAR, pOut && pOut->GuiMacro.nSucceeded ? pOut->GuiMacro.sMacro : nullptr);\n\n\tExecuteFreeResult(pOut);\n\tExecuteFreeResult(pIn);\n}\n\n// ESC ] 9 ; 7 ; \"cmd\" ST        Run some process with arguments\nvoid SrvAnsiImpl::DoProcess(LPCWSTR asCmd, ssize_t cchLen)\n{\n\t// We need zero-terminated string\n\twchar_t* pszCmdLine = (wchar_t*)malloc((cchLen + 1)*sizeof(*asCmd));\n\n\tif (pszCmdLine)\n\t{\n\t\tEscCopyCtrlString(pszCmdLine, asCmd, cchLen);\n\n\t\tif (IsAnsiExecAllowed(pszCmdLine))\n\t\t{\n\t\t\tSTARTUPINFO si = {};\n\t\t\tsi.cb = sizeof(si);\n\t\t\tPROCESS_INFORMATION pi = {};\n\n\t\t\tconst bool bCreated = CreateProcessW(nullptr, pszCmdLine, nullptr, nullptr, FALSE, 0, nullptr, nullptr, &si, &pi);\n\t\t\tif (bCreated)\n\t\t\t{\n\t\t\t\tWaitForSingleObject(pi.hProcess, INFINITE);\n\t\t\t\tCloseHandle(pi.hProcess);\n\t\t\t\tCloseHandle(pi.hThread);\n\t\t\t}\n\t\t}\n\n\t\tfree(pszCmdLine);\n\t}\n}\n\n// ESC ] 9 ; 8 ; \"env\" ST        Output value of environment variable\nvoid SrvAnsiImpl::DoPrintEnv(LPCWSTR asCmd, ssize_t cchLen)\n{\n\t// We need zero-terminated string\n\twchar_t* pszVarName = (wchar_t*)malloc((cchLen + 1)*sizeof(*asCmd));\n\n\tif (pszVarName)\n\t{\n\t\tEscCopyCtrlString(pszVarName, asCmd, cchLen);\n\n\t\twchar_t szValue[MAX_PATH];\n\t\twchar_t* pszValue = szValue;\n\t\tDWORD cchMax = countof(szValue);\n\t\tDWORD nMax = GetEnvironmentVariable(pszVarName, pszValue, cchMax);\n\n\t\t// Some predefined as `time`, `date`, `cd`, ...\n\t\tif (!nMax)\n\t\t{\n\t\t\tif ((lstrcmpi(pszVarName, L\"date\") == 0)\n\t\t\t\t|| (lstrcmpi(pszVarName, L\"time\") == 0))\n\t\t\t{\n\t\t\t\tSYSTEMTIME st = {}; GetLocalTime(&st);\n\t\t\t\tif (lstrcmpi(pszVarName, L\"date\") == 0)\n\t\t\t\t\tswprintf_c(szValue, L\"%u-%02u-%02u\", st.wYear, st.wMonth, st.wDay);\n\t\t\t\telse\n\t\t\t\t\tswprintf_c(szValue, L\"%u:%02u:%02u.%03u\", st.wHour, st.wMinute, st.wSecond, st.wMilliseconds);\n\t\t\t\tnMax = lstrlen(szValue);\n\t\t\t}\n\t\t\t#if 0\n\t\t\telse if (lstrcmpi(pszVarName, L\"cd\") == 0)\n\t\t\t{\n\t\t\t\t//TODO: If possible\n\t\t\t}\n\t\t\t#endif\n\t\t}\n\n\t\tif (nMax >= cchMax)\n\t\t{\n\t\t\tcchMax = nMax+1;\n\t\t\tpszValue = (wchar_t*)malloc(cchMax*sizeof(*pszValue));\n\t\t\tnMax = pszValue ? GetEnvironmentVariable(pszVarName, szValue, countof(szValue)) : 0;\n\t\t}\n\n\t\tif (nMax)\n\t\t{\n\t\t\tTODO(\"Process here ANSI colors TOO! But now it will be 'reentrance'?\");\n\t\t\tWriteText(pszValue, nMax, &cchMax);\n\t\t}\n\n\t\tif (pszValue && pszValue != szValue)\n\t\t\tfree(pszValue);\n\t\tfree(pszVarName);\n\t}\n}\n\n// ESC ] 9 ; 9 ; \"cwd\" ST        Inform ConEmu about shell current working directory\nvoid SrvAnsiImpl::DoSendCWD(LPCWSTR asCmd, ssize_t cchLen)\n{\n\t// We need zero-terminated string\n\twchar_t* pszCWD = (wchar_t*)malloc((cchLen + 1)*sizeof(*asCmd));\n\n\tif (pszCWD)\n\t{\n\t\tEscCopyCtrlString(pszCWD, asCmd, cchLen);\n\n\t\t// Sends CECMD_STORECURDIR into RConServer\n\t\tSendCurrentDirectory(gState.realConWnd_, pszCWD);\n\n\t\tfree(pszCWD);\n\t}\n}\n\n// When _st_ is 0: remove progress.\n// When _st_ is 1: set progress value to _pr_ (number, 0-100).\n// When _st_ is 2: set error state in progress on Windows 7 taskbar\nvoid SrvAnsiImpl::DoSetProgress(const AnsiProgressStatus st, const WORD pr, LPCWSTR pszName /*= nullptr*/)\n{\n\tint nLen = pszName ? (lstrlen(pszName) + 1) : 1;\n\tCESERVER_REQ* pIn = ExecuteNewCmd(CECMD_SETPROGRESS, sizeof(CESERVER_REQ_HDR) + sizeof(WORD) * (2 + nLen));\n\tif (pIn)\n\t{\n\t\tpIn->wData[0] = static_cast<WORD>(st);\n\t\tpIn->wData[1] = pr;  // NOLINT(clang-diagnostic-array-bounds)\n\t\tif (pszName)\n\t\t{\n\t\t\tlstrcpy((wchar_t*)(pIn->wData+2), pszName);\n\t\t}\n\n\t\tCESERVER_REQ* pOut = ExecuteGuiCmd(gState.realConWnd_, pIn, gState.realConWnd_);\n\t\tExecuteFreeResult(pIn);\n\t\tExecuteFreeResult(pOut);\n\t}\n}\n\n\nbool SrvAnsiImpl::ReportString(LPCWSTR asRet)\n{\n\tif (!asRet || !*asRet)\n\t\treturn FALSE;\n\tINPUT_RECORD ir[16] = {};\n\tint nLen = lstrlen(asRet);\n\tINPUT_RECORD* pir = (nLen <= (int)countof(ir)) ? ir : (INPUT_RECORD*)calloc(nLen,sizeof(INPUT_RECORD));\n\tif (!pir)\n\t\treturn FALSE;\n\n\tINPUT_RECORD* p = pir;\n\tLPCWSTR pc = asRet;\n\tfor (int i = 0; i < nLen; i++, p++, pc++)\n\t{\n\t\tconst char ch = (*pc == 0x1B || *pc >= 0x20) ? *pc : L' ';\n\t\tp->EventType = KEY_EVENT;\n\t\tp->Event.KeyEvent.bKeyDown = TRUE;\n\t\tp->Event.KeyEvent.wRepeatCount = 1;\n\t\tp->Event.KeyEvent.uChar.UnicodeChar = ch;\n\t}\n\n\tDumpKnownEscape(asRet, nLen, SrvAnsi::de_Report);\n\n\tDWORD nWritten = 0;\n\tHANDLE hIn = GetStdHandle(STD_INPUT_HANDLE);\n\tbool bSuccess = WriteConsoleInput(hIn, pir, nLen, &nWritten) && (nWritten == nLen);\n\n\tif (pir != ir)\n\t\tfree(pir);\n\treturn bSuccess;\n}\n\nvoid SrvAnsiImpl::ReportConsoleTitle()\n{\n\twchar_t sTitle[MAX_PATH*2+6] = L\"\\x1B]l\";\n\twchar_t* p = sTitle+3;\n\t_ASSERTEX(lstrlen(sTitle)==3);\n\n\tDWORD nTitle = GetConsoleTitle(sTitle+3, MAX_PATH*2);\n\tp = sTitle + 3 + std::min<DWORD>(nTitle, MAX_PATH*2);\n\t*(p++) = L'\\x1B';\n\t*(p++) = L'\\\\';\n\t*(p++) = 0;\n\n\tReportString(sTitle);\n}\n\nvoid SrvAnsiImpl::ReportTerminalPixelSize()\n{\n\t// `CSI 4 ; height ; width t`\n\twchar_t szReport[64];\n\tint width = 0, height = 0;\n\tRECT rcWnd = {};\n\n\tif (gState.conemuWndDC_ && GetClientRect(gState.conemuWndDC_, &rcWnd))\n\t{\n\t\twidth = RectWidth(rcWnd);\n\t\theight = RectHeight(rcWnd);\n\t}\n\n\tif ((width <= 0 || height <= 0) && gState.realConWnd_ && GetClientRect(gState.realConWnd_, &rcWnd))\n\t{\n\t\twidth = RectWidth(rcWnd);\n\t\theight = RectHeight(rcWnd);\n\t}\n\n\tif (width <= 0 || height <= 0)\n\t{\n\t\t_ASSERTE(width > 0 && height > 0);\n\t\t// Both DC and RealConsole windows were failed?\n\t\tconst auto size = m_Table->GetSize();\n\t\t_ASSERTE(size.x > 0 && size.y > 0);\n\t\tconst int defCharWidth = 8, defCharHeight = 14;\n\t\twidth = size.x * defCharWidth;\n\t\theight = size.y * defCharHeight;\n\t}\n\n\tif (width > 0 && height > 0)\n\t{\n\t\tswprintf_c(szReport, L\"\\x1B[4;%u;%ut\", (uint32_t)height, (uint32_t)width);\n\t\tReportString(szReport);\n\t}\n}\n\nvoid SrvAnsiImpl::ReportTerminalCharSize(int code)\n{\n\tCONSOLE_SCREEN_BUFFER_INFO csbi = {};\n\tif (GetConsoleScreenBufferInfoCached(&csbi))\n\t{\n\t\twchar_t sCurInfo[64];\n\t\tmsprintf(sCurInfo, countof(sCurInfo),\n\t\t\tL\"\\x1B[%u;%u;%ut\",\n\t\t\tcode == 18 ? 8 : 9,\n\t\t\tcsbi.srWindow.Bottom-csbi.srWindow.Top+1, csbi.srWindow.Right-csbi.srWindow.Left+1);\n\t\tReportString(sCurInfo);\n\t}\n}\n\nvoid SrvAnsiImpl::ReportCursorPosition()\n{\n\tCONSOLE_SCREEN_BUFFER_INFO csbi = {};\n\tif (GetConsoleScreenBufferInfoCached(&csbi))\n\t{\n\t\twchar_t sCurInfo[32];\n\t\tmsprintf(sCurInfo, countof(sCurInfo),\n\t\t\tL\"\\x1B[%u;%uR\",\n\t\t\tcsbi.dwCursorPosition.Y-csbi.srWindow.Top+1, csbi.dwCursorPosition.X-csbi.srWindow.Left+1);\n\t\tReportString(sCurInfo);\n\t}\n}\n\nbool SrvAnsiImpl::WriteAnsiCodes(LPCWSTR lpBuffer, DWORD nNumberOfCharsToWrite, LPDWORD lpNumberOfCharsWritten)\n{\n\tbool lbRc = TRUE;\n\tLPCWSTR lpEnd = (lpBuffer + nNumberOfCharsToWrite);\n\tAnsiEscCode Code = {};\n\twchar_t szPreDump[SrvAnsi::CEAnsi_MaxPrevPart];\n\tDWORD cchPrevPart;\n\n\t//ExtWriteTextParm write = {sizeof(write), ewtf_Current};\n\t//write.Private = _WriteConsoleW;\n\n\twhile (lpBuffer < lpEnd)\n\t{\n\t\tLPCWSTR lpStart = nullptr, lpNext = nullptr; // Required to be nullptr-initialized\n\n\t\t// '^' is ESC\n\t\t// ^[0;31;47m   $E[31;47m   ^[0m ^[0;1;31;47m  $E[1;31;47m  ^[0m\n\n\t\tcchPrevPart = 0;\n\n\t\tint iEsc = NextEscCode(lpBuffer, lpEnd, szPreDump, cchPrevPart, lpStart, lpNext, Code);\n\n\t\tif (cchPrevPart)\n\t\t{\n\t\t\tm_Owner->ApplyDisplayParm();\n\n\t\t\tlbRc = WriteText(szPreDump, cchPrevPart, lpNumberOfCharsWritten);\n\t\t\tif (!lbRc)\n\t\t\t\tgoto wrap;\n\t\t}\n\n\t\tif (iEsc != 0)\n\t\t{\n\t\t\tif (lpStart > lpBuffer)\n\t\t\t{\n\t\t\t\t_ASSERTEX((lpStart-lpBuffer) < (ssize_t)nNumberOfCharsToWrite);\n\n\t\t\t\tm_Owner->ApplyDisplayParm();\n\n\t\t\t\tDWORD nWrite = (DWORD)(lpStart - lpBuffer);\n\t\t\t\t//lbRc = WriteText(lpBuffer, nWrite, lpNumberOfCharsWritten);\n\t\t\t\tlbRc = WriteText(lpBuffer, nWrite, lpNumberOfCharsWritten);\n\t\t\t\tif (!lbRc)\n\t\t\t\t\tgoto wrap;\n\t\t\t\t//write.Buffer = lpBuffer;\n\t\t\t\t//write.NumberOfCharsToWrite = nWrite;\n\t\t\t\t//lbRc = ExtWriteText(&write);\n\t\t\t\t//if (!lbRc)\n\t\t\t\t//\tgoto wrap;\n\t\t\t\t//else\n\t\t\t\t//{\n\t\t\t\t//\tif (lpNumberOfCharsWritten)\n\t\t\t\t//\t\t*lpNumberOfCharsWritten = write.NumberOfCharsWritten;\n\t\t\t\t//\tif (write.ScrolledRowsUp > 0)\n\t\t\t\t//\t\tgDisplayCursor.StoredCursorPos.Y = std::max(0,((int)gDisplayCursor.StoredCursorPos.Y - (int)write.ScrolledRowsUp));\n\t\t\t\t//}\n\t\t\t}\n\n\t\t\tif (iEsc == 1)\n\t\t\t{\n\t\t\t\tif (Code.Skip)\n\t\t\t\t{\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tswitch (Code.Second)\n\t\t\t\t\t{\n\t\t\t\t\tcase L'[':  // ESC [ xxx\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tWriteAnsiCode_CSI(Code);\n\n\t\t\t\t\t\t} // case L'[':\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase L']': // ESC ] xxx \\ESC\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tWriteAnsiCode_OSC(Code);\n\n\t\t\t\t\t\t} // case L']':\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase L'|': // ESC | xxx\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// vim-xterm-emulation\n\t\t\t\t\t\t\tWriteAnsiCode_VIM(Code);\n\t\t\t\t\t\t} // case L'|':\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase L'7': // ESC 7\n\t\t\t\t\tcase L'8': // ESC 8\n\t\t\t\t\t\t//TODO: 7 - Save Cursor and _Attributes_\n\t\t\t\t\t\t//TODO: 8 - Restore Cursor and _Attributes_\n\t\t\t\t\t\tXTermSaveRestoreCursor((Code.Second == L'7'));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase L'c': // ESC c\n\t\t\t\t\t\t// Full reset\n\t\t\t\t\t\tFullReset();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase L'g':\n\t\t\t\t\t\t// User may disable flashing in ConEmu settings\n\t\t\t\t\t\t// #ANSI Implement GuiFlashWindow in common\n\t\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored);\n\t\t\t\t\t\t// GuiFlashWindow(eFlashBeep, gState.realConWnd, FALSE, FLASHW_ALL, 1, 0);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase L'H':\n\t\t\t\t\t\t// #ANSI gh-1827: support 'H' to set tab stops\n\t\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase L'M': // ESC M\n\t\t\t\t\t\tReverseLF();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase L'E': // ESC E\n\t\t\t\t\t\tForwardCRLF();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase L'D': // ESC D\n\t\t\t\t\t\tForwardLF();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase L'=': // ESC =\n\t\t\t\t\tcase L'>': // ESC >\n\t\t\t\t\t\t// xterm \"ESC =\" - Application Keypad (DECKPAM)\n\t\t\t\t\t\t// xterm \"ESC >\" - Normal Keypad (DECKPNM)\n\t\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, SrvAnsi::de_Ignored);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase L'(': // ESC (\n\t\t\t\t\t\t// xterm G0..G3?\n\t\t\t\t\t\tswitch (Code.Action)\n\t\t\t\t\t\t{\n\t\t\t\t\t\tcase L'0':\n\t\t\t\t\t\t\tm_Owner->mCharSet = SrvAnsi::VTCS_DRAWING;\n\t\t\t\t\t\t\t//DumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Comment);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase L'B':\n\t\t\t\t\t\t\tm_Owner->mCharSet = SrvAnsi::VTCS_DEFAULT;\n\t\t\t\t\t\t\t//DumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Comment);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tm_Owner->mCharSet = SrvAnsi::VTCS_DEFAULT;\n\t\t\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, SrvAnsi::de_Ignored);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse //if (iEsc != 2) // 2 - means \"Esc part stored in buffer\"\n\t\t{\n\t\t\t_ASSERTEX(iEsc == 0);\n\t\t\tif (lpNext > lpBuffer)\n\t\t\t{\n\t\t\t\tm_Owner->ApplyDisplayParm();\n\n\t\t\t\tDWORD nWrite = (DWORD)(lpNext - lpBuffer);\n\t\t\t\t//lbRc = WriteText(lpBuffer, nWrite, lpNumberOfCharsWritten);\n\t\t\t\tlbRc = WriteText(lpBuffer, nWrite, lpNumberOfCharsWritten);\n\t\t\t\tif (!lbRc)\n\t\t\t\t\tgoto wrap;\n\t\t\t\t//write.Buffer = lpBuffer;\n\t\t\t\t//write.NumberOfCharsToWrite = nWrite;\n\t\t\t\t//lbRc = ExtWriteText(&write);\n\t\t\t\t//if (!lbRc)\n\t\t\t\t//\tgoto wrap;\n\t\t\t\t//else\n\t\t\t\t//{\n\t\t\t\t//\tif (lpNumberOfCharsWritten)\n\t\t\t\t//\t\t*lpNumberOfCharsWritten = write.NumberOfCharsWritten;\n\t\t\t\t//\tif (write.ScrolledRowsUp > 0)\n\t\t\t\t//\t\tgDisplayCursor.StoredCursorPos.Y = std::max(0,((int)gDisplayCursor.StoredCursorPos.Y - (int)write.ScrolledRowsUp));\n\t\t\t\t//}\n\t\t\t}\n\t\t}\n\n\t\tif (lpNext > lpBuffer)\n\t\t{\n\t\t\tlpBuffer = lpNext;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t_ASSERTEX(lpNext > lpBuffer || lpNext == nullptr);\n\t\t\t++lpBuffer;\n\t\t}\n\t}\n\n\tif (lbRc && lpNumberOfCharsWritten)\n\t\t*lpNumberOfCharsWritten = nNumberOfCharsToWrite;\n\nwrap:\n\tm_Owner->ApplyDisplayParm();\n\treturn lbRc;\n}\n\nvoid SrvAnsiImpl::WriteAnsiCode_CSI(AnsiEscCode& Code)\n{\n\t/*\n\nCSI ? P m h\t\t\tDEC Private Mode Set (DECSET)\n\tP s = 4 7 \u2192 Use Alternate Screen Buffer (unless disabled by the titeInhibit resource)\n\tP s = 1 0 4 7 \u2192 Use Alternate Screen Buffer (unless disabled by the titeInhibit resource)\n\tP s = 1 0 4 8 \u2192 Save cursor as in DECSC (unless disabled by the titeInhibit resource)\n\tP s = 1 0 4 9 \u2192 Save cursor as in DECSC and use Alternate Screen Buffer, clearing it first (unless disabled by the titeInhibit resource). This combines the effects of the 1 0 4 7 and 1 0 4 8 modes. Use this with terminfo-based applications rather than the 4 7 mode.\n\nCSI ? P m l\t\t\tDEC Private Mode Reset (DECRST)\n\tP s = 4 7 \u2192 Use Normal Screen Buffer\n\tP s = 1 0 4 7 \u2192 Use Normal Screen Buffer, clearing screen first if in the Alternate Screen (unless disabled by the titeInhibit resource)\n\tP s = 1 0 4 8 \u2192 Restore cursor as in DECRC (unless disabled by the titeInhibit resource)\n\tP s = 1 0 4 9 \u2192 Use Normal Screen Buffer and restore cursor as in DECRC (unless disabled by the titeInhibit resource). This combines the effects of the 1 0 4 7 and 1 0 4 8 modes. Use this with terminfo-based applications rather than the 4 7 mode.\n\n\nCSI P s @\t\t\tInsert P s (Blank) Character(s) (default = 1) (ICH)\n\n\t*/\n\tswitch (Code.Action) // case sensitive\n\t{\n\tcase L's':\n\t\t// Save cursor position (can not be nested)\n\t\tXTermSaveRestoreCursor(true);\n\t\tbreak;\n\n\tcase L'u':\n\t\t// Restore cursor position\n\t\tXTermSaveRestoreCursor(false);\n\t\tbreak;\n\n\tcase L'H': // Set cursor position (1-based)\n\tcase L'f': // Same as 'H'\n\tcase L'A': // Cursor up by N rows\n\tcase L'B': // Cursor down by N rows\n\tcase L'C': // Cursor right by N cols\n\tcase L'D': // Cursor left by N cols\n\tcase L'E': // Moves cursor to beginning of the line n (default 1) lines down.\n\tcase L'F': // Moves cursor to beginning of the line n (default 1) lines up.\n\tcase L'G': // Moves the cursor to column n.\n\tcase L'd': // Moves the cursor to line n.\n\t\t// Change cursor position\n\t\t{\n\t\t\t//if (gbIsVimProcess)\n\t\t\t//\tgbIsVimAnsi = true;\n\n\t\t\tstruct PointXY {int X,Y;};\n\t\t\tconst auto& workSize = m_Table->GetSize();\n\t\t\tconst struct {int left, top, right, bottom;} workRgn = {0, 0, (int)workSize.x - 1, workSize.y - 1};\n\t\t\t_ASSERTEX(workRgn.left <= workRgn.right && workRgn.top <= workRgn.bottom);\n\t\t\tconst auto& clipRgn = m_Table->GetScrollRegion();\n\t\t\tconst auto cur = PointXY{(int)m_Table->GetCursor().x, m_Table->GetCursor().y};\n\t\t\tPointXY crNewPos = cur;\n\t\t\tenum class Direction { kAbsolute, kCompatible, kRelative };\n\n\t\t\tauto set_y = [&crNewPos, &workRgn, &clipRgn, &cur](Direction direction, int value)\n\t\t\t{\n\t\t\t\tconst int kLegacyY = 9999;\n\t\t\t\tif (direction == Direction::kCompatible && value >= std::min(kLegacyY, workRgn.bottom))\n\t\t\t\t\t// #XTERM_256 Allow to put cursor into the legacy true-color area\n\t\t\t\t\tcrNewPos.Y = workRgn.bottom;\n\t\t\t\telse if (direction == Direction::kAbsolute || direction == Direction::kCompatible)\n\t\t\t\t\tcrNewPos.Y = std::max(workRgn.top, std::min(workRgn.bottom, value));\n\t\t\t\telse if (value < 0 && cur.Y >= (int)clipRgn.Top)\n\t\t\t\t\tcrNewPos.Y = std::max<int>(clipRgn.Top, std::min(workRgn.bottom, cur.Y + value));\n\t\t\t\telse if (value > 0 && cur.Y <= (int)clipRgn.Bottom)\n\t\t\t\t\tcrNewPos.Y = std::max(workRgn.top, std::min<int>(clipRgn.Bottom, cur.Y + value));\n\t\t\t\telse\n\t\t\t\t\tcrNewPos.Y = std::max(workRgn.top, std::min(workRgn.bottom, cur.Y + value));\n\t\t\t};\n\t\t\tauto set_x = [&crNewPos, &workRgn, &clipRgn, &cur](Direction direction, int value)\n\t\t\t{\n\t\t\t\tif (direction == Direction::kAbsolute || direction == Direction::kCompatible)\n\t\t\t\t\tcrNewPos.X = std::max(workRgn.left, std::min(workRgn.right, value));\n\t\t\t\telse\n\t\t\t\t\tcrNewPos.X = std::max(workRgn.left, std::min(workRgn.right, cur.X + value));\n\t\t\t};\n\n\t\t\tswitch (Code.Action)\n\t\t\t{\n\t\t\tcase L'H':\n\t\t\t\t// Set cursor position (ANSI values are 1-based)\n\t\t\t\tset_y(Direction::kCompatible, (Code.ArgC > 0 && Code.ArgV[0]) ? (Code.ArgV[0] - 1) : 0);\n\t\t\t\tset_x(Direction::kAbsolute, (Code.ArgC > 1 && Code.ArgV[1]) ? (Code.ArgV[1] - 1) : 0);\n\t\t\t\tbreak;\n\t\t\tcase L'f':\n\t\t\t\t// Set cursor position (ANSI values are 1-based)\n\t\t\t\tset_y(Direction::kAbsolute, (Code.ArgC > 0 && Code.ArgV[0]) ? (Code.ArgV[0] - 1) : 0);\n\t\t\t\tset_x(Direction::kAbsolute, (Code.ArgC > 1 && Code.ArgV[1]) ? (Code.ArgV[1] - 1) : 0);\n\t\t\t\tbreak;\n\t\t\tcase L'A':\n\t\t\t\t// Cursor up by N rows\n\t\t\t\tset_y(Direction::kRelative, -((Code.ArgC > 0 && Code.ArgV[0]) ? Code.ArgV[0] : 1));\n\t\t\t\tbreak;\n\t\t\tcase L'B':\n\t\t\t\t// Cursor down by N rows\n\t\t\t\tset_y(Direction::kRelative, +((Code.ArgC > 0 && Code.ArgV[0]) ? Code.ArgV[0] : 1));\n\t\t\t\tbreak;\n\t\t\tcase L'C':\n\t\t\t\t// Cursor right by N cols\n\t\t\t\tset_x(Direction::kRelative, +((Code.ArgC > 0 && Code.ArgV[0]) ? Code.ArgV[0] : 1));\n\t\t\t\tbreak;\n\t\t\tcase L'D':\n\t\t\t\t// Cursor left by N cols\n\t\t\t\tset_x(Direction::kRelative, -((Code.ArgC > 0 && Code.ArgV[0]) ? Code.ArgV[0] : 1));\n\t\t\t\tbreak;\n\t\t\tcase L'E':\n\t\t\t\t// Moves cursor to beginning of the line n (default 1) lines down.\n\t\t\t\tset_y(Direction::kRelative, +((Code.ArgC > 0 && Code.ArgV[0]) ? Code.ArgV[0] : 1));\n\t\t\t\tset_x(Direction::kAbsolute, 0);\n\t\t\t\tbreak;\n\t\t\tcase L'F':\n\t\t\t\t// Moves cursor to beginning of the line n (default 1) lines up.\n\t\t\t\tset_y(Direction::kRelative, -((Code.ArgC > 0 && Code.ArgV[0]) ? Code.ArgV[0] : 1));\n\t\t\t\tset_x(Direction::kAbsolute, 0);\n\t\t\t\tbreak;\n\t\t\tcase L'G':\n\t\t\t\t// Moves the cursor to column n.\n\t\t\t\tset_x(Direction::kAbsolute, (Code.ArgC > 0) ? (Code.ArgV[0] - 1) : 0);\n\t\t\t\tbreak;\n\t\t\tcase L'd':\n\t\t\t\t// Moves the cursor to line n (almost the same as 'H', but leave X unchanged).\n\t\t\t\tset_y(Direction::kAbsolute, (Code.ArgC > 0) ? (Code.ArgV[0] - 1) : 0);\n\t\t\t\tbreak;\n\t\t\t#ifdef _DEBUG\n\t\t\tdefault:\n\t\t\t\t_ASSERTEX(FALSE && \"Missed (sub)case value!\");\n\t\t\t#endif\n\t\t\t}\n\n\t\t\t// Goto\n\t\t\tm_Table->SetCursor({unsigned(crNewPos.X), crNewPos.Y});\n\n\t\t} // case 'H', 'f', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'd'\n\t\tbreak;\n\n\tcase L'J': // Clears part of the screen\n\t\t// Clears the screen and moves the cursor to the home position (line 0, column 0).\n\t\t{\n\t\t\tm_Owner->ApplyDisplayParm();\n\n\t\t\tint nCmd = (Code.ArgC > 0) ? Code.ArgV[0] : 0;\n\t\t\tcondata::Coord cur_pos = {};\n\t\t\tint from_row = -1, to_row = 0;\n\n\t\t\tswitch (nCmd)\n\t\t\t{\n\t\t\tcase 0:\n\t\t\t\t// clear from cursor to end of screen\n\t\t\t\tcur_pos = m_Table->GetCursor();\n\t\t\t\tfrom_row = cur_pos.y;\n\t\t\t\tto_row = m_Table->GetSize().y - 1;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\t// clear from cursor to beginning of the screen\n\t\t\t\tcur_pos = m_Table->GetCursor();\n\t\t\t\tfrom_row = 0;\n\t\t\t\tto_row = cur_pos.y;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\t// clear entire screen\n\t\t\t\tm_Table->ClearWorkspace();\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\t// xterm: clear scrollback buffer entirely\n\t\t\t\tm_Table->ClearBackscroll();\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t\t}\n\n\t\t\t// Clears only part of working area\n\t\t\tif (from_row >= 0)\n\t\t\t{\n\t\t\t\t_ASSERTE(to_row >= from_row);\n\t\t\t\tconst auto attr = m_Table->GetAttr();\n\t\t\t\tfor (int row = to_row; row >= from_row; --row)\n\t\t\t\t{\n\t\t\t\t\tif (row != cur_pos.y)\n\t\t\t\t\t\tm_Table->GetRow((unsigned)row)->Reset(attr);\n\t\t\t\t}\n\n\t\t\t\tauto row = m_Table->CurrentRow();\n\t\t\t\tswitch (nCmd)\n\t\t\t\t{\n\t\t\t\tcase 0:\n\t\t\t\t\t// clear from cursor to end of screen\n\t\t\t\t\trow->Delete(cur_pos.x, row->GetLength() - cur_pos.x);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\t// clear from cursor to beginning of the screen\n\t\t\t\t\trow->Delete(0, cur_pos.x + 1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t} // case L'J':\n\t\tbreak;\n\n\tcase L'b': // repeat output of the last written char N times\n\t\tif (!Code.PvtLen)\n\t\t{\n\t\t\tint repeat = (Code.ArgC > 0) ? Code.ArgV[0] : 1;\n\t\t\tif (m_Owner->m_LastWrittenChar && repeat > 0)\n\t\t\t{\n\t\t\t\tCEStr buffer;\n\t\t\t\tif (wchar_t* ptr = buffer.GetBuffer(repeat))\n\t\t\t\t{\n\t\t\t\t\tfor (int i = 0; i < repeat; ++i)\n\t\t\t\t\t\tptr[i] = m_Owner->m_LastWrittenChar;\n\t\t\t\t\tWriteText(ptr, repeat, nullptr);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\tbreak; // case L'b'\n\n\tcase L'K': // Erases part of the line\n\t\t{\n\t\t\tm_Owner->ApplyDisplayParm();\n\n\t\t\tint nCmd = (Code.ArgC > 0) ? Code.ArgV[0] : 0;\n\t\t\tconst auto cur = m_Table->GetCursor();\n\t\t\tauto row = m_Table->CurrentRow();\n\n\t\t\tswitch (nCmd)\n\t\t\t{\n\t\t\tcase 0: // clear from cursor to the end of the line (including char under the cursor)\n\t\t\t\trow->Delete(cur.x, row->GetLength() - cur.x);\n\t\t\t\tbreak;\n\t\t\tcase 1: // clear from cursor to beginning of the line (including char under the cursor)\n\t\t\t\trow->Write(0, m_Table->GetAttr(), L' ', cur.x + 1);\n\t\t\t\tbreak;\n\t\t\tcase 2: // clear entire line\n\t\t\t\t*row = condata::Row(m_Table->GetAttr());\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t\t}\n\t\t}\n\t\tbreak; // case L'K':\n\n\tcase L'r':\n\t\t//\\027[Pt;Pbr\n\t\t//\n\t\t// Pt is the number of the top line of the scrolling region;\n\t\t// Pb is the number of the bottom line of the scrolling region\n\t\t//  and must be greater than Pt.\n\t\t// (The default for Pt is line 1, the default for Pb is the end\n\t\t// of the screen)\n\t\t//\n\t\t// Values are 1-based\n\t\tif ((Code.ArgC >= 2) && (Code.ArgV[0] >= 0) && (Code.ArgV[1] >= Code.ArgV[0]))\n\t\t\tSetScrollRegion(true, Code.ArgV[0], Code.ArgV[1]);\n\t\telse\n\t\t\tSetScrollRegion(false);\n\t\tbreak; // L'r'\n\n\tcase L'L':\n\t\t// Insert P s Line(s) (default = 1) (IL).\n\t\tm_Owner->ApplyDisplayParm();\n\t\tm_Table->InsertRow((Code.ArgC > 0 && Code.ArgV[0] > 0) ? Code.ArgV[0] : 1);\n\t\tbreak;\n\n\tcase L'M':\n\t\t// Delete N Line(s) (default = 1) (DL).\n\t\t// This is actually \"Scroll UP N line(s) inside defined scrolling region\"\n\t\tm_Owner->ApplyDisplayParm();\n\t\tm_Table->DeleteRow((Code.ArgC > 0 && Code.ArgV[0] > 0) ? Code.ArgV[0] : 1);\n\t\tbreak;\n\n\tcase L'@':\n\t\t// Insert P s (Blank) Character(s) (default = 1) (ICH).\n\t\tm_Owner->ApplyDisplayParm();\n\t\tm_Table->InsertCell((Code.ArgC > 0 && Code.ArgV[0] > 0) ? Code.ArgV[0] : 1);\n\t\tbreak;\n\tcase L'P':\n\t\t// Delete P s Character(s) (default = 1) (DCH).\n\t\tm_Owner->ApplyDisplayParm();\n\t\tm_Table->DeleteCell((Code.ArgC > 0 && Code.ArgV[0] > 0) ? Code.ArgV[0] : 1);\n\t\tbreak;\n\n\tcase L'S':\n\t\t// Scroll whole page up by n (default 1) lines. New lines are added at the bottom.\n\t\tm_Owner->ApplyDisplayParm();\n\t\tm_Table->Scroll((Code.ArgC > 0 && Code.ArgV[0] > 0) ? -Code.ArgV[0] : -1);\n\t\tbreak;\n\n\tcase L'T':\n\t\t// Scroll whole page down by n (default 1) lines. New lines are added at the top.\n\t\tm_Owner->ApplyDisplayParm();\n\t\tm_Table->Scroll((Code.ArgC > 0 && Code.ArgV[0] > 0) ? Code.ArgV[0] : 1);\n\t\tbreak;\n\n\tcase L'h':\n\tcase L'l':\n\t\t// Set/ReSet Mode\n\t\tif (Code.ArgC > 0)\n\t\t{\n\t\t\t//ESC [ 3 h\n\t\t\t//       DECCRM (default off): Display control chars.\n\n\t\t\t//ESC [ 4 h\n\t\t\t//       DECIM (default off): Set insert mode.\n\n\t\t\t//ESC [ 20 h\n\t\t\t//       LF/NL (default off): Automatically follow echo of LF, VT or FF with CR.\n\n\t\t\t//ESC [ ? 1 h\n\t\t\t//\t  DECCKM (default off): When set, the cursor keys send an ESC O prefix,\n\t\t\t//\t  rather than ESC [.\n\n\t\t\t//ESC [ ? 3 h\n\t\t\t//\t  DECCOLM (default off = 80 columns): 80/132 col mode switch.  The driver\n\t\t\t//\t  sources note that this alone does not suffice; some user-mode utility\n\t\t\t//\t  such as resizecons(8) has to change the hardware registers on the\n\t\t\t//\t  console video card.\n\n\t\t\t//ESC [ ? 5 h\n\t\t\t//\t  DECSCNM (default off): Set reverse-video mode.\n\n\t\t\t//ESC [ ? 6 h\n\t\t\t//\t  DECOM (default off): When set, cursor addressing is relative to the\n\t\t\t//\t  upper left corner of the scrolling region.\n\n\n\t\t\t//ESC [ ? 8 h\n\t\t\t//\t  DECARM (default on): Set keyboard autorepeat on.\n\n\t\t\t//ESC [ ? 9 h\n\t\t\t//\t  X10 Mouse Reporting (default off): Set reporting mode to 1 (or reset to\n\t\t\t//\t  0) -- see below.\n\n\t\t\t//ESC [ ? 1000 h\n\t\t\t//\t  X11 Mouse Reporting (default off): Set reporting mode to 2 (or reset to\n\t\t\t//\t  0) -- see below.\n\n\t\t\t//ESC [ ? 7711 h\n\t\t\t//    mimic mintty code, same as \"ESC ] 9 ; 12 ST\"\n\n\t\t\tswitch (Code.ArgV[0])\n\t\t\t{\n\t\t\tcase 1:\n\t\t\t\tif ((Code.PvtLen == 1) && (Code.Pvt[0] == L'?'))\n\t\t\t\t{\n\t\t\t\t\tm_Owner->gDisplayCursor.CursorKeysApp = (Code.Action == L'h');\n\n\t\t\t\t\t#if 0\n\t\t\t\t\tif (gbIsVimProcess)\n\t\t\t\t\t{\n\t\t\t\t\t\tTODO(\"Need to find proper way for activation alternative buffer from ViM?\");\n\t\t\t\t\t\tif (Code.Action == L'h')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tStartVimTerm(false);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tStopVimTerm();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t#endif\n\n\t\t\t\t\tm_Owner->ChangeTermMode(tmc_AppCursorKeys, (Code.Action == L'h'));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart, Code.nTotalLen);\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tm_Owner->gDisplayOpt.ShowRawAnsi = (Code.Action == L'h');\n\t\t\t\tbreak;\n\t\t\tcase 7:\n\t\t\t\t//ESC [ ? 7 h\n\t\t\t\t//\t  DECAWM (default off): Set autowrap on.  In this mode, a graphic\n\t\t\t\t//\t  character emitted after column 80 (or column 132 of DECCOLM is on)\n\t\t\t\t//\t  forces a wrap to the beginning of the following line first.\n\t\t\t\t//ESC [ = 7 h\n\t\t\t\t//    Enables line wrapping\n\t\t\t\t//ESC [ 7 ; _col_ h\n\t\t\t\t//    Our extension. _col_ - wrap at column (1-based), default = 80\n\t\t\t\tif ((m_Owner->gDisplayOpt.WrapWasSet = (Code.Action == L'h')))\n\t\t\t\t{\n\t\t\t\t\tm_Owner->gDisplayOpt.WrapAt = ((Code.ArgC > 1) && (Code.ArgV[1] > 0)) ? Code.ArgV[1] : 80;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 20:\n\t\t\t\tif (Code.PvtLen == 0)\n\t\t\t\t{\n\t\t\t\t\tm_Owner->gDisplayOpt.AutoLfNl = (Code.Action == L'h');\n\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, SrvAnsi::de_Ignored);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart, Code.nTotalLen);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t//ESC [ ? 12 h\n\t\t\t//\t  Start Blinking Cursor (att610)\n\t\t\tcase 12:\n\t\t\t//ESC [ ? 25 h\n\t\t\t//\t  DECTECM (default on): Make cursor visible.\n\t\t\tcase 25:\n\t\t\t\tif ((Code.PvtLen == 1) && (Code.Pvt[0] == L'?'))\n\t\t\t\t{\n\t\t\t\t\tbool unknown = false;\n\t\t\t\t\tfor (int i = 0; i < Code.ArgC; ++i)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (Code.ArgV[i] == 25)\n\t\t\t\t\t\t\tm_Owner->SetCursorVisibility((Code.Action == L'h'));\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tunknown = true;\n\t\t\t\t\t}\n\t\t\t\t\tif (unknown)\n\t\t\t\t\t{\n\t\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, SrvAnsi::de_Ignored);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart, Code.nTotalLen);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tif (Code.PvtLen == 0)\n\t\t\t\t{\n\t\t\t\t\t/* h=Insert Mode (IRM), l=Replace Mode (IRM) */\n\t\t\t\t\t// Nano posts the `ESC [ 4 l` on start, but do not post `ESC [ 4 h` on exit, that is strange...\n\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, SrvAnsi::de_Ignored); // ignored for now\n\t\t\t\t}\n\t\t\t\telse if ((Code.PvtLen == 1) && (Code.Pvt[0] == L'?'))\n\t\t\t\t{\n\t\t\t\t\t/* h=Smooth (slow) scroll, l=Jump (fast) scroll */\n\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, SrvAnsi::de_Ignored); // ignored for now\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart, Code.nTotalLen);\n\t\t\t\tbreak;\n\t\t\tcase 9:    /* X10_MOUSE */\n\t\t\tcase 1000: /* VT200_MOUSE */\n\t\t\tcase 1002: /* BTN_EVENT_MOUSE */\n\t\t\tcase 1003: /* ANY_EVENT_MOUSE */\n\t\t\tcase 1004: /* FOCUS_EVENT_MOUSE */\n\t\t\tcase 1005: /* Xterm's UTF8 encoding for mouse positions */\n\t\t\tcase 1006: /* Xterm's CSI-style mouse encoding */\n\t\t\tcase 1015: /* Urxvt's CSI-style mouse encoding */\n\t\t\t\tif ((Code.PvtLen == 1) && (Code.Pvt[0] == L'?'))\n\t\t\t\t{\n\t\t\t\t\tstatic DWORD LastMode = 0;\n\t\t\t\t\tTermMouseMode ModeMask = (Code.ArgV[0] == 9) ? tmm_X10\n\t\t\t\t\t\t: (Code.ArgV[0] == 1000) ? tmm_VT200\n\t\t\t\t\t\t: (Code.ArgV[0] == 1002) ? tmm_BTN\n\t\t\t\t\t\t: (Code.ArgV[0] == 1003) ? tmm_ANY\n\t\t\t\t\t\t: (Code.ArgV[0] == 1004) ? tmm_FOCUS\n\t\t\t\t\t\t: (Code.ArgV[0] == 1005) ? tmm_UTF8\n\t\t\t\t\t\t: (Code.ArgV[0] == 1006) ? tmm_XTERM\n\t\t\t\t\t\t: (Code.ArgV[0] == 1015) ? tmm_URXVT\n\t\t\t\t\t\t: tmm_None;\n\t\t\t\t\tDWORD Mode = (Code.Action == L'h')\n\t\t\t\t\t\t? (LastMode | ModeMask)\n\t\t\t\t\t\t: (LastMode & ~ModeMask);\n\t\t\t\t\tLastMode = Mode;\n\t\t\t\t\tm_Owner->ChangeTermMode(tmc_MouseMode, Mode);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart, Code.nTotalLen);\n\t\t\t\tbreak;\n\t\t\tcase 7786: /* 'V': Mousewheel reporting */\n\t\t\tcase 7787: /* 'W': Application mousewheel mode */\n\t\t\t\tif ((Code.PvtLen == 1) && (Code.Pvt[0] == L'?'))\n\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, SrvAnsi::de_Ignored); // ignored for now\n\t\t\t\telse\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart, Code.nTotalLen);\n\t\t\t\tbreak;\n\t\t\tcase 1034:\n\t\t\t\t// Interpret \"meta\" key, sets eighth bit. (enables/disables the eightBitInput resource).\n\t\t\t\tif ((Code.PvtLen == 1) && (Code.Pvt[0] == L'?'))\n\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, SrvAnsi::de_Ignored);\n\t\t\t\telse\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart, Code.nTotalLen);\n\t\t\t\tbreak;\n\t\t\tcase 47:   /* alternate screen */\n\t\t\tcase 1047: /* alternate screen */\n\t\t\tcase 1049: /* cursor & alternate screen */\n\t\t\t\t// xmux/screen: Alternate screen\n\t\t\t\tif ((Code.PvtLen == 1) && (Code.Pvt[0] == L'?'))\n\t\t\t\t{\n\t\t\t\t\tm_Owner->ApplyDisplayParm();\n\n\t\t\t\t\t// \\e[?1049h: save cursor pos\n\t\t\t\t\tif ((Code.ArgV[0] == 1049) && (Code.Action == L'h'))\n\t\t\t\t\t\tXTermSaveRestoreCursor(true);\n\t\t\t\t\t// h: switch to alternative buffer without backscroll\n\t\t\t\t\t// l: restore saved scrollback buffer\n\t\t\t\t\tXTermAltBuffer((Code.Action == L'h'));\n\t\t\t\t\t// \\e[?1049l - restore cursor pos\n\t\t\t\t\tif ((Code.ArgV[0] == 1049) && (Code.Action == L'l'))\n\t\t\t\t\t\tXTermSaveRestoreCursor(false);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart, Code.nTotalLen);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 1048: /* save/restore cursor */\n\t\t\t\tif ((Code.PvtLen == 1) && (Code.Pvt[0] == L'?'))\n\t\t\t\t\tXTermSaveRestoreCursor((Code.Action == L'h'));\n\t\t\t\telse\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart, Code.nTotalLen);\n\t\t\t\tbreak;\n\t\t\tcase 2004: /* bracketed paste */\n\t\t\t\t/* All \"pasted\" text will be wrapped in `\\e[200~ ... \\e[201~` */\n\t\t\t\tif ((Code.PvtLen == 1) && (Code.Pvt[0] == L'?'))\n\t\t\t\t\tm_Owner->ChangeTermMode(tmc_BracketedPaste, (Code.Action == L'h'));\n\t\t\t\telse\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart, Code.nTotalLen);\n\t\t\t\tbreak;\n\t\t\tcase 7711:\n\t\t\t\tif ((Code.Action == L'h') && (Code.PvtLen == 1) && (Code.Pvt[0] == L'?'))\n\t\t\t\t{\n\t\t\t\t\t//ESC [ ? 7711 h\n\t\t\t\t\t//    mimic mintty code, same as \"ESC ] 9 ; 12 ST\"\n\t\t\t\t\tm_Table->PromptPosStore();\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart, Code.nTotalLen);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t\t}\n\n\t\t\t//switch (Code.ArgV[0])\n\t\t\t//{\n\t\t\t//case 0: case 1:\n\t\t\t//\t// 40x25\n\t\t\t//\tif ((m_Owner->gDisplayOpt.WrapWasSet = (Code.Action == L'h')))\n\t\t\t//\t{\n\t\t\t//\t\tm_Owner->gDisplayOpt.WrapAt = 40;\n\t\t\t//\t}\n\t\t\t//\tbreak;\n\t\t\t//case 2: case 3:\n\t\t\t//\t// 80x25\n\t\t\t//\tif ((m_Owner->gDisplayOpt.WrapWasSet = (Code.Action == L'h')))\n\t\t\t//\t{\n\t\t\t//\t\tm_Owner->gDisplayOpt.WrapAt = 80;\n\t\t\t//\t}\n\t\t\t//\tbreak;\n\t\t\t//case 7:\n\t\t\t//\t{\n\t\t\t//\t\tDWORD Mode = 0;\n\t\t\t//\t\tGetConsoleMode(&Mode);\n\t\t\t//\t\tif (Code.Action == L'h')\n\t\t\t//\t\t\tMode |= ENABLE_WRAP_AT_EOL_OUTPUT;\n\t\t\t//\t\telse\n\t\t\t//\t\t\tMode &= ~ENABLE_WRAP_AT_EOL_OUTPUT;\n\t\t\t//\t\tSetConsoleMode(Mode);\n\t\t\t//\t} // enable/disable line wrapping\n\t\t\t//\tbreak;\n\t\t\t//}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t}\n\t\tbreak; // case L'h': case L'l':\n\n\tcase L'n':\n\t\tif (Code.ArgC > 0)\n\t\t{\n\t\t\tswitch (*Code.ArgV)\n\t\t\t{\n\t\t\tcase 5:\n\t\t\t\t//ESC [ 5 n\n\t\t\t\t//      Device status report (DSR): Answer is ESC [ 0 n (Terminal OK).\n\t\t\t\t//\n\t\t\t\tReportString(L\"\\x1B[0n\");\n\t\t\t\tbreak;\n\t\t\tcase 6:\n\t\t\t\t//ESC [ 6 n\n\t\t\t\t//      Cursor position report (CPR): Answer is ESC [ y ; x R, where x,y is the\n\t\t\t\t//      cursor location.\n\t\t\t\tReportCursorPosition();\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t}\n\t\tbreak;\n\n\tcase L'm':\n\t\tif (Code.PvtLen > 0)\n\t\t{\n\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, SrvAnsi::de_Ignored);\n\t\t}\n\t\t// Set display mode (colors, fonts, etc.)\n\t\telse if (!Code.ArgC)\n\t\t{\n\t\t\tm_Owner->ReSetDisplayParm(TRUE, FALSE);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor (int i = 0; i < Code.ArgC; i++)\n\t\t\t{\n\t\t\t\tswitch (Code.ArgV[i])\n\t\t\t\t{\n\t\t\t\tcase 0:\n\t\t\t\t\tm_Owner->ReSetDisplayParm(TRUE, FALSE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\t// Bold\n\t\t\t\t\tm_Owner->gDisplayParm.setBrightOrBold(TRUE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\t// Faint, decreased intensity (ISO 6429)\n\t\t\t\tcase 22:\n\t\t\t\t\t// Normal (neither bold nor faint).\n\t\t\t\t\tm_Owner->gDisplayParm.setBrightOrBold(FALSE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3:\n\t\t\t\t\t// Italic\n\t\t\t\t\tm_Owner->gDisplayParm.setItalic(TRUE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 23:\n\t\t\t\t\t// Not italic\n\t\t\t\t\tm_Owner->gDisplayParm.setItalic(FALSE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 5: // #TODO ANSI Slow Blink (less than 150 per minute)\n\t\t\t\tcase 6: // #TODO ANSI Rapid Blink (150+ per minute)\n\t\t\t\tcase 25: // #TODO ANSI Blink Off\n\t\t\t\t\tDumpKnownEscape(Code.pszEscStart,Code.nTotalLen,SrvAnsi::de_Ignored);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 4: // Underlined\n\t\t\t\t\tm_Owner->gDisplayParm.setUnderline(TRUE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 24:\n\t\t\t\t\t// Not underlined\n\t\t\t\t\tm_Owner->gDisplayParm.setUnderline(FALSE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 7:\n\t\t\t\t\t// Reverse video\n\t\t\t\t\tm_Owner->gDisplayParm.setInverse(TRUE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 27:\n\t\t\t\t\t// Positive (not inverse)\n\t\t\t\t\tm_Owner->gDisplayParm.setInverse(FALSE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 30: case 31: case 32: case 33: case 34: case 35: case 36: case 37:\n\t\t\t\t\tm_Owner->gDisplayParm.setTextColor(Code.ArgV[i] - 30);\n\t\t\t\t\tm_Owner->gDisplayParm.setBrightFore(FALSE);\n\t\t\t\t\tm_Owner->gDisplayParm.setText256(SrvAnsi::clr4b);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 38:\n\t\t\t\t\t// xterm-256 colors\n\t\t\t\t\t// ESC [ 38 ; 5 ; I m -- set foreground to I (0..255) color from xterm palette\n\t\t\t\t\tif (((i+2) < Code.ArgC) && (Code.ArgV[i+1] == 5))\n\t\t\t\t\t{\n\t\t\t\t\t\tm_Owner->gDisplayParm.setTextColor(Code.ArgV[i+2] & 0xFF);\n\t\t\t\t\t\tm_Owner->gDisplayParm.setText256(SrvAnsi::clr8b);\n\t\t\t\t\t\ti += 2;\n\t\t\t\t\t}\n\t\t\t\t\t// xterm-256 colors\n\t\t\t\t\t// ESC [ 38 ; 2 ; R ; G ; B m -- set foreground to RGB(R,G,B) 24-bit color\n\t\t\t\t\telse if (((i+4) < Code.ArgC) && (Code.ArgV[i+1] == 2))\n\t\t\t\t\t{\n\t\t\t\t\t\tm_Owner->gDisplayParm.setTextColor(RGB((Code.ArgV[i+2] & 0xFF),(Code.ArgV[i+3] & 0xFF),(Code.ArgV[i+4] & 0xFF)));\n\t\t\t\t\t\tm_Owner->gDisplayParm.setText256(SrvAnsi::clr24b);\n\t\t\t\t\t\ti += 4;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 39:\n\t\t\t\t\t// Reset\n\t\t\t\t\tm_Owner->gDisplayParm.setTextColor(CONFORECOLOR(SrvAnsi::GetDefaultAnsiAttr()));\n\t\t\t\t\tm_Owner->gDisplayParm.setBrightFore(FALSE);\n\t\t\t\t\tm_Owner->gDisplayParm.setText256(SrvAnsi::clr4b);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 40: case 41: case 42: case 43: case 44: case 45: case 46: case 47:\n\t\t\t\t\tm_Owner->gDisplayParm.setBackColor(Code.ArgV[i] - 40);\n\t\t\t\t\tm_Owner->gDisplayParm.setBrightBack(FALSE);\n\t\t\t\t\tm_Owner->gDisplayParm.setBack256(SrvAnsi::clr4b);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 48:\n\t\t\t\t\t// xterm-256 colors\n\t\t\t\t\t// ESC [ 48 ; 5 ; I m -- set background to I (0..255) color from xterm palette\n\t\t\t\t\tif (((i+2) < Code.ArgC) && (Code.ArgV[i+1] == 5))\n\t\t\t\t\t{\n\t\t\t\t\t\tm_Owner->gDisplayParm.setBackColor(Code.ArgV[i+2] & 0xFF);\n\t\t\t\t\t\tm_Owner->gDisplayParm.setBack256(SrvAnsi::clr8b);\n\t\t\t\t\t\ti += 2;\n\t\t\t\t\t}\n\t\t\t\t\t// xterm-256 colors\n\t\t\t\t\t// ESC [ 48 ; 2 ; R ; G ; B m -- set background to RGB(R,G,B) 24-bit color\n\t\t\t\t\telse if (((i+4) < Code.ArgC) && (Code.ArgV[i+1] == 2))\n\t\t\t\t\t{\n\t\t\t\t\t\tm_Owner->gDisplayParm.setBackColor(RGB((Code.ArgV[i+2] & 0xFF),(Code.ArgV[i+3] & 0xFF),(Code.ArgV[i+4] & 0xFF)));\n\t\t\t\t\t\tm_Owner->gDisplayParm.setBack256(SrvAnsi::clr24b);\n\t\t\t\t\t\ti += 4;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 49:\n\t\t\t\t\t// Reset\n\t\t\t\t\tm_Owner->gDisplayParm.setBackColor(CONBACKCOLOR(SrvAnsi::GetDefaultAnsiAttr()));\n\t\t\t\t\tm_Owner->gDisplayParm.setBrightBack(FALSE);\n\t\t\t\t\tm_Owner->gDisplayParm.setBack256(SrvAnsi::clr4b);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 90: case 91: case 92: case 93: case 94: case 95: case 96: case 97:\n\t\t\t\t\tm_Owner->gDisplayParm.setTextColor((Code.ArgV[i] - 90) | 0x8);\n\t\t\t\t\tm_Owner->gDisplayParm.setText256(SrvAnsi::clr4b);\n\t\t\t\t\tm_Owner->gDisplayParm.setBrightFore(TRUE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 100: case 101: case 102: case 103: case 104: case 105: case 106: case 107:\n\t\t\t\t\tm_Owner->gDisplayParm.setBackColor((Code.ArgV[i] - 100) | 0x8);\n\t\t\t\t\tm_Owner->gDisplayParm.setBack256(SrvAnsi::clr4b);\n\t\t\t\t\tm_Owner->gDisplayParm.setBrightBack(TRUE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 10:\n\t\t\t\t\t// Something strange and unknown... (received from ssh)\n\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, SrvAnsi::de_Ignored);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 312:\n\t\t\t\tcase 315:\n\t\t\t\tcase 414:\n\t\t\t\tcase 3130:\n\t\t\t\t\t// Something strange and unknown... (received from vim on WSL)\n\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, SrvAnsi::de_Ignored);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak; // \"[...m\"\n\n\tcase L'p':\n\t\tif (Code.ArgC == 0 && Code.PvtLen == 1 && Code.Pvt[0] == L'!')\n\t\t{\n\t\t\tFullReset();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t}\n\t\tbreak; // \"[!p\"\n\n\tcase L'q':\n\t\tif ((Code.PvtLen == 1) && (Code.Pvt[0] == L' '))\n\t\t{\n\t\t\t/*\n\t\t\tCSI Ps SP q\n\t\t\t\tSet cursor style (DECSCUSR, VT520).\n\t\t\t\t\tPs = 0  -> ConEmu's default.\n\t\t\t\t\tPs = 1  -> blinking block.\n\t\t\t\t\tPs = 2  -> steady block.\n\t\t\t\t\tPs = 3  -> blinking underline.\n\t\t\t\t\tPs = 4  -> steady underline.\n\t\t\t\t\tPs = 5  -> blinking bar (xterm).\n\t\t\t\t\tPs = 6  -> steady bar (xterm).\n\t\t\t*/\n\t\t\tunsigned nStyle = ((Code.ArgC == 0) || (Code.ArgV[0] < 0) || (Code.ArgV[0] > 6))\n\t\t\t\t? 0 : Code.ArgV[0];\n\t\t\tm_Owner->SetCursorShape(nStyle);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t}\n\t\tbreak; // \"[...q\"\n\n\tcase L't':\n\t\tif (Code.ArgC > 0 && Code.ArgC <= 3)\n\t\t{\n\t\t\tfor (int i = 0; i < Code.ArgC; i++)\n\t\t\t{\n\t\t\t\tswitch (Code.ArgV[i])\n\t\t\t\t{\n\t\t\t\tcase 8:\n\t\t\t\t\t// `ESC [ 8 ; height ; width t` --> Resize the text area to [height;width] in characters.\n\t\t\t\t\t{\n\t\t\t\t\t\tint height = -1, width = -1;\n\t\t\t\t\t\tif (i < Code.ArgC)\n\t\t\t\t\t\t\theight = Code.ArgV[++i];\n\t\t\t\t\t\tif (i < Code.ArgC)\n\t\t\t\t\t\t\twidth = Code.ArgV[++i];\n\t\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, SrvAnsi::de_Ignored);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 14:\n\t\t\t\t\t// `ESC [ 1 4 t` --> Reports terminal window size in pixels as `CSI 4 ; height ; width t`.\n\t\t\t\t\tReportTerminalPixelSize();\n\t\t\t\t\tbreak;\n\t\t\t\tcase 18:\n\t\t\t\tcase 19:\n\t\t\t\t\t// `ESC [ 1 8 t` --> Report the size of the text area in characters as `CSI 8 ; height ; width t`\n\t\t\t\t\t// `ESC [ 1 9 t` --> Report the size of the screen in characters as `CSI 9 ; height ; width t`\n\t\t\t\t\tReportTerminalCharSize(Code.ArgV[i]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 21:\n\t\t\t\t\t// `ESC [ 2 1 t` --> Report terminal window title as `OSC l title ST`\n\t\t\t\t\tReportConsoleTitle();\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tTODO(\"ANSI: xterm window manipulation\");\n\t\t\t\t\t//Window manipulation (from dtterm, as well as extensions). These controls may be disabled using the allowWindowOps resource. Valid values for the first (and any additional parameters) are:\n\t\t\t\t\t// 1 --> De-iconify window.\n\t\t\t\t\t// 2 --> Iconify window.\n\t\t\t\t\t// 3 ; x ; y --> Move window to [x, y].\n\t\t\t\t\t// 4 ; height ; width --> Resize the xterm window to height and width in pixels.\n\t\t\t\t\t// 5 --> Raise the xterm window to the front of the stacking order.\n\t\t\t\t\t// 6 --> Lower the xterm window to the bottom of the stacking order.\n\t\t\t\t\t// 7 --> Refresh the xterm window.\n\t\t\t\t\t// 8 ; height ; width --> Resize the text area to [height;width] in characters.\n\t\t\t\t\t// 9 ; 0 --> Restore maximized window.\n\t\t\t\t\t// 9 ; 1 --> Maximize window (i.e., resize to screen size).\n\t\t\t\t\t// 1 1 --> Report xterm window state. If the xterm window is open (non-iconified), it returns CSI 1 t . If the xterm window is iconified, it returns CSI 2 t .\n\t\t\t\t\t// 1 3 --> Report xterm window position as CSI 3 ; x; y t\n\t\t\t\t\t// 1 4 --> Report xterm window in pixels as CSI 4 ; height ; width t\n\t\t\t\t\t// 2 0 --> Report xterm window\ufffds icon label as OSC L label ST\n\t\t\t\t\t// >= 2 4 --> Resize to P s lines (DECSLPP)\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t}\n\t\tbreak;\n\n\tcase L'c':\n\t\t// echo -e \"\\e[>c\"\n\t\tif ((Code.PvtLen == 1) && (Code.Pvt[0] == L'>')\n\t\t\t&& ((Code.ArgC < 1) || (Code.ArgV[0] == 0)))\n\t\t{\n\t\t\t// P s = 0 or omitted -> request the terminal's identification code.\n\t\t\twchar_t szVerInfo[64];\n\t\t\t// this will be \"ESC > 67 ; build ; 0 c\"\n\t\t\t// 67 is ASCII code of 'C' (ConEmu, yeah)\n\t\t\t// Other terminals report examples: MinTTY -> 77, rxvt -> 82, screen -> 83\n\t\t\t// msprintf(szVerInfo, countof(szVerInfo), L\"\\x1B>%u;%u;0c\", (int)'C', MVV_1*10000+MVV_2*100+MVV_3);\n\t\t\t// Emulate xterm version 136?\n\t\t\twcscpy_c(szVerInfo, L\"\\x1B[>0;136;0c\");\n\t\t\tReportString(szVerInfo);\n\t\t}\n\t\t// echo -e \"\\e[c\"\n\t\telse if ((Code.ArgC < 1) || (Code.ArgV[0] == 0))\n\t\t{\n\t\t\t// Report \"VT100 with Advanced Video Option\"\n\t\t\tReportString(L\"\\x1B[?1;2c\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t}\n\t\tbreak;\n\n\tcase L'X':\n\t\t// CSI P s X:  Erase P s Character(s) (default = 1) (ECH)\n\t\t{\n\t\t\tm_Owner->ApplyDisplayParm();\n\t\t\tconst auto cur = m_Table->GetCursor();\n\t\t\tauto row = m_Table->CurrentRow();\n\t\t\tconst unsigned nCount = (Code.ArgC > 0) ? unsigned(Code.ArgV[0]) : 1;\n\t\t\tconst unsigned nMax = row->GetLength();\n\t\t\trow->Write(cur.x, m_Table->GetAttr(), L' ', std::min(nCount, (nMax > cur.x) ? (nMax - cur.x) : 0));\n\t\t} // case L'X':\n\t\tbreak;\n\n\tdefault:\n\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t} // switch (Code.Action)\n}\n\nvoid SrvAnsiImpl::WriteAnsiCode_OSC(AnsiEscCode& Code)\n{\n\tif (!Code.ArgSZ)\n\t{\n\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\treturn;\n\t}\n\n\t// Finalizing (ST) with \"\\x1B\\\\\" or \"\\x07\"\n\n\t// #condata ESC ] 10 ; txt ST       Set dynamic text color to txt.\n\t// #condata ESC ] 4 6 ; name ST     Change log file to name (normally disabled by a compile-time option)\n\t// #condata ESC ] 5 0 ; fn ST       Set font to fn.\n\n\tswitch (*Code.ArgSZ)\n\t{\n\tcase L'0':\n\tcase L'1':\n\tcase L'2':\n\t\t//ESC ] 0 ; txt ST        Set icon name and window title to txt.\n\t\t//ESC ] 1 ; txt ST        Set icon name to txt.\n\t\t//ESC ] 2 ; txt ST        Set window title to txt.\n\t\tif (Code.ArgSZ[1] == L';' && Code.ArgSZ[2])\n\t\t{\n\t\t\twchar_t* pszNewTitle = (wchar_t*)malloc(sizeof(wchar_t)*(Code.cchArgSZ));\n\t\t\tif (pszNewTitle)\n\t\t\t{\n\t\t\t\tEscCopyCtrlString(pszNewTitle, Code.ArgSZ+2, Code.cchArgSZ-2);\n\t\t\t\tSetConsoleTitle(*pszNewTitle ? pszNewTitle : m_Owner->gsInitConTitle);\n\t\t\t\tfree(pszNewTitle);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase L'4':\n\t\t// ESC ] 4 ; num; txt ST   Set ANSI color num to txt.\n\t\t// #condata the following is suggestion for exact palette colors\n\t\t// #condata but are using standard xterm palette or truecolor 24bit palette\n\t\t_ASSERTEX(Code.ArgSZ[1] == L';');\n\t\tbreak;\n\n\tcase L'9':\n\t\t// ConEmu specific\n\t\t// ESC ] 9 ; 1 ; ms ST           Sleep. ms - milliseconds\n\t\t// ESC ] 9 ; 2 ; \"txt\" ST        Show GUI MessageBox ( txt ) for dubug purposes\n\t\t// ESC ] 9 ; 3 ; \"txt\" ST        Set TAB text\n\t\t// ESC ] 9 ; 4 ; st ; pr ST      When _st_ is 0: remove progress. When _st_ is 1: set progress value to _pr_ (number, 0-100).\n\t\t//                               When _st_ is 2: set error state in progress on Windows 7 taskbar, _pr_ is optional.\n\t\t//                               When _st_ is 3: set indeterminate state. When _st_ is 4: set paused state, _pr_ is optional.\n\t\t// ESC ] 9 ; 5 ST                Wait for ENTER/SPACE/ESC. Set EnvVar \"ConEmuWaitKey\" to ENTER/SPACE/ESC on exit.\n\t\t// ESC ] 9 ; 6 ; \"txt\" ST        Execute GuiMacro. Set EnvVar \"ConEmuMacroResult\" on exit.\n\t\t// ESC ] 9 ; 7 ; \"cmd\" ST        Run some process with arguments\n\t\t// ESC ] 9 ; 8 ; \"env\" ST        Output value of environment variable\n\t\t// ESC ] 9 ; 9 ; \"cwd\" ST        Inform ConEmu about shell current working directory\n\t\t// ESC ] 9 ; 10 ; p ST           Request xterm keyboard emulation\n\t\t// ESC ] 9 ; 11; \"*txt*\" ST      Just a \u2018comment\u2019, skip it.\n\t\t// ESC ] 9 ; 12 ST               Let ConEmu treat current cursor position as prompt start. Useful with `PS1`.\n\t\tif (Code.ArgSZ[1] == L';')\n\t\t{\n\t\t\tif (Code.ArgSZ[2] == L'1')\n\t\t\t{\n\t\t\t\tif (Code.ArgSZ[3] == L';')\n\t\t\t\t{\n\t\t\t\t\t// ESC ] 9 ; 1 ; ms ST\n\t\t\t\t\tDoSleep(Code.ArgSZ+4);\n\t\t\t\t}\n\t\t\t\telse if (Code.ArgC >= 2 && Code.ArgV[1] == 10)\n\t\t\t\t{\n\t\t\t\t\t// ESC ] 9 ; 10 ST\n\t\t\t\t\t// ESC ] 9 ; 10 ; 1 ST\n\t\t\t\t\tif (!m_Owner->gbIsXTermOutput && (Code.ArgC == 2 || Code.ArgV[2] == 1))\n\t\t\t\t\t\tm_Owner->StartXTermMode(true);\n\t\t\t\t\t// ESC ] 9 ; 10 ; 0 ST\n\t\t\t\t\telse if (Code.ArgC >= 3 || Code.ArgV[2] == 0)\n\t\t\t\t\t\tm_Owner->StartXTermMode(false);\n\t\t\t\t\t// ESC ] 9 ; 10 ; 3 ST\n\t\t\t\t\telse if (Code.ArgC >= 3 || Code.ArgV[2] == 3)\n\t\t\t\t\t\tm_Owner->StartXTermOutput(true);\n\t\t\t\t\t// ESC ] 9 ; 10 ; 2 ST\n\t\t\t\t\telse if (Code.ArgC >= 3 || Code.ArgV[2] == 2)\n\t\t\t\t\t\tm_Owner->StartXTermOutput(false);\n\t\t\t\t}\n\t\t\t\telse if (Code.ArgSZ[3] == L'1' && Code.ArgSZ[4] == L';')\n\t\t\t\t{\n\t\t\t\t\t// ESC ] 9 ; 11; \"*txt*\" ST - Just a \u2018comment\u2019, skip it.\n\t\t\t\t\tDumpKnownEscape(Code.ArgSZ+5, lstrlen(Code.ArgSZ+5), SrvAnsi::de_Comment);\n\t\t\t\t}\n\t\t\t\telse if (Code.ArgSZ[3] == L'2')\n\t\t\t\t{\n\t\t\t\t\t// ESC ] 9 ; 12 ST\n\t\t\t\t\tm_Table->PromptPosStore();\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (Code.ArgSZ[2] == L'2' && Code.ArgSZ[3] == L';')\n\t\t\t{\n\t\t\t\tDoMessage(Code.ArgSZ+4, Code.cchArgSZ - 4);\n\t\t\t}\n\t\t\telse if (Code.ArgSZ[2] == L'3' && Code.ArgSZ[3] == L';')\n\t\t\t{\n\t\t\t\tCESERVER_REQ* pIn = ExecuteNewCmd(CECMD_SETTABTITLE, sizeof(CESERVER_REQ_HDR)+sizeof(wchar_t)*(Code.cchArgSZ));\n\t\t\t\tif (pIn)\n\t\t\t\t{\n\t\t\t\t\tEscCopyCtrlString((wchar_t*)pIn->wData, Code.ArgSZ+4, Code.cchArgSZ-4);\n\t\t\t\t\tCESERVER_REQ* pOut = ExecuteGuiCmd(gState.realConWnd_, pIn, gState.realConWnd_);\n\t\t\t\t\tExecuteFreeResult(pIn);\n\t\t\t\t\tExecuteFreeResult(pOut);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (Code.ArgSZ[2] == L'4')\n\t\t\t{\n\t\t\t\tAnsiProgressStatus st = AnsiProgressStatus::None;\n\t\t\t\tWORD pr = 0;\n\t\t\t\tconst wchar_t* pszName = nullptr;\n\t\t\t\tif (Code.ArgSZ[3] == L';')\n\t\t\t\t{\n\t\t\t\t\tswitch (Code.ArgSZ[4])\n\t\t\t\t\t{\n\t\t\t\t\tcase L'0':\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase L'1':\n\t\t\t\t\t\tst = AnsiProgressStatus::Running; break;\n\t\t\t\t\tcase L'2':\n\t\t\t\t\t\tst = AnsiProgressStatus::Error; break;\n\t\t\t\t\tcase L'3':\n\t\t\t\t\t\tst = AnsiProgressStatus::Indeterminate; break;\n\t\t\t\t\tcase L'4':\n\t\t\t\t\t\tst = AnsiProgressStatus::Paused; break;\n\t\t\t\t\tcase L'5': // reserved for future use\n\t\t\t\t\t\tst = AnsiProgressStatus::LongRunStart; break;\n\t\t\t\t\tcase L'6': // reserved for future use\n\t\t\t\t\t\tst = AnsiProgressStatus::LongRunStop; break;\n\t\t\t\t\t}\n\t\t\t\t\tif (st == AnsiProgressStatus::Running || st == AnsiProgressStatus::Error || st == AnsiProgressStatus::Paused)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (Code.ArgSZ[5] == L';')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tLPCWSTR pszValue = Code.ArgSZ + 6;\n\t\t\t\t\t\t\tpr = NextNumber(pszValue);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (st == AnsiProgressStatus::LongRunStart || st == AnsiProgressStatus::LongRunStop)\n\t\t\t\t\t{\n\t\t\t\t\t\tpszName = (Code.ArgSZ[5] == L';') ? (Code.ArgSZ + 6) : nullptr;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tDoSetProgress(st, pr, pszName);\n\t\t\t}\n\t\t\telse if (Code.ArgSZ[2] == L'5')\n\t\t\t{\n\t\t\t\t//int s = 0;\n\t\t\t\t//if (Code.ArgSZ[3] == L';')\n\t\t\t\t//\ts = NextNumber(Code.ArgSZ+4);\n\t\t\t\tbool bSucceeded = FALSE;\n\t\t\t\tDWORD nRead = 0;\n\t\t\t\tINPUT_RECORD r = {};\n\t\t\t\tHANDLE hIn = GetStdHandle(STD_INPUT_HANDLE);\n\t\t\t\t//DWORD nStartTick = GetTickCount();\n\t\t\t\twhile ((bSucceeded = ReadConsoleInput(hIn, &r, 1, &nRead)) && nRead)\n\t\t\t\t{\n\t\t\t\t\tif ((r.EventType == KEY_EVENT) && r.Event.KeyEvent.bKeyDown)\n\t\t\t\t\t{\n\t\t\t\t\t\tif ((r.Event.KeyEvent.wVirtualKeyCode == VK_RETURN)\n\t\t\t\t\t\t\t|| (r.Event.KeyEvent.wVirtualKeyCode == VK_SPACE)\n\t\t\t\t\t\t\t|| (r.Event.KeyEvent.wVirtualKeyCode == VK_ESCAPE))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (bSucceeded && ((r.Event.KeyEvent.wVirtualKeyCode == VK_RETURN)\n\t\t\t\t\t\t\t|| (r.Event.KeyEvent.wVirtualKeyCode == VK_SPACE)\n\t\t\t\t\t\t\t|| (r.Event.KeyEvent.wVirtualKeyCode == VK_ESCAPE)))\n\t\t\t\t{\n\t\t\t\t\tSetEnvironmentVariable(ENV_CONEMU_WAITKEY_W,\n\t\t\t\t\t\t(r.Event.KeyEvent.wVirtualKeyCode == VK_RETURN) ? L\"RETURN\" :\n\t\t\t\t\t\t(r.Event.KeyEvent.wVirtualKeyCode == VK_SPACE)  ? L\"SPACE\" :\n\t\t\t\t\t\t(r.Event.KeyEvent.wVirtualKeyCode == VK_ESCAPE) ? L\"ESC\" :\n\t\t\t\t\t\tL\"???\");\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSetEnvironmentVariable(ENV_CONEMU_WAITKEY_W, L\"\");\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (Code.ArgSZ[2] == L'6' && Code.ArgSZ[3] == L';')\n\t\t\t{\n\t\t\t\tDoGuiMacro(Code.ArgSZ+4, Code.cchArgSZ - 4);\n\t\t\t}\n\t\t\telse if (Code.ArgSZ[2] == L'7' && Code.ArgSZ[3] == L';')\n\t\t\t{\n\t\t\t\tDoProcess(Code.ArgSZ+4, Code.cchArgSZ - 4);\n\t\t\t}\n\t\t\telse if (Code.ArgSZ[2] == L'8' && Code.ArgSZ[3] == L';')\n\t\t\t{\n\t\t\t\tm_Owner->ApplyDisplayParm();\n\t\t\t\tDoPrintEnv(Code.ArgSZ+4, Code.cchArgSZ - 4);\n\t\t\t}\n\t\t\telse if (Code.ArgSZ[2] == L'9' && Code.ArgSZ[3] == L';')\n\t\t\t{\n\t\t\t\tDoSendCWD(Code.ArgSZ+4, Code.cchArgSZ - 4);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t}\n}\n\nvoid SrvAnsiImpl::WriteAnsiCode_VIM(AnsiEscCode& Code)\n{\n\t/*\n\tif (!m_Owner->gbIsXTermOutput && !gnWriteProcessed)\n\t{\n\t\tSrvAnsiImpl::StartXTermMode(true);\n\t}\n\t*/\n\n\tswitch (Code.Action)\n\t{\n\tcase L'm':\n\t\t// Set xterm display modes (colors, fonts, etc.)\n\t\tif (!Code.ArgC)\n\t\t{\n\t\t\t//m_Owner->ReSetDisplayParm(TRUE, FALSE);\n\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor (int i = 0; i < Code.ArgC; i++)\n\t\t\t{\n\t\t\t\tswitch (Code.ArgV[i])\n\t\t\t\t{\n\t\t\t\tcase 7:\n\t\t\t\t\tm_Owner->gDisplayParm.setBrightOrBold(FALSE);\n\t\t\t\t\tm_Owner->gDisplayParm.setItalic(FALSE);\n\t\t\t\t\tm_Owner->gDisplayParm.setUnderline(FALSE);\n\t\t\t\t\tm_Owner->gDisplayParm.setBrightFore(FALSE);\n\t\t\t\t\tm_Owner->gDisplayParm.setBrightBack(FALSE);\n\t\t\t\t\tm_Owner->gDisplayParm.setInverse(FALSE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 15:\n\t\t\t\t\tm_Owner->gDisplayParm.setBrightOrBold(TRUE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 112:\n\t\t\t\t\tm_Owner->gDisplayParm.setInverse(TRUE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 143:\n\t\t\t\t\t// What is this?\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak; // \"|...m\"\n\t}\n}\n\n// Values are 1-based\nvoid SrvAnsiImpl::SetScrollRegion(bool bRegion, int nStart, int nEnd)\n{\n\tif (bRegion)\n\t{\n\t\t// note: the '\\e[0;35r' shall be treated as '\\e[1;35r'\n\t\t_ASSERTE(nStart >= 0 && nEnd >= nStart);\n\t\tm_Table->SetScrollRegion(true, std::max(0, nStart - 1), std::max(0, nEnd - 1));\n\t}\n\telse\n\t{\n\t\tm_Table->SetScrollRegion(false);\n\t}\n}\n\nvoid SrvAnsiImpl::XTermSaveRestoreCursor(bool bSaveCursor)\n{\n\tif (bSaveCursor)\n\t{\n\t\tm_Owner->gDisplayCursor.bCursorPosStored = true;\n\t\tm_Owner->gDisplayCursor.StoredCursorPos = m_Table->GetCursor();\n\t}\n\telse\n\t{\n\t\t// Restore cursor position\n\t\tm_Table->SetCursor(m_Owner->gDisplayCursor.bCursorPosStored ? m_Owner->gDisplayCursor.StoredCursorPos : condata::Coord{});\n\t}\n}\n\n/// Change current buffer\n/// Alternative buffer in XTerm is used to \"fullscreen\"\n/// applications like Vim. There is no scrolling and this\n/// mode is used to save current backscroll contents and\n/// restore it when application exits\nvoid SrvAnsiImpl::XTermAltBuffer(bool bSetAltBuffer/*, condata::TablePtr& table*/)\n{\n\tif (bSetAltBuffer)\n\t{\n\t\t// Once!\n\t\tif (!m_Owner->m_UsePrimary)\n\t\t\treturn;\n\n\t\tconst auto attr = m_Table->GetAttr();\n\t\tm_Table = m_Owner->GetTable(SrvAnsi::GetTableEnum::alternative);\n\t\tm_Table->Reset(attr);\n\n\t\t// #condata Save gDisplayCursor.StoredCursorPos separately by primary/alternative\n\n\t}\n\telse\n\t{\n\t\tif (m_Owner->m_UsePrimary)\n\t\t\treturn;\n\n\t\tm_Table->Reset({});\n\n\t\tm_Table = m_Owner->GetTable(SrvAnsi::GetTableEnum::primary);\n\n\t\t// #condata Save gDisplayCursor.StoredCursorPos separately by primary/alternative\n\n\t}\n}\n", "\ufeff\n/*\nCopyright (c) 2012-present Maximus5\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions\nare met:\n1. Redistributions of source code must retain the above copyright\n   notice, this list of conditions and the following disclaimer.\n2. Redistributions in binary form must reproduce the above copyright\n   notice, this list of conditions and the following disclaimer in the\n   documentation and/or other materials provided with the distribution.\n3. The name of the authors may not be used to endorse or promote products\n   derived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE AUTHOR ''AS IS'' AND ANY EXPRESS OR\nIMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\nOF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\nIN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,\nINCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\nNOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\nTHIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n// #ANSI This file is expected to be moved almost completely to ConEmuCD\n\n#include \"../common/defines.h\"\n#include <winerror.h>\n#include <winnt.h>\n#include <tchar.h>\n#include <limits>\n#include <chrono>\n#include <tuple>\n#include <atomic>\n#include \"../common/Common.h\"\n#include \"../common/ConEmuCheck.h\"\n#include \"../common/ConsoleMixAttr.h\"\n#include \"../common/CmdLine.h\"\n#include \"../common/HandleKeeper.h\"\n#include \"../common/MConHandle.h\"\n#include \"../common/MRect.h\"\n#include \"../common/MSectionSimple.h\"\n#include \"../common/UnicodeChars.h\"\n#include \"../common/WConsole.h\"\n#include \"../common/WErrGuard.h\"\n#include \"../common/MAtomic.h\"\n\n#include \"Connector.h\"\n#include \"ExtConsole.h\"\n#include \"hlpConsole.h\"\n#include \"hlpProcess.h\"\n#include \"SetHook.h\"\n\n#include \"hkConsole.h\"\n#include \"hkStdIO.h\"\n#include \"hkWindow.h\"\n\n///* ***************** */\n#include \"Ansi.h\"\n\n#include \"../common/MHandle.h\"\nstatic DWORD gAnsiTlsIndex = 0;\n\n#include \"DllOptions.h\"\n#include \"../common/WObjects.h\"\n///* ***************** */\n\n#ifdef _DEBUG\n#define GH_1402\n#endif\n\n#undef isPressed\n#define isPressed(inp) ((GetKeyState(inp) & 0x8000) == 0x8000)\n\n#define ANSI_MAP_CHECK_TIMEOUT 1000 // 1sec\n\n#ifdef _DEBUG\n#define DebugString(x) OutputDebugString(x)\n#define DebugStringA(x) OutputDebugStringA(x)\n#define DBG_XTERM(x) //CEAnsi::DebugXtermOutput(x)\n#else\n#define DebugString(x) //OutputDebugString(x)\n#define DebugStringA(x) //OutputDebugStringA(x)\n#define DBG_XTERM(x) //CEAnsi::DebugXtermOutput(x)\n#endif\n\n/* ************ Globals ************ */\n// extern HMODULE ghOurModule; // \u0425\u044d\u043d\u0434\u043b \u043d\u0430\u0448\u0435\u0439 dll'\u043a\u0438 (\u0437\u0434\u0435\u0441\u044c \u0445\u0443\u043a\u0438 \u043d\u0435 \u0441\u0442\u0430\u0432\u044f\u0442\u0441\u044f)\n#include \"MainThread.h\"\n\n/* ************ Globals for SetHook ************ */\nextern HWND    ghConWnd;      // RealConsole  // NOLINT(readability-redundant-declaration)\nextern HWND    ghConEmuWnd;   // Root! ConEmu window  // NOLINT(readability-redundant-declaration)\n// ReSharper disable once CppInconsistentNaming\nextern HWND    ghConEmuWndDC; // ConEmu DC window  // NOLINT(readability-redundant-declaration)\n// ReSharper disable once CppInconsistentNaming\nextern DWORD   gnGuiPID;  // NOLINT(readability-redundant-declaration)\n// extern wchar_t gsInitConTitle[512];\n/* ************ Globals for SetHook ************ */\n\n/* ************ Globals for xTerm/ViM ************ */\nTODO(\"BufferWidth\")\ntypedef DWORD XTermAltBufferFlags;\nconst XTermAltBufferFlags\n\txtb_AltBuffer          = 0x0001,\n\txtb_StoredCursor       = 0x0002,\n\txtb_StoredScrollRegion = 0x0004,\n\txtb_None               = 0;\nstatic struct XTermAltBufferData\n{\n\tXTermAltBufferFlags Flags;\n\tint    BufferSize;\n\tCOORD  CursorPos;\n\tSHORT  ScrollStart, ScrollEnd;\n} gXTermAltBuffer = {};\n/* ************ Globals for xTerm/ViM ************ */\n\nBOOL WINAPI OnCreateProcessW(LPCWSTR lpApplicationName, LPWSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCWSTR lpCurrentDirectory, LPSTARTUPINFOW lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation);\n\n// These handles must be registered and released in OnCloseHandle.\nHANDLE CEAnsi::ghAnsiLogFile = nullptr;\nbool CEAnsi::gbAnsiLogCodes = false;\nLONG CEAnsi::gnEnterPressed = 0;\nbool CEAnsi::gbAnsiLogNewLine = false;\nbool CEAnsi::gbAnsiWasNewLine = false;\nMSectionSimple* CEAnsi::gcsAnsiLogFile = nullptr;\n\n// VIM, etc. Some programs waiting control keys as xterm sequences. Need to inform ConEmu GUI.\nbool CEAnsi::gbIsXTermOutput = false;\n// On Windows 10 we have ENABLE_VIRTUAL_TERMINAL_PROCESSING which implies XTerm mode\nDWORD CEAnsi::gPrevConOutMode = 0;\n// Let RefreshXTermModes() know what to restore\nCEAnsi::TermModeSet CEAnsi::gWasXTermModeSet[tmc_Last] = {};\n\nstatic MConHandle ghConOut(L\"CONOUT$\"), ghStdOut(L\"\"), ghStdErr(L\"\");  // NOLINT(clang-diagnostic-exit-time-destructors)\n\n/* ************ Export ANSI printings ************ */\nLONG gnWriteProcessed = 0;\nFARPROC CallWriteConsoleW = nullptr;\nBOOL WINAPI WriteProcessed3(LPCWSTR lpBuffer, DWORD nNumberOfCharsToWrite, LPDWORD lpNumberOfCharsWritten, HANDLE hConsoleOutput)\n{\n\tInterlockedIncrement(&gnWriteProcessed);\n\tDWORD nNumberOfCharsWritten = 0;\n\tif ((nNumberOfCharsToWrite == static_cast<DWORD>(-1)) && lpBuffer)\n\t{\n\t\tnNumberOfCharsToWrite = lstrlen(lpBuffer);\n\t}\n\tconst BOOL bRc = CEAnsi::OurWriteConsoleW(hConsoleOutput, lpBuffer, nNumberOfCharsToWrite, &nNumberOfCharsWritten, nullptr);\n\tif (lpNumberOfCharsWritten) *lpNumberOfCharsWritten = nNumberOfCharsWritten;\n\tInterlockedDecrement(&gnWriteProcessed);\n\treturn bRc;\n}\n\nHANDLE GetStreamHandle(WriteProcessedStream Stream)\n{\n\tHANDLE hConsoleOutput;\n\tswitch (Stream)  // NOLINT(clang-diagnostic-switch-enum)\n\t{\n\tcase wps_Output:\n\t\thConsoleOutput = GetStdHandle(STD_OUTPUT_HANDLE); break;\n\tcase wps_Error:\n\t\thConsoleOutput = GetStdHandle(STD_ERROR_HANDLE); break;\n\tdefault:\n\t\tSetLastError(ERROR_INVALID_PARAMETER);\n\t\treturn nullptr;\n\t}\n\treturn hConsoleOutput;\n}\nBOOL WINAPI WriteProcessed2(LPCWSTR lpBuffer, DWORD nNumberOfCharsToWrite, LPDWORD lpNumberOfCharsWritten, WriteProcessedStream Stream)\n{\n\t// ReSharper disable once CppLocalVariableMayBeConst\n\tHANDLE hConsoleOutput = GetStreamHandle(Stream);\n\tif (!hConsoleOutput || (hConsoleOutput == INVALID_HANDLE_VALUE))\n\t\treturn FALSE;\n\treturn WriteProcessed3(lpBuffer, nNumberOfCharsToWrite, lpNumberOfCharsWritten, hConsoleOutput);\n}\nBOOL WINAPI WriteProcessed(LPCWSTR lpBuffer, DWORD nNumberOfCharsToWrite, LPDWORD lpNumberOfCharsWritten)\n{\n\treturn WriteProcessed2(lpBuffer, nNumberOfCharsToWrite, lpNumberOfCharsWritten, wps_Output);\n}\nBOOL WINAPI WriteProcessedA(LPCSTR lpBuffer, DWORD nNumberOfCharsToWrite, LPDWORD lpNumberOfCharsWritten, WriteProcessedStream Stream)\n{\n\tBOOL lbRc = FALSE;\n\tCEAnsi* pObj = nullptr;\n\n\tORIGINAL_KRNL(WriteConsoleA);\n\n\tif ((nNumberOfCharsToWrite == static_cast<DWORD>(-1)) && lpBuffer)\n\t{\n\t\tnNumberOfCharsToWrite = lstrlenA(lpBuffer);\n\t}\n\n\t// Nothing to write? Or flush buffer?\n\tif (!lpBuffer || !nNumberOfCharsToWrite || Stream == wps_None)\n\t{\n\t\tif (lpNumberOfCharsWritten)\n\t\t\t*lpNumberOfCharsWritten = 0;\n\t\tlbRc = TRUE;\n\t\tgoto fin;\n\t}\n\n\tpObj = CEAnsi::Object();\n\n\tif (pObj)\n\t\tlbRc = pObj->OurWriteConsoleA(GetStreamHandle(Stream), lpBuffer, nNumberOfCharsToWrite, lpNumberOfCharsWritten);\n\telse\n\t\tlbRc = F(WriteConsoleA)(GetStreamHandle(Stream), lpBuffer, nNumberOfCharsToWrite, lpNumberOfCharsWritten, nullptr);\n\nfin:\n\treturn lbRc;\n}\n/* ************ Export ANSI printings ************ */\n\nvoid DebugStringUtf8(LPCWSTR asMessage)\n{\n\t#ifdef _DEBUG\n\tif (!asMessage || !*asMessage)\n\t\treturn;\n\t// Only ConEmuC debugger is able to show Utf-8 encoded debug strings\n\t// So, set bUseUtf8 to false if VS debugger is required\n\tstatic bool bUseUtf8 = false;\n\tif (!bUseUtf8)\n\t{\n\t\tDebugString(asMessage);\n\t\treturn;\n\t}\n\tconst int iLen = lstrlen(asMessage);\n\tchar szUtf8[200];\n\tCEStrA buffer;\n\tchar* pszUtf8 = ((iLen * 3 + 5) < static_cast<int>(countof(szUtf8))) ? szUtf8 : buffer.GetBuffer(iLen * 3 + 5);\n\tif (!pszUtf8)\n\t\treturn;\n\tpszUtf8[0] = '\\xEF'; pszUtf8[1] = '\\xBB'; pszUtf8[2] = '\\xBF';\n\tconst int iCvt = WideCharToMultiByte(CP_UTF8, 0, asMessage, iLen, pszUtf8+3, iLen*3+1, nullptr, nullptr);\n\tif (iCvt > 0)\n\t{\n\t\t_ASSERTE(iCvt < (iLen*3+2));\n\t\tpszUtf8[iCvt+3] = 0;\n\t\tDebugStringA(pszUtf8);\n\t}\n\t#endif\n}\n\nvoid CEAnsi::InitAnsiLog(LPCWSTR asFilePath, const bool LogAnsiCodes)\n{\n\tgbAnsiLogCodes = LogAnsiCodes;\n\n\t// Already initialized?\n\tif (ghAnsiLogFile)\n\t\treturn;\n\n\tScopedObject(CLastErrorGuard);\n\n\tgcsAnsiLogFile = new MSectionSimple(true);\n\t// ReSharper disable once CppLocalVariableMayBeConst\n\tHANDLE hLog = CreateFile(asFilePath, GENERIC_WRITE, FILE_SHARE_READ|FILE_SHARE_WRITE, nullptr, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, nullptr);\n\tif (hLog && (hLog != INVALID_HANDLE_VALUE))\n\t{\n\t\t// Succeeded\n\t\tghAnsiLogFile = hLog;\n\t}\n\telse\n\t{\n\t\tSafeDelete(gcsAnsiLogFile);\n\t}\n}\n\nvoid CEAnsi::DoneAnsiLog(bool bFinal)\n{\n\tif (!ghAnsiLogFile)\n\t\treturn;\n\n\tif (gbAnsiLogNewLine || (gnEnterPressed > 0))\n\t{\n\t\tCEAnsi::WriteAnsiLogUtf8(\"\\n\", 1);\n\t}\n\n\tif (!bFinal)\n\t{\n\t\tFlushFileBuffers(ghAnsiLogFile);\n\t}\n\telse\n\t{\n\t\t// ReSharper disable once CppLocalVariableMayBeConst\n\t\tHANDLE h = ghAnsiLogFile;\n\t\tghAnsiLogFile = nullptr;\n\t\tCloseHandle(h);\n\t\tSafeDelete(gcsAnsiLogFile);\n\t}\n}\n\nUINT CEAnsi::GetCodePage()\n{\n\tconst UINT cp = gCpConv.nDefaultCP ? gCpConv.nDefaultCP : GetConsoleOutputCP();\n\treturn cp;\n}\n\n// Intended to log some WinAPI functions\nvoid CEAnsi::WriteAnsiLogFormat(const char* format, ...)\n{\n\tif (!ghAnsiLogFile || !gbAnsiLogCodes || !format)\n\t\treturn;\n\tScopedObject(CLastErrorGuard);\n\n\tWriteAnsiLogTime();\n\n\tva_list argList;\n\tva_start(argList, format);\n\tchar func_buffer[200] = \"\";\n\tif (S_OK == StringCchVPrintfA(func_buffer, countof(func_buffer), format, argList))\n\t{\n\t\tstatic char s_ExeName[80] = \"\";\n\t\tif (!*s_ExeName)\n\t\t\tWideCharToMultiByte(CP_UTF8, 0, gsExeName, -1, s_ExeName, countof(s_ExeName)-1, nullptr, nullptr);\n\n\t\tchar log_string[300] = \"\";\n\t\tmsprintf(log_string, countof(log_string), \"\\x1B]9;11;\\\"%s: %s\\\"\\x7\", s_ExeName, func_buffer);\n\t\tWriteAnsiLogUtf8(log_string, static_cast<DWORD>(strlen(log_string)));\n\t}\n\tva_end(argList);\n}\n\nvoid CEAnsi::WriteAnsiLogTime()\n{\n\tif (!ghAnsiLogFile || !gbAnsiLogCodes)\n\t\treturn;\n\tstatic DWORD last_write_tick_ = 0;\n\n\tconst DWORD min_diff = 500;\n\tconst DWORD cur_tick = GetTickCount();\n\tconst DWORD cur_diff = cur_tick - last_write_tick_;\n\n\tif (!last_write_tick_ || (cur_diff >= min_diff))\n\t{\n\t\tlast_write_tick_ = cur_tick;\n\t\tSYSTEMTIME st = {};\n\t\tGetLocalTime(&st);\n\t\tchar time_str[40];\n\t\t// We should NOT use WriteAnsiLogFormat here!\n\t\tmsprintf(time_str, std::size(time_str), \"\\x1B]9;11;\\\"%02u:%02u:%02u.%03u\\\"\\x7\",\n\t\t\tst.wHour, st.wMinute, st.wSecond, st.wMilliseconds);\n\t\tWriteAnsiLogUtf8(time_str, static_cast<DWORD>(strlen(time_str)));\n\t}\n}\n\nBOOL CEAnsi::WriteAnsiLogUtf8(const char* lpBuffer, DWORD nChars)\n{\n\tif (!ghAnsiLogFile || !lpBuffer || !nChars)\n\t\treturn FALSE;\n\t// Handle multi-thread writers\n\t// But multi-process writers can't be handled correctly\n\tMSectionLockSimple lock; lock.Lock(gcsAnsiLogFile, 500);\n\tSetFilePointer(ghAnsiLogFile, 0, nullptr, FILE_END);\n\tORIGINAL_KRNL(WriteFile);\n\tDWORD nWritten = 0;\n\tconst BOOL bWrite = F(WriteFile)(ghAnsiLogFile, lpBuffer, nChars, &nWritten, nullptr);\n\tUNREFERENCED_PARAMETER(nWritten);\n\tgnEnterPressed = 0; gbAnsiLogNewLine = false;\n\tgbAnsiWasNewLine = (lpBuffer[nChars-1] == '\\n');\n\treturn bWrite;\n}\n\n// This may be called to log ReadConsoleA result\nvoid CEAnsi::WriteAnsiLogA(LPCSTR lpBuffer, DWORD nChars)\n{\n\tif (!ghAnsiLogFile || !lpBuffer || !nChars)\n\t\treturn;\n\n\tScopedObject(CLastErrorGuard);\n\n\tconst UINT cp = GetCodePage();\n\tif (cp == CP_UTF8)\n\t{\n\t\tbool writeLineFeed = false;\n\t\tif (gbAnsiLogNewLine)\n\t\t{\n\t\t\tif ((lpBuffer[0] == '\\n') || ((nChars > 1) && (lpBuffer[0] == '\\r') && (lpBuffer[1] == '\\n')))\n\t\t\t{\n\t\t\t\tgbAnsiLogNewLine = false;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\twriteLineFeed = true;\n\t\t\t}\n\t\t}\n\n\t\tWriteAnsiLogTime();\n\t\tif (writeLineFeed)\n\t\t\tWriteAnsiLogUtf8(\"\\n\", 1);\n\t\tWriteAnsiLogUtf8(lpBuffer, nChars);\n\t}\n\telse\n\t{\n\t\t// We don't check here for gbAnsiLogNewLine, because some codepages may even has different codes for CR+LF\n\t\twchar_t sBuf[80 * 3];\n\t\tCEStr buffer;\n\t\tconst int nNeed = MultiByteToWideChar(cp, 0, lpBuffer, nChars, nullptr, 0);\n\t\tif (nNeed < 1)\n\t\t\treturn;\n\t\twchar_t* pszBuf = (nNeed <= static_cast<int>(countof(sBuf))) ? sBuf : buffer.GetBuffer(nNeed);\n\t\tif (!pszBuf)\n\t\t\treturn;\n\t\tconst int nLen = MultiByteToWideChar(cp, 0, lpBuffer, nChars, pszBuf, nNeed);\n\t\t// Must be OK, but check it\n\t\tif (nLen > 0 && nLen <= nNeed)\n\t\t{\n\t\t\tWriteAnsiLogW(pszBuf, nLen);\n\t\t}\n\t}\n}\n\nvoid CEAnsi::WriteAnsiLogW(LPCWSTR lpBuffer, DWORD nChars)\n{\n\tif (!ghAnsiLogFile || !lpBuffer || !nChars)\n\t\treturn;\n\n\tScopedObject(CLastErrorGuard);\n\n\tWriteAnsiLogTime();\n\n\t// Cygwin (in RealConsole mode, not connector) don't write CR+LF to screen,\n\t// it uses SetConsoleCursorPosition instead after receiving '\\n' from readline\n\tint iEnterShift = 0;\n\tif (gbAnsiLogNewLine)\n\t{\n\t\tif ((lpBuffer[0] == '\\n') || ((nChars > 1) && (lpBuffer[0] == '\\r') && (lpBuffer[1] == '\\n')))\n\t\t\tgbAnsiLogNewLine = false;\n\t\telse\n\t\t\tiEnterShift = 1;\n\t}\n\n\tchar sBuf[80 * 3]; // Will be enough for most cases\n\tCEStrA buffer;\n\tBOOL bWrite = FALSE;\n\tconst int nNeed = WideCharToMultiByte(CP_UTF8, 0, lpBuffer, nChars, nullptr, 0, nullptr, nullptr);\n\tif (nNeed < 1)\n\t\treturn;\n\tchar* pszBuf = ((nNeed + iEnterShift + 1) <= static_cast<int>(countof(sBuf))) ? sBuf : buffer.GetBuffer(nNeed + iEnterShift + 1);\n\tif (!pszBuf)\n\t\treturn;\n\tif (iEnterShift)\n\t\tpszBuf[0] = '\\n';\n\tconst int nLen = WideCharToMultiByte(CP_UTF8, 0, lpBuffer, nChars, pszBuf+iEnterShift, nNeed, nullptr, nullptr);\n\t// Must be OK, but check it\n\tif (nLen > 0 && nLen <= nNeed)\n\t{\n\t\tpszBuf[iEnterShift+nNeed] = 0;\n\t\tbWrite = WriteAnsiLogUtf8(pszBuf, nLen+iEnterShift);\n\t}\n\tstd::ignore = bWrite;\n}\n\nvoid CEAnsi::WriteAnsiLogFarPrompt()\n{\n\t_ASSERTE(ghAnsiLogFile!=nullptr && \"Caller must check this\");\n\t// ReSharper disable once CppLocalVariableMayBeConst\n\tHANDLE hCon = GetStdHandle(STD_OUTPUT_HANDLE);\n\tCONSOLE_SCREEN_BUFFER_INFO csbi = {};\n\tif (!GetConsoleScreenBufferInfo(hCon, &csbi))\n\t\treturn;\n\tCEStr buffer;\n\tDWORD nChars = csbi.dwSize.X;\n\tif (!buffer.GetBuffer(csbi.dwSize.X + 2))\n\t\treturn;\n\t// We expect Far has already put \"black user screen\" and do CR/LF\n\t// if Far's keybar is hidden, we are on (csbi.dwSize.Y-1), otherwise - (csbi.dwSize.Y-2)\n\t_ASSERTE(csbi.dwCursorPosition.Y >= (csbi.dwSize.Y-2) && csbi.dwCursorPosition.Y <= (csbi.dwSize.Y-1));\n\tconst COORD crFrom = {0, static_cast<SHORT>(csbi.dwCursorPosition.Y - 1)};\n\tif (ReadConsoleOutputCharacterW(hCon, buffer.data(), nChars, crFrom, &nChars)\n\t\t&& nChars)\n\t{\n\t\twchar_t* pszBuf = buffer.data();\n\t\t// Do RTrim first\n\t\twhile (nChars && (pszBuf[nChars - 1] == L' '))\n\t\t\tnChars--;\n\t\t// Add CR+LF\n\t\tpszBuf[nChars++] = L'\\r'; pszBuf[nChars++] = L'\\n';\n\t\t// And do the logging\n\t\tWriteAnsiLogW(pszBuf, nChars);\n\t}\n}\n\nvoid CEAnsi::AnsiLogEnterPressed()\n{\n\tif (!ghAnsiLogFile)\n\t\treturn;\n\tInterlockedIncrement(&gnEnterPressed);\n\tgbAnsiLogNewLine = true;\n}\n\nbool CEAnsi::GetFeatures(ConEmu::ConsoleFlags& features)\n{\n\tstruct FeaturesCache\n\t{\n\t\tConEmu::ConsoleFlags features;\n\t\tBOOL result;\n\t};\n\tstatic FeaturesCache featuresCache{};\n\t// Don't use system_clock here, it fails in some cases during DllLoad (segment is not ready somehow)\n\tstatic DWORD nLastCheck{ 0 };\n\n\tif (!nLastCheck || (GetTickCount() - nLastCheck) > ANSI_MAP_CHECK_TIMEOUT)\n\t{\n\t\tCESERVER_CONSOLE_MAPPING_HDR* pMap = GetConMap();\n\t\t//\t(CESERVER_CONSOLE_MAPPING_HDR*)malloc(sizeof(CESERVER_CONSOLE_MAPPING_HDR));\n\t\tif (pMap)\n\t\t{\n\t\t\t// bAnsiAllowed = ((pMap != nullptr) && (pMap->Flags & ConEmu::ConsoleFlags::ProcessAnsi));\n\t\t\t// bSuppressBells = ((pMap != nullptr) && (pMap->Flags & ConEmu::ConsoleFlags::SuppressBells));\n\t\t\t// Well, it's not so atomic as could be, but here we care only on proper features value\n\t\t\t// and we can't use std::atomic here because function is called during DllLoad\n\t\t\tInterlockedExchange(reinterpret_cast<LONG*>(&featuresCache.features), static_cast<LONG>(pMap->Flags));\n\t\t\tInterlockedExchange(reinterpret_cast<LONG*>(&featuresCache.result), static_cast<LONG>(true));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tInterlockedExchange(reinterpret_cast<LONG*>(&featuresCache.features), 0);\n\t\t\tInterlockedExchange(reinterpret_cast<LONG*>(&featuresCache.result), 0);\n\t\t}\n\t\tnLastCheck = GetTickCount();\n\t}\n\n\tfeatures = static_cast<ConEmu::ConsoleFlags>(InterlockedCompareExchange(reinterpret_cast<LONG*>(&featuresCache.features), 0, 0));\n\tconst bool result = InterlockedCompareExchange(reinterpret_cast<LONG*>(&featuresCache.result), 0, 0);\n\treturn result;\n}\n\nvoid CEAnsi::ReloadFeatures()\n{\n\tConEmu::ConsoleFlags features = ConEmu::ConsoleFlags::Empty;\n\tGetFeatures(features);\n\tmb_SuppressBells = (features & ConEmu::ConsoleFlags::SuppressBells);\n}\n\n\n\n\n//struct DisplayParm\n//{\n//\tBOOL WasSet;\n//\tBOOL BrightOrBold;     // 1\n//\tBOOL Italic;           // 3\n//\tBOOL Underline;        // 4\n//\tBOOL BrightFore;       // 90-97\n//\tBOOL BrightBack;       // 100-107\n//\tint  TextColor;        // 30-37,38,39\n//\tBOOL Text256;          // 38\n//    int  BackColor;        // 40-47,48,49\n//    BOOL Back256;          // 48\n//\t// xterm\n//\tBOOL Inverse;\n//} gDisplayParm = {};\n\nCEAnsi::DisplayParm CEAnsi::gDisplayParm = {};\n\n// void CEAnsi::DisplayParm::setWasSet(...) -- intentionally is not defined\n\nvoid CEAnsi::DisplayParm::Reset(const bool full)\n{\n\tif (full)\n\t\t*this = DisplayParm{};\n\n\tconst WORD nDefColors = CEAnsi::GetDefaultTextAttr();\n\t_TextColor = CONFORECOLOR(nDefColors);\n\t_BackColor = CONBACKCOLOR(nDefColors);\n\t_WasSet = TRUE;\n}\nvoid CEAnsi::DisplayParm::setBrightOrBold(const bool val)\n{\n\tif (!_WasSet)\n\t\tReset(false);\n\t_BrightOrBold = val;\n\t_ASSERTE(_WasSet==TRUE);\n}\nvoid CEAnsi::DisplayParm::setItalic(const bool val)\n{\n\tif (!_WasSet)\n\t\tReset(false);\n\t_Italic = val;\n\t_ASSERTE(_WasSet==TRUE);\n}\nvoid CEAnsi::DisplayParm::setUnderline(const bool val)\n{\n\tif (!_WasSet)\n\t\tReset(false);\n\t_Underline = val;\n\t_ASSERTE(_WasSet==TRUE);\n}\nvoid CEAnsi::DisplayParm::setBrightFore(const bool val)\n{\n\tif (!_WasSet)\n\t\tReset(false);\n\t_BrightFore = val;\n\t_ASSERTE(_WasSet==TRUE);\n}\nvoid CEAnsi::DisplayParm::setBrightBack(const bool val)\n{\n\tif (!_WasSet)\n\t\tReset(false);\n\t_BrightBack = val;\n\t_ASSERTE(_WasSet==TRUE);\n}\nvoid CEAnsi::DisplayParm::setTextColor(const int val)\n{\n\tif (!_WasSet)\n\t\tReset(false);\n\t_TextColor = val;\n\t_ASSERTE(_WasSet==TRUE);\n}\nvoid CEAnsi::DisplayParm::setText256(const cbit val)\n{\n\tif (!_WasSet)\n\t\tReset(false);\n\t_Text256 = val;\n\t_ASSERTE(_WasSet==TRUE);\n}\nvoid CEAnsi::DisplayParm::setBackColor(const int val)\n{\n\tif (!_WasSet)\n\t\tReset(false);\n\t_BackColor = val;\n\t_ASSERTE(_WasSet==TRUE);\n}\nvoid CEAnsi::DisplayParm::setBack256(const cbit val)\n{\n\tif (!_WasSet)\n\t\tReset(false);\n\t_Back256 = val;\n\t_ASSERTE(_WasSet==TRUE);\n}\nvoid CEAnsi::DisplayParm::setInverse(const bool val)\n{\n\tif (!_WasSet)\n\t\tReset(false);\n\t_Inverse = val;\n\t_ASSERTE(_WasSet==TRUE);\n}\nvoid CEAnsi::DisplayParm::setCrossed(const bool val)\n{\n\tif (!_WasSet)\n\t\tReset(false);\n\t_Crossed = val;\n\t_ASSERTE(_WasSet==TRUE);\n}\n\n//struct DisplayCursorPos\n//{\n//    // Internal\n//    COORD StoredCursorPos;\n//\t// Esc[?1h \tSet cursor key to application \tDECCKM\n//\t// Esc[?1l \tSet cursor key to cursor \tDECCKM\n//\tBOOL CursorKeysApp; // \"1h\"\n//} gDisplayCursor = {};\n\nCEAnsi::DisplayCursorPos CEAnsi::gDisplayCursor = {};\n\n//struct DisplayOpt\n//{\n//\tBOOL  WrapWasSet;\n//\tSHORT WrapAt; // Rightmost X coord (1-based)\n//\t//\n//\tBOOL  AutoLfNl; // LF/NL (default off): Automatically follow echo of LF, VT or FF with CR.\n//\t//\n//\tBOOL  ScrollRegion;\n//\tSHORT ScrollStart, ScrollEnd; // 0-based absolute line indexes\n//\t//\n//\tBOOL  ShowRawAnsi; // \\e[3h display ANSI control characters (TRUE), \\e[3l process ANSI (FALSE, normal mode)\n//} gDisplayOpt;\n\nCEAnsi::DisplayOpt CEAnsi::gDisplayOpt = {};\n\n//const size_t cchMaxPrevPart = 160;\n//static wchar_t gsPrevAnsiPart[cchMaxPrevPart] = {};\n//static INT_PTR gnPrevAnsiPart = 0;\n//static wchar_t gsPrevAnsiPart2[cchMaxPrevPart] = {};\n//static INT_PTR gnPrevAnsiPart2 = 0;\n//const  INT_PTR MaxPrevAnsiPart = 80;\n\n#ifdef _DEBUG\nstatic const wchar_t szAnalogues[32] =\n{\n\t32, 9786, 9787, 9829, 9830, 9827, 9824, 8226, 9688, 9675, 9689, 9794, 9792, 9834, 9835, 9788,\n\t9658, 9668, 8597, 8252,  182,  167, 9632, 8616, 8593, 8595, 8594, 8592, 8735, 8596, 9650, 9660\n};\n#endif\n\n/*static*/ SHORT CEAnsi::GetDefaultTextAttr()\n{\n\t// Default console colors\n\tstatic SHORT clrDefault = 0;\n\tif (clrDefault)\n\t\treturn clrDefault;\n\n\t// ReSharper disable once CppLocalVariableMayBeConst\n\tHANDLE hIn = GetStdHandle(STD_OUTPUT_HANDLE);\n\tCONSOLE_SCREEN_BUFFER_INFO csbi = {};\n\tif (!GetConsoleScreenBufferInfo(hIn, &csbi))\n\t\treturn (clrDefault = 7);\n\n\tstatic SHORT Con2Ansi[16] = {0,4,2,6,1,5,3,7,8|0,8|4,8|2,8|6,8|1,8|5,8|3,8|7};\n\tclrDefault = Con2Ansi[CONFORECOLOR(csbi.wAttributes)]\n\t\t| static_cast<SHORT>(Con2Ansi[CONBACKCOLOR(csbi.wAttributes)] << 4);\n\n\treturn clrDefault;\n}\n\n\nconst CEAnsi::DisplayParm& CEAnsi::getDisplayParm()\n{\n\treturn gDisplayParm;\n}\n\n// static\nvoid CEAnsi::ReSetDisplayParm(HANDLE hConsoleOutput, BOOL bReset, BOOL bApply)\n{\n\tWARNING(\"\u042d\u0442\u0443 \u0444\u0443\u043d\u043a\u0443 \u043d\u0443\u0436\u043d\u043e \u0434\u0435\u0440\u0433\u0430\u0442\u044c \u043f\u0440\u0438 \u0441\u043c\u0435\u043d\u0435 \u0431\u0443\u0444\u0435\u0440\u043e\u0432, \u0437\u0430\u043a\u0440\u044b\u0442\u0438\u0438 \u0434\u0435\u0441\u043a\u0440\u0438\u043f\u0442\u043e\u0440\u043e\u0432, \u0438 \u0442.\u043f.\");\n\n\tif (bReset || !gDisplayParm.getWasSet())\n\t{\n\t\tgDisplayParm.Reset(bReset);\n\t}\n\n\tif (bApply)\n\t{\n\t\t// to display\n\t\tExtAttributesParm attr{};\n\t\tattr.StructSize = sizeof(attr);\n\t\tattr.ConsoleOutput = hConsoleOutput;\n\t\t//DWORD wAttrs = 0;\n\n\t\t// Ansi colors\n\t\tstatic DWORD ClrMap[8] = {0,4,2,6,1,5,3,7};\n\t\t// XTerm-256 colors\n\t\tstatic DWORD RgbMap[256] = {0,4,2,6,1,5,3,7, 8+0,8+4,8+2,8+6,8+1,8+5,8+3,8+7, // System Ansi colors\n\t\t\t/*16*/0x000000, /*17*/0x5f0000, /*18*/0x870000, /*19*/0xaf0000, /*20*/0xd70000, /*21*/0xff0000, /*22*/0x005f00, /*23*/0x5f5f00, /*24*/0x875f00, /*25*/0xaf5f00, /*26*/0xd75f00, /*27*/0xff5f00,\n\t\t\t/*28*/0x008700, /*29*/0x5f8700, /*30*/0x878700, /*31*/0xaf8700, /*32*/0xd78700, /*33*/0xff8700, /*34*/0x00af00, /*35*/0x5faf00, /*36*/0x87af00, /*37*/0xafaf00, /*38*/0xd7af00, /*39*/0xffaf00,\n\t\t\t/*40*/0x00d700, /*41*/0x5fd700, /*42*/0x87d700, /*43*/0xafd700, /*44*/0xd7d700, /*45*/0xffd700, /*46*/0x00ff00, /*47*/0x5fff00, /*48*/0x87ff00, /*49*/0xafff00, /*50*/0xd7ff00, /*51*/0xffff00,\n\t\t\t/*52*/0x00005f, /*53*/0x5f005f, /*54*/0x87005f, /*55*/0xaf005f, /*56*/0xd7005f, /*57*/0xff005f, /*58*/0x005f5f, /*59*/0x5f5f5f, /*60*/0x875f5f, /*61*/0xaf5f5f, /*62*/0xd75f5f, /*63*/0xff5f5f,\n\t\t\t/*64*/0x00875f, /*65*/0x5f875f, /*66*/0x87875f, /*67*/0xaf875f, /*68*/0xd7875f, /*69*/0xff875f, /*70*/0x00af5f, /*71*/0x5faf5f, /*72*/0x87af5f, /*73*/0xafaf5f, /*74*/0xd7af5f, /*75*/0xffaf5f,\n\t\t\t/*76*/0x00d75f, /*77*/0x5fd75f, /*78*/0x87d75f, /*79*/0xafd75f, /*80*/0xd7d75f, /*81*/0xffd75f, /*82*/0x00ff5f, /*83*/0x5fff5f, /*84*/0x87ff5f, /*85*/0xafff5f, /*86*/0xd7ff5f, /*87*/0xffff5f,\n\t\t\t/*88*/0x000087, /*89*/0x5f0087, /*90*/0x870087, /*91*/0xaf0087, /*92*/0xd70087, /*93*/0xff0087, /*94*/0x005f87, /*95*/0x5f5f87, /*96*/0x875f87, /*97*/0xaf5f87, /*98*/0xd75f87, /*99*/0xff5f87,\n\t\t\t/*100*/0x008787, /*101*/0x5f8787, /*102*/0x878787, /*103*/0xaf8787, /*104*/0xd78787, /*105*/0xff8787, /*106*/0x00af87, /*107*/0x5faf87, /*108*/0x87af87, /*109*/0xafaf87, /*110*/0xd7af87, /*111*/0xffaf87,\n\t\t\t/*112*/0x00d787, /*113*/0x5fd787, /*114*/0x87d787, /*115*/0xafd787, /*116*/0xd7d787, /*117*/0xffd787, /*118*/0x00ff87, /*119*/0x5fff87, /*120*/0x87ff87, /*121*/0xafff87, /*122*/0xd7ff87, /*123*/0xffff87,\n\t\t\t/*124*/0x0000af, /*125*/0x5f00af, /*126*/0x8700af, /*127*/0xaf00af, /*128*/0xd700af, /*129*/0xff00af, /*130*/0x005faf, /*131*/0x5f5faf, /*132*/0x875faf, /*133*/0xaf5faf, /*134*/0xd75faf, /*135*/0xff5faf,\n\t\t\t/*136*/0x0087af, /*137*/0x5f87af, /*138*/0x8787af, /*139*/0xaf87af, /*140*/0xd787af, /*141*/0xff87af, /*142*/0x00afaf, /*143*/0x5fafaf, /*144*/0x87afaf, /*145*/0xafafaf, /*146*/0xd7afaf, /*147*/0xffafaf,\n\t\t\t/*148*/0x00d7af, /*149*/0x5fd7af, /*150*/0x87d7af, /*151*/0xafd7af, /*152*/0xd7d7af, /*153*/0xffd7af, /*154*/0x00ffaf, /*155*/0x5fffaf, /*156*/0x87ffaf, /*157*/0xafffaf, /*158*/0xd7ffaf, /*159*/0xffffaf,\n\t\t\t/*160*/0x0000d7, /*161*/0x5f00d7, /*162*/0x8700d7, /*163*/0xaf00d7, /*164*/0xd700d7, /*165*/0xff00d7, /*166*/0x005fd7, /*167*/0x5f5fd7, /*168*/0x875fd7, /*169*/0xaf5fd7, /*170*/0xd75fd7, /*171*/0xff5fd7,\n\t\t\t/*172*/0x0087d7, /*173*/0x5f87d7, /*174*/0x8787d7, /*175*/0xaf87d7, /*176*/0xd787d7, /*177*/0xff87d7, /*178*/0x00afd7, /*179*/0x5fafd7, /*180*/0x87afd7, /*181*/0xafafd7, /*182*/0xd7afd7, /*183*/0xffafd7,\n\t\t\t/*184*/0x00d7d7, /*185*/0x5fd7d7, /*186*/0x87d7d7, /*187*/0xafd7d7, /*188*/0xd7d7d7, /*189*/0xffd7d7, /*190*/0x00ffd7, /*191*/0x5fffd7, /*192*/0x87ffd7, /*193*/0xafffd7, /*194*/0xd7ffd7, /*195*/0xffffd7,\n\t\t\t/*196*/0x0000ff, /*197*/0x5f00ff, /*198*/0x8700ff, /*199*/0xaf00ff, /*200*/0xd700ff, /*201*/0xff00ff, /*202*/0x005fff, /*203*/0x5f5fff, /*204*/0x875fff, /*205*/0xaf5fff, /*206*/0xd75fff, /*207*/0xff5fff,\n\t\t\t/*208*/0x0087ff, /*209*/0x5f87ff, /*210*/0x8787ff, /*211*/0xaf87ff, /*212*/0xd787ff, /*213*/0xff87ff, /*214*/0x00afff, /*215*/0x5fafff, /*216*/0x87afff, /*217*/0xafafff, /*218*/0xd7afff, /*219*/0xffafff,\n\t\t\t/*220*/0x00d7ff, /*221*/0x5fd7ff, /*222*/0x87d7ff, /*223*/0xafd7ff, /*224*/0xd7d7ff, /*225*/0xffd7ff, /*226*/0x00ffff, /*227*/0x5fffff, /*228*/0x87ffff, /*229*/0xafffff, /*230*/0xd7ffff, /*231*/0xffffff,\n\t\t\t/*232*/0x080808, /*233*/0x121212, /*234*/0x1c1c1c, /*235*/0x262626, /*236*/0x303030, /*237*/0x3a3a3a, /*238*/0x444444, /*239*/0x4e4e4e, /*240*/0x585858, /*241*/0x626262, /*242*/0x6c6c6c, /*243*/0x767676,\n\t\t\t/*244*/0x808080, /*245*/0x8a8a8a, /*246*/0x949494, /*247*/0x9e9e9e, /*248*/0xa8a8a8, /*249*/0xb2b2b2, /*250*/0xbcbcbc, /*251*/0xc6c6c6, /*252*/0xd0d0d0, /*253*/0xdadada, /*254*/0xe4e4e4, /*255*/0xeeeeee\n\t\t};\n\n\t\tconst auto& TextColor = gDisplayParm.getTextColor();   // 30-37,38,39\n\t\tconst auto& Text256 = gDisplayParm.getText256();       // 38\n\t\tconst auto& BackColor = gDisplayParm.getBackColor();   // 40-47,48,49\n\t\tconst auto& Back256 = gDisplayParm.getBack256();       // 48\n\n\t\tif (Text256)\n\t\t{\n\t\t\tif (Text256 == clr24b)\n\t\t\t{\n\t\t\t\tattr.Attributes.Flags |= ConEmu::ColorFlags::Fg24Bit;\n\t\t\t\tattr.Attributes.ForegroundColor = TextColor&0xFFFFFF;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (TextColor > 15)\n\t\t\t\t\tattr.Attributes.Flags |= ConEmu::ColorFlags::Fg24Bit;\n\t\t\t\tattr.Attributes.ForegroundColor = RgbMap[TextColor&0xFF];\n\t\t\t}\n\t\t}\n\t\telse if (TextColor & 0x8)\n\t\t{\n\t\t\t// Comes from CONSOLE_SCREEN_BUFFER_INFO::wAttributes\n\t\t\tattr.Attributes.ForegroundColor |= ClrMap[TextColor&0x7]\n\t\t\t\t| 0x08;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tattr.Attributes.ForegroundColor |= ClrMap[TextColor&0x7]\n\t\t\t\t| ((gDisplayParm.getBrightFore() || (gDisplayParm.getBrightOrBold() && !gDisplayParm.getBrightBack())) ? 0x08 : 0);\n\t\t}\n\n\t\tif (gDisplayParm.getBrightOrBold() && (Text256 || gDisplayParm.getBrightFore() || gDisplayParm.getBrightBack()))\n\t\t\tattr.Attributes.Flags |= ConEmu::ColorFlags::Bold;\n\t\tif (gDisplayParm.getItalic())\n\t\t\tattr.Attributes.Flags |= ConEmu::ColorFlags::Italic;\n\t\tif (gDisplayParm.getUnderline())\n\t\t\tattr.Attributes.Flags |= ConEmu::ColorFlags::Underline;\n\t\tif (gDisplayParm.getCrossed())\n\t\t\tattr.Attributes.Flags |= ConEmu::ColorFlags::Crossed;\n\t\tif (gDisplayParm.getInverse())\n\t\t\tattr.Attributes.Flags |= ConEmu::ColorFlags::Reverse;\n\n\t\tif (Back256)\n\t\t{\n\t\t\tif (Back256 == clr24b)\n\t\t\t{\n\t\t\t\tattr.Attributes.Flags |= ConEmu::ColorFlags::Bg24Bit;\n\t\t\t\tattr.Attributes.BackgroundColor = BackColor&0xFFFFFF;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (BackColor > 15)\n\t\t\t\t\tattr.Attributes.Flags |= ConEmu::ColorFlags::Bg24Bit;\n\t\t\t\tattr.Attributes.BackgroundColor = RgbMap[BackColor&0xFF];\n\t\t\t}\n\t\t}\n\t\telse if (BackColor & 0x8)\n\t\t{\n\t\t\t// Comes from CONSOLE_SCREEN_BUFFER_INFO::wAttributes\n\t\t\tattr.Attributes.BackgroundColor |= ClrMap[BackColor&0x7]\n\t\t\t\t| 0x8;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tattr.Attributes.BackgroundColor |= ClrMap[BackColor&0x7]\n\t\t\t\t| (gDisplayParm.getBrightBack() ? 0x8 : 0);\n\t\t}\n\n\n\t\t//SetConsoleTextAttribute(hConsoleOutput, (WORD)wAttrs);\n\t\tExtSetAttributes(&attr);\n\t}\n}\n\n\n#if defined(DUMP_UNKNOWN_ESCAPES) || defined(DUMP_WRITECONSOLE_LINES)\nstatic MAtomic<int32_t> nWriteCallNo{ 0 };\n#endif\n\nint CEAnsi::DumpEscape(LPCWSTR buf, size_t cchLen, DumpEscapeCodes iUnknown)\n{\n\tint result = 0;\n#if defined(DUMP_UNKNOWN_ESCAPES) || defined(DUMP_WRITECONSOLE_LINES)\n\tif (!buf || !cchLen)\n\t{\n\t\t// There are programs which try to write empty strings\n\t\t// e.g. clink, perl, ...\n\t\t//_ASSERTEX((buf && cchLen) || (gszClinkCmdLine && buf));\n\t}\n\n\twchar_t szDbg[200];\n\tsize_t nLen = cchLen;\n\n\tswitch (iUnknown)  // NOLINT(clang-diagnostic-switch-enum)\n\t{\n\tcase de_Unknown/*1*/:\n\t\tmsprintf(szDbg, countof(szDbg), L\"[%u] ###Unknown Esc Sequence: \", GetCurrentThreadId());\n\t\tbreak;\n\tcase de_BadUnicode/*2*/:\n\t\tmsprintf(szDbg, countof(szDbg), L\"[%u] ###Bad Unicode Translation: \", GetCurrentThreadId());\n\t\tbreak;\n\tcase de_Ignored/*3*/:\n\t\tmsprintf(szDbg, countof(szDbg), L\"[%u] ###Ignored Esc Sequence: \", GetCurrentThreadId());\n\t\tbreak;\n\tcase de_UnkControl/*4*/:\n\t\tmsprintf(szDbg, countof(szDbg), L\"[%u] ###Unknown Esc Control: \", GetCurrentThreadId());\n\t\tbreak;\n\tcase de_Report/*5*/:\n\t\tmsprintf(szDbg, countof(szDbg), L\"[%u] ###Back Report: \", GetCurrentThreadId());\n\t\tbreak;\n\tcase de_ScrollRegion/*6*/:\n\t\tmsprintf(szDbg, countof(szDbg), L\"[%u] ###Scroll region: \", GetCurrentThreadId());\n\t\tbreak;\n\tcase de_Comment/*7*/:\n\t\tmsprintf(szDbg, countof(szDbg), L\"[%u] ###Internal comment: \", GetCurrentThreadId());\n\t\tbreak;\n\tdefault:\n\t\tresult = nWriteCallNo.inc();\n\t\tmsprintf(szDbg, countof(szDbg), L\"[%u] AnsiDump #%u: \", GetCurrentThreadId(), result);\n\t}\n\n\tconst size_t nStart = lstrlenW(szDbg);\n\twchar_t* pszDst = szDbg + nStart;\n\twchar_t* pszFrom = szDbg;\n\n\tif (buf && cchLen)\n\t{\n\t\tconst wchar_t* pszSrc = static_cast<const wchar_t*>(buf);\n\t\tsize_t nCur = 0;\n\t\twhile (nLen)\n\t\t{\n\t\t\tswitch (*pszSrc)\n\t\t\t{\n\t\t\tcase L'\\r':\n\t\t\t\t*(pszDst++) = L'\\\\'; *(pszDst++) = L'r';\n\t\t\t\tbreak;\n\t\t\tcase L'\\n':\n\t\t\t\t*(pszDst++) = L'\\\\'; *(pszDst++) = L'n';\n\t\t\t\tbreak;\n\t\t\tcase L'\\t':\n\t\t\t\t*(pszDst++) = L'\\\\'; *(pszDst++) = L't';\n\t\t\t\tbreak;\n\t\t\tcase L'\\x1B':\n\t\t\t\t*(pszDst++) = szAnalogues[0x1B];\n\t\t\t\tbreak;\n\t\t\tcase 0:\n\t\t\t\t*(pszDst++) = L'\\\\'; *(pszDst++) = L'0';\n\t\t\t\tbreak;\n\t\t\tcase 7:\n\t\t\t\t*(pszDst++) = L'\\\\'; *(pszDst++) = L'a';\n\t\t\t\tbreak;\n\t\t\tcase 8:\n\t\t\t\t*(pszDst++) = L'\\\\'; *(pszDst++) = L'b';\n\t\t\t\tbreak;\n\t\t\tcase 0x7F:\n\t\t\t\t*(pszDst++) = '\\\\'; *(pszDst++) = 'x'; *(pszDst++) = '7'; *(pszDst++) = 'F';\n\t\t\t\tbreak;\n\t\t\tcase L'\\\\':\n\t\t\t\t*(pszDst++) = L'\\\\'; *(pszDst++) = L'\\\\';\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t*(pszDst++) = *pszSrc;\n\t\t\t}\n\t\t\tpszSrc++;\n\t\t\tnLen--;\n\t\t\tnCur++;\n\n\t\t\tif (nCur >= 80)\n\t\t\t{\n\t\t\t\t*(pszDst++) = 0xB6; // L'\u00b6';\n\t\t\t\t*(pszDst++) = L'\\n';\n\t\t\t\t*pszDst = 0;\n\t\t\t\t// Try to pass UTF-8 encoded strings to debugger\n\t\t\t\tDebugStringUtf8(szDbg);\n\t\t\t\twmemset(szDbg, L' ', nStart);\n\t\t\t\tnCur = 0;\n\t\t\t\tpszFrom = pszDst = szDbg + nStart;\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tpszDst -= 2;\n\t\tconst wchar_t* psEmptyMessage = L\" - <empty sequence>\";\n\t\tconst size_t nMsgLen = lstrlenW(psEmptyMessage);\n\t\twmemcpy(pszDst, psEmptyMessage, nMsgLen);\n\t\tpszDst += nMsgLen;\n\t}\n\n\tif (pszDst > pszFrom)\n\t{\n\t\t*(pszDst++) = 0xB6; // L'\u00b6';\n\t\t*(pszDst++) = L'\\n';\n\t\t*pszDst = 0;\n\t\t// Try to pass UTF-8 encoded strings to debugger\n\t\tDebugStringUtf8(szDbg);\n\t}\n\n\tif (iUnknown == 1)\n\t{\n\t\t_ASSERTEX(FALSE && \"Unknown Esc Sequence!\");\n\t}\n#endif\n\treturn result;\n}\n\n#ifdef DUMP_UNKNOWN_ESCAPES\n#define DumpUnknownEscape(buf, cchLen) DumpEscape(buf, cchLen, de_Unknown)\n#define DumpKnownEscape(buf, cchLen, eType) DumpEscape(buf, cchLen, eType)\n#else\n#define DumpUnknownEscape(buf,cchLen) (0)\n#define DumpKnownEscape(buf, cchLen, eType) (0)\n#endif\n\nstatic MAtomic<uint32_t> gnLastReadId{ 0 };\n\n// When user type something in the prompt, screen buffer may be scrolled\n// It would be nice to do the same in \"ConEmuC -StoreCWD\"\nvoid CEAnsi::OnReadConsoleBefore(HANDLE hConOut, const CONSOLE_SCREEN_BUFFER_INFO& csbi)\n{\n\tCEAnsi* pObj = CEAnsi::Object();\n\tif (!pObj)\n\t\treturn;\n\n\tif (!gnLastReadId.load())\n\t\tgnLastReadId.store(GetCurrentProcessId());\n\n\tWORD newRowId = 0;\n\tCEConsoleMark Test = {};\n\n\tCOORD crPos[] = { {4,static_cast<SHORT>(csbi.dwCursorPosition.Y - 1)}, csbi.dwCursorPosition };\n\t_ASSERTEX(countof(crPos) == countof(pObj->m_RowMarks.SaveRow) && countof(crPos) == countof(pObj->m_RowMarks.RowId));\n\n\tpObj->m_RowMarks.csbi = csbi;\n\n\tfor (int i = 0; i < 2; i++)\n\t{\n\t\tpObj->m_RowMarks.SaveRow[i] = -1;\n\t\tpObj->m_RowMarks.RowId[i] = 0;\n\n\t\tif (crPos[i].X < 4 || crPos[i].Y < 0)\n\t\t\tcontinue;\n\n\t\tif (ReadConsoleRowId(hConOut, crPos[i].Y, &Test))\n\t\t{\n\t\t\tpObj->m_RowMarks.SaveRow[i] = crPos[i].Y;\n\t\t\tpObj->m_RowMarks.RowId[i] = Test.RowId;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// ReSharper disable once CppJoinDeclarationAndAssignment\n\t\t\tnewRowId = LOWORD(gnLastReadId.inc());\n\t\t\tif (!newRowId)\n\t\t\t\tnewRowId = LOWORD(gnLastReadId.inc());\n\n\t\t\tif (WriteConsoleRowId(hConOut, crPos[i].Y, newRowId))\n\t\t\t{\n\t\t\t\tpObj->m_RowMarks.SaveRow[i] = crPos[i].Y;\n\t\t\t\tpObj->m_RowMarks.RowId[i] = newRowId;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Successful mark?\n\t_ASSERTEX(((pObj->m_RowMarks.RowId[0] || pObj->m_RowMarks.RowId[1]) && (pObj->m_RowMarks.RowId[0] != pObj->m_RowMarks.RowId[1])) || (!csbi.dwCursorPosition.X && !csbi.dwCursorPosition.Y));\n\n\t// Store info in MAPPING\n\tCESERVER_CONSOLE_APP_MAPPING* pAppMap = gpAppMap ? gpAppMap->Ptr() : nullptr;\n\tif (pAppMap)\n\t{\n\t\tpAppMap->csbiPreRead = csbi;\n\t\tpAppMap->nPreReadRowID[0] = pObj->m_RowMarks.RowId[0];\n\t\tpAppMap->nPreReadRowID[1] = pObj->m_RowMarks.RowId[1];\n\t}\n}\nvoid CEAnsi::OnReadConsoleAfter(bool bFinal, bool bNoLineFeed)\n{\n\tCEAnsi* pObj = CEAnsi::Object();\n\tif (!pObj)\n\t\treturn;\n\n\tif (pObj->m_RowMarks.SaveRow[0] < 0 && pObj->m_RowMarks.SaveRow[1] < 0)\n\t\treturn;\n\n\tCONSOLE_SCREEN_BUFFER_INFO csbi = {};\n\t// ReSharper disable once CppLocalVariableMayBeConst\n\tHANDLE hConOut = GetStdHandle(STD_OUTPUT_HANDLE);\n\tSHORT nMarkedRow = -1;\n\tCEConsoleMark Test = {};\n\n\tif (!GetConsoleScreenBufferInfo(hConOut, &csbi))\n\t\tgoto wrap;\n\n\tif (!FindConsoleRowId(hConOut, csbi.dwCursorPosition.Y, true, &nMarkedRow, &Test))\n\t\tgoto wrap;\n\n\tfor (int i = 1; i >= 0; i--)\n\t{\n\t\tif ((pObj->m_RowMarks.SaveRow[i] >= 0) && (pObj->m_RowMarks.RowId[i] == Test.RowId))\n\t\t{\n\t\t\tif (pObj->m_RowMarks.SaveRow[i] == nMarkedRow)\n\t\t\t{\n\t\t\t\t_ASSERTEX(\n\t\t\t\t\t((pObj->m_RowMarks.csbi.dwCursorPosition.Y < (pObj->m_RowMarks.csbi.dwSize.Y-1))\n\t\t\t\t\t\t|| (bNoLineFeed && (pObj->m_RowMarks.csbi.dwCursorPosition.Y == (pObj->m_RowMarks.csbi.dwSize.Y-1))))\n\t\t\t\t\t&& \"Nothing was changed? Strange, scrolling was expected\");\n\t\t\t\tgoto wrap;\n\t\t\t}\n\t\t\t// Well, we get scroll distance\n\t\t\t_ASSERTEX(nMarkedRow < pObj->m_RowMarks.SaveRow[i]); // Upside scroll expected\n\t\t\tExtScrollScreenParm scrl = {sizeof(scrl), essf_ExtOnly, hConOut, nMarkedRow - pObj->m_RowMarks.SaveRow[i], {}, 0, {}};\n\t\t\tExtScrollScreen(&scrl);\n\t\t\tgoto wrap;\n\t\t}\n\t}\n\nwrap:\n\t// Clear it\n\tfor (int i = 0; i < 2; i++)\n\t{\n\t\tpObj->m_RowMarks.SaveRow[i] = -1;\n\t\tpObj->m_RowMarks.RowId[i] = 0;\n\t}\n}\n\n\nBOOL CEAnsi::WriteText(OnWriteConsoleW_t writeConsoleW, HANDLE hConsoleOutput, LPCWSTR lpBuffer, DWORD nNumberOfCharsToWrite, LPDWORD lpNumberOfCharsWritten, BOOL abCommit /*= FALSE*/, EXTREADWRITEFLAGS AddFlags /*= ewtf_None*/)\n{\n\tBOOL lbRc = FALSE;\n\tDWORD /*nWritten = 0,*/ nTotalWritten = 0;\n\n\t#ifdef _DEBUG\n\tORIGINAL_KRNL(WriteConsoleW);\n\tOnWriteConsoleW_t pfnDbgWriteConsoleW = F(WriteConsoleW);\n\t_ASSERTE(((writeConsoleW == pfnDbgWriteConsoleW) || !HooksWereSet) && \"It must point to CallPointer for 'unhooked' call\");\n\t#endif\n\n\tif (lpBuffer && nNumberOfCharsToWrite)\n\t\tm_LastWrittenChar = lpBuffer[nNumberOfCharsToWrite-1];\n\n\tExtWriteTextParm write{};\n\twrite.StructSize = sizeof(write);\n\twrite.Flags = ewtf_Current | AddFlags;\n\twrite.ConsoleOutput = hConsoleOutput;\n\twrite.Private = reinterpret_cast<void*>(writeConsoleW);\n\n\tLPCWSTR pszSrcBuffer = lpBuffer;\n\twchar_t cvtBuf[80];\n\twchar_t* pCvtBuf = nullptr;\n\tCEStr buffer;\n\tif (mCharSet && lpBuffer && nNumberOfCharsToWrite)\n\t{\n\t\tstatic wchar_t G0_DRAWING[31] = {\n\t\t\t0x2666 /*\u2666*/, 0x2592 /*\u2592*/, 0x2192 /*\u2192*/, 0x21A8 /*\u21a8*/, 0x2190 /*\u2190*/, 0x2193 /*\u2193*/, 0x00B0 /*\u00b0*/, 0x00B1 /*\u00b1*/,\n\t\t\t0x00B6 /*\u00b6*/, 0x2195 /*\u2195*/, 0x2518 /*\u2518*/, 0x2510 /*\u2510*/, 0x250C /*\u250c*/, 0x2514 /*\u2514*/, 0x253C /*\u253c*/, 0x203E /*\u203e*/,\n\t\t\t0x207B /*\u207b*/, 0x2500 /*\u2500*/, 0x208B /*\u208b*/, 0x005F /*_*/, 0x251C /*\u251c*/, 0x2524 /*\u2524*/, 0x2534 /*\u2534*/, 0x252C /*\u252c*/,\n\t\t\t0x2502 /*\u2502*/, 0x2264 /*\u2264*/, 0x2265 /*\u2265*/, 0x03C0 /*\u03c0*/, 0x2260 /*\u2260*/, 0x00A3 /*\u00a3*/, 0x00B7 /*\u00b7*/\n\t\t};\n\t\tLPCWSTR pszMap = nullptr;\n\t\t// ReSharper disable once CppIncompleteSwitchStatement\n\t\tswitch (mCharSet)  // NOLINT(clang-diagnostic-switch)\n\t\t{\n\t\tcase VTCS_DRAWING:\n\t\t\tpszMap = G0_DRAWING;\n\t\t\tbreak;\n\t\t}\n\t\tif (pszMap)\n\t\t{\n\t\t\twchar_t* dst = nullptr;\n\t\t\tfor (DWORD i = 0; i < nNumberOfCharsToWrite; ++i)\n\t\t\t{\n\t\t\t\tif (pszSrcBuffer[i] >= 0x60 && pszSrcBuffer[i] < 0x7F)\n\t\t\t\t{\n\t\t\t\t\tif (!pCvtBuf)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (nNumberOfCharsToWrite <= countof(cvtBuf))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tpCvtBuf = cvtBuf;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (!((pCvtBuf = buffer.GetBuffer(nNumberOfCharsToWrite))))\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlpBuffer = pCvtBuf;\n\t\t\t\t\t\tdst = pCvtBuf;\n\t\t\t\t\t\tif (i)\n\t\t\t\t\t\t\tmemmove(dst, pszSrcBuffer, i * sizeof(*dst));\n\t\t\t\t\t}\n\t\t\t\t\tdst[i] = pszMap[pszSrcBuffer[i] - 0x60];\n\t\t\t\t}\n\t\t\t\telse if (dst)\n\t\t\t\t{\n\t\t\t\t\tdst[i] = pszSrcBuffer[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tReloadFeatures();\n\tif (mb_SuppressBells)\n\t{\n\t\twrite.Flags |= ewtf_NoBells;\n\t}\n\n\tif (gDisplayOpt.WrapWasSet && (gDisplayOpt.WrapAt > 0))\n\t{\n\t\twrite.Flags |= ewtf_WrapAt;\n\t\twrite.WrapAtCol = gDisplayOpt.WrapAt;\n\t}\n\n\tif (gDisplayOpt.ScrollRegion)\n\t{\n\t\twrite.Flags |= ewtf_Region;\n\t\t_ASSERTEX(gDisplayOpt.ScrollStart >= 0 && gDisplayOpt.ScrollEnd >= gDisplayOpt.ScrollStart);\n\t\twrite.Region.top = gDisplayOpt.ScrollStart;\n\t\twrite.Region.bottom = gDisplayOpt.ScrollEnd;\n\t\twrite.Region.left = write.Region.right = -1; // not used yet\n\t}\n\n\tif (!IsAutoLfNl())\n\t\twrite.Flags |= ewtf_NoLfNl;\n\n\tDWORD nWriteFrom = 0, nWriteTo = nNumberOfCharsToWrite;\n\n\t#ifdef GH_1402\n\tstatic bool fishLineFeed = false;\n\tstruct ExtWriteTextCalls { const wchar_t* buffer; size_t count; };\n\tconst size_t ext_calls_max = 16;\n\tstatic ExtWriteTextCalls ext_calls[ext_calls_max] = {};\n\tstatic size_t ext_calls_count = 0;\n\n\tauto count_chars = [&](const wchar_t test) -> unsigned {\n\t\tunsigned count = 0;\n\t\tfor (DWORD n = nWriteFrom; n < nWriteTo; ++n)\n\t\t{\n\t\t\tif (lpBuffer[n] == test)\n\t\t\t\t++count;\n\t\t}\n\t\treturn count;\n\t};\n\t#endif\n\n\tif ((nNumberOfCharsToWrite == 1) && isConsoleBadDBCS())\n\t{\n\t\tif (lpBuffer[0] == ucLineFeed)\n\t\t{\n\t\t\tstatic wchar_t dummy_buf[2] = L\"%\";\n\t\t\tlpBuffer = dummy_buf;\n\t\t}\n\t}\n\n\twhile (nWriteTo > nWriteFrom && nWriteFrom < nNumberOfCharsToWrite)\n\t{\n\t\t#ifdef GH_1402\n\t\tbool curFishLineFeed = false;\n\t\tif (count_chars(ucLineFeed) > 0)\n\t\t{\n\t\t\tif (!gbIsXTermOutput)\n\t\t\t{\n\t\t\t\t_ASSERTE(FALSE && \"XTerm mode was not enabled!\");\n\t\t\t\tDBG_XTERM(L\"xTermOutput=ON due gh-1402 LineFeed\");\n\t\t\t\tSetIsXTermOutput(true);\n\t\t\t}\n\t\t\tcurFishLineFeed = true;\n\t\t}\n\t\t#endif\n\n\t\t// for debug purposes insert \"\\x1B]9;10\\x1B\\\" at the beginning of connector-*-out.log\n\t\tif (gbIsXTermOutput)\n\t\t{\n\t\t\t// On Win10 we may utilize DISABLE_NEWLINE_AUTO_RETURN flag, but it would\n\t\t\t// complicate our code, because ConEmu support older Windows versions\n\t\t\twrite.Flags &= ~ewtf_DontWrap;\n\t\t\t// top:  writes all lines using full console width\n\t\t\t//       and thereafter some ANSI-s and \"\\r\\n\"\n\t\t\t// fish: writes in one call \"(Width-1)*Spaces,\\r,Space,\\r\"\n\t\t\tDWORD ChrSet = (lpBuffer[nWriteFrom] == L'\\r' || lpBuffer[nWriteFrom] == L'\\n') ? 1 : 2;\n\t\t\tfor (DWORD n = nWriteFrom+1; (n < nWriteTo); n++)\n\t\t\t{\n\t\t\t\tDWORD AddChrSet = (lpBuffer[n] == L'\\r' || lpBuffer[n] == L'\\n') ? 1 : 2;\n\t\t\t\tif (ChrSet != AddChrSet)\n\t\t\t\t{\n\t\t\t\t\t// If only printable chars are written\n\t\t\t\t\t// ExtWriteText will check (AI) if it must not wrap&scroll\n\t\t\t\t\tif (ChrSet == 2)\n\t\t\t\t\t\twrite.Flags |= ewtf_DontWrap;\n\t\t\t\t\tnWriteTo = n;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t// Expected to be the same\n\t\t\t\t_ASSERTE(ChrSet == AddChrSet);\n\t\t\t\tChrSet |= AddChrSet;\n\t\t\t}\n\t\t\t// Perhaps, we shall do that always\n\t\t\tif (ChrSet == 2)\n\t\t\t\twrite.Flags |= ewtf_DontWrap;\n\t\t}\n\t\t_ASSERTE(nWriteTo<=nNumberOfCharsToWrite);\n\n\t\t//lbRc = writeConsoleW(hConsoleOutput, lpBuffer, nNumberOfCharsToWrite, &nTotalWritten, nullptr);\n\t\twrite.Buffer = lpBuffer + nWriteFrom;\n\t\twrite.NumberOfCharsToWrite = nWriteTo - nWriteFrom;\n\n\t\t#ifdef GH_1402\n\t\t// For debugging purposes, we store ext_calls_max latest outputs\n\t\tauto& ext_call = ext_calls[(ext_calls_count++) % ext_calls_max];\n\t\text_call.buffer = write.Buffer;\n\t\text_call.count = write.NumberOfCharsToWrite;\n\t\t// Ensure we don't write more than a one LF character\n\t\tif (curFishLineFeed)\n\t\t{\n\t\t\tunsigned ulf_chars = count_chars(ucLineFeed);\n\t\t\t_ASSERTE(ulf_chars <= 1);\n\t\t\tunsigned cr_chars = count_chars(L'\\r');\n\t\t\tunsigned lf_chars = count_chars(L'\\n');\n\t\t\tif (ulf_chars)\n\t\t\t\t_ASSERTE((ulf_chars > 0) != ((cr_chars+lf_chars) > 0));\n\t\t\tif (fishLineFeed && (count_chars(L' ') > 0))\n\t\t\t\t_ASSERTE((write.Flags & ewtf_DontWrap) != 0);\n\t\t\tif (ulf_chars > 0)\n\t\t\t\tfishLineFeed = true;\n\t\t\tif (cr_chars > 0)\n\t\t\t\tfishLineFeed = false;\n\t\t}\n\t\t#endif\n\n\t\tlbRc = ExtWriteText(&write);\n\t\tif (lbRc)\n\t\t{\n\t\t\tif (write.NumberOfCharsWritten)\n\t\t\t{\n\t\t\t\tnTotalWritten += write.NumberOfCharsWritten;\n\t\t\t}\n\t\t\tif (write.ScrolledRowsUp > 0)\n\t\t\t{\n\t\t\t\tconst int right = static_cast<int>(gDisplayCursor.StoredCursorPos.Y) - static_cast<int>(write.ScrolledRowsUp);\n\t\t\t\tgDisplayCursor.StoredCursorPos.Y = static_cast<SHORT>(std::max(0, right));\n\t\t\t}\n\t\t}\n\n\t\tnWriteFrom = nWriteTo; nWriteTo = nNumberOfCharsToWrite;\n\t}\n\n\tif (lpNumberOfCharsWritten)\n\t\t*lpNumberOfCharsWritten = nTotalWritten;\n\n\treturn lbRc;\n}\n\n// NON-static, because we need to \u2018cache\u2019 parts of non-translated MBCS chars (one UTF-8 symbol may be transmitted by up to *three* parts)\nBOOL CEAnsi::OurWriteConsoleA(HANDLE hConsoleOutput, const char *lpBuffer, DWORD nNumberOfCharsToWrite, LPDWORD lpNumberOfCharsWritten)\n{\n\t_ASSERTE(this != nullptr);\n\tBOOL lbRc = FALSE;\n\twchar_t* buf = nullptr;\n\twchar_t szTemp[280]; // would be enough in most cases\n\tCEStr ptrTemp;\n\tINT_PTR bufMax;\n\t// ReSharper disable once CppJoinDeclarationAndAssignment\n\tDWORD cp;\n\t// ReSharper disable once CppJoinDeclarationAndAssignment\n\tCpCvtResult cvt{};\n\tconst char* pSrc = nullptr;\n\tconst char* pTokenStart = nullptr;\n\twchar_t* pDst = nullptr;\n\twchar_t* pDstEnd = nullptr;\n\tDWORD nWritten = 0;\n\tDWORD nTotalWritten = 0;\n\n\tORIGINAL_KRNL(WriteConsoleA);\n\n\t// Nothing to write? Or flush buffer?\n\tif (!lpBuffer || !nNumberOfCharsToWrite || !hConsoleOutput || (hConsoleOutput == INVALID_HANDLE_VALUE))\n\t{\n\t\tif (lpNumberOfCharsWritten)\n\t\t\t*lpNumberOfCharsWritten = 0;\n\t\tlbRc = TRUE;\n\t\tgoto fin;\n\t}\n\n\tif ((nNumberOfCharsToWrite + 3) >= countof(szTemp))\n\t{\n\t\tbufMax = nNumberOfCharsToWrite + 3;\n\t\tbuf = ptrTemp.GetBuffer(bufMax);\n\t}\n\telse\n\t{\n\t\tbuf = szTemp;\n\t\tbufMax = countof(szTemp);\n\t}\n\tif (!buf)\n\t{\n\t\tSetLastError(ERROR_NOT_ENOUGH_MEMORY);\n\t\tgoto fin;\n\t}\n\n\tcp = GetCodePage();\n\tm_Cvt.SetCP(cp);\n\n\tlbRc = TRUE;\n\tpSrc = pTokenStart = lpBuffer;\n\tpDst = buf; pDstEnd = buf + bufMax - 3;\n\tfor (DWORD n = 0; n < nNumberOfCharsToWrite; n++, pSrc++)\n\t{\n\t\tif (pDst >= pDstEnd)\n\t\t{\n\t\t\t_ASSERTE((pDst < (buf+bufMax)) && \"wchar_t buffer overflow while converting\");\n\t\t\tbuf[(pDst - buf)] = 0; // It's not required, just to easify debugging\n\t\t\tlbRc = OurWriteConsoleW(hConsoleOutput, buf, static_cast<DWORD>(pDst - buf), &nWritten, nullptr);\n\t\t\tif (lbRc) nTotalWritten += nWritten;\n\t\t\tpDst = buf;\n\t\t}\n\t\tcvt = m_Cvt.Convert(*pSrc, *pDst);\n\t\tswitch (cvt)  // NOLINT(clang-diagnostic-switch-enum)\n\t\t{\n\t\tcase ccr_OK:\n\t\tcase ccr_BadUnicode:\n\t\t\tpDst++;\n\t\t\tbreak;\n\t\tcase ccr_Surrogate:\n\t\tcase ccr_BadTail:\n\t\tcase ccr_DoubleBad:\n\t\t\tm_Cvt.GetTail(*(++pDst));\n\t\t\tpDst++;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (pDst > buf)\n\t{\n\t\t_ASSERTE((pDst < (buf+bufMax)) && \"wchar_t buffer overflow while converting\");\n\t\tbuf[(pDst - buf)] = 0; // It's not required, just to easify debugging\n\t\tlbRc = OurWriteConsoleW(hConsoleOutput, buf, static_cast<DWORD>(pDst - buf), &nWritten, nullptr);\n\t\tif (lbRc)\n\t\t\tnTotalWritten += nWritten;\n\t}\n\n\t// Issue 1291:\tPython fails to print string sequence with ASCII character followed by Chinese character.\n\tif (lpNumberOfCharsWritten && lbRc)\n\t{\n\t\t*lpNumberOfCharsWritten = nNumberOfCharsToWrite;\n\t}\n\nfin:\n\tstd::ignore = pTokenStart;\n\tstd::ignore = nTotalWritten;\n\treturn lbRc;\n}\n\nBOOL CEAnsi::OurWriteConsoleW(HANDLE hConsoleOutput, const VOID *lpBuffer, DWORD nNumberOfCharsToWrite, LPDWORD lpNumberOfCharsWritten, LPVOID lpReserved, bool bInternal /*= false*/)\n{\n\tORIGINAL_KRNL(WriteConsoleW);\n\tBOOL lbRc = FALSE;\n\t//ExtWriteTextParm wrt = {sizeof(wrt), ewtf_None, hConsoleOutput};\n\tbool bIsConOut = false;\n\tbool bIsAnsi = false;\n\n\tFIRST_ANSI_CALL(static_cast<const BYTE*>(lpBuffer), nNumberOfCharsToWrite);\n\n#if 0\n\t// Store prompt(?) for clink 0.1.1\n\tif ((gnAllowClinkUsage == 1) && nNumberOfCharsToWrite && lpBuffer && gpszLastWriteConsole && gcchLastWriteConsoleMax)\n\t{\n\t\tsize_t cchMax = std::min(gcchLastWriteConsoleMax-1,nNumberOfCharsToWrite);\n\t\tgpszLastWriteConsole[cchMax] = 0;\n\t\twmemmove(gpszLastWriteConsole, (const wchar_t*)lpBuffer, cchMax);\n\t}\n#endif\n\n\t// In debug builds: Write to debug console all console Output\n\tconst auto ansiIndex = DumpKnownEscape(static_cast<const wchar_t*>(lpBuffer), nNumberOfCharsToWrite, de_Normal);\n\n#ifdef _DEBUG\n\tstruct AnsiDuration  // NOLINT(cppcoreguidelines-special-member-functions)\n\t{\n\t\tconst int ansiIndex_;\n\t\tconst std::chrono::steady_clock::time_point startTime_;\n\n\t\tAnsiDuration(const int ansiIndex)\n\t\t\t: ansiIndex_(ansiIndex), startTime_(std::chrono::steady_clock::now())\n\t\t{\n\t\t}\n\n\t\t~AnsiDuration()\n\t\t{\n\t\t\tconst auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::steady_clock::now() - startTime_);\n\t\t\twchar_t info[80] = L\"\";\n\t\t\tmsprintf(info, countof(info), L\"[%u] AnsiDump #%u duration(ms): %u\\n\", GetCurrentThreadId(), ansiIndex_, duration.count());\n\t\t\tOutputDebugStringW(info);\n\t\t}\n\t};\n\tAnsiDuration duration(ansiIndex);\n#endif\n\n\tCEAnsi* pObj = nullptr;\n\tCEStr cpCvtBuffer;\n\n\tif (lpBuffer && nNumberOfCharsToWrite && hConsoleOutput)\n\t{\n\t\tbIsAnsi = HandleKeeper::IsAnsiCapable(hConsoleOutput, &bIsConOut);\n\n\t\tif (ghAnsiLogFile && bIsConOut)\n\t\t{\n\t\t\tCEAnsi::WriteAnsiLogW(static_cast<LPCWSTR>(lpBuffer), nNumberOfCharsToWrite);\n\t\t}\n\t}\n\n\tif (lpBuffer && nNumberOfCharsToWrite && hConsoleOutput && bIsAnsi)\n\t{\n\t\t// if that was API call of WriteConsoleW\n\t\tif (!bInternal && gCpConv.nFromCP && gCpConv.nToCP)\n\t\t{\n\t\t\t// Convert from unicode to MBCS\n\t\t\tCEStrA pszTemp;\n\t\t\tint iMbcsLen = WideCharToMultiByte(gCpConv.nFromCP, 0, static_cast<LPCWSTR>(lpBuffer), nNumberOfCharsToWrite, nullptr, 0, nullptr, nullptr);\n\t\t\tif ((iMbcsLen > 0) && ((pszTemp.GetBuffer(iMbcsLen)) != nullptr))\n\t\t\t{\n\t\t\t\tBOOL bFailed = FALSE; // Do not do conversion if some chars can't be mapped\n\t\t\t\tiMbcsLen = WideCharToMultiByte(gCpConv.nFromCP, 0, static_cast<LPCWSTR>(lpBuffer), nNumberOfCharsToWrite, pszTemp.data(), iMbcsLen, nullptr, &bFailed);\n\t\t\t\tif ((iMbcsLen > 0) && !bFailed)\n\t\t\t\t{\n\t\t\t\t\tint iWideLen = MultiByteToWideChar(gCpConv.nToCP, 0, pszTemp, iMbcsLen, nullptr, 0);\n\t\t\t\t\tif (iWideLen > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\twchar_t* ptrBuf = cpCvtBuffer.GetBuffer(iWideLen);\n\t\t\t\t\t\tif (ptrBuf)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tiWideLen = MultiByteToWideChar(gCpConv.nToCP, 0, pszTemp, iMbcsLen, ptrBuf, iWideLen);\n\t\t\t\t\t\t\tif (iWideLen > 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tlpBuffer = ptrBuf;\n\t\t\t\t\t\t\t\tnNumberOfCharsToWrite = iWideLen;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpObj = CEAnsi::Object();\n\t\tif (pObj)\n\t\t{\n\t\t\tif (pObj->gnPrevAnsiPart || gDisplayOpt.WrapWasSet)\n\t\t\t{\n\t\t\t\t// \u0415\u0441\u043b\u0438 \u043e\u0441\u0442\u0430\u043b\u0441\u044f \"\u0445\u0432\u043e\u0441\u0442\" \u043e\u0442 \u043f\u0440\u0435\u0434\u0443\u0449\u0435\u0439 \u0437\u0430\u043f\u0438\u0441\u0438 - \u0441\u0440\u0430\u0437\u0443, \u0431\u0435\u0437 \u043f\u0440\u043e\u0432\u0435\u0440\u043e\u043a\n\t\t\t\tlbRc = pObj->WriteAnsiCodes(F(WriteConsoleW), hConsoleOutput, static_cast<const wchar_t*>(lpBuffer), nNumberOfCharsToWrite, lpNumberOfCharsWritten);\n\t\t\t\tgoto ansidone;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t_ASSERTEX(ESC==27 && BEL==7 && DSC==0x90);\n\t\t\t\tconst wchar_t* pch = static_cast<const wchar_t*>(lpBuffer);\n\t\t\t\tfor (size_t i = nNumberOfCharsToWrite; i--; pch++)\n\t\t\t\t{\n\t\t\t\t\t// \u0415\u0441\u043b\u0438 \u0432 \u0432\u044b\u0432\u043e\u0434\u0438\u043c\u043e\u0439 \u0441\u0442\u0440\u043e\u043a\u0435 \u0432\u0441\u0442\u0440\u0435\u0447\u0430\u0435\u0442\u0441\u044f \"Ansi ESC Code\" - \u0432\u044b\u0432\u043e\u0434\u0438\u043c \u0441\u0430\u043c\u0438\n\t\t\t\t\tTODO(\"Non-CSI codes, like as BEL, BS, CR, LF, FF, TAB, VT, SO, SI\");\n\t\t\t\t\tif (*pch == ESC /*|| *pch == BEL*/ /*|| *pch == ENQ*/)\n\t\t\t\t\t{\n\t\t\t\t\t\tlbRc = pObj->WriteAnsiCodes(F(WriteConsoleW), hConsoleOutput, static_cast<const wchar_t*>(lpBuffer), nNumberOfCharsToWrite, lpNumberOfCharsWritten);\n\t\t\t\t\t\tgoto ansidone;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!bIsAnsi || ((pObj = CEAnsi::Object()) == nullptr))\n\t{\n\t\tlbRc = F(WriteConsoleW)(hConsoleOutput, lpBuffer, nNumberOfCharsToWrite, lpNumberOfCharsWritten, lpReserved);\n\t}\n\telse\n\t{\n\t\tlbRc = pObj->WriteText(F(WriteConsoleW), hConsoleOutput, static_cast<LPCWSTR>(lpBuffer), nNumberOfCharsToWrite, lpNumberOfCharsWritten, TRUE);\n\t\t//wrt.Flags = ewtf_Current|ewtf_Commit;\n\t\t//wrt.Buffer = (const wchar_t*)lpBuffer;\n\t\t//wrt.NumberOfCharsToWrite = nNumberOfCharsToWrite;\n\t\t//wrt.Private = F(WriteConsoleW);\n\t\t//lbRc = ExtWriteText(&wrt);\n\t\t//if (lbRc)\n\t\t//{\n\t\t//\tif (lpNumberOfCharsWritten)\n\t\t//\t\t*lpNumberOfCharsWritten = wrt.NumberOfCharsWritten;\n\t\t//\tif (wrt.ScrolledRowsUp > 0)\n\t\t//\t\tgDisplayCursor.StoredCursorPos.Y = std::max(0,((int)gDisplayCursor.StoredCursorPos.Y - (int)wrt.ScrolledRowsUp));\n\t\t//}\n\t}\n\tgoto wrap;\n\nansidone:\n\t{\n\t\tExtCommitParm cmt = {sizeof(cmt), hConsoleOutput};\n\t\tExtCommit(&cmt);\n\t}\nwrap:\n\treturn lbRc;\n}\n\n//struct AnsiEscCode\n//{\n//\twchar_t  First;  // ESC (27)\n//\twchar_t  Second; // any of 64 to 95 ('@' to '_')\n//\twchar_t  Action; // any of 64 to 126 (@ to ~). this is terminator\n//\twchar_t  Skip;   // \u0415\u0441\u043b\u0438 !=0 - \u0442\u043e \u044d\u0442\u0443 \u043f\u043e\u0441\u043b\u0435\u0434\u043e\u0432\u0430\u0442\u0435\u043b\u044c\u043d\u043e\u0441\u0442\u044c \u043d\u0443\u0436\u043d\u043e \u043f\u0440\u043e\u043f\u0443\u0441\u0442\u0438\u0442\u044c\n//\tint      ArgC;\n//\tint      ArgV[16];\n//\tLPCWSTR  ArgSZ; // Reserved for key mapping\n//\tsize_t   cchArgSZ;\n//\n//#ifdef _DEBUG\n//\tLPCWSTR  pszEscStart;\n//\tsize_t   nTotalLen;\n//#endif\n//\n//\tint      PvtLen;\n//\twchar_t  Pvt[16];\n//};\n\n\n// 0 - \u043d\u0435\u0442 (\u0432 lpBuffer \u0442\u043e\u043b\u044c\u043a\u043e \u0442\u0435\u043a\u0441\u0442)\n// 1 - \u0432 Code \u043f\u043e\u043c\u0435\u0449\u0435\u043d\u0430 Esc \u043f\u043e\u0441\u043b\u0435\u0434\u043e\u0432\u0430\u0442\u0435\u043b\u044c\u043d\u043e\u0441\u0442\u044c (\u043c\u043e\u0436\u0435\u0442 \u0431\u044b\u0442\u044c \u043f\u0440\u043e\u0441\u0442\u043e\u0439 \u0442\u0435\u043a\u0441\u0442 \u0414\u041e \u043d\u0435\u0435)\n// 2 - \u043d\u0435\u0442, \u043d\u043e \u043a\u0443\u0441\u043e\u043a \u043f\u043e\u0441\u043b\u0435\u0434\u043e\u0432\u0430\u0442\u0435\u043b\u044c\u043d\u043e\u0441\u0442\u0438 \u0441\u043e\u0445\u0440\u0430\u043d\u0435\u043d \u0432 gsPrevAnsiPart\nint CEAnsi::NextEscCode(LPCWSTR lpBuffer, LPCWSTR lpEnd, wchar_t (&szPreDump)[CEAnsi_MaxPrevPart], DWORD& cchPrevPart, LPCWSTR& lpStart, LPCWSTR& lpNext, CEAnsi::AnsiEscCode& Code, BOOL ReEntrance /*= FALSE*/)\n{\n\tint iRc = 0;\n\twchar_t wc;\n\n\tLPCWSTR lpSaveStart = lpBuffer;\n\tlpStart = lpBuffer;\n\n\t_ASSERTEX(cchPrevPart==0);\n\n\tif (gnPrevAnsiPart && !ReEntrance)\n\t{\n\t\tif (*gsPrevAnsiPart == 27)\n\t\t{\n\t\t\t_ASSERTEX(gnPrevAnsiPart < 79);\n\t\t\tconst INT_PTR nCurPrevLen = gnPrevAnsiPart;\n\t\t\tconst INT_PTR nAdd = std::min((lpEnd-lpBuffer),static_cast<INT_PTR>(countof(gsPrevAnsiPart))-nCurPrevLen-1);\n\t\t\t// Need to check buffer overflow!!!\n\t\t\t_ASSERTEX(static_cast<INT_PTR>(countof(gsPrevAnsiPart)) > (nCurPrevLen + nAdd));\n\t\t\twmemcpy(gsPrevAnsiPart+nCurPrevLen, lpBuffer, nAdd);\n\t\t\tgsPrevAnsiPart[nCurPrevLen+nAdd] = 0;\n\n\t\t\tWARNING(\"\u041f\u0440\u043e\u0432\u0435\u0440\u0438\u0442\u044c!!!\");\n\t\t\tLPCWSTR lpReStart, lpReNext;\n\t\t\tconst int iCall = NextEscCode(gsPrevAnsiPart, gsPrevAnsiPart + nAdd + gnPrevAnsiPart, szPreDump, cchPrevPart, lpReStart, lpReNext, Code, TRUE);\n\t\t\tif (iCall == 1)\n\t\t\t{\n\t\t\t\tif ((lpReNext - gsPrevAnsiPart) >= gnPrevAnsiPart)\n\t\t\t\t{\n\t\t\t\t\t// Bypass unrecognized ESC sequences to screen?\n\t\t\t\t\tif (lpReStart > gsPrevAnsiPart)\n\t\t\t\t\t{\n\t\t\t\t\t\tconst INT_PTR nSkipLen = (lpReStart - gsPrevAnsiPart); //DWORD nWritten;\n\t\t\t\t\t\t_ASSERTEX(nSkipLen > 0 && nSkipLen <= static_cast<INT_PTR>(countof(gsPrevAnsiPart)) && nSkipLen <= gnPrevAnsiPart);\n\t\t\t\t\t\tDumpUnknownEscape(gsPrevAnsiPart, nSkipLen);\n\n\t\t\t\t\t\t//WriteText(writeConsoleW, hConsoleOutput, gsPrevAnsiPart, nSkipLen, &nWritten);\n\t\t\t\t\t\t_ASSERTEX(nSkipLen <= (static_cast<int>(CEAnsi_MaxPrevPart) - static_cast<int>(cchPrevPart)));\n\t\t\t\t\t\tmemmove(szPreDump, gsPrevAnsiPart, nSkipLen);\n\t\t\t\t\t\tcchPrevPart += static_cast<int>(nSkipLen);\n\n\t\t\t\t\t\tif (nSkipLen < gnPrevAnsiPart)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tmemmove(gsPrevAnsiPart, lpReStart, (gnPrevAnsiPart - nSkipLen)*sizeof(*gsPrevAnsiPart));\n\t\t\t\t\t\t\tgnPrevAnsiPart -= nSkipLen;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t_ASSERTEX(nSkipLen == gnPrevAnsiPart);\n\t\t\t\t\t\t\t*gsPrevAnsiPart = 0;\n\t\t\t\t\t\t\tgnPrevAnsiPart = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlpReStart = gsPrevAnsiPart;\n\t\t\t\t\t}\n\t\t\t\t\t_ASSERTEX(lpReStart == gsPrevAnsiPart);\n\t\t\t\t\tlpStart = lpBuffer; // nothing to dump before Esc-sequence\n\t\t\t\t\t_ASSERTEX((lpReNext - gsPrevAnsiPart) >= gnPrevAnsiPart);\n\t\t\t\t\tWARNING(\"\u041f\u0440\u043e\u0432\u0435\u0440\u0438\u0442\u044c!!!\");\n\t\t\t\t\tlpNext = lpBuffer + (lpReNext - gsPrevAnsiPart - gnPrevAnsiPart);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t_ASSERTEX((lpReNext - gsPrevAnsiPart) >= gnPrevAnsiPart);\n\t\t\t\t\tlpStart = lpNext = lpBuffer;\n\t\t\t\t}\n\t\t\t\tgnPrevAnsiPart = 0;\n\t\t\t\tgsPrevAnsiPart[0] = 0;\n\t\t\t\tiRc = 1;\n\t\t\t\tgoto wrap2;\n\t\t\t}\n\t\t\telse if (iCall == 2)\n\t\t\t{\n\t\t\t\tgnPrevAnsiPart = nCurPrevLen+nAdd;\n\t\t\t\t_ASSERTEX(gsPrevAnsiPart[nCurPrevLen+nAdd] == 0);\n\t\t\t\tiRc = 2;\n\t\t\t\tgoto wrap;\n\t\t\t}\n\n\t\t\t_ASSERTEX((iCall == 1) && \"Invalid esc sequence, need dump to screen?\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\t_ASSERTEX(*gsPrevAnsiPart == 27);\n\t\t}\n\t}\n\n\n\twhile (lpBuffer < lpEnd)\n\t{\n\t\tswitch (*lpBuffer)\n\t\t{\n\t\tcase 27:\n\t\t\t{\n\t\t\t\tINT_PTR nLeft;\n\t\t\t\t// ReSharper disable once CppLocalVariableMayBeConst\n\t\t\t\tLPCWSTR lpEscStart = lpBuffer;\n\n\t\t\t\t#ifdef _DEBUG\n\t\t\t\tCode.pszEscStart = lpBuffer;\n\t\t\t\tCode.nTotalLen = 0;\n\t\t\t\t#endif\n\n\t\t\t\t// Special one char codes? Like \"ESC 7\" and so on...\n\t\t\t\tif ((lpBuffer + 1) < lpEnd)\n\t\t\t\t{\n\t\t\t\t\t// But it may be some \"special\" codes\n\t\t\t\t\tswitch (lpBuffer[1])\n\t\t\t\t\t{\n\t\t\t\t\tcase L'7': // Save xterm cursor\n\t\t\t\t\tcase L'8': // Restore xterm cursor\n\t\t\t\t\tcase L'c': // Full reset\n\t\t\t\t\tcase L'g': // Visual Bell\n\t\t\t\t\tcase L'=':\n\t\t\t\t\tcase L'>':\n\t\t\t\t\tcase L'H': // Horizontal Tab Set\n\t\t\t\t\tcase L'M': // Reverse LF\n\t\t\t\t\tcase L'E': // CR-LF\n\t\t\t\t\tcase L'D': // LF\n\t\t\t\t\t\t// xterm?\n\t\t\t\t\t\tlpStart = lpEscStart;\n\t\t\t\t\t\tCode.First = 27;\n\t\t\t\t\t\tCode.Second = *(++lpBuffer);\n\t\t\t\t\t\tCode.ArgC = 0;\n\t\t\t\t\t\tCode.PvtLen = 0;\n\t\t\t\t\t\tCode.Pvt[0] = 0;\n\t\t\t\t\t\tlpEnd = (++lpBuffer);\n\t\t\t\t\t\tiRc = 1;\n\t\t\t\t\t\tgoto wrap;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// If tail is larger than 2 chars, continue\n\t\t\t\tif ((lpBuffer + 2) < lpEnd)\n\t\t\t\t{\n\t\t\t\t\t// Set lpSaveStart to current start of Esc sequence, it was set to beginning of buffer\n\t\t\t\t\t_ASSERTEX(lpSaveStart <= lpBuffer);\n\t\t\t\t\tlpSaveStart = lpBuffer;\n\t\t\t\t\t_ASSERTEX(lpSaveStart == lpEscStart);\n\n\t\t\t\t\tCode.First = 27;\n\t\t\t\t\tCode.Second = *(++lpBuffer);\n\t\t\t\t\tCode.ArgC = 0;\n\t\t\t\t\tCode.PvtLen = 0;\n\t\t\t\t\tCode.Pvt[0] = 0;\n\n\t\t\t\t\tTODO(\"Bypass unrecognized ESC sequences to screen? Don't try to eliminate 'Possible' sequences?\");\n\t\t\t\t\t//if (((Code.Second < 64) || (Code.Second > 95)) && (Code.Second != 124/* '|' - vim-xterm-emulation */))\n\t\t\t\t\tif (!wcschr(L\"[]|()%\", Code.Second))\n\t\t\t\t\t{\n\t\t\t\t\t\t// Don't assert on rawdump of KeyEvents.exe Esc key presses\n\t\t\t\t\t\t// 10:00:00 KEY_EVENT_RECORD: Dn, 1, Vk=\"VK_ESCAPE\" [27/0x001B], Scan=0x0001 uChar=[U='\\x1b' (0x001B): A='\\x1b' (0x1B)]\n\t\t\t\t\t\tconst bool bStandaloneEscChar = (lpStart < lpSaveStart) && ((*(lpSaveStart - 1) == L'\\'' && Code.Second == L'\\'') || (*(lpSaveStart - 1) == L' ' && Code.Second == L' '));\n\t\t\t\t\t\t//_ASSERTEX(bStandaloneEscChar && \"Unsupported control sequence?\");\n\t\t\t\t\t\tif (!bStandaloneEscChar)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, std::min<size_t>(Code.nTotalLen, 32), de_UnkControl);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue; // invalid code\n\t\t\t\t\t}\n\n\t\t\t\t\t// Now parameters go\n\t\t\t\t\t++lpBuffer; // move pointer to the first char beyond CSI (after '[')\n\n\t\t\t\t\tauto parseNumArgs = [&Code](const wchar_t* &lpBufferParam, const wchar_t* lpSeqEnd, bool saveAction) -> bool\n\t\t\t\t\t{\n\t\t\t\t\t\twchar_t wcSave;\n\t\t\t\t\t\tint nValue = 0, nDigits = 0;\n\t\t\t\t\t\tCode.ArgC = 0;\n\n\t\t\t\t\t\twhile (lpBufferParam < lpSeqEnd)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tswitch (*lpBufferParam)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcase L'0': case L'1': case L'2': case L'3': case L'4':\n\t\t\t\t\t\t\tcase L'5': case L'6': case L'7': case L'8': case L'9':\n\t\t\t\t\t\t\t\tnValue = (nValue * 10) + (static_cast<int>(*lpBufferParam) - L'0');\n\t\t\t\t\t\t\t\t++nDigits;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase L';':\n\t\t\t\t\t\t\t\t// Even if there were no digits - default is \"0\"\n\t\t\t\t\t\t\t\tif (Code.ArgC < static_cast<int>(countof(Code.ArgV)))\n\t\t\t\t\t\t\t\t\tCode.ArgV[Code.ArgC++] = nValue; // save argument\n\t\t\t\t\t\t\t\tnDigits = nValue = 0;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tif (Code.Second == L']')\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t// OSC specific, stop on first non-digit/non-semicolon\n\t\t\t\t\t\t\t\t\tif (nDigits && (Code.ArgC < static_cast<int>(countof(Code.ArgV))))\n\t\t\t\t\t\t\t\t\t\tCode.ArgV[Code.ArgC++] = nValue;\n\t\t\t\t\t\t\t\t\treturn (Code.ArgC > 0);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (((wcSave = *lpBufferParam) >= 64) && (wcSave <= 126))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t// Fin\n\t\t\t\t\t\t\t\t\tif (saveAction)\n\t\t\t\t\t\t\t\t\t\tCode.Action = wcSave;\n\t\t\t\t\t\t\t\t\tif (nDigits && (Code.ArgC < static_cast<int>(countof(Code.ArgV))))\n\t\t\t\t\t\t\t\t\t\tCode.ArgV[Code.ArgC++] = nValue;\n\t\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif ((static_cast<size_t>(Code.PvtLen) + 2) < countof(Code.Pvt))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tCode.Pvt[Code.PvtLen++] = wcSave; // Skip private symbols\n\t\t\t\t\t\t\t\t\tCode.Pvt[Code.PvtLen] = 0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t++lpBufferParam;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (nDigits && (Code.ArgC < static_cast<int>(countof(Code.ArgV))))\n\t\t\t\t\t\t\tCode.ArgV[Code.ArgC++] = nValue;\n\t\t\t\t\t\treturn (Code.Second == L']');\n\t\t\t\t\t};\n\n\t\t\t\t\tswitch (Code.Second)\n\t\t\t\t\t{\n\t\t\t\t\tcase L'(':\n\t\t\t\t\tcase L')':\n\t\t\t\t\tcase L'%':\n\t\t\t\t\t//case L'#':\n\t\t\t\t\t//case L'*':\n\t\t\t\t\t//case L'+':\n\t\t\t\t\t//case L'-':\n\t\t\t\t\t//case L'.':\n\t\t\t\t\t//case L'/':\n\t\t\t\t\t\t// VT G0/G1/G2/G3 character sets\n\t\t\t\t\t\tlpStart = lpSaveStart;\n\t\t\t\t\t\tCode.Action = *(lpBuffer++);\n\t\t\t\t\t\tCode.Skip = 0;\n\t\t\t\t\t\tCode.ArgSZ = nullptr;\n\t\t\t\t\t\tCode.cchArgSZ = 0;\n\t\t\t\t\t\tlpEnd = lpBuffer;\n\t\t\t\t\t\tiRc = 1;\n\t\t\t\t\t\tgoto wrap;\n\t\t\t\t\tcase L'|':\n\t\t\t\t\t\t// vim-xterm-emulation\n\t\t\t\t\tcase L'[':\n\t\t\t\t\t\t// Standard\n\t\t\t\t\t\tCode.Skip = 0;\n\t\t\t\t\t\tCode.ArgSZ = nullptr;\n\t\t\t\t\t\tCode.cchArgSZ = 0;\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t#ifdef _DEBUG\n\t\t\t\t\t\t\t// ReSharper disable once CppDeclaratorNeverUsed\n\t\t\t\t\t\t\tLPCWSTR pszSaveStart = lpBuffer;\n\t\t\t\t\t\t\t#endif\n\n\t\t\t\t\t\t\tif (parseNumArgs(lpBuffer, lpEnd, true))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tlpStart = lpSaveStart;\n\t\t\t\t\t\t\t\tlpEnd = lpBuffer+1;\n\t\t\t\t\t\t\t\tiRc = 1;\n\t\t\t\t\t\t\t\tgoto wrap;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// \u0412 \u0434\u0430\u043d\u043d\u043e\u043c \u0437\u0430\u043f\u0440\u043e\u0441\u0435 (\u043d\u0430 \u0437\u0430\u043f\u0438\u0441\u044c) \u043a\u043e\u043d\u0446\u0430 \u043f\u043e\u0441\u043b\u0435\u0434\u043e\u0432\u0430\u0442\u0435\u043b\u044c\u043d\u043e\u0441\u0442\u0438 \u043d\u0435\u0442,\n\t\t\t\t\t\t// \u043e\u0441\u0442\u0430\u0432\u0448\u0438\u0439\u0441\u044f \u0445\u0432\u043e\u0441\u0442 \u043d\u0443\u0436\u043d\u043e \u0441\u043e\u0445\u0440\u0430\u043d\u0438\u0442\u044c \u0432 \u0431\u0443\u0444\u0435\u0440\u0435, \u0434\u043b\u044f \u0441\u043b\u0435\u0434\u0443\u044e\u0449\u0435\u0433\u043e \u0437\u0430\u043f\u0440\u043e\u0441\u0430\n\t\t\t\t\t\t// \u041d\u0438\u0436\u0435\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase L']':\n\t\t\t\t\t\t// Finalizing (ST) with \"\\x1B\\\\\" or \"\\x07\"\n\t\t\t\t\t\t// \"%]4;16;rgb:00/00/00%\\\" - \"%\" is ESC\n\t\t\t\t\t\t// \"%]0;this is the window titleBEL\"\n\t\t\t\t\t\t// ESC ] 0 ; txt ST        Set icon name and window title to txt.\n\t\t\t\t\t\t// ESC ] 1 ; txt ST        Set icon name to txt.\n\t\t\t\t\t\t// ESC ] 2 ; txt ST        Set window title to txt.\n\t\t\t\t\t\t// ESC ] 4 ; num; txt ST   Set ANSI color num to txt.\n\t\t\t\t\t\t// ESC ] 10 ; txt ST       Set dynamic text color to txt.\n\t\t\t\t\t\t// ESC ] 4 6 ; name ST     Change log file to name (normally disabled\n\t\t\t\t\t\t//\t\t\t\t\t       by a compile-time option)\n\t\t\t\t\t\t// ESC ] 5 0 ; fn ST       Set font to fn.\n\t\t\t\t\t\t//Following 2 codes - from linux terminal\n\t\t\t\t\t\t// ESC ] P nrrggbb         Set palette, with parameter given in 7\n                        //                         hexadecimal digits after the final P :-(.\n\t\t\t\t\t\t//                         Here n is the color (0-15), and rrggbb indicates\n\t\t\t\t\t\t//                         the red/green/blue values (0-255).\n\t\t\t\t\t\t// ESC ] R                 reset palette\n\n\t\t\t\t\t\t// ConEmu specific\n\t\t\t\t\t\t// ESC ] 9 ; 1 ; ms ST           Sleep. ms - milliseconds\n\t\t\t\t\t\t// ESC ] 9 ; 2 ; \"txt\" ST        Show GUI MessageBox ( txt ) for dubug purposes\n\t\t\t\t\t\t// ESC ] 9 ; 3 ; \"txt\" ST        Set TAB text\n\t\t\t\t\t\t// ESC ] 9 ; 4 ; st ; pr ST      When _st_ is 0: remove progress. When _st_ is 1: set progress value to _pr_ (number, 0-100). When _st_ is 2: set error state in progress on Windows 7 taskbar\n\t\t\t\t\t\t// ESC ] 9 ; 5 ST                Wait for ENTER/SPACE/ESC. Set EnvVar \"ConEmuWaitKey\" to ENTER/SPACE/ESC on exit.\n\t\t\t\t\t\t// ESC ] 9 ; 6 ; \"txt\" ST        Execute GuiMacro. Set EnvVar \"ConEmuMacroResult\" on exit.\n\t\t\t\t\t\t// and others... look at CEAnsi::WriteAnsiCode_OSC\n\n\t\t\t\t\t\tCode.ArgSZ = lpBuffer;\n\t\t\t\t\t\tCode.cchArgSZ = 0;\n\t\t\t\t\t\t//Code.Skip = Code.Second;\n\n\t\t\t\t\t\twhile (lpBuffer < lpEnd)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif ((lpBuffer[0] == 7) ||\n\t\t\t\t\t\t\t\t(lpBuffer[0] == 27) /* we'll check the proper terminator below */)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tCode.Action = *Code.ArgSZ; // \u043f\u0435\u0440\u0432\u044b\u0439 \u0441\u0438\u043c\u0432\u043e\u043b \u043f\u043e\u0441\u043b\u0435\u0434\u043e\u0432\u0430\u0442\u0435\u043b\u044c\u043d\u043e\u0441\u0442\u0438\n\t\t\t\t\t\t\t\tCode.cchArgSZ = (lpBuffer - Code.ArgSZ);\n\t\t\t\t\t\t\t\tlpStart = lpSaveStart;\n\t\t\t\t\t\t\t\tconst wchar_t* lpBufferPtr = Code.ArgSZ;\n\t\t\t\t\t\t\t\tif (lpBuffer[0] == 27)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tif ((lpBuffer + 1) >= lpEnd)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t// Sequence is not complete yet!\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse if (lpBuffer[1] == L'\\\\')\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tlpEnd = lpBuffer + 2;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tlpEnd = lpBuffer - 1;\n\t\t\t\t\t\t\t\t\t\t_ASSERTE(*(lpEnd+1) == 27);\n\t\t\t\t\t\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t\t\t\t\t\t\t\t\tiRc = 0;\n\t\t\t\t\t\t\t\t\t\tgoto wrap;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tlpEnd = lpBuffer + 1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tparseNumArgs(lpBufferPtr, lpBuffer, false);\n\t\t\t\t\t\t\t\tiRc = 1;\n\t\t\t\t\t\t\t\tgoto wrap;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t++lpBuffer;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Sequence is not complete, we have to store it to concatenate\n\t\t\t\t\t\t// and check on future write call. Below.\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t// Unknown sequence, use common termination rules\n\t\t\t\t\t\tCode.Skip = Code.Second;\n\t\t\t\t\t\tCode.ArgSZ = lpBuffer;\n\t\t\t\t\t\tCode.cchArgSZ = 0;\n\t\t\t\t\t\twhile (lpBuffer < lpEnd)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// Terminator ASCII symbol: from `@` to `~`\n\t\t\t\t\t\t\tif (((wc = *lpBuffer) >= 64) && (wc <= 126))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tCode.Action = wc;\n\t\t\t\t\t\t\t\tlpStart = lpSaveStart;\n\t\t\t\t\t\t\t\tlpEnd = lpBuffer+1;\n\t\t\t\t\t\t\t\tiRc = 1;\n\t\t\t\t\t\t\t\tgoto wrap;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t++lpBuffer;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} // end of \"switch (Code.Second)\"\n\t\t\t\t} // end of minimal length check\n\n\t\t\t\tif ((nLeft = (lpEnd - lpEscStart)) <= CEAnsi_MaxPrevAnsiPart)\n\t\t\t\t{\n\t\t\t\t\tif (ReEntrance)\n\t\t\t\t\t{\n\t\t\t\t\t\t//_ASSERTEX(!ReEntrance && \"Need to be checked!\"); -- seems to be OK\n\n\t\t\t\t\t\t// gsPrevAnsiPart2 stored for debug purposes only (fully excess)\n\t\t\t\t\t\twmemmove(gsPrevAnsiPart2, lpEscStart, nLeft);\n\t\t\t\t\t\tgsPrevAnsiPart2[nLeft] = 0;\n\t\t\t\t\t\tgnPrevAnsiPart2 = nLeft;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\twmemmove(gsPrevAnsiPart, lpEscStart, nLeft);\n\t\t\t\t\t\tgsPrevAnsiPart[nLeft] = 0;\n\t\t\t\t\t\tgnPrevAnsiPart = nLeft;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t_ASSERTEX(FALSE && \"Too long Esc-sequence part, Need to be checked!\");\n\t\t\t\t}\n\n\t\t\t\tlpStart = lpEscStart;\n\n\t\t\t\tiRc = 2;\n\t\t\t\tgoto wrap;\n\t\t\t} // end of \"case 27:\"\n\t\t} // end of \"switch (*lpBuffer)\"\n\n\t\t++lpBuffer;\n\t} // end of \"while (lpBuffer < lpEnd)\"\n\nwrap:\n\tlpNext = lpEnd;\n\n\t#ifdef _DEBUG\n\tif (iRc == 1)\n\t\tCode.nTotalLen = (lpEnd - Code.pszEscStart);\n\t#endif\nwrap2:\n\t_ASSERTEX((iRc==0) || (lpStart>=lpSaveStart && lpStart<lpEnd));\n\treturn iRc;\n}\n\n// From the cursor position!\nBOOL CEAnsi::ScrollLine(HANDLE hConsoleOutput, int nDir)\n{\n\tExtScrollScreenParm scroll = {sizeof(scroll), essf_Current|essf_Commit, hConsoleOutput, nDir, {}, L' ', {}};\n\tconst BOOL lbRc = ExtScrollLine(&scroll);\n\treturn lbRc;\n}\n\nBOOL CEAnsi::ScrollScreen(HANDLE hConsoleOutput, const int nDir) const\n{\n\tauto srView = GetWorkingRegion(hConsoleOutput, true);\n\n\tif (gDisplayOpt.ScrollRegion)\n\t{\n\t\t_ASSERTEX(gDisplayOpt.ScrollStart >= 0 && gDisplayOpt.ScrollEnd >= gDisplayOpt.ScrollStart);\n\t\tsrView.Top = gDisplayOpt.ScrollStart;\n\t\tsrView.Bottom = gDisplayOpt.ScrollEnd;\n\t}\n\n\treturn ScrollScreen(hConsoleOutput, nDir, false , srView);\n}\n\nBOOL CEAnsi::ScrollScreen(HANDLE hConsoleOutput, const int nDir, bool global, const SMALL_RECT& scrollRect) const\n{\n\tExtScrollScreenParm scroll = {\n\t\tsizeof(scroll),\n\t\tessf_Current | essf_Commit | essf_Region | (global ? essf_Global : essf_None),\n\t\thConsoleOutput, nDir, {}, L' ',\n\t\tRECT{ scrollRect.Left, scrollRect.Top, scrollRect.Right, scrollRect.Bottom } };\n\n\tconst BOOL lbRc = ExtScrollScreen(&scroll);\n\n\treturn lbRc;\n}\n\nBOOL CEAnsi::FullReset(HANDLE hConsoleOutput) const\n{\n\tCONSOLE_SCREEN_BUFFER_INFO csbi = {};\n\tif (!GetConsoleScreenBufferInfoCached(hConsoleOutput, &csbi))\n\t\treturn FALSE;\n\n\tReSetDisplayParm(hConsoleOutput, TRUE, TRUE);\n\n\t// Easy way to drop all lines\n\tScrollScreen(hConsoleOutput, -csbi.dwSize.Y);\n\n\t// Reset cursor\n\tSetConsoleCursorPosition(hConsoleOutput, {});\n\n\t//TODO? Saved cursor position?\n\n\treturn TRUE;\n}\n\nBOOL CEAnsi::ForwardLF(HANDLE hConsoleOutput, BOOL& bApply)\n{\n\tCONSOLE_SCREEN_BUFFER_INFO csbi = {};\n\tif (!GetConsoleScreenBufferInfoCached(hConsoleOutput, &csbi))\n\t\treturn FALSE;\n\n\tif (bApply)\n\t{\n\t\tReSetDisplayParm(hConsoleOutput, FALSE, TRUE);\n\t\tbApply = FALSE;\n\t}\n\n\tif (csbi.dwCursorPosition.Y == (csbi.dwSize.Y - 1))\n\t{\n\t\tWriteText(pfnWriteConsoleW, hConsoleOutput, L\"\\n\", 1, nullptr);\n\t\tSetConsoleCursorPosition(hConsoleOutput, csbi.dwCursorPosition);\n\t}\n\telse if (csbi.dwCursorPosition.Y < (csbi.dwSize.Y - 1))\n\t{\n\t\tconst COORD cr = {csbi.dwCursorPosition.X, static_cast<SHORT>(csbi.dwCursorPosition.Y + 1)};\n\t\tSetConsoleCursorPosition(hConsoleOutput, cr);\n\t\tif (cr.Y > csbi.srWindow.Bottom)\n\t\t{\n\t\t\tSMALL_RECT rcNew = csbi.srWindow;\n\t\t\trcNew.Bottom = cr.Y;\n\t\t\trcNew.Top = cr.Y - (csbi.srWindow.Bottom - csbi.srWindow.Top);\n\t\t\t_ASSERTE(rcNew.Top >= 0);\n\t\t\tSetConsoleWindowInfo(hConsoleOutput, TRUE, &rcNew);\n\t\t}\n\t}\n\telse\n\t{\n\t\t_ASSERTE(csbi.dwCursorPosition.Y > 0);\n\t}\n\n\treturn TRUE;\n}\n\nBOOL CEAnsi::ReverseLF(HANDLE hConsoleOutput, BOOL& bApply) const\n{\n\tCONSOLE_SCREEN_BUFFER_INFO csbi = {};\n\tif (!GetConsoleScreenBufferInfoCached(hConsoleOutput, &csbi))\n\t\treturn FALSE;\n\n\tif (bApply)\n\t{\n\t\tReSetDisplayParm(hConsoleOutput, FALSE, TRUE);\n\t\tbApply = FALSE;\n\t}\n\n\tif ((csbi.dwCursorPosition.Y == csbi.srWindow.Top)\n\t\t|| (gDisplayOpt.ScrollRegion && csbi.dwCursorPosition.Y == gDisplayOpt.ScrollStart))\n\t{\n\t\tLinesInsert(hConsoleOutput, 1);\n\t}\n\telse if (csbi.dwCursorPosition.Y > 0)\n\t{\n\t\tconst COORD cr = {csbi.dwCursorPosition.X, static_cast<SHORT>(csbi.dwCursorPosition.Y - 1)};\n\t\tSetConsoleCursorPosition(hConsoleOutput, cr);\n\t}\n\telse\n\t{\n\t\t_ASSERTE(csbi.dwCursorPosition.Y > 0);\n\t}\n\n\treturn TRUE;\n}\n\nBOOL CEAnsi::LinesInsert(HANDLE hConsoleOutput, const unsigned linesCount) const\n{\n\tCONSOLE_SCREEN_BUFFER_INFO csbi = {};\n\tif (!GetConsoleScreenBufferInfoCached(hConsoleOutput, &csbi))\n\t{\n\t\t_ASSERTEX(FALSE && \"GetConsoleScreenBufferInfoCached failed\");\n\t\treturn FALSE;\n\t}\n\n\t// Apply default color before scrolling!\n\tReSetDisplayParm(hConsoleOutput, FALSE, TRUE);\n\n\tif (static_cast<int>(linesCount) <= 0)\n\t{\n\t\t_ASSERTEX(static_cast<int>(linesCount) >= 0);\n\t\treturn FALSE;\n\t}\n\n\tBOOL lbRc = FALSE;\n\n\tint TopLine, BottomLine;\n\tif (gDisplayOpt.ScrollRegion)\n\t{\n\t\t_ASSERTEX(gDisplayOpt.ScrollStart>=0 && gDisplayOpt.ScrollEnd>=gDisplayOpt.ScrollStart);\n\t\tif (csbi.dwCursorPosition.Y < gDisplayOpt.ScrollStart || csbi.dwCursorPosition.Y > gDisplayOpt.ScrollEnd)\n\t\t\treturn TRUE;\n\t\tTopLine = csbi.dwCursorPosition.Y;\n\t\tBottomLine = std::max<int>(gDisplayOpt.ScrollEnd, 0);\n\n\t\tif (static_cast<int>(linesCount) <= (BottomLine - TopLine))\n\t\t{\n\t\t\tExtScrollScreenParm scroll = {\n\t\t\t\tsizeof(scroll), essf_Current|essf_Commit|essf_Region, hConsoleOutput,\n\t\t\t\tstatic_cast<int>(linesCount), {}, L' ',\n\t\t\t\t// region to be scrolled (that is not a clipping region)\n\t\t\t\t{0, TopLine, csbi.dwSize.X - 1, BottomLine}};\n\t\t\tlbRc |= ExtScrollScreen(&scroll);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tExtFillOutputParm fill = {\n\t\t\t\tsizeof(fill), efof_Attribute|efof_Character, hConsoleOutput,\n\t\t\t\t{}, L' ', {0, MakeShort(TopLine)}, csbi.dwSize.X * linesCount};\n\t\t\tlbRc |= ExtFillOutput(&fill);\n\t\t}\n\t}\n\telse\n\t{\n\t\t// What we need to scroll? Buffer or visible rect?\n\t\tTopLine = csbi.dwCursorPosition.Y;\n\t\tBottomLine = (csbi.dwCursorPosition.Y <= csbi.srWindow.Bottom)\n\t\t\t? csbi.srWindow.Bottom\n\t\t\t: csbi.dwSize.Y - 1;\n\n\t\tExtScrollScreenParm scroll = {\n\t\t\tsizeof(scroll), essf_Current|essf_Commit|essf_Region, hConsoleOutput,\n\t\t\tstatic_cast<int>(linesCount), {}, L' ', {0, TopLine, csbi.dwSize.X-1, BottomLine}};\n\t\tlbRc |= ExtScrollScreen(&scroll);\n\t}\n\n\treturn lbRc;\n}\n\nBOOL CEAnsi::LinesDelete(HANDLE hConsoleOutput, const unsigned linesCount)\n{\n\tCONSOLE_SCREEN_BUFFER_INFO csbi = {};\n\tif (!GetConsoleScreenBufferInfoCached(hConsoleOutput, &csbi))\n\t{\n\t\t_ASSERTEX(FALSE && \"GetConsoleScreenBufferInfoCached failed\");\n\t\treturn FALSE;\n\t}\n\n\t// Apply default color before scrolling!\n\tReSetDisplayParm(hConsoleOutput, FALSE, TRUE);\n\n\tBOOL lbRc = FALSE;\n\n\tint TopLine, BottomLine;\n\tif (gDisplayOpt.ScrollRegion)\n\t{\n\t\t_ASSERTEX(gDisplayOpt.ScrollStart>=0 && gDisplayOpt.ScrollEnd>gDisplayOpt.ScrollStart);\n\t\t// ScrollStart & ScrollEnd are 0-based absolute line indexes\n\t\t// relative to VISIBLE area, these are not absolute buffer coords\n\t\tif (((csbi.dwCursorPosition.Y + static_cast<int>(linesCount)) <= gDisplayOpt.ScrollStart)\n\t\t\t|| (csbi.dwCursorPosition.Y > gDisplayOpt.ScrollEnd))\n\t\t{\n\t\t\treturn TRUE; // Nothing to scroll\n\t\t}\n\t\tTopLine = csbi.dwCursorPosition.Y;\n\t\tBottomLine = gDisplayOpt.ScrollEnd;\n\n\t\tconst int negateLinesCount = -static_cast<int>(linesCount);\n\t\tExtScrollScreenParm scrl = {\n\t\t\tsizeof(scrl), essf_Current | essf_Commit | essf_Region, hConsoleOutput,\n\t\t\tnegateLinesCount, {}, L' ', {0, TopLine, csbi.dwSize.X - 1, BottomLine} };\n\t\tif (scrl.Region.top < gDisplayOpt.ScrollStart)\n\t\t{\n\t\t\tscrl.Region.top = gDisplayOpt.ScrollStart;\n\t\t\tscrl.Dir += (gDisplayOpt.ScrollStart - TopLine);\n\t\t}\n\t\tif ((scrl.Dir < 0) && (scrl.Region.top <= scrl.Region.bottom))\n\t\t{\n\t\t\tlbRc |= ExtScrollScreen(&scrl);\n\t\t}\n\t}\n\telse\n\t{\n\t\t// What we need to scroll? Buffer or visible rect?\n\t\tTopLine = csbi.dwCursorPosition.Y;\n\t\tBottomLine = (csbi.dwCursorPosition.Y <= csbi.srWindow.Bottom)\n\t\t\t? csbi.srWindow.Bottom\n\t\t\t: csbi.dwSize.Y - 1;\n\n\t\tif (BottomLine < TopLine)\n\t\t{\n\t\t\t_ASSERTEX(FALSE && \"Invalid (empty) scroll region\");\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tconst int negateLinesCount = -static_cast<int>(linesCount);\n\t\tExtScrollScreenParm scrl = {\n\t\t\tsizeof(scrl), essf_Current | essf_Commit | essf_Region, hConsoleOutput,\n\t\t\tnegateLinesCount, {}, L' ', {0, TopLine, csbi.dwSize.X - 1, BottomLine} };\n\t\tlbRc |= ExtScrollScreen(&scrl);\n\t}\n\n\treturn lbRc;\n}\n\nint CEAnsi::NextNumber(LPCWSTR& asMS)\n{\n\twchar_t wc;\n\tint ms = 0;\n\twhile (((wc = *(asMS++)) >= L'0') && (wc <= L'9'))\n\t\tms = (ms * 10) + static_cast<int>(wc - L'0');\n\treturn ms;\n}\n\n// ESC ] 9 ; 1 ; ms ST           Sleep. ms - milliseconds\n// ReSharper disable once CppMemberFunctionMayBeStatic\nvoid CEAnsi::DoSleep(LPCWSTR asMS)\n{\n\tint ms = NextNumber(asMS);\n\tif (!ms)\n\t\tms = 100;\n\telse if (ms > 10000)\n\t\tms = 10000;\n\t// Delay\n\tSleep(ms);\n}\n\nvoid CEAnsi::EscCopyCtrlString(wchar_t* pszDst, LPCWSTR asMsg, INT_PTR cchMaxLen) const\n{\n\tif (!pszDst)\n\t{\n\t\t_ASSERTEX(pszDst!=nullptr);\n\t\treturn;\n\t}\n\n\tif (cchMaxLen < 0)\n\t{\n\t\t_ASSERTEX(cchMaxLen >= 0);\n\t\tcchMaxLen = 0;\n\t}\n\tif (cchMaxLen > 1)\n\t{\n\t\tif ((asMsg[0] == L'\"') && (asMsg[cchMaxLen-1] == L'\"'))\n\t\t{\n\t\t\tasMsg++;\n\t\t\tcchMaxLen -= 2;\n\t\t}\n\t}\n\n\tif (cchMaxLen > 0)\n\t\twmemmove(pszDst, asMsg, cchMaxLen);\n\tpszDst[std::max<ssize_t>(cchMaxLen, 0)] = 0;\n}\n\n// ESC ] 9 ; 2 ; \"txt\" ST          Show GUI MessageBox ( txt ) for dubug purposes\nvoid CEAnsi::DoMessage(LPCWSTR asMsg, INT_PTR cchLen) const\n{\n\tCEStr pszText;\n\n\tif (pszText.GetBuffer(cchLen))\n\t{\n\t\tEscCopyCtrlString(pszText.data(), asMsg, cchLen);\n\t\t//if (cchLen > 0)\n\t\t//\twmemmove(pszText, asMsg, cchLen);\n\t\t//pszText[cchLen] = 0;\n\n\t\twchar_t szExe[MAX_PATH] = {};\n\t\tGetModuleFileName(nullptr, szExe, countof(szExe));\n\t\twchar_t szTitle[MAX_PATH+64];\n\t\tmsprintf(szTitle, countof(szTitle), L\"PID=%u, %s\", GetCurrentProcessId(), PointToName(szExe));\n\n\t\tGuiMessageBox(ghConEmuWnd, pszText, szTitle, MB_ICONINFORMATION|MB_SYSTEMMODAL);\n\t}\n}\n\nbool CEAnsi::IsAnsiExecAllowed(LPCWSTR asCmd) const\n{\n\t// Invalid command or macro?\n\tif (!asCmd || !*asCmd)\n\t\treturn false;\n\n\t// We need to check settings\n\tCESERVER_CONSOLE_MAPPING_HDR* pMap = GetConMap();\n\tif (!pMap)\n\t\treturn false;\n\n\tif ((pMap->Flags & ConEmu::ConsoleFlags::AnsiExecAny))\n\t{\n\t\t// Allowed in any process\n\t}\n\telse if ((pMap->Flags & ConEmu::ConsoleFlags::AnsiExecCmd))\n\t{\n\t\t// Allowed in Cmd.exe only\n\t\tif (!gbIsCmdProcess)\n\t\t\treturn false;\n\t}\n\telse\n\t{\n\t\t// Disallowed everywhere\n\t\treturn false;\n\t}\n\n\t// Now we need to ask GUI, if the command (asCmd) is allowed\n\tbool bAllowed = false;\n\tconst INT_PTR cchLen = wcslen(asCmd) + 1;\n\tCESERVER_REQ* pOut = nullptr;\n\tCESERVER_REQ* pIn = ExecuteNewCmd(CECMD_ALLOWANSIEXEC, sizeof(CESERVER_REQ_HDR)+sizeof(wchar_t)*cchLen);\n\n\tif (pIn)\n\t{\n\t\t_ASSERTE(sizeof(pIn->wData[0])==sizeof(*asCmd));\n\t\tmemmove(pIn->wData, asCmd, cchLen*sizeof(pIn->wData[0]));\n\n\t\tpOut = ExecuteGuiCmd(ghConWnd, pIn, ghConWnd);\n\t\tif (pOut && (pOut->DataSize() == sizeof(pOut->dwData[0])))\n\t\t{\n\t\t\tbAllowed = (pOut->dwData[0] == TRUE);\n\t\t}\n\t}\n\n\tExecuteFreeResult(pOut);\n\tExecuteFreeResult(pIn);\n\n\treturn bAllowed;\n}\n\n// ESC ] 9 ; 6 ; \"macro\" ST        Execute some GuiMacro\nvoid CEAnsi::DoGuiMacro(LPCWSTR asCmd, INT_PTR cchLen) const\n{\n\tCESERVER_REQ* pOut = nullptr;\n\tCESERVER_REQ* pIn = ExecuteNewCmd(CECMD_GUIMACRO, sizeof(CESERVER_REQ_HDR)+sizeof(CESERVER_REQ_GUIMACRO)+sizeof(wchar_t)*(cchLen + 1));\n\n\tif (pIn)\n\t{\n\t\tEscCopyCtrlString(pIn->GuiMacro.sMacro, asCmd, cchLen);\n\n\t\tif (IsAnsiExecAllowed(pIn->GuiMacro.sMacro))\n\t\t{\n\t\t\tpOut = ExecuteGuiCmd(ghConWnd, pIn, ghConWnd);\n\t\t}\n\t}\n\n\t// EnvVar \"ConEmuMacroResult\"\n\tSetEnvironmentVariable(CEGUIMACRORETENVVAR, pOut && pOut->GuiMacro.nSucceeded ? pOut->GuiMacro.sMacro : nullptr);\n\n\tExecuteFreeResult(pOut);\n\tExecuteFreeResult(pIn);\n}\n\n// ESC ] 9 ; 7 ; \"cmd\" ST        Run some process with arguments\nvoid CEAnsi::DoProcess(LPCWSTR asCmd, INT_PTR cchLen) const\n{\n\t// We need zero-terminated string\n\tCEStr pszCmdLine;\n\n\tif (pszCmdLine.GetBuffer(cchLen))\n\t{\n\t\tEscCopyCtrlString(pszCmdLine.data(), asCmd, cchLen);\n\n\t\tif (IsAnsiExecAllowed(pszCmdLine))\n\t\t{\n\t\t\tSTARTUPINFO si{};\n\t\t\tsi.cb = sizeof(si);\n\t\t\tPROCESS_INFORMATION pi{};\n\n\t\t\tconst BOOL bCreated = OnCreateProcessW(\n\t\t\t\tnullptr, pszCmdLine.data(), nullptr, nullptr,\n\t\t\t\tFALSE, 0, nullptr, nullptr, &si, &pi);\n\t\t\tif (bCreated)\n\t\t\t{\n\t\t\t\tif (pi.hProcess)\n\t\t\t\t{\n\t\t\t\t\tWaitForSingleObject(pi.hProcess, INFINITE);\n\t\t\t\t\tCloseHandle(pi.hProcess);\n\t\t\t\t}\n\t\t\t\tif (pi.hThread)\n\t\t\t\t{\n\t\t\t\t\tCloseHandle(pi.hThread);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// ESC ] 9 ; 8 ; \"env\" ST        Output value of environment variable\nvoid CEAnsi::DoPrintEnv(LPCWSTR asCmd, INT_PTR cchLen)\n{\n\tif (!pfnWriteConsoleW)\n\t\treturn;\n\n\t// We need zero-terminated string\n\tCEStr pszVarName;\n\n\tif (pszVarName.GetBuffer(cchLen))\n\t{\n\t\tEscCopyCtrlString(pszVarName.data(), asCmd, cchLen);\n\n\t\twchar_t szValue[MAX_PATH];\n\t\twchar_t* pszValue = szValue;\n\t\tCEStr valueBuffer;\n\t\tDWORD cchMax = countof(szValue);\n\t\tDWORD nMax = GetEnvironmentVariable(pszVarName, pszValue, cchMax);\n\n\t\t// Some predefined as `time`, `date`, `cd`, ...\n\t\tif (!nMax)\n\t\t{\n\t\t\tif ((lstrcmpi(pszVarName, L\"date\") == 0)\n\t\t\t\t|| (lstrcmpi(pszVarName, L\"time\") == 0))\n\t\t\t{\n\t\t\t\tSYSTEMTIME st = {}; GetLocalTime(&st);\n\t\t\t\tif (lstrcmpi(pszVarName, L\"date\") == 0)\n\t\t\t\t\tswprintf_c(szValue, L\"%u-%02u-%02u\", st.wYear, st.wMonth, st.wDay);\n\t\t\t\telse\n\t\t\t\t\tswprintf_c(szValue, L\"%u:%02u:%02u.%03u\", st.wHour, st.wMinute, st.wSecond, st.wMilliseconds);\n\t\t\t\tnMax = lstrlen(szValue);\n\t\t\t}\n\t\t\t#if 0\n\t\t\telse if (lstrcmpi(pszVarName, L\"cd\") == 0)\n\t\t\t{\n\t\t\t\t//TODO: If possible\n\t\t\t}\n\t\t\t#endif\n\t\t}\n\n\t\tif (nMax >= cchMax)\n\t\t{\n\t\t\tcchMax = nMax+1;\n\t\t\tpszValue = valueBuffer.GetBuffer(cchMax);\n\t\t\tnMax = pszValue ? GetEnvironmentVariable(pszVarName, szValue, countof(szValue)) : 0;\n\t\t}\n\n\t\tif (nMax)\n\t\t{\n\t\t\tTODO(\"Process here ANSI colors TOO! But now it will be 'reentrance'?\");\n\t\t\tWriteText(pfnWriteConsoleW, mh_WriteOutput, pszValue, nMax, &cchMax);\n\t\t}\n\t}\n}\n\n// ESC ] 9 ; 9 ; \"cwd\" ST        Inform ConEmu about shell current working directory\nvoid CEAnsi::DoSendCWD(LPCWSTR asCmd, INT_PTR cchLen) const\n{\n\t// We need zero-terminated string\n\tCEStr pszCWD;\n\n\tif (pszCWD.GetBuffer(cchLen))\n\t{\n\t\tEscCopyCtrlString(pszCWD.data(), asCmd, cchLen);\n\n\t\t// Sends CECMD_STORECURDIR into RConServer\n\t\tSendCurrentDirectory(ghConWnd, pszCWD);\n\t}\n}\n\n\n// ReSharper disable once CppMemberFunctionMayBeStatic\nBOOL CEAnsi::ReportString(LPCWSTR asRet)\n{\n\tif (!asRet || !*asRet)\n\t\treturn FALSE;\n\tINPUT_RECORD ir[16] = {};\n\tconst size_t nLen = wcslen(asRet);\n\tif (nLen > std::numeric_limits<DWORD>::max())\n\t\treturn false;\n\tINPUT_RECORD* pir = (nLen <= static_cast<int>(countof(ir))) ? ir : static_cast<INPUT_RECORD*>(calloc(nLen, sizeof(INPUT_RECORD)));\n\tif (!pir)\n\t\treturn FALSE;\n\n\tINPUT_RECORD* p = pir;\n\tLPCWSTR pc = asRet;\n\tfor (size_t i = 0; i < nLen; i++, p++, pc++)\n\t{\n\t\tconst char ch = (*pc == 0x1B || *pc >= 0x20) ? *pc : L' ';\n\t\tp->EventType = KEY_EVENT;\n\t\tp->Event.KeyEvent.bKeyDown = TRUE;\n\t\tp->Event.KeyEvent.wRepeatCount = 1;\n\t\tp->Event.KeyEvent.uChar.UnicodeChar = ch;\n\t}\n\n\tDumpKnownEscape(asRet, nLen, de_Report);\n\n\tDWORD nWritten = 0;\n\t// ReSharper disable once CppLocalVariableMayBeConst\n\tHANDLE hIn = GetStdHandle(STD_INPUT_HANDLE);\n\tconst BOOL bSuccess = WriteConsoleInput(hIn, pir, static_cast<DWORD>(nLen), &nWritten) && (nWritten == nLen);\n\n\tif (pir != ir)\n\t\tfree(pir);\n\treturn bSuccess;\n}\n\nvoid CEAnsi::ReportConsoleTitle()\n{\n\twchar_t sTitle[MAX_PATH*2+6] = L\"\\x1B]l\";\n\twchar_t* p = sTitle+3;\n\t_ASSERTEX(lstrlen(sTitle)==3);\n\n\tconst DWORD nTitle = GetConsoleTitle(sTitle+3, MAX_PATH*2);\n\tp = sTitle + 3 + std::min<DWORD>(nTitle, MAX_PATH*2);\n\t*(p++) = L'\\x1B';\n\t*(p++) = L'\\\\';\n\t*(p) = 0;\n\n\tReportString(sTitle);\n}\n\nvoid CEAnsi::ReportTerminalPixelSize()\n{\n\t// `CSI 4 ; height ; width t`\n\twchar_t szReport[64];\n\tint width = 0, height = 0;\n\tRECT rcWnd = {};\n\tCONSOLE_SCREEN_BUFFER_INFO csbi = {};\n\n\tif (ghConEmuWndDC && GetClientRect(ghConEmuWndDC, &rcWnd))\n\t{\n\t\twidth = RectWidth(rcWnd);\n\t\theight = RectHeight(rcWnd);\n\t}\n\n\tif ((width <= 0 || height <= 0) && ghConWnd && GetClientRect(ghConWnd, &rcWnd))\n\t{\n\t\twidth = RectWidth(rcWnd);\n\t\theight = RectHeight(rcWnd);\n\t}\n\n\tif (width <= 0 || height <= 0)\n\t{\n\t\t_ASSERTE(width > 0 && height > 0);\n\t\t// Both DC and RealConsole windows were failed?\n\t\tif (GetConsoleScreenBufferInfoCached(GetStdHandle(STD_OUTPUT_HANDLE), &csbi))\n\t\t{\n\t\t\tconst int defCharWidth = 8, defCharHeight = 14;\n\t\t\twidth = (csbi.srWindow.Right - csbi.srWindow.Left + 1) * defCharWidth;\n\t\t\theight = (csbi.srWindow.Bottom - csbi.srWindow.Top + 1) * defCharHeight;\n\t\t}\n\t}\n\n\tif (width > 0 && height > 0)\n\t{\n\t\tswprintf_c(szReport, L\"\\x1B[4;%u;%ut\", static_cast<uint32_t>(height), static_cast<uint32_t>(width));\n\t\tReportString(szReport);\n\t}\n}\n\nvoid CEAnsi::ReportTerminalCharSize(HANDLE hConsoleOutput, int code)\n{\n\tCONSOLE_SCREEN_BUFFER_INFO csbi = {};\n\tif (GetConsoleScreenBufferInfoCached(hConsoleOutput, &csbi))\n\t{\n\t\twchar_t sCurInfo[64];\n\t\tmsprintf(sCurInfo, countof(sCurInfo),\n\t\t\tL\"\\x1B[%u;%u;%ut\",\n\t\t\tcode == 18 ? 8 : 9,\n\t\t\tcsbi.srWindow.Bottom-csbi.srWindow.Top+1, csbi.srWindow.Right-csbi.srWindow.Left+1);\n\t\tReportString(sCurInfo);\n\t}\n}\n\nvoid CEAnsi::ReportCursorPosition(HANDLE hConsoleOutput)\n{\n\tCONSOLE_SCREEN_BUFFER_INFO csbi = {};\n\tif (GetConsoleScreenBufferInfoCached(hConsoleOutput, &csbi))\n\t{\n\t\twchar_t sCurInfo[32];\n\t\tmsprintf(sCurInfo, countof(sCurInfo),\n\t\t\tL\"\\x1B[%u;%uR\",\n\t\t\tcsbi.dwCursorPosition.Y-csbi.srWindow.Top+1, csbi.dwCursorPosition.X-csbi.srWindow.Left+1);\n\t\tReportString(sCurInfo);\n\t}\n}\n\nBOOL CEAnsi::WriteAnsiCodes(OnWriteConsoleW_t writeConsoleW, HANDLE hConsoleOutput, LPCWSTR lpBuffer, DWORD nNumberOfCharsToWrite, LPDWORD lpNumberOfCharsWritten)\n{\n\tBOOL lbRc = TRUE, lbApply = FALSE;\n\t// ReSharper disable once CppLocalVariableMayBeConst\n\tLPCWSTR lpEnd = (lpBuffer + nNumberOfCharsToWrite);\n\tAnsiEscCode Code = {};\n\twchar_t szPreDump[CEAnsi_MaxPrevPart];\n\t// ReSharper disable once CppJoinDeclarationAndAssignment\n\tDWORD cchPrevPart;\n\n\tReloadFeatures();\n\n\t// Store this pointer\n\tpfnWriteConsoleW = writeConsoleW;\n\t// Ans current output handle\n\tmh_WriteOutput = hConsoleOutput;\n\n\t//ExtWriteTextParm write = {sizeof(write), ewtf_Current, hConsoleOutput};\n\t//write.Private = writeConsoleW;\n\n\twhile (lpBuffer < lpEnd)\n\t{\n\t\tLPCWSTR lpStart = nullptr, lpNext = nullptr; // Required to be nullptr-initialized\n\n\t\t// '^' is ESC\n\t\t// ^[0;31;47m   $E[31;47m   ^[0m ^[0;1;31;47m  $E[1;31;47m  ^[0m\n\n\t\tcchPrevPart = 0;\n\n\t\tconst int iEsc = NextEscCode(lpBuffer, lpEnd, szPreDump, cchPrevPart, lpStart, lpNext, Code);\n\n\t\tif (cchPrevPart)\n\t\t{\n\t\t\tif (lbApply)\n\t\t\t{\n\t\t\t\tReSetDisplayParm(hConsoleOutput, FALSE, TRUE);\n\t\t\t\tlbApply = FALSE;\n\t\t\t}\n\n\t\t\tlbRc = WriteText(writeConsoleW, hConsoleOutput, szPreDump, cchPrevPart, lpNumberOfCharsWritten);\n\t\t\tif (!lbRc)\n\t\t\t\tgoto wrap;\n\t\t}\n\n\t\tif (iEsc != 0)\n\t\t{\n\t\t\tif (lpStart > lpBuffer)\n\t\t\t{\n\t\t\t\t_ASSERTEX((lpStart-lpBuffer) < static_cast<INT_PTR>(nNumberOfCharsToWrite));\n\n\t\t\t\tif (lbApply)\n\t\t\t\t{\n\t\t\t\t\tReSetDisplayParm(hConsoleOutput, FALSE, TRUE);\n\t\t\t\t\tlbApply = FALSE;\n\t\t\t\t}\n\n\t\t\t\tconst DWORD nWrite = static_cast<DWORD>(lpStart - lpBuffer);\n\t\t\t\t//lbRc = WriteText(writeConsoleW, hConsoleOutput, lpBuffer, nWrite, lpNumberOfCharsWritten);\n\t\t\t\tlbRc = WriteText(writeConsoleW, hConsoleOutput, lpBuffer, nWrite, lpNumberOfCharsWritten, FALSE);\n\t\t\t\tif (!lbRc)\n\t\t\t\t\tgoto wrap;\n\t\t\t\t//write.Buffer = lpBuffer;\n\t\t\t\t//write.NumberOfCharsToWrite = nWrite;\n\t\t\t\t//lbRc = ExtWriteText(&write);\n\t\t\t\t//if (!lbRc)\n\t\t\t\t//\tgoto wrap;\n\t\t\t\t//else\n\t\t\t\t//{\n\t\t\t\t//\tif (lpNumberOfCharsWritten)\n\t\t\t\t//\t\t*lpNumberOfCharsWritten = write.NumberOfCharsWritten;\n\t\t\t\t//\tif (write.ScrolledRowsUp > 0)\n\t\t\t\t//\t\tgDisplayCursor.StoredCursorPos.Y = std::max(0,((int)gDisplayCursor.StoredCursorPos.Y - (int)write.ScrolledRowsUp));\n\t\t\t\t//}\n\t\t\t}\n\n\t\t\tif (iEsc == 1)\n\t\t\t{\n\t\t\t\tif (Code.Skip)\n\t\t\t\t{\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tswitch (Code.Second)\n\t\t\t\t\t{\n\t\t\t\t\tcase L'[':\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlbApply = TRUE;\n\t\t\t\t\t\t\tWriteAnsiCode_CSI(writeConsoleW, hConsoleOutput, Code, lbApply);\n\n\t\t\t\t\t\t} // case L'[':\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase L']':\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlbApply = TRUE;\n\t\t\t\t\t\t\tWriteAnsiCode_OSC(writeConsoleW, hConsoleOutput, Code, lbApply);\n\n\t\t\t\t\t\t} // case L']':\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase L'|':\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// vim-xterm-emulation\n\t\t\t\t\t\t\tlbApply = TRUE;\n\t\t\t\t\t\t\tWriteAnsiCode_VIM(writeConsoleW, hConsoleOutput, Code, lbApply);\n\t\t\t\t\t\t} // case L'|':\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase L'7':\n\t\t\t\t\tcase L'8':\n\t\t\t\t\t\t//TODO: 7 - Save Cursor and _Attributes_\n\t\t\t\t\t\t//TODO: 8 - Restore Cursor and _Attributes_\n\t\t\t\t\t\tXTermSaveRestoreCursor((Code.Second == L'7'), hConsoleOutput);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase L'c':\n\t\t\t\t\t\t// Full reset\n\t\t\t\t\t\tFullReset(hConsoleOutput);\n\t\t\t\t\t\tlbApply = FALSE;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase L'g':\n\t\t\t\t\t\t// User may disable flashing in ConEmu settings\n\t\t\t\t\t\tGuiFlashWindow(eFlashBeep, ghConWnd, FALSE, FLASHW_ALL, 1, 0);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase L'H':\n\t\t\t\t\t\t// #ANSI gh-1827: support 'H' to set tab stops\n\t\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase L'M':\n\t\t\t\t\t\tReverseLF(hConsoleOutput, lbApply);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase L'E':\n\t\t\t\t\t\tWriteText(writeConsoleW, hConsoleOutput, L\"\\r\\n\", 2, nullptr);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase L'D':\n\t\t\t\t\t\tForwardLF(hConsoleOutput, lbApply);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase L'=':\n\t\t\t\t\tcase L'>':\n\t\t\t\t\t\t// xterm \"ESC =\" - Application Keypad (DECKPAM)\n\t\t\t\t\t\t// xterm \"ESC >\" - Normal Keypad (DECKPNM)\n\t\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase L'(':\n\t\t\t\t\t\t// xterm G0..G3?\n\t\t\t\t\t\tswitch (Code.Action)\n\t\t\t\t\t\t{\n\t\t\t\t\t\tcase L'0':\n\t\t\t\t\t\t\tmCharSet = VTCS_DRAWING;\n\t\t\t\t\t\t\t//DumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Comment);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase L'B':\n\t\t\t\t\t\t\tmCharSet = VTCS_DEFAULT;\n\t\t\t\t\t\t\t//DumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Comment);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tmCharSet = VTCS_DEFAULT;\n\t\t\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse //if (iEsc != 2) // 2 - means \"Esc part stored in buffer\"\n\t\t{\n\t\t\t_ASSERTEX(iEsc == 0);\n\t\t\tif (lpNext > lpBuffer)\n\t\t\t{\n\t\t\t\tif (lbApply)\n\t\t\t\t{\n\t\t\t\t\tReSetDisplayParm(hConsoleOutput, FALSE, TRUE);\n\t\t\t\t\tlbApply = FALSE;\n\t\t\t\t}\n\n\t\t\t\tconst DWORD nWrite = static_cast<DWORD>(lpNext - lpBuffer);\n\t\t\t\t//lbRc = WriteText(writeConsoleW, hConsoleOutput, lpBuffer, nWrite, lpNumberOfCharsWritten);\n\t\t\t\tlbRc = WriteText(writeConsoleW, hConsoleOutput, lpBuffer, nWrite, lpNumberOfCharsWritten);\n\t\t\t\tif (!lbRc)\n\t\t\t\t\tgoto wrap;\n\t\t\t\t//write.Buffer = lpBuffer;\n\t\t\t\t//write.NumberOfCharsToWrite = nWrite;\n\t\t\t\t//lbRc = ExtWriteText(&write);\n\t\t\t\t//if (!lbRc)\n\t\t\t\t//\tgoto wrap;\n\t\t\t\t//else\n\t\t\t\t//{\n\t\t\t\t//\tif (lpNumberOfCharsWritten)\n\t\t\t\t//\t\t*lpNumberOfCharsWritten = write.NumberOfCharsWritten;\n\t\t\t\t//\tif (write.ScrolledRowsUp > 0)\n\t\t\t\t//\t\tgDisplayCursor.StoredCursorPos.Y = std::max(0,((int)gDisplayCursor.StoredCursorPos.Y - (int)write.ScrolledRowsUp));\n\t\t\t\t//}\n\t\t\t}\n\t\t}\n\n\t\tif (lpNext > lpBuffer)\n\t\t{\n\t\t\tlpBuffer = lpNext;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t_ASSERTEX(lpNext > lpBuffer || lpNext == nullptr);\n\t\t\t++lpBuffer;\n\t\t}\n\t}\n\n\tif (lbRc && lpNumberOfCharsWritten)\n\t\t*lpNumberOfCharsWritten = nNumberOfCharsToWrite;\n\nwrap:\n\tif (lbApply)\n\t{\n\t\tReSetDisplayParm(hConsoleOutput, FALSE, TRUE);\n\t\tlbApply = FALSE;\n\t}\n\treturn lbRc;\n}\n\nvoid CEAnsi::WriteAnsiCode_CSI(OnWriteConsoleW_t writeConsoleW, HANDLE& hConsoleOutput, AnsiEscCode& Code, BOOL& lbApply)\n{\n\t/*\n\nCSI ? P m h\t\t\tDEC Private Mode Set (DECSET)\n\tP s = 4 7 \u2192 Use Alternate Screen Buffer (unless disabled by the titeInhibit resource)\n\tP s = 1 0 4 7 \u2192 Use Alternate Screen Buffer (unless disabled by the titeInhibit resource)\n\tP s = 1 0 4 8 \u2192 Save cursor as in DECSC (unless disabled by the titeInhibit resource)\n\tP s = 1 0 4 9 \u2192 Save cursor as in DECSC and use Alternate Screen Buffer, clearing it first (unless disabled by the titeInhibit resource). This combines the effects of the 1 0 4 7 and 1 0 4 8 modes. Use this with terminfo-based applications rather than the 4 7 mode.\n\nCSI ? P m l\t\t\tDEC Private Mode Reset (DECRST)\n\tP s = 4 7 \u2192 Use Normal Screen Buffer\n\tP s = 1 0 4 7 \u2192 Use Normal Screen Buffer, clearing screen first if in the Alternate Screen (unless disabled by the titeInhibit resource)\n\tP s = 1 0 4 8 \u2192 Restore cursor as in DECRC (unless disabled by the titeInhibit resource)\n\tP s = 1 0 4 9 \u2192 Use Normal Screen Buffer and restore cursor as in DECRC (unless disabled by the titeInhibit resource). This combines the effects of the 1 0 4 7 and 1 0 4 8 modes. Use this with terminfo-based applications rather than the 4 7 mode.\n\n\nCSI P s @\t\t\tInsert P s (Blank) Character(s) (default = 1) (ICH)\n\n\t*/\n\tCONSOLE_SCREEN_BUFFER_INFO csbi = {};\n\n\tswitch (Code.Action) // case sensitive\n\t{\n\tcase L's':\n\t\t// Save cursor position (can not be nested)\n\t\tXTermSaveRestoreCursor(true, hConsoleOutput);\n\t\tbreak;\n\n\tcase L'u':\n\t\t// Restore cursor position\n\t\tXTermSaveRestoreCursor(false, hConsoleOutput);\n\t\tbreak;\n\n\tcase L'H': // Set cursor position (1-based)\n\tcase L'f': // Same as 'H'\n\tcase L'A': // Cursor up by N rows\n\tcase L'B': // Cursor down by N rows\n\tcase L'C': // Cursor right by N cols\n\tcase L'D': // Cursor left by N cols\n\tcase L'E': // Moves cursor to beginning of the line n (default 1) lines down.\n\tcase L'F': // Moves cursor to beginning of the line n (default 1) lines up.\n\tcase L'G': // Moves the cursor to column n.\n\tcase L'd': // Moves the cursor to line n.\n\t\t// Change cursor position\n\t\tif (GetConsoleScreenBufferInfoCached(hConsoleOutput, &csbi))\n\t\t{\n\t\t\tstruct PointXY {int X,Y;};\n\t\t\tauto get_scroll_region = [&csbi]()\n\t\t\t{\n\t\t\t\tconst auto& srw = csbi.srWindow;\n\t\t\t\tSMALL_RECT clipRgn = MakeSmallRect(0, 0, srw.Right - srw.Left, srw.Bottom - srw.Top);\n\t\t\t\tif (gDisplayOpt.ScrollRegion)\n\t\t\t\t{\n\t\t\t\t\tclipRgn.Top = std::max<SHORT>(0, std::min<SHORT>(gDisplayOpt.ScrollStart, csbi.dwSize.Y-1));\n\t\t\t\t\tclipRgn.Bottom = std::max<SHORT>(0, std::min<SHORT>(gDisplayOpt.ScrollEnd, csbi.dwSize.Y-1));\n\t\t\t\t}\n\t\t\t\treturn clipRgn;\n\t\t\t};\n\t\t\tauto get_cursor = [&csbi]()\n\t\t\t{\n\t\t\t\tconst auto& srw = csbi.srWindow;\n\t\t\t\tconst int visible_rows = srw.Bottom - srw.Top;\n\t\t\t\treturn PointXY{\n\t\t\t\t\tcsbi.dwCursorPosition.X,\n\t\t\t\t\tstd::max(0, std::min(visible_rows, csbi.dwCursorPosition.Y - srw.Top))\n\t\t\t\t};\n\t\t\t};\n\t\t\tconst struct {int left, top, right, bottom;} workRgn = {0, 0, csbi.dwSize.X - 1, csbi.dwSize.Y - 1};\n\t\t\t_ASSERTEX(workRgn.left <= workRgn.right && workRgn.top <= workRgn.bottom);\n\t\t\tconst auto& clipRgn = get_scroll_region();\n\t\t\tconst auto cur = get_cursor();\n\t\t\tPointXY crNewPos = cur;\n\n\t\t\tenum class Direction { kAbsolute, kCompatible, kRelative };\n\n\t\t\tauto set_y = [&crNewPos, &workRgn, &clipRgn, &cur](Direction direction, int value)\n\t\t\t{\n\t\t\t\tconst int kLegacyY = 9999;\n\t\t\t\tif (direction == Direction::kCompatible && value >= std::min(kLegacyY, workRgn.bottom))\n\t\t\t\t\t// #XTERM_256 Allow to put cursor into the legacy true-color area\n\t\t\t\t\tcrNewPos.Y = workRgn.bottom;\n\t\t\t\telse if (direction == Direction::kAbsolute || direction == Direction::kCompatible)\n\t\t\t\t\tcrNewPos.Y = std::max(workRgn.top, std::min(workRgn.bottom, value));\n\t\t\t\telse if (value < 0 && cur.Y >= clipRgn.Top)\n\t\t\t\t\tcrNewPos.Y = std::max<int>(clipRgn.Top, std::min(workRgn.bottom, cur.Y + value));\n\t\t\t\telse if (value > 0 && cur.Y <= clipRgn.Bottom)\n\t\t\t\t\tcrNewPos.Y = std::max(workRgn.top, std::min<int>(clipRgn.Bottom, cur.Y + value));\n\t\t\t\telse\n\t\t\t\t\tcrNewPos.Y = std::max(workRgn.top, std::min(workRgn.bottom, cur.Y + value));\n\t\t\t};\n\t\t\tauto set_x = [&crNewPos, &workRgn, &cur](Direction direction, int value)\n\t\t\t{\n\t\t\t\tif (direction == Direction::kAbsolute || direction == Direction::kCompatible)\n\t\t\t\t\tcrNewPos.X = std::max(workRgn.left, std::min(workRgn.right, value));\n\t\t\t\telse\n\t\t\t\t\tcrNewPos.X = std::max(workRgn.left, std::min(workRgn.right, cur.X + value));\n\t\t\t};\n\n\t\t\tswitch (Code.Action)\n\t\t\t{\n\t\t\tcase L'H':\n\t\t\t\t// Set cursor position (ANSI values are 1-based)\n\t\t\t\tset_y(Direction::kCompatible, (Code.ArgC > 0 && Code.ArgV[0]) ? (Code.ArgV[0] - 1) : 0);\n\t\t\t\tset_x(Direction::kAbsolute, (Code.ArgC > 1 && Code.ArgV[1]) ? (Code.ArgV[1] - 1) : 0);\n\t\t\t\tbreak;\n\t\t\tcase L'f':\n\t\t\t\t// Set cursor position (ANSI values are 1-based)\n\t\t\t\tset_y(Direction::kAbsolute, (Code.ArgC > 0 && Code.ArgV[0]) ? (Code.ArgV[0] - 1) : 0);\n\t\t\t\tset_x(Direction::kAbsolute, (Code.ArgC > 1 && Code.ArgV[1]) ? (Code.ArgV[1] - 1) : 0);\n\t\t\t\tbreak;\n\t\t\tcase L'A':\n\t\t\t\t// Cursor up by N rows\n\t\t\t\tset_y(Direction::kRelative, -((Code.ArgC > 0 && Code.ArgV[0]) ? Code.ArgV[0] : 1));\n\t\t\t\tbreak;\n\t\t\tcase L'B':\n\t\t\t\t// Cursor down by N rows\n\t\t\t\tset_y(Direction::kRelative, +((Code.ArgC > 0 && Code.ArgV[0]) ? Code.ArgV[0] : 1));\n\t\t\t\tbreak;\n\t\t\tcase L'C':\n\t\t\t\t// Cursor right by N cols\n\t\t\t\tset_x(Direction::kRelative, +((Code.ArgC > 0 && Code.ArgV[0]) ? Code.ArgV[0] : 1));\n\t\t\t\tbreak;\n\t\t\tcase L'D':\n\t\t\t\t// Cursor left by N cols\n\t\t\t\tset_x(Direction::kRelative, -((Code.ArgC > 0 && Code.ArgV[0]) ? Code.ArgV[0] : 1));\n\t\t\t\tbreak;\n\t\t\tcase L'E':\n\t\t\t\t// Moves cursor to beginning of the line n (default 1) lines down.\n\t\t\t\tset_y(Direction::kRelative, +((Code.ArgC > 0 && Code.ArgV[0]) ? Code.ArgV[0] : 1));\n\t\t\t\tset_x(Direction::kAbsolute, 0);\n\t\t\t\tbreak;\n\t\t\tcase L'F':\n\t\t\t\t// Moves cursor to beginning of the line n (default 1) lines up.\n\t\t\t\tset_y(Direction::kRelative, -((Code.ArgC > 0 && Code.ArgV[0]) ? Code.ArgV[0] : 1));\n\t\t\t\tset_x(Direction::kAbsolute, 0);\n\t\t\t\tbreak;\n\t\t\tcase L'G':\n\t\t\t\t// Moves the cursor to column n.\n\t\t\t\tset_x(Direction::kAbsolute, (Code.ArgC > 0) ? (Code.ArgV[0] - 1) : 0);\n\t\t\t\tbreak;\n\t\t\tcase L'd':\n\t\t\t\t// Moves the cursor to line n (almost the same as 'H', but leave X unchanged).\n\t\t\t\tset_y(Direction::kAbsolute, (Code.ArgC > 0) ? (Code.ArgV[0] - 1) : 0);\n\t\t\t\tbreak;\n\t\t\t#ifdef _DEBUG\n\t\t\tdefault:\n\t\t\t\t_ASSERTEX(FALSE && \"Missed (sub)case value!\");\n\t\t\t#endif\n\t\t\t}\n\n\t\t\t// Goto\n\t\t\tORIGINAL_KRNL(SetConsoleCursorPosition);\n\t\t\t{\n\t\t\tconst auto& srw = csbi.srWindow;\n\t\t\tCOORD crNewPosAPI = {\n\t\t\t\tstatic_cast<SHORT>(crNewPos.X),\n\t\t\t\tstatic_cast<SHORT>(std::min<int>(csbi.dwSize.Y - 1, srw.Top + crNewPos.Y))\n\t\t\t};\n\t\t\t_ASSERTE(crNewPosAPI.X == crNewPos.X);\n\t\t\tF(SetConsoleCursorPosition)(hConsoleOutput, crNewPosAPI);\n\t\t\t}\n\n\t\t\tif (gbIsVimProcess)\n\t\t\t\tgbIsVimAnsi = true;\n\t\t} // case 'H', 'f', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'd'\n\t\tbreak;\n\n\tcase L'J': // Clears part of the screen\n\t\t// Clears the screen and moves the cursor to the home position (line 0, column 0).\n\t\tif (GetConsoleScreenBufferInfoCached(hConsoleOutput, &csbi))\n\t\t{\n\t\t\tif (lbApply)\n\t\t\t{\n\t\t\t\t// Apply default color before scrolling!\n\t\t\t\t// ViM: need to fill whole screen with selected background color, so Apply attributes\n\t\t\t\tReSetDisplayParm(hConsoleOutput, FALSE, TRUE);\n\t\t\t\tlbApply = FALSE;\n\t\t\t}\n\n\t\t\tint nCmd = (Code.ArgC > 0) ? Code.ArgV[0] : 0;\n\t\t\tbool resetCursor = false;\n\t\t\tCOORD cr0 = {0, csbi.srWindow.Top};\n\t\t\tint nChars = 0;\n\n\t\t\tswitch (nCmd)\n\t\t\t{\n\t\t\tcase 0:\n\t\t\t\t// clear from cursor to end of screen\n\t\t\t\tcr0 = csbi.dwCursorPosition;\n\t\t\t\tnChars = (csbi.dwSize.X - csbi.dwCursorPosition.X)\n\t\t\t\t\t+ csbi.dwSize.X * (csbi.srWindow.Bottom - csbi.dwCursorPosition.Y);\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\t// clear from cursor to beginning of the screen\n\t\t\t\tnChars = csbi.dwCursorPosition.X + 1\n\t\t\t\t\t+ csbi.dwSize.X * (csbi.dwCursorPosition.Y - csbi.srWindow.Top);\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\t// clear viewport and moves cursor to viewport's upper left\n\t\t\t\tnChars = csbi.dwSize.X * (csbi.srWindow.Bottom - csbi.srWindow.Top + 1);\n\t\t\t\tresetCursor = true;\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\t// xterm: clear scrollback buffer entirely\n\t\t\t\tif (csbi.srWindow.Top > 0)\n\t\t\t\t{\n\t\t\t\t\tcr0.X = csbi.dwCursorPosition.X;\n\t\t\t\t\tcr0.Y = static_cast<SHORT>(std::max(0, (csbi.dwCursorPosition.Y - csbi.srWindow.Top)));\n\t\t\t\t\tresetCursor = true;\n\n\t\t\t\t\tSMALL_RECT scroll{ 0, 0, static_cast<SHORT>(csbi.dwSize.X - 1),\n\t\t\t\t\t\tstatic_cast<SHORT>(csbi.dwSize.Y - 1) };\n\t\t\t\t\tScrollScreen(hConsoleOutput, -csbi.srWindow.Top, true, scroll);\n\n\t\t\t\t\tSMALL_RECT topLeft = { 0, 0, scroll.Right,\n\t\t\t\t\t\tstatic_cast<SHORT>(csbi.srWindow.Bottom - csbi.srWindow.Top) };\n\t\t\t\t\tSetConsoleWindowInfo(hConsoleOutput, TRUE, &topLeft);\n\n\t\t\t\t\tUpdateAppMapRows(0, true);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tDumpUnknownEscape(Code.pszEscStart, Code.nTotalLen);\n\t\t\t}\n\n\t\t\tif (nChars > 0)\n\t\t\t{\n\t\t\t\tExtFillOutputParm fill = {sizeof(fill), efof_Current|efof_Attribute|efof_Character,\n\t\t\t\t\thConsoleOutput, {}, L' ', cr0, static_cast<DWORD>(nChars)};\n\t\t\t\tExtFillOutput(&fill);\n\t\t\t}\n\n\t\t\tif (resetCursor)\n\t\t\t{\n\t\t\t\tSetConsoleCursorPosition(hConsoleOutput, cr0);\n\t\t\t}\n\n\t\t} // case L'J':\n\t\tbreak;\n\n\tcase L'b':\n\t\tif (!Code.PvtLen)\n\t\t{\n\t\t\tint repeat = (Code.ArgC > 0) ? Code.ArgV[0] : 1;\n\t\t\tif (m_LastWrittenChar && repeat > 0)\n\t\t\t{\n\t\t\t\tCEStr buffer;\n\t\t\t\tif (wchar_t* ptr = buffer.GetBuffer(repeat))\n\t\t\t\t{\n\t\t\t\t\tfor (int i = 0; i < repeat; ++i)\n\t\t\t\t\t\tptr[i] = m_LastWrittenChar;\n\t\t\t\t\tWriteText(writeConsoleW, hConsoleOutput, ptr, repeat, nullptr);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\tbreak; // case L'b'\n\n\tcase L'K': // Erases part of the line\n\t\t// Clears all characters from the cursor position to the end of the line\n\t\t// (including the character at the cursor position).\n\t\tif (GetConsoleScreenBufferInfoCached(hConsoleOutput, &csbi))\n\t\t{\n\t\t\tif (lbApply)\n\t\t\t{\n\t\t\t\t// Apply default color before scrolling!\n\t\t\t\tReSetDisplayParm(hConsoleOutput, FALSE, TRUE);\n\t\t\t\tlbApply = FALSE;\n\t\t\t}\n\n\t\t\tTODO(\"Need to clear attributes?\");\n\t\t\tint nChars = 0;\n\t\t\tint nCmd = (Code.ArgC > 0) ? Code.ArgV[0] : 0;\n\t\t\tCOORD cr0 = csbi.dwCursorPosition;\n\n\t\t\tswitch (nCmd)\n\t\t\t{\n\t\t\tcase 0: // clear from cursor to the end of the line\n\t\t\t\tnChars = csbi.dwSize.X - csbi.dwCursorPosition.X;\n\t\t\t\tbreak;\n\t\t\tcase 1: // clear from cursor to beginning of the line\n\t\t\t\tcr0.X = 0;\n\t\t\t\tnChars = csbi.dwCursorPosition.X + 1;\n\t\t\t\tbreak;\n\t\t\tcase 2: // clear entire line\n\t\t\t\tcr0.X = 0;\n\t\t\t\tnChars = csbi.dwSize.X;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t\t}\n\n\n\t\t\tif (nChars > 0)\n\t\t\t{\n\t\t\t\tExtFillOutputParm fill = { sizeof(fill), efof_Current | efof_Attribute | efof_Character,\n\t\t\t\t\thConsoleOutput, {}, L' ', cr0, static_cast<DWORD>(nChars) };\n\t\t\t\tExtFillOutput(&fill);\n\t\t\t}\n\t\t} // case L'K':\n\t\tbreak;\n\n\tcase L'r':\n\t\t//\\027[Pt;Pbr\n\t\t//\n\t\t//Pt is the number of the top line of the scrolling region;\n\t\t//Pb is the number of the bottom line of the scrolling region\n\t\t// and must be greater than Pt.\n\t\t//(The default for Pt is line 1, the default for Pb is the end\n\t\t// of the screen)\n\t\t//\n\t\tif ((Code.ArgC >= 2) && (Code.ArgV[0] >= 0) && (Code.ArgV[1] >= Code.ArgV[0]))\n\t\t{\n\t\t\t// Values are 1-based\n\t\t\tSetScrollRegion(true, true, Code.ArgV[0], Code.ArgV[1], hConsoleOutput);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tSetScrollRegion(false);\n\t\t}\n\t\tbreak;\n\n\tcase L'S':\n\t\t// Scroll whole page up by n (default 1) lines. New lines are added at the bottom.\n\t\tif (lbApply)\n\t\t{\n\t\t\t// Apply default color before scrolling!\n\t\t\tReSetDisplayParm(hConsoleOutput, FALSE, TRUE);\n\t\t\tlbApply = FALSE;\n\t\t}\n\t\tScrollScreen(hConsoleOutput, (Code.ArgC > 0 && Code.ArgV[0] > 0) ? -Code.ArgV[0] : -1);\n\t\tbreak;\n\n\tcase L'L':\n\t\t// Insert P s Line(s) (default = 1) (IL).\n\t\tLinesInsert(hConsoleOutput, (Code.ArgC > 0 && Code.ArgV[0] > 0) ? Code.ArgV[0] : 1);\n\t\tbreak;\n\tcase L'M':\n\t\t// Delete N Line(s) (default = 1) (DL).\n\t\t// This is actually \"Scroll UP N line(s) inside defined scrolling region\"\n\t\tLinesDelete(hConsoleOutput, (Code.ArgC > 0 && Code.ArgV[0] > 0) ? Code.ArgV[0] : 1);\n\t\tbreak;\n\n\tcase L'@':\n\t\t// Insert P s (Blank) Character(s) (default = 1) (ICH).\n\t\tScrollLine(hConsoleOutput, ((Code.ArgC > 0 && Code.ArgV[0] > 0) ? Code.ArgV[0] : 1));\n\t\tbreak;\n\tcase L'P':\n\t\t// Delete P s Character(s) (default = 1) (DCH).\n\t\tScrollLine(hConsoleOutput, -((Code.ArgC > 0 && Code.ArgV[0] > 0) ? Code.ArgV[0] : 1));\n\t\tbreak;\n\n\tcase L'T':\n\t\t// Scroll whole page down by n (default 1) lines. New lines are added at the top.\n\t\tif (lbApply)\n\t\t{\n\t\t\t// Apply default color before scrolling!\n\t\t\tReSetDisplayParm(hConsoleOutput, FALSE, TRUE);\n\t\t}\n\t\tTODO(\"Define scrolling region\");\n\t\tScrollScreen(hConsoleOutput, (Code.ArgC > 0 && Code.ArgV[0] > 0) ? Code.ArgV[0] : 1);\n\t\tbreak;\n\n\tcase L'h':\n\tcase L'l':\n\t\t// Set/ReSet Mode\n\t\tif (Code.ArgC > 0)\n\t\t{\n\t\t\t//ESC [ 3 h\n\t\t\t//       DECCRM (default off): Display control chars.\n\n\t\t\t//ESC [ 4 h\n\t\t\t//       DECIM (default off): Set insert mode.\n\n\t\t\t//ESC [ 20 h\n\t\t\t//       LF/NL (default off): Automatically follow echo of LF, VT or FF with CR.\n\n\t\t\t//ESC [ ? 1 h\n\t\t\t//\t  DECCKM (default off): When set, the cursor keys send an ESC O prefix,\n\t\t\t//\t  rather than ESC [.\n\n\t\t\t//ESC [ ? 3 h\n\t\t\t//\t  DECCOLM (default off = 80 columns): 80/132 col mode switch.  The driver\n\t\t\t//\t  sources note that this alone does not suffice; some user-mode utility\n\t\t\t//\t  such as resizecons(8) has to change the hardware registers on the\n\t\t\t//\t  console video card.\n\n\t\t\t//ESC [ ? 5 h\n\t\t\t//\t  DECSCNM (default off): Set reverse-video mode.\n\n\t\t\t//ESC [ ? 6 h\n\t\t\t//\t  DECOM (default off): When set, cursor addressing is relative to the\n\t\t\t//\t  upper left corner of the scrolling region.\n\n\n\t\t\t//ESC [ ? 8 h\n\t\t\t//\t  DECARM (default on): Set keyboard autorepeat on.\n\n\t\t\t//ESC [ ? 9 h\n\t\t\t//\t  X10 Mouse Reporting (default off): Set reporting mode to 1 (or reset to\n\t\t\t//\t  0) -- see below.\n\n\t\t\t//ESC [ ? 1000 h\n\t\t\t//\t  X11 Mouse Reporting (default off): Set reporting mode to 2 (or reset to\n\t\t\t//\t  0) -- see below.\n\n\t\t\t//ESC [ ? 7711 h\n\t\t\t//    mimic mintty code, same as \"ESC ] 9 ; 12 ST\"\n\n\t\t\tswitch (Code.ArgV[0])\n\t\t\t{\n\t\t\tcase 1:\n\t\t\t\tif ((Code.PvtLen == 1) && (Code.Pvt[0] == L'?'))\n\t\t\t\t{\n\t\t\t\t\tgDisplayCursor.CursorKeysApp = (Code.Action == L'h');\n\n\t\t\t\t\tif (gbIsVimProcess)\n\t\t\t\t\t{\n\t\t\t\t\t\tTODO(\"Need to find proper way for activation alternative buffer from ViM?\");\n\t\t\t\t\t\tif (Code.Action == L'h')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\thConsoleOutput = StartVimTerm(false);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\thConsoleOutput = StopVimTerm();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tChangeTermMode(tmc_AppCursorKeys, (Code.Action == L'h'));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart, Code.nTotalLen);\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tgDisplayOpt.ShowRawAnsi = (Code.Action == L'h');\n\t\t\t\tbreak;\n\t\t\tcase 7:\n\t\t\t\t//ESC [ ? 7 h\n\t\t\t\t//\t  DECAWM (default off): Set autowrap on.  In this mode, a graphic\n\t\t\t\t//\t  character emitted after column 80 (or column 132 of DECCOLM is on)\n\t\t\t\t//\t  forces a wrap to the beginning of the following line first.\n\t\t\t\t//ESC [ = 7 h\n\t\t\t\t//    Enables line wrapping\n\t\t\t\t//ESC [ 7 ; _col_ h\n\t\t\t\t//    Our extension. _col_ - wrap at column (1-based), default = 80\n\t\t\t\tif ((gDisplayOpt.WrapWasSet = (Code.Action == L'h')))\n\t\t\t\t{\n\t\t\t\t\tgDisplayOpt.WrapAt = ((Code.ArgC > 1) && (Code.ArgV[1] > 0)) ? static_cast<SHORT>(Code.ArgV[1]) : 80;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 20:\n\t\t\t\tif (Code.PvtLen == 0)\n\t\t\t\t{\n\t\t\t\t\tSetAutoLfNl(Code.Action == L'h');\n\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart, Code.nTotalLen);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t//ESC [ ? 12 h\n\t\t\t//\t  Start Blinking Cursor (att610)\n\t\t\tcase 12:\n\t\t\t//ESC [ ? 25 h\n\t\t\t//\t  DECTECM (default on): Make cursor visible.\n\t\t\tcase 25:\n\t\t\t\tif ((Code.PvtLen == 1) && (Code.Pvt[0] == L'?'))\n\t\t\t\t{\n\t\t\t\t\tfor (int i = 0; i < Code.ArgC; ++i)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (Code.ArgV[i] == 25)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tCONSOLE_CURSOR_INFO ci = {};\n\t\t\t\t\t\t\tif (GetConsoleCursorInfo(hConsoleOutput, &ci))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tci.bVisible = (Code.Action == L'h');\n\t\t\t\t\t\t\t\tSetConsoleCursorInfo(hConsoleOutput, &ci);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// DumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart, Code.nTotalLen);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tif (Code.PvtLen == 0)\n\t\t\t\t{  // NOLINT(bugprone-branch-clone)\n\t\t\t\t\t/* h=Insert Mode (IRM), l=Replace Mode (IRM) */\n\t\t\t\t\t// Nano posts the `ESC [ 4 l` on start, but do not post `ESC [ 4 h` on exit, that is strange...\n\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored); // ignored for now\n\t\t\t\t}\n\t\t\t\telse if ((Code.PvtLen == 1) && (Code.Pvt[0] == L'?'))\n\t\t\t\t{\n\t\t\t\t\t/* h=Smooth (slow) scroll, l=Jump (fast) scroll */\n\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored); // ignored for now\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart, Code.nTotalLen);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 9:    /* X10_MOUSE */\n\t\t\tcase 1000: /* VT200_MOUSE */\n\t\t\tcase 1002: /* BTN_EVENT_MOUSE */\n\t\t\tcase 1003: /* ANY_EVENT_MOUSE */\n\t\t\tcase 1004: /* FOCUS_EVENT_MOUSE */\n\t\t\tcase 1005: /* Xterm's UTF8 encoding for mouse positions */\n\t\t\tcase 1006: /* Xterm's CSI-style mouse encoding */\n\t\t\tcase 1015: /* Urxvt's CSI-style mouse encoding */\n\t\t\t\tif ((Code.PvtLen == 1) && (Code.Pvt[0] == L'?'))\n\t\t\t\t{\n\t\t\t\t\tstatic DWORD LastMode = 0;\n\t\t\t\t\tTermMouseMode ModeMask = (Code.ArgV[0] == 9) ? tmm_X10\n\t\t\t\t\t\t: (Code.ArgV[0] == 1000) ? tmm_VT200\n\t\t\t\t\t\t: (Code.ArgV[0] == 1002) ? tmm_BTN\n\t\t\t\t\t\t: (Code.ArgV[0] == 1003) ? tmm_ANY\n\t\t\t\t\t\t: (Code.ArgV[0] == 1004) ? tmm_FOCUS\n\t\t\t\t\t\t: (Code.ArgV[0] == 1005) ? tmm_UTF8\n\t\t\t\t\t\t: (Code.ArgV[0] == 1006) ? tmm_XTERM\n\t\t\t\t\t\t: (Code.ArgV[0] == 1015) ? tmm_URXVT\n\t\t\t\t\t\t: tmm_None;\n\t\t\t\t\tDWORD Mode = (Code.Action == L'h')\n\t\t\t\t\t\t? (LastMode | ModeMask)\n\t\t\t\t\t\t: (LastMode & ~ModeMask);\n\t\t\t\t\tLastMode = Mode;\n\t\t\t\t\tChangeTermMode(tmc_MouseMode, Mode);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart, Code.nTotalLen);\n\t\t\t\tbreak;\n\t\t\tcase 7786: /* 'V': Mouse wheel reporting */\n\t\t\tcase 7787: /* 'W': Application mouse wheel mode */\n\t\t\tcase 1034: // Interpret \"meta\" key, sets eighth bit. (enables/disables the eightBitInput resource).\n\t\t\t\tif ((Code.PvtLen == 1) && (Code.Pvt[0] == L'?'))\n\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored);\n\t\t\t\telse\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart, Code.nTotalLen);\n\t\t\t\tbreak;\n\t\t\tcase 47:   /* alternate screen */\n\t\t\tcase 1047: /* alternate screen */\n\t\t\tcase 1049: /* cursor & alternate screen */\n\t\t\t\t// xmux/screen: Alternate screen\n\t\t\t\tif ((Code.PvtLen == 1) && (Code.Pvt[0] == L'?'))\n\t\t\t\t{\n\t\t\t\t\tif (lbApply)\n\t\t\t\t\t{\n\t\t\t\t\t\tReSetDisplayParm(hConsoleOutput, FALSE, TRUE);\n\t\t\t\t\t\tlbApply = FALSE;\n\t\t\t\t\t}\n\n\t\t\t\t\t// \\e[?1049h: save cursor pos\n\t\t\t\t\tif ((Code.ArgV[0] == 1049) && (Code.Action == L'h'))\n\t\t\t\t\t\tXTermSaveRestoreCursor(true, hConsoleOutput);\n\t\t\t\t\t// h: switch to alternative buffer without backscroll\n\t\t\t\t\t// l: restore saved scrollback buffer\n\t\t\t\t\thConsoleOutput = XTermAltBuffer((Code.Action == L'h'), Code.ArgV[0]);\n\t\t\t\t\t// \\e[?1049l - restore cursor pos\n\t\t\t\t\tif ((Code.ArgV[0] == 1049) && (Code.Action == L'l'))\n\t\t\t\t\t\tXTermSaveRestoreCursor(false, hConsoleOutput);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart, Code.nTotalLen);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 1048: /* save/restore cursor */\n\t\t\t\tif ((Code.PvtLen == 1) && (Code.Pvt[0] == L'?'))\n\t\t\t\t\tXTermSaveRestoreCursor((Code.Action == L'h'), hConsoleOutput);\n\t\t\t\telse\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart, Code.nTotalLen);\n\t\t\t\tbreak;\n\t\t\tcase 2004: /* bracketed paste */\n\t\t\t\t/* All \"pasted\" text will be wrapped in `\\e[200~ ... \\e[201~` */\n\t\t\t\tif ((Code.PvtLen == 1) && (Code.Pvt[0] == L'?'))\n\t\t\t\t\tChangeTermMode(tmc_BracketedPaste, (Code.Action == L'h'));\n\t\t\t\telse\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart, Code.nTotalLen);\n\t\t\t\tbreak;\n\t\t\tcase 7711:\n\t\t\t\tif ((Code.Action == L'h') && (Code.PvtLen == 1) && (Code.Pvt[0] == L'?'))\n\t\t\t\t{\n\t\t\t\t\tStorePromptBegin();\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart, Code.nTotalLen);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t\t}\n\n\t\t\t//switch (Code.ArgV[0])\n\t\t\t//{\n\t\t\t//case 0: case 1:\n\t\t\t//\t// 40x25\n\t\t\t//\tif ((gDisplayOpt.WrapWasSet = (Code.Action == L'h')))\n\t\t\t//\t{\n\t\t\t//\t\tgDisplayOpt.WrapAt = 40;\n\t\t\t//\t}\n\t\t\t//\tbreak;\n\t\t\t//case 2: case 3:\n\t\t\t//\t// 80x25\n\t\t\t//\tif ((gDisplayOpt.WrapWasSet = (Code.Action == L'h')))\n\t\t\t//\t{\n\t\t\t//\t\tgDisplayOpt.WrapAt = 80;\n\t\t\t//\t}\n\t\t\t//\tbreak;\n\t\t\t//case 7:\n\t\t\t//\t{\n\t\t\t//\t\tDWORD Mode = 0;\n\t\t\t//\t\tGetConsoleMode(hConsoleOutput, &Mode);\n\t\t\t//\t\tif (Code.Action == L'h')\n\t\t\t//\t\t\tMode |= ENABLE_WRAP_AT_EOL_OUTPUT;\n\t\t\t//\t\telse\n\t\t\t//\t\t\tMode &= ~ENABLE_WRAP_AT_EOL_OUTPUT;\n\t\t\t//\t\tSetConsoleMode(hConsoleOutput, Mode);\n\t\t\t//\t} // enable/disable line wrapping\n\t\t\t//\tbreak;\n\t\t\t//}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t}\n\t\tbreak; // case L'h': case L'l':\n\n\tcase L'n':\n\t\tif (Code.ArgC > 0)\n\t\t{\n\t\t\tswitch (*Code.ArgV)\n\t\t\t{\n\t\t\tcase 5:\n\t\t\t\t//ESC [ 5 n\n\t\t\t\t//      Device status report (DSR): Answer is ESC [ 0 n (Terminal OK).\n\t\t\t\t//\n\t\t\t\tReportString(L\"\\x1B[0n\");\n\t\t\t\tbreak;\n\t\t\tcase 6:\n\t\t\t\t//ESC [ 6 n\n\t\t\t\t//      Cursor position report (CPR): Answer is ESC [ y ; x R, where x,y is the\n\t\t\t\t//      cursor location.\n\t\t\t\tReportCursorPosition(hConsoleOutput);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t}\n\t\tbreak;\n\n\tcase L'm':\n\t\tif (Code.PvtLen > 0)\n\t\t{\n\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored);\n\t\t}\n\t\t// Set display mode (colors, fonts, etc.)\n\t\telse if (!Code.ArgC)\n\t\t{\n\t\t\tReSetDisplayParm(hConsoleOutput, TRUE, FALSE);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor (int i = 0; i < Code.ArgC; i++)\n\t\t\t{\n\t\t\t\tswitch (Code.ArgV[i])\n\t\t\t\t{\n\t\t\t\tcase 0:\n\t\t\t\t\tReSetDisplayParm(hConsoleOutput, TRUE, FALSE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\t// Bold\n\t\t\t\t\tgDisplayParm.setBrightOrBold(TRUE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\t// Faint, decreased intensity (ISO 6429)\n\t\t\t\tcase 22:\n\t\t\t\t\t// Normal (neither bold nor faint).\n\t\t\t\t\tgDisplayParm.setBrightOrBold(FALSE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3:\n\t\t\t\t\t// Italic\n\t\t\t\t\tgDisplayParm.setItalic(TRUE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 23:\n\t\t\t\t\t// Not italic\n\t\t\t\t\tgDisplayParm.setItalic(FALSE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 5: // #TODO ANSI Slow Blink (less than 150 per minute)\n\t\t\t\tcase 6: // #TODO ANSI Rapid Blink (150+ per minute)\n\t\t\t\tcase 25: // #TODO ANSI Blink Off\n\t\t\t\t\tDumpKnownEscape(Code.pszEscStart,Code.nTotalLen,de_Ignored);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 4: // Underlined\n\t\t\t\t\tgDisplayParm.setUnderline(true);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 24:\n\t\t\t\t\t// Not underlined\n\t\t\t\t\tgDisplayParm.setUnderline(false);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 7:\n\t\t\t\t\t// Reverse video\n\t\t\t\t\tgDisplayParm.setInverse(TRUE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 27:\n\t\t\t\t\t// Positive (not inverse)\n\t\t\t\t\tgDisplayParm.setInverse(FALSE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 9:\n\t\t\t\t\t// Crossed-out / strikethrough\n\t\t\t\t\tgDisplayParm.setCrossed(true);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 29:\n\t\t\t\t\t// Not Crossed-out / Not strikethrough\n\t\t\t\t\tgDisplayParm.setCrossed(false);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 30: case 31: case 32: case 33: case 34: case 35: case 36: case 37:\n\t\t\t\t\tgDisplayParm.setTextColor(Code.ArgV[i] - 30);\n\t\t\t\t\tgDisplayParm.setBrightFore(FALSE);\n\t\t\t\t\tgDisplayParm.setText256(clr4b);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 38:\n\t\t\t\t\t// xterm-256 colors\n\t\t\t\t\t// ESC [ 38 ; 5 ; I m -- set foreground to I (0..255) color from xterm palette\n\t\t\t\t\tif (((i+2) < Code.ArgC) && (Code.ArgV[i+1] == 5))\n\t\t\t\t\t{\n\t\t\t\t\t\tgDisplayParm.setTextColor(Code.ArgV[i+2] & 0xFF);\n\t\t\t\t\t\tgDisplayParm.setText256(clr8b);\n\t\t\t\t\t\ti += 2;\n\t\t\t\t\t}\n\t\t\t\t\t// xterm-256 colors\n\t\t\t\t\t// ESC [ 38 ; 2 ; R ; G ; B m -- set foreground to RGB(R,G,B) 24-bit color\n\t\t\t\t\telse if (((i+4) < Code.ArgC) && (Code.ArgV[i+1] == 2))\n\t\t\t\t\t{\n\t\t\t\t\t\tgDisplayParm.setTextColor(RGB((Code.ArgV[i+2] & 0xFF),(Code.ArgV[i+3] & 0xFF),(Code.ArgV[i+4] & 0xFF)));\n\t\t\t\t\t\tgDisplayParm.setText256(clr24b);\n\t\t\t\t\t\ti += 4;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 39:\n\t\t\t\t\t// Reset\n\t\t\t\t\tgDisplayParm.setTextColor(CONFORECOLOR(GetDefaultTextAttr()));\n\t\t\t\t\tgDisplayParm.setBrightFore(FALSE);\n\t\t\t\t\tgDisplayParm.setText256(clr4b);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 40: case 41: case 42: case 43: case 44: case 45: case 46: case 47:\n\t\t\t\t\tgDisplayParm.setBackColor(Code.ArgV[i] - 40);\n\t\t\t\t\tgDisplayParm.setBrightBack(FALSE);\n\t\t\t\t\tgDisplayParm.setBack256(clr4b);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 48:\n\t\t\t\t\t// xterm-256 colors\n\t\t\t\t\t// ESC [ 48 ; 5 ; I m -- set background to I (0..255) color from xterm palette\n\t\t\t\t\tif (((i+2) < Code.ArgC) && (Code.ArgV[i+1] == 5))\n\t\t\t\t\t{\n\t\t\t\t\t\tgDisplayParm.setBackColor(Code.ArgV[i+2] & 0xFF);\n\t\t\t\t\t\tgDisplayParm.setBack256(clr8b);\n\t\t\t\t\t\ti += 2;\n\t\t\t\t\t}\n\t\t\t\t\t// xterm-256 colors\n\t\t\t\t\t// ESC [ 48 ; 2 ; R ; G ; B m -- set background to RGB(R,G,B) 24-bit color\n\t\t\t\t\telse if (((i+4) < Code.ArgC) && (Code.ArgV[i+1] == 2))\n\t\t\t\t\t{\n\t\t\t\t\t\tgDisplayParm.setBackColor(RGB((Code.ArgV[i+2] & 0xFF),(Code.ArgV[i+3] & 0xFF),(Code.ArgV[i+4] & 0xFF)));\n\t\t\t\t\t\tgDisplayParm.setBack256(clr24b);\n\t\t\t\t\t\ti += 4;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 49:\n\t\t\t\t\t// Reset\n\t\t\t\t\tgDisplayParm.setBackColor(CONBACKCOLOR(GetDefaultTextAttr()));\n\t\t\t\t\tgDisplayParm.setBrightBack(FALSE);\n\t\t\t\t\tgDisplayParm.setBack256(clr4b);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 90: case 91: case 92: case 93: case 94: case 95: case 96: case 97:\n\t\t\t\t\tgDisplayParm.setTextColor((Code.ArgV[i] - 90) | 0x8);\n\t\t\t\t\tgDisplayParm.setText256(clr4b);\n\t\t\t\t\tgDisplayParm.setBrightFore(TRUE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 100: case 101: case 102: case 103: case 104: case 105: case 106: case 107:\n\t\t\t\t\tgDisplayParm.setBackColor((Code.ArgV[i] - 100) | 0x8);\n\t\t\t\t\tgDisplayParm.setBack256(clr4b);\n\t\t\t\t\tgDisplayParm.setBrightBack(TRUE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 10:  // NOLINT(bugprone-branch-clone)\n\t\t\t\t\t// Something strange and unknown... (received from ssh)\n\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 312:\n\t\t\t\tcase 315:\n\t\t\t\tcase 414:\n\t\t\t\tcase 3130:\n\t\t\t\t\t// Something strange and unknown... (received from vim on WSL)\n\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak; // \"[...m\"\n\n\tcase L'p':\n\t\tif (Code.ArgC == 0 && Code.PvtLen == 1 && Code.Pvt[0] == L'!')\n\t\t{\n\t\t\tFullReset(hConsoleOutput);\n\t\t\tlbApply = FALSE;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t}\n\t\tbreak; // \"[!p\"\n\n\tcase L'q':\n\t\tif ((Code.PvtLen == 1) && (Code.Pvt[0] == L' '))\n\t\t{\n\t\t\t/*\n\t\t\tCSI Ps SP q\n\t\t\t\tSet cursor style (DECSCUSR, VT520).\n\t\t\t\t\tPs = 0  -> ConEmu's default.\n\t\t\t\t\tPs = 1  -> blinking block.\n\t\t\t\t\tPs = 2  -> steady block.\n\t\t\t\t\tPs = 3  -> blinking underline.\n\t\t\t\t\tPs = 4  -> steady underline.\n\t\t\t\t\tPs = 5  -> blinking bar (xterm).\n\t\t\t\t\tPs = 6  -> steady bar (xterm).\n\t\t\t*/\n\t\t\tDWORD nStyle = ((Code.ArgC == 0) || (Code.ArgV[0] < 0) || (Code.ArgV[0] > 6))\n\t\t\t\t? 0 : Code.ArgV[0];\n\t\t\tCONSOLE_CURSOR_INFO ci = {};\n\t\t\tif (GetConsoleCursorInfo(hConsoleOutput, &ci))\n\t\t\t{\n\t\t\t\t// We can't implement all possible styles in RealConsole,\n\t\t\t\t// but we can use \"Block/Underline\" shapes...\n\t\t\t\tci.dwSize = (nStyle == 1 || nStyle == 2) ? 100 : 15;\n\t\t\t\tSetConsoleCursorInfo(hConsoleOutput, &ci);\n\t\t\t}\n\t\t\tChangeTermMode(tmc_CursorShape, nStyle);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t}\n\t\tbreak; // \"[...q\"\n\n\tcase L't':\n\t\tif (Code.ArgC > 0 && Code.ArgC <= 3)\n\t\t{\n\t\t\tfor (int i = 0; i < Code.ArgC; i++)\n\t\t\t{\n\t\t\t\tswitch (Code.ArgV[i])\n\t\t\t\t{\n\t\t\t\tcase 8:\n\t\t\t\t\t// `ESC [ 8 ; height ; width t` --> Resize the text area to [height;width] in characters.\n\t\t\t\t\t{\n\t\t\t\t\t\tint height = -1, width = -1;\n\t\t\t\t\t\tif (i < Code.ArgC)\n\t\t\t\t\t\t\theight = Code.ArgV[++i];\n\t\t\t\t\t\tif (i < Code.ArgC)\n\t\t\t\t\t\t\twidth = Code.ArgV[++i];\n\t\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored);\n\t\t\t\t\t\tstd::ignore = height;\n\t\t\t\t\t\tstd::ignore = width;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 14:\n\t\t\t\t\t// `ESC [ 1 4 t` --> Reports terminal window size in pixels as `CSI 4 ; height ; width t`.\n\t\t\t\t\tReportTerminalPixelSize();\n\t\t\t\t\tbreak;\n\t\t\t\tcase 18:\n\t\t\t\tcase 19:\n\t\t\t\t\t// `ESC [ 1 8 t` --> Report the size of the text area in characters as `CSI 8 ; height ; width t`\n\t\t\t\t\t// `ESC [ 1 9 t` --> Report the size of the screen in characters as `CSI 9 ; height ; width t`\n\t\t\t\t\tReportTerminalCharSize(hConsoleOutput, Code.ArgV[i]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 21:\n\t\t\t\t\t// `ESC [ 2 1 t` --> Report terminal window title as `OSC l title ST`\n\t\t\t\t\tReportConsoleTitle();\n\t\t\t\t\tbreak;\n\t\t\t\tcase 22:\n\t\t\t\tcase 23:\n\t\t\t\t\t// `ESC [ 2 2 ; 0 t` --> Save xterm icon and window title on stack.\n\t\t\t\t\t// `ESC [ 2 2 ; 1 t` --> Save xterm icon title on stack.\n\t\t\t\t\t// `ESC [ 2 2 ; 2 t` --> Save xterm window title on stack.\n\t\t\t\t\t// `ESC [ 2 3 ; 0 t` --> Restore xterm icon and window title from stack.\n\t\t\t\t\t// `ESC [ 2 3 ; 1 t` --> Restore xterm icon title from stack.\n\t\t\t\t\t// `ESC [ 2 3 ; 2 t` --> Restore xterm window title from stack.\n\t\t\t\t\tif (i < Code.ArgC)\n\t\t\t\t\t\t++i; // subcommand\n\t\t\t\t\tif (i < Code.ArgC && !Code.ArgV[i])\n\t\t\t\t\t\t++i; // strange sequence 22;0;0t\n\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tTODO(\"ANSI: xterm window manipulation\");\n\t\t\t\t\t//Window manipulation (from dtterm, as well as extensions). These controls may be disabled using the allowWindowOps resource. Valid values for the first (and any additional parameters) are:\n\t\t\t\t\t// 1 --> De-iconify window.\n\t\t\t\t\t// 2 --> Iconify window.\n\t\t\t\t\t// 3 ; x ; y --> Move window to [x, y].\n\t\t\t\t\t// 4 ; height ; width --> Resize the xterm window to height and width in pixels.\n\t\t\t\t\t// 5 --> Raise the xterm window to the front of the stacking order.\n\t\t\t\t\t// 6 --> Lower the xterm window to the bottom of the stacking order.\n\t\t\t\t\t// 7 --> Refresh the xterm window.\n\t\t\t\t\t// 8 ; height ; width --> Resize the text area to [height;width] in characters.\n\t\t\t\t\t// 9 ; 0 --> Restore maximized window.\n\t\t\t\t\t// 9 ; 1 --> Maximize window (i.e., resize to screen size).\n\t\t\t\t\t// 1 1 --> Report xterm window state. If the xterm window is open (non-iconified), it returns CSI 1 t . If the xterm window is iconified, it returns CSI 2 t .\n\t\t\t\t\t// 1 3 --> Report xterm window position as CSI 3 ; x; y t\n\t\t\t\t\t// 1 4 --> Report xterm window in pixels as CSI 4 ; height ; width t\n\t\t\t\t\t// 2 0 --> Report xterm window\ufffds icon label as OSC L label ST\n\t\t\t\t\t// >= 2 4 --> Resize to P s lines (DECSLPP)\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t}\n\t\tbreak;\n\n\tcase L'c':\n\t\t// echo -e \"\\e[>c\"\n\t\tif ((Code.PvtLen == 1) && (Code.Pvt[0] == L'>')\n\t\t\t&& ((Code.ArgC < 1) || (Code.ArgV[0] == 0)))\n\t\t{\n\t\t\t// P s = 0 or omitted -> request the terminal's identification code.\n\t\t\twchar_t szVerInfo[64];\n\t\t\t// this will be \"ESC > 67 ; build ; 0 c\"\n\t\t\t// 67 is ASCII code of 'C' (ConEmu, yeah)\n\t\t\t// Other terminals report examples: MinTTY -> 77, rxvt -> 82, screen -> 83\n\t\t\t// msprintf(szVerInfo, countof(szVerInfo), L\"\\x1B>%u;%u;0c\", (int)'C', MVV_1*10000+MVV_2*100+MVV_3);\n\t\t\t// Emulate xterm version 136?\n\t\t\twcscpy_c(szVerInfo, L\"\\x1B[>0;136;0c\");\n\t\t\tReportString(szVerInfo);\n\t\t}\n\t\t// echo -e \"\\e[c\"\n\t\telse if ((Code.ArgC < 1) || (Code.ArgV[0] == 0))\n\t\t{\n\t\t\t// Report \"VT100 with Advanced Video Option\"\n\t\t\tReportString(L\"\\x1B[?1;2c\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t}\n\t\tbreak;\n\n\tcase L'X':\n\t\t// CSI P s X:  Erase P s Character(s) (default = 1) (ECH)\n\t\tif (GetConsoleScreenBufferInfoCached(hConsoleOutput, &csbi))\n\t\t{\n\t\t\tif (lbApply)\n\t\t\t{\n\t\t\t\t// Apply default color before scrolling!\n\t\t\t\tReSetDisplayParm(hConsoleOutput, FALSE, TRUE);\n\t\t\t\tlbApply = FALSE;\n\t\t\t}\n\n\t\t\tint nCount = (Code.ArgC > 0) ? Code.ArgV[0] : 1;\n\t\t\tint nScreenLeft = csbi.dwSize.X - csbi.dwCursorPosition.X - 1 + (csbi.dwSize.X * (csbi.dwSize.Y - csbi.dwCursorPosition.Y - 1));\n\t\t\tint nChars = std::min(nCount,nScreenLeft);\n\t\t\tCOORD cr0 = csbi.dwCursorPosition;\n\n\t\t\tif (nChars > 0)\n\t\t\t{\n\t\t\t\tExtFillOutputParm fill = { sizeof(fill), efof_Current | efof_Attribute | efof_Character,\n\t\t\t\t\thConsoleOutput, {}, L' ', cr0, static_cast<DWORD>(nChars) };\n\t\t\t\tExtFillOutput(&fill);\n\t\t\t}\n\t\t} // case L'X':\n\t\tbreak;\n\n\tdefault:\n\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t} // switch (Code.Action)\n}\n\nvoid CEAnsi::WriteAnsiCode_OSC(OnWriteConsoleW_t writeConsoleW, HANDLE hConsoleOutput, AnsiEscCode& Code, BOOL& lbApply)\n{\n\tif (!Code.ArgSZ)\n\t{\n\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\treturn;\n\t}\n\n\t// Finalizing (ST) with \"\\x1B\\\\\" or \"\\x07\"\n\t//ESC ] 0 ; txt ST        Set icon name and window title to txt.\n\t//ESC ] 1 ; txt ST        Set icon name to txt.\n\t//ESC ] 2 ; txt ST        Set window title to txt.\n\t//ESC ] 4 ; num; txt ST   Set ANSI color num to txt.\n\t//ESC ] 9 ... ST          ConEmu specific\n\t//ESC ] 10 ; txt ST       Set dynamic text color to txt.\n\t//ESC ] 4 6 ; name ST     Change log file to name (normally disabled\n\t//\t\t\t\t\t      by a compile-time option)\n\t//ESC ] 5 0 ; fn ST       Set font to fn.\n\n\tswitch (*Code.ArgSZ)\n\t{\n\tcase L'0':\n\tcase L'1':\n\tcase L'2':\n\t\tif (Code.ArgSZ[1] == L';' && Code.ArgSZ[2])\n\t\t{\n\t\t\tCEStr pszNewTitle;\n\t\t\tif (pszNewTitle.GetBuffer(Code.cchArgSZ))\n\t\t\t{\n\t\t\t\tEscCopyCtrlString(pszNewTitle.data(), Code.ArgSZ + 2, Code.cchArgSZ - 2);\n\t\t\t\tSetConsoleTitle(pszNewTitle.c_str(gsInitConTitle));\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase L'4':\n\t\t// TODO: the following is suggestion for exact palette colors\n\t\t// TODO: but we are using standard xterm palette or truecolor 24bit palette\n\t\t_ASSERTEX(Code.ArgSZ[1] == L';');\n\t\tbreak;\n\n\tcase L'9':\n\t\t// ConEmu specific\n\t\t// ESC ] 9 ; 1 ; ms ST           Sleep. ms - milliseconds\n\t\t// ESC ] 9 ; 2 ; \"txt\" ST        Show GUI MessageBox ( txt ) for dubug purposes\n\t\t// ESC ] 9 ; 3 ; \"txt\" ST        Set TAB text\n\t\t// ESC ] 9 ; 4 ; st ; pr ST      When _st_ is 0: remove progress. When _st_ is 1: set progress value to _pr_ (number, 0-100).\n\t\t//                               When _st_ is 2: set error state in progress on Windows 7 taskbar, _pr_ is optional.\n\t\t//                               When _st_ is 3: set indeterminate state. When _st_ is 4: set paused state, _pr_ is optional.\n\t\t// ESC ] 9 ; 5 ST                Wait for ENTER/SPACE/ESC. Set EnvVar \"ConEmuWaitKey\" to ENTER/SPACE/ESC on exit.\n\t\t// ESC ] 9 ; 6 ; \"txt\" ST        Execute GuiMacro. Set EnvVar \"ConEmuMacroResult\" on exit.\n\t\t// ESC ] 9 ; 7 ; \"cmd\" ST        Run some process with arguments\n\t\t// ESC ] 9 ; 8 ; \"env\" ST        Output value of environment variable\n\t\t// ESC ] 9 ; 9 ; \"cwd\" ST        Inform ConEmu about shell current working directory\n\t\t// ESC ] 9 ; 10 ; p ST           Request xterm keyboard/output emulation\n\t\t// ESC ] 9 ; 11; \"*txt*\" ST      Just a \u2018comment\u2019, skip it.\n\t\t// ESC ] 9 ; 12 ST               Let ConEmu treat current cursor position as prompt start. Useful with `PS1`.\n\t\tif (Code.ArgSZ[1] == L';')\n\t\t{\n\t\t\tif (Code.ArgSZ[2] == L'1')\n\t\t\t{\n\t\t\t\tif (Code.ArgSZ[3] == L';')\n\t\t\t\t{\n\t\t\t\t\t// ESC ] 9 ; 1 ; ms ST\n\t\t\t\t\tDoSleep(Code.ArgSZ+4);\n\t\t\t\t}\n\t\t\t\telse if (Code.ArgC >= 2 && Code.ArgV[1] == 10)\n\t\t\t\t{\n\t\t\t\t\t// ESC ] 9 ; 10 ST\n\t\t\t\t\t// ESC ] 9 ; 10 ; 1 ST\n\t\t\t\t\tif (!gbIsXTermOutput && (Code.ArgC == 2 || Code.ArgV[2] == 1))\n\t\t\t\t\t{\n\t\t\t\t\t\tDBG_XTERM(L\"xTermOutput=ON due ESC]9;10;1ST\");\n\t\t\t\t\t\tDBG_XTERM(L\"AutoLfNl=OFF due ESC]9;10;1ST\");\n\t\t\t\t\t\tDBG_XTERM(L\"term=XTerm due ESC]9;10;1ST\");\n\t\t\t\t\t\tCEAnsi::StartXTermMode(true);\n\t\t\t\t\t}\n\t\t\t\t\t// ESC ] 9 ; 10 ; 0 ST\n\t\t\t\t\telse if (Code.ArgC >= 3 || Code.ArgV[2] == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tDBG_XTERM(L\"xTermOutput=OFF due ESC]9;10;0ST\");\n\t\t\t\t\t\tDBG_XTERM(L\"AutoLfNl=ON due ESC]9;10;0ST\");\n\t\t\t\t\t\tDBG_XTERM(L\"term=Win32 due ESC]9;10;0ST\");\n\t\t\t\t\t\tCEAnsi::StartXTermMode(false);\n\t\t\t\t\t}\n\t\t\t\t\t// ESC ] 9 ; 10 ; 3 ST\n\t\t\t\t\telse if (Code.ArgC >= 3 || Code.ArgV[2] == 3)\n\t\t\t\t\t{\n\t\t\t\t\t\tDBG_XTERM(L\"xTermOutput=ON due ESC]9;10;3ST\");\n\t\t\t\t\t\tDBG_XTERM(L\"AutoLfNl=OFF due ESC]9;10;3ST\");\n\t\t\t\t\t\tCEAnsi::StartXTermOutput(true);\n\t\t\t\t\t}\n\t\t\t\t\t// ESC ] 9 ; 10 ; 2 ST\n\t\t\t\t\telse if (Code.ArgC >= 3 || Code.ArgV[2] == 2)\n\t\t\t\t\t{\n\t\t\t\t\t\tDBG_XTERM(L\"xTermOutput=OFF due ESC]9;10;2ST\");\n\t\t\t\t\t\tDBG_XTERM(L\"AutoLfNl=ON due ESC]9;10;2ST\");\n\t\t\t\t\t\tCEAnsi::StartXTermOutput(false);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (Code.ArgSZ[3] == L'1' && Code.ArgSZ[4] == L';')\n\t\t\t\t{\n\t\t\t\t\t// ESC ] 9 ; 11; \"*txt*\" ST - Just a \u2018comment\u2019, skip it.\n\t\t\t\t\tDumpKnownEscape(Code.ArgSZ+5, lstrlen(Code.ArgSZ+5), de_Comment);\n\t\t\t\t}\n\t\t\t\telse if (Code.ArgSZ[3] == L'2')\n\t\t\t\t{\n\t\t\t\t\t// ESC ] 9 ; 12 ST\n\t\t\t\t\tStorePromptBegin();\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (Code.ArgSZ[2] == L'2' && Code.ArgSZ[3] == L';')\n\t\t\t{\n\t\t\t\tDoMessage(Code.ArgSZ+4, Code.cchArgSZ - 4);\n\t\t\t}\n\t\t\telse if (Code.ArgSZ[2] == L'3' && Code.ArgSZ[3] == L';')\n\t\t\t{\n\t\t\t\tCESERVER_REQ* pIn = ExecuteNewCmd(CECMD_SETTABTITLE, sizeof(CESERVER_REQ_HDR)+sizeof(wchar_t)*(Code.cchArgSZ));\n\t\t\t\tif (pIn)\n\t\t\t\t{\n\t\t\t\t\tEscCopyCtrlString(reinterpret_cast<wchar_t*>(pIn->wData), Code.ArgSZ+4, Code.cchArgSZ-4);\n\t\t\t\t\tCESERVER_REQ* pOut = ExecuteGuiCmd(ghConWnd, pIn, ghConWnd);\n\t\t\t\t\tExecuteFreeResult(pIn);\n\t\t\t\t\tExecuteFreeResult(pOut);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (Code.ArgSZ[2] == L'4')\n\t\t\t{\n\t\t\t\tAnsiProgressStatus st = AnsiProgressStatus::None;\n\t\t\t\tWORD pr = 0;\n\t\t\t\tconst wchar_t* pszName = nullptr;\n\t\t\t\tif (Code.ArgSZ[3] == L';')\n\t\t\t\t{\n\t\t\t\t\tswitch (Code.ArgSZ[4])\n\t\t\t\t\t{\n\t\t\t\t\tcase L'0':\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase L'1':\n\t\t\t\t\t\tst = AnsiProgressStatus::Running; break;\n\t\t\t\t\tcase L'2':\n\t\t\t\t\t\tst = AnsiProgressStatus::Error; break;\n\t\t\t\t\tcase L'3':\n\t\t\t\t\t\tst = AnsiProgressStatus::Indeterminate; break;\n\t\t\t\t\tcase L'4':\n\t\t\t\t\t\tst = AnsiProgressStatus::Paused; break;\n\t\t\t\t\tcase L'5': // reserved for future use\n\t\t\t\t\t\tst = AnsiProgressStatus::LongRunStart; break;\n\t\t\t\t\tcase L'6': // reserved for future use\n\t\t\t\t\t\tst = AnsiProgressStatus::LongRunStop; break;\n\t\t\t\t\t}\n\t\t\t\t\tif (st == AnsiProgressStatus::Running || st == AnsiProgressStatus::Error || st == AnsiProgressStatus::Paused)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (Code.ArgSZ[5] == L';')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tLPCWSTR pszValue = Code.ArgSZ + 6;\n\t\t\t\t\t\t\tpr = NextNumber(pszValue);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (st == AnsiProgressStatus::LongRunStart || st == AnsiProgressStatus::LongRunStop)\n\t\t\t\t\t{\n\t\t\t\t\t\tpszName = (Code.ArgSZ[5] == L';') ? (Code.ArgSZ + 6) : nullptr;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tGuiSetProgress(st, pr, pszName);\n\t\t\t}\n\t\t\telse if (Code.ArgSZ[2] == L'5')\n\t\t\t{\n\t\t\t\t//int s = 0;\n\t\t\t\t//if (Code.ArgSZ[3] == L';')\n\t\t\t\t//\ts = NextNumber(Code.ArgSZ+4);\n\t\t\t\tBOOL bSucceeded = FALSE;\n\t\t\t\tDWORD nRead = 0;\n\t\t\t\tINPUT_RECORD r = {};\n\t\t\t\t// ReSharper disable once CppLocalVariableMayBeConst\n\t\t\t\tHANDLE hIn = GetStdHandle(STD_INPUT_HANDLE);\n\t\t\t\t//DWORD nStartTick = GetTickCount();\n\t\t\t\twhile (((bSucceeded = ReadConsoleInput(hIn, &r, 1, &nRead))) && nRead)\n\t\t\t\t{\n\t\t\t\t\tif ((r.EventType == KEY_EVENT) && r.Event.KeyEvent.bKeyDown)\n\t\t\t\t\t{\n\t\t\t\t\t\tif ((r.Event.KeyEvent.wVirtualKeyCode == VK_RETURN)\n\t\t\t\t\t\t\t|| (r.Event.KeyEvent.wVirtualKeyCode == VK_SPACE)\n\t\t\t\t\t\t\t|| (r.Event.KeyEvent.wVirtualKeyCode == VK_ESCAPE))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (bSucceeded && ((r.Event.KeyEvent.wVirtualKeyCode == VK_RETURN)\n\t\t\t\t\t\t\t|| (r.Event.KeyEvent.wVirtualKeyCode == VK_SPACE)\n\t\t\t\t\t\t\t|| (r.Event.KeyEvent.wVirtualKeyCode == VK_ESCAPE)))\n\t\t\t\t{\n\t\t\t\t\tSetEnvironmentVariable(ENV_CONEMU_WAITKEY_W,\n\t\t\t\t\t\t(r.Event.KeyEvent.wVirtualKeyCode == VK_RETURN) ? L\"RETURN\" :\n\t\t\t\t\t\t(r.Event.KeyEvent.wVirtualKeyCode == VK_SPACE)  ? L\"SPACE\" :\n\t\t\t\t\t\t(r.Event.KeyEvent.wVirtualKeyCode == VK_ESCAPE) ? L\"ESC\" :\n\t\t\t\t\t\tL\"???\");\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSetEnvironmentVariable(ENV_CONEMU_WAITKEY_W, L\"\");\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (Code.ArgSZ[2] == L'6' && Code.ArgSZ[3] == L';')\n\t\t\t{\n\t\t\t\tDoGuiMacro(Code.ArgSZ+4, Code.cchArgSZ - 4);\n\t\t\t}\n\t\t\telse if (Code.ArgSZ[2] == L'7' && Code.ArgSZ[3] == L';')\n\t\t\t{\n\t\t\t\tDoProcess(Code.ArgSZ+4, Code.cchArgSZ - 4);\n\t\t\t}\n\t\t\telse if (Code.ArgSZ[2] == L'8' && Code.ArgSZ[3] == L';')\n\t\t\t{\n\t\t\t\tif (lbApply)\n\t\t\t\t{\n\t\t\t\t\tReSetDisplayParm(hConsoleOutput, FALSE, TRUE);\n\t\t\t\t\tlbApply = FALSE;\n\t\t\t\t}\n\t\t\t\tDoPrintEnv(Code.ArgSZ+4, Code.cchArgSZ - 4);\n\t\t\t}\n\t\t\telse if (Code.ArgSZ[2] == L'9' && Code.ArgSZ[3] == L';')\n\t\t\t{\n\t\t\t\tDoSendCWD(Code.ArgSZ+4, Code.cchArgSZ - 4);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t}\n}\n\nvoid CEAnsi::WriteAnsiCode_VIM(OnWriteConsoleW_t writeConsoleW, HANDLE hConsoleOutput, AnsiEscCode& Code, BOOL& lbApply)\n{\n\tif (!gbIsXTermOutput && !gnWriteProcessed)\n\t{\n\t\tDBG_XTERM(L\"xTermOutput=ON due Vim start\");\n\t\tDBG_XTERM(L\"AutoLfNl=OFF due Vim start\");\n\t\tDBG_XTERM(L\"term=XTerm due Vim start\");\n\t\tCEAnsi::StartXTermMode(true);\n\t}\n\n\tswitch (Code.Action)\n\t{\n\tcase L'm':\n\t\t// Set xterm display modes (colors, fonts, etc.)\n\t\tif (!Code.ArgC)\n\t\t{\n\t\t\t//ReSetDisplayParm(hConsoleOutput, TRUE, FALSE);\n\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor (int i = 0; i < Code.ArgC; i++)\n\t\t\t{\n\t\t\t\tswitch (Code.ArgV[i])\n\t\t\t\t{\n\t\t\t\tcase 7:\n\t\t\t\t\tgDisplayParm.setBrightOrBold(FALSE);\n\t\t\t\t\tgDisplayParm.setItalic(FALSE);\n\t\t\t\t\tgDisplayParm.setUnderline(FALSE);\n\t\t\t\t\tgDisplayParm.setBrightFore(FALSE);\n\t\t\t\t\tgDisplayParm.setBrightBack(FALSE);\n\t\t\t\t\tgDisplayParm.setInverse(FALSE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 15:\n\t\t\t\t\tgDisplayParm.setBrightOrBold(TRUE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 112:\n\t\t\t\t\tgDisplayParm.setInverse(TRUE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 143:\n\t\t\t\t\t// What is this?\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak; // \"|...m\"\n\t}\n}\n\n/// Returns coordinates of either working area (viewPort) or full backscroll buffer\n/// @param hConsoleOutput   if nullptr we process STD_OUTPUT_HANDLE\n/// @param viewPort         if true - returns srWindow, false - full backscroll buffer\n/// @result valid SMALL_RECT\nSMALL_RECT CEAnsi::GetWorkingRegion(HANDLE hConsoleOutput, bool viewPort) const\n{\n\tconst short kFallback = 9999;\n\tSMALL_RECT region = {0, 0, kFallback, kFallback};\n\t// ReSharper disable once CppLocalVariableMayBeConst\n\tHANDLE hConOut = hConsoleOutput ? hConsoleOutput : GetStdHandle(STD_OUTPUT_HANDLE);\n\tCONSOLE_SCREEN_BUFFER_INFO csbi = {};\n\t// If function fails, we return {kFallback, kFallback}\n\tif (GetConsoleScreenBufferInfoCached(hConOut, &csbi, TRUE))\n\t{\n\t\tif (viewPort)\n\t\t{\n\t\t\t// Trick to avoid overflow of SHORT\n\t\t\tregion = MakeSmallRect(\n\t\t\t\tstd::min<WORD>(static_cast<WORD>(csbi.srWindow.Left), std::numeric_limits<SHORT>::max()),\n\t\t\t\tstd::min<WORD>(static_cast<WORD>(csbi.srWindow.Top), std::numeric_limits<SHORT>::max()),\n\t\t\t\tstd::min<WORD>(static_cast<WORD>(csbi.srWindow.Right), std::numeric_limits<SHORT>::max()),\n\t\t\t\tstd::min<WORD>(static_cast<WORD>(csbi.srWindow.Bottom), std::numeric_limits<SHORT>::max())\n\t\t\t);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tregion = MakeSmallRect(\n\t\t\t\t0,\n\t\t\t\t0,\n\t\t\t\tstd::min<WORD>(static_cast<WORD>(csbi.dwSize.X - 1), std::numeric_limits<SHORT>::max()),\n\t\t\t\tstd::min<WORD>(static_cast<WORD>(csbi.dwSize.Y - 1), std::numeric_limits<SHORT>::max())\n\t\t\t);\n\t\t}\n\t\t// Last checks\n\t\tif (region.Right < region.Left)\n\t\t\tregion.Right = region.Left;\n\t\tif (region.Bottom < region.Top)\n\t\t\tregion.Bottom = region.Top;\n\t}\n\treturn region;\n}\n\nvoid CEAnsi::SetScrollRegion(bool bRegion, bool bRelative, int nStart, int nEnd, HANDLE hConsoleOutput) const\n{\n\tif (bRegion && (nStart >= 0) && (nStart <= nEnd))\n\t{\n\t\t// note: the '\\e[0;35r' shall be treated as '\\e[1;35r'\n\t\t_ASSERTE(nStart >= 0 && nEnd >= nStart);\n\t\tconst SMALL_RECT working = GetWorkingRegion(hConsoleOutput, bRelative);\n\t\t_ASSERTE(working.Top>=0 && working.Left>=0 && working.Bottom>=working.Top && working.Right>=working.Left);\n\t\tif (bRelative)\n\t\t{\n\t\t\tnStart += working.Top;\n\t\t\tnEnd += working.Top;\n\t\t}\n\t\t// We need 0-based absolute values\n\t\tgDisplayOpt.ScrollStart = static_cast<SHORT>(std::max<int>(working.Top, std::min<int>(nStart - 1, working.Bottom)));\n\t\tgDisplayOpt.ScrollEnd = static_cast<SHORT>(std::max<int>(working.Top, std::min<int>(nEnd - 1, working.Bottom)));\n\t\t// Validate\n\t\tif (!((gDisplayOpt.ScrollRegion = (gDisplayOpt.ScrollStart>=0 && gDisplayOpt.ScrollEnd>=gDisplayOpt.ScrollStart))))\n\t\t{\n\t\t\t_ASSERTEX(gDisplayOpt.ScrollStart>=0 && gDisplayOpt.ScrollEnd>=gDisplayOpt.ScrollStart);\n\t\t}\n\t\twchar_t szLog[40]; msprintf(szLog, countof(szLog), L\"{%i,%i}\", gDisplayOpt.ScrollStart, gDisplayOpt.ScrollEnd);\n\t}\n\telse\n\t{\n\t\tgDisplayOpt.ScrollRegion = FALSE;\n\t\tDumpKnownEscape(L\"<Disabled>\", 10, de_ScrollRegion);\n\t}\n}\n\nvoid CEAnsi::XTermSaveRestoreCursor(bool bSaveCursor, HANDLE hConsoleOutput /*= nullptr*/)\n{\n\tCONSOLE_SCREEN_BUFFER_INFO csbi = {};\n\t// ReSharper disable once CppLocalVariableMayBeConst\n\tHANDLE hConOut = hConsoleOutput ? hConsoleOutput : GetStdHandle(STD_OUTPUT_HANDLE);\n\n\tif (bSaveCursor)\n\t{\n\t\t// Save cursor position (can not be nested)\n\t\tif (GetConsoleScreenBufferInfoCached(hConOut, &csbi))\n\t\t{\n\t\t\tgDisplayCursor.StoredCursorPos = csbi.dwCursorPosition;\n\t\t\tgDisplayCursor.bCursorPosStored = TRUE;\n\t\t}\n\t}\n\telse\n\t{\n\t\t// Restore cursor position\n\t\tSetConsoleCursorPosition(hConOut, gDisplayCursor.StoredCursorPos);\n\t}\n}\n\nHANDLE CEAnsi::XTermBufferConEmuAlternative()\n{\n\tCONSOLE_SCREEN_BUFFER_INFO csbi1 = {}, csbi2 = {};\n\tHANDLE hOut = GetStdHandle(STD_OUTPUT_HANDLE);\n\t// ReSharper disable once CppLocalVariableMayBeConst\n\tHANDLE hErr = GetStdHandle(STD_ERROR_HANDLE);\n\tghStdOut.SetHandle(hOut, MConHandle::StdMode::Output);\n\tghStdErr.SetHandle(hErr, MConHandle::StdMode::Output);\n\tif (GetConsoleScreenBufferInfoCached(hOut, &csbi1, TRUE))\n\t{\n\t\t// -- Turn on \"alternative\" buffer even if not scrolling exist now\n\t\t//if (csbi.dwSize.Y > (csbi.srWindow.Bottom - csbi.srWindow.Top + 1))\n\t\t{\n\t\t\tCESERVER_REQ *pIn = nullptr, *pOut = nullptr;\n\t\t\tpIn = ExecuteNewCmd(CECMD_ALTBUFFER,sizeof(CESERVER_REQ_HDR)+sizeof(CESERVER_REQ_ALTBUFFER));\n\t\t\tif (pIn)\n\t\t\t{\n\t\t\t\tpIn->AltBuf.AbFlags = abf_BufferOff | abf_SaveContents;\n\t\t\t\tif (isConnectorStarted())\n\t\t\t\t\tpIn->AltBuf.AbFlags |= abf_Connector;\n\t\t\t\t// support \"virtual\" dynamic console buffer height\n\t\t\t\tif (CESERVER_CONSOLE_APP_MAPPING* pAppMap = gpAppMap ? gpAppMap->Ptr() : nullptr)\n\t\t\t\t\tpIn->AltBuf.BufferHeight = std::max(static_cast<SHORT>(pAppMap->nLastConsoleRow), csbi1.srWindow.Bottom);\n\t\t\t\telse\n\t\t\t\t\tpIn->AltBuf.BufferHeight = csbi1.srWindow.Bottom;\n\t\t\t\tpOut = ExecuteSrvCmd(gnServerPID, pIn, ghConWnd);\n\t\t\t\tif (pOut)\n\t\t\t\t{\n\t\t\t\t\tif (!IsWin7Eql())\n\t\t\t\t\t{\n\t\t\t\t\t\tghConOut.Close();\n\t\t\t\t\t\t// ReSharper disable once CppLocalVariableMayBeConst\n\t\t\t\t\t\tHANDLE hNewOut = ghConOut.GetHandle();\n\t\t\t\t\t\tif (hNewOut && hNewOut != INVALID_HANDLE_VALUE)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\thOut = hNewOut;\n\t\t\t\t\t\t\tSetStdHandle(STD_OUTPUT_HANDLE, hNewOut);\n\t\t\t\t\t\t\tSetStdHandle(STD_ERROR_HANDLE, hNewOut);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Ensure we have fresh information (size was changed)\n\t\t\t\t\tGetConsoleScreenBufferInfoCached(hOut, &csbi2, TRUE);\n\n\t\t\t\t\t// Clear current screen contents, don't move cursor position\n\t\t\t\t\tconst DWORD nChars = csbi2.dwSize.X * csbi2.dwSize.Y;\n\t\t\t\t\tExtFillOutputParm fill = {sizeof(fill), efof_Current|efof_Attribute|efof_Character,\n\t\t\t\t\t\thOut, {}, L' ', {}, static_cast<DWORD>(nChars) };\n\t\t\t\t\tExtFillOutput(&fill);\n\n\t\t\t\t\tTODO(\"BufferWidth\");\n\t\t\t\t\tif (!(gXTermAltBuffer.Flags & xtb_AltBuffer))\n\t\t\t\t\t{\n\t\t\t\t\t\t// Backscroll length\n\t\t\t\t\t\tgXTermAltBuffer.BufferSize = (csbi1.dwSize.Y > (csbi1.srWindow.Bottom - csbi1.srWindow.Top + 1))\n\t\t\t\t\t\t\t? csbi1.dwSize.Y : 0;\n\t\t\t\t\t\tgXTermAltBuffer.Flags = xtb_AltBuffer;\n\t\t\t\t\t\t// Stored cursor pos\n\t\t\t\t\t\tif (gDisplayCursor.bCursorPosStored)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tgXTermAltBuffer.CursorPos = gDisplayCursor.StoredCursorPos;\n\t\t\t\t\t\t\tgXTermAltBuffer.Flags |= xtb_StoredCursor;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Stored scroll region\n\t\t\t\t\t\tif (gDisplayOpt.ScrollRegion)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tgXTermAltBuffer.ScrollStart = gDisplayOpt.ScrollStart;\n\t\t\t\t\t\t\tgXTermAltBuffer.ScrollEnd = gDisplayOpt.ScrollEnd;\n\t\t\t\t\t\t\tgXTermAltBuffer.Flags |= xtb_StoredScrollRegion;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tExecuteFreeResult(pIn);\n\t\t\t\tExecuteFreeResult(pOut);\n\t\t\t}\n\t\t}\n\t}\n\treturn hOut;\n}\n\nHANDLE CEAnsi::XTermBufferConEmuPrimary()\n{\n\t// \u0421\u0431\u0440\u043e\u0441 \u0440\u0430\u0441\u0448\u0438\u0440\u0435\u043d\u043d\u044b\u0445 \u0430\u0442\u0440\u0438\u0431\u0443\u0442\u043e\u0432!\n\tCONSOLE_SCREEN_BUFFER_INFO csbi = {};\n\tHANDLE hOut = GetStdHandle(STD_OUTPUT_HANDLE);\n\tif (GetConsoleScreenBufferInfoCached(hOut, &csbi, TRUE))\n\t{\n\t\tconst WORD nDefAttr = GetDefaultTextAttr();\n\t\t// \u0421\u0431\u0440\u043e\u0441 \u0442\u043e\u043b\u044c\u043a\u043e \u0440\u0430\u0441\u0448\u0438\u0440\u0435\u043d\u043d\u044b\u0445 \u0430\u0442\u0440\u0438\u0431\u0443\u0442\u043e\u0432\n\t\tExtFillOutputParm fill = {sizeof(fill), /*efof_ResetExt|*/efof_Attribute/*|efof_Character*/, hOut,\n\t\t\t{ConEmu::ColorFlags::None, CONFORECOLOR(nDefAttr), CONBACKCOLOR(nDefAttr)},\n\t\t\tL' ', {0,0}, static_cast<DWORD>(csbi.dwSize.X * csbi.dwSize.Y)};\n\t\tExtFillOutput(&fill);\n\t\tCEAnsi* pObj = CEAnsi::Object();\n\t\tif (pObj)\n\t\t\tpObj->ReSetDisplayParm(hOut, TRUE, TRUE);\n\t\telse\n\t\t\tSetConsoleTextAttribute(hOut, nDefAttr);\n\t}\n\n\tif (!IsWin7Eql() && ghStdOut.HasHandle())\n\t{\n\t\tSetStdHandle(STD_OUTPUT_HANDLE, ghStdOut);\n\t\tSetStdHandle(STD_ERROR_HANDLE, ghStdErr);\n\t\thOut = ghStdOut.Release();\n\t\tghConOut.Close();\n\t}\n\n\t// restore backscroll size and data\n\tCESERVER_REQ *pIn = nullptr, *pOut = nullptr;\n\tpIn = ExecuteNewCmd(CECMD_ALTBUFFER,sizeof(CESERVER_REQ_HDR)+sizeof(CESERVER_REQ_ALTBUFFER));\n\tif (pIn)\n\t{\n\t\tTODO(\"BufferWidth\");\n\t\tpIn->AltBuf.AbFlags = abf_BufferOn | abf_RestoreContents;\n\t\tif (!gXTermAltBuffer.BufferSize)\n\t\t\tpIn->AltBuf.AbFlags |= abf_BufferOff;\n\t\tif (isConnectorStarted())\n\t\t\tpIn->AltBuf.AbFlags |= abf_Connector;\n\t\tpIn->AltBuf.BufferHeight = static_cast<USHORT>(gXTermAltBuffer.BufferSize);\n\t\t// Async - is not allowed. Otherwise current application (cmd.exe for example)\n\t\t// may start printing before server finishes buffer restoration\n\t\tpOut = ExecuteSrvCmd(gnServerPID, pIn, ghConWnd);\n\t\tExecuteFreeResult(pIn);\n\t\tExecuteFreeResult(pOut);\n\t\t// Restore saved states\n\t\tif ((gDisplayCursor.bCursorPosStored = !!(gXTermAltBuffer.Flags & xtb_StoredCursor)))\n\t\t{\n\t\t\tgDisplayCursor.StoredCursorPos = gXTermAltBuffer.CursorPos;\n\t\t}\n\t\tif ((gDisplayOpt.ScrollRegion = !!(gXTermAltBuffer.Flags & xtb_StoredScrollRegion)))\n\t\t{\n\t\t\tgDisplayOpt.ScrollStart = gXTermAltBuffer.ScrollStart;\n\t\t\tgDisplayOpt.ScrollEnd = gXTermAltBuffer.ScrollEnd;\n\t\t}\n\t}\n\treturn hOut;\n}\n\n#if 0\nHANDLE CEAnsi::XTermBufferWin10(const int mode, const bool bSetAltBuffer)\n{\n\tORIGINAL_KRNL(WriteFile);\n\tconst HANDLE std_out = GetStdHandle(STD_OUTPUT_HANDLE);\n\tchar ansi_seq[32];\n\tsprintf_c(ansi_seq, \"\\x1b[?%i%c\", mode, bSetAltBuffer ? 'h' : 'l');\n\tconst DWORD write_len = static_cast<DWORD>(strlen(ansi_seq));\n\tDWORD written = 0;\n\tconst auto rc = F(WriteFile)(std_out, ansi_seq, write_len, &written, nullptr);\n\t_ASSERTEX(rc && written == write_len);\n\treturn std_out;\n}\n#endif\n\n/// Change current buffer\n/// Alternative buffer in XTerm is used to \"fullscreen\"\n/// applications like Vim. There is no scrolling and this\n/// mode is used to save current backscroll contents and\n/// restore it when application exits\nHANDLE CEAnsi::XTermAltBuffer(const bool bSetAltBuffer, const int mode)\n{\n\tif (bSetAltBuffer)\n\t{\n\t\t// Once!\n\t\tif ((gXTermAltBuffer.Flags & xtb_AltBuffer))\n\t\t\treturn GetStdHandle(STD_OUTPUT_HANDLE);\n\n\t\t#if 0\n\t\t// Can utilize Conhost V2 ANSI?\n\t\tif (gbIsSshProcess && IsWin10())\n\t\t{\n\t\t\tgXTermAltBuffer.Flags |= xtb_AltBuffer;\n\t\t\treturn XTermBufferWin10(mode, bSetAltBuffer);\n\t\t}\n\t\t#endif\n\n\t\treturn XTermBufferConEmuAlternative();\n\t}\n\telse\n\t{\n\t\tif (!(gXTermAltBuffer.Flags & xtb_AltBuffer))\n\t\t\treturn GetStdHandle(STD_OUTPUT_HANDLE);\n\n\t\t// Once!\n\t\tgXTermAltBuffer.Flags &= ~xtb_AltBuffer;\n\n\t\t#if 0\n\t\t// Can utilize Conhost V2 ANSI?\n\t\tif (gbIsSshProcess && IsWin10())\n\t\t\treturn XTermBufferWin10(mode, bSetAltBuffer);\n\t\t#endif\n\n\t\treturn XTermBufferConEmuPrimary();\n\t}\n}\n\n/*\nViM need some hacks in current ConEmu versions\nThis is because\n1) 256 colors mode requires NO scroll buffer\n2) can't find ATM legal way to switch Alternative/Primary buffer by request from ViM\n*/\n\nHANDLE CEAnsi::StartVimTerm(bool bFromDllStart)\n{\n\t// Only certain versions of Vim able to use xterm-256 in ConEmu\n\tif (gnExeFlags & (caf_Cygwin1|caf_Msys1|caf_Msys2))\n\t\treturn GetStdHandle(STD_OUTPUT_HANDLE);\n\n\t// For native vim - don't handle \"--help\" and \"--version\" switches\n\t// Has no sense for cygwin/msys, but they are skipped above\n\tCmdArg lsArg;\n\tLPCWSTR pszCmdLine = GetCommandLineW();\n\tLPCWSTR pszCompare[] = {L\"--help\", L\"-h\", L\"--version\", nullptr};\n\twhile ((pszCmdLine = NextArg(pszCmdLine, lsArg)))\n\t{\n\t\tfor (INT_PTR i = 0; pszCompare[i]; i++)\n\t\t{\n\t\t\tif (wcscmp(lsArg, pszCompare[i]) == 0)\n\t\t\t\treturn GetStdHandle(STD_OUTPUT_HANDLE);\n\t\t}\n\t}\n\n\treturn XTermAltBuffer(true);\n}\n\nHANDLE CEAnsi::StopVimTerm()\n{\n\tif (gbIsXTermOutput)\n\t{\n\t\tDBG_XTERM(L\"xTermOutput=OFF due Vim stop\");\n\t\tDBG_XTERM(L\"AutoLfNl=ON due Vim stop\");\n\t\tDBG_XTERM(L\"term=Win32 due Vim stop\");\n\t\tCEAnsi::StartXTermMode(false);\n\t}\n\n\treturn XTermAltBuffer(false);\n}\n\nvoid CEAnsi::InitTermMode()\n{\n\tbool needSetXterm = false;\n\n\tif (IsWin10())\n\t{\n\t\tconst MHandle hOut{ GetStdHandle(STD_OUTPUT_HANDLE) };\n\t\tgPrevConOutMode = 0;\n\t\tif (GetConsoleMode(hOut, &gPrevConOutMode))\n\t\t{\n\t\t\tif (gPrevConOutMode & ENABLE_VIRTUAL_TERMINAL_PROCESSING)\n\t\t\t{\n\t\t\t\tneedSetXterm = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (gbIsVimProcess)\n\t{\n\t\tStartVimTerm(true);\n\t\t_ASSERTE(CEAnsi::gbIsXTermOutput == true);\n\t}\n\n\tif (needSetXterm)\n\t{\n\t\tDBG_XTERM(L\"xTermOutput=ON due ENABLE_VIRTUAL_TERMINAL_PROCESSING in InitTermMode\");\n\t\tDBG_XTERM(L\"AutoLfNl=OFF due ENABLE_VIRTUAL_TERMINAL_PROCESSING in InitTermMode\");\n\t\tDBG_XTERM(L\"term=XTerm due ENABLE_VIRTUAL_TERMINAL_PROCESSING in InitTermMode\");\n\t\tStartXTermMode(true);\n\t}\n\n\tif (CEAnsi::gbIsXTermOutput && gPrevConOutMode)\n\t{\n\t\tconst bool autoLfNl = (gPrevConOutMode & DISABLE_NEWLINE_AUTO_RETURN) == 0;\n\t\tif (CEAnsi::IsAutoLfNl() != autoLfNl)\n\t\t{\n\t\t\tCEAnsi::SetAutoLfNl(autoLfNl);\n\t\t}\n\t}\n}\n\nvoid CEAnsi::DoneTermMode()\n{\n\tif (gbIsXTermOutput && (gPrevConOutMode & ENABLE_VIRTUAL_TERMINAL_PROCESSING))\n\t{\n\t\t// If XTerm was enabled already before process start, no need to disable it\n\t\tDBG_XTERM(L\"xTermOutput=OFF due previous !ENABLE_VIRTUAL_TERMINAL_PROCESSING in DoneTermMode\");\n\t\tSetIsXTermOutput(false); // just reset\n\t}\n\n\tif (gbIsVimProcess)\n\t{\n\t\tDBG_XTERM(L\"StopVimTerm in DoneTermMode\");\n\t\tStopVimTerm();\n\t}\n\telse if (CEAnsi::gbIsXTermOutput)\n\t{\n\t\tDBG_XTERM(L\"xTermOutput=OFF in DoneTermMode\");\n\t\tDBG_XTERM(L\"AutoLfNl=ON in DoneTermMode\");\n\t\tDBG_XTERM(L\"term=Win32 in DoneTermMode\");\n\t\tStartXTermMode(false);\n\t}\n}\n\nvoid CEAnsi::ChangeTermMode(TermModeCommand mode, DWORD value, DWORD nPID /*= 0*/)\n{\n\tCESERVER_REQ* pIn = ExecuteNewCmd(CECMD_STARTXTERM, sizeof(CESERVER_REQ_HDR) + 3 * sizeof(DWORD));\n\tif (pIn)\n\t{\n\t\tpIn->dwData[0] = mode;\n\t\tpIn->dwData[1] = value;  // NOLINT(clang-diagnostic-array-bounds)\n\t\tpIn->dwData[2] = nPID ? nPID : GetCurrentProcessId();  // NOLINT(clang-diagnostic-array-bounds)\n\t\tCESERVER_REQ* pOut = ExecuteSrvCmd(gnServerPID, pIn, ghConWnd);\n\t\tExecuteFreeResult(pIn);\n\t\tExecuteFreeResult(pOut);\n\t}\n\n\tif (mode < countof(gWasXTermModeSet))\n\t{\n\t\tgWasXTermModeSet[mode] = { value, nPID ? nPID : GetCurrentProcessId() };\n\t}\n}\n\nvoid CEAnsi::StartXTermMode(const bool bStart)\n{\n\t// May be triggered by connector, official Vim builds, ENABLE_VIRTUAL_TERMINAL_INPUT, \"ESC ] 9 ; 10 ; 1 ST\"\n\t_ASSERTEX(gbIsXTermOutput != bStart);\n\n\tStartXTermOutput(bStart);\n\n\t// Remember last mode and pass to server\n\tChangeTermMode(tmc_TerminalType, bStart ? te_xterm : te_win32);\n}\n\nvoid CEAnsi::SetIsXTermOutput(const bool value)\n{\n\tif (gbIsXTermOutput != value)\n\t{\n\t\tgbIsXTermOutput = value;\n\t}\n}\n\nvoid CEAnsi::DebugXtermOutput(const wchar_t* message)\n{\n#ifdef _DEBUG\n\twchar_t dbgOut[512];\n\tmsprintf(dbgOut, countof(dbgOut), L\"XTerm: %s PID=%u TID=%u: %s\\n\",\n\t\tgsExeName, GetCurrentProcessId(), GetCurrentThreadId(), message);\n\tOutputDebugStringW(dbgOut);\n#endif\n}\n\nvoid CEAnsi::StartXTermOutput(const bool bStart)\n{\n\t// Remember last mode\n\tSetIsXTermOutput(bStart);\n\t// Set AutoLfNl according to mode\n\tSetAutoLfNl(bStart ? false : true);\n}\n\nvoid CEAnsi::RefreshXTermModes()\n{\n\tif (!gbIsXTermOutput)\n\t\treturn;\n\tfor (int i = 0; i < static_cast<int>(countof(gWasXTermModeSet)); ++i)\n\t{\n\t\tif (!gWasXTermModeSet[i].pid)\n\t\t\tcontinue;\n\t\t_ASSERTE(i != tmc_ConInMode);\n\t\tChangeTermMode(static_cast<TermModeCommand>(i), gWasXTermModeSet[i].value, gWasXTermModeSet[i].pid);\n\t}\n}\n\nvoid CEAnsi::SetAutoLfNl(const bool autoLfNl)\n{\n\tif (static_cast<bool>(gDisplayOpt.AutoLfNl) != autoLfNl)\n\t{\n\t\tgDisplayOpt.AutoLfNl = autoLfNl;\n\t}\n}\n\nbool CEAnsi::IsAutoLfNl()\n{\n\t// #TODO check for gbIsXTermOutput?\n\treturn gDisplayOpt.AutoLfNl;\n}\n\n// This is useful when user press Shift+Home,\n// we'll select only \"typed command\" part, without \"prompt\"\nvoid CEAnsi::StorePromptBegin()\n{\n\tCONSOLE_SCREEN_BUFFER_INFO csbi = {};\n\t// ReSharper disable once CppLocalVariableMayBeConst\n\tHANDLE hConOut = GetStdHandle(STD_OUTPUT_HANDLE);\n\tif (GetConsoleScreenBufferInfo(hConOut, &csbi))\n\t{\n\t\tOnReadConsoleBefore(hConOut, csbi);\n\t}\n}\n\nvoid CEAnsi::StorePromptReset()\n{\n\tCESERVER_CONSOLE_APP_MAPPING* pAppMap = gpAppMap ? gpAppMap->Ptr() : nullptr;\n\tif (pAppMap)\n\t{\n\t\tpAppMap->csbiPreRead.dwCursorPosition = COORD{0, 0};\n\t}\n}\n\n\n//static, thread local singleton\nCEAnsi* CEAnsi::Object()\n{\n\tCLastErrorGuard errGuard;\n\n\tif (!gAnsiTlsIndex)\n\t{\n\t\tgAnsiTlsIndex = TlsAlloc();\n\t}\n\n\tif ((!gAnsiTlsIndex) || (gAnsiTlsIndex == TLS_OUT_OF_INDEXES))\n\t{\n\t\t_ASSERTEX(gAnsiTlsIndex && gAnsiTlsIndex != TLS_OUT_OF_INDEXES);\n\t\treturn nullptr;\n\t}\n\n\t// Don't use thread_local, it doesn't work in WinXP in dynamically loaded dlls\n\tCEAnsi* obj = static_cast<CEAnsi*>(TlsGetValue(gAnsiTlsIndex));\n\tif (!obj)\n\t{\n\t\tobj = new CEAnsi;\n\t\tif (obj)\n\t\t\tobj->GetDefaultTextAttr(); // Initialize \"default attributes\"\n\t\tTlsSetValue(gAnsiTlsIndex, obj);\n\t}\n\n\treturn obj;\n}\n\n//static\nvoid CEAnsi::Release()\n{\n\tif (gAnsiTlsIndex && (gAnsiTlsIndex != TLS_OUT_OF_INDEXES))\n\t{\n\t\tCEAnsi* p = static_cast<CEAnsi*>(TlsGetValue(gAnsiTlsIndex));\n\t\tif (p)\n\t\t{\n\t\t\tif (IsHeapInitialized())\n\t\t\t{\n\t\t\t\tdelete p;\n\t\t\t}\n\t\t\tTlsSetValue(gAnsiTlsIndex, nullptr);\n\t\t}\n\t}\n}\n"], "filenames": ["src/ConEmuCD/ConAnsiImpl.cpp", "src/ConEmuHk/Ansi.cpp"], "buggy_code_start_loc": [988, 2508], "buggy_code_end_loc": [2478, 2509], "fixing_code_start_loc": [988, 2508], "fixing_code_end_loc": [2476, 2509], "type": "NVD-CWE-noinfo", "message": "ConEmu before commit 230724 does not sanitize title responses correctly for control characters, potentially leading to arbitrary code execution. This is related to an incomplete fix for CVE-2022-46387.", "other": {"cve": {"id": "CVE-2023-39150", "sourceIdentifier": "cve@mitre.org", "published": "2023-09-12T13:15:07.897", "lastModified": "2023-10-05T13:14:16.257", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "ConEmu before commit 230724 does not sanitize title responses correctly for control characters, potentially leading to arbitrary code execution. This is related to an incomplete fix for CVE-2022-46387."}, {"lang": "es", "value": "ConEmu antes del commit 230724 no sanitiza correctamente las respuestas de t\u00edtulo para los caracteres de control, lo que podr\u00eda provocar la ejecuci\u00f3n de c\u00f3digo arbitrario. Esto est\u00e1 relacionado con una soluci\u00f3n incompleta para CVE-2022-46387."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:maximus5:conemu:*:*:*:*:*:*:*:*", "versionEndExcluding": "23.07.24", "matchCriteriaId": "7CB8E253-F071-4DEF-8E76-1B1D7DD8B4E0"}]}]}], "references": [{"url": "https://gist.github.com/dgl/081cf503dc635df39d844e058a6d4c88", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/Maximus5/ConEmu/commit/60683a186628ffaa7689fcb64b3c38ced69287c1", "source": "cve@mitre.org", "tags": ["Patch"]}]}, "github_commit_url": "https://github.com/Maximus5/ConEmu/commit/60683a186628ffaa7689fcb64b3c38ced69287c1"}}