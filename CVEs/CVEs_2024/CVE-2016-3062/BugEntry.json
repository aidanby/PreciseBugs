{"buggy_code": ["/*\n * MOV demuxer\n * Copyright (c) 2001 Fabrice Bellard\n * Copyright (c) 2009 Baptiste Coudurier <baptiste dot coudurier at gmail dot com>\n *\n * This file is part of FFmpeg.\n *\n * FFmpeg is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with FFmpeg; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n#include <limits.h>\n\n//#define DEBUG\n//#define MOV_EXPORT_ALL_METADATA\n\n#include \"libavutil/audioconvert.h\"\n#include \"libavutil/intreadwrite.h\"\n#include \"libavutil/intfloat.h\"\n#include \"libavutil/mathematics.h\"\n#include \"libavutil/avstring.h\"\n#include \"libavutil/dict.h\"\n#include \"libavutil/opt.h\"\n#include \"libavutil/timecode.h\"\n#include \"libavcodec/ac3tab.h\"\n#include \"avformat.h\"\n#include \"internal.h\"\n#include \"avio_internal.h\"\n#include \"riff.h\"\n#include \"isom.h\"\n#include \"libavcodec/get_bits.h\"\n#include \"id3v1.h\"\n#include \"mov_chan.h\"\n\n#if CONFIG_ZLIB\n#include <zlib.h>\n#endif\n\n/*\n * First version by Francois Revol revol@free.fr\n * Seek function by Gael Chardon gael.dev@4now.net\n */\n\n#include \"qtpalette.h\"\n\n\n#undef NDEBUG\n#include <assert.h>\n\n/* those functions parse an atom */\n/* links atom IDs to parse functions */\ntypedef struct MOVParseTableEntry {\n    uint32_t type;\n    int (*parse)(MOVContext *ctx, AVIOContext *pb, MOVAtom atom);\n} MOVParseTableEntry;\n\nstatic const MOVParseTableEntry mov_default_parse_table[];\n\nstatic int mov_metadata_track_or_disc_number(MOVContext *c, AVIOContext *pb,\n                                             unsigned len, const char *key)\n{\n    char buf[16];\n\n    short current, total = 0;\n    avio_rb16(pb); // unknown\n    current = avio_rb16(pb);\n    if (len >= 6)\n        total = avio_rb16(pb);\n    if (!total)\n        snprintf(buf, sizeof(buf), \"%d\", current);\n    else\n        snprintf(buf, sizeof(buf), \"%d/%d\", current, total);\n    av_dict_set(&c->fc->metadata, key, buf, 0);\n\n    return 0;\n}\n\nstatic int mov_metadata_int8_bypass_padding(MOVContext *c, AVIOContext *pb,\n                                            unsigned len, const char *key)\n{\n    char buf[16];\n\n    /* bypass padding bytes */\n    avio_r8(pb);\n    avio_r8(pb);\n    avio_r8(pb);\n\n    snprintf(buf, sizeof(buf), \"%d\", avio_r8(pb));\n    av_dict_set(&c->fc->metadata, key, buf, 0);\n\n    return 0;\n}\n\nstatic int mov_metadata_int8_no_padding(MOVContext *c, AVIOContext *pb,\n                                        unsigned len, const char *key)\n{\n    char buf[16];\n\n    snprintf(buf, sizeof(buf), \"%d\", avio_r8(pb));\n    av_dict_set(&c->fc->metadata, key, buf, 0);\n\n    return 0;\n}\n\nstatic int mov_metadata_gnre(MOVContext *c, AVIOContext *pb,\n                             unsigned len, const char *key)\n{\n    short genre;\n    char buf[20];\n\n    avio_r8(pb); // unknown\n\n    genre = avio_r8(pb);\n    if (genre < 1 || genre > ID3v1_GENRE_MAX)\n        return 0;\n    snprintf(buf, sizeof(buf), \"%s\", ff_id3v1_genre_str[genre-1]);\n    av_dict_set(&c->fc->metadata, key, buf, 0);\n\n    return 0;\n}\n\nstatic const uint32_t mac_to_unicode[128] = {\n    0x00C4,0x00C5,0x00C7,0x00C9,0x00D1,0x00D6,0x00DC,0x00E1,\n    0x00E0,0x00E2,0x00E4,0x00E3,0x00E5,0x00E7,0x00E9,0x00E8,\n    0x00EA,0x00EB,0x00ED,0x00EC,0x00EE,0x00EF,0x00F1,0x00F3,\n    0x00F2,0x00F4,0x00F6,0x00F5,0x00FA,0x00F9,0x00FB,0x00FC,\n    0x2020,0x00B0,0x00A2,0x00A3,0x00A7,0x2022,0x00B6,0x00DF,\n    0x00AE,0x00A9,0x2122,0x00B4,0x00A8,0x2260,0x00C6,0x00D8,\n    0x221E,0x00B1,0x2264,0x2265,0x00A5,0x00B5,0x2202,0x2211,\n    0x220F,0x03C0,0x222B,0x00AA,0x00BA,0x03A9,0x00E6,0x00F8,\n    0x00BF,0x00A1,0x00AC,0x221A,0x0192,0x2248,0x2206,0x00AB,\n    0x00BB,0x2026,0x00A0,0x00C0,0x00C3,0x00D5,0x0152,0x0153,\n    0x2013,0x2014,0x201C,0x201D,0x2018,0x2019,0x00F7,0x25CA,\n    0x00FF,0x0178,0x2044,0x20AC,0x2039,0x203A,0xFB01,0xFB02,\n    0x2021,0x00B7,0x201A,0x201E,0x2030,0x00C2,0x00CA,0x00C1,\n    0x00CB,0x00C8,0x00CD,0x00CE,0x00CF,0x00CC,0x00D3,0x00D4,\n    0xF8FF,0x00D2,0x00DA,0x00DB,0x00D9,0x0131,0x02C6,0x02DC,\n    0x00AF,0x02D8,0x02D9,0x02DA,0x00B8,0x02DD,0x02DB,0x02C7,\n};\n\nstatic int mov_read_mac_string(MOVContext *c, AVIOContext *pb, int len,\n                               char *dst, int dstlen)\n{\n    char *p = dst;\n    char *end = dst+dstlen-1;\n    int i;\n\n    for (i = 0; i < len; i++) {\n        uint8_t t, c = avio_r8(pb);\n        if (c < 0x80 && p < end)\n            *p++ = c;\n        else if (p < end)\n            PUT_UTF8(mac_to_unicode[c-0x80], t, if (p < end) *p++ = t;);\n    }\n    *p = 0;\n    return p - dst;\n}\n\nstatic int mov_read_udta_string(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n#ifdef MOV_EXPORT_ALL_METADATA\n    char tmp_key[5];\n#endif\n    char str[1024], key2[16], language[4] = {0};\n    const char *key = NULL;\n    uint16_t str_size, langcode = 0;\n    uint32_t data_type = 0;\n    int (*parse)(MOVContext*, AVIOContext*, unsigned, const char*) = NULL;\n\n    switch (atom.type) {\n    case MKTAG(0xa9,'n','a','m'): key = \"title\";     break;\n    case MKTAG(0xa9,'a','u','t'):\n    case MKTAG(0xa9,'A','R','T'): key = \"artist\";    break;\n    case MKTAG( 'a','A','R','T'): key = \"album_artist\";    break;\n    case MKTAG(0xa9,'w','r','t'): key = \"composer\";  break;\n    case MKTAG( 'c','p','r','t'):\n    case MKTAG(0xa9,'c','p','y'): key = \"copyright\"; break;\n    case MKTAG(0xa9,'g','r','p'): key = \"grouping\"; break;\n    case MKTAG(0xa9,'l','y','r'): key = \"lyrics\"; break;\n    case MKTAG(0xa9,'c','m','t'):\n    case MKTAG(0xa9,'i','n','f'): key = \"comment\";   break;\n    case MKTAG(0xa9,'a','l','b'): key = \"album\";     break;\n    case MKTAG(0xa9,'d','a','y'): key = \"date\";      break;\n    case MKTAG(0xa9,'g','e','n'): key = \"genre\";     break;\n    case MKTAG( 'g','n','r','e'): key = \"genre\";\n        parse = mov_metadata_gnre; break;\n    case MKTAG(0xa9,'t','o','o'):\n    case MKTAG(0xa9,'s','w','r'): key = \"encoder\";   break;\n    case MKTAG(0xa9,'e','n','c'): key = \"encoder\";   break;\n    case MKTAG( 'd','e','s','c'): key = \"description\";break;\n    case MKTAG( 'l','d','e','s'): key = \"synopsis\";  break;\n    case MKTAG( 't','v','s','h'): key = \"show\";      break;\n    case MKTAG( 't','v','e','n'): key = \"episode_id\";break;\n    case MKTAG( 't','v','n','n'): key = \"network\";   break;\n    case MKTAG( 't','r','k','n'): key = \"track\";\n        parse = mov_metadata_track_or_disc_number; break;\n    case MKTAG( 'd','i','s','k'): key = \"disc\";\n        parse = mov_metadata_track_or_disc_number; break;\n    case MKTAG( 't','v','e','s'): key = \"episode_sort\";\n        parse = mov_metadata_int8_bypass_padding; break;\n    case MKTAG( 't','v','s','n'): key = \"season_number\";\n        parse = mov_metadata_int8_bypass_padding; break;\n    case MKTAG( 's','t','i','k'): key = \"media_type\";\n        parse = mov_metadata_int8_no_padding; break;\n    case MKTAG( 'h','d','v','d'): key = \"hd_video\";\n        parse = mov_metadata_int8_no_padding; break;\n    case MKTAG( 'p','g','a','p'): key = \"gapless_playback\";\n        parse = mov_metadata_int8_no_padding; break;\n    }\n\n    if (c->itunes_metadata && atom.size > 8) {\n        int data_size = avio_rb32(pb);\n        int tag = avio_rl32(pb);\n        if (tag == MKTAG('d','a','t','a')) {\n            data_type = avio_rb32(pb); // type\n            avio_rb32(pb); // unknown\n            str_size = data_size - 16;\n            atom.size -= 16;\n        } else return 0;\n    } else if (atom.size > 4 && key && !c->itunes_metadata) {\n        str_size = avio_rb16(pb); // string length\n        langcode = avio_rb16(pb);\n        ff_mov_lang_to_iso639(langcode, language);\n        atom.size -= 4;\n    } else\n        str_size = atom.size;\n\n#ifdef MOV_EXPORT_ALL_METADATA\n    if (!key) {\n        snprintf(tmp_key, 5, \"%.4s\", (char*)&atom.type);\n        key = tmp_key;\n    }\n#endif\n\n    if (!key)\n        return 0;\n    if (atom.size < 0)\n        return AVERROR_INVALIDDATA;\n\n    str_size = FFMIN3(sizeof(str)-1, str_size, atom.size);\n\n    if (parse)\n        parse(c, pb, str_size, key);\n    else {\n        if (data_type == 3 || (data_type == 0 && (langcode < 0x400 || langcode == 0x7fff))) { // MAC Encoded\n            mov_read_mac_string(c, pb, str_size, str, sizeof(str));\n        } else {\n            avio_read(pb, str, str_size);\n            str[str_size] = 0;\n        }\n        av_dict_set(&c->fc->metadata, key, str, 0);\n        if (*language && strcmp(language, \"und\")) {\n            snprintf(key2, sizeof(key2), \"%s-%s\", key, language);\n            av_dict_set(&c->fc->metadata, key2, str, 0);\n        }\n    }\n    av_dlog(c->fc, \"lang \\\"%3s\\\" \", language);\n    av_dlog(c->fc, \"tag \\\"%s\\\" value \\\"%s\\\" atom \\\"%.4s\\\" %d %\"PRId64\"\\n\",\n            key, str, (char*)&atom.type, str_size, atom.size);\n\n    return 0;\n}\n\nstatic int mov_read_chpl(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    int64_t start;\n    int i, nb_chapters, str_len, version;\n    char str[256+1];\n\n    if ((atom.size -= 5) < 0)\n        return 0;\n\n    version = avio_r8(pb);\n    avio_rb24(pb);\n    if (version)\n        avio_rb32(pb); // ???\n    nb_chapters = avio_r8(pb);\n\n    for (i = 0; i < nb_chapters; i++) {\n        if (atom.size < 9)\n            return 0;\n\n        start = avio_rb64(pb);\n        str_len = avio_r8(pb);\n\n        if ((atom.size -= 9+str_len) < 0)\n            return 0;\n\n        avio_read(pb, str, str_len);\n        str[str_len] = 0;\n        avpriv_new_chapter(c->fc, i, (AVRational){1,10000000}, start, AV_NOPTS_VALUE, str);\n    }\n    return 0;\n}\n\nstatic int mov_read_default(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    int64_t total_size = 0;\n    MOVAtom a;\n    int i;\n\n    if (atom.size < 0)\n        atom.size = INT64_MAX;\n    while (total_size + 8 <= atom.size && !url_feof(pb)) {\n        int (*parse)(MOVContext*, AVIOContext*, MOVAtom) = NULL;\n        a.size = atom.size;\n        a.type=0;\n        if (atom.size >= 8) {\n            a.size = avio_rb32(pb);\n            a.type = avio_rl32(pb);\n            if (atom.type != MKTAG('r','o','o','t') &&\n                atom.type != MKTAG('m','o','o','v'))\n            {\n                if (a.type == MKTAG('t','r','a','k') || a.type == MKTAG('m','d','a','t'))\n                {\n                    av_log(c->fc, AV_LOG_ERROR, \"Broken file, trak/mdat not at top-level\\n\");\n                    avio_skip(pb, -8);\n                    return 0;\n                }\n            }\n            total_size += 8;\n            if (a.size == 1) { /* 64 bit extended size */\n                a.size = avio_rb64(pb) - 8;\n                total_size += 8;\n            }\n        }\n        av_dlog(c->fc, \"type: %08x '%.4s' parent:'%.4s' sz: %\"PRId64\" %\"PRId64\" %\"PRId64\"\\n\",\n                a.type, (char*)&a.type, (char*)&atom.type, a.size, total_size, atom.size);\n        if (a.size == 0) {\n            a.size = atom.size - total_size + 8;\n        }\n        a.size -= 8;\n        if (a.size < 0)\n            break;\n        a.size = FFMIN(a.size, atom.size - total_size);\n\n        for (i = 0; mov_default_parse_table[i].type; i++)\n            if (mov_default_parse_table[i].type == a.type) {\n                parse = mov_default_parse_table[i].parse;\n                break;\n            }\n\n        // container is user data\n        if (!parse && (atom.type == MKTAG('u','d','t','a') ||\n                       atom.type == MKTAG('i','l','s','t')))\n            parse = mov_read_udta_string;\n\n        if (!parse) { /* skip leaf atoms data */\n            avio_skip(pb, a.size);\n        } else {\n            int64_t start_pos = avio_tell(pb);\n            int64_t left;\n            int err = parse(c, pb, a);\n            if (err < 0)\n                return err;\n            if (c->found_moov && c->found_mdat &&\n                ((!pb->seekable || c->fc->flags & AVFMT_FLAG_IGNIDX) ||\n                 start_pos + a.size == avio_size(pb))) {\n                if (!pb->seekable || c->fc->flags & AVFMT_FLAG_IGNIDX)\n                    c->next_root_atom = start_pos + a.size;\n                return 0;\n            }\n            left = a.size - avio_tell(pb) + start_pos;\n            if (left > 0) /* skip garbage at atom end */\n                avio_skip(pb, left);\n        }\n\n        total_size += a.size;\n    }\n\n    if (total_size < atom.size && atom.size < 0x7ffff)\n        avio_skip(pb, atom.size - total_size);\n\n    return 0;\n}\n\nstatic int mov_read_dref(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    MOVStreamContext *sc;\n    int entries, i, j;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n    sc = st->priv_data;\n\n    avio_rb32(pb); // version + flags\n    entries = avio_rb32(pb);\n    if (entries >= UINT_MAX / sizeof(*sc->drefs))\n        return AVERROR_INVALIDDATA;\n    av_free(sc->drefs);\n    sc->drefs = av_mallocz(entries * sizeof(*sc->drefs));\n    if (!sc->drefs)\n        return AVERROR(ENOMEM);\n    sc->drefs_count = entries;\n\n    for (i = 0; i < sc->drefs_count; i++) {\n        MOVDref *dref = &sc->drefs[i];\n        uint32_t size = avio_rb32(pb);\n        int64_t next = avio_tell(pb) + size - 4;\n\n        if (size < 12)\n            return AVERROR_INVALIDDATA;\n\n        dref->type = avio_rl32(pb);\n        avio_rb32(pb); // version + flags\n        av_dlog(c->fc, \"type %.4s size %d\\n\", (char*)&dref->type, size);\n\n        if (dref->type == MKTAG('a','l','i','s') && size > 150) {\n            /* macintosh alias record */\n            uint16_t volume_len, len;\n            int16_t type;\n\n            avio_skip(pb, 10);\n\n            volume_len = avio_r8(pb);\n            volume_len = FFMIN(volume_len, 27);\n            avio_read(pb, dref->volume, 27);\n            dref->volume[volume_len] = 0;\n            av_log(c->fc, AV_LOG_DEBUG, \"volume %s, len %d\\n\", dref->volume, volume_len);\n\n            avio_skip(pb, 12);\n\n            len = avio_r8(pb);\n            len = FFMIN(len, 63);\n            avio_read(pb, dref->filename, 63);\n            dref->filename[len] = 0;\n            av_log(c->fc, AV_LOG_DEBUG, \"filename %s, len %d\\n\", dref->filename, len);\n\n            avio_skip(pb, 16);\n\n            /* read next level up_from_alias/down_to_target */\n            dref->nlvl_from = avio_rb16(pb);\n            dref->nlvl_to   = avio_rb16(pb);\n            av_log(c->fc, AV_LOG_DEBUG, \"nlvl from %d, nlvl to %d\\n\",\n                   dref->nlvl_from, dref->nlvl_to);\n\n            avio_skip(pb, 16);\n\n            for (type = 0; type != -1 && avio_tell(pb) < next; ) {\n                if(url_feof(pb))\n                    return AVERROR_EOF;\n                type = avio_rb16(pb);\n                len = avio_rb16(pb);\n                av_log(c->fc, AV_LOG_DEBUG, \"type %d, len %d\\n\", type, len);\n                if (len&1)\n                    len += 1;\n                if (type == 2) { // absolute path\n                    av_free(dref->path);\n                    dref->path = av_mallocz(len+1);\n                    if (!dref->path)\n                        return AVERROR(ENOMEM);\n                    avio_read(pb, dref->path, len);\n                    if (len > volume_len && !strncmp(dref->path, dref->volume, volume_len)) {\n                        len -= volume_len;\n                        memmove(dref->path, dref->path+volume_len, len);\n                        dref->path[len] = 0;\n                    }\n                    for (j = 0; j < len; j++)\n                        if (dref->path[j] == ':')\n                            dref->path[j] = '/';\n                    av_log(c->fc, AV_LOG_DEBUG, \"path %s\\n\", dref->path);\n                } else if (type == 0) { // directory name\n                    av_free(dref->dir);\n                    dref->dir = av_malloc(len+1);\n                    if (!dref->dir)\n                        return AVERROR(ENOMEM);\n                    avio_read(pb, dref->dir, len);\n                    dref->dir[len] = 0;\n                    for (j = 0; j < len; j++)\n                        if (dref->dir[j] == ':')\n                            dref->dir[j] = '/';\n                    av_log(c->fc, AV_LOG_DEBUG, \"dir %s\\n\", dref->dir);\n                } else\n                    avio_skip(pb, len);\n            }\n        }\n        avio_seek(pb, next, SEEK_SET);\n    }\n    return 0;\n}\n\nstatic int mov_read_hdlr(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    uint32_t type;\n    uint32_t av_unused ctype;\n    int title_size;\n    char *title_str;\n\n    if (c->fc->nb_streams < 1) // meta before first trak\n        return 0;\n\n    st = c->fc->streams[c->fc->nb_streams-1];\n\n    avio_r8(pb); /* version */\n    avio_rb24(pb); /* flags */\n\n    /* component type */\n    ctype = avio_rl32(pb);\n    type = avio_rl32(pb); /* component subtype */\n\n    av_dlog(c->fc, \"ctype= %.4s (0x%08x)\\n\", (char*)&ctype, ctype);\n    av_dlog(c->fc, \"stype= %.4s\\n\", (char*)&type);\n\n    if     (type == MKTAG('v','i','d','e'))\n        st->codec->codec_type = AVMEDIA_TYPE_VIDEO;\n    else if (type == MKTAG('s','o','u','n'))\n        st->codec->codec_type = AVMEDIA_TYPE_AUDIO;\n    else if (type == MKTAG('m','1','a',' '))\n        st->codec->codec_id = CODEC_ID_MP2;\n    else if ((type == MKTAG('s','u','b','p')) || (type == MKTAG('c','l','c','p')))\n        st->codec->codec_type = AVMEDIA_TYPE_SUBTITLE;\n\n    avio_rb32(pb); /* component  manufacture */\n    avio_rb32(pb); /* component flags */\n    avio_rb32(pb); /* component flags mask */\n\n    title_size = atom.size - 24;\n    if (title_size > 0) {\n        title_str = av_malloc(title_size + 1); /* Add null terminator */\n        if (!title_str)\n            return AVERROR(ENOMEM);\n        avio_read(pb, title_str, title_size);\n        title_str[title_size] = 0;\n        if (title_str[0])\n            av_dict_set(&st->metadata, \"handler_name\", title_str +\n                        (!c->isom && title_str[0] == title_size - 1), 0);\n        av_freep(&title_str);\n    }\n\n    return 0;\n}\n\nint ff_mov_read_esds(AVFormatContext *fc, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    int tag;\n\n    if (fc->nb_streams < 1)\n        return 0;\n    st = fc->streams[fc->nb_streams-1];\n\n    avio_rb32(pb); /* version + flags */\n    ff_mp4_read_descr(fc, pb, &tag);\n    if (tag == MP4ESDescrTag) {\n        ff_mp4_parse_es_descr(pb, NULL);\n    } else\n        avio_rb16(pb); /* ID */\n\n    ff_mp4_read_descr(fc, pb, &tag);\n    if (tag == MP4DecConfigDescrTag)\n        ff_mp4_read_dec_config_descr(fc, st, pb);\n    return 0;\n}\n\nstatic int mov_read_esds(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    return ff_mov_read_esds(c->fc, pb, atom);\n}\n\nstatic int mov_read_dac3(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    int ac3info, acmod, lfeon, bsmod;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n\n    ac3info = avio_rb24(pb);\n    bsmod = (ac3info >> 14) & 0x7;\n    acmod = (ac3info >> 11) & 0x7;\n    lfeon = (ac3info >> 10) & 0x1;\n    st->codec->channels = ((int[]){2,1,2,3,3,4,4,5})[acmod] + lfeon;\n    st->codec->channel_layout = avpriv_ac3_channel_layout_tab[acmod];\n    if (lfeon)\n        st->codec->channel_layout |= AV_CH_LOW_FREQUENCY;\n    st->codec->audio_service_type = bsmod;\n    if (st->codec->channels > 1 && bsmod == 0x7)\n        st->codec->audio_service_type = AV_AUDIO_SERVICE_TYPE_KARAOKE;\n\n    return 0;\n}\n\nstatic int mov_read_chan(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    uint8_t version;\n    uint32_t flags, layout_tag, bitmap, num_descr, label_mask;\n    int i;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n\n    if (atom.size < 16)\n        return 0;\n\n    version = avio_r8(pb);\n    flags   = avio_rb24(pb);\n\n    layout_tag = avio_rb32(pb);\n    bitmap     = avio_rb32(pb);\n    num_descr  = avio_rb32(pb);\n\n    if (atom.size < 16ULL + num_descr * 20ULL)\n        return 0;\n\n    av_dlog(c->fc, \"chan: size=%\" PRId64 \" version=%u flags=%u layout=%u bitmap=%u num_descr=%u\\n\",\n            atom.size, version, flags, layout_tag, bitmap, num_descr);\n\n    label_mask = 0;\n    for (i = 0; i < num_descr; i++) {\n        uint32_t av_unused label, cflags;\n        label     = avio_rb32(pb);          // mChannelLabel\n        cflags    = avio_rb32(pb);          // mChannelFlags\n        avio_rl32(pb);                      // mCoordinates[0]\n        avio_rl32(pb);                      // mCoordinates[1]\n        avio_rl32(pb);                      // mCoordinates[2]\n        if (layout_tag == 0) {\n            uint32_t mask_incr = ff_mov_get_channel_label(label);\n            if (mask_incr == 0) {\n                label_mask = 0;\n                break;\n            }\n            label_mask |= mask_incr;\n        }\n    }\n    if (layout_tag == 0)\n        st->codec->channel_layout = label_mask;\n    else\n        st->codec->channel_layout = ff_mov_get_channel_layout(layout_tag, bitmap);\n\n    return 0;\n}\n\nstatic int mov_read_wfex(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n\n    ff_get_wav_header(pb, st->codec, atom.size);\n\n    return 0;\n}\n\nstatic int mov_read_pasp(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    const int num = avio_rb32(pb);\n    const int den = avio_rb32(pb);\n    AVStream *st;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n\n    if ((st->sample_aspect_ratio.den != 1 || st->sample_aspect_ratio.num) && // default\n        (den != st->sample_aspect_ratio.den || num != st->sample_aspect_ratio.num)) {\n        av_log(c->fc, AV_LOG_WARNING,\n               \"sample aspect ratio already set to %d:%d, ignoring 'pasp' atom (%d:%d)\\n\",\n               st->sample_aspect_ratio.num, st->sample_aspect_ratio.den,\n               num, den);\n    } else if (den != 0) {\n        st->sample_aspect_ratio.num = num;\n        st->sample_aspect_ratio.den = den;\n    }\n    return 0;\n}\n\n/* this atom contains actual media data */\nstatic int mov_read_mdat(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    if (atom.size == 0) /* wrong one (MP4) */\n        return 0;\n    c->found_mdat=1;\n    return 0; /* now go for moov */\n}\n\n/* read major brand, minor version and compatible brands and store them as metadata */\nstatic int mov_read_ftyp(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    uint32_t minor_ver;\n    int comp_brand_size;\n    char minor_ver_str[11]; /* 32 bit integer -> 10 digits + null */\n    char* comp_brands_str;\n    uint8_t type[5] = {0};\n\n    avio_read(pb, type, 4);\n    if (strcmp(type, \"qt  \"))\n        c->isom = 1;\n    av_log(c->fc, AV_LOG_DEBUG, \"ISO: File Type Major Brand: %.4s\\n\",(char *)&type);\n    av_dict_set(&c->fc->metadata, \"major_brand\", type, 0);\n    minor_ver = avio_rb32(pb); /* minor version */\n    snprintf(minor_ver_str, sizeof(minor_ver_str), \"%d\", minor_ver);\n    av_dict_set(&c->fc->metadata, \"minor_version\", minor_ver_str, 0);\n\n    comp_brand_size = atom.size - 8;\n    if (comp_brand_size < 0)\n        return AVERROR_INVALIDDATA;\n    comp_brands_str = av_malloc(comp_brand_size + 1); /* Add null terminator */\n    if (!comp_brands_str)\n        return AVERROR(ENOMEM);\n    avio_read(pb, comp_brands_str, comp_brand_size);\n    comp_brands_str[comp_brand_size] = 0;\n    av_dict_set(&c->fc->metadata, \"compatible_brands\", comp_brands_str, 0);\n    av_freep(&comp_brands_str);\n\n    return 0;\n}\n\n/* this atom should contain all header atoms */\nstatic int mov_read_moov(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    int ret;\n\n    if ((ret = mov_read_default(c, pb, atom)) < 0)\n        return ret;\n    /* we parsed the 'moov' atom, we can terminate the parsing as soon as we find the 'mdat' */\n    /* so we don't parse the whole file if over a network */\n    c->found_moov=1;\n    return 0; /* now go for mdat */\n}\n\nstatic int mov_read_moof(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    c->fragment.moof_offset = avio_tell(pb) - 8;\n    av_dlog(c->fc, \"moof offset %\"PRIx64\"\\n\", c->fragment.moof_offset);\n    return mov_read_default(c, pb, atom);\n}\n\nstatic void mov_metadata_creation_time(AVDictionary **metadata, time_t time)\n{\n    char buffer[32];\n    if (time) {\n        struct tm *ptm;\n        time -= 2082844800;  /* seconds between 1904-01-01 and Epoch */\n        ptm = gmtime(&time);\n        if (!ptm) return;\n        strftime(buffer, sizeof(buffer), \"%Y-%m-%d %H:%M:%S\", ptm);\n        av_dict_set(metadata, \"creation_time\", buffer, 0);\n    }\n}\n\nstatic int mov_read_mdhd(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    MOVStreamContext *sc;\n    int version;\n    char language[4] = {0};\n    unsigned lang;\n    time_t creation_time;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n    sc = st->priv_data;\n\n    version = avio_r8(pb);\n    if (version > 1) {\n        av_log_ask_for_sample(c, \"unsupported version %d\\n\", version);\n        return AVERROR_PATCHWELCOME;\n    }\n    avio_rb24(pb); /* flags */\n    if (version == 1) {\n        creation_time = avio_rb64(pb);\n        avio_rb64(pb);\n    } else {\n        creation_time = avio_rb32(pb);\n        avio_rb32(pb); /* modification time */\n    }\n    mov_metadata_creation_time(&st->metadata, creation_time);\n\n    sc->time_scale = avio_rb32(pb);\n    st->duration = (version == 1) ? avio_rb64(pb) : avio_rb32(pb); /* duration */\n\n    lang = avio_rb16(pb); /* language */\n    if (ff_mov_lang_to_iso639(lang, language))\n        av_dict_set(&st->metadata, \"language\", language, 0);\n    avio_rb16(pb); /* quality */\n\n    return 0;\n}\n\nstatic int mov_read_mvhd(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    time_t creation_time;\n    int version = avio_r8(pb); /* version */\n    avio_rb24(pb); /* flags */\n\n    if (version == 1) {\n        creation_time = avio_rb64(pb);\n        avio_rb64(pb);\n    } else {\n        creation_time = avio_rb32(pb);\n        avio_rb32(pb); /* modification time */\n    }\n    mov_metadata_creation_time(&c->fc->metadata, creation_time);\n    c->time_scale = avio_rb32(pb); /* time scale */\n\n    av_dlog(c->fc, \"time scale = %i\\n\", c->time_scale);\n\n    c->duration = (version == 1) ? avio_rb64(pb) : avio_rb32(pb); /* duration */\n    // set the AVCodecContext duration because the duration of individual tracks\n    // may be inaccurate\n    if (c->time_scale > 0)\n        c->fc->duration = av_rescale(c->duration, AV_TIME_BASE, c->time_scale);\n    avio_rb32(pb); /* preferred scale */\n\n    avio_rb16(pb); /* preferred volume */\n\n    avio_skip(pb, 10); /* reserved */\n\n    avio_skip(pb, 36); /* display matrix */\n\n    avio_rb32(pb); /* preview time */\n    avio_rb32(pb); /* preview duration */\n    avio_rb32(pb); /* poster time */\n    avio_rb32(pb); /* selection time */\n    avio_rb32(pb); /* selection duration */\n    avio_rb32(pb); /* current time */\n    avio_rb32(pb); /* next track ID */\n    return 0;\n}\n\nstatic int mov_read_smi(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n\n    if ((uint64_t)atom.size > (1<<30))\n        return AVERROR_INVALIDDATA;\n\n    // currently SVQ3 decoder expect full STSD header - so let's fake it\n    // this should be fixed and just SMI header should be passed\n    av_free(st->codec->extradata);\n    st->codec->extradata_size = 0;\n    st->codec->extradata = av_mallocz(atom.size + 0x5a + FF_INPUT_BUFFER_PADDING_SIZE);\n    if (!st->codec->extradata)\n        return AVERROR(ENOMEM);\n    st->codec->extradata_size = 0x5a + atom.size;\n    memcpy(st->codec->extradata, \"SVQ3\", 4); // fake\n    avio_read(pb, st->codec->extradata + 0x5a, atom.size);\n    av_dlog(c->fc, \"Reading SMI %\"PRId64\"  %s\\n\", atom.size, st->codec->extradata + 0x5a);\n    return 0;\n}\n\nstatic int mov_read_enda(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    int little_endian;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n\n    little_endian = avio_rb16(pb) & 0xFF;\n    av_dlog(c->fc, \"enda %d\\n\", little_endian);\n    if (little_endian == 1) {\n        switch (st->codec->codec_id) {\n        case CODEC_ID_PCM_S24BE:\n            st->codec->codec_id = CODEC_ID_PCM_S24LE;\n            break;\n        case CODEC_ID_PCM_S32BE:\n            st->codec->codec_id = CODEC_ID_PCM_S32LE;\n            break;\n        case CODEC_ID_PCM_F32BE:\n            st->codec->codec_id = CODEC_ID_PCM_F32LE;\n            break;\n        case CODEC_ID_PCM_F64BE:\n            st->codec->codec_id = CODEC_ID_PCM_F64LE;\n            break;\n        default:\n            break;\n        }\n    }\n    return 0;\n}\n\nstatic int mov_read_fiel(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    unsigned mov_field_order;\n    enum AVFieldOrder decoded_field_order = AV_FIELD_UNKNOWN;\n\n    if (c->fc->nb_streams < 1) // will happen with jp2 files\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n    if (atom.size < 2)\n        return AVERROR_INVALIDDATA;\n    mov_field_order = avio_rb16(pb);\n    if ((mov_field_order & 0xFF00) == 0x0100)\n        decoded_field_order = AV_FIELD_PROGRESSIVE;\n    else if ((mov_field_order & 0xFF00) == 0x0200) {\n        switch (mov_field_order & 0xFF) {\n        case 0x01: decoded_field_order = AV_FIELD_TT;\n                   break;\n        case 0x06: decoded_field_order = AV_FIELD_BB;\n                   break;\n        case 0x09: decoded_field_order = AV_FIELD_TB;\n                   break;\n        case 0x0E: decoded_field_order = AV_FIELD_BT;\n                   break;\n        }\n    }\n    if (decoded_field_order == AV_FIELD_UNKNOWN && mov_field_order) {\n        av_log(NULL, AV_LOG_ERROR, \"Unknown MOV field order 0x%04x\\n\", mov_field_order);\n    }\n    st->codec->field_order = decoded_field_order;\n\n    return 0;\n}\n\n/* FIXME modify qdm2/svq3/h264 decoders to take full atom as extradata */\nstatic int mov_read_extradata(MOVContext *c, AVIOContext *pb, MOVAtom atom,\n                              enum CodecID codec_id)\n{\n    AVStream *st;\n    uint64_t size;\n    uint8_t *buf;\n\n    if (c->fc->nb_streams < 1) // will happen with jp2 files\n        return 0;\n    st= c->fc->streams[c->fc->nb_streams-1];\n\n    if (st->codec->codec_id != codec_id)\n        return 0; /* unexpected codec_id - don't mess with extradata */\n\n    size= (uint64_t)st->codec->extradata_size + atom.size + 8 + FF_INPUT_BUFFER_PADDING_SIZE;\n    if (size > INT_MAX || (uint64_t)atom.size > INT_MAX)\n        return AVERROR_INVALIDDATA;\n    buf= av_realloc(st->codec->extradata, size);\n    if (!buf)\n        return AVERROR(ENOMEM);\n    st->codec->extradata= buf;\n    buf+= st->codec->extradata_size;\n    st->codec->extradata_size= size - FF_INPUT_BUFFER_PADDING_SIZE;\n    AV_WB32(       buf    , atom.size + 8);\n    AV_WL32(       buf + 4, atom.type);\n    avio_read(pb, buf + 8, atom.size);\n    return 0;\n}\n\n/* wrapper functions for reading ALAC/AVS/MJPEG/MJPEG2000 extradata atoms only for those codecs */\nstatic int mov_read_alac(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    return mov_read_extradata(c, pb, atom, CODEC_ID_ALAC);\n}\n\nstatic int mov_read_avss(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    return mov_read_extradata(c, pb, atom, CODEC_ID_AVS);\n}\n\nstatic int mov_read_jp2h(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    return mov_read_extradata(c, pb, atom, CODEC_ID_JPEG2000);\n}\n\nstatic int mov_read_wave(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n\n    if ((uint64_t)atom.size > (1<<30))\n        return AVERROR_INVALIDDATA;\n\n    if (st->codec->codec_id == CODEC_ID_QDM2 || st->codec->codec_id == CODEC_ID_QDMC) {\n        // pass all frma atom to codec, needed at least for QDMC and QDM2\n        av_free(st->codec->extradata);\n        st->codec->extradata_size = 0;\n        st->codec->extradata = av_mallocz(atom.size + FF_INPUT_BUFFER_PADDING_SIZE);\n        if (!st->codec->extradata)\n            return AVERROR(ENOMEM);\n        st->codec->extradata_size = atom.size;\n        avio_read(pb, st->codec->extradata, atom.size);\n    } else if (atom.size > 8) { /* to read frma, esds atoms */\n        int ret;\n        if ((ret = mov_read_default(c, pb, atom)) < 0)\n            return ret;\n    } else\n        avio_skip(pb, atom.size);\n    return 0;\n}\n\n/**\n * This function reads atom content and puts data in extradata without tag\n * nor size unlike mov_read_extradata.\n */\nstatic int mov_read_glbl(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n\n    if ((uint64_t)atom.size > (1<<30))\n        return AVERROR_INVALIDDATA;\n\n    if (atom.size >= 10) {\n        // Broken files created by legacy versions of Libav and FFmpeg will\n        // wrap a whole fiel atom inside of a glbl atom.\n        unsigned size = avio_rb32(pb);\n        unsigned type = avio_rl32(pb);\n        avio_seek(pb, -8, SEEK_CUR);\n        if (type == MKTAG('f','i','e','l') && size == atom.size)\n            return mov_read_default(c, pb, atom);\n    }\n    av_free(st->codec->extradata);\n    st->codec->extradata_size = 0;\n    st->codec->extradata = av_mallocz(atom.size + FF_INPUT_BUFFER_PADDING_SIZE);\n    if (!st->codec->extradata)\n        return AVERROR(ENOMEM);\n    st->codec->extradata_size = atom.size;\n    avio_read(pb, st->codec->extradata, atom.size);\n    return 0;\n}\n\nstatic int mov_read_dvc1(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    uint8_t profile_level;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n\n    if (atom.size >= (1<<28) || atom.size < 7)\n        return AVERROR_INVALIDDATA;\n\n    profile_level = avio_r8(pb);\n    if (profile_level & 0xf0 != 0xc0)\n        return 0;\n\n    av_free(st->codec->extradata);\n    st->codec->extradata_size = 0;\n    st->codec->extradata = av_mallocz(atom.size - 7 + FF_INPUT_BUFFER_PADDING_SIZE);\n    if (!st->codec->extradata)\n        return AVERROR(ENOMEM);\n    st->codec->extradata_size = atom.size - 7;\n    avio_seek(pb, 6, SEEK_CUR);\n    avio_read(pb, st->codec->extradata, st->codec->extradata_size);\n    return 0;\n}\n\n/**\n * An strf atom is a BITMAPINFOHEADER struct. This struct is 40 bytes itself,\n * but can have extradata appended at the end after the 40 bytes belonging\n * to the struct.\n */\nstatic int mov_read_strf(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    if (atom.size <= 40)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n\n    if ((uint64_t)atom.size > (1<<30))\n        return AVERROR_INVALIDDATA;\n\n    av_free(st->codec->extradata);\n    st->codec->extradata_size = 0;\n    st->codec->extradata = av_mallocz(atom.size - 40 + FF_INPUT_BUFFER_PADDING_SIZE);\n    if (!st->codec->extradata)\n        return AVERROR(ENOMEM);\n    st->codec->extradata_size = atom.size - 40;\n    avio_skip(pb, 40);\n    avio_read(pb, st->codec->extradata, atom.size - 40);\n    return 0;\n}\n\nstatic int mov_read_stco(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    MOVStreamContext *sc;\n    unsigned int i, entries;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n    sc = st->priv_data;\n\n    avio_r8(pb); /* version */\n    avio_rb24(pb); /* flags */\n\n    entries = avio_rb32(pb);\n\n    if (!entries)\n        return 0;\n    if (entries >= UINT_MAX/sizeof(int64_t))\n        return AVERROR_INVALIDDATA;\n\n    sc->chunk_offsets = av_malloc(entries * sizeof(int64_t));\n    if (!sc->chunk_offsets)\n        return AVERROR(ENOMEM);\n    sc->chunk_count = entries;\n\n    if      (atom.type == MKTAG('s','t','c','o'))\n        for (i=0; i<entries; i++)\n            sc->chunk_offsets[i] = avio_rb32(pb);\n    else if (atom.type == MKTAG('c','o','6','4'))\n        for (i=0; i<entries; i++)\n            sc->chunk_offsets[i] = avio_rb64(pb);\n    else\n        return AVERROR_INVALIDDATA;\n\n    return 0;\n}\n\n/**\n * Compute codec id for 'lpcm' tag.\n * See CoreAudioTypes and AudioStreamBasicDescription at Apple.\n */\nenum CodecID ff_mov_get_lpcm_codec_id(int bps, int flags)\n{\n    if (flags & 1) { // floating point\n        if (flags & 2) { // big endian\n            if      (bps == 32) return CODEC_ID_PCM_F32BE;\n            else if (bps == 64) return CODEC_ID_PCM_F64BE;\n        } else {\n            if      (bps == 32) return CODEC_ID_PCM_F32LE;\n            else if (bps == 64) return CODEC_ID_PCM_F64LE;\n        }\n    } else {\n        if (flags & 2) {\n            if      (bps == 8)\n                // signed integer\n                if (flags & 4)  return CODEC_ID_PCM_S8;\n                else            return CODEC_ID_PCM_U8;\n            else if (bps == 16) return CODEC_ID_PCM_S16BE;\n            else if (bps == 24) return CODEC_ID_PCM_S24BE;\n            else if (bps == 32) return CODEC_ID_PCM_S32BE;\n        } else {\n            if      (bps == 8)\n                if (flags & 4)  return CODEC_ID_PCM_S8;\n                else            return CODEC_ID_PCM_U8;\n            else if (bps == 16) return CODEC_ID_PCM_S16LE;\n            else if (bps == 24) return CODEC_ID_PCM_S24LE;\n            else if (bps == 32) return CODEC_ID_PCM_S32LE;\n        }\n    }\n    return CODEC_ID_NONE;\n}\n\nint ff_mov_read_stsd_entries(MOVContext *c, AVIOContext *pb, int entries)\n{\n    AVStream *st;\n    MOVStreamContext *sc;\n    int j, pseudo_stream_id;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n    sc = st->priv_data;\n\n    for (pseudo_stream_id=0; pseudo_stream_id<entries; pseudo_stream_id++) {\n        //Parsing Sample description table\n        enum CodecID id;\n        int dref_id = 1;\n        MOVAtom a = { AV_RL32(\"stsd\") };\n        int64_t start_pos = avio_tell(pb);\n        int size = avio_rb32(pb); /* size */\n        uint32_t format = avio_rl32(pb); /* data format */\n\n        if (size >= 16) {\n            avio_rb32(pb); /* reserved */\n            avio_rb16(pb); /* reserved */\n            dref_id = avio_rb16(pb);\n        }else if (size <= 0){\n            av_log(c->fc, AV_LOG_ERROR, \"invalid size %d in stsd\\n\", size);\n            return -1;\n        }\n\n        if (st->codec->codec_tag &&\n            st->codec->codec_tag != format &&\n            (c->fc->video_codec_id ? ff_codec_get_id(ff_codec_movvideo_tags, format) != c->fc->video_codec_id\n                                   : st->codec->codec_tag != MKTAG('j','p','e','g'))\n           ){\n            /* Multiple fourcc, we skip JPEG. This is not correct, we should\n             * export it as a separate AVStream but this needs a few changes\n             * in the MOV demuxer, patch welcome. */\n            av_log(c->fc, AV_LOG_WARNING, \"multiple fourcc not supported\\n\");\n            avio_skip(pb, size - (avio_tell(pb) - start_pos));\n            continue;\n        }\n        /* we cannot demux concatenated h264 streams because of different extradata */\n        if (st->codec->codec_tag && st->codec->codec_tag == AV_RL32(\"avc1\"))\n            av_log(c->fc, AV_LOG_WARNING, \"Concatenated H.264 might not play corrently.\\n\");\n        sc->pseudo_stream_id = st->codec->codec_tag ? -1 : pseudo_stream_id;\n        sc->dref_id= dref_id;\n\n        st->codec->codec_tag = format;\n        id = ff_codec_get_id(ff_codec_movaudio_tags, format);\n        if (id<=0 && ((format&0xFFFF) == 'm'+('s'<<8) || (format&0xFFFF) == 'T'+('S'<<8)))\n            id = ff_codec_get_id(ff_codec_wav_tags, av_bswap32(format)&0xFFFF);\n\n        if (st->codec->codec_type != AVMEDIA_TYPE_VIDEO && id > 0) {\n            st->codec->codec_type = AVMEDIA_TYPE_AUDIO;\n        } else if (st->codec->codec_type != AVMEDIA_TYPE_AUDIO && /* do not overwrite codec type */\n                   format && format != MKTAG('m','p','4','s')) { /* skip old asf mpeg4 tag */\n            id = ff_codec_get_id(ff_codec_movvideo_tags, format);\n            if (id <= 0)\n                id = ff_codec_get_id(ff_codec_bmp_tags, format);\n            if (id > 0)\n                st->codec->codec_type = AVMEDIA_TYPE_VIDEO;\n            else if (st->codec->codec_type == AVMEDIA_TYPE_DATA ||\n                     (st->codec->codec_type == AVMEDIA_TYPE_SUBTITLE &&\n                      st->codec->codec_id == CODEC_ID_NONE)){\n                id = ff_codec_get_id(ff_codec_movsubtitle_tags, format);\n                if (id > 0)\n                    st->codec->codec_type = AVMEDIA_TYPE_SUBTITLE;\n            }\n        }\n\n        av_dlog(c->fc, \"size=%d 4CC= %c%c%c%c codec_type=%d\\n\", size,\n                (format >> 0) & 0xff, (format >> 8) & 0xff, (format >> 16) & 0xff,\n                (format >> 24) & 0xff, st->codec->codec_type);\n\n        if (st->codec->codec_type==AVMEDIA_TYPE_VIDEO) {\n            unsigned int color_depth, len;\n            int color_greyscale;\n            int color_table_id;\n\n            st->codec->codec_id = id;\n            avio_rb16(pb); /* version */\n            avio_rb16(pb); /* revision level */\n            avio_rb32(pb); /* vendor */\n            avio_rb32(pb); /* temporal quality */\n            avio_rb32(pb); /* spatial quality */\n\n            st->codec->width = avio_rb16(pb); /* width */\n            st->codec->height = avio_rb16(pb); /* height */\n\n            avio_rb32(pb); /* horiz resolution */\n            avio_rb32(pb); /* vert resolution */\n            avio_rb32(pb); /* data size, always 0 */\n            avio_rb16(pb); /* frames per samples */\n\n            len = avio_r8(pb); /* codec name, pascal string */\n            if (len > 31)\n                len = 31;\n            mov_read_mac_string(c, pb, len, st->codec->codec_name, 32);\n            if (len < 31)\n                avio_skip(pb, 31 - len);\n            /* codec_tag YV12 triggers an UV swap in rawdec.c */\n            if (!memcmp(st->codec->codec_name, \"Planar Y'CbCr 8-bit 4:2:0\", 25))\n                st->codec->codec_tag=MKTAG('I', '4', '2', '0');\n\n            st->codec->bits_per_coded_sample = avio_rb16(pb); /* depth */\n            color_table_id = avio_rb16(pb); /* colortable id */\n            av_dlog(c->fc, \"depth %d, ctab id %d\\n\",\n                   st->codec->bits_per_coded_sample, color_table_id);\n            /* figure out the palette situation */\n            color_depth = st->codec->bits_per_coded_sample & 0x1F;\n            color_greyscale = st->codec->bits_per_coded_sample & 0x20;\n\n            /* if the depth is 2, 4, or 8 bpp, file is palettized */\n            if ((color_depth == 2) || (color_depth == 4) ||\n                (color_depth == 8)) {\n                /* for palette traversal */\n                unsigned int color_start, color_count, color_end;\n                unsigned char a, r, g, b;\n\n                if (color_greyscale) {\n                    int color_index, color_dec;\n                    /* compute the greyscale palette */\n                    st->codec->bits_per_coded_sample = color_depth;\n                    color_count = 1 << color_depth;\n                    color_index = 255;\n                    color_dec = 256 / (color_count - 1);\n                    for (j = 0; j < color_count; j++) {\n                        if (id == CODEC_ID_CINEPAK){\n                            r = g = b = color_count - 1 - color_index;\n                        }else\n                        r = g = b = color_index;\n                        sc->palette[j] =\n                            (0xFFU << 24) | (r << 16) | (g << 8) | (b);\n                        color_index -= color_dec;\n                        if (color_index < 0)\n                            color_index = 0;\n                    }\n                } else if (color_table_id) {\n                    const uint8_t *color_table;\n                    /* if flag bit 3 is set, use the default palette */\n                    color_count = 1 << color_depth;\n                    if (color_depth == 2)\n                        color_table = ff_qt_default_palette_4;\n                    else if (color_depth == 4)\n                        color_table = ff_qt_default_palette_16;\n                    else\n                        color_table = ff_qt_default_palette_256;\n\n                    for (j = 0; j < color_count; j++) {\n                        r = color_table[j * 3 + 0];\n                        g = color_table[j * 3 + 1];\n                        b = color_table[j * 3 + 2];\n                        sc->palette[j] =\n                            (0xFFU << 24) | (r << 16) | (g << 8) | (b);\n                    }\n                } else {\n                    /* load the palette from the file */\n                    color_start = avio_rb32(pb);\n                    color_count = avio_rb16(pb);\n                    color_end = avio_rb16(pb);\n                    if ((color_start <= 255) &&\n                        (color_end <= 255)) {\n                        for (j = color_start; j <= color_end; j++) {\n                            /* each A, R, G, or B component is 16 bits;\n                             * only use the top 8 bits */\n                            a = avio_r8(pb);\n                            avio_r8(pb);\n                            r = avio_r8(pb);\n                            avio_r8(pb);\n                            g = avio_r8(pb);\n                            avio_r8(pb);\n                            b = avio_r8(pb);\n                            avio_r8(pb);\n                            sc->palette[j] =\n                                (a << 24 ) | (r << 16) | (g << 8) | (b);\n                        }\n                    }\n                }\n                sc->has_palette = 1;\n            }\n        } else if (st->codec->codec_type==AVMEDIA_TYPE_AUDIO) {\n            int bits_per_sample, flags;\n            uint16_t version = avio_rb16(pb);\n\n            st->codec->codec_id = id;\n            avio_rb16(pb); /* revision level */\n            avio_rb32(pb); /* vendor */\n\n            st->codec->channels = avio_rb16(pb);             /* channel count */\n            av_dlog(c->fc, \"audio channels %d\\n\", st->codec->channels);\n            st->codec->bits_per_coded_sample = avio_rb16(pb);      /* sample size */\n\n            sc->audio_cid = avio_rb16(pb);\n            avio_rb16(pb); /* packet size = 0 */\n\n            st->codec->sample_rate = ((avio_rb32(pb) >> 16));\n\n            //Read QT version 1 fields. In version 0 these do not exist.\n            av_dlog(c->fc, \"version =%d, isom =%d\\n\",version,c->isom);\n            if (!c->isom) {\n                if (version==1) {\n                    sc->samples_per_frame = avio_rb32(pb);\n                    avio_rb32(pb); /* bytes per packet */\n                    sc->bytes_per_frame = avio_rb32(pb);\n                    avio_rb32(pb); /* bytes per sample */\n                } else if (version==2) {\n                    avio_rb32(pb); /* sizeof struct only */\n                    st->codec->sample_rate = av_int2double(avio_rb64(pb)); /* float 64 */\n                    st->codec->channels = avio_rb32(pb);\n                    avio_rb32(pb); /* always 0x7F000000 */\n                    st->codec->bits_per_coded_sample = avio_rb32(pb); /* bits per channel if sound is uncompressed */\n                    flags = avio_rb32(pb); /* lpcm format specific flag */\n                    sc->bytes_per_frame = avio_rb32(pb); /* bytes per audio packet if constant */\n                    sc->samples_per_frame = avio_rb32(pb); /* lpcm frames per audio packet if constant */\n                    if (format == MKTAG('l','p','c','m'))\n                        st->codec->codec_id = ff_mov_get_lpcm_codec_id(st->codec->bits_per_coded_sample, flags);\n                }\n            }\n\n            switch (st->codec->codec_id) {\n            case CODEC_ID_PCM_S8:\n            case CODEC_ID_PCM_U8:\n                if (st->codec->bits_per_coded_sample == 16)\n                    st->codec->codec_id = CODEC_ID_PCM_S16BE;\n                break;\n            case CODEC_ID_PCM_S16LE:\n            case CODEC_ID_PCM_S16BE:\n                if (st->codec->bits_per_coded_sample == 8)\n                    st->codec->codec_id = CODEC_ID_PCM_S8;\n                else if (st->codec->bits_per_coded_sample == 24)\n                    st->codec->codec_id =\n                        st->codec->codec_id == CODEC_ID_PCM_S16BE ?\n                        CODEC_ID_PCM_S24BE : CODEC_ID_PCM_S24LE;\n                break;\n            /* set values for old format before stsd version 1 appeared */\n            case CODEC_ID_MACE3:\n                sc->samples_per_frame = 6;\n                sc->bytes_per_frame = 2*st->codec->channels;\n                break;\n            case CODEC_ID_MACE6:\n                sc->samples_per_frame = 6;\n                sc->bytes_per_frame = 1*st->codec->channels;\n                break;\n            case CODEC_ID_ADPCM_IMA_QT:\n                sc->samples_per_frame = 64;\n                sc->bytes_per_frame = 34*st->codec->channels;\n                break;\n            case CODEC_ID_GSM:\n                sc->samples_per_frame = 160;\n                sc->bytes_per_frame = 33;\n                break;\n            default:\n                break;\n            }\n\n            bits_per_sample = av_get_bits_per_sample(st->codec->codec_id);\n            if (bits_per_sample) {\n                st->codec->bits_per_coded_sample = bits_per_sample;\n                sc->sample_size = (bits_per_sample >> 3) * st->codec->channels;\n            }\n        } else if (st->codec->codec_type==AVMEDIA_TYPE_SUBTITLE){\n            // ttxt stsd contains display flags, justification, background\n            // color, fonts, and default styles, so fake an atom to read it\n            MOVAtom fake_atom = { .size = size - (avio_tell(pb) - start_pos) };\n            if (format != AV_RL32(\"mp4s\")) // mp4s contains a regular esds atom\n                mov_read_glbl(c, pb, fake_atom);\n            st->codec->codec_id= id;\n            st->codec->width = sc->width;\n            st->codec->height = sc->height;\n        } else {\n            if (st->codec->codec_tag == MKTAG('t','m','c','d')) {\n                MOVStreamContext *tmcd_ctx = st->priv_data;\n                int val;\n                avio_rb32(pb);       /* reserved */\n                val = avio_rb32(pb); /* flags */\n                tmcd_ctx->tmcd_flags = val;\n                if (val & 1)\n                    st->codec->flags2 |= CODEC_FLAG2_DROP_FRAME_TIMECODE;\n                avio_rb32(pb); /* time scale */\n                avio_rb32(pb); /* frame duration */\n                st->codec->time_base.den = avio_r8(pb); /* number of frame */\n                st->codec->time_base.num = 1;\n            }\n            /* other codec type, just skip (rtp, mp4s, ...) */\n            avio_skip(pb, size - (avio_tell(pb) - start_pos));\n        }\n        /* this will read extra atoms at the end (wave, alac, damr, avcC, SMI ...) */\n        a.size = size - (avio_tell(pb) - start_pos);\n        if (a.size > 8) {\n            int ret;\n            if ((ret = mov_read_default(c, pb, a)) < 0)\n                return ret;\n        } else if (a.size > 0)\n            avio_skip(pb, a.size);\n    }\n\n    if (st->codec->codec_type==AVMEDIA_TYPE_AUDIO && st->codec->sample_rate==0 && sc->time_scale>1)\n        st->codec->sample_rate= sc->time_scale;\n\n    /* special codec parameters handling */\n    switch (st->codec->codec_id) {\n#if CONFIG_DV_DEMUXER\n    case CODEC_ID_DVAUDIO:\n        c->dv_fctx = avformat_alloc_context();\n        c->dv_demux = avpriv_dv_init_demux(c->dv_fctx);\n        if (!c->dv_demux) {\n            av_log(c->fc, AV_LOG_ERROR, \"dv demux context init error\\n\");\n            return AVERROR(ENOMEM);\n        }\n        sc->dv_audio_container = 1;\n        st->codec->codec_id = CODEC_ID_PCM_S16LE;\n        break;\n#endif\n    /* no ifdef since parameters are always those */\n    case CODEC_ID_QCELP:\n        // force sample rate for qcelp when not stored in mov\n        if (st->codec->codec_tag != MKTAG('Q','c','l','p'))\n            st->codec->sample_rate = 8000;\n        st->codec->channels= 1; /* really needed */\n        break;\n    case CODEC_ID_AMR_NB:\n        st->codec->channels= 1; /* really needed */\n        /* force sample rate for amr, stsd in 3gp does not store sample rate */\n        st->codec->sample_rate = 8000;\n        break;\n    case CODEC_ID_AMR_WB:\n        st->codec->channels    = 1;\n        st->codec->sample_rate = 16000;\n        break;\n    case CODEC_ID_MP2:\n    case CODEC_ID_MP3:\n        st->codec->codec_type = AVMEDIA_TYPE_AUDIO; /* force type after stsd for m1a hdlr */\n        st->need_parsing = AVSTREAM_PARSE_FULL;\n        break;\n    case CODEC_ID_GSM:\n    case CODEC_ID_ADPCM_MS:\n    case CODEC_ID_ADPCM_IMA_WAV:\n        st->codec->block_align = sc->bytes_per_frame;\n        break;\n    case CODEC_ID_ALAC:\n        if (st->codec->extradata_size == 36) {\n            st->codec->channels   = AV_RB8 (st->codec->extradata+21);\n            st->codec->sample_rate = AV_RB32(st->codec->extradata+32);\n        }\n        break;\n    case CODEC_ID_AC3:\n        st->need_parsing = AVSTREAM_PARSE_FULL;\n        break;\n    case CODEC_ID_MPEG1VIDEO:\n        st->need_parsing = AVSTREAM_PARSE_FULL;\n        break;\n    default:\n        break;\n    }\n\n    return 0;\n}\n\nstatic int mov_read_stsd(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    int entries;\n\n    avio_r8(pb); /* version */\n    avio_rb24(pb); /* flags */\n    entries = avio_rb32(pb);\n\n    return ff_mov_read_stsd_entries(c, pb, entries);\n}\n\nstatic int mov_read_stsc(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    MOVStreamContext *sc;\n    unsigned int i, entries;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n    sc = st->priv_data;\n\n    avio_r8(pb); /* version */\n    avio_rb24(pb); /* flags */\n\n    entries = avio_rb32(pb);\n\n    av_dlog(c->fc, \"track[%i].stsc.entries = %i\\n\", c->fc->nb_streams-1, entries);\n\n    if (!entries)\n        return 0;\n    if (entries >= UINT_MAX / sizeof(*sc->stsc_data))\n        return AVERROR_INVALIDDATA;\n    sc->stsc_data = av_malloc(entries * sizeof(*sc->stsc_data));\n    if (!sc->stsc_data)\n        return AVERROR(ENOMEM);\n    sc->stsc_count = entries;\n\n    for (i=0; i<entries; i++) {\n        sc->stsc_data[i].first = avio_rb32(pb);\n        sc->stsc_data[i].count = avio_rb32(pb);\n        sc->stsc_data[i].id = avio_rb32(pb);\n    }\n    return 0;\n}\n\nstatic int mov_read_stps(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    MOVStreamContext *sc;\n    unsigned i, entries;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n    sc = st->priv_data;\n\n    avio_rb32(pb); // version + flags\n\n    entries = avio_rb32(pb);\n    if (entries >= UINT_MAX / sizeof(*sc->stps_data))\n        return AVERROR_INVALIDDATA;\n    sc->stps_data = av_malloc(entries * sizeof(*sc->stps_data));\n    if (!sc->stps_data)\n        return AVERROR(ENOMEM);\n    sc->stps_count = entries;\n\n    for (i = 0; i < entries; i++) {\n        sc->stps_data[i] = avio_rb32(pb);\n        //av_dlog(c->fc, \"stps %d\\n\", sc->stps_data[i]);\n    }\n\n    return 0;\n}\n\nstatic int mov_read_stss(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    MOVStreamContext *sc;\n    unsigned int i, entries;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n    sc = st->priv_data;\n\n    avio_r8(pb); /* version */\n    avio_rb24(pb); /* flags */\n\n    entries = avio_rb32(pb);\n\n    av_dlog(c->fc, \"keyframe_count = %d\\n\", entries);\n\n    if (!entries)\n    {\n        sc->keyframe_absent = 1;\n        return 0;\n    }\n    if (entries >= UINT_MAX / sizeof(int))\n        return AVERROR_INVALIDDATA;\n    sc->keyframes = av_malloc(entries * sizeof(int));\n    if (!sc->keyframes)\n        return AVERROR(ENOMEM);\n    sc->keyframe_count = entries;\n\n    for (i=0; i<entries; i++) {\n        sc->keyframes[i] = avio_rb32(pb);\n        //av_dlog(c->fc, \"keyframes[]=%d\\n\", sc->keyframes[i]);\n    }\n    return 0;\n}\n\nstatic int mov_read_stsz(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    MOVStreamContext *sc;\n    unsigned int i, entries, sample_size, field_size, num_bytes;\n    GetBitContext gb;\n    unsigned char* buf;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n    sc = st->priv_data;\n\n    avio_r8(pb); /* version */\n    avio_rb24(pb); /* flags */\n\n    if (atom.type == MKTAG('s','t','s','z')) {\n        sample_size = avio_rb32(pb);\n        if (!sc->sample_size) /* do not overwrite value computed in stsd */\n            sc->sample_size = sample_size;\n        sc->alt_sample_size = sample_size;\n        field_size = 32;\n    } else {\n        sample_size = 0;\n        avio_rb24(pb); /* reserved */\n        field_size = avio_r8(pb);\n    }\n    entries = avio_rb32(pb);\n\n    av_dlog(c->fc, \"sample_size = %d sample_count = %d\\n\", sc->sample_size, entries);\n\n    sc->sample_count = entries;\n    if (sample_size)\n        return 0;\n\n    if (field_size != 4 && field_size != 8 && field_size != 16 && field_size != 32) {\n        av_log(c->fc, AV_LOG_ERROR, \"Invalid sample field size %d\\n\", field_size);\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (!entries)\n        return 0;\n    if (entries >= UINT_MAX / sizeof(int) || entries >= (UINT_MAX - 4) / field_size)\n        return AVERROR_INVALIDDATA;\n    sc->sample_sizes = av_malloc(entries * sizeof(int));\n    if (!sc->sample_sizes)\n        return AVERROR(ENOMEM);\n\n    num_bytes = (entries*field_size+4)>>3;\n\n    buf = av_malloc(num_bytes+FF_INPUT_BUFFER_PADDING_SIZE);\n    if (!buf) {\n        av_freep(&sc->sample_sizes);\n        return AVERROR(ENOMEM);\n    }\n\n    if (avio_read(pb, buf, num_bytes) < num_bytes) {\n        av_freep(&sc->sample_sizes);\n        av_free(buf);\n        return AVERROR_INVALIDDATA;\n    }\n\n    init_get_bits(&gb, buf, 8*num_bytes);\n\n    for (i = 0; i < entries; i++) {\n        sc->sample_sizes[i] = get_bits_long(&gb, field_size);\n        sc->data_size += sc->sample_sizes[i];\n    }\n\n    av_free(buf);\n    return 0;\n}\n\nstatic int mov_read_stts(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    MOVStreamContext *sc;\n    unsigned int i, entries;\n    int64_t duration=0;\n    int64_t total_sample_count=0;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n    sc = st->priv_data;\n\n    avio_r8(pb); /* version */\n    avio_rb24(pb); /* flags */\n    entries = avio_rb32(pb);\n\n    av_dlog(c->fc, \"track[%i].stts.entries = %i\\n\",\n            c->fc->nb_streams-1, entries);\n\n    if (entries >= UINT_MAX / sizeof(*sc->stts_data))\n        return -1;\n\n    sc->stts_data = av_malloc(entries * sizeof(*sc->stts_data));\n    if (!sc->stts_data)\n        return AVERROR(ENOMEM);\n\n    sc->stts_count = entries;\n\n    for (i=0; i<entries; i++) {\n        int sample_duration;\n        int sample_count;\n\n        sample_count=avio_rb32(pb);\n        sample_duration = avio_rb32(pb);\n        /* sample_duration < 0 is invalid based on the spec */\n        if (sample_duration < 0) {\n            av_log(c->fc, AV_LOG_ERROR, \"Invalid SampleDelta in STTS %d\\n\", sample_duration);\n            sample_duration = 1;\n        }\n        sc->stts_data[i].count= sample_count;\n        sc->stts_data[i].duration= sample_duration;\n\n        av_dlog(c->fc, \"sample_count=%d, sample_duration=%d\\n\",\n                sample_count, sample_duration);\n\n        duration+=(int64_t)sample_duration*sample_count;\n        total_sample_count+=sample_count;\n    }\n\n    st->nb_frames= total_sample_count;\n    if (duration)\n        st->duration= duration;\n    sc->track_end = duration;\n    return 0;\n}\n\nstatic int mov_read_ctts(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    MOVStreamContext *sc;\n    unsigned int i, entries;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n    sc = st->priv_data;\n\n    avio_r8(pb); /* version */\n    avio_rb24(pb); /* flags */\n    entries = avio_rb32(pb);\n\n    av_dlog(c->fc, \"track[%i].ctts.entries = %i\\n\", c->fc->nb_streams-1, entries);\n\n    if (!entries)\n        return 0;\n    if (entries >= UINT_MAX / sizeof(*sc->ctts_data))\n        return AVERROR_INVALIDDATA;\n    sc->ctts_data = av_malloc(entries * sizeof(*sc->ctts_data));\n    if (!sc->ctts_data)\n        return AVERROR(ENOMEM);\n    sc->ctts_count = entries;\n\n    for (i=0; i<entries; i++) {\n        int count    =avio_rb32(pb);\n        int duration =avio_rb32(pb);\n\n        sc->ctts_data[i].count   = count;\n        sc->ctts_data[i].duration= duration;\n\n        if (FFABS(duration) > (1<<28) && i+2<entries) {\n            av_log(c->fc, AV_LOG_WARNING, \"CTTS invalid\\n\");\n            av_freep(&sc->ctts_data);\n            sc->ctts_count = 0;\n            return 0;\n        }\n\n        if (duration < 0 && i+2<entries)\n            sc->dts_shift = FFMAX(sc->dts_shift, -duration);\n    }\n\n    av_dlog(c->fc, \"dts shift %d\\n\", sc->dts_shift);\n\n    return 0;\n}\n\nstatic void mov_build_index(MOVContext *mov, AVStream *st)\n{\n    MOVStreamContext *sc = st->priv_data;\n    int64_t current_offset;\n    int64_t current_dts = 0;\n    unsigned int stts_index = 0;\n    unsigned int stsc_index = 0;\n    unsigned int stss_index = 0;\n    unsigned int stps_index = 0;\n    unsigned int i, j;\n    uint64_t stream_size = 0;\n    AVIndexEntry *mem;\n\n    /* adjust first dts according to edit list */\n    if ((sc->empty_duration || sc->start_time) && mov->time_scale > 0) {\n        if (sc->empty_duration)\n            sc->empty_duration = av_rescale(sc->empty_duration, sc->time_scale, mov->time_scale);\n        sc->time_offset = sc->start_time - sc->empty_duration;\n        current_dts = -sc->time_offset;\n        if (sc->ctts_data && sc->stts_data &&\n            sc->ctts_data[0].duration / FFMAX(sc->stts_data[0].duration, 1) > 16) {\n            /* more than 16 frames delay, dts are likely wrong\n               this happens with files created by iMovie */\n            sc->wrong_dts = 1;\n            st->codec->has_b_frames = 1;\n        }\n    }\n\n    /* only use old uncompressed audio chunk demuxing when stts specifies it */\n    if (!(st->codec->codec_type == AVMEDIA_TYPE_AUDIO &&\n          sc->stts_count == 1 && sc->stts_data[0].duration == 1)) {\n        unsigned int current_sample = 0;\n        unsigned int stts_sample = 0;\n        unsigned int sample_size;\n        unsigned int distance = 0;\n        int key_off = sc->keyframe_count && sc->keyframes[0] == 1;\n\n        current_dts -= sc->dts_shift;\n\n        if (!sc->sample_count || st->nb_index_entries)\n            return;\n        if (sc->sample_count >= UINT_MAX / sizeof(*st->index_entries) - st->nb_index_entries)\n            return;\n        mem = av_realloc(st->index_entries, (st->nb_index_entries + sc->sample_count) * sizeof(*st->index_entries));\n        if (!mem)\n            return;\n        st->index_entries = mem;\n        st->index_entries_allocated_size = (st->nb_index_entries + sc->sample_count) * sizeof(*st->index_entries);\n\n        for (i = 0; i < sc->chunk_count; i++) {\n            current_offset = sc->chunk_offsets[i];\n            while (stsc_index + 1 < sc->stsc_count &&\n                i + 1 == sc->stsc_data[stsc_index + 1].first)\n                stsc_index++;\n            for (j = 0; j < sc->stsc_data[stsc_index].count; j++) {\n                int keyframe = 0;\n                if (current_sample >= sc->sample_count) {\n                    av_log(mov->fc, AV_LOG_ERROR, \"wrong sample count\\n\");\n                    return;\n                }\n\n                if (!sc->keyframe_absent && (!sc->keyframe_count || current_sample+key_off == sc->keyframes[stss_index])) {\n                    keyframe = 1;\n                    if (stss_index + 1 < sc->keyframe_count)\n                        stss_index++;\n                } else if (sc->stps_count && current_sample+key_off == sc->stps_data[stps_index]) {\n                    keyframe = 1;\n                    if (stps_index + 1 < sc->stps_count)\n                        stps_index++;\n                }\n                if (keyframe)\n                    distance = 0;\n                sample_size = sc->alt_sample_size > 0 ? sc->alt_sample_size : sc->sample_sizes[current_sample];\n                if (sc->pseudo_stream_id == -1 ||\n                   sc->stsc_data[stsc_index].id - 1 == sc->pseudo_stream_id) {\n                    AVIndexEntry *e = &st->index_entries[st->nb_index_entries++];\n                    e->pos = current_offset;\n                    e->timestamp = current_dts;\n                    e->size = sample_size;\n                    e->min_distance = distance;\n                    e->flags = keyframe ? AVINDEX_KEYFRAME : 0;\n                    av_dlog(mov->fc, \"AVIndex stream %d, sample %d, offset %\"PRIx64\", dts %\"PRId64\", \"\n                            \"size %d, distance %d, keyframe %d\\n\", st->index, current_sample,\n                            current_offset, current_dts, sample_size, distance, keyframe);\n                }\n\n                current_offset += sample_size;\n                stream_size += sample_size;\n                current_dts += sc->stts_data[stts_index].duration;\n                distance++;\n                stts_sample++;\n                current_sample++;\n                if (stts_index + 1 < sc->stts_count && stts_sample == sc->stts_data[stts_index].count) {\n                    stts_sample = 0;\n                    stts_index++;\n                }\n            }\n        }\n        if (st->duration > 0)\n            st->codec->bit_rate = stream_size*8*sc->time_scale/st->duration;\n    } else {\n        unsigned chunk_samples, total = 0;\n\n        // compute total chunk count\n        for (i = 0; i < sc->stsc_count; i++) {\n            unsigned count, chunk_count;\n\n            chunk_samples = sc->stsc_data[i].count;\n            if (i != sc->stsc_count - 1 &&\n                sc->samples_per_frame && chunk_samples % sc->samples_per_frame) {\n                av_log(mov->fc, AV_LOG_ERROR, \"error unaligned chunk\\n\");\n                return;\n            }\n\n            if (sc->samples_per_frame >= 160) { // gsm\n                count = chunk_samples / sc->samples_per_frame;\n            } else if (sc->samples_per_frame > 1) {\n                unsigned samples = (1024/sc->samples_per_frame)*sc->samples_per_frame;\n                count = (chunk_samples+samples-1) / samples;\n            } else {\n                count = (chunk_samples+1023) / 1024;\n            }\n\n            if (i < sc->stsc_count - 1)\n                chunk_count = sc->stsc_data[i+1].first - sc->stsc_data[i].first;\n            else\n                chunk_count = sc->chunk_count - (sc->stsc_data[i].first - 1);\n            total += chunk_count * count;\n        }\n\n        av_dlog(mov->fc, \"chunk count %d\\n\", total);\n        if (total >= UINT_MAX / sizeof(*st->index_entries) - st->nb_index_entries)\n            return;\n        mem = av_realloc(st->index_entries, (st->nb_index_entries + total) * sizeof(*st->index_entries));\n        if (!mem)\n            return;\n        st->index_entries = mem;\n        st->index_entries_allocated_size = (st->nb_index_entries + total) * sizeof(*st->index_entries);\n\n        // populate index\n        for (i = 0; i < sc->chunk_count; i++) {\n            current_offset = sc->chunk_offsets[i];\n            if (stsc_index + 1 < sc->stsc_count &&\n                i + 1 == sc->stsc_data[stsc_index + 1].first)\n                stsc_index++;\n            chunk_samples = sc->stsc_data[stsc_index].count;\n\n            while (chunk_samples > 0) {\n                AVIndexEntry *e;\n                unsigned size, samples;\n\n                if (sc->samples_per_frame >= 160) { // gsm\n                    samples = sc->samples_per_frame;\n                    size = sc->bytes_per_frame;\n                } else {\n                    if (sc->samples_per_frame > 1) {\n                        samples = FFMIN((1024 / sc->samples_per_frame)*\n                                        sc->samples_per_frame, chunk_samples);\n                        size = (samples / sc->samples_per_frame) * sc->bytes_per_frame;\n                    } else {\n                        samples = FFMIN(1024, chunk_samples);\n                        size = samples * sc->sample_size;\n                    }\n                }\n\n                if (st->nb_index_entries >= total) {\n                    av_log(mov->fc, AV_LOG_ERROR, \"wrong chunk count %d\\n\", total);\n                    return;\n                }\n                e = &st->index_entries[st->nb_index_entries++];\n                e->pos = current_offset;\n                e->timestamp = current_dts;\n                e->size = size;\n                e->min_distance = 0;\n                e->flags = AVINDEX_KEYFRAME;\n                av_dlog(mov->fc, \"AVIndex stream %d, chunk %d, offset %\"PRIx64\", dts %\"PRId64\", \"\n                        \"size %d, duration %d\\n\", st->index, i, current_offset, current_dts,\n                        size, samples);\n\n                current_offset += size;\n                current_dts += samples;\n                chunk_samples -= samples;\n            }\n        }\n    }\n}\n\nstatic int mov_open_dref(AVIOContext **pb, const char *src, MOVDref *ref,\n                         AVIOInterruptCB *int_cb, int use_absolute_path, AVFormatContext *fc)\n{\n    /* try relative path, we do not try the absolute because it can leak information about our\n       system to an attacker */\n    if (ref->nlvl_to > 0 && ref->nlvl_from > 0) {\n        char filename[1024];\n        const char *src_path;\n        int i, l;\n\n        /* find a source dir */\n        src_path = strrchr(src, '/');\n        if (src_path)\n            src_path++;\n        else\n            src_path = src;\n\n        /* find a next level down to target */\n        for (i = 0, l = strlen(ref->path) - 1; l >= 0; l--)\n            if (ref->path[l] == '/') {\n                if (i == ref->nlvl_to - 1)\n                    break;\n                else\n                    i++;\n            }\n\n        /* compose filename if next level down to target was found */\n        if (i == ref->nlvl_to - 1 && src_path - src  < sizeof(filename)) {\n            memcpy(filename, src, src_path - src);\n            filename[src_path - src] = 0;\n\n            for (i = 1; i < ref->nlvl_from; i++)\n                av_strlcat(filename, \"../\", 1024);\n\n            av_strlcat(filename, ref->path + l + 1, 1024);\n\n            if (!avio_open2(pb, filename, AVIO_FLAG_READ, int_cb, NULL))\n                return 0;\n        }\n    } else if (use_absolute_path) {\n        av_log(fc, AV_LOG_WARNING, \"Using absolute path on user request, \"\n               \"this is a possible security issue\\n\");\n        if (!avio_open2(pb, ref->path, AVIO_FLAG_READ, int_cb, NULL))\n            return 0;\n    }\n\n    return AVERROR(ENOENT);\n}\n\nstatic int mov_read_trak(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    MOVStreamContext *sc;\n    int ret;\n\n    st = avformat_new_stream(c->fc, NULL);\n    if (!st) return AVERROR(ENOMEM);\n    st->id = c->fc->nb_streams;\n    sc = av_mallocz(sizeof(MOVStreamContext));\n    if (!sc) return AVERROR(ENOMEM);\n\n    st->priv_data = sc;\n    st->codec->codec_type = AVMEDIA_TYPE_DATA;\n    sc->ffindex = st->index;\n\n    if ((ret = mov_read_default(c, pb, atom)) < 0)\n        return ret;\n\n    /* sanity checks */\n    if (sc->chunk_count && (!sc->stts_count || !sc->stsc_count ||\n                            (!sc->sample_size && !sc->sample_count))) {\n        av_log(c->fc, AV_LOG_ERROR, \"stream %d, missing mandatory atoms, broken header\\n\",\n               st->index);\n        return 0;\n    }\n\n    if (sc->time_scale <= 0) {\n        av_log(c->fc, AV_LOG_WARNING, \"stream %d, timescale not set\\n\", st->index);\n        sc->time_scale = c->time_scale;\n        if (sc->time_scale <= 0)\n            sc->time_scale = 1;\n    }\n\n    avpriv_set_pts_info(st, 64, 1, sc->time_scale);\n\n    mov_build_index(c, st);\n\n    if (sc->dref_id-1 < sc->drefs_count && sc->drefs[sc->dref_id-1].path) {\n        MOVDref *dref = &sc->drefs[sc->dref_id - 1];\n        if (mov_open_dref(&sc->pb, c->fc->filename, dref, &c->fc->interrupt_callback,\n            c->use_absolute_path, c->fc) < 0)\n            av_log(c->fc, AV_LOG_ERROR,\n                   \"stream %d, error opening alias: path='%s', dir='%s', \"\n                   \"filename='%s', volume='%s', nlvl_from=%d, nlvl_to=%d\\n\",\n                   st->index, dref->path, dref->dir, dref->filename,\n                   dref->volume, dref->nlvl_from, dref->nlvl_to);\n    } else\n        sc->pb = c->fc->pb;\n\n    if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO) {\n        if (!st->sample_aspect_ratio.num &&\n            (st->codec->width != sc->width || st->codec->height != sc->height)) {\n            st->sample_aspect_ratio = av_d2q(((double)st->codec->height * sc->width) /\n                                             ((double)st->codec->width * sc->height), INT_MAX);\n        }\n\n        av_reduce(&st->avg_frame_rate.num, &st->avg_frame_rate.den,\n                  sc->time_scale*st->nb_frames, st->duration, INT_MAX);\n\n        if (sc->stts_count == 1 || (sc->stts_count == 2 && sc->stts_data[1].count == 1))\n            av_reduce(&st->r_frame_rate.num, &st->r_frame_rate.den,\n                      sc->time_scale, sc->stts_data[0].duration, INT_MAX);\n    }\n\n    switch (st->codec->codec_id) {\n#if CONFIG_H261_DECODER\n    case CODEC_ID_H261:\n#endif\n#if CONFIG_H263_DECODER\n    case CODEC_ID_H263:\n#endif\n#if CONFIG_H264_DECODER\n    case CODEC_ID_H264:\n#endif\n#if CONFIG_MPEG4_DECODER\n    case CODEC_ID_MPEG4:\n#endif\n        st->codec->width = 0; /* let decoder init width/height */\n        st->codec->height= 0;\n        break;\n    }\n\n    /* Do not need those anymore. */\n    av_freep(&sc->chunk_offsets);\n    av_freep(&sc->stsc_data);\n    av_freep(&sc->sample_sizes);\n    av_freep(&sc->keyframes);\n    av_freep(&sc->stts_data);\n    av_freep(&sc->stps_data);\n\n    return 0;\n}\n\nstatic int mov_read_ilst(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    int ret;\n    c->itunes_metadata = 1;\n    ret = mov_read_default(c, pb, atom);\n    c->itunes_metadata = 0;\n    return ret;\n}\n\nstatic int mov_read_meta(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    while (atom.size > 8) {\n        uint32_t tag = avio_rl32(pb);\n        atom.size -= 4;\n        if (tag == MKTAG('h','d','l','r')) {\n            avio_seek(pb, -8, SEEK_CUR);\n            atom.size += 8;\n            return mov_read_default(c, pb, atom);\n        }\n    }\n    return 0;\n}\n\nstatic int mov_read_tkhd(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    int i;\n    int width;\n    int height;\n    int64_t disp_transform[2];\n    int display_matrix[3][2];\n    AVStream *st;\n    MOVStreamContext *sc;\n    int version;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n    sc = st->priv_data;\n\n    version = avio_r8(pb);\n    avio_rb24(pb); /* flags */\n    /*\n    MOV_TRACK_ENABLED 0x0001\n    MOV_TRACK_IN_MOVIE 0x0002\n    MOV_TRACK_IN_PREVIEW 0x0004\n    MOV_TRACK_IN_POSTER 0x0008\n    */\n\n    if (version == 1) {\n        avio_rb64(pb);\n        avio_rb64(pb);\n    } else {\n        avio_rb32(pb); /* creation time */\n        avio_rb32(pb); /* modification time */\n    }\n    st->id = (int)avio_rb32(pb); /* track id (NOT 0 !)*/\n    avio_rb32(pb); /* reserved */\n\n    /* highlevel (considering edits) duration in movie timebase */\n    (version == 1) ? avio_rb64(pb) : avio_rb32(pb);\n    avio_rb32(pb); /* reserved */\n    avio_rb32(pb); /* reserved */\n\n    avio_rb16(pb); /* layer */\n    avio_rb16(pb); /* alternate group */\n    avio_rb16(pb); /* volume */\n    avio_rb16(pb); /* reserved */\n\n    //read in the display matrix (outlined in ISO 14496-12, Section 6.2.2)\n    // they're kept in fixed point format through all calculations\n    // ignore u,v,z b/c we don't need the scale factor to calc aspect ratio\n    for (i = 0; i < 3; i++) {\n        display_matrix[i][0] = avio_rb32(pb);   // 16.16 fixed point\n        display_matrix[i][1] = avio_rb32(pb);   // 16.16 fixed point\n        avio_rb32(pb);           // 2.30 fixed point (not used)\n    }\n\n    width = avio_rb32(pb);       // 16.16 fixed point track width\n    height = avio_rb32(pb);      // 16.16 fixed point track height\n    sc->width = width >> 16;\n    sc->height = height >> 16;\n\n    //Assign clockwise rotate values based on transform matrix so that\n    //we can compensate for iPhone orientation during capture.\n\n    if (display_matrix[1][0] == -65536 && display_matrix[0][1] == 65536) {\n         av_dict_set(&st->metadata, \"rotate\", \"90\", 0);\n    }\n\n    if (display_matrix[0][0] == -65536 && display_matrix[1][1] == -65536) {\n         av_dict_set(&st->metadata, \"rotate\", \"180\", 0);\n    }\n\n    if (display_matrix[1][0] == 65536 && display_matrix[0][1] == -65536) {\n         av_dict_set(&st->metadata, \"rotate\", \"270\", 0);\n    }\n\n    // transform the display width/height according to the matrix\n    // skip this if the display matrix is the default identity matrix\n    // or if it is rotating the picture, ex iPhone 3GS\n    // to keep the same scale, use [width height 1<<16]\n    if (width && height &&\n        ((display_matrix[0][0] != 65536  ||\n          display_matrix[1][1] != 65536) &&\n         !display_matrix[0][1] &&\n         !display_matrix[1][0] &&\n         !display_matrix[2][0] && !display_matrix[2][1])) {\n        for (i = 0; i < 2; i++)\n            disp_transform[i] =\n                (int64_t)  width  * display_matrix[0][i] +\n                (int64_t)  height * display_matrix[1][i] +\n                ((int64_t) display_matrix[2][i] << 16);\n\n        //sample aspect ratio is new width/height divided by old width/height\n        st->sample_aspect_ratio = av_d2q(\n            ((double) disp_transform[0] * height) /\n            ((double) disp_transform[1] * width), INT_MAX);\n    }\n    return 0;\n}\n\nstatic int mov_read_tfhd(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    MOVFragment *frag = &c->fragment;\n    MOVTrackExt *trex = NULL;\n    int flags, track_id, i;\n\n    avio_r8(pb); /* version */\n    flags = avio_rb24(pb);\n\n    track_id = avio_rb32(pb);\n    if (!track_id)\n        return AVERROR_INVALIDDATA;\n    frag->track_id = track_id;\n    for (i = 0; i < c->trex_count; i++)\n        if (c->trex_data[i].track_id == frag->track_id) {\n            trex = &c->trex_data[i];\n            break;\n        }\n    if (!trex) {\n        av_log(c->fc, AV_LOG_ERROR, \"could not find corresponding trex\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    frag->base_data_offset = flags & MOV_TFHD_BASE_DATA_OFFSET ?\n                             avio_rb64(pb) : frag->moof_offset;\n    frag->stsd_id  = flags & MOV_TFHD_STSD_ID ? avio_rb32(pb) : trex->stsd_id;\n\n    frag->duration = flags & MOV_TFHD_DEFAULT_DURATION ?\n                     avio_rb32(pb) : trex->duration;\n    frag->size     = flags & MOV_TFHD_DEFAULT_SIZE ?\n                     avio_rb32(pb) : trex->size;\n    frag->flags    = flags & MOV_TFHD_DEFAULT_FLAGS ?\n                     avio_rb32(pb) : trex->flags;\n    av_dlog(c->fc, \"frag flags 0x%x\\n\", frag->flags);\n    return 0;\n}\n\nstatic int mov_read_chap(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    c->chapter_track = avio_rb32(pb);\n    return 0;\n}\n\nstatic int mov_read_trex(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    MOVTrackExt *trex;\n\n    if ((uint64_t)c->trex_count+1 >= UINT_MAX / sizeof(*c->trex_data))\n        return AVERROR_INVALIDDATA;\n    trex = av_realloc(c->trex_data, (c->trex_count+1)*sizeof(*c->trex_data));\n    if (!trex)\n        return AVERROR(ENOMEM);\n\n    c->fc->duration = AV_NOPTS_VALUE; // the duration from mvhd is not representing the whole file when fragments are used.\n\n    c->trex_data = trex;\n    trex = &c->trex_data[c->trex_count++];\n    avio_r8(pb); /* version */\n    avio_rb24(pb); /* flags */\n    trex->track_id = avio_rb32(pb);\n    trex->stsd_id  = avio_rb32(pb);\n    trex->duration = avio_rb32(pb);\n    trex->size     = avio_rb32(pb);\n    trex->flags    = avio_rb32(pb);\n    return 0;\n}\n\nstatic int mov_read_trun(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    MOVFragment *frag = &c->fragment;\n    AVStream *st = NULL;\n    MOVStreamContext *sc;\n    MOVStts *ctts_data;\n    uint64_t offset;\n    int64_t dts;\n    int data_offset = 0;\n    unsigned entries, first_sample_flags = frag->flags;\n    int flags, distance, i, found_keyframe = 0;\n\n    for (i = 0; i < c->fc->nb_streams; i++) {\n        if (c->fc->streams[i]->id == frag->track_id) {\n            st = c->fc->streams[i];\n            break;\n        }\n    }\n    if (!st) {\n        av_log(c->fc, AV_LOG_ERROR, \"could not find corresponding track id %d\\n\", frag->track_id);\n        return AVERROR_INVALIDDATA;\n    }\n    sc = st->priv_data;\n    if (sc->pseudo_stream_id+1 != frag->stsd_id)\n        return 0;\n    avio_r8(pb); /* version */\n    flags = avio_rb24(pb);\n    entries = avio_rb32(pb);\n    av_dlog(c->fc, \"flags 0x%x entries %d\\n\", flags, entries);\n\n    /* Always assume the presence of composition time offsets.\n     * Without this assumption, for instance, we cannot deal with a track in fragmented movies that meet the following.\n     *  1) in the initial movie, there are no samples.\n     *  2) in the first movie fragment, there is only one sample without composition time offset.\n     *  3) in the subsequent movie fragments, there are samples with composition time offset. */\n    if (!sc->ctts_count && sc->sample_count)\n    {\n        /* Complement ctts table if moov atom doesn't have ctts atom. */\n        ctts_data = av_malloc(sizeof(*sc->ctts_data));\n        if (!ctts_data)\n            return AVERROR(ENOMEM);\n        sc->ctts_data = ctts_data;\n        sc->ctts_data[sc->ctts_count].count = sc->sample_count;\n        sc->ctts_data[sc->ctts_count].duration = 0;\n        sc->ctts_count++;\n    }\n    if ((uint64_t)entries+sc->ctts_count >= UINT_MAX/sizeof(*sc->ctts_data))\n        return AVERROR_INVALIDDATA;\n    ctts_data = av_realloc(sc->ctts_data,\n                           (entries+sc->ctts_count)*sizeof(*sc->ctts_data));\n    if (!ctts_data)\n        return AVERROR(ENOMEM);\n    sc->ctts_data = ctts_data;\n\n    if (flags & MOV_TRUN_DATA_OFFSET)        data_offset        = avio_rb32(pb);\n    if (flags & MOV_TRUN_FIRST_SAMPLE_FLAGS) first_sample_flags = avio_rb32(pb);\n    dts    = sc->track_end - sc->time_offset;\n    offset = frag->base_data_offset + data_offset;\n    distance = 0;\n    av_dlog(c->fc, \"first sample flags 0x%x\\n\", first_sample_flags);\n    for (i = 0; i < entries; i++) {\n        unsigned sample_size = frag->size;\n        int sample_flags = i ? frag->flags : first_sample_flags;\n        unsigned sample_duration = frag->duration;\n        int keyframe = 0;\n\n        if (flags & MOV_TRUN_SAMPLE_DURATION) sample_duration = avio_rb32(pb);\n        if (flags & MOV_TRUN_SAMPLE_SIZE)     sample_size     = avio_rb32(pb);\n        if (flags & MOV_TRUN_SAMPLE_FLAGS)    sample_flags    = avio_rb32(pb);\n        sc->ctts_data[sc->ctts_count].count = 1;\n        sc->ctts_data[sc->ctts_count].duration = (flags & MOV_TRUN_SAMPLE_CTS) ?\n                                                  avio_rb32(pb) : 0;\n        sc->ctts_count++;\n        if (st->codec->codec_type == AVMEDIA_TYPE_AUDIO)\n            keyframe = 1;\n        else if (!found_keyframe)\n            keyframe = found_keyframe =\n                !(sample_flags & (MOV_FRAG_SAMPLE_FLAG_IS_NON_SYNC |\n                                  MOV_FRAG_SAMPLE_FLAG_DEPENDS_YES));\n        if (keyframe)\n            distance = 0;\n        av_add_index_entry(st, offset, dts, sample_size, distance,\n                           keyframe ? AVINDEX_KEYFRAME : 0);\n        av_dlog(c->fc, \"AVIndex stream %d, sample %d, offset %\"PRIx64\", dts %\"PRId64\", \"\n                \"size %d, distance %d, keyframe %d\\n\", st->index, sc->sample_count+i,\n                offset, dts, sample_size, distance, keyframe);\n        distance++;\n        dts += sample_duration;\n        offset += sample_size;\n        sc->data_size += sample_size;\n    }\n    frag->moof_offset = offset;\n    st->duration = sc->track_end = dts + sc->time_offset;\n    return 0;\n}\n\n/* this atom should be null (from specs), but some buggy files put the 'moov' atom inside it... */\n/* like the files created with Adobe Premiere 5.0, for samples see */\n/* http://graphics.tudelft.nl/~wouter/publications/soundtests/ */\nstatic int mov_read_wide(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    int err;\n\n    if (atom.size < 8)\n        return 0; /* continue */\n    if (avio_rb32(pb) != 0) { /* 0 sized mdat atom... use the 'wide' atom size */\n        avio_skip(pb, atom.size - 4);\n        return 0;\n    }\n    atom.type = avio_rl32(pb);\n    atom.size -= 8;\n    if (atom.type != MKTAG('m','d','a','t')) {\n        avio_skip(pb, atom.size);\n        return 0;\n    }\n    err = mov_read_mdat(c, pb, atom);\n    return err;\n}\n\nstatic int mov_read_cmov(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n#if CONFIG_ZLIB\n    AVIOContext ctx;\n    uint8_t *cmov_data;\n    uint8_t *moov_data; /* uncompressed data */\n    long cmov_len, moov_len;\n    int ret = -1;\n\n    avio_rb32(pb); /* dcom atom */\n    if (avio_rl32(pb) != MKTAG('d','c','o','m'))\n        return AVERROR_INVALIDDATA;\n    if (avio_rl32(pb) != MKTAG('z','l','i','b')) {\n        av_log(c->fc, AV_LOG_ERROR, \"unknown compression for cmov atom !\");\n        return AVERROR_INVALIDDATA;\n    }\n    avio_rb32(pb); /* cmvd atom */\n    if (avio_rl32(pb) != MKTAG('c','m','v','d'))\n        return AVERROR_INVALIDDATA;\n    moov_len = avio_rb32(pb); /* uncompressed size */\n    cmov_len = atom.size - 6 * 4;\n\n    cmov_data = av_malloc(cmov_len);\n    if (!cmov_data)\n        return AVERROR(ENOMEM);\n    moov_data = av_malloc(moov_len);\n    if (!moov_data) {\n        av_free(cmov_data);\n        return AVERROR(ENOMEM);\n    }\n    avio_read(pb, cmov_data, cmov_len);\n    if (uncompress (moov_data, (uLongf *) &moov_len, (const Bytef *)cmov_data, cmov_len) != Z_OK)\n        goto free_and_return;\n    if (ffio_init_context(&ctx, moov_data, moov_len, 0, NULL, NULL, NULL, NULL) != 0)\n        goto free_and_return;\n    atom.type = MKTAG('m','o','o','v');\n    atom.size = moov_len;\n    ret = mov_read_default(c, &ctx, atom);\nfree_and_return:\n    av_free(moov_data);\n    av_free(cmov_data);\n    return ret;\n#else\n    av_log(c->fc, AV_LOG_ERROR, \"this file requires zlib support compiled in\\n\");\n    return AVERROR(ENOSYS);\n#endif\n}\n\n/* edit list atom */\nstatic int mov_read_elst(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    MOVStreamContext *sc;\n    int i, edit_count, version, edit_start_index = 0;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    sc = c->fc->streams[c->fc->nb_streams-1]->priv_data;\n\n    version = avio_r8(pb); /* version */\n    avio_rb24(pb); /* flags */\n    edit_count = avio_rb32(pb); /* entries */\n\n    if ((uint64_t)edit_count*12+8 > atom.size)\n        return AVERROR_INVALIDDATA;\n\n    for (i=0; i<edit_count; i++){\n        int64_t time;\n        int64_t duration;\n        if (version == 1) {\n            duration = avio_rb64(pb);\n            time     = avio_rb64(pb);\n        } else {\n            duration = avio_rb32(pb); /* segment duration */\n            time     = (int32_t)avio_rb32(pb); /* media time */\n        }\n        avio_rb32(pb); /* Media rate */\n        if (i == 0 && time == -1) {\n            sc->empty_duration = duration;\n            edit_start_index = 1;\n        } else if (i == edit_start_index && time >= 0)\n            sc->start_time = time;\n    }\n\n    if (edit_count > 1)\n        av_log(c->fc, AV_LOG_WARNING, \"multiple edit list entries, \"\n               \"a/v desync might occur, patch welcome\\n\");\n\n    av_dlog(c->fc, \"track[%i].edit_count = %i\\n\", c->fc->nb_streams-1, edit_count);\n    return 0;\n}\n\nstatic int mov_read_chan2(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    if (atom.size < 16)\n        return 0;\n    avio_skip(pb, 4);\n    ff_mov_read_chan(c->fc, atom.size - 4, c->fc->streams[0]->codec);\n    return 0;\n}\n\nstatic const MOVParseTableEntry mov_default_parse_table[] = {\n{ MKTAG('a','v','s','s'), mov_read_avss },\n{ MKTAG('c','h','p','l'), mov_read_chpl },\n{ MKTAG('c','o','6','4'), mov_read_stco },\n{ MKTAG('c','t','t','s'), mov_read_ctts }, /* composition time to sample */\n{ MKTAG('d','i','n','f'), mov_read_default },\n{ MKTAG('d','r','e','f'), mov_read_dref },\n{ MKTAG('e','d','t','s'), mov_read_default },\n{ MKTAG('e','l','s','t'), mov_read_elst },\n{ MKTAG('e','n','d','a'), mov_read_enda },\n{ MKTAG('f','i','e','l'), mov_read_fiel },\n{ MKTAG('f','t','y','p'), mov_read_ftyp },\n{ MKTAG('g','l','b','l'), mov_read_glbl },\n{ MKTAG('h','d','l','r'), mov_read_hdlr },\n{ MKTAG('i','l','s','t'), mov_read_ilst },\n{ MKTAG('j','p','2','h'), mov_read_jp2h },\n{ MKTAG('m','d','a','t'), mov_read_mdat },\n{ MKTAG('m','d','h','d'), mov_read_mdhd },\n{ MKTAG('m','d','i','a'), mov_read_default },\n{ MKTAG('m','e','t','a'), mov_read_meta },\n{ MKTAG('m','i','n','f'), mov_read_default },\n{ MKTAG('m','o','o','f'), mov_read_moof },\n{ MKTAG('m','o','o','v'), mov_read_moov },\n{ MKTAG('m','v','e','x'), mov_read_default },\n{ MKTAG('m','v','h','d'), mov_read_mvhd },\n{ MKTAG('S','M','I',' '), mov_read_smi }, /* Sorenson extension ??? */\n{ MKTAG('a','l','a','c'), mov_read_alac }, /* alac specific atom */\n{ MKTAG('a','v','c','C'), mov_read_glbl },\n{ MKTAG('p','a','s','p'), mov_read_pasp },\n{ MKTAG('s','t','b','l'), mov_read_default },\n{ MKTAG('s','t','c','o'), mov_read_stco },\n{ MKTAG('s','t','p','s'), mov_read_stps },\n{ MKTAG('s','t','r','f'), mov_read_strf },\n{ MKTAG('s','t','s','c'), mov_read_stsc },\n{ MKTAG('s','t','s','d'), mov_read_stsd }, /* sample description */\n{ MKTAG('s','t','s','s'), mov_read_stss }, /* sync sample */\n{ MKTAG('s','t','s','z'), mov_read_stsz }, /* sample size */\n{ MKTAG('s','t','t','s'), mov_read_stts },\n{ MKTAG('s','t','z','2'), mov_read_stsz }, /* compact sample size */\n{ MKTAG('t','k','h','d'), mov_read_tkhd }, /* track header */\n{ MKTAG('t','f','h','d'), mov_read_tfhd }, /* track fragment header */\n{ MKTAG('t','r','a','k'), mov_read_trak },\n{ MKTAG('t','r','a','f'), mov_read_default },\n{ MKTAG('t','r','e','f'), mov_read_default },\n{ MKTAG('c','h','a','p'), mov_read_chap },\n{ MKTAG('t','r','e','x'), mov_read_trex },\n{ MKTAG('t','r','u','n'), mov_read_trun },\n{ MKTAG('u','d','t','a'), mov_read_default },\n{ MKTAG('w','a','v','e'), mov_read_wave },\n{ MKTAG('e','s','d','s'), mov_read_esds },\n{ MKTAG('d','a','c','3'), mov_read_dac3 }, /* AC-3 info */\n{ MKTAG('w','i','d','e'), mov_read_wide }, /* place holder */\n{ MKTAG('w','f','e','x'), mov_read_wfex },\n{ MKTAG('c','m','o','v'), mov_read_cmov },\n{ MKTAG('c','h','a','n'), mov_read_chan }, /* channel layout */\n{ MKTAG('d','v','c','1'), mov_read_dvc1 },\n{ 0, NULL }\n};\n\nstatic int mov_probe(AVProbeData *p)\n{\n    unsigned int offset;\n    uint32_t tag;\n    int score = 0;\n\n    /* check file header */\n    offset = 0;\n    for (;;) {\n        /* ignore invalid offset */\n        if ((offset + 8) > (unsigned int)p->buf_size)\n            return score;\n        tag = AV_RL32(p->buf + offset + 4);\n        switch(tag) {\n        /* check for obvious tags */\n        case MKTAG('j','P',' ',' '): /* jpeg 2000 signature */\n        case MKTAG('m','o','o','v'):\n        case MKTAG('m','d','a','t'):\n        case MKTAG('p','n','o','t'): /* detect movs with preview pics like ew.mov and april.mov */\n        case MKTAG('u','d','t','a'): /* Packet Video PVAuthor adds this and a lot of more junk */\n        case MKTAG('f','t','y','p'):\n            return AVPROBE_SCORE_MAX;\n        /* those are more common words, so rate then a bit less */\n        case MKTAG('e','d','i','w'): /* xdcam files have reverted first tags */\n        case MKTAG('w','i','d','e'):\n        case MKTAG('f','r','e','e'):\n        case MKTAG('j','u','n','k'):\n        case MKTAG('p','i','c','t'):\n            return AVPROBE_SCORE_MAX - 5;\n        case MKTAG(0x82,0x82,0x7f,0x7d):\n        case MKTAG('s','k','i','p'):\n        case MKTAG('u','u','i','d'):\n        case MKTAG('p','r','f','l'):\n            offset = AV_RB32(p->buf+offset) + offset;\n            /* if we only find those cause probedata is too small at least rate them */\n            score = AVPROBE_SCORE_MAX - 50;\n            break;\n        default:\n            /* unrecognized tag */\n            return score;\n        }\n    }\n}\n\n// must be done after parsing all trak because there's no order requirement\nstatic void mov_read_chapters(AVFormatContext *s)\n{\n    MOVContext *mov = s->priv_data;\n    AVStream *st = NULL;\n    MOVStreamContext *sc;\n    int64_t cur_pos;\n    int i;\n\n    for (i = 0; i < s->nb_streams; i++)\n        if (s->streams[i]->id == mov->chapter_track) {\n            st = s->streams[i];\n            break;\n        }\n    if (!st) {\n        av_log(s, AV_LOG_ERROR, \"Referenced QT chapter track not found\\n\");\n        return;\n    }\n\n    st->discard = AVDISCARD_ALL;\n    sc = st->priv_data;\n    cur_pos = avio_tell(sc->pb);\n\n    for (i = 0; i < st->nb_index_entries; i++) {\n        AVIndexEntry *sample = &st->index_entries[i];\n        int64_t end = i+1 < st->nb_index_entries ? st->index_entries[i+1].timestamp : st->duration;\n        uint8_t *title;\n        uint16_t ch;\n        int len, title_len;\n\n        if (avio_seek(sc->pb, sample->pos, SEEK_SET) != sample->pos) {\n            av_log(s, AV_LOG_ERROR, \"Chapter %d not found in file\\n\", i);\n            goto finish;\n        }\n\n        // the first two bytes are the length of the title\n        len = avio_rb16(sc->pb);\n        if (len > sample->size-2)\n            continue;\n        title_len = 2*len + 1;\n        if (!(title = av_mallocz(title_len)))\n            goto finish;\n\n        // The samples could theoretically be in any encoding if there's an encd\n        // atom following, but in practice are only utf-8 or utf-16, distinguished\n        // instead by the presence of a BOM\n        if (!len) {\n            title[0] = 0;\n        } else {\n            ch = avio_rb16(sc->pb);\n            if (ch == 0xfeff)\n                avio_get_str16be(sc->pb, len, title, title_len);\n            else if (ch == 0xfffe)\n                avio_get_str16le(sc->pb, len, title, title_len);\n            else {\n                AV_WB16(title, ch);\n                if (len == 1 || len == 2)\n                    title[len] = 0;\n                else\n                    avio_get_str(sc->pb, INT_MAX, title + 2, len - 1);\n            }\n        }\n\n        avpriv_new_chapter(s, i, st->time_base, sample->timestamp, end, title);\n        av_freep(&title);\n    }\nfinish:\n    avio_seek(sc->pb, cur_pos, SEEK_SET);\n}\n\nstatic int parse_timecode_in_framenum_format(AVFormatContext *s, AVStream *st,\n                                             uint32_t value, int flags)\n{\n    AVTimecode tc;\n    char buf[AV_TIMECODE_STR_SIZE];\n    AVRational rate = {st->codec->time_base.den,\n                       st->codec->time_base.num};\n    int ret = av_timecode_init(&tc, rate, flags, 0, s);\n    if (ret < 0)\n        return ret;\n    av_dict_set(&st->metadata, \"timecode\",\n                av_timecode_make_string(&tc, buf, value), 0);\n    return 0;\n}\n\nstatic int mov_read_timecode_track(AVFormatContext *s, AVStream *st)\n{\n    MOVStreamContext *sc = st->priv_data;\n    int flags = 0;\n    int64_t cur_pos = avio_tell(sc->pb);\n    uint32_t value;\n\n    if (!st->nb_index_entries)\n        return -1;\n\n    avio_seek(sc->pb, st->index_entries->pos, SEEK_SET);\n    value = avio_rb32(s->pb);\n\n    if (sc->tmcd_flags & 0x0001) flags |= AV_TIMECODE_FLAG_DROPFRAME;\n    if (sc->tmcd_flags & 0x0002) flags |= AV_TIMECODE_FLAG_24HOURSMAX;\n    if (sc->tmcd_flags & 0x0004) flags |= AV_TIMECODE_FLAG_ALLOWNEGATIVE;\n\n    /* Assume Counter flag is set to 1 in tmcd track (even though it is likely\n     * not the case) and thus assume \"frame number format\" instead of QT one.\n     * No sample with tmcd track can be found with a QT timecode at the moment,\n     * despite what the tmcd track \"suggests\" (Counter flag set to 0 means QT\n     * format). */\n    parse_timecode_in_framenum_format(s, st, value, flags);\n\n    avio_seek(sc->pb, cur_pos, SEEK_SET);\n    return 0;\n}\n\nstatic int mov_read_close(AVFormatContext *s)\n{\n    MOVContext *mov = s->priv_data;\n    int i, j;\n\n    for (i = 0; i < s->nb_streams; i++) {\n        AVStream *st = s->streams[i];\n        MOVStreamContext *sc = st->priv_data;\n\n        av_freep(&sc->ctts_data);\n        for (j = 0; j < sc->drefs_count; j++) {\n            av_freep(&sc->drefs[j].path);\n            av_freep(&sc->drefs[j].dir);\n        }\n        av_freep(&sc->drefs);\n        if (sc->pb && sc->pb != s->pb)\n            avio_close(sc->pb);\n        sc->pb = NULL;\n        av_freep(&sc->chunk_offsets);\n        av_freep(&sc->keyframes);\n        av_freep(&sc->sample_sizes);\n        av_freep(&sc->stps_data);\n        av_freep(&sc->stsc_data);\n        av_freep(&sc->stts_data);\n    }\n\n    if (mov->dv_demux) {\n        for (i = 0; i < mov->dv_fctx->nb_streams; i++) {\n            av_freep(&mov->dv_fctx->streams[i]->codec);\n            av_freep(&mov->dv_fctx->streams[i]);\n        }\n        av_freep(&mov->dv_fctx);\n        av_freep(&mov->dv_demux);\n    }\n\n    av_freep(&mov->trex_data);\n\n    return 0;\n}\n\nstatic int mov_read_header(AVFormatContext *s)\n{\n    MOVContext *mov = s->priv_data;\n    AVIOContext *pb = s->pb;\n    int err;\n    MOVAtom atom = { AV_RL32(\"root\") };\n\n    mov->fc = s;\n    /* .mov and .mp4 aren't streamable anyway (only progressive download if moov is before mdat) */\n    if (pb->seekable)\n        atom.size = avio_size(pb);\n    else\n        atom.size = INT64_MAX;\n\n    /* check MOV header */\n    if ((err = mov_read_default(mov, pb, atom)) < 0) {\n        av_log(s, AV_LOG_ERROR, \"error reading header: %d\\n\", err);\n        mov_read_close(s);\n        return err;\n    }\n    if (!mov->found_moov) {\n        av_log(s, AV_LOG_ERROR, \"moov atom not found\\n\");\n        mov_read_close(s);\n        return AVERROR_INVALIDDATA;\n    }\n    av_dlog(mov->fc, \"on_parse_exit_offset=%\"PRId64\"\\n\", avio_tell(pb));\n\n    if (pb->seekable) {\n        int i;\n        if (mov->chapter_track > 0)\n            mov_read_chapters(s);\n        for (i = 0; i < s->nb_streams; i++)\n            if (s->streams[i]->codec->codec_tag == AV_RL32(\"tmcd\"))\n                mov_read_timecode_track(s, s->streams[i]);\n    }\n\n    if (mov->trex_data) {\n        int i;\n        for (i = 0; i < s->nb_streams; i++) {\n            AVStream *st = s->streams[i];\n            MOVStreamContext *sc = st->priv_data;\n            if (st->duration)\n                st->codec->bit_rate = sc->data_size * 8 * sc->time_scale / st->duration;\n        }\n    }\n\n    return 0;\n}\n\nstatic AVIndexEntry *mov_find_next_sample(AVFormatContext *s, AVStream **st)\n{\n    AVIndexEntry *sample = NULL;\n    int64_t best_dts = INT64_MAX;\n    int i;\n    for (i = 0; i < s->nb_streams; i++) {\n        AVStream *avst = s->streams[i];\n        MOVStreamContext *msc = avst->priv_data;\n        if (msc->pb && msc->current_sample < avst->nb_index_entries) {\n            AVIndexEntry *current_sample = &avst->index_entries[msc->current_sample];\n            int64_t dts = av_rescale(current_sample->timestamp, AV_TIME_BASE, msc->time_scale);\n            av_dlog(s, \"stream %d, sample %d, dts %\"PRId64\"\\n\", i, msc->current_sample, dts);\n            if (!sample || (!s->pb->seekable && current_sample->pos < sample->pos) ||\n                (s->pb->seekable &&\n                 ((msc->pb != s->pb && dts < best_dts) || (msc->pb == s->pb &&\n                 ((FFABS(best_dts - dts) <= AV_TIME_BASE && current_sample->pos < sample->pos) ||\n                  (FFABS(best_dts - dts) > AV_TIME_BASE && dts < best_dts)))))) {\n                sample = current_sample;\n                best_dts = dts;\n                *st = avst;\n            }\n        }\n    }\n    return sample;\n}\n\nstatic int mov_read_packet(AVFormatContext *s, AVPacket *pkt)\n{\n    MOVContext *mov = s->priv_data;\n    MOVStreamContext *sc;\n    AVIndexEntry *sample;\n    AVStream *st = NULL;\n    int ret;\n    mov->fc = s;\n retry:\n    sample = mov_find_next_sample(s, &st);\n    if (!sample) {\n        mov->found_mdat = 0;\n        if (!mov->next_root_atom)\n            return AVERROR_EOF;\n        avio_seek(s->pb, mov->next_root_atom, SEEK_SET);\n        mov->next_root_atom = 0;\n        if (mov_read_default(mov, s->pb, (MOVAtom){ AV_RL32(\"root\"), INT64_MAX }) < 0 ||\n            url_feof(s->pb))\n            return AVERROR_EOF;\n        av_dlog(s, \"read fragments, offset 0x%\"PRIx64\"\\n\", avio_tell(s->pb));\n        goto retry;\n    }\n    sc = st->priv_data;\n    /* must be done just before reading, to avoid infinite loop on sample */\n    sc->current_sample++;\n\n    if (st->discard != AVDISCARD_ALL) {\n        if (avio_seek(sc->pb, sample->pos, SEEK_SET) != sample->pos) {\n            av_log(mov->fc, AV_LOG_ERROR, \"stream %d, offset 0x%\"PRIx64\": partial file\\n\",\n                   sc->ffindex, sample->pos);\n            return AVERROR_INVALIDDATA;\n        }\n        ret = av_get_packet(sc->pb, pkt, sample->size);\n        if (ret < 0)\n            return ret;\n        if (sc->has_palette) {\n            uint8_t *pal;\n\n            pal = av_packet_new_side_data(pkt, AV_PKT_DATA_PALETTE, AVPALETTE_SIZE);\n            if (!pal) {\n                av_log(mov->fc, AV_LOG_ERROR, \"Cannot append palette to packet\\n\");\n            } else {\n                memcpy(pal, sc->palette, AVPALETTE_SIZE);\n                sc->has_palette = 0;\n            }\n        }\n#if CONFIG_DV_DEMUXER\n        if (mov->dv_demux && sc->dv_audio_container) {\n            avpriv_dv_produce_packet(mov->dv_demux, pkt, pkt->data, pkt->size, pkt->pos);\n            av_free(pkt->data);\n            pkt->size = 0;\n            ret = avpriv_dv_get_packet(mov->dv_demux, pkt);\n            if (ret < 0)\n                return ret;\n        }\n#endif\n    }\n\n    pkt->stream_index = sc->ffindex;\n    pkt->dts = sample->timestamp;\n    if (sc->ctts_data && sc->ctts_index < sc->ctts_count) {\n        pkt->pts = pkt->dts + sc->dts_shift + sc->ctts_data[sc->ctts_index].duration;\n        /* update ctts context */\n        sc->ctts_sample++;\n        if (sc->ctts_index < sc->ctts_count &&\n            sc->ctts_data[sc->ctts_index].count == sc->ctts_sample) {\n            sc->ctts_index++;\n            sc->ctts_sample = 0;\n        }\n        if (sc->wrong_dts)\n            pkt->dts = AV_NOPTS_VALUE;\n    } else {\n        int64_t next_dts = (sc->current_sample < st->nb_index_entries) ?\n            st->index_entries[sc->current_sample].timestamp : st->duration;\n        pkt->duration = next_dts - pkt->dts;\n        pkt->pts = pkt->dts;\n    }\n    if (st->discard == AVDISCARD_ALL)\n        goto retry;\n    pkt->flags |= sample->flags & AVINDEX_KEYFRAME ? AV_PKT_FLAG_KEY : 0;\n    pkt->pos = sample->pos;\n    av_dlog(s, \"stream %d, pts %\"PRId64\", dts %\"PRId64\", pos 0x%\"PRIx64\", duration %d\\n\",\n            pkt->stream_index, pkt->pts, pkt->dts, pkt->pos, pkt->duration);\n    return 0;\n}\n\nstatic int mov_seek_stream(AVFormatContext *s, AVStream *st, int64_t timestamp, int flags)\n{\n    MOVStreamContext *sc = st->priv_data;\n    int sample, time_sample;\n    int i;\n\n    sample = av_index_search_timestamp(st, timestamp, flags);\n    av_dlog(s, \"stream %d, timestamp %\"PRId64\", sample %d\\n\", st->index, timestamp, sample);\n    if (sample < 0 && st->nb_index_entries && timestamp < st->index_entries[0].timestamp)\n        sample = 0;\n    if (sample < 0) /* not sure what to do */\n        return AVERROR_INVALIDDATA;\n    sc->current_sample = sample;\n    av_dlog(s, \"stream %d, found sample %d\\n\", st->index, sc->current_sample);\n    /* adjust ctts index */\n    if (sc->ctts_data) {\n        time_sample = 0;\n        for (i = 0; i < sc->ctts_count; i++) {\n            int next = time_sample + sc->ctts_data[i].count;\n            if (next > sc->current_sample) {\n                sc->ctts_index = i;\n                sc->ctts_sample = sc->current_sample - time_sample;\n                break;\n            }\n            time_sample = next;\n        }\n    }\n    return sample;\n}\n\nstatic int mov_read_seek(AVFormatContext *s, int stream_index, int64_t sample_time, int flags)\n{\n    AVStream *st;\n    int64_t seek_timestamp, timestamp;\n    int sample;\n    int i;\n\n    if (stream_index >= s->nb_streams)\n        return AVERROR_INVALIDDATA;\n    if (sample_time < 0)\n        sample_time = 0;\n\n    st = s->streams[stream_index];\n    sample = mov_seek_stream(s, st, sample_time, flags);\n    if (sample < 0)\n        return sample;\n\n    /* adjust seek timestamp to found sample timestamp */\n    seek_timestamp = st->index_entries[sample].timestamp;\n\n    for (i = 0; i < s->nb_streams; i++) {\n        st = s->streams[i];\n        if (stream_index == i)\n            continue;\n\n        timestamp = av_rescale_q(seek_timestamp, s->streams[stream_index]->time_base, st->time_base);\n        mov_seek_stream(s, st, timestamp, flags);\n    }\n    return 0;\n}\n\nstatic const AVOption options[] = {\n    {\"use_absolute_path\",\n        \"allow using absolute path when opening alias, this is a possible security issue\",\n        offsetof(MOVContext, use_absolute_path), FF_OPT_TYPE_INT, {.dbl = 0},\n        0, 1, AV_OPT_FLAG_VIDEO_PARAM|AV_OPT_FLAG_DECODING_PARAM},\n    {NULL}\n};\nstatic const AVClass class = {\"mov,mp4,m4a,3gp,3g2,mj2\", av_default_item_name, options, LIBAVUTIL_VERSION_INT};\n\n\nAVInputFormat ff_mov_demuxer = {\n    .name           = \"mov,mp4,m4a,3gp,3g2,mj2\",\n    .long_name      = NULL_IF_CONFIG_SMALL(\"QuickTime/MPEG-4/Motion JPEG 2000 format\"),\n    .priv_data_size = sizeof(MOVContext),\n    .read_probe     = mov_probe,\n    .read_header    = mov_read_header,\n    .read_packet    = mov_read_packet,\n    .read_close     = mov_read_close,\n    .read_seek      = mov_read_seek,\n    .priv_class     = &class,\n};\n"], "fixing_code": ["/*\n * MOV demuxer\n * Copyright (c) 2001 Fabrice Bellard\n * Copyright (c) 2009 Baptiste Coudurier <baptiste dot coudurier at gmail dot com>\n *\n * This file is part of FFmpeg.\n *\n * FFmpeg is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with FFmpeg; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n#include <limits.h>\n\n//#define DEBUG\n//#define MOV_EXPORT_ALL_METADATA\n\n#include \"libavutil/audioconvert.h\"\n#include \"libavutil/intreadwrite.h\"\n#include \"libavutil/intfloat.h\"\n#include \"libavutil/mathematics.h\"\n#include \"libavutil/avstring.h\"\n#include \"libavutil/dict.h\"\n#include \"libavutil/opt.h\"\n#include \"libavutil/timecode.h\"\n#include \"libavcodec/ac3tab.h\"\n#include \"avformat.h\"\n#include \"internal.h\"\n#include \"avio_internal.h\"\n#include \"riff.h\"\n#include \"isom.h\"\n#include \"libavcodec/get_bits.h\"\n#include \"id3v1.h\"\n#include \"mov_chan.h\"\n\n#if CONFIG_ZLIB\n#include <zlib.h>\n#endif\n\n/*\n * First version by Francois Revol revol@free.fr\n * Seek function by Gael Chardon gael.dev@4now.net\n */\n\n#include \"qtpalette.h\"\n\n\n#undef NDEBUG\n#include <assert.h>\n\n/* those functions parse an atom */\n/* links atom IDs to parse functions */\ntypedef struct MOVParseTableEntry {\n    uint32_t type;\n    int (*parse)(MOVContext *ctx, AVIOContext *pb, MOVAtom atom);\n} MOVParseTableEntry;\n\nstatic const MOVParseTableEntry mov_default_parse_table[];\n\nstatic int mov_metadata_track_or_disc_number(MOVContext *c, AVIOContext *pb,\n                                             unsigned len, const char *key)\n{\n    char buf[16];\n\n    short current, total = 0;\n    avio_rb16(pb); // unknown\n    current = avio_rb16(pb);\n    if (len >= 6)\n        total = avio_rb16(pb);\n    if (!total)\n        snprintf(buf, sizeof(buf), \"%d\", current);\n    else\n        snprintf(buf, sizeof(buf), \"%d/%d\", current, total);\n    av_dict_set(&c->fc->metadata, key, buf, 0);\n\n    return 0;\n}\n\nstatic int mov_metadata_int8_bypass_padding(MOVContext *c, AVIOContext *pb,\n                                            unsigned len, const char *key)\n{\n    char buf[16];\n\n    /* bypass padding bytes */\n    avio_r8(pb);\n    avio_r8(pb);\n    avio_r8(pb);\n\n    snprintf(buf, sizeof(buf), \"%d\", avio_r8(pb));\n    av_dict_set(&c->fc->metadata, key, buf, 0);\n\n    return 0;\n}\n\nstatic int mov_metadata_int8_no_padding(MOVContext *c, AVIOContext *pb,\n                                        unsigned len, const char *key)\n{\n    char buf[16];\n\n    snprintf(buf, sizeof(buf), \"%d\", avio_r8(pb));\n    av_dict_set(&c->fc->metadata, key, buf, 0);\n\n    return 0;\n}\n\nstatic int mov_metadata_gnre(MOVContext *c, AVIOContext *pb,\n                             unsigned len, const char *key)\n{\n    short genre;\n    char buf[20];\n\n    avio_r8(pb); // unknown\n\n    genre = avio_r8(pb);\n    if (genre < 1 || genre > ID3v1_GENRE_MAX)\n        return 0;\n    snprintf(buf, sizeof(buf), \"%s\", ff_id3v1_genre_str[genre-1]);\n    av_dict_set(&c->fc->metadata, key, buf, 0);\n\n    return 0;\n}\n\nstatic const uint32_t mac_to_unicode[128] = {\n    0x00C4,0x00C5,0x00C7,0x00C9,0x00D1,0x00D6,0x00DC,0x00E1,\n    0x00E0,0x00E2,0x00E4,0x00E3,0x00E5,0x00E7,0x00E9,0x00E8,\n    0x00EA,0x00EB,0x00ED,0x00EC,0x00EE,0x00EF,0x00F1,0x00F3,\n    0x00F2,0x00F4,0x00F6,0x00F5,0x00FA,0x00F9,0x00FB,0x00FC,\n    0x2020,0x00B0,0x00A2,0x00A3,0x00A7,0x2022,0x00B6,0x00DF,\n    0x00AE,0x00A9,0x2122,0x00B4,0x00A8,0x2260,0x00C6,0x00D8,\n    0x221E,0x00B1,0x2264,0x2265,0x00A5,0x00B5,0x2202,0x2211,\n    0x220F,0x03C0,0x222B,0x00AA,0x00BA,0x03A9,0x00E6,0x00F8,\n    0x00BF,0x00A1,0x00AC,0x221A,0x0192,0x2248,0x2206,0x00AB,\n    0x00BB,0x2026,0x00A0,0x00C0,0x00C3,0x00D5,0x0152,0x0153,\n    0x2013,0x2014,0x201C,0x201D,0x2018,0x2019,0x00F7,0x25CA,\n    0x00FF,0x0178,0x2044,0x20AC,0x2039,0x203A,0xFB01,0xFB02,\n    0x2021,0x00B7,0x201A,0x201E,0x2030,0x00C2,0x00CA,0x00C1,\n    0x00CB,0x00C8,0x00CD,0x00CE,0x00CF,0x00CC,0x00D3,0x00D4,\n    0xF8FF,0x00D2,0x00DA,0x00DB,0x00D9,0x0131,0x02C6,0x02DC,\n    0x00AF,0x02D8,0x02D9,0x02DA,0x00B8,0x02DD,0x02DB,0x02C7,\n};\n\nstatic int mov_read_mac_string(MOVContext *c, AVIOContext *pb, int len,\n                               char *dst, int dstlen)\n{\n    char *p = dst;\n    char *end = dst+dstlen-1;\n    int i;\n\n    for (i = 0; i < len; i++) {\n        uint8_t t, c = avio_r8(pb);\n        if (c < 0x80 && p < end)\n            *p++ = c;\n        else if (p < end)\n            PUT_UTF8(mac_to_unicode[c-0x80], t, if (p < end) *p++ = t;);\n    }\n    *p = 0;\n    return p - dst;\n}\n\nstatic int mov_read_udta_string(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n#ifdef MOV_EXPORT_ALL_METADATA\n    char tmp_key[5];\n#endif\n    char str[1024], key2[16], language[4] = {0};\n    const char *key = NULL;\n    uint16_t str_size, langcode = 0;\n    uint32_t data_type = 0;\n    int (*parse)(MOVContext*, AVIOContext*, unsigned, const char*) = NULL;\n\n    switch (atom.type) {\n    case MKTAG(0xa9,'n','a','m'): key = \"title\";     break;\n    case MKTAG(0xa9,'a','u','t'):\n    case MKTAG(0xa9,'A','R','T'): key = \"artist\";    break;\n    case MKTAG( 'a','A','R','T'): key = \"album_artist\";    break;\n    case MKTAG(0xa9,'w','r','t'): key = \"composer\";  break;\n    case MKTAG( 'c','p','r','t'):\n    case MKTAG(0xa9,'c','p','y'): key = \"copyright\"; break;\n    case MKTAG(0xa9,'g','r','p'): key = \"grouping\"; break;\n    case MKTAG(0xa9,'l','y','r'): key = \"lyrics\"; break;\n    case MKTAG(0xa9,'c','m','t'):\n    case MKTAG(0xa9,'i','n','f'): key = \"comment\";   break;\n    case MKTAG(0xa9,'a','l','b'): key = \"album\";     break;\n    case MKTAG(0xa9,'d','a','y'): key = \"date\";      break;\n    case MKTAG(0xa9,'g','e','n'): key = \"genre\";     break;\n    case MKTAG( 'g','n','r','e'): key = \"genre\";\n        parse = mov_metadata_gnre; break;\n    case MKTAG(0xa9,'t','o','o'):\n    case MKTAG(0xa9,'s','w','r'): key = \"encoder\";   break;\n    case MKTAG(0xa9,'e','n','c'): key = \"encoder\";   break;\n    case MKTAG( 'd','e','s','c'): key = \"description\";break;\n    case MKTAG( 'l','d','e','s'): key = \"synopsis\";  break;\n    case MKTAG( 't','v','s','h'): key = \"show\";      break;\n    case MKTAG( 't','v','e','n'): key = \"episode_id\";break;\n    case MKTAG( 't','v','n','n'): key = \"network\";   break;\n    case MKTAG( 't','r','k','n'): key = \"track\";\n        parse = mov_metadata_track_or_disc_number; break;\n    case MKTAG( 'd','i','s','k'): key = \"disc\";\n        parse = mov_metadata_track_or_disc_number; break;\n    case MKTAG( 't','v','e','s'): key = \"episode_sort\";\n        parse = mov_metadata_int8_bypass_padding; break;\n    case MKTAG( 't','v','s','n'): key = \"season_number\";\n        parse = mov_metadata_int8_bypass_padding; break;\n    case MKTAG( 's','t','i','k'): key = \"media_type\";\n        parse = mov_metadata_int8_no_padding; break;\n    case MKTAG( 'h','d','v','d'): key = \"hd_video\";\n        parse = mov_metadata_int8_no_padding; break;\n    case MKTAG( 'p','g','a','p'): key = \"gapless_playback\";\n        parse = mov_metadata_int8_no_padding; break;\n    }\n\n    if (c->itunes_metadata && atom.size > 8) {\n        int data_size = avio_rb32(pb);\n        int tag = avio_rl32(pb);\n        if (tag == MKTAG('d','a','t','a')) {\n            data_type = avio_rb32(pb); // type\n            avio_rb32(pb); // unknown\n            str_size = data_size - 16;\n            atom.size -= 16;\n        } else return 0;\n    } else if (atom.size > 4 && key && !c->itunes_metadata) {\n        str_size = avio_rb16(pb); // string length\n        langcode = avio_rb16(pb);\n        ff_mov_lang_to_iso639(langcode, language);\n        atom.size -= 4;\n    } else\n        str_size = atom.size;\n\n#ifdef MOV_EXPORT_ALL_METADATA\n    if (!key) {\n        snprintf(tmp_key, 5, \"%.4s\", (char*)&atom.type);\n        key = tmp_key;\n    }\n#endif\n\n    if (!key)\n        return 0;\n    if (atom.size < 0)\n        return AVERROR_INVALIDDATA;\n\n    str_size = FFMIN3(sizeof(str)-1, str_size, atom.size);\n\n    if (parse)\n        parse(c, pb, str_size, key);\n    else {\n        if (data_type == 3 || (data_type == 0 && (langcode < 0x400 || langcode == 0x7fff))) { // MAC Encoded\n            mov_read_mac_string(c, pb, str_size, str, sizeof(str));\n        } else {\n            avio_read(pb, str, str_size);\n            str[str_size] = 0;\n        }\n        av_dict_set(&c->fc->metadata, key, str, 0);\n        if (*language && strcmp(language, \"und\")) {\n            snprintf(key2, sizeof(key2), \"%s-%s\", key, language);\n            av_dict_set(&c->fc->metadata, key2, str, 0);\n        }\n    }\n    av_dlog(c->fc, \"lang \\\"%3s\\\" \", language);\n    av_dlog(c->fc, \"tag \\\"%s\\\" value \\\"%s\\\" atom \\\"%.4s\\\" %d %\"PRId64\"\\n\",\n            key, str, (char*)&atom.type, str_size, atom.size);\n\n    return 0;\n}\n\nstatic int mov_read_chpl(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    int64_t start;\n    int i, nb_chapters, str_len, version;\n    char str[256+1];\n\n    if ((atom.size -= 5) < 0)\n        return 0;\n\n    version = avio_r8(pb);\n    avio_rb24(pb);\n    if (version)\n        avio_rb32(pb); // ???\n    nb_chapters = avio_r8(pb);\n\n    for (i = 0; i < nb_chapters; i++) {\n        if (atom.size < 9)\n            return 0;\n\n        start = avio_rb64(pb);\n        str_len = avio_r8(pb);\n\n        if ((atom.size -= 9+str_len) < 0)\n            return 0;\n\n        avio_read(pb, str, str_len);\n        str[str_len] = 0;\n        avpriv_new_chapter(c->fc, i, (AVRational){1,10000000}, start, AV_NOPTS_VALUE, str);\n    }\n    return 0;\n}\n\nstatic int mov_read_default(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    int64_t total_size = 0;\n    MOVAtom a;\n    int i;\n\n    if (atom.size < 0)\n        atom.size = INT64_MAX;\n    while (total_size + 8 <= atom.size && !url_feof(pb)) {\n        int (*parse)(MOVContext*, AVIOContext*, MOVAtom) = NULL;\n        a.size = atom.size;\n        a.type=0;\n        if (atom.size >= 8) {\n            a.size = avio_rb32(pb);\n            a.type = avio_rl32(pb);\n            if (atom.type != MKTAG('r','o','o','t') &&\n                atom.type != MKTAG('m','o','o','v'))\n            {\n                if (a.type == MKTAG('t','r','a','k') || a.type == MKTAG('m','d','a','t'))\n                {\n                    av_log(c->fc, AV_LOG_ERROR, \"Broken file, trak/mdat not at top-level\\n\");\n                    avio_skip(pb, -8);\n                    return 0;\n                }\n            }\n            total_size += 8;\n            if (a.size == 1) { /* 64 bit extended size */\n                a.size = avio_rb64(pb) - 8;\n                total_size += 8;\n            }\n        }\n        av_dlog(c->fc, \"type: %08x '%.4s' parent:'%.4s' sz: %\"PRId64\" %\"PRId64\" %\"PRId64\"\\n\",\n                a.type, (char*)&a.type, (char*)&atom.type, a.size, total_size, atom.size);\n        if (a.size == 0) {\n            a.size = atom.size - total_size + 8;\n        }\n        a.size -= 8;\n        if (a.size < 0)\n            break;\n        a.size = FFMIN(a.size, atom.size - total_size);\n\n        for (i = 0; mov_default_parse_table[i].type; i++)\n            if (mov_default_parse_table[i].type == a.type) {\n                parse = mov_default_parse_table[i].parse;\n                break;\n            }\n\n        // container is user data\n        if (!parse && (atom.type == MKTAG('u','d','t','a') ||\n                       atom.type == MKTAG('i','l','s','t')))\n            parse = mov_read_udta_string;\n\n        if (!parse) { /* skip leaf atoms data */\n            avio_skip(pb, a.size);\n        } else {\n            int64_t start_pos = avio_tell(pb);\n            int64_t left;\n            int err = parse(c, pb, a);\n            if (err < 0)\n                return err;\n            if (c->found_moov && c->found_mdat &&\n                ((!pb->seekable || c->fc->flags & AVFMT_FLAG_IGNIDX) ||\n                 start_pos + a.size == avio_size(pb))) {\n                if (!pb->seekable || c->fc->flags & AVFMT_FLAG_IGNIDX)\n                    c->next_root_atom = start_pos + a.size;\n                return 0;\n            }\n            left = a.size - avio_tell(pb) + start_pos;\n            if (left > 0) /* skip garbage at atom end */\n                avio_skip(pb, left);\n        }\n\n        total_size += a.size;\n    }\n\n    if (total_size < atom.size && atom.size < 0x7ffff)\n        avio_skip(pb, atom.size - total_size);\n\n    return 0;\n}\n\nstatic int mov_read_dref(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    MOVStreamContext *sc;\n    int entries, i, j;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n    sc = st->priv_data;\n\n    avio_rb32(pb); // version + flags\n    entries = avio_rb32(pb);\n    if (entries >= UINT_MAX / sizeof(*sc->drefs))\n        return AVERROR_INVALIDDATA;\n    av_free(sc->drefs);\n    sc->drefs_count = 0;\n    sc->drefs = av_mallocz(entries * sizeof(*sc->drefs));\n    if (!sc->drefs)\n        return AVERROR(ENOMEM);\n    sc->drefs_count = entries;\n\n    for (i = 0; i < sc->drefs_count; i++) {\n        MOVDref *dref = &sc->drefs[i];\n        uint32_t size = avio_rb32(pb);\n        int64_t next = avio_tell(pb) + size - 4;\n\n        if (size < 12)\n            return AVERROR_INVALIDDATA;\n\n        dref->type = avio_rl32(pb);\n        avio_rb32(pb); // version + flags\n        av_dlog(c->fc, \"type %.4s size %d\\n\", (char*)&dref->type, size);\n\n        if (dref->type == MKTAG('a','l','i','s') && size > 150) {\n            /* macintosh alias record */\n            uint16_t volume_len, len;\n            int16_t type;\n\n            avio_skip(pb, 10);\n\n            volume_len = avio_r8(pb);\n            volume_len = FFMIN(volume_len, 27);\n            avio_read(pb, dref->volume, 27);\n            dref->volume[volume_len] = 0;\n            av_log(c->fc, AV_LOG_DEBUG, \"volume %s, len %d\\n\", dref->volume, volume_len);\n\n            avio_skip(pb, 12);\n\n            len = avio_r8(pb);\n            len = FFMIN(len, 63);\n            avio_read(pb, dref->filename, 63);\n            dref->filename[len] = 0;\n            av_log(c->fc, AV_LOG_DEBUG, \"filename %s, len %d\\n\", dref->filename, len);\n\n            avio_skip(pb, 16);\n\n            /* read next level up_from_alias/down_to_target */\n            dref->nlvl_from = avio_rb16(pb);\n            dref->nlvl_to   = avio_rb16(pb);\n            av_log(c->fc, AV_LOG_DEBUG, \"nlvl from %d, nlvl to %d\\n\",\n                   dref->nlvl_from, dref->nlvl_to);\n\n            avio_skip(pb, 16);\n\n            for (type = 0; type != -1 && avio_tell(pb) < next; ) {\n                if(url_feof(pb))\n                    return AVERROR_EOF;\n                type = avio_rb16(pb);\n                len = avio_rb16(pb);\n                av_log(c->fc, AV_LOG_DEBUG, \"type %d, len %d\\n\", type, len);\n                if (len&1)\n                    len += 1;\n                if (type == 2) { // absolute path\n                    av_free(dref->path);\n                    dref->path = av_mallocz(len+1);\n                    if (!dref->path)\n                        return AVERROR(ENOMEM);\n                    avio_read(pb, dref->path, len);\n                    if (len > volume_len && !strncmp(dref->path, dref->volume, volume_len)) {\n                        len -= volume_len;\n                        memmove(dref->path, dref->path+volume_len, len);\n                        dref->path[len] = 0;\n                    }\n                    for (j = 0; j < len; j++)\n                        if (dref->path[j] == ':')\n                            dref->path[j] = '/';\n                    av_log(c->fc, AV_LOG_DEBUG, \"path %s\\n\", dref->path);\n                } else if (type == 0) { // directory name\n                    av_free(dref->dir);\n                    dref->dir = av_malloc(len+1);\n                    if (!dref->dir)\n                        return AVERROR(ENOMEM);\n                    avio_read(pb, dref->dir, len);\n                    dref->dir[len] = 0;\n                    for (j = 0; j < len; j++)\n                        if (dref->dir[j] == ':')\n                            dref->dir[j] = '/';\n                    av_log(c->fc, AV_LOG_DEBUG, \"dir %s\\n\", dref->dir);\n                } else\n                    avio_skip(pb, len);\n            }\n        }\n        avio_seek(pb, next, SEEK_SET);\n    }\n    return 0;\n}\n\nstatic int mov_read_hdlr(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    uint32_t type;\n    uint32_t av_unused ctype;\n    int title_size;\n    char *title_str;\n\n    if (c->fc->nb_streams < 1) // meta before first trak\n        return 0;\n\n    st = c->fc->streams[c->fc->nb_streams-1];\n\n    avio_r8(pb); /* version */\n    avio_rb24(pb); /* flags */\n\n    /* component type */\n    ctype = avio_rl32(pb);\n    type = avio_rl32(pb); /* component subtype */\n\n    av_dlog(c->fc, \"ctype= %.4s (0x%08x)\\n\", (char*)&ctype, ctype);\n    av_dlog(c->fc, \"stype= %.4s\\n\", (char*)&type);\n\n    if     (type == MKTAG('v','i','d','e'))\n        st->codec->codec_type = AVMEDIA_TYPE_VIDEO;\n    else if (type == MKTAG('s','o','u','n'))\n        st->codec->codec_type = AVMEDIA_TYPE_AUDIO;\n    else if (type == MKTAG('m','1','a',' '))\n        st->codec->codec_id = CODEC_ID_MP2;\n    else if ((type == MKTAG('s','u','b','p')) || (type == MKTAG('c','l','c','p')))\n        st->codec->codec_type = AVMEDIA_TYPE_SUBTITLE;\n\n    avio_rb32(pb); /* component  manufacture */\n    avio_rb32(pb); /* component flags */\n    avio_rb32(pb); /* component flags mask */\n\n    title_size = atom.size - 24;\n    if (title_size > 0) {\n        title_str = av_malloc(title_size + 1); /* Add null terminator */\n        if (!title_str)\n            return AVERROR(ENOMEM);\n        avio_read(pb, title_str, title_size);\n        title_str[title_size] = 0;\n        if (title_str[0])\n            av_dict_set(&st->metadata, \"handler_name\", title_str +\n                        (!c->isom && title_str[0] == title_size - 1), 0);\n        av_freep(&title_str);\n    }\n\n    return 0;\n}\n\nint ff_mov_read_esds(AVFormatContext *fc, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    int tag;\n\n    if (fc->nb_streams < 1)\n        return 0;\n    st = fc->streams[fc->nb_streams-1];\n\n    avio_rb32(pb); /* version + flags */\n    ff_mp4_read_descr(fc, pb, &tag);\n    if (tag == MP4ESDescrTag) {\n        ff_mp4_parse_es_descr(pb, NULL);\n    } else\n        avio_rb16(pb); /* ID */\n\n    ff_mp4_read_descr(fc, pb, &tag);\n    if (tag == MP4DecConfigDescrTag)\n        ff_mp4_read_dec_config_descr(fc, st, pb);\n    return 0;\n}\n\nstatic int mov_read_esds(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    return ff_mov_read_esds(c->fc, pb, atom);\n}\n\nstatic int mov_read_dac3(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    int ac3info, acmod, lfeon, bsmod;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n\n    ac3info = avio_rb24(pb);\n    bsmod = (ac3info >> 14) & 0x7;\n    acmod = (ac3info >> 11) & 0x7;\n    lfeon = (ac3info >> 10) & 0x1;\n    st->codec->channels = ((int[]){2,1,2,3,3,4,4,5})[acmod] + lfeon;\n    st->codec->channel_layout = avpriv_ac3_channel_layout_tab[acmod];\n    if (lfeon)\n        st->codec->channel_layout |= AV_CH_LOW_FREQUENCY;\n    st->codec->audio_service_type = bsmod;\n    if (st->codec->channels > 1 && bsmod == 0x7)\n        st->codec->audio_service_type = AV_AUDIO_SERVICE_TYPE_KARAOKE;\n\n    return 0;\n}\n\nstatic int mov_read_chan(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    uint8_t version;\n    uint32_t flags, layout_tag, bitmap, num_descr, label_mask;\n    int i;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n\n    if (atom.size < 16)\n        return 0;\n\n    version = avio_r8(pb);\n    flags   = avio_rb24(pb);\n\n    layout_tag = avio_rb32(pb);\n    bitmap     = avio_rb32(pb);\n    num_descr  = avio_rb32(pb);\n\n    if (atom.size < 16ULL + num_descr * 20ULL)\n        return 0;\n\n    av_dlog(c->fc, \"chan: size=%\" PRId64 \" version=%u flags=%u layout=%u bitmap=%u num_descr=%u\\n\",\n            atom.size, version, flags, layout_tag, bitmap, num_descr);\n\n    label_mask = 0;\n    for (i = 0; i < num_descr; i++) {\n        uint32_t av_unused label, cflags;\n        label     = avio_rb32(pb);          // mChannelLabel\n        cflags    = avio_rb32(pb);          // mChannelFlags\n        avio_rl32(pb);                      // mCoordinates[0]\n        avio_rl32(pb);                      // mCoordinates[1]\n        avio_rl32(pb);                      // mCoordinates[2]\n        if (layout_tag == 0) {\n            uint32_t mask_incr = ff_mov_get_channel_label(label);\n            if (mask_incr == 0) {\n                label_mask = 0;\n                break;\n            }\n            label_mask |= mask_incr;\n        }\n    }\n    if (layout_tag == 0)\n        st->codec->channel_layout = label_mask;\n    else\n        st->codec->channel_layout = ff_mov_get_channel_layout(layout_tag, bitmap);\n\n    return 0;\n}\n\nstatic int mov_read_wfex(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n\n    ff_get_wav_header(pb, st->codec, atom.size);\n\n    return 0;\n}\n\nstatic int mov_read_pasp(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    const int num = avio_rb32(pb);\n    const int den = avio_rb32(pb);\n    AVStream *st;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n\n    if ((st->sample_aspect_ratio.den != 1 || st->sample_aspect_ratio.num) && // default\n        (den != st->sample_aspect_ratio.den || num != st->sample_aspect_ratio.num)) {\n        av_log(c->fc, AV_LOG_WARNING,\n               \"sample aspect ratio already set to %d:%d, ignoring 'pasp' atom (%d:%d)\\n\",\n               st->sample_aspect_ratio.num, st->sample_aspect_ratio.den,\n               num, den);\n    } else if (den != 0) {\n        st->sample_aspect_ratio.num = num;\n        st->sample_aspect_ratio.den = den;\n    }\n    return 0;\n}\n\n/* this atom contains actual media data */\nstatic int mov_read_mdat(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    if (atom.size == 0) /* wrong one (MP4) */\n        return 0;\n    c->found_mdat=1;\n    return 0; /* now go for moov */\n}\n\n/* read major brand, minor version and compatible brands and store them as metadata */\nstatic int mov_read_ftyp(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    uint32_t minor_ver;\n    int comp_brand_size;\n    char minor_ver_str[11]; /* 32 bit integer -> 10 digits + null */\n    char* comp_brands_str;\n    uint8_t type[5] = {0};\n\n    avio_read(pb, type, 4);\n    if (strcmp(type, \"qt  \"))\n        c->isom = 1;\n    av_log(c->fc, AV_LOG_DEBUG, \"ISO: File Type Major Brand: %.4s\\n\",(char *)&type);\n    av_dict_set(&c->fc->metadata, \"major_brand\", type, 0);\n    minor_ver = avio_rb32(pb); /* minor version */\n    snprintf(minor_ver_str, sizeof(minor_ver_str), \"%d\", minor_ver);\n    av_dict_set(&c->fc->metadata, \"minor_version\", minor_ver_str, 0);\n\n    comp_brand_size = atom.size - 8;\n    if (comp_brand_size < 0)\n        return AVERROR_INVALIDDATA;\n    comp_brands_str = av_malloc(comp_brand_size + 1); /* Add null terminator */\n    if (!comp_brands_str)\n        return AVERROR(ENOMEM);\n    avio_read(pb, comp_brands_str, comp_brand_size);\n    comp_brands_str[comp_brand_size] = 0;\n    av_dict_set(&c->fc->metadata, \"compatible_brands\", comp_brands_str, 0);\n    av_freep(&comp_brands_str);\n\n    return 0;\n}\n\n/* this atom should contain all header atoms */\nstatic int mov_read_moov(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    int ret;\n\n    if ((ret = mov_read_default(c, pb, atom)) < 0)\n        return ret;\n    /* we parsed the 'moov' atom, we can terminate the parsing as soon as we find the 'mdat' */\n    /* so we don't parse the whole file if over a network */\n    c->found_moov=1;\n    return 0; /* now go for mdat */\n}\n\nstatic int mov_read_moof(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    c->fragment.moof_offset = avio_tell(pb) - 8;\n    av_dlog(c->fc, \"moof offset %\"PRIx64\"\\n\", c->fragment.moof_offset);\n    return mov_read_default(c, pb, atom);\n}\n\nstatic void mov_metadata_creation_time(AVDictionary **metadata, time_t time)\n{\n    char buffer[32];\n    if (time) {\n        struct tm *ptm;\n        time -= 2082844800;  /* seconds between 1904-01-01 and Epoch */\n        ptm = gmtime(&time);\n        if (!ptm) return;\n        strftime(buffer, sizeof(buffer), \"%Y-%m-%d %H:%M:%S\", ptm);\n        av_dict_set(metadata, \"creation_time\", buffer, 0);\n    }\n}\n\nstatic int mov_read_mdhd(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    MOVStreamContext *sc;\n    int version;\n    char language[4] = {0};\n    unsigned lang;\n    time_t creation_time;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n    sc = st->priv_data;\n\n    version = avio_r8(pb);\n    if (version > 1) {\n        av_log_ask_for_sample(c, \"unsupported version %d\\n\", version);\n        return AVERROR_PATCHWELCOME;\n    }\n    avio_rb24(pb); /* flags */\n    if (version == 1) {\n        creation_time = avio_rb64(pb);\n        avio_rb64(pb);\n    } else {\n        creation_time = avio_rb32(pb);\n        avio_rb32(pb); /* modification time */\n    }\n    mov_metadata_creation_time(&st->metadata, creation_time);\n\n    sc->time_scale = avio_rb32(pb);\n    st->duration = (version == 1) ? avio_rb64(pb) : avio_rb32(pb); /* duration */\n\n    lang = avio_rb16(pb); /* language */\n    if (ff_mov_lang_to_iso639(lang, language))\n        av_dict_set(&st->metadata, \"language\", language, 0);\n    avio_rb16(pb); /* quality */\n\n    return 0;\n}\n\nstatic int mov_read_mvhd(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    time_t creation_time;\n    int version = avio_r8(pb); /* version */\n    avio_rb24(pb); /* flags */\n\n    if (version == 1) {\n        creation_time = avio_rb64(pb);\n        avio_rb64(pb);\n    } else {\n        creation_time = avio_rb32(pb);\n        avio_rb32(pb); /* modification time */\n    }\n    mov_metadata_creation_time(&c->fc->metadata, creation_time);\n    c->time_scale = avio_rb32(pb); /* time scale */\n\n    av_dlog(c->fc, \"time scale = %i\\n\", c->time_scale);\n\n    c->duration = (version == 1) ? avio_rb64(pb) : avio_rb32(pb); /* duration */\n    // set the AVCodecContext duration because the duration of individual tracks\n    // may be inaccurate\n    if (c->time_scale > 0)\n        c->fc->duration = av_rescale(c->duration, AV_TIME_BASE, c->time_scale);\n    avio_rb32(pb); /* preferred scale */\n\n    avio_rb16(pb); /* preferred volume */\n\n    avio_skip(pb, 10); /* reserved */\n\n    avio_skip(pb, 36); /* display matrix */\n\n    avio_rb32(pb); /* preview time */\n    avio_rb32(pb); /* preview duration */\n    avio_rb32(pb); /* poster time */\n    avio_rb32(pb); /* selection time */\n    avio_rb32(pb); /* selection duration */\n    avio_rb32(pb); /* current time */\n    avio_rb32(pb); /* next track ID */\n    return 0;\n}\n\nstatic int mov_read_smi(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n\n    if ((uint64_t)atom.size > (1<<30))\n        return AVERROR_INVALIDDATA;\n\n    // currently SVQ3 decoder expect full STSD header - so let's fake it\n    // this should be fixed and just SMI header should be passed\n    av_free(st->codec->extradata);\n    st->codec->extradata_size = 0;\n    st->codec->extradata = av_mallocz(atom.size + 0x5a + FF_INPUT_BUFFER_PADDING_SIZE);\n    if (!st->codec->extradata)\n        return AVERROR(ENOMEM);\n    st->codec->extradata_size = 0x5a + atom.size;\n    memcpy(st->codec->extradata, \"SVQ3\", 4); // fake\n    avio_read(pb, st->codec->extradata + 0x5a, atom.size);\n    av_dlog(c->fc, \"Reading SMI %\"PRId64\"  %s\\n\", atom.size, st->codec->extradata + 0x5a);\n    return 0;\n}\n\nstatic int mov_read_enda(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    int little_endian;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n\n    little_endian = avio_rb16(pb) & 0xFF;\n    av_dlog(c->fc, \"enda %d\\n\", little_endian);\n    if (little_endian == 1) {\n        switch (st->codec->codec_id) {\n        case CODEC_ID_PCM_S24BE:\n            st->codec->codec_id = CODEC_ID_PCM_S24LE;\n            break;\n        case CODEC_ID_PCM_S32BE:\n            st->codec->codec_id = CODEC_ID_PCM_S32LE;\n            break;\n        case CODEC_ID_PCM_F32BE:\n            st->codec->codec_id = CODEC_ID_PCM_F32LE;\n            break;\n        case CODEC_ID_PCM_F64BE:\n            st->codec->codec_id = CODEC_ID_PCM_F64LE;\n            break;\n        default:\n            break;\n        }\n    }\n    return 0;\n}\n\nstatic int mov_read_fiel(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    unsigned mov_field_order;\n    enum AVFieldOrder decoded_field_order = AV_FIELD_UNKNOWN;\n\n    if (c->fc->nb_streams < 1) // will happen with jp2 files\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n    if (atom.size < 2)\n        return AVERROR_INVALIDDATA;\n    mov_field_order = avio_rb16(pb);\n    if ((mov_field_order & 0xFF00) == 0x0100)\n        decoded_field_order = AV_FIELD_PROGRESSIVE;\n    else if ((mov_field_order & 0xFF00) == 0x0200) {\n        switch (mov_field_order & 0xFF) {\n        case 0x01: decoded_field_order = AV_FIELD_TT;\n                   break;\n        case 0x06: decoded_field_order = AV_FIELD_BB;\n                   break;\n        case 0x09: decoded_field_order = AV_FIELD_TB;\n                   break;\n        case 0x0E: decoded_field_order = AV_FIELD_BT;\n                   break;\n        }\n    }\n    if (decoded_field_order == AV_FIELD_UNKNOWN && mov_field_order) {\n        av_log(NULL, AV_LOG_ERROR, \"Unknown MOV field order 0x%04x\\n\", mov_field_order);\n    }\n    st->codec->field_order = decoded_field_order;\n\n    return 0;\n}\n\n/* FIXME modify qdm2/svq3/h264 decoders to take full atom as extradata */\nstatic int mov_read_extradata(MOVContext *c, AVIOContext *pb, MOVAtom atom,\n                              enum CodecID codec_id)\n{\n    AVStream *st;\n    uint64_t size;\n    uint8_t *buf;\n\n    if (c->fc->nb_streams < 1) // will happen with jp2 files\n        return 0;\n    st= c->fc->streams[c->fc->nb_streams-1];\n\n    if (st->codec->codec_id != codec_id)\n        return 0; /* unexpected codec_id - don't mess with extradata */\n\n    size= (uint64_t)st->codec->extradata_size + atom.size + 8 + FF_INPUT_BUFFER_PADDING_SIZE;\n    if (size > INT_MAX || (uint64_t)atom.size > INT_MAX)\n        return AVERROR_INVALIDDATA;\n    buf= av_realloc(st->codec->extradata, size);\n    if (!buf)\n        return AVERROR(ENOMEM);\n    st->codec->extradata= buf;\n    buf+= st->codec->extradata_size;\n    st->codec->extradata_size= size - FF_INPUT_BUFFER_PADDING_SIZE;\n    AV_WB32(       buf    , atom.size + 8);\n    AV_WL32(       buf + 4, atom.type);\n    avio_read(pb, buf + 8, atom.size);\n    return 0;\n}\n\n/* wrapper functions for reading ALAC/AVS/MJPEG/MJPEG2000 extradata atoms only for those codecs */\nstatic int mov_read_alac(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    return mov_read_extradata(c, pb, atom, CODEC_ID_ALAC);\n}\n\nstatic int mov_read_avss(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    return mov_read_extradata(c, pb, atom, CODEC_ID_AVS);\n}\n\nstatic int mov_read_jp2h(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    return mov_read_extradata(c, pb, atom, CODEC_ID_JPEG2000);\n}\n\nstatic int mov_read_wave(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n\n    if ((uint64_t)atom.size > (1<<30))\n        return AVERROR_INVALIDDATA;\n\n    if (st->codec->codec_id == CODEC_ID_QDM2 || st->codec->codec_id == CODEC_ID_QDMC) {\n        // pass all frma atom to codec, needed at least for QDMC and QDM2\n        av_free(st->codec->extradata);\n        st->codec->extradata_size = 0;\n        st->codec->extradata = av_mallocz(atom.size + FF_INPUT_BUFFER_PADDING_SIZE);\n        if (!st->codec->extradata)\n            return AVERROR(ENOMEM);\n        st->codec->extradata_size = atom.size;\n        avio_read(pb, st->codec->extradata, atom.size);\n    } else if (atom.size > 8) { /* to read frma, esds atoms */\n        int ret;\n        if ((ret = mov_read_default(c, pb, atom)) < 0)\n            return ret;\n    } else\n        avio_skip(pb, atom.size);\n    return 0;\n}\n\n/**\n * This function reads atom content and puts data in extradata without tag\n * nor size unlike mov_read_extradata.\n */\nstatic int mov_read_glbl(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n\n    if ((uint64_t)atom.size > (1<<30))\n        return AVERROR_INVALIDDATA;\n\n    if (atom.size >= 10) {\n        // Broken files created by legacy versions of Libav and FFmpeg will\n        // wrap a whole fiel atom inside of a glbl atom.\n        unsigned size = avio_rb32(pb);\n        unsigned type = avio_rl32(pb);\n        avio_seek(pb, -8, SEEK_CUR);\n        if (type == MKTAG('f','i','e','l') && size == atom.size)\n            return mov_read_default(c, pb, atom);\n    }\n    av_free(st->codec->extradata);\n    st->codec->extradata_size = 0;\n    st->codec->extradata = av_mallocz(atom.size + FF_INPUT_BUFFER_PADDING_SIZE);\n    if (!st->codec->extradata)\n        return AVERROR(ENOMEM);\n    st->codec->extradata_size = atom.size;\n    avio_read(pb, st->codec->extradata, atom.size);\n    return 0;\n}\n\nstatic int mov_read_dvc1(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    uint8_t profile_level;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n\n    if (atom.size >= (1<<28) || atom.size < 7)\n        return AVERROR_INVALIDDATA;\n\n    profile_level = avio_r8(pb);\n    if (profile_level & 0xf0 != 0xc0)\n        return 0;\n\n    av_free(st->codec->extradata);\n    st->codec->extradata_size = 0;\n    st->codec->extradata = av_mallocz(atom.size - 7 + FF_INPUT_BUFFER_PADDING_SIZE);\n    if (!st->codec->extradata)\n        return AVERROR(ENOMEM);\n    st->codec->extradata_size = atom.size - 7;\n    avio_seek(pb, 6, SEEK_CUR);\n    avio_read(pb, st->codec->extradata, st->codec->extradata_size);\n    return 0;\n}\n\n/**\n * An strf atom is a BITMAPINFOHEADER struct. This struct is 40 bytes itself,\n * but can have extradata appended at the end after the 40 bytes belonging\n * to the struct.\n */\nstatic int mov_read_strf(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    if (atom.size <= 40)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n\n    if ((uint64_t)atom.size > (1<<30))\n        return AVERROR_INVALIDDATA;\n\n    av_free(st->codec->extradata);\n    st->codec->extradata_size = 0;\n    st->codec->extradata = av_mallocz(atom.size - 40 + FF_INPUT_BUFFER_PADDING_SIZE);\n    if (!st->codec->extradata)\n        return AVERROR(ENOMEM);\n    st->codec->extradata_size = atom.size - 40;\n    avio_skip(pb, 40);\n    avio_read(pb, st->codec->extradata, atom.size - 40);\n    return 0;\n}\n\nstatic int mov_read_stco(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    MOVStreamContext *sc;\n    unsigned int i, entries;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n    sc = st->priv_data;\n\n    avio_r8(pb); /* version */\n    avio_rb24(pb); /* flags */\n\n    entries = avio_rb32(pb);\n\n    if (!entries)\n        return 0;\n    if (entries >= UINT_MAX/sizeof(int64_t))\n        return AVERROR_INVALIDDATA;\n\n    sc->chunk_offsets = av_malloc(entries * sizeof(int64_t));\n    if (!sc->chunk_offsets)\n        return AVERROR(ENOMEM);\n    sc->chunk_count = entries;\n\n    if      (atom.type == MKTAG('s','t','c','o'))\n        for (i=0; i<entries; i++)\n            sc->chunk_offsets[i] = avio_rb32(pb);\n    else if (atom.type == MKTAG('c','o','6','4'))\n        for (i=0; i<entries; i++)\n            sc->chunk_offsets[i] = avio_rb64(pb);\n    else\n        return AVERROR_INVALIDDATA;\n\n    return 0;\n}\n\n/**\n * Compute codec id for 'lpcm' tag.\n * See CoreAudioTypes and AudioStreamBasicDescription at Apple.\n */\nenum CodecID ff_mov_get_lpcm_codec_id(int bps, int flags)\n{\n    if (flags & 1) { // floating point\n        if (flags & 2) { // big endian\n            if      (bps == 32) return CODEC_ID_PCM_F32BE;\n            else if (bps == 64) return CODEC_ID_PCM_F64BE;\n        } else {\n            if      (bps == 32) return CODEC_ID_PCM_F32LE;\n            else if (bps == 64) return CODEC_ID_PCM_F64LE;\n        }\n    } else {\n        if (flags & 2) {\n            if      (bps == 8)\n                // signed integer\n                if (flags & 4)  return CODEC_ID_PCM_S8;\n                else            return CODEC_ID_PCM_U8;\n            else if (bps == 16) return CODEC_ID_PCM_S16BE;\n            else if (bps == 24) return CODEC_ID_PCM_S24BE;\n            else if (bps == 32) return CODEC_ID_PCM_S32BE;\n        } else {\n            if      (bps == 8)\n                if (flags & 4)  return CODEC_ID_PCM_S8;\n                else            return CODEC_ID_PCM_U8;\n            else if (bps == 16) return CODEC_ID_PCM_S16LE;\n            else if (bps == 24) return CODEC_ID_PCM_S24LE;\n            else if (bps == 32) return CODEC_ID_PCM_S32LE;\n        }\n    }\n    return CODEC_ID_NONE;\n}\n\nint ff_mov_read_stsd_entries(MOVContext *c, AVIOContext *pb, int entries)\n{\n    AVStream *st;\n    MOVStreamContext *sc;\n    int j, pseudo_stream_id;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n    sc = st->priv_data;\n\n    for (pseudo_stream_id=0; pseudo_stream_id<entries; pseudo_stream_id++) {\n        //Parsing Sample description table\n        enum CodecID id;\n        int dref_id = 1;\n        MOVAtom a = { AV_RL32(\"stsd\") };\n        int64_t start_pos = avio_tell(pb);\n        int size = avio_rb32(pb); /* size */\n        uint32_t format = avio_rl32(pb); /* data format */\n\n        if (size >= 16) {\n            avio_rb32(pb); /* reserved */\n            avio_rb16(pb); /* reserved */\n            dref_id = avio_rb16(pb);\n        }else if (size <= 0){\n            av_log(c->fc, AV_LOG_ERROR, \"invalid size %d in stsd\\n\", size);\n            return -1;\n        }\n\n        if (st->codec->codec_tag &&\n            st->codec->codec_tag != format &&\n            (c->fc->video_codec_id ? ff_codec_get_id(ff_codec_movvideo_tags, format) != c->fc->video_codec_id\n                                   : st->codec->codec_tag != MKTAG('j','p','e','g'))\n           ){\n            /* Multiple fourcc, we skip JPEG. This is not correct, we should\n             * export it as a separate AVStream but this needs a few changes\n             * in the MOV demuxer, patch welcome. */\n            av_log(c->fc, AV_LOG_WARNING, \"multiple fourcc not supported\\n\");\n            avio_skip(pb, size - (avio_tell(pb) - start_pos));\n            continue;\n        }\n        /* we cannot demux concatenated h264 streams because of different extradata */\n        if (st->codec->codec_tag && st->codec->codec_tag == AV_RL32(\"avc1\"))\n            av_log(c->fc, AV_LOG_WARNING, \"Concatenated H.264 might not play corrently.\\n\");\n        sc->pseudo_stream_id = st->codec->codec_tag ? -1 : pseudo_stream_id;\n        sc->dref_id= dref_id;\n\n        st->codec->codec_tag = format;\n        id = ff_codec_get_id(ff_codec_movaudio_tags, format);\n        if (id<=0 && ((format&0xFFFF) == 'm'+('s'<<8) || (format&0xFFFF) == 'T'+('S'<<8)))\n            id = ff_codec_get_id(ff_codec_wav_tags, av_bswap32(format)&0xFFFF);\n\n        if (st->codec->codec_type != AVMEDIA_TYPE_VIDEO && id > 0) {\n            st->codec->codec_type = AVMEDIA_TYPE_AUDIO;\n        } else if (st->codec->codec_type != AVMEDIA_TYPE_AUDIO && /* do not overwrite codec type */\n                   format && format != MKTAG('m','p','4','s')) { /* skip old asf mpeg4 tag */\n            id = ff_codec_get_id(ff_codec_movvideo_tags, format);\n            if (id <= 0)\n                id = ff_codec_get_id(ff_codec_bmp_tags, format);\n            if (id > 0)\n                st->codec->codec_type = AVMEDIA_TYPE_VIDEO;\n            else if (st->codec->codec_type == AVMEDIA_TYPE_DATA ||\n                     (st->codec->codec_type == AVMEDIA_TYPE_SUBTITLE &&\n                      st->codec->codec_id == CODEC_ID_NONE)){\n                id = ff_codec_get_id(ff_codec_movsubtitle_tags, format);\n                if (id > 0)\n                    st->codec->codec_type = AVMEDIA_TYPE_SUBTITLE;\n            }\n        }\n\n        av_dlog(c->fc, \"size=%d 4CC= %c%c%c%c codec_type=%d\\n\", size,\n                (format >> 0) & 0xff, (format >> 8) & 0xff, (format >> 16) & 0xff,\n                (format >> 24) & 0xff, st->codec->codec_type);\n\n        if (st->codec->codec_type==AVMEDIA_TYPE_VIDEO) {\n            unsigned int color_depth, len;\n            int color_greyscale;\n            int color_table_id;\n\n            st->codec->codec_id = id;\n            avio_rb16(pb); /* version */\n            avio_rb16(pb); /* revision level */\n            avio_rb32(pb); /* vendor */\n            avio_rb32(pb); /* temporal quality */\n            avio_rb32(pb); /* spatial quality */\n\n            st->codec->width = avio_rb16(pb); /* width */\n            st->codec->height = avio_rb16(pb); /* height */\n\n            avio_rb32(pb); /* horiz resolution */\n            avio_rb32(pb); /* vert resolution */\n            avio_rb32(pb); /* data size, always 0 */\n            avio_rb16(pb); /* frames per samples */\n\n            len = avio_r8(pb); /* codec name, pascal string */\n            if (len > 31)\n                len = 31;\n            mov_read_mac_string(c, pb, len, st->codec->codec_name, 32);\n            if (len < 31)\n                avio_skip(pb, 31 - len);\n            /* codec_tag YV12 triggers an UV swap in rawdec.c */\n            if (!memcmp(st->codec->codec_name, \"Planar Y'CbCr 8-bit 4:2:0\", 25))\n                st->codec->codec_tag=MKTAG('I', '4', '2', '0');\n\n            st->codec->bits_per_coded_sample = avio_rb16(pb); /* depth */\n            color_table_id = avio_rb16(pb); /* colortable id */\n            av_dlog(c->fc, \"depth %d, ctab id %d\\n\",\n                   st->codec->bits_per_coded_sample, color_table_id);\n            /* figure out the palette situation */\n            color_depth = st->codec->bits_per_coded_sample & 0x1F;\n            color_greyscale = st->codec->bits_per_coded_sample & 0x20;\n\n            /* if the depth is 2, 4, or 8 bpp, file is palettized */\n            if ((color_depth == 2) || (color_depth == 4) ||\n                (color_depth == 8)) {\n                /* for palette traversal */\n                unsigned int color_start, color_count, color_end;\n                unsigned char a, r, g, b;\n\n                if (color_greyscale) {\n                    int color_index, color_dec;\n                    /* compute the greyscale palette */\n                    st->codec->bits_per_coded_sample = color_depth;\n                    color_count = 1 << color_depth;\n                    color_index = 255;\n                    color_dec = 256 / (color_count - 1);\n                    for (j = 0; j < color_count; j++) {\n                        if (id == CODEC_ID_CINEPAK){\n                            r = g = b = color_count - 1 - color_index;\n                        }else\n                        r = g = b = color_index;\n                        sc->palette[j] =\n                            (0xFFU << 24) | (r << 16) | (g << 8) | (b);\n                        color_index -= color_dec;\n                        if (color_index < 0)\n                            color_index = 0;\n                    }\n                } else if (color_table_id) {\n                    const uint8_t *color_table;\n                    /* if flag bit 3 is set, use the default palette */\n                    color_count = 1 << color_depth;\n                    if (color_depth == 2)\n                        color_table = ff_qt_default_palette_4;\n                    else if (color_depth == 4)\n                        color_table = ff_qt_default_palette_16;\n                    else\n                        color_table = ff_qt_default_palette_256;\n\n                    for (j = 0; j < color_count; j++) {\n                        r = color_table[j * 3 + 0];\n                        g = color_table[j * 3 + 1];\n                        b = color_table[j * 3 + 2];\n                        sc->palette[j] =\n                            (0xFFU << 24) | (r << 16) | (g << 8) | (b);\n                    }\n                } else {\n                    /* load the palette from the file */\n                    color_start = avio_rb32(pb);\n                    color_count = avio_rb16(pb);\n                    color_end = avio_rb16(pb);\n                    if ((color_start <= 255) &&\n                        (color_end <= 255)) {\n                        for (j = color_start; j <= color_end; j++) {\n                            /* each A, R, G, or B component is 16 bits;\n                             * only use the top 8 bits */\n                            a = avio_r8(pb);\n                            avio_r8(pb);\n                            r = avio_r8(pb);\n                            avio_r8(pb);\n                            g = avio_r8(pb);\n                            avio_r8(pb);\n                            b = avio_r8(pb);\n                            avio_r8(pb);\n                            sc->palette[j] =\n                                (a << 24 ) | (r << 16) | (g << 8) | (b);\n                        }\n                    }\n                }\n                sc->has_palette = 1;\n            }\n        } else if (st->codec->codec_type==AVMEDIA_TYPE_AUDIO) {\n            int bits_per_sample, flags;\n            uint16_t version = avio_rb16(pb);\n\n            st->codec->codec_id = id;\n            avio_rb16(pb); /* revision level */\n            avio_rb32(pb); /* vendor */\n\n            st->codec->channels = avio_rb16(pb);             /* channel count */\n            av_dlog(c->fc, \"audio channels %d\\n\", st->codec->channels);\n            st->codec->bits_per_coded_sample = avio_rb16(pb);      /* sample size */\n\n            sc->audio_cid = avio_rb16(pb);\n            avio_rb16(pb); /* packet size = 0 */\n\n            st->codec->sample_rate = ((avio_rb32(pb) >> 16));\n\n            //Read QT version 1 fields. In version 0 these do not exist.\n            av_dlog(c->fc, \"version =%d, isom =%d\\n\",version,c->isom);\n            if (!c->isom) {\n                if (version==1) {\n                    sc->samples_per_frame = avio_rb32(pb);\n                    avio_rb32(pb); /* bytes per packet */\n                    sc->bytes_per_frame = avio_rb32(pb);\n                    avio_rb32(pb); /* bytes per sample */\n                } else if (version==2) {\n                    avio_rb32(pb); /* sizeof struct only */\n                    st->codec->sample_rate = av_int2double(avio_rb64(pb)); /* float 64 */\n                    st->codec->channels = avio_rb32(pb);\n                    avio_rb32(pb); /* always 0x7F000000 */\n                    st->codec->bits_per_coded_sample = avio_rb32(pb); /* bits per channel if sound is uncompressed */\n                    flags = avio_rb32(pb); /* lpcm format specific flag */\n                    sc->bytes_per_frame = avio_rb32(pb); /* bytes per audio packet if constant */\n                    sc->samples_per_frame = avio_rb32(pb); /* lpcm frames per audio packet if constant */\n                    if (format == MKTAG('l','p','c','m'))\n                        st->codec->codec_id = ff_mov_get_lpcm_codec_id(st->codec->bits_per_coded_sample, flags);\n                }\n            }\n\n            switch (st->codec->codec_id) {\n            case CODEC_ID_PCM_S8:\n            case CODEC_ID_PCM_U8:\n                if (st->codec->bits_per_coded_sample == 16)\n                    st->codec->codec_id = CODEC_ID_PCM_S16BE;\n                break;\n            case CODEC_ID_PCM_S16LE:\n            case CODEC_ID_PCM_S16BE:\n                if (st->codec->bits_per_coded_sample == 8)\n                    st->codec->codec_id = CODEC_ID_PCM_S8;\n                else if (st->codec->bits_per_coded_sample == 24)\n                    st->codec->codec_id =\n                        st->codec->codec_id == CODEC_ID_PCM_S16BE ?\n                        CODEC_ID_PCM_S24BE : CODEC_ID_PCM_S24LE;\n                break;\n            /* set values for old format before stsd version 1 appeared */\n            case CODEC_ID_MACE3:\n                sc->samples_per_frame = 6;\n                sc->bytes_per_frame = 2*st->codec->channels;\n                break;\n            case CODEC_ID_MACE6:\n                sc->samples_per_frame = 6;\n                sc->bytes_per_frame = 1*st->codec->channels;\n                break;\n            case CODEC_ID_ADPCM_IMA_QT:\n                sc->samples_per_frame = 64;\n                sc->bytes_per_frame = 34*st->codec->channels;\n                break;\n            case CODEC_ID_GSM:\n                sc->samples_per_frame = 160;\n                sc->bytes_per_frame = 33;\n                break;\n            default:\n                break;\n            }\n\n            bits_per_sample = av_get_bits_per_sample(st->codec->codec_id);\n            if (bits_per_sample) {\n                st->codec->bits_per_coded_sample = bits_per_sample;\n                sc->sample_size = (bits_per_sample >> 3) * st->codec->channels;\n            }\n        } else if (st->codec->codec_type==AVMEDIA_TYPE_SUBTITLE){\n            // ttxt stsd contains display flags, justification, background\n            // color, fonts, and default styles, so fake an atom to read it\n            MOVAtom fake_atom = { .size = size - (avio_tell(pb) - start_pos) };\n            if (format != AV_RL32(\"mp4s\")) // mp4s contains a regular esds atom\n                mov_read_glbl(c, pb, fake_atom);\n            st->codec->codec_id= id;\n            st->codec->width = sc->width;\n            st->codec->height = sc->height;\n        } else {\n            if (st->codec->codec_tag == MKTAG('t','m','c','d')) {\n                MOVStreamContext *tmcd_ctx = st->priv_data;\n                int val;\n                avio_rb32(pb);       /* reserved */\n                val = avio_rb32(pb); /* flags */\n                tmcd_ctx->tmcd_flags = val;\n                if (val & 1)\n                    st->codec->flags2 |= CODEC_FLAG2_DROP_FRAME_TIMECODE;\n                avio_rb32(pb); /* time scale */\n                avio_rb32(pb); /* frame duration */\n                st->codec->time_base.den = avio_r8(pb); /* number of frame */\n                st->codec->time_base.num = 1;\n            }\n            /* other codec type, just skip (rtp, mp4s, ...) */\n            avio_skip(pb, size - (avio_tell(pb) - start_pos));\n        }\n        /* this will read extra atoms at the end (wave, alac, damr, avcC, SMI ...) */\n        a.size = size - (avio_tell(pb) - start_pos);\n        if (a.size > 8) {\n            int ret;\n            if ((ret = mov_read_default(c, pb, a)) < 0)\n                return ret;\n        } else if (a.size > 0)\n            avio_skip(pb, a.size);\n    }\n\n    if (st->codec->codec_type==AVMEDIA_TYPE_AUDIO && st->codec->sample_rate==0 && sc->time_scale>1)\n        st->codec->sample_rate= sc->time_scale;\n\n    /* special codec parameters handling */\n    switch (st->codec->codec_id) {\n#if CONFIG_DV_DEMUXER\n    case CODEC_ID_DVAUDIO:\n        c->dv_fctx = avformat_alloc_context();\n        c->dv_demux = avpriv_dv_init_demux(c->dv_fctx);\n        if (!c->dv_demux) {\n            av_log(c->fc, AV_LOG_ERROR, \"dv demux context init error\\n\");\n            return AVERROR(ENOMEM);\n        }\n        sc->dv_audio_container = 1;\n        st->codec->codec_id = CODEC_ID_PCM_S16LE;\n        break;\n#endif\n    /* no ifdef since parameters are always those */\n    case CODEC_ID_QCELP:\n        // force sample rate for qcelp when not stored in mov\n        if (st->codec->codec_tag != MKTAG('Q','c','l','p'))\n            st->codec->sample_rate = 8000;\n        st->codec->channels= 1; /* really needed */\n        break;\n    case CODEC_ID_AMR_NB:\n        st->codec->channels= 1; /* really needed */\n        /* force sample rate for amr, stsd in 3gp does not store sample rate */\n        st->codec->sample_rate = 8000;\n        break;\n    case CODEC_ID_AMR_WB:\n        st->codec->channels    = 1;\n        st->codec->sample_rate = 16000;\n        break;\n    case CODEC_ID_MP2:\n    case CODEC_ID_MP3:\n        st->codec->codec_type = AVMEDIA_TYPE_AUDIO; /* force type after stsd for m1a hdlr */\n        st->need_parsing = AVSTREAM_PARSE_FULL;\n        break;\n    case CODEC_ID_GSM:\n    case CODEC_ID_ADPCM_MS:\n    case CODEC_ID_ADPCM_IMA_WAV:\n        st->codec->block_align = sc->bytes_per_frame;\n        break;\n    case CODEC_ID_ALAC:\n        if (st->codec->extradata_size == 36) {\n            st->codec->channels   = AV_RB8 (st->codec->extradata+21);\n            st->codec->sample_rate = AV_RB32(st->codec->extradata+32);\n        }\n        break;\n    case CODEC_ID_AC3:\n        st->need_parsing = AVSTREAM_PARSE_FULL;\n        break;\n    case CODEC_ID_MPEG1VIDEO:\n        st->need_parsing = AVSTREAM_PARSE_FULL;\n        break;\n    default:\n        break;\n    }\n\n    return 0;\n}\n\nstatic int mov_read_stsd(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    int entries;\n\n    avio_r8(pb); /* version */\n    avio_rb24(pb); /* flags */\n    entries = avio_rb32(pb);\n\n    return ff_mov_read_stsd_entries(c, pb, entries);\n}\n\nstatic int mov_read_stsc(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    MOVStreamContext *sc;\n    unsigned int i, entries;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n    sc = st->priv_data;\n\n    avio_r8(pb); /* version */\n    avio_rb24(pb); /* flags */\n\n    entries = avio_rb32(pb);\n\n    av_dlog(c->fc, \"track[%i].stsc.entries = %i\\n\", c->fc->nb_streams-1, entries);\n\n    if (!entries)\n        return 0;\n    if (entries >= UINT_MAX / sizeof(*sc->stsc_data))\n        return AVERROR_INVALIDDATA;\n    sc->stsc_data = av_malloc(entries * sizeof(*sc->stsc_data));\n    if (!sc->stsc_data)\n        return AVERROR(ENOMEM);\n    sc->stsc_count = entries;\n\n    for (i=0; i<entries; i++) {\n        sc->stsc_data[i].first = avio_rb32(pb);\n        sc->stsc_data[i].count = avio_rb32(pb);\n        sc->stsc_data[i].id = avio_rb32(pb);\n    }\n    return 0;\n}\n\nstatic int mov_read_stps(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    MOVStreamContext *sc;\n    unsigned i, entries;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n    sc = st->priv_data;\n\n    avio_rb32(pb); // version + flags\n\n    entries = avio_rb32(pb);\n    if (entries >= UINT_MAX / sizeof(*sc->stps_data))\n        return AVERROR_INVALIDDATA;\n    sc->stps_data = av_malloc(entries * sizeof(*sc->stps_data));\n    if (!sc->stps_data)\n        return AVERROR(ENOMEM);\n    sc->stps_count = entries;\n\n    for (i = 0; i < entries; i++) {\n        sc->stps_data[i] = avio_rb32(pb);\n        //av_dlog(c->fc, \"stps %d\\n\", sc->stps_data[i]);\n    }\n\n    return 0;\n}\n\nstatic int mov_read_stss(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    MOVStreamContext *sc;\n    unsigned int i, entries;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n    sc = st->priv_data;\n\n    avio_r8(pb); /* version */\n    avio_rb24(pb); /* flags */\n\n    entries = avio_rb32(pb);\n\n    av_dlog(c->fc, \"keyframe_count = %d\\n\", entries);\n\n    if (!entries)\n    {\n        sc->keyframe_absent = 1;\n        return 0;\n    }\n    if (entries >= UINT_MAX / sizeof(int))\n        return AVERROR_INVALIDDATA;\n    sc->keyframes = av_malloc(entries * sizeof(int));\n    if (!sc->keyframes)\n        return AVERROR(ENOMEM);\n    sc->keyframe_count = entries;\n\n    for (i=0; i<entries; i++) {\n        sc->keyframes[i] = avio_rb32(pb);\n        //av_dlog(c->fc, \"keyframes[]=%d\\n\", sc->keyframes[i]);\n    }\n    return 0;\n}\n\nstatic int mov_read_stsz(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    MOVStreamContext *sc;\n    unsigned int i, entries, sample_size, field_size, num_bytes;\n    GetBitContext gb;\n    unsigned char* buf;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n    sc = st->priv_data;\n\n    avio_r8(pb); /* version */\n    avio_rb24(pb); /* flags */\n\n    if (atom.type == MKTAG('s','t','s','z')) {\n        sample_size = avio_rb32(pb);\n        if (!sc->sample_size) /* do not overwrite value computed in stsd */\n            sc->sample_size = sample_size;\n        sc->alt_sample_size = sample_size;\n        field_size = 32;\n    } else {\n        sample_size = 0;\n        avio_rb24(pb); /* reserved */\n        field_size = avio_r8(pb);\n    }\n    entries = avio_rb32(pb);\n\n    av_dlog(c->fc, \"sample_size = %d sample_count = %d\\n\", sc->sample_size, entries);\n\n    sc->sample_count = entries;\n    if (sample_size)\n        return 0;\n\n    if (field_size != 4 && field_size != 8 && field_size != 16 && field_size != 32) {\n        av_log(c->fc, AV_LOG_ERROR, \"Invalid sample field size %d\\n\", field_size);\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (!entries)\n        return 0;\n    if (entries >= UINT_MAX / sizeof(int) || entries >= (UINT_MAX - 4) / field_size)\n        return AVERROR_INVALIDDATA;\n    sc->sample_sizes = av_malloc(entries * sizeof(int));\n    if (!sc->sample_sizes)\n        return AVERROR(ENOMEM);\n\n    num_bytes = (entries*field_size+4)>>3;\n\n    buf = av_malloc(num_bytes+FF_INPUT_BUFFER_PADDING_SIZE);\n    if (!buf) {\n        av_freep(&sc->sample_sizes);\n        return AVERROR(ENOMEM);\n    }\n\n    if (avio_read(pb, buf, num_bytes) < num_bytes) {\n        av_freep(&sc->sample_sizes);\n        av_free(buf);\n        return AVERROR_INVALIDDATA;\n    }\n\n    init_get_bits(&gb, buf, 8*num_bytes);\n\n    for (i = 0; i < entries; i++) {\n        sc->sample_sizes[i] = get_bits_long(&gb, field_size);\n        sc->data_size += sc->sample_sizes[i];\n    }\n\n    av_free(buf);\n    return 0;\n}\n\nstatic int mov_read_stts(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    MOVStreamContext *sc;\n    unsigned int i, entries;\n    int64_t duration=0;\n    int64_t total_sample_count=0;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n    sc = st->priv_data;\n\n    avio_r8(pb); /* version */\n    avio_rb24(pb); /* flags */\n    entries = avio_rb32(pb);\n\n    av_dlog(c->fc, \"track[%i].stts.entries = %i\\n\",\n            c->fc->nb_streams-1, entries);\n\n    if (entries >= UINT_MAX / sizeof(*sc->stts_data))\n        return -1;\n\n    sc->stts_data = av_malloc(entries * sizeof(*sc->stts_data));\n    if (!sc->stts_data)\n        return AVERROR(ENOMEM);\n\n    sc->stts_count = entries;\n\n    for (i=0; i<entries; i++) {\n        int sample_duration;\n        int sample_count;\n\n        sample_count=avio_rb32(pb);\n        sample_duration = avio_rb32(pb);\n        /* sample_duration < 0 is invalid based on the spec */\n        if (sample_duration < 0) {\n            av_log(c->fc, AV_LOG_ERROR, \"Invalid SampleDelta in STTS %d\\n\", sample_duration);\n            sample_duration = 1;\n        }\n        sc->stts_data[i].count= sample_count;\n        sc->stts_data[i].duration= sample_duration;\n\n        av_dlog(c->fc, \"sample_count=%d, sample_duration=%d\\n\",\n                sample_count, sample_duration);\n\n        duration+=(int64_t)sample_duration*sample_count;\n        total_sample_count+=sample_count;\n    }\n\n    st->nb_frames= total_sample_count;\n    if (duration)\n        st->duration= duration;\n    sc->track_end = duration;\n    return 0;\n}\n\nstatic int mov_read_ctts(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    MOVStreamContext *sc;\n    unsigned int i, entries;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n    sc = st->priv_data;\n\n    avio_r8(pb); /* version */\n    avio_rb24(pb); /* flags */\n    entries = avio_rb32(pb);\n\n    av_dlog(c->fc, \"track[%i].ctts.entries = %i\\n\", c->fc->nb_streams-1, entries);\n\n    if (!entries)\n        return 0;\n    if (entries >= UINT_MAX / sizeof(*sc->ctts_data))\n        return AVERROR_INVALIDDATA;\n    sc->ctts_data = av_malloc(entries * sizeof(*sc->ctts_data));\n    if (!sc->ctts_data)\n        return AVERROR(ENOMEM);\n    sc->ctts_count = entries;\n\n    for (i=0; i<entries; i++) {\n        int count    =avio_rb32(pb);\n        int duration =avio_rb32(pb);\n\n        sc->ctts_data[i].count   = count;\n        sc->ctts_data[i].duration= duration;\n\n        if (FFABS(duration) > (1<<28) && i+2<entries) {\n            av_log(c->fc, AV_LOG_WARNING, \"CTTS invalid\\n\");\n            av_freep(&sc->ctts_data);\n            sc->ctts_count = 0;\n            return 0;\n        }\n\n        if (duration < 0 && i+2<entries)\n            sc->dts_shift = FFMAX(sc->dts_shift, -duration);\n    }\n\n    av_dlog(c->fc, \"dts shift %d\\n\", sc->dts_shift);\n\n    return 0;\n}\n\nstatic void mov_build_index(MOVContext *mov, AVStream *st)\n{\n    MOVStreamContext *sc = st->priv_data;\n    int64_t current_offset;\n    int64_t current_dts = 0;\n    unsigned int stts_index = 0;\n    unsigned int stsc_index = 0;\n    unsigned int stss_index = 0;\n    unsigned int stps_index = 0;\n    unsigned int i, j;\n    uint64_t stream_size = 0;\n    AVIndexEntry *mem;\n\n    /* adjust first dts according to edit list */\n    if ((sc->empty_duration || sc->start_time) && mov->time_scale > 0) {\n        if (sc->empty_duration)\n            sc->empty_duration = av_rescale(sc->empty_duration, sc->time_scale, mov->time_scale);\n        sc->time_offset = sc->start_time - sc->empty_duration;\n        current_dts = -sc->time_offset;\n        if (sc->ctts_data && sc->stts_data &&\n            sc->ctts_data[0].duration / FFMAX(sc->stts_data[0].duration, 1) > 16) {\n            /* more than 16 frames delay, dts are likely wrong\n               this happens with files created by iMovie */\n            sc->wrong_dts = 1;\n            st->codec->has_b_frames = 1;\n        }\n    }\n\n    /* only use old uncompressed audio chunk demuxing when stts specifies it */\n    if (!(st->codec->codec_type == AVMEDIA_TYPE_AUDIO &&\n          sc->stts_count == 1 && sc->stts_data[0].duration == 1)) {\n        unsigned int current_sample = 0;\n        unsigned int stts_sample = 0;\n        unsigned int sample_size;\n        unsigned int distance = 0;\n        int key_off = sc->keyframe_count && sc->keyframes[0] == 1;\n\n        current_dts -= sc->dts_shift;\n\n        if (!sc->sample_count || st->nb_index_entries)\n            return;\n        if (sc->sample_count >= UINT_MAX / sizeof(*st->index_entries) - st->nb_index_entries)\n            return;\n        mem = av_realloc(st->index_entries, (st->nb_index_entries + sc->sample_count) * sizeof(*st->index_entries));\n        if (!mem)\n            return;\n        st->index_entries = mem;\n        st->index_entries_allocated_size = (st->nb_index_entries + sc->sample_count) * sizeof(*st->index_entries);\n\n        for (i = 0; i < sc->chunk_count; i++) {\n            current_offset = sc->chunk_offsets[i];\n            while (stsc_index + 1 < sc->stsc_count &&\n                i + 1 == sc->stsc_data[stsc_index + 1].first)\n                stsc_index++;\n            for (j = 0; j < sc->stsc_data[stsc_index].count; j++) {\n                int keyframe = 0;\n                if (current_sample >= sc->sample_count) {\n                    av_log(mov->fc, AV_LOG_ERROR, \"wrong sample count\\n\");\n                    return;\n                }\n\n                if (!sc->keyframe_absent && (!sc->keyframe_count || current_sample+key_off == sc->keyframes[stss_index])) {\n                    keyframe = 1;\n                    if (stss_index + 1 < sc->keyframe_count)\n                        stss_index++;\n                } else if (sc->stps_count && current_sample+key_off == sc->stps_data[stps_index]) {\n                    keyframe = 1;\n                    if (stps_index + 1 < sc->stps_count)\n                        stps_index++;\n                }\n                if (keyframe)\n                    distance = 0;\n                sample_size = sc->alt_sample_size > 0 ? sc->alt_sample_size : sc->sample_sizes[current_sample];\n                if (sc->pseudo_stream_id == -1 ||\n                   sc->stsc_data[stsc_index].id - 1 == sc->pseudo_stream_id) {\n                    AVIndexEntry *e = &st->index_entries[st->nb_index_entries++];\n                    e->pos = current_offset;\n                    e->timestamp = current_dts;\n                    e->size = sample_size;\n                    e->min_distance = distance;\n                    e->flags = keyframe ? AVINDEX_KEYFRAME : 0;\n                    av_dlog(mov->fc, \"AVIndex stream %d, sample %d, offset %\"PRIx64\", dts %\"PRId64\", \"\n                            \"size %d, distance %d, keyframe %d\\n\", st->index, current_sample,\n                            current_offset, current_dts, sample_size, distance, keyframe);\n                }\n\n                current_offset += sample_size;\n                stream_size += sample_size;\n                current_dts += sc->stts_data[stts_index].duration;\n                distance++;\n                stts_sample++;\n                current_sample++;\n                if (stts_index + 1 < sc->stts_count && stts_sample == sc->stts_data[stts_index].count) {\n                    stts_sample = 0;\n                    stts_index++;\n                }\n            }\n        }\n        if (st->duration > 0)\n            st->codec->bit_rate = stream_size*8*sc->time_scale/st->duration;\n    } else {\n        unsigned chunk_samples, total = 0;\n\n        // compute total chunk count\n        for (i = 0; i < sc->stsc_count; i++) {\n            unsigned count, chunk_count;\n\n            chunk_samples = sc->stsc_data[i].count;\n            if (i != sc->stsc_count - 1 &&\n                sc->samples_per_frame && chunk_samples % sc->samples_per_frame) {\n                av_log(mov->fc, AV_LOG_ERROR, \"error unaligned chunk\\n\");\n                return;\n            }\n\n            if (sc->samples_per_frame >= 160) { // gsm\n                count = chunk_samples / sc->samples_per_frame;\n            } else if (sc->samples_per_frame > 1) {\n                unsigned samples = (1024/sc->samples_per_frame)*sc->samples_per_frame;\n                count = (chunk_samples+samples-1) / samples;\n            } else {\n                count = (chunk_samples+1023) / 1024;\n            }\n\n            if (i < sc->stsc_count - 1)\n                chunk_count = sc->stsc_data[i+1].first - sc->stsc_data[i].first;\n            else\n                chunk_count = sc->chunk_count - (sc->stsc_data[i].first - 1);\n            total += chunk_count * count;\n        }\n\n        av_dlog(mov->fc, \"chunk count %d\\n\", total);\n        if (total >= UINT_MAX / sizeof(*st->index_entries) - st->nb_index_entries)\n            return;\n        mem = av_realloc(st->index_entries, (st->nb_index_entries + total) * sizeof(*st->index_entries));\n        if (!mem)\n            return;\n        st->index_entries = mem;\n        st->index_entries_allocated_size = (st->nb_index_entries + total) * sizeof(*st->index_entries);\n\n        // populate index\n        for (i = 0; i < sc->chunk_count; i++) {\n            current_offset = sc->chunk_offsets[i];\n            if (stsc_index + 1 < sc->stsc_count &&\n                i + 1 == sc->stsc_data[stsc_index + 1].first)\n                stsc_index++;\n            chunk_samples = sc->stsc_data[stsc_index].count;\n\n            while (chunk_samples > 0) {\n                AVIndexEntry *e;\n                unsigned size, samples;\n\n                if (sc->samples_per_frame >= 160) { // gsm\n                    samples = sc->samples_per_frame;\n                    size = sc->bytes_per_frame;\n                } else {\n                    if (sc->samples_per_frame > 1) {\n                        samples = FFMIN((1024 / sc->samples_per_frame)*\n                                        sc->samples_per_frame, chunk_samples);\n                        size = (samples / sc->samples_per_frame) * sc->bytes_per_frame;\n                    } else {\n                        samples = FFMIN(1024, chunk_samples);\n                        size = samples * sc->sample_size;\n                    }\n                }\n\n                if (st->nb_index_entries >= total) {\n                    av_log(mov->fc, AV_LOG_ERROR, \"wrong chunk count %d\\n\", total);\n                    return;\n                }\n                e = &st->index_entries[st->nb_index_entries++];\n                e->pos = current_offset;\n                e->timestamp = current_dts;\n                e->size = size;\n                e->min_distance = 0;\n                e->flags = AVINDEX_KEYFRAME;\n                av_dlog(mov->fc, \"AVIndex stream %d, chunk %d, offset %\"PRIx64\", dts %\"PRId64\", \"\n                        \"size %d, duration %d\\n\", st->index, i, current_offset, current_dts,\n                        size, samples);\n\n                current_offset += size;\n                current_dts += samples;\n                chunk_samples -= samples;\n            }\n        }\n    }\n}\n\nstatic int mov_open_dref(AVIOContext **pb, const char *src, MOVDref *ref,\n                         AVIOInterruptCB *int_cb, int use_absolute_path, AVFormatContext *fc)\n{\n    /* try relative path, we do not try the absolute because it can leak information about our\n       system to an attacker */\n    if (ref->nlvl_to > 0 && ref->nlvl_from > 0) {\n        char filename[1024];\n        const char *src_path;\n        int i, l;\n\n        /* find a source dir */\n        src_path = strrchr(src, '/');\n        if (src_path)\n            src_path++;\n        else\n            src_path = src;\n\n        /* find a next level down to target */\n        for (i = 0, l = strlen(ref->path) - 1; l >= 0; l--)\n            if (ref->path[l] == '/') {\n                if (i == ref->nlvl_to - 1)\n                    break;\n                else\n                    i++;\n            }\n\n        /* compose filename if next level down to target was found */\n        if (i == ref->nlvl_to - 1 && src_path - src  < sizeof(filename)) {\n            memcpy(filename, src, src_path - src);\n            filename[src_path - src] = 0;\n\n            for (i = 1; i < ref->nlvl_from; i++)\n                av_strlcat(filename, \"../\", 1024);\n\n            av_strlcat(filename, ref->path + l + 1, 1024);\n\n            if (!avio_open2(pb, filename, AVIO_FLAG_READ, int_cb, NULL))\n                return 0;\n        }\n    } else if (use_absolute_path) {\n        av_log(fc, AV_LOG_WARNING, \"Using absolute path on user request, \"\n               \"this is a possible security issue\\n\");\n        if (!avio_open2(pb, ref->path, AVIO_FLAG_READ, int_cb, NULL))\n            return 0;\n    }\n\n    return AVERROR(ENOENT);\n}\n\nstatic int mov_read_trak(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    MOVStreamContext *sc;\n    int ret;\n\n    st = avformat_new_stream(c->fc, NULL);\n    if (!st) return AVERROR(ENOMEM);\n    st->id = c->fc->nb_streams;\n    sc = av_mallocz(sizeof(MOVStreamContext));\n    if (!sc) return AVERROR(ENOMEM);\n\n    st->priv_data = sc;\n    st->codec->codec_type = AVMEDIA_TYPE_DATA;\n    sc->ffindex = st->index;\n\n    if ((ret = mov_read_default(c, pb, atom)) < 0)\n        return ret;\n\n    /* sanity checks */\n    if (sc->chunk_count && (!sc->stts_count || !sc->stsc_count ||\n                            (!sc->sample_size && !sc->sample_count))) {\n        av_log(c->fc, AV_LOG_ERROR, \"stream %d, missing mandatory atoms, broken header\\n\",\n               st->index);\n        return 0;\n    }\n\n    if (sc->time_scale <= 0) {\n        av_log(c->fc, AV_LOG_WARNING, \"stream %d, timescale not set\\n\", st->index);\n        sc->time_scale = c->time_scale;\n        if (sc->time_scale <= 0)\n            sc->time_scale = 1;\n    }\n\n    avpriv_set_pts_info(st, 64, 1, sc->time_scale);\n\n    mov_build_index(c, st);\n\n    if (sc->dref_id-1 < sc->drefs_count && sc->drefs[sc->dref_id-1].path) {\n        MOVDref *dref = &sc->drefs[sc->dref_id - 1];\n        if (mov_open_dref(&sc->pb, c->fc->filename, dref, &c->fc->interrupt_callback,\n            c->use_absolute_path, c->fc) < 0)\n            av_log(c->fc, AV_LOG_ERROR,\n                   \"stream %d, error opening alias: path='%s', dir='%s', \"\n                   \"filename='%s', volume='%s', nlvl_from=%d, nlvl_to=%d\\n\",\n                   st->index, dref->path, dref->dir, dref->filename,\n                   dref->volume, dref->nlvl_from, dref->nlvl_to);\n    } else\n        sc->pb = c->fc->pb;\n\n    if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO) {\n        if (!st->sample_aspect_ratio.num &&\n            (st->codec->width != sc->width || st->codec->height != sc->height)) {\n            st->sample_aspect_ratio = av_d2q(((double)st->codec->height * sc->width) /\n                                             ((double)st->codec->width * sc->height), INT_MAX);\n        }\n\n        av_reduce(&st->avg_frame_rate.num, &st->avg_frame_rate.den,\n                  sc->time_scale*st->nb_frames, st->duration, INT_MAX);\n\n        if (sc->stts_count == 1 || (sc->stts_count == 2 && sc->stts_data[1].count == 1))\n            av_reduce(&st->r_frame_rate.num, &st->r_frame_rate.den,\n                      sc->time_scale, sc->stts_data[0].duration, INT_MAX);\n    }\n\n    switch (st->codec->codec_id) {\n#if CONFIG_H261_DECODER\n    case CODEC_ID_H261:\n#endif\n#if CONFIG_H263_DECODER\n    case CODEC_ID_H263:\n#endif\n#if CONFIG_H264_DECODER\n    case CODEC_ID_H264:\n#endif\n#if CONFIG_MPEG4_DECODER\n    case CODEC_ID_MPEG4:\n#endif\n        st->codec->width = 0; /* let decoder init width/height */\n        st->codec->height= 0;\n        break;\n    }\n\n    /* Do not need those anymore. */\n    av_freep(&sc->chunk_offsets);\n    av_freep(&sc->stsc_data);\n    av_freep(&sc->sample_sizes);\n    av_freep(&sc->keyframes);\n    av_freep(&sc->stts_data);\n    av_freep(&sc->stps_data);\n\n    return 0;\n}\n\nstatic int mov_read_ilst(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    int ret;\n    c->itunes_metadata = 1;\n    ret = mov_read_default(c, pb, atom);\n    c->itunes_metadata = 0;\n    return ret;\n}\n\nstatic int mov_read_meta(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    while (atom.size > 8) {\n        uint32_t tag = avio_rl32(pb);\n        atom.size -= 4;\n        if (tag == MKTAG('h','d','l','r')) {\n            avio_seek(pb, -8, SEEK_CUR);\n            atom.size += 8;\n            return mov_read_default(c, pb, atom);\n        }\n    }\n    return 0;\n}\n\nstatic int mov_read_tkhd(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    int i;\n    int width;\n    int height;\n    int64_t disp_transform[2];\n    int display_matrix[3][2];\n    AVStream *st;\n    MOVStreamContext *sc;\n    int version;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n    sc = st->priv_data;\n\n    version = avio_r8(pb);\n    avio_rb24(pb); /* flags */\n    /*\n    MOV_TRACK_ENABLED 0x0001\n    MOV_TRACK_IN_MOVIE 0x0002\n    MOV_TRACK_IN_PREVIEW 0x0004\n    MOV_TRACK_IN_POSTER 0x0008\n    */\n\n    if (version == 1) {\n        avio_rb64(pb);\n        avio_rb64(pb);\n    } else {\n        avio_rb32(pb); /* creation time */\n        avio_rb32(pb); /* modification time */\n    }\n    st->id = (int)avio_rb32(pb); /* track id (NOT 0 !)*/\n    avio_rb32(pb); /* reserved */\n\n    /* highlevel (considering edits) duration in movie timebase */\n    (version == 1) ? avio_rb64(pb) : avio_rb32(pb);\n    avio_rb32(pb); /* reserved */\n    avio_rb32(pb); /* reserved */\n\n    avio_rb16(pb); /* layer */\n    avio_rb16(pb); /* alternate group */\n    avio_rb16(pb); /* volume */\n    avio_rb16(pb); /* reserved */\n\n    //read in the display matrix (outlined in ISO 14496-12, Section 6.2.2)\n    // they're kept in fixed point format through all calculations\n    // ignore u,v,z b/c we don't need the scale factor to calc aspect ratio\n    for (i = 0; i < 3; i++) {\n        display_matrix[i][0] = avio_rb32(pb);   // 16.16 fixed point\n        display_matrix[i][1] = avio_rb32(pb);   // 16.16 fixed point\n        avio_rb32(pb);           // 2.30 fixed point (not used)\n    }\n\n    width = avio_rb32(pb);       // 16.16 fixed point track width\n    height = avio_rb32(pb);      // 16.16 fixed point track height\n    sc->width = width >> 16;\n    sc->height = height >> 16;\n\n    //Assign clockwise rotate values based on transform matrix so that\n    //we can compensate for iPhone orientation during capture.\n\n    if (display_matrix[1][0] == -65536 && display_matrix[0][1] == 65536) {\n         av_dict_set(&st->metadata, \"rotate\", \"90\", 0);\n    }\n\n    if (display_matrix[0][0] == -65536 && display_matrix[1][1] == -65536) {\n         av_dict_set(&st->metadata, \"rotate\", \"180\", 0);\n    }\n\n    if (display_matrix[1][0] == 65536 && display_matrix[0][1] == -65536) {\n         av_dict_set(&st->metadata, \"rotate\", \"270\", 0);\n    }\n\n    // transform the display width/height according to the matrix\n    // skip this if the display matrix is the default identity matrix\n    // or if it is rotating the picture, ex iPhone 3GS\n    // to keep the same scale, use [width height 1<<16]\n    if (width && height &&\n        ((display_matrix[0][0] != 65536  ||\n          display_matrix[1][1] != 65536) &&\n         !display_matrix[0][1] &&\n         !display_matrix[1][0] &&\n         !display_matrix[2][0] && !display_matrix[2][1])) {\n        for (i = 0; i < 2; i++)\n            disp_transform[i] =\n                (int64_t)  width  * display_matrix[0][i] +\n                (int64_t)  height * display_matrix[1][i] +\n                ((int64_t) display_matrix[2][i] << 16);\n\n        //sample aspect ratio is new width/height divided by old width/height\n        st->sample_aspect_ratio = av_d2q(\n            ((double) disp_transform[0] * height) /\n            ((double) disp_transform[1] * width), INT_MAX);\n    }\n    return 0;\n}\n\nstatic int mov_read_tfhd(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    MOVFragment *frag = &c->fragment;\n    MOVTrackExt *trex = NULL;\n    int flags, track_id, i;\n\n    avio_r8(pb); /* version */\n    flags = avio_rb24(pb);\n\n    track_id = avio_rb32(pb);\n    if (!track_id)\n        return AVERROR_INVALIDDATA;\n    frag->track_id = track_id;\n    for (i = 0; i < c->trex_count; i++)\n        if (c->trex_data[i].track_id == frag->track_id) {\n            trex = &c->trex_data[i];\n            break;\n        }\n    if (!trex) {\n        av_log(c->fc, AV_LOG_ERROR, \"could not find corresponding trex\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    frag->base_data_offset = flags & MOV_TFHD_BASE_DATA_OFFSET ?\n                             avio_rb64(pb) : frag->moof_offset;\n    frag->stsd_id  = flags & MOV_TFHD_STSD_ID ? avio_rb32(pb) : trex->stsd_id;\n\n    frag->duration = flags & MOV_TFHD_DEFAULT_DURATION ?\n                     avio_rb32(pb) : trex->duration;\n    frag->size     = flags & MOV_TFHD_DEFAULT_SIZE ?\n                     avio_rb32(pb) : trex->size;\n    frag->flags    = flags & MOV_TFHD_DEFAULT_FLAGS ?\n                     avio_rb32(pb) : trex->flags;\n    av_dlog(c->fc, \"frag flags 0x%x\\n\", frag->flags);\n    return 0;\n}\n\nstatic int mov_read_chap(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    c->chapter_track = avio_rb32(pb);\n    return 0;\n}\n\nstatic int mov_read_trex(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    MOVTrackExt *trex;\n\n    if ((uint64_t)c->trex_count+1 >= UINT_MAX / sizeof(*c->trex_data))\n        return AVERROR_INVALIDDATA;\n    trex = av_realloc(c->trex_data, (c->trex_count+1)*sizeof(*c->trex_data));\n    if (!trex)\n        return AVERROR(ENOMEM);\n\n    c->fc->duration = AV_NOPTS_VALUE; // the duration from mvhd is not representing the whole file when fragments are used.\n\n    c->trex_data = trex;\n    trex = &c->trex_data[c->trex_count++];\n    avio_r8(pb); /* version */\n    avio_rb24(pb); /* flags */\n    trex->track_id = avio_rb32(pb);\n    trex->stsd_id  = avio_rb32(pb);\n    trex->duration = avio_rb32(pb);\n    trex->size     = avio_rb32(pb);\n    trex->flags    = avio_rb32(pb);\n    return 0;\n}\n\nstatic int mov_read_trun(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    MOVFragment *frag = &c->fragment;\n    AVStream *st = NULL;\n    MOVStreamContext *sc;\n    MOVStts *ctts_data;\n    uint64_t offset;\n    int64_t dts;\n    int data_offset = 0;\n    unsigned entries, first_sample_flags = frag->flags;\n    int flags, distance, i, found_keyframe = 0;\n\n    for (i = 0; i < c->fc->nb_streams; i++) {\n        if (c->fc->streams[i]->id == frag->track_id) {\n            st = c->fc->streams[i];\n            break;\n        }\n    }\n    if (!st) {\n        av_log(c->fc, AV_LOG_ERROR, \"could not find corresponding track id %d\\n\", frag->track_id);\n        return AVERROR_INVALIDDATA;\n    }\n    sc = st->priv_data;\n    if (sc->pseudo_stream_id+1 != frag->stsd_id)\n        return 0;\n    avio_r8(pb); /* version */\n    flags = avio_rb24(pb);\n    entries = avio_rb32(pb);\n    av_dlog(c->fc, \"flags 0x%x entries %d\\n\", flags, entries);\n\n    /* Always assume the presence of composition time offsets.\n     * Without this assumption, for instance, we cannot deal with a track in fragmented movies that meet the following.\n     *  1) in the initial movie, there are no samples.\n     *  2) in the first movie fragment, there is only one sample without composition time offset.\n     *  3) in the subsequent movie fragments, there are samples with composition time offset. */\n    if (!sc->ctts_count && sc->sample_count)\n    {\n        /* Complement ctts table if moov atom doesn't have ctts atom. */\n        ctts_data = av_malloc(sizeof(*sc->ctts_data));\n        if (!ctts_data)\n            return AVERROR(ENOMEM);\n        sc->ctts_data = ctts_data;\n        sc->ctts_data[sc->ctts_count].count = sc->sample_count;\n        sc->ctts_data[sc->ctts_count].duration = 0;\n        sc->ctts_count++;\n    }\n    if ((uint64_t)entries+sc->ctts_count >= UINT_MAX/sizeof(*sc->ctts_data))\n        return AVERROR_INVALIDDATA;\n    ctts_data = av_realloc(sc->ctts_data,\n                           (entries+sc->ctts_count)*sizeof(*sc->ctts_data));\n    if (!ctts_data)\n        return AVERROR(ENOMEM);\n    sc->ctts_data = ctts_data;\n\n    if (flags & MOV_TRUN_DATA_OFFSET)        data_offset        = avio_rb32(pb);\n    if (flags & MOV_TRUN_FIRST_SAMPLE_FLAGS) first_sample_flags = avio_rb32(pb);\n    dts    = sc->track_end - sc->time_offset;\n    offset = frag->base_data_offset + data_offset;\n    distance = 0;\n    av_dlog(c->fc, \"first sample flags 0x%x\\n\", first_sample_flags);\n    for (i = 0; i < entries; i++) {\n        unsigned sample_size = frag->size;\n        int sample_flags = i ? frag->flags : first_sample_flags;\n        unsigned sample_duration = frag->duration;\n        int keyframe = 0;\n\n        if (flags & MOV_TRUN_SAMPLE_DURATION) sample_duration = avio_rb32(pb);\n        if (flags & MOV_TRUN_SAMPLE_SIZE)     sample_size     = avio_rb32(pb);\n        if (flags & MOV_TRUN_SAMPLE_FLAGS)    sample_flags    = avio_rb32(pb);\n        sc->ctts_data[sc->ctts_count].count = 1;\n        sc->ctts_data[sc->ctts_count].duration = (flags & MOV_TRUN_SAMPLE_CTS) ?\n                                                  avio_rb32(pb) : 0;\n        sc->ctts_count++;\n        if (st->codec->codec_type == AVMEDIA_TYPE_AUDIO)\n            keyframe = 1;\n        else if (!found_keyframe)\n            keyframe = found_keyframe =\n                !(sample_flags & (MOV_FRAG_SAMPLE_FLAG_IS_NON_SYNC |\n                                  MOV_FRAG_SAMPLE_FLAG_DEPENDS_YES));\n        if (keyframe)\n            distance = 0;\n        av_add_index_entry(st, offset, dts, sample_size, distance,\n                           keyframe ? AVINDEX_KEYFRAME : 0);\n        av_dlog(c->fc, \"AVIndex stream %d, sample %d, offset %\"PRIx64\", dts %\"PRId64\", \"\n                \"size %d, distance %d, keyframe %d\\n\", st->index, sc->sample_count+i,\n                offset, dts, sample_size, distance, keyframe);\n        distance++;\n        dts += sample_duration;\n        offset += sample_size;\n        sc->data_size += sample_size;\n    }\n    frag->moof_offset = offset;\n    st->duration = sc->track_end = dts + sc->time_offset;\n    return 0;\n}\n\n/* this atom should be null (from specs), but some buggy files put the 'moov' atom inside it... */\n/* like the files created with Adobe Premiere 5.0, for samples see */\n/* http://graphics.tudelft.nl/~wouter/publications/soundtests/ */\nstatic int mov_read_wide(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    int err;\n\n    if (atom.size < 8)\n        return 0; /* continue */\n    if (avio_rb32(pb) != 0) { /* 0 sized mdat atom... use the 'wide' atom size */\n        avio_skip(pb, atom.size - 4);\n        return 0;\n    }\n    atom.type = avio_rl32(pb);\n    atom.size -= 8;\n    if (atom.type != MKTAG('m','d','a','t')) {\n        avio_skip(pb, atom.size);\n        return 0;\n    }\n    err = mov_read_mdat(c, pb, atom);\n    return err;\n}\n\nstatic int mov_read_cmov(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n#if CONFIG_ZLIB\n    AVIOContext ctx;\n    uint8_t *cmov_data;\n    uint8_t *moov_data; /* uncompressed data */\n    long cmov_len, moov_len;\n    int ret = -1;\n\n    avio_rb32(pb); /* dcom atom */\n    if (avio_rl32(pb) != MKTAG('d','c','o','m'))\n        return AVERROR_INVALIDDATA;\n    if (avio_rl32(pb) != MKTAG('z','l','i','b')) {\n        av_log(c->fc, AV_LOG_ERROR, \"unknown compression for cmov atom !\");\n        return AVERROR_INVALIDDATA;\n    }\n    avio_rb32(pb); /* cmvd atom */\n    if (avio_rl32(pb) != MKTAG('c','m','v','d'))\n        return AVERROR_INVALIDDATA;\n    moov_len = avio_rb32(pb); /* uncompressed size */\n    cmov_len = atom.size - 6 * 4;\n\n    cmov_data = av_malloc(cmov_len);\n    if (!cmov_data)\n        return AVERROR(ENOMEM);\n    moov_data = av_malloc(moov_len);\n    if (!moov_data) {\n        av_free(cmov_data);\n        return AVERROR(ENOMEM);\n    }\n    avio_read(pb, cmov_data, cmov_len);\n    if (uncompress (moov_data, (uLongf *) &moov_len, (const Bytef *)cmov_data, cmov_len) != Z_OK)\n        goto free_and_return;\n    if (ffio_init_context(&ctx, moov_data, moov_len, 0, NULL, NULL, NULL, NULL) != 0)\n        goto free_and_return;\n    atom.type = MKTAG('m','o','o','v');\n    atom.size = moov_len;\n    ret = mov_read_default(c, &ctx, atom);\nfree_and_return:\n    av_free(moov_data);\n    av_free(cmov_data);\n    return ret;\n#else\n    av_log(c->fc, AV_LOG_ERROR, \"this file requires zlib support compiled in\\n\");\n    return AVERROR(ENOSYS);\n#endif\n}\n\n/* edit list atom */\nstatic int mov_read_elst(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    MOVStreamContext *sc;\n    int i, edit_count, version, edit_start_index = 0;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    sc = c->fc->streams[c->fc->nb_streams-1]->priv_data;\n\n    version = avio_r8(pb); /* version */\n    avio_rb24(pb); /* flags */\n    edit_count = avio_rb32(pb); /* entries */\n\n    if ((uint64_t)edit_count*12+8 > atom.size)\n        return AVERROR_INVALIDDATA;\n\n    for (i=0; i<edit_count; i++){\n        int64_t time;\n        int64_t duration;\n        if (version == 1) {\n            duration = avio_rb64(pb);\n            time     = avio_rb64(pb);\n        } else {\n            duration = avio_rb32(pb); /* segment duration */\n            time     = (int32_t)avio_rb32(pb); /* media time */\n        }\n        avio_rb32(pb); /* Media rate */\n        if (i == 0 && time == -1) {\n            sc->empty_duration = duration;\n            edit_start_index = 1;\n        } else if (i == edit_start_index && time >= 0)\n            sc->start_time = time;\n    }\n\n    if (edit_count > 1)\n        av_log(c->fc, AV_LOG_WARNING, \"multiple edit list entries, \"\n               \"a/v desync might occur, patch welcome\\n\");\n\n    av_dlog(c->fc, \"track[%i].edit_count = %i\\n\", c->fc->nb_streams-1, edit_count);\n    return 0;\n}\n\nstatic int mov_read_chan2(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    if (atom.size < 16)\n        return 0;\n    avio_skip(pb, 4);\n    ff_mov_read_chan(c->fc, atom.size - 4, c->fc->streams[0]->codec);\n    return 0;\n}\n\nstatic const MOVParseTableEntry mov_default_parse_table[] = {\n{ MKTAG('a','v','s','s'), mov_read_avss },\n{ MKTAG('c','h','p','l'), mov_read_chpl },\n{ MKTAG('c','o','6','4'), mov_read_stco },\n{ MKTAG('c','t','t','s'), mov_read_ctts }, /* composition time to sample */\n{ MKTAG('d','i','n','f'), mov_read_default },\n{ MKTAG('d','r','e','f'), mov_read_dref },\n{ MKTAG('e','d','t','s'), mov_read_default },\n{ MKTAG('e','l','s','t'), mov_read_elst },\n{ MKTAG('e','n','d','a'), mov_read_enda },\n{ MKTAG('f','i','e','l'), mov_read_fiel },\n{ MKTAG('f','t','y','p'), mov_read_ftyp },\n{ MKTAG('g','l','b','l'), mov_read_glbl },\n{ MKTAG('h','d','l','r'), mov_read_hdlr },\n{ MKTAG('i','l','s','t'), mov_read_ilst },\n{ MKTAG('j','p','2','h'), mov_read_jp2h },\n{ MKTAG('m','d','a','t'), mov_read_mdat },\n{ MKTAG('m','d','h','d'), mov_read_mdhd },\n{ MKTAG('m','d','i','a'), mov_read_default },\n{ MKTAG('m','e','t','a'), mov_read_meta },\n{ MKTAG('m','i','n','f'), mov_read_default },\n{ MKTAG('m','o','o','f'), mov_read_moof },\n{ MKTAG('m','o','o','v'), mov_read_moov },\n{ MKTAG('m','v','e','x'), mov_read_default },\n{ MKTAG('m','v','h','d'), mov_read_mvhd },\n{ MKTAG('S','M','I',' '), mov_read_smi }, /* Sorenson extension ??? */\n{ MKTAG('a','l','a','c'), mov_read_alac }, /* alac specific atom */\n{ MKTAG('a','v','c','C'), mov_read_glbl },\n{ MKTAG('p','a','s','p'), mov_read_pasp },\n{ MKTAG('s','t','b','l'), mov_read_default },\n{ MKTAG('s','t','c','o'), mov_read_stco },\n{ MKTAG('s','t','p','s'), mov_read_stps },\n{ MKTAG('s','t','r','f'), mov_read_strf },\n{ MKTAG('s','t','s','c'), mov_read_stsc },\n{ MKTAG('s','t','s','d'), mov_read_stsd }, /* sample description */\n{ MKTAG('s','t','s','s'), mov_read_stss }, /* sync sample */\n{ MKTAG('s','t','s','z'), mov_read_stsz }, /* sample size */\n{ MKTAG('s','t','t','s'), mov_read_stts },\n{ MKTAG('s','t','z','2'), mov_read_stsz }, /* compact sample size */\n{ MKTAG('t','k','h','d'), mov_read_tkhd }, /* track header */\n{ MKTAG('t','f','h','d'), mov_read_tfhd }, /* track fragment header */\n{ MKTAG('t','r','a','k'), mov_read_trak },\n{ MKTAG('t','r','a','f'), mov_read_default },\n{ MKTAG('t','r','e','f'), mov_read_default },\n{ MKTAG('c','h','a','p'), mov_read_chap },\n{ MKTAG('t','r','e','x'), mov_read_trex },\n{ MKTAG('t','r','u','n'), mov_read_trun },\n{ MKTAG('u','d','t','a'), mov_read_default },\n{ MKTAG('w','a','v','e'), mov_read_wave },\n{ MKTAG('e','s','d','s'), mov_read_esds },\n{ MKTAG('d','a','c','3'), mov_read_dac3 }, /* AC-3 info */\n{ MKTAG('w','i','d','e'), mov_read_wide }, /* place holder */\n{ MKTAG('w','f','e','x'), mov_read_wfex },\n{ MKTAG('c','m','o','v'), mov_read_cmov },\n{ MKTAG('c','h','a','n'), mov_read_chan }, /* channel layout */\n{ MKTAG('d','v','c','1'), mov_read_dvc1 },\n{ 0, NULL }\n};\n\nstatic int mov_probe(AVProbeData *p)\n{\n    unsigned int offset;\n    uint32_t tag;\n    int score = 0;\n\n    /* check file header */\n    offset = 0;\n    for (;;) {\n        /* ignore invalid offset */\n        if ((offset + 8) > (unsigned int)p->buf_size)\n            return score;\n        tag = AV_RL32(p->buf + offset + 4);\n        switch(tag) {\n        /* check for obvious tags */\n        case MKTAG('j','P',' ',' '): /* jpeg 2000 signature */\n        case MKTAG('m','o','o','v'):\n        case MKTAG('m','d','a','t'):\n        case MKTAG('p','n','o','t'): /* detect movs with preview pics like ew.mov and april.mov */\n        case MKTAG('u','d','t','a'): /* Packet Video PVAuthor adds this and a lot of more junk */\n        case MKTAG('f','t','y','p'):\n            return AVPROBE_SCORE_MAX;\n        /* those are more common words, so rate then a bit less */\n        case MKTAG('e','d','i','w'): /* xdcam files have reverted first tags */\n        case MKTAG('w','i','d','e'):\n        case MKTAG('f','r','e','e'):\n        case MKTAG('j','u','n','k'):\n        case MKTAG('p','i','c','t'):\n            return AVPROBE_SCORE_MAX - 5;\n        case MKTAG(0x82,0x82,0x7f,0x7d):\n        case MKTAG('s','k','i','p'):\n        case MKTAG('u','u','i','d'):\n        case MKTAG('p','r','f','l'):\n            offset = AV_RB32(p->buf+offset) + offset;\n            /* if we only find those cause probedata is too small at least rate them */\n            score = AVPROBE_SCORE_MAX - 50;\n            break;\n        default:\n            /* unrecognized tag */\n            return score;\n        }\n    }\n}\n\n// must be done after parsing all trak because there's no order requirement\nstatic void mov_read_chapters(AVFormatContext *s)\n{\n    MOVContext *mov = s->priv_data;\n    AVStream *st = NULL;\n    MOVStreamContext *sc;\n    int64_t cur_pos;\n    int i;\n\n    for (i = 0; i < s->nb_streams; i++)\n        if (s->streams[i]->id == mov->chapter_track) {\n            st = s->streams[i];\n            break;\n        }\n    if (!st) {\n        av_log(s, AV_LOG_ERROR, \"Referenced QT chapter track not found\\n\");\n        return;\n    }\n\n    st->discard = AVDISCARD_ALL;\n    sc = st->priv_data;\n    cur_pos = avio_tell(sc->pb);\n\n    for (i = 0; i < st->nb_index_entries; i++) {\n        AVIndexEntry *sample = &st->index_entries[i];\n        int64_t end = i+1 < st->nb_index_entries ? st->index_entries[i+1].timestamp : st->duration;\n        uint8_t *title;\n        uint16_t ch;\n        int len, title_len;\n\n        if (avio_seek(sc->pb, sample->pos, SEEK_SET) != sample->pos) {\n            av_log(s, AV_LOG_ERROR, \"Chapter %d not found in file\\n\", i);\n            goto finish;\n        }\n\n        // the first two bytes are the length of the title\n        len = avio_rb16(sc->pb);\n        if (len > sample->size-2)\n            continue;\n        title_len = 2*len + 1;\n        if (!(title = av_mallocz(title_len)))\n            goto finish;\n\n        // The samples could theoretically be in any encoding if there's an encd\n        // atom following, but in practice are only utf-8 or utf-16, distinguished\n        // instead by the presence of a BOM\n        if (!len) {\n            title[0] = 0;\n        } else {\n            ch = avio_rb16(sc->pb);\n            if (ch == 0xfeff)\n                avio_get_str16be(sc->pb, len, title, title_len);\n            else if (ch == 0xfffe)\n                avio_get_str16le(sc->pb, len, title, title_len);\n            else {\n                AV_WB16(title, ch);\n                if (len == 1 || len == 2)\n                    title[len] = 0;\n                else\n                    avio_get_str(sc->pb, INT_MAX, title + 2, len - 1);\n            }\n        }\n\n        avpriv_new_chapter(s, i, st->time_base, sample->timestamp, end, title);\n        av_freep(&title);\n    }\nfinish:\n    avio_seek(sc->pb, cur_pos, SEEK_SET);\n}\n\nstatic int parse_timecode_in_framenum_format(AVFormatContext *s, AVStream *st,\n                                             uint32_t value, int flags)\n{\n    AVTimecode tc;\n    char buf[AV_TIMECODE_STR_SIZE];\n    AVRational rate = {st->codec->time_base.den,\n                       st->codec->time_base.num};\n    int ret = av_timecode_init(&tc, rate, flags, 0, s);\n    if (ret < 0)\n        return ret;\n    av_dict_set(&st->metadata, \"timecode\",\n                av_timecode_make_string(&tc, buf, value), 0);\n    return 0;\n}\n\nstatic int mov_read_timecode_track(AVFormatContext *s, AVStream *st)\n{\n    MOVStreamContext *sc = st->priv_data;\n    int flags = 0;\n    int64_t cur_pos = avio_tell(sc->pb);\n    uint32_t value;\n\n    if (!st->nb_index_entries)\n        return -1;\n\n    avio_seek(sc->pb, st->index_entries->pos, SEEK_SET);\n    value = avio_rb32(s->pb);\n\n    if (sc->tmcd_flags & 0x0001) flags |= AV_TIMECODE_FLAG_DROPFRAME;\n    if (sc->tmcd_flags & 0x0002) flags |= AV_TIMECODE_FLAG_24HOURSMAX;\n    if (sc->tmcd_flags & 0x0004) flags |= AV_TIMECODE_FLAG_ALLOWNEGATIVE;\n\n    /* Assume Counter flag is set to 1 in tmcd track (even though it is likely\n     * not the case) and thus assume \"frame number format\" instead of QT one.\n     * No sample with tmcd track can be found with a QT timecode at the moment,\n     * despite what the tmcd track \"suggests\" (Counter flag set to 0 means QT\n     * format). */\n    parse_timecode_in_framenum_format(s, st, value, flags);\n\n    avio_seek(sc->pb, cur_pos, SEEK_SET);\n    return 0;\n}\n\nstatic int mov_read_close(AVFormatContext *s)\n{\n    MOVContext *mov = s->priv_data;\n    int i, j;\n\n    for (i = 0; i < s->nb_streams; i++) {\n        AVStream *st = s->streams[i];\n        MOVStreamContext *sc = st->priv_data;\n\n        av_freep(&sc->ctts_data);\n        for (j = 0; j < sc->drefs_count; j++) {\n            av_freep(&sc->drefs[j].path);\n            av_freep(&sc->drefs[j].dir);\n        }\n        av_freep(&sc->drefs);\n        if (sc->pb && sc->pb != s->pb)\n            avio_close(sc->pb);\n        sc->pb = NULL;\n        av_freep(&sc->chunk_offsets);\n        av_freep(&sc->keyframes);\n        av_freep(&sc->sample_sizes);\n        av_freep(&sc->stps_data);\n        av_freep(&sc->stsc_data);\n        av_freep(&sc->stts_data);\n    }\n\n    if (mov->dv_demux) {\n        for (i = 0; i < mov->dv_fctx->nb_streams; i++) {\n            av_freep(&mov->dv_fctx->streams[i]->codec);\n            av_freep(&mov->dv_fctx->streams[i]);\n        }\n        av_freep(&mov->dv_fctx);\n        av_freep(&mov->dv_demux);\n    }\n\n    av_freep(&mov->trex_data);\n\n    return 0;\n}\n\nstatic int mov_read_header(AVFormatContext *s)\n{\n    MOVContext *mov = s->priv_data;\n    AVIOContext *pb = s->pb;\n    int err;\n    MOVAtom atom = { AV_RL32(\"root\") };\n\n    mov->fc = s;\n    /* .mov and .mp4 aren't streamable anyway (only progressive download if moov is before mdat) */\n    if (pb->seekable)\n        atom.size = avio_size(pb);\n    else\n        atom.size = INT64_MAX;\n\n    /* check MOV header */\n    if ((err = mov_read_default(mov, pb, atom)) < 0) {\n        av_log(s, AV_LOG_ERROR, \"error reading header: %d\\n\", err);\n        mov_read_close(s);\n        return err;\n    }\n    if (!mov->found_moov) {\n        av_log(s, AV_LOG_ERROR, \"moov atom not found\\n\");\n        mov_read_close(s);\n        return AVERROR_INVALIDDATA;\n    }\n    av_dlog(mov->fc, \"on_parse_exit_offset=%\"PRId64\"\\n\", avio_tell(pb));\n\n    if (pb->seekable) {\n        int i;\n        if (mov->chapter_track > 0)\n            mov_read_chapters(s);\n        for (i = 0; i < s->nb_streams; i++)\n            if (s->streams[i]->codec->codec_tag == AV_RL32(\"tmcd\"))\n                mov_read_timecode_track(s, s->streams[i]);\n    }\n\n    if (mov->trex_data) {\n        int i;\n        for (i = 0; i < s->nb_streams; i++) {\n            AVStream *st = s->streams[i];\n            MOVStreamContext *sc = st->priv_data;\n            if (st->duration)\n                st->codec->bit_rate = sc->data_size * 8 * sc->time_scale / st->duration;\n        }\n    }\n\n    return 0;\n}\n\nstatic AVIndexEntry *mov_find_next_sample(AVFormatContext *s, AVStream **st)\n{\n    AVIndexEntry *sample = NULL;\n    int64_t best_dts = INT64_MAX;\n    int i;\n    for (i = 0; i < s->nb_streams; i++) {\n        AVStream *avst = s->streams[i];\n        MOVStreamContext *msc = avst->priv_data;\n        if (msc->pb && msc->current_sample < avst->nb_index_entries) {\n            AVIndexEntry *current_sample = &avst->index_entries[msc->current_sample];\n            int64_t dts = av_rescale(current_sample->timestamp, AV_TIME_BASE, msc->time_scale);\n            av_dlog(s, \"stream %d, sample %d, dts %\"PRId64\"\\n\", i, msc->current_sample, dts);\n            if (!sample || (!s->pb->seekable && current_sample->pos < sample->pos) ||\n                (s->pb->seekable &&\n                 ((msc->pb != s->pb && dts < best_dts) || (msc->pb == s->pb &&\n                 ((FFABS(best_dts - dts) <= AV_TIME_BASE && current_sample->pos < sample->pos) ||\n                  (FFABS(best_dts - dts) > AV_TIME_BASE && dts < best_dts)))))) {\n                sample = current_sample;\n                best_dts = dts;\n                *st = avst;\n            }\n        }\n    }\n    return sample;\n}\n\nstatic int mov_read_packet(AVFormatContext *s, AVPacket *pkt)\n{\n    MOVContext *mov = s->priv_data;\n    MOVStreamContext *sc;\n    AVIndexEntry *sample;\n    AVStream *st = NULL;\n    int ret;\n    mov->fc = s;\n retry:\n    sample = mov_find_next_sample(s, &st);\n    if (!sample) {\n        mov->found_mdat = 0;\n        if (!mov->next_root_atom)\n            return AVERROR_EOF;\n        avio_seek(s->pb, mov->next_root_atom, SEEK_SET);\n        mov->next_root_atom = 0;\n        if (mov_read_default(mov, s->pb, (MOVAtom){ AV_RL32(\"root\"), INT64_MAX }) < 0 ||\n            url_feof(s->pb))\n            return AVERROR_EOF;\n        av_dlog(s, \"read fragments, offset 0x%\"PRIx64\"\\n\", avio_tell(s->pb));\n        goto retry;\n    }\n    sc = st->priv_data;\n    /* must be done just before reading, to avoid infinite loop on sample */\n    sc->current_sample++;\n\n    if (st->discard != AVDISCARD_ALL) {\n        if (avio_seek(sc->pb, sample->pos, SEEK_SET) != sample->pos) {\n            av_log(mov->fc, AV_LOG_ERROR, \"stream %d, offset 0x%\"PRIx64\": partial file\\n\",\n                   sc->ffindex, sample->pos);\n            return AVERROR_INVALIDDATA;\n        }\n        ret = av_get_packet(sc->pb, pkt, sample->size);\n        if (ret < 0)\n            return ret;\n        if (sc->has_palette) {\n            uint8_t *pal;\n\n            pal = av_packet_new_side_data(pkt, AV_PKT_DATA_PALETTE, AVPALETTE_SIZE);\n            if (!pal) {\n                av_log(mov->fc, AV_LOG_ERROR, \"Cannot append palette to packet\\n\");\n            } else {\n                memcpy(pal, sc->palette, AVPALETTE_SIZE);\n                sc->has_palette = 0;\n            }\n        }\n#if CONFIG_DV_DEMUXER\n        if (mov->dv_demux && sc->dv_audio_container) {\n            avpriv_dv_produce_packet(mov->dv_demux, pkt, pkt->data, pkt->size, pkt->pos);\n            av_free(pkt->data);\n            pkt->size = 0;\n            ret = avpriv_dv_get_packet(mov->dv_demux, pkt);\n            if (ret < 0)\n                return ret;\n        }\n#endif\n    }\n\n    pkt->stream_index = sc->ffindex;\n    pkt->dts = sample->timestamp;\n    if (sc->ctts_data && sc->ctts_index < sc->ctts_count) {\n        pkt->pts = pkt->dts + sc->dts_shift + sc->ctts_data[sc->ctts_index].duration;\n        /* update ctts context */\n        sc->ctts_sample++;\n        if (sc->ctts_index < sc->ctts_count &&\n            sc->ctts_data[sc->ctts_index].count == sc->ctts_sample) {\n            sc->ctts_index++;\n            sc->ctts_sample = 0;\n        }\n        if (sc->wrong_dts)\n            pkt->dts = AV_NOPTS_VALUE;\n    } else {\n        int64_t next_dts = (sc->current_sample < st->nb_index_entries) ?\n            st->index_entries[sc->current_sample].timestamp : st->duration;\n        pkt->duration = next_dts - pkt->dts;\n        pkt->pts = pkt->dts;\n    }\n    if (st->discard == AVDISCARD_ALL)\n        goto retry;\n    pkt->flags |= sample->flags & AVINDEX_KEYFRAME ? AV_PKT_FLAG_KEY : 0;\n    pkt->pos = sample->pos;\n    av_dlog(s, \"stream %d, pts %\"PRId64\", dts %\"PRId64\", pos 0x%\"PRIx64\", duration %d\\n\",\n            pkt->stream_index, pkt->pts, pkt->dts, pkt->pos, pkt->duration);\n    return 0;\n}\n\nstatic int mov_seek_stream(AVFormatContext *s, AVStream *st, int64_t timestamp, int flags)\n{\n    MOVStreamContext *sc = st->priv_data;\n    int sample, time_sample;\n    int i;\n\n    sample = av_index_search_timestamp(st, timestamp, flags);\n    av_dlog(s, \"stream %d, timestamp %\"PRId64\", sample %d\\n\", st->index, timestamp, sample);\n    if (sample < 0 && st->nb_index_entries && timestamp < st->index_entries[0].timestamp)\n        sample = 0;\n    if (sample < 0) /* not sure what to do */\n        return AVERROR_INVALIDDATA;\n    sc->current_sample = sample;\n    av_dlog(s, \"stream %d, found sample %d\\n\", st->index, sc->current_sample);\n    /* adjust ctts index */\n    if (sc->ctts_data) {\n        time_sample = 0;\n        for (i = 0; i < sc->ctts_count; i++) {\n            int next = time_sample + sc->ctts_data[i].count;\n            if (next > sc->current_sample) {\n                sc->ctts_index = i;\n                sc->ctts_sample = sc->current_sample - time_sample;\n                break;\n            }\n            time_sample = next;\n        }\n    }\n    return sample;\n}\n\nstatic int mov_read_seek(AVFormatContext *s, int stream_index, int64_t sample_time, int flags)\n{\n    AVStream *st;\n    int64_t seek_timestamp, timestamp;\n    int sample;\n    int i;\n\n    if (stream_index >= s->nb_streams)\n        return AVERROR_INVALIDDATA;\n    if (sample_time < 0)\n        sample_time = 0;\n\n    st = s->streams[stream_index];\n    sample = mov_seek_stream(s, st, sample_time, flags);\n    if (sample < 0)\n        return sample;\n\n    /* adjust seek timestamp to found sample timestamp */\n    seek_timestamp = st->index_entries[sample].timestamp;\n\n    for (i = 0; i < s->nb_streams; i++) {\n        st = s->streams[i];\n        if (stream_index == i)\n            continue;\n\n        timestamp = av_rescale_q(seek_timestamp, s->streams[stream_index]->time_base, st->time_base);\n        mov_seek_stream(s, st, timestamp, flags);\n    }\n    return 0;\n}\n\nstatic const AVOption options[] = {\n    {\"use_absolute_path\",\n        \"allow using absolute path when opening alias, this is a possible security issue\",\n        offsetof(MOVContext, use_absolute_path), FF_OPT_TYPE_INT, {.dbl = 0},\n        0, 1, AV_OPT_FLAG_VIDEO_PARAM|AV_OPT_FLAG_DECODING_PARAM},\n    {NULL}\n};\nstatic const AVClass class = {\"mov,mp4,m4a,3gp,3g2,mj2\", av_default_item_name, options, LIBAVUTIL_VERSION_INT};\n\n\nAVInputFormat ff_mov_demuxer = {\n    .name           = \"mov,mp4,m4a,3gp,3g2,mj2\",\n    .long_name      = NULL_IF_CONFIG_SMALL(\"QuickTime/MPEG-4/Motion JPEG 2000 format\"),\n    .priv_data_size = sizeof(MOVContext),\n    .read_probe     = mov_probe,\n    .read_header    = mov_read_header,\n    .read_packet    = mov_read_packet,\n    .read_close     = mov_read_close,\n    .read_seek      = mov_read_seek,\n    .priv_class     = &class,\n};\n"], "filenames": ["libavformat/mov.c"], "buggy_code_start_loc": [403], "buggy_code_end_loc": [403], "fixing_code_start_loc": [404], "fixing_code_end_loc": [405], "type": "CWE-119", "message": "The mov_read_dref function in libavformat/mov.c in Libav before 11.7 and FFmpeg before 0.11 allows remote attackers to cause a denial of service (memory corruption) or execute arbitrary code via the entries value in a dref box in an MP4 file.", "other": {"cve": {"id": "CVE-2016-3062", "sourceIdentifier": "cve@mitre.org", "published": "2016-06-16T18:59:08.373", "lastModified": "2018-10-30T16:27:32.030", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The mov_read_dref function in libavformat/mov.c in Libav before 11.7 and FFmpeg before 0.11 allows remote attackers to cause a denial of service (memory corruption) or execute arbitrary code via the entries value in a dref box in an MP4 file."}, {"lang": "es", "value": "La funci\u00f3n mov_read_dref en libavformat/mov.c en Libav en versiones anteriores a 11.7 y FFmpeg en versiones anteriores a 0.11 permite a atacantes remotos provocar una denegaci\u00f3n de srevicio (corrupci\u00f3n de memoria) o ejecutar c\u00f3digo arbitrario a trav\u00e9s de valores de entrada en una caja dref en un archivo MP4."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:libav:libav:*:*:*:*:*:*:*:*", "versionEndIncluding": "11.6", "matchCriteriaId": "49C87D33-61F9-4668-B6F7-EAC88169C48A"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:*:*:*:*:*:*:*:*", "versionEndIncluding": "0.10.15", "matchCriteriaId": "2E92A173-3346-4B06-96CD-B0D06AE0A359"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:*:*:*:*:*:*:*:*", "versionEndIncluding": "8.0", "matchCriteriaId": "A35AC9E8-6666-4AB2-91B7-B77DF2DF48B9"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:42.1:*:*:*:*:*:*:*", "matchCriteriaId": "4863BE36-D16A-4D75-90D9-FD76DB5B48B7"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-updates/2016-06/msg00105.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.debian.org/security/2016/dsa-3603", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://bugzilla.libav.org/show_bug.cgi?id=929", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Vendor Advisory"]}, {"url": "https://ffmpeg.org/security.html", "source": "cve@mitre.org"}, {"url": "https://git.libav.org/?p=libav.git;a=commit;h=7e01d48cfd168c3dfc663f03a3b6a98e0ecba328", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/FFmpeg/FFmpeg/commit/689e59b7ffed34eba6159dcc78e87133862e3746", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://libav.org/releases/libav-11.7.changelog", "source": "cve@mitre.org", "tags": ["Release Notes"]}, {"url": "https://security.gentoo.org/glsa/201705-08", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/FFmpeg/FFmpeg/commit/689e59b7ffed34eba6159dcc78e87133862e3746"}}