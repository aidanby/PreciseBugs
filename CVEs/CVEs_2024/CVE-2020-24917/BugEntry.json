{"buggy_code": ["<?php\n\nif(!defined('INCLUDE_DIR')) die('!');\n\nrequire_once(INCLUDE_DIR.'class.draft.php');\n\nclass DraftAjaxAPI extends AjaxController {\n\n    function _createDraft($vars) {\n        if (false === ($vars['body'] = self::_findDraftBody($_POST)))\n            return JsonDataEncoder::encode(array(\n                'error' => __(\"Draft body not found in request\"),\n                'code' => 422,\n                ));\n\n        if (!($draft = Draft::create($vars)) || !$draft->save())\n            Http::response(500, 'Unable to create draft');\n\n        echo JsonDataEncoder::encode(array(\n            'draft_id' => $draft->getId(),\n        ));\n    }\n\n    function _getDraft($draft) {\n        if (!$draft || !$draft instanceof Draft)\n            Http::response(205, \"Draft not found. Create one first\");\n\n        $body = Format::viewableImages($draft->getBody());\n\n        echo JsonDataEncoder::encode(array(\n            'body' => $body,\n            'draft_id' => $draft->getId(),\n        ));\n    }\n\n    function _updateDraft($draft) {\n        if (false === ($body = self::_findDraftBody($_POST)))\n            return JsonDataEncoder::encode(array(\n                'error' => array(\n                    'message' => \"Draft body not found in request\",\n                    'code' => 422,\n                )\n            ));\n\n        if (!$draft->setBody($body))\n            return Http::response(500, \"Unable to update draft body\");\n\n        echo \"{}\";\n    }\n\n    function _uploadInlineImage($draft) {\n        global $cfg;\n\n        if (!isset($_POST['data']) && !isset($_FILES['file']))\n            Http::response(422, \"File not included properly\");\n\n        # Fixup for expected multiple attachments\n        if (isset($_FILES['file'])) {\n            $file = AttachmentFile::format($_FILES['file']);\n\n            # Allow for data-uri uploaded files\n            $fp = fopen($file[0]['tmp_name'], 'rb');\n            if (fread($fp, 5) == 'data:') {\n                $data = 'data:';\n                while ($block = fread($fp, 8192))\n                  $data .= $block;\n                $file[0] = Format::parseRfc2397($data);\n                list(,$ext) = explode('/', $file[0]['type'], 2);\n                $file[0] += array(\n                    'name' => Misc::randCode(8).'.'.$ext,\n                    'size' => strlen($file[0]['data']),\n                );\n            }\n            fclose($fp);\n\n            # TODO: Detect unacceptable attachment extension\n            # TODO: Verify content-type and check file-content to ensure image\n            $type = $file[0]['type'];\n            if (strpos($file[0]['type'], 'image/') !== 0)\n                return Http::response(403,\n                    JsonDataEncoder::encode(array(\n                        'error' => 'File type is not allowed',\n                    ))\n                );\n\n            # TODO: Verify file size is acceptable\n            if ($file[0]['size'] > $cfg->getMaxFileSize())\n                return Http::response(403,\n                    JsonDataEncoder::encode(array(\n                        'error' => 'File is too large',\n                    ))\n                );\n\n            // Paste uploads in Chrome will have a name of 'blob'\n            if ($file[0]['name'] == 'blob')\n                $file[0]['name'] = 'screenshot-'.Misc::randCode(4);\n\n            $ids = $draft->attachments->upload($file);\n\n            if (!$ids) {\n                if ($file[0]['error']) {\n                    return Http::response(403,\n                        JsonDataEncoder::encode(array(\n                            'error' => $file[0]['error'],\n                        ))\n                    );\n                }\n                else\n                    return Http::response(500, 'Unable to attach image');\n            }\n\n            $id = (is_array($ids)) ? $ids[0] : $ids;\n        }\n        else {\n            $type = explode('/', $_POST['contentType']);\n            $info = array(\n                'data' => base64_decode($_POST['data']),\n                'name' => Misc::randCode(10).'.'.$type[1],\n                // TODO: Ensure _POST['contentType']\n                'type' => $_POST['contentType'],\n            );\n            // TODO: Detect unacceptable filetype\n            // TODO: Verify content-type and check file-content to ensure image\n            $id = $draft->attachments->save($info);\n        }\n        if (!($f = AttachmentFile::lookup($id)))\n            return Http::response(500, 'Unable to attach image');\n\n        echo JsonDataEncoder::encode(array(\n            $f->getName() => array(\n            'content_id' => 'cid:'.$f->getKey(),\n            'id' => $f->getKey(),\n            // Return draft_id to connect the auto draft creation\n            'draft_id' => $draft->getId(),\n            'url' => $f->getDownloadUrl(\n                ['type' => 'D', 'deposition' => 'inline']),\n        )));\n    }\n\n    // Client interface for drafts =======================================\n    function createDraftClient($namespace) {\n        global $thisclient;\n\n        if (!$thisclient && substr($namespace, -12) != substr(session_id(), -12))\n            Http::response(403, \"Valid session required\");\n\n        $vars = array(\n            'namespace' => $namespace,\n        );\n\n        return self::_createDraft($vars);\n    }\n\n    function getDraftClient($namespace) {\n        global $thisclient;\n\n        if ($thisclient) {\n            try {\n                $draft = Draft::lookupByNamespaceAndStaff($namespace,\n                    $thisclient->getId());\n            }\n            catch (DoesNotExist $e) {\n                Http::response(205, \"Draft not found. Create one first\");\n            }\n        }\n        else {\n            if (substr($namespace, -12) != substr(session_id(), -12))\n                Http::response(404, \"Draft not found\");\n            try {\n                $draft = Draft::lookupByNamespaceAndStaff($namespace, 0);\n            }\n            catch (DoesNotExist $e) {\n                Http::response(205, \"Draft not found. Create one first\");\n            }\n        }\n        return self::_getDraft($draft);\n    }\n\n    function updateDraftClient($id) {\n        global $thisclient;\n\n        if (!($draft = Draft::lookup($id)))\n            Http::response(205, \"Draft not found. Create one first\");\n        // Check the owning client-id (for logged-in users), and the\n        // session_id() for others\n        elseif ($thisclient) {\n            if ($draft->getStaffId() != $thisclient->getId())\n                Http::response(404, \"Draft not found\");\n        }\n        else {\n            if (substr(session_id(), -12) != substr($draft->getNamespace(), -12))\n                Http::response(404, \"Draft not found\");\n        }\n\n        return self::_updateDraft($draft);\n    }\n\n    function deleteDraftClient($id) {\n        global $thisclient;\n\n        if (!($draft = Draft::lookup($id)))\n            Http::response(205, \"Draft not found. Create one first\");\n        elseif ($thisclient) {\n            if ($draft->getStaffId() != $thisclient->getId())\n                Http::response(404, \"Draft not found\");\n        }\n        else {\n            if (substr(session_id(), -12) != substr($draft->getNamespace(), -12))\n                Http::response(404, \"Draft not found\");\n        }\n\n        $draft->delete();\n    }\n\n    function uploadInlineImageClient($id) {\n        global $thisclient;\n\n        if (!($draft = Draft::lookup($id)))\n            Http::response(205, \"Draft not found. Create one first\");\n        elseif ($thisclient) {\n            if ($draft->getStaffId() != $thisclient->getId())\n                Http::response(404, \"Draft not found\");\n        }\n        else {\n            if (substr(session_id(), -12) != substr($draft->getNamespace(), -12))\n                Http::response(404, \"Draft not found\");\n        }\n\n        return self::_uploadInlineImage($draft);\n    }\n\n    function uploadInlineImageEarlyClient($namespace) {\n        global $thisclient;\n\n        if (!$thisclient && substr($namespace, -12) != substr(session_id(), -12))\n            Http::response(403, \"Valid session required\");\n\n        $draft = Draft::create(array(\n            'namespace' => $namespace,\n        ));\n        if (!$draft->save())\n            Http::response(500, 'Unable to create draft');\n\n        return $this->uploadInlineImageClient($draft->getId());\n    }\n\n    // Staff interface for drafts ========================================\n    function createDraft($namespace) {\n        global $thisstaff;\n\n        if (!$thisstaff)\n            Http::response(403, \"Login required for draft creation\");\n\n        $vars = array(\n            'namespace' => $namespace,\n        );\n\n        return self::_createDraft($vars);\n    }\n\n    function getDraft($namespace) {\n        global $thisstaff;\n\n        if (!$thisstaff)\n            Http::response(403, \"Login required for draft creation\");\n        try {\n            $draft = Draft::lookupByNamespaceAndStaff($namespace,\n                $thisstaff->getId());\n        }\n        catch (DoesNotExist $e) {\n            Http::response(205, \"Draft not found. Create one first\");\n        }\n\n        return self::_getDraft($draft);\n    }\n\n    function updateDraft($id) {\n        global $thisstaff;\n\n        if (!$thisstaff)\n            Http::response(403, \"Login required for image upload\");\n        elseif (!($draft = Draft::lookup($id)))\n            Http::response(205, \"Draft not found. Create one first\");\n        elseif ($draft->getStaffId() != $thisstaff->getId())\n            Http::response(404, \"Draft not found\");\n\n        return self::_updateDraft($draft);\n    }\n\n    function uploadInlineImage($draft_id) {\n        global $thisstaff;\n\n        if (!$thisstaff)\n            Http::response(403, \"Login required for image upload\");\n        elseif (!($draft = Draft::lookup($draft_id)))\n            Http::response(205, \"Draft not found. Create one first\");\n        elseif ($draft->getStaffId() != $thisstaff->getId())\n            Http::response(404, \"Draft not found\");\n\n        return self::_uploadInlineImage($draft);\n    }\n\n    function uploadInlineImageEarly($namespace) {\n        global $thisstaff;\n\n        if (!$thisstaff)\n            Http::response(403, \"Login required for image upload\");\n\n        $draft = Draft::create(array(\n            'namespace' => $namespace\n        ));\n        if (!$draft->save())\n            Http::response(500, 'Unable to create draft');\n\n        return $this->uploadInlineImage($draft->getId());\n    }\n\n    function deleteDraft($id) {\n        global $thisstaff;\n\n        if (!$thisstaff)\n            Http::response(403, \"Login required for draft edits\");\n        elseif (!($draft = Draft::lookup($id)))\n            Http::response(205, \"Draft not found. Create one first\");\n        elseif ($draft->getStaffId() != $thisstaff->getId())\n            Http::response(404, \"Draft not found\");\n\n        $draft->delete();\n    }\n\n    function getFileList() {\n        global $thisstaff;\n\n        if (!$thisstaff)\n            Http::response(403, \"Login required for file queries\");\n\n        $search = Q::any([\n            Q::all([\n                'attachments__type__in' => array('C', 'F', 'T', 'P'),\n                'attachments__inline' => 1,\n            ]),\n            'ft' => 'L',\n        ]);\n\n        if (isset($_GET['threadId']) && is_numeric($_GET['threadId'])\n            && ($thread = Thread::lookup($_GET['threadId']))\n            && ($object = $thread->getObject())\n            && ($thisstaff->canAccess($object))\n        ) {\n            $search->add(Q::all([\n                'attachments__thread_entry__thread_id' => $_GET['threadId'],\n                'attachments__inline' => 1,\n            ]));\n        }\n\n        $images = AttachmentFile::objects()->filter([\n                $search,\n                'type__startswith' => 'image/',\n            ])->distinct('id');\n\n        $files = array();\n        foreach ($images as $f) {\n            $url = $f->getDownloadUrl();\n            $files[] = array(\n                // Don't send special sizing for thread items 'cause they\n                // should be cached already by the client\n                'thumb' => $url.($f->type != 'H' ? '&s=128' : ''),\n                'url' => $url,\n                'title' => $f->getName(),\n            );\n        }\n        echo JsonDataEncoder::encode($files);\n    }\n\n    function _findDraftBody($vars) {\n        if (isset($vars['name'])) {\n            $parts = array();\n            // Support nested `name`, like trans[lang]\n            if (preg_match('`(\\w+)(?:\\[(\\w+)\\])?(?:\\[(\\w+)\\])?`', $_POST['name'], $parts)) {\n                array_shift($parts);\n                $focus = $vars;\n                foreach ($parts as $p)\n                    $focus = $focus[$p];\n                return $focus;\n            }\n        }\n        $field_list = array('response', 'note', 'answer', 'body',\n             'message', 'issue', 'description');\n        foreach ($field_list as $field) {\n            if (isset($vars[$field])) {\n                return $vars[$field];\n            }\n        }\n\n        return false;\n    }\n\n}\n?>\n", "<?php\n\nrequire_once(INCLUDE_DIR . 'class.topic.php');\nrequire_once(INCLUDE_DIR . 'class.dynamic_forms.php');\nrequire_once(INCLUDE_DIR . 'class.forms.php');\n\nclass DynamicFormsAjaxAPI extends AjaxController {\n    function getForm($form_id) {\n        $form = DynamicForm::lookup($form_id);\n        if (!$form) return;\n\n        foreach ($form->getFields() as $field) {\n            $field->render();\n        }\n    }\n\n    function getFormsForHelpTopic($topic_id, $client=false) {\n        if (!$_SERVER['HTTP_REFERER'])\n            Http::response(403, 'Forbidden.');\n\n        if (!($topic = Topic::lookup($topic_id)))\n            Http::response(404, 'No such help topic');\n\n        if ($_GET || isset($_SESSION[':form-data'])) {\n            if (!is_array($_SESSION[':form-data']))\n                $_SESSION[':form-data'] = array();\n            $_SESSION[':form-data'] = array_merge($_SESSION[':form-data'],\n                    Format::htmlchars($_GET));\n        }\n\n        foreach ($topic->getForms() as $form) {\n            if (!$form->hasAnyVisibleFields())\n                continue;\n            ob_start();\n            $form->getForm($_SESSION[':form-data'])->render(array(\n                'staff' => !$client,\n                'mode' => 'create'));\n            $html .= ob_get_clean();\n            ob_start();\n            print $form->getMedia();\n            $media .= ob_get_clean();\n        }\n        return $this->encode(array(\n            'media' => $media,\n            'html' => $html,\n        ));\n    }\n\n    function getClientFormsForHelpTopic($topic_id) {\n        return $this->getFormsForHelpTopic($topic_id, true);\n    }\n\n    function getFieldConfiguration($field_id) {\n        $field = DynamicFormField::lookup($field_id);\n        include(STAFFINC_DIR . 'templates/dynamic-field-config.tmpl.php');\n    }\n\n    function saveFieldConfiguration($field_id) {\n\n        if (!($field = DynamicFormField::lookup($field_id)))\n            Http::response(404, 'No such field');\n\n        $DFF = 'DynamicFormField';\n\n        // Capture flags which should remain unchanged\n        $p_mask = $DFF::MASK_MASK_ALL;\n        if ($field->isPrivacyForced()) {\n            $p_mask |= $DFF::FLAG_CLIENT_VIEW | $DFF::FLAG_AGENT_VIEW;\n        }\n        if ($field->isRequirementForced()) {\n            $p_mask |= $DFF::FLAG_CLIENT_REQUIRED | $DFF::FLAG_AGENT_REQUIRED;\n        }\n        if ($field->hasFlag($DFF::FLAG_MASK_DISABLE)) {\n            $p_mask |= $DFF::FLAG_ENABLED;\n        }\n\n        // Capture current state of immutable flags\n        $preserve = $field->flags & $p_mask;\n\n        // Set admin-configured flag states\n        $flags = array_reduce($_POST['flags'] ?: array(),\n            function($a, $b) { return $a | $b; }, 0);\n        $field->flags = $flags | $preserve;\n\n        if ($field->setConfiguration($_POST)) {\n            $field->save();\n            Http::response(201, 'Field successfully updated');\n        }\n\n        include STAFFINC_DIR . 'templates/dynamic-field-config.tmpl.php';\n    }\n\n    function deleteAnswer($entry_id, $field_id) {\n        global $thisstaff;\n\n        if (!$thisstaff)\n            Http::response(403, 'Login required');\n\n        $ent = DynamicFormEntryAnswer::lookup(array(\n            'entry_id'=>$entry_id, 'field_id'=>$field_id));\n        if (!$ent)\n            Http::response(404, 'Answer not found');\n\n        $ent->delete();\n    }\n\n\n    function getListItem($list_id, $item_id) {\n\n        $list = DynamicList::lookup($list_id);\n        if (!$list)\n            Http::response(404, 'No such list item');\n\n        $list = CustomListHandler::forList($list);\n        if (!($item = $list->getItem( (int) $item_id)))\n            Http::response(404, 'No such list item');\n\n        $action = \"#list/{$list->getId()}/item/{$item->getId()}/update\";\n        $item_form = $list->getListItemBasicForm($item->ht, $item);\n\n        include(STAFFINC_DIR . 'templates/list-item-properties.tmpl.php');\n    }\n\n    function getListItems($list_id) {\n        global $thisstaff;\n\n        if (!$thisstaff)\n            Http::response(403, 'Login required');\n\n        if (!($list = DynamicList::lookup($list_id)))\n            Http::response(404, 'No such list');\n\n        $pjax_container = '#items';\n        include(STAFFINC_DIR . 'templates/list-items.tmpl.php');\n    }\n\n    function previewListItem($list_id, $item_id) {\n\n        $list = DynamicList::lookup($list_id);\n        if (!$list)\n            Http::response(404, 'No such list item');\n\n        $list = CustomListHandler::forList($list);\n        if (!($item = $list->getItem( (int) $item_id)))\n            Http::response(404, 'No such list item');\n\n        $form = $list->getListItemBasicForm($item->ht, $item);\n        include(STAFFINC_DIR . 'templates/list-item-preview.tmpl.php');\n    }\n\n    function saveListItem($list_id, $item_id) {\n        global $thisstaff;\n\n        $errors = array();\n\n        if (!$thisstaff)\n            Http::response(403, 'Login required');\n\n        $list = DynamicList::lookup($list_id);\n        if (!$list)\n            Http::response(404, 'No such list item');\n\n        $list = CustomListHandler::forList($list);\n        if (!$list || !($item = $list->getItem( (int) $item_id)))\n            Http::response(404, 'No such list item');\n\n        $item_form = $list->getListItemBasicForm($_POST, $item);\n\n        if ($valid = $item_form->isValid()) {\n            if ($_item = DynamicListItem::lookup(array(\n                'list_id' => $list->getId(), 'value'=>$item->getValue()))\n            ) {\n                if ($_item && $_item->id != $item->id)\n                    $item_form->getField('value')->addError(\n                        __('Value already in use'));\n            }\n            if ($item_form->isValid()) {\n                // Update basic information\n                $basic = $item_form->getClean();\n                $item->update([\n                    'name' =>   $basic['name'],\n                    'value' =>  $basic['value'],\n                    'abbrev' =>  $basic['extra'],\n                ], $errors);\n            }\n        }\n\n        // Context\n        $action = \"#list/{$list->getId()}/item/{$item->getId()}/update\";\n        $icon = ($list->get('sort_mode') == 'SortCol')\n            ? '<i class=\"icon-sort\"></i>&nbsp;' : '';\n\n        if (!$valid || !$item->setConfiguration($_POST)) {\n            include STAFFINC_DIR . 'templates/list-item-properties.tmpl.php';\n            return;\n        }\n        else {\n            $item->save();\n        }\n\n        Http::response(201, $this->encode(array(\n            'id' => $item->getId(),\n            'row' => $this->_renderListItem($item, $list),\n            'success' => true,\n        )));\n    }\n\n    function _renderListItem($item, $list=false) {\n        $list = $list ?: $item->getList();\n\n        // Send the whole row back\n        $prop_fields = $list->getSummaryFields();\n        $icon = ($list->get('sort_mode') == 'SortCol')\n            ? '<i class=\"icon-sort\"></i>&nbsp;' : '';\n        ob_start();\n        $item->_config = null;\n        include STAFFINC_DIR . 'templates/list-item-row.tmpl.php';\n        return ob_get_clean();\n    }\n\n    function searchListItems($list_id) {\n        global $thisstaff;\n\n        if (!$thisstaff)\n            Http::response(403, 'Login required');\n        elseif (!($list = DynamicList::lookup($list_id)))\n            Http::response(404, 'No such list');\n        elseif (!($q = $_GET['q']))\n            Http::response(400, '\"q\" query arg is required');\n\n        $list = CustomListHandler::forList($list);\n        $items = $list->search($q);\n\n        $results = array();\n        foreach ($items as $I) {\n            $display = $I->getValue();\n            if (isset($I->extra))\n              $display .= \" ({$I->extra})\";\n            $results[] = array(\n                'value' => $I->getValue(),\n                'display' => $display,\n                'id' => $I->id,\n                'list_id' => $list->getId(),\n            );\n        }\n        return $this->encode($results);\n    }\n\n    function addListItem($list_id) {\n        global $thisstaff;\n\n        if (!$thisstaff)\n            Http::response(403, 'Login required');\n        elseif (!($list = DynamicList::lookup($list_id)))\n            Http::response(404, 'No such list');\n\n        $list = CustomListHandler::forList($list);\n        $action = \"#list/{$list->getId()}/item/add\";\n        $item_form = $list->getListItemBasicForm($_POST ?: null);\n        $errors = array();\n\n        if ($_POST && ($valid = $item_form->isValid())) {\n            $data = $item_form->getClean();\n            if ($list->isItemUnique($data)) {\n                $item = $list->addItem($data, $errors);\n                if ($item->setConfiguration($_POST, $errors)) {\n                    Http::response(201, $this->encode(array(\n                        'success' => true,\n                        'row' => $this->_renderListItem($item, $list)\n                    )));\n                }\n            }\n            else {\n                $item_form->getField('value')->addError(\n                    __('Value already in use'));\n            }\n        }\n\n        include(STAFFINC_DIR . 'templates/list-item-properties.tmpl.php');\n    }\n\n    function importListItems($list_id) {\n        global $thisstaff;\n\n        if (!$thisstaff)\n            Http::response(403, 'Login required');\n        elseif (!($list = DynamicList::lookup($list_id)))\n            Http::response(404, 'No such list');\n\n        $list = CustomListHandler::forList($list);\n        $info = array(\n            'title' => sprintf('%s &mdash; %s',\n                $list->getName(), __('Import Items')),\n            'action' => \"#list/{$list_id}/import\",\n            'upload_url' => \"lists.php?id={$list_id}&amp;do=import-items\",\n        );\n\n        if ($_POST) {\n            $status = $list->importFromPost($_FILES['import'] ?: $_POST['pasted']);\n            if ($status && is_numeric($status))\n                Http::response(201, $this->encode( array('success' => true, 'count' => $status)));\n\n            $info['error'] = $status;\n            $info['pasted'] = Format::htmlchars($_POST['pasted']);\n        }\n\n        include(STAFFINC_DIR . 'templates/list-import.tmpl.php');\n    }\n\n    function disableItems($list_id) {\n        global $thisstaff;\n\n        if (!$thisstaff)\n            Http::response(403, 'Login required');\n        elseif (!($list = DynamicList::lookup($list_id)))\n            Http::response(404, 'No such list');\n        elseif (!$_POST['ids'])\n            Http::response(422, 'Send `ids` parameter');\n\n        $list = CustomListHandler::forList($list);\n        foreach ($_POST['ids'] as $id) {\n            if ($item = $list->getItem( (int) $id)) {\n                $item->disable();\n                $item->save();\n            }\n            else {\n                Http::response(404, 'No such list item');\n            }\n        }\n        Http::response(200, $this->encode(array('success' => true)));\n    }\n\n    function undisableItems($list_id) {\n        global $thisstaff;\n\n        if (!$thisstaff)\n            Http::response(403, 'Login required');\n        elseif (!($list = DynamicList::lookup($list_id)))\n            Http::response(404, 'No such list');\n        elseif (!$_POST['ids'])\n            Http::response(422, 'Send `ids` parameter');\n\n        $list = CustomListHandler::forList($list);\n        foreach ($_POST['ids'] as $id) {\n            if ($item = $list->getItem( (int) $id)) {\n                $item->enable();\n                $item->save();\n            }\n            else {\n                Http::response(404, 'No such list item');\n            }\n        }\n        Http::response(200, $this->encode(array('success' => true)));\n    }\n\n    function deleteItems($list_id) {\n        global $thisstaff;\n\n        if (!$thisstaff)\n            Http::response(403, 'Login required');\n        elseif (!($list = DynamicList::lookup($list_id)))\n            Http::response(404, 'No such list');\n        elseif (!$_POST['ids'])\n            Http::response(422, 'Send `ids` parameter');\n\n        foreach ($_POST['ids'] as $id) {\n            if ($item = $list->getItem( (int) $id)) {\n                $item->delete();\n            }\n            else {\n                Http::response(404, 'No such list item');\n            }\n        }\n        Http::response(200, $this->encode(array('success' => true)));\n    }\n\n    function upload($id) {\n        if (!$field = DynamicFormField::lookup($id))\n            Http::response(400, 'No such field');\n\n        $impl = $field->getImpl();\n        if (!$impl instanceof FileUploadField)\n            Http::response(400, 'Upload to a non file-field');\n\n        return JsonDataEncoder::encode(\n            array('id'=>$impl->ajaxUpload())\n        );\n    }\n\n    function attach($object=null) {\n        global $thisstaff;\n\n        $filter = array('type__contains'=>'thread');\n        // Determine if for Ticket/Task/Custom\n        if ($object && is_string($object)) {\n            if ($object == 'ticket')\n                $filter['form_id'] = TicketForm::objects()->one()->id;\n            elseif ($object == 'task')\n                $filter['form_id'] = TaskForm::objects()->one()->id;\n        }\n        $config = DynamicFormField::objects()\n            ->filter($filter)\n            ->order_by('id')\n            ->first()->getConfiguration();\n        $field = new FileUploadField();\n        $field->_config = $config;\n        return JsonDataEncoder::encode(\n            array('id'=>$field->ajaxUpload($thisstaff ? true : false))\n        );\n    }\n\n    function getAllFields($id) {\n        global $thisstaff;\n\n        if (!$thisstaff)\n            Http::response(403, 'Login required');\n        elseif (!$form = DynamicForm::lookup($id))\n            Http::response(400, 'No such form');\n\n        // XXX: Fetch the form via the list!\n        ob_start();\n        include STAFFINC_DIR . 'templates/dynamic-form-fields-view.tmpl.php';\n        $html = ob_get_clean();\n\n        return $this->encode(array(\n            'success'=>true,\n            'html' => $html,\n        ));\n    }\n}\n?>\n", "<?php\n/*********************************************************************\n    ajax.i18n.php\n\n    Callbacks to get internaltionalized pieces for osticket\n\n    Peter Rotich <peter@osticket.com>\n    Jared Hancock <jared@osticket.com>\n    Copyright (c)  2006-2014 osTicket\n    http://www.osticket.com\n\n    Released under the GNU General Public License WITHOUT ANY WARRANTY.\n    See LICENSE.TXT for details.\n\n    vim: expandtab sw=4 ts=4 sts=4:\n**********************************************************************/\n\nif(!defined('INCLUDE_DIR')) die('!');\n\nclass i18nAjaxAPI extends AjaxController {\n    function getLanguageFile($lang, $key) {\n        global $cfg;\n\n        $i18n = new Internationalization($lang);\n        switch ($key) {\n        case 'js':\n            $data = $i18n->getTemplate('js/redactor.js')->getRawData();\n            $data .= $i18n->getTemplate('js/jquery.ui.datepicker.js')->getRawData();\n            // Strings from various javascript files\n            $data .= $i18n->getTemplate('js/osticket-strings.js')->getRawData();\n            header('Content-Type: text/javascript; charset=UTF-8');\n            break;\n        default:\n            Http::response(404, 'No such i18n data');\n        }\n\n        Http::cacheable(md5($data), $cfg->lastModified());\n        echo $data;\n    }\n\n    function getTranslations($tag) {\n        $t = CustomDataTranslation::allTranslations($tag);\n        $phrases = array();\n        $lm = 0;\n        foreach ($t as $translation) {\n            $phrases[$translation->lang] = $translation->text;\n            $lm = max($lm, strtotime($translation->updated));\n        }\n        $json = JsonDataEncoder::encode($phrases) ?: '{}';\n        //Http::cacheable(md5($json), $lm);\n\n        return $json;\n    }\n\n    function updateTranslations($tag) {\n        global $thisstaff, $cfg;\n\n        if (!$thisstaff)\n            Http::response(403, \"Agent login required\");\n        if (!$_POST)\n            Http::response(422, \"No translations found to update\");\n\n        $t = CustomDataTranslation::allTranslations($tag);\n        $phrases = array();\n        foreach ($t as $translation) {\n            $phrases[$translation->lang] = $translation;\n        }\n        foreach ($_POST as $lang => $phrase) {\n            if (isset($phrases[$lang])) {\n                $p = $phrases[$lang];\n                if (!$phrase) {\n                    $p->delete();\n                }\n                else {\n                    // Avoid XSS injection\n                    $p->text = trim(Format::sanitize($phrase));\n                    $p->agent_id = $thisstaff->getId();\n                }\n            }\n            elseif (in_array($lang, $cfg->getSecondaryLanguages())) {\n                if (!$phrase)\n                    continue;\n                $phrases[$lang] = CustomDataTranslation::create(array(\n                    'lang'          => $lang,\n                    'text'          => $phrase,\n                    'object_hash'   => $tag,\n                    'type'          => 'phrase',\n                    'agent_id'      => $thisstaff->getId(),\n                    'updated'       => new SqlFunction('NOW'),\n                ));\n            }\n            else {\n                Http::response(400,\n                    sprintf(\"%s: Must be a secondary language\", $lang));\n            }\n        }\n        // Commit.\n        foreach ($phrases as $p)\n            if (!$p->save())\n                Http::response(500, sprintf(\"%s: Unable to commit language\"));\n    }\n\n    function getConfiguredLanguages() {\n        global $cfg;\n\n        $primary = $cfg->getPrimaryLanguage();\n        $info = Internationalization::getLanguageInfo($primary);\n        $langs = array(\n            $primary => array(\n                'name' => Internationalization::getLanguageDescription($primary),\n                'flag' => strtolower($info['flag']),\n                'direction' => $info['direction'] ?: 'ltr',\n            ),\n        );\n\n        foreach ($cfg->getSecondaryLanguages() as $l) {\n            $info = Internationalization::getLanguageInfo($l);\n            $langs[$l] = array(\n                'name' => Internationalization::getLanguageDescription($l),\n                'flag' => strtolower($info['flag']),\n                'direction' => $info['direction'] ?: 'ltr',\n            );\n        }\n        $json = JsonDataEncoder::encode($langs);\n        Http::cacheable(md5($json), $cfg->lastModified());\n\n        return $json;\n    }\n\n    function getSecondaryLanguages() {\n        global $cfg;\n\n        $langs = array();\n        foreach ($cfg->getSecondaryLanguages() as $l) {\n            $info = Internationalization::getLanguageInfo($l);\n            $langs[$l] = array(\n                'name' => Internationalization::getLanguageDescription($l),\n                'flag' => strtolower($info['flag']),\n                'direction' => $info['direction'] ?: 'ltr',\n            );\n        }\n        $json = JsonDataEncoder::encode($langs);\n        Http::cacheable(md5($json), $cfg->lastModified());\n\n        return $json;\n    }\n}\n?>\n", "<?php\n/*********************************************************************\n    class.file.php\n\n    Peter Rotich <peter@osticket.com>\n    Copyright (c)  2006-2013 osTicket\n    http://www.osticket.com\n\n    Released under the GNU General Public License WITHOUT ANY WARRANTY.\n    See LICENSE.TXT for details.\n\n    vim: expandtab sw=4 ts=4 sts=4:\n**********************************************************************/\nrequire_once(INCLUDE_DIR.'class.signal.php');\nrequire_once(INCLUDE_DIR.'class.error.php');\n\n\n/**\n * Represents a file stored in a storage backend. It is generally attached\n * to something; however company logos, login page backdrops, and other\n * items are also stored in the database for various purposes.\n *\n * FileType-Definitions:\n *    The `ft` field is used to represent the type or purpose of the file\n *    with respect to the system. These are the defined file types (placed\n *    here as the definitions are not needed in code).\n *\n *    - 'T' => Attachments\n *    - 'L' => Logo\n *    - 'B' => Backdrop\n */\nclass AttachmentFile extends VerySimpleModel {\n\n    static $meta = array(\n        'table' => FILE_TABLE,\n        'pk' => array('id'),\n        'joins' => array(\n            'attachments' => array(\n                'reverse' => 'Attachment.file'\n            ),\n        ),\n    );\n    static $keyCache = array();\n\n    function __onload() {\n        // Cache for lookup in the ::lookupByHash method below\n        static::$keyCache[$this->key] = $this;\n    }\n\n    function getHashtable() {\n        return $this->ht;\n    }\n\n    function getInfo() {\n        return $this->getHashtable();\n    }\n\n    function getNumEntries() {\n        return $this->attachments->count();\n    }\n\n    function isCanned() {\n        return $this->getNumEntries();\n    }\n\n    function isInUse() {\n        return $this->getNumEntries();\n    }\n\n    function getId() {\n        return $this->id;\n    }\n\n    function getType() {\n        return $this->type;\n    }\n\n    function getMimeType() {\n        return $this->getType();\n    }\n\n    function getBackend() {\n        return $this->bk;\n    }\n\n    function getSize() {\n        return $this->size;\n    }\n\n    function getName() {\n        return $this->name;\n    }\n\n    function getKey() {\n        return $this->key;\n    }\n\n    function getSignature($cascade=false) {\n        $sig = $this->signature;\n        if (!$sig && $cascade) return $this->getKey();\n        return $sig;\n    }\n\n    function lastModified() {\n        return $this->created;\n    }\n\n    function open() {\n        return FileStorageBackend::getInstance($this);\n    }\n\n    function sendData($redirect=true, $disposition='inline') {\n        $bk = $this->open();\n        if ($redirect && $bk->sendRedirectUrl($disposition))\n            return;\n\n        @ini_set('zlib.output_compression', 'Off');\n        try {\n            $bk->passthru();\n        }\n        catch (IOException $ex) {\n            Http::response(404, 'File not found');\n        }\n    }\n\n    function getData() {\n        # XXX: This is horrible, and is subject to php's memory\n        #      restrictions, etc. Don't use this function!\n        ob_start();\n        try {\n            $this->sendData(false);\n        }\n        catch (IOException $ex) {\n            Http::response(404, 'File not found');\n        }\n        $data = &ob_get_contents();\n        ob_end_clean();\n        return $data;\n    }\n\n    function delete() {\n\n        if (!parent::delete())\n            return false;\n\n        if ($bk = $this->open())\n            $bk->unlink();\n\n        return true;\n    }\n\n    function makeCacheable($ttl=86400) {\n        Http::cacheable($this->getSignature(true), $this->lastModified(), $ttl);\n    }\n\n    function display($scale=false) {\n        $this->makeCacheable();\n\n        if ($scale && extension_loaded('gd')) {\n            $image = imagecreatefromstring($this->getData());\n            $width = imagesx($image);\n            if ($scale <= $width) {\n                $height = imagesy($image);\n                if ($width > $height) {\n                    $heightp = $height * (int)$scale / $width;\n                    $widthp = $scale;\n                } else {\n                    $widthp = $width * (int)$scale / $height;\n                    $heightp = $scale;\n                }\n                $thumb = imagecreatetruecolor($widthp, $heightp);\n                $white = imagecolorallocate($thumb, 255,255,255);\n                imagefill($thumb, 0, 0, $white);\n                imagecopyresized($thumb, $image, 0, 0, 0, 0, $widthp,\n                    $heightp, $width, $height);\n                header('Content-Type: image/png');\n                imagepng($thumb);\n                return;\n            }\n        }\n        header('Content-Type: '.($this->getType()?$this->getType():'application/octet-stream'));\n        header('Content-Length: '.$this->getSize());\n        $this->sendData();\n        exit();\n    }\n\n    function getDownloadUrl($options=array()) {\n        // Add attachment ref id if object type is set\n        if (isset($options['type'])\n                && !isset($options['id'])\n                && ($a=$this->attachments->findFirst(array(\n                            'type' => $options['type']))))\n            $options['id'] = $a->getId();\n\n        return static::generateDownloadUrl($this->getId(),\n                strtolower($this->getKey()), $this->getSignature(),\n                $options);\n    }\n\n    // Generates full download URL for external sources.\n    // e.g. https://domain.tld/file.php?args=123\n    function getExternalDownloadUrl($options=array()) {\n        global $cfg;\n\n        $download = self::getDownloadUrl($options);\n        // Separate URL handle and args\n        list($handle, $args) = explode('file.php?', $download);\n\n        return (string) rtrim($cfg->getBaseUrl(), '/').'/file.php?'.$args;\n    }\n\n    static function generateDownloadUrl($id, $key, $hash, $options = array()) {\n\n        // Expire at the nearest midnight, allow at least12 hrs access\n        $minage = @$options['minage'] ?: 43200;\n        $gmnow = Misc::gmtime() +  $options['minage'];\n        $expires = $gmnow + 86400 - ($gmnow % 86400);\n\n        // Generate a signature based on secret content\n        $signature = static::_genUrlSignature($id, $key, $hash, $expires);\n\n        // Handler / base url\n        $handler = @$options['handler'] ?: ROOT_PATH . 'file.php';\n\n        // Return sanitized query string\n        $args = array(\n            'key' => $key,\n            'expires' => $expires,\n            'signature' => $signature,\n        );\n\n        if (isset($options['disposition']))\n            $args['disposition'] =  $options['disposition'];\n\n        if (isset($options['id']))\n            $args['id'] =  $options['id'];\n\n        return sprintf('%s?%s', $handler, http_build_query($args));\n    }\n\n    function verifySignature($signature, $expires) {\n        $gmnow = Misc::gmtime();\n        if ($expires < $gmnow)\n            return false;\n\n        $check = static::_genUrlSignature($this->getId(), $this->getKey(),\n            $this->getSignature(), $expires);\n        return $signature == $check;\n    }\n\n    static function _genUrlSignature($id, $key, $signature, $expires) {\n        $pieces = array(\n            'Host='.$_SERVER['HTTP_HOST'],\n            'Path='.ROOT_PATH,\n            'Id='.$id,\n            'Key='.strtolower($key),\n            'Hash='.$signature,\n            'Expires='.$expires,\n        );\n        return hash_hmac('sha1', implode(\"\\n\", $pieces), SECRET_SALT);\n    }\n\n    function download($name=false, $disposition=false, $expires=false) {\n        $thisstaff = StaffAuthenticationBackend::getUser();\n        $inline = ($thisstaff ? ($thisstaff->getImageAttachmentView() === 'inline') : false);\n        $disposition = ((($disposition && strcasecmp($disposition, 'inline') == 0)\n              || $inline)\n              && strpos($this->getType(), 'image/') !== false)\n            ? 'inline' : 'attachment';\n        $bk = $this->open();\n        if ($bk->sendRedirectUrl($disposition))\n            return;\n        $ttl = ($expires) ? $expires - Misc::gmtime() : false;\n        $this->makeCacheable($ttl);\n        $type = $this->getType() ?: 'application/octet-stream';\n        Http::download($name ?: $this->getName(), $type, null, $disposition);\n        header('Content-Length: '.$this->getSize());\n        $this->sendData(false);\n        exit();\n    }\n\n    function _getKeyAndHash($data=false, $file=false) {\n        if ($file) {\n            $sha1 = base64_encode(sha1_file($data, true));\n            $md5 = base64_encode(md5_file($data, true));\n        }\n        else {\n            $sha1 = base64_encode(sha1($data, true));\n            $md5 = base64_encode(md5($data, true));\n        }\n\n        // Use 5 chars from the microtime() prefix and 27 chars from the\n        // sha1 hash. This should make a sufficiently strong unique key for\n        // file content. In the event there is a sha1 collision for data, it\n        // should be unlikely that there will be a collision for the\n        // microtime hash coincidently.  Remove =, change + and / to chars\n        // better suited for URLs and filesystem paths\n        $prefix = base64_encode(sha1(microtime(), true));\n        $key = str_replace(\n            array('=','+','/'),\n            array('','-','_'),\n            substr($prefix, 0, 5) . $sha1);\n\n        // The hash is a 32-char value where the first half is from the last\n        // 16 chars from the SHA1 hash and the last 16 chars are the last 16\n        // chars from the MD5 hash. This should provide for better\n        // resiliance against hash collisions and attacks against any one\n        // hash algorithm. Since we're using base64 encoding, with 6-bits\n        // per char, we should have a total hash strength of 192 bits.\n        $hash = str_replace(\n            array('=','+','/'),\n            array('','-','_'),\n            substr($sha1, 0, 16) . substr($md5, 0, 16));\n\n        return array($key, $hash);\n    }\n\n    /* Function assumes the files types have been validated */\n    static function upload($file, $ft='T', $deduplicate=true) {\n\n        if(!$file['name'] || $file['error'] || !is_uploaded_file($file['tmp_name']))\n            return false;\n\n        list($key, $sig) = self::_getKeyAndHash($file['tmp_name'], true);\n\n        $info=array('type'=>$file['type'],\n                    'filetype'=>$ft,\n                    'size'=>$file['size'],\n                    'name'=>$file['name'],\n                    'key'=>$key,\n                    'signature'=>$sig,\n                    'tmp_name'=>$file['tmp_name'],\n                    );\n\n        return static::create($info, $ft, $deduplicate);\n    }\n\n    static function uploadBackdrop(array $file, &$error) {\n        if (extension_loaded('gd')) {\n            $source_path = $file['tmp_name'];\n            list($source_width, $source_height, $source_type) = getimagesize($source_path);\n\n            switch ($source_type) {\n                case IMAGETYPE_GIF:\n                case IMAGETYPE_JPEG:\n                case IMAGETYPE_PNG:\n                    break;\n                default:\n                    $error = __('Invalid image file type');\n                    return false;\n            }\n        }\n        return self::upload($file, 'B', false);\n    }\n\n    static function uploadLogo($file, &$error, $aspect_ratio=2) {\n        /* Borrowed in part from\n         * http://salman-w.blogspot.com/2009/04/crop-to-fit-image-using-aspphp.html\n         */\n        if (extension_loaded('gd')) {\n            $source_path = $file['tmp_name'];\n            list($source_width, $source_height, $source_type) = getimagesize($source_path);\n\n            switch ($source_type) {\n                case IMAGETYPE_GIF:\n                case IMAGETYPE_JPEG:\n                case IMAGETYPE_PNG:\n                    break;\n                default:\n                    $error = __('Invalid image file type');\n                    return false;\n            }\n\n            $source_aspect_ratio = $source_width / $source_height;\n\n            if ($source_aspect_ratio < $aspect_ratio) {\n                $error = __('Image is too square. Upload a wider image');\n                return false;\n            }\n        }\n        return self::upload($file, 'L', false);\n    }\n\n    static function create(&$file, $ft='T', $deduplicate=true) {\n        if (isset($file['encoding'])) {\n            switch ($file['encoding']) {\n            case 'base64':\n                $file['data'] = base64_decode($file['data']);\n            }\n        }\n\n        if (!isset($file['data']) && isset($file['data_cbk'])\n                && is_callable($file['data_cbk'])) {\n            // Allow a callback function to delay or avoid reading or\n            // fetching ihe file contents\n            $file['data'] = $file['data_cbk']();\n        }\n\n        if (isset($file['data'])) {\n            list($key, $file['signature'])\n                = self::_getKeyAndHash($file['data']);\n            if (!$file['key'])\n                $file['key'] = $key;\n        }\n\n        if (isset($file['size']) && $file['size'] > 0) {\n            // Check and see if the file is already on record\n            $existing = static::objects()->filter(array(\n                'signature' => $file['signature'],\n                'size' => $file['size']\n            ))->first();\n\n            // If the record exists in the database already, a file with\n            // the same hash and size is already on file -- just return\n            // the file\n            if ($deduplicate && $existing) {\n                $file['key'] = $existing->key;\n                return $existing;\n            }\n        }\n        elseif (!isset($file['data'])) {\n            // Unable to determine the file's size\n            return false;\n        }\n\n        if (!$file['type'] && extension_loaded('fileinfo')) {\n            $finfo = new finfo(FILEINFO_MIME_TYPE);\n            if ($file['data'])\n                $type = $finfo->buffer($file['data']);\n            elseif ($file['tmp_name'])\n                $type = $finfo->file($file['tmp_name']);\n\n            if ($type)\n                $file['type'] = $type;\n        }\n        if (!$file['type'])\n            $file['type'] = 'application/octet-stream';\n\n\n        $f = new static(array(\n            'type' => strtolower($file['type']),\n            'name' => $file['name'],\n            'key' => $file['key'],\n            'ft' => $ft ?: 'T',\n            'signature' => $file['signature'],\n            'created' => SqlFunction::NOW(),\n        ));\n\n        if (isset($file['size']))\n            $f->size = $file['size'];\n\n        if (!$f->save())\n            return false;\n\n        // Note that this is preferred over $f->open() because the file does\n        // not have a valid backend configured yet. ::getBackendForFile()\n        // will consider the system configuration for storing the file\n        $bks = array(self::getBackendForFile($f));\n        if (!$bks[0]->getBkChar() !== 'D')\n            $bks[] = new AttachmentChunkedData($f);\n\n        // Consider the selected backen first and then save to database\n        // otherwise.\n        $succeeded = false;\n        foreach ($bks as $bk) {\n            try {\n                if (isset($file['tmp_name'])) {\n                    if ($bk->upload($file['tmp_name'])) {\n                        $succeeded = true; break;\n                    }\n                }\n                elseif ($bk->write($file['data']) && $bk->flush()) {\n                    $succeeded = true; break;\n                }\n            }\n            catch (Exception $e) {\n                // Try next backend\n            }\n            // Fallthrough to default backend if different?\n        }\n        if (!$succeeded) {\n            // Unable to save data (weird)\n            return false;\n        }\n\n        $f->bk = $bk->getBkChar();\n\n        if (!isset($file['size'])) {\n            if ($size = $bk->getSize())\n                $f->size = $size;\n            // Prefer mb_strlen, because mbstring.func_overload will\n            // automatically prefer it if configured.\n            elseif (extension_loaded('mbstring'))\n                $f->size = mb_strlen($file['data'], '8bit');\n            // bootstrap.php include a compat version of mb_strlen\n            else\n                $f->size = strlen($file['data']);\n        }\n\n        $f->save();\n        return $f;\n    }\n\n    static function __create($file, &$errors) {\n        return static::create($file);\n    }\n\n    /**\n     * Migrate this file from the current backend to the backend specified.\n     *\n     * Parameters:\n     * $bk - (string) type char of the target storage backend. Use\n     *      AttachmentStorageBackend::allRegistered() to get a list of type\n     *      chars and associated class names\n     *\n     * Returns:\n     * True if the migration was successful and false otherwise.\n     */\n    function migrate($bk) {\n\n        // Copy the file to the new backend and hash the contents\n        $target = FileStorageBackend::lookup($bk, $this);\n        $source = $this->open();\n\n        // Initialize hashing algorithm to verify uploaded contents\n        $algos = $target->getNativeHashAlgos();\n        $common_algo = 'sha1';\n        if ($algos && is_array($algos)) {\n            $supported = hash_algos();\n            foreach ($algos as $a) {\n                if (in_array(strtolower($a), $supported)) {\n                    $common_algo = strtolower($a);\n                    break;\n                }\n            }\n        }\n        $before = hash_init($common_algo);\n        // TODO: Make this resumable so that if the file cannot be migrated\n        //      in the max_execution_time, the migration can be continued\n        //      the next time the cron runs\n        try {\n            while ($block = $source->read($target->getBlockSize())) {\n                hash_update($before, $block);\n                $target->write($block);\n            }\n            $target->flush();\n        }\n        catch (Exception $e) {\n            // Migration failed\n            return false;\n        }\n\n        // Ask the backend to generate its own hash if at all possible\n        if (!($target_hash = $target->getHashDigest($common_algo))) {\n            $after = hash_init($common_algo);\n            // Verify that the hash of the target file matches the hash of\n            // the source file\n            $target = FileStorageBackend::lookup($bk, $this);\n            while ($block = $target->read())\n                hash_update($after, $block);\n            $target_hash = hash_final($after);\n        }\n\n        if (hash_final($before) != $target_hash) {\n            $target->unlink();\n            return false;\n        }\n\n        $this->bk = $target->getBkChar();\n        if (!$this->save())\n            return false;\n\n        return $source->unlink();\n    }\n\n    /**\n     * Considers the system's configuration for file storage selection based\n     * on the file information and purpose (FAQ attachment, image, etc).\n     *\n     * Parameters:\n     * $file - (hasharray) file information which would be passed to\n     * ::save() for instance.\n     *\n     * Returns:\n     * Instance<FileStorageBackend> backend selected based on the file\n     * received.\n     */\n    static function getBackendForFile($file) {\n        global $cfg;\n\n        $char = null;\n        if ($cfg) {\n            $char = $cfg->getDefaultStorageBackendChar();\n        }\n        try {\n            return FileStorageBackend::lookup($char ?: 'D', $file);\n        }\n        catch (Exception $x) {\n            return new AttachmentChunkedData($file);\n        }\n    }\n\n    static function lookupByHash($hash) {\n        if (isset(static::$keyCache[$hash]))\n            return static::$keyCache[$hash];\n\n        // Cache a negative lookup if no such file exists\n        return parent::lookup(array('key' => $hash));\n    }\n\n    static function lookup($id) {\n        return is_string($id)\n            ? static::lookupByHash($id)\n            : parent::lookup($id);\n    }\n\n    /*\n      Method formats http based $_FILE uploads - plus basic validation.\n     */\n    function format($files) {\n        global $ost;\n\n        if(!$files || !is_array($files))\n            return null;\n\n        //Reformat $_FILE  for the sane.\n        $attachments = array();\n        foreach($files as $k => $a) {\n            if(is_array($a))\n                foreach($a as $i => $v)\n                    $attachments[$i][$k] = $v;\n        }\n\n        //Basic validation.\n        foreach($attachments as $i => &$file) {\n            //skip no file upload \"error\" - why PHP calls it an error is beyond me.\n            if($file['error'] && $file['error']==UPLOAD_ERR_NO_FILE) {\n                unset($attachments[$i]);\n                continue;\n            }\n\n            if($file['error']) //PHP defined error!\n                $file['error'] = 'File upload error #'.$file['error'];\n            elseif(!$file['tmp_name'] || !is_uploaded_file($file['tmp_name']))\n                $file['error'] = 'Invalid or bad upload POST';\n        }\n        unset($file);\n\n        return array_filter($attachments);\n    }\n\n    /**\n     * Removes files and associated meta-data for files which no ticket,\n     * canned-response, or faq point to any more.\n     */\n    static function deleteOrphans() {\n\n        // XXX: Allow plugins to define filetypes which do not represent\n        //      files attached to tickets or other things in the attachment\n        //      table and are not logos\n        $files = static::objects()\n            ->filter(array(\n                'attachments__object_id__isnull' => true,\n                'ft' => 'T',\n                'created__lt' => SqlFunction::NOW()->minus(SqlInterval::DAY(1)),\n            ));\n\n        foreach ($files as $f) {\n            if (!$f->delete())\n                break;\n        }\n\n        return true;\n    }\n\n    static function allLogos() {\n        return static::objects()\n            ->filter(array('ft' => 'L'))\n            ->order_by('created');\n    }\n\n    static function allBackdrops() {\n        return static::objects()\n            ->filter(array('ft' => 'B'))\n            ->order_by('created');\n    }\n}\n\nclass FileStorageBackend {\n    var $meta;\n    static $desc = false;\n    static $registry;\n    static $blocksize = 131072;\n    static $private = false;\n\n    /**\n     * All storage backends should call this function during the request\n     * bootstrap phase.\n     */\n    static function register($typechar, $class) {\n        self::$registry[$typechar] = $class;\n    }\n\n    static function allRegistered($private=false) {\n        $R = self::$registry;\n        if (!$private) {\n            foreach ($R as $i=>$bk) {\n                if ($bk::$private)\n                    unset($R[$i]);\n            }\n        }\n        return $R;\n    }\n\n    /**\n     * Retrieves the type char registered for this storage backend's class.\n     * Null is returned if the backend is not properly registered.\n     */\n    function getBkChar() {\n        foreach (self::$registry as $tc=>$class)\n            if ($this instanceof $class)\n                return $tc;\n    }\n\n    static function isRegistered($type) {\n        return isset(self::$registry[$type]);\n    }\n\n    static function lookup($type, $file=null) {\n        if (!isset(self::$registry[$type]))\n            throw new Exception(\"No such backend registered\");\n\n        $class = self::$registry[$type];\n        return new $class($file);\n    }\n\n    static function getInstance($file) {\n        if (!isset(self::$registry[$file->getBackend()]))\n            throw new Exception(\"No such backend registered\");\n\n        $class = self::$registry[$file->getBackend()];\n        return new $class($file);\n    }\n\n    /**\n     * Returns the optimal block size for the backend. When migrating, this\n     * size blocks would be best for sending to the ::write() method\n     */\n    function getBlockSize() {\n        return static::$blocksize;\n    }\n\n    /**\n     * Create an instance of the storage backend linking the related file.\n     * Information about the file metadata is accessible via the received\n     * filed object.\n     */\n    function __construct($meta) {\n        $this->meta = $meta;\n    }\n\n    /**\n     * Commit file to the storage backend. This method is used if the\n     * backend cannot support writing a file directly. Otherwise, the\n     * ::upload($file) method is preferred.\n     *\n     * Parameters:\n     * $data - (string|binary) file contents to be written to the backend\n     */\n    function write($data) {\n        return false;\n    }\n\n    /**\n     * Called after all the blocks are sent to the ::write() method. This\n     * method should return boolean FALSE if flushing the data was\n     * somehow inhibited.\n     */\n    function flush() {\n        return true;\n    }\n\n    /**\n     * Upload a file to the backend. This method is preferred over ::write()\n     * for files which are uploaded or are otherwise available out of\n     * memory. The backend is encouraged to avoid reading the entire\n     * contents into memory.\n     */\n    function upload($filepath) {\n        return $this->write(file_get_contents($filepath));\n    }\n\n    /**\n     * Returns data from the backend, optionally returning only the number\n     * of bytes indicated at the specified offset. If the data is available\n     * in chunks, one chunk may be returned at a time. The backend should\n     * return boolean false when no more chunks are available.\n     */\n    function read($amount=0, $offset=0) {\n        return false;\n    }\n\n    /**\n     * Convenience method to send all the file to standard output\n     */\n    function passthru() {\n        while ($block = $this->read())\n            echo $block;\n    }\n\n    /**\n     * If the data is not stored or not available locally, a redirect\n     * response can be sent to the user agent indicating the actual HTTP\n     * location of the data.\n     *\n     * If the data is available locally, this method should return boolean\n     * false to indicate that the read() method should be used to retrieve\n     * the data and broker it to the user agent.\n     */\n    function sendRedirectUrl($disposition='inline') {\n        return false;\n    }\n\n    /**\n     * Requests the backend to remove the file contents.\n     */\n    function unlink() {\n        return false;\n    }\n\n    /**\n     * Fetches a list of hash algorithms that are supported transparently\n     * through the ::write() and ::upload() methods. After writing or\n     * uploading file content, the ::getHashDigest($algo) method can be\n     * called to get a hash of the remote content without fetching the\n     * entire data stream to verify the content locally.\n     */\n    function getNativeHashAlgos() {\n        return array();\n    }\n\n    /**\n     * Returns a hash of the content calculated remotely by the storage\n     * backend. If this method fails, the hash chould be calculated by\n     * downloading the content and hashing locally\n     */\n    function getHashDigest($algo) {\n        return false;\n    }\n\n    /**\n     * getSize\n     *\n     * Retrieves the size of the contents written or available to be read.\n     * The backend should optimize this process if possible by keeping track\n     * of the bytes written in a way apart from `strlen`. This value will be\n     * used instead of inspecting the contents using `strlen`.\n     */\n    function getSize() {\n        return false;\n    }\n}\n\n\n/**\n * Attachments stored in the database are cut into 500kB chunks and stored\n * in the FILE_CHUNK_TABLE to overcome the max_allowed_packet limitation of\n * LOB fields in the MySQL database\n */\ndefine('CHUNK_SIZE', 500*1024); # Beware if you change this...\nclass AttachmentFileChunk extends VerySimpleModel {\n    static $meta = array(\n        'table' => FILE_CHUNK_TABLE,\n        'pk' => array('file_id', 'chunk_id'),\n        'joins' => array(\n            'file' => array(\n                'constraint' => array('file_id' => 'AttachmentFile.id'),\n            ),\n        ),\n    );\n}\n\nclass AttachmentChunkedData extends FileStorageBackend {\n    static $desc = /* @trans */ \"In the database\";\n    static $blocksize = CHUNK_SIZE;\n\n    function __construct($file) {\n        $this->file = $file;\n        $this->_chunk = 0;\n        $this->_buffer = false;\n        $this->eof = false;\n    }\n\n    function getSize() {\n        $row = AttachmentFileChunk::objects()\n            ->filter(array('file' => $this->file))\n            ->aggregate(array('length' => SqlAggregate::SUM(SqlFunction::LENGTH(new SqlField('filedata')))))\n            ->one();\n        return $row['length'];\n    }\n\n    function read($amount=CHUNK_SIZE, $offset=0) {\n        # Read requested length of data from attachment chunks\n        if ($this->eof)\n            return false;\n\n        while (strlen($this->_buffer) < $amount + $offset) {\n            try {\n                list($buf) = AttachmentFileChunk::objects()\n                    ->filter(array('file' => $this->file, 'chunk_id' => $this->_chunk++))\n                    ->values_flat('filedata')\n                    ->one();\n            }\n            catch (DoesNotExist $e) {\n                $this->eof = true;\n                break;\n            }\n            $this->_buffer .= $buf;\n        }\n        $chunk = substr($this->_buffer, $offset, $amount);\n        $this->_buffer = substr($this->_buffer, $offset + $amount);\n        return $chunk;\n    }\n\n    function write($what, $chunk_size=CHUNK_SIZE) {\n        $offset=0;\n        while ($block = substr($what, $offset, $chunk_size)) {\n            // Chunks are considered immutable. Importing chunks should\n            // forceable remove the contents of a file before write()ing new\n            // chunks. Therefore, inserts should be safe.\n            $chunk = new AttachmentFileChunk(array(\n                'file' => $this->file,\n                'chunk_id' => $this->_chunk++,\n                'filedata' => $block\n            ));\n            if (!$chunk->save())\n                return false;\n            $offset += strlen($block);\n        }\n\n        return $this->_chunk;\n    }\n\n    function unlink() {\n        return AttachmentFileChunk::objects()\n            ->filter(array('file' => $this->file))\n            ->delete();\n    }\n}\nFileStorageBackend::register('D', 'AttachmentChunkedData');\n\n/**\n * This class provides an interface for files attached on the filesystem in\n * versions previous to v1.7. The upgrader will keep the attachments on the\n * disk where they were and write the path into the `attrs` field of the\n * %file table. This module will continue to serve those files until they\n * are migrated with the `file` cli app\n */\nclass OneSixAttachments extends FileStorageBackend {\n    static $desc = \"upload_dir folder (from osTicket v1.6)\";\n    static $private = true;\n\n    function read($bytes=32768, $offset=false) {\n        $filename = $this->meta->attrs;\n        if (!$this->fp)\n            $this->fp = @fopen($filename, 'rb');\n        if (!$this->fp)\n            throw new IOException($filename.': Unable to open for reading');\n        if ($offset)\n            fseek($this->fp, $offset);\n        if (($status = @fread($this->fp, $bytes)) === false)\n            throw new IOException($filename.': Unable to read from file');\n        return $status;\n    }\n\n    function passthru() {\n        $filename = $this->meta->attrs;\n        if (($status = @readfile($filename)) === false)\n            throw new IOException($filename.': Unable to read from file');\n        return $status;\n    }\n\n    function write($data) {\n        throw new IOException('This backend does not support new files');\n    }\n\n    function upload($filepath) {\n        throw new IOException('This backend does not support new files');\n    }\n\n    function unlink() {\n        $filename = $this->meta->attrs;\n        if (!@unlink($filename))\n            throw new IOException($filename.': Unable to delete file');\n        // Drop usage of the `attrs` field\n        $this->meta->attrs = null;\n        $this->meta->save();\n        return true;\n    }\n}\nFileStorageBackend::register('6', 'OneSixAttachments');\n\n// FileObject - wrapper for SplFileObject class\nclass FileObject extends SplFileObject {\n\n    protected $_filename;\n\n    function __construct($file, $mode='r') {\n        parent::__construct($file, $mode);\n    }\n\n    /* This allows us to set REAL file name as opposed to basename of the\n     * FS file in question\n     */\n    function setFilename($filename) {\n        $this->_filename = $filename;\n    }\n\n    function getFilename() {\n        return $this->_filename ?: parent::getFilename();\n    }\n\n    /*\n     * Set mime type - well formated mime is expected.\n     */\n    function setMimeType($type) {\n        $this->_mimetype = $type;\n    }\n\n    function getMimeType() {\n        if (!isset($this->_mimetype)) {\n            // Try to to auto-detect mime type\n            $finfo = new finfo(FILEINFO_MIME);\n            $this->_mimetype = $finfo->buffer($this->getContents(),\n                    FILEINFO_MIME_TYPE);\n        }\n\n        return $this->_mimetype;\n    }\n\n    function getContents() {\n        $this->fseek(0);\n        return $this->fread($this->getSize());\n    }\n\n    /*\n     * XXX: Needed for mailer attachments interface\n     */\n    function getData() {\n        return $this->getContents();\n    }\n}\n\n?>\n"], "fixing_code": ["<?php\n\nif(!defined('INCLUDE_DIR')) die('!');\n\nrequire_once(INCLUDE_DIR.'class.draft.php');\n\nclass DraftAjaxAPI extends AjaxController {\n\n    function _createDraft($vars) {\n        if (false === ($vars['body'] = self::_findDraftBody($_POST)))\n            return JsonDataEncoder::encode(array(\n                'error' => __(\"Draft body not found in request\"),\n                'code' => 422,\n                ));\n\n        if (!($draft = Draft::create($vars)) || !$draft->save())\n            Http::response(500, 'Unable to create draft');\n\n        header('Content-Type: application/json; charset=UTF-8');\n        echo JsonDataEncoder::encode(array(\n            'draft_id' => $draft->getId(),\n        ));\n    }\n\n    function _getDraft($draft) {\n        if (!$draft || !$draft instanceof Draft)\n            Http::response(205, \"Draft not found. Create one first\");\n\n        $body = Format::viewableImages($draft->getBody());\n\n        header('Content-Type: application/json; charset=UTF-8');\n        echo JsonDataEncoder::encode(array(\n            'body' => $body,\n            'draft_id' => $draft->getId(),\n        ));\n    }\n\n    function _updateDraft($draft) {\n        if (false === ($body = self::_findDraftBody($_POST)))\n            return JsonDataEncoder::encode(array(\n                'error' => array(\n                    'message' => \"Draft body not found in request\",\n                    'code' => 422,\n                )\n            ));\n\n        if (!$draft->setBody($body))\n            return Http::response(500, \"Unable to update draft body\");\n\n        echo \"{}\";\n    }\n\n    function _uploadInlineImage($draft) {\n        global $cfg;\n\n        if (!isset($_POST['data']) && !isset($_FILES['file']))\n            Http::response(422, \"File not included properly\");\n\n        # Fixup for expected multiple attachments\n        if (isset($_FILES['file'])) {\n            $file = AttachmentFile::format($_FILES['file']);\n\n            # Allow for data-uri uploaded files\n            $fp = fopen($file[0]['tmp_name'], 'rb');\n            if (fread($fp, 5) == 'data:') {\n                $data = 'data:';\n                while ($block = fread($fp, 8192))\n                  $data .= $block;\n                $file[0] = Format::parseRfc2397($data);\n                list(,$ext) = explode('/', $file[0]['type'], 2);\n                $file[0] += array(\n                    'name' => Misc::randCode(8).'.'.$ext,\n                    'size' => strlen($file[0]['data']),\n                );\n            }\n            fclose($fp);\n\n            # TODO: Detect unacceptable attachment extension\n            # TODO: Verify content-type and check file-content to ensure image\n            $type = $file[0]['type'];\n            if (strpos($file[0]['type'], 'image/') !== 0)\n                return Http::response(403,\n                    JsonDataEncoder::encode(array(\n                        'error' => 'File type is not allowed',\n                    ))\n                );\n\n            # TODO: Verify file size is acceptable\n            if ($file[0]['size'] > $cfg->getMaxFileSize())\n                return Http::response(403,\n                    JsonDataEncoder::encode(array(\n                        'error' => 'File is too large',\n                    ))\n                );\n\n            // Paste uploads in Chrome will have a name of 'blob'\n            if ($file[0]['name'] == 'blob')\n                $file[0]['name'] = 'screenshot-'.Misc::randCode(4);\n\n            $ids = $draft->attachments->upload($file);\n\n            if (!$ids) {\n                if ($file[0]['error']) {\n                    return Http::response(403,\n                        JsonDataEncoder::encode(array(\n                            'error' => $file[0]['error'],\n                        ))\n                    );\n                }\n                else\n                    return Http::response(500, 'Unable to attach image');\n            }\n\n            $id = (is_array($ids)) ? $ids[0] : $ids;\n        }\n        else {\n            $type = explode('/', $_POST['contentType']);\n            $info = array(\n                'data' => base64_decode($_POST['data']),\n                'name' => Misc::randCode(10).'.'.$type[1],\n                // TODO: Ensure _POST['contentType']\n                'type' => $_POST['contentType'],\n            );\n            // TODO: Detect unacceptable filetype\n            // TODO: Verify content-type and check file-content to ensure image\n            $id = $draft->attachments->save($info);\n        }\n        if (!($f = AttachmentFile::lookup($id)))\n            return Http::response(500, 'Unable to attach image');\n\n        header('Content-Type: application/json; charset=UTF-8');\n        echo JsonDataEncoder::encode(array(\n            Format::sanitize($f->getName()) => array(\n            'content_id' => 'cid:'.$f->getKey(),\n            'id' => $f->getKey(),\n            // Return draft_id to connect the auto draft creation\n            'draft_id' => $draft->getId(),\n            'url' => $f->getDownloadUrl(\n                ['type' => 'D', 'deposition' => 'inline']),\n        )));\n    }\n\n    // Client interface for drafts =======================================\n    function createDraftClient($namespace) {\n        global $thisclient;\n\n        if (!$thisclient && substr($namespace, -12) != substr(session_id(), -12))\n            Http::response(403, \"Valid session required\");\n\n        $vars = array(\n            'namespace' => $namespace,\n        );\n\n        return self::_createDraft($vars);\n    }\n\n    function getDraftClient($namespace) {\n        global $thisclient;\n\n        if ($thisclient) {\n            try {\n                $draft = Draft::lookupByNamespaceAndStaff($namespace,\n                    $thisclient->getId());\n            }\n            catch (DoesNotExist $e) {\n                Http::response(205, \"Draft not found. Create one first\");\n            }\n        }\n        else {\n            if (substr($namespace, -12) != substr(session_id(), -12))\n                Http::response(404, \"Draft not found\");\n            try {\n                $draft = Draft::lookupByNamespaceAndStaff($namespace, 0);\n            }\n            catch (DoesNotExist $e) {\n                Http::response(205, \"Draft not found. Create one first\");\n            }\n        }\n        return self::_getDraft($draft);\n    }\n\n    function updateDraftClient($id) {\n        global $thisclient;\n\n        if (!($draft = Draft::lookup($id)))\n            Http::response(205, \"Draft not found. Create one first\");\n        // Check the owning client-id (for logged-in users), and the\n        // session_id() for others\n        elseif ($thisclient) {\n            if ($draft->getStaffId() != $thisclient->getId())\n                Http::response(404, \"Draft not found\");\n        }\n        else {\n            if (substr(session_id(), -12) != substr($draft->getNamespace(), -12))\n                Http::response(404, \"Draft not found\");\n        }\n\n        return self::_updateDraft($draft);\n    }\n\n    function deleteDraftClient($id) {\n        global $thisclient;\n\n        if (!($draft = Draft::lookup($id)))\n            Http::response(205, \"Draft not found. Create one first\");\n        elseif ($thisclient) {\n            if ($draft->getStaffId() != $thisclient->getId())\n                Http::response(404, \"Draft not found\");\n        }\n        else {\n            if (substr(session_id(), -12) != substr($draft->getNamespace(), -12))\n                Http::response(404, \"Draft not found\");\n        }\n\n        $draft->delete();\n    }\n\n    function uploadInlineImageClient($id) {\n        global $thisclient;\n\n        if (!($draft = Draft::lookup($id)))\n            Http::response(205, \"Draft not found. Create one first\");\n        elseif ($thisclient) {\n            if ($draft->getStaffId() != $thisclient->getId())\n                Http::response(404, \"Draft not found\");\n        }\n        else {\n            if (substr(session_id(), -12) != substr($draft->getNamespace(), -12))\n                Http::response(404, \"Draft not found\");\n        }\n\n        return self::_uploadInlineImage($draft);\n    }\n\n    function uploadInlineImageEarlyClient($namespace) {\n        global $thisclient;\n\n        if (!$thisclient && substr($namespace, -12) != substr(session_id(), -12))\n            Http::response(403, \"Valid session required\");\n\n        $draft = Draft::create(array(\n            'namespace' => $namespace,\n        ));\n        if (!$draft->save())\n            Http::response(500, 'Unable to create draft');\n\n        return $this->uploadInlineImageClient($draft->getId());\n    }\n\n    // Staff interface for drafts ========================================\n    function createDraft($namespace) {\n        global $thisstaff;\n\n        if (!$thisstaff)\n            Http::response(403, \"Login required for draft creation\");\n\n        $vars = array(\n            'namespace' => $namespace,\n        );\n\n        return self::_createDraft($vars);\n    }\n\n    function getDraft($namespace) {\n        global $thisstaff;\n\n        if (!$thisstaff)\n            Http::response(403, \"Login required for draft creation\");\n        try {\n            $draft = Draft::lookupByNamespaceAndStaff($namespace,\n                $thisstaff->getId());\n        }\n        catch (DoesNotExist $e) {\n            Http::response(205, \"Draft not found. Create one first\");\n        }\n\n        return self::_getDraft($draft);\n    }\n\n    function updateDraft($id) {\n        global $thisstaff;\n\n        if (!$thisstaff)\n            Http::response(403, \"Login required for image upload\");\n        elseif (!($draft = Draft::lookup($id)))\n            Http::response(205, \"Draft not found. Create one first\");\n        elseif ($draft->getStaffId() != $thisstaff->getId())\n            Http::response(404, \"Draft not found\");\n\n        return self::_updateDraft($draft);\n    }\n\n    function uploadInlineImage($draft_id) {\n        global $thisstaff;\n\n        if (!$thisstaff)\n            Http::response(403, \"Login required for image upload\");\n        elseif (!($draft = Draft::lookup($draft_id)))\n            Http::response(205, \"Draft not found. Create one first\");\n        elseif ($draft->getStaffId() != $thisstaff->getId())\n            Http::response(404, \"Draft not found\");\n\n        return self::_uploadInlineImage($draft);\n    }\n\n    function uploadInlineImageEarly($namespace) {\n        global $thisstaff;\n\n        if (!$thisstaff)\n            Http::response(403, \"Login required for image upload\");\n\n        $draft = Draft::create(array(\n            'namespace' => $namespace\n        ));\n        if (!$draft->save())\n            Http::response(500, 'Unable to create draft');\n\n        return $this->uploadInlineImage($draft->getId());\n    }\n\n    function deleteDraft($id) {\n        global $thisstaff;\n\n        if (!$thisstaff)\n            Http::response(403, \"Login required for draft edits\");\n        elseif (!($draft = Draft::lookup($id)))\n            Http::response(205, \"Draft not found. Create one first\");\n        elseif ($draft->getStaffId() != $thisstaff->getId())\n            Http::response(404, \"Draft not found\");\n\n        $draft->delete();\n    }\n\n    function getFileList() {\n        global $thisstaff;\n\n        if (!$thisstaff)\n            Http::response(403, \"Login required for file queries\");\n\n        $search = Q::any([\n            Q::all([\n                'attachments__type__in' => array('C', 'F', 'T', 'P'),\n                'attachments__inline' => 1,\n            ]),\n            'ft' => 'L',\n        ]);\n\n        if (isset($_GET['threadId']) && is_numeric($_GET['threadId'])\n            && ($thread = Thread::lookup($_GET['threadId']))\n            && ($object = $thread->getObject())\n            && ($thisstaff->canAccess($object))\n        ) {\n            $search->add(Q::all([\n                'attachments__thread_entry__thread_id' => $_GET['threadId'],\n                'attachments__inline' => 1,\n            ]));\n        }\n\n        $images = AttachmentFile::objects()->filter([\n                $search,\n                'type__startswith' => 'image/',\n            ])->distinct('id');\n\n        $files = array();\n        foreach ($images as $f) {\n            $url = $f->getDownloadUrl();\n            $files[] = array(\n                // Don't send special sizing for thread items 'cause they\n                // should be cached already by the client\n                'thumb' => $url.($f->type != 'H' ? '&s=128' : ''),\n                'url' => $url,\n                'title' => $f->getName(),\n            );\n        }\n        header('Content-Type: application/json; charset=UTF-8');\n        echo JsonDataEncoder::encode($files);\n    }\n\n    function _findDraftBody($vars) {\n        if (isset($vars['name'])) {\n            $parts = array();\n            // Support nested `name`, like trans[lang]\n            if (preg_match('`(\\w+)(?:\\[(\\w+)\\])?(?:\\[(\\w+)\\])?`', $_POST['name'], $parts)) {\n                array_shift($parts);\n                $focus = $vars;\n                foreach ($parts as $p)\n                    $focus = $focus[$p];\n                return $focus;\n            }\n        }\n        $field_list = array('response', 'note', 'answer', 'body',\n             'message', 'issue', 'description');\n        foreach ($field_list as $field) {\n            if (isset($vars[$field])) {\n                return $vars[$field];\n            }\n        }\n\n        return false;\n    }\n\n}\n?>\n", "<?php\n\nrequire_once(INCLUDE_DIR . 'class.topic.php');\nrequire_once(INCLUDE_DIR . 'class.dynamic_forms.php');\nrequire_once(INCLUDE_DIR . 'class.forms.php');\n\nclass DynamicFormsAjaxAPI extends AjaxController {\n    function getForm($form_id) {\n        $form = DynamicForm::lookup($form_id);\n        if (!$form) return;\n\n        foreach ($form->getFields() as $field) {\n            $field->render();\n        }\n    }\n\n    function getFormsForHelpTopic($topic_id, $client=false) {\n        if (!$_SERVER['HTTP_REFERER'])\n            Http::response(403, 'Forbidden.');\n\n        if (!($topic = Topic::lookup($topic_id)))\n            Http::response(404, 'No such help topic');\n\n        if ($_GET || isset($_SESSION[':form-data'])) {\n            if (!is_array($_SESSION[':form-data']))\n                $_SESSION[':form-data'] = array();\n            $_SESSION[':form-data'] = array_merge($_SESSION[':form-data'],\n                    Format::htmlchars($_GET));\n        }\n\n        foreach ($topic->getForms() as $form) {\n            if (!$form->hasAnyVisibleFields())\n                continue;\n            ob_start();\n            $form->getForm($_SESSION[':form-data'])->render(array(\n                'staff' => !$client,\n                'mode' => 'create'));\n            $html .= ob_get_clean();\n            ob_start();\n            print $form->getMedia();\n            $media .= ob_get_clean();\n        }\n        return $this->encode(array(\n            'media' => $media,\n            'html' => $html,\n        ));\n    }\n\n    function getClientFormsForHelpTopic($topic_id) {\n        return $this->getFormsForHelpTopic($topic_id, true);\n    }\n\n    function getFieldConfiguration($field_id) {\n        $field = DynamicFormField::lookup($field_id);\n        include(STAFFINC_DIR . 'templates/dynamic-field-config.tmpl.php');\n    }\n\n    function saveFieldConfiguration($field_id) {\n\n        if (!($field = DynamicFormField::lookup($field_id)))\n            Http::response(404, 'No such field');\n\n        $DFF = 'DynamicFormField';\n\n        // Capture flags which should remain unchanged\n        $p_mask = $DFF::MASK_MASK_ALL;\n        if ($field->isPrivacyForced()) {\n            $p_mask |= $DFF::FLAG_CLIENT_VIEW | $DFF::FLAG_AGENT_VIEW;\n        }\n        if ($field->isRequirementForced()) {\n            $p_mask |= $DFF::FLAG_CLIENT_REQUIRED | $DFF::FLAG_AGENT_REQUIRED;\n        }\n        if ($field->hasFlag($DFF::FLAG_MASK_DISABLE)) {\n            $p_mask |= $DFF::FLAG_ENABLED;\n        }\n\n        // Capture current state of immutable flags\n        $preserve = $field->flags & $p_mask;\n\n        // Set admin-configured flag states\n        $flags = array_reduce($_POST['flags'] ?: array(),\n            function($a, $b) { return $a | $b; }, 0);\n        $field->flags = $flags | $preserve;\n\n        if ($field->setConfiguration($_POST)) {\n            $field->save();\n            Http::response(201, 'Field successfully updated');\n        }\n\n        include STAFFINC_DIR . 'templates/dynamic-field-config.tmpl.php';\n    }\n\n    function deleteAnswer($entry_id, $field_id) {\n        global $thisstaff;\n\n        if (!$thisstaff)\n            Http::response(403, 'Login required');\n\n        $ent = DynamicFormEntryAnswer::lookup(array(\n            'entry_id'=>$entry_id, 'field_id'=>$field_id));\n        if (!$ent)\n            Http::response(404, 'Answer not found');\n\n        $ent->delete();\n    }\n\n\n    function getListItem($list_id, $item_id) {\n\n        $list = DynamicList::lookup($list_id);\n        if (!$list)\n            Http::response(404, 'No such list item');\n\n        $list = CustomListHandler::forList($list);\n        if (!($item = $list->getItem( (int) $item_id)))\n            Http::response(404, 'No such list item');\n\n        $action = \"#list/{$list->getId()}/item/{$item->getId()}/update\";\n        $item_form = $list->getListItemBasicForm($item->ht, $item);\n\n        include(STAFFINC_DIR . 'templates/list-item-properties.tmpl.php');\n    }\n\n    function getListItems($list_id) {\n        global $thisstaff;\n\n        if (!$thisstaff)\n            Http::response(403, 'Login required');\n\n        if (!($list = DynamicList::lookup($list_id)))\n            Http::response(404, 'No such list');\n\n        $pjax_container = '#items';\n        include(STAFFINC_DIR . 'templates/list-items.tmpl.php');\n    }\n\n    function previewListItem($list_id, $item_id) {\n\n        $list = DynamicList::lookup($list_id);\n        if (!$list)\n            Http::response(404, 'No such list item');\n\n        $list = CustomListHandler::forList($list);\n        if (!($item = $list->getItem( (int) $item_id)))\n            Http::response(404, 'No such list item');\n\n        $form = $list->getListItemBasicForm($item->ht, $item);\n        include(STAFFINC_DIR . 'templates/list-item-preview.tmpl.php');\n    }\n\n    function saveListItem($list_id, $item_id) {\n        global $thisstaff;\n\n        $errors = array();\n\n        if (!$thisstaff)\n            Http::response(403, 'Login required');\n\n        $list = DynamicList::lookup($list_id);\n        if (!$list)\n            Http::response(404, 'No such list item');\n\n        $list = CustomListHandler::forList($list);\n        if (!$list || !($item = $list->getItem( (int) $item_id)))\n            Http::response(404, 'No such list item');\n\n        $item_form = $list->getListItemBasicForm($_POST, $item);\n\n        if ($valid = $item_form->isValid()) {\n            if ($_item = DynamicListItem::lookup(array(\n                'list_id' => $list->getId(), 'value'=>$item->getValue()))\n            ) {\n                if ($_item && $_item->id != $item->id)\n                    $item_form->getField('value')->addError(\n                        __('Value already in use'));\n            }\n            if ($item_form->isValid()) {\n                // Update basic information\n                $basic = $item_form->getClean();\n                $item->update([\n                    'name' =>   $basic['name'],\n                    'value' =>  $basic['value'],\n                    'abbrev' =>  $basic['extra'],\n                ], $errors);\n            }\n        }\n\n        // Context\n        $action = \"#list/{$list->getId()}/item/{$item->getId()}/update\";\n        $icon = ($list->get('sort_mode') == 'SortCol')\n            ? '<i class=\"icon-sort\"></i>&nbsp;' : '';\n\n        if (!$valid || !$item->setConfiguration($_POST)) {\n            include STAFFINC_DIR . 'templates/list-item-properties.tmpl.php';\n            return;\n        }\n        else {\n            $item->save();\n        }\n\n        Http::response(201, $this->encode(array(\n            'id' => $item->getId(),\n            'row' => $this->_renderListItem($item, $list),\n            'success' => true,\n        )));\n    }\n\n    function _renderListItem($item, $list=false) {\n        $list = $list ?: $item->getList();\n\n        // Send the whole row back\n        $prop_fields = $list->getSummaryFields();\n        $icon = ($list->get('sort_mode') == 'SortCol')\n            ? '<i class=\"icon-sort\"></i>&nbsp;' : '';\n        ob_start();\n        $item->_config = null;\n        include STAFFINC_DIR . 'templates/list-item-row.tmpl.php';\n        return ob_get_clean();\n    }\n\n    function searchListItems($list_id) {\n        global $thisstaff;\n\n        if (!$thisstaff)\n            Http::response(403, 'Login required');\n        elseif (!($list = DynamicList::lookup($list_id)))\n            Http::response(404, 'No such list');\n        elseif (!($q = $_GET['q']))\n            Http::response(400, '\"q\" query arg is required');\n\n        $list = CustomListHandler::forList($list);\n        $items = $list->search($q);\n\n        $results = array();\n        foreach ($items as $I) {\n            $display = $I->getValue();\n            if (isset($I->extra))\n              $display .= \" ({$I->extra})\";\n            $results[] = array(\n                'value' => $I->getValue(),\n                'display' => $display,\n                'id' => $I->id,\n                'list_id' => $list->getId(),\n            );\n        }\n        return $this->encode($results);\n    }\n\n    function addListItem($list_id) {\n        global $thisstaff;\n\n        if (!$thisstaff)\n            Http::response(403, 'Login required');\n        elseif (!($list = DynamicList::lookup($list_id)))\n            Http::response(404, 'No such list');\n\n        $list = CustomListHandler::forList($list);\n        $action = \"#list/{$list->getId()}/item/add\";\n        $item_form = $list->getListItemBasicForm($_POST ?: null);\n        $errors = array();\n\n        if ($_POST && ($valid = $item_form->isValid())) {\n            $data = $item_form->getClean();\n            if ($list->isItemUnique($data)) {\n                $item = $list->addItem($data, $errors);\n                if ($item->setConfiguration($_POST, $errors)) {\n                    Http::response(201, $this->encode(array(\n                        'success' => true,\n                        'row' => $this->_renderListItem($item, $list)\n                    )));\n                }\n            }\n            else {\n                $item_form->getField('value')->addError(\n                    __('Value already in use'));\n            }\n        }\n\n        include(STAFFINC_DIR . 'templates/list-item-properties.tmpl.php');\n    }\n\n    function importListItems($list_id) {\n        global $thisstaff;\n\n        if (!$thisstaff)\n            Http::response(403, 'Login required');\n        elseif (!($list = DynamicList::lookup($list_id)))\n            Http::response(404, 'No such list');\n\n        $list = CustomListHandler::forList($list);\n        $info = array(\n            'title' => sprintf('%s &mdash; %s',\n                $list->getName(), __('Import Items')),\n            'action' => \"#list/{$list_id}/import\",\n            'upload_url' => \"lists.php?id={$list_id}&amp;do=import-items\",\n        );\n\n        if ($_POST) {\n            $status = $list->importFromPost($_FILES['import'] ?: $_POST['pasted']);\n            if ($status && is_numeric($status))\n                Http::response(201, $this->encode( array('success' => true, 'count' => $status)));\n\n            $info['error'] = $status;\n            $info['pasted'] = Format::htmlchars($_POST['pasted']);\n        }\n\n        include(STAFFINC_DIR . 'templates/list-import.tmpl.php');\n    }\n\n    function disableItems($list_id) {\n        global $thisstaff;\n\n        if (!$thisstaff)\n            Http::response(403, 'Login required');\n        elseif (!($list = DynamicList::lookup($list_id)))\n            Http::response(404, 'No such list');\n        elseif (!$_POST['ids'])\n            Http::response(422, 'Send `ids` parameter');\n\n        $list = CustomListHandler::forList($list);\n        foreach ($_POST['ids'] as $id) {\n            if ($item = $list->getItem( (int) $id)) {\n                $item->disable();\n                $item->save();\n            }\n            else {\n                Http::response(404, 'No such list item');\n            }\n        }\n        Http::response(200, $this->encode(array('success' => true)));\n    }\n\n    function undisableItems($list_id) {\n        global $thisstaff;\n\n        if (!$thisstaff)\n            Http::response(403, 'Login required');\n        elseif (!($list = DynamicList::lookup($list_id)))\n            Http::response(404, 'No such list');\n        elseif (!$_POST['ids'])\n            Http::response(422, 'Send `ids` parameter');\n\n        $list = CustomListHandler::forList($list);\n        foreach ($_POST['ids'] as $id) {\n            if ($item = $list->getItem( (int) $id)) {\n                $item->enable();\n                $item->save();\n            }\n            else {\n                Http::response(404, 'No such list item');\n            }\n        }\n        Http::response(200, $this->encode(array('success' => true)));\n    }\n\n    function deleteItems($list_id) {\n        global $thisstaff;\n\n        if (!$thisstaff)\n            Http::response(403, 'Login required');\n        elseif (!($list = DynamicList::lookup($list_id)))\n            Http::response(404, 'No such list');\n        elseif (!$_POST['ids'])\n            Http::response(422, 'Send `ids` parameter');\n\n        foreach ($_POST['ids'] as $id) {\n            if ($item = $list->getItem( (int) $id)) {\n                $item->delete();\n            }\n            else {\n                Http::response(404, 'No such list item');\n            }\n        }\n        Http::response(200, $this->encode(array('success' => true)));\n    }\n\n    function upload($id) {\n        if (!$field = DynamicFormField::lookup($id))\n            Http::response(400, 'No such field');\n\n        $impl = $field->getImpl();\n        if (!$impl instanceof FileUploadField)\n            Http::response(400, 'Upload to a non file-field');\n\n        header('Content-Type: application/json; charset=UTF-8');\n        return JsonDataEncoder::encode(\n            array('id'=>$impl->ajaxUpload())\n        );\n    }\n\n    function attach($object=null) {\n        global $thisstaff;\n\n        $filter = array('type__contains'=>'thread');\n        // Determine if for Ticket/Task/Custom\n        if ($object && is_string($object)) {\n            if ($object == 'ticket')\n                $filter['form_id'] = TicketForm::objects()->one()->id;\n            elseif ($object == 'task')\n                $filter['form_id'] = TaskForm::objects()->one()->id;\n        }\n        $config = DynamicFormField::objects()\n            ->filter($filter)\n            ->order_by('id')\n            ->first()->getConfiguration();\n        $field = new FileUploadField();\n        $field->_config = $config;\n        header('Content-Type: application/json; charset=UTF-8');\n        return JsonDataEncoder::encode(\n            array('id'=>$field->ajaxUpload($thisstaff ? true : false))\n        );\n    }\n\n    function getAllFields($id) {\n        global $thisstaff;\n\n        if (!$thisstaff)\n            Http::response(403, 'Login required');\n        elseif (!$form = DynamicForm::lookup($id))\n            Http::response(400, 'No such form');\n\n        // XXX: Fetch the form via the list!\n        ob_start();\n        include STAFFINC_DIR . 'templates/dynamic-form-fields-view.tmpl.php';\n        $html = ob_get_clean();\n\n        return $this->encode(array(\n            'success'=>true,\n            'html' => $html,\n        ));\n    }\n}\n?>\n", "<?php\n/*********************************************************************\n    ajax.i18n.php\n\n    Callbacks to get internaltionalized pieces for osticket\n\n    Peter Rotich <peter@osticket.com>\n    Jared Hancock <jared@osticket.com>\n    Copyright (c)  2006-2014 osTicket\n    http://www.osticket.com\n\n    Released under the GNU General Public License WITHOUT ANY WARRANTY.\n    See LICENSE.TXT for details.\n\n    vim: expandtab sw=4 ts=4 sts=4:\n**********************************************************************/\n\nif(!defined('INCLUDE_DIR')) die('!');\n\nclass i18nAjaxAPI extends AjaxController {\n    function getLanguageFile($lang, $key) {\n        global $cfg;\n\n        $i18n = new Internationalization($lang);\n        switch ($key) {\n        case 'js':\n            $data = $i18n->getTemplate('js/redactor.js')->getRawData();\n            $data .= $i18n->getTemplate('js/jquery.ui.datepicker.js')->getRawData();\n            // Strings from various javascript files\n            $data .= $i18n->getTemplate('js/osticket-strings.js')->getRawData();\n            header('Content-Type: text/javascript; charset=UTF-8');\n            break;\n        default:\n            Http::response(404, 'No such i18n data');\n        }\n\n        Http::cacheable(md5($data), $cfg->lastModified());\n        echo $data;\n    }\n\n    function getTranslations($tag) {\n        $t = CustomDataTranslation::allTranslations($tag);\n        $phrases = array();\n        $lm = 0;\n        foreach ($t as $translation) {\n            $phrases[$translation->lang] = $translation->text;\n            $lm = max($lm, strtotime($translation->updated));\n        }\n        $json = JsonDataEncoder::encode($phrases) ?: '{}';\n        //Http::cacheable(md5($json), $lm);\n\n        header('Content-Type: application/json; charset=UTF-8');\n        return $json;\n    }\n\n    function updateTranslations($tag) {\n        global $thisstaff, $cfg;\n\n        if (!$thisstaff)\n            Http::response(403, \"Agent login required\");\n        if (!$_POST)\n            Http::response(422, \"No translations found to update\");\n\n        $t = CustomDataTranslation::allTranslations($tag);\n        $phrases = array();\n        foreach ($t as $translation) {\n            $phrases[$translation->lang] = $translation;\n        }\n        foreach ($_POST as $lang => $phrase) {\n            if (isset($phrases[$lang])) {\n                $p = $phrases[$lang];\n                if (!$phrase) {\n                    $p->delete();\n                }\n                else {\n                    // Avoid XSS injection\n                    $p->text = trim(Format::sanitize($phrase));\n                    $p->agent_id = $thisstaff->getId();\n                }\n            }\n            elseif (in_array($lang, $cfg->getSecondaryLanguages())) {\n                if (!$phrase)\n                    continue;\n                $phrases[$lang] = CustomDataTranslation::create(array(\n                    'lang'          => $lang,\n                    'text'          => $phrase,\n                    'object_hash'   => $tag,\n                    'type'          => 'phrase',\n                    'agent_id'      => $thisstaff->getId(),\n                    'updated'       => new SqlFunction('NOW'),\n                ));\n            }\n            else {\n                Http::response(400,\n                    sprintf(\"%s: Must be a secondary language\", $lang));\n            }\n        }\n        // Commit.\n        foreach ($phrases as $p)\n            if (!$p->save())\n                Http::response(500, sprintf(\"%s: Unable to commit language\"));\n    }\n\n    function getConfiguredLanguages() {\n        global $cfg;\n\n        $primary = $cfg->getPrimaryLanguage();\n        $info = Internationalization::getLanguageInfo($primary);\n        $langs = array(\n            $primary => array(\n                'name' => Internationalization::getLanguageDescription($primary),\n                'flag' => strtolower($info['flag']),\n                'direction' => $info['direction'] ?: 'ltr',\n            ),\n        );\n\n        foreach ($cfg->getSecondaryLanguages() as $l) {\n            $info = Internationalization::getLanguageInfo($l);\n            $langs[$l] = array(\n                'name' => Internationalization::getLanguageDescription($l),\n                'flag' => strtolower($info['flag']),\n                'direction' => $info['direction'] ?: 'ltr',\n            );\n        }\n        $json = JsonDataEncoder::encode($langs);\n        Http::cacheable(md5($json), $cfg->lastModified());\n\n        header('Content-Type: application/json; charset=UTF-8');\n        return $json;\n    }\n\n    function getSecondaryLanguages() {\n        global $cfg;\n\n        $langs = array();\n        foreach ($cfg->getSecondaryLanguages() as $l) {\n            $info = Internationalization::getLanguageInfo($l);\n            $langs[$l] = array(\n                'name' => Internationalization::getLanguageDescription($l),\n                'flag' => strtolower($info['flag']),\n                'direction' => $info['direction'] ?: 'ltr',\n            );\n        }\n        $json = JsonDataEncoder::encode($langs);\n        Http::cacheable(md5($json), $cfg->lastModified());\n\n        header('Content-Type: application/json; charset=UTF-8');\n        return $json;\n    }\n}\n?>\n", "<?php\n/*********************************************************************\n    class.file.php\n\n    Peter Rotich <peter@osticket.com>\n    Copyright (c)  2006-2013 osTicket\n    http://www.osticket.com\n\n    Released under the GNU General Public License WITHOUT ANY WARRANTY.\n    See LICENSE.TXT for details.\n\n    vim: expandtab sw=4 ts=4 sts=4:\n**********************************************************************/\nrequire_once(INCLUDE_DIR.'class.signal.php');\nrequire_once(INCLUDE_DIR.'class.error.php');\n\n\n/**\n * Represents a file stored in a storage backend. It is generally attached\n * to something; however company logos, login page backdrops, and other\n * items are also stored in the database for various purposes.\n *\n * FileType-Definitions:\n *    The `ft` field is used to represent the type or purpose of the file\n *    with respect to the system. These are the defined file types (placed\n *    here as the definitions are not needed in code).\n *\n *    - 'T' => Attachments\n *    - 'L' => Logo\n *    - 'B' => Backdrop\n */\nclass AttachmentFile extends VerySimpleModel {\n\n    static $meta = array(\n        'table' => FILE_TABLE,\n        'pk' => array('id'),\n        'joins' => array(\n            'attachments' => array(\n                'reverse' => 'Attachment.file'\n            ),\n        ),\n    );\n    static $keyCache = array();\n\n    function __onload() {\n        // Cache for lookup in the ::lookupByHash method below\n        static::$keyCache[$this->key] = $this;\n    }\n\n    function getHashtable() {\n        return $this->ht;\n    }\n\n    function getInfo() {\n        return $this->getHashtable();\n    }\n\n    function getNumEntries() {\n        return $this->attachments->count();\n    }\n\n    function isCanned() {\n        return $this->getNumEntries();\n    }\n\n    function isInUse() {\n        return $this->getNumEntries();\n    }\n\n    function getId() {\n        return $this->id;\n    }\n\n    function getType() {\n        return $this->type;\n    }\n\n    function getMimeType() {\n        return $this->getType();\n    }\n\n    function getBackend() {\n        return $this->bk;\n    }\n\n    function getSize() {\n        return $this->size;\n    }\n\n    function getName() {\n        return $this->name;\n    }\n\n    function getKey() {\n        return $this->key;\n    }\n\n    function getSignature($cascade=false) {\n        $sig = $this->signature;\n        if (!$sig && $cascade) return $this->getKey();\n        return $sig;\n    }\n\n    function lastModified() {\n        return $this->created;\n    }\n\n    function open() {\n        return FileStorageBackend::getInstance($this);\n    }\n\n    function sendData($redirect=true, $disposition='inline') {\n        $bk = $this->open();\n        if ($redirect && $bk->sendRedirectUrl($disposition))\n            return;\n\n        @ini_set('zlib.output_compression', 'Off');\n        try {\n            $bk->passthru();\n        }\n        catch (IOException $ex) {\n            Http::response(404, 'File not found');\n        }\n    }\n\n    function getData() {\n        # XXX: This is horrible, and is subject to php's memory\n        #      restrictions, etc. Don't use this function!\n        ob_start();\n        try {\n            $this->sendData(false);\n        }\n        catch (IOException $ex) {\n            Http::response(404, 'File not found');\n        }\n        $data = &ob_get_contents();\n        ob_end_clean();\n        return $data;\n    }\n\n    function delete() {\n\n        if (!parent::delete())\n            return false;\n\n        if ($bk = $this->open())\n            $bk->unlink();\n\n        return true;\n    }\n\n    function makeCacheable($ttl=86400) {\n        Http::cacheable($this->getSignature(true), $this->lastModified(), $ttl);\n    }\n\n    function display($scale=false) {\n        $this->makeCacheable();\n\n        if ($scale && extension_loaded('gd')) {\n            $image = imagecreatefromstring($this->getData());\n            $width = imagesx($image);\n            if ($scale <= $width) {\n                $height = imagesy($image);\n                if ($width > $height) {\n                    $heightp = $height * (int)$scale / $width;\n                    $widthp = $scale;\n                } else {\n                    $widthp = $width * (int)$scale / $height;\n                    $heightp = $scale;\n                }\n                $thumb = imagecreatetruecolor($widthp, $heightp);\n                $white = imagecolorallocate($thumb, 255,255,255);\n                imagefill($thumb, 0, 0, $white);\n                imagecopyresized($thumb, $image, 0, 0, 0, 0, $widthp,\n                    $heightp, $width, $height);\n                header('Content-Type: image/png');\n                imagepng($thumb);\n                return;\n            }\n        }\n        header('Content-Type: '.($this->getType()?$this->getType():'application/octet-stream'));\n        header('Content-Length: '.$this->getSize());\n        $this->sendData();\n        exit();\n    }\n\n    function getDownloadUrl($options=array()) {\n        // Add attachment ref id if object type is set\n        if (isset($options['type'])\n                && !isset($options['id'])\n                && ($a=$this->attachments->findFirst(array(\n                            'type' => $options['type']))))\n            $options['id'] = $a->getId();\n\n        return static::generateDownloadUrl($this->getId(),\n                strtolower($this->getKey()), $this->getSignature(),\n                $options);\n    }\n\n    // Generates full download URL for external sources.\n    // e.g. https://domain.tld/file.php?args=123\n    function getExternalDownloadUrl($options=array()) {\n        global $cfg;\n\n        $download = self::getDownloadUrl($options);\n        // Separate URL handle and args\n        list($handle, $args) = explode('file.php?', $download);\n\n        return (string) rtrim($cfg->getBaseUrl(), '/').'/file.php?'.$args;\n    }\n\n    static function generateDownloadUrl($id, $key, $hash, $options = array()) {\n\n        // Expire at the nearest midnight, allow at least12 hrs access\n        $minage = @$options['minage'] ?: 43200;\n        $gmnow = Misc::gmtime() +  $options['minage'];\n        $expires = $gmnow + 86400 - ($gmnow % 86400);\n\n        // Generate a signature based on secret content\n        $signature = static::_genUrlSignature($id, $key, $hash, $expires);\n\n        // Handler / base url\n        $handler = @$options['handler'] ?: ROOT_PATH . 'file.php';\n\n        // Return sanitized query string\n        $args = array(\n            'key' => $key,\n            'expires' => $expires,\n            'signature' => $signature,\n        );\n\n        if (isset($options['disposition']))\n            $args['disposition'] =  $options['disposition'];\n\n        if (isset($options['id']))\n            $args['id'] =  $options['id'];\n\n        return sprintf('%s?%s', $handler, http_build_query($args));\n    }\n\n    function verifySignature($signature, $expires) {\n        $gmnow = Misc::gmtime();\n        if ($expires < $gmnow)\n            return false;\n\n        $check = static::_genUrlSignature($this->getId(), $this->getKey(),\n            $this->getSignature(), $expires);\n        return $signature == $check;\n    }\n\n    static function _genUrlSignature($id, $key, $signature, $expires) {\n        $pieces = array(\n            'Host='.$_SERVER['HTTP_HOST'],\n            'Path='.ROOT_PATH,\n            'Id='.$id,\n            'Key='.strtolower($key),\n            'Hash='.$signature,\n            'Expires='.$expires,\n        );\n        return hash_hmac('sha1', implode(\"\\n\", $pieces), SECRET_SALT);\n    }\n\n    function download($name=false, $disposition=false, $expires=false) {\n        $thisstaff = StaffAuthenticationBackend::getUser();\n        $inline = ($thisstaff ? ($thisstaff->getImageAttachmentView() === 'inline') : false);\n        $disposition = ((($disposition && strcasecmp($disposition, 'inline') == 0)\n              || $inline)\n              && strpos($this->getType(), 'image/') !== false)\n            ? 'inline' : 'attachment';\n        $bk = $this->open();\n        if ($bk->sendRedirectUrl($disposition))\n            return;\n        $ttl = ($expires) ? $expires - Misc::gmtime() : false;\n        $this->makeCacheable($ttl);\n        $type = $this->getType() ?: 'application/octet-stream';\n        Http::download($name ?: $this->getName(), $type, null, $disposition);\n        header('Content-Length: '.$this->getSize());\n        $this->sendData(false);\n        exit();\n    }\n\n    function _getKeyAndHash($data=false, $file=false) {\n        if ($file) {\n            $sha1 = base64_encode(sha1_file($data, true));\n            $md5 = base64_encode(md5_file($data, true));\n        }\n        else {\n            $sha1 = base64_encode(sha1($data, true));\n            $md5 = base64_encode(md5($data, true));\n        }\n\n        // Use 5 chars from the microtime() prefix and 27 chars from the\n        // sha1 hash. This should make a sufficiently strong unique key for\n        // file content. In the event there is a sha1 collision for data, it\n        // should be unlikely that there will be a collision for the\n        // microtime hash coincidently.  Remove =, change + and / to chars\n        // better suited for URLs and filesystem paths\n        $prefix = base64_encode(sha1(microtime(), true));\n        $key = str_replace(\n            array('=','+','/'),\n            array('','-','_'),\n            substr($prefix, 0, 5) . $sha1);\n\n        // The hash is a 32-char value where the first half is from the last\n        // 16 chars from the SHA1 hash and the last 16 chars are the last 16\n        // chars from the MD5 hash. This should provide for better\n        // resiliance against hash collisions and attacks against any one\n        // hash algorithm. Since we're using base64 encoding, with 6-bits\n        // per char, we should have a total hash strength of 192 bits.\n        $hash = str_replace(\n            array('=','+','/'),\n            array('','-','_'),\n            substr($sha1, 0, 16) . substr($md5, 0, 16));\n\n        return array($key, $hash);\n    }\n\n    /* Function assumes the files types have been validated */\n    static function upload($file, $ft='T', $deduplicate=true) {\n\n        if(!$file['name'] || $file['error'] || !is_uploaded_file($file['tmp_name']))\n            return false;\n\n        list($key, $sig) = self::_getKeyAndHash($file['tmp_name'], true);\n\n        $info=array('type'=>$file['type'],\n                    'filetype'=>$ft,\n                    'size'=>$file['size'],\n                    'name'=>$file['name'],\n                    'key'=>$key,\n                    'signature'=>$sig,\n                    'tmp_name'=>$file['tmp_name'],\n                    );\n\n        return static::create($info, $ft, $deduplicate);\n    }\n\n    static function uploadBackdrop(array $file, &$error) {\n        if (extension_loaded('gd')) {\n            $source_path = $file['tmp_name'];\n            list($source_width, $source_height, $source_type) = getimagesize($source_path);\n\n            switch ($source_type) {\n                case IMAGETYPE_GIF:\n                case IMAGETYPE_JPEG:\n                case IMAGETYPE_PNG:\n                    break;\n                default:\n                    $error = __('Invalid image file type');\n                    return false;\n            }\n        }\n        return self::upload($file, 'B', false);\n    }\n\n    static function uploadLogo($file, &$error, $aspect_ratio=2) {\n        /* Borrowed in part from\n         * http://salman-w.blogspot.com/2009/04/crop-to-fit-image-using-aspphp.html\n         */\n        if (extension_loaded('gd')) {\n            $source_path = $file['tmp_name'];\n            list($source_width, $source_height, $source_type) = getimagesize($source_path);\n\n            switch ($source_type) {\n                case IMAGETYPE_GIF:\n                case IMAGETYPE_JPEG:\n                case IMAGETYPE_PNG:\n                    break;\n                default:\n                    $error = __('Invalid image file type');\n                    return false;\n            }\n\n            $source_aspect_ratio = $source_width / $source_height;\n\n            if ($source_aspect_ratio < $aspect_ratio) {\n                $error = __('Image is too square. Upload a wider image');\n                return false;\n            }\n        }\n        return self::upload($file, 'L', false);\n    }\n\n    static function create(&$file, $ft='T', $deduplicate=true) {\n        if (isset($file['encoding'])) {\n            switch ($file['encoding']) {\n            case 'base64':\n                $file['data'] = base64_decode($file['data']);\n            }\n        }\n\n        if (!isset($file['data']) && isset($file['data_cbk'])\n                && is_callable($file['data_cbk'])) {\n            // Allow a callback function to delay or avoid reading or\n            // fetching ihe file contents\n            $file['data'] = $file['data_cbk']();\n        }\n\n        if (isset($file['data'])) {\n            list($key, $file['signature'])\n                = self::_getKeyAndHash($file['data']);\n            if (!$file['key'])\n                $file['key'] = $key;\n        }\n\n        if (isset($file['size']) && $file['size'] > 0) {\n            // Check and see if the file is already on record\n            $existing = static::objects()->filter(array(\n                'signature' => $file['signature'],\n                'size' => $file['size']\n            ))->first();\n\n            // If the record exists in the database already, a file with\n            // the same hash and size is already on file -- just return\n            // the file\n            if ($deduplicate && $existing) {\n                $file['key'] = $existing->key;\n                return $existing;\n            }\n        }\n        elseif (!isset($file['data'])) {\n            // Unable to determine the file's size\n            return false;\n        }\n\n        if (!$file['type'] && extension_loaded('fileinfo')) {\n            $finfo = new finfo(FILEINFO_MIME_TYPE);\n            if ($file['data'])\n                $type = $finfo->buffer($file['data']);\n            elseif ($file['tmp_name'])\n                $type = $finfo->file($file['tmp_name']);\n\n            if ($type)\n                $file['type'] = $type;\n        }\n        if (!$file['type'])\n            $file['type'] = 'application/octet-stream';\n\n\n        $f = new static(array(\n            'type' => strtolower($file['type']),\n            'name' => $file['name'],\n            'key' => $file['key'],\n            'ft' => $ft ?: 'T',\n            'signature' => $file['signature'],\n            'created' => SqlFunction::NOW(),\n        ));\n\n        if (isset($file['size']))\n            $f->size = $file['size'];\n\n        if (!$f->save())\n            return false;\n\n        // Note that this is preferred over $f->open() because the file does\n        // not have a valid backend configured yet. ::getBackendForFile()\n        // will consider the system configuration for storing the file\n        $bks = array(self::getBackendForFile($f));\n        if (!$bks[0]->getBkChar() !== 'D')\n            $bks[] = new AttachmentChunkedData($f);\n\n        // Consider the selected backen first and then save to database\n        // otherwise.\n        $succeeded = false;\n        foreach ($bks as $bk) {\n            try {\n                if (isset($file['tmp_name'])) {\n                    if ($bk->upload($file['tmp_name'])) {\n                        $succeeded = true; break;\n                    }\n                }\n                elseif ($bk->write($file['data']) && $bk->flush()) {\n                    $succeeded = true; break;\n                }\n            }\n            catch (Exception $e) {\n                // Try next backend\n            }\n            // Fallthrough to default backend if different?\n        }\n        if (!$succeeded) {\n            // Unable to save data (weird)\n            return false;\n        }\n\n        $f->bk = $bk->getBkChar();\n\n        if (!isset($file['size'])) {\n            if ($size = $bk->getSize())\n                $f->size = $size;\n            // Prefer mb_strlen, because mbstring.func_overload will\n            // automatically prefer it if configured.\n            elseif (extension_loaded('mbstring'))\n                $f->size = mb_strlen($file['data'], '8bit');\n            // bootstrap.php include a compat version of mb_strlen\n            else\n                $f->size = strlen($file['data']);\n        }\n\n        $f->save();\n        return $f;\n    }\n\n    static function __create($file, &$errors) {\n        return static::create($file);\n    }\n\n    /**\n     * Migrate this file from the current backend to the backend specified.\n     *\n     * Parameters:\n     * $bk - (string) type char of the target storage backend. Use\n     *      AttachmentStorageBackend::allRegistered() to get a list of type\n     *      chars and associated class names\n     *\n     * Returns:\n     * True if the migration was successful and false otherwise.\n     */\n    function migrate($bk) {\n\n        // Copy the file to the new backend and hash the contents\n        $target = FileStorageBackend::lookup($bk, $this);\n        $source = $this->open();\n\n        // Initialize hashing algorithm to verify uploaded contents\n        $algos = $target->getNativeHashAlgos();\n        $common_algo = 'sha1';\n        if ($algos && is_array($algos)) {\n            $supported = hash_algos();\n            foreach ($algos as $a) {\n                if (in_array(strtolower($a), $supported)) {\n                    $common_algo = strtolower($a);\n                    break;\n                }\n            }\n        }\n        $before = hash_init($common_algo);\n        // TODO: Make this resumable so that if the file cannot be migrated\n        //      in the max_execution_time, the migration can be continued\n        //      the next time the cron runs\n        try {\n            while ($block = $source->read($target->getBlockSize())) {\n                hash_update($before, $block);\n                $target->write($block);\n            }\n            $target->flush();\n        }\n        catch (Exception $e) {\n            // Migration failed\n            return false;\n        }\n\n        // Ask the backend to generate its own hash if at all possible\n        if (!($target_hash = $target->getHashDigest($common_algo))) {\n            $after = hash_init($common_algo);\n            // Verify that the hash of the target file matches the hash of\n            // the source file\n            $target = FileStorageBackend::lookup($bk, $this);\n            while ($block = $target->read())\n                hash_update($after, $block);\n            $target_hash = hash_final($after);\n        }\n\n        if (hash_final($before) != $target_hash) {\n            $target->unlink();\n            return false;\n        }\n\n        $this->bk = $target->getBkChar();\n        if (!$this->save())\n            return false;\n\n        return $source->unlink();\n    }\n\n    /**\n     * Considers the system's configuration for file storage selection based\n     * on the file information and purpose (FAQ attachment, image, etc).\n     *\n     * Parameters:\n     * $file - (hasharray) file information which would be passed to\n     * ::save() for instance.\n     *\n     * Returns:\n     * Instance<FileStorageBackend> backend selected based on the file\n     * received.\n     */\n    static function getBackendForFile($file) {\n        global $cfg;\n\n        $char = null;\n        if ($cfg) {\n            $char = $cfg->getDefaultStorageBackendChar();\n        }\n        try {\n            return FileStorageBackend::lookup($char ?: 'D', $file);\n        }\n        catch (Exception $x) {\n            return new AttachmentChunkedData($file);\n        }\n    }\n\n    static function lookupByHash($hash) {\n        if (isset(static::$keyCache[$hash]))\n            return static::$keyCache[$hash];\n\n        // Cache a negative lookup if no such file exists\n        return parent::lookup(array('key' => $hash));\n    }\n\n    static function lookup($id) {\n        return is_string($id)\n            ? static::lookupByHash($id)\n            : parent::lookup($id);\n    }\n\n    /*\n      Method formats http based $_FILE uploads - plus basic validation.\n     */\n    function format($files) {\n        global $ost;\n\n        if(!$files || !is_array($files))\n            return null;\n\n        //Reformat $_FILE  for the sane.\n        $attachments = array();\n        foreach($files as $k => $a) {\n            if(is_array($a))\n                foreach($a as $i => $v)\n                    $attachments[$i][$k] = $v;\n        }\n\n        //Basic validation.\n        foreach($attachments as $i => &$file) {\n            $file['name'] = Format::sanitize($file['name']);\n\n            //skip no file upload \"error\" - why PHP calls it an error is beyond me.\n            if($file['error'] && $file['error']==UPLOAD_ERR_NO_FILE) {\n                unset($attachments[$i]);\n                continue;\n            }\n\n            if($file['error']) //PHP defined error!\n                $file['error'] = 'File upload error #'.$file['error'];\n            elseif(!$file['tmp_name'] || !is_uploaded_file($file['tmp_name']))\n                $file['error'] = 'Invalid or bad upload POST';\n        }\n        unset($file);\n\n        return array_filter($attachments);\n    }\n\n    /**\n     * Removes files and associated meta-data for files which no ticket,\n     * canned-response, or faq point to any more.\n     */\n    static function deleteOrphans() {\n\n        // XXX: Allow plugins to define filetypes which do not represent\n        //      files attached to tickets or other things in the attachment\n        //      table and are not logos\n        $files = static::objects()\n            ->filter(array(\n                'attachments__object_id__isnull' => true,\n                'ft' => 'T',\n                'created__lt' => SqlFunction::NOW()->minus(SqlInterval::DAY(1)),\n            ));\n\n        foreach ($files as $f) {\n            if (!$f->delete())\n                break;\n        }\n\n        return true;\n    }\n\n    static function allLogos() {\n        return static::objects()\n            ->filter(array('ft' => 'L'))\n            ->order_by('created');\n    }\n\n    static function allBackdrops() {\n        return static::objects()\n            ->filter(array('ft' => 'B'))\n            ->order_by('created');\n    }\n}\n\nclass FileStorageBackend {\n    var $meta;\n    static $desc = false;\n    static $registry;\n    static $blocksize = 131072;\n    static $private = false;\n\n    /**\n     * All storage backends should call this function during the request\n     * bootstrap phase.\n     */\n    static function register($typechar, $class) {\n        self::$registry[$typechar] = $class;\n    }\n\n    static function allRegistered($private=false) {\n        $R = self::$registry;\n        if (!$private) {\n            foreach ($R as $i=>$bk) {\n                if ($bk::$private)\n                    unset($R[$i]);\n            }\n        }\n        return $R;\n    }\n\n    /**\n     * Retrieves the type char registered for this storage backend's class.\n     * Null is returned if the backend is not properly registered.\n     */\n    function getBkChar() {\n        foreach (self::$registry as $tc=>$class)\n            if ($this instanceof $class)\n                return $tc;\n    }\n\n    static function isRegistered($type) {\n        return isset(self::$registry[$type]);\n    }\n\n    static function lookup($type, $file=null) {\n        if (!isset(self::$registry[$type]))\n            throw new Exception(\"No such backend registered\");\n\n        $class = self::$registry[$type];\n        return new $class($file);\n    }\n\n    static function getInstance($file) {\n        if (!isset(self::$registry[$file->getBackend()]))\n            throw new Exception(\"No such backend registered\");\n\n        $class = self::$registry[$file->getBackend()];\n        return new $class($file);\n    }\n\n    /**\n     * Returns the optimal block size for the backend. When migrating, this\n     * size blocks would be best for sending to the ::write() method\n     */\n    function getBlockSize() {\n        return static::$blocksize;\n    }\n\n    /**\n     * Create an instance of the storage backend linking the related file.\n     * Information about the file metadata is accessible via the received\n     * filed object.\n     */\n    function __construct($meta) {\n        $this->meta = $meta;\n    }\n\n    /**\n     * Commit file to the storage backend. This method is used if the\n     * backend cannot support writing a file directly. Otherwise, the\n     * ::upload($file) method is preferred.\n     *\n     * Parameters:\n     * $data - (string|binary) file contents to be written to the backend\n     */\n    function write($data) {\n        return false;\n    }\n\n    /**\n     * Called after all the blocks are sent to the ::write() method. This\n     * method should return boolean FALSE if flushing the data was\n     * somehow inhibited.\n     */\n    function flush() {\n        return true;\n    }\n\n    /**\n     * Upload a file to the backend. This method is preferred over ::write()\n     * for files which are uploaded or are otherwise available out of\n     * memory. The backend is encouraged to avoid reading the entire\n     * contents into memory.\n     */\n    function upload($filepath) {\n        return $this->write(file_get_contents($filepath));\n    }\n\n    /**\n     * Returns data from the backend, optionally returning only the number\n     * of bytes indicated at the specified offset. If the data is available\n     * in chunks, one chunk may be returned at a time. The backend should\n     * return boolean false when no more chunks are available.\n     */\n    function read($amount=0, $offset=0) {\n        return false;\n    }\n\n    /**\n     * Convenience method to send all the file to standard output\n     */\n    function passthru() {\n        while ($block = $this->read())\n            echo $block;\n    }\n\n    /**\n     * If the data is not stored or not available locally, a redirect\n     * response can be sent to the user agent indicating the actual HTTP\n     * location of the data.\n     *\n     * If the data is available locally, this method should return boolean\n     * false to indicate that the read() method should be used to retrieve\n     * the data and broker it to the user agent.\n     */\n    function sendRedirectUrl($disposition='inline') {\n        return false;\n    }\n\n    /**\n     * Requests the backend to remove the file contents.\n     */\n    function unlink() {\n        return false;\n    }\n\n    /**\n     * Fetches a list of hash algorithms that are supported transparently\n     * through the ::write() and ::upload() methods. After writing or\n     * uploading file content, the ::getHashDigest($algo) method can be\n     * called to get a hash of the remote content without fetching the\n     * entire data stream to verify the content locally.\n     */\n    function getNativeHashAlgos() {\n        return array();\n    }\n\n    /**\n     * Returns a hash of the content calculated remotely by the storage\n     * backend. If this method fails, the hash chould be calculated by\n     * downloading the content and hashing locally\n     */\n    function getHashDigest($algo) {\n        return false;\n    }\n\n    /**\n     * getSize\n     *\n     * Retrieves the size of the contents written or available to be read.\n     * The backend should optimize this process if possible by keeping track\n     * of the bytes written in a way apart from `strlen`. This value will be\n     * used instead of inspecting the contents using `strlen`.\n     */\n    function getSize() {\n        return false;\n    }\n}\n\n\n/**\n * Attachments stored in the database are cut into 500kB chunks and stored\n * in the FILE_CHUNK_TABLE to overcome the max_allowed_packet limitation of\n * LOB fields in the MySQL database\n */\ndefine('CHUNK_SIZE', 500*1024); # Beware if you change this...\nclass AttachmentFileChunk extends VerySimpleModel {\n    static $meta = array(\n        'table' => FILE_CHUNK_TABLE,\n        'pk' => array('file_id', 'chunk_id'),\n        'joins' => array(\n            'file' => array(\n                'constraint' => array('file_id' => 'AttachmentFile.id'),\n            ),\n        ),\n    );\n}\n\nclass AttachmentChunkedData extends FileStorageBackend {\n    static $desc = /* @trans */ \"In the database\";\n    static $blocksize = CHUNK_SIZE;\n\n    function __construct($file) {\n        $this->file = $file;\n        $this->_chunk = 0;\n        $this->_buffer = false;\n        $this->eof = false;\n    }\n\n    function getSize() {\n        $row = AttachmentFileChunk::objects()\n            ->filter(array('file' => $this->file))\n            ->aggregate(array('length' => SqlAggregate::SUM(SqlFunction::LENGTH(new SqlField('filedata')))))\n            ->one();\n        return $row['length'];\n    }\n\n    function read($amount=CHUNK_SIZE, $offset=0) {\n        # Read requested length of data from attachment chunks\n        if ($this->eof)\n            return false;\n\n        while (strlen($this->_buffer) < $amount + $offset) {\n            try {\n                list($buf) = AttachmentFileChunk::objects()\n                    ->filter(array('file' => $this->file, 'chunk_id' => $this->_chunk++))\n                    ->values_flat('filedata')\n                    ->one();\n            }\n            catch (DoesNotExist $e) {\n                $this->eof = true;\n                break;\n            }\n            $this->_buffer .= $buf;\n        }\n        $chunk = substr($this->_buffer, $offset, $amount);\n        $this->_buffer = substr($this->_buffer, $offset + $amount);\n        return $chunk;\n    }\n\n    function write($what, $chunk_size=CHUNK_SIZE) {\n        $offset=0;\n        while ($block = substr($what, $offset, $chunk_size)) {\n            // Chunks are considered immutable. Importing chunks should\n            // forceable remove the contents of a file before write()ing new\n            // chunks. Therefore, inserts should be safe.\n            $chunk = new AttachmentFileChunk(array(\n                'file' => $this->file,\n                'chunk_id' => $this->_chunk++,\n                'filedata' => $block\n            ));\n            if (!$chunk->save())\n                return false;\n            $offset += strlen($block);\n        }\n\n        return $this->_chunk;\n    }\n\n    function unlink() {\n        return AttachmentFileChunk::objects()\n            ->filter(array('file' => $this->file))\n            ->delete();\n    }\n}\nFileStorageBackend::register('D', 'AttachmentChunkedData');\n\n/**\n * This class provides an interface for files attached on the filesystem in\n * versions previous to v1.7. The upgrader will keep the attachments on the\n * disk where they were and write the path into the `attrs` field of the\n * %file table. This module will continue to serve those files until they\n * are migrated with the `file` cli app\n */\nclass OneSixAttachments extends FileStorageBackend {\n    static $desc = \"upload_dir folder (from osTicket v1.6)\";\n    static $private = true;\n\n    function read($bytes=32768, $offset=false) {\n        $filename = $this->meta->attrs;\n        if (!$this->fp)\n            $this->fp = @fopen($filename, 'rb');\n        if (!$this->fp)\n            throw new IOException($filename.': Unable to open for reading');\n        if ($offset)\n            fseek($this->fp, $offset);\n        if (($status = @fread($this->fp, $bytes)) === false)\n            throw new IOException($filename.': Unable to read from file');\n        return $status;\n    }\n\n    function passthru() {\n        $filename = $this->meta->attrs;\n        if (($status = @readfile($filename)) === false)\n            throw new IOException($filename.': Unable to read from file');\n        return $status;\n    }\n\n    function write($data) {\n        throw new IOException('This backend does not support new files');\n    }\n\n    function upload($filepath) {\n        throw new IOException('This backend does not support new files');\n    }\n\n    function unlink() {\n        $filename = $this->meta->attrs;\n        if (!@unlink($filename))\n            throw new IOException($filename.': Unable to delete file');\n        // Drop usage of the `attrs` field\n        $this->meta->attrs = null;\n        $this->meta->save();\n        return true;\n    }\n}\nFileStorageBackend::register('6', 'OneSixAttachments');\n\n// FileObject - wrapper for SplFileObject class\nclass FileObject extends SplFileObject {\n\n    protected $_filename;\n\n    function __construct($file, $mode='r') {\n        parent::__construct($file, $mode);\n    }\n\n    /* This allows us to set REAL file name as opposed to basename of the\n     * FS file in question\n     */\n    function setFilename($filename) {\n        $this->_filename = $filename;\n    }\n\n    function getFilename() {\n        return $this->_filename ?: parent::getFilename();\n    }\n\n    /*\n     * Set mime type - well formated mime is expected.\n     */\n    function setMimeType($type) {\n        $this->_mimetype = $type;\n    }\n\n    function getMimeType() {\n        if (!isset($this->_mimetype)) {\n            // Try to to auto-detect mime type\n            $finfo = new finfo(FILEINFO_MIME);\n            $this->_mimetype = $finfo->buffer($this->getContents(),\n                    FILEINFO_MIME_TYPE);\n        }\n\n        return $this->_mimetype;\n    }\n\n    function getContents() {\n        $this->fseek(0);\n        return $this->fread($this->getSize());\n    }\n\n    /*\n     * XXX: Needed for mailer attachments interface\n     */\n    function getData() {\n        return $this->getContents();\n    }\n}\n\n?>\n"], "filenames": ["include/ajax.draft.php", "include/ajax.forms.php", "include/ajax.i18n.php", "include/class.file.php"], "buggy_code_start_loc": [18, 384, 51, 635], "buggy_code_end_loc": [371, 406, 144, 635], "fixing_code_start_loc": [19, 385, 52, 636], "fixing_code_end_loc": [376, 409, 148, 638], "type": "CWE-79", "message": "osTicket before 1.14.3 allows XSS via a crafted filename to DraftAjaxAPI::_uploadInlineImage() in include/ajax.draft.php.", "other": {"cve": {"id": "CVE-2020-24917", "sourceIdentifier": "cve@mitre.org", "published": "2020-08-30T16:15:14.230", "lastModified": "2020-09-03T18:19:41.233", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "osTicket before 1.14.3 allows XSS via a crafted filename to DraftAjaxAPI::_uploadInlineImage() in include/ajax.draft.php."}, {"lang": "es", "value": "osTicket versiones anteriores a 1.14.3, permite un ataque XSS por medio de un nombre de archivo dise\u00f1ado en la funci\u00f3n DraftAjaxAPI::_uploadInlineImage() en el archivo include/ajax.draft.php"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:osticket:osticket:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.14.3", "matchCriteriaId": "228BD49A-F6C5-404D-9644-82F3B48F7F73"}]}]}], "references": [{"url": "https://github.com/osTicket/osTicket/commit/518de223933eab0c5558741ce317f36958ef193d", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/osTicket/osTicket/compare/v1.14.2...v1.14.3", "source": "cve@mitre.org", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://sisl.lab.uic.edu/projects/chess/osticket-xss/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/osTicket/osTicket/commit/518de223933eab0c5558741ce317f36958ef193d"}}