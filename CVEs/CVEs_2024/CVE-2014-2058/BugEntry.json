{"buggy_code": ["/*\n * The MIT License\n * \n * Copyright (c) 2004-2011, Sun Microsystems, Inc., Kohsuke Kawaguchi,\n * Brian Westrich, Erik Ramfelt, Ertan Deniz, Jean-Baptiste Quenot,\n * Luca Domenico Milanesio, R. Tyler Ballance, Stephen Connolly, Tom Huybrechts,\n * id:cactusman, Yahoo! Inc., Andrew Bayer, Manufacture Francaise des Pneumatiques\n * Michelin, Romain Seguy\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n * \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\npackage hudson.model;\n\nimport com.infradna.tool.bridge_method_injector.WithBridgeMethods;\nimport hudson.EnvVars;\nimport hudson.Functions;\nimport antlr.ANTLRException;\nimport hudson.AbortException;\nimport hudson.CopyOnWrite;\nimport hudson.FeedAdapter;\nimport hudson.FilePath;\nimport hudson.Launcher;\nimport hudson.Util;\nimport hudson.cli.declarative.CLIMethod;\nimport hudson.cli.declarative.CLIResolver;\nimport hudson.model.Cause.LegacyCodeCause;\nimport hudson.model.Cause.RemoteCause;\nimport hudson.model.Cause.UserIdCause;\nimport hudson.model.Descriptor.FormException;\nimport hudson.model.Fingerprint.RangeSet;\nimport hudson.model.Queue.Executable;\nimport hudson.model.Queue.Task;\nimport hudson.model.queue.QueueTaskFuture;\nimport hudson.model.queue.SubTask;\nimport hudson.model.Queue.WaitingItem;\nimport hudson.model.RunMap.Constructor;\nimport hudson.model.labels.LabelAtom;\nimport hudson.model.labels.LabelExpression;\nimport hudson.model.listeners.SCMPollListener;\nimport hudson.model.queue.CauseOfBlockage;\nimport hudson.model.queue.SubTaskContributor;\nimport hudson.scm.ChangeLogSet;\nimport hudson.scm.ChangeLogSet.Entry;\nimport hudson.scm.NullSCM;\nimport hudson.scm.PollingResult;\nimport hudson.scm.SCM;\nimport hudson.scm.SCMRevisionState;\nimport hudson.scm.SCMS;\nimport hudson.search.SearchIndexBuilder;\nimport hudson.security.ACL;\nimport hudson.security.Permission;\nimport hudson.slaves.WorkspaceList;\nimport hudson.tasks.BuildStep;\nimport hudson.tasks.BuildStepDescriptor;\nimport hudson.tasks.BuildTrigger;\nimport hudson.tasks.BuildWrapperDescriptor;\nimport hudson.tasks.Publisher;\nimport hudson.triggers.SCMTrigger;\nimport hudson.triggers.Trigger;\nimport hudson.triggers.TriggerDescriptor;\nimport hudson.util.AlternativeUiTextProvider;\nimport hudson.util.AlternativeUiTextProvider.Message;\nimport hudson.util.DescribableList;\nimport hudson.util.EditDistance;\nimport hudson.util.FormValidation;\nimport hudson.widgets.BuildHistoryWidget;\nimport hudson.widgets.HistoryWidget;\nimport jenkins.model.Jenkins;\nimport jenkins.model.JenkinsLocationConfiguration;\nimport jenkins.model.lazy.AbstractLazyLoadRunMap.Direction;\nimport jenkins.scm.DefaultSCMCheckoutStrategyImpl;\nimport jenkins.scm.SCMCheckoutStrategy;\nimport jenkins.scm.SCMCheckoutStrategyDescriptor;\nimport jenkins.util.TimeDuration;\nimport net.sf.json.JSONObject;\nimport org.acegisecurity.context.SecurityContext;\nimport org.acegisecurity.context.SecurityContextHolder;\nimport org.kohsuke.accmod.Restricted;\nimport org.kohsuke.accmod.restrictions.NoExternalUse;\nimport org.kohsuke.args4j.Argument;\nimport org.kohsuke.args4j.CmdLineException;\nimport org.kohsuke.stapler.ForwardToView;\nimport org.kohsuke.stapler.HttpRedirect;\nimport org.kohsuke.stapler.HttpResponse;\nimport org.kohsuke.stapler.HttpResponses;\nimport org.kohsuke.stapler.QueryParameter;\nimport org.kohsuke.stapler.StaplerRequest;\nimport org.kohsuke.stapler.StaplerResponse;\nimport org.kohsuke.stapler.export.Exported;\nimport org.kohsuke.stapler.interceptor.RequirePOST;\n\nimport javax.servlet.ServletException;\nimport java.io.File;\nimport java.io.IOException;\nimport java.lang.reflect.InvocationTargetException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Calendar;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.SortedMap;\nimport java.util.TreeMap;\nimport java.util.Vector;\nimport java.util.concurrent.Future;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\nimport static hudson.scm.PollingResult.*;\nimport static javax.servlet.http.HttpServletResponse.*;\n\n/**\n * Base implementation of {@link Job}s that build software.\n *\n * For now this is primarily the common part of {@link Project} and MavenModule.\n *\n * @author Kohsuke Kawaguchi\n * @see AbstractBuild\n */\n@SuppressWarnings(\"rawtypes\")\npublic abstract class AbstractProject<P extends AbstractProject<P,R>,R extends AbstractBuild<P,R>> extends Job<P,R> implements BuildableItem {\n\n    /**\n     * {@link SCM} associated with the project.\n     * To allow derived classes to link {@link SCM} config to elsewhere,\n     * access to this variable should always go through {@link #getScm()}.\n     */\n    private volatile SCM scm = new NullSCM();\n\n    /**\n     * Controls how the checkout is done.\n     */\n    private volatile SCMCheckoutStrategy scmCheckoutStrategy;\n\n    /**\n     * State returned from {@link SCM#poll(AbstractProject, Launcher, FilePath, TaskListener, SCMRevisionState)}.\n     */\n    private volatile transient SCMRevisionState pollingBaseline = null;\n\n    /**\n     * All the builds keyed by their build number.\n     *\n     * External code should use {@link #getBuildByNumber(int)} or {@link #getLastBuild()} and traverse via\n     * {@link Run#getPreviousBuild()}\n     */\n    @Restricted(NoExternalUse.class)\n    @SuppressWarnings(\"deprecation\") // [JENKINS-15156] builds accessed before onLoad or onCreatedFromScratch called\n    protected transient RunMap<R> builds = new RunMap<R>();\n\n    /**\n     * The quiet period. Null to delegate to the system default.\n     */\n    private volatile Integer quietPeriod = null;\n    \n    /**\n     * The retry count. Null to delegate to the system default.\n     */\n    private volatile Integer scmCheckoutRetryCount = null;\n\n    /**\n     * If this project is configured to be only built on a certain label,\n     * this value will be set to that label.\n     *\n     * For historical reasons, this is called 'assignedNode'. Also for\n     * a historical reason, null to indicate the affinity\n     * with the master node.\n     *\n     * @see #canRoam\n     */\n    private String assignedNode;\n\n    /**\n     * True if this project can be built on any node.\n     *\n     * <p>\n     * This somewhat ugly flag combination is so that we can migrate\n     * existing Hudson installations nicely.\n     */\n    private volatile boolean canRoam;\n\n    /**\n     * True to suspend new builds.\n     */\n    protected volatile boolean disabled;\n\n    /**\n     * True to keep builds of this project in queue when downstream projects are\n     * building. False by default to keep from breaking existing behavior.\n     */\n    protected volatile boolean blockBuildWhenDownstreamBuilding = false;\n\n    /**\n     * True to keep builds of this project in queue when upstream projects are\n     * building. False by default to keep from breaking existing behavior.\n     */\n    protected volatile boolean blockBuildWhenUpstreamBuilding = false;\n\n    /**\n     * Identifies {@link JDK} to be used.\n     * Null if no explicit configuration is required.\n     *\n     * <p>\n     * Can't store {@link JDK} directly because {@link Jenkins} and {@link Project}\n     * are saved independently.\n     *\n     * @see Jenkins#getJDK(String)\n     */\n    private volatile String jdk;\n\n    private volatile BuildAuthorizationToken authToken = null;\n\n    /**\n     * List of all {@link Trigger}s for this project.\n     */\n    protected List<Trigger<?>> triggers = new Vector<Trigger<?>>();\n\n    /**\n     * {@link Action}s contributed from subsidiary objects associated with\n     * {@link AbstractProject}, such as from triggers, builders, publishers, etc.\n     *\n     * We don't want to persist them separately, and these actions\n     * come and go as configuration change, so it's kept separate.\n     */\n    @CopyOnWrite\n    protected transient volatile List<Action> transientActions = new Vector<Action>();\n\n    private boolean concurrentBuild;\n\n    /**\n     * See {@link #setCustomWorkspace(String)}.\n     *\n     * @since 1.410\n     */\n    private String customWorkspace;\n    \n    protected AbstractProject(ItemGroup parent, String name) {\n        super(parent,name);\n\n        if(!Jenkins.getInstance().getNodes().isEmpty()) {\n            // if a new job is configured with Hudson that already has slave nodes\n            // make it roamable by default\n            canRoam = true;\n        }\n    }\n\n    @Override\n    public synchronized void save() throws IOException {\n        super.save();\n        updateTransientActions();\n    }\n\n    @Override\n    public void onCreatedFromScratch() {\n        super.onCreatedFromScratch();\n        builds = createBuildRunMap();\n        // solicit initial contributions, especially from TransientProjectActionFactory\n        updateTransientActions();\n    }\n\n    @Override\n    public void onLoad(ItemGroup<? extends Item> parent, String name) throws IOException {\n        super.onLoad(parent, name);\n\n        RunMap<R> builds = createBuildRunMap();\n\n        RunMap<R> currentBuilds = this.builds;\n\n        if (currentBuilds==null) {\n            // are we overwriting what currently exist?\n            // this is primarily when Jenkins is getting reloaded\n            Item current = parent.getItem(name);\n            if (current!=null && current.getClass()==getClass()) {\n                currentBuilds = ((AbstractProject)current).builds;\n            }\n        }\n        if (currentBuilds !=null) {\n            // if we are reloading, keep all those that are still building intact\n            for (R r : currentBuilds.getLoadedBuilds().values()) {\n                if (r.isBuilding())\n                    builds.put(r);\n            }\n        }\n        this.builds = builds;\n        for (Trigger t : triggers())\n            t.start(this, Items.updatingByXml.get());\n        if(scm==null)\n            scm = new NullSCM(); // perhaps it was pointing to a plugin that no longer exists.\n\n        if(transientActions==null)\n            transientActions = new Vector<Action>();    // happens when loaded from disk\n        updateTransientActions();\n    }\n\n    private RunMap<R> createBuildRunMap() {\n        return new RunMap<R>(getBuildDir(), new Constructor<R>() {\n            public R create(File dir) throws IOException {\n                return loadBuild(dir);\n            }\n        });\n    }\n\n    private synchronized List<Trigger<?>> triggers() {\n        if (triggers == null) {\n            triggers = new Vector<Trigger<?>>();\n        }\n        return triggers;\n    }\n\n    @Override\n    public EnvVars getEnvironment(Node node, TaskListener listener) throws IOException, InterruptedException {\n        EnvVars env =  super.getEnvironment(node, listener);\n\n        JDK jdk = getJDK();\n        if (jdk != null) {\n            if (node != null) { // just in case were not in a build\n                jdk = jdk.forNode(node, listener);\n            }\n            jdk.buildEnvVars(env);\n        }\n\n        return env;\n    }\n\n    @Override\n    protected void performDelete() throws IOException, InterruptedException {\n        // prevent a new build while a delete operation is in progress\n        makeDisabled(true);\n        FilePath ws = getWorkspace();\n        if(ws!=null) {\n            Node on = getLastBuiltOn();\n            getScm().processWorkspaceBeforeDeletion(this, ws, on);\n            if(on!=null)\n                on.getFileSystemProvisioner().discardWorkspace(this,ws);\n        }\n        super.performDelete();\n    }\n\n    /**\n     * Does this project perform concurrent builds?\n     * @since 1.319\n     */\n    @Exported\n    public boolean isConcurrentBuild() {\n        return concurrentBuild;\n    }\n\n    public void setConcurrentBuild(boolean b) throws IOException {\n        concurrentBuild = b;\n        save();\n    }\n\n    /**\n     * If this project is configured to be always built on this node,\n     * return that {@link Node}. Otherwise null.\n     */\n    public Label getAssignedLabel() {\n        if(canRoam)\n            return null;\n\n        if(assignedNode==null)\n            return Jenkins.getInstance().getSelfLabel();\n        return Jenkins.getInstance().getLabel(assignedNode);\n    }\n\n    /**\n     * Set of labels relevant to this job.\n     *\n     * This method is used to determine what slaves are relevant to jobs, for example by {@link View}s.\n     * It does not affect the scheduling. This information is informational and the best-effort basis.\n     *\n     * @since 1.456\n     * @return\n     *      Minimally it should contain {@link #getAssignedLabel()}. The set can contain null element\n     *      to correspond to the null return value from {@link #getAssignedLabel()}.\n     */\n    public Set<Label> getRelevantLabels() {\n        return Collections.singleton(getAssignedLabel());\n    }\n\n    /**\n     * Gets the textual representation of the assigned label as it was entered by the user.\n     */\n    public String getAssignedLabelString() {\n        if (canRoam || assignedNode==null)    return null;\n        try {\n            LabelExpression.parseExpression(assignedNode);\n            return assignedNode;\n        } catch (ANTLRException e) {\n            // must be old label or host name that includes whitespace or other unsafe chars\n            return LabelAtom.escape(assignedNode);\n        }\n    }\n\n    /**\n     * Sets the assigned label.\n     */\n    public void setAssignedLabel(Label l) throws IOException {\n        if(l==null) {\n            canRoam = true;\n            assignedNode = null;\n        } else {\n            canRoam = false;\n            if(l== Jenkins.getInstance().getSelfLabel())  assignedNode = null;\n            else                                        assignedNode = l.getExpression();\n        }\n        save();\n    }\n\n    /**\n     * Assigns this job to the given node. A convenience method over {@link #setAssignedLabel(Label)}.\n     */\n    public void setAssignedNode(Node l) throws IOException {\n        setAssignedLabel(l.getSelfLabel());\n    }\n\n    /**\n     * Get the term used in the UI to represent this kind of {@link AbstractProject}.\n     * Must start with a capital letter.\n     */\n    @Override\n    public String getPronoun() {\n        return AlternativeUiTextProvider.get(PRONOUN, this,Messages.AbstractProject_Pronoun());\n    }\n\n    /**\n     * Gets the human readable display name to be rendered in the \"Build Now\" link.\n     *\n     * @since 1.401\n     */\n    public String getBuildNowText() {\n        return AlternativeUiTextProvider.get(BUILD_NOW_TEXT,this,Messages.AbstractProject_BuildNow());\n    }\n\n    /**\n     * Gets the nearest ancestor {@link TopLevelItem} that's also an {@link AbstractProject}.\n     *\n     * <p>\n     * Some projects (such as matrix projects, Maven projects, or promotion processes) form a tree of jobs\n     * that acts as a single unit. This method can be used to find the top most dominating job that\n     * covers such a tree.\n     *\n     * @return never null.\n     * @see AbstractBuild#getRootBuild()\n     */\n    public AbstractProject<?,?> getRootProject() {\n        if (this instanceof TopLevelItem) {\n            return this;\n        } else {\n            ItemGroup p = this.getParent();\n            if (p instanceof AbstractProject)\n                return ((AbstractProject) p).getRootProject();\n            return this;\n        }\n    }\n\n    /**\n     * Gets the directory where the module is checked out.\n     *\n     * @return\n     *      null if the workspace is on a slave that's not connected.\n     * @deprecated as of 1.319\n     *      To support concurrent builds of the same project, this method is moved to {@link AbstractBuild}.\n     *      For backward compatibility, this method returns the right {@link AbstractBuild#getWorkspace()} if called\n     *      from {@link Executor}, and otherwise the workspace of the last build.\n     *\n     *      <p>\n     *      If you are calling this method during a build from an executor, switch it to {@link AbstractBuild#getWorkspace()}.\n     *      If you are calling this method to serve a file from the workspace, doing a form validation, etc., then\n     *      use {@link #getSomeWorkspace()}\n     */\n    public final FilePath getWorkspace() {\n        AbstractBuild b = getBuildForDeprecatedMethods();\n        return b != null ? b.getWorkspace() : null;\n\n    }\n    \n    /**\n     * Various deprecated methods in this class all need the 'current' build.  This method returns\n     * the build suitable for that purpose.\n     * \n     * @return An AbstractBuild for deprecated methods to use.\n     */\n    private AbstractBuild getBuildForDeprecatedMethods() {\n        Executor e = Executor.currentExecutor();\n        if(e!=null) {\n            Executable exe = e.getCurrentExecutable();\n            if (exe instanceof AbstractBuild) {\n                AbstractBuild b = (AbstractBuild) exe;\n                if(b.getProject()==this)\n                    return b;\n            }\n        }\n        R lb = getLastBuild();\n        if(lb!=null)    return lb;\n        return null;\n    }\n\n    /**\n     * Gets a workspace for some build of this project.\n     *\n     * <p>\n     * This is useful for obtaining a workspace for the purpose of form field validation, where exactly\n     * which build the workspace belonged is less important. The implementation makes a cursory effort\n     * to find some workspace.\n     *\n     * @return\n     *      null if there's no available workspace.\n     * @since 1.319\n     */\n    public final FilePath getSomeWorkspace() {\n        R b = getSomeBuildWithWorkspace();\n        if (b!=null) return b.getWorkspace();\n        for (WorkspaceBrowser browser : Jenkins.getInstance().getExtensionList(WorkspaceBrowser.class)) {\n            FilePath f = browser.getWorkspace(this);\n            if (f != null) return f;\n        }\n        return null;\n    }\n\n    /**\n     * Gets some build that has a live workspace.\n     *\n     * @return null if no such build exists.\n     */\n    public final R getSomeBuildWithWorkspace() {\n        int cnt=0;\n        for (R b = getLastBuild(); cnt<5 && b!=null; b=b.getPreviousBuild()) {\n            FilePath ws = b.getWorkspace();\n            if (ws!=null)   return b;\n        }\n        return null;\n    }\n\n    /**\n     * Returns the root directory of the checked-out module.\n     * <p>\n     * This is usually where <tt>pom.xml</tt>, <tt>build.xml</tt>\n     * and so on exists.\n     *\n     * @deprecated as of 1.319\n     *      See {@link #getWorkspace()} for a migration strategy.\n     */\n    public FilePath getModuleRoot() {\n        AbstractBuild b = getBuildForDeprecatedMethods();\n        return b != null ? b.getModuleRoot() : null;\n    }\n\n    /**\n     * Returns the root directories of all checked-out modules.\n     * <p>\n     * Some SCMs support checking out multiple modules into the same workspace.\n     * In these cases, the returned array will have a length greater than one.\n     * @return The roots of all modules checked out from the SCM.\n     *\n     * @deprecated as of 1.319\n     *      See {@link #getWorkspace()} for a migration strategy.\n     */\n    public FilePath[] getModuleRoots() {\n        AbstractBuild b = getBuildForDeprecatedMethods();\n        return b != null ? b.getModuleRoots() : null;\n    }\n\n    public int getQuietPeriod() {\n        return quietPeriod!=null ? quietPeriod : Jenkins.getInstance().getQuietPeriod();\n    }\n\n    public SCMCheckoutStrategy getScmCheckoutStrategy() {\n        return scmCheckoutStrategy == null ? new DefaultSCMCheckoutStrategyImpl() : scmCheckoutStrategy;\n    }\n\n    public void setScmCheckoutStrategy(SCMCheckoutStrategy scmCheckoutStrategy) throws IOException {\n        this.scmCheckoutStrategy = scmCheckoutStrategy;\n        save();\n    }\n\n\n    public int getScmCheckoutRetryCount() {\n        return scmCheckoutRetryCount !=null ? scmCheckoutRetryCount : Jenkins.getInstance().getScmCheckoutRetryCount();\n    }\n\n    // ugly name because of EL\n    public boolean getHasCustomQuietPeriod() {\n        return quietPeriod!=null;\n    }\n\n    /**\n     * Sets the custom quiet period of this project, or revert to the global default if null is given. \n     */\n    public void setQuietPeriod(Integer seconds) throws IOException {\n        this.quietPeriod = seconds;\n        save();\n    }\n    \n    public boolean hasCustomScmCheckoutRetryCount(){\n        return scmCheckoutRetryCount != null;\n    }\n\n    @Override\n    public boolean isBuildable() {\n        return !isDisabled() && !isHoldOffBuildUntilSave();\n    }\n\n    /**\n     * Used in <tt>sidepanel.jelly</tt> to decide whether to display\n     * the config/delete/build links.\n     */\n    public boolean isConfigurable() {\n        return true;\n    }\n\n    public boolean blockBuildWhenDownstreamBuilding() {\n        return blockBuildWhenDownstreamBuilding;\n    }\n\n    public void setBlockBuildWhenDownstreamBuilding(boolean b) throws IOException {\n        blockBuildWhenDownstreamBuilding = b;\n        save();\n    }\n\n    public boolean blockBuildWhenUpstreamBuilding() {\n        return blockBuildWhenUpstreamBuilding;\n    }\n\n    public void setBlockBuildWhenUpstreamBuilding(boolean b) throws IOException {\n        blockBuildWhenUpstreamBuilding = b;\n        save();\n    }\n\n    public boolean isDisabled() {\n        return disabled;\n    }\n    \n    /**\n     * Validates the retry count Regex\n     */\n    public FormValidation doCheckRetryCount(@QueryParameter String value)throws IOException,ServletException{\n        // retry count is optional so this is ok\n        if(value == null || value.trim().equals(\"\"))\n            return FormValidation.ok();\n        if (!value.matches(\"[0-9]*\")) {\n            return FormValidation.error(\"Invalid retry count\");\n        } \n        return FormValidation.ok();\n    }\n\n    /**\n     * Marks the build as disabled.\n     */\n    public void makeDisabled(boolean b) throws IOException {\n        if(disabled==b)     return; // noop\n        this.disabled = b;\n        if(b)\n            Jenkins.getInstance().getQueue().cancel(this);\n        save();\n    }\n\n    /**\n     * Specifies whether this project may be disabled by the user.\n     * By default, it can be only if this is a {@link TopLevelItem};\n     * would be false for matrix configurations, etc.\n     * @return true if the GUI should allow {@link #doDisable} and the like\n     * @since 1.475\n     */\n    public boolean supportsMakeDisabled() {\n        return this instanceof TopLevelItem;\n    }\n\n    public void disable() throws IOException {\n        makeDisabled(true);\n    }\n\n    public void enable() throws IOException {\n        makeDisabled(false);\n    }\n\n    @Override\n    public BallColor getIconColor() {\n        if(isDisabled())\n            return BallColor.DISABLED;\n        else\n            return super.getIconColor();\n    }\n\n    /**\n     * effectively deprecated. Since using updateTransientActions correctly\n     * under concurrent environment requires a lock that can too easily cause deadlocks.\n     *\n     * <p>\n     * Override {@link #createTransientActions()} instead.\n     */\n    protected void updateTransientActions() {\n        transientActions = createTransientActions();\n    }\n\n    protected List<Action> createTransientActions() {\n        Vector<Action> ta = new Vector<Action>();\n\n        for (JobProperty<? super P> p : Util.fixNull(properties))\n            ta.addAll(p.getJobActions((P)this));\n\n        for (TransientProjectActionFactory tpaf : TransientProjectActionFactory.all())\n            ta.addAll(Util.fixNull(tpaf.createFor(this))); // be defensive against null\n        return ta;\n    }\n\n    /**\n     * Returns the live list of all {@link Publisher}s configured for this project.\n     *\n     * <p>\n     * This method couldn't be called <tt>getPublishers()</tt> because existing methods\n     * in sub-classes return different inconsistent types.\n     */\n    public abstract DescribableList<Publisher,Descriptor<Publisher>> getPublishersList();\n\n    @Override\n    public void addProperty(JobProperty<? super P> jobProp) throws IOException {\n        super.addProperty(jobProp);\n        updateTransientActions();\n    }\n\n    public List<ProminentProjectAction> getProminentActions() {\n        List<Action> a = getActions();\n        List<ProminentProjectAction> pa = new Vector<ProminentProjectAction>();\n        for (Action action : a) {\n            if(action instanceof ProminentProjectAction)\n                pa.add((ProminentProjectAction) action);\n        }\n        return pa;\n    }\n\n    @Override\n    public void doConfigSubmit( StaplerRequest req, StaplerResponse rsp ) throws IOException, ServletException, FormException {\n        super.doConfigSubmit(req,rsp);\n\n        updateTransientActions();\n\n        Set<AbstractProject> upstream = Collections.emptySet();\n        if(req.getParameter(\"pseudoUpstreamTrigger\")!=null) {\n            upstream = new HashSet<AbstractProject>(Items.fromNameList(getParent(),req.getParameter(\"upstreamProjects\"),AbstractProject.class));\n        }\n\n        // dependency setting might have been changed by the user, so rebuild.\n        Jenkins.getInstance().rebuildDependencyGraph();\n        convertUpstreamBuildTrigger(upstream);\n\n\n        // notify the queue as the project might be now tied to different node\n        Jenkins.getInstance().getQueue().scheduleMaintenance();\n\n        // this is to reflect the upstream build adjustments done above\n        Jenkins.getInstance().rebuildDependencyGraph();\n    }\n\n    /**\n     * Reflect the submission of the pseudo 'upstream build trigger'.\n     */\n    /* package */ void convertUpstreamBuildTrigger(Set<AbstractProject> upstream) throws IOException {\n\n        SecurityContext saveCtx = ACL.impersonate(ACL.SYSTEM);\n        try {\n            for (AbstractProject<?,?> p : Jenkins.getInstance().getAllItems(AbstractProject.class)) {\n                // Don't consider child projects such as MatrixConfiguration:\n                if (!p.isConfigurable()) continue;\n                boolean isUpstream = upstream.contains(p);\n                synchronized(p) {\n                    // does 'p' include us in its BuildTrigger?\n                    DescribableList<Publisher,Descriptor<Publisher>> pl = p.getPublishersList();\n                    BuildTrigger trigger = pl.get(BuildTrigger.class);\n                    List<AbstractProject> newChildProjects = trigger == null ? new ArrayList<AbstractProject>():trigger.getChildProjects(p);\n                    if(isUpstream) {\n                        if(!newChildProjects.contains(this))\n                            newChildProjects.add(this);\n                    } else {\n                        newChildProjects.remove(this);\n                    }\n\n                    if(newChildProjects.isEmpty()) {\n                        pl.remove(BuildTrigger.class);\n                    } else {\n                        // here, we just need to replace the old one with the new one,\n                        // but there was a regression (we don't know when it started) that put multiple BuildTriggers\n                        // into the list. For us not to lose the data, we need to merge them all.\n                        List<BuildTrigger> existingList = pl.getAll(BuildTrigger.class);\n                        BuildTrigger existing;\n                        switch (existingList.size()) {\n                        case 0:\n                            existing = null;\n                            break;\n                        case 1:\n                            existing = existingList.get(0);\n                            break;\n                        default:\n                            pl.removeAll(BuildTrigger.class);\n                            Set<AbstractProject> combinedChildren = new HashSet<AbstractProject>();\n                            for (BuildTrigger bt : existingList)\n                                combinedChildren.addAll(bt.getChildProjects(p));\n                            existing = new BuildTrigger(new ArrayList<AbstractProject>(combinedChildren),existingList.get(0).getThreshold());\n                            pl.add(existing);\n                            break;\n                        }\n\n                        if(existing!=null && existing.hasSame(p,newChildProjects))\n                            continue;   // no need to touch\n                        pl.replace(new BuildTrigger(newChildProjects,\n                            existing==null? Result.SUCCESS:existing.getThreshold()));\n                    }\n                }\n            }\n        } finally {\n            SecurityContextHolder.setContext(saveCtx);\n        }\n    }\n\n    /**\n\t * @deprecated\n\t *    Use {@link #scheduleBuild(Cause)}.  Since 1.283\n\t */\n    public boolean scheduleBuild() {\n    \treturn scheduleBuild(new LegacyCodeCause());\n    }\n    \n\t/**\n\t * @deprecated\n\t *    Use {@link #scheduleBuild(int, Cause)}.  Since 1.283\n\t */\n    public boolean scheduleBuild(int quietPeriod) {\n    \treturn scheduleBuild(quietPeriod, new LegacyCodeCause());\n    }\n    \n    /**\n     * Schedules a build of this project.\n     *\n     * @return\n     *      true if the project is actually added to the queue.\n     *      false if the queue contained it and therefore the add()\n     *      was noop\n     */\n    public boolean scheduleBuild(Cause c) {\n        return scheduleBuild(getQuietPeriod(), c);\n    }\n\n    public boolean scheduleBuild(int quietPeriod, Cause c) {\n        return scheduleBuild(quietPeriod, c, new Action[0]);\n    }\n\n    /**\n     * Schedules a build.\n     *\n     * Important: the actions should be persistable without outside references (e.g. don't store\n     * references to this project). To provide parameters for a parameterized project, add a ParametersAction. If\n     * no ParametersAction is provided for such a project, one will be created with the default parameter values.\n     *\n     * @param quietPeriod the quiet period to observer\n     * @param c the cause for this build which should be recorded\n     * @param actions a list of Actions that will be added to the build\n     * @return whether the build was actually scheduled\n     */\n    public boolean scheduleBuild(int quietPeriod, Cause c, Action... actions) {\n        return scheduleBuild2(quietPeriod,c,actions)!=null;\n    }\n\n    /**\n     * Schedules a build of this project, and returns a {@link Future} object\n     * to wait for the completion of the build.\n     *\n     * @param actions\n     *      For the convenience of the caller, this array can contain null, and those will be silently ignored.\n     */\n    @WithBridgeMethods(Future.class)\n    public QueueTaskFuture<R> scheduleBuild2(int quietPeriod, Cause c, Action... actions) {\n        return scheduleBuild2(quietPeriod,c,Arrays.asList(actions));\n    }\n\n    /**\n     * Schedules a build of this project, and returns a {@link Future} object\n     * to wait for the completion of the build.\n     *\n     * @param actions\n     *      For the convenience of the caller, this collection can contain null, and those will be silently ignored.\n     * @since 1.383\n     */\n    @SuppressWarnings(\"unchecked\")\n    @WithBridgeMethods(Future.class)\n    public QueueTaskFuture<R> scheduleBuild2(int quietPeriod, Cause c, Collection<? extends Action> actions) {\n        if (!isBuildable())\n            return null;\n\n        List<Action> queueActions = new ArrayList<Action>(actions);\n        if (isParameterized() && Util.filter(queueActions, ParametersAction.class).isEmpty()) {\n            queueActions.add(new ParametersAction(getDefaultParametersValues()));\n        }\n\n        if (c != null) {\n            queueActions.add(new CauseAction(c));\n        }\n\n        WaitingItem i = Jenkins.getInstance().getQueue().schedule(this, quietPeriod, queueActions);\n        if(i!=null)\n            return (QueueTaskFuture)i.getFuture();\n        return null;\n    }\n\n    private List<ParameterValue> getDefaultParametersValues() {\n        ParametersDefinitionProperty paramDefProp = getProperty(ParametersDefinitionProperty.class);\n        ArrayList<ParameterValue> defValues = new ArrayList<ParameterValue>();\n        \n        /*\n         * This check is made ONLY if someone will call this method even if isParametrized() is false.\n         */\n        if(paramDefProp == null)\n            return defValues;\n        \n        /* Scan for all parameter with an associated default values */\n        for(ParameterDefinition paramDefinition : paramDefProp.getParameterDefinitions())\n        {\n           ParameterValue defaultValue  = paramDefinition.getDefaultParameterValue();\n            \n            if(defaultValue != null)\n                defValues.add(defaultValue);           \n        }\n        \n        return defValues;\n    }\n\n    /**\n     * Schedules a build, and returns a {@link Future} object\n     * to wait for the completion of the build.\n     *\n     * <p>\n     * Production code shouldn't be using this, but for tests this is very convenient, so this isn't marked\n     * as deprecated.\n     */\n    @SuppressWarnings(\"deprecation\")\n    @WithBridgeMethods(Future.class)\n    public QueueTaskFuture<R> scheduleBuild2(int quietPeriod) {\n        return scheduleBuild2(quietPeriod, new LegacyCodeCause());\n    }\n    \n    /**\n     * Schedules a build of this project, and returns a {@link Future} object\n     * to wait for the completion of the build.\n     */\n    @WithBridgeMethods(Future.class)\n    public QueueTaskFuture<R> scheduleBuild2(int quietPeriod, Cause c) {\n        return scheduleBuild2(quietPeriod, c, new Action[0]);\n    }\n\n    /**\n     * Schedules a polling of this project.\n     */\n    public boolean schedulePolling() {\n        if(isDisabled())    return false;\n        SCMTrigger scmt = getTrigger(SCMTrigger.class);\n        if(scmt==null)      return false;\n        scmt.run();\n        return true;\n    }\n\n    /**\n     * Returns true if the build is in the queue.\n     */\n    @Override\n    public boolean isInQueue() {\n        return Jenkins.getInstance().getQueue().contains(this);\n    }\n\n    @Override\n    public Queue.Item getQueueItem() {\n        return Jenkins.getInstance().getQueue().getItem(this);\n    }\n\n    /**\n     * Gets the JDK that this project is configured with, or null.\n     */\n    public JDK getJDK() {\n        return Jenkins.getInstance().getJDK(jdk);\n    }\n\n    /**\n     * Overwrites the JDK setting.\n     */\n    public void setJDK(JDK jdk) throws IOException {\n        this.jdk = jdk.getName();\n        save();\n    }\n\n    public BuildAuthorizationToken getAuthToken() {\n        return authToken;\n    }\n\n    @Override\n    public RunMap<R> _getRuns() {\n        assert builds.baseDirInitialized() : \"neither onCreatedFromScratch nor onLoad called on \" + this + \" yet\";\n        return builds;\n    }\n\n    @Override\n    public void removeRun(R run) {\n        this.builds.remove(run);\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * More efficient implementation.\n     */\n    @Override\n    public R getBuild(String id) {\n        return builds.getById(id);\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * More efficient implementation.\n     */\n    @Override\n    public R getBuildByNumber(int n) {\n        return builds.getByNumber(n);\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * More efficient implementation.\n     */\n    @Override\n    public R getFirstBuild() {\n        return builds.oldestBuild();\n    }\n\n    @Override\n    public R getLastBuild() {\n        return builds.newestBuild();\n    }\n\n    @Override\n    public R getNearestBuild(int n) {\n        return builds.search(n, Direction.ASC);\n    }\n\n    @Override\n    public R getNearestOldBuild(int n) {\n        return builds.search(n, Direction.DESC);\n    }\n\n    /**\n     * Determines Class&lt;R>.\n     */\n    protected abstract Class<R> getBuildClass();\n\n    // keep track of the previous time we started a build\n    private transient long lastBuildStartTime;\n    \n    /**\n     * Creates a new build of this project for immediate execution.\n     */\n    protected synchronized R newBuild() throws IOException {\n    \t// make sure we don't start two builds in the same second\n    \t// so the build directories will be different too\n    \tlong timeSinceLast = System.currentTimeMillis() - lastBuildStartTime;\n    \tif (timeSinceLast < 1000) {\n    \t\ttry {\n\t\t\t\tThread.sleep(1000 - timeSinceLast);\n\t\t\t} catch (InterruptedException e) {\n\t\t\t}\n    \t}\n    \tlastBuildStartTime = System.currentTimeMillis();\n        try {\n            R lastBuild = getBuildClass().getConstructor(getClass()).newInstance(this);\n            builds.put(lastBuild);\n            return lastBuild;\n        } catch (InstantiationException e) {\n            throw new Error(e);\n        } catch (IllegalAccessException e) {\n            throw new Error(e);\n        } catch (InvocationTargetException e) {\n            throw handleInvocationTargetException(e);\n        } catch (NoSuchMethodException e) {\n            throw new Error(e);\n        }\n    }\n\n    private IOException handleInvocationTargetException(InvocationTargetException e) {\n        Throwable t = e.getTargetException();\n        if(t instanceof Error)  throw (Error)t;\n        if(t instanceof RuntimeException)   throw (RuntimeException)t;\n        if(t instanceof IOException)    return (IOException)t;\n        throw new Error(t);\n    }\n\n    /**\n     * Loads an existing build record from disk.\n     */\n    protected R loadBuild(File dir) throws IOException {\n        try {\n            return getBuildClass().getConstructor(getClass(),File.class).newInstance(this,dir);\n        } catch (InstantiationException e) {\n            throw new Error(e);\n        } catch (IllegalAccessException e) {\n            throw new Error(e);\n        } catch (InvocationTargetException e) {\n            throw handleInvocationTargetException(e);\n        } catch (NoSuchMethodException e) {\n            throw new Error(e);\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * <p>\n     * Note that this method returns a read-only view of {@link Action}s.\n     * {@link BuildStep}s and others who want to add a project action\n     * should do so by implementing {@link BuildStep#getProjectActions(AbstractProject)}.\n     *\n     * @see TransientProjectActionFactory\n     */\n    @Override\n    public List<Action> getActions() {\n        // add all the transient actions, too\n        List<Action> actions = new Vector<Action>(super.getActions());\n        actions.addAll(transientActions);\n        // return the read only list to cause a failure on plugins who try to add an action here\n        return Collections.unmodifiableList(actions);\n    }\n\n    /**\n     * Gets the {@link Node} where this project was last built on.\n     *\n     * @return\n     *      null if no information is available (for example,\n     *      if no build was done yet.)\n     */\n    public Node getLastBuiltOn() {\n        // where was it built on?\n        AbstractBuild b = getLastBuild();\n        if(b==null)\n            return null;\n        else\n            return b.getBuiltOn();\n    }\n\n    public Object getSameNodeConstraint() {\n        return this; // in this way, any member that wants to run with the main guy can nominate the project itself \n    }\n\n    public final Task getOwnerTask() {\n        return this;\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * <p>\n     * A project must be blocked if its own previous build is in progress,\n     * or if the blockBuildWhenUpstreamBuilding option is true and an upstream\n     * project is building, but derived classes can also check other conditions.\n     */\n    public boolean isBuildBlocked() {\n        return getCauseOfBlockage()!=null;\n    }\n\n    public String getWhyBlocked() {\n        CauseOfBlockage cb = getCauseOfBlockage();\n        return cb!=null ? cb.getShortDescription() : null;\n    }\n\n    /**\n     * Blocked because the previous build is already in progress.\n     */\n    public static class BecauseOfBuildInProgress extends CauseOfBlockage {\n        private final AbstractBuild<?,?> build;\n\n        public BecauseOfBuildInProgress(AbstractBuild<?, ?> build) {\n            this.build = build;\n        }\n\n        @Override\n        public String getShortDescription() {\n            Executor e = build.getExecutor();\n            String eta = \"\";\n            if (e != null)\n                eta = Messages.AbstractProject_ETA(e.getEstimatedRemainingTime());\n            int lbn = build.getNumber();\n            return Messages.AbstractProject_BuildInProgress(lbn, eta);\n        }\n    }\n    \n    /**\n     * Because the downstream build is in progress, and we are configured to wait for that.\n     */\n    public static class BecauseOfDownstreamBuildInProgress extends CauseOfBlockage {\n        public final AbstractProject<?,?> up;\n\n        public BecauseOfDownstreamBuildInProgress(AbstractProject<?,?> up) {\n            this.up = up;\n        }\n\n        @Override\n        public String getShortDescription() {\n            return Messages.AbstractProject_DownstreamBuildInProgress(up.getName());\n        }\n    }\n\n    /**\n     * Because the upstream build is in progress, and we are configured to wait for that.\n     */\n    public static class BecauseOfUpstreamBuildInProgress extends CauseOfBlockage {\n        public final AbstractProject<?,?> up;\n\n        public BecauseOfUpstreamBuildInProgress(AbstractProject<?,?> up) {\n            this.up = up;\n        }\n\n        @Override\n        public String getShortDescription() {\n            return Messages.AbstractProject_UpstreamBuildInProgress(up.getName());\n        }\n    }\n\n    public CauseOfBlockage getCauseOfBlockage() {\n        // Block builds until they are done with post-production\n        if (isLogUpdated() && !isConcurrentBuild())\n            return new BecauseOfBuildInProgress(getLastBuild());\n        if (blockBuildWhenDownstreamBuilding()) {\n            AbstractProject<?,?> bup = getBuildingDownstream();\n            if (bup!=null)\n                return new BecauseOfDownstreamBuildInProgress(bup);\n        }\n        if (blockBuildWhenUpstreamBuilding()) {\n            AbstractProject<?,?> bup = getBuildingUpstream();\n            if (bup!=null)\n                return new BecauseOfUpstreamBuildInProgress(bup);\n        }\n        return null;\n    }\n\n    /**\n     * Returns the project if any of the downstream project is either\n     * building, waiting, pending or buildable.\n     * <p>\n     * This means eventually there will be an automatic triggering of\n     * the given project (provided that all builds went smoothly.)\n     */\n    public AbstractProject getBuildingDownstream() {\n        Set<Task> unblockedTasks = Jenkins.getInstance().getQueue().getUnblockedTasks();\n\n        for (AbstractProject tup : getTransitiveDownstreamProjects()) {\n\t\t\tif (tup!=this && (tup.isBuilding() || unblockedTasks.contains(tup)))\n                return tup;\n        }\n        return null;\n    }\n\n    /**\n     * Returns the project if any of the upstream project is either\n     * building or is in the queue.\n     * <p>\n     * This means eventually there will be an automatic triggering of\n     * the given project (provided that all builds went smoothly.)\n     */\n    public AbstractProject getBuildingUpstream() {\n        Set<Task> unblockedTasks = Jenkins.getInstance().getQueue().getUnblockedTasks();\n\n        for (AbstractProject tup : getTransitiveUpstreamProjects()) {\n\t\t\tif (tup!=this && (tup.isBuilding() || unblockedTasks.contains(tup)))\n                return tup;\n        }\n        return null;\n    }\n\n    public List<SubTask> getSubTasks() {\n        List<SubTask> r = new ArrayList<SubTask>();\n        r.add(this);\n        for (SubTaskContributor euc : SubTaskContributor.all())\n            r.addAll(euc.forProject(this));\n        for (JobProperty<? super P> p : properties)\n            r.addAll(p.getSubTasks());\n        return r;\n    }\n\n    public R createExecutable() throws IOException {\n        if(isDisabled())    return null;\n        return newBuild();\n    }\n\n    public void checkAbortPermission() {\n        checkPermission(AbstractProject.ABORT);\n    }\n\n    public boolean hasAbortPermission() {\n        return hasPermission(AbstractProject.ABORT);\n    }\n\n    /**\n     * Gets the {@link Resource} that represents the workspace of this project.\n     * Useful for locking and mutual exclusion control.\n     *\n     * @deprecated as of 1.319\n     *      Projects no longer have a fixed workspace, ands builds will find an available workspace via\n     *      {@link WorkspaceList} for each build (furthermore, that happens after a build is started.)\n     *      So a {@link Resource} representation for a workspace at the project level no longer makes sense.\n     *\n     *      <p>\n     *      If you need to lock a workspace while you do some computation, see the source code of\n     *      {@link #pollSCMChanges(TaskListener)} for how to obtain a lock of a workspace through {@link WorkspaceList}.\n     */\n    public Resource getWorkspaceResource() {\n        return new Resource(getFullDisplayName()+\" workspace\");\n    }\n\n    /**\n     * List of necessary resources to perform the build of this project.\n     */\n    public ResourceList getResourceList() {\n        final Set<ResourceActivity> resourceActivities = getResourceActivities();\n        final List<ResourceList> resourceLists = new ArrayList<ResourceList>(1 + resourceActivities.size());\n        for (ResourceActivity activity : resourceActivities) {\n            if (activity != this && activity != null) {\n                // defensive infinite recursion and null check\n                resourceLists.add(activity.getResourceList());\n            }\n        }\n        return ResourceList.union(resourceLists);\n    }\n\n    /**\n     * Set of child resource activities of the build of this project (override in child projects).\n     * @return The set of child resource activities of the build of this project.\n     */\n    protected Set<ResourceActivity> getResourceActivities() {\n        return Collections.emptySet();\n    }\n\n    public boolean checkout(AbstractBuild build, Launcher launcher, BuildListener listener, File changelogFile) throws IOException, InterruptedException {\n        SCM scm = getScm();\n        if(scm==null)\n            return true;    // no SCM\n\n        FilePath workspace = build.getWorkspace();\n        workspace.mkdirs();\n        \n        boolean r = scm.checkout(build, launcher, workspace, listener, changelogFile);\n        if (r) {\n            // Only calcRevisionsFromBuild if checkout was successful. Note that modern SCM implementations\n            // won't reach this line anyway, as they throw AbortExceptions on checkout failure.\n            calcPollingBaseline(build, launcher, listener);\n        }\n        return r;\n    }\n\n    /**\n     * Pushes the baseline up to the newly checked out revision.\n     */\n    private void calcPollingBaseline(AbstractBuild build, Launcher launcher, TaskListener listener) throws IOException, InterruptedException {\n        SCMRevisionState baseline = build.getAction(SCMRevisionState.class);\n        if (baseline==null) {\n            try {\n                baseline = getScm()._calcRevisionsFromBuild(build, launcher, listener);\n            } catch (AbstractMethodError e) {\n                baseline = SCMRevisionState.NONE; // pre-1.345 SCM implementations, which doesn't use the baseline in polling\n            }\n            if (baseline!=null)\n                build.addAction(baseline);\n        }\n        pollingBaseline = baseline;\n    }\n\n    /**\n     * Checks if there's any update in SCM, and returns true if any is found.\n     *\n     * @deprecated as of 1.346\n     *      Use {@link #poll(TaskListener)} instead.\n     */\n    public boolean pollSCMChanges( TaskListener listener ) {\n        return poll(listener).hasChanges();\n    }\n\n    /**\n     * Checks if there's any update in SCM, and returns true if any is found.\n     *\n     * <p>\n     * The implementation is responsible for ensuring mutual exclusion between polling and builds\n     * if necessary.\n     *\n     * @since 1.345\n     */\n    public PollingResult poll( TaskListener listener ) {\n        SCM scm = getScm();\n        if (scm==null) {\n            listener.getLogger().println(Messages.AbstractProject_NoSCM());\n            return NO_CHANGES;\n        }\n        if (!isBuildable()) {\n            listener.getLogger().println(Messages.AbstractProject_Disabled());\n            return NO_CHANGES;\n        }\n\n        R lb = getLastBuild();\n        if (lb==null) {\n            listener.getLogger().println(Messages.AbstractProject_NoBuilds());\n            return isInQueue() ? NO_CHANGES : BUILD_NOW;\n        }\n\n        if (pollingBaseline==null) {\n            R success = getLastSuccessfulBuild(); // if we have a persisted baseline, we'll find it by this\n            for (R r=lb; r!=null; r=r.getPreviousBuild()) {\n                SCMRevisionState s = r.getAction(SCMRevisionState.class);\n                if (s!=null) {\n                    pollingBaseline = s;\n                    break;\n                }\n                if (r==success) break;  // searched far enough\n            }\n            // NOTE-NO-BASELINE:\n            // if we don't have baseline yet, it means the data is built by old Hudson that doesn't set the baseline\n            // as action, so we need to compute it. This happens later.\n        }\n\n        try {\n            SCMPollListener.fireBeforePolling(this, listener);\n            PollingResult r = _poll(listener, scm, lb);\n            SCMPollListener.firePollingSuccess(this,listener, r);\n            return r;\n        } catch (AbortException e) {\n            listener.getLogger().println(e.getMessage());\n            listener.fatalError(Messages.AbstractProject_Aborted());\n            LOGGER.log(Level.FINE, \"Polling \"+this+\" aborted\",e);\n            SCMPollListener.firePollingFailed(this, listener,e);\n            return NO_CHANGES;\n        } catch (IOException e) {\n            e.printStackTrace(listener.fatalError(e.getMessage()));\n            SCMPollListener.firePollingFailed(this, listener,e);\n            return NO_CHANGES;\n        } catch (InterruptedException e) {\n            e.printStackTrace(listener.fatalError(Messages.AbstractProject_PollingABorted()));\n            SCMPollListener.firePollingFailed(this, listener,e);\n            return NO_CHANGES;\n        } catch (RuntimeException e) {\n            SCMPollListener.firePollingFailed(this, listener,e);\n            throw e;\n        } catch (Error e) {\n            SCMPollListener.firePollingFailed(this, listener,e);\n            throw e;\n        }\n    }\n\n    /**\n     * {@link #poll(TaskListener)} method without the try/catch block that does listener notification and .\n     */\n    private PollingResult _poll(TaskListener listener, SCM scm, R lb) throws IOException, InterruptedException {\n        if (scm.requiresWorkspaceForPolling()) {\n            // lock the workspace of the last build\n            FilePath ws=lb.getWorkspace();\n\n            WorkspaceOfflineReason workspaceOfflineReason = workspaceOffline( lb );\n            if ( workspaceOfflineReason != null ) {\n                // workspace offline\n                for (WorkspaceBrowser browser : Jenkins.getInstance().getExtensionList(WorkspaceBrowser.class)) {\n                    ws = browser.getWorkspace(this);\n                    if (ws != null) {\n                        return pollWithWorkspace(listener, scm, lb, ws, browser.getWorkspaceList());\n                    }\n                }\n\n                // build now, or nothing will ever be built\n                Label label = getAssignedLabel();\n                if (label != null && label.isSelfLabel()) {\n                    // if the build is fixed on a node, then attempting a build will do us\n                    // no good. We should just wait for the slave to come back.\n                    listener.getLogger().print(Messages.AbstractProject_NoWorkspace());\n                    listener.getLogger().println( \" (\" + workspaceOfflineReason.name() + \")\");\n                    return NO_CHANGES;\n                }\n                listener.getLogger().println( ws==null\n                    ? Messages.AbstractProject_WorkspaceOffline()\n                    : Messages.AbstractProject_NoWorkspace());\n                if (isInQueue()) {\n                    listener.getLogger().println(Messages.AbstractProject_AwaitingBuildForWorkspace());\n                    return NO_CHANGES;\n                } else {\n                    listener.getLogger().print(Messages.AbstractProject_NewBuildForWorkspace());\n                    listener.getLogger().println( \" (\" + workspaceOfflineReason.name() + \")\");\n                    return BUILD_NOW;\n                }\n            } else {\n                WorkspaceList l = lb.getBuiltOn().toComputer().getWorkspaceList();\n                return pollWithWorkspace(listener, scm, lb, ws, l);\n\n            }\n        } else {\n            // polling without workspace\n            LOGGER.fine(\"Polling SCM changes of \" + getName());\n\n            if (pollingBaseline==null) // see NOTE-NO-BASELINE above\n                calcPollingBaseline(lb,null,listener);\n            PollingResult r = scm.poll(this, null, null, listener, pollingBaseline);\n            pollingBaseline = r.remote;\n            return r;\n        }\n    }\n\n    private PollingResult pollWithWorkspace(TaskListener listener, SCM scm, R lb, FilePath ws, WorkspaceList l) throws InterruptedException, IOException {\n        // if doing non-concurrent build, acquire a workspace in a way that causes builds to block for this workspace.\n        // this prevents multiple workspaces of the same job --- the behavior of Hudson < 1.319.\n        //\n        // OTOH, if a concurrent build is chosen, the user is willing to create a multiple workspace,\n        // so better throughput is achieved over time (modulo the initial cost of creating that many workspaces)\n        // by having multiple workspaces\n        WorkspaceList.Lease lease = l.acquire(ws, !concurrentBuild);\n        Launcher launcher = ws.createLauncher(listener).decorateByEnv(getEnvironment(lb.getBuiltOn(),listener));\n        try {\n            LOGGER.fine(\"Polling SCM changes of \" + getName());\n            if (pollingBaseline==null) // see NOTE-NO-BASELINE above\n                calcPollingBaseline(lb,launcher,listener);\n            PollingResult r = scm.poll(this, launcher, ws, listener, pollingBaseline);\n            pollingBaseline = r.remote;\n            return r;\n        } finally {\n            lease.release();\n        }\n    }\n\n    enum WorkspaceOfflineReason {\n        nonexisting_workspace,\n        builton_node_gone,\n        builton_node_no_executors\n    }\n\n    private WorkspaceOfflineReason workspaceOffline(R build) throws IOException, InterruptedException {\n        FilePath ws = build.getWorkspace();\n        if (ws==null || !ws.exists()) {\n            return WorkspaceOfflineReason.nonexisting_workspace;\n        }\n        \n        Node builtOn = build.getBuiltOn();\n        if (builtOn == null) { // node built-on doesn't exist anymore\n            return WorkspaceOfflineReason.builton_node_gone;\n        }\n        \n        if (builtOn.toComputer() == null) { // node still exists, but has 0 executors - o.s.l.t.\n            return WorkspaceOfflineReason.builton_node_no_executors;\n        }\n\n        return null;\n    }\n\n    /**\n     * Returns true if this user has made a commit to this project.\n     *\n     * @since 1.191\n     */\n    public boolean hasParticipant(User user) {\n        for( R build = getLastBuild(); build!=null; build=build.getPreviousBuild())\n            if(build.hasParticipant(user))\n                return true;\n        return false;\n    }\n\n    @Exported\n    public SCM getScm() {\n        return scm;\n    }\n\n    public void setScm(SCM scm) throws IOException {\n        this.scm = scm;\n        save();\n    }\n\n    /**\n     * Adds a new {@link Trigger} to this {@link Project} if not active yet.\n     */\n    public void addTrigger(Trigger<?> trigger) throws IOException {\n        addToList(trigger,triggers());\n    }\n\n    public void removeTrigger(TriggerDescriptor trigger) throws IOException {\n        removeFromList(trigger,triggers());\n    }\n\n    protected final synchronized <T extends Describable<T>>\n    void addToList( T item, List<T> collection ) throws IOException {\n        for( int i=0; i<collection.size(); i++ ) {\n            if(collection.get(i).getDescriptor()==item.getDescriptor()) {\n                // replace\n                collection.set(i,item);\n                save();\n                return;\n            }\n        }\n        // add\n        collection.add(item);\n        save();\n        updateTransientActions();\n    }\n\n    protected final synchronized <T extends Describable<T>>\n    void removeFromList(Descriptor<T> item, List<T> collection) throws IOException {\n        for( int i=0; i< collection.size(); i++ ) {\n            if(collection.get(i).getDescriptor()==item) {\n                // found it\n                collection.remove(i);\n                save();\n                updateTransientActions();\n                return;\n            }\n        }\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public synchronized Map<TriggerDescriptor,Trigger> getTriggers() {\n        return (Map)Descriptor.toMap(triggers());\n    }\n\n    /**\n     * Gets the specific trigger, or null if the propert is not configured for this job.\n     */\n    public <T extends Trigger> T getTrigger(Class<T> clazz) {\n        for (Trigger p : triggers()) {\n            if(clazz.isInstance(p))\n                return clazz.cast(p);\n        }\n        return null;\n    }\n\n//\n//\n// fingerprint related\n//\n//\n    /**\n     * True if the builds of this project produces {@link Fingerprint} records.\n     */\n    public abstract boolean isFingerprintConfigured();\n\n    /**\n     * Gets the other {@link AbstractProject}s that should be built\n     * when a build of this project is completed.\n     */\n    @Exported\n    public final List<AbstractProject> getDownstreamProjects() {\n        return Jenkins.getInstance().getDependencyGraph().getDownstream(this);\n    }\n\n    @Exported\n    public final List<AbstractProject> getUpstreamProjects() {\n        return Jenkins.getInstance().getDependencyGraph().getUpstream(this);\n    }\n\n    /**\n     * Returns only those upstream projects that defines {@link BuildTrigger} to this project.\n     * This is a subset of {@link #getUpstreamProjects()}\n     *\n     * @return A List of upstream projects that has a {@link BuildTrigger} to this project.\n     */\n    public final List<AbstractProject> getBuildTriggerUpstreamProjects() {\n        ArrayList<AbstractProject> result = new ArrayList<AbstractProject>();\n        for (AbstractProject<?,?> ap : getUpstreamProjects()) {\n            BuildTrigger buildTrigger = ap.getPublishersList().get(BuildTrigger.class);\n            if (buildTrigger != null)\n                if (buildTrigger.getChildProjects(ap).contains(this))\n                    result.add(ap);\n        }        \n        return result;\n    }    \n    \n    /**\n     * Gets all the upstream projects including transitive upstream projects.\n     *\n     * @since 1.138\n     */\n    public final Set<AbstractProject> getTransitiveUpstreamProjects() {\n        return Jenkins.getInstance().getDependencyGraph().getTransitiveUpstream(this);\n    }\n\n    /**\n     * Gets all the downstream projects including transitive downstream projects.\n     *\n     * @since 1.138\n     */\n    public final Set<AbstractProject> getTransitiveDownstreamProjects() {\n        return Jenkins.getInstance().getDependencyGraph().getTransitiveDownstream(this);\n    }\n\n    /**\n     * Gets the dependency relationship map between this project (as the source)\n     * and that project (as the sink.)\n     *\n     * @return\n     *      can be empty but not null. build number of this project to the build\n     *      numbers of that project.\n     */\n    public SortedMap<Integer, RangeSet> getRelationship(AbstractProject that) {\n        TreeMap<Integer,RangeSet> r = new TreeMap<Integer,RangeSet>(REVERSE_INTEGER_COMPARATOR);\n\n        checkAndRecord(that, r, this.getBuilds());\n        // checkAndRecord(that, r, that.getBuilds());\n\n        return r;\n    }\n\n    /**\n     * Helper method for getDownstreamRelationship.\n     *\n     * For each given build, find the build number range of the given project and put that into the map.\n     */\n    private void checkAndRecord(AbstractProject that, TreeMap<Integer, RangeSet> r, Collection<R> builds) {\n        for (R build : builds) {\n            RangeSet rs = build.getDownstreamRelationship(that);\n            if(rs==null || rs.isEmpty())\n                continue;\n\n            int n = build.getNumber();\n\n            RangeSet value = r.get(n);\n            if(value==null)\n                r.put(n,rs);\n            else\n                value.add(rs);\n        }\n    }\n\n    /**\n     * Builds the dependency graph.\n     * @see DependencyGraph\n     */\n    protected abstract void buildDependencyGraph(DependencyGraph graph);\n\n    @Override\n    protected SearchIndexBuilder makeSearchIndex() {\n        SearchIndexBuilder sib = super.makeSearchIndex();\n        if(isBuildable() && hasPermission(Jenkins.ADMINISTER))\n            sib.add(\"build\",\"build\");\n        return sib;\n    }\n\n    @Override\n    protected HistoryWidget createHistoryWidget() {\n        return new BuildHistoryWidget<R>(this,builds,HISTORY_ADAPTER);\n    }\n    \n    public boolean isParameterized() {\n        return getProperty(ParametersDefinitionProperty.class) != null;\n    }\n\n//\n//\n// actions\n//\n//\n    /**\n     * Schedules a new build command.\n     */\n    public void doBuild( StaplerRequest req, StaplerResponse rsp, @QueryParameter TimeDuration delay ) throws IOException, ServletException {\n        if (delay==null)    delay=new TimeDuration(getQuietPeriod());\n\n        // if a build is parameterized, let that take over\n        ParametersDefinitionProperty pp = getProperty(ParametersDefinitionProperty.class);\n        if (pp != null && !req.getMethod().equals(\"POST\")) {\n            // show the parameter entry form.\n            req.getView(pp, \"index.jelly\").forward(req, rsp);\n            return;\n        }\n\n        BuildAuthorizationToken.checkPermission(this, authToken, req, rsp);\n\n        if (pp != null) {\n            pp._doBuild(req,rsp,delay);\n            return;\n        }\n\n        if (!isBuildable())\n            throw HttpResponses.error(SC_INTERNAL_SERVER_ERROR,new IOException(getFullName()+\" is not buildable\"));\n\n        Jenkins.getInstance().getQueue().schedule(this, (int)delay.getTime(), getBuildCause(req));\n        rsp.sendRedirect(\".\");\n    }\n\n    /**\n     * Computes the build cause, using RemoteCause or UserCause as appropriate.\n     */\n    /*package*/ CauseAction getBuildCause(StaplerRequest req) {\n        Cause cause;\n        if (authToken != null && authToken.getToken() != null && req.getParameter(\"token\") != null) {\n            // Optional additional cause text when starting via token\n            String causeText = req.getParameter(\"cause\");\n            cause = new RemoteCause(req.getRemoteAddr(), causeText);\n        } else {\n            cause = new UserIdCause();\n        }\n        return new CauseAction(cause);\n    }\n\n    /**\n     * Computes the delay by taking the default value and the override in the request parameter into the account.\n     *\n     * @deprecated as of 1.488\n     *      Inject {@link TimeDuration}.\n     */\n    public int getDelay(StaplerRequest req) throws ServletException {\n        String delay = req.getParameter(\"delay\");\n        if (delay==null)    return getQuietPeriod();\n\n        try {\n            // TODO: more unit handling\n            if(delay.endsWith(\"sec\"))   delay=delay.substring(0,delay.length()-3);\n            if(delay.endsWith(\"secs\"))  delay=delay.substring(0,delay.length()-4);\n            return Integer.parseInt(delay);\n        } catch (NumberFormatException e) {\n            throw new ServletException(\"Invalid delay parameter value: \"+delay);\n        }\n    }\n\n    /**\n     * Supports build trigger with parameters via an HTTP GET or POST.\n     * Currently only String parameters are supported.\n     */\n    public void doBuildWithParameters(StaplerRequest req, StaplerResponse rsp, @QueryParameter TimeDuration delay) throws IOException, ServletException {\n        BuildAuthorizationToken.checkPermission(this, authToken, req, rsp);\n\n        ParametersDefinitionProperty pp = getProperty(ParametersDefinitionProperty.class);\n        if (pp != null) {\n            pp.buildWithParameters(req,rsp,delay);\n        } else {\n        \tthrow new IllegalStateException(\"This build is not parameterized!\");\n        }\n    \t\n    }\n\n    /**\n     * Schedules a new SCM polling command.\n     */\n    public void doPolling( StaplerRequest req, StaplerResponse rsp ) throws IOException, ServletException {\n        BuildAuthorizationToken.checkPermission(this, authToken, req, rsp);\n        schedulePolling();\n        rsp.sendRedirect(\".\");\n    }\n\n    /**\n     * Cancels a scheduled build.\n     */\n    @RequirePOST\n    public void doCancelQueue( StaplerRequest req, StaplerResponse rsp ) throws IOException, ServletException {\n        checkPermission(ABORT);\n\n        Jenkins.getInstance().getQueue().cancel(this);\n        rsp.forwardToPreviousPage(req);\n    }\n\n    /**\n     * Deletes this project.\n     */\n    @Override\n    @RequirePOST\n    public void doDoDelete(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException, InterruptedException {\n        delete();\n        if (req == null || rsp == null)\n            return;\n        View view = req.findAncestorObject(View.class);\n        if (view == null)\n            rsp.sendRedirect2(req.getContextPath() + '/' + getParent().getUrl());\n        else \n            rsp.sendRedirect2(req.getContextPath() + '/' + view.getUrl());\n    }\n    \n    @Override\n    protected void submit(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException, FormException {\n        super.submit(req,rsp);\n        JSONObject json = req.getSubmittedForm();\n\n        makeDisabled(req.getParameter(\"disable\")!=null);\n\n        jdk = req.getParameter(\"jdk\");\n        if(req.getParameter(\"hasCustomQuietPeriod\")!=null) {\n            quietPeriod = Integer.parseInt(req.getParameter(\"quiet_period\"));\n        } else {\n            quietPeriod = null;\n        }\n        if(req.getParameter(\"hasCustomScmCheckoutRetryCount\")!=null) {\n            scmCheckoutRetryCount = Integer.parseInt(req.getParameter(\"scmCheckoutRetryCount\"));\n        } else {\n            scmCheckoutRetryCount = null;\n        }\n        blockBuildWhenDownstreamBuilding = req.getParameter(\"blockBuildWhenDownstreamBuilding\")!=null;\n        blockBuildWhenUpstreamBuilding = req.getParameter(\"blockBuildWhenUpstreamBuilding\")!=null;\n\n        if(req.hasParameter(\"customWorkspace\")) {\n            customWorkspace = Util.fixEmptyAndTrim(req.getParameter(\"customWorkspace.directory\"));\n        } else {\n            customWorkspace = null;\n        }\n\n        if (json.has(\"scmCheckoutStrategy\"))\n            scmCheckoutStrategy = req.bindJSON(SCMCheckoutStrategy.class,\n                json.getJSONObject(\"scmCheckoutStrategy\"));\n        else\n            scmCheckoutStrategy = null;\n\n        \n        if(req.getParameter(\"hasSlaveAffinity\")!=null) {\n            assignedNode = Util.fixEmptyAndTrim(req.getParameter(\"_.assignedLabelString\"));\n        } else {\n            assignedNode = null;\n        }\n        canRoam = assignedNode==null;\n\n        concurrentBuild = req.getSubmittedForm().has(\"concurrentBuild\");\n\n        authToken = BuildAuthorizationToken.create(req);\n\n        setScm(SCMS.parseSCM(req,this));\n\n        for (Trigger t : triggers())\n            t.stop();\n        triggers = buildDescribable(req, Trigger.for_(this));\n        for (Trigger t : triggers)\n            t.start(this,true);\n\n        for (Publisher _t : Descriptor.newInstancesFromHeteroList(req, json, \"publisher\", Jenkins.getInstance().getExtensionList(BuildTrigger.DescriptorImpl.class))) {\n            BuildTrigger t = (BuildTrigger) _t;\n            for (AbstractProject downstream : t.getChildProjects(this)) {\n                downstream.checkPermission(BUILD);\n            }\n        }\n    }\n\n    /**\n     * @deprecated\n     *      As of 1.261. Use {@link #buildDescribable(StaplerRequest, List)} instead.\n     */\n    protected final <T extends Describable<T>> List<T> buildDescribable(StaplerRequest req, List<? extends Descriptor<T>> descriptors, String prefix) throws FormException, ServletException {\n        return buildDescribable(req,descriptors);\n    }\n\n    protected final <T extends Describable<T>> List<T> buildDescribable(StaplerRequest req, List<? extends Descriptor<T>> descriptors)\n        throws FormException, ServletException {\n\n        JSONObject data = req.getSubmittedForm();\n        List<T> r = new Vector<T>();\n        for (Descriptor<T> d : descriptors) {\n            String safeName = d.getJsonSafeClassName();\n            if (req.getParameter(safeName) != null) {\n                T instance = d.newInstance(req, data.getJSONObject(safeName));\n                r.add(instance);\n            }\n        }\n        return r;\n    }\n\n    /**\n     * Serves the workspace files.\n     */\n    public DirectoryBrowserSupport doWs( StaplerRequest req, StaplerResponse rsp ) throws IOException, ServletException, InterruptedException {\n        checkPermission(AbstractProject.WORKSPACE);\n        FilePath ws = getSomeWorkspace();\n        if ((ws == null) || (!ws.exists())) {\n            // if there's no workspace, report a nice error message\n            // Would be good if when asked for *plain*, do something else!\n            // (E.g. return 404, or send empty doc.)\n            // Not critical; client can just check if content type is not text/plain,\n            // which also serves to detect old versions of Hudson.\n            req.getView(this,\"noWorkspace.jelly\").forward(req,rsp);\n            return null;\n        } else {\n            return new DirectoryBrowserSupport(this, ws, getDisplayName()+\" workspace\", \"folder.png\", true);\n        }\n    }\n\n    /**\n     * Wipes out the workspace.\n     */\n    public HttpResponse doDoWipeOutWorkspace() throws IOException, ServletException, InterruptedException {\n        checkPermission(Functions.isWipeOutPermissionEnabled() ? WIPEOUT : BUILD);\n        R b = getSomeBuildWithWorkspace();\n        FilePath ws = b!=null ? b.getWorkspace() : null;\n        if (ws!=null && getScm().processWorkspaceBeforeDeletion(this, ws, b.getBuiltOn())) {\n            ws.deleteRecursive();\n            for (WorkspaceListener wl : WorkspaceListener.all()) {\n                wl.afterDelete(this);\n            }\n            return new HttpRedirect(\".\");\n        } else {\n            // If we get here, that means the SCM blocked the workspace deletion.\n            return new ForwardToView(this,\"wipeOutWorkspaceBlocked.jelly\");\n        }\n    }\n\n    @CLIMethod(name=\"disable-job\")\n    @RequirePOST\n    public HttpResponse doDisable() throws IOException, ServletException {\n        checkPermission(CONFIGURE);\n        makeDisabled(true);\n        return new HttpRedirect(\".\");\n    }\n\n    @CLIMethod(name=\"enable-job\")\n    @RequirePOST\n    public HttpResponse doEnable() throws IOException, ServletException {\n        checkPermission(CONFIGURE);\n        makeDisabled(false);\n        return new HttpRedirect(\".\");\n    }\n\n    /**\n     * RSS feed for changes in this project.\n     */\n    public void doRssChangelog(  StaplerRequest req, StaplerResponse rsp  ) throws IOException, ServletException {\n        class FeedItem {\n            ChangeLogSet.Entry e;\n            int idx;\n\n            public FeedItem(Entry e, int idx) {\n                this.e = e;\n                this.idx = idx;\n            }\n\n            AbstractBuild<?,?> getBuild() {\n                return e.getParent().build;\n            }\n        }\n\n        List<FeedItem> entries = new ArrayList<FeedItem>();\n\n        for(R r=getLastBuild(); r!=null; r=r.getPreviousBuild()) {\n            int idx=0;\n            for( ChangeLogSet.Entry e : r.getChangeSet())\n                entries.add(new FeedItem(e,idx++));\n        }\n\n        RSS.forwardToRss(\n            getDisplayName()+' '+getScm().getDescriptor().getDisplayName()+\" changes\",\n            getUrl()+\"changes\",\n            entries, new FeedAdapter<FeedItem>() {\n                public String getEntryTitle(FeedItem item) {\n                    return \"#\"+item.getBuild().number+' '+item.e.getMsg()+\" (\"+item.e.getAuthor()+\")\";\n                }\n\n                public String getEntryUrl(FeedItem item) {\n                    return item.getBuild().getUrl()+\"changes#detail\"+item.idx;\n                }\n\n                public String getEntryID(FeedItem item) {\n                    return getEntryUrl(item);\n                }\n\n                public String getEntryDescription(FeedItem item) {\n                    StringBuilder buf = new StringBuilder();\n                    for(String path : item.e.getAffectedPaths())\n                        buf.append(path).append('\\n');\n                    return buf.toString();\n                }\n\n                public Calendar getEntryTimestamp(FeedItem item) {\n                    return item.getBuild().getTimestamp();\n                }\n\n                public String getEntryAuthor(FeedItem entry) {\n                    return JenkinsLocationConfiguration.get().getAdminAddress();\n                }\n            },\n            req, rsp );\n    }\n\n    /**\n     * {@link AbstractProject} subtypes should implement this base class as a descriptor.\n     *\n     * @since 1.294\n     */\n    public static abstract class AbstractProjectDescriptor extends TopLevelItemDescriptor {\n        /**\n         * {@link AbstractProject} subtypes can override this method to veto some {@link Descriptor}s\n         * from showing up on their configuration screen. This is often useful when you are building\n         * a workflow/company specific project type, where you want to limit the number of choices\n         * given to the users.\n         *\n         * <p>\n         * Some {@link Descriptor}s define their own schemes for controlling applicability\n         * (such as {@link BuildStepDescriptor#isApplicable(Class)}),\n         * This method works like AND in conjunction with them;\n         * Both this method and that method need to return true in order for a given {@link Descriptor}\n         * to show up for the given {@link Project}.\n         *\n         * <p>\n         * The default implementation returns true for everything.\n         *\n         * @see BuildStepDescriptor#isApplicable(Class) \n         * @see BuildWrapperDescriptor#isApplicable(AbstractProject) \n         * @see TriggerDescriptor#isApplicable(Item)\n         */\n        @Override\n        public boolean isApplicable(Descriptor descriptor) {\n            return true;\n        }\n\n        public FormValidation doCheckAssignedLabelString(@QueryParameter String value) {\n            if (Util.fixEmpty(value)==null)\n                return FormValidation.ok(); // nothing typed yet\n            try {\n                Label.parseExpression(value);\n            } catch (ANTLRException e) {\n                return FormValidation.error(e,\n                        Messages.AbstractProject_AssignedLabelString_InvalidBooleanExpression(e.getMessage()));\n            }\n            Label l = Jenkins.getInstance().getLabel(value);\n            if (l.isEmpty()) {\n                for (LabelAtom a : l.listAtoms()) {\n                    if (a.isEmpty()) {\n                        LabelAtom nearest = LabelAtom.findNearest(a.getName());\n                        return FormValidation.warning(Messages.AbstractProject_AssignedLabelString_NoMatch_DidYouMean(a.getName(),nearest.getDisplayName()));\n                    }\n                }\n                return FormValidation.warning(Messages.AbstractProject_AssignedLabelString_NoMatch());\n            }\n            return FormValidation.ok();\n        }\n\n        public FormValidation doCheckCustomWorkspace(@QueryParameter(value=\"customWorkspace.directory\") String customWorkspace){\n        \tif(Util.fixEmptyAndTrim(customWorkspace)==null)\n        \t\treturn FormValidation.error(Messages.AbstractProject_CustomWorkspaceEmpty());\n        \telse\n        \t\treturn FormValidation.ok();\n        }\n        \n        public AutoCompletionCandidates doAutoCompleteUpstreamProjects(@QueryParameter String value) {\n            AutoCompletionCandidates candidates = new AutoCompletionCandidates();\n            List<Job> jobs = Jenkins.getInstance().getItems(Job.class);\n            for (Job job: jobs) {\n                if (job.getFullName().startsWith(value)) {\n                    if (job.hasPermission(Item.READ)) {\n                        candidates.add(job.getFullName());\n                    }\n                }\n            }\n            return candidates;\n        }\n\n        public AutoCompletionCandidates doAutoCompleteAssignedLabelString(@QueryParameter String value) {\n            AutoCompletionCandidates c = new AutoCompletionCandidates();\n            Set<Label> labels = Jenkins.getInstance().getLabels();\n            List<String> queries = new AutoCompleteSeeder(value).getSeeds();\n\n            for (String term : queries) {\n                for (Label l : labels) {\n                    if (l.getName().startsWith(term)) {\n                        c.add(l.getName());\n                    }\n                }\n            }\n            return c;\n        }\n\n        public List<SCMCheckoutStrategyDescriptor> getApplicableSCMCheckoutStrategyDescriptors(AbstractProject p) {\n            return SCMCheckoutStrategyDescriptor._for(p);\n        }\n\n        /**\n        * Utility class for taking the current input value and computing a list\n        * of potential terms to match against the list of defined labels.\n         */\n        static class AutoCompleteSeeder {\n            private String source;\n\n            AutoCompleteSeeder(String source) {\n                this.source = source;\n            }\n\n            List<String> getSeeds() {\n                ArrayList<String> terms = new ArrayList<String>();\n                boolean trailingQuote = source.endsWith(\"\\\"\");\n                boolean leadingQuote = source.startsWith(\"\\\"\");\n                boolean trailingSpace = source.endsWith(\" \");\n\n                if (trailingQuote || (trailingSpace && !leadingQuote)) {\n                    terms.add(\"\");\n                } else {\n                    if (leadingQuote) {\n                        int quote = source.lastIndexOf('\"');\n                        if (quote == 0) {\n                            terms.add(source.substring(1));\n                        } else {\n                            terms.add(\"\");\n                        }\n                    } else {\n                        int space = source.lastIndexOf(' ');\n                        if (space > -1) {\n                            terms.add(source.substring(space+1));\n                        } else {\n                            terms.add(source);\n                        }\n                    }\n                }\n\n                return terms;\n            }\n        }\n    }\n\n    /**\n     * Finds a {@link AbstractProject} that has the name closest to the given name.\n     */\n    public static AbstractProject findNearest(String name) {\n        return findNearest(name,Hudson.getInstance());\n    }\n\n    /**\n     * Finds a {@link AbstractProject} whose name (when referenced from the specified context) is closest to the given name.\n     *\n     * @since 1.419\n     */\n    public static AbstractProject findNearest(String name, ItemGroup context) {\n        List<AbstractProject> projects = Hudson.getInstance().getAllItems(AbstractProject.class);\n        String[] names = new String[projects.size()];\n        for( int i=0; i<projects.size(); i++ )\n            names[i] = projects.get(i).getRelativeNameFrom(context);\n\n        String nearest = EditDistance.findNearest(name, names);\n        return (AbstractProject)Jenkins.getInstance().getItem(nearest,context);\n    }\n\n    private static final Comparator<Integer> REVERSE_INTEGER_COMPARATOR = new Comparator<Integer>() {\n        public int compare(Integer o1, Integer o2) {\n            return o2-o1;\n        }\n    };\n\n    private static final Logger LOGGER = Logger.getLogger(AbstractProject.class.getName());\n\n    /**\n     * Permission to abort a build\n     */\n    public static final Permission ABORT = CANCEL;\n\n    /**\n     * Replaceable \"Build Now\" text.\n     */\n    public static final Message<AbstractProject> BUILD_NOW_TEXT = new Message<AbstractProject>();\n\n    /**\n     * Used for CLI binding.\n     */\n    @CLIResolver\n    public static AbstractProject resolveForCLI(\n            @Argument(required=true,metaVar=\"NAME\",usage=\"Job name\") String name) throws CmdLineException {\n        AbstractProject item = Jenkins.getInstance().getItemByFullName(name, AbstractProject.class);\n        if (item==null)\n            throw new CmdLineException(null,Messages.AbstractItem_NoSuchJobExists(name,AbstractProject.findNearest(name).getFullName()));\n        return item;\n    }\n\n    public String getCustomWorkspace() {\n        return customWorkspace;\n    }\n\n    /**\n     * User-specified workspace directory, or null if it's up to Jenkins.\n     *\n     * <p>\n     * Normally a project uses the workspace location assigned by its parent container,\n     * but sometimes people have builds that have hard-coded paths.\n     *\n     * <p>\n     * This is not {@link File} because it may have to hold a path representation on another OS.\n     *\n     * <p>\n     * If this path is relative, it's resolved against {@link Node#getRootPath()} on the node where this workspace\n     * is prepared. \n     *\n     * @since 1.410\n     */\n    public void setCustomWorkspace(String customWorkspace) throws IOException {\n        this.customWorkspace= Util.fixEmptyAndTrim(customWorkspace);\n        save();\n    }\n    \n}\n", "/*\n * The MIT License\n *\n * Copyright (c) 2004-2009, Sun Microsystems, Inc., Alan Harder\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\npackage hudson.tasks;\n\nimport com.gargoylesoftware.htmlunit.html.HtmlForm;\nimport com.gargoylesoftware.htmlunit.html.HtmlPage;\nimport hudson.maven.MavenModuleSet;\nimport hudson.maven.MavenModuleSetBuild;\nimport hudson.model.FreeStyleBuild;\nimport hudson.model.FreeStyleProject;\nimport hudson.model.Result;\nimport hudson.model.Run;\nimport org.jvnet.hudson.test.ExtractResourceSCM;\nimport org.jvnet.hudson.test.HudsonTestCase;\nimport org.jvnet.hudson.test.MockBuilder;\n\n/**\n * Tests for hudson.tasks.BuildTrigger\n * @author Alan.Harder@sun.com\n */\npublic class BuildTriggerTest extends HudsonTestCase {\n\n    private FreeStyleProject createDownstreamProject() throws Exception {\n        FreeStyleProject dp = createFreeStyleProject(\"downstream\");\n\n        // Hm, no setQuietPeriod, have to submit form..\n        WebClient webClient = new WebClient();\n        HtmlPage page = webClient.getPage(dp,\"configure\");\n        HtmlForm form = page.getFormByName(\"config\");\n        form.getInputByName(\"hasCustomQuietPeriod\").click();\n        form.getInputByName(\"quiet_period\").setValueAttribute(\"0\");\n        submit(form);\n        assertEquals(\"set quiet period\", 0, dp.getQuietPeriod());\n\n        return dp;\n    }\n\n    private void doTriggerTest(boolean evenWhenUnstable, Result triggerResult,\n            Result dontTriggerResult) throws Exception {\n        FreeStyleProject p = createFreeStyleProject(),\n                dp = createDownstreamProject();\n        p.getPublishersList().add(new BuildTrigger(\"downstream\", evenWhenUnstable));\n        p.getBuildersList().add(new MockBuilder(dontTriggerResult));\n        jenkins.rebuildDependencyGraph();\n\n        // First build should not trigger downstream job\n        FreeStyleBuild b = p.scheduleBuild2(0).get();\n        assertNoDownstreamBuild(dp, b);\n\n        // Next build should trigger downstream job\n        p.getBuildersList().replace(new MockBuilder(triggerResult));\n        b = p.scheduleBuild2(0).get();\n        assertDownstreamBuild(dp, b);\n    }\n\n    private void assertNoDownstreamBuild(FreeStyleProject dp, Run<?,?> b) throws Exception {\n        for (int i = 0; i < 3; i++) {\n            Thread.sleep(200);\n            assertTrue(\"downstream build should not run!  upstream log: \" + getLog(b),\n                       !dp.isInQueue() && !dp.isBuilding() && dp.getLastBuild()==null);\n        }\n    }\n\n    private void assertDownstreamBuild(FreeStyleProject dp, Run<?,?> b) throws Exception {\n        // Wait for downstream build\n        for (int i = 0; dp.getLastBuild()==null && i < 20; i++) Thread.sleep(100);\n        assertNotNull(\"downstream build didn't run.. upstream log: \" + getLog(b), dp.getLastBuild());\n    }\n\n    public void testBuildTrigger() throws Exception {\n        doTriggerTest(false, Result.SUCCESS, Result.UNSTABLE);\n    }\n\n    public void testTriggerEvenWhenUnstable() throws Exception {\n        doTriggerTest(true, Result.UNSTABLE, Result.FAILURE);\n    }\n\n    private void doMavenTriggerTest(boolean evenWhenUnstable) throws Exception {\n        FreeStyleProject dp = createDownstreamProject();\n        configureDefaultMaven();\n        MavenModuleSet m = createMavenProject();\n        m.getPublishersList().add(new BuildTrigger(\"downstream\", evenWhenUnstable));\n        if (!evenWhenUnstable) {\n            // Configure for UNSTABLE\n            m.setGoals(\"clean test\");\n            m.setScm(new ExtractResourceSCM(getClass().getResource(\"maven-test-failure.zip\")));\n        } // otherwise do nothing which gets FAILURE\n        // First build should not trigger downstream project\n        MavenModuleSetBuild b = m.scheduleBuild2(0).get();\n        assertNoDownstreamBuild(dp, b);\n\n        if (evenWhenUnstable) {\n            // Configure for UNSTABLE\n            m.setGoals(\"clean test\");\n            m.setScm(new ExtractResourceSCM(getClass().getResource(\"maven-test-failure.zip\")));\n        } else {\n            // Configure for SUCCESS\n            m.setGoals(\"clean\");\n            m.setScm(new ExtractResourceSCM(getClass().getResource(\"maven-empty.zip\")));\n        }\n        // Next build should trigger downstream project\n        b = m.scheduleBuild2(0).get();\n        assertDownstreamBuild(dp, b);\n    }\n\n    public void testMavenBuildTrigger() throws Exception {\n        doMavenTriggerTest(false);\n    }\n\n    public void testMavenTriggerEvenWhenUnstable() throws Exception {\n        doMavenTriggerTest(true);\n    }\n}\n"], "fixing_code": ["/*\n * The MIT License\n * \n * Copyright (c) 2004-2011, Sun Microsystems, Inc., Kohsuke Kawaguchi,\n * Brian Westrich, Erik Ramfelt, Ertan Deniz, Jean-Baptiste Quenot,\n * Luca Domenico Milanesio, R. Tyler Ballance, Stephen Connolly, Tom Huybrechts,\n * id:cactusman, Yahoo! Inc., Andrew Bayer, Manufacture Francaise des Pneumatiques\n * Michelin, Romain Seguy\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n * \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\npackage hudson.model;\n\nimport com.infradna.tool.bridge_method_injector.WithBridgeMethods;\nimport hudson.EnvVars;\nimport hudson.Functions;\nimport antlr.ANTLRException;\nimport hudson.AbortException;\nimport hudson.CopyOnWrite;\nimport hudson.FeedAdapter;\nimport hudson.FilePath;\nimport hudson.Launcher;\nimport hudson.Util;\nimport hudson.cli.declarative.CLIMethod;\nimport hudson.cli.declarative.CLIResolver;\nimport hudson.model.Cause.LegacyCodeCause;\nimport hudson.model.Cause.RemoteCause;\nimport hudson.model.Cause.UserIdCause;\nimport hudson.model.Descriptor.FormException;\nimport hudson.model.Fingerprint.RangeSet;\nimport hudson.model.Queue.Executable;\nimport hudson.model.Queue.Task;\nimport hudson.model.queue.QueueTaskFuture;\nimport hudson.model.queue.SubTask;\nimport hudson.model.Queue.WaitingItem;\nimport hudson.model.RunMap.Constructor;\nimport hudson.model.labels.LabelAtom;\nimport hudson.model.labels.LabelExpression;\nimport hudson.model.listeners.SCMPollListener;\nimport hudson.model.queue.CauseOfBlockage;\nimport hudson.model.queue.SubTaskContributor;\nimport hudson.scm.ChangeLogSet;\nimport hudson.scm.ChangeLogSet.Entry;\nimport hudson.scm.NullSCM;\nimport hudson.scm.PollingResult;\nimport hudson.scm.SCM;\nimport hudson.scm.SCMRevisionState;\nimport hudson.scm.SCMS;\nimport hudson.search.SearchIndexBuilder;\nimport hudson.security.ACL;\nimport hudson.security.Permission;\nimport hudson.slaves.WorkspaceList;\nimport hudson.tasks.BuildStep;\nimport hudson.tasks.BuildStepDescriptor;\nimport hudson.tasks.BuildTrigger;\nimport hudson.tasks.BuildWrapperDescriptor;\nimport hudson.tasks.Publisher;\nimport hudson.triggers.SCMTrigger;\nimport hudson.triggers.Trigger;\nimport hudson.triggers.TriggerDescriptor;\nimport hudson.util.AlternativeUiTextProvider;\nimport hudson.util.AlternativeUiTextProvider.Message;\nimport hudson.util.DescribableList;\nimport hudson.util.EditDistance;\nimport hudson.util.FormValidation;\nimport hudson.widgets.BuildHistoryWidget;\nimport hudson.widgets.HistoryWidget;\nimport jenkins.model.Jenkins;\nimport jenkins.model.JenkinsLocationConfiguration;\nimport jenkins.model.lazy.AbstractLazyLoadRunMap.Direction;\nimport jenkins.scm.DefaultSCMCheckoutStrategyImpl;\nimport jenkins.scm.SCMCheckoutStrategy;\nimport jenkins.scm.SCMCheckoutStrategyDescriptor;\nimport jenkins.util.TimeDuration;\nimport net.sf.json.JSONObject;\nimport org.acegisecurity.context.SecurityContext;\nimport org.acegisecurity.context.SecurityContextHolder;\nimport org.kohsuke.accmod.Restricted;\nimport org.kohsuke.accmod.restrictions.NoExternalUse;\nimport org.kohsuke.args4j.Argument;\nimport org.kohsuke.args4j.CmdLineException;\nimport org.kohsuke.stapler.ForwardToView;\nimport org.kohsuke.stapler.HttpRedirect;\nimport org.kohsuke.stapler.HttpResponse;\nimport org.kohsuke.stapler.HttpResponses;\nimport org.kohsuke.stapler.QueryParameter;\nimport org.kohsuke.stapler.StaplerRequest;\nimport org.kohsuke.stapler.StaplerResponse;\nimport org.kohsuke.stapler.export.Exported;\nimport org.kohsuke.stapler.interceptor.RequirePOST;\n\nimport javax.servlet.ServletException;\nimport java.io.File;\nimport java.io.IOException;\nimport java.lang.reflect.InvocationTargetException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Calendar;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.SortedMap;\nimport java.util.TreeMap;\nimport java.util.Vector;\nimport java.util.concurrent.Future;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\nimport static hudson.scm.PollingResult.*;\nimport static javax.servlet.http.HttpServletResponse.*;\n\n/**\n * Base implementation of {@link Job}s that build software.\n *\n * For now this is primarily the common part of {@link Project} and MavenModule.\n *\n * @author Kohsuke Kawaguchi\n * @see AbstractBuild\n */\n@SuppressWarnings(\"rawtypes\")\npublic abstract class AbstractProject<P extends AbstractProject<P,R>,R extends AbstractBuild<P,R>> extends Job<P,R> implements BuildableItem {\n\n    /**\n     * {@link SCM} associated with the project.\n     * To allow derived classes to link {@link SCM} config to elsewhere,\n     * access to this variable should always go through {@link #getScm()}.\n     */\n    private volatile SCM scm = new NullSCM();\n\n    /**\n     * Controls how the checkout is done.\n     */\n    private volatile SCMCheckoutStrategy scmCheckoutStrategy;\n\n    /**\n     * State returned from {@link SCM#poll(AbstractProject, Launcher, FilePath, TaskListener, SCMRevisionState)}.\n     */\n    private volatile transient SCMRevisionState pollingBaseline = null;\n\n    /**\n     * All the builds keyed by their build number.\n     *\n     * External code should use {@link #getBuildByNumber(int)} or {@link #getLastBuild()} and traverse via\n     * {@link Run#getPreviousBuild()}\n     */\n    @Restricted(NoExternalUse.class)\n    @SuppressWarnings(\"deprecation\") // [JENKINS-15156] builds accessed before onLoad or onCreatedFromScratch called\n    protected transient RunMap<R> builds = new RunMap<R>();\n\n    /**\n     * The quiet period. Null to delegate to the system default.\n     */\n    private volatile Integer quietPeriod = null;\n    \n    /**\n     * The retry count. Null to delegate to the system default.\n     */\n    private volatile Integer scmCheckoutRetryCount = null;\n\n    /**\n     * If this project is configured to be only built on a certain label,\n     * this value will be set to that label.\n     *\n     * For historical reasons, this is called 'assignedNode'. Also for\n     * a historical reason, null to indicate the affinity\n     * with the master node.\n     *\n     * @see #canRoam\n     */\n    private String assignedNode;\n\n    /**\n     * True if this project can be built on any node.\n     *\n     * <p>\n     * This somewhat ugly flag combination is so that we can migrate\n     * existing Hudson installations nicely.\n     */\n    private volatile boolean canRoam;\n\n    /**\n     * True to suspend new builds.\n     */\n    protected volatile boolean disabled;\n\n    /**\n     * True to keep builds of this project in queue when downstream projects are\n     * building. False by default to keep from breaking existing behavior.\n     */\n    protected volatile boolean blockBuildWhenDownstreamBuilding = false;\n\n    /**\n     * True to keep builds of this project in queue when upstream projects are\n     * building. False by default to keep from breaking existing behavior.\n     */\n    protected volatile boolean blockBuildWhenUpstreamBuilding = false;\n\n    /**\n     * Identifies {@link JDK} to be used.\n     * Null if no explicit configuration is required.\n     *\n     * <p>\n     * Can't store {@link JDK} directly because {@link Jenkins} and {@link Project}\n     * are saved independently.\n     *\n     * @see Jenkins#getJDK(String)\n     */\n    private volatile String jdk;\n\n    private volatile BuildAuthorizationToken authToken = null;\n\n    /**\n     * List of all {@link Trigger}s for this project.\n     */\n    protected List<Trigger<?>> triggers = new Vector<Trigger<?>>();\n\n    /**\n     * {@link Action}s contributed from subsidiary objects associated with\n     * {@link AbstractProject}, such as from triggers, builders, publishers, etc.\n     *\n     * We don't want to persist them separately, and these actions\n     * come and go as configuration change, so it's kept separate.\n     */\n    @CopyOnWrite\n    protected transient volatile List<Action> transientActions = new Vector<Action>();\n\n    private boolean concurrentBuild;\n\n    /**\n     * See {@link #setCustomWorkspace(String)}.\n     *\n     * @since 1.410\n     */\n    private String customWorkspace;\n    \n    protected AbstractProject(ItemGroup parent, String name) {\n        super(parent,name);\n\n        if(!Jenkins.getInstance().getNodes().isEmpty()) {\n            // if a new job is configured with Hudson that already has slave nodes\n            // make it roamable by default\n            canRoam = true;\n        }\n    }\n\n    @Override\n    public synchronized void save() throws IOException {\n        super.save();\n        updateTransientActions();\n    }\n\n    @Override\n    public void onCreatedFromScratch() {\n        super.onCreatedFromScratch();\n        builds = createBuildRunMap();\n        // solicit initial contributions, especially from TransientProjectActionFactory\n        updateTransientActions();\n    }\n\n    @Override\n    public void onLoad(ItemGroup<? extends Item> parent, String name) throws IOException {\n        super.onLoad(parent, name);\n\n        RunMap<R> builds = createBuildRunMap();\n\n        RunMap<R> currentBuilds = this.builds;\n\n        if (currentBuilds==null) {\n            // are we overwriting what currently exist?\n            // this is primarily when Jenkins is getting reloaded\n            Item current = parent.getItem(name);\n            if (current!=null && current.getClass()==getClass()) {\n                currentBuilds = ((AbstractProject)current).builds;\n            }\n        }\n        if (currentBuilds !=null) {\n            // if we are reloading, keep all those that are still building intact\n            for (R r : currentBuilds.getLoadedBuilds().values()) {\n                if (r.isBuilding())\n                    builds.put(r);\n            }\n        }\n        this.builds = builds;\n        for (Trigger t : triggers())\n            t.start(this, Items.updatingByXml.get());\n        if(scm==null)\n            scm = new NullSCM(); // perhaps it was pointing to a plugin that no longer exists.\n\n        if(transientActions==null)\n            transientActions = new Vector<Action>();    // happens when loaded from disk\n        updateTransientActions();\n    }\n\n    private RunMap<R> createBuildRunMap() {\n        return new RunMap<R>(getBuildDir(), new Constructor<R>() {\n            public R create(File dir) throws IOException {\n                return loadBuild(dir);\n            }\n        });\n    }\n\n    private synchronized List<Trigger<?>> triggers() {\n        if (triggers == null) {\n            triggers = new Vector<Trigger<?>>();\n        }\n        return triggers;\n    }\n\n    @Override\n    public EnvVars getEnvironment(Node node, TaskListener listener) throws IOException, InterruptedException {\n        EnvVars env =  super.getEnvironment(node, listener);\n\n        JDK jdk = getJDK();\n        if (jdk != null) {\n            if (node != null) { // just in case were not in a build\n                jdk = jdk.forNode(node, listener);\n            }\n            jdk.buildEnvVars(env);\n        }\n\n        return env;\n    }\n\n    @Override\n    protected void performDelete() throws IOException, InterruptedException {\n        // prevent a new build while a delete operation is in progress\n        makeDisabled(true);\n        FilePath ws = getWorkspace();\n        if(ws!=null) {\n            Node on = getLastBuiltOn();\n            getScm().processWorkspaceBeforeDeletion(this, ws, on);\n            if(on!=null)\n                on.getFileSystemProvisioner().discardWorkspace(this,ws);\n        }\n        super.performDelete();\n    }\n\n    /**\n     * Does this project perform concurrent builds?\n     * @since 1.319\n     */\n    @Exported\n    public boolean isConcurrentBuild() {\n        return concurrentBuild;\n    }\n\n    public void setConcurrentBuild(boolean b) throws IOException {\n        concurrentBuild = b;\n        save();\n    }\n\n    /**\n     * If this project is configured to be always built on this node,\n     * return that {@link Node}. Otherwise null.\n     */\n    public Label getAssignedLabel() {\n        if(canRoam)\n            return null;\n\n        if(assignedNode==null)\n            return Jenkins.getInstance().getSelfLabel();\n        return Jenkins.getInstance().getLabel(assignedNode);\n    }\n\n    /**\n     * Set of labels relevant to this job.\n     *\n     * This method is used to determine what slaves are relevant to jobs, for example by {@link View}s.\n     * It does not affect the scheduling. This information is informational and the best-effort basis.\n     *\n     * @since 1.456\n     * @return\n     *      Minimally it should contain {@link #getAssignedLabel()}. The set can contain null element\n     *      to correspond to the null return value from {@link #getAssignedLabel()}.\n     */\n    public Set<Label> getRelevantLabels() {\n        return Collections.singleton(getAssignedLabel());\n    }\n\n    /**\n     * Gets the textual representation of the assigned label as it was entered by the user.\n     */\n    public String getAssignedLabelString() {\n        if (canRoam || assignedNode==null)    return null;\n        try {\n            LabelExpression.parseExpression(assignedNode);\n            return assignedNode;\n        } catch (ANTLRException e) {\n            // must be old label or host name that includes whitespace or other unsafe chars\n            return LabelAtom.escape(assignedNode);\n        }\n    }\n\n    /**\n     * Sets the assigned label.\n     */\n    public void setAssignedLabel(Label l) throws IOException {\n        if(l==null) {\n            canRoam = true;\n            assignedNode = null;\n        } else {\n            canRoam = false;\n            if(l== Jenkins.getInstance().getSelfLabel())  assignedNode = null;\n            else                                        assignedNode = l.getExpression();\n        }\n        save();\n    }\n\n    /**\n     * Assigns this job to the given node. A convenience method over {@link #setAssignedLabel(Label)}.\n     */\n    public void setAssignedNode(Node l) throws IOException {\n        setAssignedLabel(l.getSelfLabel());\n    }\n\n    /**\n     * Get the term used in the UI to represent this kind of {@link AbstractProject}.\n     * Must start with a capital letter.\n     */\n    @Override\n    public String getPronoun() {\n        return AlternativeUiTextProvider.get(PRONOUN, this,Messages.AbstractProject_Pronoun());\n    }\n\n    /**\n     * Gets the human readable display name to be rendered in the \"Build Now\" link.\n     *\n     * @since 1.401\n     */\n    public String getBuildNowText() {\n        return AlternativeUiTextProvider.get(BUILD_NOW_TEXT,this,Messages.AbstractProject_BuildNow());\n    }\n\n    /**\n     * Gets the nearest ancestor {@link TopLevelItem} that's also an {@link AbstractProject}.\n     *\n     * <p>\n     * Some projects (such as matrix projects, Maven projects, or promotion processes) form a tree of jobs\n     * that acts as a single unit. This method can be used to find the top most dominating job that\n     * covers such a tree.\n     *\n     * @return never null.\n     * @see AbstractBuild#getRootBuild()\n     */\n    public AbstractProject<?,?> getRootProject() {\n        if (this instanceof TopLevelItem) {\n            return this;\n        } else {\n            ItemGroup p = this.getParent();\n            if (p instanceof AbstractProject)\n                return ((AbstractProject) p).getRootProject();\n            return this;\n        }\n    }\n\n    /**\n     * Gets the directory where the module is checked out.\n     *\n     * @return\n     *      null if the workspace is on a slave that's not connected.\n     * @deprecated as of 1.319\n     *      To support concurrent builds of the same project, this method is moved to {@link AbstractBuild}.\n     *      For backward compatibility, this method returns the right {@link AbstractBuild#getWorkspace()} if called\n     *      from {@link Executor}, and otherwise the workspace of the last build.\n     *\n     *      <p>\n     *      If you are calling this method during a build from an executor, switch it to {@link AbstractBuild#getWorkspace()}.\n     *      If you are calling this method to serve a file from the workspace, doing a form validation, etc., then\n     *      use {@link #getSomeWorkspace()}\n     */\n    public final FilePath getWorkspace() {\n        AbstractBuild b = getBuildForDeprecatedMethods();\n        return b != null ? b.getWorkspace() : null;\n\n    }\n    \n    /**\n     * Various deprecated methods in this class all need the 'current' build.  This method returns\n     * the build suitable for that purpose.\n     * \n     * @return An AbstractBuild for deprecated methods to use.\n     */\n    private AbstractBuild getBuildForDeprecatedMethods() {\n        Executor e = Executor.currentExecutor();\n        if(e!=null) {\n            Executable exe = e.getCurrentExecutable();\n            if (exe instanceof AbstractBuild) {\n                AbstractBuild b = (AbstractBuild) exe;\n                if(b.getProject()==this)\n                    return b;\n            }\n        }\n        R lb = getLastBuild();\n        if(lb!=null)    return lb;\n        return null;\n    }\n\n    /**\n     * Gets a workspace for some build of this project.\n     *\n     * <p>\n     * This is useful for obtaining a workspace for the purpose of form field validation, where exactly\n     * which build the workspace belonged is less important. The implementation makes a cursory effort\n     * to find some workspace.\n     *\n     * @return\n     *      null if there's no available workspace.\n     * @since 1.319\n     */\n    public final FilePath getSomeWorkspace() {\n        R b = getSomeBuildWithWorkspace();\n        if (b!=null) return b.getWorkspace();\n        for (WorkspaceBrowser browser : Jenkins.getInstance().getExtensionList(WorkspaceBrowser.class)) {\n            FilePath f = browser.getWorkspace(this);\n            if (f != null) return f;\n        }\n        return null;\n    }\n\n    /**\n     * Gets some build that has a live workspace.\n     *\n     * @return null if no such build exists.\n     */\n    public final R getSomeBuildWithWorkspace() {\n        int cnt=0;\n        for (R b = getLastBuild(); cnt<5 && b!=null; b=b.getPreviousBuild()) {\n            FilePath ws = b.getWorkspace();\n            if (ws!=null)   return b;\n        }\n        return null;\n    }\n\n    /**\n     * Returns the root directory of the checked-out module.\n     * <p>\n     * This is usually where <tt>pom.xml</tt>, <tt>build.xml</tt>\n     * and so on exists.\n     *\n     * @deprecated as of 1.319\n     *      See {@link #getWorkspace()} for a migration strategy.\n     */\n    public FilePath getModuleRoot() {\n        AbstractBuild b = getBuildForDeprecatedMethods();\n        return b != null ? b.getModuleRoot() : null;\n    }\n\n    /**\n     * Returns the root directories of all checked-out modules.\n     * <p>\n     * Some SCMs support checking out multiple modules into the same workspace.\n     * In these cases, the returned array will have a length greater than one.\n     * @return The roots of all modules checked out from the SCM.\n     *\n     * @deprecated as of 1.319\n     *      See {@link #getWorkspace()} for a migration strategy.\n     */\n    public FilePath[] getModuleRoots() {\n        AbstractBuild b = getBuildForDeprecatedMethods();\n        return b != null ? b.getModuleRoots() : null;\n    }\n\n    public int getQuietPeriod() {\n        return quietPeriod!=null ? quietPeriod : Jenkins.getInstance().getQuietPeriod();\n    }\n\n    public SCMCheckoutStrategy getScmCheckoutStrategy() {\n        return scmCheckoutStrategy == null ? new DefaultSCMCheckoutStrategyImpl() : scmCheckoutStrategy;\n    }\n\n    public void setScmCheckoutStrategy(SCMCheckoutStrategy scmCheckoutStrategy) throws IOException {\n        this.scmCheckoutStrategy = scmCheckoutStrategy;\n        save();\n    }\n\n\n    public int getScmCheckoutRetryCount() {\n        return scmCheckoutRetryCount !=null ? scmCheckoutRetryCount : Jenkins.getInstance().getScmCheckoutRetryCount();\n    }\n\n    // ugly name because of EL\n    public boolean getHasCustomQuietPeriod() {\n        return quietPeriod!=null;\n    }\n\n    /**\n     * Sets the custom quiet period of this project, or revert to the global default if null is given. \n     */\n    public void setQuietPeriod(Integer seconds) throws IOException {\n        this.quietPeriod = seconds;\n        save();\n    }\n    \n    public boolean hasCustomScmCheckoutRetryCount(){\n        return scmCheckoutRetryCount != null;\n    }\n\n    @Override\n    public boolean isBuildable() {\n        return !isDisabled() && !isHoldOffBuildUntilSave();\n    }\n\n    /**\n     * Used in <tt>sidepanel.jelly</tt> to decide whether to display\n     * the config/delete/build links.\n     */\n    public boolean isConfigurable() {\n        return true;\n    }\n\n    public boolean blockBuildWhenDownstreamBuilding() {\n        return blockBuildWhenDownstreamBuilding;\n    }\n\n    public void setBlockBuildWhenDownstreamBuilding(boolean b) throws IOException {\n        blockBuildWhenDownstreamBuilding = b;\n        save();\n    }\n\n    public boolean blockBuildWhenUpstreamBuilding() {\n        return blockBuildWhenUpstreamBuilding;\n    }\n\n    public void setBlockBuildWhenUpstreamBuilding(boolean b) throws IOException {\n        blockBuildWhenUpstreamBuilding = b;\n        save();\n    }\n\n    public boolean isDisabled() {\n        return disabled;\n    }\n    \n    /**\n     * Validates the retry count Regex\n     */\n    public FormValidation doCheckRetryCount(@QueryParameter String value)throws IOException,ServletException{\n        // retry count is optional so this is ok\n        if(value == null || value.trim().equals(\"\"))\n            return FormValidation.ok();\n        if (!value.matches(\"[0-9]*\")) {\n            return FormValidation.error(\"Invalid retry count\");\n        } \n        return FormValidation.ok();\n    }\n\n    /**\n     * Marks the build as disabled.\n     */\n    public void makeDisabled(boolean b) throws IOException {\n        if(disabled==b)     return; // noop\n        this.disabled = b;\n        if(b)\n            Jenkins.getInstance().getQueue().cancel(this);\n        save();\n    }\n\n    /**\n     * Specifies whether this project may be disabled by the user.\n     * By default, it can be only if this is a {@link TopLevelItem};\n     * would be false for matrix configurations, etc.\n     * @return true if the GUI should allow {@link #doDisable} and the like\n     * @since 1.475\n     */\n    public boolean supportsMakeDisabled() {\n        return this instanceof TopLevelItem;\n    }\n\n    public void disable() throws IOException {\n        makeDisabled(true);\n    }\n\n    public void enable() throws IOException {\n        makeDisabled(false);\n    }\n\n    @Override\n    public BallColor getIconColor() {\n        if(isDisabled())\n            return BallColor.DISABLED;\n        else\n            return super.getIconColor();\n    }\n\n    /**\n     * effectively deprecated. Since using updateTransientActions correctly\n     * under concurrent environment requires a lock that can too easily cause deadlocks.\n     *\n     * <p>\n     * Override {@link #createTransientActions()} instead.\n     */\n    protected void updateTransientActions() {\n        transientActions = createTransientActions();\n    }\n\n    protected List<Action> createTransientActions() {\n        Vector<Action> ta = new Vector<Action>();\n\n        for (JobProperty<? super P> p : Util.fixNull(properties))\n            ta.addAll(p.getJobActions((P)this));\n\n        for (TransientProjectActionFactory tpaf : TransientProjectActionFactory.all())\n            ta.addAll(Util.fixNull(tpaf.createFor(this))); // be defensive against null\n        return ta;\n    }\n\n    /**\n     * Returns the live list of all {@link Publisher}s configured for this project.\n     *\n     * <p>\n     * This method couldn't be called <tt>getPublishers()</tt> because existing methods\n     * in sub-classes return different inconsistent types.\n     */\n    public abstract DescribableList<Publisher,Descriptor<Publisher>> getPublishersList();\n\n    @Override\n    public void addProperty(JobProperty<? super P> jobProp) throws IOException {\n        super.addProperty(jobProp);\n        updateTransientActions();\n    }\n\n    public List<ProminentProjectAction> getProminentActions() {\n        List<Action> a = getActions();\n        List<ProminentProjectAction> pa = new Vector<ProminentProjectAction>();\n        for (Action action : a) {\n            if(action instanceof ProminentProjectAction)\n                pa.add((ProminentProjectAction) action);\n        }\n        return pa;\n    }\n\n    @Override\n    public void doConfigSubmit( StaplerRequest req, StaplerResponse rsp ) throws IOException, ServletException, FormException {\n        super.doConfigSubmit(req,rsp);\n\n        updateTransientActions();\n\n        Set<AbstractProject> upstream = Collections.emptySet();\n        if(req.getParameter(\"pseudoUpstreamTrigger\")!=null) {\n            upstream = new HashSet<AbstractProject>(Items.fromNameList(getParent(),req.getParameter(\"upstreamProjects\"),AbstractProject.class));\n        }\n\n        // dependency setting might have been changed by the user, so rebuild.\n        Jenkins.getInstance().rebuildDependencyGraph();\n        convertUpstreamBuildTrigger(upstream);\n\n\n        // notify the queue as the project might be now tied to different node\n        Jenkins.getInstance().getQueue().scheduleMaintenance();\n\n        // this is to reflect the upstream build adjustments done above\n        Jenkins.getInstance().rebuildDependencyGraph();\n    }\n\n    /**\n     * Reflect the submission of the pseudo 'upstream build trigger'.\n     */\n    /* package */ void convertUpstreamBuildTrigger(Set<AbstractProject> upstream) throws IOException {\n\n        SecurityContext saveCtx = ACL.impersonate(ACL.SYSTEM);\n        try {\n            for (AbstractProject<?,?> p : Jenkins.getInstance().getAllItems(AbstractProject.class)) {\n                // Don't consider child projects such as MatrixConfiguration:\n                if (!p.isConfigurable()) continue;\n                boolean isUpstream = upstream.contains(p);\n                synchronized(p) {\n                    // does 'p' include us in its BuildTrigger?\n                    DescribableList<Publisher,Descriptor<Publisher>> pl = p.getPublishersList();\n                    BuildTrigger trigger = pl.get(BuildTrigger.class);\n                    List<AbstractProject> newChildProjects = trigger == null ? new ArrayList<AbstractProject>():trigger.getChildProjects(p);\n                    if(isUpstream) {\n                        if(!newChildProjects.contains(this))\n                            newChildProjects.add(this);\n                    } else {\n                        newChildProjects.remove(this);\n                    }\n\n                    if(newChildProjects.isEmpty()) {\n                        pl.remove(BuildTrigger.class);\n                    } else {\n                        // here, we just need to replace the old one with the new one,\n                        // but there was a regression (we don't know when it started) that put multiple BuildTriggers\n                        // into the list. For us not to lose the data, we need to merge them all.\n                        List<BuildTrigger> existingList = pl.getAll(BuildTrigger.class);\n                        BuildTrigger existing;\n                        switch (existingList.size()) {\n                        case 0:\n                            existing = null;\n                            break;\n                        case 1:\n                            existing = existingList.get(0);\n                            break;\n                        default:\n                            pl.removeAll(BuildTrigger.class);\n                            Set<AbstractProject> combinedChildren = new HashSet<AbstractProject>();\n                            for (BuildTrigger bt : existingList)\n                                combinedChildren.addAll(bt.getChildProjects(p));\n                            existing = new BuildTrigger(new ArrayList<AbstractProject>(combinedChildren),existingList.get(0).getThreshold());\n                            pl.add(existing);\n                            break;\n                        }\n\n                        if(existing!=null && existing.hasSame(p,newChildProjects))\n                            continue;   // no need to touch\n                        pl.replace(new BuildTrigger(newChildProjects,\n                            existing==null? Result.SUCCESS:existing.getThreshold()));\n                    }\n                }\n            }\n        } finally {\n            SecurityContextHolder.setContext(saveCtx);\n        }\n    }\n\n    /**\n\t * @deprecated\n\t *    Use {@link #scheduleBuild(Cause)}.  Since 1.283\n\t */\n    public boolean scheduleBuild() {\n    \treturn scheduleBuild(new LegacyCodeCause());\n    }\n    \n\t/**\n\t * @deprecated\n\t *    Use {@link #scheduleBuild(int, Cause)}.  Since 1.283\n\t */\n    public boolean scheduleBuild(int quietPeriod) {\n    \treturn scheduleBuild(quietPeriod, new LegacyCodeCause());\n    }\n    \n    /**\n     * Schedules a build of this project.\n     *\n     * @return\n     *      true if the project is actually added to the queue.\n     *      false if the queue contained it and therefore the add()\n     *      was noop\n     */\n    public boolean scheduleBuild(Cause c) {\n        return scheduleBuild(getQuietPeriod(), c);\n    }\n\n    public boolean scheduleBuild(int quietPeriod, Cause c) {\n        return scheduleBuild(quietPeriod, c, new Action[0]);\n    }\n\n    /**\n     * Schedules a build.\n     *\n     * Important: the actions should be persistable without outside references (e.g. don't store\n     * references to this project). To provide parameters for a parameterized project, add a ParametersAction. If\n     * no ParametersAction is provided for such a project, one will be created with the default parameter values.\n     *\n     * @param quietPeriod the quiet period to observer\n     * @param c the cause for this build which should be recorded\n     * @param actions a list of Actions that will be added to the build\n     * @return whether the build was actually scheduled\n     */\n    public boolean scheduleBuild(int quietPeriod, Cause c, Action... actions) {\n        return scheduleBuild2(quietPeriod,c,actions)!=null;\n    }\n\n    /**\n     * Schedules a build of this project, and returns a {@link Future} object\n     * to wait for the completion of the build.\n     *\n     * @param actions\n     *      For the convenience of the caller, this array can contain null, and those will be silently ignored.\n     */\n    @WithBridgeMethods(Future.class)\n    public QueueTaskFuture<R> scheduleBuild2(int quietPeriod, Cause c, Action... actions) {\n        return scheduleBuild2(quietPeriod,c,Arrays.asList(actions));\n    }\n\n    /**\n     * Schedules a build of this project, and returns a {@link Future} object\n     * to wait for the completion of the build.\n     *\n     * @param actions\n     *      For the convenience of the caller, this collection can contain null, and those will be silently ignored.\n     * @since 1.383\n     */\n    @SuppressWarnings(\"unchecked\")\n    @WithBridgeMethods(Future.class)\n    public QueueTaskFuture<R> scheduleBuild2(int quietPeriod, Cause c, Collection<? extends Action> actions) {\n        if (!isBuildable())\n            return null;\n\n        List<Action> queueActions = new ArrayList<Action>(actions);\n        if (isParameterized() && Util.filter(queueActions, ParametersAction.class).isEmpty()) {\n            queueActions.add(new ParametersAction(getDefaultParametersValues()));\n        }\n\n        if (c != null) {\n            queueActions.add(new CauseAction(c));\n        }\n\n        WaitingItem i = Jenkins.getInstance().getQueue().schedule(this, quietPeriod, queueActions);\n        if(i!=null)\n            return (QueueTaskFuture)i.getFuture();\n        return null;\n    }\n\n    private List<ParameterValue> getDefaultParametersValues() {\n        ParametersDefinitionProperty paramDefProp = getProperty(ParametersDefinitionProperty.class);\n        ArrayList<ParameterValue> defValues = new ArrayList<ParameterValue>();\n        \n        /*\n         * This check is made ONLY if someone will call this method even if isParametrized() is false.\n         */\n        if(paramDefProp == null)\n            return defValues;\n        \n        /* Scan for all parameter with an associated default values */\n        for(ParameterDefinition paramDefinition : paramDefProp.getParameterDefinitions())\n        {\n           ParameterValue defaultValue  = paramDefinition.getDefaultParameterValue();\n            \n            if(defaultValue != null)\n                defValues.add(defaultValue);           \n        }\n        \n        return defValues;\n    }\n\n    /**\n     * Schedules a build, and returns a {@link Future} object\n     * to wait for the completion of the build.\n     *\n     * <p>\n     * Production code shouldn't be using this, but for tests this is very convenient, so this isn't marked\n     * as deprecated.\n     */\n    @SuppressWarnings(\"deprecation\")\n    @WithBridgeMethods(Future.class)\n    public QueueTaskFuture<R> scheduleBuild2(int quietPeriod) {\n        return scheduleBuild2(quietPeriod, new LegacyCodeCause());\n    }\n    \n    /**\n     * Schedules a build of this project, and returns a {@link Future} object\n     * to wait for the completion of the build.\n     */\n    @WithBridgeMethods(Future.class)\n    public QueueTaskFuture<R> scheduleBuild2(int quietPeriod, Cause c) {\n        return scheduleBuild2(quietPeriod, c, new Action[0]);\n    }\n\n    /**\n     * Schedules a polling of this project.\n     */\n    public boolean schedulePolling() {\n        if(isDisabled())    return false;\n        SCMTrigger scmt = getTrigger(SCMTrigger.class);\n        if(scmt==null)      return false;\n        scmt.run();\n        return true;\n    }\n\n    /**\n     * Returns true if the build is in the queue.\n     */\n    @Override\n    public boolean isInQueue() {\n        return Jenkins.getInstance().getQueue().contains(this);\n    }\n\n    @Override\n    public Queue.Item getQueueItem() {\n        return Jenkins.getInstance().getQueue().getItem(this);\n    }\n\n    /**\n     * Gets the JDK that this project is configured with, or null.\n     */\n    public JDK getJDK() {\n        return Jenkins.getInstance().getJDK(jdk);\n    }\n\n    /**\n     * Overwrites the JDK setting.\n     */\n    public void setJDK(JDK jdk) throws IOException {\n        this.jdk = jdk.getName();\n        save();\n    }\n\n    public BuildAuthorizationToken getAuthToken() {\n        return authToken;\n    }\n\n    @Override\n    public RunMap<R> _getRuns() {\n        assert builds.baseDirInitialized() : \"neither onCreatedFromScratch nor onLoad called on \" + this + \" yet\";\n        return builds;\n    }\n\n    @Override\n    public void removeRun(R run) {\n        this.builds.remove(run);\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * More efficient implementation.\n     */\n    @Override\n    public R getBuild(String id) {\n        return builds.getById(id);\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * More efficient implementation.\n     */\n    @Override\n    public R getBuildByNumber(int n) {\n        return builds.getByNumber(n);\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * More efficient implementation.\n     */\n    @Override\n    public R getFirstBuild() {\n        return builds.oldestBuild();\n    }\n\n    @Override\n    public R getLastBuild() {\n        return builds.newestBuild();\n    }\n\n    @Override\n    public R getNearestBuild(int n) {\n        return builds.search(n, Direction.ASC);\n    }\n\n    @Override\n    public R getNearestOldBuild(int n) {\n        return builds.search(n, Direction.DESC);\n    }\n\n    /**\n     * Determines Class&lt;R>.\n     */\n    protected abstract Class<R> getBuildClass();\n\n    // keep track of the previous time we started a build\n    private transient long lastBuildStartTime;\n    \n    /**\n     * Creates a new build of this project for immediate execution.\n     */\n    protected synchronized R newBuild() throws IOException {\n    \t// make sure we don't start two builds in the same second\n    \t// so the build directories will be different too\n    \tlong timeSinceLast = System.currentTimeMillis() - lastBuildStartTime;\n    \tif (timeSinceLast < 1000) {\n    \t\ttry {\n\t\t\t\tThread.sleep(1000 - timeSinceLast);\n\t\t\t} catch (InterruptedException e) {\n\t\t\t}\n    \t}\n    \tlastBuildStartTime = System.currentTimeMillis();\n        try {\n            R lastBuild = getBuildClass().getConstructor(getClass()).newInstance(this);\n            builds.put(lastBuild);\n            return lastBuild;\n        } catch (InstantiationException e) {\n            throw new Error(e);\n        } catch (IllegalAccessException e) {\n            throw new Error(e);\n        } catch (InvocationTargetException e) {\n            throw handleInvocationTargetException(e);\n        } catch (NoSuchMethodException e) {\n            throw new Error(e);\n        }\n    }\n\n    private IOException handleInvocationTargetException(InvocationTargetException e) {\n        Throwable t = e.getTargetException();\n        if(t instanceof Error)  throw (Error)t;\n        if(t instanceof RuntimeException)   throw (RuntimeException)t;\n        if(t instanceof IOException)    return (IOException)t;\n        throw new Error(t);\n    }\n\n    /**\n     * Loads an existing build record from disk.\n     */\n    protected R loadBuild(File dir) throws IOException {\n        try {\n            return getBuildClass().getConstructor(getClass(),File.class).newInstance(this,dir);\n        } catch (InstantiationException e) {\n            throw new Error(e);\n        } catch (IllegalAccessException e) {\n            throw new Error(e);\n        } catch (InvocationTargetException e) {\n            throw handleInvocationTargetException(e);\n        } catch (NoSuchMethodException e) {\n            throw new Error(e);\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * <p>\n     * Note that this method returns a read-only view of {@link Action}s.\n     * {@link BuildStep}s and others who want to add a project action\n     * should do so by implementing {@link BuildStep#getProjectActions(AbstractProject)}.\n     *\n     * @see TransientProjectActionFactory\n     */\n    @Override\n    public List<Action> getActions() {\n        // add all the transient actions, too\n        List<Action> actions = new Vector<Action>(super.getActions());\n        actions.addAll(transientActions);\n        // return the read only list to cause a failure on plugins who try to add an action here\n        return Collections.unmodifiableList(actions);\n    }\n\n    /**\n     * Gets the {@link Node} where this project was last built on.\n     *\n     * @return\n     *      null if no information is available (for example,\n     *      if no build was done yet.)\n     */\n    public Node getLastBuiltOn() {\n        // where was it built on?\n        AbstractBuild b = getLastBuild();\n        if(b==null)\n            return null;\n        else\n            return b.getBuiltOn();\n    }\n\n    public Object getSameNodeConstraint() {\n        return this; // in this way, any member that wants to run with the main guy can nominate the project itself \n    }\n\n    public final Task getOwnerTask() {\n        return this;\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * <p>\n     * A project must be blocked if its own previous build is in progress,\n     * or if the blockBuildWhenUpstreamBuilding option is true and an upstream\n     * project is building, but derived classes can also check other conditions.\n     */\n    public boolean isBuildBlocked() {\n        return getCauseOfBlockage()!=null;\n    }\n\n    public String getWhyBlocked() {\n        CauseOfBlockage cb = getCauseOfBlockage();\n        return cb!=null ? cb.getShortDescription() : null;\n    }\n\n    /**\n     * Blocked because the previous build is already in progress.\n     */\n    public static class BecauseOfBuildInProgress extends CauseOfBlockage {\n        private final AbstractBuild<?,?> build;\n\n        public BecauseOfBuildInProgress(AbstractBuild<?, ?> build) {\n            this.build = build;\n        }\n\n        @Override\n        public String getShortDescription() {\n            Executor e = build.getExecutor();\n            String eta = \"\";\n            if (e != null)\n                eta = Messages.AbstractProject_ETA(e.getEstimatedRemainingTime());\n            int lbn = build.getNumber();\n            return Messages.AbstractProject_BuildInProgress(lbn, eta);\n        }\n    }\n    \n    /**\n     * Because the downstream build is in progress, and we are configured to wait for that.\n     */\n    public static class BecauseOfDownstreamBuildInProgress extends CauseOfBlockage {\n        public final AbstractProject<?,?> up;\n\n        public BecauseOfDownstreamBuildInProgress(AbstractProject<?,?> up) {\n            this.up = up;\n        }\n\n        @Override\n        public String getShortDescription() {\n            return Messages.AbstractProject_DownstreamBuildInProgress(up.getName());\n        }\n    }\n\n    /**\n     * Because the upstream build is in progress, and we are configured to wait for that.\n     */\n    public static class BecauseOfUpstreamBuildInProgress extends CauseOfBlockage {\n        public final AbstractProject<?,?> up;\n\n        public BecauseOfUpstreamBuildInProgress(AbstractProject<?,?> up) {\n            this.up = up;\n        }\n\n        @Override\n        public String getShortDescription() {\n            return Messages.AbstractProject_UpstreamBuildInProgress(up.getName());\n        }\n    }\n\n    public CauseOfBlockage getCauseOfBlockage() {\n        // Block builds until they are done with post-production\n        if (isLogUpdated() && !isConcurrentBuild())\n            return new BecauseOfBuildInProgress(getLastBuild());\n        if (blockBuildWhenDownstreamBuilding()) {\n            AbstractProject<?,?> bup = getBuildingDownstream();\n            if (bup!=null)\n                return new BecauseOfDownstreamBuildInProgress(bup);\n        }\n        if (blockBuildWhenUpstreamBuilding()) {\n            AbstractProject<?,?> bup = getBuildingUpstream();\n            if (bup!=null)\n                return new BecauseOfUpstreamBuildInProgress(bup);\n        }\n        return null;\n    }\n\n    /**\n     * Returns the project if any of the downstream project is either\n     * building, waiting, pending or buildable.\n     * <p>\n     * This means eventually there will be an automatic triggering of\n     * the given project (provided that all builds went smoothly.)\n     */\n    public AbstractProject getBuildingDownstream() {\n        Set<Task> unblockedTasks = Jenkins.getInstance().getQueue().getUnblockedTasks();\n\n        for (AbstractProject tup : getTransitiveDownstreamProjects()) {\n\t\t\tif (tup!=this && (tup.isBuilding() || unblockedTasks.contains(tup)))\n                return tup;\n        }\n        return null;\n    }\n\n    /**\n     * Returns the project if any of the upstream project is either\n     * building or is in the queue.\n     * <p>\n     * This means eventually there will be an automatic triggering of\n     * the given project (provided that all builds went smoothly.)\n     */\n    public AbstractProject getBuildingUpstream() {\n        Set<Task> unblockedTasks = Jenkins.getInstance().getQueue().getUnblockedTasks();\n\n        for (AbstractProject tup : getTransitiveUpstreamProjects()) {\n\t\t\tif (tup!=this && (tup.isBuilding() || unblockedTasks.contains(tup)))\n                return tup;\n        }\n        return null;\n    }\n\n    public List<SubTask> getSubTasks() {\n        List<SubTask> r = new ArrayList<SubTask>();\n        r.add(this);\n        for (SubTaskContributor euc : SubTaskContributor.all())\n            r.addAll(euc.forProject(this));\n        for (JobProperty<? super P> p : properties)\n            r.addAll(p.getSubTasks());\n        return r;\n    }\n\n    public R createExecutable() throws IOException {\n        if(isDisabled())    return null;\n        return newBuild();\n    }\n\n    public void checkAbortPermission() {\n        checkPermission(AbstractProject.ABORT);\n    }\n\n    public boolean hasAbortPermission() {\n        return hasPermission(AbstractProject.ABORT);\n    }\n\n    /**\n     * Gets the {@link Resource} that represents the workspace of this project.\n     * Useful for locking and mutual exclusion control.\n     *\n     * @deprecated as of 1.319\n     *      Projects no longer have a fixed workspace, ands builds will find an available workspace via\n     *      {@link WorkspaceList} for each build (furthermore, that happens after a build is started.)\n     *      So a {@link Resource} representation for a workspace at the project level no longer makes sense.\n     *\n     *      <p>\n     *      If you need to lock a workspace while you do some computation, see the source code of\n     *      {@link #pollSCMChanges(TaskListener)} for how to obtain a lock of a workspace through {@link WorkspaceList}.\n     */\n    public Resource getWorkspaceResource() {\n        return new Resource(getFullDisplayName()+\" workspace\");\n    }\n\n    /**\n     * List of necessary resources to perform the build of this project.\n     */\n    public ResourceList getResourceList() {\n        final Set<ResourceActivity> resourceActivities = getResourceActivities();\n        final List<ResourceList> resourceLists = new ArrayList<ResourceList>(1 + resourceActivities.size());\n        for (ResourceActivity activity : resourceActivities) {\n            if (activity != this && activity != null) {\n                // defensive infinite recursion and null check\n                resourceLists.add(activity.getResourceList());\n            }\n        }\n        return ResourceList.union(resourceLists);\n    }\n\n    /**\n     * Set of child resource activities of the build of this project (override in child projects).\n     * @return The set of child resource activities of the build of this project.\n     */\n    protected Set<ResourceActivity> getResourceActivities() {\n        return Collections.emptySet();\n    }\n\n    public boolean checkout(AbstractBuild build, Launcher launcher, BuildListener listener, File changelogFile) throws IOException, InterruptedException {\n        SCM scm = getScm();\n        if(scm==null)\n            return true;    // no SCM\n\n        FilePath workspace = build.getWorkspace();\n        workspace.mkdirs();\n        \n        boolean r = scm.checkout(build, launcher, workspace, listener, changelogFile);\n        if (r) {\n            // Only calcRevisionsFromBuild if checkout was successful. Note that modern SCM implementations\n            // won't reach this line anyway, as they throw AbortExceptions on checkout failure.\n            calcPollingBaseline(build, launcher, listener);\n        }\n        return r;\n    }\n\n    /**\n     * Pushes the baseline up to the newly checked out revision.\n     */\n    private void calcPollingBaseline(AbstractBuild build, Launcher launcher, TaskListener listener) throws IOException, InterruptedException {\n        SCMRevisionState baseline = build.getAction(SCMRevisionState.class);\n        if (baseline==null) {\n            try {\n                baseline = getScm()._calcRevisionsFromBuild(build, launcher, listener);\n            } catch (AbstractMethodError e) {\n                baseline = SCMRevisionState.NONE; // pre-1.345 SCM implementations, which doesn't use the baseline in polling\n            }\n            if (baseline!=null)\n                build.addAction(baseline);\n        }\n        pollingBaseline = baseline;\n    }\n\n    /**\n     * Checks if there's any update in SCM, and returns true if any is found.\n     *\n     * @deprecated as of 1.346\n     *      Use {@link #poll(TaskListener)} instead.\n     */\n    public boolean pollSCMChanges( TaskListener listener ) {\n        return poll(listener).hasChanges();\n    }\n\n    /**\n     * Checks if there's any update in SCM, and returns true if any is found.\n     *\n     * <p>\n     * The implementation is responsible for ensuring mutual exclusion between polling and builds\n     * if necessary.\n     *\n     * @since 1.345\n     */\n    public PollingResult poll( TaskListener listener ) {\n        SCM scm = getScm();\n        if (scm==null) {\n            listener.getLogger().println(Messages.AbstractProject_NoSCM());\n            return NO_CHANGES;\n        }\n        if (!isBuildable()) {\n            listener.getLogger().println(Messages.AbstractProject_Disabled());\n            return NO_CHANGES;\n        }\n\n        R lb = getLastBuild();\n        if (lb==null) {\n            listener.getLogger().println(Messages.AbstractProject_NoBuilds());\n            return isInQueue() ? NO_CHANGES : BUILD_NOW;\n        }\n\n        if (pollingBaseline==null) {\n            R success = getLastSuccessfulBuild(); // if we have a persisted baseline, we'll find it by this\n            for (R r=lb; r!=null; r=r.getPreviousBuild()) {\n                SCMRevisionState s = r.getAction(SCMRevisionState.class);\n                if (s!=null) {\n                    pollingBaseline = s;\n                    break;\n                }\n                if (r==success) break;  // searched far enough\n            }\n            // NOTE-NO-BASELINE:\n            // if we don't have baseline yet, it means the data is built by old Hudson that doesn't set the baseline\n            // as action, so we need to compute it. This happens later.\n        }\n\n        try {\n            SCMPollListener.fireBeforePolling(this, listener);\n            PollingResult r = _poll(listener, scm, lb);\n            SCMPollListener.firePollingSuccess(this,listener, r);\n            return r;\n        } catch (AbortException e) {\n            listener.getLogger().println(e.getMessage());\n            listener.fatalError(Messages.AbstractProject_Aborted());\n            LOGGER.log(Level.FINE, \"Polling \"+this+\" aborted\",e);\n            SCMPollListener.firePollingFailed(this, listener,e);\n            return NO_CHANGES;\n        } catch (IOException e) {\n            e.printStackTrace(listener.fatalError(e.getMessage()));\n            SCMPollListener.firePollingFailed(this, listener,e);\n            return NO_CHANGES;\n        } catch (InterruptedException e) {\n            e.printStackTrace(listener.fatalError(Messages.AbstractProject_PollingABorted()));\n            SCMPollListener.firePollingFailed(this, listener,e);\n            return NO_CHANGES;\n        } catch (RuntimeException e) {\n            SCMPollListener.firePollingFailed(this, listener,e);\n            throw e;\n        } catch (Error e) {\n            SCMPollListener.firePollingFailed(this, listener,e);\n            throw e;\n        }\n    }\n\n    /**\n     * {@link #poll(TaskListener)} method without the try/catch block that does listener notification and .\n     */\n    private PollingResult _poll(TaskListener listener, SCM scm, R lb) throws IOException, InterruptedException {\n        if (scm.requiresWorkspaceForPolling()) {\n            // lock the workspace of the last build\n            FilePath ws=lb.getWorkspace();\n\n            WorkspaceOfflineReason workspaceOfflineReason = workspaceOffline( lb );\n            if ( workspaceOfflineReason != null ) {\n                // workspace offline\n                for (WorkspaceBrowser browser : Jenkins.getInstance().getExtensionList(WorkspaceBrowser.class)) {\n                    ws = browser.getWorkspace(this);\n                    if (ws != null) {\n                        return pollWithWorkspace(listener, scm, lb, ws, browser.getWorkspaceList());\n                    }\n                }\n\n                // build now, or nothing will ever be built\n                Label label = getAssignedLabel();\n                if (label != null && label.isSelfLabel()) {\n                    // if the build is fixed on a node, then attempting a build will do us\n                    // no good. We should just wait for the slave to come back.\n                    listener.getLogger().print(Messages.AbstractProject_NoWorkspace());\n                    listener.getLogger().println( \" (\" + workspaceOfflineReason.name() + \")\");\n                    return NO_CHANGES;\n                }\n                listener.getLogger().println( ws==null\n                    ? Messages.AbstractProject_WorkspaceOffline()\n                    : Messages.AbstractProject_NoWorkspace());\n                if (isInQueue()) {\n                    listener.getLogger().println(Messages.AbstractProject_AwaitingBuildForWorkspace());\n                    return NO_CHANGES;\n                } else {\n                    listener.getLogger().print(Messages.AbstractProject_NewBuildForWorkspace());\n                    listener.getLogger().println( \" (\" + workspaceOfflineReason.name() + \")\");\n                    return BUILD_NOW;\n                }\n            } else {\n                WorkspaceList l = lb.getBuiltOn().toComputer().getWorkspaceList();\n                return pollWithWorkspace(listener, scm, lb, ws, l);\n\n            }\n        } else {\n            // polling without workspace\n            LOGGER.fine(\"Polling SCM changes of \" + getName());\n\n            if (pollingBaseline==null) // see NOTE-NO-BASELINE above\n                calcPollingBaseline(lb,null,listener);\n            PollingResult r = scm.poll(this, null, null, listener, pollingBaseline);\n            pollingBaseline = r.remote;\n            return r;\n        }\n    }\n\n    private PollingResult pollWithWorkspace(TaskListener listener, SCM scm, R lb, FilePath ws, WorkspaceList l) throws InterruptedException, IOException {\n        // if doing non-concurrent build, acquire a workspace in a way that causes builds to block for this workspace.\n        // this prevents multiple workspaces of the same job --- the behavior of Hudson < 1.319.\n        //\n        // OTOH, if a concurrent build is chosen, the user is willing to create a multiple workspace,\n        // so better throughput is achieved over time (modulo the initial cost of creating that many workspaces)\n        // by having multiple workspaces\n        WorkspaceList.Lease lease = l.acquire(ws, !concurrentBuild);\n        Launcher launcher = ws.createLauncher(listener).decorateByEnv(getEnvironment(lb.getBuiltOn(),listener));\n        try {\n            LOGGER.fine(\"Polling SCM changes of \" + getName());\n            if (pollingBaseline==null) // see NOTE-NO-BASELINE above\n                calcPollingBaseline(lb,launcher,listener);\n            PollingResult r = scm.poll(this, launcher, ws, listener, pollingBaseline);\n            pollingBaseline = r.remote;\n            return r;\n        } finally {\n            lease.release();\n        }\n    }\n\n    enum WorkspaceOfflineReason {\n        nonexisting_workspace,\n        builton_node_gone,\n        builton_node_no_executors\n    }\n\n    private WorkspaceOfflineReason workspaceOffline(R build) throws IOException, InterruptedException {\n        FilePath ws = build.getWorkspace();\n        if (ws==null || !ws.exists()) {\n            return WorkspaceOfflineReason.nonexisting_workspace;\n        }\n        \n        Node builtOn = build.getBuiltOn();\n        if (builtOn == null) { // node built-on doesn't exist anymore\n            return WorkspaceOfflineReason.builton_node_gone;\n        }\n        \n        if (builtOn.toComputer() == null) { // node still exists, but has 0 executors - o.s.l.t.\n            return WorkspaceOfflineReason.builton_node_no_executors;\n        }\n\n        return null;\n    }\n\n    /**\n     * Returns true if this user has made a commit to this project.\n     *\n     * @since 1.191\n     */\n    public boolean hasParticipant(User user) {\n        for( R build = getLastBuild(); build!=null; build=build.getPreviousBuild())\n            if(build.hasParticipant(user))\n                return true;\n        return false;\n    }\n\n    @Exported\n    public SCM getScm() {\n        return scm;\n    }\n\n    public void setScm(SCM scm) throws IOException {\n        this.scm = scm;\n        save();\n    }\n\n    /**\n     * Adds a new {@link Trigger} to this {@link Project} if not active yet.\n     */\n    public void addTrigger(Trigger<?> trigger) throws IOException {\n        addToList(trigger,triggers());\n    }\n\n    public void removeTrigger(TriggerDescriptor trigger) throws IOException {\n        removeFromList(trigger,triggers());\n    }\n\n    protected final synchronized <T extends Describable<T>>\n    void addToList( T item, List<T> collection ) throws IOException {\n        for( int i=0; i<collection.size(); i++ ) {\n            if(collection.get(i).getDescriptor()==item.getDescriptor()) {\n                // replace\n                collection.set(i,item);\n                save();\n                return;\n            }\n        }\n        // add\n        collection.add(item);\n        save();\n        updateTransientActions();\n    }\n\n    protected final synchronized <T extends Describable<T>>\n    void removeFromList(Descriptor<T> item, List<T> collection) throws IOException {\n        for( int i=0; i< collection.size(); i++ ) {\n            if(collection.get(i).getDescriptor()==item) {\n                // found it\n                collection.remove(i);\n                save();\n                updateTransientActions();\n                return;\n            }\n        }\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public synchronized Map<TriggerDescriptor,Trigger> getTriggers() {\n        return (Map)Descriptor.toMap(triggers());\n    }\n\n    /**\n     * Gets the specific trigger, or null if the propert is not configured for this job.\n     */\n    public <T extends Trigger> T getTrigger(Class<T> clazz) {\n        for (Trigger p : triggers()) {\n            if(clazz.isInstance(p))\n                return clazz.cast(p);\n        }\n        return null;\n    }\n\n//\n//\n// fingerprint related\n//\n//\n    /**\n     * True if the builds of this project produces {@link Fingerprint} records.\n     */\n    public abstract boolean isFingerprintConfigured();\n\n    /**\n     * Gets the other {@link AbstractProject}s that should be built\n     * when a build of this project is completed.\n     */\n    @Exported\n    public final List<AbstractProject> getDownstreamProjects() {\n        return Jenkins.getInstance().getDependencyGraph().getDownstream(this);\n    }\n\n    @Exported\n    public final List<AbstractProject> getUpstreamProjects() {\n        return Jenkins.getInstance().getDependencyGraph().getUpstream(this);\n    }\n\n    /**\n     * Returns only those upstream projects that defines {@link BuildTrigger} to this project.\n     * This is a subset of {@link #getUpstreamProjects()}\n     *\n     * @return A List of upstream projects that has a {@link BuildTrigger} to this project.\n     */\n    public final List<AbstractProject> getBuildTriggerUpstreamProjects() {\n        ArrayList<AbstractProject> result = new ArrayList<AbstractProject>();\n        for (AbstractProject<?,?> ap : getUpstreamProjects()) {\n            BuildTrigger buildTrigger = ap.getPublishersList().get(BuildTrigger.class);\n            if (buildTrigger != null)\n                if (buildTrigger.getChildProjects(ap).contains(this))\n                    result.add(ap);\n        }        \n        return result;\n    }    \n    \n    /**\n     * Gets all the upstream projects including transitive upstream projects.\n     *\n     * @since 1.138\n     */\n    public final Set<AbstractProject> getTransitiveUpstreamProjects() {\n        return Jenkins.getInstance().getDependencyGraph().getTransitiveUpstream(this);\n    }\n\n    /**\n     * Gets all the downstream projects including transitive downstream projects.\n     *\n     * @since 1.138\n     */\n    public final Set<AbstractProject> getTransitiveDownstreamProjects() {\n        return Jenkins.getInstance().getDependencyGraph().getTransitiveDownstream(this);\n    }\n\n    /**\n     * Gets the dependency relationship map between this project (as the source)\n     * and that project (as the sink.)\n     *\n     * @return\n     *      can be empty but not null. build number of this project to the build\n     *      numbers of that project.\n     */\n    public SortedMap<Integer, RangeSet> getRelationship(AbstractProject that) {\n        TreeMap<Integer,RangeSet> r = new TreeMap<Integer,RangeSet>(REVERSE_INTEGER_COMPARATOR);\n\n        checkAndRecord(that, r, this.getBuilds());\n        // checkAndRecord(that, r, that.getBuilds());\n\n        return r;\n    }\n\n    /**\n     * Helper method for getDownstreamRelationship.\n     *\n     * For each given build, find the build number range of the given project and put that into the map.\n     */\n    private void checkAndRecord(AbstractProject that, TreeMap<Integer, RangeSet> r, Collection<R> builds) {\n        for (R build : builds) {\n            RangeSet rs = build.getDownstreamRelationship(that);\n            if(rs==null || rs.isEmpty())\n                continue;\n\n            int n = build.getNumber();\n\n            RangeSet value = r.get(n);\n            if(value==null)\n                r.put(n,rs);\n            else\n                value.add(rs);\n        }\n    }\n\n    /**\n     * Builds the dependency graph.\n     * @see DependencyGraph\n     */\n    protected abstract void buildDependencyGraph(DependencyGraph graph);\n\n    @Override\n    protected SearchIndexBuilder makeSearchIndex() {\n        SearchIndexBuilder sib = super.makeSearchIndex();\n        if(isBuildable() && hasPermission(Jenkins.ADMINISTER))\n            sib.add(\"build\",\"build\");\n        return sib;\n    }\n\n    @Override\n    protected HistoryWidget createHistoryWidget() {\n        return new BuildHistoryWidget<R>(this,builds,HISTORY_ADAPTER);\n    }\n    \n    public boolean isParameterized() {\n        return getProperty(ParametersDefinitionProperty.class) != null;\n    }\n\n//\n//\n// actions\n//\n//\n    /**\n     * Schedules a new build command.\n     */\n    public void doBuild( StaplerRequest req, StaplerResponse rsp, @QueryParameter TimeDuration delay ) throws IOException, ServletException {\n        if (delay==null)    delay=new TimeDuration(getQuietPeriod());\n\n        // if a build is parameterized, let that take over\n        ParametersDefinitionProperty pp = getProperty(ParametersDefinitionProperty.class);\n        if (pp != null && !req.getMethod().equals(\"POST\")) {\n            // show the parameter entry form.\n            req.getView(pp, \"index.jelly\").forward(req, rsp);\n            return;\n        }\n\n        BuildAuthorizationToken.checkPermission(this, authToken, req, rsp);\n\n        if (pp != null) {\n            pp._doBuild(req,rsp,delay);\n            return;\n        }\n\n        if (!isBuildable())\n            throw HttpResponses.error(SC_INTERNAL_SERVER_ERROR,new IOException(getFullName()+\" is not buildable\"));\n\n        Jenkins.getInstance().getQueue().schedule(this, (int)delay.getTime(), getBuildCause(req));\n        rsp.sendRedirect(\".\");\n    }\n\n    /**\n     * Computes the build cause, using RemoteCause or UserCause as appropriate.\n     */\n    /*package*/ CauseAction getBuildCause(StaplerRequest req) {\n        Cause cause;\n        if (authToken != null && authToken.getToken() != null && req.getParameter(\"token\") != null) {\n            // Optional additional cause text when starting via token\n            String causeText = req.getParameter(\"cause\");\n            cause = new RemoteCause(req.getRemoteAddr(), causeText);\n        } else {\n            cause = new UserIdCause();\n        }\n        return new CauseAction(cause);\n    }\n\n    /**\n     * Computes the delay by taking the default value and the override in the request parameter into the account.\n     *\n     * @deprecated as of 1.488\n     *      Inject {@link TimeDuration}.\n     */\n    public int getDelay(StaplerRequest req) throws ServletException {\n        String delay = req.getParameter(\"delay\");\n        if (delay==null)    return getQuietPeriod();\n\n        try {\n            // TODO: more unit handling\n            if(delay.endsWith(\"sec\"))   delay=delay.substring(0,delay.length()-3);\n            if(delay.endsWith(\"secs\"))  delay=delay.substring(0,delay.length()-4);\n            return Integer.parseInt(delay);\n        } catch (NumberFormatException e) {\n            throw new ServletException(\"Invalid delay parameter value: \"+delay);\n        }\n    }\n\n    /**\n     * Supports build trigger with parameters via an HTTP GET or POST.\n     * Currently only String parameters are supported.\n     */\n    public void doBuildWithParameters(StaplerRequest req, StaplerResponse rsp, @QueryParameter TimeDuration delay) throws IOException, ServletException {\n        BuildAuthorizationToken.checkPermission(this, authToken, req, rsp);\n\n        ParametersDefinitionProperty pp = getProperty(ParametersDefinitionProperty.class);\n        if (pp != null) {\n            pp.buildWithParameters(req,rsp,delay);\n        } else {\n        \tthrow new IllegalStateException(\"This build is not parameterized!\");\n        }\n    \t\n    }\n\n    /**\n     * Schedules a new SCM polling command.\n     */\n    public void doPolling( StaplerRequest req, StaplerResponse rsp ) throws IOException, ServletException {\n        BuildAuthorizationToken.checkPermission(this, authToken, req, rsp);\n        schedulePolling();\n        rsp.sendRedirect(\".\");\n    }\n\n    /**\n     * Cancels a scheduled build.\n     */\n    @RequirePOST\n    public void doCancelQueue( StaplerRequest req, StaplerResponse rsp ) throws IOException, ServletException {\n        checkPermission(ABORT);\n\n        Jenkins.getInstance().getQueue().cancel(this);\n        rsp.forwardToPreviousPage(req);\n    }\n\n    /**\n     * Deletes this project.\n     */\n    @Override\n    @RequirePOST\n    public void doDoDelete(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException, InterruptedException {\n        delete();\n        if (req == null || rsp == null)\n            return;\n        View view = req.findAncestorObject(View.class);\n        if (view == null)\n            rsp.sendRedirect2(req.getContextPath() + '/' + getParent().getUrl());\n        else \n            rsp.sendRedirect2(req.getContextPath() + '/' + view.getUrl());\n    }\n    \n    @Override\n    protected void submit(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException, FormException {\n        super.submit(req,rsp);\n        JSONObject json = req.getSubmittedForm();\n\n        makeDisabled(req.getParameter(\"disable\")!=null);\n\n        jdk = req.getParameter(\"jdk\");\n        if(req.getParameter(\"hasCustomQuietPeriod\")!=null) {\n            quietPeriod = Integer.parseInt(req.getParameter(\"quiet_period\"));\n        } else {\n            quietPeriod = null;\n        }\n        if(req.getParameter(\"hasCustomScmCheckoutRetryCount\")!=null) {\n            scmCheckoutRetryCount = Integer.parseInt(req.getParameter(\"scmCheckoutRetryCount\"));\n        } else {\n            scmCheckoutRetryCount = null;\n        }\n        blockBuildWhenDownstreamBuilding = req.getParameter(\"blockBuildWhenDownstreamBuilding\")!=null;\n        blockBuildWhenUpstreamBuilding = req.getParameter(\"blockBuildWhenUpstreamBuilding\")!=null;\n\n        if(req.hasParameter(\"customWorkspace\")) {\n            customWorkspace = Util.fixEmptyAndTrim(req.getParameter(\"customWorkspace.directory\"));\n        } else {\n            customWorkspace = null;\n        }\n\n        if (json.has(\"scmCheckoutStrategy\"))\n            scmCheckoutStrategy = req.bindJSON(SCMCheckoutStrategy.class,\n                json.getJSONObject(\"scmCheckoutStrategy\"));\n        else\n            scmCheckoutStrategy = null;\n\n        \n        if(req.getParameter(\"hasSlaveAffinity\")!=null) {\n            assignedNode = Util.fixEmptyAndTrim(req.getParameter(\"_.assignedLabelString\"));\n        } else {\n            assignedNode = null;\n        }\n        canRoam = assignedNode==null;\n\n        concurrentBuild = req.getSubmittedForm().has(\"concurrentBuild\");\n\n        authToken = BuildAuthorizationToken.create(req);\n\n        setScm(SCMS.parseSCM(req,this));\n\n        for (Trigger t : triggers())\n            t.stop();\n        triggers = buildDescribable(req, Trigger.for_(this));\n        for (Trigger t : triggers)\n            t.start(this,true);\n\n        for (Publisher _t : Descriptor.newInstancesFromHeteroList(req, json, \"publisher\", Jenkins.getInstance().getExtensionList(BuildTrigger.DescriptorImpl.class))) {\n            BuildTrigger t = (BuildTrigger) _t;\n            List<AbstractProject> childProjects;\n            SecurityContext orig = ACL.impersonate(ACL.SYSTEM);\n            try {\n                childProjects = t.getChildProjects(this);\n            } finally {\n                SecurityContextHolder.setContext(orig);\n            }\n            for (AbstractProject downstream : childProjects) {\n                downstream.checkPermission(BUILD);\n            }\n        }\n    }\n\n    /**\n     * @deprecated\n     *      As of 1.261. Use {@link #buildDescribable(StaplerRequest, List)} instead.\n     */\n    protected final <T extends Describable<T>> List<T> buildDescribable(StaplerRequest req, List<? extends Descriptor<T>> descriptors, String prefix) throws FormException, ServletException {\n        return buildDescribable(req,descriptors);\n    }\n\n    protected final <T extends Describable<T>> List<T> buildDescribable(StaplerRequest req, List<? extends Descriptor<T>> descriptors)\n        throws FormException, ServletException {\n\n        JSONObject data = req.getSubmittedForm();\n        List<T> r = new Vector<T>();\n        for (Descriptor<T> d : descriptors) {\n            String safeName = d.getJsonSafeClassName();\n            if (req.getParameter(safeName) != null) {\n                T instance = d.newInstance(req, data.getJSONObject(safeName));\n                r.add(instance);\n            }\n        }\n        return r;\n    }\n\n    /**\n     * Serves the workspace files.\n     */\n    public DirectoryBrowserSupport doWs( StaplerRequest req, StaplerResponse rsp ) throws IOException, ServletException, InterruptedException {\n        checkPermission(AbstractProject.WORKSPACE);\n        FilePath ws = getSomeWorkspace();\n        if ((ws == null) || (!ws.exists())) {\n            // if there's no workspace, report a nice error message\n            // Would be good if when asked for *plain*, do something else!\n            // (E.g. return 404, or send empty doc.)\n            // Not critical; client can just check if content type is not text/plain,\n            // which also serves to detect old versions of Hudson.\n            req.getView(this,\"noWorkspace.jelly\").forward(req,rsp);\n            return null;\n        } else {\n            return new DirectoryBrowserSupport(this, ws, getDisplayName()+\" workspace\", \"folder.png\", true);\n        }\n    }\n\n    /**\n     * Wipes out the workspace.\n     */\n    public HttpResponse doDoWipeOutWorkspace() throws IOException, ServletException, InterruptedException {\n        checkPermission(Functions.isWipeOutPermissionEnabled() ? WIPEOUT : BUILD);\n        R b = getSomeBuildWithWorkspace();\n        FilePath ws = b!=null ? b.getWorkspace() : null;\n        if (ws!=null && getScm().processWorkspaceBeforeDeletion(this, ws, b.getBuiltOn())) {\n            ws.deleteRecursive();\n            for (WorkspaceListener wl : WorkspaceListener.all()) {\n                wl.afterDelete(this);\n            }\n            return new HttpRedirect(\".\");\n        } else {\n            // If we get here, that means the SCM blocked the workspace deletion.\n            return new ForwardToView(this,\"wipeOutWorkspaceBlocked.jelly\");\n        }\n    }\n\n    @CLIMethod(name=\"disable-job\")\n    @RequirePOST\n    public HttpResponse doDisable() throws IOException, ServletException {\n        checkPermission(CONFIGURE);\n        makeDisabled(true);\n        return new HttpRedirect(\".\");\n    }\n\n    @CLIMethod(name=\"enable-job\")\n    @RequirePOST\n    public HttpResponse doEnable() throws IOException, ServletException {\n        checkPermission(CONFIGURE);\n        makeDisabled(false);\n        return new HttpRedirect(\".\");\n    }\n\n    /**\n     * RSS feed for changes in this project.\n     */\n    public void doRssChangelog(  StaplerRequest req, StaplerResponse rsp  ) throws IOException, ServletException {\n        class FeedItem {\n            ChangeLogSet.Entry e;\n            int idx;\n\n            public FeedItem(Entry e, int idx) {\n                this.e = e;\n                this.idx = idx;\n            }\n\n            AbstractBuild<?,?> getBuild() {\n                return e.getParent().build;\n            }\n        }\n\n        List<FeedItem> entries = new ArrayList<FeedItem>();\n\n        for(R r=getLastBuild(); r!=null; r=r.getPreviousBuild()) {\n            int idx=0;\n            for( ChangeLogSet.Entry e : r.getChangeSet())\n                entries.add(new FeedItem(e,idx++));\n        }\n\n        RSS.forwardToRss(\n            getDisplayName()+' '+getScm().getDescriptor().getDisplayName()+\" changes\",\n            getUrl()+\"changes\",\n            entries, new FeedAdapter<FeedItem>() {\n                public String getEntryTitle(FeedItem item) {\n                    return \"#\"+item.getBuild().number+' '+item.e.getMsg()+\" (\"+item.e.getAuthor()+\")\";\n                }\n\n                public String getEntryUrl(FeedItem item) {\n                    return item.getBuild().getUrl()+\"changes#detail\"+item.idx;\n                }\n\n                public String getEntryID(FeedItem item) {\n                    return getEntryUrl(item);\n                }\n\n                public String getEntryDescription(FeedItem item) {\n                    StringBuilder buf = new StringBuilder();\n                    for(String path : item.e.getAffectedPaths())\n                        buf.append(path).append('\\n');\n                    return buf.toString();\n                }\n\n                public Calendar getEntryTimestamp(FeedItem item) {\n                    return item.getBuild().getTimestamp();\n                }\n\n                public String getEntryAuthor(FeedItem entry) {\n                    return JenkinsLocationConfiguration.get().getAdminAddress();\n                }\n            },\n            req, rsp );\n    }\n\n    /**\n     * {@link AbstractProject} subtypes should implement this base class as a descriptor.\n     *\n     * @since 1.294\n     */\n    public static abstract class AbstractProjectDescriptor extends TopLevelItemDescriptor {\n        /**\n         * {@link AbstractProject} subtypes can override this method to veto some {@link Descriptor}s\n         * from showing up on their configuration screen. This is often useful when you are building\n         * a workflow/company specific project type, where you want to limit the number of choices\n         * given to the users.\n         *\n         * <p>\n         * Some {@link Descriptor}s define their own schemes for controlling applicability\n         * (such as {@link BuildStepDescriptor#isApplicable(Class)}),\n         * This method works like AND in conjunction with them;\n         * Both this method and that method need to return true in order for a given {@link Descriptor}\n         * to show up for the given {@link Project}.\n         *\n         * <p>\n         * The default implementation returns true for everything.\n         *\n         * @see BuildStepDescriptor#isApplicable(Class) \n         * @see BuildWrapperDescriptor#isApplicable(AbstractProject) \n         * @see TriggerDescriptor#isApplicable(Item)\n         */\n        @Override\n        public boolean isApplicable(Descriptor descriptor) {\n            return true;\n        }\n\n        public FormValidation doCheckAssignedLabelString(@QueryParameter String value) {\n            if (Util.fixEmpty(value)==null)\n                return FormValidation.ok(); // nothing typed yet\n            try {\n                Label.parseExpression(value);\n            } catch (ANTLRException e) {\n                return FormValidation.error(e,\n                        Messages.AbstractProject_AssignedLabelString_InvalidBooleanExpression(e.getMessage()));\n            }\n            Label l = Jenkins.getInstance().getLabel(value);\n            if (l.isEmpty()) {\n                for (LabelAtom a : l.listAtoms()) {\n                    if (a.isEmpty()) {\n                        LabelAtom nearest = LabelAtom.findNearest(a.getName());\n                        return FormValidation.warning(Messages.AbstractProject_AssignedLabelString_NoMatch_DidYouMean(a.getName(),nearest.getDisplayName()));\n                    }\n                }\n                return FormValidation.warning(Messages.AbstractProject_AssignedLabelString_NoMatch());\n            }\n            return FormValidation.ok();\n        }\n\n        public FormValidation doCheckCustomWorkspace(@QueryParameter(value=\"customWorkspace.directory\") String customWorkspace){\n        \tif(Util.fixEmptyAndTrim(customWorkspace)==null)\n        \t\treturn FormValidation.error(Messages.AbstractProject_CustomWorkspaceEmpty());\n        \telse\n        \t\treturn FormValidation.ok();\n        }\n        \n        public AutoCompletionCandidates doAutoCompleteUpstreamProjects(@QueryParameter String value) {\n            AutoCompletionCandidates candidates = new AutoCompletionCandidates();\n            List<Job> jobs = Jenkins.getInstance().getItems(Job.class);\n            for (Job job: jobs) {\n                if (job.getFullName().startsWith(value)) {\n                    if (job.hasPermission(Item.READ)) {\n                        candidates.add(job.getFullName());\n                    }\n                }\n            }\n            return candidates;\n        }\n\n        public AutoCompletionCandidates doAutoCompleteAssignedLabelString(@QueryParameter String value) {\n            AutoCompletionCandidates c = new AutoCompletionCandidates();\n            Set<Label> labels = Jenkins.getInstance().getLabels();\n            List<String> queries = new AutoCompleteSeeder(value).getSeeds();\n\n            for (String term : queries) {\n                for (Label l : labels) {\n                    if (l.getName().startsWith(term)) {\n                        c.add(l.getName());\n                    }\n                }\n            }\n            return c;\n        }\n\n        public List<SCMCheckoutStrategyDescriptor> getApplicableSCMCheckoutStrategyDescriptors(AbstractProject p) {\n            return SCMCheckoutStrategyDescriptor._for(p);\n        }\n\n        /**\n        * Utility class for taking the current input value and computing a list\n        * of potential terms to match against the list of defined labels.\n         */\n        static class AutoCompleteSeeder {\n            private String source;\n\n            AutoCompleteSeeder(String source) {\n                this.source = source;\n            }\n\n            List<String> getSeeds() {\n                ArrayList<String> terms = new ArrayList<String>();\n                boolean trailingQuote = source.endsWith(\"\\\"\");\n                boolean leadingQuote = source.startsWith(\"\\\"\");\n                boolean trailingSpace = source.endsWith(\" \");\n\n                if (trailingQuote || (trailingSpace && !leadingQuote)) {\n                    terms.add(\"\");\n                } else {\n                    if (leadingQuote) {\n                        int quote = source.lastIndexOf('\"');\n                        if (quote == 0) {\n                            terms.add(source.substring(1));\n                        } else {\n                            terms.add(\"\");\n                        }\n                    } else {\n                        int space = source.lastIndexOf(' ');\n                        if (space > -1) {\n                            terms.add(source.substring(space+1));\n                        } else {\n                            terms.add(source);\n                        }\n                    }\n                }\n\n                return terms;\n            }\n        }\n    }\n\n    /**\n     * Finds a {@link AbstractProject} that has the name closest to the given name.\n     */\n    public static AbstractProject findNearest(String name) {\n        return findNearest(name,Hudson.getInstance());\n    }\n\n    /**\n     * Finds a {@link AbstractProject} whose name (when referenced from the specified context) is closest to the given name.\n     *\n     * @since 1.419\n     */\n    public static AbstractProject findNearest(String name, ItemGroup context) {\n        List<AbstractProject> projects = Hudson.getInstance().getAllItems(AbstractProject.class);\n        String[] names = new String[projects.size()];\n        for( int i=0; i<projects.size(); i++ )\n            names[i] = projects.get(i).getRelativeNameFrom(context);\n\n        String nearest = EditDistance.findNearest(name, names);\n        return (AbstractProject)Jenkins.getInstance().getItem(nearest,context);\n    }\n\n    private static final Comparator<Integer> REVERSE_INTEGER_COMPARATOR = new Comparator<Integer>() {\n        public int compare(Integer o1, Integer o2) {\n            return o2-o1;\n        }\n    };\n\n    private static final Logger LOGGER = Logger.getLogger(AbstractProject.class.getName());\n\n    /**\n     * Permission to abort a build\n     */\n    public static final Permission ABORT = CANCEL;\n\n    /**\n     * Replaceable \"Build Now\" text.\n     */\n    public static final Message<AbstractProject> BUILD_NOW_TEXT = new Message<AbstractProject>();\n\n    /**\n     * Used for CLI binding.\n     */\n    @CLIResolver\n    public static AbstractProject resolveForCLI(\n            @Argument(required=true,metaVar=\"NAME\",usage=\"Job name\") String name) throws CmdLineException {\n        AbstractProject item = Jenkins.getInstance().getItemByFullName(name, AbstractProject.class);\n        if (item==null)\n            throw new CmdLineException(null,Messages.AbstractItem_NoSuchJobExists(name,AbstractProject.findNearest(name).getFullName()));\n        return item;\n    }\n\n    public String getCustomWorkspace() {\n        return customWorkspace;\n    }\n\n    /**\n     * User-specified workspace directory, or null if it's up to Jenkins.\n     *\n     * <p>\n     * Normally a project uses the workspace location assigned by its parent container,\n     * but sometimes people have builds that have hard-coded paths.\n     *\n     * <p>\n     * This is not {@link File} because it may have to hold a path representation on another OS.\n     *\n     * <p>\n     * If this path is relative, it's resolved against {@link Node#getRootPath()} on the node where this workspace\n     * is prepared. \n     *\n     * @since 1.410\n     */\n    public void setCustomWorkspace(String customWorkspace) throws IOException {\n        this.customWorkspace= Util.fixEmptyAndTrim(customWorkspace);\n        save();\n    }\n    \n}\n", "/*\n * The MIT License\n *\n * Copyright (c) 2004-2009, Sun Microsystems, Inc., Alan Harder\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\npackage hudson.tasks;\n\nimport com.gargoylesoftware.htmlunit.FailingHttpStatusCodeException;\nimport com.gargoylesoftware.htmlunit.html.HtmlForm;\nimport com.gargoylesoftware.htmlunit.html.HtmlPage;\nimport com.gargoylesoftware.htmlunit.html.HtmlTextInput;\nimport hudson.maven.MavenModuleSet;\nimport hudson.maven.MavenModuleSetBuild;\nimport hudson.model.FreeStyleBuild;\nimport hudson.model.FreeStyleProject;\nimport hudson.model.Item;\nimport hudson.model.Result;\nimport hudson.model.Run;\nimport hudson.security.AuthorizationMatrixProperty;\nimport hudson.security.LegacySecurityRealm;\nimport hudson.security.Permission;\nimport hudson.security.ProjectMatrixAuthorizationStrategy;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Set;\nimport jenkins.model.Jenkins;\nimport org.jvnet.hudson.test.ExtractResourceSCM;\nimport org.jvnet.hudson.test.HudsonTestCase;\nimport org.jvnet.hudson.test.MockBuilder;\n\n/**\n * Tests for hudson.tasks.BuildTrigger\n * @author Alan.Harder@sun.com\n */\npublic class BuildTriggerTest extends HudsonTestCase {\n\n    private FreeStyleProject createDownstreamProject() throws Exception {\n        FreeStyleProject dp = createFreeStyleProject(\"downstream\");\n\n        // Hm, no setQuietPeriod, have to submit form..\n        WebClient webClient = new WebClient();\n        HtmlPage page = webClient.getPage(dp,\"configure\");\n        HtmlForm form = page.getFormByName(\"config\");\n        form.getInputByName(\"hasCustomQuietPeriod\").click();\n        form.getInputByName(\"quiet_period\").setValueAttribute(\"0\");\n        submit(form);\n        assertEquals(\"set quiet period\", 0, dp.getQuietPeriod());\n\n        return dp;\n    }\n\n    private void doTriggerTest(boolean evenWhenUnstable, Result triggerResult,\n            Result dontTriggerResult) throws Exception {\n        FreeStyleProject p = createFreeStyleProject(),\n                dp = createDownstreamProject();\n        p.getPublishersList().add(new BuildTrigger(\"downstream\", evenWhenUnstable));\n        p.getBuildersList().add(new MockBuilder(dontTriggerResult));\n        jenkins.rebuildDependencyGraph();\n\n        // First build should not trigger downstream job\n        FreeStyleBuild b = p.scheduleBuild2(0).get();\n        assertNoDownstreamBuild(dp, b);\n\n        // Next build should trigger downstream job\n        p.getBuildersList().replace(new MockBuilder(triggerResult));\n        b = p.scheduleBuild2(0).get();\n        assertDownstreamBuild(dp, b);\n    }\n\n    private void assertNoDownstreamBuild(FreeStyleProject dp, Run<?,?> b) throws Exception {\n        for (int i = 0; i < 3; i++) {\n            Thread.sleep(200);\n            assertTrue(\"downstream build should not run!  upstream log: \" + getLog(b),\n                       !dp.isInQueue() && !dp.isBuilding() && dp.getLastBuild()==null);\n        }\n    }\n\n    private void assertDownstreamBuild(FreeStyleProject dp, Run<?,?> b) throws Exception {\n        // Wait for downstream build\n        for (int i = 0; dp.getLastBuild()==null && i < 20; i++) Thread.sleep(100);\n        assertNotNull(\"downstream build didn't run.. upstream log: \" + getLog(b), dp.getLastBuild());\n    }\n\n    public void testBuildTrigger() throws Exception {\n        doTriggerTest(false, Result.SUCCESS, Result.UNSTABLE);\n    }\n\n    public void testTriggerEvenWhenUnstable() throws Exception {\n        doTriggerTest(true, Result.UNSTABLE, Result.FAILURE);\n    }\n\n    private void doMavenTriggerTest(boolean evenWhenUnstable) throws Exception {\n        FreeStyleProject dp = createDownstreamProject();\n        configureDefaultMaven();\n        MavenModuleSet m = createMavenProject();\n        m.getPublishersList().add(new BuildTrigger(\"downstream\", evenWhenUnstable));\n        if (!evenWhenUnstable) {\n            // Configure for UNSTABLE\n            m.setGoals(\"clean test\");\n            m.setScm(new ExtractResourceSCM(getClass().getResource(\"maven-test-failure.zip\")));\n        } // otherwise do nothing which gets FAILURE\n        // First build should not trigger downstream project\n        MavenModuleSetBuild b = m.scheduleBuild2(0).get();\n        assertNoDownstreamBuild(dp, b);\n\n        if (evenWhenUnstable) {\n            // Configure for UNSTABLE\n            m.setGoals(\"clean test\");\n            m.setScm(new ExtractResourceSCM(getClass().getResource(\"maven-test-failure.zip\")));\n        } else {\n            // Configure for SUCCESS\n            m.setGoals(\"clean\");\n            m.setScm(new ExtractResourceSCM(getClass().getResource(\"maven-empty.zip\")));\n        }\n        // Next build should trigger downstream project\n        b = m.scheduleBuild2(0).get();\n        assertDownstreamBuild(dp, b);\n    }\n\n    public void testMavenBuildTrigger() throws Exception {\n        doMavenTriggerTest(false);\n    }\n\n    public void testMavenTriggerEvenWhenUnstable() throws Exception {\n        doMavenTriggerTest(true);\n    }\n\n    public void testConfigureDownstreamProjectSecurity() throws Exception {\n        jenkins.setSecurityRealm(new LegacySecurityRealm());\n        ProjectMatrixAuthorizationStrategy auth = new ProjectMatrixAuthorizationStrategy();\n        auth.add(Jenkins.READ, \"alice\");\n        jenkins.setAuthorizationStrategy(auth);\n        FreeStyleProject upstream = createFreeStyleProject(\"upstream\");\n        Map<Permission,Set<String>> perms = new HashMap<Permission,Set<String>>();\n        perms.put(Item.READ, Collections.singleton(\"alice\"));\n        perms.put(Item.CONFIGURE, Collections.singleton(\"alice\"));\n        upstream.addProperty(new AuthorizationMatrixProperty(perms));\n        FreeStyleProject downstream = createFreeStyleProject(\"downstream\");\n        /* Original SECURITY-55 test case:\n        downstream.addProperty(new AuthorizationMatrixProperty(Collections.singletonMap(Item.READ, Collections.singleton(\"alice\"))));\n        */\n        WebClient wc = createWebClient();\n        wc.login(\"alice\");\n        HtmlPage page = wc.getPage(upstream, \"configure\");\n        HtmlForm config = page.getFormByName(\"config\");\n        config.getButtonByCaption(\"Add post-build action\").click(); // lib/hudson/project/config-publishers2.jelly\n        page.getAnchorByText(\"Build other projects\").click();\n        HtmlTextInput childProjects = config.getInputByName(\"buildTrigger.childProjects\");\n        childProjects.setValueAttribute(\"downstream\");\n        try {\n            submit(config);\n            fail();\n        } catch (FailingHttpStatusCodeException x) {\n            assertEquals(403, x.getStatusCode());\n        }\n        assertEquals(Collections.emptyList(), upstream.getDownstreamProjects());\n    }\n\n}\n"], "filenames": ["core/src/main/java/hudson/model/AbstractProject.java", "test/src/test/java/hudson/tasks/BuildTriggerTest.java"], "buggy_code_start_loc": [1942, 25], "buggy_code_end_loc": [1943, 133], "fixing_code_start_loc": [1942, 26], "fixing_code_end_loc": [1950, 178], "type": "CWE-264", "message": "BuildTrigger in Jenkins before 1.551 and LTS before 1.532.2 allows remote authenticated users to bypass access restrictions and execute arbitrary jobs by configuring a job to trigger another job. NOTE: this vulnerability exists because of an incomplete fix for CVE-2013-7330.", "other": {"cve": {"id": "CVE-2014-2058", "sourceIdentifier": "security@debian.org", "published": "2014-10-17T15:55:05.510", "lastModified": "2016-06-13T23:32:02.143", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "BuildTrigger in Jenkins before 1.551 and LTS before 1.532.2 allows remote authenticated users to bypass access restrictions and execute arbitrary jobs by configuring a job to trigger another job. NOTE: this vulnerability exists because of an incomplete fix for CVE-2013-7330."}, {"lang": "es", "value": "BuildTrigger en Jenkins en versiones anteriores a 1.551 y LTS en versiones anteriores a 1.532.2 permite a usuarios remotos autenticados eludir las restricciones de acceso y ejecutar trabajos arbitrarios configurando un trabajo para desencadenar otro trabajo. NOTA: esta vulnerabilidad existe debido a una soluci\u00f3n incompleta para CVE-2013-7330."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.5}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-264"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:jenkins:jenkins:*:*:*:*:lts:*:*:*", "versionEndIncluding": "1.532.1", "matchCriteriaId": "F5EDE52E-F7BE-457D-8E56-F24800F02241"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:jenkins:jenkins:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.550", "matchCriteriaId": "07E4FEB5-A7D9-49FE-839A-0D650CC19C42"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2014/02/21/2", "source": "security@debian.org"}, {"url": "https://github.com/jenkinsci/jenkins/commit/b6b2a367a7976be80a799c6a49fa6c58d778b50e", "source": "security@debian.org", "tags": ["Patch"]}, {"url": "https://wiki.jenkins-ci.org/display/SECURITY/Jenkins+Security+Advisory+2014-02-14", "source": "security@debian.org", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/jenkinsci/jenkins/commit/b6b2a367a7976be80a799c6a49fa6c58d778b50e"}}