{"buggy_code": ["/*\n * Copyright (C) 2011 Red Hat, Inc.\n *\n * All rights reserved.\n *\n * Author: Angus Salkeld <asalkeld@redhat.com>\n *\n * libqb is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation, either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * libqb is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with libqb.  If not, see <http://www.gnu.org/licenses/>.\n */\n#include \"os_base.h\"\n\n#include <qb/qbrb.h>\n#include \"util_int.h\"\n#include \"log_int.h\"\n#include \"ringbuffer_int.h\"\n\n#define BB_MIN_ENTRY_SIZE (4 * sizeof(uint32_t) +\\\n\t\t\t   sizeof(uint8_t) +\\\n\t\t\t   2 * sizeof(char) + sizeof(time_t))\n\n\nstatic void\n_blackbox_reload(int32_t target)\n{\n\tstruct qb_log_target *t = qb_log_target_get(target);\n\n\tif (t->instance == NULL) {\n\t\treturn;\n\t}\n\tqb_rb_close(t->instance);\n\tt->instance = qb_rb_open(t->filename, t->size,\n\t\t\t\t QB_RB_FLAG_CREATE | QB_RB_FLAG_OVERWRITE, 0);\n}\n\n/* <u32> file lineno\n * <u32> tags\n * <u8> priority\n * <u32> function name length\n * <string> function name\n * <u32> buffer length\n * <string> buffer\n */\nstatic void\n_blackbox_vlogger(int32_t target,\n\t\t  struct qb_log_callsite *cs, struct timespec *timestamp, va_list ap)\n{\n\tsize_t max_size;\n\tsize_t actual_size;\n\tuint32_t fn_size;\n\tchar *chunk;\n\tchar *msg_len_pt;\n\tuint32_t msg_len;\n\tstruct qb_log_target *t = qb_log_target_get(target);\n\n\tif (t->instance == NULL) {\n\t\treturn;\n\t}\n\n\tfn_size = strlen(cs->function) + 1;\n\n\tactual_size = 4 * sizeof(uint32_t) + sizeof(uint8_t) + fn_size + sizeof(struct timespec);\n\tmax_size = actual_size + t->max_line_length;\n\n\tchunk = qb_rb_chunk_alloc(t->instance, max_size);\n\n\tif (chunk == NULL) {\n\t\t/* something bad has happened. abort blackbox logging */\n\t\tqb_util_perror(LOG_ERR, \"Blackbox allocation error, aborting blackbox log %s\", t->filename);\n\t\tqb_rb_close(qb_rb_lastref_and_ret(\n\t\t\t(struct qb_ringbuffer_s **) &t->instance\n\t\t));\n\t\treturn;\n\t}\n\n\t/* line number */\n\tmemcpy(chunk, &cs->lineno, sizeof(uint32_t));\n\tchunk += sizeof(uint32_t);\n\n\t/* tags */\n\tmemcpy(chunk, &cs->tags, sizeof(uint32_t));\n\tchunk += sizeof(uint32_t);\n\n\t/* log level/priority */\n\tmemcpy(chunk, &cs->priority, sizeof(uint8_t));\n\tchunk += sizeof(uint8_t);\n\n\t/* function name */\n\tmemcpy(chunk, &fn_size, sizeof(uint32_t));\n\tchunk += sizeof(uint32_t);\n\tmemcpy(chunk, cs->function, fn_size);\n\tchunk += fn_size;\n\n\t/* timestamp */\n\tmemcpy(chunk, timestamp, sizeof(struct timespec));\n\tchunk += sizeof(struct timespec);\n\n\t/* log message length */\n\tmsg_len_pt = chunk;\n\tchunk += sizeof(uint32_t);\n\n\t/* log message */\n\tmsg_len = qb_vsnprintf_serialize(chunk, max_size, cs->format, ap);\n\tif (msg_len >= max_size) {\n\t    chunk = msg_len_pt + sizeof(uint32_t); /* Reset */\n\n\t    /* Leave this at QB_LOG_MAX_LEN so as not to overflow the blackbox */\n\t    msg_len = qb_vsnprintf_serialize(chunk, QB_LOG_MAX_LEN,\n\t\t\"Log message too long to be stored in the blackbox.  \"\\\n\t\t\"Maximum is QB_LOG_MAX_LEN\" , ap);\n\t}\n\n\tactual_size += msg_len;\n\n\t/* now that we know the length, write it\n\t */\n\tmemcpy(msg_len_pt, &msg_len, sizeof(uint32_t));\n\n\t(void)qb_rb_chunk_commit(t->instance, actual_size);\n}\n\nstatic void\n_blackbox_close(int32_t target)\n{\n\tstruct qb_log_target *t = qb_log_target_get(target);\n\n\tqb_rb_close(qb_rb_lastref_and_ret(\n\t\t(struct qb_ringbuffer_s **) &t->instance\n\t));\n}\n\nint32_t\nqb_log_blackbox_open(struct qb_log_target *t)\n{\n\tif (t->size < 1024) {\n\t\treturn -EINVAL;\n\t}\n\tsnprintf(t->filename, PATH_MAX, \"%s-%d-blackbox\", t->name, getpid());\n\n\tt->instance = qb_rb_open(t->filename, t->size,\n\t\t\t\t QB_RB_FLAG_CREATE | QB_RB_FLAG_OVERWRITE, 0);\n\tif (t->instance == NULL) {\n\t\treturn -errno;\n\t}\n\n\tt->logger = NULL;\n\tt->vlogger = _blackbox_vlogger;\n\tt->reload = _blackbox_reload;\n\tt->close = _blackbox_close;\n\treturn 0;\n}\n\n/*\n * This is designed to look as much like the ringbuffer header\n * as possible so that we can distinguish an old RB dump\n * from a new one with this header.\n */\n\nstruct _blackbox_file_header {\n\tuint32_t word_size;\n\tuint32_t read_pt;\n\tuint32_t write_pt;\n\tuint32_t version;\n\tuint32_t hash;\n} __attribute__((packed));\n\n/* Values we expect for a 'new' header */\n#define QB_BLACKBOX_HEADER_WORDSIZE 0\n#define QB_BLACKBOX_HEADER_READPT   0xCCBBCCBB\n#define QB_BLACKBOX_HEADER_WRITEPT  0xBBCCBBCC\n#define QB_BLACKBOX_HEADER_VERSION  2\n#define QB_BLACKBOX_HEADER_HASH     0\n\nssize_t\nqb_log_blackbox_write_to_file(const char *filename)\n{\n\tssize_t written_size = 0;\n\tstruct qb_log_target *t;\n\tstruct _blackbox_file_header header;\n\tint fd = open(filename, O_CREAT | O_RDWR, 0700);\n\n\tif (fd < 0) {\n\t\treturn -errno;\n\t}\n\n\t/* Write header, so we know this is a 'new' format blackbox */\n\theader.word_size = QB_BLACKBOX_HEADER_WORDSIZE;\n\theader.read_pt   = QB_BLACKBOX_HEADER_READPT;\n\theader.write_pt  = QB_BLACKBOX_HEADER_WRITEPT;\n\theader.version   = QB_BLACKBOX_HEADER_VERSION;\n\theader.hash      = QB_BLACKBOX_HEADER_HASH;\n\twritten_size = write(fd, &header, sizeof(header));\n\tif (written_size < sizeof(header)) {\n\t\tclose(fd);\n\t\treturn written_size;\n\t}\n\n\tt = qb_log_target_get(QB_LOG_BLACKBOX);\n\tif (t->instance) {\n\t\twritten_size += qb_rb_write_to_file(t->instance, fd);\n\t} else {\n\t\twritten_size = -ENOENT;\n\t}\n\tclose(fd);\n\n\treturn written_size;\n}\n\nint\nqb_log_blackbox_print_from_file(const char *bb_filename)\n{\n\tqb_ringbuffer_t *instance;\n\tssize_t bytes_read;\n\tint max_size = 2 * QB_LOG_MAX_LEN;\n\tchar *chunk;\n\tint fd;\n\tint err = 0;\n\tint saved_errno;\n\tstruct _blackbox_file_header header;\n\tint have_timespecs = 0;\n\tchar time_buf[64];\n\n\tfd = open(bb_filename, 0);\n\tif (fd < 0) {\n\t\tsaved_errno = errno;\n\t\tqb_util_perror(LOG_ERR, \"qb_log_blackbox_print_from_file\");\n\t\treturn -saved_errno;\n\t}\n\n\t/* Read the header. If it looks like one of ours then\n\t   we know we have hi-res timestamps */\n\terr = read(fd, &header, sizeof(header));\n\tif (err < sizeof(header)) {\n\t\tsaved_errno = errno;\n\t\tclose(fd);\n\t\treturn -saved_errno;\n\t}\n\n\tif (header.word_size == QB_BLACKBOX_HEADER_WORDSIZE &&\n\t    header.read_pt == QB_BLACKBOX_HEADER_READPT &&\n\t    header.write_pt == QB_BLACKBOX_HEADER_WRITEPT &&\n\t    header.version == QB_BLACKBOX_HEADER_VERSION &&\n\t    header.hash == QB_BLACKBOX_HEADER_HASH) {\n\t\thave_timespecs = 1;\n\t} else {\n\t\t(void)lseek(fd, 0, SEEK_SET);\n\t}\n\n\n\tinstance = qb_rb_create_from_file(fd, 0);\n\tclose(fd);\n\tif (instance == NULL) {\n\t\treturn -EIO;\n\t}\n\tchunk = malloc(max_size);\n\tif (!chunk) {\n\t\tgoto cleanup;\n\t}\n\n\tdo {\n\t\tchar *ptr;\n\t\tuint32_t lineno;\n\t\tuint32_t tags;\n\t\tuint8_t priority;\n\t\tuint32_t fn_size;\n\t\tchar *function;\n\t\tuint32_t len;\n\t\tstruct timespec timestamp;\n\t\ttime_t time_sec;\n\t\tuint32_t msg_len;\n\t\tstruct tm *tm;\n\t\tchar message[QB_LOG_MAX_LEN];\n\n\t\tbytes_read = qb_rb_chunk_read(instance, chunk, max_size, 0);\n\n\t\tif (bytes_read >= 0 && bytes_read < BB_MIN_ENTRY_SIZE) {\n\t\t\tprintf(\"ERROR Corrupt file: blackbox header too small.\\n\");\n\t\t\terr = -1;\n\t\t\tgoto cleanup;\n\t\t} else if (bytes_read < 0) {\n\t\t\terrno = -bytes_read;\n\t\t\tperror(\"ERROR: qb_rb_chunk_read failed\");\n\t\t\terr = -EIO;\n\t\t\tgoto cleanup;\n\t\t}\n\t\tptr = chunk;\n\n\t\t/* lineno */\n\t\tmemcpy(&lineno, ptr, sizeof(uint32_t));\n\t\tptr += sizeof(uint32_t);\n\n\t\t/* tags */\n\t\tmemcpy(&tags, ptr, sizeof(uint32_t));\n\t\tptr += sizeof(uint32_t);\n\n\t\t/* priority */\n\t\tmemcpy(&priority, ptr, sizeof(uint8_t));\n\t\tptr += sizeof(uint8_t);\n\n\t\t/* function size & name */\n\t\tmemcpy(&fn_size, ptr, sizeof(uint32_t));\n\t\tif ((fn_size + BB_MIN_ENTRY_SIZE) > bytes_read) {\n#ifndef S_SPLINT_S\n\t\t\tprintf(\"ERROR Corrupt file: fn_size way too big %\" PRIu32 \"\\n\", fn_size);\n\t\t\terr = -EIO;\n#endif /* S_SPLINT_S */\n\t\t\tgoto cleanup;\n\t\t}\n\t\tif (fn_size <= 0) {\n#ifndef S_SPLINT_S\n\t\t\tprintf(\"ERROR Corrupt file: fn_size negative %\" PRIu32 \"\\n\", fn_size);\n\t\t\terr = -EIO;\n#endif /* S_SPLINT_S */\n\t\t\tgoto cleanup;\n\t\t}\n\t\tptr += sizeof(uint32_t);\n\n\t\tfunction = ptr;\n\t\tptr += fn_size;\n\n\t\t/* timestamp size & content */\n\t\tif (have_timespecs) {\n\t\t\tmemcpy(&timestamp, ptr, sizeof(struct timespec));\n\t\t\tptr += sizeof(struct timespec);\n\t\t\ttime_sec = timestamp.tv_sec;\n\t\t} else {\n\t\t\tmemcpy(&time_sec, ptr, sizeof(time_t));\n\t\t\tptr += sizeof(time_t);\n\t\t\ttimestamp.tv_nsec = 0LL;\n\t\t}\n\n\t\ttm = localtime(&time_sec);\n\t\tif (tm) {\n\t\t\tint slen = strftime(time_buf,\n\t\t\t\t\t    sizeof(time_buf), \"%b %d %T\",\n\t\t\t\t\t    tm);\n\t\t\tsnprintf(time_buf+slen, sizeof(time_buf) - slen, \".%03llu\", timestamp.tv_nsec/QB_TIME_NS_IN_MSEC);\n\t\t} else {\n\t\t\tsnprintf(time_buf, sizeof(time_buf), \"%ld\",\n\t\t\t\t (long int)time_sec);\n\t\t}\n\t\t/* message length */\n\t\tmemcpy(&msg_len, ptr, sizeof(uint32_t));\n\t\tif (msg_len > QB_LOG_MAX_LEN || msg_len <= 0) {\n#ifndef S_SPLINT_S\n\t\t\tprintf(\"ERROR Corrupt file: msg_len out of bounds %\" PRIu32 \"\\n\", msg_len);\n\t\t\terr = -EIO;\n#endif /* S_SPLINT_S */\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tptr += sizeof(uint32_t);\n\n\t\t/* message content */\n\t\tlen = qb_vsnprintf_deserialize(message, QB_LOG_MAX_LEN, ptr);\n\t\tassert(len > 0);\n\t\tmessage[len] = '\\0';\n\t\tlen--;\n\t\twhile (len > 0 && (message[len] == '\\n' || message[len] == '\\0')) {\n\t\t\tmessage[len] = '\\0';\n\t\t\tlen--;\n\t\t}\n\n\t\tprintf(\"%-7s %s %s(%u):%u: %s\\n\",\n\t\t       qb_log_priority2str(priority),\n\t\t       time_buf, function, lineno, tags, message);\n\n\t} while (bytes_read > BB_MIN_ENTRY_SIZE);\n\ncleanup:\n\tqb_rb_close(instance);\n\tfree(chunk);\n\treturn err;\n}\n", "/*\n * Copyright (c) 2011-2015 Red Hat, Inc.\n *\n * All rights reserved.\n *\n * Author: Angus Salkeld <asalkeld@redhat.com>\n *\n * This file is part of libqb.\n *\n * libqb is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation, either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * libqb is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with libqb.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"os_base.h\"\n#include <pthread.h>\n\n#include \"check_common.h\"\n\n#include <qb/qbdefs.h>\n#include <qb/qbutil.h>\n#include <qb/qblog.h>\n\n#ifdef USE_JOURNAL\n#include <systemd/sd-journal.h>\n#endif\n\n#include \"_syslog_override.h\"\n\nextern size_t qb_vsnprintf_serialize(char *serialize, size_t max_len, const char *fmt, va_list ap);\nextern size_t qb_vsnprintf_deserialize(char *string, size_t strlen, const char *buf);\n\n\nstatic void\nformat_this(char *out, const char *fmt, ...)\n{\n\tchar buf[QB_LOG_MAX_LEN];\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tqb_vsnprintf_serialize(buf, QB_LOG_MAX_LEN, fmt, ap);\n\tqb_vsnprintf_deserialize(out, QB_LOG_MAX_LEN, buf);\n\tva_end(ap);\n}\n\nstatic void\nformat_this_up_to(char *out, size_t max_len, const char *fmt, ...)\n{\n\tchar buf[QB_LOG_MAX_LEN];\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tqb_vsnprintf_serialize(buf, max_len, fmt, ap);\n\tqb_vsnprintf_deserialize(out, QB_LOG_MAX_LEN, buf);\n\tva_end(ap);\n}\n\nSTART_TEST(test_va_serialize)\n{\n\tchar buf[QB_LOG_MAX_LEN];\n\tchar cmp_buf[QB_LOG_MAX_LEN];\n\n\tformat_this(buf, \"one line\");\n\tck_assert_str_eq(buf, \"one line\");\n\n\tformat_this(buf, \"p1:%p, p2:%p\", format_this, buf);\n\tsnprintf(cmp_buf, QB_LOG_MAX_LEN, \"p1:%p, p2:%p\", format_this, buf);\n\tck_assert_str_eq(buf, cmp_buf);\n\n\tformat_this(buf, \"s1:%s, s2:%s\", \"Yes\", \"Never\");\n\tck_assert_str_eq(buf, \"s1:Yes, s2:Never\");\n\n\tformat_this(buf, \"s1:%s, s2:%s\", \"Yes\", \"Never\");\n\tck_assert_str_eq(buf, \"s1:Yes, s2:Never\");\n\n\tformat_this(buf, \"d1:%d, d2:%5i, d3:%04i\", 23, 37, 84);\n\tck_assert_str_eq(buf, \"d1:23, d2:   37, d3:0084\");\n\n\tformat_this(buf, \"f1:%.5f, f2:%.2f\", 23.34109, 23.34109);\n\tck_assert_str_eq(buf, \"f1:23.34109, f2:23.34\");\n\n\tformat_this(buf, \"%zd\", (size_t)13140964);\n\tck_assert_str_eq(buf, \"13140964\");\n\tformat_this(buf, \"%jd\", (intmax_t)30627823);\n\tck_assert_str_eq(buf, \"30627823\");\n\tformat_this(buf, \"%td\", buf-cmp_buf);\n\tsnprintf(cmp_buf, QB_LOG_MAX_LEN, \"%td\", buf-cmp_buf);\n\tck_assert_str_eq(buf, cmp_buf);\n\n\tformat_this(buf, \":%s:\", \"Hello, world!\");\n\tck_assert_str_eq(buf, \":Hello, world!:\");\n\tformat_this(buf, \":%15s:\", \"Hello, world!\");\n\tck_assert_str_eq(buf, \":  Hello, world!:\");\n\tformat_this(buf, \":%.10s:\", \"Hello, world!\");\n\tck_assert_str_eq(buf, \":Hello, wor:\");\n\tformat_this(buf, \":%-10s:\", \"Hello, world!\");\n\tck_assert_str_eq(buf, \":Hello, world!:\");\n\tformat_this(buf, \":%-15s:\", \"Hello, world!\");\n\tck_assert_str_eq(buf, \":Hello, world!  :\");\n\tformat_this(buf, \":%.15s:\", \"Hello, world!\");\n\tck_assert_str_eq(buf, \":Hello, world!:\");\n\tformat_this(buf, \":%15.10s:\", \"Hello, world!\");\n\tck_assert_str_eq(buf, \":     Hello, wor:\");\n\tformat_this(buf, \":%-15.10s:\", \"Hello, world!\");\n\tck_assert_str_eq(buf, \":Hello, wor     :\");\n\n\tformat_this(buf, \":%*d:\", 8, 96);\n\tck_assert_str_eq(buf, \":      96:\");\n\n\tformat_this_up_to(buf, 11, \"123456789____\");\n\tck_assert_str_eq(buf, \"123456789_\");\n\n\tformat_this(buf, \"Client %s.%.9s wants to fence (%s) '%s' with device '%s'\",\n\t\t    \"bla\", \"foooooooooooooooooo\",\n\t\t    \"action\", \"target\", \"hoop\");\n\n\tck_assert_str_eq(buf,\n\t\t\t \"Client bla.foooooooo wants to fence (action) 'target' with device 'hoop'\");\n\n\tformat_this(buf, \"Node %s now has process list: %.32x (was %.32x)\",\n\t\t    \"18builder\", 2, 0);\n\tck_assert_str_eq(buf, \"Node 18builder now has process list: 00000000000000000000000000000002 (was 00000000000000000000000000000000)\");\n\n\n}\nEND_TEST\n\nSTART_TEST(test_log_stupid_inputs)\n{\n\tint32_t rc;\n\n\t/* shouldn't crash with out an init() */\n\tqb_log_fini();\n\n\t/* not init'ed */\n\trc = qb_log_filter_ctl(QB_LOG_SYSLOG, QB_LOG_FILTER_ADD,\n\t\t\t       QB_LOG_FILTER_FILE, \"bla\", LOG_TRACE);\n\tck_assert_int_eq(rc, -EINVAL);\n\n\trc = qb_log_ctl(QB_LOG_BLACKBOX, QB_LOG_CONF_SIZE, 2000);\n\tck_assert_int_eq(rc, -EINVAL);\n\n\tqb_log(LOG_INFO, \"not init'd\");\n\n\tqb_log_from_external_source(__func__, __FILE__, \"%s\", LOG_INFO,\n\t\t\t\t    __LINE__, 0, \"also not init'd\");\n\n\tqb_log_init(\"test\", LOG_USER, LOG_DEBUG);\n\n\t/* non-opened log file */\n\trc = qb_log_filter_ctl(21, QB_LOG_FILTER_ADD,\n\t\t\t       QB_LOG_FILTER_FILE, \"bla\", LOG_TRACE);\n\tck_assert_int_eq(rc, -EBADF);\n\n\trc = qb_log_ctl(21, QB_LOG_CONF_PRIORITY_BUMP, -1);\n\tck_assert_int_eq(rc, -EBADF);\n\n\t/* target < 0 or >= 32 */\n\trc = qb_log_filter_ctl(41, QB_LOG_FILTER_ADD,\n\t\t\t       QB_LOG_FILTER_FILE, \"bla\", LOG_TRACE);\n\tck_assert_int_eq(rc, -EBADF);\n\n\trc = qb_log_ctl(-1, QB_LOG_CONF_PRIORITY_BUMP, -1);\n\tck_assert_int_eq(rc, -EBADF);\n\n\t/* crap values to filter_ctl() */\n\trc = qb_log_filter_ctl(QB_LOG_SYSLOG, QB_LOG_FILTER_ADD,\n\t\t\t       QB_LOG_FILTER_FILE, NULL, LOG_INFO);\n\tck_assert_int_eq(rc, -EINVAL);\n\trc = qb_log_filter_ctl(QB_LOG_SYSLOG, 56,\n\t\t\t       QB_LOG_FILTER_FILE, \"boja\", LOG_INFO);\n\tck_assert_int_eq(rc, -EINVAL);\n\n\t/* crap values to ctl() */\n\trc = qb_log_ctl(QB_LOG_BLACKBOX, QB_LOG_CONF_SIZE, -2000);\n\tck_assert_int_eq(rc, -EINVAL);\n\trc = qb_log_ctl(QB_LOG_BLACKBOX, 67, 2000);\n\tck_assert_int_eq(rc, -EINVAL);\n\trc = qb_log_ctl(QB_LOG_SYSLOG, QB_LOG_CONF_SIZE, 2000);\n\tck_assert_int_eq(rc, -ENOSYS);\n\n}\nEND_TEST\n\nstatic char test_buf[4097];\nstatic uint8_t test_priority;\nstatic int32_t num_msgs;\nstatic size_t last_length;\n\n/*\n * to test that we get what we expect.\n */\nstatic void\n_test_logger(int32_t t,\n\t     struct qb_log_callsite *cs,\n\t     struct timespec *timestamp, const char *msg)\n{\n\ttest_buf[0] = '\\0';\n\tqb_log_target_format(t, cs, timestamp, msg, test_buf);\n\ttest_priority = cs->priority;\n\n\tnum_msgs++;\n}\n\nstatic void\n_test_length_logger(int32_t t,\n\t     struct qb_log_callsite *cs,\n\t     struct timespec *timestamp, const char *msg)\n{\n\tstrcpy(test_buf, msg);\n\tqb_log_target_format(t, cs, timestamp, msg, test_buf);\n\ttest_priority = cs->priority;\n\n\tnum_msgs++;\n\tlast_length = strlen(msg);\n}\n\nstatic void log_also(void)\n{\n\tqb_log(LOG_INFO, \"yes please\");\n}\n\nstatic void log_and_this_too(void)\n{\n\tqb_log(LOG_INFO, \"this too please\");\n}\n\nstatic void log_it_please(void)\n{\n\tqb_enter();\n\tqb_log(LOG_TRACE, \"A:%d B:%d C:%d\", 1, 2, 3);\n\tqb_log(LOG_DEBUG, \"A:%d B:%d C:%d\", 1, 2, 3);\n\terrno = EEXIST;\n\tqb_perror(LOG_WARNING, \"bogus error\");\n\terrno = 0;\n\tqb_log(LOG_INFO, \"A:%d B:%d C:%d\", 1, 2, 3);\n\tqb_log(LOG_NOTICE, \"A:%d B:%d C:%d\", 1, 2, 3);\n\tqb_log(LOG_WARNING, \"A:%d B:%d C:%d\", 1, 2, 3);\n\tqb_log(LOG_ERR, \"A:%d B:%d C:%d\", 1, 2, 3);\n\tqb_leave();\n}\n\n\nstatic int32_t _cust_t = -1;\nstatic void\nm_filter(struct qb_log_callsite *cs)\n{\n\tif ((cs->priority >= LOG_ALERT &&\n\t     cs->priority <= LOG_INFO) ||\n\t    cs->tags > 0) {\n\t\tqb_bit_set(cs->targets, _cust_t);\n\t} else {\n\t\tqb_bit_clear(cs->targets, _cust_t);\n\t}\n}\n\n\nSTART_TEST(test_log_filter_fn)\n{\n\tint32_t rc;\n\n\tqb_log_init(\"test\", LOG_USER, LOG_EMERG);\n\tqb_log_ctl(QB_LOG_SYSLOG, QB_LOG_CONF_ENABLED, QB_FALSE);\n\n\t_cust_t = qb_log_custom_open(_test_logger, NULL, NULL, NULL);\n\t_ck_assert_int(_cust_t, >, QB_LOG_BLACKBOX);\n\trc = qb_log_ctl(_cust_t, QB_LOG_CONF_ENABLED, QB_TRUE);\n\tck_assert_int_eq(rc, 0);\n\n\t/*\n\t * test the custom filter function.\n\t * make sure qb_log, and qb_log_from_external_source are filtered.\n\t */\n\tqb_log_filter_fn_set(m_filter);\n\tnum_msgs = 0;\n\n\tqb_log(LOG_NOTICE, \"qb_log_filter_fn_set good\");\n\tqb_log_from_external_source(__func__, __FILE__, \"%s\", LOG_INFO,\n\t\t\t\t    __LINE__, 0, \"qb_log_filter_fn_set good\");\n\tqb_log(LOG_TRACE, \"qb_log_filter_fn_set bad\");\n\tqb_log_from_external_source(__func__, __FILE__, \"%s\", LOG_DEBUG,\n\t\t\t\t    __LINE__, 44, \"qb_log_filter_fn_set woot\");\n\tqb_log_from_external_source(__func__, __FILE__, \"%s\", LOG_DEBUG,\n\t\t\t\t    __LINE__, 0, \"qb_log_filter_fn_set bad\");\n\n\tck_assert_int_eq(num_msgs, 3);\n}\nEND_TEST\n\nSTART_TEST(test_file_logging)\n{\n\tstruct stat st;\n\tint rc, lf;\n\n\tunlink(\"test1.log\");\n\tunlink(\"test2.log\");\n\n\tqb_log_init(\"test\", LOG_USER, LOG_DEBUG);\n\tlf = qb_log_file_open(\"test1.log\");\n\trc = qb_log_filter_ctl(lf, QB_LOG_FILTER_ADD, QB_LOG_FILTER_FILE,\n\t\t\t       __FILE__, LOG_DEBUG);\n\tck_assert_int_eq(rc, 0);\n\trc = qb_log_ctl(lf, QB_LOG_CONF_ENABLED, QB_TRUE);\n\tck_assert_int_eq(rc, 0);\n\n\tqb_log(LOG_INFO, \"write to file 1\");\n\tqb_log(LOG_INFO, \"write to file 1 again\");\n\n\trc = stat(\"test1.log\", &st);\n\tck_assert_int_eq(rc, 0);\n\tck_assert_int_ge(st.st_size, 32);\n\n\t/* Test reopen with NULL arg */\n\trc = qb_log_file_reopen(lf, NULL);\n\tck_assert_int_eq(rc, 0);\n\tqb_log(LOG_INFO, \"write to file 1 and again\");\n\tqb_log(LOG_INFO, \"write to file 1 yet again\");\n\trc = stat(\"test1.log\", &st);\n\tck_assert_int_eq(rc, 0);\n\tck_assert_int_ge(st.st_size, 64);\n\n\t/* Test reopen with new file */\n\trc = qb_log_file_reopen(lf, \"test2.log\");\n\tck_assert_int_eq(rc, 0);\n\n\tqb_log(LOG_INFO, \"write to file 2\");\n\tqb_log(LOG_INFO, \"write to file 2 again\");\n\n\trc = stat(\"test2.log\", &st);\n\tck_assert_int_eq(rc, 0);\n\tck_assert_int_ge(st.st_size, 32);\n\n\tunlink(\"test1.log\");\n\tunlink(\"test2.log\");\n}\nEND_TEST\n\nSTART_TEST(test_timestamps)\n{\n\tint32_t t;\n\tint32_t rc;\n\tint a,b,c,d;\n\n\tqb_log_init(\"test\", LOG_USER, LOG_EMERG);\n\tqb_log_ctl(QB_LOG_SYSLOG, QB_LOG_CONF_ENABLED, QB_FALSE);\n\n\tt = qb_log_custom_open(_test_logger, NULL, NULL, NULL);\n\trc = qb_log_filter_ctl(t, QB_LOG_FILTER_ADD,\n\t\t\t       QB_LOG_FILTER_FILE, \"*\", LOG_INFO);\n\tck_assert_int_eq(rc, 0);\n\n\t/* normal timestamp */\n\tqb_log_format_set(t, \"%t %b\");\n\trc = qb_log_ctl(t, QB_LOG_CONF_ENABLED, QB_TRUE);\n\tck_assert_int_eq(rc, 0);\n\n\tqb_log(LOG_INFO, \"The time now is (see left)\");\n\trc = sscanf(test_buf+7, \"%d:%d:%d.%d\", &a, &b, &c, &d);\n\tck_assert_int_eq(rc, 3);\n\n\t/* millisecond timestamp */\n\tqb_log_format_set(t, \"%T %b\");\n\tqb_log(LOG_INFO, \"The time now is precisely (see left)\");\n\trc = sscanf(test_buf+7, \"%d:%d:%d.%d\", &a, &b, &c, &d);\n\tck_assert_int_eq(rc, 4);\n}\nEND_TEST\n\n\nSTART_TEST(test_line_length)\n{\n\tint32_t t;\n\tint32_t rc;\n\tint i;\n\tchar bigbuf[4097];\n\n\tqb_log_init(\"test\", LOG_USER, LOG_EMERG);\n\tqb_log_ctl(QB_LOG_SYSLOG, QB_LOG_CONF_ENABLED, QB_FALSE);\n\n\tt = qb_log_custom_open(_test_length_logger, NULL, NULL, NULL);\n\trc = qb_log_filter_ctl(t, QB_LOG_FILTER_ADD,\n\t\t\t  QB_LOG_FILTER_FORMAT, \"*\", LOG_WARNING);\n\tck_assert_int_eq(rc, 0);\n\tqb_log_format_set(t, \"[%p] %b\");\n\trc = qb_log_ctl(t, QB_LOG_CONF_ENABLED, QB_TRUE);\n\tck_assert_int_eq(rc, 0);\n\trc = qb_log_ctl(t, QB_LOG_CONF_MAX_LINE_LEN, 32);\n\tck_assert_int_eq(rc, 0);\n\trc = qb_log_ctl(t, QB_LOG_CONF_ELLIPSIS, QB_TRUE);\n\tck_assert_int_eq(rc, 0);\n\n\t/* captures last log */\n\tmemset(test_buf, 0, sizeof(test_buf));\n\ttest_priority = 0;\n\tnum_msgs = 0;\n\n\tqb_log(LOG_ERR, \"Short message\");\n\tqb_log(LOG_ERR, \"This is a longer message 123456789012345678901234567890\");\n\tqb_log(LOG_ERR, \"Long message with parameters %d %s\", 1234, \"Oh yes it is\");\n\n\tck_assert_int_eq(num_msgs, 3);\n\tck_assert_int_eq(last_length, 31);\n\n\tck_assert_str_eq(test_buf+28, \"...\");\n\n\trc = qb_log_ctl(t, QB_LOG_CONF_ELLIPSIS, QB_FALSE);\n\tck_assert_int_eq(rc, 0);\n\n\tqb_log(LOG_ERR, \"Long message with parameters %d %s\", 1234, \"Oh yes it is\");\n\tck_assert_str_ne(test_buf+28, \"...\");\n\n\t/* Long lines */\n\tnum_msgs = 0;\n\trc = qb_log_ctl(t, QB_LOG_CONF_MAX_LINE_LEN, 4096);\n\tck_assert_int_eq(rc, 0);\n\n\tfor (i=0; i<4096; i++) {\n\t\tbigbuf[i] = '0'+(i%10);\n\t}\n\tbigbuf[4096] = '\\0';\n\tqb_log(LOG_ERR, \"%s\", bigbuf);\n\tck_assert_int_eq(num_msgs, 1);\n\tck_assert_int_eq(last_length, 4095);\n}\nEND_TEST\n\nSTART_TEST(test_log_basic)\n{\n\tint32_t t;\n\tint32_t rc;\n\n\tqb_log_init(\"test\", LOG_USER, LOG_EMERG);\n\tqb_log_ctl(QB_LOG_SYSLOG, QB_LOG_CONF_ENABLED, QB_FALSE);\n\n\tt = qb_log_custom_open(_test_logger, NULL, NULL, NULL);\n\trc = qb_log_filter_ctl(t, QB_LOG_FILTER_ADD,\n\t\t\t  QB_LOG_FILTER_FORMAT, \"Angus\", LOG_WARNING);\n\tck_assert_int_eq(rc, 0);\n\tqb_log_format_set(t, \"%b\");\n\trc = qb_log_ctl(t, QB_LOG_CONF_ENABLED, QB_TRUE);\n\tck_assert_int_eq(rc, 0);\n\n\t/* captures last log */\n\tmemset(test_buf, 0, sizeof(test_buf));\n\ttest_priority = 0;\n\tnum_msgs = 0;\n\n\t/*\n\t * test filtering by format\n\t */\n\tqb_log(LOG_INFO, \"Hello Angus, how are you?\");\n\tqb_log(LOG_WARNING, \"Hello Steven, how are you?\");\n\tqb_log(LOG_ERR, \"Hello Andrew, how are you?\");\n\tqb_log(LOG_ERR, \"Hello Angus, how are you?\");\n\tqb_log(LOG_EMERG, \"Hello Anna, how are you?\");\n\tck_assert_int_eq(test_priority, LOG_ERR);\n\tck_assert_int_eq(num_msgs, 1);\n\tck_assert_str_eq(test_buf, \"Hello Angus, how are you?\");\n\n\n\t/*\n\t * test filtering by file regex\n \t */\n\tqb_log_filter_ctl(t, QB_LOG_FILTER_CLEAR_ALL,\n\t\t\t  QB_LOG_FILTER_FORMAT, \"*\", LOG_TRACE);\n\tqb_log_filter_ctl(t, QB_LOG_FILTER_ADD,\n\t\t\t  QB_LOG_FILTER_FILE_REGEX, \"^fakefile*\", LOG_DEBUG);\n\n\tnum_msgs = 0;\n\tqb_log_from_external_source(__func__, \"fakefile_logging\", \"%s bla\", LOG_INFO,\n\t\t\t\t    56, 0, \"filename/lineno\");\n\tqb_log_from_external_source(__func__, \"do_not_log_fakefile_logging\", \"%s bla\", LOG_INFO,\n\t\t\t\t    56, 0, \"filename/lineno\");\n\tck_assert_int_eq(num_msgs, 1);\n\n\t/*\n\t * test filtering by format regex\n \t */\n\tqb_log_filter_ctl(t, QB_LOG_FILTER_CLEAR_ALL,\n\t\t\t  QB_LOG_FILTER_FORMAT, \"*\", LOG_TRACE);\n\tqb_log_filter_ctl(t, QB_LOG_FILTER_ADD,\n\t\t\t  QB_LOG_FILTER_FORMAT_REGEX, \"^one\", LOG_WARNING);\n\n\tnum_msgs = 0;\n\tqb_log(LOG_INFO, \"one two three\");\n\tqb_log(LOG_ERR, \"testing one two three\");\n\tqb_log(LOG_WARNING, \"one two three\");\n\tqb_log(LOG_ERR, \"one two three\");\n\tqb_log(LOG_EMERG, \"one two three\");\n\tck_assert_int_eq(num_msgs, 3);\n\n\t/*\n\t * test filtering by function and regex\n\t */\n\tqb_log_filter_ctl(t, QB_LOG_FILTER_CLEAR_ALL,\n\t\t\t  QB_LOG_FILTER_FILE, \"*\", LOG_TRACE);\n\tqb_log_filter_ctl(t, QB_LOG_FILTER_ADD,\n\t\t\t  QB_LOG_FILTER_FUNCTION_REGEX, \"^log_.*please\", LOG_WARNING);\n\n\tnum_msgs = 0;\n\tqb_log(LOG_ERR, \"try if you: log_it_please()\");\n\tlog_it_please();\n\tck_assert_int_eq(num_msgs, 3);\n\n\tqb_log_filter_ctl(t, QB_LOG_FILTER_REMOVE,\n\t\t\t  QB_LOG_FILTER_FUNCTION_REGEX, \"log_it_please\", LOG_WARNING);\n\n\t/*\n\t * test filtering by function\n\t */\n\tqb_log_filter_ctl(t, QB_LOG_FILTER_CLEAR_ALL,\n\t\t\t  QB_LOG_FILTER_FILE, \"*\", LOG_TRACE);\n\tqb_log_filter_ctl(t, QB_LOG_FILTER_ADD,\n\t\t\t  QB_LOG_FILTER_FUNCTION, \"log_it_please\", LOG_WARNING);\n\n\tnum_msgs = 0;\n\tqb_log(LOG_ERR, \"try if you: log_it_please()\");\n\tlog_it_please();\n\tck_assert_int_eq(num_msgs, 3);\n\n\tqb_log_filter_ctl(t, QB_LOG_FILTER_REMOVE,\n\t\t\t  QB_LOG_FILTER_FUNCTION, \"log_it_please\", LOG_WARNING);\n\tqb_log_filter_ctl(t, QB_LOG_FILTER_ADD,\n\t\t\t  QB_LOG_FILTER_FUNCTION, __func__, LOG_DEBUG);\n\n\tnum_msgs = 0;\n\tlog_it_please();\n\tck_assert_int_eq(num_msgs, 0);\n\tqb_log(LOG_DEBUG, \"try if you: log_it_please()\");\n\tck_assert_int_eq(num_msgs, 1);\n\n\tqb_log_filter_ctl(t, QB_LOG_FILTER_CLEAR_ALL,\n\t\t\t  QB_LOG_FILTER_FILE, \"*\", LOG_TRACE);\n\tqb_log_filter_ctl(t, QB_LOG_FILTER_ADD,\n\t\t\t  QB_LOG_FILTER_FUNCTION,\n\t\t\t  \"log_also,log_and_this_too\",\n\t\t\t  LOG_DEBUG);\n\tnum_msgs = 0;\n\tlog_also();\n\tlog_and_this_too();\n\tck_assert_int_eq(num_msgs, 2);\n\n\tqb_log_filter_ctl(t, QB_LOG_FILTER_CLEAR_ALL,\n\t\t\t  QB_LOG_FILTER_FILE, \"*\", LOG_TRACE);\n\tqb_log_filter_ctl(t, QB_LOG_FILTER_ADD,\n\t\t\t  QB_LOG_FILTER_FILE, \"fakefile.c,\"__FILE__\",otherfakefile\", LOG_DEBUG);\n\t/*\n\t * make sure we can pass in a null filename or function name.\n\t */\n\tqb_log_from_external_source(__func__, NULL, \"%s\", LOG_INFO,\n\t\t\t\t    __LINE__, 0, \"null filename\");\n\tqb_log_from_external_source(NULL, __FILE__, \"%s\", LOG_INFO,\n\t\t\t\t    __LINE__, 0, \"null function\");\n\n\t/* check same file/lineno logs with different formats work\n\t */\n\tnum_msgs = 0;\n\tqb_log_from_external_source(__func__, __FILE__, \"%s bla\", LOG_INFO,\n\t\t\t\t    56, 0, \"filename/lineno\");\n\tck_assert_int_eq(num_msgs, 1);\n\tck_assert_str_eq(test_buf, \"filename/lineno bla\");\n\n\tnum_msgs = 0;\n\tqb_log_from_external_source(__func__, __FILE__, \"%s\", LOG_INFO,\n\t\t\t\t    56, 0, \"same filename/lineno\");\n\tck_assert_int_eq(num_msgs, 1);\n\tck_assert_str_eq(test_buf, \"same filename/lineno\");\n\n\t/* check filtering works on same file/lineno but different\n\t * log level.\n\t */\n\tqb_log_filter_ctl(t, QB_LOG_FILTER_CLEAR_ALL,\n\t\t\t  QB_LOG_FILTER_FILE, \"*\", LOG_TRACE);\n\tqb_log_filter_ctl(t, QB_LOG_FILTER_ADD,\n\t\t\t  QB_LOG_FILTER_FILE, __FILE__, LOG_INFO);\n\n\tnum_msgs = 0;\n\tqb_log_from_external_source(__func__, __FILE__,\n\t\t\t\t    \"same filename/lineno, this level %d\",\n\t\t\t\t    LOG_INFO, 56, 0, LOG_INFO);\n\tck_assert_int_eq(num_msgs, 1);\n\tck_assert_str_eq(test_buf, \"same filename/lineno, this level 6\");\n\n\tnum_msgs = 0;\n\tqb_log_from_external_source(__func__, __FILE__,\n\t\t\t\t    \"same filename/lineno, this level %d\",\n\t\t\t\t    LOG_DEBUG, 56, 0, LOG_DEBUG);\n\tck_assert_int_eq(num_msgs, 0);\n}\nEND_TEST\n\nstatic const char *_test_tags_stringify(uint32_t tags)\n{\n\tif (tags == 1) {\n\t\treturn \"ONE\";\n\t} else if (tags == 8) {\n\t\treturn \"ATE\";\n\t} else {\n\t\treturn \"ANY\";\n\t}\n}\n\nSTART_TEST(test_log_format)\n{\n\tint32_t t;\n\t/* following size/length related equation holds in the context of use:\n\t   strlen(cmp_str) = strlen(host_str) + X; X ~ 20 < sizeof(host_str) */\n\tchar host_str[256];\n\tchar cmp_str[2 * sizeof(host_str)];\n\n\tqb_log_init(\"test\", LOG_USER, LOG_DEBUG);\n\tqb_log_ctl(QB_LOG_SYSLOG, QB_LOG_CONF_ENABLED, QB_FALSE);\n\n\tt = qb_log_custom_open(_test_logger, NULL, NULL, NULL);\n\tqb_log_ctl(t, QB_LOG_CONF_ENABLED, QB_TRUE);\n\n\tqb_log_filter_ctl(t, QB_LOG_FILTER_ADD,\n\t\t\t  QB_LOG_FILTER_FILE, \"*\", LOG_DEBUG);\n\tqb_log_format_set(t, \"%p %f %b\");\n\n\tqb_log(LOG_DEBUG, \"Angus\");\n\tck_assert_str_eq(test_buf, \"debug check_log.c Angus\");\n\tqb_log(LOG_INFO, \"Angus\");\n\tck_assert_str_eq(test_buf, \"info check_log.c Angus\");\n\tqb_log(LOG_NOTICE, \"Angus\");\n\tck_assert_str_eq(test_buf, \"notice check_log.c Angus\");\n\tqb_log(LOG_WARNING, \"Angus\");\n\tck_assert_str_eq(test_buf, \"warning check_log.c Angus\");\n\tqb_log(LOG_ERR, \"Angus\");\n\tck_assert_str_eq(test_buf, \"error check_log.c Angus\");\n\tqb_log(LOG_CRIT, \"Angus\");\n\tck_assert_str_eq(test_buf, \"crit check_log.c Angus\");\n\tqb_log(LOG_ALERT, \"Angus\");\n\tck_assert_str_eq(test_buf, \"alert check_log.c Angus\");\n\tqb_log(LOG_EMERG, \"Angus\");\n\tck_assert_str_eq(test_buf, \"emerg check_log.c Angus\");\n\n\tqb_log_tags_stringify_fn_set(_test_tags_stringify);\n\tqb_log_format_set(t, \"%g %b\");\n\n\tqb_logt(LOG_INFO, 0, \"Angus\");\n\tck_assert_str_eq(test_buf, \"ANY Angus\");\n\tqb_logt(LOG_INFO, 1, \"Angus\");\n\tck_assert_str_eq(test_buf, \"ONE Angus\");\n\tqb_logt(LOG_INFO, 5, \"Angus\");\n\tck_assert_str_eq(test_buf, \"ANY Angus\");\n\tqb_logt(LOG_INFO, 8, \"Angus\");\n\tck_assert_str_eq(test_buf, \"ATE Angus\");\n\n\tqb_log_format_set(t, \"%-15f %b\");\n\tqb_log(LOG_WARNING, \"Andrew\");\n\tck_assert_str_eq(test_buf, \"    check_log.c Andrew\");\n\n\tqb_log_tags_stringify_fn_set(NULL);\n\n\tgethostname(host_str, sizeof(host_str));\n\thost_str[sizeof(host_str) - 1] = '\\0';\n\n\tqb_log_format_set(t, \"%P %H %N %b\");\n\tqb_log(LOG_INFO, \"Angus\");\n\tsnprintf(cmp_str, sizeof(cmp_str), \"%d %s test Angus\", getpid(),\n\t\t host_str);\n\tck_assert_str_eq(test_buf, cmp_str);\n\n\tqb_log_format_set(t, \"%3N %H %P %b\");\n\tqb_log(LOG_INFO, \"Angus\");\n\tsnprintf(cmp_str, sizeof(cmp_str), \"tes %s %d Angus\", host_str,\n\t\t getpid());\n\tck_assert_str_eq(test_buf, cmp_str);\n}\nEND_TEST\n\nSTART_TEST(test_log_enable)\n{\n\tint32_t t;\n\tint32_t state;\n\n\tqb_log_init(\"test\", LOG_USER, LOG_DEBUG);\n\tstate = qb_log_ctl(QB_LOG_SYSLOG, QB_LOG_CONF_STATE_GET, 0);\n\tck_assert_int_eq(state, QB_LOG_STATE_ENABLED);\n\tstate = qb_log_ctl(QB_LOG_STDERR, QB_LOG_CONF_STATE_GET, 0);\n\tck_assert_int_eq(state, QB_LOG_STATE_DISABLED);\n\tstate = qb_log_ctl(QB_LOG_BLACKBOX, QB_LOG_CONF_STATE_GET, 0);\n\tck_assert_int_eq(state, QB_LOG_STATE_DISABLED);\n\n\tqb_log_ctl(QB_LOG_SYSLOG, QB_LOG_CONF_ENABLED, QB_FALSE);\n\tstate = qb_log_ctl(QB_LOG_SYSLOG, QB_LOG_CONF_STATE_GET, 0);\n\tck_assert_int_eq(state, QB_LOG_STATE_DISABLED);\n\n\tt = qb_log_custom_open(_test_logger, NULL, NULL, NULL);\n\tqb_log_ctl(t, QB_LOG_CONF_ENABLED, QB_TRUE);\n\n\tqb_log_filter_ctl(t, QB_LOG_FILTER_ADD,\n\t\t\t  QB_LOG_FILTER_FILE, \"*\", LOG_DEBUG);\n\tqb_log_format_set(t, \"%b\");\n\n\tqb_log(LOG_DEBUG, \"Hello\");\n\tck_assert_str_eq(test_buf, \"Hello\");\n\n\tnum_msgs = 0;\n\tqb_log_ctl(t, QB_LOG_CONF_ENABLED, QB_FALSE);\n\tqb_log(LOG_DEBUG, \"Goodbye\");\n\tck_assert_int_eq(num_msgs, 0);\n\tqb_log_ctl(t, QB_LOG_CONF_ENABLED, QB_TRUE);\n\tqb_log(LOG_DEBUG, \"Hello again\");\n\tck_assert_int_eq(num_msgs, 1);\n\tck_assert_str_eq(test_buf, \"Hello again\");\n}\nEND_TEST\n\n#define ITERATIONS 100000\nstatic void *thr_send_logs_2(void *ctx)\n{\n\tint32_t i;\n\tprintf(\"%s\\n\", __func__);\n\n\tfor (i = 0; i < ITERATIONS; i++) {\n\t\tqb_log(LOG_INFO, \"bla bla\");\n\t\tqb_log(LOG_INFO, \"blue blue\");\n\t\tqb_log(LOG_INFO, \"bra bra\");\n\t\tqb_log(LOG_INFO, \"bro bro\");\n\t\tqb_log(LOG_INFO, \"brown brown\");\n\t\tqb_log(LOG_INFO, \"booo booo\");\n\t\tqb_log(LOG_INFO, \"bogus bogus\");\n\t\tqb_log(LOG_INFO, \"bungu bungu\");\n\t}\n\treturn (NULL);\n}\n\nstatic void *thr_send_logs_1(void *ctx)\n{\n\tint32_t i;\n\n\tprintf(\"%s\\n\", __func__);\n\tfor (i = 0; i < ITERATIONS; i++) {\n\t\tqb_log_from_external_source(__func__, __FILE__, \"%s\", LOG_INFO,\n\t\t\t\t\t    __LINE__, 0, \"foo soup\");\n\t\tqb_log_from_external_source(__func__, __FILE__, \"%s\", LOG_INFO,\n\t\t\t\t\t    __LINE__, 0, \"fungus soup\");\n\t\tqb_log_from_external_source(__func__, __FILE__, \"%s\", LOG_INFO,\n\t\t\t\t\t    __LINE__, 0, \"fruity soup\");\n\t\tqb_log_from_external_source(__func__, __FILE__, \"%s\", LOG_INFO,\n\t\t\t\t\t    __LINE__, 0, \"free soup\");\n\t\tqb_log_from_external_source(__func__, __FILE__, \"%s\", LOG_INFO,\n\t\t\t\t\t    __LINE__, 0, \"frot soup\");\n\t\tqb_log_from_external_source(__func__, __FILE__, \"%s\", LOG_INFO,\n\t\t\t\t\t    __LINE__, 0, \"fresh soup\");\n\t\tqb_log_from_external_source(__func__, __FILE__, \"%s\", LOG_INFO,\n\t\t\t\t\t    __LINE__, 0, \"fattening soup\");\n\n\t}\n\treturn (NULL);\n}\n\n#define THREADS 4\nSTART_TEST(test_log_threads)\n{\n\tpthread_t threads[THREADS];\n\tpthread_attr_t thread_attr[THREADS];\n\tint32_t i;\n\tint32_t rc;\n\tint32_t lf;\n\tvoid *retval;\n\n\tqb_log_init(\"test\", LOG_USER, LOG_DEBUG);\n\tlf = qb_log_file_open(\"threads.log\");\n\trc = qb_log_filter_ctl(lf, QB_LOG_FILTER_ADD, QB_LOG_FILTER_FILE,\n\t\t\t\t\t   __FILE__, LOG_DEBUG);\n\tck_assert_int_eq(rc, 0);\n\tqb_log_format_set(lf, \"[%p] [%l] %b\");\n\trc = qb_log_ctl(lf, QB_LOG_CONF_ENABLED, QB_TRUE);\n\tck_assert_int_eq(rc, 0);\n\trc = qb_log_ctl(QB_LOG_SYSLOG, QB_LOG_CONF_ENABLED, QB_FALSE);\n\tck_assert_int_eq(rc, 0);\n\n\tfor (i = 0; i < THREADS/2; i++) {\n\t\tpthread_attr_init(&thread_attr[i]);\n\n\t\tpthread_attr_setdetachstate(&thread_attr[i],\n\t\t\t\t\t    PTHREAD_CREATE_JOINABLE);\n\t\tpthread_create(&threads[i], &thread_attr[i],\n\t\t\t       thr_send_logs_1, NULL);\n\t}\n\tfor (i = THREADS/2; i < THREADS; i++) {\n\t\tpthread_attr_init(&thread_attr[i]);\n\n\t\tpthread_attr_setdetachstate(&thread_attr[i],\n\t\t\t\t\t    PTHREAD_CREATE_JOINABLE);\n\t\tpthread_create(&threads[i], &thread_attr[i],\n\t\t\t       thr_send_logs_2, NULL);\n\t}\n\tfor (i = 0; i < THREADS; i++) {\n\t\tpthread_join(threads[i], &retval);\n\t}\n\n}\nEND_TEST\n\nSTART_TEST(test_log_long_msg)\n{\n\tint lpc;\n\tint rc;\n\tint i, max = 1000;\n\tchar *buffer = calloc(1, max);\n\n\tqb_log_init(\"test\", LOG_USER, LOG_DEBUG);\n\trc = qb_log_ctl(QB_LOG_SYSLOG, QB_LOG_CONF_ENABLED, QB_FALSE);\n\tck_assert_int_eq(rc, 0);\n\trc = qb_log_ctl(QB_LOG_BLACKBOX, QB_LOG_CONF_SIZE, 1024);\n\tck_assert_int_eq(rc, 0);\n\trc = qb_log_ctl(QB_LOG_BLACKBOX, QB_LOG_CONF_ENABLED, QB_TRUE);\n\tck_assert_int_eq(rc, 0);\n\trc = qb_log_filter_ctl(QB_LOG_BLACKBOX, QB_LOG_FILTER_ADD,\n\t\t\t  QB_LOG_FILTER_FILE, \"*\", LOG_TRACE);\n\tck_assert_int_eq(rc, 0);\n\n\tfor (lpc = 500; lpc < max; lpc++) {\n\t\tlpc++;\n\t\tfor(i = 0; i < max; i++) {\n\t\t\tbuffer[i] = 'a' + (i % 10);\n\t\t}\n\t\tbuffer[lpc%600] = 0;\n\t\tqb_log(LOG_INFO, \"Message %d %d - %s\", lpc, lpc%600, buffer);\n\t}\n\n        qb_log_blackbox_write_to_file(\"blackbox.dump\");\n        qb_log_blackbox_print_from_file(\"blackbox.dump\");\n\tunlink(\"blackbox.dump\");\n\tqb_log_fini();\n}\nEND_TEST\n\nSTART_TEST(test_threaded_logging)\n{\n\tint32_t t;\n\tint32_t rc;\n\n\tqb_log_init(\"test\", LOG_USER, LOG_EMERG);\n\tqb_log_ctl(QB_LOG_SYSLOG, QB_LOG_CONF_ENABLED, QB_FALSE);\n\n\tt = qb_log_custom_open(_test_logger, NULL, NULL, NULL);\n\trc = qb_log_filter_ctl(t, QB_LOG_FILTER_ADD,\n\t\t\t       QB_LOG_FILTER_FILE, \"*\", LOG_INFO);\n\tck_assert_int_eq(rc, 0);\n\tqb_log_format_set(t, \"%b\");\n\trc = qb_log_ctl(t, QB_LOG_CONF_ENABLED, QB_TRUE);\n\tck_assert_int_eq(rc, 0);\n\trc = qb_log_ctl(t, QB_LOG_CONF_THREADED, QB_TRUE);\n\tck_assert_int_eq(rc, 0);\n\tqb_log_thread_start();\n\n\tmemset(test_buf, 0, sizeof(test_buf));\n\ttest_priority = 0;\n\tnum_msgs = 0;\n\n\tqb_log(LOG_INFO, \"Yoda how old are you? - %d\", __LINE__);\n\tqb_log(LOG_INFO, \"Yoda how old are you? - %d\", __LINE__);\n\tqb_log(LOG_INFO, \"Yoda how old are you? - %d\", __LINE__);\n\tqb_log(LOG_INFO, \"Yoda how old are you? - %d\", __LINE__);\n\tqb_log(LOG_INFO, \"Yoda how old are you? - %d\", __LINE__);\n\tqb_log(LOG_INFO, \"Yoda how old are you? - %d\", __LINE__);\n\tqb_log(LOG_INFO, \"Yoda how old are you? - %d\", __LINE__);\n\tqb_log(LOG_INFO, \"Yoda how old are you? - %d\", __LINE__);\n\tqb_log(LOG_INFO, \"Yoda how old are you? - %d\", __LINE__);\n\tqb_log(LOG_INFO, \"Yoda how old are you? - %d\", __LINE__);\n\n\tqb_log_fini();\n\n\tck_assert_int_eq(num_msgs, 10);\n}\nEND_TEST\n\n#ifdef HAVE_PTHREAD_SETSCHEDPARAM\nSTART_TEST(test_threaded_logging_bad_sched_params)\n{\n\tint32_t t;\n\tint32_t rc;\n\n\tqb_log_init(\"test\", LOG_USER, LOG_EMERG);\n\tqb_log_ctl(QB_LOG_SYSLOG, QB_LOG_CONF_ENABLED, QB_FALSE);\n\n\tt = qb_log_custom_open(_test_logger, NULL, NULL, NULL);\n\trc = qb_log_filter_ctl(t, QB_LOG_FILTER_ADD,\n\t\t\t       QB_LOG_FILTER_FILE, \"*\", LOG_INFO);\n\tck_assert_int_eq(rc, 0);\n\tqb_log_format_set(t, \"%b\");\n\trc = qb_log_ctl(t, QB_LOG_CONF_ENABLED, QB_TRUE);\n\tck_assert_int_eq(rc, 0);\n\trc = qb_log_ctl(t, QB_LOG_CONF_THREADED, QB_TRUE);\n\tck_assert_int_eq(rc, 0);\n\n#if defined(SCHED_RR)\n#define QB_SCHED SCHED_RR\n#elif defined(SCHED_FIFO)\n#define QB_SCHED SCHED_FIFO\n#else\n#define QB_SCHED (-1)\n#endif\n\trc = qb_log_thread_priority_set(QB_SCHED, -1);\n\tck_assert_int_eq(rc, 0);\n\n\trc = qb_log_thread_start();\n\tck_assert_int_ne(rc, 0);\n\tqb_log_fini();\n}\nEND_TEST\n#endif\n\nSTART_TEST(test_extended_information)\n{\n\tint32_t t;\n\tint32_t rc;\n\tint extended;\n\n\tqb_log_init(\"test\", LOG_USER, LOG_DEBUG);\n\tqb_log_ctl(QB_LOG_SYSLOG, QB_LOG_CONF_ENABLED, QB_FALSE);\n\n\tt = qb_log_custom_open(_test_logger, NULL, NULL, NULL);\n\t_ck_assert_int(t, >, QB_LOG_STDOUT);\n\tqb_log_format_set(t, \"%b\");\n\trc = qb_log_filter_fn_set(NULL);\n\tck_assert_int_eq(rc, 0);\n\trc = qb_log_filter_ctl(t, QB_LOG_FILTER_CLEAR_ALL, QB_LOG_FILTER_FILE,\n\t\t\t       \"*\", LOG_TRACE);\n\tck_assert_int_eq(rc, 0);\n\trc = qb_log_filter_ctl(t, QB_LOG_FILTER_CLEAR_ALL, QB_LOG_FILTER_FORMAT,\n\t\t\t       \"*\", LOG_TRACE);\n\tck_assert_int_eq(rc, 0);\n\trc = qb_log_filter_ctl(t, QB_LOG_FILTER_ADD, QB_LOG_FILTER_FORMAT,\n\t\t\t       \"*\", LOG_TRACE);\n\tck_assert_int_eq(rc, 0);\n\trc = qb_log_ctl(t, QB_LOG_CONF_ENABLED, QB_TRUE);\n\tck_assert_int_eq(rc, 0);\n\n\tfor (extended = QB_FALSE; extended <= QB_TRUE; ++extended) {\n\t\trc = qb_log_ctl(t, QB_LOG_CONF_EXTENDED, extended);\n\t\tck_assert_int_eq(rc, 0);\n\n\t\tnum_msgs = 0;\n\n\t\tmemset(test_buf, 0, sizeof(test_buf));\n\t\tqb_log(LOG_ERR, \"message with no extended information\");\n\t\tck_assert_str_eq(test_buf, \"message with no extended information\");\n\n\t\tmemset(test_buf, 0, sizeof(test_buf));\n\t\tqb_log(LOG_ERR, \"message with empty extended information \"QB_XS);\n\t\tck_assert_str_eq(test_buf, \"message with empty extended information \");\n\n\t\tmemset(test_buf, 0, sizeof(test_buf));\n\t\tqb_log(LOG_ERR, QB_XS\" message with only extended information\");\n\t\tck_assert_str_eq(test_buf, extended?\n\t\t\t\t \"| message with only extended information\" : \"\");\n\n\t\tmemset(test_buf, 0, sizeof(test_buf));\n\t\tqb_log(LOG_ERR, \"message with extended information \"QB_XS\" (namely this)\");\n\t\tck_assert_str_eq(test_buf, extended?\n\t\t\t\t \"message with extended information | (namely this)\"\n\t\t\t\t : \"message with extended information \");\n\n\t\tck_assert_int_eq(num_msgs, (extended? 4 : 3));\n\t}\n\tqb_log_fini();\n}\nEND_TEST\n\nstatic const char *tagtest_stringify_tag(uint32_t tag)\n{\n\tstatic char buf[32];\n\tsprintf(buf, \"%5\" PRIu32, tag);\n\treturn buf;\n}\n\nSTART_TEST(test_zero_tags)\n{\n\tint32_t rc;\n\tint32_t t;\n\n\tqb_log_init(\"test\", LOG_USER, LOG_EMERG);\n\tqb_log_ctl(QB_LOG_SYSLOG, QB_LOG_CONF_ENABLED, QB_FALSE);\n\n\tt = qb_log_custom_open(_test_logger, NULL, NULL, NULL);\n\trc = qb_log_filter_ctl(t, QB_LOG_FILTER_ADD,\n\t\t\t       QB_LOG_FILTER_FILE, \"*\", LOG_INFO);\n\tck_assert_int_eq(rc, 0);\n\n\tqb_log_format_set(t, \"[%g] %b\");\n\tqb_log_tags_stringify_fn_set(tagtest_stringify_tag);\n\trc = qb_log_ctl(t, QB_LOG_CONF_ENABLED, QB_TRUE);\n\tck_assert_int_eq(rc, 0);\n\n\tqb_log_filter_ctl(t, QB_LOG_FILTER_ADD,\n\t\t\t  QB_LOG_FILTER_FILE, \"*\", LOG_TRACE);\n\n\tqb_log_from_external_source(\"function\", \"filename\", \"%s: %d\", LOG_DEBUG, 356, 2, \"testlog\", 2);\n\tck_assert_str_eq(test_buf, \"[    2] testlog: 2\");\n\n\tqb_log_from_external_source(\"function\", \"filename\", \"%s: %d\", LOG_DEBUG, 356, 0, \"testlog\", 0);\n\tck_assert_str_eq(test_buf, \"[    2] testlog: 0\");\n\n\tqb_log_fini();\n\n\n}\nEND_TEST\n\n#ifdef USE_JOURNAL\nSTART_TEST(test_journal)\n{\n\tint rc;\n\tconst char *msg;\n\tsize_t len;\n\tpid_t log_pid;\n\tsd_journal *jnl;\n\tint count = 0;\n\tconst char *msgid=\"f77379a8490b408bbe5f6940505a777b\";\n\n\tqb_log_init(\"check_log\", LOG_USER, LOG_DEBUG);\n\tqb_log_ctl(QB_LOG_SYSLOG, QB_LOG_CONF_ENABLED, QB_TRUE);\n\trc = qb_log_ctl(QB_LOG_SYSLOG, QB_LOG_CONF_USE_JOURNAL, 1);\n\tck_assert_int_eq(rc, 0);\n\tqb_log2(msgid, LOG_ERR, \"Test message 1 from libqb\");\n\n\tqb_log_ctl(QB_LOG_BLACKBOX, QB_LOG_CONF_ENABLED, QB_TRUE);\n\trc = qb_log_ctl(QB_LOG_BLACKBOX, QB_LOG_CONF_USE_JOURNAL, 1);\n\tck_assert_int_eq(rc, -EINVAL);\n\tsleep(1);\n\n\t/* Check it reached the journal */\n\trc = sd_journal_open(&jnl, 0);\n\tck_assert_int_eq(rc, 0);\n\trc = sd_journal_seek_tail(jnl);\n\tck_assert_int_eq(rc, 0);\n\tSD_JOURNAL_FOREACH_BACKWARDS(jnl) {\n\t    rc = sd_journal_get_data(jnl, \"_PID\", (const void **)&msg, &len);\n\t    ck_assert_int_eq(rc, 0);\n\t    sscanf(msg, \"_PID=%d\", &log_pid);\n\t    fprintf(stderr, \"PID message = '%s' - pid = %d (pid=%d, parent=%d)\\n\", msg, log_pid, getpid(), getppid());\n\t    if (log_pid == getpid()) {\n\t        rc = sd_journal_get_data(jnl, \"MESSAGE\", (const void **)&msg, &len);\n\t\tck_assert_int_eq(rc, 0);\n\t        rc = sd_journal_get_data(jnl, \"MESSAGE_ID\", (const void **)&msg, &len);\n\t\tck_assert_int_eq(rc, 0);\n\t\tck_assert_str_eq(msg+11, msgid);\n\t\tbreak;\n\t    }\n\t    if (++count > 20) {\n\t\t    break;\n            }\n        }\n\tsd_journal_close(jnl);\n\tck_assert_int_lt(count, 20);\n}\nEND_TEST\n#else\nSTART_TEST(test_syslog)\n{\n\tint rc;\n\n\tqb_log_init(\"flip\", LOG_USER, LOG_INFO);\n\tqb_log_ctl(QB_LOG_SYSLOG, QB_LOG_CONF_ENABLED, QB_TRUE);\n\n\tqb_log(LOG_ERR, \"first as flip\");\n\tck_assert_int_eq(_syslog_opened, 1);\n\tck_assert_str_eq(_syslog_ident, \"flip\");\n\n\tqb_log_ctl2(QB_LOG_SYSLOG, QB_LOG_CONF_IDENT, QB_LOG_CTL2_S(\"flop\"));\n\tqb_log(LOG_ERR, \"second as flop\");\n\tck_assert_str_eq(_syslog_ident, \"flop\");\n\n\t/* This test only runs if USE_JOURNAL is undefined, so should always fail */\n\trc = qb_log_ctl(QB_LOG_SYSLOG, QB_LOG_CONF_USE_JOURNAL, 1);\n\tck_assert_int_eq(rc, -EOPNOTSUPP);\n\n\tqb_log_fini();\n}\nEND_TEST\n#endif\n\nstatic Suite *\nlog_suite(void)\n{\n\tTCase *tc;\n\tSuite *s = suite_create(\"logging\");\n\n\tadd_tcase(s, tc, test_va_serialize);\n\tadd_tcase(s, tc, test_log_stupid_inputs);\n\tadd_tcase(s, tc, test_log_basic);\n\tadd_tcase(s, tc, test_log_format);\n\tadd_tcase(s, tc, test_log_enable);\n\tadd_tcase(s, tc, test_log_threads, 360);\n\tadd_tcase(s, tc, test_log_long_msg);\n\tadd_tcase(s, tc, test_log_filter_fn);\n\tadd_tcase(s, tc, test_threaded_logging);\n\tadd_tcase(s, tc, test_line_length);\n\tadd_tcase(s, tc, test_file_logging);\n#ifdef HAVE_PTHREAD_SETSCHEDPARAM\n\tadd_tcase(s, tc, test_threaded_logging_bad_sched_params);\n#endif\n\tadd_tcase(s, tc, test_timestamps);\n\tadd_tcase(s, tc, test_extended_information);\n\tadd_tcase(s, tc, test_zero_tags);\n/*\n * You can still use syslog and journal in a normal application,\n * but the syslog_override code doesn't work when -lsystemd is present\n */\n#ifdef USE_JOURNAL\n        add_tcase(s, tc, test_journal);\n#else\n\tadd_tcase(s, tc, test_syslog);\n#endif\n\n\treturn s;\n}\n\nint32_t\nmain(void)\n{\n\tint32_t number_failed;\n\n\tSuite *s = log_suite();\n\tSRunner *sr = srunner_create(s);\n\n\tsrunner_run_all(sr, CK_VERBOSE);\n\tnumber_failed = srunner_ntests_failed(sr);\n\tsrunner_free(sr);\n\treturn (number_failed == 0) ? EXIT_SUCCESS : EXIT_FAILURE;\n}\n"], "fixing_code": ["/*\n * Copyright (C) 2011 Red Hat, Inc.\n *\n * All rights reserved.\n *\n * Author: Angus Salkeld <asalkeld@redhat.com>\n *\n * libqb is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation, either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * libqb is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with libqb.  If not, see <http://www.gnu.org/licenses/>.\n */\n#include \"os_base.h\"\n\n#include <qb/qbrb.h>\n#include \"util_int.h\"\n#include \"log_int.h\"\n#include \"ringbuffer_int.h\"\n\n#define BB_MIN_ENTRY_SIZE (4 * sizeof(uint32_t) +\\\n\t\t\t   sizeof(uint8_t) +\\\n\t\t\t   2 * sizeof(char) + sizeof(time_t))\n\n\nstatic void\n_blackbox_reload(int32_t target)\n{\n\tstruct qb_log_target *t = qb_log_target_get(target);\n\n\tif (t->instance == NULL) {\n\t\treturn;\n\t}\n\tqb_rb_close(t->instance);\n\tt->instance = qb_rb_open(t->filename, t->size,\n\t\t\t\t QB_RB_FLAG_CREATE | QB_RB_FLAG_OVERWRITE, 0);\n}\n\n/* <u32> file lineno\n * <u32> tags\n * <u8> priority\n * <u32> function name length\n * <string> function name\n * <u32> buffer length\n * <string> buffer\n */\nstatic void\n_blackbox_vlogger(int32_t target,\n\t\t  struct qb_log_callsite *cs, struct timespec *timestamp, va_list ap)\n{\n\tsize_t max_size;\n\tsize_t actual_size;\n\tuint32_t fn_size;\n\tchar *chunk;\n\tchar *msg_len_pt;\n\tuint32_t msg_len;\n\tstruct qb_log_target *t = qb_log_target_get(target);\n\n\tif (t->instance == NULL) {\n\t\treturn;\n\t}\n\n\tfn_size = strlen(cs->function) + 1;\n\n\tactual_size = 4 * sizeof(uint32_t) + sizeof(uint8_t) + fn_size + sizeof(struct timespec);\n\tmax_size = actual_size + t->max_line_length;\n\n\tchunk = qb_rb_chunk_alloc(t->instance, max_size);\n\n\tif (chunk == NULL) {\n\t\t/* something bad has happened. abort blackbox logging */\n\t\tqb_util_perror(LOG_ERR, \"Blackbox allocation error, aborting blackbox log %s\", t->filename);\n\t\tqb_rb_close(qb_rb_lastref_and_ret(\n\t\t\t(struct qb_ringbuffer_s **) &t->instance\n\t\t));\n\t\treturn;\n\t}\n\n\t/* line number */\n\tmemcpy(chunk, &cs->lineno, sizeof(uint32_t));\n\tchunk += sizeof(uint32_t);\n\n\t/* tags */\n\tmemcpy(chunk, &cs->tags, sizeof(uint32_t));\n\tchunk += sizeof(uint32_t);\n\n\t/* log level/priority */\n\tmemcpy(chunk, &cs->priority, sizeof(uint8_t));\n\tchunk += sizeof(uint8_t);\n\n\t/* function name */\n\tmemcpy(chunk, &fn_size, sizeof(uint32_t));\n\tchunk += sizeof(uint32_t);\n\tmemcpy(chunk, cs->function, fn_size);\n\tchunk += fn_size;\n\n\t/* timestamp */\n\tmemcpy(chunk, timestamp, sizeof(struct timespec));\n\tchunk += sizeof(struct timespec);\n\n\t/* log message length */\n\tmsg_len_pt = chunk;\n\tchunk += sizeof(uint32_t);\n\n\t/* log message */\n\tmsg_len = qb_vsnprintf_serialize(chunk, t->max_line_length, cs->format, ap);\n\tif (msg_len >= t->max_line_length) {\n\t    chunk = msg_len_pt + sizeof(uint32_t); /* Reset */\n\n\t    /* Leave this at QB_LOG_MAX_LEN so as not to overflow the blackbox */\n\t    msg_len = qb_vsnprintf_serialize(chunk, QB_LOG_MAX_LEN,\n\t\t\"Log message too long to be stored in the blackbox.  \"\\\n\t\t\"Maximum is QB_LOG_MAX_LEN\" , ap);\n\t}\n\n\tactual_size += msg_len;\n\n\t/* now that we know the length, write it\n\t */\n\tmemcpy(msg_len_pt, &msg_len, sizeof(uint32_t));\n\n\t(void)qb_rb_chunk_commit(t->instance, actual_size);\n}\n\nstatic void\n_blackbox_close(int32_t target)\n{\n\tstruct qb_log_target *t = qb_log_target_get(target);\n\n\tqb_rb_close(qb_rb_lastref_and_ret(\n\t\t(struct qb_ringbuffer_s **) &t->instance\n\t));\n}\n\nint32_t\nqb_log_blackbox_open(struct qb_log_target *t)\n{\n\tif (t->size < 1024) {\n\t\treturn -EINVAL;\n\t}\n\tsnprintf(t->filename, PATH_MAX, \"%s-%d-blackbox\", t->name, getpid());\n\n\tt->instance = qb_rb_open(t->filename, t->size,\n\t\t\t\t QB_RB_FLAG_CREATE | QB_RB_FLAG_OVERWRITE, 0);\n\tif (t->instance == NULL) {\n\t\treturn -errno;\n\t}\n\n\tt->logger = NULL;\n\tt->vlogger = _blackbox_vlogger;\n\tt->reload = _blackbox_reload;\n\tt->close = _blackbox_close;\n\treturn 0;\n}\n\n/*\n * This is designed to look as much like the ringbuffer header\n * as possible so that we can distinguish an old RB dump\n * from a new one with this header.\n */\n\nstruct _blackbox_file_header {\n\tuint32_t word_size;\n\tuint32_t read_pt;\n\tuint32_t write_pt;\n\tuint32_t version;\n\tuint32_t hash;\n} __attribute__((packed));\n\n/* Values we expect for a 'new' header */\n#define QB_BLACKBOX_HEADER_WORDSIZE 0\n#define QB_BLACKBOX_HEADER_READPT   0xCCBBCCBB\n#define QB_BLACKBOX_HEADER_WRITEPT  0xBBCCBBCC\n#define QB_BLACKBOX_HEADER_VERSION  2\n#define QB_BLACKBOX_HEADER_HASH     0\n\nssize_t\nqb_log_blackbox_write_to_file(const char *filename)\n{\n\tssize_t written_size = 0;\n\tstruct qb_log_target *t;\n\tstruct _blackbox_file_header header;\n\tint fd = open(filename, O_CREAT | O_RDWR, 0700);\n\n\tif (fd < 0) {\n\t\treturn -errno;\n\t}\n\n\t/* Write header, so we know this is a 'new' format blackbox */\n\theader.word_size = QB_BLACKBOX_HEADER_WORDSIZE;\n\theader.read_pt   = QB_BLACKBOX_HEADER_READPT;\n\theader.write_pt  = QB_BLACKBOX_HEADER_WRITEPT;\n\theader.version   = QB_BLACKBOX_HEADER_VERSION;\n\theader.hash      = QB_BLACKBOX_HEADER_HASH;\n\twritten_size = write(fd, &header, sizeof(header));\n\tif (written_size < sizeof(header)) {\n\t\tclose(fd);\n\t\treturn written_size;\n\t}\n\n\tt = qb_log_target_get(QB_LOG_BLACKBOX);\n\tif (t->instance) {\n\t\twritten_size += qb_rb_write_to_file(t->instance, fd);\n\t} else {\n\t\twritten_size = -ENOENT;\n\t}\n\tclose(fd);\n\n\treturn written_size;\n}\n\nint\nqb_log_blackbox_print_from_file(const char *bb_filename)\n{\n\tqb_ringbuffer_t *instance;\n\tssize_t bytes_read;\n\tint max_size = 2 * QB_LOG_MAX_LEN;\n\tchar *chunk;\n\tint fd;\n\tint err = 0;\n\tint saved_errno;\n\tstruct _blackbox_file_header header;\n\tint have_timespecs = 0;\n\tchar time_buf[64];\n\n\tfd = open(bb_filename, 0);\n\tif (fd < 0) {\n\t\tsaved_errno = errno;\n\t\tqb_util_perror(LOG_ERR, \"qb_log_blackbox_print_from_file\");\n\t\treturn -saved_errno;\n\t}\n\n\t/* Read the header. If it looks like one of ours then\n\t   we know we have hi-res timestamps */\n\terr = read(fd, &header, sizeof(header));\n\tif (err < sizeof(header)) {\n\t\tsaved_errno = errno;\n\t\tclose(fd);\n\t\treturn -saved_errno;\n\t}\n\n\tif (header.word_size == QB_BLACKBOX_HEADER_WORDSIZE &&\n\t    header.read_pt == QB_BLACKBOX_HEADER_READPT &&\n\t    header.write_pt == QB_BLACKBOX_HEADER_WRITEPT &&\n\t    header.version == QB_BLACKBOX_HEADER_VERSION &&\n\t    header.hash == QB_BLACKBOX_HEADER_HASH) {\n\t\thave_timespecs = 1;\n\t} else {\n\t\t(void)lseek(fd, 0, SEEK_SET);\n\t}\n\n\n\tinstance = qb_rb_create_from_file(fd, 0);\n\tclose(fd);\n\tif (instance == NULL) {\n\t\treturn -EIO;\n\t}\n\tchunk = malloc(max_size);\n\tif (!chunk) {\n\t\tgoto cleanup;\n\t}\n\n\tdo {\n\t\tchar *ptr;\n\t\tuint32_t lineno;\n\t\tuint32_t tags;\n\t\tuint8_t priority;\n\t\tuint32_t fn_size;\n\t\tchar *function;\n\t\tuint32_t len;\n\t\tstruct timespec timestamp;\n\t\ttime_t time_sec;\n\t\tuint32_t msg_len;\n\t\tstruct tm *tm;\n\t\tchar message[QB_LOG_MAX_LEN];\n\n\t\tbytes_read = qb_rb_chunk_read(instance, chunk, max_size, 0);\n\n\t\tif (bytes_read >= 0 && bytes_read < BB_MIN_ENTRY_SIZE) {\n\t\t\tprintf(\"ERROR Corrupt file: blackbox header too small.\\n\");\n\t\t\terr = -1;\n\t\t\tgoto cleanup;\n\t\t} else if (bytes_read < 0) {\n\t\t\terrno = -bytes_read;\n\t\t\tperror(\"ERROR: qb_rb_chunk_read failed\");\n\t\t\terr = -EIO;\n\t\t\tgoto cleanup;\n\t\t}\n\t\tptr = chunk;\n\n\t\t/* lineno */\n\t\tmemcpy(&lineno, ptr, sizeof(uint32_t));\n\t\tptr += sizeof(uint32_t);\n\n\t\t/* tags */\n\t\tmemcpy(&tags, ptr, sizeof(uint32_t));\n\t\tptr += sizeof(uint32_t);\n\n\t\t/* priority */\n\t\tmemcpy(&priority, ptr, sizeof(uint8_t));\n\t\tptr += sizeof(uint8_t);\n\n\t\t/* function size & name */\n\t\tmemcpy(&fn_size, ptr, sizeof(uint32_t));\n\t\tif ((fn_size + BB_MIN_ENTRY_SIZE) > bytes_read) {\n#ifndef S_SPLINT_S\n\t\t\tprintf(\"ERROR Corrupt file: fn_size way too big %\" PRIu32 \"\\n\", fn_size);\n\t\t\terr = -EIO;\n#endif /* S_SPLINT_S */\n\t\t\tgoto cleanup;\n\t\t}\n\t\tif (fn_size <= 0) {\n#ifndef S_SPLINT_S\n\t\t\tprintf(\"ERROR Corrupt file: fn_size negative %\" PRIu32 \"\\n\", fn_size);\n\t\t\terr = -EIO;\n#endif /* S_SPLINT_S */\n\t\t\tgoto cleanup;\n\t\t}\n\t\tptr += sizeof(uint32_t);\n\n\t\tfunction = ptr;\n\t\tptr += fn_size;\n\n\t\t/* timestamp size & content */\n\t\tif (have_timespecs) {\n\t\t\tmemcpy(&timestamp, ptr, sizeof(struct timespec));\n\t\t\tptr += sizeof(struct timespec);\n\t\t\ttime_sec = timestamp.tv_sec;\n\t\t} else {\n\t\t\tmemcpy(&time_sec, ptr, sizeof(time_t));\n\t\t\tptr += sizeof(time_t);\n\t\t\ttimestamp.tv_nsec = 0LL;\n\t\t}\n\n\t\ttm = localtime(&time_sec);\n\t\tif (tm) {\n\t\t\tint slen = strftime(time_buf,\n\t\t\t\t\t    sizeof(time_buf), \"%b %d %T\",\n\t\t\t\t\t    tm);\n\t\t\tsnprintf(time_buf+slen, sizeof(time_buf) - slen, \".%03llu\", timestamp.tv_nsec/QB_TIME_NS_IN_MSEC);\n\t\t} else {\n\t\t\tsnprintf(time_buf, sizeof(time_buf), \"%ld\",\n\t\t\t\t (long int)time_sec);\n\t\t}\n\t\t/* message length */\n\t\tmemcpy(&msg_len, ptr, sizeof(uint32_t));\n\t\tif (msg_len > QB_LOG_MAX_LEN || msg_len <= 0) {\n#ifndef S_SPLINT_S\n\t\t\tprintf(\"ERROR Corrupt file: msg_len out of bounds %\" PRIu32 \"\\n\", msg_len);\n\t\t\terr = -EIO;\n#endif /* S_SPLINT_S */\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tptr += sizeof(uint32_t);\n\n\t\t/* message content */\n\t\tlen = qb_vsnprintf_deserialize(message, QB_LOG_MAX_LEN, ptr);\n\t\tassert(len > 0);\n\t\tmessage[len] = '\\0';\n\t\tlen--;\n\t\twhile (len > 0 && (message[len] == '\\n' || message[len] == '\\0')) {\n\t\t\tmessage[len] = '\\0';\n\t\t\tlen--;\n\t\t}\n\n\t\tprintf(\"%-7s %s %s(%u):%u: %s\\n\",\n\t\t       qb_log_priority2str(priority),\n\t\t       time_buf, function, lineno, tags, message);\n\n\t} while (bytes_read > BB_MIN_ENTRY_SIZE);\n\ncleanup:\n\tqb_rb_close(instance);\n\tfree(chunk);\n\treturn err;\n}\n", "/*\n * Copyright (c) 2011-2015 Red Hat, Inc.\n *\n * All rights reserved.\n *\n * Author: Angus Salkeld <asalkeld@redhat.com>\n *\n * This file is part of libqb.\n *\n * libqb is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation, either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * libqb is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with libqb.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"os_base.h\"\n#include <pthread.h>\n\n#include \"check_common.h\"\n\n#include <qb/qbdefs.h>\n#include <qb/qbutil.h>\n#include <qb/qblog.h>\n\n#ifdef USE_JOURNAL\n#include <systemd/sd-journal.h>\n#endif\n\n#include \"_syslog_override.h\"\n\nextern size_t qb_vsnprintf_serialize(char *serialize, size_t max_len, const char *fmt, va_list ap);\nextern size_t qb_vsnprintf_deserialize(char *string, size_t strlen, const char *buf);\n\n\nstatic void\nformat_this(char *out, const char *fmt, ...)\n{\n\tchar buf[QB_LOG_MAX_LEN];\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tqb_vsnprintf_serialize(buf, QB_LOG_MAX_LEN, fmt, ap);\n\tqb_vsnprintf_deserialize(out, QB_LOG_MAX_LEN, buf);\n\tva_end(ap);\n}\n\nstatic void\nformat_this_up_to(char *out, size_t max_len, const char *fmt, ...)\n{\n\tchar buf[QB_LOG_MAX_LEN];\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tqb_vsnprintf_serialize(buf, max_len, fmt, ap);\n\tqb_vsnprintf_deserialize(out, QB_LOG_MAX_LEN, buf);\n\tva_end(ap);\n}\n\nSTART_TEST(test_va_serialize)\n{\n\tchar buf[QB_LOG_MAX_LEN];\n\tchar cmp_buf[QB_LOG_MAX_LEN];\n\n\tformat_this(buf, \"one line\");\n\tck_assert_str_eq(buf, \"one line\");\n\n\tformat_this(buf, \"p1:%p, p2:%p\", format_this, buf);\n\tsnprintf(cmp_buf, QB_LOG_MAX_LEN, \"p1:%p, p2:%p\", format_this, buf);\n\tck_assert_str_eq(buf, cmp_buf);\n\n\tformat_this(buf, \"s1:%s, s2:%s\", \"Yes\", \"Never\");\n\tck_assert_str_eq(buf, \"s1:Yes, s2:Never\");\n\n\tformat_this(buf, \"s1:%s, s2:%s\", \"Yes\", \"Never\");\n\tck_assert_str_eq(buf, \"s1:Yes, s2:Never\");\n\n\tformat_this(buf, \"d1:%d, d2:%5i, d3:%04i\", 23, 37, 84);\n\tck_assert_str_eq(buf, \"d1:23, d2:   37, d3:0084\");\n\n\tformat_this(buf, \"f1:%.5f, f2:%.2f\", 23.34109, 23.34109);\n\tck_assert_str_eq(buf, \"f1:23.34109, f2:23.34\");\n\n\tformat_this(buf, \"%zd\", (size_t)13140964);\n\tck_assert_str_eq(buf, \"13140964\");\n\tformat_this(buf, \"%jd\", (intmax_t)30627823);\n\tck_assert_str_eq(buf, \"30627823\");\n\tformat_this(buf, \"%td\", buf-cmp_buf);\n\tsnprintf(cmp_buf, QB_LOG_MAX_LEN, \"%td\", buf-cmp_buf);\n\tck_assert_str_eq(buf, cmp_buf);\n\n\tformat_this(buf, \":%s:\", \"Hello, world!\");\n\tck_assert_str_eq(buf, \":Hello, world!:\");\n\tformat_this(buf, \":%15s:\", \"Hello, world!\");\n\tck_assert_str_eq(buf, \":  Hello, world!:\");\n\tformat_this(buf, \":%.10s:\", \"Hello, world!\");\n\tck_assert_str_eq(buf, \":Hello, wor:\");\n\tformat_this(buf, \":%-10s:\", \"Hello, world!\");\n\tck_assert_str_eq(buf, \":Hello, world!:\");\n\tformat_this(buf, \":%-15s:\", \"Hello, world!\");\n\tck_assert_str_eq(buf, \":Hello, world!  :\");\n\tformat_this(buf, \":%.15s:\", \"Hello, world!\");\n\tck_assert_str_eq(buf, \":Hello, world!:\");\n\tformat_this(buf, \":%15.10s:\", \"Hello, world!\");\n\tck_assert_str_eq(buf, \":     Hello, wor:\");\n\tformat_this(buf, \":%-15.10s:\", \"Hello, world!\");\n\tck_assert_str_eq(buf, \":Hello, wor     :\");\n\n\tformat_this(buf, \":%*d:\", 8, 96);\n\tck_assert_str_eq(buf, \":      96:\");\n\n\tformat_this_up_to(buf, 11, \"123456789____\");\n\tck_assert_str_eq(buf, \"123456789_\");\n\n\tformat_this(buf, \"Client %s.%.9s wants to fence (%s) '%s' with device '%s'\",\n\t\t    \"bla\", \"foooooooooooooooooo\",\n\t\t    \"action\", \"target\", \"hoop\");\n\n\tck_assert_str_eq(buf,\n\t\t\t \"Client bla.foooooooo wants to fence (action) 'target' with device 'hoop'\");\n\n\tformat_this(buf, \"Node %s now has process list: %.32x (was %.32x)\",\n\t\t    \"18builder\", 2, 0);\n\tck_assert_str_eq(buf, \"Node 18builder now has process list: 00000000000000000000000000000002 (was 00000000000000000000000000000000)\");\n\n\n}\nEND_TEST\n\nSTART_TEST(test_log_stupid_inputs)\n{\n\tint32_t rc;\n\n\t/* shouldn't crash with out an init() */\n\tqb_log_fini();\n\n\t/* not init'ed */\n\trc = qb_log_filter_ctl(QB_LOG_SYSLOG, QB_LOG_FILTER_ADD,\n\t\t\t       QB_LOG_FILTER_FILE, \"bla\", LOG_TRACE);\n\tck_assert_int_eq(rc, -EINVAL);\n\n\trc = qb_log_ctl(QB_LOG_BLACKBOX, QB_LOG_CONF_SIZE, 2000);\n\tck_assert_int_eq(rc, -EINVAL);\n\n\tqb_log(LOG_INFO, \"not init'd\");\n\n\tqb_log_from_external_source(__func__, __FILE__, \"%s\", LOG_INFO,\n\t\t\t\t    __LINE__, 0, \"also not init'd\");\n\n\tqb_log_init(\"test\", LOG_USER, LOG_DEBUG);\n\n\t/* non-opened log file */\n\trc = qb_log_filter_ctl(21, QB_LOG_FILTER_ADD,\n\t\t\t       QB_LOG_FILTER_FILE, \"bla\", LOG_TRACE);\n\tck_assert_int_eq(rc, -EBADF);\n\n\trc = qb_log_ctl(21, QB_LOG_CONF_PRIORITY_BUMP, -1);\n\tck_assert_int_eq(rc, -EBADF);\n\n\t/* target < 0 or >= 32 */\n\trc = qb_log_filter_ctl(41, QB_LOG_FILTER_ADD,\n\t\t\t       QB_LOG_FILTER_FILE, \"bla\", LOG_TRACE);\n\tck_assert_int_eq(rc, -EBADF);\n\n\trc = qb_log_ctl(-1, QB_LOG_CONF_PRIORITY_BUMP, -1);\n\tck_assert_int_eq(rc, -EBADF);\n\n\t/* crap values to filter_ctl() */\n\trc = qb_log_filter_ctl(QB_LOG_SYSLOG, QB_LOG_FILTER_ADD,\n\t\t\t       QB_LOG_FILTER_FILE, NULL, LOG_INFO);\n\tck_assert_int_eq(rc, -EINVAL);\n\trc = qb_log_filter_ctl(QB_LOG_SYSLOG, 56,\n\t\t\t       QB_LOG_FILTER_FILE, \"boja\", LOG_INFO);\n\tck_assert_int_eq(rc, -EINVAL);\n\n\t/* crap values to ctl() */\n\trc = qb_log_ctl(QB_LOG_BLACKBOX, QB_LOG_CONF_SIZE, -2000);\n\tck_assert_int_eq(rc, -EINVAL);\n\trc = qb_log_ctl(QB_LOG_BLACKBOX, 67, 2000);\n\tck_assert_int_eq(rc, -EINVAL);\n\trc = qb_log_ctl(QB_LOG_SYSLOG, QB_LOG_CONF_SIZE, 2000);\n\tck_assert_int_eq(rc, -ENOSYS);\n\n}\nEND_TEST\n\nstatic char test_buf[4097];\nstatic uint8_t test_priority;\nstatic int32_t num_msgs;\nstatic size_t last_length;\n\n/*\n * to test that we get what we expect.\n */\nstatic void\n_test_logger(int32_t t,\n\t     struct qb_log_callsite *cs,\n\t     struct timespec *timestamp, const char *msg)\n{\n\ttest_buf[0] = '\\0';\n\tqb_log_target_format(t, cs, timestamp, msg, test_buf);\n\ttest_priority = cs->priority;\n\n\tnum_msgs++;\n}\n\nstatic void\n_test_length_logger(int32_t t,\n\t     struct qb_log_callsite *cs,\n\t     struct timespec *timestamp, const char *msg)\n{\n\tstrcpy(test_buf, msg);\n\tqb_log_target_format(t, cs, timestamp, msg, test_buf);\n\ttest_priority = cs->priority;\n\n\tnum_msgs++;\n\tlast_length = strlen(msg);\n}\n\nstatic void log_also(void)\n{\n\tqb_log(LOG_INFO, \"yes please\");\n}\n\nstatic void log_and_this_too(void)\n{\n\tqb_log(LOG_INFO, \"this too please\");\n}\n\nstatic void log_it_please(void)\n{\n\tqb_enter();\n\tqb_log(LOG_TRACE, \"A:%d B:%d C:%d\", 1, 2, 3);\n\tqb_log(LOG_DEBUG, \"A:%d B:%d C:%d\", 1, 2, 3);\n\terrno = EEXIST;\n\tqb_perror(LOG_WARNING, \"bogus error\");\n\terrno = 0;\n\tqb_log(LOG_INFO, \"A:%d B:%d C:%d\", 1, 2, 3);\n\tqb_log(LOG_NOTICE, \"A:%d B:%d C:%d\", 1, 2, 3);\n\tqb_log(LOG_WARNING, \"A:%d B:%d C:%d\", 1, 2, 3);\n\tqb_log(LOG_ERR, \"A:%d B:%d C:%d\", 1, 2, 3);\n\tqb_leave();\n}\n\n\nstatic int32_t _cust_t = -1;\nstatic void\nm_filter(struct qb_log_callsite *cs)\n{\n\tif ((cs->priority >= LOG_ALERT &&\n\t     cs->priority <= LOG_INFO) ||\n\t    cs->tags > 0) {\n\t\tqb_bit_set(cs->targets, _cust_t);\n\t} else {\n\t\tqb_bit_clear(cs->targets, _cust_t);\n\t}\n}\n\n\nSTART_TEST(test_log_filter_fn)\n{\n\tint32_t rc;\n\n\tqb_log_init(\"test\", LOG_USER, LOG_EMERG);\n\tqb_log_ctl(QB_LOG_SYSLOG, QB_LOG_CONF_ENABLED, QB_FALSE);\n\n\t_cust_t = qb_log_custom_open(_test_logger, NULL, NULL, NULL);\n\t_ck_assert_int(_cust_t, >, QB_LOG_BLACKBOX);\n\trc = qb_log_ctl(_cust_t, QB_LOG_CONF_ENABLED, QB_TRUE);\n\tck_assert_int_eq(rc, 0);\n\n\t/*\n\t * test the custom filter function.\n\t * make sure qb_log, and qb_log_from_external_source are filtered.\n\t */\n\tqb_log_filter_fn_set(m_filter);\n\tnum_msgs = 0;\n\n\tqb_log(LOG_NOTICE, \"qb_log_filter_fn_set good\");\n\tqb_log_from_external_source(__func__, __FILE__, \"%s\", LOG_INFO,\n\t\t\t\t    __LINE__, 0, \"qb_log_filter_fn_set good\");\n\tqb_log(LOG_TRACE, \"qb_log_filter_fn_set bad\");\n\tqb_log_from_external_source(__func__, __FILE__, \"%s\", LOG_DEBUG,\n\t\t\t\t    __LINE__, 44, \"qb_log_filter_fn_set woot\");\n\tqb_log_from_external_source(__func__, __FILE__, \"%s\", LOG_DEBUG,\n\t\t\t\t    __LINE__, 0, \"qb_log_filter_fn_set bad\");\n\n\tck_assert_int_eq(num_msgs, 3);\n}\nEND_TEST\n\nSTART_TEST(test_file_logging)\n{\n\tstruct stat st;\n\tint rc, lf;\n\n\tunlink(\"test1.log\");\n\tunlink(\"test2.log\");\n\n\tqb_log_init(\"test\", LOG_USER, LOG_DEBUG);\n\tlf = qb_log_file_open(\"test1.log\");\n\trc = qb_log_filter_ctl(lf, QB_LOG_FILTER_ADD, QB_LOG_FILTER_FILE,\n\t\t\t       __FILE__, LOG_DEBUG);\n\tck_assert_int_eq(rc, 0);\n\trc = qb_log_ctl(lf, QB_LOG_CONF_ENABLED, QB_TRUE);\n\tck_assert_int_eq(rc, 0);\n\n\tqb_log(LOG_INFO, \"write to file 1\");\n\tqb_log(LOG_INFO, \"write to file 1 again\");\n\n\trc = stat(\"test1.log\", &st);\n\tck_assert_int_eq(rc, 0);\n\tck_assert_int_ge(st.st_size, 32);\n\n\t/* Test reopen with NULL arg */\n\trc = qb_log_file_reopen(lf, NULL);\n\tck_assert_int_eq(rc, 0);\n\tqb_log(LOG_INFO, \"write to file 1 and again\");\n\tqb_log(LOG_INFO, \"write to file 1 yet again\");\n\trc = stat(\"test1.log\", &st);\n\tck_assert_int_eq(rc, 0);\n\tck_assert_int_ge(st.st_size, 64);\n\n\t/* Test reopen with new file */\n\trc = qb_log_file_reopen(lf, \"test2.log\");\n\tck_assert_int_eq(rc, 0);\n\n\tqb_log(LOG_INFO, \"write to file 2\");\n\tqb_log(LOG_INFO, \"write to file 2 again\");\n\n\trc = stat(\"test2.log\", &st);\n\tck_assert_int_eq(rc, 0);\n\tck_assert_int_ge(st.st_size, 32);\n\n\tunlink(\"test1.log\");\n\tunlink(\"test2.log\");\n}\nEND_TEST\n\nSTART_TEST(test_timestamps)\n{\n\tint32_t t;\n\tint32_t rc;\n\tint a,b,c,d;\n\n\tqb_log_init(\"test\", LOG_USER, LOG_EMERG);\n\tqb_log_ctl(QB_LOG_SYSLOG, QB_LOG_CONF_ENABLED, QB_FALSE);\n\n\tt = qb_log_custom_open(_test_logger, NULL, NULL, NULL);\n\trc = qb_log_filter_ctl(t, QB_LOG_FILTER_ADD,\n\t\t\t       QB_LOG_FILTER_FILE, \"*\", LOG_INFO);\n\tck_assert_int_eq(rc, 0);\n\n\t/* normal timestamp */\n\tqb_log_format_set(t, \"%t %b\");\n\trc = qb_log_ctl(t, QB_LOG_CONF_ENABLED, QB_TRUE);\n\tck_assert_int_eq(rc, 0);\n\n\tqb_log(LOG_INFO, \"The time now is (see left)\");\n\trc = sscanf(test_buf+7, \"%d:%d:%d.%d\", &a, &b, &c, &d);\n\tck_assert_int_eq(rc, 3);\n\n\t/* millisecond timestamp */\n\tqb_log_format_set(t, \"%T %b\");\n\tqb_log(LOG_INFO, \"The time now is precisely (see left)\");\n\trc = sscanf(test_buf+7, \"%d:%d:%d.%d\", &a, &b, &c, &d);\n\tck_assert_int_eq(rc, 4);\n}\nEND_TEST\n\n\nSTART_TEST(test_line_length)\n{\n\tint32_t t;\n\tint32_t rc;\n\tint i;\n\tchar bigbuf[4097];\n\n\tqb_log_init(\"test\", LOG_USER, LOG_EMERG);\n\tqb_log_ctl(QB_LOG_SYSLOG, QB_LOG_CONF_ENABLED, QB_FALSE);\n\n\tt = qb_log_custom_open(_test_length_logger, NULL, NULL, NULL);\n\trc = qb_log_filter_ctl(t, QB_LOG_FILTER_ADD,\n\t\t\t  QB_LOG_FILTER_FORMAT, \"*\", LOG_WARNING);\n\tck_assert_int_eq(rc, 0);\n\tqb_log_format_set(t, \"[%p] %b\");\n\trc = qb_log_ctl(t, QB_LOG_CONF_ENABLED, QB_TRUE);\n\tck_assert_int_eq(rc, 0);\n\trc = qb_log_ctl(t, QB_LOG_CONF_MAX_LINE_LEN, 32);\n\tck_assert_int_eq(rc, 0);\n\trc = qb_log_ctl(t, QB_LOG_CONF_ELLIPSIS, QB_TRUE);\n\tck_assert_int_eq(rc, 0);\n\n\t/* captures last log */\n\tmemset(test_buf, 0, sizeof(test_buf));\n\ttest_priority = 0;\n\tnum_msgs = 0;\n\n\tqb_log(LOG_ERR, \"Short message\");\n\tqb_log(LOG_ERR, \"This is a longer message 123456789012345678901234567890\");\n\tqb_log(LOG_ERR, \"Long message with parameters %d %s\", 1234, \"Oh yes it is\");\n\n\tck_assert_int_eq(num_msgs, 3);\n\tck_assert_int_eq(last_length, 31);\n\n\tck_assert_str_eq(test_buf+28, \"...\");\n\n\trc = qb_log_ctl(t, QB_LOG_CONF_ELLIPSIS, QB_FALSE);\n\tck_assert_int_eq(rc, 0);\n\n\tqb_log(LOG_ERR, \"Long message with parameters %d %s\", 1234, \"Oh yes it is\");\n\tck_assert_str_ne(test_buf+28, \"...\");\n\n\t/* Long lines */\n\tnum_msgs = 0;\n\trc = qb_log_ctl(t, QB_LOG_CONF_MAX_LINE_LEN, 4096);\n\tck_assert_int_eq(rc, 0);\n\n\tfor (i=0; i<4096; i++) {\n\t\tbigbuf[i] = '0'+(i%10);\n\t}\n\tbigbuf[4096] = '\\0';\n\tqb_log(LOG_ERR, \"%s\", bigbuf);\n\tck_assert_int_eq(num_msgs, 1);\n\tck_assert_int_eq(last_length, 4095);\n}\nEND_TEST\n\nSTART_TEST(test_log_basic)\n{\n\tint32_t t;\n\tint32_t rc;\n\n\tqb_log_init(\"test\", LOG_USER, LOG_EMERG);\n\tqb_log_ctl(QB_LOG_SYSLOG, QB_LOG_CONF_ENABLED, QB_FALSE);\n\n\tt = qb_log_custom_open(_test_logger, NULL, NULL, NULL);\n\trc = qb_log_filter_ctl(t, QB_LOG_FILTER_ADD,\n\t\t\t  QB_LOG_FILTER_FORMAT, \"Angus\", LOG_WARNING);\n\tck_assert_int_eq(rc, 0);\n\tqb_log_format_set(t, \"%b\");\n\trc = qb_log_ctl(t, QB_LOG_CONF_ENABLED, QB_TRUE);\n\tck_assert_int_eq(rc, 0);\n\n\t/* captures last log */\n\tmemset(test_buf, 0, sizeof(test_buf));\n\ttest_priority = 0;\n\tnum_msgs = 0;\n\n\t/*\n\t * test filtering by format\n\t */\n\tqb_log(LOG_INFO, \"Hello Angus, how are you?\");\n\tqb_log(LOG_WARNING, \"Hello Steven, how are you?\");\n\tqb_log(LOG_ERR, \"Hello Andrew, how are you?\");\n\tqb_log(LOG_ERR, \"Hello Angus, how are you?\");\n\tqb_log(LOG_EMERG, \"Hello Anna, how are you?\");\n\tck_assert_int_eq(test_priority, LOG_ERR);\n\tck_assert_int_eq(num_msgs, 1);\n\tck_assert_str_eq(test_buf, \"Hello Angus, how are you?\");\n\n\n\t/*\n\t * test filtering by file regex\n \t */\n\tqb_log_filter_ctl(t, QB_LOG_FILTER_CLEAR_ALL,\n\t\t\t  QB_LOG_FILTER_FORMAT, \"*\", LOG_TRACE);\n\tqb_log_filter_ctl(t, QB_LOG_FILTER_ADD,\n\t\t\t  QB_LOG_FILTER_FILE_REGEX, \"^fakefile*\", LOG_DEBUG);\n\n\tnum_msgs = 0;\n\tqb_log_from_external_source(__func__, \"fakefile_logging\", \"%s bla\", LOG_INFO,\n\t\t\t\t    56, 0, \"filename/lineno\");\n\tqb_log_from_external_source(__func__, \"do_not_log_fakefile_logging\", \"%s bla\", LOG_INFO,\n\t\t\t\t    56, 0, \"filename/lineno\");\n\tck_assert_int_eq(num_msgs, 1);\n\n\t/*\n\t * test filtering by format regex\n \t */\n\tqb_log_filter_ctl(t, QB_LOG_FILTER_CLEAR_ALL,\n\t\t\t  QB_LOG_FILTER_FORMAT, \"*\", LOG_TRACE);\n\tqb_log_filter_ctl(t, QB_LOG_FILTER_ADD,\n\t\t\t  QB_LOG_FILTER_FORMAT_REGEX, \"^one\", LOG_WARNING);\n\n\tnum_msgs = 0;\n\tqb_log(LOG_INFO, \"one two three\");\n\tqb_log(LOG_ERR, \"testing one two three\");\n\tqb_log(LOG_WARNING, \"one two three\");\n\tqb_log(LOG_ERR, \"one two three\");\n\tqb_log(LOG_EMERG, \"one two three\");\n\tck_assert_int_eq(num_msgs, 3);\n\n\t/*\n\t * test filtering by function and regex\n\t */\n\tqb_log_filter_ctl(t, QB_LOG_FILTER_CLEAR_ALL,\n\t\t\t  QB_LOG_FILTER_FILE, \"*\", LOG_TRACE);\n\tqb_log_filter_ctl(t, QB_LOG_FILTER_ADD,\n\t\t\t  QB_LOG_FILTER_FUNCTION_REGEX, \"^log_.*please\", LOG_WARNING);\n\n\tnum_msgs = 0;\n\tqb_log(LOG_ERR, \"try if you: log_it_please()\");\n\tlog_it_please();\n\tck_assert_int_eq(num_msgs, 3);\n\n\tqb_log_filter_ctl(t, QB_LOG_FILTER_REMOVE,\n\t\t\t  QB_LOG_FILTER_FUNCTION_REGEX, \"log_it_please\", LOG_WARNING);\n\n\t/*\n\t * test filtering by function\n\t */\n\tqb_log_filter_ctl(t, QB_LOG_FILTER_CLEAR_ALL,\n\t\t\t  QB_LOG_FILTER_FILE, \"*\", LOG_TRACE);\n\tqb_log_filter_ctl(t, QB_LOG_FILTER_ADD,\n\t\t\t  QB_LOG_FILTER_FUNCTION, \"log_it_please\", LOG_WARNING);\n\n\tnum_msgs = 0;\n\tqb_log(LOG_ERR, \"try if you: log_it_please()\");\n\tlog_it_please();\n\tck_assert_int_eq(num_msgs, 3);\n\n\tqb_log_filter_ctl(t, QB_LOG_FILTER_REMOVE,\n\t\t\t  QB_LOG_FILTER_FUNCTION, \"log_it_please\", LOG_WARNING);\n\tqb_log_filter_ctl(t, QB_LOG_FILTER_ADD,\n\t\t\t  QB_LOG_FILTER_FUNCTION, __func__, LOG_DEBUG);\n\n\tnum_msgs = 0;\n\tlog_it_please();\n\tck_assert_int_eq(num_msgs, 0);\n\tqb_log(LOG_DEBUG, \"try if you: log_it_please()\");\n\tck_assert_int_eq(num_msgs, 1);\n\n\tqb_log_filter_ctl(t, QB_LOG_FILTER_CLEAR_ALL,\n\t\t\t  QB_LOG_FILTER_FILE, \"*\", LOG_TRACE);\n\tqb_log_filter_ctl(t, QB_LOG_FILTER_ADD,\n\t\t\t  QB_LOG_FILTER_FUNCTION,\n\t\t\t  \"log_also,log_and_this_too\",\n\t\t\t  LOG_DEBUG);\n\tnum_msgs = 0;\n\tlog_also();\n\tlog_and_this_too();\n\tck_assert_int_eq(num_msgs, 2);\n\n\tqb_log_filter_ctl(t, QB_LOG_FILTER_CLEAR_ALL,\n\t\t\t  QB_LOG_FILTER_FILE, \"*\", LOG_TRACE);\n\tqb_log_filter_ctl(t, QB_LOG_FILTER_ADD,\n\t\t\t  QB_LOG_FILTER_FILE, \"fakefile.c,\"__FILE__\",otherfakefile\", LOG_DEBUG);\n\t/*\n\t * make sure we can pass in a null filename or function name.\n\t */\n\tqb_log_from_external_source(__func__, NULL, \"%s\", LOG_INFO,\n\t\t\t\t    __LINE__, 0, \"null filename\");\n\tqb_log_from_external_source(NULL, __FILE__, \"%s\", LOG_INFO,\n\t\t\t\t    __LINE__, 0, \"null function\");\n\n\t/* check same file/lineno logs with different formats work\n\t */\n\tnum_msgs = 0;\n\tqb_log_from_external_source(__func__, __FILE__, \"%s bla\", LOG_INFO,\n\t\t\t\t    56, 0, \"filename/lineno\");\n\tck_assert_int_eq(num_msgs, 1);\n\tck_assert_str_eq(test_buf, \"filename/lineno bla\");\n\n\tnum_msgs = 0;\n\tqb_log_from_external_source(__func__, __FILE__, \"%s\", LOG_INFO,\n\t\t\t\t    56, 0, \"same filename/lineno\");\n\tck_assert_int_eq(num_msgs, 1);\n\tck_assert_str_eq(test_buf, \"same filename/lineno\");\n\n\t/* check filtering works on same file/lineno but different\n\t * log level.\n\t */\n\tqb_log_filter_ctl(t, QB_LOG_FILTER_CLEAR_ALL,\n\t\t\t  QB_LOG_FILTER_FILE, \"*\", LOG_TRACE);\n\tqb_log_filter_ctl(t, QB_LOG_FILTER_ADD,\n\t\t\t  QB_LOG_FILTER_FILE, __FILE__, LOG_INFO);\n\n\tnum_msgs = 0;\n\tqb_log_from_external_source(__func__, __FILE__,\n\t\t\t\t    \"same filename/lineno, this level %d\",\n\t\t\t\t    LOG_INFO, 56, 0, LOG_INFO);\n\tck_assert_int_eq(num_msgs, 1);\n\tck_assert_str_eq(test_buf, \"same filename/lineno, this level 6\");\n\n\tnum_msgs = 0;\n\tqb_log_from_external_source(__func__, __FILE__,\n\t\t\t\t    \"same filename/lineno, this level %d\",\n\t\t\t\t    LOG_DEBUG, 56, 0, LOG_DEBUG);\n\tck_assert_int_eq(num_msgs, 0);\n}\nEND_TEST\n\nstatic const char *_test_tags_stringify(uint32_t tags)\n{\n\tif (tags == 1) {\n\t\treturn \"ONE\";\n\t} else if (tags == 8) {\n\t\treturn \"ATE\";\n\t} else {\n\t\treturn \"ANY\";\n\t}\n}\n\nSTART_TEST(test_log_format)\n{\n\tint32_t t;\n\t/* following size/length related equation holds in the context of use:\n\t   strlen(cmp_str) = strlen(host_str) + X; X ~ 20 < sizeof(host_str) */\n\tchar host_str[256];\n\tchar cmp_str[2 * sizeof(host_str)];\n\n\tqb_log_init(\"test\", LOG_USER, LOG_DEBUG);\n\tqb_log_ctl(QB_LOG_SYSLOG, QB_LOG_CONF_ENABLED, QB_FALSE);\n\n\tt = qb_log_custom_open(_test_logger, NULL, NULL, NULL);\n\tqb_log_ctl(t, QB_LOG_CONF_ENABLED, QB_TRUE);\n\n\tqb_log_filter_ctl(t, QB_LOG_FILTER_ADD,\n\t\t\t  QB_LOG_FILTER_FILE, \"*\", LOG_DEBUG);\n\tqb_log_format_set(t, \"%p %f %b\");\n\n\tqb_log(LOG_DEBUG, \"Angus\");\n\tck_assert_str_eq(test_buf, \"debug check_log.c Angus\");\n\tqb_log(LOG_INFO, \"Angus\");\n\tck_assert_str_eq(test_buf, \"info check_log.c Angus\");\n\tqb_log(LOG_NOTICE, \"Angus\");\n\tck_assert_str_eq(test_buf, \"notice check_log.c Angus\");\n\tqb_log(LOG_WARNING, \"Angus\");\n\tck_assert_str_eq(test_buf, \"warning check_log.c Angus\");\n\tqb_log(LOG_ERR, \"Angus\");\n\tck_assert_str_eq(test_buf, \"error check_log.c Angus\");\n\tqb_log(LOG_CRIT, \"Angus\");\n\tck_assert_str_eq(test_buf, \"crit check_log.c Angus\");\n\tqb_log(LOG_ALERT, \"Angus\");\n\tck_assert_str_eq(test_buf, \"alert check_log.c Angus\");\n\tqb_log(LOG_EMERG, \"Angus\");\n\tck_assert_str_eq(test_buf, \"emerg check_log.c Angus\");\n\n\tqb_log_tags_stringify_fn_set(_test_tags_stringify);\n\tqb_log_format_set(t, \"%g %b\");\n\n\tqb_logt(LOG_INFO, 0, \"Angus\");\n\tck_assert_str_eq(test_buf, \"ANY Angus\");\n\tqb_logt(LOG_INFO, 1, \"Angus\");\n\tck_assert_str_eq(test_buf, \"ONE Angus\");\n\tqb_logt(LOG_INFO, 5, \"Angus\");\n\tck_assert_str_eq(test_buf, \"ANY Angus\");\n\tqb_logt(LOG_INFO, 8, \"Angus\");\n\tck_assert_str_eq(test_buf, \"ATE Angus\");\n\n\tqb_log_format_set(t, \"%-15f %b\");\n\tqb_log(LOG_WARNING, \"Andrew\");\n\tck_assert_str_eq(test_buf, \"    check_log.c Andrew\");\n\n\tqb_log_tags_stringify_fn_set(NULL);\n\n\tgethostname(host_str, sizeof(host_str));\n\thost_str[sizeof(host_str) - 1] = '\\0';\n\n\tqb_log_format_set(t, \"%P %H %N %b\");\n\tqb_log(LOG_INFO, \"Angus\");\n\tsnprintf(cmp_str, sizeof(cmp_str), \"%d %s test Angus\", getpid(),\n\t\t host_str);\n\tck_assert_str_eq(test_buf, cmp_str);\n\n\tqb_log_format_set(t, \"%3N %H %P %b\");\n\tqb_log(LOG_INFO, \"Angus\");\n\tsnprintf(cmp_str, sizeof(cmp_str), \"tes %s %d Angus\", host_str,\n\t\t getpid());\n\tck_assert_str_eq(test_buf, cmp_str);\n}\nEND_TEST\n\nSTART_TEST(test_log_enable)\n{\n\tint32_t t;\n\tint32_t state;\n\n\tqb_log_init(\"test\", LOG_USER, LOG_DEBUG);\n\tstate = qb_log_ctl(QB_LOG_SYSLOG, QB_LOG_CONF_STATE_GET, 0);\n\tck_assert_int_eq(state, QB_LOG_STATE_ENABLED);\n\tstate = qb_log_ctl(QB_LOG_STDERR, QB_LOG_CONF_STATE_GET, 0);\n\tck_assert_int_eq(state, QB_LOG_STATE_DISABLED);\n\tstate = qb_log_ctl(QB_LOG_BLACKBOX, QB_LOG_CONF_STATE_GET, 0);\n\tck_assert_int_eq(state, QB_LOG_STATE_DISABLED);\n\n\tqb_log_ctl(QB_LOG_SYSLOG, QB_LOG_CONF_ENABLED, QB_FALSE);\n\tstate = qb_log_ctl(QB_LOG_SYSLOG, QB_LOG_CONF_STATE_GET, 0);\n\tck_assert_int_eq(state, QB_LOG_STATE_DISABLED);\n\n\tt = qb_log_custom_open(_test_logger, NULL, NULL, NULL);\n\tqb_log_ctl(t, QB_LOG_CONF_ENABLED, QB_TRUE);\n\n\tqb_log_filter_ctl(t, QB_LOG_FILTER_ADD,\n\t\t\t  QB_LOG_FILTER_FILE, \"*\", LOG_DEBUG);\n\tqb_log_format_set(t, \"%b\");\n\n\tqb_log(LOG_DEBUG, \"Hello\");\n\tck_assert_str_eq(test_buf, \"Hello\");\n\n\tnum_msgs = 0;\n\tqb_log_ctl(t, QB_LOG_CONF_ENABLED, QB_FALSE);\n\tqb_log(LOG_DEBUG, \"Goodbye\");\n\tck_assert_int_eq(num_msgs, 0);\n\tqb_log_ctl(t, QB_LOG_CONF_ENABLED, QB_TRUE);\n\tqb_log(LOG_DEBUG, \"Hello again\");\n\tck_assert_int_eq(num_msgs, 1);\n\tck_assert_str_eq(test_buf, \"Hello again\");\n}\nEND_TEST\n\n#define ITERATIONS 100000\nstatic void *thr_send_logs_2(void *ctx)\n{\n\tint32_t i;\n\tprintf(\"%s\\n\", __func__);\n\n\tfor (i = 0; i < ITERATIONS; i++) {\n\t\tqb_log(LOG_INFO, \"bla bla\");\n\t\tqb_log(LOG_INFO, \"blue blue\");\n\t\tqb_log(LOG_INFO, \"bra bra\");\n\t\tqb_log(LOG_INFO, \"bro bro\");\n\t\tqb_log(LOG_INFO, \"brown brown\");\n\t\tqb_log(LOG_INFO, \"booo booo\");\n\t\tqb_log(LOG_INFO, \"bogus bogus\");\n\t\tqb_log(LOG_INFO, \"bungu bungu\");\n\t}\n\treturn (NULL);\n}\n\nstatic void *thr_send_logs_1(void *ctx)\n{\n\tint32_t i;\n\n\tprintf(\"%s\\n\", __func__);\n\tfor (i = 0; i < ITERATIONS; i++) {\n\t\tqb_log_from_external_source(__func__, __FILE__, \"%s\", LOG_INFO,\n\t\t\t\t\t    __LINE__, 0, \"foo soup\");\n\t\tqb_log_from_external_source(__func__, __FILE__, \"%s\", LOG_INFO,\n\t\t\t\t\t    __LINE__, 0, \"fungus soup\");\n\t\tqb_log_from_external_source(__func__, __FILE__, \"%s\", LOG_INFO,\n\t\t\t\t\t    __LINE__, 0, \"fruity soup\");\n\t\tqb_log_from_external_source(__func__, __FILE__, \"%s\", LOG_INFO,\n\t\t\t\t\t    __LINE__, 0, \"free soup\");\n\t\tqb_log_from_external_source(__func__, __FILE__, \"%s\", LOG_INFO,\n\t\t\t\t\t    __LINE__, 0, \"frot soup\");\n\t\tqb_log_from_external_source(__func__, __FILE__, \"%s\", LOG_INFO,\n\t\t\t\t\t    __LINE__, 0, \"fresh soup\");\n\t\tqb_log_from_external_source(__func__, __FILE__, \"%s\", LOG_INFO,\n\t\t\t\t\t    __LINE__, 0, \"fattening soup\");\n\n\t}\n\treturn (NULL);\n}\n\n#define THREADS 4\nSTART_TEST(test_log_threads)\n{\n\tpthread_t threads[THREADS];\n\tpthread_attr_t thread_attr[THREADS];\n\tint32_t i;\n\tint32_t rc;\n\tint32_t lf;\n\tvoid *retval;\n\n\tqb_log_init(\"test\", LOG_USER, LOG_DEBUG);\n\tlf = qb_log_file_open(\"threads.log\");\n\trc = qb_log_filter_ctl(lf, QB_LOG_FILTER_ADD, QB_LOG_FILTER_FILE,\n\t\t\t\t\t   __FILE__, LOG_DEBUG);\n\tck_assert_int_eq(rc, 0);\n\tqb_log_format_set(lf, \"[%p] [%l] %b\");\n\trc = qb_log_ctl(lf, QB_LOG_CONF_ENABLED, QB_TRUE);\n\tck_assert_int_eq(rc, 0);\n\trc = qb_log_ctl(QB_LOG_SYSLOG, QB_LOG_CONF_ENABLED, QB_FALSE);\n\tck_assert_int_eq(rc, 0);\n\n\tfor (i = 0; i < THREADS/2; i++) {\n\t\tpthread_attr_init(&thread_attr[i]);\n\n\t\tpthread_attr_setdetachstate(&thread_attr[i],\n\t\t\t\t\t    PTHREAD_CREATE_JOINABLE);\n\t\tpthread_create(&threads[i], &thread_attr[i],\n\t\t\t       thr_send_logs_1, NULL);\n\t}\n\tfor (i = THREADS/2; i < THREADS; i++) {\n\t\tpthread_attr_init(&thread_attr[i]);\n\n\t\tpthread_attr_setdetachstate(&thread_attr[i],\n\t\t\t\t\t    PTHREAD_CREATE_JOINABLE);\n\t\tpthread_create(&threads[i], &thread_attr[i],\n\t\t\t       thr_send_logs_2, NULL);\n\t}\n\tfor (i = 0; i < THREADS; i++) {\n\t\tpthread_join(threads[i], &retval);\n\t}\n\n}\nEND_TEST\n\nSTART_TEST(test_log_long_msg)\n{\n\tint lpc;\n\tint rc;\n\tint i, max = 1000;\n\tchar *buffer = calloc(1, max);\n\n\tqb_log_init(\"test\", LOG_USER, LOG_DEBUG);\n\trc = qb_log_ctl(QB_LOG_SYSLOG, QB_LOG_CONF_ENABLED, QB_FALSE);\n\tck_assert_int_eq(rc, 0);\n\trc = qb_log_ctl(QB_LOG_BLACKBOX, QB_LOG_CONF_SIZE, 1024);\n\tck_assert_int_eq(rc, 0);\n\trc = qb_log_ctl(QB_LOG_BLACKBOX, QB_LOG_CONF_ENABLED, QB_TRUE);\n\tck_assert_int_eq(rc, 0);\n\trc = qb_log_filter_ctl(QB_LOG_BLACKBOX, QB_LOG_FILTER_ADD,\n\t\t\t  QB_LOG_FILTER_FILE, \"*\", LOG_TRACE);\n\tck_assert_int_eq(rc, 0);\n\n\tfor (lpc = 500; lpc < max; lpc++) {\n\t\tlpc++;\n\t\tfor(i = 0; i < max; i++) {\n\t\t\tbuffer[i] = 'a' + (i % 10);\n\t\t}\n\t\tbuffer[lpc%600] = 0;\n\t\tqb_log(LOG_INFO, \"Message %d %d - %s\", lpc, lpc%600, buffer);\n\t}\n\n        rc = qb_log_blackbox_write_to_file(\"blackbox.dump\");\n\tck_assert_int_gt(rc, 0);\n        rc = qb_log_blackbox_print_from_file(\"blackbox.dump\");\n\tck_assert_int_le(rc, 0);\n\tunlink(\"blackbox.dump\");\n\tqb_log_fini();\n}\nEND_TEST\n\nSTART_TEST(test_threaded_logging)\n{\n\tint32_t t;\n\tint32_t rc;\n\n\tqb_log_init(\"test\", LOG_USER, LOG_EMERG);\n\tqb_log_ctl(QB_LOG_SYSLOG, QB_LOG_CONF_ENABLED, QB_FALSE);\n\n\tt = qb_log_custom_open(_test_logger, NULL, NULL, NULL);\n\trc = qb_log_filter_ctl(t, QB_LOG_FILTER_ADD,\n\t\t\t       QB_LOG_FILTER_FILE, \"*\", LOG_INFO);\n\tck_assert_int_eq(rc, 0);\n\tqb_log_format_set(t, \"%b\");\n\trc = qb_log_ctl(t, QB_LOG_CONF_ENABLED, QB_TRUE);\n\tck_assert_int_eq(rc, 0);\n\trc = qb_log_ctl(t, QB_LOG_CONF_THREADED, QB_TRUE);\n\tck_assert_int_eq(rc, 0);\n\tqb_log_thread_start();\n\n\tmemset(test_buf, 0, sizeof(test_buf));\n\ttest_priority = 0;\n\tnum_msgs = 0;\n\n\tqb_log(LOG_INFO, \"Yoda how old are you? - %d\", __LINE__);\n\tqb_log(LOG_INFO, \"Yoda how old are you? - %d\", __LINE__);\n\tqb_log(LOG_INFO, \"Yoda how old are you? - %d\", __LINE__);\n\tqb_log(LOG_INFO, \"Yoda how old are you? - %d\", __LINE__);\n\tqb_log(LOG_INFO, \"Yoda how old are you? - %d\", __LINE__);\n\tqb_log(LOG_INFO, \"Yoda how old are you? - %d\", __LINE__);\n\tqb_log(LOG_INFO, \"Yoda how old are you? - %d\", __LINE__);\n\tqb_log(LOG_INFO, \"Yoda how old are you? - %d\", __LINE__);\n\tqb_log(LOG_INFO, \"Yoda how old are you? - %d\", __LINE__);\n\tqb_log(LOG_INFO, \"Yoda how old are you? - %d\", __LINE__);\n\n\tqb_log_fini();\n\n\tck_assert_int_eq(num_msgs, 10);\n}\nEND_TEST\n\n#ifdef HAVE_PTHREAD_SETSCHEDPARAM\nSTART_TEST(test_threaded_logging_bad_sched_params)\n{\n\tint32_t t;\n\tint32_t rc;\n\n\tqb_log_init(\"test\", LOG_USER, LOG_EMERG);\n\tqb_log_ctl(QB_LOG_SYSLOG, QB_LOG_CONF_ENABLED, QB_FALSE);\n\n\tt = qb_log_custom_open(_test_logger, NULL, NULL, NULL);\n\trc = qb_log_filter_ctl(t, QB_LOG_FILTER_ADD,\n\t\t\t       QB_LOG_FILTER_FILE, \"*\", LOG_INFO);\n\tck_assert_int_eq(rc, 0);\n\tqb_log_format_set(t, \"%b\");\n\trc = qb_log_ctl(t, QB_LOG_CONF_ENABLED, QB_TRUE);\n\tck_assert_int_eq(rc, 0);\n\trc = qb_log_ctl(t, QB_LOG_CONF_THREADED, QB_TRUE);\n\tck_assert_int_eq(rc, 0);\n\n#if defined(SCHED_RR)\n#define QB_SCHED SCHED_RR\n#elif defined(SCHED_FIFO)\n#define QB_SCHED SCHED_FIFO\n#else\n#define QB_SCHED (-1)\n#endif\n\trc = qb_log_thread_priority_set(QB_SCHED, -1);\n\tck_assert_int_eq(rc, 0);\n\n\trc = qb_log_thread_start();\n\tck_assert_int_ne(rc, 0);\n\tqb_log_fini();\n}\nEND_TEST\n#endif\n\nSTART_TEST(test_extended_information)\n{\n\tint32_t t;\n\tint32_t rc;\n\tint extended;\n\n\tqb_log_init(\"test\", LOG_USER, LOG_DEBUG);\n\tqb_log_ctl(QB_LOG_SYSLOG, QB_LOG_CONF_ENABLED, QB_FALSE);\n\n\tt = qb_log_custom_open(_test_logger, NULL, NULL, NULL);\n\t_ck_assert_int(t, >, QB_LOG_STDOUT);\n\tqb_log_format_set(t, \"%b\");\n\trc = qb_log_filter_fn_set(NULL);\n\tck_assert_int_eq(rc, 0);\n\trc = qb_log_filter_ctl(t, QB_LOG_FILTER_CLEAR_ALL, QB_LOG_FILTER_FILE,\n\t\t\t       \"*\", LOG_TRACE);\n\tck_assert_int_eq(rc, 0);\n\trc = qb_log_filter_ctl(t, QB_LOG_FILTER_CLEAR_ALL, QB_LOG_FILTER_FORMAT,\n\t\t\t       \"*\", LOG_TRACE);\n\tck_assert_int_eq(rc, 0);\n\trc = qb_log_filter_ctl(t, QB_LOG_FILTER_ADD, QB_LOG_FILTER_FORMAT,\n\t\t\t       \"*\", LOG_TRACE);\n\tck_assert_int_eq(rc, 0);\n\trc = qb_log_ctl(t, QB_LOG_CONF_ENABLED, QB_TRUE);\n\tck_assert_int_eq(rc, 0);\n\n\tfor (extended = QB_FALSE; extended <= QB_TRUE; ++extended) {\n\t\trc = qb_log_ctl(t, QB_LOG_CONF_EXTENDED, extended);\n\t\tck_assert_int_eq(rc, 0);\n\n\t\tnum_msgs = 0;\n\n\t\tmemset(test_buf, 0, sizeof(test_buf));\n\t\tqb_log(LOG_ERR, \"message with no extended information\");\n\t\tck_assert_str_eq(test_buf, \"message with no extended information\");\n\n\t\tmemset(test_buf, 0, sizeof(test_buf));\n\t\tqb_log(LOG_ERR, \"message with empty extended information \"QB_XS);\n\t\tck_assert_str_eq(test_buf, \"message with empty extended information \");\n\n\t\tmemset(test_buf, 0, sizeof(test_buf));\n\t\tqb_log(LOG_ERR, QB_XS\" message with only extended information\");\n\t\tck_assert_str_eq(test_buf, extended?\n\t\t\t\t \"| message with only extended information\" : \"\");\n\n\t\tmemset(test_buf, 0, sizeof(test_buf));\n\t\tqb_log(LOG_ERR, \"message with extended information \"QB_XS\" (namely this)\");\n\t\tck_assert_str_eq(test_buf, extended?\n\t\t\t\t \"message with extended information | (namely this)\"\n\t\t\t\t : \"message with extended information \");\n\n\t\tck_assert_int_eq(num_msgs, (extended? 4 : 3));\n\t}\n\tqb_log_fini();\n}\nEND_TEST\n\nstatic const char *tagtest_stringify_tag(uint32_t tag)\n{\n\tstatic char buf[32];\n\tsprintf(buf, \"%5\" PRIu32, tag);\n\treturn buf;\n}\n\nSTART_TEST(test_zero_tags)\n{\n\tint32_t rc;\n\tint32_t t;\n\n\tqb_log_init(\"test\", LOG_USER, LOG_EMERG);\n\tqb_log_ctl(QB_LOG_SYSLOG, QB_LOG_CONF_ENABLED, QB_FALSE);\n\n\tt = qb_log_custom_open(_test_logger, NULL, NULL, NULL);\n\trc = qb_log_filter_ctl(t, QB_LOG_FILTER_ADD,\n\t\t\t       QB_LOG_FILTER_FILE, \"*\", LOG_INFO);\n\tck_assert_int_eq(rc, 0);\n\n\tqb_log_format_set(t, \"[%g] %b\");\n\tqb_log_tags_stringify_fn_set(tagtest_stringify_tag);\n\trc = qb_log_ctl(t, QB_LOG_CONF_ENABLED, QB_TRUE);\n\tck_assert_int_eq(rc, 0);\n\n\tqb_log_filter_ctl(t, QB_LOG_FILTER_ADD,\n\t\t\t  QB_LOG_FILTER_FILE, \"*\", LOG_TRACE);\n\n\tqb_log_from_external_source(\"function\", \"filename\", \"%s: %d\", LOG_DEBUG, 356, 2, \"testlog\", 2);\n\tck_assert_str_eq(test_buf, \"[    2] testlog: 2\");\n\n\tqb_log_from_external_source(\"function\", \"filename\", \"%s: %d\", LOG_DEBUG, 356, 0, \"testlog\", 0);\n\tck_assert_str_eq(test_buf, \"[    2] testlog: 0\");\n\n\tqb_log_fini();\n\n\n}\nEND_TEST\n\n#ifdef USE_JOURNAL\nSTART_TEST(test_journal)\n{\n\tint rc;\n\tconst char *msg;\n\tsize_t len;\n\tpid_t log_pid;\n\tsd_journal *jnl;\n\tint count = 0;\n\tconst char *msgid=\"f77379a8490b408bbe5f6940505a777b\";\n\n\tqb_log_init(\"check_log\", LOG_USER, LOG_DEBUG);\n\tqb_log_ctl(QB_LOG_SYSLOG, QB_LOG_CONF_ENABLED, QB_TRUE);\n\trc = qb_log_ctl(QB_LOG_SYSLOG, QB_LOG_CONF_USE_JOURNAL, 1);\n\tck_assert_int_eq(rc, 0);\n\tqb_log2(msgid, LOG_ERR, \"Test message 1 from libqb\");\n\n\tqb_log_ctl(QB_LOG_BLACKBOX, QB_LOG_CONF_ENABLED, QB_TRUE);\n\trc = qb_log_ctl(QB_LOG_BLACKBOX, QB_LOG_CONF_USE_JOURNAL, 1);\n\tck_assert_int_eq(rc, -EINVAL);\n\tsleep(1);\n\n\t/* Check it reached the journal */\n\trc = sd_journal_open(&jnl, 0);\n\tck_assert_int_eq(rc, 0);\n\trc = sd_journal_seek_tail(jnl);\n\tck_assert_int_eq(rc, 0);\n\tSD_JOURNAL_FOREACH_BACKWARDS(jnl) {\n\t    rc = sd_journal_get_data(jnl, \"_PID\", (const void **)&msg, &len);\n\t    ck_assert_int_eq(rc, 0);\n\t    sscanf(msg, \"_PID=%d\", &log_pid);\n\t    fprintf(stderr, \"PID message = '%s' - pid = %d (pid=%d, parent=%d)\\n\", msg, log_pid, getpid(), getppid());\n\t    if (log_pid == getpid()) {\n\t        rc = sd_journal_get_data(jnl, \"MESSAGE\", (const void **)&msg, &len);\n\t\tck_assert_int_eq(rc, 0);\n\t        rc = sd_journal_get_data(jnl, \"MESSAGE_ID\", (const void **)&msg, &len);\n\t\tck_assert_int_eq(rc, 0);\n\t\tck_assert_str_eq(msg+11, msgid);\n\t\tbreak;\n\t    }\n\t    if (++count > 20) {\n\t\t    break;\n            }\n        }\n\tsd_journal_close(jnl);\n\tck_assert_int_lt(count, 20);\n}\nEND_TEST\n#else\nSTART_TEST(test_syslog)\n{\n\tint rc;\n\n\tqb_log_init(\"flip\", LOG_USER, LOG_INFO);\n\tqb_log_ctl(QB_LOG_SYSLOG, QB_LOG_CONF_ENABLED, QB_TRUE);\n\n\tqb_log(LOG_ERR, \"first as flip\");\n\tck_assert_int_eq(_syslog_opened, 1);\n\tck_assert_str_eq(_syslog_ident, \"flip\");\n\n\tqb_log_ctl2(QB_LOG_SYSLOG, QB_LOG_CONF_IDENT, QB_LOG_CTL2_S(\"flop\"));\n\tqb_log(LOG_ERR, \"second as flop\");\n\tck_assert_str_eq(_syslog_ident, \"flop\");\n\n\t/* This test only runs if USE_JOURNAL is undefined, so should always fail */\n\trc = qb_log_ctl(QB_LOG_SYSLOG, QB_LOG_CONF_USE_JOURNAL, 1);\n\tck_assert_int_eq(rc, -EOPNOTSUPP);\n\n\tqb_log_fini();\n}\nEND_TEST\n#endif\n\nstatic Suite *\nlog_suite(void)\n{\n\tTCase *tc;\n\tSuite *s = suite_create(\"logging\");\n\n\tadd_tcase(s, tc, test_va_serialize);\n\tadd_tcase(s, tc, test_log_stupid_inputs);\n\tadd_tcase(s, tc, test_log_basic);\n\tadd_tcase(s, tc, test_log_format);\n\tadd_tcase(s, tc, test_log_enable);\n\tadd_tcase(s, tc, test_log_threads, 360);\n\tadd_tcase(s, tc, test_log_long_msg);\n\tadd_tcase(s, tc, test_log_filter_fn);\n\tadd_tcase(s, tc, test_threaded_logging);\n\tadd_tcase(s, tc, test_line_length);\n\tadd_tcase(s, tc, test_file_logging);\n#ifdef HAVE_PTHREAD_SETSCHEDPARAM\n\tadd_tcase(s, tc, test_threaded_logging_bad_sched_params);\n#endif\n\tadd_tcase(s, tc, test_timestamps);\n\tadd_tcase(s, tc, test_extended_information);\n\tadd_tcase(s, tc, test_zero_tags);\n/*\n * You can still use syslog and journal in a normal application,\n * but the syslog_override code doesn't work when -lsystemd is present\n */\n#ifdef USE_JOURNAL\n        add_tcase(s, tc, test_journal);\n#else\n\tadd_tcase(s, tc, test_syslog);\n#endif\n\n\treturn s;\n}\n\nint32_t\nmain(void)\n{\n\tint32_t number_failed;\n\n\tSuite *s = log_suite();\n\tSRunner *sr = srunner_create(s);\n\n\tsrunner_run_all(sr, CK_VERBOSE);\n\tnumber_failed = srunner_ntests_failed(sr);\n\tsrunner_free(sr);\n\treturn (number_failed == 0) ? EXIT_SUCCESS : EXIT_FAILURE;\n}\n"], "filenames": ["lib/log_blackbox.c", "tests/check_log.c"], "buggy_code_start_loc": [113, 835], "buggy_code_end_loc": [115, 837], "fixing_code_start_loc": [113, 835], "fixing_code_end_loc": [115, 839], "type": "CWE-120", "message": "log_blackbox.c in libqb before 2.0.8 allows a buffer overflow via long log messages because the header size is not considered.", "other": {"cve": {"id": "CVE-2023-39976", "sourceIdentifier": "cve@mitre.org", "published": "2023-08-08T06:15:46.590", "lastModified": "2023-11-07T04:17:41.023", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "log_blackbox.c in libqb before 2.0.8 allows a buffer overflow via long log messages because the header size is not considered."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-120"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:clusterlabs:libqb:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.0.8", "matchCriteriaId": "6356D585-67AB-4E61-9DCB-50DD9662CED3"}]}]}], "references": [{"url": "https://github.com/ClusterLabs/libqb/commit/1bbaa929b77113532785c408dd1b41cd0521ffc8", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/ClusterLabs/libqb/compare/v2.0.7...v2.0.8", "source": "cve@mitre.org", "tags": ["Not Applicable"]}, {"url": "https://github.com/ClusterLabs/libqb/pull/490", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/KECNF7LFBPE57XSBT6EM7ACVMIBP63WH/", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/ClusterLabs/libqb/commit/1bbaa929b77113532785c408dd1b41cd0521ffc8"}}