{"buggy_code": ["<f:layout name=\"Default\" />\n\n<f:section name=\"Main\">\nVariables template from Singles.\n\n<!-- Simple variable accessing -->\nSimple variable: {foobar}\nSimple variable in array, numeric: {array.numeric.0}\nSimple variable in array, associative: {array.fixed}\n\n<!-- Casting variables to certain types -->\nA string with numbers in it: {types.aStringWithNumbers as integer}\nDitto, with type name stored in variable: {types.aStringWithNumbers as types.typeNameInteger}\nA comma-separated value iterated as array:\n<f:for each=\"{types.csv as array}\" as=\"arrayMember\">\t- {arrayMember}\n</f:for>\n<!-- Dynamic string: changing \"dynamic1\" to \"dynamic2\" reads other string -->\nString variable name with dynamic1 part: {stringwith{dynamic1}part}.\nString variable name with dynamic2 part: {stringwith{dynamic2}part}.\nOutput of variable whose name is stored in a variable: {{dynamicVariableName}}\n\n<!-- Dynamic array: changing \"dynanic1\" to \"dynamic2\" reads other array member -->\nArray member in $array[$dynamic1]: {array.{dynamic1}}\nArray member in $array[$dynamic2]: {array.{dynamic2}}\n\n<!-- Numerically prefixed variables -->\nDirect access of numeric prefixed variable: {123numericprefix}\n<f:alias map=\"{mappedNumericPrefix: 123numericprefix}\">Aliased access of numeric prefixed variable: {mappedNumericPrefix}</f:alias>\n\n<!-- Passing arguments to sections/partials -->\n<f:render section=\"Secondary\" arguments=\"{\n\tmyVariable: 'Nice string',\n\tarray: {\n\t\tbaz: 42,\n\t\tfoobar: '<b>Unescaped string</b>',\n\t\tprintf: 'Formatted string, value: %s',\n\t\txyz: '{\n\t\t\tfoobar: \\'Escaped sub-string\\'\n\t\t}'\n\t}\n}\"/>\n\n</f:section>\n\n<f:section name=\"Secondary\">\nReceived $array.foobar with value {array.foobar -> f:format.raw()} (same using \"value\" argument: {f:format.raw(value: array.foobar)})\nReceived $array.printf with formatted string {array.printf -> f:format.printf(arguments: {0: 'formatted'})}\nReceived $array.baz with value {array.baz}\nReceived $array.xyz.foobar with value {array.xyz.foobar}\nReceived $myVariable with value {myVariable}\n</f:section>\n", "<?php\nnamespace TYPO3Fluid\\Fluid\\Core\\Parser\\Interceptor;\n\n/*\n * This file belongs to the package \"TYPO3 Fluid\".\n * See LICENSE.txt that was shipped with this package.\n */\n\nuse TYPO3Fluid\\Fluid\\Core\\Parser\\InterceptorInterface;\nuse TYPO3Fluid\\Fluid\\Core\\Parser\\ParsingState;\nuse TYPO3Fluid\\Fluid\\Core\\Parser\\SyntaxTree\\EscapingNode;\nuse TYPO3Fluid\\Fluid\\Core\\Parser\\SyntaxTree\\NodeInterface;\nuse TYPO3Fluid\\Fluid\\Core\\Parser\\SyntaxTree\\ObjectAccessorNode;\nuse TYPO3Fluid\\Fluid\\Core\\Parser\\SyntaxTree\\ViewHelperNode;\n\n/**\n * An interceptor adding the \"Htmlspecialchars\" viewhelper to the suitable places.\n */\nclass Escape implements InterceptorInterface\n{\n\n    /**\n     * Is the interceptor enabled right now for child nodes?\n     *\n     * @var boolean\n     */\n    protected $childrenEscapingEnabled = true;\n\n    /**\n     * A stack of ViewHelperNodes which currently disable the interceptor.\n     * Needed to enable the interceptor again.\n     *\n     * @var NodeInterface[]\n     */\n    protected $viewHelperNodesWhichDisableTheInterceptor = [];\n\n    /**\n     * Adds a ViewHelper node using the Format\\HtmlspecialcharsViewHelper to the given node.\n     * If \"escapingInterceptorEnabled\" in the ViewHelper is FALSE, will disable itself inside the ViewHelpers body.\n     *\n     * @param NodeInterface $node\n     * @param integer $interceptorPosition One of the INTERCEPT_* constants for the current interception point\n     * @param ParsingState $parsingState the current parsing state. Not needed in this interceptor.\n     * @return NodeInterface\n     */\n    public function process(NodeInterface $node, $interceptorPosition, ParsingState $parsingState)\n    {\n        if ($interceptorPosition === InterceptorInterface::INTERCEPT_OPENING_VIEWHELPER) {\n            /** @var ViewHelperNode $node */\n            if (!$node->getUninitializedViewHelper()->isChildrenEscapingEnabled()) {\n                $this->childrenEscapingEnabled = false;\n                $this->viewHelperNodesWhichDisableTheInterceptor[] = $node;\n            }\n        } elseif ($interceptorPosition === InterceptorInterface::INTERCEPT_CLOSING_VIEWHELPER) {\n            if (end($this->viewHelperNodesWhichDisableTheInterceptor) === $node) {\n                array_pop($this->viewHelperNodesWhichDisableTheInterceptor);\n                if (count($this->viewHelperNodesWhichDisableTheInterceptor) === 0) {\n                    $this->childrenEscapingEnabled = true;\n                }\n            }\n            /** @var ViewHelperNode $node */\n            if ($this->childrenEscapingEnabled && $node->getUninitializedViewHelper()->isOutputEscapingEnabled()) {\n                $node = new EscapingNode($node);\n            }\n        } elseif ($this->childrenEscapingEnabled && $node instanceof ObjectAccessorNode) {\n            $node = new EscapingNode($node);\n        }\n        return $node;\n    }\n\n    /**\n     * This interceptor wants to hook into object accessor creation, and opening / closing ViewHelpers.\n     *\n     * @return array Array of INTERCEPT_* constants\n     */\n    public function getInterceptionPoints()\n    {\n        return [\n            InterceptorInterface::INTERCEPT_OPENING_VIEWHELPER,\n            InterceptorInterface::INTERCEPT_CLOSING_VIEWHELPER,\n            InterceptorInterface::INTERCEPT_OBJECTACCESSOR\n        ];\n    }\n}\n", "<?php\nnamespace TYPO3Fluid\\Fluid\\Core\\Parser;\n\n/*\n * This file belongs to the package \"TYPO3 Fluid\".\n * See LICENSE.txt that was shipped with this package.\n */\n\nuse TYPO3Fluid\\Fluid\\Core\\Parser\\SyntaxTree\\NodeInterface;\n\n/**\n * An interceptor interface. Interceptors are used in the parsing stage to change\n * the syntax tree of a template, e.g. by adding viewhelper nodes.\n */\ninterface InterceptorInterface\n{\n\n    const INTERCEPT_OPENING_VIEWHELPER = 1;\n    const INTERCEPT_CLOSING_VIEWHELPER = 2;\n    const INTERCEPT_TEXT = 3;\n    const INTERCEPT_OBJECTACCESSOR = 4;\n\n    /**\n     * The interceptor can process the given node at will and must return a node\n     * that will be used in place of the given node.\n     *\n     * @param NodeInterface $node\n     * @param integer $interceptorPosition One of the INTERCEPT_* constants for the current interception point\n     * @param ParsingState $parsingState the parsing state\n     * @return NodeInterface\n     */\n    public function process(NodeInterface $node, $interceptorPosition, ParsingState $parsingState);\n\n    /**\n     * The interceptor should define at which interception positions it wants to be called.\n     *\n     * @return array Array of INTERCEPT_* constants\n     */\n    public function getInterceptionPoints();\n}\n", "<?php\nnamespace TYPO3Fluid\\Fluid\\Core\\Parser;\n\n/*\n * This file belongs to the package \"TYPO3 Fluid\".\n * See LICENSE.txt that was shipped with this package.\n */\n\nuse TYPO3Fluid\\Fluid\\Core\\Compiler\\StopCompilingException;\nuse TYPO3Fluid\\Fluid\\Core\\Parser\\SyntaxTree\\ArrayNode;\nuse TYPO3Fluid\\Fluid\\Core\\Compiler\\UncompilableTemplateInterface;\nuse TYPO3Fluid\\Fluid\\Core\\Parser\\SyntaxTree\\Expression\\ExpressionException;\nuse TYPO3Fluid\\Fluid\\Core\\Parser\\SyntaxTree\\Expression\\ExpressionNodeInterface;\nuse TYPO3Fluid\\Fluid\\Core\\Parser\\SyntaxTree\\Expression\\ParseTimeEvaluatedExpressionNodeInterface;\nuse TYPO3Fluid\\Fluid\\Core\\Parser\\SyntaxTree\\NodeInterface;\nuse TYPO3Fluid\\Fluid\\Core\\Parser\\SyntaxTree\\NumericNode;\nuse TYPO3Fluid\\Fluid\\Core\\Parser\\SyntaxTree\\ObjectAccessorNode;\nuse TYPO3Fluid\\Fluid\\Core\\Parser\\SyntaxTree\\RootNode;\nuse TYPO3Fluid\\Fluid\\Core\\Parser\\SyntaxTree\\TextNode;\nuse TYPO3Fluid\\Fluid\\Core\\Parser\\SyntaxTree\\ViewHelperNode;\nuse TYPO3Fluid\\Fluid\\Core\\Rendering\\RenderingContextInterface;\n\n/**\n * Template parser building up an object syntax tree\n */\nclass TemplateParser\n{\n\n    /**\n     * The following two constants are used for tracking whether we are currently\n     * parsing ViewHelper arguments or not. This is used to parse arrays only as\n     * ViewHelper argument.\n     */\n    const CONTEXT_INSIDE_VIEWHELPER_ARGUMENTS = 1;\n    const CONTEXT_OUTSIDE_VIEWHELPER_ARGUMENTS = 2;\n\n    /**\n     * Whether or not the escaping interceptors are active\n     *\n     * @var boolean\n     */\n    protected $escapingEnabled = true;\n\n    /**\n     * @var Configuration\n     */\n    protected $configuration;\n\n    /**\n     * @var array\n     */\n    protected $settings;\n\n    /**\n     * @var RenderingContextInterface\n     */\n    protected $renderingContext;\n\n    /**\n     * @var integer\n     */\n    protected $pointerLineNumber = 1;\n\n    /**\n     * @var integer\n     */\n    protected $pointerLineCharacter = 1;\n\n    /**\n     * @var string\n     */\n    protected $pointerTemplateCode = null;\n\n    /**\n     * @var ParsedTemplateInterface[]\n     */\n    protected $parsedTemplates = [];\n\n    /**\n     * @param RenderingContextInterface $renderingContext\n     * @return void\n     */\n    public function setRenderingContext(RenderingContextInterface $renderingContext)\n    {\n        $this->renderingContext = $renderingContext;\n        $this->configuration = $renderingContext->buildParserConfiguration();\n    }\n\n    /**\n     * Returns an array of current line number, character in line and reference template code;\n     * for extraction when catching parser-related Exceptions during parsing.\n     *\n     * @return array\n     */\n    public function getCurrentParsingPointers()\n    {\n        return [$this->pointerLineNumber, $this->pointerLineCharacter, $this->pointerTemplateCode];\n    }\n\n    /**\n     * @return boolean\n     */\n    public function isEscapingEnabled()\n    {\n        return $this->escapingEnabled;\n    }\n\n    /**\n     * @param boolean $escapingEnabled\n     * @return void\n     */\n    public function setEscapingEnabled($escapingEnabled)\n    {\n        $this->escapingEnabled = (boolean) $escapingEnabled;\n    }\n\n    /**\n     * Parses a given template string and returns a parsed template object.\n     *\n     * The resulting ParsedTemplate can then be rendered by calling evaluate() on it.\n     *\n     * Normally, you should use a subclass of AbstractTemplateView instead of calling the\n     * TemplateParser directly.\n     *\n     * @param string $templateString The template to parse as a string\n     * @param string|null $templateIdentifier If the template has an identifying string it can be passed here to improve error reporting.\n     * @return ParsingState Parsed template\n     * @throws Exception\n     */\n    public function parse($templateString, $templateIdentifier = null)\n    {\n        if (!is_string($templateString)) {\n            throw new Exception('Parse requires a template string as argument, ' . gettype($templateString) . ' given.', 1224237899);\n        }\n        try {\n            $this->reset();\n\n            $templateString = $this->preProcessTemplateSource($templateString);\n\n            $splitTemplate = $this->splitTemplateAtDynamicTags($templateString);\n            $parsingState = $this->buildObjectTree($splitTemplate, self::CONTEXT_OUTSIDE_VIEWHELPER_ARGUMENTS);\n        } catch (Exception $error) {\n            throw $this->createParsingRelatedExceptionWithContext($error, $templateIdentifier);\n        }\n        $this->parsedTemplates[$templateIdentifier] = $parsingState;\n        return $parsingState;\n    }\n\n    /**\n     * @param \\Exception $error\n     * @param string $templateIdentifier\n     * @throws \\Exception\n     */\n    public function createParsingRelatedExceptionWithContext(\\Exception $error, $templateIdentifier)\n    {\n        list ($line, $character, $templateCode) = $this->getCurrentParsingPointers();\n        $exceptionClass = get_class($error);\n        return new $exceptionClass(\n            sprintf(\n                'Fluid parse error in template %s, line %d at character %d. Error: %s (error code %d). Template source chunk: %s',\n                $templateIdentifier,\n                $line,\n                $character,\n                $error->getMessage(),\n                $error->getCode(),\n                $templateCode\n            ),\n            $error->getCode(),\n            $error\n        );\n    }\n\n    /**\n     * @param string $templateIdentifier\n     * @param \\Closure $templateSourceClosure Closure which returns the template source if needed\n     * @return ParsedTemplateInterface\n     */\n    public function getOrParseAndStoreTemplate($templateIdentifier, $templateSourceClosure)\n    {\n        $compiler = $this->renderingContext->getTemplateCompiler();\n        if (isset($this->parsedTemplates[$templateIdentifier])) {\n            $parsedTemplate = $this->parsedTemplates[$templateIdentifier];\n        } elseif ($compiler->has($templateIdentifier)) {\n            $parsedTemplate = $compiler->get($templateIdentifier);\n            if ($parsedTemplate instanceof UncompilableTemplateInterface) {\n                $parsedTemplate = $this->parseTemplateSource($templateIdentifier, $templateSourceClosure);\n            }\n        } else {\n            $parsedTemplate = $this->parseTemplateSource($templateIdentifier, $templateSourceClosure);\n            try {\n                $compiler->store($templateIdentifier, $parsedTemplate);\n            } catch (StopCompilingException $stop) {\n                $this->renderingContext->getErrorHandler()->handleCompilerError($stop);\n                $parsedTemplate->setCompilable(false);\n                $compiler->store($templateIdentifier, $parsedTemplate);\n            }\n        }\n        return $parsedTemplate;\n    }\n\n    /**\n     * @param string $templateIdentifier\n     * @param \\Closure $templateSourceClosure\n     * @return ParsedTemplateInterface\n     */\n    protected function parseTemplateSource($templateIdentifier, $templateSourceClosure)\n    {\n        $parsedTemplate = $this->parse(\n            $templateSourceClosure($this, $this->renderingContext->getTemplatePaths()),\n            $templateIdentifier\n        );\n        $parsedTemplate->setIdentifier($templateIdentifier);\n        $this->parsedTemplates[$templateIdentifier] = $parsedTemplate;\n        return $parsedTemplate;\n    }\n\n    /**\n     * Pre-process the template source, making all registered TemplateProcessors\n     * do what they need to do with the template source before it is parsed.\n     *\n     * @param string $templateSource\n     * @return string\n     */\n    protected function preProcessTemplateSource($templateSource)\n    {\n        foreach ($this->renderingContext->getTemplateProcessors() as $templateProcessor) {\n            $templateSource = $templateProcessor->preProcessSource($templateSource);\n        }\n        return $templateSource;\n    }\n\n    /**\n     * Resets the parser to its default values.\n     *\n     * @return void\n     */\n    protected function reset()\n    {\n        $this->escapingEnabled = true;\n        $this->pointerLineNumber = 1;\n        $this->pointerLineCharacter = 1;\n    }\n\n    /**\n     * Splits the template string on all dynamic tags found.\n     *\n     * @param string $templateString Template string to split.\n     * @return array Splitted template\n     */\n    protected function splitTemplateAtDynamicTags($templateString)\n    {\n        return preg_split(Patterns::$SPLIT_PATTERN_TEMPLATE_DYNAMICTAGS, $templateString, -1, PREG_SPLIT_DELIM_CAPTURE | PREG_SPLIT_NO_EMPTY);\n    }\n\n    /**\n     * Build object tree from the split template\n     *\n     * @param array $splitTemplate The split template, so that every tag with a namespace declaration is already a seperate array element.\n     * @param integer $context one of the CONTEXT_* constants, defining whether we are inside or outside of ViewHelper arguments currently.\n     * @return ParsingState\n     * @throws Exception\n     */\n    protected function buildObjectTree(array $splitTemplate, $context)\n    {\n        $state = $this->getParsingState();\n        $previousBlock = '';\n\n        foreach ($splitTemplate as $templateElement) {\n            if ($context === self::CONTEXT_OUTSIDE_VIEWHELPER_ARGUMENTS) {\n                // Store a neat reference to the outermost chunk of Fluid template code.\n                // Don't store the reference if parsing ViewHelper arguments object tree;\n                // we want the reference code to contain *all* of the ViewHelper call.\n                $this->pointerTemplateCode = $templateElement;\n            }\n            $this->pointerLineNumber += substr_count($templateElement, PHP_EOL);\n            $this->pointerLineCharacter = strlen(substr($previousBlock, strrpos($previousBlock, PHP_EOL))) + 1;\n            $previousBlock = $templateElement;\n            $matchedVariables = [];\n\n            if (preg_match(Patterns::$SCAN_PATTERN_TEMPLATE_VIEWHELPERTAG, $templateElement, $matchedVariables) > 0) {\n                if ($this->openingViewHelperTagHandler(\n                    $state,\n                    $matchedVariables['NamespaceIdentifier'],\n                    $matchedVariables['MethodIdentifier'],\n                    $matchedVariables['Attributes'],\n                    ($matchedVariables['Selfclosing'] === '' ? false : true),\n                    $templateElement\n                )) {\n                    continue;\n                }\n            } elseif (preg_match(Patterns::$SCAN_PATTERN_TEMPLATE_CLOSINGVIEWHELPERTAG, $templateElement, $matchedVariables) > 0) {\n                if ($this->closingViewHelperTagHandler(\n                    $state,\n                    $matchedVariables['NamespaceIdentifier'],\n                    $matchedVariables['MethodIdentifier']\n                )) {\n                    continue;\n                }\n            }\n            $this->textAndShorthandSyntaxHandler($state, $templateElement, $context);\n        }\n\n        if ($state->countNodeStack() !== 1) {\n            throw new Exception(\n                'Not all tags were closed!',\n                1238169398\n            );\n        }\n        return $state;\n    }\n    /**\n     * Handles an opening or self-closing view helper tag.\n     *\n     * @param ParsingState $state Current parsing state\n     * @param string $namespaceIdentifier Namespace identifier - being looked up in $this->namespaces\n     * @param string $methodIdentifier Method identifier\n     * @param string $arguments Arguments string, not yet parsed\n     * @param boolean $selfclosing true, if the tag is a self-closing tag.\n     * @param string $templateElement The template code containing the ViewHelper call\n     * @return NodeInterface|null\n     */\n    protected function openingViewHelperTagHandler(ParsingState $state, $namespaceIdentifier, $methodIdentifier, $arguments, $selfclosing, $templateElement)\n    {\n        $viewHelperNode = $this->initializeViewHelperAndAddItToStack(\n            $state,\n            $namespaceIdentifier,\n            $methodIdentifier,\n            $this->parseArguments($arguments)\n        );\n\n        if ($viewHelperNode) {\n            $viewHelperNode->setPointerTemplateCode($templateElement);\n            if ($selfclosing === true) {\n                $state->popNodeFromStack();\n                $this->callInterceptor($viewHelperNode, InterceptorInterface::INTERCEPT_CLOSING_VIEWHELPER, $state);\n                // This needs to be called here because closingViewHelperTagHandler() is not triggered for self-closing tags\n                $state->getNodeFromStack()->addChildNode($viewHelperNode);\n            }\n        }\n\n        return $viewHelperNode;\n    }\n\n    /**\n     * Initialize the given ViewHelper and adds it to the current node and to\n     * the stack.\n     *\n     * @param ParsingState $state Current parsing state\n     * @param string $namespaceIdentifier Namespace identifier - being looked up in $this->namespaces\n     * @param string $methodIdentifier Method identifier\n     * @param array $argumentsObjectTree Arguments object tree\n     * @return null|NodeInterface An instance of ViewHelperNode if identity was valid - NULL if the namespace/identity was not registered\n     * @throws Exception\n     */\n    protected function initializeViewHelperAndAddItToStack(ParsingState $state, $namespaceIdentifier, $methodIdentifier, $argumentsObjectTree)\n    {\n        $viewHelperResolver = $this->renderingContext->getViewHelperResolver();\n        if (!$viewHelperResolver->isNamespaceValid($namespaceIdentifier)) {\n            return null;\n        }\n        try {\n            $currentViewHelperNode = new ViewHelperNode(\n                $this->renderingContext,\n                $namespaceIdentifier,\n                $methodIdentifier,\n                $argumentsObjectTree,\n                $state\n            );\n\n            $this->callInterceptor($currentViewHelperNode, InterceptorInterface::INTERCEPT_OPENING_VIEWHELPER, $state);\n            $viewHelper = $currentViewHelperNode->getUninitializedViewHelper();\n            $viewHelper::postParseEvent($currentViewHelperNode, $argumentsObjectTree, $state->getVariableContainer());\n            $state->pushNodeToStack($currentViewHelperNode);\n            return $currentViewHelperNode;\n        } catch (\\TYPO3Fluid\\Fluid\\Core\\ViewHelper\\Exception $error) {\n            $this->textHandler(\n                $state,\n                $this->renderingContext->getErrorHandler()->handleViewHelperError($error)\n            );\n        } catch (Exception $error) {\n            $this->textHandler(\n                $state,\n                $this->renderingContext->getErrorHandler()->handleParserError($error)\n            );\n        }\n        return null;\n    }\n\n    /**\n     * Handles a closing view helper tag\n     *\n     * @param ParsingState $state The current parsing state\n     * @param string $namespaceIdentifier Namespace identifier for the closing tag.\n     * @param string $methodIdentifier Method identifier.\n     * @return boolean whether the viewHelper was found and added to the stack or not\n     * @throws Exception\n     */\n    protected function closingViewHelperTagHandler(ParsingState $state, $namespaceIdentifier, $methodIdentifier)\n    {\n        $viewHelperResolver = $this->renderingContext->getViewHelperResolver();\n        if (!$viewHelperResolver->isNamespaceValid($namespaceIdentifier)) {\n            return false;\n        }\n        $lastStackElement = $state->popNodeFromStack();\n        if (!($lastStackElement instanceof ViewHelperNode)) {\n            throw new Exception('You closed a templating tag which you never opened!', 1224485838);\n        }\n        $actualViewHelperClassName = $viewHelperResolver->resolveViewHelperClassName($namespaceIdentifier, $methodIdentifier);\n        $expectedViewHelperClassName = $lastStackElement->getViewHelperClassName();\n        if ($actualViewHelperClassName !== $expectedViewHelperClassName) {\n            throw new Exception(\n                'Templating tags not properly nested. Expected: ' . $expectedViewHelperClassName . '; Actual: ' .\n                $actualViewHelperClassName,\n                1224485398\n            );\n        }\n        $this->callInterceptor($lastStackElement, InterceptorInterface::INTERCEPT_CLOSING_VIEWHELPER, $state);\n        $state->getNodeFromStack()->addChildNode($lastStackElement);\n\n        return true;\n    }\n\n    /**\n     * Handles the appearance of an object accessor (like {posts.author.email}).\n     * Creates a new instance of \\TYPO3Fluid\\Fluid\\ObjectAccessorNode.\n     *\n     * Handles ViewHelpers as well which are in the shorthand syntax.\n     *\n     * @param ParsingState $state The current parsing state\n     * @param string $objectAccessorString String which identifies which objects to fetch\n     * @param string $delimiter\n     * @param string $viewHelperString\n     * @param string $additionalViewHelpersString\n     * @return void\n     */\n    protected function objectAccessorHandler(ParsingState $state, $objectAccessorString, $delimiter, $viewHelperString, $additionalViewHelpersString)\n    {\n        $viewHelperString .= $additionalViewHelpersString;\n        $numberOfViewHelpers = 0;\n\n        // The following post-processing handles a case when there is only a ViewHelper, and no Object Accessor.\n        // Resolves bug #5107.\n        if (strlen($delimiter) === 0 && strlen($viewHelperString) > 0) {\n            $viewHelperString = $objectAccessorString . $viewHelperString;\n            $objectAccessorString = '';\n        }\n\n        // ViewHelpers\n        $matches = [];\n        if (strlen($viewHelperString) > 0 && preg_match_all(Patterns::$SPLIT_PATTERN_SHORTHANDSYNTAX_VIEWHELPER, $viewHelperString, $matches, PREG_SET_ORDER) > 0) {\n            // The last ViewHelper has to be added first for correct chaining.\n            foreach (array_reverse($matches) as $singleMatch) {\n                if (strlen($singleMatch['ViewHelperArguments']) > 0) {\n                    $arguments = $this->recursiveArrayHandler($singleMatch['ViewHelperArguments']);\n                } else {\n                    $arguments = [];\n                }\n                $viewHelperNode = $this->initializeViewHelperAndAddItToStack($state, $singleMatch['NamespaceIdentifier'], $singleMatch['MethodIdentifier'], $arguments);\n                if ($viewHelperNode) {\n                    $numberOfViewHelpers++;\n                }\n            }\n        }\n\n        // Object Accessor\n        if (strlen($objectAccessorString) > 0) {\n            $node = new ObjectAccessorNode($objectAccessorString);\n            $this->callInterceptor($node, InterceptorInterface::INTERCEPT_OBJECTACCESSOR, $state);\n            $state->getNodeFromStack()->addChildNode($node);\n        }\n\n        // Close ViewHelper Tags if needed.\n        for ($i = 0; $i < $numberOfViewHelpers; $i++) {\n            $node = $state->popNodeFromStack();\n            $this->callInterceptor($node, InterceptorInterface::INTERCEPT_CLOSING_VIEWHELPER, $state);\n            $state->getNodeFromStack()->addChildNode($node);\n        }\n    }\n\n    /**\n     * Call all interceptors registered for a given interception point.\n     *\n     * @param NodeInterface $node The syntax tree node which can be modified by the interceptors.\n     * @param integer $interceptionPoint the interception point. One of the \\TYPO3Fluid\\Fluid\\Core\\Parser\\InterceptorInterface::INTERCEPT_* constants.\n     * @param ParsingState $state the parsing state\n     * @return void\n     */\n    protected function callInterceptor(NodeInterface & $node, $interceptionPoint, ParsingState $state)\n    {\n        if ($this->configuration === null) {\n            return;\n        }\n        if ($this->escapingEnabled) {\n            /** @var $interceptor InterceptorInterface */\n            foreach ($this->configuration->getEscapingInterceptors($interceptionPoint) as $interceptor) {\n                $node = $interceptor->process($node, $interceptionPoint, $state);\n            }\n        }\n\n        /** @var $interceptor InterceptorInterface */\n        foreach ($this->configuration->getInterceptors($interceptionPoint) as $interceptor) {\n            $node = $interceptor->process($node, $interceptionPoint, $state);\n        }\n    }\n\n    /**\n     * Parse arguments of a given tag, and build up the Arguments Object Tree\n     * for each argument.\n     * Returns an associative array, where the key is the name of the argument,\n     * and the value is a single Argument Object Tree.\n     *\n     * @param string $argumentsString All arguments as string\n     * @return array An associative array of objects, where the key is the argument name.\n     */\n    protected function parseArguments($argumentsString)\n    {\n        $argumentsObjectTree = [];\n        $matches = [];\n        if (preg_match_all(Patterns::$SPLIT_PATTERN_TAGARGUMENTS, $argumentsString, $matches, PREG_SET_ORDER) > 0) {\n            $escapingEnabledBackup = $this->escapingEnabled;\n            $this->escapingEnabled = false;\n            foreach ($matches as $singleMatch) {\n                $argument = $singleMatch['Argument'];\n                $value = $this->unquoteString($singleMatch['ValueQuoted']);\n                $argumentsObjectTree[$argument] = $this->buildArgumentObjectTree($value);\n            }\n            $this->escapingEnabled = $escapingEnabledBackup;\n        }\n        return $argumentsObjectTree;\n    }\n\n    /**\n     * Build up an argument object tree for the string in $argumentString.\n     * This builds up the tree for a single argument value.\n     *\n     * This method also does some performance optimizations, so in case\n     * no { or < is found, then we just return a TextNode.\n     *\n     * @param string $argumentString\n     * @return SyntaxTree\\NodeInterface the corresponding argument object tree.\n     */\n    protected function buildArgumentObjectTree($argumentString)\n    {\n        if (strpos($argumentString, '{') === false && strpos($argumentString, '<') === false) {\n            if (is_numeric($argumentString)) {\n                return new NumericNode($argumentString);\n            }\n            return new TextNode($argumentString);\n        }\n        $splitArgument = $this->splitTemplateAtDynamicTags($argumentString);\n        $rootNode = $this->buildObjectTree($splitArgument, self::CONTEXT_INSIDE_VIEWHELPER_ARGUMENTS)->getRootNode();\n        return $rootNode;\n    }\n\n    /**\n     * Removes escapings from a given argument string and trims the outermost\n     * quotes.\n     *\n     * This method is meant as a helper for regular expression results.\n     *\n     * @param string $quotedValue Value to unquote\n     * @return string Unquoted value\n     */\n    public function unquoteString($quotedValue)\n    {\n        $value = $quotedValue;\n        if ($value === '') {\n            return $value;\n        }\n        if ($quotedValue{0} === '\"') {\n            $value = str_replace('\\\\\"', '\"', preg_replace('/(^\"|\"$)/', '', $quotedValue));\n        } elseif ($quotedValue{0} === '\\'') {\n            $value = str_replace(\"\\\\'\", \"'\", preg_replace('/(^\\'|\\'$)/', '', $quotedValue));\n        }\n        return str_replace('\\\\\\\\', '\\\\', $value);\n    }\n\n    /**\n     * Handler for everything which is not a ViewHelperNode.\n     *\n     * This includes Text, array syntax, and object accessor syntax.\n     *\n     * @param ParsingState $state Current parsing state\n     * @param string $text Text to process\n     * @param integer $context one of the CONTEXT_* constants, defining whether we are inside or outside of ViewHelper arguments currently.\n     * @return void\n     */\n    protected function textAndShorthandSyntaxHandler(ParsingState $state, $text, $context)\n    {\n        $sections = preg_split(Patterns::$SPLIT_PATTERN_SHORTHANDSYNTAX, $text, -1, PREG_SPLIT_DELIM_CAPTURE | PREG_SPLIT_NO_EMPTY);\n        foreach ($sections as $section) {\n            $matchedVariables = [];\n            $expressionNode = null;\n            if (preg_match(Patterns::$SCAN_PATTERN_SHORTHANDSYNTAX_OBJECTACCESSORS, $section, $matchedVariables) > 0) {\n                $this->objectAccessorHandler(\n                    $state,\n                    $matchedVariables['Object'],\n                    $matchedVariables['Delimiter'],\n                    (isset($matchedVariables['ViewHelper']) ? $matchedVariables['ViewHelper'] : ''),\n                    (isset($matchedVariables['AdditionalViewHelpers']) ? $matchedVariables['AdditionalViewHelpers'] : '')\n                );\n            } elseif ($context === self::CONTEXT_INSIDE_VIEWHELPER_ARGUMENTS\n                && preg_match(Patterns::$SCAN_PATTERN_SHORTHANDSYNTAX_ARRAYS, $section, $matchedVariables) > 0\n            ) {\n                // We only match arrays if we are INSIDE viewhelper arguments\n                $this->arrayHandler($state, $this->recursiveArrayHandler($matchedVariables['Array']));\n            } else {\n                // We ask custom ExpressionNode instances from ViewHelperResolver\n                // if any match our expression:\n                foreach ($this->renderingContext->getExpressionNodeTypes() as $expressionNodeTypeClassName) {\n                    $detectionExpression = $expressionNodeTypeClassName::$detectionExpression;\n                    $matchedVariables = [];\n                    preg_match_all($detectionExpression, $section, $matchedVariables, PREG_SET_ORDER);\n                    if (is_array($matchedVariables) === true) {\n                        foreach ($matchedVariables as $matchedVariableSet) {\n                            $expressionStartPosition = strpos($section, $matchedVariableSet[0]);\n                            /** @var ExpressionNodeInterface $expressionNode */\n                            $expressionNode = new $expressionNodeTypeClassName($matchedVariableSet[0], $matchedVariableSet, $state);\n                            try {\n                                // Trigger initial parse-time evaluation to allow the node to manipulate the rendering context.\n                                if ($expressionNode instanceof ParseTimeEvaluatedExpressionNodeInterface) {\n                                    $expressionNode->evaluate($this->renderingContext);\n                                }\n\n                                if ($expressionStartPosition > 0) {\n                                    $state->getNodeFromStack()->addChildNode(new TextNode(substr($section, 0, $expressionStartPosition)));\n                                }\n                                $state->getNodeFromStack()->addChildNode($expressionNode);\n\n                                $expressionEndPosition = $expressionStartPosition + strlen($matchedVariableSet[0]);\n                                if ($expressionEndPosition < strlen($section)) {\n                                    $this->textAndShorthandSyntaxHandler($state, substr($section, $expressionEndPosition), $context);\n                                    break;\n                                }\n                            } catch (ExpressionException $error) {\n                                $this->textHandler(\n                                    $state,\n                                    $this->renderingContext->getErrorHandler()->handleExpressionError($error)\n                                );\n                            }\n                        }\n                    }\n                }\n\n                if (!$expressionNode) {\n                    // As fallback we simply render the expression back as template content.\n                    $this->textHandler($state, $section);\n                }\n            }\n        }\n    }\n\n    /**\n     * Handler for array syntax. This creates the array object recursively and\n     * adds it to the current node.\n     *\n     * @param ParsingState $state The current parsing state\n     * @param NodeInterface[] $arrayText The array as string.\n     * @return void\n     */\n    protected function arrayHandler(ParsingState $state, $arrayText)\n    {\n        $arrayNode = new ArrayNode($arrayText);\n        $state->getNodeFromStack()->addChildNode($arrayNode);\n    }\n\n    /**\n     * Recursive function which takes the string representation of an array and\n     * builds an object tree from it.\n     *\n     * Deals with the following value types:\n     * - Numbers (Integers and Floats)\n     * - Strings\n     * - Variables\n     * - sub-arrays\n     *\n     * @param string $arrayText Array text\n     * @return NodeInterface[] the array node built up\n     * @throws Exception\n     */\n    protected function recursiveArrayHandler($arrayText)\n    {\n        $matches = [];\n        $arrayToBuild = [];\n        if (preg_match_all(Patterns::$SPLIT_PATTERN_SHORTHANDSYNTAX_ARRAY_PARTS, $arrayText, $matches, PREG_SET_ORDER)) {\n            foreach ($matches as $singleMatch) {\n                $arrayKey = $this->unquoteString($singleMatch['Key']);\n                if (!empty($singleMatch['VariableIdentifier'])) {\n                    $arrayToBuild[$arrayKey] = new ObjectAccessorNode($singleMatch['VariableIdentifier']);\n                } elseif (array_key_exists('Number', $singleMatch) && (!empty($singleMatch['Number']) || $singleMatch['Number'] === '0')) {\n                    // Note: this method of casting picks \"int\" when value is a natural number and \"float\" if any decimals are found. See also NumericNode.\n                    $arrayToBuild[$arrayKey] = $singleMatch['Number'] + 0;\n                } elseif ((array_key_exists('QuotedString', $singleMatch) && !empty($singleMatch['QuotedString']))) {\n                    $argumentString = $this->unquoteString($singleMatch['QuotedString']);\n                    $arrayToBuild[$arrayKey] = $this->buildArgumentObjectTree($argumentString);\n                } elseif (array_key_exists('Subarray', $singleMatch) && !empty($singleMatch['Subarray'])) {\n                    $arrayToBuild[$arrayKey] = new ArrayNode($this->recursiveArrayHandler($singleMatch['Subarray']));\n                }\n            }\n        }\n        return $arrayToBuild;\n    }\n\n    /**\n     * Text node handler\n     *\n     * @param ParsingState $state\n     * @param string $text\n     * @return void\n     */\n    protected function textHandler(ParsingState $state, $text)\n    {\n        $node = new TextNode($text);\n        $this->callInterceptor($node, InterceptorInterface::INTERCEPT_TEXT, $state);\n        $state->getNodeFromStack()->addChildNode($node);\n    }\n\n    /**\n     * @return ParsingState\n     */\n    protected function getParsingState()\n    {\n        $rootNode = new RootNode();\n        $variableProvider = $this->renderingContext->getVariableProvider();\n        $state = new ParsingState();\n        $state->setRootNode($rootNode);\n        $state->pushNodeToStack($rootNode);\n        $state->setVariableProvider($variableProvider->getScopeCopy($variableProvider->getAll()));\n        return $state;\n    }\n}\n", "<?php\nnamespace FluidTYPO3Fluid\\Flux\\Tests\\Unit\\Functional;\n\n/*\n * This file belongs to the package \"TYPO3 Fluid\".\n * See LICENSE.txt that was shipped with this package.\n */\n\nuse org\\bovigo\\vfs\\vfsStream;\nuse TYPO3Fluid\\Fluid\\Tests\\BaseTestCase;\n\n/**\n * Class ExamplesTest\n */\nclass ExamplesTest extends BaseTestCase\n{\n\n    /**\n     * @return void\n     */\n    public static function setUpBeforeClass()\n    {\n        vfsStream::setup('fakecache/');\n    }\n\n    /**\n     * @dataProvider getExampleScriptTestValues\n     * @param string $script\n     * @param array $expectedOutputs\n     * @param string $expectedException\n     */\n    public function testExampleScriptFileWithoutCache($script, array $expectedOutputs, $expectedException = null)\n    {\n        if ($expectedException !== null) {\n            $this->setExpectedException($expectedException);\n        }\n        $this->runExampleScriptTest($script, $expectedOutputs, false);\n    }\n\n    /**\n     * @dataProvider getExampleScriptTestValues\n     * @param string $script\n     * @param array $expectedOutputs\n     * @param string $expectedException\n     */\n    public function testExampleScriptFileWithCache($script, array $expectedOutputs, $expectedException = null)\n    {\n        if ($expectedException !== null) {\n            $this->setExpectedException($expectedException);\n        }\n        $cache = vfsStream::url('fakecache/');\n        $this->runExampleScriptTest($script, $expectedOutputs, $cache);\n        $this->runExampleScriptTest($script, $expectedOutputs, $cache);\n    }\n\n    /**\n     * @param string $script\n     * @param array $expectedOutputs\n     * @param string $FLUID_CACHE_DIRECTORY\n     */\n    protected function runExampleScriptTest($script, array $expectedOutputs, $FLUID_CACHE_DIRECTORY)\n    {\n        $scriptFile = __DIR__ . '/../../examples/' . $script;\n        $self = $this;\n        $this->setOutputCallback(function ($output) use ($self, $expectedOutputs) {\n            foreach ($expectedOutputs as $expectedOutput) {\n                $self->assertContains($expectedOutput, $output);\n            }\n        });\n        include $scriptFile;\n        unset($FLUID_CACHE_DIRECTORY);\n    }\n\n    /**\n     * @return array\n     */\n    public function getExampleScriptTestValues()\n    {\n        return [\n            'example_conditions.php' => [\n                'example_conditions.php',\n                [\n                    'Standard ternary expression: The ternary expression is TRUE',\n                    'Negated ternary expression without then case: The ternary expression is FALSE',\n                    'Negated ternary expression: The ternary expression is FALSE',\n                    'Ternary expression without then case: The ternary expression is TRUE',\n                    '1 === TRUE',\n                    '(0) === FALSE',\n                    '(1) === TRUE',\n                    '0 && 0 === FALSE',\n                    '0 || 0 === FALSE',\n                    '1 && 0 === FALSE',\n                    '0 && 1 === FALSE',\n                    '1 || 0 === TRUE',\n                    '0 || 1 === TRUE',\n                    '0 || 1 && 0 === FALSE',\n                    '0 || 1 && 1 === TRUE',\n                    '$varfalse === FALSE',\n                    '$vartrue === TRUE',\n                    '!($vartrue) === FALSE',\n                    '$vararray1 == $vararray2 === FALSE',\n                    '($vararray1 == $vararray1) && $vartrue === TRUE',\n                    '$varfalse == $varfalse === TRUE',\n                    '$varfalse != $varfalse === FALSE',\n                    '$vararray1 == $vararray1 === TRUE',\n                    '\\'thisstring\\' != \\'thatstring\\' === TRUE'\n                ]\n            ],\n            'example_customresolving.php' => [\n                'example_customresolving.php',\n                [\n                    var_export(['foo' => 'bar'], true),\n                    var_export(['bar' => 'foo'], true),\n                ]\n            ],\n            'example_format.php' => [\n                'example_format.php',\n                [\n                    '\"layout\": \"Default.json\",',\n                    '\"foobar\": \"Variable foobar\"'\n                ]\n            ],\n            'example_layoutless.php' => [\n                'example_layoutless.php',\n                [\n                    'This section is rendered below',\n                    'This text is rendered because it is outside the section'\n                ]\n            ],\n            'example_math.php' => [\n                'example_math.php',\n                [\n                    'Expression: $numberten % 4 = 2',\n                    'Expression: 4 * $numberten = 40',\n                    'Expression: 4 / $numberten = 0.4',\n                    'Expression: $numberone / $numberten = 0.1',\n                    'Expression: 10 ^ $numberten = 10000000000'\n                ]\n            ],\n            'example_multiplepaths.php' => [\n                'example_multiplepaths.php',\n                [\n                    'Rendered via overridden Layout, section \"Main\":',\n                    'Overridden Default template.',\n                    'Value of \"foobar\": This is foobar.',\n                    'Contents of FirstPartial.html',\n                    'Overridden contents of SecondPartial.html',\n                ]\n            ],\n            'example_mvc.php' => [\n                'example_mvc.php',\n                [\n                    'I am the template belonging to the \"Default\" controller, action \"Default\".',\n                    'I am the template belonging to the \"Other\" controller, action \"Default\".',\n                    'I am the template belonging to the \"Other\" controller, action \"List\".',\n                    'Value of \"foobar\": MVC template.'\n                ]\n            ],\n            'example_namespaces.php' => [\n                'example_namespaces.php',\n                [\n                    'Namespaces template',\n                    '<invalid:vh>This tag will be shown</invalid:vh>'\n                ]\n            ],\n            'example_namespaceresolving.php' => [\n                'example_namespaceresolving.php',\n                [\n                    'NamespaceResolving template from Singles.',\n                    'Argument passed to CustomViewHelper:',\n                    '123'\n                ]\n            ],\n            'example_single.php' => [\n                'example_single.php',\n                [\n                    'Value of \"foobar\": Single template'\n                ]\n            ],\n            'example_escapingmodifier.php' => [\n                'example_escapingmodifier.php',\n                [\n                    'Value of \"html\": <strong>This is not escaped</strong>',\n                    'From partial: <strong>This is not escaped</strong>',\n                ]\n            ],\n            'example_structures.php' => [\n                'example_structures.php',\n                [\n                    'Tag: \"Dynamic\"',\n                    'Pass: \"Dynamic\"',\n                    'Pipe: \"Dynamic\"',\n                    'Pipe, multiple levels: \"Dynamic\"',\n                    'This section exists and is rendered: Valid section',\n                    'Expects no output because section name is invalid: ' . \"\\n\",\n                    'Dynamic section name: Dynamically suffixed section',\n                    'Bad dynamic section name, expects fallback: Just a section',\n                    'Will render: Just a section',\n                    'Will render, clause reversed: Just a section',\n                    'Will not render: ' . \"\\n\",\n                    'This `f:else` was rendered',\n                    'The value was \"3\"',\n                    'The unmatched value case triggered',\n                    'The \"b\" nested switch case was triggered'\n                ]\n            ],\n            'example_variables.php' => [\n                'example_variables.php',\n                [\n                    'Simple variable: string foo',\n                    'A string with numbers in it: 132',\n                    'Ditto, with type name stored in variable: 132',\n                    'A comma-separated value iterated as array:' . \"\\n\\t- one\\n\\t- two\",\n                    'String variable name with dynamic1 part: String using $dynamic1.',\n                    'String variable name with dynamic2 part: String using $dynamic2.',\n                    'Array member in $array[$dynamic1]: Dynamic key in $array[$dynamic1]',\n                    'Array member in $array[$dynamic2]: Dynamic key in $array[$dynamic2]',\n                    'Output of variable whose name is stored in a variable: string foo',\n                    'Direct access of numeric prefixed variable: Numeric prefixed variable',\n                    'Aliased access of numeric prefixed variable: Numeric prefixed variable',\n                    'Received $array.foobar with value <b>Unescaped string</b> (same using \"value\" argument: <b>Unescaped string</b>)',\n                    'Received $array.printf with formatted string Formatted string, value: formatted',\n                    'Received $array.baz with value 42',\n                    'Received $array.xyz.foobar with value Escaped sub-string',\n                    'Received $myVariable with value Nice string'\n                ]\n            ],\n            'example_variableprovider.php' => [\n                'example_variableprovider.php',\n                [\n                    'VariableProvider template from Singles.',\n                    'Random: random',\n                ]\n            ],\n            'example_dynamiclayout.php' => [\n                'example_dynamiclayout.php',\n                [\n                    'Rendered via DynamicLayout, section \"Main\":',\n                ]\n            ],\n            'example_cachestatic.php' => [\n                'example_cachestatic.php',\n                [\n                    'Cached as static text 1',\n                    'Cached as static text 2',\n                    'Cached as static text 3',\n                ]\n            ],\n            'example_passthrough.php' => [\n                'example_passthrough.php',\n                [\n                    '<f:format.raw>This does not get parsed; the source is passed through with Fluid markup</f:format.raw>'\n                ]\n            ],\n            'example_errorhandling.php' => [\n                'example_errorhandling.php',\n                [\n                    'View error: The Fluid template files',\n                    'Section rendering error: Section \"DoesNotExist\" does not exist. Section rendering is mandatory; \"optional\" is false.',\n                    'ViewHelper error: Undeclared arguments passed to ViewHelper TYPO3Fluid\\Fluid\\ViewHelpers\\IfViewHelper: notregistered. Valid arguments are: then, else, condition - Offending code: <f:if notregistered=\"1\" />',\n                    'Parser error: The ViewHelper \"<f:invalid>\" could not be resolved.',\n                    'Based on your spelling, the system would load the class \"TYPO3Fluid\\Fluid\\ViewHelpers\\InvalidViewHelper\", however this class does not exist. Offending code: <f:invalid />',\n                    'Invalid expression: Invalid target conversion type \"invalidtype\" specified in casting expression \"{foobar as invalidtype}\".',\n                ]\n            ]\n        ];\n    }\n}\n"], "fixing_code": ["<f:layout name=\"Default\" />\n\n<f:section name=\"Main\">\nVariables template from Singles.\n\n<!-- Simple variable accessing -->\nSimple variable: {foobar}\nSimple variable in array, numeric: {array.numeric.0}\nSimple variable in array, associative: {array.fixed}\n\n<!-- Casting variables to certain types -->\nA string with numbers in it: {types.aStringWithNumbers as integer}\nDitto, with type name stored in variable: {types.aStringWithNumbers as types.typeNameInteger}\nA comma-separated value iterated as array:\n<f:for each=\"{types.csv as array}\" as=\"arrayMember\">\t- {arrayMember}\n</f:for>\n<!-- Dynamic string: changing \"dynamic1\" to \"dynamic2\" reads other string -->\nString variable name with dynamic1 part: {stringwith{dynamic1}part}.\nString variable name with dynamic2 part: {stringwith{dynamic2}part}.\nOutput of variable whose name is stored in a variable: {{dynamicVariableName}}\n\n<!-- Dynamic array: changing \"dynanic1\" to \"dynamic2\" reads other array member -->\nArray member in $array[$dynamic1]: {array.{dynamic1}}\nArray member in $array[$dynamic2]: {array.{dynamic2}}\n\n<!-- Numerically prefixed variables -->\nDirect access of numeric prefixed variable: {123numericprefix}\n<f:alias map=\"{mappedNumericPrefix: 123numericprefix}\">Aliased access of numeric prefixed variable: {mappedNumericPrefix}</f:alias>\n\n<!-- Passing arguments to sections/partials -->\n<f:render section=\"Secondary\" arguments=\"{\n    ternaryCheck: 1,\n\tmyVariable: 'Nice string',\n\tarray: {\n\t\tbaz: 42,\n\t\tfoobar: '<b>Unescaped string</b>',\n\t\tprintf: 'Formatted string, value: %s',\n\t\txyz: '{\n\t\t\tfoobar: \\'Escaped sub-string\\'\n\t\t}'\n\t}\n}\"/>\n\n</f:section>\n\n<f:section name=\"Secondary\">\nEscaped ternary expression: {ternaryCheck ? array.foobar : array.foobar}\nEscaped cast expression: {array.foobar as string}\nReceived $array.foobar with value {array.foobar -> f:format.raw()} (same using \"value\" argument: {f:format.raw(value: array.foobar)})\nReceived $array.printf with formatted string {array.printf -> f:format.printf(arguments: {0: 'formatted'})}\nReceived $array.baz with value {array.baz}\nReceived $array.xyz.foobar with value {array.xyz.foobar}\nReceived $myVariable with value {myVariable}\n</f:section>\n", "<?php\nnamespace TYPO3Fluid\\Fluid\\Core\\Parser\\Interceptor;\n\n/*\n * This file belongs to the package \"TYPO3 Fluid\".\n * See LICENSE.txt that was shipped with this package.\n */\n\nuse TYPO3Fluid\\Fluid\\Core\\Parser\\InterceptorInterface;\nuse TYPO3Fluid\\Fluid\\Core\\Parser\\ParsingState;\nuse TYPO3Fluid\\Fluid\\Core\\Parser\\SyntaxTree\\EscapingNode;\nuse TYPO3Fluid\\Fluid\\Core\\Parser\\SyntaxTree\\Expression\\ExpressionNodeInterface;\nuse TYPO3Fluid\\Fluid\\Core\\Parser\\SyntaxTree\\NodeInterface;\nuse TYPO3Fluid\\Fluid\\Core\\Parser\\SyntaxTree\\ObjectAccessorNode;\nuse TYPO3Fluid\\Fluid\\Core\\Parser\\SyntaxTree\\ViewHelperNode;\n\n/**\n * An interceptor adding the \"Htmlspecialchars\" viewhelper to the suitable places.\n */\nclass Escape implements InterceptorInterface\n{\n\n    /**\n     * Is the interceptor enabled right now for child nodes?\n     *\n     * @var boolean\n     */\n    protected $childrenEscapingEnabled = true;\n\n    /**\n     * A stack of ViewHelperNodes which currently disable the interceptor.\n     * Needed to enable the interceptor again.\n     *\n     * @var NodeInterface[]\n     */\n    protected $viewHelperNodesWhichDisableTheInterceptor = [];\n\n    /**\n     * Adds a ViewHelper node using the Format\\HtmlspecialcharsViewHelper to the given node.\n     * If \"escapingInterceptorEnabled\" in the ViewHelper is FALSE, will disable itself inside the ViewHelpers body.\n     *\n     * @param NodeInterface $node\n     * @param integer $interceptorPosition One of the INTERCEPT_* constants for the current interception point\n     * @param ParsingState $parsingState the current parsing state. Not needed in this interceptor.\n     * @return NodeInterface\n     */\n    public function process(NodeInterface $node, $interceptorPosition, ParsingState $parsingState)\n    {\n        if ($interceptorPosition === InterceptorInterface::INTERCEPT_OPENING_VIEWHELPER) {\n            /** @var ViewHelperNode $node */\n            if (!$node->getUninitializedViewHelper()->isChildrenEscapingEnabled()) {\n                $this->childrenEscapingEnabled = false;\n                $this->viewHelperNodesWhichDisableTheInterceptor[] = $node;\n            }\n        } elseif ($interceptorPosition === InterceptorInterface::INTERCEPT_CLOSING_VIEWHELPER) {\n            if (end($this->viewHelperNodesWhichDisableTheInterceptor) === $node) {\n                array_pop($this->viewHelperNodesWhichDisableTheInterceptor);\n                if (count($this->viewHelperNodesWhichDisableTheInterceptor) === 0) {\n                    $this->childrenEscapingEnabled = true;\n                }\n            }\n            /** @var ViewHelperNode $node */\n            if ($this->childrenEscapingEnabled && $node->getUninitializedViewHelper()->isOutputEscapingEnabled()) {\n                $node = new EscapingNode($node);\n            }\n        } elseif ($this->childrenEscapingEnabled && ($node instanceof ObjectAccessorNode || $node instanceof ExpressionNodeInterface)) {\n            $node = new EscapingNode($node);\n        }\n        return $node;\n    }\n\n    /**\n     * This interceptor wants to hook into object accessor creation, and opening / closing ViewHelpers.\n     *\n     * @return array Array of INTERCEPT_* constants\n     */\n    public function getInterceptionPoints()\n    {\n        return [\n            InterceptorInterface::INTERCEPT_OPENING_VIEWHELPER,\n            InterceptorInterface::INTERCEPT_CLOSING_VIEWHELPER,\n            InterceptorInterface::INTERCEPT_OBJECTACCESSOR,\n            InterceptorInterface::INTERCEPT_EXPRESSION,\n        ];\n    }\n}\n", "<?php\nnamespace TYPO3Fluid\\Fluid\\Core\\Parser;\n\n/*\n * This file belongs to the package \"TYPO3 Fluid\".\n * See LICENSE.txt that was shipped with this package.\n */\n\nuse TYPO3Fluid\\Fluid\\Core\\Parser\\SyntaxTree\\NodeInterface;\n\n/**\n * An interceptor interface. Interceptors are used in the parsing stage to change\n * the syntax tree of a template, e.g. by adding viewhelper nodes.\n */\ninterface InterceptorInterface\n{\n\n    const INTERCEPT_OPENING_VIEWHELPER = 1;\n    const INTERCEPT_CLOSING_VIEWHELPER = 2;\n    const INTERCEPT_TEXT = 3;\n    const INTERCEPT_OBJECTACCESSOR = 4;\n    const INTERCEPT_EXPRESSION = 5;\n\n    /**\n     * The interceptor can process the given node at will and must return a node\n     * that will be used in place of the given node.\n     *\n     * @param NodeInterface $node\n     * @param integer $interceptorPosition One of the INTERCEPT_* constants for the current interception point\n     * @param ParsingState $parsingState the parsing state\n     * @return NodeInterface\n     */\n    public function process(NodeInterface $node, $interceptorPosition, ParsingState $parsingState);\n\n    /**\n     * The interceptor should define at which interception positions it wants to be called.\n     *\n     * @return array Array of INTERCEPT_* constants\n     */\n    public function getInterceptionPoints();\n}\n", "<?php\nnamespace TYPO3Fluid\\Fluid\\Core\\Parser;\n\n/*\n * This file belongs to the package \"TYPO3 Fluid\".\n * See LICENSE.txt that was shipped with this package.\n */\n\nuse TYPO3Fluid\\Fluid\\Core\\Compiler\\StopCompilingException;\nuse TYPO3Fluid\\Fluid\\Core\\Parser\\SyntaxTree\\ArrayNode;\nuse TYPO3Fluid\\Fluid\\Core\\Compiler\\UncompilableTemplateInterface;\nuse TYPO3Fluid\\Fluid\\Core\\Parser\\SyntaxTree\\Expression\\ExpressionException;\nuse TYPO3Fluid\\Fluid\\Core\\Parser\\SyntaxTree\\Expression\\ExpressionNodeInterface;\nuse TYPO3Fluid\\Fluid\\Core\\Parser\\SyntaxTree\\Expression\\ParseTimeEvaluatedExpressionNodeInterface;\nuse TYPO3Fluid\\Fluid\\Core\\Parser\\SyntaxTree\\NodeInterface;\nuse TYPO3Fluid\\Fluid\\Core\\Parser\\SyntaxTree\\NumericNode;\nuse TYPO3Fluid\\Fluid\\Core\\Parser\\SyntaxTree\\ObjectAccessorNode;\nuse TYPO3Fluid\\Fluid\\Core\\Parser\\SyntaxTree\\RootNode;\nuse TYPO3Fluid\\Fluid\\Core\\Parser\\SyntaxTree\\TextNode;\nuse TYPO3Fluid\\Fluid\\Core\\Parser\\SyntaxTree\\ViewHelperNode;\nuse TYPO3Fluid\\Fluid\\Core\\Rendering\\RenderingContextInterface;\n\n/**\n * Template parser building up an object syntax tree\n */\nclass TemplateParser\n{\n\n    /**\n     * The following two constants are used for tracking whether we are currently\n     * parsing ViewHelper arguments or not. This is used to parse arrays only as\n     * ViewHelper argument.\n     */\n    const CONTEXT_INSIDE_VIEWHELPER_ARGUMENTS = 1;\n    const CONTEXT_OUTSIDE_VIEWHELPER_ARGUMENTS = 2;\n\n    /**\n     * Whether or not the escaping interceptors are active\n     *\n     * @var boolean\n     */\n    protected $escapingEnabled = true;\n\n    /**\n     * @var Configuration\n     */\n    protected $configuration;\n\n    /**\n     * @var array\n     */\n    protected $settings;\n\n    /**\n     * @var RenderingContextInterface\n     */\n    protected $renderingContext;\n\n    /**\n     * @var integer\n     */\n    protected $pointerLineNumber = 1;\n\n    /**\n     * @var integer\n     */\n    protected $pointerLineCharacter = 1;\n\n    /**\n     * @var string\n     */\n    protected $pointerTemplateCode = null;\n\n    /**\n     * @var ParsedTemplateInterface[]\n     */\n    protected $parsedTemplates = [];\n\n    /**\n     * @param RenderingContextInterface $renderingContext\n     * @return void\n     */\n    public function setRenderingContext(RenderingContextInterface $renderingContext)\n    {\n        $this->renderingContext = $renderingContext;\n        $this->configuration = $renderingContext->buildParserConfiguration();\n    }\n\n    /**\n     * Returns an array of current line number, character in line and reference template code;\n     * for extraction when catching parser-related Exceptions during parsing.\n     *\n     * @return array\n     */\n    public function getCurrentParsingPointers()\n    {\n        return [$this->pointerLineNumber, $this->pointerLineCharacter, $this->pointerTemplateCode];\n    }\n\n    /**\n     * @return boolean\n     */\n    public function isEscapingEnabled()\n    {\n        return $this->escapingEnabled;\n    }\n\n    /**\n     * @param boolean $escapingEnabled\n     * @return void\n     */\n    public function setEscapingEnabled($escapingEnabled)\n    {\n        $this->escapingEnabled = (boolean) $escapingEnabled;\n    }\n\n    /**\n     * Parses a given template string and returns a parsed template object.\n     *\n     * The resulting ParsedTemplate can then be rendered by calling evaluate() on it.\n     *\n     * Normally, you should use a subclass of AbstractTemplateView instead of calling the\n     * TemplateParser directly.\n     *\n     * @param string $templateString The template to parse as a string\n     * @param string|null $templateIdentifier If the template has an identifying string it can be passed here to improve error reporting.\n     * @return ParsingState Parsed template\n     * @throws Exception\n     */\n    public function parse($templateString, $templateIdentifier = null)\n    {\n        if (!is_string($templateString)) {\n            throw new Exception('Parse requires a template string as argument, ' . gettype($templateString) . ' given.', 1224237899);\n        }\n        try {\n            $this->reset();\n\n            $templateString = $this->preProcessTemplateSource($templateString);\n\n            $splitTemplate = $this->splitTemplateAtDynamicTags($templateString);\n            $parsingState = $this->buildObjectTree($splitTemplate, self::CONTEXT_OUTSIDE_VIEWHELPER_ARGUMENTS);\n        } catch (Exception $error) {\n            throw $this->createParsingRelatedExceptionWithContext($error, $templateIdentifier);\n        }\n        $this->parsedTemplates[$templateIdentifier] = $parsingState;\n        return $parsingState;\n    }\n\n    /**\n     * @param \\Exception $error\n     * @param string $templateIdentifier\n     * @throws \\Exception\n     */\n    public function createParsingRelatedExceptionWithContext(\\Exception $error, $templateIdentifier)\n    {\n        list ($line, $character, $templateCode) = $this->getCurrentParsingPointers();\n        $exceptionClass = get_class($error);\n        return new $exceptionClass(\n            sprintf(\n                'Fluid parse error in template %s, line %d at character %d. Error: %s (error code %d). Template source chunk: %s',\n                $templateIdentifier,\n                $line,\n                $character,\n                $error->getMessage(),\n                $error->getCode(),\n                $templateCode\n            ),\n            $error->getCode(),\n            $error\n        );\n    }\n\n    /**\n     * @param string $templateIdentifier\n     * @param \\Closure $templateSourceClosure Closure which returns the template source if needed\n     * @return ParsedTemplateInterface\n     */\n    public function getOrParseAndStoreTemplate($templateIdentifier, $templateSourceClosure)\n    {\n        $compiler = $this->renderingContext->getTemplateCompiler();\n        if (isset($this->parsedTemplates[$templateIdentifier])) {\n            $parsedTemplate = $this->parsedTemplates[$templateIdentifier];\n        } elseif ($compiler->has($templateIdentifier)) {\n            $parsedTemplate = $compiler->get($templateIdentifier);\n            if ($parsedTemplate instanceof UncompilableTemplateInterface) {\n                $parsedTemplate = $this->parseTemplateSource($templateIdentifier, $templateSourceClosure);\n            }\n        } else {\n            $parsedTemplate = $this->parseTemplateSource($templateIdentifier, $templateSourceClosure);\n            try {\n                $compiler->store($templateIdentifier, $parsedTemplate);\n            } catch (StopCompilingException $stop) {\n                $this->renderingContext->getErrorHandler()->handleCompilerError($stop);\n                $parsedTemplate->setCompilable(false);\n                $compiler->store($templateIdentifier, $parsedTemplate);\n            }\n        }\n        return $parsedTemplate;\n    }\n\n    /**\n     * @param string $templateIdentifier\n     * @param \\Closure $templateSourceClosure\n     * @return ParsedTemplateInterface\n     */\n    protected function parseTemplateSource($templateIdentifier, $templateSourceClosure)\n    {\n        $parsedTemplate = $this->parse(\n            $templateSourceClosure($this, $this->renderingContext->getTemplatePaths()),\n            $templateIdentifier\n        );\n        $parsedTemplate->setIdentifier($templateIdentifier);\n        $this->parsedTemplates[$templateIdentifier] = $parsedTemplate;\n        return $parsedTemplate;\n    }\n\n    /**\n     * Pre-process the template source, making all registered TemplateProcessors\n     * do what they need to do with the template source before it is parsed.\n     *\n     * @param string $templateSource\n     * @return string\n     */\n    protected function preProcessTemplateSource($templateSource)\n    {\n        foreach ($this->renderingContext->getTemplateProcessors() as $templateProcessor) {\n            $templateSource = $templateProcessor->preProcessSource($templateSource);\n        }\n        return $templateSource;\n    }\n\n    /**\n     * Resets the parser to its default values.\n     *\n     * @return void\n     */\n    protected function reset()\n    {\n        $this->escapingEnabled = true;\n        $this->pointerLineNumber = 1;\n        $this->pointerLineCharacter = 1;\n    }\n\n    /**\n     * Splits the template string on all dynamic tags found.\n     *\n     * @param string $templateString Template string to split.\n     * @return array Splitted template\n     */\n    protected function splitTemplateAtDynamicTags($templateString)\n    {\n        return preg_split(Patterns::$SPLIT_PATTERN_TEMPLATE_DYNAMICTAGS, $templateString, -1, PREG_SPLIT_DELIM_CAPTURE | PREG_SPLIT_NO_EMPTY);\n    }\n\n    /**\n     * Build object tree from the split template\n     *\n     * @param array $splitTemplate The split template, so that every tag with a namespace declaration is already a seperate array element.\n     * @param integer $context one of the CONTEXT_* constants, defining whether we are inside or outside of ViewHelper arguments currently.\n     * @return ParsingState\n     * @throws Exception\n     */\n    protected function buildObjectTree(array $splitTemplate, $context)\n    {\n        $state = $this->getParsingState();\n        $previousBlock = '';\n\n        foreach ($splitTemplate as $templateElement) {\n            if ($context === self::CONTEXT_OUTSIDE_VIEWHELPER_ARGUMENTS) {\n                // Store a neat reference to the outermost chunk of Fluid template code.\n                // Don't store the reference if parsing ViewHelper arguments object tree;\n                // we want the reference code to contain *all* of the ViewHelper call.\n                $this->pointerTemplateCode = $templateElement;\n            }\n            $this->pointerLineNumber += substr_count($templateElement, PHP_EOL);\n            $this->pointerLineCharacter = strlen(substr($previousBlock, strrpos($previousBlock, PHP_EOL))) + 1;\n            $previousBlock = $templateElement;\n            $matchedVariables = [];\n\n            if (preg_match(Patterns::$SCAN_PATTERN_TEMPLATE_VIEWHELPERTAG, $templateElement, $matchedVariables) > 0) {\n                if ($this->openingViewHelperTagHandler(\n                    $state,\n                    $matchedVariables['NamespaceIdentifier'],\n                    $matchedVariables['MethodIdentifier'],\n                    $matchedVariables['Attributes'],\n                    ($matchedVariables['Selfclosing'] === '' ? false : true),\n                    $templateElement\n                )) {\n                    continue;\n                }\n            } elseif (preg_match(Patterns::$SCAN_PATTERN_TEMPLATE_CLOSINGVIEWHELPERTAG, $templateElement, $matchedVariables) > 0) {\n                if ($this->closingViewHelperTagHandler(\n                    $state,\n                    $matchedVariables['NamespaceIdentifier'],\n                    $matchedVariables['MethodIdentifier']\n                )) {\n                    continue;\n                }\n            }\n            $this->textAndShorthandSyntaxHandler($state, $templateElement, $context);\n        }\n\n        if ($state->countNodeStack() !== 1) {\n            throw new Exception(\n                'Not all tags were closed!',\n                1238169398\n            );\n        }\n        return $state;\n    }\n    /**\n     * Handles an opening or self-closing view helper tag.\n     *\n     * @param ParsingState $state Current parsing state\n     * @param string $namespaceIdentifier Namespace identifier - being looked up in $this->namespaces\n     * @param string $methodIdentifier Method identifier\n     * @param string $arguments Arguments string, not yet parsed\n     * @param boolean $selfclosing true, if the tag is a self-closing tag.\n     * @param string $templateElement The template code containing the ViewHelper call\n     * @return NodeInterface|null\n     */\n    protected function openingViewHelperTagHandler(ParsingState $state, $namespaceIdentifier, $methodIdentifier, $arguments, $selfclosing, $templateElement)\n    {\n        $viewHelperNode = $this->initializeViewHelperAndAddItToStack(\n            $state,\n            $namespaceIdentifier,\n            $methodIdentifier,\n            $this->parseArguments($arguments)\n        );\n\n        if ($viewHelperNode) {\n            $viewHelperNode->setPointerTemplateCode($templateElement);\n            if ($selfclosing === true) {\n                $state->popNodeFromStack();\n                $this->callInterceptor($viewHelperNode, InterceptorInterface::INTERCEPT_CLOSING_VIEWHELPER, $state);\n                // This needs to be called here because closingViewHelperTagHandler() is not triggered for self-closing tags\n                $state->getNodeFromStack()->addChildNode($viewHelperNode);\n            }\n        }\n\n        return $viewHelperNode;\n    }\n\n    /**\n     * Initialize the given ViewHelper and adds it to the current node and to\n     * the stack.\n     *\n     * @param ParsingState $state Current parsing state\n     * @param string $namespaceIdentifier Namespace identifier - being looked up in $this->namespaces\n     * @param string $methodIdentifier Method identifier\n     * @param array $argumentsObjectTree Arguments object tree\n     * @return null|NodeInterface An instance of ViewHelperNode if identity was valid - NULL if the namespace/identity was not registered\n     * @throws Exception\n     */\n    protected function initializeViewHelperAndAddItToStack(ParsingState $state, $namespaceIdentifier, $methodIdentifier, $argumentsObjectTree)\n    {\n        $viewHelperResolver = $this->renderingContext->getViewHelperResolver();\n        if (!$viewHelperResolver->isNamespaceValid($namespaceIdentifier)) {\n            return null;\n        }\n        try {\n            $currentViewHelperNode = new ViewHelperNode(\n                $this->renderingContext,\n                $namespaceIdentifier,\n                $methodIdentifier,\n                $argumentsObjectTree,\n                $state\n            );\n\n            $this->callInterceptor($currentViewHelperNode, InterceptorInterface::INTERCEPT_OPENING_VIEWHELPER, $state);\n            $viewHelper = $currentViewHelperNode->getUninitializedViewHelper();\n            $viewHelper::postParseEvent($currentViewHelperNode, $argumentsObjectTree, $state->getVariableContainer());\n            $state->pushNodeToStack($currentViewHelperNode);\n            return $currentViewHelperNode;\n        } catch (\\TYPO3Fluid\\Fluid\\Core\\ViewHelper\\Exception $error) {\n            $this->textHandler(\n                $state,\n                $this->renderingContext->getErrorHandler()->handleViewHelperError($error)\n            );\n        } catch (Exception $error) {\n            $this->textHandler(\n                $state,\n                $this->renderingContext->getErrorHandler()->handleParserError($error)\n            );\n        }\n        return null;\n    }\n\n    /**\n     * Handles a closing view helper tag\n     *\n     * @param ParsingState $state The current parsing state\n     * @param string $namespaceIdentifier Namespace identifier for the closing tag.\n     * @param string $methodIdentifier Method identifier.\n     * @return boolean whether the viewHelper was found and added to the stack or not\n     * @throws Exception\n     */\n    protected function closingViewHelperTagHandler(ParsingState $state, $namespaceIdentifier, $methodIdentifier)\n    {\n        $viewHelperResolver = $this->renderingContext->getViewHelperResolver();\n        if (!$viewHelperResolver->isNamespaceValid($namespaceIdentifier)) {\n            return false;\n        }\n        $lastStackElement = $state->popNodeFromStack();\n        if (!($lastStackElement instanceof ViewHelperNode)) {\n            throw new Exception('You closed a templating tag which you never opened!', 1224485838);\n        }\n        $actualViewHelperClassName = $viewHelperResolver->resolveViewHelperClassName($namespaceIdentifier, $methodIdentifier);\n        $expectedViewHelperClassName = $lastStackElement->getViewHelperClassName();\n        if ($actualViewHelperClassName !== $expectedViewHelperClassName) {\n            throw new Exception(\n                'Templating tags not properly nested. Expected: ' . $expectedViewHelperClassName . '; Actual: ' .\n                $actualViewHelperClassName,\n                1224485398\n            );\n        }\n        $this->callInterceptor($lastStackElement, InterceptorInterface::INTERCEPT_CLOSING_VIEWHELPER, $state);\n        $state->getNodeFromStack()->addChildNode($lastStackElement);\n\n        return true;\n    }\n\n    /**\n     * Handles the appearance of an object accessor (like {posts.author.email}).\n     * Creates a new instance of \\TYPO3Fluid\\Fluid\\ObjectAccessorNode.\n     *\n     * Handles ViewHelpers as well which are in the shorthand syntax.\n     *\n     * @param ParsingState $state The current parsing state\n     * @param string $objectAccessorString String which identifies which objects to fetch\n     * @param string $delimiter\n     * @param string $viewHelperString\n     * @param string $additionalViewHelpersString\n     * @return void\n     */\n    protected function objectAccessorHandler(ParsingState $state, $objectAccessorString, $delimiter, $viewHelperString, $additionalViewHelpersString)\n    {\n        $viewHelperString .= $additionalViewHelpersString;\n        $numberOfViewHelpers = 0;\n\n        // The following post-processing handles a case when there is only a ViewHelper, and no Object Accessor.\n        // Resolves bug #5107.\n        if (strlen($delimiter) === 0 && strlen($viewHelperString) > 0) {\n            $viewHelperString = $objectAccessorString . $viewHelperString;\n            $objectAccessorString = '';\n        }\n\n        // ViewHelpers\n        $matches = [];\n        if (strlen($viewHelperString) > 0 && preg_match_all(Patterns::$SPLIT_PATTERN_SHORTHANDSYNTAX_VIEWHELPER, $viewHelperString, $matches, PREG_SET_ORDER) > 0) {\n            // The last ViewHelper has to be added first for correct chaining.\n            foreach (array_reverse($matches) as $singleMatch) {\n                if (strlen($singleMatch['ViewHelperArguments']) > 0) {\n                    $arguments = $this->recursiveArrayHandler($singleMatch['ViewHelperArguments']);\n                } else {\n                    $arguments = [];\n                }\n                $viewHelperNode = $this->initializeViewHelperAndAddItToStack($state, $singleMatch['NamespaceIdentifier'], $singleMatch['MethodIdentifier'], $arguments);\n                if ($viewHelperNode) {\n                    $numberOfViewHelpers++;\n                }\n            }\n        }\n\n        // Object Accessor\n        if (strlen($objectAccessorString) > 0) {\n            $node = new ObjectAccessorNode($objectAccessorString);\n            $this->callInterceptor($node, InterceptorInterface::INTERCEPT_OBJECTACCESSOR, $state);\n            $state->getNodeFromStack()->addChildNode($node);\n        }\n\n        // Close ViewHelper Tags if needed.\n        for ($i = 0; $i < $numberOfViewHelpers; $i++) {\n            $node = $state->popNodeFromStack();\n            $this->callInterceptor($node, InterceptorInterface::INTERCEPT_CLOSING_VIEWHELPER, $state);\n            $state->getNodeFromStack()->addChildNode($node);\n        }\n    }\n\n    /**\n     * Call all interceptors registered for a given interception point.\n     *\n     * @param NodeInterface $node The syntax tree node which can be modified by the interceptors.\n     * @param integer $interceptionPoint the interception point. One of the \\TYPO3Fluid\\Fluid\\Core\\Parser\\InterceptorInterface::INTERCEPT_* constants.\n     * @param ParsingState $state the parsing state\n     * @return void\n     */\n    protected function callInterceptor(NodeInterface & $node, $interceptionPoint, ParsingState $state)\n    {\n        if ($this->configuration === null) {\n            return;\n        }\n        if ($this->escapingEnabled) {\n            /** @var $interceptor InterceptorInterface */\n            foreach ($this->configuration->getEscapingInterceptors($interceptionPoint) as $interceptor) {\n                $node = $interceptor->process($node, $interceptionPoint, $state);\n            }\n        }\n\n        /** @var $interceptor InterceptorInterface */\n        foreach ($this->configuration->getInterceptors($interceptionPoint) as $interceptor) {\n            $node = $interceptor->process($node, $interceptionPoint, $state);\n        }\n    }\n\n    /**\n     * Parse arguments of a given tag, and build up the Arguments Object Tree\n     * for each argument.\n     * Returns an associative array, where the key is the name of the argument,\n     * and the value is a single Argument Object Tree.\n     *\n     * @param string $argumentsString All arguments as string\n     * @return array An associative array of objects, where the key is the argument name.\n     */\n    protected function parseArguments($argumentsString)\n    {\n        $argumentsObjectTree = [];\n        $matches = [];\n        if (preg_match_all(Patterns::$SPLIT_PATTERN_TAGARGUMENTS, $argumentsString, $matches, PREG_SET_ORDER) > 0) {\n            $escapingEnabledBackup = $this->escapingEnabled;\n            $this->escapingEnabled = false;\n            foreach ($matches as $singleMatch) {\n                $argument = $singleMatch['Argument'];\n                $value = $this->unquoteString($singleMatch['ValueQuoted']);\n                $argumentsObjectTree[$argument] = $this->buildArgumentObjectTree($value);\n            }\n            $this->escapingEnabled = $escapingEnabledBackup;\n        }\n        return $argumentsObjectTree;\n    }\n\n    /**\n     * Build up an argument object tree for the string in $argumentString.\n     * This builds up the tree for a single argument value.\n     *\n     * This method also does some performance optimizations, so in case\n     * no { or < is found, then we just return a TextNode.\n     *\n     * @param string $argumentString\n     * @return SyntaxTree\\NodeInterface the corresponding argument object tree.\n     */\n    protected function buildArgumentObjectTree($argumentString)\n    {\n        if (strpos($argumentString, '{') === false && strpos($argumentString, '<') === false) {\n            if (is_numeric($argumentString)) {\n                return new NumericNode($argumentString);\n            }\n            return new TextNode($argumentString);\n        }\n        $splitArgument = $this->splitTemplateAtDynamicTags($argumentString);\n        $rootNode = $this->buildObjectTree($splitArgument, self::CONTEXT_INSIDE_VIEWHELPER_ARGUMENTS)->getRootNode();\n        return $rootNode;\n    }\n\n    /**\n     * Removes escapings from a given argument string and trims the outermost\n     * quotes.\n     *\n     * This method is meant as a helper for regular expression results.\n     *\n     * @param string $quotedValue Value to unquote\n     * @return string Unquoted value\n     */\n    public function unquoteString($quotedValue)\n    {\n        $value = $quotedValue;\n        if ($value === '') {\n            return $value;\n        }\n        if ($quotedValue{0} === '\"') {\n            $value = str_replace('\\\\\"', '\"', preg_replace('/(^\"|\"$)/', '', $quotedValue));\n        } elseif ($quotedValue{0} === '\\'') {\n            $value = str_replace(\"\\\\'\", \"'\", preg_replace('/(^\\'|\\'$)/', '', $quotedValue));\n        }\n        return str_replace('\\\\\\\\', '\\\\', $value);\n    }\n\n    /**\n     * Handler for everything which is not a ViewHelperNode.\n     *\n     * This includes Text, array syntax, and object accessor syntax.\n     *\n     * @param ParsingState $state Current parsing state\n     * @param string $text Text to process\n     * @param integer $context one of the CONTEXT_* constants, defining whether we are inside or outside of ViewHelper arguments currently.\n     * @return void\n     */\n    protected function textAndShorthandSyntaxHandler(ParsingState $state, $text, $context)\n    {\n        $sections = preg_split(Patterns::$SPLIT_PATTERN_SHORTHANDSYNTAX, $text, -1, PREG_SPLIT_DELIM_CAPTURE | PREG_SPLIT_NO_EMPTY);\n        foreach ($sections as $section) {\n            $matchedVariables = [];\n            $expressionNode = null;\n            if (preg_match(Patterns::$SCAN_PATTERN_SHORTHANDSYNTAX_OBJECTACCESSORS, $section, $matchedVariables) > 0) {\n                $this->objectAccessorHandler(\n                    $state,\n                    $matchedVariables['Object'],\n                    $matchedVariables['Delimiter'],\n                    (isset($matchedVariables['ViewHelper']) ? $matchedVariables['ViewHelper'] : ''),\n                    (isset($matchedVariables['AdditionalViewHelpers']) ? $matchedVariables['AdditionalViewHelpers'] : '')\n                );\n            } elseif ($context === self::CONTEXT_INSIDE_VIEWHELPER_ARGUMENTS\n                && preg_match(Patterns::$SCAN_PATTERN_SHORTHANDSYNTAX_ARRAYS, $section, $matchedVariables) > 0\n            ) {\n                // We only match arrays if we are INSIDE viewhelper arguments\n                $this->arrayHandler($state, $this->recursiveArrayHandler($matchedVariables['Array']));\n            } else {\n                // We ask custom ExpressionNode instances from ViewHelperResolver\n                // if any match our expression:\n                foreach ($this->renderingContext->getExpressionNodeTypes() as $expressionNodeTypeClassName) {\n                    $detectionExpression = $expressionNodeTypeClassName::$detectionExpression;\n                    $matchedVariables = [];\n                    preg_match_all($detectionExpression, $section, $matchedVariables, PREG_SET_ORDER);\n                    if (is_array($matchedVariables) === true) {\n                        foreach ($matchedVariables as $matchedVariableSet) {\n                            $expressionStartPosition = strpos($section, $matchedVariableSet[0]);\n                            /** @var ExpressionNodeInterface $expressionNode */\n                            $expressionNode = new $expressionNodeTypeClassName($matchedVariableSet[0], $matchedVariableSet, $state);\n                            try {\n                                // Trigger initial parse-time evaluation to allow the node to manipulate the rendering context.\n                                if ($expressionNode instanceof ParseTimeEvaluatedExpressionNodeInterface) {\n                                    $expressionNode->evaluate($this->renderingContext);\n                                }\n\n                                if ($expressionStartPosition > 0) {\n                                    $state->getNodeFromStack()->addChildNode(new TextNode(substr($section, 0, $expressionStartPosition)));\n                                }\n\n                                $this->callInterceptor($expressionNode, InterceptorInterface::INTERCEPT_EXPRESSION, $state);\n                                $state->getNodeFromStack()->addChildNode($expressionNode);\n\n                                $expressionEndPosition = $expressionStartPosition + strlen($matchedVariableSet[0]);\n                                if ($expressionEndPosition < strlen($section)) {\n                                    $this->textAndShorthandSyntaxHandler($state, substr($section, $expressionEndPosition), $context);\n                                    break;\n                                }\n                            } catch (ExpressionException $error) {\n                                $this->textHandler(\n                                    $state,\n                                    $this->renderingContext->getErrorHandler()->handleExpressionError($error)\n                                );\n                            }\n                        }\n                    }\n                }\n\n                if (!$expressionNode) {\n                    // As fallback we simply render the expression back as template content.\n                    $this->textHandler($state, $section);\n                }\n            }\n        }\n    }\n\n    /**\n     * Handler for array syntax. This creates the array object recursively and\n     * adds it to the current node.\n     *\n     * @param ParsingState $state The current parsing state\n     * @param NodeInterface[] $arrayText The array as string.\n     * @return void\n     */\n    protected function arrayHandler(ParsingState $state, $arrayText)\n    {\n        $arrayNode = new ArrayNode($arrayText);\n        $state->getNodeFromStack()->addChildNode($arrayNode);\n    }\n\n    /**\n     * Recursive function which takes the string representation of an array and\n     * builds an object tree from it.\n     *\n     * Deals with the following value types:\n     * - Numbers (Integers and Floats)\n     * - Strings\n     * - Variables\n     * - sub-arrays\n     *\n     * @param string $arrayText Array text\n     * @return NodeInterface[] the array node built up\n     * @throws Exception\n     */\n    protected function recursiveArrayHandler($arrayText)\n    {\n        $matches = [];\n        $arrayToBuild = [];\n        if (preg_match_all(Patterns::$SPLIT_PATTERN_SHORTHANDSYNTAX_ARRAY_PARTS, $arrayText, $matches, PREG_SET_ORDER)) {\n            foreach ($matches as $singleMatch) {\n                $arrayKey = $this->unquoteString($singleMatch['Key']);\n                if (!empty($singleMatch['VariableIdentifier'])) {\n                    $arrayToBuild[$arrayKey] = new ObjectAccessorNode($singleMatch['VariableIdentifier']);\n                } elseif (array_key_exists('Number', $singleMatch) && (!empty($singleMatch['Number']) || $singleMatch['Number'] === '0')) {\n                    // Note: this method of casting picks \"int\" when value is a natural number and \"float\" if any decimals are found. See also NumericNode.\n                    $arrayToBuild[$arrayKey] = $singleMatch['Number'] + 0;\n                } elseif ((array_key_exists('QuotedString', $singleMatch) && !empty($singleMatch['QuotedString']))) {\n                    $argumentString = $this->unquoteString($singleMatch['QuotedString']);\n                    $arrayToBuild[$arrayKey] = $this->buildArgumentObjectTree($argumentString);\n                } elseif (array_key_exists('Subarray', $singleMatch) && !empty($singleMatch['Subarray'])) {\n                    $arrayToBuild[$arrayKey] = new ArrayNode($this->recursiveArrayHandler($singleMatch['Subarray']));\n                }\n            }\n        }\n        return $arrayToBuild;\n    }\n\n    /**\n     * Text node handler\n     *\n     * @param ParsingState $state\n     * @param string $text\n     * @return void\n     */\n    protected function textHandler(ParsingState $state, $text)\n    {\n        $node = new TextNode($text);\n        $this->callInterceptor($node, InterceptorInterface::INTERCEPT_TEXT, $state);\n        $state->getNodeFromStack()->addChildNode($node);\n    }\n\n    /**\n     * @return ParsingState\n     */\n    protected function getParsingState()\n    {\n        $rootNode = new RootNode();\n        $variableProvider = $this->renderingContext->getVariableProvider();\n        $state = new ParsingState();\n        $state->setRootNode($rootNode);\n        $state->pushNodeToStack($rootNode);\n        $state->setVariableProvider($variableProvider->getScopeCopy($variableProvider->getAll()));\n        return $state;\n    }\n}\n", "<?php\nnamespace FluidTYPO3Fluid\\Flux\\Tests\\Unit\\Functional;\n\n/*\n * This file belongs to the package \"TYPO3 Fluid\".\n * See LICENSE.txt that was shipped with this package.\n */\n\nuse org\\bovigo\\vfs\\vfsStream;\nuse TYPO3Fluid\\Fluid\\Tests\\BaseTestCase;\n\n/**\n * Class ExamplesTest\n */\nclass ExamplesTest extends BaseTestCase\n{\n\n    /**\n     * @return void\n     */\n    public static function setUpBeforeClass()\n    {\n        vfsStream::setup('fakecache/');\n    }\n\n    /**\n     * @dataProvider getExampleScriptTestValues\n     * @param string $script\n     * @param array $expectedOutputs\n     * @param string $expectedException\n     */\n    public function testExampleScriptFileWithoutCache($script, array $expectedOutputs, $expectedException = null)\n    {\n        if ($expectedException !== null) {\n            $this->setExpectedException($expectedException);\n        }\n        $this->runExampleScriptTest($script, $expectedOutputs, false);\n    }\n\n    /**\n     * @dataProvider getExampleScriptTestValues\n     * @param string $script\n     * @param array $expectedOutputs\n     * @param string $expectedException\n     */\n    public function testExampleScriptFileWithCache($script, array $expectedOutputs, $expectedException = null)\n    {\n        if ($expectedException !== null) {\n            $this->setExpectedException($expectedException);\n        }\n        $cache = vfsStream::url('fakecache/');\n        $this->runExampleScriptTest($script, $expectedOutputs, $cache);\n        $this->runExampleScriptTest($script, $expectedOutputs, $cache);\n    }\n\n    /**\n     * @param string $script\n     * @param array $expectedOutputs\n     * @param string $FLUID_CACHE_DIRECTORY\n     */\n    protected function runExampleScriptTest($script, array $expectedOutputs, $FLUID_CACHE_DIRECTORY)\n    {\n        $scriptFile = __DIR__ . '/../../examples/' . $script;\n        $self = $this;\n        $this->setOutputCallback(function ($output) use ($self, $expectedOutputs) {\n            foreach ($expectedOutputs as $expectedOutput) {\n                $self->assertContains($expectedOutput, $output);\n            }\n        });\n        include $scriptFile;\n        unset($FLUID_CACHE_DIRECTORY);\n    }\n\n    /**\n     * @return array\n     */\n    public function getExampleScriptTestValues()\n    {\n        return [\n            'example_conditions.php' => [\n                'example_conditions.php',\n                [\n                    'Standard ternary expression: The ternary expression is TRUE',\n                    'Negated ternary expression without then case: The ternary expression is FALSE',\n                    'Negated ternary expression: The ternary expression is FALSE',\n                    'Ternary expression without then case: The ternary expression is TRUE',\n                    '1 === TRUE',\n                    '(0) === FALSE',\n                    '(1) === TRUE',\n                    '0 && 0 === FALSE',\n                    '0 || 0 === FALSE',\n                    '1 && 0 === FALSE',\n                    '0 && 1 === FALSE',\n                    '1 || 0 === TRUE',\n                    '0 || 1 === TRUE',\n                    '0 || 1 && 0 === FALSE',\n                    '0 || 1 && 1 === TRUE',\n                    '$varfalse === FALSE',\n                    '$vartrue === TRUE',\n                    '!($vartrue) === FALSE',\n                    '$vararray1 == $vararray2 === FALSE',\n                    '($vararray1 == $vararray1) && $vartrue === TRUE',\n                    '$varfalse == $varfalse === TRUE',\n                    '$varfalse != $varfalse === FALSE',\n                    '$vararray1 == $vararray1 === TRUE',\n                    '\\'thisstring\\' != \\'thatstring\\' === TRUE'\n                ]\n            ],\n            'example_customresolving.php' => [\n                'example_customresolving.php',\n                [\n                    var_export(['foo' => 'bar'], true),\n                    var_export(['bar' => 'foo'], true),\n                ]\n            ],\n            'example_format.php' => [\n                'example_format.php',\n                [\n                    '\"layout\": \"Default.json\",',\n                    '\"foobar\": \"Variable foobar\"'\n                ]\n            ],\n            'example_layoutless.php' => [\n                'example_layoutless.php',\n                [\n                    'This section is rendered below',\n                    'This text is rendered because it is outside the section'\n                ]\n            ],\n            'example_math.php' => [\n                'example_math.php',\n                [\n                    'Expression: $numberten % 4 = 2',\n                    'Expression: 4 * $numberten = 40',\n                    'Expression: 4 / $numberten = 0.4',\n                    'Expression: $numberone / $numberten = 0.1',\n                    'Expression: 10 ^ $numberten = 10000000000'\n                ]\n            ],\n            'example_multiplepaths.php' => [\n                'example_multiplepaths.php',\n                [\n                    'Rendered via overridden Layout, section \"Main\":',\n                    'Overridden Default template.',\n                    'Value of \"foobar\": This is foobar.',\n                    'Contents of FirstPartial.html',\n                    'Overridden contents of SecondPartial.html',\n                ]\n            ],\n            'example_mvc.php' => [\n                'example_mvc.php',\n                [\n                    'I am the template belonging to the \"Default\" controller, action \"Default\".',\n                    'I am the template belonging to the \"Other\" controller, action \"Default\".',\n                    'I am the template belonging to the \"Other\" controller, action \"List\".',\n                    'Value of \"foobar\": MVC template.'\n                ]\n            ],\n            'example_namespaces.php' => [\n                'example_namespaces.php',\n                [\n                    'Namespaces template',\n                    '<invalid:vh>This tag will be shown</invalid:vh>'\n                ]\n            ],\n            'example_namespaceresolving.php' => [\n                'example_namespaceresolving.php',\n                [\n                    'NamespaceResolving template from Singles.',\n                    'Argument passed to CustomViewHelper:',\n                    '123'\n                ]\n            ],\n            'example_single.php' => [\n                'example_single.php',\n                [\n                    'Value of \"foobar\": Single template'\n                ]\n            ],\n            'example_escapingmodifier.php' => [\n                'example_escapingmodifier.php',\n                [\n                    'Value of \"html\": <strong>This is not escaped</strong>',\n                    'From partial: <strong>This is not escaped</strong>',\n                ]\n            ],\n            'example_structures.php' => [\n                'example_structures.php',\n                [\n                    'Tag: \"Dynamic\"',\n                    'Pass: \"Dynamic\"',\n                    'Pipe: \"Dynamic\"',\n                    'Pipe, multiple levels: \"Dynamic\"',\n                    'This section exists and is rendered: Valid section',\n                    'Expects no output because section name is invalid: ' . \"\\n\",\n                    'Dynamic section name: Dynamically suffixed section',\n                    'Bad dynamic section name, expects fallback: Just a section',\n                    'Will render: Just a section',\n                    'Will render, clause reversed: Just a section',\n                    'Will not render: ' . \"\\n\",\n                    'This `f:else` was rendered',\n                    'The value was \"3\"',\n                    'The unmatched value case triggered',\n                    'The \"b\" nested switch case was triggered'\n                ]\n            ],\n            'example_variables.php' => [\n                'example_variables.php',\n                [\n                    'Simple variable: string foo',\n                    'A string with numbers in it: 132',\n                    'Ditto, with type name stored in variable: 132',\n                    'A comma-separated value iterated as array:' . \"\\n\\t- one\\n\\t- two\",\n                    'String variable name with dynamic1 part: String using $dynamic1.',\n                    'String variable name with dynamic2 part: String using $dynamic2.',\n                    'Array member in $array[$dynamic1]: Dynamic key in $array[$dynamic1]',\n                    'Array member in $array[$dynamic2]: Dynamic key in $array[$dynamic2]',\n                    'Output of variable whose name is stored in a variable: string foo',\n                    'Direct access of numeric prefixed variable: Numeric prefixed variable',\n                    'Aliased access of numeric prefixed variable: Numeric prefixed variable',\n                    'Escaped ternary expression: &lt;b&gt;Unescaped string&lt;/b&gt;',\n                    'Escaped cast expression: &lt;b&gt;Unescaped string&lt;/b&gt;',\n                    'Received $array.foobar with value <b>Unescaped string</b> (same using \"value\" argument: <b>Unescaped string</b>)',\n                    'Received $array.printf with formatted string Formatted string, value: formatted',\n                    'Received $array.baz with value 42',\n                    'Received $array.xyz.foobar with value Escaped sub-string',\n                    'Received $myVariable with value Nice string'\n                ]\n            ],\n            'example_variableprovider.php' => [\n                'example_variableprovider.php',\n                [\n                    'VariableProvider template from Singles.',\n                    'Random: random',\n                ]\n            ],\n            'example_dynamiclayout.php' => [\n                'example_dynamiclayout.php',\n                [\n                    'Rendered via DynamicLayout, section \"Main\":',\n                ]\n            ],\n            'example_cachestatic.php' => [\n                'example_cachestatic.php',\n                [\n                    'Cached as static text 1',\n                    'Cached as static text 2',\n                    'Cached as static text 3',\n                ]\n            ],\n            'example_passthrough.php' => [\n                'example_passthrough.php',\n                [\n                    '<f:format.raw>This does not get parsed; the source is passed through with Fluid markup</f:format.raw>'\n                ]\n            ],\n            'example_errorhandling.php' => [\n                'example_errorhandling.php',\n                [\n                    'View error: The Fluid template files',\n                    'Section rendering error: Section \"DoesNotExist\" does not exist. Section rendering is mandatory; \"optional\" is false.',\n                    'ViewHelper error: Undeclared arguments passed to ViewHelper TYPO3Fluid\\Fluid\\ViewHelpers\\IfViewHelper: notregistered. Valid arguments are: then, else, condition - Offending code: <f:if notregistered=\"1\" />',\n                    'Parser error: The ViewHelper \"<f:invalid>\" could not be resolved.',\n                    'Based on your spelling, the system would load the class \"TYPO3Fluid\\Fluid\\ViewHelpers\\InvalidViewHelper\", however this class does not exist. Offending code: <f:invalid />',\n                    'Invalid expression: Invalid target conversion type &quot;invalidtype&quot; specified in casting expression &quot;{foobar as invalidtype}&quot;.',\n                ]\n            ]\n        ];\n    }\n}\n"], "filenames": ["examples/Resources/Private/Singles/Variables.html", "src/Core/Parser/Interceptor/Escape.php", "src/Core/Parser/InterceptorInterface.php", "src/Core/Parser/TemplateParser.php", "tests/Functional/ExamplesTest.php"], "buggy_code_start_loc": [31, 11, 21, 627, 220], "buggy_code_end_loc": [45, 82, 21, 627, 264], "fixing_code_start_loc": [32, 12, 22, 628, 221], "fixing_code_end_loc": [49, 84, 23, 630, 266], "type": "CWE-79", "message": "TYPO3 Fluid Engine (package `typo3fluid/fluid`) before versions 2.0.5, 2.1.4, 2.2.1, 2.3.5, 2.4.1, 2.5.5 or 2.6.1 is vulnerable to cross-site scripting when making use of the ternary conditional operator in templates like `{showFullName ? fullName : defaultValue}`. Updated versions of this package are bundled in following TYPO3 (`typo3/cms-core`) versions as well: TYPO3 v8.7.25 (using `typo3fluid/fluid` v2.5.4) and TYPO3 v9.5.6 (using `typo3fluid/fluid` v2.6.1).", "other": {"cve": {"id": "CVE-2020-15241", "sourceIdentifier": "security-advisories@github.com", "published": "2020-10-08T21:15:10.167", "lastModified": "2021-11-18T16:55:53.293", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "TYPO3 Fluid Engine (package `typo3fluid/fluid`) before versions 2.0.5, 2.1.4, 2.2.1, 2.3.5, 2.4.1, 2.5.5 or 2.6.1 is vulnerable to cross-site scripting when making use of the ternary conditional operator in templates like `{showFullName ? fullName : defaultValue}`. Updated versions of this package are bundled in following TYPO3 (`typo3/cms-core`) versions as well: TYPO3 v8.7.25 (using `typo3fluid/fluid` v2.5.4) and TYPO3 v9.5.6 (using `typo3fluid/fluid` v2.6.1)."}, {"lang": "es", "value": "TYPO3 Fluid Engine (paquete \"ypo3fluid/fluid\") versiones anteriores a 2.0.5, 2.1.4, 2.2.1, 2.3.5, 2.4.1, 2.5.5 o 2.6.1, es susceptible a una vulnerabilidad de tipo cross-site scripting cuando se utiliza el operador condicional ternario en plantillas como \"{showFullName ? fullName : defaultValue}\". Las versiones actualizadas de este paquete tambi\u00e9n se incluyen en las siguientes versiones de TYPO3 (\"typo3/cms-core\"): TYPO3 v8.7.25 (usando \"typo3fluid/fluid\" v2.5.4) y TYPO3 v9.5.6 (usando \"typo3fluid/fluid\" v2.6.1)"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 4.7, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.6, "impactScore": 2.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-601"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:typo3:fluid_engine:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.0.5", "matchCriteriaId": "768EE2A0-4C07-422B-A7D4-8E0132257103"}, {"vulnerable": true, "criteria": "cpe:2.3:a:typo3:fluid_engine:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.1.0", "versionEndExcluding": "2.1.4", "matchCriteriaId": "B519C49A-53BF-4F33-8582-F686CDC53BC7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:typo3:fluid_engine:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.2.0", "versionEndExcluding": "2.2.1", "matchCriteriaId": "3A6D9005-0C5C-4723-B074-045F1C669EF5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:typo3:fluid_engine:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.3.0", "versionEndExcluding": "2.3.5", "matchCriteriaId": "031F6347-5D70-4BCA-BF65-D399BAA67AA8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:typo3:fluid_engine:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.4.0", "versionEndExcluding": "2.4.1", "matchCriteriaId": "0FBB5013-12A2-467C-9D04-051629BBAADD"}, {"vulnerable": true, "criteria": "cpe:2.3:a:typo3:fluid_engine:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.5.0", "versionEndExcluding": "2.5.5", "matchCriteriaId": "AC3AA935-E37A-4CDD-A9CC-19C7DCD236F2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:typo3:fluid_engine:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.6.0", "versionEndExcluding": "2.6.1", "matchCriteriaId": "09784D80-A267-4C8B-8989-A26B5B3155FA"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:typo3:typo3:8.7.25:*:*:*:*:*:*:*", "matchCriteriaId": "5E46577F-2AC5-427B-AAA2-9D12D158E856"}, {"vulnerable": true, "criteria": "cpe:2.3:a:typo3:typo3:9.5.6:*:*:*:*:*:*:*", "matchCriteriaId": "7E02D19F-8C78-4BD3-8A95-CD10984880CD"}]}]}], "references": [{"url": "https://github.com/TYPO3/Fluid/commit/9ef6a8ffff2e812025fc0701b4ce72eea6911a3d", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/TYPO3/Fluid/security/advisories/GHSA-7733-hjv6-4h47", "source": "security-advisories@github.com", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://typo3.org/security/advisory/typo3-core-sa-2019-013", "source": "security-advisories@github.com", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/TYPO3/Fluid/commit/9ef6a8ffff2e812025fc0701b4ce72eea6911a3d"}}