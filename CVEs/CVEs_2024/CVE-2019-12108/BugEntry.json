{"buggy_code": ["/* $Id: upnpsoap.c,v 1.151 2018/03/13 10:32:53 nanard Exp $ */\n/* vim: tabstop=4 shiftwidth=4 noexpandtab\n * MiniUPnP project\n * http://miniupnp.free.fr/ or https://miniupnp.tuxfamily.org/\n * (c) 2006-2018 Thomas Bernard\n * This software is subject to the conditions detailed\n * in the LICENCE file provided within the distribution */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <string.h>\n#include <errno.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/types.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <ctype.h>\n\n#include \"macros.h\"\n#include \"config.h\"\n#include \"upnpglobalvars.h\"\n#include \"upnphttp.h\"\n#include \"upnpsoap.h\"\n#include \"upnpreplyparse.h\"\n#include \"upnpredirect.h\"\n#include \"upnppinhole.h\"\n#include \"getifaddr.h\"\n#include \"getifstats.h\"\n#include \"getconnstatus.h\"\n#include \"upnpurns.h\"\n#include \"upnputils.h\"\n\n/* utility function */\nstatic int is_numeric(const char * s)\n{\n\twhile(*s) {\n\t\tif(*s < '0' || *s > '9') return 0;\n\t\ts++;\n\t}\n\treturn 1;\n}\n\nstatic void\nBuildSendAndCloseSoapResp(struct upnphttp * h,\n                          const char * body, int bodylen)\n{\n\tstatic const char beforebody[] =\n\t\t\"<?xml version=\\\"1.0\\\"?>\\r\\n\"\n\t\t\"<s:Envelope xmlns:s=\\\"http://schemas.xmlsoap.org/soap/envelope/\\\" \"\n\t\t\"s:encodingStyle=\\\"http://schemas.xmlsoap.org/soap/encoding/\\\">\"\n\t\t\"<s:Body>\";\n\n\tstatic const char afterbody[] =\n\t\t\"</s:Body>\"\n\t\t\"</s:Envelope>\\r\\n\";\n\n\tint r = BuildHeader_upnphttp(h, 200, \"OK\",  sizeof(beforebody) - 1\n\t                             + sizeof(afterbody) - 1 + bodylen );\n\n\tif(r >= 0) {\n\t\tmemcpy(h->res_buf + h->res_buflen, beforebody, sizeof(beforebody) - 1);\n\t\th->res_buflen += sizeof(beforebody) - 1;\n\n\t\tmemcpy(h->res_buf + h->res_buflen, body, bodylen);\n\t\th->res_buflen += bodylen;\n\n\t\tmemcpy(h->res_buf + h->res_buflen, afterbody, sizeof(afterbody) - 1);\n\t\th->res_buflen += sizeof(afterbody) - 1;\n\t} else {\n\t\tBuildResp2_upnphttp(h, 500, \"Internal Server Error\", NULL, 0);\n\t}\n\n\tSendRespAndClose_upnphttp(h);\n}\n\nstatic void\nGetConnectionTypeInfo(struct upnphttp * h, const char * action, const char * ns)\n{\n#if 0\n\tstatic const char resp[] =\n\t\t\"<u:GetConnectionTypeInfoResponse \"\n\t\t\"xmlns:u=\\\"\" SERVICE_TYPE_WANIPC \"\\\">\"\n\t\t\"<NewConnectionType>IP_Routed</NewConnectionType>\"\n\t\t\"<NewPossibleConnectionTypes>IP_Routed</NewPossibleConnectionTypes>\"\n\t\t\"</u:GetConnectionTypeInfoResponse>\";\n#endif\n\tstatic const char resp[] =\n\t\t\"<u:%sResponse \"\n\t\t\"xmlns:u=\\\"%s\\\">\"\n\t\t\"<NewConnectionType>IP_Routed</NewConnectionType>\"\n\t\t\"<NewPossibleConnectionTypes>IP_Routed</NewPossibleConnectionTypes>\"\n\t\t\"</u:%sResponse>\";\n\tchar body[512];\n\tint bodylen;\n\n\tbodylen = snprintf(body, sizeof(body), resp,\n\t         action, ns, action);\n\tBuildSendAndCloseSoapResp(h, body, bodylen);\n}\n\n/* maximum value for a UPNP ui4 type variable */\n#define UPNP_UI4_MAX (4294967295ul)\n\nstatic void\nGetTotalBytesSent(struct upnphttp * h, const char * action, const char * ns)\n{\n\tint r;\n\n\tstatic const char resp[] =\n\t\t\"<u:%sResponse \"\n\t\t\"xmlns:u=\\\"%s\\\">\"\n\t\t\"<NewTotalBytesSent>%lu</NewTotalBytesSent>\"\n\t\t\"</u:%sResponse>\";\n\n\tchar body[512];\n\tint bodylen;\n\tstruct ifdata data;\n\n\tr = getifstats(ext_if_name, &data);\n\tbodylen = snprintf(body, sizeof(body), resp,\n\t         action, ns, /* was \"urn:schemas-upnp-org:service:WANCommonInterfaceConfig:1\" */\n#ifdef UPNP_STRICT\n             r<0?0:(data.obytes & UPNP_UI4_MAX), action);\n#else /* UPNP_STRICT */\n             r<0?0:data.obytes, action);\n#endif /* UPNP_STRICT */\n\tBuildSendAndCloseSoapResp(h, body, bodylen);\n}\n\nstatic void\nGetTotalBytesReceived(struct upnphttp * h, const char * action, const char * ns)\n{\n\tint r;\n\n\tstatic const char resp[] =\n\t\t\"<u:%sResponse \"\n\t\t\"xmlns:u=\\\"%s\\\">\"\n\t\t\"<NewTotalBytesReceived>%lu</NewTotalBytesReceived>\"\n\t\t\"</u:%sResponse>\";\n\n\tchar body[512];\n\tint bodylen;\n\tstruct ifdata data;\n\n\tr = getifstats(ext_if_name, &data);\n\t/* TotalBytesReceived\n\t * This variable represents the cumulative counter for total number of\n\t * bytes received downstream across all connection service instances on\n\t * WANDevice. The count rolls over to 0 after it reaching the maximum\n\t * value (2^32)-1. */\n\tbodylen = snprintf(body, sizeof(body), resp,\n\t         action, ns, /* was \"urn:schemas-upnp-org:service:WANCommonInterfaceConfig:1\" */\n#ifdef UPNP_STRICT\n\t         r<0?0:(data.ibytes & UPNP_UI4_MAX), action);\n#else /* UPNP_STRICT */\n\t         r<0?0:data.ibytes, action);\n#endif /* UPNP_STRICT */\n\tBuildSendAndCloseSoapResp(h, body, bodylen);\n}\n\nstatic void\nGetTotalPacketsSent(struct upnphttp * h, const char * action, const char * ns)\n{\n\tint r;\n\n\tstatic const char resp[] =\n\t\t\"<u:%sResponse \"\n\t\t\"xmlns:u=\\\"%s\\\">\"\n\t\t\"<NewTotalPacketsSent>%lu</NewTotalPacketsSent>\"\n\t\t\"</u:%sResponse>\";\n\n\tchar body[512];\n\tint bodylen;\n\tstruct ifdata data;\n\n\tr = getifstats(ext_if_name, &data);\n\tbodylen = snprintf(body, sizeof(body), resp,\n\t         action, ns,/*\"urn:schemas-upnp-org:service:WANCommonInterfaceConfig:1\",*/\n#ifdef UPNP_STRICT\n\t         r<0?0:(data.opackets & UPNP_UI4_MAX), action);\n#else /* UPNP_STRICT */\n\t         r<0?0:data.opackets, action);\n#endif /* UPNP_STRICT */\n\tBuildSendAndCloseSoapResp(h, body, bodylen);\n}\n\nstatic void\nGetTotalPacketsReceived(struct upnphttp * h, const char * action, const char * ns)\n{\n\tint r;\n\n\tstatic const char resp[] =\n\t\t\"<u:%sResponse \"\n\t\t\"xmlns:u=\\\"%s\\\">\"\n\t\t\"<NewTotalPacketsReceived>%lu</NewTotalPacketsReceived>\"\n\t\t\"</u:%sResponse>\";\n\n\tchar body[512];\n\tint bodylen;\n\tstruct ifdata data;\n\n\tr = getifstats(ext_if_name, &data);\n\tbodylen = snprintf(body, sizeof(body), resp,\n\t         action, ns, /* was \"urn:schemas-upnp-org:service:WANCommonInterfaceConfig:1\" */\n#ifdef UPNP_STRICT\n\t         r<0?0:(data.ipackets & UPNP_UI4_MAX), action);\n#else /* UPNP_STRICT */\n\t         r<0?0:data.ipackets, action);\n#endif /* UPNP_STRICT */\n\tBuildSendAndCloseSoapResp(h, body, bodylen);\n}\n\nstatic void\nGetCommonLinkProperties(struct upnphttp * h, const char * action, const char * ns)\n{\n\t/* WANAccessType : set depending on the hardware :\n\t * DSL, POTS (plain old Telephone service), Cable, Ethernet */\n\tstatic const char resp[] =\n\t\t\"<u:%sResponse \"\n\t\t\"xmlns:u=\\\"%s\\\">\"\n\t\t\"<NewWANAccessType>%s</NewWANAccessType>\"\n\t\t\"<NewLayer1UpstreamMaxBitRate>%lu</NewLayer1UpstreamMaxBitRate>\"\n\t\t\"<NewLayer1DownstreamMaxBitRate>%lu</NewLayer1DownstreamMaxBitRate>\"\n\t\t\"<NewPhysicalLinkStatus>%s</NewPhysicalLinkStatus>\"\n\t\t\"</u:%sResponse>\";\n\n\tchar body[2048];\n\tint bodylen;\n\tstruct ifdata data;\n\tconst char * status = \"Up\";\t/* Up, Down (Required),\n\t                             * Initializing, Unavailable (Optional) */\n\tconst char * wan_access_type = \"Cable\"; /* DSL, POTS, Cable, Ethernet */\n\tchar ext_ip_addr[INET_ADDRSTRLEN];\n\n\tif((downstream_bitrate == 0) || (upstream_bitrate == 0))\n\t{\n\t\tif(getifstats(ext_if_name, &data) >= 0)\n\t\t{\n\t\t\tif(downstream_bitrate == 0) downstream_bitrate = data.baudrate;\n\t\t\tif(upstream_bitrate == 0) upstream_bitrate = data.baudrate;\n\t\t}\n\t}\n\tif(getifaddr(ext_if_name, ext_ip_addr, INET_ADDRSTRLEN, NULL, NULL) < 0) {\n\t\tstatus = \"Down\";\n\t}\n\tbodylen = snprintf(body, sizeof(body), resp,\n\t    action, ns, /* was \"urn:schemas-upnp-org:service:WANCommonInterfaceConfig:1\" */\n\t    wan_access_type,\n\t    upstream_bitrate, downstream_bitrate,\n\t    status, action);\n\tBuildSendAndCloseSoapResp(h, body, bodylen);\n}\n\nstatic void\nGetStatusInfo(struct upnphttp * h, const char * action, const char * ns)\n{\n\tstatic const char resp[] =\n\t\t\"<u:%sResponse \"\n\t\t\"xmlns:u=\\\"%s\\\">\"\n\t\t\"<NewConnectionStatus>%s</NewConnectionStatus>\"\n\t\t\"<NewLastConnectionError>ERROR_NONE</NewLastConnectionError>\"\n\t\t\"<NewUptime>%ld</NewUptime>\"\n\t\t\"</u:%sResponse>\";\n\n\tchar body[512];\n\tint bodylen;\n\ttime_t uptime;\n\tconst char * status;\n\t/* ConnectionStatus possible values :\n\t * Unconfigured, Connecting, Connected, PendingDisconnect,\n\t * Disconnecting, Disconnected */\n\n\tstatus = get_wan_connection_status_str(ext_if_name);\n\tuptime = upnp_get_uptime();\n\tbodylen = snprintf(body, sizeof(body), resp,\n\t\taction, ns, /*SERVICE_TYPE_WANIPC,*/\n\t\tstatus, (long)uptime, action);\n\tBuildSendAndCloseSoapResp(h, body, bodylen);\n}\n\nstatic void\nGetNATRSIPStatus(struct upnphttp * h, const char * action, const char * ns)\n{\n#if 0\n\tstatic const char resp[] =\n\t\t\"<u:GetNATRSIPStatusResponse \"\n\t\t\"xmlns:u=\\\"\" SERVICE_TYPE_WANIPC \"\\\">\"\n\t\t\"<NewRSIPAvailable>0</NewRSIPAvailable>\"\n\t\t\"<NewNATEnabled>1</NewNATEnabled>\"\n\t\t\"</u:GetNATRSIPStatusResponse>\";\n\tUNUSED(action);\n#endif\n\tstatic const char resp[] =\n\t\t\"<u:%sResponse \"\n\t\t\"xmlns:u=\\\"%s\\\">\"\n\t\t\"<NewRSIPAvailable>0</NewRSIPAvailable>\"\n\t\t\"<NewNATEnabled>1</NewNATEnabled>\"\n\t\t\"</u:%sResponse>\";\n\tchar body[512];\n\tint bodylen;\n\t/* 2.2.9. RSIPAvailable\n\t * This variable indicates if Realm-specific IP (RSIP) is available\n\t * as a feature on the InternetGatewayDevice. RSIP is being defined\n\t * in the NAT working group in the IETF to allow host-NATing using\n\t * a standard set of message exchanges. It also allows end-to-end\n\t * applications that otherwise break if NAT is introduced\n\t * (e.g. IPsec-based VPNs).\n\t * A gateway that does not support RSIP should set this variable to 0. */\n\tbodylen = snprintf(body, sizeof(body), resp,\n\t\taction, ns, /*SERVICE_TYPE_WANIPC,*/\n\t\taction);\n\tBuildSendAndCloseSoapResp(h, body, bodylen);\n}\n\nstatic void\nGetExternalIPAddress(struct upnphttp * h, const char * action, const char * ns)\n{\n\tstatic const char resp[] =\n\t\t\"<u:%sResponse \"\n\t\t\"xmlns:u=\\\"%s\\\">\"\n\t\t\"<NewExternalIPAddress>%s</NewExternalIPAddress>\"\n\t\t\"</u:%sResponse>\";\n\n\tchar body[512];\n\tint bodylen;\n\tchar ext_ip_addr[INET_ADDRSTRLEN];\n\t/* Does that method need to work with IPv6 ?\n\t * There is usually no NAT with IPv6 */\n\n#ifndef MULTIPLE_EXTERNAL_IP\n\tstruct in_addr addr;\n\tif(use_ext_ip_addr)\n\t{\n\t\tstrncpy(ext_ip_addr, use_ext_ip_addr, INET_ADDRSTRLEN);\n\t\text_ip_addr[INET_ADDRSTRLEN - 1] = '\\0';\n\t}\n\telse if(getifaddr(ext_if_name, ext_ip_addr, INET_ADDRSTRLEN, &addr, NULL) < 0)\n\t{\n\t\tsyslog(LOG_ERR, \"Failed to get ip address for interface %s\",\n\t\t\text_if_name);\n\t\tstrncpy(ext_ip_addr, \"0.0.0.0\", INET_ADDRSTRLEN);\n\t}\n\tif (addr_is_reserved(&addr))\n\t\tstrncpy(ext_ip_addr, \"0.0.0.0\", INET_ADDRSTRLEN);\n#else\n\tstruct lan_addr_s * lan_addr;\n\tstrncpy(ext_ip_addr, \"0.0.0.0\", INET_ADDRSTRLEN);\n\tfor(lan_addr = lan_addrs.lh_first; lan_addr != NULL; lan_addr = lan_addr->list.le_next)\n\t{\n\t\tif( (h->clientaddr.s_addr & lan_addr->mask.s_addr)\n\t\t   == (lan_addr->addr.s_addr & lan_addr->mask.s_addr))\n\t\t{\n\t\t\tstrncpy(ext_ip_addr, lan_addr->ext_ip_str, INET_ADDRSTRLEN);\n\t\t\tbreak;\n\t\t}\n\t}\n#endif\n\tif (strcmp(ext_ip_addr, \"0.0.0.0\") == 0)\n\t{\n\t\tSoapError(h, 501, \"Action Failed\");\n\t\treturn;\n\t}\n\tbodylen = snprintf(body, sizeof(body), resp,\n\t              action, ns, /*SERVICE_TYPE_WANIPC,*/\n\t\t\t\t  ext_ip_addr, action);\n\tBuildSendAndCloseSoapResp(h, body, bodylen);\n}\n\n/* AddPortMapping method of WANIPConnection Service\n * Ignored argument : NewEnabled */\nstatic void\nAddPortMapping(struct upnphttp * h, const char * action, const char * ns)\n{\n\tint r;\n\n\t/*static const char resp[] =\n\t\t\"<u:AddPortMappingResponse \"\n\t\t\"xmlns:u=\\\"\" SERVICE_TYPE_WANIPC \"\\\"/>\";*/\n\tstatic const char resp[] =\n\t\t\"<u:%sResponse \"\n\t\t\"xmlns:u=\\\"%s\\\"/>\";\n\n\tchar body[512];\n\tint bodylen;\n\tstruct NameValueParserData data;\n\tchar * int_ip, * int_port, * ext_port, * protocol, * desc;\n\tchar * leaseduration_str;\n\tunsigned int leaseduration;\n\tchar * r_host;\n\tunsigned short iport, eport;\n\n\tstruct hostent *hp; /* getbyhostname() */\n\tchar ** ptr; /* getbyhostname() */\n\tstruct in_addr result_ip;/*unsigned char result_ip[16];*/ /* inet_pton() */\n\n\tParseNameValue(h->req_buf + h->req_contentoff, h->req_contentlen, &data);\n\tint_ip = GetValueFromNameValueList(&data, \"NewInternalClient\");\n\tif (int_ip) {\n\t\t/* trim */\n\t\twhile(int_ip[0] == ' ')\n\t\t\tint_ip++;\n\t}\n#ifdef UPNP_STRICT\n\tif (!int_ip || int_ip[0] == '\\0')\n\t{\n\t\tClearNameValueList(&data);\n\t\tSoapError(h, 402, \"Invalid Args\");\n\t\treturn;\n\t}\n#endif\n\n\t/* IGD 2 MUST support both wildcard and specific IP address values\n\t * for RemoteHost (only the wildcard value was REQUIRED in release 1.0) */\n\tr_host = GetValueFromNameValueList(&data, \"NewRemoteHost\");\n#ifndef SUPPORT_REMOTEHOST\n#ifdef UPNP_STRICT\n\tif (r_host && (r_host[0] != '\\0') && (0 != strcmp(r_host, \"*\")))\n\t{\n\t\tClearNameValueList(&data);\n\t\tSoapError(h, 726, \"RemoteHostOnlySupportsWildcard\");\n\t\treturn;\n\t}\n#endif\n#endif\n\n#ifndef UPNP_STRICT\n\t/* if <NewInternalClient> arg is empty, use client address\n\t * see https://github.com/miniupnp/miniupnp/issues/236 */\n\tif (!int_ip || int_ip[0] == '\\0')\n\t{\n\t\tint_ip = h->clientaddr_str;\n\t\tmemcpy(&result_ip, &(h->clientaddr), sizeof(struct in_addr));\n\t}\n\telse\n#endif\n\t/* if ip not valid assume hostname and convert */\n\tif (inet_pton(AF_INET, int_ip, &result_ip) <= 0)\n\t{\n\t\thp = gethostbyname(int_ip);\n\t\tif(hp && hp->h_addrtype == AF_INET)\n\t\t{\n\t\t\tfor(ptr = hp->h_addr_list; ptr && *ptr; ptr++)\n\t\t   \t{\n\t\t\t\tint_ip = inet_ntoa(*((struct in_addr *) *ptr));\n\t\t\t\tresult_ip = *((struct in_addr *) *ptr);\n\t\t\t\t/* TODO : deal with more than one ip per hostname */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsyslog(LOG_ERR, \"Failed to convert hostname '%s' to ip address\", int_ip);\n\t\t\tClearNameValueList(&data);\n\t\t\tSoapError(h, 402, \"Invalid Args\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* check if NewInternalAddress is the client address */\n\tif(GETFLAG(SECUREMODEMASK))\n\t{\n\t\tif(h->clientaddr.s_addr != result_ip.s_addr)\n\t\t{\n\t\t\tsyslog(LOG_INFO, \"Client %s tried to redirect port to %s\",\n\t\t\t       inet_ntoa(h->clientaddr), int_ip);\n\t\t\tClearNameValueList(&data);\n\t\t\tSoapError(h, 718, \"ConflictInMappingEntry\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\tint_port = GetValueFromNameValueList(&data, \"NewInternalPort\");\n\text_port = GetValueFromNameValueList(&data, \"NewExternalPort\");\n\tprotocol = GetValueFromNameValueList(&data, \"NewProtocol\");\n\tdesc = GetValueFromNameValueList(&data, \"NewPortMappingDescription\");\n\tleaseduration_str = GetValueFromNameValueList(&data, \"NewLeaseDuration\");\n\n\tif (!int_port || !ext_port || !protocol)\n\t{\n\t\tClearNameValueList(&data);\n\t\tSoapError(h, 402, \"Invalid Args\");\n\t\treturn;\n\t}\n\n\teport = (unsigned short)atoi(ext_port);\n\tiport = (unsigned short)atoi(int_port);\n\n\tif (strcmp(ext_port, \"*\") == 0 || eport == 0)\n\t{\n\t\tClearNameValueList(&data);\n\t\tSoapError(h, 716, \"Wildcard not permited in ExtPort\");\n\t\treturn;\n\t}\n\n\tleaseduration = leaseduration_str ? atoi(leaseduration_str) : 0;\n#ifdef IGD_V2\n\t/* PortMappingLeaseDuration can be either a value between 1 and\n\t * 604800 seconds or the zero value (for infinite lease time).\n\t * Note that an infinite lease time can be only set by out-of-band\n\t * mechanisms like WWW-administration, remote management or local\n\t * management.\n\t * If a control point uses the value 0 to indicate an infinite lease\n\t * time mapping, it is REQUIRED that gateway uses the maximum value\n\t * instead (e.g. 604800 seconds) */\n\tif(leaseduration == 0 || leaseduration > 604800)\n\t\tleaseduration = 604800;\n#endif\n\n\tsyslog(LOG_INFO, \"%s: ext port %hu to %s:%hu protocol %s for: %s leaseduration=%u rhost=%s\",\n\t       action, eport, int_ip, iport, protocol, desc, leaseduration,\n\t       r_host ? r_host : \"NULL\");\n\n\tr = upnp_redirect(r_host, eport, int_ip, iport, protocol, desc, leaseduration);\n\n\tClearNameValueList(&data);\n\n\t/* possible error codes for AddPortMapping :\n\t * 402 - Invalid Args\n\t * 501 - Action Failed\n\t * 715 - Wildcard not permited in SrcAddr\n\t * 716 - Wildcard not permited in ExtPort\n\t * 718 - ConflictInMappingEntry\n\t * 724 - SamePortValuesRequired (deprecated in IGD v2)\n     * 725 - OnlyPermanentLeasesSupported\n             The NAT implementation only supports permanent lease times on\n             port mappings (deprecated in IGD v2)\n     * 726 - RemoteHostOnlySupportsWildcard\n             RemoteHost must be a wildcard and cannot be a specific IP\n             address or DNS name (deprecated in IGD v2)\n     * 727 - ExternalPortOnlySupportsWildcard\n             ExternalPort must be a wildcard and cannot be a specific port\n             value (deprecated in IGD v2)\n     * 728 - NoPortMapsAvailable\n             There are not enough free ports available to complete the mapping\n             (added in IGD v2)\n\t * 729 - ConflictWithOtherMechanisms (added in IGD v2) */\n\tswitch(r)\n\t{\n\tcase 0:\t/* success */\n\t\tbodylen = snprintf(body, sizeof(body), resp,\n\t\t                   action, ns/*SERVICE_TYPE_WANIPC*/);\n\t\tBuildSendAndCloseSoapResp(h, body, bodylen);\n\t\tbreak;\n\tcase -4:\n#ifdef IGD_V2\n\t\tSoapError(h, 729, \"ConflictWithOtherMechanisms\");\n\t\tbreak;\n#endif /* IGD_V2 */\n\tcase -2:\t/* already redirected */\n\tcase -3:\t/* not permitted */\n\t\tSoapError(h, 718, \"ConflictInMappingEntry\");\n\t\tbreak;\n\tdefault:\n\t\tSoapError(h, 501, \"ActionFailed\");\n\t}\n}\n\n/* AddAnyPortMapping was added in WANIPConnection v2 */\nstatic void\nAddAnyPortMapping(struct upnphttp * h, const char * action, const char * ns)\n{\n\tint r;\n\tstatic const char resp[] =\n\t\t\"<u:%sResponse \"\n\t\t\"xmlns:u=\\\"%s\\\">\"\n\t\t\"<NewReservedPort>%hu</NewReservedPort>\"\n\t\t\"</u:%sResponse>\";\n\n\tchar body[512];\n\tint bodylen;\n\n\tstruct NameValueParserData data;\n\tconst char * int_ip, * int_port, * ext_port, * protocol, * desc;\n\tconst char * r_host;\n\tunsigned short iport, eport;\n\tconst char * leaseduration_str;\n\tunsigned int leaseduration;\n\n\tstruct hostent *hp; /* getbyhostname() */\n\tchar ** ptr; /* getbyhostname() */\n\tstruct in_addr result_ip;/*unsigned char result_ip[16];*/ /* inet_pton() */\n\n\tParseNameValue(h->req_buf + h->req_contentoff, h->req_contentlen, &data);\n\tr_host = GetValueFromNameValueList(&data, \"NewRemoteHost\");\n\text_port = GetValueFromNameValueList(&data, \"NewExternalPort\");\n\tprotocol = GetValueFromNameValueList(&data, \"NewProtocol\");\n\tint_port = GetValueFromNameValueList(&data, \"NewInternalPort\");\n\tint_ip = GetValueFromNameValueList(&data, \"NewInternalClient\");\n\t/* NewEnabled */\n\tdesc = GetValueFromNameValueList(&data, \"NewPortMappingDescription\");\n\tleaseduration_str = GetValueFromNameValueList(&data, \"NewLeaseDuration\");\n\n\tleaseduration = leaseduration_str ? atoi(leaseduration_str) : 0;\n\tif(leaseduration == 0)\n\t\tleaseduration = 604800;\n\n\tif (!int_ip || !ext_port || !int_port)\n\t{\n\t\tClearNameValueList(&data);\n\t\tSoapError(h, 402, \"Invalid Args\");\n\t\treturn;\n\t}\n\n\teport = (unsigned short)atoi(ext_port);\n\tiport = (unsigned short)atoi(int_port);\n\tif(iport == 0 || !is_numeric(ext_port)) {\n\t\tClearNameValueList(&data);\n\t\tSoapError(h, 402, \"Invalid Args\");\n\t\treturn;\n\t}\n#ifndef SUPPORT_REMOTEHOST\n#ifdef UPNP_STRICT\n\tif (r_host && (r_host[0] != '\\0') && (0 != strcmp(r_host, \"*\")))\n\t{\n\t\tClearNameValueList(&data);\n\t\tSoapError(h, 726, \"RemoteHostOnlySupportsWildcard\");\n\t\treturn;\n\t}\n#endif\n#endif\n\n\t/* if ip not valid assume hostname and convert */\n\tif (inet_pton(AF_INET, int_ip, &result_ip) <= 0)\n\t{\n\t\thp = gethostbyname(int_ip);\n\t\tif(hp && hp->h_addrtype == AF_INET)\n\t\t{\n\t\t\tfor(ptr = hp->h_addr_list; ptr && *ptr; ptr++)\n\t\t   \t{\n\t\t\t\tint_ip = inet_ntoa(*((struct in_addr *) *ptr));\n\t\t\t\tresult_ip = *((struct in_addr *) *ptr);\n\t\t\t\t/* TODO : deal with more than one ip per hostname */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsyslog(LOG_ERR, \"Failed to convert hostname '%s' to ip address\", int_ip);\n\t\t\tClearNameValueList(&data);\n\t\t\tSoapError(h, 402, \"Invalid Args\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* check if NewInternalAddress is the client address */\n\tif(GETFLAG(SECUREMODEMASK))\n\t{\n\t\tif(h->clientaddr.s_addr != result_ip.s_addr)\n\t\t{\n\t\t\tsyslog(LOG_INFO, \"Client %s tried to redirect port to %s\",\n\t\t\t       inet_ntoa(h->clientaddr), int_ip);\n\t\t\tClearNameValueList(&data);\n\t\t\tSoapError(h, 606, \"Action not authorized\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* TODO : accept a different external port\n\t * have some smart strategy to choose the port */\n\tfor(;;) {\n\t\tr = upnp_redirect(r_host, eport, int_ip, iport, protocol, desc, leaseduration);\n\t\tif(r==-2 && eport < 65535) {\n\t\t\teport++;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tClearNameValueList(&data);\n\n\tswitch(r)\n\t{\n\tcase 0:\t/* success */\n\t\tbodylen = snprintf(body, sizeof(body), resp,\n\t\t              action, ns, /*SERVICE_TYPE_WANIPC,*/\n\t\t\t\t\t  eport, action);\n\t\tBuildSendAndCloseSoapResp(h, body, bodylen);\n\t\tbreak;\n\tcase -2:\t/* already redirected */\n\t\tSoapError(h, 718, \"ConflictInMappingEntry\");\n\t\tbreak;\n\tcase -3:\t/* not permitted */\n\t\tSoapError(h, 606, \"Action not authorized\");\n\t\tbreak;\n\tdefault:\n\t\tSoapError(h, 501, \"ActionFailed\");\n\t}\n}\n\nstatic void\nGetSpecificPortMappingEntry(struct upnphttp * h, const char * action, const char * ns)\n{\n\tint r;\n\n\tstatic const char resp[] =\n\t\t\"<u:%sResponse \"\n\t\t\"xmlns:u=\\\"%s\\\">\"\n\t\t\"<NewInternalPort>%u</NewInternalPort>\"\n\t\t\"<NewInternalClient>%s</NewInternalClient>\"\n\t\t\"<NewEnabled>1</NewEnabled>\"\n\t\t\"<NewPortMappingDescription>%s</NewPortMappingDescription>\"\n\t\t\"<NewLeaseDuration>%u</NewLeaseDuration>\"\n\t\t\"</u:%sResponse>\";\n\n\tchar body[1024];\n\tint bodylen;\n\tstruct NameValueParserData data;\n\tconst char * r_host, * ext_port, * protocol;\n\tunsigned short eport, iport;\n\tchar int_ip[32];\n\tchar desc[64];\n\tunsigned int leaseduration = 0;\n\n\tParseNameValue(h->req_buf + h->req_contentoff, h->req_contentlen, &data);\n\tr_host = GetValueFromNameValueList(&data, \"NewRemoteHost\");\n\text_port = GetValueFromNameValueList(&data, \"NewExternalPort\");\n\tprotocol = GetValueFromNameValueList(&data, \"NewProtocol\");\n\n#ifdef UPNP_STRICT\n\tif(!ext_port || !protocol || !r_host)\n#else\n\tif(!ext_port || !protocol)\n#endif\n\t{\n\t\tClearNameValueList(&data);\n\t\tSoapError(h, 402, \"Invalid Args\");\n\t\treturn;\n\t}\n#ifndef SUPPORT_REMOTEHOST\n#ifdef UPNP_STRICT\n\tif (r_host && (r_host[0] != '\\0') && (0 != strcmp(r_host, \"*\")))\n\t{\n\t\tClearNameValueList(&data);\n\t\tSoapError(h, 726, \"RemoteHostOnlySupportsWildcard\");\n\t\treturn;\n\t}\n#endif\n#endif\n\n\teport = (unsigned short)atoi(ext_port);\n\tif(eport == 0)\n\t{\n\t\tClearNameValueList(&data);\n\t\tSoapError(h, 402, \"Invalid Args\");\n\t\treturn;\n\t}\n\n\t/* TODO : add r_host as an input parameter ...\n\t * We prevent several Port Mapping with same external port\n\t * but different remoteHost to be set up, so that is not\n\t * a priority. */\n\tr = upnp_get_redirection_infos(eport, protocol, &iport,\n\t                               int_ip, sizeof(int_ip),\n\t                               desc, sizeof(desc),\n\t                               NULL, 0,\n\t                               &leaseduration);\n\n\tif(r < 0)\n\t{\n\t\tSoapError(h, 714, \"NoSuchEntryInArray\");\n\t}\n\telse\n\t{\n\t\tsyslog(LOG_INFO, \"%s: rhost='%s' %s %s found => %s:%u desc='%s'\",\n\t\t       action,\n\t\t       r_host ? r_host : \"NULL\", ext_port, protocol, int_ip,\n\t\t       (unsigned int)iport, desc);\n\t\tbodylen = snprintf(body, sizeof(body), resp,\n\t\t\t\taction, ns/*SERVICE_TYPE_WANIPC*/,\n\t\t\t\t(unsigned int)iport, int_ip, desc, leaseduration,\n\t\t\t\taction);\n\t\tBuildSendAndCloseSoapResp(h, body, bodylen);\n\t}\n\n\tClearNameValueList(&data);\n}\n\nstatic void\nDeletePortMapping(struct upnphttp * h, const char * action, const char * ns)\n{\n\tint r;\n\n\t/*static const char resp[] =\n\t\t\"<u:DeletePortMappingResponse \"\n\t\t\"xmlns:u=\\\"\" SERVICE_TYPE_WANIPC \"\\\">\"\n\t\t\"</u:DeletePortMappingResponse>\";*/\n\tstatic const char resp[] =\n\t\t\"<u:%sResponse \"\n\t\t\"xmlns:u=\\\"%s\\\">\"\n\t\t\"</u:%sResponse>\";\n\n\tchar body[512];\n\tint bodylen;\n\tstruct NameValueParserData data;\n\tconst char * ext_port, * protocol;\n\tunsigned short eport;\n#ifdef UPNP_STRICT\n\tconst char * r_host;\n#endif /* UPNP_STRICT */\n\n\tParseNameValue(h->req_buf + h->req_contentoff, h->req_contentlen, &data);\n\text_port = GetValueFromNameValueList(&data, \"NewExternalPort\");\n\tprotocol = GetValueFromNameValueList(&data, \"NewProtocol\");\n#ifdef UPNP_STRICT\n\tr_host = GetValueFromNameValueList(&data, \"NewRemoteHost\");\n#endif /* UPNP_STRICT */\n\n#ifdef UPNP_STRICT\n\tif(!ext_port || !protocol || !r_host)\n#else\n\tif(!ext_port || !protocol)\n#endif /* UPNP_STRICT */\n\t{\n\t\tClearNameValueList(&data);\n\t\tSoapError(h, 402, \"Invalid Args\");\n\t\treturn;\n\t}\n#ifndef SUPPORT_REMOTEHOST\n#ifdef UPNP_STRICT\n\tif (r_host && (r_host[0] != '\\0') && (0 != strcmp(r_host, \"*\")))\n\t{\n\t\tClearNameValueList(&data);\n\t\tSoapError(h, 726, \"RemoteHostOnlySupportsWildcard\");\n\t\treturn;\n\t}\n#endif /* UPNP_STRICT */\n#endif /* SUPPORT_REMOTEHOST */\n\n\teport = (unsigned short)atoi(ext_port);\n\tif(eport == 0)\n\t{\n\t\tClearNameValueList(&data);\n\t\tSoapError(h, 402, \"Invalid Args\");\n\t\treturn;\n\t}\n\n\tsyslog(LOG_INFO, \"%s: external port: %hu, protocol: %s\",\n\t\taction, eport, protocol);\n\n\t/* if in secure mode, check the IP\n\t * Removing a redirection is not a security threat,\n\t * just an annoyance for the user using it. So this is not\n\t * a priority. */\n\tif(GETFLAG(SECUREMODEMASK))\n\t{\n\t\tchar int_ip[32];\n\t\tstruct in_addr int_ip_addr;\n\t\tunsigned short iport;\n\t\tunsigned int leaseduration = 0;\n\t\tr = upnp_get_redirection_infos(eport, protocol, &iport,\n\t\t                               int_ip, sizeof(int_ip),\n\t\t                               NULL, 0, NULL, 0,\n\t\t                               &leaseduration);\n\t\tif(r >= 0)\n\t\t{\n\t\t\tif(inet_pton(AF_INET, int_ip, &int_ip_addr) > 0)\n\t\t\t{\n\t\t\t\tif(h->clientaddr.s_addr != int_ip_addr.s_addr)\n\t\t\t\t{\n\t\t\t\t\tSoapError(h, 606, \"Action not authorized\");\n\t\t\t\t\t/*SoapError(h, 714, \"NoSuchEntryInArray\");*/\n\t\t\t\t\tClearNameValueList(&data);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tr = upnp_delete_redirection(eport, protocol);\n\n\tif(r < 0)\n\t{\n\t\tSoapError(h, 714, \"NoSuchEntryInArray\");\n\t}\n\telse\n\t{\n\t\tbodylen = snprintf(body, sizeof(body), resp,\n\t\t                   action, ns, action);\n\t\tBuildSendAndCloseSoapResp(h, body, bodylen);\n\t}\n\n\tClearNameValueList(&data);\n}\n\n/* DeletePortMappingRange was added in IGD spec v2 */\nstatic void\nDeletePortMappingRange(struct upnphttp * h, const char * action, const char * ns)\n{\n\tint r = -1;\n\t/*static const char resp[] =\n\t\t\"<u:DeletePortMappingRangeResponse \"\n\t\t\"xmlns:u=\\\"\" SERVICE_TYPE_WANIPC \"\\\">\"\n\t\t\"</u:DeletePortMappingRangeResponse>\";*/\n\tstatic const char resp[] =\n\t\t\"<u:%sResponse \"\n\t\t\"xmlns:u=\\\"%s\\\">\"\n\t\t\"</u:%sResponse>\";\n\tchar body[512];\n\tint bodylen;\n\tstruct NameValueParserData data;\n\tconst char * protocol;\n\tconst char * startport_s, * endport_s;\n\tunsigned short startport, endport;\n\t/*int manage;*/\n\tunsigned short * port_list;\n\tunsigned int i, number = 0;\n\n\tParseNameValue(h->req_buf + h->req_contentoff, h->req_contentlen, &data);\n\tstartport_s = GetValueFromNameValueList(&data, \"NewStartPort\");\n\tendport_s = GetValueFromNameValueList(&data, \"NewEndPort\");\n\tprotocol = GetValueFromNameValueList(&data, \"NewProtocol\");\n\t/*manage = atoi(GetValueFromNameValueList(&data, \"NewManage\"));*/\n\tif(startport_s == NULL || endport_s == NULL || protocol == NULL ||\n\t   !is_numeric(startport_s) || !is_numeric(endport_s)) {\n\t\tSoapError(h, 402, \"Invalid Args\");\n\t\tClearNameValueList(&data);\n\t\treturn;\n\t}\n\tstartport = (unsigned short)atoi(startport_s);\n\tendport = (unsigned short)atoi(endport_s);\n\n\t/* possible errors :\n\t   606 - Action not authorized\n\t   730 - PortMappingNotFound\n\t   733 - InconsistentParameter\n\t */\n\tif(startport > endport)\n\t{\n\t\tSoapError(h, 733, \"InconsistentParameter\");\n\t\tClearNameValueList(&data);\n\t\treturn;\n\t}\n\n\tsyslog(LOG_INFO, \"%s: deleting external ports: %hu-%hu, protocol: %s\",\n\t       action, startport, endport, protocol);\n\n\tport_list = upnp_get_portmappings_in_range(startport, endport,\n\t                                           protocol, &number);\n\tif(number == 0)\n\t{\n\t\tSoapError(h, 730, \"PortMappingNotFound\");\n\t\tClearNameValueList(&data);\n\t\tfree(port_list);\n\t\treturn;\n\t}\n\n\tfor(i = 0; i < number; i++)\n\t{\n\t\tr = upnp_delete_redirection(port_list[i], protocol);\n\t\tsyslog(LOG_INFO, \"%s: deleting external port: %hu, protocol: %s: %s\",\n\t\t       action, port_list[i], protocol, r < 0 ? \"failed\" : \"ok\");\n\t}\n\tfree(port_list);\n\tbodylen = snprintf(body, sizeof(body), resp,\n\t                   action, ns, action);\n\tBuildSendAndCloseSoapResp(h, body, bodylen);\n\n\tClearNameValueList(&data);\n}\n\nstatic void\nGetGenericPortMappingEntry(struct upnphttp * h, const char * action, const char * ns)\n{\n\tint r;\n\n\tstatic const char resp[] =\n\t\t\"<u:%sResponse \"\n\t\t\"xmlns:u=\\\"%s\\\">\"\n\t\t\"<NewRemoteHost>%s</NewRemoteHost>\"\n\t\t\"<NewExternalPort>%u</NewExternalPort>\"\n\t\t\"<NewProtocol>%s</NewProtocol>\"\n\t\t\"<NewInternalPort>%u</NewInternalPort>\"\n\t\t\"<NewInternalClient>%s</NewInternalClient>\"\n\t\t\"<NewEnabled>1</NewEnabled>\"\n\t\t\"<NewPortMappingDescription>%s</NewPortMappingDescription>\"\n\t\t\"<NewLeaseDuration>%u</NewLeaseDuration>\"\n\t\t\"</u:%sResponse>\";\n\n\tlong int index = 0;\n\tunsigned short eport, iport;\n\tconst char * m_index;\n\tchar * endptr;\n\tchar protocol[8], iaddr[32];\n\tchar desc[64];\n\tchar rhost[40];\n\tunsigned int leaseduration = 0;\n\tstruct NameValueParserData data;\n\n\tParseNameValue(h->req_buf + h->req_contentoff, h->req_contentlen, &data);\n\tm_index = GetValueFromNameValueList(&data, \"NewPortMappingIndex\");\n\n\tif(!m_index)\n\t{\n\t\tClearNameValueList(&data);\n\t\tSoapError(h, 402, \"Invalid Args\");\n\t\treturn;\n\t}\n\terrno = 0;\t/* To distinguish success/failure after call */\n\tindex = strtol(m_index, &endptr, 10);\n\tif((errno == ERANGE && (index == LONG_MAX || index == LONG_MIN))\n\t   || (errno != 0 && index == 0) || (m_index == endptr))\n\t{\n\t\t/* should condition (*endptr != '\\0') be also an error ? */\n\t\tif(m_index == endptr)\n\t\t\tsyslog(LOG_WARNING, \"%s: no digits were found in <%s>\",\n\t\t\t       \"GetGenericPortMappingEntry\", \"NewPortMappingIndex\");\n\t\telse\n\t\t\tsyslog(LOG_WARNING, \"%s: strtol('%s'): %m\",\n\t\t\t       \"GetGenericPortMappingEntry\", m_index);\n\t\tClearNameValueList(&data);\n\t\tSoapError(h, 402, \"Invalid Args\");\n\t\treturn;\n\t}\n\n\tsyslog(LOG_INFO, \"%s: index=%d\", action, (int)index);\n\n\trhost[0] = '\\0';\n\tr = upnp_get_redirection_infos_by_index((int)index, &eport, protocol, &iport,\n                                            iaddr, sizeof(iaddr),\n\t                                        desc, sizeof(desc),\n\t                                        rhost, sizeof(rhost),\n\t                                        &leaseduration);\n\n\tif(r < 0)\n\t{\n\t\tSoapError(h, 713, \"SpecifiedArrayIndexInvalid\");\n\t}\n\telse\n\t{\n\t\tint bodylen;\n\t\tchar body[2048];\n\t\tbodylen = snprintf(body, sizeof(body), resp,\n\t\t\taction, ns, /*SERVICE_TYPE_WANIPC,*/ rhost,\n\t\t\t(unsigned int)eport, protocol, (unsigned int)iport, iaddr, desc,\n\t\t    leaseduration, action);\n\t\tBuildSendAndCloseSoapResp(h, body, bodylen);\n\t}\n\n\tClearNameValueList(&data);\n}\n\n/* GetListOfPortMappings was added in the IGD v2 specification */\nstatic void\nGetListOfPortMappings(struct upnphttp * h, const char * action, const char * ns)\n{\n\tstatic const char resp_start[] =\n\t\t\"<u:%sResponse \"\n\t\t\"xmlns:u=\\\"%s\\\">\"\n\t\t\"<NewPortListing><![CDATA[\";\n\tstatic const char resp_end[] =\n\t\t\"]]></NewPortListing>\"\n\t\t\"</u:%sResponse>\";\n\n\tstatic const char list_start[] =\n\t\t\"<p:PortMappingList xmlns:p=\\\"urn:schemas-upnp-org:gw:WANIPConnection\\\"\"\n\t\t\" xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\"\"\n\t\t\" xsi:schemaLocation=\\\"urn:schemas-upnp-org:gw:WANIPConnection\"\n\t\t\" http://www.upnp.org/schemas/gw/WANIPConnection-v2.xsd\\\">\";\n\tstatic const char list_end[] =\n\t\t\"</p:PortMappingList>\";\n\n\tstatic const char entry[] =\n\t\t\"<p:PortMappingEntry>\"\n\t\t\"<p:NewRemoteHost>%s</p:NewRemoteHost>\"\n\t\t\"<p:NewExternalPort>%hu</p:NewExternalPort>\"\n\t\t\"<p:NewProtocol>%s</p:NewProtocol>\"\n\t\t\"<p:NewInternalPort>%hu</p:NewInternalPort>\"\n\t\t\"<p:NewInternalClient>%s</p:NewInternalClient>\"\n\t\t\"<p:NewEnabled>1</p:NewEnabled>\"\n\t\t\"<p:NewDescription>%s</p:NewDescription>\"\n\t\t\"<p:NewLeaseTime>%u</p:NewLeaseTime>\"\n\t\t\"</p:PortMappingEntry>\";\n\n\tchar * body;\n\tsize_t bodyalloc;\n\tint bodylen;\n\n\tint r = -1;\n\tunsigned short iport;\n\tchar int_ip[32];\n\tchar desc[64];\n\tchar rhost[64];\n\tunsigned int leaseduration = 0;\n\n\tstruct NameValueParserData data;\n\tconst char * startport_s, * endport_s;\n\tunsigned short startport, endport;\n\tconst char * protocol;\n\t/*int manage;*/\n\tconst char * number_s;\n\tint number;\n\tunsigned short * port_list;\n\tunsigned int i, list_size = 0;\n\n\tParseNameValue(h->req_buf + h->req_contentoff, h->req_contentlen, &data);\n\tstartport_s = GetValueFromNameValueList(&data, \"NewStartPort\");\n\tendport_s = GetValueFromNameValueList(&data, \"NewEndPort\");\n\tprotocol = GetValueFromNameValueList(&data, \"NewProtocol\");\n\t/*manage_s = GetValueFromNameValueList(&data, \"NewManage\");*/\n\tnumber_s = GetValueFromNameValueList(&data, \"NewNumberOfPorts\");\n\tif(startport_s == NULL || endport_s == NULL || protocol == NULL ||\n\t   number_s == NULL || !is_numeric(number_s) ||\n\t   !is_numeric(startport_s) || !is_numeric(endport_s)) {\n\t\tSoapError(h, 402, \"Invalid Args\");\n\t\tClearNameValueList(&data);\n\t\treturn;\n\t}\n\n\tstartport = (unsigned short)atoi(startport_s);\n\tendport = (unsigned short)atoi(endport_s);\n\t/*manage = atoi(manage_s);*/\n\tnumber = atoi(number_s);\n\tif(number == 0) number = 1000;\t/* return up to 1000 mappings by default */\n\n\tif(startport > endport)\n\t{\n\t\tSoapError(h, 733, \"InconsistentParameter\");\n\t\tClearNameValueList(&data);\n\t\treturn;\n\t}\n/*\nbuild the PortMappingList xml document :\n\n<p:PortMappingList xmlns:p=\"urn:schemas-upnp-org:gw:WANIPConnection\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxsi:schemaLocation=\"urn:schemas-upnp-org:gw:WANIPConnection\nhttp://www.upnp.org/schemas/gw/WANIPConnection-v2.xsd\">\n<p:PortMappingEntry>\n<p:NewRemoteHost>202.233.2.1</p:NewRemoteHost>\n<p:NewExternalPort>2345</p:NewExternalPort>\n<p:NewProtocol>TCP</p:NewProtocol>\n<p:NewInternalPort>2345</p:NewInternalPort>\n<p:NewInternalClient>192.168.1.137</p:NewInternalClient>\n<p:NewEnabled>1</p:NewEnabled>\n<p:NewDescription>dooom</p:NewDescription>\n<p:NewLeaseTime>345</p:NewLeaseTime>\n</p:PortMappingEntry>\n</p:PortMappingList>\n*/\n\tbodyalloc = 4096;\n\tbody = malloc(bodyalloc);\n\tif(!body)\n\t{\n\t\tClearNameValueList(&data);\n\t\tSoapError(h, 501, \"ActionFailed\");\n\t\treturn;\n\t}\n\tbodylen = snprintf(body, bodyalloc, resp_start,\n\t              action, ns/*SERVICE_TYPE_WANIPC*/);\n\tif(bodylen < 0)\n\t{\n\t\tSoapError(h, 501, \"ActionFailed\");\n\t\tfree(body);\n\t\treturn;\n\t}\n\tmemcpy(body+bodylen, list_start, sizeof(list_start));\n\tbodylen += (sizeof(list_start) - 1);\n\n\tport_list = upnp_get_portmappings_in_range(startport, endport,\n\t                                           protocol, &list_size);\n\t/* loop through port mappings */\n\tfor(i = 0; number > 0 && i < list_size; i++)\n\t{\n\t\t/* have a margin of 1024 bytes to store the new entry */\n\t\tif((unsigned int)bodylen + 1024 > bodyalloc)\n\t\t{\n\t\t\tchar * body_sav = body;\n\t\t\tbodyalloc += 4096;\n\t\t\tbody = realloc(body, bodyalloc);\n\t\t\tif(!body)\n\t\t\t{\n\t\t\t\tsyslog(LOG_CRIT, \"realloc(%p, %u) FAILED\", body_sav, (unsigned)bodyalloc);\n\t\t\t\tClearNameValueList(&data);\n\t\t\t\tSoapError(h, 501, \"ActionFailed\");\n\t\t\t\tfree(body_sav);\n\t\t\t\tfree(port_list);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\trhost[0] = '\\0';\n\t\tr = upnp_get_redirection_infos(port_list[i], protocol, &iport,\n\t\t                               int_ip, sizeof(int_ip),\n\t\t                               desc, sizeof(desc),\n\t\t                               rhost, sizeof(rhost),\n\t\t                               &leaseduration);\n\t\tif(r == 0)\n\t\t{\n\t\t\tbodylen += snprintf(body+bodylen, bodyalloc-bodylen, entry,\n\t\t\t                    rhost, port_list[i], protocol,\n\t\t\t                    iport, int_ip, desc, leaseduration);\n\t\t\tnumber--;\n\t\t}\n\t}\n\tfree(port_list);\n\tport_list = NULL;\n\n\tif((bodylen + sizeof(list_end) + 1024) > bodyalloc)\n\t{\n\t\tchar * body_sav = body;\n\t\tbodyalloc += (sizeof(list_end) + 1024);\n\t\tbody = realloc(body, bodyalloc);\n\t\tif(!body)\n\t\t{\n\t\t\tsyslog(LOG_CRIT, \"realloc(%p, %u) FAILED\", body_sav, (unsigned)bodyalloc);\n\t\t\tClearNameValueList(&data);\n\t\t\tSoapError(h, 501, \"ActionFailed\");\n\t\t\tfree(body_sav);\n\t\t\treturn;\n\t\t}\n\t}\n\tmemcpy(body+bodylen, list_end, sizeof(list_end));\n\tbodylen += (sizeof(list_end) - 1);\n\tbodylen += snprintf(body+bodylen, bodyalloc-bodylen, resp_end,\n\t                    action);\n\tBuildSendAndCloseSoapResp(h, body, bodylen);\n\tfree(body);\n\n\tClearNameValueList(&data);\n}\n\n#ifdef ENABLE_L3F_SERVICE\nstatic void\nSetDefaultConnectionService(struct upnphttp * h, const char * action, const char * ns)\n{\n\t/*static const char resp[] =\n\t\t\"<u:SetDefaultConnectionServiceResponse \"\n\t\t\"xmlns:u=\\\"urn:schemas-upnp-org:service:Layer3Forwarding:1\\\">\"\n\t\t\"</u:SetDefaultConnectionServiceResponse>\";*/\n\tstatic const char resp[] =\n\t\t\"<u:%sResponse \"\n\t\t\"xmlns:u=\\\"%s\\\">\"\n\t\t\"</u:%sResponse>\";\n\tchar body[512];\n\tint bodylen;\n\tstruct NameValueParserData data;\n\tchar * p;\n\tParseNameValue(h->req_buf + h->req_contentoff, h->req_contentlen, &data);\n\tp = GetValueFromNameValueList(&data, \"NewDefaultConnectionService\");\n\tif(p) {\n\t\t/* 720 InvalidDeviceUUID\n\t\t * 721 InvalidServiceID\n\t\t * 723 InvalidConnServiceSelection */\n#ifdef UPNP_STRICT\n\t\tchar * service;\n\t\tservice = strchr(p, ',');\n\t\tif(0 != memcmp(uuidvalue_wcd, p, sizeof(\"uuid:00000000-0000-0000-0000-000000000000\") - 1)) {\n\t\t\tSoapError(h, 720, \"InvalidDeviceUUID\");\n\t\t} else if(service == NULL || 0 != strcmp(service+1, SERVICE_ID_WANIPC)) {\n\t\t\tSoapError(h, 721, \"InvalidServiceID\");\n\t\t} else\n#endif\n\t\t{\n\t\t\tsyslog(LOG_INFO, \"%s(%s) : Ignored\", action, p);\n\t\t\tbodylen = snprintf(body, sizeof(body), resp,\n\t\t\t                   action, ns, action);\n\t\t\tBuildSendAndCloseSoapResp(h, body, bodylen);\n\t\t}\n\t} else {\n\t\t/* missing argument */\n\t\tSoapError(h, 402, \"Invalid Args\");\n\t}\n\tClearNameValueList(&data);\n}\n\nstatic void\nGetDefaultConnectionService(struct upnphttp * h, const char * action, const char * ns)\n{\n\tstatic const char resp[] =\n\t\t\"<u:%sResponse \"\n\t\t\"xmlns:u=\\\"%s\\\">\"\n#ifdef IGD_V2\n\t\t\"<NewDefaultConnectionService>%s:WANConnectionDevice:2,\"\n#else\n\t\t\"<NewDefaultConnectionService>%s:WANConnectionDevice:1,\"\n#endif\n\t\tSERVICE_ID_WANIPC \"</NewDefaultConnectionService>\"\n\t\t\"</u:%sResponse>\";\n\t/* example from UPnP_IGD_Layer3Forwarding 1.0.pdf :\n\t * uuid:44f5824f-c57d-418c-a131-f22b34e14111:WANConnectionDevice:1,\n\t * urn:upnp-org:serviceId:WANPPPConn1 */\n\tchar body[1024];\n\tint bodylen;\n\n\t/* namespace : urn:schemas-upnp-org:service:Layer3Forwarding:1 */\n\tbodylen = snprintf(body, sizeof(body), resp,\n\t                   action, ns, uuidvalue_wcd, action);\n\tBuildSendAndCloseSoapResp(h, body, bodylen);\n}\n#endif\n\n/* Added for compliance with WANIPConnection v2 */\nstatic void\nSetConnectionType(struct upnphttp * h, const char * action, const char * ns)\n{\n#ifdef UPNP_STRICT\n\tconst char * connection_type;\n#endif /* UPNP_STRICT */\n\tstruct NameValueParserData data;\n\tUNUSED(action);\n\tUNUSED(ns);\n\n\tParseNameValue(h->req_buf + h->req_contentoff, h->req_contentlen, &data);\n#ifdef UPNP_STRICT\n\tconnection_type = GetValueFromNameValueList(&data, \"NewConnectionType\");\n\tif(!connection_type) {\n\t\tClearNameValueList(&data);\n\t\tSoapError(h, 402, \"Invalid Args\");\n\t\treturn;\n\t}\n#endif /* UPNP_STRICT */\n\t/* Unconfigured, IP_Routed, IP_Bridged */\n\tClearNameValueList(&data);\n\t/* always return a ReadOnly error */\n\tSoapError(h, 731, \"ReadOnly\");\n}\n\n/* Added for compliance with WANIPConnection v2 */\nstatic void\nRequestConnection(struct upnphttp * h, const char * action, const char * ns)\n{\n\tUNUSED(action);\n\tUNUSED(ns);\n\tSoapError(h, 606, \"Action not authorized\");\n}\n\n/* Added for compliance with WANIPConnection v2 */\nstatic void\nForceTermination(struct upnphttp * h, const char * action, const char * ns)\n{\n\tUNUSED(action);\n\tUNUSED(ns);\n\tSoapError(h, 606, \"Action not authorized\");\n}\n\n/*\nIf a control point calls QueryStateVariable on a state variable that is not\nbuffered in memory within (or otherwise available from) the service,\nthe service must return a SOAP fault with an errorCode of 404 Invalid Var.\n\nQueryStateVariable remains useful as a limited test tool but may not be\npart of some future versions of UPnP.\n*/\nstatic void\nQueryStateVariable(struct upnphttp * h, const char * action, const char * ns)\n{\n\tstatic const char resp[] =\n        \"<u:%sResponse \"\n        \"xmlns:u=\\\"%s\\\">\"\n\t\t\"<return>%s</return>\"\n        \"</u:%sResponse>\";\n\n\tchar body[512];\n\tint bodylen;\n\tstruct NameValueParserData data;\n\tconst char * var_name;\n\n\tParseNameValue(h->req_buf + h->req_contentoff, h->req_contentlen, &data);\n\t/*var_name = GetValueFromNameValueList(&data, \"QueryStateVariable\"); */\n\t/*var_name = GetValueFromNameValueListIgnoreNS(&data, \"varName\");*/\n\tvar_name = GetValueFromNameValueList(&data, \"varName\");\n\n\t/*syslog(LOG_INFO, \"QueryStateVariable(%.40s)\", var_name); */\n\n\tif(!var_name)\n\t{\n\t\tSoapError(h, 402, \"Invalid Args\");\n\t}\n\telse if(strcmp(var_name, \"ConnectionStatus\") == 0)\n\t{\n\t\tconst char * status;\n\n\t\tstatus = get_wan_connection_status_str(ext_if_name);\n\t\tbodylen = snprintf(body, sizeof(body), resp,\n                           action, ns,/*\"urn:schemas-upnp-org:control-1-0\",*/\n\t\t                   status, action);\n\t\tBuildSendAndCloseSoapResp(h, body, bodylen);\n\t}\n#if 0\n\t/* not useful */\n\telse if(strcmp(var_name, \"ConnectionType\") == 0)\n\t{\n\t\tbodylen = snprintf(body, sizeof(body), resp, \"IP_Routed\");\n\t\tBuildSendAndCloseSoapResp(h, body, bodylen);\n\t}\n\telse if(strcmp(var_name, \"LastConnectionError\") == 0)\n\t{\n\t\tbodylen = snprintf(body, sizeof(body), resp, \"ERROR_NONE\");\n\t\tBuildSendAndCloseSoapResp(h, body, bodylen);\n\t}\n#endif\n\telse if(strcmp(var_name, \"PortMappingNumberOfEntries\") == 0)\n\t{\n\t\tchar strn[10];\n\t\tsnprintf(strn, sizeof(strn), \"%i\",\n\t\t         upnp_get_portmapping_number_of_entries());\n\t\tbodylen = snprintf(body, sizeof(body), resp,\n                           action, ns,/*\"urn:schemas-upnp-org:control-1-0\",*/\n\t\t                   strn, action);\n\t\tBuildSendAndCloseSoapResp(h, body, bodylen);\n\t}\n\telse\n\t{\n\t\tsyslog(LOG_NOTICE, \"%s: Unknown: %s\", action, var_name?var_name:\"\");\n\t\tSoapError(h, 404, \"Invalid Var\");\n\t}\n\n\tClearNameValueList(&data);\n}\n\n#ifdef ENABLE_6FC_SERVICE\n#ifndef ENABLE_IPV6\n#error \"ENABLE_6FC_SERVICE needs ENABLE_IPV6\"\n#endif\n/* WANIPv6FirewallControl actions */\nstatic void\nGetFirewallStatus(struct upnphttp * h, const char * action, const char * ns)\n{\n\tstatic const char resp[] =\n\t\t\"<u:%sResponse \"\n\t\t\"xmlns:u=\\\"%s\\\">\"\n\t\t\"<FirewallEnabled>%d</FirewallEnabled>\"\n\t\t\"<InboundPinholeAllowed>%d</InboundPinholeAllowed>\"\n\t\t\"</u:%sResponse>\";\n\n\tchar body[512];\n\tint bodylen;\n\n\tbodylen = snprintf(body, sizeof(body), resp,\n\t\taction, ns, /*\"urn:schemas-upnp-org:service:WANIPv6FirewallControl:1\",*/\n\t    GETFLAG(IPV6FCFWDISABLEDMASK) ? 0 : 1,\n\t    GETFLAG(IPV6FCINBOUNDDISALLOWEDMASK) ? 0 : 1,\n\t    action);\n\tBuildSendAndCloseSoapResp(h, body, bodylen);\n}\n\nstatic int\nCheckStatus(struct upnphttp * h)\n{\n\tif (GETFLAG(IPV6FCFWDISABLEDMASK))\n\t{\n\t\tSoapError(h, 702, \"FirewallDisabled\");\n\t\treturn 0;\n\t}\n\telse if(GETFLAG(IPV6FCINBOUNDDISALLOWEDMASK))\n\t{\n\t\tSoapError(h, 703, \"InboundPinholeNotAllowed\");\n\t\treturn 0;\n\t}\n\telse\n\t\treturn 1;\n}\n\n#if 0\nstatic int connecthostport(const char * host, unsigned short port, char * result)\n{\n\tint s, n;\n\tchar hostname[INET6_ADDRSTRLEN];\n\tchar port_str[8], ifname[8], tmp[4];\n\tstruct addrinfo *ai, *p;\n\tstruct addrinfo hints;\n\n\tmemset(&hints, 0, sizeof(hints));\n\t/* hints.ai_flags = AI_ADDRCONFIG; */\n#ifdef AI_NUMERICSERV\n\thints.ai_flags = AI_NUMERICSERV;\n#endif\n\thints.ai_socktype = SOCK_STREAM;\n\thints.ai_family = AF_UNSPEC; /* AF_INET, AF_INET6 or AF_UNSPEC */\n\t/* hints.ai_protocol = IPPROTO_TCP; */\n\tsnprintf(port_str, sizeof(port_str), \"%hu\", port);\n\tstrcpy(hostname, host);\n\tif(!strncmp(host, \"fe80\", 4))\n\t{\n\t\tprintf(\"Using an linklocal address\\n\");\n\t\tstrcpy(ifname, \"%\");\n\t\tsnprintf(tmp, sizeof(tmp), \"%d\", linklocal_index);\n\t\tstrcat(ifname, tmp);\n\t\tstrcat(hostname, ifname);\n\t\tprintf(\"host: %s\\n\", hostname);\n\t}\n\tn = getaddrinfo(hostname, port_str, &hints, &ai);\n\tif(n != 0)\n\t{\n\t\tfprintf(stderr, \"getaddrinfo() error : %s\\n\", gai_strerror(n));\n\t\treturn -1;\n\t}\n\ts = -1;\n\tfor(p = ai; p; p = p->ai_next)\n\t{\n#ifdef DEBUG\n\t\tchar tmp_host[256];\n\t\tchar tmp_service[256];\n\t\tprintf(\"ai_family=%d ai_socktype=%d ai_protocol=%d ai_addrlen=%d\\n \",\n\t\t       p->ai_family, p->ai_socktype, p->ai_protocol, p->ai_addrlen);\n\t\tgetnameinfo(p->ai_addr, p->ai_addrlen, tmp_host, sizeof(tmp_host),\n\t\t            tmp_service, sizeof(tmp_service),\n\t\t            NI_NUMERICHOST | NI_NUMERICSERV);\n\t\tprintf(\" host=%s service=%s\\n\", tmp_host, tmp_service);\n#endif\n\t\tinet_ntop(AF_INET6, &(((struct sockaddr_in6 *)p->ai_addr)->sin6_addr), result, INET6_ADDRSTRLEN);\n\t\treturn 0;\n\t}\n\tfreeaddrinfo(ai);\n}\n#endif\n\n/* Check the security policy right */\nstatic int\nPinholeVerification(struct upnphttp * h, char * int_ip, unsigned short int_port)\n{\n\tint n;\n\tchar senderAddr[INET6_ADDRSTRLEN]=\"\";\n\tstruct addrinfo hints, *ai, *p;\n\tstruct in6_addr result_ip;\n\n\t/* Pinhole InternalClient address must correspond to the action sender */\n\tsyslog(LOG_INFO, \"Checking internal IP@ and port (Security policy purpose)\");\n\n\thints.ai_socktype = SOCK_STREAM;\n\thints.ai_family = AF_UNSPEC;\n\n\t/* if ip not valid assume hostname and convert */\n\tif (inet_pton(AF_INET6, int_ip, &result_ip) <= 0)\n\t{\n\t\tn = getaddrinfo(int_ip, NULL, &hints, &ai);\n\t\tif(!n && ai->ai_family == AF_INET6)\n\t\t{\n\t\t\tfor(p = ai; p; p = p->ai_next)\n\t\t\t{\n\t\t\t\tinet_ntop(AF_INET6, (struct in6_addr *) p, int_ip, sizeof(struct in6_addr));\n\t\t\t\tresult_ip = *((struct in6_addr *) p);\n\t\t\t\t/* TODO : deal with more than one ip per hostname */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsyslog(LOG_ERR, \"Failed to convert hostname '%s' to ip address\", int_ip);\n\t\t\tSoapError(h, 402, \"Invalid Args\");\n\t\t\treturn -1;\n\t\t}\n        freeaddrinfo(p);\n\t}\n\n\tif(inet_ntop(AF_INET6, &(h->clientaddr_v6), senderAddr, INET6_ADDRSTRLEN) == NULL)\n\t{\n\t\tsyslog(LOG_ERR, \"inet_ntop: %m\");\n\t}\n#ifdef DEBUG\n\tprintf(\"\\tPinholeVerification:\\n\\t\\tCompare sender @: %s\\n\\t\\t  to intClient @: %s\\n\", senderAddr, int_ip);\n#endif\n\tif(strcmp(senderAddr, int_ip) != 0)\n\tif(h->clientaddr_v6.s6_addr != result_ip.s6_addr)\n\t{\n\t\tsyslog(LOG_INFO, \"Client %s tried to access pinhole for internal %s and is not authorized to do it\",\n\t\t       senderAddr, int_ip);\n\t\tSoapError(h, 606, \"Action not authorized\");\n\t\treturn 0;\n\t}\n\n\t/* Pinhole InternalPort must be greater than or equal to 1024 */\n\tif (int_port < 1024)\n\t{\n\t\tsyslog(LOG_INFO, \"Client %s tried to access pinhole with port < 1024 and is not authorized to do it\",\n\t\t       senderAddr);\n\t\tSoapError(h, 606, \"Action not authorized\");\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\nstatic void\nAddPinhole(struct upnphttp * h, const char * action, const char * ns)\n{\n\tint r;\n\tstatic const char resp[] =\n\t\t\"<u:%sResponse \"\n\t\t\"xmlns:u=\\\"%s\\\">\"\n\t\t\"<UniqueID>%d</UniqueID>\"\n\t\t\"</u:%sResponse>\";\n\tchar body[512];\n\tint bodylen;\n\tstruct NameValueParserData data;\n\tchar * rem_host, * rem_port, * int_ip, * int_port, * protocol, * leaseTime;\n\tint uid = 0;\n\tunsigned short iport, rport;\n\tint ltime;\n\tlong proto;\n\tchar rem_ip[INET6_ADDRSTRLEN];\n\n\tif(CheckStatus(h)==0)\n\t\treturn;\n\n\tParseNameValue(h->req_buf + h->req_contentoff, h->req_contentlen, &data);\n\trem_host = GetValueFromNameValueList(&data, \"RemoteHost\");\n\trem_port = GetValueFromNameValueList(&data, \"RemotePort\");\n\tint_ip = GetValueFromNameValueList(&data, \"InternalClient\");\n\tint_port = GetValueFromNameValueList(&data, \"InternalPort\");\n\tprotocol = GetValueFromNameValueList(&data, \"Protocol\");\n\tleaseTime = GetValueFromNameValueList(&data, \"LeaseTime\");\n\n\trport = (unsigned short)(rem_port ? atoi(rem_port) : 0);\n\tiport = (unsigned short)(int_port ? atoi(int_port) : 0);\n\tltime = leaseTime ? atoi(leaseTime) : -1;\n\terrno = 0;\n\tproto = protocol ? strtol(protocol, NULL, 0) : -1;\n\tif(errno != 0 || proto > 65535 || proto < 0)\n\t{\n\t\tSoapError(h, 402, \"Invalid Args\");\n\t\tgoto clear_and_exit;\n\t}\n\tif(iport == 0)\n\t{\n\t\tSoapError(h, 706, \"InternalPortWilcardingNotAllowed\");\n\t\tgoto clear_and_exit;\n\t}\n\n\t/* In particular, [IGD2] RECOMMENDS that unauthenticated and\n\t * unauthorized control points are only allowed to invoke\n\t * this action with:\n\t * - InternalPort value greater than or equal to 1024,\n\t * - InternalClient value equals to the control point's IP address.\n\t * It is REQUIRED that InternalClient cannot be one of IPv6\n\t * addresses used by the gateway. */\n\tif(!int_ip || int_ip[0] == '\\0' || 0 == strcmp(int_ip, \"*\"))\n\t{\n\t\tSoapError(h, 708, \"WildCardNotPermittedInSrcIP\");\n\t\tgoto clear_and_exit;\n\t}\n\t/* I guess it is useless to convert int_ip to literal ipv6 address */\n\tif(rem_host)\n\t{\n\t\t/* trim */\n\t\twhile(isspace(rem_host[0]))\n\t\t\trem_host++;\n\t}\n\t/* rem_host should be converted to literal ipv6 : */\n\tif(rem_host && (rem_host[0] != '\\0') && (rem_host[0] != '*'))\n\t{\n\t\tstruct addrinfo *ai, *p;\n\t\tstruct addrinfo hints;\n\t\tint err;\n\t\tmemset(&hints, 0, sizeof(struct addrinfo));\n\t\thints.ai_family = AF_INET6;\n\t\t/*hints.ai_flags = */\n\t\t/* hints.ai_protocol = proto; */\n\t\terr = getaddrinfo(rem_host, rem_port, &hints, &ai);\n\t\tif(err == 0)\n\t\t{\n\t\t\t/* take the 1st IPv6 address */\n\t\t\tfor(p = ai; p; p = p->ai_next)\n\t\t\t{\n\t\t\t\tif(p->ai_family == AF_INET6)\n\t\t\t\t{\n\t\t\t\t\tinet_ntop(AF_INET6,\n\t\t\t\t\t          &(((struct sockaddr_in6 *)p->ai_addr)->sin6_addr),\n\t\t\t\t\t          rem_ip, sizeof(rem_ip));\n\t\t\t\t\tsyslog(LOG_INFO, \"resolved '%s' to '%s'\", rem_host, rem_ip);\n\t\t\t\t\trem_host = rem_ip;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfreeaddrinfo(ai);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsyslog(LOG_WARNING, \"AddPinhole : getaddrinfo(%s) : %s\",\n\t\t\t       rem_host, gai_strerror(err));\n#if 0\n\t\t\tSoapError(h, 402, \"Invalid Args\");\n\t\t\tgoto clear_and_exit;\n#endif\n\t\t}\n\t}\n\n\tif(proto == 65535)\n\t{\n\t\tSoapError(h, 707, \"ProtocolWilcardingNotAllowed\");\n\t\tgoto clear_and_exit;\n\t}\n\tif(proto != IPPROTO_UDP && proto != IPPROTO_TCP\n#ifdef IPPROTO_UDPITE\n\t   && atoi(protocol) != IPPROTO_UDPLITE\n#endif\n\t  )\n\t{\n\t\tSoapError(h, 705, \"ProtocolNotSupported\");\n\t\tgoto clear_and_exit;\n\t}\n\tif(ltime < 1 || ltime > 86400)\n\t{\n\t\tsyslog(LOG_WARNING, \"%s: LeaseTime=%d not supported, (ip=%s)\",\n\t\t       action, ltime, int_ip);\n\t\tSoapError(h, 402, \"Invalid Args\");\n\t\tgoto clear_and_exit;\n\t}\n\n\tif(PinholeVerification(h, int_ip, iport) <= 0)\n\t\tgoto clear_and_exit;\n\n\tsyslog(LOG_INFO, \"%s: (inbound) from [%s]:%hu to [%s]:%hu with proto %ld during %d sec\",\n\t       action, rem_host?rem_host:\"any\",\n\t       rport, int_ip, iport,\n\t       proto, ltime);\n\n\t/* In cases where the RemoteHost, RemotePort, InternalPort,\n\t * InternalClient and Protocol are the same than an existing pinhole,\n\t * but LeaseTime is different, the device MUST extend the existing\n\t * pinhole's lease time and return the UniqueID of the existing pinhole. */\n\tr = upnp_add_inboundpinhole(rem_host, rport, int_ip, iport, proto, \"IGD2 pinhole\", ltime, &uid);\n\n\tswitch(r)\n\t{\n\t\tcase 1:\t        /* success */\n\t\t\tbodylen = snprintf(body, sizeof(body),\n\t\t\t                   resp, action,\n\t\t\t                   ns/*\"urn:schemas-upnp-org:service:WANIPv6FirewallControl:1\"*/,\n\t\t\t                   uid, action);\n\t\t\tBuildSendAndCloseSoapResp(h, body, bodylen);\n\t\t\tbreak;\n\t\tcase -1: \t/* not permitted */\n\t\t\tSoapError(h, 701, \"PinholeSpaceExhausted\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tSoapError(h, 501, \"ActionFailed\");\n\t\t\tbreak;\n\t}\n\t/* 606 Action not authorized\n\t * 701 PinholeSpaceExhausted\n\t * 702 FirewallDisabled\n\t * 703 InboundPinholeNotAllowed\n\t * 705 ProtocolNotSupported\n\t * 706 InternalPortWildcardingNotAllowed\n\t * 707 ProtocolWildcardingNotAllowed\n\t * 708 WildCardNotPermittedInSrcIP */\nclear_and_exit:\n\tClearNameValueList(&data);\n}\n\nstatic void\nUpdatePinhole(struct upnphttp * h, const char * action, const char * ns)\n{\n#if 0\n\tstatic const char resp[] =\n\t\t\"<u:UpdatePinholeResponse \"\n\t\t\"xmlns:u=\\\"urn:schemas-upnp-org:service:WANIPv6FirewallControl:1\\\">\"\n\t\t\"</u:UpdatePinholeResponse>\";\n#endif\n\tstatic const char resp[] =\n\t\t\"<u:%sResponse \"\n\t\t\"xmlns:u=\\\"%s\\\">\"\n\t\t\"</u:%sResponse>\";\n\tchar body[512];\n\tint bodylen;\n\tstruct NameValueParserData data;\n\tconst char * uid_str, * leaseTime;\n\tchar iaddr[INET6_ADDRSTRLEN];\n\tunsigned short iport;\n\tint ltime;\n\tint uid;\n\tint n;\n\n\tif(CheckStatus(h)==0)\n\t\treturn;\n\n\tParseNameValue(h->req_buf + h->req_contentoff, h->req_contentlen, &data);\n\tuid_str = GetValueFromNameValueList(&data, \"UniqueID\");\n\tleaseTime = GetValueFromNameValueList(&data, \"NewLeaseTime\");\n\tuid = uid_str ? atoi(uid_str) : -1;\n\tltime = leaseTime ? atoi(leaseTime) : -1;\n\tClearNameValueList(&data);\n\n\tif(uid < 0 || uid > 65535 || ltime <= 0 || ltime > 86400)\n\t{\n\t\tSoapError(h, 402, \"Invalid Args\");\n\t\treturn;\n\t}\n\n\t/* Check that client is not updating an pinhole\n\t * it doesn't have access to, because of its public access */\n\tn = upnp_get_pinhole_info(uid, NULL, 0, NULL,\n\t                          iaddr, sizeof(iaddr), &iport,\n\t                          NULL, /* proto */\n\t                          NULL, 0, /* desc, desclen */\n\t                          NULL, NULL);\n\tif (n >= 0)\n\t{\n\t\tif(PinholeVerification(h, iaddr, iport) <= 0)\n\t\t\treturn;\n\t}\n\telse if(n == -2)\n\t{\n\t\tSoapError(h, 704, \"NoSuchEntry\");\n\t\treturn;\n\t}\n\telse\n\t{\n\t\tSoapError(h, 501, \"ActionFailed\");\n\t\treturn;\n\t}\n\n\tsyslog(LOG_INFO, \"%s: (inbound) updating lease duration to %d for pinhole with ID: %d\",\n\t       action, ltime, uid);\n\n\tn = upnp_update_inboundpinhole(uid, ltime);\n\tif(n == -1)\n\t\tSoapError(h, 704, \"NoSuchEntry\");\n\telse if(n < 0)\n\t\tSoapError(h, 501, \"ActionFailed\");\n\telse {\n\t\tbodylen = snprintf(body, sizeof(body), resp,\n\t\t                   action, ns, action);\n\t\tBuildSendAndCloseSoapResp(h, body, bodylen);\n\t}\n}\n\nstatic void\nGetOutboundPinholeTimeout(struct upnphttp * h, const char * action, const char * ns)\n{\n\tint r;\n\n\tstatic const char resp[] =\n\t\t\"<u:%sResponse \"\n\t\t\"xmlns:u=\\\"%s\\\">\"\n\t\t\"<OutboundPinholeTimeout>%d</OutboundPinholeTimeout>\"\n\t\t\"</u:%sResponse>\";\n\n\tchar body[512];\n\tint bodylen;\n\tstruct NameValueParserData data;\n\tchar * int_ip, * int_port, * rem_host, * rem_port, * protocol;\n\tint opt=0;\n\t/*int proto=0;*/\n\tunsigned short iport, rport;\n\n\tif (GETFLAG(IPV6FCFWDISABLEDMASK))\n\t{\n\t\tSoapError(h, 702, \"FirewallDisabled\");\n\t\treturn;\n\t}\n\n\tParseNameValue(h->req_buf + h->req_contentoff, h->req_contentlen, &data);\n\tint_ip = GetValueFromNameValueList(&data, \"InternalClient\");\n\tint_port = GetValueFromNameValueList(&data, \"InternalPort\");\n\trem_host = GetValueFromNameValueList(&data, \"RemoteHost\");\n\trem_port = GetValueFromNameValueList(&data, \"RemotePort\");\n\tprotocol = GetValueFromNameValueList(&data, \"Protocol\");\n\n\trport = (unsigned short)atoi(rem_port);\n\tiport = (unsigned short)atoi(int_port);\n\t/*proto = atoi(protocol);*/\n\n\tsyslog(LOG_INFO, \"%s: retrieving timeout for outbound pinhole from [%s]:%hu to [%s]:%hu protocol %s\", action, int_ip, iport,rem_host, rport, protocol);\n\n\t/* TODO */\n\tr = -1;/*upnp_check_outbound_pinhole(proto, &opt);*/\n\n\tswitch(r)\n\t{\n\t\tcase 1:\t/* success */\n\t\t\tbodylen = snprintf(body, sizeof(body), resp,\n\t\t\t                   action, ns/*\"urn:schemas-upnp-org:service:WANIPv6FirewallControl:1\"*/,\n\t\t\t                   opt, action);\n\t\t\tBuildSendAndCloseSoapResp(h, body, bodylen);\n\t\t\tbreak;\n\t\tcase -5:\t/* Protocol not supported */\n\t\t\tSoapError(h, 705, \"ProtocolNotSupported\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tSoapError(h, 501, \"ActionFailed\");\n\t}\n\tClearNameValueList(&data);\n}\n\nstatic void\nDeletePinhole(struct upnphttp * h, const char * action, const char * ns)\n{\n\tint n;\n#if 0\n\tstatic const char resp[] =\n\t\t\"<u:DeletePinholeResponse \"\n\t\t\"xmlns:u=\\\"urn:schemas-upnp-org:service:WANIPv6FirewallControl:1\\\">\"\n\t\t\"</u:DeletePinholeResponse>\";\n#endif\n\tstatic const char resp[] =\n\t\t\"<u:%sResponse \"\n\t\t\"xmlns:u=\\\"%s\\\">\"\n\t\t\"</u:%sResponse>\";\n\tchar body[512];\n\tint bodylen;\n\n\tstruct NameValueParserData data;\n\tconst char * uid_str;\n\tchar iaddr[INET6_ADDRSTRLEN];\n\tint proto;\n\tunsigned short iport;\n\tunsigned int leasetime;\n\tint uid;\n\n\tif(CheckStatus(h)==0)\n\t\treturn;\n\n\tParseNameValue(h->req_buf + h->req_contentoff, h->req_contentlen, &data);\n\tuid_str = GetValueFromNameValueList(&data, \"UniqueID\");\n\tuid = uid_str ? atoi(uid_str) : -1;\n\tClearNameValueList(&data);\n\n\tif(uid < 0 || uid > 65535)\n\t{\n\t\tSoapError(h, 402, \"Invalid Args\");\n\t\treturn;\n\t}\n\n\t/* Check that client is not deleting an pinhole\n\t * it doesn't have access to, because of its public access */\n\tn = upnp_get_pinhole_info(uid, NULL, 0, NULL,\n\t                          iaddr, sizeof(iaddr), &iport,\n\t                          &proto,\n\t                          NULL, 0, /* desc, desclen */\n\t                          &leasetime, NULL);\n\tif (n >= 0)\n\t{\n\t\tif(PinholeVerification(h, iaddr, iport) <= 0)\n\t\t\treturn;\n\t}\n\telse if(n == -2)\n\t{\n\t\tSoapError(h, 704, \"NoSuchEntry\");\n\t\treturn;\n\t}\n\telse\n\t{\n\t\tSoapError(h, 501, \"ActionFailed\");\n\t\treturn;\n\t}\n\n\tn = upnp_delete_inboundpinhole(uid);\n\tif(n < 0)\n\t{\n\t\tsyslog(LOG_INFO, \"%s: (inbound) failed to remove pinhole with ID: %d\",\n\t           action, uid);\n\t\tSoapError(h, 501, \"ActionFailed\");\n\t\treturn;\n\t}\n\tsyslog(LOG_INFO, \"%s: (inbound) pinhole with ID %d successfully removed\",\n\t       action, uid);\n\tbodylen = snprintf(body, sizeof(body), resp,\n\t                   action, ns, action);\n\tBuildSendAndCloseSoapResp(h, body, bodylen);\n}\n\nstatic void\nCheckPinholeWorking(struct upnphttp * h, const char * action, const char * ns)\n{\n\tstatic const char resp[] =\n\t\t\"<u:%sResponse \"\n\t\t\"xmlns:u=\\\"%s\\\">\"\n\t\t\"<IsWorking>%d</IsWorking>\"\n\t\t\"</u:%sResponse>\";\n\tchar body[512];\n\tint bodylen;\n\tint r;\n\tstruct NameValueParserData data;\n\tconst char * uid_str;\n\tint uid;\n\tchar iaddr[INET6_ADDRSTRLEN];\n\tunsigned short iport;\n\tunsigned int packets;\n\n\tif(CheckStatus(h)==0)\n\t\treturn;\n\n\tParseNameValue(h->req_buf + h->req_contentoff, h->req_contentlen, &data);\n\tuid_str = GetValueFromNameValueList(&data, \"UniqueID\");\n\tuid = uid_str ? atoi(uid_str) : -1;\n\tClearNameValueList(&data);\n\n\tif(uid < 0 || uid > 65535)\n\t{\n\t\tSoapError(h, 402, \"Invalid Args\");\n\t\treturn;\n\t}\n\n\t/* Check that client is not checking a pinhole\n\t * it doesn't have access to, because of its public access */\n\tr = upnp_get_pinhole_info(uid,\n\t                          NULL, 0, NULL,\n\t                          iaddr, sizeof(iaddr), &iport,\n\t                          NULL, /* proto */\n\t                          NULL, 0, /* desc, desclen */\n\t                          NULL, &packets);\n\tif (r >= 0)\n\t{\n\t\tif(PinholeVerification(h, iaddr, iport) <= 0)\n\t\t\treturn ;\n\t\tif(packets == 0)\n\t\t{\n\t\t\tSoapError(h, 709, \"NoPacketSent\");\n\t\t\treturn;\n\t\t}\n\t\tbodylen = snprintf(body, sizeof(body), resp,\n\t\t\t\t\t\taction, ns/*\"urn:schemas-upnp-org:service:WANIPv6FirewallControl:1\"*/,\n\t\t\t\t\t\t1, action);\n\t\tBuildSendAndCloseSoapResp(h, body, bodylen);\n\t}\n\telse if(r == -2)\n\t\tSoapError(h, 704, \"NoSuchEntry\");\n\telse\n\t\tSoapError(h, 501, \"ActionFailed\");\n}\n\nstatic void\nGetPinholePackets(struct upnphttp * h, const char * action, const char * ns)\n{\n\tstatic const char resp[] =\n\t\t\"<u:%sResponse \"\n\t\t\"xmlns:u=\\\"%s\\\">\"\n\t\t\"<PinholePackets>%u</PinholePackets>\"\n\t\t\"</u:%sResponse>\";\n\tchar body[512];\n\tint bodylen;\n\tstruct NameValueParserData data;\n\tconst char * uid_str;\n\tint n;\n\tchar iaddr[INET6_ADDRSTRLEN];\n\tunsigned short iport;\n\tunsigned int packets = 0;\n\tint uid;\n\tint proto;\n\tunsigned int leasetime;\n\n\tif(CheckStatus(h)==0)\n\t\treturn;\n\n\tParseNameValue(h->req_buf + h->req_contentoff, h->req_contentlen, &data);\n\tuid_str = GetValueFromNameValueList(&data, \"UniqueID\");\n\tuid = uid_str ? atoi(uid_str) : -1;\n\tClearNameValueList(&data);\n\n\tif(uid < 0 || uid > 65535)\n\t{\n\t\tSoapError(h, 402, \"Invalid Args\");\n\t\treturn;\n\t}\n\n\t/* Check that client is not getting infos of a pinhole\n\t * it doesn't have access to, because of its public access */\n\tn = upnp_get_pinhole_info(uid, NULL, 0, NULL,\n\t                          iaddr, sizeof(iaddr), &iport,\n\t                          &proto,\n\t                          NULL, 0, /* desc, desclen */\n\t                          &leasetime, &packets);\n\tif (n >= 0)\n\t{\n\t\tif(PinholeVerification(h, iaddr, iport)<=0)\n\t\t\treturn ;\n\t}\n#if 0\n\telse if(r == -4 || r == -1)\n\t{\n\t\tSoapError(h, 704, \"NoSuchEntry\");\n\t}\n#endif\n\n\tbodylen = snprintf(body, sizeof(body), resp,\n\t\t\taction, ns/*\"urn:schemas-upnp-org:service:WANIPv6FirewallControl:1\"*/,\n\t\t\tpackets, action);\n\tBuildSendAndCloseSoapResp(h, body, bodylen);\n}\n#endif\n\n#ifdef ENABLE_DP_SERVICE\nstatic void\nSendSetupMessage(struct upnphttp * h, const char * action, const char * ns)\n{\n\tstatic const char resp[] =\n\t\t\"<u:%sResponse \"\n\t\t\"xmlns:u=\\\"%s\\\">\"\n\t\t\"<OutMessage>%s</OutMessage>\"\n\t\t\"</u:%sResponse>\";\n\tchar body[1024];\n\tint bodylen;\n\tstruct NameValueParserData data;\n\tconst char * ProtocolType;\t/* string */\n\tconst char * InMessage;\t\t/* base64 */\n\tconst char * OutMessage = \"\";\t/* base64 */\n\n\tParseNameValue(h->req_buf + h->req_contentoff, h->req_contentlen, &data);\n\tProtocolType = GetValueFromNameValueList(&data, \"ProtocolType\");\t/* string */\n\tInMessage = GetValueFromNameValueList(&data, \"InMessage\");\t/* base64 */\n\n\tif(ProtocolType == NULL || InMessage == NULL)\n\t{\n\t\tClearNameValueList(&data);\n\t\tSoapError(h, 402, \"Invalid Args\");\n\t\treturn;\n\t}\n\t/*if(strcmp(ProtocolType, \"DeviceProtection:1\") != 0)*/\n\tif(strcmp(ProtocolType, \"WPS\") != 0)\n\t{\n\t\tClearNameValueList(&data);\n\t\tSoapError(h, 600, \"Argument Value Invalid\"); /* 703 ? */\n\t\treturn;\n\t}\n\t/* TODO : put here code for WPS */\n\n\tbodylen = snprintf(body, sizeof(body), resp,\n\t                   action, ns/*\"urn:schemas-upnp-org:service:DeviceProtection:1\"*/,\n\t                   OutMessage, action);\n\tBuildSendAndCloseSoapResp(h, body, bodylen);\n\tClearNameValueList(&data);\n}\n\nstatic void\nGetSupportedProtocols(struct upnphttp * h, const char * action, const char * ns)\n{\n\tstatic const char resp[] =\n\t\t\"<u:%sResponse \"\n\t\t\"xmlns:u=\\\"%s\\\">\"\n\t\t\"<ProtocolList><![CDATA[%s]]></ProtocolList>\"\n\t\t\"</u:%sResponse>\";\n\tchar body[1024];\n\tint bodylen;\n\tconst char * ProtocolList =\n\t\t\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\"\n\t\t\"<SupportedProtocols xmlns=\\\"urn:schemas-upnp-org:gw:DeviceProtection\\\"\"\n\t\t\" xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\"\"\n\t\t\" xsi:schemaLocation=\\\"urn:schemas-upnp-org:gw:DeviceProtection\"\n\t\t\" http://www.upnp.org/schemas/gw/DeviceProtection-v1.xsd\\\">\"\n\t\t\"<Introduction><Name>WPS</Name></Introduction>\"\n\t\t\"<Login><Name>PKCS5</Name></Login>\"\n\t\t\"</SupportedProtocols>\";\n\n\tbodylen = snprintf(body, sizeof(body), resp,\n\t                   action, ns/*\"urn:schemas-upnp-org:service:DeviceProtection:1\"*/,\n\t                   ProtocolList, action);\n\tBuildSendAndCloseSoapResp(h, body, bodylen);\n}\n\nstatic void\nGetAssignedRoles(struct upnphttp * h, const char * action, const char * ns)\n{\n\tstatic const char resp[] =\n\t\t\"<u:%sResponse \"\n\t\t\"xmlns:u=\\\"%s\\\">\"\n\t\t\"<RoleList>%s</RoleList>\"\n\t\t\"</u:%sResponse>\";\n\tchar body[1024];\n\tint bodylen;\n\tconst char * RoleList = \"Public\"; /* list of roles separated by spaces */\n\n#ifdef ENABLE_HTTPS\n\tif(h->ssl != NULL) {\n\t\t/* we should get the Roles of the session (based on client certificate) */\n\t\tX509 * peercert;\n\t\tpeercert = SSL_get_peer_certificate(h->ssl);\n\t\tif(peercert != NULL) {\n\t\t\tRoleList = \"Admin Basic\";\n\t\t\tX509_free(peercert);\n\t\t}\n\t}\n#endif\n\n\tbodylen = snprintf(body, sizeof(body), resp,\n\t                   action, ns/*\"urn:schemas-upnp-org:service:DeviceProtection:1\"*/,\n\t                   RoleList, action);\n\tBuildSendAndCloseSoapResp(h, body, bodylen);\n}\n#endif\n\n/* Windows XP as client send the following requests :\n * GetConnectionTypeInfo\n * GetNATRSIPStatus\n * ? GetTotalBytesSent - WANCommonInterfaceConfig\n * ? GetTotalBytesReceived - idem\n * ? GetTotalPacketsSent - idem\n * ? GetTotalPacketsReceived - idem\n * GetCommonLinkProperties - idem\n * GetStatusInfo - WANIPConnection\n * GetExternalIPAddress\n * QueryStateVariable / ConnectionStatus!\n */\nstatic const struct\n{\n\tconst char * methodName;\n\tvoid (*methodImpl)(struct upnphttp *, const char *, const char *);\n}\nsoapMethods[] =\n{\n\t/* WANCommonInterfaceConfig */\n\t{ \"QueryStateVariable\", QueryStateVariable},\n\t{ \"GetTotalBytesSent\", GetTotalBytesSent},\n\t{ \"GetTotalBytesReceived\", GetTotalBytesReceived},\n\t{ \"GetTotalPacketsSent\", GetTotalPacketsSent},\n\t{ \"GetTotalPacketsReceived\", GetTotalPacketsReceived},\n\t{ \"GetCommonLinkProperties\", GetCommonLinkProperties},\n\t{ \"GetStatusInfo\", GetStatusInfo},\n\t/* WANIPConnection */\n\t{ \"GetConnectionTypeInfo\", GetConnectionTypeInfo },\n\t{ \"GetNATRSIPStatus\", GetNATRSIPStatus},\n\t{ \"GetExternalIPAddress\", GetExternalIPAddress},\n\t{ \"AddPortMapping\", AddPortMapping},\n\t{ \"DeletePortMapping\", DeletePortMapping},\n\t{ \"GetGenericPortMappingEntry\", GetGenericPortMappingEntry},\n\t{ \"GetSpecificPortMappingEntry\", GetSpecificPortMappingEntry},\n/* Required in WANIPConnection:2 */\n\t{ \"SetConnectionType\", SetConnectionType},\n\t{ \"RequestConnection\", RequestConnection},\n\t{ \"ForceTermination\", ForceTermination},\n\t{ \"AddAnyPortMapping\", AddAnyPortMapping},\n\t{ \"DeletePortMappingRange\", DeletePortMappingRange},\n\t{ \"GetListOfPortMappings\", GetListOfPortMappings},\n#ifdef ENABLE_L3F_SERVICE\n\t/* Layer3Forwarding */\n\t{ \"SetDefaultConnectionService\", SetDefaultConnectionService},\n\t{ \"GetDefaultConnectionService\", GetDefaultConnectionService},\n#endif\n#ifdef ENABLE_6FC_SERVICE\n\t/* WANIPv6FirewallControl */\n\t{ \"GetFirewallStatus\", GetFirewallStatus},\t/* Required */\n\t{ \"AddPinhole\", AddPinhole},\t\t\t\t/* Required */\n\t{ \"UpdatePinhole\", UpdatePinhole},\t\t\t/* Required */\n\t{ \"GetOutboundPinholeTimeout\", GetOutboundPinholeTimeout},\t/* Optional */\n\t{ \"DeletePinhole\", DeletePinhole},\t\t\t/* Required */\n\t{ \"CheckPinholeWorking\", CheckPinholeWorking},\t/* Optional */\n\t{ \"GetPinholePackets\", GetPinholePackets},\t/* Required */\n#endif\n#ifdef ENABLE_DP_SERVICE\n\t/* DeviceProtection */\n\t{ \"SendSetupMessage\", SendSetupMessage},\t/* Required */\n\t{ \"GetSupportedProtocols\", GetSupportedProtocols},\t/* Required */\n\t{ \"GetAssignedRoles\", GetAssignedRoles},\t/* Required */\n#endif\n\t{ 0, 0 }\n};\n\nvoid\nExecuteSoapAction(struct upnphttp * h, const char * action, int n)\n{\n\tchar * p;\n\tchar * p2;\n\tint i, len, methodlen;\n\tchar namespace[256];\n\n\t/* SoapAction example :\n\t * urn:schemas-upnp-org:service:WANIPConnection:1#GetStatusInfo */\n\tp = strchr(action, '#');\n\tif(p && (p - action) < n) {\n\t\tfor(i = 0; i < ((int)sizeof(namespace) - 1) && (action + i) < p; i++)\n\t\t\tnamespace[i] = action[i];\n\t\tnamespace[i] = '\\0';\n\t\tp++;\n\t\tp2 = strchr(p, '\"');\n\t\tif(p2 && (p2 - action) <= n)\n\t\t\tmethodlen = p2 - p;\n\t\telse\n\t\t\tmethodlen = n - (p - action);\n\t\t/*syslog(LOG_DEBUG, \"SoapMethod: %.*s %d %d %p %p %d\",\n\t\t       methodlen, p, methodlen, n, action, p, (int)(p - action));*/\n\t\tfor(i = 0; soapMethods[i].methodName; i++) {\n\t\t\tlen = strlen(soapMethods[i].methodName);\n\t\t\tif((len == methodlen) && memcmp(p, soapMethods[i].methodName, len) == 0) {\n#ifdef DEBUG\n\t\t\t\tsyslog(LOG_DEBUG, \"Remote Call of SoapMethod '%s' %s\",\n\t\t\t\t       soapMethods[i].methodName, namespace);\n#endif /* DEBUG */\n\t\t\t\tsoapMethods[i].methodImpl(h, soapMethods[i].methodName, namespace);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tsyslog(LOG_NOTICE, \"SoapMethod: Unknown: %.*s %s\", methodlen, p, namespace);\n\t} else {\n\t\tsyslog(LOG_NOTICE, \"cannot parse SoapAction\");\n\t}\n\n\tSoapError(h, 401, \"Invalid Action\");\n}\n\n/* Standard Errors:\n *\n * errorCode errorDescription Description\n * --------\t---------------- -----------\n * 401 \t\tInvalid Action \tNo action by that name at this service.\n * 402 \t\tInvalid Args \tCould be any of the following: not enough in args,\n * \t\t\t\t\t\t\ttoo many in args, no in arg by that name,\n * \t\t\t\t\t\t\tone or more in args are of the wrong data type.\n * 403 \t\tOut of Sync \tOut of synchronization.\n * 501 \t\tAction Failed \tMay be returned in current state of service\n * \t\t\t\t\t\t\tprevents invoking that action.\n * 600-699 \tTBD \t\t\tCommon action errors. Defined by UPnP Forum\n * \t\t\t\t\t\t\tTechnical Committee.\n * 700-799 \tTBD \t\t\tAction-specific errors for standard actions.\n * \t\t\t\t\t\t\tDefined by UPnP Forum working committee.\n * 800-899 \tTBD \t\t\tAction-specific errors for non-standard actions.\n * \t\t\t\t\t\t\tDefined by UPnP vendor.\n*/\nvoid\nSoapError(struct upnphttp * h, int errCode, const char * errDesc)\n{\n\tstatic const char resp[] =\n\t\t\"<s:Envelope \"\n\t\t\"xmlns:s=\\\"http://schemas.xmlsoap.org/soap/envelope/\\\" \"\n\t\t\"s:encodingStyle=\\\"http://schemas.xmlsoap.org/soap/encoding/\\\">\"\n\t\t\"<s:Body>\"\n\t\t\"<s:Fault>\"\n\t\t\"<faultcode>s:Client</faultcode>\"\n\t\t\"<faultstring>UPnPError</faultstring>\"\n\t\t\"<detail>\"\n\t\t\"<UPnPError xmlns=\\\"urn:schemas-upnp-org:control-1-0\\\">\"\n\t\t\"<errorCode>%d</errorCode>\"\n\t\t\"<errorDescription>%s</errorDescription>\"\n\t\t\"</UPnPError>\"\n\t\t\"</detail>\"\n\t\t\"</s:Fault>\"\n\t\t\"</s:Body>\"\n\t\t\"</s:Envelope>\";\n\n\tchar body[2048];\n\tint bodylen;\n\n\tsyslog(LOG_INFO, \"Returning UPnPError %d: %s\", errCode, errDesc);\n\tbodylen = snprintf(body, sizeof(body), resp, errCode, errDesc);\n\tBuildResp2_upnphttp(h, 500, \"Internal Server Error\", body, bodylen);\n\tSendRespAndClose_upnphttp(h);\n}\n\n"], "fixing_code": ["/* $Id: upnpsoap.c,v 1.151 2018/03/13 10:32:53 nanard Exp $ */\n/* vim: tabstop=4 shiftwidth=4 noexpandtab\n * MiniUPnP project\n * http://miniupnp.free.fr/ or https://miniupnp.tuxfamily.org/\n * (c) 2006-2018 Thomas Bernard\n * This software is subject to the conditions detailed\n * in the LICENCE file provided within the distribution */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <string.h>\n#include <errno.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/types.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <ctype.h>\n\n#include \"macros.h\"\n#include \"config.h\"\n#include \"upnpglobalvars.h\"\n#include \"upnphttp.h\"\n#include \"upnpsoap.h\"\n#include \"upnpreplyparse.h\"\n#include \"upnpredirect.h\"\n#include \"upnppinhole.h\"\n#include \"getifaddr.h\"\n#include \"getifstats.h\"\n#include \"getconnstatus.h\"\n#include \"upnpurns.h\"\n#include \"upnputils.h\"\n\n/* utility function */\nstatic int is_numeric(const char * s)\n{\n\twhile(*s) {\n\t\tif(*s < '0' || *s > '9') return 0;\n\t\ts++;\n\t}\n\treturn 1;\n}\n\nstatic void\nBuildSendAndCloseSoapResp(struct upnphttp * h,\n                          const char * body, int bodylen)\n{\n\tstatic const char beforebody[] =\n\t\t\"<?xml version=\\\"1.0\\\"?>\\r\\n\"\n\t\t\"<s:Envelope xmlns:s=\\\"http://schemas.xmlsoap.org/soap/envelope/\\\" \"\n\t\t\"s:encodingStyle=\\\"http://schemas.xmlsoap.org/soap/encoding/\\\">\"\n\t\t\"<s:Body>\";\n\n\tstatic const char afterbody[] =\n\t\t\"</s:Body>\"\n\t\t\"</s:Envelope>\\r\\n\";\n\n\tint r = BuildHeader_upnphttp(h, 200, \"OK\",  sizeof(beforebody) - 1\n\t                             + sizeof(afterbody) - 1 + bodylen );\n\n\tif(r >= 0) {\n\t\tmemcpy(h->res_buf + h->res_buflen, beforebody, sizeof(beforebody) - 1);\n\t\th->res_buflen += sizeof(beforebody) - 1;\n\n\t\tmemcpy(h->res_buf + h->res_buflen, body, bodylen);\n\t\th->res_buflen += bodylen;\n\n\t\tmemcpy(h->res_buf + h->res_buflen, afterbody, sizeof(afterbody) - 1);\n\t\th->res_buflen += sizeof(afterbody) - 1;\n\t} else {\n\t\tBuildResp2_upnphttp(h, 500, \"Internal Server Error\", NULL, 0);\n\t}\n\n\tSendRespAndClose_upnphttp(h);\n}\n\nstatic void\nGetConnectionTypeInfo(struct upnphttp * h, const char * action, const char * ns)\n{\n#if 0\n\tstatic const char resp[] =\n\t\t\"<u:GetConnectionTypeInfoResponse \"\n\t\t\"xmlns:u=\\\"\" SERVICE_TYPE_WANIPC \"\\\">\"\n\t\t\"<NewConnectionType>IP_Routed</NewConnectionType>\"\n\t\t\"<NewPossibleConnectionTypes>IP_Routed</NewPossibleConnectionTypes>\"\n\t\t\"</u:GetConnectionTypeInfoResponse>\";\n#endif\n\tstatic const char resp[] =\n\t\t\"<u:%sResponse \"\n\t\t\"xmlns:u=\\\"%s\\\">\"\n\t\t\"<NewConnectionType>IP_Routed</NewConnectionType>\"\n\t\t\"<NewPossibleConnectionTypes>IP_Routed</NewPossibleConnectionTypes>\"\n\t\t\"</u:%sResponse>\";\n\tchar body[512];\n\tint bodylen;\n\n\tbodylen = snprintf(body, sizeof(body), resp,\n\t         action, ns, action);\n\tBuildSendAndCloseSoapResp(h, body, bodylen);\n}\n\n/* maximum value for a UPNP ui4 type variable */\n#define UPNP_UI4_MAX (4294967295ul)\n\nstatic void\nGetTotalBytesSent(struct upnphttp * h, const char * action, const char * ns)\n{\n\tint r;\n\n\tstatic const char resp[] =\n\t\t\"<u:%sResponse \"\n\t\t\"xmlns:u=\\\"%s\\\">\"\n\t\t\"<NewTotalBytesSent>%lu</NewTotalBytesSent>\"\n\t\t\"</u:%sResponse>\";\n\n\tchar body[512];\n\tint bodylen;\n\tstruct ifdata data;\n\n\tr = getifstats(ext_if_name, &data);\n\tbodylen = snprintf(body, sizeof(body), resp,\n\t         action, ns, /* was \"urn:schemas-upnp-org:service:WANCommonInterfaceConfig:1\" */\n#ifdef UPNP_STRICT\n             r<0?0:(data.obytes & UPNP_UI4_MAX), action);\n#else /* UPNP_STRICT */\n             r<0?0:data.obytes, action);\n#endif /* UPNP_STRICT */\n\tBuildSendAndCloseSoapResp(h, body, bodylen);\n}\n\nstatic void\nGetTotalBytesReceived(struct upnphttp * h, const char * action, const char * ns)\n{\n\tint r;\n\n\tstatic const char resp[] =\n\t\t\"<u:%sResponse \"\n\t\t\"xmlns:u=\\\"%s\\\">\"\n\t\t\"<NewTotalBytesReceived>%lu</NewTotalBytesReceived>\"\n\t\t\"</u:%sResponse>\";\n\n\tchar body[512];\n\tint bodylen;\n\tstruct ifdata data;\n\n\tr = getifstats(ext_if_name, &data);\n\t/* TotalBytesReceived\n\t * This variable represents the cumulative counter for total number of\n\t * bytes received downstream across all connection service instances on\n\t * WANDevice. The count rolls over to 0 after it reaching the maximum\n\t * value (2^32)-1. */\n\tbodylen = snprintf(body, sizeof(body), resp,\n\t         action, ns, /* was \"urn:schemas-upnp-org:service:WANCommonInterfaceConfig:1\" */\n#ifdef UPNP_STRICT\n\t         r<0?0:(data.ibytes & UPNP_UI4_MAX), action);\n#else /* UPNP_STRICT */\n\t         r<0?0:data.ibytes, action);\n#endif /* UPNP_STRICT */\n\tBuildSendAndCloseSoapResp(h, body, bodylen);\n}\n\nstatic void\nGetTotalPacketsSent(struct upnphttp * h, const char * action, const char * ns)\n{\n\tint r;\n\n\tstatic const char resp[] =\n\t\t\"<u:%sResponse \"\n\t\t\"xmlns:u=\\\"%s\\\">\"\n\t\t\"<NewTotalPacketsSent>%lu</NewTotalPacketsSent>\"\n\t\t\"</u:%sResponse>\";\n\n\tchar body[512];\n\tint bodylen;\n\tstruct ifdata data;\n\n\tr = getifstats(ext_if_name, &data);\n\tbodylen = snprintf(body, sizeof(body), resp,\n\t         action, ns,/*\"urn:schemas-upnp-org:service:WANCommonInterfaceConfig:1\",*/\n#ifdef UPNP_STRICT\n\t         r<0?0:(data.opackets & UPNP_UI4_MAX), action);\n#else /* UPNP_STRICT */\n\t         r<0?0:data.opackets, action);\n#endif /* UPNP_STRICT */\n\tBuildSendAndCloseSoapResp(h, body, bodylen);\n}\n\nstatic void\nGetTotalPacketsReceived(struct upnphttp * h, const char * action, const char * ns)\n{\n\tint r;\n\n\tstatic const char resp[] =\n\t\t\"<u:%sResponse \"\n\t\t\"xmlns:u=\\\"%s\\\">\"\n\t\t\"<NewTotalPacketsReceived>%lu</NewTotalPacketsReceived>\"\n\t\t\"</u:%sResponse>\";\n\n\tchar body[512];\n\tint bodylen;\n\tstruct ifdata data;\n\n\tr = getifstats(ext_if_name, &data);\n\tbodylen = snprintf(body, sizeof(body), resp,\n\t         action, ns, /* was \"urn:schemas-upnp-org:service:WANCommonInterfaceConfig:1\" */\n#ifdef UPNP_STRICT\n\t         r<0?0:(data.ipackets & UPNP_UI4_MAX), action);\n#else /* UPNP_STRICT */\n\t         r<0?0:data.ipackets, action);\n#endif /* UPNP_STRICT */\n\tBuildSendAndCloseSoapResp(h, body, bodylen);\n}\n\nstatic void\nGetCommonLinkProperties(struct upnphttp * h, const char * action, const char * ns)\n{\n\t/* WANAccessType : set depending on the hardware :\n\t * DSL, POTS (plain old Telephone service), Cable, Ethernet */\n\tstatic const char resp[] =\n\t\t\"<u:%sResponse \"\n\t\t\"xmlns:u=\\\"%s\\\">\"\n\t\t\"<NewWANAccessType>%s</NewWANAccessType>\"\n\t\t\"<NewLayer1UpstreamMaxBitRate>%lu</NewLayer1UpstreamMaxBitRate>\"\n\t\t\"<NewLayer1DownstreamMaxBitRate>%lu</NewLayer1DownstreamMaxBitRate>\"\n\t\t\"<NewPhysicalLinkStatus>%s</NewPhysicalLinkStatus>\"\n\t\t\"</u:%sResponse>\";\n\n\tchar body[2048];\n\tint bodylen;\n\tstruct ifdata data;\n\tconst char * status = \"Up\";\t/* Up, Down (Required),\n\t                             * Initializing, Unavailable (Optional) */\n\tconst char * wan_access_type = \"Cable\"; /* DSL, POTS, Cable, Ethernet */\n\tchar ext_ip_addr[INET_ADDRSTRLEN];\n\n\tif((downstream_bitrate == 0) || (upstream_bitrate == 0))\n\t{\n\t\tif(getifstats(ext_if_name, &data) >= 0)\n\t\t{\n\t\t\tif(downstream_bitrate == 0) downstream_bitrate = data.baudrate;\n\t\t\tif(upstream_bitrate == 0) upstream_bitrate = data.baudrate;\n\t\t}\n\t}\n\tif(getifaddr(ext_if_name, ext_ip_addr, INET_ADDRSTRLEN, NULL, NULL) < 0) {\n\t\tstatus = \"Down\";\n\t}\n\tbodylen = snprintf(body, sizeof(body), resp,\n\t    action, ns, /* was \"urn:schemas-upnp-org:service:WANCommonInterfaceConfig:1\" */\n\t    wan_access_type,\n\t    upstream_bitrate, downstream_bitrate,\n\t    status, action);\n\tBuildSendAndCloseSoapResp(h, body, bodylen);\n}\n\nstatic void\nGetStatusInfo(struct upnphttp * h, const char * action, const char * ns)\n{\n\tstatic const char resp[] =\n\t\t\"<u:%sResponse \"\n\t\t\"xmlns:u=\\\"%s\\\">\"\n\t\t\"<NewConnectionStatus>%s</NewConnectionStatus>\"\n\t\t\"<NewLastConnectionError>ERROR_NONE</NewLastConnectionError>\"\n\t\t\"<NewUptime>%ld</NewUptime>\"\n\t\t\"</u:%sResponse>\";\n\n\tchar body[512];\n\tint bodylen;\n\ttime_t uptime;\n\tconst char * status;\n\t/* ConnectionStatus possible values :\n\t * Unconfigured, Connecting, Connected, PendingDisconnect,\n\t * Disconnecting, Disconnected */\n\n\tstatus = get_wan_connection_status_str(ext_if_name);\n\tuptime = upnp_get_uptime();\n\tbodylen = snprintf(body, sizeof(body), resp,\n\t\taction, ns, /*SERVICE_TYPE_WANIPC,*/\n\t\tstatus, (long)uptime, action);\n\tBuildSendAndCloseSoapResp(h, body, bodylen);\n}\n\nstatic void\nGetNATRSIPStatus(struct upnphttp * h, const char * action, const char * ns)\n{\n#if 0\n\tstatic const char resp[] =\n\t\t\"<u:GetNATRSIPStatusResponse \"\n\t\t\"xmlns:u=\\\"\" SERVICE_TYPE_WANIPC \"\\\">\"\n\t\t\"<NewRSIPAvailable>0</NewRSIPAvailable>\"\n\t\t\"<NewNATEnabled>1</NewNATEnabled>\"\n\t\t\"</u:GetNATRSIPStatusResponse>\";\n\tUNUSED(action);\n#endif\n\tstatic const char resp[] =\n\t\t\"<u:%sResponse \"\n\t\t\"xmlns:u=\\\"%s\\\">\"\n\t\t\"<NewRSIPAvailable>0</NewRSIPAvailable>\"\n\t\t\"<NewNATEnabled>1</NewNATEnabled>\"\n\t\t\"</u:%sResponse>\";\n\tchar body[512];\n\tint bodylen;\n\t/* 2.2.9. RSIPAvailable\n\t * This variable indicates if Realm-specific IP (RSIP) is available\n\t * as a feature on the InternetGatewayDevice. RSIP is being defined\n\t * in the NAT working group in the IETF to allow host-NATing using\n\t * a standard set of message exchanges. It also allows end-to-end\n\t * applications that otherwise break if NAT is introduced\n\t * (e.g. IPsec-based VPNs).\n\t * A gateway that does not support RSIP should set this variable to 0. */\n\tbodylen = snprintf(body, sizeof(body), resp,\n\t\taction, ns, /*SERVICE_TYPE_WANIPC,*/\n\t\taction);\n\tBuildSendAndCloseSoapResp(h, body, bodylen);\n}\n\nstatic void\nGetExternalIPAddress(struct upnphttp * h, const char * action, const char * ns)\n{\n\tstatic const char resp[] =\n\t\t\"<u:%sResponse \"\n\t\t\"xmlns:u=\\\"%s\\\">\"\n\t\t\"<NewExternalIPAddress>%s</NewExternalIPAddress>\"\n\t\t\"</u:%sResponse>\";\n\n\tchar body[512];\n\tint bodylen;\n\tchar ext_ip_addr[INET_ADDRSTRLEN];\n\t/* Does that method need to work with IPv6 ?\n\t * There is usually no NAT with IPv6 */\n\n#ifndef MULTIPLE_EXTERNAL_IP\n\tstruct in_addr addr;\n\tif(use_ext_ip_addr)\n\t{\n\t\tstrncpy(ext_ip_addr, use_ext_ip_addr, INET_ADDRSTRLEN);\n\t\text_ip_addr[INET_ADDRSTRLEN - 1] = '\\0';\n\t}\n\telse if(getifaddr(ext_if_name, ext_ip_addr, INET_ADDRSTRLEN, &addr, NULL) < 0)\n\t{\n\t\tsyslog(LOG_ERR, \"Failed to get ip address for interface %s\",\n\t\t\text_if_name);\n\t\tstrncpy(ext_ip_addr, \"0.0.0.0\", INET_ADDRSTRLEN);\n\t}\n\tif (addr_is_reserved(&addr))\n\t\tstrncpy(ext_ip_addr, \"0.0.0.0\", INET_ADDRSTRLEN);\n#else\n\tstruct lan_addr_s * lan_addr;\n\tstrncpy(ext_ip_addr, \"0.0.0.0\", INET_ADDRSTRLEN);\n\tfor(lan_addr = lan_addrs.lh_first; lan_addr != NULL; lan_addr = lan_addr->list.le_next)\n\t{\n\t\tif( (h->clientaddr.s_addr & lan_addr->mask.s_addr)\n\t\t   == (lan_addr->addr.s_addr & lan_addr->mask.s_addr))\n\t\t{\n\t\t\tstrncpy(ext_ip_addr, lan_addr->ext_ip_str, INET_ADDRSTRLEN);\n\t\t\tbreak;\n\t\t}\n\t}\n#endif\n\tif (strcmp(ext_ip_addr, \"0.0.0.0\") == 0)\n\t{\n\t\tSoapError(h, 501, \"Action Failed\");\n\t\treturn;\n\t}\n\tbodylen = snprintf(body, sizeof(body), resp,\n\t              action, ns, /*SERVICE_TYPE_WANIPC,*/\n\t\t\t\t  ext_ip_addr, action);\n\tBuildSendAndCloseSoapResp(h, body, bodylen);\n}\n\n/* AddPortMapping method of WANIPConnection Service\n * Ignored argument : NewEnabled */\nstatic void\nAddPortMapping(struct upnphttp * h, const char * action, const char * ns)\n{\n\tint r;\n\n\t/*static const char resp[] =\n\t\t\"<u:AddPortMappingResponse \"\n\t\t\"xmlns:u=\\\"\" SERVICE_TYPE_WANIPC \"\\\"/>\";*/\n\tstatic const char resp[] =\n\t\t\"<u:%sResponse \"\n\t\t\"xmlns:u=\\\"%s\\\"/>\";\n\n\tchar body[512];\n\tint bodylen;\n\tstruct NameValueParserData data;\n\tchar * int_ip, * int_port, * ext_port, * protocol, * desc;\n\tchar * leaseduration_str;\n\tunsigned int leaseduration;\n\tchar * r_host;\n\tunsigned short iport, eport;\n\n\tstruct hostent *hp; /* getbyhostname() */\n\tchar ** ptr; /* getbyhostname() */\n\tstruct in_addr result_ip;/*unsigned char result_ip[16];*/ /* inet_pton() */\n\n\tParseNameValue(h->req_buf + h->req_contentoff, h->req_contentlen, &data);\n\tint_ip = GetValueFromNameValueList(&data, \"NewInternalClient\");\n\tif (int_ip) {\n\t\t/* trim */\n\t\twhile(int_ip[0] == ' ')\n\t\t\tint_ip++;\n\t}\n#ifdef UPNP_STRICT\n\tif (!int_ip || int_ip[0] == '\\0')\n\t{\n\t\tClearNameValueList(&data);\n\t\tSoapError(h, 402, \"Invalid Args\");\n\t\treturn;\n\t}\n#endif\n\n\t/* IGD 2 MUST support both wildcard and specific IP address values\n\t * for RemoteHost (only the wildcard value was REQUIRED in release 1.0) */\n\tr_host = GetValueFromNameValueList(&data, \"NewRemoteHost\");\n#ifndef SUPPORT_REMOTEHOST\n#ifdef UPNP_STRICT\n\tif (r_host && (r_host[0] != '\\0') && (0 != strcmp(r_host, \"*\")))\n\t{\n\t\tClearNameValueList(&data);\n\t\tSoapError(h, 726, \"RemoteHostOnlySupportsWildcard\");\n\t\treturn;\n\t}\n#endif\n#endif\n\n#ifndef UPNP_STRICT\n\t/* if <NewInternalClient> arg is empty, use client address\n\t * see https://github.com/miniupnp/miniupnp/issues/236 */\n\tif (!int_ip || int_ip[0] == '\\0')\n\t{\n\t\tint_ip = h->clientaddr_str;\n\t\tmemcpy(&result_ip, &(h->clientaddr), sizeof(struct in_addr));\n\t}\n\telse\n#endif\n\t/* if ip not valid assume hostname and convert */\n\tif (inet_pton(AF_INET, int_ip, &result_ip) <= 0)\n\t{\n\t\thp = gethostbyname(int_ip);\n\t\tif(hp && hp->h_addrtype == AF_INET)\n\t\t{\n\t\t\tfor(ptr = hp->h_addr_list; ptr && *ptr; ptr++)\n\t\t   \t{\n\t\t\t\tint_ip = inet_ntoa(*((struct in_addr *) *ptr));\n\t\t\t\tresult_ip = *((struct in_addr *) *ptr);\n\t\t\t\t/* TODO : deal with more than one ip per hostname */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsyslog(LOG_ERR, \"Failed to convert hostname '%s' to ip address\", int_ip);\n\t\t\tClearNameValueList(&data);\n\t\t\tSoapError(h, 402, \"Invalid Args\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* check if NewInternalAddress is the client address */\n\tif(GETFLAG(SECUREMODEMASK))\n\t{\n\t\tif(h->clientaddr.s_addr != result_ip.s_addr)\n\t\t{\n\t\t\tsyslog(LOG_INFO, \"Client %s tried to redirect port to %s\",\n\t\t\t       inet_ntoa(h->clientaddr), int_ip);\n\t\t\tClearNameValueList(&data);\n\t\t\tSoapError(h, 718, \"ConflictInMappingEntry\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\tint_port = GetValueFromNameValueList(&data, \"NewInternalPort\");\n\text_port = GetValueFromNameValueList(&data, \"NewExternalPort\");\n\tprotocol = GetValueFromNameValueList(&data, \"NewProtocol\");\n\tdesc = GetValueFromNameValueList(&data, \"NewPortMappingDescription\");\n\tleaseduration_str = GetValueFromNameValueList(&data, \"NewLeaseDuration\");\n\n\tif (!int_port || !ext_port || !protocol)\n\t{\n\t\tClearNameValueList(&data);\n\t\tSoapError(h, 402, \"Invalid Args\");\n\t\treturn;\n\t}\n\n\teport = (unsigned short)atoi(ext_port);\n\tiport = (unsigned short)atoi(int_port);\n\n\tif (strcmp(ext_port, \"*\") == 0 || eport == 0)\n\t{\n\t\tClearNameValueList(&data);\n\t\tSoapError(h, 716, \"Wildcard not permited in ExtPort\");\n\t\treturn;\n\t}\n\n\tleaseduration = leaseduration_str ? atoi(leaseduration_str) : 0;\n#ifdef IGD_V2\n\t/* PortMappingLeaseDuration can be either a value between 1 and\n\t * 604800 seconds or the zero value (for infinite lease time).\n\t * Note that an infinite lease time can be only set by out-of-band\n\t * mechanisms like WWW-administration, remote management or local\n\t * management.\n\t * If a control point uses the value 0 to indicate an infinite lease\n\t * time mapping, it is REQUIRED that gateway uses the maximum value\n\t * instead (e.g. 604800 seconds) */\n\tif(leaseduration == 0 || leaseduration > 604800)\n\t\tleaseduration = 604800;\n#endif\n\n\tsyslog(LOG_INFO, \"%s: ext port %hu to %s:%hu protocol %s for: %s leaseduration=%u rhost=%s\",\n\t       action, eport, int_ip, iport, protocol, desc, leaseduration,\n\t       r_host ? r_host : \"NULL\");\n\n\tr = upnp_redirect(r_host, eport, int_ip, iport, protocol, desc, leaseduration);\n\n\tClearNameValueList(&data);\n\n\t/* possible error codes for AddPortMapping :\n\t * 402 - Invalid Args\n\t * 501 - Action Failed\n\t * 715 - Wildcard not permited in SrcAddr\n\t * 716 - Wildcard not permited in ExtPort\n\t * 718 - ConflictInMappingEntry\n\t * 724 - SamePortValuesRequired (deprecated in IGD v2)\n     * 725 - OnlyPermanentLeasesSupported\n             The NAT implementation only supports permanent lease times on\n             port mappings (deprecated in IGD v2)\n     * 726 - RemoteHostOnlySupportsWildcard\n             RemoteHost must be a wildcard and cannot be a specific IP\n             address or DNS name (deprecated in IGD v2)\n     * 727 - ExternalPortOnlySupportsWildcard\n             ExternalPort must be a wildcard and cannot be a specific port\n             value (deprecated in IGD v2)\n     * 728 - NoPortMapsAvailable\n             There are not enough free ports available to complete the mapping\n             (added in IGD v2)\n\t * 729 - ConflictWithOtherMechanisms (added in IGD v2) */\n\tswitch(r)\n\t{\n\tcase 0:\t/* success */\n\t\tbodylen = snprintf(body, sizeof(body), resp,\n\t\t                   action, ns/*SERVICE_TYPE_WANIPC*/);\n\t\tBuildSendAndCloseSoapResp(h, body, bodylen);\n\t\tbreak;\n\tcase -4:\n#ifdef IGD_V2\n\t\tSoapError(h, 729, \"ConflictWithOtherMechanisms\");\n\t\tbreak;\n#endif /* IGD_V2 */\n\tcase -2:\t/* already redirected */\n\tcase -3:\t/* not permitted */\n\t\tSoapError(h, 718, \"ConflictInMappingEntry\");\n\t\tbreak;\n\tdefault:\n\t\tSoapError(h, 501, \"ActionFailed\");\n\t}\n}\n\n/* AddAnyPortMapping was added in WANIPConnection v2 */\nstatic void\nAddAnyPortMapping(struct upnphttp * h, const char * action, const char * ns)\n{\n\tint r;\n\tstatic const char resp[] =\n\t\t\"<u:%sResponse \"\n\t\t\"xmlns:u=\\\"%s\\\">\"\n\t\t\"<NewReservedPort>%hu</NewReservedPort>\"\n\t\t\"</u:%sResponse>\";\n\n\tchar body[512];\n\tint bodylen;\n\n\tstruct NameValueParserData data;\n\tconst char * int_ip, * int_port, * ext_port, * protocol, * desc;\n\tconst char * r_host;\n\tunsigned short iport, eport;\n\tconst char * leaseduration_str;\n\tunsigned int leaseduration;\n\n\tstruct hostent *hp; /* getbyhostname() */\n\tchar ** ptr; /* getbyhostname() */\n\tstruct in_addr result_ip;/*unsigned char result_ip[16];*/ /* inet_pton() */\n\n\tParseNameValue(h->req_buf + h->req_contentoff, h->req_contentlen, &data);\n\tr_host = GetValueFromNameValueList(&data, \"NewRemoteHost\");\n\text_port = GetValueFromNameValueList(&data, \"NewExternalPort\");\n\tprotocol = GetValueFromNameValueList(&data, \"NewProtocol\");\n\tint_port = GetValueFromNameValueList(&data, \"NewInternalPort\");\n\tint_ip = GetValueFromNameValueList(&data, \"NewInternalClient\");\n\t/* NewEnabled */\n\tdesc = GetValueFromNameValueList(&data, \"NewPortMappingDescription\");\n\tleaseduration_str = GetValueFromNameValueList(&data, \"NewLeaseDuration\");\n\n\tleaseduration = leaseduration_str ? atoi(leaseduration_str) : 0;\n\tif(leaseduration == 0)\n\t\tleaseduration = 604800;\n\n\tif (!int_ip || !ext_port || !int_port)\n\t{\n\t\tClearNameValueList(&data);\n\t\tSoapError(h, 402, \"Invalid Args\");\n\t\treturn;\n\t}\n\n\teport = (unsigned short)atoi(ext_port);\n\tiport = (unsigned short)atoi(int_port);\n\tif(iport == 0 || !is_numeric(ext_port)) {\n\t\tClearNameValueList(&data);\n\t\tSoapError(h, 402, \"Invalid Args\");\n\t\treturn;\n\t}\n#ifndef SUPPORT_REMOTEHOST\n#ifdef UPNP_STRICT\n\tif (r_host && (r_host[0] != '\\0') && (0 != strcmp(r_host, \"*\")))\n\t{\n\t\tClearNameValueList(&data);\n\t\tSoapError(h, 726, \"RemoteHostOnlySupportsWildcard\");\n\t\treturn;\n\t}\n#endif\n#endif\n\n\t/* if ip not valid assume hostname and convert */\n\tif (inet_pton(AF_INET, int_ip, &result_ip) <= 0)\n\t{\n\t\thp = gethostbyname(int_ip);\n\t\tif(hp && hp->h_addrtype == AF_INET)\n\t\t{\n\t\t\tfor(ptr = hp->h_addr_list; ptr && *ptr; ptr++)\n\t\t   \t{\n\t\t\t\tint_ip = inet_ntoa(*((struct in_addr *) *ptr));\n\t\t\t\tresult_ip = *((struct in_addr *) *ptr);\n\t\t\t\t/* TODO : deal with more than one ip per hostname */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsyslog(LOG_ERR, \"Failed to convert hostname '%s' to ip address\", int_ip);\n\t\t\tClearNameValueList(&data);\n\t\t\tSoapError(h, 402, \"Invalid Args\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* check if NewInternalAddress is the client address */\n\tif(GETFLAG(SECUREMODEMASK))\n\t{\n\t\tif(h->clientaddr.s_addr != result_ip.s_addr)\n\t\t{\n\t\t\tsyslog(LOG_INFO, \"Client %s tried to redirect port to %s\",\n\t\t\t       inet_ntoa(h->clientaddr), int_ip);\n\t\t\tClearNameValueList(&data);\n\t\t\tSoapError(h, 606, \"Action not authorized\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* TODO : accept a different external port\n\t * have some smart strategy to choose the port */\n\tfor(;;) {\n\t\tr = upnp_redirect(r_host, eport, int_ip, iport, protocol, desc, leaseduration);\n\t\tif(r==-2 && eport < 65535) {\n\t\t\teport++;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tClearNameValueList(&data);\n\n\tswitch(r)\n\t{\n\tcase 0:\t/* success */\n\t\tbodylen = snprintf(body, sizeof(body), resp,\n\t\t              action, ns, /*SERVICE_TYPE_WANIPC,*/\n\t\t\t\t\t  eport, action);\n\t\tBuildSendAndCloseSoapResp(h, body, bodylen);\n\t\tbreak;\n\tcase -2:\t/* already redirected */\n\t\tSoapError(h, 718, \"ConflictInMappingEntry\");\n\t\tbreak;\n\tcase -3:\t/* not permitted */\n\t\tSoapError(h, 606, \"Action not authorized\");\n\t\tbreak;\n\tdefault:\n\t\tSoapError(h, 501, \"ActionFailed\");\n\t}\n}\n\nstatic void\nGetSpecificPortMappingEntry(struct upnphttp * h, const char * action, const char * ns)\n{\n\tint r;\n\n\tstatic const char resp[] =\n\t\t\"<u:%sResponse \"\n\t\t\"xmlns:u=\\\"%s\\\">\"\n\t\t\"<NewInternalPort>%u</NewInternalPort>\"\n\t\t\"<NewInternalClient>%s</NewInternalClient>\"\n\t\t\"<NewEnabled>1</NewEnabled>\"\n\t\t\"<NewPortMappingDescription>%s</NewPortMappingDescription>\"\n\t\t\"<NewLeaseDuration>%u</NewLeaseDuration>\"\n\t\t\"</u:%sResponse>\";\n\n\tchar body[1024];\n\tint bodylen;\n\tstruct NameValueParserData data;\n\tconst char * r_host, * ext_port, * protocol;\n\tunsigned short eport, iport;\n\tchar int_ip[32];\n\tchar desc[64];\n\tunsigned int leaseduration = 0;\n\n\tParseNameValue(h->req_buf + h->req_contentoff, h->req_contentlen, &data);\n\tr_host = GetValueFromNameValueList(&data, \"NewRemoteHost\");\n\text_port = GetValueFromNameValueList(&data, \"NewExternalPort\");\n\tprotocol = GetValueFromNameValueList(&data, \"NewProtocol\");\n\n#ifdef UPNP_STRICT\n\tif(!ext_port || !protocol || !r_host)\n#else\n\tif(!ext_port || !protocol)\n#endif\n\t{\n\t\tClearNameValueList(&data);\n\t\tSoapError(h, 402, \"Invalid Args\");\n\t\treturn;\n\t}\n#ifndef SUPPORT_REMOTEHOST\n#ifdef UPNP_STRICT\n\tif (r_host && (r_host[0] != '\\0') && (0 != strcmp(r_host, \"*\")))\n\t{\n\t\tClearNameValueList(&data);\n\t\tSoapError(h, 726, \"RemoteHostOnlySupportsWildcard\");\n\t\treturn;\n\t}\n#endif\n#endif\n\n\teport = (unsigned short)atoi(ext_port);\n\tif(eport == 0)\n\t{\n\t\tClearNameValueList(&data);\n\t\tSoapError(h, 402, \"Invalid Args\");\n\t\treturn;\n\t}\n\n\t/* TODO : add r_host as an input parameter ...\n\t * We prevent several Port Mapping with same external port\n\t * but different remoteHost to be set up, so that is not\n\t * a priority. */\n\tr = upnp_get_redirection_infos(eport, protocol, &iport,\n\t                               int_ip, sizeof(int_ip),\n\t                               desc, sizeof(desc),\n\t                               NULL, 0,\n\t                               &leaseduration);\n\n\tif(r < 0)\n\t{\n\t\tSoapError(h, 714, \"NoSuchEntryInArray\");\n\t}\n\telse\n\t{\n\t\tsyslog(LOG_INFO, \"%s: rhost='%s' %s %s found => %s:%u desc='%s'\",\n\t\t       action,\n\t\t       r_host ? r_host : \"NULL\", ext_port, protocol, int_ip,\n\t\t       (unsigned int)iport, desc);\n\t\tbodylen = snprintf(body, sizeof(body), resp,\n\t\t\t\taction, ns/*SERVICE_TYPE_WANIPC*/,\n\t\t\t\t(unsigned int)iport, int_ip, desc, leaseduration,\n\t\t\t\taction);\n\t\tBuildSendAndCloseSoapResp(h, body, bodylen);\n\t}\n\n\tClearNameValueList(&data);\n}\n\nstatic void\nDeletePortMapping(struct upnphttp * h, const char * action, const char * ns)\n{\n\tint r;\n\n\t/*static const char resp[] =\n\t\t\"<u:DeletePortMappingResponse \"\n\t\t\"xmlns:u=\\\"\" SERVICE_TYPE_WANIPC \"\\\">\"\n\t\t\"</u:DeletePortMappingResponse>\";*/\n\tstatic const char resp[] =\n\t\t\"<u:%sResponse \"\n\t\t\"xmlns:u=\\\"%s\\\">\"\n\t\t\"</u:%sResponse>\";\n\n\tchar body[512];\n\tint bodylen;\n\tstruct NameValueParserData data;\n\tconst char * ext_port, * protocol;\n\tunsigned short eport;\n#ifdef UPNP_STRICT\n\tconst char * r_host;\n#endif /* UPNP_STRICT */\n\n\tParseNameValue(h->req_buf + h->req_contentoff, h->req_contentlen, &data);\n\text_port = GetValueFromNameValueList(&data, \"NewExternalPort\");\n\tprotocol = GetValueFromNameValueList(&data, \"NewProtocol\");\n#ifdef UPNP_STRICT\n\tr_host = GetValueFromNameValueList(&data, \"NewRemoteHost\");\n#endif /* UPNP_STRICT */\n\n#ifdef UPNP_STRICT\n\tif(!ext_port || !protocol || !r_host)\n#else\n\tif(!ext_port || !protocol)\n#endif /* UPNP_STRICT */\n\t{\n\t\tClearNameValueList(&data);\n\t\tSoapError(h, 402, \"Invalid Args\");\n\t\treturn;\n\t}\n#ifndef SUPPORT_REMOTEHOST\n#ifdef UPNP_STRICT\n\tif (r_host && (r_host[0] != '\\0') && (0 != strcmp(r_host, \"*\")))\n\t{\n\t\tClearNameValueList(&data);\n\t\tSoapError(h, 726, \"RemoteHostOnlySupportsWildcard\");\n\t\treturn;\n\t}\n#endif /* UPNP_STRICT */\n#endif /* SUPPORT_REMOTEHOST */\n\n\teport = (unsigned short)atoi(ext_port);\n\tif(eport == 0)\n\t{\n\t\tClearNameValueList(&data);\n\t\tSoapError(h, 402, \"Invalid Args\");\n\t\treturn;\n\t}\n\n\tsyslog(LOG_INFO, \"%s: external port: %hu, protocol: %s\",\n\t\taction, eport, protocol);\n\n\t/* if in secure mode, check the IP\n\t * Removing a redirection is not a security threat,\n\t * just an annoyance for the user using it. So this is not\n\t * a priority. */\n\tif(GETFLAG(SECUREMODEMASK))\n\t{\n\t\tchar int_ip[32];\n\t\tstruct in_addr int_ip_addr;\n\t\tunsigned short iport;\n\t\tunsigned int leaseduration = 0;\n\t\tr = upnp_get_redirection_infos(eport, protocol, &iport,\n\t\t                               int_ip, sizeof(int_ip),\n\t\t                               NULL, 0, NULL, 0,\n\t\t                               &leaseduration);\n\t\tif(r >= 0)\n\t\t{\n\t\t\tif(inet_pton(AF_INET, int_ip, &int_ip_addr) > 0)\n\t\t\t{\n\t\t\t\tif(h->clientaddr.s_addr != int_ip_addr.s_addr)\n\t\t\t\t{\n\t\t\t\t\tSoapError(h, 606, \"Action not authorized\");\n\t\t\t\t\t/*SoapError(h, 714, \"NoSuchEntryInArray\");*/\n\t\t\t\t\tClearNameValueList(&data);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tr = upnp_delete_redirection(eport, protocol);\n\n\tif(r < 0)\n\t{\n\t\tSoapError(h, 714, \"NoSuchEntryInArray\");\n\t}\n\telse\n\t{\n\t\tbodylen = snprintf(body, sizeof(body), resp,\n\t\t                   action, ns, action);\n\t\tBuildSendAndCloseSoapResp(h, body, bodylen);\n\t}\n\n\tClearNameValueList(&data);\n}\n\n/* DeletePortMappingRange was added in IGD spec v2 */\nstatic void\nDeletePortMappingRange(struct upnphttp * h, const char * action, const char * ns)\n{\n\tint r = -1;\n\t/*static const char resp[] =\n\t\t\"<u:DeletePortMappingRangeResponse \"\n\t\t\"xmlns:u=\\\"\" SERVICE_TYPE_WANIPC \"\\\">\"\n\t\t\"</u:DeletePortMappingRangeResponse>\";*/\n\tstatic const char resp[] =\n\t\t\"<u:%sResponse \"\n\t\t\"xmlns:u=\\\"%s\\\">\"\n\t\t\"</u:%sResponse>\";\n\tchar body[512];\n\tint bodylen;\n\tstruct NameValueParserData data;\n\tconst char * protocol;\n\tconst char * startport_s, * endport_s;\n\tunsigned short startport, endport;\n\t/*int manage;*/\n\tunsigned short * port_list;\n\tunsigned int i, number = 0;\n\n\tParseNameValue(h->req_buf + h->req_contentoff, h->req_contentlen, &data);\n\tstartport_s = GetValueFromNameValueList(&data, \"NewStartPort\");\n\tendport_s = GetValueFromNameValueList(&data, \"NewEndPort\");\n\tprotocol = GetValueFromNameValueList(&data, \"NewProtocol\");\n\t/*manage = atoi(GetValueFromNameValueList(&data, \"NewManage\"));*/\n\tif(startport_s == NULL || endport_s == NULL || protocol == NULL ||\n\t   !is_numeric(startport_s) || !is_numeric(endport_s)) {\n\t\tSoapError(h, 402, \"Invalid Args\");\n\t\tClearNameValueList(&data);\n\t\treturn;\n\t}\n\tstartport = (unsigned short)atoi(startport_s);\n\tendport = (unsigned short)atoi(endport_s);\n\n\t/* possible errors :\n\t   606 - Action not authorized\n\t   730 - PortMappingNotFound\n\t   733 - InconsistentParameter\n\t */\n\tif(startport > endport)\n\t{\n\t\tSoapError(h, 733, \"InconsistentParameter\");\n\t\tClearNameValueList(&data);\n\t\treturn;\n\t}\n\n\tsyslog(LOG_INFO, \"%s: deleting external ports: %hu-%hu, protocol: %s\",\n\t       action, startport, endport, protocol);\n\n\tport_list = upnp_get_portmappings_in_range(startport, endport,\n\t                                           protocol, &number);\n\tif(number == 0)\n\t{\n\t\tSoapError(h, 730, \"PortMappingNotFound\");\n\t\tClearNameValueList(&data);\n\t\tfree(port_list);\n\t\treturn;\n\t}\n\n\tfor(i = 0; i < number; i++)\n\t{\n\t\tr = upnp_delete_redirection(port_list[i], protocol);\n\t\tsyslog(LOG_INFO, \"%s: deleting external port: %hu, protocol: %s: %s\",\n\t\t       action, port_list[i], protocol, r < 0 ? \"failed\" : \"ok\");\n\t}\n\tfree(port_list);\n\tbodylen = snprintf(body, sizeof(body), resp,\n\t                   action, ns, action);\n\tBuildSendAndCloseSoapResp(h, body, bodylen);\n\n\tClearNameValueList(&data);\n}\n\nstatic void\nGetGenericPortMappingEntry(struct upnphttp * h, const char * action, const char * ns)\n{\n\tint r;\n\n\tstatic const char resp[] =\n\t\t\"<u:%sResponse \"\n\t\t\"xmlns:u=\\\"%s\\\">\"\n\t\t\"<NewRemoteHost>%s</NewRemoteHost>\"\n\t\t\"<NewExternalPort>%u</NewExternalPort>\"\n\t\t\"<NewProtocol>%s</NewProtocol>\"\n\t\t\"<NewInternalPort>%u</NewInternalPort>\"\n\t\t\"<NewInternalClient>%s</NewInternalClient>\"\n\t\t\"<NewEnabled>1</NewEnabled>\"\n\t\t\"<NewPortMappingDescription>%s</NewPortMappingDescription>\"\n\t\t\"<NewLeaseDuration>%u</NewLeaseDuration>\"\n\t\t\"</u:%sResponse>\";\n\n\tlong int index = 0;\n\tunsigned short eport, iport;\n\tconst char * m_index;\n\tchar * endptr;\n\tchar protocol[8], iaddr[32];\n\tchar desc[64];\n\tchar rhost[40];\n\tunsigned int leaseduration = 0;\n\tstruct NameValueParserData data;\n\n\tParseNameValue(h->req_buf + h->req_contentoff, h->req_contentlen, &data);\n\tm_index = GetValueFromNameValueList(&data, \"NewPortMappingIndex\");\n\n\tif(!m_index)\n\t{\n\t\tClearNameValueList(&data);\n\t\tSoapError(h, 402, \"Invalid Args\");\n\t\treturn;\n\t}\n\terrno = 0;\t/* To distinguish success/failure after call */\n\tindex = strtol(m_index, &endptr, 10);\n\tif((errno == ERANGE && (index == LONG_MAX || index == LONG_MIN))\n\t   || (errno != 0 && index == 0) || (m_index == endptr))\n\t{\n\t\t/* should condition (*endptr != '\\0') be also an error ? */\n\t\tif(m_index == endptr)\n\t\t\tsyslog(LOG_WARNING, \"%s: no digits were found in <%s>\",\n\t\t\t       \"GetGenericPortMappingEntry\", \"NewPortMappingIndex\");\n\t\telse\n\t\t\tsyslog(LOG_WARNING, \"%s: strtol('%s'): %m\",\n\t\t\t       \"GetGenericPortMappingEntry\", m_index);\n\t\tClearNameValueList(&data);\n\t\tSoapError(h, 402, \"Invalid Args\");\n\t\treturn;\n\t}\n\n\tsyslog(LOG_INFO, \"%s: index=%d\", action, (int)index);\n\n\trhost[0] = '\\0';\n\tr = upnp_get_redirection_infos_by_index((int)index, &eport, protocol, &iport,\n                                            iaddr, sizeof(iaddr),\n\t                                        desc, sizeof(desc),\n\t                                        rhost, sizeof(rhost),\n\t                                        &leaseduration);\n\n\tif(r < 0)\n\t{\n\t\tSoapError(h, 713, \"SpecifiedArrayIndexInvalid\");\n\t}\n\telse\n\t{\n\t\tint bodylen;\n\t\tchar body[2048];\n\t\tbodylen = snprintf(body, sizeof(body), resp,\n\t\t\taction, ns, /*SERVICE_TYPE_WANIPC,*/ rhost,\n\t\t\t(unsigned int)eport, protocol, (unsigned int)iport, iaddr, desc,\n\t\t    leaseduration, action);\n\t\tBuildSendAndCloseSoapResp(h, body, bodylen);\n\t}\n\n\tClearNameValueList(&data);\n}\n\n/* GetListOfPortMappings was added in the IGD v2 specification */\nstatic void\nGetListOfPortMappings(struct upnphttp * h, const char * action, const char * ns)\n{\n\tstatic const char resp_start[] =\n\t\t\"<u:%sResponse \"\n\t\t\"xmlns:u=\\\"%s\\\">\"\n\t\t\"<NewPortListing><![CDATA[\";\n\tstatic const char resp_end[] =\n\t\t\"]]></NewPortListing>\"\n\t\t\"</u:%sResponse>\";\n\n\tstatic const char list_start[] =\n\t\t\"<p:PortMappingList xmlns:p=\\\"urn:schemas-upnp-org:gw:WANIPConnection\\\"\"\n\t\t\" xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\"\"\n\t\t\" xsi:schemaLocation=\\\"urn:schemas-upnp-org:gw:WANIPConnection\"\n\t\t\" http://www.upnp.org/schemas/gw/WANIPConnection-v2.xsd\\\">\";\n\tstatic const char list_end[] =\n\t\t\"</p:PortMappingList>\";\n\n\tstatic const char entry[] =\n\t\t\"<p:PortMappingEntry>\"\n\t\t\"<p:NewRemoteHost>%s</p:NewRemoteHost>\"\n\t\t\"<p:NewExternalPort>%hu</p:NewExternalPort>\"\n\t\t\"<p:NewProtocol>%s</p:NewProtocol>\"\n\t\t\"<p:NewInternalPort>%hu</p:NewInternalPort>\"\n\t\t\"<p:NewInternalClient>%s</p:NewInternalClient>\"\n\t\t\"<p:NewEnabled>1</p:NewEnabled>\"\n\t\t\"<p:NewDescription>%s</p:NewDescription>\"\n\t\t\"<p:NewLeaseTime>%u</p:NewLeaseTime>\"\n\t\t\"</p:PortMappingEntry>\";\n\n\tchar * body;\n\tsize_t bodyalloc;\n\tint bodylen;\n\n\tint r = -1;\n\tunsigned short iport;\n\tchar int_ip[32];\n\tchar desc[64];\n\tchar rhost[64];\n\tunsigned int leaseduration = 0;\n\n\tstruct NameValueParserData data;\n\tconst char * startport_s, * endport_s;\n\tunsigned short startport, endport;\n\tconst char * protocol;\n\t/*int manage;*/\n\tconst char * number_s;\n\tint number;\n\tunsigned short * port_list;\n\tunsigned int i, list_size = 0;\n\n\tParseNameValue(h->req_buf + h->req_contentoff, h->req_contentlen, &data);\n\tstartport_s = GetValueFromNameValueList(&data, \"NewStartPort\");\n\tendport_s = GetValueFromNameValueList(&data, \"NewEndPort\");\n\tprotocol = GetValueFromNameValueList(&data, \"NewProtocol\");\n\t/*manage_s = GetValueFromNameValueList(&data, \"NewManage\");*/\n\tnumber_s = GetValueFromNameValueList(&data, \"NewNumberOfPorts\");\n\tif(startport_s == NULL || endport_s == NULL || protocol == NULL ||\n\t   number_s == NULL || !is_numeric(number_s) ||\n\t   !is_numeric(startport_s) || !is_numeric(endport_s)) {\n\t\tSoapError(h, 402, \"Invalid Args\");\n\t\tClearNameValueList(&data);\n\t\treturn;\n\t}\n\n\tstartport = (unsigned short)atoi(startport_s);\n\tendport = (unsigned short)atoi(endport_s);\n\t/*manage = atoi(manage_s);*/\n\tnumber = atoi(number_s);\n\tif(number == 0) number = 1000;\t/* return up to 1000 mappings by default */\n\n\tif(startport > endport)\n\t{\n\t\tSoapError(h, 733, \"InconsistentParameter\");\n\t\tClearNameValueList(&data);\n\t\treturn;\n\t}\n/*\nbuild the PortMappingList xml document :\n\n<p:PortMappingList xmlns:p=\"urn:schemas-upnp-org:gw:WANIPConnection\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxsi:schemaLocation=\"urn:schemas-upnp-org:gw:WANIPConnection\nhttp://www.upnp.org/schemas/gw/WANIPConnection-v2.xsd\">\n<p:PortMappingEntry>\n<p:NewRemoteHost>202.233.2.1</p:NewRemoteHost>\n<p:NewExternalPort>2345</p:NewExternalPort>\n<p:NewProtocol>TCP</p:NewProtocol>\n<p:NewInternalPort>2345</p:NewInternalPort>\n<p:NewInternalClient>192.168.1.137</p:NewInternalClient>\n<p:NewEnabled>1</p:NewEnabled>\n<p:NewDescription>dooom</p:NewDescription>\n<p:NewLeaseTime>345</p:NewLeaseTime>\n</p:PortMappingEntry>\n</p:PortMappingList>\n*/\n\tbodyalloc = 4096;\n\tbody = malloc(bodyalloc);\n\tif(!body)\n\t{\n\t\tClearNameValueList(&data);\n\t\tSoapError(h, 501, \"ActionFailed\");\n\t\treturn;\n\t}\n\tbodylen = snprintf(body, bodyalloc, resp_start,\n\t              action, ns/*SERVICE_TYPE_WANIPC*/);\n\tif(bodylen < 0)\n\t{\n\t\tSoapError(h, 501, \"ActionFailed\");\n\t\tfree(body);\n\t\treturn;\n\t}\n\tmemcpy(body+bodylen, list_start, sizeof(list_start));\n\tbodylen += (sizeof(list_start) - 1);\n\n\tport_list = upnp_get_portmappings_in_range(startport, endport,\n\t                                           protocol, &list_size);\n\t/* loop through port mappings */\n\tfor(i = 0; number > 0 && i < list_size; i++)\n\t{\n\t\t/* have a margin of 1024 bytes to store the new entry */\n\t\tif((unsigned int)bodylen + 1024 > bodyalloc)\n\t\t{\n\t\t\tchar * body_sav = body;\n\t\t\tbodyalloc += 4096;\n\t\t\tbody = realloc(body, bodyalloc);\n\t\t\tif(!body)\n\t\t\t{\n\t\t\t\tsyslog(LOG_CRIT, \"realloc(%p, %u) FAILED\", body_sav, (unsigned)bodyalloc);\n\t\t\t\tClearNameValueList(&data);\n\t\t\t\tSoapError(h, 501, \"ActionFailed\");\n\t\t\t\tfree(body_sav);\n\t\t\t\tfree(port_list);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\trhost[0] = '\\0';\n\t\tr = upnp_get_redirection_infos(port_list[i], protocol, &iport,\n\t\t                               int_ip, sizeof(int_ip),\n\t\t                               desc, sizeof(desc),\n\t\t                               rhost, sizeof(rhost),\n\t\t                               &leaseduration);\n\t\tif(r == 0)\n\t\t{\n\t\t\tbodylen += snprintf(body+bodylen, bodyalloc-bodylen, entry,\n\t\t\t                    rhost, port_list[i], protocol,\n\t\t\t                    iport, int_ip, desc, leaseduration);\n\t\t\tnumber--;\n\t\t}\n\t}\n\tfree(port_list);\n\tport_list = NULL;\n\n\tif((bodylen + sizeof(list_end) + 1024) > bodyalloc)\n\t{\n\t\tchar * body_sav = body;\n\t\tbodyalloc += (sizeof(list_end) + 1024);\n\t\tbody = realloc(body, bodyalloc);\n\t\tif(!body)\n\t\t{\n\t\t\tsyslog(LOG_CRIT, \"realloc(%p, %u) FAILED\", body_sav, (unsigned)bodyalloc);\n\t\t\tClearNameValueList(&data);\n\t\t\tSoapError(h, 501, \"ActionFailed\");\n\t\t\tfree(body_sav);\n\t\t\treturn;\n\t\t}\n\t}\n\tmemcpy(body+bodylen, list_end, sizeof(list_end));\n\tbodylen += (sizeof(list_end) - 1);\n\tbodylen += snprintf(body+bodylen, bodyalloc-bodylen, resp_end,\n\t                    action);\n\tBuildSendAndCloseSoapResp(h, body, bodylen);\n\tfree(body);\n\n\tClearNameValueList(&data);\n}\n\n#ifdef ENABLE_L3F_SERVICE\nstatic void\nSetDefaultConnectionService(struct upnphttp * h, const char * action, const char * ns)\n{\n\t/*static const char resp[] =\n\t\t\"<u:SetDefaultConnectionServiceResponse \"\n\t\t\"xmlns:u=\\\"urn:schemas-upnp-org:service:Layer3Forwarding:1\\\">\"\n\t\t\"</u:SetDefaultConnectionServiceResponse>\";*/\n\tstatic const char resp[] =\n\t\t\"<u:%sResponse \"\n\t\t\"xmlns:u=\\\"%s\\\">\"\n\t\t\"</u:%sResponse>\";\n\tchar body[512];\n\tint bodylen;\n\tstruct NameValueParserData data;\n\tchar * p;\n\tParseNameValue(h->req_buf + h->req_contentoff, h->req_contentlen, &data);\n\tp = GetValueFromNameValueList(&data, \"NewDefaultConnectionService\");\n\tif(p) {\n\t\t/* 720 InvalidDeviceUUID\n\t\t * 721 InvalidServiceID\n\t\t * 723 InvalidConnServiceSelection */\n#ifdef UPNP_STRICT\n\t\tchar * service;\n\t\tservice = strchr(p, ',');\n\t\tif(0 != memcmp(uuidvalue_wcd, p, sizeof(\"uuid:00000000-0000-0000-0000-000000000000\") - 1)) {\n\t\t\tSoapError(h, 720, \"InvalidDeviceUUID\");\n\t\t} else if(service == NULL || 0 != strcmp(service+1, SERVICE_ID_WANIPC)) {\n\t\t\tSoapError(h, 721, \"InvalidServiceID\");\n\t\t} else\n#endif\n\t\t{\n\t\t\tsyslog(LOG_INFO, \"%s(%s) : Ignored\", action, p);\n\t\t\tbodylen = snprintf(body, sizeof(body), resp,\n\t\t\t                   action, ns, action);\n\t\t\tBuildSendAndCloseSoapResp(h, body, bodylen);\n\t\t}\n\t} else {\n\t\t/* missing argument */\n\t\tSoapError(h, 402, \"Invalid Args\");\n\t}\n\tClearNameValueList(&data);\n}\n\nstatic void\nGetDefaultConnectionService(struct upnphttp * h, const char * action, const char * ns)\n{\n\tstatic const char resp[] =\n\t\t\"<u:%sResponse \"\n\t\t\"xmlns:u=\\\"%s\\\">\"\n#ifdef IGD_V2\n\t\t\"<NewDefaultConnectionService>%s:WANConnectionDevice:2,\"\n#else\n\t\t\"<NewDefaultConnectionService>%s:WANConnectionDevice:1,\"\n#endif\n\t\tSERVICE_ID_WANIPC \"</NewDefaultConnectionService>\"\n\t\t\"</u:%sResponse>\";\n\t/* example from UPnP_IGD_Layer3Forwarding 1.0.pdf :\n\t * uuid:44f5824f-c57d-418c-a131-f22b34e14111:WANConnectionDevice:1,\n\t * urn:upnp-org:serviceId:WANPPPConn1 */\n\tchar body[1024];\n\tint bodylen;\n\n\t/* namespace : urn:schemas-upnp-org:service:Layer3Forwarding:1 */\n\tbodylen = snprintf(body, sizeof(body), resp,\n\t                   action, ns, uuidvalue_wcd, action);\n\tBuildSendAndCloseSoapResp(h, body, bodylen);\n}\n#endif\n\n/* Added for compliance with WANIPConnection v2 */\nstatic void\nSetConnectionType(struct upnphttp * h, const char * action, const char * ns)\n{\n#ifdef UPNP_STRICT\n\tconst char * connection_type;\n#endif /* UPNP_STRICT */\n\tstruct NameValueParserData data;\n\tUNUSED(action);\n\tUNUSED(ns);\n\n\tParseNameValue(h->req_buf + h->req_contentoff, h->req_contentlen, &data);\n#ifdef UPNP_STRICT\n\tconnection_type = GetValueFromNameValueList(&data, \"NewConnectionType\");\n\tif(!connection_type) {\n\t\tClearNameValueList(&data);\n\t\tSoapError(h, 402, \"Invalid Args\");\n\t\treturn;\n\t}\n#endif /* UPNP_STRICT */\n\t/* Unconfigured, IP_Routed, IP_Bridged */\n\tClearNameValueList(&data);\n\t/* always return a ReadOnly error */\n\tSoapError(h, 731, \"ReadOnly\");\n}\n\n/* Added for compliance with WANIPConnection v2 */\nstatic void\nRequestConnection(struct upnphttp * h, const char * action, const char * ns)\n{\n\tUNUSED(action);\n\tUNUSED(ns);\n\tSoapError(h, 606, \"Action not authorized\");\n}\n\n/* Added for compliance with WANIPConnection v2 */\nstatic void\nForceTermination(struct upnphttp * h, const char * action, const char * ns)\n{\n\tUNUSED(action);\n\tUNUSED(ns);\n\tSoapError(h, 606, \"Action not authorized\");\n}\n\n/*\nIf a control point calls QueryStateVariable on a state variable that is not\nbuffered in memory within (or otherwise available from) the service,\nthe service must return a SOAP fault with an errorCode of 404 Invalid Var.\n\nQueryStateVariable remains useful as a limited test tool but may not be\npart of some future versions of UPnP.\n*/\nstatic void\nQueryStateVariable(struct upnphttp * h, const char * action, const char * ns)\n{\n\tstatic const char resp[] =\n        \"<u:%sResponse \"\n        \"xmlns:u=\\\"%s\\\">\"\n\t\t\"<return>%s</return>\"\n        \"</u:%sResponse>\";\n\n\tchar body[512];\n\tint bodylen;\n\tstruct NameValueParserData data;\n\tconst char * var_name;\n\n\tParseNameValue(h->req_buf + h->req_contentoff, h->req_contentlen, &data);\n\t/*var_name = GetValueFromNameValueList(&data, \"QueryStateVariable\"); */\n\t/*var_name = GetValueFromNameValueListIgnoreNS(&data, \"varName\");*/\n\tvar_name = GetValueFromNameValueList(&data, \"varName\");\n\n\t/*syslog(LOG_INFO, \"QueryStateVariable(%.40s)\", var_name); */\n\n\tif(!var_name)\n\t{\n\t\tSoapError(h, 402, \"Invalid Args\");\n\t}\n\telse if(strcmp(var_name, \"ConnectionStatus\") == 0)\n\t{\n\t\tconst char * status;\n\n\t\tstatus = get_wan_connection_status_str(ext_if_name);\n\t\tbodylen = snprintf(body, sizeof(body), resp,\n                           action, ns,/*\"urn:schemas-upnp-org:control-1-0\",*/\n\t\t                   status, action);\n\t\tBuildSendAndCloseSoapResp(h, body, bodylen);\n\t}\n#if 0\n\t/* not useful */\n\telse if(strcmp(var_name, \"ConnectionType\") == 0)\n\t{\n\t\tbodylen = snprintf(body, sizeof(body), resp, \"IP_Routed\");\n\t\tBuildSendAndCloseSoapResp(h, body, bodylen);\n\t}\n\telse if(strcmp(var_name, \"LastConnectionError\") == 0)\n\t{\n\t\tbodylen = snprintf(body, sizeof(body), resp, \"ERROR_NONE\");\n\t\tBuildSendAndCloseSoapResp(h, body, bodylen);\n\t}\n#endif\n\telse if(strcmp(var_name, \"PortMappingNumberOfEntries\") == 0)\n\t{\n\t\tchar strn[10];\n\t\tsnprintf(strn, sizeof(strn), \"%i\",\n\t\t         upnp_get_portmapping_number_of_entries());\n\t\tbodylen = snprintf(body, sizeof(body), resp,\n                           action, ns,/*\"urn:schemas-upnp-org:control-1-0\",*/\n\t\t                   strn, action);\n\t\tBuildSendAndCloseSoapResp(h, body, bodylen);\n\t}\n\telse\n\t{\n\t\tsyslog(LOG_NOTICE, \"%s: Unknown: %s\", action, var_name?var_name:\"\");\n\t\tSoapError(h, 404, \"Invalid Var\");\n\t}\n\n\tClearNameValueList(&data);\n}\n\n#ifdef ENABLE_6FC_SERVICE\n#ifndef ENABLE_IPV6\n#error \"ENABLE_6FC_SERVICE needs ENABLE_IPV6\"\n#endif\n/* WANIPv6FirewallControl actions */\nstatic void\nGetFirewallStatus(struct upnphttp * h, const char * action, const char * ns)\n{\n\tstatic const char resp[] =\n\t\t\"<u:%sResponse \"\n\t\t\"xmlns:u=\\\"%s\\\">\"\n\t\t\"<FirewallEnabled>%d</FirewallEnabled>\"\n\t\t\"<InboundPinholeAllowed>%d</InboundPinholeAllowed>\"\n\t\t\"</u:%sResponse>\";\n\n\tchar body[512];\n\tint bodylen;\n\n\tbodylen = snprintf(body, sizeof(body), resp,\n\t\taction, ns, /*\"urn:schemas-upnp-org:service:WANIPv6FirewallControl:1\",*/\n\t    GETFLAG(IPV6FCFWDISABLEDMASK) ? 0 : 1,\n\t    GETFLAG(IPV6FCINBOUNDDISALLOWEDMASK) ? 0 : 1,\n\t    action);\n\tBuildSendAndCloseSoapResp(h, body, bodylen);\n}\n\nstatic int\nCheckStatus(struct upnphttp * h)\n{\n\tif (GETFLAG(IPV6FCFWDISABLEDMASK))\n\t{\n\t\tSoapError(h, 702, \"FirewallDisabled\");\n\t\treturn 0;\n\t}\n\telse if(GETFLAG(IPV6FCINBOUNDDISALLOWEDMASK))\n\t{\n\t\tSoapError(h, 703, \"InboundPinholeNotAllowed\");\n\t\treturn 0;\n\t}\n\telse\n\t\treturn 1;\n}\n\n#if 0\nstatic int connecthostport(const char * host, unsigned short port, char * result)\n{\n\tint s, n;\n\tchar hostname[INET6_ADDRSTRLEN];\n\tchar port_str[8], ifname[8], tmp[4];\n\tstruct addrinfo *ai, *p;\n\tstruct addrinfo hints;\n\n\tmemset(&hints, 0, sizeof(hints));\n\t/* hints.ai_flags = AI_ADDRCONFIG; */\n#ifdef AI_NUMERICSERV\n\thints.ai_flags = AI_NUMERICSERV;\n#endif\n\thints.ai_socktype = SOCK_STREAM;\n\thints.ai_family = AF_UNSPEC; /* AF_INET, AF_INET6 or AF_UNSPEC */\n\t/* hints.ai_protocol = IPPROTO_TCP; */\n\tsnprintf(port_str, sizeof(port_str), \"%hu\", port);\n\tstrcpy(hostname, host);\n\tif(!strncmp(host, \"fe80\", 4))\n\t{\n\t\tprintf(\"Using an linklocal address\\n\");\n\t\tstrcpy(ifname, \"%\");\n\t\tsnprintf(tmp, sizeof(tmp), \"%d\", linklocal_index);\n\t\tstrcat(ifname, tmp);\n\t\tstrcat(hostname, ifname);\n\t\tprintf(\"host: %s\\n\", hostname);\n\t}\n\tn = getaddrinfo(hostname, port_str, &hints, &ai);\n\tif(n != 0)\n\t{\n\t\tfprintf(stderr, \"getaddrinfo() error : %s\\n\", gai_strerror(n));\n\t\treturn -1;\n\t}\n\ts = -1;\n\tfor(p = ai; p; p = p->ai_next)\n\t{\n#ifdef DEBUG\n\t\tchar tmp_host[256];\n\t\tchar tmp_service[256];\n\t\tprintf(\"ai_family=%d ai_socktype=%d ai_protocol=%d ai_addrlen=%d\\n \",\n\t\t       p->ai_family, p->ai_socktype, p->ai_protocol, p->ai_addrlen);\n\t\tgetnameinfo(p->ai_addr, p->ai_addrlen, tmp_host, sizeof(tmp_host),\n\t\t            tmp_service, sizeof(tmp_service),\n\t\t            NI_NUMERICHOST | NI_NUMERICSERV);\n\t\tprintf(\" host=%s service=%s\\n\", tmp_host, tmp_service);\n#endif\n\t\tinet_ntop(AF_INET6, &(((struct sockaddr_in6 *)p->ai_addr)->sin6_addr), result, INET6_ADDRSTRLEN);\n\t\treturn 0;\n\t}\n\tfreeaddrinfo(ai);\n}\n#endif\n\n/* Check the security policy right */\nstatic int\nPinholeVerification(struct upnphttp * h, char * int_ip, unsigned short int_port)\n{\n\tint n;\n\tchar senderAddr[INET6_ADDRSTRLEN]=\"\";\n\tstruct addrinfo hints, *ai, *p;\n\tstruct in6_addr result_ip;\n\n\t/* Pinhole InternalClient address must correspond to the action sender */\n\tsyslog(LOG_INFO, \"Checking internal IP@ and port (Security policy purpose)\");\n\n\thints.ai_socktype = SOCK_STREAM;\n\thints.ai_family = AF_UNSPEC;\n\n\t/* if ip not valid assume hostname and convert */\n\tif (inet_pton(AF_INET6, int_ip, &result_ip) <= 0)\n\t{\n\t\tn = getaddrinfo(int_ip, NULL, &hints, &ai);\n\t\tif(!n && ai->ai_family == AF_INET6)\n\t\t{\n\t\t\tfor(p = ai; p; p = p->ai_next)\n\t\t\t{\n\t\t\t\tinet_ntop(AF_INET6, (struct in6_addr *) p, int_ip, sizeof(struct in6_addr));\n\t\t\t\tresult_ip = *((struct in6_addr *) p);\n\t\t\t\t/* TODO : deal with more than one ip per hostname */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsyslog(LOG_ERR, \"Failed to convert hostname '%s' to ip address\", int_ip);\n\t\t\tSoapError(h, 402, \"Invalid Args\");\n\t\t\treturn -1;\n\t\t}\n        freeaddrinfo(p);\n\t}\n\n\tif(inet_ntop(AF_INET6, &(h->clientaddr_v6), senderAddr, INET6_ADDRSTRLEN) == NULL)\n\t{\n\t\tsyslog(LOG_ERR, \"inet_ntop: %m\");\n\t}\n#ifdef DEBUG\n\tprintf(\"\\tPinholeVerification:\\n\\t\\tCompare sender @: %s\\n\\t\\t  to intClient @: %s\\n\", senderAddr, int_ip);\n#endif\n\tif(strcmp(senderAddr, int_ip) != 0)\n\tif(h->clientaddr_v6.s6_addr != result_ip.s6_addr)\n\t{\n\t\tsyslog(LOG_INFO, \"Client %s tried to access pinhole for internal %s and is not authorized to do it\",\n\t\t       senderAddr, int_ip);\n\t\tSoapError(h, 606, \"Action not authorized\");\n\t\treturn 0;\n\t}\n\n\t/* Pinhole InternalPort must be greater than or equal to 1024 */\n\tif (int_port < 1024)\n\t{\n\t\tsyslog(LOG_INFO, \"Client %s tried to access pinhole with port < 1024 and is not authorized to do it\",\n\t\t       senderAddr);\n\t\tSoapError(h, 606, \"Action not authorized\");\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\nstatic void\nAddPinhole(struct upnphttp * h, const char * action, const char * ns)\n{\n\tint r;\n\tstatic const char resp[] =\n\t\t\"<u:%sResponse \"\n\t\t\"xmlns:u=\\\"%s\\\">\"\n\t\t\"<UniqueID>%d</UniqueID>\"\n\t\t\"</u:%sResponse>\";\n\tchar body[512];\n\tint bodylen;\n\tstruct NameValueParserData data;\n\tchar * rem_host, * rem_port, * int_ip, * int_port, * protocol, * leaseTime;\n\tint uid = 0;\n\tunsigned short iport, rport;\n\tint ltime;\n\tlong proto;\n\tchar rem_ip[INET6_ADDRSTRLEN];\n\n\tif(CheckStatus(h)==0)\n\t\treturn;\n\n\tParseNameValue(h->req_buf + h->req_contentoff, h->req_contentlen, &data);\n\trem_host = GetValueFromNameValueList(&data, \"RemoteHost\");\n\trem_port = GetValueFromNameValueList(&data, \"RemotePort\");\n\tint_ip = GetValueFromNameValueList(&data, \"InternalClient\");\n\tint_port = GetValueFromNameValueList(&data, \"InternalPort\");\n\tprotocol = GetValueFromNameValueList(&data, \"Protocol\");\n\tleaseTime = GetValueFromNameValueList(&data, \"LeaseTime\");\n\n\trport = (unsigned short)(rem_port ? atoi(rem_port) : 0);\n\tiport = (unsigned short)(int_port ? atoi(int_port) : 0);\n\tltime = leaseTime ? atoi(leaseTime) : -1;\n\terrno = 0;\n\tproto = protocol ? strtol(protocol, NULL, 0) : -1;\n\tif(errno != 0 || proto > 65535 || proto < 0)\n\t{\n\t\tSoapError(h, 402, \"Invalid Args\");\n\t\tgoto clear_and_exit;\n\t}\n\tif(iport == 0)\n\t{\n\t\tSoapError(h, 706, \"InternalPortWilcardingNotAllowed\");\n\t\tgoto clear_and_exit;\n\t}\n\n\t/* In particular, [IGD2] RECOMMENDS that unauthenticated and\n\t * unauthorized control points are only allowed to invoke\n\t * this action with:\n\t * - InternalPort value greater than or equal to 1024,\n\t * - InternalClient value equals to the control point's IP address.\n\t * It is REQUIRED that InternalClient cannot be one of IPv6\n\t * addresses used by the gateway. */\n\tif(!int_ip || int_ip[0] == '\\0' || 0 == strcmp(int_ip, \"*\"))\n\t{\n\t\tSoapError(h, 708, \"WildCardNotPermittedInSrcIP\");\n\t\tgoto clear_and_exit;\n\t}\n\t/* I guess it is useless to convert int_ip to literal ipv6 address */\n\tif(rem_host)\n\t{\n\t\t/* trim */\n\t\twhile(isspace(rem_host[0]))\n\t\t\trem_host++;\n\t}\n\t/* rem_host should be converted to literal ipv6 : */\n\tif(rem_host && (rem_host[0] != '\\0') && (rem_host[0] != '*'))\n\t{\n\t\tstruct addrinfo *ai, *p;\n\t\tstruct addrinfo hints;\n\t\tint err;\n\t\tmemset(&hints, 0, sizeof(struct addrinfo));\n\t\thints.ai_family = AF_INET6;\n\t\t/*hints.ai_flags = */\n\t\t/* hints.ai_protocol = proto; */\n\t\terr = getaddrinfo(rem_host, rem_port, &hints, &ai);\n\t\tif(err == 0)\n\t\t{\n\t\t\t/* take the 1st IPv6 address */\n\t\t\tfor(p = ai; p; p = p->ai_next)\n\t\t\t{\n\t\t\t\tif(p->ai_family == AF_INET6)\n\t\t\t\t{\n\t\t\t\t\tinet_ntop(AF_INET6,\n\t\t\t\t\t          &(((struct sockaddr_in6 *)p->ai_addr)->sin6_addr),\n\t\t\t\t\t          rem_ip, sizeof(rem_ip));\n\t\t\t\t\tsyslog(LOG_INFO, \"resolved '%s' to '%s'\", rem_host, rem_ip);\n\t\t\t\t\trem_host = rem_ip;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfreeaddrinfo(ai);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsyslog(LOG_WARNING, \"AddPinhole : getaddrinfo(%s) : %s\",\n\t\t\t       rem_host, gai_strerror(err));\n#if 0\n\t\t\tSoapError(h, 402, \"Invalid Args\");\n\t\t\tgoto clear_and_exit;\n#endif\n\t\t}\n\t}\n\n\tif(proto == 65535)\n\t{\n\t\tSoapError(h, 707, \"ProtocolWilcardingNotAllowed\");\n\t\tgoto clear_and_exit;\n\t}\n\tif(proto != IPPROTO_UDP && proto != IPPROTO_TCP\n#ifdef IPPROTO_UDPITE\n\t   && atoi(protocol) != IPPROTO_UDPLITE\n#endif\n\t  )\n\t{\n\t\tSoapError(h, 705, \"ProtocolNotSupported\");\n\t\tgoto clear_and_exit;\n\t}\n\tif(ltime < 1 || ltime > 86400)\n\t{\n\t\tsyslog(LOG_WARNING, \"%s: LeaseTime=%d not supported, (ip=%s)\",\n\t\t       action, ltime, int_ip);\n\t\tSoapError(h, 402, \"Invalid Args\");\n\t\tgoto clear_and_exit;\n\t}\n\n\tif(PinholeVerification(h, int_ip, iport) <= 0)\n\t\tgoto clear_and_exit;\n\n\tsyslog(LOG_INFO, \"%s: (inbound) from [%s]:%hu to [%s]:%hu with proto %ld during %d sec\",\n\t       action, rem_host?rem_host:\"any\",\n\t       rport, int_ip, iport,\n\t       proto, ltime);\n\n\t/* In cases where the RemoteHost, RemotePort, InternalPort,\n\t * InternalClient and Protocol are the same than an existing pinhole,\n\t * but LeaseTime is different, the device MUST extend the existing\n\t * pinhole's lease time and return the UniqueID of the existing pinhole. */\n\tr = upnp_add_inboundpinhole(rem_host, rport, int_ip, iport, proto, \"IGD2 pinhole\", ltime, &uid);\n\n\tswitch(r)\n\t{\n\t\tcase 1:\t        /* success */\n\t\t\tbodylen = snprintf(body, sizeof(body),\n\t\t\t                   resp, action,\n\t\t\t                   ns/*\"urn:schemas-upnp-org:service:WANIPv6FirewallControl:1\"*/,\n\t\t\t                   uid, action);\n\t\t\tBuildSendAndCloseSoapResp(h, body, bodylen);\n\t\t\tbreak;\n\t\tcase -1: \t/* not permitted */\n\t\t\tSoapError(h, 701, \"PinholeSpaceExhausted\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tSoapError(h, 501, \"ActionFailed\");\n\t\t\tbreak;\n\t}\n\t/* 606 Action not authorized\n\t * 701 PinholeSpaceExhausted\n\t * 702 FirewallDisabled\n\t * 703 InboundPinholeNotAllowed\n\t * 705 ProtocolNotSupported\n\t * 706 InternalPortWildcardingNotAllowed\n\t * 707 ProtocolWildcardingNotAllowed\n\t * 708 WildCardNotPermittedInSrcIP */\nclear_and_exit:\n\tClearNameValueList(&data);\n}\n\nstatic void\nUpdatePinhole(struct upnphttp * h, const char * action, const char * ns)\n{\n#if 0\n\tstatic const char resp[] =\n\t\t\"<u:UpdatePinholeResponse \"\n\t\t\"xmlns:u=\\\"urn:schemas-upnp-org:service:WANIPv6FirewallControl:1\\\">\"\n\t\t\"</u:UpdatePinholeResponse>\";\n#endif\n\tstatic const char resp[] =\n\t\t\"<u:%sResponse \"\n\t\t\"xmlns:u=\\\"%s\\\">\"\n\t\t\"</u:%sResponse>\";\n\tchar body[512];\n\tint bodylen;\n\tstruct NameValueParserData data;\n\tconst char * uid_str, * leaseTime;\n\tchar iaddr[INET6_ADDRSTRLEN];\n\tunsigned short iport;\n\tint ltime;\n\tint uid;\n\tint n;\n\n\tif(CheckStatus(h)==0)\n\t\treturn;\n\n\tParseNameValue(h->req_buf + h->req_contentoff, h->req_contentlen, &data);\n\tuid_str = GetValueFromNameValueList(&data, \"UniqueID\");\n\tleaseTime = GetValueFromNameValueList(&data, \"NewLeaseTime\");\n\tuid = uid_str ? atoi(uid_str) : -1;\n\tltime = leaseTime ? atoi(leaseTime) : -1;\n\tClearNameValueList(&data);\n\n\tif(uid < 0 || uid > 65535 || ltime <= 0 || ltime > 86400)\n\t{\n\t\tSoapError(h, 402, \"Invalid Args\");\n\t\treturn;\n\t}\n\n\t/* Check that client is not updating an pinhole\n\t * it doesn't have access to, because of its public access */\n\tn = upnp_get_pinhole_info(uid, NULL, 0, NULL,\n\t                          iaddr, sizeof(iaddr), &iport,\n\t                          NULL, /* proto */\n\t                          NULL, 0, /* desc, desclen */\n\t                          NULL, NULL);\n\tif (n >= 0)\n\t{\n\t\tif(PinholeVerification(h, iaddr, iport) <= 0)\n\t\t\treturn;\n\t}\n\telse if(n == -2)\n\t{\n\t\tSoapError(h, 704, \"NoSuchEntry\");\n\t\treturn;\n\t}\n\telse\n\t{\n\t\tSoapError(h, 501, \"ActionFailed\");\n\t\treturn;\n\t}\n\n\tsyslog(LOG_INFO, \"%s: (inbound) updating lease duration to %d for pinhole with ID: %d\",\n\t       action, ltime, uid);\n\n\tn = upnp_update_inboundpinhole(uid, ltime);\n\tif(n == -1)\n\t\tSoapError(h, 704, \"NoSuchEntry\");\n\telse if(n < 0)\n\t\tSoapError(h, 501, \"ActionFailed\");\n\telse {\n\t\tbodylen = snprintf(body, sizeof(body), resp,\n\t\t                   action, ns, action);\n\t\tBuildSendAndCloseSoapResp(h, body, bodylen);\n\t}\n}\n\nstatic void\nGetOutboundPinholeTimeout(struct upnphttp * h, const char * action, const char * ns)\n{\n\tint r;\n\n\tstatic const char resp[] =\n\t\t\"<u:%sResponse \"\n\t\t\"xmlns:u=\\\"%s\\\">\"\n\t\t\"<OutboundPinholeTimeout>%d</OutboundPinholeTimeout>\"\n\t\t\"</u:%sResponse>\";\n\n\tchar body[512];\n\tint bodylen;\n\tstruct NameValueParserData data;\n\tchar * int_ip, * int_port, * rem_host, * rem_port, * protocol;\n\tint opt=0;\n\t/*int proto=0;*/\n\tunsigned short iport, rport;\n\n\tif (GETFLAG(IPV6FCFWDISABLEDMASK))\n\t{\n\t\tSoapError(h, 702, \"FirewallDisabled\");\n\t\treturn;\n\t}\n\n\tParseNameValue(h->req_buf + h->req_contentoff, h->req_contentlen, &data);\n\tint_ip = GetValueFromNameValueList(&data, \"InternalClient\");\n\tint_port = GetValueFromNameValueList(&data, \"InternalPort\");\n\trem_host = GetValueFromNameValueList(&data, \"RemoteHost\");\n\trem_port = GetValueFromNameValueList(&data, \"RemotePort\");\n\tprotocol = GetValueFromNameValueList(&data, \"Protocol\");\n\n\tif (!int_port || !ext_port || !protocol)\n\t{\n\t\tClearNameValueList(&data);\n\t\tSoapError(h, 402, \"Invalid Args\");\n\t\treturn;\n\t}\n\n\trport = (unsigned short)atoi(rem_port);\n\tiport = (unsigned short)atoi(int_port);\n\t/*proto = atoi(protocol);*/\n\n\tsyslog(LOG_INFO, \"%s: retrieving timeout for outbound pinhole from [%s]:%hu to [%s]:%hu protocol %s\", action, int_ip, iport,rem_host, rport, protocol);\n\n\t/* TODO */\n\tr = -1;/*upnp_check_outbound_pinhole(proto, &opt);*/\n\n\tswitch(r)\n\t{\n\t\tcase 1:\t/* success */\n\t\t\tbodylen = snprintf(body, sizeof(body), resp,\n\t\t\t                   action, ns/*\"urn:schemas-upnp-org:service:WANIPv6FirewallControl:1\"*/,\n\t\t\t                   opt, action);\n\t\t\tBuildSendAndCloseSoapResp(h, body, bodylen);\n\t\t\tbreak;\n\t\tcase -5:\t/* Protocol not supported */\n\t\t\tSoapError(h, 705, \"ProtocolNotSupported\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tSoapError(h, 501, \"ActionFailed\");\n\t}\n\tClearNameValueList(&data);\n}\n\nstatic void\nDeletePinhole(struct upnphttp * h, const char * action, const char * ns)\n{\n\tint n;\n#if 0\n\tstatic const char resp[] =\n\t\t\"<u:DeletePinholeResponse \"\n\t\t\"xmlns:u=\\\"urn:schemas-upnp-org:service:WANIPv6FirewallControl:1\\\">\"\n\t\t\"</u:DeletePinholeResponse>\";\n#endif\n\tstatic const char resp[] =\n\t\t\"<u:%sResponse \"\n\t\t\"xmlns:u=\\\"%s\\\">\"\n\t\t\"</u:%sResponse>\";\n\tchar body[512];\n\tint bodylen;\n\n\tstruct NameValueParserData data;\n\tconst char * uid_str;\n\tchar iaddr[INET6_ADDRSTRLEN];\n\tint proto;\n\tunsigned short iport;\n\tunsigned int leasetime;\n\tint uid;\n\n\tif(CheckStatus(h)==0)\n\t\treturn;\n\n\tParseNameValue(h->req_buf + h->req_contentoff, h->req_contentlen, &data);\n\tuid_str = GetValueFromNameValueList(&data, \"UniqueID\");\n\tuid = uid_str ? atoi(uid_str) : -1;\n\tClearNameValueList(&data);\n\n\tif(uid < 0 || uid > 65535)\n\t{\n\t\tSoapError(h, 402, \"Invalid Args\");\n\t\treturn;\n\t}\n\n\t/* Check that client is not deleting an pinhole\n\t * it doesn't have access to, because of its public access */\n\tn = upnp_get_pinhole_info(uid, NULL, 0, NULL,\n\t                          iaddr, sizeof(iaddr), &iport,\n\t                          &proto,\n\t                          NULL, 0, /* desc, desclen */\n\t                          &leasetime, NULL);\n\tif (n >= 0)\n\t{\n\t\tif(PinholeVerification(h, iaddr, iport) <= 0)\n\t\t\treturn;\n\t}\n\telse if(n == -2)\n\t{\n\t\tSoapError(h, 704, \"NoSuchEntry\");\n\t\treturn;\n\t}\n\telse\n\t{\n\t\tSoapError(h, 501, \"ActionFailed\");\n\t\treturn;\n\t}\n\n\tn = upnp_delete_inboundpinhole(uid);\n\tif(n < 0)\n\t{\n\t\tsyslog(LOG_INFO, \"%s: (inbound) failed to remove pinhole with ID: %d\",\n\t           action, uid);\n\t\tSoapError(h, 501, \"ActionFailed\");\n\t\treturn;\n\t}\n\tsyslog(LOG_INFO, \"%s: (inbound) pinhole with ID %d successfully removed\",\n\t       action, uid);\n\tbodylen = snprintf(body, sizeof(body), resp,\n\t                   action, ns, action);\n\tBuildSendAndCloseSoapResp(h, body, bodylen);\n}\n\nstatic void\nCheckPinholeWorking(struct upnphttp * h, const char * action, const char * ns)\n{\n\tstatic const char resp[] =\n\t\t\"<u:%sResponse \"\n\t\t\"xmlns:u=\\\"%s\\\">\"\n\t\t\"<IsWorking>%d</IsWorking>\"\n\t\t\"</u:%sResponse>\";\n\tchar body[512];\n\tint bodylen;\n\tint r;\n\tstruct NameValueParserData data;\n\tconst char * uid_str;\n\tint uid;\n\tchar iaddr[INET6_ADDRSTRLEN];\n\tunsigned short iport;\n\tunsigned int packets;\n\n\tif(CheckStatus(h)==0)\n\t\treturn;\n\n\tParseNameValue(h->req_buf + h->req_contentoff, h->req_contentlen, &data);\n\tuid_str = GetValueFromNameValueList(&data, \"UniqueID\");\n\tuid = uid_str ? atoi(uid_str) : -1;\n\tClearNameValueList(&data);\n\n\tif(uid < 0 || uid > 65535)\n\t{\n\t\tSoapError(h, 402, \"Invalid Args\");\n\t\treturn;\n\t}\n\n\t/* Check that client is not checking a pinhole\n\t * it doesn't have access to, because of its public access */\n\tr = upnp_get_pinhole_info(uid,\n\t                          NULL, 0, NULL,\n\t                          iaddr, sizeof(iaddr), &iport,\n\t                          NULL, /* proto */\n\t                          NULL, 0, /* desc, desclen */\n\t                          NULL, &packets);\n\tif (r >= 0)\n\t{\n\t\tif(PinholeVerification(h, iaddr, iport) <= 0)\n\t\t\treturn ;\n\t\tif(packets == 0)\n\t\t{\n\t\t\tSoapError(h, 709, \"NoPacketSent\");\n\t\t\treturn;\n\t\t}\n\t\tbodylen = snprintf(body, sizeof(body), resp,\n\t\t\t\t\t\taction, ns/*\"urn:schemas-upnp-org:service:WANIPv6FirewallControl:1\"*/,\n\t\t\t\t\t\t1, action);\n\t\tBuildSendAndCloseSoapResp(h, body, bodylen);\n\t}\n\telse if(r == -2)\n\t\tSoapError(h, 704, \"NoSuchEntry\");\n\telse\n\t\tSoapError(h, 501, \"ActionFailed\");\n}\n\nstatic void\nGetPinholePackets(struct upnphttp * h, const char * action, const char * ns)\n{\n\tstatic const char resp[] =\n\t\t\"<u:%sResponse \"\n\t\t\"xmlns:u=\\\"%s\\\">\"\n\t\t\"<PinholePackets>%u</PinholePackets>\"\n\t\t\"</u:%sResponse>\";\n\tchar body[512];\n\tint bodylen;\n\tstruct NameValueParserData data;\n\tconst char * uid_str;\n\tint n;\n\tchar iaddr[INET6_ADDRSTRLEN];\n\tunsigned short iport;\n\tunsigned int packets = 0;\n\tint uid;\n\tint proto;\n\tunsigned int leasetime;\n\n\tif(CheckStatus(h)==0)\n\t\treturn;\n\n\tParseNameValue(h->req_buf + h->req_contentoff, h->req_contentlen, &data);\n\tuid_str = GetValueFromNameValueList(&data, \"UniqueID\");\n\tuid = uid_str ? atoi(uid_str) : -1;\n\tClearNameValueList(&data);\n\n\tif(uid < 0 || uid > 65535)\n\t{\n\t\tSoapError(h, 402, \"Invalid Args\");\n\t\treturn;\n\t}\n\n\t/* Check that client is not getting infos of a pinhole\n\t * it doesn't have access to, because of its public access */\n\tn = upnp_get_pinhole_info(uid, NULL, 0, NULL,\n\t                          iaddr, sizeof(iaddr), &iport,\n\t                          &proto,\n\t                          NULL, 0, /* desc, desclen */\n\t                          &leasetime, &packets);\n\tif (n >= 0)\n\t{\n\t\tif(PinholeVerification(h, iaddr, iport)<=0)\n\t\t\treturn ;\n\t}\n#if 0\n\telse if(r == -4 || r == -1)\n\t{\n\t\tSoapError(h, 704, \"NoSuchEntry\");\n\t}\n#endif\n\n\tbodylen = snprintf(body, sizeof(body), resp,\n\t\t\taction, ns/*\"urn:schemas-upnp-org:service:WANIPv6FirewallControl:1\"*/,\n\t\t\tpackets, action);\n\tBuildSendAndCloseSoapResp(h, body, bodylen);\n}\n#endif\n\n#ifdef ENABLE_DP_SERVICE\nstatic void\nSendSetupMessage(struct upnphttp * h, const char * action, const char * ns)\n{\n\tstatic const char resp[] =\n\t\t\"<u:%sResponse \"\n\t\t\"xmlns:u=\\\"%s\\\">\"\n\t\t\"<OutMessage>%s</OutMessage>\"\n\t\t\"</u:%sResponse>\";\n\tchar body[1024];\n\tint bodylen;\n\tstruct NameValueParserData data;\n\tconst char * ProtocolType;\t/* string */\n\tconst char * InMessage;\t\t/* base64 */\n\tconst char * OutMessage = \"\";\t/* base64 */\n\n\tParseNameValue(h->req_buf + h->req_contentoff, h->req_contentlen, &data);\n\tProtocolType = GetValueFromNameValueList(&data, \"ProtocolType\");\t/* string */\n\tInMessage = GetValueFromNameValueList(&data, \"InMessage\");\t/* base64 */\n\n\tif(ProtocolType == NULL || InMessage == NULL)\n\t{\n\t\tClearNameValueList(&data);\n\t\tSoapError(h, 402, \"Invalid Args\");\n\t\treturn;\n\t}\n\t/*if(strcmp(ProtocolType, \"DeviceProtection:1\") != 0)*/\n\tif(strcmp(ProtocolType, \"WPS\") != 0)\n\t{\n\t\tClearNameValueList(&data);\n\t\tSoapError(h, 600, \"Argument Value Invalid\"); /* 703 ? */\n\t\treturn;\n\t}\n\t/* TODO : put here code for WPS */\n\n\tbodylen = snprintf(body, sizeof(body), resp,\n\t                   action, ns/*\"urn:schemas-upnp-org:service:DeviceProtection:1\"*/,\n\t                   OutMessage, action);\n\tBuildSendAndCloseSoapResp(h, body, bodylen);\n\tClearNameValueList(&data);\n}\n\nstatic void\nGetSupportedProtocols(struct upnphttp * h, const char * action, const char * ns)\n{\n\tstatic const char resp[] =\n\t\t\"<u:%sResponse \"\n\t\t\"xmlns:u=\\\"%s\\\">\"\n\t\t\"<ProtocolList><![CDATA[%s]]></ProtocolList>\"\n\t\t\"</u:%sResponse>\";\n\tchar body[1024];\n\tint bodylen;\n\tconst char * ProtocolList =\n\t\t\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\"\n\t\t\"<SupportedProtocols xmlns=\\\"urn:schemas-upnp-org:gw:DeviceProtection\\\"\"\n\t\t\" xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\"\"\n\t\t\" xsi:schemaLocation=\\\"urn:schemas-upnp-org:gw:DeviceProtection\"\n\t\t\" http://www.upnp.org/schemas/gw/DeviceProtection-v1.xsd\\\">\"\n\t\t\"<Introduction><Name>WPS</Name></Introduction>\"\n\t\t\"<Login><Name>PKCS5</Name></Login>\"\n\t\t\"</SupportedProtocols>\";\n\n\tbodylen = snprintf(body, sizeof(body), resp,\n\t                   action, ns/*\"urn:schemas-upnp-org:service:DeviceProtection:1\"*/,\n\t                   ProtocolList, action);\n\tBuildSendAndCloseSoapResp(h, body, bodylen);\n}\n\nstatic void\nGetAssignedRoles(struct upnphttp * h, const char * action, const char * ns)\n{\n\tstatic const char resp[] =\n\t\t\"<u:%sResponse \"\n\t\t\"xmlns:u=\\\"%s\\\">\"\n\t\t\"<RoleList>%s</RoleList>\"\n\t\t\"</u:%sResponse>\";\n\tchar body[1024];\n\tint bodylen;\n\tconst char * RoleList = \"Public\"; /* list of roles separated by spaces */\n\n#ifdef ENABLE_HTTPS\n\tif(h->ssl != NULL) {\n\t\t/* we should get the Roles of the session (based on client certificate) */\n\t\tX509 * peercert;\n\t\tpeercert = SSL_get_peer_certificate(h->ssl);\n\t\tif(peercert != NULL) {\n\t\t\tRoleList = \"Admin Basic\";\n\t\t\tX509_free(peercert);\n\t\t}\n\t}\n#endif\n\n\tbodylen = snprintf(body, sizeof(body), resp,\n\t                   action, ns/*\"urn:schemas-upnp-org:service:DeviceProtection:1\"*/,\n\t                   RoleList, action);\n\tBuildSendAndCloseSoapResp(h, body, bodylen);\n}\n#endif\n\n/* Windows XP as client send the following requests :\n * GetConnectionTypeInfo\n * GetNATRSIPStatus\n * ? GetTotalBytesSent - WANCommonInterfaceConfig\n * ? GetTotalBytesReceived - idem\n * ? GetTotalPacketsSent - idem\n * ? GetTotalPacketsReceived - idem\n * GetCommonLinkProperties - idem\n * GetStatusInfo - WANIPConnection\n * GetExternalIPAddress\n * QueryStateVariable / ConnectionStatus!\n */\nstatic const struct\n{\n\tconst char * methodName;\n\tvoid (*methodImpl)(struct upnphttp *, const char *, const char *);\n}\nsoapMethods[] =\n{\n\t/* WANCommonInterfaceConfig */\n\t{ \"QueryStateVariable\", QueryStateVariable},\n\t{ \"GetTotalBytesSent\", GetTotalBytesSent},\n\t{ \"GetTotalBytesReceived\", GetTotalBytesReceived},\n\t{ \"GetTotalPacketsSent\", GetTotalPacketsSent},\n\t{ \"GetTotalPacketsReceived\", GetTotalPacketsReceived},\n\t{ \"GetCommonLinkProperties\", GetCommonLinkProperties},\n\t{ \"GetStatusInfo\", GetStatusInfo},\n\t/* WANIPConnection */\n\t{ \"GetConnectionTypeInfo\", GetConnectionTypeInfo },\n\t{ \"GetNATRSIPStatus\", GetNATRSIPStatus},\n\t{ \"GetExternalIPAddress\", GetExternalIPAddress},\n\t{ \"AddPortMapping\", AddPortMapping},\n\t{ \"DeletePortMapping\", DeletePortMapping},\n\t{ \"GetGenericPortMappingEntry\", GetGenericPortMappingEntry},\n\t{ \"GetSpecificPortMappingEntry\", GetSpecificPortMappingEntry},\n/* Required in WANIPConnection:2 */\n\t{ \"SetConnectionType\", SetConnectionType},\n\t{ \"RequestConnection\", RequestConnection},\n\t{ \"ForceTermination\", ForceTermination},\n\t{ \"AddAnyPortMapping\", AddAnyPortMapping},\n\t{ \"DeletePortMappingRange\", DeletePortMappingRange},\n\t{ \"GetListOfPortMappings\", GetListOfPortMappings},\n#ifdef ENABLE_L3F_SERVICE\n\t/* Layer3Forwarding */\n\t{ \"SetDefaultConnectionService\", SetDefaultConnectionService},\n\t{ \"GetDefaultConnectionService\", GetDefaultConnectionService},\n#endif\n#ifdef ENABLE_6FC_SERVICE\n\t/* WANIPv6FirewallControl */\n\t{ \"GetFirewallStatus\", GetFirewallStatus},\t/* Required */\n\t{ \"AddPinhole\", AddPinhole},\t\t\t\t/* Required */\n\t{ \"UpdatePinhole\", UpdatePinhole},\t\t\t/* Required */\n\t{ \"GetOutboundPinholeTimeout\", GetOutboundPinholeTimeout},\t/* Optional */\n\t{ \"DeletePinhole\", DeletePinhole},\t\t\t/* Required */\n\t{ \"CheckPinholeWorking\", CheckPinholeWorking},\t/* Optional */\n\t{ \"GetPinholePackets\", GetPinholePackets},\t/* Required */\n#endif\n#ifdef ENABLE_DP_SERVICE\n\t/* DeviceProtection */\n\t{ \"SendSetupMessage\", SendSetupMessage},\t/* Required */\n\t{ \"GetSupportedProtocols\", GetSupportedProtocols},\t/* Required */\n\t{ \"GetAssignedRoles\", GetAssignedRoles},\t/* Required */\n#endif\n\t{ 0, 0 }\n};\n\nvoid\nExecuteSoapAction(struct upnphttp * h, const char * action, int n)\n{\n\tchar * p;\n\tchar * p2;\n\tint i, len, methodlen;\n\tchar namespace[256];\n\n\t/* SoapAction example :\n\t * urn:schemas-upnp-org:service:WANIPConnection:1#GetStatusInfo */\n\tp = strchr(action, '#');\n\tif(p && (p - action) < n) {\n\t\tfor(i = 0; i < ((int)sizeof(namespace) - 1) && (action + i) < p; i++)\n\t\t\tnamespace[i] = action[i];\n\t\tnamespace[i] = '\\0';\n\t\tp++;\n\t\tp2 = strchr(p, '\"');\n\t\tif(p2 && (p2 - action) <= n)\n\t\t\tmethodlen = p2 - p;\n\t\telse\n\t\t\tmethodlen = n - (p - action);\n\t\t/*syslog(LOG_DEBUG, \"SoapMethod: %.*s %d %d %p %p %d\",\n\t\t       methodlen, p, methodlen, n, action, p, (int)(p - action));*/\n\t\tfor(i = 0; soapMethods[i].methodName; i++) {\n\t\t\tlen = strlen(soapMethods[i].methodName);\n\t\t\tif((len == methodlen) && memcmp(p, soapMethods[i].methodName, len) == 0) {\n#ifdef DEBUG\n\t\t\t\tsyslog(LOG_DEBUG, \"Remote Call of SoapMethod '%s' %s\",\n\t\t\t\t       soapMethods[i].methodName, namespace);\n#endif /* DEBUG */\n\t\t\t\tsoapMethods[i].methodImpl(h, soapMethods[i].methodName, namespace);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tsyslog(LOG_NOTICE, \"SoapMethod: Unknown: %.*s %s\", methodlen, p, namespace);\n\t} else {\n\t\tsyslog(LOG_NOTICE, \"cannot parse SoapAction\");\n\t}\n\n\tSoapError(h, 401, \"Invalid Action\");\n}\n\n/* Standard Errors:\n *\n * errorCode errorDescription Description\n * --------\t---------------- -----------\n * 401 \t\tInvalid Action \tNo action by that name at this service.\n * 402 \t\tInvalid Args \tCould be any of the following: not enough in args,\n * \t\t\t\t\t\t\ttoo many in args, no in arg by that name,\n * \t\t\t\t\t\t\tone or more in args are of the wrong data type.\n * 403 \t\tOut of Sync \tOut of synchronization.\n * 501 \t\tAction Failed \tMay be returned in current state of service\n * \t\t\t\t\t\t\tprevents invoking that action.\n * 600-699 \tTBD \t\t\tCommon action errors. Defined by UPnP Forum\n * \t\t\t\t\t\t\tTechnical Committee.\n * 700-799 \tTBD \t\t\tAction-specific errors for standard actions.\n * \t\t\t\t\t\t\tDefined by UPnP Forum working committee.\n * 800-899 \tTBD \t\t\tAction-specific errors for non-standard actions.\n * \t\t\t\t\t\t\tDefined by UPnP vendor.\n*/\nvoid\nSoapError(struct upnphttp * h, int errCode, const char * errDesc)\n{\n\tstatic const char resp[] =\n\t\t\"<s:Envelope \"\n\t\t\"xmlns:s=\\\"http://schemas.xmlsoap.org/soap/envelope/\\\" \"\n\t\t\"s:encodingStyle=\\\"http://schemas.xmlsoap.org/soap/encoding/\\\">\"\n\t\t\"<s:Body>\"\n\t\t\"<s:Fault>\"\n\t\t\"<faultcode>s:Client</faultcode>\"\n\t\t\"<faultstring>UPnPError</faultstring>\"\n\t\t\"<detail>\"\n\t\t\"<UPnPError xmlns=\\\"urn:schemas-upnp-org:control-1-0\\\">\"\n\t\t\"<errorCode>%d</errorCode>\"\n\t\t\"<errorDescription>%s</errorDescription>\"\n\t\t\"</UPnPError>\"\n\t\t\"</detail>\"\n\t\t\"</s:Fault>\"\n\t\t\"</s:Body>\"\n\t\t\"</s:Envelope>\";\n\n\tchar body[2048];\n\tint bodylen;\n\n\tsyslog(LOG_INFO, \"Returning UPnPError %d: %s\", errCode, errDesc);\n\tbodylen = snprintf(body, sizeof(body), resp, errCode, errDesc);\n\tBuildResp2_upnphttp(h, 500, \"Internal Server Error\", body, bodylen);\n\tSendRespAndClose_upnphttp(h);\n}\n\n"], "filenames": ["miniupnpd/upnpsoap.c"], "buggy_code_start_loc": [1852], "buggy_code_end_loc": [1852], "fixing_code_start_loc": [1853], "fixing_code_end_loc": [1860], "type": "CWE-476", "message": "A Denial Of Service vulnerability in MiniUPnP MiniUPnPd through 2.1 exists due to a NULL pointer dereference in GetOutboundPinholeTimeout in upnpsoap.c for int_port.", "other": {"cve": {"id": "CVE-2019-12108", "sourceIdentifier": "cve@mitre.org", "published": "2019-05-15T23:29:00.607", "lastModified": "2020-09-28T20:15:12.827", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "A Denial Of Service vulnerability in MiniUPnP MiniUPnPd through 2.1 exists due to a NULL pointer dereference in GetOutboundPinholeTimeout in upnpsoap.c for int_port."}, {"lang": "es", "value": "Existe una vulnerabilidad de Denegaci\u00f3n de Servicio en MiniUPnP MiniUPnPd hasta la versi\u00f3n 2.1, debido a una diferencia de puntero NULL en GetOutboundPinholeTimeout en upnpsoap.c para int_port."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:miniupnp_project:miniupnpd:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.1", "matchCriteriaId": "75C9C56C-3164-4A9D-8CEC-3325503527D0"}]}]}], "references": [{"url": "https://github.com/miniupnp/miniupnp/commit/13585f15c7f7dc28bbbba1661efb280d530d114c", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/miniupnp/miniupnp/commit/86030db849260dd8fb2ed975b9890aef1b62b692", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2019/05/msg00045.html", "source": "cve@mitre.org"}, {"url": "https://usn.ubuntu.com/4542-1/", "source": "cve@mitre.org"}, {"url": "https://www.vdoo.com/blog/security-issues-discovered-in-miniupnp", "source": "cve@mitre.org", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/miniupnp/miniupnp/commit/13585f15c7f7dc28bbbba1661efb280d530d114c"}}