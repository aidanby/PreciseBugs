{"buggy_code": ["package providers\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"net/url\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/oauth2-proxy/oauth2-proxy/v7/pkg/apis/sessions\"\n\t\"github.com/oauth2-proxy/oauth2-proxy/v7/pkg/logger\"\n\t\"github.com/oauth2-proxy/oauth2-proxy/v7/pkg/requests\"\n\t\"golang.org/x/oauth2\"\n)\n\n// GitLabProvider represents a GitLab based Identity Provider\ntype GitLabProvider struct {\n\t*ProviderData\n\n\tGroups   []string\n\tProjects []*GitlabProject\n}\n\n// GitlabProject represents a Gitlab project constraint entity\ntype GitlabProject struct {\n\tName        string\n\tAccessLevel int\n}\n\n// newGitlabProject Creates a new GitlabProject struct from project string formatted as namespace/project=accesslevel\n// if no accesslevel provided, use the default one\nfunc newGitlabproject(project string) (*GitlabProject, error) {\n\t// default access level is 20\n\tdefaultAccessLevel := 20\n\t// see https://docs.gitlab.com/ee/api/members.html#valid-access-levels\n\tvalidAccessLevel := [4]int{10, 20, 30, 40}\n\n\tparts := strings.SplitN(project, \"=\", 2)\n\n\tif len(parts) == 2 {\n\t\tlvl, err := strconv.Atoi(parts[1])\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tfor _, valid := range validAccessLevel {\n\t\t\tif lvl == valid {\n\t\t\t\treturn &GitlabProject{\n\t\t\t\t\t\tName:        parts[0],\n\t\t\t\t\t\tAccessLevel: lvl},\n\t\t\t\t\terr\n\t\t\t}\n\t\t}\n\n\t\treturn nil, fmt.Errorf(\"invalid gitlab project access level specified (%s)\", parts[0])\n\n\t}\n\n\treturn &GitlabProject{\n\t\t\tName:        project,\n\t\t\tAccessLevel: defaultAccessLevel},\n\t\tnil\n\n}\n\nvar _ Provider = (*GitLabProvider)(nil)\n\nconst (\n\tgitlabProviderName = \"GitLab\"\n\tgitlabDefaultScope = \"openid email\"\n)\n\n// NewGitLabProvider initiates a new GitLabProvider\nfunc NewGitLabProvider(p *ProviderData) *GitLabProvider {\n\tp.ProviderName = gitlabProviderName\n\n\tif p.Scope == \"\" {\n\t\tp.Scope = gitlabDefaultScope\n\t}\n\n\treturn &GitLabProvider{ProviderData: p}\n}\n\n// Redeem exchanges the OAuth2 authentication token for an ID token\nfunc (p *GitLabProvider) Redeem(ctx context.Context, redirectURL, code string) (s *sessions.SessionState, err error) {\n\tclientSecret, err := p.GetClientSecret()\n\tif err != nil {\n\t\treturn\n\t}\n\n\tc := oauth2.Config{\n\t\tClientID:     p.ClientID,\n\t\tClientSecret: clientSecret,\n\t\tEndpoint: oauth2.Endpoint{\n\t\t\tTokenURL: p.RedeemURL.String(),\n\t\t},\n\t\tRedirectURL: redirectURL,\n\t}\n\ttoken, err := c.Exchange(ctx, code)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"token exchange: %v\", err)\n\t}\n\ts, err = p.createSession(ctx, token)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"unable to update session: %v\", err)\n\t}\n\treturn\n}\n\n// SetProjectScope ensure read_api is added to scope when filtering on projects\nfunc (p *GitLabProvider) SetProjectScope() {\n\tif len(p.Projects) > 0 {\n\t\tfor _, val := range strings.Split(p.Scope, \" \") {\n\t\t\tif val == \"read_api\" {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t}\n\t\tp.Scope += \" read_api\"\n\t}\n}\n\n// RefreshSessionIfNeeded checks if the session has expired and uses the\n// RefreshToken to fetch a new ID token if required\nfunc (p *GitLabProvider) RefreshSessionIfNeeded(ctx context.Context, s *sessions.SessionState) (bool, error) {\n\tif s == nil || (s.ExpiresOn != nil && s.ExpiresOn.After(time.Now())) || s.RefreshToken == \"\" {\n\t\treturn false, nil\n\t}\n\n\torigExpiration := s.ExpiresOn\n\n\terr := p.redeemRefreshToken(ctx, s)\n\tif err != nil {\n\t\treturn false, fmt.Errorf(\"unable to redeem refresh token: %v\", err)\n\t}\n\n\tlogger.Printf(\"refreshed id token %s (expired on %s)\\n\", s, origExpiration)\n\treturn true, nil\n}\n\nfunc (p *GitLabProvider) redeemRefreshToken(ctx context.Context, s *sessions.SessionState) (err error) {\n\tclientSecret, err := p.GetClientSecret()\n\tif err != nil {\n\t\treturn\n\t}\n\n\tc := oauth2.Config{\n\t\tClientID:     p.ClientID,\n\t\tClientSecret: clientSecret,\n\t\tEndpoint: oauth2.Endpoint{\n\t\t\tTokenURL: p.RedeemURL.String(),\n\t\t},\n\t}\n\tt := &oauth2.Token{\n\t\tRefreshToken: s.RefreshToken,\n\t\tExpiry:       time.Now().Add(-time.Hour),\n\t}\n\ttoken, err := c.TokenSource(ctx, t).Token()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to get token: %v\", err)\n\t}\n\tnewSession, err := p.createSession(ctx, token)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"unable to update session: %v\", err)\n\t}\n\ts.AccessToken = newSession.AccessToken\n\ts.IDToken = newSession.IDToken\n\ts.RefreshToken = newSession.RefreshToken\n\ts.CreatedAt = newSession.CreatedAt\n\ts.ExpiresOn = newSession.ExpiresOn\n\ts.Email = newSession.Email\n\treturn\n}\n\ntype gitlabUserInfo struct {\n\tUsername      string   `json:\"nickname\"`\n\tEmail         string   `json:\"email\"`\n\tEmailVerified bool     `json:\"email_verified\"`\n\tGroups        []string `json:\"groups\"`\n}\n\nfunc (p *GitLabProvider) getUserInfo(ctx context.Context, s *sessions.SessionState) (*gitlabUserInfo, error) {\n\t// Retrieve user info JSON\n\t// https://docs.gitlab.com/ee/integration/openid_connect_provider.html#shared-information\n\n\t// Build user info url from login url of GitLab instance\n\tuserInfoURL := *p.LoginURL\n\tuserInfoURL.Path = \"/oauth/userinfo\"\n\n\tvar userInfo gitlabUserInfo\n\terr := requests.New(userInfoURL.String()).\n\t\tWithContext(ctx).\n\t\tSetHeader(\"Authorization\", \"Bearer \"+s.AccessToken).\n\t\tDo().\n\t\tUnmarshalInto(&userInfo)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error getting user info: %v\", err)\n\t}\n\n\treturn &userInfo, nil\n}\n\ntype gitlabPermissionAccess struct {\n\tAccessLevel int `json:\"access_level\"`\n}\n\ntype gitlabProjectPermission struct {\n\tProjectAccess *gitlabPermissionAccess `json:\"project_access\"`\n\tGroupAccess   *gitlabPermissionAccess `json:\"group_access\"`\n}\n\ntype gitlabProjectInfo struct {\n\tName              string                  `json:\"name\"`\n\tArchived          bool                    `json:\"archived\"`\n\tPathWithNamespace string                  `json:\"path_with_namespace\"`\n\tPermissions       gitlabProjectPermission `json:\"permissions\"`\n}\n\nfunc (p *GitLabProvider) getProjectInfo(ctx context.Context, s *sessions.SessionState, project string) (*gitlabProjectInfo, error) {\n\tvar projectInfo gitlabProjectInfo\n\n\tendpointURL := &url.URL{\n\t\tScheme: p.LoginURL.Scheme,\n\t\tHost:   p.LoginURL.Host,\n\t\tPath:   \"/api/v4/projects/\",\n\t}\n\n\terr := requests.New(fmt.Sprintf(\"%s%s\", endpointURL.String(), url.QueryEscape(project))).\n\t\tWithContext(ctx).\n\t\tSetHeader(\"Authorization\", \"Bearer \"+s.AccessToken).\n\t\tDo().\n\t\tUnmarshalInto(&projectInfo)\n\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to get project info: %v\", err)\n\t}\n\n\treturn &projectInfo, nil\n}\n\n// AddProjects adds Gitlab projects from options to GitlabProvider struct\nfunc (p *GitLabProvider) AddProjects(projects []string) error {\n\tfor _, project := range projects {\n\t\tgp, err := newGitlabproject(project)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tp.Projects = append(p.Projects, gp)\n\t}\n\n\treturn nil\n}\n\nfunc (p *GitLabProvider) createSession(ctx context.Context, token *oauth2.Token) (*sessions.SessionState, error) {\n\tidToken, err := p.verifyIDToken(ctx, token)\n\tif err != nil {\n\t\tswitch err {\n\t\tcase ErrMissingIDToken:\n\t\t\treturn nil, fmt.Errorf(\"token response did not contain an id_token\")\n\t\tdefault:\n\t\t\treturn nil, fmt.Errorf(\"could not verify id_token: %v\", err)\n\t\t}\n\t}\n\n\tcreated := time.Now()\n\treturn &sessions.SessionState{\n\t\tAccessToken:  token.AccessToken,\n\t\tIDToken:      getIDToken(token),\n\t\tRefreshToken: token.RefreshToken,\n\t\tCreatedAt:    &created,\n\t\tExpiresOn:    &idToken.Expiry,\n\t}, nil\n}\n\n// ValidateSession checks that the session's IDToken is still valid\nfunc (p *GitLabProvider) ValidateSession(ctx context.Context, s *sessions.SessionState) bool {\n\t_, err := p.Verifier.Verify(ctx, s.IDToken)\n\treturn err == nil\n}\n\n// EnrichSession adds values and data from the Gitlab endpoint to current session\nfunc (p *GitLabProvider) EnrichSession(ctx context.Context, s *sessions.SessionState) error {\n\t// Retrieve user info\n\tuserInfo, err := p.getUserInfo(ctx, s)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to retrieve user info: %v\", err)\n\t}\n\n\t// Check if email is verified\n\tif !p.AllowUnverifiedEmail && !userInfo.EmailVerified {\n\t\treturn fmt.Errorf(\"user email is not verified\")\n\t}\n\n\ts.User = userInfo.Username\n\ts.Email = userInfo.Email\n\n\tp.addGroupsToSession(ctx, s)\n\n\tp.addProjectsToSession(ctx, s)\n\n\treturn nil\n\n}\n\n// addGroupsToSession projects into session.Groups\nfunc (p *GitLabProvider) addGroupsToSession(ctx context.Context, s *sessions.SessionState) {\n\t// Iterate over projects, check if oauth2-proxy can get project information on behalf of the user\n\tfor _, group := range p.Groups {\n\t\ts.Groups = append(s.Groups, fmt.Sprintf(\"group:%s\", group))\n\t}\n}\n\n// addProjectsToSession adds projects matching user access requirements into the session state groups list\n// This method prefix projects names with `project` to specify group kind\nfunc (p *GitLabProvider) addProjectsToSession(ctx context.Context, s *sessions.SessionState) {\n\t// Iterate over projects, check if oauth2-proxy can get project information on behalf of the user\n\tfor _, project := range p.Projects {\n\t\tprojectInfo, err := p.getProjectInfo(ctx, s, project.Name)\n\n\t\tif err != nil {\n\t\t\tlogger.Errorf(\"Warning: project info request failed: %v\", err)\n\t\t\tcontinue\n\t\t}\n\n\t\tif !projectInfo.Archived {\n\t\t\tperms := projectInfo.Permissions.ProjectAccess\n\t\t\tif perms == nil {\n\t\t\t\t// use group project access as fallback\n\t\t\t\tperms = projectInfo.Permissions.GroupAccess\n\t\t\t\t// group project access is not set for this user then we give up\n\t\t\t\tif perms == nil {\n\t\t\t\t\tlogger.Errorf(\"Warning: user %q has no project level access to %s\", s.Email, project.Name)\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif perms != nil && perms.AccessLevel >= project.AccessLevel {\n\t\t\t\ts.Groups = append(s.Groups, fmt.Sprintf(\"project:%s\", project.Name))\n\t\t\t} else {\n\t\t\t\tlogger.Errorf(\"Warning: user %q does not have the minimum required access level for project %q\", s.Email, project.Name)\n\t\t\t}\n\t\t} else {\n\t\t\tlogger.Errorf(\"Warning: project %s is archived\", project.Name)\n\t\t}\n\n\t}\n\n}\n\n// PrefixAllowedGroups returns a list of allowed groups, prefixed by their `kind` value\nfunc (p *GitLabProvider) PrefixAllowedGroups() (groups []string) {\n\n\tfor _, val := range p.Groups {\n\t\tgroups = append(groups, fmt.Sprintf(\"group:%s\", val))\n\t}\n\n\tfor _, val := range p.Projects {\n\t\tgroups = append(groups, fmt.Sprintf(\"project:%s\", val.Name))\n\t}\n\n\treturn groups\n}\n", "package providers\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"net/url\"\n\n\t\"github.com/oauth2-proxy/oauth2-proxy/v7/pkg/apis/sessions\"\n\t. \"github.com/onsi/ginkgo\"\n\t. \"github.com/onsi/ginkgo/extensions/table\"\n\t. \"github.com/onsi/gomega\"\n)\n\nfunc testGitLabProvider(hostname string) *GitLabProvider {\n\tp := NewGitLabProvider(\n\t\t&ProviderData{\n\t\t\tProviderName: \"\",\n\t\t\tLoginURL:     &url.URL{},\n\t\t\tRedeemURL:    &url.URL{},\n\t\t\tProfileURL:   &url.URL{},\n\t\t\tValidateURL:  &url.URL{},\n\t\t\tScope:        \"\"})\n\tif hostname != \"\" {\n\t\tupdateURL(p.Data().LoginURL, hostname)\n\t\tupdateURL(p.Data().RedeemURL, hostname)\n\t\tupdateURL(p.Data().ProfileURL, hostname)\n\t\tupdateURL(p.Data().ValidateURL, hostname)\n\t}\n\n\treturn p\n}\n\nfunc testGitLabBackend() *httptest.Server {\n\tuserInfo := `\n\t\t{\n\t\t\t\"nickname\": \"FooBar\",\n\t\t\t\"email\": \"foo@bar.com\",\n\t\t\t\"email_verified\": false,\n\t\t\t\"groups\": [\"foo\", \"bar\"]\n\t\t}\n\t`\n\n\tprojectInfo := `\n\t\t{\n\t\t\t\"name\": \"MyProject\",\n\t\t\t\"archived\": false,\n\t\t\t\"path_with_namespace\": \"my_group/my_project\",\n\t\t\t\"permissions\": {\n\t\t\t\t\"project_access\": null,\n\t\t\t\t\"group_access\": {\n\t\t\t\t\t\"access_level\": 30,\n\t\t\t\t\t\"notification_level\": 3\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t`\n\n\tnoAccessProjectInfo := `\n\t\t{\n\t\t\t\"name\": \"NoAccessProject\",\n\t\t\t\"archived\": false,\n\t\t\t\"path_with_namespace\": \"no_access_group/no_access_project\",\n\t\t\t\"permissions\": {\n\t\t\t\t\"project_access\": null,\n\t\t\t\t\"group_access\": null,\n\t\t\t}\n\t\t}\n\t`\n\n\tpersonalProjectInfo := `\n\t\t{\n\t\t\t\"name\": \"MyPersonalProject\",\n\t\t\t\"archived\": false,\n\t\t\t\"path_with_namespace\": \"my_profile/my_personal_project\",\n\t\t\t\"permissions\": {\n\t\t\t\t\"project_access\": {\n\t\t\t\t\t\"access_level\": 30,\n\t\t\t\t\t\"notification_level\": 3\n\t\t\t\t},\n\t\t\t\t\"group_access\": null\n\t\t\t}\n\t\t}\n\t`\n\n\tarchivedProjectInfo := `\n\t\t{\n\t\t\t\"name\": \"MyArchivedProject\",\n\t\t\t\"archived\": true,\n\t\t\t\"path_with_namespace\": \"my_group/my_archived_project\",\n\t\t\t\"permissions\": {\n\t\t\t\t\"project_access\": {\n\t\t\t\t\t\"access_level\": 30,\n\t\t\t\t\t\"notification_level\": 3\n\t\t\t\t},\n\t\t\t\t\"group_access\": null\n\t\t\t}\n\t\t}\n\t`\n\n\tauthHeader := \"Bearer gitlab_access_token\"\n\n\treturn httptest.NewServer(http.HandlerFunc(\n\t\tfunc(w http.ResponseWriter, r *http.Request) {\n\t\t\tswitch r.URL.Path {\n\t\t\tcase \"/oauth/userinfo\":\n\t\t\t\tif r.Header[\"Authorization\"][0] == authHeader {\n\t\t\t\t\tw.WriteHeader(200)\n\t\t\t\t\tw.Write([]byte(userInfo))\n\t\t\t\t} else {\n\t\t\t\t\tw.WriteHeader(401)\n\t\t\t\t}\n\t\t\tcase \"/api/v4/projects/my_group/my_project\":\n\t\t\t\tif r.Header[\"Authorization\"][0] == authHeader {\n\t\t\t\t\tw.WriteHeader(200)\n\t\t\t\t\tw.Write([]byte(projectInfo))\n\t\t\t\t} else {\n\t\t\t\t\tw.WriteHeader(401)\n\t\t\t\t}\n\t\t\tcase \"/api/v4/projects/no_access_group/no_access_project\":\n\t\t\t\tif r.Header[\"Authorization\"][0] == authHeader {\n\t\t\t\t\tw.WriteHeader(200)\n\t\t\t\t\tw.Write([]byte(noAccessProjectInfo))\n\t\t\t\t} else {\n\t\t\t\t\tw.WriteHeader(401)\n\t\t\t\t}\n\t\t\tcase \"/api/v4/projects/my_group/my_archived_project\":\n\t\t\t\tif r.Header[\"Authorization\"][0] == authHeader {\n\t\t\t\t\tw.WriteHeader(200)\n\t\t\t\t\tw.Write([]byte(archivedProjectInfo))\n\t\t\t\t} else {\n\t\t\t\t\tw.WriteHeader(401)\n\t\t\t\t}\n\t\t\tcase \"/api/v4/projects/my_profile/my_personal_project\":\n\t\t\t\tif r.Header[\"Authorization\"][0] == authHeader {\n\t\t\t\t\tw.WriteHeader(200)\n\t\t\t\t\tw.Write([]byte(personalProjectInfo))\n\t\t\t\t} else {\n\t\t\t\t\tw.WriteHeader(401)\n\t\t\t\t}\n\t\t\tcase \"/api/v4/projects/my_group/my_bad_project\":\n\t\t\t\tw.WriteHeader(403)\n\t\t\tdefault:\n\t\t\t\tw.WriteHeader(404)\n\t\t\t}\n\t\t}))\n}\n\nvar _ = Describe(\"Gitlab Provider Tests\", func() {\n\tvar p *GitLabProvider\n\tvar b *httptest.Server\n\n\tBeforeEach(func() {\n\t\tb = testGitLabBackend()\n\n\t\tbURL, err := url.Parse(b.URL)\n\t\tExpect(err).To(BeNil())\n\n\t\tp = testGitLabProvider(bURL.Host)\n\t})\n\n\tAfterEach(func() {\n\t\tb.Close()\n\t})\n\n\tContext(\"with bad token\", func() {\n\t\tIt(\"should trigger an error\", func() {\n\t\t\tp.AllowUnverifiedEmail = false\n\t\t\tsession := &sessions.SessionState{AccessToken: \"unexpected_gitlab_access_token\"}\n\t\t\terr := p.EnrichSession(context.Background(), session)\n\t\t\tExpect(err).To(MatchError(errors.New(\"failed to retrieve user info: error getting user info: unexpected status \\\"401\\\": \")))\n\t\t})\n\t})\n\n\tContext(\"when filtering on email\", func() {\n\t\ttype emailsTableInput struct {\n\t\t\texpectedError        error\n\t\t\texpectedValue        string\n\t\t\tallowUnverifiedEmail bool\n\t\t}\n\n\t\tDescribeTable(\"should return expected results\",\n\t\t\tfunc(in emailsTableInput) {\n\t\t\t\tp.AllowUnverifiedEmail = in.allowUnverifiedEmail\n\t\t\t\tsession := &sessions.SessionState{AccessToken: \"gitlab_access_token\"}\n\n\t\t\t\terr := p.EnrichSession(context.Background(), session)\n\n\t\t\t\tif in.expectedError != nil {\n\t\t\t\t\tExpect(err).To(MatchError(err))\n\t\t\t\t} else {\n\t\t\t\t\tExpect(err).To(BeNil())\n\t\t\t\t\tExpect(session.Email).To(Equal(in.expectedValue))\n\t\t\t\t}\n\t\t\t},\n\t\t\tEntry(\"unverified email denied\", emailsTableInput{\n\t\t\t\texpectedError:        errors.New(\"user email is not verified\"),\n\t\t\t\tallowUnverifiedEmail: false,\n\t\t\t}),\n\t\t\tEntry(\"unverified email allowed\", emailsTableInput{\n\t\t\t\texpectedError:        nil,\n\t\t\t\texpectedValue:        \"foo@bar.com\",\n\t\t\t\tallowUnverifiedEmail: true,\n\t\t\t}),\n\t\t)\n\t})\n\n\tContext(\"when filtering on gitlab entities (groups and projects)\", func() {\n\t\ttype entitiesTableInput struct {\n\t\t\texpectedValue []string\n\t\t\tprojects      []string\n\t\t\tgroups        []string\n\t\t}\n\n\t\tDescribeTable(\"should return expected results\",\n\t\t\tfunc(in entitiesTableInput) {\n\t\t\t\tp.AllowUnverifiedEmail = true\n\t\t\t\tsession := &sessions.SessionState{AccessToken: \"gitlab_access_token\"}\n\n\t\t\t\terr := p.AddProjects(in.projects)\n\t\t\t\tExpect(err).To(BeNil())\n\t\t\t\tp.SetProjectScope()\n\n\t\t\t\tif len(in.groups) > 0 {\n\t\t\t\t\tp.Groups = in.groups\n\t\t\t\t}\n\n\t\t\t\terr = p.EnrichSession(context.Background(), session)\n\n\t\t\t\tExpect(err).To(BeNil())\n\t\t\t\tExpect(session.Groups).To(Equal(in.expectedValue))\n\t\t\t},\n\t\t\tEntry(\"project membership valid on group project\", entitiesTableInput{\n\t\t\t\texpectedValue: []string{\"project:my_group/my_project\"},\n\t\t\t\tprojects:      []string{\"my_group/my_project\"},\n\t\t\t}),\n\t\t\tEntry(\"project membership invalid on group project, insufficient access level level\", entitiesTableInput{\n\t\t\t\texpectedValue: nil,\n\t\t\t\tprojects:      []string{\"my_group/my_project=40\"},\n\t\t\t}),\n\t\t\tEntry(\"project membership invalid on group project, no access at all\", entitiesTableInput{\n\t\t\t\texpectedValue: nil,\n\t\t\t\tprojects:      []string{\"no_access_group/no_access_project=30\"},\n\t\t\t}),\n\t\t\tEntry(\"project membership valid on personnal project\", entitiesTableInput{\n\t\t\t\texpectedValue: []string{\"project:my_profile/my_personal_project\"},\n\t\t\t\tprojects:      []string{\"my_profile/my_personal_project\"},\n\t\t\t}),\n\t\t\tEntry(\"project membership invalid on personnal project, insufficient access level\", entitiesTableInput{\n\t\t\t\texpectedValue: nil,\n\t\t\t\tprojects:      []string{\"my_profile/my_personal_project=40\"},\n\t\t\t}),\n\t\t\tEntry(\"project membership invalid\", entitiesTableInput{\n\t\t\t\texpectedValue: nil,\n\t\t\t\tprojects:      []string{\"my_group/my_bad_project\"},\n\t\t\t}),\n\t\t\tEntry(\"group membership valid\", entitiesTableInput{\n\t\t\t\texpectedValue: []string{\"group:foo\"},\n\t\t\t\tgroups:        []string{\"foo\"},\n\t\t\t}),\n\t\t\tEntry(\"groups and projects\", entitiesTableInput{\n\t\t\t\texpectedValue: []string{\"group:foo\", \"group:baz\", \"project:my_group/my_project\", \"project:my_profile/my_personal_project\"},\n\t\t\t\tgroups:        []string{\"foo\", \"baz\"},\n\t\t\t\tprojects:      []string{\"my_group/my_project\", \"my_profile/my_personal_project\"},\n\t\t\t}),\n\t\t\tEntry(\"archived projects\", entitiesTableInput{\n\t\t\t\texpectedValue: nil,\n\t\t\t\tgroups:        []string{},\n\t\t\t\tprojects:      []string{\"my_group/my_archived_project\"},\n\t\t\t}),\n\t\t)\n\n\t})\n\n\tContext(\"when generating group list from multiple kind\", func() {\n\t\ttype entitiesTableInput struct {\n\t\t\tprojects []string\n\t\t\tgroups   []string\n\t\t}\n\n\t\tDescribeTable(\"should prefix entities with group kind\", func(in entitiesTableInput) {\n\t\t\tp.Groups = in.groups\n\t\t\terr := p.AddProjects(in.projects)\n\t\t\tExpect(err).To(BeNil())\n\n\t\t\tall := p.PrefixAllowedGroups()\n\n\t\t\tExpect(len(all)).To(Equal(len(in.projects) + len(in.groups)))\n\t\t},\n\t\t\tEntry(\"simple test case\", entitiesTableInput{\n\t\t\t\tprojects: []string{\"my_group/my_project\", \"my_group/my_other_project\"},\n\t\t\t\tgroups:   []string{\"mygroup\", \"myothergroup\"},\n\t\t\t}),\n\t\t\tEntry(\"projects only\", entitiesTableInput{\n\t\t\t\tprojects: []string{\"my_group/my_project\", \"my_group/my_other_project\"},\n\t\t\t\tgroups:   []string{},\n\t\t\t}),\n\t\t\tEntry(\"groups only\", entitiesTableInput{\n\t\t\t\tprojects: []string{},\n\t\t\t\tgroups:   []string{\"mygroup\", \"myothergroup\"},\n\t\t\t}),\n\t\t)\n\t})\n})\n"], "fixing_code": ["package providers\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"net/url\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/oauth2-proxy/oauth2-proxy/v7/pkg/apis/sessions\"\n\t\"github.com/oauth2-proxy/oauth2-proxy/v7/pkg/logger\"\n\t\"github.com/oauth2-proxy/oauth2-proxy/v7/pkg/requests\"\n\t\"golang.org/x/oauth2\"\n)\n\n// GitLabProvider represents a GitLab based Identity Provider\ntype GitLabProvider struct {\n\t*ProviderData\n\n\tGroups   []string\n\tProjects []*GitlabProject\n}\n\n// GitlabProject represents a Gitlab project constraint entity\ntype GitlabProject struct {\n\tName        string\n\tAccessLevel int\n}\n\n// newGitlabProject Creates a new GitlabProject struct from project string formatted as namespace/project=accesslevel\n// if no accesslevel provided, use the default one\nfunc newGitlabproject(project string) (*GitlabProject, error) {\n\t// default access level is 20\n\tdefaultAccessLevel := 20\n\t// see https://docs.gitlab.com/ee/api/members.html#valid-access-levels\n\tvalidAccessLevel := [4]int{10, 20, 30, 40}\n\n\tparts := strings.SplitN(project, \"=\", 2)\n\n\tif len(parts) == 2 {\n\t\tlvl, err := strconv.Atoi(parts[1])\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tfor _, valid := range validAccessLevel {\n\t\t\tif lvl == valid {\n\t\t\t\treturn &GitlabProject{\n\t\t\t\t\t\tName:        parts[0],\n\t\t\t\t\t\tAccessLevel: lvl},\n\t\t\t\t\terr\n\t\t\t}\n\t\t}\n\n\t\treturn nil, fmt.Errorf(\"invalid gitlab project access level specified (%s)\", parts[0])\n\n\t}\n\n\treturn &GitlabProject{\n\t\t\tName:        project,\n\t\t\tAccessLevel: defaultAccessLevel},\n\t\tnil\n\n}\n\nvar _ Provider = (*GitLabProvider)(nil)\n\nconst (\n\tgitlabProviderName = \"GitLab\"\n\tgitlabDefaultScope = \"openid email\"\n)\n\n// NewGitLabProvider initiates a new GitLabProvider\nfunc NewGitLabProvider(p *ProviderData) *GitLabProvider {\n\tp.ProviderName = gitlabProviderName\n\n\tif p.Scope == \"\" {\n\t\tp.Scope = gitlabDefaultScope\n\t}\n\n\treturn &GitLabProvider{ProviderData: p}\n}\n\n// Redeem exchanges the OAuth2 authentication token for an ID token\nfunc (p *GitLabProvider) Redeem(ctx context.Context, redirectURL, code string) (s *sessions.SessionState, err error) {\n\tclientSecret, err := p.GetClientSecret()\n\tif err != nil {\n\t\treturn\n\t}\n\n\tc := oauth2.Config{\n\t\tClientID:     p.ClientID,\n\t\tClientSecret: clientSecret,\n\t\tEndpoint: oauth2.Endpoint{\n\t\t\tTokenURL: p.RedeemURL.String(),\n\t\t},\n\t\tRedirectURL: redirectURL,\n\t}\n\ttoken, err := c.Exchange(ctx, code)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"token exchange: %v\", err)\n\t}\n\ts, err = p.createSession(ctx, token)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"unable to update session: %v\", err)\n\t}\n\treturn\n}\n\n// SetProjectScope ensure read_api is added to scope when filtering on projects\nfunc (p *GitLabProvider) SetProjectScope() {\n\tif len(p.Projects) > 0 {\n\t\tfor _, val := range strings.Split(p.Scope, \" \") {\n\t\t\tif val == \"read_api\" {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t}\n\t\tp.Scope += \" read_api\"\n\t}\n}\n\n// RefreshSessionIfNeeded checks if the session has expired and uses the\n// RefreshToken to fetch a new ID token if required\nfunc (p *GitLabProvider) RefreshSessionIfNeeded(ctx context.Context, s *sessions.SessionState) (bool, error) {\n\tif s == nil || (s.ExpiresOn != nil && s.ExpiresOn.After(time.Now())) || s.RefreshToken == \"\" {\n\t\treturn false, nil\n\t}\n\n\torigExpiration := s.ExpiresOn\n\n\terr := p.redeemRefreshToken(ctx, s)\n\tif err != nil {\n\t\treturn false, fmt.Errorf(\"unable to redeem refresh token: %v\", err)\n\t}\n\n\tlogger.Printf(\"refreshed id token %s (expired on %s)\\n\", s, origExpiration)\n\treturn true, nil\n}\n\nfunc (p *GitLabProvider) redeemRefreshToken(ctx context.Context, s *sessions.SessionState) (err error) {\n\tclientSecret, err := p.GetClientSecret()\n\tif err != nil {\n\t\treturn\n\t}\n\n\tc := oauth2.Config{\n\t\tClientID:     p.ClientID,\n\t\tClientSecret: clientSecret,\n\t\tEndpoint: oauth2.Endpoint{\n\t\t\tTokenURL: p.RedeemURL.String(),\n\t\t},\n\t}\n\tt := &oauth2.Token{\n\t\tRefreshToken: s.RefreshToken,\n\t\tExpiry:       time.Now().Add(-time.Hour),\n\t}\n\ttoken, err := c.TokenSource(ctx, t).Token()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to get token: %v\", err)\n\t}\n\tnewSession, err := p.createSession(ctx, token)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"unable to update session: %v\", err)\n\t}\n\ts.AccessToken = newSession.AccessToken\n\ts.IDToken = newSession.IDToken\n\ts.RefreshToken = newSession.RefreshToken\n\ts.CreatedAt = newSession.CreatedAt\n\ts.ExpiresOn = newSession.ExpiresOn\n\ts.Email = newSession.Email\n\treturn\n}\n\ntype gitlabUserInfo struct {\n\tUsername      string   `json:\"nickname\"`\n\tEmail         string   `json:\"email\"`\n\tEmailVerified bool     `json:\"email_verified\"`\n\tGroups        []string `json:\"groups\"`\n}\n\nfunc (p *GitLabProvider) getUserInfo(ctx context.Context, s *sessions.SessionState) (*gitlabUserInfo, error) {\n\t// Retrieve user info JSON\n\t// https://docs.gitlab.com/ee/integration/openid_connect_provider.html#shared-information\n\n\t// Build user info url from login url of GitLab instance\n\tuserInfoURL := *p.LoginURL\n\tuserInfoURL.Path = \"/oauth/userinfo\"\n\n\tvar userInfo gitlabUserInfo\n\terr := requests.New(userInfoURL.String()).\n\t\tWithContext(ctx).\n\t\tSetHeader(\"Authorization\", \"Bearer \"+s.AccessToken).\n\t\tDo().\n\t\tUnmarshalInto(&userInfo)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error getting user info: %v\", err)\n\t}\n\n\treturn &userInfo, nil\n}\n\ntype gitlabPermissionAccess struct {\n\tAccessLevel int `json:\"access_level\"`\n}\n\ntype gitlabProjectPermission struct {\n\tProjectAccess *gitlabPermissionAccess `json:\"project_access\"`\n\tGroupAccess   *gitlabPermissionAccess `json:\"group_access\"`\n}\n\ntype gitlabProjectInfo struct {\n\tName              string                  `json:\"name\"`\n\tArchived          bool                    `json:\"archived\"`\n\tPathWithNamespace string                  `json:\"path_with_namespace\"`\n\tPermissions       gitlabProjectPermission `json:\"permissions\"`\n}\n\nfunc (p *GitLabProvider) getProjectInfo(ctx context.Context, s *sessions.SessionState, project string) (*gitlabProjectInfo, error) {\n\tvar projectInfo gitlabProjectInfo\n\n\tendpointURL := &url.URL{\n\t\tScheme: p.LoginURL.Scheme,\n\t\tHost:   p.LoginURL.Host,\n\t\tPath:   \"/api/v4/projects/\",\n\t}\n\n\terr := requests.New(fmt.Sprintf(\"%s%s\", endpointURL.String(), url.QueryEscape(project))).\n\t\tWithContext(ctx).\n\t\tSetHeader(\"Authorization\", \"Bearer \"+s.AccessToken).\n\t\tDo().\n\t\tUnmarshalInto(&projectInfo)\n\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to get project info: %v\", err)\n\t}\n\n\treturn &projectInfo, nil\n}\n\n// AddProjects adds Gitlab projects from options to GitlabProvider struct\nfunc (p *GitLabProvider) AddProjects(projects []string) error {\n\tfor _, project := range projects {\n\t\tgp, err := newGitlabproject(project)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tp.Projects = append(p.Projects, gp)\n\t}\n\n\treturn nil\n}\n\nfunc (p *GitLabProvider) createSession(ctx context.Context, token *oauth2.Token) (*sessions.SessionState, error) {\n\tidToken, err := p.verifyIDToken(ctx, token)\n\tif err != nil {\n\t\tswitch err {\n\t\tcase ErrMissingIDToken:\n\t\t\treturn nil, fmt.Errorf(\"token response did not contain an id_token\")\n\t\tdefault:\n\t\t\treturn nil, fmt.Errorf(\"could not verify id_token: %v\", err)\n\t\t}\n\t}\n\n\tcreated := time.Now()\n\treturn &sessions.SessionState{\n\t\tAccessToken:  token.AccessToken,\n\t\tIDToken:      getIDToken(token),\n\t\tRefreshToken: token.RefreshToken,\n\t\tCreatedAt:    &created,\n\t\tExpiresOn:    &idToken.Expiry,\n\t}, nil\n}\n\n// ValidateSession checks that the session's IDToken is still valid\nfunc (p *GitLabProvider) ValidateSession(ctx context.Context, s *sessions.SessionState) bool {\n\t_, err := p.Verifier.Verify(ctx, s.IDToken)\n\treturn err == nil\n}\n\n// EnrichSession adds values and data from the Gitlab endpoint to current session\nfunc (p *GitLabProvider) EnrichSession(ctx context.Context, s *sessions.SessionState) error {\n\t// Retrieve user info\n\tuserInfo, err := p.getUserInfo(ctx, s)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to retrieve user info: %v\", err)\n\t}\n\n\t// Check if email is verified\n\tif !p.AllowUnverifiedEmail && !userInfo.EmailVerified {\n\t\treturn fmt.Errorf(\"user email is not verified\")\n\t}\n\n\ts.User = userInfo.Username\n\ts.Email = userInfo.Email\n\tfor _, group := range userInfo.Groups {\n\t\ts.Groups = append(s.Groups, fmt.Sprintf(\"group:%s\", group))\n\t}\n\n\tp.addProjectsToSession(ctx, s)\n\n\treturn nil\n}\n\n// addProjectsToSession adds projects matching user access requirements into the session state groups list\n// This method prefix projects names with `project` to specify group kind\nfunc (p *GitLabProvider) addProjectsToSession(ctx context.Context, s *sessions.SessionState) {\n\t// Iterate over projects, check if oauth2-proxy can get project information on behalf of the user\n\tfor _, project := range p.Projects {\n\t\tprojectInfo, err := p.getProjectInfo(ctx, s, project.Name)\n\n\t\tif err != nil {\n\t\t\tlogger.Errorf(\"Warning: project info request failed: %v\", err)\n\t\t\tcontinue\n\t\t}\n\n\t\tif !projectInfo.Archived {\n\t\t\tperms := projectInfo.Permissions.ProjectAccess\n\t\t\tif perms == nil {\n\t\t\t\t// use group project access as fallback\n\t\t\t\tperms = projectInfo.Permissions.GroupAccess\n\t\t\t\t// group project access is not set for this user then we give up\n\t\t\t\tif perms == nil {\n\t\t\t\t\tlogger.Errorf(\"Warning: user %q has no project level access to %s\", s.Email, project.Name)\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif perms != nil && perms.AccessLevel >= project.AccessLevel {\n\t\t\t\ts.Groups = append(s.Groups, fmt.Sprintf(\"project:%s\", project.Name))\n\t\t\t} else {\n\t\t\t\tlogger.Errorf(\"Warning: user %q does not have the minimum required access level for project %q\", s.Email, project.Name)\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\n\t\tlogger.Errorf(\"Warning: project %s is archived\", project.Name)\n\t}\n}\n\n// PrefixAllowedGroups returns a list of allowed groups, prefixed by their `kind` value\nfunc (p *GitLabProvider) PrefixAllowedGroups() (groups []string) {\n\tfor _, val := range p.Groups {\n\t\tgroups = append(groups, fmt.Sprintf(\"group:%s\", val))\n\t}\n\tfor _, val := range p.Projects {\n\t\tgroups = append(groups, fmt.Sprintf(\"project:%s\", val.Name))\n\t}\n\treturn groups\n}\n", "package providers\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"net/url\"\n\n\t\"github.com/oauth2-proxy/oauth2-proxy/v7/pkg/apis/sessions\"\n\t. \"github.com/onsi/ginkgo\"\n\t. \"github.com/onsi/ginkgo/extensions/table\"\n\t. \"github.com/onsi/gomega\"\n)\n\nfunc testGitLabProvider(hostname string) *GitLabProvider {\n\tp := NewGitLabProvider(\n\t\t&ProviderData{\n\t\t\tProviderName: \"\",\n\t\t\tLoginURL:     &url.URL{},\n\t\t\tRedeemURL:    &url.URL{},\n\t\t\tProfileURL:   &url.URL{},\n\t\t\tValidateURL:  &url.URL{},\n\t\t\tScope:        \"\"})\n\tif hostname != \"\" {\n\t\tupdateURL(p.Data().LoginURL, hostname)\n\t\tupdateURL(p.Data().RedeemURL, hostname)\n\t\tupdateURL(p.Data().ProfileURL, hostname)\n\t\tupdateURL(p.Data().ValidateURL, hostname)\n\t}\n\n\treturn p\n}\n\nfunc testGitLabBackend() *httptest.Server {\n\tuserInfo := `\n\t\t{\n\t\t\t\"nickname\": \"FooBar\",\n\t\t\t\"email\": \"foo@bar.com\",\n\t\t\t\"email_verified\": false,\n\t\t\t\"groups\": [\"foo\", \"bar\"]\n\t\t}\n\t`\n\n\tprojectInfo := `\n\t\t{\n\t\t\t\"name\": \"MyProject\",\n\t\t\t\"archived\": false,\n\t\t\t\"path_with_namespace\": \"my_group/my_project\",\n\t\t\t\"permissions\": {\n\t\t\t\t\"project_access\": null,\n\t\t\t\t\"group_access\": {\n\t\t\t\t\t\"access_level\": 30,\n\t\t\t\t\t\"notification_level\": 3\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t`\n\n\tnoAccessProjectInfo := `\n\t\t{\n\t\t\t\"name\": \"NoAccessProject\",\n\t\t\t\"archived\": false,\n\t\t\t\"path_with_namespace\": \"no_access_group/no_access_project\",\n\t\t\t\"permissions\": {\n\t\t\t\t\"project_access\": null,\n\t\t\t\t\"group_access\": null,\n\t\t\t}\n\t\t}\n\t`\n\n\tpersonalProjectInfo := `\n\t\t{\n\t\t\t\"name\": \"MyPersonalProject\",\n\t\t\t\"archived\": false,\n\t\t\t\"path_with_namespace\": \"my_profile/my_personal_project\",\n\t\t\t\"permissions\": {\n\t\t\t\t\"project_access\": {\n\t\t\t\t\t\"access_level\": 30,\n\t\t\t\t\t\"notification_level\": 3\n\t\t\t\t},\n\t\t\t\t\"group_access\": null\n\t\t\t}\n\t\t}\n\t`\n\n\tarchivedProjectInfo := `\n\t\t{\n\t\t\t\"name\": \"MyArchivedProject\",\n\t\t\t\"archived\": true,\n\t\t\t\"path_with_namespace\": \"my_group/my_archived_project\",\n\t\t\t\"permissions\": {\n\t\t\t\t\"project_access\": {\n\t\t\t\t\t\"access_level\": 30,\n\t\t\t\t\t\"notification_level\": 3\n\t\t\t\t},\n\t\t\t\t\"group_access\": null\n\t\t\t}\n\t\t}\n\t`\n\n\tauthHeader := \"Bearer gitlab_access_token\"\n\n\treturn httptest.NewServer(http.HandlerFunc(\n\t\tfunc(w http.ResponseWriter, r *http.Request) {\n\t\t\tswitch r.URL.Path {\n\t\t\tcase \"/oauth/userinfo\":\n\t\t\t\tif r.Header[\"Authorization\"][0] == authHeader {\n\t\t\t\t\tw.WriteHeader(200)\n\t\t\t\t\tw.Write([]byte(userInfo))\n\t\t\t\t} else {\n\t\t\t\t\tw.WriteHeader(401)\n\t\t\t\t}\n\t\t\tcase \"/api/v4/projects/my_group/my_project\":\n\t\t\t\tif r.Header[\"Authorization\"][0] == authHeader {\n\t\t\t\t\tw.WriteHeader(200)\n\t\t\t\t\tw.Write([]byte(projectInfo))\n\t\t\t\t} else {\n\t\t\t\t\tw.WriteHeader(401)\n\t\t\t\t}\n\t\t\tcase \"/api/v4/projects/no_access_group/no_access_project\":\n\t\t\t\tif r.Header[\"Authorization\"][0] == authHeader {\n\t\t\t\t\tw.WriteHeader(200)\n\t\t\t\t\tw.Write([]byte(noAccessProjectInfo))\n\t\t\t\t} else {\n\t\t\t\t\tw.WriteHeader(401)\n\t\t\t\t}\n\t\t\tcase \"/api/v4/projects/my_group/my_archived_project\":\n\t\t\t\tif r.Header[\"Authorization\"][0] == authHeader {\n\t\t\t\t\tw.WriteHeader(200)\n\t\t\t\t\tw.Write([]byte(archivedProjectInfo))\n\t\t\t\t} else {\n\t\t\t\t\tw.WriteHeader(401)\n\t\t\t\t}\n\t\t\tcase \"/api/v4/projects/my_profile/my_personal_project\":\n\t\t\t\tif r.Header[\"Authorization\"][0] == authHeader {\n\t\t\t\t\tw.WriteHeader(200)\n\t\t\t\t\tw.Write([]byte(personalProjectInfo))\n\t\t\t\t} else {\n\t\t\t\t\tw.WriteHeader(401)\n\t\t\t\t}\n\t\t\tcase \"/api/v4/projects/my_group/my_bad_project\":\n\t\t\t\tw.WriteHeader(403)\n\t\t\tdefault:\n\t\t\t\tw.WriteHeader(404)\n\t\t\t}\n\t\t}))\n}\n\nvar _ = Describe(\"Gitlab Provider Tests\", func() {\n\tvar p *GitLabProvider\n\tvar b *httptest.Server\n\n\tBeforeEach(func() {\n\t\tb = testGitLabBackend()\n\n\t\tbURL, err := url.Parse(b.URL)\n\t\tExpect(err).To(BeNil())\n\n\t\tp = testGitLabProvider(bURL.Host)\n\t})\n\n\tAfterEach(func() {\n\t\tb.Close()\n\t})\n\n\tContext(\"with bad token\", func() {\n\t\tIt(\"should trigger an error\", func() {\n\t\t\tp.AllowUnverifiedEmail = false\n\t\t\tsession := &sessions.SessionState{AccessToken: \"unexpected_gitlab_access_token\"}\n\t\t\terr := p.EnrichSession(context.Background(), session)\n\t\t\tExpect(err).To(MatchError(errors.New(\"failed to retrieve user info: error getting user info: unexpected status \\\"401\\\": \")))\n\t\t})\n\t})\n\n\tContext(\"when filtering on email\", func() {\n\t\ttype emailsTableInput struct {\n\t\t\texpectedError        error\n\t\t\texpectedValue        string\n\t\t\tallowUnverifiedEmail bool\n\t\t}\n\n\t\tDescribeTable(\"should return expected results\",\n\t\t\tfunc(in emailsTableInput) {\n\t\t\t\tp.AllowUnverifiedEmail = in.allowUnverifiedEmail\n\t\t\t\tsession := &sessions.SessionState{AccessToken: \"gitlab_access_token\"}\n\n\t\t\t\terr := p.EnrichSession(context.Background(), session)\n\n\t\t\t\tif in.expectedError != nil {\n\t\t\t\t\tExpect(err).To(MatchError(err))\n\t\t\t\t} else {\n\t\t\t\t\tExpect(err).To(BeNil())\n\t\t\t\t\tExpect(session.Email).To(Equal(in.expectedValue))\n\t\t\t\t}\n\t\t\t},\n\t\t\tEntry(\"unverified email denied\", emailsTableInput{\n\t\t\t\texpectedError:        errors.New(\"user email is not verified\"),\n\t\t\t\tallowUnverifiedEmail: false,\n\t\t\t}),\n\t\t\tEntry(\"unverified email allowed\", emailsTableInput{\n\t\t\t\texpectedError:        nil,\n\t\t\t\texpectedValue:        \"foo@bar.com\",\n\t\t\t\tallowUnverifiedEmail: true,\n\t\t\t}),\n\t\t)\n\t})\n\n\tContext(\"when filtering on gitlab entities (groups and projects)\", func() {\n\t\ttype entitiesTableInput struct {\n\t\t\texpectedValue []string\n\t\t\tprojects      []string\n\t\t\tgroups        []string\n\t\t}\n\n\t\tDescribeTable(\"should return expected results\",\n\t\t\tfunc(in entitiesTableInput) {\n\t\t\t\tp.AllowUnverifiedEmail = true\n\t\t\t\tsession := &sessions.SessionState{AccessToken: \"gitlab_access_token\"}\n\n\t\t\t\terr := p.AddProjects(in.projects)\n\t\t\t\tExpect(err).To(BeNil())\n\t\t\t\tp.SetProjectScope()\n\n\t\t\t\tif len(in.groups) > 0 {\n\t\t\t\t\tp.Groups = in.groups\n\t\t\t\t}\n\n\t\t\t\terr = p.EnrichSession(context.Background(), session)\n\n\t\t\t\tExpect(err).To(BeNil())\n\t\t\t\tExpect(session.Groups).To(Equal(in.expectedValue))\n\t\t\t},\n\t\t\tEntry(\"project membership valid on group project\", entitiesTableInput{\n\t\t\t\texpectedValue: []string{\"group:foo\", \"group:bar\", \"project:my_group/my_project\"},\n\t\t\t\tprojects:      []string{\"my_group/my_project\"},\n\t\t\t}),\n\t\t\tEntry(\"project membership invalid on group project, insufficient access level level\", entitiesTableInput{\n\t\t\t\texpectedValue: []string{\"group:foo\", \"group:bar\"},\n\t\t\t\tprojects:      []string{\"my_group/my_project=40\"},\n\t\t\t}),\n\t\t\tEntry(\"project membership invalid on group project, no access at all\", entitiesTableInput{\n\t\t\t\texpectedValue: nil,\n\t\t\t\tprojects:      []string{\"no_access_group/no_access_project=30\"},\n\t\t\t}),\n\t\t\tEntry(\"project membership valid on personnal project\", entitiesTableInput{\n\t\t\t\texpectedValue: []string{\"group:foo\", \"group:bar\", \"project:my_profile/my_personal_project\"},\n\t\t\t\tprojects:      []string{\"my_profile/my_personal_project\"},\n\t\t\t}),\n\t\t\tEntry(\"project membership invalid on personnal project, insufficient access level\", entitiesTableInput{\n\t\t\t\texpectedValue: []string{\"group:foo\", \"group:bar\"},\n\t\t\t\tprojects:      []string{\"my_profile/my_personal_project=40\"},\n\t\t\t}),\n\t\t\tEntry(\"project membership invalid\", entitiesTableInput{\n\t\t\t\texpectedValue: []string{\"group:foo\", \"group:bar\"},\n\t\t\t\tprojects:      []string{\"my_group/my_bad_project\"},\n\t\t\t}),\n\t\t\tEntry(\"group membership valid\", entitiesTableInput{\n\t\t\t\texpectedValue: []string{\"group:foo\", \"group:bar\"},\n\t\t\t\tgroups:        []string{\"foo\"},\n\t\t\t}),\n\t\t\tEntry(\"groups and projects\", entitiesTableInput{\n\t\t\t\texpectedValue: []string{\"group:foo\", \"group:bar\", \"project:my_group/my_project\", \"project:my_profile/my_personal_project\"},\n\t\t\t\tgroups:        []string{\"foo\", \"baz\"},\n\t\t\t\tprojects:      []string{\"my_group/my_project\", \"my_profile/my_personal_project\"},\n\t\t\t}),\n\t\t\tEntry(\"archived projects\", entitiesTableInput{\n\t\t\t\texpectedValue: []string{\"group:foo\", \"group:bar\"},\n\t\t\t\tgroups:        []string{},\n\t\t\t\tprojects:      []string{\"my_group/my_archived_project\"},\n\t\t\t}),\n\t\t)\n\n\t})\n\n\tContext(\"when generating group list from multiple kind\", func() {\n\t\ttype entitiesTableInput struct {\n\t\t\tprojects []string\n\t\t\tgroups   []string\n\t\t}\n\n\t\tDescribeTable(\"should prefix entities with group kind\", func(in entitiesTableInput) {\n\t\t\tp.Groups = in.groups\n\t\t\terr := p.AddProjects(in.projects)\n\t\t\tExpect(err).To(BeNil())\n\n\t\t\tall := p.PrefixAllowedGroups()\n\n\t\t\tExpect(len(all)).To(Equal(len(in.projects) + len(in.groups)))\n\t\t},\n\t\t\tEntry(\"simple test case\", entitiesTableInput{\n\t\t\t\tprojects: []string{\"my_group/my_project\", \"my_group/my_other_project\"},\n\t\t\t\tgroups:   []string{\"mygroup\", \"myothergroup\"},\n\t\t\t}),\n\t\t\tEntry(\"projects only\", entitiesTableInput{\n\t\t\t\tprojects: []string{\"my_group/my_project\", \"my_group/my_other_project\"},\n\t\t\t\tgroups:   []string{},\n\t\t\t}),\n\t\t\tEntry(\"groups only\", entitiesTableInput{\n\t\t\t\tprojects: []string{},\n\t\t\t\tgroups:   []string{\"mygroup\", \"myothergroup\"},\n\t\t\t}),\n\t\t)\n\t})\n})\n"], "filenames": ["providers/gitlab.go", "providers/gitlab_test.go"], "buggy_code_start_loc": [298, 235], "buggy_code_end_loc": [363, 269], "fixing_code_start_loc": [298, 235], "fixing_code_end_loc": [350, 269], "type": "CWE-863", "message": "OAuth2-Proxy is an open source reverse proxy that provides authentication with Google, Github or other providers. The `--gitlab-group` flag for group-based authorization in the GitLab provider stopped working in the v7.0.0 release. Regardless of the flag settings, authorization wasn't restricted. Additionally, any authenticated users had whichever groups were set in `--gitlab-group` added to the new `X-Forwarded-Groups` header to the upstream application. While adding GitLab project based authorization support in #630, a bug was introduced where the user session's groups field was populated with the `--gitlab-group` config entries instead of pulling the individual user's group membership from the GitLab Userinfo endpoint. When the session groups where compared against the allowed groups for authorization, they matched improperly (since both lists were populated with the same data) so authorization was allowed. This impacts GitLab Provider users who relies on group membership for authorization restrictions. Any authenticated users in your GitLab environment can access your applications regardless of `--gitlab-group` membership restrictions. This is patched in v7.1.0. There is no workaround for the Group membership bug. But `--gitlab-project` can be set to use Project membership as the authorization checks instead of groups; it is not broken.", "other": {"cve": {"id": "CVE-2021-21411", "sourceIdentifier": "security-advisories@github.com", "published": "2021-03-26T21:15:13.630", "lastModified": "2021-04-06T12:42:17.673", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "OAuth2-Proxy is an open source reverse proxy that provides authentication with Google, Github or other providers. The `--gitlab-group` flag for group-based authorization in the GitLab provider stopped working in the v7.0.0 release. Regardless of the flag settings, authorization wasn't restricted. Additionally, any authenticated users had whichever groups were set in `--gitlab-group` added to the new `X-Forwarded-Groups` header to the upstream application. While adding GitLab project based authorization support in #630, a bug was introduced where the user session's groups field was populated with the `--gitlab-group` config entries instead of pulling the individual user's group membership from the GitLab Userinfo endpoint. When the session groups where compared against the allowed groups for authorization, they matched improperly (since both lists were populated with the same data) so authorization was allowed. This impacts GitLab Provider users who relies on group membership for authorization restrictions. Any authenticated users in your GitLab environment can access your applications regardless of `--gitlab-group` membership restrictions. This is patched in v7.1.0. There is no workaround for the Group membership bug. But `--gitlab-project` can be set to use Project membership as the authorization checks instead of groups; it is not broken."}, {"lang": "es", "value": "OAuth2-Proxy es un proxy inverso de c\u00f3digo abierto que proporciona autenticaci\u00f3n con Google, Github u otros proveedores. El flag \"--gitlab-group\" para la autorizaci\u00f3n basada en grupos en el proveedor GitLab dej\u00f3 de funcionar en la versi\u00f3n v7.0.0. Independientemente de la configuraci\u00f3n del flag, la autorizaci\u00f3n no estaba restringida. Adem\u00e1s, cualquier usuario autenticado ten\u00eda los grupos que hab\u00edan sido establecidos en \"--gitlab-group\" a\u00f1adidos al nuevo encabezado \"X-Forwarded-Groups\" para la aplicaci\u00f3n de origen. Al a\u00f1adir la compatibilidad con la autorizaci\u00f3n basada en proyectos de GitLab en el n\u00famero 630, se introdujo un error por el que el campo groups de la sesi\u00f3n del usuario se rellenaba con las entradas de configuraci\u00f3n de \"--gitlab-group\" en lugar de extraer la pertenencia al grupo del usuario individual desde el endpoint de GitLab Userinfo. Cuando los grupos de la sesi\u00f3n se comparaban con los grupos permitidos para la autorizaci\u00f3n, coincid\u00edan incorrectamente (ya que ambas listas se rellenaban con los mismos datos), por lo que se permit\u00eda la autorizaci\u00f3n. Esto afecta a usuarios del proveedor de GitLab que se basan en la pertenencia a grupos para las restricciones de autorizaci\u00f3n. Cualquier usuario autenticado en su entorno de GitLab puede acceder a sus aplicaciones independientemente de las restricciones de pertenencia a grupos de \"--gitlab-group\". Esto ha  sido corregido en la versi\u00f3n 7.1.0. No se presenta una soluci\u00f3n para el error de Group membership. Pero \"--gitlab-project\" puede ser configurado para usar Project membership como la comprobaci\u00f3n de la autorizaci\u00f3n en lugar de los grupos; esto no est\u00e1 roto."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.3, "impactScore": 2.7}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.3, "impactScore": 2.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.5}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-863"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:oauth2_proxy_project:oauth2_proxy:*:*:*:*:*:*:*:*", "versionStartIncluding": "7.0.0", "versionEndExcluding": "7.1.0", "matchCriteriaId": "A5AAF6F8-6CAE-4E37-9DD9-28C967852020"}]}]}], "references": [{"url": "https://docs.gitlab.com/ee/user/group/", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/oauth2-proxy/oauth2-proxy/commit/0279fa7dff1752f1710707dbd1ffac839de8bbfc", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/oauth2-proxy/oauth2-proxy/releases/tag/v7.1.0", "source": "security-advisories@github.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/oauth2-proxy/oauth2-proxy/security/advisories/GHSA-652x-m2gr-hppm", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://pkg.go.dev/github.com/oauth2-proxy/oauth2-proxy/v7", "source": "security-advisories@github.com", "tags": ["Product", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/oauth2-proxy/oauth2-proxy/commit/0279fa7dff1752f1710707dbd1ffac839de8bbfc"}}