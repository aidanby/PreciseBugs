{"buggy_code": ["/* $OpenBSD: kex.c,v 1.126 2016/09/28 21:44:52 djm Exp $ */\n/*\n * Copyright (c) 2000, 2001 Markus Friedl.  All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,\n * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"includes.h\"\n\n\n#include <signal.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#ifdef WITH_OPENSSL\n#include <openssl/crypto.h>\n#include <openssl/dh.h>\n#endif\n\n#include \"ssh2.h\"\n#include \"packet.h\"\n#include \"compat.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"kex.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"dispatch.h\"\n#include \"monitor.h\"\n\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"digest.h\"\n\n#if OPENSSL_VERSION_NUMBER >= 0x00907000L\n# if defined(HAVE_EVP_SHA256)\n# define evp_ssh_sha256 EVP_sha256\n# else\nextern const EVP_MD *evp_ssh_sha256(void);\n# endif\n#endif\n\n/* prototype */\nstatic int kex_choose_conf(struct ssh *);\nstatic int kex_input_newkeys(int, u_int32_t, void *);\n\nstatic const char *proposal_names[PROPOSAL_MAX] = {\n\t\"KEX algorithms\",\n\t\"host key algorithms\",\n\t\"ciphers ctos\",\n\t\"ciphers stoc\",\n\t\"MACs ctos\",\n\t\"MACs stoc\",\n\t\"compression ctos\",\n\t\"compression stoc\",\n\t\"languages ctos\",\n\t\"languages stoc\",\n};\n\nstruct kexalg {\n\tchar *name;\n\tu_int type;\n\tint ec_nid;\n\tint hash_alg;\n};\nstatic const struct kexalg kexalgs[] = {\n#ifdef WITH_OPENSSL\n\t{ KEX_DH1, KEX_DH_GRP1_SHA1, 0, SSH_DIGEST_SHA1 },\n\t{ KEX_DH14_SHA1, KEX_DH_GRP14_SHA1, 0, SSH_DIGEST_SHA1 },\n\t{ KEX_DH14_SHA256, KEX_DH_GRP14_SHA256, 0, SSH_DIGEST_SHA256 },\n\t{ KEX_DH16_SHA512, KEX_DH_GRP16_SHA512, 0, SSH_DIGEST_SHA512 },\n\t{ KEX_DH18_SHA512, KEX_DH_GRP18_SHA512, 0, SSH_DIGEST_SHA512 },\n\t{ KEX_DHGEX_SHA1, KEX_DH_GEX_SHA1, 0, SSH_DIGEST_SHA1 },\n#ifdef HAVE_EVP_SHA256\n\t{ KEX_DHGEX_SHA256, KEX_DH_GEX_SHA256, 0, SSH_DIGEST_SHA256 },\n#endif /* HAVE_EVP_SHA256 */\n#ifdef OPENSSL_HAS_ECC\n\t{ KEX_ECDH_SHA2_NISTP256, KEX_ECDH_SHA2,\n\t    NID_X9_62_prime256v1, SSH_DIGEST_SHA256 },\n\t{ KEX_ECDH_SHA2_NISTP384, KEX_ECDH_SHA2, NID_secp384r1,\n\t    SSH_DIGEST_SHA384 },\n# ifdef OPENSSL_HAS_NISTP521\n\t{ KEX_ECDH_SHA2_NISTP521, KEX_ECDH_SHA2, NID_secp521r1,\n\t    SSH_DIGEST_SHA512 },\n# endif /* OPENSSL_HAS_NISTP521 */\n#endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n#if defined(HAVE_EVP_SHA256) || !defined(WITH_OPENSSL)\n\t{ KEX_CURVE25519_SHA256, KEX_C25519_SHA256, 0, SSH_DIGEST_SHA256 },\n\t{ KEX_CURVE25519_SHA256_OLD, KEX_C25519_SHA256, 0, SSH_DIGEST_SHA256 },\n#endif /* HAVE_EVP_SHA256 || !WITH_OPENSSL */\n\t{ NULL, -1, -1, -1},\n};\n\nchar *\nkex_alg_list(char sep)\n{\n\tchar *ret = NULL, *tmp;\n\tsize_t nlen, rlen = 0;\n\tconst struct kexalg *k;\n\n\tfor (k = kexalgs; k->name != NULL; k++) {\n\t\tif (ret != NULL)\n\t\t\tret[rlen++] = sep;\n\t\tnlen = strlen(k->name);\n\t\tif ((tmp = realloc(ret, rlen + nlen + 2)) == NULL) {\n\t\t\tfree(ret);\n\t\t\treturn NULL;\n\t\t}\n\t\tret = tmp;\n\t\tmemcpy(ret + rlen, k->name, nlen + 1);\n\t\trlen += nlen;\n\t}\n\treturn ret;\n}\n\nstatic const struct kexalg *\nkex_alg_by_name(const char *name)\n{\n\tconst struct kexalg *k;\n\n\tfor (k = kexalgs; k->name != NULL; k++) {\n\t\tif (strcmp(k->name, name) == 0)\n\t\t\treturn k;\n\t}\n\treturn NULL;\n}\n\n/* Validate KEX method name list */\nint\nkex_names_valid(const char *names)\n{\n\tchar *s, *cp, *p;\n\n\tif (names == NULL || strcmp(names, \"\") == 0)\n\t\treturn 0;\n\tif ((s = cp = strdup(names)) == NULL)\n\t\treturn 0;\n\tfor ((p = strsep(&cp, \",\")); p && *p != '\\0';\n\t    (p = strsep(&cp, \",\"))) {\n\t\tif (kex_alg_by_name(p) == NULL) {\n\t\t\terror(\"Unsupported KEX algorithm \\\"%.100s\\\"\", p);\n\t\t\tfree(s);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tdebug3(\"kex names ok: [%s]\", names);\n\tfree(s);\n\treturn 1;\n}\n\n/*\n * Concatenate algorithm names, avoiding duplicates in the process.\n * Caller must free returned string.\n */\nchar *\nkex_names_cat(const char *a, const char *b)\n{\n\tchar *ret = NULL, *tmp = NULL, *cp, *p;\n\tsize_t len;\n\n\tif (a == NULL || *a == '\\0')\n\t\treturn NULL;\n\tif (b == NULL || *b == '\\0')\n\t\treturn strdup(a);\n\tif (strlen(b) > 1024*1024)\n\t\treturn NULL;\n\tlen = strlen(a) + strlen(b) + 2;\n\tif ((tmp = cp = strdup(b)) == NULL ||\n\t    (ret = calloc(1, len)) == NULL) {\n\t\tfree(tmp);\n\t\treturn NULL;\n\t}\n\tstrlcpy(ret, a, len);\n\tfor ((p = strsep(&cp, \",\")); p && *p != '\\0'; (p = strsep(&cp, \",\"))) {\n\t\tif (match_list(ret, p, NULL) != NULL)\n\t\t\tcontinue; /* Algorithm already present */\n\t\tif (strlcat(ret, \",\", len) >= len ||\n\t\t    strlcat(ret, p, len) >= len) {\n\t\t\tfree(tmp);\n\t\t\tfree(ret);\n\t\t\treturn NULL; /* Shouldn't happen */\n\t\t}\n\t}\n\tfree(tmp);\n\treturn ret;\n}\n\n/*\n * Assemble a list of algorithms from a default list and a string from a\n * configuration file. The user-provided string may begin with '+' to\n * indicate that it should be appended to the default.\n */\nint\nkex_assemble_names(const char *def, char **list)\n{\n\tchar *ret;\n\n\tif (list == NULL || *list == NULL || **list == '\\0') {\n\t\t*list = strdup(def);\n\t\treturn 0;\n\t}\n\tif (**list != '+') {\n\t\treturn 0;\n\t}\n\n\tif ((ret = kex_names_cat(def, *list + 1)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tfree(*list);\n\t*list = ret;\n\treturn 0;\n}\n\n/* put algorithm proposal into buffer */\nint\nkex_prop2buf(struct sshbuf *b, char *proposal[PROPOSAL_MAX])\n{\n\tu_int i;\n\tint r;\n\n\tsshbuf_reset(b);\n\n\t/*\n\t * add a dummy cookie, the cookie will be overwritten by\n\t * kex_send_kexinit(), each time a kexinit is set\n\t */\n\tfor (i = 0; i < KEX_COOKIE_LEN; i++) {\n\t\tif ((r = sshbuf_put_u8(b, 0)) != 0)\n\t\t\treturn r;\n\t}\n\tfor (i = 0; i < PROPOSAL_MAX; i++) {\n\t\tif ((r = sshbuf_put_cstring(b, proposal[i])) != 0)\n\t\t\treturn r;\n\t}\n\tif ((r = sshbuf_put_u8(b, 0)) != 0 ||\t/* first_kex_packet_follows */\n\t    (r = sshbuf_put_u32(b, 0)) != 0)\t/* uint32 reserved */\n\t\treturn r;\n\treturn 0;\n}\n\n/* parse buffer and return algorithm proposal */\nint\nkex_buf2prop(struct sshbuf *raw, int *first_kex_follows, char ***propp)\n{\n\tstruct sshbuf *b = NULL;\n\tu_char v;\n\tu_int i;\n\tchar **proposal = NULL;\n\tint r;\n\n\t*propp = NULL;\n\tif ((proposal = calloc(PROPOSAL_MAX, sizeof(char *))) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((b = sshbuf_fromb(raw)) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif ((r = sshbuf_consume(b, KEX_COOKIE_LEN)) != 0) /* skip cookie */\n\t\tgoto out;\n\t/* extract kex init proposal strings */\n\tfor (i = 0; i < PROPOSAL_MAX; i++) {\n\t\tif ((r = sshbuf_get_cstring(b, &(proposal[i]), NULL)) != 0)\n\t\t\tgoto out;\n\t\tdebug2(\"%s: %s\", proposal_names[i], proposal[i]);\n\t}\n\t/* first kex follows / reserved */\n\tif ((r = sshbuf_get_u8(b, &v)) != 0 ||\t/* first_kex_follows */\n\t    (r = sshbuf_get_u32(b, &i)) != 0)\t/* reserved */\n\t\tgoto out;\n\tif (first_kex_follows != NULL)\n\t\t*first_kex_follows = v;\n\tdebug2(\"first_kex_follows %d \", v);\n\tdebug2(\"reserved %u \", i);\n\tr = 0;\n\t*propp = proposal;\n out:\n\tif (r != 0 && proposal != NULL)\n\t\tkex_prop_free(proposal);\n\tsshbuf_free(b);\n\treturn r;\n}\n\nvoid\nkex_prop_free(char **proposal)\n{\n\tu_int i;\n\n\tif (proposal == NULL)\n\t\treturn;\n\tfor (i = 0; i < PROPOSAL_MAX; i++)\n\t\tfree(proposal[i]);\n\tfree(proposal);\n}\n\n/* ARGSUSED */\nstatic int\nkex_protocol_error(int type, u_int32_t seq, void *ctxt)\n{\n\tstruct ssh *ssh = active_state; /* XXX */\n\tint r;\n\n\terror(\"kex protocol error: type %d seq %u\", type, seq);\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_UNIMPLEMENTED)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, seq)) != 0 ||\n\t    (r = sshpkt_send(ssh)) != 0)\n\t\treturn r;\n\treturn 0;\n}\n\nstatic void\nkex_reset_dispatch(struct ssh *ssh)\n{\n\tssh_dispatch_range(ssh, SSH2_MSG_TRANSPORT_MIN,\n\t    SSH2_MSG_TRANSPORT_MAX, &kex_protocol_error);\n\tssh_dispatch_set(ssh, SSH2_MSG_KEXINIT, &kex_input_kexinit);\n}\n\nstatic int\nkex_send_ext_info(struct ssh *ssh)\n{\n\tint r;\n\tchar *algs;\n\n\tif ((algs = sshkey_alg_list(0, 1, ',')) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_EXT_INFO)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, 1)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, \"server-sig-algs\")) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, algs)) != 0 ||\n\t    (r = sshpkt_send(ssh)) != 0)\n\t\tgoto out;\n\t/* success */\n\tr = 0;\n out:\n\tfree(algs);\n\treturn r;\n}\n\nint\nkex_send_newkeys(struct ssh *ssh)\n{\n\tint r;\n\n\tkex_reset_dispatch(ssh);\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_NEWKEYS)) != 0 ||\n\t    (r = sshpkt_send(ssh)) != 0)\n\t\treturn r;\n\tdebug(\"SSH2_MSG_NEWKEYS sent\");\n\tdebug(\"expecting SSH2_MSG_NEWKEYS\");\n\tssh_dispatch_set(ssh, SSH2_MSG_NEWKEYS, &kex_input_newkeys);\n\tif (ssh->kex->ext_info_c)\n\t\tif ((r = kex_send_ext_info(ssh)) != 0)\n\t\t\treturn r;\n\treturn 0;\n}\n\nint\nkex_input_ext_info(int type, u_int32_t seq, void *ctxt)\n{\n\tstruct ssh *ssh = ctxt;\n\tstruct kex *kex = ssh->kex;\n\tu_int32_t i, ninfo;\n\tchar *name, *val, *found;\n\tint r;\n\n\tdebug(\"SSH2_MSG_EXT_INFO received\");\n\tssh_dispatch_set(ssh, SSH2_MSG_EXT_INFO, &kex_protocol_error);\n\tif ((r = sshpkt_get_u32(ssh, &ninfo)) != 0)\n\t\treturn r;\n\tfor (i = 0; i < ninfo; i++) {\n\t\tif ((r = sshpkt_get_cstring(ssh, &name, NULL)) != 0)\n\t\t\treturn r;\n\t\tif ((r = sshpkt_get_cstring(ssh, &val, NULL)) != 0) {\n\t\t\tfree(name);\n\t\t\treturn r;\n\t\t}\n\t\tdebug(\"%s: %s=<%s>\", __func__, name, val);\n\t\tif (strcmp(name, \"server-sig-algs\") == 0) {\n\t\t\tfound = match_list(\"rsa-sha2-256\", val, NULL);\n\t\t\tif (found) {\n\t\t\t\tkex->rsa_sha2 = 256;\n\t\t\t\tfree(found);\n\t\t\t}\n\t\t\tfound = match_list(\"rsa-sha2-512\", val, NULL);\n\t\t\tif (found) {\n\t\t\t\tkex->rsa_sha2 = 512;\n\t\t\t\tfree(found);\n\t\t\t}\n\t\t}\n\t\tfree(name);\n\t\tfree(val);\n\t}\n\treturn sshpkt_get_end(ssh);\n}\n\nstatic int\nkex_input_newkeys(int type, u_int32_t seq, void *ctxt)\n{\n\tstruct ssh *ssh = ctxt;\n\tstruct kex *kex = ssh->kex;\n\tint r;\n\n\tdebug(\"SSH2_MSG_NEWKEYS received\");\n\tssh_dispatch_set(ssh, SSH2_MSG_NEWKEYS, &kex_protocol_error);\n\tif ((r = sshpkt_get_end(ssh)) != 0)\n\t\treturn r;\n\tif ((r = ssh_set_newkeys(ssh, MODE_IN)) != 0)\n\t\treturn r;\n\tkex->done = 1;\n\tsshbuf_reset(kex->peer);\n\t/* sshbuf_reset(kex->my); */\n\tkex->flags &= ~KEX_INIT_SENT;\n\tfree(kex->name);\n\tkex->name = NULL;\n\treturn 0;\n}\n\nint\nkex_send_kexinit(struct ssh *ssh)\n{\n\tu_char *cookie;\n\tstruct kex *kex = ssh->kex;\n\tint r;\n\n\tif (kex == NULL)\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\tif (kex->flags & KEX_INIT_SENT)\n\t\treturn 0;\n\tkex->done = 0;\n\n\t/* generate a random cookie */\n\tif (sshbuf_len(kex->my) < KEX_COOKIE_LEN)\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\tif ((cookie = sshbuf_mutable_ptr(kex->my)) == NULL)\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\tarc4random_buf(cookie, KEX_COOKIE_LEN);\n\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_KEXINIT)) != 0 ||\n\t    (r = sshpkt_putb(ssh, kex->my)) != 0 ||\n\t    (r = sshpkt_send(ssh)) != 0)\n\t\treturn r;\n\tdebug(\"SSH2_MSG_KEXINIT sent\");\n\tkex->flags |= KEX_INIT_SENT;\n\treturn 0;\n}\n\n/* ARGSUSED */\nint\nkex_input_kexinit(int type, u_int32_t seq, void *ctxt)\n{\n\tstruct ssh *ssh = ctxt;\n\tstruct kex *kex = ssh->kex;\n\tconst u_char *ptr;\n\tu_int i;\n\tsize_t dlen;\n\tint r;\n\n\tdebug(\"SSH2_MSG_KEXINIT received\");\n\tif (kex == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\n\tptr = sshpkt_ptr(ssh, &dlen);\n\tif ((r = sshbuf_put(kex->peer, ptr, dlen)) != 0)\n\t\treturn r;\n\n\t/* discard packet */\n\tfor (i = 0; i < KEX_COOKIE_LEN; i++)\n\t\tif ((r = sshpkt_get_u8(ssh, NULL)) != 0)\n\t\t\treturn r;\n\tfor (i = 0; i < PROPOSAL_MAX; i++)\n\t\tif ((r = sshpkt_get_string(ssh, NULL, NULL)) != 0)\n\t\t\treturn r;\n\t/*\n\t * XXX RFC4253 sec 7: \"each side MAY guess\" - currently no supported\n\t * KEX method has the server move first, but a server might be using\n\t * a custom method or one that we otherwise don't support. We should\n\t * be prepared to remember first_kex_follows here so we can eat a\n\t * packet later.\n\t * XXX2 - RFC4253 is kind of ambiguous on what first_kex_follows means\n\t * for cases where the server *doesn't* go first. I guess we should\n\t * ignore it when it is set for these cases, which is what we do now.\n\t */\n\tif ((r = sshpkt_get_u8(ssh, NULL)) != 0 ||\t/* first_kex_follows */\n\t    (r = sshpkt_get_u32(ssh, NULL)) != 0 ||\t/* reserved */\n\t    (r = sshpkt_get_end(ssh)) != 0)\n\t\t\treturn r;\n\n\tif (!(kex->flags & KEX_INIT_SENT))\n\t\tif ((r = kex_send_kexinit(ssh)) != 0)\n\t\t\treturn r;\n\tif ((r = kex_choose_conf(ssh)) != 0)\n\t\treturn r;\n\n\tif (kex->kex_type < KEX_MAX && kex->kex[kex->kex_type] != NULL)\n\t\treturn (kex->kex[kex->kex_type])(ssh);\n\n\treturn SSH_ERR_INTERNAL_ERROR;\n}\n\nint\nkex_new(struct ssh *ssh, char *proposal[PROPOSAL_MAX], struct kex **kexp)\n{\n\tstruct kex *kex;\n\tint r;\n\n\t*kexp = NULL;\n\tif ((kex = calloc(1, sizeof(*kex))) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((kex->peer = sshbuf_new()) == NULL ||\n\t    (kex->my = sshbuf_new()) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif ((r = kex_prop2buf(kex->my, proposal)) != 0)\n\t\tgoto out;\n\tkex->done = 0;\n\tkex_reset_dispatch(ssh);\n\tr = 0;\n\t*kexp = kex;\n out:\n\tif (r != 0)\n\t\tkex_free(kex);\n\treturn r;\n}\n\nvoid\nkex_free_newkeys(struct newkeys *newkeys)\n{\n\tif (newkeys == NULL)\n\t\treturn;\n\tif (newkeys->enc.key) {\n\t\texplicit_bzero(newkeys->enc.key, newkeys->enc.key_len);\n\t\tfree(newkeys->enc.key);\n\t\tnewkeys->enc.key = NULL;\n\t}\n\tif (newkeys->enc.iv) {\n\t\texplicit_bzero(newkeys->enc.iv, newkeys->enc.iv_len);\n\t\tfree(newkeys->enc.iv);\n\t\tnewkeys->enc.iv = NULL;\n\t}\n\tfree(newkeys->enc.name);\n\texplicit_bzero(&newkeys->enc, sizeof(newkeys->enc));\n\tfree(newkeys->comp.name);\n\texplicit_bzero(&newkeys->comp, sizeof(newkeys->comp));\n\tmac_clear(&newkeys->mac);\n\tif (newkeys->mac.key) {\n\t\texplicit_bzero(newkeys->mac.key, newkeys->mac.key_len);\n\t\tfree(newkeys->mac.key);\n\t\tnewkeys->mac.key = NULL;\n\t}\n\tfree(newkeys->mac.name);\n\texplicit_bzero(&newkeys->mac, sizeof(newkeys->mac));\n\texplicit_bzero(newkeys, sizeof(*newkeys));\n\tfree(newkeys);\n}\n\nvoid\nkex_free(struct kex *kex)\n{\n\tu_int mode;\n\n#ifdef WITH_OPENSSL\n\tif (kex->dh)\n\t\tDH_free(kex->dh);\n#ifdef OPENSSL_HAS_ECC\n\tif (kex->ec_client_key)\n\t\tEC_KEY_free(kex->ec_client_key);\n#endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tfor (mode = 0; mode < MODE_MAX; mode++) {\n\t\tkex_free_newkeys(kex->newkeys[mode]);\n\t\tkex->newkeys[mode] = NULL;\n\t}\n\tsshbuf_free(kex->peer);\n\tsshbuf_free(kex->my);\n\tfree(kex->session_id);\n\tfree(kex->client_version_string);\n\tfree(kex->server_version_string);\n\tfree(kex->failed_choice);\n\tfree(kex->hostkey_alg);\n\tfree(kex->name);\n\tfree(kex);\n}\n\nint\nkex_setup(struct ssh *ssh, char *proposal[PROPOSAL_MAX])\n{\n\tint r;\n\n\tif ((r = kex_new(ssh, proposal, &ssh->kex)) != 0)\n\t\treturn r;\n\tif ((r = kex_send_kexinit(ssh)) != 0) {\t\t/* we start */\n\t\tkex_free(ssh->kex);\n\t\tssh->kex = NULL;\n\t\treturn r;\n\t}\n\treturn 0;\n}\n\n/*\n * Request key re-exchange, returns 0 on success or a ssherr.h error\n * code otherwise. Must not be called if KEX is incomplete or in-progress.\n */\nint\nkex_start_rekex(struct ssh *ssh)\n{\n\tif (ssh->kex == NULL) {\n\t\terror(\"%s: no kex\", __func__);\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\tif (ssh->kex->done == 0) {\n\t\terror(\"%s: requested twice\", __func__);\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\tssh->kex->done = 0;\n\treturn kex_send_kexinit(ssh);\n}\n\nstatic int\nchoose_enc(struct sshenc *enc, char *client, char *server)\n{\n\tchar *name = match_list(client, server, NULL);\n\n\tif (name == NULL)\n\t\treturn SSH_ERR_NO_CIPHER_ALG_MATCH;\n\tif ((enc->cipher = cipher_by_name(name)) == NULL)\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\tenc->name = name;\n\tenc->enabled = 0;\n\tenc->iv = NULL;\n\tenc->iv_len = cipher_ivlen(enc->cipher);\n\tenc->key = NULL;\n\tenc->key_len = cipher_keylen(enc->cipher);\n\tenc->block_size = cipher_blocksize(enc->cipher);\n\treturn 0;\n}\n\nstatic int\nchoose_mac(struct ssh *ssh, struct sshmac *mac, char *client, char *server)\n{\n\tchar *name = match_list(client, server, NULL);\n\n\tif (name == NULL)\n\t\treturn SSH_ERR_NO_MAC_ALG_MATCH;\n\tif (mac_setup(mac, name) < 0)\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t/* truncate the key */\n\tif (ssh->compat & SSH_BUG_HMAC)\n\t\tmac->key_len = 16;\n\tmac->name = name;\n\tmac->key = NULL;\n\tmac->enabled = 0;\n\treturn 0;\n}\n\nstatic int\nchoose_comp(struct sshcomp *comp, char *client, char *server)\n{\n\tchar *name = match_list(client, server, NULL);\n\n\tif (name == NULL)\n\t\treturn SSH_ERR_NO_COMPRESS_ALG_MATCH;\n\tif (strcmp(name, \"zlib@openssh.com\") == 0) {\n\t\tcomp->type = COMP_DELAYED;\n\t} else if (strcmp(name, \"zlib\") == 0) {\n\t\tcomp->type = COMP_ZLIB;\n\t} else if (strcmp(name, \"none\") == 0) {\n\t\tcomp->type = COMP_NONE;\n\t} else {\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\tcomp->name = name;\n\treturn 0;\n}\n\nstatic int\nchoose_kex(struct kex *k, char *client, char *server)\n{\n\tconst struct kexalg *kexalg;\n\n\tk->name = match_list(client, server, NULL);\n\n\tdebug(\"kex: algorithm: %s\", k->name ? k->name : \"(no match)\");\n\tif (k->name == NULL)\n\t\treturn SSH_ERR_NO_KEX_ALG_MATCH;\n\tif ((kexalg = kex_alg_by_name(k->name)) == NULL)\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\tk->kex_type = kexalg->type;\n\tk->hash_alg = kexalg->hash_alg;\n\tk->ec_nid = kexalg->ec_nid;\n\treturn 0;\n}\n\nstatic int\nchoose_hostkeyalg(struct kex *k, char *client, char *server)\n{\n\tk->hostkey_alg = match_list(client, server, NULL);\n\n\tdebug(\"kex: host key algorithm: %s\",\n\t    k->hostkey_alg ? k->hostkey_alg : \"(no match)\");\n\tif (k->hostkey_alg == NULL)\n\t\treturn SSH_ERR_NO_HOSTKEY_ALG_MATCH;\n\tk->hostkey_type = sshkey_type_from_name(k->hostkey_alg);\n\tif (k->hostkey_type == KEY_UNSPEC)\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\tk->hostkey_nid = sshkey_ecdsa_nid_from_name(k->hostkey_alg);\n\treturn 0;\n}\n\nstatic int\nproposals_match(char *my[PROPOSAL_MAX], char *peer[PROPOSAL_MAX])\n{\n\tstatic int check[] = {\n\t\tPROPOSAL_KEX_ALGS, PROPOSAL_SERVER_HOST_KEY_ALGS, -1\n\t};\n\tint *idx;\n\tchar *p;\n\n\tfor (idx = &check[0]; *idx != -1; idx++) {\n\t\tif ((p = strchr(my[*idx], ',')) != NULL)\n\t\t\t*p = '\\0';\n\t\tif ((p = strchr(peer[*idx], ',')) != NULL)\n\t\t\t*p = '\\0';\n\t\tif (strcmp(my[*idx], peer[*idx]) != 0) {\n\t\t\tdebug2(\"proposal mismatch: my %s peer %s\",\n\t\t\t    my[*idx], peer[*idx]);\n\t\t\treturn (0);\n\t\t}\n\t}\n\tdebug2(\"proposals match\");\n\treturn (1);\n}\n\nstatic int\nkex_choose_conf(struct ssh *ssh)\n{\n\tstruct kex *kex = ssh->kex;\n\tstruct newkeys *newkeys;\n\tchar **my = NULL, **peer = NULL;\n\tchar **cprop, **sprop;\n\tint nenc, nmac, ncomp;\n\tu_int mode, ctos, need, dh_need, authlen;\n\tint r, first_kex_follows;\n\n\tdebug2(\"local %s KEXINIT proposal\", kex->server ? \"server\" : \"client\");\n\tif ((r = kex_buf2prop(kex->my, NULL, &my)) != 0)\n\t\tgoto out;\n\tdebug2(\"peer %s KEXINIT proposal\", kex->server ? \"client\" : \"server\");\n\tif ((r = kex_buf2prop(kex->peer, &first_kex_follows, &peer)) != 0)\n\t\tgoto out;\n\n\tif (kex->server) {\n\t\tcprop=peer;\n\t\tsprop=my;\n\t} else {\n\t\tcprop=my;\n\t\tsprop=peer;\n\t}\n\n\t/* Check whether client supports ext_info_c */\n\tif (kex->server) {\n\t\tchar *ext;\n\n\t\text = match_list(\"ext-info-c\", peer[PROPOSAL_KEX_ALGS], NULL);\n\t\tkex->ext_info_c = (ext != NULL);\n\t\tfree(ext);\n\t}\n\n\t/* Algorithm Negotiation */\n\tif ((r = choose_kex(kex, cprop[PROPOSAL_KEX_ALGS],\n\t    sprop[PROPOSAL_KEX_ALGS])) != 0) {\n\t\tkex->failed_choice = peer[PROPOSAL_KEX_ALGS];\n\t\tpeer[PROPOSAL_KEX_ALGS] = NULL;\n\t\tgoto out;\n\t}\n\tif ((r = choose_hostkeyalg(kex, cprop[PROPOSAL_SERVER_HOST_KEY_ALGS],\n\t    sprop[PROPOSAL_SERVER_HOST_KEY_ALGS])) != 0) {\n\t\tkex->failed_choice = peer[PROPOSAL_SERVER_HOST_KEY_ALGS];\n\t\tpeer[PROPOSAL_SERVER_HOST_KEY_ALGS] = NULL;\n\t\tgoto out;\n\t}\n\tfor (mode = 0; mode < MODE_MAX; mode++) {\n\t\tif ((newkeys = calloc(1, sizeof(*newkeys))) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tkex->newkeys[mode] = newkeys;\n\t\tctos = (!kex->server && mode == MODE_OUT) ||\n\t\t    (kex->server && mode == MODE_IN);\n\t\tnenc  = ctos ? PROPOSAL_ENC_ALGS_CTOS  : PROPOSAL_ENC_ALGS_STOC;\n\t\tnmac  = ctos ? PROPOSAL_MAC_ALGS_CTOS  : PROPOSAL_MAC_ALGS_STOC;\n\t\tncomp = ctos ? PROPOSAL_COMP_ALGS_CTOS : PROPOSAL_COMP_ALGS_STOC;\n\t\tif ((r = choose_enc(&newkeys->enc, cprop[nenc],\n\t\t    sprop[nenc])) != 0) {\n\t\t\tkex->failed_choice = peer[nenc];\n\t\t\tpeer[nenc] = NULL;\n\t\t\tgoto out;\n\t\t}\n\t\tauthlen = cipher_authlen(newkeys->enc.cipher);\n\t\t/* ignore mac for authenticated encryption */\n\t\tif (authlen == 0 &&\n\t\t    (r = choose_mac(ssh, &newkeys->mac, cprop[nmac],\n\t\t    sprop[nmac])) != 0) {\n\t\t\tkex->failed_choice = peer[nmac];\n\t\t\tpeer[nmac] = NULL;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = choose_comp(&newkeys->comp, cprop[ncomp],\n\t\t    sprop[ncomp])) != 0) {\n\t\t\tkex->failed_choice = peer[ncomp];\n\t\t\tpeer[ncomp] = NULL;\n\t\t\tgoto out;\n\t\t}\n\t\tdebug(\"kex: %s cipher: %s MAC: %s compression: %s\",\n\t\t    ctos ? \"client->server\" : \"server->client\",\n\t\t    newkeys->enc.name,\n\t\t    authlen == 0 ? newkeys->mac.name : \"<implicit>\",\n\t\t    newkeys->comp.name);\n\t}\n\tneed = dh_need = 0;\n\tfor (mode = 0; mode < MODE_MAX; mode++) {\n\t\tnewkeys = kex->newkeys[mode];\n\t\tneed = MAXIMUM(need, newkeys->enc.key_len);\n\t\tneed = MAXIMUM(need, newkeys->enc.block_size);\n\t\tneed = MAXIMUM(need, newkeys->enc.iv_len);\n\t\tneed = MAXIMUM(need, newkeys->mac.key_len);\n\t\tdh_need = MAXIMUM(dh_need, cipher_seclen(newkeys->enc.cipher));\n\t\tdh_need = MAXIMUM(dh_need, newkeys->enc.block_size);\n\t\tdh_need = MAXIMUM(dh_need, newkeys->enc.iv_len);\n\t\tdh_need = MAXIMUM(dh_need, newkeys->mac.key_len);\n\t}\n\t/* XXX need runden? */\n\tkex->we_need = need;\n\tkex->dh_need = dh_need;\n\n\t/* ignore the next message if the proposals do not match */\n\tif (first_kex_follows && !proposals_match(my, peer) &&\n\t    !(ssh->compat & SSH_BUG_FIRSTKEX))\n\t\tssh->dispatch_skip_packets = 1;\n\tr = 0;\n out:\n\tkex_prop_free(my);\n\tkex_prop_free(peer);\n\treturn r;\n}\n\nstatic int\nderive_key(struct ssh *ssh, int id, u_int need, u_char *hash, u_int hashlen,\n    const struct sshbuf *shared_secret, u_char **keyp)\n{\n\tstruct kex *kex = ssh->kex;\n\tstruct ssh_digest_ctx *hashctx = NULL;\n\tchar c = id;\n\tu_int have;\n\tsize_t mdsz;\n\tu_char *digest;\n\tint r;\n\n\tif ((mdsz = ssh_digest_bytes(kex->hash_alg)) == 0)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif ((digest = calloc(1, ROUNDUP(need, mdsz))) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\n\t/* K1 = HASH(K || H || \"A\" || session_id) */\n\tif ((hashctx = ssh_digest_start(kex->hash_alg)) == NULL ||\n\t    ssh_digest_update_buffer(hashctx, shared_secret) != 0 ||\n\t    ssh_digest_update(hashctx, hash, hashlen) != 0 ||\n\t    ssh_digest_update(hashctx, &c, 1) != 0 ||\n\t    ssh_digest_update(hashctx, kex->session_id,\n\t    kex->session_id_len) != 0 ||\n\t    ssh_digest_final(hashctx, digest, mdsz) != 0) {\n\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\tssh_digest_free(hashctx);\n\thashctx = NULL;\n\n\t/*\n\t * expand key:\n\t * Kn = HASH(K || H || K1 || K2 || ... || Kn-1)\n\t * Key = K1 || K2 || ... || Kn\n\t */\n\tfor (have = mdsz; need > have; have += mdsz) {\n\t\tif ((hashctx = ssh_digest_start(kex->hash_alg)) == NULL ||\n\t\t    ssh_digest_update_buffer(hashctx, shared_secret) != 0 ||\n\t\t    ssh_digest_update(hashctx, hash, hashlen) != 0 ||\n\t\t    ssh_digest_update(hashctx, digest, have) != 0 ||\n\t\t    ssh_digest_final(hashctx, digest + have, mdsz) != 0) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tssh_digest_free(hashctx);\n\t\thashctx = NULL;\n\t}\n#ifdef DEBUG_KEX\n\tfprintf(stderr, \"key '%c'== \", c);\n\tdump_digest(\"key\", digest, need);\n#endif\n\t*keyp = digest;\n\tdigest = NULL;\n\tr = 0;\n out:\n\tfree(digest);\n\tssh_digest_free(hashctx);\n\treturn r;\n}\n\n#define NKEYS\t6\nint\nkex_derive_keys(struct ssh *ssh, u_char *hash, u_int hashlen,\n    const struct sshbuf *shared_secret)\n{\n\tstruct kex *kex = ssh->kex;\n\tu_char *keys[NKEYS];\n\tu_int i, j, mode, ctos;\n\tint r;\n\n\tfor (i = 0; i < NKEYS; i++) {\n\t\tif ((r = derive_key(ssh, 'A'+i, kex->we_need, hash, hashlen,\n\t\t    shared_secret, &keys[i])) != 0) {\n\t\t\tfor (j = 0; j < i; j++)\n\t\t\t\tfree(keys[j]);\n\t\t\treturn r;\n\t\t}\n\t}\n\tfor (mode = 0; mode < MODE_MAX; mode++) {\n\t\tctos = (!kex->server && mode == MODE_OUT) ||\n\t\t    (kex->server && mode == MODE_IN);\n\t\tkex->newkeys[mode]->enc.iv  = keys[ctos ? 0 : 1];\n\t\tkex->newkeys[mode]->enc.key = keys[ctos ? 2 : 3];\n\t\tkex->newkeys[mode]->mac.key = keys[ctos ? 4 : 5];\n\t}\n\treturn 0;\n}\n\n#ifdef WITH_OPENSSL\nint\nkex_derive_keys_bn(struct ssh *ssh, u_char *hash, u_int hashlen,\n    const BIGNUM *secret)\n{\n\tstruct sshbuf *shared_secret;\n\tint r;\n\n\tif ((shared_secret = sshbuf_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((r = sshbuf_put_bignum2(shared_secret, secret)) == 0)\n\t\tr = kex_derive_keys(ssh, hash, hashlen, shared_secret);\n\tsshbuf_free(shared_secret);\n\treturn r;\n}\n#endif\n\n#ifdef WITH_SSH1\nint\nderive_ssh1_session_id(BIGNUM *host_modulus, BIGNUM *server_modulus,\n    u_int8_t cookie[8], u_int8_t id[16])\n{\n\tu_int8_t hbuf[2048], sbuf[2048], obuf[SSH_DIGEST_MAX_LENGTH];\n\tstruct ssh_digest_ctx *hashctx = NULL;\n\tsize_t hlen, slen;\n\tint r;\n\n\thlen = BN_num_bytes(host_modulus);\n\tslen = BN_num_bytes(server_modulus);\n\tif (hlen < (512 / 8) || (u_int)hlen > sizeof(hbuf) ||\n\t    slen < (512 / 8) || (u_int)slen > sizeof(sbuf))\n\t\treturn SSH_ERR_KEY_BITS_MISMATCH;\n\tif (BN_bn2bin(host_modulus, hbuf) <= 0 ||\n\t    BN_bn2bin(server_modulus, sbuf) <= 0) {\n\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\tif ((hashctx = ssh_digest_start(SSH_DIGEST_MD5)) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif (ssh_digest_update(hashctx, hbuf, hlen) != 0 ||\n\t    ssh_digest_update(hashctx, sbuf, slen) != 0 ||\n\t    ssh_digest_update(hashctx, cookie, 8) != 0 ||\n\t    ssh_digest_final(hashctx, obuf, sizeof(obuf)) != 0) {\n\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\tmemcpy(id, obuf, ssh_digest_bytes(SSH_DIGEST_MD5));\n\tr = 0;\n out:\n\tssh_digest_free(hashctx);\n\texplicit_bzero(hbuf, sizeof(hbuf));\n\texplicit_bzero(sbuf, sizeof(sbuf));\n\texplicit_bzero(obuf, sizeof(obuf));\n\treturn r;\n}\n#endif\n\n#if defined(DEBUG_KEX) || defined(DEBUG_KEXDH) || defined(DEBUG_KEXECDH)\nvoid\ndump_digest(char *msg, u_char *digest, int len)\n{\n\tfprintf(stderr, \"%s\\n\", msg);\n\tsshbuf_dump_data(digest, len, stderr);\n}\n#endif\n"], "fixing_code": ["/* $OpenBSD: kex.c,v 1.127 2016/10/10 19:28:48 markus Exp $ */\n/*\n * Copyright (c) 2000, 2001 Markus Friedl.  All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,\n * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"includes.h\"\n\n\n#include <signal.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#ifdef WITH_OPENSSL\n#include <openssl/crypto.h>\n#include <openssl/dh.h>\n#endif\n\n#include \"ssh2.h\"\n#include \"packet.h\"\n#include \"compat.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"kex.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"dispatch.h\"\n#include \"monitor.h\"\n\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"digest.h\"\n\n#if OPENSSL_VERSION_NUMBER >= 0x00907000L\n# if defined(HAVE_EVP_SHA256)\n# define evp_ssh_sha256 EVP_sha256\n# else\nextern const EVP_MD *evp_ssh_sha256(void);\n# endif\n#endif\n\n/* prototype */\nstatic int kex_choose_conf(struct ssh *);\nstatic int kex_input_newkeys(int, u_int32_t, void *);\n\nstatic const char *proposal_names[PROPOSAL_MAX] = {\n\t\"KEX algorithms\",\n\t\"host key algorithms\",\n\t\"ciphers ctos\",\n\t\"ciphers stoc\",\n\t\"MACs ctos\",\n\t\"MACs stoc\",\n\t\"compression ctos\",\n\t\"compression stoc\",\n\t\"languages ctos\",\n\t\"languages stoc\",\n};\n\nstruct kexalg {\n\tchar *name;\n\tu_int type;\n\tint ec_nid;\n\tint hash_alg;\n};\nstatic const struct kexalg kexalgs[] = {\n#ifdef WITH_OPENSSL\n\t{ KEX_DH1, KEX_DH_GRP1_SHA1, 0, SSH_DIGEST_SHA1 },\n\t{ KEX_DH14_SHA1, KEX_DH_GRP14_SHA1, 0, SSH_DIGEST_SHA1 },\n\t{ KEX_DH14_SHA256, KEX_DH_GRP14_SHA256, 0, SSH_DIGEST_SHA256 },\n\t{ KEX_DH16_SHA512, KEX_DH_GRP16_SHA512, 0, SSH_DIGEST_SHA512 },\n\t{ KEX_DH18_SHA512, KEX_DH_GRP18_SHA512, 0, SSH_DIGEST_SHA512 },\n\t{ KEX_DHGEX_SHA1, KEX_DH_GEX_SHA1, 0, SSH_DIGEST_SHA1 },\n#ifdef HAVE_EVP_SHA256\n\t{ KEX_DHGEX_SHA256, KEX_DH_GEX_SHA256, 0, SSH_DIGEST_SHA256 },\n#endif /* HAVE_EVP_SHA256 */\n#ifdef OPENSSL_HAS_ECC\n\t{ KEX_ECDH_SHA2_NISTP256, KEX_ECDH_SHA2,\n\t    NID_X9_62_prime256v1, SSH_DIGEST_SHA256 },\n\t{ KEX_ECDH_SHA2_NISTP384, KEX_ECDH_SHA2, NID_secp384r1,\n\t    SSH_DIGEST_SHA384 },\n# ifdef OPENSSL_HAS_NISTP521\n\t{ KEX_ECDH_SHA2_NISTP521, KEX_ECDH_SHA2, NID_secp521r1,\n\t    SSH_DIGEST_SHA512 },\n# endif /* OPENSSL_HAS_NISTP521 */\n#endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n#if defined(HAVE_EVP_SHA256) || !defined(WITH_OPENSSL)\n\t{ KEX_CURVE25519_SHA256, KEX_C25519_SHA256, 0, SSH_DIGEST_SHA256 },\n\t{ KEX_CURVE25519_SHA256_OLD, KEX_C25519_SHA256, 0, SSH_DIGEST_SHA256 },\n#endif /* HAVE_EVP_SHA256 || !WITH_OPENSSL */\n\t{ NULL, -1, -1, -1},\n};\n\nchar *\nkex_alg_list(char sep)\n{\n\tchar *ret = NULL, *tmp;\n\tsize_t nlen, rlen = 0;\n\tconst struct kexalg *k;\n\n\tfor (k = kexalgs; k->name != NULL; k++) {\n\t\tif (ret != NULL)\n\t\t\tret[rlen++] = sep;\n\t\tnlen = strlen(k->name);\n\t\tif ((tmp = realloc(ret, rlen + nlen + 2)) == NULL) {\n\t\t\tfree(ret);\n\t\t\treturn NULL;\n\t\t}\n\t\tret = tmp;\n\t\tmemcpy(ret + rlen, k->name, nlen + 1);\n\t\trlen += nlen;\n\t}\n\treturn ret;\n}\n\nstatic const struct kexalg *\nkex_alg_by_name(const char *name)\n{\n\tconst struct kexalg *k;\n\n\tfor (k = kexalgs; k->name != NULL; k++) {\n\t\tif (strcmp(k->name, name) == 0)\n\t\t\treturn k;\n\t}\n\treturn NULL;\n}\n\n/* Validate KEX method name list */\nint\nkex_names_valid(const char *names)\n{\n\tchar *s, *cp, *p;\n\n\tif (names == NULL || strcmp(names, \"\") == 0)\n\t\treturn 0;\n\tif ((s = cp = strdup(names)) == NULL)\n\t\treturn 0;\n\tfor ((p = strsep(&cp, \",\")); p && *p != '\\0';\n\t    (p = strsep(&cp, \",\"))) {\n\t\tif (kex_alg_by_name(p) == NULL) {\n\t\t\terror(\"Unsupported KEX algorithm \\\"%.100s\\\"\", p);\n\t\t\tfree(s);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tdebug3(\"kex names ok: [%s]\", names);\n\tfree(s);\n\treturn 1;\n}\n\n/*\n * Concatenate algorithm names, avoiding duplicates in the process.\n * Caller must free returned string.\n */\nchar *\nkex_names_cat(const char *a, const char *b)\n{\n\tchar *ret = NULL, *tmp = NULL, *cp, *p;\n\tsize_t len;\n\n\tif (a == NULL || *a == '\\0')\n\t\treturn NULL;\n\tif (b == NULL || *b == '\\0')\n\t\treturn strdup(a);\n\tif (strlen(b) > 1024*1024)\n\t\treturn NULL;\n\tlen = strlen(a) + strlen(b) + 2;\n\tif ((tmp = cp = strdup(b)) == NULL ||\n\t    (ret = calloc(1, len)) == NULL) {\n\t\tfree(tmp);\n\t\treturn NULL;\n\t}\n\tstrlcpy(ret, a, len);\n\tfor ((p = strsep(&cp, \",\")); p && *p != '\\0'; (p = strsep(&cp, \",\"))) {\n\t\tif (match_list(ret, p, NULL) != NULL)\n\t\t\tcontinue; /* Algorithm already present */\n\t\tif (strlcat(ret, \",\", len) >= len ||\n\t\t    strlcat(ret, p, len) >= len) {\n\t\t\tfree(tmp);\n\t\t\tfree(ret);\n\t\t\treturn NULL; /* Shouldn't happen */\n\t\t}\n\t}\n\tfree(tmp);\n\treturn ret;\n}\n\n/*\n * Assemble a list of algorithms from a default list and a string from a\n * configuration file. The user-provided string may begin with '+' to\n * indicate that it should be appended to the default.\n */\nint\nkex_assemble_names(const char *def, char **list)\n{\n\tchar *ret;\n\n\tif (list == NULL || *list == NULL || **list == '\\0') {\n\t\t*list = strdup(def);\n\t\treturn 0;\n\t}\n\tif (**list != '+') {\n\t\treturn 0;\n\t}\n\n\tif ((ret = kex_names_cat(def, *list + 1)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tfree(*list);\n\t*list = ret;\n\treturn 0;\n}\n\n/* put algorithm proposal into buffer */\nint\nkex_prop2buf(struct sshbuf *b, char *proposal[PROPOSAL_MAX])\n{\n\tu_int i;\n\tint r;\n\n\tsshbuf_reset(b);\n\n\t/*\n\t * add a dummy cookie, the cookie will be overwritten by\n\t * kex_send_kexinit(), each time a kexinit is set\n\t */\n\tfor (i = 0; i < KEX_COOKIE_LEN; i++) {\n\t\tif ((r = sshbuf_put_u8(b, 0)) != 0)\n\t\t\treturn r;\n\t}\n\tfor (i = 0; i < PROPOSAL_MAX; i++) {\n\t\tif ((r = sshbuf_put_cstring(b, proposal[i])) != 0)\n\t\t\treturn r;\n\t}\n\tif ((r = sshbuf_put_u8(b, 0)) != 0 ||\t/* first_kex_packet_follows */\n\t    (r = sshbuf_put_u32(b, 0)) != 0)\t/* uint32 reserved */\n\t\treturn r;\n\treturn 0;\n}\n\n/* parse buffer and return algorithm proposal */\nint\nkex_buf2prop(struct sshbuf *raw, int *first_kex_follows, char ***propp)\n{\n\tstruct sshbuf *b = NULL;\n\tu_char v;\n\tu_int i;\n\tchar **proposal = NULL;\n\tint r;\n\n\t*propp = NULL;\n\tif ((proposal = calloc(PROPOSAL_MAX, sizeof(char *))) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((b = sshbuf_fromb(raw)) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif ((r = sshbuf_consume(b, KEX_COOKIE_LEN)) != 0) /* skip cookie */\n\t\tgoto out;\n\t/* extract kex init proposal strings */\n\tfor (i = 0; i < PROPOSAL_MAX; i++) {\n\t\tif ((r = sshbuf_get_cstring(b, &(proposal[i]), NULL)) != 0)\n\t\t\tgoto out;\n\t\tdebug2(\"%s: %s\", proposal_names[i], proposal[i]);\n\t}\n\t/* first kex follows / reserved */\n\tif ((r = sshbuf_get_u8(b, &v)) != 0 ||\t/* first_kex_follows */\n\t    (r = sshbuf_get_u32(b, &i)) != 0)\t/* reserved */\n\t\tgoto out;\n\tif (first_kex_follows != NULL)\n\t\t*first_kex_follows = v;\n\tdebug2(\"first_kex_follows %d \", v);\n\tdebug2(\"reserved %u \", i);\n\tr = 0;\n\t*propp = proposal;\n out:\n\tif (r != 0 && proposal != NULL)\n\t\tkex_prop_free(proposal);\n\tsshbuf_free(b);\n\treturn r;\n}\n\nvoid\nkex_prop_free(char **proposal)\n{\n\tu_int i;\n\n\tif (proposal == NULL)\n\t\treturn;\n\tfor (i = 0; i < PROPOSAL_MAX; i++)\n\t\tfree(proposal[i]);\n\tfree(proposal);\n}\n\n/* ARGSUSED */\nstatic int\nkex_protocol_error(int type, u_int32_t seq, void *ctxt)\n{\n\tstruct ssh *ssh = active_state; /* XXX */\n\tint r;\n\n\terror(\"kex protocol error: type %d seq %u\", type, seq);\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_UNIMPLEMENTED)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, seq)) != 0 ||\n\t    (r = sshpkt_send(ssh)) != 0)\n\t\treturn r;\n\treturn 0;\n}\n\nstatic void\nkex_reset_dispatch(struct ssh *ssh)\n{\n\tssh_dispatch_range(ssh, SSH2_MSG_TRANSPORT_MIN,\n\t    SSH2_MSG_TRANSPORT_MAX, &kex_protocol_error);\n\tssh_dispatch_set(ssh, SSH2_MSG_KEXINIT, &kex_input_kexinit);\n}\n\nstatic int\nkex_send_ext_info(struct ssh *ssh)\n{\n\tint r;\n\tchar *algs;\n\n\tif ((algs = sshkey_alg_list(0, 1, ',')) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_EXT_INFO)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, 1)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, \"server-sig-algs\")) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, algs)) != 0 ||\n\t    (r = sshpkt_send(ssh)) != 0)\n\t\tgoto out;\n\t/* success */\n\tr = 0;\n out:\n\tfree(algs);\n\treturn r;\n}\n\nint\nkex_send_newkeys(struct ssh *ssh)\n{\n\tint r;\n\n\tkex_reset_dispatch(ssh);\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_NEWKEYS)) != 0 ||\n\t    (r = sshpkt_send(ssh)) != 0)\n\t\treturn r;\n\tdebug(\"SSH2_MSG_NEWKEYS sent\");\n\tdebug(\"expecting SSH2_MSG_NEWKEYS\");\n\tssh_dispatch_set(ssh, SSH2_MSG_NEWKEYS, &kex_input_newkeys);\n\tif (ssh->kex->ext_info_c)\n\t\tif ((r = kex_send_ext_info(ssh)) != 0)\n\t\t\treturn r;\n\treturn 0;\n}\n\nint\nkex_input_ext_info(int type, u_int32_t seq, void *ctxt)\n{\n\tstruct ssh *ssh = ctxt;\n\tstruct kex *kex = ssh->kex;\n\tu_int32_t i, ninfo;\n\tchar *name, *val, *found;\n\tint r;\n\n\tdebug(\"SSH2_MSG_EXT_INFO received\");\n\tssh_dispatch_set(ssh, SSH2_MSG_EXT_INFO, &kex_protocol_error);\n\tif ((r = sshpkt_get_u32(ssh, &ninfo)) != 0)\n\t\treturn r;\n\tfor (i = 0; i < ninfo; i++) {\n\t\tif ((r = sshpkt_get_cstring(ssh, &name, NULL)) != 0)\n\t\t\treturn r;\n\t\tif ((r = sshpkt_get_cstring(ssh, &val, NULL)) != 0) {\n\t\t\tfree(name);\n\t\t\treturn r;\n\t\t}\n\t\tdebug(\"%s: %s=<%s>\", __func__, name, val);\n\t\tif (strcmp(name, \"server-sig-algs\") == 0) {\n\t\t\tfound = match_list(\"rsa-sha2-256\", val, NULL);\n\t\t\tif (found) {\n\t\t\t\tkex->rsa_sha2 = 256;\n\t\t\t\tfree(found);\n\t\t\t}\n\t\t\tfound = match_list(\"rsa-sha2-512\", val, NULL);\n\t\t\tif (found) {\n\t\t\t\tkex->rsa_sha2 = 512;\n\t\t\t\tfree(found);\n\t\t\t}\n\t\t}\n\t\tfree(name);\n\t\tfree(val);\n\t}\n\treturn sshpkt_get_end(ssh);\n}\n\nstatic int\nkex_input_newkeys(int type, u_int32_t seq, void *ctxt)\n{\n\tstruct ssh *ssh = ctxt;\n\tstruct kex *kex = ssh->kex;\n\tint r;\n\n\tdebug(\"SSH2_MSG_NEWKEYS received\");\n\tssh_dispatch_set(ssh, SSH2_MSG_NEWKEYS, &kex_protocol_error);\n\tif ((r = sshpkt_get_end(ssh)) != 0)\n\t\treturn r;\n\tif ((r = ssh_set_newkeys(ssh, MODE_IN)) != 0)\n\t\treturn r;\n\tkex->done = 1;\n\tsshbuf_reset(kex->peer);\n\t/* sshbuf_reset(kex->my); */\n\tkex->flags &= ~KEX_INIT_SENT;\n\tfree(kex->name);\n\tkex->name = NULL;\n\treturn 0;\n}\n\nint\nkex_send_kexinit(struct ssh *ssh)\n{\n\tu_char *cookie;\n\tstruct kex *kex = ssh->kex;\n\tint r;\n\n\tif (kex == NULL)\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\tif (kex->flags & KEX_INIT_SENT)\n\t\treturn 0;\n\tkex->done = 0;\n\n\t/* generate a random cookie */\n\tif (sshbuf_len(kex->my) < KEX_COOKIE_LEN)\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\tif ((cookie = sshbuf_mutable_ptr(kex->my)) == NULL)\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\tarc4random_buf(cookie, KEX_COOKIE_LEN);\n\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_KEXINIT)) != 0 ||\n\t    (r = sshpkt_putb(ssh, kex->my)) != 0 ||\n\t    (r = sshpkt_send(ssh)) != 0)\n\t\treturn r;\n\tdebug(\"SSH2_MSG_KEXINIT sent\");\n\tkex->flags |= KEX_INIT_SENT;\n\treturn 0;\n}\n\n/* ARGSUSED */\nint\nkex_input_kexinit(int type, u_int32_t seq, void *ctxt)\n{\n\tstruct ssh *ssh = ctxt;\n\tstruct kex *kex = ssh->kex;\n\tconst u_char *ptr;\n\tu_int i;\n\tsize_t dlen;\n\tint r;\n\n\tdebug(\"SSH2_MSG_KEXINIT received\");\n\tif (kex == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\n\tssh_dispatch_set(ssh, SSH2_MSG_KEXINIT, NULL);\n\tptr = sshpkt_ptr(ssh, &dlen);\n\tif ((r = sshbuf_put(kex->peer, ptr, dlen)) != 0)\n\t\treturn r;\n\n\t/* discard packet */\n\tfor (i = 0; i < KEX_COOKIE_LEN; i++)\n\t\tif ((r = sshpkt_get_u8(ssh, NULL)) != 0)\n\t\t\treturn r;\n\tfor (i = 0; i < PROPOSAL_MAX; i++)\n\t\tif ((r = sshpkt_get_string(ssh, NULL, NULL)) != 0)\n\t\t\treturn r;\n\t/*\n\t * XXX RFC4253 sec 7: \"each side MAY guess\" - currently no supported\n\t * KEX method has the server move first, but a server might be using\n\t * a custom method or one that we otherwise don't support. We should\n\t * be prepared to remember first_kex_follows here so we can eat a\n\t * packet later.\n\t * XXX2 - RFC4253 is kind of ambiguous on what first_kex_follows means\n\t * for cases where the server *doesn't* go first. I guess we should\n\t * ignore it when it is set for these cases, which is what we do now.\n\t */\n\tif ((r = sshpkt_get_u8(ssh, NULL)) != 0 ||\t/* first_kex_follows */\n\t    (r = sshpkt_get_u32(ssh, NULL)) != 0 ||\t/* reserved */\n\t    (r = sshpkt_get_end(ssh)) != 0)\n\t\t\treturn r;\n\n\tif (!(kex->flags & KEX_INIT_SENT))\n\t\tif ((r = kex_send_kexinit(ssh)) != 0)\n\t\t\treturn r;\n\tif ((r = kex_choose_conf(ssh)) != 0)\n\t\treturn r;\n\n\tif (kex->kex_type < KEX_MAX && kex->kex[kex->kex_type] != NULL)\n\t\treturn (kex->kex[kex->kex_type])(ssh);\n\n\treturn SSH_ERR_INTERNAL_ERROR;\n}\n\nint\nkex_new(struct ssh *ssh, char *proposal[PROPOSAL_MAX], struct kex **kexp)\n{\n\tstruct kex *kex;\n\tint r;\n\n\t*kexp = NULL;\n\tif ((kex = calloc(1, sizeof(*kex))) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((kex->peer = sshbuf_new()) == NULL ||\n\t    (kex->my = sshbuf_new()) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif ((r = kex_prop2buf(kex->my, proposal)) != 0)\n\t\tgoto out;\n\tkex->done = 0;\n\tkex_reset_dispatch(ssh);\n\tr = 0;\n\t*kexp = kex;\n out:\n\tif (r != 0)\n\t\tkex_free(kex);\n\treturn r;\n}\n\nvoid\nkex_free_newkeys(struct newkeys *newkeys)\n{\n\tif (newkeys == NULL)\n\t\treturn;\n\tif (newkeys->enc.key) {\n\t\texplicit_bzero(newkeys->enc.key, newkeys->enc.key_len);\n\t\tfree(newkeys->enc.key);\n\t\tnewkeys->enc.key = NULL;\n\t}\n\tif (newkeys->enc.iv) {\n\t\texplicit_bzero(newkeys->enc.iv, newkeys->enc.iv_len);\n\t\tfree(newkeys->enc.iv);\n\t\tnewkeys->enc.iv = NULL;\n\t}\n\tfree(newkeys->enc.name);\n\texplicit_bzero(&newkeys->enc, sizeof(newkeys->enc));\n\tfree(newkeys->comp.name);\n\texplicit_bzero(&newkeys->comp, sizeof(newkeys->comp));\n\tmac_clear(&newkeys->mac);\n\tif (newkeys->mac.key) {\n\t\texplicit_bzero(newkeys->mac.key, newkeys->mac.key_len);\n\t\tfree(newkeys->mac.key);\n\t\tnewkeys->mac.key = NULL;\n\t}\n\tfree(newkeys->mac.name);\n\texplicit_bzero(&newkeys->mac, sizeof(newkeys->mac));\n\texplicit_bzero(newkeys, sizeof(*newkeys));\n\tfree(newkeys);\n}\n\nvoid\nkex_free(struct kex *kex)\n{\n\tu_int mode;\n\n#ifdef WITH_OPENSSL\n\tif (kex->dh)\n\t\tDH_free(kex->dh);\n#ifdef OPENSSL_HAS_ECC\n\tif (kex->ec_client_key)\n\t\tEC_KEY_free(kex->ec_client_key);\n#endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tfor (mode = 0; mode < MODE_MAX; mode++) {\n\t\tkex_free_newkeys(kex->newkeys[mode]);\n\t\tkex->newkeys[mode] = NULL;\n\t}\n\tsshbuf_free(kex->peer);\n\tsshbuf_free(kex->my);\n\tfree(kex->session_id);\n\tfree(kex->client_version_string);\n\tfree(kex->server_version_string);\n\tfree(kex->failed_choice);\n\tfree(kex->hostkey_alg);\n\tfree(kex->name);\n\tfree(kex);\n}\n\nint\nkex_setup(struct ssh *ssh, char *proposal[PROPOSAL_MAX])\n{\n\tint r;\n\n\tif ((r = kex_new(ssh, proposal, &ssh->kex)) != 0)\n\t\treturn r;\n\tif ((r = kex_send_kexinit(ssh)) != 0) {\t\t/* we start */\n\t\tkex_free(ssh->kex);\n\t\tssh->kex = NULL;\n\t\treturn r;\n\t}\n\treturn 0;\n}\n\n/*\n * Request key re-exchange, returns 0 on success or a ssherr.h error\n * code otherwise. Must not be called if KEX is incomplete or in-progress.\n */\nint\nkex_start_rekex(struct ssh *ssh)\n{\n\tif (ssh->kex == NULL) {\n\t\terror(\"%s: no kex\", __func__);\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\tif (ssh->kex->done == 0) {\n\t\terror(\"%s: requested twice\", __func__);\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\tssh->kex->done = 0;\n\treturn kex_send_kexinit(ssh);\n}\n\nstatic int\nchoose_enc(struct sshenc *enc, char *client, char *server)\n{\n\tchar *name = match_list(client, server, NULL);\n\n\tif (name == NULL)\n\t\treturn SSH_ERR_NO_CIPHER_ALG_MATCH;\n\tif ((enc->cipher = cipher_by_name(name)) == NULL)\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\tenc->name = name;\n\tenc->enabled = 0;\n\tenc->iv = NULL;\n\tenc->iv_len = cipher_ivlen(enc->cipher);\n\tenc->key = NULL;\n\tenc->key_len = cipher_keylen(enc->cipher);\n\tenc->block_size = cipher_blocksize(enc->cipher);\n\treturn 0;\n}\n\nstatic int\nchoose_mac(struct ssh *ssh, struct sshmac *mac, char *client, char *server)\n{\n\tchar *name = match_list(client, server, NULL);\n\n\tif (name == NULL)\n\t\treturn SSH_ERR_NO_MAC_ALG_MATCH;\n\tif (mac_setup(mac, name) < 0)\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t/* truncate the key */\n\tif (ssh->compat & SSH_BUG_HMAC)\n\t\tmac->key_len = 16;\n\tmac->name = name;\n\tmac->key = NULL;\n\tmac->enabled = 0;\n\treturn 0;\n}\n\nstatic int\nchoose_comp(struct sshcomp *comp, char *client, char *server)\n{\n\tchar *name = match_list(client, server, NULL);\n\n\tif (name == NULL)\n\t\treturn SSH_ERR_NO_COMPRESS_ALG_MATCH;\n\tif (strcmp(name, \"zlib@openssh.com\") == 0) {\n\t\tcomp->type = COMP_DELAYED;\n\t} else if (strcmp(name, \"zlib\") == 0) {\n\t\tcomp->type = COMP_ZLIB;\n\t} else if (strcmp(name, \"none\") == 0) {\n\t\tcomp->type = COMP_NONE;\n\t} else {\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\tcomp->name = name;\n\treturn 0;\n}\n\nstatic int\nchoose_kex(struct kex *k, char *client, char *server)\n{\n\tconst struct kexalg *kexalg;\n\n\tk->name = match_list(client, server, NULL);\n\n\tdebug(\"kex: algorithm: %s\", k->name ? k->name : \"(no match)\");\n\tif (k->name == NULL)\n\t\treturn SSH_ERR_NO_KEX_ALG_MATCH;\n\tif ((kexalg = kex_alg_by_name(k->name)) == NULL)\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\tk->kex_type = kexalg->type;\n\tk->hash_alg = kexalg->hash_alg;\n\tk->ec_nid = kexalg->ec_nid;\n\treturn 0;\n}\n\nstatic int\nchoose_hostkeyalg(struct kex *k, char *client, char *server)\n{\n\tk->hostkey_alg = match_list(client, server, NULL);\n\n\tdebug(\"kex: host key algorithm: %s\",\n\t    k->hostkey_alg ? k->hostkey_alg : \"(no match)\");\n\tif (k->hostkey_alg == NULL)\n\t\treturn SSH_ERR_NO_HOSTKEY_ALG_MATCH;\n\tk->hostkey_type = sshkey_type_from_name(k->hostkey_alg);\n\tif (k->hostkey_type == KEY_UNSPEC)\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\tk->hostkey_nid = sshkey_ecdsa_nid_from_name(k->hostkey_alg);\n\treturn 0;\n}\n\nstatic int\nproposals_match(char *my[PROPOSAL_MAX], char *peer[PROPOSAL_MAX])\n{\n\tstatic int check[] = {\n\t\tPROPOSAL_KEX_ALGS, PROPOSAL_SERVER_HOST_KEY_ALGS, -1\n\t};\n\tint *idx;\n\tchar *p;\n\n\tfor (idx = &check[0]; *idx != -1; idx++) {\n\t\tif ((p = strchr(my[*idx], ',')) != NULL)\n\t\t\t*p = '\\0';\n\t\tif ((p = strchr(peer[*idx], ',')) != NULL)\n\t\t\t*p = '\\0';\n\t\tif (strcmp(my[*idx], peer[*idx]) != 0) {\n\t\t\tdebug2(\"proposal mismatch: my %s peer %s\",\n\t\t\t    my[*idx], peer[*idx]);\n\t\t\treturn (0);\n\t\t}\n\t}\n\tdebug2(\"proposals match\");\n\treturn (1);\n}\n\nstatic int\nkex_choose_conf(struct ssh *ssh)\n{\n\tstruct kex *kex = ssh->kex;\n\tstruct newkeys *newkeys;\n\tchar **my = NULL, **peer = NULL;\n\tchar **cprop, **sprop;\n\tint nenc, nmac, ncomp;\n\tu_int mode, ctos, need, dh_need, authlen;\n\tint r, first_kex_follows;\n\n\tdebug2(\"local %s KEXINIT proposal\", kex->server ? \"server\" : \"client\");\n\tif ((r = kex_buf2prop(kex->my, NULL, &my)) != 0)\n\t\tgoto out;\n\tdebug2(\"peer %s KEXINIT proposal\", kex->server ? \"client\" : \"server\");\n\tif ((r = kex_buf2prop(kex->peer, &first_kex_follows, &peer)) != 0)\n\t\tgoto out;\n\n\tif (kex->server) {\n\t\tcprop=peer;\n\t\tsprop=my;\n\t} else {\n\t\tcprop=my;\n\t\tsprop=peer;\n\t}\n\n\t/* Check whether client supports ext_info_c */\n\tif (kex->server) {\n\t\tchar *ext;\n\n\t\text = match_list(\"ext-info-c\", peer[PROPOSAL_KEX_ALGS], NULL);\n\t\tkex->ext_info_c = (ext != NULL);\n\t\tfree(ext);\n\t}\n\n\t/* Algorithm Negotiation */\n\tif ((r = choose_kex(kex, cprop[PROPOSAL_KEX_ALGS],\n\t    sprop[PROPOSAL_KEX_ALGS])) != 0) {\n\t\tkex->failed_choice = peer[PROPOSAL_KEX_ALGS];\n\t\tpeer[PROPOSAL_KEX_ALGS] = NULL;\n\t\tgoto out;\n\t}\n\tif ((r = choose_hostkeyalg(kex, cprop[PROPOSAL_SERVER_HOST_KEY_ALGS],\n\t    sprop[PROPOSAL_SERVER_HOST_KEY_ALGS])) != 0) {\n\t\tkex->failed_choice = peer[PROPOSAL_SERVER_HOST_KEY_ALGS];\n\t\tpeer[PROPOSAL_SERVER_HOST_KEY_ALGS] = NULL;\n\t\tgoto out;\n\t}\n\tfor (mode = 0; mode < MODE_MAX; mode++) {\n\t\tif ((newkeys = calloc(1, sizeof(*newkeys))) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tkex->newkeys[mode] = newkeys;\n\t\tctos = (!kex->server && mode == MODE_OUT) ||\n\t\t    (kex->server && mode == MODE_IN);\n\t\tnenc  = ctos ? PROPOSAL_ENC_ALGS_CTOS  : PROPOSAL_ENC_ALGS_STOC;\n\t\tnmac  = ctos ? PROPOSAL_MAC_ALGS_CTOS  : PROPOSAL_MAC_ALGS_STOC;\n\t\tncomp = ctos ? PROPOSAL_COMP_ALGS_CTOS : PROPOSAL_COMP_ALGS_STOC;\n\t\tif ((r = choose_enc(&newkeys->enc, cprop[nenc],\n\t\t    sprop[nenc])) != 0) {\n\t\t\tkex->failed_choice = peer[nenc];\n\t\t\tpeer[nenc] = NULL;\n\t\t\tgoto out;\n\t\t}\n\t\tauthlen = cipher_authlen(newkeys->enc.cipher);\n\t\t/* ignore mac for authenticated encryption */\n\t\tif (authlen == 0 &&\n\t\t    (r = choose_mac(ssh, &newkeys->mac, cprop[nmac],\n\t\t    sprop[nmac])) != 0) {\n\t\t\tkex->failed_choice = peer[nmac];\n\t\t\tpeer[nmac] = NULL;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = choose_comp(&newkeys->comp, cprop[ncomp],\n\t\t    sprop[ncomp])) != 0) {\n\t\t\tkex->failed_choice = peer[ncomp];\n\t\t\tpeer[ncomp] = NULL;\n\t\t\tgoto out;\n\t\t}\n\t\tdebug(\"kex: %s cipher: %s MAC: %s compression: %s\",\n\t\t    ctos ? \"client->server\" : \"server->client\",\n\t\t    newkeys->enc.name,\n\t\t    authlen == 0 ? newkeys->mac.name : \"<implicit>\",\n\t\t    newkeys->comp.name);\n\t}\n\tneed = dh_need = 0;\n\tfor (mode = 0; mode < MODE_MAX; mode++) {\n\t\tnewkeys = kex->newkeys[mode];\n\t\tneed = MAXIMUM(need, newkeys->enc.key_len);\n\t\tneed = MAXIMUM(need, newkeys->enc.block_size);\n\t\tneed = MAXIMUM(need, newkeys->enc.iv_len);\n\t\tneed = MAXIMUM(need, newkeys->mac.key_len);\n\t\tdh_need = MAXIMUM(dh_need, cipher_seclen(newkeys->enc.cipher));\n\t\tdh_need = MAXIMUM(dh_need, newkeys->enc.block_size);\n\t\tdh_need = MAXIMUM(dh_need, newkeys->enc.iv_len);\n\t\tdh_need = MAXIMUM(dh_need, newkeys->mac.key_len);\n\t}\n\t/* XXX need runden? */\n\tkex->we_need = need;\n\tkex->dh_need = dh_need;\n\n\t/* ignore the next message if the proposals do not match */\n\tif (first_kex_follows && !proposals_match(my, peer) &&\n\t    !(ssh->compat & SSH_BUG_FIRSTKEX))\n\t\tssh->dispatch_skip_packets = 1;\n\tr = 0;\n out:\n\tkex_prop_free(my);\n\tkex_prop_free(peer);\n\treturn r;\n}\n\nstatic int\nderive_key(struct ssh *ssh, int id, u_int need, u_char *hash, u_int hashlen,\n    const struct sshbuf *shared_secret, u_char **keyp)\n{\n\tstruct kex *kex = ssh->kex;\n\tstruct ssh_digest_ctx *hashctx = NULL;\n\tchar c = id;\n\tu_int have;\n\tsize_t mdsz;\n\tu_char *digest;\n\tint r;\n\n\tif ((mdsz = ssh_digest_bytes(kex->hash_alg)) == 0)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif ((digest = calloc(1, ROUNDUP(need, mdsz))) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\n\t/* K1 = HASH(K || H || \"A\" || session_id) */\n\tif ((hashctx = ssh_digest_start(kex->hash_alg)) == NULL ||\n\t    ssh_digest_update_buffer(hashctx, shared_secret) != 0 ||\n\t    ssh_digest_update(hashctx, hash, hashlen) != 0 ||\n\t    ssh_digest_update(hashctx, &c, 1) != 0 ||\n\t    ssh_digest_update(hashctx, kex->session_id,\n\t    kex->session_id_len) != 0 ||\n\t    ssh_digest_final(hashctx, digest, mdsz) != 0) {\n\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\tssh_digest_free(hashctx);\n\thashctx = NULL;\n\n\t/*\n\t * expand key:\n\t * Kn = HASH(K || H || K1 || K2 || ... || Kn-1)\n\t * Key = K1 || K2 || ... || Kn\n\t */\n\tfor (have = mdsz; need > have; have += mdsz) {\n\t\tif ((hashctx = ssh_digest_start(kex->hash_alg)) == NULL ||\n\t\t    ssh_digest_update_buffer(hashctx, shared_secret) != 0 ||\n\t\t    ssh_digest_update(hashctx, hash, hashlen) != 0 ||\n\t\t    ssh_digest_update(hashctx, digest, have) != 0 ||\n\t\t    ssh_digest_final(hashctx, digest + have, mdsz) != 0) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tssh_digest_free(hashctx);\n\t\thashctx = NULL;\n\t}\n#ifdef DEBUG_KEX\n\tfprintf(stderr, \"key '%c'== \", c);\n\tdump_digest(\"key\", digest, need);\n#endif\n\t*keyp = digest;\n\tdigest = NULL;\n\tr = 0;\n out:\n\tfree(digest);\n\tssh_digest_free(hashctx);\n\treturn r;\n}\n\n#define NKEYS\t6\nint\nkex_derive_keys(struct ssh *ssh, u_char *hash, u_int hashlen,\n    const struct sshbuf *shared_secret)\n{\n\tstruct kex *kex = ssh->kex;\n\tu_char *keys[NKEYS];\n\tu_int i, j, mode, ctos;\n\tint r;\n\n\tfor (i = 0; i < NKEYS; i++) {\n\t\tif ((r = derive_key(ssh, 'A'+i, kex->we_need, hash, hashlen,\n\t\t    shared_secret, &keys[i])) != 0) {\n\t\t\tfor (j = 0; j < i; j++)\n\t\t\t\tfree(keys[j]);\n\t\t\treturn r;\n\t\t}\n\t}\n\tfor (mode = 0; mode < MODE_MAX; mode++) {\n\t\tctos = (!kex->server && mode == MODE_OUT) ||\n\t\t    (kex->server && mode == MODE_IN);\n\t\tkex->newkeys[mode]->enc.iv  = keys[ctos ? 0 : 1];\n\t\tkex->newkeys[mode]->enc.key = keys[ctos ? 2 : 3];\n\t\tkex->newkeys[mode]->mac.key = keys[ctos ? 4 : 5];\n\t}\n\treturn 0;\n}\n\n#ifdef WITH_OPENSSL\nint\nkex_derive_keys_bn(struct ssh *ssh, u_char *hash, u_int hashlen,\n    const BIGNUM *secret)\n{\n\tstruct sshbuf *shared_secret;\n\tint r;\n\n\tif ((shared_secret = sshbuf_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((r = sshbuf_put_bignum2(shared_secret, secret)) == 0)\n\t\tr = kex_derive_keys(ssh, hash, hashlen, shared_secret);\n\tsshbuf_free(shared_secret);\n\treturn r;\n}\n#endif\n\n#ifdef WITH_SSH1\nint\nderive_ssh1_session_id(BIGNUM *host_modulus, BIGNUM *server_modulus,\n    u_int8_t cookie[8], u_int8_t id[16])\n{\n\tu_int8_t hbuf[2048], sbuf[2048], obuf[SSH_DIGEST_MAX_LENGTH];\n\tstruct ssh_digest_ctx *hashctx = NULL;\n\tsize_t hlen, slen;\n\tint r;\n\n\thlen = BN_num_bytes(host_modulus);\n\tslen = BN_num_bytes(server_modulus);\n\tif (hlen < (512 / 8) || (u_int)hlen > sizeof(hbuf) ||\n\t    slen < (512 / 8) || (u_int)slen > sizeof(sbuf))\n\t\treturn SSH_ERR_KEY_BITS_MISMATCH;\n\tif (BN_bn2bin(host_modulus, hbuf) <= 0 ||\n\t    BN_bn2bin(server_modulus, sbuf) <= 0) {\n\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\tif ((hashctx = ssh_digest_start(SSH_DIGEST_MD5)) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif (ssh_digest_update(hashctx, hbuf, hlen) != 0 ||\n\t    ssh_digest_update(hashctx, sbuf, slen) != 0 ||\n\t    ssh_digest_update(hashctx, cookie, 8) != 0 ||\n\t    ssh_digest_final(hashctx, obuf, sizeof(obuf)) != 0) {\n\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\tmemcpy(id, obuf, ssh_digest_bytes(SSH_DIGEST_MD5));\n\tr = 0;\n out:\n\tssh_digest_free(hashctx);\n\texplicit_bzero(hbuf, sizeof(hbuf));\n\texplicit_bzero(sbuf, sizeof(sbuf));\n\texplicit_bzero(obuf, sizeof(obuf));\n\treturn r;\n}\n#endif\n\n#if defined(DEBUG_KEX) || defined(DEBUG_KEXDH) || defined(DEBUG_KEXECDH)\nvoid\ndump_digest(char *msg, u_char *digest, int len)\n{\n\tfprintf(stderr, \"%s\\n\", msg);\n\tsshbuf_dump_data(digest, len, stderr);\n}\n#endif\n"], "filenames": ["kex.c"], "buggy_code_start_loc": [1], "buggy_code_end_loc": [483], "fixing_code_start_loc": [1], "fixing_code_end_loc": [485], "type": "CWE-399", "message": "** DISPUTED ** The kex_input_kexinit function in kex.c in OpenSSH 6.x and 7.x through 7.3 allows remote attackers to cause a denial of service (memory consumption) by sending many duplicate KEXINIT requests.  NOTE: a third party reports that \"OpenSSH upstream does not consider this as a security issue.\"", "other": {"cve": {"id": "CVE-2016-8858", "sourceIdentifier": "cve@mitre.org", "published": "2016-12-09T11:59:00.207", "lastModified": "2022-12-13T12:15:23.850", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "** DISPUTED ** The kex_input_kexinit function in kex.c in OpenSSH 6.x and 7.x through 7.3 allows remote attackers to cause a denial of service (memory consumption) by sending many duplicate KEXINIT requests.  NOTE: a third party reports that \"OpenSSH upstream does not consider this as a security issue.\""}, {"lang": "es", "value": "** DISPUTADA ** La funci\u00f3n kex_input_kexinit en kex.c en OpenSSH 6.x y 7.x hasta la versi\u00f3n 7.3 permite a atacantes remotos provocar una denegaci\u00f3n de servicio (consumo de memoria) enviando muchas peticiones duplicadas KEXINIT. NOTA: un tercero reporta que \"OpenSSH upstream no considera esto como un problema de seguridad\"."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:C", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 7.8}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-399"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:openbsd:openssh:6.8:*:*:*:*:*:*:*", "matchCriteriaId": "65A8629A-CFAE-4403-BEE7-622912483702"}, {"vulnerable": true, "criteria": "cpe:2.3:a:openbsd:openssh:6.9:*:*:*:*:*:*:*", "matchCriteriaId": "D0607649-62FE-41CB-9444-53CD9C5B67C0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:openbsd:openssh:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "0B0FB8D5-75CB-4691-AB9F-B4FA46973421"}, {"vulnerable": true, "criteria": "cpe:2.3:a:openbsd:openssh:7.1:*:*:*:*:*:*:*", "matchCriteriaId": "67E1B240-BD86-41D3-BAC1-96005CB31DEE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:openbsd:openssh:7.2:*:*:*:*:*:*:*", "matchCriteriaId": "2FC2BA97-6E7A-4AEF-8944-DB3AB8E14762"}, {"vulnerable": true, "criteria": "cpe:2.3:a:openbsd:openssh:7.3:*:*:*:*:*:*:*", "matchCriteriaId": "F5D3A31E-D785-406D-A8C8-FD122F4C9E38"}]}]}], "references": [{"url": "http://cvsweb.openbsd.org/cgi-bin/cvsweb/src/usr.bin/ssh/kex.c.diff?r1=1.126&r2=1.127&f=h", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Vendor Advisory"]}, {"url": "http://cvsweb.openbsd.org/cgi-bin/cvsweb/src/usr.bin/ssh/kex.c?rev=1.127&content-type=text/x-cvsweb-markup", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Vendor Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2016/10/19/3", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2016/10/20/1", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/93776", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "http://www.securitytracker.com/id/1037057", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1384860", "source": "cve@mitre.org", "tags": ["Issue Tracking"]}, {"url": "https://cert-portal.siemens.com/productcert/pdf/ssa-412672.pdf", "source": "cve@mitre.org"}, {"url": "https://ftp.openbsd.org/pub/OpenBSD/patches/6.0/common/013_ssh_kexinit.patch.sig", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://github.com/openssh/openssh-portable/commit/ec165c392ca54317dbe3064a8c200de6531e89ad", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://security.FreeBSD.org/advisories/FreeBSD-SA-16:33.openssh.asc", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/201612-18", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20180201-0001/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/openssh/openssh-portable/commit/ec165c392ca54317dbe3064a8c200de6531e89ad"}}