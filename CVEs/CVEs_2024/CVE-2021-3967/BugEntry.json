{"buggy_code": ["import $ from \"jquery\";\n\nimport render_change_email_modal from \"../templates/change_email_modal.hbs\";\nimport render_confirm_deactivate_own_user from \"../templates/confirm_dialog/confirm_deactivate_own_user.hbs\";\nimport render_dialog_change_password from \"../templates/dialog_change_password.hbs\";\nimport render_settings_api_key_modal from \"../templates/settings/api_key_modal.hbs\";\nimport render_settings_custom_user_profile_field from \"../templates/settings/custom_user_profile_field.hbs\";\nimport render_settings_dev_env_email_access from \"../templates/settings/dev_env_email_access.hbs\";\n\nimport * as avatar from \"./avatar\";\nimport * as blueslip from \"./blueslip\";\nimport * as channel from \"./channel\";\nimport * as common from \"./common\";\nimport * as confirm_dialog from \"./confirm_dialog\";\nimport {csrf_token} from \"./csrf\";\nimport * as dialog_widget from \"./dialog_widget\";\nimport {$t_html} from \"./i18n\";\nimport * as overlays from \"./overlays\";\nimport {page_params} from \"./page_params\";\nimport * as people from \"./people\";\nimport * as pill_typeahead from \"./pill_typeahead\";\nimport * as settings_bots from \"./settings_bots\";\nimport * as settings_data from \"./settings_data\";\nimport * as settings_ui from \"./settings_ui\";\nimport * as ui_report from \"./ui_report\";\nimport * as user_pill from \"./user_pill\";\nimport * as user_profile from \"./user_profile\";\nimport {user_settings} from \"./user_settings\";\n\nlet password_quality; // Loaded asynchronously\n\nexport function update_email(new_email) {\n    const email_input = $(\"#change_email\");\n\n    if (email_input) {\n        email_input.text(new_email);\n    }\n}\n\nexport function update_full_name(new_full_name) {\n    // Arguably, this should work more like how the `update_email`\n    // flow works, where we update the name in the modal on open,\n    // rather than updating it here, but this works.\n    const full_name_input = $(\".full-name-change-form input[name='full_name']\");\n    if (full_name_input) {\n        full_name_input.val(new_full_name);\n    }\n}\n\nexport function update_name_change_display() {\n    if (!settings_data.user_can_change_name()) {\n        $(\"#full_name\").prop(\"disabled\", true);\n        $(\".change_name_tooltip\").show();\n    } else {\n        $(\"#full_name\").prop(\"disabled\", false);\n        $(\".change_name_tooltip\").hide();\n    }\n}\n\nexport function update_email_change_display() {\n    if (page_params.realm_email_changes_disabled && !page_params.is_admin) {\n        $(\"#change_email\").prop(\"disabled\", true);\n        $(\".change_email_tooltip\").show();\n    } else {\n        $(\"#change_email\").prop(\"disabled\", false);\n        $(\".change_email_tooltip\").hide();\n    }\n}\n\nexport function update_avatar_change_display() {\n    if (!settings_data.user_can_change_avatar()) {\n        // We disable this widget by simply hiding its edit UI.\n        $(\"#user-avatar-upload-widget .image_upload_button\").hide();\n        $(\".user-avatar-section .settings-info-icon\").show();\n    } else {\n        $(\"#user-avatar-upload-widget .image_upload_button\").show();\n        $(\".user-avatar-section .settings-info-icon\").hide();\n    }\n}\n\nfunction display_avatar_upload_complete() {\n    $(\"#user-avatar-upload-widget .upload-spinner-background\").css({visibility: \"hidden\"});\n    $(\"#user-avatar-upload-widget .image-upload-text\").show();\n    $(\"#user-avatar-upload-widget .image-delete-button\").show();\n}\n\nfunction display_avatar_upload_started() {\n    $(\"#user-avatar-source\").hide();\n    $(\"#user-avatar-upload-widget .upload-spinner-background\").css({visibility: \"visible\"});\n    $(\"#user-avatar-upload-widget .image-upload-text\").hide();\n    $(\"#user-avatar-upload-widget .image-delete-button\").hide();\n}\n\nfunction settings_change_error(message_html, xhr) {\n    ui_report.error(message_html, xhr, $(\"#account-settings-status\").expectOne());\n}\n\nfunction update_custom_profile_field(field, method) {\n    let field_id;\n    if (method === channel.del) {\n        field_id = field;\n    } else {\n        field_id = field.id;\n    }\n\n    const spinner_element = $(\n        `.custom_user_field[data-field-id=\"${CSS.escape(field_id)}\"] .custom-field-status`,\n    ).expectOne();\n    settings_ui.do_settings_change(\n        method,\n        \"/json/users/me/profile_data\",\n        {data: JSON.stringify([field])},\n        spinner_element,\n    );\n}\n\nfunction update_user_custom_profile_fields(fields, method) {\n    if (method === undefined) {\n        blueslip.error(\"Undefined method in update_user_custom_profile_fields\");\n    }\n\n    for (const field of fields) {\n        update_custom_profile_field(field, method);\n    }\n}\n\nexport function append_custom_profile_fields(element_id, user_id) {\n    const person = people.get_by_user_id(user_id);\n    if (person.is_bot) {\n        return;\n    }\n    const all_custom_fields = page_params.custom_profile_fields;\n    const all_field_types = page_params.custom_profile_field_types;\n\n    const all_field_template_types = new Map([\n        [all_field_types.LONG_TEXT.id, \"text\"],\n        [all_field_types.SHORT_TEXT.id, \"text\"],\n        [all_field_types.SELECT.id, \"select\"],\n        [all_field_types.USER.id, \"user\"],\n        [all_field_types.DATE.id, \"date\"],\n        [all_field_types.EXTERNAL_ACCOUNT.id, \"text\"],\n        [all_field_types.URL.id, \"url\"],\n    ]);\n\n    for (const field of all_custom_fields) {\n        let field_value = people.get_custom_profile_data(user_id, field.id);\n        const is_select_field = field.type === all_field_types.SELECT.id;\n        const field_choices = [];\n\n        if (field_value === undefined || field_value === null) {\n            field_value = {value: \"\", rendered_value: \"\"};\n        }\n        if (is_select_field) {\n            const field_choice_dict = JSON.parse(field.field_data);\n            for (const choice in field_choice_dict) {\n                if (choice) {\n                    field_choices[field_choice_dict[choice].order] = {\n                        value: choice,\n                        text: field_choice_dict[choice].text,\n                        selected: choice === field_value.value,\n                    };\n                }\n            }\n        }\n\n        const html = render_settings_custom_user_profile_field({\n            field,\n            field_type: all_field_template_types.get(field.type),\n            field_value,\n            is_long_text_field: field.type === all_field_types.LONG_TEXT.id,\n            is_user_field: field.type === all_field_types.USER.id,\n            is_date_field: field.type === all_field_types.DATE.id,\n            is_select_field,\n            field_choices,\n        });\n        $(element_id).append(html);\n    }\n}\n\nexport function initialize_custom_date_type_fields(element_id) {\n    $(element_id).find(\".custom_user_field .datepicker\").flatpickr({\n        altInput: true,\n        altFormat: \"F j, Y\",\n        allowInput: true,\n    });\n\n    $(element_id)\n        .find(\".custom_user_field .datepicker\")\n        .on(\"mouseenter\", function () {\n            if ($(this).val().length <= 0) {\n                $(this).parent().find(\".remove_date\").hide();\n            } else {\n                $(this).parent().find(\".remove_date\").show();\n            }\n        });\n\n    $(element_id)\n        .find(\".custom_user_field .remove_date\")\n        .on(\"click\", function () {\n            $(this).parent().find(\".custom_user_field_value\").val(\"\");\n        });\n}\n\nexport function initialize_custom_user_type_fields(\n    element_id,\n    user_id,\n    is_editable,\n    set_handler_on_update,\n) {\n    const field_types = page_params.custom_profile_field_types;\n    const user_pills = new Map();\n\n    const person = people.get_by_user_id(user_id);\n    if (person.is_bot) {\n        return user_pills;\n    }\n\n    for (const field of page_params.custom_profile_fields) {\n        let field_value_raw = people.get_custom_profile_data(user_id, field.id);\n\n        if (field_value_raw) {\n            field_value_raw = field_value_raw.value;\n        }\n\n        // If field is not editable and field value is null, we don't expect\n        // pill container for that field and proceed further\n        if (field.type === field_types.USER.id && (field_value_raw || is_editable)) {\n            const pill_container = $(element_id)\n                .find(`.custom_user_field[data-field-id=\"${CSS.escape(field.id)}\"] .pill-container`)\n                .expectOne();\n            const pills = user_pill.create_pills(pill_container);\n\n            function update_custom_user_field() {\n                const fields = [];\n                const user_ids = user_pill.get_user_ids(pills);\n                if (user_ids.length < 1) {\n                    fields.push(field.id);\n                    update_user_custom_profile_fields(fields, channel.del);\n                } else {\n                    fields.push({id: field.id, value: user_ids});\n                    update_user_custom_profile_fields(fields, channel.patch);\n                }\n            }\n\n            if (field_value_raw) {\n                const field_value = JSON.parse(field_value_raw);\n                if (field_value) {\n                    for (const pill_user_id of field_value) {\n                        const user = people.get_by_user_id(pill_user_id);\n                        user_pill.append_user(user, pills);\n                    }\n                }\n            }\n\n            if (is_editable) {\n                const input = pill_container.children(\".input\");\n                if (set_handler_on_update) {\n                    const opts = {update_func: update_custom_user_field, user: true};\n                    pill_typeahead.set_up(input, pills, opts);\n                    pills.onPillRemove(() => {\n                        update_custom_user_field();\n                    });\n                } else {\n                    pill_typeahead.set_up(input, pills, {user: true});\n                }\n            }\n            user_pills.set(field.id, pills);\n        }\n    }\n\n    return user_pills;\n}\n\nexport function add_custom_profile_fields_to_settings() {\n    if (!overlays.settings_open()) {\n        return;\n    }\n\n    const element_id = \"#profile-settings .custom-profile-fields-form\";\n    $(element_id).html(\"\");\n\n    append_custom_profile_fields(element_id, people.my_current_user_id());\n    initialize_custom_user_type_fields(element_id, people.my_current_user_id(), true, true);\n    initialize_custom_date_type_fields(element_id);\n}\n\nexport function hide_confirm_email_banner() {\n    if (!overlays.settings_open()) {\n        return;\n    }\n    $(\"#account-settings-status\").hide();\n}\n\nexport function set_up() {\n    // Add custom profile fields elements to user account settings.\n    add_custom_profile_fields_to_settings();\n    $(\"#account-settings-status\").hide();\n\n    const setup_api_key_modal = () => {\n        function request_api_key(data) {\n            channel.post({\n                url: \"/json/fetch_api_key\",\n                data,\n                success(data) {\n                    $(\"#get_api_key_password\").val(\"\");\n                    $(\"#api_key_value\").text(data.api_key);\n                    // The display property on the error bar is set to important\n                    // so instead of making display: none !important we just\n                    // remove it.\n                    $(\"#api_key_status\").remove();\n                    $(\"#password_confirmation\").hide();\n                    $(\"#get_api_key_button\").hide();\n                    $(\"#show_api_key\").show();\n                    $(\"#api_key_buttons\").show();\n                },\n                error(xhr) {\n                    ui_report.error(\n                        $t_html({defaultMessage: \"Error\"}),\n                        xhr,\n                        $(\"#api_key_status\").expectOne(),\n                    );\n                    $(\"#show_api_key\").hide();\n                },\n            });\n        }\n\n        $(\"#api_key_value\").text(\"\");\n        $(\"#show_api_key\").hide();\n        $(\"#api_key_buttons\").hide();\n        common.setup_password_visibility_toggle(\n            \"#get_api_key_password\",\n            \"#get_api_key_password + .password_visibility_toggle\",\n            {tippy_tooltips: true},\n        );\n\n        function do_get_api_key() {\n            $(\"#api_key_status\").hide();\n            const data = {};\n            data.password = $(\"#get_api_key_password\").val();\n            request_api_key(data);\n        }\n\n        if (page_params.realm_password_auth_enabled === false) {\n            // Skip the password prompt step, since the user doesn't have one.\n            request_api_key({});\n        } else {\n            $(\"#get_api_key_button\").on(\"click\", (e) => {\n                e.preventDefault();\n                e.stopPropagation();\n                do_get_api_key();\n            });\n            $(\"#get_api_key_password\").on(\"keydown\", (e) => {\n                if (e.key === \"Enter\") {\n                    e.preventDefault();\n                    e.stopPropagation();\n                    do_get_api_key();\n                }\n            });\n        }\n\n        $(\"#regenerate_api_key\").on(\"click\", (e) => {\n            channel.post({\n                url: \"/json/users/me/api_key/regenerate\",\n                success(data) {\n                    $(\"#api_key_value\").text(data.api_key);\n                },\n                error(xhr) {\n                    $(\"#user_api_key_error\").text(JSON.parse(xhr.responseText).msg).show();\n                },\n            });\n            e.preventDefault();\n            e.stopPropagation();\n        });\n\n        $(\"#download_zuliprc\").on(\"click\", function () {\n            const bot_object = {\n                user_id: people.my_current_user_id(),\n                email: page_params.delivery_email,\n                api_key: $(\"#api_key_value\").text(),\n            };\n            const data = settings_bots.generate_zuliprc_content(bot_object);\n            $(this).attr(\"href\", settings_bots.encode_zuliprc_as_uri(data));\n        });\n\n        $(\"#api_key_modal [data-micromodal-close]\").on(\"click\", () => {\n            common.reset_password_toggle_icons(\n                \"#get_api_key_password\",\n                \"#get_api_key_password + .password_visibility_toggle\",\n            );\n        });\n    };\n\n    $(\"#api_key_button\").on(\"click\", (e) => {\n        $(\"body\").append(render_settings_api_key_modal());\n        setup_api_key_modal();\n        $(\"#api_key_status\").hide();\n        overlays.open_modal(\"api_key_modal\", {\n            autoremove: true,\n            micromodal: true,\n            on_show: () => {\n                $(\"#get_api_key_password\").trigger(\"focus\");\n            },\n        });\n        e.preventDefault();\n        e.stopPropagation();\n    });\n\n    function clear_password_change() {\n        // Clear the password boxes so that passwords don't linger in the DOM\n        // for an XSS attacker to find.\n        common.reset_password_toggle_icons(\n            \"#old_password\",\n            \"#old_password + .password_visibility_toggle\",\n        );\n        common.reset_password_toggle_icons(\n            \"#new_password\",\n            \"#new_password + .password_visibility_toggle\",\n        );\n        $(\"#old_password, #new_password\").val(\"\");\n        password_quality?.(\"\", $(\"#pw_strength .bar\"), $(\"#new_password\"));\n    }\n\n    function change_password_post_render() {\n        $(\"#change_password_modal\")\n            .find(\"[data-micromodal-close]\")\n            .on(\"click\", () => {\n                clear_password_change();\n            });\n        common.setup_password_visibility_toggle(\n            \"#old_password\",\n            \"#old_password + .password_visibility_toggle\",\n            {tippy_tooltips: true},\n        );\n        common.setup_password_visibility_toggle(\n            \"#new_password\",\n            \"#new_password + .password_visibility_toggle\",\n            {tippy_tooltips: true},\n        );\n        clear_password_change();\n    }\n\n    $(\"#change_password\").on(\"click\", async (e) => {\n        e.preventDefault();\n        e.stopPropagation();\n\n        function validate_input(e) {\n            e.preventDefault();\n            e.stopPropagation();\n            const old_password = $(\"#old_password\").val();\n            const new_password = $(\"#new_password\").val();\n\n            if (old_password === \"\") {\n                ui_report.error(\n                    $t_html({defaultMessage: \"Please enter your password\"}),\n                    undefined,\n                    $(\"#dialog_error\"),\n                );\n                return false;\n            }\n\n            if (new_password === \"\") {\n                ui_report.error(\n                    $t_html({defaultMessage: \"Please choose a new password\"}),\n                    undefined,\n                    $(\"#dialog_error\"),\n                );\n                return false;\n            }\n            return true;\n        }\n\n        dialog_widget.launch({\n            html_heading: $t_html({defaultMessage: \"Change password\"}),\n            html_body: render_dialog_change_password(),\n            html_submit_button: $t_html({defaultMessage: \"Change\"}),\n            loading_spinner: true,\n            id: \"change_password_modal\",\n            form_id: \"change_password_container\",\n            post_render: change_password_post_render,\n            on_click: do_change_password,\n            validate_input,\n        });\n        $(\"#pw_change_controls\").show();\n        if (page_params.realm_password_auth_enabled !== false) {\n            // zxcvbn.js is pretty big, and is only needed on password\n            // change, so load it asynchronously.\n            password_quality = (await import(\"./password_quality\")).password_quality;\n            $(\"#pw_strength .bar\").removeClass(\"fade\");\n        }\n    });\n\n    function do_change_password(e) {\n        e.preventDefault();\n        e.stopPropagation();\n        const change_password_error = $(\"#change_password_modal\").find(\"#dialog_error\");\n        change_password_error.hide();\n\n        const data = {\n            old_password: $(\"#old_password\").val(),\n            new_password: $(\"#new_password\").val(),\n        };\n\n        const new_pw_field = $(\"#new_password\");\n        const new_pw = data.new_password;\n        if (new_pw !== \"\") {\n            if (password_quality === undefined) {\n                // password_quality didn't load, for whatever reason.\n                settings_change_error(\n                    \"An internal error occurred; try reloading the page. \" +\n                        \"Sorry for the trouble!\",\n                );\n                return;\n            } else if (!password_quality(new_pw, undefined, new_pw_field)) {\n                settings_change_error($t_html({defaultMessage: \"New password is too weak\"}));\n                return;\n            }\n        }\n\n        channel.set_password_change_in_progress(true);\n        const opts = {\n            success_continuation() {\n                channel.set_password_change_in_progress(false);\n                dialog_widget.close_modal();\n            },\n            error_continuation() {\n                dialog_widget.hide_dialog_spinner();\n                channel.set_password_change_in_progress(false);\n            },\n            error_msg_element: change_password_error,\n            failure_msg_html: null,\n        };\n        settings_ui.do_settings_change(\n            channel.patch,\n            \"/json/settings\",\n            data,\n            $(\"#account-settings-status\").expectOne(),\n            opts,\n        );\n        clear_password_change();\n    }\n\n    $(\"#new_password\").on(\"input\", () => {\n        const field = $(\"#new_password\");\n        password_quality?.(field.val(), $(\"#pw_strength .bar\"), field);\n    });\n\n    $(\"#full_name\").on(\"change\", (e) => {\n        e.preventDefault();\n        e.stopPropagation();\n        const data = {};\n\n        data.full_name = $(\"#full_name\").val();\n\n        settings_ui.do_settings_change(\n            channel.patch,\n            \"/json/settings\",\n            data,\n            $(\".full-name-status\").expectOne(),\n        );\n    });\n\n    function do_change_email(e) {\n        e.preventDefault();\n        e.stopPropagation();\n        const change_email_error = $(\"#change_email_modal\").find(\"#dialog_error\");\n        const data = {};\n        data.email = $(\"#change_email_container\").find(\"input[name='email']\").val();\n\n        const opts = {\n            success_continuation() {\n                if (page_params.development_environment) {\n                    const email_msg = render_settings_dev_env_email_access();\n                    ui_report.success(\n                        email_msg,\n                        $(\"#dev-account-settings-status\").expectOne(),\n                        4000,\n                    );\n                }\n                dialog_widget.close_modal();\n            },\n            error_continuation() {\n                dialog_widget.hide_dialog_spinner();\n            },\n            error_msg_element: change_email_error,\n            success_msg_html: $t_html(\n                {defaultMessage: \"Check your email ({email}) to confirm the new address.\"},\n                {email: data.email},\n            ),\n            sticky: true,\n        };\n        settings_ui.do_settings_change(\n            channel.patch,\n            \"/json/settings\",\n            data,\n            $(\"#account-settings-status\").expectOne(),\n            opts,\n        );\n    }\n\n    function change_email_post_render() {\n        const input_elem = $(\"#change_email_container\").find(\"input[name='email']\");\n        const email = $(\"#change_email\").text().trim();\n        input_elem.val(email);\n    }\n\n    $(\"#change_email\").on(\"click\", (e) => {\n        e.preventDefault();\n        e.stopPropagation();\n        if (!page_params.realm_email_changes_disabled || page_params.is_admin) {\n            dialog_widget.launch({\n                html_heading: $t_html({defaultMessage: \"Change email\"}),\n                html_body: render_change_email_modal(),\n                html_submit_button: $t_html({defaultMessage: \"Change\"}),\n                loading_spinner: true,\n                id: \"change_email_modal\",\n                form_id: \"change_email_container\",\n                on_click: do_change_email,\n                post_render: change_email_post_render,\n                on_shown: () => {\n                    $(\"#change_email_container input\").trigger(\"focus\");\n                },\n            });\n        }\n    });\n\n    $(\"#profile-settings\").on(\"click\", \".custom_user_field .remove_date\", (e) => {\n        e.preventDefault();\n        e.stopPropagation();\n        const field = $(e.target).closest(\".custom_user_field\").expectOne();\n        const field_id = Number.parseInt($(field).attr(\"data-field-id\"), 10);\n        update_user_custom_profile_fields([field_id], channel.del);\n    });\n\n    $(\"#profile-settings\").on(\"change\", \".custom_user_field_value\", function (e) {\n        const fields = [];\n        const value = $(this).val();\n        const field_id = Number.parseInt(\n            $(e.target).closest(\".custom_user_field\").attr(\"data-field-id\"),\n            10,\n        );\n        if (value) {\n            fields.push({id: field_id, value});\n            update_user_custom_profile_fields(fields, channel.patch);\n        } else {\n            fields.push(field_id);\n            update_user_custom_profile_fields(fields, channel.del);\n        }\n    });\n\n    $(\"#user_deactivate_account_button\").on(\"click\", (e) => {\n        // This click event must not get propagated to parent container otherwise the modal\n        // will not show up because of a call to `close_active_modal` in `settings.js`.\n        e.preventDefault();\n        e.stopPropagation();\n\n        function handle_confirm() {\n            channel.del({\n                url: \"/json/users/me\",\n                success() {\n                    dialog_widget.hide_dialog_spinner();\n                    dialog_widget.close_modal();\n                    window.location.href = \"/login/\";\n                },\n                error(xhr) {\n                    const error_last_owner = $t_html({\n                        defaultMessage: \"Error: Cannot deactivate the only organization owner.\",\n                    });\n                    const error_last_user = $t_html(\n                        {\n                            defaultMessage:\n                                \"Error: Cannot deactivate the only user. You can deactivate the whole organization though in your <z-link>organization profile settings</z-link>.\",\n                        },\n                        {\n                            \"z-link\": (content_html) =>\n                                `<a target=\"_blank\" href=\"/#organization/organization-profile\">${content_html}</a>`,\n                        },\n                    );\n                    let rendered_error_msg;\n                    if (xhr.responseJSON.code === \"CANNOT_DEACTIVATE_LAST_USER\") {\n                        if (xhr.responseJSON.is_last_owner) {\n                            rendered_error_msg = error_last_owner;\n                        } else {\n                            rendered_error_msg = error_last_user;\n                        }\n                    }\n                    dialog_widget.hide_dialog_spinner();\n                    dialog_widget.close_modal();\n                    $(\"#account-settings-status\")\n                        .addClass(\"alert-error\")\n                        .html(rendered_error_msg)\n                        .show();\n                },\n            });\n        }\n        const html_body = render_confirm_deactivate_own_user();\n        confirm_dialog.launch({\n            html_heading: $t_html({defaultMessage: \"Deactivate your account\"}),\n            html_body,\n            on_click: handle_confirm,\n            help_link: \"/help/deactivate-your-account\",\n            loading_spinner: true,\n        });\n    });\n\n    $(\"#show_my_user_profile_modal\").on(\"click\", () => {\n        overlays.close_overlay(\"settings\");\n        const user = people.get_by_user_id(people.my_current_user_id());\n        setTimeout(() => {\n            user_profile.show_user_profile(user);\n        }, 100);\n\n        // If user opened the \"preview profile\" modal from user\n        // settings, then closing preview profile modal should\n        // send them back to the settings modal.\n        $(\"body\").one(\"hidden.bs.modal\", \"#user-profile-modal\", (e) => {\n            e.preventDefault();\n            e.stopPropagation();\n\n            setTimeout(() => {\n                if (!overlays.settings_open()) {\n                    overlays.open_settings();\n                }\n            }, 100);\n        });\n    });\n\n    function upload_avatar(file_input) {\n        const form_data = new FormData();\n\n        form_data.append(\"csrfmiddlewaretoken\", csrf_token);\n        for (const [i, file] of Array.prototype.entries.call(file_input[0].files)) {\n            form_data.append(\"file-\" + i, file);\n        }\n        display_avatar_upload_started();\n        channel.post({\n            url: \"/json/users/me/avatar\",\n            data: form_data,\n            cache: false,\n            processData: false,\n            contentType: false,\n            success() {\n                display_avatar_upload_complete();\n                $(\"#user-avatar-upload-widget .image_file_input_error\").hide();\n                $(\"#user-avatar-source\").hide();\n                // Rest of the work is done via the user_events -> avatar_url event we will get\n            },\n            error(xhr) {\n                display_avatar_upload_complete();\n                if (page_params.avatar_source === \"G\") {\n                    $(\"#user-avatar-source\").show();\n                }\n                const $error = $(\"#user-avatar-upload-widget .image_file_input_error\");\n                $error.text(JSON.parse(xhr.responseText).msg);\n                $error.show();\n            },\n        });\n    }\n\n    avatar.build_user_avatar_widget(upload_avatar);\n\n    $(\"#user_timezone\").val(user_settings.timezone);\n\n    $(\"#user_timezone\").on(\"change\", function (e) {\n        e.preventDefault();\n        e.stopPropagation();\n\n        const data = {timezone: this.value};\n\n        settings_ui.do_settings_change(\n            channel.patch,\n            \"/json/settings\",\n            data,\n            $(\".timezone-setting-status\").expectOne(),\n        );\n    });\n\n    $(\"#privacy_settings_box\").on(\"change\", \"input\", (e) => {\n        e.preventDefault();\n        e.stopPropagation();\n\n        const input_elem = $(e.currentTarget);\n        const setting_name = input_elem.attr(\"name\");\n        const checked = input_elem.prop(\"checked\");\n\n        const data = {[setting_name]: checked};\n        settings_ui.do_settings_change(\n            channel.patch,\n            \"/json/settings\",\n            data,\n            $(\"#account-settings .privacy-setting-status\").expectOne(),\n        );\n    });\n}\n", "import time\nfrom datetime import datetime, timezone\nfrom typing import Any, Dict\nfrom unittest import mock\n\nimport orjson\nfrom django.http import HttpRequest, HttpResponse\nfrom django.test import override_settings\n\nfrom zerver.lib.initial_password import initial_password\nfrom zerver.lib.rate_limiter import add_ratelimit_rule, remove_ratelimit_rule\nfrom zerver.lib.test_classes import ZulipTestCase\nfrom zerver.lib.test_helpers import get_test_image_file\nfrom zerver.lib.users import get_all_api_keys\nfrom zerver.models import (\n    Draft,\n    NotificationTriggers,\n    ScheduledMessageNotificationEmail,\n    UserProfile,\n    get_user_profile_by_api_key,\n)\n\n\nclass ChangeSettingsTest(ZulipTestCase):\n    # TODO: requires method consolidation, right now, there's no alternative\n    # for check_for_toggle_param for PATCH.\n    def check_for_toggle_param_patch(self, pattern: str, param: str) -> None:\n        self.login(\"hamlet\")\n        user_profile = self.example_user(\"hamlet\")\n        json_result = self.client_patch(pattern, {param: orjson.dumps(True).decode()})\n        self.assert_json_success(json_result)\n        # refetch user_profile object to correctly handle caching\n        user_profile = self.example_user(\"hamlet\")\n        self.assertEqual(getattr(user_profile, param), True)\n\n        json_result = self.client_patch(pattern, {param: orjson.dumps(False).decode()})\n        self.assert_json_success(json_result)\n        # refetch user_profile object to correctly handle caching\n        user_profile = self.example_user(\"hamlet\")\n        self.assertEqual(getattr(user_profile, param), False)\n\n    def test_successful_change_settings(self) -> None:\n        \"\"\"\n        A call to /json/settings with valid parameters changes the user's\n        settings correctly and returns correct values.\n        \"\"\"\n        user = self.example_user(\"hamlet\")\n        self.login_user(user)\n        json_result = self.client_patch(\n            \"/json/settings\",\n            dict(\n                full_name=\"Foo Bar\",\n                old_password=initial_password(user.delivery_email),\n                new_password=\"foobar1\",\n            ),\n        )\n        self.assert_json_success(json_result)\n\n        user.refresh_from_db()\n        self.assertEqual(user.full_name, \"Foo Bar\")\n        self.logout()\n\n        # This is one of the few places we log in directly\n        # with Django's client (to test the password change\n        # with as few moving parts as possible).\n        request = HttpRequest()\n        request.session = self.client.session\n        self.assertTrue(\n            self.client.login(\n                request=request,\n                username=user.delivery_email,\n                password=\"foobar1\",\n                realm=user.realm,\n            ),\n        )\n        self.assert_logged_in_user_id(user.id)\n\n    def test_password_change_check_strength(self) -> None:\n        self.login(\"hamlet\")\n        with self.settings(PASSWORD_MIN_LENGTH=3, PASSWORD_MIN_GUESSES=1000):\n            json_result = self.client_patch(\n                \"/json/settings\",\n                dict(\n                    full_name=\"Foo Bar\",\n                    old_password=initial_password(self.example_email(\"hamlet\")),\n                    new_password=\"easy\",\n                ),\n            )\n            self.assert_json_error(json_result, \"New password is too weak!\")\n\n            json_result = self.client_patch(\n                \"/json/settings\",\n                dict(\n                    full_name=\"Foo Bar\",\n                    old_password=initial_password(self.example_email(\"hamlet\")),\n                    new_password=\"f657gdGGk9\",\n                ),\n            )\n            self.assert_json_success(json_result)\n\n    def test_illegal_name_changes(self) -> None:\n        user = self.example_user(\"hamlet\")\n        self.login_user(user)\n        full_name = user.full_name\n\n        with self.settings(NAME_CHANGES_DISABLED=True):\n            json_result = self.client_patch(\"/json/settings\", dict(full_name=\"Foo Bar\"))\n\n        # We actually fail silently here, since this only happens if\n        # somebody is trying to game our API, and there's no reason to\n        # give them the courtesy of an error reason.\n        self.assert_json_success(json_result)\n\n        user = self.example_user(\"hamlet\")\n        self.assertEqual(user.full_name, full_name)\n\n        # Now try a too-long name\n        json_result = self.client_patch(\"/json/settings\", dict(full_name=\"x\" * 1000))\n        self.assert_json_error(json_result, \"Name too long!\")\n\n        # Now try a too-short name\n        json_result = self.client_patch(\"/json/settings\", dict(full_name=\"x\"))\n        self.assert_json_error(json_result, \"Name too short!\")\n\n    def test_illegal_characters_in_name_changes(self) -> None:\n        self.login(\"hamlet\")\n\n        # Now try a name with invalid characters\n        json_result = self.client_patch(\"/json/settings\", dict(full_name=\"Opheli*\"))\n        self.assert_json_error(json_result, \"Invalid characters in name!\")\n\n    def test_change_email_to_disposable_email(self) -> None:\n        hamlet = self.example_user(\"hamlet\")\n        self.login_user(hamlet)\n        realm = hamlet.realm\n        realm.disallow_disposable_email_addresses = True\n        realm.emails_restricted_to_domains = False\n        realm.save()\n\n        json_result = self.client_patch(\"/json/settings\", dict(email=\"hamlet@mailnator.com\"))\n        self.assert_json_error(json_result, \"Please use your real email address.\")\n\n    def test_change_email_batching_period(self) -> None:\n        hamlet = self.example_user(\"hamlet\")\n        cordelia = self.example_user(\"cordelia\")\n        othello = self.example_user(\"othello\")\n        self.login_user(hamlet)\n\n        # Default is two minutes\n        self.assertEqual(hamlet.email_notifications_batching_period_seconds, 120)\n\n        result = self.client_patch(\n            \"/json/settings\", {\"email_notifications_batching_period_seconds\": -1}\n        )\n        self.assert_json_error(result, \"Invalid email batching period: -1 seconds\")\n\n        result = self.client_patch(\n            \"/json/settings\", {\"email_notifications_batching_period_seconds\": 7 * 24 * 60 * 60 + 10}\n        )\n        self.assert_json_error(result, \"Invalid email batching period: 604810 seconds\")\n\n        result = self.client_patch(\n            \"/json/settings\", {\"email_notifications_batching_period_seconds\": 5 * 60}\n        )\n        self.assert_json_success(result)\n        hamlet = self.example_user(\"hamlet\")\n        self.assertEqual(hamlet.email_notifications_batching_period_seconds, 300)\n\n        # Test that timestamps get updated for existing ScheduledMessageNotificationEmail rows\n        hamlet_msg_id1 = self.send_stream_message(sender=cordelia, stream_name=\"Verona\")\n        hamlet_msg_id2 = self.send_stream_message(sender=cordelia, stream_name=\"Verona\")\n        othello_msg_id1 = self.send_stream_message(sender=cordelia, stream_name=\"Verona\")\n\n        def create_entry(user_profile_id: int, message_id: int, timestamp: datetime) -> int:\n            # The above messages don't actually mention anyone. We just fill up the trigger\n            # because we need to.\n            entry = ScheduledMessageNotificationEmail.objects.create(\n                user_profile_id=user_profile_id,\n                message_id=message_id,\n                trigger=NotificationTriggers.MENTION,\n                scheduled_timestamp=timestamp,\n            )\n            return entry.id\n\n        def get_datetime_object(minutes: int) -> datetime:\n            return datetime(\n                year=2021, month=8, day=10, hour=10, minute=minutes, second=15, tzinfo=timezone.utc\n            )\n\n        hamlet_timestamp = get_datetime_object(10)\n        othello_timestamp = get_datetime_object(20)\n\n        hamlet_entry1_id = create_entry(hamlet.id, hamlet_msg_id1, hamlet_timestamp)\n        hamlet_entry2_id = create_entry(hamlet.id, hamlet_msg_id2, hamlet_timestamp)\n        othello_entry1_id = create_entry(othello.id, othello_msg_id1, othello_timestamp)\n\n        # Update Hamlet's setting from 300 seconds (5 minutes) to 600 seconds (10 minutes)\n        self.assertEqual(hamlet.email_notifications_batching_period_seconds, 300)\n        result = self.client_patch(\n            \"/json/settings\", {\"email_notifications_batching_period_seconds\": 10 * 60}\n        )\n        self.assert_json_success(result)\n        hamlet = self.example_user(\"hamlet\")\n        self.assertEqual(hamlet.email_notifications_batching_period_seconds, 10 * 60)\n\n        def check_scheduled_timestamp(entry_id: int, expected_timestamp: datetime) -> None:\n            entry = ScheduledMessageNotificationEmail.objects.get(id=entry_id)\n            self.assertEqual(entry.scheduled_timestamp, expected_timestamp)\n\n        # For Hamlet, the new scheduled timestamp should have been updated\n        expected_hamlet_timestamp = get_datetime_object(15)\n        check_scheduled_timestamp(hamlet_entry1_id, expected_hamlet_timestamp)\n        check_scheduled_timestamp(hamlet_entry2_id, expected_hamlet_timestamp)\n\n        # Nothing should have changed for Othello\n        check_scheduled_timestamp(othello_entry1_id, othello_timestamp)\n\n    def test_toggling_boolean_user_settings(self) -> None:\n        \"\"\"Test updating each boolean setting in UserProfile property_types\"\"\"\n        boolean_settings = (\n            s for s in UserProfile.property_types if UserProfile.property_types[s] is bool\n        )\n        for user_setting in boolean_settings:\n            self.check_for_toggle_param_patch(\"/json/settings\", user_setting)\n\n    def test_wrong_old_password(self) -> None:\n        self.login(\"hamlet\")\n        result = self.client_patch(\n            \"/json/settings\",\n            dict(\n                old_password=\"bad_password\",\n                new_password=\"ignored\",\n            ),\n        )\n        self.assert_json_error(result, \"Wrong password!\")\n\n    def test_wrong_old_password_rate_limiter(self) -> None:\n        self.login(\"hamlet\")\n        with self.settings(RATE_LIMITING_AUTHENTICATE=True):\n            add_ratelimit_rule(10, 2, domain=\"authenticate_by_username\")\n            start_time = time.time()\n            with mock.patch(\"time.time\", return_value=start_time):\n                result = self.client_patch(\n                    \"/json/settings\",\n                    dict(\n                        old_password=\"bad_password\",\n                        new_password=\"ignored\",\n                    ),\n                )\n                self.assert_json_error(result, \"Wrong password!\")\n                result = self.client_patch(\n                    \"/json/settings\",\n                    dict(\n                        old_password=\"bad_password\",\n                        new_password=\"ignored\",\n                    ),\n                )\n                self.assert_json_error(result, \"Wrong password!\")\n\n                # We're over the limit, so we'll get blocked even with the correct password.\n                result = self.client_patch(\n                    \"/json/settings\",\n                    dict(\n                        old_password=initial_password(self.example_email(\"hamlet\")),\n                        new_password=\"ignored\",\n                    ),\n                )\n                self.assert_json_error(\n                    result, \"You're making too many attempts! Try again in 10 seconds.\"\n                )\n\n            # After time passes, we should be able to succeed if we give the correct password.\n            with mock.patch(\"time.time\", return_value=start_time + 11):\n                json_result = self.client_patch(\n                    \"/json/settings\",\n                    dict(\n                        old_password=initial_password(self.example_email(\"hamlet\")),\n                        new_password=\"foobar1\",\n                    ),\n                )\n                self.assert_json_success(json_result)\n\n            remove_ratelimit_rule(10, 2, domain=\"authenticate_by_username\")\n\n    @override_settings(\n        AUTHENTICATION_BACKENDS=(\n            \"zproject.backends.ZulipLDAPAuthBackend\",\n            \"zproject.backends.EmailAuthBackend\",\n            \"zproject.backends.ZulipDummyBackend\",\n        )\n    )\n    def test_change_password_ldap_backend(self) -> None:\n        self.init_default_ldap_database()\n        ldap_user_attr_map = {\"full_name\": \"cn\", \"short_name\": \"sn\"}\n\n        self.login(\"hamlet\")\n\n        with self.settings(\n            LDAP_APPEND_DOMAIN=\"zulip.com\", AUTH_LDAP_USER_ATTR_MAP=ldap_user_attr_map\n        ):\n            result = self.client_patch(\n                \"/json/settings\",\n                dict(\n                    old_password=initial_password(self.example_email(\"hamlet\")),\n                    new_password=\"ignored\",\n                ),\n            )\n            self.assert_json_error(result, \"Your Zulip password is managed in LDAP\")\n\n            result = self.client_patch(\n                \"/json/settings\",\n                dict(\n                    old_password=self.ldap_password(\"hamlet\"),  # hamlet's password in LDAP\n                    new_password=\"ignored\",\n                ),\n            )\n            self.assert_json_error(result, \"Your Zulip password is managed in LDAP\")\n\n        with self.settings(\n            LDAP_APPEND_DOMAIN=\"example.com\", AUTH_LDAP_USER_ATTR_MAP=ldap_user_attr_map\n        ), self.assertLogs(\"zulip.ldap\", \"DEBUG\") as debug_log:\n            result = self.client_patch(\n                \"/json/settings\",\n                dict(\n                    old_password=initial_password(self.example_email(\"hamlet\")),\n                    new_password=\"ignored\",\n                ),\n            )\n            self.assert_json_success(result)\n            self.assertEqual(\n                debug_log.output,\n                [\n                    \"DEBUG:zulip.ldap:ZulipLDAPAuthBackend: Email hamlet@zulip.com does not match LDAP domain example.com.\"\n                ],\n            )\n\n        with self.settings(LDAP_APPEND_DOMAIN=None, AUTH_LDAP_USER_ATTR_MAP=ldap_user_attr_map):\n            result = self.client_patch(\n                \"/json/settings\",\n                dict(\n                    old_password=initial_password(self.example_email(\"hamlet\")),\n                    new_password=\"ignored\",\n                ),\n            )\n            self.assert_json_error(result, \"Your Zulip password is managed in LDAP\")\n\n    def do_test_change_user_setting(self, setting_name: str) -> None:\n\n        test_changes: Dict[str, Any] = dict(\n            default_language=\"de\",\n            default_view=\"all_messages\",\n            emojiset=\"google\",\n            timezone=\"America/Denver\",\n            demote_inactive_streams=2,\n            color_scheme=2,\n            email_notifications_batching_period_seconds=100,\n            notification_sound=\"ding\",\n            desktop_icon_count_display=2,\n        )\n\n        self.login(\"hamlet\")\n        test_value = test_changes.get(setting_name)\n        # Error if a setting in UserProfile.property_types does not have test values\n        if test_value is None:\n            raise AssertionError(f\"No test created for {setting_name}\")\n\n        if setting_name not in [\"demote_inactive_streams\", \"color_scheme\"]:\n            data = {setting_name: test_value}\n        else:\n            data = {setting_name: orjson.dumps(test_value).decode()}\n\n        result = self.client_patch(\"/json/settings\", data)\n        self.assert_json_success(result)\n        user_profile = self.example_user(\"hamlet\")\n        self.assertEqual(getattr(user_profile, setting_name), test_value)\n\n    def test_change_user_setting(self) -> None:\n        \"\"\"Test updating each non-boolean setting in UserProfile property_types\"\"\"\n        user_settings = (\n            s for s in UserProfile.property_types if UserProfile.property_types[s] is not bool\n        )\n        for setting in user_settings:\n            self.do_test_change_user_setting(setting)\n        self.do_test_change_user_setting(\"timezone\")\n\n    def test_invalid_setting_value(self) -> None:\n        invalid_values_dict = dict(\n            default_language=\"invalid_de\",\n            default_view=\"invalid_view\",\n            emojiset=\"apple\",\n            timezone=\"invalid_US/Mountain\",\n            demote_inactive_streams=10,\n            color_scheme=10,\n            notification_sound=\"invalid_sound\",\n            desktop_icon_count_display=10,\n        )\n\n        self.login(\"hamlet\")\n        for setting_name in invalid_values_dict.keys():\n            invalid_value = invalid_values_dict.get(setting_name)\n            if isinstance(invalid_value, str):\n                invalid_value = orjson.dumps(invalid_value).decode()\n\n            req = {setting_name: invalid_value}\n            result = self.client_patch(\"/json/settings\", req)\n\n            expected_error_msg = f\"Invalid {setting_name}\"\n            if setting_name == \"notification_sound\":\n                expected_error_msg = f\"Invalid notification sound '{invalid_value}'\"\n            self.assert_json_error(result, expected_error_msg)\n            hamlet = self.example_user(\"hamlet\")\n            self.assertNotEqual(getattr(hamlet, setting_name), invalid_value)\n\n    def do_change_emojiset(self, emojiset: str) -> HttpResponse:\n        self.login(\"hamlet\")\n        data = {\"emojiset\": emojiset}\n        result = self.client_patch(\"/json/settings\", data)\n        return result\n\n    def test_emojiset(self) -> None:\n        \"\"\"Test banned emoji sets are not accepted.\"\"\"\n        banned_emojisets = [\"apple\", \"emojione\"]\n        valid_emojisets = [\"google\", \"google-blob\", \"text\", \"twitter\"]\n\n        for emojiset in banned_emojisets:\n            result = self.do_change_emojiset(emojiset)\n            self.assert_json_error(result, \"Invalid emojiset\")\n\n        for emojiset in valid_emojisets:\n            result = self.do_change_emojiset(emojiset)\n            self.assert_json_success(result)\n\n    def test_avatar_changes_disabled(self) -> None:\n        self.login(\"hamlet\")\n\n        with self.settings(AVATAR_CHANGES_DISABLED=True):\n            result = self.client_delete(\"/json/users/me/avatar\")\n            self.assert_json_error(result, \"Avatar changes are disabled in this organization.\", 400)\n\n        with self.settings(AVATAR_CHANGES_DISABLED=True):\n            with get_test_image_file(\"img.png\") as fp1:\n                result = self.client_post(\"/json/users/me/avatar\", {\"f1\": fp1})\n            self.assert_json_error(result, \"Avatar changes are disabled in this organization.\", 400)\n\n    def test_invalid_setting_name(self) -> None:\n        self.login(\"hamlet\")\n\n        # Now try an invalid setting name\n        json_result = self.client_patch(\"/json/settings\", dict(invalid_setting=\"value\"))\n        self.assert_json_success(json_result)\n\n        result = orjson.loads(json_result.content)\n        self.assertIn(\"ignored_parameters_unsupported\", result)\n        self.assertEqual(result[\"ignored_parameters_unsupported\"], [\"invalid_setting\"])\n\n    def test_changing_setting_using_display_setting_endpoint(self) -> None:\n        \"\"\"\n        This test is just for adding coverage for `/settings/display` endpoint which is\n        now deprecated.\n        \"\"\"\n        self.login(\"hamlet\")\n\n        result = self.client_patch(\n            \"/json/settings/display\", dict(color_scheme=UserProfile.COLOR_SCHEME_NIGHT)\n        )\n        self.assert_json_success(result)\n        hamlet = self.example_user(\"hamlet\")\n        self.assertEqual(hamlet.color_scheme, UserProfile.COLOR_SCHEME_NIGHT)\n\n    def test_changing_setting_using_notification_setting_endpoint(self) -> None:\n        \"\"\"\n        This test is just for adding coverage for `/settings/notifications` endpoint which is\n        now deprecated.\n        \"\"\"\n        self.login(\"hamlet\")\n\n        result = self.client_patch(\n            \"/json/settings/notifications\",\n            dict(enable_stream_desktop_notifications=orjson.dumps(True).decode()),\n        )\n        self.assert_json_success(result)\n        hamlet = self.example_user(\"hamlet\")\n        self.assertEqual(hamlet.enable_stream_desktop_notifications, True)\n\n\nclass UserChangesTest(ZulipTestCase):\n    def test_update_api_key(self) -> None:\n        user = self.example_user(\"hamlet\")\n        email = user.email\n\n        self.login_user(user)\n        old_api_keys = get_all_api_keys(user)\n        # Ensure the old API keys are in the authentication cache, so\n        # that the below logic can test whether we have a cache-flushing bug.\n        for api_key in old_api_keys:\n            self.assertEqual(get_user_profile_by_api_key(api_key).email, email)\n\n        result = self.client_post(\"/json/users/me/api_key/regenerate\")\n        self.assert_json_success(result)\n        new_api_key = result.json()[\"api_key\"]\n        self.assertNotIn(new_api_key, old_api_keys)\n        user = self.example_user(\"hamlet\")\n        current_api_keys = get_all_api_keys(user)\n        self.assertIn(new_api_key, current_api_keys)\n\n        for api_key in old_api_keys:\n            with self.assertRaises(UserProfile.DoesNotExist):\n                get_user_profile_by_api_key(api_key)\n\n        for api_key in current_api_keys:\n            self.assertEqual(get_user_profile_by_api_key(api_key).email, email)\n\n\nclass UserDraftSettingsTests(ZulipTestCase):\n    def test_enable_drafts_syncing(self) -> None:\n        hamlet = self.example_user(\"hamlet\")\n        hamlet.enable_drafts_synchronization = False\n        hamlet.save()\n        payload = {\"enable_drafts_synchronization\": orjson.dumps(True).decode()}\n        resp = self.api_patch(hamlet, \"/api/v1/settings\", payload)\n        self.assert_json_success(resp)\n        hamlet = self.example_user(\"hamlet\")\n        self.assertTrue(hamlet.enable_drafts_synchronization)\n\n    def test_disable_drafts_syncing(self) -> None:\n        aaron = self.example_user(\"aaron\")\n        self.assertTrue(aaron.enable_drafts_synchronization)\n\n        initial_count = Draft.objects.count()\n\n        # Create some drafts. These should be deleted once aaron disables\n        # syncing drafts.\n        visible_stream_id = self.get_stream_id(self.get_streams(aaron)[0])\n        draft_dicts = [\n            {\n                \"type\": \"stream\",\n                \"to\": [visible_stream_id],\n                \"topic\": \"thinking out loud\",\n                \"content\": \"What if pigs really could fly?\",\n                \"timestamp\": 15954790199,\n            },\n            {\n                \"type\": \"private\",\n                \"to\": [],\n                \"topic\": \"\",\n                \"content\": \"What if made it possible to sync drafts in Zulip?\",\n                \"timestamp\": 1595479020,\n            },\n        ]\n        payload = {\"drafts\": orjson.dumps(draft_dicts).decode()}\n        resp = self.api_post(aaron, \"/api/v1/drafts\", payload)\n        self.assert_json_success(resp)\n        self.assertEqual(Draft.objects.count() - initial_count, 2)\n\n        payload = {\"enable_drafts_synchronization\": orjson.dumps(False).decode()}\n        resp = self.api_patch(aaron, \"/api/v1/settings\", payload)\n        self.assert_json_success(resp)\n        aaron = self.example_user(\"aaron\")\n        self.assertFalse(aaron.enable_drafts_synchronization)\n        self.assertEqual(Draft.objects.count() - initial_count, 0)\n", "import os\nfrom typing import List, Union\n\nfrom django.conf import settings\nfrom django.conf.urls import include\nfrom django.conf.urls.i18n import i18n_patterns\nfrom django.contrib.auth.views import (\n    LoginView,\n    PasswordResetCompleteView,\n    PasswordResetConfirmView,\n    PasswordResetDoneView,\n)\nfrom django.urls import path, re_path\nfrom django.urls.resolvers import URLPattern, URLResolver\nfrom django.utils.module_loading import import_string\nfrom django.views.generic import RedirectView, TemplateView\n\nfrom zerver.forms import LoggingSetPasswordForm\nfrom zerver.lib.integrations import WEBHOOK_INTEGRATIONS\nfrom zerver.lib.rest import rest_path\nfrom zerver.tornado.views import cleanup_event_queue, get_events, get_events_internal, notify\nfrom zerver.views.alert_words import add_alert_words, list_alert_words, remove_alert_words\nfrom zerver.views.attachments import list_by_user, remove\nfrom zerver.views.auth import (\n    api_fetch_api_key,\n    api_get_server_settings,\n    json_fetch_api_key,\n    log_into_subdomain,\n    login_page,\n    logout_then_login,\n    password_reset,\n    remote_user_jwt,\n    remote_user_sso,\n    saml_sp_metadata,\n    show_deactivation_notice,\n    start_remote_user_sso,\n    start_social_login,\n    start_social_signup,\n)\nfrom zerver.views.compatibility import check_global_compatibility\nfrom zerver.views.custom_profile_fields import (\n    create_realm_custom_profile_field,\n    delete_realm_custom_profile_field,\n    list_realm_custom_profile_fields,\n    remove_user_custom_profile_data,\n    reorder_realm_custom_profile_fields,\n    update_realm_custom_profile_field,\n    update_user_custom_profile_data,\n)\nfrom zerver.views.digest import digest_page\nfrom zerver.views.documentation import IntegrationView, MarkdownDirectoryView, integration_doc\nfrom zerver.views.drafts import create_drafts, delete_draft, edit_draft, fetch_drafts\nfrom zerver.views.email_mirror import email_mirror_message\nfrom zerver.views.events_register import events_register_backend\nfrom zerver.views.home import accounts_accept_terms, desktop_home, home\nfrom zerver.views.hotspots import mark_hotspot_as_read\nfrom zerver.views.invite import (\n    generate_multiuse_invite_backend,\n    get_user_invites,\n    invite_users_backend,\n    resend_user_invite_email,\n    revoke_multiuse_invite,\n    revoke_user_invite,\n)\nfrom zerver.views.message_edit import (\n    delete_message_backend,\n    get_message_edit_history,\n    json_fetch_raw_message,\n    update_message_backend,\n)\nfrom zerver.views.message_fetch import get_messages_backend, messages_in_narrow_backend\nfrom zerver.views.message_flags import (\n    mark_all_as_read,\n    mark_stream_as_read,\n    mark_topic_as_read,\n    update_message_flags,\n)\nfrom zerver.views.message_send import render_message_backend, send_message_backend, zcommand_backend\nfrom zerver.views.muting import mute_user, unmute_user, update_muted_topic\nfrom zerver.views.portico import (\n    app_download_link_redirect,\n    apps_view,\n    hello_view,\n    landing_view,\n    plans_view,\n    team_view,\n)\nfrom zerver.views.presence import (\n    get_presence_backend,\n    get_statuses_for_realm,\n    update_active_status_backend,\n    update_user_status_backend,\n)\nfrom zerver.views.push_notifications import (\n    add_android_reg_id,\n    add_apns_device_token,\n    remove_android_reg_id,\n    remove_apns_device_token,\n)\nfrom zerver.views.reactions import add_reaction, remove_reaction\nfrom zerver.views.realm import (\n    check_subdomain_available,\n    deactivate_realm,\n    realm_reactivation,\n    update_realm,\n    update_realm_user_settings_defaults,\n)\nfrom zerver.views.realm_domains import (\n    create_realm_domain,\n    delete_realm_domain,\n    list_realm_domains,\n    patch_realm_domain,\n)\nfrom zerver.views.realm_emoji import delete_emoji, list_emoji, upload_emoji\nfrom zerver.views.realm_export import delete_realm_export, export_realm, get_realm_exports\nfrom zerver.views.realm_icon import delete_icon_backend, get_icon_backend, upload_icon\nfrom zerver.views.realm_linkifiers import (\n    create_linkifier,\n    delete_linkifier,\n    list_linkifiers,\n    update_linkifier,\n)\nfrom zerver.views.realm_logo import delete_logo_backend, get_logo_backend, upload_logo\nfrom zerver.views.realm_playgrounds import add_realm_playground, delete_realm_playground\nfrom zerver.views.registration import (\n    accounts_home,\n    accounts_home_from_multiuse_invite,\n    accounts_register,\n    create_realm,\n    find_account,\n    get_prereg_key_and_redirect,\n    realm_redirect,\n)\nfrom zerver.views.report import (\n    report_csp_violations,\n    report_error,\n    report_narrow_times,\n    report_send_times,\n    report_unnarrow_times,\n)\nfrom zerver.views.storage import get_storage, remove_storage, update_storage\nfrom zerver.views.streams import (\n    add_default_stream,\n    add_subscriptions_backend,\n    create_default_stream_group,\n    deactivate_stream_backend,\n    delete_in_topic,\n    get_streams_backend,\n    get_subscribers_backend,\n    get_topics_backend,\n    json_get_stream_id,\n    list_subscriptions_backend,\n    remove_default_stream,\n    remove_default_stream_group,\n    remove_subscriptions_backend,\n    update_default_stream_group_info,\n    update_default_stream_group_streams,\n    update_stream_backend,\n    update_subscription_properties_backend,\n    update_subscriptions_backend,\n    update_subscriptions_property,\n)\nfrom zerver.views.submessage import process_submessage\nfrom zerver.views.thumbnail import backend_serve_thumbnail\nfrom zerver.views.tutorial import set_tutorial_status\nfrom zerver.views.typing import send_notification_backend\nfrom zerver.views.unsubscribe import email_unsubscribe\nfrom zerver.views.upload import (\n    serve_file_backend,\n    serve_file_url_backend,\n    serve_local_file_unauthed,\n    upload_file_backend,\n)\nfrom zerver.views.user_groups import (\n    add_user_group,\n    delete_user_group,\n    edit_user_group,\n    get_user_group,\n    update_user_group_backend,\n)\nfrom zerver.views.user_settings import (\n    confirm_email_change,\n    delete_avatar_backend,\n    json_change_settings,\n    regenerate_api_key,\n    set_avatar_backend,\n)\nfrom zerver.views.users import (\n    add_bot_backend,\n    avatar,\n    create_user_backend,\n    deactivate_bot_backend,\n    deactivate_user_backend,\n    deactivate_user_own_backend,\n    get_bots_backend,\n    get_members_backend,\n    get_profile_backend,\n    get_subscription_backend,\n    get_user_by_email,\n    patch_bot_backend,\n    reactivate_user_backend,\n    regenerate_bot_api_key,\n    update_user_backend,\n)\nfrom zerver.views.video_calls import (\n    complete_zoom_user,\n    deauthorize_zoom_user,\n    get_bigbluebutton_url,\n    join_bigbluebutton,\n    make_zoom_video_call,\n    register_zoom_user,\n)\nfrom zerver.views.zephyr import webathena_kerberos_login\nfrom zproject import dev_urls\nfrom zproject.legacy_urls import legacy_urls\n\nif settings.TWO_FACTOR_AUTHENTICATION_ENABLED:\n    from two_factor.gateways.twilio.urls import urlpatterns as tf_twilio_urls\n    from two_factor.urls import urlpatterns as tf_urls\n\n# NB: There are several other pieces of code which route requests by URL:\n#\n#   - legacy_urls.py contains API endpoint written before the redesign\n#     and should not be added to.\n#\n#   - runtornado.py has its own URL list for Tornado views.  See the\n#     invocation of web.Application in that file.\n#\n#   - The nginx config knows which URLs to route to Django or Tornado.\n#\n#   - Likewise for the local dev server in tools/run-dev.py.\n\n# These endpoints constitute the currently designed API (V1), which uses:\n# * REST verbs\n# * Basic auth (username:password is email:apiKey)\n# * Take and return json-formatted data\n#\n# If you're adding a new endpoint to the code that requires authentication,\n# please add it here.\n# See rest_dispatch in zerver.lib.rest for an explanation of auth methods used\n#\n# All of these paths are accessed by either a /json or /api/v1 prefix;\n# e.g. `PATCH /json/realm` or `PATCH /api/v1/realm`.\nv1_api_and_json_patterns = [\n    # realm-level calls\n    rest_path(\"realm\", PATCH=update_realm),\n    rest_path(\"realm/user_settings_defaults\", PATCH=update_realm_user_settings_defaults),\n    path(\"realm/subdomain/<subdomain>\", check_subdomain_available),\n    # realm/domains -> zerver.views.realm_domains\n    rest_path(\"realm/domains\", GET=list_realm_domains, POST=create_realm_domain),\n    rest_path(\"realm/domains/<domain>\", PATCH=patch_realm_domain, DELETE=delete_realm_domain),\n    # realm/emoji -> zerver.views.realm_emoji\n    rest_path(\"realm/emoji\", GET=list_emoji),\n    rest_path(\n        \"realm/emoji/<emoji_name>\",\n        POST=upload_emoji,\n        DELETE=(delete_emoji, {\"intentionally_undocumented\"}),\n    ),\n    # this endpoint throws a status code 400 JsonableError when it should be a 404.\n    # realm/icon -> zerver.views.realm_icon\n    rest_path(\"realm/icon\", POST=upload_icon, DELETE=delete_icon_backend, GET=get_icon_backend),\n    # realm/logo -> zerver.views.realm_logo\n    rest_path(\"realm/logo\", POST=upload_logo, DELETE=delete_logo_backend, GET=get_logo_backend),\n    # realm/filters and realm/linkifiers -> zerver.views.realm_linkifiers\n    rest_path(\"realm/linkifiers\", GET=list_linkifiers),\n    rest_path(\"realm/filters\", POST=create_linkifier),\n    rest_path(\"realm/filters/<int:filter_id>\", DELETE=delete_linkifier, PATCH=update_linkifier),\n    # realm/playgrounds -> zerver.views.realm_playgrounds\n    rest_path(\"realm/playgrounds\", POST=add_realm_playground),\n    rest_path(\"realm/playgrounds/<int:playground_id>\", DELETE=delete_realm_playground),\n    # realm/profile_fields -> zerver.views.custom_profile_fields\n    rest_path(\n        \"realm/profile_fields\",\n        GET=list_realm_custom_profile_fields,\n        PATCH=reorder_realm_custom_profile_fields,\n        POST=create_realm_custom_profile_field,\n    ),\n    rest_path(\n        \"realm/profile_fields/<int:field_id>\",\n        PATCH=update_realm_custom_profile_field,\n        DELETE=delete_realm_custom_profile_field,\n    ),\n    # realm/deactivate -> zerver.views.deactivate_realm\n    rest_path(\"realm/deactivate\", POST=deactivate_realm),\n    # users -> zerver.views.users\n    rest_path(\"users\", GET=get_members_backend, POST=create_user_backend),\n    rest_path(\"users/me\", GET=get_profile_backend, DELETE=deactivate_user_own_backend),\n    rest_path(\"users/<int:user_id>/reactivate\", POST=reactivate_user_backend),\n    rest_path(\n        \"users/<int:user_id>\",\n        GET=get_members_backend,\n        PATCH=update_user_backend,\n        DELETE=deactivate_user_backend,\n    ),\n    rest_path(\"users/<int:user_id>/subscriptions/<int:stream_id>\", GET=get_subscription_backend),\n    rest_path(\"users/<email>\", GET=get_user_by_email),\n    rest_path(\"bots\", GET=get_bots_backend, POST=add_bot_backend),\n    rest_path(\"bots/<int:bot_id>/api_key/regenerate\", POST=regenerate_bot_api_key),\n    rest_path(\"bots/<int:bot_id>\", PATCH=patch_bot_backend, DELETE=deactivate_bot_backend),\n    # invites -> zerver.views.invite\n    rest_path(\"invites\", GET=get_user_invites, POST=invite_users_backend),\n    rest_path(\"invites/<int:prereg_id>\", DELETE=revoke_user_invite),\n    rest_path(\"invites/<int:prereg_id>/resend\", POST=resend_user_invite_email),\n    # invites/multiuse -> zerver.views.invite\n    rest_path(\"invites/multiuse\", POST=generate_multiuse_invite_backend),\n    # invites/multiuse -> zerver.views.invite\n    rest_path(\"invites/multiuse/<int:invite_id>\", DELETE=revoke_multiuse_invite),\n    # mark messages as read (in bulk)\n    rest_path(\"mark_all_as_read\", POST=mark_all_as_read),\n    rest_path(\"mark_stream_as_read\", POST=mark_stream_as_read),\n    rest_path(\"mark_topic_as_read\", POST=mark_topic_as_read),\n    rest_path(\"zcommand\", POST=zcommand_backend),\n    # Endpoints for syncing drafts.\n    rest_path(\"drafts\", GET=fetch_drafts, POST=create_drafts),\n    rest_path(\"drafts/<int:draft_id>\", PATCH=edit_draft, DELETE=delete_draft),\n    # messages -> zerver.views.message*\n    # GET returns messages, possibly filtered, POST sends a message\n    rest_path(\n        \"messages\",\n        GET=(get_messages_backend, {\"allow_anonymous_user_web\"}),\n        POST=(send_message_backend, {\"allow_incoming_webhooks\"}),\n    ),\n    rest_path(\n        \"messages/<int:message_id>\",\n        GET=(json_fetch_raw_message, {\"allow_anonymous_user_web\"}),\n        PATCH=update_message_backend,\n        DELETE=delete_message_backend,\n    ),\n    rest_path(\"messages/render\", POST=render_message_backend),\n    rest_path(\"messages/flags\", POST=update_message_flags),\n    rest_path(\"messages/<int:message_id>/history\", GET=get_message_edit_history),\n    rest_path(\"messages/matches_narrow\", GET=messages_in_narrow_backend),\n    rest_path(\"users/me/subscriptions/properties\", POST=update_subscription_properties_backend),\n    rest_path(\"users/me/subscriptions/<int:stream_id>\", PATCH=update_subscriptions_property),\n    rest_path(\"submessage\", POST=process_submessage),\n    # New endpoint for handling reactions.\n    # reactions -> zerver.view.reactions\n    # POST adds a reaction to a message\n    # DELETE removes a reaction from a message\n    rest_path(\"messages/<int:message_id>/reactions\", POST=add_reaction, DELETE=remove_reaction),\n    # attachments -> zerver.views.attachments\n    rest_path(\"attachments\", GET=list_by_user),\n    rest_path(\"attachments/<int:attachment_id>\", DELETE=remove),\n    # typing -> zerver.views.typing\n    # POST sends a typing notification event to recipients\n    rest_path(\"typing\", POST=send_notification_backend),\n    # user_uploads -> zerver.views.upload\n    rest_path(\"user_uploads\", POST=upload_file_backend),\n    rest_path(\n        \"user_uploads/<realm_id_str>/<path:filename>\",\n        GET=(serve_file_url_backend, {\"override_api_url_scheme\"}),\n    ),\n    # bot_storage -> zerver.views.storage\n    rest_path(\"bot_storage\", PUT=update_storage, GET=get_storage, DELETE=remove_storage),\n    # Endpoint used by mobile devices to register their push\n    # notification credentials\n    rest_path(\n        \"users/me/apns_device_token\", POST=add_apns_device_token, DELETE=remove_apns_device_token\n    ),\n    rest_path(\"users/me/android_gcm_reg_id\", POST=add_android_reg_id, DELETE=remove_android_reg_id),\n    # users/*/presence => zerver.views.presence.\n    rest_path(\"users/me/presence\", POST=update_active_status_backend),\n    # It's important that this sit after users/me/presence so that\n    # Django's URL resolution order doesn't break the\n    # /users/me/presence endpoint.\n    rest_path(\"users/<user_id_or_email>/presence\", GET=get_presence_backend),\n    rest_path(\"realm/presence\", GET=get_statuses_for_realm),\n    rest_path(\"users/me/status\", POST=update_user_status_backend),\n    # user_groups -> zerver.views.user_groups\n    rest_path(\"user_groups\", GET=get_user_group),\n    rest_path(\"user_groups/create\", POST=add_user_group),\n    rest_path(\"user_groups/<int:user_group_id>\", PATCH=edit_user_group, DELETE=delete_user_group),\n    rest_path(\"user_groups/<int:user_group_id>/members\", POST=update_user_group_backend),\n    # users/me -> zerver.views.user_settings\n    rest_path(\"users/me/api_key/regenerate\", POST=regenerate_api_key),\n    rest_path(\"users/me/avatar\", POST=set_avatar_backend, DELETE=delete_avatar_backend),\n    # users/me/hotspots -> zerver.views.hotspots\n    rest_path(\n        \"users/me/hotspots\",\n        POST=(\n            mark_hotspot_as_read,\n            # This endpoint is low priority for documentation as\n            # it is part of the web app-specific tutorial.\n            {\"intentionally_undocumented\"},\n        ),\n    ),\n    # users/me/tutorial_status -> zerver.views.tutorial\n    rest_path(\n        \"users/me/tutorial_status\",\n        POST=(\n            set_tutorial_status,\n            # This is a relic of an old Zulip tutorial model and\n            # should be deleted.\n            {\"intentionally_undocumented\"},\n        ),\n    ),\n    # settings -> zerver.views.user_settings\n    rest_path(\"settings\", PATCH=json_change_settings),\n    # These next two are legacy aliases for /settings, from before\n    # we merged the endpoints. They are documented in the `/json/settings`\n    # documentation, rather than having dedicated pages.\n    rest_path(\"settings/display\", PATCH=(json_change_settings, {\"intentionally_undocumented\"})),\n    rest_path(\n        \"settings/notifications\", PATCH=(json_change_settings, {\"intentionally_undocumented\"})\n    ),\n    # users/me/alert_words -> zerver.views.alert_words\n    rest_path(\n        \"users/me/alert_words\",\n        GET=list_alert_words,\n        POST=add_alert_words,\n        DELETE=remove_alert_words,\n    ),\n    # users/me/custom_profile_data -> zerver.views.custom_profile_data\n    rest_path(\n        \"users/me/profile_data\",\n        PATCH=update_user_custom_profile_data,\n        DELETE=remove_user_custom_profile_data,\n    ),\n    rest_path(\n        \"users/me/<int:stream_id>/topics\", GET=(get_topics_backend, {\"allow_anonymous_user_web\"})\n    ),\n    # streams -> zerver.views.streams\n    # (this API is only used externally)\n    rest_path(\"streams\", GET=get_streams_backend),\n    # GET returns `stream_id`, stream name should be encoded in the URL query (in `stream` param)\n    rest_path(\"get_stream_id\", GET=json_get_stream_id),\n    # GET returns \"stream info\" (undefined currently?), HEAD returns whether stream exists (200 or 404)\n    rest_path(\"streams/<int:stream_id>/members\", GET=get_subscribers_backend),\n    rest_path(\n        \"streams/<int:stream_id>\", PATCH=update_stream_backend, DELETE=deactivate_stream_backend\n    ),\n    # Delete topic in stream\n    rest_path(\"streams/<int:stream_id>/delete_topic\", POST=delete_in_topic),\n    rest_path(\"default_streams\", POST=add_default_stream, DELETE=remove_default_stream),\n    rest_path(\"default_stream_groups/create\", POST=create_default_stream_group),\n    rest_path(\n        \"default_stream_groups/<int:group_id>\",\n        PATCH=update_default_stream_group_info,\n        DELETE=remove_default_stream_group,\n    ),\n    rest_path(\n        \"default_stream_groups/<int:group_id>/streams\", PATCH=update_default_stream_group_streams\n    ),\n    # GET lists your streams, POST bulk adds, PATCH bulk modifies/removes\n    rest_path(\n        \"users/me/subscriptions\",\n        GET=list_subscriptions_backend,\n        POST=add_subscriptions_backend,\n        PATCH=update_subscriptions_backend,\n        DELETE=remove_subscriptions_backend,\n    ),\n    # muting -> zerver.views.muting\n    rest_path(\"users/me/subscriptions/muted_topics\", PATCH=update_muted_topic),\n    rest_path(\"users/me/muted_users/<int:muted_user_id>\", POST=mute_user, DELETE=unmute_user),\n    # used to register for an event queue in tornado\n    rest_path(\"register\", POST=events_register_backend),\n    # events -> zerver.tornado.views\n    rest_path(\"events\", GET=get_events, DELETE=cleanup_event_queue),\n    # report -> zerver.views.report\n    #\n    # These endpoints are for internal error/performance reporting\n    # from the browser to the web app, and we don't expect to ever\n    # include in our API documentation.\n    rest_path(\n        \"report/error\",\n        # Logged-out browsers can hit this endpoint, for portico page JS exceptions.\n        POST=(report_error, {\"allow_anonymous_user_web\", \"intentionally_undocumented\"}),\n    ),\n    rest_path(\"report/send_times\", POST=(report_send_times, {\"intentionally_undocumented\"})),\n    rest_path(\n        \"report/narrow_times\",\n        POST=(report_narrow_times, {\"allow_anonymous_user_web\", \"intentionally_undocumented\"}),\n    ),\n    rest_path(\n        \"report/unnarrow_times\",\n        POST=(report_unnarrow_times, {\"allow_anonymous_user_web\", \"intentionally_undocumented\"}),\n    ),\n    # Used to generate a Zoom video call URL\n    rest_path(\"calls/zoom/create\", POST=make_zoom_video_call),\n    # Used to generate a BigBlueButton video call URL\n    rest_path(\"calls/bigbluebutton/create\", GET=get_bigbluebutton_url),\n    # export/realm -> zerver.views.realm_export\n    rest_path(\"export/realm\", POST=export_realm, GET=get_realm_exports),\n    rest_path(\"export/realm/<int:export_id>\", DELETE=delete_realm_export),\n]\n\nintegrations_view = IntegrationView.as_view()\n\n# These views serve pages (HTML). As such, their internationalization\n# must depend on the URL.\n#\n# If you're adding a new page to the website (as opposed to a new\n# endpoint for use by code), you should add it here.\ni18n_urls = [\n    path(\"\", home, name=\"home\"),\n    # We have a desktop-specific landing page in case we change our /\n    # to not log in in the future. We don't want to require a new\n    # desktop app build for everyone in that case\n    path(\"desktop_home/\", desktop_home),\n    # Backwards-compatibility (legacy) Google auth URL for the mobile\n    # apps; see https://github.com/zulip/zulip/issues/13081 for\n    # background.  We can remove this once older versions of the\n    # mobile app are no longer present in the wild.\n    path(\"accounts/login/google/\", start_social_login, {\"backend\": \"google\"}),\n    path(\"accounts/login/start/sso/\", start_remote_user_sso, name=\"start-login-sso\"),\n    path(\"accounts/login/sso/\", remote_user_sso, name=\"login-sso\"),\n    path(\"accounts/login/jwt/\", remote_user_jwt),\n    path(\"accounts/login/social/<backend>\", start_social_login, name=\"login-social\"),\n    path(\"accounts/login/social/<backend>/<extra_arg>\", start_social_login, name=\"login-social\"),\n    path(\"accounts/register/social/<backend>\", start_social_signup, name=\"signup-social\"),\n    path(\n        \"accounts/register/social/<backend>/<extra_arg>\", start_social_signup, name=\"signup-social\"\n    ),\n    path(\"accounts/login/subdomain/<token>\", log_into_subdomain),\n    # We have two entries for accounts/login; only the first one is\n    # used for URL resolution.  The second here is to allow\n    # reverse(\"login\") in templates to\n    # return `/accounts/login/`.\n    path(\"accounts/login/\", login_page, {\"template_name\": \"zerver/login.html\"}, name=\"login_page\"),\n    path(\"accounts/login/\", LoginView.as_view(template_name=\"zerver/login.html\"), name=\"login\"),\n    path(\"accounts/logout/\", logout_then_login),\n    path(\"accounts/webathena_kerberos_login/\", webathena_kerberos_login),\n    path(\"accounts/password/reset/\", password_reset, name=\"password_reset\"),\n    path(\n        \"accounts/password/reset/done/\",\n        PasswordResetDoneView.as_view(template_name=\"zerver/reset_emailed.html\"),\n    ),\n    path(\n        \"accounts/password/reset/<uidb64>/<token>/\",\n        PasswordResetConfirmView.as_view(\n            success_url=\"/accounts/password/done/\",\n            template_name=\"zerver/reset_confirm.html\",\n            form_class=LoggingSetPasswordForm,\n        ),\n        name=\"password_reset_confirm\",\n    ),\n    path(\n        \"accounts/password/done/\",\n        PasswordResetCompleteView.as_view(template_name=\"zerver/reset_done.html\"),\n    ),\n    path(\"accounts/deactivated/\", show_deactivation_notice),\n    # Displays digest email content in browser.\n    path(\"digest/\", digest_page),\n    # Registration views, require a confirmation ID.\n    path(\"accounts/home/\", accounts_home),\n    path(\n        \"accounts/send_confirm/<email>\",\n        TemplateView.as_view(template_name=\"zerver/accounts_send_confirm.html\"),\n        name=\"signup_send_confirm\",\n    ),\n    path(\n        \"accounts/new/send_confirm/<email>\",\n        TemplateView.as_view(template_name=\"zerver/accounts_send_confirm.html\"),\n        {\"realm_creation\": True},\n        name=\"new_realm_send_confirm\",\n    ),\n    path(\"accounts/register/\", accounts_register, name=\"accounts_register\"),\n    path(\n        \"accounts/do_confirm/<confirmation_key>\",\n        get_prereg_key_and_redirect,\n        name=\"get_prereg_key_and_redirect\",\n    ),\n    path(\n        \"accounts/confirm_new_email/<confirmation_key>\",\n        confirm_email_change,\n        name=\"confirm_email_change\",\n    ),\n    # Email unsubscription endpoint. Allows for unsubscribing from various types of emails,\n    # including the welcome emails (day 1 & 2), missed PMs, etc.\n    path(\n        \"accounts/unsubscribe/<email_type>/<confirmation_key>\",\n        email_unsubscribe,\n        name=\"unsubscribe\",\n    ),\n    # Portico-styled page used to provide email confirmation of terms acceptance.\n    path(\"accounts/accept_terms/\", accounts_accept_terms, name=\"accept_terms\"),\n    # Find your account\n    path(\"accounts/find/\", find_account, name=\"find_account\"),\n    # Go to organization subdomain\n    path(\"accounts/go/\", realm_redirect, name=\"realm_redirect\"),\n    # Realm creation\n    path(\"new/\", create_realm),\n    path(\"new/<creation_key>\", create_realm, name=\"create_realm\"),\n    # Realm reactivation\n    path(\"reactivate/<confirmation_key>\", realm_reactivation, name=\"realm_reactivation\"),\n    # Login/registration\n    path(\"register/\", accounts_home, name=\"register\"),\n    path(\"login/\", login_page, {\"template_name\": \"zerver/login.html\"}, name=\"login_page\"),\n    path(\"join/<confirmation_key>/\", accounts_home_from_multiuse_invite, name=\"join\"),\n    # Used to generate a Zoom video call URL\n    path(\"calls/zoom/register\", register_zoom_user),\n    path(\"calls/zoom/complete\", complete_zoom_user),\n    path(\"calls/zoom/deauthorize\", deauthorize_zoom_user),\n    # Used to join a BigBlueButton video call\n    path(\"calls/bigbluebutton/join\", join_bigbluebutton),\n    # API and integrations documentation\n    path(\"integrations/doc-html/<integration_name>\", integration_doc),\n    path(\"integrations/\", integrations_view),\n    path(\"integrations/<path:path>\", integrations_view),\n    # Landing page, features pages, signup form, etc.\n    path(\"hello/\", hello_view),\n    path(\"new-user/\", RedirectView.as_view(url=\"/hello\", permanent=True)),\n    path(\"features/\", landing_view, {\"template_name\": \"zerver/features.html\"}),\n    path(\"plans/\", plans_view, name=\"plans\"),\n    path(\"apps/\", apps_view),\n    path(\"apps/download/<platform>\", app_download_link_redirect),\n    path(\"apps/<platform>\", apps_view),\n    path(\n        \"developer-community/\", RedirectView.as_view(url=\"/development-community/\", permanent=True)\n    ),\n    path(\n        \"development-community/\",\n        landing_view,\n        {\"template_name\": \"zerver/development-community.html\"},\n    ),\n    # Renamed to have a cleared URL.\n    path(\n        \"developer-community/\", RedirectView.as_view(url=\"/development-community/\", permanent=True)\n    ),\n    path(\"attribution/\", landing_view, {\"template_name\": \"zerver/attribution.html\"}),\n    path(\"team/\", team_view),\n    path(\"history/\", landing_view, {\"template_name\": \"zerver/history.html\"}),\n    path(\"why-zulip/\", landing_view, {\"template_name\": \"zerver/why-zulip.html\"}),\n    path(\"for/education/\", landing_view, {\"template_name\": \"zerver/for-education.html\"}),\n    path(\"for/events/\", landing_view, {\"template_name\": \"zerver/for-events.html\"}),\n    path(\"for/open-source/\", landing_view, {\"template_name\": \"zerver/for-open-source.html\"}),\n    path(\"for/research/\", landing_view, {\"template_name\": \"zerver/for-research.html\"}),\n    path(\"for/business/\", landing_view, {\"template_name\": \"zerver/for-business.html\"}),\n    path(\"for/companies/\", RedirectView.as_view(url=\"/for/business/\", permanent=True)),\n    path(\"case-studies/idrift/\", landing_view, {\"template_name\": \"zerver/idrift-case-study.html\"}),\n    path(\"case-studies/tum/\", landing_view, {\"template_name\": \"zerver/tum-case-study.html\"}),\n    path(\"case-studies/ucsd/\", landing_view, {\"template_name\": \"zerver/ucsd-case-study.html\"}),\n    path(\"case-studies/rust/\", landing_view, {\"template_name\": \"zerver/rust-case-study.html\"}),\n    path(\"case-studies/lean/\", landing_view, {\"template_name\": \"zerver/lean-case-study.html\"}),\n    path(\n        \"for/communities/\",\n        landing_view,\n        {\"template_name\": \"zerver/for-communities.html\"},\n    ),\n    # We merged this into /for/communities.\n    path(\n        \"for/working-groups-and-communities/\",\n        RedirectView.as_view(url=\"/for/communities/\", permanent=True),\n    ),\n    path(\"self-hosting/\", landing_view, {\"template_name\": \"zerver/self-hosting.html\"}),\n    path(\"security/\", landing_view, {\"template_name\": \"zerver/security.html\"}),\n]\n\n# Make a copy of i18n_urls so that they appear without prefix for english\nurls: List[Union[URLPattern, URLResolver]] = list(i18n_urls)\n\n# Include the dual-use patterns twice\nurls += [\n    path(\"api/v1/\", include(v1_api_and_json_patterns)),\n    path(\"json/\", include(v1_api_and_json_patterns)),\n]\n\n# user_uploads -> zerver.views.upload.serve_file_backend\n#\n# This URL is an exception to the URL naming schemes for endpoints. It\n# supports both API and session cookie authentication, using a single\n# URL for both (not 'api/v1/' or 'json/' prefix). This is required to\n# easily support the mobile apps fetching uploaded files without\n# having to rewrite URLs, and is implemented using the\n# 'override_api_url_scheme' flag passed to rest_dispatch\nurls += [\n    path(\n        \"user_uploads/temporary/<token>/<filename>\",\n        serve_local_file_unauthed,\n        name=\"local_file_unauthed\",\n    ),\n    rest_path(\n        \"user_uploads/<realm_id_str>/<path:filename>\",\n        GET=(serve_file_backend, {\"override_api_url_scheme\"}),\n    ),\n    # This endpoint redirects to camo; it requires an exception for the\n    # same reason.\n    rest_path(\"thumbnail\", GET=(backend_serve_thumbnail, {\"override_api_url_scheme\"})),\n    # Avatars have the same constraint because their URLs are included\n    # in API data structures used by both the mobile and web clients.\n    rest_path(\n        \"avatar/<email_or_id>\",\n        GET=(avatar, {\"override_api_url_scheme\", \"allow_anonymous_user_web\"}),\n    ),\n    rest_path(\n        \"avatar/<email_or_id>/medium\",\n        {\"medium\": True},\n        GET=(avatar, {\"override_api_url_scheme\", \"allow_anonymous_user_web\"}),\n    ),\n]\n\n# This URL serves as a way to receive CSP violation reports from the users.\n# We use this endpoint to just log these reports.\nurls += [\n    path(\"report/csp_violations\", report_csp_violations),\n]\n\n# Incoming webhook URLs\n# We don't create URLs for particular Git integrations here\n# because of generic one below\nfor incoming_webhook in WEBHOOK_INTEGRATIONS:\n    if incoming_webhook.url_object:\n        urls.append(incoming_webhook.url_object)\n\n# Desktop-specific authentication URLs\nurls += [\n    rest_path(\"json/fetch_api_key\", POST=json_fetch_api_key),\n]\n\n# Mobile-specific authentication URLs\nurls += [\n    # Used as a global check by all mobile clients, which currently send\n    # requests to https://zulip.com/compatibility almost immediately after\n    # starting up.\n    path(\"compatibility\", check_global_compatibility),\n]\n\nv1_api_mobile_patterns = [\n    # This json format view used by the mobile apps lists which\n    # authentication backends the server allows as well as details\n    # like the requested subdomains'd realm icon (if known) and\n    # server-specific compatibility.\n    path(\"server_settings\", api_get_server_settings),\n    # This json format view used by the mobile apps accepts a username\n    # password/pair and returns an API key.\n    path(\"fetch_api_key\", api_fetch_api_key),\n]\n\n# View for uploading messages from email mirror\nurls += [\n    path(\"email_mirror_message\", email_mirror_message),\n]\n\n# Include URL configuration files for site-specified extra installed\n# Django apps\nfor app_name in settings.EXTRA_INSTALLED_APPS:\n    app_dir = os.path.join(settings.DEPLOY_ROOT, app_name)\n    if os.path.exists(os.path.join(app_dir, \"urls.py\")):\n        urls += [path(\"\", include(f\"{app_name}.urls\"))]\n        i18n_urls += import_string(f\"{app_name}.urls.i18n_urlpatterns\")\n\n# Tornado views\nurls += [\n    # Used internally for communication between Django and Tornado processes\n    #\n    # Since these views don't use rest_dispatch, they cannot have\n    # asynchronous Tornado behavior.\n    path(\"notify_tornado\", notify),\n    path(\"api/v1/events/internal\", get_events_internal),\n]\n\n# Python Social Auth\n\nurls += [path(\"\", include(\"social_django.urls\", namespace=\"social\"))]\nurls += [path(\"saml/metadata.xml\", saml_sp_metadata)]\n\n# SCIM2\n\nfrom django_scim import views as scim_views\n\nurls += [\n    # Everything below here are features that we don't yet support and we want\n    # to explicitly mark them to return \"Not Implemented\" rather than running\n    # the django-scim2 code for them.\n    re_path(\n        r\"^scim/v2/Groups/.search$\",\n        scim_views.SCIMView.as_view(implemented=False),\n    ),\n    re_path(\n        r\"^scim/v2/Groups(?:/(?P<uuid>[^/]+))?$\",\n        scim_views.SCIMView.as_view(implemented=False),\n    ),\n    re_path(r\"^scim/v2/Me$\", scim_views.SCIMView.as_view(implemented=False)),\n    re_path(\n        r\"^scim/v2/ServiceProviderConfig$\",\n        scim_views.SCIMView.as_view(implemented=False),\n    ),\n    re_path(\n        r\"^scim/v2/ResourceTypes(?:/(?P<uuid>[^/]+))?$\",\n        scim_views.SCIMView.as_view(implemented=False),\n    ),\n    re_path(\n        r\"^scim/v2/Schemas(?:/(?P<uuid>[^/]+))?$\", scim_views.SCIMView.as_view(implemented=False)\n    ),\n    re_path(r\"^scim/v2/Bulk$\", scim_views.SCIMView.as_view(implemented=False)),\n    # This registers the remaining SCIM endpoints.\n    path(\"scim/v2/\", include(\"django_scim.urls\", namespace=\"scim\")),\n]\n\n# User documentation site\nhelp_documentation_view = MarkdownDirectoryView.as_view(\n    template_name=\"zerver/documentation_main.html\", path_template=\"/zerver/help/%s.md\"\n)\napi_documentation_view = MarkdownDirectoryView.as_view(\n    template_name=\"zerver/documentation_main.html\", path_template=\"/zerver/api/%s.md\"\n)\npolicy_documentation_view = MarkdownDirectoryView.as_view(\n    template_name=\"zerver/documentation_main.html\",\n    policies_view=True,\n)\nurls += [\n    # Redirects due to us having moved the docs:\n    path(\n        \"help/delete-a-stream\", RedirectView.as_view(url=\"/help/archive-a-stream\", permanent=True)\n    ),\n    path(\"api/delete-stream\", RedirectView.as_view(url=\"/api/archive-stream\", permanent=True)),\n    path(\n        \"help/change-the-topic-of-a-message\",\n        RedirectView.as_view(url=\"/help/rename-a-topic\", permanent=True),\n    ),\n    path(\n        \"help/configure-missed-message-emails\",\n        RedirectView.as_view(url=\"/help/email-notifications\", permanent=True),\n    ),\n    path(\n        \"help/add-an-alert-word\",\n        RedirectView.as_view(\n            url=\"/help/pm-mention-alert-notifications#alert-words\", permanent=True\n        ),\n    ),\n    path(\n        \"help/test-mobile-notifications\",\n        RedirectView.as_view(url=\"/help/mobile-notifications\", permanent=True),\n    ),\n    path(\n        \"help/troubleshooting-desktop-notifications\",\n        RedirectView.as_view(\n            url=\"/help/desktop-notifications#troubleshooting-desktop-notifications\", permanent=True\n        ),\n    ),\n    path(\n        \"help/change-notification-sound\",\n        RedirectView.as_view(\n            url=\"/help/desktop-notifications#change-notification-sound\", permanent=True\n        ),\n    ),\n    path(\n        \"help/configure-message-notification-emails\",\n        RedirectView.as_view(url=\"/help/email-notifications\", permanent=True),\n    ),\n    path(\n        \"help/disable-new-login-emails\",\n        RedirectView.as_view(url=\"/help/email-notifications#new-login-emails\", permanent=True),\n    ),\n    # This redirect is particularly important, because the old URL\n    # appears in links from Welcome Bot messages.\n    path(\n        \"help/about-streams-and-topics\",\n        RedirectView.as_view(url=\"/help/streams-and-topics\", permanent=True),\n    ),\n    path(\n        \"help/community-topic-edits\",\n        RedirectView.as_view(url=\"/help/configure-who-can-edit-topics\", permanent=True),\n    ),\n    path(\n        \"help/only-allow-admins-to-add-emoji\",\n        RedirectView.as_view(\n            url=\"/help/custom-emoji#change-who-can-add-custom-emoji\", permanent=True\n        ),\n    ),\n    path(\n        \"help/configure-who-can-add-custom-emoji\",\n        RedirectView.as_view(\n            url=\"/help/custom-emoji#change-who-can-add-custom-emoji\", permanent=True\n        ),\n    ),\n    path(\n        \"help/add-custom-emoji\",\n        RedirectView.as_view(url=\"/help/custom-emoji\", permanent=True),\n    ),\n    path(\n        \"help/night-mode\",\n        RedirectView.as_view(url=\"/help/dark-theme\", permanent=True),\n    ),\n    path(\"help/\", help_documentation_view),\n    path(\"help/<path:article>\", help_documentation_view),\n    path(\"api/\", api_documentation_view),\n    path(\"api/<slug:article>\", api_documentation_view),\n    path(\"policies/\", policy_documentation_view),\n    path(\"policies/<slug:article>\", policy_documentation_view),\n    path(\n        \"privacy/\",\n        RedirectView.as_view(url=\"/policies/privacy\"),\n    ),\n    path(\n        \"terms/\",\n        RedirectView.as_view(url=\"/policies/terms\"),\n    ),\n]\n\n# Two-factor URLs\nif settings.TWO_FACTOR_AUTHENTICATION_ENABLED:\n    urls += [path(\"\", include(tf_urls)), path(\"\", include(tf_twilio_urls))]\n\nif settings.DEVELOPMENT:\n    urls += dev_urls.urls\n    i18n_urls += dev_urls.i18n_urls\n    v1_api_mobile_patterns += dev_urls.v1_api_mobile_patterns\n\nurls += [\n    path(\"api/v1/\", include(v1_api_mobile_patterns)),\n]\n\n# The sequence is important; if i18n URLs don't come first then\n# reverse URL mapping points to i18n URLs which causes the frontend\n# tests to fail\nurlpatterns = i18n_patterns(*i18n_urls) + urls + legacy_urls\n"], "fixing_code": ["import $ from \"jquery\";\n\nimport render_change_email_modal from \"../templates/change_email_modal.hbs\";\nimport render_confirm_deactivate_own_user from \"../templates/confirm_dialog/confirm_deactivate_own_user.hbs\";\nimport render_dialog_change_password from \"../templates/dialog_change_password.hbs\";\nimport render_settings_api_key_modal from \"../templates/settings/api_key_modal.hbs\";\nimport render_settings_custom_user_profile_field from \"../templates/settings/custom_user_profile_field.hbs\";\nimport render_settings_dev_env_email_access from \"../templates/settings/dev_env_email_access.hbs\";\n\nimport * as avatar from \"./avatar\";\nimport * as blueslip from \"./blueslip\";\nimport * as channel from \"./channel\";\nimport * as common from \"./common\";\nimport * as confirm_dialog from \"./confirm_dialog\";\nimport {csrf_token} from \"./csrf\";\nimport * as dialog_widget from \"./dialog_widget\";\nimport {$t_html} from \"./i18n\";\nimport * as overlays from \"./overlays\";\nimport {page_params} from \"./page_params\";\nimport * as people from \"./people\";\nimport * as pill_typeahead from \"./pill_typeahead\";\nimport * as settings_bots from \"./settings_bots\";\nimport * as settings_data from \"./settings_data\";\nimport * as settings_ui from \"./settings_ui\";\nimport * as ui_report from \"./ui_report\";\nimport * as user_pill from \"./user_pill\";\nimport * as user_profile from \"./user_profile\";\nimport {user_settings} from \"./user_settings\";\n\nlet password_quality; // Loaded asynchronously\n\nexport function update_email(new_email) {\n    const email_input = $(\"#change_email\");\n\n    if (email_input) {\n        email_input.text(new_email);\n    }\n}\n\nexport function update_full_name(new_full_name) {\n    // Arguably, this should work more like how the `update_email`\n    // flow works, where we update the name in the modal on open,\n    // rather than updating it here, but this works.\n    const full_name_input = $(\".full-name-change-form input[name='full_name']\");\n    if (full_name_input) {\n        full_name_input.val(new_full_name);\n    }\n}\n\nexport function update_name_change_display() {\n    if (!settings_data.user_can_change_name()) {\n        $(\"#full_name\").prop(\"disabled\", true);\n        $(\".change_name_tooltip\").show();\n    } else {\n        $(\"#full_name\").prop(\"disabled\", false);\n        $(\".change_name_tooltip\").hide();\n    }\n}\n\nexport function update_email_change_display() {\n    if (page_params.realm_email_changes_disabled && !page_params.is_admin) {\n        $(\"#change_email\").prop(\"disabled\", true);\n        $(\".change_email_tooltip\").show();\n    } else {\n        $(\"#change_email\").prop(\"disabled\", false);\n        $(\".change_email_tooltip\").hide();\n    }\n}\n\nexport function update_avatar_change_display() {\n    if (!settings_data.user_can_change_avatar()) {\n        // We disable this widget by simply hiding its edit UI.\n        $(\"#user-avatar-upload-widget .image_upload_button\").hide();\n        $(\".user-avatar-section .settings-info-icon\").show();\n    } else {\n        $(\"#user-avatar-upload-widget .image_upload_button\").show();\n        $(\".user-avatar-section .settings-info-icon\").hide();\n    }\n}\n\nfunction display_avatar_upload_complete() {\n    $(\"#user-avatar-upload-widget .upload-spinner-background\").css({visibility: \"hidden\"});\n    $(\"#user-avatar-upload-widget .image-upload-text\").show();\n    $(\"#user-avatar-upload-widget .image-delete-button\").show();\n}\n\nfunction display_avatar_upload_started() {\n    $(\"#user-avatar-source\").hide();\n    $(\"#user-avatar-upload-widget .upload-spinner-background\").css({visibility: \"visible\"});\n    $(\"#user-avatar-upload-widget .image-upload-text\").hide();\n    $(\"#user-avatar-upload-widget .image-delete-button\").hide();\n}\n\nfunction settings_change_error(message_html, xhr) {\n    ui_report.error(message_html, xhr, $(\"#account-settings-status\").expectOne());\n}\n\nfunction update_custom_profile_field(field, method) {\n    let field_id;\n    if (method === channel.del) {\n        field_id = field;\n    } else {\n        field_id = field.id;\n    }\n\n    const spinner_element = $(\n        `.custom_user_field[data-field-id=\"${CSS.escape(field_id)}\"] .custom-field-status`,\n    ).expectOne();\n    settings_ui.do_settings_change(\n        method,\n        \"/json/users/me/profile_data\",\n        {data: JSON.stringify([field])},\n        spinner_element,\n    );\n}\n\nfunction update_user_custom_profile_fields(fields, method) {\n    if (method === undefined) {\n        blueslip.error(\"Undefined method in update_user_custom_profile_fields\");\n    }\n\n    for (const field of fields) {\n        update_custom_profile_field(field, method);\n    }\n}\n\nexport function append_custom_profile_fields(element_id, user_id) {\n    const person = people.get_by_user_id(user_id);\n    if (person.is_bot) {\n        return;\n    }\n    const all_custom_fields = page_params.custom_profile_fields;\n    const all_field_types = page_params.custom_profile_field_types;\n\n    const all_field_template_types = new Map([\n        [all_field_types.LONG_TEXT.id, \"text\"],\n        [all_field_types.SHORT_TEXT.id, \"text\"],\n        [all_field_types.SELECT.id, \"select\"],\n        [all_field_types.USER.id, \"user\"],\n        [all_field_types.DATE.id, \"date\"],\n        [all_field_types.EXTERNAL_ACCOUNT.id, \"text\"],\n        [all_field_types.URL.id, \"url\"],\n    ]);\n\n    for (const field of all_custom_fields) {\n        let field_value = people.get_custom_profile_data(user_id, field.id);\n        const is_select_field = field.type === all_field_types.SELECT.id;\n        const field_choices = [];\n\n        if (field_value === undefined || field_value === null) {\n            field_value = {value: \"\", rendered_value: \"\"};\n        }\n        if (is_select_field) {\n            const field_choice_dict = JSON.parse(field.field_data);\n            for (const choice in field_choice_dict) {\n                if (choice) {\n                    field_choices[field_choice_dict[choice].order] = {\n                        value: choice,\n                        text: field_choice_dict[choice].text,\n                        selected: choice === field_value.value,\n                    };\n                }\n            }\n        }\n\n        const html = render_settings_custom_user_profile_field({\n            field,\n            field_type: all_field_template_types.get(field.type),\n            field_value,\n            is_long_text_field: field.type === all_field_types.LONG_TEXT.id,\n            is_user_field: field.type === all_field_types.USER.id,\n            is_date_field: field.type === all_field_types.DATE.id,\n            is_select_field,\n            field_choices,\n        });\n        $(element_id).append(html);\n    }\n}\n\nexport function initialize_custom_date_type_fields(element_id) {\n    $(element_id).find(\".custom_user_field .datepicker\").flatpickr({\n        altInput: true,\n        altFormat: \"F j, Y\",\n        allowInput: true,\n    });\n\n    $(element_id)\n        .find(\".custom_user_field .datepicker\")\n        .on(\"mouseenter\", function () {\n            if ($(this).val().length <= 0) {\n                $(this).parent().find(\".remove_date\").hide();\n            } else {\n                $(this).parent().find(\".remove_date\").show();\n            }\n        });\n\n    $(element_id)\n        .find(\".custom_user_field .remove_date\")\n        .on(\"click\", function () {\n            $(this).parent().find(\".custom_user_field_value\").val(\"\");\n        });\n}\n\nexport function initialize_custom_user_type_fields(\n    element_id,\n    user_id,\n    is_editable,\n    set_handler_on_update,\n) {\n    const field_types = page_params.custom_profile_field_types;\n    const user_pills = new Map();\n\n    const person = people.get_by_user_id(user_id);\n    if (person.is_bot) {\n        return user_pills;\n    }\n\n    for (const field of page_params.custom_profile_fields) {\n        let field_value_raw = people.get_custom_profile_data(user_id, field.id);\n\n        if (field_value_raw) {\n            field_value_raw = field_value_raw.value;\n        }\n\n        // If field is not editable and field value is null, we don't expect\n        // pill container for that field and proceed further\n        if (field.type === field_types.USER.id && (field_value_raw || is_editable)) {\n            const pill_container = $(element_id)\n                .find(`.custom_user_field[data-field-id=\"${CSS.escape(field.id)}\"] .pill-container`)\n                .expectOne();\n            const pills = user_pill.create_pills(pill_container);\n\n            function update_custom_user_field() {\n                const fields = [];\n                const user_ids = user_pill.get_user_ids(pills);\n                if (user_ids.length < 1) {\n                    fields.push(field.id);\n                    update_user_custom_profile_fields(fields, channel.del);\n                } else {\n                    fields.push({id: field.id, value: user_ids});\n                    update_user_custom_profile_fields(fields, channel.patch);\n                }\n            }\n\n            if (field_value_raw) {\n                const field_value = JSON.parse(field_value_raw);\n                if (field_value) {\n                    for (const pill_user_id of field_value) {\n                        const user = people.get_by_user_id(pill_user_id);\n                        user_pill.append_user(user, pills);\n                    }\n                }\n            }\n\n            if (is_editable) {\n                const input = pill_container.children(\".input\");\n                if (set_handler_on_update) {\n                    const opts = {update_func: update_custom_user_field, user: true};\n                    pill_typeahead.set_up(input, pills, opts);\n                    pills.onPillRemove(() => {\n                        update_custom_user_field();\n                    });\n                } else {\n                    pill_typeahead.set_up(input, pills, {user: true});\n                }\n            }\n            user_pills.set(field.id, pills);\n        }\n    }\n\n    return user_pills;\n}\n\nexport function add_custom_profile_fields_to_settings() {\n    if (!overlays.settings_open()) {\n        return;\n    }\n\n    const element_id = \"#profile-settings .custom-profile-fields-form\";\n    $(element_id).html(\"\");\n\n    append_custom_profile_fields(element_id, people.my_current_user_id());\n    initialize_custom_user_type_fields(element_id, people.my_current_user_id(), true, true);\n    initialize_custom_date_type_fields(element_id);\n}\n\nexport function hide_confirm_email_banner() {\n    if (!overlays.settings_open()) {\n        return;\n    }\n    $(\"#account-settings-status\").hide();\n}\n\nexport function set_up() {\n    // Add custom profile fields elements to user account settings.\n    add_custom_profile_fields_to_settings();\n    $(\"#account-settings-status\").hide();\n\n    const setup_api_key_modal = () => {\n        function request_api_key(data) {\n            channel.post({\n                url: \"/json/fetch_api_key\",\n                data,\n                success(data) {\n                    $(\"#get_api_key_password\").val(\"\");\n                    $(\"#api_key_value\").text(data.api_key);\n                    // The display property on the error bar is set to important\n                    // so instead of making display: none !important we just\n                    // remove it.\n                    $(\"#api_key_status\").remove();\n                    $(\"#password_confirmation\").hide();\n                    $(\"#get_api_key_button\").hide();\n                    $(\"#show_api_key\").show();\n                    $(\"#api_key_buttons\").show();\n                },\n                error(xhr) {\n                    ui_report.error(\n                        $t_html({defaultMessage: \"Error\"}),\n                        xhr,\n                        $(\"#api_key_status\").expectOne(),\n                    );\n                    $(\"#show_api_key\").hide();\n                },\n            });\n        }\n\n        $(\"#api_key_value\").text(\"\");\n        $(\"#show_api_key\").hide();\n        $(\"#api_key_buttons\").hide();\n        common.setup_password_visibility_toggle(\n            \"#get_api_key_password\",\n            \"#get_api_key_password + .password_visibility_toggle\",\n            {tippy_tooltips: true},\n        );\n\n        function do_get_api_key() {\n            $(\"#api_key_status\").hide();\n            const data = {};\n            data.password = $(\"#get_api_key_password\").val();\n            request_api_key(data);\n        }\n\n        if (page_params.realm_password_auth_enabled === false) {\n            // Skip the password prompt step, since the user doesn't have one.\n            request_api_key({});\n        } else {\n            $(\"#get_api_key_button\").on(\"click\", (e) => {\n                e.preventDefault();\n                e.stopPropagation();\n                do_get_api_key();\n            });\n            $(\"#get_api_key_password\").on(\"keydown\", (e) => {\n                if (e.key === \"Enter\") {\n                    e.preventDefault();\n                    e.stopPropagation();\n                    do_get_api_key();\n                }\n            });\n        }\n\n        $(\"#regenerate_api_key\").on(\"click\", (e) => {\n            const email = page_params.delivery_email;\n            const api_key = $(\"#api_key_value\").text();\n            const authorization_header = \"Basic \" + btoa(`${email}:${api_key}`);\n\n            channel.post({\n                // This endpoint is only accessible with the previous API key,\n                // via our usual HTTP Basic auth mechanism.\n                url: \"/api/v1/users/me/api_key/regenerate\",\n                headers: {Authorization: authorization_header},\n                success(data) {\n                    $(\"#api_key_value\").text(data.api_key);\n                },\n                error(xhr) {\n                    $(\"#user_api_key_error\").text(JSON.parse(xhr.responseText).msg).show();\n                },\n            });\n            e.preventDefault();\n            e.stopPropagation();\n        });\n\n        $(\"#download_zuliprc\").on(\"click\", function () {\n            const bot_object = {\n                user_id: people.my_current_user_id(),\n                email: page_params.delivery_email,\n                api_key: $(\"#api_key_value\").text(),\n            };\n            const data = settings_bots.generate_zuliprc_content(bot_object);\n            $(this).attr(\"href\", settings_bots.encode_zuliprc_as_uri(data));\n        });\n\n        $(\"#api_key_modal [data-micromodal-close]\").on(\"click\", () => {\n            common.reset_password_toggle_icons(\n                \"#get_api_key_password\",\n                \"#get_api_key_password + .password_visibility_toggle\",\n            );\n        });\n    };\n\n    $(\"#api_key_button\").on(\"click\", (e) => {\n        $(\"body\").append(render_settings_api_key_modal());\n        setup_api_key_modal();\n        $(\"#api_key_status\").hide();\n        overlays.open_modal(\"api_key_modal\", {\n            autoremove: true,\n            micromodal: true,\n            on_show: () => {\n                $(\"#get_api_key_password\").trigger(\"focus\");\n            },\n        });\n        e.preventDefault();\n        e.stopPropagation();\n    });\n\n    function clear_password_change() {\n        // Clear the password boxes so that passwords don't linger in the DOM\n        // for an XSS attacker to find.\n        common.reset_password_toggle_icons(\n            \"#old_password\",\n            \"#old_password + .password_visibility_toggle\",\n        );\n        common.reset_password_toggle_icons(\n            \"#new_password\",\n            \"#new_password + .password_visibility_toggle\",\n        );\n        $(\"#old_password, #new_password\").val(\"\");\n        password_quality?.(\"\", $(\"#pw_strength .bar\"), $(\"#new_password\"));\n    }\n\n    function change_password_post_render() {\n        $(\"#change_password_modal\")\n            .find(\"[data-micromodal-close]\")\n            .on(\"click\", () => {\n                clear_password_change();\n            });\n        common.setup_password_visibility_toggle(\n            \"#old_password\",\n            \"#old_password + .password_visibility_toggle\",\n            {tippy_tooltips: true},\n        );\n        common.setup_password_visibility_toggle(\n            \"#new_password\",\n            \"#new_password + .password_visibility_toggle\",\n            {tippy_tooltips: true},\n        );\n        clear_password_change();\n    }\n\n    $(\"#change_password\").on(\"click\", async (e) => {\n        e.preventDefault();\n        e.stopPropagation();\n\n        function validate_input(e) {\n            e.preventDefault();\n            e.stopPropagation();\n            const old_password = $(\"#old_password\").val();\n            const new_password = $(\"#new_password\").val();\n\n            if (old_password === \"\") {\n                ui_report.error(\n                    $t_html({defaultMessage: \"Please enter your password\"}),\n                    undefined,\n                    $(\"#dialog_error\"),\n                );\n                return false;\n            }\n\n            if (new_password === \"\") {\n                ui_report.error(\n                    $t_html({defaultMessage: \"Please choose a new password\"}),\n                    undefined,\n                    $(\"#dialog_error\"),\n                );\n                return false;\n            }\n            return true;\n        }\n\n        dialog_widget.launch({\n            html_heading: $t_html({defaultMessage: \"Change password\"}),\n            html_body: render_dialog_change_password(),\n            html_submit_button: $t_html({defaultMessage: \"Change\"}),\n            loading_spinner: true,\n            id: \"change_password_modal\",\n            form_id: \"change_password_container\",\n            post_render: change_password_post_render,\n            on_click: do_change_password,\n            validate_input,\n        });\n        $(\"#pw_change_controls\").show();\n        if (page_params.realm_password_auth_enabled !== false) {\n            // zxcvbn.js is pretty big, and is only needed on password\n            // change, so load it asynchronously.\n            password_quality = (await import(\"./password_quality\")).password_quality;\n            $(\"#pw_strength .bar\").removeClass(\"fade\");\n        }\n    });\n\n    function do_change_password(e) {\n        e.preventDefault();\n        e.stopPropagation();\n        const change_password_error = $(\"#change_password_modal\").find(\"#dialog_error\");\n        change_password_error.hide();\n\n        const data = {\n            old_password: $(\"#old_password\").val(),\n            new_password: $(\"#new_password\").val(),\n        };\n\n        const new_pw_field = $(\"#new_password\");\n        const new_pw = data.new_password;\n        if (new_pw !== \"\") {\n            if (password_quality === undefined) {\n                // password_quality didn't load, for whatever reason.\n                settings_change_error(\n                    \"An internal error occurred; try reloading the page. \" +\n                        \"Sorry for the trouble!\",\n                );\n                return;\n            } else if (!password_quality(new_pw, undefined, new_pw_field)) {\n                settings_change_error($t_html({defaultMessage: \"New password is too weak\"}));\n                return;\n            }\n        }\n\n        channel.set_password_change_in_progress(true);\n        const opts = {\n            success_continuation() {\n                channel.set_password_change_in_progress(false);\n                dialog_widget.close_modal();\n            },\n            error_continuation() {\n                dialog_widget.hide_dialog_spinner();\n                channel.set_password_change_in_progress(false);\n            },\n            error_msg_element: change_password_error,\n            failure_msg_html: null,\n        };\n        settings_ui.do_settings_change(\n            channel.patch,\n            \"/json/settings\",\n            data,\n            $(\"#account-settings-status\").expectOne(),\n            opts,\n        );\n        clear_password_change();\n    }\n\n    $(\"#new_password\").on(\"input\", () => {\n        const field = $(\"#new_password\");\n        password_quality?.(field.val(), $(\"#pw_strength .bar\"), field);\n    });\n\n    $(\"#full_name\").on(\"change\", (e) => {\n        e.preventDefault();\n        e.stopPropagation();\n        const data = {};\n\n        data.full_name = $(\"#full_name\").val();\n\n        settings_ui.do_settings_change(\n            channel.patch,\n            \"/json/settings\",\n            data,\n            $(\".full-name-status\").expectOne(),\n        );\n    });\n\n    function do_change_email(e) {\n        e.preventDefault();\n        e.stopPropagation();\n        const change_email_error = $(\"#change_email_modal\").find(\"#dialog_error\");\n        const data = {};\n        data.email = $(\"#change_email_container\").find(\"input[name='email']\").val();\n\n        const opts = {\n            success_continuation() {\n                if (page_params.development_environment) {\n                    const email_msg = render_settings_dev_env_email_access();\n                    ui_report.success(\n                        email_msg,\n                        $(\"#dev-account-settings-status\").expectOne(),\n                        4000,\n                    );\n                }\n                dialog_widget.close_modal();\n            },\n            error_continuation() {\n                dialog_widget.hide_dialog_spinner();\n            },\n            error_msg_element: change_email_error,\n            success_msg_html: $t_html(\n                {defaultMessage: \"Check your email ({email}) to confirm the new address.\"},\n                {email: data.email},\n            ),\n            sticky: true,\n        };\n        settings_ui.do_settings_change(\n            channel.patch,\n            \"/json/settings\",\n            data,\n            $(\"#account-settings-status\").expectOne(),\n            opts,\n        );\n    }\n\n    function change_email_post_render() {\n        const input_elem = $(\"#change_email_container\").find(\"input[name='email']\");\n        const email = $(\"#change_email\").text().trim();\n        input_elem.val(email);\n    }\n\n    $(\"#change_email\").on(\"click\", (e) => {\n        e.preventDefault();\n        e.stopPropagation();\n        if (!page_params.realm_email_changes_disabled || page_params.is_admin) {\n            dialog_widget.launch({\n                html_heading: $t_html({defaultMessage: \"Change email\"}),\n                html_body: render_change_email_modal(),\n                html_submit_button: $t_html({defaultMessage: \"Change\"}),\n                loading_spinner: true,\n                id: \"change_email_modal\",\n                form_id: \"change_email_container\",\n                on_click: do_change_email,\n                post_render: change_email_post_render,\n                on_shown: () => {\n                    $(\"#change_email_container input\").trigger(\"focus\");\n                },\n            });\n        }\n    });\n\n    $(\"#profile-settings\").on(\"click\", \".custom_user_field .remove_date\", (e) => {\n        e.preventDefault();\n        e.stopPropagation();\n        const field = $(e.target).closest(\".custom_user_field\").expectOne();\n        const field_id = Number.parseInt($(field).attr(\"data-field-id\"), 10);\n        update_user_custom_profile_fields([field_id], channel.del);\n    });\n\n    $(\"#profile-settings\").on(\"change\", \".custom_user_field_value\", function (e) {\n        const fields = [];\n        const value = $(this).val();\n        const field_id = Number.parseInt(\n            $(e.target).closest(\".custom_user_field\").attr(\"data-field-id\"),\n            10,\n        );\n        if (value) {\n            fields.push({id: field_id, value});\n            update_user_custom_profile_fields(fields, channel.patch);\n        } else {\n            fields.push(field_id);\n            update_user_custom_profile_fields(fields, channel.del);\n        }\n    });\n\n    $(\"#user_deactivate_account_button\").on(\"click\", (e) => {\n        // This click event must not get propagated to parent container otherwise the modal\n        // will not show up because of a call to `close_active_modal` in `settings.js`.\n        e.preventDefault();\n        e.stopPropagation();\n\n        function handle_confirm() {\n            channel.del({\n                url: \"/json/users/me\",\n                success() {\n                    dialog_widget.hide_dialog_spinner();\n                    dialog_widget.close_modal();\n                    window.location.href = \"/login/\";\n                },\n                error(xhr) {\n                    const error_last_owner = $t_html({\n                        defaultMessage: \"Error: Cannot deactivate the only organization owner.\",\n                    });\n                    const error_last_user = $t_html(\n                        {\n                            defaultMessage:\n                                \"Error: Cannot deactivate the only user. You can deactivate the whole organization though in your <z-link>organization profile settings</z-link>.\",\n                        },\n                        {\n                            \"z-link\": (content_html) =>\n                                `<a target=\"_blank\" href=\"/#organization/organization-profile\">${content_html}</a>`,\n                        },\n                    );\n                    let rendered_error_msg;\n                    if (xhr.responseJSON.code === \"CANNOT_DEACTIVATE_LAST_USER\") {\n                        if (xhr.responseJSON.is_last_owner) {\n                            rendered_error_msg = error_last_owner;\n                        } else {\n                            rendered_error_msg = error_last_user;\n                        }\n                    }\n                    dialog_widget.hide_dialog_spinner();\n                    dialog_widget.close_modal();\n                    $(\"#account-settings-status\")\n                        .addClass(\"alert-error\")\n                        .html(rendered_error_msg)\n                        .show();\n                },\n            });\n        }\n        const html_body = render_confirm_deactivate_own_user();\n        confirm_dialog.launch({\n            html_heading: $t_html({defaultMessage: \"Deactivate your account\"}),\n            html_body,\n            on_click: handle_confirm,\n            help_link: \"/help/deactivate-your-account\",\n            loading_spinner: true,\n        });\n    });\n\n    $(\"#show_my_user_profile_modal\").on(\"click\", () => {\n        overlays.close_overlay(\"settings\");\n        const user = people.get_by_user_id(people.my_current_user_id());\n        setTimeout(() => {\n            user_profile.show_user_profile(user);\n        }, 100);\n\n        // If user opened the \"preview profile\" modal from user\n        // settings, then closing preview profile modal should\n        // send them back to the settings modal.\n        $(\"body\").one(\"hidden.bs.modal\", \"#user-profile-modal\", (e) => {\n            e.preventDefault();\n            e.stopPropagation();\n\n            setTimeout(() => {\n                if (!overlays.settings_open()) {\n                    overlays.open_settings();\n                }\n            }, 100);\n        });\n    });\n\n    function upload_avatar(file_input) {\n        const form_data = new FormData();\n\n        form_data.append(\"csrfmiddlewaretoken\", csrf_token);\n        for (const [i, file] of Array.prototype.entries.call(file_input[0].files)) {\n            form_data.append(\"file-\" + i, file);\n        }\n        display_avatar_upload_started();\n        channel.post({\n            url: \"/json/users/me/avatar\",\n            data: form_data,\n            cache: false,\n            processData: false,\n            contentType: false,\n            success() {\n                display_avatar_upload_complete();\n                $(\"#user-avatar-upload-widget .image_file_input_error\").hide();\n                $(\"#user-avatar-source\").hide();\n                // Rest of the work is done via the user_events -> avatar_url event we will get\n            },\n            error(xhr) {\n                display_avatar_upload_complete();\n                if (page_params.avatar_source === \"G\") {\n                    $(\"#user-avatar-source\").show();\n                }\n                const $error = $(\"#user-avatar-upload-widget .image_file_input_error\");\n                $error.text(JSON.parse(xhr.responseText).msg);\n                $error.show();\n            },\n        });\n    }\n\n    avatar.build_user_avatar_widget(upload_avatar);\n\n    $(\"#user_timezone\").val(user_settings.timezone);\n\n    $(\"#user_timezone\").on(\"change\", function (e) {\n        e.preventDefault();\n        e.stopPropagation();\n\n        const data = {timezone: this.value};\n\n        settings_ui.do_settings_change(\n            channel.patch,\n            \"/json/settings\",\n            data,\n            $(\".timezone-setting-status\").expectOne(),\n        );\n    });\n\n    $(\"#privacy_settings_box\").on(\"change\", \"input\", (e) => {\n        e.preventDefault();\n        e.stopPropagation();\n\n        const input_elem = $(e.currentTarget);\n        const setting_name = input_elem.attr(\"name\");\n        const checked = input_elem.prop(\"checked\");\n\n        const data = {[setting_name]: checked};\n        settings_ui.do_settings_change(\n            channel.patch,\n            \"/json/settings\",\n            data,\n            $(\"#account-settings .privacy-setting-status\").expectOne(),\n        );\n    });\n}\n", "import time\nfrom datetime import datetime, timezone\nfrom typing import Any, Dict\nfrom unittest import mock\n\nimport orjson\nfrom django.http import HttpRequest, HttpResponse\nfrom django.test import override_settings\n\nfrom zerver.lib.initial_password import initial_password\nfrom zerver.lib.rate_limiter import add_ratelimit_rule, remove_ratelimit_rule\nfrom zerver.lib.test_classes import ZulipTestCase\nfrom zerver.lib.test_helpers import get_test_image_file\nfrom zerver.lib.users import get_all_api_keys\nfrom zerver.models import (\n    Draft,\n    NotificationTriggers,\n    ScheduledMessageNotificationEmail,\n    UserProfile,\n    get_user_profile_by_api_key,\n)\n\n\nclass ChangeSettingsTest(ZulipTestCase):\n    # TODO: requires method consolidation, right now, there's no alternative\n    # for check_for_toggle_param for PATCH.\n    def check_for_toggle_param_patch(self, pattern: str, param: str) -> None:\n        self.login(\"hamlet\")\n        user_profile = self.example_user(\"hamlet\")\n        json_result = self.client_patch(pattern, {param: orjson.dumps(True).decode()})\n        self.assert_json_success(json_result)\n        # refetch user_profile object to correctly handle caching\n        user_profile = self.example_user(\"hamlet\")\n        self.assertEqual(getattr(user_profile, param), True)\n\n        json_result = self.client_patch(pattern, {param: orjson.dumps(False).decode()})\n        self.assert_json_success(json_result)\n        # refetch user_profile object to correctly handle caching\n        user_profile = self.example_user(\"hamlet\")\n        self.assertEqual(getattr(user_profile, param), False)\n\n    def test_successful_change_settings(self) -> None:\n        \"\"\"\n        A call to /json/settings with valid parameters changes the user's\n        settings correctly and returns correct values.\n        \"\"\"\n        user = self.example_user(\"hamlet\")\n        self.login_user(user)\n        json_result = self.client_patch(\n            \"/json/settings\",\n            dict(\n                full_name=\"Foo Bar\",\n                old_password=initial_password(user.delivery_email),\n                new_password=\"foobar1\",\n            ),\n        )\n        self.assert_json_success(json_result)\n\n        user.refresh_from_db()\n        self.assertEqual(user.full_name, \"Foo Bar\")\n        self.logout()\n\n        # This is one of the few places we log in directly\n        # with Django's client (to test the password change\n        # with as few moving parts as possible).\n        request = HttpRequest()\n        request.session = self.client.session\n        self.assertTrue(\n            self.client.login(\n                request=request,\n                username=user.delivery_email,\n                password=\"foobar1\",\n                realm=user.realm,\n            ),\n        )\n        self.assert_logged_in_user_id(user.id)\n\n    def test_password_change_check_strength(self) -> None:\n        self.login(\"hamlet\")\n        with self.settings(PASSWORD_MIN_LENGTH=3, PASSWORD_MIN_GUESSES=1000):\n            json_result = self.client_patch(\n                \"/json/settings\",\n                dict(\n                    full_name=\"Foo Bar\",\n                    old_password=initial_password(self.example_email(\"hamlet\")),\n                    new_password=\"easy\",\n                ),\n            )\n            self.assert_json_error(json_result, \"New password is too weak!\")\n\n            json_result = self.client_patch(\n                \"/json/settings\",\n                dict(\n                    full_name=\"Foo Bar\",\n                    old_password=initial_password(self.example_email(\"hamlet\")),\n                    new_password=\"f657gdGGk9\",\n                ),\n            )\n            self.assert_json_success(json_result)\n\n    def test_illegal_name_changes(self) -> None:\n        user = self.example_user(\"hamlet\")\n        self.login_user(user)\n        full_name = user.full_name\n\n        with self.settings(NAME_CHANGES_DISABLED=True):\n            json_result = self.client_patch(\"/json/settings\", dict(full_name=\"Foo Bar\"))\n\n        # We actually fail silently here, since this only happens if\n        # somebody is trying to game our API, and there's no reason to\n        # give them the courtesy of an error reason.\n        self.assert_json_success(json_result)\n\n        user = self.example_user(\"hamlet\")\n        self.assertEqual(user.full_name, full_name)\n\n        # Now try a too-long name\n        json_result = self.client_patch(\"/json/settings\", dict(full_name=\"x\" * 1000))\n        self.assert_json_error(json_result, \"Name too long!\")\n\n        # Now try a too-short name\n        json_result = self.client_patch(\"/json/settings\", dict(full_name=\"x\"))\n        self.assert_json_error(json_result, \"Name too short!\")\n\n    def test_illegal_characters_in_name_changes(self) -> None:\n        self.login(\"hamlet\")\n\n        # Now try a name with invalid characters\n        json_result = self.client_patch(\"/json/settings\", dict(full_name=\"Opheli*\"))\n        self.assert_json_error(json_result, \"Invalid characters in name!\")\n\n    def test_change_email_to_disposable_email(self) -> None:\n        hamlet = self.example_user(\"hamlet\")\n        self.login_user(hamlet)\n        realm = hamlet.realm\n        realm.disallow_disposable_email_addresses = True\n        realm.emails_restricted_to_domains = False\n        realm.save()\n\n        json_result = self.client_patch(\"/json/settings\", dict(email=\"hamlet@mailnator.com\"))\n        self.assert_json_error(json_result, \"Please use your real email address.\")\n\n    def test_change_email_batching_period(self) -> None:\n        hamlet = self.example_user(\"hamlet\")\n        cordelia = self.example_user(\"cordelia\")\n        othello = self.example_user(\"othello\")\n        self.login_user(hamlet)\n\n        # Default is two minutes\n        self.assertEqual(hamlet.email_notifications_batching_period_seconds, 120)\n\n        result = self.client_patch(\n            \"/json/settings\", {\"email_notifications_batching_period_seconds\": -1}\n        )\n        self.assert_json_error(result, \"Invalid email batching period: -1 seconds\")\n\n        result = self.client_patch(\n            \"/json/settings\", {\"email_notifications_batching_period_seconds\": 7 * 24 * 60 * 60 + 10}\n        )\n        self.assert_json_error(result, \"Invalid email batching period: 604810 seconds\")\n\n        result = self.client_patch(\n            \"/json/settings\", {\"email_notifications_batching_period_seconds\": 5 * 60}\n        )\n        self.assert_json_success(result)\n        hamlet = self.example_user(\"hamlet\")\n        self.assertEqual(hamlet.email_notifications_batching_period_seconds, 300)\n\n        # Test that timestamps get updated for existing ScheduledMessageNotificationEmail rows\n        hamlet_msg_id1 = self.send_stream_message(sender=cordelia, stream_name=\"Verona\")\n        hamlet_msg_id2 = self.send_stream_message(sender=cordelia, stream_name=\"Verona\")\n        othello_msg_id1 = self.send_stream_message(sender=cordelia, stream_name=\"Verona\")\n\n        def create_entry(user_profile_id: int, message_id: int, timestamp: datetime) -> int:\n            # The above messages don't actually mention anyone. We just fill up the trigger\n            # because we need to.\n            entry = ScheduledMessageNotificationEmail.objects.create(\n                user_profile_id=user_profile_id,\n                message_id=message_id,\n                trigger=NotificationTriggers.MENTION,\n                scheduled_timestamp=timestamp,\n            )\n            return entry.id\n\n        def get_datetime_object(minutes: int) -> datetime:\n            return datetime(\n                year=2021, month=8, day=10, hour=10, minute=minutes, second=15, tzinfo=timezone.utc\n            )\n\n        hamlet_timestamp = get_datetime_object(10)\n        othello_timestamp = get_datetime_object(20)\n\n        hamlet_entry1_id = create_entry(hamlet.id, hamlet_msg_id1, hamlet_timestamp)\n        hamlet_entry2_id = create_entry(hamlet.id, hamlet_msg_id2, hamlet_timestamp)\n        othello_entry1_id = create_entry(othello.id, othello_msg_id1, othello_timestamp)\n\n        # Update Hamlet's setting from 300 seconds (5 minutes) to 600 seconds (10 minutes)\n        self.assertEqual(hamlet.email_notifications_batching_period_seconds, 300)\n        result = self.client_patch(\n            \"/json/settings\", {\"email_notifications_batching_period_seconds\": 10 * 60}\n        )\n        self.assert_json_success(result)\n        hamlet = self.example_user(\"hamlet\")\n        self.assertEqual(hamlet.email_notifications_batching_period_seconds, 10 * 60)\n\n        def check_scheduled_timestamp(entry_id: int, expected_timestamp: datetime) -> None:\n            entry = ScheduledMessageNotificationEmail.objects.get(id=entry_id)\n            self.assertEqual(entry.scheduled_timestamp, expected_timestamp)\n\n        # For Hamlet, the new scheduled timestamp should have been updated\n        expected_hamlet_timestamp = get_datetime_object(15)\n        check_scheduled_timestamp(hamlet_entry1_id, expected_hamlet_timestamp)\n        check_scheduled_timestamp(hamlet_entry2_id, expected_hamlet_timestamp)\n\n        # Nothing should have changed for Othello\n        check_scheduled_timestamp(othello_entry1_id, othello_timestamp)\n\n    def test_toggling_boolean_user_settings(self) -> None:\n        \"\"\"Test updating each boolean setting in UserProfile property_types\"\"\"\n        boolean_settings = (\n            s for s in UserProfile.property_types if UserProfile.property_types[s] is bool\n        )\n        for user_setting in boolean_settings:\n            self.check_for_toggle_param_patch(\"/json/settings\", user_setting)\n\n    def test_wrong_old_password(self) -> None:\n        self.login(\"hamlet\")\n        result = self.client_patch(\n            \"/json/settings\",\n            dict(\n                old_password=\"bad_password\",\n                new_password=\"ignored\",\n            ),\n        )\n        self.assert_json_error(result, \"Wrong password!\")\n\n    def test_wrong_old_password_rate_limiter(self) -> None:\n        self.login(\"hamlet\")\n        with self.settings(RATE_LIMITING_AUTHENTICATE=True):\n            add_ratelimit_rule(10, 2, domain=\"authenticate_by_username\")\n            start_time = time.time()\n            with mock.patch(\"time.time\", return_value=start_time):\n                result = self.client_patch(\n                    \"/json/settings\",\n                    dict(\n                        old_password=\"bad_password\",\n                        new_password=\"ignored\",\n                    ),\n                )\n                self.assert_json_error(result, \"Wrong password!\")\n                result = self.client_patch(\n                    \"/json/settings\",\n                    dict(\n                        old_password=\"bad_password\",\n                        new_password=\"ignored\",\n                    ),\n                )\n                self.assert_json_error(result, \"Wrong password!\")\n\n                # We're over the limit, so we'll get blocked even with the correct password.\n                result = self.client_patch(\n                    \"/json/settings\",\n                    dict(\n                        old_password=initial_password(self.example_email(\"hamlet\")),\n                        new_password=\"ignored\",\n                    ),\n                )\n                self.assert_json_error(\n                    result, \"You're making too many attempts! Try again in 10 seconds.\"\n                )\n\n            # After time passes, we should be able to succeed if we give the correct password.\n            with mock.patch(\"time.time\", return_value=start_time + 11):\n                json_result = self.client_patch(\n                    \"/json/settings\",\n                    dict(\n                        old_password=initial_password(self.example_email(\"hamlet\")),\n                        new_password=\"foobar1\",\n                    ),\n                )\n                self.assert_json_success(json_result)\n\n            remove_ratelimit_rule(10, 2, domain=\"authenticate_by_username\")\n\n    @override_settings(\n        AUTHENTICATION_BACKENDS=(\n            \"zproject.backends.ZulipLDAPAuthBackend\",\n            \"zproject.backends.EmailAuthBackend\",\n            \"zproject.backends.ZulipDummyBackend\",\n        )\n    )\n    def test_change_password_ldap_backend(self) -> None:\n        self.init_default_ldap_database()\n        ldap_user_attr_map = {\"full_name\": \"cn\", \"short_name\": \"sn\"}\n\n        self.login(\"hamlet\")\n\n        with self.settings(\n            LDAP_APPEND_DOMAIN=\"zulip.com\", AUTH_LDAP_USER_ATTR_MAP=ldap_user_attr_map\n        ):\n            result = self.client_patch(\n                \"/json/settings\",\n                dict(\n                    old_password=initial_password(self.example_email(\"hamlet\")),\n                    new_password=\"ignored\",\n                ),\n            )\n            self.assert_json_error(result, \"Your Zulip password is managed in LDAP\")\n\n            result = self.client_patch(\n                \"/json/settings\",\n                dict(\n                    old_password=self.ldap_password(\"hamlet\"),  # hamlet's password in LDAP\n                    new_password=\"ignored\",\n                ),\n            )\n            self.assert_json_error(result, \"Your Zulip password is managed in LDAP\")\n\n        with self.settings(\n            LDAP_APPEND_DOMAIN=\"example.com\", AUTH_LDAP_USER_ATTR_MAP=ldap_user_attr_map\n        ), self.assertLogs(\"zulip.ldap\", \"DEBUG\") as debug_log:\n            result = self.client_patch(\n                \"/json/settings\",\n                dict(\n                    old_password=initial_password(self.example_email(\"hamlet\")),\n                    new_password=\"ignored\",\n                ),\n            )\n            self.assert_json_success(result)\n            self.assertEqual(\n                debug_log.output,\n                [\n                    \"DEBUG:zulip.ldap:ZulipLDAPAuthBackend: Email hamlet@zulip.com does not match LDAP domain example.com.\"\n                ],\n            )\n\n        with self.settings(LDAP_APPEND_DOMAIN=None, AUTH_LDAP_USER_ATTR_MAP=ldap_user_attr_map):\n            result = self.client_patch(\n                \"/json/settings\",\n                dict(\n                    old_password=initial_password(self.example_email(\"hamlet\")),\n                    new_password=\"ignored\",\n                ),\n            )\n            self.assert_json_error(result, \"Your Zulip password is managed in LDAP\")\n\n    def do_test_change_user_setting(self, setting_name: str) -> None:\n\n        test_changes: Dict[str, Any] = dict(\n            default_language=\"de\",\n            default_view=\"all_messages\",\n            emojiset=\"google\",\n            timezone=\"America/Denver\",\n            demote_inactive_streams=2,\n            color_scheme=2,\n            email_notifications_batching_period_seconds=100,\n            notification_sound=\"ding\",\n            desktop_icon_count_display=2,\n        )\n\n        self.login(\"hamlet\")\n        test_value = test_changes.get(setting_name)\n        # Error if a setting in UserProfile.property_types does not have test values\n        if test_value is None:\n            raise AssertionError(f\"No test created for {setting_name}\")\n\n        if setting_name not in [\"demote_inactive_streams\", \"color_scheme\"]:\n            data = {setting_name: test_value}\n        else:\n            data = {setting_name: orjson.dumps(test_value).decode()}\n\n        result = self.client_patch(\"/json/settings\", data)\n        self.assert_json_success(result)\n        user_profile = self.example_user(\"hamlet\")\n        self.assertEqual(getattr(user_profile, setting_name), test_value)\n\n    def test_change_user_setting(self) -> None:\n        \"\"\"Test updating each non-boolean setting in UserProfile property_types\"\"\"\n        user_settings = (\n            s for s in UserProfile.property_types if UserProfile.property_types[s] is not bool\n        )\n        for setting in user_settings:\n            self.do_test_change_user_setting(setting)\n        self.do_test_change_user_setting(\"timezone\")\n\n    def test_invalid_setting_value(self) -> None:\n        invalid_values_dict = dict(\n            default_language=\"invalid_de\",\n            default_view=\"invalid_view\",\n            emojiset=\"apple\",\n            timezone=\"invalid_US/Mountain\",\n            demote_inactive_streams=10,\n            color_scheme=10,\n            notification_sound=\"invalid_sound\",\n            desktop_icon_count_display=10,\n        )\n\n        self.login(\"hamlet\")\n        for setting_name in invalid_values_dict.keys():\n            invalid_value = invalid_values_dict.get(setting_name)\n            if isinstance(invalid_value, str):\n                invalid_value = orjson.dumps(invalid_value).decode()\n\n            req = {setting_name: invalid_value}\n            result = self.client_patch(\"/json/settings\", req)\n\n            expected_error_msg = f\"Invalid {setting_name}\"\n            if setting_name == \"notification_sound\":\n                expected_error_msg = f\"Invalid notification sound '{invalid_value}'\"\n            self.assert_json_error(result, expected_error_msg)\n            hamlet = self.example_user(\"hamlet\")\n            self.assertNotEqual(getattr(hamlet, setting_name), invalid_value)\n\n    def do_change_emojiset(self, emojiset: str) -> HttpResponse:\n        self.login(\"hamlet\")\n        data = {\"emojiset\": emojiset}\n        result = self.client_patch(\"/json/settings\", data)\n        return result\n\n    def test_emojiset(self) -> None:\n        \"\"\"Test banned emoji sets are not accepted.\"\"\"\n        banned_emojisets = [\"apple\", \"emojione\"]\n        valid_emojisets = [\"google\", \"google-blob\", \"text\", \"twitter\"]\n\n        for emojiset in banned_emojisets:\n            result = self.do_change_emojiset(emojiset)\n            self.assert_json_error(result, \"Invalid emojiset\")\n\n        for emojiset in valid_emojisets:\n            result = self.do_change_emojiset(emojiset)\n            self.assert_json_success(result)\n\n    def test_avatar_changes_disabled(self) -> None:\n        self.login(\"hamlet\")\n\n        with self.settings(AVATAR_CHANGES_DISABLED=True):\n            result = self.client_delete(\"/json/users/me/avatar\")\n            self.assert_json_error(result, \"Avatar changes are disabled in this organization.\", 400)\n\n        with self.settings(AVATAR_CHANGES_DISABLED=True):\n            with get_test_image_file(\"img.png\") as fp1:\n                result = self.client_post(\"/json/users/me/avatar\", {\"f1\": fp1})\n            self.assert_json_error(result, \"Avatar changes are disabled in this organization.\", 400)\n\n    def test_invalid_setting_name(self) -> None:\n        self.login(\"hamlet\")\n\n        # Now try an invalid setting name\n        json_result = self.client_patch(\"/json/settings\", dict(invalid_setting=\"value\"))\n        self.assert_json_success(json_result)\n\n        result = orjson.loads(json_result.content)\n        self.assertIn(\"ignored_parameters_unsupported\", result)\n        self.assertEqual(result[\"ignored_parameters_unsupported\"], [\"invalid_setting\"])\n\n    def test_changing_setting_using_display_setting_endpoint(self) -> None:\n        \"\"\"\n        This test is just for adding coverage for `/settings/display` endpoint which is\n        now deprecated.\n        \"\"\"\n        self.login(\"hamlet\")\n\n        result = self.client_patch(\n            \"/json/settings/display\", dict(color_scheme=UserProfile.COLOR_SCHEME_NIGHT)\n        )\n        self.assert_json_success(result)\n        hamlet = self.example_user(\"hamlet\")\n        self.assertEqual(hamlet.color_scheme, UserProfile.COLOR_SCHEME_NIGHT)\n\n    def test_changing_setting_using_notification_setting_endpoint(self) -> None:\n        \"\"\"\n        This test is just for adding coverage for `/settings/notifications` endpoint which is\n        now deprecated.\n        \"\"\"\n        self.login(\"hamlet\")\n\n        result = self.client_patch(\n            \"/json/settings/notifications\",\n            dict(enable_stream_desktop_notifications=orjson.dumps(True).decode()),\n        )\n        self.assert_json_success(result)\n        hamlet = self.example_user(\"hamlet\")\n        self.assertEqual(hamlet.enable_stream_desktop_notifications, True)\n\n\nclass UserChangesTest(ZulipTestCase):\n    def test_update_api_key(self) -> None:\n        user = self.example_user(\"hamlet\")\n        email = user.email\n\n        self.login_user(user)\n        old_api_keys = get_all_api_keys(user)\n        # Ensure the old API keys are in the authentication cache, so\n        # that the below logic can test whether we have a cache-flushing bug.\n        for api_key in old_api_keys:\n            self.assertEqual(get_user_profile_by_api_key(api_key).email, email)\n\n        # First verify this endpoint is not registered in the /json/... path\n        # to prevent access with only a session.\n        result = self.client_post(\"/json/users/me/api_key/regenerate\")\n        self.assertEqual(result.status_code, 404)\n\n        # A logged-in session doesn't allow access to an /api/v1/ endpoint\n        # of course.\n        result = self.client_post(\"/api/v1/users/me/api_key/regenerate\")\n        self.assertEqual(result.status_code, 401)\n\n        result = self.api_post(user, \"/api/v1/users/me/api_key/regenerate\")\n        self.assert_json_success(result)\n        new_api_key = result.json()[\"api_key\"]\n        self.assertNotIn(new_api_key, old_api_keys)\n        user = self.example_user(\"hamlet\")\n        current_api_keys = get_all_api_keys(user)\n        self.assertIn(new_api_key, current_api_keys)\n\n        for api_key in old_api_keys:\n            with self.assertRaises(UserProfile.DoesNotExist):\n                get_user_profile_by_api_key(api_key)\n\n        for api_key in current_api_keys:\n            self.assertEqual(get_user_profile_by_api_key(api_key).email, email)\n\n\nclass UserDraftSettingsTests(ZulipTestCase):\n    def test_enable_drafts_syncing(self) -> None:\n        hamlet = self.example_user(\"hamlet\")\n        hamlet.enable_drafts_synchronization = False\n        hamlet.save()\n        payload = {\"enable_drafts_synchronization\": orjson.dumps(True).decode()}\n        resp = self.api_patch(hamlet, \"/api/v1/settings\", payload)\n        self.assert_json_success(resp)\n        hamlet = self.example_user(\"hamlet\")\n        self.assertTrue(hamlet.enable_drafts_synchronization)\n\n    def test_disable_drafts_syncing(self) -> None:\n        aaron = self.example_user(\"aaron\")\n        self.assertTrue(aaron.enable_drafts_synchronization)\n\n        initial_count = Draft.objects.count()\n\n        # Create some drafts. These should be deleted once aaron disables\n        # syncing drafts.\n        visible_stream_id = self.get_stream_id(self.get_streams(aaron)[0])\n        draft_dicts = [\n            {\n                \"type\": \"stream\",\n                \"to\": [visible_stream_id],\n                \"topic\": \"thinking out loud\",\n                \"content\": \"What if pigs really could fly?\",\n                \"timestamp\": 15954790199,\n            },\n            {\n                \"type\": \"private\",\n                \"to\": [],\n                \"topic\": \"\",\n                \"content\": \"What if made it possible to sync drafts in Zulip?\",\n                \"timestamp\": 1595479020,\n            },\n        ]\n        payload = {\"drafts\": orjson.dumps(draft_dicts).decode()}\n        resp = self.api_post(aaron, \"/api/v1/drafts\", payload)\n        self.assert_json_success(resp)\n        self.assertEqual(Draft.objects.count() - initial_count, 2)\n\n        payload = {\"enable_drafts_synchronization\": orjson.dumps(False).decode()}\n        resp = self.api_patch(aaron, \"/api/v1/settings\", payload)\n        self.assert_json_success(resp)\n        aaron = self.example_user(\"aaron\")\n        self.assertFalse(aaron.enable_drafts_synchronization)\n        self.assertEqual(Draft.objects.count() - initial_count, 0)\n", "import os\nfrom typing import List, Union\n\nfrom django.conf import settings\nfrom django.conf.urls import include\nfrom django.conf.urls.i18n import i18n_patterns\nfrom django.contrib.auth.views import (\n    LoginView,\n    PasswordResetCompleteView,\n    PasswordResetConfirmView,\n    PasswordResetDoneView,\n)\nfrom django.urls import path, re_path\nfrom django.urls.resolvers import URLPattern, URLResolver\nfrom django.utils.module_loading import import_string\nfrom django.views.generic import RedirectView, TemplateView\n\nfrom zerver.forms import LoggingSetPasswordForm\nfrom zerver.lib.integrations import WEBHOOK_INTEGRATIONS\nfrom zerver.lib.rest import rest_path\nfrom zerver.tornado.views import cleanup_event_queue, get_events, get_events_internal, notify\nfrom zerver.views.alert_words import add_alert_words, list_alert_words, remove_alert_words\nfrom zerver.views.attachments import list_by_user, remove\nfrom zerver.views.auth import (\n    api_fetch_api_key,\n    api_get_server_settings,\n    json_fetch_api_key,\n    log_into_subdomain,\n    login_page,\n    logout_then_login,\n    password_reset,\n    remote_user_jwt,\n    remote_user_sso,\n    saml_sp_metadata,\n    show_deactivation_notice,\n    start_remote_user_sso,\n    start_social_login,\n    start_social_signup,\n)\nfrom zerver.views.compatibility import check_global_compatibility\nfrom zerver.views.custom_profile_fields import (\n    create_realm_custom_profile_field,\n    delete_realm_custom_profile_field,\n    list_realm_custom_profile_fields,\n    remove_user_custom_profile_data,\n    reorder_realm_custom_profile_fields,\n    update_realm_custom_profile_field,\n    update_user_custom_profile_data,\n)\nfrom zerver.views.digest import digest_page\nfrom zerver.views.documentation import IntegrationView, MarkdownDirectoryView, integration_doc\nfrom zerver.views.drafts import create_drafts, delete_draft, edit_draft, fetch_drafts\nfrom zerver.views.email_mirror import email_mirror_message\nfrom zerver.views.events_register import events_register_backend\nfrom zerver.views.home import accounts_accept_terms, desktop_home, home\nfrom zerver.views.hotspots import mark_hotspot_as_read\nfrom zerver.views.invite import (\n    generate_multiuse_invite_backend,\n    get_user_invites,\n    invite_users_backend,\n    resend_user_invite_email,\n    revoke_multiuse_invite,\n    revoke_user_invite,\n)\nfrom zerver.views.message_edit import (\n    delete_message_backend,\n    get_message_edit_history,\n    json_fetch_raw_message,\n    update_message_backend,\n)\nfrom zerver.views.message_fetch import get_messages_backend, messages_in_narrow_backend\nfrom zerver.views.message_flags import (\n    mark_all_as_read,\n    mark_stream_as_read,\n    mark_topic_as_read,\n    update_message_flags,\n)\nfrom zerver.views.message_send import render_message_backend, send_message_backend, zcommand_backend\nfrom zerver.views.muting import mute_user, unmute_user, update_muted_topic\nfrom zerver.views.portico import (\n    app_download_link_redirect,\n    apps_view,\n    hello_view,\n    landing_view,\n    plans_view,\n    team_view,\n)\nfrom zerver.views.presence import (\n    get_presence_backend,\n    get_statuses_for_realm,\n    update_active_status_backend,\n    update_user_status_backend,\n)\nfrom zerver.views.push_notifications import (\n    add_android_reg_id,\n    add_apns_device_token,\n    remove_android_reg_id,\n    remove_apns_device_token,\n)\nfrom zerver.views.reactions import add_reaction, remove_reaction\nfrom zerver.views.realm import (\n    check_subdomain_available,\n    deactivate_realm,\n    realm_reactivation,\n    update_realm,\n    update_realm_user_settings_defaults,\n)\nfrom zerver.views.realm_domains import (\n    create_realm_domain,\n    delete_realm_domain,\n    list_realm_domains,\n    patch_realm_domain,\n)\nfrom zerver.views.realm_emoji import delete_emoji, list_emoji, upload_emoji\nfrom zerver.views.realm_export import delete_realm_export, export_realm, get_realm_exports\nfrom zerver.views.realm_icon import delete_icon_backend, get_icon_backend, upload_icon\nfrom zerver.views.realm_linkifiers import (\n    create_linkifier,\n    delete_linkifier,\n    list_linkifiers,\n    update_linkifier,\n)\nfrom zerver.views.realm_logo import delete_logo_backend, get_logo_backend, upload_logo\nfrom zerver.views.realm_playgrounds import add_realm_playground, delete_realm_playground\nfrom zerver.views.registration import (\n    accounts_home,\n    accounts_home_from_multiuse_invite,\n    accounts_register,\n    create_realm,\n    find_account,\n    get_prereg_key_and_redirect,\n    realm_redirect,\n)\nfrom zerver.views.report import (\n    report_csp_violations,\n    report_error,\n    report_narrow_times,\n    report_send_times,\n    report_unnarrow_times,\n)\nfrom zerver.views.storage import get_storage, remove_storage, update_storage\nfrom zerver.views.streams import (\n    add_default_stream,\n    add_subscriptions_backend,\n    create_default_stream_group,\n    deactivate_stream_backend,\n    delete_in_topic,\n    get_streams_backend,\n    get_subscribers_backend,\n    get_topics_backend,\n    json_get_stream_id,\n    list_subscriptions_backend,\n    remove_default_stream,\n    remove_default_stream_group,\n    remove_subscriptions_backend,\n    update_default_stream_group_info,\n    update_default_stream_group_streams,\n    update_stream_backend,\n    update_subscription_properties_backend,\n    update_subscriptions_backend,\n    update_subscriptions_property,\n)\nfrom zerver.views.submessage import process_submessage\nfrom zerver.views.thumbnail import backend_serve_thumbnail\nfrom zerver.views.tutorial import set_tutorial_status\nfrom zerver.views.typing import send_notification_backend\nfrom zerver.views.unsubscribe import email_unsubscribe\nfrom zerver.views.upload import (\n    serve_file_backend,\n    serve_file_url_backend,\n    serve_local_file_unauthed,\n    upload_file_backend,\n)\nfrom zerver.views.user_groups import (\n    add_user_group,\n    delete_user_group,\n    edit_user_group,\n    get_user_group,\n    update_user_group_backend,\n)\nfrom zerver.views.user_settings import (\n    confirm_email_change,\n    delete_avatar_backend,\n    json_change_settings,\n    regenerate_api_key,\n    set_avatar_backend,\n)\nfrom zerver.views.users import (\n    add_bot_backend,\n    avatar,\n    create_user_backend,\n    deactivate_bot_backend,\n    deactivate_user_backend,\n    deactivate_user_own_backend,\n    get_bots_backend,\n    get_members_backend,\n    get_profile_backend,\n    get_subscription_backend,\n    get_user_by_email,\n    patch_bot_backend,\n    reactivate_user_backend,\n    regenerate_bot_api_key,\n    update_user_backend,\n)\nfrom zerver.views.video_calls import (\n    complete_zoom_user,\n    deauthorize_zoom_user,\n    get_bigbluebutton_url,\n    join_bigbluebutton,\n    make_zoom_video_call,\n    register_zoom_user,\n)\nfrom zerver.views.zephyr import webathena_kerberos_login\nfrom zproject import dev_urls\nfrom zproject.legacy_urls import legacy_urls\n\nif settings.TWO_FACTOR_AUTHENTICATION_ENABLED:\n    from two_factor.gateways.twilio.urls import urlpatterns as tf_twilio_urls\n    from two_factor.urls import urlpatterns as tf_urls\n\n# NB: There are several other pieces of code which route requests by URL:\n#\n#   - legacy_urls.py contains API endpoint written before the redesign\n#     and should not be added to.\n#\n#   - runtornado.py has its own URL list for Tornado views.  See the\n#     invocation of web.Application in that file.\n#\n#   - The nginx config knows which URLs to route to Django or Tornado.\n#\n#   - Likewise for the local dev server in tools/run-dev.py.\n\n# These endpoints constitute the currently designed API (V1), which uses:\n# * REST verbs\n# * Basic auth (username:password is email:apiKey)\n# * Take and return json-formatted data\n#\n# If you're adding a new endpoint to the code that requires authentication,\n# please add it here.\n# See rest_dispatch in zerver.lib.rest for an explanation of auth methods used\n#\n# All of these paths are accessed by either a /json or /api/v1 prefix;\n# e.g. `PATCH /json/realm` or `PATCH /api/v1/realm`.\nv1_api_and_json_patterns = [\n    # realm-level calls\n    rest_path(\"realm\", PATCH=update_realm),\n    rest_path(\"realm/user_settings_defaults\", PATCH=update_realm_user_settings_defaults),\n    path(\"realm/subdomain/<subdomain>\", check_subdomain_available),\n    # realm/domains -> zerver.views.realm_domains\n    rest_path(\"realm/domains\", GET=list_realm_domains, POST=create_realm_domain),\n    rest_path(\"realm/domains/<domain>\", PATCH=patch_realm_domain, DELETE=delete_realm_domain),\n    # realm/emoji -> zerver.views.realm_emoji\n    rest_path(\"realm/emoji\", GET=list_emoji),\n    rest_path(\n        \"realm/emoji/<emoji_name>\",\n        POST=upload_emoji,\n        DELETE=(delete_emoji, {\"intentionally_undocumented\"}),\n    ),\n    # this endpoint throws a status code 400 JsonableError when it should be a 404.\n    # realm/icon -> zerver.views.realm_icon\n    rest_path(\"realm/icon\", POST=upload_icon, DELETE=delete_icon_backend, GET=get_icon_backend),\n    # realm/logo -> zerver.views.realm_logo\n    rest_path(\"realm/logo\", POST=upload_logo, DELETE=delete_logo_backend, GET=get_logo_backend),\n    # realm/filters and realm/linkifiers -> zerver.views.realm_linkifiers\n    rest_path(\"realm/linkifiers\", GET=list_linkifiers),\n    rest_path(\"realm/filters\", POST=create_linkifier),\n    rest_path(\"realm/filters/<int:filter_id>\", DELETE=delete_linkifier, PATCH=update_linkifier),\n    # realm/playgrounds -> zerver.views.realm_playgrounds\n    rest_path(\"realm/playgrounds\", POST=add_realm_playground),\n    rest_path(\"realm/playgrounds/<int:playground_id>\", DELETE=delete_realm_playground),\n    # realm/profile_fields -> zerver.views.custom_profile_fields\n    rest_path(\n        \"realm/profile_fields\",\n        GET=list_realm_custom_profile_fields,\n        PATCH=reorder_realm_custom_profile_fields,\n        POST=create_realm_custom_profile_field,\n    ),\n    rest_path(\n        \"realm/profile_fields/<int:field_id>\",\n        PATCH=update_realm_custom_profile_field,\n        DELETE=delete_realm_custom_profile_field,\n    ),\n    # realm/deactivate -> zerver.views.deactivate_realm\n    rest_path(\"realm/deactivate\", POST=deactivate_realm),\n    # users -> zerver.views.users\n    rest_path(\"users\", GET=get_members_backend, POST=create_user_backend),\n    rest_path(\"users/me\", GET=get_profile_backend, DELETE=deactivate_user_own_backend),\n    rest_path(\"users/<int:user_id>/reactivate\", POST=reactivate_user_backend),\n    rest_path(\n        \"users/<int:user_id>\",\n        GET=get_members_backend,\n        PATCH=update_user_backend,\n        DELETE=deactivate_user_backend,\n    ),\n    rest_path(\"users/<int:user_id>/subscriptions/<int:stream_id>\", GET=get_subscription_backend),\n    rest_path(\"users/<email>\", GET=get_user_by_email),\n    rest_path(\"bots\", GET=get_bots_backend, POST=add_bot_backend),\n    rest_path(\"bots/<int:bot_id>/api_key/regenerate\", POST=regenerate_bot_api_key),\n    rest_path(\"bots/<int:bot_id>\", PATCH=patch_bot_backend, DELETE=deactivate_bot_backend),\n    # invites -> zerver.views.invite\n    rest_path(\"invites\", GET=get_user_invites, POST=invite_users_backend),\n    rest_path(\"invites/<int:prereg_id>\", DELETE=revoke_user_invite),\n    rest_path(\"invites/<int:prereg_id>/resend\", POST=resend_user_invite_email),\n    # invites/multiuse -> zerver.views.invite\n    rest_path(\"invites/multiuse\", POST=generate_multiuse_invite_backend),\n    # invites/multiuse -> zerver.views.invite\n    rest_path(\"invites/multiuse/<int:invite_id>\", DELETE=revoke_multiuse_invite),\n    # mark messages as read (in bulk)\n    rest_path(\"mark_all_as_read\", POST=mark_all_as_read),\n    rest_path(\"mark_stream_as_read\", POST=mark_stream_as_read),\n    rest_path(\"mark_topic_as_read\", POST=mark_topic_as_read),\n    rest_path(\"zcommand\", POST=zcommand_backend),\n    # Endpoints for syncing drafts.\n    rest_path(\"drafts\", GET=fetch_drafts, POST=create_drafts),\n    rest_path(\"drafts/<int:draft_id>\", PATCH=edit_draft, DELETE=delete_draft),\n    # messages -> zerver.views.message*\n    # GET returns messages, possibly filtered, POST sends a message\n    rest_path(\n        \"messages\",\n        GET=(get_messages_backend, {\"allow_anonymous_user_web\"}),\n        POST=(send_message_backend, {\"allow_incoming_webhooks\"}),\n    ),\n    rest_path(\n        \"messages/<int:message_id>\",\n        GET=(json_fetch_raw_message, {\"allow_anonymous_user_web\"}),\n        PATCH=update_message_backend,\n        DELETE=delete_message_backend,\n    ),\n    rest_path(\"messages/render\", POST=render_message_backend),\n    rest_path(\"messages/flags\", POST=update_message_flags),\n    rest_path(\"messages/<int:message_id>/history\", GET=get_message_edit_history),\n    rest_path(\"messages/matches_narrow\", GET=messages_in_narrow_backend),\n    rest_path(\"users/me/subscriptions/properties\", POST=update_subscription_properties_backend),\n    rest_path(\"users/me/subscriptions/<int:stream_id>\", PATCH=update_subscriptions_property),\n    rest_path(\"submessage\", POST=process_submessage),\n    # New endpoint for handling reactions.\n    # reactions -> zerver.view.reactions\n    # POST adds a reaction to a message\n    # DELETE removes a reaction from a message\n    rest_path(\"messages/<int:message_id>/reactions\", POST=add_reaction, DELETE=remove_reaction),\n    # attachments -> zerver.views.attachments\n    rest_path(\"attachments\", GET=list_by_user),\n    rest_path(\"attachments/<int:attachment_id>\", DELETE=remove),\n    # typing -> zerver.views.typing\n    # POST sends a typing notification event to recipients\n    rest_path(\"typing\", POST=send_notification_backend),\n    # user_uploads -> zerver.views.upload\n    rest_path(\"user_uploads\", POST=upload_file_backend),\n    rest_path(\n        \"user_uploads/<realm_id_str>/<path:filename>\",\n        GET=(serve_file_url_backend, {\"override_api_url_scheme\"}),\n    ),\n    # bot_storage -> zerver.views.storage\n    rest_path(\"bot_storage\", PUT=update_storage, GET=get_storage, DELETE=remove_storage),\n    # Endpoint used by mobile devices to register their push\n    # notification credentials\n    rest_path(\n        \"users/me/apns_device_token\", POST=add_apns_device_token, DELETE=remove_apns_device_token\n    ),\n    rest_path(\"users/me/android_gcm_reg_id\", POST=add_android_reg_id, DELETE=remove_android_reg_id),\n    # users/*/presence => zerver.views.presence.\n    rest_path(\"users/me/presence\", POST=update_active_status_backend),\n    # It's important that this sit after users/me/presence so that\n    # Django's URL resolution order doesn't break the\n    # /users/me/presence endpoint.\n    rest_path(\"users/<user_id_or_email>/presence\", GET=get_presence_backend),\n    rest_path(\"realm/presence\", GET=get_statuses_for_realm),\n    rest_path(\"users/me/status\", POST=update_user_status_backend),\n    # user_groups -> zerver.views.user_groups\n    rest_path(\"user_groups\", GET=get_user_group),\n    rest_path(\"user_groups/create\", POST=add_user_group),\n    rest_path(\"user_groups/<int:user_group_id>\", PATCH=edit_user_group, DELETE=delete_user_group),\n    rest_path(\"user_groups/<int:user_group_id>/members\", POST=update_user_group_backend),\n    # users/me -> zerver.views.user_settings\n    rest_path(\"users/me/avatar\", POST=set_avatar_backend, DELETE=delete_avatar_backend),\n    # users/me/hotspots -> zerver.views.hotspots\n    rest_path(\n        \"users/me/hotspots\",\n        POST=(\n            mark_hotspot_as_read,\n            # This endpoint is low priority for documentation as\n            # it is part of the web app-specific tutorial.\n            {\"intentionally_undocumented\"},\n        ),\n    ),\n    # users/me/tutorial_status -> zerver.views.tutorial\n    rest_path(\n        \"users/me/tutorial_status\",\n        POST=(\n            set_tutorial_status,\n            # This is a relic of an old Zulip tutorial model and\n            # should be deleted.\n            {\"intentionally_undocumented\"},\n        ),\n    ),\n    # settings -> zerver.views.user_settings\n    rest_path(\"settings\", PATCH=json_change_settings),\n    # These next two are legacy aliases for /settings, from before\n    # we merged the endpoints. They are documented in the `/json/settings`\n    # documentation, rather than having dedicated pages.\n    rest_path(\"settings/display\", PATCH=(json_change_settings, {\"intentionally_undocumented\"})),\n    rest_path(\n        \"settings/notifications\", PATCH=(json_change_settings, {\"intentionally_undocumented\"})\n    ),\n    # users/me/alert_words -> zerver.views.alert_words\n    rest_path(\n        \"users/me/alert_words\",\n        GET=list_alert_words,\n        POST=add_alert_words,\n        DELETE=remove_alert_words,\n    ),\n    # users/me/custom_profile_data -> zerver.views.custom_profile_data\n    rest_path(\n        \"users/me/profile_data\",\n        PATCH=update_user_custom_profile_data,\n        DELETE=remove_user_custom_profile_data,\n    ),\n    rest_path(\n        \"users/me/<int:stream_id>/topics\", GET=(get_topics_backend, {\"allow_anonymous_user_web\"})\n    ),\n    # streams -> zerver.views.streams\n    # (this API is only used externally)\n    rest_path(\"streams\", GET=get_streams_backend),\n    # GET returns `stream_id`, stream name should be encoded in the URL query (in `stream` param)\n    rest_path(\"get_stream_id\", GET=json_get_stream_id),\n    # GET returns \"stream info\" (undefined currently?), HEAD returns whether stream exists (200 or 404)\n    rest_path(\"streams/<int:stream_id>/members\", GET=get_subscribers_backend),\n    rest_path(\n        \"streams/<int:stream_id>\", PATCH=update_stream_backend, DELETE=deactivate_stream_backend\n    ),\n    # Delete topic in stream\n    rest_path(\"streams/<int:stream_id>/delete_topic\", POST=delete_in_topic),\n    rest_path(\"default_streams\", POST=add_default_stream, DELETE=remove_default_stream),\n    rest_path(\"default_stream_groups/create\", POST=create_default_stream_group),\n    rest_path(\n        \"default_stream_groups/<int:group_id>\",\n        PATCH=update_default_stream_group_info,\n        DELETE=remove_default_stream_group,\n    ),\n    rest_path(\n        \"default_stream_groups/<int:group_id>/streams\", PATCH=update_default_stream_group_streams\n    ),\n    # GET lists your streams, POST bulk adds, PATCH bulk modifies/removes\n    rest_path(\n        \"users/me/subscriptions\",\n        GET=list_subscriptions_backend,\n        POST=add_subscriptions_backend,\n        PATCH=update_subscriptions_backend,\n        DELETE=remove_subscriptions_backend,\n    ),\n    # muting -> zerver.views.muting\n    rest_path(\"users/me/subscriptions/muted_topics\", PATCH=update_muted_topic),\n    rest_path(\"users/me/muted_users/<int:muted_user_id>\", POST=mute_user, DELETE=unmute_user),\n    # used to register for an event queue in tornado\n    rest_path(\"register\", POST=events_register_backend),\n    # events -> zerver.tornado.views\n    rest_path(\"events\", GET=get_events, DELETE=cleanup_event_queue),\n    # report -> zerver.views.report\n    #\n    # These endpoints are for internal error/performance reporting\n    # from the browser to the web app, and we don't expect to ever\n    # include in our API documentation.\n    rest_path(\n        \"report/error\",\n        # Logged-out browsers can hit this endpoint, for portico page JS exceptions.\n        POST=(report_error, {\"allow_anonymous_user_web\", \"intentionally_undocumented\"}),\n    ),\n    rest_path(\"report/send_times\", POST=(report_send_times, {\"intentionally_undocumented\"})),\n    rest_path(\n        \"report/narrow_times\",\n        POST=(report_narrow_times, {\"allow_anonymous_user_web\", \"intentionally_undocumented\"}),\n    ),\n    rest_path(\n        \"report/unnarrow_times\",\n        POST=(report_unnarrow_times, {\"allow_anonymous_user_web\", \"intentionally_undocumented\"}),\n    ),\n    # Used to generate a Zoom video call URL\n    rest_path(\"calls/zoom/create\", POST=make_zoom_video_call),\n    # Used to generate a BigBlueButton video call URL\n    rest_path(\"calls/bigbluebutton/create\", GET=get_bigbluebutton_url),\n    # export/realm -> zerver.views.realm_export\n    rest_path(\"export/realm\", POST=export_realm, GET=get_realm_exports),\n    rest_path(\"export/realm/<int:export_id>\", DELETE=delete_realm_export),\n]\n\nintegrations_view = IntegrationView.as_view()\n\n# These views serve pages (HTML). As such, their internationalization\n# must depend on the URL.\n#\n# If you're adding a new page to the website (as opposed to a new\n# endpoint for use by code), you should add it here.\ni18n_urls = [\n    path(\"\", home, name=\"home\"),\n    # We have a desktop-specific landing page in case we change our /\n    # to not log in in the future. We don't want to require a new\n    # desktop app build for everyone in that case\n    path(\"desktop_home/\", desktop_home),\n    # Backwards-compatibility (legacy) Google auth URL for the mobile\n    # apps; see https://github.com/zulip/zulip/issues/13081 for\n    # background.  We can remove this once older versions of the\n    # mobile app are no longer present in the wild.\n    path(\"accounts/login/google/\", start_social_login, {\"backend\": \"google\"}),\n    path(\"accounts/login/start/sso/\", start_remote_user_sso, name=\"start-login-sso\"),\n    path(\"accounts/login/sso/\", remote_user_sso, name=\"login-sso\"),\n    path(\"accounts/login/jwt/\", remote_user_jwt),\n    path(\"accounts/login/social/<backend>\", start_social_login, name=\"login-social\"),\n    path(\"accounts/login/social/<backend>/<extra_arg>\", start_social_login, name=\"login-social\"),\n    path(\"accounts/register/social/<backend>\", start_social_signup, name=\"signup-social\"),\n    path(\n        \"accounts/register/social/<backend>/<extra_arg>\", start_social_signup, name=\"signup-social\"\n    ),\n    path(\"accounts/login/subdomain/<token>\", log_into_subdomain),\n    # We have two entries for accounts/login; only the first one is\n    # used for URL resolution.  The second here is to allow\n    # reverse(\"login\") in templates to\n    # return `/accounts/login/`.\n    path(\"accounts/login/\", login_page, {\"template_name\": \"zerver/login.html\"}, name=\"login_page\"),\n    path(\"accounts/login/\", LoginView.as_view(template_name=\"zerver/login.html\"), name=\"login\"),\n    path(\"accounts/logout/\", logout_then_login),\n    path(\"accounts/webathena_kerberos_login/\", webathena_kerberos_login),\n    path(\"accounts/password/reset/\", password_reset, name=\"password_reset\"),\n    path(\n        \"accounts/password/reset/done/\",\n        PasswordResetDoneView.as_view(template_name=\"zerver/reset_emailed.html\"),\n    ),\n    path(\n        \"accounts/password/reset/<uidb64>/<token>/\",\n        PasswordResetConfirmView.as_view(\n            success_url=\"/accounts/password/done/\",\n            template_name=\"zerver/reset_confirm.html\",\n            form_class=LoggingSetPasswordForm,\n        ),\n        name=\"password_reset_confirm\",\n    ),\n    path(\n        \"accounts/password/done/\",\n        PasswordResetCompleteView.as_view(template_name=\"zerver/reset_done.html\"),\n    ),\n    path(\"accounts/deactivated/\", show_deactivation_notice),\n    # Displays digest email content in browser.\n    path(\"digest/\", digest_page),\n    # Registration views, require a confirmation ID.\n    path(\"accounts/home/\", accounts_home),\n    path(\n        \"accounts/send_confirm/<email>\",\n        TemplateView.as_view(template_name=\"zerver/accounts_send_confirm.html\"),\n        name=\"signup_send_confirm\",\n    ),\n    path(\n        \"accounts/new/send_confirm/<email>\",\n        TemplateView.as_view(template_name=\"zerver/accounts_send_confirm.html\"),\n        {\"realm_creation\": True},\n        name=\"new_realm_send_confirm\",\n    ),\n    path(\"accounts/register/\", accounts_register, name=\"accounts_register\"),\n    path(\n        \"accounts/do_confirm/<confirmation_key>\",\n        get_prereg_key_and_redirect,\n        name=\"get_prereg_key_and_redirect\",\n    ),\n    path(\n        \"accounts/confirm_new_email/<confirmation_key>\",\n        confirm_email_change,\n        name=\"confirm_email_change\",\n    ),\n    # Email unsubscription endpoint. Allows for unsubscribing from various types of emails,\n    # including the welcome emails (day 1 & 2), missed PMs, etc.\n    path(\n        \"accounts/unsubscribe/<email_type>/<confirmation_key>\",\n        email_unsubscribe,\n        name=\"unsubscribe\",\n    ),\n    # Portico-styled page used to provide email confirmation of terms acceptance.\n    path(\"accounts/accept_terms/\", accounts_accept_terms, name=\"accept_terms\"),\n    # Find your account\n    path(\"accounts/find/\", find_account, name=\"find_account\"),\n    # Go to organization subdomain\n    path(\"accounts/go/\", realm_redirect, name=\"realm_redirect\"),\n    # Realm creation\n    path(\"new/\", create_realm),\n    path(\"new/<creation_key>\", create_realm, name=\"create_realm\"),\n    # Realm reactivation\n    path(\"reactivate/<confirmation_key>\", realm_reactivation, name=\"realm_reactivation\"),\n    # Login/registration\n    path(\"register/\", accounts_home, name=\"register\"),\n    path(\"login/\", login_page, {\"template_name\": \"zerver/login.html\"}, name=\"login_page\"),\n    path(\"join/<confirmation_key>/\", accounts_home_from_multiuse_invite, name=\"join\"),\n    # Used to generate a Zoom video call URL\n    path(\"calls/zoom/register\", register_zoom_user),\n    path(\"calls/zoom/complete\", complete_zoom_user),\n    path(\"calls/zoom/deauthorize\", deauthorize_zoom_user),\n    # Used to join a BigBlueButton video call\n    path(\"calls/bigbluebutton/join\", join_bigbluebutton),\n    # API and integrations documentation\n    path(\"integrations/doc-html/<integration_name>\", integration_doc),\n    path(\"integrations/\", integrations_view),\n    path(\"integrations/<path:path>\", integrations_view),\n    # Landing page, features pages, signup form, etc.\n    path(\"hello/\", hello_view),\n    path(\"new-user/\", RedirectView.as_view(url=\"/hello\", permanent=True)),\n    path(\"features/\", landing_view, {\"template_name\": \"zerver/features.html\"}),\n    path(\"plans/\", plans_view, name=\"plans\"),\n    path(\"apps/\", apps_view),\n    path(\"apps/download/<platform>\", app_download_link_redirect),\n    path(\"apps/<platform>\", apps_view),\n    path(\n        \"developer-community/\", RedirectView.as_view(url=\"/development-community/\", permanent=True)\n    ),\n    path(\n        \"development-community/\",\n        landing_view,\n        {\"template_name\": \"zerver/development-community.html\"},\n    ),\n    # Renamed to have a cleared URL.\n    path(\n        \"developer-community/\", RedirectView.as_view(url=\"/development-community/\", permanent=True)\n    ),\n    path(\"attribution/\", landing_view, {\"template_name\": \"zerver/attribution.html\"}),\n    path(\"team/\", team_view),\n    path(\"history/\", landing_view, {\"template_name\": \"zerver/history.html\"}),\n    path(\"why-zulip/\", landing_view, {\"template_name\": \"zerver/why-zulip.html\"}),\n    path(\"for/education/\", landing_view, {\"template_name\": \"zerver/for-education.html\"}),\n    path(\"for/events/\", landing_view, {\"template_name\": \"zerver/for-events.html\"}),\n    path(\"for/open-source/\", landing_view, {\"template_name\": \"zerver/for-open-source.html\"}),\n    path(\"for/research/\", landing_view, {\"template_name\": \"zerver/for-research.html\"}),\n    path(\"for/business/\", landing_view, {\"template_name\": \"zerver/for-business.html\"}),\n    path(\"for/companies/\", RedirectView.as_view(url=\"/for/business/\", permanent=True)),\n    path(\"case-studies/idrift/\", landing_view, {\"template_name\": \"zerver/idrift-case-study.html\"}),\n    path(\"case-studies/tum/\", landing_view, {\"template_name\": \"zerver/tum-case-study.html\"}),\n    path(\"case-studies/ucsd/\", landing_view, {\"template_name\": \"zerver/ucsd-case-study.html\"}),\n    path(\"case-studies/rust/\", landing_view, {\"template_name\": \"zerver/rust-case-study.html\"}),\n    path(\"case-studies/lean/\", landing_view, {\"template_name\": \"zerver/lean-case-study.html\"}),\n    path(\n        \"for/communities/\",\n        landing_view,\n        {\"template_name\": \"zerver/for-communities.html\"},\n    ),\n    # We merged this into /for/communities.\n    path(\n        \"for/working-groups-and-communities/\",\n        RedirectView.as_view(url=\"/for/communities/\", permanent=True),\n    ),\n    path(\"self-hosting/\", landing_view, {\"template_name\": \"zerver/self-hosting.html\"}),\n    path(\"security/\", landing_view, {\"template_name\": \"zerver/security.html\"}),\n]\n\n# Make a copy of i18n_urls so that they appear without prefix for english\nurls: List[Union[URLPattern, URLResolver]] = list(i18n_urls)\n\n# Include the dual-use patterns twice\nurls += [\n    path(\"api/v1/\", include(v1_api_and_json_patterns)),\n    path(\"json/\", include(v1_api_and_json_patterns)),\n]\n\n# user_uploads -> zerver.views.upload.serve_file_backend\n#\n# This URL is an exception to the URL naming schemes for endpoints. It\n# supports both API and session cookie authentication, using a single\n# URL for both (not 'api/v1/' or 'json/' prefix). This is required to\n# easily support the mobile apps fetching uploaded files without\n# having to rewrite URLs, and is implemented using the\n# 'override_api_url_scheme' flag passed to rest_dispatch\nurls += [\n    path(\n        \"user_uploads/temporary/<token>/<filename>\",\n        serve_local_file_unauthed,\n        name=\"local_file_unauthed\",\n    ),\n    rest_path(\n        \"user_uploads/<realm_id_str>/<path:filename>\",\n        GET=(serve_file_backend, {\"override_api_url_scheme\"}),\n    ),\n    # This endpoint redirects to camo; it requires an exception for the\n    # same reason.\n    rest_path(\"thumbnail\", GET=(backend_serve_thumbnail, {\"override_api_url_scheme\"})),\n    # Avatars have the same constraint because their URLs are included\n    # in API data structures used by both the mobile and web clients.\n    rest_path(\n        \"avatar/<email_or_id>\",\n        GET=(avatar, {\"override_api_url_scheme\", \"allow_anonymous_user_web\"}),\n    ),\n    rest_path(\n        \"avatar/<email_or_id>/medium\",\n        {\"medium\": True},\n        GET=(avatar, {\"override_api_url_scheme\", \"allow_anonymous_user_web\"}),\n    ),\n]\n\n# This URL serves as a way to receive CSP violation reports from the users.\n# We use this endpoint to just log these reports.\nurls += [\n    path(\"report/csp_violations\", report_csp_violations),\n]\n\n# Incoming webhook URLs\n# We don't create URLs for particular Git integrations here\n# because of generic one below\nfor incoming_webhook in WEBHOOK_INTEGRATIONS:\n    if incoming_webhook.url_object:\n        urls.append(incoming_webhook.url_object)\n\n# Desktop-specific authentication URLs\nurls += [\n    rest_path(\"json/fetch_api_key\", POST=json_fetch_api_key),\n]\n\n# Mobile-specific authentication URLs\nurls += [\n    # Used as a global check by all mobile clients, which currently send\n    # requests to https://zulip.com/compatibility almost immediately after\n    # starting up.\n    path(\"compatibility\", check_global_compatibility),\n]\n\nv1_api_mobile_patterns = [\n    # This json format view used by the mobile apps lists which\n    # authentication backends the server allows as well as details\n    # like the requested subdomains'd realm icon (if known) and\n    # server-specific compatibility.\n    path(\"server_settings\", api_get_server_settings),\n    # This json format view used by the mobile apps accepts a username\n    # password/pair and returns an API key.\n    path(\"fetch_api_key\", api_fetch_api_key),\n    # The endpoint for regenerating and obtaining a new API key\n    # should only be available by authenticating with the current\n    # API key - as we consider access to the API key sensitive\n    # and just having a logged-in session should be insufficient.\n    rest_path(\"users/me/api_key/regenerate\", POST=regenerate_api_key),\n]\n\n# View for uploading messages from email mirror\nurls += [\n    path(\"email_mirror_message\", email_mirror_message),\n]\n\n# Include URL configuration files for site-specified extra installed\n# Django apps\nfor app_name in settings.EXTRA_INSTALLED_APPS:\n    app_dir = os.path.join(settings.DEPLOY_ROOT, app_name)\n    if os.path.exists(os.path.join(app_dir, \"urls.py\")):\n        urls += [path(\"\", include(f\"{app_name}.urls\"))]\n        i18n_urls += import_string(f\"{app_name}.urls.i18n_urlpatterns\")\n\n# Tornado views\nurls += [\n    # Used internally for communication between Django and Tornado processes\n    #\n    # Since these views don't use rest_dispatch, they cannot have\n    # asynchronous Tornado behavior.\n    path(\"notify_tornado\", notify),\n    path(\"api/v1/events/internal\", get_events_internal),\n]\n\n# Python Social Auth\n\nurls += [path(\"\", include(\"social_django.urls\", namespace=\"social\"))]\nurls += [path(\"saml/metadata.xml\", saml_sp_metadata)]\n\n# SCIM2\n\nfrom django_scim import views as scim_views\n\nurls += [\n    # Everything below here are features that we don't yet support and we want\n    # to explicitly mark them to return \"Not Implemented\" rather than running\n    # the django-scim2 code for them.\n    re_path(\n        r\"^scim/v2/Groups/.search$\",\n        scim_views.SCIMView.as_view(implemented=False),\n    ),\n    re_path(\n        r\"^scim/v2/Groups(?:/(?P<uuid>[^/]+))?$\",\n        scim_views.SCIMView.as_view(implemented=False),\n    ),\n    re_path(r\"^scim/v2/Me$\", scim_views.SCIMView.as_view(implemented=False)),\n    re_path(\n        r\"^scim/v2/ServiceProviderConfig$\",\n        scim_views.SCIMView.as_view(implemented=False),\n    ),\n    re_path(\n        r\"^scim/v2/ResourceTypes(?:/(?P<uuid>[^/]+))?$\",\n        scim_views.SCIMView.as_view(implemented=False),\n    ),\n    re_path(\n        r\"^scim/v2/Schemas(?:/(?P<uuid>[^/]+))?$\", scim_views.SCIMView.as_view(implemented=False)\n    ),\n    re_path(r\"^scim/v2/Bulk$\", scim_views.SCIMView.as_view(implemented=False)),\n    # This registers the remaining SCIM endpoints.\n    path(\"scim/v2/\", include(\"django_scim.urls\", namespace=\"scim\")),\n]\n\n# User documentation site\nhelp_documentation_view = MarkdownDirectoryView.as_view(\n    template_name=\"zerver/documentation_main.html\", path_template=\"/zerver/help/%s.md\"\n)\napi_documentation_view = MarkdownDirectoryView.as_view(\n    template_name=\"zerver/documentation_main.html\", path_template=\"/zerver/api/%s.md\"\n)\npolicy_documentation_view = MarkdownDirectoryView.as_view(\n    template_name=\"zerver/documentation_main.html\",\n    policies_view=True,\n)\nurls += [\n    # Redirects due to us having moved the docs:\n    path(\n        \"help/delete-a-stream\", RedirectView.as_view(url=\"/help/archive-a-stream\", permanent=True)\n    ),\n    path(\"api/delete-stream\", RedirectView.as_view(url=\"/api/archive-stream\", permanent=True)),\n    path(\n        \"help/change-the-topic-of-a-message\",\n        RedirectView.as_view(url=\"/help/rename-a-topic\", permanent=True),\n    ),\n    path(\n        \"help/configure-missed-message-emails\",\n        RedirectView.as_view(url=\"/help/email-notifications\", permanent=True),\n    ),\n    path(\n        \"help/add-an-alert-word\",\n        RedirectView.as_view(\n            url=\"/help/pm-mention-alert-notifications#alert-words\", permanent=True\n        ),\n    ),\n    path(\n        \"help/test-mobile-notifications\",\n        RedirectView.as_view(url=\"/help/mobile-notifications\", permanent=True),\n    ),\n    path(\n        \"help/troubleshooting-desktop-notifications\",\n        RedirectView.as_view(\n            url=\"/help/desktop-notifications#troubleshooting-desktop-notifications\", permanent=True\n        ),\n    ),\n    path(\n        \"help/change-notification-sound\",\n        RedirectView.as_view(\n            url=\"/help/desktop-notifications#change-notification-sound\", permanent=True\n        ),\n    ),\n    path(\n        \"help/configure-message-notification-emails\",\n        RedirectView.as_view(url=\"/help/email-notifications\", permanent=True),\n    ),\n    path(\n        \"help/disable-new-login-emails\",\n        RedirectView.as_view(url=\"/help/email-notifications#new-login-emails\", permanent=True),\n    ),\n    # This redirect is particularly important, because the old URL\n    # appears in links from Welcome Bot messages.\n    path(\n        \"help/about-streams-and-topics\",\n        RedirectView.as_view(url=\"/help/streams-and-topics\", permanent=True),\n    ),\n    path(\n        \"help/community-topic-edits\",\n        RedirectView.as_view(url=\"/help/configure-who-can-edit-topics\", permanent=True),\n    ),\n    path(\n        \"help/only-allow-admins-to-add-emoji\",\n        RedirectView.as_view(\n            url=\"/help/custom-emoji#change-who-can-add-custom-emoji\", permanent=True\n        ),\n    ),\n    path(\n        \"help/configure-who-can-add-custom-emoji\",\n        RedirectView.as_view(\n            url=\"/help/custom-emoji#change-who-can-add-custom-emoji\", permanent=True\n        ),\n    ),\n    path(\n        \"help/add-custom-emoji\",\n        RedirectView.as_view(url=\"/help/custom-emoji\", permanent=True),\n    ),\n    path(\n        \"help/night-mode\",\n        RedirectView.as_view(url=\"/help/dark-theme\", permanent=True),\n    ),\n    path(\"help/\", help_documentation_view),\n    path(\"help/<path:article>\", help_documentation_view),\n    path(\"api/\", api_documentation_view),\n    path(\"api/<slug:article>\", api_documentation_view),\n    path(\"policies/\", policy_documentation_view),\n    path(\"policies/<slug:article>\", policy_documentation_view),\n    path(\n        \"privacy/\",\n        RedirectView.as_view(url=\"/policies/privacy\"),\n    ),\n    path(\n        \"terms/\",\n        RedirectView.as_view(url=\"/policies/terms\"),\n    ),\n]\n\n# Two-factor URLs\nif settings.TWO_FACTOR_AUTHENTICATION_ENABLED:\n    urls += [path(\"\", include(tf_urls)), path(\"\", include(tf_twilio_urls))]\n\nif settings.DEVELOPMENT:\n    urls += dev_urls.urls\n    i18n_urls += dev_urls.i18n_urls\n    v1_api_mobile_patterns += dev_urls.v1_api_mobile_patterns\n\nurls += [\n    path(\"api/v1/\", include(v1_api_mobile_patterns)),\n]\n\n# The sequence is important; if i18n URLs don't come first then\n# reverse URL mapping points to i18n URLs which causes the frontend\n# tests to fail\nurlpatterns = i18n_patterns(*i18n_urls) + urls + legacy_urls\n"], "filenames": ["static/js/settings_account.js", "zerver/tests/test_settings.py", "zproject/urls.py"], "buggy_code_start_loc": [361, 497, 375], "buggy_code_end_loc": [364, 498, 726], "fixing_code_start_loc": [362, 498, 374], "fixing_code_end_loc": [371, 509, 731], "type": "NVD-CWE-Other", "message": "Improper Access Control in GitHub repository zulip/zulip prior to 4.10.", "other": {"cve": {"id": "CVE-2021-3967", "sourceIdentifier": "security@huntr.dev", "published": "2022-02-26T23:15:08.830", "lastModified": "2022-08-05T11:31:54.533", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Improper Access Control in GitHub repository zulip/zulip prior to 4.10."}, {"lang": "es", "value": "Un Control de Acceso Inapropiado en el repositorio de GitHub zulip/zulip versiones anteriores a 4.10."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:H/PR:H/UI:N/S:U/C:L/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 4.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 0.7, "impactScore": 3.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.5}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-Other"}]}, {"source": "security@huntr.dev", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-284"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:zulip:zulip:*:*:*:*:*:*:*:*", "versionEndExcluding": "4.10", "matchCriteriaId": "B0DE9BF6-B7FF-47B4-908E-FA6D97D0A032"}]}]}], "references": [{"url": "https://github.com/zulip/zulip/commit/d5db254ca8167995a1654d1c45ffc74b2fade39a", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/2928a625-0467-4a0a-b4e2-e27322786686", "source": "security@huntr.dev", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/zulip/zulip/commit/d5db254ca8167995a1654d1c45ffc74b2fade39a"}}