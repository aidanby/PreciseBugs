{"buggy_code": ["/*\n  +----------------------------------------------------------------------+\n  | PHP Version 7                                                        |\n  +----------------------------------------------------------------------+\n  | Copyright (c) 1997-2016 The PHP Group                                |\n  +----------------------------------------------------------------------+\n  | This source file is subject to version 3.01 of the PHP license,      |\n  | that is bundled with this package in the file LICENSE, and is        |\n  | available through the world-wide-web at the following url:           |\n  | http://www.php.net/license/3_01.txt.                                 |\n  | If you did not receive a copy of the PHP license and are unable to   |\n  | obtain it through the world-wide-web, please send a note to          |\n  | license@php.net so we can mail you a copy immediately.               |\n  +----------------------------------------------------------------------+\n  | Author: Piere-Alain Joye <pierre@php.net>                            |\n  +----------------------------------------------------------------------+\n*/\n\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include \"php.h\"\n#include \"php_ini.h\"\n#include \"ext/standard/info.h\"\n#include \"ext/standard/file.h\"\n#include \"ext/standard/php_string.h\"\n#include \"ext/pcre/php_pcre.h\"\n#include \"ext/standard/php_filestat.h\"\n#include \"php_zip.h\"\n\n/* zip_open is a macro for renaming libzip zipopen, so we need to use PHP_NAMED_FUNCTION */\nstatic PHP_NAMED_FUNCTION(zif_zip_open);\nstatic PHP_NAMED_FUNCTION(zif_zip_read);\nstatic PHP_NAMED_FUNCTION(zif_zip_close);\nstatic PHP_NAMED_FUNCTION(zif_zip_entry_read);\nstatic PHP_NAMED_FUNCTION(zif_zip_entry_filesize);\nstatic PHP_NAMED_FUNCTION(zif_zip_entry_name);\nstatic PHP_NAMED_FUNCTION(zif_zip_entry_compressedsize);\nstatic PHP_NAMED_FUNCTION(zif_zip_entry_compressionmethod);\nstatic PHP_NAMED_FUNCTION(zif_zip_entry_open);\nstatic PHP_NAMED_FUNCTION(zif_zip_entry_close);\n\n#ifdef HAVE_GLOB\n#ifndef PHP_WIN32\n#include <glob.h>\n#else\n#include \"win32/glob.h\"\n#endif\n#endif\n\n/* {{{ Resource le */\nstatic int le_zip_dir;\n#define le_zip_dir_name \"Zip Directory\"\nstatic int le_zip_entry;\n#define le_zip_entry_name \"Zip Entry\"\n/* }}} */\n\n/* {{{ PHP_ZIP_STAT_INDEX(za, index, flags, sb) */\n#define PHP_ZIP_STAT_INDEX(za, index, flags, sb) \\\n\tif (zip_stat_index(za, index, flags, &sb) != 0) { \\\n\t\tRETURN_FALSE; \\\n\t}\n/* }}} */\n\n/* {{{  PHP_ZIP_STAT_PATH(za, path, path_len, flags, sb) */\n#define PHP_ZIP_STAT_PATH(za, path, path_len, flags, sb) \\\n\tif (path_len < 1) { \\\n\t\tphp_error_docref(NULL, E_NOTICE, \"Empty string as entry name\"); \\\n\t\tRETURN_FALSE; \\\n\t} \\\n\tif (zip_stat(za, path, flags, &sb) != 0) { \\\n\t\tRETURN_FALSE; \\\n\t}\n/* }}} */\n\n/* {{{ PHP_ZIP_SET_FILE_COMMENT(za, index, comment, comment_len) */\n#define PHP_ZIP_SET_FILE_COMMENT(za, index, comment, comment_len) \\\n\tif (comment_len == 0) { \\\n\t\t/* Passing NULL remove the existing comment */ \\\n\t\tif (zip_set_file_comment(za, index, NULL, 0) < 0) { \\\n\t\t\tRETURN_FALSE; \\\n\t\t} \\\n\t} else if (zip_set_file_comment(za, index, comment, comment_len) < 0) { \\\n\t\tRETURN_FALSE; \\\n\t} \\\n\tRETURN_TRUE;\n/* }}} */\n\n# define add_ascii_assoc_string add_assoc_string\n# define add_ascii_assoc_long add_assoc_long\n\n/* Flatten a path by making a relative path (to .)*/\nstatic char * php_zip_make_relative_path(char *path, size_t path_len) /* {{{ */\n{\n\tchar *path_begin = path;\n\tsize_t i;\n\n\tif (path_len < 1 || path == NULL) {\n\t\treturn NULL;\n\t}\n\n\tif (IS_SLASH(path[0])) {\n\t\treturn path + 1;\n\t}\n\n\ti = path_len;\n\n\twhile (1) {\n\t\twhile (i > 0 && !IS_SLASH(path[i])) {\n\t\t\ti--;\n\t\t}\n\n\t\tif (!i) {\n\t\t\treturn path;\n\t\t}\n\n\t\tif (i >= 2 && (path[i -1] == '.' || path[i -1] == ':')) {\n\t\t\t/* i is the position of . or :, add 1 for / */\n\t\t\tpath_begin = path + i + 1;\n\t\t\tbreak;\n\t\t}\n\t\ti--;\n\t}\n\n\treturn path_begin;\n}\n/* }}} */\n\n# define CWD_STATE_ALLOC(l) emalloc(l)\n# define CWD_STATE_FREE(s)  efree(s)\n\n/* {{{ php_zip_extract_file */\nstatic int php_zip_extract_file(struct zip * za, char *dest, char *file, int file_len)\n{\n\tphp_stream_statbuf ssb;\n\tstruct zip_file *zf;\n\tstruct zip_stat sb;\n\tchar b[8192];\n\tint n, len, ret;\n\tphp_stream *stream;\n\tchar *fullpath;\n\tchar *file_dirname_fullpath;\n\tchar file_dirname[MAXPATHLEN];\n\tsize_t dir_len;\n\tint is_dir_only = 0;\n\tchar *path_cleaned;\n\tsize_t path_cleaned_len;\n\tcwd_state new_state;\n\tzend_string *file_basename;\n\n\tnew_state.cwd = CWD_STATE_ALLOC(1);\n\tnew_state.cwd[0] = '\\0';\n\tnew_state.cwd_length = 0;\n\n\t/* Clean/normlize the path and then transform any path (absolute or relative)\n\t\t to a path relative to cwd (../../mydir/foo.txt > mydir/foo.txt)\n\t */\n\tvirtual_file_ex(&new_state, file, NULL, CWD_EXPAND);\n\tpath_cleaned =  php_zip_make_relative_path(new_state.cwd, new_state.cwd_length);\n\tif(!path_cleaned) {\n\t\treturn 0;\n\t}\n\tpath_cleaned_len = strlen(path_cleaned);\n\n\tif (path_cleaned_len >= MAXPATHLEN || zip_stat(za, file, 0, &sb) != 0) {\n\t\treturn 0;\n\t}\n\n\t/* it is a directory only, see #40228 */\n\tif (path_cleaned_len > 1 && IS_SLASH(path_cleaned[path_cleaned_len - 1])) {\n\t\tlen = spprintf(&file_dirname_fullpath, 0, \"%s/%s\", dest, path_cleaned);\n\t\tis_dir_only = 1;\n\t} else {\n\t\tmemcpy(file_dirname, path_cleaned, path_cleaned_len);\n\t\tdir_len = php_dirname(file_dirname, path_cleaned_len);\n\n\t\tif (dir_len <= 0 || (dir_len == 1 && file_dirname[0] == '.')) {\n\t\t\tlen = spprintf(&file_dirname_fullpath, 0, \"%s\", dest);\n\t\t} else {\n\t\t\tlen = spprintf(&file_dirname_fullpath, 0, \"%s/%s\", dest, file_dirname);\n\t\t}\n\n\t\tfile_basename =\tphp_basename(path_cleaned, path_cleaned_len, NULL, 0);\n\n\t\tif (ZIP_OPENBASEDIR_CHECKPATH(file_dirname_fullpath)) {\n\t\t\tefree(file_dirname_fullpath);\n\t\t\tzend_string_release(file_basename);\n\t\t\tCWD_STATE_FREE(new_state.cwd);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/* let see if the path already exists */\n\tif (php_stream_stat_path_ex(file_dirname_fullpath, PHP_STREAM_URL_STAT_QUIET, &ssb, NULL) < 0) {\n\t\tret = php_stream_mkdir(file_dirname_fullpath, 0777,  PHP_STREAM_MKDIR_RECURSIVE|REPORT_ERRORS, NULL);\n\t\tif (!ret) {\n\t\t\tefree(file_dirname_fullpath);\n\t\t\tif (!is_dir_only) {\n\t\t\t\tzend_string_release(file_basename);\n\t\t\t\tCWD_STATE_FREE(new_state.cwd);\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/* it is a standalone directory, job done */\n\tif (is_dir_only) {\n\t\tefree(file_dirname_fullpath);\n\t\tCWD_STATE_FREE(new_state.cwd);\n\t\treturn 1;\n\t}\n\n\tlen = spprintf(&fullpath, 0, \"%s/%s\", file_dirname_fullpath, ZSTR_VAL(file_basename));\n\tif (!len) {\n\t\tefree(file_dirname_fullpath);\n\t\tzend_string_release(file_basename);\n\t\tCWD_STATE_FREE(new_state.cwd);\n\t\treturn 0;\n\t} else if (len > MAXPATHLEN) {\n\t\tphp_error_docref(NULL, E_WARNING, \"Full extraction path exceed MAXPATHLEN (%i)\", MAXPATHLEN);\n\t\tefree(file_dirname_fullpath);\n\t\tzend_string_release(file_basename);\n\t\tCWD_STATE_FREE(new_state.cwd);\n\t\treturn 0;\n\t}\n\n\t/* check again the full path, not sure if it\n\t * is required, does a file can have a different\n\t * safemode status as its parent folder?\n\t */\n\tif (ZIP_OPENBASEDIR_CHECKPATH(fullpath)) {\n\t\tefree(fullpath);\n\t\tefree(file_dirname_fullpath);\n\t\tzend_string_release(file_basename);\n\t\tCWD_STATE_FREE(new_state.cwd);\n\t\treturn 0;\n\t}\n\n\tstream = php_stream_open_wrapper(fullpath, \"w+b\", REPORT_ERRORS, NULL);\n\n\tif (stream == NULL) {\n\t\tn = -1;\n\t\tgoto done;\n\t}\n\n\tzf = zip_fopen(za, file, 0);\n\tif (zf == NULL) {\n\t\tn = -1;\n\t\tphp_stream_close(stream);\n\t\tgoto done;\n\t}\n\n\tn = 0;\n\n\twhile ((n=zip_fread(zf, b, sizeof(b))) > 0) {\n\t\tphp_stream_write(stream, b, n);\n\t}\n\n\tphp_stream_close(stream);\n\tn = zip_fclose(zf);\n\ndone:\n\tefree(fullpath);\n\tzend_string_release(file_basename);\n\tefree(file_dirname_fullpath);\n\tCWD_STATE_FREE(new_state.cwd);\n\n\tif (n<0) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}\n/* }}} */\n\nstatic int php_zip_add_file(struct zip *za, const char *filename, size_t filename_len,\n\tchar *entry_name, size_t entry_name_len, long offset_start, long offset_len) /* {{{ */\n{\n\tstruct zip_source *zs;\n\tchar resolved_path[MAXPATHLEN];\n\tzval exists_flag;\n\n\n\tif (ZIP_OPENBASEDIR_CHECKPATH(filename)) {\n\t\treturn -1;\n\t}\n\n\tif (!expand_filepath(filename, resolved_path)) {\n\t\treturn -1;\n\t}\n\n\tphp_stat(resolved_path, strlen(resolved_path), FS_EXISTS, &exists_flag);\n\tif (Z_TYPE(exists_flag) == IS_FALSE) {\n\t\treturn -1;\n\t}\n\n\tzs = zip_source_file(za, resolved_path, offset_start, offset_len);\n\tif (!zs) {\n\t\treturn -1;\n\t}\n\tif (zip_file_add(za, entry_name, zs, ZIP_FL_OVERWRITE) < 0) {\n\t\tzip_source_free(zs);\n\t\treturn -1;\n\t} else {\n\t\tzip_error_clear(za);\n\t\treturn 1;\n\t}\n}\n/* }}} */\n\nstatic int php_zip_parse_options(zval *options, zend_long *remove_all_path, char **remove_path, size_t *remove_path_len, char **add_path, size_t *add_path_len) /* {{{ */\n{\n\tzval *option;\n\tif ((option = zend_hash_str_find(Z_ARRVAL_P(options), \"remove_all_path\", sizeof(\"remove_all_path\") - 1)) != NULL) {\n\t\t*remove_all_path = zval_get_long(option);\n\t}\n\n\t/* If I add more options, it would make sense to create a nice static struct and loop over it. */\n\tif ((option = zend_hash_str_find(Z_ARRVAL_P(options), \"remove_path\", sizeof(\"remove_path\") - 1)) != NULL) {\n\t\tif (Z_TYPE_P(option) != IS_STRING) {\n\t\t\tphp_error_docref(NULL, E_WARNING, \"remove_path option expected to be a string\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (Z_STRLEN_P(option) < 1) {\n\t\t\tphp_error_docref(NULL, E_NOTICE, \"Empty string given as remove_path option\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (Z_STRLEN_P(option) >= MAXPATHLEN) {\n\t\t\tphp_error_docref(NULL, E_WARNING, \"remove_path string is too long (max: %d, %zd given)\",\n\t\t\t\t\t\tMAXPATHLEN - 1, Z_STRLEN_P(option));\n\t\t\treturn -1;\n\t\t}\n\t\t*remove_path_len = Z_STRLEN_P(option);\n\t\t*remove_path = Z_STRVAL_P(option);\n\t}\n\n\tif ((option = zend_hash_str_find(Z_ARRVAL_P(options), \"add_path\", sizeof(\"add_path\") - 1)) != NULL) {\n\t\tif (Z_TYPE_P(option) != IS_STRING) {\n\t\t\tphp_error_docref(NULL, E_WARNING, \"add_path option expected to be a string\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (Z_STRLEN_P(option) < 1) {\n\t\t\tphp_error_docref(NULL, E_NOTICE, \"Empty string given as the add_path option\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (Z_STRLEN_P(option) >= MAXPATHLEN) {\n\t\t\tphp_error_docref(NULL, E_WARNING, \"add_path string too long (max: %d, %zd given)\",\n\t\t\t\t\t\tMAXPATHLEN - 1, Z_STRLEN_P(option));\n\t\t\treturn -1;\n\t\t}\n\t\t*add_path_len = Z_STRLEN_P(option);\n\t\t*add_path = Z_STRVAL_P(option);\n\t}\n\treturn 1;\n}\n/* }}} */\n\n/* {{{ REGISTER_ZIP_CLASS_CONST_LONG */\n#define REGISTER_ZIP_CLASS_CONST_LONG(const_name, value) \\\n\t    zend_declare_class_constant_long(zip_class_entry, const_name, sizeof(const_name)-1, (zend_long)value);\n/* }}} */\n\n/* {{{ ZIP_FROM_OBJECT */\n#define ZIP_FROM_OBJECT(intern, object) \\\n\t{ \\\n\t\tze_zip_object *obj = Z_ZIP_P(object); \\\n\t\tintern = obj->za; \\\n\t\tif (!intern) { \\\n\t\t\tphp_error_docref(NULL, E_WARNING, \"Invalid or uninitialized Zip object\"); \\\n\t\t\tRETURN_FALSE; \\\n\t\t} \\\n\t}\n/* }}} */\n\n/* {{{ RETURN_SB(sb) */\n#define RETURN_SB(sb) \\\n\t{ \\\n\t\tarray_init(return_value); \\\n\t\tadd_ascii_assoc_string(return_value, \"name\", (char *)(sb)->name); \\\n\t\tadd_ascii_assoc_long(return_value, \"index\", (zend_long) (sb)->index); \\\n\t\tadd_ascii_assoc_long(return_value, \"crc\", (zend_long) (sb)->crc); \\\n\t\tadd_ascii_assoc_long(return_value, \"size\", (zend_long) (sb)->size); \\\n\t\tadd_ascii_assoc_long(return_value, \"mtime\", (zend_long) (sb)->mtime); \\\n\t\tadd_ascii_assoc_long(return_value, \"comp_size\", (zend_long) (sb)->comp_size); \\\n\t\tadd_ascii_assoc_long(return_value, \"comp_method\", (zend_long) (sb)->comp_method); \\\n\t}\n/* }}} */\n\nstatic int php_zip_status(struct zip *za) /* {{{ */\n{\n#if LIBZIP_VERSION_MAJOR < 1\n\tint zep, syp;\n\n\tzip_error_get(za, &zep, &syp);\n#else\n\tint zep;\n\tzip_error_t *err;\n\n\terr = zip_get_error(za);\n\tzep = zip_error_code_zip(err);\n\tzip_error_fini(err);\n#endif\n\treturn zep;\n}\n/* }}} */\n\nstatic int php_zip_status_sys(struct zip *za) /* {{{ */\n{\n#if LIBZIP_VERSION_MAJOR < 1\n\tint zep, syp;\n\n\tzip_error_get(za, &zep, &syp);\n#else\n\tint syp;\n\tzip_error_t *err;\n\n\terr = zip_get_error(za);\n\tsyp = zip_error_code_system(err);\n\tzip_error_fini(err);\n#endif\n\treturn syp;\n}\n/* }}} */\n\nstatic int php_zip_get_num_files(struct zip *za) /* {{{ */\n{\n\treturn zip_get_num_files(za);\n}\n/* }}} */\n\nstatic char * php_zipobj_get_filename(ze_zip_object *obj) /* {{{ */\n{\n\n\tif (!obj) {\n\t\treturn NULL;\n\t}\n\n\tif (obj->filename) {\n\t\treturn obj->filename;\n\t}\n\treturn NULL;\n}\n/* }}} */\n\nstatic char * php_zipobj_get_zip_comment(struct zip *za, int *len) /* {{{ */\n{\n\tif (za) {\n\t\treturn (char *)zip_get_archive_comment(za, len, 0);\n\t}\n\treturn NULL;\n}\n/* }}} */\n\n#ifdef HAVE_GLOB /* {{{ */\n#ifndef GLOB_ONLYDIR\n#define GLOB_ONLYDIR (1<<30)\n#define GLOB_EMULATE_ONLYDIR\n#define GLOB_FLAGMASK (~GLOB_ONLYDIR)\n#else\n#define GLOB_FLAGMASK (~0)\n#endif\n#ifndef GLOB_BRACE\n# define GLOB_BRACE 0\n#endif\n#ifndef GLOB_MARK\n# define GLOB_MARK 0\n#endif\n#ifndef GLOB_NOSORT\n# define GLOB_NOSORT 0\n#endif\n#ifndef GLOB_NOCHECK\n# define GLOB_NOCHECK 0\n#endif\n#ifndef GLOB_NOESCAPE\n# define GLOB_NOESCAPE 0\n#endif\n#ifndef GLOB_ERR\n# define GLOB_ERR 0\n#endif\n\n/* This is used for checking validity of passed flags (passing invalid flags causes segfault in glob()!! */\n#define GLOB_AVAILABLE_FLAGS (0 | GLOB_BRACE | GLOB_MARK | GLOB_NOSORT | GLOB_NOCHECK | GLOB_NOESCAPE | GLOB_ERR | GLOB_ONLYDIR)\n\n#endif /* }}} */\n\nint php_zip_glob(char *pattern, int pattern_len, zend_long flags, zval *return_value) /* {{{ */\n{\n#ifdef HAVE_GLOB\n\tchar cwd[MAXPATHLEN];\n\tint cwd_skip = 0;\n#ifdef ZTS\n\tchar work_pattern[MAXPATHLEN];\n\tchar *result;\n#endif\n\tglob_t globbuf;\n\tint n;\n\tint ret;\n\n\tif (pattern_len >= MAXPATHLEN) {\n\t\tphp_error_docref(NULL, E_WARNING, \"Pattern exceeds the maximum allowed length of %d characters\", MAXPATHLEN);\n\t\treturn -1;\n\t}\n\n\tif ((GLOB_AVAILABLE_FLAGS & flags) != flags) {\n\t\tphp_error_docref(NULL, E_WARNING, \"At least one of the passed flags is invalid or not supported on this platform\");\n\t\treturn -1;\n\t}\n\n#ifdef ZTS\n\tif (!IS_ABSOLUTE_PATH(pattern, pattern_len)) {\n\t\tresult = VCWD_GETCWD(cwd, MAXPATHLEN);\n\t\tif (!result) {\n\t\t\tcwd[0] = '\\0';\n\t\t}\n#ifdef PHP_WIN32\n\t\tif (IS_SLASH(*pattern)) {\n\t\t\tcwd[2] = '\\0';\n\t\t}\n#endif\n\t\tcwd_skip = strlen(cwd)+1;\n\n\t\tsnprintf(work_pattern, MAXPATHLEN, \"%s%c%s\", cwd, DEFAULT_SLASH, pattern);\n\t\tpattern = work_pattern;\n\t}\n#endif\n\n\tglobbuf.gl_offs = 0;\n\tif (0 != (ret = glob(pattern, flags & GLOB_FLAGMASK, NULL, &globbuf))) {\n#ifdef GLOB_NOMATCH\n\t\tif (GLOB_NOMATCH == ret) {\n\t\t\t/* Some glob implementation simply return no data if no matches\n\t\t\t   were found, others return the GLOB_NOMATCH error code.\n\t\t\t   We don't want to treat GLOB_NOMATCH as an error condition\n\t\t\t   so that PHP glob() behaves the same on both types of\n\t\t\t   implementations and so that 'foreach (glob() as ...'\n\t\t\t   can be used for simple glob() calls without further error\n\t\t\t   checking.\n\t\t\t*/\n\t\t\tarray_init(return_value);\n\t\t\treturn 0;\n\t\t}\n#endif\n\t\treturn 0;\n\t}\n\n\t/* now catch the FreeBSD style of \"no matches\" */\n\tif (!globbuf.gl_pathc || !globbuf.gl_pathv) {\n\t\tarray_init(return_value);\n\t\treturn 0;\n\t}\n\n\t/* we assume that any glob pattern will match files from one directory only\n\t   so checking the dirname of the first match should be sufficient */\n\tstrncpy(cwd, globbuf.gl_pathv[0], MAXPATHLEN);\n\tif (ZIP_OPENBASEDIR_CHECKPATH(cwd)) {\n\t\treturn -1;\n\t}\n\n\tarray_init(return_value);\n\tfor (n = 0; n < globbuf.gl_pathc; n++) {\n\t\t/* we need to do this every time since GLOB_ONLYDIR does not guarantee that\n\t\t * all directories will be filtered. GNU libc documentation states the\n\t\t * following:\n\t\t * If the information about the type of the file is easily available\n\t\t * non-directories will be rejected but no extra work will be done to\n\t\t * determine the information for each file. I.e., the caller must still be\n\t\t * able to filter directories out.\n\t\t */\n\t\tif (flags & GLOB_ONLYDIR) {\n\t\t\tzend_stat_t s;\n\n\t\t\tif (0 != VCWD_STAT(globbuf.gl_pathv[n], &s)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (S_IFDIR != (s.st_mode & S_IFMT)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tadd_next_index_string(return_value, globbuf.gl_pathv[n]+cwd_skip);\n\t}\n\n\tglobfree(&globbuf);\n\treturn globbuf.gl_pathc;\n#else\n\tphp_error_docref(NULL, E_ERROR, \"Glob support is not available\");\n\treturn 0;\n#endif  /* HAVE_GLOB */\n}\n/* }}} */\n\nint php_zip_pcre(zend_string *regexp, char *path, int path_len, zval *return_value) /* {{{ */\n{\n#ifdef ZTS\n\tchar cwd[MAXPATHLEN];\n\tint cwd_skip = 0;\n\tchar work_path[MAXPATHLEN];\n\tchar *result;\n#endif\n\tint files_cnt;\n\tzend_string **namelist;\n\n#ifdef ZTS\n\tif (!IS_ABSOLUTE_PATH(path, path_len)) {\n\t\tresult = VCWD_GETCWD(cwd, MAXPATHLEN);\n\t\tif (!result) {\n\t\t\tcwd[0] = '\\0';\n\t\t}\n#ifdef PHP_WIN32\n\t\tif (IS_SLASH(*path)) {\n\t\t\tcwd[2] = '\\0';\n\t\t}\n#endif\n\t\tcwd_skip = strlen(cwd)+1;\n\n\t\tsnprintf(work_path, MAXPATHLEN, \"%s%c%s\", cwd, DEFAULT_SLASH, path);\n\t\tpath = work_path;\n\t}\n#endif\n\n\tif (ZIP_OPENBASEDIR_CHECKPATH(path)) {\n\t\treturn -1;\n\t}\n\n\tfiles_cnt = php_stream_scandir(path, &namelist, NULL, (void *) php_stream_dirent_alphasort);\n\n\tif (files_cnt > 0) {\n\t\tpcre *re = NULL;\n\t\tpcre_extra *pcre_extra = NULL;\n\t\tint preg_options = 0, i;\n\n\t\tre = pcre_get_compiled_regex(regexp, &pcre_extra, &preg_options);\n\t\tif (!re) {\n\t\t\tphp_error_docref(NULL, E_WARNING, \"Invalid expression\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tarray_init(return_value);\n\n\t\t/* only the files, directories are ignored */\n\t\tfor (i = 0; i < files_cnt; i++) {\n\t\t\tzend_stat_t s;\n\t\t\tchar   fullpath[MAXPATHLEN];\n\t\t\tint    ovector[3];\n\t\t\tint    matches;\n\t\t\tint    namelist_len = ZSTR_LEN(namelist[i]);\n\n\t\t\tif ((namelist_len == 1 && ZSTR_VAL(namelist[i])[0] == '.') ||\n\t\t\t\t(namelist_len == 2 && ZSTR_VAL(namelist[i])[0] == '.' && ZSTR_VAL(namelist[i])[1] == '.')) {\n\t\t\t\tzend_string_release(namelist[i]);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif ((path_len + namelist_len + 1) >= MAXPATHLEN) {\n\t\t\t\tphp_error_docref(NULL, E_WARNING, \"add_path string too long (max: %i, %i given)\",\n\t\t\t\t\t\tMAXPATHLEN - 1, (path_len + namelist_len + 1));\n\t\t\t\tzend_string_release(namelist[i]);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tsnprintf(fullpath, MAXPATHLEN, \"%s%c%s\", path, DEFAULT_SLASH, ZSTR_VAL(namelist[i]));\n\n\t\t\tif (0 != VCWD_STAT(fullpath, &s)) {\n\t\t\t\tphp_error_docref(NULL, E_WARNING, \"Cannot read <%s>\", fullpath);\n\t\t\t\tzend_string_release(namelist[i]);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (S_IFDIR == (s.st_mode & S_IFMT)) {\n\t\t\t\tzend_string_release(namelist[i]);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tmatches = pcre_exec(re, NULL, ZSTR_VAL(namelist[i]), ZSTR_LEN(namelist[i]), 0, 0, ovector, 3);\n\t\t\t/* 0 means that the vector is too small to hold all the captured substring offsets */\n\t\t\tif (matches < 0) {\n\t\t\t\tzend_string_release(namelist[i]);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tadd_next_index_string(return_value, fullpath);\n\t\t\tzend_string_release(namelist[i]);\n\t\t}\n\t\tefree(namelist);\n\t}\n\treturn files_cnt;\n}\n/* }}} */\n\n/* {{{ arginfo */\nZEND_BEGIN_ARG_INFO_EX(arginfo_zip_open, 0, 0, 1)\n\tZEND_ARG_INFO(0, filename)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_zip_close, 0, 0, 1)\n\tZEND_ARG_INFO(0, zip)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_zip_read, 0, 0, 1)\n\tZEND_ARG_INFO(0, zip)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_zip_entry_open, 0, 0, 2)\n\tZEND_ARG_INFO(0, zip_dp)\n\tZEND_ARG_INFO(0, zip_entry)\n\tZEND_ARG_INFO(0, mode)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_zip_entry_close, 0, 0, 1)\n\tZEND_ARG_INFO(0, zip_ent)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_zip_entry_read, 0, 0, 1)\n\tZEND_ARG_INFO(0, zip_entry)\n\tZEND_ARG_INFO(0, len)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_zip_entry_name, 0, 0, 1)\n\tZEND_ARG_INFO(0, zip_entry)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_zip_entry_compressedsize, 0, 0, 1)\n\tZEND_ARG_INFO(0, zip_entry)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_zip_entry_filesize, 0, 0, 1)\n\tZEND_ARG_INFO(0, zip_entry)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_zip_entry_compressionmethod, 0, 0, 1)\n\tZEND_ARG_INFO(0, zip_entry)\nZEND_END_ARG_INFO()\n/* }}} */\n\n/* {{{ zend_function_entry */\nstatic const zend_function_entry zip_functions[] = {\n\tZEND_RAW_FENTRY(\"zip_open\", zif_zip_open, arginfo_zip_open, 0)\n\tZEND_RAW_FENTRY(\"zip_close\", zif_zip_close, arginfo_zip_close, 0)\n\tZEND_RAW_FENTRY(\"zip_read\", zif_zip_read, arginfo_zip_read, 0)\n\tPHP_FE(zip_entry_open,\t\targinfo_zip_entry_open)\n\tPHP_FE(zip_entry_close,\t\targinfo_zip_entry_close)\n\tPHP_FE(zip_entry_read,\t\targinfo_zip_entry_read)\n\tPHP_FE(zip_entry_filesize,\targinfo_zip_entry_filesize)\n\tPHP_FE(zip_entry_name,\t\targinfo_zip_entry_name)\n\tPHP_FE(zip_entry_compressedsize,\t\targinfo_zip_entry_compressedsize)\n\tPHP_FE(zip_entry_compressionmethod,\t\targinfo_zip_entry_compressionmethod)\n#ifdef  PHP_FE_END\n\tPHP_FE_END\n#else\n\t{NULL,NULL,NULL}\n#endif\n};\n/* }}} */\n\n/* {{{ ZE2 OO definitions */\nstatic zend_class_entry *zip_class_entry;\nstatic zend_object_handlers zip_object_handlers;\n\nstatic HashTable zip_prop_handlers;\n\ntypedef int (*zip_read_int_t)(struct zip *za);\ntypedef char *(*zip_read_const_char_t)(struct zip *za, int *len);\ntypedef char *(*zip_read_const_char_from_ze_t)(ze_zip_object *obj);\n\ntypedef struct _zip_prop_handler {\n\tzip_read_int_t read_int_func;\n\tzip_read_const_char_t read_const_char_func;\n\tzip_read_const_char_from_ze_t read_const_char_from_obj_func;\n\n\tint type;\n} zip_prop_handler;\n/* }}} */\n\nstatic void php_zip_register_prop_handler(HashTable *prop_handler, char *name, zip_read_int_t read_int_func, zip_read_const_char_t read_char_func, zip_read_const_char_from_ze_t read_char_from_obj_func, int rettype) /* {{{ */\n{\n\tzip_prop_handler hnd;\n\n\thnd.read_const_char_func = read_char_func;\n\thnd.read_int_func = read_int_func;\n\thnd.read_const_char_from_obj_func = read_char_from_obj_func;\n\thnd.type = rettype;\n\tzend_hash_str_add_mem(prop_handler, name, strlen(name), &hnd, sizeof(zip_prop_handler));\n}\n/* }}} */\n\nstatic zval *php_zip_property_reader(ze_zip_object *obj, zip_prop_handler *hnd, zval *rv) /* {{{ */\n{\n\tconst char *retchar = NULL;\n\tint retint = 0;\n\tint len = 0;\n\n\tif (obj && obj->za != NULL) {\n\t\tif (hnd->read_const_char_func) {\n\t\t\tretchar = hnd->read_const_char_func(obj->za, &len);\n\t\t} else {\n\t\t\tif (hnd->read_int_func) {\n\t\t\t\tretint = hnd->read_int_func(obj->za);\n\t\t\t\tif (retint == -1) {\n\t\t\t\t\tphp_error_docref(NULL, E_WARNING, \"Internal zip error returned\");\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (hnd->read_const_char_from_obj_func) {\n\t\t\t\t\tretchar = hnd->read_const_char_from_obj_func(obj);\n\t\t\t\t\tlen = strlen(retchar);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tswitch (hnd->type) {\n\t\tcase IS_STRING:\n\t\t\tif (retchar) {\n\t\t\t\tZVAL_STRINGL(rv, (char *) retchar, len);\n\t\t\t} else {\n\t\t\t\tZVAL_EMPTY_STRING(rv);\n\t\t\t}\n\t\t\tbreak;\n\t\t/* case IS_TRUE */\n\t\tcase IS_FALSE:\n\t\t\tZVAL_BOOL(rv, (long)retint);\n\t\t\tbreak;\n\t\tcase IS_LONG:\n\t\t\tZVAL_LONG(rv, (long)retint);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tZVAL_NULL(rv);\n\t}\n\n\treturn rv;\n}\n/* }}} */\n\nstatic zval *php_zip_get_property_ptr_ptr(zval *object, zval *member, int type, void **cache_slot) /* {{{ */\n{\n\tze_zip_object *obj;\n\tzval tmp_member;\n\tzval *retval = NULL;\n\tzip_prop_handler *hnd = NULL;\n\tzend_object_handlers *std_hnd;\n\n\tif (Z_TYPE_P(member) != IS_STRING) {\n\t\tZVAL_COPY(&tmp_member, member);\n\t\tconvert_to_string(&tmp_member);\n\t\tmember = &tmp_member;\n\t\tcache_slot = NULL;\n\t}\n\n\tobj = Z_ZIP_P(object);\n\n\tif (obj->prop_handler != NULL) {\n\t\thnd = zend_hash_find_ptr(obj->prop_handler, Z_STR_P(member));\n\t}\n\n\tif (hnd == NULL) {\n\t\tstd_hnd = zend_get_std_object_handlers();\n\t\tretval = std_hnd->get_property_ptr_ptr(object, member, type, cache_slot);\n\t}\n\n\tif (member == &tmp_member) {\n\t\tzval_dtor(member);\n\t}\n\n\treturn retval;\n}\n/* }}} */\n\nstatic zval *php_zip_read_property(zval *object, zval *member, int type, void **cache_slot, zval *rv) /* {{{ */\n{\n\tze_zip_object *obj;\n\tzval tmp_member;\n\tzval *retval = NULL;\n\tzip_prop_handler *hnd = NULL;\n\tzend_object_handlers *std_hnd;\n\n\tif (Z_TYPE_P(member) != IS_STRING) {\n\t\tZVAL_COPY(&tmp_member, member);\n\t\tconvert_to_string(&tmp_member);\n\t\tmember = &tmp_member;\n\t\tcache_slot = NULL;\n\t}\n\n\tobj = Z_ZIP_P(object);\n\n\tif (obj->prop_handler != NULL) {\n\t\thnd = zend_hash_find_ptr(obj->prop_handler, Z_STR_P(member));\n\t}\n\n\tif (hnd != NULL) {\n\t\tretval = php_zip_property_reader(obj, hnd, rv);\n\t\tif (retval == NULL) {\n\t\t\tretval = &EG(uninitialized_zval);\n\t\t}\n\t} else {\n\t\tstd_hnd = zend_get_std_object_handlers();\n\t\tretval = std_hnd->read_property(object, member, type, cache_slot, rv);\n\t}\n\n\tif (member == &tmp_member) {\n\t\tzval_dtor(member);\n\t}\n\n\treturn retval;\n}\n/* }}} */\n\nstatic int php_zip_has_property(zval *object, zval *member, int type, void **cache_slot) /* {{{ */\n{\n\tze_zip_object *obj;\n\tzval tmp_member;\n\tzip_prop_handler *hnd = NULL;\n\tzend_object_handlers *std_hnd;\n\tint retval = 0;\n\n\tif (Z_TYPE_P(member) != IS_STRING) {\n\t\tZVAL_COPY(&tmp_member, member);\n\t\tconvert_to_string(&tmp_member);\n\t\tmember = &tmp_member;\n\t\tcache_slot = NULL;\n\t}\n\n\tobj = Z_ZIP_P(object);\n\n\tif (obj->prop_handler != NULL) {\n\t\thnd = zend_hash_find_ptr(obj->prop_handler, Z_STR_P(member));\n\t}\n\n\tif (hnd != NULL) {\n\t\tzval tmp, *prop;\n\n\t\tif (type == 2) {\n\t\t\tretval = 1;\n\t\t} else if ((prop = php_zip_property_reader(obj, hnd, &tmp)) != NULL) {\n\t\t\tif (type == 1) {\n\t\t\t\tretval = zend_is_true(&tmp);\n\t\t\t} else if (type == 0) {\n\t\t\t\tretval = (Z_TYPE(tmp) != IS_NULL);\n\t\t\t}\n\t\t}\n\n\t\tzval_ptr_dtor(&tmp);\n\t} else {\n\t\tstd_hnd = zend_get_std_object_handlers();\n\t\tretval = std_hnd->has_property(object, member, type, cache_slot);\n\t}\n\n\tif (member == &tmp_member) {\n\t\tzval_dtor(member);\n\t}\n\n\treturn retval;\n}\n/* }}} */\n\nstatic HashTable *php_zip_get_properties(zval *object)/* {{{ */\n{\n\tze_zip_object *obj;\n\tHashTable *props;\n\tzip_prop_handler *hnd;\n\tzend_string *key;\n\n\tobj = Z_ZIP_P(object);\n\tprops = zend_std_get_properties(object);\n\n\tif (obj->prop_handler == NULL) {\n\t\treturn NULL;\n\t}\n\n\tZEND_HASH_FOREACH_STR_KEY_PTR(obj->prop_handler, key, hnd) {\n\t\tzval *ret, val;\n\t\tret = php_zip_property_reader(obj, hnd, &val);\n\t\tif (ret == NULL) {\n\t\t\tret = &EG(uninitialized_zval);\n\t\t}\n\t\tzend_hash_update(props, key, ret);\n\t} ZEND_HASH_FOREACH_END();\n\n\treturn props;\n}\n/* }}} */\n\nstatic void php_zip_object_free_storage(zend_object *object) /* {{{ */\n{\n\tze_zip_object * intern = php_zip_fetch_object(object);\n\tint i;\n\n\tif (!intern) {\n\t\treturn;\n\t}\n\tif (intern->za) {\n\t\tif (zip_close(intern->za) != 0) {\n\t\t\tphp_error_docref(NULL, E_WARNING, \"Cannot destroy the zip context: %s\", zip_strerror(intern->za));\n\t\t\treturn;\n\t\t}\n\t\tintern->za = NULL;\n\t}\n\n\tif (intern->buffers_cnt>0) {\n\t\tfor (i=0; i<intern->buffers_cnt; i++) {\n\t\t\tefree(intern->buffers[i]);\n\t\t}\n\t\tefree(intern->buffers);\n\t}\n\n\tintern->za = NULL;\n\tzend_object_std_dtor(&intern->zo);\n\n\tif (intern->filename) {\n\t\tefree(intern->filename);\n\t}\n}\n/* }}} */\n\nstatic zend_object *php_zip_object_new(zend_class_entry *class_type) /* {{{ */\n{\n\tze_zip_object *intern;\n\n\tintern = ecalloc(1, sizeof(ze_zip_object) + zend_object_properties_size(class_type));\n\tintern->prop_handler = &zip_prop_handlers;\n\tzend_object_std_init(&intern->zo, class_type);\n\tobject_properties_init(&intern->zo, class_type);\n\tintern->zo.handlers = &zip_object_handlers;\n\n\treturn &intern->zo;\n}\n/* }}} */\n\n/* {{{ Resource dtors */\n\n/* {{{ php_zip_free_dir */\nstatic void php_zip_free_dir(zend_resource *rsrc)\n{\n\tzip_rsrc * zip_int = (zip_rsrc *) rsrc->ptr;\n\n\tif (zip_int) {\n\t\tif (zip_int->za) {\n\t\t\tif (zip_close(zip_int->za) != 0) {\n\t\t\t\tphp_error_docref(NULL, E_WARNING, \"Cannot destroy the zip context\");\n\t\t\t}\n\t\t\tzip_int->za = NULL;\n\t\t}\n\n\t\tefree(rsrc->ptr);\n\n\t\trsrc->ptr = NULL;\n\t}\n}\n/* }}} */\n\n/* {{{ php_zip_free_entry */\nstatic void php_zip_free_entry(zend_resource *rsrc)\n{\n\tzip_read_rsrc *zr_rsrc = (zip_read_rsrc *) rsrc->ptr;\n\n\tif (zr_rsrc) {\n\t\tif (zr_rsrc->zf) {\n\t\t\tzip_fclose(zr_rsrc->zf);\n\t\t\tzr_rsrc->zf = NULL;\n\t\t}\n\t\tefree(zr_rsrc);\n\t\trsrc->ptr = NULL;\n\t}\n}\n/* }}} */\n\n/* }}}*/\n\n/* reset macro */\n\n/* {{{ function prototypes */\nstatic PHP_MINIT_FUNCTION(zip);\nstatic PHP_MSHUTDOWN_FUNCTION(zip);\nstatic PHP_MINFO_FUNCTION(zip);\n/* }}} */\n\n/* {{{ zip_module_entry\n */\nzend_module_entry zip_module_entry = {\n\tSTANDARD_MODULE_HEADER,\n\t\"zip\",\n\tzip_functions,\n\tPHP_MINIT(zip),\n\tPHP_MSHUTDOWN(zip),\n\tNULL,\n\tNULL,\n\tPHP_MINFO(zip),\n\tPHP_ZIP_VERSION,\n\tSTANDARD_MODULE_PROPERTIES\n};\n/* }}} */\n\n#ifdef COMPILE_DL_ZIP\nZEND_GET_MODULE(zip)\n#endif\n/* set macro */\n\n/* {{{ proto resource zip_open(string filename)\nCreate new zip using source uri for output */\nstatic PHP_NAMED_FUNCTION(zif_zip_open)\n{\n\tchar resolved_path[MAXPATHLEN + 1];\n\tzip_rsrc *rsrc_int;\n\tint err = 0;\n\tzend_string *filename;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"P\", &filename) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (ZSTR_LEN(filename) == 0) {\n\t\tphp_error_docref(NULL, E_WARNING, \"Empty string as source\");\n\t\tRETURN_FALSE;\n\t}\n\n\tif (ZIP_OPENBASEDIR_CHECKPATH(ZSTR_VAL(filename))) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif(!expand_filepath(ZSTR_VAL(filename), resolved_path)) {\n\t\tRETURN_FALSE;\n\t}\n\n\trsrc_int = (zip_rsrc *)emalloc(sizeof(zip_rsrc));\n\n\trsrc_int->za = zip_open(resolved_path, 0, &err);\n\tif (rsrc_int->za == NULL) {\n\t\tefree(rsrc_int);\n\t\tRETURN_LONG((zend_long)err);\n\t}\n\n\trsrc_int->index_current = 0;\n\trsrc_int->num_files = zip_get_num_files(rsrc_int->za);\n\n\tRETURN_RES(zend_register_resource(rsrc_int, le_zip_dir));\n}\n/* }}} */\n\n/* {{{ proto void zip_close(resource zip)\n   Close a Zip archive */\nstatic PHP_NAMED_FUNCTION(zif_zip_close)\n{\n\tzval * zip;\n\tzip_rsrc *z_rsrc = NULL;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"r\", &zip) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif ((z_rsrc = (zip_rsrc *)zend_fetch_resource(Z_RES_P(zip), le_zip_dir_name, le_zip_dir)) == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\n\t/* really close the zip will break BC :-D */\n\tzend_list_close(Z_RES_P(zip));\n}\n/* }}} */\n\n/* {{{ proto resource zip_read(resource zip)\n   Returns the next file in the archive */\nstatic PHP_NAMED_FUNCTION(zif_zip_read)\n{\n\tzval *zip_dp;\n\tzip_read_rsrc *zr_rsrc;\n\tint ret;\n\tzip_rsrc *rsrc_int;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"r\", &zip_dp) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif ((rsrc_int = (zip_rsrc *)zend_fetch_resource(Z_RES_P(zip_dp), le_zip_dir_name, le_zip_dir)) == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (rsrc_int && rsrc_int->za) {\n\t\tif (rsrc_int->index_current >= rsrc_int->num_files) {\n\t\t\tRETURN_FALSE;\n\t\t}\n\n\t\tzr_rsrc = emalloc(sizeof(zip_read_rsrc));\n\n\t\tret = zip_stat_index(rsrc_int->za, rsrc_int->index_current, 0, &zr_rsrc->sb);\n\n\t\tif (ret != 0) {\n\t\t\tefree(zr_rsrc);\n\t\t\tRETURN_FALSE;\n\t\t}\n\n\t\tzr_rsrc->zf = zip_fopen_index(rsrc_int->za, rsrc_int->index_current, 0);\n\t\tif (zr_rsrc->zf) {\n\t\t\trsrc_int->index_current++;\n\t\t\tRETURN_RES(zend_register_resource(zr_rsrc, le_zip_entry));\n\t\t} else {\n\t\t\tefree(zr_rsrc);\n\t\t\tRETURN_FALSE;\n\t\t}\n\n\t} else {\n\t\tRETURN_FALSE;\n\t}\n}\n/* }}} */\n\n/* {{{ proto bool zip_entry_open(resource zip_dp, resource zip_entry [, string mode])\n   Open a Zip File, pointed by the resource entry */\n/* Dummy function to follow the old API */\nstatic PHP_NAMED_FUNCTION(zif_zip_entry_open)\n{\n\tzval * zip;\n\tzval * zip_entry;\n\tchar *mode = NULL;\n\tsize_t mode_len = 0;\n\tzip_read_rsrc * zr_rsrc;\n\tzip_rsrc *z_rsrc;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"rr|s\", &zip, &zip_entry, &mode, &mode_len) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif ((zr_rsrc = (zip_read_rsrc *)zend_fetch_resource(Z_RES_P(zip_entry), le_zip_entry_name, le_zip_entry)) == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif ((z_rsrc = (zip_rsrc *)zend_fetch_resource(Z_RES_P(zip), le_zip_dir_name, le_zip_dir)) == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (zr_rsrc->zf != NULL) {\n\t\tRETURN_TRUE;\n\t} else {\n\t\tRETURN_FALSE;\n\t}\n}\n/* }}} */\n\n/* {{{ proto bool zip_entry_close(resource zip_ent)\n   Close a zip entry */\nstatic PHP_NAMED_FUNCTION(zif_zip_entry_close)\n{\n\tzval * zip_entry;\n\tzip_read_rsrc * zr_rsrc;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"r\", &zip_entry) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif ((zr_rsrc = (zip_read_rsrc *)zend_fetch_resource(Z_RES_P(zip_entry), le_zip_entry_name, le_zip_entry)) == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\n\tRETURN_BOOL(SUCCESS == zend_list_close(Z_RES_P(zip_entry)));\n}\n/* }}} */\n\n/* {{{ proto mixed zip_entry_read(resource zip_entry [, int len])\n   Read from an open directory entry */\nstatic PHP_NAMED_FUNCTION(zif_zip_entry_read)\n{\n\tzval * zip_entry;\n\tzend_long len = 0;\n\tzip_read_rsrc * zr_rsrc;\n\tzend_string *buffer;\n\tint n = 0;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"r|l\", &zip_entry, &len) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif ((zr_rsrc = (zip_read_rsrc *)zend_fetch_resource(Z_RES_P(zip_entry), le_zip_entry_name, le_zip_entry)) == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (len <= 0) {\n\t\tlen = 1024;\n\t}\n\n\tif (zr_rsrc->zf) {\n\t\tbuffer = zend_string_alloc(len, 0);\n\t\tn = zip_fread(zr_rsrc->zf, ZSTR_VAL(buffer), ZSTR_LEN(buffer));\n\t\tif (n > 0) {\n\t\t\tZSTR_VAL(buffer)[n] = '\\0';\n\t\t\tZSTR_LEN(buffer) = n;\n\t\t\tRETURN_NEW_STR(buffer);\n\t\t} else {\n\t\t\tzend_string_free(buffer);\n\t\t\tRETURN_EMPTY_STRING()\n\t\t}\n\t} else {\n\t\tRETURN_FALSE;\n\t}\n}\n/* }}} */\n\nstatic void php_zip_entry_get_info(INTERNAL_FUNCTION_PARAMETERS, int opt) /* {{{ */\n{\n\tzval * zip_entry;\n\tzip_read_rsrc * zr_rsrc;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"r\", &zip_entry) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif ((zr_rsrc = (zip_read_rsrc *)zend_fetch_resource(Z_RES_P(zip_entry), le_zip_entry_name, le_zip_entry)) == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (!zr_rsrc->zf) {\n\t\tRETURN_FALSE;\n\t}\n\n\tswitch (opt) {\n\t\tcase 0:\n\t\t\tRETURN_STRING((char *)zr_rsrc->sb.name);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tRETURN_LONG((zend_long) (zr_rsrc->sb.comp_size));\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tRETURN_LONG((zend_long) (zr_rsrc->sb.size));\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tswitch (zr_rsrc->sb.comp_method) {\n\t\t\t\tcase 0:\n\t\t\t\t\tRETURN_STRING(\"stored\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\tRETURN_STRING(\"shrunk\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\tcase 3:\n\t\t\t\tcase 4:\n\t\t\t\tcase 5:\n\t\t\t\t\tRETURN_STRING(\"reduced\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase 6:\n\t\t\t\t\tRETURN_STRING(\"imploded\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase 7:\n\t\t\t\t\tRETURN_STRING(\"tokenized\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase 8:\n\t\t\t\t\tRETURN_STRING(\"deflated\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase 9:\n\t\t\t\t\tRETURN_STRING(\"deflatedX\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase 10:\n\t\t\t\t\tRETURN_STRING(\"implodedX\");\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tRETURN_FALSE;\n\t\t\t}\n\t\t\tRETURN_LONG((zend_long) (zr_rsrc->sb.comp_method));\n\t\t\tbreak;\n\t}\n\n}\n/* }}} */\n\n/* {{{ proto string zip_entry_name(resource zip_entry)\n   Return the name given a ZZip entry */\nstatic PHP_NAMED_FUNCTION(zif_zip_entry_name)\n{\n\tphp_zip_entry_get_info(INTERNAL_FUNCTION_PARAM_PASSTHRU, 0);\n}\n/* }}} */\n\n/* {{{ proto int zip_entry_compressedsize(resource zip_entry)\n   Return the compressed size of a ZZip entry */\nstatic PHP_NAMED_FUNCTION(zif_zip_entry_compressedsize)\n{\n\tphp_zip_entry_get_info(INTERNAL_FUNCTION_PARAM_PASSTHRU, 1);\n}\n/* }}} */\n\n/* {{{ proto int zip_entry_filesize(resource zip_entry)\n   Return the actual filesize of a ZZip entry */\nstatic PHP_NAMED_FUNCTION(zif_zip_entry_filesize)\n{\n\tphp_zip_entry_get_info(INTERNAL_FUNCTION_PARAM_PASSTHRU, 2);\n}\n/* }}} */\n\n/* {{{ proto string zip_entry_compressionmethod(resource zip_entry)\n   Return a string containing the compression method used on a particular entry */\nstatic PHP_NAMED_FUNCTION(zif_zip_entry_compressionmethod)\n{\n\tphp_zip_entry_get_info(INTERNAL_FUNCTION_PARAM_PASSTHRU, 3);\n}\n/* }}} */\n\n/* {{{ proto mixed ZipArchive::open(string source [, int flags])\nCreate new zip using source uri for output, return TRUE on success or the error code */\nstatic ZIPARCHIVE_METHOD(open)\n{\n\tstruct zip *intern;\n\tint err = 0;\n\tzend_long flags = 0;\n\tchar *resolved_path;\n\tzend_string *filename;\n\tzval *self = getThis();\n\tze_zip_object *ze_obj = NULL;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"P|l\", &filename, &flags) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (self) {\n\t\t/* We do not use ZIP_FROM_OBJECT, zip init function here */\n\t\tze_obj = Z_ZIP_P(self);\n\t}\n\n\tif (ZSTR_LEN(filename) == 0) {\n\t\tphp_error_docref(NULL, E_WARNING, \"Empty string as source\");\n\t\tRETURN_FALSE;\n\t}\n\n\tif (ZIP_OPENBASEDIR_CHECKPATH(ZSTR_VAL(filename))) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (!(resolved_path = expand_filepath(ZSTR_VAL(filename), NULL))) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (ze_obj->za) {\n\t\t/* we already have an opened zip, free it */\n\t\tif (zip_close(ze_obj->za) != 0) {\n\t\t\tphp_error_docref(NULL, E_WARNING, \"Empty string as source\");\n\t\t\tefree(resolved_path);\n\t\t\tRETURN_FALSE;\n\t\t}\n\t\tze_obj->za = NULL;\n\t}\n\tif (ze_obj->filename) {\n\t\tefree(ze_obj->filename);\n\t\tze_obj->filename = NULL;\n\t}\n\n\tintern = zip_open(resolved_path, flags, &err);\n\tif (!intern || err) {\n\t\tefree(resolved_path);\n\t\tRETURN_LONG((zend_long)err);\n\t}\n\tze_obj->filename = resolved_path;\n\tze_obj->filename_len = strlen(resolved_path);\n\tze_obj->za = intern;\n\tRETURN_TRUE;\n}\n/* }}} */\n\n/* {{{ proto resource ZipArchive::setPassword(string password)\nSet the password for the active archive */\nstatic ZIPARCHIVE_METHOD(setPassword)\n{\n\tstruct zip *intern;\n\tzval *self = getThis();\n\tchar *password;\n\tsize_t\tpassword_len;\n\n\tif (!self) {\n\t\tRETURN_FALSE;\n\t}\n\n\tZIP_FROM_OBJECT(intern, self);\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"s\", &password, &password_len) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (password_len < 1) {\n\t\tRETURN_FALSE;\n\t} else {\n\t\tint res = zip_set_default_password(intern, (const char *)password);\n\t\tif (res == 0) {\n\t\t\tRETURN_TRUE;\n\t\t} else {\n\t\t\tRETURN_FALSE;\n\t\t}\n\t}\n}\n/* }}} */\n\n/* {{{ proto bool ZipArchive::close()\nclose the zip archive */\nstatic ZIPARCHIVE_METHOD(close)\n{\n\tstruct zip *intern;\n\tzval *self = getThis();\n\tze_zip_object *ze_obj;\n\tint err;\n\n\tif (!self) {\n\t\tRETURN_FALSE;\n\t}\n\n\tZIP_FROM_OBJECT(intern, self);\n\n\tze_obj = Z_ZIP_P(self);\n\n\tif ((err = zip_close(intern))) {\n\t\tphp_error_docref(NULL, E_WARNING, \"%s\", zip_strerror(intern));\n\t\tzip_discard(intern);\n\t}\n\n\tefree(ze_obj->filename);\n\tze_obj->filename = NULL;\n\tze_obj->filename_len = 0;\n\tze_obj->za = NULL;\n\n\tif (!err) {\n\t\tRETURN_TRUE;\n\t} else {\n\t\tRETURN_FALSE;\n\t}\n}\n/* }}} */\n\n/* {{{ proto string ZipArchive::getStatusString()\n * Returns the status error message, system and/or zip messages */\nstatic ZIPARCHIVE_METHOD(getStatusString)\n{\n\tstruct zip *intern;\n\tzval *self = getThis();\n#if LIBZIP_VERSION_MAJOR < 1\n\tint zep, syp, len;\n\tchar error_string[128];\n#else\n\tzip_error_t *err;\n#endif\n\n\tif (!self) {\n\t\tRETURN_FALSE;\n\t}\n\n\tZIP_FROM_OBJECT(intern, self);\n\n#if LIBZIP_VERSION_MAJOR < 1\n\tzip_error_get(intern, &zep, &syp);\n\n\tlen = zip_error_to_str(error_string, 128, zep, syp);\n\tRETVAL_STRINGL(error_string, len);\n#else\n\terr = zip_get_error(intern);\n\tRETVAL_STRING(zip_error_strerror(err));\n\tzip_error_fini(err);\n#endif\n}\n/* }}} */\n\n/* {{{ proto bool ZipArchive::createEmptyDir(string dirname)\nReturns the index of the entry named filename in the archive */\nstatic ZIPARCHIVE_METHOD(addEmptyDir)\n{\n\tstruct zip *intern;\n\tzval *self = getThis();\n\tchar *dirname;\n\tsize_t   dirname_len;\n\tint idx;\n\tstruct zip_stat sb;\n\tchar *s;\n\n\tif (!self) {\n\t\tRETURN_FALSE;\n\t}\n\n\tZIP_FROM_OBJECT(intern, self);\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"s\",\n\t\t\t\t&dirname, &dirname_len) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (dirname_len<1) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (dirname[dirname_len-1] != '/') {\n\t\ts=(char *)emalloc(dirname_len+2);\n\t\tstrcpy(s, dirname);\n\t\ts[dirname_len] = '/';\n\t\ts[dirname_len+1] = '\\0';\n\t} else {\n\t\ts = dirname;\n\t}\n\n\tidx = zip_stat(intern, s, 0, &sb);\n\tif (idx >= 0) {\n\t\tRETVAL_FALSE;\n\t} else {\n\t\tif (zip_add_dir(intern, (const char *)s) == -1) {\n\t\t\tRETVAL_FALSE;\n\t\t}\n\t\tzip_error_clear(intern);\n\t\tRETVAL_TRUE;\n\t}\n\n\tif (s != dirname) {\n\t\tefree(s);\n\t}\n}\n/* }}} */\n\nstatic void php_zip_add_from_pattern(INTERNAL_FUNCTION_PARAMETERS, int type) /* {{{ */\n{\n\tstruct zip *intern;\n\tzval *self = getThis();\n\tchar *path = NULL;\n\tchar *remove_path = NULL;\n\tchar *add_path = NULL;\n\tsize_t  add_path_len, remove_path_len = 0, path_len = 0;\n\tzend_long remove_all_path = 0;\n\tzend_long flags = 0;\n\tzval *options = NULL;\n\tint found;\n\tzend_string *pattern;\n\n\tif (!self) {\n\t\tRETURN_FALSE;\n\t}\n\n\tZIP_FROM_OBJECT(intern, self);\n\t/* 1 == glob, 2 == pcre */\n\tif (type == 1) {\n\t\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"P|la\",\n\t\t\t\t\t&pattern, &flags, &options) == FAILURE) {\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"P|sa\",\n\t\t\t\t\t&pattern, &path, &path_len, &options) == FAILURE) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (ZSTR_LEN(pattern) == 0) {\n\t\tphp_error_docref(NULL, E_NOTICE, \"Empty string as pattern\");\n\t\tRETURN_FALSE;\n\t}\n\tif (options && (php_zip_parse_options(options, &remove_all_path, &remove_path, &remove_path_len,\n\t\t\t&add_path, &add_path_len) < 0)) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (remove_path && remove_path_len > 1) {\n\t\tsize_t real_len = strlen(remove_path);\n\t\tif ((real_len > 1) && ((remove_path[real_len - 1] == '/') || (remove_path[real_len - 1] == '\\\\'))) {\n\t\t\tremove_path[real_len - 1] = '\\0';\n\t\t}\n\t}\n\n\tif (type == 1) {\n\t\tfound = php_zip_glob(ZSTR_VAL(pattern), ZSTR_LEN(pattern), flags, return_value);\n\t} else {\n\t\tfound = php_zip_pcre(pattern, path, path_len, return_value);\n\t}\n\n\tif (found > 0) {\n\t\tint i;\n\t\tzval *zval_file;\n\n\t\tfor (i = 0; i < found; i++) {\n\t\t\tchar *file_stripped, *entry_name;\n\t\t\tsize_t entry_name_len, file_stripped_len;\n\t\t\tchar entry_name_buf[MAXPATHLEN];\n\t\t\tzend_string *basename = NULL;\n\n\t\t\tif ((zval_file = zend_hash_index_find(Z_ARRVAL_P(return_value), i)) != NULL) {\n\t\t\t\tif (remove_all_path) {\n\t\t\t\t\tbasename = php_basename(Z_STRVAL_P(zval_file), Z_STRLEN_P(zval_file), NULL, 0);\n\t\t\t\t\tfile_stripped = ZSTR_VAL(basename);\n\t\t\t\t\tfile_stripped_len = ZSTR_LEN(basename);\n\t\t\t\t} else if (remove_path && strstr(Z_STRVAL_P(zval_file), remove_path) != NULL) {\n\t\t\t\t\tfile_stripped = Z_STRVAL_P(zval_file) + remove_path_len + 1;\n\t\t\t\t\tfile_stripped_len = Z_STRLEN_P(zval_file) - remove_path_len - 1;\n\t\t\t\t} else {\n\t\t\t\t\tfile_stripped = Z_STRVAL_P(zval_file);\n\t\t\t\t\tfile_stripped_len = Z_STRLEN_P(zval_file);\n\t\t\t\t}\n\n\t\t\t\tif (add_path) {\n\t\t\t\t\tif ((add_path_len + file_stripped_len) > MAXPATHLEN) {\n\t\t\t\t\t\tphp_error_docref(NULL, E_WARNING, \"Entry name too long (max: %d, %pd given)\",\n\t\t\t\t\t\tMAXPATHLEN - 1, (add_path_len + file_stripped_len));\n\t\t\t\t\t\tzval_ptr_dtor(return_value);\n\t\t\t\t\t\tRETURN_FALSE;\n\t\t\t\t\t}\n\n\t\t\t\t\tsnprintf(entry_name_buf, MAXPATHLEN, \"%s%s\", add_path, file_stripped);\n\t\t\t\t\tentry_name = entry_name_buf;\n\t\t\t\t\tentry_name_len = strlen(entry_name);\n\t\t\t\t} else {\n\t\t\t\t\tentry_name = Z_STRVAL_P(zval_file);\n\t\t\t\t\tentry_name_len = Z_STRLEN_P(zval_file);\n\t\t\t\t}\n\t\t\t\tif (basename) {\n\t\t\t\t\tzend_string_release(basename);\n\t\t\t\t\tbasename = NULL;\n\t\t\t\t}\n\t\t\t\tif (php_zip_add_file(intern, Z_STRVAL_P(zval_file), Z_STRLEN_P(zval_file),\n\t\t\t\t\tentry_name, entry_name_len, 0, 0) < 0) {\n\t\t\t\t\tzval_dtor(return_value);\n\t\t\t\t\tRETURN_FALSE;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n/* }}} */\n\n/* {{{ proto bool ZipArchive::addGlob(string pattern[,int flags [, array options]])\nAdd files matching the glob pattern. See php's glob for the pattern syntax. */\nstatic ZIPARCHIVE_METHOD(addGlob)\n{\n\tphp_zip_add_from_pattern(INTERNAL_FUNCTION_PARAM_PASSTHRU, 1);\n}\n/* }}} */\n\n/* {{{ proto bool ZipArchive::addPattern(string pattern[, string path [, array options]])\nAdd files matching the pcre pattern. See php's pcre for the pattern syntax. */\nstatic ZIPARCHIVE_METHOD(addPattern)\n{\n\tphp_zip_add_from_pattern(INTERNAL_FUNCTION_PARAM_PASSTHRU, 2);\n}\n/* }}} */\n\n/* {{{ proto bool ZipArchive::addFile(string filepath[, string entryname[, int start [, int length]]])\nAdd a file in a Zip archive using its path and the name to use. */\nstatic ZIPARCHIVE_METHOD(addFile)\n{\n\tstruct zip *intern;\n\tzval *self = getThis();\n\tchar *entry_name = NULL;\n\tsize_t entry_name_len = 0;\n\tzend_long offset_start = 0, offset_len = 0;\n\tzend_string *filename;\n\n\tif (!self) {\n\t\tRETURN_FALSE;\n\t}\n\n\tZIP_FROM_OBJECT(intern, self);\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"P|sll\",\n\t\t\t&filename, &entry_name, &entry_name_len, &offset_start, &offset_len) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (ZSTR_LEN(filename) == 0) {\n\t\tphp_error_docref(NULL, E_NOTICE, \"Empty string as filename\");\n\t\tRETURN_FALSE;\n\t}\n\n\tif (entry_name_len == 0) {\n\t\tentry_name = ZSTR_VAL(filename);\n\t\tentry_name_len = ZSTR_LEN(filename);\n\t}\n\n\tif (php_zip_add_file(intern, ZSTR_VAL(filename), ZSTR_LEN(filename), entry_name, entry_name_len, 0, 0) < 0) {\n\t\tRETURN_FALSE;\n\t} else {\n\t\tRETURN_TRUE;\n\t}\n}\n/* }}} */\n\n/* {{{ proto bool ZipArchive::addFromString(string name, string content)\nAdd a file using content and the entry name */\nstatic ZIPARCHIVE_METHOD(addFromString)\n{\n\tstruct zip *intern;\n\tzval *self = getThis();\n\tzend_string *buffer;\n\tchar *name;\n\tsize_t name_len;\n\tze_zip_object *ze_obj;\n\tstruct zip_source *zs;\n\tint pos = 0;\n\tint cur_idx;\n\n\tif (!self) {\n\t\tRETURN_FALSE;\n\t}\n\n\tZIP_FROM_OBJECT(intern, self);\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"sS\",\n\t\t\t&name, &name_len, &buffer) == FAILURE) {\n\t\treturn;\n\t}\n\n\tze_obj = Z_ZIP_P(self);\n\tif (ze_obj->buffers_cnt) {\n\t\tze_obj->buffers = (char **)erealloc(ze_obj->buffers, sizeof(char *) * (ze_obj->buffers_cnt+1));\n\t\tpos = ze_obj->buffers_cnt++;\n\t} else {\n\t\tze_obj->buffers = (char **)emalloc(sizeof(char *));\n\t\tze_obj->buffers_cnt++;\n\t\tpos = 0;\n\t}\n\tze_obj->buffers[pos] = (char *)emalloc(ZSTR_LEN(buffer) + 1);\n\tmemcpy(ze_obj->buffers[pos], ZSTR_VAL(buffer), ZSTR_LEN(buffer) + 1);\n\n\tzs = zip_source_buffer(intern, ze_obj->buffers[pos], ZSTR_LEN(buffer), 0);\n\n\tif (zs == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\n\tcur_idx = zip_name_locate(intern, (const char *)name, 0);\n\t/* TODO: fix  _zip_replace */\n\tif (cur_idx >= 0) {\n\t\tif (zip_delete(intern, cur_idx) == -1) {\n\t\t\tzip_source_free(zs);\n\t\t\tRETURN_FALSE;\n\t\t}\n\t}\n\n\tif (zip_add(intern, name, zs) == -1) {\n\t\tzip_source_free(zs);\n\t\tRETURN_FALSE;\n\t} else {\n\t\tzip_error_clear(intern);\n\t\tRETURN_TRUE;\n\t}\n}\n/* }}} */\n\n/* {{{ proto array ZipArchive::statName(string filename[, int flags])\nReturns the information about a the zip entry filename */\nstatic ZIPARCHIVE_METHOD(statName)\n{\n\tstruct zip *intern;\n\tzval *self = getThis();\n\tzend_long flags = 0;\n\tstruct zip_stat sb;\n\tzend_string *name;\n\n\tif (!self) {\n\t\tRETURN_FALSE;\n\t}\n\n\tZIP_FROM_OBJECT(intern, self);\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"P|l\", &name, &flags) == FAILURE) {\n\t\treturn;\n\t}\n\n\tPHP_ZIP_STAT_PATH(intern, ZSTR_VAL(name), ZSTR_LEN(name), flags, sb);\n\n\tRETURN_SB(&sb);\n}\n/* }}} */\n\n/* {{{ proto resource ZipArchive::statIndex(int index[, int flags])\nReturns the zip entry informations using its index */\nstatic ZIPARCHIVE_METHOD(statIndex)\n{\n\tstruct zip *intern;\n\tzval *self = getThis();\n\tzend_long index, flags = 0;\n\n\tstruct zip_stat sb;\n\n\tif (!self) {\n\t\tRETURN_FALSE;\n\t}\n\n\tZIP_FROM_OBJECT(intern, self);\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"l|l\",\n\t\t\t&index, &flags) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (zip_stat_index(intern, index, flags, &sb) != 0) {\n\t\tRETURN_FALSE;\n\t}\n\tRETURN_SB(&sb);\n}\n/* }}} */\n\n/* {{{ proto int ZipArchive::locateName(string filename[, int flags])\nReturns the index of the entry named filename in the archive */\nstatic ZIPARCHIVE_METHOD(locateName)\n{\n\tstruct zip *intern;\n\tzval *self = getThis();\n\tzend_long flags = 0;\n\tzend_long idx = -1;\n\tzend_string *name;\n\n\tif (!self) {\n\t\tRETURN_FALSE;\n\t}\n\n\tZIP_FROM_OBJECT(intern, self);\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"P|l\", &name, &flags) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (ZSTR_LEN(name) < 1) {\n\t\tRETURN_FALSE;\n\t}\n\n\tidx = (zend_long)zip_name_locate(intern, (const char *)ZSTR_VAL(name), flags);\n\n\tif (idx >= 0) {\n\t\tRETURN_LONG(idx);\n\t} else {\n\t\tRETURN_FALSE;\n\t}\n}\n/* }}} */\n\n/* {{{ proto string ZipArchive::getNameIndex(int index [, int flags])\nReturns the name of the file at position index */\nstatic ZIPARCHIVE_METHOD(getNameIndex)\n{\n\tstruct zip *intern;\n\tzval *self = getThis();\n\tconst char *name;\n\tzend_long flags = 0, index = 0;\n\n\tif (!self) {\n\t\tRETURN_FALSE;\n\t}\n\n\tZIP_FROM_OBJECT(intern, self);\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"l|l\",\n\t\t\t&index, &flags) == FAILURE) {\n\t\treturn;\n\t}\n\n\tname = zip_get_name(intern, (int) index, flags);\n\n\tif (name) {\n\t\tRETVAL_STRING((char *)name);\n\t} else {\n\t\tRETURN_FALSE;\n\t}\n}\n/* }}} */\n\n/* {{{ proto bool ZipArchive::setArchiveComment(string comment)\nSet or remove (NULL/'') the comment of the archive */\nstatic ZIPARCHIVE_METHOD(setArchiveComment)\n{\n\tstruct zip *intern;\n\tzval *self = getThis();\n\tsize_t comment_len;\n\tchar * comment;\n\n\tif (!self) {\n\t\tRETURN_FALSE;\n\t}\n\n\tZIP_FROM_OBJECT(intern, self);\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"s\", &comment, &comment_len) == FAILURE) {\n\t\treturn;\n\t}\n\tif (zip_set_archive_comment(intern, (const char *)comment, (int)comment_len)) {\n\t\tRETURN_FALSE;\n\t} else {\n\t\tRETURN_TRUE;\n\t}\n}\n/* }}} */\n\n/* {{{ proto string ZipArchive::getArchiveComment([int flags])\nReturns the comment of an entry using its index */\nstatic ZIPARCHIVE_METHOD(getArchiveComment)\n{\n\tstruct zip *intern;\n\tzval *self = getThis();\n\tzend_long flags = 0;\n\tconst char * comment;\n\tint comment_len = 0;\n\n\tif (!self) {\n\t\tRETURN_FALSE;\n\t}\n\n\tZIP_FROM_OBJECT(intern, self);\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"|l\", &flags) == FAILURE) {\n\t\treturn;\n\t}\n\n\tcomment = zip_get_archive_comment(intern, &comment_len, (int)flags);\n\tif(comment==NULL) {\n\t\tRETURN_FALSE;\n\t}\n\tRETURN_STRINGL((char *)comment, (zend_long)comment_len);\n}\n/* }}} */\n\n/* {{{ proto bool ZipArchive::setCommentName(string name, string comment)\nSet or remove (NULL/'') the comment of an entry using its Name */\nstatic ZIPARCHIVE_METHOD(setCommentName)\n{\n\tstruct zip *intern;\n\tzval *self = getThis();\n\tsize_t comment_len, name_len;\n\tchar * comment, *name;\n\tint idx;\n\n\tif (!self) {\n\t\tRETURN_FALSE;\n\t}\n\n\tZIP_FROM_OBJECT(intern, self);\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"ss\",\n\t\t\t&name, &name_len, &comment, &comment_len) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (name_len < 1) {\n\t\tphp_error_docref(NULL, E_NOTICE, \"Empty string as entry name\");\n\t}\n\n\tidx = zip_name_locate(intern, name, 0);\n\tif (idx < 0) {\n\t\tRETURN_FALSE;\n\t}\n\tPHP_ZIP_SET_FILE_COMMENT(intern, idx, comment, comment_len);\n}\n/* }}} */\n\n/* {{{ proto bool ZipArchive::setCommentIndex(int index, string comment)\nSet or remove (NULL/'') the comment of an entry using its index */\nstatic ZIPARCHIVE_METHOD(setCommentIndex)\n{\n\tstruct zip *intern;\n\tzval *self = getThis();\n\tzend_long index;\n\tsize_t comment_len;\n\tchar * comment;\n\tstruct zip_stat sb;\n\n\tif (!self) {\n\t\tRETURN_FALSE;\n\t}\n\n\tZIP_FROM_OBJECT(intern, self);\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"ls\",\n\t\t\t&index, &comment, &comment_len) == FAILURE) {\n\t\treturn;\n\t}\n\n\tPHP_ZIP_STAT_INDEX(intern, index, 0, sb);\n\tPHP_ZIP_SET_FILE_COMMENT(intern, index, comment, comment_len);\n}\n/* }}} */\n\n/* those constants/functions are only available in libzip since 0.11.2 */\n#ifdef ZIP_OPSYS_DEFAULT\n\n/* {{{ proto bool ZipArchive::setExternalAttributesName(string name, int opsys, int attr [, int flags])\nSet external attributes for file in zip, using its name */\nstatic ZIPARCHIVE_METHOD(setExternalAttributesName)\n{\n\tstruct zip *intern;\n\tzval *self = getThis();\n\tsize_t name_len;\n\tchar *name;\n\tzend_long flags=0, opsys, attr;\n\tzip_int64_t idx;\n\n\tif (!self) {\n\t\tRETURN_FALSE;\n\t}\n\n\tZIP_FROM_OBJECT(intern, self);\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"sll|l\",\n\t\t\t&name, &name_len, &opsys, &attr, &flags) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (name_len < 1) {\n\t\tphp_error_docref(NULL, E_NOTICE, \"Empty string as entry name\");\n\t}\n\n\tidx = zip_name_locate(intern, name, 0);\n\tif (idx < 0) {\n\t\tRETURN_FALSE;\n\t}\n\tif (zip_file_set_external_attributes(intern, idx, (zip_flags_t)flags,\n\t\t\t(zip_uint8_t)(opsys&0xff), (zip_uint32_t)attr) < 0) {\n\t\tRETURN_FALSE;\n\t}\n\tRETURN_TRUE;\n}\n/* }}} */\n\n/* {{{ proto bool ZipArchive::setExternalAttributesIndex(int index, int opsys, int attr [, int flags])\nSet external attributes for file in zip, using its index */\nstatic ZIPARCHIVE_METHOD(setExternalAttributesIndex)\n{\n\tstruct zip *intern;\n\tzval *self = getThis();\n\tzend_long index, flags=0, opsys, attr;\n\tstruct zip_stat sb;\n\n\tif (!self) {\n\t\tRETURN_FALSE;\n\t}\n\n\tZIP_FROM_OBJECT(intern, self);\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"lll|l\",\n\t\t\t&index, &opsys, &attr, &flags) == FAILURE) {\n\t\treturn;\n\t}\n\n\tPHP_ZIP_STAT_INDEX(intern, index, 0, sb);\n\tif (zip_file_set_external_attributes(intern, (zip_uint64_t)index,\n\t\t\t(zip_flags_t)flags, (zip_uint8_t)(opsys&0xff), (zip_uint32_t)attr) < 0) {\n\t\tRETURN_FALSE;\n\t}\n\tRETURN_TRUE;\n}\n/* }}} */\n\n/* {{{ proto bool ZipArchive::getExternalAttributesName(string name, int &opsys, int &attr [, int flags])\nGet external attributes for file in zip, using its name */\nstatic ZIPARCHIVE_METHOD(getExternalAttributesName)\n{\n\tstruct zip *intern;\n\tzval *self = getThis(), *z_opsys, *z_attr;\n\tsize_t name_len;\n\tchar *name;\n\tzend_long flags=0;\n\tzip_uint8_t opsys;\n\tzip_uint32_t attr;\n\tzip_int64_t idx;\n\n\tif (!self) {\n\t\tRETURN_FALSE;\n\t}\n\n\tZIP_FROM_OBJECT(intern, self);\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"sz/z/|l\",\n\t\t\t&name, &name_len, &z_opsys, &z_attr, &flags) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (name_len < 1) {\n\t\tphp_error_docref(NULL, E_NOTICE, \"Empty string as entry name\");\n\t}\n\n\tidx = zip_name_locate(intern, name, 0);\n\tif (idx < 0) {\n\t\tRETURN_FALSE;\n\t}\n\tif (zip_file_get_external_attributes(intern, idx,\n\t\t\t(zip_flags_t)flags, &opsys, &attr) < 0) {\n\t\tRETURN_FALSE;\n\t}\n\tzval_ptr_dtor(z_opsys);\n\tZVAL_LONG(z_opsys, opsys);\n\tzval_ptr_dtor(z_attr);\n\tZVAL_LONG(z_attr, attr);\n\tRETURN_TRUE;\n}\n/* }}} */\n\n/* {{{ proto bool ZipArchive::getExternalAttributesIndex(int index, int &opsys, int &attr [, int flags])\nGet external attributes for file in zip, using its index */\nstatic ZIPARCHIVE_METHOD(getExternalAttributesIndex)\n{\n\tstruct zip *intern;\n\tzval *self = getThis(), *z_opsys, *z_attr;\n\tzend_long index, flags=0;\n\tzip_uint8_t opsys;\n\tzip_uint32_t attr;\n\tstruct zip_stat sb;\n\n\tif (!self) {\n\t\tRETURN_FALSE;\n\t}\n\n\tZIP_FROM_OBJECT(intern, self);\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"lz/z/|l\",\n\t\t\t&index, &z_opsys, &z_attr, &flags) == FAILURE) {\n\t\treturn;\n\t}\n\n\tPHP_ZIP_STAT_INDEX(intern, index, 0, sb);\n\tif (zip_file_get_external_attributes(intern, (zip_uint64_t)index,\n\t\t\t(zip_flags_t)flags, &opsys, &attr) < 0) {\n\t\tRETURN_FALSE;\n\t}\n\tzval_dtor(z_opsys);\n\tZVAL_LONG(z_opsys, opsys);\n\tzval_dtor(z_attr);\n\tZVAL_LONG(z_attr, attr);\n\tRETURN_TRUE;\n}\n/* }}} */\n#endif /* ifdef ZIP_OPSYS_DEFAULT */\n\n/* {{{ proto string ZipArchive::getCommentName(string name[, int flags])\nReturns the comment of an entry using its name */\nstatic ZIPARCHIVE_METHOD(getCommentName)\n{\n\tstruct zip *intern;\n\tzval *self = getThis();\n\tsize_t name_len;\n\tint idx;\n\tzend_long flags = 0;\n\tint comment_len = 0;\n\tconst char * comment;\n\tchar *name;\n\n\tif (!self) {\n\t\tRETURN_FALSE;\n\t}\n\n\tZIP_FROM_OBJECT(intern, self);\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"s|l\",\n\t\t\t&name, &name_len, &flags) == FAILURE) {\n\t\treturn;\n\t}\n\tif (name_len < 1) {\n\t\tphp_error_docref(NULL, E_NOTICE, \"Empty string as entry name\");\n\t\tRETURN_FALSE;\n\t}\n\n\tidx = zip_name_locate(intern, name, 0);\n\tif (idx < 0) {\n\t\tRETURN_FALSE;\n\t}\n\n\tcomment = zip_get_file_comment(intern, idx, &comment_len, (int)flags);\n\tRETURN_STRINGL((char *)comment, (zend_long)comment_len);\n}\n/* }}} */\n\n/* {{{ proto string ZipArchive::getCommentIndex(int index[, int flags])\nReturns the comment of an entry using its index */\nstatic ZIPARCHIVE_METHOD(getCommentIndex)\n{\n\tstruct zip *intern;\n\tzval *self = getThis();\n\tzend_long index, flags = 0;\n\tconst char * comment;\n\tint comment_len = 0;\n\tstruct zip_stat sb;\n\n\tif (!self) {\n\t\tRETURN_FALSE;\n\t}\n\n\tZIP_FROM_OBJECT(intern, self);\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"l|l\",\n\t\t\t\t&index, &flags) == FAILURE) {\n\t\treturn;\n\t}\n\n\tPHP_ZIP_STAT_INDEX(intern, index, 0, sb);\n\tcomment = zip_get_file_comment(intern, index, &comment_len, (int)flags);\n\tRETURN_STRINGL((char *)comment, (zend_long)comment_len);\n}\n/* }}} */\n\n/* {{{ proto bool ZipArchive::setCompressionName(string name, int comp_method[, int comp_flags])\nSet the compression of a file in zip, using its name */\nstatic ZIPARCHIVE_METHOD(setCompressionName)\n {\n\tstruct zip *intern;\n\tzval *this = getThis();\n\tsize_t name_len;\n\tchar *name;\n\tzip_int64_t idx;\n\tzend_long comp_method, comp_flags = 0;\n\n\tif (!this) {\n\t\tRETURN_FALSE;\n\t}\n\n\tZIP_FROM_OBJECT(intern, this);\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"sl|l\",\n\t\t\t&name, &name_len, &comp_method, &comp_flags) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (name_len < 1) {\n\t\tphp_error_docref(NULL, E_NOTICE, \"Empty string as entry name\");\n\t}\n\n\tidx = zip_name_locate(intern, name, 0);\n\tif (idx < 0) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (zip_set_file_compression(intern, (zip_uint64_t)idx,\n\t\t\t(zip_int32_t)comp_method, (zip_uint32_t)comp_flags) != 0) {\n\t\tRETURN_FALSE;\n\t}\n\tRETURN_TRUE;\n}\n/* }}} */\n\n/* {{{ proto bool ZipArchive::setCompressionIndex(int index, int comp_method[, int comp_flags])\nSet the compression of a file in zip, using its index */\nstatic ZIPARCHIVE_METHOD(setCompressionIndex)\n{\n\tstruct zip *intern;\n\tzval *this = getThis();\n\tzend_long index;\n\tzend_long comp_method, comp_flags = 0;\n\n\tif (!this) {\n\t\tRETURN_FALSE;\n\t}\n\n\tZIP_FROM_OBJECT(intern, this);\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"ll|l\",\n\t\t\t&index, &comp_method, &comp_flags) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (zip_set_file_compression(intern, (zip_uint64_t)index,\n\t\t\t(zip_int32_t)comp_method, (zip_uint32_t)comp_flags) != 0) {\n\t\tRETURN_FALSE;\n\t}\n\tRETURN_TRUE;\n}\n/* }}} */\n\n/* {{{ proto bool ZipArchive::deleteIndex(int index)\nDelete a file using its index */\nstatic ZIPARCHIVE_METHOD(deleteIndex)\n{\n\tstruct zip *intern;\n\tzval *self = getThis();\n\tzend_long index;\n\n\tif (!self) {\n\t\tRETURN_FALSE;\n\t}\n\n\tZIP_FROM_OBJECT(intern, self);\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"l\", &index) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (index < 0) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (zip_delete(intern, index) < 0) {\n\t\tRETURN_FALSE;\n\t}\n\n\tRETURN_TRUE;\n}\n/* }}} */\n\n/* {{{ proto bool ZipArchive::deleteName(string name)\nDelete a file using its index */\nstatic ZIPARCHIVE_METHOD(deleteName)\n{\n\tstruct zip *intern;\n\tzval *self = getThis();\n\tsize_t name_len;\n\tchar *name;\n\tstruct zip_stat sb;\n\n\tif (!self) {\n\t\tRETURN_FALSE;\n\t}\n\n\tZIP_FROM_OBJECT(intern, self);\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"s\", &name, &name_len) == FAILURE) {\n\t\treturn;\n\t}\n\tif (name_len < 1) {\n\t\tRETURN_FALSE;\n\t}\n\n\tPHP_ZIP_STAT_PATH(intern, name, name_len, 0, sb);\n\tif (zip_delete(intern, sb.index)) {\n\t\tRETURN_FALSE;\n\t}\n\tRETURN_TRUE;\n}\n/* }}} */\n\n/* {{{ proto bool ZipArchive::renameIndex(int index, string new_name)\nRename an entry selected by its index to new_name */\nstatic ZIPARCHIVE_METHOD(renameIndex)\n{\n\tstruct zip *intern;\n\tzval *self = getThis();\n\n\tchar *new_name;\n\tsize_t new_name_len;\n\tzend_long index;\n\n\tif (!self) {\n\t\tRETURN_FALSE;\n\t}\n\n\tZIP_FROM_OBJECT(intern, self);\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"ls\", &index, &new_name, &new_name_len) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (index < 0) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (new_name_len < 1) {\n\t\tphp_error_docref(NULL, E_NOTICE, \"Empty string as new entry name\");\n\t\tRETURN_FALSE;\n\t}\n\tif (zip_rename(intern, index, (const char *)new_name) != 0) {\n\t\tRETURN_FALSE;\n\t}\n\tRETURN_TRUE;\n}\n/* }}} */\n\n/* {{{ proto bool ZipArchive::renameName(string name, string new_name)\nRename an entry selected by its name to new_name */\nstatic ZIPARCHIVE_METHOD(renameName)\n{\n\tstruct zip *intern;\n\tzval *self = getThis();\n\tstruct zip_stat sb;\n\tchar *name, *new_name;\n\tsize_t name_len, new_name_len;\n\n\tif (!self) {\n\t\tRETURN_FALSE;\n\t}\n\n\tZIP_FROM_OBJECT(intern, self);\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"ss\", &name, &name_len, &new_name, &new_name_len) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (new_name_len < 1) {\n\t\tphp_error_docref(NULL, E_NOTICE, \"Empty string as new entry name\");\n\t\tRETURN_FALSE;\n\t}\n\n\tPHP_ZIP_STAT_PATH(intern, name, name_len, 0, sb);\n\n\tif (zip_rename(intern, sb.index, (const char *)new_name)) {\n\t\tRETURN_FALSE;\n\t}\n\tRETURN_TRUE;\n}\n/* }}} */\n\n/* {{{ proto bool ZipArchive::unchangeIndex(int index)\nChanges to the file at position index are reverted */\nstatic ZIPARCHIVE_METHOD(unchangeIndex)\n{\n\tstruct zip *intern;\n\tzval *self = getThis();\n\tzend_long index;\n\n\tif (!self) {\n\t\tRETURN_FALSE;\n\t}\n\n\tZIP_FROM_OBJECT(intern, self);\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"l\", &index) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (index < 0) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (zip_unchange(intern, index) != 0) {\n\t\tRETURN_FALSE;\n\t} else {\n\t\tRETURN_TRUE;\n\t}\n}\n/* }}} */\n\n/* {{{ proto bool ZipArchive::unchangeName(string name)\nChanges to the file named 'name' are reverted */\nstatic ZIPARCHIVE_METHOD(unchangeName)\n{\n\tstruct zip *intern;\n\tzval *self = getThis();\n\tstruct zip_stat sb;\n\tchar *name;\n\tsize_t name_len;\n\n\tif (!self) {\n\t\tRETURN_FALSE;\n\t}\n\n\tZIP_FROM_OBJECT(intern, self);\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"s\", &name, &name_len) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (name_len < 1) {\n\t\tRETURN_FALSE;\n\t}\n\n\tPHP_ZIP_STAT_PATH(intern, name, name_len, 0, sb);\n\n\tif (zip_unchange(intern, sb.index) != 0) {\n\t\tRETURN_FALSE;\n\t} else {\n\t\tRETURN_TRUE;\n\t}\n}\n/* }}} */\n\n/* {{{ proto bool ZipArchive::unchangeAll()\nAll changes to files and global information in archive are reverted */\nstatic ZIPARCHIVE_METHOD(unchangeAll)\n{\n\tstruct zip *intern;\n\tzval *self = getThis();\n\n\tif (!self) {\n\t\tRETURN_FALSE;\n\t}\n\n\tZIP_FROM_OBJECT(intern, self);\n\n\tif (zip_unchange_all(intern) != 0) {\n\t\tRETURN_FALSE;\n\t} else {\n\t\tRETURN_TRUE;\n\t}\n}\n/* }}} */\n\n/* {{{ proto bool ZipArchive::unchangeArchive()\nRevert all global changes to the archive archive.  For now, this only reverts archive comment changes. */\nstatic ZIPARCHIVE_METHOD(unchangeArchive)\n{\n\tstruct zip *intern;\n\tzval *self = getThis();\n\n\tif (!self) {\n\t\tRETURN_FALSE;\n\t}\n\n\tZIP_FROM_OBJECT(intern, self);\n\n\tif (zip_unchange_archive(intern) != 0) {\n\t\tRETURN_FALSE;\n\t} else {\n\t\tRETURN_TRUE;\n\t}\n}\n/* }}} */\n\n/* {{{ proto bool ZipArchive::extractTo(string pathto[, mixed files])\nExtract one or more file from a zip archive */\n/* TODO:\n * - allow index or array of indeces\n * - replace path\n * - patterns\n */\nstatic ZIPARCHIVE_METHOD(extractTo)\n{\n\tstruct zip *intern;\n\n\tzval *self = getThis();\n\tzval *zval_files = NULL;\n\tzval *zval_file = NULL;\n\tphp_stream_statbuf ssb;\n\tchar *pathto;\n\tsize_t pathto_len;\n\tint ret, i;\n\n\tint nelems;\n\n\tif (!self) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"s|z\", &pathto, &pathto_len, &zval_files) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (pathto_len < 1) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (php_stream_stat_path_ex(pathto, PHP_STREAM_URL_STAT_QUIET, &ssb, NULL) < 0) {\n\t\t\tret = php_stream_mkdir(pathto, 0777,  PHP_STREAM_MKDIR_RECURSIVE, NULL);\n\t\t\tif (!ret) {\n\t\t\t\t\tRETURN_FALSE;\n\t\t\t}\n\t}\n\n\tZIP_FROM_OBJECT(intern, self);\n\tif (zval_files && (Z_TYPE_P(zval_files) != IS_NULL)) {\n\t\tswitch (Z_TYPE_P(zval_files)) {\n\t\t\tcase IS_STRING:\n\t\t\t\tif (!php_zip_extract_file(intern, pathto, Z_STRVAL_P(zval_files), Z_STRLEN_P(zval_files))) {\n\t\t\t\t\tRETURN_FALSE;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase IS_ARRAY:\n\t\t\t\tnelems = zend_hash_num_elements(Z_ARRVAL_P(zval_files));\n\t\t\t\tif (nelems == 0 ) {\n\t\t\t\t\tRETURN_FALSE;\n\t\t\t\t}\n\t\t\t\tfor (i = 0; i < nelems; i++) {\n\t\t\t\t\tif ((zval_file = zend_hash_index_find(Z_ARRVAL_P(zval_files), i)) != NULL) {\n\t\t\t\t\t\tswitch (Z_TYPE_P(zval_file)) {\n\t\t\t\t\t\t\tcase IS_LONG:\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase IS_STRING:\n\t\t\t\t\t\t\t\tif (!php_zip_extract_file(intern, pathto, Z_STRVAL_P(zval_file), Z_STRLEN_P(zval_file))) {\n\t\t\t\t\t\t\t\t\tRETURN_FALSE;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase IS_LONG:\n\t\t\tdefault:\n\t\t\t\tphp_error_docref(NULL, E_WARNING, \"Invalid argument, expect string or array of strings\");\n\t\t\t\tbreak;\n\t\t}\n\t} else {\n\t\t/* Extract all files */\n\t\tint filecount = zip_get_num_files(intern);\n\n\t\tif (filecount == -1) {\n\t\t\t\tphp_error_docref(NULL, E_WARNING, \"Illegal archive\");\n\t\t\t\tRETURN_FALSE;\n\t\t}\n\n\t\tfor (i = 0; i < filecount; i++) {\n\t\t\tchar *file = (char*)zip_get_name(intern, i, ZIP_FL_UNCHANGED);\n\t\t\tif (!file || !php_zip_extract_file(intern, pathto, file, strlen(file))) {\n\t\t\t\t\tRETURN_FALSE;\n\t\t\t}\n\t\t}\n\t}\n\tRETURN_TRUE;\n}\n/* }}} */\n\nstatic void php_zip_get_from(INTERNAL_FUNCTION_PARAMETERS, int type) /* {{{ */\n{\n\tstruct zip *intern;\n\tzval *self = getThis();\n\n\tstruct zip_stat sb;\n\tstruct zip_file *zf;\n\n\tzend_long index = -1;\n\tzend_long flags = 0;\n\tzend_long len = 0;\n\n\tzend_string *filename;\n\tzend_string *buffer;\n\n\tint n = 0;\n\n\tif (!self) {\n\t\tRETURN_FALSE;\n\t}\n\n\tZIP_FROM_OBJECT(intern, self);\n\n\tif (type == 1) {\n\t\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"P|ll\", &filename, &len, &flags) == FAILURE) {\n\t\t\treturn;\n\t\t}\n\t\tPHP_ZIP_STAT_PATH(intern, ZSTR_VAL(filename), ZSTR_LEN(filename), flags, sb);\n\t} else {\n\t\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"l|ll\", &index, &len, &flags) == FAILURE) {\n\t\t\treturn;\n\t\t}\n\t\tPHP_ZIP_STAT_INDEX(intern, index, 0, sb);\n\t}\n\n\tif (sb.size < 1) {\n\t\tRETURN_EMPTY_STRING();\n\t}\n\n\tif (len < 1) {\n\t\tlen = sb.size;\n\t}\n\tif (index >= 0) {\n\t\tzf = zip_fopen_index(intern, index, flags);\n\t} else {\n\t\tzf = zip_fopen(intern, ZSTR_VAL(filename), flags);\n\t}\n\n\tif (zf == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\n\tbuffer = zend_string_alloc(len, 0);\n\tn = zip_fread(zf, ZSTR_VAL(buffer), ZSTR_LEN(buffer));\n\tif (n < 1) {\n\t\tzend_string_free(buffer);\n\t\tRETURN_EMPTY_STRING();\n\t}\n\n\tzip_fclose(zf);\n\tZSTR_VAL(buffer)[n] = '\\0';\n\tZSTR_LEN(buffer) = n;\n\tRETURN_NEW_STR(buffer);\n}\n/* }}} */\n\n/* {{{ proto string ZipArchive::getFromName(string entryname[, int len [, int flags]])\nget the contents of an entry using its name */\nstatic ZIPARCHIVE_METHOD(getFromName)\n{\n\tphp_zip_get_from(INTERNAL_FUNCTION_PARAM_PASSTHRU, 1);\n}\n/* }}} */\n\n/* {{{ proto string ZipArchive::getFromIndex(int index[, int len [, int flags]])\nget the contents of an entry using its index */\nstatic ZIPARCHIVE_METHOD(getFromIndex)\n{\n\tphp_zip_get_from(INTERNAL_FUNCTION_PARAM_PASSTHRU, 0);\n}\n/* }}} */\n\n/* {{{ proto resource ZipArchive::getStream(string entryname)\nget a stream for an entry using its name */\nstatic ZIPARCHIVE_METHOD(getStream)\n{\n\tstruct zip *intern;\n\tzval *self = getThis();\n\tstruct zip_stat sb;\n\tchar *mode = \"rb\";\n\tzend_string *filename;\n\tphp_stream *stream;\n\tze_zip_object *obj;\n\n\tif (!self) {\n\t\tRETURN_FALSE;\n\t}\n\n\tZIP_FROM_OBJECT(intern, self);\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"P\", &filename) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (zip_stat(intern, ZSTR_VAL(filename), 0, &sb) != 0) {\n\t\tRETURN_FALSE;\n\t}\n\n\tobj = Z_ZIP_P(self);\n\n\tstream = php_stream_zip_open(obj->filename, ZSTR_VAL(filename), mode STREAMS_CC);\n\tif (stream) {\n\t\tphp_stream_to_zval(stream, return_value);\n\t} else {\n\t\tRETURN_FALSE;\n\t}\n}\n/* }}} */\n\n/* {{{ arginfo */\nZEND_BEGIN_ARG_INFO_EX(arginfo_ziparchive_open, 0, 0, 1)\n\tZEND_ARG_INFO(0, filename)\n\tZEND_ARG_INFO(0, flags)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_ziparchive_setpassword, 0, 0, 1)\n\tZEND_ARG_INFO(0, password)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO(arginfo_ziparchive__void, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_ziparchive_addemptydir, 0, 0, 1)\n\tZEND_ARG_INFO(0, dirname)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_ziparchive_addglob, 0, 0, 1)\n\tZEND_ARG_INFO(0, pattern)\n\tZEND_ARG_INFO(0, flags)\n\tZEND_ARG_INFO(0, options)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_ziparchive_addpattern, 0, 0, 1)\n\tZEND_ARG_INFO(0, pattern)\n\tZEND_ARG_INFO(0, path)\n\tZEND_ARG_INFO(0, options)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_ziparchive_addfile, 0, 0, 1)\n\tZEND_ARG_INFO(0, filepath)\n\tZEND_ARG_INFO(0, entryname)\n\tZEND_ARG_INFO(0, start)\n\tZEND_ARG_INFO(0, length)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_ziparchive_addfromstring, 0, 0, 2)\n\tZEND_ARG_INFO(0, name)\n\tZEND_ARG_INFO(0, content)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_ziparchive_statname, 0, 0, 1)\n\tZEND_ARG_INFO(0, filename)\n\tZEND_ARG_INFO(0, flags)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_ziparchive_statindex, 0, 0, 1)\n\tZEND_ARG_INFO(0, index)\n\tZEND_ARG_INFO(0, flags)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_ziparchive_setarchivecomment, 0, 0, 1)\n\tZEND_ARG_INFO(0, comment)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_ziparchive_setcommentindex, 0, 0, 2)\n\tZEND_ARG_INFO(0, index)\n\tZEND_ARG_INFO(0, comment)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_ziparchive_getcommentname, 0, 0, 1)\n\tZEND_ARG_INFO(0, name)\n\tZEND_ARG_INFO(0, flags)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_ziparchive_getcommentindex, 0, 0, 1)\n\tZEND_ARG_INFO(0, index)\n\tZEND_ARG_INFO(0, flags)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_ziparchive_renameindex, 0, 0, 2)\n\tZEND_ARG_INFO(0, index)\n\tZEND_ARG_INFO(0, new_name)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_ziparchive_renamename, 0, 0, 2)\n\tZEND_ARG_INFO(0, name)\n\tZEND_ARG_INFO(0, new_name)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_ziparchive_unchangeindex, 0, 0, 1)\n\tZEND_ARG_INFO(0, index)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_ziparchive_unchangename, 0, 0, 1)\n\tZEND_ARG_INFO(0, name)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_ziparchive_extractto, 0, 0, 1)\n\tZEND_ARG_INFO(0, pathto)\n\tZEND_ARG_INFO(0, files)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_ziparchive_getfromname, 0, 0, 1)\n\tZEND_ARG_INFO(0, entryname)\n\tZEND_ARG_INFO(0, len)\n\tZEND_ARG_INFO(0, flags)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_ziparchive_getfromindex, 0, 0, 1)\n\tZEND_ARG_INFO(0, index)\n\tZEND_ARG_INFO(0, len)\n\tZEND_ARG_INFO(0, flags)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_ziparchive_getarchivecomment, 0, 0, 0)\n\tZEND_ARG_INFO(0, flags)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_ziparchive_setcommentname, 0, 0, 2)\n\tZEND_ARG_INFO(0, name)\n\tZEND_ARG_INFO(0, comment)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_ziparchive_getstream, 0, 0, 1)\n\tZEND_ARG_INFO(0, entryname)\nZEND_END_ARG_INFO()\n\n#ifdef ZIP_OPSYS_DEFAULT\nZEND_BEGIN_ARG_INFO_EX(arginfo_ziparchive_setextattrname, 0, 0, 3)\n\tZEND_ARG_INFO(0, name)\n\tZEND_ARG_INFO(0, opsys)\n\tZEND_ARG_INFO(0, attr)\n\tZEND_ARG_INFO(0, flags)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_ziparchive_setextattrindex, 0, 0, 3)\n\tZEND_ARG_INFO(0, index)\n\tZEND_ARG_INFO(0, opsys)\n\tZEND_ARG_INFO(0, attr)\n\tZEND_ARG_INFO(0, flags)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_ziparchive_getextattrname, 0, 0, 3)\n\tZEND_ARG_INFO(0, name)\n\tZEND_ARG_INFO(1, opsys)\n\tZEND_ARG_INFO(1, attr)\n\tZEND_ARG_INFO(0, flags)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_ziparchive_getextattrindex, 0, 0, 3)\n\tZEND_ARG_INFO(0, index)\n\tZEND_ARG_INFO(1, opsys)\n\tZEND_ARG_INFO(1, attr)\n\tZEND_ARG_INFO(0, flags)\nZEND_END_ARG_INFO()\n#endif /* ifdef ZIP_OPSYS_DEFAULT */\n/* }}} */\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_ziparchive_setcompname, 0, 0, 2)\n\tZEND_ARG_INFO(0, name)\n\tZEND_ARG_INFO(0, method)\n\tZEND_ARG_INFO(0, compflags)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_ziparchive_setcompindex, 0, 0, 2)\n\tZEND_ARG_INFO(0, index)\n\tZEND_ARG_INFO(0, method)\n\tZEND_ARG_INFO(0, compflags)\nZEND_END_ARG_INFO()\n\n/* {{{ ze_zip_object_class_functions */\nstatic const zend_function_entry zip_class_functions[] = {\n\tZIPARCHIVE_ME(open,\t\t\t\t\targinfo_ziparchive_open, ZEND_ACC_PUBLIC)\n\tZIPARCHIVE_ME(setPassword,\t\t\targinfo_ziparchive_setpassword, ZEND_ACC_PUBLIC)\n\tZIPARCHIVE_ME(close,\t\t\t\targinfo_ziparchive__void, ZEND_ACC_PUBLIC)\n\tZIPARCHIVE_ME(getStatusString,\t\targinfo_ziparchive__void, ZEND_ACC_PUBLIC)\n\tZIPARCHIVE_ME(addEmptyDir,\t\t\targinfo_ziparchive_addemptydir, ZEND_ACC_PUBLIC)\n\tZIPARCHIVE_ME(addFromString,\t\targinfo_ziparchive_addfromstring, ZEND_ACC_PUBLIC)\n\tZIPARCHIVE_ME(addFile,\t\t\t\targinfo_ziparchive_addfile, ZEND_ACC_PUBLIC)\n\tZIPARCHIVE_ME(addGlob,\t\t\t\targinfo_ziparchive_addglob, ZEND_ACC_PUBLIC)\n\tZIPARCHIVE_ME(addPattern,\t\t\targinfo_ziparchive_addpattern, ZEND_ACC_PUBLIC)\n\tZIPARCHIVE_ME(renameIndex,\t\t\targinfo_ziparchive_renameindex, ZEND_ACC_PUBLIC)\n\tZIPARCHIVE_ME(renameName,\t\t\targinfo_ziparchive_renamename, ZEND_ACC_PUBLIC)\n\tZIPARCHIVE_ME(setArchiveComment,\targinfo_ziparchive_setarchivecomment, ZEND_ACC_PUBLIC)\n\tZIPARCHIVE_ME(getArchiveComment,\targinfo_ziparchive_getarchivecomment, ZEND_ACC_PUBLIC)\n\tZIPARCHIVE_ME(setCommentIndex,\t\targinfo_ziparchive_setcommentindex, ZEND_ACC_PUBLIC)\n\tZIPARCHIVE_ME(setCommentName,\t\targinfo_ziparchive_setcommentname, ZEND_ACC_PUBLIC)\n\tZIPARCHIVE_ME(getCommentIndex,\t\targinfo_ziparchive_getcommentindex, ZEND_ACC_PUBLIC)\n\tZIPARCHIVE_ME(getCommentName,\t\targinfo_ziparchive_getcommentname, ZEND_ACC_PUBLIC)\n\tZIPARCHIVE_ME(deleteIndex,\t\t\targinfo_ziparchive_unchangeindex, ZEND_ACC_PUBLIC)\n\tZIPARCHIVE_ME(deleteName,\t\t\targinfo_ziparchive_unchangename, ZEND_ACC_PUBLIC)\n\tZIPARCHIVE_ME(statName,\t\t\t\targinfo_ziparchive_statname, ZEND_ACC_PUBLIC)\n\tZIPARCHIVE_ME(statIndex,\t\t\targinfo_ziparchive_statindex, ZEND_ACC_PUBLIC)\n\tZIPARCHIVE_ME(locateName,\t\t\targinfo_ziparchive_statname, ZEND_ACC_PUBLIC)\n\tZIPARCHIVE_ME(getNameIndex,\t\t\targinfo_ziparchive_statindex, ZEND_ACC_PUBLIC)\n\tZIPARCHIVE_ME(unchangeArchive,\t\targinfo_ziparchive__void, ZEND_ACC_PUBLIC)\n\tZIPARCHIVE_ME(unchangeAll,\t\t\targinfo_ziparchive__void, ZEND_ACC_PUBLIC)\n\tZIPARCHIVE_ME(unchangeIndex,\t\targinfo_ziparchive_unchangeindex, ZEND_ACC_PUBLIC)\n\tZIPARCHIVE_ME(unchangeName,\t\t\targinfo_ziparchive_unchangename, ZEND_ACC_PUBLIC)\n\tZIPARCHIVE_ME(extractTo,\t\t\targinfo_ziparchive_extractto, ZEND_ACC_PUBLIC)\n\tZIPARCHIVE_ME(getFromName,\t\t\targinfo_ziparchive_getfromname, ZEND_ACC_PUBLIC)\n\tZIPARCHIVE_ME(getFromIndex,\t\t\targinfo_ziparchive_getfromindex, ZEND_ACC_PUBLIC)\n\tZIPARCHIVE_ME(getStream,\t\t\targinfo_ziparchive_getstream, ZEND_ACC_PUBLIC)\n\tZIPARCHIVE_ME(setExternalAttributesName,\targinfo_ziparchive_setextattrname, ZEND_ACC_PUBLIC)\n\tZIPARCHIVE_ME(setExternalAttributesIndex,\targinfo_ziparchive_setextattrindex, ZEND_ACC_PUBLIC)\n\tZIPARCHIVE_ME(getExternalAttributesName,\targinfo_ziparchive_getextattrname, ZEND_ACC_PUBLIC)\n\tZIPARCHIVE_ME(getExternalAttributesIndex,\targinfo_ziparchive_getextattrindex, ZEND_ACC_PUBLIC)\n\tZIPARCHIVE_ME(setCompressionName,\t\targinfo_ziparchive_setcompname, ZEND_ACC_PUBLIC)\n\tZIPARCHIVE_ME(setCompressionIndex,\t\targinfo_ziparchive_setcompindex, ZEND_ACC_PUBLIC)\n\t{NULL, NULL, NULL}\n};\n/* }}} */\n\nstatic void php_zip_free_prop_handler(zval *el) /* {{{ */ {\n\tpefree(Z_PTR_P(el), 1);\n} /* }}} */\n\n/* {{{ PHP_MINIT_FUNCTION */\nstatic PHP_MINIT_FUNCTION(zip)\n{\n\tzend_class_entry ce;\n\n\tmemcpy(&zip_object_handlers, zend_get_std_object_handlers(), sizeof(zend_object_handlers));\n\tzip_object_handlers.offset = XtOffsetOf(ze_zip_object, zo);\n\tzip_object_handlers.free_obj = php_zip_object_free_storage;\n\tzip_object_handlers.clone_obj = NULL;\n\tzip_object_handlers.get_property_ptr_ptr = php_zip_get_property_ptr_ptr;\n\n\tzip_object_handlers.get_properties = php_zip_get_properties;\n\tzip_object_handlers.read_property\t= php_zip_read_property;\n\tzip_object_handlers.has_property\t= php_zip_has_property;\n\n\tINIT_CLASS_ENTRY(ce, \"ZipArchive\", zip_class_functions);\n\tce.create_object = php_zip_object_new;\n\tzip_class_entry = zend_register_internal_class(&ce);\n\n\tzend_hash_init(&zip_prop_handlers, 0, NULL, php_zip_free_prop_handler, 1);\n\tphp_zip_register_prop_handler(&zip_prop_handlers, \"status\",    php_zip_status, NULL, NULL, IS_LONG);\n\tphp_zip_register_prop_handler(&zip_prop_handlers, \"statusSys\", php_zip_status_sys, NULL, NULL, IS_LONG);\n\tphp_zip_register_prop_handler(&zip_prop_handlers, \"numFiles\",  php_zip_get_num_files, NULL, NULL, IS_LONG);\n\tphp_zip_register_prop_handler(&zip_prop_handlers, \"filename\", NULL, NULL, php_zipobj_get_filename, IS_STRING);\n\tphp_zip_register_prop_handler(&zip_prop_handlers, \"comment\", NULL, php_zipobj_get_zip_comment, NULL, IS_STRING);\n\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CREATE\", ZIP_CREATE);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"EXCL\", ZIP_EXCL);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CHECKCONS\", ZIP_CHECKCONS);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"OVERWRITE\", ZIP_OVERWRITE);\n\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"FL_NOCASE\", ZIP_FL_NOCASE);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"FL_NODIR\", ZIP_FL_NODIR);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"FL_COMPRESSED\", ZIP_FL_COMPRESSED);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"FL_UNCHANGED\", ZIP_FL_UNCHANGED);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CM_DEFAULT\", ZIP_CM_DEFAULT);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CM_STORE\", ZIP_CM_STORE);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CM_SHRINK\", ZIP_CM_SHRINK);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CM_REDUCE_1\", ZIP_CM_REDUCE_1);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CM_REDUCE_2\", ZIP_CM_REDUCE_2);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CM_REDUCE_3\", ZIP_CM_REDUCE_3);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CM_REDUCE_4\", ZIP_CM_REDUCE_4);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CM_IMPLODE\", ZIP_CM_IMPLODE);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CM_DEFLATE\", ZIP_CM_DEFLATE);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CM_DEFLATE64\", ZIP_CM_DEFLATE64);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CM_PKWARE_IMPLODE\", ZIP_CM_PKWARE_IMPLODE);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CM_BZIP2\", ZIP_CM_BZIP2);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CM_LZMA\", ZIP_CM_LZMA);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CM_TERSE\", ZIP_CM_TERSE);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CM_LZ77\", ZIP_CM_LZ77);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CM_WAVPACK\", ZIP_CM_WAVPACK);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CM_PPMD\", ZIP_CM_PPMD);\n\n\t/* Error code */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_OK\",\t\t\tZIP_ER_OK);\t\t\t/* N No error */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_MULTIDISK\",\tZIP_ER_MULTIDISK);\t/* N Multi-disk zip archives not supported */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_RENAME\",\t\tZIP_ER_RENAME);\t\t/* S Renaming temporary file failed */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_CLOSE\",\t\tZIP_ER_CLOSE);\t\t/* S Closing zip archive failed */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_SEEK\",\t\tZIP_ER_SEEK);\t\t/* S Seek error */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_READ\",\t\tZIP_ER_READ);\t\t/* S Read error */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_WRITE\",\t\tZIP_ER_WRITE);\t\t/* S Write error */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_CRC\",\t\t\tZIP_ER_CRC);\t\t/* N CRC error */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_ZIPCLOSED\",\tZIP_ER_ZIPCLOSED);\t/* N Containing zip archive was closed */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_NOENT\",\t\tZIP_ER_NOENT);\t\t/* N No such file */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_EXISTS\",\t\tZIP_ER_EXISTS);\t\t/* N File already exists */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_OPEN\",\t\tZIP_ER_OPEN);\t\t/* S Can't open file */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_TMPOPEN\",\t\tZIP_ER_TMPOPEN);\t/* S Failure to create temporary file */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_ZLIB\",\t\tZIP_ER_ZLIB);\t\t/* Z Zlib error */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_MEMORY\",\t\tZIP_ER_MEMORY);\t\t/* N Malloc failure */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_CHANGED\",\t\tZIP_ER_CHANGED);\t/* N Entry has been changed */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_COMPNOTSUPP\",\tZIP_ER_COMPNOTSUPP);/* N Compression method not supported */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_EOF\",\t\t\tZIP_ER_EOF);\t\t/* N Premature EOF */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_INVAL\",\t\tZIP_ER_INVAL);\t\t/* N Invalid argument */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_NOZIP\",\t\tZIP_ER_NOZIP);\t\t/* N Not a zip archive */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_INTERNAL\",\tZIP_ER_INTERNAL);\t/* N Internal error */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_INCONS\",\t\tZIP_ER_INCONS);\t\t/* N Zip archive inconsistent */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_REMOVE\",\t\tZIP_ER_REMOVE);\t\t/* S Can't remove file */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_DELETED\",  \tZIP_ER_DELETED);\t/* N Entry has been deleted */\n\n#ifdef ZIP_OPSYS_DEFAULT\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"OPSYS_DOS\",\t\t\t\tZIP_OPSYS_DOS);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"OPSYS_AMIGA\",\t\t\tZIP_OPSYS_AMIGA);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"OPSYS_OPENVMS\",\t\t\tZIP_OPSYS_OPENVMS);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"OPSYS_UNIX\",\t\t\t\tZIP_OPSYS_UNIX);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"OPSYS_VM_CMS\",\t\t\tZIP_OPSYS_VM_CMS);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"OPSYS_ATARI_ST\",\t\t\tZIP_OPSYS_ATARI_ST);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"OPSYS_OS_2\",\t\t\t\tZIP_OPSYS_OS_2);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"OPSYS_MACINTOSH\",\t\tZIP_OPSYS_MACINTOSH);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"OPSYS_Z_SYSTEM\",\t\t\tZIP_OPSYS_Z_SYSTEM);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"OPSYS_Z_CPM\",\t\t\tZIP_OPSYS_CPM);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"OPSYS_WINDOWS_NTFS\",\t\tZIP_OPSYS_WINDOWS_NTFS);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"OPSYS_MVS\",\t\t\t\tZIP_OPSYS_MVS);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"OPSYS_VSE\",\t\t\t\tZIP_OPSYS_VSE);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"OPSYS_ACORN_RISC\",\t\tZIP_OPSYS_ACORN_RISC);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"OPSYS_VFAT\",\t\t\t\tZIP_OPSYS_VFAT);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"OPSYS_ALTERNATE_MVS\",\tZIP_OPSYS_ALTERNATE_MVS);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"OPSYS_BEOS\",\t\t\t\tZIP_OPSYS_BEOS);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"OPSYS_TANDEM\",\t\t\tZIP_OPSYS_TANDEM);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"OPSYS_OS_400\",\t\t\tZIP_OPSYS_OS_400);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"OPSYS_OS_X\",\t\t\t\tZIP_OPSYS_OS_X);\n\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"OPSYS_DEFAULT\", ZIP_OPSYS_DEFAULT);\n#endif /* ifdef ZIP_OPSYS_DEFAULT */\n\n\tphp_register_url_stream_wrapper(\"zip\", &php_stream_zip_wrapper);\n\n\tle_zip_dir   = zend_register_list_destructors_ex(php_zip_free_dir,   NULL, le_zip_dir_name,   module_number);\n\tle_zip_entry = zend_register_list_destructors_ex(php_zip_free_entry, NULL, le_zip_entry_name, module_number);\n\n\treturn SUCCESS;\n}\n/* }}} */\n\n/* {{{ PHP_MSHUTDOWN_FUNCTION\n */\nstatic PHP_MSHUTDOWN_FUNCTION(zip)\n{\n\tzend_hash_destroy(&zip_prop_handlers);\n\tphp_unregister_url_stream_wrapper(\"zip\");\n\treturn SUCCESS;\n}\n/* }}} */\n\n/* {{{ PHP_MINFO_FUNCTION\n */\nstatic PHP_MINFO_FUNCTION(zip)\n{\n\tphp_info_print_table_start();\n\n\tphp_info_print_table_row(2, \"Zip\", \"enabled\");\n\tphp_info_print_table_row(2, \"Zip version\", PHP_ZIP_VERSION);\n\tphp_info_print_table_row(2, \"Libzip version\", LIBZIP_VERSION);\n\n\tphp_info_print_table_end();\n}\n/* }}} */\n\n/*\n * Local variables:\n * tab-width: 4\n * c-basic-offset: 4\n * End:\n * vim600: noet sw=4 ts=4 fdm=marker\n * vim<600: noet sw=4 ts=4\n */\n"], "fixing_code": ["/*\n  +----------------------------------------------------------------------+\n  | PHP Version 7                                                        |\n  +----------------------------------------------------------------------+\n  | Copyright (c) 1997-2016 The PHP Group                                |\n  +----------------------------------------------------------------------+\n  | This source file is subject to version 3.01 of the PHP license,      |\n  | that is bundled with this package in the file LICENSE, and is        |\n  | available through the world-wide-web at the following url:           |\n  | http://www.php.net/license/3_01.txt.                                 |\n  | If you did not receive a copy of the PHP license and are unable to   |\n  | obtain it through the world-wide-web, please send a note to          |\n  | license@php.net so we can mail you a copy immediately.               |\n  +----------------------------------------------------------------------+\n  | Author: Piere-Alain Joye <pierre@php.net>                            |\n  +----------------------------------------------------------------------+\n*/\n\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include \"php.h\"\n#include \"php_ini.h\"\n#include \"ext/standard/info.h\"\n#include \"ext/standard/file.h\"\n#include \"ext/standard/php_string.h\"\n#include \"ext/pcre/php_pcre.h\"\n#include \"ext/standard/php_filestat.h\"\n#include \"php_zip.h\"\n\n/* zip_open is a macro for renaming libzip zipopen, so we need to use PHP_NAMED_FUNCTION */\nstatic PHP_NAMED_FUNCTION(zif_zip_open);\nstatic PHP_NAMED_FUNCTION(zif_zip_read);\nstatic PHP_NAMED_FUNCTION(zif_zip_close);\nstatic PHP_NAMED_FUNCTION(zif_zip_entry_read);\nstatic PHP_NAMED_FUNCTION(zif_zip_entry_filesize);\nstatic PHP_NAMED_FUNCTION(zif_zip_entry_name);\nstatic PHP_NAMED_FUNCTION(zif_zip_entry_compressedsize);\nstatic PHP_NAMED_FUNCTION(zif_zip_entry_compressionmethod);\nstatic PHP_NAMED_FUNCTION(zif_zip_entry_open);\nstatic PHP_NAMED_FUNCTION(zif_zip_entry_close);\n\n#ifdef HAVE_GLOB\n#ifndef PHP_WIN32\n#include <glob.h>\n#else\n#include \"win32/glob.h\"\n#endif\n#endif\n\n/* {{{ Resource le */\nstatic int le_zip_dir;\n#define le_zip_dir_name \"Zip Directory\"\nstatic int le_zip_entry;\n#define le_zip_entry_name \"Zip Entry\"\n/* }}} */\n\n/* {{{ PHP_ZIP_STAT_INDEX(za, index, flags, sb) */\n#define PHP_ZIP_STAT_INDEX(za, index, flags, sb) \\\n\tif (zip_stat_index(za, index, flags, &sb) != 0) { \\\n\t\tRETURN_FALSE; \\\n\t}\n/* }}} */\n\n/* {{{  PHP_ZIP_STAT_PATH(za, path, path_len, flags, sb) */\n#define PHP_ZIP_STAT_PATH(za, path, path_len, flags, sb) \\\n\tif (path_len < 1) { \\\n\t\tphp_error_docref(NULL, E_NOTICE, \"Empty string as entry name\"); \\\n\t\tRETURN_FALSE; \\\n\t} \\\n\tif (zip_stat(za, path, flags, &sb) != 0) { \\\n\t\tRETURN_FALSE; \\\n\t}\n/* }}} */\n\n/* {{{ PHP_ZIP_SET_FILE_COMMENT(za, index, comment, comment_len) */\n#define PHP_ZIP_SET_FILE_COMMENT(za, index, comment, comment_len) \\\n\tif (comment_len == 0) { \\\n\t\t/* Passing NULL remove the existing comment */ \\\n\t\tif (zip_set_file_comment(za, index, NULL, 0) < 0) { \\\n\t\t\tRETURN_FALSE; \\\n\t\t} \\\n\t} else if (zip_set_file_comment(za, index, comment, comment_len) < 0) { \\\n\t\tRETURN_FALSE; \\\n\t} \\\n\tRETURN_TRUE;\n/* }}} */\n\n# define add_ascii_assoc_string add_assoc_string\n# define add_ascii_assoc_long add_assoc_long\n\n/* Flatten a path by making a relative path (to .)*/\nstatic char * php_zip_make_relative_path(char *path, size_t path_len) /* {{{ */\n{\n\tchar *path_begin = path;\n\tsize_t i;\n\n\tif (path_len < 1 || path == NULL) {\n\t\treturn NULL;\n\t}\n\n\tif (IS_SLASH(path[0])) {\n\t\treturn path + 1;\n\t}\n\n\ti = path_len;\n\n\twhile (1) {\n\t\twhile (i > 0 && !IS_SLASH(path[i])) {\n\t\t\ti--;\n\t\t}\n\n\t\tif (!i) {\n\t\t\treturn path;\n\t\t}\n\n\t\tif (i >= 2 && (path[i -1] == '.' || path[i -1] == ':')) {\n\t\t\t/* i is the position of . or :, add 1 for / */\n\t\t\tpath_begin = path + i + 1;\n\t\t\tbreak;\n\t\t}\n\t\ti--;\n\t}\n\n\treturn path_begin;\n}\n/* }}} */\n\n# define CWD_STATE_ALLOC(l) emalloc(l)\n# define CWD_STATE_FREE(s)  efree(s)\n\n/* {{{ php_zip_extract_file */\nstatic int php_zip_extract_file(struct zip * za, char *dest, char *file, int file_len)\n{\n\tphp_stream_statbuf ssb;\n\tstruct zip_file *zf;\n\tstruct zip_stat sb;\n\tchar b[8192];\n\tint n, len, ret;\n\tphp_stream *stream;\n\tchar *fullpath;\n\tchar *file_dirname_fullpath;\n\tchar file_dirname[MAXPATHLEN];\n\tsize_t dir_len;\n\tint is_dir_only = 0;\n\tchar *path_cleaned;\n\tsize_t path_cleaned_len;\n\tcwd_state new_state;\n\tzend_string *file_basename;\n\n\tnew_state.cwd = CWD_STATE_ALLOC(1);\n\tnew_state.cwd[0] = '\\0';\n\tnew_state.cwd_length = 0;\n\n\t/* Clean/normlize the path and then transform any path (absolute or relative)\n\t\t to a path relative to cwd (../../mydir/foo.txt > mydir/foo.txt)\n\t */\n\tvirtual_file_ex(&new_state, file, NULL, CWD_EXPAND);\n\tpath_cleaned =  php_zip_make_relative_path(new_state.cwd, new_state.cwd_length);\n\tif(!path_cleaned) {\n\t\treturn 0;\n\t}\n\tpath_cleaned_len = strlen(path_cleaned);\n\n\tif (path_cleaned_len >= MAXPATHLEN || zip_stat(za, file, 0, &sb) != 0) {\n\t\treturn 0;\n\t}\n\n\t/* it is a directory only, see #40228 */\n\tif (path_cleaned_len > 1 && IS_SLASH(path_cleaned[path_cleaned_len - 1])) {\n\t\tlen = spprintf(&file_dirname_fullpath, 0, \"%s/%s\", dest, path_cleaned);\n\t\tis_dir_only = 1;\n\t} else {\n\t\tmemcpy(file_dirname, path_cleaned, path_cleaned_len);\n\t\tdir_len = php_dirname(file_dirname, path_cleaned_len);\n\n\t\tif (dir_len <= 0 || (dir_len == 1 && file_dirname[0] == '.')) {\n\t\t\tlen = spprintf(&file_dirname_fullpath, 0, \"%s\", dest);\n\t\t} else {\n\t\t\tlen = spprintf(&file_dirname_fullpath, 0, \"%s/%s\", dest, file_dirname);\n\t\t}\n\n\t\tfile_basename =\tphp_basename(path_cleaned, path_cleaned_len, NULL, 0);\n\n\t\tif (ZIP_OPENBASEDIR_CHECKPATH(file_dirname_fullpath)) {\n\t\t\tefree(file_dirname_fullpath);\n\t\t\tzend_string_release(file_basename);\n\t\t\tCWD_STATE_FREE(new_state.cwd);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/* let see if the path already exists */\n\tif (php_stream_stat_path_ex(file_dirname_fullpath, PHP_STREAM_URL_STAT_QUIET, &ssb, NULL) < 0) {\n\t\tret = php_stream_mkdir(file_dirname_fullpath, 0777,  PHP_STREAM_MKDIR_RECURSIVE|REPORT_ERRORS, NULL);\n\t\tif (!ret) {\n\t\t\tefree(file_dirname_fullpath);\n\t\t\tif (!is_dir_only) {\n\t\t\t\tzend_string_release(file_basename);\n\t\t\t\tCWD_STATE_FREE(new_state.cwd);\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/* it is a standalone directory, job done */\n\tif (is_dir_only) {\n\t\tefree(file_dirname_fullpath);\n\t\tCWD_STATE_FREE(new_state.cwd);\n\t\treturn 1;\n\t}\n\n\tlen = spprintf(&fullpath, 0, \"%s/%s\", file_dirname_fullpath, ZSTR_VAL(file_basename));\n\tif (!len) {\n\t\tefree(file_dirname_fullpath);\n\t\tzend_string_release(file_basename);\n\t\tCWD_STATE_FREE(new_state.cwd);\n\t\treturn 0;\n\t} else if (len > MAXPATHLEN) {\n\t\tphp_error_docref(NULL, E_WARNING, \"Full extraction path exceed MAXPATHLEN (%i)\", MAXPATHLEN);\n\t\tefree(file_dirname_fullpath);\n\t\tzend_string_release(file_basename);\n\t\tCWD_STATE_FREE(new_state.cwd);\n\t\treturn 0;\n\t}\n\n\t/* check again the full path, not sure if it\n\t * is required, does a file can have a different\n\t * safemode status as its parent folder?\n\t */\n\tif (ZIP_OPENBASEDIR_CHECKPATH(fullpath)) {\n\t\tefree(fullpath);\n\t\tefree(file_dirname_fullpath);\n\t\tzend_string_release(file_basename);\n\t\tCWD_STATE_FREE(new_state.cwd);\n\t\treturn 0;\n\t}\n\n\tstream = php_stream_open_wrapper(fullpath, \"w+b\", REPORT_ERRORS, NULL);\n\n\tif (stream == NULL) {\n\t\tn = -1;\n\t\tgoto done;\n\t}\n\n\tzf = zip_fopen(za, file, 0);\n\tif (zf == NULL) {\n\t\tn = -1;\n\t\tphp_stream_close(stream);\n\t\tgoto done;\n\t}\n\n\tn = 0;\n\n\twhile ((n=zip_fread(zf, b, sizeof(b))) > 0) {\n\t\tphp_stream_write(stream, b, n);\n\t}\n\n\tphp_stream_close(stream);\n\tn = zip_fclose(zf);\n\ndone:\n\tefree(fullpath);\n\tzend_string_release(file_basename);\n\tefree(file_dirname_fullpath);\n\tCWD_STATE_FREE(new_state.cwd);\n\n\tif (n<0) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}\n/* }}} */\n\nstatic int php_zip_add_file(struct zip *za, const char *filename, size_t filename_len,\n\tchar *entry_name, size_t entry_name_len, long offset_start, long offset_len) /* {{{ */\n{\n\tstruct zip_source *zs;\n\tchar resolved_path[MAXPATHLEN];\n\tzval exists_flag;\n\n\n\tif (ZIP_OPENBASEDIR_CHECKPATH(filename)) {\n\t\treturn -1;\n\t}\n\n\tif (!expand_filepath(filename, resolved_path)) {\n\t\treturn -1;\n\t}\n\n\tphp_stat(resolved_path, strlen(resolved_path), FS_EXISTS, &exists_flag);\n\tif (Z_TYPE(exists_flag) == IS_FALSE) {\n\t\treturn -1;\n\t}\n\n\tzs = zip_source_file(za, resolved_path, offset_start, offset_len);\n\tif (!zs) {\n\t\treturn -1;\n\t}\n\tif (zip_file_add(za, entry_name, zs, ZIP_FL_OVERWRITE) < 0) {\n\t\tzip_source_free(zs);\n\t\treturn -1;\n\t} else {\n\t\tzip_error_clear(za);\n\t\treturn 1;\n\t}\n}\n/* }}} */\n\nstatic int php_zip_parse_options(zval *options, zend_long *remove_all_path, char **remove_path, size_t *remove_path_len, char **add_path, size_t *add_path_len) /* {{{ */\n{\n\tzval *option;\n\tif ((option = zend_hash_str_find(Z_ARRVAL_P(options), \"remove_all_path\", sizeof(\"remove_all_path\") - 1)) != NULL) {\n\t\t*remove_all_path = zval_get_long(option);\n\t}\n\n\t/* If I add more options, it would make sense to create a nice static struct and loop over it. */\n\tif ((option = zend_hash_str_find(Z_ARRVAL_P(options), \"remove_path\", sizeof(\"remove_path\") - 1)) != NULL) {\n\t\tif (Z_TYPE_P(option) != IS_STRING) {\n\t\t\tphp_error_docref(NULL, E_WARNING, \"remove_path option expected to be a string\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (Z_STRLEN_P(option) < 1) {\n\t\t\tphp_error_docref(NULL, E_NOTICE, \"Empty string given as remove_path option\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (Z_STRLEN_P(option) >= MAXPATHLEN) {\n\t\t\tphp_error_docref(NULL, E_WARNING, \"remove_path string is too long (max: %d, %zd given)\",\n\t\t\t\t\t\tMAXPATHLEN - 1, Z_STRLEN_P(option));\n\t\t\treturn -1;\n\t\t}\n\t\t*remove_path_len = Z_STRLEN_P(option);\n\t\t*remove_path = Z_STRVAL_P(option);\n\t}\n\n\tif ((option = zend_hash_str_find(Z_ARRVAL_P(options), \"add_path\", sizeof(\"add_path\") - 1)) != NULL) {\n\t\tif (Z_TYPE_P(option) != IS_STRING) {\n\t\t\tphp_error_docref(NULL, E_WARNING, \"add_path option expected to be a string\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (Z_STRLEN_P(option) < 1) {\n\t\t\tphp_error_docref(NULL, E_NOTICE, \"Empty string given as the add_path option\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (Z_STRLEN_P(option) >= MAXPATHLEN) {\n\t\t\tphp_error_docref(NULL, E_WARNING, \"add_path string too long (max: %d, %zd given)\",\n\t\t\t\t\t\tMAXPATHLEN - 1, Z_STRLEN_P(option));\n\t\t\treturn -1;\n\t\t}\n\t\t*add_path_len = Z_STRLEN_P(option);\n\t\t*add_path = Z_STRVAL_P(option);\n\t}\n\treturn 1;\n}\n/* }}} */\n\n/* {{{ REGISTER_ZIP_CLASS_CONST_LONG */\n#define REGISTER_ZIP_CLASS_CONST_LONG(const_name, value) \\\n\t    zend_declare_class_constant_long(zip_class_entry, const_name, sizeof(const_name)-1, (zend_long)value);\n/* }}} */\n\n/* {{{ ZIP_FROM_OBJECT */\n#define ZIP_FROM_OBJECT(intern, object) \\\n\t{ \\\n\t\tze_zip_object *obj = Z_ZIP_P(object); \\\n\t\tintern = obj->za; \\\n\t\tif (!intern) { \\\n\t\t\tphp_error_docref(NULL, E_WARNING, \"Invalid or uninitialized Zip object\"); \\\n\t\t\tRETURN_FALSE; \\\n\t\t} \\\n\t}\n/* }}} */\n\n/* {{{ RETURN_SB(sb) */\n#define RETURN_SB(sb) \\\n\t{ \\\n\t\tarray_init(return_value); \\\n\t\tadd_ascii_assoc_string(return_value, \"name\", (char *)(sb)->name); \\\n\t\tadd_ascii_assoc_long(return_value, \"index\", (zend_long) (sb)->index); \\\n\t\tadd_ascii_assoc_long(return_value, \"crc\", (zend_long) (sb)->crc); \\\n\t\tadd_ascii_assoc_long(return_value, \"size\", (zend_long) (sb)->size); \\\n\t\tadd_ascii_assoc_long(return_value, \"mtime\", (zend_long) (sb)->mtime); \\\n\t\tadd_ascii_assoc_long(return_value, \"comp_size\", (zend_long) (sb)->comp_size); \\\n\t\tadd_ascii_assoc_long(return_value, \"comp_method\", (zend_long) (sb)->comp_method); \\\n\t}\n/* }}} */\n\nstatic int php_zip_status(struct zip *za) /* {{{ */\n{\n#if LIBZIP_VERSION_MAJOR < 1\n\tint zep, syp;\n\n\tzip_error_get(za, &zep, &syp);\n#else\n\tint zep;\n\tzip_error_t *err;\n\n\terr = zip_get_error(za);\n\tzep = zip_error_code_zip(err);\n\tzip_error_fini(err);\n#endif\n\treturn zep;\n}\n/* }}} */\n\nstatic int php_zip_status_sys(struct zip *za) /* {{{ */\n{\n#if LIBZIP_VERSION_MAJOR < 1\n\tint zep, syp;\n\n\tzip_error_get(za, &zep, &syp);\n#else\n\tint syp;\n\tzip_error_t *err;\n\n\terr = zip_get_error(za);\n\tsyp = zip_error_code_system(err);\n\tzip_error_fini(err);\n#endif\n\treturn syp;\n}\n/* }}} */\n\nstatic int php_zip_get_num_files(struct zip *za) /* {{{ */\n{\n\treturn zip_get_num_files(za);\n}\n/* }}} */\n\nstatic char * php_zipobj_get_filename(ze_zip_object *obj) /* {{{ */\n{\n\n\tif (!obj) {\n\t\treturn NULL;\n\t}\n\n\tif (obj->filename) {\n\t\treturn obj->filename;\n\t}\n\treturn NULL;\n}\n/* }}} */\n\nstatic char * php_zipobj_get_zip_comment(struct zip *za, int *len) /* {{{ */\n{\n\tif (za) {\n\t\treturn (char *)zip_get_archive_comment(za, len, 0);\n\t}\n\treturn NULL;\n}\n/* }}} */\n\n#ifdef HAVE_GLOB /* {{{ */\n#ifndef GLOB_ONLYDIR\n#define GLOB_ONLYDIR (1<<30)\n#define GLOB_EMULATE_ONLYDIR\n#define GLOB_FLAGMASK (~GLOB_ONLYDIR)\n#else\n#define GLOB_FLAGMASK (~0)\n#endif\n#ifndef GLOB_BRACE\n# define GLOB_BRACE 0\n#endif\n#ifndef GLOB_MARK\n# define GLOB_MARK 0\n#endif\n#ifndef GLOB_NOSORT\n# define GLOB_NOSORT 0\n#endif\n#ifndef GLOB_NOCHECK\n# define GLOB_NOCHECK 0\n#endif\n#ifndef GLOB_NOESCAPE\n# define GLOB_NOESCAPE 0\n#endif\n#ifndef GLOB_ERR\n# define GLOB_ERR 0\n#endif\n\n/* This is used for checking validity of passed flags (passing invalid flags causes segfault in glob()!! */\n#define GLOB_AVAILABLE_FLAGS (0 | GLOB_BRACE | GLOB_MARK | GLOB_NOSORT | GLOB_NOCHECK | GLOB_NOESCAPE | GLOB_ERR | GLOB_ONLYDIR)\n\n#endif /* }}} */\n\nint php_zip_glob(char *pattern, int pattern_len, zend_long flags, zval *return_value) /* {{{ */\n{\n#ifdef HAVE_GLOB\n\tchar cwd[MAXPATHLEN];\n\tint cwd_skip = 0;\n#ifdef ZTS\n\tchar work_pattern[MAXPATHLEN];\n\tchar *result;\n#endif\n\tglob_t globbuf;\n\tint n;\n\tint ret;\n\n\tif (pattern_len >= MAXPATHLEN) {\n\t\tphp_error_docref(NULL, E_WARNING, \"Pattern exceeds the maximum allowed length of %d characters\", MAXPATHLEN);\n\t\treturn -1;\n\t}\n\n\tif ((GLOB_AVAILABLE_FLAGS & flags) != flags) {\n\t\tphp_error_docref(NULL, E_WARNING, \"At least one of the passed flags is invalid or not supported on this platform\");\n\t\treturn -1;\n\t}\n\n#ifdef ZTS\n\tif (!IS_ABSOLUTE_PATH(pattern, pattern_len)) {\n\t\tresult = VCWD_GETCWD(cwd, MAXPATHLEN);\n\t\tif (!result) {\n\t\t\tcwd[0] = '\\0';\n\t\t}\n#ifdef PHP_WIN32\n\t\tif (IS_SLASH(*pattern)) {\n\t\t\tcwd[2] = '\\0';\n\t\t}\n#endif\n\t\tcwd_skip = strlen(cwd)+1;\n\n\t\tsnprintf(work_pattern, MAXPATHLEN, \"%s%c%s\", cwd, DEFAULT_SLASH, pattern);\n\t\tpattern = work_pattern;\n\t}\n#endif\n\n\tglobbuf.gl_offs = 0;\n\tif (0 != (ret = glob(pattern, flags & GLOB_FLAGMASK, NULL, &globbuf))) {\n#ifdef GLOB_NOMATCH\n\t\tif (GLOB_NOMATCH == ret) {\n\t\t\t/* Some glob implementation simply return no data if no matches\n\t\t\t   were found, others return the GLOB_NOMATCH error code.\n\t\t\t   We don't want to treat GLOB_NOMATCH as an error condition\n\t\t\t   so that PHP glob() behaves the same on both types of\n\t\t\t   implementations and so that 'foreach (glob() as ...'\n\t\t\t   can be used for simple glob() calls without further error\n\t\t\t   checking.\n\t\t\t*/\n\t\t\tarray_init(return_value);\n\t\t\treturn 0;\n\t\t}\n#endif\n\t\treturn 0;\n\t}\n\n\t/* now catch the FreeBSD style of \"no matches\" */\n\tif (!globbuf.gl_pathc || !globbuf.gl_pathv) {\n\t\tarray_init(return_value);\n\t\treturn 0;\n\t}\n\n\t/* we assume that any glob pattern will match files from one directory only\n\t   so checking the dirname of the first match should be sufficient */\n\tstrncpy(cwd, globbuf.gl_pathv[0], MAXPATHLEN);\n\tif (ZIP_OPENBASEDIR_CHECKPATH(cwd)) {\n\t\treturn -1;\n\t}\n\n\tarray_init(return_value);\n\tfor (n = 0; n < globbuf.gl_pathc; n++) {\n\t\t/* we need to do this every time since GLOB_ONLYDIR does not guarantee that\n\t\t * all directories will be filtered. GNU libc documentation states the\n\t\t * following:\n\t\t * If the information about the type of the file is easily available\n\t\t * non-directories will be rejected but no extra work will be done to\n\t\t * determine the information for each file. I.e., the caller must still be\n\t\t * able to filter directories out.\n\t\t */\n\t\tif (flags & GLOB_ONLYDIR) {\n\t\t\tzend_stat_t s;\n\n\t\t\tif (0 != VCWD_STAT(globbuf.gl_pathv[n], &s)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (S_IFDIR != (s.st_mode & S_IFMT)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tadd_next_index_string(return_value, globbuf.gl_pathv[n]+cwd_skip);\n\t}\n\n\tglobfree(&globbuf);\n\treturn globbuf.gl_pathc;\n#else\n\tphp_error_docref(NULL, E_ERROR, \"Glob support is not available\");\n\treturn 0;\n#endif  /* HAVE_GLOB */\n}\n/* }}} */\n\nint php_zip_pcre(zend_string *regexp, char *path, int path_len, zval *return_value) /* {{{ */\n{\n#ifdef ZTS\n\tchar cwd[MAXPATHLEN];\n\tint cwd_skip = 0;\n\tchar work_path[MAXPATHLEN];\n\tchar *result;\n#endif\n\tint files_cnt;\n\tzend_string **namelist;\n\n#ifdef ZTS\n\tif (!IS_ABSOLUTE_PATH(path, path_len)) {\n\t\tresult = VCWD_GETCWD(cwd, MAXPATHLEN);\n\t\tif (!result) {\n\t\t\tcwd[0] = '\\0';\n\t\t}\n#ifdef PHP_WIN32\n\t\tif (IS_SLASH(*path)) {\n\t\t\tcwd[2] = '\\0';\n\t\t}\n#endif\n\t\tcwd_skip = strlen(cwd)+1;\n\n\t\tsnprintf(work_path, MAXPATHLEN, \"%s%c%s\", cwd, DEFAULT_SLASH, path);\n\t\tpath = work_path;\n\t}\n#endif\n\n\tif (ZIP_OPENBASEDIR_CHECKPATH(path)) {\n\t\treturn -1;\n\t}\n\n\tfiles_cnt = php_stream_scandir(path, &namelist, NULL, (void *) php_stream_dirent_alphasort);\n\n\tif (files_cnt > 0) {\n\t\tpcre *re = NULL;\n\t\tpcre_extra *pcre_extra = NULL;\n\t\tint preg_options = 0, i;\n\n\t\tre = pcre_get_compiled_regex(regexp, &pcre_extra, &preg_options);\n\t\tif (!re) {\n\t\t\tphp_error_docref(NULL, E_WARNING, \"Invalid expression\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tarray_init(return_value);\n\n\t\t/* only the files, directories are ignored */\n\t\tfor (i = 0; i < files_cnt; i++) {\n\t\t\tzend_stat_t s;\n\t\t\tchar   fullpath[MAXPATHLEN];\n\t\t\tint    ovector[3];\n\t\t\tint    matches;\n\t\t\tint    namelist_len = ZSTR_LEN(namelist[i]);\n\n\t\t\tif ((namelist_len == 1 && ZSTR_VAL(namelist[i])[0] == '.') ||\n\t\t\t\t(namelist_len == 2 && ZSTR_VAL(namelist[i])[0] == '.' && ZSTR_VAL(namelist[i])[1] == '.')) {\n\t\t\t\tzend_string_release(namelist[i]);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif ((path_len + namelist_len + 1) >= MAXPATHLEN) {\n\t\t\t\tphp_error_docref(NULL, E_WARNING, \"add_path string too long (max: %i, %i given)\",\n\t\t\t\t\t\tMAXPATHLEN - 1, (path_len + namelist_len + 1));\n\t\t\t\tzend_string_release(namelist[i]);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tsnprintf(fullpath, MAXPATHLEN, \"%s%c%s\", path, DEFAULT_SLASH, ZSTR_VAL(namelist[i]));\n\n\t\t\tif (0 != VCWD_STAT(fullpath, &s)) {\n\t\t\t\tphp_error_docref(NULL, E_WARNING, \"Cannot read <%s>\", fullpath);\n\t\t\t\tzend_string_release(namelist[i]);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (S_IFDIR == (s.st_mode & S_IFMT)) {\n\t\t\t\tzend_string_release(namelist[i]);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tmatches = pcre_exec(re, NULL, ZSTR_VAL(namelist[i]), ZSTR_LEN(namelist[i]), 0, 0, ovector, 3);\n\t\t\t/* 0 means that the vector is too small to hold all the captured substring offsets */\n\t\t\tif (matches < 0) {\n\t\t\t\tzend_string_release(namelist[i]);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tadd_next_index_string(return_value, fullpath);\n\t\t\tzend_string_release(namelist[i]);\n\t\t}\n\t\tefree(namelist);\n\t}\n\treturn files_cnt;\n}\n/* }}} */\n\n/* {{{ arginfo */\nZEND_BEGIN_ARG_INFO_EX(arginfo_zip_open, 0, 0, 1)\n\tZEND_ARG_INFO(0, filename)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_zip_close, 0, 0, 1)\n\tZEND_ARG_INFO(0, zip)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_zip_read, 0, 0, 1)\n\tZEND_ARG_INFO(0, zip)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_zip_entry_open, 0, 0, 2)\n\tZEND_ARG_INFO(0, zip_dp)\n\tZEND_ARG_INFO(0, zip_entry)\n\tZEND_ARG_INFO(0, mode)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_zip_entry_close, 0, 0, 1)\n\tZEND_ARG_INFO(0, zip_ent)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_zip_entry_read, 0, 0, 1)\n\tZEND_ARG_INFO(0, zip_entry)\n\tZEND_ARG_INFO(0, len)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_zip_entry_name, 0, 0, 1)\n\tZEND_ARG_INFO(0, zip_entry)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_zip_entry_compressedsize, 0, 0, 1)\n\tZEND_ARG_INFO(0, zip_entry)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_zip_entry_filesize, 0, 0, 1)\n\tZEND_ARG_INFO(0, zip_entry)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_zip_entry_compressionmethod, 0, 0, 1)\n\tZEND_ARG_INFO(0, zip_entry)\nZEND_END_ARG_INFO()\n/* }}} */\n\n/* {{{ zend_function_entry */\nstatic const zend_function_entry zip_functions[] = {\n\tZEND_RAW_FENTRY(\"zip_open\", zif_zip_open, arginfo_zip_open, 0)\n\tZEND_RAW_FENTRY(\"zip_close\", zif_zip_close, arginfo_zip_close, 0)\n\tZEND_RAW_FENTRY(\"zip_read\", zif_zip_read, arginfo_zip_read, 0)\n\tPHP_FE(zip_entry_open,\t\targinfo_zip_entry_open)\n\tPHP_FE(zip_entry_close,\t\targinfo_zip_entry_close)\n\tPHP_FE(zip_entry_read,\t\targinfo_zip_entry_read)\n\tPHP_FE(zip_entry_filesize,\targinfo_zip_entry_filesize)\n\tPHP_FE(zip_entry_name,\t\targinfo_zip_entry_name)\n\tPHP_FE(zip_entry_compressedsize,\t\targinfo_zip_entry_compressedsize)\n\tPHP_FE(zip_entry_compressionmethod,\t\targinfo_zip_entry_compressionmethod)\n#ifdef  PHP_FE_END\n\tPHP_FE_END\n#else\n\t{NULL,NULL,NULL}\n#endif\n};\n/* }}} */\n\n/* {{{ ZE2 OO definitions */\nstatic zend_class_entry *zip_class_entry;\nstatic zend_object_handlers zip_object_handlers;\n\nstatic HashTable zip_prop_handlers;\n\ntypedef int (*zip_read_int_t)(struct zip *za);\ntypedef char *(*zip_read_const_char_t)(struct zip *za, int *len);\ntypedef char *(*zip_read_const_char_from_ze_t)(ze_zip_object *obj);\n\ntypedef struct _zip_prop_handler {\n\tzip_read_int_t read_int_func;\n\tzip_read_const_char_t read_const_char_func;\n\tzip_read_const_char_from_ze_t read_const_char_from_obj_func;\n\n\tint type;\n} zip_prop_handler;\n/* }}} */\n\nstatic void php_zip_register_prop_handler(HashTable *prop_handler, char *name, zip_read_int_t read_int_func, zip_read_const_char_t read_char_func, zip_read_const_char_from_ze_t read_char_from_obj_func, int rettype) /* {{{ */\n{\n\tzip_prop_handler hnd;\n\n\thnd.read_const_char_func = read_char_func;\n\thnd.read_int_func = read_int_func;\n\thnd.read_const_char_from_obj_func = read_char_from_obj_func;\n\thnd.type = rettype;\n\tzend_hash_str_add_mem(prop_handler, name, strlen(name), &hnd, sizeof(zip_prop_handler));\n}\n/* }}} */\n\nstatic zval *php_zip_property_reader(ze_zip_object *obj, zip_prop_handler *hnd, zval *rv) /* {{{ */\n{\n\tconst char *retchar = NULL;\n\tint retint = 0;\n\tint len = 0;\n\n\tif (obj && obj->za != NULL) {\n\t\tif (hnd->read_const_char_func) {\n\t\t\tretchar = hnd->read_const_char_func(obj->za, &len);\n\t\t} else {\n\t\t\tif (hnd->read_int_func) {\n\t\t\t\tretint = hnd->read_int_func(obj->za);\n\t\t\t\tif (retint == -1) {\n\t\t\t\t\tphp_error_docref(NULL, E_WARNING, \"Internal zip error returned\");\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (hnd->read_const_char_from_obj_func) {\n\t\t\t\t\tretchar = hnd->read_const_char_from_obj_func(obj);\n\t\t\t\t\tlen = strlen(retchar);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tswitch (hnd->type) {\n\t\tcase IS_STRING:\n\t\t\tif (retchar) {\n\t\t\t\tZVAL_STRINGL(rv, (char *) retchar, len);\n\t\t\t} else {\n\t\t\t\tZVAL_EMPTY_STRING(rv);\n\t\t\t}\n\t\t\tbreak;\n\t\t/* case IS_TRUE */\n\t\tcase IS_FALSE:\n\t\t\tZVAL_BOOL(rv, (long)retint);\n\t\t\tbreak;\n\t\tcase IS_LONG:\n\t\t\tZVAL_LONG(rv, (long)retint);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tZVAL_NULL(rv);\n\t}\n\n\treturn rv;\n}\n/* }}} */\n\nstatic zval *php_zip_get_property_ptr_ptr(zval *object, zval *member, int type, void **cache_slot) /* {{{ */\n{\n\tze_zip_object *obj;\n\tzval tmp_member;\n\tzval *retval = NULL;\n\tzip_prop_handler *hnd = NULL;\n\tzend_object_handlers *std_hnd;\n\n\tif (Z_TYPE_P(member) != IS_STRING) {\n\t\tZVAL_COPY(&tmp_member, member);\n\t\tconvert_to_string(&tmp_member);\n\t\tmember = &tmp_member;\n\t\tcache_slot = NULL;\n\t}\n\n\tobj = Z_ZIP_P(object);\n\n\tif (obj->prop_handler != NULL) {\n\t\thnd = zend_hash_find_ptr(obj->prop_handler, Z_STR_P(member));\n\t}\n\n\tif (hnd == NULL) {\n\t\tstd_hnd = zend_get_std_object_handlers();\n\t\tretval = std_hnd->get_property_ptr_ptr(object, member, type, cache_slot);\n\t}\n\n\tif (member == &tmp_member) {\n\t\tzval_dtor(member);\n\t}\n\n\treturn retval;\n}\n/* }}} */\n\nstatic zval *php_zip_read_property(zval *object, zval *member, int type, void **cache_slot, zval *rv) /* {{{ */\n{\n\tze_zip_object *obj;\n\tzval tmp_member;\n\tzval *retval = NULL;\n\tzip_prop_handler *hnd = NULL;\n\tzend_object_handlers *std_hnd;\n\n\tif (Z_TYPE_P(member) != IS_STRING) {\n\t\tZVAL_COPY(&tmp_member, member);\n\t\tconvert_to_string(&tmp_member);\n\t\tmember = &tmp_member;\n\t\tcache_slot = NULL;\n\t}\n\n\tobj = Z_ZIP_P(object);\n\n\tif (obj->prop_handler != NULL) {\n\t\thnd = zend_hash_find_ptr(obj->prop_handler, Z_STR_P(member));\n\t}\n\n\tif (hnd != NULL) {\n\t\tretval = php_zip_property_reader(obj, hnd, rv);\n\t\tif (retval == NULL) {\n\t\t\tretval = &EG(uninitialized_zval);\n\t\t}\n\t} else {\n\t\tstd_hnd = zend_get_std_object_handlers();\n\t\tretval = std_hnd->read_property(object, member, type, cache_slot, rv);\n\t}\n\n\tif (member == &tmp_member) {\n\t\tzval_dtor(member);\n\t}\n\n\treturn retval;\n}\n/* }}} */\n\nstatic int php_zip_has_property(zval *object, zval *member, int type, void **cache_slot) /* {{{ */\n{\n\tze_zip_object *obj;\n\tzval tmp_member;\n\tzip_prop_handler *hnd = NULL;\n\tzend_object_handlers *std_hnd;\n\tint retval = 0;\n\n\tif (Z_TYPE_P(member) != IS_STRING) {\n\t\tZVAL_COPY(&tmp_member, member);\n\t\tconvert_to_string(&tmp_member);\n\t\tmember = &tmp_member;\n\t\tcache_slot = NULL;\n\t}\n\n\tobj = Z_ZIP_P(object);\n\n\tif (obj->prop_handler != NULL) {\n\t\thnd = zend_hash_find_ptr(obj->prop_handler, Z_STR_P(member));\n\t}\n\n\tif (hnd != NULL) {\n\t\tzval tmp, *prop;\n\n\t\tif (type == 2) {\n\t\t\tretval = 1;\n\t\t} else if ((prop = php_zip_property_reader(obj, hnd, &tmp)) != NULL) {\n\t\t\tif (type == 1) {\n\t\t\t\tretval = zend_is_true(&tmp);\n\t\t\t} else if (type == 0) {\n\t\t\t\tretval = (Z_TYPE(tmp) != IS_NULL);\n\t\t\t}\n\t\t}\n\n\t\tzval_ptr_dtor(&tmp);\n\t} else {\n\t\tstd_hnd = zend_get_std_object_handlers();\n\t\tretval = std_hnd->has_property(object, member, type, cache_slot);\n\t}\n\n\tif (member == &tmp_member) {\n\t\tzval_dtor(member);\n\t}\n\n\treturn retval;\n}\n/* }}} */\n\nstatic HashTable *php_zip_get_properties(zval *object)/* {{{ */\n{\n\tze_zip_object *obj;\n\tHashTable *props;\n\tzip_prop_handler *hnd;\n\tzend_string *key;\n\n\tobj = Z_ZIP_P(object);\n\tprops = zend_std_get_properties(object);\n\n\tif (obj->prop_handler == NULL) {\n\t\treturn NULL;\n\t}\n\n\tZEND_HASH_FOREACH_STR_KEY_PTR(obj->prop_handler, key, hnd) {\n\t\tzval *ret, val;\n\t\tret = php_zip_property_reader(obj, hnd, &val);\n\t\tif (ret == NULL) {\n\t\t\tret = &EG(uninitialized_zval);\n\t\t}\n\t\tzend_hash_update(props, key, ret);\n\t} ZEND_HASH_FOREACH_END();\n\n\treturn props;\n}\n/* }}} */\n\nstatic void php_zip_object_free_storage(zend_object *object) /* {{{ */\n{\n\tze_zip_object * intern = php_zip_fetch_object(object);\n\tint i;\n\n\tif (!intern) {\n\t\treturn;\n\t}\n\tif (intern->za) {\n\t\tif (zip_close(intern->za) != 0) {\n\t\t\tphp_error_docref(NULL, E_WARNING, \"Cannot destroy the zip context: %s\", zip_strerror(intern->za));\n\t\t\treturn;\n\t\t}\n\t\tintern->za = NULL;\n\t}\n\n\tif (intern->buffers_cnt>0) {\n\t\tfor (i=0; i<intern->buffers_cnt; i++) {\n\t\t\tefree(intern->buffers[i]);\n\t\t}\n\t\tefree(intern->buffers);\n\t}\n\n\tintern->za = NULL;\n\tzend_object_std_dtor(&intern->zo);\n\n\tif (intern->filename) {\n\t\tefree(intern->filename);\n\t}\n}\n/* }}} */\n\nstatic zend_object *php_zip_object_new(zend_class_entry *class_type) /* {{{ */\n{\n\tze_zip_object *intern;\n\n\tintern = ecalloc(1, sizeof(ze_zip_object) + zend_object_properties_size(class_type));\n\tintern->prop_handler = &zip_prop_handlers;\n\tzend_object_std_init(&intern->zo, class_type);\n\tobject_properties_init(&intern->zo, class_type);\n\tintern->zo.handlers = &zip_object_handlers;\n\n\treturn &intern->zo;\n}\n/* }}} */\n\n/* {{{ Resource dtors */\n\n/* {{{ php_zip_free_dir */\nstatic void php_zip_free_dir(zend_resource *rsrc)\n{\n\tzip_rsrc * zip_int = (zip_rsrc *) rsrc->ptr;\n\n\tif (zip_int) {\n\t\tif (zip_int->za) {\n\t\t\tif (zip_close(zip_int->za) != 0) {\n\t\t\t\tphp_error_docref(NULL, E_WARNING, \"Cannot destroy the zip context\");\n\t\t\t}\n\t\t\tzip_int->za = NULL;\n\t\t}\n\n\t\tefree(rsrc->ptr);\n\n\t\trsrc->ptr = NULL;\n\t}\n}\n/* }}} */\n\n/* {{{ php_zip_free_entry */\nstatic void php_zip_free_entry(zend_resource *rsrc)\n{\n\tzip_read_rsrc *zr_rsrc = (zip_read_rsrc *) rsrc->ptr;\n\n\tif (zr_rsrc) {\n\t\tif (zr_rsrc->zf) {\n\t\t\tzip_fclose(zr_rsrc->zf);\n\t\t\tzr_rsrc->zf = NULL;\n\t\t}\n\t\tefree(zr_rsrc);\n\t\trsrc->ptr = NULL;\n\t}\n}\n/* }}} */\n\n/* }}}*/\n\n/* reset macro */\n\n/* {{{ function prototypes */\nstatic PHP_MINIT_FUNCTION(zip);\nstatic PHP_MSHUTDOWN_FUNCTION(zip);\nstatic PHP_MINFO_FUNCTION(zip);\n/* }}} */\n\n/* {{{ zip_module_entry\n */\nzend_module_entry zip_module_entry = {\n\tSTANDARD_MODULE_HEADER,\n\t\"zip\",\n\tzip_functions,\n\tPHP_MINIT(zip),\n\tPHP_MSHUTDOWN(zip),\n\tNULL,\n\tNULL,\n\tPHP_MINFO(zip),\n\tPHP_ZIP_VERSION,\n\tSTANDARD_MODULE_PROPERTIES\n};\n/* }}} */\n\n#ifdef COMPILE_DL_ZIP\nZEND_GET_MODULE(zip)\n#endif\n/* set macro */\n\n/* {{{ proto resource zip_open(string filename)\nCreate new zip using source uri for output */\nstatic PHP_NAMED_FUNCTION(zif_zip_open)\n{\n\tchar resolved_path[MAXPATHLEN + 1];\n\tzip_rsrc *rsrc_int;\n\tint err = 0;\n\tzend_string *filename;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"P\", &filename) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (ZSTR_LEN(filename) == 0) {\n\t\tphp_error_docref(NULL, E_WARNING, \"Empty string as source\");\n\t\tRETURN_FALSE;\n\t}\n\n\tif (ZIP_OPENBASEDIR_CHECKPATH(ZSTR_VAL(filename))) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif(!expand_filepath(ZSTR_VAL(filename), resolved_path)) {\n\t\tRETURN_FALSE;\n\t}\n\n\trsrc_int = (zip_rsrc *)emalloc(sizeof(zip_rsrc));\n\n\trsrc_int->za = zip_open(resolved_path, 0, &err);\n\tif (rsrc_int->za == NULL) {\n\t\tefree(rsrc_int);\n\t\tRETURN_LONG((zend_long)err);\n\t}\n\n\trsrc_int->index_current = 0;\n\trsrc_int->num_files = zip_get_num_files(rsrc_int->za);\n\n\tRETURN_RES(zend_register_resource(rsrc_int, le_zip_dir));\n}\n/* }}} */\n\n/* {{{ proto void zip_close(resource zip)\n   Close a Zip archive */\nstatic PHP_NAMED_FUNCTION(zif_zip_close)\n{\n\tzval * zip;\n\tzip_rsrc *z_rsrc = NULL;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"r\", &zip) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif ((z_rsrc = (zip_rsrc *)zend_fetch_resource(Z_RES_P(zip), le_zip_dir_name, le_zip_dir)) == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\n\t/* really close the zip will break BC :-D */\n\tzend_list_close(Z_RES_P(zip));\n}\n/* }}} */\n\n/* {{{ proto resource zip_read(resource zip)\n   Returns the next file in the archive */\nstatic PHP_NAMED_FUNCTION(zif_zip_read)\n{\n\tzval *zip_dp;\n\tzip_read_rsrc *zr_rsrc;\n\tint ret;\n\tzip_rsrc *rsrc_int;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"r\", &zip_dp) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif ((rsrc_int = (zip_rsrc *)zend_fetch_resource(Z_RES_P(zip_dp), le_zip_dir_name, le_zip_dir)) == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (rsrc_int && rsrc_int->za) {\n\t\tif (rsrc_int->index_current >= rsrc_int->num_files) {\n\t\t\tRETURN_FALSE;\n\t\t}\n\n\t\tzr_rsrc = emalloc(sizeof(zip_read_rsrc));\n\n\t\tret = zip_stat_index(rsrc_int->za, rsrc_int->index_current, 0, &zr_rsrc->sb);\n\n\t\tif (ret != 0) {\n\t\t\tefree(zr_rsrc);\n\t\t\tRETURN_FALSE;\n\t\t}\n\n\t\tzr_rsrc->zf = zip_fopen_index(rsrc_int->za, rsrc_int->index_current, 0);\n\t\tif (zr_rsrc->zf) {\n\t\t\trsrc_int->index_current++;\n\t\t\tRETURN_RES(zend_register_resource(zr_rsrc, le_zip_entry));\n\t\t} else {\n\t\t\tefree(zr_rsrc);\n\t\t\tRETURN_FALSE;\n\t\t}\n\n\t} else {\n\t\tRETURN_FALSE;\n\t}\n}\n/* }}} */\n\n/* {{{ proto bool zip_entry_open(resource zip_dp, resource zip_entry [, string mode])\n   Open a Zip File, pointed by the resource entry */\n/* Dummy function to follow the old API */\nstatic PHP_NAMED_FUNCTION(zif_zip_entry_open)\n{\n\tzval * zip;\n\tzval * zip_entry;\n\tchar *mode = NULL;\n\tsize_t mode_len = 0;\n\tzip_read_rsrc * zr_rsrc;\n\tzip_rsrc *z_rsrc;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"rr|s\", &zip, &zip_entry, &mode, &mode_len) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif ((zr_rsrc = (zip_read_rsrc *)zend_fetch_resource(Z_RES_P(zip_entry), le_zip_entry_name, le_zip_entry)) == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif ((z_rsrc = (zip_rsrc *)zend_fetch_resource(Z_RES_P(zip), le_zip_dir_name, le_zip_dir)) == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (zr_rsrc->zf != NULL) {\n\t\tRETURN_TRUE;\n\t} else {\n\t\tRETURN_FALSE;\n\t}\n}\n/* }}} */\n\n/* {{{ proto bool zip_entry_close(resource zip_ent)\n   Close a zip entry */\nstatic PHP_NAMED_FUNCTION(zif_zip_entry_close)\n{\n\tzval * zip_entry;\n\tzip_read_rsrc * zr_rsrc;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"r\", &zip_entry) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif ((zr_rsrc = (zip_read_rsrc *)zend_fetch_resource(Z_RES_P(zip_entry), le_zip_entry_name, le_zip_entry)) == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\n\tRETURN_BOOL(SUCCESS == zend_list_close(Z_RES_P(zip_entry)));\n}\n/* }}} */\n\n/* {{{ proto mixed zip_entry_read(resource zip_entry [, int len])\n   Read from an open directory entry */\nstatic PHP_NAMED_FUNCTION(zif_zip_entry_read)\n{\n\tzval * zip_entry;\n\tzend_long len = 0;\n\tzip_read_rsrc * zr_rsrc;\n\tzend_string *buffer;\n\tint n = 0;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"r|l\", &zip_entry, &len) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif ((zr_rsrc = (zip_read_rsrc *)zend_fetch_resource(Z_RES_P(zip_entry), le_zip_entry_name, le_zip_entry)) == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (len <= 0) {\n\t\tlen = 1024;\n\t}\n\n\tif (zr_rsrc->zf) {\n\t\tbuffer = zend_string_safe_alloc(1, len, 0, 0);\n\t\tn = zip_fread(zr_rsrc->zf, ZSTR_VAL(buffer), ZSTR_LEN(buffer));\n\t\tif (n > 0) {\n\t\t\tZSTR_VAL(buffer)[n] = '\\0';\n\t\t\tZSTR_LEN(buffer) = n;\n\t\t\tRETURN_NEW_STR(buffer);\n\t\t} else {\n\t\t\tzend_string_free(buffer);\n\t\t\tRETURN_EMPTY_STRING()\n\t\t}\n\t} else {\n\t\tRETURN_FALSE;\n\t}\n}\n/* }}} */\n\nstatic void php_zip_entry_get_info(INTERNAL_FUNCTION_PARAMETERS, int opt) /* {{{ */\n{\n\tzval * zip_entry;\n\tzip_read_rsrc * zr_rsrc;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"r\", &zip_entry) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif ((zr_rsrc = (zip_read_rsrc *)zend_fetch_resource(Z_RES_P(zip_entry), le_zip_entry_name, le_zip_entry)) == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (!zr_rsrc->zf) {\n\t\tRETURN_FALSE;\n\t}\n\n\tswitch (opt) {\n\t\tcase 0:\n\t\t\tRETURN_STRING((char *)zr_rsrc->sb.name);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tRETURN_LONG((zend_long) (zr_rsrc->sb.comp_size));\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tRETURN_LONG((zend_long) (zr_rsrc->sb.size));\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tswitch (zr_rsrc->sb.comp_method) {\n\t\t\t\tcase 0:\n\t\t\t\t\tRETURN_STRING(\"stored\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\tRETURN_STRING(\"shrunk\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\tcase 3:\n\t\t\t\tcase 4:\n\t\t\t\tcase 5:\n\t\t\t\t\tRETURN_STRING(\"reduced\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase 6:\n\t\t\t\t\tRETURN_STRING(\"imploded\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase 7:\n\t\t\t\t\tRETURN_STRING(\"tokenized\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase 8:\n\t\t\t\t\tRETURN_STRING(\"deflated\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase 9:\n\t\t\t\t\tRETURN_STRING(\"deflatedX\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase 10:\n\t\t\t\t\tRETURN_STRING(\"implodedX\");\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tRETURN_FALSE;\n\t\t\t}\n\t\t\tRETURN_LONG((zend_long) (zr_rsrc->sb.comp_method));\n\t\t\tbreak;\n\t}\n\n}\n/* }}} */\n\n/* {{{ proto string zip_entry_name(resource zip_entry)\n   Return the name given a ZZip entry */\nstatic PHP_NAMED_FUNCTION(zif_zip_entry_name)\n{\n\tphp_zip_entry_get_info(INTERNAL_FUNCTION_PARAM_PASSTHRU, 0);\n}\n/* }}} */\n\n/* {{{ proto int zip_entry_compressedsize(resource zip_entry)\n   Return the compressed size of a ZZip entry */\nstatic PHP_NAMED_FUNCTION(zif_zip_entry_compressedsize)\n{\n\tphp_zip_entry_get_info(INTERNAL_FUNCTION_PARAM_PASSTHRU, 1);\n}\n/* }}} */\n\n/* {{{ proto int zip_entry_filesize(resource zip_entry)\n   Return the actual filesize of a ZZip entry */\nstatic PHP_NAMED_FUNCTION(zif_zip_entry_filesize)\n{\n\tphp_zip_entry_get_info(INTERNAL_FUNCTION_PARAM_PASSTHRU, 2);\n}\n/* }}} */\n\n/* {{{ proto string zip_entry_compressionmethod(resource zip_entry)\n   Return a string containing the compression method used on a particular entry */\nstatic PHP_NAMED_FUNCTION(zif_zip_entry_compressionmethod)\n{\n\tphp_zip_entry_get_info(INTERNAL_FUNCTION_PARAM_PASSTHRU, 3);\n}\n/* }}} */\n\n/* {{{ proto mixed ZipArchive::open(string source [, int flags])\nCreate new zip using source uri for output, return TRUE on success or the error code */\nstatic ZIPARCHIVE_METHOD(open)\n{\n\tstruct zip *intern;\n\tint err = 0;\n\tzend_long flags = 0;\n\tchar *resolved_path;\n\tzend_string *filename;\n\tzval *self = getThis();\n\tze_zip_object *ze_obj = NULL;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"P|l\", &filename, &flags) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (self) {\n\t\t/* We do not use ZIP_FROM_OBJECT, zip init function here */\n\t\tze_obj = Z_ZIP_P(self);\n\t}\n\n\tif (ZSTR_LEN(filename) == 0) {\n\t\tphp_error_docref(NULL, E_WARNING, \"Empty string as source\");\n\t\tRETURN_FALSE;\n\t}\n\n\tif (ZIP_OPENBASEDIR_CHECKPATH(ZSTR_VAL(filename))) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (!(resolved_path = expand_filepath(ZSTR_VAL(filename), NULL))) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (ze_obj->za) {\n\t\t/* we already have an opened zip, free it */\n\t\tif (zip_close(ze_obj->za) != 0) {\n\t\t\tphp_error_docref(NULL, E_WARNING, \"Empty string as source\");\n\t\t\tefree(resolved_path);\n\t\t\tRETURN_FALSE;\n\t\t}\n\t\tze_obj->za = NULL;\n\t}\n\tif (ze_obj->filename) {\n\t\tefree(ze_obj->filename);\n\t\tze_obj->filename = NULL;\n\t}\n\n\tintern = zip_open(resolved_path, flags, &err);\n\tif (!intern || err) {\n\t\tefree(resolved_path);\n\t\tRETURN_LONG((zend_long)err);\n\t}\n\tze_obj->filename = resolved_path;\n\tze_obj->filename_len = strlen(resolved_path);\n\tze_obj->za = intern;\n\tRETURN_TRUE;\n}\n/* }}} */\n\n/* {{{ proto resource ZipArchive::setPassword(string password)\nSet the password for the active archive */\nstatic ZIPARCHIVE_METHOD(setPassword)\n{\n\tstruct zip *intern;\n\tzval *self = getThis();\n\tchar *password;\n\tsize_t\tpassword_len;\n\n\tif (!self) {\n\t\tRETURN_FALSE;\n\t}\n\n\tZIP_FROM_OBJECT(intern, self);\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"s\", &password, &password_len) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (password_len < 1) {\n\t\tRETURN_FALSE;\n\t} else {\n\t\tint res = zip_set_default_password(intern, (const char *)password);\n\t\tif (res == 0) {\n\t\t\tRETURN_TRUE;\n\t\t} else {\n\t\t\tRETURN_FALSE;\n\t\t}\n\t}\n}\n/* }}} */\n\n/* {{{ proto bool ZipArchive::close()\nclose the zip archive */\nstatic ZIPARCHIVE_METHOD(close)\n{\n\tstruct zip *intern;\n\tzval *self = getThis();\n\tze_zip_object *ze_obj;\n\tint err;\n\n\tif (!self) {\n\t\tRETURN_FALSE;\n\t}\n\n\tZIP_FROM_OBJECT(intern, self);\n\n\tze_obj = Z_ZIP_P(self);\n\n\tif ((err = zip_close(intern))) {\n\t\tphp_error_docref(NULL, E_WARNING, \"%s\", zip_strerror(intern));\n\t\tzip_discard(intern);\n\t}\n\n\tefree(ze_obj->filename);\n\tze_obj->filename = NULL;\n\tze_obj->filename_len = 0;\n\tze_obj->za = NULL;\n\n\tif (!err) {\n\t\tRETURN_TRUE;\n\t} else {\n\t\tRETURN_FALSE;\n\t}\n}\n/* }}} */\n\n/* {{{ proto string ZipArchive::getStatusString()\n * Returns the status error message, system and/or zip messages */\nstatic ZIPARCHIVE_METHOD(getStatusString)\n{\n\tstruct zip *intern;\n\tzval *self = getThis();\n#if LIBZIP_VERSION_MAJOR < 1\n\tint zep, syp, len;\n\tchar error_string[128];\n#else\n\tzip_error_t *err;\n#endif\n\n\tif (!self) {\n\t\tRETURN_FALSE;\n\t}\n\n\tZIP_FROM_OBJECT(intern, self);\n\n#if LIBZIP_VERSION_MAJOR < 1\n\tzip_error_get(intern, &zep, &syp);\n\n\tlen = zip_error_to_str(error_string, 128, zep, syp);\n\tRETVAL_STRINGL(error_string, len);\n#else\n\terr = zip_get_error(intern);\n\tRETVAL_STRING(zip_error_strerror(err));\n\tzip_error_fini(err);\n#endif\n}\n/* }}} */\n\n/* {{{ proto bool ZipArchive::createEmptyDir(string dirname)\nReturns the index of the entry named filename in the archive */\nstatic ZIPARCHIVE_METHOD(addEmptyDir)\n{\n\tstruct zip *intern;\n\tzval *self = getThis();\n\tchar *dirname;\n\tsize_t   dirname_len;\n\tint idx;\n\tstruct zip_stat sb;\n\tchar *s;\n\n\tif (!self) {\n\t\tRETURN_FALSE;\n\t}\n\n\tZIP_FROM_OBJECT(intern, self);\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"s\",\n\t\t\t\t&dirname, &dirname_len) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (dirname_len<1) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (dirname[dirname_len-1] != '/') {\n\t\ts=(char *)emalloc(dirname_len+2);\n\t\tstrcpy(s, dirname);\n\t\ts[dirname_len] = '/';\n\t\ts[dirname_len+1] = '\\0';\n\t} else {\n\t\ts = dirname;\n\t}\n\n\tidx = zip_stat(intern, s, 0, &sb);\n\tif (idx >= 0) {\n\t\tRETVAL_FALSE;\n\t} else {\n\t\tif (zip_add_dir(intern, (const char *)s) == -1) {\n\t\t\tRETVAL_FALSE;\n\t\t}\n\t\tzip_error_clear(intern);\n\t\tRETVAL_TRUE;\n\t}\n\n\tif (s != dirname) {\n\t\tefree(s);\n\t}\n}\n/* }}} */\n\nstatic void php_zip_add_from_pattern(INTERNAL_FUNCTION_PARAMETERS, int type) /* {{{ */\n{\n\tstruct zip *intern;\n\tzval *self = getThis();\n\tchar *path = NULL;\n\tchar *remove_path = NULL;\n\tchar *add_path = NULL;\n\tsize_t  add_path_len, remove_path_len = 0, path_len = 0;\n\tzend_long remove_all_path = 0;\n\tzend_long flags = 0;\n\tzval *options = NULL;\n\tint found;\n\tzend_string *pattern;\n\n\tif (!self) {\n\t\tRETURN_FALSE;\n\t}\n\n\tZIP_FROM_OBJECT(intern, self);\n\t/* 1 == glob, 2 == pcre */\n\tif (type == 1) {\n\t\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"P|la\",\n\t\t\t\t\t&pattern, &flags, &options) == FAILURE) {\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"P|sa\",\n\t\t\t\t\t&pattern, &path, &path_len, &options) == FAILURE) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (ZSTR_LEN(pattern) == 0) {\n\t\tphp_error_docref(NULL, E_NOTICE, \"Empty string as pattern\");\n\t\tRETURN_FALSE;\n\t}\n\tif (options && (php_zip_parse_options(options, &remove_all_path, &remove_path, &remove_path_len,\n\t\t\t&add_path, &add_path_len) < 0)) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (remove_path && remove_path_len > 1) {\n\t\tsize_t real_len = strlen(remove_path);\n\t\tif ((real_len > 1) && ((remove_path[real_len - 1] == '/') || (remove_path[real_len - 1] == '\\\\'))) {\n\t\t\tremove_path[real_len - 1] = '\\0';\n\t\t}\n\t}\n\n\tif (type == 1) {\n\t\tfound = php_zip_glob(ZSTR_VAL(pattern), ZSTR_LEN(pattern), flags, return_value);\n\t} else {\n\t\tfound = php_zip_pcre(pattern, path, path_len, return_value);\n\t}\n\n\tif (found > 0) {\n\t\tint i;\n\t\tzval *zval_file;\n\n\t\tfor (i = 0; i < found; i++) {\n\t\t\tchar *file_stripped, *entry_name;\n\t\t\tsize_t entry_name_len, file_stripped_len;\n\t\t\tchar entry_name_buf[MAXPATHLEN];\n\t\t\tzend_string *basename = NULL;\n\n\t\t\tif ((zval_file = zend_hash_index_find(Z_ARRVAL_P(return_value), i)) != NULL) {\n\t\t\t\tif (remove_all_path) {\n\t\t\t\t\tbasename = php_basename(Z_STRVAL_P(zval_file), Z_STRLEN_P(zval_file), NULL, 0);\n\t\t\t\t\tfile_stripped = ZSTR_VAL(basename);\n\t\t\t\t\tfile_stripped_len = ZSTR_LEN(basename);\n\t\t\t\t} else if (remove_path && strstr(Z_STRVAL_P(zval_file), remove_path) != NULL) {\n\t\t\t\t\tfile_stripped = Z_STRVAL_P(zval_file) + remove_path_len + 1;\n\t\t\t\t\tfile_stripped_len = Z_STRLEN_P(zval_file) - remove_path_len - 1;\n\t\t\t\t} else {\n\t\t\t\t\tfile_stripped = Z_STRVAL_P(zval_file);\n\t\t\t\t\tfile_stripped_len = Z_STRLEN_P(zval_file);\n\t\t\t\t}\n\n\t\t\t\tif (add_path) {\n\t\t\t\t\tif ((add_path_len + file_stripped_len) > MAXPATHLEN) {\n\t\t\t\t\t\tphp_error_docref(NULL, E_WARNING, \"Entry name too long (max: %d, %pd given)\",\n\t\t\t\t\t\tMAXPATHLEN - 1, (add_path_len + file_stripped_len));\n\t\t\t\t\t\tzval_ptr_dtor(return_value);\n\t\t\t\t\t\tRETURN_FALSE;\n\t\t\t\t\t}\n\n\t\t\t\t\tsnprintf(entry_name_buf, MAXPATHLEN, \"%s%s\", add_path, file_stripped);\n\t\t\t\t\tentry_name = entry_name_buf;\n\t\t\t\t\tentry_name_len = strlen(entry_name);\n\t\t\t\t} else {\n\t\t\t\t\tentry_name = Z_STRVAL_P(zval_file);\n\t\t\t\t\tentry_name_len = Z_STRLEN_P(zval_file);\n\t\t\t\t}\n\t\t\t\tif (basename) {\n\t\t\t\t\tzend_string_release(basename);\n\t\t\t\t\tbasename = NULL;\n\t\t\t\t}\n\t\t\t\tif (php_zip_add_file(intern, Z_STRVAL_P(zval_file), Z_STRLEN_P(zval_file),\n\t\t\t\t\tentry_name, entry_name_len, 0, 0) < 0) {\n\t\t\t\t\tzval_dtor(return_value);\n\t\t\t\t\tRETURN_FALSE;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n/* }}} */\n\n/* {{{ proto bool ZipArchive::addGlob(string pattern[,int flags [, array options]])\nAdd files matching the glob pattern. See php's glob for the pattern syntax. */\nstatic ZIPARCHIVE_METHOD(addGlob)\n{\n\tphp_zip_add_from_pattern(INTERNAL_FUNCTION_PARAM_PASSTHRU, 1);\n}\n/* }}} */\n\n/* {{{ proto bool ZipArchive::addPattern(string pattern[, string path [, array options]])\nAdd files matching the pcre pattern. See php's pcre for the pattern syntax. */\nstatic ZIPARCHIVE_METHOD(addPattern)\n{\n\tphp_zip_add_from_pattern(INTERNAL_FUNCTION_PARAM_PASSTHRU, 2);\n}\n/* }}} */\n\n/* {{{ proto bool ZipArchive::addFile(string filepath[, string entryname[, int start [, int length]]])\nAdd a file in a Zip archive using its path and the name to use. */\nstatic ZIPARCHIVE_METHOD(addFile)\n{\n\tstruct zip *intern;\n\tzval *self = getThis();\n\tchar *entry_name = NULL;\n\tsize_t entry_name_len = 0;\n\tzend_long offset_start = 0, offset_len = 0;\n\tzend_string *filename;\n\n\tif (!self) {\n\t\tRETURN_FALSE;\n\t}\n\n\tZIP_FROM_OBJECT(intern, self);\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"P|sll\",\n\t\t\t&filename, &entry_name, &entry_name_len, &offset_start, &offset_len) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (ZSTR_LEN(filename) == 0) {\n\t\tphp_error_docref(NULL, E_NOTICE, \"Empty string as filename\");\n\t\tRETURN_FALSE;\n\t}\n\n\tif (entry_name_len == 0) {\n\t\tentry_name = ZSTR_VAL(filename);\n\t\tentry_name_len = ZSTR_LEN(filename);\n\t}\n\n\tif (php_zip_add_file(intern, ZSTR_VAL(filename), ZSTR_LEN(filename), entry_name, entry_name_len, 0, 0) < 0) {\n\t\tRETURN_FALSE;\n\t} else {\n\t\tRETURN_TRUE;\n\t}\n}\n/* }}} */\n\n/* {{{ proto bool ZipArchive::addFromString(string name, string content)\nAdd a file using content and the entry name */\nstatic ZIPARCHIVE_METHOD(addFromString)\n{\n\tstruct zip *intern;\n\tzval *self = getThis();\n\tzend_string *buffer;\n\tchar *name;\n\tsize_t name_len;\n\tze_zip_object *ze_obj;\n\tstruct zip_source *zs;\n\tint pos = 0;\n\tint cur_idx;\n\n\tif (!self) {\n\t\tRETURN_FALSE;\n\t}\n\n\tZIP_FROM_OBJECT(intern, self);\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"sS\",\n\t\t\t&name, &name_len, &buffer) == FAILURE) {\n\t\treturn;\n\t}\n\n\tze_obj = Z_ZIP_P(self);\n\tif (ze_obj->buffers_cnt) {\n\t\tze_obj->buffers = (char **)erealloc(ze_obj->buffers, sizeof(char *) * (ze_obj->buffers_cnt+1));\n\t\tpos = ze_obj->buffers_cnt++;\n\t} else {\n\t\tze_obj->buffers = (char **)emalloc(sizeof(char *));\n\t\tze_obj->buffers_cnt++;\n\t\tpos = 0;\n\t}\n\tze_obj->buffers[pos] = (char *)emalloc(ZSTR_LEN(buffer) + 1);\n\tmemcpy(ze_obj->buffers[pos], ZSTR_VAL(buffer), ZSTR_LEN(buffer) + 1);\n\n\tzs = zip_source_buffer(intern, ze_obj->buffers[pos], ZSTR_LEN(buffer), 0);\n\n\tif (zs == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\n\tcur_idx = zip_name_locate(intern, (const char *)name, 0);\n\t/* TODO: fix  _zip_replace */\n\tif (cur_idx >= 0) {\n\t\tif (zip_delete(intern, cur_idx) == -1) {\n\t\t\tzip_source_free(zs);\n\t\t\tRETURN_FALSE;\n\t\t}\n\t}\n\n\tif (zip_add(intern, name, zs) == -1) {\n\t\tzip_source_free(zs);\n\t\tRETURN_FALSE;\n\t} else {\n\t\tzip_error_clear(intern);\n\t\tRETURN_TRUE;\n\t}\n}\n/* }}} */\n\n/* {{{ proto array ZipArchive::statName(string filename[, int flags])\nReturns the information about a the zip entry filename */\nstatic ZIPARCHIVE_METHOD(statName)\n{\n\tstruct zip *intern;\n\tzval *self = getThis();\n\tzend_long flags = 0;\n\tstruct zip_stat sb;\n\tzend_string *name;\n\n\tif (!self) {\n\t\tRETURN_FALSE;\n\t}\n\n\tZIP_FROM_OBJECT(intern, self);\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"P|l\", &name, &flags) == FAILURE) {\n\t\treturn;\n\t}\n\n\tPHP_ZIP_STAT_PATH(intern, ZSTR_VAL(name), ZSTR_LEN(name), flags, sb);\n\n\tRETURN_SB(&sb);\n}\n/* }}} */\n\n/* {{{ proto resource ZipArchive::statIndex(int index[, int flags])\nReturns the zip entry informations using its index */\nstatic ZIPARCHIVE_METHOD(statIndex)\n{\n\tstruct zip *intern;\n\tzval *self = getThis();\n\tzend_long index, flags = 0;\n\n\tstruct zip_stat sb;\n\n\tif (!self) {\n\t\tRETURN_FALSE;\n\t}\n\n\tZIP_FROM_OBJECT(intern, self);\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"l|l\",\n\t\t\t&index, &flags) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (zip_stat_index(intern, index, flags, &sb) != 0) {\n\t\tRETURN_FALSE;\n\t}\n\tRETURN_SB(&sb);\n}\n/* }}} */\n\n/* {{{ proto int ZipArchive::locateName(string filename[, int flags])\nReturns the index of the entry named filename in the archive */\nstatic ZIPARCHIVE_METHOD(locateName)\n{\n\tstruct zip *intern;\n\tzval *self = getThis();\n\tzend_long flags = 0;\n\tzend_long idx = -1;\n\tzend_string *name;\n\n\tif (!self) {\n\t\tRETURN_FALSE;\n\t}\n\n\tZIP_FROM_OBJECT(intern, self);\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"P|l\", &name, &flags) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (ZSTR_LEN(name) < 1) {\n\t\tRETURN_FALSE;\n\t}\n\n\tidx = (zend_long)zip_name_locate(intern, (const char *)ZSTR_VAL(name), flags);\n\n\tif (idx >= 0) {\n\t\tRETURN_LONG(idx);\n\t} else {\n\t\tRETURN_FALSE;\n\t}\n}\n/* }}} */\n\n/* {{{ proto string ZipArchive::getNameIndex(int index [, int flags])\nReturns the name of the file at position index */\nstatic ZIPARCHIVE_METHOD(getNameIndex)\n{\n\tstruct zip *intern;\n\tzval *self = getThis();\n\tconst char *name;\n\tzend_long flags = 0, index = 0;\n\n\tif (!self) {\n\t\tRETURN_FALSE;\n\t}\n\n\tZIP_FROM_OBJECT(intern, self);\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"l|l\",\n\t\t\t&index, &flags) == FAILURE) {\n\t\treturn;\n\t}\n\n\tname = zip_get_name(intern, (int) index, flags);\n\n\tif (name) {\n\t\tRETVAL_STRING((char *)name);\n\t} else {\n\t\tRETURN_FALSE;\n\t}\n}\n/* }}} */\n\n/* {{{ proto bool ZipArchive::setArchiveComment(string comment)\nSet or remove (NULL/'') the comment of the archive */\nstatic ZIPARCHIVE_METHOD(setArchiveComment)\n{\n\tstruct zip *intern;\n\tzval *self = getThis();\n\tsize_t comment_len;\n\tchar * comment;\n\n\tif (!self) {\n\t\tRETURN_FALSE;\n\t}\n\n\tZIP_FROM_OBJECT(intern, self);\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"s\", &comment, &comment_len) == FAILURE) {\n\t\treturn;\n\t}\n\tif (zip_set_archive_comment(intern, (const char *)comment, (int)comment_len)) {\n\t\tRETURN_FALSE;\n\t} else {\n\t\tRETURN_TRUE;\n\t}\n}\n/* }}} */\n\n/* {{{ proto string ZipArchive::getArchiveComment([int flags])\nReturns the comment of an entry using its index */\nstatic ZIPARCHIVE_METHOD(getArchiveComment)\n{\n\tstruct zip *intern;\n\tzval *self = getThis();\n\tzend_long flags = 0;\n\tconst char * comment;\n\tint comment_len = 0;\n\n\tif (!self) {\n\t\tRETURN_FALSE;\n\t}\n\n\tZIP_FROM_OBJECT(intern, self);\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"|l\", &flags) == FAILURE) {\n\t\treturn;\n\t}\n\n\tcomment = zip_get_archive_comment(intern, &comment_len, (int)flags);\n\tif(comment==NULL) {\n\t\tRETURN_FALSE;\n\t}\n\tRETURN_STRINGL((char *)comment, (zend_long)comment_len);\n}\n/* }}} */\n\n/* {{{ proto bool ZipArchive::setCommentName(string name, string comment)\nSet or remove (NULL/'') the comment of an entry using its Name */\nstatic ZIPARCHIVE_METHOD(setCommentName)\n{\n\tstruct zip *intern;\n\tzval *self = getThis();\n\tsize_t comment_len, name_len;\n\tchar * comment, *name;\n\tint idx;\n\n\tif (!self) {\n\t\tRETURN_FALSE;\n\t}\n\n\tZIP_FROM_OBJECT(intern, self);\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"ss\",\n\t\t\t&name, &name_len, &comment, &comment_len) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (name_len < 1) {\n\t\tphp_error_docref(NULL, E_NOTICE, \"Empty string as entry name\");\n\t}\n\n\tidx = zip_name_locate(intern, name, 0);\n\tif (idx < 0) {\n\t\tRETURN_FALSE;\n\t}\n\tPHP_ZIP_SET_FILE_COMMENT(intern, idx, comment, comment_len);\n}\n/* }}} */\n\n/* {{{ proto bool ZipArchive::setCommentIndex(int index, string comment)\nSet or remove (NULL/'') the comment of an entry using its index */\nstatic ZIPARCHIVE_METHOD(setCommentIndex)\n{\n\tstruct zip *intern;\n\tzval *self = getThis();\n\tzend_long index;\n\tsize_t comment_len;\n\tchar * comment;\n\tstruct zip_stat sb;\n\n\tif (!self) {\n\t\tRETURN_FALSE;\n\t}\n\n\tZIP_FROM_OBJECT(intern, self);\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"ls\",\n\t\t\t&index, &comment, &comment_len) == FAILURE) {\n\t\treturn;\n\t}\n\n\tPHP_ZIP_STAT_INDEX(intern, index, 0, sb);\n\tPHP_ZIP_SET_FILE_COMMENT(intern, index, comment, comment_len);\n}\n/* }}} */\n\n/* those constants/functions are only available in libzip since 0.11.2 */\n#ifdef ZIP_OPSYS_DEFAULT\n\n/* {{{ proto bool ZipArchive::setExternalAttributesName(string name, int opsys, int attr [, int flags])\nSet external attributes for file in zip, using its name */\nstatic ZIPARCHIVE_METHOD(setExternalAttributesName)\n{\n\tstruct zip *intern;\n\tzval *self = getThis();\n\tsize_t name_len;\n\tchar *name;\n\tzend_long flags=0, opsys, attr;\n\tzip_int64_t idx;\n\n\tif (!self) {\n\t\tRETURN_FALSE;\n\t}\n\n\tZIP_FROM_OBJECT(intern, self);\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"sll|l\",\n\t\t\t&name, &name_len, &opsys, &attr, &flags) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (name_len < 1) {\n\t\tphp_error_docref(NULL, E_NOTICE, \"Empty string as entry name\");\n\t}\n\n\tidx = zip_name_locate(intern, name, 0);\n\tif (idx < 0) {\n\t\tRETURN_FALSE;\n\t}\n\tif (zip_file_set_external_attributes(intern, idx, (zip_flags_t)flags,\n\t\t\t(zip_uint8_t)(opsys&0xff), (zip_uint32_t)attr) < 0) {\n\t\tRETURN_FALSE;\n\t}\n\tRETURN_TRUE;\n}\n/* }}} */\n\n/* {{{ proto bool ZipArchive::setExternalAttributesIndex(int index, int opsys, int attr [, int flags])\nSet external attributes for file in zip, using its index */\nstatic ZIPARCHIVE_METHOD(setExternalAttributesIndex)\n{\n\tstruct zip *intern;\n\tzval *self = getThis();\n\tzend_long index, flags=0, opsys, attr;\n\tstruct zip_stat sb;\n\n\tif (!self) {\n\t\tRETURN_FALSE;\n\t}\n\n\tZIP_FROM_OBJECT(intern, self);\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"lll|l\",\n\t\t\t&index, &opsys, &attr, &flags) == FAILURE) {\n\t\treturn;\n\t}\n\n\tPHP_ZIP_STAT_INDEX(intern, index, 0, sb);\n\tif (zip_file_set_external_attributes(intern, (zip_uint64_t)index,\n\t\t\t(zip_flags_t)flags, (zip_uint8_t)(opsys&0xff), (zip_uint32_t)attr) < 0) {\n\t\tRETURN_FALSE;\n\t}\n\tRETURN_TRUE;\n}\n/* }}} */\n\n/* {{{ proto bool ZipArchive::getExternalAttributesName(string name, int &opsys, int &attr [, int flags])\nGet external attributes for file in zip, using its name */\nstatic ZIPARCHIVE_METHOD(getExternalAttributesName)\n{\n\tstruct zip *intern;\n\tzval *self = getThis(), *z_opsys, *z_attr;\n\tsize_t name_len;\n\tchar *name;\n\tzend_long flags=0;\n\tzip_uint8_t opsys;\n\tzip_uint32_t attr;\n\tzip_int64_t idx;\n\n\tif (!self) {\n\t\tRETURN_FALSE;\n\t}\n\n\tZIP_FROM_OBJECT(intern, self);\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"sz/z/|l\",\n\t\t\t&name, &name_len, &z_opsys, &z_attr, &flags) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (name_len < 1) {\n\t\tphp_error_docref(NULL, E_NOTICE, \"Empty string as entry name\");\n\t}\n\n\tidx = zip_name_locate(intern, name, 0);\n\tif (idx < 0) {\n\t\tRETURN_FALSE;\n\t}\n\tif (zip_file_get_external_attributes(intern, idx,\n\t\t\t(zip_flags_t)flags, &opsys, &attr) < 0) {\n\t\tRETURN_FALSE;\n\t}\n\tzval_ptr_dtor(z_opsys);\n\tZVAL_LONG(z_opsys, opsys);\n\tzval_ptr_dtor(z_attr);\n\tZVAL_LONG(z_attr, attr);\n\tRETURN_TRUE;\n}\n/* }}} */\n\n/* {{{ proto bool ZipArchive::getExternalAttributesIndex(int index, int &opsys, int &attr [, int flags])\nGet external attributes for file in zip, using its index */\nstatic ZIPARCHIVE_METHOD(getExternalAttributesIndex)\n{\n\tstruct zip *intern;\n\tzval *self = getThis(), *z_opsys, *z_attr;\n\tzend_long index, flags=0;\n\tzip_uint8_t opsys;\n\tzip_uint32_t attr;\n\tstruct zip_stat sb;\n\n\tif (!self) {\n\t\tRETURN_FALSE;\n\t}\n\n\tZIP_FROM_OBJECT(intern, self);\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"lz/z/|l\",\n\t\t\t&index, &z_opsys, &z_attr, &flags) == FAILURE) {\n\t\treturn;\n\t}\n\n\tPHP_ZIP_STAT_INDEX(intern, index, 0, sb);\n\tif (zip_file_get_external_attributes(intern, (zip_uint64_t)index,\n\t\t\t(zip_flags_t)flags, &opsys, &attr) < 0) {\n\t\tRETURN_FALSE;\n\t}\n\tzval_dtor(z_opsys);\n\tZVAL_LONG(z_opsys, opsys);\n\tzval_dtor(z_attr);\n\tZVAL_LONG(z_attr, attr);\n\tRETURN_TRUE;\n}\n/* }}} */\n#endif /* ifdef ZIP_OPSYS_DEFAULT */\n\n/* {{{ proto string ZipArchive::getCommentName(string name[, int flags])\nReturns the comment of an entry using its name */\nstatic ZIPARCHIVE_METHOD(getCommentName)\n{\n\tstruct zip *intern;\n\tzval *self = getThis();\n\tsize_t name_len;\n\tint idx;\n\tzend_long flags = 0;\n\tint comment_len = 0;\n\tconst char * comment;\n\tchar *name;\n\n\tif (!self) {\n\t\tRETURN_FALSE;\n\t}\n\n\tZIP_FROM_OBJECT(intern, self);\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"s|l\",\n\t\t\t&name, &name_len, &flags) == FAILURE) {\n\t\treturn;\n\t}\n\tif (name_len < 1) {\n\t\tphp_error_docref(NULL, E_NOTICE, \"Empty string as entry name\");\n\t\tRETURN_FALSE;\n\t}\n\n\tidx = zip_name_locate(intern, name, 0);\n\tif (idx < 0) {\n\t\tRETURN_FALSE;\n\t}\n\n\tcomment = zip_get_file_comment(intern, idx, &comment_len, (int)flags);\n\tRETURN_STRINGL((char *)comment, (zend_long)comment_len);\n}\n/* }}} */\n\n/* {{{ proto string ZipArchive::getCommentIndex(int index[, int flags])\nReturns the comment of an entry using its index */\nstatic ZIPARCHIVE_METHOD(getCommentIndex)\n{\n\tstruct zip *intern;\n\tzval *self = getThis();\n\tzend_long index, flags = 0;\n\tconst char * comment;\n\tint comment_len = 0;\n\tstruct zip_stat sb;\n\n\tif (!self) {\n\t\tRETURN_FALSE;\n\t}\n\n\tZIP_FROM_OBJECT(intern, self);\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"l|l\",\n\t\t\t\t&index, &flags) == FAILURE) {\n\t\treturn;\n\t}\n\n\tPHP_ZIP_STAT_INDEX(intern, index, 0, sb);\n\tcomment = zip_get_file_comment(intern, index, &comment_len, (int)flags);\n\tRETURN_STRINGL((char *)comment, (zend_long)comment_len);\n}\n/* }}} */\n\n/* {{{ proto bool ZipArchive::setCompressionName(string name, int comp_method[, int comp_flags])\nSet the compression of a file in zip, using its name */\nstatic ZIPARCHIVE_METHOD(setCompressionName)\n {\n\tstruct zip *intern;\n\tzval *this = getThis();\n\tsize_t name_len;\n\tchar *name;\n\tzip_int64_t idx;\n\tzend_long comp_method, comp_flags = 0;\n\n\tif (!this) {\n\t\tRETURN_FALSE;\n\t}\n\n\tZIP_FROM_OBJECT(intern, this);\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"sl|l\",\n\t\t\t&name, &name_len, &comp_method, &comp_flags) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (name_len < 1) {\n\t\tphp_error_docref(NULL, E_NOTICE, \"Empty string as entry name\");\n\t}\n\n\tidx = zip_name_locate(intern, name, 0);\n\tif (idx < 0) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (zip_set_file_compression(intern, (zip_uint64_t)idx,\n\t\t\t(zip_int32_t)comp_method, (zip_uint32_t)comp_flags) != 0) {\n\t\tRETURN_FALSE;\n\t}\n\tRETURN_TRUE;\n}\n/* }}} */\n\n/* {{{ proto bool ZipArchive::setCompressionIndex(int index, int comp_method[, int comp_flags])\nSet the compression of a file in zip, using its index */\nstatic ZIPARCHIVE_METHOD(setCompressionIndex)\n{\n\tstruct zip *intern;\n\tzval *this = getThis();\n\tzend_long index;\n\tzend_long comp_method, comp_flags = 0;\n\n\tif (!this) {\n\t\tRETURN_FALSE;\n\t}\n\n\tZIP_FROM_OBJECT(intern, this);\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"ll|l\",\n\t\t\t&index, &comp_method, &comp_flags) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (zip_set_file_compression(intern, (zip_uint64_t)index,\n\t\t\t(zip_int32_t)comp_method, (zip_uint32_t)comp_flags) != 0) {\n\t\tRETURN_FALSE;\n\t}\n\tRETURN_TRUE;\n}\n/* }}} */\n\n/* {{{ proto bool ZipArchive::deleteIndex(int index)\nDelete a file using its index */\nstatic ZIPARCHIVE_METHOD(deleteIndex)\n{\n\tstruct zip *intern;\n\tzval *self = getThis();\n\tzend_long index;\n\n\tif (!self) {\n\t\tRETURN_FALSE;\n\t}\n\n\tZIP_FROM_OBJECT(intern, self);\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"l\", &index) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (index < 0) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (zip_delete(intern, index) < 0) {\n\t\tRETURN_FALSE;\n\t}\n\n\tRETURN_TRUE;\n}\n/* }}} */\n\n/* {{{ proto bool ZipArchive::deleteName(string name)\nDelete a file using its index */\nstatic ZIPARCHIVE_METHOD(deleteName)\n{\n\tstruct zip *intern;\n\tzval *self = getThis();\n\tsize_t name_len;\n\tchar *name;\n\tstruct zip_stat sb;\n\n\tif (!self) {\n\t\tRETURN_FALSE;\n\t}\n\n\tZIP_FROM_OBJECT(intern, self);\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"s\", &name, &name_len) == FAILURE) {\n\t\treturn;\n\t}\n\tif (name_len < 1) {\n\t\tRETURN_FALSE;\n\t}\n\n\tPHP_ZIP_STAT_PATH(intern, name, name_len, 0, sb);\n\tif (zip_delete(intern, sb.index)) {\n\t\tRETURN_FALSE;\n\t}\n\tRETURN_TRUE;\n}\n/* }}} */\n\n/* {{{ proto bool ZipArchive::renameIndex(int index, string new_name)\nRename an entry selected by its index to new_name */\nstatic ZIPARCHIVE_METHOD(renameIndex)\n{\n\tstruct zip *intern;\n\tzval *self = getThis();\n\n\tchar *new_name;\n\tsize_t new_name_len;\n\tzend_long index;\n\n\tif (!self) {\n\t\tRETURN_FALSE;\n\t}\n\n\tZIP_FROM_OBJECT(intern, self);\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"ls\", &index, &new_name, &new_name_len) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (index < 0) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (new_name_len < 1) {\n\t\tphp_error_docref(NULL, E_NOTICE, \"Empty string as new entry name\");\n\t\tRETURN_FALSE;\n\t}\n\tif (zip_rename(intern, index, (const char *)new_name) != 0) {\n\t\tRETURN_FALSE;\n\t}\n\tRETURN_TRUE;\n}\n/* }}} */\n\n/* {{{ proto bool ZipArchive::renameName(string name, string new_name)\nRename an entry selected by its name to new_name */\nstatic ZIPARCHIVE_METHOD(renameName)\n{\n\tstruct zip *intern;\n\tzval *self = getThis();\n\tstruct zip_stat sb;\n\tchar *name, *new_name;\n\tsize_t name_len, new_name_len;\n\n\tif (!self) {\n\t\tRETURN_FALSE;\n\t}\n\n\tZIP_FROM_OBJECT(intern, self);\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"ss\", &name, &name_len, &new_name, &new_name_len) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (new_name_len < 1) {\n\t\tphp_error_docref(NULL, E_NOTICE, \"Empty string as new entry name\");\n\t\tRETURN_FALSE;\n\t}\n\n\tPHP_ZIP_STAT_PATH(intern, name, name_len, 0, sb);\n\n\tif (zip_rename(intern, sb.index, (const char *)new_name)) {\n\t\tRETURN_FALSE;\n\t}\n\tRETURN_TRUE;\n}\n/* }}} */\n\n/* {{{ proto bool ZipArchive::unchangeIndex(int index)\nChanges to the file at position index are reverted */\nstatic ZIPARCHIVE_METHOD(unchangeIndex)\n{\n\tstruct zip *intern;\n\tzval *self = getThis();\n\tzend_long index;\n\n\tif (!self) {\n\t\tRETURN_FALSE;\n\t}\n\n\tZIP_FROM_OBJECT(intern, self);\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"l\", &index) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (index < 0) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (zip_unchange(intern, index) != 0) {\n\t\tRETURN_FALSE;\n\t} else {\n\t\tRETURN_TRUE;\n\t}\n}\n/* }}} */\n\n/* {{{ proto bool ZipArchive::unchangeName(string name)\nChanges to the file named 'name' are reverted */\nstatic ZIPARCHIVE_METHOD(unchangeName)\n{\n\tstruct zip *intern;\n\tzval *self = getThis();\n\tstruct zip_stat sb;\n\tchar *name;\n\tsize_t name_len;\n\n\tif (!self) {\n\t\tRETURN_FALSE;\n\t}\n\n\tZIP_FROM_OBJECT(intern, self);\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"s\", &name, &name_len) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (name_len < 1) {\n\t\tRETURN_FALSE;\n\t}\n\n\tPHP_ZIP_STAT_PATH(intern, name, name_len, 0, sb);\n\n\tif (zip_unchange(intern, sb.index) != 0) {\n\t\tRETURN_FALSE;\n\t} else {\n\t\tRETURN_TRUE;\n\t}\n}\n/* }}} */\n\n/* {{{ proto bool ZipArchive::unchangeAll()\nAll changes to files and global information in archive are reverted */\nstatic ZIPARCHIVE_METHOD(unchangeAll)\n{\n\tstruct zip *intern;\n\tzval *self = getThis();\n\n\tif (!self) {\n\t\tRETURN_FALSE;\n\t}\n\n\tZIP_FROM_OBJECT(intern, self);\n\n\tif (zip_unchange_all(intern) != 0) {\n\t\tRETURN_FALSE;\n\t} else {\n\t\tRETURN_TRUE;\n\t}\n}\n/* }}} */\n\n/* {{{ proto bool ZipArchive::unchangeArchive()\nRevert all global changes to the archive archive.  For now, this only reverts archive comment changes. */\nstatic ZIPARCHIVE_METHOD(unchangeArchive)\n{\n\tstruct zip *intern;\n\tzval *self = getThis();\n\n\tif (!self) {\n\t\tRETURN_FALSE;\n\t}\n\n\tZIP_FROM_OBJECT(intern, self);\n\n\tif (zip_unchange_archive(intern) != 0) {\n\t\tRETURN_FALSE;\n\t} else {\n\t\tRETURN_TRUE;\n\t}\n}\n/* }}} */\n\n/* {{{ proto bool ZipArchive::extractTo(string pathto[, mixed files])\nExtract one or more file from a zip archive */\n/* TODO:\n * - allow index or array of indeces\n * - replace path\n * - patterns\n */\nstatic ZIPARCHIVE_METHOD(extractTo)\n{\n\tstruct zip *intern;\n\n\tzval *self = getThis();\n\tzval *zval_files = NULL;\n\tzval *zval_file = NULL;\n\tphp_stream_statbuf ssb;\n\tchar *pathto;\n\tsize_t pathto_len;\n\tint ret, i;\n\n\tint nelems;\n\n\tif (!self) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"s|z\", &pathto, &pathto_len, &zval_files) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (pathto_len < 1) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (php_stream_stat_path_ex(pathto, PHP_STREAM_URL_STAT_QUIET, &ssb, NULL) < 0) {\n\t\t\tret = php_stream_mkdir(pathto, 0777,  PHP_STREAM_MKDIR_RECURSIVE, NULL);\n\t\t\tif (!ret) {\n\t\t\t\t\tRETURN_FALSE;\n\t\t\t}\n\t}\n\n\tZIP_FROM_OBJECT(intern, self);\n\tif (zval_files && (Z_TYPE_P(zval_files) != IS_NULL)) {\n\t\tswitch (Z_TYPE_P(zval_files)) {\n\t\t\tcase IS_STRING:\n\t\t\t\tif (!php_zip_extract_file(intern, pathto, Z_STRVAL_P(zval_files), Z_STRLEN_P(zval_files))) {\n\t\t\t\t\tRETURN_FALSE;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase IS_ARRAY:\n\t\t\t\tnelems = zend_hash_num_elements(Z_ARRVAL_P(zval_files));\n\t\t\t\tif (nelems == 0 ) {\n\t\t\t\t\tRETURN_FALSE;\n\t\t\t\t}\n\t\t\t\tfor (i = 0; i < nelems; i++) {\n\t\t\t\t\tif ((zval_file = zend_hash_index_find(Z_ARRVAL_P(zval_files), i)) != NULL) {\n\t\t\t\t\t\tswitch (Z_TYPE_P(zval_file)) {\n\t\t\t\t\t\t\tcase IS_LONG:\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase IS_STRING:\n\t\t\t\t\t\t\t\tif (!php_zip_extract_file(intern, pathto, Z_STRVAL_P(zval_file), Z_STRLEN_P(zval_file))) {\n\t\t\t\t\t\t\t\t\tRETURN_FALSE;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase IS_LONG:\n\t\t\tdefault:\n\t\t\t\tphp_error_docref(NULL, E_WARNING, \"Invalid argument, expect string or array of strings\");\n\t\t\t\tbreak;\n\t\t}\n\t} else {\n\t\t/* Extract all files */\n\t\tint filecount = zip_get_num_files(intern);\n\n\t\tif (filecount == -1) {\n\t\t\t\tphp_error_docref(NULL, E_WARNING, \"Illegal archive\");\n\t\t\t\tRETURN_FALSE;\n\t\t}\n\n\t\tfor (i = 0; i < filecount; i++) {\n\t\t\tchar *file = (char*)zip_get_name(intern, i, ZIP_FL_UNCHANGED);\n\t\t\tif (!file || !php_zip_extract_file(intern, pathto, file, strlen(file))) {\n\t\t\t\t\tRETURN_FALSE;\n\t\t\t}\n\t\t}\n\t}\n\tRETURN_TRUE;\n}\n/* }}} */\n\nstatic void php_zip_get_from(INTERNAL_FUNCTION_PARAMETERS, int type) /* {{{ */\n{\n\tstruct zip *intern;\n\tzval *self = getThis();\n\n\tstruct zip_stat sb;\n\tstruct zip_file *zf;\n\n\tzend_long index = -1;\n\tzend_long flags = 0;\n\tzend_long len = 0;\n\n\tzend_string *filename;\n\tzend_string *buffer;\n\n\tint n = 0;\n\n\tif (!self) {\n\t\tRETURN_FALSE;\n\t}\n\n\tZIP_FROM_OBJECT(intern, self);\n\n\tif (type == 1) {\n\t\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"P|ll\", &filename, &len, &flags) == FAILURE) {\n\t\t\treturn;\n\t\t}\n\t\tPHP_ZIP_STAT_PATH(intern, ZSTR_VAL(filename), ZSTR_LEN(filename), flags, sb);\n\t} else {\n\t\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"l|ll\", &index, &len, &flags) == FAILURE) {\n\t\t\treturn;\n\t\t}\n\t\tPHP_ZIP_STAT_INDEX(intern, index, 0, sb);\n\t}\n\n\tif (sb.size < 1) {\n\t\tRETURN_EMPTY_STRING();\n\t}\n\n\tif (len < 1) {\n\t\tlen = sb.size;\n\t}\n\tif (index >= 0) {\n\t\tzf = zip_fopen_index(intern, index, flags);\n\t} else {\n\t\tzf = zip_fopen(intern, ZSTR_VAL(filename), flags);\n\t}\n\n\tif (zf == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\n\tbuffer = zend_string_safe_alloc(1, len, 0, 0);\n\tn = zip_fread(zf, ZSTR_VAL(buffer), ZSTR_LEN(buffer));\n\tif (n < 1) {\n\t\tzend_string_free(buffer);\n\t\tRETURN_EMPTY_STRING();\n\t}\n\n\tzip_fclose(zf);\n\tZSTR_VAL(buffer)[n] = '\\0';\n\tZSTR_LEN(buffer) = n;\n\tRETURN_NEW_STR(buffer);\n}\n/* }}} */\n\n/* {{{ proto string ZipArchive::getFromName(string entryname[, int len [, int flags]])\nget the contents of an entry using its name */\nstatic ZIPARCHIVE_METHOD(getFromName)\n{\n\tphp_zip_get_from(INTERNAL_FUNCTION_PARAM_PASSTHRU, 1);\n}\n/* }}} */\n\n/* {{{ proto string ZipArchive::getFromIndex(int index[, int len [, int flags]])\nget the contents of an entry using its index */\nstatic ZIPARCHIVE_METHOD(getFromIndex)\n{\n\tphp_zip_get_from(INTERNAL_FUNCTION_PARAM_PASSTHRU, 0);\n}\n/* }}} */\n\n/* {{{ proto resource ZipArchive::getStream(string entryname)\nget a stream for an entry using its name */\nstatic ZIPARCHIVE_METHOD(getStream)\n{\n\tstruct zip *intern;\n\tzval *self = getThis();\n\tstruct zip_stat sb;\n\tchar *mode = \"rb\";\n\tzend_string *filename;\n\tphp_stream *stream;\n\tze_zip_object *obj;\n\n\tif (!self) {\n\t\tRETURN_FALSE;\n\t}\n\n\tZIP_FROM_OBJECT(intern, self);\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"P\", &filename) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (zip_stat(intern, ZSTR_VAL(filename), 0, &sb) != 0) {\n\t\tRETURN_FALSE;\n\t}\n\n\tobj = Z_ZIP_P(self);\n\n\tstream = php_stream_zip_open(obj->filename, ZSTR_VAL(filename), mode STREAMS_CC);\n\tif (stream) {\n\t\tphp_stream_to_zval(stream, return_value);\n\t} else {\n\t\tRETURN_FALSE;\n\t}\n}\n/* }}} */\n\n/* {{{ arginfo */\nZEND_BEGIN_ARG_INFO_EX(arginfo_ziparchive_open, 0, 0, 1)\n\tZEND_ARG_INFO(0, filename)\n\tZEND_ARG_INFO(0, flags)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_ziparchive_setpassword, 0, 0, 1)\n\tZEND_ARG_INFO(0, password)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO(arginfo_ziparchive__void, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_ziparchive_addemptydir, 0, 0, 1)\n\tZEND_ARG_INFO(0, dirname)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_ziparchive_addglob, 0, 0, 1)\n\tZEND_ARG_INFO(0, pattern)\n\tZEND_ARG_INFO(0, flags)\n\tZEND_ARG_INFO(0, options)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_ziparchive_addpattern, 0, 0, 1)\n\tZEND_ARG_INFO(0, pattern)\n\tZEND_ARG_INFO(0, path)\n\tZEND_ARG_INFO(0, options)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_ziparchive_addfile, 0, 0, 1)\n\tZEND_ARG_INFO(0, filepath)\n\tZEND_ARG_INFO(0, entryname)\n\tZEND_ARG_INFO(0, start)\n\tZEND_ARG_INFO(0, length)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_ziparchive_addfromstring, 0, 0, 2)\n\tZEND_ARG_INFO(0, name)\n\tZEND_ARG_INFO(0, content)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_ziparchive_statname, 0, 0, 1)\n\tZEND_ARG_INFO(0, filename)\n\tZEND_ARG_INFO(0, flags)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_ziparchive_statindex, 0, 0, 1)\n\tZEND_ARG_INFO(0, index)\n\tZEND_ARG_INFO(0, flags)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_ziparchive_setarchivecomment, 0, 0, 1)\n\tZEND_ARG_INFO(0, comment)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_ziparchive_setcommentindex, 0, 0, 2)\n\tZEND_ARG_INFO(0, index)\n\tZEND_ARG_INFO(0, comment)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_ziparchive_getcommentname, 0, 0, 1)\n\tZEND_ARG_INFO(0, name)\n\tZEND_ARG_INFO(0, flags)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_ziparchive_getcommentindex, 0, 0, 1)\n\tZEND_ARG_INFO(0, index)\n\tZEND_ARG_INFO(0, flags)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_ziparchive_renameindex, 0, 0, 2)\n\tZEND_ARG_INFO(0, index)\n\tZEND_ARG_INFO(0, new_name)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_ziparchive_renamename, 0, 0, 2)\n\tZEND_ARG_INFO(0, name)\n\tZEND_ARG_INFO(0, new_name)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_ziparchive_unchangeindex, 0, 0, 1)\n\tZEND_ARG_INFO(0, index)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_ziparchive_unchangename, 0, 0, 1)\n\tZEND_ARG_INFO(0, name)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_ziparchive_extractto, 0, 0, 1)\n\tZEND_ARG_INFO(0, pathto)\n\tZEND_ARG_INFO(0, files)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_ziparchive_getfromname, 0, 0, 1)\n\tZEND_ARG_INFO(0, entryname)\n\tZEND_ARG_INFO(0, len)\n\tZEND_ARG_INFO(0, flags)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_ziparchive_getfromindex, 0, 0, 1)\n\tZEND_ARG_INFO(0, index)\n\tZEND_ARG_INFO(0, len)\n\tZEND_ARG_INFO(0, flags)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_ziparchive_getarchivecomment, 0, 0, 0)\n\tZEND_ARG_INFO(0, flags)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_ziparchive_setcommentname, 0, 0, 2)\n\tZEND_ARG_INFO(0, name)\n\tZEND_ARG_INFO(0, comment)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_ziparchive_getstream, 0, 0, 1)\n\tZEND_ARG_INFO(0, entryname)\nZEND_END_ARG_INFO()\n\n#ifdef ZIP_OPSYS_DEFAULT\nZEND_BEGIN_ARG_INFO_EX(arginfo_ziparchive_setextattrname, 0, 0, 3)\n\tZEND_ARG_INFO(0, name)\n\tZEND_ARG_INFO(0, opsys)\n\tZEND_ARG_INFO(0, attr)\n\tZEND_ARG_INFO(0, flags)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_ziparchive_setextattrindex, 0, 0, 3)\n\tZEND_ARG_INFO(0, index)\n\tZEND_ARG_INFO(0, opsys)\n\tZEND_ARG_INFO(0, attr)\n\tZEND_ARG_INFO(0, flags)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_ziparchive_getextattrname, 0, 0, 3)\n\tZEND_ARG_INFO(0, name)\n\tZEND_ARG_INFO(1, opsys)\n\tZEND_ARG_INFO(1, attr)\n\tZEND_ARG_INFO(0, flags)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_ziparchive_getextattrindex, 0, 0, 3)\n\tZEND_ARG_INFO(0, index)\n\tZEND_ARG_INFO(1, opsys)\n\tZEND_ARG_INFO(1, attr)\n\tZEND_ARG_INFO(0, flags)\nZEND_END_ARG_INFO()\n#endif /* ifdef ZIP_OPSYS_DEFAULT */\n/* }}} */\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_ziparchive_setcompname, 0, 0, 2)\n\tZEND_ARG_INFO(0, name)\n\tZEND_ARG_INFO(0, method)\n\tZEND_ARG_INFO(0, compflags)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_ziparchive_setcompindex, 0, 0, 2)\n\tZEND_ARG_INFO(0, index)\n\tZEND_ARG_INFO(0, method)\n\tZEND_ARG_INFO(0, compflags)\nZEND_END_ARG_INFO()\n\n/* {{{ ze_zip_object_class_functions */\nstatic const zend_function_entry zip_class_functions[] = {\n\tZIPARCHIVE_ME(open,\t\t\t\t\targinfo_ziparchive_open, ZEND_ACC_PUBLIC)\n\tZIPARCHIVE_ME(setPassword,\t\t\targinfo_ziparchive_setpassword, ZEND_ACC_PUBLIC)\n\tZIPARCHIVE_ME(close,\t\t\t\targinfo_ziparchive__void, ZEND_ACC_PUBLIC)\n\tZIPARCHIVE_ME(getStatusString,\t\targinfo_ziparchive__void, ZEND_ACC_PUBLIC)\n\tZIPARCHIVE_ME(addEmptyDir,\t\t\targinfo_ziparchive_addemptydir, ZEND_ACC_PUBLIC)\n\tZIPARCHIVE_ME(addFromString,\t\targinfo_ziparchive_addfromstring, ZEND_ACC_PUBLIC)\n\tZIPARCHIVE_ME(addFile,\t\t\t\targinfo_ziparchive_addfile, ZEND_ACC_PUBLIC)\n\tZIPARCHIVE_ME(addGlob,\t\t\t\targinfo_ziparchive_addglob, ZEND_ACC_PUBLIC)\n\tZIPARCHIVE_ME(addPattern,\t\t\targinfo_ziparchive_addpattern, ZEND_ACC_PUBLIC)\n\tZIPARCHIVE_ME(renameIndex,\t\t\targinfo_ziparchive_renameindex, ZEND_ACC_PUBLIC)\n\tZIPARCHIVE_ME(renameName,\t\t\targinfo_ziparchive_renamename, ZEND_ACC_PUBLIC)\n\tZIPARCHIVE_ME(setArchiveComment,\targinfo_ziparchive_setarchivecomment, ZEND_ACC_PUBLIC)\n\tZIPARCHIVE_ME(getArchiveComment,\targinfo_ziparchive_getarchivecomment, ZEND_ACC_PUBLIC)\n\tZIPARCHIVE_ME(setCommentIndex,\t\targinfo_ziparchive_setcommentindex, ZEND_ACC_PUBLIC)\n\tZIPARCHIVE_ME(setCommentName,\t\targinfo_ziparchive_setcommentname, ZEND_ACC_PUBLIC)\n\tZIPARCHIVE_ME(getCommentIndex,\t\targinfo_ziparchive_getcommentindex, ZEND_ACC_PUBLIC)\n\tZIPARCHIVE_ME(getCommentName,\t\targinfo_ziparchive_getcommentname, ZEND_ACC_PUBLIC)\n\tZIPARCHIVE_ME(deleteIndex,\t\t\targinfo_ziparchive_unchangeindex, ZEND_ACC_PUBLIC)\n\tZIPARCHIVE_ME(deleteName,\t\t\targinfo_ziparchive_unchangename, ZEND_ACC_PUBLIC)\n\tZIPARCHIVE_ME(statName,\t\t\t\targinfo_ziparchive_statname, ZEND_ACC_PUBLIC)\n\tZIPARCHIVE_ME(statIndex,\t\t\targinfo_ziparchive_statindex, ZEND_ACC_PUBLIC)\n\tZIPARCHIVE_ME(locateName,\t\t\targinfo_ziparchive_statname, ZEND_ACC_PUBLIC)\n\tZIPARCHIVE_ME(getNameIndex,\t\t\targinfo_ziparchive_statindex, ZEND_ACC_PUBLIC)\n\tZIPARCHIVE_ME(unchangeArchive,\t\targinfo_ziparchive__void, ZEND_ACC_PUBLIC)\n\tZIPARCHIVE_ME(unchangeAll,\t\t\targinfo_ziparchive__void, ZEND_ACC_PUBLIC)\n\tZIPARCHIVE_ME(unchangeIndex,\t\targinfo_ziparchive_unchangeindex, ZEND_ACC_PUBLIC)\n\tZIPARCHIVE_ME(unchangeName,\t\t\targinfo_ziparchive_unchangename, ZEND_ACC_PUBLIC)\n\tZIPARCHIVE_ME(extractTo,\t\t\targinfo_ziparchive_extractto, ZEND_ACC_PUBLIC)\n\tZIPARCHIVE_ME(getFromName,\t\t\targinfo_ziparchive_getfromname, ZEND_ACC_PUBLIC)\n\tZIPARCHIVE_ME(getFromIndex,\t\t\targinfo_ziparchive_getfromindex, ZEND_ACC_PUBLIC)\n\tZIPARCHIVE_ME(getStream,\t\t\targinfo_ziparchive_getstream, ZEND_ACC_PUBLIC)\n\tZIPARCHIVE_ME(setExternalAttributesName,\targinfo_ziparchive_setextattrname, ZEND_ACC_PUBLIC)\n\tZIPARCHIVE_ME(setExternalAttributesIndex,\targinfo_ziparchive_setextattrindex, ZEND_ACC_PUBLIC)\n\tZIPARCHIVE_ME(getExternalAttributesName,\targinfo_ziparchive_getextattrname, ZEND_ACC_PUBLIC)\n\tZIPARCHIVE_ME(getExternalAttributesIndex,\targinfo_ziparchive_getextattrindex, ZEND_ACC_PUBLIC)\n\tZIPARCHIVE_ME(setCompressionName,\t\targinfo_ziparchive_setcompname, ZEND_ACC_PUBLIC)\n\tZIPARCHIVE_ME(setCompressionIndex,\t\targinfo_ziparchive_setcompindex, ZEND_ACC_PUBLIC)\n\t{NULL, NULL, NULL}\n};\n/* }}} */\n\nstatic void php_zip_free_prop_handler(zval *el) /* {{{ */ {\n\tpefree(Z_PTR_P(el), 1);\n} /* }}} */\n\n/* {{{ PHP_MINIT_FUNCTION */\nstatic PHP_MINIT_FUNCTION(zip)\n{\n\tzend_class_entry ce;\n\n\tmemcpy(&zip_object_handlers, zend_get_std_object_handlers(), sizeof(zend_object_handlers));\n\tzip_object_handlers.offset = XtOffsetOf(ze_zip_object, zo);\n\tzip_object_handlers.free_obj = php_zip_object_free_storage;\n\tzip_object_handlers.clone_obj = NULL;\n\tzip_object_handlers.get_property_ptr_ptr = php_zip_get_property_ptr_ptr;\n\n\tzip_object_handlers.get_properties = php_zip_get_properties;\n\tzip_object_handlers.read_property\t= php_zip_read_property;\n\tzip_object_handlers.has_property\t= php_zip_has_property;\n\n\tINIT_CLASS_ENTRY(ce, \"ZipArchive\", zip_class_functions);\n\tce.create_object = php_zip_object_new;\n\tzip_class_entry = zend_register_internal_class(&ce);\n\n\tzend_hash_init(&zip_prop_handlers, 0, NULL, php_zip_free_prop_handler, 1);\n\tphp_zip_register_prop_handler(&zip_prop_handlers, \"status\",    php_zip_status, NULL, NULL, IS_LONG);\n\tphp_zip_register_prop_handler(&zip_prop_handlers, \"statusSys\", php_zip_status_sys, NULL, NULL, IS_LONG);\n\tphp_zip_register_prop_handler(&zip_prop_handlers, \"numFiles\",  php_zip_get_num_files, NULL, NULL, IS_LONG);\n\tphp_zip_register_prop_handler(&zip_prop_handlers, \"filename\", NULL, NULL, php_zipobj_get_filename, IS_STRING);\n\tphp_zip_register_prop_handler(&zip_prop_handlers, \"comment\", NULL, php_zipobj_get_zip_comment, NULL, IS_STRING);\n\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CREATE\", ZIP_CREATE);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"EXCL\", ZIP_EXCL);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CHECKCONS\", ZIP_CHECKCONS);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"OVERWRITE\", ZIP_OVERWRITE);\n\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"FL_NOCASE\", ZIP_FL_NOCASE);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"FL_NODIR\", ZIP_FL_NODIR);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"FL_COMPRESSED\", ZIP_FL_COMPRESSED);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"FL_UNCHANGED\", ZIP_FL_UNCHANGED);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CM_DEFAULT\", ZIP_CM_DEFAULT);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CM_STORE\", ZIP_CM_STORE);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CM_SHRINK\", ZIP_CM_SHRINK);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CM_REDUCE_1\", ZIP_CM_REDUCE_1);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CM_REDUCE_2\", ZIP_CM_REDUCE_2);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CM_REDUCE_3\", ZIP_CM_REDUCE_3);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CM_REDUCE_4\", ZIP_CM_REDUCE_4);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CM_IMPLODE\", ZIP_CM_IMPLODE);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CM_DEFLATE\", ZIP_CM_DEFLATE);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CM_DEFLATE64\", ZIP_CM_DEFLATE64);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CM_PKWARE_IMPLODE\", ZIP_CM_PKWARE_IMPLODE);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CM_BZIP2\", ZIP_CM_BZIP2);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CM_LZMA\", ZIP_CM_LZMA);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CM_TERSE\", ZIP_CM_TERSE);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CM_LZ77\", ZIP_CM_LZ77);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CM_WAVPACK\", ZIP_CM_WAVPACK);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"CM_PPMD\", ZIP_CM_PPMD);\n\n\t/* Error code */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_OK\",\t\t\tZIP_ER_OK);\t\t\t/* N No error */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_MULTIDISK\",\tZIP_ER_MULTIDISK);\t/* N Multi-disk zip archives not supported */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_RENAME\",\t\tZIP_ER_RENAME);\t\t/* S Renaming temporary file failed */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_CLOSE\",\t\tZIP_ER_CLOSE);\t\t/* S Closing zip archive failed */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_SEEK\",\t\tZIP_ER_SEEK);\t\t/* S Seek error */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_READ\",\t\tZIP_ER_READ);\t\t/* S Read error */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_WRITE\",\t\tZIP_ER_WRITE);\t\t/* S Write error */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_CRC\",\t\t\tZIP_ER_CRC);\t\t/* N CRC error */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_ZIPCLOSED\",\tZIP_ER_ZIPCLOSED);\t/* N Containing zip archive was closed */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_NOENT\",\t\tZIP_ER_NOENT);\t\t/* N No such file */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_EXISTS\",\t\tZIP_ER_EXISTS);\t\t/* N File already exists */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_OPEN\",\t\tZIP_ER_OPEN);\t\t/* S Can't open file */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_TMPOPEN\",\t\tZIP_ER_TMPOPEN);\t/* S Failure to create temporary file */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_ZLIB\",\t\tZIP_ER_ZLIB);\t\t/* Z Zlib error */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_MEMORY\",\t\tZIP_ER_MEMORY);\t\t/* N Malloc failure */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_CHANGED\",\t\tZIP_ER_CHANGED);\t/* N Entry has been changed */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_COMPNOTSUPP\",\tZIP_ER_COMPNOTSUPP);/* N Compression method not supported */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_EOF\",\t\t\tZIP_ER_EOF);\t\t/* N Premature EOF */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_INVAL\",\t\tZIP_ER_INVAL);\t\t/* N Invalid argument */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_NOZIP\",\t\tZIP_ER_NOZIP);\t\t/* N Not a zip archive */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_INTERNAL\",\tZIP_ER_INTERNAL);\t/* N Internal error */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_INCONS\",\t\tZIP_ER_INCONS);\t\t/* N Zip archive inconsistent */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_REMOVE\",\t\tZIP_ER_REMOVE);\t\t/* S Can't remove file */\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"ER_DELETED\",  \tZIP_ER_DELETED);\t/* N Entry has been deleted */\n\n#ifdef ZIP_OPSYS_DEFAULT\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"OPSYS_DOS\",\t\t\t\tZIP_OPSYS_DOS);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"OPSYS_AMIGA\",\t\t\tZIP_OPSYS_AMIGA);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"OPSYS_OPENVMS\",\t\t\tZIP_OPSYS_OPENVMS);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"OPSYS_UNIX\",\t\t\t\tZIP_OPSYS_UNIX);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"OPSYS_VM_CMS\",\t\t\tZIP_OPSYS_VM_CMS);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"OPSYS_ATARI_ST\",\t\t\tZIP_OPSYS_ATARI_ST);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"OPSYS_OS_2\",\t\t\t\tZIP_OPSYS_OS_2);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"OPSYS_MACINTOSH\",\t\tZIP_OPSYS_MACINTOSH);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"OPSYS_Z_SYSTEM\",\t\t\tZIP_OPSYS_Z_SYSTEM);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"OPSYS_Z_CPM\",\t\t\tZIP_OPSYS_CPM);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"OPSYS_WINDOWS_NTFS\",\t\tZIP_OPSYS_WINDOWS_NTFS);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"OPSYS_MVS\",\t\t\t\tZIP_OPSYS_MVS);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"OPSYS_VSE\",\t\t\t\tZIP_OPSYS_VSE);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"OPSYS_ACORN_RISC\",\t\tZIP_OPSYS_ACORN_RISC);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"OPSYS_VFAT\",\t\t\t\tZIP_OPSYS_VFAT);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"OPSYS_ALTERNATE_MVS\",\tZIP_OPSYS_ALTERNATE_MVS);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"OPSYS_BEOS\",\t\t\t\tZIP_OPSYS_BEOS);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"OPSYS_TANDEM\",\t\t\tZIP_OPSYS_TANDEM);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"OPSYS_OS_400\",\t\t\tZIP_OPSYS_OS_400);\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"OPSYS_OS_X\",\t\t\t\tZIP_OPSYS_OS_X);\n\n\tREGISTER_ZIP_CLASS_CONST_LONG(\"OPSYS_DEFAULT\", ZIP_OPSYS_DEFAULT);\n#endif /* ifdef ZIP_OPSYS_DEFAULT */\n\n\tphp_register_url_stream_wrapper(\"zip\", &php_stream_zip_wrapper);\n\n\tle_zip_dir   = zend_register_list_destructors_ex(php_zip_free_dir,   NULL, le_zip_dir_name,   module_number);\n\tle_zip_entry = zend_register_list_destructors_ex(php_zip_free_entry, NULL, le_zip_entry_name, module_number);\n\n\treturn SUCCESS;\n}\n/* }}} */\n\n/* {{{ PHP_MSHUTDOWN_FUNCTION\n */\nstatic PHP_MSHUTDOWN_FUNCTION(zip)\n{\n\tzend_hash_destroy(&zip_prop_handlers);\n\tphp_unregister_url_stream_wrapper(\"zip\");\n\treturn SUCCESS;\n}\n/* }}} */\n\n/* {{{ PHP_MINFO_FUNCTION\n */\nstatic PHP_MINFO_FUNCTION(zip)\n{\n\tphp_info_print_table_start();\n\n\tphp_info_print_table_row(2, \"Zip\", \"enabled\");\n\tphp_info_print_table_row(2, \"Zip version\", PHP_ZIP_VERSION);\n\tphp_info_print_table_row(2, \"Libzip version\", LIBZIP_VERSION);\n\n\tphp_info_print_table_end();\n}\n/* }}} */\n\n/*\n * Local variables:\n * tab-width: 4\n * c-basic-offset: 4\n * End:\n * vim600: noet sw=4 ts=4 fdm=marker\n * vim<600: noet sw=4 ts=4\n */\n"], "filenames": ["ext/zip/php_zip.c"], "buggy_code_start_loc": [1284], "buggy_code_end_loc": [2732], "fixing_code_start_loc": [1284], "fixing_code_end_loc": [2732], "type": "CWE-190", "message": "Multiple integer overflows in php_zip.c in the zip extension in PHP before 7.0.6 allow remote attackers to cause a denial of service (heap-based buffer overflow and application crash) or possibly have unspecified other impact via a crafted call to (1) getFromIndex or (2) getFromName in the ZipArchive class.", "other": {"cve": {"id": "CVE-2016-3078", "sourceIdentifier": "secalert@redhat.com", "published": "2016-08-07T10:59:02.757", "lastModified": "2022-07-20T16:57:07.213", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Multiple integer overflows in php_zip.c in the zip extension in PHP before 7.0.6 allow remote attackers to cause a denial of service (heap-based buffer overflow and application crash) or possibly have unspecified other impact via a crafted call to (1) getFromIndex or (2) getFromName in the ZipArchive class."}, {"lang": "es", "value": "Multiples desbordamientos de entero en PHP en versiones anteriores a 7.0.8 permite a atacantes remotos provocar una denegaci\u00f3n de servicio (desbordamiento de b\u00fafer basado en memoria din\u00e1mica y ca\u00edda de aplicaci\u00f3n) o posiblemente tener otro impacto no especificado a trav\u00e9s de una llamada manipulada a (1) getFromIndex o (2) getFromName en la clase ZipArchive."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": true, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-190"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:php:php:*:*:*:*:*:*:*:*", "versionStartIncluding": "7.0.0", "versionEndExcluding": "7.0.6", "matchCriteriaId": "29444ECA-CE15-42F2-9FA2-829C18E51069"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2016/04/28/1", "source": "secalert@redhat.com", "tags": ["Exploit", "Mailing List", "Third Party Advisory"]}, {"url": "http://www.securitytracker.com/id/1035701", "source": "secalert@redhat.com", "tags": ["Broken Link", "Third Party Advisory", "VDB Entry"]}, {"url": "https://bugs.php.net/bug.php?id=71923", "source": "secalert@redhat.com", "tags": ["Exploit", "Issue Tracking", "Vendor Advisory"]}, {"url": "https://github.com/php/php-src/commit/3b8d4de300854b3517c7acb239b84f7726c1353c?w=1", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://php.net/ChangeLog-7.php", "source": "secalert@redhat.com", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "https://security-tracker.debian.org/tracker/CVE-2016-3078", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://www.exploit-db.com/exploits/39742/", "source": "secalert@redhat.com", "tags": ["Exploit", "Third Party Advisory", "VDB Entry"]}]}, "github_commit_url": "https://github.com/php/php-src/commit/3b8d4de300854b3517c7acb239b84f7726c1353c?w=1"}}