{"buggy_code": ["/*\n * Crypto user configuration API.\n *\n * Copyright (C) 2011 secunet Security Networks AG\n * Copyright (C) 2011 Steffen Klassert <steffen.klassert@secunet.com>\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms and conditions of the GNU General Public License,\n * version 2, as published by the Free Software Foundation.\n *\n * This program is distributed in the hope it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n * more details.\n *\n * You should have received a copy of the GNU General Public License along with\n * this program; if not, write to the Free Software Foundation, Inc.,\n * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.\n */\n\n#include <linux/module.h>\n#include <linux/crypto.h>\n#include <linux/cryptouser.h>\n#include <linux/sched.h>\n#include <net/netlink.h>\n#include <linux/security.h>\n#include <net/net_namespace.h>\n#include <crypto/internal/skcipher.h>\n#include <crypto/internal/rng.h>\n#include <crypto/akcipher.h>\n#include <crypto/kpp.h>\n#include <crypto/internal/cryptouser.h>\n\n#include \"internal.h\"\n\n#define null_terminated(x)\t(strnlen(x, sizeof(x)) < sizeof(x))\n\nstatic DEFINE_MUTEX(crypto_cfg_mutex);\n\n/* The crypto netlink socket */\nstruct sock *crypto_nlsk;\n\nstruct crypto_dump_info {\n\tstruct sk_buff *in_skb;\n\tstruct sk_buff *out_skb;\n\tu32 nlmsg_seq;\n\tu16 nlmsg_flags;\n};\n\nstruct crypto_alg *crypto_alg_match(struct crypto_user_alg *p, int exact)\n{\n\tstruct crypto_alg *q, *alg = NULL;\n\n\tdown_read(&crypto_alg_sem);\n\n\tlist_for_each_entry(q, &crypto_alg_list, cra_list) {\n\t\tint match = 0;\n\n\t\tif ((q->cra_flags ^ p->cru_type) & p->cru_mask)\n\t\t\tcontinue;\n\n\t\tif (strlen(p->cru_driver_name))\n\t\t\tmatch = !strcmp(q->cra_driver_name,\n\t\t\t\t\tp->cru_driver_name);\n\t\telse if (!exact)\n\t\t\tmatch = !strcmp(q->cra_name, p->cru_name);\n\n\t\tif (!match)\n\t\t\tcontinue;\n\n\t\tif (unlikely(!crypto_mod_get(q)))\n\t\t\tcontinue;\n\n\t\talg = q;\n\t\tbreak;\n\t}\n\n\tup_read(&crypto_alg_sem);\n\n\treturn alg;\n}\n\nstatic int crypto_report_cipher(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_cipher rcipher;\n\n\tstrlcpy(rcipher.type, \"cipher\", sizeof(rcipher.type));\n\n\trcipher.blocksize = alg->cra_blocksize;\n\trcipher.min_keysize = alg->cra_cipher.cia_min_keysize;\n\trcipher.max_keysize = alg->cra_cipher.cia_max_keysize;\n\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_CIPHER,\n\t\t    sizeof(struct crypto_report_cipher), &rcipher))\n\t\tgoto nla_put_failure;\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}\n\nstatic int crypto_report_comp(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_comp rcomp;\n\n\tstrlcpy(rcomp.type, \"compression\", sizeof(rcomp.type));\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_COMPRESS,\n\t\t    sizeof(struct crypto_report_comp), &rcomp))\n\t\tgoto nla_put_failure;\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}\n\nstatic int crypto_report_acomp(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_acomp racomp;\n\n\tstrlcpy(racomp.type, \"acomp\", sizeof(racomp.type));\n\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_ACOMP,\n\t\t    sizeof(struct crypto_report_acomp), &racomp))\n\t\tgoto nla_put_failure;\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}\n\nstatic int crypto_report_akcipher(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_akcipher rakcipher;\n\n\tstrlcpy(rakcipher.type, \"akcipher\", sizeof(rakcipher.type));\n\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_AKCIPHER,\n\t\t    sizeof(struct crypto_report_akcipher), &rakcipher))\n\t\tgoto nla_put_failure;\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}\n\nstatic int crypto_report_kpp(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_kpp rkpp;\n\n\tstrlcpy(rkpp.type, \"kpp\", sizeof(rkpp.type));\n\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_KPP,\n\t\t    sizeof(struct crypto_report_kpp), &rkpp))\n\t\tgoto nla_put_failure;\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}\n\nstatic int crypto_report_one(struct crypto_alg *alg,\n\t\t\t     struct crypto_user_alg *ualg, struct sk_buff *skb)\n{\n\tstrlcpy(ualg->cru_name, alg->cra_name, sizeof(ualg->cru_name));\n\tstrlcpy(ualg->cru_driver_name, alg->cra_driver_name,\n\t\tsizeof(ualg->cru_driver_name));\n\tstrlcpy(ualg->cru_module_name, module_name(alg->cra_module),\n\t\tsizeof(ualg->cru_module_name));\n\n\tualg->cru_type = 0;\n\tualg->cru_mask = 0;\n\tualg->cru_flags = alg->cra_flags;\n\tualg->cru_refcnt = refcount_read(&alg->cra_refcnt);\n\n\tif (nla_put_u32(skb, CRYPTOCFGA_PRIORITY_VAL, alg->cra_priority))\n\t\tgoto nla_put_failure;\n\tif (alg->cra_flags & CRYPTO_ALG_LARVAL) {\n\t\tstruct crypto_report_larval rl;\n\n\t\tstrlcpy(rl.type, \"larval\", sizeof(rl.type));\n\t\tif (nla_put(skb, CRYPTOCFGA_REPORT_LARVAL,\n\t\t\t    sizeof(struct crypto_report_larval), &rl))\n\t\t\tgoto nla_put_failure;\n\t\tgoto out;\n\t}\n\n\tif (alg->cra_type && alg->cra_type->report) {\n\t\tif (alg->cra_type->report(skb, alg))\n\t\t\tgoto nla_put_failure;\n\n\t\tgoto out;\n\t}\n\n\tswitch (alg->cra_flags & (CRYPTO_ALG_TYPE_MASK | CRYPTO_ALG_LARVAL)) {\n\tcase CRYPTO_ALG_TYPE_CIPHER:\n\t\tif (crypto_report_cipher(skb, alg))\n\t\t\tgoto nla_put_failure;\n\n\t\tbreak;\n\tcase CRYPTO_ALG_TYPE_COMPRESS:\n\t\tif (crypto_report_comp(skb, alg))\n\t\t\tgoto nla_put_failure;\n\n\t\tbreak;\n\tcase CRYPTO_ALG_TYPE_ACOMPRESS:\n\t\tif (crypto_report_acomp(skb, alg))\n\t\t\tgoto nla_put_failure;\n\n\t\tbreak;\n\tcase CRYPTO_ALG_TYPE_AKCIPHER:\n\t\tif (crypto_report_akcipher(skb, alg))\n\t\t\tgoto nla_put_failure;\n\n\t\tbreak;\n\tcase CRYPTO_ALG_TYPE_KPP:\n\t\tif (crypto_report_kpp(skb, alg))\n\t\t\tgoto nla_put_failure;\n\t\tbreak;\n\t}\n\nout:\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}\n\nstatic int crypto_report_alg(struct crypto_alg *alg,\n\t\t\t     struct crypto_dump_info *info)\n{\n\tstruct sk_buff *in_skb = info->in_skb;\n\tstruct sk_buff *skb = info->out_skb;\n\tstruct nlmsghdr *nlh;\n\tstruct crypto_user_alg *ualg;\n\tint err = 0;\n\n\tnlh = nlmsg_put(skb, NETLINK_CB(in_skb).portid, info->nlmsg_seq,\n\t\t\tCRYPTO_MSG_GETALG, sizeof(*ualg), info->nlmsg_flags);\n\tif (!nlh) {\n\t\terr = -EMSGSIZE;\n\t\tgoto out;\n\t}\n\n\tualg = nlmsg_data(nlh);\n\n\terr = crypto_report_one(alg, ualg, skb);\n\tif (err) {\n\t\tnlmsg_cancel(skb, nlh);\n\t\tgoto out;\n\t}\n\n\tnlmsg_end(skb, nlh);\n\nout:\n\treturn err;\n}\n\nstatic int crypto_report(struct sk_buff *in_skb, struct nlmsghdr *in_nlh,\n\t\t\t struct nlattr **attrs)\n{\n\tstruct crypto_user_alg *p = nlmsg_data(in_nlh);\n\tstruct crypto_alg *alg;\n\tstruct sk_buff *skb;\n\tstruct crypto_dump_info info;\n\tint err;\n\n\tif (!null_terminated(p->cru_name) || !null_terminated(p->cru_driver_name))\n\t\treturn -EINVAL;\n\n\talg = crypto_alg_match(p, 0);\n\tif (!alg)\n\t\treturn -ENOENT;\n\n\terr = -ENOMEM;\n\tskb = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!skb)\n\t\tgoto drop_alg;\n\n\tinfo.in_skb = in_skb;\n\tinfo.out_skb = skb;\n\tinfo.nlmsg_seq = in_nlh->nlmsg_seq;\n\tinfo.nlmsg_flags = 0;\n\n\terr = crypto_report_alg(alg, &info);\n\ndrop_alg:\n\tcrypto_mod_put(alg);\n\n\tif (err)\n\t\treturn err;\n\n\treturn nlmsg_unicast(crypto_nlsk, skb, NETLINK_CB(in_skb).portid);\n}\n\nstatic int crypto_dump_report(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct crypto_alg *alg;\n\tstruct crypto_dump_info info;\n\tint err;\n\n\tif (cb->args[0])\n\t\tgoto out;\n\n\tcb->args[0] = 1;\n\n\tinfo.in_skb = cb->skb;\n\tinfo.out_skb = skb;\n\tinfo.nlmsg_seq = cb->nlh->nlmsg_seq;\n\tinfo.nlmsg_flags = NLM_F_MULTI;\n\n\tlist_for_each_entry(alg, &crypto_alg_list, cra_list) {\n\t\terr = crypto_report_alg(alg, &info);\n\t\tif (err)\n\t\t\tgoto out_err;\n\t}\n\nout:\n\treturn skb->len;\nout_err:\n\treturn err;\n}\n\nstatic int crypto_dump_report_done(struct netlink_callback *cb)\n{\n\treturn 0;\n}\n\nstatic int crypto_update_alg(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\t     struct nlattr **attrs)\n{\n\tstruct crypto_alg *alg;\n\tstruct crypto_user_alg *p = nlmsg_data(nlh);\n\tstruct nlattr *priority = attrs[CRYPTOCFGA_PRIORITY_VAL];\n\tLIST_HEAD(list);\n\n\tif (!netlink_capable(skb, CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tif (!null_terminated(p->cru_name) || !null_terminated(p->cru_driver_name))\n\t\treturn -EINVAL;\n\n\tif (priority && !strlen(p->cru_driver_name))\n\t\treturn -EINVAL;\n\n\talg = crypto_alg_match(p, 1);\n\tif (!alg)\n\t\treturn -ENOENT;\n\n\tdown_write(&crypto_alg_sem);\n\n\tcrypto_remove_spawns(alg, &list, NULL);\n\n\tif (priority)\n\t\talg->cra_priority = nla_get_u32(priority);\n\n\tup_write(&crypto_alg_sem);\n\n\tcrypto_mod_put(alg);\n\tcrypto_remove_final(&list);\n\n\treturn 0;\n}\n\nstatic int crypto_del_alg(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\t  struct nlattr **attrs)\n{\n\tstruct crypto_alg *alg;\n\tstruct crypto_user_alg *p = nlmsg_data(nlh);\n\tint err;\n\n\tif (!netlink_capable(skb, CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tif (!null_terminated(p->cru_name) || !null_terminated(p->cru_driver_name))\n\t\treturn -EINVAL;\n\n\talg = crypto_alg_match(p, 1);\n\tif (!alg)\n\t\treturn -ENOENT;\n\n\t/* We can not unregister core algorithms such as aes-generic.\n\t * We would loose the reference in the crypto_alg_list to this algorithm\n\t * if we try to unregister. Unregistering such an algorithm without\n\t * removing the module is not possible, so we restrict to crypto\n\t * instances that are build from templates. */\n\terr = -EINVAL;\n\tif (!(alg->cra_flags & CRYPTO_ALG_INSTANCE))\n\t\tgoto drop_alg;\n\n\terr = -EBUSY;\n\tif (refcount_read(&alg->cra_refcnt) > 2)\n\t\tgoto drop_alg;\n\n\terr = crypto_unregister_instance((struct crypto_instance *)alg);\n\ndrop_alg:\n\tcrypto_mod_put(alg);\n\treturn err;\n}\n\nstatic int crypto_add_alg(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\t  struct nlattr **attrs)\n{\n\tint exact = 0;\n\tconst char *name;\n\tstruct crypto_alg *alg;\n\tstruct crypto_user_alg *p = nlmsg_data(nlh);\n\tstruct nlattr *priority = attrs[CRYPTOCFGA_PRIORITY_VAL];\n\n\tif (!netlink_capable(skb, CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tif (!null_terminated(p->cru_name) || !null_terminated(p->cru_driver_name))\n\t\treturn -EINVAL;\n\n\tif (strlen(p->cru_driver_name))\n\t\texact = 1;\n\n\tif (priority && !exact)\n\t\treturn -EINVAL;\n\n\talg = crypto_alg_match(p, exact);\n\tif (alg) {\n\t\tcrypto_mod_put(alg);\n\t\treturn -EEXIST;\n\t}\n\n\tif (strlen(p->cru_driver_name))\n\t\tname = p->cru_driver_name;\n\telse\n\t\tname = p->cru_name;\n\n\talg = crypto_alg_mod_lookup(name, p->cru_type, p->cru_mask);\n\tif (IS_ERR(alg))\n\t\treturn PTR_ERR(alg);\n\n\tdown_write(&crypto_alg_sem);\n\n\tif (priority)\n\t\talg->cra_priority = nla_get_u32(priority);\n\n\tup_write(&crypto_alg_sem);\n\n\tcrypto_mod_put(alg);\n\n\treturn 0;\n}\n\nstatic int crypto_del_rng(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\t  struct nlattr **attrs)\n{\n\tif (!netlink_capable(skb, CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\treturn crypto_del_default_rng();\n}\n\n#define MSGSIZE(type) sizeof(struct type)\n\nstatic const int crypto_msg_min[CRYPTO_NR_MSGTYPES] = {\n\t[CRYPTO_MSG_NEWALG\t- CRYPTO_MSG_BASE] = MSGSIZE(crypto_user_alg),\n\t[CRYPTO_MSG_DELALG\t- CRYPTO_MSG_BASE] = MSGSIZE(crypto_user_alg),\n\t[CRYPTO_MSG_UPDATEALG\t- CRYPTO_MSG_BASE] = MSGSIZE(crypto_user_alg),\n\t[CRYPTO_MSG_GETALG\t- CRYPTO_MSG_BASE] = MSGSIZE(crypto_user_alg),\n\t[CRYPTO_MSG_DELRNG\t- CRYPTO_MSG_BASE] = 0,\n\t[CRYPTO_MSG_GETSTAT\t- CRYPTO_MSG_BASE] = MSGSIZE(crypto_user_alg),\n};\n\nstatic const struct nla_policy crypto_policy[CRYPTOCFGA_MAX+1] = {\n\t[CRYPTOCFGA_PRIORITY_VAL]   = { .type = NLA_U32},\n};\n\n#undef MSGSIZE\n\nstatic const struct crypto_link {\n\tint (*doit)(struct sk_buff *, struct nlmsghdr *, struct nlattr **);\n\tint (*dump)(struct sk_buff *, struct netlink_callback *);\n\tint (*done)(struct netlink_callback *);\n} crypto_dispatch[CRYPTO_NR_MSGTYPES] = {\n\t[CRYPTO_MSG_NEWALG\t- CRYPTO_MSG_BASE] = { .doit = crypto_add_alg},\n\t[CRYPTO_MSG_DELALG\t- CRYPTO_MSG_BASE] = { .doit = crypto_del_alg},\n\t[CRYPTO_MSG_UPDATEALG\t- CRYPTO_MSG_BASE] = { .doit = crypto_update_alg},\n\t[CRYPTO_MSG_GETALG\t- CRYPTO_MSG_BASE] = { .doit = crypto_report,\n\t\t\t\t\t\t       .dump = crypto_dump_report,\n\t\t\t\t\t\t       .done = crypto_dump_report_done},\n\t[CRYPTO_MSG_DELRNG\t- CRYPTO_MSG_BASE] = { .doit = crypto_del_rng },\n\t[CRYPTO_MSG_GETSTAT\t- CRYPTO_MSG_BASE] = { .doit = crypto_reportstat,\n\t\t\t\t\t\t       .dump = crypto_dump_reportstat,\n\t\t\t\t\t\t       .done = crypto_dump_reportstat_done},\n};\n\nstatic int crypto_user_rcv_msg(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\t       struct netlink_ext_ack *extack)\n{\n\tstruct nlattr *attrs[CRYPTOCFGA_MAX+1];\n\tconst struct crypto_link *link;\n\tint type, err;\n\n\ttype = nlh->nlmsg_type;\n\tif (type > CRYPTO_MSG_MAX)\n\t\treturn -EINVAL;\n\n\ttype -= CRYPTO_MSG_BASE;\n\tlink = &crypto_dispatch[type];\n\n\tif ((type == (CRYPTO_MSG_GETALG - CRYPTO_MSG_BASE) &&\n\t    (nlh->nlmsg_flags & NLM_F_DUMP))) {\n\t\tstruct crypto_alg *alg;\n\t\tu16 dump_alloc = 0;\n\n\t\tif (link->dump == NULL)\n\t\t\treturn -EINVAL;\n\n\t\tdown_read(&crypto_alg_sem);\n\t\tlist_for_each_entry(alg, &crypto_alg_list, cra_list)\n\t\t\tdump_alloc += CRYPTO_REPORT_MAXSIZE;\n\n\t\t{\n\t\t\tstruct netlink_dump_control c = {\n\t\t\t\t.dump = link->dump,\n\t\t\t\t.done = link->done,\n\t\t\t\t.min_dump_alloc = dump_alloc,\n\t\t\t};\n\t\t\terr = netlink_dump_start(crypto_nlsk, skb, nlh, &c);\n\t\t}\n\t\tup_read(&crypto_alg_sem);\n\n\t\treturn err;\n\t}\n\n\terr = nlmsg_parse(nlh, crypto_msg_min[type], attrs, CRYPTOCFGA_MAX,\n\t\t\t  crypto_policy, extack);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (link->doit == NULL)\n\t\treturn -EINVAL;\n\n\treturn link->doit(skb, nlh, attrs);\n}\n\nstatic void crypto_netlink_rcv(struct sk_buff *skb)\n{\n\tmutex_lock(&crypto_cfg_mutex);\n\tnetlink_rcv_skb(skb, &crypto_user_rcv_msg);\n\tmutex_unlock(&crypto_cfg_mutex);\n}\n\nstatic int __init crypto_user_init(void)\n{\n\tstruct netlink_kernel_cfg cfg = {\n\t\t.input\t= crypto_netlink_rcv,\n\t};\n\n\tcrypto_nlsk = netlink_kernel_create(&init_net, NETLINK_CRYPTO, &cfg);\n\tif (!crypto_nlsk)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic void __exit crypto_user_exit(void)\n{\n\tnetlink_kernel_release(crypto_nlsk);\n}\n\nmodule_init(crypto_user_init);\nmodule_exit(crypto_user_exit);\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Steffen Klassert <steffen.klassert@secunet.com>\");\nMODULE_DESCRIPTION(\"Crypto userspace configuration API\");\nMODULE_ALIAS(\"net-pf-16-proto-21\");\n"], "fixing_code": ["/*\n * Crypto user configuration API.\n *\n * Copyright (C) 2011 secunet Security Networks AG\n * Copyright (C) 2011 Steffen Klassert <steffen.klassert@secunet.com>\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms and conditions of the GNU General Public License,\n * version 2, as published by the Free Software Foundation.\n *\n * This program is distributed in the hope it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n * more details.\n *\n * You should have received a copy of the GNU General Public License along with\n * this program; if not, write to the Free Software Foundation, Inc.,\n * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.\n */\n\n#include <linux/module.h>\n#include <linux/crypto.h>\n#include <linux/cryptouser.h>\n#include <linux/sched.h>\n#include <net/netlink.h>\n#include <linux/security.h>\n#include <net/net_namespace.h>\n#include <crypto/internal/skcipher.h>\n#include <crypto/internal/rng.h>\n#include <crypto/akcipher.h>\n#include <crypto/kpp.h>\n#include <crypto/internal/cryptouser.h>\n\n#include \"internal.h\"\n\n#define null_terminated(x)\t(strnlen(x, sizeof(x)) < sizeof(x))\n\nstatic DEFINE_MUTEX(crypto_cfg_mutex);\n\n/* The crypto netlink socket */\nstruct sock *crypto_nlsk;\n\nstruct crypto_dump_info {\n\tstruct sk_buff *in_skb;\n\tstruct sk_buff *out_skb;\n\tu32 nlmsg_seq;\n\tu16 nlmsg_flags;\n};\n\nstruct crypto_alg *crypto_alg_match(struct crypto_user_alg *p, int exact)\n{\n\tstruct crypto_alg *q, *alg = NULL;\n\n\tdown_read(&crypto_alg_sem);\n\n\tlist_for_each_entry(q, &crypto_alg_list, cra_list) {\n\t\tint match = 0;\n\n\t\tif ((q->cra_flags ^ p->cru_type) & p->cru_mask)\n\t\t\tcontinue;\n\n\t\tif (strlen(p->cru_driver_name))\n\t\t\tmatch = !strcmp(q->cra_driver_name,\n\t\t\t\t\tp->cru_driver_name);\n\t\telse if (!exact)\n\t\t\tmatch = !strcmp(q->cra_name, p->cru_name);\n\n\t\tif (!match)\n\t\t\tcontinue;\n\n\t\tif (unlikely(!crypto_mod_get(q)))\n\t\t\tcontinue;\n\n\t\talg = q;\n\t\tbreak;\n\t}\n\n\tup_read(&crypto_alg_sem);\n\n\treturn alg;\n}\n\nstatic int crypto_report_cipher(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_cipher rcipher;\n\n\tstrncpy(rcipher.type, \"cipher\", sizeof(rcipher.type));\n\n\trcipher.blocksize = alg->cra_blocksize;\n\trcipher.min_keysize = alg->cra_cipher.cia_min_keysize;\n\trcipher.max_keysize = alg->cra_cipher.cia_max_keysize;\n\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_CIPHER,\n\t\t    sizeof(struct crypto_report_cipher), &rcipher))\n\t\tgoto nla_put_failure;\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}\n\nstatic int crypto_report_comp(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_comp rcomp;\n\n\tstrncpy(rcomp.type, \"compression\", sizeof(rcomp.type));\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_COMPRESS,\n\t\t    sizeof(struct crypto_report_comp), &rcomp))\n\t\tgoto nla_put_failure;\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}\n\nstatic int crypto_report_acomp(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_acomp racomp;\n\n\tstrncpy(racomp.type, \"acomp\", sizeof(racomp.type));\n\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_ACOMP,\n\t\t    sizeof(struct crypto_report_acomp), &racomp))\n\t\tgoto nla_put_failure;\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}\n\nstatic int crypto_report_akcipher(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_akcipher rakcipher;\n\n\tstrncpy(rakcipher.type, \"akcipher\", sizeof(rakcipher.type));\n\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_AKCIPHER,\n\t\t    sizeof(struct crypto_report_akcipher), &rakcipher))\n\t\tgoto nla_put_failure;\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}\n\nstatic int crypto_report_kpp(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_kpp rkpp;\n\n\tstrncpy(rkpp.type, \"kpp\", sizeof(rkpp.type));\n\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_KPP,\n\t\t    sizeof(struct crypto_report_kpp), &rkpp))\n\t\tgoto nla_put_failure;\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}\n\nstatic int crypto_report_one(struct crypto_alg *alg,\n\t\t\t     struct crypto_user_alg *ualg, struct sk_buff *skb)\n{\n\tstrncpy(ualg->cru_name, alg->cra_name, sizeof(ualg->cru_name));\n\tstrncpy(ualg->cru_driver_name, alg->cra_driver_name,\n\t\tsizeof(ualg->cru_driver_name));\n\tstrncpy(ualg->cru_module_name, module_name(alg->cra_module),\n\t\tsizeof(ualg->cru_module_name));\n\n\tualg->cru_type = 0;\n\tualg->cru_mask = 0;\n\tualg->cru_flags = alg->cra_flags;\n\tualg->cru_refcnt = refcount_read(&alg->cra_refcnt);\n\n\tif (nla_put_u32(skb, CRYPTOCFGA_PRIORITY_VAL, alg->cra_priority))\n\t\tgoto nla_put_failure;\n\tif (alg->cra_flags & CRYPTO_ALG_LARVAL) {\n\t\tstruct crypto_report_larval rl;\n\n\t\tstrncpy(rl.type, \"larval\", sizeof(rl.type));\n\t\tif (nla_put(skb, CRYPTOCFGA_REPORT_LARVAL,\n\t\t\t    sizeof(struct crypto_report_larval), &rl))\n\t\t\tgoto nla_put_failure;\n\t\tgoto out;\n\t}\n\n\tif (alg->cra_type && alg->cra_type->report) {\n\t\tif (alg->cra_type->report(skb, alg))\n\t\t\tgoto nla_put_failure;\n\n\t\tgoto out;\n\t}\n\n\tswitch (alg->cra_flags & (CRYPTO_ALG_TYPE_MASK | CRYPTO_ALG_LARVAL)) {\n\tcase CRYPTO_ALG_TYPE_CIPHER:\n\t\tif (crypto_report_cipher(skb, alg))\n\t\t\tgoto nla_put_failure;\n\n\t\tbreak;\n\tcase CRYPTO_ALG_TYPE_COMPRESS:\n\t\tif (crypto_report_comp(skb, alg))\n\t\t\tgoto nla_put_failure;\n\n\t\tbreak;\n\tcase CRYPTO_ALG_TYPE_ACOMPRESS:\n\t\tif (crypto_report_acomp(skb, alg))\n\t\t\tgoto nla_put_failure;\n\n\t\tbreak;\n\tcase CRYPTO_ALG_TYPE_AKCIPHER:\n\t\tif (crypto_report_akcipher(skb, alg))\n\t\t\tgoto nla_put_failure;\n\n\t\tbreak;\n\tcase CRYPTO_ALG_TYPE_KPP:\n\t\tif (crypto_report_kpp(skb, alg))\n\t\t\tgoto nla_put_failure;\n\t\tbreak;\n\t}\n\nout:\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}\n\nstatic int crypto_report_alg(struct crypto_alg *alg,\n\t\t\t     struct crypto_dump_info *info)\n{\n\tstruct sk_buff *in_skb = info->in_skb;\n\tstruct sk_buff *skb = info->out_skb;\n\tstruct nlmsghdr *nlh;\n\tstruct crypto_user_alg *ualg;\n\tint err = 0;\n\n\tnlh = nlmsg_put(skb, NETLINK_CB(in_skb).portid, info->nlmsg_seq,\n\t\t\tCRYPTO_MSG_GETALG, sizeof(*ualg), info->nlmsg_flags);\n\tif (!nlh) {\n\t\terr = -EMSGSIZE;\n\t\tgoto out;\n\t}\n\n\tualg = nlmsg_data(nlh);\n\n\terr = crypto_report_one(alg, ualg, skb);\n\tif (err) {\n\t\tnlmsg_cancel(skb, nlh);\n\t\tgoto out;\n\t}\n\n\tnlmsg_end(skb, nlh);\n\nout:\n\treturn err;\n}\n\nstatic int crypto_report(struct sk_buff *in_skb, struct nlmsghdr *in_nlh,\n\t\t\t struct nlattr **attrs)\n{\n\tstruct crypto_user_alg *p = nlmsg_data(in_nlh);\n\tstruct crypto_alg *alg;\n\tstruct sk_buff *skb;\n\tstruct crypto_dump_info info;\n\tint err;\n\n\tif (!null_terminated(p->cru_name) || !null_terminated(p->cru_driver_name))\n\t\treturn -EINVAL;\n\n\talg = crypto_alg_match(p, 0);\n\tif (!alg)\n\t\treturn -ENOENT;\n\n\terr = -ENOMEM;\n\tskb = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!skb)\n\t\tgoto drop_alg;\n\n\tinfo.in_skb = in_skb;\n\tinfo.out_skb = skb;\n\tinfo.nlmsg_seq = in_nlh->nlmsg_seq;\n\tinfo.nlmsg_flags = 0;\n\n\terr = crypto_report_alg(alg, &info);\n\ndrop_alg:\n\tcrypto_mod_put(alg);\n\n\tif (err)\n\t\treturn err;\n\n\treturn nlmsg_unicast(crypto_nlsk, skb, NETLINK_CB(in_skb).portid);\n}\n\nstatic int crypto_dump_report(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct crypto_alg *alg;\n\tstruct crypto_dump_info info;\n\tint err;\n\n\tif (cb->args[0])\n\t\tgoto out;\n\n\tcb->args[0] = 1;\n\n\tinfo.in_skb = cb->skb;\n\tinfo.out_skb = skb;\n\tinfo.nlmsg_seq = cb->nlh->nlmsg_seq;\n\tinfo.nlmsg_flags = NLM_F_MULTI;\n\n\tlist_for_each_entry(alg, &crypto_alg_list, cra_list) {\n\t\terr = crypto_report_alg(alg, &info);\n\t\tif (err)\n\t\t\tgoto out_err;\n\t}\n\nout:\n\treturn skb->len;\nout_err:\n\treturn err;\n}\n\nstatic int crypto_dump_report_done(struct netlink_callback *cb)\n{\n\treturn 0;\n}\n\nstatic int crypto_update_alg(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\t     struct nlattr **attrs)\n{\n\tstruct crypto_alg *alg;\n\tstruct crypto_user_alg *p = nlmsg_data(nlh);\n\tstruct nlattr *priority = attrs[CRYPTOCFGA_PRIORITY_VAL];\n\tLIST_HEAD(list);\n\n\tif (!netlink_capable(skb, CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tif (!null_terminated(p->cru_name) || !null_terminated(p->cru_driver_name))\n\t\treturn -EINVAL;\n\n\tif (priority && !strlen(p->cru_driver_name))\n\t\treturn -EINVAL;\n\n\talg = crypto_alg_match(p, 1);\n\tif (!alg)\n\t\treturn -ENOENT;\n\n\tdown_write(&crypto_alg_sem);\n\n\tcrypto_remove_spawns(alg, &list, NULL);\n\n\tif (priority)\n\t\talg->cra_priority = nla_get_u32(priority);\n\n\tup_write(&crypto_alg_sem);\n\n\tcrypto_mod_put(alg);\n\tcrypto_remove_final(&list);\n\n\treturn 0;\n}\n\nstatic int crypto_del_alg(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\t  struct nlattr **attrs)\n{\n\tstruct crypto_alg *alg;\n\tstruct crypto_user_alg *p = nlmsg_data(nlh);\n\tint err;\n\n\tif (!netlink_capable(skb, CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tif (!null_terminated(p->cru_name) || !null_terminated(p->cru_driver_name))\n\t\treturn -EINVAL;\n\n\talg = crypto_alg_match(p, 1);\n\tif (!alg)\n\t\treturn -ENOENT;\n\n\t/* We can not unregister core algorithms such as aes-generic.\n\t * We would loose the reference in the crypto_alg_list to this algorithm\n\t * if we try to unregister. Unregistering such an algorithm without\n\t * removing the module is not possible, so we restrict to crypto\n\t * instances that are build from templates. */\n\terr = -EINVAL;\n\tif (!(alg->cra_flags & CRYPTO_ALG_INSTANCE))\n\t\tgoto drop_alg;\n\n\terr = -EBUSY;\n\tif (refcount_read(&alg->cra_refcnt) > 2)\n\t\tgoto drop_alg;\n\n\terr = crypto_unregister_instance((struct crypto_instance *)alg);\n\ndrop_alg:\n\tcrypto_mod_put(alg);\n\treturn err;\n}\n\nstatic int crypto_add_alg(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\t  struct nlattr **attrs)\n{\n\tint exact = 0;\n\tconst char *name;\n\tstruct crypto_alg *alg;\n\tstruct crypto_user_alg *p = nlmsg_data(nlh);\n\tstruct nlattr *priority = attrs[CRYPTOCFGA_PRIORITY_VAL];\n\n\tif (!netlink_capable(skb, CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tif (!null_terminated(p->cru_name) || !null_terminated(p->cru_driver_name))\n\t\treturn -EINVAL;\n\n\tif (strlen(p->cru_driver_name))\n\t\texact = 1;\n\n\tif (priority && !exact)\n\t\treturn -EINVAL;\n\n\talg = crypto_alg_match(p, exact);\n\tif (alg) {\n\t\tcrypto_mod_put(alg);\n\t\treturn -EEXIST;\n\t}\n\n\tif (strlen(p->cru_driver_name))\n\t\tname = p->cru_driver_name;\n\telse\n\t\tname = p->cru_name;\n\n\talg = crypto_alg_mod_lookup(name, p->cru_type, p->cru_mask);\n\tif (IS_ERR(alg))\n\t\treturn PTR_ERR(alg);\n\n\tdown_write(&crypto_alg_sem);\n\n\tif (priority)\n\t\talg->cra_priority = nla_get_u32(priority);\n\n\tup_write(&crypto_alg_sem);\n\n\tcrypto_mod_put(alg);\n\n\treturn 0;\n}\n\nstatic int crypto_del_rng(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\t  struct nlattr **attrs)\n{\n\tif (!netlink_capable(skb, CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\treturn crypto_del_default_rng();\n}\n\n#define MSGSIZE(type) sizeof(struct type)\n\nstatic const int crypto_msg_min[CRYPTO_NR_MSGTYPES] = {\n\t[CRYPTO_MSG_NEWALG\t- CRYPTO_MSG_BASE] = MSGSIZE(crypto_user_alg),\n\t[CRYPTO_MSG_DELALG\t- CRYPTO_MSG_BASE] = MSGSIZE(crypto_user_alg),\n\t[CRYPTO_MSG_UPDATEALG\t- CRYPTO_MSG_BASE] = MSGSIZE(crypto_user_alg),\n\t[CRYPTO_MSG_GETALG\t- CRYPTO_MSG_BASE] = MSGSIZE(crypto_user_alg),\n\t[CRYPTO_MSG_DELRNG\t- CRYPTO_MSG_BASE] = 0,\n\t[CRYPTO_MSG_GETSTAT\t- CRYPTO_MSG_BASE] = MSGSIZE(crypto_user_alg),\n};\n\nstatic const struct nla_policy crypto_policy[CRYPTOCFGA_MAX+1] = {\n\t[CRYPTOCFGA_PRIORITY_VAL]   = { .type = NLA_U32},\n};\n\n#undef MSGSIZE\n\nstatic const struct crypto_link {\n\tint (*doit)(struct sk_buff *, struct nlmsghdr *, struct nlattr **);\n\tint (*dump)(struct sk_buff *, struct netlink_callback *);\n\tint (*done)(struct netlink_callback *);\n} crypto_dispatch[CRYPTO_NR_MSGTYPES] = {\n\t[CRYPTO_MSG_NEWALG\t- CRYPTO_MSG_BASE] = { .doit = crypto_add_alg},\n\t[CRYPTO_MSG_DELALG\t- CRYPTO_MSG_BASE] = { .doit = crypto_del_alg},\n\t[CRYPTO_MSG_UPDATEALG\t- CRYPTO_MSG_BASE] = { .doit = crypto_update_alg},\n\t[CRYPTO_MSG_GETALG\t- CRYPTO_MSG_BASE] = { .doit = crypto_report,\n\t\t\t\t\t\t       .dump = crypto_dump_report,\n\t\t\t\t\t\t       .done = crypto_dump_report_done},\n\t[CRYPTO_MSG_DELRNG\t- CRYPTO_MSG_BASE] = { .doit = crypto_del_rng },\n\t[CRYPTO_MSG_GETSTAT\t- CRYPTO_MSG_BASE] = { .doit = crypto_reportstat,\n\t\t\t\t\t\t       .dump = crypto_dump_reportstat,\n\t\t\t\t\t\t       .done = crypto_dump_reportstat_done},\n};\n\nstatic int crypto_user_rcv_msg(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\t       struct netlink_ext_ack *extack)\n{\n\tstruct nlattr *attrs[CRYPTOCFGA_MAX+1];\n\tconst struct crypto_link *link;\n\tint type, err;\n\n\ttype = nlh->nlmsg_type;\n\tif (type > CRYPTO_MSG_MAX)\n\t\treturn -EINVAL;\n\n\ttype -= CRYPTO_MSG_BASE;\n\tlink = &crypto_dispatch[type];\n\n\tif ((type == (CRYPTO_MSG_GETALG - CRYPTO_MSG_BASE) &&\n\t    (nlh->nlmsg_flags & NLM_F_DUMP))) {\n\t\tstruct crypto_alg *alg;\n\t\tu16 dump_alloc = 0;\n\n\t\tif (link->dump == NULL)\n\t\t\treturn -EINVAL;\n\n\t\tdown_read(&crypto_alg_sem);\n\t\tlist_for_each_entry(alg, &crypto_alg_list, cra_list)\n\t\t\tdump_alloc += CRYPTO_REPORT_MAXSIZE;\n\n\t\t{\n\t\t\tstruct netlink_dump_control c = {\n\t\t\t\t.dump = link->dump,\n\t\t\t\t.done = link->done,\n\t\t\t\t.min_dump_alloc = dump_alloc,\n\t\t\t};\n\t\t\terr = netlink_dump_start(crypto_nlsk, skb, nlh, &c);\n\t\t}\n\t\tup_read(&crypto_alg_sem);\n\n\t\treturn err;\n\t}\n\n\terr = nlmsg_parse(nlh, crypto_msg_min[type], attrs, CRYPTOCFGA_MAX,\n\t\t\t  crypto_policy, extack);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (link->doit == NULL)\n\t\treturn -EINVAL;\n\n\treturn link->doit(skb, nlh, attrs);\n}\n\nstatic void crypto_netlink_rcv(struct sk_buff *skb)\n{\n\tmutex_lock(&crypto_cfg_mutex);\n\tnetlink_rcv_skb(skb, &crypto_user_rcv_msg);\n\tmutex_unlock(&crypto_cfg_mutex);\n}\n\nstatic int __init crypto_user_init(void)\n{\n\tstruct netlink_kernel_cfg cfg = {\n\t\t.input\t= crypto_netlink_rcv,\n\t};\n\n\tcrypto_nlsk = netlink_kernel_create(&init_net, NETLINK_CRYPTO, &cfg);\n\tif (!crypto_nlsk)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic void __exit crypto_user_exit(void)\n{\n\tnetlink_kernel_release(crypto_nlsk);\n}\n\nmodule_init(crypto_user_init);\nmodule_exit(crypto_user_exit);\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Steffen Klassert <steffen.klassert@secunet.com>\");\nMODULE_DESCRIPTION(\"Crypto userspace configuration API\");\nMODULE_ALIAS(\"net-pf-16-proto-21\");\n"], "filenames": ["crypto/crypto_user_base.c"], "buggy_code_start_loc": [87], "buggy_code_end_loc": [181], "fixing_code_start_loc": [87], "fixing_code_end_loc": [181], "type": "CWE-200", "message": "An issue was discovered in the Linux kernel before 4.19.3. crypto_report_one() and related functions in crypto/crypto_user.c (the crypto user configuration API) do not fully initialize structures that are copied to userspace, potentially leaking sensitive memory to user programs. NOTE: this is a CVE-2013-2547 regression but with easier exploitability because the attacker does not need a capability (however, the system must have the CONFIG_CRYPTO_USER kconfig option).", "other": {"cve": {"id": "CVE-2018-19854", "sourceIdentifier": "cve@mitre.org", "published": "2018-12-04T16:29:00.587", "lastModified": "2019-11-06T01:15:17.137", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "An issue was discovered in the Linux kernel before 4.19.3. crypto_report_one() and related functions in crypto/crypto_user.c (the crypto user configuration API) do not fully initialize structures that are copied to userspace, potentially leaking sensitive memory to user programs. NOTE: this is a CVE-2013-2547 regression but with easier exploitability because the attacker does not need a capability (however, the system must have the CONFIG_CRYPTO_USER kconfig option)."}, {"lang": "es", "value": "Se ha descubierto un problema en el kernel de Linux hasta antes de la versi\u00f3n 4.19.3. crypto_report_one() y otras funciones relacionadas en crypto/crypto_user.c (la API de configuraci\u00f3n de usuarios crypto) no inicializan completamente las estructuras que se copian en el espacio de usuario, lo que podr\u00eda filtrar memoria sensible a los programas del usuario. NOTA: esta es una regresi\u00f3n de CVE-2013-2547, pero con una explotabilidad m\u00e1s sencilla. Esto se deba a que el atacante no necesita una capacidad (sin embargo, el sistema debe tener la opci\u00f3n de kconfig CONFIG_CRYPTO_USER)."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:N/A:N", "attackVector": "LOCAL", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.7, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.0, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:M/Au:N/C:P/I:N/A:N", "accessVector": "LOCAL", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 1.9}, "baseSeverity": "LOW", "exploitabilityScore": 3.4, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-200"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "4.19.3", "matchCriteriaId": "F729629A-5EA0-4542-BC58-0409385C14EB"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.04:*:*:*:lts:*:*:*", "matchCriteriaId": "B5A6F2F3-4894-4392-8296-3B8DD2679084"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:lts:*:*:*", "matchCriteriaId": "F7016A2A-8365-4F1A-89A2-7A19F2BCAE5B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.10:*:*:*:*:*:*:*", "matchCriteriaId": "07C312A0-CD2C-4B9C-B064-6409B25C278F"}]}]}], "references": [{"url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=f43f39958beb206b53292801e216d9b8a660f087", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2019:3309", "source": "cve@mitre.org"}, {"url": "https://access.redhat.com/errata/RHSA-2019:3517", "source": "cve@mitre.org"}, {"url": "https://github.com/torvalds/linux/commit/f43f39958beb206b53292801e216d9b8a660f087", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://kernel.org/pub/linux/kernel/v4.x/ChangeLog-4.19.3", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}, {"url": "https://usn.ubuntu.com/3872-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3878-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3878-2/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3901-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3901-2/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/f43f39958beb206b53292801e216d9b8a660f087"}}