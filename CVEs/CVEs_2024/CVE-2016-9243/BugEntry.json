{"buggy_code": ["# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import absolute_import, division, print_function\n\nimport six\n\nfrom cryptography import utils\nfrom cryptography.exceptions import (\n    AlreadyFinalized, InvalidKey, UnsupportedAlgorithm, _Reasons\n)\nfrom cryptography.hazmat.backends.interfaces import HMACBackend\nfrom cryptography.hazmat.primitives import constant_time, hmac\nfrom cryptography.hazmat.primitives.kdf import KeyDerivationFunction\n\n\n@utils.register_interface(KeyDerivationFunction)\nclass HKDF(object):\n    def __init__(self, algorithm, length, salt, info, backend):\n        if not isinstance(backend, HMACBackend):\n            raise UnsupportedAlgorithm(\n                \"Backend object does not implement HMACBackend.\",\n                _Reasons.BACKEND_MISSING_INTERFACE\n            )\n\n        self._algorithm = algorithm\n\n        if not (salt is None or isinstance(salt, bytes)):\n            raise TypeError(\"salt must be bytes.\")\n\n        if salt is None:\n            salt = b\"\\x00\" * (self._algorithm.digest_size // 8)\n\n        self._salt = salt\n\n        self._backend = backend\n\n        self._hkdf_expand = HKDFExpand(self._algorithm, length, info, backend)\n\n    def _extract(self, key_material):\n        h = hmac.HMAC(self._salt, self._algorithm, backend=self._backend)\n        h.update(key_material)\n        return h.finalize()\n\n    def derive(self, key_material):\n        if not isinstance(key_material, bytes):\n            raise TypeError(\"key_material must be bytes.\")\n\n        return self._hkdf_expand.derive(self._extract(key_material))\n\n    def verify(self, key_material, expected_key):\n        if not constant_time.bytes_eq(self.derive(key_material), expected_key):\n            raise InvalidKey\n\n\n@utils.register_interface(KeyDerivationFunction)\nclass HKDFExpand(object):\n    def __init__(self, algorithm, length, info, backend):\n        if not isinstance(backend, HMACBackend):\n            raise UnsupportedAlgorithm(\n                \"Backend object does not implement HMACBackend.\",\n                _Reasons.BACKEND_MISSING_INTERFACE\n            )\n\n        self._algorithm = algorithm\n\n        self._backend = backend\n\n        max_length = 255 * (algorithm.digest_size // 8)\n\n        if length > max_length:\n            raise ValueError(\n                \"Can not derive keys larger than {0} octets.\".format(\n                    max_length\n                ))\n\n        self._length = length\n\n        if not (info is None or isinstance(info, bytes)):\n            raise TypeError(\"info must be bytes.\")\n\n        if info is None:\n            info = b\"\"\n\n        self._info = info\n\n        self._used = False\n\n    def _expand(self, key_material):\n        output = [b\"\"]\n        counter = 1\n\n        while (self._algorithm.digest_size // 8) * len(output) < self._length:\n            h = hmac.HMAC(key_material, self._algorithm, backend=self._backend)\n            h.update(output[-1])\n            h.update(self._info)\n            h.update(six.int2byte(counter))\n            output.append(h.finalize())\n            counter += 1\n\n        return b\"\".join(output)[:self._length]\n\n    def derive(self, key_material):\n        if not isinstance(key_material, bytes):\n            raise TypeError(\"key_material must be bytes.\")\n\n        if self._used:\n            raise AlreadyFinalized\n\n        self._used = True\n        return self._expand(key_material)\n\n    def verify(self, key_material, expected_key):\n        if not constant_time.bytes_eq(self.derive(key_material), expected_key):\n            raise InvalidKey\n", "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import absolute_import, division, print_function\n\nimport binascii\n\nimport pytest\n\nfrom cryptography.exceptions import (\n    AlreadyFinalized, InvalidKey, _Reasons\n)\nfrom cryptography.hazmat.backends.interfaces import HMACBackend\nfrom cryptography.hazmat.primitives import hashes\nfrom cryptography.hazmat.primitives.kdf.hkdf import HKDF, HKDFExpand\n\nfrom ...utils import raises_unsupported_algorithm\n\n\n@pytest.mark.requires_backend_interface(interface=HMACBackend)\nclass TestHKDF(object):\n    def test_length_limit(self, backend):\n        big_length = 255 * (hashes.SHA256().digest_size // 8) + 1\n\n        with pytest.raises(ValueError):\n            HKDF(\n                hashes.SHA256(),\n                big_length,\n                salt=None,\n                info=None,\n                backend=backend\n            )\n\n    def test_already_finalized(self, backend):\n        hkdf = HKDF(\n            hashes.SHA256(),\n            16,\n            salt=None,\n            info=None,\n            backend=backend\n        )\n\n        hkdf.derive(b\"\\x01\" * 16)\n\n        with pytest.raises(AlreadyFinalized):\n            hkdf.derive(b\"\\x02\" * 16)\n\n        hkdf = HKDF(\n            hashes.SHA256(),\n            16,\n            salt=None,\n            info=None,\n            backend=backend\n        )\n\n        hkdf.verify(b\"\\x01\" * 16, b\"gJ\\xfb{\\xb1Oi\\xc5sMC\\xb7\\xe4@\\xf7u\")\n\n        with pytest.raises(AlreadyFinalized):\n            hkdf.verify(b\"\\x02\" * 16, b\"gJ\\xfb{\\xb1Oi\\xc5sMC\\xb7\\xe4@\\xf7u\")\n\n        hkdf = HKDF(\n            hashes.SHA256(),\n            16,\n            salt=None,\n            info=None,\n            backend=backend\n        )\n\n    def test_verify(self, backend):\n        hkdf = HKDF(\n            hashes.SHA256(),\n            16,\n            salt=None,\n            info=None,\n            backend=backend\n        )\n\n        hkdf.verify(b\"\\x01\" * 16, b\"gJ\\xfb{\\xb1Oi\\xc5sMC\\xb7\\xe4@\\xf7u\")\n\n    def test_verify_invalid(self, backend):\n        hkdf = HKDF(\n            hashes.SHA256(),\n            16,\n            salt=None,\n            info=None,\n            backend=backend\n        )\n\n        with pytest.raises(InvalidKey):\n            hkdf.verify(b\"\\x02\" * 16, b\"gJ\\xfb{\\xb1Oi\\xc5sMC\\xb7\\xe4@\\xf7u\")\n\n    def test_unicode_typeerror(self, backend):\n        with pytest.raises(TypeError):\n            HKDF(\n                hashes.SHA256(),\n                16,\n                salt=u\"foo\",\n                info=None,\n                backend=backend\n            )\n\n        with pytest.raises(TypeError):\n            HKDF(\n                hashes.SHA256(),\n                16,\n                salt=None,\n                info=u\"foo\",\n                backend=backend\n            )\n\n        with pytest.raises(TypeError):\n            hkdf = HKDF(\n                hashes.SHA256(),\n                16,\n                salt=None,\n                info=None,\n                backend=backend\n            )\n\n            hkdf.derive(u\"foo\")\n\n        with pytest.raises(TypeError):\n            hkdf = HKDF(\n                hashes.SHA256(),\n                16,\n                salt=None,\n                info=None,\n                backend=backend\n            )\n\n            hkdf.verify(u\"foo\", b\"bar\")\n\n        with pytest.raises(TypeError):\n            hkdf = HKDF(\n                hashes.SHA256(),\n                16,\n                salt=None,\n                info=None,\n                backend=backend\n            )\n\n            hkdf.verify(b\"foo\", u\"bar\")\n\n\n@pytest.mark.requires_backend_interface(interface=HMACBackend)\nclass TestHKDFExpand(object):\n    def test_derive(self, backend):\n        prk = binascii.unhexlify(\n            b\"077709362c2e32df0ddc3f0dc47bba6390b6c73bb50f9c3122ec844ad7c2b3e5\"\n        )\n\n        okm = (b\"3cb25f25faacd57a90434f64d0362f2a2d2d0a90cf1a5a4c5db02d56ecc4c\"\n               b\"5bf34007208d5b887185865\")\n\n        info = binascii.unhexlify(b\"f0f1f2f3f4f5f6f7f8f9\")\n        hkdf = HKDFExpand(hashes.SHA256(), 42, info, backend)\n\n        assert binascii.hexlify(hkdf.derive(prk)) == okm\n\n    def test_verify(self, backend):\n        prk = binascii.unhexlify(\n            b\"077709362c2e32df0ddc3f0dc47bba6390b6c73bb50f9c3122ec844ad7c2b3e5\"\n        )\n\n        okm = (b\"3cb25f25faacd57a90434f64d0362f2a2d2d0a90cf1a5a4c5db02d56ecc4c\"\n               b\"5bf34007208d5b887185865\")\n\n        info = binascii.unhexlify(b\"f0f1f2f3f4f5f6f7f8f9\")\n        hkdf = HKDFExpand(hashes.SHA256(), 42, info, backend)\n\n        assert hkdf.verify(prk, binascii.unhexlify(okm)) is None\n\n    def test_invalid_verify(self, backend):\n        prk = binascii.unhexlify(\n            b\"077709362c2e32df0ddc3f0dc47bba6390b6c73bb50f9c3122ec844ad7c2b3e5\"\n        )\n\n        info = binascii.unhexlify(b\"f0f1f2f3f4f5f6f7f8f9\")\n        hkdf = HKDFExpand(hashes.SHA256(), 42, info, backend)\n\n        with pytest.raises(InvalidKey):\n            hkdf.verify(prk, b\"wrong key\")\n\n    def test_already_finalized(self, backend):\n        info = binascii.unhexlify(b\"f0f1f2f3f4f5f6f7f8f9\")\n        hkdf = HKDFExpand(hashes.SHA256(), 42, info, backend)\n\n        hkdf.derive(b\"first\")\n\n        with pytest.raises(AlreadyFinalized):\n            hkdf.derive(b\"second\")\n\n    def test_unicode_error(self, backend):\n        info = binascii.unhexlify(b\"f0f1f2f3f4f5f6f7f8f9\")\n        hkdf = HKDFExpand(hashes.SHA256(), 42, info, backend)\n\n        with pytest.raises(TypeError):\n            hkdf.derive(u\"first\")\n\n\ndef test_invalid_backend():\n    pretend_backend = object()\n\n    with raises_unsupported_algorithm(_Reasons.BACKEND_MISSING_INTERFACE):\n        HKDF(hashes.SHA256(), 16, None, None, pretend_backend)\n\n    with raises_unsupported_algorithm(_Reasons.BACKEND_MISSING_INTERFACE):\n        HKDFExpand(hashes.SHA256(), 16, None, pretend_backend)\n"], "fixing_code": ["# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import absolute_import, division, print_function\n\nimport six\n\nfrom cryptography import utils\nfrom cryptography.exceptions import (\n    AlreadyFinalized, InvalidKey, UnsupportedAlgorithm, _Reasons\n)\nfrom cryptography.hazmat.backends.interfaces import HMACBackend\nfrom cryptography.hazmat.primitives import constant_time, hmac\nfrom cryptography.hazmat.primitives.kdf import KeyDerivationFunction\n\n\n@utils.register_interface(KeyDerivationFunction)\nclass HKDF(object):\n    def __init__(self, algorithm, length, salt, info, backend):\n        if not isinstance(backend, HMACBackend):\n            raise UnsupportedAlgorithm(\n                \"Backend object does not implement HMACBackend.\",\n                _Reasons.BACKEND_MISSING_INTERFACE\n            )\n\n        self._algorithm = algorithm\n\n        if not (salt is None or isinstance(salt, bytes)):\n            raise TypeError(\"salt must be bytes.\")\n\n        if salt is None:\n            salt = b\"\\x00\" * (self._algorithm.digest_size // 8)\n\n        self._salt = salt\n\n        self._backend = backend\n\n        self._hkdf_expand = HKDFExpand(self._algorithm, length, info, backend)\n\n    def _extract(self, key_material):\n        h = hmac.HMAC(self._salt, self._algorithm, backend=self._backend)\n        h.update(key_material)\n        return h.finalize()\n\n    def derive(self, key_material):\n        if not isinstance(key_material, bytes):\n            raise TypeError(\"key_material must be bytes.\")\n\n        return self._hkdf_expand.derive(self._extract(key_material))\n\n    def verify(self, key_material, expected_key):\n        if not constant_time.bytes_eq(self.derive(key_material), expected_key):\n            raise InvalidKey\n\n\n@utils.register_interface(KeyDerivationFunction)\nclass HKDFExpand(object):\n    def __init__(self, algorithm, length, info, backend):\n        if not isinstance(backend, HMACBackend):\n            raise UnsupportedAlgorithm(\n                \"Backend object does not implement HMACBackend.\",\n                _Reasons.BACKEND_MISSING_INTERFACE\n            )\n\n        self._algorithm = algorithm\n\n        self._backend = backend\n\n        max_length = 255 * (algorithm.digest_size // 8)\n\n        if length > max_length:\n            raise ValueError(\n                \"Can not derive keys larger than {0} octets.\".format(\n                    max_length\n                ))\n\n        self._length = length\n\n        if not (info is None or isinstance(info, bytes)):\n            raise TypeError(\"info must be bytes.\")\n\n        if info is None:\n            info = b\"\"\n\n        self._info = info\n\n        self._used = False\n\n    def _expand(self, key_material):\n        output = [b\"\"]\n        counter = 1\n\n        while self._algorithm.digest_size * (len(output) - 1) < self._length:\n            h = hmac.HMAC(key_material, self._algorithm, backend=self._backend)\n            h.update(output[-1])\n            h.update(self._info)\n            h.update(six.int2byte(counter))\n            output.append(h.finalize())\n            counter += 1\n\n        return b\"\".join(output)[:self._length]\n\n    def derive(self, key_material):\n        if not isinstance(key_material, bytes):\n            raise TypeError(\"key_material must be bytes.\")\n\n        if self._used:\n            raise AlreadyFinalized\n\n        self._used = True\n        return self._expand(key_material)\n\n    def verify(self, key_material, expected_key):\n        if not constant_time.bytes_eq(self.derive(key_material), expected_key):\n            raise InvalidKey\n", "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import absolute_import, division, print_function\n\nimport binascii\n\nimport pytest\n\nfrom cryptography.exceptions import (\n    AlreadyFinalized, InvalidKey, _Reasons\n)\nfrom cryptography.hazmat.backends.interfaces import HMACBackend\nfrom cryptography.hazmat.primitives import hashes\nfrom cryptography.hazmat.primitives.kdf.hkdf import HKDF, HKDFExpand\n\nfrom ...utils import raises_unsupported_algorithm\n\n\n@pytest.mark.requires_backend_interface(interface=HMACBackend)\nclass TestHKDF(object):\n    def test_length_limit(self, backend):\n        big_length = 255 * (hashes.SHA256().digest_size // 8) + 1\n\n        with pytest.raises(ValueError):\n            HKDF(\n                hashes.SHA256(),\n                big_length,\n                salt=None,\n                info=None,\n                backend=backend\n            )\n\n    def test_already_finalized(self, backend):\n        hkdf = HKDF(\n            hashes.SHA256(),\n            16,\n            salt=None,\n            info=None,\n            backend=backend\n        )\n\n        hkdf.derive(b\"\\x01\" * 16)\n\n        with pytest.raises(AlreadyFinalized):\n            hkdf.derive(b\"\\x02\" * 16)\n\n        hkdf = HKDF(\n            hashes.SHA256(),\n            16,\n            salt=None,\n            info=None,\n            backend=backend\n        )\n\n        hkdf.verify(b\"\\x01\" * 16, b\"gJ\\xfb{\\xb1Oi\\xc5sMC\\xb7\\xe4@\\xf7u\")\n\n        with pytest.raises(AlreadyFinalized):\n            hkdf.verify(b\"\\x02\" * 16, b\"gJ\\xfb{\\xb1Oi\\xc5sMC\\xb7\\xe4@\\xf7u\")\n\n        hkdf = HKDF(\n            hashes.SHA256(),\n            16,\n            salt=None,\n            info=None,\n            backend=backend\n        )\n\n    def test_verify(self, backend):\n        hkdf = HKDF(\n            hashes.SHA256(),\n            16,\n            salt=None,\n            info=None,\n            backend=backend\n        )\n\n        hkdf.verify(b\"\\x01\" * 16, b\"gJ\\xfb{\\xb1Oi\\xc5sMC\\xb7\\xe4@\\xf7u\")\n\n    def test_verify_invalid(self, backend):\n        hkdf = HKDF(\n            hashes.SHA256(),\n            16,\n            salt=None,\n            info=None,\n            backend=backend\n        )\n\n        with pytest.raises(InvalidKey):\n            hkdf.verify(b\"\\x02\" * 16, b\"gJ\\xfb{\\xb1Oi\\xc5sMC\\xb7\\xe4@\\xf7u\")\n\n    def test_unicode_typeerror(self, backend):\n        with pytest.raises(TypeError):\n            HKDF(\n                hashes.SHA256(),\n                16,\n                salt=u\"foo\",\n                info=None,\n                backend=backend\n            )\n\n        with pytest.raises(TypeError):\n            HKDF(\n                hashes.SHA256(),\n                16,\n                salt=None,\n                info=u\"foo\",\n                backend=backend\n            )\n\n        with pytest.raises(TypeError):\n            hkdf = HKDF(\n                hashes.SHA256(),\n                16,\n                salt=None,\n                info=None,\n                backend=backend\n            )\n\n            hkdf.derive(u\"foo\")\n\n        with pytest.raises(TypeError):\n            hkdf = HKDF(\n                hashes.SHA256(),\n                16,\n                salt=None,\n                info=None,\n                backend=backend\n            )\n\n            hkdf.verify(u\"foo\", b\"bar\")\n\n        with pytest.raises(TypeError):\n            hkdf = HKDF(\n                hashes.SHA256(),\n                16,\n                salt=None,\n                info=None,\n                backend=backend\n            )\n\n            hkdf.verify(b\"foo\", u\"bar\")\n\n    def test_derive_short_output(self, backend):\n        hkdf = HKDF(\n            hashes.SHA256(),\n            4,\n            salt=None,\n            info=None,\n            backend=backend\n        )\n\n        assert hkdf.derive(b\"\\x01\" * 16) == b\"gJ\\xfb{\"\n\n\n@pytest.mark.requires_backend_interface(interface=HMACBackend)\nclass TestHKDFExpand(object):\n    def test_derive(self, backend):\n        prk = binascii.unhexlify(\n            b\"077709362c2e32df0ddc3f0dc47bba6390b6c73bb50f9c3122ec844ad7c2b3e5\"\n        )\n\n        okm = (b\"3cb25f25faacd57a90434f64d0362f2a2d2d0a90cf1a5a4c5db02d56ecc4c\"\n               b\"5bf34007208d5b887185865\")\n\n        info = binascii.unhexlify(b\"f0f1f2f3f4f5f6f7f8f9\")\n        hkdf = HKDFExpand(hashes.SHA256(), 42, info, backend)\n\n        assert binascii.hexlify(hkdf.derive(prk)) == okm\n\n    def test_verify(self, backend):\n        prk = binascii.unhexlify(\n            b\"077709362c2e32df0ddc3f0dc47bba6390b6c73bb50f9c3122ec844ad7c2b3e5\"\n        )\n\n        okm = (b\"3cb25f25faacd57a90434f64d0362f2a2d2d0a90cf1a5a4c5db02d56ecc4c\"\n               b\"5bf34007208d5b887185865\")\n\n        info = binascii.unhexlify(b\"f0f1f2f3f4f5f6f7f8f9\")\n        hkdf = HKDFExpand(hashes.SHA256(), 42, info, backend)\n\n        assert hkdf.verify(prk, binascii.unhexlify(okm)) is None\n\n    def test_invalid_verify(self, backend):\n        prk = binascii.unhexlify(\n            b\"077709362c2e32df0ddc3f0dc47bba6390b6c73bb50f9c3122ec844ad7c2b3e5\"\n        )\n\n        info = binascii.unhexlify(b\"f0f1f2f3f4f5f6f7f8f9\")\n        hkdf = HKDFExpand(hashes.SHA256(), 42, info, backend)\n\n        with pytest.raises(InvalidKey):\n            hkdf.verify(prk, b\"wrong key\")\n\n    def test_already_finalized(self, backend):\n        info = binascii.unhexlify(b\"f0f1f2f3f4f5f6f7f8f9\")\n        hkdf = HKDFExpand(hashes.SHA256(), 42, info, backend)\n\n        hkdf.derive(b\"first\")\n\n        with pytest.raises(AlreadyFinalized):\n            hkdf.derive(b\"second\")\n\n    def test_unicode_error(self, backend):\n        info = binascii.unhexlify(b\"f0f1f2f3f4f5f6f7f8f9\")\n        hkdf = HKDFExpand(hashes.SHA256(), 42, info, backend)\n\n        with pytest.raises(TypeError):\n            hkdf.derive(u\"first\")\n\n\ndef test_invalid_backend():\n    pretend_backend = object()\n\n    with raises_unsupported_algorithm(_Reasons.BACKEND_MISSING_INTERFACE):\n        HKDF(hashes.SHA256(), 16, None, None, pretend_backend)\n\n    with raises_unsupported_algorithm(_Reasons.BACKEND_MISSING_INTERFACE):\n        HKDFExpand(hashes.SHA256(), 16, None, pretend_backend)\n"], "filenames": ["src/cryptography/hazmat/primitives/kdf/hkdf.py", "tests/hazmat/primitives/test_hkdf.py"], "buggy_code_start_loc": [94, 144], "buggy_code_end_loc": [95, 144], "fixing_code_start_loc": [94, 145], "fixing_code_end_loc": [95, 156], "type": "CWE-20", "message": "HKDF in cryptography before 1.5.2 returns an empty byte-string if used with a length less than algorithm.digest_size.", "other": {"cve": {"id": "CVE-2016-9243", "sourceIdentifier": "secalert@redhat.com", "published": "2017-03-27T17:59:00.460", "lastModified": "2017-04-04T16:00:48.033", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "HKDF in cryptography before 1.5.2 returns an empty byte-string if used with a length less than algorithm.digest_size."}, {"lang": "es", "value": "HKDF en criptograf\u00eda en versiones anteriores a 1.5.2 devuelve una cadena de bytes vac\u00eda si se utiliza con una longitud inferior que algorithm.digest_size."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:cryptography.io:cryptography:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.5.2", "matchCriteriaId": "6F86E75C-3D06-496D-801F-DEACF47258D4"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:23:*:*:*:*:*:*:*", "matchCriteriaId": "E79AB8DD-C907-4038-A931-1A5A4CFB6A5B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:24:*:*:*:*:*:*:*", "matchCriteriaId": "C729D5D1-ED95-443A-9F53-5D7C2FD9B80C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:25:*:*:*:*:*:*:*", "matchCriteriaId": "772E9557-A371-4664-AE2D-4135AAEB89AA"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:lts:*:*:*", "matchCriteriaId": "F7016A2A-8365-4F1A-89A2-7A19F2BCAE5B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.10:*:*:*:*:*:*:*", "matchCriteriaId": "1AFB20FA-CB00-4729-AB3A-816454C6D096"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2016/11/09/2", "source": "secalert@redhat.com", "tags": ["Mailing List", "Patch", "VDB Entry"]}, {"url": "http://www.securityfocus.com/bid/94216", "source": "secalert@redhat.com", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "http://www.ubuntu.com/usn/USN-3138-1", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://cryptography.io/en/latest/changelog", "source": "secalert@redhat.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/pyca/cryptography/commit/b924696b2e8731f39696584d12cceeb3aeb2d874", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/pyca/cryptography/issues/3211", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/5R2ZOBMPWDFFHUZ6QOZZY36A6H5CGJXL/", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/U23KDR2M2N7W2ZSREG63BVW7D4VC6CIZ/", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/WQ5G7KHKZC4SI23JE7277KZXM57GEQKT/", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/pyca/cryptography/commit/b924696b2e8731f39696584d12cceeb3aeb2d874"}}