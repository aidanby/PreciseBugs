{"buggy_code": ["import Big from \"big.js\";\nimport { CacheMap } from \"./cachemap\";\nimport { Crypto } from \"./crypto\";\nimport { IValidSlpTxidParams, IValidSlpTxnParams } from \"./interfaces\";\nimport { Slp, SlpTransactionDetails, SlpTransactionType, SlpVersionType } from \"./slp\";\nimport { Transaction } from \"./transaction\";\n\nexport interface Validation {\n    validity: boolean|null;\n    parents: Parent[];\n    details: SlpTransactionDetails|null;\n    invalidReason: string|null;\n    waiting: boolean;\n}\n\nexport type GetRawTransactionAsync = (txid: string) => Promise<string|Buffer>;\n\nconst sleep = (ms: number) => new Promise(resolve => setTimeout(resolve, ms));\n\ninterface Parent {\n    txid: string;\n    vout: number;\n    versionType: number;\n    valid: boolean|null;\n    inputQty: Big|null;\n}\n\nexport class ValidatorType1 {\n    public cachedRawTransactions: CacheMap<string, Buffer>; // { [txid: string]: Buffer }\n    public cachedValidations: CacheMap<string, Validation>; // { [txid: string]: Validation }\n    public getRawTransaction: GetRawTransactionAsync;\n    public logger: { log: (s: string) => any };\n\n    constructor({ getRawTransaction, logger= console, maxTransactionCacheSize= 100000,\n                maxValidationCacheSize= 100000 }: { getRawTransaction: GetRawTransactionAsync, logger?:\n                    { log: (s: string) => any }, maxTransactionCacheSize?: number, maxValidationCacheSize?: number }) {\n        if (!getRawTransaction) {\n            throw Error(\"Must provide method getRawTransaction to class constructor.\");\n        }\n        this.logger = logger;\n        this.getRawTransaction = getRawTransaction;\n        this.cachedValidations = new CacheMap<string, Validation>(maxValidationCacheSize);\n        this.cachedRawTransactions = new CacheMap<string, Buffer>(maxTransactionCacheSize);\n    }\n\n    // WARNING: this method will be deprecated in next version\n    public addValidationFromStore(txnHex: string, isValid: boolean) {\n        const id = Crypto.HashTxid(Buffer.from(txnHex, \"hex\")).toString(\"hex\");\n        if (!this.cachedValidations.has(id)) {\n            this.cachedValidations.set(id,\n                { validity: isValid, parents: [], details: null, invalidReason: null, waiting: false });\n        }\n        if (!this.cachedRawTransactions.has(id)) {\n            this.cachedRawTransactions.set(id, Buffer.from(txnHex, \"hex\"));\n        }\n    }\n\n    public addValidTxnFromStore(txnHex: string) {\n        const id = Crypto.HashTxid(Buffer.from(txnHex, \"hex\")).toString(\"hex\");\n        if (!this.cachedValidations.has(id)) {\n            this.cachedValidations.set(id,\n            {\n                validity: true, \n                parents: [],\n                details: null,\n                invalidReason: null,\n                waiting: false \n            });\n        }\n        if (!this.cachedRawTransactions.has(id)) {\n            this.cachedRawTransactions.set(id, Buffer.from(txnHex, \"hex\"));\n        }\n    }\n\n    public addValidTxidFromStore(txidHex: string) {\n        if (!this.cachedValidations.has(txidHex)) {\n            this.cachedValidations.set(txidHex,\n            { \n                validity: true,\n                parents: [],\n                details: null,\n                invalidReason: null,\n                waiting: false\n            });\n        }\n    }\n\n    public async waitForCurrentValidationProcessing(txid: string) {\n        const cached: Validation = this.cachedValidations.get(txid)!;\n\n        if (!cached) {\n            throw Error(\"txid is missing from cachedValidations.\");\n        }\n\n        while (true) {\n            if (typeof cached.validity === \"boolean\") {\n                cached.waiting = false;\n                break;\n            }\n            await sleep(10);\n        }\n    }\n\n    public async waitForTransactionDownloadToComplete(txid: string) {\n        while (true) {\n            // @ts-ignore\n            if (this.cachedRawTransactions.get(txid)! && this.cachedRawTransactions.get(txid)! !== \"waiting\") {\n                break;\n            }\n            await sleep(10);\n        }\n    }\n\n    public async retrieveRawTransaction(txid: string) {\n        if (this.cachedRawTransactions.has(txid)) {\n            return this.cachedRawTransactions.get(txid)!;\n        }\n        // @ts-ignore\n        this.cachedRawTransactions.set(txid, \"waiting\");\n        const res = await this.getRawTransaction(txid);\n        if (typeof res === \"string\") {\n            this.cachedRawTransactions.set(txid, Buffer.from(res, \"hex\"));\n        } else {\n            this.cachedRawTransactions.set(txid, res);\n        }\n        if (this.cachedRawTransactions.has(txid)) {\n            if (this.cachedRawTransactions.get(txid)!.length < 60) {\n                throw Error(\"Valid transaction data not provided.\");\n            }\n            return this.cachedRawTransactions.get(txid)!;\n        }\n        throw Error(\"Transaction data not provided (null or undefined).\");\n    }\n\n    /**\n     * isValidSlpTxn\n     *\n     * Description:\n     * This public method can be use with SEND type transactions to prevent accidental\n     * of tokens having the same token ID.\n     *\n     * @param txn: hex string or buffer of the raw transaction to be validated\n     * @param tokenIdFilter: (optional) token id of the token that should be considered valid\n     * @param tokenTypeFilter: (optional) token type of the token that should be considered valid\n     * @param burnQuantity: (optional) quantity of token to be burned (for same token id)\n     *\n     * Notes/Warnings:\n     *   * This method does not yet check for burned inputs from another token IDs.\n     *   * This method does not yet check for proper burn quanity of NFT1 parent\n     *   * This method only works with SEND or type 0x01/0x81 GENESIS/MINT.\n     *   * Burning operations must be done using a valid SLP SEND OP_RETURN message.\n     */\n    public async isValidSlpTxn({ txn, tokenIdFilter, tokenTypeFilter, burnQuantity= Big(0) }: IValidSlpTxnParams):\n        Promise<boolean> {\n\n        let txid;\n        if (typeof txn === \"string\") {\n            const txnBuf = Buffer.from(txn, \"hex\");\n            txid = Crypto.HashTxid(txnBuf).toString(\"hex\");\n            this.cachedRawTransactions.set(txid, txnBuf);\n        } else {\n            txid = Crypto.HashTxid(txn).toString(\"hex\");\n            this.cachedRawTransactions.set(txid, txn);\n        }\n\n        const validity = await this.isValidSlpTxid({ txid, tokenIdFilter, tokenTypeFilter });\n        if (!validity) {\n            return validity;\n        }\n        const validation = this.cachedValidations.get(txid)!;\n        let validInputs: Big;\n        let outputs: Big;\n        const txnType = validation.details!.transactionType;\n\n        if (txnType === SlpTransactionType.SEND) {\n            outputs = validation.details!.sendOutputs!.reduce((p, c) => p.plus(c), Big(0));\n        } else if ([SlpTransactionType.GENESIS, SlpTransactionType.MINT].includes(txnType) &&\n                   (SlpVersionType.TokenVersionType1 ||\n                   SlpVersionType.TokenVersionType1_NFT_Parent)\n        ) {\n            return validity;\n        } else {\n            // This is here for NFT1 child type, since this method does not yet check accidental burning of NFT1 parent.\n            throw Error(\"[slp-validate] isValidSlpTxn() for this type of transaction is not yet implemented (use 'isValidSlpTxid' instead).\");\n        }\n\n        validInputs = validation.parents.map(p => p.inputQty ?\n                                                    p.inputQty :\n                                                    Big(0)).reduce((p, c) => p.plus(c), Big(0));\n\n        if (burnQuantity.eq(0)) {\n            if (!validInputs.eq(outputs)) {\n                throw Error(\"[slp-validate] Outputs do not match valid inputs\");\n            }\n        } else if (burnQuantity.gt(0)) {\n            if (!validInputs.minus(burnQuantity).eq(outputs)) {\n                throw Error(\"[slp-validate] Burn amount specified is not properly being burned in the provided transaction.\");\n            }\n        }\n\n        return validity;\n    }\n\n    /**\n     * isValidSlpTxid\n     *\n     * Description:\n     * This public method is used to determine validity of any type of token transaction\n     *\n     * @param txid: hex string or buffer of the raw transaction to be validated\n     * @param tokenIdFilter: (optional) token id of the token that should be considered valid\n     * @param tokenTypeFilter: (optional) token type of the token that should be considered valid\n     *\n     * Notes/Warnings:\n     *   * This method does not prevent burning, for burn prevention checking in SEND\n     *     use 'isValidSlpTxn()'.\n     *\n     */\n    public async isValidSlpTxid(\n        { txid, tokenIdFilter, tokenTypeFilter }: IValidSlpTxidParams): Promise<boolean> {\n        this.logger.log(\"[slp-validate] Validating: \" + txid);\n        const valid = await this._isValidSlpTxid(txid, tokenIdFilter, tokenTypeFilter);\n        this.logger.log(\"[slp-validate] Result: \" + valid + \" (\" + txid + \")\");\n        if (!valid && this.cachedValidations.get(txid)!.invalidReason) {\n            this.logger.log(\"[slp-validate] Invalid Reason: \" + this.cachedValidations.get(txid)!.invalidReason);\n        } else if (!valid) {\n            this.logger.log(\"[slp-validate] Invalid Reason: unknown (result is user supplied)\");\n }\n        return valid;\n    }\n\n    /**\n     * _isValidSlpTxid\n     *\n     * Description:\n     * This internal method uses recursion to do a Depth-First-Search with the node result being\n     * computed in Postorder Traversal (left/right/root) order.  A validation cache\n     * is used to keep track of the results for nodes that have already been evaluated.\n     *\n     * Each call to this method evaluates node validity with respect to\n     * its parent node(s), so it walks backwards until the\n     * validation cache provides a result or the GENESIS node is evaluated.\n     *\n     * Root nodes await the validation result of their upstream parent.\n     * In the case of NFT1 the search continues to the group/parent NFT DAG after the Genesis\n     * of the NFT child is discovered.\n     *\n     * @param txid: hex string or buffer of the raw transaction to be validated\n     * @param tokenIdFilter: (optional) token id of the token that should be considered valid\n     * @param tokenTypeFilter: (optional) token type of the token that should be considered valid\n     *\n     */\n    async _isValidSlpTxid(txid: string, tokenIdFilter?: string, tokenTypeFilter?: number): Promise<boolean> {\n        // Check to see if this txn has been processed by looking at shared cache, if doesn't exist then download txn.\n        if (!this.cachedValidations.has(txid)) {\n            this.cachedValidations.set(txid, {\n                details: null,\n                invalidReason: null,\n                parents: [],\n                validity: null,\n                waiting: false,\n            });\n            await this.retrieveRawTransaction(txid);\n        } else if (typeof this.cachedValidations.get(txid)!.validity === \"boolean\" &&\n                  !tokenIdFilter && !tokenTypeFilter) {\n            return this.cachedValidations.get(txid)!.validity!;\n        }\n\n        //\n        // Handle the case where neither branch of the previous if/else statement was\n        // executed and the raw transaction has never been downloaded.\n        //\n        // Also handle case where a 2nd request of same txid comes in\n        // during the download of a previous request.\n        //\n        // @ts-ignore\n        if (!this.cachedRawTransactions.get(txid)! || this.cachedRawTransactions.get(txid)! === \"waiting\") {\n            // @ts-ignore\n            if (this.cachedRawTransactions.get(txid)! !== \"waiting\") {\n                this.retrieveRawTransaction(txid);\n            }\n\n            // Wait for previously a initiated download to completed\n            await this.waitForTransactionDownloadToComplete(txid);\n        }\n\n        const validation = this.cachedValidations.get(txid)!;\n        const transaction = this.cachedRawTransactions.get(txid)!;\n\n        // Handle case where txid is already in the process of being validated from a previous call\n        if (validation.waiting) {\n            await this.waitForCurrentValidationProcessing(txid);\n            if (typeof validation.validity === \"boolean\" && !tokenIdFilter && !tokenTypeFilter) {\n                return validation.validity!;\n            }\n        }\n\n        validation.waiting = true;\n\n        // Check SLP message validity\n        const txn: Transaction = Transaction.parseFromBuffer(transaction);\n        let slpmsg: SlpTransactionDetails;\n        try {\n            slpmsg = validation.details = Slp.parseSlpOutputScript(txn.outputs[0].scriptPubKey);\n            if (slpmsg.transactionType === SlpTransactionType.GENESIS) {\n                slpmsg.tokenIdHex = txid;\n            }\n        } catch (e) {\n            validation.validity = false;\n            validation.waiting = false;\n            validation.invalidReason = \"SLP OP_RETURN parsing error (\" + e.message + \").\";\n            return validation.validity!;\n        }\n\n        // Check for tokenId filter\n        if (tokenIdFilter && slpmsg.tokenIdHex !== tokenIdFilter) {\n            validation.waiting = false;\n            validation.invalidReason = \"Validator was run with filter only considering tokenId \" + tokenIdFilter + \" as valid.\";\n            return false; // Don't save boolean result to cache incase cache is ever used without tokenIdFilter.\n        } else {\n            if (validation.validity !== false) {\n                validation.invalidReason = null;\n            }\n        }\n\n        // Check specified token type is being respected\n        if (tokenTypeFilter && slpmsg.versionType !== tokenTypeFilter) {\n            validation.validity = null;\n            validation.waiting = false;\n            validation.invalidReason = \"Validator was run with filter only considering token type: \" + tokenTypeFilter + \" as valid.\";\n            return false; // Don't save boolean result to cache incase cache is ever used with different token type.\n        } else {\n            if (validation.validity !== false) {\n                validation.invalidReason = null;\n            }\n        }\n\n        // Check DAG validity\n        if (slpmsg.transactionType === SlpTransactionType.GENESIS) {\n            // Check for NFT1 child (type 0x41)\n            if (slpmsg.versionType === 0x41) {\n                // An NFT1 parent should be provided at input index 0,\n                // so we check this first before checking the whole parent DAG\n                const inputTxid = txn.inputs[0].previousTxHash;\n                const inputTxHex = await this.retrieveRawTransaction(inputTxid);\n                const inputTx: Transaction = Transaction.parseFromBuffer(inputTxHex);\n                let inputSlpMsg;\n                try {\n                    inputSlpMsg = Slp.parseSlpOutputScript(inputTx.outputs[0].scriptPubKey);\n                } catch (_) {}\n                if (!inputSlpMsg || inputSlpMsg.versionType !== 0x81) {\n                    validation.validity = false;\n                    validation.waiting = false;\n                    validation.invalidReason = \"NFT1 child GENESIS does not have a valid NFT1 parent input.\";\n                    return validation.validity!;\n                }\n                // Check that the there is a burned output >0 in the parent txn SLP message\n                if (inputSlpMsg.transactionType === SlpTransactionType.SEND &&\n                    !inputSlpMsg.sendOutputs![1].gt(0)) {\n                    validation.validity = false;\n                    validation.waiting = false;\n                    validation.invalidReason = \"NFT1 child's parent has SLP output that is not greater than zero.\";\n                    return validation.validity!;\n                } else if ((inputSlpMsg.transactionType === SlpTransactionType.GENESIS ||\n                            inputSlpMsg.transactionType === SlpTransactionType.MINT) &&\n                            !inputSlpMsg.genesisOrMintQuantity!.gt(0)) {\n                    validation.validity = false;\n                    validation.waiting = false;\n                    validation.invalidReason = \"NFT1 child's parent has SLP output that is not greater than zero.\";\n                    return validation.validity!;\n                }\n                // Continue to check the NFT1 parent DAG\n                let nft_parent_dag_validity = await this.isValidSlpTxid({ txid: inputTxid, tokenIdFilter: undefined, tokenTypeFilter: 0x81 });\n                validation.validity = nft_parent_dag_validity;\n                validation.waiting = false;\n                if (!nft_parent_dag_validity) {\n                    validation.invalidReason = \"NFT1 child GENESIS does not have valid parent DAG.\";\n                }\n                return validation.validity!;\n            } else {\n                validation.validity = true;\n                validation.waiting = false;\n                return validation.validity!;\n            }\n        } else if (slpmsg.transactionType === SlpTransactionType.MINT) {\n            for (let i = 0; i < txn.inputs.length; i++) {\n                const inputTxid = txn.inputs[i].previousTxHash;\n                const inputTxHex = await this.retrieveRawTransaction(inputTxid);\n                const inputTx: Transaction = Transaction.parseFromBuffer(inputTxHex);\n                try {\n                    const inputSlpMsg = Slp.parseSlpOutputScript(inputTx.outputs[0].scriptPubKey);\n                    if (inputSlpMsg.transactionType === SlpTransactionType.GENESIS) {\n                        inputSlpMsg.tokenIdHex = inputTxid;\n                    }\n                    if (inputSlpMsg.tokenIdHex === slpmsg.tokenIdHex) {\n                        if (inputSlpMsg.transactionType === SlpTransactionType.GENESIS ||\n                            inputSlpMsg.transactionType === SlpTransactionType.MINT) {\n                            if (txn.inputs[i].previousTxOutIndex === inputSlpMsg.batonVout) {\n                                validation.parents.push({\n                                    txid: txn.inputs[i].previousTxHash,\n                                    vout: txn.inputs[i].previousTxOutIndex,\n                                    versionType: inputSlpMsg.versionType,\n                                    valid: null,\n                                    inputQty: null,\n                                });\n                            }\n                        }\n                    }\n                } catch (_) { }\n            }\n            if (validation.parents.length !== 1) {\n                validation.validity = false;\n                validation.waiting = false;\n                validation.invalidReason = \"MINT transaction must have 1 valid baton parent.\";\n                return validation.validity!;\n            }\n        } else if (slpmsg.transactionType === SlpTransactionType.SEND) {\n            const tokenOutQty = slpmsg.sendOutputs!.reduce((t, v) => t.plus(v), new Big(0));\n            let tokenInQty = new Big(0);\n            for (let i = 0; i < txn.inputs.length; i++) {\n                const inputTxid = txn.inputs[i].previousTxHash;\n                const inputTxHex = await this.retrieveRawTransaction(inputTxid);\n                const inputTx: Transaction = Transaction.parseFromBuffer(inputTxHex);\n                try {\n                    const inputSlpMsg = Slp.parseSlpOutputScript(inputTx.outputs[0].scriptPubKey);\n                    if (inputSlpMsg.transactionType === SlpTransactionType.GENESIS) {\n                        inputSlpMsg.tokenIdHex = inputTxid;\n                    }\n                    if (inputSlpMsg.tokenIdHex === slpmsg.tokenIdHex) {\n                        if (inputSlpMsg.transactionType === SlpTransactionType.SEND) {\n                            if (txn.inputs[i].previousTxOutIndex <= inputSlpMsg.sendOutputs!.length - 1) {\n                                tokenInQty = tokenInQty.plus(\n                                    inputSlpMsg.sendOutputs![txn.inputs[i].previousTxOutIndex]);\n                                validation.parents.push({\n                                    txid: txn.inputs[i].previousTxHash,\n                                    vout: txn.inputs[i].previousTxOutIndex,\n                                    versionType: inputSlpMsg.versionType,\n                                    valid: null,\n                                    inputQty: inputSlpMsg.sendOutputs![txn.inputs[i].previousTxOutIndex],\n                                });\n                            }\n                        } else if (inputSlpMsg.transactionType === SlpTransactionType.GENESIS ||\n                                   inputSlpMsg.transactionType === SlpTransactionType.MINT) {\n                            if (txn.inputs[i].previousTxOutIndex === 1) {\n                                tokenInQty = tokenInQty.plus(inputSlpMsg.genesisOrMintQuantity!);\n                                validation.parents.push({\n                                    txid: txn.inputs[i].previousTxHash,\n                                    vout: txn.inputs[i].previousTxOutIndex,\n                                    versionType: inputSlpMsg.versionType,\n                                    valid: null,\n                                    inputQty: inputSlpMsg.genesisOrMintQuantity,\n                                });\n                            }\n                        }\n                    }\n                } catch (_) { }\n            }\n\n            // Check token inputs are greater than token outputs (includes valid and invalid inputs)\n            if (tokenOutQty.gt(tokenInQty)) {\n                validation.validity = false;\n                validation.waiting = false;\n                validation.invalidReason = \"Token outputs are greater than possible token inputs.\";\n                return validation.validity!;\n            }\n        }\n\n        // Set validity validation-cache for parents, and handle MINT condition with no valid input\n        // we don't need to check proper token id since we only added parents with same ID in above steps.\n        const parentTxids = [...new Set(validation.parents.map(p => p.txid))];\n        for (let i = 0; i < parentTxids.length; i++) {\n            const valid = await this.isValidSlpTxid({ txid: parentTxids[i] });\n            validation.parents.filter(p => p.txid === parentTxids[i]).map(p => p.valid = valid);\n            if (validation.details!.transactionType === SlpTransactionType.MINT && !valid) {\n                validation.validity = false;\n                validation.waiting = false;\n                validation.invalidReason = \"MINT transaction with invalid baton parent.\";\n                return validation.validity!;\n            }\n        }\n\n        // Check valid inputs are greater than token outputs\n        if (validation.details!.transactionType === SlpTransactionType.SEND) {\n            const validInputQty = validation.parents.reduce((t, v) => v.valid ? t.plus(v.inputQty!) : t, new Big(0));\n            const tokenOutQty = slpmsg.sendOutputs!.reduce((t, v) => t.plus(v), new Big(0));\n            if (tokenOutQty.gt(validInputQty)) {\n                validation.validity = false;\n                validation.waiting = false;\n                validation.invalidReason = \"Token outputs are greater than valid token inputs.\";\n                return validation.validity!;\n            }\n        }\n\n        // Check versionType is not different from valid parents\n        if (validation.parents.filter(p => p.valid).length > 0) {\n            const validVersionType = validation.parents.find(p => p.valid!)!.versionType;\n            if (validation.details!.versionType !== validVersionType) {\n                validation.validity = false;\n                validation.waiting = false;\n                validation.invalidReason = \"SLP version/type mismatch from valid parent.\";\n                return validation.validity!;\n            }\n        }\n        validation.validity = true;\n        validation.waiting = false;\n        return validation.validity!;\n    }\n\n    public async validateSlpTransactions(txids: string[]): Promise<string[]> {\n        const res = [];\n        for (const txid of txids) {\n            res.push((await this.isValidSlpTxid({ txid })) ? txid : \"\");\n        }\n        return res.filter((id: string) => id.length > 0);\n    }\n}\n"], "fixing_code": ["import Big from \"big.js\";\nimport { CacheMap } from \"./cachemap\";\nimport { Crypto } from \"./crypto\";\nimport { IValidSlpTxidParams, IValidSlpTxnParams } from \"./interfaces\";\nimport { Slp, SlpTransactionDetails, SlpTransactionType, SlpVersionType } from \"./slp\";\nimport { Transaction } from \"./transaction\";\n\nexport interface Validation {\n    validity: boolean|null;\n    parents: Parent[];\n    details: SlpTransactionDetails|null;\n    invalidReason: string|null;\n    waiting: boolean;\n}\n\nexport type GetRawTransactionAsync = (txid: string) => Promise<string|Buffer>;\n\nconst sleep = (ms: number) => new Promise(resolve => setTimeout(resolve, ms));\n\ninterface Parent {\n    txid: string;\n    vout: number;\n    versionType: number;\n    valid: boolean|null;\n    inputQty: Big|null;\n}\n\nexport class ValidatorType1 {\n    public cachedRawTransactions: CacheMap<string, Buffer>; // { [txid: string]: Buffer }\n    public cachedValidations: CacheMap<string, Validation>; // { [txid: string]: Validation }\n    public getRawTransaction: GetRawTransactionAsync;\n    public logger: { log: (s: string) => any };\n\n    constructor({ getRawTransaction, logger= console, maxTransactionCacheSize= 100000,\n                maxValidationCacheSize= 100000 }: { getRawTransaction: GetRawTransactionAsync, logger?:\n                    { log: (s: string) => any }, maxTransactionCacheSize?: number, maxValidationCacheSize?: number }) {\n        if (!getRawTransaction) {\n            throw Error(\"Must provide method getRawTransaction to class constructor.\");\n        }\n        this.logger = logger;\n        this.getRawTransaction = getRawTransaction;\n        this.cachedValidations = new CacheMap<string, Validation>(maxValidationCacheSize);\n        this.cachedRawTransactions = new CacheMap<string, Buffer>(maxTransactionCacheSize);\n    }\n\n    // WARNING: this method will be deprecated in next version\n    public addValidationFromStore(txnHex: string, isValid: boolean) {\n        const id = Crypto.HashTxid(Buffer.from(txnHex, \"hex\")).toString(\"hex\");\n        if (!this.cachedValidations.has(id)) {\n            this.cachedValidations.set(id,\n                { validity: isValid, parents: [], details: null, invalidReason: null, waiting: false });\n        }\n        if (!this.cachedRawTransactions.has(id)) {\n            this.cachedRawTransactions.set(id, Buffer.from(txnHex, \"hex\"));\n        }\n    }\n\n    public addValidTxnFromStore(txnHex: string) {\n        const id = Crypto.HashTxid(Buffer.from(txnHex, \"hex\")).toString(\"hex\");\n        if (!this.cachedValidations.has(id)) {\n            this.cachedValidations.set(id,\n            {\n                validity: true, \n                parents: [],\n                details: null,\n                invalidReason: null,\n                waiting: false \n            });\n        }\n        if (!this.cachedRawTransactions.has(id)) {\n            this.cachedRawTransactions.set(id, Buffer.from(txnHex, \"hex\"));\n        }\n    }\n\n    public addValidTxidFromStore(txidHex: string) {\n        if (!this.cachedValidations.has(txidHex)) {\n            this.cachedValidations.set(txidHex,\n            { \n                validity: true,\n                parents: [],\n                details: null,\n                invalidReason: null,\n                waiting: false\n            });\n        }\n    }\n\n    public async waitForCurrentValidationProcessing(txid: string) {\n        const cached: Validation = this.cachedValidations.get(txid)!;\n\n        if (!cached) {\n            throw Error(\"txid is missing from cachedValidations.\");\n        }\n\n        while (true) {\n            if (typeof cached.validity === \"boolean\") {\n                cached.waiting = false;\n                break;\n            }\n            await sleep(10);\n        }\n    }\n\n    public async waitForTransactionDownloadToComplete(txid: string) {\n        while (true) {\n            // @ts-ignore\n            if (this.cachedRawTransactions.get(txid)! && this.cachedRawTransactions.get(txid)! !== \"waiting\") {\n                break;\n            }\n            await sleep(10);\n        }\n    }\n\n    public async retrieveRawTransaction(txid: string) {\n        if (this.cachedRawTransactions.has(txid)) {\n            return this.cachedRawTransactions.get(txid)!;\n        }\n        // @ts-ignore\n        this.cachedRawTransactions.set(txid, \"waiting\");\n        const res = await this.getRawTransaction(txid);\n        if (typeof res === \"string\") {\n            this.cachedRawTransactions.set(txid, Buffer.from(res, \"hex\"));\n        } else {\n            this.cachedRawTransactions.set(txid, res);\n        }\n        if (this.cachedRawTransactions.has(txid)) {\n            if (this.cachedRawTransactions.get(txid)!.length < 60) {\n                throw Error(\"Valid transaction data not provided.\");\n            }\n            return this.cachedRawTransactions.get(txid)!;\n        }\n        throw Error(\"Transaction data not provided (null or undefined).\");\n    }\n\n    /**\n     * isValidSlpTxn\n     *\n     * Description:\n     * This public method can be use with SEND type transactions to prevent accidental\n     * of tokens having the same token ID.\n     *\n     * @param txn: hex string or buffer of the raw transaction to be validated\n     * @param tokenIdFilter: (optional) token id of the token that should be considered valid\n     * @param tokenTypeFilter: (optional) token type of the token that should be considered valid\n     * @param burnQuantity: (optional) quantity of token to be burned (for same token id)\n     *\n     * Notes/Warnings:\n     *   * This method does not yet check for burned inputs from another token IDs.\n     *   * This method does not yet check for proper burn quanity of NFT1 parent\n     *   * This method only works with SEND or type 0x01/0x81 GENESIS/MINT.\n     *   * Burning operations must be done using a valid SLP SEND OP_RETURN message.\n     */\n    public async isValidSlpTxn({ txn, tokenIdFilter, tokenTypeFilter, burnQuantity= Big(0) }: IValidSlpTxnParams):\n        Promise<boolean> {\n\n        let txid;\n        if (typeof txn === \"string\") {\n            const txnBuf = Buffer.from(txn, \"hex\");\n            txid = Crypto.HashTxid(txnBuf).toString(\"hex\");\n            this.cachedRawTransactions.set(txid, txnBuf);\n        } else {\n            txid = Crypto.HashTxid(txn).toString(\"hex\");\n            this.cachedRawTransactions.set(txid, txn);\n        }\n\n        const validity = await this.isValidSlpTxid({ txid, tokenIdFilter, tokenTypeFilter });\n        if (!validity) {\n            return validity;\n        }\n        const validation = this.cachedValidations.get(txid)!;\n        let validInputs: Big;\n        let outputs: Big;\n        const txnType = validation.details!.transactionType;\n\n        if (txnType === SlpTransactionType.SEND) {\n            outputs = validation.details!.sendOutputs!.reduce((p, c) => p.plus(c), Big(0));\n        } else if ([SlpTransactionType.GENESIS, SlpTransactionType.MINT].includes(txnType) &&\n                   (SlpVersionType.TokenVersionType1 ||\n                   SlpVersionType.TokenVersionType1_NFT_Parent)\n        ) {\n            return validity;\n        } else {\n            // This is here for NFT1 child type, since this method does not yet check accidental burning of NFT1 parent.\n            throw Error(\"[slp-validate] isValidSlpTxn() for this type of transaction is not yet implemented (use 'isValidSlpTxid' instead).\");\n        }\n\n        validInputs = validation.parents.map(p => p.inputQty ?\n                                                    p.inputQty :\n                                                    Big(0)).reduce((p, c) => p.plus(c), Big(0));\n\n        if (burnQuantity.eq(0)) {\n            if (!validInputs.eq(outputs)) {\n                throw Error(\"[slp-validate] Outputs do not match valid inputs\");\n            }\n        } else if (burnQuantity.gt(0)) {\n            if (!validInputs.minus(burnQuantity).eq(outputs)) {\n                throw Error(\"[slp-validate] Burn amount specified is not properly being burned in the provided transaction.\");\n            }\n        }\n\n        return validity;\n    }\n\n    /**\n     * isValidSlpTxid\n     *\n     * Description:\n     * This public method is used to determine validity of any type of token transaction\n     *\n     * @param txid: hex string or buffer of the raw transaction to be validated\n     * @param tokenIdFilter: (optional) token id of the token that should be considered valid\n     * @param tokenTypeFilter: (optional) token type of the token that should be considered valid\n     *\n     * Notes/Warnings:\n     *   * This method does not prevent burning, for burn prevention checking in SEND\n     *     use 'isValidSlpTxn()'.\n     *\n     */\n    public async isValidSlpTxid(\n        { txid, tokenIdFilter, tokenTypeFilter }: IValidSlpTxidParams): Promise<boolean> {\n        this.logger.log(\"[slp-validate] Validating: \" + txid);\n        const valid = await this._isValidSlpTxid(txid, tokenIdFilter, tokenTypeFilter);\n        this.logger.log(\"[slp-validate] Result: \" + valid + \" (\" + txid + \")\");\n        if (!valid && this.cachedValidations.get(txid)!.invalidReason) {\n            this.logger.log(\"[slp-validate] Invalid Reason: \" + this.cachedValidations.get(txid)!.invalidReason);\n        } else if (!valid) {\n            this.logger.log(\"[slp-validate] Invalid Reason: unknown (result is user supplied)\");\n }\n        return valid;\n    }\n\n    /**\n     * _isValidSlpTxid\n     *\n     * Description:\n     * This internal method uses recursion to do a Depth-First-Search with the node result being\n     * computed in Postorder Traversal (left/right/root) order.  A validation cache\n     * is used to keep track of the results for nodes that have already been evaluated.\n     *\n     * Each call to this method evaluates node validity with respect to\n     * its parent node(s), so it walks backwards until the\n     * validation cache provides a result or the GENESIS node is evaluated.\n     *\n     * Root nodes await the validation result of their upstream parent.\n     * In the case of NFT1 the search continues to the group/parent NFT DAG after the Genesis\n     * of the NFT child is discovered.\n     *\n     * @param txid: hex string or buffer of the raw transaction to be validated\n     * @param tokenIdFilter: (optional) token id of the token that should be considered valid\n     * @param tokenTypeFilter: (optional) token type of the token that should be considered valid\n     *\n     */\n    async _isValidSlpTxid(txid: string, tokenIdFilter?: string, tokenTypeFilter?: number): Promise<boolean> {\n        // Check to see if this txn has been processed by looking at shared cache, if doesn't exist then download txn.\n        if (!this.cachedValidations.has(txid)) {\n            this.cachedValidations.set(txid, {\n                details: null,\n                invalidReason: null,\n                parents: [],\n                validity: null,\n                waiting: false,\n            });\n            await this.retrieveRawTransaction(txid);\n        } else if (typeof this.cachedValidations.get(txid)!.validity === \"boolean\" &&\n                  !tokenIdFilter && !tokenTypeFilter) {\n            return this.cachedValidations.get(txid)!.validity!;\n        }\n\n        //\n        // Handle the case where neither branch of the previous if/else statement was\n        // executed and the raw transaction has never been downloaded.\n        //\n        // Also handle case where a 2nd request of same txid comes in\n        // during the download of a previous request.\n        //\n        // @ts-ignore\n        if (!this.cachedRawTransactions.get(txid)! || this.cachedRawTransactions.get(txid)! === \"waiting\") {\n            // @ts-ignore\n            if (this.cachedRawTransactions.get(txid)! !== \"waiting\") {\n                this.retrieveRawTransaction(txid);\n            }\n\n            // Wait for previously a initiated download to completed\n            await this.waitForTransactionDownloadToComplete(txid);\n        }\n\n        const validation = this.cachedValidations.get(txid)!;\n        const transaction = this.cachedRawTransactions.get(txid)!;\n\n        // Handle case where txid is already in the process of being validated from a previous call\n        if (validation.waiting) {\n            await this.waitForCurrentValidationProcessing(txid);\n            if (typeof validation.validity === \"boolean\" && !tokenIdFilter && !tokenTypeFilter) {\n                return validation.validity!;\n            }\n        }\n\n        validation.waiting = true;\n\n        // Check SLP message validity\n        const txn: Transaction = Transaction.parseFromBuffer(transaction);\n        let slpmsg: SlpTransactionDetails;\n        try {\n            slpmsg = validation.details = Slp.parseSlpOutputScript(txn.outputs[0].scriptPubKey);\n            if (slpmsg.transactionType === SlpTransactionType.GENESIS) {\n                slpmsg.tokenIdHex = txid;\n            }\n        } catch (e) {\n            validation.validity = false;\n            validation.waiting = false;\n            validation.invalidReason = \"SLP OP_RETURN parsing error (\" + e.message + \").\";\n            return validation.validity!;\n        }\n\n        // Check for tokenId filter\n        if (tokenIdFilter && slpmsg.tokenIdHex !== tokenIdFilter) {\n            validation.waiting = false;\n            validation.invalidReason = \"Validator was run with filter only considering tokenId \" + tokenIdFilter + \" as valid.\";\n            return false; // Don't save boolean result to cache incase cache is ever used without tokenIdFilter.\n        } else {\n            if (validation.validity !== false) {\n                validation.invalidReason = null;\n            }\n        }\n\n        // Check specified token type is being respected\n        if (tokenTypeFilter && slpmsg.versionType !== tokenTypeFilter) {\n            validation.validity = null;\n            validation.waiting = false;\n            validation.invalidReason = \"Validator was run with filter only considering token type: \" + tokenTypeFilter + \" as valid.\";\n            return false; // Don't save boolean result to cache incase cache is ever used with different token type.\n        } else {\n            if (validation.validity !== false) {\n                validation.invalidReason = null;\n            }\n        }\n\n        // Check DAG validity\n        if (slpmsg.transactionType === SlpTransactionType.GENESIS) {\n            // Check for NFT1 child (type 0x41)\n            if (slpmsg.versionType === 0x41) {\n                // An NFT1 parent should be provided at input index 0,\n                // so we check this first before checking the whole parent DAG\n                const inputTxid = txn.inputs[0].previousTxHash;\n                const inputTxHex = await this.retrieveRawTransaction(inputTxid);\n                const inputTx: Transaction = Transaction.parseFromBuffer(inputTxHex);\n                let inputSlpMsg;\n                try {\n                    inputSlpMsg = Slp.parseSlpOutputScript(inputTx.outputs[0].scriptPubKey);\n                } catch (_) {}\n                if (!inputSlpMsg || inputSlpMsg.versionType !== 0x81) {\n                    validation.validity = false;\n                    validation.waiting = false;\n                    validation.invalidReason = \"NFT1 child GENESIS does not have a valid NFT1 parent input.\";\n                    return validation.validity!;\n                }\n                // Check that the there is a burned output >0 in the parent txn SLP message\n                if (inputSlpMsg.transactionType === SlpTransactionType.SEND &&\n                    !inputSlpMsg.sendOutputs![1].gt(0)) {\n                    validation.validity = false;\n                    validation.waiting = false;\n                    validation.invalidReason = \"NFT1 child's parent has SLP output that is not greater than zero.\";\n                    return validation.validity!;\n                } else if ((inputSlpMsg.transactionType === SlpTransactionType.GENESIS ||\n                            inputSlpMsg.transactionType === SlpTransactionType.MINT) &&\n                            !inputSlpMsg.genesisOrMintQuantity!.gt(0)) {\n                    validation.validity = false;\n                    validation.waiting = false;\n                    validation.invalidReason = \"NFT1 child's parent has SLP output that is not greater than zero.\";\n                    return validation.validity!;\n                }\n                // Continue to check the NFT1 parent DAG\n                let nft_parent_dag_validity = await this.isValidSlpTxid({ txid: inputTxid, tokenIdFilter: undefined, tokenTypeFilter: 0x81 });\n                validation.validity = nft_parent_dag_validity;\n                validation.waiting = false;\n                if (!nft_parent_dag_validity) {\n                    validation.invalidReason = \"NFT1 child GENESIS does not have valid parent DAG.\";\n                }\n                return validation.validity!;\n            } else {\n                validation.validity = true;\n                validation.waiting = false;\n                return validation.validity!;\n            }\n        } else if (slpmsg.transactionType === SlpTransactionType.MINT) {\n            for (let i = 0; i < txn.inputs.length; i++) {\n                const inputTxid = txn.inputs[i].previousTxHash;\n                const inputTxHex = await this.retrieveRawTransaction(inputTxid);\n                const inputTx: Transaction = Transaction.parseFromBuffer(inputTxHex);\n                try {\n                    const inputSlpMsg = Slp.parseSlpOutputScript(inputTx.outputs[0].scriptPubKey);\n                    if (inputSlpMsg.transactionType === SlpTransactionType.GENESIS) {\n                        inputSlpMsg.tokenIdHex = inputTxid;\n                    }\n                    if (inputSlpMsg.tokenIdHex === slpmsg.tokenIdHex) {\n                        if (inputSlpMsg.transactionType === SlpTransactionType.GENESIS ||\n                            inputSlpMsg.transactionType === SlpTransactionType.MINT) {\n                            if (txn.inputs[i].previousTxOutIndex === inputSlpMsg.batonVout) {\n                                validation.parents.push({\n                                    txid: txn.inputs[i].previousTxHash,\n                                    vout: txn.inputs[i].previousTxOutIndex,\n                                    versionType: inputSlpMsg.versionType,\n                                    valid: null,\n                                    inputQty: null,\n                                });\n                            }\n                        }\n                    }\n                } catch (_) { }\n            }\n            if (validation.parents.length < 1) {\n                validation.validity = false;\n                validation.waiting = false;\n                validation.invalidReason = \"MINT transaction must have at least 1 candidate baton parent input.\";\n                return validation.validity!;\n            }\n        } else if (slpmsg.transactionType === SlpTransactionType.SEND) {\n            const tokenOutQty = slpmsg.sendOutputs!.reduce((t, v) => t.plus(v), new Big(0));\n            let tokenInQty = new Big(0);\n            for (let i = 0; i < txn.inputs.length; i++) {\n                const inputTxid = txn.inputs[i].previousTxHash;\n                const inputTxHex = await this.retrieveRawTransaction(inputTxid);\n                const inputTx: Transaction = Transaction.parseFromBuffer(inputTxHex);\n                try {\n                    const inputSlpMsg = Slp.parseSlpOutputScript(inputTx.outputs[0].scriptPubKey);\n                    if (inputSlpMsg.transactionType === SlpTransactionType.GENESIS) {\n                        inputSlpMsg.tokenIdHex = inputTxid;\n                    }\n                    if (inputSlpMsg.tokenIdHex === slpmsg.tokenIdHex) {\n                        if (inputSlpMsg.transactionType === SlpTransactionType.SEND) {\n                            if (txn.inputs[i].previousTxOutIndex <= inputSlpMsg.sendOutputs!.length - 1) {\n                                tokenInQty = tokenInQty.plus(\n                                    inputSlpMsg.sendOutputs![txn.inputs[i].previousTxOutIndex]);\n                                validation.parents.push({\n                                    txid: txn.inputs[i].previousTxHash,\n                                    vout: txn.inputs[i].previousTxOutIndex,\n                                    versionType: inputSlpMsg.versionType,\n                                    valid: null,\n                                    inputQty: inputSlpMsg.sendOutputs![txn.inputs[i].previousTxOutIndex],\n                                });\n                            }\n                        } else if (inputSlpMsg.transactionType === SlpTransactionType.GENESIS ||\n                                   inputSlpMsg.transactionType === SlpTransactionType.MINT) {\n                            if (txn.inputs[i].previousTxOutIndex === 1) {\n                                tokenInQty = tokenInQty.plus(inputSlpMsg.genesisOrMintQuantity!);\n                                validation.parents.push({\n                                    txid: txn.inputs[i].previousTxHash,\n                                    vout: txn.inputs[i].previousTxOutIndex,\n                                    versionType: inputSlpMsg.versionType,\n                                    valid: null,\n                                    inputQty: inputSlpMsg.genesisOrMintQuantity,\n                                });\n                            }\n                        }\n                    }\n                } catch (_) { }\n            }\n\n            // Check token inputs are greater than token outputs (includes valid and invalid inputs)\n            if (tokenOutQty.gt(tokenInQty)) {\n                validation.validity = false;\n                validation.waiting = false;\n                validation.invalidReason = \"Token outputs are greater than possible token inputs.\";\n                return validation.validity!;\n            }\n        }\n\n        // Set validity validation-cache for parents, and handle MINT condition with no valid input\n        // we don't need to check proper token id since we only added parents with same ID in above steps.\n        const parentTxids = [...new Set(validation.parents.map(p => p.txid))];\n        for (const id of parentTxids) {\n            const valid = await this.isValidSlpTxid({ txid: id });\n            validation.parents.filter(p => p.txid === id).map(p => p.valid = valid);\n        }\n\n        // Check MINT for exactly 1 valid MINT baton\n        if (validation.details!.transactionType === SlpTransactionType.MINT) {\n            if (validation.parents.filter(p => p.valid && p.inputQty === null).length !== 1) {\n                validation.validity = false;\n                validation.waiting = false;\n                validation.invalidReason = \"MINT transaction with invalid baton parent.\";\n                return validation.validity!;\n            }\n        }\n\n        // Check valid inputs are greater than token outputs\n        if (validation.details!.transactionType === SlpTransactionType.SEND) {\n            const validInputQty = validation.parents.reduce((t, v) => v.valid ? t.plus(v.inputQty!) : t, new Big(0));\n            const tokenOutQty = slpmsg.sendOutputs!.reduce((t, v) => t.plus(v), new Big(0));\n            if (tokenOutQty.gt(validInputQty)) {\n                validation.validity = false;\n                validation.waiting = false;\n                validation.invalidReason = \"Token outputs are greater than valid token inputs.\";\n                return validation.validity!;\n            }\n        }\n\n        // Check versionType is not different from valid parents\n        if (validation.parents.filter(p => p.valid).length > 0) {\n            const validVersionType = validation.parents.find(p => p.valid!)!.versionType;\n            if (validation.details!.versionType !== validVersionType) {\n                validation.validity = false;\n                validation.waiting = false;\n                validation.invalidReason = \"SLP version/type mismatch from valid parent.\";\n                return validation.validity!;\n            }\n        }\n        validation.validity = true;\n        validation.waiting = false;\n        return validation.validity!;\n    }\n\n    public async validateSlpTransactions(txids: string[]): Promise<string[]> {\n        const res = [];\n        for (const txid of txids) {\n            res.push((await this.isValidSlpTxid({ txid })) ? txid : \"\");\n        }\n        return res.filter((id: string) => id.length > 0);\n    }\n}\n"], "filenames": ["lib/validation.ts"], "buggy_code_start_loc": [411], "buggy_code_end_loc": [475], "fixing_code_start_loc": [411], "fixing_code_end_loc": [479], "type": "CWE-697", "message": "In SLP Validate (npm package slp-validate) before version 1.2.1, users could experience false-negative validation outcomes for MINT transaction operations. A poorly implemented SLP wallet could allow spending of the affected tokens which would result in the destruction of a user's minting baton. This has been fixed in slp-validate in version 1.2.1. Additonally, slpjs version 0.27.2 has a related fix under related CVE-2020-11071.", "other": {"cve": {"id": "CVE-2020-11072", "sourceIdentifier": "security-advisories@github.com", "published": "2020-05-12T01:15:11.213", "lastModified": "2020-05-19T16:04:53.063", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In SLP Validate (npm package slp-validate) before version 1.2.1, users could experience false-negative validation outcomes for MINT transaction operations. A poorly implemented SLP wallet could allow spending of the affected tokens which would result in the destruction of a user's minting baton. This has been fixed in slp-validate in version 1.2.1. Additonally, slpjs version 0.27.2 has a related fix under related CVE-2020-11071."}, {"lang": "es", "value": "En SLP Validate (paquete slp-validate de npm) versiones anteriores a 1.2.1, los usuarios pod\u00edan experimentar resultados de comprobaci\u00f3n falsos negativos para operaciones de transacci\u00f3n MINT. Una billetera SLP mal implementada podr\u00eda permitir el gasto de los tokens afectados, lo cual resultar\u00eda en la destrucci\u00f3n del minting baton del usuario. Esto ha sido corregido en slp-validate en la versi\u00f3n 1.2.1. Adem\u00e1s, slpjs versi\u00f3n 0.27.2 presenta una correcci\u00f3n relacionada bajo el CVE-2020-11071 relacionado."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 8.6, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 4.0}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 8.6, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 4.0}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-697"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-697"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:simpleledger:slp-validate:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.2.1", "matchCriteriaId": "4A590BD4-A698-4851-843E-7B0E2C9E85FC"}]}]}], "references": [{"url": "https://github.com/simpleledger/slp-validate/commit/cde95c0c6470dceb4f023cd462f904135ebd73e7", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/simpleledger/slp-validate/security/advisories/GHSA-4w97-57v2-3w44", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/simpleledger/slp-validate/commit/cde95c0c6470dceb4f023cd462f904135ebd73e7"}}