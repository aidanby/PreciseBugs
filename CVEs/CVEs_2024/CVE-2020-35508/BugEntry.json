{"buggy_code": ["// SPDX-License-Identifier: GPL-2.0-only\n/*\n *  linux/kernel/fork.c\n *\n *  Copyright (C) 1991, 1992  Linus Torvalds\n */\n\n/*\n *  'fork.c' contains the help-routines for the 'fork' system call\n * (see also entry.S and others).\n * Fork is rather simple, once you get the hang of it, but the memory\n * management can be a bitch. See 'mm/memory.c': 'copy_page_range()'\n */\n\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/user.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/task.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/cputime.h>\n#include <linux/seq_file.h>\n#include <linux/rtmutex.h>\n#include <linux/init.h>\n#include <linux/unistd.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/completion.h>\n#include <linux/personality.h>\n#include <linux/mempolicy.h>\n#include <linux/sem.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/iocontext.h>\n#include <linux/key.h>\n#include <linux/binfmts.h>\n#include <linux/mman.h>\n#include <linux/mmu_notifier.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/vmacache.h>\n#include <linux/nsproxy.h>\n#include <linux/capability.h>\n#include <linux/cpu.h>\n#include <linux/cgroup.h>\n#include <linux/security.h>\n#include <linux/hugetlb.h>\n#include <linux/seccomp.h>\n#include <linux/swap.h>\n#include <linux/syscalls.h>\n#include <linux/jiffies.h>\n#include <linux/futex.h>\n#include <linux/compat.h>\n#include <linux/kthread.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/rcupdate.h>\n#include <linux/ptrace.h>\n#include <linux/mount.h>\n#include <linux/audit.h>\n#include <linux/memcontrol.h>\n#include <linux/ftrace.h>\n#include <linux/proc_fs.h>\n#include <linux/profile.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/acct.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/tsacct_kern.h>\n#include <linux/cn_proc.h>\n#include <linux/freezer.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/random.h>\n#include <linux/tty.h>\n#include <linux/blkdev.h>\n#include <linux/fs_struct.h>\n#include <linux/magic.h>\n#include <linux/perf_event.h>\n#include <linux/posix-timers.h>\n#include <linux/user-return-notifier.h>\n#include <linux/oom.h>\n#include <linux/khugepaged.h>\n#include <linux/signalfd.h>\n#include <linux/uprobes.h>\n#include <linux/aio.h>\n#include <linux/compiler.h>\n#include <linux/sysctl.h>\n#include <linux/kcov.h>\n#include <linux/livepatch.h>\n#include <linux/thread_info.h>\n#include <linux/stackleak.h>\n#include <linux/kasan.h>\n#include <linux/scs.h>\n#include <linux/io_uring.h>\n\n#include <asm/pgalloc.h>\n#include <linux/uaccess.h>\n#include <asm/mmu_context.h>\n#include <asm/cacheflush.h>\n#include <asm/tlbflush.h>\n\n#include <trace/events/sched.h>\n\n#define CREATE_TRACE_POINTS\n#include <trace/events/task.h>\n\n/*\n * Minimum number of threads to boot the kernel\n */\n#define MIN_THREADS 20\n\n/*\n * Maximum number of threads\n */\n#define MAX_THREADS FUTEX_TID_MASK\n\n/*\n * Protected counters by write_lock_irq(&tasklist_lock)\n */\nunsigned long total_forks;\t/* Handle normal Linux uptimes. */\nint nr_threads;\t\t\t/* The idle threads do not count.. */\n\nstatic int max_threads;\t\t/* tunable limit on nr_threads */\n\n#define NAMED_ARRAY_INDEX(x)\t[x] = __stringify(x)\n\nstatic const char * const resident_page_types[] = {\n\tNAMED_ARRAY_INDEX(MM_FILEPAGES),\n\tNAMED_ARRAY_INDEX(MM_ANONPAGES),\n\tNAMED_ARRAY_INDEX(MM_SWAPENTS),\n\tNAMED_ARRAY_INDEX(MM_SHMEMPAGES),\n};\n\nDEFINE_PER_CPU(unsigned long, process_counts) = 0;\n\n__cacheline_aligned DEFINE_RWLOCK(tasklist_lock);  /* outer */\n\n#ifdef CONFIG_PROVE_RCU\nint lockdep_tasklist_lock_is_held(void)\n{\n\treturn lockdep_is_held(&tasklist_lock);\n}\nEXPORT_SYMBOL_GPL(lockdep_tasklist_lock_is_held);\n#endif /* #ifdef CONFIG_PROVE_RCU */\n\nint nr_processes(void)\n{\n\tint cpu;\n\tint total = 0;\n\n\tfor_each_possible_cpu(cpu)\n\t\ttotal += per_cpu(process_counts, cpu);\n\n\treturn total;\n}\n\nvoid __weak arch_release_task_struct(struct task_struct *tsk)\n{\n}\n\n#ifndef CONFIG_ARCH_TASK_STRUCT_ALLOCATOR\nstatic struct kmem_cache *task_struct_cachep;\n\nstatic inline struct task_struct *alloc_task_struct_node(int node)\n{\n\treturn kmem_cache_alloc_node(task_struct_cachep, GFP_KERNEL, node);\n}\n\nstatic inline void free_task_struct(struct task_struct *tsk)\n{\n\tkmem_cache_free(task_struct_cachep, tsk);\n}\n#endif\n\n#ifndef CONFIG_ARCH_THREAD_STACK_ALLOCATOR\n\n/*\n * Allocate pages if THREAD_SIZE is >= PAGE_SIZE, otherwise use a\n * kmemcache based allocator.\n */\n# if THREAD_SIZE >= PAGE_SIZE || defined(CONFIG_VMAP_STACK)\n\n#ifdef CONFIG_VMAP_STACK\n/*\n * vmalloc() is a bit slow, and calling vfree() enough times will force a TLB\n * flush.  Try to minimize the number of calls by caching stacks.\n */\n#define NR_CACHED_STACKS 2\nstatic DEFINE_PER_CPU(struct vm_struct *, cached_stacks[NR_CACHED_STACKS]);\n\nstatic int free_vm_stack_cache(unsigned int cpu)\n{\n\tstruct vm_struct **cached_vm_stacks = per_cpu_ptr(cached_stacks, cpu);\n\tint i;\n\n\tfor (i = 0; i < NR_CACHED_STACKS; i++) {\n\t\tstruct vm_struct *vm_stack = cached_vm_stacks[i];\n\n\t\tif (!vm_stack)\n\t\t\tcontinue;\n\n\t\tvfree(vm_stack->addr);\n\t\tcached_vm_stacks[i] = NULL;\n\t}\n\n\treturn 0;\n}\n#endif\n\nstatic unsigned long *alloc_thread_stack_node(struct task_struct *tsk, int node)\n{\n#ifdef CONFIG_VMAP_STACK\n\tvoid *stack;\n\tint i;\n\n\tfor (i = 0; i < NR_CACHED_STACKS; i++) {\n\t\tstruct vm_struct *s;\n\n\t\ts = this_cpu_xchg(cached_stacks[i], NULL);\n\n\t\tif (!s)\n\t\t\tcontinue;\n\n\t\t/* Clear the KASAN shadow of the stack. */\n\t\tkasan_unpoison_shadow(s->addr, THREAD_SIZE);\n\n\t\t/* Clear stale pointers from reused stack. */\n\t\tmemset(s->addr, 0, THREAD_SIZE);\n\n\t\ttsk->stack_vm_area = s;\n\t\ttsk->stack = s->addr;\n\t\treturn s->addr;\n\t}\n\n\t/*\n\t * Allocated stacks are cached and later reused by new threads,\n\t * so memcg accounting is performed manually on assigning/releasing\n\t * stacks to tasks. Drop __GFP_ACCOUNT.\n\t */\n\tstack = __vmalloc_node_range(THREAD_SIZE, THREAD_ALIGN,\n\t\t\t\t     VMALLOC_START, VMALLOC_END,\n\t\t\t\t     THREADINFO_GFP & ~__GFP_ACCOUNT,\n\t\t\t\t     PAGE_KERNEL,\n\t\t\t\t     0, node, __builtin_return_address(0));\n\n\t/*\n\t * We can't call find_vm_area() in interrupt context, and\n\t * free_thread_stack() can be called in interrupt context,\n\t * so cache the vm_struct.\n\t */\n\tif (stack) {\n\t\ttsk->stack_vm_area = find_vm_area(stack);\n\t\ttsk->stack = stack;\n\t}\n\treturn stack;\n#else\n\tstruct page *page = alloc_pages_node(node, THREADINFO_GFP,\n\t\t\t\t\t     THREAD_SIZE_ORDER);\n\n\tif (likely(page)) {\n\t\ttsk->stack = kasan_reset_tag(page_address(page));\n\t\treturn tsk->stack;\n\t}\n\treturn NULL;\n#endif\n}\n\nstatic inline void free_thread_stack(struct task_struct *tsk)\n{\n#ifdef CONFIG_VMAP_STACK\n\tstruct vm_struct *vm = task_stack_vm_area(tsk);\n\n\tif (vm) {\n\t\tint i;\n\n\t\tfor (i = 0; i < THREAD_SIZE / PAGE_SIZE; i++)\n\t\t\tmemcg_kmem_uncharge_page(vm->pages[i], 0);\n\n\t\tfor (i = 0; i < NR_CACHED_STACKS; i++) {\n\t\t\tif (this_cpu_cmpxchg(cached_stacks[i],\n\t\t\t\t\tNULL, tsk->stack_vm_area) != NULL)\n\t\t\t\tcontinue;\n\n\t\t\treturn;\n\t\t}\n\n\t\tvfree_atomic(tsk->stack);\n\t\treturn;\n\t}\n#endif\n\n\t__free_pages(virt_to_page(tsk->stack), THREAD_SIZE_ORDER);\n}\n# else\nstatic struct kmem_cache *thread_stack_cache;\n\nstatic unsigned long *alloc_thread_stack_node(struct task_struct *tsk,\n\t\t\t\t\t\t  int node)\n{\n\tunsigned long *stack;\n\tstack = kmem_cache_alloc_node(thread_stack_cache, THREADINFO_GFP, node);\n\tstack = kasan_reset_tag(stack);\n\ttsk->stack = stack;\n\treturn stack;\n}\n\nstatic void free_thread_stack(struct task_struct *tsk)\n{\n\tkmem_cache_free(thread_stack_cache, tsk->stack);\n}\n\nvoid thread_stack_cache_init(void)\n{\n\tthread_stack_cache = kmem_cache_create_usercopy(\"thread_stack\",\n\t\t\t\t\tTHREAD_SIZE, THREAD_SIZE, 0, 0,\n\t\t\t\t\tTHREAD_SIZE, NULL);\n\tBUG_ON(thread_stack_cache == NULL);\n}\n# endif\n#endif\n\n/* SLAB cache for signal_struct structures (tsk->signal) */\nstatic struct kmem_cache *signal_cachep;\n\n/* SLAB cache for sighand_struct structures (tsk->sighand) */\nstruct kmem_cache *sighand_cachep;\n\n/* SLAB cache for files_struct structures (tsk->files) */\nstruct kmem_cache *files_cachep;\n\n/* SLAB cache for fs_struct structures (tsk->fs) */\nstruct kmem_cache *fs_cachep;\n\n/* SLAB cache for vm_area_struct structures */\nstatic struct kmem_cache *vm_area_cachep;\n\n/* SLAB cache for mm_struct structures (tsk->mm) */\nstatic struct kmem_cache *mm_cachep;\n\nstruct vm_area_struct *vm_area_alloc(struct mm_struct *mm)\n{\n\tstruct vm_area_struct *vma;\n\n\tvma = kmem_cache_alloc(vm_area_cachep, GFP_KERNEL);\n\tif (vma)\n\t\tvma_init(vma, mm);\n\treturn vma;\n}\n\nstruct vm_area_struct *vm_area_dup(struct vm_area_struct *orig)\n{\n\tstruct vm_area_struct *new = kmem_cache_alloc(vm_area_cachep, GFP_KERNEL);\n\n\tif (new) {\n\t\tASSERT_EXCLUSIVE_WRITER(orig->vm_flags);\n\t\tASSERT_EXCLUSIVE_WRITER(orig->vm_file);\n\t\t/*\n\t\t * orig->shared.rb may be modified concurrently, but the clone\n\t\t * will be reinitialized.\n\t\t */\n\t\t*new = data_race(*orig);\n\t\tINIT_LIST_HEAD(&new->anon_vma_chain);\n\t\tnew->vm_next = new->vm_prev = NULL;\n\t}\n\treturn new;\n}\n\nvoid vm_area_free(struct vm_area_struct *vma)\n{\n\tkmem_cache_free(vm_area_cachep, vma);\n}\n\nstatic void account_kernel_stack(struct task_struct *tsk, int account)\n{\n\tvoid *stack = task_stack_page(tsk);\n\tstruct vm_struct *vm = task_stack_vm_area(tsk);\n\n\n\t/* All stack pages are in the same node. */\n\tif (vm)\n\t\tmod_lruvec_page_state(vm->pages[0], NR_KERNEL_STACK_KB,\n\t\t\t\t      account * (THREAD_SIZE / 1024));\n\telse\n\t\tmod_lruvec_slab_state(stack, NR_KERNEL_STACK_KB,\n\t\t\t\t      account * (THREAD_SIZE / 1024));\n}\n\nstatic int memcg_charge_kernel_stack(struct task_struct *tsk)\n{\n#ifdef CONFIG_VMAP_STACK\n\tstruct vm_struct *vm = task_stack_vm_area(tsk);\n\tint ret;\n\n\tBUILD_BUG_ON(IS_ENABLED(CONFIG_VMAP_STACK) && PAGE_SIZE % 1024 != 0);\n\n\tif (vm) {\n\t\tint i;\n\n\t\tBUG_ON(vm->nr_pages != THREAD_SIZE / PAGE_SIZE);\n\n\t\tfor (i = 0; i < THREAD_SIZE / PAGE_SIZE; i++) {\n\t\t\t/*\n\t\t\t * If memcg_kmem_charge_page() fails, page->mem_cgroup\n\t\t\t * pointer is NULL, and memcg_kmem_uncharge_page() in\n\t\t\t * free_thread_stack() will ignore this page.\n\t\t\t */\n\t\t\tret = memcg_kmem_charge_page(vm->pages[i], GFP_KERNEL,\n\t\t\t\t\t\t     0);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n#endif\n\treturn 0;\n}\n\nstatic void release_task_stack(struct task_struct *tsk)\n{\n\tif (WARN_ON(tsk->state != TASK_DEAD))\n\t\treturn;  /* Better to leak the stack than to free prematurely */\n\n\taccount_kernel_stack(tsk, -1);\n\tfree_thread_stack(tsk);\n\ttsk->stack = NULL;\n#ifdef CONFIG_VMAP_STACK\n\ttsk->stack_vm_area = NULL;\n#endif\n}\n\n#ifdef CONFIG_THREAD_INFO_IN_TASK\nvoid put_task_stack(struct task_struct *tsk)\n{\n\tif (refcount_dec_and_test(&tsk->stack_refcount))\n\t\trelease_task_stack(tsk);\n}\n#endif\n\nvoid free_task(struct task_struct *tsk)\n{\n\tscs_release(tsk);\n\n#ifndef CONFIG_THREAD_INFO_IN_TASK\n\t/*\n\t * The task is finally done with both the stack and thread_info,\n\t * so free both.\n\t */\n\trelease_task_stack(tsk);\n#else\n\t/*\n\t * If the task had a separate stack allocation, it should be gone\n\t * by now.\n\t */\n\tWARN_ON_ONCE(refcount_read(&tsk->stack_refcount) != 0);\n#endif\n\trt_mutex_debug_task_free(tsk);\n\tftrace_graph_exit_task(tsk);\n\tarch_release_task_struct(tsk);\n\tif (tsk->flags & PF_KTHREAD)\n\t\tfree_kthread_struct(tsk);\n\tfree_task_struct(tsk);\n}\nEXPORT_SYMBOL(free_task);\n\n#ifdef CONFIG_MMU\nstatic __latent_entropy int dup_mmap(struct mm_struct *mm,\n\t\t\t\t\tstruct mm_struct *oldmm)\n{\n\tstruct vm_area_struct *mpnt, *tmp, *prev, **pprev;\n\tstruct rb_node **rb_link, *rb_parent;\n\tint retval;\n\tunsigned long charge;\n\tLIST_HEAD(uf);\n\n\tuprobe_start_dup_mmap();\n\tif (mmap_write_lock_killable(oldmm)) {\n\t\tretval = -EINTR;\n\t\tgoto fail_uprobe_end;\n\t}\n\tflush_cache_dup_mm(oldmm);\n\tuprobe_dup_mmap(oldmm, mm);\n\t/*\n\t * Not linked in yet - no deadlock potential:\n\t */\n\tmmap_write_lock_nested(mm, SINGLE_DEPTH_NESTING);\n\n\t/* No ordering required: file already has been exposed. */\n\tRCU_INIT_POINTER(mm->exe_file, get_mm_exe_file(oldmm));\n\n\tmm->total_vm = oldmm->total_vm;\n\tmm->data_vm = oldmm->data_vm;\n\tmm->exec_vm = oldmm->exec_vm;\n\tmm->stack_vm = oldmm->stack_vm;\n\n\trb_link = &mm->mm_rb.rb_node;\n\trb_parent = NULL;\n\tpprev = &mm->mmap;\n\tretval = ksm_fork(mm, oldmm);\n\tif (retval)\n\t\tgoto out;\n\tretval = khugepaged_fork(mm, oldmm);\n\tif (retval)\n\t\tgoto out;\n\n\tprev = NULL;\n\tfor (mpnt = oldmm->mmap; mpnt; mpnt = mpnt->vm_next) {\n\t\tstruct file *file;\n\n\t\tif (mpnt->vm_flags & VM_DONTCOPY) {\n\t\t\tvm_stat_account(mm, mpnt->vm_flags, -vma_pages(mpnt));\n\t\t\tcontinue;\n\t\t}\n\t\tcharge = 0;\n\t\t/*\n\t\t * Don't duplicate many vmas if we've been oom-killed (for\n\t\t * example)\n\t\t */\n\t\tif (fatal_signal_pending(current)) {\n\t\t\tretval = -EINTR;\n\t\t\tgoto out;\n\t\t}\n\t\tif (mpnt->vm_flags & VM_ACCOUNT) {\n\t\t\tunsigned long len = vma_pages(mpnt);\n\n\t\t\tif (security_vm_enough_memory_mm(oldmm, len)) /* sic */\n\t\t\t\tgoto fail_nomem;\n\t\t\tcharge = len;\n\t\t}\n\t\ttmp = vm_area_dup(mpnt);\n\t\tif (!tmp)\n\t\t\tgoto fail_nomem;\n\t\tretval = vma_dup_policy(mpnt, tmp);\n\t\tif (retval)\n\t\t\tgoto fail_nomem_policy;\n\t\ttmp->vm_mm = mm;\n\t\tretval = dup_userfaultfd(tmp, &uf);\n\t\tif (retval)\n\t\t\tgoto fail_nomem_anon_vma_fork;\n\t\tif (tmp->vm_flags & VM_WIPEONFORK) {\n\t\t\t/*\n\t\t\t * VM_WIPEONFORK gets a clean slate in the child.\n\t\t\t * Don't prepare anon_vma until fault since we don't\n\t\t\t * copy page for current vma.\n\t\t\t */\n\t\t\ttmp->anon_vma = NULL;\n\t\t} else if (anon_vma_fork(tmp, mpnt))\n\t\t\tgoto fail_nomem_anon_vma_fork;\n\t\ttmp->vm_flags &= ~(VM_LOCKED | VM_LOCKONFAULT);\n\t\tfile = tmp->vm_file;\n\t\tif (file) {\n\t\t\tstruct inode *inode = file_inode(file);\n\t\t\tstruct address_space *mapping = file->f_mapping;\n\n\t\t\tget_file(file);\n\t\t\tif (tmp->vm_flags & VM_DENYWRITE)\n\t\t\t\tput_write_access(inode);\n\t\t\ti_mmap_lock_write(mapping);\n\t\t\tif (tmp->vm_flags & VM_SHARED)\n\t\t\t\tmapping_allow_writable(mapping);\n\t\t\tflush_dcache_mmap_lock(mapping);\n\t\t\t/* insert tmp into the share list, just after mpnt */\n\t\t\tvma_interval_tree_insert_after(tmp, mpnt,\n\t\t\t\t\t&mapping->i_mmap);\n\t\t\tflush_dcache_mmap_unlock(mapping);\n\t\t\ti_mmap_unlock_write(mapping);\n\t\t}\n\n\t\t/*\n\t\t * Clear hugetlb-related page reserves for children. This only\n\t\t * affects MAP_PRIVATE mappings. Faults generated by the child\n\t\t * are not guaranteed to succeed, even if read-only\n\t\t */\n\t\tif (is_vm_hugetlb_page(tmp))\n\t\t\treset_vma_resv_huge_pages(tmp);\n\n\t\t/*\n\t\t * Link in the new vma and copy the page table entries.\n\t\t */\n\t\t*pprev = tmp;\n\t\tpprev = &tmp->vm_next;\n\t\ttmp->vm_prev = prev;\n\t\tprev = tmp;\n\n\t\t__vma_link_rb(mm, tmp, rb_link, rb_parent);\n\t\trb_link = &tmp->vm_rb.rb_right;\n\t\trb_parent = &tmp->vm_rb;\n\n\t\tmm->map_count++;\n\t\tif (!(tmp->vm_flags & VM_WIPEONFORK))\n\t\t\tretval = copy_page_range(tmp, mpnt);\n\n\t\tif (tmp->vm_ops && tmp->vm_ops->open)\n\t\t\ttmp->vm_ops->open(tmp);\n\n\t\tif (retval)\n\t\t\tgoto out;\n\t}\n\t/* a new mm has just been created */\n\tretval = arch_dup_mmap(oldmm, mm);\nout:\n\tmmap_write_unlock(mm);\n\tflush_tlb_mm(oldmm);\n\tmmap_write_unlock(oldmm);\n\tdup_userfaultfd_complete(&uf);\nfail_uprobe_end:\n\tuprobe_end_dup_mmap();\n\treturn retval;\nfail_nomem_anon_vma_fork:\n\tmpol_put(vma_policy(tmp));\nfail_nomem_policy:\n\tvm_area_free(tmp);\nfail_nomem:\n\tretval = -ENOMEM;\n\tvm_unacct_memory(charge);\n\tgoto out;\n}\n\nstatic inline int mm_alloc_pgd(struct mm_struct *mm)\n{\n\tmm->pgd = pgd_alloc(mm);\n\tif (unlikely(!mm->pgd))\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\nstatic inline void mm_free_pgd(struct mm_struct *mm)\n{\n\tpgd_free(mm, mm->pgd);\n}\n#else\nstatic int dup_mmap(struct mm_struct *mm, struct mm_struct *oldmm)\n{\n\tmmap_write_lock(oldmm);\n\tRCU_INIT_POINTER(mm->exe_file, get_mm_exe_file(oldmm));\n\tmmap_write_unlock(oldmm);\n\treturn 0;\n}\n#define mm_alloc_pgd(mm)\t(0)\n#define mm_free_pgd(mm)\n#endif /* CONFIG_MMU */\n\nstatic void check_mm(struct mm_struct *mm)\n{\n\tint i;\n\n\tBUILD_BUG_ON_MSG(ARRAY_SIZE(resident_page_types) != NR_MM_COUNTERS,\n\t\t\t \"Please make sure 'struct resident_page_types[]' is updated as well\");\n\n\tfor (i = 0; i < NR_MM_COUNTERS; i++) {\n\t\tlong x = atomic_long_read(&mm->rss_stat.count[i]);\n\n\t\tif (unlikely(x))\n\t\t\tpr_alert(\"BUG: Bad rss-counter state mm:%p type:%s val:%ld\\n\",\n\t\t\t\t mm, resident_page_types[i], x);\n\t}\n\n\tif (mm_pgtables_bytes(mm))\n\t\tpr_alert(\"BUG: non-zero pgtables_bytes on freeing mm: %ld\\n\",\n\t\t\t\tmm_pgtables_bytes(mm));\n\n#if defined(CONFIG_TRANSPARENT_HUGEPAGE) && !USE_SPLIT_PMD_PTLOCKS\n\tVM_BUG_ON_MM(mm->pmd_huge_pte, mm);\n#endif\n}\n\n#define allocate_mm()\t(kmem_cache_alloc(mm_cachep, GFP_KERNEL))\n#define free_mm(mm)\t(kmem_cache_free(mm_cachep, (mm)))\n\n/*\n * Called when the last reference to the mm\n * is dropped: either by a lazy thread or by\n * mmput. Free the page directory and the mm.\n */\nvoid __mmdrop(struct mm_struct *mm)\n{\n\tBUG_ON(mm == &init_mm);\n\tWARN_ON_ONCE(mm == current->mm);\n\tWARN_ON_ONCE(mm == current->active_mm);\n\tmm_free_pgd(mm);\n\tdestroy_context(mm);\n\tmmu_notifier_subscriptions_destroy(mm);\n\tcheck_mm(mm);\n\tput_user_ns(mm->user_ns);\n\tfree_mm(mm);\n}\nEXPORT_SYMBOL_GPL(__mmdrop);\n\nstatic void mmdrop_async_fn(struct work_struct *work)\n{\n\tstruct mm_struct *mm;\n\n\tmm = container_of(work, struct mm_struct, async_put_work);\n\t__mmdrop(mm);\n}\n\nstatic void mmdrop_async(struct mm_struct *mm)\n{\n\tif (unlikely(atomic_dec_and_test(&mm->mm_count))) {\n\t\tINIT_WORK(&mm->async_put_work, mmdrop_async_fn);\n\t\tschedule_work(&mm->async_put_work);\n\t}\n}\n\nstatic inline void free_signal_struct(struct signal_struct *sig)\n{\n\ttaskstats_tgid_free(sig);\n\tsched_autogroup_exit(sig);\n\t/*\n\t * __mmdrop is not safe to call from softirq context on x86 due to\n\t * pgd_dtor so postpone it to the async context\n\t */\n\tif (sig->oom_mm)\n\t\tmmdrop_async(sig->oom_mm);\n\tkmem_cache_free(signal_cachep, sig);\n}\n\nstatic inline void put_signal_struct(struct signal_struct *sig)\n{\n\tif (refcount_dec_and_test(&sig->sigcnt))\n\t\tfree_signal_struct(sig);\n}\n\nvoid __put_task_struct(struct task_struct *tsk)\n{\n\tWARN_ON(!tsk->exit_state);\n\tWARN_ON(refcount_read(&tsk->usage));\n\tWARN_ON(tsk == current);\n\n\tio_uring_free(tsk);\n\tcgroup_free(tsk);\n\ttask_numa_free(tsk, true);\n\tsecurity_task_free(tsk);\n\texit_creds(tsk);\n\tdelayacct_tsk_free(tsk);\n\tput_signal_struct(tsk->signal);\n\n\tif (!profile_handoff_task(tsk))\n\t\tfree_task(tsk);\n}\nEXPORT_SYMBOL_GPL(__put_task_struct);\n\nvoid __init __weak arch_task_cache_init(void) { }\n\n/*\n * set_max_threads\n */\nstatic void set_max_threads(unsigned int max_threads_suggested)\n{\n\tu64 threads;\n\tunsigned long nr_pages = totalram_pages();\n\n\t/*\n\t * The number of threads shall be limited such that the thread\n\t * structures may only consume a small part of the available memory.\n\t */\n\tif (fls64(nr_pages) + fls64(PAGE_SIZE) > 64)\n\t\tthreads = MAX_THREADS;\n\telse\n\t\tthreads = div64_u64((u64) nr_pages * (u64) PAGE_SIZE,\n\t\t\t\t    (u64) THREAD_SIZE * 8UL);\n\n\tif (threads > max_threads_suggested)\n\t\tthreads = max_threads_suggested;\n\n\tmax_threads = clamp_t(u64, threads, MIN_THREADS, MAX_THREADS);\n}\n\n#ifdef CONFIG_ARCH_WANTS_DYNAMIC_TASK_STRUCT\n/* Initialized by the architecture: */\nint arch_task_struct_size __read_mostly;\n#endif\n\n#ifndef CONFIG_ARCH_TASK_STRUCT_ALLOCATOR\nstatic void task_struct_whitelist(unsigned long *offset, unsigned long *size)\n{\n\t/* Fetch thread_struct whitelist for the architecture. */\n\tarch_thread_struct_whitelist(offset, size);\n\n\t/*\n\t * Handle zero-sized whitelist or empty thread_struct, otherwise\n\t * adjust offset to position of thread_struct in task_struct.\n\t */\n\tif (unlikely(*size == 0))\n\t\t*offset = 0;\n\telse\n\t\t*offset += offsetof(struct task_struct, thread);\n}\n#endif /* CONFIG_ARCH_TASK_STRUCT_ALLOCATOR */\n\nvoid __init fork_init(void)\n{\n\tint i;\n#ifndef CONFIG_ARCH_TASK_STRUCT_ALLOCATOR\n#ifndef ARCH_MIN_TASKALIGN\n#define ARCH_MIN_TASKALIGN\t0\n#endif\n\tint align = max_t(int, L1_CACHE_BYTES, ARCH_MIN_TASKALIGN);\n\tunsigned long useroffset, usersize;\n\n\t/* create a slab on which task_structs can be allocated */\n\ttask_struct_whitelist(&useroffset, &usersize);\n\ttask_struct_cachep = kmem_cache_create_usercopy(\"task_struct\",\n\t\t\tarch_task_struct_size, align,\n\t\t\tSLAB_PANIC|SLAB_ACCOUNT,\n\t\t\tuseroffset, usersize, NULL);\n#endif\n\n\t/* do the arch specific task caches init */\n\tarch_task_cache_init();\n\n\tset_max_threads(MAX_THREADS);\n\n\tinit_task.signal->rlim[RLIMIT_NPROC].rlim_cur = max_threads/2;\n\tinit_task.signal->rlim[RLIMIT_NPROC].rlim_max = max_threads/2;\n\tinit_task.signal->rlim[RLIMIT_SIGPENDING] =\n\t\tinit_task.signal->rlim[RLIMIT_NPROC];\n\n\tfor (i = 0; i < UCOUNT_COUNTS; i++) {\n\t\tinit_user_ns.ucount_max[i] = max_threads/2;\n\t}\n\n#ifdef CONFIG_VMAP_STACK\n\tcpuhp_setup_state(CPUHP_BP_PREPARE_DYN, \"fork:vm_stack_cache\",\n\t\t\t  NULL, free_vm_stack_cache);\n#endif\n\n\tscs_init();\n\n\tlockdep_init_task(&init_task);\n\tuprobes_init();\n}\n\nint __weak arch_dup_task_struct(struct task_struct *dst,\n\t\t\t\t\t       struct task_struct *src)\n{\n\t*dst = *src;\n\treturn 0;\n}\n\nvoid set_task_stack_end_magic(struct task_struct *tsk)\n{\n\tunsigned long *stackend;\n\n\tstackend = end_of_stack(tsk);\n\t*stackend = STACK_END_MAGIC;\t/* for overflow detection */\n}\n\nstatic struct task_struct *dup_task_struct(struct task_struct *orig, int node)\n{\n\tstruct task_struct *tsk;\n\tunsigned long *stack;\n\tstruct vm_struct *stack_vm_area __maybe_unused;\n\tint err;\n\n\tif (node == NUMA_NO_NODE)\n\t\tnode = tsk_fork_get_node(orig);\n\ttsk = alloc_task_struct_node(node);\n\tif (!tsk)\n\t\treturn NULL;\n\n\tstack = alloc_thread_stack_node(tsk, node);\n\tif (!stack)\n\t\tgoto free_tsk;\n\n\tif (memcg_charge_kernel_stack(tsk))\n\t\tgoto free_stack;\n\n\tstack_vm_area = task_stack_vm_area(tsk);\n\n\terr = arch_dup_task_struct(tsk, orig);\n\n\t/*\n\t * arch_dup_task_struct() clobbers the stack-related fields.  Make\n\t * sure they're properly initialized before using any stack-related\n\t * functions again.\n\t */\n\ttsk->stack = stack;\n#ifdef CONFIG_VMAP_STACK\n\ttsk->stack_vm_area = stack_vm_area;\n#endif\n#ifdef CONFIG_THREAD_INFO_IN_TASK\n\trefcount_set(&tsk->stack_refcount, 1);\n#endif\n\n\tif (err)\n\t\tgoto free_stack;\n\n\terr = scs_prepare(tsk, node);\n\tif (err)\n\t\tgoto free_stack;\n\n#ifdef CONFIG_SECCOMP\n\t/*\n\t * We must handle setting up seccomp filters once we're under\n\t * the sighand lock in case orig has changed between now and\n\t * then. Until then, filter must be NULL to avoid messing up\n\t * the usage counts on the error path calling free_task.\n\t */\n\ttsk->seccomp.filter = NULL;\n#endif\n\n\tsetup_thread_stack(tsk, orig);\n\tclear_user_return_notifier(tsk);\n\tclear_tsk_need_resched(tsk);\n\tset_task_stack_end_magic(tsk);\n\n#ifdef CONFIG_STACKPROTECTOR\n\ttsk->stack_canary = get_random_canary();\n#endif\n\tif (orig->cpus_ptr == &orig->cpus_mask)\n\t\ttsk->cpus_ptr = &tsk->cpus_mask;\n\n\t/*\n\t * One for the user space visible state that goes away when reaped.\n\t * One for the scheduler.\n\t */\n\trefcount_set(&tsk->rcu_users, 2);\n\t/* One for the rcu users */\n\trefcount_set(&tsk->usage, 1);\n#ifdef CONFIG_BLK_DEV_IO_TRACE\n\ttsk->btrace_seq = 0;\n#endif\n\ttsk->splice_pipe = NULL;\n\ttsk->task_frag.page = NULL;\n\ttsk->wake_q.next = NULL;\n\n\taccount_kernel_stack(tsk, 1);\n\n\tkcov_task_init(tsk);\n\n#ifdef CONFIG_FAULT_INJECTION\n\ttsk->fail_nth = 0;\n#endif\n\n#ifdef CONFIG_BLK_CGROUP\n\ttsk->throttle_queue = NULL;\n\ttsk->use_memdelay = 0;\n#endif\n\n#ifdef CONFIG_MEMCG\n\ttsk->active_memcg = NULL;\n#endif\n\treturn tsk;\n\nfree_stack:\n\tfree_thread_stack(tsk);\nfree_tsk:\n\tfree_task_struct(tsk);\n\treturn NULL;\n}\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(mmlist_lock);\n\nstatic unsigned long default_dump_filter = MMF_DUMP_FILTER_DEFAULT;\n\nstatic int __init coredump_filter_setup(char *s)\n{\n\tdefault_dump_filter =\n\t\t(simple_strtoul(s, NULL, 0) << MMF_DUMP_FILTER_SHIFT) &\n\t\tMMF_DUMP_FILTER_MASK;\n\treturn 1;\n}\n\n__setup(\"coredump_filter=\", coredump_filter_setup);\n\n#include <linux/init_task.h>\n\nstatic void mm_init_aio(struct mm_struct *mm)\n{\n#ifdef CONFIG_AIO\n\tspin_lock_init(&mm->ioctx_lock);\n\tmm->ioctx_table = NULL;\n#endif\n}\n\nstatic __always_inline void mm_clear_owner(struct mm_struct *mm,\n\t\t\t\t\t   struct task_struct *p)\n{\n#ifdef CONFIG_MEMCG\n\tif (mm->owner == p)\n\t\tWRITE_ONCE(mm->owner, NULL);\n#endif\n}\n\nstatic void mm_init_owner(struct mm_struct *mm, struct task_struct *p)\n{\n#ifdef CONFIG_MEMCG\n\tmm->owner = p;\n#endif\n}\n\nstatic void mm_init_uprobes_state(struct mm_struct *mm)\n{\n#ifdef CONFIG_UPROBES\n\tmm->uprobes_state.xol_area = NULL;\n#endif\n}\n\nstatic struct mm_struct *mm_init(struct mm_struct *mm, struct task_struct *p,\n\tstruct user_namespace *user_ns)\n{\n\tmm->mmap = NULL;\n\tmm->mm_rb = RB_ROOT;\n\tmm->vmacache_seqnum = 0;\n\tatomic_set(&mm->mm_users, 1);\n\tatomic_set(&mm->mm_count, 1);\n\tmmap_init_lock(mm);\n\tINIT_LIST_HEAD(&mm->mmlist);\n\tmm->core_state = NULL;\n\tmm_pgtables_bytes_init(mm);\n\tmm->map_count = 0;\n\tmm->locked_vm = 0;\n\tatomic_set(&mm->has_pinned, 0);\n\tatomic64_set(&mm->pinned_vm, 0);\n\tmemset(&mm->rss_stat, 0, sizeof(mm->rss_stat));\n\tspin_lock_init(&mm->page_table_lock);\n\tspin_lock_init(&mm->arg_lock);\n\tmm_init_cpumask(mm);\n\tmm_init_aio(mm);\n\tmm_init_owner(mm, p);\n\tRCU_INIT_POINTER(mm->exe_file, NULL);\n\tmmu_notifier_subscriptions_init(mm);\n\tinit_tlb_flush_pending(mm);\n#if defined(CONFIG_TRANSPARENT_HUGEPAGE) && !USE_SPLIT_PMD_PTLOCKS\n\tmm->pmd_huge_pte = NULL;\n#endif\n\tmm_init_uprobes_state(mm);\n\n\tif (current->mm) {\n\t\tmm->flags = current->mm->flags & MMF_INIT_MASK;\n\t\tmm->def_flags = current->mm->def_flags & VM_INIT_DEF_MASK;\n\t} else {\n\t\tmm->flags = default_dump_filter;\n\t\tmm->def_flags = 0;\n\t}\n\n\tif (mm_alloc_pgd(mm))\n\t\tgoto fail_nopgd;\n\n\tif (init_new_context(p, mm))\n\t\tgoto fail_nocontext;\n\n\tmm->user_ns = get_user_ns(user_ns);\n\treturn mm;\n\nfail_nocontext:\n\tmm_free_pgd(mm);\nfail_nopgd:\n\tfree_mm(mm);\n\treturn NULL;\n}\n\n/*\n * Allocate and initialize an mm_struct.\n */\nstruct mm_struct *mm_alloc(void)\n{\n\tstruct mm_struct *mm;\n\n\tmm = allocate_mm();\n\tif (!mm)\n\t\treturn NULL;\n\n\tmemset(mm, 0, sizeof(*mm));\n\treturn mm_init(mm, current, current_user_ns());\n}\n\nstatic inline void __mmput(struct mm_struct *mm)\n{\n\tVM_BUG_ON(atomic_read(&mm->mm_users));\n\n\tuprobe_clear_state(mm);\n\texit_aio(mm);\n\tksm_exit(mm);\n\tkhugepaged_exit(mm); /* must run before exit_mmap */\n\texit_mmap(mm);\n\tmm_put_huge_zero_page(mm);\n\tset_mm_exe_file(mm, NULL);\n\tif (!list_empty(&mm->mmlist)) {\n\t\tspin_lock(&mmlist_lock);\n\t\tlist_del(&mm->mmlist);\n\t\tspin_unlock(&mmlist_lock);\n\t}\n\tif (mm->binfmt)\n\t\tmodule_put(mm->binfmt->module);\n\tmmdrop(mm);\n}\n\n/*\n * Decrement the use count and release all resources for an mm.\n */\nvoid mmput(struct mm_struct *mm)\n{\n\tmight_sleep();\n\n\tif (atomic_dec_and_test(&mm->mm_users))\n\t\t__mmput(mm);\n}\nEXPORT_SYMBOL_GPL(mmput);\n\n#ifdef CONFIG_MMU\nstatic void mmput_async_fn(struct work_struct *work)\n{\n\tstruct mm_struct *mm = container_of(work, struct mm_struct,\n\t\t\t\t\t    async_put_work);\n\n\t__mmput(mm);\n}\n\nvoid mmput_async(struct mm_struct *mm)\n{\n\tif (atomic_dec_and_test(&mm->mm_users)) {\n\t\tINIT_WORK(&mm->async_put_work, mmput_async_fn);\n\t\tschedule_work(&mm->async_put_work);\n\t}\n}\n#endif\n\n/**\n * set_mm_exe_file - change a reference to the mm's executable file\n *\n * This changes mm's executable file (shown as symlink /proc/[pid]/exe).\n *\n * Main users are mmput() and sys_execve(). Callers prevent concurrent\n * invocations: in mmput() nobody alive left, in execve task is single\n * threaded. sys_prctl(PR_SET_MM_MAP/EXE_FILE) also needs to set the\n * mm->exe_file, but does so without using set_mm_exe_file() in order\n * to do avoid the need for any locks.\n */\nvoid set_mm_exe_file(struct mm_struct *mm, struct file *new_exe_file)\n{\n\tstruct file *old_exe_file;\n\n\t/*\n\t * It is safe to dereference the exe_file without RCU as\n\t * this function is only called if nobody else can access\n\t * this mm -- see comment above for justification.\n\t */\n\told_exe_file = rcu_dereference_raw(mm->exe_file);\n\n\tif (new_exe_file)\n\t\tget_file(new_exe_file);\n\trcu_assign_pointer(mm->exe_file, new_exe_file);\n\tif (old_exe_file)\n\t\tfput(old_exe_file);\n}\n\n/**\n * get_mm_exe_file - acquire a reference to the mm's executable file\n *\n * Returns %NULL if mm has no associated executable file.\n * User must release file via fput().\n */\nstruct file *get_mm_exe_file(struct mm_struct *mm)\n{\n\tstruct file *exe_file;\n\n\trcu_read_lock();\n\texe_file = rcu_dereference(mm->exe_file);\n\tif (exe_file && !get_file_rcu(exe_file))\n\t\texe_file = NULL;\n\trcu_read_unlock();\n\treturn exe_file;\n}\nEXPORT_SYMBOL(get_mm_exe_file);\n\n/**\n * get_task_exe_file - acquire a reference to the task's executable file\n *\n * Returns %NULL if task's mm (if any) has no associated executable file or\n * this is a kernel thread with borrowed mm (see the comment above get_task_mm).\n * User must release file via fput().\n */\nstruct file *get_task_exe_file(struct task_struct *task)\n{\n\tstruct file *exe_file = NULL;\n\tstruct mm_struct *mm;\n\n\ttask_lock(task);\n\tmm = task->mm;\n\tif (mm) {\n\t\tif (!(task->flags & PF_KTHREAD))\n\t\t\texe_file = get_mm_exe_file(mm);\n\t}\n\ttask_unlock(task);\n\treturn exe_file;\n}\nEXPORT_SYMBOL(get_task_exe_file);\n\n/**\n * get_task_mm - acquire a reference to the task's mm\n *\n * Returns %NULL if the task has no mm.  Checks PF_KTHREAD (meaning\n * this kernel workthread has transiently adopted a user mm with use_mm,\n * to do its AIO) is not set and if so returns a reference to it, after\n * bumping up the use count.  User must release the mm via mmput()\n * after use.  Typically used by /proc and ptrace.\n */\nstruct mm_struct *get_task_mm(struct task_struct *task)\n{\n\tstruct mm_struct *mm;\n\n\ttask_lock(task);\n\tmm = task->mm;\n\tif (mm) {\n\t\tif (task->flags & PF_KTHREAD)\n\t\t\tmm = NULL;\n\t\telse\n\t\t\tmmget(mm);\n\t}\n\ttask_unlock(task);\n\treturn mm;\n}\nEXPORT_SYMBOL_GPL(get_task_mm);\n\nstruct mm_struct *mm_access(struct task_struct *task, unsigned int mode)\n{\n\tstruct mm_struct *mm;\n\tint err;\n\n\terr =  mutex_lock_killable(&task->signal->exec_update_mutex);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\tmm = get_task_mm(task);\n\tif (mm && mm != current->mm &&\n\t\t\t!ptrace_may_access(task, mode)) {\n\t\tmmput(mm);\n\t\tmm = ERR_PTR(-EACCES);\n\t}\n\tmutex_unlock(&task->signal->exec_update_mutex);\n\n\treturn mm;\n}\n\nstatic void complete_vfork_done(struct task_struct *tsk)\n{\n\tstruct completion *vfork;\n\n\ttask_lock(tsk);\n\tvfork = tsk->vfork_done;\n\tif (likely(vfork)) {\n\t\ttsk->vfork_done = NULL;\n\t\tcomplete(vfork);\n\t}\n\ttask_unlock(tsk);\n}\n\nstatic int wait_for_vfork_done(struct task_struct *child,\n\t\t\t\tstruct completion *vfork)\n{\n\tint killed;\n\n\tfreezer_do_not_count();\n\tcgroup_enter_frozen();\n\tkilled = wait_for_completion_killable(vfork);\n\tcgroup_leave_frozen(false);\n\tfreezer_count();\n\n\tif (killed) {\n\t\ttask_lock(child);\n\t\tchild->vfork_done = NULL;\n\t\ttask_unlock(child);\n\t}\n\n\tput_task_struct(child);\n\treturn killed;\n}\n\n/* Please note the differences between mmput and mm_release.\n * mmput is called whenever we stop holding onto a mm_struct,\n * error success whatever.\n *\n * mm_release is called after a mm_struct has been removed\n * from the current process.\n *\n * This difference is important for error handling, when we\n * only half set up a mm_struct for a new process and need to restore\n * the old one.  Because we mmput the new mm_struct before\n * restoring the old one. . .\n * Eric Biederman 10 January 1998\n */\nstatic void mm_release(struct task_struct *tsk, struct mm_struct *mm)\n{\n\tuprobe_free_utask(tsk);\n\n\t/* Get rid of any cached register state */\n\tdeactivate_mm(tsk, mm);\n\n\t/*\n\t * Signal userspace if we're not exiting with a core dump\n\t * because we want to leave the value intact for debugging\n\t * purposes.\n\t */\n\tif (tsk->clear_child_tid) {\n\t\tif (!(tsk->signal->flags & SIGNAL_GROUP_COREDUMP) &&\n\t\t    atomic_read(&mm->mm_users) > 1) {\n\t\t\t/*\n\t\t\t * We don't check the error code - if userspace has\n\t\t\t * not set up a proper pointer then tough luck.\n\t\t\t */\n\t\t\tput_user(0, tsk->clear_child_tid);\n\t\t\tdo_futex(tsk->clear_child_tid, FUTEX_WAKE,\n\t\t\t\t\t1, NULL, NULL, 0, 0);\n\t\t}\n\t\ttsk->clear_child_tid = NULL;\n\t}\n\n\t/*\n\t * All done, finally we can wake up parent and return this mm to him.\n\t * Also kthread_stop() uses this completion for synchronization.\n\t */\n\tif (tsk->vfork_done)\n\t\tcomplete_vfork_done(tsk);\n}\n\nvoid exit_mm_release(struct task_struct *tsk, struct mm_struct *mm)\n{\n\tfutex_exit_release(tsk);\n\tmm_release(tsk, mm);\n}\n\nvoid exec_mm_release(struct task_struct *tsk, struct mm_struct *mm)\n{\n\tfutex_exec_release(tsk);\n\tmm_release(tsk, mm);\n}\n\n/**\n * dup_mm() - duplicates an existing mm structure\n * @tsk: the task_struct with which the new mm will be associated.\n * @oldmm: the mm to duplicate.\n *\n * Allocates a new mm structure and duplicates the provided @oldmm structure\n * content into it.\n *\n * Return: the duplicated mm or NULL on failure.\n */\nstatic struct mm_struct *dup_mm(struct task_struct *tsk,\n\t\t\t\tstruct mm_struct *oldmm)\n{\n\tstruct mm_struct *mm;\n\tint err;\n\n\tmm = allocate_mm();\n\tif (!mm)\n\t\tgoto fail_nomem;\n\n\tmemcpy(mm, oldmm, sizeof(*mm));\n\n\tif (!mm_init(mm, tsk, mm->user_ns))\n\t\tgoto fail_nomem;\n\n\terr = dup_mmap(mm, oldmm);\n\tif (err)\n\t\tgoto free_pt;\n\n\tmm->hiwater_rss = get_mm_rss(mm);\n\tmm->hiwater_vm = mm->total_vm;\n\n\tif (mm->binfmt && !try_module_get(mm->binfmt->module))\n\t\tgoto free_pt;\n\n\treturn mm;\n\nfree_pt:\n\t/* don't put binfmt in mmput, we haven't got module yet */\n\tmm->binfmt = NULL;\n\tmm_init_owner(mm, NULL);\n\tmmput(mm);\n\nfail_nomem:\n\treturn NULL;\n}\n\nstatic int copy_mm(unsigned long clone_flags, struct task_struct *tsk)\n{\n\tstruct mm_struct *mm, *oldmm;\n\tint retval;\n\n\ttsk->min_flt = tsk->maj_flt = 0;\n\ttsk->nvcsw = tsk->nivcsw = 0;\n#ifdef CONFIG_DETECT_HUNG_TASK\n\ttsk->last_switch_count = tsk->nvcsw + tsk->nivcsw;\n\ttsk->last_switch_time = 0;\n#endif\n\n\ttsk->mm = NULL;\n\ttsk->active_mm = NULL;\n\n\t/*\n\t * Are we cloning a kernel thread?\n\t *\n\t * We need to steal a active VM for that..\n\t */\n\toldmm = current->mm;\n\tif (!oldmm)\n\t\treturn 0;\n\n\t/* initialize the new vmacache entries */\n\tvmacache_flush(tsk);\n\n\tif (clone_flags & CLONE_VM) {\n\t\tmmget(oldmm);\n\t\tmm = oldmm;\n\t\tgoto good_mm;\n\t}\n\n\tretval = -ENOMEM;\n\tmm = dup_mm(tsk, current->mm);\n\tif (!mm)\n\t\tgoto fail_nomem;\n\ngood_mm:\n\ttsk->mm = mm;\n\ttsk->active_mm = mm;\n\treturn 0;\n\nfail_nomem:\n\treturn retval;\n}\n\nstatic int copy_fs(unsigned long clone_flags, struct task_struct *tsk)\n{\n\tstruct fs_struct *fs = current->fs;\n\tif (clone_flags & CLONE_FS) {\n\t\t/* tsk->fs is already what we want */\n\t\tspin_lock(&fs->lock);\n\t\tif (fs->in_exec) {\n\t\t\tspin_unlock(&fs->lock);\n\t\t\treturn -EAGAIN;\n\t\t}\n\t\tfs->users++;\n\t\tspin_unlock(&fs->lock);\n\t\treturn 0;\n\t}\n\ttsk->fs = copy_fs_struct(fs);\n\tif (!tsk->fs)\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\nstatic int copy_files(unsigned long clone_flags, struct task_struct *tsk)\n{\n\tstruct files_struct *oldf, *newf;\n\tint error = 0;\n\n\t/*\n\t * A background process may not have any files ...\n\t */\n\toldf = current->files;\n\tif (!oldf)\n\t\tgoto out;\n\n\tif (clone_flags & CLONE_FILES) {\n\t\tatomic_inc(&oldf->count);\n\t\tgoto out;\n\t}\n\n\tnewf = dup_fd(oldf, NR_OPEN_MAX, &error);\n\tif (!newf)\n\t\tgoto out;\n\n\ttsk->files = newf;\n\terror = 0;\nout:\n\treturn error;\n}\n\nstatic int copy_io(unsigned long clone_flags, struct task_struct *tsk)\n{\n#ifdef CONFIG_BLOCK\n\tstruct io_context *ioc = current->io_context;\n\tstruct io_context *new_ioc;\n\n\tif (!ioc)\n\t\treturn 0;\n\t/*\n\t * Share io context with parent, if CLONE_IO is set\n\t */\n\tif (clone_flags & CLONE_IO) {\n\t\tioc_task_link(ioc);\n\t\ttsk->io_context = ioc;\n\t} else if (ioprio_valid(ioc->ioprio)) {\n\t\tnew_ioc = get_task_io_context(tsk, GFP_KERNEL, NUMA_NO_NODE);\n\t\tif (unlikely(!new_ioc))\n\t\t\treturn -ENOMEM;\n\n\t\tnew_ioc->ioprio = ioc->ioprio;\n\t\tput_io_context(new_ioc);\n\t}\n#endif\n\treturn 0;\n}\n\nstatic int copy_sighand(unsigned long clone_flags, struct task_struct *tsk)\n{\n\tstruct sighand_struct *sig;\n\n\tif (clone_flags & CLONE_SIGHAND) {\n\t\trefcount_inc(&current->sighand->count);\n\t\treturn 0;\n\t}\n\tsig = kmem_cache_alloc(sighand_cachep, GFP_KERNEL);\n\tRCU_INIT_POINTER(tsk->sighand, sig);\n\tif (!sig)\n\t\treturn -ENOMEM;\n\n\trefcount_set(&sig->count, 1);\n\tspin_lock_irq(&current->sighand->siglock);\n\tmemcpy(sig->action, current->sighand->action, sizeof(sig->action));\n\tspin_unlock_irq(&current->sighand->siglock);\n\n\t/* Reset all signal handler not set to SIG_IGN to SIG_DFL. */\n\tif (clone_flags & CLONE_CLEAR_SIGHAND)\n\t\tflush_signal_handlers(tsk, 0);\n\n\treturn 0;\n}\n\nvoid __cleanup_sighand(struct sighand_struct *sighand)\n{\n\tif (refcount_dec_and_test(&sighand->count)) {\n\t\tsignalfd_cleanup(sighand);\n\t\t/*\n\t\t * sighand_cachep is SLAB_TYPESAFE_BY_RCU so we can free it\n\t\t * without an RCU grace period, see __lock_task_sighand().\n\t\t */\n\t\tkmem_cache_free(sighand_cachep, sighand);\n\t}\n}\n\n/*\n * Initialize POSIX timer handling for a thread group.\n */\nstatic void posix_cpu_timers_init_group(struct signal_struct *sig)\n{\n\tstruct posix_cputimers *pct = &sig->posix_cputimers;\n\tunsigned long cpu_limit;\n\n\tcpu_limit = READ_ONCE(sig->rlim[RLIMIT_CPU].rlim_cur);\n\tposix_cputimers_group_init(pct, cpu_limit);\n}\n\nstatic int copy_signal(unsigned long clone_flags, struct task_struct *tsk)\n{\n\tstruct signal_struct *sig;\n\n\tif (clone_flags & CLONE_THREAD)\n\t\treturn 0;\n\n\tsig = kmem_cache_zalloc(signal_cachep, GFP_KERNEL);\n\ttsk->signal = sig;\n\tif (!sig)\n\t\treturn -ENOMEM;\n\n\tsig->nr_threads = 1;\n\tatomic_set(&sig->live, 1);\n\trefcount_set(&sig->sigcnt, 1);\n\n\t/* list_add(thread_node, thread_head) without INIT_LIST_HEAD() */\n\tsig->thread_head = (struct list_head)LIST_HEAD_INIT(tsk->thread_node);\n\ttsk->thread_node = (struct list_head)LIST_HEAD_INIT(sig->thread_head);\n\n\tinit_waitqueue_head(&sig->wait_chldexit);\n\tsig->curr_target = tsk;\n\tinit_sigpending(&sig->shared_pending);\n\tINIT_HLIST_HEAD(&sig->multiprocess);\n\tseqlock_init(&sig->stats_lock);\n\tprev_cputime_init(&sig->prev_cputime);\n\n#ifdef CONFIG_POSIX_TIMERS\n\tINIT_LIST_HEAD(&sig->posix_timers);\n\thrtimer_init(&sig->real_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);\n\tsig->real_timer.function = it_real_fn;\n#endif\n\n\ttask_lock(current->group_leader);\n\tmemcpy(sig->rlim, current->signal->rlim, sizeof sig->rlim);\n\ttask_unlock(current->group_leader);\n\n\tposix_cpu_timers_init_group(sig);\n\n\ttty_audit_fork(sig);\n\tsched_autogroup_fork(sig);\n\n\tsig->oom_score_adj = current->signal->oom_score_adj;\n\tsig->oom_score_adj_min = current->signal->oom_score_adj_min;\n\n\tmutex_init(&sig->cred_guard_mutex);\n\tmutex_init(&sig->exec_update_mutex);\n\n\treturn 0;\n}\n\nstatic void copy_seccomp(struct task_struct *p)\n{\n#ifdef CONFIG_SECCOMP\n\t/*\n\t * Must be called with sighand->lock held, which is common to\n\t * all threads in the group. Holding cred_guard_mutex is not\n\t * needed because this new task is not yet running and cannot\n\t * be racing exec.\n\t */\n\tassert_spin_locked(&current->sighand->siglock);\n\n\t/* Ref-count the new filter user, and assign it. */\n\tget_seccomp_filter(current);\n\tp->seccomp = current->seccomp;\n\n\t/*\n\t * Explicitly enable no_new_privs here in case it got set\n\t * between the task_struct being duplicated and holding the\n\t * sighand lock. The seccomp state and nnp must be in sync.\n\t */\n\tif (task_no_new_privs(current))\n\t\ttask_set_no_new_privs(p);\n\n\t/*\n\t * If the parent gained a seccomp mode after copying thread\n\t * flags and between before we held the sighand lock, we have\n\t * to manually enable the seccomp thread flag here.\n\t */\n\tif (p->seccomp.mode != SECCOMP_MODE_DISABLED)\n\t\tset_tsk_thread_flag(p, TIF_SECCOMP);\n#endif\n}\n\nSYSCALL_DEFINE1(set_tid_address, int __user *, tidptr)\n{\n\tcurrent->clear_child_tid = tidptr;\n\n\treturn task_pid_vnr(current);\n}\n\nstatic void rt_mutex_init_task(struct task_struct *p)\n{\n\traw_spin_lock_init(&p->pi_lock);\n#ifdef CONFIG_RT_MUTEXES\n\tp->pi_waiters = RB_ROOT_CACHED;\n\tp->pi_top_task = NULL;\n\tp->pi_blocked_on = NULL;\n#endif\n}\n\nstatic inline void init_task_pid_links(struct task_struct *task)\n{\n\tenum pid_type type;\n\n\tfor (type = PIDTYPE_PID; type < PIDTYPE_MAX; ++type) {\n\t\tINIT_HLIST_NODE(&task->pid_links[type]);\n\t}\n}\n\nstatic inline void\ninit_task_pid(struct task_struct *task, enum pid_type type, struct pid *pid)\n{\n\tif (type == PIDTYPE_PID)\n\t\ttask->thread_pid = pid;\n\telse\n\t\ttask->signal->pids[type] = pid;\n}\n\nstatic inline void rcu_copy_process(struct task_struct *p)\n{\n#ifdef CONFIG_PREEMPT_RCU\n\tp->rcu_read_lock_nesting = 0;\n\tp->rcu_read_unlock_special.s = 0;\n\tp->rcu_blocked_node = NULL;\n\tINIT_LIST_HEAD(&p->rcu_node_entry);\n#endif /* #ifdef CONFIG_PREEMPT_RCU */\n#ifdef CONFIG_TASKS_RCU\n\tp->rcu_tasks_holdout = false;\n\tINIT_LIST_HEAD(&p->rcu_tasks_holdout_list);\n\tp->rcu_tasks_idle_cpu = -1;\n#endif /* #ifdef CONFIG_TASKS_RCU */\n#ifdef CONFIG_TASKS_TRACE_RCU\n\tp->trc_reader_nesting = 0;\n\tp->trc_reader_special.s = 0;\n\tINIT_LIST_HEAD(&p->trc_holdout_list);\n#endif /* #ifdef CONFIG_TASKS_TRACE_RCU */\n}\n\nstruct pid *pidfd_pid(const struct file *file)\n{\n\tif (file->f_op == &pidfd_fops)\n\t\treturn file->private_data;\n\n\treturn ERR_PTR(-EBADF);\n}\n\nstatic int pidfd_release(struct inode *inode, struct file *file)\n{\n\tstruct pid *pid = file->private_data;\n\n\tfile->private_data = NULL;\n\tput_pid(pid);\n\treturn 0;\n}\n\n#ifdef CONFIG_PROC_FS\n/**\n * pidfd_show_fdinfo - print information about a pidfd\n * @m: proc fdinfo file\n * @f: file referencing a pidfd\n *\n * Pid:\n * This function will print the pid that a given pidfd refers to in the\n * pid namespace of the procfs instance.\n * If the pid namespace of the process is not a descendant of the pid\n * namespace of the procfs instance 0 will be shown as its pid. This is\n * similar to calling getppid() on a process whose parent is outside of\n * its pid namespace.\n *\n * NSpid:\n * If pid namespaces are supported then this function will also print\n * the pid of a given pidfd refers to for all descendant pid namespaces\n * starting from the current pid namespace of the instance, i.e. the\n * Pid field and the first entry in the NSpid field will be identical.\n * If the pid namespace of the process is not a descendant of the pid\n * namespace of the procfs instance 0 will be shown as its first NSpid\n * entry and no others will be shown.\n * Note that this differs from the Pid and NSpid fields in\n * /proc/<pid>/status where Pid and NSpid are always shown relative to\n * the  pid namespace of the procfs instance. The difference becomes\n * obvious when sending around a pidfd between pid namespaces from a\n * different branch of the tree, i.e. where no ancestoral relation is\n * present between the pid namespaces:\n * - create two new pid namespaces ns1 and ns2 in the initial pid\n *   namespace (also take care to create new mount namespaces in the\n *   new pid namespace and mount procfs)\n * - create a process with a pidfd in ns1\n * - send pidfd from ns1 to ns2\n * - read /proc/self/fdinfo/<pidfd> and observe that both Pid and NSpid\n *   have exactly one entry, which is 0\n */\nstatic void pidfd_show_fdinfo(struct seq_file *m, struct file *f)\n{\n\tstruct pid *pid = f->private_data;\n\tstruct pid_namespace *ns;\n\tpid_t nr = -1;\n\n\tif (likely(pid_has_task(pid, PIDTYPE_PID))) {\n\t\tns = proc_pid_ns(file_inode(m->file)->i_sb);\n\t\tnr = pid_nr_ns(pid, ns);\n\t}\n\n\tseq_put_decimal_ll(m, \"Pid:\\t\", nr);\n\n#ifdef CONFIG_PID_NS\n\tseq_put_decimal_ll(m, \"\\nNSpid:\\t\", nr);\n\tif (nr > 0) {\n\t\tint i;\n\n\t\t/* If nr is non-zero it means that 'pid' is valid and that\n\t\t * ns, i.e. the pid namespace associated with the procfs\n\t\t * instance, is in the pid namespace hierarchy of pid.\n\t\t * Start at one below the already printed level.\n\t\t */\n\t\tfor (i = ns->level + 1; i <= pid->level; i++)\n\t\t\tseq_put_decimal_ll(m, \"\\t\", pid->numbers[i].nr);\n\t}\n#endif\n\tseq_putc(m, '\\n');\n}\n#endif\n\n/*\n * Poll support for process exit notification.\n */\nstatic __poll_t pidfd_poll(struct file *file, struct poll_table_struct *pts)\n{\n\tstruct pid *pid = file->private_data;\n\t__poll_t poll_flags = 0;\n\n\tpoll_wait(file, &pid->wait_pidfd, pts);\n\n\t/*\n\t * Inform pollers only when the whole thread group exits.\n\t * If the thread group leader exits before all other threads in the\n\t * group, then poll(2) should block, similar to the wait(2) family.\n\t */\n\tif (thread_group_exited(pid))\n\t\tpoll_flags = EPOLLIN | EPOLLRDNORM;\n\n\treturn poll_flags;\n}\n\nconst struct file_operations pidfd_fops = {\n\t.release = pidfd_release,\n\t.poll = pidfd_poll,\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo = pidfd_show_fdinfo,\n#endif\n};\n\nstatic void __delayed_free_task(struct rcu_head *rhp)\n{\n\tstruct task_struct *tsk = container_of(rhp, struct task_struct, rcu);\n\n\tfree_task(tsk);\n}\n\nstatic __always_inline void delayed_free_task(struct task_struct *tsk)\n{\n\tif (IS_ENABLED(CONFIG_MEMCG))\n\t\tcall_rcu(&tsk->rcu, __delayed_free_task);\n\telse\n\t\tfree_task(tsk);\n}\n\nstatic void copy_oom_score_adj(u64 clone_flags, struct task_struct *tsk)\n{\n\t/* Skip if kernel thread */\n\tif (!tsk->mm)\n\t\treturn;\n\n\t/* Skip if spawning a thread or using vfork */\n\tif ((clone_flags & (CLONE_VM | CLONE_THREAD | CLONE_VFORK)) != CLONE_VM)\n\t\treturn;\n\n\t/* We need to synchronize with __set_oom_adj */\n\tmutex_lock(&oom_adj_mutex);\n\tset_bit(MMF_MULTIPROCESS, &tsk->mm->flags);\n\t/* Update the values in case they were changed after copy_signal */\n\ttsk->signal->oom_score_adj = current->signal->oom_score_adj;\n\ttsk->signal->oom_score_adj_min = current->signal->oom_score_adj_min;\n\tmutex_unlock(&oom_adj_mutex);\n}\n\n/*\n * This creates a new process as a copy of the old one,\n * but does not actually start it yet.\n *\n * It copies the registers, and all the appropriate\n * parts of the process environment (as per the clone\n * flags). The actual kick-off is left to the caller.\n */\nstatic __latent_entropy struct task_struct *copy_process(\n\t\t\t\t\tstruct pid *pid,\n\t\t\t\t\tint trace,\n\t\t\t\t\tint node,\n\t\t\t\t\tstruct kernel_clone_args *args)\n{\n\tint pidfd = -1, retval;\n\tstruct task_struct *p;\n\tstruct multiprocess_signals delayed;\n\tstruct file *pidfile = NULL;\n\tu64 clone_flags = args->flags;\n\tstruct nsproxy *nsp = current->nsproxy;\n\n\t/*\n\t * Don't allow sharing the root directory with processes in a different\n\t * namespace\n\t */\n\tif ((clone_flags & (CLONE_NEWNS|CLONE_FS)) == (CLONE_NEWNS|CLONE_FS))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif ((clone_flags & (CLONE_NEWUSER|CLONE_FS)) == (CLONE_NEWUSER|CLONE_FS))\n\t\treturn ERR_PTR(-EINVAL);\n\n\t/*\n\t * Thread groups must share signals as well, and detached threads\n\t * can only be started up within the thread group.\n\t */\n\tif ((clone_flags & CLONE_THREAD) && !(clone_flags & CLONE_SIGHAND))\n\t\treturn ERR_PTR(-EINVAL);\n\n\t/*\n\t * Shared signal handlers imply shared VM. By way of the above,\n\t * thread groups also imply shared VM. Blocking this case allows\n\t * for various simplifications in other code.\n\t */\n\tif ((clone_flags & CLONE_SIGHAND) && !(clone_flags & CLONE_VM))\n\t\treturn ERR_PTR(-EINVAL);\n\n\t/*\n\t * Siblings of global init remain as zombies on exit since they are\n\t * not reaped by their parent (swapper). To solve this and to avoid\n\t * multi-rooted process trees, prevent global and container-inits\n\t * from creating siblings.\n\t */\n\tif ((clone_flags & CLONE_PARENT) &&\n\t\t\t\tcurrent->signal->flags & SIGNAL_UNKILLABLE)\n\t\treturn ERR_PTR(-EINVAL);\n\n\t/*\n\t * If the new process will be in a different pid or user namespace\n\t * do not allow it to share a thread group with the forking task.\n\t */\n\tif (clone_flags & CLONE_THREAD) {\n\t\tif ((clone_flags & (CLONE_NEWUSER | CLONE_NEWPID)) ||\n\t\t    (task_active_pid_ns(current) != nsp->pid_ns_for_children))\n\t\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\t/*\n\t * If the new process will be in a different time namespace\n\t * do not allow it to share VM or a thread group with the forking task.\n\t */\n\tif (clone_flags & (CLONE_THREAD | CLONE_VM)) {\n\t\tif (nsp->time_ns != nsp->time_ns_for_children)\n\t\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tif (clone_flags & CLONE_PIDFD) {\n\t\t/*\n\t\t * - CLONE_DETACHED is blocked so that we can potentially\n\t\t *   reuse it later for CLONE_PIDFD.\n\t\t * - CLONE_THREAD is blocked until someone really needs it.\n\t\t */\n\t\tif (clone_flags & (CLONE_DETACHED | CLONE_THREAD))\n\t\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\t/*\n\t * Force any signals received before this point to be delivered\n\t * before the fork happens.  Collect up signals sent to multiple\n\t * processes that happen during the fork and delay them so that\n\t * they appear to happen after the fork.\n\t */\n\tsigemptyset(&delayed.signal);\n\tINIT_HLIST_NODE(&delayed.node);\n\n\tspin_lock_irq(&current->sighand->siglock);\n\tif (!(clone_flags & CLONE_THREAD))\n\t\thlist_add_head(&delayed.node, &current->signal->multiprocess);\n\trecalc_sigpending();\n\tspin_unlock_irq(&current->sighand->siglock);\n\tretval = -ERESTARTNOINTR;\n\tif (signal_pending(current))\n\t\tgoto fork_out;\n\n\tretval = -ENOMEM;\n\tp = dup_task_struct(current, node);\n\tif (!p)\n\t\tgoto fork_out;\n\n\t/*\n\t * This _must_ happen before we call free_task(), i.e. before we jump\n\t * to any of the bad_fork_* labels. This is to avoid freeing\n\t * p->set_child_tid which is (ab)used as a kthread's data pointer for\n\t * kernel threads (PF_KTHREAD).\n\t */\n\tp->set_child_tid = (clone_flags & CLONE_CHILD_SETTID) ? args->child_tid : NULL;\n\t/*\n\t * Clear TID on mm_release()?\n\t */\n\tp->clear_child_tid = (clone_flags & CLONE_CHILD_CLEARTID) ? args->child_tid : NULL;\n\n\tftrace_graph_init_task(p);\n\n\trt_mutex_init_task(p);\n\n\tlockdep_assert_irqs_enabled();\n#ifdef CONFIG_PROVE_LOCKING\n\tDEBUG_LOCKS_WARN_ON(!p->softirqs_enabled);\n#endif\n\tretval = -EAGAIN;\n\tif (atomic_read(&p->real_cred->user->processes) >=\n\t\t\ttask_rlimit(p, RLIMIT_NPROC)) {\n\t\tif (p->real_cred->user != INIT_USER &&\n\t\t    !capable(CAP_SYS_RESOURCE) && !capable(CAP_SYS_ADMIN))\n\t\t\tgoto bad_fork_free;\n\t}\n\tcurrent->flags &= ~PF_NPROC_EXCEEDED;\n\n\tretval = copy_creds(p, clone_flags);\n\tif (retval < 0)\n\t\tgoto bad_fork_free;\n\n\t/*\n\t * If multiple threads are within copy_process(), then this check\n\t * triggers too late. This doesn't hurt, the check is only there\n\t * to stop root fork bombs.\n\t */\n\tretval = -EAGAIN;\n\tif (data_race(nr_threads >= max_threads))\n\t\tgoto bad_fork_cleanup_count;\n\n\tdelayacct_tsk_init(p);\t/* Must remain after dup_task_struct() */\n\tp->flags &= ~(PF_SUPERPRIV | PF_WQ_WORKER | PF_IDLE);\n\tp->flags |= PF_FORKNOEXEC;\n\tINIT_LIST_HEAD(&p->children);\n\tINIT_LIST_HEAD(&p->sibling);\n\trcu_copy_process(p);\n\tp->vfork_done = NULL;\n\tspin_lock_init(&p->alloc_lock);\n\n\tinit_sigpending(&p->pending);\n\n\tp->utime = p->stime = p->gtime = 0;\n#ifdef CONFIG_ARCH_HAS_SCALED_CPUTIME\n\tp->utimescaled = p->stimescaled = 0;\n#endif\n\tprev_cputime_init(&p->prev_cputime);\n\n#ifdef CONFIG_VIRT_CPU_ACCOUNTING_GEN\n\tseqcount_init(&p->vtime.seqcount);\n\tp->vtime.starttime = 0;\n\tp->vtime.state = VTIME_INACTIVE;\n#endif\n\n#ifdef CONFIG_IO_URING\n\tp->io_uring = NULL;\n#endif\n\n#if defined(SPLIT_RSS_COUNTING)\n\tmemset(&p->rss_stat, 0, sizeof(p->rss_stat));\n#endif\n\n\tp->default_timer_slack_ns = current->timer_slack_ns;\n\n#ifdef CONFIG_PSI\n\tp->psi_flags = 0;\n#endif\n\n\ttask_io_accounting_init(&p->ioac);\n\tacct_clear_integrals(p);\n\n\tposix_cputimers_init(&p->posix_cputimers);\n\n\tp->io_context = NULL;\n\taudit_set_context(p, NULL);\n\tcgroup_fork(p);\n#ifdef CONFIG_NUMA\n\tp->mempolicy = mpol_dup(p->mempolicy);\n\tif (IS_ERR(p->mempolicy)) {\n\t\tretval = PTR_ERR(p->mempolicy);\n\t\tp->mempolicy = NULL;\n\t\tgoto bad_fork_cleanup_threadgroup_lock;\n\t}\n#endif\n#ifdef CONFIG_CPUSETS\n\tp->cpuset_mem_spread_rotor = NUMA_NO_NODE;\n\tp->cpuset_slab_spread_rotor = NUMA_NO_NODE;\n\tseqcount_spinlock_init(&p->mems_allowed_seq, &p->alloc_lock);\n#endif\n#ifdef CONFIG_TRACE_IRQFLAGS\n\tmemset(&p->irqtrace, 0, sizeof(p->irqtrace));\n\tp->irqtrace.hardirq_disable_ip\t= _THIS_IP_;\n\tp->irqtrace.softirq_enable_ip\t= _THIS_IP_;\n\tp->softirqs_enabled\t\t= 1;\n\tp->softirq_context\t\t= 0;\n#endif\n\n\tp->pagefault_disabled = 0;\n\n#ifdef CONFIG_LOCKDEP\n\tlockdep_init_task(p);\n#endif\n\n#ifdef CONFIG_DEBUG_MUTEXES\n\tp->blocked_on = NULL; /* not blocked yet */\n#endif\n#ifdef CONFIG_BCACHE\n\tp->sequential_io\t= 0;\n\tp->sequential_io_avg\t= 0;\n#endif\n\n\t/* Perform scheduler related setup. Assign this task to a CPU. */\n\tretval = sched_fork(clone_flags, p);\n\tif (retval)\n\t\tgoto bad_fork_cleanup_policy;\n\n\tretval = perf_event_init_task(p);\n\tif (retval)\n\t\tgoto bad_fork_cleanup_policy;\n\tretval = audit_alloc(p);\n\tif (retval)\n\t\tgoto bad_fork_cleanup_perf;\n\t/* copy all the process information */\n\tshm_init_task(p);\n\tretval = security_task_alloc(p, clone_flags);\n\tif (retval)\n\t\tgoto bad_fork_cleanup_audit;\n\tretval = copy_semundo(clone_flags, p);\n\tif (retval)\n\t\tgoto bad_fork_cleanup_security;\n\tretval = copy_files(clone_flags, p);\n\tif (retval)\n\t\tgoto bad_fork_cleanup_semundo;\n\tretval = copy_fs(clone_flags, p);\n\tif (retval)\n\t\tgoto bad_fork_cleanup_files;\n\tretval = copy_sighand(clone_flags, p);\n\tif (retval)\n\t\tgoto bad_fork_cleanup_fs;\n\tretval = copy_signal(clone_flags, p);\n\tif (retval)\n\t\tgoto bad_fork_cleanup_sighand;\n\tretval = copy_mm(clone_flags, p);\n\tif (retval)\n\t\tgoto bad_fork_cleanup_signal;\n\tretval = copy_namespaces(clone_flags, p);\n\tif (retval)\n\t\tgoto bad_fork_cleanup_mm;\n\tretval = copy_io(clone_flags, p);\n\tif (retval)\n\t\tgoto bad_fork_cleanup_namespaces;\n\tretval = copy_thread(clone_flags, args->stack, args->stack_size, p, args->tls);\n\tif (retval)\n\t\tgoto bad_fork_cleanup_io;\n\n\tstackleak_task_init(p);\n\n\tif (pid != &init_struct_pid) {\n\t\tpid = alloc_pid(p->nsproxy->pid_ns_for_children, args->set_tid,\n\t\t\t\targs->set_tid_size);\n\t\tif (IS_ERR(pid)) {\n\t\t\tretval = PTR_ERR(pid);\n\t\t\tgoto bad_fork_cleanup_thread;\n\t\t}\n\t}\n\n\t/*\n\t * This has to happen after we've potentially unshared the file\n\t * descriptor table (so that the pidfd doesn't leak into the child\n\t * if the fd table isn't shared).\n\t */\n\tif (clone_flags & CLONE_PIDFD) {\n\t\tretval = get_unused_fd_flags(O_RDWR | O_CLOEXEC);\n\t\tif (retval < 0)\n\t\t\tgoto bad_fork_free_pid;\n\n\t\tpidfd = retval;\n\n\t\tpidfile = anon_inode_getfile(\"[pidfd]\", &pidfd_fops, pid,\n\t\t\t\t\t      O_RDWR | O_CLOEXEC);\n\t\tif (IS_ERR(pidfile)) {\n\t\t\tput_unused_fd(pidfd);\n\t\t\tretval = PTR_ERR(pidfile);\n\t\t\tgoto bad_fork_free_pid;\n\t\t}\n\t\tget_pid(pid);\t/* held by pidfile now */\n\n\t\tretval = put_user(pidfd, args->pidfd);\n\t\tif (retval)\n\t\t\tgoto bad_fork_put_pidfd;\n\t}\n\n#ifdef CONFIG_BLOCK\n\tp->plug = NULL;\n#endif\n\tfutex_init_task(p);\n\n\t/*\n\t * sigaltstack should be cleared when sharing the same VM\n\t */\n\tif ((clone_flags & (CLONE_VM|CLONE_VFORK)) == CLONE_VM)\n\t\tsas_ss_reset(p);\n\n\t/*\n\t * Syscall tracing and stepping should be turned off in the\n\t * child regardless of CLONE_PTRACE.\n\t */\n\tuser_disable_single_step(p);\n\tclear_tsk_thread_flag(p, TIF_SYSCALL_TRACE);\n#ifdef TIF_SYSCALL_EMU\n\tclear_tsk_thread_flag(p, TIF_SYSCALL_EMU);\n#endif\n\tclear_tsk_latency_tracing(p);\n\n\t/* ok, now we should be set up.. */\n\tp->pid = pid_nr(pid);\n\tif (clone_flags & CLONE_THREAD) {\n\t\tp->exit_signal = -1;\n\t\tp->group_leader = current->group_leader;\n\t\tp->tgid = current->tgid;\n\t} else {\n\t\tif (clone_flags & CLONE_PARENT)\n\t\t\tp->exit_signal = current->group_leader->exit_signal;\n\t\telse\n\t\t\tp->exit_signal = args->exit_signal;\n\t\tp->group_leader = p;\n\t\tp->tgid = p->pid;\n\t}\n\n\tp->nr_dirtied = 0;\n\tp->nr_dirtied_pause = 128 >> (PAGE_SHIFT - 10);\n\tp->dirty_paused_when = 0;\n\n\tp->pdeath_signal = 0;\n\tINIT_LIST_HEAD(&p->thread_group);\n\tp->task_works = NULL;\n\n\t/*\n\t * Ensure that the cgroup subsystem policies allow the new process to be\n\t * forked. It should be noted that the new process's css_set can be changed\n\t * between here and cgroup_post_fork() if an organisation operation is in\n\t * progress.\n\t */\n\tretval = cgroup_can_fork(p, args);\n\tif (retval)\n\t\tgoto bad_fork_put_pidfd;\n\n\t/*\n\t * From this point on we must avoid any synchronous user-space\n\t * communication until we take the tasklist-lock. In particular, we do\n\t * not want user-space to be able to predict the process start-time by\n\t * stalling fork(2) after we recorded the start_time but before it is\n\t * visible to the system.\n\t */\n\n\tp->start_time = ktime_get_ns();\n\tp->start_boottime = ktime_get_boottime_ns();\n\n\t/*\n\t * Make it visible to the rest of the system, but dont wake it up yet.\n\t * Need tasklist lock for parent etc handling!\n\t */\n\twrite_lock_irq(&tasklist_lock);\n\n\t/* CLONE_PARENT re-uses the old parent */\n\tif (clone_flags & (CLONE_PARENT|CLONE_THREAD)) {\n\t\tp->real_parent = current->real_parent;\n\t\tp->parent_exec_id = current->parent_exec_id;\n\t} else {\n\t\tp->real_parent = current;\n\t\tp->parent_exec_id = current->self_exec_id;\n\t}\n\n\tklp_copy_process(p);\n\n\tspin_lock(&current->sighand->siglock);\n\n\t/*\n\t * Copy seccomp details explicitly here, in case they were changed\n\t * before holding sighand lock.\n\t */\n\tcopy_seccomp(p);\n\n\trseq_fork(p, clone_flags);\n\n\t/* Don't start children in a dying pid namespace */\n\tif (unlikely(!(ns_of_pid(pid)->pid_allocated & PIDNS_ADDING))) {\n\t\tretval = -ENOMEM;\n\t\tgoto bad_fork_cancel_cgroup;\n\t}\n\n\t/* Let kill terminate clone/fork in the middle */\n\tif (fatal_signal_pending(current)) {\n\t\tretval = -EINTR;\n\t\tgoto bad_fork_cancel_cgroup;\n\t}\n\n\t/* past the last point of failure */\n\tif (pidfile)\n\t\tfd_install(pidfd, pidfile);\n\n\tinit_task_pid_links(p);\n\tif (likely(p->pid)) {\n\t\tptrace_init_task(p, (clone_flags & CLONE_PTRACE) || trace);\n\n\t\tinit_task_pid(p, PIDTYPE_PID, pid);\n\t\tif (thread_group_leader(p)) {\n\t\t\tinit_task_pid(p, PIDTYPE_TGID, pid);\n\t\t\tinit_task_pid(p, PIDTYPE_PGID, task_pgrp(current));\n\t\t\tinit_task_pid(p, PIDTYPE_SID, task_session(current));\n\n\t\t\tif (is_child_reaper(pid)) {\n\t\t\t\tns_of_pid(pid)->child_reaper = p;\n\t\t\t\tp->signal->flags |= SIGNAL_UNKILLABLE;\n\t\t\t}\n\t\t\tp->signal->shared_pending.signal = delayed.signal;\n\t\t\tp->signal->tty = tty_kref_get(current->signal->tty);\n\t\t\t/*\n\t\t\t * Inherit has_child_subreaper flag under the same\n\t\t\t * tasklist_lock with adding child to the process tree\n\t\t\t * for propagate_has_child_subreaper optimization.\n\t\t\t */\n\t\t\tp->signal->has_child_subreaper = p->real_parent->signal->has_child_subreaper ||\n\t\t\t\t\t\t\t p->real_parent->signal->is_child_subreaper;\n\t\t\tlist_add_tail(&p->sibling, &p->real_parent->children);\n\t\t\tlist_add_tail_rcu(&p->tasks, &init_task.tasks);\n\t\t\tattach_pid(p, PIDTYPE_TGID);\n\t\t\tattach_pid(p, PIDTYPE_PGID);\n\t\t\tattach_pid(p, PIDTYPE_SID);\n\t\t\t__this_cpu_inc(process_counts);\n\t\t} else {\n\t\t\tcurrent->signal->nr_threads++;\n\t\t\tatomic_inc(&current->signal->live);\n\t\t\trefcount_inc(&current->signal->sigcnt);\n\t\t\ttask_join_group_stop(p);\n\t\t\tlist_add_tail_rcu(&p->thread_group,\n\t\t\t\t\t  &p->group_leader->thread_group);\n\t\t\tlist_add_tail_rcu(&p->thread_node,\n\t\t\t\t\t  &p->signal->thread_head);\n\t\t}\n\t\tattach_pid(p, PIDTYPE_PID);\n\t\tnr_threads++;\n\t}\n\ttotal_forks++;\n\thlist_del_init(&delayed.node);\n\tspin_unlock(&current->sighand->siglock);\n\tsyscall_tracepoint_update(p);\n\twrite_unlock_irq(&tasklist_lock);\n\n\tproc_fork_connector(p);\n\tsched_post_fork(p);\n\tcgroup_post_fork(p, args);\n\tperf_event_fork(p);\n\n\ttrace_task_newtask(p, clone_flags);\n\tuprobe_copy_process(p, clone_flags);\n\n\tcopy_oom_score_adj(clone_flags, p);\n\n\treturn p;\n\nbad_fork_cancel_cgroup:\n\tspin_unlock(&current->sighand->siglock);\n\twrite_unlock_irq(&tasklist_lock);\n\tcgroup_cancel_fork(p, args);\nbad_fork_put_pidfd:\n\tif (clone_flags & CLONE_PIDFD) {\n\t\tfput(pidfile);\n\t\tput_unused_fd(pidfd);\n\t}\nbad_fork_free_pid:\n\tif (pid != &init_struct_pid)\n\t\tfree_pid(pid);\nbad_fork_cleanup_thread:\n\texit_thread(p);\nbad_fork_cleanup_io:\n\tif (p->io_context)\n\t\texit_io_context(p);\nbad_fork_cleanup_namespaces:\n\texit_task_namespaces(p);\nbad_fork_cleanup_mm:\n\tif (p->mm) {\n\t\tmm_clear_owner(p->mm, p);\n\t\tmmput(p->mm);\n\t}\nbad_fork_cleanup_signal:\n\tif (!(clone_flags & CLONE_THREAD))\n\t\tfree_signal_struct(p->signal);\nbad_fork_cleanup_sighand:\n\t__cleanup_sighand(p->sighand);\nbad_fork_cleanup_fs:\n\texit_fs(p); /* blocking */\nbad_fork_cleanup_files:\n\texit_files(p); /* blocking */\nbad_fork_cleanup_semundo:\n\texit_sem(p);\nbad_fork_cleanup_security:\n\tsecurity_task_free(p);\nbad_fork_cleanup_audit:\n\taudit_free(p);\nbad_fork_cleanup_perf:\n\tperf_event_free_task(p);\nbad_fork_cleanup_policy:\n\tlockdep_free_task(p);\n#ifdef CONFIG_NUMA\n\tmpol_put(p->mempolicy);\nbad_fork_cleanup_threadgroup_lock:\n#endif\n\tdelayacct_tsk_free(p);\nbad_fork_cleanup_count:\n\tatomic_dec(&p->cred->user->processes);\n\texit_creds(p);\nbad_fork_free:\n\tp->state = TASK_DEAD;\n\tput_task_stack(p);\n\tdelayed_free_task(p);\nfork_out:\n\tspin_lock_irq(&current->sighand->siglock);\n\thlist_del_init(&delayed.node);\n\tspin_unlock_irq(&current->sighand->siglock);\n\treturn ERR_PTR(retval);\n}\n\nstatic inline void init_idle_pids(struct task_struct *idle)\n{\n\tenum pid_type type;\n\n\tfor (type = PIDTYPE_PID; type < PIDTYPE_MAX; ++type) {\n\t\tINIT_HLIST_NODE(&idle->pid_links[type]); /* not really needed */\n\t\tinit_task_pid(idle, type, &init_struct_pid);\n\t}\n}\n\nstruct task_struct *fork_idle(int cpu)\n{\n\tstruct task_struct *task;\n\tstruct kernel_clone_args args = {\n\t\t.flags = CLONE_VM,\n\t};\n\n\ttask = copy_process(&init_struct_pid, 0, cpu_to_node(cpu), &args);\n\tif (!IS_ERR(task)) {\n\t\tinit_idle_pids(task);\n\t\tinit_idle(task, cpu);\n\t}\n\n\treturn task;\n}\n\nstruct mm_struct *copy_init_mm(void)\n{\n\treturn dup_mm(NULL, &init_mm);\n}\n\n/*\n *  Ok, this is the main fork-routine.\n *\n * It copies the process, and if successful kick-starts\n * it and waits for it to finish using the VM if required.\n *\n * args->exit_signal is expected to be checked for sanity by the caller.\n */\npid_t kernel_clone(struct kernel_clone_args *args)\n{\n\tu64 clone_flags = args->flags;\n\tstruct completion vfork;\n\tstruct pid *pid;\n\tstruct task_struct *p;\n\tint trace = 0;\n\tpid_t nr;\n\n\t/*\n\t * For legacy clone() calls, CLONE_PIDFD uses the parent_tid argument\n\t * to return the pidfd. Hence, CLONE_PIDFD and CLONE_PARENT_SETTID are\n\t * mutually exclusive. With clone3() CLONE_PIDFD has grown a separate\n\t * field in struct clone_args and it still doesn't make sense to have\n\t * them both point at the same memory location. Performing this check\n\t * here has the advantage that we don't need to have a separate helper\n\t * to check for legacy clone().\n\t */\n\tif ((args->flags & CLONE_PIDFD) &&\n\t    (args->flags & CLONE_PARENT_SETTID) &&\n\t    (args->pidfd == args->parent_tid))\n\t\treturn -EINVAL;\n\n\t/*\n\t * Determine whether and which event to report to ptracer.  When\n\t * called from kernel_thread or CLONE_UNTRACED is explicitly\n\t * requested, no event is reported; otherwise, report if the event\n\t * for the type of forking is enabled.\n\t */\n\tif (!(clone_flags & CLONE_UNTRACED)) {\n\t\tif (clone_flags & CLONE_VFORK)\n\t\t\ttrace = PTRACE_EVENT_VFORK;\n\t\telse if (args->exit_signal != SIGCHLD)\n\t\t\ttrace = PTRACE_EVENT_CLONE;\n\t\telse\n\t\t\ttrace = PTRACE_EVENT_FORK;\n\n\t\tif (likely(!ptrace_event_enabled(current, trace)))\n\t\t\ttrace = 0;\n\t}\n\n\tp = copy_process(NULL, trace, NUMA_NO_NODE, args);\n\tadd_latent_entropy();\n\n\tif (IS_ERR(p))\n\t\treturn PTR_ERR(p);\n\n\t/*\n\t * Do this prior waking up the new thread - the thread pointer\n\t * might get invalid after that point, if the thread exits quickly.\n\t */\n\ttrace_sched_process_fork(current, p);\n\n\tpid = get_task_pid(p, PIDTYPE_PID);\n\tnr = pid_vnr(pid);\n\n\tif (clone_flags & CLONE_PARENT_SETTID)\n\t\tput_user(nr, args->parent_tid);\n\n\tif (clone_flags & CLONE_VFORK) {\n\t\tp->vfork_done = &vfork;\n\t\tinit_completion(&vfork);\n\t\tget_task_struct(p);\n\t}\n\n\twake_up_new_task(p);\n\n\t/* forking complete and child started to run, tell ptracer */\n\tif (unlikely(trace))\n\t\tptrace_event_pid(trace, pid);\n\n\tif (clone_flags & CLONE_VFORK) {\n\t\tif (!wait_for_vfork_done(p, &vfork))\n\t\t\tptrace_event_pid(PTRACE_EVENT_VFORK_DONE, pid);\n\t}\n\n\tput_pid(pid);\n\treturn nr;\n}\n\n/*\n * Create a kernel thread.\n */\npid_t kernel_thread(int (*fn)(void *), void *arg, unsigned long flags)\n{\n\tstruct kernel_clone_args args = {\n\t\t.flags\t\t= ((lower_32_bits(flags) | CLONE_VM |\n\t\t\t\t    CLONE_UNTRACED) & ~CSIGNAL),\n\t\t.exit_signal\t= (lower_32_bits(flags) & CSIGNAL),\n\t\t.stack\t\t= (unsigned long)fn,\n\t\t.stack_size\t= (unsigned long)arg,\n\t};\n\n\treturn kernel_clone(&args);\n}\n\n#ifdef __ARCH_WANT_SYS_FORK\nSYSCALL_DEFINE0(fork)\n{\n#ifdef CONFIG_MMU\n\tstruct kernel_clone_args args = {\n\t\t.exit_signal = SIGCHLD,\n\t};\n\n\treturn kernel_clone(&args);\n#else\n\t/* can not support in nommu mode */\n\treturn -EINVAL;\n#endif\n}\n#endif\n\n#ifdef __ARCH_WANT_SYS_VFORK\nSYSCALL_DEFINE0(vfork)\n{\n\tstruct kernel_clone_args args = {\n\t\t.flags\t\t= CLONE_VFORK | CLONE_VM,\n\t\t.exit_signal\t= SIGCHLD,\n\t};\n\n\treturn kernel_clone(&args);\n}\n#endif\n\n#ifdef __ARCH_WANT_SYS_CLONE\n#ifdef CONFIG_CLONE_BACKWARDS\nSYSCALL_DEFINE5(clone, unsigned long, clone_flags, unsigned long, newsp,\n\t\t int __user *, parent_tidptr,\n\t\t unsigned long, tls,\n\t\t int __user *, child_tidptr)\n#elif defined(CONFIG_CLONE_BACKWARDS2)\nSYSCALL_DEFINE5(clone, unsigned long, newsp, unsigned long, clone_flags,\n\t\t int __user *, parent_tidptr,\n\t\t int __user *, child_tidptr,\n\t\t unsigned long, tls)\n#elif defined(CONFIG_CLONE_BACKWARDS3)\nSYSCALL_DEFINE6(clone, unsigned long, clone_flags, unsigned long, newsp,\n\t\tint, stack_size,\n\t\tint __user *, parent_tidptr,\n\t\tint __user *, child_tidptr,\n\t\tunsigned long, tls)\n#else\nSYSCALL_DEFINE5(clone, unsigned long, clone_flags, unsigned long, newsp,\n\t\t int __user *, parent_tidptr,\n\t\t int __user *, child_tidptr,\n\t\t unsigned long, tls)\n#endif\n{\n\tstruct kernel_clone_args args = {\n\t\t.flags\t\t= (lower_32_bits(clone_flags) & ~CSIGNAL),\n\t\t.pidfd\t\t= parent_tidptr,\n\t\t.child_tid\t= child_tidptr,\n\t\t.parent_tid\t= parent_tidptr,\n\t\t.exit_signal\t= (lower_32_bits(clone_flags) & CSIGNAL),\n\t\t.stack\t\t= newsp,\n\t\t.tls\t\t= tls,\n\t};\n\n\treturn kernel_clone(&args);\n}\n#endif\n\n#ifdef __ARCH_WANT_SYS_CLONE3\n\nnoinline static int copy_clone_args_from_user(struct kernel_clone_args *kargs,\n\t\t\t\t\t      struct clone_args __user *uargs,\n\t\t\t\t\t      size_t usize)\n{\n\tint err;\n\tstruct clone_args args;\n\tpid_t *kset_tid = kargs->set_tid;\n\n\tBUILD_BUG_ON(offsetofend(struct clone_args, tls) !=\n\t\t     CLONE_ARGS_SIZE_VER0);\n\tBUILD_BUG_ON(offsetofend(struct clone_args, set_tid_size) !=\n\t\t     CLONE_ARGS_SIZE_VER1);\n\tBUILD_BUG_ON(offsetofend(struct clone_args, cgroup) !=\n\t\t     CLONE_ARGS_SIZE_VER2);\n\tBUILD_BUG_ON(sizeof(struct clone_args) != CLONE_ARGS_SIZE_VER2);\n\n\tif (unlikely(usize > PAGE_SIZE))\n\t\treturn -E2BIG;\n\tif (unlikely(usize < CLONE_ARGS_SIZE_VER0))\n\t\treturn -EINVAL;\n\n\terr = copy_struct_from_user(&args, sizeof(args), uargs, usize);\n\tif (err)\n\t\treturn err;\n\n\tif (unlikely(args.set_tid_size > MAX_PID_NS_LEVEL))\n\t\treturn -EINVAL;\n\n\tif (unlikely(!args.set_tid && args.set_tid_size > 0))\n\t\treturn -EINVAL;\n\n\tif (unlikely(args.set_tid && args.set_tid_size == 0))\n\t\treturn -EINVAL;\n\n\t/*\n\t * Verify that higher 32bits of exit_signal are unset and that\n\t * it is a valid signal\n\t */\n\tif (unlikely((args.exit_signal & ~((u64)CSIGNAL)) ||\n\t\t     !valid_signal(args.exit_signal)))\n\t\treturn -EINVAL;\n\n\tif ((args.flags & CLONE_INTO_CGROUP) &&\n\t    (args.cgroup > INT_MAX || usize < CLONE_ARGS_SIZE_VER2))\n\t\treturn -EINVAL;\n\n\t*kargs = (struct kernel_clone_args){\n\t\t.flags\t\t= args.flags,\n\t\t.pidfd\t\t= u64_to_user_ptr(args.pidfd),\n\t\t.child_tid\t= u64_to_user_ptr(args.child_tid),\n\t\t.parent_tid\t= u64_to_user_ptr(args.parent_tid),\n\t\t.exit_signal\t= args.exit_signal,\n\t\t.stack\t\t= args.stack,\n\t\t.stack_size\t= args.stack_size,\n\t\t.tls\t\t= args.tls,\n\t\t.set_tid_size\t= args.set_tid_size,\n\t\t.cgroup\t\t= args.cgroup,\n\t};\n\n\tif (args.set_tid &&\n\t\tcopy_from_user(kset_tid, u64_to_user_ptr(args.set_tid),\n\t\t\t(kargs->set_tid_size * sizeof(pid_t))))\n\t\treturn -EFAULT;\n\n\tkargs->set_tid = kset_tid;\n\n\treturn 0;\n}\n\n/**\n * clone3_stack_valid - check and prepare stack\n * @kargs: kernel clone args\n *\n * Verify that the stack arguments userspace gave us are sane.\n * In addition, set the stack direction for userspace since it's easy for us to\n * determine.\n */\nstatic inline bool clone3_stack_valid(struct kernel_clone_args *kargs)\n{\n\tif (kargs->stack == 0) {\n\t\tif (kargs->stack_size > 0)\n\t\t\treturn false;\n\t} else {\n\t\tif (kargs->stack_size == 0)\n\t\t\treturn false;\n\n\t\tif (!access_ok((void __user *)kargs->stack, kargs->stack_size))\n\t\t\treturn false;\n\n#if !defined(CONFIG_STACK_GROWSUP) && !defined(CONFIG_IA64)\n\t\tkargs->stack += kargs->stack_size;\n#endif\n\t}\n\n\treturn true;\n}\n\nstatic bool clone3_args_valid(struct kernel_clone_args *kargs)\n{\n\t/* Verify that no unknown flags are passed along. */\n\tif (kargs->flags &\n\t    ~(CLONE_LEGACY_FLAGS | CLONE_CLEAR_SIGHAND | CLONE_INTO_CGROUP))\n\t\treturn false;\n\n\t/*\n\t * - make the CLONE_DETACHED bit reuseable for clone3\n\t * - make the CSIGNAL bits reuseable for clone3\n\t */\n\tif (kargs->flags & (CLONE_DETACHED | CSIGNAL))\n\t\treturn false;\n\n\tif ((kargs->flags & (CLONE_SIGHAND | CLONE_CLEAR_SIGHAND)) ==\n\t    (CLONE_SIGHAND | CLONE_CLEAR_SIGHAND))\n\t\treturn false;\n\n\tif ((kargs->flags & (CLONE_THREAD | CLONE_PARENT)) &&\n\t    kargs->exit_signal)\n\t\treturn false;\n\n\tif (!clone3_stack_valid(kargs))\n\t\treturn false;\n\n\treturn true;\n}\n\n/**\n * clone3 - create a new process with specific properties\n * @uargs: argument structure\n * @size:  size of @uargs\n *\n * clone3() is the extensible successor to clone()/clone2().\n * It takes a struct as argument that is versioned by its size.\n *\n * Return: On success, a positive PID for the child process.\n *         On error, a negative errno number.\n */\nSYSCALL_DEFINE2(clone3, struct clone_args __user *, uargs, size_t, size)\n{\n\tint err;\n\n\tstruct kernel_clone_args kargs;\n\tpid_t set_tid[MAX_PID_NS_LEVEL];\n\n\tkargs.set_tid = set_tid;\n\n\terr = copy_clone_args_from_user(&kargs, uargs, size);\n\tif (err)\n\t\treturn err;\n\n\tif (!clone3_args_valid(&kargs))\n\t\treturn -EINVAL;\n\n\treturn kernel_clone(&kargs);\n}\n#endif\n\nvoid walk_process_tree(struct task_struct *top, proc_visitor visitor, void *data)\n{\n\tstruct task_struct *leader, *parent, *child;\n\tint res;\n\n\tread_lock(&tasklist_lock);\n\tleader = top = top->group_leader;\ndown:\n\tfor_each_thread(leader, parent) {\n\t\tlist_for_each_entry(child, &parent->children, sibling) {\n\t\t\tres = visitor(child, data);\n\t\t\tif (res) {\n\t\t\t\tif (res < 0)\n\t\t\t\t\tgoto out;\n\t\t\t\tleader = child;\n\t\t\t\tgoto down;\n\t\t\t}\nup:\n\t\t\t;\n\t\t}\n\t}\n\n\tif (leader != top) {\n\t\tchild = leader;\n\t\tparent = child->real_parent;\n\t\tleader = parent->group_leader;\n\t\tgoto up;\n\t}\nout:\n\tread_unlock(&tasklist_lock);\n}\n\n#ifndef ARCH_MIN_MMSTRUCT_ALIGN\n#define ARCH_MIN_MMSTRUCT_ALIGN 0\n#endif\n\nstatic void sighand_ctor(void *data)\n{\n\tstruct sighand_struct *sighand = data;\n\n\tspin_lock_init(&sighand->siglock);\n\tinit_waitqueue_head(&sighand->signalfd_wqh);\n}\n\nvoid __init proc_caches_init(void)\n{\n\tunsigned int mm_size;\n\n\tsighand_cachep = kmem_cache_create(\"sighand_cache\",\n\t\t\tsizeof(struct sighand_struct), 0,\n\t\t\tSLAB_HWCACHE_ALIGN|SLAB_PANIC|SLAB_TYPESAFE_BY_RCU|\n\t\t\tSLAB_ACCOUNT, sighand_ctor);\n\tsignal_cachep = kmem_cache_create(\"signal_cache\",\n\t\t\tsizeof(struct signal_struct), 0,\n\t\t\tSLAB_HWCACHE_ALIGN|SLAB_PANIC|SLAB_ACCOUNT,\n\t\t\tNULL);\n\tfiles_cachep = kmem_cache_create(\"files_cache\",\n\t\t\tsizeof(struct files_struct), 0,\n\t\t\tSLAB_HWCACHE_ALIGN|SLAB_PANIC|SLAB_ACCOUNT,\n\t\t\tNULL);\n\tfs_cachep = kmem_cache_create(\"fs_cache\",\n\t\t\tsizeof(struct fs_struct), 0,\n\t\t\tSLAB_HWCACHE_ALIGN|SLAB_PANIC|SLAB_ACCOUNT,\n\t\t\tNULL);\n\n\t/*\n\t * The mm_cpumask is located at the end of mm_struct, and is\n\t * dynamically sized based on the maximum CPU number this system\n\t * can have, taking hotplug into account (nr_cpu_ids).\n\t */\n\tmm_size = sizeof(struct mm_struct) + cpumask_size();\n\n\tmm_cachep = kmem_cache_create_usercopy(\"mm_struct\",\n\t\t\tmm_size, ARCH_MIN_MMSTRUCT_ALIGN,\n\t\t\tSLAB_HWCACHE_ALIGN|SLAB_PANIC|SLAB_ACCOUNT,\n\t\t\toffsetof(struct mm_struct, saved_auxv),\n\t\t\tsizeof_field(struct mm_struct, saved_auxv),\n\t\t\tNULL);\n\tvm_area_cachep = KMEM_CACHE(vm_area_struct, SLAB_PANIC|SLAB_ACCOUNT);\n\tmmap_init();\n\tnsproxy_cache_init();\n}\n\n/*\n * Check constraints on flags passed to the unshare system call.\n */\nstatic int check_unshare_flags(unsigned long unshare_flags)\n{\n\tif (unshare_flags & ~(CLONE_THREAD|CLONE_FS|CLONE_NEWNS|CLONE_SIGHAND|\n\t\t\t\tCLONE_VM|CLONE_FILES|CLONE_SYSVSEM|\n\t\t\t\tCLONE_NEWUTS|CLONE_NEWIPC|CLONE_NEWNET|\n\t\t\t\tCLONE_NEWUSER|CLONE_NEWPID|CLONE_NEWCGROUP|\n\t\t\t\tCLONE_NEWTIME))\n\t\treturn -EINVAL;\n\t/*\n\t * Not implemented, but pretend it works if there is nothing\n\t * to unshare.  Note that unsharing the address space or the\n\t * signal handlers also need to unshare the signal queues (aka\n\t * CLONE_THREAD).\n\t */\n\tif (unshare_flags & (CLONE_THREAD | CLONE_SIGHAND | CLONE_VM)) {\n\t\tif (!thread_group_empty(current))\n\t\t\treturn -EINVAL;\n\t}\n\tif (unshare_flags & (CLONE_SIGHAND | CLONE_VM)) {\n\t\tif (refcount_read(&current->sighand->count) > 1)\n\t\t\treturn -EINVAL;\n\t}\n\tif (unshare_flags & CLONE_VM) {\n\t\tif (!current_is_single_threaded())\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n/*\n * Unshare the filesystem structure if it is being shared\n */\nstatic int unshare_fs(unsigned long unshare_flags, struct fs_struct **new_fsp)\n{\n\tstruct fs_struct *fs = current->fs;\n\n\tif (!(unshare_flags & CLONE_FS) || !fs)\n\t\treturn 0;\n\n\t/* don't need lock here; in the worst case we'll do useless copy */\n\tif (fs->users == 1)\n\t\treturn 0;\n\n\t*new_fsp = copy_fs_struct(fs);\n\tif (!*new_fsp)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\n/*\n * Unshare file descriptor table if it is being shared\n */\nint unshare_fd(unsigned long unshare_flags, unsigned int max_fds,\n\t       struct files_struct **new_fdp)\n{\n\tstruct files_struct *fd = current->files;\n\tint error = 0;\n\n\tif ((unshare_flags & CLONE_FILES) &&\n\t    (fd && atomic_read(&fd->count) > 1)) {\n\t\t*new_fdp = dup_fd(fd, max_fds, &error);\n\t\tif (!*new_fdp)\n\t\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\n/*\n * unshare allows a process to 'unshare' part of the process\n * context which was originally shared using clone.  copy_*\n * functions used by kernel_clone() cannot be used here directly\n * because they modify an inactive task_struct that is being\n * constructed. Here we are modifying the current, active,\n * task_struct.\n */\nint ksys_unshare(unsigned long unshare_flags)\n{\n\tstruct fs_struct *fs, *new_fs = NULL;\n\tstruct files_struct *fd, *new_fd = NULL;\n\tstruct cred *new_cred = NULL;\n\tstruct nsproxy *new_nsproxy = NULL;\n\tint do_sysvsem = 0;\n\tint err;\n\n\t/*\n\t * If unsharing a user namespace must also unshare the thread group\n\t * and unshare the filesystem root and working directories.\n\t */\n\tif (unshare_flags & CLONE_NEWUSER)\n\t\tunshare_flags |= CLONE_THREAD | CLONE_FS;\n\t/*\n\t * If unsharing vm, must also unshare signal handlers.\n\t */\n\tif (unshare_flags & CLONE_VM)\n\t\tunshare_flags |= CLONE_SIGHAND;\n\t/*\n\t * If unsharing a signal handlers, must also unshare the signal queues.\n\t */\n\tif (unshare_flags & CLONE_SIGHAND)\n\t\tunshare_flags |= CLONE_THREAD;\n\t/*\n\t * If unsharing namespace, must also unshare filesystem information.\n\t */\n\tif (unshare_flags & CLONE_NEWNS)\n\t\tunshare_flags |= CLONE_FS;\n\n\terr = check_unshare_flags(unshare_flags);\n\tif (err)\n\t\tgoto bad_unshare_out;\n\t/*\n\t * CLONE_NEWIPC must also detach from the undolist: after switching\n\t * to a new ipc namespace, the semaphore arrays from the old\n\t * namespace are unreachable.\n\t */\n\tif (unshare_flags & (CLONE_NEWIPC|CLONE_SYSVSEM))\n\t\tdo_sysvsem = 1;\n\terr = unshare_fs(unshare_flags, &new_fs);\n\tif (err)\n\t\tgoto bad_unshare_out;\n\terr = unshare_fd(unshare_flags, NR_OPEN_MAX, &new_fd);\n\tif (err)\n\t\tgoto bad_unshare_cleanup_fs;\n\terr = unshare_userns(unshare_flags, &new_cred);\n\tif (err)\n\t\tgoto bad_unshare_cleanup_fd;\n\terr = unshare_nsproxy_namespaces(unshare_flags, &new_nsproxy,\n\t\t\t\t\t new_cred, new_fs);\n\tif (err)\n\t\tgoto bad_unshare_cleanup_cred;\n\n\tif (new_fs || new_fd || do_sysvsem || new_cred || new_nsproxy) {\n\t\tif (do_sysvsem) {\n\t\t\t/*\n\t\t\t * CLONE_SYSVSEM is equivalent to sys_exit().\n\t\t\t */\n\t\t\texit_sem(current);\n\t\t}\n\t\tif (unshare_flags & CLONE_NEWIPC) {\n\t\t\t/* Orphan segments in old ns (see sem above). */\n\t\t\texit_shm(current);\n\t\t\tshm_init_task(current);\n\t\t}\n\n\t\tif (new_nsproxy)\n\t\t\tswitch_task_namespaces(current, new_nsproxy);\n\n\t\ttask_lock(current);\n\n\t\tif (new_fs) {\n\t\t\tfs = current->fs;\n\t\t\tspin_lock(&fs->lock);\n\t\t\tcurrent->fs = new_fs;\n\t\t\tif (--fs->users)\n\t\t\t\tnew_fs = NULL;\n\t\t\telse\n\t\t\t\tnew_fs = fs;\n\t\t\tspin_unlock(&fs->lock);\n\t\t}\n\n\t\tif (new_fd) {\n\t\t\tfd = current->files;\n\t\t\tcurrent->files = new_fd;\n\t\t\tnew_fd = fd;\n\t\t}\n\n\t\ttask_unlock(current);\n\n\t\tif (new_cred) {\n\t\t\t/* Install the new user namespace */\n\t\t\tcommit_creds(new_cred);\n\t\t\tnew_cred = NULL;\n\t\t}\n\t}\n\n\tperf_event_namespaces(current);\n\nbad_unshare_cleanup_cred:\n\tif (new_cred)\n\t\tput_cred(new_cred);\nbad_unshare_cleanup_fd:\n\tif (new_fd)\n\t\tput_files_struct(new_fd);\n\nbad_unshare_cleanup_fs:\n\tif (new_fs)\n\t\tfree_fs_struct(new_fs);\n\nbad_unshare_out:\n\treturn err;\n}\n\nSYSCALL_DEFINE1(unshare, unsigned long, unshare_flags)\n{\n\treturn ksys_unshare(unshare_flags);\n}\n\n/*\n *\tHelper to unshare the files of the current task.\n *\tWe don't want to expose copy_files internals to\n *\tthe exec layer of the kernel.\n */\n\nint unshare_files(struct files_struct **displaced)\n{\n\tstruct task_struct *task = current;\n\tstruct files_struct *copy = NULL;\n\tint error;\n\n\terror = unshare_fd(CLONE_FILES, NR_OPEN_MAX, &copy);\n\tif (error || !copy) {\n\t\t*displaced = NULL;\n\t\treturn error;\n\t}\n\t*displaced = task->files;\n\ttask_lock(task);\n\ttask->files = copy;\n\ttask_unlock(task);\n\treturn 0;\n}\n\nint sysctl_max_threads(struct ctl_table *table, int write,\n\t\t       void *buffer, size_t *lenp, loff_t *ppos)\n{\n\tstruct ctl_table t;\n\tint ret;\n\tint threads = max_threads;\n\tint min = 1;\n\tint max = MAX_THREADS;\n\n\tt = *table;\n\tt.data = &threads;\n\tt.extra1 = &min;\n\tt.extra2 = &max;\n\n\tret = proc_dointvec_minmax(&t, write, buffer, lenp, ppos);\n\tif (ret || !write)\n\t\treturn ret;\n\n\tmax_threads = threads;\n\n\treturn 0;\n}\n"], "fixing_code": ["// SPDX-License-Identifier: GPL-2.0-only\n/*\n *  linux/kernel/fork.c\n *\n *  Copyright (C) 1991, 1992  Linus Torvalds\n */\n\n/*\n *  'fork.c' contains the help-routines for the 'fork' system call\n * (see also entry.S and others).\n * Fork is rather simple, once you get the hang of it, but the memory\n * management can be a bitch. See 'mm/memory.c': 'copy_page_range()'\n */\n\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/user.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/task.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/cputime.h>\n#include <linux/seq_file.h>\n#include <linux/rtmutex.h>\n#include <linux/init.h>\n#include <linux/unistd.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/completion.h>\n#include <linux/personality.h>\n#include <linux/mempolicy.h>\n#include <linux/sem.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/iocontext.h>\n#include <linux/key.h>\n#include <linux/binfmts.h>\n#include <linux/mman.h>\n#include <linux/mmu_notifier.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/vmacache.h>\n#include <linux/nsproxy.h>\n#include <linux/capability.h>\n#include <linux/cpu.h>\n#include <linux/cgroup.h>\n#include <linux/security.h>\n#include <linux/hugetlb.h>\n#include <linux/seccomp.h>\n#include <linux/swap.h>\n#include <linux/syscalls.h>\n#include <linux/jiffies.h>\n#include <linux/futex.h>\n#include <linux/compat.h>\n#include <linux/kthread.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/rcupdate.h>\n#include <linux/ptrace.h>\n#include <linux/mount.h>\n#include <linux/audit.h>\n#include <linux/memcontrol.h>\n#include <linux/ftrace.h>\n#include <linux/proc_fs.h>\n#include <linux/profile.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/acct.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/tsacct_kern.h>\n#include <linux/cn_proc.h>\n#include <linux/freezer.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/random.h>\n#include <linux/tty.h>\n#include <linux/blkdev.h>\n#include <linux/fs_struct.h>\n#include <linux/magic.h>\n#include <linux/perf_event.h>\n#include <linux/posix-timers.h>\n#include <linux/user-return-notifier.h>\n#include <linux/oom.h>\n#include <linux/khugepaged.h>\n#include <linux/signalfd.h>\n#include <linux/uprobes.h>\n#include <linux/aio.h>\n#include <linux/compiler.h>\n#include <linux/sysctl.h>\n#include <linux/kcov.h>\n#include <linux/livepatch.h>\n#include <linux/thread_info.h>\n#include <linux/stackleak.h>\n#include <linux/kasan.h>\n#include <linux/scs.h>\n#include <linux/io_uring.h>\n\n#include <asm/pgalloc.h>\n#include <linux/uaccess.h>\n#include <asm/mmu_context.h>\n#include <asm/cacheflush.h>\n#include <asm/tlbflush.h>\n\n#include <trace/events/sched.h>\n\n#define CREATE_TRACE_POINTS\n#include <trace/events/task.h>\n\n/*\n * Minimum number of threads to boot the kernel\n */\n#define MIN_THREADS 20\n\n/*\n * Maximum number of threads\n */\n#define MAX_THREADS FUTEX_TID_MASK\n\n/*\n * Protected counters by write_lock_irq(&tasklist_lock)\n */\nunsigned long total_forks;\t/* Handle normal Linux uptimes. */\nint nr_threads;\t\t\t/* The idle threads do not count.. */\n\nstatic int max_threads;\t\t/* tunable limit on nr_threads */\n\n#define NAMED_ARRAY_INDEX(x)\t[x] = __stringify(x)\n\nstatic const char * const resident_page_types[] = {\n\tNAMED_ARRAY_INDEX(MM_FILEPAGES),\n\tNAMED_ARRAY_INDEX(MM_ANONPAGES),\n\tNAMED_ARRAY_INDEX(MM_SWAPENTS),\n\tNAMED_ARRAY_INDEX(MM_SHMEMPAGES),\n};\n\nDEFINE_PER_CPU(unsigned long, process_counts) = 0;\n\n__cacheline_aligned DEFINE_RWLOCK(tasklist_lock);  /* outer */\n\n#ifdef CONFIG_PROVE_RCU\nint lockdep_tasklist_lock_is_held(void)\n{\n\treturn lockdep_is_held(&tasklist_lock);\n}\nEXPORT_SYMBOL_GPL(lockdep_tasklist_lock_is_held);\n#endif /* #ifdef CONFIG_PROVE_RCU */\n\nint nr_processes(void)\n{\n\tint cpu;\n\tint total = 0;\n\n\tfor_each_possible_cpu(cpu)\n\t\ttotal += per_cpu(process_counts, cpu);\n\n\treturn total;\n}\n\nvoid __weak arch_release_task_struct(struct task_struct *tsk)\n{\n}\n\n#ifndef CONFIG_ARCH_TASK_STRUCT_ALLOCATOR\nstatic struct kmem_cache *task_struct_cachep;\n\nstatic inline struct task_struct *alloc_task_struct_node(int node)\n{\n\treturn kmem_cache_alloc_node(task_struct_cachep, GFP_KERNEL, node);\n}\n\nstatic inline void free_task_struct(struct task_struct *tsk)\n{\n\tkmem_cache_free(task_struct_cachep, tsk);\n}\n#endif\n\n#ifndef CONFIG_ARCH_THREAD_STACK_ALLOCATOR\n\n/*\n * Allocate pages if THREAD_SIZE is >= PAGE_SIZE, otherwise use a\n * kmemcache based allocator.\n */\n# if THREAD_SIZE >= PAGE_SIZE || defined(CONFIG_VMAP_STACK)\n\n#ifdef CONFIG_VMAP_STACK\n/*\n * vmalloc() is a bit slow, and calling vfree() enough times will force a TLB\n * flush.  Try to minimize the number of calls by caching stacks.\n */\n#define NR_CACHED_STACKS 2\nstatic DEFINE_PER_CPU(struct vm_struct *, cached_stacks[NR_CACHED_STACKS]);\n\nstatic int free_vm_stack_cache(unsigned int cpu)\n{\n\tstruct vm_struct **cached_vm_stacks = per_cpu_ptr(cached_stacks, cpu);\n\tint i;\n\n\tfor (i = 0; i < NR_CACHED_STACKS; i++) {\n\t\tstruct vm_struct *vm_stack = cached_vm_stacks[i];\n\n\t\tif (!vm_stack)\n\t\t\tcontinue;\n\n\t\tvfree(vm_stack->addr);\n\t\tcached_vm_stacks[i] = NULL;\n\t}\n\n\treturn 0;\n}\n#endif\n\nstatic unsigned long *alloc_thread_stack_node(struct task_struct *tsk, int node)\n{\n#ifdef CONFIG_VMAP_STACK\n\tvoid *stack;\n\tint i;\n\n\tfor (i = 0; i < NR_CACHED_STACKS; i++) {\n\t\tstruct vm_struct *s;\n\n\t\ts = this_cpu_xchg(cached_stacks[i], NULL);\n\n\t\tif (!s)\n\t\t\tcontinue;\n\n\t\t/* Clear the KASAN shadow of the stack. */\n\t\tkasan_unpoison_shadow(s->addr, THREAD_SIZE);\n\n\t\t/* Clear stale pointers from reused stack. */\n\t\tmemset(s->addr, 0, THREAD_SIZE);\n\n\t\ttsk->stack_vm_area = s;\n\t\ttsk->stack = s->addr;\n\t\treturn s->addr;\n\t}\n\n\t/*\n\t * Allocated stacks are cached and later reused by new threads,\n\t * so memcg accounting is performed manually on assigning/releasing\n\t * stacks to tasks. Drop __GFP_ACCOUNT.\n\t */\n\tstack = __vmalloc_node_range(THREAD_SIZE, THREAD_ALIGN,\n\t\t\t\t     VMALLOC_START, VMALLOC_END,\n\t\t\t\t     THREADINFO_GFP & ~__GFP_ACCOUNT,\n\t\t\t\t     PAGE_KERNEL,\n\t\t\t\t     0, node, __builtin_return_address(0));\n\n\t/*\n\t * We can't call find_vm_area() in interrupt context, and\n\t * free_thread_stack() can be called in interrupt context,\n\t * so cache the vm_struct.\n\t */\n\tif (stack) {\n\t\ttsk->stack_vm_area = find_vm_area(stack);\n\t\ttsk->stack = stack;\n\t}\n\treturn stack;\n#else\n\tstruct page *page = alloc_pages_node(node, THREADINFO_GFP,\n\t\t\t\t\t     THREAD_SIZE_ORDER);\n\n\tif (likely(page)) {\n\t\ttsk->stack = kasan_reset_tag(page_address(page));\n\t\treturn tsk->stack;\n\t}\n\treturn NULL;\n#endif\n}\n\nstatic inline void free_thread_stack(struct task_struct *tsk)\n{\n#ifdef CONFIG_VMAP_STACK\n\tstruct vm_struct *vm = task_stack_vm_area(tsk);\n\n\tif (vm) {\n\t\tint i;\n\n\t\tfor (i = 0; i < THREAD_SIZE / PAGE_SIZE; i++)\n\t\t\tmemcg_kmem_uncharge_page(vm->pages[i], 0);\n\n\t\tfor (i = 0; i < NR_CACHED_STACKS; i++) {\n\t\t\tif (this_cpu_cmpxchg(cached_stacks[i],\n\t\t\t\t\tNULL, tsk->stack_vm_area) != NULL)\n\t\t\t\tcontinue;\n\n\t\t\treturn;\n\t\t}\n\n\t\tvfree_atomic(tsk->stack);\n\t\treturn;\n\t}\n#endif\n\n\t__free_pages(virt_to_page(tsk->stack), THREAD_SIZE_ORDER);\n}\n# else\nstatic struct kmem_cache *thread_stack_cache;\n\nstatic unsigned long *alloc_thread_stack_node(struct task_struct *tsk,\n\t\t\t\t\t\t  int node)\n{\n\tunsigned long *stack;\n\tstack = kmem_cache_alloc_node(thread_stack_cache, THREADINFO_GFP, node);\n\tstack = kasan_reset_tag(stack);\n\ttsk->stack = stack;\n\treturn stack;\n}\n\nstatic void free_thread_stack(struct task_struct *tsk)\n{\n\tkmem_cache_free(thread_stack_cache, tsk->stack);\n}\n\nvoid thread_stack_cache_init(void)\n{\n\tthread_stack_cache = kmem_cache_create_usercopy(\"thread_stack\",\n\t\t\t\t\tTHREAD_SIZE, THREAD_SIZE, 0, 0,\n\t\t\t\t\tTHREAD_SIZE, NULL);\n\tBUG_ON(thread_stack_cache == NULL);\n}\n# endif\n#endif\n\n/* SLAB cache for signal_struct structures (tsk->signal) */\nstatic struct kmem_cache *signal_cachep;\n\n/* SLAB cache for sighand_struct structures (tsk->sighand) */\nstruct kmem_cache *sighand_cachep;\n\n/* SLAB cache for files_struct structures (tsk->files) */\nstruct kmem_cache *files_cachep;\n\n/* SLAB cache for fs_struct structures (tsk->fs) */\nstruct kmem_cache *fs_cachep;\n\n/* SLAB cache for vm_area_struct structures */\nstatic struct kmem_cache *vm_area_cachep;\n\n/* SLAB cache for mm_struct structures (tsk->mm) */\nstatic struct kmem_cache *mm_cachep;\n\nstruct vm_area_struct *vm_area_alloc(struct mm_struct *mm)\n{\n\tstruct vm_area_struct *vma;\n\n\tvma = kmem_cache_alloc(vm_area_cachep, GFP_KERNEL);\n\tif (vma)\n\t\tvma_init(vma, mm);\n\treturn vma;\n}\n\nstruct vm_area_struct *vm_area_dup(struct vm_area_struct *orig)\n{\n\tstruct vm_area_struct *new = kmem_cache_alloc(vm_area_cachep, GFP_KERNEL);\n\n\tif (new) {\n\t\tASSERT_EXCLUSIVE_WRITER(orig->vm_flags);\n\t\tASSERT_EXCLUSIVE_WRITER(orig->vm_file);\n\t\t/*\n\t\t * orig->shared.rb may be modified concurrently, but the clone\n\t\t * will be reinitialized.\n\t\t */\n\t\t*new = data_race(*orig);\n\t\tINIT_LIST_HEAD(&new->anon_vma_chain);\n\t\tnew->vm_next = new->vm_prev = NULL;\n\t}\n\treturn new;\n}\n\nvoid vm_area_free(struct vm_area_struct *vma)\n{\n\tkmem_cache_free(vm_area_cachep, vma);\n}\n\nstatic void account_kernel_stack(struct task_struct *tsk, int account)\n{\n\tvoid *stack = task_stack_page(tsk);\n\tstruct vm_struct *vm = task_stack_vm_area(tsk);\n\n\n\t/* All stack pages are in the same node. */\n\tif (vm)\n\t\tmod_lruvec_page_state(vm->pages[0], NR_KERNEL_STACK_KB,\n\t\t\t\t      account * (THREAD_SIZE / 1024));\n\telse\n\t\tmod_lruvec_slab_state(stack, NR_KERNEL_STACK_KB,\n\t\t\t\t      account * (THREAD_SIZE / 1024));\n}\n\nstatic int memcg_charge_kernel_stack(struct task_struct *tsk)\n{\n#ifdef CONFIG_VMAP_STACK\n\tstruct vm_struct *vm = task_stack_vm_area(tsk);\n\tint ret;\n\n\tBUILD_BUG_ON(IS_ENABLED(CONFIG_VMAP_STACK) && PAGE_SIZE % 1024 != 0);\n\n\tif (vm) {\n\t\tint i;\n\n\t\tBUG_ON(vm->nr_pages != THREAD_SIZE / PAGE_SIZE);\n\n\t\tfor (i = 0; i < THREAD_SIZE / PAGE_SIZE; i++) {\n\t\t\t/*\n\t\t\t * If memcg_kmem_charge_page() fails, page->mem_cgroup\n\t\t\t * pointer is NULL, and memcg_kmem_uncharge_page() in\n\t\t\t * free_thread_stack() will ignore this page.\n\t\t\t */\n\t\t\tret = memcg_kmem_charge_page(vm->pages[i], GFP_KERNEL,\n\t\t\t\t\t\t     0);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n#endif\n\treturn 0;\n}\n\nstatic void release_task_stack(struct task_struct *tsk)\n{\n\tif (WARN_ON(tsk->state != TASK_DEAD))\n\t\treturn;  /* Better to leak the stack than to free prematurely */\n\n\taccount_kernel_stack(tsk, -1);\n\tfree_thread_stack(tsk);\n\ttsk->stack = NULL;\n#ifdef CONFIG_VMAP_STACK\n\ttsk->stack_vm_area = NULL;\n#endif\n}\n\n#ifdef CONFIG_THREAD_INFO_IN_TASK\nvoid put_task_stack(struct task_struct *tsk)\n{\n\tif (refcount_dec_and_test(&tsk->stack_refcount))\n\t\trelease_task_stack(tsk);\n}\n#endif\n\nvoid free_task(struct task_struct *tsk)\n{\n\tscs_release(tsk);\n\n#ifndef CONFIG_THREAD_INFO_IN_TASK\n\t/*\n\t * The task is finally done with both the stack and thread_info,\n\t * so free both.\n\t */\n\trelease_task_stack(tsk);\n#else\n\t/*\n\t * If the task had a separate stack allocation, it should be gone\n\t * by now.\n\t */\n\tWARN_ON_ONCE(refcount_read(&tsk->stack_refcount) != 0);\n#endif\n\trt_mutex_debug_task_free(tsk);\n\tftrace_graph_exit_task(tsk);\n\tarch_release_task_struct(tsk);\n\tif (tsk->flags & PF_KTHREAD)\n\t\tfree_kthread_struct(tsk);\n\tfree_task_struct(tsk);\n}\nEXPORT_SYMBOL(free_task);\n\n#ifdef CONFIG_MMU\nstatic __latent_entropy int dup_mmap(struct mm_struct *mm,\n\t\t\t\t\tstruct mm_struct *oldmm)\n{\n\tstruct vm_area_struct *mpnt, *tmp, *prev, **pprev;\n\tstruct rb_node **rb_link, *rb_parent;\n\tint retval;\n\tunsigned long charge;\n\tLIST_HEAD(uf);\n\n\tuprobe_start_dup_mmap();\n\tif (mmap_write_lock_killable(oldmm)) {\n\t\tretval = -EINTR;\n\t\tgoto fail_uprobe_end;\n\t}\n\tflush_cache_dup_mm(oldmm);\n\tuprobe_dup_mmap(oldmm, mm);\n\t/*\n\t * Not linked in yet - no deadlock potential:\n\t */\n\tmmap_write_lock_nested(mm, SINGLE_DEPTH_NESTING);\n\n\t/* No ordering required: file already has been exposed. */\n\tRCU_INIT_POINTER(mm->exe_file, get_mm_exe_file(oldmm));\n\n\tmm->total_vm = oldmm->total_vm;\n\tmm->data_vm = oldmm->data_vm;\n\tmm->exec_vm = oldmm->exec_vm;\n\tmm->stack_vm = oldmm->stack_vm;\n\n\trb_link = &mm->mm_rb.rb_node;\n\trb_parent = NULL;\n\tpprev = &mm->mmap;\n\tretval = ksm_fork(mm, oldmm);\n\tif (retval)\n\t\tgoto out;\n\tretval = khugepaged_fork(mm, oldmm);\n\tif (retval)\n\t\tgoto out;\n\n\tprev = NULL;\n\tfor (mpnt = oldmm->mmap; mpnt; mpnt = mpnt->vm_next) {\n\t\tstruct file *file;\n\n\t\tif (mpnt->vm_flags & VM_DONTCOPY) {\n\t\t\tvm_stat_account(mm, mpnt->vm_flags, -vma_pages(mpnt));\n\t\t\tcontinue;\n\t\t}\n\t\tcharge = 0;\n\t\t/*\n\t\t * Don't duplicate many vmas if we've been oom-killed (for\n\t\t * example)\n\t\t */\n\t\tif (fatal_signal_pending(current)) {\n\t\t\tretval = -EINTR;\n\t\t\tgoto out;\n\t\t}\n\t\tif (mpnt->vm_flags & VM_ACCOUNT) {\n\t\t\tunsigned long len = vma_pages(mpnt);\n\n\t\t\tif (security_vm_enough_memory_mm(oldmm, len)) /* sic */\n\t\t\t\tgoto fail_nomem;\n\t\t\tcharge = len;\n\t\t}\n\t\ttmp = vm_area_dup(mpnt);\n\t\tif (!tmp)\n\t\t\tgoto fail_nomem;\n\t\tretval = vma_dup_policy(mpnt, tmp);\n\t\tif (retval)\n\t\t\tgoto fail_nomem_policy;\n\t\ttmp->vm_mm = mm;\n\t\tretval = dup_userfaultfd(tmp, &uf);\n\t\tif (retval)\n\t\t\tgoto fail_nomem_anon_vma_fork;\n\t\tif (tmp->vm_flags & VM_WIPEONFORK) {\n\t\t\t/*\n\t\t\t * VM_WIPEONFORK gets a clean slate in the child.\n\t\t\t * Don't prepare anon_vma until fault since we don't\n\t\t\t * copy page for current vma.\n\t\t\t */\n\t\t\ttmp->anon_vma = NULL;\n\t\t} else if (anon_vma_fork(tmp, mpnt))\n\t\t\tgoto fail_nomem_anon_vma_fork;\n\t\ttmp->vm_flags &= ~(VM_LOCKED | VM_LOCKONFAULT);\n\t\tfile = tmp->vm_file;\n\t\tif (file) {\n\t\t\tstruct inode *inode = file_inode(file);\n\t\t\tstruct address_space *mapping = file->f_mapping;\n\n\t\t\tget_file(file);\n\t\t\tif (tmp->vm_flags & VM_DENYWRITE)\n\t\t\t\tput_write_access(inode);\n\t\t\ti_mmap_lock_write(mapping);\n\t\t\tif (tmp->vm_flags & VM_SHARED)\n\t\t\t\tmapping_allow_writable(mapping);\n\t\t\tflush_dcache_mmap_lock(mapping);\n\t\t\t/* insert tmp into the share list, just after mpnt */\n\t\t\tvma_interval_tree_insert_after(tmp, mpnt,\n\t\t\t\t\t&mapping->i_mmap);\n\t\t\tflush_dcache_mmap_unlock(mapping);\n\t\t\ti_mmap_unlock_write(mapping);\n\t\t}\n\n\t\t/*\n\t\t * Clear hugetlb-related page reserves for children. This only\n\t\t * affects MAP_PRIVATE mappings. Faults generated by the child\n\t\t * are not guaranteed to succeed, even if read-only\n\t\t */\n\t\tif (is_vm_hugetlb_page(tmp))\n\t\t\treset_vma_resv_huge_pages(tmp);\n\n\t\t/*\n\t\t * Link in the new vma and copy the page table entries.\n\t\t */\n\t\t*pprev = tmp;\n\t\tpprev = &tmp->vm_next;\n\t\ttmp->vm_prev = prev;\n\t\tprev = tmp;\n\n\t\t__vma_link_rb(mm, tmp, rb_link, rb_parent);\n\t\trb_link = &tmp->vm_rb.rb_right;\n\t\trb_parent = &tmp->vm_rb;\n\n\t\tmm->map_count++;\n\t\tif (!(tmp->vm_flags & VM_WIPEONFORK))\n\t\t\tretval = copy_page_range(tmp, mpnt);\n\n\t\tif (tmp->vm_ops && tmp->vm_ops->open)\n\t\t\ttmp->vm_ops->open(tmp);\n\n\t\tif (retval)\n\t\t\tgoto out;\n\t}\n\t/* a new mm has just been created */\n\tretval = arch_dup_mmap(oldmm, mm);\nout:\n\tmmap_write_unlock(mm);\n\tflush_tlb_mm(oldmm);\n\tmmap_write_unlock(oldmm);\n\tdup_userfaultfd_complete(&uf);\nfail_uprobe_end:\n\tuprobe_end_dup_mmap();\n\treturn retval;\nfail_nomem_anon_vma_fork:\n\tmpol_put(vma_policy(tmp));\nfail_nomem_policy:\n\tvm_area_free(tmp);\nfail_nomem:\n\tretval = -ENOMEM;\n\tvm_unacct_memory(charge);\n\tgoto out;\n}\n\nstatic inline int mm_alloc_pgd(struct mm_struct *mm)\n{\n\tmm->pgd = pgd_alloc(mm);\n\tif (unlikely(!mm->pgd))\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\nstatic inline void mm_free_pgd(struct mm_struct *mm)\n{\n\tpgd_free(mm, mm->pgd);\n}\n#else\nstatic int dup_mmap(struct mm_struct *mm, struct mm_struct *oldmm)\n{\n\tmmap_write_lock(oldmm);\n\tRCU_INIT_POINTER(mm->exe_file, get_mm_exe_file(oldmm));\n\tmmap_write_unlock(oldmm);\n\treturn 0;\n}\n#define mm_alloc_pgd(mm)\t(0)\n#define mm_free_pgd(mm)\n#endif /* CONFIG_MMU */\n\nstatic void check_mm(struct mm_struct *mm)\n{\n\tint i;\n\n\tBUILD_BUG_ON_MSG(ARRAY_SIZE(resident_page_types) != NR_MM_COUNTERS,\n\t\t\t \"Please make sure 'struct resident_page_types[]' is updated as well\");\n\n\tfor (i = 0; i < NR_MM_COUNTERS; i++) {\n\t\tlong x = atomic_long_read(&mm->rss_stat.count[i]);\n\n\t\tif (unlikely(x))\n\t\t\tpr_alert(\"BUG: Bad rss-counter state mm:%p type:%s val:%ld\\n\",\n\t\t\t\t mm, resident_page_types[i], x);\n\t}\n\n\tif (mm_pgtables_bytes(mm))\n\t\tpr_alert(\"BUG: non-zero pgtables_bytes on freeing mm: %ld\\n\",\n\t\t\t\tmm_pgtables_bytes(mm));\n\n#if defined(CONFIG_TRANSPARENT_HUGEPAGE) && !USE_SPLIT_PMD_PTLOCKS\n\tVM_BUG_ON_MM(mm->pmd_huge_pte, mm);\n#endif\n}\n\n#define allocate_mm()\t(kmem_cache_alloc(mm_cachep, GFP_KERNEL))\n#define free_mm(mm)\t(kmem_cache_free(mm_cachep, (mm)))\n\n/*\n * Called when the last reference to the mm\n * is dropped: either by a lazy thread or by\n * mmput. Free the page directory and the mm.\n */\nvoid __mmdrop(struct mm_struct *mm)\n{\n\tBUG_ON(mm == &init_mm);\n\tWARN_ON_ONCE(mm == current->mm);\n\tWARN_ON_ONCE(mm == current->active_mm);\n\tmm_free_pgd(mm);\n\tdestroy_context(mm);\n\tmmu_notifier_subscriptions_destroy(mm);\n\tcheck_mm(mm);\n\tput_user_ns(mm->user_ns);\n\tfree_mm(mm);\n}\nEXPORT_SYMBOL_GPL(__mmdrop);\n\nstatic void mmdrop_async_fn(struct work_struct *work)\n{\n\tstruct mm_struct *mm;\n\n\tmm = container_of(work, struct mm_struct, async_put_work);\n\t__mmdrop(mm);\n}\n\nstatic void mmdrop_async(struct mm_struct *mm)\n{\n\tif (unlikely(atomic_dec_and_test(&mm->mm_count))) {\n\t\tINIT_WORK(&mm->async_put_work, mmdrop_async_fn);\n\t\tschedule_work(&mm->async_put_work);\n\t}\n}\n\nstatic inline void free_signal_struct(struct signal_struct *sig)\n{\n\ttaskstats_tgid_free(sig);\n\tsched_autogroup_exit(sig);\n\t/*\n\t * __mmdrop is not safe to call from softirq context on x86 due to\n\t * pgd_dtor so postpone it to the async context\n\t */\n\tif (sig->oom_mm)\n\t\tmmdrop_async(sig->oom_mm);\n\tkmem_cache_free(signal_cachep, sig);\n}\n\nstatic inline void put_signal_struct(struct signal_struct *sig)\n{\n\tif (refcount_dec_and_test(&sig->sigcnt))\n\t\tfree_signal_struct(sig);\n}\n\nvoid __put_task_struct(struct task_struct *tsk)\n{\n\tWARN_ON(!tsk->exit_state);\n\tWARN_ON(refcount_read(&tsk->usage));\n\tWARN_ON(tsk == current);\n\n\tio_uring_free(tsk);\n\tcgroup_free(tsk);\n\ttask_numa_free(tsk, true);\n\tsecurity_task_free(tsk);\n\texit_creds(tsk);\n\tdelayacct_tsk_free(tsk);\n\tput_signal_struct(tsk->signal);\n\n\tif (!profile_handoff_task(tsk))\n\t\tfree_task(tsk);\n}\nEXPORT_SYMBOL_GPL(__put_task_struct);\n\nvoid __init __weak arch_task_cache_init(void) { }\n\n/*\n * set_max_threads\n */\nstatic void set_max_threads(unsigned int max_threads_suggested)\n{\n\tu64 threads;\n\tunsigned long nr_pages = totalram_pages();\n\n\t/*\n\t * The number of threads shall be limited such that the thread\n\t * structures may only consume a small part of the available memory.\n\t */\n\tif (fls64(nr_pages) + fls64(PAGE_SIZE) > 64)\n\t\tthreads = MAX_THREADS;\n\telse\n\t\tthreads = div64_u64((u64) nr_pages * (u64) PAGE_SIZE,\n\t\t\t\t    (u64) THREAD_SIZE * 8UL);\n\n\tif (threads > max_threads_suggested)\n\t\tthreads = max_threads_suggested;\n\n\tmax_threads = clamp_t(u64, threads, MIN_THREADS, MAX_THREADS);\n}\n\n#ifdef CONFIG_ARCH_WANTS_DYNAMIC_TASK_STRUCT\n/* Initialized by the architecture: */\nint arch_task_struct_size __read_mostly;\n#endif\n\n#ifndef CONFIG_ARCH_TASK_STRUCT_ALLOCATOR\nstatic void task_struct_whitelist(unsigned long *offset, unsigned long *size)\n{\n\t/* Fetch thread_struct whitelist for the architecture. */\n\tarch_thread_struct_whitelist(offset, size);\n\n\t/*\n\t * Handle zero-sized whitelist or empty thread_struct, otherwise\n\t * adjust offset to position of thread_struct in task_struct.\n\t */\n\tif (unlikely(*size == 0))\n\t\t*offset = 0;\n\telse\n\t\t*offset += offsetof(struct task_struct, thread);\n}\n#endif /* CONFIG_ARCH_TASK_STRUCT_ALLOCATOR */\n\nvoid __init fork_init(void)\n{\n\tint i;\n#ifndef CONFIG_ARCH_TASK_STRUCT_ALLOCATOR\n#ifndef ARCH_MIN_TASKALIGN\n#define ARCH_MIN_TASKALIGN\t0\n#endif\n\tint align = max_t(int, L1_CACHE_BYTES, ARCH_MIN_TASKALIGN);\n\tunsigned long useroffset, usersize;\n\n\t/* create a slab on which task_structs can be allocated */\n\ttask_struct_whitelist(&useroffset, &usersize);\n\ttask_struct_cachep = kmem_cache_create_usercopy(\"task_struct\",\n\t\t\tarch_task_struct_size, align,\n\t\t\tSLAB_PANIC|SLAB_ACCOUNT,\n\t\t\tuseroffset, usersize, NULL);\n#endif\n\n\t/* do the arch specific task caches init */\n\tarch_task_cache_init();\n\n\tset_max_threads(MAX_THREADS);\n\n\tinit_task.signal->rlim[RLIMIT_NPROC].rlim_cur = max_threads/2;\n\tinit_task.signal->rlim[RLIMIT_NPROC].rlim_max = max_threads/2;\n\tinit_task.signal->rlim[RLIMIT_SIGPENDING] =\n\t\tinit_task.signal->rlim[RLIMIT_NPROC];\n\n\tfor (i = 0; i < UCOUNT_COUNTS; i++) {\n\t\tinit_user_ns.ucount_max[i] = max_threads/2;\n\t}\n\n#ifdef CONFIG_VMAP_STACK\n\tcpuhp_setup_state(CPUHP_BP_PREPARE_DYN, \"fork:vm_stack_cache\",\n\t\t\t  NULL, free_vm_stack_cache);\n#endif\n\n\tscs_init();\n\n\tlockdep_init_task(&init_task);\n\tuprobes_init();\n}\n\nint __weak arch_dup_task_struct(struct task_struct *dst,\n\t\t\t\t\t       struct task_struct *src)\n{\n\t*dst = *src;\n\treturn 0;\n}\n\nvoid set_task_stack_end_magic(struct task_struct *tsk)\n{\n\tunsigned long *stackend;\n\n\tstackend = end_of_stack(tsk);\n\t*stackend = STACK_END_MAGIC;\t/* for overflow detection */\n}\n\nstatic struct task_struct *dup_task_struct(struct task_struct *orig, int node)\n{\n\tstruct task_struct *tsk;\n\tunsigned long *stack;\n\tstruct vm_struct *stack_vm_area __maybe_unused;\n\tint err;\n\n\tif (node == NUMA_NO_NODE)\n\t\tnode = tsk_fork_get_node(orig);\n\ttsk = alloc_task_struct_node(node);\n\tif (!tsk)\n\t\treturn NULL;\n\n\tstack = alloc_thread_stack_node(tsk, node);\n\tif (!stack)\n\t\tgoto free_tsk;\n\n\tif (memcg_charge_kernel_stack(tsk))\n\t\tgoto free_stack;\n\n\tstack_vm_area = task_stack_vm_area(tsk);\n\n\terr = arch_dup_task_struct(tsk, orig);\n\n\t/*\n\t * arch_dup_task_struct() clobbers the stack-related fields.  Make\n\t * sure they're properly initialized before using any stack-related\n\t * functions again.\n\t */\n\ttsk->stack = stack;\n#ifdef CONFIG_VMAP_STACK\n\ttsk->stack_vm_area = stack_vm_area;\n#endif\n#ifdef CONFIG_THREAD_INFO_IN_TASK\n\trefcount_set(&tsk->stack_refcount, 1);\n#endif\n\n\tif (err)\n\t\tgoto free_stack;\n\n\terr = scs_prepare(tsk, node);\n\tif (err)\n\t\tgoto free_stack;\n\n#ifdef CONFIG_SECCOMP\n\t/*\n\t * We must handle setting up seccomp filters once we're under\n\t * the sighand lock in case orig has changed between now and\n\t * then. Until then, filter must be NULL to avoid messing up\n\t * the usage counts on the error path calling free_task.\n\t */\n\ttsk->seccomp.filter = NULL;\n#endif\n\n\tsetup_thread_stack(tsk, orig);\n\tclear_user_return_notifier(tsk);\n\tclear_tsk_need_resched(tsk);\n\tset_task_stack_end_magic(tsk);\n\n#ifdef CONFIG_STACKPROTECTOR\n\ttsk->stack_canary = get_random_canary();\n#endif\n\tif (orig->cpus_ptr == &orig->cpus_mask)\n\t\ttsk->cpus_ptr = &tsk->cpus_mask;\n\n\t/*\n\t * One for the user space visible state that goes away when reaped.\n\t * One for the scheduler.\n\t */\n\trefcount_set(&tsk->rcu_users, 2);\n\t/* One for the rcu users */\n\trefcount_set(&tsk->usage, 1);\n#ifdef CONFIG_BLK_DEV_IO_TRACE\n\ttsk->btrace_seq = 0;\n#endif\n\ttsk->splice_pipe = NULL;\n\ttsk->task_frag.page = NULL;\n\ttsk->wake_q.next = NULL;\n\n\taccount_kernel_stack(tsk, 1);\n\n\tkcov_task_init(tsk);\n\n#ifdef CONFIG_FAULT_INJECTION\n\ttsk->fail_nth = 0;\n#endif\n\n#ifdef CONFIG_BLK_CGROUP\n\ttsk->throttle_queue = NULL;\n\ttsk->use_memdelay = 0;\n#endif\n\n#ifdef CONFIG_MEMCG\n\ttsk->active_memcg = NULL;\n#endif\n\treturn tsk;\n\nfree_stack:\n\tfree_thread_stack(tsk);\nfree_tsk:\n\tfree_task_struct(tsk);\n\treturn NULL;\n}\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(mmlist_lock);\n\nstatic unsigned long default_dump_filter = MMF_DUMP_FILTER_DEFAULT;\n\nstatic int __init coredump_filter_setup(char *s)\n{\n\tdefault_dump_filter =\n\t\t(simple_strtoul(s, NULL, 0) << MMF_DUMP_FILTER_SHIFT) &\n\t\tMMF_DUMP_FILTER_MASK;\n\treturn 1;\n}\n\n__setup(\"coredump_filter=\", coredump_filter_setup);\n\n#include <linux/init_task.h>\n\nstatic void mm_init_aio(struct mm_struct *mm)\n{\n#ifdef CONFIG_AIO\n\tspin_lock_init(&mm->ioctx_lock);\n\tmm->ioctx_table = NULL;\n#endif\n}\n\nstatic __always_inline void mm_clear_owner(struct mm_struct *mm,\n\t\t\t\t\t   struct task_struct *p)\n{\n#ifdef CONFIG_MEMCG\n\tif (mm->owner == p)\n\t\tWRITE_ONCE(mm->owner, NULL);\n#endif\n}\n\nstatic void mm_init_owner(struct mm_struct *mm, struct task_struct *p)\n{\n#ifdef CONFIG_MEMCG\n\tmm->owner = p;\n#endif\n}\n\nstatic void mm_init_uprobes_state(struct mm_struct *mm)\n{\n#ifdef CONFIG_UPROBES\n\tmm->uprobes_state.xol_area = NULL;\n#endif\n}\n\nstatic struct mm_struct *mm_init(struct mm_struct *mm, struct task_struct *p,\n\tstruct user_namespace *user_ns)\n{\n\tmm->mmap = NULL;\n\tmm->mm_rb = RB_ROOT;\n\tmm->vmacache_seqnum = 0;\n\tatomic_set(&mm->mm_users, 1);\n\tatomic_set(&mm->mm_count, 1);\n\tmmap_init_lock(mm);\n\tINIT_LIST_HEAD(&mm->mmlist);\n\tmm->core_state = NULL;\n\tmm_pgtables_bytes_init(mm);\n\tmm->map_count = 0;\n\tmm->locked_vm = 0;\n\tatomic_set(&mm->has_pinned, 0);\n\tatomic64_set(&mm->pinned_vm, 0);\n\tmemset(&mm->rss_stat, 0, sizeof(mm->rss_stat));\n\tspin_lock_init(&mm->page_table_lock);\n\tspin_lock_init(&mm->arg_lock);\n\tmm_init_cpumask(mm);\n\tmm_init_aio(mm);\n\tmm_init_owner(mm, p);\n\tRCU_INIT_POINTER(mm->exe_file, NULL);\n\tmmu_notifier_subscriptions_init(mm);\n\tinit_tlb_flush_pending(mm);\n#if defined(CONFIG_TRANSPARENT_HUGEPAGE) && !USE_SPLIT_PMD_PTLOCKS\n\tmm->pmd_huge_pte = NULL;\n#endif\n\tmm_init_uprobes_state(mm);\n\n\tif (current->mm) {\n\t\tmm->flags = current->mm->flags & MMF_INIT_MASK;\n\t\tmm->def_flags = current->mm->def_flags & VM_INIT_DEF_MASK;\n\t} else {\n\t\tmm->flags = default_dump_filter;\n\t\tmm->def_flags = 0;\n\t}\n\n\tif (mm_alloc_pgd(mm))\n\t\tgoto fail_nopgd;\n\n\tif (init_new_context(p, mm))\n\t\tgoto fail_nocontext;\n\n\tmm->user_ns = get_user_ns(user_ns);\n\treturn mm;\n\nfail_nocontext:\n\tmm_free_pgd(mm);\nfail_nopgd:\n\tfree_mm(mm);\n\treturn NULL;\n}\n\n/*\n * Allocate and initialize an mm_struct.\n */\nstruct mm_struct *mm_alloc(void)\n{\n\tstruct mm_struct *mm;\n\n\tmm = allocate_mm();\n\tif (!mm)\n\t\treturn NULL;\n\n\tmemset(mm, 0, sizeof(*mm));\n\treturn mm_init(mm, current, current_user_ns());\n}\n\nstatic inline void __mmput(struct mm_struct *mm)\n{\n\tVM_BUG_ON(atomic_read(&mm->mm_users));\n\n\tuprobe_clear_state(mm);\n\texit_aio(mm);\n\tksm_exit(mm);\n\tkhugepaged_exit(mm); /* must run before exit_mmap */\n\texit_mmap(mm);\n\tmm_put_huge_zero_page(mm);\n\tset_mm_exe_file(mm, NULL);\n\tif (!list_empty(&mm->mmlist)) {\n\t\tspin_lock(&mmlist_lock);\n\t\tlist_del(&mm->mmlist);\n\t\tspin_unlock(&mmlist_lock);\n\t}\n\tif (mm->binfmt)\n\t\tmodule_put(mm->binfmt->module);\n\tmmdrop(mm);\n}\n\n/*\n * Decrement the use count and release all resources for an mm.\n */\nvoid mmput(struct mm_struct *mm)\n{\n\tmight_sleep();\n\n\tif (atomic_dec_and_test(&mm->mm_users))\n\t\t__mmput(mm);\n}\nEXPORT_SYMBOL_GPL(mmput);\n\n#ifdef CONFIG_MMU\nstatic void mmput_async_fn(struct work_struct *work)\n{\n\tstruct mm_struct *mm = container_of(work, struct mm_struct,\n\t\t\t\t\t    async_put_work);\n\n\t__mmput(mm);\n}\n\nvoid mmput_async(struct mm_struct *mm)\n{\n\tif (atomic_dec_and_test(&mm->mm_users)) {\n\t\tINIT_WORK(&mm->async_put_work, mmput_async_fn);\n\t\tschedule_work(&mm->async_put_work);\n\t}\n}\n#endif\n\n/**\n * set_mm_exe_file - change a reference to the mm's executable file\n *\n * This changes mm's executable file (shown as symlink /proc/[pid]/exe).\n *\n * Main users are mmput() and sys_execve(). Callers prevent concurrent\n * invocations: in mmput() nobody alive left, in execve task is single\n * threaded. sys_prctl(PR_SET_MM_MAP/EXE_FILE) also needs to set the\n * mm->exe_file, but does so without using set_mm_exe_file() in order\n * to do avoid the need for any locks.\n */\nvoid set_mm_exe_file(struct mm_struct *mm, struct file *new_exe_file)\n{\n\tstruct file *old_exe_file;\n\n\t/*\n\t * It is safe to dereference the exe_file without RCU as\n\t * this function is only called if nobody else can access\n\t * this mm -- see comment above for justification.\n\t */\n\told_exe_file = rcu_dereference_raw(mm->exe_file);\n\n\tif (new_exe_file)\n\t\tget_file(new_exe_file);\n\trcu_assign_pointer(mm->exe_file, new_exe_file);\n\tif (old_exe_file)\n\t\tfput(old_exe_file);\n}\n\n/**\n * get_mm_exe_file - acquire a reference to the mm's executable file\n *\n * Returns %NULL if mm has no associated executable file.\n * User must release file via fput().\n */\nstruct file *get_mm_exe_file(struct mm_struct *mm)\n{\n\tstruct file *exe_file;\n\n\trcu_read_lock();\n\texe_file = rcu_dereference(mm->exe_file);\n\tif (exe_file && !get_file_rcu(exe_file))\n\t\texe_file = NULL;\n\trcu_read_unlock();\n\treturn exe_file;\n}\nEXPORT_SYMBOL(get_mm_exe_file);\n\n/**\n * get_task_exe_file - acquire a reference to the task's executable file\n *\n * Returns %NULL if task's mm (if any) has no associated executable file or\n * this is a kernel thread with borrowed mm (see the comment above get_task_mm).\n * User must release file via fput().\n */\nstruct file *get_task_exe_file(struct task_struct *task)\n{\n\tstruct file *exe_file = NULL;\n\tstruct mm_struct *mm;\n\n\ttask_lock(task);\n\tmm = task->mm;\n\tif (mm) {\n\t\tif (!(task->flags & PF_KTHREAD))\n\t\t\texe_file = get_mm_exe_file(mm);\n\t}\n\ttask_unlock(task);\n\treturn exe_file;\n}\nEXPORT_SYMBOL(get_task_exe_file);\n\n/**\n * get_task_mm - acquire a reference to the task's mm\n *\n * Returns %NULL if the task has no mm.  Checks PF_KTHREAD (meaning\n * this kernel workthread has transiently adopted a user mm with use_mm,\n * to do its AIO) is not set and if so returns a reference to it, after\n * bumping up the use count.  User must release the mm via mmput()\n * after use.  Typically used by /proc and ptrace.\n */\nstruct mm_struct *get_task_mm(struct task_struct *task)\n{\n\tstruct mm_struct *mm;\n\n\ttask_lock(task);\n\tmm = task->mm;\n\tif (mm) {\n\t\tif (task->flags & PF_KTHREAD)\n\t\t\tmm = NULL;\n\t\telse\n\t\t\tmmget(mm);\n\t}\n\ttask_unlock(task);\n\treturn mm;\n}\nEXPORT_SYMBOL_GPL(get_task_mm);\n\nstruct mm_struct *mm_access(struct task_struct *task, unsigned int mode)\n{\n\tstruct mm_struct *mm;\n\tint err;\n\n\terr =  mutex_lock_killable(&task->signal->exec_update_mutex);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\tmm = get_task_mm(task);\n\tif (mm && mm != current->mm &&\n\t\t\t!ptrace_may_access(task, mode)) {\n\t\tmmput(mm);\n\t\tmm = ERR_PTR(-EACCES);\n\t}\n\tmutex_unlock(&task->signal->exec_update_mutex);\n\n\treturn mm;\n}\n\nstatic void complete_vfork_done(struct task_struct *tsk)\n{\n\tstruct completion *vfork;\n\n\ttask_lock(tsk);\n\tvfork = tsk->vfork_done;\n\tif (likely(vfork)) {\n\t\ttsk->vfork_done = NULL;\n\t\tcomplete(vfork);\n\t}\n\ttask_unlock(tsk);\n}\n\nstatic int wait_for_vfork_done(struct task_struct *child,\n\t\t\t\tstruct completion *vfork)\n{\n\tint killed;\n\n\tfreezer_do_not_count();\n\tcgroup_enter_frozen();\n\tkilled = wait_for_completion_killable(vfork);\n\tcgroup_leave_frozen(false);\n\tfreezer_count();\n\n\tif (killed) {\n\t\ttask_lock(child);\n\t\tchild->vfork_done = NULL;\n\t\ttask_unlock(child);\n\t}\n\n\tput_task_struct(child);\n\treturn killed;\n}\n\n/* Please note the differences between mmput and mm_release.\n * mmput is called whenever we stop holding onto a mm_struct,\n * error success whatever.\n *\n * mm_release is called after a mm_struct has been removed\n * from the current process.\n *\n * This difference is important for error handling, when we\n * only half set up a mm_struct for a new process and need to restore\n * the old one.  Because we mmput the new mm_struct before\n * restoring the old one. . .\n * Eric Biederman 10 January 1998\n */\nstatic void mm_release(struct task_struct *tsk, struct mm_struct *mm)\n{\n\tuprobe_free_utask(tsk);\n\n\t/* Get rid of any cached register state */\n\tdeactivate_mm(tsk, mm);\n\n\t/*\n\t * Signal userspace if we're not exiting with a core dump\n\t * because we want to leave the value intact for debugging\n\t * purposes.\n\t */\n\tif (tsk->clear_child_tid) {\n\t\tif (!(tsk->signal->flags & SIGNAL_GROUP_COREDUMP) &&\n\t\t    atomic_read(&mm->mm_users) > 1) {\n\t\t\t/*\n\t\t\t * We don't check the error code - if userspace has\n\t\t\t * not set up a proper pointer then tough luck.\n\t\t\t */\n\t\t\tput_user(0, tsk->clear_child_tid);\n\t\t\tdo_futex(tsk->clear_child_tid, FUTEX_WAKE,\n\t\t\t\t\t1, NULL, NULL, 0, 0);\n\t\t}\n\t\ttsk->clear_child_tid = NULL;\n\t}\n\n\t/*\n\t * All done, finally we can wake up parent and return this mm to him.\n\t * Also kthread_stop() uses this completion for synchronization.\n\t */\n\tif (tsk->vfork_done)\n\t\tcomplete_vfork_done(tsk);\n}\n\nvoid exit_mm_release(struct task_struct *tsk, struct mm_struct *mm)\n{\n\tfutex_exit_release(tsk);\n\tmm_release(tsk, mm);\n}\n\nvoid exec_mm_release(struct task_struct *tsk, struct mm_struct *mm)\n{\n\tfutex_exec_release(tsk);\n\tmm_release(tsk, mm);\n}\n\n/**\n * dup_mm() - duplicates an existing mm structure\n * @tsk: the task_struct with which the new mm will be associated.\n * @oldmm: the mm to duplicate.\n *\n * Allocates a new mm structure and duplicates the provided @oldmm structure\n * content into it.\n *\n * Return: the duplicated mm or NULL on failure.\n */\nstatic struct mm_struct *dup_mm(struct task_struct *tsk,\n\t\t\t\tstruct mm_struct *oldmm)\n{\n\tstruct mm_struct *mm;\n\tint err;\n\n\tmm = allocate_mm();\n\tif (!mm)\n\t\tgoto fail_nomem;\n\n\tmemcpy(mm, oldmm, sizeof(*mm));\n\n\tif (!mm_init(mm, tsk, mm->user_ns))\n\t\tgoto fail_nomem;\n\n\terr = dup_mmap(mm, oldmm);\n\tif (err)\n\t\tgoto free_pt;\n\n\tmm->hiwater_rss = get_mm_rss(mm);\n\tmm->hiwater_vm = mm->total_vm;\n\n\tif (mm->binfmt && !try_module_get(mm->binfmt->module))\n\t\tgoto free_pt;\n\n\treturn mm;\n\nfree_pt:\n\t/* don't put binfmt in mmput, we haven't got module yet */\n\tmm->binfmt = NULL;\n\tmm_init_owner(mm, NULL);\n\tmmput(mm);\n\nfail_nomem:\n\treturn NULL;\n}\n\nstatic int copy_mm(unsigned long clone_flags, struct task_struct *tsk)\n{\n\tstruct mm_struct *mm, *oldmm;\n\tint retval;\n\n\ttsk->min_flt = tsk->maj_flt = 0;\n\ttsk->nvcsw = tsk->nivcsw = 0;\n#ifdef CONFIG_DETECT_HUNG_TASK\n\ttsk->last_switch_count = tsk->nvcsw + tsk->nivcsw;\n\ttsk->last_switch_time = 0;\n#endif\n\n\ttsk->mm = NULL;\n\ttsk->active_mm = NULL;\n\n\t/*\n\t * Are we cloning a kernel thread?\n\t *\n\t * We need to steal a active VM for that..\n\t */\n\toldmm = current->mm;\n\tif (!oldmm)\n\t\treturn 0;\n\n\t/* initialize the new vmacache entries */\n\tvmacache_flush(tsk);\n\n\tif (clone_flags & CLONE_VM) {\n\t\tmmget(oldmm);\n\t\tmm = oldmm;\n\t\tgoto good_mm;\n\t}\n\n\tretval = -ENOMEM;\n\tmm = dup_mm(tsk, current->mm);\n\tif (!mm)\n\t\tgoto fail_nomem;\n\ngood_mm:\n\ttsk->mm = mm;\n\ttsk->active_mm = mm;\n\treturn 0;\n\nfail_nomem:\n\treturn retval;\n}\n\nstatic int copy_fs(unsigned long clone_flags, struct task_struct *tsk)\n{\n\tstruct fs_struct *fs = current->fs;\n\tif (clone_flags & CLONE_FS) {\n\t\t/* tsk->fs is already what we want */\n\t\tspin_lock(&fs->lock);\n\t\tif (fs->in_exec) {\n\t\t\tspin_unlock(&fs->lock);\n\t\t\treturn -EAGAIN;\n\t\t}\n\t\tfs->users++;\n\t\tspin_unlock(&fs->lock);\n\t\treturn 0;\n\t}\n\ttsk->fs = copy_fs_struct(fs);\n\tif (!tsk->fs)\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\nstatic int copy_files(unsigned long clone_flags, struct task_struct *tsk)\n{\n\tstruct files_struct *oldf, *newf;\n\tint error = 0;\n\n\t/*\n\t * A background process may not have any files ...\n\t */\n\toldf = current->files;\n\tif (!oldf)\n\t\tgoto out;\n\n\tif (clone_flags & CLONE_FILES) {\n\t\tatomic_inc(&oldf->count);\n\t\tgoto out;\n\t}\n\n\tnewf = dup_fd(oldf, NR_OPEN_MAX, &error);\n\tif (!newf)\n\t\tgoto out;\n\n\ttsk->files = newf;\n\terror = 0;\nout:\n\treturn error;\n}\n\nstatic int copy_io(unsigned long clone_flags, struct task_struct *tsk)\n{\n#ifdef CONFIG_BLOCK\n\tstruct io_context *ioc = current->io_context;\n\tstruct io_context *new_ioc;\n\n\tif (!ioc)\n\t\treturn 0;\n\t/*\n\t * Share io context with parent, if CLONE_IO is set\n\t */\n\tif (clone_flags & CLONE_IO) {\n\t\tioc_task_link(ioc);\n\t\ttsk->io_context = ioc;\n\t} else if (ioprio_valid(ioc->ioprio)) {\n\t\tnew_ioc = get_task_io_context(tsk, GFP_KERNEL, NUMA_NO_NODE);\n\t\tif (unlikely(!new_ioc))\n\t\t\treturn -ENOMEM;\n\n\t\tnew_ioc->ioprio = ioc->ioprio;\n\t\tput_io_context(new_ioc);\n\t}\n#endif\n\treturn 0;\n}\n\nstatic int copy_sighand(unsigned long clone_flags, struct task_struct *tsk)\n{\n\tstruct sighand_struct *sig;\n\n\tif (clone_flags & CLONE_SIGHAND) {\n\t\trefcount_inc(&current->sighand->count);\n\t\treturn 0;\n\t}\n\tsig = kmem_cache_alloc(sighand_cachep, GFP_KERNEL);\n\tRCU_INIT_POINTER(tsk->sighand, sig);\n\tif (!sig)\n\t\treturn -ENOMEM;\n\n\trefcount_set(&sig->count, 1);\n\tspin_lock_irq(&current->sighand->siglock);\n\tmemcpy(sig->action, current->sighand->action, sizeof(sig->action));\n\tspin_unlock_irq(&current->sighand->siglock);\n\n\t/* Reset all signal handler not set to SIG_IGN to SIG_DFL. */\n\tif (clone_flags & CLONE_CLEAR_SIGHAND)\n\t\tflush_signal_handlers(tsk, 0);\n\n\treturn 0;\n}\n\nvoid __cleanup_sighand(struct sighand_struct *sighand)\n{\n\tif (refcount_dec_and_test(&sighand->count)) {\n\t\tsignalfd_cleanup(sighand);\n\t\t/*\n\t\t * sighand_cachep is SLAB_TYPESAFE_BY_RCU so we can free it\n\t\t * without an RCU grace period, see __lock_task_sighand().\n\t\t */\n\t\tkmem_cache_free(sighand_cachep, sighand);\n\t}\n}\n\n/*\n * Initialize POSIX timer handling for a thread group.\n */\nstatic void posix_cpu_timers_init_group(struct signal_struct *sig)\n{\n\tstruct posix_cputimers *pct = &sig->posix_cputimers;\n\tunsigned long cpu_limit;\n\n\tcpu_limit = READ_ONCE(sig->rlim[RLIMIT_CPU].rlim_cur);\n\tposix_cputimers_group_init(pct, cpu_limit);\n}\n\nstatic int copy_signal(unsigned long clone_flags, struct task_struct *tsk)\n{\n\tstruct signal_struct *sig;\n\n\tif (clone_flags & CLONE_THREAD)\n\t\treturn 0;\n\n\tsig = kmem_cache_zalloc(signal_cachep, GFP_KERNEL);\n\ttsk->signal = sig;\n\tif (!sig)\n\t\treturn -ENOMEM;\n\n\tsig->nr_threads = 1;\n\tatomic_set(&sig->live, 1);\n\trefcount_set(&sig->sigcnt, 1);\n\n\t/* list_add(thread_node, thread_head) without INIT_LIST_HEAD() */\n\tsig->thread_head = (struct list_head)LIST_HEAD_INIT(tsk->thread_node);\n\ttsk->thread_node = (struct list_head)LIST_HEAD_INIT(sig->thread_head);\n\n\tinit_waitqueue_head(&sig->wait_chldexit);\n\tsig->curr_target = tsk;\n\tinit_sigpending(&sig->shared_pending);\n\tINIT_HLIST_HEAD(&sig->multiprocess);\n\tseqlock_init(&sig->stats_lock);\n\tprev_cputime_init(&sig->prev_cputime);\n\n#ifdef CONFIG_POSIX_TIMERS\n\tINIT_LIST_HEAD(&sig->posix_timers);\n\thrtimer_init(&sig->real_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);\n\tsig->real_timer.function = it_real_fn;\n#endif\n\n\ttask_lock(current->group_leader);\n\tmemcpy(sig->rlim, current->signal->rlim, sizeof sig->rlim);\n\ttask_unlock(current->group_leader);\n\n\tposix_cpu_timers_init_group(sig);\n\n\ttty_audit_fork(sig);\n\tsched_autogroup_fork(sig);\n\n\tsig->oom_score_adj = current->signal->oom_score_adj;\n\tsig->oom_score_adj_min = current->signal->oom_score_adj_min;\n\n\tmutex_init(&sig->cred_guard_mutex);\n\tmutex_init(&sig->exec_update_mutex);\n\n\treturn 0;\n}\n\nstatic void copy_seccomp(struct task_struct *p)\n{\n#ifdef CONFIG_SECCOMP\n\t/*\n\t * Must be called with sighand->lock held, which is common to\n\t * all threads in the group. Holding cred_guard_mutex is not\n\t * needed because this new task is not yet running and cannot\n\t * be racing exec.\n\t */\n\tassert_spin_locked(&current->sighand->siglock);\n\n\t/* Ref-count the new filter user, and assign it. */\n\tget_seccomp_filter(current);\n\tp->seccomp = current->seccomp;\n\n\t/*\n\t * Explicitly enable no_new_privs here in case it got set\n\t * between the task_struct being duplicated and holding the\n\t * sighand lock. The seccomp state and nnp must be in sync.\n\t */\n\tif (task_no_new_privs(current))\n\t\ttask_set_no_new_privs(p);\n\n\t/*\n\t * If the parent gained a seccomp mode after copying thread\n\t * flags and between before we held the sighand lock, we have\n\t * to manually enable the seccomp thread flag here.\n\t */\n\tif (p->seccomp.mode != SECCOMP_MODE_DISABLED)\n\t\tset_tsk_thread_flag(p, TIF_SECCOMP);\n#endif\n}\n\nSYSCALL_DEFINE1(set_tid_address, int __user *, tidptr)\n{\n\tcurrent->clear_child_tid = tidptr;\n\n\treturn task_pid_vnr(current);\n}\n\nstatic void rt_mutex_init_task(struct task_struct *p)\n{\n\traw_spin_lock_init(&p->pi_lock);\n#ifdef CONFIG_RT_MUTEXES\n\tp->pi_waiters = RB_ROOT_CACHED;\n\tp->pi_top_task = NULL;\n\tp->pi_blocked_on = NULL;\n#endif\n}\n\nstatic inline void init_task_pid_links(struct task_struct *task)\n{\n\tenum pid_type type;\n\n\tfor (type = PIDTYPE_PID; type < PIDTYPE_MAX; ++type) {\n\t\tINIT_HLIST_NODE(&task->pid_links[type]);\n\t}\n}\n\nstatic inline void\ninit_task_pid(struct task_struct *task, enum pid_type type, struct pid *pid)\n{\n\tif (type == PIDTYPE_PID)\n\t\ttask->thread_pid = pid;\n\telse\n\t\ttask->signal->pids[type] = pid;\n}\n\nstatic inline void rcu_copy_process(struct task_struct *p)\n{\n#ifdef CONFIG_PREEMPT_RCU\n\tp->rcu_read_lock_nesting = 0;\n\tp->rcu_read_unlock_special.s = 0;\n\tp->rcu_blocked_node = NULL;\n\tINIT_LIST_HEAD(&p->rcu_node_entry);\n#endif /* #ifdef CONFIG_PREEMPT_RCU */\n#ifdef CONFIG_TASKS_RCU\n\tp->rcu_tasks_holdout = false;\n\tINIT_LIST_HEAD(&p->rcu_tasks_holdout_list);\n\tp->rcu_tasks_idle_cpu = -1;\n#endif /* #ifdef CONFIG_TASKS_RCU */\n#ifdef CONFIG_TASKS_TRACE_RCU\n\tp->trc_reader_nesting = 0;\n\tp->trc_reader_special.s = 0;\n\tINIT_LIST_HEAD(&p->trc_holdout_list);\n#endif /* #ifdef CONFIG_TASKS_TRACE_RCU */\n}\n\nstruct pid *pidfd_pid(const struct file *file)\n{\n\tif (file->f_op == &pidfd_fops)\n\t\treturn file->private_data;\n\n\treturn ERR_PTR(-EBADF);\n}\n\nstatic int pidfd_release(struct inode *inode, struct file *file)\n{\n\tstruct pid *pid = file->private_data;\n\n\tfile->private_data = NULL;\n\tput_pid(pid);\n\treturn 0;\n}\n\n#ifdef CONFIG_PROC_FS\n/**\n * pidfd_show_fdinfo - print information about a pidfd\n * @m: proc fdinfo file\n * @f: file referencing a pidfd\n *\n * Pid:\n * This function will print the pid that a given pidfd refers to in the\n * pid namespace of the procfs instance.\n * If the pid namespace of the process is not a descendant of the pid\n * namespace of the procfs instance 0 will be shown as its pid. This is\n * similar to calling getppid() on a process whose parent is outside of\n * its pid namespace.\n *\n * NSpid:\n * If pid namespaces are supported then this function will also print\n * the pid of a given pidfd refers to for all descendant pid namespaces\n * starting from the current pid namespace of the instance, i.e. the\n * Pid field and the first entry in the NSpid field will be identical.\n * If the pid namespace of the process is not a descendant of the pid\n * namespace of the procfs instance 0 will be shown as its first NSpid\n * entry and no others will be shown.\n * Note that this differs from the Pid and NSpid fields in\n * /proc/<pid>/status where Pid and NSpid are always shown relative to\n * the  pid namespace of the procfs instance. The difference becomes\n * obvious when sending around a pidfd between pid namespaces from a\n * different branch of the tree, i.e. where no ancestoral relation is\n * present between the pid namespaces:\n * - create two new pid namespaces ns1 and ns2 in the initial pid\n *   namespace (also take care to create new mount namespaces in the\n *   new pid namespace and mount procfs)\n * - create a process with a pidfd in ns1\n * - send pidfd from ns1 to ns2\n * - read /proc/self/fdinfo/<pidfd> and observe that both Pid and NSpid\n *   have exactly one entry, which is 0\n */\nstatic void pidfd_show_fdinfo(struct seq_file *m, struct file *f)\n{\n\tstruct pid *pid = f->private_data;\n\tstruct pid_namespace *ns;\n\tpid_t nr = -1;\n\n\tif (likely(pid_has_task(pid, PIDTYPE_PID))) {\n\t\tns = proc_pid_ns(file_inode(m->file)->i_sb);\n\t\tnr = pid_nr_ns(pid, ns);\n\t}\n\n\tseq_put_decimal_ll(m, \"Pid:\\t\", nr);\n\n#ifdef CONFIG_PID_NS\n\tseq_put_decimal_ll(m, \"\\nNSpid:\\t\", nr);\n\tif (nr > 0) {\n\t\tint i;\n\n\t\t/* If nr is non-zero it means that 'pid' is valid and that\n\t\t * ns, i.e. the pid namespace associated with the procfs\n\t\t * instance, is in the pid namespace hierarchy of pid.\n\t\t * Start at one below the already printed level.\n\t\t */\n\t\tfor (i = ns->level + 1; i <= pid->level; i++)\n\t\t\tseq_put_decimal_ll(m, \"\\t\", pid->numbers[i].nr);\n\t}\n#endif\n\tseq_putc(m, '\\n');\n}\n#endif\n\n/*\n * Poll support for process exit notification.\n */\nstatic __poll_t pidfd_poll(struct file *file, struct poll_table_struct *pts)\n{\n\tstruct pid *pid = file->private_data;\n\t__poll_t poll_flags = 0;\n\n\tpoll_wait(file, &pid->wait_pidfd, pts);\n\n\t/*\n\t * Inform pollers only when the whole thread group exits.\n\t * If the thread group leader exits before all other threads in the\n\t * group, then poll(2) should block, similar to the wait(2) family.\n\t */\n\tif (thread_group_exited(pid))\n\t\tpoll_flags = EPOLLIN | EPOLLRDNORM;\n\n\treturn poll_flags;\n}\n\nconst struct file_operations pidfd_fops = {\n\t.release = pidfd_release,\n\t.poll = pidfd_poll,\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo = pidfd_show_fdinfo,\n#endif\n};\n\nstatic void __delayed_free_task(struct rcu_head *rhp)\n{\n\tstruct task_struct *tsk = container_of(rhp, struct task_struct, rcu);\n\n\tfree_task(tsk);\n}\n\nstatic __always_inline void delayed_free_task(struct task_struct *tsk)\n{\n\tif (IS_ENABLED(CONFIG_MEMCG))\n\t\tcall_rcu(&tsk->rcu, __delayed_free_task);\n\telse\n\t\tfree_task(tsk);\n}\n\nstatic void copy_oom_score_adj(u64 clone_flags, struct task_struct *tsk)\n{\n\t/* Skip if kernel thread */\n\tif (!tsk->mm)\n\t\treturn;\n\n\t/* Skip if spawning a thread or using vfork */\n\tif ((clone_flags & (CLONE_VM | CLONE_THREAD | CLONE_VFORK)) != CLONE_VM)\n\t\treturn;\n\n\t/* We need to synchronize with __set_oom_adj */\n\tmutex_lock(&oom_adj_mutex);\n\tset_bit(MMF_MULTIPROCESS, &tsk->mm->flags);\n\t/* Update the values in case they were changed after copy_signal */\n\ttsk->signal->oom_score_adj = current->signal->oom_score_adj;\n\ttsk->signal->oom_score_adj_min = current->signal->oom_score_adj_min;\n\tmutex_unlock(&oom_adj_mutex);\n}\n\n/*\n * This creates a new process as a copy of the old one,\n * but does not actually start it yet.\n *\n * It copies the registers, and all the appropriate\n * parts of the process environment (as per the clone\n * flags). The actual kick-off is left to the caller.\n */\nstatic __latent_entropy struct task_struct *copy_process(\n\t\t\t\t\tstruct pid *pid,\n\t\t\t\t\tint trace,\n\t\t\t\t\tint node,\n\t\t\t\t\tstruct kernel_clone_args *args)\n{\n\tint pidfd = -1, retval;\n\tstruct task_struct *p;\n\tstruct multiprocess_signals delayed;\n\tstruct file *pidfile = NULL;\n\tu64 clone_flags = args->flags;\n\tstruct nsproxy *nsp = current->nsproxy;\n\n\t/*\n\t * Don't allow sharing the root directory with processes in a different\n\t * namespace\n\t */\n\tif ((clone_flags & (CLONE_NEWNS|CLONE_FS)) == (CLONE_NEWNS|CLONE_FS))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif ((clone_flags & (CLONE_NEWUSER|CLONE_FS)) == (CLONE_NEWUSER|CLONE_FS))\n\t\treturn ERR_PTR(-EINVAL);\n\n\t/*\n\t * Thread groups must share signals as well, and detached threads\n\t * can only be started up within the thread group.\n\t */\n\tif ((clone_flags & CLONE_THREAD) && !(clone_flags & CLONE_SIGHAND))\n\t\treturn ERR_PTR(-EINVAL);\n\n\t/*\n\t * Shared signal handlers imply shared VM. By way of the above,\n\t * thread groups also imply shared VM. Blocking this case allows\n\t * for various simplifications in other code.\n\t */\n\tif ((clone_flags & CLONE_SIGHAND) && !(clone_flags & CLONE_VM))\n\t\treturn ERR_PTR(-EINVAL);\n\n\t/*\n\t * Siblings of global init remain as zombies on exit since they are\n\t * not reaped by their parent (swapper). To solve this and to avoid\n\t * multi-rooted process trees, prevent global and container-inits\n\t * from creating siblings.\n\t */\n\tif ((clone_flags & CLONE_PARENT) &&\n\t\t\t\tcurrent->signal->flags & SIGNAL_UNKILLABLE)\n\t\treturn ERR_PTR(-EINVAL);\n\n\t/*\n\t * If the new process will be in a different pid or user namespace\n\t * do not allow it to share a thread group with the forking task.\n\t */\n\tif (clone_flags & CLONE_THREAD) {\n\t\tif ((clone_flags & (CLONE_NEWUSER | CLONE_NEWPID)) ||\n\t\t    (task_active_pid_ns(current) != nsp->pid_ns_for_children))\n\t\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\t/*\n\t * If the new process will be in a different time namespace\n\t * do not allow it to share VM or a thread group with the forking task.\n\t */\n\tif (clone_flags & (CLONE_THREAD | CLONE_VM)) {\n\t\tif (nsp->time_ns != nsp->time_ns_for_children)\n\t\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tif (clone_flags & CLONE_PIDFD) {\n\t\t/*\n\t\t * - CLONE_DETACHED is blocked so that we can potentially\n\t\t *   reuse it later for CLONE_PIDFD.\n\t\t * - CLONE_THREAD is blocked until someone really needs it.\n\t\t */\n\t\tif (clone_flags & (CLONE_DETACHED | CLONE_THREAD))\n\t\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\t/*\n\t * Force any signals received before this point to be delivered\n\t * before the fork happens.  Collect up signals sent to multiple\n\t * processes that happen during the fork and delay them so that\n\t * they appear to happen after the fork.\n\t */\n\tsigemptyset(&delayed.signal);\n\tINIT_HLIST_NODE(&delayed.node);\n\n\tspin_lock_irq(&current->sighand->siglock);\n\tif (!(clone_flags & CLONE_THREAD))\n\t\thlist_add_head(&delayed.node, &current->signal->multiprocess);\n\trecalc_sigpending();\n\tspin_unlock_irq(&current->sighand->siglock);\n\tretval = -ERESTARTNOINTR;\n\tif (signal_pending(current))\n\t\tgoto fork_out;\n\n\tretval = -ENOMEM;\n\tp = dup_task_struct(current, node);\n\tif (!p)\n\t\tgoto fork_out;\n\n\t/*\n\t * This _must_ happen before we call free_task(), i.e. before we jump\n\t * to any of the bad_fork_* labels. This is to avoid freeing\n\t * p->set_child_tid which is (ab)used as a kthread's data pointer for\n\t * kernel threads (PF_KTHREAD).\n\t */\n\tp->set_child_tid = (clone_flags & CLONE_CHILD_SETTID) ? args->child_tid : NULL;\n\t/*\n\t * Clear TID on mm_release()?\n\t */\n\tp->clear_child_tid = (clone_flags & CLONE_CHILD_CLEARTID) ? args->child_tid : NULL;\n\n\tftrace_graph_init_task(p);\n\n\trt_mutex_init_task(p);\n\n\tlockdep_assert_irqs_enabled();\n#ifdef CONFIG_PROVE_LOCKING\n\tDEBUG_LOCKS_WARN_ON(!p->softirqs_enabled);\n#endif\n\tretval = -EAGAIN;\n\tif (atomic_read(&p->real_cred->user->processes) >=\n\t\t\ttask_rlimit(p, RLIMIT_NPROC)) {\n\t\tif (p->real_cred->user != INIT_USER &&\n\t\t    !capable(CAP_SYS_RESOURCE) && !capable(CAP_SYS_ADMIN))\n\t\t\tgoto bad_fork_free;\n\t}\n\tcurrent->flags &= ~PF_NPROC_EXCEEDED;\n\n\tretval = copy_creds(p, clone_flags);\n\tif (retval < 0)\n\t\tgoto bad_fork_free;\n\n\t/*\n\t * If multiple threads are within copy_process(), then this check\n\t * triggers too late. This doesn't hurt, the check is only there\n\t * to stop root fork bombs.\n\t */\n\tretval = -EAGAIN;\n\tif (data_race(nr_threads >= max_threads))\n\t\tgoto bad_fork_cleanup_count;\n\n\tdelayacct_tsk_init(p);\t/* Must remain after dup_task_struct() */\n\tp->flags &= ~(PF_SUPERPRIV | PF_WQ_WORKER | PF_IDLE);\n\tp->flags |= PF_FORKNOEXEC;\n\tINIT_LIST_HEAD(&p->children);\n\tINIT_LIST_HEAD(&p->sibling);\n\trcu_copy_process(p);\n\tp->vfork_done = NULL;\n\tspin_lock_init(&p->alloc_lock);\n\n\tinit_sigpending(&p->pending);\n\n\tp->utime = p->stime = p->gtime = 0;\n#ifdef CONFIG_ARCH_HAS_SCALED_CPUTIME\n\tp->utimescaled = p->stimescaled = 0;\n#endif\n\tprev_cputime_init(&p->prev_cputime);\n\n#ifdef CONFIG_VIRT_CPU_ACCOUNTING_GEN\n\tseqcount_init(&p->vtime.seqcount);\n\tp->vtime.starttime = 0;\n\tp->vtime.state = VTIME_INACTIVE;\n#endif\n\n#ifdef CONFIG_IO_URING\n\tp->io_uring = NULL;\n#endif\n\n#if defined(SPLIT_RSS_COUNTING)\n\tmemset(&p->rss_stat, 0, sizeof(p->rss_stat));\n#endif\n\n\tp->default_timer_slack_ns = current->timer_slack_ns;\n\n#ifdef CONFIG_PSI\n\tp->psi_flags = 0;\n#endif\n\n\ttask_io_accounting_init(&p->ioac);\n\tacct_clear_integrals(p);\n\n\tposix_cputimers_init(&p->posix_cputimers);\n\n\tp->io_context = NULL;\n\taudit_set_context(p, NULL);\n\tcgroup_fork(p);\n#ifdef CONFIG_NUMA\n\tp->mempolicy = mpol_dup(p->mempolicy);\n\tif (IS_ERR(p->mempolicy)) {\n\t\tretval = PTR_ERR(p->mempolicy);\n\t\tp->mempolicy = NULL;\n\t\tgoto bad_fork_cleanup_threadgroup_lock;\n\t}\n#endif\n#ifdef CONFIG_CPUSETS\n\tp->cpuset_mem_spread_rotor = NUMA_NO_NODE;\n\tp->cpuset_slab_spread_rotor = NUMA_NO_NODE;\n\tseqcount_spinlock_init(&p->mems_allowed_seq, &p->alloc_lock);\n#endif\n#ifdef CONFIG_TRACE_IRQFLAGS\n\tmemset(&p->irqtrace, 0, sizeof(p->irqtrace));\n\tp->irqtrace.hardirq_disable_ip\t= _THIS_IP_;\n\tp->irqtrace.softirq_enable_ip\t= _THIS_IP_;\n\tp->softirqs_enabled\t\t= 1;\n\tp->softirq_context\t\t= 0;\n#endif\n\n\tp->pagefault_disabled = 0;\n\n#ifdef CONFIG_LOCKDEP\n\tlockdep_init_task(p);\n#endif\n\n#ifdef CONFIG_DEBUG_MUTEXES\n\tp->blocked_on = NULL; /* not blocked yet */\n#endif\n#ifdef CONFIG_BCACHE\n\tp->sequential_io\t= 0;\n\tp->sequential_io_avg\t= 0;\n#endif\n\n\t/* Perform scheduler related setup. Assign this task to a CPU. */\n\tretval = sched_fork(clone_flags, p);\n\tif (retval)\n\t\tgoto bad_fork_cleanup_policy;\n\n\tretval = perf_event_init_task(p);\n\tif (retval)\n\t\tgoto bad_fork_cleanup_policy;\n\tretval = audit_alloc(p);\n\tif (retval)\n\t\tgoto bad_fork_cleanup_perf;\n\t/* copy all the process information */\n\tshm_init_task(p);\n\tretval = security_task_alloc(p, clone_flags);\n\tif (retval)\n\t\tgoto bad_fork_cleanup_audit;\n\tretval = copy_semundo(clone_flags, p);\n\tif (retval)\n\t\tgoto bad_fork_cleanup_security;\n\tretval = copy_files(clone_flags, p);\n\tif (retval)\n\t\tgoto bad_fork_cleanup_semundo;\n\tretval = copy_fs(clone_flags, p);\n\tif (retval)\n\t\tgoto bad_fork_cleanup_files;\n\tretval = copy_sighand(clone_flags, p);\n\tif (retval)\n\t\tgoto bad_fork_cleanup_fs;\n\tretval = copy_signal(clone_flags, p);\n\tif (retval)\n\t\tgoto bad_fork_cleanup_sighand;\n\tretval = copy_mm(clone_flags, p);\n\tif (retval)\n\t\tgoto bad_fork_cleanup_signal;\n\tretval = copy_namespaces(clone_flags, p);\n\tif (retval)\n\t\tgoto bad_fork_cleanup_mm;\n\tretval = copy_io(clone_flags, p);\n\tif (retval)\n\t\tgoto bad_fork_cleanup_namespaces;\n\tretval = copy_thread(clone_flags, args->stack, args->stack_size, p, args->tls);\n\tif (retval)\n\t\tgoto bad_fork_cleanup_io;\n\n\tstackleak_task_init(p);\n\n\tif (pid != &init_struct_pid) {\n\t\tpid = alloc_pid(p->nsproxy->pid_ns_for_children, args->set_tid,\n\t\t\t\targs->set_tid_size);\n\t\tif (IS_ERR(pid)) {\n\t\t\tretval = PTR_ERR(pid);\n\t\t\tgoto bad_fork_cleanup_thread;\n\t\t}\n\t}\n\n\t/*\n\t * This has to happen after we've potentially unshared the file\n\t * descriptor table (so that the pidfd doesn't leak into the child\n\t * if the fd table isn't shared).\n\t */\n\tif (clone_flags & CLONE_PIDFD) {\n\t\tretval = get_unused_fd_flags(O_RDWR | O_CLOEXEC);\n\t\tif (retval < 0)\n\t\t\tgoto bad_fork_free_pid;\n\n\t\tpidfd = retval;\n\n\t\tpidfile = anon_inode_getfile(\"[pidfd]\", &pidfd_fops, pid,\n\t\t\t\t\t      O_RDWR | O_CLOEXEC);\n\t\tif (IS_ERR(pidfile)) {\n\t\t\tput_unused_fd(pidfd);\n\t\t\tretval = PTR_ERR(pidfile);\n\t\t\tgoto bad_fork_free_pid;\n\t\t}\n\t\tget_pid(pid);\t/* held by pidfile now */\n\n\t\tretval = put_user(pidfd, args->pidfd);\n\t\tif (retval)\n\t\t\tgoto bad_fork_put_pidfd;\n\t}\n\n#ifdef CONFIG_BLOCK\n\tp->plug = NULL;\n#endif\n\tfutex_init_task(p);\n\n\t/*\n\t * sigaltstack should be cleared when sharing the same VM\n\t */\n\tif ((clone_flags & (CLONE_VM|CLONE_VFORK)) == CLONE_VM)\n\t\tsas_ss_reset(p);\n\n\t/*\n\t * Syscall tracing and stepping should be turned off in the\n\t * child regardless of CLONE_PTRACE.\n\t */\n\tuser_disable_single_step(p);\n\tclear_tsk_thread_flag(p, TIF_SYSCALL_TRACE);\n#ifdef TIF_SYSCALL_EMU\n\tclear_tsk_thread_flag(p, TIF_SYSCALL_EMU);\n#endif\n\tclear_tsk_latency_tracing(p);\n\n\t/* ok, now we should be set up.. */\n\tp->pid = pid_nr(pid);\n\tif (clone_flags & CLONE_THREAD) {\n\t\tp->group_leader = current->group_leader;\n\t\tp->tgid = current->tgid;\n\t} else {\n\t\tp->group_leader = p;\n\t\tp->tgid = p->pid;\n\t}\n\n\tp->nr_dirtied = 0;\n\tp->nr_dirtied_pause = 128 >> (PAGE_SHIFT - 10);\n\tp->dirty_paused_when = 0;\n\n\tp->pdeath_signal = 0;\n\tINIT_LIST_HEAD(&p->thread_group);\n\tp->task_works = NULL;\n\n\t/*\n\t * Ensure that the cgroup subsystem policies allow the new process to be\n\t * forked. It should be noted that the new process's css_set can be changed\n\t * between here and cgroup_post_fork() if an organisation operation is in\n\t * progress.\n\t */\n\tretval = cgroup_can_fork(p, args);\n\tif (retval)\n\t\tgoto bad_fork_put_pidfd;\n\n\t/*\n\t * From this point on we must avoid any synchronous user-space\n\t * communication until we take the tasklist-lock. In particular, we do\n\t * not want user-space to be able to predict the process start-time by\n\t * stalling fork(2) after we recorded the start_time but before it is\n\t * visible to the system.\n\t */\n\n\tp->start_time = ktime_get_ns();\n\tp->start_boottime = ktime_get_boottime_ns();\n\n\t/*\n\t * Make it visible to the rest of the system, but dont wake it up yet.\n\t * Need tasklist lock for parent etc handling!\n\t */\n\twrite_lock_irq(&tasklist_lock);\n\n\t/* CLONE_PARENT re-uses the old parent */\n\tif (clone_flags & (CLONE_PARENT|CLONE_THREAD)) {\n\t\tp->real_parent = current->real_parent;\n\t\tp->parent_exec_id = current->parent_exec_id;\n\t\tif (clone_flags & CLONE_THREAD)\n\t\t\tp->exit_signal = -1;\n\t\telse\n\t\t\tp->exit_signal = current->group_leader->exit_signal;\n\t} else {\n\t\tp->real_parent = current;\n\t\tp->parent_exec_id = current->self_exec_id;\n\t\tp->exit_signal = args->exit_signal;\n\t}\n\n\tklp_copy_process(p);\n\n\tspin_lock(&current->sighand->siglock);\n\n\t/*\n\t * Copy seccomp details explicitly here, in case they were changed\n\t * before holding sighand lock.\n\t */\n\tcopy_seccomp(p);\n\n\trseq_fork(p, clone_flags);\n\n\t/* Don't start children in a dying pid namespace */\n\tif (unlikely(!(ns_of_pid(pid)->pid_allocated & PIDNS_ADDING))) {\n\t\tretval = -ENOMEM;\n\t\tgoto bad_fork_cancel_cgroup;\n\t}\n\n\t/* Let kill terminate clone/fork in the middle */\n\tif (fatal_signal_pending(current)) {\n\t\tretval = -EINTR;\n\t\tgoto bad_fork_cancel_cgroup;\n\t}\n\n\t/* past the last point of failure */\n\tif (pidfile)\n\t\tfd_install(pidfd, pidfile);\n\n\tinit_task_pid_links(p);\n\tif (likely(p->pid)) {\n\t\tptrace_init_task(p, (clone_flags & CLONE_PTRACE) || trace);\n\n\t\tinit_task_pid(p, PIDTYPE_PID, pid);\n\t\tif (thread_group_leader(p)) {\n\t\t\tinit_task_pid(p, PIDTYPE_TGID, pid);\n\t\t\tinit_task_pid(p, PIDTYPE_PGID, task_pgrp(current));\n\t\t\tinit_task_pid(p, PIDTYPE_SID, task_session(current));\n\n\t\t\tif (is_child_reaper(pid)) {\n\t\t\t\tns_of_pid(pid)->child_reaper = p;\n\t\t\t\tp->signal->flags |= SIGNAL_UNKILLABLE;\n\t\t\t}\n\t\t\tp->signal->shared_pending.signal = delayed.signal;\n\t\t\tp->signal->tty = tty_kref_get(current->signal->tty);\n\t\t\t/*\n\t\t\t * Inherit has_child_subreaper flag under the same\n\t\t\t * tasklist_lock with adding child to the process tree\n\t\t\t * for propagate_has_child_subreaper optimization.\n\t\t\t */\n\t\t\tp->signal->has_child_subreaper = p->real_parent->signal->has_child_subreaper ||\n\t\t\t\t\t\t\t p->real_parent->signal->is_child_subreaper;\n\t\t\tlist_add_tail(&p->sibling, &p->real_parent->children);\n\t\t\tlist_add_tail_rcu(&p->tasks, &init_task.tasks);\n\t\t\tattach_pid(p, PIDTYPE_TGID);\n\t\t\tattach_pid(p, PIDTYPE_PGID);\n\t\t\tattach_pid(p, PIDTYPE_SID);\n\t\t\t__this_cpu_inc(process_counts);\n\t\t} else {\n\t\t\tcurrent->signal->nr_threads++;\n\t\t\tatomic_inc(&current->signal->live);\n\t\t\trefcount_inc(&current->signal->sigcnt);\n\t\t\ttask_join_group_stop(p);\n\t\t\tlist_add_tail_rcu(&p->thread_group,\n\t\t\t\t\t  &p->group_leader->thread_group);\n\t\t\tlist_add_tail_rcu(&p->thread_node,\n\t\t\t\t\t  &p->signal->thread_head);\n\t\t}\n\t\tattach_pid(p, PIDTYPE_PID);\n\t\tnr_threads++;\n\t}\n\ttotal_forks++;\n\thlist_del_init(&delayed.node);\n\tspin_unlock(&current->sighand->siglock);\n\tsyscall_tracepoint_update(p);\n\twrite_unlock_irq(&tasklist_lock);\n\n\tproc_fork_connector(p);\n\tsched_post_fork(p);\n\tcgroup_post_fork(p, args);\n\tperf_event_fork(p);\n\n\ttrace_task_newtask(p, clone_flags);\n\tuprobe_copy_process(p, clone_flags);\n\n\tcopy_oom_score_adj(clone_flags, p);\n\n\treturn p;\n\nbad_fork_cancel_cgroup:\n\tspin_unlock(&current->sighand->siglock);\n\twrite_unlock_irq(&tasklist_lock);\n\tcgroup_cancel_fork(p, args);\nbad_fork_put_pidfd:\n\tif (clone_flags & CLONE_PIDFD) {\n\t\tfput(pidfile);\n\t\tput_unused_fd(pidfd);\n\t}\nbad_fork_free_pid:\n\tif (pid != &init_struct_pid)\n\t\tfree_pid(pid);\nbad_fork_cleanup_thread:\n\texit_thread(p);\nbad_fork_cleanup_io:\n\tif (p->io_context)\n\t\texit_io_context(p);\nbad_fork_cleanup_namespaces:\n\texit_task_namespaces(p);\nbad_fork_cleanup_mm:\n\tif (p->mm) {\n\t\tmm_clear_owner(p->mm, p);\n\t\tmmput(p->mm);\n\t}\nbad_fork_cleanup_signal:\n\tif (!(clone_flags & CLONE_THREAD))\n\t\tfree_signal_struct(p->signal);\nbad_fork_cleanup_sighand:\n\t__cleanup_sighand(p->sighand);\nbad_fork_cleanup_fs:\n\texit_fs(p); /* blocking */\nbad_fork_cleanup_files:\n\texit_files(p); /* blocking */\nbad_fork_cleanup_semundo:\n\texit_sem(p);\nbad_fork_cleanup_security:\n\tsecurity_task_free(p);\nbad_fork_cleanup_audit:\n\taudit_free(p);\nbad_fork_cleanup_perf:\n\tperf_event_free_task(p);\nbad_fork_cleanup_policy:\n\tlockdep_free_task(p);\n#ifdef CONFIG_NUMA\n\tmpol_put(p->mempolicy);\nbad_fork_cleanup_threadgroup_lock:\n#endif\n\tdelayacct_tsk_free(p);\nbad_fork_cleanup_count:\n\tatomic_dec(&p->cred->user->processes);\n\texit_creds(p);\nbad_fork_free:\n\tp->state = TASK_DEAD;\n\tput_task_stack(p);\n\tdelayed_free_task(p);\nfork_out:\n\tspin_lock_irq(&current->sighand->siglock);\n\thlist_del_init(&delayed.node);\n\tspin_unlock_irq(&current->sighand->siglock);\n\treturn ERR_PTR(retval);\n}\n\nstatic inline void init_idle_pids(struct task_struct *idle)\n{\n\tenum pid_type type;\n\n\tfor (type = PIDTYPE_PID; type < PIDTYPE_MAX; ++type) {\n\t\tINIT_HLIST_NODE(&idle->pid_links[type]); /* not really needed */\n\t\tinit_task_pid(idle, type, &init_struct_pid);\n\t}\n}\n\nstruct task_struct *fork_idle(int cpu)\n{\n\tstruct task_struct *task;\n\tstruct kernel_clone_args args = {\n\t\t.flags = CLONE_VM,\n\t};\n\n\ttask = copy_process(&init_struct_pid, 0, cpu_to_node(cpu), &args);\n\tif (!IS_ERR(task)) {\n\t\tinit_idle_pids(task);\n\t\tinit_idle(task, cpu);\n\t}\n\n\treturn task;\n}\n\nstruct mm_struct *copy_init_mm(void)\n{\n\treturn dup_mm(NULL, &init_mm);\n}\n\n/*\n *  Ok, this is the main fork-routine.\n *\n * It copies the process, and if successful kick-starts\n * it and waits for it to finish using the VM if required.\n *\n * args->exit_signal is expected to be checked for sanity by the caller.\n */\npid_t kernel_clone(struct kernel_clone_args *args)\n{\n\tu64 clone_flags = args->flags;\n\tstruct completion vfork;\n\tstruct pid *pid;\n\tstruct task_struct *p;\n\tint trace = 0;\n\tpid_t nr;\n\n\t/*\n\t * For legacy clone() calls, CLONE_PIDFD uses the parent_tid argument\n\t * to return the pidfd. Hence, CLONE_PIDFD and CLONE_PARENT_SETTID are\n\t * mutually exclusive. With clone3() CLONE_PIDFD has grown a separate\n\t * field in struct clone_args and it still doesn't make sense to have\n\t * them both point at the same memory location. Performing this check\n\t * here has the advantage that we don't need to have a separate helper\n\t * to check for legacy clone().\n\t */\n\tif ((args->flags & CLONE_PIDFD) &&\n\t    (args->flags & CLONE_PARENT_SETTID) &&\n\t    (args->pidfd == args->parent_tid))\n\t\treturn -EINVAL;\n\n\t/*\n\t * Determine whether and which event to report to ptracer.  When\n\t * called from kernel_thread or CLONE_UNTRACED is explicitly\n\t * requested, no event is reported; otherwise, report if the event\n\t * for the type of forking is enabled.\n\t */\n\tif (!(clone_flags & CLONE_UNTRACED)) {\n\t\tif (clone_flags & CLONE_VFORK)\n\t\t\ttrace = PTRACE_EVENT_VFORK;\n\t\telse if (args->exit_signal != SIGCHLD)\n\t\t\ttrace = PTRACE_EVENT_CLONE;\n\t\telse\n\t\t\ttrace = PTRACE_EVENT_FORK;\n\n\t\tif (likely(!ptrace_event_enabled(current, trace)))\n\t\t\ttrace = 0;\n\t}\n\n\tp = copy_process(NULL, trace, NUMA_NO_NODE, args);\n\tadd_latent_entropy();\n\n\tif (IS_ERR(p))\n\t\treturn PTR_ERR(p);\n\n\t/*\n\t * Do this prior waking up the new thread - the thread pointer\n\t * might get invalid after that point, if the thread exits quickly.\n\t */\n\ttrace_sched_process_fork(current, p);\n\n\tpid = get_task_pid(p, PIDTYPE_PID);\n\tnr = pid_vnr(pid);\n\n\tif (clone_flags & CLONE_PARENT_SETTID)\n\t\tput_user(nr, args->parent_tid);\n\n\tif (clone_flags & CLONE_VFORK) {\n\t\tp->vfork_done = &vfork;\n\t\tinit_completion(&vfork);\n\t\tget_task_struct(p);\n\t}\n\n\twake_up_new_task(p);\n\n\t/* forking complete and child started to run, tell ptracer */\n\tif (unlikely(trace))\n\t\tptrace_event_pid(trace, pid);\n\n\tif (clone_flags & CLONE_VFORK) {\n\t\tif (!wait_for_vfork_done(p, &vfork))\n\t\t\tptrace_event_pid(PTRACE_EVENT_VFORK_DONE, pid);\n\t}\n\n\tput_pid(pid);\n\treturn nr;\n}\n\n/*\n * Create a kernel thread.\n */\npid_t kernel_thread(int (*fn)(void *), void *arg, unsigned long flags)\n{\n\tstruct kernel_clone_args args = {\n\t\t.flags\t\t= ((lower_32_bits(flags) | CLONE_VM |\n\t\t\t\t    CLONE_UNTRACED) & ~CSIGNAL),\n\t\t.exit_signal\t= (lower_32_bits(flags) & CSIGNAL),\n\t\t.stack\t\t= (unsigned long)fn,\n\t\t.stack_size\t= (unsigned long)arg,\n\t};\n\n\treturn kernel_clone(&args);\n}\n\n#ifdef __ARCH_WANT_SYS_FORK\nSYSCALL_DEFINE0(fork)\n{\n#ifdef CONFIG_MMU\n\tstruct kernel_clone_args args = {\n\t\t.exit_signal = SIGCHLD,\n\t};\n\n\treturn kernel_clone(&args);\n#else\n\t/* can not support in nommu mode */\n\treturn -EINVAL;\n#endif\n}\n#endif\n\n#ifdef __ARCH_WANT_SYS_VFORK\nSYSCALL_DEFINE0(vfork)\n{\n\tstruct kernel_clone_args args = {\n\t\t.flags\t\t= CLONE_VFORK | CLONE_VM,\n\t\t.exit_signal\t= SIGCHLD,\n\t};\n\n\treturn kernel_clone(&args);\n}\n#endif\n\n#ifdef __ARCH_WANT_SYS_CLONE\n#ifdef CONFIG_CLONE_BACKWARDS\nSYSCALL_DEFINE5(clone, unsigned long, clone_flags, unsigned long, newsp,\n\t\t int __user *, parent_tidptr,\n\t\t unsigned long, tls,\n\t\t int __user *, child_tidptr)\n#elif defined(CONFIG_CLONE_BACKWARDS2)\nSYSCALL_DEFINE5(clone, unsigned long, newsp, unsigned long, clone_flags,\n\t\t int __user *, parent_tidptr,\n\t\t int __user *, child_tidptr,\n\t\t unsigned long, tls)\n#elif defined(CONFIG_CLONE_BACKWARDS3)\nSYSCALL_DEFINE6(clone, unsigned long, clone_flags, unsigned long, newsp,\n\t\tint, stack_size,\n\t\tint __user *, parent_tidptr,\n\t\tint __user *, child_tidptr,\n\t\tunsigned long, tls)\n#else\nSYSCALL_DEFINE5(clone, unsigned long, clone_flags, unsigned long, newsp,\n\t\t int __user *, parent_tidptr,\n\t\t int __user *, child_tidptr,\n\t\t unsigned long, tls)\n#endif\n{\n\tstruct kernel_clone_args args = {\n\t\t.flags\t\t= (lower_32_bits(clone_flags) & ~CSIGNAL),\n\t\t.pidfd\t\t= parent_tidptr,\n\t\t.child_tid\t= child_tidptr,\n\t\t.parent_tid\t= parent_tidptr,\n\t\t.exit_signal\t= (lower_32_bits(clone_flags) & CSIGNAL),\n\t\t.stack\t\t= newsp,\n\t\t.tls\t\t= tls,\n\t};\n\n\treturn kernel_clone(&args);\n}\n#endif\n\n#ifdef __ARCH_WANT_SYS_CLONE3\n\nnoinline static int copy_clone_args_from_user(struct kernel_clone_args *kargs,\n\t\t\t\t\t      struct clone_args __user *uargs,\n\t\t\t\t\t      size_t usize)\n{\n\tint err;\n\tstruct clone_args args;\n\tpid_t *kset_tid = kargs->set_tid;\n\n\tBUILD_BUG_ON(offsetofend(struct clone_args, tls) !=\n\t\t     CLONE_ARGS_SIZE_VER0);\n\tBUILD_BUG_ON(offsetofend(struct clone_args, set_tid_size) !=\n\t\t     CLONE_ARGS_SIZE_VER1);\n\tBUILD_BUG_ON(offsetofend(struct clone_args, cgroup) !=\n\t\t     CLONE_ARGS_SIZE_VER2);\n\tBUILD_BUG_ON(sizeof(struct clone_args) != CLONE_ARGS_SIZE_VER2);\n\n\tif (unlikely(usize > PAGE_SIZE))\n\t\treturn -E2BIG;\n\tif (unlikely(usize < CLONE_ARGS_SIZE_VER0))\n\t\treturn -EINVAL;\n\n\terr = copy_struct_from_user(&args, sizeof(args), uargs, usize);\n\tif (err)\n\t\treturn err;\n\n\tif (unlikely(args.set_tid_size > MAX_PID_NS_LEVEL))\n\t\treturn -EINVAL;\n\n\tif (unlikely(!args.set_tid && args.set_tid_size > 0))\n\t\treturn -EINVAL;\n\n\tif (unlikely(args.set_tid && args.set_tid_size == 0))\n\t\treturn -EINVAL;\n\n\t/*\n\t * Verify that higher 32bits of exit_signal are unset and that\n\t * it is a valid signal\n\t */\n\tif (unlikely((args.exit_signal & ~((u64)CSIGNAL)) ||\n\t\t     !valid_signal(args.exit_signal)))\n\t\treturn -EINVAL;\n\n\tif ((args.flags & CLONE_INTO_CGROUP) &&\n\t    (args.cgroup > INT_MAX || usize < CLONE_ARGS_SIZE_VER2))\n\t\treturn -EINVAL;\n\n\t*kargs = (struct kernel_clone_args){\n\t\t.flags\t\t= args.flags,\n\t\t.pidfd\t\t= u64_to_user_ptr(args.pidfd),\n\t\t.child_tid\t= u64_to_user_ptr(args.child_tid),\n\t\t.parent_tid\t= u64_to_user_ptr(args.parent_tid),\n\t\t.exit_signal\t= args.exit_signal,\n\t\t.stack\t\t= args.stack,\n\t\t.stack_size\t= args.stack_size,\n\t\t.tls\t\t= args.tls,\n\t\t.set_tid_size\t= args.set_tid_size,\n\t\t.cgroup\t\t= args.cgroup,\n\t};\n\n\tif (args.set_tid &&\n\t\tcopy_from_user(kset_tid, u64_to_user_ptr(args.set_tid),\n\t\t\t(kargs->set_tid_size * sizeof(pid_t))))\n\t\treturn -EFAULT;\n\n\tkargs->set_tid = kset_tid;\n\n\treturn 0;\n}\n\n/**\n * clone3_stack_valid - check and prepare stack\n * @kargs: kernel clone args\n *\n * Verify that the stack arguments userspace gave us are sane.\n * In addition, set the stack direction for userspace since it's easy for us to\n * determine.\n */\nstatic inline bool clone3_stack_valid(struct kernel_clone_args *kargs)\n{\n\tif (kargs->stack == 0) {\n\t\tif (kargs->stack_size > 0)\n\t\t\treturn false;\n\t} else {\n\t\tif (kargs->stack_size == 0)\n\t\t\treturn false;\n\n\t\tif (!access_ok((void __user *)kargs->stack, kargs->stack_size))\n\t\t\treturn false;\n\n#if !defined(CONFIG_STACK_GROWSUP) && !defined(CONFIG_IA64)\n\t\tkargs->stack += kargs->stack_size;\n#endif\n\t}\n\n\treturn true;\n}\n\nstatic bool clone3_args_valid(struct kernel_clone_args *kargs)\n{\n\t/* Verify that no unknown flags are passed along. */\n\tif (kargs->flags &\n\t    ~(CLONE_LEGACY_FLAGS | CLONE_CLEAR_SIGHAND | CLONE_INTO_CGROUP))\n\t\treturn false;\n\n\t/*\n\t * - make the CLONE_DETACHED bit reuseable for clone3\n\t * - make the CSIGNAL bits reuseable for clone3\n\t */\n\tif (kargs->flags & (CLONE_DETACHED | CSIGNAL))\n\t\treturn false;\n\n\tif ((kargs->flags & (CLONE_SIGHAND | CLONE_CLEAR_SIGHAND)) ==\n\t    (CLONE_SIGHAND | CLONE_CLEAR_SIGHAND))\n\t\treturn false;\n\n\tif ((kargs->flags & (CLONE_THREAD | CLONE_PARENT)) &&\n\t    kargs->exit_signal)\n\t\treturn false;\n\n\tif (!clone3_stack_valid(kargs))\n\t\treturn false;\n\n\treturn true;\n}\n\n/**\n * clone3 - create a new process with specific properties\n * @uargs: argument structure\n * @size:  size of @uargs\n *\n * clone3() is the extensible successor to clone()/clone2().\n * It takes a struct as argument that is versioned by its size.\n *\n * Return: On success, a positive PID for the child process.\n *         On error, a negative errno number.\n */\nSYSCALL_DEFINE2(clone3, struct clone_args __user *, uargs, size_t, size)\n{\n\tint err;\n\n\tstruct kernel_clone_args kargs;\n\tpid_t set_tid[MAX_PID_NS_LEVEL];\n\n\tkargs.set_tid = set_tid;\n\n\terr = copy_clone_args_from_user(&kargs, uargs, size);\n\tif (err)\n\t\treturn err;\n\n\tif (!clone3_args_valid(&kargs))\n\t\treturn -EINVAL;\n\n\treturn kernel_clone(&kargs);\n}\n#endif\n\nvoid walk_process_tree(struct task_struct *top, proc_visitor visitor, void *data)\n{\n\tstruct task_struct *leader, *parent, *child;\n\tint res;\n\n\tread_lock(&tasklist_lock);\n\tleader = top = top->group_leader;\ndown:\n\tfor_each_thread(leader, parent) {\n\t\tlist_for_each_entry(child, &parent->children, sibling) {\n\t\t\tres = visitor(child, data);\n\t\t\tif (res) {\n\t\t\t\tif (res < 0)\n\t\t\t\t\tgoto out;\n\t\t\t\tleader = child;\n\t\t\t\tgoto down;\n\t\t\t}\nup:\n\t\t\t;\n\t\t}\n\t}\n\n\tif (leader != top) {\n\t\tchild = leader;\n\t\tparent = child->real_parent;\n\t\tleader = parent->group_leader;\n\t\tgoto up;\n\t}\nout:\n\tread_unlock(&tasklist_lock);\n}\n\n#ifndef ARCH_MIN_MMSTRUCT_ALIGN\n#define ARCH_MIN_MMSTRUCT_ALIGN 0\n#endif\n\nstatic void sighand_ctor(void *data)\n{\n\tstruct sighand_struct *sighand = data;\n\n\tspin_lock_init(&sighand->siglock);\n\tinit_waitqueue_head(&sighand->signalfd_wqh);\n}\n\nvoid __init proc_caches_init(void)\n{\n\tunsigned int mm_size;\n\n\tsighand_cachep = kmem_cache_create(\"sighand_cache\",\n\t\t\tsizeof(struct sighand_struct), 0,\n\t\t\tSLAB_HWCACHE_ALIGN|SLAB_PANIC|SLAB_TYPESAFE_BY_RCU|\n\t\t\tSLAB_ACCOUNT, sighand_ctor);\n\tsignal_cachep = kmem_cache_create(\"signal_cache\",\n\t\t\tsizeof(struct signal_struct), 0,\n\t\t\tSLAB_HWCACHE_ALIGN|SLAB_PANIC|SLAB_ACCOUNT,\n\t\t\tNULL);\n\tfiles_cachep = kmem_cache_create(\"files_cache\",\n\t\t\tsizeof(struct files_struct), 0,\n\t\t\tSLAB_HWCACHE_ALIGN|SLAB_PANIC|SLAB_ACCOUNT,\n\t\t\tNULL);\n\tfs_cachep = kmem_cache_create(\"fs_cache\",\n\t\t\tsizeof(struct fs_struct), 0,\n\t\t\tSLAB_HWCACHE_ALIGN|SLAB_PANIC|SLAB_ACCOUNT,\n\t\t\tNULL);\n\n\t/*\n\t * The mm_cpumask is located at the end of mm_struct, and is\n\t * dynamically sized based on the maximum CPU number this system\n\t * can have, taking hotplug into account (nr_cpu_ids).\n\t */\n\tmm_size = sizeof(struct mm_struct) + cpumask_size();\n\n\tmm_cachep = kmem_cache_create_usercopy(\"mm_struct\",\n\t\t\tmm_size, ARCH_MIN_MMSTRUCT_ALIGN,\n\t\t\tSLAB_HWCACHE_ALIGN|SLAB_PANIC|SLAB_ACCOUNT,\n\t\t\toffsetof(struct mm_struct, saved_auxv),\n\t\t\tsizeof_field(struct mm_struct, saved_auxv),\n\t\t\tNULL);\n\tvm_area_cachep = KMEM_CACHE(vm_area_struct, SLAB_PANIC|SLAB_ACCOUNT);\n\tmmap_init();\n\tnsproxy_cache_init();\n}\n\n/*\n * Check constraints on flags passed to the unshare system call.\n */\nstatic int check_unshare_flags(unsigned long unshare_flags)\n{\n\tif (unshare_flags & ~(CLONE_THREAD|CLONE_FS|CLONE_NEWNS|CLONE_SIGHAND|\n\t\t\t\tCLONE_VM|CLONE_FILES|CLONE_SYSVSEM|\n\t\t\t\tCLONE_NEWUTS|CLONE_NEWIPC|CLONE_NEWNET|\n\t\t\t\tCLONE_NEWUSER|CLONE_NEWPID|CLONE_NEWCGROUP|\n\t\t\t\tCLONE_NEWTIME))\n\t\treturn -EINVAL;\n\t/*\n\t * Not implemented, but pretend it works if there is nothing\n\t * to unshare.  Note that unsharing the address space or the\n\t * signal handlers also need to unshare the signal queues (aka\n\t * CLONE_THREAD).\n\t */\n\tif (unshare_flags & (CLONE_THREAD | CLONE_SIGHAND | CLONE_VM)) {\n\t\tif (!thread_group_empty(current))\n\t\t\treturn -EINVAL;\n\t}\n\tif (unshare_flags & (CLONE_SIGHAND | CLONE_VM)) {\n\t\tif (refcount_read(&current->sighand->count) > 1)\n\t\t\treturn -EINVAL;\n\t}\n\tif (unshare_flags & CLONE_VM) {\n\t\tif (!current_is_single_threaded())\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n/*\n * Unshare the filesystem structure if it is being shared\n */\nstatic int unshare_fs(unsigned long unshare_flags, struct fs_struct **new_fsp)\n{\n\tstruct fs_struct *fs = current->fs;\n\n\tif (!(unshare_flags & CLONE_FS) || !fs)\n\t\treturn 0;\n\n\t/* don't need lock here; in the worst case we'll do useless copy */\n\tif (fs->users == 1)\n\t\treturn 0;\n\n\t*new_fsp = copy_fs_struct(fs);\n\tif (!*new_fsp)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\n/*\n * Unshare file descriptor table if it is being shared\n */\nint unshare_fd(unsigned long unshare_flags, unsigned int max_fds,\n\t       struct files_struct **new_fdp)\n{\n\tstruct files_struct *fd = current->files;\n\tint error = 0;\n\n\tif ((unshare_flags & CLONE_FILES) &&\n\t    (fd && atomic_read(&fd->count) > 1)) {\n\t\t*new_fdp = dup_fd(fd, max_fds, &error);\n\t\tif (!*new_fdp)\n\t\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\n/*\n * unshare allows a process to 'unshare' part of the process\n * context which was originally shared using clone.  copy_*\n * functions used by kernel_clone() cannot be used here directly\n * because they modify an inactive task_struct that is being\n * constructed. Here we are modifying the current, active,\n * task_struct.\n */\nint ksys_unshare(unsigned long unshare_flags)\n{\n\tstruct fs_struct *fs, *new_fs = NULL;\n\tstruct files_struct *fd, *new_fd = NULL;\n\tstruct cred *new_cred = NULL;\n\tstruct nsproxy *new_nsproxy = NULL;\n\tint do_sysvsem = 0;\n\tint err;\n\n\t/*\n\t * If unsharing a user namespace must also unshare the thread group\n\t * and unshare the filesystem root and working directories.\n\t */\n\tif (unshare_flags & CLONE_NEWUSER)\n\t\tunshare_flags |= CLONE_THREAD | CLONE_FS;\n\t/*\n\t * If unsharing vm, must also unshare signal handlers.\n\t */\n\tif (unshare_flags & CLONE_VM)\n\t\tunshare_flags |= CLONE_SIGHAND;\n\t/*\n\t * If unsharing a signal handlers, must also unshare the signal queues.\n\t */\n\tif (unshare_flags & CLONE_SIGHAND)\n\t\tunshare_flags |= CLONE_THREAD;\n\t/*\n\t * If unsharing namespace, must also unshare filesystem information.\n\t */\n\tif (unshare_flags & CLONE_NEWNS)\n\t\tunshare_flags |= CLONE_FS;\n\n\terr = check_unshare_flags(unshare_flags);\n\tif (err)\n\t\tgoto bad_unshare_out;\n\t/*\n\t * CLONE_NEWIPC must also detach from the undolist: after switching\n\t * to a new ipc namespace, the semaphore arrays from the old\n\t * namespace are unreachable.\n\t */\n\tif (unshare_flags & (CLONE_NEWIPC|CLONE_SYSVSEM))\n\t\tdo_sysvsem = 1;\n\terr = unshare_fs(unshare_flags, &new_fs);\n\tif (err)\n\t\tgoto bad_unshare_out;\n\terr = unshare_fd(unshare_flags, NR_OPEN_MAX, &new_fd);\n\tif (err)\n\t\tgoto bad_unshare_cleanup_fs;\n\terr = unshare_userns(unshare_flags, &new_cred);\n\tif (err)\n\t\tgoto bad_unshare_cleanup_fd;\n\terr = unshare_nsproxy_namespaces(unshare_flags, &new_nsproxy,\n\t\t\t\t\t new_cred, new_fs);\n\tif (err)\n\t\tgoto bad_unshare_cleanup_cred;\n\n\tif (new_fs || new_fd || do_sysvsem || new_cred || new_nsproxy) {\n\t\tif (do_sysvsem) {\n\t\t\t/*\n\t\t\t * CLONE_SYSVSEM is equivalent to sys_exit().\n\t\t\t */\n\t\t\texit_sem(current);\n\t\t}\n\t\tif (unshare_flags & CLONE_NEWIPC) {\n\t\t\t/* Orphan segments in old ns (see sem above). */\n\t\t\texit_shm(current);\n\t\t\tshm_init_task(current);\n\t\t}\n\n\t\tif (new_nsproxy)\n\t\t\tswitch_task_namespaces(current, new_nsproxy);\n\n\t\ttask_lock(current);\n\n\t\tif (new_fs) {\n\t\t\tfs = current->fs;\n\t\t\tspin_lock(&fs->lock);\n\t\t\tcurrent->fs = new_fs;\n\t\t\tif (--fs->users)\n\t\t\t\tnew_fs = NULL;\n\t\t\telse\n\t\t\t\tnew_fs = fs;\n\t\t\tspin_unlock(&fs->lock);\n\t\t}\n\n\t\tif (new_fd) {\n\t\t\tfd = current->files;\n\t\t\tcurrent->files = new_fd;\n\t\t\tnew_fd = fd;\n\t\t}\n\n\t\ttask_unlock(current);\n\n\t\tif (new_cred) {\n\t\t\t/* Install the new user namespace */\n\t\t\tcommit_creds(new_cred);\n\t\t\tnew_cred = NULL;\n\t\t}\n\t}\n\n\tperf_event_namespaces(current);\n\nbad_unshare_cleanup_cred:\n\tif (new_cred)\n\t\tput_cred(new_cred);\nbad_unshare_cleanup_fd:\n\tif (new_fd)\n\t\tput_files_struct(new_fd);\n\nbad_unshare_cleanup_fs:\n\tif (new_fs)\n\t\tfree_fs_struct(new_fs);\n\nbad_unshare_out:\n\treturn err;\n}\n\nSYSCALL_DEFINE1(unshare, unsigned long, unshare_flags)\n{\n\treturn ksys_unshare(unshare_flags);\n}\n\n/*\n *\tHelper to unshare the files of the current task.\n *\tWe don't want to expose copy_files internals to\n *\tthe exec layer of the kernel.\n */\n\nint unshare_files(struct files_struct **displaced)\n{\n\tstruct task_struct *task = current;\n\tstruct files_struct *copy = NULL;\n\tint error;\n\n\terror = unshare_fd(CLONE_FILES, NR_OPEN_MAX, &copy);\n\tif (error || !copy) {\n\t\t*displaced = NULL;\n\t\treturn error;\n\t}\n\t*displaced = task->files;\n\ttask_lock(task);\n\ttask->files = copy;\n\ttask_unlock(task);\n\treturn 0;\n}\n\nint sysctl_max_threads(struct ctl_table *table, int write,\n\t\t       void *buffer, size_t *lenp, loff_t *ppos)\n{\n\tstruct ctl_table t;\n\tint ret;\n\tint threads = max_threads;\n\tint min = 1;\n\tint max = MAX_THREADS;\n\n\tt = *table;\n\tt.data = &threads;\n\tt.extra1 = &min;\n\tt.extra2 = &max;\n\n\tret = proc_dointvec_minmax(&t, write, buffer, lenp, ppos);\n\tif (ret || !write)\n\t\treturn ret;\n\n\tmax_threads = threads;\n\n\treturn 0;\n}\n"], "filenames": ["kernel/fork.c"], "buggy_code_start_loc": [2170], "buggy_code_end_loc": [2223], "fixing_code_start_loc": [2169], "fixing_code_end_loc": [2224], "type": "CWE-665", "message": "A flaw possibility of race condition and incorrect initialization of the process id was found in the Linux kernel child/parent process identification handling while filtering signal handlers. A local attacker is able to abuse this flaw to bypass checks to send any signal to a privileged process.", "other": {"cve": {"id": "CVE-2020-35508", "sourceIdentifier": "secalert@redhat.com", "published": "2021-03-26T17:15:12.203", "lastModified": "2023-02-12T23:41:00.150", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "A flaw possibility of race condition and incorrect initialization of the process id was found in the Linux kernel child/parent process identification handling while filtering signal handlers. A local attacker is able to abuse this flaw to bypass checks to send any signal to a privileged process."}, {"lang": "es", "value": "Se ha encontrado una posibilidad de fallo de condici\u00f3n de carrera y de inicializaci\u00f3n incorrecta del id del proceso en el manejo del id del proceso child/parent del kernel de Linux mientras se filtran los manejadores de se\u00f1ales. Un atacante local es capaz de abusar de este fallo para omitir unas comprobaciones y enviar cualquier se\u00f1al a un proceso privilegiado."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:L/I:L/A:L", "attackVector": "LOCAL", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 4.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.0, "impactScore": 3.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "LOCAL", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 4.4}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.4, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "secalert@redhat.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-665"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-362"}, {"lang": "en", "value": "CWE-665"}]}], "configurations": [{"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "5.12", "matchCriteriaId": "40362FFA-6C99-41DB-AC04-5B835E7DE052"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:5.12:-:*:*:*:*:*:*", "matchCriteriaId": "75EB504D-4A83-4C67-9C8D-FD9C6C8EB4CD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:5.12:rc1:*:*:*:*:*:*", "matchCriteriaId": "07875739-0CCB-4F48-9330-3D4B6A4064FA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:5.12:rc2:*:*:*:*:*:*", "matchCriteriaId": "DA09B732-04F8-452C-94CF-97644E78684D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:5.12:rc3:*:*:*:*:*:*", "matchCriteriaId": "E5371152-7515-4908-BB7E-494805EA5DF2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:5.12:rc4:*:*:*:*:*:*", "matchCriteriaId": "D7788E5B-D54E-45BF-9043-2C7B77842FD0"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "F4CFF558-3C47-480D-A2F0-BABF26042943"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:a700s_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "FDD92BFA-9117-4E6E-A13F-ED064B4B7284"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:a700s:-:*:*:*:*:*:*:*", "matchCriteriaId": "4B7DA42F-5D64-4967-A2D4-6210FE507841"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:brocade_fabric_operating_system_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "05BEB6DA-10B8-43D8-A527-68E26F4875CE"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:fas8300_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "89706810-031B-49F0-B353-FD27FD7B2776"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:fas8300:-:*:*:*:*:*:*:*", "matchCriteriaId": "03BCC59D-C782-4149-B6DC-5DDAFAB48F2D"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:fas8700_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "FDD1E822-1EA6-4E62-A58B-2378149D20DC"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:fas8700:-:*:*:*:*:*:*:*", "matchCriteriaId": "E07EAE5F-B1B5-4FDA-9B50-8CB1D2AFC5A0"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:aff_a400_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "56FD9B9A-BBE5-4CA5-B9F9-B16E1FE738C8"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:aff_a400:-:*:*:*:*:*:*:*", "matchCriteriaId": "F3E70A56-DBA8-45C7-8C49-1A036501156F"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h300s_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "6770B6C3-732E-4E22-BF1C-2D2FD610061C"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h300s:-:*:*:*:*:*:*:*", "matchCriteriaId": "9F9C8C20-42EB-4AB5-BD97-212DEB070C43"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h500s_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "7FFF7106-ED78-49BA-9EC5-B889E3685D53"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h500s:-:*:*:*:*:*:*:*", "matchCriteriaId": "E63D8B0F-006E-4801-BF9D-1C001BBFB4F9"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h700s_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "56409CEC-5A1E-4450-AA42-641E459CC2AF"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h700s:-:*:*:*:*:*:*:*", "matchCriteriaId": "B06F4839-D16A-4A61-9BB5-55B13F41E47F"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h300e_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "108A2215-50FB-4074-94CF-C130FA14566D"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h300e:-:*:*:*:*:*:*:*", "matchCriteriaId": "7AFC73CE-ABB9-42D3-9A71-3F5BC5381E0E"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h500e_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "32F0B6C0-F930-480D-962B-3F4EFDCC13C7"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h500e:-:*:*:*:*:*:*:*", "matchCriteriaId": "803BC414-B250-4E3A-A478-A3881340D6B8"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h700e_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "0FEB3337-BFDE-462A-908B-176F92053CEC"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h700e:-:*:*:*:*:*:*:*", "matchCriteriaId": "736AEAE9-782B-4F71-9893-DED53367E102"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h410s_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "D0B4AD8A-F172-4558-AEC6-FF424BA2D912"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h410s:-:*:*:*:*:*:*:*", "matchCriteriaId": "8497A4C9-8474-4A62-8331-3FE862ED4098"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h410c_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "234DEFE0-5CE5-4B0A-96B8-5D227CB8ED31"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h410c:-:*:*:*:*:*:*:*", "matchCriteriaId": "CDDF61B7-EC5C-467C-B710-B89F502CD04F"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h610c_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "89612649-BACF-4FAC-9BA4-324724FD93A6"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h610c:-:*:*:*:*:*:*:*", "matchCriteriaId": "F3D9B255-C1AF-42D1-BF9B-13642FBDC080"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h610s_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "FD7CFE0E-9D1E-4495-B302-89C3096FC0DF"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h610s:-:*:*:*:*:*:*:*", "matchCriteriaId": "F63A3FA7-AAED-4A9D-9FDE-6195302DA0F6"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h615c_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "5921A877-18BF-43FE-915C-D226E140ACFC"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h615c:-:*:*:*:*:*:*:*", "matchCriteriaId": "7296A1F2-D315-4FD5-8A73-65C480C855BE"}]}]}], "references": [{"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1902724", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/b4e00444cab4c3f3fec876dc0cccc8cbb0d1a948", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20210513-0006/", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/b4e00444cab4c3f3fec876dc0cccc8cbb0d1a948"}}