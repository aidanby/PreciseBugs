{"buggy_code": ["/*\n * PNG image format\n * Copyright (c) 2003 Fabrice Bellard\n *\n * This file is part of FFmpeg.\n *\n * FFmpeg is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with FFmpeg; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n//#define DEBUG\n\n#include \"libavutil/avassert.h\"\n#include \"libavutil/bprint.h\"\n#include \"libavutil/imgutils.h\"\n#include \"libavutil/stereo3d.h\"\n\n#include \"avcodec.h\"\n#include \"bytestream.h\"\n#include \"internal.h\"\n#include \"apng.h\"\n#include \"png.h\"\n#include \"pngdsp.h\"\n#include \"thread.h\"\n\n#include <zlib.h>\n\ntypedef struct PNGDecContext {\n    PNGDSPContext dsp;\n    AVCodecContext *avctx;\n\n    GetByteContext gb;\n    ThreadFrame previous_picture;\n    ThreadFrame last_picture;\n    ThreadFrame picture;\n\n    int state;\n    int width, height;\n    int cur_w, cur_h;\n    int last_w, last_h;\n    int x_offset, y_offset;\n    int last_x_offset, last_y_offset;\n    uint8_t dispose_op, blend_op;\n    uint8_t last_dispose_op;\n    int bit_depth;\n    int color_type;\n    int compression_type;\n    int interlace_type;\n    int filter_type;\n    int channels;\n    int bits_per_pixel;\n    int bpp;\n    int has_trns;\n    uint8_t transparent_color_be[6];\n\n    uint8_t *image_buf;\n    int image_linesize;\n    uint32_t palette[256];\n    uint8_t *crow_buf;\n    uint8_t *last_row;\n    unsigned int last_row_size;\n    uint8_t *tmp_row;\n    unsigned int tmp_row_size;\n    uint8_t *buffer;\n    int buffer_size;\n    int pass;\n    int crow_size; /* compressed row size (include filter type) */\n    int row_size; /* decompressed row size */\n    int pass_row_size; /* decompress row size of the current pass */\n    int y;\n    z_stream zstream;\n} PNGDecContext;\n\n/* Mask to determine which pixels are valid in a pass */\nstatic const uint8_t png_pass_mask[NB_PASSES] = {\n    0x01, 0x01, 0x11, 0x11, 0x55, 0x55, 0xff,\n};\n\n/* Mask to determine which y pixels can be written in a pass */\nstatic const uint8_t png_pass_dsp_ymask[NB_PASSES] = {\n    0xff, 0xff, 0x0f, 0xff, 0x33, 0xff, 0x55,\n};\n\n/* Mask to determine which pixels to overwrite while displaying */\nstatic const uint8_t png_pass_dsp_mask[NB_PASSES] = {\n    0xff, 0x0f, 0xff, 0x33, 0xff, 0x55, 0xff\n};\n\n/* NOTE: we try to construct a good looking image at each pass. width\n * is the original image width. We also do pixel format conversion at\n * this stage */\nstatic void png_put_interlaced_row(uint8_t *dst, int width,\n                                   int bits_per_pixel, int pass,\n                                   int color_type, const uint8_t *src)\n{\n    int x, mask, dsp_mask, j, src_x, b, bpp;\n    uint8_t *d;\n    const uint8_t *s;\n\n    mask     = png_pass_mask[pass];\n    dsp_mask = png_pass_dsp_mask[pass];\n\n    switch (bits_per_pixel) {\n    case 1:\n        src_x = 0;\n        for (x = 0; x < width; x++) {\n            j = (x & 7);\n            if ((dsp_mask << j) & 0x80) {\n                b = (src[src_x >> 3] >> (7 - (src_x & 7))) & 1;\n                dst[x >> 3] &= 0xFF7F>>j;\n                dst[x >> 3] |= b << (7 - j);\n            }\n            if ((mask << j) & 0x80)\n                src_x++;\n        }\n        break;\n    case 2:\n        src_x = 0;\n        for (x = 0; x < width; x++) {\n            int j2 = 2 * (x & 3);\n            j = (x & 7);\n            if ((dsp_mask << j) & 0x80) {\n                b = (src[src_x >> 2] >> (6 - 2*(src_x & 3))) & 3;\n                dst[x >> 2] &= 0xFF3F>>j2;\n                dst[x >> 2] |= b << (6 - j2);\n            }\n            if ((mask << j) & 0x80)\n                src_x++;\n        }\n        break;\n    case 4:\n        src_x = 0;\n        for (x = 0; x < width; x++) {\n            int j2 = 4*(x&1);\n            j = (x & 7);\n            if ((dsp_mask << j) & 0x80) {\n                b = (src[src_x >> 1] >> (4 - 4*(src_x & 1))) & 15;\n                dst[x >> 1] &= 0xFF0F>>j2;\n                dst[x >> 1] |= b << (4 - j2);\n            }\n            if ((mask << j) & 0x80)\n                src_x++;\n        }\n        break;\n    default:\n        bpp = bits_per_pixel >> 3;\n        d   = dst;\n        s   = src;\n            for (x = 0; x < width; x++) {\n                j = x & 7;\n                if ((dsp_mask << j) & 0x80) {\n                    memcpy(d, s, bpp);\n                }\n                d += bpp;\n                if ((mask << j) & 0x80)\n                    s += bpp;\n            }\n        break;\n    }\n}\n\nvoid ff_add_png_paeth_prediction(uint8_t *dst, uint8_t *src, uint8_t *top,\n                                 int w, int bpp)\n{\n    int i;\n    for (i = 0; i < w; i++) {\n        int a, b, c, p, pa, pb, pc;\n\n        a = dst[i - bpp];\n        b = top[i];\n        c = top[i - bpp];\n\n        p  = b - c;\n        pc = a - c;\n\n        pa = abs(p);\n        pb = abs(pc);\n        pc = abs(p + pc);\n\n        if (pa <= pb && pa <= pc)\n            p = a;\n        else if (pb <= pc)\n            p = b;\n        else\n            p = c;\n        dst[i] = p + src[i];\n    }\n}\n\n#define UNROLL1(bpp, op)                                                      \\\n    {                                                                         \\\n        r = dst[0];                                                           \\\n        if (bpp >= 2)                                                         \\\n            g = dst[1];                                                       \\\n        if (bpp >= 3)                                                         \\\n            b = dst[2];                                                       \\\n        if (bpp >= 4)                                                         \\\n            a = dst[3];                                                       \\\n        for (; i <= size - bpp; i += bpp) {                                   \\\n            dst[i + 0] = r = op(r, src[i + 0], last[i + 0]);                  \\\n            if (bpp == 1)                                                     \\\n                continue;                                                     \\\n            dst[i + 1] = g = op(g, src[i + 1], last[i + 1]);                  \\\n            if (bpp == 2)                                                     \\\n                continue;                                                     \\\n            dst[i + 2] = b = op(b, src[i + 2], last[i + 2]);                  \\\n            if (bpp == 3)                                                     \\\n                continue;                                                     \\\n            dst[i + 3] = a = op(a, src[i + 3], last[i + 3]);                  \\\n        }                                                                     \\\n    }\n\n#define UNROLL_FILTER(op)                                                     \\\n    if (bpp == 1) {                                                           \\\n        UNROLL1(1, op)                                                        \\\n    } else if (bpp == 2) {                                                    \\\n        UNROLL1(2, op)                                                        \\\n    } else if (bpp == 3) {                                                    \\\n        UNROLL1(3, op)                                                        \\\n    } else if (bpp == 4) {                                                    \\\n        UNROLL1(4, op)                                                        \\\n    }                                                                         \\\n    for (; i < size; i++) {                                                   \\\n        dst[i] = op(dst[i - bpp], src[i], last[i]);                           \\\n    }\n\n/* NOTE: 'dst' can be equal to 'last' */\nstatic void png_filter_row(PNGDSPContext *dsp, uint8_t *dst, int filter_type,\n                           uint8_t *src, uint8_t *last, int size, int bpp)\n{\n    int i, p, r, g, b, a;\n\n    switch (filter_type) {\n    case PNG_FILTER_VALUE_NONE:\n        memcpy(dst, src, size);\n        break;\n    case PNG_FILTER_VALUE_SUB:\n        for (i = 0; i < bpp; i++)\n            dst[i] = src[i];\n        if (bpp == 4) {\n            p = *(int *)dst;\n            for (; i < size; i += bpp) {\n                unsigned s = *(int *)(src + i);\n                p = ((s & 0x7f7f7f7f) + (p & 0x7f7f7f7f)) ^ ((s ^ p) & 0x80808080);\n                *(int *)(dst + i) = p;\n            }\n        } else {\n#define OP_SUB(x, s, l) ((x) + (s))\n            UNROLL_FILTER(OP_SUB);\n        }\n        break;\n    case PNG_FILTER_VALUE_UP:\n        dsp->add_bytes_l2(dst, src, last, size);\n        break;\n    case PNG_FILTER_VALUE_AVG:\n        for (i = 0; i < bpp; i++) {\n            p      = (last[i] >> 1);\n            dst[i] = p + src[i];\n        }\n#define OP_AVG(x, s, l) (((((x) + (l)) >> 1) + (s)) & 0xff)\n        UNROLL_FILTER(OP_AVG);\n        break;\n    case PNG_FILTER_VALUE_PAETH:\n        for (i = 0; i < bpp; i++) {\n            p      = last[i];\n            dst[i] = p + src[i];\n        }\n        if (bpp > 2 && size > 4) {\n            /* would write off the end of the array if we let it process\n             * the last pixel with bpp=3 */\n            int w = (bpp & 3) ? size - 3 : size;\n\n            if (w > i) {\n                dsp->add_paeth_prediction(dst + i, src + i, last + i, size - i, bpp);\n                i = w;\n            }\n        }\n        ff_add_png_paeth_prediction(dst + i, src + i, last + i, size - i, bpp);\n        break;\n    }\n}\n\n/* This used to be called \"deloco\" in FFmpeg\n * and is actually an inverse reversible colorspace transformation */\n#define YUV2RGB(NAME, TYPE) \\\nstatic void deloco_ ## NAME(TYPE *dst, int size, int alpha) \\\n{ \\\n    int i; \\\n    for (i = 0; i < size; i += 3 + alpha) { \\\n        int g = dst [i + 1]; \\\n        dst[i + 0] += g; \\\n        dst[i + 2] += g; \\\n    } \\\n}\n\nYUV2RGB(rgb8, uint8_t)\nYUV2RGB(rgb16, uint16_t)\n\n/* process exactly one decompressed row */\nstatic void png_handle_row(PNGDecContext *s)\n{\n    uint8_t *ptr, *last_row;\n    int got_line;\n\n    if (!s->interlace_type) {\n        ptr = s->image_buf + s->image_linesize * (s->y + s->y_offset) + s->x_offset * s->bpp;\n        if (s->y == 0)\n            last_row = s->last_row;\n        else\n            last_row = ptr - s->image_linesize;\n\n        png_filter_row(&s->dsp, ptr, s->crow_buf[0], s->crow_buf + 1,\n                       last_row, s->row_size, s->bpp);\n        /* loco lags by 1 row so that it doesn't interfere with top prediction */\n        if (s->filter_type == PNG_FILTER_TYPE_LOCO && s->y > 0) {\n            if (s->bit_depth == 16) {\n                deloco_rgb16((uint16_t *)(ptr - s->image_linesize), s->row_size / 2,\n                             s->color_type == PNG_COLOR_TYPE_RGB_ALPHA);\n            } else {\n                deloco_rgb8(ptr - s->image_linesize, s->row_size,\n                            s->color_type == PNG_COLOR_TYPE_RGB_ALPHA);\n            }\n        }\n        s->y++;\n        if (s->y == s->cur_h) {\n            s->state |= PNG_ALLIMAGE;\n            if (s->filter_type == PNG_FILTER_TYPE_LOCO) {\n                if (s->bit_depth == 16) {\n                    deloco_rgb16((uint16_t *)ptr, s->row_size / 2,\n                                 s->color_type == PNG_COLOR_TYPE_RGB_ALPHA);\n                } else {\n                    deloco_rgb8(ptr, s->row_size,\n                                s->color_type == PNG_COLOR_TYPE_RGB_ALPHA);\n                }\n            }\n        }\n    } else {\n        got_line = 0;\n        for (;;) {\n            ptr = s->image_buf + s->image_linesize * (s->y + s->y_offset) + s->x_offset * s->bpp;\n            if ((ff_png_pass_ymask[s->pass] << (s->y & 7)) & 0x80) {\n                /* if we already read one row, it is time to stop to\n                 * wait for the next one */\n                if (got_line)\n                    break;\n                png_filter_row(&s->dsp, s->tmp_row, s->crow_buf[0], s->crow_buf + 1,\n                               s->last_row, s->pass_row_size, s->bpp);\n                FFSWAP(uint8_t *, s->last_row, s->tmp_row);\n                FFSWAP(unsigned int, s->last_row_size, s->tmp_row_size);\n                got_line = 1;\n            }\n            if ((png_pass_dsp_ymask[s->pass] << (s->y & 7)) & 0x80) {\n                png_put_interlaced_row(ptr, s->cur_w, s->bits_per_pixel, s->pass,\n                                       s->color_type, s->last_row);\n            }\n            s->y++;\n            if (s->y == s->cur_h) {\n                memset(s->last_row, 0, s->row_size);\n                for (;;) {\n                    if (s->pass == NB_PASSES - 1) {\n                        s->state |= PNG_ALLIMAGE;\n                        goto the_end;\n                    } else {\n                        s->pass++;\n                        s->y = 0;\n                        s->pass_row_size = ff_png_pass_row_size(s->pass,\n                                                                s->bits_per_pixel,\n                                                                s->cur_w);\n                        s->crow_size = s->pass_row_size + 1;\n                        if (s->pass_row_size != 0)\n                            break;\n                        /* skip pass if empty row */\n                    }\n                }\n            }\n        }\nthe_end:;\n    }\n}\n\nstatic int png_decode_idat(PNGDecContext *s, int length)\n{\n    int ret;\n    s->zstream.avail_in = FFMIN(length, bytestream2_get_bytes_left(&s->gb));\n    s->zstream.next_in  = (unsigned char *)s->gb.buffer;\n    bytestream2_skip(&s->gb, length);\n\n    /* decode one line if possible */\n    while (s->zstream.avail_in > 0) {\n        ret = inflate(&s->zstream, Z_PARTIAL_FLUSH);\n        if (ret != Z_OK && ret != Z_STREAM_END) {\n            av_log(s->avctx, AV_LOG_ERROR, \"inflate returned error %d\\n\", ret);\n            return AVERROR_EXTERNAL;\n        }\n        if (s->zstream.avail_out == 0) {\n            if (!(s->state & PNG_ALLIMAGE)) {\n                png_handle_row(s);\n            }\n            s->zstream.avail_out = s->crow_size;\n            s->zstream.next_out  = s->crow_buf;\n        }\n        if (ret == Z_STREAM_END && s->zstream.avail_in > 0) {\n            av_log(NULL, AV_LOG_WARNING,\n                   \"%d undecompressed bytes left in buffer\\n\", s->zstream.avail_in);\n            return 0;\n        }\n    }\n    return 0;\n}\n\nstatic int decode_zbuf(AVBPrint *bp, const uint8_t *data,\n                       const uint8_t *data_end)\n{\n    z_stream zstream;\n    unsigned char *buf;\n    unsigned buf_size;\n    int ret;\n\n    zstream.zalloc = ff_png_zalloc;\n    zstream.zfree  = ff_png_zfree;\n    zstream.opaque = NULL;\n    if (inflateInit(&zstream) != Z_OK)\n        return AVERROR_EXTERNAL;\n    zstream.next_in  = (unsigned char *)data;\n    zstream.avail_in = data_end - data;\n    av_bprint_init(bp, 0, -1);\n\n    while (zstream.avail_in > 0) {\n        av_bprint_get_buffer(bp, 2, &buf, &buf_size);\n        if (buf_size < 2) {\n            ret = AVERROR(ENOMEM);\n            goto fail;\n        }\n        zstream.next_out  = buf;\n        zstream.avail_out = buf_size - 1;\n        ret = inflate(&zstream, Z_PARTIAL_FLUSH);\n        if (ret != Z_OK && ret != Z_STREAM_END) {\n            ret = AVERROR_EXTERNAL;\n            goto fail;\n        }\n        bp->len += zstream.next_out - buf;\n        if (ret == Z_STREAM_END)\n            break;\n    }\n    inflateEnd(&zstream);\n    bp->str[bp->len] = 0;\n    return 0;\n\nfail:\n    inflateEnd(&zstream);\n    av_bprint_finalize(bp, NULL);\n    return ret;\n}\n\nstatic uint8_t *iso88591_to_utf8(const uint8_t *in, size_t size_in)\n{\n    size_t extra = 0, i;\n    uint8_t *out, *q;\n\n    for (i = 0; i < size_in; i++)\n        extra += in[i] >= 0x80;\n    if (size_in == SIZE_MAX || extra > SIZE_MAX - size_in - 1)\n        return NULL;\n    q = out = av_malloc(size_in + extra + 1);\n    if (!out)\n        return NULL;\n    for (i = 0; i < size_in; i++) {\n        if (in[i] >= 0x80) {\n            *(q++) = 0xC0 | (in[i] >> 6);\n            *(q++) = 0x80 | (in[i] & 0x3F);\n        } else {\n            *(q++) = in[i];\n        }\n    }\n    *(q++) = 0;\n    return out;\n}\n\nstatic int decode_text_chunk(PNGDecContext *s, uint32_t length, int compressed,\n                             AVDictionary **dict)\n{\n    int ret, method;\n    const uint8_t *data        = s->gb.buffer;\n    const uint8_t *data_end    = data + length;\n    const uint8_t *keyword     = data;\n    const uint8_t *keyword_end = memchr(keyword, 0, data_end - keyword);\n    uint8_t *kw_utf8 = NULL, *text, *txt_utf8 = NULL;\n    unsigned text_len;\n    AVBPrint bp;\n\n    if (!keyword_end)\n        return AVERROR_INVALIDDATA;\n    data = keyword_end + 1;\n\n    if (compressed) {\n        if (data == data_end)\n            return AVERROR_INVALIDDATA;\n        method = *(data++);\n        if (method)\n            return AVERROR_INVALIDDATA;\n        if ((ret = decode_zbuf(&bp, data, data_end)) < 0)\n            return ret;\n        text_len = bp.len;\n        av_bprint_finalize(&bp, (char **)&text);\n        if (!text)\n            return AVERROR(ENOMEM);\n    } else {\n        text = (uint8_t *)data;\n        text_len = data_end - text;\n    }\n\n    kw_utf8  = iso88591_to_utf8(keyword, keyword_end - keyword);\n    txt_utf8 = iso88591_to_utf8(text, text_len);\n    if (text != data)\n        av_free(text);\n    if (!(kw_utf8 && txt_utf8)) {\n        av_free(kw_utf8);\n        av_free(txt_utf8);\n        return AVERROR(ENOMEM);\n    }\n\n    av_dict_set(dict, kw_utf8, txt_utf8,\n                AV_DICT_DONT_STRDUP_KEY | AV_DICT_DONT_STRDUP_VAL);\n    return 0;\n}\n\nstatic int decode_ihdr_chunk(AVCodecContext *avctx, PNGDecContext *s,\n                             uint32_t length)\n{\n    if (length != 13)\n        return AVERROR_INVALIDDATA;\n\n    if (s->state & PNG_IDAT) {\n        av_log(avctx, AV_LOG_ERROR, \"IHDR after IDAT\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (s->state & PNG_IHDR) {\n        av_log(avctx, AV_LOG_ERROR, \"Multiple IHDR\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    s->width  = s->cur_w = bytestream2_get_be32(&s->gb);\n    s->height = s->cur_h = bytestream2_get_be32(&s->gb);\n    if (av_image_check_size(s->width, s->height, 0, avctx)) {\n        s->cur_w = s->cur_h = s->width = s->height = 0;\n        av_log(avctx, AV_LOG_ERROR, \"Invalid image size\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    s->bit_depth        = bytestream2_get_byte(&s->gb);\n    s->color_type       = bytestream2_get_byte(&s->gb);\n    s->compression_type = bytestream2_get_byte(&s->gb);\n    s->filter_type      = bytestream2_get_byte(&s->gb);\n    s->interlace_type   = bytestream2_get_byte(&s->gb);\n    bytestream2_skip(&s->gb, 4); /* crc */\n    s->state |= PNG_IHDR;\n    if (avctx->debug & FF_DEBUG_PICT_INFO)\n        av_log(avctx, AV_LOG_DEBUG, \"width=%d height=%d depth=%d color_type=%d \"\n                \"compression_type=%d filter_type=%d interlace_type=%d\\n\",\n                s->width, s->height, s->bit_depth, s->color_type,\n                s->compression_type, s->filter_type, s->interlace_type);\n\n    return 0;\n}\n\nstatic int decode_phys_chunk(AVCodecContext *avctx, PNGDecContext *s)\n{\n    if (s->state & PNG_IDAT) {\n        av_log(avctx, AV_LOG_ERROR, \"pHYs after IDAT\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    avctx->sample_aspect_ratio.num = bytestream2_get_be32(&s->gb);\n    avctx->sample_aspect_ratio.den = bytestream2_get_be32(&s->gb);\n    if (avctx->sample_aspect_ratio.num < 0 || avctx->sample_aspect_ratio.den < 0)\n        avctx->sample_aspect_ratio = (AVRational){ 0, 1 };\n    bytestream2_skip(&s->gb, 1); /* unit specifier */\n    bytestream2_skip(&s->gb, 4); /* crc */\n\n    return 0;\n}\n\nstatic int decode_idat_chunk(AVCodecContext *avctx, PNGDecContext *s,\n                             uint32_t length, AVFrame *p)\n{\n    int ret;\n    size_t byte_depth = s->bit_depth > 8 ? 2 : 1;\n\n    if (!(s->state & PNG_IHDR)) {\n        av_log(avctx, AV_LOG_ERROR, \"IDAT without IHDR\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    if (!(s->state & PNG_IDAT)) {\n        /* init image info */\n        avctx->width  = s->width;\n        avctx->height = s->height;\n\n        s->channels       = ff_png_get_nb_channels(s->color_type);\n        s->bits_per_pixel = s->bit_depth * s->channels;\n        s->bpp            = (s->bits_per_pixel + 7) >> 3;\n        s->row_size       = (s->cur_w * s->bits_per_pixel + 7) >> 3;\n\n        if ((s->bit_depth == 2 || s->bit_depth == 4 || s->bit_depth == 8) &&\n                s->color_type == PNG_COLOR_TYPE_RGB) {\n            avctx->pix_fmt = AV_PIX_FMT_RGB24;\n        } else if ((s->bit_depth == 2 || s->bit_depth == 4 || s->bit_depth == 8) &&\n                s->color_type == PNG_COLOR_TYPE_RGB_ALPHA) {\n            avctx->pix_fmt = AV_PIX_FMT_RGBA;\n        } else if ((s->bit_depth == 2 || s->bit_depth == 4 || s->bit_depth == 8) &&\n                s->color_type == PNG_COLOR_TYPE_GRAY) {\n            avctx->pix_fmt = AV_PIX_FMT_GRAY8;\n        } else if (s->bit_depth == 16 &&\n                s->color_type == PNG_COLOR_TYPE_GRAY) {\n            avctx->pix_fmt = AV_PIX_FMT_GRAY16BE;\n        } else if (s->bit_depth == 16 &&\n                s->color_type == PNG_COLOR_TYPE_RGB) {\n            avctx->pix_fmt = AV_PIX_FMT_RGB48BE;\n        } else if (s->bit_depth == 16 &&\n                s->color_type == PNG_COLOR_TYPE_RGB_ALPHA) {\n            avctx->pix_fmt = AV_PIX_FMT_RGBA64BE;\n        } else if ((s->bits_per_pixel == 1 || s->bits_per_pixel == 2 || s->bits_per_pixel == 4 || s->bits_per_pixel == 8) &&\n                s->color_type == PNG_COLOR_TYPE_PALETTE) {\n            avctx->pix_fmt = AV_PIX_FMT_PAL8;\n        } else if (s->bit_depth == 1 && s->bits_per_pixel == 1 && avctx->codec_id != AV_CODEC_ID_APNG) {\n            avctx->pix_fmt = AV_PIX_FMT_MONOBLACK;\n        } else if (s->bit_depth == 8 &&\n                s->color_type == PNG_COLOR_TYPE_GRAY_ALPHA) {\n            avctx->pix_fmt = AV_PIX_FMT_YA8;\n        } else if (s->bit_depth == 16 &&\n                s->color_type == PNG_COLOR_TYPE_GRAY_ALPHA) {\n            avctx->pix_fmt = AV_PIX_FMT_YA16BE;\n        } else {\n            av_log(avctx, AV_LOG_ERROR, \"unsupported bit depth %d \"\n                    \"and color type %d\\n\",\n                    s->bit_depth, s->color_type);\n            return AVERROR_INVALIDDATA;\n        }\n\n        if (s->has_trns && s->color_type != PNG_COLOR_TYPE_PALETTE) {\n            switch (avctx->pix_fmt) {\n            case AV_PIX_FMT_RGB24:\n                avctx->pix_fmt = AV_PIX_FMT_RGBA;\n                break;\n\n            case AV_PIX_FMT_RGB48BE:\n                avctx->pix_fmt = AV_PIX_FMT_RGBA64BE;\n                break;\n\n            case AV_PIX_FMT_GRAY8:\n                avctx->pix_fmt = AV_PIX_FMT_YA8;\n                break;\n\n            case AV_PIX_FMT_GRAY16BE:\n                avctx->pix_fmt = AV_PIX_FMT_YA16BE;\n                break;\n\n            default:\n                avpriv_request_sample(avctx, \"bit depth %d \"\n                        \"and color type %d with TRNS\",\n                        s->bit_depth, s->color_type);\n                return AVERROR_INVALIDDATA;\n            }\n\n            s->bpp += byte_depth;\n        }\n\n        if ((ret = ff_thread_get_buffer(avctx, &s->picture, AV_GET_BUFFER_FLAG_REF)) < 0)\n            return ret;\n        if (avctx->codec_id == AV_CODEC_ID_APNG && s->last_dispose_op != APNG_DISPOSE_OP_PREVIOUS) {\n            ff_thread_release_buffer(avctx, &s->previous_picture);\n            if ((ret = ff_thread_get_buffer(avctx, &s->previous_picture, AV_GET_BUFFER_FLAG_REF)) < 0)\n                return ret;\n        }\n        ff_thread_finish_setup(avctx);\n\n        p->pict_type        = AV_PICTURE_TYPE_I;\n        p->key_frame        = 1;\n        p->interlaced_frame = !!s->interlace_type;\n\n        /* compute the compressed row size */\n        if (!s->interlace_type) {\n            s->crow_size = s->row_size + 1;\n        } else {\n            s->pass          = 0;\n            s->pass_row_size = ff_png_pass_row_size(s->pass,\n                    s->bits_per_pixel,\n                    s->cur_w);\n            s->crow_size = s->pass_row_size + 1;\n        }\n        ff_dlog(avctx, \"row_size=%d crow_size =%d\\n\",\n                s->row_size, s->crow_size);\n        s->image_buf      = p->data[0];\n        s->image_linesize = p->linesize[0];\n        /* copy the palette if needed */\n        if (avctx->pix_fmt == AV_PIX_FMT_PAL8)\n            memcpy(p->data[1], s->palette, 256 * sizeof(uint32_t));\n        /* empty row is used if differencing to the first row */\n        av_fast_padded_mallocz(&s->last_row, &s->last_row_size, s->row_size);\n        if (!s->last_row)\n            return AVERROR_INVALIDDATA;\n        if (s->interlace_type ||\n                s->color_type == PNG_COLOR_TYPE_RGB_ALPHA) {\n            av_fast_padded_malloc(&s->tmp_row, &s->tmp_row_size, s->row_size);\n            if (!s->tmp_row)\n                return AVERROR_INVALIDDATA;\n        }\n        /* compressed row */\n        av_fast_padded_malloc(&s->buffer, &s->buffer_size, s->row_size + 16);\n        if (!s->buffer)\n            return AVERROR(ENOMEM);\n\n        /* we want crow_buf+1 to be 16-byte aligned */\n        s->crow_buf          = s->buffer + 15;\n        s->zstream.avail_out = s->crow_size;\n        s->zstream.next_out  = s->crow_buf;\n    }\n\n    s->state |= PNG_IDAT;\n\n    /* set image to non-transparent bpp while decompressing */\n    if (s->has_trns && s->color_type != PNG_COLOR_TYPE_PALETTE)\n        s->bpp -= byte_depth;\n\n    ret = png_decode_idat(s, length);\n\n    if (s->has_trns && s->color_type != PNG_COLOR_TYPE_PALETTE)\n        s->bpp += byte_depth;\n\n    if (ret < 0)\n        return ret;\n\n    bytestream2_skip(&s->gb, 4); /* crc */\n\n    return 0;\n}\n\nstatic int decode_plte_chunk(AVCodecContext *avctx, PNGDecContext *s,\n                             uint32_t length)\n{\n    int n, i, r, g, b;\n\n    if ((length % 3) != 0 || length > 256 * 3)\n        return AVERROR_INVALIDDATA;\n    /* read the palette */\n    n = length / 3;\n    for (i = 0; i < n; i++) {\n        r = bytestream2_get_byte(&s->gb);\n        g = bytestream2_get_byte(&s->gb);\n        b = bytestream2_get_byte(&s->gb);\n        s->palette[i] = (0xFFU << 24) | (r << 16) | (g << 8) | b;\n    }\n    for (; i < 256; i++)\n        s->palette[i] = (0xFFU << 24);\n    s->state |= PNG_PLTE;\n    bytestream2_skip(&s->gb, 4);     /* crc */\n\n    return 0;\n}\n\nstatic int decode_trns_chunk(AVCodecContext *avctx, PNGDecContext *s,\n                             uint32_t length)\n{\n    int v, i;\n\n    if (s->color_type == PNG_COLOR_TYPE_PALETTE) {\n        if (length > 256 || !(s->state & PNG_PLTE))\n            return AVERROR_INVALIDDATA;\n\n        for (i = 0; i < length; i++) {\n            v = bytestream2_get_byte(&s->gb);\n            s->palette[i] = (s->palette[i] & 0x00ffffff) | (v << 24);\n        }\n    } else if (s->color_type == PNG_COLOR_TYPE_GRAY || s->color_type == PNG_COLOR_TYPE_RGB) {\n        if ((s->color_type == PNG_COLOR_TYPE_GRAY && length != 2) ||\n            (s->color_type == PNG_COLOR_TYPE_RGB && length != 6))\n            return AVERROR_INVALIDDATA;\n\n        for (i = 0; i < length / 2; i++) {\n            /* only use the least significant bits */\n            v = av_mod_uintp2(bytestream2_get_be16(&s->gb), s->bit_depth);\n\n            if (s->bit_depth > 8)\n                AV_WB16(&s->transparent_color_be[2 * i], v);\n            else\n                s->transparent_color_be[i] = v;\n        }\n    } else {\n        return AVERROR_INVALIDDATA;\n    }\n\n    bytestream2_skip(&s->gb, 4); /* crc */\n    s->has_trns = 1;\n\n    return 0;\n}\n\nstatic void handle_small_bpp(PNGDecContext *s, AVFrame *p)\n{\n    if (s->bits_per_pixel == 1 && s->color_type == PNG_COLOR_TYPE_PALETTE) {\n        int i, j, k;\n        uint8_t *pd = p->data[0];\n        for (j = 0; j < s->height; j++) {\n            i = s->width / 8;\n            for (k = 7; k >= 1; k--)\n                if ((s->width&7) >= k)\n                    pd[8*i + k - 1] = (pd[i]>>8-k) & 1;\n            for (i--; i >= 0; i--) {\n                pd[8*i + 7]=  pd[i]     & 1;\n                pd[8*i + 6]= (pd[i]>>1) & 1;\n                pd[8*i + 5]= (pd[i]>>2) & 1;\n                pd[8*i + 4]= (pd[i]>>3) & 1;\n                pd[8*i + 3]= (pd[i]>>4) & 1;\n                pd[8*i + 2]= (pd[i]>>5) & 1;\n                pd[8*i + 1]= (pd[i]>>6) & 1;\n                pd[8*i + 0]=  pd[i]>>7;\n            }\n            pd += s->image_linesize;\n        }\n    } else if (s->bits_per_pixel == 2) {\n        int i, j;\n        uint8_t *pd = p->data[0];\n        for (j = 0; j < s->height; j++) {\n            i = s->width / 4;\n            if (s->color_type == PNG_COLOR_TYPE_PALETTE) {\n                if ((s->width&3) >= 3) pd[4*i + 2]= (pd[i] >> 2) & 3;\n                if ((s->width&3) >= 2) pd[4*i + 1]= (pd[i] >> 4) & 3;\n                if ((s->width&3) >= 1) pd[4*i + 0]=  pd[i] >> 6;\n                for (i--; i >= 0; i--) {\n                    pd[4*i + 3]=  pd[i]     & 3;\n                    pd[4*i + 2]= (pd[i]>>2) & 3;\n                    pd[4*i + 1]= (pd[i]>>4) & 3;\n                    pd[4*i + 0]=  pd[i]>>6;\n                }\n            } else {\n                if ((s->width&3) >= 3) pd[4*i + 2]= ((pd[i]>>2) & 3)*0x55;\n                if ((s->width&3) >= 2) pd[4*i + 1]= ((pd[i]>>4) & 3)*0x55;\n                if ((s->width&3) >= 1) pd[4*i + 0]= ( pd[i]>>6     )*0x55;\n                for (i--; i >= 0; i--) {\n                    pd[4*i + 3]= ( pd[i]     & 3)*0x55;\n                    pd[4*i + 2]= ((pd[i]>>2) & 3)*0x55;\n                    pd[4*i + 1]= ((pd[i]>>4) & 3)*0x55;\n                    pd[4*i + 0]= ( pd[i]>>6     )*0x55;\n                }\n            }\n            pd += s->image_linesize;\n        }\n    } else if (s->bits_per_pixel == 4) {\n        int i, j;\n        uint8_t *pd = p->data[0];\n        for (j = 0; j < s->height; j++) {\n            i = s->width/2;\n            if (s->color_type == PNG_COLOR_TYPE_PALETTE) {\n                if (s->width&1) pd[2*i+0]= pd[i]>>4;\n                for (i--; i >= 0; i--) {\n                    pd[2*i + 1] = pd[i] & 15;\n                    pd[2*i + 0] = pd[i] >> 4;\n                }\n            } else {\n                if (s->width & 1) pd[2*i + 0]= (pd[i] >> 4) * 0x11;\n                for (i--; i >= 0; i--) {\n                    pd[2*i + 1] = (pd[i] & 15) * 0x11;\n                    pd[2*i + 0] = (pd[i] >> 4) * 0x11;\n                }\n            }\n            pd += s->image_linesize;\n        }\n    }\n}\n\nstatic int decode_fctl_chunk(AVCodecContext *avctx, PNGDecContext *s,\n                             uint32_t length)\n{\n    uint32_t sequence_number;\n    int cur_w, cur_h, x_offset, y_offset, dispose_op, blend_op;\n\n    if (length != 26)\n        return AVERROR_INVALIDDATA;\n\n    if (!(s->state & PNG_IHDR)) {\n        av_log(avctx, AV_LOG_ERROR, \"fctl before IHDR\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    s->last_w = s->cur_w;\n    s->last_h = s->cur_h;\n    s->last_x_offset = s->x_offset;\n    s->last_y_offset = s->y_offset;\n    s->last_dispose_op = s->dispose_op;\n\n    sequence_number = bytestream2_get_be32(&s->gb);\n    cur_w           = bytestream2_get_be32(&s->gb);\n    cur_h           = bytestream2_get_be32(&s->gb);\n    x_offset        = bytestream2_get_be32(&s->gb);\n    y_offset        = bytestream2_get_be32(&s->gb);\n    bytestream2_skip(&s->gb, 4); /* delay_num (2), delay_den (2) */\n    dispose_op      = bytestream2_get_byte(&s->gb);\n    blend_op        = bytestream2_get_byte(&s->gb);\n    bytestream2_skip(&s->gb, 4); /* crc */\n\n    if (sequence_number == 0 &&\n        (cur_w != s->width ||\n         cur_h != s->height ||\n         x_offset != 0 ||\n         y_offset != 0) ||\n        cur_w <= 0 || cur_h <= 0 ||\n        x_offset < 0 || y_offset < 0 ||\n        cur_w > s->width - x_offset|| cur_h > s->height - y_offset)\n            return AVERROR_INVALIDDATA;\n\n    if (blend_op != APNG_BLEND_OP_OVER && blend_op != APNG_BLEND_OP_SOURCE) {\n        av_log(avctx, AV_LOG_ERROR, \"Invalid blend_op %d\\n\", blend_op);\n        return AVERROR_INVALIDDATA;\n    }\n\n    if ((sequence_number == 0 || !s->previous_picture.f->data[0]) &&\n        dispose_op == APNG_DISPOSE_OP_PREVIOUS) {\n        // No previous frame to revert to for the first frame\n        // Spec says to just treat it as a APNG_DISPOSE_OP_BACKGROUND\n        dispose_op = APNG_DISPOSE_OP_BACKGROUND;\n    }\n\n    if (blend_op == APNG_BLEND_OP_OVER && !s->has_trns && (\n            avctx->pix_fmt == AV_PIX_FMT_RGB24 ||\n            avctx->pix_fmt == AV_PIX_FMT_RGB48BE ||\n            avctx->pix_fmt == AV_PIX_FMT_PAL8 ||\n            avctx->pix_fmt == AV_PIX_FMT_GRAY8 ||\n            avctx->pix_fmt == AV_PIX_FMT_GRAY16BE ||\n            avctx->pix_fmt == AV_PIX_FMT_MONOBLACK\n        )) {\n        // APNG_BLEND_OP_OVER is the same as APNG_BLEND_OP_SOURCE when there is no alpha channel\n        blend_op = APNG_BLEND_OP_SOURCE;\n    }\n\n    s->cur_w      = cur_w;\n    s->cur_h      = cur_h;\n    s->x_offset   = x_offset;\n    s->y_offset   = y_offset;\n    s->dispose_op = dispose_op;\n    s->blend_op   = blend_op;\n\n    return 0;\n}\n\nstatic void handle_p_frame_png(PNGDecContext *s, AVFrame *p)\n{\n    int i, j;\n    uint8_t *pd      = p->data[0];\n    uint8_t *pd_last = s->last_picture.f->data[0];\n    int ls = FFMIN(av_image_get_linesize(p->format, s->width, 0), s->width * s->bpp);\n\n    ff_thread_await_progress(&s->last_picture, INT_MAX, 0);\n    for (j = 0; j < s->height; j++) {\n        for (i = 0; i < ls; i++)\n            pd[i] += pd_last[i];\n        pd      += s->image_linesize;\n        pd_last += s->image_linesize;\n    }\n}\n\n// divide by 255 and round to nearest\n// apply a fast variant: (X+127)/255 = ((X+127)*257+257)>>16 = ((X+128)*257)>>16\n#define FAST_DIV255(x) ((((x) + 128) * 257) >> 16)\n\nstatic int handle_p_frame_apng(AVCodecContext *avctx, PNGDecContext *s,\n                               AVFrame *p)\n{\n    size_t x, y;\n    uint8_t *buffer;\n\n    if (s->blend_op == APNG_BLEND_OP_OVER &&\n        avctx->pix_fmt != AV_PIX_FMT_RGBA &&\n        avctx->pix_fmt != AV_PIX_FMT_GRAY8A &&\n        avctx->pix_fmt != AV_PIX_FMT_PAL8) {\n        avpriv_request_sample(avctx, \"Blending with pixel format %s\",\n                              av_get_pix_fmt_name(avctx->pix_fmt));\n        return AVERROR_PATCHWELCOME;\n    }\n\n    buffer = av_malloc_array(s->image_linesize, s->height);\n    if (!buffer)\n        return AVERROR(ENOMEM);\n\n\n    // Do the disposal operation specified by the last frame on the frame\n    if (s->last_dispose_op != APNG_DISPOSE_OP_PREVIOUS) {\n        ff_thread_await_progress(&s->last_picture, INT_MAX, 0);\n        memcpy(buffer, s->last_picture.f->data[0], s->image_linesize * s->height);\n\n        if (s->last_dispose_op == APNG_DISPOSE_OP_BACKGROUND)\n            for (y = s->last_y_offset; y < s->last_y_offset + s->last_h; ++y)\n                memset(buffer + s->image_linesize * y + s->bpp * s->last_x_offset, 0, s->bpp * s->last_w);\n\n        memcpy(s->previous_picture.f->data[0], buffer, s->image_linesize * s->height);\n        ff_thread_report_progress(&s->previous_picture, INT_MAX, 0);\n    } else {\n        ff_thread_await_progress(&s->previous_picture, INT_MAX, 0);\n        memcpy(buffer, s->previous_picture.f->data[0], s->image_linesize * s->height);\n    }\n\n    // Perform blending\n    if (s->blend_op == APNG_BLEND_OP_SOURCE) {\n        for (y = s->y_offset; y < s->y_offset + s->cur_h; ++y) {\n            size_t row_start = s->image_linesize * y + s->bpp * s->x_offset;\n            memcpy(buffer + row_start, p->data[0] + row_start, s->bpp * s->cur_w);\n        }\n    } else { // APNG_BLEND_OP_OVER\n        for (y = s->y_offset; y < s->y_offset + s->cur_h; ++y) {\n            uint8_t *foreground = p->data[0] + s->image_linesize * y + s->bpp * s->x_offset;\n            uint8_t *background = buffer + s->image_linesize * y + s->bpp * s->x_offset;\n            for (x = s->x_offset; x < s->x_offset + s->cur_w; ++x, foreground += s->bpp, background += s->bpp) {\n                size_t b;\n                uint8_t foreground_alpha, background_alpha, output_alpha;\n                uint8_t output[10];\n\n                // Since we might be blending alpha onto alpha, we use the following equations:\n                // output_alpha = foreground_alpha + (1 - foreground_alpha) * background_alpha\n                // output = (foreground_alpha * foreground + (1 - foreground_alpha) * background_alpha * background) / output_alpha\n\n                switch (avctx->pix_fmt) {\n                case AV_PIX_FMT_RGBA:\n                    foreground_alpha = foreground[3];\n                    background_alpha = background[3];\n                    break;\n\n                case AV_PIX_FMT_GRAY8A:\n                    foreground_alpha = foreground[1];\n                    background_alpha = background[1];\n                    break;\n\n                case AV_PIX_FMT_PAL8:\n                    foreground_alpha = s->palette[foreground[0]] >> 24;\n                    background_alpha = s->palette[background[0]] >> 24;\n                    break;\n                }\n\n                if (foreground_alpha == 0)\n                    continue;\n\n                if (foreground_alpha == 255) {\n                    memcpy(background, foreground, s->bpp);\n                    continue;\n                }\n\n                if (avctx->pix_fmt == AV_PIX_FMT_PAL8) {\n                    // TODO: Alpha blending with PAL8 will likely need the entire image converted over to RGBA first\n                    avpriv_request_sample(avctx, \"Alpha blending palette samples\");\n                    background[0] = foreground[0];\n                    continue;\n                }\n\n                output_alpha = foreground_alpha + FAST_DIV255((255 - foreground_alpha) * background_alpha);\n\n                av_assert0(s->bpp <= 10);\n\n                for (b = 0; b < s->bpp - 1; ++b) {\n                    if (output_alpha == 0) {\n                        output[b] = 0;\n                    } else if (background_alpha == 255) {\n                        output[b] = FAST_DIV255(foreground_alpha * foreground[b] + (255 - foreground_alpha) * background[b]);\n                    } else {\n                        output[b] = (255 * foreground_alpha * foreground[b] + (255 - foreground_alpha) * background_alpha * background[b]) / (255 * output_alpha);\n                    }\n                }\n                output[b] = output_alpha;\n                memcpy(background, output, s->bpp);\n            }\n        }\n    }\n\n    // Copy blended buffer into the frame and free\n    memcpy(p->data[0], buffer, s->image_linesize * s->height);\n    av_free(buffer);\n\n    return 0;\n}\n\nstatic int decode_frame_common(AVCodecContext *avctx, PNGDecContext *s,\n                               AVFrame *p, AVPacket *avpkt)\n{\n    AVDictionary *metadata  = NULL;\n    uint32_t tag, length;\n    int decode_next_dat = 0;\n    int ret;\n\n    for (;;) {\n        length = bytestream2_get_bytes_left(&s->gb);\n        if (length <= 0) {\n\n            if (avctx->codec_id == AV_CODEC_ID_PNG &&\n                avctx->skip_frame == AVDISCARD_ALL) {\n                av_frame_set_metadata(p, metadata);\n                return 0;\n            }\n\n            if (CONFIG_APNG_DECODER && avctx->codec_id == AV_CODEC_ID_APNG && length == 0) {\n                if (!(s->state & PNG_IDAT))\n                    return 0;\n                else\n                    goto exit_loop;\n            }\n            av_log(avctx, AV_LOG_ERROR, \"%d bytes left\\n\", length);\n            if (   s->state & PNG_ALLIMAGE\n                && avctx->strict_std_compliance <= FF_COMPLIANCE_NORMAL)\n                goto exit_loop;\n            ret = AVERROR_INVALIDDATA;\n            goto fail;\n        }\n\n        length = bytestream2_get_be32(&s->gb);\n        if (length > 0x7fffffff || length > bytestream2_get_bytes_left(&s->gb)) {\n            av_log(avctx, AV_LOG_ERROR, \"chunk too big\\n\");\n            ret = AVERROR_INVALIDDATA;\n            goto fail;\n        }\n        tag = bytestream2_get_le32(&s->gb);\n        if (avctx->debug & FF_DEBUG_STARTCODE)\n            av_log(avctx, AV_LOG_DEBUG, \"png: tag=%c%c%c%c length=%u\\n\",\n                (tag & 0xff),\n                ((tag >> 8) & 0xff),\n                ((tag >> 16) & 0xff),\n                ((tag >> 24) & 0xff), length);\n\n        if (avctx->codec_id == AV_CODEC_ID_PNG &&\n            avctx->skip_frame == AVDISCARD_ALL) {\n            switch(tag) {\n            case MKTAG('I', 'H', 'D', 'R'):\n            case MKTAG('p', 'H', 'Y', 's'):\n            case MKTAG('t', 'E', 'X', 't'):\n            case MKTAG('I', 'D', 'A', 'T'):\n            case MKTAG('t', 'R', 'N', 'S'):\n                break;\n            default:\n                goto skip_tag;\n            }\n        }\n\n        switch (tag) {\n        case MKTAG('I', 'H', 'D', 'R'):\n            if ((ret = decode_ihdr_chunk(avctx, s, length)) < 0)\n                goto fail;\n            break;\n        case MKTAG('p', 'H', 'Y', 's'):\n            if ((ret = decode_phys_chunk(avctx, s)) < 0)\n                goto fail;\n            break;\n        case MKTAG('f', 'c', 'T', 'L'):\n            if (!CONFIG_APNG_DECODER || avctx->codec_id != AV_CODEC_ID_APNG)\n                goto skip_tag;\n            if ((ret = decode_fctl_chunk(avctx, s, length)) < 0)\n                goto fail;\n            decode_next_dat = 1;\n            break;\n        case MKTAG('f', 'd', 'A', 'T'):\n            if (!CONFIG_APNG_DECODER || avctx->codec_id != AV_CODEC_ID_APNG)\n                goto skip_tag;\n            if (!decode_next_dat) {\n                ret = AVERROR_INVALIDDATA;\n                goto fail;\n            }\n            bytestream2_get_be32(&s->gb);\n            length -= 4;\n            /* fallthrough */\n        case MKTAG('I', 'D', 'A', 'T'):\n            if (CONFIG_APNG_DECODER && avctx->codec_id == AV_CODEC_ID_APNG && !decode_next_dat)\n                goto skip_tag;\n            if ((ret = decode_idat_chunk(avctx, s, length, p)) < 0)\n                goto fail;\n            break;\n        case MKTAG('P', 'L', 'T', 'E'):\n            if (decode_plte_chunk(avctx, s, length) < 0)\n                goto skip_tag;\n            break;\n        case MKTAG('t', 'R', 'N', 'S'):\n            if (decode_trns_chunk(avctx, s, length) < 0)\n                goto skip_tag;\n            break;\n        case MKTAG('t', 'E', 'X', 't'):\n            if (decode_text_chunk(s, length, 0, &metadata) < 0)\n                av_log(avctx, AV_LOG_WARNING, \"Broken tEXt chunk\\n\");\n            bytestream2_skip(&s->gb, length + 4);\n            break;\n        case MKTAG('z', 'T', 'X', 't'):\n            if (decode_text_chunk(s, length, 1, &metadata) < 0)\n                av_log(avctx, AV_LOG_WARNING, \"Broken zTXt chunk\\n\");\n            bytestream2_skip(&s->gb, length + 4);\n            break;\n        case MKTAG('s', 'T', 'E', 'R'): {\n            int mode = bytestream2_get_byte(&s->gb);\n            AVStereo3D *stereo3d = av_stereo3d_create_side_data(p);\n            if (!stereo3d)\n                goto fail;\n\n            if (mode == 0 || mode == 1) {\n                stereo3d->type  = AV_STEREO3D_SIDEBYSIDE;\n                stereo3d->flags = mode ? 0 : AV_STEREO3D_FLAG_INVERT;\n            } else {\n                 av_log(avctx, AV_LOG_WARNING,\n                        \"Unknown value in sTER chunk (%d)\\n\", mode);\n            }\n            bytestream2_skip(&s->gb, 4); /* crc */\n            break;\n        }\n        case MKTAG('I', 'E', 'N', 'D'):\n            if (!(s->state & PNG_ALLIMAGE))\n                av_log(avctx, AV_LOG_ERROR, \"IEND without all image\\n\");\n            if (!(s->state & (PNG_ALLIMAGE|PNG_IDAT))) {\n                ret = AVERROR_INVALIDDATA;\n                goto fail;\n            }\n            bytestream2_skip(&s->gb, 4); /* crc */\n            goto exit_loop;\n        default:\n            /* skip tag */\nskip_tag:\n            bytestream2_skip(&s->gb, length + 4);\n            break;\n        }\n    }\nexit_loop:\n    if (avctx->codec_id == AV_CODEC_ID_PNG &&\n        avctx->skip_frame == AVDISCARD_ALL) {\n        av_frame_set_metadata(p, metadata);\n        return 0;\n    }\n\n    if (s->bits_per_pixel <= 4)\n        handle_small_bpp(s, p);\n\n    /* apply transparency if needed */\n    if (s->has_trns && s->color_type != PNG_COLOR_TYPE_PALETTE) {\n        size_t byte_depth = s->bit_depth > 8 ? 2 : 1;\n        size_t raw_bpp = s->bpp - byte_depth;\n        unsigned x, y;\n\n        for (y = 0; y < s->height; ++y) {\n            uint8_t *row = &s->image_buf[s->image_linesize * y];\n\n            /* since we're updating in-place, we have to go from right to left */\n            for (x = s->width; x > 0; --x) {\n                uint8_t *pixel = &row[s->bpp * (x - 1)];\n                memmove(pixel, &row[raw_bpp * (x - 1)], raw_bpp);\n\n                if (!memcmp(pixel, s->transparent_color_be, raw_bpp)) {\n                    memset(&pixel[raw_bpp], 0, byte_depth);\n                } else {\n                    memset(&pixel[raw_bpp], 0xff, byte_depth);\n                }\n            }\n        }\n    }\n\n    /* handle P-frames only if a predecessor frame is available */\n    if (s->last_picture.f->data[0]) {\n        if (   !(avpkt->flags & AV_PKT_FLAG_KEY) && avctx->codec_tag != AV_RL32(\"MPNG\")\n            && s->last_picture.f->width == p->width\n            && s->last_picture.f->height== p->height\n            && s->last_picture.f->format== p->format\n         ) {\n            if (CONFIG_PNG_DECODER && avctx->codec_id != AV_CODEC_ID_APNG)\n                handle_p_frame_png(s, p);\n            else if (CONFIG_APNG_DECODER &&\n                     avctx->codec_id == AV_CODEC_ID_APNG &&\n                     (ret = handle_p_frame_apng(avctx, s, p)) < 0)\n                goto fail;\n        }\n    }\n    ff_thread_report_progress(&s->picture, INT_MAX, 0);\n    ff_thread_report_progress(&s->previous_picture, INT_MAX, 0);\n\n    av_frame_set_metadata(p, metadata);\n    metadata   = NULL;\n    return 0;\n\nfail:\n    av_dict_free(&metadata);\n    ff_thread_report_progress(&s->picture, INT_MAX, 0);\n    ff_thread_report_progress(&s->previous_picture, INT_MAX, 0);\n    return ret;\n}\n\n#if CONFIG_PNG_DECODER\nstatic int decode_frame_png(AVCodecContext *avctx,\n                        void *data, int *got_frame,\n                        AVPacket *avpkt)\n{\n    PNGDecContext *const s = avctx->priv_data;\n    const uint8_t *buf     = avpkt->data;\n    int buf_size           = avpkt->size;\n    AVFrame *p;\n    int64_t sig;\n    int ret;\n\n    ff_thread_release_buffer(avctx, &s->last_picture);\n    FFSWAP(ThreadFrame, s->picture, s->last_picture);\n    p = s->picture.f;\n\n    bytestream2_init(&s->gb, buf, buf_size);\n\n    /* check signature */\n    sig = bytestream2_get_be64(&s->gb);\n    if (sig != PNGSIG &&\n        sig != MNGSIG) {\n        av_log(avctx, AV_LOG_ERROR, \"Invalid PNG signature 0x%08\"PRIX64\".\\n\", sig);\n        return AVERROR_INVALIDDATA;\n    }\n\n    s->y = s->state = s->has_trns = 0;\n\n    /* init the zlib */\n    s->zstream.zalloc = ff_png_zalloc;\n    s->zstream.zfree  = ff_png_zfree;\n    s->zstream.opaque = NULL;\n    ret = inflateInit(&s->zstream);\n    if (ret != Z_OK) {\n        av_log(avctx, AV_LOG_ERROR, \"inflateInit returned error %d\\n\", ret);\n        return AVERROR_EXTERNAL;\n    }\n\n    if ((ret = decode_frame_common(avctx, s, p, avpkt)) < 0)\n        goto the_end;\n\n    if (avctx->skip_frame == AVDISCARD_ALL) {\n        *got_frame = 0;\n        ret = bytestream2_tell(&s->gb);\n        goto the_end;\n    }\n\n    if ((ret = av_frame_ref(data, s->picture.f)) < 0)\n        return ret;\n\n    *got_frame = 1;\n\n    ret = bytestream2_tell(&s->gb);\nthe_end:\n    inflateEnd(&s->zstream);\n    s->crow_buf = NULL;\n    return ret;\n}\n#endif\n\n#if CONFIG_APNG_DECODER\nstatic int decode_frame_apng(AVCodecContext *avctx,\n                        void *data, int *got_frame,\n                        AVPacket *avpkt)\n{\n    PNGDecContext *const s = avctx->priv_data;\n    int ret;\n    AVFrame *p;\n\n    ff_thread_release_buffer(avctx, &s->last_picture);\n    FFSWAP(ThreadFrame, s->picture, s->last_picture);\n    p = s->picture.f;\n\n    if (!(s->state & PNG_IHDR)) {\n        if (!avctx->extradata_size)\n            return AVERROR_INVALIDDATA;\n\n        /* only init fields, there is no zlib use in extradata */\n        s->zstream.zalloc = ff_png_zalloc;\n        s->zstream.zfree  = ff_png_zfree;\n\n        bytestream2_init(&s->gb, avctx->extradata, avctx->extradata_size);\n        if ((ret = decode_frame_common(avctx, s, p, avpkt)) < 0)\n            goto end;\n    }\n\n    /* reset state for a new frame */\n    if ((ret = inflateInit(&s->zstream)) != Z_OK) {\n        av_log(avctx, AV_LOG_ERROR, \"inflateInit returned error %d\\n\", ret);\n        ret = AVERROR_EXTERNAL;\n        goto end;\n    }\n    s->y = 0;\n    s->state &= ~(PNG_IDAT | PNG_ALLIMAGE);\n    bytestream2_init(&s->gb, avpkt->data, avpkt->size);\n    if ((ret = decode_frame_common(avctx, s, p, avpkt)) < 0)\n        goto end;\n\n    if (!(s->state & PNG_ALLIMAGE))\n        av_log(avctx, AV_LOG_WARNING, \"Frame did not contain a complete image\\n\");\n    if (!(s->state & (PNG_ALLIMAGE|PNG_IDAT))) {\n        ret = AVERROR_INVALIDDATA;\n        goto end;\n    }\n    if ((ret = av_frame_ref(data, s->picture.f)) < 0)\n        goto end;\n\n    *got_frame = 1;\n    ret = bytestream2_tell(&s->gb);\n\nend:\n    inflateEnd(&s->zstream);\n    return ret;\n}\n#endif\n\n#if HAVE_THREADS\nstatic int update_thread_context(AVCodecContext *dst, const AVCodecContext *src)\n{\n    PNGDecContext *psrc = src->priv_data;\n    PNGDecContext *pdst = dst->priv_data;\n    int ret;\n\n    if (dst == src)\n        return 0;\n\n    ff_thread_release_buffer(dst, &pdst->picture);\n    if (psrc->picture.f->data[0] &&\n        (ret = ff_thread_ref_frame(&pdst->picture, &psrc->picture)) < 0)\n        return ret;\n    if (CONFIG_APNG_DECODER && dst->codec_id == AV_CODEC_ID_APNG) {\n        pdst->width             = psrc->width;\n        pdst->height            = psrc->height;\n        pdst->bit_depth         = psrc->bit_depth;\n        pdst->color_type        = psrc->color_type;\n        pdst->compression_type  = psrc->compression_type;\n        pdst->interlace_type    = psrc->interlace_type;\n        pdst->filter_type       = psrc->filter_type;\n        pdst->cur_w = psrc->cur_w;\n        pdst->cur_h = psrc->cur_h;\n        pdst->x_offset = psrc->x_offset;\n        pdst->y_offset = psrc->y_offset;\n        pdst->has_trns = psrc->has_trns;\n        memcpy(pdst->transparent_color_be, psrc->transparent_color_be, sizeof(pdst->transparent_color_be));\n\n        pdst->dispose_op = psrc->dispose_op;\n\n        memcpy(pdst->palette, psrc->palette, sizeof(pdst->palette));\n\n        pdst->state |= psrc->state & (PNG_IHDR | PNG_PLTE);\n\n        ff_thread_release_buffer(dst, &pdst->last_picture);\n        if (psrc->last_picture.f->data[0] &&\n            (ret = ff_thread_ref_frame(&pdst->last_picture, &psrc->last_picture)) < 0)\n            return ret;\n\n        ff_thread_release_buffer(dst, &pdst->previous_picture);\n        if (psrc->previous_picture.f->data[0] &&\n            (ret = ff_thread_ref_frame(&pdst->previous_picture, &psrc->previous_picture)) < 0)\n            return ret;\n    }\n\n    return 0;\n}\n#endif\n\nstatic av_cold int png_dec_init(AVCodecContext *avctx)\n{\n    PNGDecContext *s = avctx->priv_data;\n\n    avctx->color_range = AVCOL_RANGE_JPEG;\n\n    s->avctx = avctx;\n    s->previous_picture.f = av_frame_alloc();\n    s->last_picture.f = av_frame_alloc();\n    s->picture.f = av_frame_alloc();\n    if (!s->previous_picture.f || !s->last_picture.f || !s->picture.f) {\n        av_frame_free(&s->previous_picture.f);\n        av_frame_free(&s->last_picture.f);\n        av_frame_free(&s->picture.f);\n        return AVERROR(ENOMEM);\n    }\n\n    if (!avctx->internal->is_copy) {\n        avctx->internal->allocate_progress = 1;\n        ff_pngdsp_init(&s->dsp);\n    }\n\n    return 0;\n}\n\nstatic av_cold int png_dec_end(AVCodecContext *avctx)\n{\n    PNGDecContext *s = avctx->priv_data;\n\n    ff_thread_release_buffer(avctx, &s->previous_picture);\n    av_frame_free(&s->previous_picture.f);\n    ff_thread_release_buffer(avctx, &s->last_picture);\n    av_frame_free(&s->last_picture.f);\n    ff_thread_release_buffer(avctx, &s->picture);\n    av_frame_free(&s->picture.f);\n    av_freep(&s->buffer);\n    s->buffer_size = 0;\n    av_freep(&s->last_row);\n    s->last_row_size = 0;\n    av_freep(&s->tmp_row);\n    s->tmp_row_size = 0;\n\n    return 0;\n}\n\n#if CONFIG_APNG_DECODER\nAVCodec ff_apng_decoder = {\n    .name           = \"apng\",\n    .long_name      = NULL_IF_CONFIG_SMALL(\"APNG (Animated Portable Network Graphics) image\"),\n    .type           = AVMEDIA_TYPE_VIDEO,\n    .id             = AV_CODEC_ID_APNG,\n    .priv_data_size = sizeof(PNGDecContext),\n    .init           = png_dec_init,\n    .close          = png_dec_end,\n    .decode         = decode_frame_apng,\n    .init_thread_copy = ONLY_IF_THREADS_ENABLED(png_dec_init),\n    .update_thread_context = ONLY_IF_THREADS_ENABLED(update_thread_context),\n    .capabilities   = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_FRAME_THREADS /*| AV_CODEC_CAP_DRAW_HORIZ_BAND*/,\n};\n#endif\n\n#if CONFIG_PNG_DECODER\nAVCodec ff_png_decoder = {\n    .name           = \"png\",\n    .long_name      = NULL_IF_CONFIG_SMALL(\"PNG (Portable Network Graphics) image\"),\n    .type           = AVMEDIA_TYPE_VIDEO,\n    .id             = AV_CODEC_ID_PNG,\n    .priv_data_size = sizeof(PNGDecContext),\n    .init           = png_dec_init,\n    .close          = png_dec_end,\n    .decode         = decode_frame_png,\n    .init_thread_copy = ONLY_IF_THREADS_ENABLED(png_dec_init),\n    .update_thread_context = ONLY_IF_THREADS_ENABLED(update_thread_context),\n    .capabilities   = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_FRAME_THREADS /*| AV_CODEC_CAP_DRAW_HORIZ_BAND*/,\n    .caps_internal  = FF_CODEC_CAP_SKIP_FRAME_FILL_PARAM,\n};\n#endif\n"], "fixing_code": ["/*\n * PNG image format\n * Copyright (c) 2003 Fabrice Bellard\n *\n * This file is part of FFmpeg.\n *\n * FFmpeg is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with FFmpeg; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n//#define DEBUG\n\n#include \"libavutil/avassert.h\"\n#include \"libavutil/bprint.h\"\n#include \"libavutil/imgutils.h\"\n#include \"libavutil/stereo3d.h\"\n\n#include \"avcodec.h\"\n#include \"bytestream.h\"\n#include \"internal.h\"\n#include \"apng.h\"\n#include \"png.h\"\n#include \"pngdsp.h\"\n#include \"thread.h\"\n\n#include <zlib.h>\n\ntypedef struct PNGDecContext {\n    PNGDSPContext dsp;\n    AVCodecContext *avctx;\n\n    GetByteContext gb;\n    ThreadFrame previous_picture;\n    ThreadFrame last_picture;\n    ThreadFrame picture;\n\n    int state;\n    int width, height;\n    int cur_w, cur_h;\n    int last_w, last_h;\n    int x_offset, y_offset;\n    int last_x_offset, last_y_offset;\n    uint8_t dispose_op, blend_op;\n    uint8_t last_dispose_op;\n    int bit_depth;\n    int color_type;\n    int compression_type;\n    int interlace_type;\n    int filter_type;\n    int channels;\n    int bits_per_pixel;\n    int bpp;\n    int has_trns;\n    uint8_t transparent_color_be[6];\n\n    uint8_t *image_buf;\n    int image_linesize;\n    uint32_t palette[256];\n    uint8_t *crow_buf;\n    uint8_t *last_row;\n    unsigned int last_row_size;\n    uint8_t *tmp_row;\n    unsigned int tmp_row_size;\n    uint8_t *buffer;\n    int buffer_size;\n    int pass;\n    int crow_size; /* compressed row size (include filter type) */\n    int row_size; /* decompressed row size */\n    int pass_row_size; /* decompress row size of the current pass */\n    int y;\n    z_stream zstream;\n} PNGDecContext;\n\n/* Mask to determine which pixels are valid in a pass */\nstatic const uint8_t png_pass_mask[NB_PASSES] = {\n    0x01, 0x01, 0x11, 0x11, 0x55, 0x55, 0xff,\n};\n\n/* Mask to determine which y pixels can be written in a pass */\nstatic const uint8_t png_pass_dsp_ymask[NB_PASSES] = {\n    0xff, 0xff, 0x0f, 0xff, 0x33, 0xff, 0x55,\n};\n\n/* Mask to determine which pixels to overwrite while displaying */\nstatic const uint8_t png_pass_dsp_mask[NB_PASSES] = {\n    0xff, 0x0f, 0xff, 0x33, 0xff, 0x55, 0xff\n};\n\n/* NOTE: we try to construct a good looking image at each pass. width\n * is the original image width. We also do pixel format conversion at\n * this stage */\nstatic void png_put_interlaced_row(uint8_t *dst, int width,\n                                   int bits_per_pixel, int pass,\n                                   int color_type, const uint8_t *src)\n{\n    int x, mask, dsp_mask, j, src_x, b, bpp;\n    uint8_t *d;\n    const uint8_t *s;\n\n    mask     = png_pass_mask[pass];\n    dsp_mask = png_pass_dsp_mask[pass];\n\n    switch (bits_per_pixel) {\n    case 1:\n        src_x = 0;\n        for (x = 0; x < width; x++) {\n            j = (x & 7);\n            if ((dsp_mask << j) & 0x80) {\n                b = (src[src_x >> 3] >> (7 - (src_x & 7))) & 1;\n                dst[x >> 3] &= 0xFF7F>>j;\n                dst[x >> 3] |= b << (7 - j);\n            }\n            if ((mask << j) & 0x80)\n                src_x++;\n        }\n        break;\n    case 2:\n        src_x = 0;\n        for (x = 0; x < width; x++) {\n            int j2 = 2 * (x & 3);\n            j = (x & 7);\n            if ((dsp_mask << j) & 0x80) {\n                b = (src[src_x >> 2] >> (6 - 2*(src_x & 3))) & 3;\n                dst[x >> 2] &= 0xFF3F>>j2;\n                dst[x >> 2] |= b << (6 - j2);\n            }\n            if ((mask << j) & 0x80)\n                src_x++;\n        }\n        break;\n    case 4:\n        src_x = 0;\n        for (x = 0; x < width; x++) {\n            int j2 = 4*(x&1);\n            j = (x & 7);\n            if ((dsp_mask << j) & 0x80) {\n                b = (src[src_x >> 1] >> (4 - 4*(src_x & 1))) & 15;\n                dst[x >> 1] &= 0xFF0F>>j2;\n                dst[x >> 1] |= b << (4 - j2);\n            }\n            if ((mask << j) & 0x80)\n                src_x++;\n        }\n        break;\n    default:\n        bpp = bits_per_pixel >> 3;\n        d   = dst;\n        s   = src;\n            for (x = 0; x < width; x++) {\n                j = x & 7;\n                if ((dsp_mask << j) & 0x80) {\n                    memcpy(d, s, bpp);\n                }\n                d += bpp;\n                if ((mask << j) & 0x80)\n                    s += bpp;\n            }\n        break;\n    }\n}\n\nvoid ff_add_png_paeth_prediction(uint8_t *dst, uint8_t *src, uint8_t *top,\n                                 int w, int bpp)\n{\n    int i;\n    for (i = 0; i < w; i++) {\n        int a, b, c, p, pa, pb, pc;\n\n        a = dst[i - bpp];\n        b = top[i];\n        c = top[i - bpp];\n\n        p  = b - c;\n        pc = a - c;\n\n        pa = abs(p);\n        pb = abs(pc);\n        pc = abs(p + pc);\n\n        if (pa <= pb && pa <= pc)\n            p = a;\n        else if (pb <= pc)\n            p = b;\n        else\n            p = c;\n        dst[i] = p + src[i];\n    }\n}\n\n#define UNROLL1(bpp, op)                                                      \\\n    {                                                                         \\\n        r = dst[0];                                                           \\\n        if (bpp >= 2)                                                         \\\n            g = dst[1];                                                       \\\n        if (bpp >= 3)                                                         \\\n            b = dst[2];                                                       \\\n        if (bpp >= 4)                                                         \\\n            a = dst[3];                                                       \\\n        for (; i <= size - bpp; i += bpp) {                                   \\\n            dst[i + 0] = r = op(r, src[i + 0], last[i + 0]);                  \\\n            if (bpp == 1)                                                     \\\n                continue;                                                     \\\n            dst[i + 1] = g = op(g, src[i + 1], last[i + 1]);                  \\\n            if (bpp == 2)                                                     \\\n                continue;                                                     \\\n            dst[i + 2] = b = op(b, src[i + 2], last[i + 2]);                  \\\n            if (bpp == 3)                                                     \\\n                continue;                                                     \\\n            dst[i + 3] = a = op(a, src[i + 3], last[i + 3]);                  \\\n        }                                                                     \\\n    }\n\n#define UNROLL_FILTER(op)                                                     \\\n    if (bpp == 1) {                                                           \\\n        UNROLL1(1, op)                                                        \\\n    } else if (bpp == 2) {                                                    \\\n        UNROLL1(2, op)                                                        \\\n    } else if (bpp == 3) {                                                    \\\n        UNROLL1(3, op)                                                        \\\n    } else if (bpp == 4) {                                                    \\\n        UNROLL1(4, op)                                                        \\\n    }                                                                         \\\n    for (; i < size; i++) {                                                   \\\n        dst[i] = op(dst[i - bpp], src[i], last[i]);                           \\\n    }\n\n/* NOTE: 'dst' can be equal to 'last' */\nstatic void png_filter_row(PNGDSPContext *dsp, uint8_t *dst, int filter_type,\n                           uint8_t *src, uint8_t *last, int size, int bpp)\n{\n    int i, p, r, g, b, a;\n\n    switch (filter_type) {\n    case PNG_FILTER_VALUE_NONE:\n        memcpy(dst, src, size);\n        break;\n    case PNG_FILTER_VALUE_SUB:\n        for (i = 0; i < bpp; i++)\n            dst[i] = src[i];\n        if (bpp == 4) {\n            p = *(int *)dst;\n            for (; i < size; i += bpp) {\n                unsigned s = *(int *)(src + i);\n                p = ((s & 0x7f7f7f7f) + (p & 0x7f7f7f7f)) ^ ((s ^ p) & 0x80808080);\n                *(int *)(dst + i) = p;\n            }\n        } else {\n#define OP_SUB(x, s, l) ((x) + (s))\n            UNROLL_FILTER(OP_SUB);\n        }\n        break;\n    case PNG_FILTER_VALUE_UP:\n        dsp->add_bytes_l2(dst, src, last, size);\n        break;\n    case PNG_FILTER_VALUE_AVG:\n        for (i = 0; i < bpp; i++) {\n            p      = (last[i] >> 1);\n            dst[i] = p + src[i];\n        }\n#define OP_AVG(x, s, l) (((((x) + (l)) >> 1) + (s)) & 0xff)\n        UNROLL_FILTER(OP_AVG);\n        break;\n    case PNG_FILTER_VALUE_PAETH:\n        for (i = 0; i < bpp; i++) {\n            p      = last[i];\n            dst[i] = p + src[i];\n        }\n        if (bpp > 2 && size > 4) {\n            /* would write off the end of the array if we let it process\n             * the last pixel with bpp=3 */\n            int w = (bpp & 3) ? size - 3 : size;\n\n            if (w > i) {\n                dsp->add_paeth_prediction(dst + i, src + i, last + i, size - i, bpp);\n                i = w;\n            }\n        }\n        ff_add_png_paeth_prediction(dst + i, src + i, last + i, size - i, bpp);\n        break;\n    }\n}\n\n/* This used to be called \"deloco\" in FFmpeg\n * and is actually an inverse reversible colorspace transformation */\n#define YUV2RGB(NAME, TYPE) \\\nstatic void deloco_ ## NAME(TYPE *dst, int size, int alpha) \\\n{ \\\n    int i; \\\n    for (i = 0; i < size; i += 3 + alpha) { \\\n        int g = dst [i + 1]; \\\n        dst[i + 0] += g; \\\n        dst[i + 2] += g; \\\n    } \\\n}\n\nYUV2RGB(rgb8, uint8_t)\nYUV2RGB(rgb16, uint16_t)\n\n/* process exactly one decompressed row */\nstatic void png_handle_row(PNGDecContext *s)\n{\n    uint8_t *ptr, *last_row;\n    int got_line;\n\n    if (!s->interlace_type) {\n        ptr = s->image_buf + s->image_linesize * (s->y + s->y_offset) + s->x_offset * s->bpp;\n        if (s->y == 0)\n            last_row = s->last_row;\n        else\n            last_row = ptr - s->image_linesize;\n\n        png_filter_row(&s->dsp, ptr, s->crow_buf[0], s->crow_buf + 1,\n                       last_row, s->row_size, s->bpp);\n        /* loco lags by 1 row so that it doesn't interfere with top prediction */\n        if (s->filter_type == PNG_FILTER_TYPE_LOCO && s->y > 0) {\n            if (s->bit_depth == 16) {\n                deloco_rgb16((uint16_t *)(ptr - s->image_linesize), s->row_size / 2,\n                             s->color_type == PNG_COLOR_TYPE_RGB_ALPHA);\n            } else {\n                deloco_rgb8(ptr - s->image_linesize, s->row_size,\n                            s->color_type == PNG_COLOR_TYPE_RGB_ALPHA);\n            }\n        }\n        s->y++;\n        if (s->y == s->cur_h) {\n            s->state |= PNG_ALLIMAGE;\n            if (s->filter_type == PNG_FILTER_TYPE_LOCO) {\n                if (s->bit_depth == 16) {\n                    deloco_rgb16((uint16_t *)ptr, s->row_size / 2,\n                                 s->color_type == PNG_COLOR_TYPE_RGB_ALPHA);\n                } else {\n                    deloco_rgb8(ptr, s->row_size,\n                                s->color_type == PNG_COLOR_TYPE_RGB_ALPHA);\n                }\n            }\n        }\n    } else {\n        got_line = 0;\n        for (;;) {\n            ptr = s->image_buf + s->image_linesize * (s->y + s->y_offset) + s->x_offset * s->bpp;\n            if ((ff_png_pass_ymask[s->pass] << (s->y & 7)) & 0x80) {\n                /* if we already read one row, it is time to stop to\n                 * wait for the next one */\n                if (got_line)\n                    break;\n                png_filter_row(&s->dsp, s->tmp_row, s->crow_buf[0], s->crow_buf + 1,\n                               s->last_row, s->pass_row_size, s->bpp);\n                FFSWAP(uint8_t *, s->last_row, s->tmp_row);\n                FFSWAP(unsigned int, s->last_row_size, s->tmp_row_size);\n                got_line = 1;\n            }\n            if ((png_pass_dsp_ymask[s->pass] << (s->y & 7)) & 0x80) {\n                png_put_interlaced_row(ptr, s->cur_w, s->bits_per_pixel, s->pass,\n                                       s->color_type, s->last_row);\n            }\n            s->y++;\n            if (s->y == s->cur_h) {\n                memset(s->last_row, 0, s->row_size);\n                for (;;) {\n                    if (s->pass == NB_PASSES - 1) {\n                        s->state |= PNG_ALLIMAGE;\n                        goto the_end;\n                    } else {\n                        s->pass++;\n                        s->y = 0;\n                        s->pass_row_size = ff_png_pass_row_size(s->pass,\n                                                                s->bits_per_pixel,\n                                                                s->cur_w);\n                        s->crow_size = s->pass_row_size + 1;\n                        if (s->pass_row_size != 0)\n                            break;\n                        /* skip pass if empty row */\n                    }\n                }\n            }\n        }\nthe_end:;\n    }\n}\n\nstatic int png_decode_idat(PNGDecContext *s, int length)\n{\n    int ret;\n    s->zstream.avail_in = FFMIN(length, bytestream2_get_bytes_left(&s->gb));\n    s->zstream.next_in  = (unsigned char *)s->gb.buffer;\n    bytestream2_skip(&s->gb, length);\n\n    /* decode one line if possible */\n    while (s->zstream.avail_in > 0) {\n        ret = inflate(&s->zstream, Z_PARTIAL_FLUSH);\n        if (ret != Z_OK && ret != Z_STREAM_END) {\n            av_log(s->avctx, AV_LOG_ERROR, \"inflate returned error %d\\n\", ret);\n            return AVERROR_EXTERNAL;\n        }\n        if (s->zstream.avail_out == 0) {\n            if (!(s->state & PNG_ALLIMAGE)) {\n                png_handle_row(s);\n            }\n            s->zstream.avail_out = s->crow_size;\n            s->zstream.next_out  = s->crow_buf;\n        }\n        if (ret == Z_STREAM_END && s->zstream.avail_in > 0) {\n            av_log(NULL, AV_LOG_WARNING,\n                   \"%d undecompressed bytes left in buffer\\n\", s->zstream.avail_in);\n            return 0;\n        }\n    }\n    return 0;\n}\n\nstatic int decode_zbuf(AVBPrint *bp, const uint8_t *data,\n                       const uint8_t *data_end)\n{\n    z_stream zstream;\n    unsigned char *buf;\n    unsigned buf_size;\n    int ret;\n\n    zstream.zalloc = ff_png_zalloc;\n    zstream.zfree  = ff_png_zfree;\n    zstream.opaque = NULL;\n    if (inflateInit(&zstream) != Z_OK)\n        return AVERROR_EXTERNAL;\n    zstream.next_in  = (unsigned char *)data;\n    zstream.avail_in = data_end - data;\n    av_bprint_init(bp, 0, -1);\n\n    while (zstream.avail_in > 0) {\n        av_bprint_get_buffer(bp, 2, &buf, &buf_size);\n        if (buf_size < 2) {\n            ret = AVERROR(ENOMEM);\n            goto fail;\n        }\n        zstream.next_out  = buf;\n        zstream.avail_out = buf_size - 1;\n        ret = inflate(&zstream, Z_PARTIAL_FLUSH);\n        if (ret != Z_OK && ret != Z_STREAM_END) {\n            ret = AVERROR_EXTERNAL;\n            goto fail;\n        }\n        bp->len += zstream.next_out - buf;\n        if (ret == Z_STREAM_END)\n            break;\n    }\n    inflateEnd(&zstream);\n    bp->str[bp->len] = 0;\n    return 0;\n\nfail:\n    inflateEnd(&zstream);\n    av_bprint_finalize(bp, NULL);\n    return ret;\n}\n\nstatic uint8_t *iso88591_to_utf8(const uint8_t *in, size_t size_in)\n{\n    size_t extra = 0, i;\n    uint8_t *out, *q;\n\n    for (i = 0; i < size_in; i++)\n        extra += in[i] >= 0x80;\n    if (size_in == SIZE_MAX || extra > SIZE_MAX - size_in - 1)\n        return NULL;\n    q = out = av_malloc(size_in + extra + 1);\n    if (!out)\n        return NULL;\n    for (i = 0; i < size_in; i++) {\n        if (in[i] >= 0x80) {\n            *(q++) = 0xC0 | (in[i] >> 6);\n            *(q++) = 0x80 | (in[i] & 0x3F);\n        } else {\n            *(q++) = in[i];\n        }\n    }\n    *(q++) = 0;\n    return out;\n}\n\nstatic int decode_text_chunk(PNGDecContext *s, uint32_t length, int compressed,\n                             AVDictionary **dict)\n{\n    int ret, method;\n    const uint8_t *data        = s->gb.buffer;\n    const uint8_t *data_end    = data + length;\n    const uint8_t *keyword     = data;\n    const uint8_t *keyword_end = memchr(keyword, 0, data_end - keyword);\n    uint8_t *kw_utf8 = NULL, *text, *txt_utf8 = NULL;\n    unsigned text_len;\n    AVBPrint bp;\n\n    if (!keyword_end)\n        return AVERROR_INVALIDDATA;\n    data = keyword_end + 1;\n\n    if (compressed) {\n        if (data == data_end)\n            return AVERROR_INVALIDDATA;\n        method = *(data++);\n        if (method)\n            return AVERROR_INVALIDDATA;\n        if ((ret = decode_zbuf(&bp, data, data_end)) < 0)\n            return ret;\n        text_len = bp.len;\n        av_bprint_finalize(&bp, (char **)&text);\n        if (!text)\n            return AVERROR(ENOMEM);\n    } else {\n        text = (uint8_t *)data;\n        text_len = data_end - text;\n    }\n\n    kw_utf8  = iso88591_to_utf8(keyword, keyword_end - keyword);\n    txt_utf8 = iso88591_to_utf8(text, text_len);\n    if (text != data)\n        av_free(text);\n    if (!(kw_utf8 && txt_utf8)) {\n        av_free(kw_utf8);\n        av_free(txt_utf8);\n        return AVERROR(ENOMEM);\n    }\n\n    av_dict_set(dict, kw_utf8, txt_utf8,\n                AV_DICT_DONT_STRDUP_KEY | AV_DICT_DONT_STRDUP_VAL);\n    return 0;\n}\n\nstatic int decode_ihdr_chunk(AVCodecContext *avctx, PNGDecContext *s,\n                             uint32_t length)\n{\n    if (length != 13)\n        return AVERROR_INVALIDDATA;\n\n    if (s->state & PNG_IDAT) {\n        av_log(avctx, AV_LOG_ERROR, \"IHDR after IDAT\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (s->state & PNG_IHDR) {\n        av_log(avctx, AV_LOG_ERROR, \"Multiple IHDR\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    s->width  = s->cur_w = bytestream2_get_be32(&s->gb);\n    s->height = s->cur_h = bytestream2_get_be32(&s->gb);\n    if (av_image_check_size(s->width, s->height, 0, avctx)) {\n        s->cur_w = s->cur_h = s->width = s->height = 0;\n        av_log(avctx, AV_LOG_ERROR, \"Invalid image size\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    s->bit_depth        = bytestream2_get_byte(&s->gb);\n    s->color_type       = bytestream2_get_byte(&s->gb);\n    s->compression_type = bytestream2_get_byte(&s->gb);\n    s->filter_type      = bytestream2_get_byte(&s->gb);\n    s->interlace_type   = bytestream2_get_byte(&s->gb);\n    bytestream2_skip(&s->gb, 4); /* crc */\n    s->state |= PNG_IHDR;\n    if (avctx->debug & FF_DEBUG_PICT_INFO)\n        av_log(avctx, AV_LOG_DEBUG, \"width=%d height=%d depth=%d color_type=%d \"\n                \"compression_type=%d filter_type=%d interlace_type=%d\\n\",\n                s->width, s->height, s->bit_depth, s->color_type,\n                s->compression_type, s->filter_type, s->interlace_type);\n\n    return 0;\n}\n\nstatic int decode_phys_chunk(AVCodecContext *avctx, PNGDecContext *s)\n{\n    if (s->state & PNG_IDAT) {\n        av_log(avctx, AV_LOG_ERROR, \"pHYs after IDAT\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    avctx->sample_aspect_ratio.num = bytestream2_get_be32(&s->gb);\n    avctx->sample_aspect_ratio.den = bytestream2_get_be32(&s->gb);\n    if (avctx->sample_aspect_ratio.num < 0 || avctx->sample_aspect_ratio.den < 0)\n        avctx->sample_aspect_ratio = (AVRational){ 0, 1 };\n    bytestream2_skip(&s->gb, 1); /* unit specifier */\n    bytestream2_skip(&s->gb, 4); /* crc */\n\n    return 0;\n}\n\nstatic int decode_idat_chunk(AVCodecContext *avctx, PNGDecContext *s,\n                             uint32_t length, AVFrame *p)\n{\n    int ret;\n    size_t byte_depth = s->bit_depth > 8 ? 2 : 1;\n\n    if (!(s->state & PNG_IHDR)) {\n        av_log(avctx, AV_LOG_ERROR, \"IDAT without IHDR\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    if (!(s->state & PNG_IDAT)) {\n        /* init image info */\n        avctx->width  = s->width;\n        avctx->height = s->height;\n\n        s->channels       = ff_png_get_nb_channels(s->color_type);\n        s->bits_per_pixel = s->bit_depth * s->channels;\n        s->bpp            = (s->bits_per_pixel + 7) >> 3;\n        s->row_size       = (s->cur_w * s->bits_per_pixel + 7) >> 3;\n\n        if ((s->bit_depth == 2 || s->bit_depth == 4 || s->bit_depth == 8) &&\n                s->color_type == PNG_COLOR_TYPE_RGB) {\n            avctx->pix_fmt = AV_PIX_FMT_RGB24;\n        } else if ((s->bit_depth == 2 || s->bit_depth == 4 || s->bit_depth == 8) &&\n                s->color_type == PNG_COLOR_TYPE_RGB_ALPHA) {\n            avctx->pix_fmt = AV_PIX_FMT_RGBA;\n        } else if ((s->bit_depth == 2 || s->bit_depth == 4 || s->bit_depth == 8) &&\n                s->color_type == PNG_COLOR_TYPE_GRAY) {\n            avctx->pix_fmt = AV_PIX_FMT_GRAY8;\n        } else if (s->bit_depth == 16 &&\n                s->color_type == PNG_COLOR_TYPE_GRAY) {\n            avctx->pix_fmt = AV_PIX_FMT_GRAY16BE;\n        } else if (s->bit_depth == 16 &&\n                s->color_type == PNG_COLOR_TYPE_RGB) {\n            avctx->pix_fmt = AV_PIX_FMT_RGB48BE;\n        } else if (s->bit_depth == 16 &&\n                s->color_type == PNG_COLOR_TYPE_RGB_ALPHA) {\n            avctx->pix_fmt = AV_PIX_FMT_RGBA64BE;\n        } else if ((s->bits_per_pixel == 1 || s->bits_per_pixel == 2 || s->bits_per_pixel == 4 || s->bits_per_pixel == 8) &&\n                s->color_type == PNG_COLOR_TYPE_PALETTE) {\n            avctx->pix_fmt = AV_PIX_FMT_PAL8;\n        } else if (s->bit_depth == 1 && s->bits_per_pixel == 1 && avctx->codec_id != AV_CODEC_ID_APNG) {\n            avctx->pix_fmt = AV_PIX_FMT_MONOBLACK;\n        } else if (s->bit_depth == 8 &&\n                s->color_type == PNG_COLOR_TYPE_GRAY_ALPHA) {\n            avctx->pix_fmt = AV_PIX_FMT_YA8;\n        } else if (s->bit_depth == 16 &&\n                s->color_type == PNG_COLOR_TYPE_GRAY_ALPHA) {\n            avctx->pix_fmt = AV_PIX_FMT_YA16BE;\n        } else {\n            av_log(avctx, AV_LOG_ERROR, \"unsupported bit depth %d \"\n                    \"and color type %d\\n\",\n                    s->bit_depth, s->color_type);\n            return AVERROR_INVALIDDATA;\n        }\n\n        if (s->has_trns && s->color_type != PNG_COLOR_TYPE_PALETTE) {\n            switch (avctx->pix_fmt) {\n            case AV_PIX_FMT_RGB24:\n                avctx->pix_fmt = AV_PIX_FMT_RGBA;\n                break;\n\n            case AV_PIX_FMT_RGB48BE:\n                avctx->pix_fmt = AV_PIX_FMT_RGBA64BE;\n                break;\n\n            case AV_PIX_FMT_GRAY8:\n                avctx->pix_fmt = AV_PIX_FMT_YA8;\n                break;\n\n            case AV_PIX_FMT_GRAY16BE:\n                avctx->pix_fmt = AV_PIX_FMT_YA16BE;\n                break;\n\n            default:\n                avpriv_request_sample(avctx, \"bit depth %d \"\n                        \"and color type %d with TRNS\",\n                        s->bit_depth, s->color_type);\n                return AVERROR_INVALIDDATA;\n            }\n\n            s->bpp += byte_depth;\n        }\n\n        if ((ret = ff_thread_get_buffer(avctx, &s->picture, AV_GET_BUFFER_FLAG_REF)) < 0)\n            return ret;\n        if (avctx->codec_id == AV_CODEC_ID_APNG && s->last_dispose_op != APNG_DISPOSE_OP_PREVIOUS) {\n            ff_thread_release_buffer(avctx, &s->previous_picture);\n            if ((ret = ff_thread_get_buffer(avctx, &s->previous_picture, AV_GET_BUFFER_FLAG_REF)) < 0)\n                return ret;\n        }\n        ff_thread_finish_setup(avctx);\n\n        p->pict_type        = AV_PICTURE_TYPE_I;\n        p->key_frame        = 1;\n        p->interlaced_frame = !!s->interlace_type;\n\n        /* compute the compressed row size */\n        if (!s->interlace_type) {\n            s->crow_size = s->row_size + 1;\n        } else {\n            s->pass          = 0;\n            s->pass_row_size = ff_png_pass_row_size(s->pass,\n                    s->bits_per_pixel,\n                    s->cur_w);\n            s->crow_size = s->pass_row_size + 1;\n        }\n        ff_dlog(avctx, \"row_size=%d crow_size =%d\\n\",\n                s->row_size, s->crow_size);\n        s->image_buf      = p->data[0];\n        s->image_linesize = p->linesize[0];\n        /* copy the palette if needed */\n        if (avctx->pix_fmt == AV_PIX_FMT_PAL8)\n            memcpy(p->data[1], s->palette, 256 * sizeof(uint32_t));\n        /* empty row is used if differencing to the first row */\n        av_fast_padded_mallocz(&s->last_row, &s->last_row_size, s->row_size);\n        if (!s->last_row)\n            return AVERROR_INVALIDDATA;\n        if (s->interlace_type ||\n                s->color_type == PNG_COLOR_TYPE_RGB_ALPHA) {\n            av_fast_padded_malloc(&s->tmp_row, &s->tmp_row_size, s->row_size);\n            if (!s->tmp_row)\n                return AVERROR_INVALIDDATA;\n        }\n        /* compressed row */\n        av_fast_padded_malloc(&s->buffer, &s->buffer_size, s->row_size + 16);\n        if (!s->buffer)\n            return AVERROR(ENOMEM);\n\n        /* we want crow_buf+1 to be 16-byte aligned */\n        s->crow_buf          = s->buffer + 15;\n        s->zstream.avail_out = s->crow_size;\n        s->zstream.next_out  = s->crow_buf;\n    }\n\n    s->state |= PNG_IDAT;\n\n    /* set image to non-transparent bpp while decompressing */\n    if (s->has_trns && s->color_type != PNG_COLOR_TYPE_PALETTE)\n        s->bpp -= byte_depth;\n\n    ret = png_decode_idat(s, length);\n\n    if (s->has_trns && s->color_type != PNG_COLOR_TYPE_PALETTE)\n        s->bpp += byte_depth;\n\n    if (ret < 0)\n        return ret;\n\n    bytestream2_skip(&s->gb, 4); /* crc */\n\n    return 0;\n}\n\nstatic int decode_plte_chunk(AVCodecContext *avctx, PNGDecContext *s,\n                             uint32_t length)\n{\n    int n, i, r, g, b;\n\n    if ((length % 3) != 0 || length > 256 * 3)\n        return AVERROR_INVALIDDATA;\n    /* read the palette */\n    n = length / 3;\n    for (i = 0; i < n; i++) {\n        r = bytestream2_get_byte(&s->gb);\n        g = bytestream2_get_byte(&s->gb);\n        b = bytestream2_get_byte(&s->gb);\n        s->palette[i] = (0xFFU << 24) | (r << 16) | (g << 8) | b;\n    }\n    for (; i < 256; i++)\n        s->palette[i] = (0xFFU << 24);\n    s->state |= PNG_PLTE;\n    bytestream2_skip(&s->gb, 4);     /* crc */\n\n    return 0;\n}\n\nstatic int decode_trns_chunk(AVCodecContext *avctx, PNGDecContext *s,\n                             uint32_t length)\n{\n    int v, i;\n\n    if (!(s->state & PNG_IHDR)) {\n        av_log(avctx, AV_LOG_ERROR, \"trns before IHDR\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (s->state & PNG_IDAT) {\n        av_log(avctx, AV_LOG_ERROR, \"trns after IDAT\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (s->color_type == PNG_COLOR_TYPE_PALETTE) {\n        if (length > 256 || !(s->state & PNG_PLTE))\n            return AVERROR_INVALIDDATA;\n\n        for (i = 0; i < length; i++) {\n            v = bytestream2_get_byte(&s->gb);\n            s->palette[i] = (s->palette[i] & 0x00ffffff) | (v << 24);\n        }\n    } else if (s->color_type == PNG_COLOR_TYPE_GRAY || s->color_type == PNG_COLOR_TYPE_RGB) {\n        if ((s->color_type == PNG_COLOR_TYPE_GRAY && length != 2) ||\n            (s->color_type == PNG_COLOR_TYPE_RGB && length != 6) ||\n            s->bit_depth == 1)\n            return AVERROR_INVALIDDATA;\n\n        for (i = 0; i < length / 2; i++) {\n            /* only use the least significant bits */\n            v = av_mod_uintp2(bytestream2_get_be16(&s->gb), s->bit_depth);\n\n            if (s->bit_depth > 8)\n                AV_WB16(&s->transparent_color_be[2 * i], v);\n            else\n                s->transparent_color_be[i] = v;\n        }\n    } else {\n        return AVERROR_INVALIDDATA;\n    }\n\n    bytestream2_skip(&s->gb, 4); /* crc */\n    s->has_trns = 1;\n\n    return 0;\n}\n\nstatic void handle_small_bpp(PNGDecContext *s, AVFrame *p)\n{\n    if (s->bits_per_pixel == 1 && s->color_type == PNG_COLOR_TYPE_PALETTE) {\n        int i, j, k;\n        uint8_t *pd = p->data[0];\n        for (j = 0; j < s->height; j++) {\n            i = s->width / 8;\n            for (k = 7; k >= 1; k--)\n                if ((s->width&7) >= k)\n                    pd[8*i + k - 1] = (pd[i]>>8-k) & 1;\n            for (i--; i >= 0; i--) {\n                pd[8*i + 7]=  pd[i]     & 1;\n                pd[8*i + 6]= (pd[i]>>1) & 1;\n                pd[8*i + 5]= (pd[i]>>2) & 1;\n                pd[8*i + 4]= (pd[i]>>3) & 1;\n                pd[8*i + 3]= (pd[i]>>4) & 1;\n                pd[8*i + 2]= (pd[i]>>5) & 1;\n                pd[8*i + 1]= (pd[i]>>6) & 1;\n                pd[8*i + 0]=  pd[i]>>7;\n            }\n            pd += s->image_linesize;\n        }\n    } else if (s->bits_per_pixel == 2) {\n        int i, j;\n        uint8_t *pd = p->data[0];\n        for (j = 0; j < s->height; j++) {\n            i = s->width / 4;\n            if (s->color_type == PNG_COLOR_TYPE_PALETTE) {\n                if ((s->width&3) >= 3) pd[4*i + 2]= (pd[i] >> 2) & 3;\n                if ((s->width&3) >= 2) pd[4*i + 1]= (pd[i] >> 4) & 3;\n                if ((s->width&3) >= 1) pd[4*i + 0]=  pd[i] >> 6;\n                for (i--; i >= 0; i--) {\n                    pd[4*i + 3]=  pd[i]     & 3;\n                    pd[4*i + 2]= (pd[i]>>2) & 3;\n                    pd[4*i + 1]= (pd[i]>>4) & 3;\n                    pd[4*i + 0]=  pd[i]>>6;\n                }\n            } else {\n                if ((s->width&3) >= 3) pd[4*i + 2]= ((pd[i]>>2) & 3)*0x55;\n                if ((s->width&3) >= 2) pd[4*i + 1]= ((pd[i]>>4) & 3)*0x55;\n                if ((s->width&3) >= 1) pd[4*i + 0]= ( pd[i]>>6     )*0x55;\n                for (i--; i >= 0; i--) {\n                    pd[4*i + 3]= ( pd[i]     & 3)*0x55;\n                    pd[4*i + 2]= ((pd[i]>>2) & 3)*0x55;\n                    pd[4*i + 1]= ((pd[i]>>4) & 3)*0x55;\n                    pd[4*i + 0]= ( pd[i]>>6     )*0x55;\n                }\n            }\n            pd += s->image_linesize;\n        }\n    } else if (s->bits_per_pixel == 4) {\n        int i, j;\n        uint8_t *pd = p->data[0];\n        for (j = 0; j < s->height; j++) {\n            i = s->width/2;\n            if (s->color_type == PNG_COLOR_TYPE_PALETTE) {\n                if (s->width&1) pd[2*i+0]= pd[i]>>4;\n                for (i--; i >= 0; i--) {\n                    pd[2*i + 1] = pd[i] & 15;\n                    pd[2*i + 0] = pd[i] >> 4;\n                }\n            } else {\n                if (s->width & 1) pd[2*i + 0]= (pd[i] >> 4) * 0x11;\n                for (i--; i >= 0; i--) {\n                    pd[2*i + 1] = (pd[i] & 15) * 0x11;\n                    pd[2*i + 0] = (pd[i] >> 4) * 0x11;\n                }\n            }\n            pd += s->image_linesize;\n        }\n    }\n}\n\nstatic int decode_fctl_chunk(AVCodecContext *avctx, PNGDecContext *s,\n                             uint32_t length)\n{\n    uint32_t sequence_number;\n    int cur_w, cur_h, x_offset, y_offset, dispose_op, blend_op;\n\n    if (length != 26)\n        return AVERROR_INVALIDDATA;\n\n    if (!(s->state & PNG_IHDR)) {\n        av_log(avctx, AV_LOG_ERROR, \"fctl before IHDR\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    s->last_w = s->cur_w;\n    s->last_h = s->cur_h;\n    s->last_x_offset = s->x_offset;\n    s->last_y_offset = s->y_offset;\n    s->last_dispose_op = s->dispose_op;\n\n    sequence_number = bytestream2_get_be32(&s->gb);\n    cur_w           = bytestream2_get_be32(&s->gb);\n    cur_h           = bytestream2_get_be32(&s->gb);\n    x_offset        = bytestream2_get_be32(&s->gb);\n    y_offset        = bytestream2_get_be32(&s->gb);\n    bytestream2_skip(&s->gb, 4); /* delay_num (2), delay_den (2) */\n    dispose_op      = bytestream2_get_byte(&s->gb);\n    blend_op        = bytestream2_get_byte(&s->gb);\n    bytestream2_skip(&s->gb, 4); /* crc */\n\n    if (sequence_number == 0 &&\n        (cur_w != s->width ||\n         cur_h != s->height ||\n         x_offset != 0 ||\n         y_offset != 0) ||\n        cur_w <= 0 || cur_h <= 0 ||\n        x_offset < 0 || y_offset < 0 ||\n        cur_w > s->width - x_offset|| cur_h > s->height - y_offset)\n            return AVERROR_INVALIDDATA;\n\n    if (blend_op != APNG_BLEND_OP_OVER && blend_op != APNG_BLEND_OP_SOURCE) {\n        av_log(avctx, AV_LOG_ERROR, \"Invalid blend_op %d\\n\", blend_op);\n        return AVERROR_INVALIDDATA;\n    }\n\n    if ((sequence_number == 0 || !s->previous_picture.f->data[0]) &&\n        dispose_op == APNG_DISPOSE_OP_PREVIOUS) {\n        // No previous frame to revert to for the first frame\n        // Spec says to just treat it as a APNG_DISPOSE_OP_BACKGROUND\n        dispose_op = APNG_DISPOSE_OP_BACKGROUND;\n    }\n\n    if (blend_op == APNG_BLEND_OP_OVER && !s->has_trns && (\n            avctx->pix_fmt == AV_PIX_FMT_RGB24 ||\n            avctx->pix_fmt == AV_PIX_FMT_RGB48BE ||\n            avctx->pix_fmt == AV_PIX_FMT_PAL8 ||\n            avctx->pix_fmt == AV_PIX_FMT_GRAY8 ||\n            avctx->pix_fmt == AV_PIX_FMT_GRAY16BE ||\n            avctx->pix_fmt == AV_PIX_FMT_MONOBLACK\n        )) {\n        // APNG_BLEND_OP_OVER is the same as APNG_BLEND_OP_SOURCE when there is no alpha channel\n        blend_op = APNG_BLEND_OP_SOURCE;\n    }\n\n    s->cur_w      = cur_w;\n    s->cur_h      = cur_h;\n    s->x_offset   = x_offset;\n    s->y_offset   = y_offset;\n    s->dispose_op = dispose_op;\n    s->blend_op   = blend_op;\n\n    return 0;\n}\n\nstatic void handle_p_frame_png(PNGDecContext *s, AVFrame *p)\n{\n    int i, j;\n    uint8_t *pd      = p->data[0];\n    uint8_t *pd_last = s->last_picture.f->data[0];\n    int ls = FFMIN(av_image_get_linesize(p->format, s->width, 0), s->width * s->bpp);\n\n    ff_thread_await_progress(&s->last_picture, INT_MAX, 0);\n    for (j = 0; j < s->height; j++) {\n        for (i = 0; i < ls; i++)\n            pd[i] += pd_last[i];\n        pd      += s->image_linesize;\n        pd_last += s->image_linesize;\n    }\n}\n\n// divide by 255 and round to nearest\n// apply a fast variant: (X+127)/255 = ((X+127)*257+257)>>16 = ((X+128)*257)>>16\n#define FAST_DIV255(x) ((((x) + 128) * 257) >> 16)\n\nstatic int handle_p_frame_apng(AVCodecContext *avctx, PNGDecContext *s,\n                               AVFrame *p)\n{\n    size_t x, y;\n    uint8_t *buffer;\n\n    if (s->blend_op == APNG_BLEND_OP_OVER &&\n        avctx->pix_fmt != AV_PIX_FMT_RGBA &&\n        avctx->pix_fmt != AV_PIX_FMT_GRAY8A &&\n        avctx->pix_fmt != AV_PIX_FMT_PAL8) {\n        avpriv_request_sample(avctx, \"Blending with pixel format %s\",\n                              av_get_pix_fmt_name(avctx->pix_fmt));\n        return AVERROR_PATCHWELCOME;\n    }\n\n    buffer = av_malloc_array(s->image_linesize, s->height);\n    if (!buffer)\n        return AVERROR(ENOMEM);\n\n\n    // Do the disposal operation specified by the last frame on the frame\n    if (s->last_dispose_op != APNG_DISPOSE_OP_PREVIOUS) {\n        ff_thread_await_progress(&s->last_picture, INT_MAX, 0);\n        memcpy(buffer, s->last_picture.f->data[0], s->image_linesize * s->height);\n\n        if (s->last_dispose_op == APNG_DISPOSE_OP_BACKGROUND)\n            for (y = s->last_y_offset; y < s->last_y_offset + s->last_h; ++y)\n                memset(buffer + s->image_linesize * y + s->bpp * s->last_x_offset, 0, s->bpp * s->last_w);\n\n        memcpy(s->previous_picture.f->data[0], buffer, s->image_linesize * s->height);\n        ff_thread_report_progress(&s->previous_picture, INT_MAX, 0);\n    } else {\n        ff_thread_await_progress(&s->previous_picture, INT_MAX, 0);\n        memcpy(buffer, s->previous_picture.f->data[0], s->image_linesize * s->height);\n    }\n\n    // Perform blending\n    if (s->blend_op == APNG_BLEND_OP_SOURCE) {\n        for (y = s->y_offset; y < s->y_offset + s->cur_h; ++y) {\n            size_t row_start = s->image_linesize * y + s->bpp * s->x_offset;\n            memcpy(buffer + row_start, p->data[0] + row_start, s->bpp * s->cur_w);\n        }\n    } else { // APNG_BLEND_OP_OVER\n        for (y = s->y_offset; y < s->y_offset + s->cur_h; ++y) {\n            uint8_t *foreground = p->data[0] + s->image_linesize * y + s->bpp * s->x_offset;\n            uint8_t *background = buffer + s->image_linesize * y + s->bpp * s->x_offset;\n            for (x = s->x_offset; x < s->x_offset + s->cur_w; ++x, foreground += s->bpp, background += s->bpp) {\n                size_t b;\n                uint8_t foreground_alpha, background_alpha, output_alpha;\n                uint8_t output[10];\n\n                // Since we might be blending alpha onto alpha, we use the following equations:\n                // output_alpha = foreground_alpha + (1 - foreground_alpha) * background_alpha\n                // output = (foreground_alpha * foreground + (1 - foreground_alpha) * background_alpha * background) / output_alpha\n\n                switch (avctx->pix_fmt) {\n                case AV_PIX_FMT_RGBA:\n                    foreground_alpha = foreground[3];\n                    background_alpha = background[3];\n                    break;\n\n                case AV_PIX_FMT_GRAY8A:\n                    foreground_alpha = foreground[1];\n                    background_alpha = background[1];\n                    break;\n\n                case AV_PIX_FMT_PAL8:\n                    foreground_alpha = s->palette[foreground[0]] >> 24;\n                    background_alpha = s->palette[background[0]] >> 24;\n                    break;\n                }\n\n                if (foreground_alpha == 0)\n                    continue;\n\n                if (foreground_alpha == 255) {\n                    memcpy(background, foreground, s->bpp);\n                    continue;\n                }\n\n                if (avctx->pix_fmt == AV_PIX_FMT_PAL8) {\n                    // TODO: Alpha blending with PAL8 will likely need the entire image converted over to RGBA first\n                    avpriv_request_sample(avctx, \"Alpha blending palette samples\");\n                    background[0] = foreground[0];\n                    continue;\n                }\n\n                output_alpha = foreground_alpha + FAST_DIV255((255 - foreground_alpha) * background_alpha);\n\n                av_assert0(s->bpp <= 10);\n\n                for (b = 0; b < s->bpp - 1; ++b) {\n                    if (output_alpha == 0) {\n                        output[b] = 0;\n                    } else if (background_alpha == 255) {\n                        output[b] = FAST_DIV255(foreground_alpha * foreground[b] + (255 - foreground_alpha) * background[b]);\n                    } else {\n                        output[b] = (255 * foreground_alpha * foreground[b] + (255 - foreground_alpha) * background_alpha * background[b]) / (255 * output_alpha);\n                    }\n                }\n                output[b] = output_alpha;\n                memcpy(background, output, s->bpp);\n            }\n        }\n    }\n\n    // Copy blended buffer into the frame and free\n    memcpy(p->data[0], buffer, s->image_linesize * s->height);\n    av_free(buffer);\n\n    return 0;\n}\n\nstatic int decode_frame_common(AVCodecContext *avctx, PNGDecContext *s,\n                               AVFrame *p, AVPacket *avpkt)\n{\n    AVDictionary *metadata  = NULL;\n    uint32_t tag, length;\n    int decode_next_dat = 0;\n    int ret;\n\n    for (;;) {\n        length = bytestream2_get_bytes_left(&s->gb);\n        if (length <= 0) {\n\n            if (avctx->codec_id == AV_CODEC_ID_PNG &&\n                avctx->skip_frame == AVDISCARD_ALL) {\n                av_frame_set_metadata(p, metadata);\n                return 0;\n            }\n\n            if (CONFIG_APNG_DECODER && avctx->codec_id == AV_CODEC_ID_APNG && length == 0) {\n                if (!(s->state & PNG_IDAT))\n                    return 0;\n                else\n                    goto exit_loop;\n            }\n            av_log(avctx, AV_LOG_ERROR, \"%d bytes left\\n\", length);\n            if (   s->state & PNG_ALLIMAGE\n                && avctx->strict_std_compliance <= FF_COMPLIANCE_NORMAL)\n                goto exit_loop;\n            ret = AVERROR_INVALIDDATA;\n            goto fail;\n        }\n\n        length = bytestream2_get_be32(&s->gb);\n        if (length > 0x7fffffff || length > bytestream2_get_bytes_left(&s->gb)) {\n            av_log(avctx, AV_LOG_ERROR, \"chunk too big\\n\");\n            ret = AVERROR_INVALIDDATA;\n            goto fail;\n        }\n        tag = bytestream2_get_le32(&s->gb);\n        if (avctx->debug & FF_DEBUG_STARTCODE)\n            av_log(avctx, AV_LOG_DEBUG, \"png: tag=%c%c%c%c length=%u\\n\",\n                (tag & 0xff),\n                ((tag >> 8) & 0xff),\n                ((tag >> 16) & 0xff),\n                ((tag >> 24) & 0xff), length);\n\n        if (avctx->codec_id == AV_CODEC_ID_PNG &&\n            avctx->skip_frame == AVDISCARD_ALL) {\n            switch(tag) {\n            case MKTAG('I', 'H', 'D', 'R'):\n            case MKTAG('p', 'H', 'Y', 's'):\n            case MKTAG('t', 'E', 'X', 't'):\n            case MKTAG('I', 'D', 'A', 'T'):\n            case MKTAG('t', 'R', 'N', 'S'):\n                break;\n            default:\n                goto skip_tag;\n            }\n        }\n\n        switch (tag) {\n        case MKTAG('I', 'H', 'D', 'R'):\n            if ((ret = decode_ihdr_chunk(avctx, s, length)) < 0)\n                goto fail;\n            break;\n        case MKTAG('p', 'H', 'Y', 's'):\n            if ((ret = decode_phys_chunk(avctx, s)) < 0)\n                goto fail;\n            break;\n        case MKTAG('f', 'c', 'T', 'L'):\n            if (!CONFIG_APNG_DECODER || avctx->codec_id != AV_CODEC_ID_APNG)\n                goto skip_tag;\n            if ((ret = decode_fctl_chunk(avctx, s, length)) < 0)\n                goto fail;\n            decode_next_dat = 1;\n            break;\n        case MKTAG('f', 'd', 'A', 'T'):\n            if (!CONFIG_APNG_DECODER || avctx->codec_id != AV_CODEC_ID_APNG)\n                goto skip_tag;\n            if (!decode_next_dat) {\n                ret = AVERROR_INVALIDDATA;\n                goto fail;\n            }\n            bytestream2_get_be32(&s->gb);\n            length -= 4;\n            /* fallthrough */\n        case MKTAG('I', 'D', 'A', 'T'):\n            if (CONFIG_APNG_DECODER && avctx->codec_id == AV_CODEC_ID_APNG && !decode_next_dat)\n                goto skip_tag;\n            if ((ret = decode_idat_chunk(avctx, s, length, p)) < 0)\n                goto fail;\n            break;\n        case MKTAG('P', 'L', 'T', 'E'):\n            if (decode_plte_chunk(avctx, s, length) < 0)\n                goto skip_tag;\n            break;\n        case MKTAG('t', 'R', 'N', 'S'):\n            if (decode_trns_chunk(avctx, s, length) < 0)\n                goto skip_tag;\n            break;\n        case MKTAG('t', 'E', 'X', 't'):\n            if (decode_text_chunk(s, length, 0, &metadata) < 0)\n                av_log(avctx, AV_LOG_WARNING, \"Broken tEXt chunk\\n\");\n            bytestream2_skip(&s->gb, length + 4);\n            break;\n        case MKTAG('z', 'T', 'X', 't'):\n            if (decode_text_chunk(s, length, 1, &metadata) < 0)\n                av_log(avctx, AV_LOG_WARNING, \"Broken zTXt chunk\\n\");\n            bytestream2_skip(&s->gb, length + 4);\n            break;\n        case MKTAG('s', 'T', 'E', 'R'): {\n            int mode = bytestream2_get_byte(&s->gb);\n            AVStereo3D *stereo3d = av_stereo3d_create_side_data(p);\n            if (!stereo3d)\n                goto fail;\n\n            if (mode == 0 || mode == 1) {\n                stereo3d->type  = AV_STEREO3D_SIDEBYSIDE;\n                stereo3d->flags = mode ? 0 : AV_STEREO3D_FLAG_INVERT;\n            } else {\n                 av_log(avctx, AV_LOG_WARNING,\n                        \"Unknown value in sTER chunk (%d)\\n\", mode);\n            }\n            bytestream2_skip(&s->gb, 4); /* crc */\n            break;\n        }\n        case MKTAG('I', 'E', 'N', 'D'):\n            if (!(s->state & PNG_ALLIMAGE))\n                av_log(avctx, AV_LOG_ERROR, \"IEND without all image\\n\");\n            if (!(s->state & (PNG_ALLIMAGE|PNG_IDAT))) {\n                ret = AVERROR_INVALIDDATA;\n                goto fail;\n            }\n            bytestream2_skip(&s->gb, 4); /* crc */\n            goto exit_loop;\n        default:\n            /* skip tag */\nskip_tag:\n            bytestream2_skip(&s->gb, length + 4);\n            break;\n        }\n    }\nexit_loop:\n    if (avctx->codec_id == AV_CODEC_ID_PNG &&\n        avctx->skip_frame == AVDISCARD_ALL) {\n        av_frame_set_metadata(p, metadata);\n        return 0;\n    }\n\n    if (s->bits_per_pixel <= 4)\n        handle_small_bpp(s, p);\n\n    /* apply transparency if needed */\n    if (s->has_trns && s->color_type != PNG_COLOR_TYPE_PALETTE) {\n        size_t byte_depth = s->bit_depth > 8 ? 2 : 1;\n        size_t raw_bpp = s->bpp - byte_depth;\n        unsigned x, y;\n\n        av_assert0(s->bit_depth > 1);\n\n        for (y = 0; y < s->height; ++y) {\n            uint8_t *row = &s->image_buf[s->image_linesize * y];\n\n            /* since we're updating in-place, we have to go from right to left */\n            for (x = s->width; x > 0; --x) {\n                uint8_t *pixel = &row[s->bpp * (x - 1)];\n                memmove(pixel, &row[raw_bpp * (x - 1)], raw_bpp);\n\n                if (!memcmp(pixel, s->transparent_color_be, raw_bpp)) {\n                    memset(&pixel[raw_bpp], 0, byte_depth);\n                } else {\n                    memset(&pixel[raw_bpp], 0xff, byte_depth);\n                }\n            }\n        }\n    }\n\n    /* handle P-frames only if a predecessor frame is available */\n    if (s->last_picture.f->data[0]) {\n        if (   !(avpkt->flags & AV_PKT_FLAG_KEY) && avctx->codec_tag != AV_RL32(\"MPNG\")\n            && s->last_picture.f->width == p->width\n            && s->last_picture.f->height== p->height\n            && s->last_picture.f->format== p->format\n         ) {\n            if (CONFIG_PNG_DECODER && avctx->codec_id != AV_CODEC_ID_APNG)\n                handle_p_frame_png(s, p);\n            else if (CONFIG_APNG_DECODER &&\n                     avctx->codec_id == AV_CODEC_ID_APNG &&\n                     (ret = handle_p_frame_apng(avctx, s, p)) < 0)\n                goto fail;\n        }\n    }\n    ff_thread_report_progress(&s->picture, INT_MAX, 0);\n    ff_thread_report_progress(&s->previous_picture, INT_MAX, 0);\n\n    av_frame_set_metadata(p, metadata);\n    metadata   = NULL;\n    return 0;\n\nfail:\n    av_dict_free(&metadata);\n    ff_thread_report_progress(&s->picture, INT_MAX, 0);\n    ff_thread_report_progress(&s->previous_picture, INT_MAX, 0);\n    return ret;\n}\n\n#if CONFIG_PNG_DECODER\nstatic int decode_frame_png(AVCodecContext *avctx,\n                        void *data, int *got_frame,\n                        AVPacket *avpkt)\n{\n    PNGDecContext *const s = avctx->priv_data;\n    const uint8_t *buf     = avpkt->data;\n    int buf_size           = avpkt->size;\n    AVFrame *p;\n    int64_t sig;\n    int ret;\n\n    ff_thread_release_buffer(avctx, &s->last_picture);\n    FFSWAP(ThreadFrame, s->picture, s->last_picture);\n    p = s->picture.f;\n\n    bytestream2_init(&s->gb, buf, buf_size);\n\n    /* check signature */\n    sig = bytestream2_get_be64(&s->gb);\n    if (sig != PNGSIG &&\n        sig != MNGSIG) {\n        av_log(avctx, AV_LOG_ERROR, \"Invalid PNG signature 0x%08\"PRIX64\".\\n\", sig);\n        return AVERROR_INVALIDDATA;\n    }\n\n    s->y = s->state = s->has_trns = 0;\n\n    /* init the zlib */\n    s->zstream.zalloc = ff_png_zalloc;\n    s->zstream.zfree  = ff_png_zfree;\n    s->zstream.opaque = NULL;\n    ret = inflateInit(&s->zstream);\n    if (ret != Z_OK) {\n        av_log(avctx, AV_LOG_ERROR, \"inflateInit returned error %d\\n\", ret);\n        return AVERROR_EXTERNAL;\n    }\n\n    if ((ret = decode_frame_common(avctx, s, p, avpkt)) < 0)\n        goto the_end;\n\n    if (avctx->skip_frame == AVDISCARD_ALL) {\n        *got_frame = 0;\n        ret = bytestream2_tell(&s->gb);\n        goto the_end;\n    }\n\n    if ((ret = av_frame_ref(data, s->picture.f)) < 0)\n        return ret;\n\n    *got_frame = 1;\n\n    ret = bytestream2_tell(&s->gb);\nthe_end:\n    inflateEnd(&s->zstream);\n    s->crow_buf = NULL;\n    return ret;\n}\n#endif\n\n#if CONFIG_APNG_DECODER\nstatic int decode_frame_apng(AVCodecContext *avctx,\n                        void *data, int *got_frame,\n                        AVPacket *avpkt)\n{\n    PNGDecContext *const s = avctx->priv_data;\n    int ret;\n    AVFrame *p;\n\n    ff_thread_release_buffer(avctx, &s->last_picture);\n    FFSWAP(ThreadFrame, s->picture, s->last_picture);\n    p = s->picture.f;\n\n    if (!(s->state & PNG_IHDR)) {\n        if (!avctx->extradata_size)\n            return AVERROR_INVALIDDATA;\n\n        /* only init fields, there is no zlib use in extradata */\n        s->zstream.zalloc = ff_png_zalloc;\n        s->zstream.zfree  = ff_png_zfree;\n\n        bytestream2_init(&s->gb, avctx->extradata, avctx->extradata_size);\n        if ((ret = decode_frame_common(avctx, s, p, avpkt)) < 0)\n            goto end;\n    }\n\n    /* reset state for a new frame */\n    if ((ret = inflateInit(&s->zstream)) != Z_OK) {\n        av_log(avctx, AV_LOG_ERROR, \"inflateInit returned error %d\\n\", ret);\n        ret = AVERROR_EXTERNAL;\n        goto end;\n    }\n    s->y = 0;\n    s->state &= ~(PNG_IDAT | PNG_ALLIMAGE);\n    bytestream2_init(&s->gb, avpkt->data, avpkt->size);\n    if ((ret = decode_frame_common(avctx, s, p, avpkt)) < 0)\n        goto end;\n\n    if (!(s->state & PNG_ALLIMAGE))\n        av_log(avctx, AV_LOG_WARNING, \"Frame did not contain a complete image\\n\");\n    if (!(s->state & (PNG_ALLIMAGE|PNG_IDAT))) {\n        ret = AVERROR_INVALIDDATA;\n        goto end;\n    }\n    if ((ret = av_frame_ref(data, s->picture.f)) < 0)\n        goto end;\n\n    *got_frame = 1;\n    ret = bytestream2_tell(&s->gb);\n\nend:\n    inflateEnd(&s->zstream);\n    return ret;\n}\n#endif\n\n#if HAVE_THREADS\nstatic int update_thread_context(AVCodecContext *dst, const AVCodecContext *src)\n{\n    PNGDecContext *psrc = src->priv_data;\n    PNGDecContext *pdst = dst->priv_data;\n    int ret;\n\n    if (dst == src)\n        return 0;\n\n    ff_thread_release_buffer(dst, &pdst->picture);\n    if (psrc->picture.f->data[0] &&\n        (ret = ff_thread_ref_frame(&pdst->picture, &psrc->picture)) < 0)\n        return ret;\n    if (CONFIG_APNG_DECODER && dst->codec_id == AV_CODEC_ID_APNG) {\n        pdst->width             = psrc->width;\n        pdst->height            = psrc->height;\n        pdst->bit_depth         = psrc->bit_depth;\n        pdst->color_type        = psrc->color_type;\n        pdst->compression_type  = psrc->compression_type;\n        pdst->interlace_type    = psrc->interlace_type;\n        pdst->filter_type       = psrc->filter_type;\n        pdst->cur_w = psrc->cur_w;\n        pdst->cur_h = psrc->cur_h;\n        pdst->x_offset = psrc->x_offset;\n        pdst->y_offset = psrc->y_offset;\n        pdst->has_trns = psrc->has_trns;\n        memcpy(pdst->transparent_color_be, psrc->transparent_color_be, sizeof(pdst->transparent_color_be));\n\n        pdst->dispose_op = psrc->dispose_op;\n\n        memcpy(pdst->palette, psrc->palette, sizeof(pdst->palette));\n\n        pdst->state |= psrc->state & (PNG_IHDR | PNG_PLTE);\n\n        ff_thread_release_buffer(dst, &pdst->last_picture);\n        if (psrc->last_picture.f->data[0] &&\n            (ret = ff_thread_ref_frame(&pdst->last_picture, &psrc->last_picture)) < 0)\n            return ret;\n\n        ff_thread_release_buffer(dst, &pdst->previous_picture);\n        if (psrc->previous_picture.f->data[0] &&\n            (ret = ff_thread_ref_frame(&pdst->previous_picture, &psrc->previous_picture)) < 0)\n            return ret;\n    }\n\n    return 0;\n}\n#endif\n\nstatic av_cold int png_dec_init(AVCodecContext *avctx)\n{\n    PNGDecContext *s = avctx->priv_data;\n\n    avctx->color_range = AVCOL_RANGE_JPEG;\n\n    s->avctx = avctx;\n    s->previous_picture.f = av_frame_alloc();\n    s->last_picture.f = av_frame_alloc();\n    s->picture.f = av_frame_alloc();\n    if (!s->previous_picture.f || !s->last_picture.f || !s->picture.f) {\n        av_frame_free(&s->previous_picture.f);\n        av_frame_free(&s->last_picture.f);\n        av_frame_free(&s->picture.f);\n        return AVERROR(ENOMEM);\n    }\n\n    if (!avctx->internal->is_copy) {\n        avctx->internal->allocate_progress = 1;\n        ff_pngdsp_init(&s->dsp);\n    }\n\n    return 0;\n}\n\nstatic av_cold int png_dec_end(AVCodecContext *avctx)\n{\n    PNGDecContext *s = avctx->priv_data;\n\n    ff_thread_release_buffer(avctx, &s->previous_picture);\n    av_frame_free(&s->previous_picture.f);\n    ff_thread_release_buffer(avctx, &s->last_picture);\n    av_frame_free(&s->last_picture.f);\n    ff_thread_release_buffer(avctx, &s->picture);\n    av_frame_free(&s->picture.f);\n    av_freep(&s->buffer);\n    s->buffer_size = 0;\n    av_freep(&s->last_row);\n    s->last_row_size = 0;\n    av_freep(&s->tmp_row);\n    s->tmp_row_size = 0;\n\n    return 0;\n}\n\n#if CONFIG_APNG_DECODER\nAVCodec ff_apng_decoder = {\n    .name           = \"apng\",\n    .long_name      = NULL_IF_CONFIG_SMALL(\"APNG (Animated Portable Network Graphics) image\"),\n    .type           = AVMEDIA_TYPE_VIDEO,\n    .id             = AV_CODEC_ID_APNG,\n    .priv_data_size = sizeof(PNGDecContext),\n    .init           = png_dec_init,\n    .close          = png_dec_end,\n    .decode         = decode_frame_apng,\n    .init_thread_copy = ONLY_IF_THREADS_ENABLED(png_dec_init),\n    .update_thread_context = ONLY_IF_THREADS_ENABLED(update_thread_context),\n    .capabilities   = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_FRAME_THREADS /*| AV_CODEC_CAP_DRAW_HORIZ_BAND*/,\n};\n#endif\n\n#if CONFIG_PNG_DECODER\nAVCodec ff_png_decoder = {\n    .name           = \"png\",\n    .long_name      = NULL_IF_CONFIG_SMALL(\"PNG (Portable Network Graphics) image\"),\n    .type           = AVMEDIA_TYPE_VIDEO,\n    .id             = AV_CODEC_ID_PNG,\n    .priv_data_size = sizeof(PNGDecContext),\n    .init           = png_dec_init,\n    .close          = png_dec_end,\n    .decode         = decode_frame_png,\n    .init_thread_copy = ONLY_IF_THREADS_ENABLED(png_dec_init),\n    .update_thread_context = ONLY_IF_THREADS_ENABLED(update_thread_context),\n    .capabilities   = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_FRAME_THREADS /*| AV_CODEC_CAP_DRAW_HORIZ_BAND*/,\n    .caps_internal  = FF_CODEC_CAP_SKIP_FRAME_FILL_PARAM,\n};\n#endif\n"], "filenames": ["libavcodec/pngdec.c"], "buggy_code_start_loc": [774], "buggy_code_end_loc": [1244], "fixing_code_start_loc": [775], "fixing_code_end_loc": [1258], "type": "CWE-787", "message": "FFmpeg before 2017-02-04 has an out-of-bounds write caused by a heap-based buffer overflow related to the decode_frame_common function in libavcodec/pngdec.c.", "other": {"cve": {"id": "CVE-2017-7863", "sourceIdentifier": "cve@mitre.org", "published": "2017-04-14T04:59:00.507", "lastModified": "2019-03-04T21:12:58.597", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "FFmpeg before 2017-02-04 has an out-of-bounds write caused by a heap-based buffer overflow related to the decode_frame_common function in libavcodec/pngdec.c."}, {"lang": "es", "value": "FFmpeg en versiones anteriores a 04-02-2017 tiene una escritura fuera de l\u00edmites provocado por un desbordamiento de b\u00fafer basado en memoria din\u00e1mica en relaci\u00f3n con la funci\u00f3n decode_frame_common en libavcodec/pngdec.c"}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": true, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.8.10", "matchCriteriaId": "E0E1F413-9BBA-4CDD-8162-0E550316B36A"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}]}]}], "references": [{"url": "http://www.securityfocus.com/bid/97675", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=546", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/FFmpeg/FFmpeg/commit/e477f09d0b3619f3d29173b2cd593e17e2d1978e", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2019/02/msg00005.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/FFmpeg/FFmpeg/commit/e477f09d0b3619f3d29173b2cd593e17e2d1978e"}}