{"buggy_code": ["<?php\n/**\n * Security Component\n *\n * PHP versions 4 and 5\n *\n * CakePHP(tm) : Rapid Development Framework (http://cakephp.org)\n * Copyright 2005-2010, Cake Software Foundation, Inc. (http://cakefoundation.org)\n *\n * Licensed under The MIT License\n * Redistributions of files must retain the above copyright notice.\n *\n * @copyright     Copyright 2005-2010, Cake Software Foundation, Inc. (http://cakefoundation.org)\n * @link          http://cakephp.org CakePHP(tm) Project\n * @package       cake\n * @subpackage    cake.cake.libs.controller.components\n * @since         CakePHP(tm) v 0.10.8.2156\n * @license       MIT License (http://www.opensource.org/licenses/mit-license.php)\n */\nApp::import('Core', array('String', 'Security'));\n\n/**\n * SecurityComponent\n *\n * @package       cake\n * @subpackage    cake.cake.libs.controller.components\n * @link http://book.cakephp.org/view/1296/Security-Component\n */\nclass SecurityComponent extends Object {\n\n/**\n * The controller method that will be called if this request is black-hole'd\n *\n * @var string\n * @access public\n */\n\tvar $blackHoleCallback = null;\n\n/**\n * List of controller actions for which a POST request is required\n *\n * @var array\n * @access public\n * @see SecurityComponent::requirePost()\n */\n\tvar $requirePost = array();\n\n/**\n * List of controller actions for which a GET request is required\n *\n * @var array\n * @access public\n * @see SecurityComponent::requireGet()\n */\n\tvar $requireGet = array();\n\n/**\n * List of controller actions for which a PUT request is required\n *\n * @var array\n * @access public\n * @see SecurityComponent::requirePut()\n */\n\tvar $requirePut = array();\n\n/**\n * List of controller actions for which a DELETE request is required\n *\n * @var array\n * @access public\n * @see SecurityComponent::requireDelete()\n */\n\tvar $requireDelete = array();\n\n/**\n * List of actions that require an SSL-secured connection\n *\n * @var array\n * @access public\n * @see SecurityComponent::requireSecure()\n */\n\tvar $requireSecure = array();\n\n/**\n * List of actions that require a valid authentication key\n *\n * @var array\n * @access public\n * @see SecurityComponent::requireAuth()\n */\n\tvar $requireAuth = array();\n\n/**\n * List of actions that require an HTTP-authenticated login (basic or digest)\n *\n * @var array\n * @access public\n * @see SecurityComponent::requireLogin()\n */\n\tvar $requireLogin = array();\n\n/**\n * Login options for SecurityComponent::requireLogin()\n *\n * @var array\n * @access public\n * @see SecurityComponent::requireLogin()\n */\n\tvar $loginOptions = array('type' => '', 'prompt' => null);\n\n/**\n * An associative array of usernames/passwords used for HTTP-authenticated logins.\n *\n * @var array\n * @access public\n * @see SecurityComponent::requireLogin()\n */\n\tvar $loginUsers = array();\n\n/**\n * Controllers from which actions of the current controller are allowed to receive\n * requests.\n *\n * @var array\n * @access public\n * @see SecurityComponent::requireAuth()\n */\n\tvar $allowedControllers = array();\n\n/**\n * Actions from which actions of the current controller are allowed to receive\n * requests.\n *\n * @var array\n * @access public\n * @see SecurityComponent::requireAuth()\n */\n\tvar $allowedActions = array();\n\n/**\n * Form fields to disable\n *\n * @var array\n * @access public\n */\n\tvar $disabledFields = array();\n\n/**\n * Whether to validate POST data.  Set to false to disable for data coming from 3rd party\n * services, etc.\n *\n * @var boolean\n * @access public\n */\n\tvar $validatePost = true;\n\n/**\n * Other components used by the Security component\n *\n * @var array\n * @access public\n */\n\tvar $components = array('RequestHandler', 'Session');\n\n/**\n * Holds the current action of the controller\n *\n * @var string\n */\n\tvar $_action = null;\n\n/**\n * Initialize the SecurityComponent\n *\n * @param object $controller Controller instance for the request\n * @param array $settings Settings to set to the component\n * @return void\n * @access public\n */\n\tfunction initialize(&$controller, $settings = array()) {\n\t\t$this->_set($settings);\n\t}\n\n/**\n * Component startup. All security checking happens here.\n *\n * @param object $controller Instantiating controller\n * @return void\n * @access public\n */\n\tfunction startup(&$controller) {\n\t\t$this->_action = strtolower($controller->action);\n\t\t$this->_methodsRequired($controller);\n\t\t$this->_secureRequired($controller);\n\t\t$this->_authRequired($controller);\n\t\t$this->_loginRequired($controller);\n\n\t\t$isPost = ($this->RequestHandler->isPost() || $this->RequestHandler->isPut());\n\t\t$isRequestAction = (\n\t\t\t!isset($controller->params['requested']) ||\n\t\t\t$controller->params['requested'] != 1\n\t\t);\n\n\t\tif ($isPost && $isRequestAction && $this->validatePost) {\n\t\t\tif ($this->_validatePost($controller) === false) {\n\t\t\t\tif (!$this->blackHole($controller, 'auth')) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t$this->_generateToken($controller);\n\t}\n\n/**\n * Sets the actions that require a POST request, or empty for all actions\n *\n * @return void\n * @access public\n * @link http://book.cakephp.org/view/1299/requirePost\n */\n\tfunction requirePost() {\n\t\t$args = func_get_args();\n\t\t$this->_requireMethod('Post', $args);\n\t}\n\n/**\n * Sets the actions that require a GET request, or empty for all actions\n *\n * @return void\n * @access public\n */\n\tfunction requireGet() {\n\t\t$args = func_get_args();\n\t\t$this->_requireMethod('Get', $args);\n\t}\n\n/**\n * Sets the actions that require a PUT request, or empty for all actions\n *\n * @return void\n * @access public\n */\n\tfunction requirePut() {\n\t\t$args = func_get_args();\n\t\t$this->_requireMethod('Put', $args);\n\t}\n\n/**\n * Sets the actions that require a DELETE request, or empty for all actions\n *\n * @return void\n * @access public\n */\n\tfunction requireDelete() {\n\t\t$args = func_get_args();\n\t\t$this->_requireMethod('Delete', $args);\n\t}\n\n/**\n * Sets the actions that require a request that is SSL-secured, or empty for all actions\n *\n * @return void\n * @access public\n * @link http://book.cakephp.org/view/1300/requireSecure\n */\n\tfunction requireSecure() {\n\t\t$args = func_get_args();\n\t\t$this->_requireMethod('Secure', $args);\n\t}\n\n/**\n * Sets the actions that require an authenticated request, or empty for all actions\n *\n * @return void\n * @access public\n * @link http://book.cakephp.org/view/1301/requireAuth\n */\n\tfunction requireAuth() {\n\t\t$args = func_get_args();\n\t\t$this->_requireMethod('Auth', $args);\n\t}\n\n/**\n * Sets the actions that require an HTTP-authenticated request, or empty for all actions\n *\n * @return void\n * @access public\n * @link http://book.cakephp.org/view/1302/requireLogin\n */\n\tfunction requireLogin() {\n\t\t$args = func_get_args();\n\t\t$base = $this->loginOptions;\n\n\t\tforeach ($args as $i => $arg) {\n\t\t\tif (is_array($arg)) {\n\t\t\t\t$this->loginOptions = $arg;\n\t\t\t\tunset($args[$i]);\n\t\t\t}\n\t\t}\n\t\t$this->loginOptions = array_merge($base, $this->loginOptions);\n\t\t$this->_requireMethod('Login', $args);\n\n\t\tif (isset($this->loginOptions['users'])) {\n\t\t\t$this->loginUsers =& $this->loginOptions['users'];\n\t\t}\n\t}\n\n/**\n * Attempts to validate the login credentials for an HTTP-authenticated request\n *\n * @param string $type Either 'basic', 'digest', or null. If null/empty, will try both.\n * @return mixed If successful, returns an array with login name and password, otherwise null.\n * @access public\n * @link http://book.cakephp.org/view/1303/loginCredentials-string-type\n */\n\tfunction loginCredentials($type = null) {\n\t\tswitch (strtolower($type)) {\n\t\t\tcase 'basic':\n\t\t\t\t$login = array('username' => env('PHP_AUTH_USER'), 'password' => env('PHP_AUTH_PW'));\n\t\t\t\tif (!empty($login['username'])) {\n\t\t\t\t\treturn $login;\n\t\t\t\t}\n\t\t\tbreak;\n\t\t\tcase 'digest':\n\t\t\tdefault:\n\t\t\t\t$digest = null;\n\n\t\t\t\tif (version_compare(PHP_VERSION, '5.1') != -1) {\n\t\t\t\t\t$digest = env('PHP_AUTH_DIGEST');\n\t\t\t\t} elseif (function_exists('apache_request_headers')) {\n\t\t\t\t\t$headers = apache_request_headers();\n\t\t\t\t\tif (isset($headers['Authorization']) && !empty($headers['Authorization']) && substr($headers['Authorization'], 0, 7) == 'Digest ') {\n\t\t\t\t\t\t$digest = substr($headers['Authorization'], 7);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// Server doesn't support digest-auth headers\n\t\t\t\t\ttrigger_error(__('SecurityComponent::loginCredentials() - Server does not support digest authentication', true), E_USER_WARNING);\n\t\t\t\t}\n\n\t\t\t\tif (!empty($digest)) {\n\t\t\t\t\treturn $this->parseDigestAuthData($digest);\n\t\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\treturn null;\n\t}\n\n/**\n * Generates the text of an HTTP-authentication request header from an array of options.\n *\n * @param array $options Set of options for header\n * @return string HTTP-authentication request header\n * @access public\n * @link http://book.cakephp.org/view/1304/loginRequest-array-options\n */\n\tfunction loginRequest($options = array()) {\n\t\t$options = array_merge($this->loginOptions, $options);\n\t\t$this->_setLoginDefaults($options);\n\t\t$auth = 'WWW-Authenticate: ' . ucfirst($options['type']);\n\t\t$out = array('realm=\"' . $options['realm'] . '\"');\n\n\t\tif (strtolower($options['type']) == 'digest') {\n\t\t\t$out[] = 'qop=\"auth\"';\n\t\t\t$out[] = 'nonce=\"' . uniqid(\"\") . '\"';\n\t\t\t$out[] = 'opaque=\"' . md5($options['realm']) . '\"';\n\t\t}\n\n\t\treturn $auth . ' ' . implode(',', $out);\n\t}\n\n/**\n * Parses an HTTP digest authentication response, and returns an array of the data, or null on failure.\n *\n * @param string $digest Digest authentication response\n * @return array Digest authentication parameters\n * @access public\n * @link http://book.cakephp.org/view/1305/parseDigestAuthData-string-digest\n */\n\tfunction parseDigestAuthData($digest) {\n\t\tif (substr($digest, 0, 7) == 'Digest ') {\n\t\t\t$digest = substr($digest, 7);\n\t\t}\n\t\t$keys = array();\n\t\t$match = array();\n\t\t$req = array('nonce' => 1, 'nc' => 1, 'cnonce' => 1, 'qop' => 1, 'username' => 1, 'uri' => 1, 'response' => 1);\n\t\tpreg_match_all('/(\\w+)=([\\'\"]?)([a-zA-Z0-9@=.\\/_-]+)\\2/', $digest, $match, PREG_SET_ORDER);\n\n\t\tforeach ($match as $i) {\n\t\t\t$keys[$i[1]] = $i[3];\n\t\t\tunset($req[$i[1]]);\n\t\t}\n\n\t\tif (empty($req)) {\n\t\t\treturn $keys;\n\t\t}\n\t\treturn null;\n\t}\n\n/**\n * Generates a hash to be compared with an HTTP digest-authenticated response\n *\n * @param array $data HTTP digest response data, as parsed by SecurityComponent::parseDigestAuthData()\n * @return string Digest authentication hash\n * @access public\n * @see SecurityComponent::parseDigestAuthData()\n * @link http://book.cakephp.org/view/1306/generateDigestResponseHash-array-data\n */\n\tfunction generateDigestResponseHash($data) {\n\t\treturn md5(\n\t\t\tmd5($data['username'] . ':' . $this->loginOptions['realm'] . ':' . $this->loginUsers[$data['username']]) .\n\t\t\t':' . $data['nonce'] . ':' . $data['nc'] . ':' . $data['cnonce'] . ':' . $data['qop'] . ':' .\n\t\t\tmd5(env('REQUEST_METHOD') . ':' . $data['uri'])\n\t\t);\n\t}\n\n/**\n * Black-hole an invalid request with a 404 error or custom callback. If SecurityComponent::$blackHoleCallback\n * is specified, it will use this callback by executing the method indicated in $error\n *\n * @param object $controller Instantiating controller\n * @param string $error Error method\n * @return mixed If specified, controller blackHoleCallback's response, or no return otherwise\n * @access public\n * @see SecurityComponent::$blackHoleCallback\n * @link http://book.cakephp.org/view/1307/blackHole-object-controller-string-error\n */\n\tfunction blackHole(&$controller, $error = '') {\n\t\tif ($this->blackHoleCallback == null) {\n\t\t\t$code = 404;\n\t\t\tif ($error == 'login') {\n\t\t\t\t$code = 401;\n\t\t\t\t$controller->header($this->loginRequest());\n\t\t\t}\n\t\t\t$controller->redirect(null, $code, true);\n\t\t} else {\n\t\t\treturn $this->_callback($controller, $this->blackHoleCallback, array($error));\n\t\t}\n\t}\n\n/**\n * Sets the actions that require a $method HTTP request, or empty for all actions\n *\n * @param string $method The HTTP method to assign controller actions to\n * @param array $actions Controller actions to set the required HTTP method to.\n * @return void\n * @access protected\n */\n\tfunction _requireMethod($method, $actions = array()) {\n\t\tif (isset($actions[0]) && is_array($actions[0])) {\n\t\t\t$actions = $actions[0];\n\t\t}\n\t\t$this->{'require' . $method} = (empty($actions)) ? array('*'): $actions;\n\t}\n\n/**\n * Check if HTTP methods are required\n *\n * @param object $controller Instantiating controller\n * @return bool true if $method is required\n * @access protected\n */\n\tfunction _methodsRequired(&$controller) {\n\t\tforeach (array('Post', 'Get', 'Put', 'Delete') as $method) {\n\t\t\t$property = 'require' . $method;\n\t\t\tif (is_array($this->$property) && !empty($this->$property)) {\n\t\t\t\t$require = array_map('strtolower', $this->$property);\n\n\t\t\t\tif (in_array($this->_action, $require) || $this->$property == array('*')) {\n\t\t\t\t\tif (!$this->RequestHandler->{'is' . $method}()) {\n\t\t\t\t\t\tif (!$this->blackHole($controller, strtolower($method))) {\n\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n/**\n * Check if access requires secure connection\n *\n * @param object $controller Instantiating controller\n * @return bool true if secure connection required\n * @access protected\n */\n\tfunction _secureRequired(&$controller) {\n\t\tif (is_array($this->requireSecure) && !empty($this->requireSecure)) {\n\t\t\t$requireSecure = array_map('strtolower', $this->requireSecure);\n\n\t\t\tif (in_array($this->_action, $requireSecure) || $this->requireSecure == array('*')) {\n\t\t\t\tif (!$this->RequestHandler->isSSL()) {\n\t\t\t\t\tif (!$this->blackHole($controller, 'secure')) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n/**\n * Check if authentication is required\n *\n * @param object $controller Instantiating controller\n * @return bool true if authentication required\n * @access protected\n */\n\tfunction _authRequired(&$controller) {\n\t\tif (is_array($this->requireAuth) && !empty($this->requireAuth) && !empty($controller->data)) {\n\t\t\t$requireAuth = array_map('strtolower', $this->requireAuth);\n\n\t\t\tif (in_array($this->_action, $requireAuth) || $this->requireAuth == array('*')) {\n\t\t\t\tif (!isset($controller->data['_Token'] )) {\n\t\t\t\t\tif (!$this->blackHole($controller, 'auth')) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif ($this->Session->check('_Token')) {\n\t\t\t\t\t$tData = unserialize($this->Session->read('_Token'));\n\n\t\t\t\t\tif (!empty($tData['allowedControllers']) && !in_array($controller->params['controller'], $tData['allowedControllers']) || !empty($tData['allowedActions']) && !in_array($controller->params['action'], $tData['allowedActions'])) {\n\t\t\t\t\t\tif (!$this->blackHole($controller, 'auth')) {\n\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (!$this->blackHole($controller, 'auth')) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n/**\n * Check if login is required\n *\n * @param object $controller Instantiating controller\n * @return bool true if login is required\n * @access protected\n */\n\tfunction _loginRequired(&$controller) {\n\t\tif (is_array($this->requireLogin) && !empty($this->requireLogin)) {\n\t\t\t$requireLogin = array_map('strtolower', $this->requireLogin);\n\n\t\t\tif (in_array($this->_action, $requireLogin) || $this->requireLogin == array('*')) {\n\t\t\t\t$login = $this->loginCredentials($this->loginOptions['type']);\n\n\t\t\t\tif ($login == null) {\n\t\t\t\t\t$controller->header($this->loginRequest());\n\n\t\t\t\t\tif (!empty($this->loginOptions['prompt'])) {\n\t\t\t\t\t\t$this->_callback($controller, $this->loginOptions['prompt']);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$this->blackHole($controller, 'login');\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (isset($this->loginOptions['login'])) {\n\t\t\t\t\t\t$this->_callback($controller, $this->loginOptions['login'], array($login));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (strtolower($this->loginOptions['type']) == 'digest') {\n\t\t\t\t\t\t\tif ($login && isset($this->loginUsers[$login['username']])) {\n\t\t\t\t\t\t\t\tif ($login['response'] == $this->generateDigestResponseHash($login)) {\n\t\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t$this->blackHole($controller, 'login');\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t!(in_array($login['username'], array_keys($this->loginUsers)) &&\n\t\t\t\t\t\t\t\t$this->loginUsers[$login['username']] == $login['password'])\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t$this->blackHole($controller, 'login');\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n/**\n * Validate submitted form\n *\n * @param object $controller Instantiating controller\n * @return bool true if submitted form is valid\n * @access protected\n */\n\tfunction _validatePost(&$controller) {\n\t\tif (empty($controller->data)) {\n\t\t\treturn true;\n\t\t}\n\t\t$data = $controller->data;\n\n\t\tif (!isset($data['_Token']) || !isset($data['_Token']['fields']) || !isset($data['_Token']['key'])) {\n\t\t\treturn false;\n\t\t}\n\t\t$token = $data['_Token']['key'];\n\n\t\tif ($this->Session->check('_Token')) {\n\t\t\t$tokenData = unserialize($this->Session->read('_Token'));\n\n\t\t\tif ($tokenData['expires'] < time() || $tokenData['key'] !== $token) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t$locked = null;\n\t\t$check = $controller->data;\n\t\t$token = urldecode($check['_Token']['fields']);\n\n\t\tif (strpos($token, ':')) {\n\t\t\tlist($token, $locked) = explode(':', $token, 2);\n\t\t}\n\t\tunset($check['_Token']);\n\n\t\t$lockedFields = array();\n\t\t$fields = Set::flatten($check);\n\t\t$fieldList = array_keys($fields);\n\t\t$locked = unserialize(str_rot13($locked));\n\t\t$multi = array();\n\n\t\tforeach ($fieldList as $i => $key) {\n\t\t\tif (preg_match('/\\.\\d+$/', $key)) {\n\t\t\t\t$multi[$i] = preg_replace('/\\.\\d+$/', '', $key);\n\t\t\t\tunset($fieldList[$i]);\n\t\t\t}\n\t\t}\n\t\tif (!empty($multi)) {\n\t\t\t$fieldList += array_unique($multi);\n\t\t}\n\n\t\tforeach ($fieldList as $i => $key) {\n\t\t\t$isDisabled = false;\n\t\t\t$isLocked = (is_array($locked) && in_array($key, $locked));\n\n\t\t\tif (!empty($this->disabledFields)) {\n\t\t\t\tforeach ((array)$this->disabledFields as $disabled) {\n\t\t\t\t\t$disabled = explode('.', $disabled);\n\t\t\t\t\t$field = array_values(array_intersect(explode('.', $key), $disabled));\n\t\t\t\t\t$isDisabled = ($field === $disabled);\n\t\t\t\t\tif ($isDisabled) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ($isDisabled || $isLocked) {\n\t\t\t\tunset($fieldList[$i]);\n\t\t\t\tif ($isLocked) {\n\t\t\t\t\t$lockedFields[$key] = $fields[$key];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsort($fieldList, SORT_STRING);\n\t\tksort($lockedFields, SORT_STRING);\n\n\t\t$fieldList += $lockedFields;\n\t\t$check = Security::hash(serialize($fieldList) . Configure::read('Security.salt'));\n\t\treturn ($token === $check);\n\t}\n\n/**\n * Add authentication key for new form posts\n *\n * @param object $controller Instantiating controller\n * @return bool Success\n * @access protected\n */\n\tfunction _generateToken(&$controller) {\n\t\tif (isset($controller->params['requested']) && $controller->params['requested'] === 1) {\n\t\t\tif ($this->Session->check('_Token')) {\n\t\t\t\t$tokenData = unserialize($this->Session->read('_Token'));\n\t\t\t\t$controller->params['_Token'] = $tokenData;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\t$authKey = Security::generateAuthKey();\n\t\t$expires = strtotime('+' . Security::inactiveMins() . ' minutes');\n\t\t$token = array(\n\t\t\t'key' => $authKey,\n\t\t\t'expires' => $expires,\n\t\t\t'allowedControllers' => $this->allowedControllers,\n\t\t\t'allowedActions' => $this->allowedActions,\n\t\t\t'disabledFields' => $this->disabledFields\n\t\t);\n\n\t\tif (!isset($controller->data)) {\n\t\t\t$controller->data = array();\n\t\t}\n\n\t\tif ($this->Session->check('_Token')) {\n\t\t\t$tokenData = unserialize($this->Session->read('_Token'));\n\t\t\t$valid = (\n\t\t\t\tisset($tokenData['expires']) &&\n\t\t\t\t$tokenData['expires'] > time() &&\n\t\t\t\tisset($tokenData['key'])\n\t\t\t);\n\n\t\t\tif ($valid) {\n\t\t\t\t$token['key'] = $tokenData['key'];\n\t\t\t}\n\t\t}\n\t\t$controller->params['_Token'] = $token;\n\t\t$this->Session->write('_Token', serialize($token));\n\t\treturn true;\n\t}\n\n/**\n * Sets the default login options for an HTTP-authenticated request\n *\n * @param array $options Default login options\n * @return void\n * @access protected\n */\n\tfunction _setLoginDefaults(&$options) {\n\t\t$options = array_merge(array(\n\t\t\t'type' => 'basic',\n\t\t\t'realm' => env('SERVER_NAME'),\n\t\t\t'qop' => 'auth',\n\t\t\t'nonce' => String::uuid()\n\t\t), array_filter($options));\n\t\t$options = array_merge(array('opaque' => md5($options['realm'])), $options);\n\t}\n\n/**\n * Calls a controller callback method\n *\n * @param object $controller Controller to run callback on\n * @param string $method Method to execute\n * @param array $params Parameters to send to method\n * @return mixed Controller callback method's response\n * @access protected\n */\n\tfunction _callback(&$controller, $method, $params = array()) {\n\t\tif (is_callable(array($controller, $method))) {\n\t\t\treturn call_user_func_array(array(&$controller, $method), empty($params) ? null : $params);\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n}\n", "<?php\n/**\n * SecurityComponentTest file\n *\n * PHP versions 4 and 5\n *\n * CakePHP(tm) Tests <http://book.cakephp.org/view/1196/Testing>\n * Copyright 2005-2010, Cake Software Foundation, Inc. (http://cakefoundation.org)\n *\n *  Licensed under The Open Group Test Suite License\n *  Redistributions of files must retain the above copyright notice.\n *\n * @copyright     Copyright 2005-2010, Cake Software Foundation, Inc. (http://cakefoundation.org)\n * @link          http://book.cakephp.org/view/1196/Testing CakePHP(tm) Tests\n * @package       cake\n * @subpackage    cake.tests.cases.libs.controller.components\n * @since         CakePHP(tm) v 1.2.0.5435\n * @license       http://www.opensource.org/licenses/opengroup.php The Open Group Test Suite License\n */\nApp::import('Component', 'Security');\n\n/**\n* TestSecurityComponent\n*\n* @package       cake\n* @subpackage    cake.tests.cases.libs.controller.components\n*/\nclass TestSecurityComponent extends SecurityComponent {\n\n/**\n * validatePost method\n *\n * @param Controller $controller\n * @return unknown\n */\n\tfunction validatePost(&$controller) {\n\t\treturn $this->_validatePost($controller);\n\t}\n}\n\n/**\n* SecurityTestController\n*\n* @package       cake\n* @subpackage    cake.tests.cases.libs.controller.components\n*/\nclass SecurityTestController extends Controller {\n\n/**\n * name property\n *\n * @var string 'SecurityTest'\n * @access public\n */\n\tvar $name = 'SecurityTest';\n\n/**\n * components property\n *\n * @var array\n * @access public\n */\n\tvar $components = array('Session', 'TestSecurity');\n\n/**\n * failed property\n *\n * @var bool false\n * @access public\n */\n\tvar $failed = false;\n\n/**\n * Used for keeping track of headers in test\n *\n * @var array\n * @access public\n */\n\tvar $testHeaders = array();\n\n/**\n * fail method\n *\n * @access public\n * @return void\n */\n\tfunction fail() {\n\t\t$this->failed = true;\n\t}\n\n/**\n * redirect method\n *\n * @param mixed $option\n * @param mixed $code\n * @param mixed $exit\n * @access public\n * @return void\n */\n\tfunction redirect($option, $code, $exit) {\n\t\treturn $code;\n\t}\n\n/**\n * Conveinence method for header()\n *\n * @param string $status\n * @return void\n * @access public\n */\n\tfunction header($status) {\n\t\t$this->testHeaders[] = $status;\n\t}\n}\n\n/**\n * SecurityComponentTest class\n *\n * @package       cake\n * @subpackage    cake.tests.cases.libs.controller.components\n */\nclass SecurityComponentTest extends CakeTestCase {\n\n/**\n * Controller property\n *\n * @var SecurityTestController\n * @access public\n */\n\tvar $Controller;\n\n/**\n * oldSalt property\n *\n * @var string\n * @access public\n */\n\tvar $oldSalt;\n\n/**\n * setUp method\n *\n * @access public\n * @return void\n */\n\tfunction startTest() {\n\t\t$this->Controller =& new SecurityTestController();\n\t\t$this->Controller->Component->init($this->Controller);\n\t\t$this->Controller->Security =& $this->Controller->TestSecurity;\n\t\t$this->Controller->Security->blackHoleCallback = 'fail';\n\t\t$this->oldSalt = Configure::read('Security.salt');\n\t\tConfigure::write('Security.salt', 'foo!');\n\t}\n\n/**\n * Tear-down method. Resets environment state.\n *\n * @access public\n * @return void\n */\n\tfunction endTest() {\n\t\tConfigure::write('Security.salt', $this->oldSalt);\n\t\t$this->Controller->Session->delete('_Token');\n\t\tunset($this->Controller->Security);\n\t\tunset($this->Controller->Component);\n\t\tunset($this->Controller);\n\t}\n\n/**\n * test that initalize can set properties.\n *\n * @return void\n */\n\tfunction testInitialize() {\n\t\t$settings = array(\n\t\t\t'requirePost' => array('edit', 'update'),\n\t\t\t'requireSecure' => array('update_account'),\n\t\t\t'requireGet' => array('index'),\n\t\t\t'validatePost' => false,\n\t\t\t'loginUsers' => array(\n\t\t\t\t'mark' => 'password'\n\t\t\t),\n\t\t\t'requireLogin' => array('login'),\n\t\t);\n\t\t$this->Controller->Security->initialize($this->Controller, $settings);\n\t\t$this->assertEqual($this->Controller->Security->requirePost, $settings['requirePost']);\n\t\t$this->assertEqual($this->Controller->Security->requireSecure, $settings['requireSecure']);\n\t\t$this->assertEqual($this->Controller->Security->requireGet, $settings['requireGet']);\n\t\t$this->assertEqual($this->Controller->Security->validatePost, $settings['validatePost']);\n\t\t$this->assertEqual($this->Controller->Security->loginUsers, $settings['loginUsers']);\n\t\t$this->assertEqual($this->Controller->Security->requireLogin, $settings['requireLogin']);\n\t}\n\n/**\n * testStartup method\n *\n * @access public\n * @return void\n */\n\tfunction testStartup() {\n\t\t$this->Controller->Security->startup($this->Controller);\n\t\t$result = $this->Controller->params['_Token']['key'];\n\t\t$this->assertNotNull($result);\n\t\t$this->assertTrue($this->Controller->Session->check('_Token'));\n\t}\n\n/**\n * testRequirePostFail method\n *\n * @access public\n * @return void\n */\n\tfunction testRequirePostFail() {\n\t\t$_SERVER['REQUEST_METHOD'] = 'GET';\n\t\t$this->Controller->action = 'posted';\n\t\t$this->Controller->Security->requirePost(array('posted'));\n\t\t$this->Controller->Security->startup($this->Controller);\n\t\t$this->assertTrue($this->Controller->failed);\n\t}\n\n/**\n * testRequirePostSucceed method\n *\n * @access public\n * @return void\n */\n\tfunction testRequirePostSucceed() {\n\t\t$_SERVER['REQUEST_METHOD'] = 'POST';\n\t\t$this->Controller->action = 'posted';\n\t\t$this->Controller->Security->requirePost('posted');\n\t\t$this->Controller->Security->startup($this->Controller);\n\t\t$this->assertFalse($this->Controller->failed);\n\t}\n\n/**\n * testRequireSecureFail method\n *\n * @access public\n * @return void\n */\n\tfunction testRequireSecureFail() {\n\t\t$_SERVER['HTTPS'] = 'off';\n\t\t$_SERVER['REQUEST_METHOD'] = 'POST';\n\t\t$this->Controller->action = 'posted';\n\t\t$this->Controller->Security->requireSecure(array('posted'));\n\t\t$this->Controller->Security->startup($this->Controller);\n\t\t$this->assertTrue($this->Controller->failed);\n\t}\n\n/**\n * testRequireSecureSucceed method\n *\n * @access public\n * @return void\n */\n\tfunction testRequireSecureSucceed() {\n\t\t$_SERVER['REQUEST_METHOD'] = 'Secure';\n\t\t$this->Controller->action = 'posted';\n\t\t$_SERVER['HTTPS'] = 'on';\n\t\t$this->Controller->Security->requireSecure('posted');\n\t\t$this->Controller->Security->startup($this->Controller);\n\t\t$this->assertFalse($this->Controller->failed);\n\t}\n\n/**\n * testRequireAuthFail method\n *\n * @access public\n * @return void\n */\n\tfunction testRequireAuthFail() {\n\t\t$_SERVER['REQUEST_METHOD'] = 'AUTH';\n\t\t$this->Controller->action = 'posted';\n\t\t$this->Controller->data = array('username' => 'willy', 'password' => 'somePass');\n\t\t$this->Controller->Security->requireAuth(array('posted'));\n\t\t$this->Controller->Security->startup($this->Controller);\n\t\t$this->assertTrue($this->Controller->failed);\n\n\t\t$this->Controller->Session->write('_Token', serialize(array('allowedControllers' => array())));\n\t\t$this->Controller->data = array('username' => 'willy', 'password' => 'somePass');\n\t\t$this->Controller->action = 'posted';\n\t\t$this->Controller->Security->requireAuth('posted');\n\t\t$this->Controller->Security->startup($this->Controller);\n\t\t$this->assertTrue($this->Controller->failed);\n\n\t\t$this->Controller->Session->write('_Token', serialize(array(\n\t\t\t'allowedControllers' => array('SecurityTest'), 'allowedActions' => array('posted2')\n\t\t)));\n\t\t$this->Controller->data = array('username' => 'willy', 'password' => 'somePass');\n\t\t$this->Controller->action = 'posted';\n\t\t$this->Controller->Security->requireAuth('posted');\n\t\t$this->Controller->Security->startup($this->Controller);\n\t\t$this->assertTrue($this->Controller->failed);\n\t}\n\n/**\n * testRequireAuthSucceed method\n *\n * @access public\n * @return void\n */\n\tfunction testRequireAuthSucceed() {\n\t\t$_SERVER['REQUEST_METHOD'] = 'AUTH';\n\t\t$this->Controller->action = 'posted';\n\t\t$this->Controller->Security->requireAuth('posted');\n\t\t$this->Controller->Security->startup($this->Controller);\n\t\t$this->assertFalse($this->Controller->failed);\n\n\t\t$this->Controller->Security->Session->write('_Token', serialize(array(\n\t\t\t'allowedControllers' => array('SecurityTest'), 'allowedActions' => array('posted')\n\t\t)));\n\t\t$this->Controller->params['controller'] = 'SecurityTest';\n\t\t$this->Controller->params['action'] = 'posted';\n\n\t\t$this->Controller->data = array(\n\t\t\t'username' => 'willy', 'password' => 'somePass', '_Token' => ''\n\t\t);\n\t\t$this->Controller->action = 'posted';\n\t\t$this->Controller->Security->requireAuth('posted');\n\t\t$this->Controller->Security->startup($this->Controller);\n\t\t$this->assertFalse($this->Controller->failed);\n\t}\n\n/**\n * testRequirePostSucceedWrongMethod method\n *\n * @access public\n * @return void\n */\n\tfunction testRequirePostSucceedWrongMethod() {\n\t\t$_SERVER['REQUEST_METHOD'] = 'GET';\n\t\t$this->Controller->action = 'getted';\n\t\t$this->Controller->Security->requirePost('posted');\n\t\t$this->Controller->Security->startup($this->Controller);\n\t\t$this->assertFalse($this->Controller->failed);\n\t}\n\n/**\n * testRequireGetFail method\n *\n * @access public\n * @return void\n */\n\tfunction testRequireGetFail() {\n\t\t$_SERVER['REQUEST_METHOD'] = 'POST';\n\t\t$this->Controller->action = 'getted';\n\t\t$this->Controller->Security->requireGet(array('getted'));\n\t\t$this->Controller->Security->startup($this->Controller);\n\t\t$this->assertTrue($this->Controller->failed);\n\t}\n\n/**\n * testRequireGetSucceed method\n *\n * @access public\n * @return void\n */\n\tfunction testRequireGetSucceed() {\n\t\t$_SERVER['REQUEST_METHOD'] = 'GET';\n\t\t$this->Controller->action = 'getted';\n\t\t$this->Controller->Security->requireGet('getted');\n\t\t$this->Controller->Security->startup($this->Controller);\n\t\t$this->assertFalse($this->Controller->failed);\n\t}\n\n/**\n * testRequireLogin method\n *\n * @access public\n * @return void\n */\n\tfunction testRequireLogin() {\n\t\t$this->Controller->action = 'posted';\n\t\t$this->Controller->Security->requireLogin(\n\t\t\t'posted',\n\t\t\tarray('type' => 'basic', 'users' => array('admin' => 'password'))\n\t\t);\n\t\t$_SERVER['PHP_AUTH_USER'] = 'admin';\n\t\t$_SERVER['PHP_AUTH_PW'] = 'password';\n\t\t$this->Controller->Security->startup($this->Controller);\n\t\t$this->assertFalse($this->Controller->failed);\n\n\n\t\t$this->Controller->action = 'posted';\n\t\t$this->Controller->Security->requireLogin(\n\t\t\tarray('posted'),\n\t\t\tarray('type' => 'basic', 'users' => array('admin' => 'password'))\n\t\t);\n\t\t$_SERVER['PHP_AUTH_USER'] = 'admin2';\n\t\t$_SERVER['PHP_AUTH_PW'] = 'password';\n\t\t$this->Controller->Security->startup($this->Controller);\n\t\t$this->assertTrue($this->Controller->failed);\n\n\t\t$this->Controller->action = 'posted';\n\t\t$this->Controller->Security->requireLogin(\n\t\t\t'posted',\n\t\t\tarray('type' => 'basic', 'users' => array('admin' => 'password'))\n\t\t);\n\t\t$_SERVER['PHP_AUTH_USER'] = 'admin';\n\t\t$_SERVER['PHP_AUTH_PW'] = 'password2';\n\t\t$this->Controller->Security->startup($this->Controller);\n\t\t$this->assertTrue($this->Controller->failed);\n\t}\n\n/**\n * testDigestAuth method\n *\n * @access public\n * @return void\n */\n\tfunction testDigestAuth() {\n\t\t$skip = $this->skipIf((version_compare(PHP_VERSION, '5.1') == -1) XOR (!function_exists('apache_request_headers')),\n\t\t\t\"%s Cannot run Digest Auth test for PHP versions < 5.1\"\n\t\t);\n\n\t\tif ($skip) {\n\t\t\treturn;\n\t\t}\n\n\t\t$this->Controller->action = 'posted';\n\t\t$_SERVER['PHP_AUTH_DIGEST'] = $digest = <<<DIGEST\n\t\tDigest username=\"Mufasa\",\n\t\trealm=\"testrealm@host.com\",\n\t\tnonce=\"dcd98b7102dd2f0e8b11d0f600bfb0c093\",\n\t\turi=\"/dir/index.html\",\n\t\tqop=auth,\n\t\tnc=00000001,\n\t\tcnonce=\"0a4f113b\",\n\t\tresponse=\"460d0d3c6867c2f1ab85b1ada1aece48\",\n\t\topaque=\"5ccc069c403ebaf9f0171e9517f40e41\"\nDIGEST;\n\t\t$this->Controller->Security->requireLogin('posted', array(\n\t\t\t'type' => 'digest', 'users' => array('Mufasa' => 'password'),\n\t\t\t'realm' => 'testrealm@host.com'\n\t\t));\n\t\t$this->Controller->Security->startup($this->Controller);\n\t\t$this->assertFalse($this->Controller->failed);\n\t}\n\n/**\n * testRequireGetSucceedWrongMethod method\n *\n * @access public\n * @return void\n */\n\tfunction testRequireGetSucceedWrongMethod() {\n\t\t$_SERVER['REQUEST_METHOD'] = 'POST';\n\t\t$this->Controller->action = 'posted';\n\t\t$this->Controller->Security->requireGet('getted');\n\t\t$this->Controller->Security->startup($this->Controller);\n\t\t$this->assertFalse($this->Controller->failed);\n\t}\n\n/**\n * testRequirePutFail method\n *\n * @access public\n * @return void\n */\n\tfunction testRequirePutFail() {\n\t\t$_SERVER['REQUEST_METHOD'] = 'POST';\n\t\t$this->Controller->action = 'putted';\n\t\t$this->Controller->Security->requirePut(array('putted'));\n\t\t$this->Controller->Security->startup($this->Controller);\n\t\t$this->assertTrue($this->Controller->failed);\n\t}\n\n/**\n * testRequirePutSucceed method\n *\n * @access public\n * @return void\n */\n\tfunction testRequirePutSucceed() {\n\t\t$_SERVER['REQUEST_METHOD'] = 'PUT';\n\t\t$this->Controller->action = 'putted';\n\t\t$this->Controller->Security->requirePut('putted');\n\t\t$this->Controller->Security->startup($this->Controller);\n\t\t$this->assertFalse($this->Controller->failed);\n\t}\n\n/**\n * testRequirePutSucceedWrongMethod method\n *\n * @access public\n * @return void\n */\n\tfunction testRequirePutSucceedWrongMethod() {\n\t\t$_SERVER['REQUEST_METHOD'] = 'POST';\n\t\t$this->Controller->action = 'posted';\n\t\t$this->Controller->Security->requirePut('putted');\n\t\t$this->Controller->Security->startup($this->Controller);\n\t\t$this->assertFalse($this->Controller->failed);\n\t}\n\n/**\n * testRequireDeleteFail method\n *\n * @access public\n * @return void\n */\n\tfunction testRequireDeleteFail() {\n\t\t$_SERVER['REQUEST_METHOD'] = 'POST';\n\t\t$this->Controller->action = 'deleted';\n\t\t$this->Controller->Security->requireDelete(array('deleted', 'other_method'));\n\t\t$this->Controller->Security->startup($this->Controller);\n\t\t$this->assertTrue($this->Controller->failed);\n\t}\n\n/**\n * testRequireDeleteSucceed method\n *\n * @access public\n * @return void\n */\n\tfunction testRequireDeleteSucceed() {\n\t\t$_SERVER['REQUEST_METHOD'] = 'DELETE';\n\t\t$this->Controller->action = 'deleted';\n\t\t$this->Controller->Security->requireDelete('deleted');\n\t\t$this->Controller->Security->startup($this->Controller);\n\t\t$this->assertFalse($this->Controller->failed);\n\t}\n\n/**\n * testRequireDeleteSucceedWrongMethod method\n *\n * @access public\n * @return void\n */\n\tfunction testRequireDeleteSucceedWrongMethod() {\n\t\t$_SERVER['REQUEST_METHOD'] = 'POST';\n\t\t$this->Controller->action = 'posted';\n\t\t$this->Controller->Security->requireDelete('deleted');\n\t\t$this->Controller->Security->startup($this->Controller);\n\t\t$this->assertFalse($this->Controller->failed);\n\t}\n\n/**\n * testRequireLoginSettings method\n *\n * @access public\n * @return void\n */\n\tfunction testRequireLoginSettings() {\n\t\t$this->Controller->Security->requireLogin(\n\t\t\t'add', 'edit',\n\t\t\tarray('type' => 'basic', 'users' => array('admin' => 'password'))\n\t\t);\n\t\t$this->assertEqual($this->Controller->Security->requireLogin, array('add', 'edit'));\n\t\t$this->assertEqual($this->Controller->Security->loginUsers, array('admin' => 'password'));\n\t}\n\n/**\n * testRequireLoginAllActions method\n *\n * @access public\n * @return void\n */\n\tfunction testRequireLoginAllActions() {\n\t\t$this->Controller->Security->requireLogin(\n\t\t\tarray('type' => 'basic', 'users' => array('admin' => 'password'))\n\t\t);\n\t\t$this->assertEqual($this->Controller->Security->requireLogin, array('*'));\n\t\t$this->assertEqual($this->Controller->Security->loginUsers, array('admin' => 'password'));\n\t}\n\n/**\n * Simple hash validation test\n *\n * @access public\n * @return void\n */\n\tfunction testValidatePost() {\n\t\t$this->Controller->Security->startup($this->Controller);\n\t\t$key = $this->Controller->params['_Token']['key'];\n\t\t$fields = 'a5475372b40f6e3ccbf9f8af191f20e1642fd877%3An%3A1%3A%7Bv%3A0%3B';\n\t\t$fields .= 'f%3A11%3A%22Zbqry.inyvq%22%3B%7D';\n\n\t\t$this->Controller->data = array(\n\t\t\t'Model' => array('username' => 'nate', 'password' => 'foo', 'valid' => '0'),\n\t\t\t'_Token' => compact('key', 'fields')\n\t\t);\n\t\t$this->assertTrue($this->Controller->Security->validatePost($this->Controller));\n\t}\n\n/**\n * test that validatePost fails if any of its required fields are missing.\n *\n * @return void\n */\n\tfunction testValidatePostFormHacking() {\n\t\t$this->Controller->Security->startup($this->Controller);\n\t\t$key = $this->Controller->params['_Token']['key'];\n\t\t$fields = 'a5475372b40f6e3ccbf9f8af191f20e1642fd877%3An%3A1%3A%7Bv%3A0%3B';\n\t\t$fields .= 'f%3A11%3A%22Zbqry.inyvq%22%3B%7D';\n\n\t\t$this->Controller->data = array(\n\t\t\t'Model' => array('username' => 'nate', 'password' => 'foo', 'valid' => '0'),\n\t\t\t'_Token' => compact('key')\n\t\t);\n\t\t$result = $this->Controller->Security->validatePost($this->Controller);\n\t\t$this->assertFalse($result, 'validatePost passed when fields were missing. %s');\n\n\t\t$this->Controller->data = array(\n\t\t\t'Model' => array('username' => 'nate', 'password' => 'foo', 'valid' => '0'),\n\t\t\t'_Token' => compact('fields')\n\t\t);\n\t\t$result = $this->Controller->Security->validatePost($this->Controller);\n\t\t$this->assertFalse($result, 'validatePost passed when key was missing. %s');\n\t}\n/**\n * Tests validation of checkbox arrays\n *\n * @access public\n * @return void\n */\n\tfunction testValidatePostArray() {\n\t\t$this->Controller->Security->startup($this->Controller);\n\t\t$key = $this->Controller->params['_Token']['key'];\n\t\t$fields = 'f7d573650a295b94e0938d32b323fde775e5f32b%3An%3A0%3A%7B%7D';\n\n\t\t$this->Controller->data = array(\n\t\t\t'Model' => array('multi_field' => array('1', '3')),\n\t\t\t'_Token' => compact('key', 'fields')\n\t\t);\n\t\t$this->assertTrue($this->Controller->Security->validatePost($this->Controller));\n\t}\n\n/**\n * testValidatePostNoModel method\n *\n * @access public\n * @return void\n */\n\tfunction testValidatePostNoModel() {\n\t\t$this->Controller->Security->startup($this->Controller);\n\t\t$key = $this->Controller->params['_Token']['key'];\n\t\t$fields = '540ac9c60d323c22bafe997b72c0790f39a8bdef%3An%3A0%3A%7B%7D';\n\n\t\t$this->Controller->data = array(\n\t\t\t'anything' => 'some_data',\n\t\t\t'_Token' => compact('key', 'fields')\n\t\t);\n\n\t\t$result = $this->Controller->Security->validatePost($this->Controller);\n\t\t$this->assertTrue($result);\n\t}\n\n/**\n * testValidatePostSimple method\n *\n * @access public\n * @return void\n */\n\tfunction testValidatePostSimple() {\n\t\t$this->Controller->Security->startup($this->Controller);\n\t\t$key = $this->Controller->params['_Token']['key'];\n\t\t$fields = '69f493434187b867ea14b901fdf58b55d27c935d%3An%3A0%3A%7B%7D';\n\n\t\t$this->Controller->data = $data = array(\n\t\t\t'Model' => array('username' => '', 'password' => ''),\n\t\t\t'_Token' => compact('key', 'fields')\n\t\t);\n\n\t\t$result = $this->Controller->Security->validatePost($this->Controller);\n\t\t$this->assertTrue($result);\n\t}\n\n/**\n * Tests hash validation for multiple records, including locked fields\n *\n * @access public\n * @return void\n */\n\tfunction testValidatePostComplex() {\n\t\t$this->Controller->Security->startup($this->Controller);\n\t\t$key = $this->Controller->params['_Token']['key'];\n\t\t$fields = 'c9118120e680a7201b543f562e5301006ccfcbe2%3An%3A2%3A%7Bv%3A0%3Bf%3A14%3A%';\n\t\t$fields .= '22Nqqerffrf.0.vq%22%3Bv%3A1%3Bf%3A14%3A%22Nqqerffrf.1.vq%22%3B%7D';\n\n\t\t$this->Controller->data = array(\n\t\t\t'Addresses' => array(\n\t\t\t\t'0' => array(\n\t\t\t\t\t'id' => '123456', 'title' => '', 'first_name' => '', 'last_name' => '',\n\t\t\t\t\t'address' => '', 'city' => '', 'phone' => '', 'primary' => ''\n\t\t\t\t),\n\t\t\t\t'1' => array(\n\t\t\t\t\t'id' => '654321', 'title' => '', 'first_name' => '', 'last_name' => '',\n\t\t\t\t\t'address' => '', 'city' => '', 'phone' => '', 'primary' => ''\n\t\t\t\t)\n\t\t\t),\n\t\t\t'_Token' => compact('key', 'fields')\n\t\t);\n\t\t$result = $this->Controller->Security->validatePost($this->Controller);\n\t\t$this->assertTrue($result);\n\t}\n\n/**\n * test ValidatePost with multiple select elements.\n *\n * @return void\n */\n\tfunction testValidatePostMultipleSelect() {\n\t\t$this->Controller->Security->startup($this->Controller);\n\t\t$key = $this->Controller->params['_Token']['key'];\n\t\t$fields = '422cde416475abc171568be690a98cad20e66079%3An%3A0%3A%7B%7D';\n\n\t\t$this->Controller->data = array(\n\t\t\t'Tag' => array('Tag' => array(1, 2)),\n\t\t\t'_Token' => compact('key', 'fields'),\n\t\t);\n\t\t$result = $this->Controller->Security->validatePost($this->Controller);\n\t\t$this->assertTrue($result);\n\n\t\t$this->Controller->data = array(\n\t\t\t'Tag' => array('Tag' => array(1, 2, 3)),\n\t\t\t'_Token' => compact('key', 'fields'),\n\t\t);\n\t\t$result = $this->Controller->Security->validatePost($this->Controller);\n\t\t$this->assertTrue($result);\n\n\t\t$this->Controller->data = array(\n\t\t\t'Tag' => array('Tag' => array(1, 2, 3, 4)),\n\t\t\t'_Token' => compact('key', 'fields'),\n\t\t);\n\t\t$result = $this->Controller->Security->validatePost($this->Controller);\n\t\t$this->assertTrue($result);\n\n\t\t$fields = '19464422eafe977ee729c59222af07f983010c5f%3An%3A0%3A%7B%7D';\n\t\t$this->Controller->data = array(\n\t\t\t'User.password' => 'bar', 'User.name' => 'foo', 'User.is_valid' => '1',\n\t\t\t'Tag' => array('Tag' => array(1)), '_Token' => compact('key', 'fields'),\n\t\t);\n\t\t$result = $this->Controller->Security->validatePost($this->Controller);\n\t\t$this->assertTrue($result);\n\t}\n\n/**\n * testValidatePostCheckbox method\n *\n * First block tests un-checked checkbox\n * Second block tests checked checkbox\n *\n * @access public\n * @return void\n */\n\tfunction testValidatePostCheckbox() {\n\t\t$this->Controller->Security->startup($this->Controller);\n\t\t$key = $this->Controller->params['_Token']['key'];\n\t\t$fields = 'a5475372b40f6e3ccbf9f8af191f20e1642fd877%3An%3A1%3A%7Bv%3A0%';\n\t\t$fields .= '3Bf%3A11%3A%22Zbqry.inyvq%22%3B%7D';\n\n\t\t$this->Controller->data = array(\n\t\t\t'Model' => array('username' => '', 'password' => '', 'valid' => '0'),\n\t\t\t'_Token' => compact('key', 'fields')\n\t\t);\n\n\t\t$result = $this->Controller->Security->validatePost($this->Controller);\n\t\t$this->assertTrue($result);\n\n\t\t$fields = '874439ca69f89b4c4a5f50fb9c36ff56a28f5d42%3An%3A0%3A%7B%7D';\n\n\t\t$this->Controller->data = array(\n\t\t\t'Model' => array('username' => '', 'password' => '', 'valid' => '0'),\n\t\t\t'_Token' => compact('key', 'fields')\n\t\t);\n\n\t\t$result = $this->Controller->Security->validatePost($this->Controller);\n\t\t$this->assertTrue($result);\n\n\n\t\t$this->Controller->data = array();\n\t\t$this->Controller->Security->startup($this->Controller);\n\t\t$key = $this->Controller->params['_Token']['key'];\n\n\t\t$this->Controller->data = $data = array(\n\t\t\t'Model' => array('username' => '', 'password' => '', 'valid' => '0'),\n\t\t\t'_Token' => compact('key', 'fields')\n\t\t);\n\n\t\t$result = $this->Controller->Security->validatePost($this->Controller);\n\t\t$this->assertTrue($result);\n\t}\n\n/**\n * testValidatePostHidden method\n *\n * @access public\n * @return void\n */\n\tfunction testValidatePostHidden() {\n\t\t$this->Controller->Security->startup($this->Controller);\n\t\t$key = $this->Controller->params['_Token']['key'];\n\t\t$fields = '51ccd8cb0997c7b3d4523ecde5a109318405ef8c%3An%3A2%3A%7Bv%3A0%3Bf%3A12%3A';\n\t\t$fields .= '%22Zbqry.uvqqra%22%3Bv%3A1%3Bf%3A18%3A%22Zbqry.bgure_uvqqra%22%3B%7D';\n\n\t\t$this->Controller->data = array(\n\t\t\t'Model' => array(\n\t\t\t\t'username' => '', 'password' => '', 'hidden' => '0',\n\t\t\t\t'other_hidden' => 'some hidden value'\n\t\t\t),\n\t\t\t'_Token' => compact('key', 'fields')\n\t\t);\n\t\t$result = $this->Controller->Security->validatePost($this->Controller);\n\t\t$this->assertTrue($result);\n\t}\n\n/**\n * testValidatePostWithDisabledFields method\n *\n * @access public\n * @return void\n */\n\tfunction testValidatePostWithDisabledFields() {\n\t\t$this->Controller->Security->disabledFields = array('Model.username', 'Model.password');\n\t\t$this->Controller->Security->startup($this->Controller);\n\t\t$key = $this->Controller->params['_Token']['key'];\n\t\t$fields = 'ef1082968c449397bcd849f963636864383278b1%3An%3A1%3A%7Bv%';\n\t\t$fields .= '3A0%3Bf%3A12%3A%22Zbqry.uvqqra%22%3B%7D';\n\n\t\t$this->Controller->data = array(\n\t\t\t'Model' => array(\n\t\t\t\t'username' => '', 'password' => '', 'hidden' => '0'\n\t\t\t),\n\t\t\t'_Token' => compact('fields', 'key')\n\t\t);\n\n\t\t$result = $this->Controller->Security->validatePost($this->Controller);\n\t\t$this->assertTrue($result);\n\t}\n\n/**\n * testValidateHiddenMultipleModel method\n *\n * @access public\n * @return void\n */\n\tfunction testValidateHiddenMultipleModel() {\n\t\t$this->Controller->Security->startup($this->Controller);\n\t\t$key = $this->Controller->params['_Token']['key'];\n\t\t$fields = 'a2d01072dc4660eea9d15007025f35a7a5b58e18%3An%3A3%3A%7Bv%3A0%3Bf%3A11';\n\t\t$fields .= '%3A%22Zbqry.inyvq%22%3Bv%3A1%3Bf%3A12%3A%22Zbqry2.inyvq%22%3Bv%3A2%';\n\t\t$fields .= '3Bf%3A12%3A%22Zbqry3.inyvq%22%3B%7D';\n\n\t\t$this->Controller->data = array(\n\t\t\t'Model' => array('username' => '', 'password' => '', 'valid' => '0'),\n\t\t\t'Model2' => array('valid' => '0'),\n\t\t\t'Model3' => array('valid' => '0'),\n\t\t\t'_Token' => compact('key', 'fields')\n\t\t);\n\t\t$result = $this->Controller->Security->validatePost($this->Controller);\n\t\t$this->assertTrue($result);\n\t}\n\n/**\n * testLoginValidation method\n *\n * @access public\n * @return void\n */\n\tfunction testLoginValidation() {\n\n\t}\n\n/**\n * testValidateHasManyModel method\n *\n * @access public\n * @return void\n */\n\tfunction testValidateHasManyModel() {\n\t\t$this->Controller->Security->startup($this->Controller);\n\t\t$key = $this->Controller->params['_Token']['key'];\n\t\t$fields = '51e3b55a6edd82020b3f29c9ae200e14bbeb7ee5%3An%3A4%3A%7Bv%3A0%3Bf%3A14%3A%2';\n\t\t$fields .= '2Zbqry.0.uvqqra%22%3Bv%3A1%3Bf%3A13%3A%22Zbqry.0.inyvq%22%3Bv%3A2%3Bf%3';\n\t\t$fields .= 'A14%3A%22Zbqry.1.uvqqra%22%3Bv%3A3%3Bf%3A13%3A%22Zbqry.1.inyvq%22%3B%7D';\n\n\t\t$this->Controller->data = array(\n\t\t\t'Model' => array(\n\t\t\t\tarray(\n\t\t\t\t\t'username' => 'username', 'password' => 'password',\n\t\t\t\t\t'hidden' => 'value', 'valid' => '0'\n\t\t\t\t),\n\t\t\t\tarray(\n\t\t\t\t\t'username' => 'username', 'password' => 'password',\n\t\t\t\t\t'hidden' => 'value', 'valid' => '0'\n\t\t\t\t)\n\t\t\t),\n\t\t\t'_Token' => compact('key', 'fields')\n\t\t);\n\n\t\t$result = $this->Controller->Security->validatePost($this->Controller);\n\t\t$this->assertTrue($result);\n\t}\n\n/**\n * testValidateHasManyRecordsPass method\n *\n * @access public\n * @return void\n */\n\tfunction testValidateHasManyRecordsPass() {\n\t\t$this->Controller->Security->startup($this->Controller);\n\t\t$key = $this->Controller->params['_Token']['key'];\n\t\t$fields = '7a203edb3d345bbf38fe0dccae960da8842e11d7%3An%3A4%3A%7Bv%3A0%3Bf%3A12%3A%2';\n\t\t$fields .= '2Nqqerff.0.vq%22%3Bv%3A1%3Bf%3A17%3A%22Nqqerff.0.cevznel%22%3Bv%3A2%3Bf%';\n\t\t$fields .= '3A12%3A%22Nqqerff.1.vq%22%3Bv%3A3%3Bf%3A17%3A%22Nqqerff.1.cevznel%22%3B%7D';\n\n\t\t$this->Controller->data = array(\n\t\t\t'Address' => array(\n\t\t\t\t0 => array(\n\t\t\t\t\t'id' => '123',\n\t\t\t\t\t'title' => 'home',\n\t\t\t\t\t'first_name' => 'Bilbo',\n\t\t\t\t\t'last_name' => 'Baggins',\n\t\t\t\t\t'address' => '23 Bag end way',\n\t\t\t\t\t'city' => 'the shire',\n\t\t\t\t\t'phone' => 'N/A',\n\t\t\t\t\t'primary' => '1',\n\t\t\t\t),\n\t\t\t\t1 => array(\n\t\t\t\t\t'id' => '124',\n\t\t\t\t\t'title' => 'home',\n\t\t\t\t\t'first_name' => 'Frodo',\n\t\t\t\t\t'last_name' => 'Baggins',\n\t\t\t\t\t'address' => '50 Bag end way',\n\t\t\t\t\t'city' => 'the shire',\n\t\t\t\t\t'phone' => 'N/A',\n\t\t\t\t\t'primary' => '1'\n\t\t\t\t)\n\t\t\t),\n\t\t\t'_Token' => compact('key', 'fields')\n\t\t);\n\n\t\t$result = $this->Controller->Security->validatePost($this->Controller);\n\t\t$this->assertTrue($result);\n\t}\n\n/**\n * testValidateHasManyRecords method\n *\n * validatePost should fail, hidden fields have been changed.\n *\n * @access public\n * @return void\n */\n\tfunction testValidateHasManyRecordsFail() {\n\t\t$this->Controller->Security->startup($this->Controller);\n\t\t$key = $this->Controller->params['_Token']['key'];\n\t\t$fields = '7a203edb3d345bbf38fe0dccae960da8842e11d7%3An%3A4%3A%7Bv%3A0%3Bf%3A12%3A%2';\n\t\t$fields .= '2Nqqerff.0.vq%22%3Bv%3A1%3Bf%3A17%3A%22Nqqerff.0.cevznel%22%3Bv%3A2%3Bf%';\n\t\t$fields .= '3A12%3A%22Nqqerff.1.vq%22%3Bv%3A3%3Bf%3A17%3A%22Nqqerff.1.cevznel%22%3B%7D';\n\n\t\t$this->Controller->data = array(\n\t\t\t'Address' => array(\n\t\t\t\t0 => array(\n\t\t\t\t\t'id' => '123',\n\t\t\t\t\t'title' => 'home',\n\t\t\t\t\t'first_name' => 'Bilbo',\n\t\t\t\t\t'last_name' => 'Baggins',\n\t\t\t\t\t'address' => '23 Bag end way',\n\t\t\t\t\t'city' => 'the shire',\n\t\t\t\t\t'phone' => 'N/A',\n\t\t\t\t\t'primary' => '5',\n\t\t\t\t),\n\t\t\t\t1 => array(\n\t\t\t\t\t'id' => '124',\n\t\t\t\t\t'title' => 'home',\n\t\t\t\t\t'first_name' => 'Frodo',\n\t\t\t\t\t'last_name' => 'Baggins',\n\t\t\t\t\t'address' => '50 Bag end way',\n\t\t\t\t\t'city' => 'the shire',\n\t\t\t\t\t'phone' => 'N/A',\n\t\t\t\t\t'primary' => '1'\n\t\t\t\t)\n\t\t\t),\n\t\t\t'_Token' => compact('key', 'fields')\n\t\t);\n\n\t\t$result = $this->Controller->Security->validatePost($this->Controller);\n\t\t$this->assertFalse($result);\n\t}\n\n/**\n * testLoginRequest method\n *\n * @access public\n * @return void\n */\n\tfunction testLoginRequest() {\n\t\t$this->Controller->Security->startup($this->Controller);\n\t\t$realm = 'cakephp.org';\n\t\t$options = array('realm' => $realm, 'type' => 'basic');\n\t\t$result = $this->Controller->Security->loginRequest($options);\n\t\t$expected = 'WWW-Authenticate: Basic realm=\"'.$realm.'\"';\n\t\t$this->assertEqual($result, $expected);\n\n\t\t$this->Controller->Security->startup($this->Controller);\n\t\t$options = array('realm' => $realm, 'type' => 'digest');\n\t\t$result = $this->Controller->Security->loginRequest($options);\n\t\t$this->assertPattern('/realm=\"'.$realm.'\"/', $result);\n\t\t$this->assertPattern('/qop=\"auth\"/', $result);\n\t}\n\n/**\n * testGenerateDigestResponseHash method\n *\n * @access public\n * @return void\n */\n\tfunction testGenerateDigestResponseHash() {\n\t\t$this->Controller->Security->startup($this->Controller);\n\t\t$realm = 'cakephp.org';\n\t\t$loginData = array('realm' => $realm, 'users' => array('Willy Smith' => 'password'));\n\t\t$this->Controller->Security->requireLogin($loginData);\n\n\t\t$data = array(\n\t\t\t'username' => 'Willy Smith',\n\t\t\t'password' => 'password',\n\t\t\t'nonce' => String::uuid(),\n\t\t\t'nc' => 1,\n\t\t\t'cnonce' => 1,\n\t\t\t'realm' => $realm,\n\t\t\t'uri' => 'path_to_identifier',\n\t\t\t'qop' => 'testme'\n\t\t);\n\t\t$_SERVER['REQUEST_METHOD'] = 'POST';\n\n\t\t$result = $this->Controller->Security->generateDigestResponseHash($data);\n\t\t$expected = md5(\n\t\t\tmd5($data['username'] . ':' . $loginData['realm'] . ':' . $data['password']) . ':' .\n\t\t\t$data['nonce'] . ':' . $data['nc'] . ':' . $data['cnonce'] . ':' . $data['qop'] . ':' .\n\t\t\tmd5(env('REQUEST_METHOD') . ':' . $data['uri'])\n\t\t);\n\t\t$this->assertIdentical($result, $expected);\n\t}\n\n/**\n * testLoginCredentials method\n *\n * @access public\n * @return void\n */\n\tfunction testLoginCredentials() {\n\t\t$this->Controller->Security->startup($this->Controller);\n\t\t$_SERVER['PHP_AUTH_USER'] = $user = 'Willy Test';\n\t\t$_SERVER['PHP_AUTH_PW'] = $pw = 'some password for the nice test';\n\n\t\t$result = $this->Controller->Security->loginCredentials('basic');\n\t\t$expected = array('username' => $user, 'password' => $pw);\n\t\t$this->assertIdentical($result, $expected);\n\n\t\tif (version_compare(PHP_VERSION, '5.1') != -1) {\n\t\t\t$_SERVER['PHP_AUTH_DIGEST'] = $digest = <<<DIGEST\n\t\t\t\tDigest username=\"Mufasa\",\n\t\t\t\trealm=\"testrealm@host.com\",\n\t\t\t\tnonce=\"dcd98b7102dd2f0e8b11d0f600bfb0c093\",\n\t\t\t\turi=\"/dir/index.html\",\n\t\t\t\tqop=auth,\n\t\t\t\tnc=00000001,\n\t\t\t\tcnonce=\"0a4f113b\",\n\t\t\t\tresponse=\"6629fae49393a05397450978507c4ef1\",\n\t\t\t\topaque=\"5ccc069c403ebaf9f0171e9517f40e41\"\nDIGEST;\n\t\t\t$expected = array(\n\t\t\t\t'username' => 'Mufasa',\n\t\t\t\t'realm' => 'testrealm@host.com',\n\t\t\t\t'nonce' => 'dcd98b7102dd2f0e8b11d0f600bfb0c093',\n\t\t\t\t'uri' => '/dir/index.html',\n\t\t\t\t'qop' => 'auth',\n\t\t\t\t'nc' => '00000001',\n\t\t\t\t'cnonce' => '0a4f113b',\n\t\t\t\t'response' => '6629fae49393a05397450978507c4ef1',\n\t\t\t\t'opaque' => '5ccc069c403ebaf9f0171e9517f40e41'\n\t\t\t);\n\t\t\t$result = $this->Controller->Security->loginCredentials('digest');\n\t\t\t$this->assertIdentical($result, $expected);\n\t\t}\n\t}\n\n/**\n * testParseDigestAuthData method\n *\n * @access public\n * @return void\n */\n\tfunction testParseDigestAuthData() {\n\t\t$this->Controller->Security->startup($this->Controller);\n\t\t$digest = <<<DIGEST\n\t\t\tDigest username=\"Mufasa\",\n\t\t\trealm=\"testrealm@host.com\",\n\t\t\tnonce=\"dcd98b7102dd2f0e8b11d0f600bfb0c093\",\n\t\t\turi=\"/dir/index.html\",\n\t\t\tqop=auth,\n\t\t\tnc=00000001,\n\t\t\tcnonce=\"0a4f113b\",\n\t\t\tresponse=\"6629fae49393a05397450978507c4ef1\",\n\t\t\topaque=\"5ccc069c403ebaf9f0171e9517f40e41\"\nDIGEST;\n\t\t$expected = array(\n\t\t\t'username' => 'Mufasa',\n\t\t\t'realm' => 'testrealm@host.com',\n\t\t\t'nonce' => 'dcd98b7102dd2f0e8b11d0f600bfb0c093',\n\t\t\t'uri' => '/dir/index.html',\n\t\t\t'qop' => 'auth',\n\t\t\t'nc' => '00000001',\n\t\t\t'cnonce' => '0a4f113b',\n\t\t\t'response' => '6629fae49393a05397450978507c4ef1',\n\t\t\t'opaque' => '5ccc069c403ebaf9f0171e9517f40e41'\n\t\t);\n\t\t$result = $this->Controller->Security->parseDigestAuthData($digest);\n\t\t$this->assertIdentical($result, $expected);\n\n\t\t$result = $this->Controller->Security->parseDigestAuthData('');\n\t\t$this->assertNull($result);\n\t}\n\n/**\n * test parsing digest information with email addresses\n *\n * @return void\n */\n\tfunction testParseDigestAuthEmailAddress() {\n\t\t$this->Controller->Security->startup($this->Controller);\n\t\t$digest = <<<DIGEST\n\t\t\tDigest username=\"mark@example.com\",\n\t\t\trealm=\"testrealm@host.com\",\n\t\t\tnonce=\"dcd98b7102dd2f0e8b11d0f600bfb0c093\",\n\t\t\turi=\"/dir/index.html\",\n\t\t\tqop=auth,\n\t\t\tnc=00000001,\n\t\t\tcnonce=\"0a4f113b\",\n\t\t\tresponse=\"6629fae49393a05397450978507c4ef1\",\n\t\t\topaque=\"5ccc069c403ebaf9f0171e9517f40e41\"\nDIGEST;\n\t\t$expected = array(\n\t\t\t'username' => 'mark@example.com',\n\t\t\t'realm' => 'testrealm@host.com',\n\t\t\t'nonce' => 'dcd98b7102dd2f0e8b11d0f600bfb0c093',\n\t\t\t'uri' => '/dir/index.html',\n\t\t\t'qop' => 'auth',\n\t\t\t'nc' => '00000001',\n\t\t\t'cnonce' => '0a4f113b',\n\t\t\t'response' => '6629fae49393a05397450978507c4ef1',\n\t\t\t'opaque' => '5ccc069c403ebaf9f0171e9517f40e41'\n\t\t);\n\t\t$result = $this->Controller->Security->parseDigestAuthData($digest);\n\t\t$this->assertIdentical($result, $expected);\n\t}\n\n/**\n * testFormDisabledFields method\n *\n * @access public\n * @return void\n */\n\tfunction testFormDisabledFields() {\n\t\t$this->Controller->Security->startup($this->Controller);\n\t\t$key = $this->Controller->params['_Token']['key'];\n\t\t$fields = '11842060341b9d0fc3808b90ba29fdea7054d6ad%3An%3A0%3A%7B%7D';\n\n\t\t$this->Controller->data = array(\n\t\t\t'MyModel' => array('name' => 'some data'),\n\t\t\t'_Token' => compact('key', 'fields')\n\t\t);\n\t\t$result = $this->Controller->Security->validatePost($this->Controller);\n\t\t$this->assertFalse($result);\n\n\t\t$this->Controller->Security->startup($this->Controller);\n\t\t$this->Controller->Security->disabledFields = array('MyModel.name');\n\t\t$key = $this->Controller->params['_Token']['key'];\n\n\t\t$this->Controller->data = array(\n\t\t\t'MyModel' => array('name' => 'some data'),\n\t\t\t'_Token' => compact('key', 'fields')\n\t\t);\n\n\t\t$result = $this->Controller->Security->validatePost($this->Controller);\n\t\t$this->assertTrue($result);\n\t}\n\n/**\n * testRadio method\n *\n * @access public\n * @return void\n */\n\tfunction testRadio() {\n\t\t$this->Controller->Security->startup($this->Controller);\n\t\t$key = $this->Controller->params['_Token']['key'];\n\t\t$fields = '575ef54ca4fc8cab468d6d898e9acd3a9671c17e%3An%3A0%3A%7B%7D';\n\n\t\t$this->Controller->data = array(\n\t\t\t'_Token' => compact('key', 'fields')\n\t\t);\n\t\t$result = $this->Controller->Security->validatePost($this->Controller);\n\t\t$this->assertFalse($result);\n\n\t\t$this->Controller->data = array(\n\t\t\t'_Token' => compact('key', 'fields'),\n\t\t\t'Test' => array('test' => '')\n\t\t);\n\t\t$result = $this->Controller->Security->validatePost($this->Controller);\n\t\t$this->assertTrue($result);\n\n\t\t$this->Controller->data = array(\n\t\t\t'_Token' => compact('key', 'fields'),\n\t\t\t'Test' => array('test' => '1')\n\t\t);\n\t\t$result = $this->Controller->Security->validatePost($this->Controller);\n\t\t$this->assertTrue($result);\n\n\t\t$this->Controller->data = array(\n\t\t\t'_Token' => compact('key', 'fields'),\n\t\t\t'Test' => array('test' => '2')\n\t\t);\n\t\t$result = $this->Controller->Security->validatePost($this->Controller);\n\t\t$this->assertTrue($result);\n\t}\n\n/**\n * testInvalidAuthHeaders method\n *\n * @access public\n * @return void\n */\n\tfunction testInvalidAuthHeaders() {\n\t\t$this->Controller->Security->blackHoleCallback = null;\n\t\t$_SERVER['PHP_AUTH_USER'] = 'admin';\n\t\t$_SERVER['PHP_AUTH_PW'] = 'password';\n\t\t$realm = 'cakephp.org';\n\t\t$loginData = array('type' => 'basic', 'realm' => $realm);\n\t\t$this->Controller->Security->requireLogin($loginData);\n\t\t$this->Controller->Security->startup($this->Controller);\n\n\t\t$expected = 'WWW-Authenticate: Basic realm=\"'.$realm.'\"';\n\t\t$this->assertEqual(count($this->Controller->testHeaders), 1);\n\t\t$this->assertEqual(current($this->Controller->testHeaders), $expected);\n\t}\n\n/**\n * test that a requestAction's controller will have the _Token appended to\n * the params.\n *\n * @return void\n * @see http://cakephp.lighthouseapp.com/projects/42648/tickets/68\n */\n\tfunction testSettingTokenForRequestAction() {\n\t\t$this->Controller->Security->startup($this->Controller);\n\t\t$key = $this->Controller->params['_Token']['key'];\n\n\t\t$this->Controller->params['requested'] = 1;\n\t\tunset($this->Controller->params['_Token']);\n\n\t\t$this->Controller->Security->startup($this->Controller);\n\t\t$this->assertEqual($this->Controller->params['_Token']['key'], $key);\n\t}\n\n/**\n * test that blackhole doesn't delete the _Token session key so repeat data submissions\n * stay blackholed.\n *\n * @link http://cakephp.lighthouseapp.com/projects/42648/tickets/214\n * @return void\n */\n\tfunction testBlackHoleNotDeletingSessionInformation() {\n\t\t$this->Controller->Security->startup($this->Controller);\n\n\t\t$this->Controller->Security->blackHole($this->Controller, 'auth');\n\t\t$this->assertTrue($this->Controller->Security->Session->check('_Token'), '_Token was deleted by blackHole %s');\n\t}\n}\n"], "fixing_code": ["<?php\n/**\n * Security Component\n *\n * PHP versions 4 and 5\n *\n * CakePHP(tm) : Rapid Development Framework (http://cakephp.org)\n * Copyright 2005-2010, Cake Software Foundation, Inc. (http://cakefoundation.org)\n *\n * Licensed under The MIT License\n * Redistributions of files must retain the above copyright notice.\n *\n * @copyright     Copyright 2005-2010, Cake Software Foundation, Inc. (http://cakefoundation.org)\n * @link          http://cakephp.org CakePHP(tm) Project\n * @package       cake\n * @subpackage    cake.cake.libs.controller.components\n * @since         CakePHP(tm) v 0.10.8.2156\n * @license       MIT License (http://www.opensource.org/licenses/mit-license.php)\n */\nApp::import('Core', array('String', 'Security'));\n\n/**\n * SecurityComponent\n *\n * @package       cake\n * @subpackage    cake.cake.libs.controller.components\n * @link http://book.cakephp.org/view/1296/Security-Component\n */\nclass SecurityComponent extends Object {\n\n/**\n * The controller method that will be called if this request is black-hole'd\n *\n * @var string\n * @access public\n */\n\tvar $blackHoleCallback = null;\n\n/**\n * List of controller actions for which a POST request is required\n *\n * @var array\n * @access public\n * @see SecurityComponent::requirePost()\n */\n\tvar $requirePost = array();\n\n/**\n * List of controller actions for which a GET request is required\n *\n * @var array\n * @access public\n * @see SecurityComponent::requireGet()\n */\n\tvar $requireGet = array();\n\n/**\n * List of controller actions for which a PUT request is required\n *\n * @var array\n * @access public\n * @see SecurityComponent::requirePut()\n */\n\tvar $requirePut = array();\n\n/**\n * List of controller actions for which a DELETE request is required\n *\n * @var array\n * @access public\n * @see SecurityComponent::requireDelete()\n */\n\tvar $requireDelete = array();\n\n/**\n * List of actions that require an SSL-secured connection\n *\n * @var array\n * @access public\n * @see SecurityComponent::requireSecure()\n */\n\tvar $requireSecure = array();\n\n/**\n * List of actions that require a valid authentication key\n *\n * @var array\n * @access public\n * @see SecurityComponent::requireAuth()\n */\n\tvar $requireAuth = array();\n\n/**\n * List of actions that require an HTTP-authenticated login (basic or digest)\n *\n * @var array\n * @access public\n * @see SecurityComponent::requireLogin()\n */\n\tvar $requireLogin = array();\n\n/**\n * Login options for SecurityComponent::requireLogin()\n *\n * @var array\n * @access public\n * @see SecurityComponent::requireLogin()\n */\n\tvar $loginOptions = array('type' => '', 'prompt' => null);\n\n/**\n * An associative array of usernames/passwords used for HTTP-authenticated logins.\n *\n * @var array\n * @access public\n * @see SecurityComponent::requireLogin()\n */\n\tvar $loginUsers = array();\n\n/**\n * Controllers from which actions of the current controller are allowed to receive\n * requests.\n *\n * @var array\n * @access public\n * @see SecurityComponent::requireAuth()\n */\n\tvar $allowedControllers = array();\n\n/**\n * Actions from which actions of the current controller are allowed to receive\n * requests.\n *\n * @var array\n * @access public\n * @see SecurityComponent::requireAuth()\n */\n\tvar $allowedActions = array();\n\n/**\n * Form fields to disable\n *\n * @var array\n * @access public\n */\n\tvar $disabledFields = array();\n\n/**\n * Whether to validate POST data.  Set to false to disable for data coming from 3rd party\n * services, etc.\n *\n * @var boolean\n * @access public\n */\n\tvar $validatePost = true;\n\n/**\n * Other components used by the Security component\n *\n * @var array\n * @access public\n */\n\tvar $components = array('RequestHandler', 'Session');\n\n/**\n * Holds the current action of the controller\n *\n * @var string\n */\n\tvar $_action = null;\n\n/**\n * Initialize the SecurityComponent\n *\n * @param object $controller Controller instance for the request\n * @param array $settings Settings to set to the component\n * @return void\n * @access public\n */\n\tfunction initialize(&$controller, $settings = array()) {\n\t\t$this->_set($settings);\n\t}\n\n/**\n * Component startup. All security checking happens here.\n *\n * @param object $controller Instantiating controller\n * @return void\n * @access public\n */\n\tfunction startup(&$controller) {\n\t\t$this->_action = strtolower($controller->action);\n\t\t$this->_methodsRequired($controller);\n\t\t$this->_secureRequired($controller);\n\t\t$this->_authRequired($controller);\n\t\t$this->_loginRequired($controller);\n\n\t\t$isPost = ($this->RequestHandler->isPost() || $this->RequestHandler->isPut());\n\t\t$isRequestAction = (\n\t\t\t!isset($controller->params['requested']) ||\n\t\t\t$controller->params['requested'] != 1\n\t\t);\n\n\t\tif ($isPost && $isRequestAction && $this->validatePost) {\n\t\t\tif ($this->_validatePost($controller) === false) {\n\t\t\t\tif (!$this->blackHole($controller, 'auth')) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t$this->_generateToken($controller);\n\t}\n\n/**\n * Sets the actions that require a POST request, or empty for all actions\n *\n * @return void\n * @access public\n * @link http://book.cakephp.org/view/1299/requirePost\n */\n\tfunction requirePost() {\n\t\t$args = func_get_args();\n\t\t$this->_requireMethod('Post', $args);\n\t}\n\n/**\n * Sets the actions that require a GET request, or empty for all actions\n *\n * @return void\n * @access public\n */\n\tfunction requireGet() {\n\t\t$args = func_get_args();\n\t\t$this->_requireMethod('Get', $args);\n\t}\n\n/**\n * Sets the actions that require a PUT request, or empty for all actions\n *\n * @return void\n * @access public\n */\n\tfunction requirePut() {\n\t\t$args = func_get_args();\n\t\t$this->_requireMethod('Put', $args);\n\t}\n\n/**\n * Sets the actions that require a DELETE request, or empty for all actions\n *\n * @return void\n * @access public\n */\n\tfunction requireDelete() {\n\t\t$args = func_get_args();\n\t\t$this->_requireMethod('Delete', $args);\n\t}\n\n/**\n * Sets the actions that require a request that is SSL-secured, or empty for all actions\n *\n * @return void\n * @access public\n * @link http://book.cakephp.org/view/1300/requireSecure\n */\n\tfunction requireSecure() {\n\t\t$args = func_get_args();\n\t\t$this->_requireMethod('Secure', $args);\n\t}\n\n/**\n * Sets the actions that require an authenticated request, or empty for all actions\n *\n * @return void\n * @access public\n * @link http://book.cakephp.org/view/1301/requireAuth\n */\n\tfunction requireAuth() {\n\t\t$args = func_get_args();\n\t\t$this->_requireMethod('Auth', $args);\n\t}\n\n/**\n * Sets the actions that require an HTTP-authenticated request, or empty for all actions\n *\n * @return void\n * @access public\n * @link http://book.cakephp.org/view/1302/requireLogin\n */\n\tfunction requireLogin() {\n\t\t$args = func_get_args();\n\t\t$base = $this->loginOptions;\n\n\t\tforeach ($args as $i => $arg) {\n\t\t\tif (is_array($arg)) {\n\t\t\t\t$this->loginOptions = $arg;\n\t\t\t\tunset($args[$i]);\n\t\t\t}\n\t\t}\n\t\t$this->loginOptions = array_merge($base, $this->loginOptions);\n\t\t$this->_requireMethod('Login', $args);\n\n\t\tif (isset($this->loginOptions['users'])) {\n\t\t\t$this->loginUsers =& $this->loginOptions['users'];\n\t\t}\n\t}\n\n/**\n * Attempts to validate the login credentials for an HTTP-authenticated request\n *\n * @param string $type Either 'basic', 'digest', or null. If null/empty, will try both.\n * @return mixed If successful, returns an array with login name and password, otherwise null.\n * @access public\n * @link http://book.cakephp.org/view/1303/loginCredentials-string-type\n */\n\tfunction loginCredentials($type = null) {\n\t\tswitch (strtolower($type)) {\n\t\t\tcase 'basic':\n\t\t\t\t$login = array('username' => env('PHP_AUTH_USER'), 'password' => env('PHP_AUTH_PW'));\n\t\t\t\tif (!empty($login['username'])) {\n\t\t\t\t\treturn $login;\n\t\t\t\t}\n\t\t\tbreak;\n\t\t\tcase 'digest':\n\t\t\tdefault:\n\t\t\t\t$digest = null;\n\n\t\t\t\tif (version_compare(PHP_VERSION, '5.1') != -1) {\n\t\t\t\t\t$digest = env('PHP_AUTH_DIGEST');\n\t\t\t\t} elseif (function_exists('apache_request_headers')) {\n\t\t\t\t\t$headers = apache_request_headers();\n\t\t\t\t\tif (isset($headers['Authorization']) && !empty($headers['Authorization']) && substr($headers['Authorization'], 0, 7) == 'Digest ') {\n\t\t\t\t\t\t$digest = substr($headers['Authorization'], 7);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// Server doesn't support digest-auth headers\n\t\t\t\t\ttrigger_error(__('SecurityComponent::loginCredentials() - Server does not support digest authentication', true), E_USER_WARNING);\n\t\t\t\t}\n\n\t\t\t\tif (!empty($digest)) {\n\t\t\t\t\treturn $this->parseDigestAuthData($digest);\n\t\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\treturn null;\n\t}\n\n/**\n * Generates the text of an HTTP-authentication request header from an array of options.\n *\n * @param array $options Set of options for header\n * @return string HTTP-authentication request header\n * @access public\n * @link http://book.cakephp.org/view/1304/loginRequest-array-options\n */\n\tfunction loginRequest($options = array()) {\n\t\t$options = array_merge($this->loginOptions, $options);\n\t\t$this->_setLoginDefaults($options);\n\t\t$auth = 'WWW-Authenticate: ' . ucfirst($options['type']);\n\t\t$out = array('realm=\"' . $options['realm'] . '\"');\n\n\t\tif (strtolower($options['type']) == 'digest') {\n\t\t\t$out[] = 'qop=\"auth\"';\n\t\t\t$out[] = 'nonce=\"' . uniqid(\"\") . '\"';\n\t\t\t$out[] = 'opaque=\"' . md5($options['realm']) . '\"';\n\t\t}\n\n\t\treturn $auth . ' ' . implode(',', $out);\n\t}\n\n/**\n * Parses an HTTP digest authentication response, and returns an array of the data, or null on failure.\n *\n * @param string $digest Digest authentication response\n * @return array Digest authentication parameters\n * @access public\n * @link http://book.cakephp.org/view/1305/parseDigestAuthData-string-digest\n */\n\tfunction parseDigestAuthData($digest) {\n\t\tif (substr($digest, 0, 7) == 'Digest ') {\n\t\t\t$digest = substr($digest, 7);\n\t\t}\n\t\t$keys = array();\n\t\t$match = array();\n\t\t$req = array('nonce' => 1, 'nc' => 1, 'cnonce' => 1, 'qop' => 1, 'username' => 1, 'uri' => 1, 'response' => 1);\n\t\tpreg_match_all('/(\\w+)=([\\'\"]?)([a-zA-Z0-9@=.\\/_-]+)\\2/', $digest, $match, PREG_SET_ORDER);\n\n\t\tforeach ($match as $i) {\n\t\t\t$keys[$i[1]] = $i[3];\n\t\t\tunset($req[$i[1]]);\n\t\t}\n\n\t\tif (empty($req)) {\n\t\t\treturn $keys;\n\t\t}\n\t\treturn null;\n\t}\n\n/**\n * Generates a hash to be compared with an HTTP digest-authenticated response\n *\n * @param array $data HTTP digest response data, as parsed by SecurityComponent::parseDigestAuthData()\n * @return string Digest authentication hash\n * @access public\n * @see SecurityComponent::parseDigestAuthData()\n * @link http://book.cakephp.org/view/1306/generateDigestResponseHash-array-data\n */\n\tfunction generateDigestResponseHash($data) {\n\t\treturn md5(\n\t\t\tmd5($data['username'] . ':' . $this->loginOptions['realm'] . ':' . $this->loginUsers[$data['username']]) .\n\t\t\t':' . $data['nonce'] . ':' . $data['nc'] . ':' . $data['cnonce'] . ':' . $data['qop'] . ':' .\n\t\t\tmd5(env('REQUEST_METHOD') . ':' . $data['uri'])\n\t\t);\n\t}\n\n/**\n * Black-hole an invalid request with a 404 error or custom callback. If SecurityComponent::$blackHoleCallback\n * is specified, it will use this callback by executing the method indicated in $error\n *\n * @param object $controller Instantiating controller\n * @param string $error Error method\n * @return mixed If specified, controller blackHoleCallback's response, or no return otherwise\n * @access public\n * @see SecurityComponent::$blackHoleCallback\n * @link http://book.cakephp.org/view/1307/blackHole-object-controller-string-error\n */\n\tfunction blackHole(&$controller, $error = '') {\n\t\tif ($this->blackHoleCallback == null) {\n\t\t\t$code = 404;\n\t\t\tif ($error == 'login') {\n\t\t\t\t$code = 401;\n\t\t\t\t$controller->header($this->loginRequest());\n\t\t\t}\n\t\t\t$controller->redirect(null, $code, true);\n\t\t} else {\n\t\t\treturn $this->_callback($controller, $this->blackHoleCallback, array($error));\n\t\t}\n\t}\n\n/**\n * Sets the actions that require a $method HTTP request, or empty for all actions\n *\n * @param string $method The HTTP method to assign controller actions to\n * @param array $actions Controller actions to set the required HTTP method to.\n * @return void\n * @access protected\n */\n\tfunction _requireMethod($method, $actions = array()) {\n\t\tif (isset($actions[0]) && is_array($actions[0])) {\n\t\t\t$actions = $actions[0];\n\t\t}\n\t\t$this->{'require' . $method} = (empty($actions)) ? array('*'): $actions;\n\t}\n\n/**\n * Check if HTTP methods are required\n *\n * @param object $controller Instantiating controller\n * @return bool true if $method is required\n * @access protected\n */\n\tfunction _methodsRequired(&$controller) {\n\t\tforeach (array('Post', 'Get', 'Put', 'Delete') as $method) {\n\t\t\t$property = 'require' . $method;\n\t\t\tif (is_array($this->$property) && !empty($this->$property)) {\n\t\t\t\t$require = array_map('strtolower', $this->$property);\n\n\t\t\t\tif (in_array($this->_action, $require) || $this->$property == array('*')) {\n\t\t\t\t\tif (!$this->RequestHandler->{'is' . $method}()) {\n\t\t\t\t\t\tif (!$this->blackHole($controller, strtolower($method))) {\n\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n/**\n * Check if access requires secure connection\n *\n * @param object $controller Instantiating controller\n * @return bool true if secure connection required\n * @access protected\n */\n\tfunction _secureRequired(&$controller) {\n\t\tif (is_array($this->requireSecure) && !empty($this->requireSecure)) {\n\t\t\t$requireSecure = array_map('strtolower', $this->requireSecure);\n\n\t\t\tif (in_array($this->_action, $requireSecure) || $this->requireSecure == array('*')) {\n\t\t\t\tif (!$this->RequestHandler->isSSL()) {\n\t\t\t\t\tif (!$this->blackHole($controller, 'secure')) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n/**\n * Check if authentication is required\n *\n * @param object $controller Instantiating controller\n * @return bool true if authentication required\n * @access protected\n */\n\tfunction _authRequired(&$controller) {\n\t\tif (is_array($this->requireAuth) && !empty($this->requireAuth) && !empty($controller->data)) {\n\t\t\t$requireAuth = array_map('strtolower', $this->requireAuth);\n\n\t\t\tif (in_array($this->_action, $requireAuth) || $this->requireAuth == array('*')) {\n\t\t\t\tif (!isset($controller->data['_Token'] )) {\n\t\t\t\t\tif (!$this->blackHole($controller, 'auth')) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif ($this->Session->check('_Token')) {\n\t\t\t\t\t$tData = unserialize($this->Session->read('_Token'));\n\n\t\t\t\t\tif (!empty($tData['allowedControllers']) && !in_array($controller->params['controller'], $tData['allowedControllers']) || !empty($tData['allowedActions']) && !in_array($controller->params['action'], $tData['allowedActions'])) {\n\t\t\t\t\t\tif (!$this->blackHole($controller, 'auth')) {\n\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (!$this->blackHole($controller, 'auth')) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n/**\n * Check if login is required\n *\n * @param object $controller Instantiating controller\n * @return bool true if login is required\n * @access protected\n */\n\tfunction _loginRequired(&$controller) {\n\t\tif (is_array($this->requireLogin) && !empty($this->requireLogin)) {\n\t\t\t$requireLogin = array_map('strtolower', $this->requireLogin);\n\n\t\t\tif (in_array($this->_action, $requireLogin) || $this->requireLogin == array('*')) {\n\t\t\t\t$login = $this->loginCredentials($this->loginOptions['type']);\n\n\t\t\t\tif ($login == null) {\n\t\t\t\t\t$controller->header($this->loginRequest());\n\n\t\t\t\t\tif (!empty($this->loginOptions['prompt'])) {\n\t\t\t\t\t\t$this->_callback($controller, $this->loginOptions['prompt']);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$this->blackHole($controller, 'login');\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (isset($this->loginOptions['login'])) {\n\t\t\t\t\t\t$this->_callback($controller, $this->loginOptions['login'], array($login));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (strtolower($this->loginOptions['type']) == 'digest') {\n\t\t\t\t\t\t\tif ($login && isset($this->loginUsers[$login['username']])) {\n\t\t\t\t\t\t\t\tif ($login['response'] == $this->generateDigestResponseHash($login)) {\n\t\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t$this->blackHole($controller, 'login');\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t!(in_array($login['username'], array_keys($this->loginUsers)) &&\n\t\t\t\t\t\t\t\t$this->loginUsers[$login['username']] == $login['password'])\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t$this->blackHole($controller, 'login');\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n/**\n * Validate submitted form\n *\n * @param object $controller Instantiating controller\n * @return bool true if submitted form is valid\n * @access protected\n */\n\tfunction _validatePost(&$controller) {\n\t\tif (empty($controller->data)) {\n\t\t\treturn true;\n\t\t}\n\t\t$data = $controller->data;\n\n\t\tif (!isset($data['_Token']) || !isset($data['_Token']['fields']) || !isset($data['_Token']['key'])) {\n\t\t\treturn false;\n\t\t}\n\t\t$token = $data['_Token']['key'];\n\n\t\tif ($this->Session->check('_Token')) {\n\t\t\t$tokenData = unserialize($this->Session->read('_Token'));\n\n\t\t\tif ($tokenData['expires'] < time() || $tokenData['key'] !== $token) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t$locked = null;\n\t\t$check = $controller->data;\n\t\t$token = urldecode($check['_Token']['fields']);\n\n\t\tif (strpos($token, ':')) {\n\t\t\tlist($token, $locked) = explode(':', $token, 2);\n\t\t}\n\t\tunset($check['_Token']);\n\n\t\t$locked = str_rot13($locked);\n\t\tif (preg_match('/(\\A|;|{|})O\\:[0-9]+/', $locked)) {\n\t\t\treturn false;\n\t\t}\n\n\t\t$lockedFields = array();\n\t\t$fields = Set::flatten($check);\n\t\t$fieldList = array_keys($fields);\n\t\t$locked = unserialize($locked);\n\t\t$multi = array();\n\n\t\tforeach ($fieldList as $i => $key) {\n\t\t\tif (preg_match('/\\.\\d+$/', $key)) {\n\t\t\t\t$multi[$i] = preg_replace('/\\.\\d+$/', '', $key);\n\t\t\t\tunset($fieldList[$i]);\n\t\t\t}\n\t\t}\n\t\tif (!empty($multi)) {\n\t\t\t$fieldList += array_unique($multi);\n\t\t}\n\n\t\tforeach ($fieldList as $i => $key) {\n\t\t\t$isDisabled = false;\n\t\t\t$isLocked = (is_array($locked) && in_array($key, $locked));\n\n\t\t\tif (!empty($this->disabledFields)) {\n\t\t\t\tforeach ((array)$this->disabledFields as $disabled) {\n\t\t\t\t\t$disabled = explode('.', $disabled);\n\t\t\t\t\t$field = array_values(array_intersect(explode('.', $key), $disabled));\n\t\t\t\t\t$isDisabled = ($field === $disabled);\n\t\t\t\t\tif ($isDisabled) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ($isDisabled || $isLocked) {\n\t\t\t\tunset($fieldList[$i]);\n\t\t\t\tif ($isLocked) {\n\t\t\t\t\t$lockedFields[$key] = $fields[$key];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsort($fieldList, SORT_STRING);\n\t\tksort($lockedFields, SORT_STRING);\n\n\t\t$fieldList += $lockedFields;\n\t\t$check = Security::hash(serialize($fieldList) . Configure::read('Security.salt'));\n\t\treturn ($token === $check);\n\t}\n\n/**\n * Add authentication key for new form posts\n *\n * @param object $controller Instantiating controller\n * @return bool Success\n * @access protected\n */\n\tfunction _generateToken(&$controller) {\n\t\tif (isset($controller->params['requested']) && $controller->params['requested'] === 1) {\n\t\t\tif ($this->Session->check('_Token')) {\n\t\t\t\t$tokenData = unserialize($this->Session->read('_Token'));\n\t\t\t\t$controller->params['_Token'] = $tokenData;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\t$authKey = Security::generateAuthKey();\n\t\t$expires = strtotime('+' . Security::inactiveMins() . ' minutes');\n\t\t$token = array(\n\t\t\t'key' => $authKey,\n\t\t\t'expires' => $expires,\n\t\t\t'allowedControllers' => $this->allowedControllers,\n\t\t\t'allowedActions' => $this->allowedActions,\n\t\t\t'disabledFields' => $this->disabledFields\n\t\t);\n\n\t\tif (!isset($controller->data)) {\n\t\t\t$controller->data = array();\n\t\t}\n\n\t\tif ($this->Session->check('_Token')) {\n\t\t\t$tokenData = unserialize($this->Session->read('_Token'));\n\t\t\t$valid = (\n\t\t\t\tisset($tokenData['expires']) &&\n\t\t\t\t$tokenData['expires'] > time() &&\n\t\t\t\tisset($tokenData['key'])\n\t\t\t);\n\n\t\t\tif ($valid) {\n\t\t\t\t$token['key'] = $tokenData['key'];\n\t\t\t}\n\t\t}\n\t\t$controller->params['_Token'] = $token;\n\t\t$this->Session->write('_Token', serialize($token));\n\t\treturn true;\n\t}\n\n/**\n * Sets the default login options for an HTTP-authenticated request\n *\n * @param array $options Default login options\n * @return void\n * @access protected\n */\n\tfunction _setLoginDefaults(&$options) {\n\t\t$options = array_merge(array(\n\t\t\t'type' => 'basic',\n\t\t\t'realm' => env('SERVER_NAME'),\n\t\t\t'qop' => 'auth',\n\t\t\t'nonce' => String::uuid()\n\t\t), array_filter($options));\n\t\t$options = array_merge(array('opaque' => md5($options['realm'])), $options);\n\t}\n\n/**\n * Calls a controller callback method\n *\n * @param object $controller Controller to run callback on\n * @param string $method Method to execute\n * @param array $params Parameters to send to method\n * @return mixed Controller callback method's response\n * @access protected\n */\n\tfunction _callback(&$controller, $method, $params = array()) {\n\t\tif (is_callable(array($controller, $method))) {\n\t\t\treturn call_user_func_array(array(&$controller, $method), empty($params) ? null : $params);\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n}\n", "<?php\n/**\n * SecurityComponentTest file\n *\n * PHP versions 4 and 5\n *\n * CakePHP(tm) Tests <http://book.cakephp.org/view/1196/Testing>\n * Copyright 2005-2010, Cake Software Foundation, Inc. (http://cakefoundation.org)\n *\n *  Licensed under The Open Group Test Suite License\n *  Redistributions of files must retain the above copyright notice.\n *\n * @copyright     Copyright 2005-2010, Cake Software Foundation, Inc. (http://cakefoundation.org)\n * @link          http://book.cakephp.org/view/1196/Testing CakePHP(tm) Tests\n * @package       cake\n * @subpackage    cake.tests.cases.libs.controller.components\n * @since         CakePHP(tm) v 1.2.0.5435\n * @license       http://www.opensource.org/licenses/opengroup.php The Open Group Test Suite License\n */\nApp::import('Component', 'Security');\n\n/**\n* TestSecurityComponent\n*\n* @package       cake\n* @subpackage    cake.tests.cases.libs.controller.components\n*/\nclass TestSecurityComponent extends SecurityComponent {\n\n/**\n * validatePost method\n *\n * @param Controller $controller\n * @return unknown\n */\n\tfunction validatePost(&$controller) {\n\t\treturn $this->_validatePost($controller);\n\t}\n}\n\n/**\n* SecurityTestController\n*\n* @package       cake\n* @subpackage    cake.tests.cases.libs.controller.components\n*/\nclass SecurityTestController extends Controller {\n\n/**\n * name property\n *\n * @var string 'SecurityTest'\n * @access public\n */\n\tvar $name = 'SecurityTest';\n\n/**\n * components property\n *\n * @var array\n * @access public\n */\n\tvar $components = array('Session', 'TestSecurity');\n\n/**\n * failed property\n *\n * @var bool false\n * @access public\n */\n\tvar $failed = false;\n\n/**\n * Used for keeping track of headers in test\n *\n * @var array\n * @access public\n */\n\tvar $testHeaders = array();\n\n/**\n * fail method\n *\n * @access public\n * @return void\n */\n\tfunction fail() {\n\t\t$this->failed = true;\n\t}\n\n/**\n * redirect method\n *\n * @param mixed $option\n * @param mixed $code\n * @param mixed $exit\n * @access public\n * @return void\n */\n\tfunction redirect($option, $code, $exit) {\n\t\treturn $code;\n\t}\n\n/**\n * Conveinence method for header()\n *\n * @param string $status\n * @return void\n * @access public\n */\n\tfunction header($status) {\n\t\t$this->testHeaders[] = $status;\n\t}\n}\n\n/**\n * SecurityComponentTest class\n *\n * @package       cake\n * @subpackage    cake.tests.cases.libs.controller.components\n */\nclass SecurityComponentTest extends CakeTestCase {\n\n/**\n * Controller property\n *\n * @var SecurityTestController\n * @access public\n */\n\tvar $Controller;\n\n/**\n * oldSalt property\n *\n * @var string\n * @access public\n */\n\tvar $oldSalt;\n\n/**\n * setUp method\n *\n * @access public\n * @return void\n */\n\tfunction startTest() {\n\t\t$this->Controller =& new SecurityTestController();\n\t\t$this->Controller->Component->init($this->Controller);\n\t\t$this->Controller->Security =& $this->Controller->TestSecurity;\n\t\t$this->Controller->Security->blackHoleCallback = 'fail';\n\t\t$this->oldSalt = Configure::read('Security.salt');\n\t\tConfigure::write('Security.salt', 'foo!');\n\t}\n\n/**\n * Tear-down method. Resets environment state.\n *\n * @access public\n * @return void\n */\n\tfunction endTest() {\n\t\tConfigure::write('Security.salt', $this->oldSalt);\n\t\t$this->Controller->Session->delete('_Token');\n\t\tunset($this->Controller->Security);\n\t\tunset($this->Controller->Component);\n\t\tunset($this->Controller);\n\t}\n\n/**\n * test that initalize can set properties.\n *\n * @return void\n */\n\tfunction testInitialize() {\n\t\t$settings = array(\n\t\t\t'requirePost' => array('edit', 'update'),\n\t\t\t'requireSecure' => array('update_account'),\n\t\t\t'requireGet' => array('index'),\n\t\t\t'validatePost' => false,\n\t\t\t'loginUsers' => array(\n\t\t\t\t'mark' => 'password'\n\t\t\t),\n\t\t\t'requireLogin' => array('login'),\n\t\t);\n\t\t$this->Controller->Security->initialize($this->Controller, $settings);\n\t\t$this->assertEqual($this->Controller->Security->requirePost, $settings['requirePost']);\n\t\t$this->assertEqual($this->Controller->Security->requireSecure, $settings['requireSecure']);\n\t\t$this->assertEqual($this->Controller->Security->requireGet, $settings['requireGet']);\n\t\t$this->assertEqual($this->Controller->Security->validatePost, $settings['validatePost']);\n\t\t$this->assertEqual($this->Controller->Security->loginUsers, $settings['loginUsers']);\n\t\t$this->assertEqual($this->Controller->Security->requireLogin, $settings['requireLogin']);\n\t}\n\n/**\n * testStartup method\n *\n * @access public\n * @return void\n */\n\tfunction testStartup() {\n\t\t$this->Controller->Security->startup($this->Controller);\n\t\t$result = $this->Controller->params['_Token']['key'];\n\t\t$this->assertNotNull($result);\n\t\t$this->assertTrue($this->Controller->Session->check('_Token'));\n\t}\n\n/**\n * testRequirePostFail method\n *\n * @access public\n * @return void\n */\n\tfunction testRequirePostFail() {\n\t\t$_SERVER['REQUEST_METHOD'] = 'GET';\n\t\t$this->Controller->action = 'posted';\n\t\t$this->Controller->Security->requirePost(array('posted'));\n\t\t$this->Controller->Security->startup($this->Controller);\n\t\t$this->assertTrue($this->Controller->failed);\n\t}\n\n/**\n * testRequirePostSucceed method\n *\n * @access public\n * @return void\n */\n\tfunction testRequirePostSucceed() {\n\t\t$_SERVER['REQUEST_METHOD'] = 'POST';\n\t\t$this->Controller->action = 'posted';\n\t\t$this->Controller->Security->requirePost('posted');\n\t\t$this->Controller->Security->startup($this->Controller);\n\t\t$this->assertFalse($this->Controller->failed);\n\t}\n\n/**\n * testRequireSecureFail method\n *\n * @access public\n * @return void\n */\n\tfunction testRequireSecureFail() {\n\t\t$_SERVER['HTTPS'] = 'off';\n\t\t$_SERVER['REQUEST_METHOD'] = 'POST';\n\t\t$this->Controller->action = 'posted';\n\t\t$this->Controller->Security->requireSecure(array('posted'));\n\t\t$this->Controller->Security->startup($this->Controller);\n\t\t$this->assertTrue($this->Controller->failed);\n\t}\n\n/**\n * testRequireSecureSucceed method\n *\n * @access public\n * @return void\n */\n\tfunction testRequireSecureSucceed() {\n\t\t$_SERVER['REQUEST_METHOD'] = 'Secure';\n\t\t$this->Controller->action = 'posted';\n\t\t$_SERVER['HTTPS'] = 'on';\n\t\t$this->Controller->Security->requireSecure('posted');\n\t\t$this->Controller->Security->startup($this->Controller);\n\t\t$this->assertFalse($this->Controller->failed);\n\t}\n\n/**\n * testRequireAuthFail method\n *\n * @access public\n * @return void\n */\n\tfunction testRequireAuthFail() {\n\t\t$_SERVER['REQUEST_METHOD'] = 'AUTH';\n\t\t$this->Controller->action = 'posted';\n\t\t$this->Controller->data = array('username' => 'willy', 'password' => 'somePass');\n\t\t$this->Controller->Security->requireAuth(array('posted'));\n\t\t$this->Controller->Security->startup($this->Controller);\n\t\t$this->assertTrue($this->Controller->failed);\n\n\t\t$this->Controller->Session->write('_Token', serialize(array('allowedControllers' => array())));\n\t\t$this->Controller->data = array('username' => 'willy', 'password' => 'somePass');\n\t\t$this->Controller->action = 'posted';\n\t\t$this->Controller->Security->requireAuth('posted');\n\t\t$this->Controller->Security->startup($this->Controller);\n\t\t$this->assertTrue($this->Controller->failed);\n\n\t\t$this->Controller->Session->write('_Token', serialize(array(\n\t\t\t'allowedControllers' => array('SecurityTest'), 'allowedActions' => array('posted2')\n\t\t)));\n\t\t$this->Controller->data = array('username' => 'willy', 'password' => 'somePass');\n\t\t$this->Controller->action = 'posted';\n\t\t$this->Controller->Security->requireAuth('posted');\n\t\t$this->Controller->Security->startup($this->Controller);\n\t\t$this->assertTrue($this->Controller->failed);\n\t}\n\n/**\n * testRequireAuthSucceed method\n *\n * @access public\n * @return void\n */\n\tfunction testRequireAuthSucceed() {\n\t\t$_SERVER['REQUEST_METHOD'] = 'AUTH';\n\t\t$this->Controller->action = 'posted';\n\t\t$this->Controller->Security->requireAuth('posted');\n\t\t$this->Controller->Security->startup($this->Controller);\n\t\t$this->assertFalse($this->Controller->failed);\n\n\t\t$this->Controller->Security->Session->write('_Token', serialize(array(\n\t\t\t'allowedControllers' => array('SecurityTest'), 'allowedActions' => array('posted')\n\t\t)));\n\t\t$this->Controller->params['controller'] = 'SecurityTest';\n\t\t$this->Controller->params['action'] = 'posted';\n\n\t\t$this->Controller->data = array(\n\t\t\t'username' => 'willy', 'password' => 'somePass', '_Token' => ''\n\t\t);\n\t\t$this->Controller->action = 'posted';\n\t\t$this->Controller->Security->requireAuth('posted');\n\t\t$this->Controller->Security->startup($this->Controller);\n\t\t$this->assertFalse($this->Controller->failed);\n\t}\n\n/**\n * testRequirePostSucceedWrongMethod method\n *\n * @access public\n * @return void\n */\n\tfunction testRequirePostSucceedWrongMethod() {\n\t\t$_SERVER['REQUEST_METHOD'] = 'GET';\n\t\t$this->Controller->action = 'getted';\n\t\t$this->Controller->Security->requirePost('posted');\n\t\t$this->Controller->Security->startup($this->Controller);\n\t\t$this->assertFalse($this->Controller->failed);\n\t}\n\n/**\n * testRequireGetFail method\n *\n * @access public\n * @return void\n */\n\tfunction testRequireGetFail() {\n\t\t$_SERVER['REQUEST_METHOD'] = 'POST';\n\t\t$this->Controller->action = 'getted';\n\t\t$this->Controller->Security->requireGet(array('getted'));\n\t\t$this->Controller->Security->startup($this->Controller);\n\t\t$this->assertTrue($this->Controller->failed);\n\t}\n\n/**\n * testRequireGetSucceed method\n *\n * @access public\n * @return void\n */\n\tfunction testRequireGetSucceed() {\n\t\t$_SERVER['REQUEST_METHOD'] = 'GET';\n\t\t$this->Controller->action = 'getted';\n\t\t$this->Controller->Security->requireGet('getted');\n\t\t$this->Controller->Security->startup($this->Controller);\n\t\t$this->assertFalse($this->Controller->failed);\n\t}\n\n/**\n * testRequireLogin method\n *\n * @access public\n * @return void\n */\n\tfunction testRequireLogin() {\n\t\t$this->Controller->action = 'posted';\n\t\t$this->Controller->Security->requireLogin(\n\t\t\t'posted',\n\t\t\tarray('type' => 'basic', 'users' => array('admin' => 'password'))\n\t\t);\n\t\t$_SERVER['PHP_AUTH_USER'] = 'admin';\n\t\t$_SERVER['PHP_AUTH_PW'] = 'password';\n\t\t$this->Controller->Security->startup($this->Controller);\n\t\t$this->assertFalse($this->Controller->failed);\n\n\n\t\t$this->Controller->action = 'posted';\n\t\t$this->Controller->Security->requireLogin(\n\t\t\tarray('posted'),\n\t\t\tarray('type' => 'basic', 'users' => array('admin' => 'password'))\n\t\t);\n\t\t$_SERVER['PHP_AUTH_USER'] = 'admin2';\n\t\t$_SERVER['PHP_AUTH_PW'] = 'password';\n\t\t$this->Controller->Security->startup($this->Controller);\n\t\t$this->assertTrue($this->Controller->failed);\n\n\t\t$this->Controller->action = 'posted';\n\t\t$this->Controller->Security->requireLogin(\n\t\t\t'posted',\n\t\t\tarray('type' => 'basic', 'users' => array('admin' => 'password'))\n\t\t);\n\t\t$_SERVER['PHP_AUTH_USER'] = 'admin';\n\t\t$_SERVER['PHP_AUTH_PW'] = 'password2';\n\t\t$this->Controller->Security->startup($this->Controller);\n\t\t$this->assertTrue($this->Controller->failed);\n\t}\n\n/**\n * testDigestAuth method\n *\n * @access public\n * @return void\n */\n\tfunction testDigestAuth() {\n\t\t$skip = $this->skipIf((version_compare(PHP_VERSION, '5.1') == -1) XOR (!function_exists('apache_request_headers')),\n\t\t\t\"%s Cannot run Digest Auth test for PHP versions < 5.1\"\n\t\t);\n\n\t\tif ($skip) {\n\t\t\treturn;\n\t\t}\n\n\t\t$this->Controller->action = 'posted';\n\t\t$_SERVER['PHP_AUTH_DIGEST'] = $digest = <<<DIGEST\n\t\tDigest username=\"Mufasa\",\n\t\trealm=\"testrealm@host.com\",\n\t\tnonce=\"dcd98b7102dd2f0e8b11d0f600bfb0c093\",\n\t\turi=\"/dir/index.html\",\n\t\tqop=auth,\n\t\tnc=00000001,\n\t\tcnonce=\"0a4f113b\",\n\t\tresponse=\"460d0d3c6867c2f1ab85b1ada1aece48\",\n\t\topaque=\"5ccc069c403ebaf9f0171e9517f40e41\"\nDIGEST;\n\t\t$this->Controller->Security->requireLogin('posted', array(\n\t\t\t'type' => 'digest', 'users' => array('Mufasa' => 'password'),\n\t\t\t'realm' => 'testrealm@host.com'\n\t\t));\n\t\t$this->Controller->Security->startup($this->Controller);\n\t\t$this->assertFalse($this->Controller->failed);\n\t}\n\n/**\n * testRequireGetSucceedWrongMethod method\n *\n * @access public\n * @return void\n */\n\tfunction testRequireGetSucceedWrongMethod() {\n\t\t$_SERVER['REQUEST_METHOD'] = 'POST';\n\t\t$this->Controller->action = 'posted';\n\t\t$this->Controller->Security->requireGet('getted');\n\t\t$this->Controller->Security->startup($this->Controller);\n\t\t$this->assertFalse($this->Controller->failed);\n\t}\n\n/**\n * testRequirePutFail method\n *\n * @access public\n * @return void\n */\n\tfunction testRequirePutFail() {\n\t\t$_SERVER['REQUEST_METHOD'] = 'POST';\n\t\t$this->Controller->action = 'putted';\n\t\t$this->Controller->Security->requirePut(array('putted'));\n\t\t$this->Controller->Security->startup($this->Controller);\n\t\t$this->assertTrue($this->Controller->failed);\n\t}\n\n/**\n * testRequirePutSucceed method\n *\n * @access public\n * @return void\n */\n\tfunction testRequirePutSucceed() {\n\t\t$_SERVER['REQUEST_METHOD'] = 'PUT';\n\t\t$this->Controller->action = 'putted';\n\t\t$this->Controller->Security->requirePut('putted');\n\t\t$this->Controller->Security->startup($this->Controller);\n\t\t$this->assertFalse($this->Controller->failed);\n\t}\n\n/**\n * testRequirePutSucceedWrongMethod method\n *\n * @access public\n * @return void\n */\n\tfunction testRequirePutSucceedWrongMethod() {\n\t\t$_SERVER['REQUEST_METHOD'] = 'POST';\n\t\t$this->Controller->action = 'posted';\n\t\t$this->Controller->Security->requirePut('putted');\n\t\t$this->Controller->Security->startup($this->Controller);\n\t\t$this->assertFalse($this->Controller->failed);\n\t}\n\n/**\n * testRequireDeleteFail method\n *\n * @access public\n * @return void\n */\n\tfunction testRequireDeleteFail() {\n\t\t$_SERVER['REQUEST_METHOD'] = 'POST';\n\t\t$this->Controller->action = 'deleted';\n\t\t$this->Controller->Security->requireDelete(array('deleted', 'other_method'));\n\t\t$this->Controller->Security->startup($this->Controller);\n\t\t$this->assertTrue($this->Controller->failed);\n\t}\n\n/**\n * testRequireDeleteSucceed method\n *\n * @access public\n * @return void\n */\n\tfunction testRequireDeleteSucceed() {\n\t\t$_SERVER['REQUEST_METHOD'] = 'DELETE';\n\t\t$this->Controller->action = 'deleted';\n\t\t$this->Controller->Security->requireDelete('deleted');\n\t\t$this->Controller->Security->startup($this->Controller);\n\t\t$this->assertFalse($this->Controller->failed);\n\t}\n\n/**\n * testRequireDeleteSucceedWrongMethod method\n *\n * @access public\n * @return void\n */\n\tfunction testRequireDeleteSucceedWrongMethod() {\n\t\t$_SERVER['REQUEST_METHOD'] = 'POST';\n\t\t$this->Controller->action = 'posted';\n\t\t$this->Controller->Security->requireDelete('deleted');\n\t\t$this->Controller->Security->startup($this->Controller);\n\t\t$this->assertFalse($this->Controller->failed);\n\t}\n\n/**\n * testRequireLoginSettings method\n *\n * @access public\n * @return void\n */\n\tfunction testRequireLoginSettings() {\n\t\t$this->Controller->Security->requireLogin(\n\t\t\t'add', 'edit',\n\t\t\tarray('type' => 'basic', 'users' => array('admin' => 'password'))\n\t\t);\n\t\t$this->assertEqual($this->Controller->Security->requireLogin, array('add', 'edit'));\n\t\t$this->assertEqual($this->Controller->Security->loginUsers, array('admin' => 'password'));\n\t}\n\n/**\n * testRequireLoginAllActions method\n *\n * @access public\n * @return void\n */\n\tfunction testRequireLoginAllActions() {\n\t\t$this->Controller->Security->requireLogin(\n\t\t\tarray('type' => 'basic', 'users' => array('admin' => 'password'))\n\t\t);\n\t\t$this->assertEqual($this->Controller->Security->requireLogin, array('*'));\n\t\t$this->assertEqual($this->Controller->Security->loginUsers, array('admin' => 'password'));\n\t}\n\n/**\n * Simple hash validation test\n *\n * @access public\n * @return void\n */\n\tfunction testValidatePost() {\n\t\t$this->Controller->Security->startup($this->Controller);\n\t\t$key = $this->Controller->params['_Token']['key'];\n\t\t$fields = 'a5475372b40f6e3ccbf9f8af191f20e1642fd877%3An%3A1%3A%7Bv%3A0%3B';\n\t\t$fields .= 'f%3A11%3A%22Zbqry.inyvq%22%3B%7D';\n\n\t\t$this->Controller->data = array(\n\t\t\t'Model' => array('username' => 'nate', 'password' => 'foo', 'valid' => '0'),\n\t\t\t'_Token' => compact('key', 'fields')\n\t\t);\n\t\t$this->assertTrue($this->Controller->Security->validatePost($this->Controller));\n\t}\n\n/**\n * test that validatePost fails if any of its required fields are missing.\n *\n * @return void\n */\n\tfunction testValidatePostFormHacking() {\n\t\t$this->Controller->Security->startup($this->Controller);\n\t\t$key = $this->Controller->params['_Token']['key'];\n\t\t$fields = 'a5475372b40f6e3ccbf9f8af191f20e1642fd877%3An%3A1%3A%7Bv%3A0%3B';\n\t\t$fields .= 'f%3A11%3A%22Zbqry.inyvq%22%3B%7D';\n\n\t\t$this->Controller->data = array(\n\t\t\t'Model' => array('username' => 'nate', 'password' => 'foo', 'valid' => '0'),\n\t\t\t'_Token' => compact('key')\n\t\t);\n\t\t$result = $this->Controller->Security->validatePost($this->Controller);\n\t\t$this->assertFalse($result, 'validatePost passed when fields were missing. %s');\n\n\t\t$this->Controller->data = array(\n\t\t\t'Model' => array('username' => 'nate', 'password' => 'foo', 'valid' => '0'),\n\t\t\t'_Token' => compact('fields')\n\t\t);\n\t\t$result = $this->Controller->Security->validatePost($this->Controller);\n\t\t$this->assertFalse($result, 'validatePost passed when key was missing. %s');\n\t}\n\n/**\n * Test that objects can't be passed into the serialized string. This was a vector for RFI and LFI \n * attacks. Thanks to Felix Wilhelm\n *\n * @return void\n */\n\tfunction testValidatePostObjectDeserialize() {\n\t\t$this->Controller->Security->startup($this->Controller);\n\t\t$key = $this->Controller->params['_Token']['key'];\n\t\t$fields = 'a5475372b40f6e3ccbf9f8af191f20e1642fd877';\n\n\t\t// a corrupted serialized object, so we can see if it ever gets to deserialize\n\t\t$attack = 'O:3:\"App\":1:{s:5:\"__map\";a:1:{s:3:\"foo\";s:7:\"Hacked!\";s:1:\"fail\"}}';\n\t\t$fields .= urlencode(':' . str_rot13($attack));\n\n\t\t$this->Controller->data = array(\n\t\t\t'Model' => array('username' => 'mark', 'password' => 'foo', 'valid' => '0'),\n\t\t\t'_Token' => compact('key', 'fields')\n\t\t);\n\t\t$result = $this->Controller->Security->validatePost($this->Controller);\n\t\t$this->assertFalse($result, 'validatePost passed when key was missing. %s');\n\t}\n\n/**\n * Tests validation of checkbox arrays\n *\n * @access public\n * @return void\n */\n\tfunction testValidatePostArray() {\n\t\t$this->Controller->Security->startup($this->Controller);\n\t\t$key = $this->Controller->params['_Token']['key'];\n\t\t$fields = 'f7d573650a295b94e0938d32b323fde775e5f32b%3An%3A0%3A%7B%7D';\n\n\t\t$this->Controller->data = array(\n\t\t\t'Model' => array('multi_field' => array('1', '3')),\n\t\t\t'_Token' => compact('key', 'fields')\n\t\t);\n\t\t$this->assertTrue($this->Controller->Security->validatePost($this->Controller));\n\t}\n\n/**\n * testValidatePostNoModel method\n *\n * @access public\n * @return void\n */\n\tfunction testValidatePostNoModel() {\n\t\t$this->Controller->Security->startup($this->Controller);\n\t\t$key = $this->Controller->params['_Token']['key'];\n\t\t$fields = '540ac9c60d323c22bafe997b72c0790f39a8bdef%3An%3A0%3A%7B%7D';\n\n\t\t$this->Controller->data = array(\n\t\t\t'anything' => 'some_data',\n\t\t\t'_Token' => compact('key', 'fields')\n\t\t);\n\n\t\t$result = $this->Controller->Security->validatePost($this->Controller);\n\t\t$this->assertTrue($result);\n\t}\n\n/**\n * testValidatePostSimple method\n *\n * @access public\n * @return void\n */\n\tfunction testValidatePostSimple() {\n\t\t$this->Controller->Security->startup($this->Controller);\n\t\t$key = $this->Controller->params['_Token']['key'];\n\t\t$fields = '69f493434187b867ea14b901fdf58b55d27c935d%3An%3A0%3A%7B%7D';\n\n\t\t$this->Controller->data = $data = array(\n\t\t\t'Model' => array('username' => '', 'password' => ''),\n\t\t\t'_Token' => compact('key', 'fields')\n\t\t);\n\n\t\t$result = $this->Controller->Security->validatePost($this->Controller);\n\t\t$this->assertTrue($result);\n\t}\n\n/**\n * Tests hash validation for multiple records, including locked fields\n *\n * @access public\n * @return void\n */\n\tfunction testValidatePostComplex() {\n\t\t$this->Controller->Security->startup($this->Controller);\n\t\t$key = $this->Controller->params['_Token']['key'];\n\t\t$fields = 'c9118120e680a7201b543f562e5301006ccfcbe2%3An%3A2%3A%7Bv%3A0%3Bf%3A14%3A%';\n\t\t$fields .= '22Nqqerffrf.0.vq%22%3Bv%3A1%3Bf%3A14%3A%22Nqqerffrf.1.vq%22%3B%7D';\n\n\t\t$this->Controller->data = array(\n\t\t\t'Addresses' => array(\n\t\t\t\t'0' => array(\n\t\t\t\t\t'id' => '123456', 'title' => '', 'first_name' => '', 'last_name' => '',\n\t\t\t\t\t'address' => '', 'city' => '', 'phone' => '', 'primary' => ''\n\t\t\t\t),\n\t\t\t\t'1' => array(\n\t\t\t\t\t'id' => '654321', 'title' => '', 'first_name' => '', 'last_name' => '',\n\t\t\t\t\t'address' => '', 'city' => '', 'phone' => '', 'primary' => ''\n\t\t\t\t)\n\t\t\t),\n\t\t\t'_Token' => compact('key', 'fields')\n\t\t);\n\t\t$result = $this->Controller->Security->validatePost($this->Controller);\n\t\t$this->assertTrue($result);\n\t}\n\n/**\n * test ValidatePost with multiple select elements.\n *\n * @return void\n */\n\tfunction testValidatePostMultipleSelect() {\n\t\t$this->Controller->Security->startup($this->Controller);\n\t\t$key = $this->Controller->params['_Token']['key'];\n\t\t$fields = '422cde416475abc171568be690a98cad20e66079%3An%3A0%3A%7B%7D';\n\n\t\t$this->Controller->data = array(\n\t\t\t'Tag' => array('Tag' => array(1, 2)),\n\t\t\t'_Token' => compact('key', 'fields'),\n\t\t);\n\t\t$result = $this->Controller->Security->validatePost($this->Controller);\n\t\t$this->assertTrue($result);\n\n\t\t$this->Controller->data = array(\n\t\t\t'Tag' => array('Tag' => array(1, 2, 3)),\n\t\t\t'_Token' => compact('key', 'fields'),\n\t\t);\n\t\t$result = $this->Controller->Security->validatePost($this->Controller);\n\t\t$this->assertTrue($result);\n\n\t\t$this->Controller->data = array(\n\t\t\t'Tag' => array('Tag' => array(1, 2, 3, 4)),\n\t\t\t'_Token' => compact('key', 'fields'),\n\t\t);\n\t\t$result = $this->Controller->Security->validatePost($this->Controller);\n\t\t$this->assertTrue($result);\n\n\t\t$fields = '19464422eafe977ee729c59222af07f983010c5f%3An%3A0%3A%7B%7D';\n\t\t$this->Controller->data = array(\n\t\t\t'User.password' => 'bar', 'User.name' => 'foo', 'User.is_valid' => '1',\n\t\t\t'Tag' => array('Tag' => array(1)), '_Token' => compact('key', 'fields'),\n\t\t);\n\t\t$result = $this->Controller->Security->validatePost($this->Controller);\n\t\t$this->assertTrue($result);\n\t}\n\n/**\n * testValidatePostCheckbox method\n *\n * First block tests un-checked checkbox\n * Second block tests checked checkbox\n *\n * @access public\n * @return void\n */\n\tfunction testValidatePostCheckbox() {\n\t\t$this->Controller->Security->startup($this->Controller);\n\t\t$key = $this->Controller->params['_Token']['key'];\n\t\t$fields = 'a5475372b40f6e3ccbf9f8af191f20e1642fd877%3An%3A1%3A%7Bv%3A0%';\n\t\t$fields .= '3Bf%3A11%3A%22Zbqry.inyvq%22%3B%7D';\n\n\t\t$this->Controller->data = array(\n\t\t\t'Model' => array('username' => '', 'password' => '', 'valid' => '0'),\n\t\t\t'_Token' => compact('key', 'fields')\n\t\t);\n\n\t\t$result = $this->Controller->Security->validatePost($this->Controller);\n\t\t$this->assertTrue($result);\n\n\t\t$fields = '874439ca69f89b4c4a5f50fb9c36ff56a28f5d42%3An%3A0%3A%7B%7D';\n\n\t\t$this->Controller->data = array(\n\t\t\t'Model' => array('username' => '', 'password' => '', 'valid' => '0'),\n\t\t\t'_Token' => compact('key', 'fields')\n\t\t);\n\n\t\t$result = $this->Controller->Security->validatePost($this->Controller);\n\t\t$this->assertTrue($result);\n\n\n\t\t$this->Controller->data = array();\n\t\t$this->Controller->Security->startup($this->Controller);\n\t\t$key = $this->Controller->params['_Token']['key'];\n\n\t\t$this->Controller->data = $data = array(\n\t\t\t'Model' => array('username' => '', 'password' => '', 'valid' => '0'),\n\t\t\t'_Token' => compact('key', 'fields')\n\t\t);\n\n\t\t$result = $this->Controller->Security->validatePost($this->Controller);\n\t\t$this->assertTrue($result);\n\t}\n\n/**\n * testValidatePostHidden method\n *\n * @access public\n * @return void\n */\n\tfunction testValidatePostHidden() {\n\t\t$this->Controller->Security->startup($this->Controller);\n\t\t$key = $this->Controller->params['_Token']['key'];\n\t\t$fields = '51ccd8cb0997c7b3d4523ecde5a109318405ef8c%3An%3A2%3A%7Bv%3A0%3Bf%3A12%3A';\n\t\t$fields .= '%22Zbqry.uvqqra%22%3Bv%3A1%3Bf%3A18%3A%22Zbqry.bgure_uvqqra%22%3B%7D';\n\n\t\t$this->Controller->data = array(\n\t\t\t'Model' => array(\n\t\t\t\t'username' => '', 'password' => '', 'hidden' => '0',\n\t\t\t\t'other_hidden' => 'some hidden value'\n\t\t\t),\n\t\t\t'_Token' => compact('key', 'fields')\n\t\t);\n\t\t$result = $this->Controller->Security->validatePost($this->Controller);\n\t\t$this->assertTrue($result);\n\t}\n\n/**\n * testValidatePostWithDisabledFields method\n *\n * @access public\n * @return void\n */\n\tfunction testValidatePostWithDisabledFields() {\n\t\t$this->Controller->Security->disabledFields = array('Model.username', 'Model.password');\n\t\t$this->Controller->Security->startup($this->Controller);\n\t\t$key = $this->Controller->params['_Token']['key'];\n\t\t$fields = 'ef1082968c449397bcd849f963636864383278b1%3An%3A1%3A%7Bv%';\n\t\t$fields .= '3A0%3Bf%3A12%3A%22Zbqry.uvqqra%22%3B%7D';\n\n\t\t$this->Controller->data = array(\n\t\t\t'Model' => array(\n\t\t\t\t'username' => '', 'password' => '', 'hidden' => '0'\n\t\t\t),\n\t\t\t'_Token' => compact('fields', 'key')\n\t\t);\n\n\t\t$result = $this->Controller->Security->validatePost($this->Controller);\n\t\t$this->assertTrue($result);\n\t}\n\n/**\n * testValidateHiddenMultipleModel method\n *\n * @access public\n * @return void\n */\n\tfunction testValidateHiddenMultipleModel() {\n\t\t$this->Controller->Security->startup($this->Controller);\n\t\t$key = $this->Controller->params['_Token']['key'];\n\t\t$fields = 'a2d01072dc4660eea9d15007025f35a7a5b58e18%3An%3A3%3A%7Bv%3A0%3Bf%3A11';\n\t\t$fields .= '%3A%22Zbqry.inyvq%22%3Bv%3A1%3Bf%3A12%3A%22Zbqry2.inyvq%22%3Bv%3A2%';\n\t\t$fields .= '3Bf%3A12%3A%22Zbqry3.inyvq%22%3B%7D';\n\n\t\t$this->Controller->data = array(\n\t\t\t'Model' => array('username' => '', 'password' => '', 'valid' => '0'),\n\t\t\t'Model2' => array('valid' => '0'),\n\t\t\t'Model3' => array('valid' => '0'),\n\t\t\t'_Token' => compact('key', 'fields')\n\t\t);\n\t\t$result = $this->Controller->Security->validatePost($this->Controller);\n\t\t$this->assertTrue($result);\n\t}\n\n/**\n * testLoginValidation method\n *\n * @access public\n * @return void\n */\n\tfunction testLoginValidation() {\n\n\t}\n\n/**\n * testValidateHasManyModel method\n *\n * @access public\n * @return void\n */\n\tfunction testValidateHasManyModel() {\n\t\t$this->Controller->Security->startup($this->Controller);\n\t\t$key = $this->Controller->params['_Token']['key'];\n\t\t$fields = '51e3b55a6edd82020b3f29c9ae200e14bbeb7ee5%3An%3A4%3A%7Bv%3A0%3Bf%3A14%3A%2';\n\t\t$fields .= '2Zbqry.0.uvqqra%22%3Bv%3A1%3Bf%3A13%3A%22Zbqry.0.inyvq%22%3Bv%3A2%3Bf%3';\n\t\t$fields .= 'A14%3A%22Zbqry.1.uvqqra%22%3Bv%3A3%3Bf%3A13%3A%22Zbqry.1.inyvq%22%3B%7D';\n\n\t\t$this->Controller->data = array(\n\t\t\t'Model' => array(\n\t\t\t\tarray(\n\t\t\t\t\t'username' => 'username', 'password' => 'password',\n\t\t\t\t\t'hidden' => 'value', 'valid' => '0'\n\t\t\t\t),\n\t\t\t\tarray(\n\t\t\t\t\t'username' => 'username', 'password' => 'password',\n\t\t\t\t\t'hidden' => 'value', 'valid' => '0'\n\t\t\t\t)\n\t\t\t),\n\t\t\t'_Token' => compact('key', 'fields')\n\t\t);\n\n\t\t$result = $this->Controller->Security->validatePost($this->Controller);\n\t\t$this->assertTrue($result);\n\t}\n\n/**\n * testValidateHasManyRecordsPass method\n *\n * @access public\n * @return void\n */\n\tfunction testValidateHasManyRecordsPass() {\n\t\t$this->Controller->Security->startup($this->Controller);\n\t\t$key = $this->Controller->params['_Token']['key'];\n\t\t$fields = '7a203edb3d345bbf38fe0dccae960da8842e11d7%3An%3A4%3A%7Bv%3A0%3Bf%3A12%3A%2';\n\t\t$fields .= '2Nqqerff.0.vq%22%3Bv%3A1%3Bf%3A17%3A%22Nqqerff.0.cevznel%22%3Bv%3A2%3Bf%';\n\t\t$fields .= '3A12%3A%22Nqqerff.1.vq%22%3Bv%3A3%3Bf%3A17%3A%22Nqqerff.1.cevznel%22%3B%7D';\n\n\t\t$this->Controller->data = array(\n\t\t\t'Address' => array(\n\t\t\t\t0 => array(\n\t\t\t\t\t'id' => '123',\n\t\t\t\t\t'title' => 'home',\n\t\t\t\t\t'first_name' => 'Bilbo',\n\t\t\t\t\t'last_name' => 'Baggins',\n\t\t\t\t\t'address' => '23 Bag end way',\n\t\t\t\t\t'city' => 'the shire',\n\t\t\t\t\t'phone' => 'N/A',\n\t\t\t\t\t'primary' => '1',\n\t\t\t\t),\n\t\t\t\t1 => array(\n\t\t\t\t\t'id' => '124',\n\t\t\t\t\t'title' => 'home',\n\t\t\t\t\t'first_name' => 'Frodo',\n\t\t\t\t\t'last_name' => 'Baggins',\n\t\t\t\t\t'address' => '50 Bag end way',\n\t\t\t\t\t'city' => 'the shire',\n\t\t\t\t\t'phone' => 'N/A',\n\t\t\t\t\t'primary' => '1'\n\t\t\t\t)\n\t\t\t),\n\t\t\t'_Token' => compact('key', 'fields')\n\t\t);\n\n\t\t$result = $this->Controller->Security->validatePost($this->Controller);\n\t\t$this->assertTrue($result);\n\t}\n\n/**\n * testValidateHasManyRecords method\n *\n * validatePost should fail, hidden fields have been changed.\n *\n * @access public\n * @return void\n */\n\tfunction testValidateHasManyRecordsFail() {\n\t\t$this->Controller->Security->startup($this->Controller);\n\t\t$key = $this->Controller->params['_Token']['key'];\n\t\t$fields = '7a203edb3d345bbf38fe0dccae960da8842e11d7%3An%3A4%3A%7Bv%3A0%3Bf%3A12%3A%2';\n\t\t$fields .= '2Nqqerff.0.vq%22%3Bv%3A1%3Bf%3A17%3A%22Nqqerff.0.cevznel%22%3Bv%3A2%3Bf%';\n\t\t$fields .= '3A12%3A%22Nqqerff.1.vq%22%3Bv%3A3%3Bf%3A17%3A%22Nqqerff.1.cevznel%22%3B%7D';\n\n\t\t$this->Controller->data = array(\n\t\t\t'Address' => array(\n\t\t\t\t0 => array(\n\t\t\t\t\t'id' => '123',\n\t\t\t\t\t'title' => 'home',\n\t\t\t\t\t'first_name' => 'Bilbo',\n\t\t\t\t\t'last_name' => 'Baggins',\n\t\t\t\t\t'address' => '23 Bag end way',\n\t\t\t\t\t'city' => 'the shire',\n\t\t\t\t\t'phone' => 'N/A',\n\t\t\t\t\t'primary' => '5',\n\t\t\t\t),\n\t\t\t\t1 => array(\n\t\t\t\t\t'id' => '124',\n\t\t\t\t\t'title' => 'home',\n\t\t\t\t\t'first_name' => 'Frodo',\n\t\t\t\t\t'last_name' => 'Baggins',\n\t\t\t\t\t'address' => '50 Bag end way',\n\t\t\t\t\t'city' => 'the shire',\n\t\t\t\t\t'phone' => 'N/A',\n\t\t\t\t\t'primary' => '1'\n\t\t\t\t)\n\t\t\t),\n\t\t\t'_Token' => compact('key', 'fields')\n\t\t);\n\n\t\t$result = $this->Controller->Security->validatePost($this->Controller);\n\t\t$this->assertFalse($result);\n\t}\n\n/**\n * testLoginRequest method\n *\n * @access public\n * @return void\n */\n\tfunction testLoginRequest() {\n\t\t$this->Controller->Security->startup($this->Controller);\n\t\t$realm = 'cakephp.org';\n\t\t$options = array('realm' => $realm, 'type' => 'basic');\n\t\t$result = $this->Controller->Security->loginRequest($options);\n\t\t$expected = 'WWW-Authenticate: Basic realm=\"'.$realm.'\"';\n\t\t$this->assertEqual($result, $expected);\n\n\t\t$this->Controller->Security->startup($this->Controller);\n\t\t$options = array('realm' => $realm, 'type' => 'digest');\n\t\t$result = $this->Controller->Security->loginRequest($options);\n\t\t$this->assertPattern('/realm=\"'.$realm.'\"/', $result);\n\t\t$this->assertPattern('/qop=\"auth\"/', $result);\n\t}\n\n/**\n * testGenerateDigestResponseHash method\n *\n * @access public\n * @return void\n */\n\tfunction testGenerateDigestResponseHash() {\n\t\t$this->Controller->Security->startup($this->Controller);\n\t\t$realm = 'cakephp.org';\n\t\t$loginData = array('realm' => $realm, 'users' => array('Willy Smith' => 'password'));\n\t\t$this->Controller->Security->requireLogin($loginData);\n\n\t\t$data = array(\n\t\t\t'username' => 'Willy Smith',\n\t\t\t'password' => 'password',\n\t\t\t'nonce' => String::uuid(),\n\t\t\t'nc' => 1,\n\t\t\t'cnonce' => 1,\n\t\t\t'realm' => $realm,\n\t\t\t'uri' => 'path_to_identifier',\n\t\t\t'qop' => 'testme'\n\t\t);\n\t\t$_SERVER['REQUEST_METHOD'] = 'POST';\n\n\t\t$result = $this->Controller->Security->generateDigestResponseHash($data);\n\t\t$expected = md5(\n\t\t\tmd5($data['username'] . ':' . $loginData['realm'] . ':' . $data['password']) . ':' .\n\t\t\t$data['nonce'] . ':' . $data['nc'] . ':' . $data['cnonce'] . ':' . $data['qop'] . ':' .\n\t\t\tmd5(env('REQUEST_METHOD') . ':' . $data['uri'])\n\t\t);\n\t\t$this->assertIdentical($result, $expected);\n\t}\n\n/**\n * testLoginCredentials method\n *\n * @access public\n * @return void\n */\n\tfunction testLoginCredentials() {\n\t\t$this->Controller->Security->startup($this->Controller);\n\t\t$_SERVER['PHP_AUTH_USER'] = $user = 'Willy Test';\n\t\t$_SERVER['PHP_AUTH_PW'] = $pw = 'some password for the nice test';\n\n\t\t$result = $this->Controller->Security->loginCredentials('basic');\n\t\t$expected = array('username' => $user, 'password' => $pw);\n\t\t$this->assertIdentical($result, $expected);\n\n\t\tif (version_compare(PHP_VERSION, '5.1') != -1) {\n\t\t\t$_SERVER['PHP_AUTH_DIGEST'] = $digest = <<<DIGEST\n\t\t\t\tDigest username=\"Mufasa\",\n\t\t\t\trealm=\"testrealm@host.com\",\n\t\t\t\tnonce=\"dcd98b7102dd2f0e8b11d0f600bfb0c093\",\n\t\t\t\turi=\"/dir/index.html\",\n\t\t\t\tqop=auth,\n\t\t\t\tnc=00000001,\n\t\t\t\tcnonce=\"0a4f113b\",\n\t\t\t\tresponse=\"6629fae49393a05397450978507c4ef1\",\n\t\t\t\topaque=\"5ccc069c403ebaf9f0171e9517f40e41\"\nDIGEST;\n\t\t\t$expected = array(\n\t\t\t\t'username' => 'Mufasa',\n\t\t\t\t'realm' => 'testrealm@host.com',\n\t\t\t\t'nonce' => 'dcd98b7102dd2f0e8b11d0f600bfb0c093',\n\t\t\t\t'uri' => '/dir/index.html',\n\t\t\t\t'qop' => 'auth',\n\t\t\t\t'nc' => '00000001',\n\t\t\t\t'cnonce' => '0a4f113b',\n\t\t\t\t'response' => '6629fae49393a05397450978507c4ef1',\n\t\t\t\t'opaque' => '5ccc069c403ebaf9f0171e9517f40e41'\n\t\t\t);\n\t\t\t$result = $this->Controller->Security->loginCredentials('digest');\n\t\t\t$this->assertIdentical($result, $expected);\n\t\t}\n\t}\n\n/**\n * testParseDigestAuthData method\n *\n * @access public\n * @return void\n */\n\tfunction testParseDigestAuthData() {\n\t\t$this->Controller->Security->startup($this->Controller);\n\t\t$digest = <<<DIGEST\n\t\t\tDigest username=\"Mufasa\",\n\t\t\trealm=\"testrealm@host.com\",\n\t\t\tnonce=\"dcd98b7102dd2f0e8b11d0f600bfb0c093\",\n\t\t\turi=\"/dir/index.html\",\n\t\t\tqop=auth,\n\t\t\tnc=00000001,\n\t\t\tcnonce=\"0a4f113b\",\n\t\t\tresponse=\"6629fae49393a05397450978507c4ef1\",\n\t\t\topaque=\"5ccc069c403ebaf9f0171e9517f40e41\"\nDIGEST;\n\t\t$expected = array(\n\t\t\t'username' => 'Mufasa',\n\t\t\t'realm' => 'testrealm@host.com',\n\t\t\t'nonce' => 'dcd98b7102dd2f0e8b11d0f600bfb0c093',\n\t\t\t'uri' => '/dir/index.html',\n\t\t\t'qop' => 'auth',\n\t\t\t'nc' => '00000001',\n\t\t\t'cnonce' => '0a4f113b',\n\t\t\t'response' => '6629fae49393a05397450978507c4ef1',\n\t\t\t'opaque' => '5ccc069c403ebaf9f0171e9517f40e41'\n\t\t);\n\t\t$result = $this->Controller->Security->parseDigestAuthData($digest);\n\t\t$this->assertIdentical($result, $expected);\n\n\t\t$result = $this->Controller->Security->parseDigestAuthData('');\n\t\t$this->assertNull($result);\n\t}\n\n/**\n * test parsing digest information with email addresses\n *\n * @return void\n */\n\tfunction testParseDigestAuthEmailAddress() {\n\t\t$this->Controller->Security->startup($this->Controller);\n\t\t$digest = <<<DIGEST\n\t\t\tDigest username=\"mark@example.com\",\n\t\t\trealm=\"testrealm@host.com\",\n\t\t\tnonce=\"dcd98b7102dd2f0e8b11d0f600bfb0c093\",\n\t\t\turi=\"/dir/index.html\",\n\t\t\tqop=auth,\n\t\t\tnc=00000001,\n\t\t\tcnonce=\"0a4f113b\",\n\t\t\tresponse=\"6629fae49393a05397450978507c4ef1\",\n\t\t\topaque=\"5ccc069c403ebaf9f0171e9517f40e41\"\nDIGEST;\n\t\t$expected = array(\n\t\t\t'username' => 'mark@example.com',\n\t\t\t'realm' => 'testrealm@host.com',\n\t\t\t'nonce' => 'dcd98b7102dd2f0e8b11d0f600bfb0c093',\n\t\t\t'uri' => '/dir/index.html',\n\t\t\t'qop' => 'auth',\n\t\t\t'nc' => '00000001',\n\t\t\t'cnonce' => '0a4f113b',\n\t\t\t'response' => '6629fae49393a05397450978507c4ef1',\n\t\t\t'opaque' => '5ccc069c403ebaf9f0171e9517f40e41'\n\t\t);\n\t\t$result = $this->Controller->Security->parseDigestAuthData($digest);\n\t\t$this->assertIdentical($result, $expected);\n\t}\n\n/**\n * testFormDisabledFields method\n *\n * @access public\n * @return void\n */\n\tfunction testFormDisabledFields() {\n\t\t$this->Controller->Security->startup($this->Controller);\n\t\t$key = $this->Controller->params['_Token']['key'];\n\t\t$fields = '11842060341b9d0fc3808b90ba29fdea7054d6ad%3An%3A0%3A%7B%7D';\n\n\t\t$this->Controller->data = array(\n\t\t\t'MyModel' => array('name' => 'some data'),\n\t\t\t'_Token' => compact('key', 'fields')\n\t\t);\n\t\t$result = $this->Controller->Security->validatePost($this->Controller);\n\t\t$this->assertFalse($result);\n\n\t\t$this->Controller->Security->startup($this->Controller);\n\t\t$this->Controller->Security->disabledFields = array('MyModel.name');\n\t\t$key = $this->Controller->params['_Token']['key'];\n\n\t\t$this->Controller->data = array(\n\t\t\t'MyModel' => array('name' => 'some data'),\n\t\t\t'_Token' => compact('key', 'fields')\n\t\t);\n\n\t\t$result = $this->Controller->Security->validatePost($this->Controller);\n\t\t$this->assertTrue($result);\n\t}\n\n/**\n * testRadio method\n *\n * @access public\n * @return void\n */\n\tfunction testRadio() {\n\t\t$this->Controller->Security->startup($this->Controller);\n\t\t$key = $this->Controller->params['_Token']['key'];\n\t\t$fields = '575ef54ca4fc8cab468d6d898e9acd3a9671c17e%3An%3A0%3A%7B%7D';\n\n\t\t$this->Controller->data = array(\n\t\t\t'_Token' => compact('key', 'fields')\n\t\t);\n\t\t$result = $this->Controller->Security->validatePost($this->Controller);\n\t\t$this->assertFalse($result);\n\n\t\t$this->Controller->data = array(\n\t\t\t'_Token' => compact('key', 'fields'),\n\t\t\t'Test' => array('test' => '')\n\t\t);\n\t\t$result = $this->Controller->Security->validatePost($this->Controller);\n\t\t$this->assertTrue($result);\n\n\t\t$this->Controller->data = array(\n\t\t\t'_Token' => compact('key', 'fields'),\n\t\t\t'Test' => array('test' => '1')\n\t\t);\n\t\t$result = $this->Controller->Security->validatePost($this->Controller);\n\t\t$this->assertTrue($result);\n\n\t\t$this->Controller->data = array(\n\t\t\t'_Token' => compact('key', 'fields'),\n\t\t\t'Test' => array('test' => '2')\n\t\t);\n\t\t$result = $this->Controller->Security->validatePost($this->Controller);\n\t\t$this->assertTrue($result);\n\t}\n\n/**\n * testInvalidAuthHeaders method\n *\n * @access public\n * @return void\n */\n\tfunction testInvalidAuthHeaders() {\n\t\t$this->Controller->Security->blackHoleCallback = null;\n\t\t$_SERVER['PHP_AUTH_USER'] = 'admin';\n\t\t$_SERVER['PHP_AUTH_PW'] = 'password';\n\t\t$realm = 'cakephp.org';\n\t\t$loginData = array('type' => 'basic', 'realm' => $realm);\n\t\t$this->Controller->Security->requireLogin($loginData);\n\t\t$this->Controller->Security->startup($this->Controller);\n\n\t\t$expected = 'WWW-Authenticate: Basic realm=\"'.$realm.'\"';\n\t\t$this->assertEqual(count($this->Controller->testHeaders), 1);\n\t\t$this->assertEqual(current($this->Controller->testHeaders), $expected);\n\t}\n\n/**\n * test that a requestAction's controller will have the _Token appended to\n * the params.\n *\n * @return void\n * @see http://cakephp.lighthouseapp.com/projects/42648/tickets/68\n */\n\tfunction testSettingTokenForRequestAction() {\n\t\t$this->Controller->Security->startup($this->Controller);\n\t\t$key = $this->Controller->params['_Token']['key'];\n\n\t\t$this->Controller->params['requested'] = 1;\n\t\tunset($this->Controller->params['_Token']);\n\n\t\t$this->Controller->Security->startup($this->Controller);\n\t\t$this->assertEqual($this->Controller->params['_Token']['key'], $key);\n\t}\n\n/**\n * test that blackhole doesn't delete the _Token session key so repeat data submissions\n * stay blackholed.\n *\n * @link http://cakephp.lighthouseapp.com/projects/42648/tickets/214\n * @return void\n */\n\tfunction testBlackHoleNotDeletingSessionInformation() {\n\t\t$this->Controller->Security->startup($this->Controller);\n\n\t\t$this->Controller->Security->blackHole($this->Controller, 'auth');\n\t\t$this->assertTrue($this->Controller->Security->Session->check('_Token'), '_Token was deleted by blackHole %s');\n\t}\n}\n"], "filenames": ["cake/libs/controller/components/security.php", "cake/tests/cases/libs/controller/components/security.test.php"], "buggy_code_start_loc": [620, 610], "buggy_code_end_loc": [625, 610], "fixing_code_start_loc": [621, 611], "fixing_code_end_loc": [630, 635], "type": "CWE-20", "message": "The _validatePost function in libs/controller/components/security.php in CakePHP 1.3.x through 1.3.5 and 1.2.8 allows remote attackers to modify the internal Cake cache and execute arbitrary code via a crafted data[_Token][fields] value that is processed by the unserialize function, as demonstrated by modifying the file_map cache to execute arbitrary local files.", "other": {"cve": {"id": "CVE-2010-4335", "sourceIdentifier": "secalert@redhat.com", "published": "2011-01-14T23:00:46.850", "lastModified": "2011-01-22T06:44:44.190", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The _validatePost function in libs/controller/components/security.php in CakePHP 1.3.x through 1.3.5 and 1.2.8 allows remote attackers to modify the internal Cake cache and execute arbitrary code via a crafted data[_Token][fields] value that is processed by the unserialize function, as demonstrated by modifying the file_map cache to execute arbitrary local files."}, {"lang": "es", "value": "la funci\u00f3n _validatePost en libs/controller/components/security.php en CakePHP v1.3.x hasta la v1.3.5 y v1.2.8 permite a atacantes remotos modificar la cach\u00e9 interna de la aplicaci\u00f3n y ejecutar c\u00f3digo arbitrario a trav\u00e9s de un valor data[_token][fields] debiadamente modificado, el cual es procesado por la funci\u00f3n unserialize, como se ha demostrado mediante la modificaci\u00f3n de la cach\u00e9 file_map para ejecutar archivos locales."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:cakefoundation:cakephp:1.2.8:*:*:*:*:*:*:*", "matchCriteriaId": "4EAF987A-B6AE-49BC-9B1F-F91C8BEDE8BB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:cakefoundation:cakephp:1.3:dev:*:*:*:*:*:*", "matchCriteriaId": "3FC00F9B-A680-43F9-ABDA-3242D7AC6B3E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:cakefoundation:cakephp:1.3.0:*:*:*:*:*:*:*", "matchCriteriaId": "C65627A5-D154-48F5-8902-D66899ABC206"}, {"vulnerable": true, "criteria": "cpe:2.3:a:cakefoundation:cakephp:1.3.0:alpha:*:*:*:*:*:*", "matchCriteriaId": "F0D64CF7-9431-410E-B69D-7B2828452739"}, {"vulnerable": true, "criteria": "cpe:2.3:a:cakefoundation:cakephp:1.3.0:beta:*:*:*:*:*:*", "matchCriteriaId": "BEAAA812-F8F6-48F2-995E-48929D532DB9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:cakefoundation:cakephp:1.3.0:rc1:*:*:*:*:*:*", "matchCriteriaId": "3AD6C268-C6DA-4DEE-853D-28E893CDE90E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:cakefoundation:cakephp:1.3.0:rc2:*:*:*:*:*:*", "matchCriteriaId": "D1C5033B-0E35-4270-AEFD-C7E78E546E53"}, {"vulnerable": true, "criteria": "cpe:2.3:a:cakefoundation:cakephp:1.3.0:rc3:*:*:*:*:*:*", "matchCriteriaId": "1119962A-421C-4F35-BCEE-3AD718F7E077"}, {"vulnerable": true, "criteria": "cpe:2.3:a:cakefoundation:cakephp:1.3.0:rc4:*:*:*:*:*:*", "matchCriteriaId": "C4E96540-FF61-4EEF-9768-BA4BE9441426"}, {"vulnerable": true, "criteria": "cpe:2.3:a:cakefoundation:cakephp:1.3.1:*:*:*:*:*:*:*", "matchCriteriaId": "3FE40BC8-8605-46FD-A6B3-B471623F5C14"}, {"vulnerable": true, "criteria": "cpe:2.3:a:cakefoundation:cakephp:1.3.2:*:*:*:*:*:*:*", "matchCriteriaId": "1602F4C6-4596-44B7-A2D7-CAF7F137748E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:cakefoundation:cakephp:1.3.3:*:*:*:*:*:*:*", "matchCriteriaId": "33DA98E6-D097-40F7-B63D-508E0BB593FF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:cakefoundation:cakephp:1.3.4:*:*:*:*:*:*:*", "matchCriteriaId": "2F002CFD-453B-4E9E-8BC3-9E647EDB0BD4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:cakefoundation:cakephp:1.3.5:*:*:*:*:*:*:*", "matchCriteriaId": "900DC462-B0B1-4205-B988-9DFC51366861"}]}]}], "references": [{"url": "http://malloc.im/CakePHP-unserialize.txt", "source": "secalert@redhat.com", "tags": ["Exploit"]}, {"url": "http://packetstormsecurity.org/files/view/95847/burnedcake.py.txt", "source": "secalert@redhat.com", "tags": ["Exploit"]}, {"url": "http://securityreason.com/securityalert/8026", "source": "secalert@redhat.com"}, {"url": "http://www.exploit-db.com/exploits/16011", "source": "secalert@redhat.com"}, {"url": "https://github.com/cakephp/cakephp/commit/e431e86aa4301ced4273dc7919b59362cbb353cb", "source": "secalert@redhat.com", "tags": ["Patch"]}]}, "github_commit_url": "https://github.com/cakephp/cakephp/commit/e431e86aa4301ced4273dc7919b59362cbb353cb"}}