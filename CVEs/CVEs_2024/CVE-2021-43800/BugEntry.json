{"buggy_code": ["const qs = require('querystring')\nconst _ = require('lodash')\nconst crypto = require('crypto')\nconst path = require('path')\n\nconst localeSegmentRegex = /^[A-Z]{2}(-[A-Z]{2})?$/i\nconst localeFolderRegex = /^([a-z]{2}(?:-[a-z]{2})?\\/)?(.*)/i\n// eslint-disable-next-line no-control-regex\nconst unsafeCharsRegex = /[\\x00-\\x1f\\x80-\\x9f\\\\\"|<>:*?]/\n\nconst contentToExt = {\n  markdown: 'md',\n  html: 'html'\n}\nconst extToContent = _.invert(contentToExt)\n\n/* global WIKI */\n\nmodule.exports = {\n  /**\n   * Parse raw url path and make it safe\n   */\n  parsePath (rawPath, opts = {}) {\n    let pathObj = {\n      locale: WIKI.config.lang.code,\n      path: 'home',\n      private: false,\n      privateNS: '',\n      explicitLocale: false\n    }\n\n    // Clean Path\n    rawPath = _.trim(qs.unescape(rawPath))\n    if (_.startsWith(rawPath, '/')) { rawPath = rawPath.substring(1) }\n    rawPath = rawPath.replace(unsafeCharsRegex, '')\n    if (rawPath === '') { rawPath = 'home' }\n\n    // Extract Info\n    let pathParts = _.filter(_.split(rawPath, '/'), p => {\n      p = _.trim(p)\n      return !_.isEmpty(p) && p !== '..' && p !== '.'\n    })\n    if (pathParts[0].length === 1) {\n      pathParts.shift()\n    }\n    if (localeSegmentRegex.test(pathParts[0])) {\n      pathObj.locale = pathParts[0]\n      pathObj.explicitLocale = true\n      pathParts.shift()\n    }\n\n    // Strip extension\n    if (opts.stripExt && pathParts.length > 0) {\n      const lastPart = _.last(pathParts)\n      if (lastPart.indexOf('.') > 0) {\n        pathParts.pop()\n        const lastPartMeta = path.parse(lastPart)\n        pathParts.push(lastPartMeta.name)\n      }\n    }\n\n    pathObj.path = _.join(pathParts, '/')\n    return pathObj\n  },\n  /**\n   * Generate unique hash from page\n   */\n  generateHash(opts) {\n    return crypto.createHash('sha1').update(`${opts.locale}|${opts.path}|${opts.privateNS}`).digest('hex')\n  },\n  /**\n   * Inject Page Metadata\n   */\n  injectPageMetadata(page) {\n    let meta = [\n      ['title', page.title],\n      ['description', page.description],\n      ['published', page.isPublished.toString()],\n      ['date', page.updatedAt],\n      ['tags', page.tags ? page.tags.map(t => t.tag).join(', ') : ''],\n      ['editor', page.editorKey],\n      ['dateCreated', page.createdAt]\n    ]\n    switch (page.contentType) {\n      case 'markdown':\n        return '---\\n' + meta.map(mt => `${mt[0]}: ${mt[1]}`).join('\\n') + '\\n---\\n\\n' + page.content\n      case 'html':\n        return '<!--\\n' + meta.map(mt => `${mt[0]}: ${mt[1]}`).join('\\n') + '\\n-->\\n\\n' + page.content\n      case 'json':\n        return {\n          ...page.content,\n          _meta: _.fromPairs(meta)\n        }\n      default:\n        return page.content\n    }\n  },\n  /**\n   * Check if path is a reserved path\n   */\n  isReservedPath(rawPath) {\n    const firstSection = _.head(rawPath.split('/'))\n    if (firstSection.length <= 1) {\n      return true\n    } else if (localeSegmentRegex.test(firstSection)) {\n      return true\n    } else if (\n      _.some(WIKI.data.reservedPaths, p => {\n        return p === firstSection\n      })) {\n      return true\n    } else {\n      return false\n    }\n  },\n  /**\n   * Get file extension from content type\n   */\n  getFileExtension(contentType) {\n    return _.get(contentToExt, contentType, 'txt')\n  },\n  /**\n   * Get content type from file extension\n   */\n  getContentType (filePath) {\n    const ext = _.last(filePath.split('.'))\n    return _.get(extToContent, ext, false)\n  },\n  /**\n   * Get Page Meta object from disk path\n   */\n  getPagePath (filePath) {\n    let fpath = filePath\n    if (process.platform === 'win32') {\n      fpath = filePath.replace(/\\\\/g, '/')\n    }\n    let meta = {\n      locale: WIKI.config.lang.code,\n      path: _.initial(fpath.split('.')).join('')\n    }\n    const result = localeFolderRegex.exec(meta.path)\n    if (result[1]) {\n      meta = {\n        locale: result[1].replace('/', ''),\n        path: result[2]\n      }\n    }\n    return meta\n  }\n}\n"], "fixing_code": ["const qs = require('querystring')\nconst _ = require('lodash')\nconst crypto = require('crypto')\nconst path = require('path')\n\nconst localeSegmentRegex = /^[A-Z]{2}(-[A-Z]{2})?$/i\nconst localeFolderRegex = /^([a-z]{2}(?:-[a-z]{2})?\\/)?(.*)/i\n// eslint-disable-next-line no-control-regex\nconst unsafeCharsRegex = /[\\x00-\\x1f\\x80-\\x9f\\\\\"|<>:*?]/\n\nconst contentToExt = {\n  markdown: 'md',\n  html: 'html'\n}\nconst extToContent = _.invert(contentToExt)\n\n/* global WIKI */\n\nmodule.exports = {\n  /**\n   * Parse raw url path and make it safe\n   */\n  parsePath (rawPath, opts = {}) {\n    let pathObj = {\n      locale: WIKI.config.lang.code,\n      path: 'home',\n      private: false,\n      privateNS: '',\n      explicitLocale: false\n    }\n\n    // Clean Path\n    rawPath = _.trim(qs.unescape(rawPath))\n    if (_.startsWith(rawPath, '/')) { rawPath = rawPath.substring(1) }\n    rawPath = rawPath.replace(unsafeCharsRegex, '')\n    if (rawPath === '') { rawPath = 'home' }\n\n    rawPath = rawPath.replaceAll('\\\\', '').replaceAll('//', '').replaceAll(/\\.\\.+/ig, '')\n\n    // Extract Info\n    let pathParts = _.filter(_.split(rawPath, '/'), p => {\n      p = _.trim(p)\n      return !_.isEmpty(p) && p !== '..' && p !== '.'\n    })\n    if (pathParts[0].length === 1) {\n      pathParts.shift()\n    }\n    if (localeSegmentRegex.test(pathParts[0])) {\n      pathObj.locale = pathParts[0]\n      pathObj.explicitLocale = true\n      pathParts.shift()\n    }\n\n    // Strip extension\n    if (opts.stripExt && pathParts.length > 0) {\n      const lastPart = _.last(pathParts)\n      if (lastPart.indexOf('.') > 0) {\n        pathParts.pop()\n        const lastPartMeta = path.parse(lastPart)\n        pathParts.push(lastPartMeta.name)\n      }\n    }\n\n    pathObj.path = _.join(pathParts, '/')\n    return pathObj\n  },\n  /**\n   * Generate unique hash from page\n   */\n  generateHash(opts) {\n    return crypto.createHash('sha1').update(`${opts.locale}|${opts.path}|${opts.privateNS}`).digest('hex')\n  },\n  /**\n   * Inject Page Metadata\n   */\n  injectPageMetadata(page) {\n    let meta = [\n      ['title', page.title],\n      ['description', page.description],\n      ['published', page.isPublished.toString()],\n      ['date', page.updatedAt],\n      ['tags', page.tags ? page.tags.map(t => t.tag).join(', ') : ''],\n      ['editor', page.editorKey],\n      ['dateCreated', page.createdAt]\n    ]\n    switch (page.contentType) {\n      case 'markdown':\n        return '---\\n' + meta.map(mt => `${mt[0]}: ${mt[1]}`).join('\\n') + '\\n---\\n\\n' + page.content\n      case 'html':\n        return '<!--\\n' + meta.map(mt => `${mt[0]}: ${mt[1]}`).join('\\n') + '\\n-->\\n\\n' + page.content\n      case 'json':\n        return {\n          ...page.content,\n          _meta: _.fromPairs(meta)\n        }\n      default:\n        return page.content\n    }\n  },\n  /**\n   * Check if path is a reserved path\n   */\n  isReservedPath(rawPath) {\n    const firstSection = _.head(rawPath.split('/'))\n    if (firstSection.length <= 1) {\n      return true\n    } else if (localeSegmentRegex.test(firstSection)) {\n      return true\n    } else if (\n      _.some(WIKI.data.reservedPaths, p => {\n        return p === firstSection\n      })) {\n      return true\n    } else {\n      return false\n    }\n  },\n  /**\n   * Get file extension from content type\n   */\n  getFileExtension(contentType) {\n    return _.get(contentToExt, contentType, 'txt')\n  },\n  /**\n   * Get content type from file extension\n   */\n  getContentType (filePath) {\n    const ext = _.last(filePath.split('.'))\n    return _.get(extToContent, ext, false)\n  },\n  /**\n   * Get Page Meta object from disk path\n   */\n  getPagePath (filePath) {\n    let fpath = filePath\n    if (process.platform === 'win32') {\n      fpath = filePath.replace(/\\\\/g, '/')\n    }\n    let meta = {\n      locale: WIKI.config.lang.code,\n      path: _.initial(fpath.split('.')).join('')\n    }\n    const result = localeFolderRegex.exec(meta.path)\n    if (result[1]) {\n      meta = {\n        locale: result[1].replace('/', ''),\n        path: result[2]\n      }\n    }\n    return meta\n  }\n}\n"], "filenames": ["server/helpers/page.js"], "buggy_code_start_loc": [36], "buggy_code_end_loc": [36], "fixing_code_start_loc": [37], "fixing_code_end_loc": [39], "type": "CWE-22", "message": "Wiki.js is a wiki app built on Node.js. Prior to version 2.5.254, directory traversal outside of Wiki.js context is possible when a storage module with local asset cache fetching is enabled on a Windows host. A malicious user can potentially read any file on the file system by crafting a special URL that allows for directory traversal. This is only possible on a Wiki.js server running on Windows, when a storage module implementing local asset cache (e.g Local File System or Git) is enabled and that no web application firewall solution (e.g. cloudflare) strips potentially malicious URLs. Commit number 414033de9dff66a327e3f3243234852f468a9d85 fixes this vulnerability by sanitizing the path before it is passed on to the storage module. The sanitization step removes any windows directory traversal sequences from the path. As a workaround, disable any storage module with local asset caching capabilities (Local File System, Git).", "other": {"cve": {"id": "CVE-2021-43800", "sourceIdentifier": "security-advisories@github.com", "published": "2021-12-06T19:15:07.670", "lastModified": "2021-12-08T15:25:39.400", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Wiki.js is a wiki app built on Node.js. Prior to version 2.5.254, directory traversal outside of Wiki.js context is possible when a storage module with local asset cache fetching is enabled on a Windows host. A malicious user can potentially read any file on the file system by crafting a special URL that allows for directory traversal. This is only possible on a Wiki.js server running on Windows, when a storage module implementing local asset cache (e.g Local File System or Git) is enabled and that no web application firewall solution (e.g. cloudflare) strips potentially malicious URLs. Commit number 414033de9dff66a327e3f3243234852f468a9d85 fixes this vulnerability by sanitizing the path before it is passed on to the storage module. The sanitization step removes any windows directory traversal sequences from the path. As a workaround, disable any storage module with local asset caching capabilities (Local File System, Git)."}, {"lang": "es", "value": "Wiki.js es una aplicaci\u00f3n wiki construida sobre Node.js. En versiones anteriores a 2.5.254, un salto de directorio fuera del contexto de Wiki.js es posible cuando se habilita un m\u00f3dulo de almacenamiento con b\u00fasqueda de cach\u00e9 de activos locales en un host de Windows. Un usuario malicioso puede leer potencialmente cualquier archivo del sistema de archivos dise\u00f1ando una URL especial que permita saltar el directorio. Esto s\u00f3lo es posible en un servidor Wiki.js que es ejecutado en Windows, cuando un m\u00f3dulo de almacenamiento que implementa la cach\u00e9 de activos locales (por ejemplo, Sistema de archivos locales o Git) est\u00e1 habilitado y que ninguna soluci\u00f3n de firewall de aplicaciones web (por ejemplo, cloudflare) elimina las URL potencialmente maliciosas. El n\u00famero de commit 414033de9dff66a327e3f3243234852f468a9d85 corrige esta vulnerabilidad saneando la ruta antes de pasarla al m\u00f3dulo de almacenamiento. El paso de saneo elimina cualquier secuencia de salto de directorio de Windows de la ruta. Como soluci\u00f3n, deshabilite cualquier m\u00f3dulo de almacenamiento con capacidades de almacenamiento en cach\u00e9 de activos locales (Sistema de archivos local, Git)"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-22"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-22"}]}], "configurations": [{"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:requarks:wiki.js:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.5.245", "matchCriteriaId": "F37B6EF5-4E9C-45D3-94B5-370C3BAC2003"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:o:microsoft:windows:-:*:*:*:*:*:*:*", "matchCriteriaId": "A2572D17-1DE6-457B-99CC-64AFD54487EA"}]}]}], "references": [{"url": "https://github.com/Requarks/wiki/commit/414033de9dff66a327e3f3243234852f468a9d85", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/Requarks/wiki/releases/tag/2.5.254", "source": "security-advisories@github.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/Requarks/wiki/security/advisories/GHSA-r363-73gj-6j25", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/Requarks/wiki/commit/414033de9dff66a327e3f3243234852f468a9d85"}}