{"buggy_code": ["from __future__ import print_function\n\nimport argparse\nimport json\nfrom oauthlib.oauth2 import LegacyApplicationClient\nimport logging\nimport logging.handlers\nfrom requests_oauthlib import OAuth2Session\nimport os\nimport requests\nimport six\nimport sys\nimport traceback\n\nfrom six.moves.urllib.parse import quote as urlquote\nfrom six.moves.urllib.parse import urlparse\n\n\n# ------------------------------------------------------------------------------\n\nlogger = None\nprog_name = os.path.basename(sys.argv[0])\nAUTH_ROLES = ['root-admin', 'realm-admin', 'anonymous']\n\nLOG_FILE_ROTATION_COUNT = 3\n\nTOKEN_URL_TEMPLATE = (\n    '{server}/auth/realms/{realm}/protocol/openid-connect/token')\nGET_SERVER_INFO_TEMPLATE = (\n    '{server}/auth/admin/serverinfo/')\nGET_REALMS_URL_TEMPLATE = (\n    '{server}/auth/admin/realms')\nCREATE_REALM_URL_TEMPLATE = (\n    '{server}/auth/admin/realms')\nDELETE_REALM_URL_TEMPLATE = (\n    '{server}/auth/admin/realms/{realm}')\nGET_REALM_METADATA_TEMPLATE = (\n    '{server}/auth/realms/{realm}/protocol/saml/descriptor')\n\nCLIENT_REPRESENTATION_TEMPLATE = (\n    '{server}/auth/admin/realms/{realm}/clients/{id}')\nGET_CLIENTS_URL_TEMPLATE = (\n    '{server}/auth/admin/realms/{realm}/clients')\nCLIENT_DESCRIPTOR_URL_TEMPLATE = (\n    '{server}/auth/admin/realms/{realm}/client-description-converter')\nCREATE_CLIENT_URL_TEMPLATE = (\n    '{server}/auth/admin/realms/{realm}/clients')\n\nGET_INITIAL_ACCESS_TOKEN_TEMPLATE = (\n    '{server}/auth/admin/realms/{realm}/clients-initial-access')\nSAML2_CLIENT_REGISTRATION_TEMPLATE = (\n  '{server}/auth/realms/{realm}/clients-registrations/saml2-entity-descriptor')\n\nGET_CLIENT_PROTOCOL_MAPPERS_TEMPLATE = (\n    '{server}/auth/admin/realms/{realm}/clients/{id}/protocol-mappers/models')\nGET_CLIENT_PROTOCOL_MAPPERS_BY_PROTOCOL_TEMPLATE = (\n    '{server}/auth/admin/realms/{realm}/clients/{id}/protocol-mappers/protocol/{protocol}')\n\nPOST_CLIENT_PROTOCOL_MAPPER_TEMPLATE = (\n    '{server}/auth/admin/realms/{realm}/clients/{id}/protocol-mappers/models')\n\n\nADMIN_CLIENT_ID = 'admin-cli'\n\n# ------------------------------------------------------------------------------\n\n\nclass RESTError(Exception):\n    def __init__(self, status_code, status_reason,\n                 response_json, response_text, cmd):\n        self.status_code = status_code\n        self.status_reason = status_reason\n        self.error_description = None\n        self.error = None\n        self.response_json = response_json\n        self.response_text = response_text\n        self.cmd = cmd\n\n        self.message = '{status_reason}({status_code}): '.format(\n            status_reason=self.status_reason,\n            status_code=self.status_code)\n\n        if response_json:\n            self.error_description = response_json.get('error_description')\n            if self.error_description is None:\n                self.error_description = response_json.get('errorMessage')\n            self.error = response_json.get('error')\n            self.message += '\"{error_description}\" [{error}]'.format(\n                error_description=self.error_description,\n                error=self.error)\n        else:\n            self.message += '\"{response_text}\"'.format(\n                response_text=self.response_text)\n\n        self.args = (self.message,)\n\n    def __str__(self):\n        return self.message\n\n# ------------------------------------------------------------------------------\n\n\ndef configure_logging(options):\n    global logger  # pylint: disable=W0603\n\n    log_dir = os.path.dirname(options.log_file)\n    if os.path.exists(log_dir):\n        if not os.path.isdir(log_dir):\n            raise ValueError('logging directory \"{log_dir}\" exists but is not '\n                             'directory'.format(log_dir=log_dir))\n    else:\n        os.makedirs(log_dir)\n\n    log_level = logging.ERROR\n    if options.verbose:\n        log_level = logging.INFO\n    if options.debug:\n        log_level = logging.DEBUG\n\n        # These two lines enable debugging at httplib level\n        # (requests->urllib3->http.client) You will see the REQUEST,\n        # including HEADERS and DATA, and RESPONSE with HEADERS but\n        # without DATA.  The only thing missing will be the\n        # response.body which is not logged.\n        try:\n            import http.client as http_client  # Python 3\n        except ImportError:\n            import httplib as http_client      # Python 2\n\n        http_client.HTTPConnection.debuglevel = 1\n\n        # Turn on cookielib debugging\n        if False:\n            try:\n                import http.cookiejar as cookiejar\n            except ImportError:\n                import cookielib as cookiejar  # Python 2\n            cookiejar.debug = True\n\n    logger = logging.getLogger(prog_name)\n\n    try:\n        file_handler = logging.handlers.RotatingFileHandler(\n            options.log_file, backupCount=LOG_FILE_ROTATION_COUNT)\n    except IOError as e:\n        print('Unable to open log file %s (%s)' % (options.log_file, e),\n              file=sys.stderr)\n\n    else:\n        formatter = logging.Formatter(\n            '%(asctime)s %(name)s %(levelname)s: %(message)s')\n        file_handler.setFormatter(formatter)\n        file_handler.setLevel(logging.DEBUG)\n        logger.addHandler(file_handler)\n\n    console_handler = logging.StreamHandler(sys.stdout)\n    formatter = logging.Formatter('%(message)s')\n    console_handler.setFormatter(formatter)\n    console_handler.setLevel(log_level)\n    logger.addHandler(console_handler)\n\n    # Set the log level on the logger to the lowest level\n    # possible. This allows the message to be emitted from the logger\n    # to it's handlers where the level will be filtered on a per\n    # handler basis.\n    logger.setLevel(1)\n\n# ------------------------------------------------------------------------------\n\n\ndef json_pretty(text):\n    return json.dumps(json.loads(text),\n                      indent=4, sort_keys=True)\n\n\ndef py_json_pretty(py_json):\n    return json_pretty(json.dumps(py_json))\n\n\ndef server_name_from_url(url):\n    return urlparse(url).netloc\n\n\ndef get_realm_names_from_realms(realms):\n    return [x['realm'] for x in realms]\n\n\ndef get_client_client_ids_from_clients(clients):\n    return [x['clientId'] for x in clients]\n\n\ndef find_client_by_name(clients, client_id):\n    for client in clients:\n        if client.get('clientId') == client_id:\n            return client\n    raise KeyError('{item} not found'.format(item=client_id))\n\n\n# ------------------------------------------------------------------------------\n\nclass KeycloakREST(object):\n\n    def __init__(self, server, auth_role=None, session=None):\n        self.server = server\n        self.auth_role = auth_role\n        self.session = session\n\n    def get_initial_access_token(self, realm_name):\n        cmd_name = \"get initial access token for realm '{realm}'\".format(\n            realm=realm_name)\n        url = GET_INITIAL_ACCESS_TOKEN_TEMPLATE.format(\n            server=self.server, realm=urlquote(realm_name))\n\n        logger.debug(\"%s on server %s\", cmd_name, self.server)\n\n        params = {\"expiration\": 60,  # seconds\n                  \"count\": 1}\n\n        response = self.session.post(url, json=params)\n        logger.debug(\"%s response code: %s %s\",\n                     cmd_name, response.status_code, response.reason)\n\n        try:\n            response_json = response.json()\n        except ValueError as e:\n            response_json = None\n\n        if (not response_json or\n            response.status_code != requests.codes.ok):\n            logger.error(\"%s error: status=%s (%s) text=%s\",\n                         cmd_name, response.status_code, response.reason,\n                         response.text)\n            raise RESTError(response.status_code, response.reason,\n                            response_json, response.text, cmd_name)\n\n        logger.debug(\"%s response = %s\", cmd_name, json_pretty(response.text))\n\n        return response_json    # ClientInitialAccessPresentation\n\n    def get_server_info(self):\n        cmd_name = \"get server info\"\n        url = GET_SERVER_INFO_TEMPLATE.format(server=self.server)\n\n        logger.debug(\"%s on server %s\", cmd_name, self.server)\n        response = self.session.get(url)\n        logger.debug(\"%s response code: %s %s\",\n                     cmd_name, response.status_code, response.reason)\n\n        try:\n            response_json = response.json()\n        except ValueError as e:\n            response_json = None\n\n        if (not response_json or\n            response.status_code != requests.codes.ok):\n            logger.error(\"%s error: status=%s (%s) text=%s\",\n                         cmd_name, response.status_code, response.reason,\n                         response.text)\n            raise RESTError(response.status_code, response.reason,\n                            response_json, response.text, cmd_name)\n\n        logger.debug(\"%s response = %s\", cmd_name, json_pretty(response.text))\n\n        return response_json\n\n    def get_realms(self):\n        cmd_name = \"get realms\"\n        url = GET_REALMS_URL_TEMPLATE.format(server=self.server)\n\n        logger.debug(\"%s on server %s\", cmd_name, self.server)\n        response = self.session.get(url)\n        logger.debug(\"%s response code: %s %s\",\n                     cmd_name, response.status_code, response.reason)\n\n        try:\n            response_json = response.json()\n        except ValueError as e:\n            response_json = None\n\n        if (not response_json or\n            response.status_code != requests.codes.ok):\n            logger.error(\"%s error: status=%s (%s) text=%s\",\n                         cmd_name, response.status_code, response.reason,\n                         response.text)\n            raise RESTError(response.status_code, response.reason,\n                            response_json, response.text, cmd_name)\n\n        logger.debug(\"%s response = %s\", cmd_name, json_pretty(response.text))\n\n        return response_json\n\n    def create_realm(self, realm_name):\n        cmd_name = \"create realm '{realm}'\".format(realm=realm_name)\n        url = CREATE_REALM_URL_TEMPLATE.format(server=self.server)\n\n        logger.debug(\"%s on server %s\", cmd_name, self.server)\n\n        params = {\"enabled\": True,\n                  \"id\": realm_name,\n                  \"realm\": realm_name,\n                  }\n\n        response = self.session.post(url, json=params)\n        logger.debug(\"%s response code: %s %s\",\n                     cmd_name, response.status_code, response.reason)\n\n        try:\n            response_json = response.json()\n        except ValueError as e:\n            response_json = None\n\n        if response.status_code != requests.codes.created:\n            logger.error(\"%s error: status=%s (%s) text=%s\",\n                         cmd_name, response.status_code, response.reason,\n                         response.text)\n            raise RESTError(response.status_code, response.reason,\n                            response_json, response.text, cmd_name)\n\n        logger.debug(\"%s response = %s\", cmd_name, response.text)\n\n    def delete_realm(self, realm_name):\n        cmd_name = \"delete realm '{realm}'\".format(realm=realm_name)\n        url = DELETE_REALM_URL_TEMPLATE.format(\n            server=self.server, realm=urlquote(realm_name))\n\n        logger.debug(\"%s on server %s\", cmd_name, self.server)\n        response = self.session.delete(url)\n        logger.debug(\"%s response code: %s %s\",\n                     cmd_name, response.status_code, response.reason)\n\n        try:\n            response_json = response.json()\n        except ValueError as e:\n            response_json = None\n\n        if response.status_code != requests.codes.no_content:\n            logger.error(\"%s error: status=%s (%s) text=%s\",\n                         cmd_name, response.status_code, response.reason,\n                         response.text)\n            raise RESTError(response.status_code, response.reason,\n                            response_json, response.text, cmd_name)\n\n        logger.debug(\"%s response = %s\", cmd_name, response.text)\n\n    def get_realm_metadata(self, realm_name):\n        cmd_name = \"get metadata for realm '{realm}'\".format(realm=realm_name)\n        url = GET_REALM_METADATA_TEMPLATE.format(\n            server=self.server, realm=urlquote(realm_name))\n\n        logger.debug(\"%s on server %s\", cmd_name, self.server)\n        response = self.session.get(url)\n        logger.debug(\"%s response code: %s %s\",\n                     cmd_name, response.status_code, response.reason)\n\n        try:\n            response_json = response.json()\n        except ValueError as e:\n            response_json = None\n\n        if response.status_code != requests.codes.ok:\n            logger.error(\"%s error: status=%s (%s) text=%s\",\n                         cmd_name, response.status_code, response.reason,\n                         response.text)\n            raise RESTError(response.status_code, response.reason,\n                            response_json, response.text, cmd_name)\n\n        logger.debug(\"%s response = %s\", cmd_name, response.text)\n        return response.text\n\n    def get_clients(self, realm_name):\n        cmd_name = \"get clients in realm '{realm}'\".format(realm=realm_name)\n        url = GET_CLIENTS_URL_TEMPLATE.format(\n            server=self.server, realm=urlquote(realm_name))\n\n        logger.debug(\"%s on server %s\", cmd_name, self.server)\n        response = self.session.get(url)\n        logger.debug(\"%s response code: %s %s\",\n                     cmd_name, response.status_code, response.reason)\n\n        try:\n            response_json = response.json()\n        except ValueError as e:\n            response_json = None\n\n        if (not response_json or\n            response.status_code != requests.codes.ok):\n            logger.error(\"%s error: status=%s (%s) text=%s\",\n                         cmd_name, response.status_code, response.reason,\n                         response.text)\n            raise RESTError(response.status_code, response.reason,\n                            response_json, response.text, cmd_name)\n\n        logger.debug(\"%s response = %s\", cmd_name, json_pretty(response.text))\n\n        return response_json\n\n\n    def get_client_by_id(self, realm_name, id):\n        cmd_name = \"get client id {id} in realm '{realm}'\".format(\n            id=id, realm=realm_name)\n        url = GET_CLIENTS_URL_TEMPLATE.format(\n            server=self.server, realm=urlquote(realm_name))\n\n        params = {'clientID': id}\n\n        logger.debug(\"%s on server %s\", cmd_name, self.server)\n        response = self.session.get(url, params=params)\n        logger.debug(\"%s response code: %s %s\",\n                     cmd_name, response.status_code, response.reason)\n\n        try:\n            response_json = response.json()\n        except ValueError as e:\n            response_json = None\n\n        if (not response_json or\n            response.status_code != requests.codes.ok):\n            logger.error(\"%s error: status=%s (%s) text=%s\",\n                         cmd_name, response.status_code, response.reason,\n                         response.text)\n            raise RESTError(response.status_code, response.reason,\n                            response_json, response.text, cmd_name)\n\n        logger.debug(\"%s response = %s\", cmd_name, json_pretty(response.text))\n\n        return response_json\n\n\n    def get_client_by_name(self, realm_name, client_name):\n        clients = self.get_clients(realm_name)\n        client = find_client_by_name(clients, client_name)\n        id = client.get('id')\n        logger.debug(\"client name '%s' mapped to id '%s'\",\n                     client_name, id)\n        logger.debug(\"client %s\\n%s\", client_name, py_json_pretty(client))\n        return client\n\n    def get_client_id_by_name(self, realm_name, client_name):\n        client = self.get_client_by_name(realm_name, client_name)\n        id = client.get('id')\n        return id\n\n    def get_client_descriptor(self, realm_name, metadata):\n        cmd_name = \"get client descriptor realm '{realm}'\".format(\n            realm=realm_name)\n        url = CLIENT_DESCRIPTOR_URL_TEMPLATE.format(\n            server=self.server, realm=urlquote(realm_name))\n\n        logger.debug(\"%s on server %s\", cmd_name, self.server)\n\n        headers = {'Content-Type': 'application/xml;charset=utf-8'}\n\n        response = self.session.post(url, headers=headers, data=metadata)\n        logger.debug(\"%s response code: %s %s\",\n                     cmd_name, response.status_code, response.reason)\n\n        try:\n            response_json = response.json()\n        except ValueError as e:\n            response_json = None\n\n        if (not response_json or\n            response.status_code != requests.codes.ok):\n            logger.error(\"%s error: status=%s (%s) text=%s\",\n                         cmd_name, response.status_code, response.reason,\n                         response.text)\n            raise RESTError(response.status_code, response.reason,\n                            response_json, response.text, cmd_name)\n\n        logger.debug(\"%s response = %s\", cmd_name, json_pretty(response.text))\n\n        return response_json\n\n    def create_client_from_descriptor(self, realm_name, descriptor):\n        cmd_name = \"create client from descriptor \"\n        \"'{client_id}'in realm '{realm}'\".format(\n            client_id=descriptor['clientId'], realm=realm_name)\n        url = CREATE_CLIENT_URL_TEMPLATE.format(\n            server=self.server, realm=urlquote(realm_name))\n\n        logger.debug(\"%s on server %s\", cmd_name, self.server)\n\n        response = self.session.post(url, json=descriptor)\n        logger.debug(\"%s response code: %s %s\",\n                     cmd_name, response.status_code, response.reason)\n\n        try:\n            response_json = response.json()\n        except ValueError as e:\n            response_json = None\n\n        if response.status_code != requests.codes.created:\n            logger.error(\"%s error: status=%s (%s) text=%s\",\n                         cmd_name, response.status_code, response.reason,\n                         response.text)\n            raise RESTError(response.status_code, response.reason,\n                            response_json, response.text, cmd_name)\n\n        logger.debug(\"%s response = %s\", cmd_name, response.text)\n\n    def create_client(self, realm_name, metadata):\n        logger.debug(\"create client in realm %s on server %s\",\n                     realm_name, self.server)\n        descriptor = self.get_client_descriptor(realm_name, metadata)\n        self.create_client_from_descriptor(realm_name, descriptor)\n        return descriptor\n\n    def register_client(self, initial_access_token, realm_name, metadata):\n        cmd_name = \"register_client realm '{realm}'\".format(\n            realm=realm_name)\n        url = SAML2_CLIENT_REGISTRATION_TEMPLATE.format(\n            server=self.server, realm=urlquote(realm_name))\n\n        logger.debug(\"%s on server %s\", cmd_name, self.server)\n\n        headers = {'Content-Type': 'application/xml;charset=utf-8'}\n\n        if initial_access_token:\n            headers['Authorization'] = 'Bearer {token}'.format(\n                token=initial_access_token)\n\n        response = self.session.post(url, headers=headers, data=metadata)\n        logger.debug(\"%s response code: %s %s\",\n                     cmd_name, response.status_code, response.reason)\n\n        try:\n            response_json = response.json()\n        except ValueError as e:\n            response_json = None\n\n        if (not response_json or\n            response.status_code != requests.codes.created):\n            logger.error(\"%s error: status=%s (%s) text=%s\",\n                         cmd_name, response.status_code, response.reason,\n                         response.text)\n            raise RESTError(response.status_code, response.reason,\n                            response_json, response.text, cmd_name)\n\n        logger.debug(\"%s response = %s\", cmd_name, json_pretty(response.text))\n\n        return response_json    # ClientRepresentation\n\n    def delete_client_by_name(self, realm_name, client_name):\n        id = self.get_client_id_by_name(realm_name, client_name)\n        self.delete_client_by_id(realm_name, id)\n\n\n    def delete_client_by_id(self, realm_name, id):\n        cmd_name = \"delete client id '{id}'in realm '{realm}'\".format(\n            id=id, realm=realm_name)\n        url = CLIENT_REPRESENTATION_TEMPLATE.format(\n            server=self.server, realm=urlquote(realm_name),\n            id=urlquote(id))\n\n        logger.debug(\"%s on server %s\", cmd_name, self.server)\n        response = self.session.delete(url)\n        logger.debug(\"%s response code: %s %s\",\n                     cmd_name, response.status_code, response.reason)\n\n        try:\n            response_json = response.json()\n        except ValueError as e:\n            response_json = None\n\n        if response.status_code != requests.codes.no_content:\n            logger.error(\"%s error: status=%s (%s) text=%s\",\n                         cmd_name, response.status_code, response.reason,\n                         response.text)\n            raise RESTError(response.status_code, response.reason,\n                            response_json, response.text, cmd_name)\n\n        logger.debug(\"%s response = %s\", cmd_name, response.text)\n\n    def update_client(self, realm_name, client):\n        id = client['id']\n        cmd_name = \"update client {id} in realm '{realm}'\".format(\n            id=client['clientId'], realm=realm_name)\n        url = CLIENT_REPRESENTATION_TEMPLATE.format(\n            server=self.server, realm=urlquote(realm_name),\n            id=urlquote(id))\n\n        logger.debug(\"%s on server %s\", cmd_name, self.server)\n\n        response = self.session.put(url, json=client)\n        logger.debug(\"%s response code: %s %s\",\n                     cmd_name, response.status_code, response.reason)\n\n        try:\n            response_json = response.json()\n        except ValueError as e:\n            response_json = None\n\n        if response.status_code != requests.codes.no_content:\n            logger.error(\"%s error: status=%s (%s) text=%s\",\n                         cmd_name, response.status_code, response.reason,\n                         response.text)\n            raise RESTError(response.status_code, response.reason,\n                            response_json, response.text, cmd_name)\n\n        logger.debug(\"%s response = %s\", cmd_name, response.text)\n\n\n    def update_client_attributes(self, realm_name, client, update_attrs):\n        client_id = client['clientId']\n        logger.debug(\"update client attrs: client_id=%s \"\n        \"current attrs=%s update=%s\" % (client_id, client['attributes'],\n                                update_attrs))\n        client['attributes'].update(update_attrs)\n        logger.debug(\"update client attrs: client_id=%s \"\n        \"new attrs=%s\" % (client_id, client['attributes']))\n        self.update_client(realm_name, client);\n\n\n    def update_client_by_name_attributes(self, realm_name, client_name,\n                                         update_attrs):\n        client = self.get_client_by_name(realm_name, client_name)\n        self.update_client_attributes(realm_name, client, update_attrs)\n\n    def new_saml_group_protocol_mapper(self, mapper_name, attribute_name,\n                                       friendly_name=None,\n                                       single_attribute=True):\n        mapper = {\n            'protocol': 'saml',\n            'name': mapper_name,\n            'protocolMapper': 'saml-group-membership-mapper',\n            'config': {\n                'attribute.name': attribute_name,\n                'attribute.nameformat': 'Basic',\n                'single': single_attribute,\n                'full.path': False,\n            },\n        }\n\n        if friendly_name:\n            mapper['config']['friendly.name'] = friendly_name\n\n        return mapper\n\n    def create_client_protocol_mapper(self, realm_name, client, mapper):\n        id = client['id']\n        cmd_name = (\"create protocol-mapper '{mapper_name}' for client {id} \"\n                    \"in realm '{realm}'\".format(\n                        mapper_name=mapper['name'],id=client['clientId'], realm=realm_name))\n        url = POST_CLIENT_PROTOCOL_MAPPER_TEMPLATE.format(\n            server=self.server,\n            realm=urlquote(realm_name),\n            id=urlquote(id))\n\n        logger.debug(\"%s on server %s\", cmd_name, self.server)\n\n        response = self.session.post(url, json=mapper)\n        logger.debug(\"%s response code: %s %s\",\n                     cmd_name, response.status_code, response.reason)\n\n        try:\n            response_json = response.json()\n        except ValueError as e:\n            response_json = None\n\n        if response.status_code != requests.codes.created:\n            logger.error(\"%s error: status=%s (%s) text=%s\",\n                         cmd_name, response.status_code, response.reason,\n                         response.text)\n            raise RESTError(response.status_code, response.reason,\n                            response_json, response.text, cmd_name)\n\n        logger.debug(\"%s response = %s\", cmd_name, response.text)\n\n\n    def create_client_by_name_protocol_mapper(self, realm_name, client_name,\n                                              mapper):\n        client = self.get_client_by_name(realm_name, client_name)\n        self.create_client_protocol_mapper(realm_name, client, mapper)\n\n\n\n    def add_client_by_name_redirect_uris(self, realm_name, client_name, uris):\n        client = self.get_client_by_name(realm_name, client_name)\n\n        uris = set(uris)\n        redirect_uris = set(client['redirectUris'])\n        redirect_uris |= uris\n        client['redirectUris'] = list(redirect_uris)\n        self.update_client(realm_name, client);\n\n    def remove_client_by_name_redirect_uris(self, realm_name, client_name, uris):\n        client = self.get_client_by_name(realm_name, client_name)\n\n        uris = set(uris)\n        redirect_uris = set(client['redirectUris'])\n        redirect_uris -= uris\n        client['redirectUris'] = list(redirect_uris)\n\n        self.update_client(realm_name, client);\n\n\n# ------------------------------------------------------------------------------\n\n\nclass KeycloakAdminConnection(KeycloakREST):\n\n    def __init__(self, server, auth_role, realm, client_id,\n                 username, password, tls_verify):\n        super(KeycloakAdminConnection, self).__init__(server, auth_role)\n\n        self.realm = realm\n        self.client_id = client_id\n        self.username = username\n        self.password = password\n\n        self.session = self._create_session(tls_verify)\n\n    def _create_session(self, tls_verify):\n        token_url = TOKEN_URL_TEMPLATE.format(\n            server=self.server, realm=urlquote(self.realm))\n        refresh_url = token_url\n\n        client = LegacyApplicationClient(client_id=self.client_id)\n        session = OAuth2Session(client=client,\n                                auto_refresh_url=refresh_url,\n                                auto_refresh_kwargs={\n                                    'client_id': self.client_id})\n\n        session.verify = tls_verify\n        token = session.fetch_token(token_url=token_url,\n                                    username=self.username,\n                                    password=self.password,\n                                    client_id=self.client_id,\n                                    verify=session.verify)\n\n        return session\n\n\nclass KeycloakAnonymousConnection(KeycloakREST):\n\n    def __init__(self, server, tls_verify):\n        super(KeycloakAnonymousConnection, self).__init__(server, 'anonymous')\n        self.session = self._create_session(tls_verify)\n\n\n    def _create_session(self, tls_verify):\n        session = requests.Session()\n        session.verify = tls_verify\n\n        return session\n\n# ------------------------------------------------------------------------------\n\n\ndef do_server_info(options, conn):\n    server_info = conn.get_server_info()\n    print(json_pretty(server_info))\n\n\ndef do_list_realms(options, conn):\n    realms = conn.get_realms()\n    realm_names = get_realm_names_from_realms(realms)\n    print('\\n'.join(sorted(realm_names)))\n\n\ndef do_create_realm(options, conn):\n    conn.create_realm(options.realm_name)\n\n\ndef do_delete_realm(options, conn):\n    conn.delete_realm(options.realm_name)\n\n\ndef do_get_realm_metadata(options, conn):\n    metadata = conn.get_realm_metadata(options.realm_name)\n    print(metadata)\n\n\ndef do_list_clients(options, conn):\n    clients = conn.get_clients(options.realm_name)\n    client_ids = get_client_client_ids_from_clients(clients)\n    print('\\n'.join(sorted(client_ids)))\n\n\ndef do_create_client(options, conn):\n    metadata = options.metadata.read()\n    descriptor = conn.create_client(options.realm_name, metadata)\n\n\ndef do_register_client(options, conn):\n    metadata = options.metadata.read()\n    client_representation = conn.register_client(\n        options.initial_access_token,\n        options.realm_name, metadata)\n\n\ndef do_delete_client(options, conn):\n    conn.delete_client_by_name(options.realm_name, options.client_name)\n\ndef do_client_test(options, conn):\n    'experimental test code used during development'\n\n    uri = 'https://openstack.jdennis.oslab.test:5000/v3/mellon/fooResponse'\n\n    conn.remove_client_by_name_redirect_uri(options.realm_name,\n                                            options.client_name,\n                                            uri)\n\n# ------------------------------------------------------------------------------\n\nverbose_help = '''\n\nThe structure of the command line arguments is \"noun verb\" where noun\nis one of Keycloak's data items (e.g. realm, client, etc.) and the\nverb is an action to perform on the item. Each of the nouns and verbs\nmay have their own set of arguments which must follow the noun or\nverb.\n\nFor example to delete the client XYZ in the realm ABC:\n\necho password | {prog_name} -s http://example.com:8080 -P - client delete -r ABC -c XYZ\n\nwhere 'client' is the noun, 'delete' is the verb and -r ABC -c XYZ are\narguments to the delete action.\n\nIf the command completes successfully the exit status is 0. The exit\nstatus is 1 if an authenticated connection with the server cannont be\nsuccessfully established. The exit status is 2 if the REST operation\nfails.\n\nThe server should be a scheme://hostname:port URL.\n'''\n\n\nclass TlsVerifyAction(argparse.Action):\n    def __init__(self, option_strings, dest, nargs=None, **kwargs):\n        if nargs is not None:\n            raise ValueError(\"nargs not allowed\")\n        super(TlsVerifyAction, self).__init__(option_strings, dest, **kwargs)\n\n    def __call__(self, parser, namespace, values, option_string=None):\n        if values.lower() in ['true', 'yes', 'on']:\n            verify = True\n        elif values.lower() in ['false', 'no', 'off']:\n            verify = False\n        else:\n            verify = values\n            \n        setattr(namespace, self.dest, verify)\n\ndef main():\n    global logger\n    result = 0\n\n    parser = argparse.ArgumentParser(description='Keycloak REST client',\n                    prog=prog_name,\n                    epilog=verbose_help.format(prog_name=prog_name),\n                    formatter_class=argparse.RawDescriptionHelpFormatter)\n\n    parser.add_argument('-v', '--verbose', action='store_true',\n                        help='be chatty')\n\n    parser.add_argument('-d', '--debug', action='store_true',\n                        help='turn on debug info')\n\n    parser.add_argument('--show-traceback', action='store_true',\n                        help='exceptions print traceback in addition to '\n                             'error message')\n\n    parser.add_argument('--log-file',\n                        default='/tmp/{prog_name}.log'.format(\n                            prog_name=prog_name),\n                        help='log file pathname')\n\n    parser.add_argument('--permit-insecure-transport',  action='store_true',\n                        help='Normally secure transport such as TLS '\n                        'is required, defeat this check')\n\n    parser.add_argument('--tls-verify', action=TlsVerifyAction,\n                        default=True,\n                        help='TLS certificate verification for requests to'\n                        ' the server. May be one of case insenstive '\n                        '[true, yes, on] to enable,'\n                        '[false, no, off] to disable.'\n                        'Or the pathname to a OpenSSL CA bundle to use.'\n                        ' Default is True.')\n\n    group = parser.add_argument_group('Server')\n\n    group.add_argument('-s', '--server',\n                       required=True,\n                       help='DNS name or IP address of Keycloak server')\n\n    group.add_argument('-a', '--auth-role',\n                       choices=AUTH_ROLES,\n                       default='root-admin',\n                       help='authenticating as what type of user (default: root-admin)')\n\n    group.add_argument('-u', '--admin-username',\n                       default='admin',\n                       help='admin user name (default: admin)')\n\n    group.add_argument('-P', '--admin-password-file',\n                       type=argparse.FileType('rb'),\n                       help=('file containing admin password '\n                             '(or use a hyphen \"-\" to read the password '\n                             'from stdin)'))\n\n    group.add_argument('--admin-realm',\n                       default='master',\n                       help='realm admin belongs to')\n\n    cmd_parsers = parser.add_subparsers(help='available commands')\n\n    # --- realm commands ---\n    realm_parser = cmd_parsers.add_parser('realm',\n                                          help='realm operations')\n\n    sub_parser = realm_parser.add_subparsers(help='realm commands')\n\n    cmd_parser = sub_parser.add_parser('server_info',\n                                       help='dump server info')\n    cmd_parser.set_defaults(func=do_server_info)\n\n    cmd_parser = sub_parser.add_parser('list',\n                                       help='list realm names')\n    cmd_parser.set_defaults(func=do_list_realms)\n\n    cmd_parser = sub_parser.add_parser('create',\n                                       help='create new realm')\n    cmd_parser.add_argument('-r', '--realm-name', required=True,\n                            help='realm name')\n    cmd_parser.set_defaults(func=do_create_realm)\n\n    cmd_parser = sub_parser.add_parser('delete',\n                                       help='delete existing realm')\n    cmd_parser.add_argument('-r', '--realm-name', required=True,\n                            help='realm name')\n    cmd_parser.set_defaults(func=do_delete_realm)\n\n    cmd_parser = sub_parser.add_parser('metadata',\n                                       help='retrieve realm metadata')\n    cmd_parser.add_argument('-r', '--realm-name', required=True,\n                            help='realm name')\n    cmd_parser.set_defaults(func=do_get_realm_metadata)\n\n    # --- client commands ---\n    client_parser = cmd_parsers.add_parser('client',\n                                           help='client operations')\n\n    sub_parser = client_parser.add_subparsers(help='client commands')\n\n    cmd_parser = sub_parser.add_parser('list',\n                                       help='list client names')\n    cmd_parser.add_argument('-r', '--realm-name', required=True,\n                            help='realm name')\n\n    cmd_parser.set_defaults(func=do_list_clients)\n\n    cmd_parser = sub_parser.add_parser('create',\n                                       help='create new client')\n    cmd_parser.add_argument('-r', '--realm-name', required=True,\n                            help='realm name')\n    cmd_parser.add_argument('-m', '--metadata', type=argparse.FileType('rb'),\n                            required=True,\n                            help='SP metadata file or stdin')\n    cmd_parser.set_defaults(func=do_create_client)\n\n    cmd_parser = sub_parser.add_parser('register',\n                                       help='register new client')\n    cmd_parser.add_argument('-r', '--realm-name', required=True,\n                            help='realm name')\n    cmd_parser.add_argument('-m', '--metadata', type=argparse.FileType('rb'),\n                            required=True,\n                            help='SP metadata file or stdin')\n    cmd_parser.add_argument('--initial-access-token', required=True,\n                            help='realm initial access token for '\n                            'client registeration')\n    cmd_parser.set_defaults(func=do_register_client)\n\n    cmd_parser = sub_parser.add_parser('delete',\n                                       help='delete existing client')\n    cmd_parser.add_argument('-r', '--realm-name', required=True,\n                            help='realm name')\n    cmd_parser.add_argument('-c', '--client-name', required=True,\n                            help='client name')\n    cmd_parser.set_defaults(func=do_delete_client)\n\n    cmd_parser = sub_parser.add_parser('test',\n                                       help='experimental test used during '\n                                       'development')\n    cmd_parser.add_argument('-r', '--realm-name', required=True,\n                            help='realm name')\n    cmd_parser.add_argument('-c', '--client-name', required=True,\n                            help='client name')\n    cmd_parser.set_defaults(func=do_client_test)\n\n    # Process command line arguments\n    options = parser.parse_args()\n    configure_logging(options)\n\n    if options.permit_insecure_transport:\n        os.environ['OAUTHLIB_INSECURE_TRANSPORT'] = '1'\n\n    # Get admin password\n    options.admin_password = None\n\n    # 1. Try password file\n    if options.admin_password_file is not None:\n        options.admin_password = options.keycloak_admin_password_file.readline().strip()\n        options.keycloak_admin_password_file.close()\n\n    # 2. Try KEYCLOAK_ADMIN_PASSWORD environment variable\n    if options.admin_password is None:\n        if (('KEYCLOAK_ADMIN_PASSWORD' in os.environ) and\n            (os.environ['KEYCLOAK_ADMIN_PASSWORD'])):\n            options.admin_password = os.environ['KEYCLOAK_ADMIN_PASSWORD']\n\n    try:\n        anonymous_conn = KeycloakAnonymousConnection(options.server,\n                                                     options.tls_verify)\n\n        admin_conn = KeycloakAdminConnection(options.server,\n                                             options.auth_role,\n                                             options.admin_realm,\n                                             ADMIN_CLIENT_ID,\n                                             options.admin_username,\n                                             options.admin_password,\n                                             options.tls_verify)\n    except Exception as e:\n        if options.show_traceback:\n            traceback.print_exc()\n        print(six.text_type(e), file=sys.stderr)\n        result = 1\n        return result\n\n    try:\n        if options.func == do_register_client:\n            conn = admin_conn\n        else:\n            conn = admin_conn\n        result = options.func(options, conn)\n    except Exception as e:\n        if options.show_traceback:\n            traceback.print_exc()\n        print(six.text_type(e), file=sys.stderr)\n        result = 2\n        return result\n\n    return result\n\n# ------------------------------------------------------------------------------\n\nif __name__ == '__main__':\n    sys.exit(main())\nelse:\n    logger = logging.getLogger('keycloak-cli')\n"], "fixing_code": ["from __future__ import print_function\n\nimport argparse\nimport json\nfrom oauthlib.oauth2 import LegacyApplicationClient\nimport logging\nimport logging.handlers\nfrom requests_oauthlib import OAuth2Session\nimport os\nimport requests\nimport six\nimport sys\nimport traceback\n\nfrom six.moves.urllib.parse import quote as urlquote\nfrom six.moves.urllib.parse import urlparse\n\n\n# ------------------------------------------------------------------------------\n\nlogger = None\nprog_name = os.path.basename(sys.argv[0])\nAUTH_ROLES = ['root-admin', 'realm-admin', 'anonymous']\n\nLOG_FILE_ROTATION_COUNT = 3\n\nTOKEN_URL_TEMPLATE = (\n    '{server}/auth/realms/{realm}/protocol/openid-connect/token')\nGET_SERVER_INFO_TEMPLATE = (\n    '{server}/auth/admin/serverinfo/')\nGET_REALMS_URL_TEMPLATE = (\n    '{server}/auth/admin/realms')\nCREATE_REALM_URL_TEMPLATE = (\n    '{server}/auth/admin/realms')\nDELETE_REALM_URL_TEMPLATE = (\n    '{server}/auth/admin/realms/{realm}')\nGET_REALM_METADATA_TEMPLATE = (\n    '{server}/auth/realms/{realm}/protocol/saml/descriptor')\n\nCLIENT_REPRESENTATION_TEMPLATE = (\n    '{server}/auth/admin/realms/{realm}/clients/{id}')\nGET_CLIENTS_URL_TEMPLATE = (\n    '{server}/auth/admin/realms/{realm}/clients')\nCLIENT_DESCRIPTOR_URL_TEMPLATE = (\n    '{server}/auth/admin/realms/{realm}/client-description-converter')\nCREATE_CLIENT_URL_TEMPLATE = (\n    '{server}/auth/admin/realms/{realm}/clients')\n\nGET_INITIAL_ACCESS_TOKEN_TEMPLATE = (\n    '{server}/auth/admin/realms/{realm}/clients-initial-access')\nSAML2_CLIENT_REGISTRATION_TEMPLATE = (\n  '{server}/auth/realms/{realm}/clients-registrations/saml2-entity-descriptor')\n\nGET_CLIENT_PROTOCOL_MAPPERS_TEMPLATE = (\n    '{server}/auth/admin/realms/{realm}/clients/{id}/protocol-mappers/models')\nGET_CLIENT_PROTOCOL_MAPPERS_BY_PROTOCOL_TEMPLATE = (\n    '{server}/auth/admin/realms/{realm}/clients/{id}/protocol-mappers/protocol/{protocol}')\n\nPOST_CLIENT_PROTOCOL_MAPPER_TEMPLATE = (\n    '{server}/auth/admin/realms/{realm}/clients/{id}/protocol-mappers/models')\n\n\nADMIN_CLIENT_ID = 'admin-cli'\n\n# ------------------------------------------------------------------------------\n\n\nclass RESTError(Exception):\n    def __init__(self, status_code, status_reason,\n                 response_json, response_text, cmd):\n        self.status_code = status_code\n        self.status_reason = status_reason\n        self.error_description = None\n        self.error = None\n        self.response_json = response_json\n        self.response_text = response_text\n        self.cmd = cmd\n\n        self.message = '{status_reason}({status_code}): '.format(\n            status_reason=self.status_reason,\n            status_code=self.status_code)\n\n        if response_json:\n            self.error_description = response_json.get('error_description')\n            if self.error_description is None:\n                self.error_description = response_json.get('errorMessage')\n            self.error = response_json.get('error')\n            self.message += '\"{error_description}\" [{error}]'.format(\n                error_description=self.error_description,\n                error=self.error)\n        else:\n            self.message += '\"{response_text}\"'.format(\n                response_text=self.response_text)\n\n        self.args = (self.message,)\n\n    def __str__(self):\n        return self.message\n\n# ------------------------------------------------------------------------------\n\n\ndef configure_logging(options):\n    global logger  # pylint: disable=W0603\n\n    log_dir = os.path.dirname(options.log_file)\n    if os.path.exists(log_dir):\n        if not os.path.isdir(log_dir):\n            raise ValueError('logging directory \"{log_dir}\" exists but is not '\n                             'directory'.format(log_dir=log_dir))\n    else:\n        os.makedirs(log_dir)\n\n    log_level = logging.ERROR\n    if options.verbose:\n        log_level = logging.INFO\n    if options.debug:\n        log_level = logging.DEBUG\n\n        # These two lines enable debugging at httplib level\n        # (requests->urllib3->http.client) You will see the REQUEST,\n        # including HEADERS and DATA, and RESPONSE with HEADERS but\n        # without DATA.  The only thing missing will be the\n        # response.body which is not logged.\n        try:\n            import http.client as http_client  # Python 3\n        except ImportError:\n            import httplib as http_client      # Python 2\n\n        http_client.HTTPConnection.debuglevel = 1\n\n        # Turn on cookielib debugging\n        if False:\n            try:\n                import http.cookiejar as cookiejar\n            except ImportError:\n                import cookielib as cookiejar  # Python 2\n            cookiejar.debug = True\n\n    logger = logging.getLogger(prog_name)\n\n    try:\n        file_handler = logging.handlers.RotatingFileHandler(\n            options.log_file, backupCount=LOG_FILE_ROTATION_COUNT)\n    except IOError as e:\n        print('Unable to open log file %s (%s)' % (options.log_file, e),\n              file=sys.stderr)\n\n    else:\n        formatter = logging.Formatter(\n            '%(asctime)s %(name)s %(levelname)s: %(message)s')\n        file_handler.setFormatter(formatter)\n        file_handler.setLevel(logging.DEBUG)\n        logger.addHandler(file_handler)\n\n    console_handler = logging.StreamHandler(sys.stdout)\n    formatter = logging.Formatter('%(message)s')\n    console_handler.setFormatter(formatter)\n    console_handler.setLevel(log_level)\n    logger.addHandler(console_handler)\n\n    # Set the log level on the logger to the lowest level\n    # possible. This allows the message to be emitted from the logger\n    # to it's handlers where the level will be filtered on a per\n    # handler basis.\n    logger.setLevel(1)\n\n# ------------------------------------------------------------------------------\n\n\ndef json_pretty(text):\n    return json.dumps(json.loads(text),\n                      indent=4, sort_keys=True)\n\n\ndef py_json_pretty(py_json):\n    return json_pretty(json.dumps(py_json))\n\n\ndef server_name_from_url(url):\n    return urlparse(url).netloc\n\n\ndef get_realm_names_from_realms(realms):\n    return [x['realm'] for x in realms]\n\n\ndef get_client_client_ids_from_clients(clients):\n    return [x['clientId'] for x in clients]\n\n\ndef find_client_by_name(clients, client_id):\n    for client in clients:\n        if client.get('clientId') == client_id:\n            return client\n    raise KeyError('{item} not found'.format(item=client_id))\n\n\n# ------------------------------------------------------------------------------\n\nclass KeycloakREST(object):\n\n    def __init__(self, server, auth_role=None, session=None):\n        self.server = server\n        self.auth_role = auth_role\n        self.session = session\n\n    def get_initial_access_token(self, realm_name):\n        cmd_name = \"get initial access token for realm '{realm}'\".format(\n            realm=realm_name)\n        url = GET_INITIAL_ACCESS_TOKEN_TEMPLATE.format(\n            server=self.server, realm=urlquote(realm_name))\n\n        logger.debug(\"%s on server %s\", cmd_name, self.server)\n\n        params = {\"expiration\": 60,  # seconds\n                  \"count\": 1}\n\n        response = self.session.post(url, json=params)\n        logger.debug(\"%s response code: %s %s\",\n                     cmd_name, response.status_code, response.reason)\n\n        try:\n            response_json = response.json()\n        except ValueError as e:\n            response_json = None\n\n        if (not response_json or\n            response.status_code != requests.codes.ok):\n            logger.error(\"%s error: status=%s (%s) text=%s\",\n                         cmd_name, response.status_code, response.reason,\n                         response.text)\n            raise RESTError(response.status_code, response.reason,\n                            response_json, response.text, cmd_name)\n\n        logger.debug(\"%s response = %s\", cmd_name, json_pretty(response.text))\n\n        return response_json    # ClientInitialAccessPresentation\n\n    def get_server_info(self):\n        cmd_name = \"get server info\"\n        url = GET_SERVER_INFO_TEMPLATE.format(server=self.server)\n\n        logger.debug(\"%s on server %s\", cmd_name, self.server)\n        response = self.session.get(url)\n        logger.debug(\"%s response code: %s %s\",\n                     cmd_name, response.status_code, response.reason)\n\n        try:\n            response_json = response.json()\n        except ValueError as e:\n            response_json = None\n\n        if (not response_json or\n            response.status_code != requests.codes.ok):\n            logger.error(\"%s error: status=%s (%s) text=%s\",\n                         cmd_name, response.status_code, response.reason,\n                         response.text)\n            raise RESTError(response.status_code, response.reason,\n                            response_json, response.text, cmd_name)\n\n        logger.debug(\"%s response = %s\", cmd_name, json_pretty(response.text))\n\n        return response_json\n\n    def get_realms(self):\n        cmd_name = \"get realms\"\n        url = GET_REALMS_URL_TEMPLATE.format(server=self.server)\n\n        logger.debug(\"%s on server %s\", cmd_name, self.server)\n        response = self.session.get(url)\n        logger.debug(\"%s response code: %s %s\",\n                     cmd_name, response.status_code, response.reason)\n\n        try:\n            response_json = response.json()\n        except ValueError as e:\n            response_json = None\n\n        if (not response_json or\n            response.status_code != requests.codes.ok):\n            logger.error(\"%s error: status=%s (%s) text=%s\",\n                         cmd_name, response.status_code, response.reason,\n                         response.text)\n            raise RESTError(response.status_code, response.reason,\n                            response_json, response.text, cmd_name)\n\n        logger.debug(\"%s response = %s\", cmd_name, json_pretty(response.text))\n\n        return response_json\n\n    def create_realm(self, realm_name):\n        cmd_name = \"create realm '{realm}'\".format(realm=realm_name)\n        url = CREATE_REALM_URL_TEMPLATE.format(server=self.server)\n\n        logger.debug(\"%s on server %s\", cmd_name, self.server)\n\n        params = {\"enabled\": True,\n                  \"id\": realm_name,\n                  \"realm\": realm_name,\n                  }\n\n        response = self.session.post(url, json=params)\n        logger.debug(\"%s response code: %s %s\",\n                     cmd_name, response.status_code, response.reason)\n\n        try:\n            response_json = response.json()\n        except ValueError as e:\n            response_json = None\n\n        if response.status_code != requests.codes.created:\n            logger.error(\"%s error: status=%s (%s) text=%s\",\n                         cmd_name, response.status_code, response.reason,\n                         response.text)\n            raise RESTError(response.status_code, response.reason,\n                            response_json, response.text, cmd_name)\n\n        logger.debug(\"%s response = %s\", cmd_name, response.text)\n\n    def delete_realm(self, realm_name):\n        cmd_name = \"delete realm '{realm}'\".format(realm=realm_name)\n        url = DELETE_REALM_URL_TEMPLATE.format(\n            server=self.server, realm=urlquote(realm_name))\n\n        logger.debug(\"%s on server %s\", cmd_name, self.server)\n        response = self.session.delete(url)\n        logger.debug(\"%s response code: %s %s\",\n                     cmd_name, response.status_code, response.reason)\n\n        try:\n            response_json = response.json()\n        except ValueError as e:\n            response_json = None\n\n        if response.status_code != requests.codes.no_content:\n            logger.error(\"%s error: status=%s (%s) text=%s\",\n                         cmd_name, response.status_code, response.reason,\n                         response.text)\n            raise RESTError(response.status_code, response.reason,\n                            response_json, response.text, cmd_name)\n\n        logger.debug(\"%s response = %s\", cmd_name, response.text)\n\n    def get_realm_metadata(self, realm_name):\n        cmd_name = \"get metadata for realm '{realm}'\".format(realm=realm_name)\n        url = GET_REALM_METADATA_TEMPLATE.format(\n            server=self.server, realm=urlquote(realm_name))\n\n        logger.debug(\"%s on server %s\", cmd_name, self.server)\n        response = self.session.get(url)\n        logger.debug(\"%s response code: %s %s\",\n                     cmd_name, response.status_code, response.reason)\n\n        try:\n            response_json = response.json()\n        except ValueError as e:\n            response_json = None\n\n        if response.status_code != requests.codes.ok:\n            logger.error(\"%s error: status=%s (%s) text=%s\",\n                         cmd_name, response.status_code, response.reason,\n                         response.text)\n            raise RESTError(response.status_code, response.reason,\n                            response_json, response.text, cmd_name)\n\n        logger.debug(\"%s response = %s\", cmd_name, response.text)\n        return response.text\n\n    def get_clients(self, realm_name):\n        cmd_name = \"get clients in realm '{realm}'\".format(realm=realm_name)\n        url = GET_CLIENTS_URL_TEMPLATE.format(\n            server=self.server, realm=urlquote(realm_name))\n\n        logger.debug(\"%s on server %s\", cmd_name, self.server)\n        response = self.session.get(url)\n        logger.debug(\"%s response code: %s %s\",\n                     cmd_name, response.status_code, response.reason)\n\n        try:\n            response_json = response.json()\n        except ValueError as e:\n            response_json = None\n\n        if (not response_json or\n            response.status_code != requests.codes.ok):\n            logger.error(\"%s error: status=%s (%s) text=%s\",\n                         cmd_name, response.status_code, response.reason,\n                         response.text)\n            raise RESTError(response.status_code, response.reason,\n                            response_json, response.text, cmd_name)\n\n        logger.debug(\"%s response = %s\", cmd_name, json_pretty(response.text))\n\n        return response_json\n\n\n    def get_client_by_id(self, realm_name, id):\n        cmd_name = \"get client id {id} in realm '{realm}'\".format(\n            id=id, realm=realm_name)\n        url = GET_CLIENTS_URL_TEMPLATE.format(\n            server=self.server, realm=urlquote(realm_name))\n\n        params = {'clientID': id}\n\n        logger.debug(\"%s on server %s\", cmd_name, self.server)\n        response = self.session.get(url, params=params)\n        logger.debug(\"%s response code: %s %s\",\n                     cmd_name, response.status_code, response.reason)\n\n        try:\n            response_json = response.json()\n        except ValueError as e:\n            response_json = None\n\n        if (not response_json or\n            response.status_code != requests.codes.ok):\n            logger.error(\"%s error: status=%s (%s) text=%s\",\n                         cmd_name, response.status_code, response.reason,\n                         response.text)\n            raise RESTError(response.status_code, response.reason,\n                            response_json, response.text, cmd_name)\n\n        logger.debug(\"%s response = %s\", cmd_name, json_pretty(response.text))\n\n        return response_json\n\n\n    def get_client_by_name(self, realm_name, client_name):\n        clients = self.get_clients(realm_name)\n        client = find_client_by_name(clients, client_name)\n        id = client.get('id')\n        logger.debug(\"client name '%s' mapped to id '%s'\",\n                     client_name, id)\n        logger.debug(\"client %s\\n%s\", client_name, py_json_pretty(client))\n        return client\n\n    def get_client_id_by_name(self, realm_name, client_name):\n        client = self.get_client_by_name(realm_name, client_name)\n        id = client.get('id')\n        return id\n\n    def get_client_descriptor(self, realm_name, metadata):\n        cmd_name = \"get client descriptor realm '{realm}'\".format(\n            realm=realm_name)\n        url = CLIENT_DESCRIPTOR_URL_TEMPLATE.format(\n            server=self.server, realm=urlquote(realm_name))\n\n        logger.debug(\"%s on server %s\", cmd_name, self.server)\n\n        headers = {'Content-Type': 'application/xml;charset=utf-8'}\n\n        response = self.session.post(url, headers=headers, data=metadata)\n        logger.debug(\"%s response code: %s %s\",\n                     cmd_name, response.status_code, response.reason)\n\n        try:\n            response_json = response.json()\n        except ValueError as e:\n            response_json = None\n\n        if (not response_json or\n            response.status_code != requests.codes.ok):\n            logger.error(\"%s error: status=%s (%s) text=%s\",\n                         cmd_name, response.status_code, response.reason,\n                         response.text)\n            raise RESTError(response.status_code, response.reason,\n                            response_json, response.text, cmd_name)\n\n        logger.debug(\"%s response = %s\", cmd_name, json_pretty(response.text))\n\n        return response_json\n\n    def create_client_from_descriptor(self, realm_name, descriptor):\n        cmd_name = \"create client from descriptor \"\n        \"'{client_id}'in realm '{realm}'\".format(\n            client_id=descriptor['clientId'], realm=realm_name)\n        url = CREATE_CLIENT_URL_TEMPLATE.format(\n            server=self.server, realm=urlquote(realm_name))\n\n        logger.debug(\"%s on server %s\", cmd_name, self.server)\n\n        response = self.session.post(url, json=descriptor)\n        logger.debug(\"%s response code: %s %s\",\n                     cmd_name, response.status_code, response.reason)\n\n        try:\n            response_json = response.json()\n        except ValueError as e:\n            response_json = None\n\n        if response.status_code != requests.codes.created:\n            logger.error(\"%s error: status=%s (%s) text=%s\",\n                         cmd_name, response.status_code, response.reason,\n                         response.text)\n            raise RESTError(response.status_code, response.reason,\n                            response_json, response.text, cmd_name)\n\n        logger.debug(\"%s response = %s\", cmd_name, response.text)\n\n    def create_client(self, realm_name, metadata):\n        logger.debug(\"create client in realm %s on server %s\",\n                     realm_name, self.server)\n        descriptor = self.get_client_descriptor(realm_name, metadata)\n        self.create_client_from_descriptor(realm_name, descriptor)\n        return descriptor\n\n    def register_client(self, initial_access_token, realm_name, metadata):\n        cmd_name = \"register_client realm '{realm}'\".format(\n            realm=realm_name)\n        url = SAML2_CLIENT_REGISTRATION_TEMPLATE.format(\n            server=self.server, realm=urlquote(realm_name))\n\n        logger.debug(\"%s on server %s\", cmd_name, self.server)\n\n        headers = {'Content-Type': 'application/xml;charset=utf-8'}\n\n        if initial_access_token:\n            headers['Authorization'] = 'Bearer {token}'.format(\n                token=initial_access_token)\n\n        response = self.session.post(url, headers=headers, data=metadata)\n        logger.debug(\"%s response code: %s %s\",\n                     cmd_name, response.status_code, response.reason)\n\n        try:\n            response_json = response.json()\n        except ValueError as e:\n            response_json = None\n\n        if (not response_json or\n            response.status_code != requests.codes.created):\n            logger.error(\"%s error: status=%s (%s) text=%s\",\n                         cmd_name, response.status_code, response.reason,\n                         response.text)\n            raise RESTError(response.status_code, response.reason,\n                            response_json, response.text, cmd_name)\n\n        logger.debug(\"%s response = %s\", cmd_name, json_pretty(response.text))\n\n        return response_json    # ClientRepresentation\n\n    def delete_client_by_name(self, realm_name, client_name):\n        id = self.get_client_id_by_name(realm_name, client_name)\n        self.delete_client_by_id(realm_name, id)\n\n\n    def delete_client_by_id(self, realm_name, id):\n        cmd_name = \"delete client id '{id}'in realm '{realm}'\".format(\n            id=id, realm=realm_name)\n        url = CLIENT_REPRESENTATION_TEMPLATE.format(\n            server=self.server, realm=urlquote(realm_name),\n            id=urlquote(id))\n\n        logger.debug(\"%s on server %s\", cmd_name, self.server)\n        response = self.session.delete(url)\n        logger.debug(\"%s response code: %s %s\",\n                     cmd_name, response.status_code, response.reason)\n\n        try:\n            response_json = response.json()\n        except ValueError as e:\n            response_json = None\n\n        if response.status_code != requests.codes.no_content:\n            logger.error(\"%s error: status=%s (%s) text=%s\",\n                         cmd_name, response.status_code, response.reason,\n                         response.text)\n            raise RESTError(response.status_code, response.reason,\n                            response_json, response.text, cmd_name)\n\n        logger.debug(\"%s response = %s\", cmd_name, response.text)\n\n    def update_client(self, realm_name, client):\n        id = client['id']\n        cmd_name = \"update client {id} in realm '{realm}'\".format(\n            id=client['clientId'], realm=realm_name)\n        url = CLIENT_REPRESENTATION_TEMPLATE.format(\n            server=self.server, realm=urlquote(realm_name),\n            id=urlquote(id))\n\n        logger.debug(\"%s on server %s\", cmd_name, self.server)\n\n        response = self.session.put(url, json=client)\n        logger.debug(\"%s response code: %s %s\",\n                     cmd_name, response.status_code, response.reason)\n\n        try:\n            response_json = response.json()\n        except ValueError as e:\n            response_json = None\n\n        if response.status_code != requests.codes.no_content:\n            logger.error(\"%s error: status=%s (%s) text=%s\",\n                         cmd_name, response.status_code, response.reason,\n                         response.text)\n            raise RESTError(response.status_code, response.reason,\n                            response_json, response.text, cmd_name)\n\n        logger.debug(\"%s response = %s\", cmd_name, response.text)\n\n\n    def update_client_attributes(self, realm_name, client, update_attrs):\n        client_id = client['clientId']\n        logger.debug(\"update client attrs: client_id=%s \"\n        \"current attrs=%s update=%s\" % (client_id, client['attributes'],\n                                update_attrs))\n        client['attributes'].update(update_attrs)\n        logger.debug(\"update client attrs: client_id=%s \"\n        \"new attrs=%s\" % (client_id, client['attributes']))\n        self.update_client(realm_name, client);\n\n\n    def update_client_by_name_attributes(self, realm_name, client_name,\n                                         update_attrs):\n        client = self.get_client_by_name(realm_name, client_name)\n        self.update_client_attributes(realm_name, client, update_attrs)\n\n    def new_saml_group_protocol_mapper(self, mapper_name, attribute_name,\n                                       friendly_name=None,\n                                       single_attribute=True):\n        mapper = {\n            'protocol': 'saml',\n            'name': mapper_name,\n            'protocolMapper': 'saml-group-membership-mapper',\n            'config': {\n                'attribute.name': attribute_name,\n                'attribute.nameformat': 'Basic',\n                'single': single_attribute,\n                'full.path': False,\n            },\n        }\n\n        if friendly_name:\n            mapper['config']['friendly.name'] = friendly_name\n\n        return mapper\n\n    def create_client_protocol_mapper(self, realm_name, client, mapper):\n        id = client['id']\n        cmd_name = (\"create protocol-mapper '{mapper_name}' for client {id} \"\n                    \"in realm '{realm}'\".format(\n                        mapper_name=mapper['name'],id=client['clientId'], realm=realm_name))\n        url = POST_CLIENT_PROTOCOL_MAPPER_TEMPLATE.format(\n            server=self.server,\n            realm=urlquote(realm_name),\n            id=urlquote(id))\n\n        logger.debug(\"%s on server %s\", cmd_name, self.server)\n\n        response = self.session.post(url, json=mapper)\n        logger.debug(\"%s response code: %s %s\",\n                     cmd_name, response.status_code, response.reason)\n\n        try:\n            response_json = response.json()\n        except ValueError as e:\n            response_json = None\n\n        if response.status_code != requests.codes.created:\n            logger.error(\"%s error: status=%s (%s) text=%s\",\n                         cmd_name, response.status_code, response.reason,\n                         response.text)\n            raise RESTError(response.status_code, response.reason,\n                            response_json, response.text, cmd_name)\n\n        logger.debug(\"%s response = %s\", cmd_name, response.text)\n\n\n    def create_client_by_name_protocol_mapper(self, realm_name, client_name,\n                                              mapper):\n        client = self.get_client_by_name(realm_name, client_name)\n        self.create_client_protocol_mapper(realm_name, client, mapper)\n\n\n\n    def add_client_by_name_redirect_uris(self, realm_name, client_name, uris):\n        client = self.get_client_by_name(realm_name, client_name)\n\n        uris = set(uris)\n        redirect_uris = set(client['redirectUris'])\n        redirect_uris |= uris\n        client['redirectUris'] = list(redirect_uris)\n        self.update_client(realm_name, client);\n\n    def remove_client_by_name_redirect_uris(self, realm_name, client_name, uris):\n        client = self.get_client_by_name(realm_name, client_name)\n\n        uris = set(uris)\n        redirect_uris = set(client['redirectUris'])\n        redirect_uris -= uris\n        client['redirectUris'] = list(redirect_uris)\n\n        self.update_client(realm_name, client);\n\n\n# ------------------------------------------------------------------------------\n\n\nclass KeycloakAdminConnection(KeycloakREST):\n\n    def __init__(self, server, auth_role, realm, client_id,\n                 username, password, tls_verify):\n        super(KeycloakAdminConnection, self).__init__(server, auth_role)\n\n        self.realm = realm\n        self.client_id = client_id\n        self.username = username\n        self.password = password\n\n        self.session = self._create_session(tls_verify)\n\n    def _create_session(self, tls_verify):\n        token_url = TOKEN_URL_TEMPLATE.format(\n            server=self.server, realm=urlquote(self.realm))\n        refresh_url = token_url\n\n        client = LegacyApplicationClient(client_id=self.client_id)\n        session = OAuth2Session(client=client,\n                                auto_refresh_url=refresh_url,\n                                auto_refresh_kwargs={\n                                    'client_id': self.client_id})\n\n        session.verify = tls_verify\n        token = session.fetch_token(token_url=token_url,\n                                    username=self.username,\n                                    password=self.password,\n                                    client_id=self.client_id,\n                                    verify=session.verify)\n\n        return session\n\n\nclass KeycloakAnonymousConnection(KeycloakREST):\n\n    def __init__(self, server, tls_verify):\n        super(KeycloakAnonymousConnection, self).__init__(server, 'anonymous')\n        self.session = self._create_session(tls_verify)\n\n\n    def _create_session(self, tls_verify):\n        session = requests.Session()\n        session.verify = tls_verify\n\n        return session\n\n# ------------------------------------------------------------------------------\n\n\ndef do_server_info(options, conn):\n    server_info = conn.get_server_info()\n    print(json_pretty(server_info))\n\n\ndef do_list_realms(options, conn):\n    realms = conn.get_realms()\n    realm_names = get_realm_names_from_realms(realms)\n    print('\\n'.join(sorted(realm_names)))\n\n\ndef do_create_realm(options, conn):\n    conn.create_realm(options.realm_name)\n\n\ndef do_delete_realm(options, conn):\n    conn.delete_realm(options.realm_name)\n\n\ndef do_get_realm_metadata(options, conn):\n    metadata = conn.get_realm_metadata(options.realm_name)\n    print(metadata)\n\n\ndef do_list_clients(options, conn):\n    clients = conn.get_clients(options.realm_name)\n    client_ids = get_client_client_ids_from_clients(clients)\n    print('\\n'.join(sorted(client_ids)))\n\n\ndef do_create_client(options, conn):\n    metadata = options.metadata.read()\n    descriptor = conn.create_client(options.realm_name, metadata)\n\n\ndef do_register_client(options, conn):\n    metadata = options.metadata.read()\n    client_representation = conn.register_client(\n        options.initial_access_token,\n        options.realm_name, metadata)\n\n\ndef do_delete_client(options, conn):\n    conn.delete_client_by_name(options.realm_name, options.client_name)\n\ndef do_client_test(options, conn):\n    'experimental test code used during development'\n\n    uri = 'https://openstack.jdennis.oslab.test:5000/v3/mellon/fooResponse'\n\n    conn.remove_client_by_name_redirect_uri(options.realm_name,\n                                            options.client_name,\n                                            uri)\n\n# ------------------------------------------------------------------------------\n\nverbose_help = '''\n\nThe structure of the command line arguments is \"noun verb\" where noun\nis one of Keycloak's data items (e.g. realm, client, etc.) and the\nverb is an action to perform on the item. Each of the nouns and verbs\nmay have their own set of arguments which must follow the noun or\nverb.\n\nFor example to delete the client XYZ in the realm ABC:\n\necho password | {prog_name} -s http://example.com:8080 -P - client delete -r ABC -c XYZ\n\nwhere 'client' is the noun, 'delete' is the verb and -r ABC -c XYZ are\narguments to the delete action.\n\nIf the command completes successfully the exit status is 0. The exit\nstatus is 1 if an authenticated connection with the server cannont be\nsuccessfully established. The exit status is 2 if the REST operation\nfails.\n\nThe server should be a scheme://hostname:port URL.\n'''\n\n\nclass TlsVerifyAction(argparse.Action):\n    def __init__(self, option_strings, dest, nargs=None, **kwargs):\n        if nargs is not None:\n            raise ValueError(\"nargs not allowed\")\n        super(TlsVerifyAction, self).__init__(option_strings, dest, **kwargs)\n\n    def __call__(self, parser, namespace, values, option_string=None):\n        if values.lower() in ['true', 'yes', 'on']:\n            verify = True\n        elif values.lower() in ['false', 'no', 'off']:\n            verify = False\n        else:\n            verify = values\n            \n        setattr(namespace, self.dest, verify)\n\ndef main():\n    global logger\n    result = 0\n\n    parser = argparse.ArgumentParser(description='Keycloak REST client',\n                    prog=prog_name,\n                    epilog=verbose_help.format(prog_name=prog_name),\n                    formatter_class=argparse.RawDescriptionHelpFormatter)\n\n    parser.add_argument('-v', '--verbose', action='store_true',\n                        help='be chatty')\n\n    parser.add_argument('-d', '--debug', action='store_true',\n                        help='turn on debug info')\n\n    parser.add_argument('--show-traceback', action='store_true',\n                        help='exceptions print traceback in addition to '\n                             'error message')\n\n    parser.add_argument('--log-file',\n                        default='{prog_name}.log'.format(\n                            prog_name=prog_name),\n                        help='log file pathname')\n\n    parser.add_argument('--permit-insecure-transport',  action='store_true',\n                        help='Normally secure transport such as TLS '\n                        'is required, defeat this check')\n\n    parser.add_argument('--tls-verify', action=TlsVerifyAction,\n                        default=True,\n                        help='TLS certificate verification for requests to'\n                        ' the server. May be one of case insenstive '\n                        '[true, yes, on] to enable,'\n                        '[false, no, off] to disable.'\n                        'Or the pathname to a OpenSSL CA bundle to use.'\n                        ' Default is True.')\n\n    group = parser.add_argument_group('Server')\n\n    group.add_argument('-s', '--server',\n                       required=True,\n                       help='DNS name or IP address of Keycloak server')\n\n    group.add_argument('-a', '--auth-role',\n                       choices=AUTH_ROLES,\n                       default='root-admin',\n                       help='authenticating as what type of user (default: root-admin)')\n\n    group.add_argument('-u', '--admin-username',\n                       default='admin',\n                       help='admin user name (default: admin)')\n\n    group.add_argument('-P', '--admin-password-file',\n                       type=argparse.FileType('rb'),\n                       help=('file containing admin password '\n                             '(or use a hyphen \"-\" to read the password '\n                             'from stdin)'))\n\n    group.add_argument('--admin-realm',\n                       default='master',\n                       help='realm admin belongs to')\n\n    cmd_parsers = parser.add_subparsers(help='available commands')\n\n    # --- realm commands ---\n    realm_parser = cmd_parsers.add_parser('realm',\n                                          help='realm operations')\n\n    sub_parser = realm_parser.add_subparsers(help='realm commands')\n\n    cmd_parser = sub_parser.add_parser('server_info',\n                                       help='dump server info')\n    cmd_parser.set_defaults(func=do_server_info)\n\n    cmd_parser = sub_parser.add_parser('list',\n                                       help='list realm names')\n    cmd_parser.set_defaults(func=do_list_realms)\n\n    cmd_parser = sub_parser.add_parser('create',\n                                       help='create new realm')\n    cmd_parser.add_argument('-r', '--realm-name', required=True,\n                            help='realm name')\n    cmd_parser.set_defaults(func=do_create_realm)\n\n    cmd_parser = sub_parser.add_parser('delete',\n                                       help='delete existing realm')\n    cmd_parser.add_argument('-r', '--realm-name', required=True,\n                            help='realm name')\n    cmd_parser.set_defaults(func=do_delete_realm)\n\n    cmd_parser = sub_parser.add_parser('metadata',\n                                       help='retrieve realm metadata')\n    cmd_parser.add_argument('-r', '--realm-name', required=True,\n                            help='realm name')\n    cmd_parser.set_defaults(func=do_get_realm_metadata)\n\n    # --- client commands ---\n    client_parser = cmd_parsers.add_parser('client',\n                                           help='client operations')\n\n    sub_parser = client_parser.add_subparsers(help='client commands')\n\n    cmd_parser = sub_parser.add_parser('list',\n                                       help='list client names')\n    cmd_parser.add_argument('-r', '--realm-name', required=True,\n                            help='realm name')\n\n    cmd_parser.set_defaults(func=do_list_clients)\n\n    cmd_parser = sub_parser.add_parser('create',\n                                       help='create new client')\n    cmd_parser.add_argument('-r', '--realm-name', required=True,\n                            help='realm name')\n    cmd_parser.add_argument('-m', '--metadata', type=argparse.FileType('rb'),\n                            required=True,\n                            help='SP metadata file or stdin')\n    cmd_parser.set_defaults(func=do_create_client)\n\n    cmd_parser = sub_parser.add_parser('register',\n                                       help='register new client')\n    cmd_parser.add_argument('-r', '--realm-name', required=True,\n                            help='realm name')\n    cmd_parser.add_argument('-m', '--metadata', type=argparse.FileType('rb'),\n                            required=True,\n                            help='SP metadata file or stdin')\n    cmd_parser.add_argument('--initial-access-token', required=True,\n                            help='realm initial access token for '\n                            'client registeration')\n    cmd_parser.set_defaults(func=do_register_client)\n\n    cmd_parser = sub_parser.add_parser('delete',\n                                       help='delete existing client')\n    cmd_parser.add_argument('-r', '--realm-name', required=True,\n                            help='realm name')\n    cmd_parser.add_argument('-c', '--client-name', required=True,\n                            help='client name')\n    cmd_parser.set_defaults(func=do_delete_client)\n\n    cmd_parser = sub_parser.add_parser('test',\n                                       help='experimental test used during '\n                                       'development')\n    cmd_parser.add_argument('-r', '--realm-name', required=True,\n                            help='realm name')\n    cmd_parser.add_argument('-c', '--client-name', required=True,\n                            help='client name')\n    cmd_parser.set_defaults(func=do_client_test)\n\n    # Process command line arguments\n    options = parser.parse_args()\n    configure_logging(options)\n\n    if options.permit_insecure_transport:\n        os.environ['OAUTHLIB_INSECURE_TRANSPORT'] = '1'\n\n    # Get admin password\n    options.admin_password = None\n\n    # 1. Try password file\n    if options.admin_password_file is not None:\n        options.admin_password = options.keycloak_admin_password_file.readline().strip()\n        options.keycloak_admin_password_file.close()\n\n    # 2. Try KEYCLOAK_ADMIN_PASSWORD environment variable\n    if options.admin_password is None:\n        if (('KEYCLOAK_ADMIN_PASSWORD' in os.environ) and\n            (os.environ['KEYCLOAK_ADMIN_PASSWORD'])):\n            options.admin_password = os.environ['KEYCLOAK_ADMIN_PASSWORD']\n\n    try:\n        anonymous_conn = KeycloakAnonymousConnection(options.server,\n                                                     options.tls_verify)\n\n        admin_conn = KeycloakAdminConnection(options.server,\n                                             options.auth_role,\n                                             options.admin_realm,\n                                             ADMIN_CLIENT_ID,\n                                             options.admin_username,\n                                             options.admin_password,\n                                             options.tls_verify)\n    except Exception as e:\n        if options.show_traceback:\n            traceback.print_exc()\n        print(six.text_type(e), file=sys.stderr)\n        result = 1\n        return result\n\n    try:\n        if options.func == do_register_client:\n            conn = admin_conn\n        else:\n            conn = admin_conn\n        result = options.func(options, conn)\n    except Exception as e:\n        if options.show_traceback:\n            traceback.print_exc()\n        print(six.text_type(e), file=sys.stderr)\n        result = 2\n        return result\n\n    return result\n\n# ------------------------------------------------------------------------------\n\nif __name__ == '__main__':\n    sys.exit(main())\nelse:\n    logger = logging.getLogger('keycloak-cli')\n"], "filenames": ["keycloak_httpd_client/keycloak_cli.py"], "buggy_code_start_loc": [866], "buggy_code_end_loc": [867], "fixing_code_start_loc": [866], "fixing_code_end_loc": [867], "type": "CWE-59", "message": "keycloak-httpd-client-install versions before 0.8 insecurely creates temporary file allowing local attackers to overwrite other files via symbolic link.", "other": {"cve": {"id": "CVE-2017-15111", "sourceIdentifier": "secalert@redhat.com", "published": "2018-01-20T00:29:00.467", "lastModified": "2019-08-06T17:15:15.133", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "keycloak-httpd-client-install versions before 0.8 insecurely creates temporary file allowing local attackers to overwrite other files via symbolic link."}, {"lang": "es", "value": "keycloak-httpd-client-install, en versiones anteriores a la 0.8, crea archivos temporales de forma insegura, lo que permite que atacantes locales sobrescriban otros archivos mediante un enlace simb\u00f3lico."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:H/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:P/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 3.6}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-59"}]}, {"source": "secalert@redhat.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-377"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:keycloak-httpd-client-install_project:keycloak-httpd-client-install:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.8", "matchCriteriaId": "AD338DCE-487F-49A6-B72F-90037280ACAA"}]}]}], "references": [{"url": "https://access.redhat.com/errata/RHSA-2019:2137", "source": "secalert@redhat.com"}, {"url": "https://github.com/jdennis/keycloak-httpd-client-install/commit/07f26e213196936fb328ea0c1d5a66a09d8b5440", "source": "secalert@redhat.com", "tags": ["Patch", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/jdennis/keycloak-httpd-client-install/commit/07f26e213196936fb328ea0c1d5a66a09d8b5440"}}