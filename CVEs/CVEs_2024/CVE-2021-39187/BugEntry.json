{"buggy_code": ["# Parse Server Changelog\n\nJump directly to a version:\n\n| 4.x                                  |\n|--------------------------------------|\n| [**4.10.2 (latest release)**](#4102) |\n| [4.10.1](#4101)                      |\n| [4.10.0](#4100)                      |\n| [4.5.2](#452)                        |\n| [4.5.1](#451)                        |\n| [4.5.0](#450)                        |\n| [4.4.0](#440)                        |\n| [4.3.0](#430)                        |\n| [4.2.0](#420)                        |\n| [4.1.0](#410)                        |\n| [4.0.2](#402)                        |\n| [4.0.1](#401)                        |\n| [4.0.0](#400)                        |\n\n<details>\n<summary>Previous Versions</summary>\n\n| 3.x             | 2.x             |\n|-----------------|-----------------|\n| [3.10.0](#3100) | [2.8.4](#284)   |\n| [3.9.0](#390)   | [2.8.3](#283)   |\n| [3.8.0](#380)   | [2.8.2](#282)   |\n| [3.7.2](#372)   | [2.8.1](#281)   |\n| [3.7.1](#371)   | [2.8.0](#280)   |\n| [3.7.0](#370)   | [2.7.4](#274)   |\n| [3.6.0](#360)   | [2.7.3](#273)   |\n| [3.5.0](#350)   | [2.7.2](#272)   |\n| [3.4.4](#344)   | [2.7.1](#271)   |\n| [3.4.3](#343)   | [2.7.0](#270)   |\n| [3.4.2](#342)   | [2.6.5](#265)   |\n| [3.4.1](#341)   | [2.6.4](#264)   |\n| [3.4.0](#340)   | [2.6.3](#263)   |\n| [3.3.0](#330)   | [2.6.2](#262)   |\n| [3.2.3](#323)   | [2.6.1](#261)   |\n| [3.2.2](#322)   | [2.6.0](#260)   |\n| [3.2.1](#321)   | [2.5.3](#253)   |\n| [3.2.0](#320)   | [2.5.2](#252)   |\n| [3.1.3](#313)   | [2.5.1](#251)   |\n| [3.1.2](#312)   | [2.5.0](#250)   |\n| [3.1.1](#311)   | [2.4.2](#242)   |\n| [3.1.0](#310)   | [2.4.1](#241)   |\n| [3.0.0](#300)   | [2.4.0](#240)   |\n|                 | [2.3.8](#238)   |\n|                 | [2.3.7](#237)   |\n|                 | [2.3.6](#236)   |\n|                 | [2.3.5](#235)   |\n|                 | [2.3.3](#233)   |\n|                 | [2.3.2](#232)   |\n|                 | [2.3.1](#231)   |\n|                 | [2.3.0](#230)   |\n|                 | [2.2.25](#2225) |\n|                 | [2.2.24](#2224) |\n|                 | [2.2.23](#2223) |\n|                 | [2.2.22](#2222) |\n|                 | [2.2.21](#2221) |\n|                 | [2.2.20](#2220) |\n|                 | [2.2.19](#2219) |\n|                 | [2.2.18](#2218) |\n|                 | [2.2.17](#2217) |\n|                 | [2.2.16](#2216) |\n|                 | [2.2.15](#2215) |\n|                 | [2.2.14](#2214) |\n|                 | [2.2.13](#2213) |\n|                 | [2.2.12](#2212) |\n|                 | [2.2.11](#2211) |\n|                 | [2.2.10](#2210) |\n|                 | [2.2.9](#229)   |\n|                 | [2.2.8](#228)   |\n|                 | [2.2.7](#227)   |\n|                 | [2.2.6](#226)   |\n|                 | [2.2.5](#225)   |\n|                 | [2.2.4](#224)   |\n|                 | [2.2.3](#223)   |\n|                 | [2.2.2](#222)   |\n|                 | [2.2.1](#221)   |\n|                 | [2.2.0](#220)   |\n|                 | [2.1.6](#216)   |\n|                 | [2.1.5](#215)   |\n|                 | [2.1.4](#214)   |\n|                 | [2.1.3](#213)   |\n|                 | [2.1.2](#212)   |\n|                 | [2.1.1](#211)   |\n|                 | [2.1.0](#210)   |\n|                 | [2.0.8](#208)   |\n</details>\n\n___\n\n## Unreleased (Master Branch)\n[Full Changelog](https://github.com/parse-community/parse-server/compare/4.10.2...master)\n### Breaking Changes\n- Improved schema caching through database real-time hooks. Reduces DB queries, decreases Parse Query execution time and fixes a potential schema memory leak. If multiple Parse Server instances connect to the same DB (for example behind a load balancer), set the [Parse Server Option](https://parseplatform.org/parse-server/api/master/ParseServerOptions.html) `databaseOptions.enableSchemaHooks: true` to enable this feature and keep the schema in sync across all instances. Failing to do so will cause a schema change to not propagate to other instances and re-syncing will only happen when these instances restart. The options `enableSingleSchemaCache` and `schemaCacheTTL` have been removed. To use this feature with MongoDB, a replica set cluster with [change stream](https://docs.mongodb.com/manual/changeStreams/#availability) support is required. (Diamond Lewis, SebC) [#7214](https://github.com/parse-community/parse-server/issues/7214)\n- Added file upload restriction. File upload is now only allowed for authenticated users by default for improved security. To allow file upload also for Anonymous Users or Public, set the `fileUpload` parameter in the [Parse Server Options](https://parseplatform.org/parse-server/api/master/ParseServerOptions.html) (dblythy, Manuel Trezza) [#7071](https://github.com/parse-community/parse-server/pull/7071)\n- Removed [parse-server-simple-mailgun-adapter](https://github.com/parse-community/parse-server-simple-mailgun-adapter) dependency; to continue using the adapter it has to be explicitly installed (Manuel Trezza) [#7321](https://github.com/parse-community/parse-server/pull/7321)\n- Remove support for MongoDB 3.6 which has reached its End-of-Life date and PostgreSQL 10 (Manuel Trezza) [#7315](https://github.com/parse-community/parse-server/pull/7315)\n- Remove support for Node 10 which has reached its End-of-Life date (Manuel Trezza) [#7314](https://github.com/parse-community/parse-server/pull/7314)\n- Remove S3 Files Adapter from Parse Server, instead install separately as `@parse/s3-files-adapter` (Manuel Trezza) [#7324](https://github.com/parse-community/parse-server/pull/7324)\n### Notable Changes\n- Added Parse Server Security Check to report weak security settings (Manuel Trezza, dblythy) [#7247](https://github.com/parse-community/parse-server/issues/7247)\n- EXPERIMENTAL: Added new page router with placeholder rendering and localization of custom and feature pages such as password reset and email verification (Manuel Trezza) [#7128](https://github.com/parse-community/parse-server/pull/7128)\n- EXPERIMENTAL: Added custom routes to easily customize flows for password reset, email verification or build entirely new flows (Manuel Trezza) [#7231](https://github.com/parse-community/parse-server/pull/7231)\n- Added Deprecation Policy to govern the introduction of breaking changes in a phased pattern that is more predictable for developers (Manuel Trezza) [#7199](https://github.com/parse-community/parse-server/pull/7199)\n- Add REST API endpoint `/loginAs` to create session of any user with master key; allows to impersonate another user. (GormanFletcher) [#7406](https://github.com/parse-community/parse-server/pull/7406)\n- Add official support for MongoDB 5.0 (Manuel Trezza) [#7469](https://github.com/parse-community/parse-server/pull/7469)\n- Add issue bot (Manuel Trezza) [#7523](https://github.com/parse-community/parse-server/pull/7523)\n\n### Other Changes\n- Support native mongodb syntax in aggregation pipelines (Raschid JF Rafeally) [#7339](https://github.com/parse-community/parse-server/pull/7339)\n- Fix error when a not yet inserted job is updated (Antonio Davi Macedo Coelho de Castro) [#7196](https://github.com/parse-community/parse-server/pull/7196)\n- request.context for afterFind triggers (dblythy) [#7078](https://github.com/parse-community/parse-server/pull/7078)\n- Winston Logger interpolating stdout to console (dplewis) [#7114](https://github.com/parse-community/parse-server/pull/7114)\n- Added convenience method `Parse.Cloud.sendEmail(...)` to send email via email adapter in Cloud Code (dblythy) [#7089](https://github.com/parse-community/parse-server/pull/7089)\n- LiveQuery support for $and, $nor, $containedBy, $geoWithin, $geoIntersects queries (dplewis) [#7113](https://github.com/parse-community/parse-server/pull/7113)\n- Supporting patterns in LiveQuery server's config parameter `classNames` (Nes-si) [#7131](https://github.com/parse-community/parse-server/pull/7131)\n- Added `requireAnyUserRoles` and `requireAllUserRoles` for Parse Cloud validator (dblythy) [#7097](https://github.com/parse-community/parse-server/pull/7097)\n- Support Facebook Limited Login (miguel-s) [#7219](https://github.com/parse-community/parse-server/pull/7219)\n- Removed Stage name check on aggregate pipelines (BRETT71) [#7237](https://github.com/parse-community/parse-server/pull/7237)\n- Retry transactions on MongoDB when it fails due to transient error (Antonio Davi Macedo Coelho de Castro) [#7187](https://github.com/parse-community/parse-server/pull/7187)\n- Bump tests to use Mongo 4.4.4 (Antonio Davi Macedo Coelho de Castro) [#7184](https://github.com/parse-community/parse-server/pull/7184)\n- Added new account lockout policy option `accountLockout.unlockOnPasswordReset` to automatically unlock account on password reset (Manuel Trezza) [#7146](https://github.com/parse-community/parse-server/pull/7146)\n- Test Parse Server continuously against all recent MongoDB versions that have not reached their end-of-life support date, added MongoDB compatibility table to Parse Server docs (Manuel Trezza) [#7161](https://github.com/parse-community/parse-server/pull/7161)\n- Test Parse Server continuously against all recent Node.js versions that have not reached their end-of-life support date, added Node.js compatibility table to Parse Server docs (Manuel Trezza) [7161](https://github.com/parse-community/parse-server/pull/7177)\n- Throw error on invalid Cloud Function validation configuration (dblythy) [#7154](https://github.com/parse-community/parse-server/pull/7154)\n- Allow Cloud Validator `options` to be async (dblythy) [#7155](https://github.com/parse-community/parse-server/pull/7155)\n- Optimize queries on classes with pointer permissions (Pedro Diaz) [#7061](https://github.com/parse-community/parse-server/pull/7061)\n- Test Parse Server continuously against all relevant Postgres versions (minor versions), added Postgres compatibility table to Parse Server docs (Corey Baker) [#7176](https://github.com/parse-community/parse-server/pull/7176)\n- Randomize test suite (Diamond Lewis) [#7265](https://github.com/parse-community/parse-server/pull/7265)\n- LDAP: Properly unbind client on group search error (Diamond Lewis) [#7265](https://github.com/parse-community/parse-server/pull/7265)\n- Improve data consistency in Push and Job Status update (Diamond Lewis) [#7267](https://github.com/parse-community/parse-server/pull/7267)\n- Excluding keys that have trailing edges.node when performing GraphQL resolver (Chris Bland) [#7273](https://github.com/parse-community/parse-server/pull/7273)\n- Added centralized feature deprecation with standardized warning logs (Manuel Trezza) [#7303](https://github.com/parse-community/parse-server/pull/7303)\n- Use Node.js 15.13.0 in CI (Olle Jonsson) [#7312](https://github.com/parse-community/parse-server/pull/7312)\n- Fix file upload issue for S3 compatible storage (Linode, DigitalOcean) by avoiding empty tags property when creating a file (Ali Oguzhan Yildiz) [#7300](https://github.com/parse-community/parse-server/pull/7300)\n- Add building Docker image as CI check (Manuel Trezza) [#7332](https://github.com/parse-community/parse-server/pull/7332)\n- Add NPM package-lock version check to CI (Manuel Trezza) [#7333](https://github.com/parse-community/parse-server/pull/7333)\n- Fix incorrect LiveQuery events triggered for multiple subscriptions on the same class with different events [#7341](https://github.com/parse-community/parse-server/pull/7341)\n- Fix select and excludeKey queries to properly accept JSON string arrays. Also allow nested fields in exclude (Corey Baker) [#7242](https://github.com/parse-community/parse-server/pull/7242)\n- Fix LiveQuery server crash when using $all query operator on a missing object key (Jason Posthuma) [#7421](https://github.com/parse-community/parse-server/pull/7421)\n- Added runtime deprecation warnings (Manuel Trezza) [#7451](https://github.com/parse-community/parse-server/pull/7451)\n- Add ability to pass context of an object via a header, X-Parse-Cloud-Context, for Cloud Code triggers. The header addition allows client SDK's to add context without injecting _context in the body of JSON objects (Corey Baker) [#7437](https://github.com/parse-community/parse-server/pull/7437)\n- Add CI check to add changelog entry (Manuel Trezza) [#7512](https://github.com/parse-community/parse-server/pull/7512)\n- Refactor: uniform issue templates across repos (Manuel Trezza) [#7528](https://github.com/parse-community/parse-server/pull/7528)\n\n## 4.10.2\n[Full Changelog](https://github.com/parse-community/parse-server/compare/4.10.1...4.10.2)\n\n### Other Changes\n- Move graphql-tag from devDependencies to dependencies (Antonio Davi Macedo Coelho de Castro) [#7183](https://github.com/parse-community/parse-server/pull/7183)\n\n## 4.10.1\n[Full Changelog](https://github.com/parse-community/parse-server/compare/4.10.0...4.10.1)\n\n### Security Fixes\n- Updated to Parse JS SDK 3.3.0 and other security fixes (Manuel Trezza) [#7508](https://github.com/parse-community/parse-server/pull/7508)\n\n> \u26a0\ufe0f This includes a security fix of the Parse JS SDK where `logIn` will default to `POST` instead of `GET` method. This may require changes in your deployment before you upgrade to this release, see the Parse JS SDK 3.0.0 [release notes](https://github.com/parse-community/Parse-SDK-JS/releases/tag/3.0.0).\n\n## 4.10.0\n[Full Changelog](https://github.com/parse-community/parse-server/compare/4.5.2...4.10.0)\n\n*Versions >4.5.2 and <4.10.0 are skipped.*\n\n> \u26a0\ufe0f A security incident caused a number of incorrect version tags to be pushed to the Parse Server repository. These version tags linked to a personal fork of a contributor who had write access to the repository. The code to which these tags linked has not been reviewed or approved by Parse Platform. Even though no releases were published with these incorrect versions, it was possible to define a Parse Server dependency that pointed to these version tags, for example if you defined this dependency: \n> ```js\n> \"parse-server\": \"git@github.com:parse-community/parse-server.git#4.9.3\"\n> ```\n> \n> We have since deleted the incorrect version tags, but they may still show up if your personal fork on GitHub or locally. We do not know when these tags have been pushed to the Parse Server repository, but we first became aware of this issue on July 21, 2021. We are not aware of any malicious code or concerns related to privacy, security or legality (e.g. proprietary code). However, it has been reported that some functionality does not work as expected and the introduction of security vulnerabilities cannot be ruled out.\n>\n> You may be also affected if you used the Bitnami image for Parse Server. Bitnami picked up the incorrect version tag `4.9.3` and published a new Bitnami image for Parse Server. \n> \n>**If you are using any of the affected versions, we urgently recommend to upgrade to version `4.10.0`.**\n\n## 4.5.2\n[Full Changelog](https://github.com/parse-community/parse-server/compare/4.5.0...4.5.2)\n\n### Security Fixes\n- SECURITY FIX: Fixes incorrect session property `authProvider: password` of anonymous users. When signing up an anonymous user, the session field `createdWith` indicates incorrectly that the session has been created using username and password with `authProvider: password`, instead of an anonymous sign-up with `authProvider: anonymous`. This fixes the issue by setting the correct `authProvider: anonymous` for future sign-ups of anonymous users. This fix does not fix incorrect `authProvider: password` for existing sessions of anonymous users. Consider this if your app logic depends on the `authProvider` field. (Corey Baker) [GHSA-23r4-5mxp-c7g5](https://github.com/parse-community/parse-server/security/advisories/GHSA-23r4-5mxp-c7g5)\n\n## 4.5.1\n*This version was published by mistake and was deprecated.*\n\n## 4.5.0\n[Full Changelog](https://github.com/parse-community/parse-server/compare/4.4.0...4.5.0)\n### Breaking Changes\n- FIX: Consistent casing for afterLiveQueryEvent. The afterLiveQueryEvent was introduced in 4.4.0 with inconsistent casing for the event names, which was fixed in 4.5.0. [#7023](https://github.com/parse-community/parse-server/pull/7023). Thanks to [dblythy](https://github.com/dblythy).\n### Other Changes\n- FIX: Properly handle serverURL and publicServerUrl in Batch requests. [#7049](https://github.com/parse-community/parse-server/pull/7049). Thanks to [Zach Goldberg](https://github.com/ZachGoldberg).\n- IMPROVE: Prevent invalid column names (className and length). [#7053](https://github.com/parse-community/parse-server/pull/7053). Thanks to [Diamond Lewis](https://github.com/dplewis).\n- IMPROVE: GraphQL: Remove viewer from logout mutation. [#7029](https://github.com/parse-community/parse-server/pull/7029). Thanks to [Antoine Cormouls](https://github.com/Moumouls).\n- IMPROVE: GraphQL: Optimize on Relation. [#7044](https://github.com/parse-community/parse-server/pull/7044). Thanks to [Antoine Cormouls](https://github.com/Moumouls).\n- NEW: Include sessionToken in onLiveQueryEvent. [#7043](https://github.com/parse-community/parse-server/pull/7043). Thanks to [dblythy](https://github.com/dblythy).\n- FIX: Definitions for accountLockout and passwordPolicy. [#7040](https://github.com/parse-community/parse-server/pull/7040). Thanks to [dblythy](https://github.com/dblythy).\n- FIX: Fix typo in server definitions for emailVerifyTokenReuseIfValid. [#7037](https://github.com/parse-community/parse-server/pull/7037). Thanks to [dblythy](https://github.com/dblythy).\n- SECURITY FIX: LDAP auth stores password in plain text. See [GHSA-4w46-w44m-3jq3](https://github.com/parse-community/parse-server/security/advisories/GHSA-4w46-w44m-3jq3) for more details about the vulnerability and [da905a3](https://github.com/parse-community/parse-server/commit/da905a357d062ab4fea727a21eac231acc2ed92a) for the fix. Thanks to [Fabian Strachanski](https://github.com/fastrde).\n- NEW: Reuse tokens if they haven't expired. [#7017](https://github.com/parse-community/parse-server/pull/7017). Thanks to [dblythy](https://github.com/dblythy).\n- NEW: Add LDAPS-support to LDAP-Authcontroller. [#7014](https://github.com/parse-community/parse-server/pull/7014). Thanks to [Fabian Strachanski](https://github.com/fastrde).\n- FIX: (beforeSave/afterSave): Return value instead of Parse.Op for nested fields. [#7005](https://github.com/parse-community/parse-server/pull/7005). Thanks to [Diamond Lewis](https://github.com/dplewis).\n- FIX: (beforeSave): Skip Sanitizing Database results. [#7003](https://github.com/parse-community/parse-server/pull/7003). Thanks to [Diamond Lewis](https://github.com/dplewis).\n- FIX: Fix includeAll for querying a Pointer and Pointer array. [#7002](https://github.com/parse-community/parse-server/pull/7002). Thanks to [Corey Baker](https://github.com/cbaker6).\n- FIX: Add encryptionKey to src/options/index.js. [#6999](https://github.com/parse-community/parse-server/pull/6999). Thanks to [dblythy](https://github.com/dblythy).\n- IMPROVE: Update PostgresStorageAdapter.js. [#6989](https://github.com/parse-community/parse-server/pull/6989). Thanks to [Vitaly Tomilov](https://github.com/vitaly-t).\n\n## 4.4.0\n[Full Changelog](https://github.com/parse-community/parse-server/compare/4.3.0...4.4.0)\n- IMPROVE: Update PostgresStorageAdapter.js. [#6981](https://github.com/parse-community/parse-server/pull/6981). Thanks to [Vitaly Tomilov](https://github.com/vitaly-t)\n- NEW: skipWithMasterKey on Built-In Validator. [#6972](https://github.com/parse-community/parse-server/issues/6972). Thanks to [dblythy](https://github.com/dblythy).\n- NEW: Add fileKey rotation to GridFSBucketAdapter. [#6768](https://github.com/parse-community/parse-server/pull/6768). Thanks to [Corey Baker](https://github.com/cbaker6).\n- IMPROVE: Remove unused parameter in Cloud Function. [#6969](https://github.com/parse-community/parse-server/issues/6969). Thanks to [Diamond Lewis](https://github.com/dplewis).\n- IMPROVE: Validation Handler Update. [#6968](https://github.com/parse-community/parse-server/issues/6968). Thanks to [dblythy](https://github.com/dblythy).\n- FIX: (directAccess): Properly handle response status. [#6966](https://github.com/parse-community/parse-server/issues/6966). Thanks to [Diamond Lewis](https://github.com/dplewis).\n- FIX: Remove hostnameMaxLen for Mongo URL. [#6693](https://github.com/parse-community/parse-server/issues/6693). Thanks to [markhoward02](https://github.com/markhoward02).\n- IMPROVE: Show a message if cloud functions are duplicated. [#6963](https://github.com/parse-community/parse-server/issues/6963). Thanks to [dblythy](https://github.com/dblythy).\n- FIX: Pass request.query to afterFind. [#6960](https://github.com/parse-community/parse-server/issues/6960). Thanks to [dblythy](https://github.com/dblythy).\n- SECURITY FIX: Patch session vulnerability over Live Query. See [GHSA-2xm2-xj2q-qgpj](https://github.com/parse-community/parse-server/security/advisories/GHSA-2xm2-xj2q-qgpj) for more details about the vulnerability and [78b59fb](https://github.com/parse-community/parse-server/commit/78b59fb26b1c36e3cdbd42ba9fec025003267f58) for the fix. Thanks to [Antonio Davi Macedo Coelho de Castro](https://github.com/davimacedo).\n- IMPROVE: LiveQueryEvent Error Logging Improvements. [#6951](https://github.com/parse-community/parse-server/issues/6951). Thanks to [dblythy](https://github.com/dblythy).\n- IMPROVE: Include stack in Cloud Code. [#6958](https://github.com/parse-community/parse-server/issues/6958). Thanks to [dblythy](https://github.com/dblythy).\n- FIX: (jobs): Add Error Message to JobStatus Failure. [#6954](https://github.com/parse-community/parse-server/issues/6954). Thanks to [Diamond Lewis](https://github.com/dplewis).\n- NEW: Create Cloud function afterLiveQueryEvent. [#6859](https://github.com/parse-community/parse-server/issues/6859). Thanks to [dblythy](https://github.com/dblythy).\n- FIX: Update vkontakte API to the latest version. [#6944](https://github.com/parse-community/parse-server/issues/6944). Thanks to [Antonio Davi Macedo Coelho de Castro](https://github.com/davimacedo).\n- FIX: Use an empty object as default value of options for Google Sign in. [#6844](https://github.com/parse-community/parse-server/issues/6844). Thanks to [Kevin Kuang](https://github.com/kvnkuang).\n- FIX: Postgres: prepend className to unique indexes. [#6741](https://github.com/parse-community/parse-server/pull/6741). Thanks to [Corey Baker](https://github.com/cbaker6).\n- FIX: GraphQL: Transform input types also on user mutations. [#6934](https://github.com/parse-community/parse-server/pull/6934). Thanks to [Antoine Cormouls](https://github.com/Moumouls).\n- FIX: Set objectId into query for Email Validation. [#6930](https://github.com/parse-community/parse-server/pull/6930). Thanks to [Danaru](https://github.com/Danaru87).\n- FIX: GraphQL: Optimize queries, fixes some null returns (on object), fix stitched GraphQLUpload. [#6709](https://github.com/parse-community/parse-server/pull/6709). Thanks to [Antoine Cormouls](https://github.com/Moumouls).\n- FIX: Do not throw error if user provide a pointer like index onMongo. [#6923](https://github.com/parse-community/parse-server/pull/6923). Thanks to [Antoine Cormouls](https://github.com/Moumouls).\n- FIX: Hotfix instagram api. [#6922](https://github.com/parse-community/parse-server/issues/6922). Thanks to [Tim](https://github.com/timination).\n- FIX: (directAccess/cloud-code): Pass installationId with LogIn. [#6903](https://github.com/parse-community/parse-server/issues/6903). Thanks to [Diamond Lewis](https://github.com/dplewis).\n- FIX: Fix bcrypt binary incompatibility. [#6891](https://github.com/parse-community/parse-server/issues/6891). Thanks to [Manuel Trezza](https://github.com/mtrezza).\n- NEW: Keycloak auth adapter. [#6376](https://github.com/parse-community/parse-server/issues/6376). Thanks to [Rhuan](https://github.com/rhuanbarreto).\n- IMPROVE: Changed incorrect key name in apple auth adapter tests. [#6861](https://github.com/parse-community/parse-server/issues/6861). Thanks to [Manuel Trezza](https://github.com/mtrezza).\n- FIX: Fix mutating beforeSubscribe Query. [#6868](https://github.com/parse-community/parse-server/issues/6868). Thanks to [dblythy](https://github.com/dblythy).\n- FIX: Fix beforeLogin for users logging in with AuthData. [#6872](https://github.com/parse-community/parse-server/issues/6872). Thanks to [Kevin Kuang](https://github.com/kvnkuang).\n- FIX: Remove Facebook AccountKit auth. [#6870](https://github.com/parse-community/parse-server/issues/6870). Thanks to [Diamond Lewis](https://github.com/dplewis).\n- FIX: Updated TOKEN_ISSUER to 'accounts.google.com'. [#6836](https://github.com/parse-community/parse-server/issues/6836). Thanks to [Arjun Vedak](https://github.com/arjun3396).\n- IMPROVE: Optimized deletion of class field from schema by using an index if available to do an index scan instead of a collection scan. [#6815](https://github.com/parse-community/parse-server/issues/6815). Thanks to [Manuel Trezza](https://github.com/mtrezza).\n- IMPROVE: Enable MongoDB transaction test for MongoDB >= 4.0.4 [#6827](https://github.com/parse-community/parse-server/pull/6827). Thanks to [Manuel](https://github.com/mtrezza).\n\n## 4.3.0\n[Full Changelog](https://github.com/parse-community/parse-server/compare/4.2.0...4.3.0)\n- PERFORMANCE: Optimizing pointer CLP query decoration done by DatabaseController#addPointerPermissions [#6747](https://github.com/parse-community/parse-server/pull/6747). Thanks to [mess-lelouch](https://github.com/mess-lelouch).\n- SECURITY: Fix security breach on GraphQL viewer [78239ac](https://github.com/parse-community/parse-server/commit/78239ac9071167fdf243c55ae4bc9a2c0b0d89aa), [security advisory](https://github.com/parse-community/parse-server/security/advisories/GHSA-236h-rqv8-8q73). Thanks to [Antoine Cormouls](https://github.com/Moumouls).\n- FIX: Save context not present if direct access enabled [#6764](https://github.com/parse-community/parse-server/pull/6764). Thanks to [Omair Vaiyani](https://github.com/omairvaiyani).\n- NEW: Before Connect + Before Subscribe [#6793](https://github.com/parse-community/parse-server/pull/6793). Thanks to [dblythy](https://github.com/dblythy).\n- FIX: Add version to playground to fix CDN [#6804](https://github.com/parse-community/parse-server/pull/6804). Thanks to [Antoine Cormouls](https://github.com/Moumouls).\n- NEW (EXPERIMENTAL): Idempotency enforcement for client requests. This deduplicates requests where the client intends to send one request to Parse Server but due to network issues the server receives the request multiple times. **Caution, this is an experimental feature that may not be appropriate for production.** [#6748](https://github.com/parse-community/parse-server/issues/6748). Thanks to [Manuel Trezza](https://github.com/mtrezza).\n- FIX: Add production Google Auth Adapter instead of using the development url [#6734](https://github.com/parse-community/parse-server/pull/6734). Thanks to [SebC.](https://github.com/SebC99).\n- IMPROVE: Run Prettier JS Again Without requiring () on arrow functions [#6796](https://github.com/parse-community/parse-server/pull/6796). Thanks to [Diamond Lewis](https://github.com/dplewis).\n- IMPROVE: Run Prettier JS [#6795](https://github.com/parse-community/parse-server/pull/6795). Thanks to [Diamond Lewis](https://github.com/dplewis).\n- IMPROVE: Replace bcrypt with @node-rs/bcrypt [#6794](https://github.com/parse-community/parse-server/pull/6794). Thanks to [LongYinan](https://github.com/Brooooooklyn).\n- IMPROVE: Make clear description of anonymous user [#6655](https://github.com/parse-community/parse-server/pull/6655). Thanks to [Jerome De Leon](https://github.com/JeromeDeLeon).\n- IMPROVE: Simplify GraphQL merge system to avoid js ref bugs [#6791](https://github.com/parse-community/parse-server/pull/6791). Thanks to [Antoine Cormouls](https://github.com/Moumouls).\n- NEW: Pass context in beforeDelete, afterDelete, beforeFind and Parse.Cloud.run [#6666](https://github.com/parse-community/parse-server/pull/6666). Thanks to [yog27ray](https://github.com/yog27ray).\n- NEW: Allow passing custom gql schema function to ParseServer#start options [#6762](https://github.com/parse-community/parse-server/pull/6762). Thanks to [Luca](https://github.com/lucatk).\n- NEW: Allow custom cors origin header [#6772](https://github.com/parse-community/parse-server/pull/6772). Thanks to [Kevin Yao](https://github.com/kzmeyao).\n- FIX: Fix context for cascade-saving and saving existing object [#6735](https://github.com/parse-community/parse-server/pull/6735). Thanks to [Manuel](https://github.com/mtrezza).\n- NEW: Add file bucket encryption using fileKey [#6765](https://github.com/parse-community/parse-server/pull/6765). Thanks to [Corey Baker](https://github.com/cbaker6).\n- FIX: Removed gaze from dev dependencies and removed not working dev script [#6745](https://github.com/parse-community/parse-server/pull/6745). Thanks to [Vincent Semrau](https://github.com/vince1995).\n- IMPROVE: Upgrade graphql-tools to v6 [#6701](https://github.com/parse-community/parse-server/pull/6701). Thanks to [Yaacov Rydzinski](https://github.com/yaacovCR).\n- NEW: Support Metadata in GridFSAdapter [#6660](https://github.com/parse-community/parse-server/pull/6660). Thanks to [Diamond Lewis](https://github.com/dplewis).\n- NEW: Allow to unset file from graphql [#6651](https://github.com/parse-community/parse-server/pull/6651). Thanks to [Antoine Cormouls](https://github.com/Moumouls).\n- NEW: Handle shutdown for RedisCacheAdapter [#6658](https://github.com/parse-community/parse-server/pull/6658). Thanks to [promisenxu](https://github.com/promisenxu).\n- FIX: Fix explain on user class [#6650](https://github.com/parse-community/parse-server/pull/6650). Thanks to [Manuel](https://github.com/mtrezza).\n- FIX: Fix read preference for aggregate [#6585](https://github.com/parse-community/parse-server/pull/6585). Thanks to [Manuel](https://github.com/mtrezza).\n- NEW: Add context to Parse.Object.save [#6626](https://github.com/parse-community/parse-server/pull/6626). Thanks to [Manuel](https://github.com/mtrezza).\n- NEW: Adding ssl config params to Postgres URI [#6580](https://github.com/parse-community/parse-server/pull/6580). Thanks to [Corey Baker](https://github.com/cbaker6).\n- FIX: Travis postgres update: removing unnecessary start of mongo-runner [#6594](https://github.com/parse-community/parse-server/pull/6594). Thanks to [Corey Baker](https://github.com/cbaker6).\n- FIX: ObjectId size for Pointer in Postgres [#6619](https://github.com/parse-community/parse-server/pull/6619). Thanks to [Corey Baker](https://github.com/cbaker6).\n- IMPROVE: Improve a test case [#6629](https://github.com/parse-community/parse-server/pull/6629). Thanks to [Gordon Sun](https://github.com/sunshineo).\n- NEW: Allow to resolve automatically Parse Type fields from Custom Schema [#6562](https://github.com/parse-community/parse-server/pull/6562). Thanks to [Antoine Cormouls](https://github.com/Moumouls).\n- FIX: Remove wrong console log in test [#6627](https://github.com/parse-community/parse-server/pull/6627). Thanks to [Gordon Sun](https://github.com/sunshineo).\n- IMPROVE: Graphql tools v5 [#6611](https://github.com/parse-community/parse-server/pull/6611). Thanks to [Yaacov Rydzinski](https://github.com/yaacovCR).\n- FIX: Catch JSON.parse and return 403 properly [#6589](https://github.com/parse-community/parse-server/pull/6589). Thanks to [Gordon Sun](https://github.com/sunshineo).\n- PERFORMANCE: Allow covering relation queries with minimal index [#6581](https://github.com/parse-community/parse-server/pull/6581). Thanks to [Noah Silas](https://github.com/noahsilas).\n- FIX: Fix Postgres group aggregation [#6522](https://github.com/parse-community/parse-server/pull/6522). Thanks to [Siddharth Ramesh](https://github.com/srameshr).\n- NEW: Allow set user mapped from JWT directly on request [#6411](https://github.com/parse-community/parse-server/pull/6411). Thanks to [Gordon Sun](https://github.com/sunshineo).\n\n## 4.2.0\n[Full Changelog](https://github.com/parse-community/parse-server/compare/4.1.0...4.2.0)\n\n__BREAKING CHANGES:__\n- CHANGE: The Sign-In with Apple authentication adapter parameter `client_id` has been changed to `clientId`. If using the Apple authentication adapter, this change requires to update the Parse Server configuration accordingly. See [#6523](https://github.com/parse-community/parse-server/pull/6523) for details.\n___\n- UPGRADE: Parse JS SDK to 2.12.0 [#6548](https://github.com/parse-community/parse-server/pull/6548)\n- NEW: Support Group aggregation on multiple columns for Postgres [#6483](https://github.com/parse-community/parse-server/pull/6483). Thanks to [Siddharth Ramesh](https://github.com/srameshr).\n- FIX: Improve test reliability by instructing Travis to only install one version of Postgres [#6490](https://github.com/parse-community/parse-server/pull/6490). Thanks to\n[Corey Baker](https://github.com/cbaker6).\n- FIX: Unknown type bug on overloaded types [#6494](https://github.com/parse-community/parse-server/pull/6494). Thanks to [Antoine Cormouls](https://github.com/Moumouls).\n- FIX: Improve reliability of 'SignIn with AppleID' [#6416](https://github.com/parse-community/parse-server/pull/6416). Thanks to [Andy King](https://github.com/andrewking0207).\n- FIX: Improve Travis reliability by separating Postgres & Mongo scripts [#6505](https://github.com/parse-community/parse-server/pull/6505). Thanks to\n[Corey Baker](https://github.com/cbaker6).\n- NEW: Apple SignIn support for multiple IDs [#6523](https://github.com/parse-community/parse-server/pull/6523). Thanks to [UnderratedDev](https://github.com/UnderratedDev).\n- NEW: Add support for new Instagram API [#6398](https://github.com/parse-community/parse-server/pull/6398). Thanks to [Maravilho Singa](https://github.com/maravilhosinga).\n- FIX: Updating Postgres/Postgis Call and Postgis to 3.0 [#6528](https://github.com/parse-community/parse-server/pull/6528). Thanks to\n[Corey Baker](https://github.com/cbaker6).\n- FIX: enableExpressErrorHandler logic [#6423](https://github.com/parse-community/parse-server/pull/6423). Thanks to [Nikolay Andryukhin](https://github.com/hybeats).\n- FIX: Change Order Enum Strategy for GraphQL [#6515](https://github.com/parse-community/parse-server/pull/6515). Thanks to [Antoine Cormouls](https://github.com/Moumouls).\n- FIX: Switch ACL to Relay Global Id for GraphQL [#6495](https://github.com/parse-community/parse-server/pull/6495). Thanks to [Antoine Cormouls](https://github.com/Moumouls).\n- FIX: Handle keys for pointer fields properly for GraphQL [#6499](https://github.com/parse-community/parse-server/pull/6499). Thanks to [Antoine Cormouls](https://github.com/Moumouls).\n- FIX: GraphQL file mutation [#6507](https://github.com/parse-community/parse-server/pull/6507). Thanks to [Antoine Cormouls](https://github.com/Moumouls).\n- FIX: Aggregate geoNear with date query [#6540](https://github.com/parse-community/parse-server/pull/6540). Thanks to [Manuel](https://github.com/mtrezza).\n- NEW: Add file triggers and file meta data [#6344](https://github.com/parse-community/parse-server/pull/6344). Thanks to [stevestencil](https://github.com/stevestencil).\n- FIX: Improve local testing of postgres [#6531](https://github.com/parse-community/parse-server/pull/6531). Thanks to\n[Corey Baker](https://github.com/cbaker6).\n- NEW: Case insensitive username and email indexing and query planning for Postgres [#6506](https://github.com/parse-community/parse-server/issues/6441). Thanks to\n[Corey Baker](https://github.com/cbaker6).\n\n## 4.1.0\n[Full Changelog](https://github.com/parse-community/parse-server/compare/4.0.2...4.1.0)\n\n_SECURITY RELEASE_: see [advisory](https://github.com/parse-community/parse-server/security/advisories/GHSA-h4mf-75hf-67w4) for details\n- SECURITY FIX: Patch Regex vulnerabilities. See [3a3a5ee](https://github.com/parse-community/parse-server/commit/3a3a5eee5ffa48da1352423312cb767de14de269). Special thanks to [W0lfw00d](https://github.com/W0lfw00d) for identifying and [responsibly reporting](https://github.com/parse-community/parse-server/blob/master/SECURITY.md) the vulnerability. Thanks to [Antonio Davi Macedo Coelho de Castro](https://github.com/davimacedo) for the speedy fix.\n\n## 4.0.2\n[Full Changelog](https://github.com/parse-community/parse-server/compare/4.0.1...4.0.2)\n\n__BREAKING CHANGES:__\n1. Remove Support for Mongo 3.2 & 3.4. The new minimum supported version is Mongo 3.6.\n2. Change username and email validation to be case insensitive. This change should be transparent in most use cases. The validation behavior should now behave 'as expected'. See [#5634](https://github.com/parse-community/parse-server/pull/5634) for details.\n\n> __Special Note on Upgrading to Parse Server 4.0.0 and above__\n>\n> In addition to the breaking changes noted above, [#5634](https://github.com/parse-community/parse-server/pull/5634) introduces a two new case insensitive indexes on the `User` collection. Special care should be taken when upgrading to this version to ensure that:\n>\n> 1. The new indexes can be successfully created (see issue [#6465](https://github.com/parse-community/parse-server/issues/6465) for details on a potential issue for your installation).\n>\n> 2. Care is taken ensure that there is adequate compute capacity to create the index in the background while still servicing requests.\n\n- FIX: attempt to get travis to deploy to npmjs again. See [#6475](https://github.com/parse-community/parse-server/pull/6457). Thanks to [Arthur Cinader](https://github.com/acinader).\n\n## 4.0.1\n[Full Changelog](https://github.com/parse-community/parse-server/compare/4.0.0...4.0.1)\n- FIX: correct 'new' travis config to properly deploy.  See [#6452](https://github.com/parse-community/parse-server/pull/6452). Thanks to [Arthur Cinader](https://github.com/acinader).\n- FIX: Better message on not allowed to protect default fields. See [#6439](https://github.com/parse-community/parse-server/pull/6439).Thanks to [Old Grandpa](https://github.com/BufferUnderflower)\n\n## 4.0.0\n[Full Changelog](https://github.com/parse-community/parse-server/compare/3.10.0...4.0.0)\n\n> __Special Note on Upgrading to Parse Server 4.0.0 and above__\n>\n> In addition to the breaking changes noted below, [#5634](https://github.com/parse-community/parse-server/pull/5634) introduces a two new case insensitive indexes on the `User` collection. Special care should be taken when upgrading to this version to ensure that:\n>\n> 1. The new indexes can be successfully created (see issue [#6465](https://github.com/parse-community/parse-server/issues/6465) for details on a potential issue for your installation).\n>\n> 2. Care is taken ensure that there is adequate compute capacity to create the index in the background while still servicing requests.\n\n- NEW: add hint option to Parse.Query [#6322](https://github.com/parse-community/parse-server/pull/6322). Thanks to [Steve Stencil](https://github.com/stevestencil)\n- FIX: CLP objectId size validation fix [#6332](https://github.com/parse-community/parse-server/pull/6332). Thanks to [Old Grandpa](https://github.com/BufferUnderflower)\n- FIX: Add volumes to Docker command [#6356](https://github.com/parse-community/parse-server/pull/6356). Thanks to [Kasra Bigdeli](https://github.com/githubsaturn)\n- NEW: GraphQL 3rd Party LoginWith Support [#6371](https://github.com/parse-community/parse-server/pull/6371). Thanks to [Antoine Cormouls](https://github.com/Moumouls)\n- FIX: GraphQL Geo Queries [#6363](https://github.com/parse-community/parse-server/pull/6363). Thanks to [Antoine Cormouls](https://github.com/Moumouls)\n- NEW: GraphQL Nested File Upload [#6372](https://github.com/parse-community/parse-server/pull/6372). Thanks to [Antoine Cormouls](https://github.com/Moumouls)\n- NEW: Granular CLP pointer permissions [#6352](https://github.com/parse-community/parse-server/pull/6352). Thanks to [Old Grandpa](https://github.com/BufferUnderflower)\n- FIX: Add missing colon for customPages [#6393](https://github.com/parse-community/parse-server/pull/6393). Thanks to [Jerome De Leon](https://github.com/JeromeDeLeon)\n- NEW: `afterLogin` cloud code hook [#6387](https://github.com/parse-community/parse-server/pull/6387). Thanks to [David Corona](https://github.com/davesters)\n- FIX: __BREAKING CHANGE__ Prevent new usernames or emails that clash with existing users' email or username if it only differs by case.  For example, don't allow a new user with the name 'Jane' if we already have a user 'jane'. [#5634](https://github.com/parse-community/parse-server/pull/5634). Thanks to [Arthur Cinader](https://github.com/acinader)\n- FIX: Support Travis CI V2. [#6414](https://github.com/parse-community/parse-server/pull/6414). Thanks to [Diamond Lewis](https://github.com/dplewis)\n- FIX: Prevent crashing on websocket error. [#6418](https://github.com/parse-community/parse-server/pull/6418). Thanks to [Diamond Lewis](https://github.com/dplewis)\n- NEW: Allow protectedFields for Authenticated users and Public. [$6415](https://github.com/parse-community/parse-server/pull/6415). Thanks to [Old Grandpa](https://github.com/BufferUnderflower)\n- FIX: Correct bug in determining GraphQL pointer errors when mutating. [#6413](https://github.com/parse-community/parse-server/pull/6431). Thanks to [Antoine Cormouls](https://github.com/Moumouls)\n- NEW: Allow true GraphQL Schema Customization. [#6360](https://github.com/parse-community/parse-server/pull/6360). Thanks to [Antoine Cormouls](https://github.com/Moumouls)\n- __BREAKING CHANGE__: Remove Support for Mongo version < 3.6 [#6445](https://github.com/parse-community/parse-server/pull/6445). Thanks to [Arthur Cinader](https://github.com/acinader)\n\n## 3.10.0\n[Full Changelog](https://github.com/parse-community/parse-server/compare/3.9.0...3.10.0)\n- FIX: correct and cover ordering queries in GraphQL [#6316](https://github.com/parse-community/parse-server/pull/6316).  Thanks to [Antonio Davi Macedo Coelho de Castro](https://github.com/davimacedo)\n- NEW: GraphQL support for reset password email [#6301](https://github.com/parse-community/parse-server/pull/6301). Thanks to [Antoine Cormouls](https://github.com/Moumouls)\n- FIX: Add default limit to GraphQL fetch [#6304](https://github.com/parse-community/parse-server/pull/6304). Thanks to [Antoine Cormouls](https://github.com/Moumouls)\n- DOCS: use bash syntax highlighting [#6302](https://github.com/parse-community/parse-server/pull/6302). Thanks to [Jerome De Leon](https://github.com/JeromeDeLeon)\n- NEW: Add max log file option [#6296](https://github.com/parse-community/parse-server/pull/6296). Thanks to [Diamond Lewis](https://github.com/dplewis)\n- NEW: support user supplied objectId [#6101](https://github.com/parse-community/parse-server/pull/6101). Thanks to [Ruhan](https://github.com/rhuanbarretos)\n- FIX: Add missing encodeURIComponent on username [#6278](https://github.com/parse-community/parse-server/pull/6278). Thanks to [Christopher Brookes](https://github.com/Klaitos)\n- NEW: update  PostgresStorageAdapter.js to use async/await [#6275](https://github.com/parse-community/parse-server/pull/6275). Thanks to [Vitaly Tomilov](https://github.com/vitaly-t)\n- NEW: Support required fields on output type for GraphQL [#6279](https://github.com/parse-community/parse-server/pull/6279). Thanks to [Antoine Cormouls](https://github.com/Moumouls)\n- NEW: Support required fields for GraphQL [#6271](https://github.com/parse-community/parse-server/pull/6279). Thanks to [Antoine Cormouls](https://github.com/Moumouls)\n- CHANGE: use mongodb 3.3.5 [#6263](https://github.com/parse-community/parse-server/pull/6263). Thanks to [Diamond Lewis](https://github.com/dplewis)\n- NEW: GraphQL: DX Relational Where Query [#6255](https://github.com/parse-community/parse-server/pull/6255). Thanks to [Antoine Cormouls](https://github.com/Moumouls)\n- CHANGE: test against Postgres 11 [#6260](https://github.com/parse-community/parse-server/pull/6260). Thanks to [Diamond Lewis](https://github.com/dplewis)\n- CHANGE: test against Postgres 11 [#6260](https://github.com/parse-community/parse-server/pull/6260). Thanks to [Diamond Lewis](https://github.com/dplewis)\n- NEW: GraphQL alias for mutations in classConfigs [#6258](https://github.com/parse-community/parse-server/pull/6258). Thanks to [Old Grandpa](https://github.com/BufferUnderflower)\n- NEW: GraphQL classConfig query alias [#6257](https://github.com/parse-community/parse-server/pull/6257). Thanks to [Old Grandpa](https://github.com/BufferUnderflower)\n- NEW: Allow validateFilename to return a string or Parse Error [#6246](https://github.com/parse-community/parse-server/pull/6246). Thanks to [Mike Patnode](https://github.com/mpatnode)\n- NEW: Relay Spec [#6089](https://github.com/parse-community/parse-server/pull/6089). Thanks to [Antonio Davi Macedo Coelho de Castro](https://github.com/davimacedo)\n- CHANGE: Set default ACL for GraphQL [#6249](https://github.com/parse-community/parse-server/pull/6249). Thanks to [Antoine Cormouls](https://github.com/Moumouls)\n- NEW: LDAP auth Adapter [#6226](https://github.com/parse-community/parse-server/pull/6226). Thanks to [Julian Dax](https://github.com/brodo)\n- FIX: improve beforeFind to include Query info [#6237](https://github.com/parse-community/parse-server/pull/6237). Thanks to [Diamond Lewis](https://github.com/dplewis)\n- FIX: improve websocket error handling [#6230](https://github.com/parse-community/parse-server/pull/6230). Thanks to [Diamond Lewis](https://github.com/dplewis)\n- NEW: addition of an afterLogout trigger [#6217](https://github.com/parse-community/parse-server/pull/6217). Thanks to [Diamond Lewis](https://github.com/dplewis)\n- FIX: Initialize default logger [#6186](https://github.com/parse-community/parse-server/pull/6186). Thanks to [Diamond Lewis](https://github.com/dplewis)\n- NEW: Add funding link [#6192](https://github.com/parse-community/parse-server/pull/6192 ). Thanks to [Tom Fox](https://github.com/TomWFox)\n- FIX: installationId on LiveQuery connect [#6180](https://github.com/parse-community/parse-server/pull/6180). Thanks to [Diamond Lewis](https://github.com/dplewis)\n- NEW: Add exposing port in docker container [#6165](https://github.com/parse-community/parse-server/pull/6165). Thanks to [Priyash Patil](https://github.com/priyashpatil)\n- NEW: Support Google Play Games Service [#6147](https://github.com/parse-community/parse-server/pull/6147). Thanks to [Diamond Lewis](https://github.com/dplewis)\n- DOC: Throw error when setting authData to null [#6154](https://github.com/parse-community/parse-server/pull/6154). Thanks to [Manuel](https://github.com/mtrezza)\n- CHANGE: Move filename validation out of the Router and into the FilesAdaptor [#6157](https://github.com/parse-community/parse-server/pull/6157). Thanks to [Mike Patnode](https://github.com/mpatnode)\n- NEW: Added warning for special URL sensitive characters for appId [#6159](https://github.com/parse-community/parse-server/pull/6159). Thanks to [Saimoom Safayet Akash](https://github.com/saimoomsafayet)\n- NEW: Support Apple Game Center Auth [#6143](https://github.com/parse-community/parse-server/pull/6143). Thanks to [Diamond Lewis](https://github.com/dplewis)\n- CHANGE: test with Node 12 [#6133](https://github.com/parse-community/parse-server/pull/6133). Thanks to [Arthur Cinader](https://github.com/acinader)\n- FIX: prevent after find from firing when saving objects [#6127](https://github.com/parse-community/parse-server/pull/6127). Thanks to [Diamond Lewis](https://github.com/dplewis)\n- FIX: GraphQL Mutations not returning updated information [6130](https://github.com/parse-community/parse-server/pull/6130). Thanks to [Omair Vaiyani](https://github.com/omairvaiyani)\n- CHANGE: Cleanup Schema cache per request [#6216](https://github.com/parse-community/parse-server/pull/6216). Thanks to [Diamond Lewis](https://github.com/dplewis)\n- DOC: Improve installation instructions [#6120](https://github.com/parse-community/parse-server/pull/6120). Thanks to [Andres Galante](https://github.com/andresgalante)\n- DOC: add code formatting to contributing guidelines [#6119](https://github.com/parse-community/parse-server/pull/6119). Thanks to [Andres Galante](https://github.com/andresgalante)\n- NEW: Add GraphQL ACL Type + Input [#5957](https://github.com/parse-community/parse-server/pull/5957). Thanks to [Antoine Cormouls](https://github.com/Moumouls)\n- CHANGE: replace public key [#6099](https://github.com/parse-community/parse-server/pull/6099). Thanks to [Arthur Cinader](https://github.com/acinader)\n- NEW: Support microsoft authentication in GraphQL [#6051](https://github.com/parse-community/parse-server/pull/6051). Thanks to [Alann Maulana](https://github.com/alann-maulana)\n- NEW: Install parse-server 3.9.0 instead of 2.2 [#6069](https://github.com/parse-community/parse-server/pull/6069). Thanks to [Julian Dax](https://github.com/brodo)\n- NEW: Use #!/bin/bash instead of #!/bin/sh [#6062](https://github.com/parse-community/parse-server/pull/6062). Thanks to [Julian Dax](https://github.com/brodo)\n- DOC: Update GraphQL readme section [#6030](https://github.com/parse-community/parse-server/pull/6030). Thanks to [Antonio Davi Macedo Coelho de Castro](https://github.com/davimacedo)\n\n## 3.9.0\n[Full Changelog](https://github.com/parse-community/parse-server/compare/3.8.0...3.9.0)\n- NEW: Add allowHeaders to Options [#6044](https://github.com/parse-community/parse-server/pull/6044). Thanks to [Omair Vaiyani](https://github.com/omairvaiyani)\n- CHANGE: Introduce ReadOptionsInput to GraphQL API [#6030](https://github.com/parse-community/parse-server/pull/6030). Thanks to [Antonio Davi Macedo Coelho de Castro](https://github.com/davimacedo)\n- NEW: Stream video with GridFSBucketAdapter (implements byte-range requests) [#6028](https://github.com/parse-community/parse-server/pull/6028). Thanks to [Diamond Lewis](https://github.com/dplewis)\n- FIX: Aggregate not matching null values [#6043](https://github.com/parse-community/parse-server/pull/6043). Thanks to [Antonio Davi Macedo Coelho de Castro](https://github.com/davimacedo)\n- CHANGE: Improve callCloudCode mutation to receive a CloudCodeFunction enum instead of a String in the GraphQL API [#6029](https://github.com/parse-community/parse-server/pull/6029). Thanks to [Antonio Davi Macedo Coelho de Castro](https://github.com/davimacedo)\n- TEST: Add more tests to transactions [#6022](https://github.com/parse-community/parse-server/pull/6022). Thanks to [Antonio Davi Macedo Coelho de Castro](https://github.com/davimacedo)\n- CHANGE: Pointer constraint input type as ID in the GraphQL API [#6020](https://github.com/parse-community/parse-server/pull/6020). Thanks to [Douglas Muraoka](https://github.com/douglasmuraoka)\n- CHANGE: Remove underline from operators of the GraphQL API [#6024](https://github.com/parse-community/parse-server/pull/6024). Thanks to [Antonio Davi Macedo Coelho de Castro](https://github.com/davimacedo)\n- FIX: Make method async as expected in usage [#6025](https://github.com/parse-community/parse-server/pull/6025). Thanks to [Omair Vaiyani](https://github.com/omairvaiyani)\n- DOC: Added breaking change note to 3.8 release [#6023](https://github.com/parse-community/parse-server/pull/6023). Thanks to [Manuel](https://github.com/mtrezza)\n- NEW: Added support for line auth [#6007](https://github.com/parse-community/parse-server/pull/6007). Thanks to [Saimoom Safayet Akash](https://github.com/saimoomsafayet)\n- FIX: Fix aggregate group id [#5994](https://github.com/parse-community/parse-server/pull/5994). Thanks to [Antonio Davi Macedo Coelho de Castro](https://github.com/davimacedo)\n- CHANGE: Schema operations instead of generic operations in the GraphQL API [#5993](https://github.com/parse-community/parse-server/pull/5993). Thanks to [Antonio Davi Macedo Coelho de Castro](https://github.com/davimacedo)\n- DOC: Fix changelog formatting[#6009](https://github.com/parse-community/parse-server/pull/6009). Thanks to [Tom Fox](https://github.com/TomWFox)\n- CHANGE: Rename objectId to id in the GraphQL API [#5985](https://github.com/parse-community/parse-server/pull/5985). Thanks to [Douglas Muraoka](https://github.com/douglasmuraoka)\n- FIX: Fix beforeLogin trigger when user has a file [#6001](https://github.com/parse-community/parse-server/pull/6001). Thanks to [Antonio Davi Macedo Coelho de Castro](https://github.com/davimacedo)\n- DOC: Update GraphQL Docs with the latest changes [#5980](https://github.com/parse-community/parse-server/pull/5980). Thanks to [Antonio Davi Macedo Coelho de Castro](https://github.com/davimacedo)\n\n## 3.8.0\n[Full Changelog](https://github.com/parse-community/parse-server/compare/3.7.2...3.8.0)\n- NEW:  Protected fields pointer-permissions support [#5951](https://github.com/parse-community/parse-server/pull/5951).  Thanks to [Dobbias Nan](https://github.com/Dobbias)\n- NEW: GraphQL DX: Relation/Pointer [#5946](https://github.com/parse-community/parse-server/pull/5946).  Thanks to [Antoine Cormouls](https://github.com/Moumouls)\n- NEW: Master Key Only Config Properties [#5953](https://github.com/parse-community/parse-server/pull/5954). Thanks to [Manuel](https://github.com/mtrezza)\n- FIX: Better validation when creating a Relation fields [#5922](https://github.com/parse-community/parse-server/pull/5922).  Thanks to [Lucas Alencar](https://github.com/alencarlucas)\n- NEW: enable GraphQL file upload [#5944](https://github.com/parse-community/parse-server/pull/5944). Thanks to [Antonio Davi Macedo Coelho de Castro](https://github.com/davimacedo)\n- NEW: Handle shutdown on grid adapters  [#5943](https://github.com/parse-community/parse-server/pull/5943).  Thanks to [Antonio Davi Macedo Coelho de Castro](https://github.com/davimacedo)\n- NEW: Fix GraphQL max upload size [#5940](https://github.com/parse-community/parse-server/pull/5940). Thanks to [Antonio Davi Macedo Coelho de Castro](https://github.com/davimacedo)\n- FIX: Remove Buffer() deprecation notice [#5942](https://github.com/parse-community/parse-server/pull/5942).  Thanks to [Antonio Davi Macedo Coelho de Castro](https://github.com/davimacedo)\n- FIX: Remove MongoDB unified topology deprecation notice from the grid adapter [#5941](https://github.com/parse-community/parse-server/pull/5941).  Thanks to [Antonio Davi Macedo Coelho de Castro](https://github.com/davimacedo)\n- NEW: add callback for serverCloseComplete [#5937](https://github.com/parse-community/parse-server/pull/5937). Thanks to [Diamond Lewis](https://github.com/dplewis)\n- DOCS: Add Cloud Code guide to README [#5936](https://github.com/parse-community/parse-server/pull/5936).  Thanks to [Diamond Lewis](https://github.com/dplewis)\n- NEW: Remove nested operations from GraphQL API [#5931](https://github.com/parse-community/parse-server/pull/5931).  Thanks to [Antonio Davi Macedo Coelho de Castro](https://github.com/davimacedo)\n- NEW: Improve Live Query Monitoring [#5927](https://github.com/parse-community/parse-server/pull/5927).  Thanks to [Diamond Lewis](https://github.com/dplewis)\n- FIX: GraphQL: Fix undefined Array [#5296](https://github.com/parse-community/parse-server/pull/5926). Thanks to [Antoine Cormouls](https://github.com/Moumouls)\n- NEW: Added array support for pointer-permissions [#5921](https://github.com/parse-community/parse-server/pull/5921).  Thanks to [Dobbias Nan](https://github.com/Dobbias)\n- GraphQL: Renaming Types/Inputs [#5921](https://github.com/parse-community/parse-server/pull/5921). Thanks to [Antoine Cormouls](https://github.com/Moumouls)\n- FIX: Lint no-prototype-builtins [#5920](https://github.com/parse-community/parse-server/pull/5920). Thanks to [Diamond Lewis](https://github.com/dplewis)\n- GraphQL: Inline Fragment on Array Fields [#5908](https://github.com/parse-community/parse-server/pull/5908). Thanks to [Antoine Cormouls](https://github.com/Moumouls)\n- DOCS: Add instructions to launch a compatible Docker Postgres [](). Thanks to [Antoine Cormouls](https://github.com/Moumouls)\n- Fix: Undefined dot notation in matchKeyInQuery [#5917](https://github.com/parse-community/parse-server/pull/5917). Thanks to [Diamond Lewis](https://github.com/dplewis)\n- Fix: Logger print JSON and Numbers [#5916](https://github.com/parse-community/parse-server/pull/5916). Thanks to [Diamond Lewis](https://github.com/dplewis)\n- GraphQL: Return specific Type on specific Mutation [#5893](https://github.com/parse-community/parse-server/pull/5893). Thanks to [Antoine Cormouls](https://github.com/Moumouls)\n- FIX: Apple sign-in authAdapter [#5891](https://github.com/parse-community/parse-server/pull/5891). Thanks to [SebC](https://github.com/SebC99).\n- DOCS: Add GraphQL beta notice [#5886](https://github.com/parse-community/parse-server/pull/5886). Thanks to [Antonio Davi Macedo Coelho de Castro](https://github.com/davimacedo)\n- GraphQL: Remove \"password\" output field from _User class [#5889](https://github.com/parse-community/parse-server/pull/5889). Thanks to [Douglas Muraoka](https://github.com/douglasmuraoka)\n- GraphQL: Object constraints [#5715](https://github.com/parse-community/parse-server/pull/5715). Thanks to [Douglas Muraoka](https://github.com/douglasmuraoka)\n- DOCS: README top section overhaul + add sponsors [#5876](https://github.com/parse-community/parse-server/pull/5876). Thanks to [Tom Fox](https://github.com/TomWFox)\n- FIX: Return a Promise from classUpdate method [#5877](https://github.com/parse-community/parse-server/pull/5877). Thanks to [Lucas Alencar](https://github.com/alencarlucas)\n- FIX: Use UTC Month in aggregate tests [#5879](https://github.com/parse-community/parse-server/pull/5879). Thanks to [Antonio Davi Macedo Coelho de Castro](https://github.com/davimacedo)\n- FIX: Transaction was aborting before all promises have either resolved or rejected [#5878](https://github.com/parse-community/parse-server/pull/5878). Thanks to [Antonio Davi Macedo Coelho de Castro](https://github.com/davimacedo)\n- NEW: Use transactions for batch operation [#5849](https://github.com/parse-community/parse-server/pull/5849). Thanks to [Antonio Davi Macedo Coelho de Castro](https://github.com/davimacedo)\n\n### Breaking Changes\n- If you are running Parse Server on top of a MongoDB deployment which does not fit the [Retryable Writes Requirements](https://docs.mongodb.com/manual/core/retryable-writes/#prerequisites), you will have to add `retryWrites=false` to your connection string in order to upgrade to Parse Server 3.8.\n\n## 3.7.2\n[Full Changelog](https://github.com/parse-community/parse-server/compare/3.7.1...3.7.2)\n\n- FIX: Live Query was failing on release 3.7.1\n\n## 3.7.1\n[Full Changelog](https://github.com/parse-community/parse-server/compare/3.7.0...3.7.1)\n\n- FIX: Missing APN module\n- FIX: Set falsy values as default to schema fields [#5868](https://github.com/parse-community/parse-server/pull/5868), thanks to [Lucas Alencar](https://github.com/alencarlucas)\n- NEW: Implement WebSocketServer Adapter [#5866](https://github.com/parse-community/parse-server/pull/5866), thanks to [Diamond Lewis](https://github.com/dplewis)\n\n## 3.7.0\n[Full Changelog](https://github.com/parse-community/parse-server/compare/3.6.0...3.7.0)\n\n- FIX: Prevent linkWith sessionToken from generating new session [#5801](https://github.com/parse-community/parse-server/pull/5801), thanks to [Diamond Lewis](https://github.com/dplewis)\n- GraphQL: Improve session token error messages [#5753](https://github.com/parse-community/parse-server/pull/5753), thanks to [Douglas Muraoka](https://github.com/douglasmuraoka)\n- NEW: GraphQL { functions { call } } generic mutation [#5818](https://github.com/parse-community/parse-server/pull/5818), thanks to [Antonio Davi Macedo Coelho de Castro](https://github.com/davimacedo)\n- NEW: GraphQL Custom Schema [#5821](https://github.com/parse-community/parse-server/pull/5821), thanks to [Antonio Davi Macedo Coelho de Castro](https://github.com/davimacedo)\n- NEW: GraphQL custom schema on CLI [#5828](https://github.com/parse-community/parse-server/pull/5828), thanks to [Antonio Davi Macedo Coelho de Castro](https://github.com/davimacedo)\n- NEW: GraphQL @mock directive [#5836](https://github.com/parse-community/parse-server/pull/5836), thanks to [Antonio Davi Macedo Coelho de Castro](https://github.com/davimacedo)\n- FIX: GraphQL _or operator not working [#5840](https://github.com/parse-community/parse-server/pull/5840), thanks to [Antonio Davi Macedo Coelho de Castro](https://github.com/davimacedo)\n- NEW: Add \"count\" to CLP initial value [#5841](https://github.com/parse-community/parse-server/pull/5841), thanks to [Douglas Muraoka](https://github.com/douglasmuraoka)\n- NEW: Add ability to alter the response from the after save trigger [#5814](https://github.com/parse-community/parse-server/pull/5814), thanks to [BrunoMaurice](https://github.com/brunoMaurice)\n- FIX: Cache apple public key for the case it fails to fetch again [#5848](https://github.com/parse-community/parse-server/pull/5848), thanks to [Antonio Davi Macedo Coelho de Castro](https://github.com/davimacedo)\n- NEW: GraphQL Configuration Options [#5782](https://github.com/parse-community/parse-server/pull/5782), thanks to [Omair Vaiyani](https://github.com/omairvaiyani)\n- NEW: Required fields and default values [#5835](https://github.com/parse-community/parse-server/pull/5835), thanks to [Antonio Davi Macedo Coelho de Castro](https://github.com/davimacedo)\n- FIX: Postgres safely escape strings in nested objects [#5855](https://github.com/parse-community/parse-server/pull/5855), thanks to [Diamond Lewis](https://github.com/dplewis)\n- NEW: Support PhantAuth authentication [#5850](https://github.com/parse-community/parse-server/pull/5850), thanks to [Ivan SZKIBA](https://github.com/szkiba)\n- FIX: Remove uws package [#5860](https://github.com/parse-community/parse-server/pull/5860), thanks to [Zeal Murapa](https://github.com/GoGross)\n\n## 3.6.0\n[Full Changelog](https://github.com/parse-community/parse-server/compare/3.5.0...3.6.0)\n\n- SECURITY FIX: Address [Security Advisory](https://github.com/parse-community/parse-server/security/advisories/GHSA-8w3j-g983-8jh5) of a potential [Enumeration Attack](https://www.owasp.org/index.php/Testing_for_User_Enumeration_and_Guessable_User_Account_(OWASP-AT-002)#Description_of_the_Issue) [73b0f9a](https://github.com/parse-community/parse-server/commit/73b0f9a339b81f5d757725dc557955a7b670a3ec), big thanks to [Fabian Strachanski](https://github.com/fastrde) for identifying the problem, creating a fix and following the [vulnerability disclosure guidelines](https://github.com/parse-community/parse-server/blob/master/SECURITY.md#parse-community-vulnerability-disclosure-program)\n- NEW: Added rest option: excludeKeys [#5737](https://github.com/parse-community/parse-server/pull/5737), thanks to [Raschid J.F. Rafeally](https://github.com/RaschidJFR)\n- FIX: LiveQuery create event with fields [#5790](https://github.com/parse-community/parse-server/pull/5790), thanks to [Diamond Lewis](https://github.com/dplewis)\n- FIX: Generate sessionToken with linkWith [#5799](https://github.com/parse-community/parse-server/pull/5799), thanks to [Diamond Lewis](https://github.com/dplewis)\n\n## 3.5.0\n[Full Changelog](https://github.com/parse-community/parse-server/compare/3.4.4...3.5.0)\n\n- NEW: GraphQL Support [#5674](https://github.com/parse-community/parse-server/pull/5674), thanks to [Antonio Davi Macedo Coelho de Castro](https://github.com/davimacedo)\n\n[GraphQL Guide](https://github.com/parse-community/parse-server#graphql)\n\n- NEW: Sign in with Apple [#5694](https://github.com/parse-community/parse-server/pull/5694), thanks to [Diamond Lewis](https://github.com/dplewis)\n- NEW: AppSecret to Facebook Auth [#5695](https://github.com/parse-community/parse-server/pull/5695), thanks to [Diamond Lewis](https://github.com/dplewis)\n- NEW: Postgres: Regex support foreign characters [#5598](https://github.com/parse-community/parse-server/pull/5598), thanks to [Jeff Gu Kang](https://github.com/JeffGuKang)\n- FIX: Winston Logger string interpolation [#5729](https://github.com/parse-community/parse-server/pull/5729), thanks to [Diamond Lewis](https://github.com/dplewis)\n\n## 3.4.4\n[Full Changelog](https://github.com/parse-community/parse-server/compare/3.4.3...3.4.4)\n\nFix: Commit changes\n\n## 3.4.3\n[Full Changelog](https://github.com/parse-community/parse-server/compare/3.4.2...3.4.3)\n\nFix: Use changes in master to travis configuration to enable pushing to npm and gh_pages.  See diff for details.\n\n## 3.4.2\n[Full Changelog](https://github.com/parse-community/parse-server/compare/3.4.1...3.4.2)\n\nFix: In my haste to get a [Security Fix](https://github.com/parse-community/parse-server/security/advisories/GHSA-2479-qvv7-47qq) out, I added [8709daf](https://github.com/parse-community/parse-server/commit/8709daf698ea69b59268cb66f0f7cee75b52daa5) to master instead of to 3.4.1.  This commit fixes that.  [Arthur Cinader](https://github.com/acinader)\n\n## 3.4.1\n[Full Changelog](https://github.com/parse-community/parse-server/compare/3.4.0...3.4.1)\n\nSecurity Fix: see Advisory: [GHSA-2479-qvv7-47q](https://github.com/parse-community/parse-server/security/advisories/GHSA-2479-qvv7-47qq) for details [8709daf](https://github.com/parse-community/parse-server/commit/8709daf698ea69b59268cb66f0f7cee75b52daa5). Big thanks to: [Benjamin Simonsson](https://github.com/BenniPlejd) for identifying the issue and promptly bringing it to the Parse Community's attention and also big thanks to the indefatigable [Diamond Lewis](https://github.com/dplewis) for crafting a failing test and then a solution within an hour of the report.\n\n## 3.4.0\n[Full Changelog](https://github.com/parse-community/parse-server/compare/3.3.0...3.4.0)\n- NEW: Aggregate supports group by date fields [#5538](https://github.com/parse-community/parse-server/pull/5538) thanks to [Antonio Davi Macedo Coelho de Castro](https://github.com/davimacedo)\n- NEW: API for Read Preferences [#3963](https://github.com/parse-community/parse-server/pull/3963) thanks to [Antonio Davi Macedo Coelho de Castro](https://github.com/davimacedo)\n- NEW: Add Redis options for LiveQuery [#5584](https://github.com/parse-community/parse-server/pull/5584) thanks to [Diamond Lewis](https://github.com/dplewis)\n- NEW: Add Direct Access option for Server Config [#5550](https://github.com/parse-community/parse-server/pull/5550) thanks to [Diamond Lewis](https://github.com/dplewis)\n- FIX: updating mixed array in Postgres [#5552](https://github.com/parse-community/parse-server/pull/5552) thanks to [Diamond Lewis](https://github.com/dplewis)\n- FIX: notEqualTo GeoPoint Query in Postgres [#5549](https://github.com/parse-community/parse-server/pull/5549), thanks to [Diamond Lewis](https://github.com/dplewis)\n- FIX: put the timestamp back in logs that was lost after Winston upgrade [#5571](https://github.com/parse-community/parse-server/pull/5571), thanks to [Steven Rowe](https://github.com/mrowe009) and [Arthur Cinader](https://github.com/acinader)\n- FIX: Validates permission before calling beforeSave [#5546](https://github.com/parse-community/parse-server/pull/5546), thanks to [Antonio Davi Macedo Coelho de Castro](https://github.com/davimacedo)\n- FIX: Remove userSensitiveFields default value. [#5588](https://github.com/parse-community/parse-server/pull/5588), thanks to [William George](https://github.com/awgeorge)\n- FIX: Decode Date JSON value in LiveQuery. [#5540](https://github.com/parse-community/parse-server/pull/5540), thanks to [ananfang](https://github.com/ananfang)\n\n\n## 3.3.0\n[Full Changelog](https://github.com/parse-community/parse-server/compare/3.2.3...3.3.0)\n- NEW: beforeLogin trigger with support for auth providers ([#5445](https://github.com/parse-community/parse-server/pull/5445)), thanks to [Omair Vaiyani](https://github.com/omairvaiyani)\n- NEW: RFC 7662 compliant OAuth2 auth adapter ([#4910](https://github.com/parse-community/parse-server/pull/4910)), thanks to [M\u00fcller Zsolt](https://github.com/zsmuller)\n- FIX: cannot change password when maxPasswordHistory is 1 ([#5191](https://github.com/parse-community/parse-server/pull/5191)), thanks to [Tulsi Sapkota](https://github.com/Tolsee)\n- FIX (Postgres): count being very slow on large Parse Classes' collections ([#5330](https://github.com/parse-community/parse-server/pull/5330)), thanks to [CoderickLamar](https://github.com/CoderickLamar)\n- FIX: using per-key basis queue ([#5420](https://github.com/parse-community/parse-server/pull/5420)), thanks to [Georges Jamous](https://github.com/georgesjamous)\n- FIX: issue on count with Geo constraints and mongo ([#5286](https://github.com/parse-community/parse-server/pull/5286)), thanks to [Julien Qu\u00e9r\u00e9](https://github.com/jlnquere)\n\n## 3.2.3\n[Full Changelog](https://github.com/parse-community/parse-server/compare/3.2.2...3.2.3)\n- Correct previous release with patch that is fully merged\n\n## 3.2.2\n[Full Changelog](https://github.com/parse-community/parse-server/compare/3.2.1...3.2.2)\n- Security fix to properly process userSensitiveFields when parse-server is started with\n  ../lib/cli/parse-server [#5463](https://github.com/parse-community/parse-server/pull/5463\n  )\n\n## 3.2.1\n[Full Changelog](https://github.com/parse-community/parse-server/compare/3.2.0...3.2.1)\n- Increment package.json version to match the deployment tag\n\n## 3.2.0\n[Full Changelog](https://github.com/parse-community/parse-server/compare/3.1.3...3.2.0)\n- NEW: Support accessing sensitive fields with an explicit ACL.  Not documented yet, see [tests](https://github.com/parse-community/parse-server/blob/f2c332ea6a984808ad5b2e3ce34864a20724f72b/spec/UserPII.spec.js#L526) for examples\n- Upgrade Parse SDK JS to 2.3.1 [#5457](https://github.com/parse-community/parse-server/pull/5457)\n- Hides token contents in logStartupOptions if they arrive as a buffer [#6a9380](https://github.com/parse-community/parse-server/commit/6a93806c62205a56a8f4e3b8765848c552510337)\n- Support custom message for password requirements [#5399](https://github.com/parse-community/parse-server/pull/5399)\n- Support for Ajax password reset [#5332](https://github.com/parse-community/parse-server/pull/5332)\n- Postgres: Refuse to build unsafe JSON lists for contains [#5337](https://github.com/parse-community/parse-server/pull/5337)\n- Properly handle return values in beforeSave [#5228](https://github.com/parse-community/parse-server/pull/5228)\n- Fixes issue when querying user roles [#5276](https://github.com/parse-community/parse-server/pull/5276)\n- Fixes issue affecting update with CLP [#5269](https://github.com/parse-community/parse-server/pull/5269)\n\n## 3.1.3\n[Full Changelog](https://github.com/parse-community/parse-server/compare/3.1.2...3.1.3)\n\n- Postgres: Fixes support for global configuration\n- Postgres: Fixes support for numeric arrays\n- Postgres: Fixes issue affecting queries on empty arrays\n- LiveQuery: Adds support for transmitting the original object\n- Queries: Use estimated count if query is empty\n- Docker: Reduces the size of the docker image to 154Mb\n\n\n## 3.1.2\n[Full Changelog](https://github.com/parse-community/parse-server/compare/3.1.1...3.1.2)\n\n- Removes dev script, use TDD instead of server.\n- Removes nodemon and problematic dependencies.\n- Addressed event-stream security debacle.\n\n## 3.1.1\n[Full Changelog](https://github.com/parse-community/parse-server/compare/3.1.0...3.1.1)\n\n### Improvements:\n* Fixes issue that would prevent users with large number of roles to resolve all of them [Antoine Cormouls](https://github.com/Moumouls) (#5131, #5132)\n* Fixes distinct query on special fields ([#5144](https://github.com/parse-community/parse-server/pull/5144))\n\n\n## 3.1.0\n[Full Changelog](https://github.com/parse-community/parse-server/compare/3.0.0...3.1.0)\n\n### Breaking Changes:\n* Return success on sendPasswordResetEmail even if email not found. (#7fe4030)\n### Security Fix:\n* Expire password reset tokens on email change (#5104)\n### Improvements:\n* Live Query CLPs (#4387)\n* Reduces number of calls to injectDefaultSchema (#5107)\n* Remove runtime dependency on request (#5076)\n### Bug fixes:\n* Fixes issue with vkontatke authentication (#4977)\n* Use the correct function when validating google auth tokens (#5018)\n* fix unexpected 'delete' trigger issue on LiveQuery (#5031)\n* Improves performance for roles and ACL's in live query server (#5126)\n\n\n## 3.0.0\n[Full Changelog](https://github.com/parse-community/parse-server/compare/2.8.4...3.0.0)\n\n`parse-server` 3.0.0 comes with brand new handlers for cloud code. It now fully supports promises and async / await.\nFor more informations, visit the v3.0.0 [migration guide](https://github.com/parse-community/parse-server/blob/master/3.0.0.md).\n\n### Breaking changes:\n* Cloud Code handlers have a new interface based on promises.\n* response.success / response.error are removed in Cloud Code\n* Cloud Code runs with Parse-SDK 2.0\n* The aggregate now require aggregates to be passed in the form: `{\"pipeline\": [...]}` (REST Only)\n\n### Improvements:\n* Adds Pipeline Operator to Aggregate Router.\n* Adds documentations for parse-server's adapters, constructors and more.\n* Adds ability to pass a context object between `beforeSave` and `afterSave` affecting the same object.\n\n### Bug Fixes:\n* Fixes issue that would crash the server when mongo objects had undefined values [#4966](https://github.com/parse-community/parse-server/issues/4966)\n* Fixes issue that prevented ACL's from being used with `select` (see [#571](https://github.com/parse-community/Parse-SDK-JS/issues/571))\n\n### Dependency updates:\n* [@parse/simple-mailgun-adapter@1.1.0](https://www.npmjs.com/package/@parse/simple-mailgun-adapter)\n* [mongodb@3.1.3](https://www.npmjs.com/package/mongodb)\n* [request@2.88.0](https://www.npmjs.com/package/request)\n\n### Development Dependencies Updates:\n* [@parse/minami@1.0.0](https://www.npmjs.com/package/@parse/minami)\n* [deep-diff@1.0.2](https://www.npmjs.com/package/deep-diff)\n* [flow-bin@0.79.0](https://www.npmjs.com/package/flow-bin)\n* [jsdoc@3.5.5](https://www.npmjs.com/package/jsdoc)\n* [jsdoc-babel@0.4.0](https://www.npmjs.com/package/jsdoc-babel)\n\n### 2.8.4\n[Full Changelog](https://github.com/parse-community/parse-server/compare/2.8.3...2.8.4)\n\n#### Improvements:\n* Adds ability to forward errors to express handler (#4697)\n* Adds ability to increment the push badge with an arbitrary value (#4889)\n* Adds ability to preserve the file names when uploading (#4915)\n* `_User` now follow regular ACL policy. Letting administrator lock user out. (#4860) and (#4898)\n* Ensure dates are properly handled in aggregates (#4743)\n* Aggregates: Improved support for stages sharing the same name\n* Add includeAll option\n* Added verify password to users router and tests. (#4747)\n* Ensure read preference is never overriden, so DB config prevails (#4833)\n* add support for geoWithin.centerSphere queries via withJSON (#4825)\n* Allow sorting an object field (#4806)\n* Postgres: Don't merge JSON fields after save() to keep same behaviour as MongoDB (#4808) (#4815)\n\n#### Dependency updates\n* [commander@2.16.0](https://www.npmjs.com/package/commander)\n* [mongodb@3.1.1](https://www.npmjs.com/package/mongodb)\n* [pg-promise@8.4.5](https://www.npmjs.com/package/pg-promise)\n* [ws@6.0.0](https://www.npmjs.com/package/ws)\n* [bcrypt@3.0.0](https://www.npmjs.com/package/bcrypt)\n* [uws@10.148.1](https://www.npmjs.com/package/uws)\n\n##### Development Dependencies Updates:\n* [cross-env@5.2.0](https://www.npmjs.com/package/cross-env)\n* [eslint@5.0.0](https://www.npmjs.com/package/eslint)\n* [flow-bin@0.76.0](https://www.npmjs.com/package/flow-bin)\n* [mongodb-runner@4.0.0](https://www.npmjs.com/package/mongodb-runner)\n* [nodemon@1.18.1](https://www.npmjs.com/package/nodemon)\n* [nyc@12.0.2](https://www.npmjs.com/package/nyc)\n* [request-promise@4.2.2](https://www.npmjs.com/package/request-promise)\n* [supports-color@5.4.0](https://www.npmjs.com/package/supports-color)\n\n### 2.8.3\n[Full Changelog](https://github.com/parse-community/parse-server/compare/2.8.2...2.8.3)\n\n#### Improvements:\n\n* Adds support for JS SDK 2.0 job status header\n* Removes npm-git scripts as npm supports using git repositories that build, thanks to [Florent Vilmart](https://github.com/flovilmart)\n\n\n### 2.8.2\n[Full Changelog](https://github.com/parse-community/parse-server/compare/2.8.1...2.8.2)\n\n##### Bug Fixes:\n* Ensure legacy users without ACL's are not locked out, thanks to [Florent Vilmart](https://github.com/flovilmart)\n\n#### Improvements:\n* Use common HTTP agent to increase webhooks performance, thanks to [Tyler Brock](https://github.com/TylerBrock)\n* Adds withinPolygon support for Polygon objects, thanks to [Mads Bjerre](https://github.com/madsb)\n\n#### Dependency Updates:\n* [ws@5.2.0](https://www.npmjs.com/package/ws)\n* [commander@2.15.1](https://www.npmjs.com/package/commander)\n* [nodemon@1.17.5](https://www.npmjs.com/package/nodemon)\n\n##### Development Dependencies Updates:\n* [flow-bin@0.73.0](https://www.npmjs.com/package/flow-bin)\n* [cross-env@5.1.6](https://www.npmjs.com/package/cross-env)\n* [gaze@1.1.3](https://www.npmjs.com/package/gaze)\n* [deepcopy@1.0.0](https://www.npmjs.com/package/deepcopy)\n* [deep-diff@1.0.1](https://www.npmjs.com/package/deep-diff)\n\n\n### 2.8.1\n[Full Changelog](https://github.com/parse-community/parse-server/compare/2.8.1...2.8.0)\n\nEnsure all the files are properly exported to the final package.\n\n### 2.8.0\n[Full Changelog](https://github.com/parse-community/parse-server/compare/2.8.0...2.7.4)\n\n#### New Features\n* Adding Mongodb element to add `arrayMatches` the #4762 (#4766), thanks to [J\u00e9r\u00e9my Piednoel](https://github.com/jeremypiednoel)\n* Adds ability to Lockout users (#4749), thanks to [Florent Vilmart](https://github.com/flovilmart)\n\n#### Bug fixes:\n* Fixes issue when using afterFind with relations (#4752), thanks to [Florent Vilmart](https://github.com/flovilmart)\n* New query condition support to match all strings that starts with some other given strings (#3864), thanks to [Eduard Bosch Bertran](https://github.com/eduardbosch)\n* Allow creation of indices on default fields (#4738), thanks to [Claire Neveu](https://github.com/ClaireNeveu)\n* Purging empty class (#4676), thanks to [Diamond Lewis](https://github.com/dplewis)\n* Postgres: Fixes issues comparing to zero or false (#4667), thanks to [Diamond Lewis](https://github.com/dplewis)\n* Fix Aggregate Match Pointer (#4643), thanks to [Diamond Lewis](https://github.com/dplewis)\n\n#### Improvements:\n* Allow Parse.Error when returning from Cloud Code (#4695), thanks to [Saulo Tauil](https://github.com/saulogt)\n* Fix typo: \"requrest\" -> \"request\" (#4761), thanks to [Joseph Frazier](https://github.com/josephfrazier)\n* Send version for Vkontakte API (#4725), thanks to [oleg](https://github.com/alekoleg)\n* Ensure we respond with invalid password even if email is unverified (#4708), thanks to [dblythy](https://github.com/dblythy)\n* Add _password_history to default sensitive data (#4699), thanks to [Jong Eun Lee](https://github.com/yomybaby)\n* Check for node version in postinstall script (#4657), thanks to [Diamond Lewis](https://github.com/dplewis)\n* Remove FB Graph API version from URL to use the oldest non deprecated version, thanks to [SebC](https://github.com/SebC99)\n\n#### Dependency Updates:\n* [@parse/push-adapter@2.0.3](https://www.npmjs.com/package/@parse/push-adapter)\n* [@parse/simple-mailgun-adapter@1.0.2](https://www.npmjs.com/package/@parse/simple-mailgun-adapter)\n* [uws@10.148.0](https://www.npmjs.com/package/uws)\n* [body-parser@1.18.3](https://www.npmjs.com/package/body-parser)\n* [mime@2.3.1](https://www.npmjs.com/package/mime)\n* [request@2.85.0](https://www.npmjs.com/package/request)\n* [mongodb@3.0.7](https://www.npmjs.com/package/mongodb)\n* [bcrypt@2.0.1](https://www.npmjs.com/package/bcrypt)\n* [ws@5.1.1](https://www.npmjs.com/package/ws)\n\n##### Development Dependencies Updates:\n* [cross-env@5.1.5](https://www.npmjs.com/package/cross-env)\n* [flow-bin@0.71.0](https://www.npmjs.com/package/flow-bin)\n* [deep-diff@1.0.0](https://www.npmjs.com/package/deep-diff)\n* [nodemon@1.17.3](https://www.npmjs.com/package/nodemon)\n\n\n### 2.7.4\n[Full Changelog](https://github.com/parse-community/parse-server/compare/2.7.4...2.7.3)\n\n#### Bug Fixes:\n* Fixes an issue affecting polygon queries, thanks to [Diamond Lewis](https://github.com/dplewis)\n\n#### Dependency Updates:\n* [pg-promise@8.2.1](https://www.npmjs.com/package/pg-promise)\n\n##### Development Dependencies Updates:\n* [nodemon@1.17.1](https://www.npmjs.com/package/nodemon)\n\n### 2.7.3\n[Full Changelog](https://github.com/parse-community/parse-server/compare/2.7.3...2.7.2)\n\n#### Improvements:\n* Improve documentation for LiveQuery options, thanks to [Arthur Cinader](https://github.com/acinader)\n* Improve documentation for using cloud code with docker, thanks to [Stephen Tuso](https://github.com/stephentuso)\n* Adds support for Facebook's AccountKit, thanks to [6thfdwp](https://github.com/6thfdwp)\n* Disable afterFind routines when running aggregates, thanks to [Diamond Lewis](https://github.com/dplewis)\n* Improve support for distinct aggregations of nulls, thanks to [Diamond Lewis](https://github.com/dplewis)\n* Regenreate the email verification token when requesting a new email, thanks to [Benjamin Wilson Friedman](https://github.com/montymxb)\n\n#### Bug Fixes:\n* Fix issue affecting readOnly masterKey and purge command, thanks to [AreyouHappy](https://github.com/AreyouHappy)\n* Fixes Issue unsetting in beforeSave doesn't allow object creation, thanks to [Diamond Lewis](https://github.com/dplewis)\n* Fixes issue crashing server on invalid live query payload, thanks to [fridays](https://github.com/fridays)\n* Fixes issue affecting postgres storage adapter \"undefined property '__op'\", thanks to [Tyson Andre](https://github,com/TysonAndre)\n\n#### Dependency Updates:\n* [winston@2.4.1](https://www.npmjs.com/package/winston)\n* [pg-promise@8.2.0](https://www.npmjs.com/package/pg-promise)\n* [commander@2.15.0](https://www.npmjs.com/package/commander)\n* [lru-cache@4.1.2](https://www.npmjs.com/package/lru-cache)\n* [parse@1.11.1](https://www.npmjs.com/package/parse)\n* [ws@5.0.0](https://www.npmjs.com/package/ws)\n* [mongodb@3.0.4](https://www.npmjs.com/package/mongodb)\n* [lodash@4.17.5](https://www.npmjs.com/package/lodash)\n\n##### Development Dependencies Updates:\n* [cross-env@5.1.4](https://www.npmjs.com/package/cross-env)\n* [flow-bin@0.67.1](https://www.npmjs.com/package/flow-bin)\n* [jasmine@3.1.0](https://www.npmjs.com/package/jasmine)\n* [parse@1.11.1](https://www.npmjs.com/package/parse)\n* [babel-eslint@8.2.2](https://www.npmjs.com/package/babel-eslint)\n* [nodemon@1.15.0](https://www.npmjs.com/package/nodemon)\n\n### 2.7.2\n[Full Changelog](https://github.com/parse-community/parse-server/compare/2.7.2...2.7.1)\n\n#### Improvements:\n* Improved match aggregate\n* Do not mark the empty push as failed\n* Support pointer in aggregate query\n* Introduces flow types for storage\n* Postgres: Refactoring of Postgres Storage Adapter\n* Postgres: Support for multiple projection in aggregate\n* Postgres: performance optimizations\n* Adds infos about vulnerability disclosures\n* Adds ability to login with email when provided as username\n\n#### Bug Fixes\n* Scrub Passwords with URL Encoded Characters\n* Fixes issue affecting using sorting in beforeFind\n\n#### Dependency Updates:\n* [commander@2.13.0](https://www.npmjs.com/package/commander)\n* [semver@5.5.0](https://www.npmjs.com/package/semver)\n* [pg-promise@7.4.0](https://www.npmjs.com/package/pg-promise)\n* [ws@4.0.0](https://www.npmjs.com/package/ws)\n* [mime@2.2.0](https://www.npmjs.com/package/mime)\n* [parse@1.11.0](https://www.npmjs.com/package/parse)\n\n##### Development Dependencies Updates:\n* [nodemon@1.14.11](https://www.npmjs.com/package/nodemon)\n* [flow-bin@0.64.0](https://www.npmjs.com/package/flow-bin)\n* [jasmine@2.9.0](https://www.npmjs.com/package/jasmine)\n* [cross-env@5.1.3](https://www.npmjs.com/package/cross-env)\n\n### 2.7.1\n[Full Changelog](https://github.com/parse-community/parse-server/compare/2.7.1...2.7.0)\n\n:warning: Fixes a security issue affecting Class Level Permissions\n\n* Adds support for dot notation when using matchesKeyInQuery, thanks to [Henrik](https://github.com/bohemima) and [Arthur Cinader](https://github.com/acinader)\n\n### 2.7.0\n[Full Changelog](https://github.com/parse-community/parse-server/compare/2.7.0...2.6.5)\n\n:warning: This version contains an issue affecting Class Level Permissions on mongoDB. Please upgrade to 2.7.1.\n\nStarting parse-server 2.7.0, the minimun nodejs version is 6.11.4, please update your engines before updating parse-server\n\n#### New Features:\n* Aggregation endpoints, thanks to [Diamond Lewis](https://github.com/dplewis)\n* Adds indexation options onto Schema endpoints, thanks to [Diamond Lewis](https://github.com/dplewis)\n\n#### Bug fixes:\n* Fixes sessionTokens being overridden in 'find' (#4332), thanks to [Benjamin Wilson Friedman](https://github.com/montymxb)\n* Proper `handleShutdown()` feature to close database connections (#4361), thanks to [CHANG, TZU-YEN](https://github.com/trylovetom)\n* Fixes issue affecting state of _PushStatus objects, thanks to [Benjamin Wilson Friedman](https://github.com/montymxb)\n* Fixes issue affecting calling password reset password pages with wrong appid, thanks to [Bryan de Leon](https://github.com/bryandel)\n* Fixes issue affecting duplicates _Sessions on successive logins, thanks to [Florent Vilmart](https://github.com/flovilmart)\n\n#### Improvements:\n* Updates contributing guides, and improves windows support, thanks to [Addison Elliott](https://github.com/addisonelliott)\n* Uses new official scoped packaged, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Improves health checks responses, thanks to [Benjamin Wilson Friedman](https://github.com/montymxb)\n* Add password confirmation to choose_password, thanks to [Worathiti Manosroi](https://github.com/pungme)\n* Improve performance of relation queries, thanks to [Florent Vilmart](https://github.com/flovilmart)\n\n#### Dependency Updates:\n* [commander@2.12.1](https://www.npmjs.com/package/commander)\n* [ws@3.3.2](https://www.npmjs.com/package/ws)\n* [uws@9.14.0](https://www.npmjs.com/package/uws)\n* [pg-promise@7.3.2](https://www.npmjs.com/package/pg-promise)\n* [parse@1.10.2](https://www.npmjs.com/package/parse)\n* [pg-promise@7.3.1](https://www.npmjs.com/package/pg-promise)\n\n##### Development Dependencies Updates:\n* [cross-env@5.1.1](https://www.npmjs.com/package/cross-env)\n\n\n\n### 2.6.5\n[Full Changelog](https://github.com/ParsePlatform/parse-server/compare/2.6.5...2.6.4)\n\n#### New Features:\n* Adds support for read-only masterKey, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Adds support for relative time queries (mongodb only), thanks to [Marvel Mathew](https://github.com/marvelm)\n\n#### Improvements:\n* Handle possible afterSave exception, thanks to [Benjamin Wilson Friedman](https://github.com/montymxb)\n* Add support for expiration interval in Push, thanks to [Marvel Mathew](https://github.com/marvelm)\n\n#### Bug Fixes:\n* The REST API key was improperly inferred from environment when using the CLI, thanks to [Florent Vilmart](https://github.com/flovilmart)\n\n### 2.6.4\n[Full Changelog](https://github.com/ParsePlatform/parse-server/compare/2.6.4...2.6.3)\n\n#### Improvements:\n* Improves management of configurations and default values, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Adds ability to start ParseServer with `ParseServer.start(options)`, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Adds request original IP to cloud code hooks, thanks to [Gustav Ahlberg](https://github.com/Gyran)\n* Corrects some outdated links, thanks to [Benjamin Wilson Friedman](https://github.com/montymxb)\n* Adds serverURL validation on startup, thanks to [Benjamin Wilson Friedman](https://github.com/montymxb)\n* Adds ability to login with POST requests alongside GET, thanks to [Benjamin Wilson Friedman](https://github.com/montymxb)\n* Adds ability to login with email, instead of username, thanks to [Florent Vilmart](https://github.com/flovilmart)\n\n#### Bug Fixes:\n* Fixes issue affecting beforeSaves and increments, thanks to [Benjamin Wilson Friedman](https://github.com/montymxb)\n\n#### Dependency Updates:\n* [parse-server-push-adapter@2.0.2](https://www.npmjs.com/package/parse-server-push-adapter)\n* [semver@5.4.1](https://www.npmjs.com/package/semver)\n* [pg-promise@7.0.3](https://www.npmjs.com/package/pg-promise)\n* [mongodb@2.2.33](https://www.npmjs.com/package/mongodb)\n* [parse@1.10.1](https://www.npmjs.com/package/parse)\n* [express@4.16.0](https://www.npmjs.com/package/express)\n* [mime@1.4.1](https://www.npmjs.com/package/mime)\n* [parse-server-simple-mailgun-adapter@1.0.1](https://www.npmjs.com/package/parse-server-simple-mailgun-adapter)\n\n##### Development Dependencies Updates:\n* [babel-preset-env@1.6.1](https://www.npmjs.com/package/babel-preset-env)\n* [cross-env@5.1.0](https://www.npmjs.com/package/cross-env)\n* [mongodb-runner@3.6.1](https://www.npmjs.com/package/mongodb-runner)\n* [eslint-plugin-flowtype@2.39.1](https://www.npmjs.com/package/eslint-plugin-flowtype)\n* [eslint@4.9.0](https://www.npmjs.com/package/eslint)\n\n### 2.6.3\n[Full Changelog](https://github.com/ParsePlatform/parse-server/compare/2.6.2...2.6.3)\n\n#### Improvements:\n* Queries on Pointer fields with `$in` and `$nin` now supports list of objectId's, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* LiveQueries on `$in` and `$nin` for pointer fields work as expected thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Also remove device token when APNS error is BadDeviceToken, thanks to [Mauricio Tollin](https://github.com/)\n* LRU cache is not available on the ParseServer object, thanks to [Tyler Brock](https://github.com/tbrock)\n* Error messages are more expressive, thanks to [Tyler Brock](https://github.com/tbrock)\n* Postgres: Properly handle undefined field values, thanks to [Diamond Lewis](https://github.com/dlewis)\n* Updating with two GeoPoints fails correctly, thanks to [Anthony Mosca](https://github.com/aontas)\n\n#### New Features:\n* Adds ability to set a maxLimit on server configuration for queries, thanks to [Chris Norris](https://github.com/)\n\n#### Bug fixes:\n* Fixes issue affecting reporting `_PushStatus` with misconfigured serverURL, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Fixes issue affecting deletion of class that doesn't exist, thanks to [Diamond Lewis](https://github.com/dlewis)\n\n#### Dependency Updates:\n* [winston@2.4.0](https://www.npmjs.com/package/winston)\n* [pg-promise@6.10.2](https://www.npmjs.com/package/pg-promise)\n* [winston-daily-rotate-file@1.6.0](https://www.npmjs.com/package/winston-daily-rotate-file)\n* [request@2.83.0](https://www.npmjs.com/package/request)\n* [body-parser@1.18.2](https://www.npmjs.com/package/body-parser)\n\n##### Development Dependencies Updates:\n* [request-promise@4.2.2](https://www.npmjs.com/package/request-promise)\n* [eslint@4.7.1](https://www.npmjs.com/package/eslint)\n\n### 2.6.2\n[Full Changelog](https://github.com/ParsePlatform/parse-server/compare/2.6.1...2.6.2)\n\n#### Improvements:\n* PushWorker/PushQueue channels are properly prefixed with the Parse applicationId, thanks to [Marvel Mathew](https://github.com/marvelm)\n* You can use Parse.Cloud.afterSave hooks on _PushStatus\n* You can use Parse.Cloud.onLiveQueryEvent to track the number of clients and subscriptions\n* Adds support for more fields from the Audience class.\n\n#### New Features:\n* Push: Adds ability to track sentPerUTC offset if your push scheduler supports it.\n* Push: Adds support for cleaning up invalid deviceTokens from _Installation (PARSE_SERVER_CLEANUP_INVALID_INSTALLATIONS=1).\n\n#### Dependency Updates:\n* [ws@3.2.0](https://www.npmjs.com/package/ws)\n* [pg-promise@6.5.3](https://www.npmjs.com/package/pg-promise)\n* [winston-daily-rotate-file@1.5.0](https://www.npmjs.com/package/winston-daily-rotate-file)\n* [body-parser@1.18.1](https://www.npmjs.com/package/body-parser)\n\n##### Development Dependencies Updates:\n* [nodemon@1.12.1](https://www.npmjs.com/package/nodemon)\n* [mongodb-runner@3.6.0](https://www.npmjs.com/package/mongodb-runner)\n* [babel-eslint@8.0.0](https://www.npmjs.com/package/babel-eslint)\n\n### 2.6.1\n[Full Changelog](https://github.com/ParsePlatform/parse-server/compare/2.6.0...2.6.1)\n\n#### Improvements:\n* Improves overall performance of the server, more particularly with large query results.\n* Improves performance of InMemoryCacheAdapter by removing serialization.\n* Improves logging performance by skipping necessary log calls.\n* Refactors object routers to simplify logic.\n* Adds automatic indexing on $text indexes, thanks to [Diamon Lewis](https://github.com/dplewis)\n\n#### New Features:\n* Push: Adds ability to send localized pushes according to the _Installation localeIdentifier\n* Push: proper support for scheduling push in user's locale time, thanks to [Marvel Mathew](https://github.com/marvelm)\n* LiveQuery: Adds ability to use LiveQuery with a masterKey, thanks to [Jeremy May](https://github.com/kenishi)\n\n#### Bug Fixes:\n* Fixes an issue that would duplicate Session objects per userId-installationId pair.\n* Fixes an issue affecting pointer permissions introduced in this release.\n* Fixes an issue that would prevent displaying audiences correctly in dashboard.\n* Fixes an issue affecting preventLoginWithUnverifiedEmail upon signups.\n\n#### Dependency Updates:\n* [pg-promise@6.3.2](https://www.npmjs.com/package/pg-promise)\n* [body-parser@1.18.0](https://www.npmjs.com/package/body-parser)\n* [nodemon@1.11.1](https://www.npmjs.com/package/nodemon)\n\n##### Development Dependencies Updates:\n* [babel-cli@6.26.0](https://www.npmjs.com/package/babel-cli)\n\n### 2.6.0\n[Full Changelog](https://github.com/ParsePlatform/parse-server/compare/2.5.3...2.6.0)\n\n#### Breaking Changes:\n* [parse-server-s3-adapter@1.2.0](https://www.npmjs.com/package/parse-server-s3-adapter): A new deprecation notice is introduced with parse-server-s3-adapter's version 1.2.0.  An upcoming release will remove passing key and password arguments.  AWS credentials should be set using AWS best practices.  See the [Deprecation Notice for AWS credentials]( https://github.com/parse-server-modules/parse-server-s3-adapter/blob/master/README.md#deprecation-notice----aws-credentials) section of the adapter's README.\n\n#### New Features\n* Polygon is fully supported as a type, thanks to [Diamond Lewis](https://github.com/dplewis)\n* Query supports PolygonContains, thanks to [Diamond Lewis](https://github.com/dplewis)\n\n#### Improvements\n* Postgres: Adds support nested contains and containedIn, thanks to [Diamond Lewis](https://github.com/dplewis)\n* Postgres: Adds support for `null` in containsAll queries, thanks to [Diamond Lewis](https://github.com/dplewis)\n* Cloud Code: Request headers are passed to the cloud functions, thanks to [miguel-s](https://github.com/miguel-s)\n* Push: All push queries now filter only where deviceToken exists\n\n#### Bug Fixes:\n* Fixes issue affecting updates of _User objects when authData was passed.\n* Push: Pushing to an empty audience should now properly report a failed _PushStatus\n* Linking Users: Fixes issue affecting linking users with sessionToken only\n\n#### Dependency Updates:\n* [ws@3.1.0](https://www.npmjs.com/package/ws)\n* [mime@1.4.0](https://www.npmjs.com/package/mime)\n* [semver@5.4.0](https://www.npmjs.com/package/semver)\n* [uws@8.14.1](https://www.npmjs.com/package/uws)\n* [bcrypt@1.0.3](https://www.npmjs.com/package/bcrypt)\n* [mongodb@2.2.31](https://www.npmjs.com/package/mongodb)\n* [redis@2.8.0](https://www.npmjs.com/package/redis)\n* [pg-promise@6.3.1](https://www.npmjs.com/package/pg-promise)\n* [commander@2.11.0](https://www.npmjs.com/package/commander)\n\n##### Development Dependencies Updates:\n* [jasmine@2.8.0](https://www.npmjs.com/package/jasmine)\n* [babel-register@6.26.0](https://www.npmjs.com/package/babel-register)\n* [babel-core@6.26.0](https://www.npmjs.com/package/babel-core)\n* [cross-env@5.0.2](https://www.npmjs.com/package/cross-env)\n\n### 2.5.3\n[Full Changelog](https://github.com/ParsePlatform/parse-server/compare/2.5.2...2.5.3)\n\n#### New Features:\n* badge property on android installations will now be set as on iOS (#3970), thanks to [Florent Vilmart](https://github.com/flovilmart)\n\n#### Bug Fixes:\n* Fixes incorrect number parser for cache options\n\n### 2.5.2\n[Full Changelog](https://github.com/ParsePlatform/parse-server/compare/2.5.1...2.5.2)\n\n#### Improvements:\n* Restores ability to run on node >= 4.6\n* Adds ability to configure cache from CLI\n* Removes runtime check for node >= 4.6\n\n### 2.5.1\n[Full Changelog](https://github.com/ParsePlatform/parse-server/compare/2.5.0...2.5.1)\n\n#### New Features:\n* Adds ability to set default objectId size (#3950), thanks to [Steven Shipton](https://github.com/steven-supersolid)\n\n#### Improvements:\n* Uses LRU cache instead of InMemoryCache by default (#3979), thanks to [Florent Vilmart](https://github.com/flovilmart)\n* iOS pushes are now using HTTP/2.0 instead of binary API  (#3983), thanks to [Florent Vilmart](https://github.com/flovilmart)\n\n#### Dependency Updates:\n* [parse@1.10.0](https://www.npmjs.com/package/parse)\n* [pg-promise@6.3.0](https://www.npmjs.com/package/pg-promise)\n* [parse-server-s3-adapter@1.1.0](https://www.npmjs.com/package/parse-server-s3-adapter)\n* [parse-server-push-adapter@2.0.0](https://www.npmjs.com/package/parse-server-push-adapter)\n\n### 2.5.0\n[Full Changelog](https://github.com/ParsePlatform/parse-server/compare/2.4.2...2.5.0)\n\n#### New Features:\n* Adds ability to run full text search (#3904), thanks to [Diamond Lewis](https://github.com/dplewis)\n* Adds ability to run `$withinPolygon` queries (#3889), thanks to [Diamond Lewis](https://github.com/dplewis)\n* Adds ability to pass read preference per query with mongodb (#3865), thanks to [davimacedo](https://github.com/davimacedo)\n* beforeFind trigger now includes `isGet` for get queries (#3862), thanks to [davimacedo](https://github.com/davimacedo)\n* Adds endpoints for dashboard's audience API (#3861), thanks to [davimacedo](https://github.com/davimacedo)\n* Restores the job scheduling endpoints (#3927), thanks to [Florent Vilmart](https://github.com/flovilmart)\n\n#### Improvements:\n* Removes unnecessary warning when using maxTimeMs with mongodb, thanks to [Tyler Brock](https://github.com/tbrock)\n* Improves access control on system classes (#3916), thanks to [Worathiti Manosroi](https://github.com/pungme)\n* Adds bytes support in postgres (#3894), thanks to [Diamond Lewis](https://github.com/dplewis)\n\n#### Bug Fixes:\n* Fixes issue with vkontakte adapter that would hang the request, thanks to [Denis Trofimov](https://github.com/denistrofimov)\n* Fixes issue affecting null relational data (#3924), thanks to [davimacedo](https://github.com/davimacedo)\n* Fixes issue affecting session token deletion (#3937), thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Fixes issue affecting the serverInfo endpoint (#3933), thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Fixes issue affecting beforeSave with dot-noted sub-documents (#3912), thanks to [IlyaDiallo](https://github.com/IlyaDiallo)\n* Fixes issue affecting emails being sent when using a 3rd party auth (#3882), thanks to [davimacedo](https://github.com/davimacedo)\n\n#### Dependency Updates:\n* [commander@2.10.0](https://www.npmjs.com/package/commander)\n* [pg-promise@5.9.7](https://www.npmjs.com/package/pg-promise)\n* [lru-cache@4.1.0](https://www.npmjs.com/package/lru-cache)\n* [mongodb@2.2.28](https://www.npmjs.com/package/mongodb)\n\n##### Development dependencies\n* [babel-core@6.25.0](https://www.npmjs.com/package/babel-core)\n* [cross-env@5.0.1](https://www.npmjs.com/package/cross-env)\n* [nyc@11.0.2](https://www.npmjs.com/package/nyc)\n\n### 2.4.2\n[Full Changelog](https://github.com/ParsePlatform/parse-server/compare/2.4.1...2.4.2)\n\n#### New Features:\n* ParseQuery: Support for withinPolygon [#3866](https://github.com/parse-community/parse-server/pull/3866), thanks to [Diamond Lewis](https://github.com/dplewis)\n\n#### Improvements:\n* Postgres: Use transactions when deleting a class, [#3869](https://github.com/parse-community/parse-server/pull/3836), thanks to [Vitaly Tomilov](https://github.com/vitaly-t)\n* Postgres: Proper support for GeoPoint equality query, [#3874](https://github.com/parse-community/parse-server/pull/3836), thanks to [Diamond Lewis](https://github.com/dplewis)\n* beforeSave and liveQuery will be correctly triggered on email verification [#3851](https://github.com/parse-community/parse-server/pull/3851), thanks to [Florent Vilmart](https://github.com/flovilmart)\n\n#### Bug fixes:\n* Skip authData validation if it hasn't changed, on PUT requests [#3872](https://github.com/parse-community/parse-server/pull/3872), thanks to [Florent Vilmart](https://github.com/flovilmart)\n\n#### Dependency Updates:\n* [mongodb@2.2.27](https://www.npmjs.com/package/mongodb)\n* [pg-promise@5.7.2](https://www.npmjs.com/package/pg-promise)\n\n\n### 2.4.1\n[Full Changelog](https://github.com/ParsePlatform/parse-server/compare/2.4.0...2.4.1)\n\n#### Bug fixes:\n* Fixes issue affecting relation updates ([#3835](https://github.com/parse-community/parse-server/pull/3835), [#3836](https://github.com/parse-community/parse-server/pull/3836)), thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Fixes issue affecting sending push notifications, thanks to [Felipe Andrade](https://github.com/felipemobile)\n* Session are always cleared when updating the passwords ([#3289](https://github.com/parse-community/parse-server/pull/3289), [#3821](https://github.com/parse-community/parse-server/pull/3821), thanks to [Florent Vilmart](https://github.com/flovilmart)\n\n#### Dependency Updates:\n* [body-parser@1.17.2](https://www.npmjs.com/package/body-parser)\n* [pg-promise@5.7.1](https://www.npmjs.com/package/pg-promise)\n* [ws@3.0.0](https://www.npmjs.com/package/ws)\n\n\n### 2.4.0\n[Full Changelog](https://github.com/ParsePlatform/parse-server/compare/2.3.8...2.4.0)\n\nStarting 2.4.0, parse-server is tested against node 6.10 and 7.10, mongodb 3.2 and 3.4.\nIf you experience issues with older versions, please [open a issue](https://github.com/parse-community/parse-server/issues).\n\n#### New Features:\n* Adds `count` Class Level Permission ([#3814](https://github.com/parse-community/parse-server/pull/3814)), thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Proper graceful shutdown support ([#3786](https://github.com/parse-community/parse-server/pull/3786)), thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Let parse-server store as `scheduled` Push Notifications with push_time (#3717, #3722), thanks to [Felipe Andrade](https://github.com/felipemobile)\n\n#### Improvements\n* Parse-Server images are built through docker hub, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Skip authData validation if it hasn't changed, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* [postgres] Improve performance when adding many new fields to the Schema ([#3740](https://github.com/parse-community/parse-server/pull/3740)), thanks to [Paulo V\u00edtor S Reis](https://github.com/paulovitin)\n* Test maintenance, wordsmithing and nits ([#3744](https://github.com/parse-community/parse-server/pull/3744)), thanks to [Arthur Cinader](https://github.com/acinader)\n\n#### Bug Fixes:\n* [postgres] Fixes issue affecting deleting multiple fields of a Schema ([#3734](https://github.com/parse-community/parse-server/pull/3734), [#3735](https://github.com/parse-community/parse-server/pull/3735)), thanks to [Paulo V\u00edtor S Reis](https://github.com/paulovitin)\n* Fix issue affecting _PushStatus state ([#3808](https://github.com/parse-community/parse-server/pull/3808)), thanks to [Florent Vilmart](https://github.com/flovilmart)\n* requiresAuthentication Class Level Permission behaves correctly, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Email Verification related fields are not exposed ([#3681](https://github.com/parse-community/parse-server/pull/3681), [#3393](https://github.com/parse-community/parse-server/pull/3393), [#3432](https://github.com/parse-community/parse-server/pull/3432)), thanks to [Anthony Mosca](https://github.com/aontas)\n* HTTP query parameters are properly obfuscated in logs ([#3793](https://github.com/parse-community/parse-server/pull/3793), [#3789](https://github.com/parse-community/parse-server/pull/3789)), thanks to [@youngerong](https://github.com/youngerong)\n* Improve handling of `$near` operators in `$or` queries ([#3767](https://github.com/parse-community/parse-server/pull/3767), [#3798](https://github.com/parse-community/parse-server/pull/3798)), thanks to [Jack Wearden](https://github.com/NotBobTheBuilder)\n* Fix issue affecting arrays of pointers ([#3169](https://github.com/parse-community/parse-server/pull/3169)), thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Fix issue affecting overloaded query constraints ([#3723](https://github.com/parse-community/parse-server/pull/3723), [#3678](https://github.com/parse-community/parse-server/pull/3678)), thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Properly catch unhandled rejections in _Installation updates ([#3795](https://github.com/parse-community/parse-server/pull/3795)), thanks to [kahoona77](https://github.com/kahoona77)\n\n#### Dependency Updates:\n\n* [uws@0.14.5](https://www.npmjs.com/package/uws)\n* [mime@1.3.6](https://www.npmjs.com/package/mime)\n* [mongodb@2.2.26](https://www.npmjs.com/package/mongodb)\n* [pg-promise@5.7.0](https://www.npmjs.com/package/pg-promise)\n* [semver@5.3.0](https://www.npmjs.com/package/semver)\n\n##### Development dependencies\n* [babel-cli@6.24.1](https://www.npmjs.com/package/babel-cli)\n* [babel-core@6.24.1](https://www.npmjs.com/package/babel-core)\n* [babel-preset-es2015@6.24.1](https://www.npmjs.com/package/babel-preset-es2015)\n* [babel-preset-stage-0@6.24.1](https://www.npmjs.com/package/babel-preset-stage-0)\n* [babel-register@6.24.1](https://www.npmjs.com/package/babel-register)\n* [cross-env@5.0.0](https://www.npmjs.com/package/cross-env)\n* [deep-diff@0.3.8](https://www.npmjs.com/package/deep-diff)\n* [gaze@1.1.2](https://www.npmjs.com/package/gaze)\n* [jasmine@2.6.0](https://www.npmjs.com/package/jasmine)\n* [jasmine-spec-reporter@4.1.0](https://www.npmjs.com/package/jasmine-spec-reporter)\n* [mongodb-runner@3.5.0](https://www.npmjs.com/package/mongodb-runner)\n* [nyc@10.3.2](https://www.npmjs.com/package/nyc)\n* [request-promise@4.2.1](https://www.npmjs.com/package/request-promise)\n\n\n### 2.3.8\n[Full Changelog](https://github.com/ParsePlatform/parse-server/compare/2.3.7...2.3.8)\n\n#### New Features\n* Support for PG-Promise options, thanks to [ren dong](https://github.com/rendongsc)\n\n#### Improvements\n* Improves support for graceful shutdown, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Improves configuration validation for Twitter Authentication, thanks to [Benjamin Wilson Friedman](https://github.com/montymxb)\n\n#### Bug Fixes\n* Fixes issue affecting GeoPoint __type with Postgres, thanks to [zhoul-HS](https://github.com/zhoul-HS)\n* Prevent user creation if username or password is empty, thanks to [Wissam Abirached](https://github.com/wabirached)\n\n#### Dependency Updates:\n* [cross-env@4.0.0 ](https://www.npmjs.com/package/cross-env)\n* [ws@2.2.3](https://www.npmjs.com/package/ws)\n* [babel-core@6.24.0](https://www.npmjs.com/package/babel-core)\n* [uws@0.14.0](https://www.npmjs.com/package/uws)\n* [babel-preset-es2015@6.24.0](https://www.npmjs.com/package/babel-preset-es2015)\n* [babel-plugin-syntax-flow@6.18.0](https://www.npmjs.com/package/babel-plugin-syntax-flow)\n* [babel-cli@6.24.0](https://www.npmjs.com/package/babel-cli)\n* [babel-register@6.24.0](https://www.npmjs.com/package/babel-register)\n* [winston-daily-rotate-file@1.4.6](https://www.npmjs.com/package/winston-daily-rotate-file)\n* [mongodb@2.2.25](https://www.npmjs.com/package/mongodb)\n* [redis@2.7.0](https://www.npmjs.com/package/redis)\n* [pg-promise@5.6.4](https://www.npmjs.com/package/pg-promise)\n* [parse-server-push-adapter@1.3.0](https://www.npmjs.com/package/parse-server-push-adapter)\n\n### 2.3.7\n[Full Changelog](https://github.com/ParsePlatform/parse-server/compare/2.3.6...2.3.7)\n\n#### New Features\n* New endpoint to resend verification email, thanks to [Xy Ziemba](https://github.com/xyziemba)\n\n#### Improvements\n* Add TTL option for Redis Cache Adapter, thanks to [Ryan Foster](https://github.com/f0ster)\n* Update Postgres Storage Adapter, thanks to [Vitaly Tomilov](https://github.com/vitaly-t)\n\n#### Bug Fixes\n* Add index on Role.name, fixes (#3579), thanks to [Natan Rolnik](https://github.com/natanrolnik)\n* Fix default value of userSensitiveFields, fixes (#3593), thanks to [Arthur Cinader](https://github.com/acinader)\n\n#### Dependency Updates:\n* [body-parser@1.17.1](https://www.npmjs.com/package/body-parser)\n* [express@4.15.2](https://www.npmjs.com/package/express)\n* [request@2.81.0](https://www.npmjs.com/package/request)\n* [winston-daily-rotate-file@1.4.5](https://www.npmjs.com/package/winston-daily-rotate-file)\n* [ws@2.2.0](https://www.npmjs.com/package/ws)\n\n\n### 2.3.6\n[Full Changelog](https://github.com/ParsePlatform/parse-server/compare/2.3.5...2.3.6)\n\n#### Improvements\n* Adds support for injecting a middleware for instumentation in the CLI, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Alleviate mongodb bug with $or queries [SERVER-13732](https://jira.mongodb.org/browse/SERVER-13732), thanks to [Jack Wearden](https://github.com/NotBobTheBuilder)\n\n#### Bug Fixes\n* Fix issue affecting password policy and empty passwords, thanks to [Bhaskar Reddy Yasa](https://github.com/bhaskaryasa)\n* Fix issue when logging url in non string objects, thanks to [Paulo V\u00edtor S Reis](https://github.com/paulovitin)\n\n#### Dependencies updates:\n* [ws@2.1.0](https://npmjs.com/package/ws)\n* [uws@0.13.0](https://npmjs.com/package/uws)\n* [pg-promise@5.6.2](https://npmjs.com/package/pg-promise)\n\n\n### 2.3.5\n[Full Changelog](https://github.com/ParsePlatform/parse-server/compare/2.3.3...2.3.5)\n\n#### Bug Fixes\n* Allow empty client key\n(#3497), thanks to [Arthur Cinader](https://github.com/acinader)\n* Fix LiveQuery unsafe user\n(#3525), thanks to [David Starke](https://github.com/dstarke)\n* Use `flushdb` instead of `flushall` in RedisCacheAdapter\n(#3523), thanks to [Jeremy Louie](https://github.com/JeremyPlease)\n* Fix saving GeoPoints and Files in `_GlobalConfig` (Make sure we don't treat\ndot notation keys as topLevel atoms)\n(#3531), thanks to [Florent Vilmart](https://github.com/flovilmart)\n\n### 2.3.3\n[Full Changelog](https://github.com/ParsePlatform/parse-server/compare/2.3.2...2.3.3)\n\n#### Breaking Changes\n* **Minimum Node engine bumped to 4.6** (#3480), thanks to [Florent Vilmart](https://github.com/flovilmart)\n\n#### Bug Fixes\n* Add logging on failure to create file (#3424), thanks to [Arthur Cinader](https://github.com/acinader)\n* Log Parse Errors so they are intelligible (#3431), thanks to [Arthur Cinader](https://github.com/acinader)\n* MongoDB $or Queries avoid SERVER-13732 bug (#3476), thanks to [Jack Wearden](https://github.com/NotBobTheBuilder)\n* Mongo object to Parse object date serialization - avoid re-serialization of iso of type Date (#3389), thanks to [nodechefMatt](https://github.com/nodechefMatt)\n\n#### Improvements\n* Ground preparations for push scalability (#3080), thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Use uWS as optional dependency for ws server (#3231), thanks to [Florent Vilmart](https://github.com/flovilmart)\n\n### 2.3.2\n[Full Changelog](https://github.com/ParsePlatform/parse-server/compare/2.3.1...2.3.2)\n\n#### New features\n* Add parseFrameURL for masking user-facing pages (#3267), thanks to  [Lenart Rudel](https://github.com/lenart)\n\n#### Bug fixes\n* Fix Parse-Server to work with winston-daily-rotate-1.4.2 (#3335), thanks to [Arthur Cinader](https://github.com/acinader)\n\n#### Improvements\n* Add support for regex string for password policy validatorPattern setting (#3331), thanks to [Bhaskar Reddy Yasa](https://github.com/bhaskaryasa)\n* LiveQuery should match subobjects with dot notation (#3322), thanks to [David Starke](https://github.com/dstarke)\n* Reduce time to process high number of installations for push (#3264), thanks to [jeacott1](https://github.com/jeacott1)\n* Fix trivial typo in error message (#3238), thanks to [Arthur Cinader](https://github.com/acinader)\n\n### 2.3.1\n[Full Changelog](https://github.com/ParsePlatform/parse-server/compare/2.3.0...2.3.1)\n\nA major issue was introduced when refactoring the authentication modules.\nThis release addresses only that issue.\n\n### 2.3.0\n[Full Changelog](https://github.com/ParsePlatform/parse-server/compare/2.2.25...2.3.0)\n\n#### Breaking changes\n* Parse.Cloud.useMasterKey() is a no-op, please refer to (Cloud Code migration guide)[https://github.com/ParsePlatform/parse-server/wiki/Compatibility-with-Hosted-Parse#cloud-code]\n* Authentication helpers are now proper adapters, deprecates oauth option in favor of auth.\n* DEPRECATES: facebookAppIds, use `auth: { facebook: { appIds: [\"AAAAAAAAA\" ] } }`\n* `email` field is not returned anymore for `Parse.User` queries. (Provided only on the user itself if provided).\n\n#### New Features\n* Adds ability to restrict access through Class Level Permissions to only authenticated users [see docs](http://parseplatform.github.io/docs/ios/guide/#requires-authentication-permission-requires-parse-server---230)\n* Adds ability to strip sensitive data from `_User` responses, strips emails by default, thanks to [Arthur Cinader](https://github.com/acinader)\n* Adds password history support for password policies, thanks to [Bhaskar Reddy Yasa](https://github.com/bhaskaryasa)\n\n#### Improvements\n* Bump parse-server-s3-adapter to 1.0.6, thanks to [Arthur Cinader](https://github.com/acinader)\n* Using PARSE_SERVER_ENABLE_EXPERIMENTAL_DIRECT_ACCESS let you create user sessions when passing {installationId: \"xxx-xxx\"} on signup in cloud code, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Add CLI option to pass `host` parameter when creating parse-server from CLI, thanks to [Kulshekhar Kabra](https://github.com/kulshekhar)\n\n#### Bug fixes\n* Ensure batch routes are only using posix paths, thanks to [Steven Shipton](https://github.com/steven-supersolid)\n* Ensure falsy options from CLI are properly taken into account, thanks to [Steven Shipton](https://github.com/steven-supersolid)\n* Fixes issues affecting calls to `matchesKeyInQuery` with pointers.\n* Ensure that `select` keys can be changed in triggers (beforeFind...), thanks to [Arthur Cinader](https://github.com/acinader)\n\n#### Housekeeping\n* Enables and enforces linting with eslint, thanks to [Arthur Cinader](https://github.com/acinader)\n\n### 2.2.25\n\nPostgres support requires v9.5\n\n#### New Features\n* Dockerizing Parse Server, thanks to [Kirill Kravinsky](https://github.com/woyorus)\n* Login with qq, wechat, weibo, thanks to [haifeizhang]()\n* Password policy, validation and expiration, thanks to [Bhaskar Reddy Yasa](https://github.com/bhaskaryasa)\n* Health check on /health, thanks to [Kirill Kravinsky](https://github.com/woyorus)\n* Reuse SchemaCache across requests option, thanks to [Steven Shipton](https://github.com/steven-supersolid)\n\n#### Improvements\n* Better support for CLI options, thanks to [Steven Shipton](https://github.com/steven-supersolid)\n* Specity a database timeout with maxTimeMS, thanks to [Tyler Brock](https://github.com/TylerBrock)\n* Adds the username to reset password success pages, thanks to [Halim Qarroum](https://github.com/HQarroum)\n* Better support for Redis cache adapter, thanks to [Tyler Brock](https://github.com/TylerBrock)\n* Better coverage of Postgres, thanks to [Kulshekhar Kabra](https://github.com/kulshekhar)\n\n#### Bug Fixes\n* Fixes issue when sending push to multiple installations, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Fixes issues with twitter authentication, thanks to [jonas-db](https://github.com/jonas-db)\n* Ignore createdAt fields update, thanks to [Yuki Takeichi](https://github.com/yuki-takeichi)\n* Improve support for array equality with LiveQuery, thanks to [David Poetzsch-Heffter](https://github.com/dpoetzsch)\n* Improve support for batch endpoint when serverURL and publicServerURL have different paths, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Support saving relation objects, thanks to [Yuki Takeichi](https://github.com/yuki-takeichi)\n\n### 2.2.24\n\n#### New Features\n* LiveQuery: Bring your own adapter (#2902), thanks to [Florent Vilmart](https://github.com/flovilmart)\n* LiveQuery: Adds \"update\" operator to update a query subscription (#2935), thanks to [Florent Vilmart](https://github.com/flovilmart)\n\n#### Improvements\n* Better Postgres support, thanks to [Kulshekhar Kabra](https://github.com/kulshekhar)\n* Logs the function name when failing (#2963), thanks to [Michael Helvey](https://github.com/michaelhelvey)\n* CLI: forces closing the connections with SIGINT/SIGTERM (#2964), thanks to [Kulshekhar Kabra](https://github.com/kulshekhar)\n* Reduce the number of calls to the `_SCHEMA` table (#2912), thanks to [Steven Shipton](https://github.com/steven-supersolid)\n* LiveQuery: Support for Role ACL's, thanks to [Aaron Blondeau](https://github.com/aaron-blondeau-dose)\n\n#### Bug Fixes\n* Better support for checking application and client keys, thanks to [Steven Shipton](https://github.com/steven-supersolid)\n* Google OAuth, better support for android and web logins, thanks to [Florent Vilmart](https://github.com/flovilmart)\n\n### 2.2.23\n\n* Run liveQuery server from CLI with a different port, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Support for Postgres databaseURI, thanks to [Kulshekhar Kabra](https://github.com/kulshekhar)\n* Support for Postgres options, thanks to [Kulshekhar Kabra](https://github.com/kulshekhar)\n* Improved support for google login (id_token and access_token), thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Improvements with VKontakte login, thanks to [Eugene Antropov](https://github.com/antigp)\n* Improved support for `select` and `include`, thanks to [Florent Vilmart](https://github.com/flovilmart)\n\n#### Bug fixes\n\n* Fix error when updating installation with useMasterKey (#2888), thanks to [Jeremy Louie](https://github.com/JeremyPlease)\n* Fix bug affecting usage of multiple `notEqualTo`, thanks to [Jeremy Louie](https://github.com/JeremyPlease)\n* Improved support for null values in arrays, thanks to [Florent Vilmart](https://github.com/flovilmart)\n\n### 2.2.22\n\n* Minimum nodejs engine is now 4.5\n\n#### New Features\n* New: CLI for parse-live-query-server, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* New: Start parse-live-query-server for parse-server CLI, thanks to [Florent Vilmart](https://github.com/flovilmart)\n\n#### Bug fixes\n* Fix: Include with pointers are not conflicting with get CLP anymore, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Fix: Removes dependency on babel-polyfill, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Fix: Support nested select calls, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Fix: Use native column selection instead of runtime, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Fix: installationId header is properly used when updating `_Installation` objects, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Fix: don't crash parse-server on improperly formatted live-query messages, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Fix: Passwords are properly stripped out of logs, thanks to [Arthur Cinader](https://github.com/acinader)\n* Fix: Lookup for email in username if email is not set, thanks to [Florent Vilmart](https://github.com/flovilmart)\n\n### 2.2.21\n\n* Fix: Reverts removal of babel-polyfill\n\n### 2.2.20\n\n* New: Adds CloudCode handler for `beforeFind`, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* New: RedisCacheAdapter for syncing schema, role and user caches across servers, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* New: Latest master build available at `ParsePlatform/parse-server#latest`, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Fix: Better support for upgradeToRevocableSession with missing session token, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Fix: Removes babel-polyfill runtime dependency, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Fix: Cluster option now support a boolean value for automatically choosing the right number of processes, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Fix: Filenames now appear correctly, thanks to [Lama Chandrasena](https://github.com/lama-buddy)\n* Fix: `_acl` is properly updated, thanks to [Steven Shipton](https://github.com/steven-supersolid)\n\nOther fixes by [Mathias Rangel Wulff](https://github.com/mathiasrw)\n\n### 2.2.19\n\n* New: support for upgrading to revocable sessions, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* New: NullCacheAdapter for disabling caching, thanks to [Yuki Takeichi](https://github.com/yuki-takeichi)\n* New: Account lockout policy [#2601](https://github.com/ParsePlatform/parse-server/pull/2601), thanks to [Diwakar Cherukumilli](https://github.com/cherukumilli)\n* New: Jobs endpoint for defining and run jobs (no scheduling), thanks to [Florent Vilmart](https://github.com/flovilmart)\n* New: Add --cluster option to the CLI, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* New: Support for login with vk.com, thanks to [Nurdaulet Bolatov](https://github.com/nbolatov)\n* New: experimental support for postgres databases, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Fix: parse-server doesn't call next() after successful responses, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Fix: Nested objects are properly includeed with Pointer Permissions on, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Fix: null values in include calls are properly handled, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Fix: Schema validations now runs after beforeSave hooks, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Fix: usersname and passwords are properly type checked, thanks to [Bam Wang](https://github.com/bamwang)\n* Fix: logging in info log would log also in error log, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Fix: removes extaneous logging from ParseLiveQueryServer, thanks to [Flavio Torres](https://github.com/flavionegrao)\n* Fix: support for Range requests for files, thanks to [Brage G. Staven](https://github.com/Bragegs)\n\n### 2.2.18\n\n* Fix: Improve support for objects in push alert, thanks to [Antoine Lenoir](https://github.com/alenoir)\n* Fix; Prevent pointed from getting clobbered when they are changed in a beforeSave, thanks to [sud](https://github.com/sud80)\n* Fix: Improve support for \"Bytes\" type, thanks to [CongHoang](https://github.com/conghoang)\n* Fix: Better logging compatability with Parse.com, thanks to [Arthur Cinader](https://github.com/acinader)\n* New: Add Janrain Capture and Janrain Engage auth provider, thanks to [Andrew Lane](https://github.com/AndrewLane)\n* Improved: Include content length header in files response, thanks to [Steven Van Bael](https://github.com/vbsteven)\n* Improved: Support byte range header for files, thanks to [Brage G. Staven](https://github.com/Bragegs)\n* Improved: Validations for LinkedIn access_tokens, thanks to [Felix Dumit](https://github.com/felix-dumit)\n* Improved: Experimental postgres support, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Perf: Use native bcrypt implementation if available, thanks to [Florent Vilmart](https://github.com/flovilmart)\n\n\n### 2.2.17\n[Full Changelog](https://github.com/ParsePlatform/parse-server/compare/2.2.16...2.2.17)\n\n* Cloud code logs [\\#2370](https://github.com/ParsePlatform/parse-server/pull/2370) ([flovilmart](https://github.com/flovilmart))\n* Make sure \\_PushStatus operations are run in order [\\#2367](https://github.com/ParsePlatform/parse-server/pull/2367) ([flovilmart](https://github.com/flovilmart))\n* Typo fix for error message when can't ensure uniqueness of user email addresses [\\#2360](https://github.com/ParsePlatform/parse-server/pull/2360) ([AndrewLane](https://github.com/AndrewLane))\n* LiveQuery constrains matching fix [\\#2357](https://github.com/ParsePlatform/parse-server/pull/2357) ([simonas-notcat](https://github.com/simonas-notcat))\n* Fix typo in logging for commander parseConfigFile [\\#2352](https://github.com/ParsePlatform/parse-server/pull/2352) ([AndrewLane](https://github.com/AndrewLane))\n* Fix minor typos in test names [\\#2351](https://github.com/ParsePlatform/parse-server/pull/2351) ([acinader](https://github.com/acinader))\n* Makes sure we don't strip authData or session token from users using masterKey [\\#2348](https://github.com/ParsePlatform/parse-server/pull/2348) ([flovilmart](https://github.com/flovilmart))\n* Run coverage with istanbul [\\#2340](https://github.com/ParsePlatform/parse-server/pull/2340) ([flovilmart](https://github.com/flovilmart))\n* Run next\\(\\) after successfully sending data to the client [\\#2338](https://github.com/ParsePlatform/parse-server/pull/2338) ([blacha](https://github.com/blacha))\n* Cache all the mongodb/version folder [\\#2336](https://github.com/ParsePlatform/parse-server/pull/2336) ([flovilmart](https://github.com/flovilmart))\n* updates usage of setting: emailVerifyTokenValidityDuration [\\#2331](https://github.com/ParsePlatform/parse-server/pull/2331) ([cherukumilli](https://github.com/cherukumilli))\n* Update Mongodb client to 2.2.4 [\\#2329](https://github.com/ParsePlatform/parse-server/pull/2329) ([flovilmart](https://github.com/flovilmart))\n* Allow usage of analytics adapter [\\#2327](https://github.com/ParsePlatform/parse-server/pull/2327) ([deashay](https://github.com/deashay))\n* Fix flaky tests [\\#2324](https://github.com/ParsePlatform/parse-server/pull/2324) ([flovilmart](https://github.com/flovilmart))\n* don't serve null authData values [\\#2320](https://github.com/ParsePlatform/parse-server/pull/2320) ([yuzeh](https://github.com/yuzeh))\n* Fix null relation problem [\\#2319](https://github.com/ParsePlatform/parse-server/pull/2319) ([flovilmart](https://github.com/flovilmart))\n* Clear the connectionPromise upon close or error [\\#2314](https://github.com/ParsePlatform/parse-server/pull/2314) ([flovilmart](https://github.com/flovilmart))\n* Report validation errors with correct error code [\\#2299](https://github.com/ParsePlatform/parse-server/pull/2299) ([flovilmart](https://github.com/flovilmart))\n* Parses correctly Parse.Files and Dates when sent to Cloud Code Functions [\\#2297](https://github.com/ParsePlatform/parse-server/pull/2297) ([flovilmart](https://github.com/flovilmart))\n* Adding proper generic Not Implemented. [\\#2292](https://github.com/ParsePlatform/parse-server/pull/2292) ([vitaly-t](https://github.com/vitaly-t))\n* Adds schema caching capabilities \\(5s by default\\) [\\#2286](https://github.com/ParsePlatform/parse-server/pull/2286) ([flovilmart](https://github.com/flovilmart))\n* add digits oauth provider [\\#2284](https://github.com/ParsePlatform/parse-server/pull/2284) ([ranhsd](https://github.com/ranhsd))\n* Improve installations query [\\#2281](https://github.com/ParsePlatform/parse-server/pull/2281) ([flovilmart](https://github.com/flovilmart))\n* Adding request headers to cloud functions fixes \\#1461 [\\#2274](https://github.com/ParsePlatform/parse-server/pull/2274) ([blacha](https://github.com/blacha))\n* Creates a new sessionToken when updating password [\\#2266](https://github.com/ParsePlatform/parse-server/pull/2266) ([flovilmart](https://github.com/flovilmart))\n* Add Gitter chat link to the README. [\\#2264](https://github.com/ParsePlatform/parse-server/pull/2264) ([nlutsenko](https://github.com/nlutsenko))\n* Restores ability to include non pointer keys [\\#2263](https://github.com/ParsePlatform/parse-server/pull/2263) ([flovilmart](https://github.com/flovilmart))\n* Allow next middleware handle error in handleParseErrors [\\#2260](https://github.com/ParsePlatform/parse-server/pull/2260) ([mejcz](https://github.com/mejcz))\n* Exposes the ClientSDK infos if available [\\#2259](https://github.com/ParsePlatform/parse-server/pull/2259) ([flovilmart](https://github.com/flovilmart))\n* Adds support for multiple twitter auths options [\\#2256](https://github.com/ParsePlatform/parse-server/pull/2256) ([flovilmart](https://github.com/flovilmart))\n* validate\\_purchase fix for SANDBOX requests [\\#2253](https://github.com/ParsePlatform/parse-server/pull/2253) ([valeryvaskabovich](https://github.com/valeryvaskabovich))\n\n### 2.2.16\n\n* New: Expose InMemoryCacheAdapter publicly, thanks to [Steven Shipton](https://github.com/steven-supersolid)\n* New: Add ability to prevent login with unverified email, thanks to [Diwakar Cherukumilli](https://github.com/cherukumilli)\n* Improved: Better error message for incorrect type, thanks to [Andrew Lane](https://github.com/AndrewLane)\n* Improved: Better error message for permission denied, thanks to [Blayne Chard](https://github.com/blacha)\n* Improved: Update authData on login, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Improved: Ability to not check for old files on Parse.com, thanks to [OzgeAkin](https://github.com/OzgeAkin)\n* Fix: Issues with email adapter validation, thanks to [Tyler Brock](https://github.com/TylerBrock)\n* Fix: Issues with nested $or queries, thanks to [Florent Vilmart](https://github.com/flovilmart)\n\n### 2.2.15\n\n* Fix: Type in description for Parse.Error.INVALID_QUERY, thanks to [Andrew Lane](https://github.com/AndrewLane)\n* Improvement: Stop requiring verifyUserEmails for password reset functionality, thanks to [Tyler Brock](https://github.com/TylerBrock)\n* Improvement: Kill without validation, thanks to [Drew Gross](https://github.com/drew-gross)\n* Fix: Deleting a file does not delete from fs.files, thanks to [David Keita](https://github.com/maninga)\n* Fix: Postgres stoage adapter fix, thanks to [Vitaly Tomilov](https://github.com/vitaly-t)\n* Fix: Results invalid session when providing an invalid session token, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Fix: issue creating an anonymous user, thanks to [Hussam Moqhim](https://github.com/hmoqhim)\n* Fix: make http response serializable, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* New: Add postmark email adapter alternative [Glenn Reyes](https://github.com/glennreyes)\n\n### 2.2.14\n\n* Hotfix: Fix Parse.Cloud.HTTPResponse serialization\n\n### 2.2.13\n\n* Hotfix: Pin version of deepcopy\n\n### 2.2.12\n\n* New: Custom error codes in cloud code response.error, thanks to [Jeremy Pease](https://github.com/JeremyPlease)\n* Fix: Crash in beforeSave when response is not an object, thanks to [Tyler Brock](https://github.com/TylerBrock)\n* Fix: Allow \"get\" on installations\n* Fix: Fix overly restrictive Class Level Permissions, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Fix: Fix nested date parsing in Cloud Code, thanks to [Marco Cheung](https://github.com/Marco129)\n* Fix: Support very old file formats from Parse.com\n\n### 2.2.11\n\n* Security: Censor user password in logs, thanks to [Marco Cheung](https://github.com/Marco129)\n* New: Add PARSE_SERVER_LOGS_FOLDER env var for setting log folder, thanks to [KartikeyaRokde](https://github.com/KartikeyaRokde)\n* New: Webhook key support, thanks to [Tyler Brock](https://github.com/TylerBrock)\n* Perf: Add cache adapter and default caching of certain objects, thanks to [Blayne Chard](https://github.com/blacha)\n* Improvement: Better error messages for schema type mismatches, thanks to [Jeremy Pease](https://github.com/JeremyPlease)\n* Improvement: Better error messages for reset password emails\n* Improvement: Webhook key support in CLI, thanks to [Tyler Brock](https://github.com/TylerBrock)\n* Fix: Remove read only fields when using beforeSave, thanks to [Tyler Brock](https://github.com/TylerBrock)\n* Fix: Use content type provided by JS SDK, thanks to [Blayne Chard](https://github.com/blacha) and [Florent Vilmart](https://github.com/flovilmart)\n* Fix: Tell the dashboard the stored push data is available, thanks to [Jeremy Pease](https://github.com/JeremyPlease)\n* Fix: Add support for HTTP Basic Auth, thanks to [Hussam Moqhim](https://github.com/hmoqhim)\n* Fix: Support for MongoDB version 3.2.6, (note: do not use MongoDB 3.2 with migrated apps that still have traffic on Parse.com), thanks to [Tyler Brock](https://github.com/TylerBrock)\n* Fix: Prevent `pm2` from crashing when push notifications fail, thanks to [benishak](https://github.com/benishak)\n* Fix: Add full list of default _Installation fields, thanks to [Jeremy Pease](https://github.com/JeremyPlease)\n* Fix: Strip objectId out of hooks responses, thanks to [Tyler Brock](https://github.com/TylerBrock)\n* Fix: Fix external webhook response format, thanks to [Tyler Brock](https://github.com/TylerBrock)\n* Fix: Fix beforeSave when object is passed to `success`, thanks to [Madhav Bhagat](https://github.com/codebreach)\n* Fix: Remove use of deprecated APIs, thanks to [Emad Ehsan](https://github.com/emadehsan)\n* Fix: Crash when multiple Parse Servers on the same machine try to write to the same logs folder, thanks to [Steven Shipton](https://github.com/steven-supersolid)\n* Fix: Various issues with key names in `Parse.Object`s\n* Fix: Treat Bytes type properly\n* Fix: Caching bugs that caused writes by masterKey or other session token to not show up to users reading with a different session token\n* Fix: Pin mongo driver version, preventing a regression in version 2.1.19\n* Fix: Various issues with pointer fields not being treated properly\n* Fix: Issues with pointed getting un-fetched due to changes in beforeSave\n* Fix: Fixed crash when deleting classes that have CLPs\n\n### 2.2.10\n\n* Fix: Write legacy ACLs to Mongo so that clients that still go through Parse.com can read them, thanks to [Tyler Brock](https://github.com/TylerBrock) and [carmenlau](https://github.com/carmenlau)\n* Fix: Querying installations with limit = 0 and count = 1 now works, thanks to [ssk7833](https://github.com/ssk7833)\n* Fix: Return correct error when violating unique index, thanks to [Marco Cheung](https://github.com/Marco129)\n* Fix: Allow unsetting user's email, thanks to [Marco Cheung](https://github.com/Marco129)\n* New: Support for Node 6.1\n\n### 2.2.9\n\n* Fix: Fix a regression that caused Parse Server to crash when a null parameter is passed to a Cloud function\n\n### 2.2.8\n\n* New: Support for Pointer Permissions\n* New: Expose logger in Cloud Code\n* New: Option to revoke sessions on password reset\n* New: Option to expire inactive sessions\n* Perf: Improvements in ACL checking query\n* Fix: Issues when sending pushes to list of devices that contains invalid values\n* Fix: Issues caused by using babel-polyfill outside of Parse Server, but in the same express app\n* Fix: Remove creation of extra session tokens\n* Fix: Return authData when querying with master key\n* Fix: Bugs when deleting webhooks\n* Fix: Ignore _RevocableSession header, which might be sent by the JS SDK\n* Fix: Issues with querying via URL params\n* Fix: Properly encode \"Date\" parameters to cloud code functions\n\n\n### 2.2.7\n\n* Adds support for --verbose and verbose option when running ParseServer [\\#1414](https://github.com/ParsePlatform/parse-server/pull/1414) ([flovilmart](https://github.com/flovilmart))\n* Adds limit = 0 as a valid parameter for queries [\\#1493](https://github.com/ParsePlatform/parse-server/pull/1493) ([seijiakiyama](https://github.com/seijiakiyama))\n* Makes sure we preserve Installations when updating a token  \\(\\#1475\\) [\\#1486](https://github.com/ParsePlatform/parse-server/pull/1486) ([flovilmart](https://github.com/flovilmart))\n* Hotfix for tests [\\#1503](https://github.com/ParsePlatform/parse-server/pull/1503) ([flovilmart](https://github.com/flovilmart))\n* Enable logs [\\#1502](https://github.com/ParsePlatform/parse-server/pull/1502) ([drew-gross](https://github.com/drew-gross))\n* Do some triple equals for great justice [\\#1499](https://github.com/ParsePlatform/parse-server/pull/1499) ([TylerBrock](https://github.com/TylerBrock))\n* Apply credential stripping to all untransforms for \\_User [\\#1498](https://github.com/ParsePlatform/parse-server/pull/1498) ([TylerBrock](https://github.com/TylerBrock))\n* Checking if object has defined key for Pointer constraints in liveQuery [\\#1487](https://github.com/ParsePlatform/parse-server/pull/1487) ([simonas-notcat](https://github.com/simonas-notcat))\n* Remove collection prefix and default mongo URI [\\#1479](https://github.com/ParsePlatform/parse-server/pull/1479) ([drew-gross](https://github.com/drew-gross))\n* Store collection prefix in mongo adapter, and clean up adapter interface [\\#1472](https://github.com/ParsePlatform/parse-server/pull/1472) ([drew-gross](https://github.com/drew-gross))\n* Move field deletion logic into mongo adapter [\\#1471](https://github.com/ParsePlatform/parse-server/pull/1471) ([drew-gross](https://github.com/drew-gross))\n* Adds support for Long and Double mongodb types \\(fixes \\#1316\\) [\\#1470](https://github.com/ParsePlatform/parse-server/pull/1470) ([flovilmart](https://github.com/flovilmart))\n* Schema.js database agnostic [\\#1468](https://github.com/ParsePlatform/parse-server/pull/1468) ([flovilmart](https://github.com/flovilmart))\n* Remove console.log [\\#1465](https://github.com/ParsePlatform/parse-server/pull/1465) ([drew-gross](https://github.com/drew-gross))\n* Push status nits [\\#1462](https://github.com/ParsePlatform/parse-server/pull/1462) ([flovilmart](https://github.com/flovilmart))\n* Fixes \\#1444 [\\#1451](https://github.com/ParsePlatform/parse-server/pull/1451) ([flovilmart](https://github.com/flovilmart))\n* Removing sessionToken and authData from \\_User objects included in a query [\\#1450](https://github.com/ParsePlatform/parse-server/pull/1450) ([simonas-notcat](https://github.com/simonas-notcat))\n* Move mongo field type logic into mongoadapter [\\#1432](https://github.com/ParsePlatform/parse-server/pull/1432) ([drew-gross](https://github.com/drew-gross))\n* Prevents \\_User lock out when setting ACL on signup or afterwards [\\#1429](https://github.com/ParsePlatform/parse-server/pull/1429) ([flovilmart](https://github.com/flovilmart))\n* Update .travis.yml [\\#1428](https://github.com/ParsePlatform/parse-server/pull/1428) ([flovilmart](https://github.com/flovilmart))\n* Adds relation fields to objects [\\#1424](https://github.com/ParsePlatform/parse-server/pull/1424) ([flovilmart](https://github.com/flovilmart))\n* Update .travis.yml [\\#1423](https://github.com/ParsePlatform/parse-server/pull/1423) ([flovilmart](https://github.com/flovilmart))\n* Sets the defaultSchemas keys in the SchemaCollection [\\#1421](https://github.com/ParsePlatform/parse-server/pull/1421) ([flovilmart](https://github.com/flovilmart))\n* Fixes \\#1417 [\\#1420](https://github.com/ParsePlatform/parse-server/pull/1420) ([drew-gross](https://github.com/drew-gross))\n* Untransform should treat Array's as nested objects [\\#1416](https://github.com/ParsePlatform/parse-server/pull/1416) ([blacha](https://github.com/blacha))\n* Adds X-Parse-Push-Status-Id header [\\#1412](https://github.com/ParsePlatform/parse-server/pull/1412) ([flovilmart](https://github.com/flovilmart))\n* Schema format cleanup [\\#1407](https://github.com/ParsePlatform/parse-server/pull/1407) ([drew-gross](https://github.com/drew-gross))\n* Updates the publicServerURL option [\\#1397](https://github.com/ParsePlatform/parse-server/pull/1397) ([flovilmart](https://github.com/flovilmart))\n* Fix exception with non-expiring session tokens. [\\#1386](https://github.com/ParsePlatform/parse-server/pull/1386) ([0x18B2EE](https://github.com/0x18B2EE))\n* Move mongo schema format related logic into mongo adapter [\\#1385](https://github.com/ParsePlatform/parse-server/pull/1385) ([drew-gross](https://github.com/drew-gross))\n* WIP: Huge performance improvement on roles queries [\\#1383](https://github.com/ParsePlatform/parse-server/pull/1383) ([flovilmart](https://github.com/flovilmart))\n* Removes GCS Adapter from provided adapters [\\#1339](https://github.com/ParsePlatform/parse-server/pull/1339) ([flovilmart](https://github.com/flovilmart))\n* DBController refactoring [\\#1228](https://github.com/ParsePlatform/parse-server/pull/1228) ([flovilmart](https://github.com/flovilmart))\n* Spotify authentication [\\#1226](https://github.com/ParsePlatform/parse-server/pull/1226) ([1nput0utput](https://github.com/1nput0utput))\n* Expose DatabaseAdapter to simplify application tests [\\#1121](https://github.com/ParsePlatform/parse-server/pull/1121) ([steven-supersolid](https://github.com/steven-supersolid))\n\n### 2.2.6\n\n* Important Fix: Disables find on installation from clients [\\#1374](https://github.com/ParsePlatform/parse-server/pull/1374) ([flovilmart](https://github.com/flovilmart))\n* Adds missing options to the CLI [\\#1368](https://github.com/ParsePlatform/parse-server/pull/1368) ([flovilmart](https://github.com/flovilmart))\n* Removes only master on travis [\\#1367](https://github.com/ParsePlatform/parse-server/pull/1367) ([flovilmart](https://github.com/flovilmart))\n* Auth.\\_loadRoles should not query the same role twice. [\\#1366](https://github.com/ParsePlatform/parse-server/pull/1366) ([blacha](https://github.com/blacha))\n\n### 2.2.5\n\n* Improves config loading and tests [\\#1363](https://github.com/ParsePlatform/parse-server/pull/1363) ([flovilmart](https://github.com/flovilmart))\n* Adds travis configuration to deploy NPM on new version tags [\\#1361](https://github.com/ParsePlatform/parse-server/pull/1361) ([gfosco](https://github.com/gfosco))\n* Inject the default schemas properties when loading it [\\#1357](https://github.com/ParsePlatform/parse-server/pull/1357) ([flovilmart](https://github.com/flovilmart))\n* Adds console transport when testing with VERBOSE=1 [\\#1351](https://github.com/ParsePlatform/parse-server/pull/1351) ([flovilmart](https://github.com/flovilmart))\n* Make notEqual work on relations  [\\#1350](https://github.com/ParsePlatform/parse-server/pull/1350) ([flovilmart](https://github.com/flovilmart))\n* Accept only bool for $exists in LiveQuery [\\#1315](https://github.com/ParsePlatform/parse-server/pull/1315) ([drew-gross](https://github.com/drew-gross))\n* Adds more options when using CLI/config [\\#1305](https://github.com/ParsePlatform/parse-server/pull/1305) ([flovilmart](https://github.com/flovilmart))\n* Update error message [\\#1297](https://github.com/ParsePlatform/parse-server/pull/1297) ([drew-gross](https://github.com/drew-gross))\n* Properly let masterKey add fields [\\#1291](https://github.com/ParsePlatform/parse-server/pull/1291) ([flovilmart](https://github.com/flovilmart))\n* Point to \\#1271 as how to write a good issue report [\\#1290](https://github.com/ParsePlatform/parse-server/pull/1290) ([drew-gross](https://github.com/drew-gross))\n* Adds ability to override mount with publicServerURL for production uses [\\#1287](https://github.com/ParsePlatform/parse-server/pull/1287) ([flovilmart](https://github.com/flovilmart))\n* Single object queries to use include and keys [\\#1280](https://github.com/ParsePlatform/parse-server/pull/1280) ([jeremyjackson89](https://github.com/jeremyjackson89))\n* Improves report for Push error in logs and \\_PushStatus [\\#1269](https://github.com/ParsePlatform/parse-server/pull/1269) ([flovilmart](https://github.com/flovilmart))\n* Removes all stdout/err logs while testing [\\#1268](https://github.com/ParsePlatform/parse-server/pull/1268) ([flovilmart](https://github.com/flovilmart))\n* Matching queries with doesNotExist constraint [\\#1250](https://github.com/ParsePlatform/parse-server/pull/1250) ([andrecardoso](https://github.com/andrecardoso))\n* Added session length option for session tokens to server configuration [\\#997](https://github.com/ParsePlatform/parse-server/pull/997) ([Kenishi](https://github.com/Kenishi))\n* Regression test for \\#1259 [\\#1286](https://github.com/ParsePlatform/parse-server/pull/1286) ([drew-gross](https://github.com/drew-gross))\n* Regression test for \\#871 [\\#1283](https://github.com/ParsePlatform/parse-server/pull/1283) ([drew-gross](https://github.com/drew-gross))\n* Add a test to repro \\#701 [\\#1281](https://github.com/ParsePlatform/parse-server/pull/1281) ([drew-gross](https://github.com/drew-gross))\n* Fix for \\#1334: using relative cloud code files broken  [\\#1353](https://github.com/ParsePlatform/parse-server/pull/1353) ([airdrummingfool](https://github.com/airdrummingfool))\n* Fix Issue/1288 [\\#1346](https://github.com/ParsePlatform/parse-server/pull/1346) ([flovilmart](https://github.com/flovilmart))\n* Fixes \\#1271 [\\#1295](https://github.com/ParsePlatform/parse-server/pull/1295) ([drew-gross](https://github.com/drew-gross))\n* Fixes issue \\#1302 [\\#1314](https://github.com/ParsePlatform/parse-server/pull/1314) ([flovilmart](https://github.com/flovilmart))\n* Fixes bug related to include in queries [\\#1312](https://github.com/ParsePlatform/parse-server/pull/1312) ([flovilmart](https://github.com/flovilmart))\n\n\n### 2.2.4\n\n* Hotfix: fixed imports issue for S3Adapter, GCSAdapter, FileSystemAdapter [\\#1263](https://github.com/ParsePlatform/parse-server/pull/1263) ([drew-gross](https://github.com/drew-gross)\n* Fix: Clean null authData values on _User update [\\#1199](https://github.com/ParsePlatform/parse-server/pull/1199) ([yuzeh](https://github.com/yuzeh))\n\n### 2.2.3\n\n* Fixed bug with invalid email verification link on email update. [\\#1253](https://github.com/ParsePlatform/parse-server/pull/1253) ([kzielonka](https://github.com/kzielonka))\n* Badge update supports increment as well as Increment [\\#1248](https://github.com/ParsePlatform/parse-server/pull/1248) ([flovilmart](https://github.com/flovilmart))\n* Config/Push Tested with the dashboard. [\\#1235](https://github.com/ParsePlatform/parse-server/pull/1235) ([drew-gross](https://github.com/drew-gross))\n* Better logging with winston [\\#1234](https://github.com/ParsePlatform/parse-server/pull/1234) ([flovilmart](https://github.com/flovilmart))\n* Make GlobalConfig work like parse.com [\\#1210](https://github.com/ParsePlatform/parse-server/pull/1210) ([framp](https://github.com/framp))\n* Improve flattening of results from pushAdapter [\\#1204](https://github.com/ParsePlatform/parse-server/pull/1204) ([flovilmart](https://github.com/flovilmart))\n* Push adapters are provided by external packages [\\#1195](https://github.com/ParsePlatform/parse-server/pull/1195) ([flovilmart](https://github.com/flovilmart))\n* Fix flaky test [\\#1188](https://github.com/ParsePlatform/parse-server/pull/1188) ([drew-gross](https://github.com/drew-gross))\n* Fixes problem affecting finding array pointers [\\#1185](https://github.com/ParsePlatform/parse-server/pull/1185) ([flovilmart](https://github.com/flovilmart))\n* Moves Files adapters to external packages [\\#1172](https://github.com/ParsePlatform/parse-server/pull/1172) ([flovilmart](https://github.com/flovilmart))\n* Mark push as enabled in serverInfo endpoint [\\#1164](https://github.com/ParsePlatform/parse-server/pull/1164) ([drew-gross](https://github.com/drew-gross))\n* Document email adapter [\\#1144](https://github.com/ParsePlatform/parse-server/pull/1144) ([drew-gross](https://github.com/drew-gross))\n* Reset password fix [\\#1133](https://github.com/ParsePlatform/parse-server/pull/1133) ([carmenlau](https://github.com/carmenlau))\n\n### 2.2.2\n\n* Important Fix: Mounts createLiveQueryServer, fix babel induced problem [\\#1153](https://github.com/ParsePlatform/parse-server/pull/1153) (flovilmart)\n* Move ParseServer to it's own file [\\#1166](https://github.com/ParsePlatform/parse-server/pull/1166) (flovilmart)\n* Update README.md * remove deploy buttons * replace with community links [\\#1139](https://github.com/ParsePlatform/parse-server/pull/1139) (drew-gross)\n* Adds bootstrap.sh [\\#1138](https://github.com/ParsePlatform/parse-server/pull/1138) (flovilmart)\n* Fix: Do not override username [\\#1142](https://github.com/ParsePlatform/parse-server/pull/1142) (flovilmart)\n* Fix: Add pushId back to GCM payload [\\#1168](https://github.com/ParsePlatform/parse-server/pull/1168) (wangmengyan95)\n\n### 2.2.1\n\n* New: Add FileSystemAdapter file adapter [\\#1098](https://github.com/ParsePlatform/parse-server/pull/1098) (dtsolis)\n* New: Enabled CLP editing [\\#1128](https://github.com/ParsePlatform/parse-server/pull/1128) (drew-gross)\n* Improvement: Reduces the number of connections to mongo created [\\#1111](https://github.com/ParsePlatform/parse-server/pull/1111) (flovilmart)\n* Improvement: Make ParseServer a class [\\#980](https://github.com/ParsePlatform/parse-server/pull/980) (flovilmart)\n* Fix: Adds support for plain object in $add, $addUnique, $remove [\\#1114](https://github.com/ParsePlatform/parse-server/pull/1114) (flovilmart)\n* Fix: Generates default CLP, freezes objects [\\#1132](https://github.com/ParsePlatform/parse-server/pull/1132) (flovilmart)\n* Fix: Properly sets installationId on creating session with 3rd party auth [\\#1110](https://github.com/ParsePlatform/parse-server/pull/1110) (flovilmart)\n\n### 2.2.0\n\n* New Feature: Real-time functionality with Live Queries! [\\#1092](https://github.com/ParsePlatform/parse-server/pull/1092) (wangmengyan95)\n* Improvement: Push Status API [\\#1004](https://github.com/ParsePlatform/parse-server/pull/1004) (flovilmart)\n* Improvement: Allow client operations on Roles [\\#1068](https://github.com/ParsePlatform/parse-server/pull/1068) (flovilmart)\n* Improvement: Add URI encoding to mongo auth parameters [\\#986](https://github.com/ParsePlatform/parse-server/pull/986) (bgw)\n* Improvement: Adds support for apps key in config file, but only support single app for now [\\#979](https://github.com/ParsePlatform/parse-server/pull/979) (flovilmart)\n* Documentation: Getting Started and Configuring Parse Server [\\#988](https://github.com/ParsePlatform/parse-server/pull/988) (hramos)\n* Fix: Various edge cases with REST API [\\#1066](https://github.com/ParsePlatform/parse-server/pull/1066) (flovilmart)\n* Fix: Makes sure the location in results has the proper objectId [\\#1065](https://github.com/ParsePlatform/parse-server/pull/1065) (flovilmart)\n* Fix: Third-party auth is properly removed when unlinked [\\#1081](https://github.com/ParsePlatform/parse-server/pull/1081) (flovilmart)\n* Fix: Clear the session-user cache when changing \\_User objects [\\#1072](https://github.com/ParsePlatform/parse-server/pull/1072) (gfosco)\n* Fix: Bug related to subqueries on unfetched objects [\\#1046](https://github.com/ParsePlatform/parse-server/pull/1046) (flovilmart)\n* Fix: Properly urlencode parameters for email validation and password reset [\\#1001](https://github.com/ParsePlatform/parse-server/pull/1001) (flovilmart)\n* Fix: Better sanitization/decoding of object data for afterSave triggers [\\#992](https://github.com/ParsePlatform/parse-server/pull/992) (flovilmart)\n* Fix: Changes default encoding for httpRequest [\\#892](https://github.com/ParsePlatform/parse-server/pull/892) (flovilmart)\n\n### 2.1.6\n\n* Improvement: Full query support for badge Increment \\(\\#931\\) [\\#983](https://github.com/ParsePlatform/parse-server/pull/983) (flovilmart)\n* Improvement: Shutdown standalone parse server gracefully [\\#958](https://github.com/ParsePlatform/parse-server/pull/958) (raulr)\n* Improvement: Add database options to ParseServer constructor and pass to MongoStorageAdapter [\\#956](https://github.com/ParsePlatform/parse-server/pull/956) (steven-supersolid)\n* Improvement: AuthData logic refactor [\\#952](https://github.com/ParsePlatform/parse-server/pull/952) (flovilmart)\n* Improvement: Changed FileLoggerAdapterSpec to fail gracefully on Windows [\\#946](https://github.com/ParsePlatform/parse-server/pull/946) (aneeshd16)\n* Improvement: Add new schema collection type and replace all usages of direct mongo collection for schema operations. [\\#943](https://github.com/ParsePlatform/parse-server/pull/943) (nlutsenko)\n* Improvement: Adds CLP API to Schema router [\\#898](https://github.com/ParsePlatform/parse-server/pull/898) (flovilmart)\n* Fix: Cleans up authData null keys on login for android crash [\\#978](https://github.com/ParsePlatform/parse-server/pull/978) (flovilmart)\n* Fix: Do master query for before/afterSaveHook [\\#959](https://github.com/ParsePlatform/parse-server/pull/959) (wangmengyan95)\n* Fix: re-add shebang [\\#944](https://github.com/ParsePlatform/parse-server/pull/944) (flovilmart)\n* Fix: Added test command for Windows support [\\#886](https://github.com/ParsePlatform/parse-server/pull/886) (aneeshd16)\n\n### 2.1.5\n\n* New: FileAdapter for Google Cloud Storage [\\#708](https://github.com/ParsePlatform/parse-server/pull/708) (mcdonamp)\n* Improvement: Minimize extra schema queries in some scenarios. [\\#919](https://github.com/ParsePlatform/parse-server/pull/919) (Marco129)\n* Improvement: Move DatabaseController and Schema fully to adaptive mongo collection. [\\#909](https://github.com/ParsePlatform/parse-server/pull/909) (nlutsenko)\n* Improvement: Cleanup PushController/PushRouter, remove raw mongo collection access. [\\#903](https://github.com/ParsePlatform/parse-server/pull/903) (nlutsenko)\n* Improvement: Increment badge the right way [\\#902](https://github.com/ParsePlatform/parse-server/pull/902) (flovilmart)\n* Improvement: Migrate ParseGlobalConfig to new database storage API. [\\#901](https://github.com/ParsePlatform/parse-server/pull/901) (nlutsenko)\n* Improvement: Improve delete flow for non-existent \\_Join collection [\\#881](https://github.com/ParsePlatform/parse-server/pull/881) (Marco129)\n* Improvement: Adding a role scenario test for issue 827 [\\#878](https://github.com/ParsePlatform/parse-server/pull/878) (gfosco)\n* Improvement: Test empty authData block on login for \\#413 [\\#863](https://github.com/ParsePlatform/parse-server/pull/863) (gfosco)\n* Improvement: Modified the npm dev script to support Windows [\\#846](https://github.com/ParsePlatform/parse-server/pull/846) (aneeshd16)\n* Improvement: Move HooksController to use MongoCollection instead of direct Mongo access. [\\#844](https://github.com/ParsePlatform/parse-server/pull/844) (nlutsenko)\n* Improvement: Adds public\\_html and views for packaging [\\#839](https://github.com/ParsePlatform/parse-server/pull/839) (flovilmart)\n* Improvement: Better support for windows builds [\\#831](https://github.com/ParsePlatform/parse-server/pull/831) (flovilmart)\n* Improvement: Convert Schema.js to ES6 class. [\\#826](https://github.com/ParsePlatform/parse-server/pull/826) (nlutsenko)\n* Improvement: Remove duplicated instructions [\\#816](https://github.com/ParsePlatform/parse-server/pull/816) (hramos)\n* Improvement: Completely migrate SchemasRouter to new MongoCollection API. [\\#794](https://github.com/ParsePlatform/parse-server/pull/794) (nlutsenko)\n* Fix: Do not require where clause in $dontSelect condition on queries. [\\#925](https://github.com/ParsePlatform/parse-server/pull/925) (nlutsenko)\n* Fix: Make sure that ACLs propagate to before/after save hooks. [\\#924](https://github.com/ParsePlatform/parse-server/pull/924) (nlutsenko)\n* Fix: Support params option in Parse.Cloud.httpRequest. [\\#912](https://github.com/ParsePlatform/parse-server/pull/912) (carmenlau)\n* Fix: Fix flaky Parse.GeoPoint test. [\\#908](https://github.com/ParsePlatform/parse-server/pull/908) (nlutsenko)\n* Fix: Handle legacy \\_client\\_permissions key in \\_SCHEMA. [\\#900](https://github.com/ParsePlatform/parse-server/pull/900) (drew-gross)\n* Fix: Fixes bug when querying equalTo on objectId and relation [\\#887](https://github.com/ParsePlatform/parse-server/pull/887) (flovilmart)\n* Fix: Allow crossdomain on filesRouter [\\#876](https://github.com/ParsePlatform/parse-server/pull/876) (flovilmart)\n* Fix: Remove limit when counting results. [\\#867](https://github.com/ParsePlatform/parse-server/pull/867) (gfosco)\n* Fix: beforeSave changes should propagate to the response [\\#865](https://github.com/ParsePlatform/parse-server/pull/865) (gfosco)\n* Fix: Delete relation field when \\_Join collection not exist [\\#864](https://github.com/ParsePlatform/parse-server/pull/864) (Marco129)\n* Fix: Related query on non-existing column [\\#861](https://github.com/ParsePlatform/parse-server/pull/861) (gfosco)\n* Fix: Update markdown in .github/ISSUE\\_TEMPLATE.md [\\#859](https://github.com/ParsePlatform/parse-server/pull/859) (igorshubovych)\n* Fix: Issue with creating wrong \\_Session for Facebook login [\\#857](https://github.com/ParsePlatform/parse-server/pull/857) (tobernguyen)\n* Fix: Leak warnings in tests, use mongodb-runner from node\\_modules [\\#843](https://github.com/ParsePlatform/parse-server/pull/843) (drew-gross)\n* Fix: Reversed roles lookup [\\#841](https://github.com/ParsePlatform/parse-server/pull/841) (flovilmart)\n* Fix: Improves loading of Push Adapter, fix loading of S3Adapter [\\#833](https://github.com/ParsePlatform/parse-server/pull/833) (flovilmart)\n* Fix: Add field to system schema [\\#828](https://github.com/ParsePlatform/parse-server/pull/828) (Marco129)\n\n### 2.1.4\n\n* New: serverInfo endpoint that returns server version and info about the server's features\n* Improvement: Add support for badges on iOS\n* Improvement: Improve failure handling in cloud code http requests\n* Improvement: Add support for queries on pointers and relations\n* Improvement: Add support for multiple $in clauses in a query\n* Improvement: Add allowClientClassCreation config option\n* Improvement: Allow atomically setting subdocument keys\n* Improvement: Allow arbitrarily deeply nested roles\n* Improvement: Set proper content-type in S3 File Adapter\n* Improvement: S3 adapter auto-creates buckets\n* Improvement: Better error messages for many errors\n* Performance: Improved algorithm for validating client keys\n* Experimental: Parse Hooks and Hooks API\n* Experimental: Email verification and password reset emails\n* Experimental: Improve compatability of logs feature with Parse.com\n* Fix: Fix for attempting to delete missing classes via schemas API\n* Fix: Allow creation of system classes via schemas API\n* Fix: Allow missing where cause in $select\n* Fix: Improve handling of invalid object ids\n* Fix: Replace query overwriting existing query\n* Fix: Propagate installationId in cloud code triggers\n* Fix: Session expiresAt is now a Date instead of a string\n* Fix: Fix count queries\n* Fix: Disallow _Role objects without names or without ACL\n* Fix: Better handling of invalid types submitted\n* Fix: beforeSave will not be triggered for attempts to save with invalid authData\n* Fix: Fix duplicate device token issues on Android\n* Fix: Allow empty authData on signup\n* Fix: Allow Master Key Headers (CORS)\n* Fix: Fix bugs if JavaScript key was not provided in server configuration\n* Fix: Parse Files on objects can now be stored without URLs\n* Fix: allow both objectId or installationId when modifying installation\n* Fix: Command line works better when not given options\n\n### 2.1.3\n\n* Feature: Add initial support for in-app purchases\n* Feature: Better error messages when attempting to run the server on a port that is already in use or without a server URL\n* Feature: Allow customization of max file size\n* Performance: Faster saves if not using beforeSave triggers\n* Fix: Send session token in response to current user endpoint\n* Fix: Remove triggers for _Session collection\n* Fix: Improve compatability of cloud code beforeSave hook for newly created object\n* Fix: ACL creation for master key only objects\n* Fix: Allow uploading files without Content-Type\n* Fix: Add features to http request to match Parse.com\n* Fix: Bugs in development script when running from locations other than project root\n* Fix: Can pass query constraints in URL\n* Fix: Objects with legacy \"_tombstone\" key now don't cause issues.\n* Fix: Allow nested keys in objects to begin with underscores\n* Fix: Allow correct headers for CORS\n\n### 2.1.2\n\n* Change: The S3 file adapter constructor requires a bucket name\n* Fix: Parse Query should throw if improperly encoded\n* Fix: Issue where roles were not used in some requests\n* Fix: serverURL will no longer default to api.parse.com/1\n\n### 2.1.1\n\n* Experimental: Schemas API support for DELETE operations\n* Fix: Session token issue fetching Users\n* Fix: Facebook auth validation\n* Fix: Invalid error when deleting missing session\n\n### 2.1.0\n\n* Feature: Support for additional OAuth providers\n* Feature: Ability to implement custom OAuth providers\n* Feature: Support for deleting Parse Files\n* Feature: Allow querying roles\n* Feature: Support for logs, extensible via Log Adapter\n* Feature: New Push Adapter for sending push notifications through OneSignal\n* Feature: Tighter default security for Users\n* Feature: Pass parameters to cloud code in query string\n* Feature: Disable anonymous users via configuration.\n* Experimental: Schemas API support for PUT operations\n* Fix: Prevent installation ID from being added to User\n* Fix: Becoming a user works properly with sessions\n* Fix: Including multiple object when some object are unavailable will get all the objects that are available\n* Fix: Invalid URL for Parse Files\n* Fix: Making a query without a limit now returns 100 results\n* Fix: Expose installation id in cloud code\n* Fix: Correct username for Anonymous users\n* Fix: Session token issue after fetching user\n* Fix: Issues during install process\n* Fix: Issue with Unity SDK sending _noBody\n\n### 2.0.8\n\n* Add: support for Android and iOS push notifications\n* Experimental: cloud code validation hooks (can mark as non-experimental after we have docs)\n* Experimental: support for schemas API (GET and POST only)\n* Experimental: support for Parse Config (GET and POST only)\n* Fix: Querying objects with equality constraint on array column\n* Fix: User logout will remove session token\n* Fix: Various files related bugs\n* Fix: Force minimum node version 4.3 due to security issues in earlier version\n* Performance Improvement: Improved caching\n", "// This is a port of the test suite:\n// hungry/js/test/parse_query_test.js\n//\n// Some new tests are added.\n'use strict';\n\nconst Parse = require('parse/node');\nconst request = require('../lib/request');\n\nconst masterKeyHeaders = {\n  'X-Parse-Application-Id': 'test',\n  'X-Parse-Rest-API-Key': 'test',\n  'X-Parse-Master-Key': 'test',\n  'Content-Type': 'application/json',\n};\n\nconst masterKeyOptions = {\n  headers: masterKeyHeaders,\n};\n\nconst BoxedNumber = Parse.Object.extend({\n  className: 'BoxedNumber',\n});\n\ndescribe('Parse.Query testing', () => {\n  it('basic query', function (done) {\n    const baz = new TestObject({ foo: 'baz' });\n    const qux = new TestObject({ foo: 'qux' });\n    Parse.Object.saveAll([baz, qux]).then(function () {\n      const query = new Parse.Query(TestObject);\n      query.equalTo('foo', 'baz');\n      query.find().then(function (results) {\n        equal(results.length, 1);\n        equal(results[0].get('foo'), 'baz');\n        done();\n      });\n    });\n  });\n\n  it('searching for null', function (done) {\n    const baz = new TestObject({ foo: null });\n    const qux = new TestObject({ foo: 'qux' });\n    const qux2 = new TestObject({});\n    Parse.Object.saveAll([baz, qux, qux2]).then(function () {\n      const query = new Parse.Query(TestObject);\n      query.equalTo('foo', null);\n      query.find().then(function (results) {\n        equal(results.length, 2);\n        qux.set('foo', null);\n        qux.save().then(function () {\n          query.find().then(function (results) {\n            equal(results.length, 3);\n            done();\n          });\n        });\n      });\n    });\n  });\n\n  it('searching for not null', function (done) {\n    const baz = new TestObject({ foo: null });\n    const qux = new TestObject({ foo: 'qux' });\n    const qux2 = new TestObject({});\n    Parse.Object.saveAll([baz, qux, qux2]).then(function () {\n      const query = new Parse.Query(TestObject);\n      query.notEqualTo('foo', null);\n      query.find().then(function (results) {\n        equal(results.length, 1);\n        qux.set('foo', null);\n        qux.save().then(function () {\n          query.find().then(function (results) {\n            equal(results.length, 0);\n            done();\n          });\n        });\n      });\n    });\n  });\n\n  it('notEqualTo with Relation is working', function (done) {\n    const user = new Parse.User();\n    user.setPassword('asdf');\n    user.setUsername('zxcv');\n\n    const user1 = new Parse.User();\n    user1.setPassword('asdf');\n    user1.setUsername('qwerty');\n\n    const user2 = new Parse.User();\n    user2.setPassword('asdf');\n    user2.setUsername('asdf');\n\n    const Cake = Parse.Object.extend('Cake');\n    const cake1 = new Cake();\n    const cake2 = new Cake();\n    const cake3 = new Cake();\n\n    user\n      .signUp()\n      .then(function () {\n        return user1.signUp();\n      })\n      .then(function () {\n        return user2.signUp();\n      })\n      .then(function () {\n        const relLike1 = cake1.relation('liker');\n        relLike1.add([user, user1]);\n\n        const relDislike1 = cake1.relation('hater');\n        relDislike1.add(user2);\n\n        return cake1.save();\n      })\n      .then(function () {\n        const rellike2 = cake2.relation('liker');\n        rellike2.add([user, user1]);\n\n        const relDislike2 = cake2.relation('hater');\n        relDislike2.add(user2);\n\n        const relSomething = cake2.relation('something');\n        relSomething.add(user);\n\n        return cake2.save();\n      })\n      .then(function () {\n        const rellike3 = cake3.relation('liker');\n        rellike3.add(user);\n\n        const relDislike3 = cake3.relation('hater');\n        relDislike3.add([user1, user2]);\n        return cake3.save();\n      })\n      .then(function () {\n        const query = new Parse.Query(Cake);\n        // User2 likes nothing so we should receive 0\n        query.equalTo('liker', user2);\n        return query.find().then(function (results) {\n          equal(results.length, 0);\n        });\n      })\n      .then(function () {\n        const query = new Parse.Query(Cake);\n        // User1 likes two of three cakes\n        query.equalTo('liker', user1);\n        return query.find().then(function (results) {\n          // It should return 2 -> cake 1 and cake 2\n          equal(results.length, 2);\n        });\n      })\n      .then(function () {\n        const query = new Parse.Query(Cake);\n        // We want to know which cake the user1 is not appreciating -> cake3\n        query.notEqualTo('liker', user1);\n        return query.find().then(function (results) {\n          // Should return 1 -> the cake 3\n          equal(results.length, 1);\n        });\n      })\n      .then(function () {\n        const query = new Parse.Query(Cake);\n        // User2 is a hater of everything so we should receive 0\n        query.notEqualTo('hater', user2);\n        return query.find().then(function (results) {\n          equal(results.length, 0);\n        });\n      })\n      .then(function () {\n        const query = new Parse.Query(Cake);\n        // Only cake3 is liked by user\n        query.notContainedIn('liker', [user1]);\n        return query.find().then(function (results) {\n          equal(results.length, 1);\n        });\n      })\n      .then(function () {\n        const query = new Parse.Query(Cake);\n        // All the users\n        query.containedIn('liker', [user, user1, user2]);\n        // Exclude user 1\n        query.notEqualTo('liker', user1);\n        // Only cake3 is liked only by user1\n        return query.find().then(function (results) {\n          equal(results.length, 1);\n          const cake = results[0];\n          expect(cake.id).toBe(cake3.id);\n        });\n      })\n      .then(function () {\n        const query = new Parse.Query(Cake);\n        // Exclude user1\n        query.notEqualTo('liker', user1);\n        // Only cake1\n        query.equalTo('objectId', cake1.id);\n        // user1 likes cake1 so this should return no results\n        return query.find().then(function (results) {\n          equal(results.length, 0);\n        });\n      })\n      .then(function () {\n        const query = new Parse.Query(Cake);\n        query.notEqualTo('hater', user2);\n        query.notEqualTo('liker', user2);\n        // user2 doesn't like any cake so this should be 0\n        return query.find().then(function (results) {\n          equal(results.length, 0);\n        });\n      })\n      .then(function () {\n        const query = new Parse.Query(Cake);\n        query.equalTo('hater', user);\n        query.equalTo('liker', user);\n        // user doesn't hate any cake so this should be 0\n        return query.find().then(function (results) {\n          equal(results.length, 0);\n        });\n      })\n      .then(function () {\n        const query = new Parse.Query(Cake);\n        query.equalTo('hater', null);\n        query.equalTo('liker', null);\n        // user doesn't hate any cake so this should be 0\n        return query.find().then(function (results) {\n          equal(results.length, 0);\n        });\n      })\n      .then(function () {\n        const query = new Parse.Query(Cake);\n        query.equalTo('something', null);\n        // user doesn't hate any cake so this should be 0\n        return query.find().then(function (results) {\n          equal(results.length, 0);\n        });\n      })\n      .then(function () {\n        done();\n      })\n      .catch(err => {\n        jfail(err);\n        done();\n      });\n  });\n\n  it('query notContainedIn on empty array', async () => {\n    const object = new TestObject();\n    object.set('value', 100);\n    await object.save();\n\n    const query = new Parse.Query(TestObject);\n    query.notContainedIn('value', []);\n\n    const results = await query.find();\n    equal(results.length, 1);\n  });\n\n  it('query containedIn on empty array', async () => {\n    const object = new TestObject();\n    object.set('value', 100);\n    await object.save();\n\n    const query = new Parse.Query(TestObject);\n    query.containedIn('value', []);\n\n    const results = await query.find();\n    equal(results.length, 0);\n  });\n\n  it('query with limit', function (done) {\n    const baz = new TestObject({ foo: 'baz' });\n    const qux = new TestObject({ foo: 'qux' });\n    Parse.Object.saveAll([baz, qux]).then(function () {\n      const query = new Parse.Query(TestObject);\n      query.limit(1);\n      query.find().then(function (results) {\n        equal(results.length, 1);\n        done();\n      });\n    });\n  });\n\n  it('query with limit equal to maxlimit', async () => {\n    const baz = new TestObject({ foo: 'baz' });\n    const qux = new TestObject({ foo: 'qux' });\n    await reconfigureServer({ maxLimit: 1 });\n    await Parse.Object.saveAll([baz, qux]);\n    const query = new Parse.Query(TestObject);\n    query.limit(1);\n    const results = await query.find();\n    equal(results.length, 1);\n  });\n\n  it('query with limit exceeding maxlimit', async () => {\n    const baz = new TestObject({ foo: 'baz' });\n    const qux = new TestObject({ foo: 'qux' });\n    await reconfigureServer({ maxLimit: 1 });\n    await Parse.Object.saveAll([baz, qux]);\n    const query = new Parse.Query(TestObject);\n    query.limit(2);\n    const results = await query.find();\n    equal(results.length, 1);\n  });\n\n  it('containedIn object array queries', function (done) {\n    const messageList = [];\n    for (let i = 0; i < 4; ++i) {\n      const message = new TestObject({});\n      if (i > 0) {\n        message.set('prior', messageList[i - 1]);\n      }\n      messageList.push(message);\n    }\n\n    Parse.Object.saveAll(messageList).then(\n      function () {\n        equal(messageList.length, 4);\n\n        const inList = [];\n        inList.push(messageList[0]);\n        inList.push(messageList[2]);\n\n        const query = new Parse.Query(TestObject);\n        query.containedIn('prior', inList);\n        query.find().then(\n          function (results) {\n            equal(results.length, 2);\n            done();\n          },\n          function (e) {\n            jfail(e);\n            done();\n          }\n        );\n      },\n      e => {\n        jfail(e);\n        done();\n      }\n    );\n  });\n\n  it('containedIn null array', done => {\n    const emails = ['contact@xyz.com', 'contact@zyx.com', null];\n    const user = new Parse.User();\n    user.setUsername(emails[0]);\n    user.setPassword('asdf');\n    user\n      .signUp()\n      .then(() => {\n        const query = new Parse.Query(Parse.User);\n        query.containedIn('username', emails);\n        return query.find({ useMasterKey: true });\n      })\n      .then(results => {\n        equal(results.length, 1);\n        done();\n      }, done.fail);\n  });\n\n  it('nested equalTo string with single quote', async () => {\n    const obj = new TestObject({ nested: { foo: \"single'quote\" } });\n    await obj.save();\n    const query = new Parse.Query(TestObject);\n    query.equalTo('nested.foo', \"single'quote\");\n    const result = await query.get(obj.id);\n    equal(result.get('nested').foo, \"single'quote\");\n  });\n\n  it('nested containedIn string with single quote', async () => {\n    const obj = new TestObject({ nested: { foo: [\"single'quote\"] } });\n    await obj.save();\n    const query = new Parse.Query(TestObject);\n    query.containedIn('nested.foo', [\"single'quote\"]);\n    const result = await query.get(obj.id);\n    equal(result.get('nested').foo[0], \"single'quote\");\n  });\n\n  it('nested containedIn string', done => {\n    const sender1 = { group: ['A', 'B'] };\n    const sender2 = { group: ['A', 'C'] };\n    const sender3 = { group: ['B', 'C'] };\n    const obj1 = new TestObject({ sender: sender1 });\n    const obj2 = new TestObject({ sender: sender2 });\n    const obj3 = new TestObject({ sender: sender3 });\n    Parse.Object.saveAll([obj1, obj2, obj3])\n      .then(() => {\n        const query = new Parse.Query(TestObject);\n        query.containedIn('sender.group', ['A']);\n        return query.find();\n      })\n      .then(results => {\n        equal(results.length, 2);\n        done();\n      }, done.fail);\n  });\n\n  it('nested containedIn number', done => {\n    const sender1 = { group: [1, 2] };\n    const sender2 = { group: [1, 3] };\n    const sender3 = { group: [2, 3] };\n    const obj1 = new TestObject({ sender: sender1 });\n    const obj2 = new TestObject({ sender: sender2 });\n    const obj3 = new TestObject({ sender: sender3 });\n    Parse.Object.saveAll([obj1, obj2, obj3])\n      .then(() => {\n        const query = new Parse.Query(TestObject);\n        query.containedIn('sender.group', [1]);\n        return query.find();\n      })\n      .then(results => {\n        equal(results.length, 2);\n        done();\n      }, done.fail);\n  });\n\n  it('containsAll number array queries', function (done) {\n    const NumberSet = Parse.Object.extend({ className: 'NumberSet' });\n\n    const objectsList = [];\n    objectsList.push(new NumberSet({ numbers: [1, 2, 3, 4, 5] }));\n    objectsList.push(new NumberSet({ numbers: [1, 3, 4, 5] }));\n\n    Parse.Object.saveAll(objectsList)\n      .then(function () {\n        const query = new Parse.Query(NumberSet);\n        query.containsAll('numbers', [1, 2, 3]);\n        query.find().then(\n          function (results) {\n            equal(results.length, 1);\n            done();\n          },\n          function (err) {\n            jfail(err);\n            done();\n          }\n        );\n      })\n      .catch(err => {\n        jfail(err);\n        done();\n      });\n  });\n\n  it('containsAll string array queries', function (done) {\n    const StringSet = Parse.Object.extend({ className: 'StringSet' });\n\n    const objectsList = [];\n    objectsList.push(new StringSet({ strings: ['a', 'b', 'c', 'd', 'e'] }));\n    objectsList.push(new StringSet({ strings: ['a', 'c', 'd', 'e'] }));\n\n    Parse.Object.saveAll(objectsList)\n      .then(function () {\n        const query = new Parse.Query(StringSet);\n        query.containsAll('strings', ['a', 'b', 'c']);\n        query.find().then(function (results) {\n          equal(results.length, 1);\n          done();\n        });\n      })\n      .catch(err => {\n        jfail(err);\n        done();\n      });\n  });\n\n  it('containsAll date array queries', function (done) {\n    const DateSet = Parse.Object.extend({ className: 'DateSet' });\n\n    function parseDate(iso8601) {\n      const regexp = new RegExp(\n        '^([0-9]{1,4})-([0-9]{1,2})-([0-9]{1,2})' +\n          'T' +\n          '([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2})' +\n          '(.([0-9]+))?' +\n          'Z$'\n      );\n      const match = regexp.exec(iso8601);\n      if (!match) {\n        return null;\n      }\n\n      const year = match[1] || 0;\n      const month = (match[2] || 1) - 1;\n      const day = match[3] || 0;\n      const hour = match[4] || 0;\n      const minute = match[5] || 0;\n      const second = match[6] || 0;\n      const milli = match[8] || 0;\n\n      return new Date(Date.UTC(year, month, day, hour, minute, second, milli));\n    }\n\n    const makeDates = function (stringArray) {\n      return stringArray.map(function (dateStr) {\n        return parseDate(dateStr + 'T00:00:00Z');\n      });\n    };\n\n    const objectsList = [];\n    objectsList.push(\n      new DateSet({\n        dates: makeDates(['2013-02-01', '2013-02-02', '2013-02-03', '2013-02-04']),\n      })\n    );\n    objectsList.push(\n      new DateSet({\n        dates: makeDates(['2013-02-01', '2013-02-03', '2013-02-04']),\n      })\n    );\n\n    Parse.Object.saveAll(objectsList).then(function () {\n      const query = new Parse.Query(DateSet);\n      query.containsAll('dates', makeDates(['2013-02-01', '2013-02-02', '2013-02-03']));\n      query.find().then(\n        function (results) {\n          equal(results.length, 1);\n          done();\n        },\n        function (e) {\n          jfail(e);\n          done();\n        }\n      );\n    });\n  });\n\n  it('containsAll object array queries', function (done) {\n    const MessageSet = Parse.Object.extend({ className: 'MessageSet' });\n\n    const messageList = [];\n    for (let i = 0; i < 4; ++i) {\n      messageList.push(new TestObject({ i: i }));\n    }\n\n    Parse.Object.saveAll(messageList).then(function () {\n      equal(messageList.length, 4);\n\n      const messageSetList = [];\n      messageSetList.push(new MessageSet({ messages: messageList }));\n\n      const someList = [];\n      someList.push(messageList[0]);\n      someList.push(messageList[1]);\n      someList.push(messageList[3]);\n      messageSetList.push(new MessageSet({ messages: someList }));\n\n      Parse.Object.saveAll(messageSetList).then(function () {\n        const inList = [];\n        inList.push(messageList[0]);\n        inList.push(messageList[2]);\n\n        const query = new Parse.Query(MessageSet);\n        query.containsAll('messages', inList);\n        query.find().then(function (results) {\n          equal(results.length, 1);\n          done();\n        });\n      });\n    });\n  });\n\n  it('containsAllStartingWith should match all strings that starts with string', done => {\n    const object = new Parse.Object('Object');\n    object.set('strings', ['the', 'brown', 'lazy', 'fox', 'jumps']);\n    const object2 = new Parse.Object('Object');\n    object2.set('strings', ['the', 'brown', 'fox', 'jumps']);\n    const object3 = new Parse.Object('Object');\n    object3.set('strings', ['over', 'the', 'lazy', 'dog']);\n\n    const objectList = [object, object2, object3];\n\n    Parse.Object.saveAll(objectList).then(results => {\n      equal(objectList.length, results.length);\n\n      return request({\n        url: Parse.serverURL + '/classes/Object',\n        qs: {\n          where: JSON.stringify({\n            strings: {\n              $all: [{ $regex: '^\\\\Qthe\\\\E' }, { $regex: '^\\\\Qfox\\\\E' }, { $regex: '^\\\\Qlazy\\\\E' }],\n            },\n          }),\n        },\n        headers: {\n          'X-Parse-Application-Id': Parse.applicationId,\n          'X-Parse-Javascript-Key': Parse.javaScriptKey,\n          'Content-Type': 'application/json',\n        },\n      })\n        .then(function (response) {\n          const results = response.data;\n          equal(results.results.length, 1);\n          arrayContains(results.results, object);\n\n          return request({\n            url: Parse.serverURL + '/classes/Object',\n            qs: {\n              where: JSON.stringify({\n                strings: {\n                  $all: [{ $regex: '^\\\\Qthe\\\\E' }, { $regex: '^\\\\Qlazy\\\\E' }],\n                },\n              }),\n            },\n            headers: {\n              'X-Parse-Application-Id': Parse.applicationId,\n              'X-Parse-Javascript-Key': Parse.javaScriptKey,\n              'Content-Type': 'application/json',\n            },\n          });\n        })\n        .then(function (response) {\n          const results = response.data;\n          equal(results.results.length, 2);\n          arrayContains(results.results, object);\n          arrayContains(results.results, object3);\n\n          return request({\n            url: Parse.serverURL + '/classes/Object',\n            qs: {\n              where: JSON.stringify({\n                strings: {\n                  $all: [{ $regex: '^\\\\Qhe\\\\E' }, { $regex: '^\\\\Qlazy\\\\E' }],\n                },\n              }),\n            },\n            headers: {\n              'X-Parse-Application-Id': Parse.applicationId,\n              'X-Parse-Javascript-Key': Parse.javaScriptKey,\n              'Content-Type': 'application/json',\n            },\n          });\n        })\n        .then(function (response) {\n          const results = response.data;\n          equal(results.results.length, 0);\n\n          done();\n        });\n    });\n  });\n\n  it('containsAllStartingWith values must be all of type starting with regex', done => {\n    const object = new Parse.Object('Object');\n    object.set('strings', ['the', 'brown', 'lazy', 'fox', 'jumps']);\n\n    object\n      .save()\n      .then(() => {\n        equal(object.isNew(), false);\n\n        return request({\n          url: Parse.serverURL + '/classes/Object',\n          qs: {\n            where: JSON.stringify({\n              strings: {\n                $all: [\n                  { $regex: '^\\\\Qthe\\\\E' },\n                  { $regex: '^\\\\Qlazy\\\\E' },\n                  { $regex: '^\\\\Qfox\\\\E' },\n                  { $unknown: /unknown/ },\n                ],\n              },\n            }),\n          },\n          headers: {\n            'X-Parse-Application-Id': Parse.applicationId,\n            'X-Parse-Javascript-Key': Parse.javaScriptKey,\n            'Content-Type': 'application/json',\n          },\n        });\n      })\n      .then(done.fail, function () {\n        done();\n      });\n  });\n\n  it('containsAllStartingWith empty array values should return empty results', done => {\n    const object = new Parse.Object('Object');\n    object.set('strings', ['the', 'brown', 'lazy', 'fox', 'jumps']);\n\n    object\n      .save()\n      .then(() => {\n        equal(object.isNew(), false);\n\n        return request({\n          url: Parse.serverURL + '/classes/Object',\n          qs: {\n            where: JSON.stringify({\n              strings: {\n                $all: [],\n              },\n            }),\n          },\n          headers: {\n            'X-Parse-Application-Id': Parse.applicationId,\n            'X-Parse-Javascript-Key': Parse.javaScriptKey,\n            'Content-Type': 'application/json',\n          },\n        });\n      })\n      .then(\n        function (response) {\n          const results = response.data;\n          equal(results.results.length, 0);\n          done();\n        },\n        function () {}\n      );\n  });\n\n  it('containsAllStartingWith single empty value returns empty results', done => {\n    const object = new Parse.Object('Object');\n    object.set('strings', ['the', 'brown', 'lazy', 'fox', 'jumps']);\n\n    object\n      .save()\n      .then(() => {\n        equal(object.isNew(), false);\n\n        return request({\n          url: Parse.serverURL + '/classes/Object',\n          qs: {\n            where: JSON.stringify({\n              strings: {\n                $all: [{}],\n              },\n            }),\n          },\n          headers: {\n            'X-Parse-Application-Id': Parse.applicationId,\n            'X-Parse-Javascript-Key': Parse.javaScriptKey,\n            'Content-Type': 'application/json',\n          },\n        });\n      })\n      .then(\n        function (response) {\n          const results = response.data;\n          equal(results.results.length, 0);\n          done();\n        },\n        function () {}\n      );\n  });\n\n  it('containsAllStartingWith single regex value should return corresponding matching results', done => {\n    const object = new Parse.Object('Object');\n    object.set('strings', ['the', 'brown', 'lazy', 'fox', 'jumps']);\n    const object2 = new Parse.Object('Object');\n    object2.set('strings', ['the', 'brown', 'fox', 'jumps']);\n    const object3 = new Parse.Object('Object');\n    object3.set('strings', ['over', 'the', 'lazy', 'dog']);\n\n    const objectList = [object, object2, object3];\n\n    Parse.Object.saveAll(objectList)\n      .then(results => {\n        equal(objectList.length, results.length);\n\n        return request({\n          url: Parse.serverURL + '/classes/Object',\n          qs: {\n            where: JSON.stringify({\n              strings: {\n                $all: [{ $regex: '^\\\\Qlazy\\\\E' }],\n              },\n            }),\n          },\n          headers: {\n            'X-Parse-Application-Id': Parse.applicationId,\n            'X-Parse-Javascript-Key': Parse.javaScriptKey,\n            'Content-Type': 'application/json',\n          },\n        });\n      })\n      .then(\n        function (response) {\n          const results = response.data;\n          equal(results.results.length, 2);\n          done();\n        },\n        function () {}\n      );\n  });\n\n  it('containsAllStartingWith single invalid regex returns empty results', done => {\n    const object = new Parse.Object('Object');\n    object.set('strings', ['the', 'brown', 'lazy', 'fox', 'jumps']);\n\n    object\n      .save()\n      .then(() => {\n        equal(object.isNew(), false);\n\n        return request({\n          url: Parse.serverURL + '/classes/Object',\n          qs: {\n            where: JSON.stringify({\n              strings: {\n                $all: [{ $unknown: '^\\\\Qlazy\\\\E' }],\n              },\n            }),\n          },\n          headers: {\n            'X-Parse-Application-Id': Parse.applicationId,\n            'X-Parse-Javascript-Key': Parse.javaScriptKey,\n          },\n        });\n      })\n      .then(\n        function (response) {\n          const results = response.data;\n          equal(results.results.length, 0);\n          done();\n        },\n        function () {}\n      );\n  });\n\n  it('containedBy pointer array', done => {\n    const objects = Array.from(Array(10).keys()).map(idx => {\n      const obj = new Parse.Object('Object');\n      obj.set('key', idx);\n      return obj;\n    });\n\n    const parent = new Parse.Object('Parent');\n    const parent2 = new Parse.Object('Parent');\n    const parent3 = new Parse.Object('Parent');\n\n    Parse.Object.saveAll(objects)\n      .then(() => {\n        // [0, 1, 2]\n        parent.set('objects', objects.slice(0, 3));\n\n        const shift = objects.shift();\n        // [2, 0]\n        parent2.set('objects', [objects[1], shift]);\n\n        // [1, 2, 3, 4]\n        parent3.set('objects', objects.slice(1, 4));\n\n        return Parse.Object.saveAll([parent, parent2, parent3]);\n      })\n      .then(() => {\n        // [1, 2, 3, 4, 5, 6, 7, 8, 9]\n        const pointers = objects.map(object => object.toPointer());\n\n        // Return all Parent where all parent.objects are contained in objects\n        return request({\n          url: Parse.serverURL + '/classes/Parent',\n          qs: {\n            where: JSON.stringify({\n              objects: {\n                $containedBy: pointers,\n              },\n            }),\n          },\n          headers: {\n            'X-Parse-Application-Id': Parse.applicationId,\n            'X-Parse-Javascript-Key': Parse.javaScriptKey,\n            'Content-Type': 'application/json',\n          },\n        });\n      })\n      .then(response => {\n        const results = response.data;\n        expect(results.results[0].objectId).not.toBeUndefined();\n        expect(results.results[0].objectId).toBe(parent3.id);\n        expect(results.results.length).toBe(1);\n        done();\n      });\n  });\n\n  it('containedBy number array', done => {\n    const options = Object.assign({}, masterKeyOptions, {\n      qs: {\n        where: JSON.stringify({\n          numbers: { $containedBy: [1, 2, 3, 4, 5, 6, 7, 8, 9] },\n        }),\n      },\n    });\n    const obj1 = new TestObject({ numbers: [0, 1, 2] });\n    const obj2 = new TestObject({ numbers: [2, 0] });\n    const obj3 = new TestObject({ numbers: [1, 2, 3, 4] });\n    Parse.Object.saveAll([obj1, obj2, obj3])\n      .then(() => {\n        return request(Object.assign({ url: Parse.serverURL + '/classes/TestObject' }, options));\n      })\n      .then(response => {\n        const results = response.data;\n        expect(results.results[0].objectId).not.toBeUndefined();\n        expect(results.results[0].objectId).toBe(obj3.id);\n        expect(results.results.length).toBe(1);\n        done();\n      });\n  });\n\n  it('containedBy empty array', done => {\n    const options = Object.assign({}, masterKeyOptions, {\n      qs: {\n        where: JSON.stringify({ numbers: { $containedBy: [] } }),\n      },\n    });\n    const obj1 = new TestObject({ numbers: [0, 1, 2] });\n    const obj2 = new TestObject({ numbers: [2, 0] });\n    const obj3 = new TestObject({ numbers: [1, 2, 3, 4] });\n    Parse.Object.saveAll([obj1, obj2, obj3])\n      .then(() => {\n        return request(Object.assign({ url: Parse.serverURL + '/classes/TestObject' }, options));\n      })\n      .then(response => {\n        const results = response.data;\n        expect(results.results.length).toBe(0);\n        done();\n      });\n  });\n\n  it('containedBy invalid query', done => {\n    const options = Object.assign({}, masterKeyOptions, {\n      qs: {\n        where: JSON.stringify({ objects: { $containedBy: 1234 } }),\n      },\n    });\n    const obj = new TestObject();\n    obj\n      .save()\n      .then(() => {\n        return request(Object.assign({ url: Parse.serverURL + '/classes/TestObject' }, options));\n      })\n      .then(done.fail)\n      .catch(response => {\n        equal(response.data.code, Parse.Error.INVALID_JSON);\n        equal(response.data.error, 'bad $containedBy: should be an array');\n        done();\n      });\n  });\n\n  it('equalTo queries', function (done) {\n    const makeBoxedNumber = function (i) {\n      return new BoxedNumber({ number: i });\n    };\n    Parse.Object.saveAll([0, 1, 2, 3, 4, 5, 6, 7, 8, 9].map(makeBoxedNumber)).then(function () {\n      const query = new Parse.Query(BoxedNumber);\n      query.equalTo('number', 3);\n      query.find().then(function (results) {\n        equal(results.length, 1);\n        done();\n      });\n    });\n  });\n\n  it('equalTo undefined', function (done) {\n    const makeBoxedNumber = function (i) {\n      return new BoxedNumber({ number: i });\n    };\n    Parse.Object.saveAll([0, 1, 2, 3, 4, 5, 6, 7, 8, 9].map(makeBoxedNumber)).then(function () {\n      const query = new Parse.Query(BoxedNumber);\n      query.equalTo('number', undefined);\n      query.find().then(function (results) {\n        equal(results.length, 0);\n        done();\n      });\n    });\n  });\n\n  it('lessThan queries', function (done) {\n    const makeBoxedNumber = function (i) {\n      return new BoxedNumber({ number: i });\n    };\n    Parse.Object.saveAll([0, 1, 2, 3, 4, 5, 6, 7, 8, 9].map(makeBoxedNumber)).then(function () {\n      const query = new Parse.Query(BoxedNumber);\n      query.lessThan('number', 7);\n      query.find().then(function (results) {\n        equal(results.length, 7);\n        done();\n      });\n    });\n  });\n\n  it('lessThanOrEqualTo queries', function (done) {\n    const makeBoxedNumber = function (i) {\n      return new BoxedNumber({ number: i });\n    };\n    Parse.Object.saveAll([0, 1, 2, 3, 4, 5, 6, 7, 8, 9].map(makeBoxedNumber)).then(function () {\n      const query = new Parse.Query(BoxedNumber);\n      query.lessThanOrEqualTo('number', 7);\n      query.find().then(function (results) {\n        equal(results.length, 8);\n        done();\n      });\n    });\n  });\n\n  it('lessThan zero queries', done => {\n    const makeBoxedNumber = i => {\n      return new BoxedNumber({ number: i });\n    };\n    const numbers = [-3, -2, -1, 0, 1];\n    const boxedNumbers = numbers.map(makeBoxedNumber);\n    Parse.Object.saveAll(boxedNumbers)\n      .then(() => {\n        const query = new Parse.Query(BoxedNumber);\n        query.lessThan('number', 0);\n        return query.find();\n      })\n      .then(results => {\n        equal(results.length, 3);\n        done();\n      });\n  });\n\n  it('lessThanOrEqualTo zero queries', done => {\n    const makeBoxedNumber = i => {\n      return new BoxedNumber({ number: i });\n    };\n    const numbers = [-3, -2, -1, 0, 1];\n    const boxedNumbers = numbers.map(makeBoxedNumber);\n    Parse.Object.saveAll(boxedNumbers)\n      .then(() => {\n        const query = new Parse.Query(BoxedNumber);\n        query.lessThanOrEqualTo('number', 0);\n        return query.find();\n      })\n      .then(results => {\n        equal(results.length, 4);\n        done();\n      });\n  });\n\n  it('greaterThan queries', function (done) {\n    const makeBoxedNumber = function (i) {\n      return new BoxedNumber({ number: i });\n    };\n    Parse.Object.saveAll([0, 1, 2, 3, 4, 5, 6, 7, 8, 9].map(makeBoxedNumber)).then(function () {\n      const query = new Parse.Query(BoxedNumber);\n      query.greaterThan('number', 7);\n      query.find().then(function (results) {\n        equal(results.length, 2);\n        done();\n      });\n    });\n  });\n\n  it('greaterThanOrEqualTo queries', function (done) {\n    const makeBoxedNumber = function (i) {\n      return new BoxedNumber({ number: i });\n    };\n    Parse.Object.saveAll([0, 1, 2, 3, 4, 5, 6, 7, 8, 9].map(makeBoxedNumber)).then(function () {\n      const query = new Parse.Query(BoxedNumber);\n      query.greaterThanOrEqualTo('number', 7);\n      query.find().then(function (results) {\n        equal(results.length, 3);\n        done();\n      });\n    });\n  });\n\n  it('greaterThan zero queries', done => {\n    const makeBoxedNumber = i => {\n      return new BoxedNumber({ number: i });\n    };\n    const numbers = [-3, -2, -1, 0, 1];\n    const boxedNumbers = numbers.map(makeBoxedNumber);\n    Parse.Object.saveAll(boxedNumbers)\n      .then(() => {\n        const query = new Parse.Query(BoxedNumber);\n        query.greaterThan('number', 0);\n        return query.find();\n      })\n      .then(results => {\n        equal(results.length, 1);\n        done();\n      });\n  });\n\n  it('greaterThanOrEqualTo zero queries', done => {\n    const makeBoxedNumber = i => {\n      return new BoxedNumber({ number: i });\n    };\n    const numbers = [-3, -2, -1, 0, 1];\n    const boxedNumbers = numbers.map(makeBoxedNumber);\n    Parse.Object.saveAll(boxedNumbers)\n      .then(() => {\n        const query = new Parse.Query(BoxedNumber);\n        query.greaterThanOrEqualTo('number', 0);\n        return query.find();\n      })\n      .then(results => {\n        equal(results.length, 2);\n        done();\n      });\n  });\n\n  it('lessThanOrEqualTo greaterThanOrEqualTo queries', function (done) {\n    const makeBoxedNumber = function (i) {\n      return new BoxedNumber({ number: i });\n    };\n    Parse.Object.saveAll([0, 1, 2, 3, 4, 5, 6, 7, 8, 9].map(makeBoxedNumber)).then(function () {\n      const query = new Parse.Query(BoxedNumber);\n      query.lessThanOrEqualTo('number', 7);\n      query.greaterThanOrEqualTo('number', 7);\n      query.find().then(function (results) {\n        equal(results.length, 1);\n        done();\n      });\n    });\n  });\n\n  it('lessThan greaterThan queries', function (done) {\n    const makeBoxedNumber = function (i) {\n      return new BoxedNumber({ number: i });\n    };\n    Parse.Object.saveAll([0, 1, 2, 3, 4, 5, 6, 7, 8, 9].map(makeBoxedNumber)).then(function () {\n      const query = new Parse.Query(BoxedNumber);\n      query.lessThan('number', 9);\n      query.greaterThan('number', 3);\n      query.find().then(function (results) {\n        equal(results.length, 5);\n        done();\n      });\n    });\n  });\n\n  it('notEqualTo queries', function (done) {\n    const makeBoxedNumber = function (i) {\n      return new BoxedNumber({ number: i });\n    };\n    Parse.Object.saveAll([0, 1, 2, 3, 4, 5, 6, 7, 8, 9].map(makeBoxedNumber)).then(function () {\n      const query = new Parse.Query(BoxedNumber);\n      query.notEqualTo('number', 5);\n      query.find().then(function (results) {\n        equal(results.length, 9);\n        done();\n      });\n    });\n  });\n\n  it('notEqualTo zero queries', done => {\n    const makeBoxedNumber = i => {\n      return new BoxedNumber({ number: i });\n    };\n    const numbers = [-3, -2, -1, 0, 1];\n    const boxedNumbers = numbers.map(makeBoxedNumber);\n    Parse.Object.saveAll(boxedNumbers)\n      .then(() => {\n        const query = new Parse.Query(BoxedNumber);\n        query.notEqualTo('number', 0);\n        return query.find();\n      })\n      .then(results => {\n        equal(results.length, 4);\n        done();\n      });\n  });\n\n  it('equalTo zero queries', done => {\n    const makeBoxedNumber = i => {\n      return new BoxedNumber({ number: i });\n    };\n    const numbers = [-3, -2, -1, 0, 1];\n    const boxedNumbers = numbers.map(makeBoxedNumber);\n    Parse.Object.saveAll(boxedNumbers)\n      .then(() => {\n        const query = new Parse.Query(BoxedNumber);\n        query.equalTo('number', 0);\n        return query.find();\n      })\n      .then(results => {\n        equal(results.length, 1);\n        done();\n      });\n  });\n\n  it('number equalTo boolean queries', done => {\n    const makeBoxedNumber = i => {\n      return new BoxedNumber({ number: i });\n    };\n    const numbers = [-3, -2, -1, 0, 1];\n    const boxedNumbers = numbers.map(makeBoxedNumber);\n    Parse.Object.saveAll(boxedNumbers)\n      .then(() => {\n        const query = new Parse.Query(BoxedNumber);\n        query.equalTo('number', false);\n        return query.find();\n      })\n      .then(results => {\n        equal(results.length, 0);\n        done();\n      });\n  });\n\n  it('equalTo false queries', done => {\n    const obj1 = new TestObject({ field: false });\n    const obj2 = new TestObject({ field: true });\n    Parse.Object.saveAll([obj1, obj2])\n      .then(() => {\n        const query = new Parse.Query(TestObject);\n        query.equalTo('field', false);\n        return query.find();\n      })\n      .then(results => {\n        equal(results.length, 1);\n        done();\n      });\n  });\n\n  it('where $eq false queries (rest)', done => {\n    const options = Object.assign({}, masterKeyOptions, {\n      qs: {\n        where: JSON.stringify({ field: { $eq: false } }),\n      },\n    });\n    const obj1 = new TestObject({ field: false });\n    const obj2 = new TestObject({ field: true });\n    Parse.Object.saveAll([obj1, obj2]).then(() => {\n      request(Object.assign({ url: Parse.serverURL + '/classes/TestObject' }, options)).then(\n        resp => {\n          equal(resp.data.results.length, 1);\n          done();\n        }\n      );\n    });\n  });\n\n  it('where $eq null queries (rest)', done => {\n    const options = Object.assign({}, masterKeyOptions, {\n      qs: {\n        where: JSON.stringify({ field: { $eq: null } }),\n      },\n    });\n    const obj1 = new TestObject({ field: false });\n    const obj2 = new TestObject({ field: null });\n    Parse.Object.saveAll([obj1, obj2]).then(() => {\n      return request(Object.assign({ url: Parse.serverURL + '/classes/TestObject' }, options)).then(\n        resp => {\n          equal(resp.data.results.length, 1);\n          done();\n        }\n      );\n    });\n  });\n\n  it('containedIn queries', function (done) {\n    const makeBoxedNumber = function (i) {\n      return new BoxedNumber({ number: i });\n    };\n    Parse.Object.saveAll([0, 1, 2, 3, 4, 5, 6, 7, 8, 9].map(makeBoxedNumber)).then(function () {\n      const query = new Parse.Query(BoxedNumber);\n      query.containedIn('number', [3, 5, 7, 9, 11]);\n      query.find().then(function (results) {\n        equal(results.length, 4);\n        done();\n      });\n    });\n  });\n\n  it('containedIn false queries', done => {\n    const makeBoxedNumber = i => {\n      return new BoxedNumber({ number: i });\n    };\n    const numbers = [-3, -2, -1, 0, 1];\n    const boxedNumbers = numbers.map(makeBoxedNumber);\n    Parse.Object.saveAll(boxedNumbers)\n      .then(() => {\n        const query = new Parse.Query(BoxedNumber);\n        query.containedIn('number', false);\n        return query.find();\n      })\n      .then(done.fail)\n      .catch(error => {\n        equal(error.code, Parse.Error.INVALID_JSON);\n        equal(error.message, 'bad $in value');\n        done();\n      });\n  });\n\n  it('notContainedIn false queries', done => {\n    const makeBoxedNumber = i => {\n      return new BoxedNumber({ number: i });\n    };\n    const numbers = [-3, -2, -1, 0, 1];\n    const boxedNumbers = numbers.map(makeBoxedNumber);\n    Parse.Object.saveAll(boxedNumbers)\n      .then(() => {\n        const query = new Parse.Query(BoxedNumber);\n        query.notContainedIn('number', false);\n        return query.find();\n      })\n      .then(done.fail)\n      .catch(error => {\n        equal(error.code, Parse.Error.INVALID_JSON);\n        equal(error.message, 'bad $nin value');\n        done();\n      });\n  });\n\n  it('notContainedIn queries', function (done) {\n    const makeBoxedNumber = function (i) {\n      return new BoxedNumber({ number: i });\n    };\n    Parse.Object.saveAll([0, 1, 2, 3, 4, 5, 6, 7, 8, 9].map(makeBoxedNumber)).then(function () {\n      const query = new Parse.Query(BoxedNumber);\n      query.notContainedIn('number', [3, 5, 7, 9, 11]);\n      query.find().then(function (results) {\n        equal(results.length, 6);\n        done();\n      });\n    });\n  });\n\n  it('objectId containedIn queries', function (done) {\n    const makeBoxedNumber = function (i) {\n      return new BoxedNumber({ number: i });\n    };\n    Parse.Object.saveAll([0, 1, 2, 3, 4, 5, 6, 7, 8, 9].map(makeBoxedNumber)).then(function (list) {\n      const query = new Parse.Query(BoxedNumber);\n      query.containedIn('objectId', [list[2].id, list[3].id, list[0].id, 'NONSENSE']);\n      query.ascending('number');\n      query.find().then(function (results) {\n        if (results.length != 3) {\n          fail('expected 3 results');\n        } else {\n          equal(results[0].get('number'), 0);\n          equal(results[1].get('number'), 2);\n          equal(results[2].get('number'), 3);\n        }\n        done();\n      });\n    });\n  });\n\n  it('objectId equalTo queries', function (done) {\n    const makeBoxedNumber = function (i) {\n      return new BoxedNumber({ number: i });\n    };\n    Parse.Object.saveAll([0, 1, 2, 3, 4, 5, 6, 7, 8, 9].map(makeBoxedNumber)).then(function (list) {\n      const query = new Parse.Query(BoxedNumber);\n      query.equalTo('objectId', list[4].id);\n      query.find().then(function (results) {\n        if (results.length != 1) {\n          fail('expected 1 result');\n          done();\n        } else {\n          equal(results[0].get('number'), 4);\n        }\n        done();\n      });\n    });\n  });\n\n  it('find no elements', function (done) {\n    const makeBoxedNumber = function (i) {\n      return new BoxedNumber({ number: i });\n    };\n    Parse.Object.saveAll([0, 1, 2, 3, 4, 5, 6, 7, 8, 9].map(makeBoxedNumber)).then(function () {\n      const query = new Parse.Query(BoxedNumber);\n      query.equalTo('number', 17);\n      query.find().then(function (results) {\n        equal(results.length, 0);\n        done();\n      });\n    });\n  });\n\n  it('find with error', function (done) {\n    const query = new Parse.Query(BoxedNumber);\n    query.equalTo('$foo', 'bar');\n    query\n      .find()\n      .then(done.fail)\n      .catch(error => expect(error.code).toBe(Parse.Error.INVALID_KEY_NAME))\n      .then(done);\n  });\n\n  it('get', function (done) {\n    Parse.Object.saveAll([new TestObject({ foo: 'bar' })]).then(function (items) {\n      ok(items[0]);\n      const objectId = items[0].id;\n      const query = new Parse.Query(TestObject);\n      query.get(objectId).then(function (result) {\n        ok(result);\n        equal(result.id, objectId);\n        equal(result.get('foo'), 'bar');\n        ok(result.createdAt instanceof Date);\n        ok(result.updatedAt instanceof Date);\n        done();\n      });\n    });\n  });\n\n  it('get undefined', function (done) {\n    Parse.Object.saveAll([new TestObject({ foo: 'bar' })]).then(function (items) {\n      ok(items[0]);\n      const query = new Parse.Query(TestObject);\n      query.get(undefined).then(fail, () => done());\n    });\n  });\n\n  it('get error', function (done) {\n    Parse.Object.saveAll([new TestObject({ foo: 'bar' })]).then(function (items) {\n      ok(items[0]);\n      const query = new Parse.Query(TestObject);\n      query.get('InvalidObjectID').then(\n        function () {\n          ok(false, 'The get should have failed.');\n          done();\n        },\n        function (error) {\n          equal(error.code, Parse.Error.OBJECT_NOT_FOUND);\n          done();\n        }\n      );\n    });\n  });\n\n  it('first', function (done) {\n    Parse.Object.saveAll([new TestObject({ foo: 'bar' })]).then(function () {\n      const query = new Parse.Query(TestObject);\n      query.equalTo('foo', 'bar');\n      query.first().then(function (result) {\n        equal(result.get('foo'), 'bar');\n        done();\n      });\n    });\n  });\n\n  it('first no result', function (done) {\n    Parse.Object.saveAll([new TestObject({ foo: 'bar' })]).then(function () {\n      const query = new Parse.Query(TestObject);\n      query.equalTo('foo', 'baz');\n      query.first().then(function (result) {\n        equal(result, undefined);\n        done();\n      });\n    });\n  });\n\n  it('first with two results', function (done) {\n    Parse.Object.saveAll([new TestObject({ foo: 'bar' }), new TestObject({ foo: 'bar' })]).then(\n      function () {\n        const query = new Parse.Query(TestObject);\n        query.equalTo('foo', 'bar');\n        query.first().then(function (result) {\n          equal(result.get('foo'), 'bar');\n          done();\n        });\n      }\n    );\n  });\n\n  it('first with error', function (done) {\n    const query = new Parse.Query(BoxedNumber);\n    query.equalTo('$foo', 'bar');\n    query\n      .first()\n      .then(done.fail)\n      .catch(e => expect(e.code).toBe(Parse.Error.INVALID_KEY_NAME))\n      .then(done);\n  });\n\n  const Container = Parse.Object.extend({\n    className: 'Container',\n  });\n\n  it('notEqualTo object', function (done) {\n    const item1 = new TestObject();\n    const item2 = new TestObject();\n    const container1 = new Container({ item: item1 });\n    const container2 = new Container({ item: item2 });\n    Parse.Object.saveAll([item1, item2, container1, container2]).then(function () {\n      const query = new Parse.Query(Container);\n      query.notEqualTo('item', item1);\n      query.find().then(function (results) {\n        equal(results.length, 1);\n        done();\n      });\n    });\n  });\n\n  it('skip', function (done) {\n    Parse.Object.saveAll([new TestObject(), new TestObject()]).then(function () {\n      const query = new Parse.Query(TestObject);\n      query.skip(1);\n      query.find().then(function (results) {\n        equal(results.length, 1);\n        query.skip(3);\n        query.find().then(function (results) {\n          equal(results.length, 0);\n          done();\n        });\n      });\n    });\n  });\n\n  it(\"skip doesn't affect count\", function (done) {\n    Parse.Object.saveAll([new TestObject(), new TestObject()]).then(function () {\n      const query = new Parse.Query(TestObject);\n      query.count().then(function (count) {\n        equal(count, 2);\n        query.skip(1);\n        query.count().then(function (count) {\n          equal(count, 2);\n          query.skip(3);\n          query.count().then(function (count) {\n            equal(count, 2);\n            done();\n          });\n        });\n      });\n    });\n  });\n\n  it('count', function (done) {\n    const makeBoxedNumber = function (i) {\n      return new BoxedNumber({ number: i });\n    };\n    Parse.Object.saveAll([0, 1, 2, 3, 4, 5, 6, 7, 8, 9].map(makeBoxedNumber)).then(function () {\n      const query = new Parse.Query(BoxedNumber);\n      query.greaterThan('number', 1);\n      query.count().then(function (count) {\n        equal(count, 8);\n        done();\n      });\n    });\n  });\n\n  it('order by ascending number', function (done) {\n    const makeBoxedNumber = function (i) {\n      return new BoxedNumber({ number: i });\n    };\n    Parse.Object.saveAll([3, 1, 2].map(makeBoxedNumber)).then(function () {\n      const query = new Parse.Query(BoxedNumber);\n      query.ascending('number');\n      query.find().then(function (results) {\n        equal(results.length, 3);\n        equal(results[0].get('number'), 1);\n        equal(results[1].get('number'), 2);\n        equal(results[2].get('number'), 3);\n        done();\n      });\n    });\n  });\n\n  it('order by descending number', function (done) {\n    const makeBoxedNumber = function (i) {\n      return new BoxedNumber({ number: i });\n    };\n    Parse.Object.saveAll([3, 1, 2].map(makeBoxedNumber)).then(function () {\n      const query = new Parse.Query(BoxedNumber);\n      query.descending('number');\n      query.find().then(function (results) {\n        equal(results.length, 3);\n        equal(results[0].get('number'), 3);\n        equal(results[1].get('number'), 2);\n        equal(results[2].get('number'), 1);\n        done();\n      });\n    });\n  });\n\n  it('can order on an object string field', function (done) {\n    const testSet = [\n      { sortField: { value: 'Z' } },\n      { sortField: { value: 'A' } },\n      { sortField: { value: 'M' } },\n    ];\n\n    const objects = testSet.map(e => new Parse.Object('Test', e));\n    Parse.Object.saveAll(objects)\n      .then(() => new Parse.Query('Test').addDescending('sortField.value').first())\n      .then(result => {\n        expect(result.get('sortField').value).toBe('Z');\n        return new Parse.Query('Test').addAscending('sortField.value').first();\n      })\n      .then(result => {\n        expect(result.get('sortField').value).toBe('A');\n        done();\n      })\n      .catch(done.fail);\n  });\n\n  it('can order on an object string field (level 2)', function (done) {\n    const testSet = [\n      { sortField: { value: { field: 'Z' } } },\n      { sortField: { value: { field: 'A' } } },\n      { sortField: { value: { field: 'M' } } },\n    ];\n\n    const objects = testSet.map(e => new Parse.Object('Test', e));\n    Parse.Object.saveAll(objects)\n      .then(() => new Parse.Query('Test').addDescending('sortField.value.field').first())\n      .then(result => {\n        expect(result.get('sortField').value.field).toBe('Z');\n        return new Parse.Query('Test').addAscending('sortField.value.field').first();\n      })\n      .then(result => {\n        expect(result.get('sortField').value.field).toBe('A');\n        done();\n      })\n      .catch(done.fail);\n  });\n\n  it('can order on an object number field', function (done) {\n    const testSet = [\n      { sortField: { value: 10 } },\n      { sortField: { value: 1 } },\n      { sortField: { value: 5 } },\n    ];\n\n    const objects = testSet.map(e => new Parse.Object('Test', e));\n    Parse.Object.saveAll(objects)\n      .then(() => new Parse.Query('Test').addDescending('sortField.value').first())\n      .then(result => {\n        expect(result.get('sortField').value).toBe(10);\n        return new Parse.Query('Test').addAscending('sortField.value').first();\n      })\n      .then(result => {\n        expect(result.get('sortField').value).toBe(1);\n        done();\n      })\n      .catch(done.fail);\n  });\n\n  it('can order on an object number field (level 2)', function (done) {\n    const testSet = [\n      { sortField: { value: { field: 10 } } },\n      { sortField: { value: { field: 1 } } },\n      { sortField: { value: { field: 5 } } },\n    ];\n\n    const objects = testSet.map(e => new Parse.Object('Test', e));\n    Parse.Object.saveAll(objects)\n      .then(() => new Parse.Query('Test').addDescending('sortField.value.field').first())\n      .then(result => {\n        expect(result.get('sortField').value.field).toBe(10);\n        return new Parse.Query('Test').addAscending('sortField.value.field').first();\n      })\n      .then(result => {\n        expect(result.get('sortField').value.field).toBe(1);\n        done();\n      })\n      .catch(done.fail);\n  });\n\n  it('order by ascending number then descending string', function (done) {\n    const strings = ['a', 'b', 'c', 'd'];\n    const makeBoxedNumber = function (num, i) {\n      return new BoxedNumber({ number: num, string: strings[i] });\n    };\n    Parse.Object.saveAll([3, 1, 3, 2].map(makeBoxedNumber)).then(function () {\n      const query = new Parse.Query(BoxedNumber);\n      query.ascending('number').addDescending('string');\n      query.find().then(function (results) {\n        equal(results.length, 4);\n        equal(results[0].get('number'), 1);\n        equal(results[0].get('string'), 'b');\n        equal(results[1].get('number'), 2);\n        equal(results[1].get('string'), 'd');\n        equal(results[2].get('number'), 3);\n        equal(results[2].get('string'), 'c');\n        equal(results[3].get('number'), 3);\n        equal(results[3].get('string'), 'a');\n        done();\n      });\n    });\n  });\n\n  it('order by descending number then ascending string', function (done) {\n    const strings = ['a', 'b', 'c', 'd'];\n    const makeBoxedNumber = function (num, i) {\n      return new BoxedNumber({ number: num, string: strings[i] });\n    };\n\n    const objects = [3, 1, 3, 2].map(makeBoxedNumber);\n    Parse.Object.saveAll(objects)\n      .then(() => {\n        const query = new Parse.Query(BoxedNumber);\n        query.descending('number').addAscending('string');\n        return query.find();\n      })\n      .then(\n        results => {\n          equal(results.length, 4);\n          equal(results[0].get('number'), 3);\n          equal(results[0].get('string'), 'a');\n          equal(results[1].get('number'), 3);\n          equal(results[1].get('string'), 'c');\n          equal(results[2].get('number'), 2);\n          equal(results[2].get('string'), 'd');\n          equal(results[3].get('number'), 1);\n          equal(results[3].get('string'), 'b');\n          done();\n        },\n        err => {\n          jfail(err);\n          done();\n        }\n      );\n  });\n\n  it('order by descending number and string', function (done) {\n    const strings = ['a', 'b', 'c', 'd'];\n    const makeBoxedNumber = function (num, i) {\n      return new BoxedNumber({ number: num, string: strings[i] });\n    };\n    Parse.Object.saveAll([3, 1, 3, 2].map(makeBoxedNumber)).then(function () {\n      const query = new Parse.Query(BoxedNumber);\n      query.descending('number,string');\n      query.find().then(function (results) {\n        equal(results.length, 4);\n        equal(results[0].get('number'), 3);\n        equal(results[0].get('string'), 'c');\n        equal(results[1].get('number'), 3);\n        equal(results[1].get('string'), 'a');\n        equal(results[2].get('number'), 2);\n        equal(results[2].get('string'), 'd');\n        equal(results[3].get('number'), 1);\n        equal(results[3].get('string'), 'b');\n        done();\n      });\n    });\n  });\n\n  it('order by descending number and string, with space', function (done) {\n    const strings = ['a', 'b', 'c', 'd'];\n    const makeBoxedNumber = function (num, i) {\n      return new BoxedNumber({ number: num, string: strings[i] });\n    };\n    Parse.Object.saveAll([3, 1, 3, 2].map(makeBoxedNumber)).then(\n      function () {\n        const query = new Parse.Query(BoxedNumber);\n        query.descending('number, string');\n        query.find().then(function (results) {\n          equal(results.length, 4);\n          equal(results[0].get('number'), 3);\n          equal(results[0].get('string'), 'c');\n          equal(results[1].get('number'), 3);\n          equal(results[1].get('string'), 'a');\n          equal(results[2].get('number'), 2);\n          equal(results[2].get('string'), 'd');\n          equal(results[3].get('number'), 1);\n          equal(results[3].get('string'), 'b');\n          done();\n        });\n      },\n      err => {\n        jfail(err);\n        done();\n      }\n    );\n  });\n\n  it('order by descending number and string, with array arg', function (done) {\n    const strings = ['a', 'b', 'c', 'd'];\n    const makeBoxedNumber = function (num, i) {\n      return new BoxedNumber({ number: num, string: strings[i] });\n    };\n    Parse.Object.saveAll([3, 1, 3, 2].map(makeBoxedNumber)).then(function () {\n      const query = new Parse.Query(BoxedNumber);\n      query.descending(['number', 'string']);\n      query.find().then(function (results) {\n        equal(results.length, 4);\n        equal(results[0].get('number'), 3);\n        equal(results[0].get('string'), 'c');\n        equal(results[1].get('number'), 3);\n        equal(results[1].get('string'), 'a');\n        equal(results[2].get('number'), 2);\n        equal(results[2].get('string'), 'd');\n        equal(results[3].get('number'), 1);\n        equal(results[3].get('string'), 'b');\n        done();\n      });\n    });\n  });\n\n  it('order by descending number and string, with multiple args', function (done) {\n    const strings = ['a', 'b', 'c', 'd'];\n    const makeBoxedNumber = function (num, i) {\n      return new BoxedNumber({ number: num, string: strings[i] });\n    };\n    Parse.Object.saveAll([3, 1, 3, 2].map(makeBoxedNumber)).then(function () {\n      const query = new Parse.Query(BoxedNumber);\n      query.descending('number', 'string');\n      query.find().then(function (results) {\n        equal(results.length, 4);\n        equal(results[0].get('number'), 3);\n        equal(results[0].get('string'), 'c');\n        equal(results[1].get('number'), 3);\n        equal(results[1].get('string'), 'a');\n        equal(results[2].get('number'), 2);\n        equal(results[2].get('string'), 'd');\n        equal(results[3].get('number'), 1);\n        equal(results[3].get('string'), 'b');\n        done();\n      });\n    });\n  });\n\n  it(\"can't order by password\", function (done) {\n    const makeBoxedNumber = function (i) {\n      return new BoxedNumber({ number: i });\n    };\n    Parse.Object.saveAll([3, 1, 2].map(makeBoxedNumber)).then(function () {\n      const query = new Parse.Query(BoxedNumber);\n      query.ascending('_password');\n      query\n        .find()\n        .then(done.fail)\n        .catch(e => expect(e.code).toBe(Parse.Error.INVALID_KEY_NAME))\n        .then(done);\n    });\n  });\n\n  it('order by _created_at', function (done) {\n    const makeBoxedNumber = function (i) {\n      return new BoxedNumber({ number: i });\n    };\n    const numbers = [3, 1, 2].map(makeBoxedNumber);\n    numbers[0]\n      .save()\n      .then(() => {\n        return numbers[1].save();\n      })\n      .then(() => {\n        return numbers[2].save();\n      })\n      .then(function () {\n        const query = new Parse.Query(BoxedNumber);\n        query.ascending('_created_at');\n        query.find().then(function (results) {\n          equal(results.length, 3);\n          equal(results[0].get('number'), 3);\n          equal(results[1].get('number'), 1);\n          equal(results[2].get('number'), 2);\n          done();\n        }, done.fail);\n      });\n  });\n\n  it('order by createdAt', function (done) {\n    const makeBoxedNumber = function (i) {\n      return new BoxedNumber({ number: i });\n    };\n    const numbers = [3, 1, 2].map(makeBoxedNumber);\n    numbers[0]\n      .save()\n      .then(() => {\n        return numbers[1].save();\n      })\n      .then(() => {\n        return numbers[2].save();\n      })\n      .then(function () {\n        const query = new Parse.Query(BoxedNumber);\n        query.descending('createdAt');\n        query.find().then(function (results) {\n          equal(results.length, 3);\n          equal(results[0].get('number'), 2);\n          equal(results[1].get('number'), 1);\n          equal(results[2].get('number'), 3);\n          done();\n        });\n      });\n  });\n\n  it('order by _updated_at', function (done) {\n    const makeBoxedNumber = function (i) {\n      return new BoxedNumber({ number: i });\n    };\n    const numbers = [3, 1, 2].map(makeBoxedNumber);\n    numbers[0]\n      .save()\n      .then(() => {\n        return numbers[1].save();\n      })\n      .then(() => {\n        return numbers[2].save();\n      })\n      .then(function () {\n        numbers[1].set('number', 4);\n        numbers[1].save().then(function () {\n          const query = new Parse.Query(BoxedNumber);\n          query.ascending('_updated_at');\n          query.find().then(function (results) {\n            equal(results.length, 3);\n            equal(results[0].get('number'), 3);\n            equal(results[1].get('number'), 2);\n            equal(results[2].get('number'), 4);\n            done();\n          });\n        });\n      });\n  });\n\n  it('order by updatedAt', function (done) {\n    const makeBoxedNumber = function (i) {\n      return new BoxedNumber({ number: i });\n    };\n    const numbers = [3, 1, 2].map(makeBoxedNumber);\n    numbers[0]\n      .save()\n      .then(() => {\n        return numbers[1].save();\n      })\n      .then(() => {\n        return numbers[2].save();\n      })\n      .then(function () {\n        numbers[1].set('number', 4);\n        numbers[1].save().then(function () {\n          const query = new Parse.Query(BoxedNumber);\n          query.descending('_updated_at');\n          query.find().then(function (results) {\n            equal(results.length, 3);\n            equal(results[0].get('number'), 4);\n            equal(results[1].get('number'), 2);\n            equal(results[2].get('number'), 3);\n            done();\n          });\n        });\n      });\n  });\n\n  // Returns a promise\n  function makeTimeObject(start, i) {\n    const time = new Date();\n    time.setSeconds(start.getSeconds() + i);\n    const item = new TestObject({ name: 'item' + i, time: time });\n    return item.save();\n  }\n\n  // Returns a promise for all the time objects\n  function makeThreeTimeObjects() {\n    const start = new Date();\n    let one, two, three;\n    return makeTimeObject(start, 1)\n      .then(o1 => {\n        one = o1;\n        return makeTimeObject(start, 2);\n      })\n      .then(o2 => {\n        two = o2;\n        return makeTimeObject(start, 3);\n      })\n      .then(o3 => {\n        three = o3;\n        return [one, two, three];\n      });\n  }\n\n  it('time equality', function (done) {\n    makeThreeTimeObjects().then(function (list) {\n      const query = new Parse.Query(TestObject);\n      query.equalTo('time', list[1].get('time'));\n      query.find().then(function (results) {\n        equal(results.length, 1);\n        equal(results[0].get('name'), 'item2');\n        done();\n      });\n    });\n  });\n\n  it('time lessThan', function (done) {\n    makeThreeTimeObjects().then(function (list) {\n      const query = new Parse.Query(TestObject);\n      query.lessThan('time', list[2].get('time'));\n      query.find().then(function (results) {\n        equal(results.length, 2);\n        done();\n      });\n    });\n  });\n\n  // This test requires Date objects to be consistently stored as a Date.\n  it('time createdAt', function (done) {\n    makeThreeTimeObjects().then(function (list) {\n      const query = new Parse.Query(TestObject);\n      query.greaterThanOrEqualTo('createdAt', list[0].createdAt);\n      query.find().then(function (results) {\n        equal(results.length, 3);\n        done();\n      });\n    });\n  });\n\n  it('matches string', function (done) {\n    const thing1 = new TestObject();\n    thing1.set('myString', 'football');\n    const thing2 = new TestObject();\n    thing2.set('myString', 'soccer');\n    Parse.Object.saveAll([thing1, thing2]).then(function () {\n      const query = new Parse.Query(TestObject);\n      query.matches('myString', '^fo*\\\\wb[^o]l+$');\n      query.find().then(function (results) {\n        equal(results.length, 1);\n        done();\n      });\n    });\n  });\n\n  it('matches regex', function (done) {\n    const thing1 = new TestObject();\n    thing1.set('myString', 'football');\n    const thing2 = new TestObject();\n    thing2.set('myString', 'soccer');\n    Parse.Object.saveAll([thing1, thing2]).then(function () {\n      const query = new Parse.Query(TestObject);\n      query.matches('myString', /^fo*\\wb[^o]l+$/);\n      query.find().then(function (results) {\n        equal(results.length, 1);\n        done();\n      });\n    });\n  });\n\n  it('case insensitive regex success', function (done) {\n    const thing = new TestObject();\n    thing.set('myString', 'football');\n    Parse.Object.saveAll([thing]).then(function () {\n      const query = new Parse.Query(TestObject);\n      query.matches('myString', 'FootBall', 'i');\n      query.find().then(done);\n    });\n  });\n\n  it('regexes with invalid options fail', function (done) {\n    const query = new Parse.Query(TestObject);\n    query.matches('myString', 'FootBall', 'some invalid option');\n    query\n      .find()\n      .then(done.fail)\n      .catch(e => expect(e.code).toBe(Parse.Error.INVALID_QUERY))\n      .then(done);\n  });\n\n  it('Use a regex that requires all modifiers', function (done) {\n    const thing = new TestObject();\n    thing.set('myString', 'PArSe\\nCom');\n    Parse.Object.saveAll([thing]).then(function () {\n      const query = new Parse.Query(TestObject);\n      query.matches(\n        'myString',\n        \"parse # First fragment. We'll write this in one case but match insensitively\\n\" +\n          '.com  # Second fragment. This can be separated by any character, including newline;' +\n          'however, this comment must end with a newline to recognize it as a comment\\n',\n        'mixs'\n      );\n      query.find().then(\n        function (results) {\n          equal(results.length, 1);\n          done();\n        },\n        function (err) {\n          jfail(err);\n          done();\n        }\n      );\n    });\n  });\n\n  it('Regular expression constructor includes modifiers inline', function (done) {\n    const thing = new TestObject();\n    thing.set('myString', '\\n\\nbuffer\\n\\nparse.COM');\n    Parse.Object.saveAll([thing]).then(function () {\n      const query = new Parse.Query(TestObject);\n      query.matches('myString', /parse\\.com/im);\n      query.find().then(function (results) {\n        equal(results.length, 1);\n        done();\n      });\n    });\n  });\n\n  const someAscii =\n    \"\\\\E' !\\\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTU\" +\n    \"VWXYZ[\\\\]^_`abcdefghijklmnopqrstuvwxyz{|}~'\";\n\n  it('contains', function (done) {\n    Parse.Object.saveAll([\n      new TestObject({ myString: 'zax' + someAscii + 'qub' }),\n      new TestObject({ myString: 'start' + someAscii }),\n      new TestObject({ myString: someAscii + 'end' }),\n      new TestObject({ myString: someAscii }),\n    ]).then(function () {\n      const query = new Parse.Query(TestObject);\n      query.contains('myString', someAscii);\n      query.find().then(function (results) {\n        equal(results.length, 4);\n        done();\n      });\n    });\n  });\n\n  it('nested contains', done => {\n    const sender1 = { group: ['A', 'B'] };\n    const sender2 = { group: ['A', 'C'] };\n    const sender3 = { group: ['B', 'C'] };\n    const obj1 = new TestObject({ sender: sender1 });\n    const obj2 = new TestObject({ sender: sender2 });\n    const obj3 = new TestObject({ sender: sender3 });\n    Parse.Object.saveAll([obj1, obj2, obj3])\n      .then(() => {\n        const query = new Parse.Query(TestObject);\n        query.contains('sender.group', 'A');\n        return query.find();\n      })\n      .then(results => {\n        equal(results.length, 2);\n        done();\n      }, done.fail);\n  });\n\n  it('startsWith', function (done) {\n    Parse.Object.saveAll([\n      new TestObject({ myString: 'zax' + someAscii + 'qub' }),\n      new TestObject({ myString: 'start' + someAscii }),\n      new TestObject({ myString: someAscii + 'end' }),\n      new TestObject({ myString: someAscii }),\n    ]).then(function () {\n      const query = new Parse.Query(TestObject);\n      query.startsWith('myString', someAscii);\n      query.find().then(function (results) {\n        equal(results.length, 2);\n        done();\n      });\n    });\n  });\n\n  it('endsWith', function (done) {\n    Parse.Object.saveAll([\n      new TestObject({ myString: 'zax' + someAscii + 'qub' }),\n      new TestObject({ myString: 'start' + someAscii }),\n      new TestObject({ myString: someAscii + 'end' }),\n      new TestObject({ myString: someAscii }),\n    ]).then(function () {\n      const query = new Parse.Query(TestObject);\n      query.endsWith('myString', someAscii);\n      query.find().then(function (results) {\n        equal(results.length, 2);\n        done();\n      });\n    });\n  });\n\n  it('exists', function (done) {\n    const objects = [];\n    for (const i of [0, 1, 2, 3, 4, 5, 6, 7, 8]) {\n      const item = new TestObject();\n      if (i % 2 === 0) {\n        item.set('x', i + 1);\n      } else {\n        item.set('y', i + 1);\n      }\n      objects.push(item);\n    }\n    Parse.Object.saveAll(objects).then(function () {\n      const query = new Parse.Query(TestObject);\n      query.exists('x');\n      query.find().then(function (results) {\n        equal(results.length, 5);\n        for (const result of results) {\n          ok(result.get('x'));\n        }\n        done();\n      });\n    });\n  });\n\n  it('doesNotExist', function (done) {\n    const objects = [];\n    for (const i of [0, 1, 2, 3, 4, 5, 6, 7, 8]) {\n      const item = new TestObject();\n      if (i % 2 === 0) {\n        item.set('x', i + 1);\n      } else {\n        item.set('y', i + 1);\n      }\n      objects.push(item);\n    }\n    Parse.Object.saveAll(objects).then(function () {\n      const query = new Parse.Query(TestObject);\n      query.doesNotExist('x');\n      query.find().then(function (results) {\n        equal(results.length, 4);\n        for (const result of results) {\n          ok(result.get('y'));\n        }\n        done();\n      });\n    });\n  });\n\n  it('exists relation', function (done) {\n    const objects = [];\n    for (const i of [0, 1, 2, 3, 4, 5, 6, 7, 8]) {\n      const container = new Container();\n      if (i % 2 === 0) {\n        const item = new TestObject();\n        item.set('x', i);\n        container.set('x', item);\n        objects.push(item);\n      } else {\n        container.set('y', i);\n      }\n      objects.push(container);\n    }\n    Parse.Object.saveAll(objects).then(function () {\n      const query = new Parse.Query(Container);\n      query.exists('x');\n      query.find().then(function (results) {\n        equal(results.length, 5);\n        for (const result of results) {\n          ok(result.get('x'));\n        }\n        done();\n      });\n    });\n  });\n\n  it('doesNotExist relation', function (done) {\n    const objects = [];\n    for (const i of [0, 1, 2, 3, 4, 5, 6, 7]) {\n      const container = new Container();\n      if (i % 2 === 0) {\n        const item = new TestObject();\n        item.set('x', i);\n        container.set('x', item);\n        objects.push(item);\n      } else {\n        container.set('y', i);\n      }\n      objects.push(container);\n    }\n    Parse.Object.saveAll(objects).then(function () {\n      const query = new Parse.Query(Container);\n      query.doesNotExist('x');\n      query.find().then(function (results) {\n        equal(results.length, 4);\n        for (const result of results) {\n          ok(result.get('y'));\n        }\n        done();\n      });\n    });\n  });\n\n  it(\"don't include by default\", function (done) {\n    const child = new TestObject();\n    const parent = new Container();\n    child.set('foo', 'bar');\n    parent.set('child', child);\n    Parse.Object.saveAll([child, parent]).then(function () {\n      child._clearServerData();\n      const query = new Parse.Query(Container);\n      query.find().then(function (results) {\n        equal(results.length, 1);\n        const parentAgain = results[0];\n        const goodURL = Parse.serverURL;\n        Parse.serverURL = 'YAAAAAAAAARRRRRGGGGGGGGG';\n        const childAgain = parentAgain.get('child');\n        ok(childAgain);\n        equal(childAgain.get('foo'), undefined);\n        Parse.serverURL = goodURL;\n        done();\n      });\n    });\n  });\n\n  it('include relation', function (done) {\n    const child = new TestObject();\n    const parent = new Container();\n    child.set('foo', 'bar');\n    parent.set('child', child);\n    Parse.Object.saveAll([child, parent]).then(function () {\n      const query = new Parse.Query(Container);\n      query.include('child');\n      query.find().then(function (results) {\n        equal(results.length, 1);\n        const parentAgain = results[0];\n        const goodURL = Parse.serverURL;\n        Parse.serverURL = 'YAAAAAAAAARRRRRGGGGGGGGG';\n        const childAgain = parentAgain.get('child');\n        ok(childAgain);\n        equal(childAgain.get('foo'), 'bar');\n        Parse.serverURL = goodURL;\n        done();\n      });\n    });\n  });\n\n  it('include relation array', function (done) {\n    const child = new TestObject();\n    const parent = new Container();\n    child.set('foo', 'bar');\n    parent.set('child', child);\n    Parse.Object.saveAll([child, parent]).then(function () {\n      const query = new Parse.Query(Container);\n      query.include(['child']);\n      query.find().then(function (results) {\n        equal(results.length, 1);\n        const parentAgain = results[0];\n        const goodURL = Parse.serverURL;\n        Parse.serverURL = 'YAAAAAAAAARRRRRGGGGGGGGG';\n        const childAgain = parentAgain.get('child');\n        ok(childAgain);\n        equal(childAgain.get('foo'), 'bar');\n        Parse.serverURL = goodURL;\n        done();\n      });\n    });\n  });\n\n  it('nested include', function (done) {\n    const Child = Parse.Object.extend('Child');\n    const Parent = Parse.Object.extend('Parent');\n    const Grandparent = Parse.Object.extend('Grandparent');\n    const objects = [];\n    for (let i = 0; i < 5; ++i) {\n      const grandparent = new Grandparent({\n        z: i,\n        parent: new Parent({\n          y: i,\n          child: new Child({\n            x: i,\n          }),\n        }),\n      });\n      objects.push(grandparent);\n    }\n\n    Parse.Object.saveAll(objects).then(function () {\n      const query = new Parse.Query(Grandparent);\n      query.include(['parent.child']);\n      query.find().then(function (results) {\n        equal(results.length, 5);\n        for (const object of results) {\n          equal(object.get('z'), object.get('parent').get('y'));\n          equal(object.get('z'), object.get('parent').get('child').get('x'));\n        }\n        done();\n      });\n    });\n  });\n\n  it(\"include doesn't make dirty wrong\", function (done) {\n    const Parent = Parse.Object.extend('ParentObject');\n    const Child = Parse.Object.extend('ChildObject');\n    const parent = new Parent();\n    const child = new Child();\n    child.set('foo', 'bar');\n    parent.set('child', child);\n\n    Parse.Object.saveAll([child, parent]).then(function () {\n      const query = new Parse.Query(Parent);\n      query.include('child');\n      query.find().then(function (results) {\n        equal(results.length, 1);\n        const parentAgain = results[0];\n        const childAgain = parentAgain.get('child');\n        equal(childAgain.id, child.id);\n        equal(parentAgain.id, parent.id);\n        equal(childAgain.get('foo'), 'bar');\n        equal(false, parentAgain.dirty());\n        equal(false, childAgain.dirty());\n        done();\n      });\n    });\n  });\n\n  it('properly includes array', done => {\n    const objects = [];\n    let total = 0;\n    while (objects.length != 5) {\n      const object = new Parse.Object('AnObject');\n      object.set('key', objects.length);\n      total += objects.length;\n      objects.push(object);\n    }\n    Parse.Object.saveAll(objects)\n      .then(() => {\n        const object = new Parse.Object('AContainer');\n        object.set('objects', objects);\n        return object.save();\n      })\n      .then(() => {\n        const query = new Parse.Query('AContainer');\n        query.include('objects');\n        return query.find();\n      })\n      .then(\n        results => {\n          expect(results.length).toBe(1);\n          const res = results[0];\n          const objects = res.get('objects');\n          expect(objects.length).toBe(5);\n          objects.forEach(object => {\n            total -= object.get('key');\n          });\n          expect(total).toBe(0);\n          done();\n        },\n        () => {\n          fail('should not fail');\n          done();\n        }\n      );\n  });\n\n  it('properly includes array of mixed objects', done => {\n    const objects = [];\n    let total = 0;\n    while (objects.length != 5) {\n      const object = new Parse.Object('AnObject');\n      object.set('key', objects.length);\n      total += objects.length;\n      objects.push(object);\n    }\n    while (objects.length != 10) {\n      const object = new Parse.Object('AnotherObject');\n      object.set('key', objects.length);\n      total += objects.length;\n      objects.push(object);\n    }\n    Parse.Object.saveAll(objects)\n      .then(() => {\n        const object = new Parse.Object('AContainer');\n        object.set('objects', objects);\n        return object.save();\n      })\n      .then(() => {\n        const query = new Parse.Query('AContainer');\n        query.include('objects');\n        return query.find();\n      })\n      .then(\n        results => {\n          expect(results.length).toBe(1);\n          const res = results[0];\n          const objects = res.get('objects');\n          expect(objects.length).toBe(10);\n          objects.forEach(object => {\n            total -= object.get('key');\n          });\n          expect(total).toBe(0);\n          done();\n        },\n        e => {\n          fail('should not fail');\n          fail(JSON.stringify(e));\n          done();\n        }\n      );\n  });\n\n  it('properly nested array of mixed objects with bad ids', done => {\n    const objects = [];\n    let total = 0;\n    while (objects.length != 5) {\n      const object = new Parse.Object('AnObject');\n      object.set('key', objects.length);\n      objects.push(object);\n    }\n    while (objects.length != 10) {\n      const object = new Parse.Object('AnotherObject');\n      object.set('key', objects.length);\n      objects.push(object);\n    }\n    Parse.Object.saveAll(objects)\n      .then(() => {\n        const object = new Parse.Object('AContainer');\n        for (let i = 0; i < objects.length; i++) {\n          if (i % 2 == 0) {\n            objects[i].id = 'randomThing';\n          } else {\n            total += objects[i].get('key');\n          }\n        }\n        object.set('objects', objects);\n        return object.save();\n      })\n      .then(() => {\n        const query = new Parse.Query('AContainer');\n        query.include('objects');\n        return query.find();\n      })\n      .then(\n        results => {\n          expect(results.length).toBe(1);\n          const res = results[0];\n          const objects = res.get('objects');\n          expect(objects.length).toBe(5);\n          objects.forEach(object => {\n            total -= object.get('key');\n          });\n          expect(total).toBe(0);\n          done();\n        },\n        err => {\n          jfail(err);\n          fail('should not fail');\n          done();\n        }\n      );\n  });\n\n  it('properly fetches nested pointers', done => {\n    const color = new Parse.Object('Color');\n    color.set('hex', '#133733');\n    const circle = new Parse.Object('Circle');\n    circle.set('radius', 1337);\n\n    Parse.Object.saveAll([color, circle])\n      .then(() => {\n        circle.set('color', color);\n        const badCircle = new Parse.Object('Circle');\n        badCircle.id = 'badId';\n        const complexFigure = new Parse.Object('ComplexFigure');\n        complexFigure.set('consistsOf', [circle, badCircle]);\n        return complexFigure.save();\n      })\n      .then(() => {\n        const q = new Parse.Query('ComplexFigure');\n        q.include('consistsOf.color');\n        return q.find();\n      })\n      .then(\n        results => {\n          expect(results.length).toBe(1);\n          const figure = results[0];\n          expect(figure.get('consistsOf').length).toBe(1);\n          expect(figure.get('consistsOf')[0].get('color').get('hex')).toBe('#133733');\n          done();\n        },\n        () => {\n          fail('should not fail');\n          done();\n        }\n      );\n  });\n\n  it('result object creation uses current extension', function (done) {\n    const ParentObject = Parse.Object.extend({ className: 'ParentObject' });\n    // Add a foo() method to ChildObject.\n    let ChildObject = Parse.Object.extend('ChildObject', {\n      foo: function () {\n        return 'foo';\n      },\n    });\n\n    const parent = new ParentObject();\n    const child = new ChildObject();\n    parent.set('child', child);\n    Parse.Object.saveAll([child, parent]).then(function () {\n      // Add a bar() method to ChildObject.\n      ChildObject = Parse.Object.extend('ChildObject', {\n        bar: function () {\n          return 'bar';\n        },\n      });\n\n      const query = new Parse.Query(ParentObject);\n      query.include('child');\n      query.find().then(function (results) {\n        equal(results.length, 1);\n        const parentAgain = results[0];\n        const childAgain = parentAgain.get('child');\n        equal(childAgain.foo(), 'foo');\n        equal(childAgain.bar(), 'bar');\n        done();\n      });\n    });\n  });\n\n  it('matches query', function (done) {\n    const ParentObject = Parse.Object.extend('ParentObject');\n    const ChildObject = Parse.Object.extend('ChildObject');\n    const objects = [];\n    for (let i = 0; i < 10; ++i) {\n      objects.push(\n        new ParentObject({\n          child: new ChildObject({ x: i }),\n          x: 10 + i,\n        })\n      );\n    }\n    Parse.Object.saveAll(objects).then(function () {\n      const subQuery = new Parse.Query(ChildObject);\n      subQuery.greaterThan('x', 5);\n      const query = new Parse.Query(ParentObject);\n      query.matchesQuery('child', subQuery);\n      query.find().then(function (results) {\n        equal(results.length, 4);\n        for (const object of results) {\n          ok(object.get('x') > 15);\n        }\n        const query = new Parse.Query(ParentObject);\n        query.doesNotMatchQuery('child', subQuery);\n        query.find().then(function (results) {\n          equal(results.length, 6);\n          for (const object of results) {\n            ok(object.get('x') >= 10);\n            ok(object.get('x') <= 15);\n            done();\n          }\n        });\n      });\n    });\n  });\n\n  it('select query', function (done) {\n    const RestaurantObject = Parse.Object.extend('Restaurant');\n    const PersonObject = Parse.Object.extend('Person');\n    const objects = [\n      new RestaurantObject({ ratings: 5, location: 'Djibouti' }),\n      new RestaurantObject({ ratings: 3, location: 'Ouagadougou' }),\n      new PersonObject({ name: 'Bob', hometown: 'Djibouti' }),\n      new PersonObject({ name: 'Tom', hometown: 'Ouagadougou' }),\n      new PersonObject({ name: 'Billy', hometown: 'Detroit' }),\n    ];\n\n    Parse.Object.saveAll(objects).then(function () {\n      const query = new Parse.Query(RestaurantObject);\n      query.greaterThan('ratings', 4);\n      const mainQuery = new Parse.Query(PersonObject);\n      mainQuery.matchesKeyInQuery('hometown', 'location', query);\n      mainQuery.find().then(function (results) {\n        equal(results.length, 1);\n        equal(results[0].get('name'), 'Bob');\n        done();\n      });\n    });\n  });\n\n  it('$select inside $or', done => {\n    const Restaurant = Parse.Object.extend('Restaurant');\n    const Person = Parse.Object.extend('Person');\n    const objects = [\n      new Restaurant({ ratings: 5, location: 'Djibouti' }),\n      new Restaurant({ ratings: 3, location: 'Ouagadougou' }),\n      new Person({ name: 'Bob', hometown: 'Djibouti' }),\n      new Person({ name: 'Tom', hometown: 'Ouagadougou' }),\n      new Person({ name: 'Billy', hometown: 'Detroit' }),\n    ];\n\n    Parse.Object.saveAll(objects)\n      .then(() => {\n        const subquery = new Parse.Query(Restaurant);\n        subquery.greaterThan('ratings', 4);\n        const query1 = new Parse.Query(Person);\n        query1.matchesKeyInQuery('hometown', 'location', subquery);\n        const query2 = new Parse.Query(Person);\n        query2.equalTo('name', 'Tom');\n        const query = Parse.Query.or(query1, query2);\n        return query.find();\n      })\n      .then(\n        results => {\n          expect(results.length).toEqual(2);\n          done();\n        },\n        error => {\n          jfail(error);\n          done();\n        }\n      );\n  });\n\n  it('$nor valid query', done => {\n    const objects = Array.from(Array(10).keys()).map(rating => {\n      return new TestObject({ rating: rating });\n    });\n\n    const highValue = 5;\n    const lowValue = 3;\n    const options = Object.assign({}, masterKeyOptions, {\n      qs: {\n        where: JSON.stringify({\n          $nor: [{ rating: { $gt: highValue } }, { rating: { $lte: lowValue } }],\n        }),\n      },\n    });\n\n    Parse.Object.saveAll(objects)\n      .then(() => {\n        return request(Object.assign({ url: Parse.serverURL + '/classes/TestObject' }, options));\n      })\n      .then(response => {\n        const results = response.data;\n        expect(results.results.length).toBe(highValue - lowValue);\n        expect(results.results.every(res => res.rating > lowValue && res.rating <= highValue)).toBe(\n          true\n        );\n        done();\n      });\n  });\n\n  it('$nor invalid query - empty array', done => {\n    const options = Object.assign({}, masterKeyOptions, {\n      qs: {\n        where: JSON.stringify({ $nor: [] }),\n      },\n    });\n    const obj = new TestObject();\n    obj\n      .save()\n      .then(() => {\n        return request(Object.assign({ url: Parse.serverURL + '/classes/TestObject' }, options));\n      })\n      .then(done.fail)\n      .catch(response => {\n        equal(response.data.code, Parse.Error.INVALID_QUERY);\n        done();\n      });\n  });\n\n  it('$nor invalid query - wrong type', done => {\n    const options = Object.assign({}, masterKeyOptions, {\n      qs: {\n        where: JSON.stringify({ $nor: 1337 }),\n      },\n    });\n    const obj = new TestObject();\n    obj\n      .save()\n      .then(() => {\n        return request(Object.assign({ url: Parse.serverURL + '/classes/TestObject' }, options));\n      })\n      .then(done.fail)\n      .catch(response => {\n        equal(response.data.code, Parse.Error.INVALID_QUERY);\n        done();\n      });\n  });\n\n  it('dontSelect query', function (done) {\n    const RestaurantObject = Parse.Object.extend('Restaurant');\n    const PersonObject = Parse.Object.extend('Person');\n    const objects = [\n      new RestaurantObject({ ratings: 5, location: 'Djibouti' }),\n      new RestaurantObject({ ratings: 3, location: 'Ouagadougou' }),\n      new PersonObject({ name: 'Bob', hometown: 'Djibouti' }),\n      new PersonObject({ name: 'Tom', hometown: 'Ouagadougou' }),\n      new PersonObject({ name: 'Billy', hometown: 'Djibouti' }),\n    ];\n\n    Parse.Object.saveAll(objects).then(function () {\n      const query = new Parse.Query(RestaurantObject);\n      query.greaterThan('ratings', 4);\n      const mainQuery = new Parse.Query(PersonObject);\n      mainQuery.doesNotMatchKeyInQuery('hometown', 'location', query);\n      mainQuery.find().then(function (results) {\n        equal(results.length, 1);\n        equal(results[0].get('name'), 'Tom');\n        done();\n      });\n    });\n  });\n\n  it('dontSelect query without conditions', function (done) {\n    const RestaurantObject = Parse.Object.extend('Restaurant');\n    const PersonObject = Parse.Object.extend('Person');\n    const objects = [\n      new RestaurantObject({ location: 'Djibouti' }),\n      new RestaurantObject({ location: 'Ouagadougou' }),\n      new PersonObject({ name: 'Bob', hometown: 'Djibouti' }),\n      new PersonObject({ name: 'Tom', hometown: 'Yoloblahblahblah' }),\n      new PersonObject({ name: 'Billy', hometown: 'Ouagadougou' }),\n    ];\n\n    Parse.Object.saveAll(objects).then(function () {\n      const query = new Parse.Query(RestaurantObject);\n      const mainQuery = new Parse.Query(PersonObject);\n      mainQuery.doesNotMatchKeyInQuery('hometown', 'location', query);\n      mainQuery.find().then(results => {\n        equal(results.length, 1);\n        equal(results[0].get('name'), 'Tom');\n        done();\n      });\n    });\n  });\n\n  it('equalTo on same column as $dontSelect should not break $dontSelect functionality (#3678)', function (done) {\n    const AuthorObject = Parse.Object.extend('Author');\n    const BlockedObject = Parse.Object.extend('Blocked');\n    const PostObject = Parse.Object.extend('Post');\n\n    let postAuthor = null;\n    let requestUser = null;\n\n    return new AuthorObject({ name: 'Julius' })\n      .save()\n      .then(user => {\n        postAuthor = user;\n        return new AuthorObject({ name: 'Bob' }).save();\n      })\n      .then(user => {\n        requestUser = user;\n        const objects = [\n          new PostObject({ author: postAuthor, title: 'Lorem ipsum' }),\n          new PostObject({ author: requestUser, title: 'Kafka' }),\n          new PostObject({ author: requestUser, title: 'Brown fox' }),\n          new BlockedObject({\n            blockedBy: postAuthor,\n            blockedUser: requestUser,\n          }),\n        ];\n        return Parse.Object.saveAll(objects);\n      })\n      .then(() => {\n        const banListQuery = new Parse.Query(BlockedObject);\n        banListQuery.equalTo('blockedUser', requestUser);\n\n        return new Parse.Query(PostObject)\n          .equalTo('author', postAuthor)\n          .doesNotMatchKeyInQuery('author', 'blockedBy', banListQuery)\n          .find()\n          .then(r => {\n            expect(r.length).toEqual(0);\n            done();\n          }, done.fail);\n      });\n  });\n\n  it('multiple dontSelect query', function (done) {\n    const RestaurantObject = Parse.Object.extend('Restaurant');\n    const PersonObject = Parse.Object.extend('Person');\n    const objects = [\n      new RestaurantObject({ ratings: 7, location: 'Djibouti2' }),\n      new RestaurantObject({ ratings: 5, location: 'Djibouti' }),\n      new RestaurantObject({ ratings: 3, location: 'Ouagadougou' }),\n      new PersonObject({ name: 'Bob2', hometown: 'Djibouti2' }),\n      new PersonObject({ name: 'Bob', hometown: 'Djibouti' }),\n      new PersonObject({ name: 'Tom', hometown: 'Ouagadougou' }),\n    ];\n\n    Parse.Object.saveAll(objects).then(function () {\n      const query = new Parse.Query(RestaurantObject);\n      query.greaterThan('ratings', 6);\n      const query2 = new Parse.Query(RestaurantObject);\n      query2.lessThan('ratings', 4);\n      const subQuery = new Parse.Query(PersonObject);\n      subQuery.matchesKeyInQuery('hometown', 'location', query);\n      const subQuery2 = new Parse.Query(PersonObject);\n      subQuery2.matchesKeyInQuery('hometown', 'location', query2);\n      const mainQuery = new Parse.Query(PersonObject);\n      mainQuery.doesNotMatchKeyInQuery('objectId', 'objectId', Parse.Query.or(subQuery, subQuery2));\n      mainQuery.find().then(function (results) {\n        equal(results.length, 1);\n        equal(results[0].get('name'), 'Bob');\n        done();\n      });\n    });\n  });\n\n  it('include user', function (done) {\n    Parse.User.signUp('bob', 'password', { age: 21 }).then(function (user) {\n      const TestObject = Parse.Object.extend('TestObject');\n      const obj = new TestObject();\n      obj\n        .save({\n          owner: user,\n        })\n        .then(function (obj) {\n          const query = new Parse.Query(TestObject);\n          query.include('owner');\n          query.get(obj.id).then(function (objAgain) {\n            equal(objAgain.id, obj.id);\n            ok(objAgain.get('owner') instanceof Parse.User);\n            equal(objAgain.get('owner').get('age'), 21);\n            done();\n          }, done.fail);\n        }, done.fail);\n    }, done.fail);\n  });\n\n  it('or queries', function (done) {\n    const objects = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9].map(function (x) {\n      const object = new Parse.Object('BoxedNumber');\n      object.set('x', x);\n      return object;\n    });\n    Parse.Object.saveAll(objects).then(function () {\n      const query1 = new Parse.Query('BoxedNumber');\n      query1.lessThan('x', 2);\n      const query2 = new Parse.Query('BoxedNumber');\n      query2.greaterThan('x', 5);\n      const orQuery = Parse.Query.or(query1, query2);\n      orQuery.find().then(function (results) {\n        equal(results.length, 6);\n        for (const number of results) {\n          ok(number.get('x') < 2 || number.get('x') > 5);\n        }\n        done();\n      });\n    });\n  });\n\n  // This relies on matchesQuery aka the $inQuery operator\n  it('or complex queries', function (done) {\n    const objects = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9].map(function (x) {\n      const child = new Parse.Object('Child');\n      child.set('x', x);\n      const parent = new Parse.Object('Parent');\n      parent.set('child', child);\n      parent.set('y', x);\n      return parent;\n    });\n\n    Parse.Object.saveAll(objects).then(function () {\n      const subQuery = new Parse.Query('Child');\n      subQuery.equalTo('x', 4);\n      const query1 = new Parse.Query('Parent');\n      query1.matchesQuery('child', subQuery);\n      const query2 = new Parse.Query('Parent');\n      query2.lessThan('y', 2);\n      const orQuery = Parse.Query.or(query1, query2);\n      orQuery.find().then(function (results) {\n        equal(results.length, 3);\n        done();\n      });\n    });\n  });\n\n  it('async methods', function (done) {\n    const saves = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9].map(function (x) {\n      const obj = new Parse.Object('TestObject');\n      obj.set('x', x + 1);\n      return obj;\n    });\n\n    Parse.Object.saveAll(saves)\n      .then(function () {\n        const query = new Parse.Query('TestObject');\n        query.ascending('x');\n        return query.first();\n      })\n      .then(function (obj) {\n        equal(obj.get('x'), 1);\n        const query = new Parse.Query('TestObject');\n        query.descending('x');\n        return query.find();\n      })\n      .then(function (results) {\n        equal(results.length, 10);\n        const query = new Parse.Query('TestObject');\n        return query.get(results[0].id);\n      })\n      .then(function (obj1) {\n        equal(obj1.get('x'), 10);\n        const query = new Parse.Query('TestObject');\n        return query.count();\n      })\n      .then(function (count) {\n        equal(count, 10);\n      })\n      .then(function () {\n        done();\n      });\n  });\n\n  it('query.each', function (done) {\n    const TOTAL = 50;\n    const COUNT = 25;\n\n    const items = range(TOTAL).map(function (x) {\n      const obj = new TestObject();\n      obj.set('x', x);\n      return obj;\n    });\n\n    Parse.Object.saveAll(items).then(function () {\n      const query = new Parse.Query(TestObject);\n      query.lessThan('x', COUNT);\n\n      const seen = [];\n      query\n        .each(\n          function (obj) {\n            seen[obj.get('x')] = (seen[obj.get('x')] || 0) + 1;\n          },\n          {\n            batchSize: 10,\n          }\n        )\n        .then(function () {\n          equal(seen.length, COUNT);\n          for (let i = 0; i < COUNT; i++) {\n            equal(seen[i], 1, 'Should have seen object number ' + i);\n          }\n          done();\n        }, done.fail);\n    });\n  });\n\n  it('query.each async', function (done) {\n    const TOTAL = 50;\n    const COUNT = 25;\n\n    expect(COUNT + 1);\n\n    const items = range(TOTAL).map(function (x) {\n      const obj = new TestObject();\n      obj.set('x', x);\n      return obj;\n    });\n\n    const seen = [];\n\n    Parse.Object.saveAll(items)\n      .then(function () {\n        const query = new Parse.Query(TestObject);\n        query.lessThan('x', COUNT);\n        return query.each(\n          function (obj) {\n            return new Promise(resolve => {\n              process.nextTick(function () {\n                seen[obj.get('x')] = (seen[obj.get('x')] || 0) + 1;\n                resolve();\n              });\n            });\n          },\n          {\n            batchSize: 10,\n          }\n        );\n      })\n      .then(function () {\n        equal(seen.length, COUNT);\n        for (let i = 0; i < COUNT; i++) {\n          equal(seen[i], 1, 'Should have seen object number ' + i);\n        }\n        done();\n      });\n  });\n\n  it('query.each fails with order', function (done) {\n    const TOTAL = 50;\n    const COUNT = 25;\n\n    const items = range(TOTAL).map(function (x) {\n      const obj = new TestObject();\n      obj.set('x', x);\n      return obj;\n    });\n\n    const seen = [];\n\n    Parse.Object.saveAll(items)\n      .then(function () {\n        const query = new Parse.Query(TestObject);\n        query.lessThan('x', COUNT);\n        query.ascending('x');\n        return query.each(function (obj) {\n          seen[obj.get('x')] = (seen[obj.get('x')] || 0) + 1;\n        });\n      })\n      .then(\n        function () {\n          ok(false, 'This should have failed.');\n          done();\n        },\n        function () {\n          done();\n        }\n      );\n  });\n\n  it('query.each fails with skip', function (done) {\n    const TOTAL = 50;\n    const COUNT = 25;\n\n    const items = range(TOTAL).map(function (x) {\n      const obj = new TestObject();\n      obj.set('x', x);\n      return obj;\n    });\n\n    const seen = [];\n\n    Parse.Object.saveAll(items)\n      .then(function () {\n        const query = new Parse.Query(TestObject);\n        query.lessThan('x', COUNT);\n        query.skip(5);\n        return query.each(function (obj) {\n          seen[obj.get('x')] = (seen[obj.get('x')] || 0) + 1;\n        });\n      })\n      .then(\n        function () {\n          ok(false, 'This should have failed.');\n          done();\n        },\n        function () {\n          done();\n        }\n      );\n  });\n\n  it('query.each fails with limit', function (done) {\n    const TOTAL = 50;\n    const COUNT = 25;\n\n    expect(0);\n\n    const items = range(TOTAL).map(function (x) {\n      const obj = new TestObject();\n      obj.set('x', x);\n      return obj;\n    });\n\n    const seen = [];\n\n    Parse.Object.saveAll(items)\n      .then(function () {\n        const query = new Parse.Query(TestObject);\n        query.lessThan('x', COUNT);\n        query.limit(5);\n        return query.each(function (obj) {\n          seen[obj.get('x')] = (seen[obj.get('x')] || 0) + 1;\n        });\n      })\n      .then(\n        function () {\n          ok(false, 'This should have failed.');\n          done();\n        },\n        function () {\n          done();\n        }\n      );\n  });\n\n  it('select keys query JS SDK', async () => {\n    const obj = new TestObject({ foo: 'baz', bar: 1, qux: 2 });\n    await obj.save();\n    obj._clearServerData();\n    const query1 = new Parse.Query(TestObject);\n    query1.select('foo');\n    const result1 = await query1.first();\n    ok(result1.id, 'expected object id to be set');\n    ok(result1.createdAt, 'expected object createdAt to be set');\n    ok(result1.updatedAt, 'expected object updatedAt to be set');\n    ok(!result1.dirty(), 'expected result not to be dirty');\n    strictEqual(result1.get('foo'), 'baz');\n    strictEqual(result1.get('bar'), undefined, \"expected 'bar' field to be unset\");\n    strictEqual(result1.get('qux'), undefined, \"expected 'qux' field to be unset\");\n\n    const result2 = await result1.fetch();\n    strictEqual(result2.get('foo'), 'baz');\n    strictEqual(result2.get('bar'), 1);\n    strictEqual(result2.get('qux'), 2);\n\n    obj._clearServerData();\n    const query2 = new Parse.Query(TestObject);\n    query2.select();\n    const result3 = await query2.first();\n    ok(result3.id, 'expected object id to be set');\n    ok(result3.createdAt, 'expected object createdAt to be set');\n    ok(result3.updatedAt, 'expected object updatedAt to be set');\n    ok(!result3.dirty(), 'expected result not to be dirty');\n    strictEqual(result3.get('foo'), undefined, \"expected 'foo' field to be unset\");\n    strictEqual(result3.get('bar'), undefined, \"expected 'bar' field to be unset\");\n    strictEqual(result3.get('qux'), undefined, \"expected 'qux' field to be unset\");\n\n    obj._clearServerData();\n    const query3 = new Parse.Query(TestObject);\n    query3.select([]);\n    const result4 = await query3.first();\n    ok(result4.id, 'expected object id to be set');\n    ok(result4.createdAt, 'expected object createdAt to be set');\n    ok(result4.updatedAt, 'expected object updatedAt to be set');\n    ok(!result4.dirty(), 'expected result not to be dirty');\n    strictEqual(result4.get('foo'), undefined, \"expected 'foo' field to be unset\");\n    strictEqual(result4.get('bar'), undefined, \"expected 'bar' field to be unset\");\n    strictEqual(result4.get('qux'), undefined, \"expected 'qux' field to be unset\");\n\n    obj._clearServerData();\n    const query4 = new Parse.Query(TestObject);\n    query4.select(['foo']);\n    const result5 = await query4.first();\n    ok(result5.id, 'expected object id to be set');\n    ok(result5.createdAt, 'expected object createdAt to be set');\n    ok(result5.updatedAt, 'expected object updatedAt to be set');\n    ok(!result5.dirty(), 'expected result not to be dirty');\n    strictEqual(result5.get('foo'), 'baz');\n    strictEqual(result5.get('bar'), undefined, \"expected 'bar' field to be unset\");\n    strictEqual(result5.get('qux'), undefined, \"expected 'qux' field to be unset\");\n\n    obj._clearServerData();\n    const query5 = new Parse.Query(TestObject);\n    query5.select(['foo', 'bar']);\n    const result6 = await query5.first();\n    ok(result6.id, 'expected object id to be set');\n    ok(!result6.dirty(), 'expected result not to be dirty');\n    strictEqual(result6.get('foo'), 'baz');\n    strictEqual(result6.get('bar'), 1);\n    strictEqual(result6.get('qux'), undefined, \"expected 'qux' field to be unset\");\n\n    obj._clearServerData();\n    const query6 = new Parse.Query(TestObject);\n    query6.select(['foo', 'bar', 'qux']);\n    const result7 = await query6.first();\n    ok(result7.id, 'expected object id to be set');\n    ok(!result7.dirty(), 'expected result not to be dirty');\n    strictEqual(result7.get('foo'), 'baz');\n    strictEqual(result7.get('bar'), 1);\n    strictEqual(result7.get('qux'), 2);\n\n    obj._clearServerData();\n    const query7 = new Parse.Query(TestObject);\n    query7.select('foo', 'bar');\n    const result8 = await query7.first();\n    ok(result8.id, 'expected object id to be set');\n    ok(!result8.dirty(), 'expected result not to be dirty');\n    strictEqual(result8.get('foo'), 'baz');\n    strictEqual(result8.get('bar'), 1);\n    strictEqual(result8.get('qux'), undefined, \"expected 'qux' field to be unset\");\n\n    obj._clearServerData();\n    const query8 = new Parse.Query(TestObject);\n    query8.select('foo', 'bar', 'qux');\n    const result9 = await query8.first();\n    ok(result9.id, 'expected object id to be set');\n    ok(!result9.dirty(), 'expected result not to be dirty');\n    strictEqual(result9.get('foo'), 'baz');\n    strictEqual(result9.get('bar'), 1);\n    strictEqual(result9.get('qux'), 2);\n  });\n\n  it('select keys (arrays)', async () => {\n    const obj = new TestObject({ foo: 'baz', bar: 1, hello: 'world' });\n    await obj.save();\n\n    const response = await request({\n      url: Parse.serverURL + '/classes/TestObject',\n      qs: {\n        keys: 'hello',\n        where: JSON.stringify({ objectId: obj.id }),\n      },\n      headers: masterKeyHeaders,\n    });\n    expect(response.data.results[0].foo).toBeUndefined();\n    expect(response.data.results[0].bar).toBeUndefined();\n    expect(response.data.results[0].hello).toBe('world');\n\n    const response2 = await request({\n      url: Parse.serverURL + '/classes/TestObject',\n      qs: {\n        keys: ['foo', 'hello'],\n        where: JSON.stringify({ objectId: obj.id }),\n      },\n      headers: masterKeyHeaders,\n    });\n    expect(response2.data.results[0].foo).toBe('baz');\n    expect(response2.data.results[0].bar).toBeUndefined();\n    expect(response2.data.results[0].hello).toBe('world');\n\n    const response3 = await request({\n      url: Parse.serverURL + '/classes/TestObject',\n      qs: {\n        keys: ['foo', 'bar', 'hello'],\n        where: JSON.stringify({ objectId: obj.id }),\n      },\n      headers: masterKeyHeaders,\n    });\n    expect(response3.data.results[0].foo).toBe('baz');\n    expect(response3.data.results[0].bar).toBe(1);\n    expect(response3.data.results[0].hello).toBe('world');\n\n    const response4 = await request({\n      url: Parse.serverURL + '/classes/TestObject',\n      qs: {\n        keys: [''],\n        where: JSON.stringify({ objectId: obj.id }),\n      },\n      headers: masterKeyHeaders,\n    });\n    ok(response4.data.results[0].objectId, 'expected objectId to be set');\n    ok(response4.data.results[0].createdAt, 'expected object createdAt to be set');\n    ok(response4.data.results[0].updatedAt, 'expected object updatedAt to be set');\n    expect(response4.data.results[0].foo).toBeUndefined();\n    expect(response4.data.results[0].bar).toBeUndefined();\n    expect(response4.data.results[0].hello).toBeUndefined();\n\n    const response5 = await request({\n      url: Parse.serverURL + '/classes/TestObject',\n      qs: {\n        keys: [],\n        where: JSON.stringify({ objectId: obj.id }),\n      },\n      headers: masterKeyHeaders,\n    });\n    ok(response5.data.results[0].objectId, 'expected objectId to be set');\n    ok(response5.data.results[0].createdAt, 'expected object createdAt to be set');\n    ok(response5.data.results[0].updatedAt, 'expected object updatedAt to be set');\n    expect(response5.data.results[0].foo).toBe('baz');\n    expect(response5.data.results[0].bar).toBe(1);\n    expect(response5.data.results[0].hello).toBe('world');\n  });\n\n  it('select keys (strings)', async () => {\n    const obj = new TestObject({ foo: 'baz', bar: 1, hello: 'world' });\n    await obj.save();\n\n    const response = await request({\n      url: Parse.serverURL + '/classes/TestObject',\n      qs: {\n        keys: '',\n        where: JSON.stringify({ objectId: obj.id }),\n      },\n      headers: masterKeyHeaders,\n    });\n    ok(response.data.results[0].objectId, 'expected objectId to be set');\n    ok(response.data.results[0].createdAt, 'expected object createdAt to be set');\n    ok(response.data.results[0].updatedAt, 'expected object updatedAt to be set');\n    expect(response.data.results[0].foo).toBeUndefined();\n    expect(response.data.results[0].bar).toBeUndefined();\n    expect(response.data.results[0].hello).toBeUndefined();\n\n    const response2 = await request({\n      url: Parse.serverURL + '/classes/TestObject',\n      qs: {\n        keys: '[\"foo\", \"hello\"]',\n        where: JSON.stringify({ objectId: obj.id }),\n      },\n      headers: masterKeyHeaders,\n    });\n    ok(response2.data.results[0].objectId, 'expected objectId to be set');\n    ok(response2.data.results[0].createdAt, 'expected object createdAt to be set');\n    ok(response2.data.results[0].updatedAt, 'expected object updatedAt to be set');\n    expect(response2.data.results[0].foo).toBe('baz');\n    expect(response2.data.results[0].bar).toBeUndefined();\n    expect(response2.data.results[0].hello).toBe('world');\n\n    const response3 = await request({\n      url: Parse.serverURL + '/classes/TestObject',\n      qs: {\n        keys: '[\"foo\", \"bar\", \"hello\"]',\n        where: JSON.stringify({ objectId: obj.id }),\n      },\n      headers: masterKeyHeaders,\n    });\n    ok(response3.data.results[0].objectId, 'expected objectId to be set');\n    ok(response3.data.results[0].createdAt, 'expected object createdAt to be set');\n    ok(response3.data.results[0].updatedAt, 'expected object updatedAt to be set');\n    expect(response3.data.results[0].foo).toBe('baz');\n    expect(response3.data.results[0].bar).toBe(1);\n    expect(response3.data.results[0].hello).toBe('world');\n  });\n\n  it('exclude keys query JS SDK', async () => {\n    const obj = new TestObject({ foo: 'baz', bar: 1, qux: 2 });\n\n    await obj.save();\n    obj._clearServerData();\n    const query1 = new Parse.Query(TestObject);\n    query1.exclude('foo');\n    const result1 = await query1.first();\n    ok(result1.id, 'expected object id to be set');\n    ok(result1.createdAt, 'expected object createdAt to be set');\n    ok(result1.updatedAt, 'expected object updatedAt to be set');\n    ok(!result1.dirty(), 'expected result not to be dirty');\n    strictEqual(result1.get('foo'), undefined, \"expected 'bar' field to be unset\");\n    strictEqual(result1.get('bar'), 1);\n    strictEqual(result1.get('qux'), 2);\n\n    const result2 = await result1.fetch();\n    strictEqual(result2.get('foo'), 'baz');\n    strictEqual(result2.get('bar'), 1);\n    strictEqual(result2.get('qux'), 2);\n\n    obj._clearServerData();\n    const query2 = new Parse.Query(TestObject);\n    query2.exclude();\n    const result3 = await query2.first();\n    ok(result3.id, 'expected object id to be set');\n    ok(result3.createdAt, 'expected object createdAt to be set');\n    ok(result3.updatedAt, 'expected object updatedAt to be set');\n    ok(!result3.dirty(), 'expected result not to be dirty');\n    strictEqual(result3.get('foo'), 'baz');\n    strictEqual(result3.get('bar'), 1);\n    strictEqual(result3.get('qux'), 2);\n\n    obj._clearServerData();\n    const query3 = new Parse.Query(TestObject);\n    query3.exclude([]);\n    const result4 = await query3.first();\n    ok(result4.id, 'expected object id to be set');\n    ok(result4.createdAt, 'expected object createdAt to be set');\n    ok(result4.updatedAt, 'expected object updatedAt to be set');\n    ok(!result4.dirty(), 'expected result not to be dirty');\n    strictEqual(result4.get('foo'), 'baz');\n    strictEqual(result4.get('bar'), 1);\n    strictEqual(result4.get('qux'), 2);\n\n    obj._clearServerData();\n    const query4 = new Parse.Query(TestObject);\n    query4.exclude(['foo']);\n    const result5 = await query4.first();\n    ok(result5.id, 'expected object id to be set');\n    ok(result5.createdAt, 'expected object createdAt to be set');\n    ok(result5.updatedAt, 'expected object updatedAt to be set');\n    ok(!result5.dirty(), 'expected result not to be dirty');\n    strictEqual(result5.get('foo'), undefined, \"expected 'bar' field to be unset\");\n    strictEqual(result5.get('bar'), 1);\n    strictEqual(result5.get('qux'), 2);\n\n    obj._clearServerData();\n    const query5 = new Parse.Query(TestObject);\n    query5.exclude(['foo', 'bar']);\n    const result6 = await query5.first();\n    ok(result6.id, 'expected object id to be set');\n    ok(!result6.dirty(), 'expected result not to be dirty');\n    strictEqual(result6.get('foo'), undefined, \"expected 'bar' field to be unset\");\n    strictEqual(result6.get('bar'), undefined, \"expected 'bar' field to be unset\");\n    strictEqual(result6.get('qux'), 2);\n\n    obj._clearServerData();\n    const query6 = new Parse.Query(TestObject);\n    query6.exclude(['foo', 'bar', 'qux']);\n    const result7 = await query6.first();\n    ok(result7.id, 'expected object id to be set');\n    ok(!result7.dirty(), 'expected result not to be dirty');\n    strictEqual(result7.get('foo'), undefined, \"expected 'bar' field to be unset\");\n    strictEqual(result7.get('bar'), undefined, \"expected 'bar' field to be unset\");\n    strictEqual(result7.get('qux'), undefined, \"expected 'bar' field to be unset\");\n\n    obj._clearServerData();\n    const query7 = new Parse.Query(TestObject);\n    query7.exclude('foo');\n    const result8 = await query7.first();\n    ok(result8.id, 'expected object id to be set');\n    ok(!result8.dirty(), 'expected result not to be dirty');\n    strictEqual(result8.get('foo'), undefined, \"expected 'bar' field to be unset\");\n    strictEqual(result8.get('bar'), 1);\n    strictEqual(result8.get('qux'), 2);\n\n    obj._clearServerData();\n    const query8 = new Parse.Query(TestObject);\n    query8.exclude('foo', 'bar');\n    const result9 = await query8.first();\n    ok(result9.id, 'expected object id to be set');\n    ok(!result9.dirty(), 'expected result not to be dirty');\n    strictEqual(result9.get('foo'), undefined, \"expected 'bar' field to be unset\");\n    strictEqual(result9.get('bar'), undefined, \"expected 'bar' field to be unset\");\n    strictEqual(result9.get('qux'), 2);\n\n    obj._clearServerData();\n    const query9 = new Parse.Query(TestObject);\n    query9.exclude('foo', 'bar', 'qux');\n    const result10 = await query9.first();\n    ok(result10.id, 'expected object id to be set');\n    ok(!result10.dirty(), 'expected result not to be dirty');\n    strictEqual(result10.get('foo'), undefined, \"expected 'bar' field to be unset\");\n    strictEqual(result10.get('bar'), undefined, \"expected 'bar' field to be unset\");\n    strictEqual(result10.get('qux'), undefined, \"expected 'bar' field to be unset\");\n  });\n\n  it('exclude keys (arrays)', async () => {\n    const obj = new TestObject({ foo: 'baz', hello: 'world' });\n    await obj.save();\n\n    const response = await request({\n      url: Parse.serverURL + '/classes/TestObject',\n      qs: {\n        excludeKeys: ['foo'],\n        where: JSON.stringify({ objectId: obj.id }),\n      },\n      headers: masterKeyHeaders,\n    });\n    ok(response.data.results[0].objectId, 'expected objectId to be set');\n    ok(response.data.results[0].createdAt, 'expected object createdAt to be set');\n    ok(response.data.results[0].updatedAt, 'expected object updatedAt to be set');\n    expect(response.data.results[0].foo).toBeUndefined();\n    expect(response.data.results[0].hello).toBe('world');\n\n    const response2 = await request({\n      url: Parse.serverURL + '/classes/TestObject',\n      qs: {\n        excludeKeys: ['foo', 'hello'],\n        where: JSON.stringify({ objectId: obj.id }),\n      },\n      headers: masterKeyHeaders,\n    });\n    ok(response2.data.results[0].objectId, 'expected objectId to be set');\n    ok(response2.data.results[0].createdAt, 'expected object createdAt to be set');\n    ok(response2.data.results[0].updatedAt, 'expected object updatedAt to be set');\n    expect(response2.data.results[0].foo).toBeUndefined();\n    expect(response2.data.results[0].hello).toBeUndefined();\n\n    const response3 = await request({\n      url: Parse.serverURL + '/classes/TestObject',\n      qs: {\n        excludeKeys: [],\n        where: JSON.stringify({ objectId: obj.id }),\n      },\n      headers: masterKeyHeaders,\n    });\n    ok(response3.data.results[0].objectId, 'expected objectId to be set');\n    ok(response3.data.results[0].createdAt, 'expected object createdAt to be set');\n    ok(response3.data.results[0].updatedAt, 'expected object updatedAt to be set');\n    expect(response3.data.results[0].foo).toBe('baz');\n    expect(response3.data.results[0].hello).toBe('world');\n\n    const response4 = await request({\n      url: Parse.serverURL + '/classes/TestObject',\n      qs: {\n        excludeKeys: [''],\n        where: JSON.stringify({ objectId: obj.id }),\n      },\n      headers: masterKeyHeaders,\n    });\n    ok(response4.data.results[0].objectId, 'expected objectId to be set');\n    ok(response4.data.results[0].createdAt, 'expected object createdAt to be set');\n    ok(response4.data.results[0].updatedAt, 'expected object updatedAt to be set');\n    expect(response4.data.results[0].foo).toBe('baz');\n    expect(response4.data.results[0].hello).toBe('world');\n  });\n\n  it('exclude keys (strings)', async () => {\n    const obj = new TestObject({ foo: 'baz', hello: 'world' });\n    await obj.save();\n\n    const response = await request({\n      url: Parse.serverURL + '/classes/TestObject',\n      qs: {\n        excludeKeys: 'foo',\n        where: JSON.stringify({ objectId: obj.id }),\n      },\n      headers: masterKeyHeaders,\n    });\n    ok(response.data.results[0].objectId, 'expected objectId to be set');\n    ok(response.data.results[0].createdAt, 'expected object createdAt to be set');\n    ok(response.data.results[0].updatedAt, 'expected object updatedAt to be set');\n    expect(response.data.results[0].foo).toBeUndefined();\n    expect(response.data.results[0].hello).toBe('world');\n\n    const response2 = await request({\n      url: Parse.serverURL + '/classes/TestObject',\n      qs: {\n        excludeKeys: '',\n        where: JSON.stringify({ objectId: obj.id }),\n      },\n      headers: masterKeyHeaders,\n    });\n    ok(response2.data.results[0].objectId, 'expected objectId to be set');\n    ok(response2.data.results[0].createdAt, 'expected object createdAt to be set');\n    ok(response2.data.results[0].updatedAt, 'expected object updatedAt to be set');\n    expect(response2.data.results[0].foo).toBe('baz');\n    expect(response2.data.results[0].hello).toBe('world');\n\n    const response3 = await request({\n      url: Parse.serverURL + '/classes/TestObject',\n      qs: {\n        excludeKeys: '[\"hello\"]',\n        where: JSON.stringify({ objectId: obj.id }),\n      },\n      headers: masterKeyHeaders,\n    });\n    ok(response3.data.results[0].objectId, 'expected objectId to be set');\n    ok(response3.data.results[0].createdAt, 'expected object createdAt to be set');\n    ok(response3.data.results[0].updatedAt, 'expected object updatedAt to be set');\n    expect(response3.data.results[0].foo).toBe('baz');\n    expect(response3.data.results[0].hello).toBeUndefined();\n\n    const response4 = await request({\n      url: Parse.serverURL + '/classes/TestObject',\n      qs: {\n        excludeKeys: '[\"foo\", \"hello\"]',\n        where: JSON.stringify({ objectId: obj.id }),\n      },\n      headers: masterKeyHeaders,\n    });\n    ok(response4.data.results[0].objectId, 'expected objectId to be set');\n    ok(response4.data.results[0].createdAt, 'expected object createdAt to be set');\n    ok(response4.data.results[0].updatedAt, 'expected object updatedAt to be set');\n    expect(response4.data.results[0].foo).toBeUndefined();\n    expect(response4.data.results[0].hello).toBeUndefined();\n  });\n\n  it('exclude keys with select same key', async () => {\n    const obj = new TestObject({ foo: 'baz', hello: 'world' });\n    await obj.save();\n\n    const response = await request({\n      url: Parse.serverURL + '/classes/TestObject',\n      qs: {\n        keys: 'foo',\n        excludeKeys: 'foo',\n        where: JSON.stringify({ objectId: obj.id }),\n      },\n      headers: masterKeyHeaders,\n    });\n    expect(response.data.results[0].foo).toBeUndefined();\n    expect(response.data.results[0].hello).toBeUndefined();\n  });\n\n  it('exclude keys with select different key', async () => {\n    const obj = new TestObject({ foo: 'baz', hello: 'world' });\n    await obj.save();\n\n    const response = await request({\n      url: Parse.serverURL + '/classes/TestObject',\n      qs: {\n        keys: 'foo,hello',\n        excludeKeys: 'foo',\n        where: JSON.stringify({ objectId: obj.id }),\n      },\n      headers: masterKeyHeaders,\n    });\n    expect(response.data.results[0].foo).toBeUndefined();\n    expect(response.data.results[0].hello).toBe('world');\n  });\n\n  it('exclude keys with include same key', async () => {\n    const pointer = new TestObject();\n    await pointer.save();\n    const obj = new TestObject({ child: pointer, hello: 'world' });\n    await obj.save();\n\n    const response = await request({\n      url: Parse.serverURL + '/classes/TestObject',\n      qs: {\n        include: 'child',\n        excludeKeys: 'child',\n        where: JSON.stringify({ objectId: obj.id }),\n      },\n      headers: masterKeyHeaders,\n    });\n    expect(response.data.results[0].child).toBeUndefined();\n    expect(response.data.results[0].hello).toBe('world');\n  });\n\n  it('exclude keys with include different key', async () => {\n    const pointer = new TestObject();\n    await pointer.save();\n    const obj = new TestObject({\n      child1: pointer,\n      child2: pointer,\n      hello: 'world',\n    });\n    await obj.save();\n\n    const response = await request({\n      url: Parse.serverURL + '/classes/TestObject',\n      qs: {\n        include: 'child1,child2',\n        excludeKeys: 'child1',\n        where: JSON.stringify({ objectId: obj.id }),\n      },\n      headers: masterKeyHeaders,\n    });\n    expect(response.data.results[0].child1).toBeUndefined();\n    expect(response.data.results[0].child2.objectId).toEqual(pointer.id);\n    expect(response.data.results[0].hello).toBe('world');\n  });\n\n  it('exclude keys with includeAll', async () => {\n    const pointer = new TestObject();\n    await pointer.save();\n    const obj = new TestObject({\n      child1: pointer,\n      child2: pointer,\n      hello: 'world',\n    });\n    await obj.save();\n\n    const response = await request({\n      url: Parse.serverURL + '/classes/TestObject',\n      qs: {\n        includeAll: true,\n        excludeKeys: 'child1',\n        where: JSON.stringify({ objectId: obj.id }),\n      },\n      headers: masterKeyHeaders,\n    });\n    expect(response.data.results[0].child).toBeUndefined();\n    expect(response.data.results[0].child2.objectId).toEqual(pointer.id);\n    expect(response.data.results[0].hello).toBe('world');\n  });\n\n  it('select keys with each query', function (done) {\n    const obj = new TestObject({ foo: 'baz', bar: 1 });\n\n    obj.save().then(function () {\n      obj._clearServerData();\n      const query = new Parse.Query(TestObject);\n      query.select('foo');\n      query\n        .each(function (result) {\n          ok(result.id, 'expected object id to be set');\n          ok(result.createdAt, 'expected object createdAt to be set');\n          ok(result.updatedAt, 'expected object updatedAt to be set');\n          ok(!result.dirty(), 'expected result not to be dirty');\n          strictEqual(result.get('foo'), 'baz');\n          strictEqual(result.get('bar'), undefined, 'expected \"bar\" field to be unset');\n        })\n        .then(\n          function () {\n            done();\n          },\n          function (err) {\n            jfail(err);\n            done();\n          }\n        );\n    });\n  });\n\n  it('notEqual with array of pointers', done => {\n    const children = [];\n    const parents = [];\n    const promises = [];\n    for (let i = 0; i < 2; i++) {\n      const proc = iter => {\n        const child = new Parse.Object('Child');\n        children.push(child);\n        const parent = new Parse.Object('Parent');\n        parents.push(parent);\n        promises.push(\n          child.save().then(() => {\n            parents[iter].set('child', [children[iter]]);\n            return parents[iter].save();\n          })\n        );\n      };\n      proc(i);\n    }\n    Promise.all(promises)\n      .then(() => {\n        const query = new Parse.Query('Parent');\n        query.notEqualTo('child', children[0]);\n        return query.find();\n      })\n      .then(results => {\n        expect(results.length).toEqual(1);\n        expect(results[0].id).toEqual(parents[1].id);\n        done();\n      })\n      .catch(error => {\n        console.log(error);\n      });\n  });\n\n  // PG don't support creating a null column\n  it_exclude_dbs(['postgres'])('querying for null value', done => {\n    const obj = new Parse.Object('TestObject');\n    obj.set('aNull', null);\n    obj\n      .save()\n      .then(() => {\n        const query = new Parse.Query('TestObject');\n        query.equalTo('aNull', null);\n        return query.find();\n      })\n      .then(results => {\n        expect(results.length).toEqual(1);\n        expect(results[0].get('aNull')).toEqual(null);\n        done();\n      });\n  });\n\n  it('query within dictionary', done => {\n    const promises = [];\n    for (let i = 0; i < 2; i++) {\n      const proc = iter => {\n        const obj = new Parse.Object('TestObject');\n        obj.set('aDict', { x: iter + 1, y: iter + 2 });\n        promises.push(obj.save());\n      };\n      proc(i);\n    }\n    Promise.all(promises)\n      .then(() => {\n        const query = new Parse.Query('TestObject');\n        query.equalTo('aDict.x', 1);\n        return query.find();\n      })\n      .then(\n        results => {\n          expect(results.length).toEqual(1);\n          done();\n        },\n        error => {\n          console.log(error);\n        }\n      );\n  });\n\n  it('supports include on the wrong key type (#2262)', function (done) {\n    const childObject = new Parse.Object('TestChildObject');\n    childObject.set('hello', 'world');\n    childObject\n      .save()\n      .then(() => {\n        const obj = new Parse.Object('TestObject');\n        obj.set('foo', 'bar');\n        obj.set('child', childObject);\n        return obj.save();\n      })\n      .then(() => {\n        const q = new Parse.Query('TestObject');\n        q.include('child');\n        q.include('child.parent');\n        q.include('createdAt');\n        q.include('createdAt.createdAt');\n        return q.find();\n      })\n      .then(\n        objs => {\n          expect(objs.length).toBe(1);\n          expect(objs[0].get('child').get('hello')).toEqual('world');\n          expect(objs[0].createdAt instanceof Date).toBe(true);\n          done();\n        },\n        () => {\n          fail('should not fail');\n          done();\n        }\n      );\n  });\n\n  it('query match on array with single object', done => {\n    const target = {\n      __type: 'Pointer',\n      className: 'TestObject',\n      objectId: 'abc123',\n    };\n    const obj = new Parse.Object('TestObject');\n    obj.set('someObjs', [target]);\n    obj\n      .save()\n      .then(() => {\n        const query = new Parse.Query('TestObject');\n        query.equalTo('someObjs', target);\n        return query.find();\n      })\n      .then(\n        results => {\n          expect(results.length).toEqual(1);\n          done();\n        },\n        error => {\n          console.log(error);\n        }\n      );\n  });\n\n  it('query match on array with multiple objects', done => {\n    const target1 = {\n      __type: 'Pointer',\n      className: 'TestObject',\n      objectId: 'abc',\n    };\n    const target2 = {\n      __type: 'Pointer',\n      className: 'TestObject',\n      objectId: '123',\n    };\n    const obj = new Parse.Object('TestObject');\n    obj.set('someObjs', [target1, target2]);\n    obj\n      .save()\n      .then(() => {\n        const query = new Parse.Query('TestObject');\n        query.equalTo('someObjs', target1);\n        return query.find();\n      })\n      .then(\n        results => {\n          expect(results.length).toEqual(1);\n          done();\n        },\n        error => {\n          console.log(error);\n        }\n      );\n  });\n\n  it('query should not match on array when searching for null', done => {\n    const target = {\n      __type: 'Pointer',\n      className: 'TestObject',\n      objectId: '123',\n    };\n    const obj = new Parse.Object('TestObject');\n    obj.set('someKey', 'someValue');\n    obj.set('someObjs', [target]);\n    obj\n      .save()\n      .then(() => {\n        const query = new Parse.Query('TestObject');\n        query.equalTo('someKey', 'someValue');\n        query.equalTo('someObjs', null);\n        return query.find();\n      })\n      .then(\n        results => {\n          expect(results.length).toEqual(0);\n          done();\n        },\n        error => {\n          console.log(error);\n        }\n      );\n  });\n\n  // #371\n  it('should properly interpret a query v1', done => {\n    const query = new Parse.Query('C1');\n    const auxQuery = new Parse.Query('C1');\n    query.matchesKeyInQuery('A1', 'A2', auxQuery);\n    query.include('A3');\n    query.include('A2');\n    query.find().then(\n      () => {\n        done();\n      },\n      err => {\n        jfail(err);\n        fail('should not failt');\n        done();\n      }\n    );\n  });\n\n  it('should properly interpret a query v2', done => {\n    const user = new Parse.User();\n    user.set('username', 'foo');\n    user.set('password', 'bar');\n    return user\n      .save()\n      .then(user => {\n        const objIdQuery = new Parse.Query('_User').equalTo('objectId', user.id);\n        const blockedUserQuery = user.relation('blockedUsers').query();\n\n        const aResponseQuery = new Parse.Query('MatchRelationshipActivityResponse');\n        aResponseQuery.equalTo('userA', user);\n        aResponseQuery.equalTo('userAResponse', 1);\n\n        const bResponseQuery = new Parse.Query('MatchRelationshipActivityResponse');\n        bResponseQuery.equalTo('userB', user);\n        bResponseQuery.equalTo('userBResponse', 1);\n\n        const matchOr = Parse.Query.or(aResponseQuery, bResponseQuery);\n        const matchRelationshipA = new Parse.Query('_User');\n        matchRelationshipA.matchesKeyInQuery('objectId', 'userAObjectId', matchOr);\n        const matchRelationshipB = new Parse.Query('_User');\n        matchRelationshipB.matchesKeyInQuery('objectId', 'userBObjectId', matchOr);\n\n        const orQuery = Parse.Query.or(\n          objIdQuery,\n          blockedUserQuery,\n          matchRelationshipA,\n          matchRelationshipB\n        );\n        const query = new Parse.Query('_User');\n        query.doesNotMatchQuery('objectId', orQuery);\n        return query.find();\n      })\n      .then(\n        () => {\n          done();\n        },\n        err => {\n          jfail(err);\n          fail('should not fail');\n          done();\n        }\n      );\n  });\n\n  it('should match a key in an array (#3195)', function (done) {\n    const AuthorObject = Parse.Object.extend('Author');\n    const GroupObject = Parse.Object.extend('Group');\n    const PostObject = Parse.Object.extend('Post');\n\n    return new AuthorObject()\n      .save()\n      .then(user => {\n        const post = new PostObject({\n          author: user,\n        });\n\n        const group = new GroupObject({\n          members: [user],\n        });\n\n        return Promise.all([post.save(), group.save()]);\n      })\n      .then(results => {\n        const p = results[0];\n        return new Parse.Query(PostObject)\n          .matchesKeyInQuery('author', 'members', new Parse.Query(GroupObject))\n          .find()\n          .then(r => {\n            expect(r.length).toEqual(1);\n            if (r.length > 0) {\n              expect(r[0].id).toEqual(p.id);\n            }\n            done();\n          }, done.fail);\n      });\n  });\n\n  it('should find objects with array of pointers', done => {\n    const objects = [];\n    while (objects.length != 5) {\n      const object = new Parse.Object('ContainedObject');\n      object.set('index', objects.length);\n      objects.push(object);\n    }\n\n    Parse.Object.saveAll(objects)\n      .then(objects => {\n        const container = new Parse.Object('Container');\n        const pointers = objects.map(obj => {\n          return {\n            __type: 'Pointer',\n            className: 'ContainedObject',\n            objectId: obj.id,\n          };\n        });\n        container.set('objects', pointers);\n        const container2 = new Parse.Object('Container');\n        container2.set('objects', pointers.slice(2, 3));\n        return Parse.Object.saveAll([container, container2]);\n      })\n      .then(() => {\n        const inQuery = new Parse.Query('ContainedObject');\n        inQuery.greaterThanOrEqualTo('index', 1);\n        const query = new Parse.Query('Container');\n        query.matchesQuery('objects', inQuery);\n        return query.find();\n      })\n      .then(results => {\n        if (results) {\n          expect(results.length).toBe(2);\n        }\n        done();\n      })\n      .catch(err => {\n        jfail(err);\n        fail('should not fail');\n        done();\n      });\n  });\n\n  it('query with two OR subqueries (regression test #1259)', done => {\n    const relatedObject = new Parse.Object('Class2');\n    relatedObject\n      .save()\n      .then(relatedObject => {\n        const anObject = new Parse.Object('Class1');\n        const relation = anObject.relation('relation');\n        relation.add(relatedObject);\n        return anObject.save();\n      })\n      .then(anObject => {\n        const q1 = anObject.relation('relation').query();\n        q1.doesNotExist('nonExistantKey1');\n        const q2 = anObject.relation('relation').query();\n        q2.doesNotExist('nonExistantKey2');\n        Parse.Query.or(q1, q2)\n          .find()\n          .then(results => {\n            expect(results.length).toEqual(1);\n            if (results.length == 1) {\n              expect(results[0].objectId).toEqual(q1.objectId);\n            }\n            done();\n          });\n      });\n  });\n\n  it('objectId containedIn with multiple large array', done => {\n    const obj = new Parse.Object('MyClass');\n    obj\n      .save()\n      .then(obj => {\n        const longListOfStrings = [];\n        for (let i = 0; i < 130; i++) {\n          longListOfStrings.push(i.toString());\n        }\n        longListOfStrings.push(obj.id);\n        const q = new Parse.Query('MyClass');\n        q.containedIn('objectId', longListOfStrings);\n        q.containedIn('objectId', longListOfStrings);\n        return q.find();\n      })\n      .then(results => {\n        expect(results.length).toEqual(1);\n        done();\n      });\n  });\n\n  it('containedIn with pointers should work with string array', done => {\n    const obj = new Parse.Object('MyClass');\n    const child = new Parse.Object('Child');\n    child\n      .save()\n      .then(() => {\n        obj.set('child', child);\n        return obj.save();\n      })\n      .then(() => {\n        const objs = [];\n        for (let i = 0; i < 10; i++) {\n          objs.push(new Parse.Object('MyClass'));\n        }\n        return Parse.Object.saveAll(objs);\n      })\n      .then(() => {\n        const query = new Parse.Query('MyClass');\n        query.containedIn('child', [child.id]);\n        return query.find();\n      })\n      .then(results => {\n        expect(results.length).toBe(1);\n      })\n      .then(done)\n      .catch(done.fail);\n  });\n\n  it('containedIn with pointers should work with string array, with many objects', done => {\n    const objs = [];\n    const children = [];\n    for (let i = 0; i < 10; i++) {\n      const obj = new Parse.Object('MyClass');\n      const child = new Parse.Object('Child');\n      objs.push(obj);\n      children.push(child);\n    }\n    Parse.Object.saveAll(children)\n      .then(() => {\n        return Parse.Object.saveAll(\n          objs.map((obj, i) => {\n            obj.set('child', children[i]);\n            return obj;\n          })\n        );\n      })\n      .then(() => {\n        const query = new Parse.Query('MyClass');\n        const subset = children.slice(0, 5).map(child => {\n          return child.id;\n        });\n        query.containedIn('child', subset);\n        return query.find();\n      })\n      .then(results => {\n        expect(results.length).toBe(5);\n      })\n      .then(done)\n      .catch(done.fail);\n  });\n\n  it('include for specific object', function (done) {\n    const child = new Parse.Object('Child');\n    const parent = new Parse.Object('Parent');\n    child.set('foo', 'bar');\n    parent.set('child', child);\n    Parse.Object.saveAll([child, parent]).then(function (response) {\n      const savedParent = response[1];\n      const parentQuery = new Parse.Query('Parent');\n      parentQuery.include('child');\n      parentQuery.get(savedParent.id).then(function (parentObj) {\n        const childPointer = parentObj.get('child');\n        ok(childPointer);\n        equal(childPointer.get('foo'), 'bar');\n        done();\n      });\n    });\n  });\n\n  it('select keys for specific object', function (done) {\n    const Foobar = new Parse.Object('Foobar');\n    Foobar.set('foo', 'bar');\n    Foobar.set('fizz', 'buzz');\n    Foobar.save().then(function (savedFoobar) {\n      const foobarQuery = new Parse.Query('Foobar');\n      foobarQuery.select('fizz');\n      foobarQuery.get(savedFoobar.id).then(function (foobarObj) {\n        equal(foobarObj.get('fizz'), 'buzz');\n        equal(foobarObj.get('foo'), undefined);\n        done();\n      });\n    });\n  });\n\n  it('select nested keys (issue #1567)', function (done) {\n    const Foobar = new Parse.Object('Foobar');\n    const BarBaz = new Parse.Object('Barbaz');\n    BarBaz.set('key', 'value');\n    BarBaz.set('otherKey', 'value');\n    BarBaz.save()\n      .then(() => {\n        Foobar.set('foo', 'bar');\n        Foobar.set('fizz', 'buzz');\n        Foobar.set('barBaz', BarBaz);\n        return Foobar.save();\n      })\n      .then(function (savedFoobar) {\n        const foobarQuery = new Parse.Query('Foobar');\n        foobarQuery.select(['fizz', 'barBaz.key']);\n        foobarQuery.get(savedFoobar.id).then(function (foobarObj) {\n          equal(foobarObj.get('fizz'), 'buzz');\n          equal(foobarObj.get('foo'), undefined);\n          if (foobarObj.has('barBaz')) {\n            equal(foobarObj.get('barBaz').get('key'), 'value');\n            equal(foobarObj.get('barBaz').get('otherKey'), undefined);\n          } else {\n            fail('barBaz should be set');\n          }\n          done();\n        });\n      });\n  });\n\n  it('select nested keys 2 level (issue #1567)', function (done) {\n    const Foobar = new Parse.Object('Foobar');\n    const BarBaz = new Parse.Object('Barbaz');\n    const Bazoo = new Parse.Object('Bazoo');\n\n    Bazoo.set('some', 'thing');\n    Bazoo.set('otherSome', 'value');\n    Bazoo.save()\n      .then(() => {\n        BarBaz.set('key', 'value');\n        BarBaz.set('otherKey', 'value');\n        BarBaz.set('bazoo', Bazoo);\n        return BarBaz.save();\n      })\n      .then(() => {\n        Foobar.set('foo', 'bar');\n        Foobar.set('fizz', 'buzz');\n        Foobar.set('barBaz', BarBaz);\n        return Foobar.save();\n      })\n      .then(function (savedFoobar) {\n        const foobarQuery = new Parse.Query('Foobar');\n        foobarQuery.select(['fizz', 'barBaz.key', 'barBaz.bazoo.some']);\n        foobarQuery.get(savedFoobar.id).then(function (foobarObj) {\n          equal(foobarObj.get('fizz'), 'buzz');\n          equal(foobarObj.get('foo'), undefined);\n          if (foobarObj.has('barBaz')) {\n            equal(foobarObj.get('barBaz').get('key'), 'value');\n            equal(foobarObj.get('barBaz').get('otherKey'), undefined);\n            equal(foobarObj.get('barBaz').get('bazoo').get('some'), 'thing');\n            equal(foobarObj.get('barBaz').get('bazoo').get('otherSome'), undefined);\n          } else {\n            fail('barBaz should be set');\n          }\n          done();\n        });\n      });\n  });\n\n  it('exclude nested keys', async () => {\n    const Foobar = new Parse.Object('Foobar');\n    const BarBaz = new Parse.Object('Barbaz');\n    BarBaz.set('key', 'value');\n    BarBaz.set('otherKey', 'value');\n    await BarBaz.save();\n\n    Foobar.set('foo', 'bar');\n    Foobar.set('fizz', 'buzz');\n    Foobar.set('barBaz', BarBaz);\n    const savedFoobar = await Foobar.save();\n\n    const foobarQuery = new Parse.Query('Foobar');\n    foobarQuery.exclude(['foo', 'barBaz.otherKey']);\n    const foobarObj = await foobarQuery.get(savedFoobar.id);\n    equal(foobarObj.get('fizz'), 'buzz');\n    equal(foobarObj.get('foo'), undefined);\n    if (foobarObj.has('barBaz')) {\n      equal(foobarObj.get('barBaz').get('key'), 'value');\n      equal(foobarObj.get('barBaz').get('otherKey'), undefined);\n    } else {\n      fail('barBaz should be set');\n    }\n  });\n\n  it('exclude nested keys 2 level', async () => {\n    const Foobar = new Parse.Object('Foobar');\n    const BarBaz = new Parse.Object('Barbaz');\n    const Bazoo = new Parse.Object('Bazoo');\n\n    Bazoo.set('some', 'thing');\n    Bazoo.set('otherSome', 'value');\n    await Bazoo.save();\n\n    BarBaz.set('key', 'value');\n    BarBaz.set('otherKey', 'value');\n    BarBaz.set('bazoo', Bazoo);\n    await BarBaz.save();\n\n    Foobar.set('foo', 'bar');\n    Foobar.set('fizz', 'buzz');\n    Foobar.set('barBaz', BarBaz);\n    const savedFoobar = await Foobar.save();\n\n    const foobarQuery = new Parse.Query('Foobar');\n    foobarQuery.exclude(['foo', 'barBaz.otherKey', 'barBaz.bazoo.otherSome']);\n    const foobarObj = await foobarQuery.get(savedFoobar.id);\n    equal(foobarObj.get('fizz'), 'buzz');\n    equal(foobarObj.get('foo'), undefined);\n    if (foobarObj.has('barBaz')) {\n      equal(foobarObj.get('barBaz').get('key'), 'value');\n      equal(foobarObj.get('barBaz').get('otherKey'), undefined);\n      equal(foobarObj.get('barBaz').get('bazoo').get('some'), 'thing');\n      equal(foobarObj.get('barBaz').get('bazoo').get('otherSome'), undefined);\n    } else {\n      fail('barBaz should be set');\n    }\n  });\n\n  it('include with *', async () => {\n    const child1 = new TestObject({ foo: 'bar', name: 'ac' });\n    const child2 = new TestObject({ foo: 'baz', name: 'flo' });\n    const child3 = new TestObject({ foo: 'bad', name: 'mo' });\n    const parent = new Container({ child1, child2, child3 });\n    await Parse.Object.saveAll([parent, child1, child2, child3]);\n    const options = Object.assign({}, masterKeyOptions, {\n      qs: {\n        where: JSON.stringify({ objectId: parent.id }),\n        include: '*',\n      },\n    });\n    const resp = await request(\n      Object.assign({ url: Parse.serverURL + '/classes/Container' }, options)\n    );\n    const result = resp.data.results[0];\n    equal(result.child1.foo, 'bar');\n    equal(result.child2.foo, 'baz');\n    equal(result.child3.foo, 'bad');\n    equal(result.child1.name, 'ac');\n    equal(result.child2.name, 'flo');\n    equal(result.child3.name, 'mo');\n  });\n\n  it('include with [\"*\"]', async () => {\n    const child1 = new TestObject({ foo: 'bar', name: 'ac' });\n    const child2 = new TestObject({ foo: 'baz', name: 'flo' });\n    const child3 = new TestObject({ foo: 'bad', name: 'mo' });\n    const parent = new Container({ child1, child2, child3 });\n    await Parse.Object.saveAll([parent, child1, child2, child3]);\n    const options = Object.assign({}, masterKeyOptions, {\n      qs: {\n        where: JSON.stringify({ objectId: parent.id }),\n        include: '[\"*\"]',\n      },\n    });\n    const resp = await request(\n      Object.assign({ url: Parse.serverURL + '/classes/Container' }, options)\n    );\n    const result = resp.data.results[0];\n    equal(result.child1.foo, 'bar');\n    equal(result.child2.foo, 'baz');\n    equal(result.child3.foo, 'bad');\n    equal(result.child1.name, 'ac');\n    equal(result.child2.name, 'flo');\n    equal(result.child3.name, 'mo');\n  });\n\n  it('include with * overrides', async () => {\n    const child1 = new TestObject({ foo: 'bar', name: 'ac' });\n    const child2 = new TestObject({ foo: 'baz', name: 'flo' });\n    const child3 = new TestObject({ foo: 'bad', name: 'mo' });\n    const parent = new Container({ child1, child2, child3 });\n    await Parse.Object.saveAll([parent, child1, child2, child3]);\n    const options = Object.assign({}, masterKeyOptions, {\n      qs: {\n        where: JSON.stringify({ objectId: parent.id }),\n        include: 'child2,*',\n      },\n    });\n    const resp = await request(\n      Object.assign({ url: Parse.serverURL + '/classes/Container' }, options)\n    );\n    const result = resp.data.results[0];\n    equal(result.child1.foo, 'bar');\n    equal(result.child2.foo, 'baz');\n    equal(result.child3.foo, 'bad');\n    equal(result.child1.name, 'ac');\n    equal(result.child2.name, 'flo');\n    equal(result.child3.name, 'mo');\n  });\n\n  it('include with [\"*\"] overrides', async () => {\n    const child1 = new TestObject({ foo: 'bar', name: 'ac' });\n    const child2 = new TestObject({ foo: 'baz', name: 'flo' });\n    const child3 = new TestObject({ foo: 'bad', name: 'mo' });\n    const parent = new Container({ child1, child2, child3 });\n    await Parse.Object.saveAll([parent, child1, child2, child3]);\n    const options = Object.assign({}, masterKeyOptions, {\n      qs: {\n        where: JSON.stringify({ objectId: parent.id }),\n        include: '[\"child2\",\"*\"]',\n      },\n    });\n    const resp = await request(\n      Object.assign({ url: Parse.serverURL + '/classes/Container' }, options)\n    );\n    const result = resp.data.results[0];\n    equal(result.child1.foo, 'bar');\n    equal(result.child2.foo, 'baz');\n    equal(result.child3.foo, 'bad');\n    equal(result.child1.name, 'ac');\n    equal(result.child2.name, 'flo');\n    equal(result.child3.name, 'mo');\n  });\n\n  it('includeAll', done => {\n    const child1 = new TestObject({ foo: 'bar', name: 'ac' });\n    const child2 = new TestObject({ foo: 'baz', name: 'flo' });\n    const child3 = new TestObject({ foo: 'bad', name: 'mo' });\n    const parent = new Container({ child1, child2, child3 });\n    Parse.Object.saveAll([parent, child1, child2, child3])\n      .then(() => {\n        const options = Object.assign({}, masterKeyOptions, {\n          qs: {\n            where: JSON.stringify({ objectId: parent.id }),\n            includeAll: true,\n          },\n        });\n        return request(Object.assign({ url: Parse.serverURL + '/classes/Container' }, options));\n      })\n      .then(resp => {\n        const result = resp.data.results[0];\n        equal(result.child1.foo, 'bar');\n        equal(result.child2.foo, 'baz');\n        equal(result.child3.foo, 'bad');\n        equal(result.child1.name, 'ac');\n        equal(result.child2.name, 'flo');\n        equal(result.child3.name, 'mo');\n        done();\n      });\n  });\n\n  it('include pointer and pointer array', function (done) {\n    const child = new TestObject();\n    const child2 = new TestObject();\n    child.set('foo', 'bar');\n    child2.set('hello', 'world');\n    Parse.Object.saveAll([child, child2]).then(function () {\n      const parent = new Container();\n      parent.set('child', child.toPointer());\n      parent.set('child2', [child2.toPointer()]);\n      parent.save().then(function () {\n        const query = new Parse.Query(Container);\n        query.include(['child', 'child2']);\n        query.find().then(function (results) {\n          equal(results.length, 1);\n          const parentAgain = results[0];\n          const childAgain = parentAgain.get('child');\n          ok(childAgain);\n          equal(childAgain.get('foo'), 'bar');\n          const child2Again = parentAgain.get('child2');\n          equal(child2Again.length, 1);\n          ok(child2Again);\n          equal(child2Again[0].get('hello'), 'world');\n          done();\n        });\n      });\n    });\n  });\n\n  it('include pointer and pointer array (keys switched)', function (done) {\n    const child = new TestObject();\n    const child2 = new TestObject();\n    child.set('foo', 'bar');\n    child2.set('hello', 'world');\n    Parse.Object.saveAll([child, child2]).then(function () {\n      const parent = new Container();\n      parent.set('child', child.toPointer());\n      parent.set('child2', [child2.toPointer()]);\n      parent.save().then(function () {\n        const query = new Parse.Query(Container);\n        query.include(['child2', 'child']);\n        query.find().then(function (results) {\n          equal(results.length, 1);\n          const parentAgain = results[0];\n          const childAgain = parentAgain.get('child');\n          ok(childAgain);\n          equal(childAgain.get('foo'), 'bar');\n          const child2Again = parentAgain.get('child2');\n          equal(child2Again.length, 1);\n          ok(child2Again);\n          equal(child2Again[0].get('hello'), 'world');\n          done();\n        });\n      });\n    });\n  });\n\n  it('includeAll pointer and pointer array', function (done) {\n    const child = new TestObject();\n    const child2 = new TestObject();\n    child.set('foo', 'bar');\n    child2.set('hello', 'world');\n    Parse.Object.saveAll([child, child2]).then(function () {\n      const parent = new Container();\n      parent.set('child', child.toPointer());\n      parent.set('child2', [child2.toPointer()]);\n      parent.save().then(function () {\n        const query = new Parse.Query(Container);\n        query.includeAll();\n        query.find().then(function (results) {\n          equal(results.length, 1);\n          const parentAgain = results[0];\n          const childAgain = parentAgain.get('child');\n          ok(childAgain);\n          equal(childAgain.get('foo'), 'bar');\n          const child2Again = parentAgain.get('child2');\n          equal(child2Again.length, 1);\n          ok(child2Again);\n          equal(child2Again[0].get('hello'), 'world');\n          done();\n        });\n      });\n    });\n  });\n\n  it('select nested keys 2 level includeAll', done => {\n    const Foobar = new Parse.Object('Foobar');\n    const BarBaz = new Parse.Object('Barbaz');\n    const Bazoo = new Parse.Object('Bazoo');\n    const Tang = new Parse.Object('Tang');\n\n    Bazoo.set('some', 'thing');\n    Bazoo.set('otherSome', 'value');\n    Bazoo.save()\n      .then(() => {\n        BarBaz.set('key', 'value');\n        BarBaz.set('otherKey', 'value');\n        BarBaz.set('bazoo', Bazoo);\n        return BarBaz.save();\n      })\n      .then(() => {\n        Tang.set('clan', 'wu');\n        return Tang.save();\n      })\n      .then(() => {\n        Foobar.set('foo', 'bar');\n        Foobar.set('fizz', 'buzz');\n        Foobar.set('barBaz', BarBaz);\n        Foobar.set('group', Tang);\n        return Foobar.save();\n      })\n      .then(savedFoobar => {\n        const options = Object.assign(\n          {\n            url: Parse.serverURL + '/classes/Foobar',\n          },\n          masterKeyOptions,\n          {\n            qs: {\n              where: JSON.stringify({ objectId: savedFoobar.id }),\n              includeAll: true,\n              keys: 'fizz,barBaz.key,barBaz.bazoo.some',\n            },\n          }\n        );\n        return request(options);\n      })\n      .then(resp => {\n        const result = resp.data.results[0];\n        equal(result.group.clan, 'wu');\n        equal(result.foo, undefined);\n        equal(result.fizz, 'buzz');\n        equal(result.barBaz.key, 'value');\n        equal(result.barBaz.otherKey, undefined);\n        equal(result.barBaz.bazoo.some, 'thing');\n        equal(result.barBaz.bazoo.otherSome, undefined);\n        done();\n      })\n      .catch(done.fail);\n  });\n\n  it('select nested keys 2 level without include (issue #3185)', function (done) {\n    const Foobar = new Parse.Object('Foobar');\n    const BarBaz = new Parse.Object('Barbaz');\n    const Bazoo = new Parse.Object('Bazoo');\n\n    Bazoo.set('some', 'thing');\n    Bazoo.set('otherSome', 'value');\n    Bazoo.save()\n      .then(() => {\n        BarBaz.set('key', 'value');\n        BarBaz.set('otherKey', 'value');\n        BarBaz.set('bazoo', Bazoo);\n        return BarBaz.save();\n      })\n      .then(() => {\n        Foobar.set('foo', 'bar');\n        Foobar.set('fizz', 'buzz');\n        Foobar.set('barBaz', BarBaz);\n        return Foobar.save();\n      })\n      .then(function (savedFoobar) {\n        const foobarQuery = new Parse.Query('Foobar');\n        foobarQuery.select(['fizz', 'barBaz.key', 'barBaz.bazoo.some']);\n        return foobarQuery.get(savedFoobar.id);\n      })\n      .then(foobarObj => {\n        equal(foobarObj.get('fizz'), 'buzz');\n        equal(foobarObj.get('foo'), undefined);\n        if (foobarObj.has('barBaz')) {\n          equal(foobarObj.get('barBaz').get('key'), 'value');\n          equal(foobarObj.get('barBaz').get('otherKey'), undefined);\n          if (foobarObj.get('barBaz').has('bazoo')) {\n            equal(foobarObj.get('barBaz').get('bazoo').get('some'), 'thing');\n            equal(foobarObj.get('barBaz').get('bazoo').get('otherSome'), undefined);\n          } else {\n            fail('bazoo should be set');\n          }\n        } else {\n          fail('barBaz should be set');\n        }\n        done();\n      });\n  });\n\n  it('properly handles nested ors', function (done) {\n    const objects = [];\n    while (objects.length != 4) {\n      const obj = new Parse.Object('Object');\n      obj.set('x', objects.length);\n      objects.push(obj);\n    }\n    Parse.Object.saveAll(objects)\n      .then(() => {\n        const q0 = new Parse.Query('Object');\n        q0.equalTo('x', 0);\n        const q1 = new Parse.Query('Object');\n        q1.equalTo('x', 1);\n        const q2 = new Parse.Query('Object');\n        q2.equalTo('x', 2);\n        const or01 = Parse.Query.or(q0, q1);\n        return Parse.Query.or(or01, q2).find();\n      })\n      .then(results => {\n        expect(results.length).toBe(3);\n        done();\n      })\n      .catch(error => {\n        fail('should not fail');\n        jfail(error);\n        done();\n      });\n  });\n\n  it('should not depend on parameter order #3169', function (done) {\n    const score1 = new Parse.Object('Score', { scoreId: '1' });\n    const score2 = new Parse.Object('Score', { scoreId: '2' });\n    const game1 = new Parse.Object('Game', { gameId: '1' });\n    const game2 = new Parse.Object('Game', { gameId: '2' });\n    Parse.Object.saveAll([score1, score2, game1, game2])\n      .then(() => {\n        game1.set('score', [score1]);\n        game2.set('score', [score2]);\n        return Parse.Object.saveAll([game1, game2]);\n      })\n      .then(() => {\n        const where = {\n          score: {\n            objectId: score1.id,\n            className: 'Score',\n            __type: 'Pointer',\n          },\n        };\n        return request({\n          method: 'POST',\n          url: Parse.serverURL + '/classes/Game',\n          body: { where, _method: 'GET' },\n          headers: {\n            'X-Parse-Application-Id': Parse.applicationId,\n            'X-Parse-Javascript-Key': Parse.javaScriptKey,\n            'Content-Type': 'application/json',\n          },\n        });\n      })\n      .then(\n        response => {\n          const results = response.data;\n          expect(results.results.length).toBe(1);\n          done();\n        },\n        res => done.fail(res.data)\n      );\n  });\n\n  it('should not interfere with has when using select on field with undefined value #3999', done => {\n    const obj1 = new Parse.Object('TestObject');\n    const obj2 = new Parse.Object('OtherObject');\n    obj2.set('otherField', 1);\n    obj1.set('testPointerField', obj2);\n    obj1.set('shouldBe', true);\n    const obj3 = new Parse.Object('TestObject');\n    obj3.set('shouldBe', false);\n    Parse.Object.saveAll([obj1, obj3])\n      .then(() => {\n        const query = new Parse.Query('TestObject');\n        query.include('testPointerField');\n        query.select(['testPointerField', 'testPointerField.otherField', 'shouldBe']);\n        return query.find();\n      })\n      .then(results => {\n        results.forEach(result => {\n          equal(result.has('testPointerField'), result.get('shouldBe'));\n        });\n        done();\n      })\n      .catch(done.fail);\n  });\n\n  it_only_db('mongo')('should handle relative times correctly', function (done) {\n    const now = Date.now();\n    const obj1 = new Parse.Object('MyCustomObject', {\n      name: 'obj1',\n      ttl: new Date(now + 2 * 24 * 60 * 60 * 1000), // 2 days from now\n    });\n    const obj2 = new Parse.Object('MyCustomObject', {\n      name: 'obj2',\n      ttl: new Date(now - 2 * 24 * 60 * 60 * 1000), // 2 days ago\n    });\n\n    Parse.Object.saveAll([obj1, obj2])\n      .then(() => {\n        const q = new Parse.Query('MyCustomObject');\n        q.greaterThan('ttl', { $relativeTime: 'in 1 day' });\n        return q.find({ useMasterKey: true });\n      })\n      .then(results => {\n        expect(results.length).toBe(1);\n      })\n      .then(() => {\n        const q = new Parse.Query('MyCustomObject');\n        q.greaterThan('ttl', { $relativeTime: '1 day ago' });\n        return q.find({ useMasterKey: true });\n      })\n      .then(results => {\n        expect(results.length).toBe(1);\n      })\n      .then(() => {\n        const q = new Parse.Query('MyCustomObject');\n        q.lessThan('ttl', { $relativeTime: '5 days ago' });\n        return q.find({ useMasterKey: true });\n      })\n      .then(results => {\n        expect(results.length).toBe(0);\n      })\n      .then(() => {\n        const q = new Parse.Query('MyCustomObject');\n        q.greaterThan('ttl', { $relativeTime: '3 days ago' });\n        return q.find({ useMasterKey: true });\n      })\n      .then(results => {\n        expect(results.length).toBe(2);\n      })\n      .then(() => {\n        const q = new Parse.Query('MyCustomObject');\n        q.greaterThan('ttl', { $relativeTime: 'now' });\n        return q.find({ useMasterKey: true });\n      })\n      .then(results => {\n        expect(results.length).toBe(1);\n      })\n      .then(() => {\n        const q = new Parse.Query('MyCustomObject');\n        q.greaterThan('ttl', { $relativeTime: 'now' });\n        q.lessThan('ttl', { $relativeTime: 'in 1 day' });\n        return q.find({ useMasterKey: true });\n      })\n      .then(results => {\n        expect(results.length).toBe(0);\n      })\n      .then(() => {\n        const q = new Parse.Query('MyCustomObject');\n        q.greaterThan('ttl', { $relativeTime: '1 year 3 weeks ago' });\n        return q.find({ useMasterKey: true });\n      })\n      .then(results => {\n        expect(results.length).toBe(2);\n      })\n      .then(done, done.fail);\n  });\n\n  it_only_db('mongo')('should error on invalid relative time', function (done) {\n    const obj1 = new Parse.Object('MyCustomObject', {\n      name: 'obj1',\n      ttl: new Date(Date.now() + 2 * 24 * 60 * 60 * 1000), // 2 days from now\n    });\n\n    const q = new Parse.Query('MyCustomObject');\n    q.greaterThan('ttl', { $relativeTime: '-12 bananas ago' });\n    obj1\n      .save({ useMasterKey: true })\n      .then(() => q.find({ useMasterKey: true }))\n      .then(done.fail, () => done());\n  });\n\n  it_only_db('mongo')('should error when using $relativeTime on non-Date field', function (done) {\n    const obj1 = new Parse.Object('MyCustomObject', {\n      name: 'obj1',\n      nonDateField: 'abcd',\n      ttl: new Date(Date.now() + 2 * 24 * 60 * 60 * 1000), // 2 days from now\n    });\n\n    const q = new Parse.Query('MyCustomObject');\n    q.greaterThan('nonDateField', { $relativeTime: '1 day ago' });\n    obj1\n      .save({ useMasterKey: true })\n      .then(() => q.find({ useMasterKey: true }))\n      .then(done.fail, () => done());\n  });\n\n  it('should match complex structure with dot notation when using matchesKeyInQuery', function (done) {\n    const group1 = new Parse.Object('Group', {\n      name: 'Group #1',\n    });\n\n    const group2 = new Parse.Object('Group', {\n      name: 'Group #2',\n    });\n\n    Parse.Object.saveAll([group1, group2])\n      .then(() => {\n        const role1 = new Parse.Object('Role', {\n          name: 'Role #1',\n          type: 'x',\n          belongsTo: group1,\n        });\n\n        const role2 = new Parse.Object('Role', {\n          name: 'Role #2',\n          type: 'y',\n          belongsTo: group1,\n        });\n\n        return Parse.Object.saveAll([role1, role2]);\n      })\n      .then(() => {\n        const rolesOfTypeX = new Parse.Query('Role');\n        rolesOfTypeX.equalTo('type', 'x');\n\n        const groupsWithRoleX = new Parse.Query('Group');\n        groupsWithRoleX.matchesKeyInQuery('objectId', 'belongsTo.objectId', rolesOfTypeX);\n\n        groupsWithRoleX.find().then(function (results) {\n          equal(results.length, 1);\n          equal(results[0].get('name'), group1.get('name'));\n          done();\n        });\n      });\n  });\n\n  it('should match complex structure with dot notation when using doesNotMatchKeyInQuery', function (done) {\n    const group1 = new Parse.Object('Group', {\n      name: 'Group #1',\n    });\n\n    const group2 = new Parse.Object('Group', {\n      name: 'Group #2',\n    });\n\n    Parse.Object.saveAll([group1, group2])\n      .then(() => {\n        const role1 = new Parse.Object('Role', {\n          name: 'Role #1',\n          type: 'x',\n          belongsTo: group1,\n        });\n\n        const role2 = new Parse.Object('Role', {\n          name: 'Role #2',\n          type: 'y',\n          belongsTo: group1,\n        });\n\n        return Parse.Object.saveAll([role1, role2]);\n      })\n      .then(() => {\n        const rolesOfTypeX = new Parse.Query('Role');\n        rolesOfTypeX.equalTo('type', 'x');\n\n        const groupsWithRoleX = new Parse.Query('Group');\n        groupsWithRoleX.doesNotMatchKeyInQuery('objectId', 'belongsTo.objectId', rolesOfTypeX);\n\n        groupsWithRoleX.find().then(function (results) {\n          equal(results.length, 1);\n          equal(results[0].get('name'), group2.get('name'));\n          done();\n        });\n      });\n  });\n\n  it('should not throw error with undefined dot notation when using matchesKeyInQuery', async () => {\n    const group = new Parse.Object('Group', { name: 'Group #1' });\n    await group.save();\n\n    const role1 = new Parse.Object('Role', {\n      name: 'Role #1',\n      type: 'x',\n      belongsTo: group,\n    });\n\n    const role2 = new Parse.Object('Role', {\n      name: 'Role #2',\n      type: 'y',\n      belongsTo: undefined,\n    });\n    await Parse.Object.saveAll([role1, role2]);\n\n    const rolesOfTypeX = new Parse.Query('Role');\n    rolesOfTypeX.equalTo('type', 'x');\n\n    const groupsWithRoleX = new Parse.Query('Group');\n    groupsWithRoleX.matchesKeyInQuery('objectId', 'belongsTo.objectId', rolesOfTypeX);\n\n    const results = await groupsWithRoleX.find();\n    equal(results.length, 1);\n    equal(results[0].get('name'), group.get('name'));\n  });\n\n  it('should not throw error with undefined dot notation when using doesNotMatchKeyInQuery', async () => {\n    const group1 = new Parse.Object('Group', { name: 'Group #1' });\n    const group2 = new Parse.Object('Group', { name: 'Group #2' });\n    await Parse.Object.saveAll([group1, group2]);\n\n    const role1 = new Parse.Object('Role', {\n      name: 'Role #1',\n      type: 'x',\n      belongsTo: group1,\n    });\n\n    const role2 = new Parse.Object('Role', {\n      name: 'Role #2',\n      type: 'y',\n      belongsTo: undefined,\n    });\n    await Parse.Object.saveAll([role1, role2]);\n\n    const rolesOfTypeX = new Parse.Query('Role');\n    rolesOfTypeX.equalTo('type', 'x');\n\n    const groupsWithRoleX = new Parse.Query('Group');\n    groupsWithRoleX.doesNotMatchKeyInQuery('objectId', 'belongsTo.objectId', rolesOfTypeX);\n\n    const results = await groupsWithRoleX.find();\n    equal(results.length, 1);\n    equal(results[0].get('name'), group2.get('name'));\n  });\n\n  it('withJSON supports geoWithin.centerSphere', done => {\n    const inbound = new Parse.GeoPoint(1.5, 1.5);\n    const onbound = new Parse.GeoPoint(10, 10);\n    const outbound = new Parse.GeoPoint(20, 20);\n    const obj1 = new Parse.Object('TestObject', { location: inbound });\n    const obj2 = new Parse.Object('TestObject', { location: onbound });\n    const obj3 = new Parse.Object('TestObject', { location: outbound });\n    const center = new Parse.GeoPoint(0, 0);\n    const distanceInKilometers = 1569 + 1; // 1569km is the approximate distance between {0, 0} and {10, 10}.\n    Parse.Object.saveAll([obj1, obj2, obj3])\n      .then(() => {\n        const q = new Parse.Query(TestObject);\n        const jsonQ = q.toJSON();\n        jsonQ.where.location = {\n          $geoWithin: {\n            $centerSphere: [center, distanceInKilometers / 6371.0],\n          },\n        };\n        q.withJSON(jsonQ);\n        return q.find();\n      })\n      .then(results => {\n        equal(results.length, 2);\n        const q = new Parse.Query(TestObject);\n        const jsonQ = q.toJSON();\n        jsonQ.where.location = {\n          $geoWithin: {\n            $centerSphere: [[0, 0], distanceInKilometers / 6371.0],\n          },\n        };\n        q.withJSON(jsonQ);\n        return q.find();\n      })\n      .then(results => {\n        equal(results.length, 2);\n        done();\n      })\n      .catch(error => {\n        fail(error);\n        done();\n      });\n  });\n\n  it('withJSON with geoWithin.centerSphere fails without parameters', done => {\n    const q = new Parse.Query(TestObject);\n    const jsonQ = q.toJSON();\n    jsonQ.where.location = {\n      $geoWithin: {\n        $centerSphere: [],\n      },\n    };\n    q.withJSON(jsonQ);\n    q.find()\n      .then(done.fail)\n      .catch(e => expect(e.code).toBe(Parse.Error.INVALID_JSON))\n      .then(done);\n  });\n\n  it('withJSON with geoWithin.centerSphere fails with invalid distance', done => {\n    const q = new Parse.Query(TestObject);\n    const jsonQ = q.toJSON();\n    jsonQ.where.location = {\n      $geoWithin: {\n        $centerSphere: [[0, 0], 'invalid_distance'],\n      },\n    };\n    q.withJSON(jsonQ);\n    q.find()\n      .then(done.fail)\n      .catch(e => expect(e.code).toBe(Parse.Error.INVALID_JSON))\n      .then(done);\n  });\n\n  it('withJSON with geoWithin.centerSphere fails with invalid coordinate', done => {\n    const q = new Parse.Query(TestObject);\n    const jsonQ = q.toJSON();\n    jsonQ.where.location = {\n      $geoWithin: {\n        $centerSphere: [[-190, -190], 1],\n      },\n    };\n    q.withJSON(jsonQ);\n    q.find()\n      .then(done.fail)\n      .catch(() => done());\n  });\n\n  it('withJSON with geoWithin.centerSphere fails with invalid geo point', done => {\n    const q = new Parse.Query(TestObject);\n    const jsonQ = q.toJSON();\n    jsonQ.where.location = {\n      $geoWithin: {\n        $centerSphere: [{ longitude: 0, dummytude: 0 }, 1],\n      },\n    };\n    q.withJSON(jsonQ);\n    q.find()\n      .then(done.fail)\n      .catch(() => done());\n  });\n\n  it('can add new config to existing config', async () => {\n    await request({\n      method: 'PUT',\n      url: 'http://localhost:8378/1/config',\n      json: true,\n      body: {\n        params: {\n          files: [{ __type: 'File', name: 'name', url: 'http://url' }],\n        },\n      },\n      headers: masterKeyHeaders,\n    });\n\n    await request({\n      method: 'PUT',\n      url: 'http://localhost:8378/1/config',\n      json: true,\n      body: {\n        params: { newConfig: 'good' },\n      },\n      headers: masterKeyHeaders,\n    });\n\n    const result = await Parse.Config.get();\n    equal(result.get('files')[0].toJSON(), {\n      __type: 'File',\n      name: 'name',\n      url: 'http://url',\n    });\n    equal(result.get('newConfig'), 'good');\n  });\n\n  it('can set object type key', async () => {\n    const data = { bar: true, baz: 100 };\n    const object = new TestObject();\n    object.set('objectField', data);\n    await object.save();\n\n    const query = new Parse.Query(TestObject);\n    let result = await query.get(object.id);\n    equal(result.get('objectField'), data);\n\n    object.set('objectField.baz', 50, { ignoreValidation: true });\n    await object.save();\n\n    result = await query.get(object.id);\n    equal(result.get('objectField'), { bar: true, baz: 50 });\n  });\n\n  it('can update numeric array', async () => {\n    const data1 = [0, 1.1, 1, -2, 3];\n    const data2 = [0, 1.1, 1, -2, 3, 4];\n    const obj1 = new TestObject();\n    obj1.set('array', data1);\n    await obj1.save();\n    equal(obj1.get('array'), data1);\n\n    const query = new Parse.Query(TestObject);\n    query.equalTo('objectId', obj1.id);\n\n    const result = await query.first();\n    equal(result.get('array'), data1);\n\n    result.set('array', data2);\n    equal(result.get('array'), data2);\n    await result.save();\n    equal(result.get('array'), data2);\n\n    const results = await query.find();\n    equal(results[0].get('array'), data2);\n  });\n\n  it('can update mixed array', async () => {\n    const data1 = [0, 1.1, 'hello world', { foo: 'bar' }];\n    const data2 = [0, 1, { foo: 'bar' }, [], [1, 2, 'bar']];\n    const obj1 = new TestObject();\n    obj1.set('array', data1);\n    await obj1.save();\n    equal(obj1.get('array'), data1);\n\n    const query = new Parse.Query(TestObject);\n    query.equalTo('objectId', obj1.id);\n\n    const result = await query.first();\n    equal(result.get('array'), data1);\n\n    result.set('array', data2);\n    equal(result.get('array'), data2);\n\n    await result.save();\n    equal(result.get('array'), data2);\n\n    const results = await query.find();\n    equal(results[0].get('array'), data2);\n  });\n\n  it('can query regex with unicode', async () => {\n    const object = new TestObject();\n    object.set('field', 'auto\u00f6o');\n    await object.save();\n\n    const query = new Parse.Query(TestObject);\n    query.contains('field', 'auto\u00f6o');\n    const results = await query.find();\n\n    expect(results.length).toBe(1);\n    expect(results[0].get('field')).toBe('auto\u00f6o');\n  });\n\n  it('can update mixed array more than 100 elements', async () => {\n    const array = [0, 1.1, 'hello world', { foo: 'bar' }, null];\n    const obj = new TestObject({ array });\n    await obj.save();\n\n    const query = new Parse.Query(TestObject);\n    const result = await query.get(obj.id);\n    equal(result.get('array').length, 5);\n\n    for (let i = 0; i < 100; i += 1) {\n      array.push(i);\n    }\n    obj.set('array', array);\n    await obj.save();\n\n    const results = await query.find();\n    equal(results[0].get('array').length, 105);\n  });\n\n  xit('todo: exclude keys with select key (sdk query get)', async done => {\n    // there is some problem with js sdk caching\n\n    const obj = new TestObject({ foo: 'baz', hello: 'world' });\n    await obj.save();\n\n    const query = new Parse.Query('TestObject');\n\n    query.withJSON({\n      keys: 'hello',\n      excludeKeys: 'hello',\n    });\n\n    const object = await query.get(obj.id);\n    expect(object.get('foo')).toBeUndefined();\n    expect(object.get('hello')).toBeUndefined();\n    done();\n  });\n\n  it_only_db('mongo')('can use explain on User class', async () => {\n    // Create user\n    const user = new Parse.User();\n    user.set('username', 'foo');\n    user.set('password', 'bar');\n    await user.save();\n    // Query for user with explain\n    const query = new Parse.Query('_User');\n    query.equalTo('objectId', user.id);\n    query.explain();\n    const result = await query.find();\n    // Validate\n    expect(result.executionStats).not.toBeUndefined();\n  });\n});\n", "// @flow\nimport MongoCollection from './MongoCollection';\nimport MongoSchemaCollection from './MongoSchemaCollection';\nimport { StorageAdapter } from '../StorageAdapter';\nimport type { SchemaType, QueryType, StorageClass, QueryOptions } from '../StorageAdapter';\nimport { parse as parseUrl, format as formatUrl } from '../../../vendor/mongodbUrl';\nimport {\n  parseObjectToMongoObjectForCreate,\n  mongoObjectToParseObject,\n  transformKey,\n  transformWhere,\n  transformUpdate,\n  transformPointerString,\n} from './MongoTransform';\n// @flow-disable-next\nimport Parse from 'parse/node';\n// @flow-disable-next\nimport _ from 'lodash';\nimport defaults from '../../../defaults';\nimport logger from '../../../logger';\n\n// @flow-disable-next\nconst mongodb = require('mongodb');\nconst MongoClient = mongodb.MongoClient;\nconst ReadPreference = mongodb.ReadPreference;\n\nconst MongoSchemaCollectionName = '_SCHEMA';\n\nconst storageAdapterAllCollections = mongoAdapter => {\n  return mongoAdapter\n    .connect()\n    .then(() => mongoAdapter.database.collections())\n    .then(collections => {\n      return collections.filter(collection => {\n        if (collection.namespace.match(/\\.system\\./)) {\n          return false;\n        }\n        // TODO: If you have one app with a collection prefix that happens to be a prefix of another\n        // apps prefix, this will go very very badly. We should fix that somehow.\n        return collection.collectionName.indexOf(mongoAdapter._collectionPrefix) == 0;\n      });\n    });\n};\n\nconst convertParseSchemaToMongoSchema = ({ ...schema }) => {\n  delete schema.fields._rperm;\n  delete schema.fields._wperm;\n\n  if (schema.className === '_User') {\n    // Legacy mongo adapter knows about the difference between password and _hashed_password.\n    // Future database adapters will only know about _hashed_password.\n    // Note: Parse Server will bring back password with injectDefaultSchema, so we don't need\n    // to add _hashed_password back ever.\n    delete schema.fields._hashed_password;\n  }\n\n  return schema;\n};\n\n// Returns { code, error } if invalid, or { result }, an object\n// suitable for inserting into _SCHEMA collection, otherwise.\nconst mongoSchemaFromFieldsAndClassNameAndCLP = (\n  fields,\n  className,\n  classLevelPermissions,\n  indexes\n) => {\n  const mongoObject = {\n    _id: className,\n    objectId: 'string',\n    updatedAt: 'string',\n    createdAt: 'string',\n    _metadata: undefined,\n  };\n\n  for (const fieldName in fields) {\n    const { type, targetClass, ...fieldOptions } = fields[fieldName];\n    mongoObject[fieldName] = MongoSchemaCollection.parseFieldTypeToMongoFieldType({\n      type,\n      targetClass,\n    });\n    if (fieldOptions && Object.keys(fieldOptions).length > 0) {\n      mongoObject._metadata = mongoObject._metadata || {};\n      mongoObject._metadata.fields_options = mongoObject._metadata.fields_options || {};\n      mongoObject._metadata.fields_options[fieldName] = fieldOptions;\n    }\n  }\n\n  if (typeof classLevelPermissions !== 'undefined') {\n    mongoObject._metadata = mongoObject._metadata || {};\n    if (!classLevelPermissions) {\n      delete mongoObject._metadata.class_permissions;\n    } else {\n      mongoObject._metadata.class_permissions = classLevelPermissions;\n    }\n  }\n\n  if (indexes && typeof indexes === 'object' && Object.keys(indexes).length > 0) {\n    mongoObject._metadata = mongoObject._metadata || {};\n    mongoObject._metadata.indexes = indexes;\n  }\n\n  if (!mongoObject._metadata) {\n    // cleanup the unused _metadata\n    delete mongoObject._metadata;\n  }\n\n  return mongoObject;\n};\n\nexport class MongoStorageAdapter implements StorageAdapter {\n  // Private\n  _uri: string;\n  _collectionPrefix: string;\n  _mongoOptions: Object;\n  _onchange: any;\n  _stream: any;\n  // Public\n  connectionPromise: ?Promise<any>;\n  database: any;\n  client: MongoClient;\n  _maxTimeMS: ?number;\n  canSortOnJoinTables: boolean;\n  enableSchemaHooks: boolean;\n\n  constructor({ uri = defaults.DefaultMongoURI, collectionPrefix = '', mongoOptions = {} }: any) {\n    this._uri = uri;\n    this._collectionPrefix = collectionPrefix;\n    this._mongoOptions = mongoOptions;\n    this._mongoOptions.useNewUrlParser = true;\n    this._mongoOptions.useUnifiedTopology = true;\n    this._onchange = () => {};\n\n    // MaxTimeMS is not a global MongoDB client option, it is applied per operation.\n    this._maxTimeMS = mongoOptions.maxTimeMS;\n    this.canSortOnJoinTables = true;\n    this.enableSchemaHooks = !!mongoOptions.enableSchemaHooks;\n    delete mongoOptions.enableSchemaHooks;\n    delete mongoOptions.maxTimeMS;\n  }\n\n  watch(callback: () => void): void {\n    this._onchange = callback;\n  }\n\n  connect() {\n    if (this.connectionPromise) {\n      return this.connectionPromise;\n    }\n\n    // parsing and re-formatting causes the auth value (if there) to get URI\n    // encoded\n    const encodedUri = formatUrl(parseUrl(this._uri));\n\n    this.connectionPromise = MongoClient.connect(encodedUri, this._mongoOptions)\n      .then(client => {\n        // Starting mongoDB 3.0, the MongoClient.connect don't return a DB anymore but a client\n        // Fortunately, we can get back the options and use them to select the proper DB.\n        // https://github.com/mongodb/node-mongodb-native/blob/2c35d76f08574225b8db02d7bef687123e6bb018/lib/mongo_client.js#L885\n        const options = client.s.options;\n        const database = client.db(options.dbName);\n        if (!database) {\n          delete this.connectionPromise;\n          return;\n        }\n        database.on('error', () => {\n          delete this.connectionPromise;\n        });\n        database.on('close', () => {\n          delete this.connectionPromise;\n        });\n        this.client = client;\n        this.database = database;\n      })\n      .catch(err => {\n        delete this.connectionPromise;\n        return Promise.reject(err);\n      });\n\n    return this.connectionPromise;\n  }\n\n  handleError<T>(error: ?(Error | Parse.Error)): Promise<T> {\n    if (error && error.code === 13) {\n      // Unauthorized error\n      delete this.client;\n      delete this.database;\n      delete this.connectionPromise;\n      logger.error('Received unauthorized error', { error: error });\n    }\n    throw error;\n  }\n\n  handleShutdown() {\n    if (!this.client) {\n      return Promise.resolve();\n    }\n    return this.client.close(false);\n  }\n\n  _adaptiveCollection(name: string) {\n    return this.connect()\n      .then(() => this.database.collection(this._collectionPrefix + name))\n      .then(rawCollection => new MongoCollection(rawCollection))\n      .catch(err => this.handleError(err));\n  }\n\n  _schemaCollection(): Promise<MongoSchemaCollection> {\n    return this.connect()\n      .then(() => this._adaptiveCollection(MongoSchemaCollectionName))\n      .then(collection => {\n        if (!this._stream && this.enableSchemaHooks) {\n          this._stream = collection._mongoCollection.watch();\n          this._stream.on('change', () => this._onchange());\n        }\n        return new MongoSchemaCollection(collection);\n      });\n  }\n\n  classExists(name: string) {\n    return this.connect()\n      .then(() => {\n        return this.database.listCollections({ name: this._collectionPrefix + name }).toArray();\n      })\n      .then(collections => {\n        return collections.length > 0;\n      })\n      .catch(err => this.handleError(err));\n  }\n\n  setClassLevelPermissions(className: string, CLPs: any): Promise<void> {\n    return this._schemaCollection()\n      .then(schemaCollection =>\n        schemaCollection.updateSchema(className, {\n          $set: { '_metadata.class_permissions': CLPs },\n        })\n      )\n      .catch(err => this.handleError(err));\n  }\n\n  setIndexesWithSchemaFormat(\n    className: string,\n    submittedIndexes: any,\n    existingIndexes: any = {},\n    fields: any\n  ): Promise<void> {\n    if (submittedIndexes === undefined) {\n      return Promise.resolve();\n    }\n    if (Object.keys(existingIndexes).length === 0) {\n      existingIndexes = { _id_: { _id: 1 } };\n    }\n    const deletePromises = [];\n    const insertedIndexes = [];\n    Object.keys(submittedIndexes).forEach(name => {\n      const field = submittedIndexes[name];\n      if (existingIndexes[name] && field.__op !== 'Delete') {\n        throw new Parse.Error(Parse.Error.INVALID_QUERY, `Index ${name} exists, cannot update.`);\n      }\n      if (!existingIndexes[name] && field.__op === 'Delete') {\n        throw new Parse.Error(\n          Parse.Error.INVALID_QUERY,\n          `Index ${name} does not exist, cannot delete.`\n        );\n      }\n      if (field.__op === 'Delete') {\n        const promise = this.dropIndex(className, name);\n        deletePromises.push(promise);\n        delete existingIndexes[name];\n      } else {\n        Object.keys(field).forEach(key => {\n          if (\n            !Object.prototype.hasOwnProperty.call(\n              fields,\n              key.indexOf('_p_') === 0 ? key.replace('_p_', '') : key\n            )\n          ) {\n            throw new Parse.Error(\n              Parse.Error.INVALID_QUERY,\n              `Field ${key} does not exist, cannot add index.`\n            );\n          }\n        });\n        existingIndexes[name] = field;\n        insertedIndexes.push({\n          key: field,\n          name,\n        });\n      }\n    });\n    let insertPromise = Promise.resolve();\n    if (insertedIndexes.length > 0) {\n      insertPromise = this.createIndexes(className, insertedIndexes);\n    }\n    return Promise.all(deletePromises)\n      .then(() => insertPromise)\n      .then(() => this._schemaCollection())\n      .then(schemaCollection =>\n        schemaCollection.updateSchema(className, {\n          $set: { '_metadata.indexes': existingIndexes },\n        })\n      )\n      .catch(err => this.handleError(err));\n  }\n\n  setIndexesFromMongo(className: string) {\n    return this.getIndexes(className)\n      .then(indexes => {\n        indexes = indexes.reduce((obj, index) => {\n          if (index.key._fts) {\n            delete index.key._fts;\n            delete index.key._ftsx;\n            for (const field in index.weights) {\n              index.key[field] = 'text';\n            }\n          }\n          obj[index.name] = index.key;\n          return obj;\n        }, {});\n        return this._schemaCollection().then(schemaCollection =>\n          schemaCollection.updateSchema(className, {\n            $set: { '_metadata.indexes': indexes },\n          })\n        );\n      })\n      .catch(err => this.handleError(err))\n      .catch(() => {\n        // Ignore if collection not found\n        return Promise.resolve();\n      });\n  }\n\n  createClass(className: string, schema: SchemaType): Promise<void> {\n    schema = convertParseSchemaToMongoSchema(schema);\n    const mongoObject = mongoSchemaFromFieldsAndClassNameAndCLP(\n      schema.fields,\n      className,\n      schema.classLevelPermissions,\n      schema.indexes\n    );\n    mongoObject._id = className;\n    return this.setIndexesWithSchemaFormat(className, schema.indexes, {}, schema.fields)\n      .then(() => this._schemaCollection())\n      .then(schemaCollection => schemaCollection.insertSchema(mongoObject))\n      .catch(err => this.handleError(err));\n  }\n\n  addFieldIfNotExists(className: string, fieldName: string, type: any): Promise<void> {\n    return this._schemaCollection()\n      .then(schemaCollection => schemaCollection.addFieldIfNotExists(className, fieldName, type))\n      .then(() => this.createIndexesIfNeeded(className, fieldName, type))\n      .catch(err => this.handleError(err));\n  }\n\n  // Drops a collection. Resolves with true if it was a Parse Schema (eg. _User, Custom, etc.)\n  // and resolves with false if it wasn't (eg. a join table). Rejects if deletion was impossible.\n  deleteClass(className: string) {\n    return (\n      this._adaptiveCollection(className)\n        .then(collection => collection.drop())\n        .catch(error => {\n          // 'ns not found' means collection was already gone. Ignore deletion attempt.\n          if (error.message == 'ns not found') {\n            return;\n          }\n          throw error;\n        })\n        // We've dropped the collection, now remove the _SCHEMA document\n        .then(() => this._schemaCollection())\n        .then(schemaCollection => schemaCollection.findAndDeleteSchema(className))\n        .catch(err => this.handleError(err))\n    );\n  }\n\n  deleteAllClasses(fast: boolean) {\n    return storageAdapterAllCollections(this).then(collections =>\n      Promise.all(\n        collections.map(collection => (fast ? collection.deleteMany({}) : collection.drop()))\n      )\n    );\n  }\n\n  // Remove the column and all the data. For Relations, the _Join collection is handled\n  // specially, this function does not delete _Join columns. It should, however, indicate\n  // that the relation fields does not exist anymore. In mongo, this means removing it from\n  // the _SCHEMA collection.  There should be no actual data in the collection under the same name\n  // as the relation column, so it's fine to attempt to delete it. If the fields listed to be\n  // deleted do not exist, this function should return successfully anyways. Checking for\n  // attempts to delete non-existent fields is the responsibility of Parse Server.\n\n  // Pointer field names are passed for legacy reasons: the original mongo\n  // format stored pointer field names differently in the database, and therefore\n  // needed to know the type of the field before it could delete it. Future database\n  // adapters should ignore the pointerFieldNames argument. All the field names are in\n  // fieldNames, they show up additionally in the pointerFieldNames database for use\n  // by the mongo adapter, which deals with the legacy mongo format.\n\n  // This function is not obligated to delete fields atomically. It is given the field\n  // names in a list so that databases that are capable of deleting fields atomically\n  // may do so.\n\n  // Returns a Promise.\n  deleteFields(className: string, schema: SchemaType, fieldNames: string[]) {\n    const mongoFormatNames = fieldNames.map(fieldName => {\n      if (schema.fields[fieldName].type === 'Pointer') {\n        return `_p_${fieldName}`;\n      } else {\n        return fieldName;\n      }\n    });\n    const collectionUpdate = { $unset: {} };\n    mongoFormatNames.forEach(name => {\n      collectionUpdate['$unset'][name] = null;\n    });\n\n    const collectionFilter = { $or: [] };\n    mongoFormatNames.forEach(name => {\n      collectionFilter['$or'].push({ [name]: { $exists: true } });\n    });\n\n    const schemaUpdate = { $unset: {} };\n    fieldNames.forEach(name => {\n      schemaUpdate['$unset'][name] = null;\n      schemaUpdate['$unset'][`_metadata.fields_options.${name}`] = null;\n    });\n\n    return this._adaptiveCollection(className)\n      .then(collection => collection.updateMany(collectionFilter, collectionUpdate))\n      .then(() => this._schemaCollection())\n      .then(schemaCollection => schemaCollection.updateSchema(className, schemaUpdate))\n      .catch(err => this.handleError(err));\n  }\n\n  // Return a promise for all schemas known to this adapter, in Parse format. In case the\n  // schemas cannot be retrieved, returns a promise that rejects. Requirements for the\n  // rejection reason are TBD.\n  getAllClasses(): Promise<StorageClass[]> {\n    return this._schemaCollection()\n      .then(schemasCollection => schemasCollection._fetchAllSchemasFrom_SCHEMA())\n      .catch(err => this.handleError(err));\n  }\n\n  // Return a promise for the schema with the given name, in Parse format. If\n  // this adapter doesn't know about the schema, return a promise that rejects with\n  // undefined as the reason.\n  getClass(className: string): Promise<StorageClass> {\n    return this._schemaCollection()\n      .then(schemasCollection => schemasCollection._fetchOneSchemaFrom_SCHEMA(className))\n      .catch(err => this.handleError(err));\n  }\n\n  // TODO: As yet not particularly well specified. Creates an object. Maybe shouldn't even need the schema,\n  // and should infer from the type. Or maybe does need the schema for validations. Or maybe needs\n  // the schema only for the legacy mongo format. We'll figure that out later.\n  createObject(className: string, schema: SchemaType, object: any, transactionalSession: ?any) {\n    schema = convertParseSchemaToMongoSchema(schema);\n    const mongoObject = parseObjectToMongoObjectForCreate(className, object, schema);\n    return this._adaptiveCollection(className)\n      .then(collection => collection.insertOne(mongoObject, transactionalSession))\n      .catch(error => {\n        if (error.code === 11000) {\n          // Duplicate value\n          const err = new Parse.Error(\n            Parse.Error.DUPLICATE_VALUE,\n            'A duplicate value for a field with unique values was provided'\n          );\n          err.underlyingError = error;\n          if (error.message) {\n            const matches = error.message.match(/index:[\\sa-zA-Z0-9_\\-\\.]+\\$?([a-zA-Z_-]+)_1/);\n            if (matches && Array.isArray(matches)) {\n              err.userInfo = { duplicated_field: matches[1] };\n            }\n          }\n          throw err;\n        }\n        throw error;\n      })\n      .catch(err => this.handleError(err));\n  }\n\n  // Remove all objects that match the given Parse Query.\n  // If no objects match, reject with OBJECT_NOT_FOUND. If objects are found and deleted, resolve with undefined.\n  // If there is some other error, reject with INTERNAL_SERVER_ERROR.\n  deleteObjectsByQuery(\n    className: string,\n    schema: SchemaType,\n    query: QueryType,\n    transactionalSession: ?any\n  ) {\n    schema = convertParseSchemaToMongoSchema(schema);\n    return this._adaptiveCollection(className)\n      .then(collection => {\n        const mongoWhere = transformWhere(className, query, schema);\n        return collection.deleteMany(mongoWhere, transactionalSession);\n      })\n      .catch(err => this.handleError(err))\n      .then(\n        ({ result }) => {\n          if (result.n === 0) {\n            throw new Parse.Error(Parse.Error.OBJECT_NOT_FOUND, 'Object not found.');\n          }\n          return Promise.resolve();\n        },\n        () => {\n          throw new Parse.Error(Parse.Error.INTERNAL_SERVER_ERROR, 'Database adapter error');\n        }\n      );\n  }\n\n  // Apply the update to all objects that match the given Parse Query.\n  updateObjectsByQuery(\n    className: string,\n    schema: SchemaType,\n    query: QueryType,\n    update: any,\n    transactionalSession: ?any\n  ) {\n    schema = convertParseSchemaToMongoSchema(schema);\n    const mongoUpdate = transformUpdate(className, update, schema);\n    const mongoWhere = transformWhere(className, query, schema);\n    return this._adaptiveCollection(className)\n      .then(collection => collection.updateMany(mongoWhere, mongoUpdate, transactionalSession))\n      .catch(err => this.handleError(err));\n  }\n\n  // Atomically finds and updates an object based on query.\n  // Return value not currently well specified.\n  findOneAndUpdate(\n    className: string,\n    schema: SchemaType,\n    query: QueryType,\n    update: any,\n    transactionalSession: ?any\n  ) {\n    schema = convertParseSchemaToMongoSchema(schema);\n    const mongoUpdate = transformUpdate(className, update, schema);\n    const mongoWhere = transformWhere(className, query, schema);\n    return this._adaptiveCollection(className)\n      .then(collection =>\n        collection._mongoCollection.findOneAndUpdate(mongoWhere, mongoUpdate, {\n          returnOriginal: false,\n          session: transactionalSession || undefined,\n        })\n      )\n      .then(result => mongoObjectToParseObject(className, result.value, schema))\n      .catch(error => {\n        if (error.code === 11000) {\n          throw new Parse.Error(\n            Parse.Error.DUPLICATE_VALUE,\n            'A duplicate value for a field with unique values was provided'\n          );\n        }\n        throw error;\n      })\n      .catch(err => this.handleError(err));\n  }\n\n  // Hopefully we can get rid of this. It's only used for config and hooks.\n  upsertOneObject(\n    className: string,\n    schema: SchemaType,\n    query: QueryType,\n    update: any,\n    transactionalSession: ?any\n  ) {\n    schema = convertParseSchemaToMongoSchema(schema);\n    const mongoUpdate = transformUpdate(className, update, schema);\n    const mongoWhere = transformWhere(className, query, schema);\n    return this._adaptiveCollection(className)\n      .then(collection => collection.upsertOne(mongoWhere, mongoUpdate, transactionalSession))\n      .catch(err => this.handleError(err));\n  }\n\n  // Executes a find. Accepts: className, query in Parse format, and { skip, limit, sort }.\n  find(\n    className: string,\n    schema: SchemaType,\n    query: QueryType,\n    { skip, limit, sort, keys, readPreference, hint, caseInsensitive, explain }: QueryOptions\n  ): Promise<any> {\n    schema = convertParseSchemaToMongoSchema(schema);\n    const mongoWhere = transformWhere(className, query, schema);\n    const mongoSort = _.mapKeys(sort, (value, fieldName) =>\n      transformKey(className, fieldName, schema)\n    );\n    const mongoKeys = _.reduce(\n      keys,\n      (memo, key) => {\n        if (key === 'ACL') {\n          memo['_rperm'] = 1;\n          memo['_wperm'] = 1;\n        } else {\n          memo[transformKey(className, key, schema)] = 1;\n        }\n        return memo;\n      },\n      {}\n    );\n\n    // If we aren't requesting the `_id` field, we need to explicitly opt out\n    // of it. Doing so in parse-server is unusual, but it can allow us to\n    // optimize some queries with covering indexes.\n    if (keys && !mongoKeys._id) {\n      mongoKeys._id = 0;\n    }\n\n    readPreference = this._parseReadPreference(readPreference);\n    return this.createTextIndexesIfNeeded(className, query, schema)\n      .then(() => this._adaptiveCollection(className))\n      .then(collection =>\n        collection.find(mongoWhere, {\n          skip,\n          limit,\n          sort: mongoSort,\n          keys: mongoKeys,\n          maxTimeMS: this._maxTimeMS,\n          readPreference,\n          hint,\n          caseInsensitive,\n          explain,\n        })\n      )\n      .then(objects => {\n        if (explain) {\n          return objects;\n        }\n        return objects.map(object => mongoObjectToParseObject(className, object, schema));\n      })\n      .catch(err => this.handleError(err));\n  }\n\n  ensureIndex(\n    className: string,\n    schema: SchemaType,\n    fieldNames: string[],\n    indexName: ?string,\n    caseInsensitive: boolean = false,\n    options?: Object = {}\n  ): Promise<any> {\n    schema = convertParseSchemaToMongoSchema(schema);\n    const indexCreationRequest = {};\n    const mongoFieldNames = fieldNames.map(fieldName => transformKey(className, fieldName, schema));\n    mongoFieldNames.forEach(fieldName => {\n      indexCreationRequest[fieldName] = options.indexType !== undefined ? options.indexType : 1;\n    });\n\n    const defaultOptions: Object = { background: true, sparse: true };\n    const indexNameOptions: Object = indexName ? { name: indexName } : {};\n    const ttlOptions: Object = options.ttl !== undefined ? { expireAfterSeconds: options.ttl } : {};\n    const caseInsensitiveOptions: Object = caseInsensitive\n      ? { collation: MongoCollection.caseInsensitiveCollation() }\n      : {};\n    const indexOptions: Object = {\n      ...defaultOptions,\n      ...caseInsensitiveOptions,\n      ...indexNameOptions,\n      ...ttlOptions,\n    };\n\n    return this._adaptiveCollection(className)\n      .then(\n        collection =>\n          new Promise((resolve, reject) =>\n            collection._mongoCollection.createIndex(indexCreationRequest, indexOptions, error =>\n              error ? reject(error) : resolve()\n            )\n          )\n      )\n      .catch(err => this.handleError(err));\n  }\n\n  // Create a unique index. Unique indexes on nullable fields are not allowed. Since we don't\n  // currently know which fields are nullable and which aren't, we ignore that criteria.\n  // As such, we shouldn't expose this function to users of parse until we have an out-of-band\n  // Way of determining if a field is nullable. Undefined doesn't count against uniqueness,\n  // which is why we use sparse indexes.\n  ensureUniqueness(className: string, schema: SchemaType, fieldNames: string[]) {\n    schema = convertParseSchemaToMongoSchema(schema);\n    const indexCreationRequest = {};\n    const mongoFieldNames = fieldNames.map(fieldName => transformKey(className, fieldName, schema));\n    mongoFieldNames.forEach(fieldName => {\n      indexCreationRequest[fieldName] = 1;\n    });\n    return this._adaptiveCollection(className)\n      .then(collection => collection._ensureSparseUniqueIndexInBackground(indexCreationRequest))\n      .catch(error => {\n        if (error.code === 11000) {\n          throw new Parse.Error(\n            Parse.Error.DUPLICATE_VALUE,\n            'Tried to ensure field uniqueness for a class that already has duplicates.'\n          );\n        }\n        throw error;\n      })\n      .catch(err => this.handleError(err));\n  }\n\n  // Used in tests\n  _rawFind(className: string, query: QueryType) {\n    return this._adaptiveCollection(className)\n      .then(collection =>\n        collection.find(query, {\n          maxTimeMS: this._maxTimeMS,\n        })\n      )\n      .catch(err => this.handleError(err));\n  }\n\n  // Executes a count.\n  count(\n    className: string,\n    schema: SchemaType,\n    query: QueryType,\n    readPreference: ?string,\n    hint: ?mixed\n  ) {\n    schema = convertParseSchemaToMongoSchema(schema);\n    readPreference = this._parseReadPreference(readPreference);\n    return this._adaptiveCollection(className)\n      .then(collection =>\n        collection.count(transformWhere(className, query, schema, true), {\n          maxTimeMS: this._maxTimeMS,\n          readPreference,\n          hint,\n        })\n      )\n      .catch(err => this.handleError(err));\n  }\n\n  distinct(className: string, schema: SchemaType, query: QueryType, fieldName: string) {\n    schema = convertParseSchemaToMongoSchema(schema);\n    const isPointerField = schema.fields[fieldName] && schema.fields[fieldName].type === 'Pointer';\n    const transformField = transformKey(className, fieldName, schema);\n\n    return this._adaptiveCollection(className)\n      .then(collection =>\n        collection.distinct(transformField, transformWhere(className, query, schema))\n      )\n      .then(objects => {\n        objects = objects.filter(obj => obj != null);\n        return objects.map(object => {\n          if (isPointerField) {\n            return transformPointerString(schema, fieldName, object);\n          }\n          return mongoObjectToParseObject(className, object, schema);\n        });\n      })\n      .catch(err => this.handleError(err));\n  }\n\n  aggregate(\n    className: string,\n    schema: any,\n    pipeline: any,\n    readPreference: ?string,\n    hint: ?mixed,\n    explain?: boolean\n  ) {\n    let isPointerField = false;\n    pipeline = pipeline.map(stage => {\n      if (stage.$group) {\n        stage.$group = this._parseAggregateGroupArgs(schema, stage.$group);\n        if (\n          stage.$group._id &&\n          typeof stage.$group._id === 'string' &&\n          stage.$group._id.indexOf('$_p_') >= 0\n        ) {\n          isPointerField = true;\n        }\n      }\n      if (stage.$match) {\n        stage.$match = this._parseAggregateArgs(schema, stage.$match);\n      }\n      if (stage.$project) {\n        stage.$project = this._parseAggregateProjectArgs(schema, stage.$project);\n      }\n      if (stage.$geoNear && stage.$geoNear.query) {\n        stage.$geoNear.query = this._parseAggregateArgs(schema, stage.$geoNear.query);\n      }\n      return stage;\n    });\n    readPreference = this._parseReadPreference(readPreference);\n    return this._adaptiveCollection(className)\n      .then(collection =>\n        collection.aggregate(pipeline, {\n          readPreference,\n          maxTimeMS: this._maxTimeMS,\n          hint,\n          explain,\n        })\n      )\n      .then(results => {\n        results.forEach(result => {\n          if (Object.prototype.hasOwnProperty.call(result, '_id')) {\n            if (isPointerField && result._id) {\n              result._id = result._id.split('$')[1];\n            }\n            if (\n              result._id == null ||\n              result._id == undefined ||\n              (['object', 'string'].includes(typeof result._id) && _.isEmpty(result._id))\n            ) {\n              result._id = null;\n            }\n            result.objectId = result._id;\n            delete result._id;\n          }\n        });\n        return results;\n      })\n      .then(objects => objects.map(object => mongoObjectToParseObject(className, object, schema)))\n      .catch(err => this.handleError(err));\n  }\n\n  // This function will recursively traverse the pipeline and convert any Pointer or Date columns.\n  // If we detect a pointer column we will rename the column being queried for to match the column\n  // in the database. We also modify the value to what we expect the value to be in the database\n  // as well.\n  // For dates, the driver expects a Date object, but we have a string coming in. So we'll convert\n  // the string to a Date so the driver can perform the necessary comparison.\n  //\n  // The goal of this method is to look for the \"leaves\" of the pipeline and determine if it needs\n  // to be converted. The pipeline can have a few different forms. For more details, see:\n  //     https://docs.mongodb.com/manual/reference/operator/aggregation/\n  //\n  // If the pipeline is an array, it means we are probably parsing an '$and' or '$or' operator. In\n  // that case we need to loop through all of it's children to find the columns being operated on.\n  // If the pipeline is an object, then we'll loop through the keys checking to see if the key name\n  // matches one of the schema columns. If it does match a column and the column is a Pointer or\n  // a Date, then we'll convert the value as described above.\n  //\n  // As much as I hate recursion...this seemed like a good fit for it. We're essentially traversing\n  // down a tree to find a \"leaf node\" and checking to see if it needs to be converted.\n  _parseAggregateArgs(schema: any, pipeline: any): any {\n    if (pipeline === null) {\n      return null;\n    } else if (Array.isArray(pipeline)) {\n      return pipeline.map(value => this._parseAggregateArgs(schema, value));\n    } else if (typeof pipeline === 'object') {\n      const returnValue = {};\n      for (const field in pipeline) {\n        if (schema.fields[field] && schema.fields[field].type === 'Pointer') {\n          if (typeof pipeline[field] === 'object') {\n            // Pass objects down to MongoDB...this is more than likely an $exists operator.\n            returnValue[`_p_${field}`] = pipeline[field];\n          } else {\n            returnValue[`_p_${field}`] = `${schema.fields[field].targetClass}$${pipeline[field]}`;\n          }\n        } else if (schema.fields[field] && schema.fields[field].type === 'Date') {\n          returnValue[field] = this._convertToDate(pipeline[field]);\n        } else {\n          returnValue[field] = this._parseAggregateArgs(schema, pipeline[field]);\n        }\n\n        if (field === 'objectId') {\n          returnValue['_id'] = returnValue[field];\n          delete returnValue[field];\n        } else if (field === 'createdAt') {\n          returnValue['_created_at'] = returnValue[field];\n          delete returnValue[field];\n        } else if (field === 'updatedAt') {\n          returnValue['_updated_at'] = returnValue[field];\n          delete returnValue[field];\n        }\n      }\n      return returnValue;\n    }\n    return pipeline;\n  }\n\n  // This function is slightly different than the one above. Rather than trying to combine these\n  // two functions and making the code even harder to understand, I decided to split it up. The\n  // difference with this function is we are not transforming the values, only the keys of the\n  // pipeline.\n  _parseAggregateProjectArgs(schema: any, pipeline: any): any {\n    const returnValue = {};\n    for (const field in pipeline) {\n      if (schema.fields[field] && schema.fields[field].type === 'Pointer') {\n        returnValue[`_p_${field}`] = pipeline[field];\n      } else {\n        returnValue[field] = this._parseAggregateArgs(schema, pipeline[field]);\n      }\n\n      if (field === 'objectId') {\n        returnValue['_id'] = returnValue[field];\n        delete returnValue[field];\n      } else if (field === 'createdAt') {\n        returnValue['_created_at'] = returnValue[field];\n        delete returnValue[field];\n      } else if (field === 'updatedAt') {\n        returnValue['_updated_at'] = returnValue[field];\n        delete returnValue[field];\n      }\n    }\n    return returnValue;\n  }\n\n  // This function is slightly different than the two above. MongoDB $group aggregate looks like:\n  //     { $group: { _id: <expression>, <field1>: { <accumulator1> : <expression1> }, ... } }\n  // The <expression> could be a column name, prefixed with the '$' character. We'll look for\n  // these <expression> and check to see if it is a 'Pointer' or if it's one of createdAt,\n  // updatedAt or objectId and change it accordingly.\n  _parseAggregateGroupArgs(schema: any, pipeline: any): any {\n    if (Array.isArray(pipeline)) {\n      return pipeline.map(value => this._parseAggregateGroupArgs(schema, value));\n    } else if (typeof pipeline === 'object') {\n      const returnValue = {};\n      for (const field in pipeline) {\n        returnValue[field] = this._parseAggregateGroupArgs(schema, pipeline[field]);\n      }\n      return returnValue;\n    } else if (typeof pipeline === 'string') {\n      const field = pipeline.substring(1);\n      if (schema.fields[field] && schema.fields[field].type === 'Pointer') {\n        return `$_p_${field}`;\n      } else if (field == 'createdAt') {\n        return '$_created_at';\n      } else if (field == 'updatedAt') {\n        return '$_updated_at';\n      }\n    }\n    return pipeline;\n  }\n\n  // This function will attempt to convert the provided value to a Date object. Since this is part\n  // of an aggregation pipeline, the value can either be a string or it can be another object with\n  // an operator in it (like $gt, $lt, etc). Because of this I felt it was easier to make this a\n  // recursive method to traverse down to the \"leaf node\" which is going to be the string.\n  _convertToDate(value: any): any {\n    if (typeof value === 'string') {\n      return new Date(value);\n    }\n\n    const returnValue = {};\n    for (const field in value) {\n      returnValue[field] = this._convertToDate(value[field]);\n    }\n    return returnValue;\n  }\n\n  _parseReadPreference(readPreference: ?string): ?string {\n    if (readPreference) {\n      readPreference = readPreference.toUpperCase();\n    }\n    switch (readPreference) {\n      case 'PRIMARY':\n        readPreference = ReadPreference.PRIMARY;\n        break;\n      case 'PRIMARY_PREFERRED':\n        readPreference = ReadPreference.PRIMARY_PREFERRED;\n        break;\n      case 'SECONDARY':\n        readPreference = ReadPreference.SECONDARY;\n        break;\n      case 'SECONDARY_PREFERRED':\n        readPreference = ReadPreference.SECONDARY_PREFERRED;\n        break;\n      case 'NEAREST':\n        readPreference = ReadPreference.NEAREST;\n        break;\n      case undefined:\n      case null:\n      case '':\n        break;\n      default:\n        throw new Parse.Error(Parse.Error.INVALID_QUERY, 'Not supported read preference.');\n    }\n    return readPreference;\n  }\n\n  performInitialization(): Promise<void> {\n    return Promise.resolve();\n  }\n\n  createIndex(className: string, index: any) {\n    return this._adaptiveCollection(className)\n      .then(collection => collection._mongoCollection.createIndex(index))\n      .catch(err => this.handleError(err));\n  }\n\n  createIndexes(className: string, indexes: any) {\n    return this._adaptiveCollection(className)\n      .then(collection => collection._mongoCollection.createIndexes(indexes))\n      .catch(err => this.handleError(err));\n  }\n\n  createIndexesIfNeeded(className: string, fieldName: string, type: any) {\n    if (type && type.type === 'Polygon') {\n      const index = {\n        [fieldName]: '2dsphere',\n      };\n      return this.createIndex(className, index);\n    }\n    return Promise.resolve();\n  }\n\n  createTextIndexesIfNeeded(className: string, query: QueryType, schema: any): Promise<void> {\n    for (const fieldName in query) {\n      if (!query[fieldName] || !query[fieldName].$text) {\n        continue;\n      }\n      const existingIndexes = schema.indexes;\n      for (const key in existingIndexes) {\n        const index = existingIndexes[key];\n        if (Object.prototype.hasOwnProperty.call(index, fieldName)) {\n          return Promise.resolve();\n        }\n      }\n      const indexName = `${fieldName}_text`;\n      const textIndex = {\n        [indexName]: { [fieldName]: 'text' },\n      };\n      return this.setIndexesWithSchemaFormat(\n        className,\n        textIndex,\n        existingIndexes,\n        schema.fields\n      ).catch(error => {\n        if (error.code === 85) {\n          // Index exist with different options\n          return this.setIndexesFromMongo(className);\n        }\n        throw error;\n      });\n    }\n    return Promise.resolve();\n  }\n\n  getIndexes(className: string) {\n    return this._adaptiveCollection(className)\n      .then(collection => collection._mongoCollection.indexes())\n      .catch(err => this.handleError(err));\n  }\n\n  dropIndex(className: string, index: any) {\n    return this._adaptiveCollection(className)\n      .then(collection => collection._mongoCollection.dropIndex(index))\n      .catch(err => this.handleError(err));\n  }\n\n  dropAllIndexes(className: string) {\n    return this._adaptiveCollection(className)\n      .then(collection => collection._mongoCollection.dropIndexes())\n      .catch(err => this.handleError(err));\n  }\n\n  updateSchemaWithIndexes(): Promise<any> {\n    return this.getAllClasses()\n      .then(classes => {\n        const promises = classes.map(schema => {\n          return this.setIndexesFromMongo(schema.className);\n        });\n        return Promise.all(promises);\n      })\n      .catch(err => this.handleError(err));\n  }\n\n  createTransactionalSession(): Promise<any> {\n    const transactionalSection = this.client.startSession();\n    transactionalSection.startTransaction();\n    return Promise.resolve(transactionalSection);\n  }\n\n  commitTransactionalSession(transactionalSection: any): Promise<void> {\n    const commit = retries => {\n      return transactionalSection\n        .commitTransaction()\n        .catch(error => {\n          if (error && error.hasErrorLabel('TransientTransactionError') && retries > 0) {\n            return commit(retries - 1);\n          }\n          throw error;\n        })\n        .then(() => {\n          transactionalSection.endSession();\n        });\n    };\n    return commit(5);\n  }\n\n  abortTransactionalSession(transactionalSection: any): Promise<void> {\n    return transactionalSection.abortTransaction().then(() => {\n      transactionalSection.endSession();\n    });\n  }\n}\n\nexport default MongoStorageAdapter;\n", "// An object that encapsulates everything we need to run a 'find'\n// operation, encoded in the REST API format.\n\nvar SchemaController = require('./Controllers/SchemaController');\nvar Parse = require('parse/node').Parse;\nconst triggers = require('./triggers');\nconst { continueWhile } = require('parse/lib/node/promiseUtils');\nconst AlwaysSelectedKeys = ['objectId', 'createdAt', 'updatedAt', 'ACL'];\n// restOptions can include:\n//   skip\n//   limit\n//   order\n//   count\n//   include\n//   keys\n//   excludeKeys\n//   redirectClassNameForKey\n//   readPreference\n//   includeReadPreference\n//   subqueryReadPreference\nfunction RestQuery(\n  config,\n  auth,\n  className,\n  restWhere = {},\n  restOptions = {},\n  clientSDK,\n  runAfterFind = true,\n  context\n) {\n  this.config = config;\n  this.auth = auth;\n  this.className = className;\n  this.restWhere = restWhere;\n  this.restOptions = restOptions;\n  this.clientSDK = clientSDK;\n  this.runAfterFind = runAfterFind;\n  this.response = null;\n  this.findOptions = {};\n  this.context = context || {};\n  if (!this.auth.isMaster) {\n    if (this.className == '_Session') {\n      if (!this.auth.user) {\n        throw new Parse.Error(Parse.Error.INVALID_SESSION_TOKEN, 'Invalid session token');\n      }\n      this.restWhere = {\n        $and: [\n          this.restWhere,\n          {\n            user: {\n              __type: 'Pointer',\n              className: '_User',\n              objectId: this.auth.user.id,\n            },\n          },\n        ],\n      };\n    }\n  }\n\n  this.doCount = false;\n  this.includeAll = false;\n\n  // The format for this.include is not the same as the format for the\n  // include option - it's the paths we should include, in order,\n  // stored as arrays, taking into account that we need to include foo\n  // before including foo.bar. Also it should dedupe.\n  // For example, passing an arg of include=foo.bar,foo.baz could lead to\n  // this.include = [['foo'], ['foo', 'baz'], ['foo', 'bar']]\n  this.include = [];\n  let keysForInclude = '';\n\n  // If we have keys, we probably want to force some includes (n-1 level)\n  // See issue: https://github.com/parse-community/parse-server/issues/3185\n  if (Object.prototype.hasOwnProperty.call(restOptions, 'keys')) {\n    keysForInclude = restOptions.keys;\n  }\n\n  // If we have keys, we probably want to force some includes (n-1 level)\n  // in order to exclude specific keys.\n  if (Object.prototype.hasOwnProperty.call(restOptions, 'excludeKeys')) {\n    keysForInclude += ',' + restOptions.excludeKeys;\n  }\n\n  if (keysForInclude.length > 0) {\n    keysForInclude = keysForInclude\n      .split(',')\n      .filter(key => {\n        // At least 2 components\n        return key.split('.').length > 1;\n      })\n      .map(key => {\n        // Slice the last component (a.b.c -> a.b)\n        // Otherwise we'll include one level too much.\n        return key.slice(0, key.lastIndexOf('.'));\n      })\n      .join(',');\n\n    // Concat the possibly present include string with the one from the keys\n    // Dedup / sorting is handle in 'include' case.\n    if (keysForInclude.length > 0) {\n      if (!restOptions.include || restOptions.include.length == 0) {\n        restOptions.include = keysForInclude;\n      } else {\n        restOptions.include += ',' + keysForInclude;\n      }\n    }\n  }\n\n  for (var option in restOptions) {\n    switch (option) {\n      case 'keys': {\n        const keys = restOptions.keys\n          .split(',')\n          .filter(key => key.length > 0)\n          .concat(AlwaysSelectedKeys);\n        this.keys = Array.from(new Set(keys));\n        break;\n      }\n      case 'excludeKeys': {\n        const exclude = restOptions.excludeKeys\n          .split(',')\n          .filter(k => AlwaysSelectedKeys.indexOf(k) < 0);\n        this.excludeKeys = Array.from(new Set(exclude));\n        break;\n      }\n      case 'count':\n        this.doCount = true;\n        break;\n      case 'includeAll':\n        this.includeAll = true;\n        break;\n      case 'explain':\n      case 'hint':\n      case 'distinct':\n      case 'pipeline':\n      case 'skip':\n      case 'limit':\n      case 'readPreference':\n        this.findOptions[option] = restOptions[option];\n        break;\n      case 'order':\n        var fields = restOptions.order.split(',');\n        this.findOptions.sort = fields.reduce((sortMap, field) => {\n          field = field.trim();\n          if (field === '$score') {\n            sortMap.score = { $meta: 'textScore' };\n          } else if (field[0] == '-') {\n            sortMap[field.slice(1)] = -1;\n          } else {\n            sortMap[field] = 1;\n          }\n          return sortMap;\n        }, {});\n        break;\n      case 'include': {\n        const paths = restOptions.include.split(',');\n        if (paths.includes('*')) {\n          this.includeAll = true;\n          break;\n        }\n        // Load the existing includes (from keys)\n        const pathSet = paths.reduce((memo, path) => {\n          // Split each paths on . (a.b.c -> [a,b,c])\n          // reduce to create all paths\n          // ([a,b,c] -> {a: true, 'a.b': true, 'a.b.c': true})\n          return path.split('.').reduce((memo, path, index, parts) => {\n            memo[parts.slice(0, index + 1).join('.')] = true;\n            return memo;\n          }, memo);\n        }, {});\n\n        this.include = Object.keys(pathSet)\n          .map(s => {\n            return s.split('.');\n          })\n          .sort((a, b) => {\n            return a.length - b.length; // Sort by number of components\n          });\n        break;\n      }\n      case 'redirectClassNameForKey':\n        this.redirectKey = restOptions.redirectClassNameForKey;\n        this.redirectClassName = null;\n        break;\n      case 'includeReadPreference':\n      case 'subqueryReadPreference':\n        break;\n      default:\n        throw new Parse.Error(Parse.Error.INVALID_JSON, 'bad option: ' + option);\n    }\n  }\n}\n\n// A convenient method to perform all the steps of processing a query\n// in order.\n// Returns a promise for the response - an object with optional keys\n// 'results' and 'count'.\n// TODO: consolidate the replaceX functions\nRestQuery.prototype.execute = function (executeOptions) {\n  return Promise.resolve()\n    .then(() => {\n      return this.buildRestWhere();\n    })\n    .then(() => {\n      return this.handleIncludeAll();\n    })\n    .then(() => {\n      return this.handleExcludeKeys();\n    })\n    .then(() => {\n      return this.runFind(executeOptions);\n    })\n    .then(() => {\n      return this.runCount();\n    })\n    .then(() => {\n      return this.handleInclude();\n    })\n    .then(() => {\n      return this.runAfterFindTrigger();\n    })\n    .then(() => {\n      return this.response;\n    });\n};\n\nRestQuery.prototype.each = function (callback) {\n  const { config, auth, className, restWhere, restOptions, clientSDK } = this;\n  // if the limit is set, use it\n  restOptions.limit = restOptions.limit || 100;\n  restOptions.order = 'objectId';\n  let finished = false;\n\n  return continueWhile(\n    () => {\n      return !finished;\n    },\n    async () => {\n      const query = new RestQuery(\n        config,\n        auth,\n        className,\n        restWhere,\n        restOptions,\n        clientSDK,\n        this.runAfterFind,\n        this.context\n      );\n      const { results } = await query.execute();\n      results.forEach(callback);\n      finished = results.length < restOptions.limit;\n      if (!finished) {\n        restWhere.objectId = Object.assign({}, restWhere.objectId, {\n          $gt: results[results.length - 1].objectId,\n        });\n      }\n    }\n  );\n};\n\nRestQuery.prototype.buildRestWhere = function () {\n  return Promise.resolve()\n    .then(() => {\n      return this.getUserAndRoleACL();\n    })\n    .then(() => {\n      return this.redirectClassNameForKey();\n    })\n    .then(() => {\n      return this.validateClientClassCreation();\n    })\n    .then(() => {\n      return this.replaceSelect();\n    })\n    .then(() => {\n      return this.replaceDontSelect();\n    })\n    .then(() => {\n      return this.replaceInQuery();\n    })\n    .then(() => {\n      return this.replaceNotInQuery();\n    })\n    .then(() => {\n      return this.replaceEquality();\n    });\n};\n\n// Uses the Auth object to get the list of roles, adds the user id\nRestQuery.prototype.getUserAndRoleACL = function () {\n  if (this.auth.isMaster) {\n    return Promise.resolve();\n  }\n\n  this.findOptions.acl = ['*'];\n\n  if (this.auth.user) {\n    return this.auth.getUserRoles().then(roles => {\n      this.findOptions.acl = this.findOptions.acl.concat(roles, [this.auth.user.id]);\n      return;\n    });\n  } else {\n    return Promise.resolve();\n  }\n};\n\n// Changes the className if redirectClassNameForKey is set.\n// Returns a promise.\nRestQuery.prototype.redirectClassNameForKey = function () {\n  if (!this.redirectKey) {\n    return Promise.resolve();\n  }\n\n  // We need to change the class name based on the schema\n  return this.config.database\n    .redirectClassNameForKey(this.className, this.redirectKey)\n    .then(newClassName => {\n      this.className = newClassName;\n      this.redirectClassName = newClassName;\n    });\n};\n\n// Validates this operation against the allowClientClassCreation config.\nRestQuery.prototype.validateClientClassCreation = function () {\n  if (\n    this.config.allowClientClassCreation === false &&\n    !this.auth.isMaster &&\n    SchemaController.systemClasses.indexOf(this.className) === -1\n  ) {\n    return this.config.database\n      .loadSchema()\n      .then(schemaController => schemaController.hasClass(this.className))\n      .then(hasClass => {\n        if (hasClass !== true) {\n          throw new Parse.Error(\n            Parse.Error.OPERATION_FORBIDDEN,\n            'This user is not allowed to access ' + 'non-existent class: ' + this.className\n          );\n        }\n      });\n  } else {\n    return Promise.resolve();\n  }\n};\n\nfunction transformInQuery(inQueryObject, className, results) {\n  var values = [];\n  for (var result of results) {\n    values.push({\n      __type: 'Pointer',\n      className: className,\n      objectId: result.objectId,\n    });\n  }\n  delete inQueryObject['$inQuery'];\n  if (Array.isArray(inQueryObject['$in'])) {\n    inQueryObject['$in'] = inQueryObject['$in'].concat(values);\n  } else {\n    inQueryObject['$in'] = values;\n  }\n}\n\n// Replaces a $inQuery clause by running the subquery, if there is an\n// $inQuery clause.\n// The $inQuery clause turns into an $in with values that are just\n// pointers to the objects returned in the subquery.\nRestQuery.prototype.replaceInQuery = function () {\n  var inQueryObject = findObjectWithKey(this.restWhere, '$inQuery');\n  if (!inQueryObject) {\n    return;\n  }\n\n  // The inQuery value must have precisely two keys - where and className\n  var inQueryValue = inQueryObject['$inQuery'];\n  if (!inQueryValue.where || !inQueryValue.className) {\n    throw new Parse.Error(Parse.Error.INVALID_QUERY, 'improper usage of $inQuery');\n  }\n\n  const additionalOptions = {\n    redirectClassNameForKey: inQueryValue.redirectClassNameForKey,\n  };\n\n  if (this.restOptions.subqueryReadPreference) {\n    additionalOptions.readPreference = this.restOptions.subqueryReadPreference;\n    additionalOptions.subqueryReadPreference = this.restOptions.subqueryReadPreference;\n  } else if (this.restOptions.readPreference) {\n    additionalOptions.readPreference = this.restOptions.readPreference;\n  }\n\n  var subquery = new RestQuery(\n    this.config,\n    this.auth,\n    inQueryValue.className,\n    inQueryValue.where,\n    additionalOptions\n  );\n  return subquery.execute().then(response => {\n    transformInQuery(inQueryObject, subquery.className, response.results);\n    // Recurse to repeat\n    return this.replaceInQuery();\n  });\n};\n\nfunction transformNotInQuery(notInQueryObject, className, results) {\n  var values = [];\n  for (var result of results) {\n    values.push({\n      __type: 'Pointer',\n      className: className,\n      objectId: result.objectId,\n    });\n  }\n  delete notInQueryObject['$notInQuery'];\n  if (Array.isArray(notInQueryObject['$nin'])) {\n    notInQueryObject['$nin'] = notInQueryObject['$nin'].concat(values);\n  } else {\n    notInQueryObject['$nin'] = values;\n  }\n}\n\n// Replaces a $notInQuery clause by running the subquery, if there is an\n// $notInQuery clause.\n// The $notInQuery clause turns into a $nin with values that are just\n// pointers to the objects returned in the subquery.\nRestQuery.prototype.replaceNotInQuery = function () {\n  var notInQueryObject = findObjectWithKey(this.restWhere, '$notInQuery');\n  if (!notInQueryObject) {\n    return;\n  }\n\n  // The notInQuery value must have precisely two keys - where and className\n  var notInQueryValue = notInQueryObject['$notInQuery'];\n  if (!notInQueryValue.where || !notInQueryValue.className) {\n    throw new Parse.Error(Parse.Error.INVALID_QUERY, 'improper usage of $notInQuery');\n  }\n\n  const additionalOptions = {\n    redirectClassNameForKey: notInQueryValue.redirectClassNameForKey,\n  };\n\n  if (this.restOptions.subqueryReadPreference) {\n    additionalOptions.readPreference = this.restOptions.subqueryReadPreference;\n    additionalOptions.subqueryReadPreference = this.restOptions.subqueryReadPreference;\n  } else if (this.restOptions.readPreference) {\n    additionalOptions.readPreference = this.restOptions.readPreference;\n  }\n\n  var subquery = new RestQuery(\n    this.config,\n    this.auth,\n    notInQueryValue.className,\n    notInQueryValue.where,\n    additionalOptions\n  );\n  return subquery.execute().then(response => {\n    transformNotInQuery(notInQueryObject, subquery.className, response.results);\n    // Recurse to repeat\n    return this.replaceNotInQuery();\n  });\n};\n\n// Used to get the deepest object from json using dot notation.\nconst getDeepestObjectFromKey = (json, key, idx, src) => {\n  if (key in json) {\n    return json[key];\n  }\n  src.splice(1); // Exit Early\n};\n\nconst transformSelect = (selectObject, key, objects) => {\n  var values = [];\n  for (var result of objects) {\n    values.push(key.split('.').reduce(getDeepestObjectFromKey, result));\n  }\n  delete selectObject['$select'];\n  if (Array.isArray(selectObject['$in'])) {\n    selectObject['$in'] = selectObject['$in'].concat(values);\n  } else {\n    selectObject['$in'] = values;\n  }\n};\n\n// Replaces a $select clause by running the subquery, if there is a\n// $select clause.\n// The $select clause turns into an $in with values selected out of\n// the subquery.\n// Returns a possible-promise.\nRestQuery.prototype.replaceSelect = function () {\n  var selectObject = findObjectWithKey(this.restWhere, '$select');\n  if (!selectObject) {\n    return;\n  }\n\n  // The select value must have precisely two keys - query and key\n  var selectValue = selectObject['$select'];\n  // iOS SDK don't send where if not set, let it pass\n  if (\n    !selectValue.query ||\n    !selectValue.key ||\n    typeof selectValue.query !== 'object' ||\n    !selectValue.query.className ||\n    Object.keys(selectValue).length !== 2\n  ) {\n    throw new Parse.Error(Parse.Error.INVALID_QUERY, 'improper usage of $select');\n  }\n\n  const additionalOptions = {\n    redirectClassNameForKey: selectValue.query.redirectClassNameForKey,\n  };\n\n  if (this.restOptions.subqueryReadPreference) {\n    additionalOptions.readPreference = this.restOptions.subqueryReadPreference;\n    additionalOptions.subqueryReadPreference = this.restOptions.subqueryReadPreference;\n  } else if (this.restOptions.readPreference) {\n    additionalOptions.readPreference = this.restOptions.readPreference;\n  }\n\n  var subquery = new RestQuery(\n    this.config,\n    this.auth,\n    selectValue.query.className,\n    selectValue.query.where,\n    additionalOptions\n  );\n  return subquery.execute().then(response => {\n    transformSelect(selectObject, selectValue.key, response.results);\n    // Keep replacing $select clauses\n    return this.replaceSelect();\n  });\n};\n\nconst transformDontSelect = (dontSelectObject, key, objects) => {\n  var values = [];\n  for (var result of objects) {\n    values.push(key.split('.').reduce(getDeepestObjectFromKey, result));\n  }\n  delete dontSelectObject['$dontSelect'];\n  if (Array.isArray(dontSelectObject['$nin'])) {\n    dontSelectObject['$nin'] = dontSelectObject['$nin'].concat(values);\n  } else {\n    dontSelectObject['$nin'] = values;\n  }\n};\n\n// Replaces a $dontSelect clause by running the subquery, if there is a\n// $dontSelect clause.\n// The $dontSelect clause turns into an $nin with values selected out of\n// the subquery.\n// Returns a possible-promise.\nRestQuery.prototype.replaceDontSelect = function () {\n  var dontSelectObject = findObjectWithKey(this.restWhere, '$dontSelect');\n  if (!dontSelectObject) {\n    return;\n  }\n\n  // The dontSelect value must have precisely two keys - query and key\n  var dontSelectValue = dontSelectObject['$dontSelect'];\n  if (\n    !dontSelectValue.query ||\n    !dontSelectValue.key ||\n    typeof dontSelectValue.query !== 'object' ||\n    !dontSelectValue.query.className ||\n    Object.keys(dontSelectValue).length !== 2\n  ) {\n    throw new Parse.Error(Parse.Error.INVALID_QUERY, 'improper usage of $dontSelect');\n  }\n  const additionalOptions = {\n    redirectClassNameForKey: dontSelectValue.query.redirectClassNameForKey,\n  };\n\n  if (this.restOptions.subqueryReadPreference) {\n    additionalOptions.readPreference = this.restOptions.subqueryReadPreference;\n    additionalOptions.subqueryReadPreference = this.restOptions.subqueryReadPreference;\n  } else if (this.restOptions.readPreference) {\n    additionalOptions.readPreference = this.restOptions.readPreference;\n  }\n\n  var subquery = new RestQuery(\n    this.config,\n    this.auth,\n    dontSelectValue.query.className,\n    dontSelectValue.query.where,\n    additionalOptions\n  );\n  return subquery.execute().then(response => {\n    transformDontSelect(dontSelectObject, dontSelectValue.key, response.results);\n    // Keep replacing $dontSelect clauses\n    return this.replaceDontSelect();\n  });\n};\n\nconst cleanResultAuthData = function (result) {\n  delete result.password;\n  if (result.authData) {\n    Object.keys(result.authData).forEach(provider => {\n      if (result.authData[provider] === null) {\n        delete result.authData[provider];\n      }\n    });\n\n    if (Object.keys(result.authData).length == 0) {\n      delete result.authData;\n    }\n  }\n};\n\nconst replaceEqualityConstraint = constraint => {\n  if (typeof constraint !== 'object') {\n    return constraint;\n  }\n  const equalToObject = {};\n  let hasDirectConstraint = false;\n  let hasOperatorConstraint = false;\n  for (const key in constraint) {\n    if (key.indexOf('$') !== 0) {\n      hasDirectConstraint = true;\n      equalToObject[key] = constraint[key];\n    } else {\n      hasOperatorConstraint = true;\n    }\n  }\n  if (hasDirectConstraint && hasOperatorConstraint) {\n    constraint['$eq'] = equalToObject;\n    Object.keys(equalToObject).forEach(key => {\n      delete constraint[key];\n    });\n  }\n  return constraint;\n};\n\nRestQuery.prototype.replaceEquality = function () {\n  if (typeof this.restWhere !== 'object') {\n    return;\n  }\n  for (const key in this.restWhere) {\n    this.restWhere[key] = replaceEqualityConstraint(this.restWhere[key]);\n  }\n};\n\n// Returns a promise for whether it was successful.\n// Populates this.response with an object that only has 'results'.\nRestQuery.prototype.runFind = function (options = {}) {\n  if (this.findOptions.limit === 0) {\n    this.response = { results: [] };\n    return Promise.resolve();\n  }\n  const findOptions = Object.assign({}, this.findOptions);\n  if (this.keys) {\n    findOptions.keys = this.keys.map(key => {\n      return key.split('.')[0];\n    });\n  }\n  if (options.op) {\n    findOptions.op = options.op;\n  }\n  return this.config.database\n    .find(this.className, this.restWhere, findOptions, this.auth)\n    .then(results => {\n      if (this.className === '_User' && findOptions.explain !== true) {\n        for (var result of results) {\n          cleanResultAuthData(result);\n        }\n      }\n\n      this.config.filesController.expandFilesInObject(this.config, results);\n\n      if (this.redirectClassName) {\n        for (var r of results) {\n          r.className = this.redirectClassName;\n        }\n      }\n      this.response = { results: results };\n    });\n};\n\n// Returns a promise for whether it was successful.\n// Populates this.response.count with the count\nRestQuery.prototype.runCount = function () {\n  if (!this.doCount) {\n    return;\n  }\n  this.findOptions.count = true;\n  delete this.findOptions.skip;\n  delete this.findOptions.limit;\n  return this.config.database.find(this.className, this.restWhere, this.findOptions).then(c => {\n    this.response.count = c;\n  });\n};\n\n// Augments this.response with all pointers on an object\nRestQuery.prototype.handleIncludeAll = function () {\n  if (!this.includeAll) {\n    return;\n  }\n  return this.config.database\n    .loadSchema()\n    .then(schemaController => schemaController.getOneSchema(this.className))\n    .then(schema => {\n      const includeFields = [];\n      const keyFields = [];\n      for (const field in schema.fields) {\n        if (\n          (schema.fields[field].type && schema.fields[field].type === 'Pointer') ||\n          (schema.fields[field].type && schema.fields[field].type === 'Array')\n        ) {\n          includeFields.push([field]);\n          keyFields.push(field);\n        }\n      }\n      // Add fields to include, keys, remove dups\n      this.include = [...new Set([...this.include, ...includeFields])];\n      // if this.keys not set, then all keys are already included\n      if (this.keys) {\n        this.keys = [...new Set([...this.keys, ...keyFields])];\n      }\n    });\n};\n\n// Updates property `this.keys` to contain all keys but the ones unselected.\nRestQuery.prototype.handleExcludeKeys = function () {\n  if (!this.excludeKeys) {\n    return;\n  }\n  if (this.keys) {\n    this.keys = this.keys.filter(k => !this.excludeKeys.includes(k));\n    return;\n  }\n  return this.config.database\n    .loadSchema()\n    .then(schemaController => schemaController.getOneSchema(this.className))\n    .then(schema => {\n      const fields = Object.keys(schema.fields);\n      this.keys = fields.filter(k => !this.excludeKeys.includes(k));\n    });\n};\n\n// Augments this.response with data at the paths provided in this.include.\nRestQuery.prototype.handleInclude = function () {\n  if (this.include.length == 0) {\n    return;\n  }\n\n  var pathResponse = includePath(\n    this.config,\n    this.auth,\n    this.response,\n    this.include[0],\n    this.restOptions\n  );\n  if (pathResponse.then) {\n    return pathResponse.then(newResponse => {\n      this.response = newResponse;\n      this.include = this.include.slice(1);\n      return this.handleInclude();\n    });\n  } else if (this.include.length > 0) {\n    this.include = this.include.slice(1);\n    return this.handleInclude();\n  }\n\n  return pathResponse;\n};\n\n//Returns a promise of a processed set of results\nRestQuery.prototype.runAfterFindTrigger = function () {\n  if (!this.response) {\n    return;\n  }\n  if (!this.runAfterFind) {\n    return;\n  }\n  // Avoid doing any setup for triggers if there is no 'afterFind' trigger for this class.\n  const hasAfterFindHook = triggers.triggerExists(\n    this.className,\n    triggers.Types.afterFind,\n    this.config.applicationId\n  );\n  if (!hasAfterFindHook) {\n    return Promise.resolve();\n  }\n  // Skip Aggregate and Distinct Queries\n  if (this.findOptions.pipeline || this.findOptions.distinct) {\n    return Promise.resolve();\n  }\n\n  const json = Object.assign({}, this.restOptions);\n  json.where = this.restWhere;\n  const parseQuery = new Parse.Query(this.className);\n  parseQuery.withJSON(json);\n  // Run afterFind trigger and set the new results\n  return triggers\n    .maybeRunAfterFindTrigger(\n      triggers.Types.afterFind,\n      this.auth,\n      this.className,\n      this.response.results,\n      this.config,\n      parseQuery,\n      this.context\n    )\n    .then(results => {\n      // Ensure we properly set the className back\n      if (this.redirectClassName) {\n        this.response.results = results.map(object => {\n          if (object instanceof Parse.Object) {\n            object = object.toJSON();\n          }\n          object.className = this.redirectClassName;\n          return object;\n        });\n      } else {\n        this.response.results = results;\n      }\n    });\n};\n\n// Adds included values to the response.\n// Path is a list of field names.\n// Returns a promise for an augmented response.\nfunction includePath(config, auth, response, path, restOptions = {}) {\n  var pointers = findPointers(response.results, path);\n  if (pointers.length == 0) {\n    return response;\n  }\n  const pointersHash = {};\n  for (var pointer of pointers) {\n    if (!pointer) {\n      continue;\n    }\n    const className = pointer.className;\n    // only include the good pointers\n    if (className) {\n      pointersHash[className] = pointersHash[className] || new Set();\n      pointersHash[className].add(pointer.objectId);\n    }\n  }\n  const includeRestOptions = {};\n  if (restOptions.keys) {\n    const keys = new Set(restOptions.keys.split(','));\n    const keySet = Array.from(keys).reduce((set, key) => {\n      const keyPath = key.split('.');\n      let i = 0;\n      for (i; i < path.length; i++) {\n        if (path[i] != keyPath[i]) {\n          return set;\n        }\n      }\n      if (i < keyPath.length) {\n        set.add(keyPath[i]);\n      }\n      return set;\n    }, new Set());\n    if (keySet.size > 0) {\n      includeRestOptions.keys = Array.from(keySet).join(',');\n    }\n  }\n\n  if (restOptions.excludeKeys) {\n    const excludeKeys = new Set(restOptions.excludeKeys.split(','));\n    const excludeKeySet = Array.from(excludeKeys).reduce((set, key) => {\n      const keyPath = key.split('.');\n      let i = 0;\n      for (i; i < path.length; i++) {\n        if (path[i] != keyPath[i]) {\n          return set;\n        }\n      }\n      if (i == (keyPath.length - 1)) {\n        set.add(keyPath[i]);\n      }\n      return set;\n    }, new Set());\n    if (excludeKeySet.size > 0) {\n      includeRestOptions.excludeKeys = Array.from(excludeKeySet).join(',');\n    }\n  }\n\n  if (restOptions.includeReadPreference) {\n    includeRestOptions.readPreference = restOptions.includeReadPreference;\n    includeRestOptions.includeReadPreference = restOptions.includeReadPreference;\n  } else if (restOptions.readPreference) {\n    includeRestOptions.readPreference = restOptions.readPreference;\n  }\n\n  const queryPromises = Object.keys(pointersHash).map(className => {\n    const objectIds = Array.from(pointersHash[className]);\n    let where;\n    if (objectIds.length === 1) {\n      where = { objectId: objectIds[0] };\n    } else {\n      where = { objectId: { $in: objectIds } };\n    }\n    var query = new RestQuery(config, auth, className, where, includeRestOptions);\n    return query.execute({ op: 'get' }).then(results => {\n      results.className = className;\n      return Promise.resolve(results);\n    });\n  });\n\n  // Get the objects for all these object ids\n  return Promise.all(queryPromises).then(responses => {\n    var replace = responses.reduce((replace, includeResponse) => {\n      for (var obj of includeResponse.results) {\n        obj.__type = 'Object';\n        obj.className = includeResponse.className;\n\n        if (obj.className == '_User' && !auth.isMaster) {\n          delete obj.sessionToken;\n          delete obj.authData;\n        }\n        replace[obj.objectId] = obj;\n      }\n      return replace;\n    }, {});\n\n    var resp = {\n      results: replacePointers(response.results, path, replace),\n    };\n    if (response.count) {\n      resp.count = response.count;\n    }\n    return resp;\n  });\n}\n\n// Object may be a list of REST-format object to find pointers in, or\n// it may be a single object.\n// If the path yields things that aren't pointers, this throws an error.\n// Path is a list of fields to search into.\n// Returns a list of pointers in REST format.\nfunction findPointers(object, path) {\n  if (object instanceof Array) {\n    var answer = [];\n    for (var x of object) {\n      answer = answer.concat(findPointers(x, path));\n    }\n    return answer;\n  }\n\n  if (typeof object !== 'object' || !object) {\n    return [];\n  }\n\n  if (path.length == 0) {\n    if (object === null || object.__type == 'Pointer') {\n      return [object];\n    }\n    return [];\n  }\n\n  var subobject = object[path[0]];\n  if (!subobject) {\n    return [];\n  }\n  return findPointers(subobject, path.slice(1));\n}\n\n// Object may be a list of REST-format objects to replace pointers\n// in, or it may be a single object.\n// Path is a list of fields to search into.\n// replace is a map from object id -> object.\n// Returns something analogous to object, but with the appropriate\n// pointers inflated.\nfunction replacePointers(object, path, replace) {\n  if (object instanceof Array) {\n    return object\n      .map(obj => replacePointers(obj, path, replace))\n      .filter(obj => typeof obj !== 'undefined');\n  }\n\n  if (typeof object !== 'object' || !object) {\n    return object;\n  }\n\n  if (path.length === 0) {\n    if (object && object.__type === 'Pointer') {\n      return replace[object.objectId];\n    }\n    return object;\n  }\n\n  var subobject = object[path[0]];\n  if (!subobject) {\n    return object;\n  }\n  var newsub = replacePointers(subobject, path.slice(1), replace);\n  var answer = {};\n  for (var key in object) {\n    if (key == path[0]) {\n      answer[key] = newsub;\n    } else {\n      answer[key] = object[key];\n    }\n  }\n  return answer;\n}\n\n// Finds a subobject that has the given key, if there is one.\n// Returns undefined otherwise.\nfunction findObjectWithKey(root, key) {\n  if (typeof root !== 'object') {\n    return;\n  }\n  if (root instanceof Array) {\n    for (var item of root) {\n      const answer = findObjectWithKey(item, key);\n      if (answer) {\n        return answer;\n      }\n    }\n  }\n  if (root && root[key]) {\n    return root;\n  }\n  for (var subkey in root) {\n    const answer = findObjectWithKey(root[subkey], key);\n    if (answer) {\n      return answer;\n    }\n  }\n}\n\nmodule.exports = RestQuery;\n"], "fixing_code": ["# Parse Server Changelog\n\nJump directly to a version:\n\n| 4.x                                  |\n|--------------------------------------|\n| [**4.10.3 (latest release)**](#4103) |\n| [4.10.2](#4102)                      |\n| [4.10.1](#4101)                      |\n| [4.10.0](#4100)                      |\n| [4.5.2](#452)                        |\n| [4.5.1](#451)                        |\n| [4.5.0](#450)                        |\n| [4.4.0](#440)                        |\n| [4.3.0](#430)                        |\n| [4.2.0](#420)                        |\n| [4.1.0](#410)                        |\n| [4.0.2](#402)                        |\n| [4.0.1](#401)                        |\n| [4.0.0](#400)                        |\n\n<details>\n<summary>Previous Versions</summary>\n\n| 3.x             | 2.x             |\n|-----------------|-----------------|\n| [3.10.0](#3100) | [2.8.4](#284)   |\n| [3.9.0](#390)   | [2.8.3](#283)   |\n| [3.8.0](#380)   | [2.8.2](#282)   |\n| [3.7.2](#372)   | [2.8.1](#281)   |\n| [3.7.1](#371)   | [2.8.0](#280)   |\n| [3.7.0](#370)   | [2.7.4](#274)   |\n| [3.6.0](#360)   | [2.7.3](#273)   |\n| [3.5.0](#350)   | [2.7.2](#272)   |\n| [3.4.4](#344)   | [2.7.1](#271)   |\n| [3.4.3](#343)   | [2.7.0](#270)   |\n| [3.4.2](#342)   | [2.6.5](#265)   |\n| [3.4.1](#341)   | [2.6.4](#264)   |\n| [3.4.0](#340)   | [2.6.3](#263)   |\n| [3.3.0](#330)   | [2.6.2](#262)   |\n| [3.2.3](#323)   | [2.6.1](#261)   |\n| [3.2.2](#322)   | [2.6.0](#260)   |\n| [3.2.1](#321)   | [2.5.3](#253)   |\n| [3.2.0](#320)   | [2.5.2](#252)   |\n| [3.1.3](#313)   | [2.5.1](#251)   |\n| [3.1.2](#312)   | [2.5.0](#250)   |\n| [3.1.1](#311)   | [2.4.2](#242)   |\n| [3.1.0](#310)   | [2.4.1](#241)   |\n| [3.0.0](#300)   | [2.4.0](#240)   |\n|                 | [2.3.8](#238)   |\n|                 | [2.3.7](#237)   |\n|                 | [2.3.6](#236)   |\n|                 | [2.3.5](#235)   |\n|                 | [2.3.3](#233)   |\n|                 | [2.3.2](#232)   |\n|                 | [2.3.1](#231)   |\n|                 | [2.3.0](#230)   |\n|                 | [2.2.25](#2225) |\n|                 | [2.2.24](#2224) |\n|                 | [2.2.23](#2223) |\n|                 | [2.2.22](#2222) |\n|                 | [2.2.21](#2221) |\n|                 | [2.2.20](#2220) |\n|                 | [2.2.19](#2219) |\n|                 | [2.2.18](#2218) |\n|                 | [2.2.17](#2217) |\n|                 | [2.2.16](#2216) |\n|                 | [2.2.15](#2215) |\n|                 | [2.2.14](#2214) |\n|                 | [2.2.13](#2213) |\n|                 | [2.2.12](#2212) |\n|                 | [2.2.11](#2211) |\n|                 | [2.2.10](#2210) |\n|                 | [2.2.9](#229)   |\n|                 | [2.2.8](#228)   |\n|                 | [2.2.7](#227)   |\n|                 | [2.2.6](#226)   |\n|                 | [2.2.5](#225)   |\n|                 | [2.2.4](#224)   |\n|                 | [2.2.3](#223)   |\n|                 | [2.2.2](#222)   |\n|                 | [2.2.1](#221)   |\n|                 | [2.2.0](#220)   |\n|                 | [2.1.6](#216)   |\n|                 | [2.1.5](#215)   |\n|                 | [2.1.4](#214)   |\n|                 | [2.1.3](#213)   |\n|                 | [2.1.2](#212)   |\n|                 | [2.1.1](#211)   |\n|                 | [2.1.0](#210)   |\n|                 | [2.0.8](#208)   |\n</details>\n\n___\n\n## Unreleased (Master Branch)\n[Full Changelog](https://github.com/parse-community/parse-server/compare/4.10.3...master)\n\n### Breaking Changes\n- Improved schema caching through database real-time hooks. Reduces DB queries, decreases Parse Query execution time and fixes a potential schema memory leak. If multiple Parse Server instances connect to the same DB (for example behind a load balancer), set the [Parse Server Option](https://parseplatform.org/parse-server/api/master/ParseServerOptions.html) `databaseOptions.enableSchemaHooks: true` to enable this feature and keep the schema in sync across all instances. Failing to do so will cause a schema change to not propagate to other instances and re-syncing will only happen when these instances restart. The options `enableSingleSchemaCache` and `schemaCacheTTL` have been removed. To use this feature with MongoDB, a replica set cluster with [change stream](https://docs.mongodb.com/manual/changeStreams/#availability) support is required. (Diamond Lewis, SebC) [#7214](https://github.com/parse-community/parse-server/issues/7214)\n- Added file upload restriction. File upload is now only allowed for authenticated users by default for improved security. To allow file upload also for Anonymous Users or Public, set the `fileUpload` parameter in the [Parse Server Options](https://parseplatform.org/parse-server/api/master/ParseServerOptions.html) (dblythy, Manuel Trezza) [#7071](https://github.com/parse-community/parse-server/pull/7071)\n- Removed [parse-server-simple-mailgun-adapter](https://github.com/parse-community/parse-server-simple-mailgun-adapter) dependency; to continue using the adapter it has to be explicitly installed (Manuel Trezza) [#7321](https://github.com/parse-community/parse-server/pull/7321)\n- Remove support for MongoDB 3.6 which has reached its End-of-Life date and PostgreSQL 10 (Manuel Trezza) [#7315](https://github.com/parse-community/parse-server/pull/7315)\n- Remove support for Node 10 which has reached its End-of-Life date (Manuel Trezza) [#7314](https://github.com/parse-community/parse-server/pull/7314)\n- Remove S3 Files Adapter from Parse Server, instead install separately as `@parse/s3-files-adapter` (Manuel Trezza) [#7324](https://github.com/parse-community/parse-server/pull/7324)\n\n### Notable Changes\n- Added Parse Server Security Check to report weak security settings (Manuel Trezza, dblythy) [#7247](https://github.com/parse-community/parse-server/issues/7247)\n- EXPERIMENTAL: Added new page router with placeholder rendering and localization of custom and feature pages such as password reset and email verification (Manuel Trezza) [#7128](https://github.com/parse-community/parse-server/pull/7128)\n- EXPERIMENTAL: Added custom routes to easily customize flows for password reset, email verification or build entirely new flows (Manuel Trezza) [#7231](https://github.com/parse-community/parse-server/pull/7231)\n- Added Deprecation Policy to govern the introduction of breaking changes in a phased pattern that is more predictable for developers (Manuel Trezza) [#7199](https://github.com/parse-community/parse-server/pull/7199)\n- Add REST API endpoint `/loginAs` to create session of any user with master key; allows to impersonate another user. (GormanFletcher) [#7406](https://github.com/parse-community/parse-server/pull/7406)\n- Add official support for MongoDB 5.0 (Manuel Trezza) [#7469](https://github.com/parse-community/parse-server/pull/7469)\n- Add issue bot (Manuel Trezza) [#7523](https://github.com/parse-community/parse-server/pull/7523)\n\n### Other Changes\n- Support native mongodb syntax in aggregation pipelines (Raschid JF Rafeally) [#7339](https://github.com/parse-community/parse-server/pull/7339)\n- Fix error when a not yet inserted job is updated (Antonio Davi Macedo Coelho de Castro) [#7196](https://github.com/parse-community/parse-server/pull/7196)\n- request.context for afterFind triggers (dblythy) [#7078](https://github.com/parse-community/parse-server/pull/7078)\n- Winston Logger interpolating stdout to console (dplewis) [#7114](https://github.com/parse-community/parse-server/pull/7114)\n- Added convenience method `Parse.Cloud.sendEmail(...)` to send email via email adapter in Cloud Code (dblythy) [#7089](https://github.com/parse-community/parse-server/pull/7089)\n- LiveQuery support for $and, $nor, $containedBy, $geoWithin, $geoIntersects queries (dplewis) [#7113](https://github.com/parse-community/parse-server/pull/7113)\n- Supporting patterns in LiveQuery server's config parameter `classNames` (Nes-si) [#7131](https://github.com/parse-community/parse-server/pull/7131)\n- Added `requireAnyUserRoles` and `requireAllUserRoles` for Parse Cloud validator (dblythy) [#7097](https://github.com/parse-community/parse-server/pull/7097)\n- Support Facebook Limited Login (miguel-s) [#7219](https://github.com/parse-community/parse-server/pull/7219)\n- Removed Stage name check on aggregate pipelines (BRETT71) [#7237](https://github.com/parse-community/parse-server/pull/7237)\n- Retry transactions on MongoDB when it fails due to transient error (Antonio Davi Macedo Coelho de Castro) [#7187](https://github.com/parse-community/parse-server/pull/7187)\n- Bump tests to use Mongo 4.4.4 (Antonio Davi Macedo Coelho de Castro) [#7184](https://github.com/parse-community/parse-server/pull/7184)\n- Added new account lockout policy option `accountLockout.unlockOnPasswordReset` to automatically unlock account on password reset (Manuel Trezza) [#7146](https://github.com/parse-community/parse-server/pull/7146)\n- Test Parse Server continuously against all recent MongoDB versions that have not reached their end-of-life support date, added MongoDB compatibility table to Parse Server docs (Manuel Trezza) [#7161](https://github.com/parse-community/parse-server/pull/7161)\n- Test Parse Server continuously against all recent Node.js versions that have not reached their end-of-life support date, added Node.js compatibility table to Parse Server docs (Manuel Trezza) [7161](https://github.com/parse-community/parse-server/pull/7177)\n- Throw error on invalid Cloud Function validation configuration (dblythy) [#7154](https://github.com/parse-community/parse-server/pull/7154)\n- Allow Cloud Validator `options` to be async (dblythy) [#7155](https://github.com/parse-community/parse-server/pull/7155)\n- Optimize queries on classes with pointer permissions (Pedro Diaz) [#7061](https://github.com/parse-community/parse-server/pull/7061)\n- Test Parse Server continuously against all relevant Postgres versions (minor versions), added Postgres compatibility table to Parse Server docs (Corey Baker) [#7176](https://github.com/parse-community/parse-server/pull/7176)\n- Randomize test suite (Diamond Lewis) [#7265](https://github.com/parse-community/parse-server/pull/7265)\n- LDAP: Properly unbind client on group search error (Diamond Lewis) [#7265](https://github.com/parse-community/parse-server/pull/7265)\n- Improve data consistency in Push and Job Status update (Diamond Lewis) [#7267](https://github.com/parse-community/parse-server/pull/7267)\n- Excluding keys that have trailing edges.node when performing GraphQL resolver (Chris Bland) [#7273](https://github.com/parse-community/parse-server/pull/7273)\n- Added centralized feature deprecation with standardized warning logs (Manuel Trezza) [#7303](https://github.com/parse-community/parse-server/pull/7303)\n- Use Node.js 15.13.0 in CI (Olle Jonsson) [#7312](https://github.com/parse-community/parse-server/pull/7312)\n- Fix file upload issue for S3 compatible storage (Linode, DigitalOcean) by avoiding empty tags property when creating a file (Ali Oguzhan Yildiz) [#7300](https://github.com/parse-community/parse-server/pull/7300)\n- Add building Docker image as CI check (Manuel Trezza) [#7332](https://github.com/parse-community/parse-server/pull/7332)\n- Add NPM package-lock version check to CI (Manuel Trezza) [#7333](https://github.com/parse-community/parse-server/pull/7333)\n- Fix incorrect LiveQuery events triggered for multiple subscriptions on the same class with different events [#7341](https://github.com/parse-community/parse-server/pull/7341)\n- Fix select and excludeKey queries to properly accept JSON string arrays. Also allow nested fields in exclude (Corey Baker) [#7242](https://github.com/parse-community/parse-server/pull/7242)\n- Fix LiveQuery server crash when using $all query operator on a missing object key (Jason Posthuma) [#7421](https://github.com/parse-community/parse-server/pull/7421)\n- Added runtime deprecation warnings (Manuel Trezza) [#7451](https://github.com/parse-community/parse-server/pull/7451)\n- Add ability to pass context of an object via a header, X-Parse-Cloud-Context, for Cloud Code triggers. The header addition allows client SDK's to add context without injecting _context in the body of JSON objects (Corey Baker) [#7437](https://github.com/parse-community/parse-server/pull/7437)\n- Add CI check to add changelog entry (Manuel Trezza) [#7512](https://github.com/parse-community/parse-server/pull/7512)\n- Refactor: uniform issue templates across repos (Manuel Trezza) [#7528](https://github.com/parse-community/parse-server/pull/7528)\n\n## 4.10.3\n[Full Changelog](https://github.com/parse-community/parse-server/compare/4.10.2...4.10.3)\n\n### Security Fixes\n- Validate `explain` query parameter to avoid a server crash due to MongoDB bug [NODE-3463](https://jira.mongodb.org/browse/NODE-3463) (Kartal Kaan Bozdogan) [GHSA-xqp8-w826-hh6x](https://github.com/parse-community/parse-server/security/advisories/GHSA-xqp8-w826-hh6x)\n\n## 4.10.2\n[Full Changelog](https://github.com/parse-community/parse-server/compare/4.10.1...4.10.2)\n\n### Other Changes\n- Move graphql-tag from devDependencies to dependencies (Antonio Davi Macedo Coelho de Castro) [#7183](https://github.com/parse-community/parse-server/pull/7183)\n\n## 4.10.1\n[Full Changelog](https://github.com/parse-community/parse-server/compare/4.10.0...4.10.1)\n\n### Security Fixes\n- Updated to Parse JS SDK 3.3.0 and other security fixes (Manuel Trezza) [#7508](https://github.com/parse-community/parse-server/pull/7508)\n\n> \u26a0\ufe0f This includes a security fix of the Parse JS SDK where `logIn` will default to `POST` instead of `GET` method. This may require changes in your deployment before you upgrade to this release, see the Parse JS SDK 3.0.0 [release notes](https://github.com/parse-community/Parse-SDK-JS/releases/tag/3.0.0).\n\n## 4.10.0\n[Full Changelog](https://github.com/parse-community/parse-server/compare/4.5.2...4.10.0)\n\n*Versions >4.5.2 and <4.10.0 are skipped.*\n\n> \u26a0\ufe0f A security incident caused a number of incorrect version tags to be pushed to the Parse Server repository. These version tags linked to a personal fork of a contributor who had write access to the repository. The code to which these tags linked has not been reviewed or approved by Parse Platform. Even though no releases were published with these incorrect versions, it was possible to define a Parse Server dependency that pointed to these version tags, for example if you defined this dependency: \n> ```js\n> \"parse-server\": \"git@github.com:parse-community/parse-server.git#4.9.3\"\n> ```\n> \n> We have since deleted the incorrect version tags, but they may still show up if your personal fork on GitHub or locally. We do not know when these tags have been pushed to the Parse Server repository, but we first became aware of this issue on July 21, 2021. We are not aware of any malicious code or concerns related to privacy, security or legality (e.g. proprietary code). However, it has been reported that some functionality does not work as expected and the introduction of security vulnerabilities cannot be ruled out.\n>\n> You may be also affected if you used the Bitnami image for Parse Server. Bitnami picked up the incorrect version tag `4.9.3` and published a new Bitnami image for Parse Server. \n> \n>**If you are using any of the affected versions, we urgently recommend to upgrade to version `4.10.0`.**\n\n## 4.5.2\n[Full Changelog](https://github.com/parse-community/parse-server/compare/4.5.0...4.5.2)\n\n### Security Fixes\n- SECURITY FIX: Fixes incorrect session property `authProvider: password` of anonymous users. When signing up an anonymous user, the session field `createdWith` indicates incorrectly that the session has been created using username and password with `authProvider: password`, instead of an anonymous sign-up with `authProvider: anonymous`. This fixes the issue by setting the correct `authProvider: anonymous` for future sign-ups of anonymous users. This fix does not fix incorrect `authProvider: password` for existing sessions of anonymous users. Consider this if your app logic depends on the `authProvider` field. (Corey Baker) [GHSA-23r4-5mxp-c7g5](https://github.com/parse-community/parse-server/security/advisories/GHSA-23r4-5mxp-c7g5)\n\n## 4.5.1\n*This version was published by mistake and was deprecated.*\n\n## 4.5.0\n[Full Changelog](https://github.com/parse-community/parse-server/compare/4.4.0...4.5.0)\n### Breaking Changes\n- FIX: Consistent casing for afterLiveQueryEvent. The afterLiveQueryEvent was introduced in 4.4.0 with inconsistent casing for the event names, which was fixed in 4.5.0. [#7023](https://github.com/parse-community/parse-server/pull/7023). Thanks to [dblythy](https://github.com/dblythy).\n### Other Changes\n- FIX: Properly handle serverURL and publicServerUrl in Batch requests. [#7049](https://github.com/parse-community/parse-server/pull/7049). Thanks to [Zach Goldberg](https://github.com/ZachGoldberg).\n- IMPROVE: Prevent invalid column names (className and length). [#7053](https://github.com/parse-community/parse-server/pull/7053). Thanks to [Diamond Lewis](https://github.com/dplewis).\n- IMPROVE: GraphQL: Remove viewer from logout mutation. [#7029](https://github.com/parse-community/parse-server/pull/7029). Thanks to [Antoine Cormouls](https://github.com/Moumouls).\n- IMPROVE: GraphQL: Optimize on Relation. [#7044](https://github.com/parse-community/parse-server/pull/7044). Thanks to [Antoine Cormouls](https://github.com/Moumouls).\n- NEW: Include sessionToken in onLiveQueryEvent. [#7043](https://github.com/parse-community/parse-server/pull/7043). Thanks to [dblythy](https://github.com/dblythy).\n- FIX: Definitions for accountLockout and passwordPolicy. [#7040](https://github.com/parse-community/parse-server/pull/7040). Thanks to [dblythy](https://github.com/dblythy).\n- FIX: Fix typo in server definitions for emailVerifyTokenReuseIfValid. [#7037](https://github.com/parse-community/parse-server/pull/7037). Thanks to [dblythy](https://github.com/dblythy).\n- SECURITY FIX: LDAP auth stores password in plain text. See [GHSA-4w46-w44m-3jq3](https://github.com/parse-community/parse-server/security/advisories/GHSA-4w46-w44m-3jq3) for more details about the vulnerability and [da905a3](https://github.com/parse-community/parse-server/commit/da905a357d062ab4fea727a21eac231acc2ed92a) for the fix. Thanks to [Fabian Strachanski](https://github.com/fastrde).\n- NEW: Reuse tokens if they haven't expired. [#7017](https://github.com/parse-community/parse-server/pull/7017). Thanks to [dblythy](https://github.com/dblythy).\n- NEW: Add LDAPS-support to LDAP-Authcontroller. [#7014](https://github.com/parse-community/parse-server/pull/7014). Thanks to [Fabian Strachanski](https://github.com/fastrde).\n- FIX: (beforeSave/afterSave): Return value instead of Parse.Op for nested fields. [#7005](https://github.com/parse-community/parse-server/pull/7005). Thanks to [Diamond Lewis](https://github.com/dplewis).\n- FIX: (beforeSave): Skip Sanitizing Database results. [#7003](https://github.com/parse-community/parse-server/pull/7003). Thanks to [Diamond Lewis](https://github.com/dplewis).\n- FIX: Fix includeAll for querying a Pointer and Pointer array. [#7002](https://github.com/parse-community/parse-server/pull/7002). Thanks to [Corey Baker](https://github.com/cbaker6).\n- FIX: Add encryptionKey to src/options/index.js. [#6999](https://github.com/parse-community/parse-server/pull/6999). Thanks to [dblythy](https://github.com/dblythy).\n- IMPROVE: Update PostgresStorageAdapter.js. [#6989](https://github.com/parse-community/parse-server/pull/6989). Thanks to [Vitaly Tomilov](https://github.com/vitaly-t).\n\n## 4.4.0\n[Full Changelog](https://github.com/parse-community/parse-server/compare/4.3.0...4.4.0)\n- IMPROVE: Update PostgresStorageAdapter.js. [#6981](https://github.com/parse-community/parse-server/pull/6981). Thanks to [Vitaly Tomilov](https://github.com/vitaly-t)\n- NEW: skipWithMasterKey on Built-In Validator. [#6972](https://github.com/parse-community/parse-server/issues/6972). Thanks to [dblythy](https://github.com/dblythy).\n- NEW: Add fileKey rotation to GridFSBucketAdapter. [#6768](https://github.com/parse-community/parse-server/pull/6768). Thanks to [Corey Baker](https://github.com/cbaker6).\n- IMPROVE: Remove unused parameter in Cloud Function. [#6969](https://github.com/parse-community/parse-server/issues/6969). Thanks to [Diamond Lewis](https://github.com/dplewis).\n- IMPROVE: Validation Handler Update. [#6968](https://github.com/parse-community/parse-server/issues/6968). Thanks to [dblythy](https://github.com/dblythy).\n- FIX: (directAccess): Properly handle response status. [#6966](https://github.com/parse-community/parse-server/issues/6966). Thanks to [Diamond Lewis](https://github.com/dplewis).\n- FIX: Remove hostnameMaxLen for Mongo URL. [#6693](https://github.com/parse-community/parse-server/issues/6693). Thanks to [markhoward02](https://github.com/markhoward02).\n- IMPROVE: Show a message if cloud functions are duplicated. [#6963](https://github.com/parse-community/parse-server/issues/6963). Thanks to [dblythy](https://github.com/dblythy).\n- FIX: Pass request.query to afterFind. [#6960](https://github.com/parse-community/parse-server/issues/6960). Thanks to [dblythy](https://github.com/dblythy).\n- SECURITY FIX: Patch session vulnerability over Live Query. See [GHSA-2xm2-xj2q-qgpj](https://github.com/parse-community/parse-server/security/advisories/GHSA-2xm2-xj2q-qgpj) for more details about the vulnerability and [78b59fb](https://github.com/parse-community/parse-server/commit/78b59fb26b1c36e3cdbd42ba9fec025003267f58) for the fix. Thanks to [Antonio Davi Macedo Coelho de Castro](https://github.com/davimacedo).\n- IMPROVE: LiveQueryEvent Error Logging Improvements. [#6951](https://github.com/parse-community/parse-server/issues/6951). Thanks to [dblythy](https://github.com/dblythy).\n- IMPROVE: Include stack in Cloud Code. [#6958](https://github.com/parse-community/parse-server/issues/6958). Thanks to [dblythy](https://github.com/dblythy).\n- FIX: (jobs): Add Error Message to JobStatus Failure. [#6954](https://github.com/parse-community/parse-server/issues/6954). Thanks to [Diamond Lewis](https://github.com/dplewis).\n- NEW: Create Cloud function afterLiveQueryEvent. [#6859](https://github.com/parse-community/parse-server/issues/6859). Thanks to [dblythy](https://github.com/dblythy).\n- FIX: Update vkontakte API to the latest version. [#6944](https://github.com/parse-community/parse-server/issues/6944). Thanks to [Antonio Davi Macedo Coelho de Castro](https://github.com/davimacedo).\n- FIX: Use an empty object as default value of options for Google Sign in. [#6844](https://github.com/parse-community/parse-server/issues/6844). Thanks to [Kevin Kuang](https://github.com/kvnkuang).\n- FIX: Postgres: prepend className to unique indexes. [#6741](https://github.com/parse-community/parse-server/pull/6741). Thanks to [Corey Baker](https://github.com/cbaker6).\n- FIX: GraphQL: Transform input types also on user mutations. [#6934](https://github.com/parse-community/parse-server/pull/6934). Thanks to [Antoine Cormouls](https://github.com/Moumouls).\n- FIX: Set objectId into query for Email Validation. [#6930](https://github.com/parse-community/parse-server/pull/6930). Thanks to [Danaru](https://github.com/Danaru87).\n- FIX: GraphQL: Optimize queries, fixes some null returns (on object), fix stitched GraphQLUpload. [#6709](https://github.com/parse-community/parse-server/pull/6709). Thanks to [Antoine Cormouls](https://github.com/Moumouls).\n- FIX: Do not throw error if user provide a pointer like index onMongo. [#6923](https://github.com/parse-community/parse-server/pull/6923). Thanks to [Antoine Cormouls](https://github.com/Moumouls).\n- FIX: Hotfix instagram api. [#6922](https://github.com/parse-community/parse-server/issues/6922). Thanks to [Tim](https://github.com/timination).\n- FIX: (directAccess/cloud-code): Pass installationId with LogIn. [#6903](https://github.com/parse-community/parse-server/issues/6903). Thanks to [Diamond Lewis](https://github.com/dplewis).\n- FIX: Fix bcrypt binary incompatibility. [#6891](https://github.com/parse-community/parse-server/issues/6891). Thanks to [Manuel Trezza](https://github.com/mtrezza).\n- NEW: Keycloak auth adapter. [#6376](https://github.com/parse-community/parse-server/issues/6376). Thanks to [Rhuan](https://github.com/rhuanbarreto).\n- IMPROVE: Changed incorrect key name in apple auth adapter tests. [#6861](https://github.com/parse-community/parse-server/issues/6861). Thanks to [Manuel Trezza](https://github.com/mtrezza).\n- FIX: Fix mutating beforeSubscribe Query. [#6868](https://github.com/parse-community/parse-server/issues/6868). Thanks to [dblythy](https://github.com/dblythy).\n- FIX: Fix beforeLogin for users logging in with AuthData. [#6872](https://github.com/parse-community/parse-server/issues/6872). Thanks to [Kevin Kuang](https://github.com/kvnkuang).\n- FIX: Remove Facebook AccountKit auth. [#6870](https://github.com/parse-community/parse-server/issues/6870). Thanks to [Diamond Lewis](https://github.com/dplewis).\n- FIX: Updated TOKEN_ISSUER to 'accounts.google.com'. [#6836](https://github.com/parse-community/parse-server/issues/6836). Thanks to [Arjun Vedak](https://github.com/arjun3396).\n- IMPROVE: Optimized deletion of class field from schema by using an index if available to do an index scan instead of a collection scan. [#6815](https://github.com/parse-community/parse-server/issues/6815). Thanks to [Manuel Trezza](https://github.com/mtrezza).\n- IMPROVE: Enable MongoDB transaction test for MongoDB >= 4.0.4 [#6827](https://github.com/parse-community/parse-server/pull/6827). Thanks to [Manuel](https://github.com/mtrezza).\n\n## 4.3.0\n[Full Changelog](https://github.com/parse-community/parse-server/compare/4.2.0...4.3.0)\n- PERFORMANCE: Optimizing pointer CLP query decoration done by DatabaseController#addPointerPermissions [#6747](https://github.com/parse-community/parse-server/pull/6747). Thanks to [mess-lelouch](https://github.com/mess-lelouch).\n- SECURITY: Fix security breach on GraphQL viewer [78239ac](https://github.com/parse-community/parse-server/commit/78239ac9071167fdf243c55ae4bc9a2c0b0d89aa), [security advisory](https://github.com/parse-community/parse-server/security/advisories/GHSA-236h-rqv8-8q73). Thanks to [Antoine Cormouls](https://github.com/Moumouls).\n- FIX: Save context not present if direct access enabled [#6764](https://github.com/parse-community/parse-server/pull/6764). Thanks to [Omair Vaiyani](https://github.com/omairvaiyani).\n- NEW: Before Connect + Before Subscribe [#6793](https://github.com/parse-community/parse-server/pull/6793). Thanks to [dblythy](https://github.com/dblythy).\n- FIX: Add version to playground to fix CDN [#6804](https://github.com/parse-community/parse-server/pull/6804). Thanks to [Antoine Cormouls](https://github.com/Moumouls).\n- NEW (EXPERIMENTAL): Idempotency enforcement for client requests. This deduplicates requests where the client intends to send one request to Parse Server but due to network issues the server receives the request multiple times. **Caution, this is an experimental feature that may not be appropriate for production.** [#6748](https://github.com/parse-community/parse-server/issues/6748). Thanks to [Manuel Trezza](https://github.com/mtrezza).\n- FIX: Add production Google Auth Adapter instead of using the development url [#6734](https://github.com/parse-community/parse-server/pull/6734). Thanks to [SebC.](https://github.com/SebC99).\n- IMPROVE: Run Prettier JS Again Without requiring () on arrow functions [#6796](https://github.com/parse-community/parse-server/pull/6796). Thanks to [Diamond Lewis](https://github.com/dplewis).\n- IMPROVE: Run Prettier JS [#6795](https://github.com/parse-community/parse-server/pull/6795). Thanks to [Diamond Lewis](https://github.com/dplewis).\n- IMPROVE: Replace bcrypt with @node-rs/bcrypt [#6794](https://github.com/parse-community/parse-server/pull/6794). Thanks to [LongYinan](https://github.com/Brooooooklyn).\n- IMPROVE: Make clear description of anonymous user [#6655](https://github.com/parse-community/parse-server/pull/6655). Thanks to [Jerome De Leon](https://github.com/JeromeDeLeon).\n- IMPROVE: Simplify GraphQL merge system to avoid js ref bugs [#6791](https://github.com/parse-community/parse-server/pull/6791). Thanks to [Antoine Cormouls](https://github.com/Moumouls).\n- NEW: Pass context in beforeDelete, afterDelete, beforeFind and Parse.Cloud.run [#6666](https://github.com/parse-community/parse-server/pull/6666). Thanks to [yog27ray](https://github.com/yog27ray).\n- NEW: Allow passing custom gql schema function to ParseServer#start options [#6762](https://github.com/parse-community/parse-server/pull/6762). Thanks to [Luca](https://github.com/lucatk).\n- NEW: Allow custom cors origin header [#6772](https://github.com/parse-community/parse-server/pull/6772). Thanks to [Kevin Yao](https://github.com/kzmeyao).\n- FIX: Fix context for cascade-saving and saving existing object [#6735](https://github.com/parse-community/parse-server/pull/6735). Thanks to [Manuel](https://github.com/mtrezza).\n- NEW: Add file bucket encryption using fileKey [#6765](https://github.com/parse-community/parse-server/pull/6765). Thanks to [Corey Baker](https://github.com/cbaker6).\n- FIX: Removed gaze from dev dependencies and removed not working dev script [#6745](https://github.com/parse-community/parse-server/pull/6745). Thanks to [Vincent Semrau](https://github.com/vince1995).\n- IMPROVE: Upgrade graphql-tools to v6 [#6701](https://github.com/parse-community/parse-server/pull/6701). Thanks to [Yaacov Rydzinski](https://github.com/yaacovCR).\n- NEW: Support Metadata in GridFSAdapter [#6660](https://github.com/parse-community/parse-server/pull/6660). Thanks to [Diamond Lewis](https://github.com/dplewis).\n- NEW: Allow to unset file from graphql [#6651](https://github.com/parse-community/parse-server/pull/6651). Thanks to [Antoine Cormouls](https://github.com/Moumouls).\n- NEW: Handle shutdown for RedisCacheAdapter [#6658](https://github.com/parse-community/parse-server/pull/6658). Thanks to [promisenxu](https://github.com/promisenxu).\n- FIX: Fix explain on user class [#6650](https://github.com/parse-community/parse-server/pull/6650). Thanks to [Manuel](https://github.com/mtrezza).\n- FIX: Fix read preference for aggregate [#6585](https://github.com/parse-community/parse-server/pull/6585). Thanks to [Manuel](https://github.com/mtrezza).\n- NEW: Add context to Parse.Object.save [#6626](https://github.com/parse-community/parse-server/pull/6626). Thanks to [Manuel](https://github.com/mtrezza).\n- NEW: Adding ssl config params to Postgres URI [#6580](https://github.com/parse-community/parse-server/pull/6580). Thanks to [Corey Baker](https://github.com/cbaker6).\n- FIX: Travis postgres update: removing unnecessary start of mongo-runner [#6594](https://github.com/parse-community/parse-server/pull/6594). Thanks to [Corey Baker](https://github.com/cbaker6).\n- FIX: ObjectId size for Pointer in Postgres [#6619](https://github.com/parse-community/parse-server/pull/6619). Thanks to [Corey Baker](https://github.com/cbaker6).\n- IMPROVE: Improve a test case [#6629](https://github.com/parse-community/parse-server/pull/6629). Thanks to [Gordon Sun](https://github.com/sunshineo).\n- NEW: Allow to resolve automatically Parse Type fields from Custom Schema [#6562](https://github.com/parse-community/parse-server/pull/6562). Thanks to [Antoine Cormouls](https://github.com/Moumouls).\n- FIX: Remove wrong console log in test [#6627](https://github.com/parse-community/parse-server/pull/6627). Thanks to [Gordon Sun](https://github.com/sunshineo).\n- IMPROVE: Graphql tools v5 [#6611](https://github.com/parse-community/parse-server/pull/6611). Thanks to [Yaacov Rydzinski](https://github.com/yaacovCR).\n- FIX: Catch JSON.parse and return 403 properly [#6589](https://github.com/parse-community/parse-server/pull/6589). Thanks to [Gordon Sun](https://github.com/sunshineo).\n- PERFORMANCE: Allow covering relation queries with minimal index [#6581](https://github.com/parse-community/parse-server/pull/6581). Thanks to [Noah Silas](https://github.com/noahsilas).\n- FIX: Fix Postgres group aggregation [#6522](https://github.com/parse-community/parse-server/pull/6522). Thanks to [Siddharth Ramesh](https://github.com/srameshr).\n- NEW: Allow set user mapped from JWT directly on request [#6411](https://github.com/parse-community/parse-server/pull/6411). Thanks to [Gordon Sun](https://github.com/sunshineo).\n\n## 4.2.0\n[Full Changelog](https://github.com/parse-community/parse-server/compare/4.1.0...4.2.0)\n\n__BREAKING CHANGES:__\n- CHANGE: The Sign-In with Apple authentication adapter parameter `client_id` has been changed to `clientId`. If using the Apple authentication adapter, this change requires to update the Parse Server configuration accordingly. See [#6523](https://github.com/parse-community/parse-server/pull/6523) for details.\n___\n- UPGRADE: Parse JS SDK to 2.12.0 [#6548](https://github.com/parse-community/parse-server/pull/6548)\n- NEW: Support Group aggregation on multiple columns for Postgres [#6483](https://github.com/parse-community/parse-server/pull/6483). Thanks to [Siddharth Ramesh](https://github.com/srameshr).\n- FIX: Improve test reliability by instructing Travis to only install one version of Postgres [#6490](https://github.com/parse-community/parse-server/pull/6490). Thanks to\n[Corey Baker](https://github.com/cbaker6).\n- FIX: Unknown type bug on overloaded types [#6494](https://github.com/parse-community/parse-server/pull/6494). Thanks to [Antoine Cormouls](https://github.com/Moumouls).\n- FIX: Improve reliability of 'SignIn with AppleID' [#6416](https://github.com/parse-community/parse-server/pull/6416). Thanks to [Andy King](https://github.com/andrewking0207).\n- FIX: Improve Travis reliability by separating Postgres & Mongo scripts [#6505](https://github.com/parse-community/parse-server/pull/6505). Thanks to\n[Corey Baker](https://github.com/cbaker6).\n- NEW: Apple SignIn support for multiple IDs [#6523](https://github.com/parse-community/parse-server/pull/6523). Thanks to [UnderratedDev](https://github.com/UnderratedDev).\n- NEW: Add support for new Instagram API [#6398](https://github.com/parse-community/parse-server/pull/6398). Thanks to [Maravilho Singa](https://github.com/maravilhosinga).\n- FIX: Updating Postgres/Postgis Call and Postgis to 3.0 [#6528](https://github.com/parse-community/parse-server/pull/6528). Thanks to\n[Corey Baker](https://github.com/cbaker6).\n- FIX: enableExpressErrorHandler logic [#6423](https://github.com/parse-community/parse-server/pull/6423). Thanks to [Nikolay Andryukhin](https://github.com/hybeats).\n- FIX: Change Order Enum Strategy for GraphQL [#6515](https://github.com/parse-community/parse-server/pull/6515). Thanks to [Antoine Cormouls](https://github.com/Moumouls).\n- FIX: Switch ACL to Relay Global Id for GraphQL [#6495](https://github.com/parse-community/parse-server/pull/6495). Thanks to [Antoine Cormouls](https://github.com/Moumouls).\n- FIX: Handle keys for pointer fields properly for GraphQL [#6499](https://github.com/parse-community/parse-server/pull/6499). Thanks to [Antoine Cormouls](https://github.com/Moumouls).\n- FIX: GraphQL file mutation [#6507](https://github.com/parse-community/parse-server/pull/6507). Thanks to [Antoine Cormouls](https://github.com/Moumouls).\n- FIX: Aggregate geoNear with date query [#6540](https://github.com/parse-community/parse-server/pull/6540). Thanks to [Manuel](https://github.com/mtrezza).\n- NEW: Add file triggers and file meta data [#6344](https://github.com/parse-community/parse-server/pull/6344). Thanks to [stevestencil](https://github.com/stevestencil).\n- FIX: Improve local testing of postgres [#6531](https://github.com/parse-community/parse-server/pull/6531). Thanks to\n[Corey Baker](https://github.com/cbaker6).\n- NEW: Case insensitive username and email indexing and query planning for Postgres [#6506](https://github.com/parse-community/parse-server/issues/6441). Thanks to\n[Corey Baker](https://github.com/cbaker6).\n\n## 4.1.0\n[Full Changelog](https://github.com/parse-community/parse-server/compare/4.0.2...4.1.0)\n\n_SECURITY RELEASE_: see [advisory](https://github.com/parse-community/parse-server/security/advisories/GHSA-h4mf-75hf-67w4) for details\n- SECURITY FIX: Patch Regex vulnerabilities. See [3a3a5ee](https://github.com/parse-community/parse-server/commit/3a3a5eee5ffa48da1352423312cb767de14de269). Special thanks to [W0lfw00d](https://github.com/W0lfw00d) for identifying and [responsibly reporting](https://github.com/parse-community/parse-server/blob/master/SECURITY.md) the vulnerability. Thanks to [Antonio Davi Macedo Coelho de Castro](https://github.com/davimacedo) for the speedy fix.\n\n## 4.0.2\n[Full Changelog](https://github.com/parse-community/parse-server/compare/4.0.1...4.0.2)\n\n__BREAKING CHANGES:__\n1. Remove Support for Mongo 3.2 & 3.4. The new minimum supported version is Mongo 3.6.\n2. Change username and email validation to be case insensitive. This change should be transparent in most use cases. The validation behavior should now behave 'as expected'. See [#5634](https://github.com/parse-community/parse-server/pull/5634) for details.\n\n> __Special Note on Upgrading to Parse Server 4.0.0 and above__\n>\n> In addition to the breaking changes noted above, [#5634](https://github.com/parse-community/parse-server/pull/5634) introduces a two new case insensitive indexes on the `User` collection. Special care should be taken when upgrading to this version to ensure that:\n>\n> 1. The new indexes can be successfully created (see issue [#6465](https://github.com/parse-community/parse-server/issues/6465) for details on a potential issue for your installation).\n>\n> 2. Care is taken ensure that there is adequate compute capacity to create the index in the background while still servicing requests.\n\n- FIX: attempt to get travis to deploy to npmjs again. See [#6475](https://github.com/parse-community/parse-server/pull/6457). Thanks to [Arthur Cinader](https://github.com/acinader).\n\n## 4.0.1\n[Full Changelog](https://github.com/parse-community/parse-server/compare/4.0.0...4.0.1)\n- FIX: correct 'new' travis config to properly deploy.  See [#6452](https://github.com/parse-community/parse-server/pull/6452). Thanks to [Arthur Cinader](https://github.com/acinader).\n- FIX: Better message on not allowed to protect default fields. See [#6439](https://github.com/parse-community/parse-server/pull/6439).Thanks to [Old Grandpa](https://github.com/BufferUnderflower)\n\n## 4.0.0\n[Full Changelog](https://github.com/parse-community/parse-server/compare/3.10.0...4.0.0)\n\n> __Special Note on Upgrading to Parse Server 4.0.0 and above__\n>\n> In addition to the breaking changes noted below, [#5634](https://github.com/parse-community/parse-server/pull/5634) introduces a two new case insensitive indexes on the `User` collection. Special care should be taken when upgrading to this version to ensure that:\n>\n> 1. The new indexes can be successfully created (see issue [#6465](https://github.com/parse-community/parse-server/issues/6465) for details on a potential issue for your installation).\n>\n> 2. Care is taken ensure that there is adequate compute capacity to create the index in the background while still servicing requests.\n\n- NEW: add hint option to Parse.Query [#6322](https://github.com/parse-community/parse-server/pull/6322). Thanks to [Steve Stencil](https://github.com/stevestencil)\n- FIX: CLP objectId size validation fix [#6332](https://github.com/parse-community/parse-server/pull/6332). Thanks to [Old Grandpa](https://github.com/BufferUnderflower)\n- FIX: Add volumes to Docker command [#6356](https://github.com/parse-community/parse-server/pull/6356). Thanks to [Kasra Bigdeli](https://github.com/githubsaturn)\n- NEW: GraphQL 3rd Party LoginWith Support [#6371](https://github.com/parse-community/parse-server/pull/6371). Thanks to [Antoine Cormouls](https://github.com/Moumouls)\n- FIX: GraphQL Geo Queries [#6363](https://github.com/parse-community/parse-server/pull/6363). Thanks to [Antoine Cormouls](https://github.com/Moumouls)\n- NEW: GraphQL Nested File Upload [#6372](https://github.com/parse-community/parse-server/pull/6372). Thanks to [Antoine Cormouls](https://github.com/Moumouls)\n- NEW: Granular CLP pointer permissions [#6352](https://github.com/parse-community/parse-server/pull/6352). Thanks to [Old Grandpa](https://github.com/BufferUnderflower)\n- FIX: Add missing colon for customPages [#6393](https://github.com/parse-community/parse-server/pull/6393). Thanks to [Jerome De Leon](https://github.com/JeromeDeLeon)\n- NEW: `afterLogin` cloud code hook [#6387](https://github.com/parse-community/parse-server/pull/6387). Thanks to [David Corona](https://github.com/davesters)\n- FIX: __BREAKING CHANGE__ Prevent new usernames or emails that clash with existing users' email or username if it only differs by case.  For example, don't allow a new user with the name 'Jane' if we already have a user 'jane'. [#5634](https://github.com/parse-community/parse-server/pull/5634). Thanks to [Arthur Cinader](https://github.com/acinader)\n- FIX: Support Travis CI V2. [#6414](https://github.com/parse-community/parse-server/pull/6414). Thanks to [Diamond Lewis](https://github.com/dplewis)\n- FIX: Prevent crashing on websocket error. [#6418](https://github.com/parse-community/parse-server/pull/6418). Thanks to [Diamond Lewis](https://github.com/dplewis)\n- NEW: Allow protectedFields for Authenticated users and Public. [$6415](https://github.com/parse-community/parse-server/pull/6415). Thanks to [Old Grandpa](https://github.com/BufferUnderflower)\n- FIX: Correct bug in determining GraphQL pointer errors when mutating. [#6413](https://github.com/parse-community/parse-server/pull/6431). Thanks to [Antoine Cormouls](https://github.com/Moumouls)\n- NEW: Allow true GraphQL Schema Customization. [#6360](https://github.com/parse-community/parse-server/pull/6360). Thanks to [Antoine Cormouls](https://github.com/Moumouls)\n- __BREAKING CHANGE__: Remove Support for Mongo version < 3.6 [#6445](https://github.com/parse-community/parse-server/pull/6445). Thanks to [Arthur Cinader](https://github.com/acinader)\n\n## 3.10.0\n[Full Changelog](https://github.com/parse-community/parse-server/compare/3.9.0...3.10.0)\n- FIX: correct and cover ordering queries in GraphQL [#6316](https://github.com/parse-community/parse-server/pull/6316).  Thanks to [Antonio Davi Macedo Coelho de Castro](https://github.com/davimacedo)\n- NEW: GraphQL support for reset password email [#6301](https://github.com/parse-community/parse-server/pull/6301). Thanks to [Antoine Cormouls](https://github.com/Moumouls)\n- FIX: Add default limit to GraphQL fetch [#6304](https://github.com/parse-community/parse-server/pull/6304). Thanks to [Antoine Cormouls](https://github.com/Moumouls)\n- DOCS: use bash syntax highlighting [#6302](https://github.com/parse-community/parse-server/pull/6302). Thanks to [Jerome De Leon](https://github.com/JeromeDeLeon)\n- NEW: Add max log file option [#6296](https://github.com/parse-community/parse-server/pull/6296). Thanks to [Diamond Lewis](https://github.com/dplewis)\n- NEW: support user supplied objectId [#6101](https://github.com/parse-community/parse-server/pull/6101). Thanks to [Ruhan](https://github.com/rhuanbarretos)\n- FIX: Add missing encodeURIComponent on username [#6278](https://github.com/parse-community/parse-server/pull/6278). Thanks to [Christopher Brookes](https://github.com/Klaitos)\n- NEW: update  PostgresStorageAdapter.js to use async/await [#6275](https://github.com/parse-community/parse-server/pull/6275). Thanks to [Vitaly Tomilov](https://github.com/vitaly-t)\n- NEW: Support required fields on output type for GraphQL [#6279](https://github.com/parse-community/parse-server/pull/6279). Thanks to [Antoine Cormouls](https://github.com/Moumouls)\n- NEW: Support required fields for GraphQL [#6271](https://github.com/parse-community/parse-server/pull/6279). Thanks to [Antoine Cormouls](https://github.com/Moumouls)\n- CHANGE: use mongodb 3.3.5 [#6263](https://github.com/parse-community/parse-server/pull/6263). Thanks to [Diamond Lewis](https://github.com/dplewis)\n- NEW: GraphQL: DX Relational Where Query [#6255](https://github.com/parse-community/parse-server/pull/6255). Thanks to [Antoine Cormouls](https://github.com/Moumouls)\n- CHANGE: test against Postgres 11 [#6260](https://github.com/parse-community/parse-server/pull/6260). Thanks to [Diamond Lewis](https://github.com/dplewis)\n- CHANGE: test against Postgres 11 [#6260](https://github.com/parse-community/parse-server/pull/6260). Thanks to [Diamond Lewis](https://github.com/dplewis)\n- NEW: GraphQL alias for mutations in classConfigs [#6258](https://github.com/parse-community/parse-server/pull/6258). Thanks to [Old Grandpa](https://github.com/BufferUnderflower)\n- NEW: GraphQL classConfig query alias [#6257](https://github.com/parse-community/parse-server/pull/6257). Thanks to [Old Grandpa](https://github.com/BufferUnderflower)\n- NEW: Allow validateFilename to return a string or Parse Error [#6246](https://github.com/parse-community/parse-server/pull/6246). Thanks to [Mike Patnode](https://github.com/mpatnode)\n- NEW: Relay Spec [#6089](https://github.com/parse-community/parse-server/pull/6089). Thanks to [Antonio Davi Macedo Coelho de Castro](https://github.com/davimacedo)\n- CHANGE: Set default ACL for GraphQL [#6249](https://github.com/parse-community/parse-server/pull/6249). Thanks to [Antoine Cormouls](https://github.com/Moumouls)\n- NEW: LDAP auth Adapter [#6226](https://github.com/parse-community/parse-server/pull/6226). Thanks to [Julian Dax](https://github.com/brodo)\n- FIX: improve beforeFind to include Query info [#6237](https://github.com/parse-community/parse-server/pull/6237). Thanks to [Diamond Lewis](https://github.com/dplewis)\n- FIX: improve websocket error handling [#6230](https://github.com/parse-community/parse-server/pull/6230). Thanks to [Diamond Lewis](https://github.com/dplewis)\n- NEW: addition of an afterLogout trigger [#6217](https://github.com/parse-community/parse-server/pull/6217). Thanks to [Diamond Lewis](https://github.com/dplewis)\n- FIX: Initialize default logger [#6186](https://github.com/parse-community/parse-server/pull/6186). Thanks to [Diamond Lewis](https://github.com/dplewis)\n- NEW: Add funding link [#6192](https://github.com/parse-community/parse-server/pull/6192 ). Thanks to [Tom Fox](https://github.com/TomWFox)\n- FIX: installationId on LiveQuery connect [#6180](https://github.com/parse-community/parse-server/pull/6180). Thanks to [Diamond Lewis](https://github.com/dplewis)\n- NEW: Add exposing port in docker container [#6165](https://github.com/parse-community/parse-server/pull/6165). Thanks to [Priyash Patil](https://github.com/priyashpatil)\n- NEW: Support Google Play Games Service [#6147](https://github.com/parse-community/parse-server/pull/6147). Thanks to [Diamond Lewis](https://github.com/dplewis)\n- DOC: Throw error when setting authData to null [#6154](https://github.com/parse-community/parse-server/pull/6154). Thanks to [Manuel](https://github.com/mtrezza)\n- CHANGE: Move filename validation out of the Router and into the FilesAdaptor [#6157](https://github.com/parse-community/parse-server/pull/6157). Thanks to [Mike Patnode](https://github.com/mpatnode)\n- NEW: Added warning for special URL sensitive characters for appId [#6159](https://github.com/parse-community/parse-server/pull/6159). Thanks to [Saimoom Safayet Akash](https://github.com/saimoomsafayet)\n- NEW: Support Apple Game Center Auth [#6143](https://github.com/parse-community/parse-server/pull/6143). Thanks to [Diamond Lewis](https://github.com/dplewis)\n- CHANGE: test with Node 12 [#6133](https://github.com/parse-community/parse-server/pull/6133). Thanks to [Arthur Cinader](https://github.com/acinader)\n- FIX: prevent after find from firing when saving objects [#6127](https://github.com/parse-community/parse-server/pull/6127). Thanks to [Diamond Lewis](https://github.com/dplewis)\n- FIX: GraphQL Mutations not returning updated information [6130](https://github.com/parse-community/parse-server/pull/6130). Thanks to [Omair Vaiyani](https://github.com/omairvaiyani)\n- CHANGE: Cleanup Schema cache per request [#6216](https://github.com/parse-community/parse-server/pull/6216). Thanks to [Diamond Lewis](https://github.com/dplewis)\n- DOC: Improve installation instructions [#6120](https://github.com/parse-community/parse-server/pull/6120). Thanks to [Andres Galante](https://github.com/andresgalante)\n- DOC: add code formatting to contributing guidelines [#6119](https://github.com/parse-community/parse-server/pull/6119). Thanks to [Andres Galante](https://github.com/andresgalante)\n- NEW: Add GraphQL ACL Type + Input [#5957](https://github.com/parse-community/parse-server/pull/5957). Thanks to [Antoine Cormouls](https://github.com/Moumouls)\n- CHANGE: replace public key [#6099](https://github.com/parse-community/parse-server/pull/6099). Thanks to [Arthur Cinader](https://github.com/acinader)\n- NEW: Support microsoft authentication in GraphQL [#6051](https://github.com/parse-community/parse-server/pull/6051). Thanks to [Alann Maulana](https://github.com/alann-maulana)\n- NEW: Install parse-server 3.9.0 instead of 2.2 [#6069](https://github.com/parse-community/parse-server/pull/6069). Thanks to [Julian Dax](https://github.com/brodo)\n- NEW: Use #!/bin/bash instead of #!/bin/sh [#6062](https://github.com/parse-community/parse-server/pull/6062). Thanks to [Julian Dax](https://github.com/brodo)\n- DOC: Update GraphQL readme section [#6030](https://github.com/parse-community/parse-server/pull/6030). Thanks to [Antonio Davi Macedo Coelho de Castro](https://github.com/davimacedo)\n\n## 3.9.0\n[Full Changelog](https://github.com/parse-community/parse-server/compare/3.8.0...3.9.0)\n- NEW: Add allowHeaders to Options [#6044](https://github.com/parse-community/parse-server/pull/6044). Thanks to [Omair Vaiyani](https://github.com/omairvaiyani)\n- CHANGE: Introduce ReadOptionsInput to GraphQL API [#6030](https://github.com/parse-community/parse-server/pull/6030). Thanks to [Antonio Davi Macedo Coelho de Castro](https://github.com/davimacedo)\n- NEW: Stream video with GridFSBucketAdapter (implements byte-range requests) [#6028](https://github.com/parse-community/parse-server/pull/6028). Thanks to [Diamond Lewis](https://github.com/dplewis)\n- FIX: Aggregate not matching null values [#6043](https://github.com/parse-community/parse-server/pull/6043). Thanks to [Antonio Davi Macedo Coelho de Castro](https://github.com/davimacedo)\n- CHANGE: Improve callCloudCode mutation to receive a CloudCodeFunction enum instead of a String in the GraphQL API [#6029](https://github.com/parse-community/parse-server/pull/6029). Thanks to [Antonio Davi Macedo Coelho de Castro](https://github.com/davimacedo)\n- TEST: Add more tests to transactions [#6022](https://github.com/parse-community/parse-server/pull/6022). Thanks to [Antonio Davi Macedo Coelho de Castro](https://github.com/davimacedo)\n- CHANGE: Pointer constraint input type as ID in the GraphQL API [#6020](https://github.com/parse-community/parse-server/pull/6020). Thanks to [Douglas Muraoka](https://github.com/douglasmuraoka)\n- CHANGE: Remove underline from operators of the GraphQL API [#6024](https://github.com/parse-community/parse-server/pull/6024). Thanks to [Antonio Davi Macedo Coelho de Castro](https://github.com/davimacedo)\n- FIX: Make method async as expected in usage [#6025](https://github.com/parse-community/parse-server/pull/6025). Thanks to [Omair Vaiyani](https://github.com/omairvaiyani)\n- DOC: Added breaking change note to 3.8 release [#6023](https://github.com/parse-community/parse-server/pull/6023). Thanks to [Manuel](https://github.com/mtrezza)\n- NEW: Added support for line auth [#6007](https://github.com/parse-community/parse-server/pull/6007). Thanks to [Saimoom Safayet Akash](https://github.com/saimoomsafayet)\n- FIX: Fix aggregate group id [#5994](https://github.com/parse-community/parse-server/pull/5994). Thanks to [Antonio Davi Macedo Coelho de Castro](https://github.com/davimacedo)\n- CHANGE: Schema operations instead of generic operations in the GraphQL API [#5993](https://github.com/parse-community/parse-server/pull/5993). Thanks to [Antonio Davi Macedo Coelho de Castro](https://github.com/davimacedo)\n- DOC: Fix changelog formatting[#6009](https://github.com/parse-community/parse-server/pull/6009). Thanks to [Tom Fox](https://github.com/TomWFox)\n- CHANGE: Rename objectId to id in the GraphQL API [#5985](https://github.com/parse-community/parse-server/pull/5985). Thanks to [Douglas Muraoka](https://github.com/douglasmuraoka)\n- FIX: Fix beforeLogin trigger when user has a file [#6001](https://github.com/parse-community/parse-server/pull/6001). Thanks to [Antonio Davi Macedo Coelho de Castro](https://github.com/davimacedo)\n- DOC: Update GraphQL Docs with the latest changes [#5980](https://github.com/parse-community/parse-server/pull/5980). Thanks to [Antonio Davi Macedo Coelho de Castro](https://github.com/davimacedo)\n\n## 3.8.0\n[Full Changelog](https://github.com/parse-community/parse-server/compare/3.7.2...3.8.0)\n- NEW:  Protected fields pointer-permissions support [#5951](https://github.com/parse-community/parse-server/pull/5951).  Thanks to [Dobbias Nan](https://github.com/Dobbias)\n- NEW: GraphQL DX: Relation/Pointer [#5946](https://github.com/parse-community/parse-server/pull/5946).  Thanks to [Antoine Cormouls](https://github.com/Moumouls)\n- NEW: Master Key Only Config Properties [#5953](https://github.com/parse-community/parse-server/pull/5954). Thanks to [Manuel](https://github.com/mtrezza)\n- FIX: Better validation when creating a Relation fields [#5922](https://github.com/parse-community/parse-server/pull/5922).  Thanks to [Lucas Alencar](https://github.com/alencarlucas)\n- NEW: enable GraphQL file upload [#5944](https://github.com/parse-community/parse-server/pull/5944). Thanks to [Antonio Davi Macedo Coelho de Castro](https://github.com/davimacedo)\n- NEW: Handle shutdown on grid adapters  [#5943](https://github.com/parse-community/parse-server/pull/5943).  Thanks to [Antonio Davi Macedo Coelho de Castro](https://github.com/davimacedo)\n- NEW: Fix GraphQL max upload size [#5940](https://github.com/parse-community/parse-server/pull/5940). Thanks to [Antonio Davi Macedo Coelho de Castro](https://github.com/davimacedo)\n- FIX: Remove Buffer() deprecation notice [#5942](https://github.com/parse-community/parse-server/pull/5942).  Thanks to [Antonio Davi Macedo Coelho de Castro](https://github.com/davimacedo)\n- FIX: Remove MongoDB unified topology deprecation notice from the grid adapter [#5941](https://github.com/parse-community/parse-server/pull/5941).  Thanks to [Antonio Davi Macedo Coelho de Castro](https://github.com/davimacedo)\n- NEW: add callback for serverCloseComplete [#5937](https://github.com/parse-community/parse-server/pull/5937). Thanks to [Diamond Lewis](https://github.com/dplewis)\n- DOCS: Add Cloud Code guide to README [#5936](https://github.com/parse-community/parse-server/pull/5936).  Thanks to [Diamond Lewis](https://github.com/dplewis)\n- NEW: Remove nested operations from GraphQL API [#5931](https://github.com/parse-community/parse-server/pull/5931).  Thanks to [Antonio Davi Macedo Coelho de Castro](https://github.com/davimacedo)\n- NEW: Improve Live Query Monitoring [#5927](https://github.com/parse-community/parse-server/pull/5927).  Thanks to [Diamond Lewis](https://github.com/dplewis)\n- FIX: GraphQL: Fix undefined Array [#5296](https://github.com/parse-community/parse-server/pull/5926). Thanks to [Antoine Cormouls](https://github.com/Moumouls)\n- NEW: Added array support for pointer-permissions [#5921](https://github.com/parse-community/parse-server/pull/5921).  Thanks to [Dobbias Nan](https://github.com/Dobbias)\n- GraphQL: Renaming Types/Inputs [#5921](https://github.com/parse-community/parse-server/pull/5921). Thanks to [Antoine Cormouls](https://github.com/Moumouls)\n- FIX: Lint no-prototype-builtins [#5920](https://github.com/parse-community/parse-server/pull/5920). Thanks to [Diamond Lewis](https://github.com/dplewis)\n- GraphQL: Inline Fragment on Array Fields [#5908](https://github.com/parse-community/parse-server/pull/5908). Thanks to [Antoine Cormouls](https://github.com/Moumouls)\n- DOCS: Add instructions to launch a compatible Docker Postgres [](). Thanks to [Antoine Cormouls](https://github.com/Moumouls)\n- Fix: Undefined dot notation in matchKeyInQuery [#5917](https://github.com/parse-community/parse-server/pull/5917). Thanks to [Diamond Lewis](https://github.com/dplewis)\n- Fix: Logger print JSON and Numbers [#5916](https://github.com/parse-community/parse-server/pull/5916). Thanks to [Diamond Lewis](https://github.com/dplewis)\n- GraphQL: Return specific Type on specific Mutation [#5893](https://github.com/parse-community/parse-server/pull/5893). Thanks to [Antoine Cormouls](https://github.com/Moumouls)\n- FIX: Apple sign-in authAdapter [#5891](https://github.com/parse-community/parse-server/pull/5891). Thanks to [SebC](https://github.com/SebC99).\n- DOCS: Add GraphQL beta notice [#5886](https://github.com/parse-community/parse-server/pull/5886). Thanks to [Antonio Davi Macedo Coelho de Castro](https://github.com/davimacedo)\n- GraphQL: Remove \"password\" output field from _User class [#5889](https://github.com/parse-community/parse-server/pull/5889). Thanks to [Douglas Muraoka](https://github.com/douglasmuraoka)\n- GraphQL: Object constraints [#5715](https://github.com/parse-community/parse-server/pull/5715). Thanks to [Douglas Muraoka](https://github.com/douglasmuraoka)\n- DOCS: README top section overhaul + add sponsors [#5876](https://github.com/parse-community/parse-server/pull/5876). Thanks to [Tom Fox](https://github.com/TomWFox)\n- FIX: Return a Promise from classUpdate method [#5877](https://github.com/parse-community/parse-server/pull/5877). Thanks to [Lucas Alencar](https://github.com/alencarlucas)\n- FIX: Use UTC Month in aggregate tests [#5879](https://github.com/parse-community/parse-server/pull/5879). Thanks to [Antonio Davi Macedo Coelho de Castro](https://github.com/davimacedo)\n- FIX: Transaction was aborting before all promises have either resolved or rejected [#5878](https://github.com/parse-community/parse-server/pull/5878). Thanks to [Antonio Davi Macedo Coelho de Castro](https://github.com/davimacedo)\n- NEW: Use transactions for batch operation [#5849](https://github.com/parse-community/parse-server/pull/5849). Thanks to [Antonio Davi Macedo Coelho de Castro](https://github.com/davimacedo)\n\n### Breaking Changes\n- If you are running Parse Server on top of a MongoDB deployment which does not fit the [Retryable Writes Requirements](https://docs.mongodb.com/manual/core/retryable-writes/#prerequisites), you will have to add `retryWrites=false` to your connection string in order to upgrade to Parse Server 3.8.\n\n## 3.7.2\n[Full Changelog](https://github.com/parse-community/parse-server/compare/3.7.1...3.7.2)\n\n- FIX: Live Query was failing on release 3.7.1\n\n## 3.7.1\n[Full Changelog](https://github.com/parse-community/parse-server/compare/3.7.0...3.7.1)\n\n- FIX: Missing APN module\n- FIX: Set falsy values as default to schema fields [#5868](https://github.com/parse-community/parse-server/pull/5868), thanks to [Lucas Alencar](https://github.com/alencarlucas)\n- NEW: Implement WebSocketServer Adapter [#5866](https://github.com/parse-community/parse-server/pull/5866), thanks to [Diamond Lewis](https://github.com/dplewis)\n\n## 3.7.0\n[Full Changelog](https://github.com/parse-community/parse-server/compare/3.6.0...3.7.0)\n\n- FIX: Prevent linkWith sessionToken from generating new session [#5801](https://github.com/parse-community/parse-server/pull/5801), thanks to [Diamond Lewis](https://github.com/dplewis)\n- GraphQL: Improve session token error messages [#5753](https://github.com/parse-community/parse-server/pull/5753), thanks to [Douglas Muraoka](https://github.com/douglasmuraoka)\n- NEW: GraphQL { functions { call } } generic mutation [#5818](https://github.com/parse-community/parse-server/pull/5818), thanks to [Antonio Davi Macedo Coelho de Castro](https://github.com/davimacedo)\n- NEW: GraphQL Custom Schema [#5821](https://github.com/parse-community/parse-server/pull/5821), thanks to [Antonio Davi Macedo Coelho de Castro](https://github.com/davimacedo)\n- NEW: GraphQL custom schema on CLI [#5828](https://github.com/parse-community/parse-server/pull/5828), thanks to [Antonio Davi Macedo Coelho de Castro](https://github.com/davimacedo)\n- NEW: GraphQL @mock directive [#5836](https://github.com/parse-community/parse-server/pull/5836), thanks to [Antonio Davi Macedo Coelho de Castro](https://github.com/davimacedo)\n- FIX: GraphQL _or operator not working [#5840](https://github.com/parse-community/parse-server/pull/5840), thanks to [Antonio Davi Macedo Coelho de Castro](https://github.com/davimacedo)\n- NEW: Add \"count\" to CLP initial value [#5841](https://github.com/parse-community/parse-server/pull/5841), thanks to [Douglas Muraoka](https://github.com/douglasmuraoka)\n- NEW: Add ability to alter the response from the after save trigger [#5814](https://github.com/parse-community/parse-server/pull/5814), thanks to [BrunoMaurice](https://github.com/brunoMaurice)\n- FIX: Cache apple public key for the case it fails to fetch again [#5848](https://github.com/parse-community/parse-server/pull/5848), thanks to [Antonio Davi Macedo Coelho de Castro](https://github.com/davimacedo)\n- NEW: GraphQL Configuration Options [#5782](https://github.com/parse-community/parse-server/pull/5782), thanks to [Omair Vaiyani](https://github.com/omairvaiyani)\n- NEW: Required fields and default values [#5835](https://github.com/parse-community/parse-server/pull/5835), thanks to [Antonio Davi Macedo Coelho de Castro](https://github.com/davimacedo)\n- FIX: Postgres safely escape strings in nested objects [#5855](https://github.com/parse-community/parse-server/pull/5855), thanks to [Diamond Lewis](https://github.com/dplewis)\n- NEW: Support PhantAuth authentication [#5850](https://github.com/parse-community/parse-server/pull/5850), thanks to [Ivan SZKIBA](https://github.com/szkiba)\n- FIX: Remove uws package [#5860](https://github.com/parse-community/parse-server/pull/5860), thanks to [Zeal Murapa](https://github.com/GoGross)\n\n## 3.6.0\n[Full Changelog](https://github.com/parse-community/parse-server/compare/3.5.0...3.6.0)\n\n- SECURITY FIX: Address [Security Advisory](https://github.com/parse-community/parse-server/security/advisories/GHSA-8w3j-g983-8jh5) of a potential [Enumeration Attack](https://www.owasp.org/index.php/Testing_for_User_Enumeration_and_Guessable_User_Account_(OWASP-AT-002)#Description_of_the_Issue) [73b0f9a](https://github.com/parse-community/parse-server/commit/73b0f9a339b81f5d757725dc557955a7b670a3ec), big thanks to [Fabian Strachanski](https://github.com/fastrde) for identifying the problem, creating a fix and following the [vulnerability disclosure guidelines](https://github.com/parse-community/parse-server/blob/master/SECURITY.md#parse-community-vulnerability-disclosure-program)\n- NEW: Added rest option: excludeKeys [#5737](https://github.com/parse-community/parse-server/pull/5737), thanks to [Raschid J.F. Rafeally](https://github.com/RaschidJFR)\n- FIX: LiveQuery create event with fields [#5790](https://github.com/parse-community/parse-server/pull/5790), thanks to [Diamond Lewis](https://github.com/dplewis)\n- FIX: Generate sessionToken with linkWith [#5799](https://github.com/parse-community/parse-server/pull/5799), thanks to [Diamond Lewis](https://github.com/dplewis)\n\n## 3.5.0\n[Full Changelog](https://github.com/parse-community/parse-server/compare/3.4.4...3.5.0)\n\n- NEW: GraphQL Support [#5674](https://github.com/parse-community/parse-server/pull/5674), thanks to [Antonio Davi Macedo Coelho de Castro](https://github.com/davimacedo)\n\n[GraphQL Guide](https://github.com/parse-community/parse-server#graphql)\n\n- NEW: Sign in with Apple [#5694](https://github.com/parse-community/parse-server/pull/5694), thanks to [Diamond Lewis](https://github.com/dplewis)\n- NEW: AppSecret to Facebook Auth [#5695](https://github.com/parse-community/parse-server/pull/5695), thanks to [Diamond Lewis](https://github.com/dplewis)\n- NEW: Postgres: Regex support foreign characters [#5598](https://github.com/parse-community/parse-server/pull/5598), thanks to [Jeff Gu Kang](https://github.com/JeffGuKang)\n- FIX: Winston Logger string interpolation [#5729](https://github.com/parse-community/parse-server/pull/5729), thanks to [Diamond Lewis](https://github.com/dplewis)\n\n## 3.4.4\n[Full Changelog](https://github.com/parse-community/parse-server/compare/3.4.3...3.4.4)\n\nFix: Commit changes\n\n## 3.4.3\n[Full Changelog](https://github.com/parse-community/parse-server/compare/3.4.2...3.4.3)\n\nFix: Use changes in master to travis configuration to enable pushing to npm and gh_pages.  See diff for details.\n\n## 3.4.2\n[Full Changelog](https://github.com/parse-community/parse-server/compare/3.4.1...3.4.2)\n\nFix: In my haste to get a [Security Fix](https://github.com/parse-community/parse-server/security/advisories/GHSA-2479-qvv7-47qq) out, I added [8709daf](https://github.com/parse-community/parse-server/commit/8709daf698ea69b59268cb66f0f7cee75b52daa5) to master instead of to 3.4.1.  This commit fixes that.  [Arthur Cinader](https://github.com/acinader)\n\n## 3.4.1\n[Full Changelog](https://github.com/parse-community/parse-server/compare/3.4.0...3.4.1)\n\nSecurity Fix: see Advisory: [GHSA-2479-qvv7-47q](https://github.com/parse-community/parse-server/security/advisories/GHSA-2479-qvv7-47qq) for details [8709daf](https://github.com/parse-community/parse-server/commit/8709daf698ea69b59268cb66f0f7cee75b52daa5). Big thanks to: [Benjamin Simonsson](https://github.com/BenniPlejd) for identifying the issue and promptly bringing it to the Parse Community's attention and also big thanks to the indefatigable [Diamond Lewis](https://github.com/dplewis) for crafting a failing test and then a solution within an hour of the report.\n\n## 3.4.0\n[Full Changelog](https://github.com/parse-community/parse-server/compare/3.3.0...3.4.0)\n- NEW: Aggregate supports group by date fields [#5538](https://github.com/parse-community/parse-server/pull/5538) thanks to [Antonio Davi Macedo Coelho de Castro](https://github.com/davimacedo)\n- NEW: API for Read Preferences [#3963](https://github.com/parse-community/parse-server/pull/3963) thanks to [Antonio Davi Macedo Coelho de Castro](https://github.com/davimacedo)\n- NEW: Add Redis options for LiveQuery [#5584](https://github.com/parse-community/parse-server/pull/5584) thanks to [Diamond Lewis](https://github.com/dplewis)\n- NEW: Add Direct Access option for Server Config [#5550](https://github.com/parse-community/parse-server/pull/5550) thanks to [Diamond Lewis](https://github.com/dplewis)\n- FIX: updating mixed array in Postgres [#5552](https://github.com/parse-community/parse-server/pull/5552) thanks to [Diamond Lewis](https://github.com/dplewis)\n- FIX: notEqualTo GeoPoint Query in Postgres [#5549](https://github.com/parse-community/parse-server/pull/5549), thanks to [Diamond Lewis](https://github.com/dplewis)\n- FIX: put the timestamp back in logs that was lost after Winston upgrade [#5571](https://github.com/parse-community/parse-server/pull/5571), thanks to [Steven Rowe](https://github.com/mrowe009) and [Arthur Cinader](https://github.com/acinader)\n- FIX: Validates permission before calling beforeSave [#5546](https://github.com/parse-community/parse-server/pull/5546), thanks to [Antonio Davi Macedo Coelho de Castro](https://github.com/davimacedo)\n- FIX: Remove userSensitiveFields default value. [#5588](https://github.com/parse-community/parse-server/pull/5588), thanks to [William George](https://github.com/awgeorge)\n- FIX: Decode Date JSON value in LiveQuery. [#5540](https://github.com/parse-community/parse-server/pull/5540), thanks to [ananfang](https://github.com/ananfang)\n\n\n## 3.3.0\n[Full Changelog](https://github.com/parse-community/parse-server/compare/3.2.3...3.3.0)\n- NEW: beforeLogin trigger with support for auth providers ([#5445](https://github.com/parse-community/parse-server/pull/5445)), thanks to [Omair Vaiyani](https://github.com/omairvaiyani)\n- NEW: RFC 7662 compliant OAuth2 auth adapter ([#4910](https://github.com/parse-community/parse-server/pull/4910)), thanks to [M\u00fcller Zsolt](https://github.com/zsmuller)\n- FIX: cannot change password when maxPasswordHistory is 1 ([#5191](https://github.com/parse-community/parse-server/pull/5191)), thanks to [Tulsi Sapkota](https://github.com/Tolsee)\n- FIX (Postgres): count being very slow on large Parse Classes' collections ([#5330](https://github.com/parse-community/parse-server/pull/5330)), thanks to [CoderickLamar](https://github.com/CoderickLamar)\n- FIX: using per-key basis queue ([#5420](https://github.com/parse-community/parse-server/pull/5420)), thanks to [Georges Jamous](https://github.com/georgesjamous)\n- FIX: issue on count with Geo constraints and mongo ([#5286](https://github.com/parse-community/parse-server/pull/5286)), thanks to [Julien Qu\u00e9r\u00e9](https://github.com/jlnquere)\n\n## 3.2.3\n[Full Changelog](https://github.com/parse-community/parse-server/compare/3.2.2...3.2.3)\n- Correct previous release with patch that is fully merged\n\n## 3.2.2\n[Full Changelog](https://github.com/parse-community/parse-server/compare/3.2.1...3.2.2)\n- Security fix to properly process userSensitiveFields when parse-server is started with\n  ../lib/cli/parse-server [#5463](https://github.com/parse-community/parse-server/pull/5463\n  )\n\n## 3.2.1\n[Full Changelog](https://github.com/parse-community/parse-server/compare/3.2.0...3.2.1)\n- Increment package.json version to match the deployment tag\n\n## 3.2.0\n[Full Changelog](https://github.com/parse-community/parse-server/compare/3.1.3...3.2.0)\n- NEW: Support accessing sensitive fields with an explicit ACL.  Not documented yet, see [tests](https://github.com/parse-community/parse-server/blob/f2c332ea6a984808ad5b2e3ce34864a20724f72b/spec/UserPII.spec.js#L526) for examples\n- Upgrade Parse SDK JS to 2.3.1 [#5457](https://github.com/parse-community/parse-server/pull/5457)\n- Hides token contents in logStartupOptions if they arrive as a buffer [#6a9380](https://github.com/parse-community/parse-server/commit/6a93806c62205a56a8f4e3b8765848c552510337)\n- Support custom message for password requirements [#5399](https://github.com/parse-community/parse-server/pull/5399)\n- Support for Ajax password reset [#5332](https://github.com/parse-community/parse-server/pull/5332)\n- Postgres: Refuse to build unsafe JSON lists for contains [#5337](https://github.com/parse-community/parse-server/pull/5337)\n- Properly handle return values in beforeSave [#5228](https://github.com/parse-community/parse-server/pull/5228)\n- Fixes issue when querying user roles [#5276](https://github.com/parse-community/parse-server/pull/5276)\n- Fixes issue affecting update with CLP [#5269](https://github.com/parse-community/parse-server/pull/5269)\n\n## 3.1.3\n[Full Changelog](https://github.com/parse-community/parse-server/compare/3.1.2...3.1.3)\n\n- Postgres: Fixes support for global configuration\n- Postgres: Fixes support for numeric arrays\n- Postgres: Fixes issue affecting queries on empty arrays\n- LiveQuery: Adds support for transmitting the original object\n- Queries: Use estimated count if query is empty\n- Docker: Reduces the size of the docker image to 154Mb\n\n\n## 3.1.2\n[Full Changelog](https://github.com/parse-community/parse-server/compare/3.1.1...3.1.2)\n\n- Removes dev script, use TDD instead of server.\n- Removes nodemon and problematic dependencies.\n- Addressed event-stream security debacle.\n\n## 3.1.1\n[Full Changelog](https://github.com/parse-community/parse-server/compare/3.1.0...3.1.1)\n\n### Improvements:\n* Fixes issue that would prevent users with large number of roles to resolve all of them [Antoine Cormouls](https://github.com/Moumouls) (#5131, #5132)\n* Fixes distinct query on special fields ([#5144](https://github.com/parse-community/parse-server/pull/5144))\n\n\n## 3.1.0\n[Full Changelog](https://github.com/parse-community/parse-server/compare/3.0.0...3.1.0)\n\n### Breaking Changes:\n* Return success on sendPasswordResetEmail even if email not found. (#7fe4030)\n### Security Fix:\n* Expire password reset tokens on email change (#5104)\n### Improvements:\n* Live Query CLPs (#4387)\n* Reduces number of calls to injectDefaultSchema (#5107)\n* Remove runtime dependency on request (#5076)\n### Bug fixes:\n* Fixes issue with vkontatke authentication (#4977)\n* Use the correct function when validating google auth tokens (#5018)\n* fix unexpected 'delete' trigger issue on LiveQuery (#5031)\n* Improves performance for roles and ACL's in live query server (#5126)\n\n\n## 3.0.0\n[Full Changelog](https://github.com/parse-community/parse-server/compare/2.8.4...3.0.0)\n\n`parse-server` 3.0.0 comes with brand new handlers for cloud code. It now fully supports promises and async / await.\nFor more informations, visit the v3.0.0 [migration guide](https://github.com/parse-community/parse-server/blob/master/3.0.0.md).\n\n### Breaking changes:\n* Cloud Code handlers have a new interface based on promises.\n* response.success / response.error are removed in Cloud Code\n* Cloud Code runs with Parse-SDK 2.0\n* The aggregate now require aggregates to be passed in the form: `{\"pipeline\": [...]}` (REST Only)\n\n### Improvements:\n* Adds Pipeline Operator to Aggregate Router.\n* Adds documentations for parse-server's adapters, constructors and more.\n* Adds ability to pass a context object between `beforeSave` and `afterSave` affecting the same object.\n\n### Bug Fixes:\n* Fixes issue that would crash the server when mongo objects had undefined values [#4966](https://github.com/parse-community/parse-server/issues/4966)\n* Fixes issue that prevented ACL's from being used with `select` (see [#571](https://github.com/parse-community/Parse-SDK-JS/issues/571))\n\n### Dependency updates:\n* [@parse/simple-mailgun-adapter@1.1.0](https://www.npmjs.com/package/@parse/simple-mailgun-adapter)\n* [mongodb@3.1.3](https://www.npmjs.com/package/mongodb)\n* [request@2.88.0](https://www.npmjs.com/package/request)\n\n### Development Dependencies Updates:\n* [@parse/minami@1.0.0](https://www.npmjs.com/package/@parse/minami)\n* [deep-diff@1.0.2](https://www.npmjs.com/package/deep-diff)\n* [flow-bin@0.79.0](https://www.npmjs.com/package/flow-bin)\n* [jsdoc@3.5.5](https://www.npmjs.com/package/jsdoc)\n* [jsdoc-babel@0.4.0](https://www.npmjs.com/package/jsdoc-babel)\n\n### 2.8.4\n[Full Changelog](https://github.com/parse-community/parse-server/compare/2.8.3...2.8.4)\n\n#### Improvements:\n* Adds ability to forward errors to express handler (#4697)\n* Adds ability to increment the push badge with an arbitrary value (#4889)\n* Adds ability to preserve the file names when uploading (#4915)\n* `_User` now follow regular ACL policy. Letting administrator lock user out. (#4860) and (#4898)\n* Ensure dates are properly handled in aggregates (#4743)\n* Aggregates: Improved support for stages sharing the same name\n* Add includeAll option\n* Added verify password to users router and tests. (#4747)\n* Ensure read preference is never overriden, so DB config prevails (#4833)\n* add support for geoWithin.centerSphere queries via withJSON (#4825)\n* Allow sorting an object field (#4806)\n* Postgres: Don't merge JSON fields after save() to keep same behaviour as MongoDB (#4808) (#4815)\n\n#### Dependency updates\n* [commander@2.16.0](https://www.npmjs.com/package/commander)\n* [mongodb@3.1.1](https://www.npmjs.com/package/mongodb)\n* [pg-promise@8.4.5](https://www.npmjs.com/package/pg-promise)\n* [ws@6.0.0](https://www.npmjs.com/package/ws)\n* [bcrypt@3.0.0](https://www.npmjs.com/package/bcrypt)\n* [uws@10.148.1](https://www.npmjs.com/package/uws)\n\n##### Development Dependencies Updates:\n* [cross-env@5.2.0](https://www.npmjs.com/package/cross-env)\n* [eslint@5.0.0](https://www.npmjs.com/package/eslint)\n* [flow-bin@0.76.0](https://www.npmjs.com/package/flow-bin)\n* [mongodb-runner@4.0.0](https://www.npmjs.com/package/mongodb-runner)\n* [nodemon@1.18.1](https://www.npmjs.com/package/nodemon)\n* [nyc@12.0.2](https://www.npmjs.com/package/nyc)\n* [request-promise@4.2.2](https://www.npmjs.com/package/request-promise)\n* [supports-color@5.4.0](https://www.npmjs.com/package/supports-color)\n\n### 2.8.3\n[Full Changelog](https://github.com/parse-community/parse-server/compare/2.8.2...2.8.3)\n\n#### Improvements:\n\n* Adds support for JS SDK 2.0 job status header\n* Removes npm-git scripts as npm supports using git repositories that build, thanks to [Florent Vilmart](https://github.com/flovilmart)\n\n\n### 2.8.2\n[Full Changelog](https://github.com/parse-community/parse-server/compare/2.8.1...2.8.2)\n\n##### Bug Fixes:\n* Ensure legacy users without ACL's are not locked out, thanks to [Florent Vilmart](https://github.com/flovilmart)\n\n#### Improvements:\n* Use common HTTP agent to increase webhooks performance, thanks to [Tyler Brock](https://github.com/TylerBrock)\n* Adds withinPolygon support for Polygon objects, thanks to [Mads Bjerre](https://github.com/madsb)\n\n#### Dependency Updates:\n* [ws@5.2.0](https://www.npmjs.com/package/ws)\n* [commander@2.15.1](https://www.npmjs.com/package/commander)\n* [nodemon@1.17.5](https://www.npmjs.com/package/nodemon)\n\n##### Development Dependencies Updates:\n* [flow-bin@0.73.0](https://www.npmjs.com/package/flow-bin)\n* [cross-env@5.1.6](https://www.npmjs.com/package/cross-env)\n* [gaze@1.1.3](https://www.npmjs.com/package/gaze)\n* [deepcopy@1.0.0](https://www.npmjs.com/package/deepcopy)\n* [deep-diff@1.0.1](https://www.npmjs.com/package/deep-diff)\n\n\n### 2.8.1\n[Full Changelog](https://github.com/parse-community/parse-server/compare/2.8.1...2.8.0)\n\nEnsure all the files are properly exported to the final package.\n\n### 2.8.0\n[Full Changelog](https://github.com/parse-community/parse-server/compare/2.8.0...2.7.4)\n\n#### New Features\n* Adding Mongodb element to add `arrayMatches` the #4762 (#4766), thanks to [J\u00e9r\u00e9my Piednoel](https://github.com/jeremypiednoel)\n* Adds ability to Lockout users (#4749), thanks to [Florent Vilmart](https://github.com/flovilmart)\n\n#### Bug fixes:\n* Fixes issue when using afterFind with relations (#4752), thanks to [Florent Vilmart](https://github.com/flovilmart)\n* New query condition support to match all strings that starts with some other given strings (#3864), thanks to [Eduard Bosch Bertran](https://github.com/eduardbosch)\n* Allow creation of indices on default fields (#4738), thanks to [Claire Neveu](https://github.com/ClaireNeveu)\n* Purging empty class (#4676), thanks to [Diamond Lewis](https://github.com/dplewis)\n* Postgres: Fixes issues comparing to zero or false (#4667), thanks to [Diamond Lewis](https://github.com/dplewis)\n* Fix Aggregate Match Pointer (#4643), thanks to [Diamond Lewis](https://github.com/dplewis)\n\n#### Improvements:\n* Allow Parse.Error when returning from Cloud Code (#4695), thanks to [Saulo Tauil](https://github.com/saulogt)\n* Fix typo: \"requrest\" -> \"request\" (#4761), thanks to [Joseph Frazier](https://github.com/josephfrazier)\n* Send version for Vkontakte API (#4725), thanks to [oleg](https://github.com/alekoleg)\n* Ensure we respond with invalid password even if email is unverified (#4708), thanks to [dblythy](https://github.com/dblythy)\n* Add _password_history to default sensitive data (#4699), thanks to [Jong Eun Lee](https://github.com/yomybaby)\n* Check for node version in postinstall script (#4657), thanks to [Diamond Lewis](https://github.com/dplewis)\n* Remove FB Graph API version from URL to use the oldest non deprecated version, thanks to [SebC](https://github.com/SebC99)\n\n#### Dependency Updates:\n* [@parse/push-adapter@2.0.3](https://www.npmjs.com/package/@parse/push-adapter)\n* [@parse/simple-mailgun-adapter@1.0.2](https://www.npmjs.com/package/@parse/simple-mailgun-adapter)\n* [uws@10.148.0](https://www.npmjs.com/package/uws)\n* [body-parser@1.18.3](https://www.npmjs.com/package/body-parser)\n* [mime@2.3.1](https://www.npmjs.com/package/mime)\n* [request@2.85.0](https://www.npmjs.com/package/request)\n* [mongodb@3.0.7](https://www.npmjs.com/package/mongodb)\n* [bcrypt@2.0.1](https://www.npmjs.com/package/bcrypt)\n* [ws@5.1.1](https://www.npmjs.com/package/ws)\n\n##### Development Dependencies Updates:\n* [cross-env@5.1.5](https://www.npmjs.com/package/cross-env)\n* [flow-bin@0.71.0](https://www.npmjs.com/package/flow-bin)\n* [deep-diff@1.0.0](https://www.npmjs.com/package/deep-diff)\n* [nodemon@1.17.3](https://www.npmjs.com/package/nodemon)\n\n\n### 2.7.4\n[Full Changelog](https://github.com/parse-community/parse-server/compare/2.7.4...2.7.3)\n\n#### Bug Fixes:\n* Fixes an issue affecting polygon queries, thanks to [Diamond Lewis](https://github.com/dplewis)\n\n#### Dependency Updates:\n* [pg-promise@8.2.1](https://www.npmjs.com/package/pg-promise)\n\n##### Development Dependencies Updates:\n* [nodemon@1.17.1](https://www.npmjs.com/package/nodemon)\n\n### 2.7.3\n[Full Changelog](https://github.com/parse-community/parse-server/compare/2.7.3...2.7.2)\n\n#### Improvements:\n* Improve documentation for LiveQuery options, thanks to [Arthur Cinader](https://github.com/acinader)\n* Improve documentation for using cloud code with docker, thanks to [Stephen Tuso](https://github.com/stephentuso)\n* Adds support for Facebook's AccountKit, thanks to [6thfdwp](https://github.com/6thfdwp)\n* Disable afterFind routines when running aggregates, thanks to [Diamond Lewis](https://github.com/dplewis)\n* Improve support for distinct aggregations of nulls, thanks to [Diamond Lewis](https://github.com/dplewis)\n* Regenreate the email verification token when requesting a new email, thanks to [Benjamin Wilson Friedman](https://github.com/montymxb)\n\n#### Bug Fixes:\n* Fix issue affecting readOnly masterKey and purge command, thanks to [AreyouHappy](https://github.com/AreyouHappy)\n* Fixes Issue unsetting in beforeSave doesn't allow object creation, thanks to [Diamond Lewis](https://github.com/dplewis)\n* Fixes issue crashing server on invalid live query payload, thanks to [fridays](https://github.com/fridays)\n* Fixes issue affecting postgres storage adapter \"undefined property '__op'\", thanks to [Tyson Andre](https://github,com/TysonAndre)\n\n#### Dependency Updates:\n* [winston@2.4.1](https://www.npmjs.com/package/winston)\n* [pg-promise@8.2.0](https://www.npmjs.com/package/pg-promise)\n* [commander@2.15.0](https://www.npmjs.com/package/commander)\n* [lru-cache@4.1.2](https://www.npmjs.com/package/lru-cache)\n* [parse@1.11.1](https://www.npmjs.com/package/parse)\n* [ws@5.0.0](https://www.npmjs.com/package/ws)\n* [mongodb@3.0.4](https://www.npmjs.com/package/mongodb)\n* [lodash@4.17.5](https://www.npmjs.com/package/lodash)\n\n##### Development Dependencies Updates:\n* [cross-env@5.1.4](https://www.npmjs.com/package/cross-env)\n* [flow-bin@0.67.1](https://www.npmjs.com/package/flow-bin)\n* [jasmine@3.1.0](https://www.npmjs.com/package/jasmine)\n* [parse@1.11.1](https://www.npmjs.com/package/parse)\n* [babel-eslint@8.2.2](https://www.npmjs.com/package/babel-eslint)\n* [nodemon@1.15.0](https://www.npmjs.com/package/nodemon)\n\n### 2.7.2\n[Full Changelog](https://github.com/parse-community/parse-server/compare/2.7.2...2.7.1)\n\n#### Improvements:\n* Improved match aggregate\n* Do not mark the empty push as failed\n* Support pointer in aggregate query\n* Introduces flow types for storage\n* Postgres: Refactoring of Postgres Storage Adapter\n* Postgres: Support for multiple projection in aggregate\n* Postgres: performance optimizations\n* Adds infos about vulnerability disclosures\n* Adds ability to login with email when provided as username\n\n#### Bug Fixes\n* Scrub Passwords with URL Encoded Characters\n* Fixes issue affecting using sorting in beforeFind\n\n#### Dependency Updates:\n* [commander@2.13.0](https://www.npmjs.com/package/commander)\n* [semver@5.5.0](https://www.npmjs.com/package/semver)\n* [pg-promise@7.4.0](https://www.npmjs.com/package/pg-promise)\n* [ws@4.0.0](https://www.npmjs.com/package/ws)\n* [mime@2.2.0](https://www.npmjs.com/package/mime)\n* [parse@1.11.0](https://www.npmjs.com/package/parse)\n\n##### Development Dependencies Updates:\n* [nodemon@1.14.11](https://www.npmjs.com/package/nodemon)\n* [flow-bin@0.64.0](https://www.npmjs.com/package/flow-bin)\n* [jasmine@2.9.0](https://www.npmjs.com/package/jasmine)\n* [cross-env@5.1.3](https://www.npmjs.com/package/cross-env)\n\n### 2.7.1\n[Full Changelog](https://github.com/parse-community/parse-server/compare/2.7.1...2.7.0)\n\n:warning: Fixes a security issue affecting Class Level Permissions\n\n* Adds support for dot notation when using matchesKeyInQuery, thanks to [Henrik](https://github.com/bohemima) and [Arthur Cinader](https://github.com/acinader)\n\n### 2.7.0\n[Full Changelog](https://github.com/parse-community/parse-server/compare/2.7.0...2.6.5)\n\n:warning: This version contains an issue affecting Class Level Permissions on mongoDB. Please upgrade to 2.7.1.\n\nStarting parse-server 2.7.0, the minimun nodejs version is 6.11.4, please update your engines before updating parse-server\n\n#### New Features:\n* Aggregation endpoints, thanks to [Diamond Lewis](https://github.com/dplewis)\n* Adds indexation options onto Schema endpoints, thanks to [Diamond Lewis](https://github.com/dplewis)\n\n#### Bug fixes:\n* Fixes sessionTokens being overridden in 'find' (#4332), thanks to [Benjamin Wilson Friedman](https://github.com/montymxb)\n* Proper `handleShutdown()` feature to close database connections (#4361), thanks to [CHANG, TZU-YEN](https://github.com/trylovetom)\n* Fixes issue affecting state of _PushStatus objects, thanks to [Benjamin Wilson Friedman](https://github.com/montymxb)\n* Fixes issue affecting calling password reset password pages with wrong appid, thanks to [Bryan de Leon](https://github.com/bryandel)\n* Fixes issue affecting duplicates _Sessions on successive logins, thanks to [Florent Vilmart](https://github.com/flovilmart)\n\n#### Improvements:\n* Updates contributing guides, and improves windows support, thanks to [Addison Elliott](https://github.com/addisonelliott)\n* Uses new official scoped packaged, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Improves health checks responses, thanks to [Benjamin Wilson Friedman](https://github.com/montymxb)\n* Add password confirmation to choose_password, thanks to [Worathiti Manosroi](https://github.com/pungme)\n* Improve performance of relation queries, thanks to [Florent Vilmart](https://github.com/flovilmart)\n\n#### Dependency Updates:\n* [commander@2.12.1](https://www.npmjs.com/package/commander)\n* [ws@3.3.2](https://www.npmjs.com/package/ws)\n* [uws@9.14.0](https://www.npmjs.com/package/uws)\n* [pg-promise@7.3.2](https://www.npmjs.com/package/pg-promise)\n* [parse@1.10.2](https://www.npmjs.com/package/parse)\n* [pg-promise@7.3.1](https://www.npmjs.com/package/pg-promise)\n\n##### Development Dependencies Updates:\n* [cross-env@5.1.1](https://www.npmjs.com/package/cross-env)\n\n\n\n### 2.6.5\n[Full Changelog](https://github.com/ParsePlatform/parse-server/compare/2.6.5...2.6.4)\n\n#### New Features:\n* Adds support for read-only masterKey, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Adds support for relative time queries (mongodb only), thanks to [Marvel Mathew](https://github.com/marvelm)\n\n#### Improvements:\n* Handle possible afterSave exception, thanks to [Benjamin Wilson Friedman](https://github.com/montymxb)\n* Add support for expiration interval in Push, thanks to [Marvel Mathew](https://github.com/marvelm)\n\n#### Bug Fixes:\n* The REST API key was improperly inferred from environment when using the CLI, thanks to [Florent Vilmart](https://github.com/flovilmart)\n\n### 2.6.4\n[Full Changelog](https://github.com/ParsePlatform/parse-server/compare/2.6.4...2.6.3)\n\n#### Improvements:\n* Improves management of configurations and default values, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Adds ability to start ParseServer with `ParseServer.start(options)`, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Adds request original IP to cloud code hooks, thanks to [Gustav Ahlberg](https://github.com/Gyran)\n* Corrects some outdated links, thanks to [Benjamin Wilson Friedman](https://github.com/montymxb)\n* Adds serverURL validation on startup, thanks to [Benjamin Wilson Friedman](https://github.com/montymxb)\n* Adds ability to login with POST requests alongside GET, thanks to [Benjamin Wilson Friedman](https://github.com/montymxb)\n* Adds ability to login with email, instead of username, thanks to [Florent Vilmart](https://github.com/flovilmart)\n\n#### Bug Fixes:\n* Fixes issue affecting beforeSaves and increments, thanks to [Benjamin Wilson Friedman](https://github.com/montymxb)\n\n#### Dependency Updates:\n* [parse-server-push-adapter@2.0.2](https://www.npmjs.com/package/parse-server-push-adapter)\n* [semver@5.4.1](https://www.npmjs.com/package/semver)\n* [pg-promise@7.0.3](https://www.npmjs.com/package/pg-promise)\n* [mongodb@2.2.33](https://www.npmjs.com/package/mongodb)\n* [parse@1.10.1](https://www.npmjs.com/package/parse)\n* [express@4.16.0](https://www.npmjs.com/package/express)\n* [mime@1.4.1](https://www.npmjs.com/package/mime)\n* [parse-server-simple-mailgun-adapter@1.0.1](https://www.npmjs.com/package/parse-server-simple-mailgun-adapter)\n\n##### Development Dependencies Updates:\n* [babel-preset-env@1.6.1](https://www.npmjs.com/package/babel-preset-env)\n* [cross-env@5.1.0](https://www.npmjs.com/package/cross-env)\n* [mongodb-runner@3.6.1](https://www.npmjs.com/package/mongodb-runner)\n* [eslint-plugin-flowtype@2.39.1](https://www.npmjs.com/package/eslint-plugin-flowtype)\n* [eslint@4.9.0](https://www.npmjs.com/package/eslint)\n\n### 2.6.3\n[Full Changelog](https://github.com/ParsePlatform/parse-server/compare/2.6.2...2.6.3)\n\n#### Improvements:\n* Queries on Pointer fields with `$in` and `$nin` now supports list of objectId's, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* LiveQueries on `$in` and `$nin` for pointer fields work as expected thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Also remove device token when APNS error is BadDeviceToken, thanks to [Mauricio Tollin](https://github.com/)\n* LRU cache is not available on the ParseServer object, thanks to [Tyler Brock](https://github.com/tbrock)\n* Error messages are more expressive, thanks to [Tyler Brock](https://github.com/tbrock)\n* Postgres: Properly handle undefined field values, thanks to [Diamond Lewis](https://github.com/dlewis)\n* Updating with two GeoPoints fails correctly, thanks to [Anthony Mosca](https://github.com/aontas)\n\n#### New Features:\n* Adds ability to set a maxLimit on server configuration for queries, thanks to [Chris Norris](https://github.com/)\n\n#### Bug fixes:\n* Fixes issue affecting reporting `_PushStatus` with misconfigured serverURL, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Fixes issue affecting deletion of class that doesn't exist, thanks to [Diamond Lewis](https://github.com/dlewis)\n\n#### Dependency Updates:\n* [winston@2.4.0](https://www.npmjs.com/package/winston)\n* [pg-promise@6.10.2](https://www.npmjs.com/package/pg-promise)\n* [winston-daily-rotate-file@1.6.0](https://www.npmjs.com/package/winston-daily-rotate-file)\n* [request@2.83.0](https://www.npmjs.com/package/request)\n* [body-parser@1.18.2](https://www.npmjs.com/package/body-parser)\n\n##### Development Dependencies Updates:\n* [request-promise@4.2.2](https://www.npmjs.com/package/request-promise)\n* [eslint@4.7.1](https://www.npmjs.com/package/eslint)\n\n### 2.6.2\n[Full Changelog](https://github.com/ParsePlatform/parse-server/compare/2.6.1...2.6.2)\n\n#### Improvements:\n* PushWorker/PushQueue channels are properly prefixed with the Parse applicationId, thanks to [Marvel Mathew](https://github.com/marvelm)\n* You can use Parse.Cloud.afterSave hooks on _PushStatus\n* You can use Parse.Cloud.onLiveQueryEvent to track the number of clients and subscriptions\n* Adds support for more fields from the Audience class.\n\n#### New Features:\n* Push: Adds ability to track sentPerUTC offset if your push scheduler supports it.\n* Push: Adds support for cleaning up invalid deviceTokens from _Installation (PARSE_SERVER_CLEANUP_INVALID_INSTALLATIONS=1).\n\n#### Dependency Updates:\n* [ws@3.2.0](https://www.npmjs.com/package/ws)\n* [pg-promise@6.5.3](https://www.npmjs.com/package/pg-promise)\n* [winston-daily-rotate-file@1.5.0](https://www.npmjs.com/package/winston-daily-rotate-file)\n* [body-parser@1.18.1](https://www.npmjs.com/package/body-parser)\n\n##### Development Dependencies Updates:\n* [nodemon@1.12.1](https://www.npmjs.com/package/nodemon)\n* [mongodb-runner@3.6.0](https://www.npmjs.com/package/mongodb-runner)\n* [babel-eslint@8.0.0](https://www.npmjs.com/package/babel-eslint)\n\n### 2.6.1\n[Full Changelog](https://github.com/ParsePlatform/parse-server/compare/2.6.0...2.6.1)\n\n#### Improvements:\n* Improves overall performance of the server, more particularly with large query results.\n* Improves performance of InMemoryCacheAdapter by removing serialization.\n* Improves logging performance by skipping necessary log calls.\n* Refactors object routers to simplify logic.\n* Adds automatic indexing on $text indexes, thanks to [Diamon Lewis](https://github.com/dplewis)\n\n#### New Features:\n* Push: Adds ability to send localized pushes according to the _Installation localeIdentifier\n* Push: proper support for scheduling push in user's locale time, thanks to [Marvel Mathew](https://github.com/marvelm)\n* LiveQuery: Adds ability to use LiveQuery with a masterKey, thanks to [Jeremy May](https://github.com/kenishi)\n\n#### Bug Fixes:\n* Fixes an issue that would duplicate Session objects per userId-installationId pair.\n* Fixes an issue affecting pointer permissions introduced in this release.\n* Fixes an issue that would prevent displaying audiences correctly in dashboard.\n* Fixes an issue affecting preventLoginWithUnverifiedEmail upon signups.\n\n#### Dependency Updates:\n* [pg-promise@6.3.2](https://www.npmjs.com/package/pg-promise)\n* [body-parser@1.18.0](https://www.npmjs.com/package/body-parser)\n* [nodemon@1.11.1](https://www.npmjs.com/package/nodemon)\n\n##### Development Dependencies Updates:\n* [babel-cli@6.26.0](https://www.npmjs.com/package/babel-cli)\n\n### 2.6.0\n[Full Changelog](https://github.com/ParsePlatform/parse-server/compare/2.5.3...2.6.0)\n\n#### Breaking Changes:\n* [parse-server-s3-adapter@1.2.0](https://www.npmjs.com/package/parse-server-s3-adapter): A new deprecation notice is introduced with parse-server-s3-adapter's version 1.2.0.  An upcoming release will remove passing key and password arguments.  AWS credentials should be set using AWS best practices.  See the [Deprecation Notice for AWS credentials]( https://github.com/parse-server-modules/parse-server-s3-adapter/blob/master/README.md#deprecation-notice----aws-credentials) section of the adapter's README.\n\n#### New Features\n* Polygon is fully supported as a type, thanks to [Diamond Lewis](https://github.com/dplewis)\n* Query supports PolygonContains, thanks to [Diamond Lewis](https://github.com/dplewis)\n\n#### Improvements\n* Postgres: Adds support nested contains and containedIn, thanks to [Diamond Lewis](https://github.com/dplewis)\n* Postgres: Adds support for `null` in containsAll queries, thanks to [Diamond Lewis](https://github.com/dplewis)\n* Cloud Code: Request headers are passed to the cloud functions, thanks to [miguel-s](https://github.com/miguel-s)\n* Push: All push queries now filter only where deviceToken exists\n\n#### Bug Fixes:\n* Fixes issue affecting updates of _User objects when authData was passed.\n* Push: Pushing to an empty audience should now properly report a failed _PushStatus\n* Linking Users: Fixes issue affecting linking users with sessionToken only\n\n#### Dependency Updates:\n* [ws@3.1.0](https://www.npmjs.com/package/ws)\n* [mime@1.4.0](https://www.npmjs.com/package/mime)\n* [semver@5.4.0](https://www.npmjs.com/package/semver)\n* [uws@8.14.1](https://www.npmjs.com/package/uws)\n* [bcrypt@1.0.3](https://www.npmjs.com/package/bcrypt)\n* [mongodb@2.2.31](https://www.npmjs.com/package/mongodb)\n* [redis@2.8.0](https://www.npmjs.com/package/redis)\n* [pg-promise@6.3.1](https://www.npmjs.com/package/pg-promise)\n* [commander@2.11.0](https://www.npmjs.com/package/commander)\n\n##### Development Dependencies Updates:\n* [jasmine@2.8.0](https://www.npmjs.com/package/jasmine)\n* [babel-register@6.26.0](https://www.npmjs.com/package/babel-register)\n* [babel-core@6.26.0](https://www.npmjs.com/package/babel-core)\n* [cross-env@5.0.2](https://www.npmjs.com/package/cross-env)\n\n### 2.5.3\n[Full Changelog](https://github.com/ParsePlatform/parse-server/compare/2.5.2...2.5.3)\n\n#### New Features:\n* badge property on android installations will now be set as on iOS (#3970), thanks to [Florent Vilmart](https://github.com/flovilmart)\n\n#### Bug Fixes:\n* Fixes incorrect number parser for cache options\n\n### 2.5.2\n[Full Changelog](https://github.com/ParsePlatform/parse-server/compare/2.5.1...2.5.2)\n\n#### Improvements:\n* Restores ability to run on node >= 4.6\n* Adds ability to configure cache from CLI\n* Removes runtime check for node >= 4.6\n\n### 2.5.1\n[Full Changelog](https://github.com/ParsePlatform/parse-server/compare/2.5.0...2.5.1)\n\n#### New Features:\n* Adds ability to set default objectId size (#3950), thanks to [Steven Shipton](https://github.com/steven-supersolid)\n\n#### Improvements:\n* Uses LRU cache instead of InMemoryCache by default (#3979), thanks to [Florent Vilmart](https://github.com/flovilmart)\n* iOS pushes are now using HTTP/2.0 instead of binary API  (#3983), thanks to [Florent Vilmart](https://github.com/flovilmart)\n\n#### Dependency Updates:\n* [parse@1.10.0](https://www.npmjs.com/package/parse)\n* [pg-promise@6.3.0](https://www.npmjs.com/package/pg-promise)\n* [parse-server-s3-adapter@1.1.0](https://www.npmjs.com/package/parse-server-s3-adapter)\n* [parse-server-push-adapter@2.0.0](https://www.npmjs.com/package/parse-server-push-adapter)\n\n### 2.5.0\n[Full Changelog](https://github.com/ParsePlatform/parse-server/compare/2.4.2...2.5.0)\n\n#### New Features:\n* Adds ability to run full text search (#3904), thanks to [Diamond Lewis](https://github.com/dplewis)\n* Adds ability to run `$withinPolygon` queries (#3889), thanks to [Diamond Lewis](https://github.com/dplewis)\n* Adds ability to pass read preference per query with mongodb (#3865), thanks to [davimacedo](https://github.com/davimacedo)\n* beforeFind trigger now includes `isGet` for get queries (#3862), thanks to [davimacedo](https://github.com/davimacedo)\n* Adds endpoints for dashboard's audience API (#3861), thanks to [davimacedo](https://github.com/davimacedo)\n* Restores the job scheduling endpoints (#3927), thanks to [Florent Vilmart](https://github.com/flovilmart)\n\n#### Improvements:\n* Removes unnecessary warning when using maxTimeMs with mongodb, thanks to [Tyler Brock](https://github.com/tbrock)\n* Improves access control on system classes (#3916), thanks to [Worathiti Manosroi](https://github.com/pungme)\n* Adds bytes support in postgres (#3894), thanks to [Diamond Lewis](https://github.com/dplewis)\n\n#### Bug Fixes:\n* Fixes issue with vkontakte adapter that would hang the request, thanks to [Denis Trofimov](https://github.com/denistrofimov)\n* Fixes issue affecting null relational data (#3924), thanks to [davimacedo](https://github.com/davimacedo)\n* Fixes issue affecting session token deletion (#3937), thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Fixes issue affecting the serverInfo endpoint (#3933), thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Fixes issue affecting beforeSave with dot-noted sub-documents (#3912), thanks to [IlyaDiallo](https://github.com/IlyaDiallo)\n* Fixes issue affecting emails being sent when using a 3rd party auth (#3882), thanks to [davimacedo](https://github.com/davimacedo)\n\n#### Dependency Updates:\n* [commander@2.10.0](https://www.npmjs.com/package/commander)\n* [pg-promise@5.9.7](https://www.npmjs.com/package/pg-promise)\n* [lru-cache@4.1.0](https://www.npmjs.com/package/lru-cache)\n* [mongodb@2.2.28](https://www.npmjs.com/package/mongodb)\n\n##### Development dependencies\n* [babel-core@6.25.0](https://www.npmjs.com/package/babel-core)\n* [cross-env@5.0.1](https://www.npmjs.com/package/cross-env)\n* [nyc@11.0.2](https://www.npmjs.com/package/nyc)\n\n### 2.4.2\n[Full Changelog](https://github.com/ParsePlatform/parse-server/compare/2.4.1...2.4.2)\n\n#### New Features:\n* ParseQuery: Support for withinPolygon [#3866](https://github.com/parse-community/parse-server/pull/3866), thanks to [Diamond Lewis](https://github.com/dplewis)\n\n#### Improvements:\n* Postgres: Use transactions when deleting a class, [#3869](https://github.com/parse-community/parse-server/pull/3836), thanks to [Vitaly Tomilov](https://github.com/vitaly-t)\n* Postgres: Proper support for GeoPoint equality query, [#3874](https://github.com/parse-community/parse-server/pull/3836), thanks to [Diamond Lewis](https://github.com/dplewis)\n* beforeSave and liveQuery will be correctly triggered on email verification [#3851](https://github.com/parse-community/parse-server/pull/3851), thanks to [Florent Vilmart](https://github.com/flovilmart)\n\n#### Bug fixes:\n* Skip authData validation if it hasn't changed, on PUT requests [#3872](https://github.com/parse-community/parse-server/pull/3872), thanks to [Florent Vilmart](https://github.com/flovilmart)\n\n#### Dependency Updates:\n* [mongodb@2.2.27](https://www.npmjs.com/package/mongodb)\n* [pg-promise@5.7.2](https://www.npmjs.com/package/pg-promise)\n\n\n### 2.4.1\n[Full Changelog](https://github.com/ParsePlatform/parse-server/compare/2.4.0...2.4.1)\n\n#### Bug fixes:\n* Fixes issue affecting relation updates ([#3835](https://github.com/parse-community/parse-server/pull/3835), [#3836](https://github.com/parse-community/parse-server/pull/3836)), thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Fixes issue affecting sending push notifications, thanks to [Felipe Andrade](https://github.com/felipemobile)\n* Session are always cleared when updating the passwords ([#3289](https://github.com/parse-community/parse-server/pull/3289), [#3821](https://github.com/parse-community/parse-server/pull/3821), thanks to [Florent Vilmart](https://github.com/flovilmart)\n\n#### Dependency Updates:\n* [body-parser@1.17.2](https://www.npmjs.com/package/body-parser)\n* [pg-promise@5.7.1](https://www.npmjs.com/package/pg-promise)\n* [ws@3.0.0](https://www.npmjs.com/package/ws)\n\n\n### 2.4.0\n[Full Changelog](https://github.com/ParsePlatform/parse-server/compare/2.3.8...2.4.0)\n\nStarting 2.4.0, parse-server is tested against node 6.10 and 7.10, mongodb 3.2 and 3.4.\nIf you experience issues with older versions, please [open a issue](https://github.com/parse-community/parse-server/issues).\n\n#### New Features:\n* Adds `count` Class Level Permission ([#3814](https://github.com/parse-community/parse-server/pull/3814)), thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Proper graceful shutdown support ([#3786](https://github.com/parse-community/parse-server/pull/3786)), thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Let parse-server store as `scheduled` Push Notifications with push_time (#3717, #3722), thanks to [Felipe Andrade](https://github.com/felipemobile)\n\n#### Improvements\n* Parse-Server images are built through docker hub, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Skip authData validation if it hasn't changed, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* [postgres] Improve performance when adding many new fields to the Schema ([#3740](https://github.com/parse-community/parse-server/pull/3740)), thanks to [Paulo V\u00edtor S Reis](https://github.com/paulovitin)\n* Test maintenance, wordsmithing and nits ([#3744](https://github.com/parse-community/parse-server/pull/3744)), thanks to [Arthur Cinader](https://github.com/acinader)\n\n#### Bug Fixes:\n* [postgres] Fixes issue affecting deleting multiple fields of a Schema ([#3734](https://github.com/parse-community/parse-server/pull/3734), [#3735](https://github.com/parse-community/parse-server/pull/3735)), thanks to [Paulo V\u00edtor S Reis](https://github.com/paulovitin)\n* Fix issue affecting _PushStatus state ([#3808](https://github.com/parse-community/parse-server/pull/3808)), thanks to [Florent Vilmart](https://github.com/flovilmart)\n* requiresAuthentication Class Level Permission behaves correctly, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Email Verification related fields are not exposed ([#3681](https://github.com/parse-community/parse-server/pull/3681), [#3393](https://github.com/parse-community/parse-server/pull/3393), [#3432](https://github.com/parse-community/parse-server/pull/3432)), thanks to [Anthony Mosca](https://github.com/aontas)\n* HTTP query parameters are properly obfuscated in logs ([#3793](https://github.com/parse-community/parse-server/pull/3793), [#3789](https://github.com/parse-community/parse-server/pull/3789)), thanks to [@youngerong](https://github.com/youngerong)\n* Improve handling of `$near` operators in `$or` queries ([#3767](https://github.com/parse-community/parse-server/pull/3767), [#3798](https://github.com/parse-community/parse-server/pull/3798)), thanks to [Jack Wearden](https://github.com/NotBobTheBuilder)\n* Fix issue affecting arrays of pointers ([#3169](https://github.com/parse-community/parse-server/pull/3169)), thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Fix issue affecting overloaded query constraints ([#3723](https://github.com/parse-community/parse-server/pull/3723), [#3678](https://github.com/parse-community/parse-server/pull/3678)), thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Properly catch unhandled rejections in _Installation updates ([#3795](https://github.com/parse-community/parse-server/pull/3795)), thanks to [kahoona77](https://github.com/kahoona77)\n\n#### Dependency Updates:\n\n* [uws@0.14.5](https://www.npmjs.com/package/uws)\n* [mime@1.3.6](https://www.npmjs.com/package/mime)\n* [mongodb@2.2.26](https://www.npmjs.com/package/mongodb)\n* [pg-promise@5.7.0](https://www.npmjs.com/package/pg-promise)\n* [semver@5.3.0](https://www.npmjs.com/package/semver)\n\n##### Development dependencies\n* [babel-cli@6.24.1](https://www.npmjs.com/package/babel-cli)\n* [babel-core@6.24.1](https://www.npmjs.com/package/babel-core)\n* [babel-preset-es2015@6.24.1](https://www.npmjs.com/package/babel-preset-es2015)\n* [babel-preset-stage-0@6.24.1](https://www.npmjs.com/package/babel-preset-stage-0)\n* [babel-register@6.24.1](https://www.npmjs.com/package/babel-register)\n* [cross-env@5.0.0](https://www.npmjs.com/package/cross-env)\n* [deep-diff@0.3.8](https://www.npmjs.com/package/deep-diff)\n* [gaze@1.1.2](https://www.npmjs.com/package/gaze)\n* [jasmine@2.6.0](https://www.npmjs.com/package/jasmine)\n* [jasmine-spec-reporter@4.1.0](https://www.npmjs.com/package/jasmine-spec-reporter)\n* [mongodb-runner@3.5.0](https://www.npmjs.com/package/mongodb-runner)\n* [nyc@10.3.2](https://www.npmjs.com/package/nyc)\n* [request-promise@4.2.1](https://www.npmjs.com/package/request-promise)\n\n\n### 2.3.8\n[Full Changelog](https://github.com/ParsePlatform/parse-server/compare/2.3.7...2.3.8)\n\n#### New Features\n* Support for PG-Promise options, thanks to [ren dong](https://github.com/rendongsc)\n\n#### Improvements\n* Improves support for graceful shutdown, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Improves configuration validation for Twitter Authentication, thanks to [Benjamin Wilson Friedman](https://github.com/montymxb)\n\n#### Bug Fixes\n* Fixes issue affecting GeoPoint __type with Postgres, thanks to [zhoul-HS](https://github.com/zhoul-HS)\n* Prevent user creation if username or password is empty, thanks to [Wissam Abirached](https://github.com/wabirached)\n\n#### Dependency Updates:\n* [cross-env@4.0.0 ](https://www.npmjs.com/package/cross-env)\n* [ws@2.2.3](https://www.npmjs.com/package/ws)\n* [babel-core@6.24.0](https://www.npmjs.com/package/babel-core)\n* [uws@0.14.0](https://www.npmjs.com/package/uws)\n* [babel-preset-es2015@6.24.0](https://www.npmjs.com/package/babel-preset-es2015)\n* [babel-plugin-syntax-flow@6.18.0](https://www.npmjs.com/package/babel-plugin-syntax-flow)\n* [babel-cli@6.24.0](https://www.npmjs.com/package/babel-cli)\n* [babel-register@6.24.0](https://www.npmjs.com/package/babel-register)\n* [winston-daily-rotate-file@1.4.6](https://www.npmjs.com/package/winston-daily-rotate-file)\n* [mongodb@2.2.25](https://www.npmjs.com/package/mongodb)\n* [redis@2.7.0](https://www.npmjs.com/package/redis)\n* [pg-promise@5.6.4](https://www.npmjs.com/package/pg-promise)\n* [parse-server-push-adapter@1.3.0](https://www.npmjs.com/package/parse-server-push-adapter)\n\n### 2.3.7\n[Full Changelog](https://github.com/ParsePlatform/parse-server/compare/2.3.6...2.3.7)\n\n#### New Features\n* New endpoint to resend verification email, thanks to [Xy Ziemba](https://github.com/xyziemba)\n\n#### Improvements\n* Add TTL option for Redis Cache Adapter, thanks to [Ryan Foster](https://github.com/f0ster)\n* Update Postgres Storage Adapter, thanks to [Vitaly Tomilov](https://github.com/vitaly-t)\n\n#### Bug Fixes\n* Add index on Role.name, fixes (#3579), thanks to [Natan Rolnik](https://github.com/natanrolnik)\n* Fix default value of userSensitiveFields, fixes (#3593), thanks to [Arthur Cinader](https://github.com/acinader)\n\n#### Dependency Updates:\n* [body-parser@1.17.1](https://www.npmjs.com/package/body-parser)\n* [express@4.15.2](https://www.npmjs.com/package/express)\n* [request@2.81.0](https://www.npmjs.com/package/request)\n* [winston-daily-rotate-file@1.4.5](https://www.npmjs.com/package/winston-daily-rotate-file)\n* [ws@2.2.0](https://www.npmjs.com/package/ws)\n\n\n### 2.3.6\n[Full Changelog](https://github.com/ParsePlatform/parse-server/compare/2.3.5...2.3.6)\n\n#### Improvements\n* Adds support for injecting a middleware for instumentation in the CLI, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Alleviate mongodb bug with $or queries [SERVER-13732](https://jira.mongodb.org/browse/SERVER-13732), thanks to [Jack Wearden](https://github.com/NotBobTheBuilder)\n\n#### Bug Fixes\n* Fix issue affecting password policy and empty passwords, thanks to [Bhaskar Reddy Yasa](https://github.com/bhaskaryasa)\n* Fix issue when logging url in non string objects, thanks to [Paulo V\u00edtor S Reis](https://github.com/paulovitin)\n\n#### Dependencies updates:\n* [ws@2.1.0](https://npmjs.com/package/ws)\n* [uws@0.13.0](https://npmjs.com/package/uws)\n* [pg-promise@5.6.2](https://npmjs.com/package/pg-promise)\n\n\n### 2.3.5\n[Full Changelog](https://github.com/ParsePlatform/parse-server/compare/2.3.3...2.3.5)\n\n#### Bug Fixes\n* Allow empty client key\n(#3497), thanks to [Arthur Cinader](https://github.com/acinader)\n* Fix LiveQuery unsafe user\n(#3525), thanks to [David Starke](https://github.com/dstarke)\n* Use `flushdb` instead of `flushall` in RedisCacheAdapter\n(#3523), thanks to [Jeremy Louie](https://github.com/JeremyPlease)\n* Fix saving GeoPoints and Files in `_GlobalConfig` (Make sure we don't treat\ndot notation keys as topLevel atoms)\n(#3531), thanks to [Florent Vilmart](https://github.com/flovilmart)\n\n### 2.3.3\n[Full Changelog](https://github.com/ParsePlatform/parse-server/compare/2.3.2...2.3.3)\n\n#### Breaking Changes\n* **Minimum Node engine bumped to 4.6** (#3480), thanks to [Florent Vilmart](https://github.com/flovilmart)\n\n#### Bug Fixes\n* Add logging on failure to create file (#3424), thanks to [Arthur Cinader](https://github.com/acinader)\n* Log Parse Errors so they are intelligible (#3431), thanks to [Arthur Cinader](https://github.com/acinader)\n* MongoDB $or Queries avoid SERVER-13732 bug (#3476), thanks to [Jack Wearden](https://github.com/NotBobTheBuilder)\n* Mongo object to Parse object date serialization - avoid re-serialization of iso of type Date (#3389), thanks to [nodechefMatt](https://github.com/nodechefMatt)\n\n#### Improvements\n* Ground preparations for push scalability (#3080), thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Use uWS as optional dependency for ws server (#3231), thanks to [Florent Vilmart](https://github.com/flovilmart)\n\n### 2.3.2\n[Full Changelog](https://github.com/ParsePlatform/parse-server/compare/2.3.1...2.3.2)\n\n#### New features\n* Add parseFrameURL for masking user-facing pages (#3267), thanks to  [Lenart Rudel](https://github.com/lenart)\n\n#### Bug fixes\n* Fix Parse-Server to work with winston-daily-rotate-1.4.2 (#3335), thanks to [Arthur Cinader](https://github.com/acinader)\n\n#### Improvements\n* Add support for regex string for password policy validatorPattern setting (#3331), thanks to [Bhaskar Reddy Yasa](https://github.com/bhaskaryasa)\n* LiveQuery should match subobjects with dot notation (#3322), thanks to [David Starke](https://github.com/dstarke)\n* Reduce time to process high number of installations for push (#3264), thanks to [jeacott1](https://github.com/jeacott1)\n* Fix trivial typo in error message (#3238), thanks to [Arthur Cinader](https://github.com/acinader)\n\n### 2.3.1\n[Full Changelog](https://github.com/ParsePlatform/parse-server/compare/2.3.0...2.3.1)\n\nA major issue was introduced when refactoring the authentication modules.\nThis release addresses only that issue.\n\n### 2.3.0\n[Full Changelog](https://github.com/ParsePlatform/parse-server/compare/2.2.25...2.3.0)\n\n#### Breaking changes\n* Parse.Cloud.useMasterKey() is a no-op, please refer to (Cloud Code migration guide)[https://github.com/ParsePlatform/parse-server/wiki/Compatibility-with-Hosted-Parse#cloud-code]\n* Authentication helpers are now proper adapters, deprecates oauth option in favor of auth.\n* DEPRECATES: facebookAppIds, use `auth: { facebook: { appIds: [\"AAAAAAAAA\" ] } }`\n* `email` field is not returned anymore for `Parse.User` queries. (Provided only on the user itself if provided).\n\n#### New Features\n* Adds ability to restrict access through Class Level Permissions to only authenticated users [see docs](http://parseplatform.github.io/docs/ios/guide/#requires-authentication-permission-requires-parse-server---230)\n* Adds ability to strip sensitive data from `_User` responses, strips emails by default, thanks to [Arthur Cinader](https://github.com/acinader)\n* Adds password history support for password policies, thanks to [Bhaskar Reddy Yasa](https://github.com/bhaskaryasa)\n\n#### Improvements\n* Bump parse-server-s3-adapter to 1.0.6, thanks to [Arthur Cinader](https://github.com/acinader)\n* Using PARSE_SERVER_ENABLE_EXPERIMENTAL_DIRECT_ACCESS let you create user sessions when passing {installationId: \"xxx-xxx\"} on signup in cloud code, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Add CLI option to pass `host` parameter when creating parse-server from CLI, thanks to [Kulshekhar Kabra](https://github.com/kulshekhar)\n\n#### Bug fixes\n* Ensure batch routes are only using posix paths, thanks to [Steven Shipton](https://github.com/steven-supersolid)\n* Ensure falsy options from CLI are properly taken into account, thanks to [Steven Shipton](https://github.com/steven-supersolid)\n* Fixes issues affecting calls to `matchesKeyInQuery` with pointers.\n* Ensure that `select` keys can be changed in triggers (beforeFind...), thanks to [Arthur Cinader](https://github.com/acinader)\n\n#### Housekeeping\n* Enables and enforces linting with eslint, thanks to [Arthur Cinader](https://github.com/acinader)\n\n### 2.2.25\n\nPostgres support requires v9.5\n\n#### New Features\n* Dockerizing Parse Server, thanks to [Kirill Kravinsky](https://github.com/woyorus)\n* Login with qq, wechat, weibo, thanks to [haifeizhang]()\n* Password policy, validation and expiration, thanks to [Bhaskar Reddy Yasa](https://github.com/bhaskaryasa)\n* Health check on /health, thanks to [Kirill Kravinsky](https://github.com/woyorus)\n* Reuse SchemaCache across requests option, thanks to [Steven Shipton](https://github.com/steven-supersolid)\n\n#### Improvements\n* Better support for CLI options, thanks to [Steven Shipton](https://github.com/steven-supersolid)\n* Specity a database timeout with maxTimeMS, thanks to [Tyler Brock](https://github.com/TylerBrock)\n* Adds the username to reset password success pages, thanks to [Halim Qarroum](https://github.com/HQarroum)\n* Better support for Redis cache adapter, thanks to [Tyler Brock](https://github.com/TylerBrock)\n* Better coverage of Postgres, thanks to [Kulshekhar Kabra](https://github.com/kulshekhar)\n\n#### Bug Fixes\n* Fixes issue when sending push to multiple installations, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Fixes issues with twitter authentication, thanks to [jonas-db](https://github.com/jonas-db)\n* Ignore createdAt fields update, thanks to [Yuki Takeichi](https://github.com/yuki-takeichi)\n* Improve support for array equality with LiveQuery, thanks to [David Poetzsch-Heffter](https://github.com/dpoetzsch)\n* Improve support for batch endpoint when serverURL and publicServerURL have different paths, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Support saving relation objects, thanks to [Yuki Takeichi](https://github.com/yuki-takeichi)\n\n### 2.2.24\n\n#### New Features\n* LiveQuery: Bring your own adapter (#2902), thanks to [Florent Vilmart](https://github.com/flovilmart)\n* LiveQuery: Adds \"update\" operator to update a query subscription (#2935), thanks to [Florent Vilmart](https://github.com/flovilmart)\n\n#### Improvements\n* Better Postgres support, thanks to [Kulshekhar Kabra](https://github.com/kulshekhar)\n* Logs the function name when failing (#2963), thanks to [Michael Helvey](https://github.com/michaelhelvey)\n* CLI: forces closing the connections with SIGINT/SIGTERM (#2964), thanks to [Kulshekhar Kabra](https://github.com/kulshekhar)\n* Reduce the number of calls to the `_SCHEMA` table (#2912), thanks to [Steven Shipton](https://github.com/steven-supersolid)\n* LiveQuery: Support for Role ACL's, thanks to [Aaron Blondeau](https://github.com/aaron-blondeau-dose)\n\n#### Bug Fixes\n* Better support for checking application and client keys, thanks to [Steven Shipton](https://github.com/steven-supersolid)\n* Google OAuth, better support for android and web logins, thanks to [Florent Vilmart](https://github.com/flovilmart)\n\n### 2.2.23\n\n* Run liveQuery server from CLI with a different port, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Support for Postgres databaseURI, thanks to [Kulshekhar Kabra](https://github.com/kulshekhar)\n* Support for Postgres options, thanks to [Kulshekhar Kabra](https://github.com/kulshekhar)\n* Improved support for google login (id_token and access_token), thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Improvements with VKontakte login, thanks to [Eugene Antropov](https://github.com/antigp)\n* Improved support for `select` and `include`, thanks to [Florent Vilmart](https://github.com/flovilmart)\n\n#### Bug fixes\n\n* Fix error when updating installation with useMasterKey (#2888), thanks to [Jeremy Louie](https://github.com/JeremyPlease)\n* Fix bug affecting usage of multiple `notEqualTo`, thanks to [Jeremy Louie](https://github.com/JeremyPlease)\n* Improved support for null values in arrays, thanks to [Florent Vilmart](https://github.com/flovilmart)\n\n### 2.2.22\n\n* Minimum nodejs engine is now 4.5\n\n#### New Features\n* New: CLI for parse-live-query-server, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* New: Start parse-live-query-server for parse-server CLI, thanks to [Florent Vilmart](https://github.com/flovilmart)\n\n#### Bug fixes\n* Fix: Include with pointers are not conflicting with get CLP anymore, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Fix: Removes dependency on babel-polyfill, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Fix: Support nested select calls, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Fix: Use native column selection instead of runtime, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Fix: installationId header is properly used when updating `_Installation` objects, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Fix: don't crash parse-server on improperly formatted live-query messages, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Fix: Passwords are properly stripped out of logs, thanks to [Arthur Cinader](https://github.com/acinader)\n* Fix: Lookup for email in username if email is not set, thanks to [Florent Vilmart](https://github.com/flovilmart)\n\n### 2.2.21\n\n* Fix: Reverts removal of babel-polyfill\n\n### 2.2.20\n\n* New: Adds CloudCode handler for `beforeFind`, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* New: RedisCacheAdapter for syncing schema, role and user caches across servers, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* New: Latest master build available at `ParsePlatform/parse-server#latest`, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Fix: Better support for upgradeToRevocableSession with missing session token, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Fix: Removes babel-polyfill runtime dependency, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Fix: Cluster option now support a boolean value for automatically choosing the right number of processes, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Fix: Filenames now appear correctly, thanks to [Lama Chandrasena](https://github.com/lama-buddy)\n* Fix: `_acl` is properly updated, thanks to [Steven Shipton](https://github.com/steven-supersolid)\n\nOther fixes by [Mathias Rangel Wulff](https://github.com/mathiasrw)\n\n### 2.2.19\n\n* New: support for upgrading to revocable sessions, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* New: NullCacheAdapter for disabling caching, thanks to [Yuki Takeichi](https://github.com/yuki-takeichi)\n* New: Account lockout policy [#2601](https://github.com/ParsePlatform/parse-server/pull/2601), thanks to [Diwakar Cherukumilli](https://github.com/cherukumilli)\n* New: Jobs endpoint for defining and run jobs (no scheduling), thanks to [Florent Vilmart](https://github.com/flovilmart)\n* New: Add --cluster option to the CLI, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* New: Support for login with vk.com, thanks to [Nurdaulet Bolatov](https://github.com/nbolatov)\n* New: experimental support for postgres databases, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Fix: parse-server doesn't call next() after successful responses, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Fix: Nested objects are properly includeed with Pointer Permissions on, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Fix: null values in include calls are properly handled, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Fix: Schema validations now runs after beforeSave hooks, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Fix: usersname and passwords are properly type checked, thanks to [Bam Wang](https://github.com/bamwang)\n* Fix: logging in info log would log also in error log, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Fix: removes extaneous logging from ParseLiveQueryServer, thanks to [Flavio Torres](https://github.com/flavionegrao)\n* Fix: support for Range requests for files, thanks to [Brage G. Staven](https://github.com/Bragegs)\n\n### 2.2.18\n\n* Fix: Improve support for objects in push alert, thanks to [Antoine Lenoir](https://github.com/alenoir)\n* Fix; Prevent pointed from getting clobbered when they are changed in a beforeSave, thanks to [sud](https://github.com/sud80)\n* Fix: Improve support for \"Bytes\" type, thanks to [CongHoang](https://github.com/conghoang)\n* Fix: Better logging compatability with Parse.com, thanks to [Arthur Cinader](https://github.com/acinader)\n* New: Add Janrain Capture and Janrain Engage auth provider, thanks to [Andrew Lane](https://github.com/AndrewLane)\n* Improved: Include content length header in files response, thanks to [Steven Van Bael](https://github.com/vbsteven)\n* Improved: Support byte range header for files, thanks to [Brage G. Staven](https://github.com/Bragegs)\n* Improved: Validations for LinkedIn access_tokens, thanks to [Felix Dumit](https://github.com/felix-dumit)\n* Improved: Experimental postgres support, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Perf: Use native bcrypt implementation if available, thanks to [Florent Vilmart](https://github.com/flovilmart)\n\n\n### 2.2.17\n[Full Changelog](https://github.com/ParsePlatform/parse-server/compare/2.2.16...2.2.17)\n\n* Cloud code logs [\\#2370](https://github.com/ParsePlatform/parse-server/pull/2370) ([flovilmart](https://github.com/flovilmart))\n* Make sure \\_PushStatus operations are run in order [\\#2367](https://github.com/ParsePlatform/parse-server/pull/2367) ([flovilmart](https://github.com/flovilmart))\n* Typo fix for error message when can't ensure uniqueness of user email addresses [\\#2360](https://github.com/ParsePlatform/parse-server/pull/2360) ([AndrewLane](https://github.com/AndrewLane))\n* LiveQuery constrains matching fix [\\#2357](https://github.com/ParsePlatform/parse-server/pull/2357) ([simonas-notcat](https://github.com/simonas-notcat))\n* Fix typo in logging for commander parseConfigFile [\\#2352](https://github.com/ParsePlatform/parse-server/pull/2352) ([AndrewLane](https://github.com/AndrewLane))\n* Fix minor typos in test names [\\#2351](https://github.com/ParsePlatform/parse-server/pull/2351) ([acinader](https://github.com/acinader))\n* Makes sure we don't strip authData or session token from users using masterKey [\\#2348](https://github.com/ParsePlatform/parse-server/pull/2348) ([flovilmart](https://github.com/flovilmart))\n* Run coverage with istanbul [\\#2340](https://github.com/ParsePlatform/parse-server/pull/2340) ([flovilmart](https://github.com/flovilmart))\n* Run next\\(\\) after successfully sending data to the client [\\#2338](https://github.com/ParsePlatform/parse-server/pull/2338) ([blacha](https://github.com/blacha))\n* Cache all the mongodb/version folder [\\#2336](https://github.com/ParsePlatform/parse-server/pull/2336) ([flovilmart](https://github.com/flovilmart))\n* updates usage of setting: emailVerifyTokenValidityDuration [\\#2331](https://github.com/ParsePlatform/parse-server/pull/2331) ([cherukumilli](https://github.com/cherukumilli))\n* Update Mongodb client to 2.2.4 [\\#2329](https://github.com/ParsePlatform/parse-server/pull/2329) ([flovilmart](https://github.com/flovilmart))\n* Allow usage of analytics adapter [\\#2327](https://github.com/ParsePlatform/parse-server/pull/2327) ([deashay](https://github.com/deashay))\n* Fix flaky tests [\\#2324](https://github.com/ParsePlatform/parse-server/pull/2324) ([flovilmart](https://github.com/flovilmart))\n* don't serve null authData values [\\#2320](https://github.com/ParsePlatform/parse-server/pull/2320) ([yuzeh](https://github.com/yuzeh))\n* Fix null relation problem [\\#2319](https://github.com/ParsePlatform/parse-server/pull/2319) ([flovilmart](https://github.com/flovilmart))\n* Clear the connectionPromise upon close or error [\\#2314](https://github.com/ParsePlatform/parse-server/pull/2314) ([flovilmart](https://github.com/flovilmart))\n* Report validation errors with correct error code [\\#2299](https://github.com/ParsePlatform/parse-server/pull/2299) ([flovilmart](https://github.com/flovilmart))\n* Parses correctly Parse.Files and Dates when sent to Cloud Code Functions [\\#2297](https://github.com/ParsePlatform/parse-server/pull/2297) ([flovilmart](https://github.com/flovilmart))\n* Adding proper generic Not Implemented. [\\#2292](https://github.com/ParsePlatform/parse-server/pull/2292) ([vitaly-t](https://github.com/vitaly-t))\n* Adds schema caching capabilities \\(5s by default\\) [\\#2286](https://github.com/ParsePlatform/parse-server/pull/2286) ([flovilmart](https://github.com/flovilmart))\n* add digits oauth provider [\\#2284](https://github.com/ParsePlatform/parse-server/pull/2284) ([ranhsd](https://github.com/ranhsd))\n* Improve installations query [\\#2281](https://github.com/ParsePlatform/parse-server/pull/2281) ([flovilmart](https://github.com/flovilmart))\n* Adding request headers to cloud functions fixes \\#1461 [\\#2274](https://github.com/ParsePlatform/parse-server/pull/2274) ([blacha](https://github.com/blacha))\n* Creates a new sessionToken when updating password [\\#2266](https://github.com/ParsePlatform/parse-server/pull/2266) ([flovilmart](https://github.com/flovilmart))\n* Add Gitter chat link to the README. [\\#2264](https://github.com/ParsePlatform/parse-server/pull/2264) ([nlutsenko](https://github.com/nlutsenko))\n* Restores ability to include non pointer keys [\\#2263](https://github.com/ParsePlatform/parse-server/pull/2263) ([flovilmart](https://github.com/flovilmart))\n* Allow next middleware handle error in handleParseErrors [\\#2260](https://github.com/ParsePlatform/parse-server/pull/2260) ([mejcz](https://github.com/mejcz))\n* Exposes the ClientSDK infos if available [\\#2259](https://github.com/ParsePlatform/parse-server/pull/2259) ([flovilmart](https://github.com/flovilmart))\n* Adds support for multiple twitter auths options [\\#2256](https://github.com/ParsePlatform/parse-server/pull/2256) ([flovilmart](https://github.com/flovilmart))\n* validate\\_purchase fix for SANDBOX requests [\\#2253](https://github.com/ParsePlatform/parse-server/pull/2253) ([valeryvaskabovich](https://github.com/valeryvaskabovich))\n\n### 2.2.16\n\n* New: Expose InMemoryCacheAdapter publicly, thanks to [Steven Shipton](https://github.com/steven-supersolid)\n* New: Add ability to prevent login with unverified email, thanks to [Diwakar Cherukumilli](https://github.com/cherukumilli)\n* Improved: Better error message for incorrect type, thanks to [Andrew Lane](https://github.com/AndrewLane)\n* Improved: Better error message for permission denied, thanks to [Blayne Chard](https://github.com/blacha)\n* Improved: Update authData on login, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Improved: Ability to not check for old files on Parse.com, thanks to [OzgeAkin](https://github.com/OzgeAkin)\n* Fix: Issues with email adapter validation, thanks to [Tyler Brock](https://github.com/TylerBrock)\n* Fix: Issues with nested $or queries, thanks to [Florent Vilmart](https://github.com/flovilmart)\n\n### 2.2.15\n\n* Fix: Type in description for Parse.Error.INVALID_QUERY, thanks to [Andrew Lane](https://github.com/AndrewLane)\n* Improvement: Stop requiring verifyUserEmails for password reset functionality, thanks to [Tyler Brock](https://github.com/TylerBrock)\n* Improvement: Kill without validation, thanks to [Drew Gross](https://github.com/drew-gross)\n* Fix: Deleting a file does not delete from fs.files, thanks to [David Keita](https://github.com/maninga)\n* Fix: Postgres stoage adapter fix, thanks to [Vitaly Tomilov](https://github.com/vitaly-t)\n* Fix: Results invalid session when providing an invalid session token, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Fix: issue creating an anonymous user, thanks to [Hussam Moqhim](https://github.com/hmoqhim)\n* Fix: make http response serializable, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* New: Add postmark email adapter alternative [Glenn Reyes](https://github.com/glennreyes)\n\n### 2.2.14\n\n* Hotfix: Fix Parse.Cloud.HTTPResponse serialization\n\n### 2.2.13\n\n* Hotfix: Pin version of deepcopy\n\n### 2.2.12\n\n* New: Custom error codes in cloud code response.error, thanks to [Jeremy Pease](https://github.com/JeremyPlease)\n* Fix: Crash in beforeSave when response is not an object, thanks to [Tyler Brock](https://github.com/TylerBrock)\n* Fix: Allow \"get\" on installations\n* Fix: Fix overly restrictive Class Level Permissions, thanks to [Florent Vilmart](https://github.com/flovilmart)\n* Fix: Fix nested date parsing in Cloud Code, thanks to [Marco Cheung](https://github.com/Marco129)\n* Fix: Support very old file formats from Parse.com\n\n### 2.2.11\n\n* Security: Censor user password in logs, thanks to [Marco Cheung](https://github.com/Marco129)\n* New: Add PARSE_SERVER_LOGS_FOLDER env var for setting log folder, thanks to [KartikeyaRokde](https://github.com/KartikeyaRokde)\n* New: Webhook key support, thanks to [Tyler Brock](https://github.com/TylerBrock)\n* Perf: Add cache adapter and default caching of certain objects, thanks to [Blayne Chard](https://github.com/blacha)\n* Improvement: Better error messages for schema type mismatches, thanks to [Jeremy Pease](https://github.com/JeremyPlease)\n* Improvement: Better error messages for reset password emails\n* Improvement: Webhook key support in CLI, thanks to [Tyler Brock](https://github.com/TylerBrock)\n* Fix: Remove read only fields when using beforeSave, thanks to [Tyler Brock](https://github.com/TylerBrock)\n* Fix: Use content type provided by JS SDK, thanks to [Blayne Chard](https://github.com/blacha) and [Florent Vilmart](https://github.com/flovilmart)\n* Fix: Tell the dashboard the stored push data is available, thanks to [Jeremy Pease](https://github.com/JeremyPlease)\n* Fix: Add support for HTTP Basic Auth, thanks to [Hussam Moqhim](https://github.com/hmoqhim)\n* Fix: Support for MongoDB version 3.2.6, (note: do not use MongoDB 3.2 with migrated apps that still have traffic on Parse.com), thanks to [Tyler Brock](https://github.com/TylerBrock)\n* Fix: Prevent `pm2` from crashing when push notifications fail, thanks to [benishak](https://github.com/benishak)\n* Fix: Add full list of default _Installation fields, thanks to [Jeremy Pease](https://github.com/JeremyPlease)\n* Fix: Strip objectId out of hooks responses, thanks to [Tyler Brock](https://github.com/TylerBrock)\n* Fix: Fix external webhook response format, thanks to [Tyler Brock](https://github.com/TylerBrock)\n* Fix: Fix beforeSave when object is passed to `success`, thanks to [Madhav Bhagat](https://github.com/codebreach)\n* Fix: Remove use of deprecated APIs, thanks to [Emad Ehsan](https://github.com/emadehsan)\n* Fix: Crash when multiple Parse Servers on the same machine try to write to the same logs folder, thanks to [Steven Shipton](https://github.com/steven-supersolid)\n* Fix: Various issues with key names in `Parse.Object`s\n* Fix: Treat Bytes type properly\n* Fix: Caching bugs that caused writes by masterKey or other session token to not show up to users reading with a different session token\n* Fix: Pin mongo driver version, preventing a regression in version 2.1.19\n* Fix: Various issues with pointer fields not being treated properly\n* Fix: Issues with pointed getting un-fetched due to changes in beforeSave\n* Fix: Fixed crash when deleting classes that have CLPs\n\n### 2.2.10\n\n* Fix: Write legacy ACLs to Mongo so that clients that still go through Parse.com can read them, thanks to [Tyler Brock](https://github.com/TylerBrock) and [carmenlau](https://github.com/carmenlau)\n* Fix: Querying installations with limit = 0 and count = 1 now works, thanks to [ssk7833](https://github.com/ssk7833)\n* Fix: Return correct error when violating unique index, thanks to [Marco Cheung](https://github.com/Marco129)\n* Fix: Allow unsetting user's email, thanks to [Marco Cheung](https://github.com/Marco129)\n* New: Support for Node 6.1\n\n### 2.2.9\n\n* Fix: Fix a regression that caused Parse Server to crash when a null parameter is passed to a Cloud function\n\n### 2.2.8\n\n* New: Support for Pointer Permissions\n* New: Expose logger in Cloud Code\n* New: Option to revoke sessions on password reset\n* New: Option to expire inactive sessions\n* Perf: Improvements in ACL checking query\n* Fix: Issues when sending pushes to list of devices that contains invalid values\n* Fix: Issues caused by using babel-polyfill outside of Parse Server, but in the same express app\n* Fix: Remove creation of extra session tokens\n* Fix: Return authData when querying with master key\n* Fix: Bugs when deleting webhooks\n* Fix: Ignore _RevocableSession header, which might be sent by the JS SDK\n* Fix: Issues with querying via URL params\n* Fix: Properly encode \"Date\" parameters to cloud code functions\n\n\n### 2.2.7\n\n* Adds support for --verbose and verbose option when running ParseServer [\\#1414](https://github.com/ParsePlatform/parse-server/pull/1414) ([flovilmart](https://github.com/flovilmart))\n* Adds limit = 0 as a valid parameter for queries [\\#1493](https://github.com/ParsePlatform/parse-server/pull/1493) ([seijiakiyama](https://github.com/seijiakiyama))\n* Makes sure we preserve Installations when updating a token  \\(\\#1475\\) [\\#1486](https://github.com/ParsePlatform/parse-server/pull/1486) ([flovilmart](https://github.com/flovilmart))\n* Hotfix for tests [\\#1503](https://github.com/ParsePlatform/parse-server/pull/1503) ([flovilmart](https://github.com/flovilmart))\n* Enable logs [\\#1502](https://github.com/ParsePlatform/parse-server/pull/1502) ([drew-gross](https://github.com/drew-gross))\n* Do some triple equals for great justice [\\#1499](https://github.com/ParsePlatform/parse-server/pull/1499) ([TylerBrock](https://github.com/TylerBrock))\n* Apply credential stripping to all untransforms for \\_User [\\#1498](https://github.com/ParsePlatform/parse-server/pull/1498) ([TylerBrock](https://github.com/TylerBrock))\n* Checking if object has defined key for Pointer constraints in liveQuery [\\#1487](https://github.com/ParsePlatform/parse-server/pull/1487) ([simonas-notcat](https://github.com/simonas-notcat))\n* Remove collection prefix and default mongo URI [\\#1479](https://github.com/ParsePlatform/parse-server/pull/1479) ([drew-gross](https://github.com/drew-gross))\n* Store collection prefix in mongo adapter, and clean up adapter interface [\\#1472](https://github.com/ParsePlatform/parse-server/pull/1472) ([drew-gross](https://github.com/drew-gross))\n* Move field deletion logic into mongo adapter [\\#1471](https://github.com/ParsePlatform/parse-server/pull/1471) ([drew-gross](https://github.com/drew-gross))\n* Adds support for Long and Double mongodb types \\(fixes \\#1316\\) [\\#1470](https://github.com/ParsePlatform/parse-server/pull/1470) ([flovilmart](https://github.com/flovilmart))\n* Schema.js database agnostic [\\#1468](https://github.com/ParsePlatform/parse-server/pull/1468) ([flovilmart](https://github.com/flovilmart))\n* Remove console.log [\\#1465](https://github.com/ParsePlatform/parse-server/pull/1465) ([drew-gross](https://github.com/drew-gross))\n* Push status nits [\\#1462](https://github.com/ParsePlatform/parse-server/pull/1462) ([flovilmart](https://github.com/flovilmart))\n* Fixes \\#1444 [\\#1451](https://github.com/ParsePlatform/parse-server/pull/1451) ([flovilmart](https://github.com/flovilmart))\n* Removing sessionToken and authData from \\_User objects included in a query [\\#1450](https://github.com/ParsePlatform/parse-server/pull/1450) ([simonas-notcat](https://github.com/simonas-notcat))\n* Move mongo field type logic into mongoadapter [\\#1432](https://github.com/ParsePlatform/parse-server/pull/1432) ([drew-gross](https://github.com/drew-gross))\n* Prevents \\_User lock out when setting ACL on signup or afterwards [\\#1429](https://github.com/ParsePlatform/parse-server/pull/1429) ([flovilmart](https://github.com/flovilmart))\n* Update .travis.yml [\\#1428](https://github.com/ParsePlatform/parse-server/pull/1428) ([flovilmart](https://github.com/flovilmart))\n* Adds relation fields to objects [\\#1424](https://github.com/ParsePlatform/parse-server/pull/1424) ([flovilmart](https://github.com/flovilmart))\n* Update .travis.yml [\\#1423](https://github.com/ParsePlatform/parse-server/pull/1423) ([flovilmart](https://github.com/flovilmart))\n* Sets the defaultSchemas keys in the SchemaCollection [\\#1421](https://github.com/ParsePlatform/parse-server/pull/1421) ([flovilmart](https://github.com/flovilmart))\n* Fixes \\#1417 [\\#1420](https://github.com/ParsePlatform/parse-server/pull/1420) ([drew-gross](https://github.com/drew-gross))\n* Untransform should treat Array's as nested objects [\\#1416](https://github.com/ParsePlatform/parse-server/pull/1416) ([blacha](https://github.com/blacha))\n* Adds X-Parse-Push-Status-Id header [\\#1412](https://github.com/ParsePlatform/parse-server/pull/1412) ([flovilmart](https://github.com/flovilmart))\n* Schema format cleanup [\\#1407](https://github.com/ParsePlatform/parse-server/pull/1407) ([drew-gross](https://github.com/drew-gross))\n* Updates the publicServerURL option [\\#1397](https://github.com/ParsePlatform/parse-server/pull/1397) ([flovilmart](https://github.com/flovilmart))\n* Fix exception with non-expiring session tokens. [\\#1386](https://github.com/ParsePlatform/parse-server/pull/1386) ([0x18B2EE](https://github.com/0x18B2EE))\n* Move mongo schema format related logic into mongo adapter [\\#1385](https://github.com/ParsePlatform/parse-server/pull/1385) ([drew-gross](https://github.com/drew-gross))\n* WIP: Huge performance improvement on roles queries [\\#1383](https://github.com/ParsePlatform/parse-server/pull/1383) ([flovilmart](https://github.com/flovilmart))\n* Removes GCS Adapter from provided adapters [\\#1339](https://github.com/ParsePlatform/parse-server/pull/1339) ([flovilmart](https://github.com/flovilmart))\n* DBController refactoring [\\#1228](https://github.com/ParsePlatform/parse-server/pull/1228) ([flovilmart](https://github.com/flovilmart))\n* Spotify authentication [\\#1226](https://github.com/ParsePlatform/parse-server/pull/1226) ([1nput0utput](https://github.com/1nput0utput))\n* Expose DatabaseAdapter to simplify application tests [\\#1121](https://github.com/ParsePlatform/parse-server/pull/1121) ([steven-supersolid](https://github.com/steven-supersolid))\n\n### 2.2.6\n\n* Important Fix: Disables find on installation from clients [\\#1374](https://github.com/ParsePlatform/parse-server/pull/1374) ([flovilmart](https://github.com/flovilmart))\n* Adds missing options to the CLI [\\#1368](https://github.com/ParsePlatform/parse-server/pull/1368) ([flovilmart](https://github.com/flovilmart))\n* Removes only master on travis [\\#1367](https://github.com/ParsePlatform/parse-server/pull/1367) ([flovilmart](https://github.com/flovilmart))\n* Auth.\\_loadRoles should not query the same role twice. [\\#1366](https://github.com/ParsePlatform/parse-server/pull/1366) ([blacha](https://github.com/blacha))\n\n### 2.2.5\n\n* Improves config loading and tests [\\#1363](https://github.com/ParsePlatform/parse-server/pull/1363) ([flovilmart](https://github.com/flovilmart))\n* Adds travis configuration to deploy NPM on new version tags [\\#1361](https://github.com/ParsePlatform/parse-server/pull/1361) ([gfosco](https://github.com/gfosco))\n* Inject the default schemas properties when loading it [\\#1357](https://github.com/ParsePlatform/parse-server/pull/1357) ([flovilmart](https://github.com/flovilmart))\n* Adds console transport when testing with VERBOSE=1 [\\#1351](https://github.com/ParsePlatform/parse-server/pull/1351) ([flovilmart](https://github.com/flovilmart))\n* Make notEqual work on relations  [\\#1350](https://github.com/ParsePlatform/parse-server/pull/1350) ([flovilmart](https://github.com/flovilmart))\n* Accept only bool for $exists in LiveQuery [\\#1315](https://github.com/ParsePlatform/parse-server/pull/1315) ([drew-gross](https://github.com/drew-gross))\n* Adds more options when using CLI/config [\\#1305](https://github.com/ParsePlatform/parse-server/pull/1305) ([flovilmart](https://github.com/flovilmart))\n* Update error message [\\#1297](https://github.com/ParsePlatform/parse-server/pull/1297) ([drew-gross](https://github.com/drew-gross))\n* Properly let masterKey add fields [\\#1291](https://github.com/ParsePlatform/parse-server/pull/1291) ([flovilmart](https://github.com/flovilmart))\n* Point to \\#1271 as how to write a good issue report [\\#1290](https://github.com/ParsePlatform/parse-server/pull/1290) ([drew-gross](https://github.com/drew-gross))\n* Adds ability to override mount with publicServerURL for production uses [\\#1287](https://github.com/ParsePlatform/parse-server/pull/1287) ([flovilmart](https://github.com/flovilmart))\n* Single object queries to use include and keys [\\#1280](https://github.com/ParsePlatform/parse-server/pull/1280) ([jeremyjackson89](https://github.com/jeremyjackson89))\n* Improves report for Push error in logs and \\_PushStatus [\\#1269](https://github.com/ParsePlatform/parse-server/pull/1269) ([flovilmart](https://github.com/flovilmart))\n* Removes all stdout/err logs while testing [\\#1268](https://github.com/ParsePlatform/parse-server/pull/1268) ([flovilmart](https://github.com/flovilmart))\n* Matching queries with doesNotExist constraint [\\#1250](https://github.com/ParsePlatform/parse-server/pull/1250) ([andrecardoso](https://github.com/andrecardoso))\n* Added session length option for session tokens to server configuration [\\#997](https://github.com/ParsePlatform/parse-server/pull/997) ([Kenishi](https://github.com/Kenishi))\n* Regression test for \\#1259 [\\#1286](https://github.com/ParsePlatform/parse-server/pull/1286) ([drew-gross](https://github.com/drew-gross))\n* Regression test for \\#871 [\\#1283](https://github.com/ParsePlatform/parse-server/pull/1283) ([drew-gross](https://github.com/drew-gross))\n* Add a test to repro \\#701 [\\#1281](https://github.com/ParsePlatform/parse-server/pull/1281) ([drew-gross](https://github.com/drew-gross))\n* Fix for \\#1334: using relative cloud code files broken  [\\#1353](https://github.com/ParsePlatform/parse-server/pull/1353) ([airdrummingfool](https://github.com/airdrummingfool))\n* Fix Issue/1288 [\\#1346](https://github.com/ParsePlatform/parse-server/pull/1346) ([flovilmart](https://github.com/flovilmart))\n* Fixes \\#1271 [\\#1295](https://github.com/ParsePlatform/parse-server/pull/1295) ([drew-gross](https://github.com/drew-gross))\n* Fixes issue \\#1302 [\\#1314](https://github.com/ParsePlatform/parse-server/pull/1314) ([flovilmart](https://github.com/flovilmart))\n* Fixes bug related to include in queries [\\#1312](https://github.com/ParsePlatform/parse-server/pull/1312) ([flovilmart](https://github.com/flovilmart))\n\n\n### 2.2.4\n\n* Hotfix: fixed imports issue for S3Adapter, GCSAdapter, FileSystemAdapter [\\#1263](https://github.com/ParsePlatform/parse-server/pull/1263) ([drew-gross](https://github.com/drew-gross)\n* Fix: Clean null authData values on _User update [\\#1199](https://github.com/ParsePlatform/parse-server/pull/1199) ([yuzeh](https://github.com/yuzeh))\n\n### 2.2.3\n\n* Fixed bug with invalid email verification link on email update. [\\#1253](https://github.com/ParsePlatform/parse-server/pull/1253) ([kzielonka](https://github.com/kzielonka))\n* Badge update supports increment as well as Increment [\\#1248](https://github.com/ParsePlatform/parse-server/pull/1248) ([flovilmart](https://github.com/flovilmart))\n* Config/Push Tested with the dashboard. [\\#1235](https://github.com/ParsePlatform/parse-server/pull/1235) ([drew-gross](https://github.com/drew-gross))\n* Better logging with winston [\\#1234](https://github.com/ParsePlatform/parse-server/pull/1234) ([flovilmart](https://github.com/flovilmart))\n* Make GlobalConfig work like parse.com [\\#1210](https://github.com/ParsePlatform/parse-server/pull/1210) ([framp](https://github.com/framp))\n* Improve flattening of results from pushAdapter [\\#1204](https://github.com/ParsePlatform/parse-server/pull/1204) ([flovilmart](https://github.com/flovilmart))\n* Push adapters are provided by external packages [\\#1195](https://github.com/ParsePlatform/parse-server/pull/1195) ([flovilmart](https://github.com/flovilmart))\n* Fix flaky test [\\#1188](https://github.com/ParsePlatform/parse-server/pull/1188) ([drew-gross](https://github.com/drew-gross))\n* Fixes problem affecting finding array pointers [\\#1185](https://github.com/ParsePlatform/parse-server/pull/1185) ([flovilmart](https://github.com/flovilmart))\n* Moves Files adapters to external packages [\\#1172](https://github.com/ParsePlatform/parse-server/pull/1172) ([flovilmart](https://github.com/flovilmart))\n* Mark push as enabled in serverInfo endpoint [\\#1164](https://github.com/ParsePlatform/parse-server/pull/1164) ([drew-gross](https://github.com/drew-gross))\n* Document email adapter [\\#1144](https://github.com/ParsePlatform/parse-server/pull/1144) ([drew-gross](https://github.com/drew-gross))\n* Reset password fix [\\#1133](https://github.com/ParsePlatform/parse-server/pull/1133) ([carmenlau](https://github.com/carmenlau))\n\n### 2.2.2\n\n* Important Fix: Mounts createLiveQueryServer, fix babel induced problem [\\#1153](https://github.com/ParsePlatform/parse-server/pull/1153) (flovilmart)\n* Move ParseServer to it's own file [\\#1166](https://github.com/ParsePlatform/parse-server/pull/1166) (flovilmart)\n* Update README.md * remove deploy buttons * replace with community links [\\#1139](https://github.com/ParsePlatform/parse-server/pull/1139) (drew-gross)\n* Adds bootstrap.sh [\\#1138](https://github.com/ParsePlatform/parse-server/pull/1138) (flovilmart)\n* Fix: Do not override username [\\#1142](https://github.com/ParsePlatform/parse-server/pull/1142) (flovilmart)\n* Fix: Add pushId back to GCM payload [\\#1168](https://github.com/ParsePlatform/parse-server/pull/1168) (wangmengyan95)\n\n### 2.2.1\n\n* New: Add FileSystemAdapter file adapter [\\#1098](https://github.com/ParsePlatform/parse-server/pull/1098) (dtsolis)\n* New: Enabled CLP editing [\\#1128](https://github.com/ParsePlatform/parse-server/pull/1128) (drew-gross)\n* Improvement: Reduces the number of connections to mongo created [\\#1111](https://github.com/ParsePlatform/parse-server/pull/1111) (flovilmart)\n* Improvement: Make ParseServer a class [\\#980](https://github.com/ParsePlatform/parse-server/pull/980) (flovilmart)\n* Fix: Adds support for plain object in $add, $addUnique, $remove [\\#1114](https://github.com/ParsePlatform/parse-server/pull/1114) (flovilmart)\n* Fix: Generates default CLP, freezes objects [\\#1132](https://github.com/ParsePlatform/parse-server/pull/1132) (flovilmart)\n* Fix: Properly sets installationId on creating session with 3rd party auth [\\#1110](https://github.com/ParsePlatform/parse-server/pull/1110) (flovilmart)\n\n### 2.2.0\n\n* New Feature: Real-time functionality with Live Queries! [\\#1092](https://github.com/ParsePlatform/parse-server/pull/1092) (wangmengyan95)\n* Improvement: Push Status API [\\#1004](https://github.com/ParsePlatform/parse-server/pull/1004) (flovilmart)\n* Improvement: Allow client operations on Roles [\\#1068](https://github.com/ParsePlatform/parse-server/pull/1068) (flovilmart)\n* Improvement: Add URI encoding to mongo auth parameters [\\#986](https://github.com/ParsePlatform/parse-server/pull/986) (bgw)\n* Improvement: Adds support for apps key in config file, but only support single app for now [\\#979](https://github.com/ParsePlatform/parse-server/pull/979) (flovilmart)\n* Documentation: Getting Started and Configuring Parse Server [\\#988](https://github.com/ParsePlatform/parse-server/pull/988) (hramos)\n* Fix: Various edge cases with REST API [\\#1066](https://github.com/ParsePlatform/parse-server/pull/1066) (flovilmart)\n* Fix: Makes sure the location in results has the proper objectId [\\#1065](https://github.com/ParsePlatform/parse-server/pull/1065) (flovilmart)\n* Fix: Third-party auth is properly removed when unlinked [\\#1081](https://github.com/ParsePlatform/parse-server/pull/1081) (flovilmart)\n* Fix: Clear the session-user cache when changing \\_User objects [\\#1072](https://github.com/ParsePlatform/parse-server/pull/1072) (gfosco)\n* Fix: Bug related to subqueries on unfetched objects [\\#1046](https://github.com/ParsePlatform/parse-server/pull/1046) (flovilmart)\n* Fix: Properly urlencode parameters for email validation and password reset [\\#1001](https://github.com/ParsePlatform/parse-server/pull/1001) (flovilmart)\n* Fix: Better sanitization/decoding of object data for afterSave triggers [\\#992](https://github.com/ParsePlatform/parse-server/pull/992) (flovilmart)\n* Fix: Changes default encoding for httpRequest [\\#892](https://github.com/ParsePlatform/parse-server/pull/892) (flovilmart)\n\n### 2.1.6\n\n* Improvement: Full query support for badge Increment \\(\\#931\\) [\\#983](https://github.com/ParsePlatform/parse-server/pull/983) (flovilmart)\n* Improvement: Shutdown standalone parse server gracefully [\\#958](https://github.com/ParsePlatform/parse-server/pull/958) (raulr)\n* Improvement: Add database options to ParseServer constructor and pass to MongoStorageAdapter [\\#956](https://github.com/ParsePlatform/parse-server/pull/956) (steven-supersolid)\n* Improvement: AuthData logic refactor [\\#952](https://github.com/ParsePlatform/parse-server/pull/952) (flovilmart)\n* Improvement: Changed FileLoggerAdapterSpec to fail gracefully on Windows [\\#946](https://github.com/ParsePlatform/parse-server/pull/946) (aneeshd16)\n* Improvement: Add new schema collection type and replace all usages of direct mongo collection for schema operations. [\\#943](https://github.com/ParsePlatform/parse-server/pull/943) (nlutsenko)\n* Improvement: Adds CLP API to Schema router [\\#898](https://github.com/ParsePlatform/parse-server/pull/898) (flovilmart)\n* Fix: Cleans up authData null keys on login for android crash [\\#978](https://github.com/ParsePlatform/parse-server/pull/978) (flovilmart)\n* Fix: Do master query for before/afterSaveHook [\\#959](https://github.com/ParsePlatform/parse-server/pull/959) (wangmengyan95)\n* Fix: re-add shebang [\\#944](https://github.com/ParsePlatform/parse-server/pull/944) (flovilmart)\n* Fix: Added test command for Windows support [\\#886](https://github.com/ParsePlatform/parse-server/pull/886) (aneeshd16)\n\n### 2.1.5\n\n* New: FileAdapter for Google Cloud Storage [\\#708](https://github.com/ParsePlatform/parse-server/pull/708) (mcdonamp)\n* Improvement: Minimize extra schema queries in some scenarios. [\\#919](https://github.com/ParsePlatform/parse-server/pull/919) (Marco129)\n* Improvement: Move DatabaseController and Schema fully to adaptive mongo collection. [\\#909](https://github.com/ParsePlatform/parse-server/pull/909) (nlutsenko)\n* Improvement: Cleanup PushController/PushRouter, remove raw mongo collection access. [\\#903](https://github.com/ParsePlatform/parse-server/pull/903) (nlutsenko)\n* Improvement: Increment badge the right way [\\#902](https://github.com/ParsePlatform/parse-server/pull/902) (flovilmart)\n* Improvement: Migrate ParseGlobalConfig to new database storage API. [\\#901](https://github.com/ParsePlatform/parse-server/pull/901) (nlutsenko)\n* Improvement: Improve delete flow for non-existent \\_Join collection [\\#881](https://github.com/ParsePlatform/parse-server/pull/881) (Marco129)\n* Improvement: Adding a role scenario test for issue 827 [\\#878](https://github.com/ParsePlatform/parse-server/pull/878) (gfosco)\n* Improvement: Test empty authData block on login for \\#413 [\\#863](https://github.com/ParsePlatform/parse-server/pull/863) (gfosco)\n* Improvement: Modified the npm dev script to support Windows [\\#846](https://github.com/ParsePlatform/parse-server/pull/846) (aneeshd16)\n* Improvement: Move HooksController to use MongoCollection instead of direct Mongo access. [\\#844](https://github.com/ParsePlatform/parse-server/pull/844) (nlutsenko)\n* Improvement: Adds public\\_html and views for packaging [\\#839](https://github.com/ParsePlatform/parse-server/pull/839) (flovilmart)\n* Improvement: Better support for windows builds [\\#831](https://github.com/ParsePlatform/parse-server/pull/831) (flovilmart)\n* Improvement: Convert Schema.js to ES6 class. [\\#826](https://github.com/ParsePlatform/parse-server/pull/826) (nlutsenko)\n* Improvement: Remove duplicated instructions [\\#816](https://github.com/ParsePlatform/parse-server/pull/816) (hramos)\n* Improvement: Completely migrate SchemasRouter to new MongoCollection API. [\\#794](https://github.com/ParsePlatform/parse-server/pull/794) (nlutsenko)\n* Fix: Do not require where clause in $dontSelect condition on queries. [\\#925](https://github.com/ParsePlatform/parse-server/pull/925) (nlutsenko)\n* Fix: Make sure that ACLs propagate to before/after save hooks. [\\#924](https://github.com/ParsePlatform/parse-server/pull/924) (nlutsenko)\n* Fix: Support params option in Parse.Cloud.httpRequest. [\\#912](https://github.com/ParsePlatform/parse-server/pull/912) (carmenlau)\n* Fix: Fix flaky Parse.GeoPoint test. [\\#908](https://github.com/ParsePlatform/parse-server/pull/908) (nlutsenko)\n* Fix: Handle legacy \\_client\\_permissions key in \\_SCHEMA. [\\#900](https://github.com/ParsePlatform/parse-server/pull/900) (drew-gross)\n* Fix: Fixes bug when querying equalTo on objectId and relation [\\#887](https://github.com/ParsePlatform/parse-server/pull/887) (flovilmart)\n* Fix: Allow crossdomain on filesRouter [\\#876](https://github.com/ParsePlatform/parse-server/pull/876) (flovilmart)\n* Fix: Remove limit when counting results. [\\#867](https://github.com/ParsePlatform/parse-server/pull/867) (gfosco)\n* Fix: beforeSave changes should propagate to the response [\\#865](https://github.com/ParsePlatform/parse-server/pull/865) (gfosco)\n* Fix: Delete relation field when \\_Join collection not exist [\\#864](https://github.com/ParsePlatform/parse-server/pull/864) (Marco129)\n* Fix: Related query on non-existing column [\\#861](https://github.com/ParsePlatform/parse-server/pull/861) (gfosco)\n* Fix: Update markdown in .github/ISSUE\\_TEMPLATE.md [\\#859](https://github.com/ParsePlatform/parse-server/pull/859) (igorshubovych)\n* Fix: Issue with creating wrong \\_Session for Facebook login [\\#857](https://github.com/ParsePlatform/parse-server/pull/857) (tobernguyen)\n* Fix: Leak warnings in tests, use mongodb-runner from node\\_modules [\\#843](https://github.com/ParsePlatform/parse-server/pull/843) (drew-gross)\n* Fix: Reversed roles lookup [\\#841](https://github.com/ParsePlatform/parse-server/pull/841) (flovilmart)\n* Fix: Improves loading of Push Adapter, fix loading of S3Adapter [\\#833](https://github.com/ParsePlatform/parse-server/pull/833) (flovilmart)\n* Fix: Add field to system schema [\\#828](https://github.com/ParsePlatform/parse-server/pull/828) (Marco129)\n\n### 2.1.4\n\n* New: serverInfo endpoint that returns server version and info about the server's features\n* Improvement: Add support for badges on iOS\n* Improvement: Improve failure handling in cloud code http requests\n* Improvement: Add support for queries on pointers and relations\n* Improvement: Add support for multiple $in clauses in a query\n* Improvement: Add allowClientClassCreation config option\n* Improvement: Allow atomically setting subdocument keys\n* Improvement: Allow arbitrarily deeply nested roles\n* Improvement: Set proper content-type in S3 File Adapter\n* Improvement: S3 adapter auto-creates buckets\n* Improvement: Better error messages for many errors\n* Performance: Improved algorithm for validating client keys\n* Experimental: Parse Hooks and Hooks API\n* Experimental: Email verification and password reset emails\n* Experimental: Improve compatability of logs feature with Parse.com\n* Fix: Fix for attempting to delete missing classes via schemas API\n* Fix: Allow creation of system classes via schemas API\n* Fix: Allow missing where cause in $select\n* Fix: Improve handling of invalid object ids\n* Fix: Replace query overwriting existing query\n* Fix: Propagate installationId in cloud code triggers\n* Fix: Session expiresAt is now a Date instead of a string\n* Fix: Fix count queries\n* Fix: Disallow _Role objects without names or without ACL\n* Fix: Better handling of invalid types submitted\n* Fix: beforeSave will not be triggered for attempts to save with invalid authData\n* Fix: Fix duplicate device token issues on Android\n* Fix: Allow empty authData on signup\n* Fix: Allow Master Key Headers (CORS)\n* Fix: Fix bugs if JavaScript key was not provided in server configuration\n* Fix: Parse Files on objects can now be stored without URLs\n* Fix: allow both objectId or installationId when modifying installation\n* Fix: Command line works better when not given options\n\n### 2.1.3\n\n* Feature: Add initial support for in-app purchases\n* Feature: Better error messages when attempting to run the server on a port that is already in use or without a server URL\n* Feature: Allow customization of max file size\n* Performance: Faster saves if not using beforeSave triggers\n* Fix: Send session token in response to current user endpoint\n* Fix: Remove triggers for _Session collection\n* Fix: Improve compatability of cloud code beforeSave hook for newly created object\n* Fix: ACL creation for master key only objects\n* Fix: Allow uploading files without Content-Type\n* Fix: Add features to http request to match Parse.com\n* Fix: Bugs in development script when running from locations other than project root\n* Fix: Can pass query constraints in URL\n* Fix: Objects with legacy \"_tombstone\" key now don't cause issues.\n* Fix: Allow nested keys in objects to begin with underscores\n* Fix: Allow correct headers for CORS\n\n### 2.1.2\n\n* Change: The S3 file adapter constructor requires a bucket name\n* Fix: Parse Query should throw if improperly encoded\n* Fix: Issue where roles were not used in some requests\n* Fix: serverURL will no longer default to api.parse.com/1\n\n### 2.1.1\n\n* Experimental: Schemas API support for DELETE operations\n* Fix: Session token issue fetching Users\n* Fix: Facebook auth validation\n* Fix: Invalid error when deleting missing session\n\n### 2.1.0\n\n* Feature: Support for additional OAuth providers\n* Feature: Ability to implement custom OAuth providers\n* Feature: Support for deleting Parse Files\n* Feature: Allow querying roles\n* Feature: Support for logs, extensible via Log Adapter\n* Feature: New Push Adapter for sending push notifications through OneSignal\n* Feature: Tighter default security for Users\n* Feature: Pass parameters to cloud code in query string\n* Feature: Disable anonymous users via configuration.\n* Experimental: Schemas API support for PUT operations\n* Fix: Prevent installation ID from being added to User\n* Fix: Becoming a user works properly with sessions\n* Fix: Including multiple object when some object are unavailable will get all the objects that are available\n* Fix: Invalid URL for Parse Files\n* Fix: Making a query without a limit now returns 100 results\n* Fix: Expose installation id in cloud code\n* Fix: Correct username for Anonymous users\n* Fix: Session token issue after fetching user\n* Fix: Issues during install process\n* Fix: Issue with Unity SDK sending _noBody\n\n### 2.0.8\n\n* Add: support for Android and iOS push notifications\n* Experimental: cloud code validation hooks (can mark as non-experimental after we have docs)\n* Experimental: support for schemas API (GET and POST only)\n* Experimental: support for Parse Config (GET and POST only)\n* Fix: Querying objects with equality constraint on array column\n* Fix: User logout will remove session token\n* Fix: Various files related bugs\n* Fix: Force minimum node version 4.3 due to security issues in earlier version\n* Performance Improvement: Improved caching\n", "// This is a port of the test suite:\n// hungry/js/test/parse_query_test.js\n//\n// Some new tests are added.\n'use strict';\n\nconst Parse = require('parse/node');\nconst request = require('../lib/request');\n\nconst masterKeyHeaders = {\n  'X-Parse-Application-Id': 'test',\n  'X-Parse-Rest-API-Key': 'test',\n  'X-Parse-Master-Key': 'test',\n  'Content-Type': 'application/json',\n};\n\nconst masterKeyOptions = {\n  headers: masterKeyHeaders,\n};\n\nconst BoxedNumber = Parse.Object.extend({\n  className: 'BoxedNumber',\n});\n\ndescribe('Parse.Query testing', () => {\n  it('basic query', function (done) {\n    const baz = new TestObject({ foo: 'baz' });\n    const qux = new TestObject({ foo: 'qux' });\n    Parse.Object.saveAll([baz, qux]).then(function () {\n      const query = new Parse.Query(TestObject);\n      query.equalTo('foo', 'baz');\n      query.find().then(function (results) {\n        equal(results.length, 1);\n        equal(results[0].get('foo'), 'baz');\n        done();\n      });\n    });\n  });\n\n  it_only_db('mongo')('gracefully handles invalid explain values', async () => {\n    // Note that anything that is not truthy (like 0) does not cause an exception, as they get swallowed up by ClassesRouter::optionsFromBody\n    const values = [1, 'yolo', { a: 1 }, [1, 2, 3]];\n    for (const value of values) {\n      try {\n        await request({\n          method: 'GET',\n          url: `http://localhost:8378/1/classes/_User?explain=${value}`,\n          json: true,\n          headers: masterKeyHeaders,\n        });\n        fail('request did not throw');\n      } catch (e) {\n        // Expect that Parse Server did not crash\n        expect(e.code).not.toEqual('ECONNRESET');\n        // Expect that Parse Server validates the explain value and does not crash;\n        // see https://jira.mongodb.org/browse/NODE-3463\n        equal(e.data.code, Parse.Error.INVALID_QUERY);\n        equal(e.data.error, 'Invalid value for explain');\n      }\n      // get queries (of the form '/classes/:className/:objectId' cannot have the explain key, see ClassesRouter.js)\n      // so it is enough that we test find queries\n    }\n  });\n\n  it_only_db('mongo')('supports valid explain values', async () => {\n    const values = [\n      false,\n      true,\n      'queryPlanner',\n      'executionStats',\n      'allPlansExecution',\n      // 'queryPlannerExtended' is excluded as it only applies to MongoDB Data Lake which is currently not available in our CI environment\n    ];\n    for (const value of values) {\n      const response = await request({\n        method: 'GET',\n        url: `http://localhost:8378/1/classes/_User?explain=${value}`,\n        json: true,\n        headers: masterKeyHeaders,\n      });\n      expect(response.status).toBe(200);\n      if (value) {\n        expect(response.data.results.ok).toBe(1);\n      }\n    }\n  });\n\n  it('searching for null', function (done) {\n    const baz = new TestObject({ foo: null });\n    const qux = new TestObject({ foo: 'qux' });\n    const qux2 = new TestObject({});\n    Parse.Object.saveAll([baz, qux, qux2]).then(function () {\n      const query = new Parse.Query(TestObject);\n      query.equalTo('foo', null);\n      query.find().then(function (results) {\n        equal(results.length, 2);\n        qux.set('foo', null);\n        qux.save().then(function () {\n          query.find().then(function (results) {\n            equal(results.length, 3);\n            done();\n          });\n        });\n      });\n    });\n  });\n\n  it('searching for not null', function (done) {\n    const baz = new TestObject({ foo: null });\n    const qux = new TestObject({ foo: 'qux' });\n    const qux2 = new TestObject({});\n    Parse.Object.saveAll([baz, qux, qux2]).then(function () {\n      const query = new Parse.Query(TestObject);\n      query.notEqualTo('foo', null);\n      query.find().then(function (results) {\n        equal(results.length, 1);\n        qux.set('foo', null);\n        qux.save().then(function () {\n          query.find().then(function (results) {\n            equal(results.length, 0);\n            done();\n          });\n        });\n      });\n    });\n  });\n\n  it('notEqualTo with Relation is working', function (done) {\n    const user = new Parse.User();\n    user.setPassword('asdf');\n    user.setUsername('zxcv');\n\n    const user1 = new Parse.User();\n    user1.setPassword('asdf');\n    user1.setUsername('qwerty');\n\n    const user2 = new Parse.User();\n    user2.setPassword('asdf');\n    user2.setUsername('asdf');\n\n    const Cake = Parse.Object.extend('Cake');\n    const cake1 = new Cake();\n    const cake2 = new Cake();\n    const cake3 = new Cake();\n\n    user\n      .signUp()\n      .then(function () {\n        return user1.signUp();\n      })\n      .then(function () {\n        return user2.signUp();\n      })\n      .then(function () {\n        const relLike1 = cake1.relation('liker');\n        relLike1.add([user, user1]);\n\n        const relDislike1 = cake1.relation('hater');\n        relDislike1.add(user2);\n\n        return cake1.save();\n      })\n      .then(function () {\n        const rellike2 = cake2.relation('liker');\n        rellike2.add([user, user1]);\n\n        const relDislike2 = cake2.relation('hater');\n        relDislike2.add(user2);\n\n        const relSomething = cake2.relation('something');\n        relSomething.add(user);\n\n        return cake2.save();\n      })\n      .then(function () {\n        const rellike3 = cake3.relation('liker');\n        rellike3.add(user);\n\n        const relDislike3 = cake3.relation('hater');\n        relDislike3.add([user1, user2]);\n        return cake3.save();\n      })\n      .then(function () {\n        const query = new Parse.Query(Cake);\n        // User2 likes nothing so we should receive 0\n        query.equalTo('liker', user2);\n        return query.find().then(function (results) {\n          equal(results.length, 0);\n        });\n      })\n      .then(function () {\n        const query = new Parse.Query(Cake);\n        // User1 likes two of three cakes\n        query.equalTo('liker', user1);\n        return query.find().then(function (results) {\n          // It should return 2 -> cake 1 and cake 2\n          equal(results.length, 2);\n        });\n      })\n      .then(function () {\n        const query = new Parse.Query(Cake);\n        // We want to know which cake the user1 is not appreciating -> cake3\n        query.notEqualTo('liker', user1);\n        return query.find().then(function (results) {\n          // Should return 1 -> the cake 3\n          equal(results.length, 1);\n        });\n      })\n      .then(function () {\n        const query = new Parse.Query(Cake);\n        // User2 is a hater of everything so we should receive 0\n        query.notEqualTo('hater', user2);\n        return query.find().then(function (results) {\n          equal(results.length, 0);\n        });\n      })\n      .then(function () {\n        const query = new Parse.Query(Cake);\n        // Only cake3 is liked by user\n        query.notContainedIn('liker', [user1]);\n        return query.find().then(function (results) {\n          equal(results.length, 1);\n        });\n      })\n      .then(function () {\n        const query = new Parse.Query(Cake);\n        // All the users\n        query.containedIn('liker', [user, user1, user2]);\n        // Exclude user 1\n        query.notEqualTo('liker', user1);\n        // Only cake3 is liked only by user1\n        return query.find().then(function (results) {\n          equal(results.length, 1);\n          const cake = results[0];\n          expect(cake.id).toBe(cake3.id);\n        });\n      })\n      .then(function () {\n        const query = new Parse.Query(Cake);\n        // Exclude user1\n        query.notEqualTo('liker', user1);\n        // Only cake1\n        query.equalTo('objectId', cake1.id);\n        // user1 likes cake1 so this should return no results\n        return query.find().then(function (results) {\n          equal(results.length, 0);\n        });\n      })\n      .then(function () {\n        const query = new Parse.Query(Cake);\n        query.notEqualTo('hater', user2);\n        query.notEqualTo('liker', user2);\n        // user2 doesn't like any cake so this should be 0\n        return query.find().then(function (results) {\n          equal(results.length, 0);\n        });\n      })\n      .then(function () {\n        const query = new Parse.Query(Cake);\n        query.equalTo('hater', user);\n        query.equalTo('liker', user);\n        // user doesn't hate any cake so this should be 0\n        return query.find().then(function (results) {\n          equal(results.length, 0);\n        });\n      })\n      .then(function () {\n        const query = new Parse.Query(Cake);\n        query.equalTo('hater', null);\n        query.equalTo('liker', null);\n        // user doesn't hate any cake so this should be 0\n        return query.find().then(function (results) {\n          equal(results.length, 0);\n        });\n      })\n      .then(function () {\n        const query = new Parse.Query(Cake);\n        query.equalTo('something', null);\n        // user doesn't hate any cake so this should be 0\n        return query.find().then(function (results) {\n          equal(results.length, 0);\n        });\n      })\n      .then(function () {\n        done();\n      })\n      .catch(err => {\n        jfail(err);\n        done();\n      });\n  });\n\n  it('query notContainedIn on empty array', async () => {\n    const object = new TestObject();\n    object.set('value', 100);\n    await object.save();\n\n    const query = new Parse.Query(TestObject);\n    query.notContainedIn('value', []);\n\n    const results = await query.find();\n    equal(results.length, 1);\n  });\n\n  it('query containedIn on empty array', async () => {\n    const object = new TestObject();\n    object.set('value', 100);\n    await object.save();\n\n    const query = new Parse.Query(TestObject);\n    query.containedIn('value', []);\n\n    const results = await query.find();\n    equal(results.length, 0);\n  });\n\n  it('query with limit', function (done) {\n    const baz = new TestObject({ foo: 'baz' });\n    const qux = new TestObject({ foo: 'qux' });\n    Parse.Object.saveAll([baz, qux]).then(function () {\n      const query = new Parse.Query(TestObject);\n      query.limit(1);\n      query.find().then(function (results) {\n        equal(results.length, 1);\n        done();\n      });\n    });\n  });\n\n  it('query with limit equal to maxlimit', async () => {\n    const baz = new TestObject({ foo: 'baz' });\n    const qux = new TestObject({ foo: 'qux' });\n    await reconfigureServer({ maxLimit: 1 });\n    await Parse.Object.saveAll([baz, qux]);\n    const query = new Parse.Query(TestObject);\n    query.limit(1);\n    const results = await query.find();\n    equal(results.length, 1);\n  });\n\n  it('query with limit exceeding maxlimit', async () => {\n    const baz = new TestObject({ foo: 'baz' });\n    const qux = new TestObject({ foo: 'qux' });\n    await reconfigureServer({ maxLimit: 1 });\n    await Parse.Object.saveAll([baz, qux]);\n    const query = new Parse.Query(TestObject);\n    query.limit(2);\n    const results = await query.find();\n    equal(results.length, 1);\n  });\n\n  it('containedIn object array queries', function (done) {\n    const messageList = [];\n    for (let i = 0; i < 4; ++i) {\n      const message = new TestObject({});\n      if (i > 0) {\n        message.set('prior', messageList[i - 1]);\n      }\n      messageList.push(message);\n    }\n\n    Parse.Object.saveAll(messageList).then(\n      function () {\n        equal(messageList.length, 4);\n\n        const inList = [];\n        inList.push(messageList[0]);\n        inList.push(messageList[2]);\n\n        const query = new Parse.Query(TestObject);\n        query.containedIn('prior', inList);\n        query.find().then(\n          function (results) {\n            equal(results.length, 2);\n            done();\n          },\n          function (e) {\n            jfail(e);\n            done();\n          }\n        );\n      },\n      e => {\n        jfail(e);\n        done();\n      }\n    );\n  });\n\n  it('containedIn null array', done => {\n    const emails = ['contact@xyz.com', 'contact@zyx.com', null];\n    const user = new Parse.User();\n    user.setUsername(emails[0]);\n    user.setPassword('asdf');\n    user\n      .signUp()\n      .then(() => {\n        const query = new Parse.Query(Parse.User);\n        query.containedIn('username', emails);\n        return query.find({ useMasterKey: true });\n      })\n      .then(results => {\n        equal(results.length, 1);\n        done();\n      }, done.fail);\n  });\n\n  it('nested equalTo string with single quote', async () => {\n    const obj = new TestObject({ nested: { foo: \"single'quote\" } });\n    await obj.save();\n    const query = new Parse.Query(TestObject);\n    query.equalTo('nested.foo', \"single'quote\");\n    const result = await query.get(obj.id);\n    equal(result.get('nested').foo, \"single'quote\");\n  });\n\n  it('nested containedIn string with single quote', async () => {\n    const obj = new TestObject({ nested: { foo: [\"single'quote\"] } });\n    await obj.save();\n    const query = new Parse.Query(TestObject);\n    query.containedIn('nested.foo', [\"single'quote\"]);\n    const result = await query.get(obj.id);\n    equal(result.get('nested').foo[0], \"single'quote\");\n  });\n\n  it('nested containedIn string', done => {\n    const sender1 = { group: ['A', 'B'] };\n    const sender2 = { group: ['A', 'C'] };\n    const sender3 = { group: ['B', 'C'] };\n    const obj1 = new TestObject({ sender: sender1 });\n    const obj2 = new TestObject({ sender: sender2 });\n    const obj3 = new TestObject({ sender: sender3 });\n    Parse.Object.saveAll([obj1, obj2, obj3])\n      .then(() => {\n        const query = new Parse.Query(TestObject);\n        query.containedIn('sender.group', ['A']);\n        return query.find();\n      })\n      .then(results => {\n        equal(results.length, 2);\n        done();\n      }, done.fail);\n  });\n\n  it('nested containedIn number', done => {\n    const sender1 = { group: [1, 2] };\n    const sender2 = { group: [1, 3] };\n    const sender3 = { group: [2, 3] };\n    const obj1 = new TestObject({ sender: sender1 });\n    const obj2 = new TestObject({ sender: sender2 });\n    const obj3 = new TestObject({ sender: sender3 });\n    Parse.Object.saveAll([obj1, obj2, obj3])\n      .then(() => {\n        const query = new Parse.Query(TestObject);\n        query.containedIn('sender.group', [1]);\n        return query.find();\n      })\n      .then(results => {\n        equal(results.length, 2);\n        done();\n      }, done.fail);\n  });\n\n  it('containsAll number array queries', function (done) {\n    const NumberSet = Parse.Object.extend({ className: 'NumberSet' });\n\n    const objectsList = [];\n    objectsList.push(new NumberSet({ numbers: [1, 2, 3, 4, 5] }));\n    objectsList.push(new NumberSet({ numbers: [1, 3, 4, 5] }));\n\n    Parse.Object.saveAll(objectsList)\n      .then(function () {\n        const query = new Parse.Query(NumberSet);\n        query.containsAll('numbers', [1, 2, 3]);\n        query.find().then(\n          function (results) {\n            equal(results.length, 1);\n            done();\n          },\n          function (err) {\n            jfail(err);\n            done();\n          }\n        );\n      })\n      .catch(err => {\n        jfail(err);\n        done();\n      });\n  });\n\n  it('containsAll string array queries', function (done) {\n    const StringSet = Parse.Object.extend({ className: 'StringSet' });\n\n    const objectsList = [];\n    objectsList.push(new StringSet({ strings: ['a', 'b', 'c', 'd', 'e'] }));\n    objectsList.push(new StringSet({ strings: ['a', 'c', 'd', 'e'] }));\n\n    Parse.Object.saveAll(objectsList)\n      .then(function () {\n        const query = new Parse.Query(StringSet);\n        query.containsAll('strings', ['a', 'b', 'c']);\n        query.find().then(function (results) {\n          equal(results.length, 1);\n          done();\n        });\n      })\n      .catch(err => {\n        jfail(err);\n        done();\n      });\n  });\n\n  it('containsAll date array queries', function (done) {\n    const DateSet = Parse.Object.extend({ className: 'DateSet' });\n\n    function parseDate(iso8601) {\n      const regexp = new RegExp(\n        '^([0-9]{1,4})-([0-9]{1,2})-([0-9]{1,2})' +\n          'T' +\n          '([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2})' +\n          '(.([0-9]+))?' +\n          'Z$'\n      );\n      const match = regexp.exec(iso8601);\n      if (!match) {\n        return null;\n      }\n\n      const year = match[1] || 0;\n      const month = (match[2] || 1) - 1;\n      const day = match[3] || 0;\n      const hour = match[4] || 0;\n      const minute = match[5] || 0;\n      const second = match[6] || 0;\n      const milli = match[8] || 0;\n\n      return new Date(Date.UTC(year, month, day, hour, minute, second, milli));\n    }\n\n    const makeDates = function (stringArray) {\n      return stringArray.map(function (dateStr) {\n        return parseDate(dateStr + 'T00:00:00Z');\n      });\n    };\n\n    const objectsList = [];\n    objectsList.push(\n      new DateSet({\n        dates: makeDates(['2013-02-01', '2013-02-02', '2013-02-03', '2013-02-04']),\n      })\n    );\n    objectsList.push(\n      new DateSet({\n        dates: makeDates(['2013-02-01', '2013-02-03', '2013-02-04']),\n      })\n    );\n\n    Parse.Object.saveAll(objectsList).then(function () {\n      const query = new Parse.Query(DateSet);\n      query.containsAll('dates', makeDates(['2013-02-01', '2013-02-02', '2013-02-03']));\n      query.find().then(\n        function (results) {\n          equal(results.length, 1);\n          done();\n        },\n        function (e) {\n          jfail(e);\n          done();\n        }\n      );\n    });\n  });\n\n  it('containsAll object array queries', function (done) {\n    const MessageSet = Parse.Object.extend({ className: 'MessageSet' });\n\n    const messageList = [];\n    for (let i = 0; i < 4; ++i) {\n      messageList.push(new TestObject({ i: i }));\n    }\n\n    Parse.Object.saveAll(messageList).then(function () {\n      equal(messageList.length, 4);\n\n      const messageSetList = [];\n      messageSetList.push(new MessageSet({ messages: messageList }));\n\n      const someList = [];\n      someList.push(messageList[0]);\n      someList.push(messageList[1]);\n      someList.push(messageList[3]);\n      messageSetList.push(new MessageSet({ messages: someList }));\n\n      Parse.Object.saveAll(messageSetList).then(function () {\n        const inList = [];\n        inList.push(messageList[0]);\n        inList.push(messageList[2]);\n\n        const query = new Parse.Query(MessageSet);\n        query.containsAll('messages', inList);\n        query.find().then(function (results) {\n          equal(results.length, 1);\n          done();\n        });\n      });\n    });\n  });\n\n  it('containsAllStartingWith should match all strings that starts with string', done => {\n    const object = new Parse.Object('Object');\n    object.set('strings', ['the', 'brown', 'lazy', 'fox', 'jumps']);\n    const object2 = new Parse.Object('Object');\n    object2.set('strings', ['the', 'brown', 'fox', 'jumps']);\n    const object3 = new Parse.Object('Object');\n    object3.set('strings', ['over', 'the', 'lazy', 'dog']);\n\n    const objectList = [object, object2, object3];\n\n    Parse.Object.saveAll(objectList).then(results => {\n      equal(objectList.length, results.length);\n\n      return request({\n        url: Parse.serverURL + '/classes/Object',\n        qs: {\n          where: JSON.stringify({\n            strings: {\n              $all: [{ $regex: '^\\\\Qthe\\\\E' }, { $regex: '^\\\\Qfox\\\\E' }, { $regex: '^\\\\Qlazy\\\\E' }],\n            },\n          }),\n        },\n        headers: {\n          'X-Parse-Application-Id': Parse.applicationId,\n          'X-Parse-Javascript-Key': Parse.javaScriptKey,\n          'Content-Type': 'application/json',\n        },\n      })\n        .then(function (response) {\n          const results = response.data;\n          equal(results.results.length, 1);\n          arrayContains(results.results, object);\n\n          return request({\n            url: Parse.serverURL + '/classes/Object',\n            qs: {\n              where: JSON.stringify({\n                strings: {\n                  $all: [{ $regex: '^\\\\Qthe\\\\E' }, { $regex: '^\\\\Qlazy\\\\E' }],\n                },\n              }),\n            },\n            headers: {\n              'X-Parse-Application-Id': Parse.applicationId,\n              'X-Parse-Javascript-Key': Parse.javaScriptKey,\n              'Content-Type': 'application/json',\n            },\n          });\n        })\n        .then(function (response) {\n          const results = response.data;\n          equal(results.results.length, 2);\n          arrayContains(results.results, object);\n          arrayContains(results.results, object3);\n\n          return request({\n            url: Parse.serverURL + '/classes/Object',\n            qs: {\n              where: JSON.stringify({\n                strings: {\n                  $all: [{ $regex: '^\\\\Qhe\\\\E' }, { $regex: '^\\\\Qlazy\\\\E' }],\n                },\n              }),\n            },\n            headers: {\n              'X-Parse-Application-Id': Parse.applicationId,\n              'X-Parse-Javascript-Key': Parse.javaScriptKey,\n              'Content-Type': 'application/json',\n            },\n          });\n        })\n        .then(function (response) {\n          const results = response.data;\n          equal(results.results.length, 0);\n\n          done();\n        });\n    });\n  });\n\n  it('containsAllStartingWith values must be all of type starting with regex', done => {\n    const object = new Parse.Object('Object');\n    object.set('strings', ['the', 'brown', 'lazy', 'fox', 'jumps']);\n\n    object\n      .save()\n      .then(() => {\n        equal(object.isNew(), false);\n\n        return request({\n          url: Parse.serverURL + '/classes/Object',\n          qs: {\n            where: JSON.stringify({\n              strings: {\n                $all: [\n                  { $regex: '^\\\\Qthe\\\\E' },\n                  { $regex: '^\\\\Qlazy\\\\E' },\n                  { $regex: '^\\\\Qfox\\\\E' },\n                  { $unknown: /unknown/ },\n                ],\n              },\n            }),\n          },\n          headers: {\n            'X-Parse-Application-Id': Parse.applicationId,\n            'X-Parse-Javascript-Key': Parse.javaScriptKey,\n            'Content-Type': 'application/json',\n          },\n        });\n      })\n      .then(done.fail, function () {\n        done();\n      });\n  });\n\n  it('containsAllStartingWith empty array values should return empty results', done => {\n    const object = new Parse.Object('Object');\n    object.set('strings', ['the', 'brown', 'lazy', 'fox', 'jumps']);\n\n    object\n      .save()\n      .then(() => {\n        equal(object.isNew(), false);\n\n        return request({\n          url: Parse.serverURL + '/classes/Object',\n          qs: {\n            where: JSON.stringify({\n              strings: {\n                $all: [],\n              },\n            }),\n          },\n          headers: {\n            'X-Parse-Application-Id': Parse.applicationId,\n            'X-Parse-Javascript-Key': Parse.javaScriptKey,\n            'Content-Type': 'application/json',\n          },\n        });\n      })\n      .then(\n        function (response) {\n          const results = response.data;\n          equal(results.results.length, 0);\n          done();\n        },\n        function () {}\n      );\n  });\n\n  it('containsAllStartingWith single empty value returns empty results', done => {\n    const object = new Parse.Object('Object');\n    object.set('strings', ['the', 'brown', 'lazy', 'fox', 'jumps']);\n\n    object\n      .save()\n      .then(() => {\n        equal(object.isNew(), false);\n\n        return request({\n          url: Parse.serverURL + '/classes/Object',\n          qs: {\n            where: JSON.stringify({\n              strings: {\n                $all: [{}],\n              },\n            }),\n          },\n          headers: {\n            'X-Parse-Application-Id': Parse.applicationId,\n            'X-Parse-Javascript-Key': Parse.javaScriptKey,\n            'Content-Type': 'application/json',\n          },\n        });\n      })\n      .then(\n        function (response) {\n          const results = response.data;\n          equal(results.results.length, 0);\n          done();\n        },\n        function () {}\n      );\n  });\n\n  it('containsAllStartingWith single regex value should return corresponding matching results', done => {\n    const object = new Parse.Object('Object');\n    object.set('strings', ['the', 'brown', 'lazy', 'fox', 'jumps']);\n    const object2 = new Parse.Object('Object');\n    object2.set('strings', ['the', 'brown', 'fox', 'jumps']);\n    const object3 = new Parse.Object('Object');\n    object3.set('strings', ['over', 'the', 'lazy', 'dog']);\n\n    const objectList = [object, object2, object3];\n\n    Parse.Object.saveAll(objectList)\n      .then(results => {\n        equal(objectList.length, results.length);\n\n        return request({\n          url: Parse.serverURL + '/classes/Object',\n          qs: {\n            where: JSON.stringify({\n              strings: {\n                $all: [{ $regex: '^\\\\Qlazy\\\\E' }],\n              },\n            }),\n          },\n          headers: {\n            'X-Parse-Application-Id': Parse.applicationId,\n            'X-Parse-Javascript-Key': Parse.javaScriptKey,\n            'Content-Type': 'application/json',\n          },\n        });\n      })\n      .then(\n        function (response) {\n          const results = response.data;\n          equal(results.results.length, 2);\n          done();\n        },\n        function () {}\n      );\n  });\n\n  it('containsAllStartingWith single invalid regex returns empty results', done => {\n    const object = new Parse.Object('Object');\n    object.set('strings', ['the', 'brown', 'lazy', 'fox', 'jumps']);\n\n    object\n      .save()\n      .then(() => {\n        equal(object.isNew(), false);\n\n        return request({\n          url: Parse.serverURL + '/classes/Object',\n          qs: {\n            where: JSON.stringify({\n              strings: {\n                $all: [{ $unknown: '^\\\\Qlazy\\\\E' }],\n              },\n            }),\n          },\n          headers: {\n            'X-Parse-Application-Id': Parse.applicationId,\n            'X-Parse-Javascript-Key': Parse.javaScriptKey,\n          },\n        });\n      })\n      .then(\n        function (response) {\n          const results = response.data;\n          equal(results.results.length, 0);\n          done();\n        },\n        function () {}\n      );\n  });\n\n  it('containedBy pointer array', done => {\n    const objects = Array.from(Array(10).keys()).map(idx => {\n      const obj = new Parse.Object('Object');\n      obj.set('key', idx);\n      return obj;\n    });\n\n    const parent = new Parse.Object('Parent');\n    const parent2 = new Parse.Object('Parent');\n    const parent3 = new Parse.Object('Parent');\n\n    Parse.Object.saveAll(objects)\n      .then(() => {\n        // [0, 1, 2]\n        parent.set('objects', objects.slice(0, 3));\n\n        const shift = objects.shift();\n        // [2, 0]\n        parent2.set('objects', [objects[1], shift]);\n\n        // [1, 2, 3, 4]\n        parent3.set('objects', objects.slice(1, 4));\n\n        return Parse.Object.saveAll([parent, parent2, parent3]);\n      })\n      .then(() => {\n        // [1, 2, 3, 4, 5, 6, 7, 8, 9]\n        const pointers = objects.map(object => object.toPointer());\n\n        // Return all Parent where all parent.objects are contained in objects\n        return request({\n          url: Parse.serverURL + '/classes/Parent',\n          qs: {\n            where: JSON.stringify({\n              objects: {\n                $containedBy: pointers,\n              },\n            }),\n          },\n          headers: {\n            'X-Parse-Application-Id': Parse.applicationId,\n            'X-Parse-Javascript-Key': Parse.javaScriptKey,\n            'Content-Type': 'application/json',\n          },\n        });\n      })\n      .then(response => {\n        const results = response.data;\n        expect(results.results[0].objectId).not.toBeUndefined();\n        expect(results.results[0].objectId).toBe(parent3.id);\n        expect(results.results.length).toBe(1);\n        done();\n      });\n  });\n\n  it('containedBy number array', done => {\n    const options = Object.assign({}, masterKeyOptions, {\n      qs: {\n        where: JSON.stringify({\n          numbers: { $containedBy: [1, 2, 3, 4, 5, 6, 7, 8, 9] },\n        }),\n      },\n    });\n    const obj1 = new TestObject({ numbers: [0, 1, 2] });\n    const obj2 = new TestObject({ numbers: [2, 0] });\n    const obj3 = new TestObject({ numbers: [1, 2, 3, 4] });\n    Parse.Object.saveAll([obj1, obj2, obj3])\n      .then(() => {\n        return request(Object.assign({ url: Parse.serverURL + '/classes/TestObject' }, options));\n      })\n      .then(response => {\n        const results = response.data;\n        expect(results.results[0].objectId).not.toBeUndefined();\n        expect(results.results[0].objectId).toBe(obj3.id);\n        expect(results.results.length).toBe(1);\n        done();\n      });\n  });\n\n  it('containedBy empty array', done => {\n    const options = Object.assign({}, masterKeyOptions, {\n      qs: {\n        where: JSON.stringify({ numbers: { $containedBy: [] } }),\n      },\n    });\n    const obj1 = new TestObject({ numbers: [0, 1, 2] });\n    const obj2 = new TestObject({ numbers: [2, 0] });\n    const obj3 = new TestObject({ numbers: [1, 2, 3, 4] });\n    Parse.Object.saveAll([obj1, obj2, obj3])\n      .then(() => {\n        return request(Object.assign({ url: Parse.serverURL + '/classes/TestObject' }, options));\n      })\n      .then(response => {\n        const results = response.data;\n        expect(results.results.length).toBe(0);\n        done();\n      });\n  });\n\n  it('containedBy invalid query', done => {\n    const options = Object.assign({}, masterKeyOptions, {\n      qs: {\n        where: JSON.stringify({ objects: { $containedBy: 1234 } }),\n      },\n    });\n    const obj = new TestObject();\n    obj\n      .save()\n      .then(() => {\n        return request(Object.assign({ url: Parse.serverURL + '/classes/TestObject' }, options));\n      })\n      .then(done.fail)\n      .catch(response => {\n        equal(response.data.code, Parse.Error.INVALID_JSON);\n        equal(response.data.error, 'bad $containedBy: should be an array');\n        done();\n      });\n  });\n\n  it('equalTo queries', function (done) {\n    const makeBoxedNumber = function (i) {\n      return new BoxedNumber({ number: i });\n    };\n    Parse.Object.saveAll([0, 1, 2, 3, 4, 5, 6, 7, 8, 9].map(makeBoxedNumber)).then(function () {\n      const query = new Parse.Query(BoxedNumber);\n      query.equalTo('number', 3);\n      query.find().then(function (results) {\n        equal(results.length, 1);\n        done();\n      });\n    });\n  });\n\n  it('equalTo undefined', function (done) {\n    const makeBoxedNumber = function (i) {\n      return new BoxedNumber({ number: i });\n    };\n    Parse.Object.saveAll([0, 1, 2, 3, 4, 5, 6, 7, 8, 9].map(makeBoxedNumber)).then(function () {\n      const query = new Parse.Query(BoxedNumber);\n      query.equalTo('number', undefined);\n      query.find().then(function (results) {\n        equal(results.length, 0);\n        done();\n      });\n    });\n  });\n\n  it('lessThan queries', function (done) {\n    const makeBoxedNumber = function (i) {\n      return new BoxedNumber({ number: i });\n    };\n    Parse.Object.saveAll([0, 1, 2, 3, 4, 5, 6, 7, 8, 9].map(makeBoxedNumber)).then(function () {\n      const query = new Parse.Query(BoxedNumber);\n      query.lessThan('number', 7);\n      query.find().then(function (results) {\n        equal(results.length, 7);\n        done();\n      });\n    });\n  });\n\n  it('lessThanOrEqualTo queries', function (done) {\n    const makeBoxedNumber = function (i) {\n      return new BoxedNumber({ number: i });\n    };\n    Parse.Object.saveAll([0, 1, 2, 3, 4, 5, 6, 7, 8, 9].map(makeBoxedNumber)).then(function () {\n      const query = new Parse.Query(BoxedNumber);\n      query.lessThanOrEqualTo('number', 7);\n      query.find().then(function (results) {\n        equal(results.length, 8);\n        done();\n      });\n    });\n  });\n\n  it('lessThan zero queries', done => {\n    const makeBoxedNumber = i => {\n      return new BoxedNumber({ number: i });\n    };\n    const numbers = [-3, -2, -1, 0, 1];\n    const boxedNumbers = numbers.map(makeBoxedNumber);\n    Parse.Object.saveAll(boxedNumbers)\n      .then(() => {\n        const query = new Parse.Query(BoxedNumber);\n        query.lessThan('number', 0);\n        return query.find();\n      })\n      .then(results => {\n        equal(results.length, 3);\n        done();\n      });\n  });\n\n  it('lessThanOrEqualTo zero queries', done => {\n    const makeBoxedNumber = i => {\n      return new BoxedNumber({ number: i });\n    };\n    const numbers = [-3, -2, -1, 0, 1];\n    const boxedNumbers = numbers.map(makeBoxedNumber);\n    Parse.Object.saveAll(boxedNumbers)\n      .then(() => {\n        const query = new Parse.Query(BoxedNumber);\n        query.lessThanOrEqualTo('number', 0);\n        return query.find();\n      })\n      .then(results => {\n        equal(results.length, 4);\n        done();\n      });\n  });\n\n  it('greaterThan queries', function (done) {\n    const makeBoxedNumber = function (i) {\n      return new BoxedNumber({ number: i });\n    };\n    Parse.Object.saveAll([0, 1, 2, 3, 4, 5, 6, 7, 8, 9].map(makeBoxedNumber)).then(function () {\n      const query = new Parse.Query(BoxedNumber);\n      query.greaterThan('number', 7);\n      query.find().then(function (results) {\n        equal(results.length, 2);\n        done();\n      });\n    });\n  });\n\n  it('greaterThanOrEqualTo queries', function (done) {\n    const makeBoxedNumber = function (i) {\n      return new BoxedNumber({ number: i });\n    };\n    Parse.Object.saveAll([0, 1, 2, 3, 4, 5, 6, 7, 8, 9].map(makeBoxedNumber)).then(function () {\n      const query = new Parse.Query(BoxedNumber);\n      query.greaterThanOrEqualTo('number', 7);\n      query.find().then(function (results) {\n        equal(results.length, 3);\n        done();\n      });\n    });\n  });\n\n  it('greaterThan zero queries', done => {\n    const makeBoxedNumber = i => {\n      return new BoxedNumber({ number: i });\n    };\n    const numbers = [-3, -2, -1, 0, 1];\n    const boxedNumbers = numbers.map(makeBoxedNumber);\n    Parse.Object.saveAll(boxedNumbers)\n      .then(() => {\n        const query = new Parse.Query(BoxedNumber);\n        query.greaterThan('number', 0);\n        return query.find();\n      })\n      .then(results => {\n        equal(results.length, 1);\n        done();\n      });\n  });\n\n  it('greaterThanOrEqualTo zero queries', done => {\n    const makeBoxedNumber = i => {\n      return new BoxedNumber({ number: i });\n    };\n    const numbers = [-3, -2, -1, 0, 1];\n    const boxedNumbers = numbers.map(makeBoxedNumber);\n    Parse.Object.saveAll(boxedNumbers)\n      .then(() => {\n        const query = new Parse.Query(BoxedNumber);\n        query.greaterThanOrEqualTo('number', 0);\n        return query.find();\n      })\n      .then(results => {\n        equal(results.length, 2);\n        done();\n      });\n  });\n\n  it('lessThanOrEqualTo greaterThanOrEqualTo queries', function (done) {\n    const makeBoxedNumber = function (i) {\n      return new BoxedNumber({ number: i });\n    };\n    Parse.Object.saveAll([0, 1, 2, 3, 4, 5, 6, 7, 8, 9].map(makeBoxedNumber)).then(function () {\n      const query = new Parse.Query(BoxedNumber);\n      query.lessThanOrEqualTo('number', 7);\n      query.greaterThanOrEqualTo('number', 7);\n      query.find().then(function (results) {\n        equal(results.length, 1);\n        done();\n      });\n    });\n  });\n\n  it('lessThan greaterThan queries', function (done) {\n    const makeBoxedNumber = function (i) {\n      return new BoxedNumber({ number: i });\n    };\n    Parse.Object.saveAll([0, 1, 2, 3, 4, 5, 6, 7, 8, 9].map(makeBoxedNumber)).then(function () {\n      const query = new Parse.Query(BoxedNumber);\n      query.lessThan('number', 9);\n      query.greaterThan('number', 3);\n      query.find().then(function (results) {\n        equal(results.length, 5);\n        done();\n      });\n    });\n  });\n\n  it('notEqualTo queries', function (done) {\n    const makeBoxedNumber = function (i) {\n      return new BoxedNumber({ number: i });\n    };\n    Parse.Object.saveAll([0, 1, 2, 3, 4, 5, 6, 7, 8, 9].map(makeBoxedNumber)).then(function () {\n      const query = new Parse.Query(BoxedNumber);\n      query.notEqualTo('number', 5);\n      query.find().then(function (results) {\n        equal(results.length, 9);\n        done();\n      });\n    });\n  });\n\n  it('notEqualTo zero queries', done => {\n    const makeBoxedNumber = i => {\n      return new BoxedNumber({ number: i });\n    };\n    const numbers = [-3, -2, -1, 0, 1];\n    const boxedNumbers = numbers.map(makeBoxedNumber);\n    Parse.Object.saveAll(boxedNumbers)\n      .then(() => {\n        const query = new Parse.Query(BoxedNumber);\n        query.notEqualTo('number', 0);\n        return query.find();\n      })\n      .then(results => {\n        equal(results.length, 4);\n        done();\n      });\n  });\n\n  it('equalTo zero queries', done => {\n    const makeBoxedNumber = i => {\n      return new BoxedNumber({ number: i });\n    };\n    const numbers = [-3, -2, -1, 0, 1];\n    const boxedNumbers = numbers.map(makeBoxedNumber);\n    Parse.Object.saveAll(boxedNumbers)\n      .then(() => {\n        const query = new Parse.Query(BoxedNumber);\n        query.equalTo('number', 0);\n        return query.find();\n      })\n      .then(results => {\n        equal(results.length, 1);\n        done();\n      });\n  });\n\n  it('number equalTo boolean queries', done => {\n    const makeBoxedNumber = i => {\n      return new BoxedNumber({ number: i });\n    };\n    const numbers = [-3, -2, -1, 0, 1];\n    const boxedNumbers = numbers.map(makeBoxedNumber);\n    Parse.Object.saveAll(boxedNumbers)\n      .then(() => {\n        const query = new Parse.Query(BoxedNumber);\n        query.equalTo('number', false);\n        return query.find();\n      })\n      .then(results => {\n        equal(results.length, 0);\n        done();\n      });\n  });\n\n  it('equalTo false queries', done => {\n    const obj1 = new TestObject({ field: false });\n    const obj2 = new TestObject({ field: true });\n    Parse.Object.saveAll([obj1, obj2])\n      .then(() => {\n        const query = new Parse.Query(TestObject);\n        query.equalTo('field', false);\n        return query.find();\n      })\n      .then(results => {\n        equal(results.length, 1);\n        done();\n      });\n  });\n\n  it('where $eq false queries (rest)', done => {\n    const options = Object.assign({}, masterKeyOptions, {\n      qs: {\n        where: JSON.stringify({ field: { $eq: false } }),\n      },\n    });\n    const obj1 = new TestObject({ field: false });\n    const obj2 = new TestObject({ field: true });\n    Parse.Object.saveAll([obj1, obj2]).then(() => {\n      request(Object.assign({ url: Parse.serverURL + '/classes/TestObject' }, options)).then(\n        resp => {\n          equal(resp.data.results.length, 1);\n          done();\n        }\n      );\n    });\n  });\n\n  it('where $eq null queries (rest)', done => {\n    const options = Object.assign({}, masterKeyOptions, {\n      qs: {\n        where: JSON.stringify({ field: { $eq: null } }),\n      },\n    });\n    const obj1 = new TestObject({ field: false });\n    const obj2 = new TestObject({ field: null });\n    Parse.Object.saveAll([obj1, obj2]).then(() => {\n      return request(Object.assign({ url: Parse.serverURL + '/classes/TestObject' }, options)).then(\n        resp => {\n          equal(resp.data.results.length, 1);\n          done();\n        }\n      );\n    });\n  });\n\n  it('containedIn queries', function (done) {\n    const makeBoxedNumber = function (i) {\n      return new BoxedNumber({ number: i });\n    };\n    Parse.Object.saveAll([0, 1, 2, 3, 4, 5, 6, 7, 8, 9].map(makeBoxedNumber)).then(function () {\n      const query = new Parse.Query(BoxedNumber);\n      query.containedIn('number', [3, 5, 7, 9, 11]);\n      query.find().then(function (results) {\n        equal(results.length, 4);\n        done();\n      });\n    });\n  });\n\n  it('containedIn false queries', done => {\n    const makeBoxedNumber = i => {\n      return new BoxedNumber({ number: i });\n    };\n    const numbers = [-3, -2, -1, 0, 1];\n    const boxedNumbers = numbers.map(makeBoxedNumber);\n    Parse.Object.saveAll(boxedNumbers)\n      .then(() => {\n        const query = new Parse.Query(BoxedNumber);\n        query.containedIn('number', false);\n        return query.find();\n      })\n      .then(done.fail)\n      .catch(error => {\n        equal(error.code, Parse.Error.INVALID_JSON);\n        equal(error.message, 'bad $in value');\n        done();\n      });\n  });\n\n  it('notContainedIn false queries', done => {\n    const makeBoxedNumber = i => {\n      return new BoxedNumber({ number: i });\n    };\n    const numbers = [-3, -2, -1, 0, 1];\n    const boxedNumbers = numbers.map(makeBoxedNumber);\n    Parse.Object.saveAll(boxedNumbers)\n      .then(() => {\n        const query = new Parse.Query(BoxedNumber);\n        query.notContainedIn('number', false);\n        return query.find();\n      })\n      .then(done.fail)\n      .catch(error => {\n        equal(error.code, Parse.Error.INVALID_JSON);\n        equal(error.message, 'bad $nin value');\n        done();\n      });\n  });\n\n  it('notContainedIn queries', function (done) {\n    const makeBoxedNumber = function (i) {\n      return new BoxedNumber({ number: i });\n    };\n    Parse.Object.saveAll([0, 1, 2, 3, 4, 5, 6, 7, 8, 9].map(makeBoxedNumber)).then(function () {\n      const query = new Parse.Query(BoxedNumber);\n      query.notContainedIn('number', [3, 5, 7, 9, 11]);\n      query.find().then(function (results) {\n        equal(results.length, 6);\n        done();\n      });\n    });\n  });\n\n  it('objectId containedIn queries', function (done) {\n    const makeBoxedNumber = function (i) {\n      return new BoxedNumber({ number: i });\n    };\n    Parse.Object.saveAll([0, 1, 2, 3, 4, 5, 6, 7, 8, 9].map(makeBoxedNumber)).then(function (list) {\n      const query = new Parse.Query(BoxedNumber);\n      query.containedIn('objectId', [list[2].id, list[3].id, list[0].id, 'NONSENSE']);\n      query.ascending('number');\n      query.find().then(function (results) {\n        if (results.length != 3) {\n          fail('expected 3 results');\n        } else {\n          equal(results[0].get('number'), 0);\n          equal(results[1].get('number'), 2);\n          equal(results[2].get('number'), 3);\n        }\n        done();\n      });\n    });\n  });\n\n  it('objectId equalTo queries', function (done) {\n    const makeBoxedNumber = function (i) {\n      return new BoxedNumber({ number: i });\n    };\n    Parse.Object.saveAll([0, 1, 2, 3, 4, 5, 6, 7, 8, 9].map(makeBoxedNumber)).then(function (list) {\n      const query = new Parse.Query(BoxedNumber);\n      query.equalTo('objectId', list[4].id);\n      query.find().then(function (results) {\n        if (results.length != 1) {\n          fail('expected 1 result');\n          done();\n        } else {\n          equal(results[0].get('number'), 4);\n        }\n        done();\n      });\n    });\n  });\n\n  it('find no elements', function (done) {\n    const makeBoxedNumber = function (i) {\n      return new BoxedNumber({ number: i });\n    };\n    Parse.Object.saveAll([0, 1, 2, 3, 4, 5, 6, 7, 8, 9].map(makeBoxedNumber)).then(function () {\n      const query = new Parse.Query(BoxedNumber);\n      query.equalTo('number', 17);\n      query.find().then(function (results) {\n        equal(results.length, 0);\n        done();\n      });\n    });\n  });\n\n  it('find with error', function (done) {\n    const query = new Parse.Query(BoxedNumber);\n    query.equalTo('$foo', 'bar');\n    query\n      .find()\n      .then(done.fail)\n      .catch(error => expect(error.code).toBe(Parse.Error.INVALID_KEY_NAME))\n      .then(done);\n  });\n\n  it('get', function (done) {\n    Parse.Object.saveAll([new TestObject({ foo: 'bar' })]).then(function (items) {\n      ok(items[0]);\n      const objectId = items[0].id;\n      const query = new Parse.Query(TestObject);\n      query.get(objectId).then(function (result) {\n        ok(result);\n        equal(result.id, objectId);\n        equal(result.get('foo'), 'bar');\n        ok(result.createdAt instanceof Date);\n        ok(result.updatedAt instanceof Date);\n        done();\n      });\n    });\n  });\n\n  it('get undefined', function (done) {\n    Parse.Object.saveAll([new TestObject({ foo: 'bar' })]).then(function (items) {\n      ok(items[0]);\n      const query = new Parse.Query(TestObject);\n      query.get(undefined).then(fail, () => done());\n    });\n  });\n\n  it('get error', function (done) {\n    Parse.Object.saveAll([new TestObject({ foo: 'bar' })]).then(function (items) {\n      ok(items[0]);\n      const query = new Parse.Query(TestObject);\n      query.get('InvalidObjectID').then(\n        function () {\n          ok(false, 'The get should have failed.');\n          done();\n        },\n        function (error) {\n          equal(error.code, Parse.Error.OBJECT_NOT_FOUND);\n          done();\n        }\n      );\n    });\n  });\n\n  it('first', function (done) {\n    Parse.Object.saveAll([new TestObject({ foo: 'bar' })]).then(function () {\n      const query = new Parse.Query(TestObject);\n      query.equalTo('foo', 'bar');\n      query.first().then(function (result) {\n        equal(result.get('foo'), 'bar');\n        done();\n      });\n    });\n  });\n\n  it('first no result', function (done) {\n    Parse.Object.saveAll([new TestObject({ foo: 'bar' })]).then(function () {\n      const query = new Parse.Query(TestObject);\n      query.equalTo('foo', 'baz');\n      query.first().then(function (result) {\n        equal(result, undefined);\n        done();\n      });\n    });\n  });\n\n  it('first with two results', function (done) {\n    Parse.Object.saveAll([new TestObject({ foo: 'bar' }), new TestObject({ foo: 'bar' })]).then(\n      function () {\n        const query = new Parse.Query(TestObject);\n        query.equalTo('foo', 'bar');\n        query.first().then(function (result) {\n          equal(result.get('foo'), 'bar');\n          done();\n        });\n      }\n    );\n  });\n\n  it('first with error', function (done) {\n    const query = new Parse.Query(BoxedNumber);\n    query.equalTo('$foo', 'bar');\n    query\n      .first()\n      .then(done.fail)\n      .catch(e => expect(e.code).toBe(Parse.Error.INVALID_KEY_NAME))\n      .then(done);\n  });\n\n  const Container = Parse.Object.extend({\n    className: 'Container',\n  });\n\n  it('notEqualTo object', function (done) {\n    const item1 = new TestObject();\n    const item2 = new TestObject();\n    const container1 = new Container({ item: item1 });\n    const container2 = new Container({ item: item2 });\n    Parse.Object.saveAll([item1, item2, container1, container2]).then(function () {\n      const query = new Parse.Query(Container);\n      query.notEqualTo('item', item1);\n      query.find().then(function (results) {\n        equal(results.length, 1);\n        done();\n      });\n    });\n  });\n\n  it('skip', function (done) {\n    Parse.Object.saveAll([new TestObject(), new TestObject()]).then(function () {\n      const query = new Parse.Query(TestObject);\n      query.skip(1);\n      query.find().then(function (results) {\n        equal(results.length, 1);\n        query.skip(3);\n        query.find().then(function (results) {\n          equal(results.length, 0);\n          done();\n        });\n      });\n    });\n  });\n\n  it(\"skip doesn't affect count\", function (done) {\n    Parse.Object.saveAll([new TestObject(), new TestObject()]).then(function () {\n      const query = new Parse.Query(TestObject);\n      query.count().then(function (count) {\n        equal(count, 2);\n        query.skip(1);\n        query.count().then(function (count) {\n          equal(count, 2);\n          query.skip(3);\n          query.count().then(function (count) {\n            equal(count, 2);\n            done();\n          });\n        });\n      });\n    });\n  });\n\n  it('count', function (done) {\n    const makeBoxedNumber = function (i) {\n      return new BoxedNumber({ number: i });\n    };\n    Parse.Object.saveAll([0, 1, 2, 3, 4, 5, 6, 7, 8, 9].map(makeBoxedNumber)).then(function () {\n      const query = new Parse.Query(BoxedNumber);\n      query.greaterThan('number', 1);\n      query.count().then(function (count) {\n        equal(count, 8);\n        done();\n      });\n    });\n  });\n\n  it('order by ascending number', function (done) {\n    const makeBoxedNumber = function (i) {\n      return new BoxedNumber({ number: i });\n    };\n    Parse.Object.saveAll([3, 1, 2].map(makeBoxedNumber)).then(function () {\n      const query = new Parse.Query(BoxedNumber);\n      query.ascending('number');\n      query.find().then(function (results) {\n        equal(results.length, 3);\n        equal(results[0].get('number'), 1);\n        equal(results[1].get('number'), 2);\n        equal(results[2].get('number'), 3);\n        done();\n      });\n    });\n  });\n\n  it('order by descending number', function (done) {\n    const makeBoxedNumber = function (i) {\n      return new BoxedNumber({ number: i });\n    };\n    Parse.Object.saveAll([3, 1, 2].map(makeBoxedNumber)).then(function () {\n      const query = new Parse.Query(BoxedNumber);\n      query.descending('number');\n      query.find().then(function (results) {\n        equal(results.length, 3);\n        equal(results[0].get('number'), 3);\n        equal(results[1].get('number'), 2);\n        equal(results[2].get('number'), 1);\n        done();\n      });\n    });\n  });\n\n  it('can order on an object string field', function (done) {\n    const testSet = [\n      { sortField: { value: 'Z' } },\n      { sortField: { value: 'A' } },\n      { sortField: { value: 'M' } },\n    ];\n\n    const objects = testSet.map(e => new Parse.Object('Test', e));\n    Parse.Object.saveAll(objects)\n      .then(() => new Parse.Query('Test').addDescending('sortField.value').first())\n      .then(result => {\n        expect(result.get('sortField').value).toBe('Z');\n        return new Parse.Query('Test').addAscending('sortField.value').first();\n      })\n      .then(result => {\n        expect(result.get('sortField').value).toBe('A');\n        done();\n      })\n      .catch(done.fail);\n  });\n\n  it('can order on an object string field (level 2)', function (done) {\n    const testSet = [\n      { sortField: { value: { field: 'Z' } } },\n      { sortField: { value: { field: 'A' } } },\n      { sortField: { value: { field: 'M' } } },\n    ];\n\n    const objects = testSet.map(e => new Parse.Object('Test', e));\n    Parse.Object.saveAll(objects)\n      .then(() => new Parse.Query('Test').addDescending('sortField.value.field').first())\n      .then(result => {\n        expect(result.get('sortField').value.field).toBe('Z');\n        return new Parse.Query('Test').addAscending('sortField.value.field').first();\n      })\n      .then(result => {\n        expect(result.get('sortField').value.field).toBe('A');\n        done();\n      })\n      .catch(done.fail);\n  });\n\n  it('can order on an object number field', function (done) {\n    const testSet = [\n      { sortField: { value: 10 } },\n      { sortField: { value: 1 } },\n      { sortField: { value: 5 } },\n    ];\n\n    const objects = testSet.map(e => new Parse.Object('Test', e));\n    Parse.Object.saveAll(objects)\n      .then(() => new Parse.Query('Test').addDescending('sortField.value').first())\n      .then(result => {\n        expect(result.get('sortField').value).toBe(10);\n        return new Parse.Query('Test').addAscending('sortField.value').first();\n      })\n      .then(result => {\n        expect(result.get('sortField').value).toBe(1);\n        done();\n      })\n      .catch(done.fail);\n  });\n\n  it('can order on an object number field (level 2)', function (done) {\n    const testSet = [\n      { sortField: { value: { field: 10 } } },\n      { sortField: { value: { field: 1 } } },\n      { sortField: { value: { field: 5 } } },\n    ];\n\n    const objects = testSet.map(e => new Parse.Object('Test', e));\n    Parse.Object.saveAll(objects)\n      .then(() => new Parse.Query('Test').addDescending('sortField.value.field').first())\n      .then(result => {\n        expect(result.get('sortField').value.field).toBe(10);\n        return new Parse.Query('Test').addAscending('sortField.value.field').first();\n      })\n      .then(result => {\n        expect(result.get('sortField').value.field).toBe(1);\n        done();\n      })\n      .catch(done.fail);\n  });\n\n  it('order by ascending number then descending string', function (done) {\n    const strings = ['a', 'b', 'c', 'd'];\n    const makeBoxedNumber = function (num, i) {\n      return new BoxedNumber({ number: num, string: strings[i] });\n    };\n    Parse.Object.saveAll([3, 1, 3, 2].map(makeBoxedNumber)).then(function () {\n      const query = new Parse.Query(BoxedNumber);\n      query.ascending('number').addDescending('string');\n      query.find().then(function (results) {\n        equal(results.length, 4);\n        equal(results[0].get('number'), 1);\n        equal(results[0].get('string'), 'b');\n        equal(results[1].get('number'), 2);\n        equal(results[1].get('string'), 'd');\n        equal(results[2].get('number'), 3);\n        equal(results[2].get('string'), 'c');\n        equal(results[3].get('number'), 3);\n        equal(results[3].get('string'), 'a');\n        done();\n      });\n    });\n  });\n\n  it('order by descending number then ascending string', function (done) {\n    const strings = ['a', 'b', 'c', 'd'];\n    const makeBoxedNumber = function (num, i) {\n      return new BoxedNumber({ number: num, string: strings[i] });\n    };\n\n    const objects = [3, 1, 3, 2].map(makeBoxedNumber);\n    Parse.Object.saveAll(objects)\n      .then(() => {\n        const query = new Parse.Query(BoxedNumber);\n        query.descending('number').addAscending('string');\n        return query.find();\n      })\n      .then(\n        results => {\n          equal(results.length, 4);\n          equal(results[0].get('number'), 3);\n          equal(results[0].get('string'), 'a');\n          equal(results[1].get('number'), 3);\n          equal(results[1].get('string'), 'c');\n          equal(results[2].get('number'), 2);\n          equal(results[2].get('string'), 'd');\n          equal(results[3].get('number'), 1);\n          equal(results[3].get('string'), 'b');\n          done();\n        },\n        err => {\n          jfail(err);\n          done();\n        }\n      );\n  });\n\n  it('order by descending number and string', function (done) {\n    const strings = ['a', 'b', 'c', 'd'];\n    const makeBoxedNumber = function (num, i) {\n      return new BoxedNumber({ number: num, string: strings[i] });\n    };\n    Parse.Object.saveAll([3, 1, 3, 2].map(makeBoxedNumber)).then(function () {\n      const query = new Parse.Query(BoxedNumber);\n      query.descending('number,string');\n      query.find().then(function (results) {\n        equal(results.length, 4);\n        equal(results[0].get('number'), 3);\n        equal(results[0].get('string'), 'c');\n        equal(results[1].get('number'), 3);\n        equal(results[1].get('string'), 'a');\n        equal(results[2].get('number'), 2);\n        equal(results[2].get('string'), 'd');\n        equal(results[3].get('number'), 1);\n        equal(results[3].get('string'), 'b');\n        done();\n      });\n    });\n  });\n\n  it('order by descending number and string, with space', function (done) {\n    const strings = ['a', 'b', 'c', 'd'];\n    const makeBoxedNumber = function (num, i) {\n      return new BoxedNumber({ number: num, string: strings[i] });\n    };\n    Parse.Object.saveAll([3, 1, 3, 2].map(makeBoxedNumber)).then(\n      function () {\n        const query = new Parse.Query(BoxedNumber);\n        query.descending('number, string');\n        query.find().then(function (results) {\n          equal(results.length, 4);\n          equal(results[0].get('number'), 3);\n          equal(results[0].get('string'), 'c');\n          equal(results[1].get('number'), 3);\n          equal(results[1].get('string'), 'a');\n          equal(results[2].get('number'), 2);\n          equal(results[2].get('string'), 'd');\n          equal(results[3].get('number'), 1);\n          equal(results[3].get('string'), 'b');\n          done();\n        });\n      },\n      err => {\n        jfail(err);\n        done();\n      }\n    );\n  });\n\n  it('order by descending number and string, with array arg', function (done) {\n    const strings = ['a', 'b', 'c', 'd'];\n    const makeBoxedNumber = function (num, i) {\n      return new BoxedNumber({ number: num, string: strings[i] });\n    };\n    Parse.Object.saveAll([3, 1, 3, 2].map(makeBoxedNumber)).then(function () {\n      const query = new Parse.Query(BoxedNumber);\n      query.descending(['number', 'string']);\n      query.find().then(function (results) {\n        equal(results.length, 4);\n        equal(results[0].get('number'), 3);\n        equal(results[0].get('string'), 'c');\n        equal(results[1].get('number'), 3);\n        equal(results[1].get('string'), 'a');\n        equal(results[2].get('number'), 2);\n        equal(results[2].get('string'), 'd');\n        equal(results[3].get('number'), 1);\n        equal(results[3].get('string'), 'b');\n        done();\n      });\n    });\n  });\n\n  it('order by descending number and string, with multiple args', function (done) {\n    const strings = ['a', 'b', 'c', 'd'];\n    const makeBoxedNumber = function (num, i) {\n      return new BoxedNumber({ number: num, string: strings[i] });\n    };\n    Parse.Object.saveAll([3, 1, 3, 2].map(makeBoxedNumber)).then(function () {\n      const query = new Parse.Query(BoxedNumber);\n      query.descending('number', 'string');\n      query.find().then(function (results) {\n        equal(results.length, 4);\n        equal(results[0].get('number'), 3);\n        equal(results[0].get('string'), 'c');\n        equal(results[1].get('number'), 3);\n        equal(results[1].get('string'), 'a');\n        equal(results[2].get('number'), 2);\n        equal(results[2].get('string'), 'd');\n        equal(results[3].get('number'), 1);\n        equal(results[3].get('string'), 'b');\n        done();\n      });\n    });\n  });\n\n  it(\"can't order by password\", function (done) {\n    const makeBoxedNumber = function (i) {\n      return new BoxedNumber({ number: i });\n    };\n    Parse.Object.saveAll([3, 1, 2].map(makeBoxedNumber)).then(function () {\n      const query = new Parse.Query(BoxedNumber);\n      query.ascending('_password');\n      query\n        .find()\n        .then(done.fail)\n        .catch(e => expect(e.code).toBe(Parse.Error.INVALID_KEY_NAME))\n        .then(done);\n    });\n  });\n\n  it('order by _created_at', function (done) {\n    const makeBoxedNumber = function (i) {\n      return new BoxedNumber({ number: i });\n    };\n    const numbers = [3, 1, 2].map(makeBoxedNumber);\n    numbers[0]\n      .save()\n      .then(() => {\n        return numbers[1].save();\n      })\n      .then(() => {\n        return numbers[2].save();\n      })\n      .then(function () {\n        const query = new Parse.Query(BoxedNumber);\n        query.ascending('_created_at');\n        query.find().then(function (results) {\n          equal(results.length, 3);\n          equal(results[0].get('number'), 3);\n          equal(results[1].get('number'), 1);\n          equal(results[2].get('number'), 2);\n          done();\n        }, done.fail);\n      });\n  });\n\n  it('order by createdAt', function (done) {\n    const makeBoxedNumber = function (i) {\n      return new BoxedNumber({ number: i });\n    };\n    const numbers = [3, 1, 2].map(makeBoxedNumber);\n    numbers[0]\n      .save()\n      .then(() => {\n        return numbers[1].save();\n      })\n      .then(() => {\n        return numbers[2].save();\n      })\n      .then(function () {\n        const query = new Parse.Query(BoxedNumber);\n        query.descending('createdAt');\n        query.find().then(function (results) {\n          equal(results.length, 3);\n          equal(results[0].get('number'), 2);\n          equal(results[1].get('number'), 1);\n          equal(results[2].get('number'), 3);\n          done();\n        });\n      });\n  });\n\n  it('order by _updated_at', function (done) {\n    const makeBoxedNumber = function (i) {\n      return new BoxedNumber({ number: i });\n    };\n    const numbers = [3, 1, 2].map(makeBoxedNumber);\n    numbers[0]\n      .save()\n      .then(() => {\n        return numbers[1].save();\n      })\n      .then(() => {\n        return numbers[2].save();\n      })\n      .then(function () {\n        numbers[1].set('number', 4);\n        numbers[1].save().then(function () {\n          const query = new Parse.Query(BoxedNumber);\n          query.ascending('_updated_at');\n          query.find().then(function (results) {\n            equal(results.length, 3);\n            equal(results[0].get('number'), 3);\n            equal(results[1].get('number'), 2);\n            equal(results[2].get('number'), 4);\n            done();\n          });\n        });\n      });\n  });\n\n  it('order by updatedAt', function (done) {\n    const makeBoxedNumber = function (i) {\n      return new BoxedNumber({ number: i });\n    };\n    const numbers = [3, 1, 2].map(makeBoxedNumber);\n    numbers[0]\n      .save()\n      .then(() => {\n        return numbers[1].save();\n      })\n      .then(() => {\n        return numbers[2].save();\n      })\n      .then(function () {\n        numbers[1].set('number', 4);\n        numbers[1].save().then(function () {\n          const query = new Parse.Query(BoxedNumber);\n          query.descending('_updated_at');\n          query.find().then(function (results) {\n            equal(results.length, 3);\n            equal(results[0].get('number'), 4);\n            equal(results[1].get('number'), 2);\n            equal(results[2].get('number'), 3);\n            done();\n          });\n        });\n      });\n  });\n\n  // Returns a promise\n  function makeTimeObject(start, i) {\n    const time = new Date();\n    time.setSeconds(start.getSeconds() + i);\n    const item = new TestObject({ name: 'item' + i, time: time });\n    return item.save();\n  }\n\n  // Returns a promise for all the time objects\n  function makeThreeTimeObjects() {\n    const start = new Date();\n    let one, two, three;\n    return makeTimeObject(start, 1)\n      .then(o1 => {\n        one = o1;\n        return makeTimeObject(start, 2);\n      })\n      .then(o2 => {\n        two = o2;\n        return makeTimeObject(start, 3);\n      })\n      .then(o3 => {\n        three = o3;\n        return [one, two, three];\n      });\n  }\n\n  it('time equality', function (done) {\n    makeThreeTimeObjects().then(function (list) {\n      const query = new Parse.Query(TestObject);\n      query.equalTo('time', list[1].get('time'));\n      query.find().then(function (results) {\n        equal(results.length, 1);\n        equal(results[0].get('name'), 'item2');\n        done();\n      });\n    });\n  });\n\n  it('time lessThan', function (done) {\n    makeThreeTimeObjects().then(function (list) {\n      const query = new Parse.Query(TestObject);\n      query.lessThan('time', list[2].get('time'));\n      query.find().then(function (results) {\n        equal(results.length, 2);\n        done();\n      });\n    });\n  });\n\n  // This test requires Date objects to be consistently stored as a Date.\n  it('time createdAt', function (done) {\n    makeThreeTimeObjects().then(function (list) {\n      const query = new Parse.Query(TestObject);\n      query.greaterThanOrEqualTo('createdAt', list[0].createdAt);\n      query.find().then(function (results) {\n        equal(results.length, 3);\n        done();\n      });\n    });\n  });\n\n  it('matches string', function (done) {\n    const thing1 = new TestObject();\n    thing1.set('myString', 'football');\n    const thing2 = new TestObject();\n    thing2.set('myString', 'soccer');\n    Parse.Object.saveAll([thing1, thing2]).then(function () {\n      const query = new Parse.Query(TestObject);\n      query.matches('myString', '^fo*\\\\wb[^o]l+$');\n      query.find().then(function (results) {\n        equal(results.length, 1);\n        done();\n      });\n    });\n  });\n\n  it('matches regex', function (done) {\n    const thing1 = new TestObject();\n    thing1.set('myString', 'football');\n    const thing2 = new TestObject();\n    thing2.set('myString', 'soccer');\n    Parse.Object.saveAll([thing1, thing2]).then(function () {\n      const query = new Parse.Query(TestObject);\n      query.matches('myString', /^fo*\\wb[^o]l+$/);\n      query.find().then(function (results) {\n        equal(results.length, 1);\n        done();\n      });\n    });\n  });\n\n  it('case insensitive regex success', function (done) {\n    const thing = new TestObject();\n    thing.set('myString', 'football');\n    Parse.Object.saveAll([thing]).then(function () {\n      const query = new Parse.Query(TestObject);\n      query.matches('myString', 'FootBall', 'i');\n      query.find().then(done);\n    });\n  });\n\n  it('regexes with invalid options fail', function (done) {\n    const query = new Parse.Query(TestObject);\n    query.matches('myString', 'FootBall', 'some invalid option');\n    query\n      .find()\n      .then(done.fail)\n      .catch(e => expect(e.code).toBe(Parse.Error.INVALID_QUERY))\n      .then(done);\n  });\n\n  it('Use a regex that requires all modifiers', function (done) {\n    const thing = new TestObject();\n    thing.set('myString', 'PArSe\\nCom');\n    Parse.Object.saveAll([thing]).then(function () {\n      const query = new Parse.Query(TestObject);\n      query.matches(\n        'myString',\n        \"parse # First fragment. We'll write this in one case but match insensitively\\n\" +\n          '.com  # Second fragment. This can be separated by any character, including newline;' +\n          'however, this comment must end with a newline to recognize it as a comment\\n',\n        'mixs'\n      );\n      query.find().then(\n        function (results) {\n          equal(results.length, 1);\n          done();\n        },\n        function (err) {\n          jfail(err);\n          done();\n        }\n      );\n    });\n  });\n\n  it('Regular expression constructor includes modifiers inline', function (done) {\n    const thing = new TestObject();\n    thing.set('myString', '\\n\\nbuffer\\n\\nparse.COM');\n    Parse.Object.saveAll([thing]).then(function () {\n      const query = new Parse.Query(TestObject);\n      query.matches('myString', /parse\\.com/im);\n      query.find().then(function (results) {\n        equal(results.length, 1);\n        done();\n      });\n    });\n  });\n\n  const someAscii =\n    \"\\\\E' !\\\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTU\" +\n    \"VWXYZ[\\\\]^_`abcdefghijklmnopqrstuvwxyz{|}~'\";\n\n  it('contains', function (done) {\n    Parse.Object.saveAll([\n      new TestObject({ myString: 'zax' + someAscii + 'qub' }),\n      new TestObject({ myString: 'start' + someAscii }),\n      new TestObject({ myString: someAscii + 'end' }),\n      new TestObject({ myString: someAscii }),\n    ]).then(function () {\n      const query = new Parse.Query(TestObject);\n      query.contains('myString', someAscii);\n      query.find().then(function (results) {\n        equal(results.length, 4);\n        done();\n      });\n    });\n  });\n\n  it('nested contains', done => {\n    const sender1 = { group: ['A', 'B'] };\n    const sender2 = { group: ['A', 'C'] };\n    const sender3 = { group: ['B', 'C'] };\n    const obj1 = new TestObject({ sender: sender1 });\n    const obj2 = new TestObject({ sender: sender2 });\n    const obj3 = new TestObject({ sender: sender3 });\n    Parse.Object.saveAll([obj1, obj2, obj3])\n      .then(() => {\n        const query = new Parse.Query(TestObject);\n        query.contains('sender.group', 'A');\n        return query.find();\n      })\n      .then(results => {\n        equal(results.length, 2);\n        done();\n      }, done.fail);\n  });\n\n  it('startsWith', function (done) {\n    Parse.Object.saveAll([\n      new TestObject({ myString: 'zax' + someAscii + 'qub' }),\n      new TestObject({ myString: 'start' + someAscii }),\n      new TestObject({ myString: someAscii + 'end' }),\n      new TestObject({ myString: someAscii }),\n    ]).then(function () {\n      const query = new Parse.Query(TestObject);\n      query.startsWith('myString', someAscii);\n      query.find().then(function (results) {\n        equal(results.length, 2);\n        done();\n      });\n    });\n  });\n\n  it('endsWith', function (done) {\n    Parse.Object.saveAll([\n      new TestObject({ myString: 'zax' + someAscii + 'qub' }),\n      new TestObject({ myString: 'start' + someAscii }),\n      new TestObject({ myString: someAscii + 'end' }),\n      new TestObject({ myString: someAscii }),\n    ]).then(function () {\n      const query = new Parse.Query(TestObject);\n      query.endsWith('myString', someAscii);\n      query.find().then(function (results) {\n        equal(results.length, 2);\n        done();\n      });\n    });\n  });\n\n  it('exists', function (done) {\n    const objects = [];\n    for (const i of [0, 1, 2, 3, 4, 5, 6, 7, 8]) {\n      const item = new TestObject();\n      if (i % 2 === 0) {\n        item.set('x', i + 1);\n      } else {\n        item.set('y', i + 1);\n      }\n      objects.push(item);\n    }\n    Parse.Object.saveAll(objects).then(function () {\n      const query = new Parse.Query(TestObject);\n      query.exists('x');\n      query.find().then(function (results) {\n        equal(results.length, 5);\n        for (const result of results) {\n          ok(result.get('x'));\n        }\n        done();\n      });\n    });\n  });\n\n  it('doesNotExist', function (done) {\n    const objects = [];\n    for (const i of [0, 1, 2, 3, 4, 5, 6, 7, 8]) {\n      const item = new TestObject();\n      if (i % 2 === 0) {\n        item.set('x', i + 1);\n      } else {\n        item.set('y', i + 1);\n      }\n      objects.push(item);\n    }\n    Parse.Object.saveAll(objects).then(function () {\n      const query = new Parse.Query(TestObject);\n      query.doesNotExist('x');\n      query.find().then(function (results) {\n        equal(results.length, 4);\n        for (const result of results) {\n          ok(result.get('y'));\n        }\n        done();\n      });\n    });\n  });\n\n  it('exists relation', function (done) {\n    const objects = [];\n    for (const i of [0, 1, 2, 3, 4, 5, 6, 7, 8]) {\n      const container = new Container();\n      if (i % 2 === 0) {\n        const item = new TestObject();\n        item.set('x', i);\n        container.set('x', item);\n        objects.push(item);\n      } else {\n        container.set('y', i);\n      }\n      objects.push(container);\n    }\n    Parse.Object.saveAll(objects).then(function () {\n      const query = new Parse.Query(Container);\n      query.exists('x');\n      query.find().then(function (results) {\n        equal(results.length, 5);\n        for (const result of results) {\n          ok(result.get('x'));\n        }\n        done();\n      });\n    });\n  });\n\n  it('doesNotExist relation', function (done) {\n    const objects = [];\n    for (const i of [0, 1, 2, 3, 4, 5, 6, 7]) {\n      const container = new Container();\n      if (i % 2 === 0) {\n        const item = new TestObject();\n        item.set('x', i);\n        container.set('x', item);\n        objects.push(item);\n      } else {\n        container.set('y', i);\n      }\n      objects.push(container);\n    }\n    Parse.Object.saveAll(objects).then(function () {\n      const query = new Parse.Query(Container);\n      query.doesNotExist('x');\n      query.find().then(function (results) {\n        equal(results.length, 4);\n        for (const result of results) {\n          ok(result.get('y'));\n        }\n        done();\n      });\n    });\n  });\n\n  it(\"don't include by default\", function (done) {\n    const child = new TestObject();\n    const parent = new Container();\n    child.set('foo', 'bar');\n    parent.set('child', child);\n    Parse.Object.saveAll([child, parent]).then(function () {\n      child._clearServerData();\n      const query = new Parse.Query(Container);\n      query.find().then(function (results) {\n        equal(results.length, 1);\n        const parentAgain = results[0];\n        const goodURL = Parse.serverURL;\n        Parse.serverURL = 'YAAAAAAAAARRRRRGGGGGGGGG';\n        const childAgain = parentAgain.get('child');\n        ok(childAgain);\n        equal(childAgain.get('foo'), undefined);\n        Parse.serverURL = goodURL;\n        done();\n      });\n    });\n  });\n\n  it('include relation', function (done) {\n    const child = new TestObject();\n    const parent = new Container();\n    child.set('foo', 'bar');\n    parent.set('child', child);\n    Parse.Object.saveAll([child, parent]).then(function () {\n      const query = new Parse.Query(Container);\n      query.include('child');\n      query.find().then(function (results) {\n        equal(results.length, 1);\n        const parentAgain = results[0];\n        const goodURL = Parse.serverURL;\n        Parse.serverURL = 'YAAAAAAAAARRRRRGGGGGGGGG';\n        const childAgain = parentAgain.get('child');\n        ok(childAgain);\n        equal(childAgain.get('foo'), 'bar');\n        Parse.serverURL = goodURL;\n        done();\n      });\n    });\n  });\n\n  it('include relation array', function (done) {\n    const child = new TestObject();\n    const parent = new Container();\n    child.set('foo', 'bar');\n    parent.set('child', child);\n    Parse.Object.saveAll([child, parent]).then(function () {\n      const query = new Parse.Query(Container);\n      query.include(['child']);\n      query.find().then(function (results) {\n        equal(results.length, 1);\n        const parentAgain = results[0];\n        const goodURL = Parse.serverURL;\n        Parse.serverURL = 'YAAAAAAAAARRRRRGGGGGGGGG';\n        const childAgain = parentAgain.get('child');\n        ok(childAgain);\n        equal(childAgain.get('foo'), 'bar');\n        Parse.serverURL = goodURL;\n        done();\n      });\n    });\n  });\n\n  it('nested include', function (done) {\n    const Child = Parse.Object.extend('Child');\n    const Parent = Parse.Object.extend('Parent');\n    const Grandparent = Parse.Object.extend('Grandparent');\n    const objects = [];\n    for (let i = 0; i < 5; ++i) {\n      const grandparent = new Grandparent({\n        z: i,\n        parent: new Parent({\n          y: i,\n          child: new Child({\n            x: i,\n          }),\n        }),\n      });\n      objects.push(grandparent);\n    }\n\n    Parse.Object.saveAll(objects).then(function () {\n      const query = new Parse.Query(Grandparent);\n      query.include(['parent.child']);\n      query.find().then(function (results) {\n        equal(results.length, 5);\n        for (const object of results) {\n          equal(object.get('z'), object.get('parent').get('y'));\n          equal(object.get('z'), object.get('parent').get('child').get('x'));\n        }\n        done();\n      });\n    });\n  });\n\n  it(\"include doesn't make dirty wrong\", function (done) {\n    const Parent = Parse.Object.extend('ParentObject');\n    const Child = Parse.Object.extend('ChildObject');\n    const parent = new Parent();\n    const child = new Child();\n    child.set('foo', 'bar');\n    parent.set('child', child);\n\n    Parse.Object.saveAll([child, parent]).then(function () {\n      const query = new Parse.Query(Parent);\n      query.include('child');\n      query.find().then(function (results) {\n        equal(results.length, 1);\n        const parentAgain = results[0];\n        const childAgain = parentAgain.get('child');\n        equal(childAgain.id, child.id);\n        equal(parentAgain.id, parent.id);\n        equal(childAgain.get('foo'), 'bar');\n        equal(false, parentAgain.dirty());\n        equal(false, childAgain.dirty());\n        done();\n      });\n    });\n  });\n\n  it('properly includes array', done => {\n    const objects = [];\n    let total = 0;\n    while (objects.length != 5) {\n      const object = new Parse.Object('AnObject');\n      object.set('key', objects.length);\n      total += objects.length;\n      objects.push(object);\n    }\n    Parse.Object.saveAll(objects)\n      .then(() => {\n        const object = new Parse.Object('AContainer');\n        object.set('objects', objects);\n        return object.save();\n      })\n      .then(() => {\n        const query = new Parse.Query('AContainer');\n        query.include('objects');\n        return query.find();\n      })\n      .then(\n        results => {\n          expect(results.length).toBe(1);\n          const res = results[0];\n          const objects = res.get('objects');\n          expect(objects.length).toBe(5);\n          objects.forEach(object => {\n            total -= object.get('key');\n          });\n          expect(total).toBe(0);\n          done();\n        },\n        () => {\n          fail('should not fail');\n          done();\n        }\n      );\n  });\n\n  it('properly includes array of mixed objects', done => {\n    const objects = [];\n    let total = 0;\n    while (objects.length != 5) {\n      const object = new Parse.Object('AnObject');\n      object.set('key', objects.length);\n      total += objects.length;\n      objects.push(object);\n    }\n    while (objects.length != 10) {\n      const object = new Parse.Object('AnotherObject');\n      object.set('key', objects.length);\n      total += objects.length;\n      objects.push(object);\n    }\n    Parse.Object.saveAll(objects)\n      .then(() => {\n        const object = new Parse.Object('AContainer');\n        object.set('objects', objects);\n        return object.save();\n      })\n      .then(() => {\n        const query = new Parse.Query('AContainer');\n        query.include('objects');\n        return query.find();\n      })\n      .then(\n        results => {\n          expect(results.length).toBe(1);\n          const res = results[0];\n          const objects = res.get('objects');\n          expect(objects.length).toBe(10);\n          objects.forEach(object => {\n            total -= object.get('key');\n          });\n          expect(total).toBe(0);\n          done();\n        },\n        e => {\n          fail('should not fail');\n          fail(JSON.stringify(e));\n          done();\n        }\n      );\n  });\n\n  it('properly nested array of mixed objects with bad ids', done => {\n    const objects = [];\n    let total = 0;\n    while (objects.length != 5) {\n      const object = new Parse.Object('AnObject');\n      object.set('key', objects.length);\n      objects.push(object);\n    }\n    while (objects.length != 10) {\n      const object = new Parse.Object('AnotherObject');\n      object.set('key', objects.length);\n      objects.push(object);\n    }\n    Parse.Object.saveAll(objects)\n      .then(() => {\n        const object = new Parse.Object('AContainer');\n        for (let i = 0; i < objects.length; i++) {\n          if (i % 2 == 0) {\n            objects[i].id = 'randomThing';\n          } else {\n            total += objects[i].get('key');\n          }\n        }\n        object.set('objects', objects);\n        return object.save();\n      })\n      .then(() => {\n        const query = new Parse.Query('AContainer');\n        query.include('objects');\n        return query.find();\n      })\n      .then(\n        results => {\n          expect(results.length).toBe(1);\n          const res = results[0];\n          const objects = res.get('objects');\n          expect(objects.length).toBe(5);\n          objects.forEach(object => {\n            total -= object.get('key');\n          });\n          expect(total).toBe(0);\n          done();\n        },\n        err => {\n          jfail(err);\n          fail('should not fail');\n          done();\n        }\n      );\n  });\n\n  it('properly fetches nested pointers', done => {\n    const color = new Parse.Object('Color');\n    color.set('hex', '#133733');\n    const circle = new Parse.Object('Circle');\n    circle.set('radius', 1337);\n\n    Parse.Object.saveAll([color, circle])\n      .then(() => {\n        circle.set('color', color);\n        const badCircle = new Parse.Object('Circle');\n        badCircle.id = 'badId';\n        const complexFigure = new Parse.Object('ComplexFigure');\n        complexFigure.set('consistsOf', [circle, badCircle]);\n        return complexFigure.save();\n      })\n      .then(() => {\n        const q = new Parse.Query('ComplexFigure');\n        q.include('consistsOf.color');\n        return q.find();\n      })\n      .then(\n        results => {\n          expect(results.length).toBe(1);\n          const figure = results[0];\n          expect(figure.get('consistsOf').length).toBe(1);\n          expect(figure.get('consistsOf')[0].get('color').get('hex')).toBe('#133733');\n          done();\n        },\n        () => {\n          fail('should not fail');\n          done();\n        }\n      );\n  });\n\n  it('result object creation uses current extension', function (done) {\n    const ParentObject = Parse.Object.extend({ className: 'ParentObject' });\n    // Add a foo() method to ChildObject.\n    let ChildObject = Parse.Object.extend('ChildObject', {\n      foo: function () {\n        return 'foo';\n      },\n    });\n\n    const parent = new ParentObject();\n    const child = new ChildObject();\n    parent.set('child', child);\n    Parse.Object.saveAll([child, parent]).then(function () {\n      // Add a bar() method to ChildObject.\n      ChildObject = Parse.Object.extend('ChildObject', {\n        bar: function () {\n          return 'bar';\n        },\n      });\n\n      const query = new Parse.Query(ParentObject);\n      query.include('child');\n      query.find().then(function (results) {\n        equal(results.length, 1);\n        const parentAgain = results[0];\n        const childAgain = parentAgain.get('child');\n        equal(childAgain.foo(), 'foo');\n        equal(childAgain.bar(), 'bar');\n        done();\n      });\n    });\n  });\n\n  it('matches query', function (done) {\n    const ParentObject = Parse.Object.extend('ParentObject');\n    const ChildObject = Parse.Object.extend('ChildObject');\n    const objects = [];\n    for (let i = 0; i < 10; ++i) {\n      objects.push(\n        new ParentObject({\n          child: new ChildObject({ x: i }),\n          x: 10 + i,\n        })\n      );\n    }\n    Parse.Object.saveAll(objects).then(function () {\n      const subQuery = new Parse.Query(ChildObject);\n      subQuery.greaterThan('x', 5);\n      const query = new Parse.Query(ParentObject);\n      query.matchesQuery('child', subQuery);\n      query.find().then(function (results) {\n        equal(results.length, 4);\n        for (const object of results) {\n          ok(object.get('x') > 15);\n        }\n        const query = new Parse.Query(ParentObject);\n        query.doesNotMatchQuery('child', subQuery);\n        query.find().then(function (results) {\n          equal(results.length, 6);\n          for (const object of results) {\n            ok(object.get('x') >= 10);\n            ok(object.get('x') <= 15);\n            done();\n          }\n        });\n      });\n    });\n  });\n\n  it('select query', function (done) {\n    const RestaurantObject = Parse.Object.extend('Restaurant');\n    const PersonObject = Parse.Object.extend('Person');\n    const objects = [\n      new RestaurantObject({ ratings: 5, location: 'Djibouti' }),\n      new RestaurantObject({ ratings: 3, location: 'Ouagadougou' }),\n      new PersonObject({ name: 'Bob', hometown: 'Djibouti' }),\n      new PersonObject({ name: 'Tom', hometown: 'Ouagadougou' }),\n      new PersonObject({ name: 'Billy', hometown: 'Detroit' }),\n    ];\n\n    Parse.Object.saveAll(objects).then(function () {\n      const query = new Parse.Query(RestaurantObject);\n      query.greaterThan('ratings', 4);\n      const mainQuery = new Parse.Query(PersonObject);\n      mainQuery.matchesKeyInQuery('hometown', 'location', query);\n      mainQuery.find().then(function (results) {\n        equal(results.length, 1);\n        equal(results[0].get('name'), 'Bob');\n        done();\n      });\n    });\n  });\n\n  it('$select inside $or', done => {\n    const Restaurant = Parse.Object.extend('Restaurant');\n    const Person = Parse.Object.extend('Person');\n    const objects = [\n      new Restaurant({ ratings: 5, location: 'Djibouti' }),\n      new Restaurant({ ratings: 3, location: 'Ouagadougou' }),\n      new Person({ name: 'Bob', hometown: 'Djibouti' }),\n      new Person({ name: 'Tom', hometown: 'Ouagadougou' }),\n      new Person({ name: 'Billy', hometown: 'Detroit' }),\n    ];\n\n    Parse.Object.saveAll(objects)\n      .then(() => {\n        const subquery = new Parse.Query(Restaurant);\n        subquery.greaterThan('ratings', 4);\n        const query1 = new Parse.Query(Person);\n        query1.matchesKeyInQuery('hometown', 'location', subquery);\n        const query2 = new Parse.Query(Person);\n        query2.equalTo('name', 'Tom');\n        const query = Parse.Query.or(query1, query2);\n        return query.find();\n      })\n      .then(\n        results => {\n          expect(results.length).toEqual(2);\n          done();\n        },\n        error => {\n          jfail(error);\n          done();\n        }\n      );\n  });\n\n  it('$nor valid query', done => {\n    const objects = Array.from(Array(10).keys()).map(rating => {\n      return new TestObject({ rating: rating });\n    });\n\n    const highValue = 5;\n    const lowValue = 3;\n    const options = Object.assign({}, masterKeyOptions, {\n      qs: {\n        where: JSON.stringify({\n          $nor: [{ rating: { $gt: highValue } }, { rating: { $lte: lowValue } }],\n        }),\n      },\n    });\n\n    Parse.Object.saveAll(objects)\n      .then(() => {\n        return request(Object.assign({ url: Parse.serverURL + '/classes/TestObject' }, options));\n      })\n      .then(response => {\n        const results = response.data;\n        expect(results.results.length).toBe(highValue - lowValue);\n        expect(results.results.every(res => res.rating > lowValue && res.rating <= highValue)).toBe(\n          true\n        );\n        done();\n      });\n  });\n\n  it('$nor invalid query - empty array', done => {\n    const options = Object.assign({}, masterKeyOptions, {\n      qs: {\n        where: JSON.stringify({ $nor: [] }),\n      },\n    });\n    const obj = new TestObject();\n    obj\n      .save()\n      .then(() => {\n        return request(Object.assign({ url: Parse.serverURL + '/classes/TestObject' }, options));\n      })\n      .then(done.fail)\n      .catch(response => {\n        equal(response.data.code, Parse.Error.INVALID_QUERY);\n        done();\n      });\n  });\n\n  it('$nor invalid query - wrong type', done => {\n    const options = Object.assign({}, masterKeyOptions, {\n      qs: {\n        where: JSON.stringify({ $nor: 1337 }),\n      },\n    });\n    const obj = new TestObject();\n    obj\n      .save()\n      .then(() => {\n        return request(Object.assign({ url: Parse.serverURL + '/classes/TestObject' }, options));\n      })\n      .then(done.fail)\n      .catch(response => {\n        equal(response.data.code, Parse.Error.INVALID_QUERY);\n        done();\n      });\n  });\n\n  it('dontSelect query', function (done) {\n    const RestaurantObject = Parse.Object.extend('Restaurant');\n    const PersonObject = Parse.Object.extend('Person');\n    const objects = [\n      new RestaurantObject({ ratings: 5, location: 'Djibouti' }),\n      new RestaurantObject({ ratings: 3, location: 'Ouagadougou' }),\n      new PersonObject({ name: 'Bob', hometown: 'Djibouti' }),\n      new PersonObject({ name: 'Tom', hometown: 'Ouagadougou' }),\n      new PersonObject({ name: 'Billy', hometown: 'Djibouti' }),\n    ];\n\n    Parse.Object.saveAll(objects).then(function () {\n      const query = new Parse.Query(RestaurantObject);\n      query.greaterThan('ratings', 4);\n      const mainQuery = new Parse.Query(PersonObject);\n      mainQuery.doesNotMatchKeyInQuery('hometown', 'location', query);\n      mainQuery.find().then(function (results) {\n        equal(results.length, 1);\n        equal(results[0].get('name'), 'Tom');\n        done();\n      });\n    });\n  });\n\n  it('dontSelect query without conditions', function (done) {\n    const RestaurantObject = Parse.Object.extend('Restaurant');\n    const PersonObject = Parse.Object.extend('Person');\n    const objects = [\n      new RestaurantObject({ location: 'Djibouti' }),\n      new RestaurantObject({ location: 'Ouagadougou' }),\n      new PersonObject({ name: 'Bob', hometown: 'Djibouti' }),\n      new PersonObject({ name: 'Tom', hometown: 'Yoloblahblahblah' }),\n      new PersonObject({ name: 'Billy', hometown: 'Ouagadougou' }),\n    ];\n\n    Parse.Object.saveAll(objects).then(function () {\n      const query = new Parse.Query(RestaurantObject);\n      const mainQuery = new Parse.Query(PersonObject);\n      mainQuery.doesNotMatchKeyInQuery('hometown', 'location', query);\n      mainQuery.find().then(results => {\n        equal(results.length, 1);\n        equal(results[0].get('name'), 'Tom');\n        done();\n      });\n    });\n  });\n\n  it('equalTo on same column as $dontSelect should not break $dontSelect functionality (#3678)', function (done) {\n    const AuthorObject = Parse.Object.extend('Author');\n    const BlockedObject = Parse.Object.extend('Blocked');\n    const PostObject = Parse.Object.extend('Post');\n\n    let postAuthor = null;\n    let requestUser = null;\n\n    return new AuthorObject({ name: 'Julius' })\n      .save()\n      .then(user => {\n        postAuthor = user;\n        return new AuthorObject({ name: 'Bob' }).save();\n      })\n      .then(user => {\n        requestUser = user;\n        const objects = [\n          new PostObject({ author: postAuthor, title: 'Lorem ipsum' }),\n          new PostObject({ author: requestUser, title: 'Kafka' }),\n          new PostObject({ author: requestUser, title: 'Brown fox' }),\n          new BlockedObject({\n            blockedBy: postAuthor,\n            blockedUser: requestUser,\n          }),\n        ];\n        return Parse.Object.saveAll(objects);\n      })\n      .then(() => {\n        const banListQuery = new Parse.Query(BlockedObject);\n        banListQuery.equalTo('blockedUser', requestUser);\n\n        return new Parse.Query(PostObject)\n          .equalTo('author', postAuthor)\n          .doesNotMatchKeyInQuery('author', 'blockedBy', banListQuery)\n          .find()\n          .then(r => {\n            expect(r.length).toEqual(0);\n            done();\n          }, done.fail);\n      });\n  });\n\n  it('multiple dontSelect query', function (done) {\n    const RestaurantObject = Parse.Object.extend('Restaurant');\n    const PersonObject = Parse.Object.extend('Person');\n    const objects = [\n      new RestaurantObject({ ratings: 7, location: 'Djibouti2' }),\n      new RestaurantObject({ ratings: 5, location: 'Djibouti' }),\n      new RestaurantObject({ ratings: 3, location: 'Ouagadougou' }),\n      new PersonObject({ name: 'Bob2', hometown: 'Djibouti2' }),\n      new PersonObject({ name: 'Bob', hometown: 'Djibouti' }),\n      new PersonObject({ name: 'Tom', hometown: 'Ouagadougou' }),\n    ];\n\n    Parse.Object.saveAll(objects).then(function () {\n      const query = new Parse.Query(RestaurantObject);\n      query.greaterThan('ratings', 6);\n      const query2 = new Parse.Query(RestaurantObject);\n      query2.lessThan('ratings', 4);\n      const subQuery = new Parse.Query(PersonObject);\n      subQuery.matchesKeyInQuery('hometown', 'location', query);\n      const subQuery2 = new Parse.Query(PersonObject);\n      subQuery2.matchesKeyInQuery('hometown', 'location', query2);\n      const mainQuery = new Parse.Query(PersonObject);\n      mainQuery.doesNotMatchKeyInQuery('objectId', 'objectId', Parse.Query.or(subQuery, subQuery2));\n      mainQuery.find().then(function (results) {\n        equal(results.length, 1);\n        equal(results[0].get('name'), 'Bob');\n        done();\n      });\n    });\n  });\n\n  it('include user', function (done) {\n    Parse.User.signUp('bob', 'password', { age: 21 }).then(function (user) {\n      const TestObject = Parse.Object.extend('TestObject');\n      const obj = new TestObject();\n      obj\n        .save({\n          owner: user,\n        })\n        .then(function (obj) {\n          const query = new Parse.Query(TestObject);\n          query.include('owner');\n          query.get(obj.id).then(function (objAgain) {\n            equal(objAgain.id, obj.id);\n            ok(objAgain.get('owner') instanceof Parse.User);\n            equal(objAgain.get('owner').get('age'), 21);\n            done();\n          }, done.fail);\n        }, done.fail);\n    }, done.fail);\n  });\n\n  it('or queries', function (done) {\n    const objects = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9].map(function (x) {\n      const object = new Parse.Object('BoxedNumber');\n      object.set('x', x);\n      return object;\n    });\n    Parse.Object.saveAll(objects).then(function () {\n      const query1 = new Parse.Query('BoxedNumber');\n      query1.lessThan('x', 2);\n      const query2 = new Parse.Query('BoxedNumber');\n      query2.greaterThan('x', 5);\n      const orQuery = Parse.Query.or(query1, query2);\n      orQuery.find().then(function (results) {\n        equal(results.length, 6);\n        for (const number of results) {\n          ok(number.get('x') < 2 || number.get('x') > 5);\n        }\n        done();\n      });\n    });\n  });\n\n  // This relies on matchesQuery aka the $inQuery operator\n  it('or complex queries', function (done) {\n    const objects = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9].map(function (x) {\n      const child = new Parse.Object('Child');\n      child.set('x', x);\n      const parent = new Parse.Object('Parent');\n      parent.set('child', child);\n      parent.set('y', x);\n      return parent;\n    });\n\n    Parse.Object.saveAll(objects).then(function () {\n      const subQuery = new Parse.Query('Child');\n      subQuery.equalTo('x', 4);\n      const query1 = new Parse.Query('Parent');\n      query1.matchesQuery('child', subQuery);\n      const query2 = new Parse.Query('Parent');\n      query2.lessThan('y', 2);\n      const orQuery = Parse.Query.or(query1, query2);\n      orQuery.find().then(function (results) {\n        equal(results.length, 3);\n        done();\n      });\n    });\n  });\n\n  it('async methods', function (done) {\n    const saves = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9].map(function (x) {\n      const obj = new Parse.Object('TestObject');\n      obj.set('x', x + 1);\n      return obj;\n    });\n\n    Parse.Object.saveAll(saves)\n      .then(function () {\n        const query = new Parse.Query('TestObject');\n        query.ascending('x');\n        return query.first();\n      })\n      .then(function (obj) {\n        equal(obj.get('x'), 1);\n        const query = new Parse.Query('TestObject');\n        query.descending('x');\n        return query.find();\n      })\n      .then(function (results) {\n        equal(results.length, 10);\n        const query = new Parse.Query('TestObject');\n        return query.get(results[0].id);\n      })\n      .then(function (obj1) {\n        equal(obj1.get('x'), 10);\n        const query = new Parse.Query('TestObject');\n        return query.count();\n      })\n      .then(function (count) {\n        equal(count, 10);\n      })\n      .then(function () {\n        done();\n      });\n  });\n\n  it('query.each', function (done) {\n    const TOTAL = 50;\n    const COUNT = 25;\n\n    const items = range(TOTAL).map(function (x) {\n      const obj = new TestObject();\n      obj.set('x', x);\n      return obj;\n    });\n\n    Parse.Object.saveAll(items).then(function () {\n      const query = new Parse.Query(TestObject);\n      query.lessThan('x', COUNT);\n\n      const seen = [];\n      query\n        .each(\n          function (obj) {\n            seen[obj.get('x')] = (seen[obj.get('x')] || 0) + 1;\n          },\n          {\n            batchSize: 10,\n          }\n        )\n        .then(function () {\n          equal(seen.length, COUNT);\n          for (let i = 0; i < COUNT; i++) {\n            equal(seen[i], 1, 'Should have seen object number ' + i);\n          }\n          done();\n        }, done.fail);\n    });\n  });\n\n  it('query.each async', function (done) {\n    const TOTAL = 50;\n    const COUNT = 25;\n\n    expect(COUNT + 1);\n\n    const items = range(TOTAL).map(function (x) {\n      const obj = new TestObject();\n      obj.set('x', x);\n      return obj;\n    });\n\n    const seen = [];\n\n    Parse.Object.saveAll(items)\n      .then(function () {\n        const query = new Parse.Query(TestObject);\n        query.lessThan('x', COUNT);\n        return query.each(\n          function (obj) {\n            return new Promise(resolve => {\n              process.nextTick(function () {\n                seen[obj.get('x')] = (seen[obj.get('x')] || 0) + 1;\n                resolve();\n              });\n            });\n          },\n          {\n            batchSize: 10,\n          }\n        );\n      })\n      .then(function () {\n        equal(seen.length, COUNT);\n        for (let i = 0; i < COUNT; i++) {\n          equal(seen[i], 1, 'Should have seen object number ' + i);\n        }\n        done();\n      });\n  });\n\n  it('query.each fails with order', function (done) {\n    const TOTAL = 50;\n    const COUNT = 25;\n\n    const items = range(TOTAL).map(function (x) {\n      const obj = new TestObject();\n      obj.set('x', x);\n      return obj;\n    });\n\n    const seen = [];\n\n    Parse.Object.saveAll(items)\n      .then(function () {\n        const query = new Parse.Query(TestObject);\n        query.lessThan('x', COUNT);\n        query.ascending('x');\n        return query.each(function (obj) {\n          seen[obj.get('x')] = (seen[obj.get('x')] || 0) + 1;\n        });\n      })\n      .then(\n        function () {\n          ok(false, 'This should have failed.');\n          done();\n        },\n        function () {\n          done();\n        }\n      );\n  });\n\n  it('query.each fails with skip', function (done) {\n    const TOTAL = 50;\n    const COUNT = 25;\n\n    const items = range(TOTAL).map(function (x) {\n      const obj = new TestObject();\n      obj.set('x', x);\n      return obj;\n    });\n\n    const seen = [];\n\n    Parse.Object.saveAll(items)\n      .then(function () {\n        const query = new Parse.Query(TestObject);\n        query.lessThan('x', COUNT);\n        query.skip(5);\n        return query.each(function (obj) {\n          seen[obj.get('x')] = (seen[obj.get('x')] || 0) + 1;\n        });\n      })\n      .then(\n        function () {\n          ok(false, 'This should have failed.');\n          done();\n        },\n        function () {\n          done();\n        }\n      );\n  });\n\n  it('query.each fails with limit', function (done) {\n    const TOTAL = 50;\n    const COUNT = 25;\n\n    expect(0);\n\n    const items = range(TOTAL).map(function (x) {\n      const obj = new TestObject();\n      obj.set('x', x);\n      return obj;\n    });\n\n    const seen = [];\n\n    Parse.Object.saveAll(items)\n      .then(function () {\n        const query = new Parse.Query(TestObject);\n        query.lessThan('x', COUNT);\n        query.limit(5);\n        return query.each(function (obj) {\n          seen[obj.get('x')] = (seen[obj.get('x')] || 0) + 1;\n        });\n      })\n      .then(\n        function () {\n          ok(false, 'This should have failed.');\n          done();\n        },\n        function () {\n          done();\n        }\n      );\n  });\n\n  it('select keys query JS SDK', async () => {\n    const obj = new TestObject({ foo: 'baz', bar: 1, qux: 2 });\n    await obj.save();\n    obj._clearServerData();\n    const query1 = new Parse.Query(TestObject);\n    query1.select('foo');\n    const result1 = await query1.first();\n    ok(result1.id, 'expected object id to be set');\n    ok(result1.createdAt, 'expected object createdAt to be set');\n    ok(result1.updatedAt, 'expected object updatedAt to be set');\n    ok(!result1.dirty(), 'expected result not to be dirty');\n    strictEqual(result1.get('foo'), 'baz');\n    strictEqual(result1.get('bar'), undefined, \"expected 'bar' field to be unset\");\n    strictEqual(result1.get('qux'), undefined, \"expected 'qux' field to be unset\");\n\n    const result2 = await result1.fetch();\n    strictEqual(result2.get('foo'), 'baz');\n    strictEqual(result2.get('bar'), 1);\n    strictEqual(result2.get('qux'), 2);\n\n    obj._clearServerData();\n    const query2 = new Parse.Query(TestObject);\n    query2.select();\n    const result3 = await query2.first();\n    ok(result3.id, 'expected object id to be set');\n    ok(result3.createdAt, 'expected object createdAt to be set');\n    ok(result3.updatedAt, 'expected object updatedAt to be set');\n    ok(!result3.dirty(), 'expected result not to be dirty');\n    strictEqual(result3.get('foo'), undefined, \"expected 'foo' field to be unset\");\n    strictEqual(result3.get('bar'), undefined, \"expected 'bar' field to be unset\");\n    strictEqual(result3.get('qux'), undefined, \"expected 'qux' field to be unset\");\n\n    obj._clearServerData();\n    const query3 = new Parse.Query(TestObject);\n    query3.select([]);\n    const result4 = await query3.first();\n    ok(result4.id, 'expected object id to be set');\n    ok(result4.createdAt, 'expected object createdAt to be set');\n    ok(result4.updatedAt, 'expected object updatedAt to be set');\n    ok(!result4.dirty(), 'expected result not to be dirty');\n    strictEqual(result4.get('foo'), undefined, \"expected 'foo' field to be unset\");\n    strictEqual(result4.get('bar'), undefined, \"expected 'bar' field to be unset\");\n    strictEqual(result4.get('qux'), undefined, \"expected 'qux' field to be unset\");\n\n    obj._clearServerData();\n    const query4 = new Parse.Query(TestObject);\n    query4.select(['foo']);\n    const result5 = await query4.first();\n    ok(result5.id, 'expected object id to be set');\n    ok(result5.createdAt, 'expected object createdAt to be set');\n    ok(result5.updatedAt, 'expected object updatedAt to be set');\n    ok(!result5.dirty(), 'expected result not to be dirty');\n    strictEqual(result5.get('foo'), 'baz');\n    strictEqual(result5.get('bar'), undefined, \"expected 'bar' field to be unset\");\n    strictEqual(result5.get('qux'), undefined, \"expected 'qux' field to be unset\");\n\n    obj._clearServerData();\n    const query5 = new Parse.Query(TestObject);\n    query5.select(['foo', 'bar']);\n    const result6 = await query5.first();\n    ok(result6.id, 'expected object id to be set');\n    ok(!result6.dirty(), 'expected result not to be dirty');\n    strictEqual(result6.get('foo'), 'baz');\n    strictEqual(result6.get('bar'), 1);\n    strictEqual(result6.get('qux'), undefined, \"expected 'qux' field to be unset\");\n\n    obj._clearServerData();\n    const query6 = new Parse.Query(TestObject);\n    query6.select(['foo', 'bar', 'qux']);\n    const result7 = await query6.first();\n    ok(result7.id, 'expected object id to be set');\n    ok(!result7.dirty(), 'expected result not to be dirty');\n    strictEqual(result7.get('foo'), 'baz');\n    strictEqual(result7.get('bar'), 1);\n    strictEqual(result7.get('qux'), 2);\n\n    obj._clearServerData();\n    const query7 = new Parse.Query(TestObject);\n    query7.select('foo', 'bar');\n    const result8 = await query7.first();\n    ok(result8.id, 'expected object id to be set');\n    ok(!result8.dirty(), 'expected result not to be dirty');\n    strictEqual(result8.get('foo'), 'baz');\n    strictEqual(result8.get('bar'), 1);\n    strictEqual(result8.get('qux'), undefined, \"expected 'qux' field to be unset\");\n\n    obj._clearServerData();\n    const query8 = new Parse.Query(TestObject);\n    query8.select('foo', 'bar', 'qux');\n    const result9 = await query8.first();\n    ok(result9.id, 'expected object id to be set');\n    ok(!result9.dirty(), 'expected result not to be dirty');\n    strictEqual(result9.get('foo'), 'baz');\n    strictEqual(result9.get('bar'), 1);\n    strictEqual(result9.get('qux'), 2);\n  });\n\n  it('select keys (arrays)', async () => {\n    const obj = new TestObject({ foo: 'baz', bar: 1, hello: 'world' });\n    await obj.save();\n\n    const response = await request({\n      url: Parse.serverURL + '/classes/TestObject',\n      qs: {\n        keys: 'hello',\n        where: JSON.stringify({ objectId: obj.id }),\n      },\n      headers: masterKeyHeaders,\n    });\n    expect(response.data.results[0].foo).toBeUndefined();\n    expect(response.data.results[0].bar).toBeUndefined();\n    expect(response.data.results[0].hello).toBe('world');\n\n    const response2 = await request({\n      url: Parse.serverURL + '/classes/TestObject',\n      qs: {\n        keys: ['foo', 'hello'],\n        where: JSON.stringify({ objectId: obj.id }),\n      },\n      headers: masterKeyHeaders,\n    });\n    expect(response2.data.results[0].foo).toBe('baz');\n    expect(response2.data.results[0].bar).toBeUndefined();\n    expect(response2.data.results[0].hello).toBe('world');\n\n    const response3 = await request({\n      url: Parse.serverURL + '/classes/TestObject',\n      qs: {\n        keys: ['foo', 'bar', 'hello'],\n        where: JSON.stringify({ objectId: obj.id }),\n      },\n      headers: masterKeyHeaders,\n    });\n    expect(response3.data.results[0].foo).toBe('baz');\n    expect(response3.data.results[0].bar).toBe(1);\n    expect(response3.data.results[0].hello).toBe('world');\n\n    const response4 = await request({\n      url: Parse.serverURL + '/classes/TestObject',\n      qs: {\n        keys: [''],\n        where: JSON.stringify({ objectId: obj.id }),\n      },\n      headers: masterKeyHeaders,\n    });\n    ok(response4.data.results[0].objectId, 'expected objectId to be set');\n    ok(response4.data.results[0].createdAt, 'expected object createdAt to be set');\n    ok(response4.data.results[0].updatedAt, 'expected object updatedAt to be set');\n    expect(response4.data.results[0].foo).toBeUndefined();\n    expect(response4.data.results[0].bar).toBeUndefined();\n    expect(response4.data.results[0].hello).toBeUndefined();\n\n    const response5 = await request({\n      url: Parse.serverURL + '/classes/TestObject',\n      qs: {\n        keys: [],\n        where: JSON.stringify({ objectId: obj.id }),\n      },\n      headers: masterKeyHeaders,\n    });\n    ok(response5.data.results[0].objectId, 'expected objectId to be set');\n    ok(response5.data.results[0].createdAt, 'expected object createdAt to be set');\n    ok(response5.data.results[0].updatedAt, 'expected object updatedAt to be set');\n    expect(response5.data.results[0].foo).toBe('baz');\n    expect(response5.data.results[0].bar).toBe(1);\n    expect(response5.data.results[0].hello).toBe('world');\n  });\n\n  it('select keys (strings)', async () => {\n    const obj = new TestObject({ foo: 'baz', bar: 1, hello: 'world' });\n    await obj.save();\n\n    const response = await request({\n      url: Parse.serverURL + '/classes/TestObject',\n      qs: {\n        keys: '',\n        where: JSON.stringify({ objectId: obj.id }),\n      },\n      headers: masterKeyHeaders,\n    });\n    ok(response.data.results[0].objectId, 'expected objectId to be set');\n    ok(response.data.results[0].createdAt, 'expected object createdAt to be set');\n    ok(response.data.results[0].updatedAt, 'expected object updatedAt to be set');\n    expect(response.data.results[0].foo).toBeUndefined();\n    expect(response.data.results[0].bar).toBeUndefined();\n    expect(response.data.results[0].hello).toBeUndefined();\n\n    const response2 = await request({\n      url: Parse.serverURL + '/classes/TestObject',\n      qs: {\n        keys: '[\"foo\", \"hello\"]',\n        where: JSON.stringify({ objectId: obj.id }),\n      },\n      headers: masterKeyHeaders,\n    });\n    ok(response2.data.results[0].objectId, 'expected objectId to be set');\n    ok(response2.data.results[0].createdAt, 'expected object createdAt to be set');\n    ok(response2.data.results[0].updatedAt, 'expected object updatedAt to be set');\n    expect(response2.data.results[0].foo).toBe('baz');\n    expect(response2.data.results[0].bar).toBeUndefined();\n    expect(response2.data.results[0].hello).toBe('world');\n\n    const response3 = await request({\n      url: Parse.serverURL + '/classes/TestObject',\n      qs: {\n        keys: '[\"foo\", \"bar\", \"hello\"]',\n        where: JSON.stringify({ objectId: obj.id }),\n      },\n      headers: masterKeyHeaders,\n    });\n    ok(response3.data.results[0].objectId, 'expected objectId to be set');\n    ok(response3.data.results[0].createdAt, 'expected object createdAt to be set');\n    ok(response3.data.results[0].updatedAt, 'expected object updatedAt to be set');\n    expect(response3.data.results[0].foo).toBe('baz');\n    expect(response3.data.results[0].bar).toBe(1);\n    expect(response3.data.results[0].hello).toBe('world');\n  });\n\n  it('exclude keys query JS SDK', async () => {\n    const obj = new TestObject({ foo: 'baz', bar: 1, qux: 2 });\n\n    await obj.save();\n    obj._clearServerData();\n    const query1 = new Parse.Query(TestObject);\n    query1.exclude('foo');\n    const result1 = await query1.first();\n    ok(result1.id, 'expected object id to be set');\n    ok(result1.createdAt, 'expected object createdAt to be set');\n    ok(result1.updatedAt, 'expected object updatedAt to be set');\n    ok(!result1.dirty(), 'expected result not to be dirty');\n    strictEqual(result1.get('foo'), undefined, \"expected 'bar' field to be unset\");\n    strictEqual(result1.get('bar'), 1);\n    strictEqual(result1.get('qux'), 2);\n\n    const result2 = await result1.fetch();\n    strictEqual(result2.get('foo'), 'baz');\n    strictEqual(result2.get('bar'), 1);\n    strictEqual(result2.get('qux'), 2);\n\n    obj._clearServerData();\n    const query2 = new Parse.Query(TestObject);\n    query2.exclude();\n    const result3 = await query2.first();\n    ok(result3.id, 'expected object id to be set');\n    ok(result3.createdAt, 'expected object createdAt to be set');\n    ok(result3.updatedAt, 'expected object updatedAt to be set');\n    ok(!result3.dirty(), 'expected result not to be dirty');\n    strictEqual(result3.get('foo'), 'baz');\n    strictEqual(result3.get('bar'), 1);\n    strictEqual(result3.get('qux'), 2);\n\n    obj._clearServerData();\n    const query3 = new Parse.Query(TestObject);\n    query3.exclude([]);\n    const result4 = await query3.first();\n    ok(result4.id, 'expected object id to be set');\n    ok(result4.createdAt, 'expected object createdAt to be set');\n    ok(result4.updatedAt, 'expected object updatedAt to be set');\n    ok(!result4.dirty(), 'expected result not to be dirty');\n    strictEqual(result4.get('foo'), 'baz');\n    strictEqual(result4.get('bar'), 1);\n    strictEqual(result4.get('qux'), 2);\n\n    obj._clearServerData();\n    const query4 = new Parse.Query(TestObject);\n    query4.exclude(['foo']);\n    const result5 = await query4.first();\n    ok(result5.id, 'expected object id to be set');\n    ok(result5.createdAt, 'expected object createdAt to be set');\n    ok(result5.updatedAt, 'expected object updatedAt to be set');\n    ok(!result5.dirty(), 'expected result not to be dirty');\n    strictEqual(result5.get('foo'), undefined, \"expected 'bar' field to be unset\");\n    strictEqual(result5.get('bar'), 1);\n    strictEqual(result5.get('qux'), 2);\n\n    obj._clearServerData();\n    const query5 = new Parse.Query(TestObject);\n    query5.exclude(['foo', 'bar']);\n    const result6 = await query5.first();\n    ok(result6.id, 'expected object id to be set');\n    ok(!result6.dirty(), 'expected result not to be dirty');\n    strictEqual(result6.get('foo'), undefined, \"expected 'bar' field to be unset\");\n    strictEqual(result6.get('bar'), undefined, \"expected 'bar' field to be unset\");\n    strictEqual(result6.get('qux'), 2);\n\n    obj._clearServerData();\n    const query6 = new Parse.Query(TestObject);\n    query6.exclude(['foo', 'bar', 'qux']);\n    const result7 = await query6.first();\n    ok(result7.id, 'expected object id to be set');\n    ok(!result7.dirty(), 'expected result not to be dirty');\n    strictEqual(result7.get('foo'), undefined, \"expected 'bar' field to be unset\");\n    strictEqual(result7.get('bar'), undefined, \"expected 'bar' field to be unset\");\n    strictEqual(result7.get('qux'), undefined, \"expected 'bar' field to be unset\");\n\n    obj._clearServerData();\n    const query7 = new Parse.Query(TestObject);\n    query7.exclude('foo');\n    const result8 = await query7.first();\n    ok(result8.id, 'expected object id to be set');\n    ok(!result8.dirty(), 'expected result not to be dirty');\n    strictEqual(result8.get('foo'), undefined, \"expected 'bar' field to be unset\");\n    strictEqual(result8.get('bar'), 1);\n    strictEqual(result8.get('qux'), 2);\n\n    obj._clearServerData();\n    const query8 = new Parse.Query(TestObject);\n    query8.exclude('foo', 'bar');\n    const result9 = await query8.first();\n    ok(result9.id, 'expected object id to be set');\n    ok(!result9.dirty(), 'expected result not to be dirty');\n    strictEqual(result9.get('foo'), undefined, \"expected 'bar' field to be unset\");\n    strictEqual(result9.get('bar'), undefined, \"expected 'bar' field to be unset\");\n    strictEqual(result9.get('qux'), 2);\n\n    obj._clearServerData();\n    const query9 = new Parse.Query(TestObject);\n    query9.exclude('foo', 'bar', 'qux');\n    const result10 = await query9.first();\n    ok(result10.id, 'expected object id to be set');\n    ok(!result10.dirty(), 'expected result not to be dirty');\n    strictEqual(result10.get('foo'), undefined, \"expected 'bar' field to be unset\");\n    strictEqual(result10.get('bar'), undefined, \"expected 'bar' field to be unset\");\n    strictEqual(result10.get('qux'), undefined, \"expected 'bar' field to be unset\");\n  });\n\n  it('exclude keys (arrays)', async () => {\n    const obj = new TestObject({ foo: 'baz', hello: 'world' });\n    await obj.save();\n\n    const response = await request({\n      url: Parse.serverURL + '/classes/TestObject',\n      qs: {\n        excludeKeys: ['foo'],\n        where: JSON.stringify({ objectId: obj.id }),\n      },\n      headers: masterKeyHeaders,\n    });\n    ok(response.data.results[0].objectId, 'expected objectId to be set');\n    ok(response.data.results[0].createdAt, 'expected object createdAt to be set');\n    ok(response.data.results[0].updatedAt, 'expected object updatedAt to be set');\n    expect(response.data.results[0].foo).toBeUndefined();\n    expect(response.data.results[0].hello).toBe('world');\n\n    const response2 = await request({\n      url: Parse.serverURL + '/classes/TestObject',\n      qs: {\n        excludeKeys: ['foo', 'hello'],\n        where: JSON.stringify({ objectId: obj.id }),\n      },\n      headers: masterKeyHeaders,\n    });\n    ok(response2.data.results[0].objectId, 'expected objectId to be set');\n    ok(response2.data.results[0].createdAt, 'expected object createdAt to be set');\n    ok(response2.data.results[0].updatedAt, 'expected object updatedAt to be set');\n    expect(response2.data.results[0].foo).toBeUndefined();\n    expect(response2.data.results[0].hello).toBeUndefined();\n\n    const response3 = await request({\n      url: Parse.serverURL + '/classes/TestObject',\n      qs: {\n        excludeKeys: [],\n        where: JSON.stringify({ objectId: obj.id }),\n      },\n      headers: masterKeyHeaders,\n    });\n    ok(response3.data.results[0].objectId, 'expected objectId to be set');\n    ok(response3.data.results[0].createdAt, 'expected object createdAt to be set');\n    ok(response3.data.results[0].updatedAt, 'expected object updatedAt to be set');\n    expect(response3.data.results[0].foo).toBe('baz');\n    expect(response3.data.results[0].hello).toBe('world');\n\n    const response4 = await request({\n      url: Parse.serverURL + '/classes/TestObject',\n      qs: {\n        excludeKeys: [''],\n        where: JSON.stringify({ objectId: obj.id }),\n      },\n      headers: masterKeyHeaders,\n    });\n    ok(response4.data.results[0].objectId, 'expected objectId to be set');\n    ok(response4.data.results[0].createdAt, 'expected object createdAt to be set');\n    ok(response4.data.results[0].updatedAt, 'expected object updatedAt to be set');\n    expect(response4.data.results[0].foo).toBe('baz');\n    expect(response4.data.results[0].hello).toBe('world');\n  });\n\n  it('exclude keys (strings)', async () => {\n    const obj = new TestObject({ foo: 'baz', hello: 'world' });\n    await obj.save();\n\n    const response = await request({\n      url: Parse.serverURL + '/classes/TestObject',\n      qs: {\n        excludeKeys: 'foo',\n        where: JSON.stringify({ objectId: obj.id }),\n      },\n      headers: masterKeyHeaders,\n    });\n    ok(response.data.results[0].objectId, 'expected objectId to be set');\n    ok(response.data.results[0].createdAt, 'expected object createdAt to be set');\n    ok(response.data.results[0].updatedAt, 'expected object updatedAt to be set');\n    expect(response.data.results[0].foo).toBeUndefined();\n    expect(response.data.results[0].hello).toBe('world');\n\n    const response2 = await request({\n      url: Parse.serverURL + '/classes/TestObject',\n      qs: {\n        excludeKeys: '',\n        where: JSON.stringify({ objectId: obj.id }),\n      },\n      headers: masterKeyHeaders,\n    });\n    ok(response2.data.results[0].objectId, 'expected objectId to be set');\n    ok(response2.data.results[0].createdAt, 'expected object createdAt to be set');\n    ok(response2.data.results[0].updatedAt, 'expected object updatedAt to be set');\n    expect(response2.data.results[0].foo).toBe('baz');\n    expect(response2.data.results[0].hello).toBe('world');\n\n    const response3 = await request({\n      url: Parse.serverURL + '/classes/TestObject',\n      qs: {\n        excludeKeys: '[\"hello\"]',\n        where: JSON.stringify({ objectId: obj.id }),\n      },\n      headers: masterKeyHeaders,\n    });\n    ok(response3.data.results[0].objectId, 'expected objectId to be set');\n    ok(response3.data.results[0].createdAt, 'expected object createdAt to be set');\n    ok(response3.data.results[0].updatedAt, 'expected object updatedAt to be set');\n    expect(response3.data.results[0].foo).toBe('baz');\n    expect(response3.data.results[0].hello).toBeUndefined();\n\n    const response4 = await request({\n      url: Parse.serverURL + '/classes/TestObject',\n      qs: {\n        excludeKeys: '[\"foo\", \"hello\"]',\n        where: JSON.stringify({ objectId: obj.id }),\n      },\n      headers: masterKeyHeaders,\n    });\n    ok(response4.data.results[0].objectId, 'expected objectId to be set');\n    ok(response4.data.results[0].createdAt, 'expected object createdAt to be set');\n    ok(response4.data.results[0].updatedAt, 'expected object updatedAt to be set');\n    expect(response4.data.results[0].foo).toBeUndefined();\n    expect(response4.data.results[0].hello).toBeUndefined();\n  });\n\n  it('exclude keys with select same key', async () => {\n    const obj = new TestObject({ foo: 'baz', hello: 'world' });\n    await obj.save();\n\n    const response = await request({\n      url: Parse.serverURL + '/classes/TestObject',\n      qs: {\n        keys: 'foo',\n        excludeKeys: 'foo',\n        where: JSON.stringify({ objectId: obj.id }),\n      },\n      headers: masterKeyHeaders,\n    });\n    expect(response.data.results[0].foo).toBeUndefined();\n    expect(response.data.results[0].hello).toBeUndefined();\n  });\n\n  it('exclude keys with select different key', async () => {\n    const obj = new TestObject({ foo: 'baz', hello: 'world' });\n    await obj.save();\n\n    const response = await request({\n      url: Parse.serverURL + '/classes/TestObject',\n      qs: {\n        keys: 'foo,hello',\n        excludeKeys: 'foo',\n        where: JSON.stringify({ objectId: obj.id }),\n      },\n      headers: masterKeyHeaders,\n    });\n    expect(response.data.results[0].foo).toBeUndefined();\n    expect(response.data.results[0].hello).toBe('world');\n  });\n\n  it('exclude keys with include same key', async () => {\n    const pointer = new TestObject();\n    await pointer.save();\n    const obj = new TestObject({ child: pointer, hello: 'world' });\n    await obj.save();\n\n    const response = await request({\n      url: Parse.serverURL + '/classes/TestObject',\n      qs: {\n        include: 'child',\n        excludeKeys: 'child',\n        where: JSON.stringify({ objectId: obj.id }),\n      },\n      headers: masterKeyHeaders,\n    });\n    expect(response.data.results[0].child).toBeUndefined();\n    expect(response.data.results[0].hello).toBe('world');\n  });\n\n  it('exclude keys with include different key', async () => {\n    const pointer = new TestObject();\n    await pointer.save();\n    const obj = new TestObject({\n      child1: pointer,\n      child2: pointer,\n      hello: 'world',\n    });\n    await obj.save();\n\n    const response = await request({\n      url: Parse.serverURL + '/classes/TestObject',\n      qs: {\n        include: 'child1,child2',\n        excludeKeys: 'child1',\n        where: JSON.stringify({ objectId: obj.id }),\n      },\n      headers: masterKeyHeaders,\n    });\n    expect(response.data.results[0].child1).toBeUndefined();\n    expect(response.data.results[0].child2.objectId).toEqual(pointer.id);\n    expect(response.data.results[0].hello).toBe('world');\n  });\n\n  it('exclude keys with includeAll', async () => {\n    const pointer = new TestObject();\n    await pointer.save();\n    const obj = new TestObject({\n      child1: pointer,\n      child2: pointer,\n      hello: 'world',\n    });\n    await obj.save();\n\n    const response = await request({\n      url: Parse.serverURL + '/classes/TestObject',\n      qs: {\n        includeAll: true,\n        excludeKeys: 'child1',\n        where: JSON.stringify({ objectId: obj.id }),\n      },\n      headers: masterKeyHeaders,\n    });\n    expect(response.data.results[0].child).toBeUndefined();\n    expect(response.data.results[0].child2.objectId).toEqual(pointer.id);\n    expect(response.data.results[0].hello).toBe('world');\n  });\n\n  it('select keys with each query', function (done) {\n    const obj = new TestObject({ foo: 'baz', bar: 1 });\n\n    obj.save().then(function () {\n      obj._clearServerData();\n      const query = new Parse.Query(TestObject);\n      query.select('foo');\n      query\n        .each(function (result) {\n          ok(result.id, 'expected object id to be set');\n          ok(result.createdAt, 'expected object createdAt to be set');\n          ok(result.updatedAt, 'expected object updatedAt to be set');\n          ok(!result.dirty(), 'expected result not to be dirty');\n          strictEqual(result.get('foo'), 'baz');\n          strictEqual(result.get('bar'), undefined, 'expected \"bar\" field to be unset');\n        })\n        .then(\n          function () {\n            done();\n          },\n          function (err) {\n            jfail(err);\n            done();\n          }\n        );\n    });\n  });\n\n  it('notEqual with array of pointers', done => {\n    const children = [];\n    const parents = [];\n    const promises = [];\n    for (let i = 0; i < 2; i++) {\n      const proc = iter => {\n        const child = new Parse.Object('Child');\n        children.push(child);\n        const parent = new Parse.Object('Parent');\n        parents.push(parent);\n        promises.push(\n          child.save().then(() => {\n            parents[iter].set('child', [children[iter]]);\n            return parents[iter].save();\n          })\n        );\n      };\n      proc(i);\n    }\n    Promise.all(promises)\n      .then(() => {\n        const query = new Parse.Query('Parent');\n        query.notEqualTo('child', children[0]);\n        return query.find();\n      })\n      .then(results => {\n        expect(results.length).toEqual(1);\n        expect(results[0].id).toEqual(parents[1].id);\n        done();\n      })\n      .catch(error => {\n        console.log(error);\n      });\n  });\n\n  // PG don't support creating a null column\n  it_exclude_dbs(['postgres'])('querying for null value', done => {\n    const obj = new Parse.Object('TestObject');\n    obj.set('aNull', null);\n    obj\n      .save()\n      .then(() => {\n        const query = new Parse.Query('TestObject');\n        query.equalTo('aNull', null);\n        return query.find();\n      })\n      .then(results => {\n        expect(results.length).toEqual(1);\n        expect(results[0].get('aNull')).toEqual(null);\n        done();\n      });\n  });\n\n  it('query within dictionary', done => {\n    const promises = [];\n    for (let i = 0; i < 2; i++) {\n      const proc = iter => {\n        const obj = new Parse.Object('TestObject');\n        obj.set('aDict', { x: iter + 1, y: iter + 2 });\n        promises.push(obj.save());\n      };\n      proc(i);\n    }\n    Promise.all(promises)\n      .then(() => {\n        const query = new Parse.Query('TestObject');\n        query.equalTo('aDict.x', 1);\n        return query.find();\n      })\n      .then(\n        results => {\n          expect(results.length).toEqual(1);\n          done();\n        },\n        error => {\n          console.log(error);\n        }\n      );\n  });\n\n  it('supports include on the wrong key type (#2262)', function (done) {\n    const childObject = new Parse.Object('TestChildObject');\n    childObject.set('hello', 'world');\n    childObject\n      .save()\n      .then(() => {\n        const obj = new Parse.Object('TestObject');\n        obj.set('foo', 'bar');\n        obj.set('child', childObject);\n        return obj.save();\n      })\n      .then(() => {\n        const q = new Parse.Query('TestObject');\n        q.include('child');\n        q.include('child.parent');\n        q.include('createdAt');\n        q.include('createdAt.createdAt');\n        return q.find();\n      })\n      .then(\n        objs => {\n          expect(objs.length).toBe(1);\n          expect(objs[0].get('child').get('hello')).toEqual('world');\n          expect(objs[0].createdAt instanceof Date).toBe(true);\n          done();\n        },\n        () => {\n          fail('should not fail');\n          done();\n        }\n      );\n  });\n\n  it('query match on array with single object', done => {\n    const target = {\n      __type: 'Pointer',\n      className: 'TestObject',\n      objectId: 'abc123',\n    };\n    const obj = new Parse.Object('TestObject');\n    obj.set('someObjs', [target]);\n    obj\n      .save()\n      .then(() => {\n        const query = new Parse.Query('TestObject');\n        query.equalTo('someObjs', target);\n        return query.find();\n      })\n      .then(\n        results => {\n          expect(results.length).toEqual(1);\n          done();\n        },\n        error => {\n          console.log(error);\n        }\n      );\n  });\n\n  it('query match on array with multiple objects', done => {\n    const target1 = {\n      __type: 'Pointer',\n      className: 'TestObject',\n      objectId: 'abc',\n    };\n    const target2 = {\n      __type: 'Pointer',\n      className: 'TestObject',\n      objectId: '123',\n    };\n    const obj = new Parse.Object('TestObject');\n    obj.set('someObjs', [target1, target2]);\n    obj\n      .save()\n      .then(() => {\n        const query = new Parse.Query('TestObject');\n        query.equalTo('someObjs', target1);\n        return query.find();\n      })\n      .then(\n        results => {\n          expect(results.length).toEqual(1);\n          done();\n        },\n        error => {\n          console.log(error);\n        }\n      );\n  });\n\n  it('query should not match on array when searching for null', done => {\n    const target = {\n      __type: 'Pointer',\n      className: 'TestObject',\n      objectId: '123',\n    };\n    const obj = new Parse.Object('TestObject');\n    obj.set('someKey', 'someValue');\n    obj.set('someObjs', [target]);\n    obj\n      .save()\n      .then(() => {\n        const query = new Parse.Query('TestObject');\n        query.equalTo('someKey', 'someValue');\n        query.equalTo('someObjs', null);\n        return query.find();\n      })\n      .then(\n        results => {\n          expect(results.length).toEqual(0);\n          done();\n        },\n        error => {\n          console.log(error);\n        }\n      );\n  });\n\n  // #371\n  it('should properly interpret a query v1', done => {\n    const query = new Parse.Query('C1');\n    const auxQuery = new Parse.Query('C1');\n    query.matchesKeyInQuery('A1', 'A2', auxQuery);\n    query.include('A3');\n    query.include('A2');\n    query.find().then(\n      () => {\n        done();\n      },\n      err => {\n        jfail(err);\n        fail('should not failt');\n        done();\n      }\n    );\n  });\n\n  it('should properly interpret a query v2', done => {\n    const user = new Parse.User();\n    user.set('username', 'foo');\n    user.set('password', 'bar');\n    return user\n      .save()\n      .then(user => {\n        const objIdQuery = new Parse.Query('_User').equalTo('objectId', user.id);\n        const blockedUserQuery = user.relation('blockedUsers').query();\n\n        const aResponseQuery = new Parse.Query('MatchRelationshipActivityResponse');\n        aResponseQuery.equalTo('userA', user);\n        aResponseQuery.equalTo('userAResponse', 1);\n\n        const bResponseQuery = new Parse.Query('MatchRelationshipActivityResponse');\n        bResponseQuery.equalTo('userB', user);\n        bResponseQuery.equalTo('userBResponse', 1);\n\n        const matchOr = Parse.Query.or(aResponseQuery, bResponseQuery);\n        const matchRelationshipA = new Parse.Query('_User');\n        matchRelationshipA.matchesKeyInQuery('objectId', 'userAObjectId', matchOr);\n        const matchRelationshipB = new Parse.Query('_User');\n        matchRelationshipB.matchesKeyInQuery('objectId', 'userBObjectId', matchOr);\n\n        const orQuery = Parse.Query.or(\n          objIdQuery,\n          blockedUserQuery,\n          matchRelationshipA,\n          matchRelationshipB\n        );\n        const query = new Parse.Query('_User');\n        query.doesNotMatchQuery('objectId', orQuery);\n        return query.find();\n      })\n      .then(\n        () => {\n          done();\n        },\n        err => {\n          jfail(err);\n          fail('should not fail');\n          done();\n        }\n      );\n  });\n\n  it('should match a key in an array (#3195)', function (done) {\n    const AuthorObject = Parse.Object.extend('Author');\n    const GroupObject = Parse.Object.extend('Group');\n    const PostObject = Parse.Object.extend('Post');\n\n    return new AuthorObject()\n      .save()\n      .then(user => {\n        const post = new PostObject({\n          author: user,\n        });\n\n        const group = new GroupObject({\n          members: [user],\n        });\n\n        return Promise.all([post.save(), group.save()]);\n      })\n      .then(results => {\n        const p = results[0];\n        return new Parse.Query(PostObject)\n          .matchesKeyInQuery('author', 'members', new Parse.Query(GroupObject))\n          .find()\n          .then(r => {\n            expect(r.length).toEqual(1);\n            if (r.length > 0) {\n              expect(r[0].id).toEqual(p.id);\n            }\n            done();\n          }, done.fail);\n      });\n  });\n\n  it('should find objects with array of pointers', done => {\n    const objects = [];\n    while (objects.length != 5) {\n      const object = new Parse.Object('ContainedObject');\n      object.set('index', objects.length);\n      objects.push(object);\n    }\n\n    Parse.Object.saveAll(objects)\n      .then(objects => {\n        const container = new Parse.Object('Container');\n        const pointers = objects.map(obj => {\n          return {\n            __type: 'Pointer',\n            className: 'ContainedObject',\n            objectId: obj.id,\n          };\n        });\n        container.set('objects', pointers);\n        const container2 = new Parse.Object('Container');\n        container2.set('objects', pointers.slice(2, 3));\n        return Parse.Object.saveAll([container, container2]);\n      })\n      .then(() => {\n        const inQuery = new Parse.Query('ContainedObject');\n        inQuery.greaterThanOrEqualTo('index', 1);\n        const query = new Parse.Query('Container');\n        query.matchesQuery('objects', inQuery);\n        return query.find();\n      })\n      .then(results => {\n        if (results) {\n          expect(results.length).toBe(2);\n        }\n        done();\n      })\n      .catch(err => {\n        jfail(err);\n        fail('should not fail');\n        done();\n      });\n  });\n\n  it('query with two OR subqueries (regression test #1259)', done => {\n    const relatedObject = new Parse.Object('Class2');\n    relatedObject\n      .save()\n      .then(relatedObject => {\n        const anObject = new Parse.Object('Class1');\n        const relation = anObject.relation('relation');\n        relation.add(relatedObject);\n        return anObject.save();\n      })\n      .then(anObject => {\n        const q1 = anObject.relation('relation').query();\n        q1.doesNotExist('nonExistantKey1');\n        const q2 = anObject.relation('relation').query();\n        q2.doesNotExist('nonExistantKey2');\n        Parse.Query.or(q1, q2)\n          .find()\n          .then(results => {\n            expect(results.length).toEqual(1);\n            if (results.length == 1) {\n              expect(results[0].objectId).toEqual(q1.objectId);\n            }\n            done();\n          });\n      });\n  });\n\n  it('objectId containedIn with multiple large array', done => {\n    const obj = new Parse.Object('MyClass');\n    obj\n      .save()\n      .then(obj => {\n        const longListOfStrings = [];\n        for (let i = 0; i < 130; i++) {\n          longListOfStrings.push(i.toString());\n        }\n        longListOfStrings.push(obj.id);\n        const q = new Parse.Query('MyClass');\n        q.containedIn('objectId', longListOfStrings);\n        q.containedIn('objectId', longListOfStrings);\n        return q.find();\n      })\n      .then(results => {\n        expect(results.length).toEqual(1);\n        done();\n      });\n  });\n\n  it('containedIn with pointers should work with string array', done => {\n    const obj = new Parse.Object('MyClass');\n    const child = new Parse.Object('Child');\n    child\n      .save()\n      .then(() => {\n        obj.set('child', child);\n        return obj.save();\n      })\n      .then(() => {\n        const objs = [];\n        for (let i = 0; i < 10; i++) {\n          objs.push(new Parse.Object('MyClass'));\n        }\n        return Parse.Object.saveAll(objs);\n      })\n      .then(() => {\n        const query = new Parse.Query('MyClass');\n        query.containedIn('child', [child.id]);\n        return query.find();\n      })\n      .then(results => {\n        expect(results.length).toBe(1);\n      })\n      .then(done)\n      .catch(done.fail);\n  });\n\n  it('containedIn with pointers should work with string array, with many objects', done => {\n    const objs = [];\n    const children = [];\n    for (let i = 0; i < 10; i++) {\n      const obj = new Parse.Object('MyClass');\n      const child = new Parse.Object('Child');\n      objs.push(obj);\n      children.push(child);\n    }\n    Parse.Object.saveAll(children)\n      .then(() => {\n        return Parse.Object.saveAll(\n          objs.map((obj, i) => {\n            obj.set('child', children[i]);\n            return obj;\n          })\n        );\n      })\n      .then(() => {\n        const query = new Parse.Query('MyClass');\n        const subset = children.slice(0, 5).map(child => {\n          return child.id;\n        });\n        query.containedIn('child', subset);\n        return query.find();\n      })\n      .then(results => {\n        expect(results.length).toBe(5);\n      })\n      .then(done)\n      .catch(done.fail);\n  });\n\n  it('include for specific object', function (done) {\n    const child = new Parse.Object('Child');\n    const parent = new Parse.Object('Parent');\n    child.set('foo', 'bar');\n    parent.set('child', child);\n    Parse.Object.saveAll([child, parent]).then(function (response) {\n      const savedParent = response[1];\n      const parentQuery = new Parse.Query('Parent');\n      parentQuery.include('child');\n      parentQuery.get(savedParent.id).then(function (parentObj) {\n        const childPointer = parentObj.get('child');\n        ok(childPointer);\n        equal(childPointer.get('foo'), 'bar');\n        done();\n      });\n    });\n  });\n\n  it('select keys for specific object', function (done) {\n    const Foobar = new Parse.Object('Foobar');\n    Foobar.set('foo', 'bar');\n    Foobar.set('fizz', 'buzz');\n    Foobar.save().then(function (savedFoobar) {\n      const foobarQuery = new Parse.Query('Foobar');\n      foobarQuery.select('fizz');\n      foobarQuery.get(savedFoobar.id).then(function (foobarObj) {\n        equal(foobarObj.get('fizz'), 'buzz');\n        equal(foobarObj.get('foo'), undefined);\n        done();\n      });\n    });\n  });\n\n  it('select nested keys (issue #1567)', function (done) {\n    const Foobar = new Parse.Object('Foobar');\n    const BarBaz = new Parse.Object('Barbaz');\n    BarBaz.set('key', 'value');\n    BarBaz.set('otherKey', 'value');\n    BarBaz.save()\n      .then(() => {\n        Foobar.set('foo', 'bar');\n        Foobar.set('fizz', 'buzz');\n        Foobar.set('barBaz', BarBaz);\n        return Foobar.save();\n      })\n      .then(function (savedFoobar) {\n        const foobarQuery = new Parse.Query('Foobar');\n        foobarQuery.select(['fizz', 'barBaz.key']);\n        foobarQuery.get(savedFoobar.id).then(function (foobarObj) {\n          equal(foobarObj.get('fizz'), 'buzz');\n          equal(foobarObj.get('foo'), undefined);\n          if (foobarObj.has('barBaz')) {\n            equal(foobarObj.get('barBaz').get('key'), 'value');\n            equal(foobarObj.get('barBaz').get('otherKey'), undefined);\n          } else {\n            fail('barBaz should be set');\n          }\n          done();\n        });\n      });\n  });\n\n  it('select nested keys 2 level (issue #1567)', function (done) {\n    const Foobar = new Parse.Object('Foobar');\n    const BarBaz = new Parse.Object('Barbaz');\n    const Bazoo = new Parse.Object('Bazoo');\n\n    Bazoo.set('some', 'thing');\n    Bazoo.set('otherSome', 'value');\n    Bazoo.save()\n      .then(() => {\n        BarBaz.set('key', 'value');\n        BarBaz.set('otherKey', 'value');\n        BarBaz.set('bazoo', Bazoo);\n        return BarBaz.save();\n      })\n      .then(() => {\n        Foobar.set('foo', 'bar');\n        Foobar.set('fizz', 'buzz');\n        Foobar.set('barBaz', BarBaz);\n        return Foobar.save();\n      })\n      .then(function (savedFoobar) {\n        const foobarQuery = new Parse.Query('Foobar');\n        foobarQuery.select(['fizz', 'barBaz.key', 'barBaz.bazoo.some']);\n        foobarQuery.get(savedFoobar.id).then(function (foobarObj) {\n          equal(foobarObj.get('fizz'), 'buzz');\n          equal(foobarObj.get('foo'), undefined);\n          if (foobarObj.has('barBaz')) {\n            equal(foobarObj.get('barBaz').get('key'), 'value');\n            equal(foobarObj.get('barBaz').get('otherKey'), undefined);\n            equal(foobarObj.get('barBaz').get('bazoo').get('some'), 'thing');\n            equal(foobarObj.get('barBaz').get('bazoo').get('otherSome'), undefined);\n          } else {\n            fail('barBaz should be set');\n          }\n          done();\n        });\n      });\n  });\n\n  it('exclude nested keys', async () => {\n    const Foobar = new Parse.Object('Foobar');\n    const BarBaz = new Parse.Object('Barbaz');\n    BarBaz.set('key', 'value');\n    BarBaz.set('otherKey', 'value');\n    await BarBaz.save();\n\n    Foobar.set('foo', 'bar');\n    Foobar.set('fizz', 'buzz');\n    Foobar.set('barBaz', BarBaz);\n    const savedFoobar = await Foobar.save();\n\n    const foobarQuery = new Parse.Query('Foobar');\n    foobarQuery.exclude(['foo', 'barBaz.otherKey']);\n    const foobarObj = await foobarQuery.get(savedFoobar.id);\n    equal(foobarObj.get('fizz'), 'buzz');\n    equal(foobarObj.get('foo'), undefined);\n    if (foobarObj.has('barBaz')) {\n      equal(foobarObj.get('barBaz').get('key'), 'value');\n      equal(foobarObj.get('barBaz').get('otherKey'), undefined);\n    } else {\n      fail('barBaz should be set');\n    }\n  });\n\n  it('exclude nested keys 2 level', async () => {\n    const Foobar = new Parse.Object('Foobar');\n    const BarBaz = new Parse.Object('Barbaz');\n    const Bazoo = new Parse.Object('Bazoo');\n\n    Bazoo.set('some', 'thing');\n    Bazoo.set('otherSome', 'value');\n    await Bazoo.save();\n\n    BarBaz.set('key', 'value');\n    BarBaz.set('otherKey', 'value');\n    BarBaz.set('bazoo', Bazoo);\n    await BarBaz.save();\n\n    Foobar.set('foo', 'bar');\n    Foobar.set('fizz', 'buzz');\n    Foobar.set('barBaz', BarBaz);\n    const savedFoobar = await Foobar.save();\n\n    const foobarQuery = new Parse.Query('Foobar');\n    foobarQuery.exclude(['foo', 'barBaz.otherKey', 'barBaz.bazoo.otherSome']);\n    const foobarObj = await foobarQuery.get(savedFoobar.id);\n    equal(foobarObj.get('fizz'), 'buzz');\n    equal(foobarObj.get('foo'), undefined);\n    if (foobarObj.has('barBaz')) {\n      equal(foobarObj.get('barBaz').get('key'), 'value');\n      equal(foobarObj.get('barBaz').get('otherKey'), undefined);\n      equal(foobarObj.get('barBaz').get('bazoo').get('some'), 'thing');\n      equal(foobarObj.get('barBaz').get('bazoo').get('otherSome'), undefined);\n    } else {\n      fail('barBaz should be set');\n    }\n  });\n\n  it('include with *', async () => {\n    const child1 = new TestObject({ foo: 'bar', name: 'ac' });\n    const child2 = new TestObject({ foo: 'baz', name: 'flo' });\n    const child3 = new TestObject({ foo: 'bad', name: 'mo' });\n    const parent = new Container({ child1, child2, child3 });\n    await Parse.Object.saveAll([parent, child1, child2, child3]);\n    const options = Object.assign({}, masterKeyOptions, {\n      qs: {\n        where: JSON.stringify({ objectId: parent.id }),\n        include: '*',\n      },\n    });\n    const resp = await request(\n      Object.assign({ url: Parse.serverURL + '/classes/Container' }, options)\n    );\n    const result = resp.data.results[0];\n    equal(result.child1.foo, 'bar');\n    equal(result.child2.foo, 'baz');\n    equal(result.child3.foo, 'bad');\n    equal(result.child1.name, 'ac');\n    equal(result.child2.name, 'flo');\n    equal(result.child3.name, 'mo');\n  });\n\n  it('include with [\"*\"]', async () => {\n    const child1 = new TestObject({ foo: 'bar', name: 'ac' });\n    const child2 = new TestObject({ foo: 'baz', name: 'flo' });\n    const child3 = new TestObject({ foo: 'bad', name: 'mo' });\n    const parent = new Container({ child1, child2, child3 });\n    await Parse.Object.saveAll([parent, child1, child2, child3]);\n    const options = Object.assign({}, masterKeyOptions, {\n      qs: {\n        where: JSON.stringify({ objectId: parent.id }),\n        include: '[\"*\"]',\n      },\n    });\n    const resp = await request(\n      Object.assign({ url: Parse.serverURL + '/classes/Container' }, options)\n    );\n    const result = resp.data.results[0];\n    equal(result.child1.foo, 'bar');\n    equal(result.child2.foo, 'baz');\n    equal(result.child3.foo, 'bad');\n    equal(result.child1.name, 'ac');\n    equal(result.child2.name, 'flo');\n    equal(result.child3.name, 'mo');\n  });\n\n  it('include with * overrides', async () => {\n    const child1 = new TestObject({ foo: 'bar', name: 'ac' });\n    const child2 = new TestObject({ foo: 'baz', name: 'flo' });\n    const child3 = new TestObject({ foo: 'bad', name: 'mo' });\n    const parent = new Container({ child1, child2, child3 });\n    await Parse.Object.saveAll([parent, child1, child2, child3]);\n    const options = Object.assign({}, masterKeyOptions, {\n      qs: {\n        where: JSON.stringify({ objectId: parent.id }),\n        include: 'child2,*',\n      },\n    });\n    const resp = await request(\n      Object.assign({ url: Parse.serverURL + '/classes/Container' }, options)\n    );\n    const result = resp.data.results[0];\n    equal(result.child1.foo, 'bar');\n    equal(result.child2.foo, 'baz');\n    equal(result.child3.foo, 'bad');\n    equal(result.child1.name, 'ac');\n    equal(result.child2.name, 'flo');\n    equal(result.child3.name, 'mo');\n  });\n\n  it('include with [\"*\"] overrides', async () => {\n    const child1 = new TestObject({ foo: 'bar', name: 'ac' });\n    const child2 = new TestObject({ foo: 'baz', name: 'flo' });\n    const child3 = new TestObject({ foo: 'bad', name: 'mo' });\n    const parent = new Container({ child1, child2, child3 });\n    await Parse.Object.saveAll([parent, child1, child2, child3]);\n    const options = Object.assign({}, masterKeyOptions, {\n      qs: {\n        where: JSON.stringify({ objectId: parent.id }),\n        include: '[\"child2\",\"*\"]',\n      },\n    });\n    const resp = await request(\n      Object.assign({ url: Parse.serverURL + '/classes/Container' }, options)\n    );\n    const result = resp.data.results[0];\n    equal(result.child1.foo, 'bar');\n    equal(result.child2.foo, 'baz');\n    equal(result.child3.foo, 'bad');\n    equal(result.child1.name, 'ac');\n    equal(result.child2.name, 'flo');\n    equal(result.child3.name, 'mo');\n  });\n\n  it('includeAll', done => {\n    const child1 = new TestObject({ foo: 'bar', name: 'ac' });\n    const child2 = new TestObject({ foo: 'baz', name: 'flo' });\n    const child3 = new TestObject({ foo: 'bad', name: 'mo' });\n    const parent = new Container({ child1, child2, child3 });\n    Parse.Object.saveAll([parent, child1, child2, child3])\n      .then(() => {\n        const options = Object.assign({}, masterKeyOptions, {\n          qs: {\n            where: JSON.stringify({ objectId: parent.id }),\n            includeAll: true,\n          },\n        });\n        return request(Object.assign({ url: Parse.serverURL + '/classes/Container' }, options));\n      })\n      .then(resp => {\n        const result = resp.data.results[0];\n        equal(result.child1.foo, 'bar');\n        equal(result.child2.foo, 'baz');\n        equal(result.child3.foo, 'bad');\n        equal(result.child1.name, 'ac');\n        equal(result.child2.name, 'flo');\n        equal(result.child3.name, 'mo');\n        done();\n      });\n  });\n\n  it('include pointer and pointer array', function (done) {\n    const child = new TestObject();\n    const child2 = new TestObject();\n    child.set('foo', 'bar');\n    child2.set('hello', 'world');\n    Parse.Object.saveAll([child, child2]).then(function () {\n      const parent = new Container();\n      parent.set('child', child.toPointer());\n      parent.set('child2', [child2.toPointer()]);\n      parent.save().then(function () {\n        const query = new Parse.Query(Container);\n        query.include(['child', 'child2']);\n        query.find().then(function (results) {\n          equal(results.length, 1);\n          const parentAgain = results[0];\n          const childAgain = parentAgain.get('child');\n          ok(childAgain);\n          equal(childAgain.get('foo'), 'bar');\n          const child2Again = parentAgain.get('child2');\n          equal(child2Again.length, 1);\n          ok(child2Again);\n          equal(child2Again[0].get('hello'), 'world');\n          done();\n        });\n      });\n    });\n  });\n\n  it('include pointer and pointer array (keys switched)', function (done) {\n    const child = new TestObject();\n    const child2 = new TestObject();\n    child.set('foo', 'bar');\n    child2.set('hello', 'world');\n    Parse.Object.saveAll([child, child2]).then(function () {\n      const parent = new Container();\n      parent.set('child', child.toPointer());\n      parent.set('child2', [child2.toPointer()]);\n      parent.save().then(function () {\n        const query = new Parse.Query(Container);\n        query.include(['child2', 'child']);\n        query.find().then(function (results) {\n          equal(results.length, 1);\n          const parentAgain = results[0];\n          const childAgain = parentAgain.get('child');\n          ok(childAgain);\n          equal(childAgain.get('foo'), 'bar');\n          const child2Again = parentAgain.get('child2');\n          equal(child2Again.length, 1);\n          ok(child2Again);\n          equal(child2Again[0].get('hello'), 'world');\n          done();\n        });\n      });\n    });\n  });\n\n  it('includeAll pointer and pointer array', function (done) {\n    const child = new TestObject();\n    const child2 = new TestObject();\n    child.set('foo', 'bar');\n    child2.set('hello', 'world');\n    Parse.Object.saveAll([child, child2]).then(function () {\n      const parent = new Container();\n      parent.set('child', child.toPointer());\n      parent.set('child2', [child2.toPointer()]);\n      parent.save().then(function () {\n        const query = new Parse.Query(Container);\n        query.includeAll();\n        query.find().then(function (results) {\n          equal(results.length, 1);\n          const parentAgain = results[0];\n          const childAgain = parentAgain.get('child');\n          ok(childAgain);\n          equal(childAgain.get('foo'), 'bar');\n          const child2Again = parentAgain.get('child2');\n          equal(child2Again.length, 1);\n          ok(child2Again);\n          equal(child2Again[0].get('hello'), 'world');\n          done();\n        });\n      });\n    });\n  });\n\n  it('select nested keys 2 level includeAll', done => {\n    const Foobar = new Parse.Object('Foobar');\n    const BarBaz = new Parse.Object('Barbaz');\n    const Bazoo = new Parse.Object('Bazoo');\n    const Tang = new Parse.Object('Tang');\n\n    Bazoo.set('some', 'thing');\n    Bazoo.set('otherSome', 'value');\n    Bazoo.save()\n      .then(() => {\n        BarBaz.set('key', 'value');\n        BarBaz.set('otherKey', 'value');\n        BarBaz.set('bazoo', Bazoo);\n        return BarBaz.save();\n      })\n      .then(() => {\n        Tang.set('clan', 'wu');\n        return Tang.save();\n      })\n      .then(() => {\n        Foobar.set('foo', 'bar');\n        Foobar.set('fizz', 'buzz');\n        Foobar.set('barBaz', BarBaz);\n        Foobar.set('group', Tang);\n        return Foobar.save();\n      })\n      .then(savedFoobar => {\n        const options = Object.assign(\n          {\n            url: Parse.serverURL + '/classes/Foobar',\n          },\n          masterKeyOptions,\n          {\n            qs: {\n              where: JSON.stringify({ objectId: savedFoobar.id }),\n              includeAll: true,\n              keys: 'fizz,barBaz.key,barBaz.bazoo.some',\n            },\n          }\n        );\n        return request(options);\n      })\n      .then(resp => {\n        const result = resp.data.results[0];\n        equal(result.group.clan, 'wu');\n        equal(result.foo, undefined);\n        equal(result.fizz, 'buzz');\n        equal(result.barBaz.key, 'value');\n        equal(result.barBaz.otherKey, undefined);\n        equal(result.barBaz.bazoo.some, 'thing');\n        equal(result.barBaz.bazoo.otherSome, undefined);\n        done();\n      })\n      .catch(done.fail);\n  });\n\n  it('select nested keys 2 level without include (issue #3185)', function (done) {\n    const Foobar = new Parse.Object('Foobar');\n    const BarBaz = new Parse.Object('Barbaz');\n    const Bazoo = new Parse.Object('Bazoo');\n\n    Bazoo.set('some', 'thing');\n    Bazoo.set('otherSome', 'value');\n    Bazoo.save()\n      .then(() => {\n        BarBaz.set('key', 'value');\n        BarBaz.set('otherKey', 'value');\n        BarBaz.set('bazoo', Bazoo);\n        return BarBaz.save();\n      })\n      .then(() => {\n        Foobar.set('foo', 'bar');\n        Foobar.set('fizz', 'buzz');\n        Foobar.set('barBaz', BarBaz);\n        return Foobar.save();\n      })\n      .then(function (savedFoobar) {\n        const foobarQuery = new Parse.Query('Foobar');\n        foobarQuery.select(['fizz', 'barBaz.key', 'barBaz.bazoo.some']);\n        return foobarQuery.get(savedFoobar.id);\n      })\n      .then(foobarObj => {\n        equal(foobarObj.get('fizz'), 'buzz');\n        equal(foobarObj.get('foo'), undefined);\n        if (foobarObj.has('barBaz')) {\n          equal(foobarObj.get('barBaz').get('key'), 'value');\n          equal(foobarObj.get('barBaz').get('otherKey'), undefined);\n          if (foobarObj.get('barBaz').has('bazoo')) {\n            equal(foobarObj.get('barBaz').get('bazoo').get('some'), 'thing');\n            equal(foobarObj.get('barBaz').get('bazoo').get('otherSome'), undefined);\n          } else {\n            fail('bazoo should be set');\n          }\n        } else {\n          fail('barBaz should be set');\n        }\n        done();\n      });\n  });\n\n  it('properly handles nested ors', function (done) {\n    const objects = [];\n    while (objects.length != 4) {\n      const obj = new Parse.Object('Object');\n      obj.set('x', objects.length);\n      objects.push(obj);\n    }\n    Parse.Object.saveAll(objects)\n      .then(() => {\n        const q0 = new Parse.Query('Object');\n        q0.equalTo('x', 0);\n        const q1 = new Parse.Query('Object');\n        q1.equalTo('x', 1);\n        const q2 = new Parse.Query('Object');\n        q2.equalTo('x', 2);\n        const or01 = Parse.Query.or(q0, q1);\n        return Parse.Query.or(or01, q2).find();\n      })\n      .then(results => {\n        expect(results.length).toBe(3);\n        done();\n      })\n      .catch(error => {\n        fail('should not fail');\n        jfail(error);\n        done();\n      });\n  });\n\n  it('should not depend on parameter order #3169', function (done) {\n    const score1 = new Parse.Object('Score', { scoreId: '1' });\n    const score2 = new Parse.Object('Score', { scoreId: '2' });\n    const game1 = new Parse.Object('Game', { gameId: '1' });\n    const game2 = new Parse.Object('Game', { gameId: '2' });\n    Parse.Object.saveAll([score1, score2, game1, game2])\n      .then(() => {\n        game1.set('score', [score1]);\n        game2.set('score', [score2]);\n        return Parse.Object.saveAll([game1, game2]);\n      })\n      .then(() => {\n        const where = {\n          score: {\n            objectId: score1.id,\n            className: 'Score',\n            __type: 'Pointer',\n          },\n        };\n        return request({\n          method: 'POST',\n          url: Parse.serverURL + '/classes/Game',\n          body: { where, _method: 'GET' },\n          headers: {\n            'X-Parse-Application-Id': Parse.applicationId,\n            'X-Parse-Javascript-Key': Parse.javaScriptKey,\n            'Content-Type': 'application/json',\n          },\n        });\n      })\n      .then(\n        response => {\n          const results = response.data;\n          expect(results.results.length).toBe(1);\n          done();\n        },\n        res => done.fail(res.data)\n      );\n  });\n\n  it('should not interfere with has when using select on field with undefined value #3999', done => {\n    const obj1 = new Parse.Object('TestObject');\n    const obj2 = new Parse.Object('OtherObject');\n    obj2.set('otherField', 1);\n    obj1.set('testPointerField', obj2);\n    obj1.set('shouldBe', true);\n    const obj3 = new Parse.Object('TestObject');\n    obj3.set('shouldBe', false);\n    Parse.Object.saveAll([obj1, obj3])\n      .then(() => {\n        const query = new Parse.Query('TestObject');\n        query.include('testPointerField');\n        query.select(['testPointerField', 'testPointerField.otherField', 'shouldBe']);\n        return query.find();\n      })\n      .then(results => {\n        results.forEach(result => {\n          equal(result.has('testPointerField'), result.get('shouldBe'));\n        });\n        done();\n      })\n      .catch(done.fail);\n  });\n\n  it_only_db('mongo')('should handle relative times correctly', function (done) {\n    const now = Date.now();\n    const obj1 = new Parse.Object('MyCustomObject', {\n      name: 'obj1',\n      ttl: new Date(now + 2 * 24 * 60 * 60 * 1000), // 2 days from now\n    });\n    const obj2 = new Parse.Object('MyCustomObject', {\n      name: 'obj2',\n      ttl: new Date(now - 2 * 24 * 60 * 60 * 1000), // 2 days ago\n    });\n\n    Parse.Object.saveAll([obj1, obj2])\n      .then(() => {\n        const q = new Parse.Query('MyCustomObject');\n        q.greaterThan('ttl', { $relativeTime: 'in 1 day' });\n        return q.find({ useMasterKey: true });\n      })\n      .then(results => {\n        expect(results.length).toBe(1);\n      })\n      .then(() => {\n        const q = new Parse.Query('MyCustomObject');\n        q.greaterThan('ttl', { $relativeTime: '1 day ago' });\n        return q.find({ useMasterKey: true });\n      })\n      .then(results => {\n        expect(results.length).toBe(1);\n      })\n      .then(() => {\n        const q = new Parse.Query('MyCustomObject');\n        q.lessThan('ttl', { $relativeTime: '5 days ago' });\n        return q.find({ useMasterKey: true });\n      })\n      .then(results => {\n        expect(results.length).toBe(0);\n      })\n      .then(() => {\n        const q = new Parse.Query('MyCustomObject');\n        q.greaterThan('ttl', { $relativeTime: '3 days ago' });\n        return q.find({ useMasterKey: true });\n      })\n      .then(results => {\n        expect(results.length).toBe(2);\n      })\n      .then(() => {\n        const q = new Parse.Query('MyCustomObject');\n        q.greaterThan('ttl', { $relativeTime: 'now' });\n        return q.find({ useMasterKey: true });\n      })\n      .then(results => {\n        expect(results.length).toBe(1);\n      })\n      .then(() => {\n        const q = new Parse.Query('MyCustomObject');\n        q.greaterThan('ttl', { $relativeTime: 'now' });\n        q.lessThan('ttl', { $relativeTime: 'in 1 day' });\n        return q.find({ useMasterKey: true });\n      })\n      .then(results => {\n        expect(results.length).toBe(0);\n      })\n      .then(() => {\n        const q = new Parse.Query('MyCustomObject');\n        q.greaterThan('ttl', { $relativeTime: '1 year 3 weeks ago' });\n        return q.find({ useMasterKey: true });\n      })\n      .then(results => {\n        expect(results.length).toBe(2);\n      })\n      .then(done, done.fail);\n  });\n\n  it_only_db('mongo')('should error on invalid relative time', function (done) {\n    const obj1 = new Parse.Object('MyCustomObject', {\n      name: 'obj1',\n      ttl: new Date(Date.now() + 2 * 24 * 60 * 60 * 1000), // 2 days from now\n    });\n\n    const q = new Parse.Query('MyCustomObject');\n    q.greaterThan('ttl', { $relativeTime: '-12 bananas ago' });\n    obj1\n      .save({ useMasterKey: true })\n      .then(() => q.find({ useMasterKey: true }))\n      .then(done.fail, () => done());\n  });\n\n  it_only_db('mongo')('should error when using $relativeTime on non-Date field', function (done) {\n    const obj1 = new Parse.Object('MyCustomObject', {\n      name: 'obj1',\n      nonDateField: 'abcd',\n      ttl: new Date(Date.now() + 2 * 24 * 60 * 60 * 1000), // 2 days from now\n    });\n\n    const q = new Parse.Query('MyCustomObject');\n    q.greaterThan('nonDateField', { $relativeTime: '1 day ago' });\n    obj1\n      .save({ useMasterKey: true })\n      .then(() => q.find({ useMasterKey: true }))\n      .then(done.fail, () => done());\n  });\n\n  it('should match complex structure with dot notation when using matchesKeyInQuery', function (done) {\n    const group1 = new Parse.Object('Group', {\n      name: 'Group #1',\n    });\n\n    const group2 = new Parse.Object('Group', {\n      name: 'Group #2',\n    });\n\n    Parse.Object.saveAll([group1, group2])\n      .then(() => {\n        const role1 = new Parse.Object('Role', {\n          name: 'Role #1',\n          type: 'x',\n          belongsTo: group1,\n        });\n\n        const role2 = new Parse.Object('Role', {\n          name: 'Role #2',\n          type: 'y',\n          belongsTo: group1,\n        });\n\n        return Parse.Object.saveAll([role1, role2]);\n      })\n      .then(() => {\n        const rolesOfTypeX = new Parse.Query('Role');\n        rolesOfTypeX.equalTo('type', 'x');\n\n        const groupsWithRoleX = new Parse.Query('Group');\n        groupsWithRoleX.matchesKeyInQuery('objectId', 'belongsTo.objectId', rolesOfTypeX);\n\n        groupsWithRoleX.find().then(function (results) {\n          equal(results.length, 1);\n          equal(results[0].get('name'), group1.get('name'));\n          done();\n        });\n      });\n  });\n\n  it('should match complex structure with dot notation when using doesNotMatchKeyInQuery', function (done) {\n    const group1 = new Parse.Object('Group', {\n      name: 'Group #1',\n    });\n\n    const group2 = new Parse.Object('Group', {\n      name: 'Group #2',\n    });\n\n    Parse.Object.saveAll([group1, group2])\n      .then(() => {\n        const role1 = new Parse.Object('Role', {\n          name: 'Role #1',\n          type: 'x',\n          belongsTo: group1,\n        });\n\n        const role2 = new Parse.Object('Role', {\n          name: 'Role #2',\n          type: 'y',\n          belongsTo: group1,\n        });\n\n        return Parse.Object.saveAll([role1, role2]);\n      })\n      .then(() => {\n        const rolesOfTypeX = new Parse.Query('Role');\n        rolesOfTypeX.equalTo('type', 'x');\n\n        const groupsWithRoleX = new Parse.Query('Group');\n        groupsWithRoleX.doesNotMatchKeyInQuery('objectId', 'belongsTo.objectId', rolesOfTypeX);\n\n        groupsWithRoleX.find().then(function (results) {\n          equal(results.length, 1);\n          equal(results[0].get('name'), group2.get('name'));\n          done();\n        });\n      });\n  });\n\n  it('should not throw error with undefined dot notation when using matchesKeyInQuery', async () => {\n    const group = new Parse.Object('Group', { name: 'Group #1' });\n    await group.save();\n\n    const role1 = new Parse.Object('Role', {\n      name: 'Role #1',\n      type: 'x',\n      belongsTo: group,\n    });\n\n    const role2 = new Parse.Object('Role', {\n      name: 'Role #2',\n      type: 'y',\n      belongsTo: undefined,\n    });\n    await Parse.Object.saveAll([role1, role2]);\n\n    const rolesOfTypeX = new Parse.Query('Role');\n    rolesOfTypeX.equalTo('type', 'x');\n\n    const groupsWithRoleX = new Parse.Query('Group');\n    groupsWithRoleX.matchesKeyInQuery('objectId', 'belongsTo.objectId', rolesOfTypeX);\n\n    const results = await groupsWithRoleX.find();\n    equal(results.length, 1);\n    equal(results[0].get('name'), group.get('name'));\n  });\n\n  it('should not throw error with undefined dot notation when using doesNotMatchKeyInQuery', async () => {\n    const group1 = new Parse.Object('Group', { name: 'Group #1' });\n    const group2 = new Parse.Object('Group', { name: 'Group #2' });\n    await Parse.Object.saveAll([group1, group2]);\n\n    const role1 = new Parse.Object('Role', {\n      name: 'Role #1',\n      type: 'x',\n      belongsTo: group1,\n    });\n\n    const role2 = new Parse.Object('Role', {\n      name: 'Role #2',\n      type: 'y',\n      belongsTo: undefined,\n    });\n    await Parse.Object.saveAll([role1, role2]);\n\n    const rolesOfTypeX = new Parse.Query('Role');\n    rolesOfTypeX.equalTo('type', 'x');\n\n    const groupsWithRoleX = new Parse.Query('Group');\n    groupsWithRoleX.doesNotMatchKeyInQuery('objectId', 'belongsTo.objectId', rolesOfTypeX);\n\n    const results = await groupsWithRoleX.find();\n    equal(results.length, 1);\n    equal(results[0].get('name'), group2.get('name'));\n  });\n\n  it('withJSON supports geoWithin.centerSphere', done => {\n    const inbound = new Parse.GeoPoint(1.5, 1.5);\n    const onbound = new Parse.GeoPoint(10, 10);\n    const outbound = new Parse.GeoPoint(20, 20);\n    const obj1 = new Parse.Object('TestObject', { location: inbound });\n    const obj2 = new Parse.Object('TestObject', { location: onbound });\n    const obj3 = new Parse.Object('TestObject', { location: outbound });\n    const center = new Parse.GeoPoint(0, 0);\n    const distanceInKilometers = 1569 + 1; // 1569km is the approximate distance between {0, 0} and {10, 10}.\n    Parse.Object.saveAll([obj1, obj2, obj3])\n      .then(() => {\n        const q = new Parse.Query(TestObject);\n        const jsonQ = q.toJSON();\n        jsonQ.where.location = {\n          $geoWithin: {\n            $centerSphere: [center, distanceInKilometers / 6371.0],\n          },\n        };\n        q.withJSON(jsonQ);\n        return q.find();\n      })\n      .then(results => {\n        equal(results.length, 2);\n        const q = new Parse.Query(TestObject);\n        const jsonQ = q.toJSON();\n        jsonQ.where.location = {\n          $geoWithin: {\n            $centerSphere: [[0, 0], distanceInKilometers / 6371.0],\n          },\n        };\n        q.withJSON(jsonQ);\n        return q.find();\n      })\n      .then(results => {\n        equal(results.length, 2);\n        done();\n      })\n      .catch(error => {\n        fail(error);\n        done();\n      });\n  });\n\n  it('withJSON with geoWithin.centerSphere fails without parameters', done => {\n    const q = new Parse.Query(TestObject);\n    const jsonQ = q.toJSON();\n    jsonQ.where.location = {\n      $geoWithin: {\n        $centerSphere: [],\n      },\n    };\n    q.withJSON(jsonQ);\n    q.find()\n      .then(done.fail)\n      .catch(e => expect(e.code).toBe(Parse.Error.INVALID_JSON))\n      .then(done);\n  });\n\n  it('withJSON with geoWithin.centerSphere fails with invalid distance', done => {\n    const q = new Parse.Query(TestObject);\n    const jsonQ = q.toJSON();\n    jsonQ.where.location = {\n      $geoWithin: {\n        $centerSphere: [[0, 0], 'invalid_distance'],\n      },\n    };\n    q.withJSON(jsonQ);\n    q.find()\n      .then(done.fail)\n      .catch(e => expect(e.code).toBe(Parse.Error.INVALID_JSON))\n      .then(done);\n  });\n\n  it('withJSON with geoWithin.centerSphere fails with invalid coordinate', done => {\n    const q = new Parse.Query(TestObject);\n    const jsonQ = q.toJSON();\n    jsonQ.where.location = {\n      $geoWithin: {\n        $centerSphere: [[-190, -190], 1],\n      },\n    };\n    q.withJSON(jsonQ);\n    q.find()\n      .then(done.fail)\n      .catch(() => done());\n  });\n\n  it('withJSON with geoWithin.centerSphere fails with invalid geo point', done => {\n    const q = new Parse.Query(TestObject);\n    const jsonQ = q.toJSON();\n    jsonQ.where.location = {\n      $geoWithin: {\n        $centerSphere: [{ longitude: 0, dummytude: 0 }, 1],\n      },\n    };\n    q.withJSON(jsonQ);\n    q.find()\n      .then(done.fail)\n      .catch(() => done());\n  });\n\n  it('can add new config to existing config', async () => {\n    await request({\n      method: 'PUT',\n      url: 'http://localhost:8378/1/config',\n      json: true,\n      body: {\n        params: {\n          files: [{ __type: 'File', name: 'name', url: 'http://url' }],\n        },\n      },\n      headers: masterKeyHeaders,\n    });\n\n    await request({\n      method: 'PUT',\n      url: 'http://localhost:8378/1/config',\n      json: true,\n      body: {\n        params: { newConfig: 'good' },\n      },\n      headers: masterKeyHeaders,\n    });\n\n    const result = await Parse.Config.get();\n    equal(result.get('files')[0].toJSON(), {\n      __type: 'File',\n      name: 'name',\n      url: 'http://url',\n    });\n    equal(result.get('newConfig'), 'good');\n  });\n\n  it('can set object type key', async () => {\n    const data = { bar: true, baz: 100 };\n    const object = new TestObject();\n    object.set('objectField', data);\n    await object.save();\n\n    const query = new Parse.Query(TestObject);\n    let result = await query.get(object.id);\n    equal(result.get('objectField'), data);\n\n    object.set('objectField.baz', 50, { ignoreValidation: true });\n    await object.save();\n\n    result = await query.get(object.id);\n    equal(result.get('objectField'), { bar: true, baz: 50 });\n  });\n\n  it('can update numeric array', async () => {\n    const data1 = [0, 1.1, 1, -2, 3];\n    const data2 = [0, 1.1, 1, -2, 3, 4];\n    const obj1 = new TestObject();\n    obj1.set('array', data1);\n    await obj1.save();\n    equal(obj1.get('array'), data1);\n\n    const query = new Parse.Query(TestObject);\n    query.equalTo('objectId', obj1.id);\n\n    const result = await query.first();\n    equal(result.get('array'), data1);\n\n    result.set('array', data2);\n    equal(result.get('array'), data2);\n    await result.save();\n    equal(result.get('array'), data2);\n\n    const results = await query.find();\n    equal(results[0].get('array'), data2);\n  });\n\n  it('can update mixed array', async () => {\n    const data1 = [0, 1.1, 'hello world', { foo: 'bar' }];\n    const data2 = [0, 1, { foo: 'bar' }, [], [1, 2, 'bar']];\n    const obj1 = new TestObject();\n    obj1.set('array', data1);\n    await obj1.save();\n    equal(obj1.get('array'), data1);\n\n    const query = new Parse.Query(TestObject);\n    query.equalTo('objectId', obj1.id);\n\n    const result = await query.first();\n    equal(result.get('array'), data1);\n\n    result.set('array', data2);\n    equal(result.get('array'), data2);\n\n    await result.save();\n    equal(result.get('array'), data2);\n\n    const results = await query.find();\n    equal(results[0].get('array'), data2);\n  });\n\n  it('can query regex with unicode', async () => {\n    const object = new TestObject();\n    object.set('field', 'auto\u00f6o');\n    await object.save();\n\n    const query = new Parse.Query(TestObject);\n    query.contains('field', 'auto\u00f6o');\n    const results = await query.find();\n\n    expect(results.length).toBe(1);\n    expect(results[0].get('field')).toBe('auto\u00f6o');\n  });\n\n  it('can update mixed array more than 100 elements', async () => {\n    const array = [0, 1.1, 'hello world', { foo: 'bar' }, null];\n    const obj = new TestObject({ array });\n    await obj.save();\n\n    const query = new Parse.Query(TestObject);\n    const result = await query.get(obj.id);\n    equal(result.get('array').length, 5);\n\n    for (let i = 0; i < 100; i += 1) {\n      array.push(i);\n    }\n    obj.set('array', array);\n    await obj.save();\n\n    const results = await query.find();\n    equal(results[0].get('array').length, 105);\n  });\n\n  xit('todo: exclude keys with select key (sdk query get)', async done => {\n    // there is some problem with js sdk caching\n\n    const obj = new TestObject({ foo: 'baz', hello: 'world' });\n    await obj.save();\n\n    const query = new Parse.Query('TestObject');\n\n    query.withJSON({\n      keys: 'hello',\n      excludeKeys: 'hello',\n    });\n\n    const object = await query.get(obj.id);\n    expect(object.get('foo')).toBeUndefined();\n    expect(object.get('hello')).toBeUndefined();\n    done();\n  });\n\n  it_only_db('mongo')('can use explain on User class', async () => {\n    // Create user\n    const user = new Parse.User();\n    user.set('username', 'foo');\n    user.set('password', 'bar');\n    await user.save();\n    // Query for user with explain\n    const query = new Parse.Query('_User');\n    query.equalTo('objectId', user.id);\n    query.explain();\n    const result = await query.find();\n    // Validate\n    expect(result.executionStats).not.toBeUndefined();\n  });\n});\n", "// @flow\nimport MongoCollection from './MongoCollection';\nimport MongoSchemaCollection from './MongoSchemaCollection';\nimport { StorageAdapter } from '../StorageAdapter';\nimport type { SchemaType, QueryType, StorageClass, QueryOptions } from '../StorageAdapter';\nimport { parse as parseUrl, format as formatUrl } from '../../../vendor/mongodbUrl';\nimport {\n  parseObjectToMongoObjectForCreate,\n  mongoObjectToParseObject,\n  transformKey,\n  transformWhere,\n  transformUpdate,\n  transformPointerString,\n} from './MongoTransform';\n// @flow-disable-next\nimport Parse from 'parse/node';\n// @flow-disable-next\nimport _ from 'lodash';\nimport defaults from '../../../defaults';\nimport logger from '../../../logger';\n\n// @flow-disable-next\nconst mongodb = require('mongodb');\nconst MongoClient = mongodb.MongoClient;\nconst ReadPreference = mongodb.ReadPreference;\n\nconst MongoSchemaCollectionName = '_SCHEMA';\n\nconst storageAdapterAllCollections = mongoAdapter => {\n  return mongoAdapter\n    .connect()\n    .then(() => mongoAdapter.database.collections())\n    .then(collections => {\n      return collections.filter(collection => {\n        if (collection.namespace.match(/\\.system\\./)) {\n          return false;\n        }\n        // TODO: If you have one app with a collection prefix that happens to be a prefix of another\n        // apps prefix, this will go very very badly. We should fix that somehow.\n        return collection.collectionName.indexOf(mongoAdapter._collectionPrefix) == 0;\n      });\n    });\n};\n\nconst convertParseSchemaToMongoSchema = ({ ...schema }) => {\n  delete schema.fields._rperm;\n  delete schema.fields._wperm;\n\n  if (schema.className === '_User') {\n    // Legacy mongo adapter knows about the difference between password and _hashed_password.\n    // Future database adapters will only know about _hashed_password.\n    // Note: Parse Server will bring back password with injectDefaultSchema, so we don't need\n    // to add _hashed_password back ever.\n    delete schema.fields._hashed_password;\n  }\n\n  return schema;\n};\n\n// Returns { code, error } if invalid, or { result }, an object\n// suitable for inserting into _SCHEMA collection, otherwise.\nconst mongoSchemaFromFieldsAndClassNameAndCLP = (\n  fields,\n  className,\n  classLevelPermissions,\n  indexes\n) => {\n  const mongoObject = {\n    _id: className,\n    objectId: 'string',\n    updatedAt: 'string',\n    createdAt: 'string',\n    _metadata: undefined,\n  };\n\n  for (const fieldName in fields) {\n    const { type, targetClass, ...fieldOptions } = fields[fieldName];\n    mongoObject[fieldName] = MongoSchemaCollection.parseFieldTypeToMongoFieldType({\n      type,\n      targetClass,\n    });\n    if (fieldOptions && Object.keys(fieldOptions).length > 0) {\n      mongoObject._metadata = mongoObject._metadata || {};\n      mongoObject._metadata.fields_options = mongoObject._metadata.fields_options || {};\n      mongoObject._metadata.fields_options[fieldName] = fieldOptions;\n    }\n  }\n\n  if (typeof classLevelPermissions !== 'undefined') {\n    mongoObject._metadata = mongoObject._metadata || {};\n    if (!classLevelPermissions) {\n      delete mongoObject._metadata.class_permissions;\n    } else {\n      mongoObject._metadata.class_permissions = classLevelPermissions;\n    }\n  }\n\n  if (indexes && typeof indexes === 'object' && Object.keys(indexes).length > 0) {\n    mongoObject._metadata = mongoObject._metadata || {};\n    mongoObject._metadata.indexes = indexes;\n  }\n\n  if (!mongoObject._metadata) {\n    // cleanup the unused _metadata\n    delete mongoObject._metadata;\n  }\n\n  return mongoObject;\n};\n\nfunction validateExplainValue(explain) {\n  if (explain) {\n    // The list of allowed explain values is from node-mongodb-native/lib/explain.js\n    const explainAllowedValues = [\n      'queryPlanner',\n      'queryPlannerExtended',\n      'executionStats',\n      'allPlansExecution',\n      false,\n      true,\n    ];\n    if (!explainAllowedValues.includes(explain)) {\n      throw new Parse.Error(Parse.Error.INVALID_QUERY, 'Invalid value for explain');\n    }\n  }\n}\n\nexport class MongoStorageAdapter implements StorageAdapter {\n  // Private\n  _uri: string;\n  _collectionPrefix: string;\n  _mongoOptions: Object;\n  _onchange: any;\n  _stream: any;\n  // Public\n  connectionPromise: ?Promise<any>;\n  database: any;\n  client: MongoClient;\n  _maxTimeMS: ?number;\n  canSortOnJoinTables: boolean;\n  enableSchemaHooks: boolean;\n\n  constructor({ uri = defaults.DefaultMongoURI, collectionPrefix = '', mongoOptions = {} }: any) {\n    this._uri = uri;\n    this._collectionPrefix = collectionPrefix;\n    this._mongoOptions = mongoOptions;\n    this._mongoOptions.useNewUrlParser = true;\n    this._mongoOptions.useUnifiedTopology = true;\n    this._onchange = () => {};\n\n    // MaxTimeMS is not a global MongoDB client option, it is applied per operation.\n    this._maxTimeMS = mongoOptions.maxTimeMS;\n    this.canSortOnJoinTables = true;\n    this.enableSchemaHooks = !!mongoOptions.enableSchemaHooks;\n    delete mongoOptions.enableSchemaHooks;\n    delete mongoOptions.maxTimeMS;\n  }\n\n  watch(callback: () => void): void {\n    this._onchange = callback;\n  }\n\n  connect() {\n    if (this.connectionPromise) {\n      return this.connectionPromise;\n    }\n\n    // parsing and re-formatting causes the auth value (if there) to get URI\n    // encoded\n    const encodedUri = formatUrl(parseUrl(this._uri));\n\n    this.connectionPromise = MongoClient.connect(encodedUri, this._mongoOptions)\n      .then(client => {\n        // Starting mongoDB 3.0, the MongoClient.connect don't return a DB anymore but a client\n        // Fortunately, we can get back the options and use them to select the proper DB.\n        // https://github.com/mongodb/node-mongodb-native/blob/2c35d76f08574225b8db02d7bef687123e6bb018/lib/mongo_client.js#L885\n        const options = client.s.options;\n        const database = client.db(options.dbName);\n        if (!database) {\n          delete this.connectionPromise;\n          return;\n        }\n        database.on('error', () => {\n          delete this.connectionPromise;\n        });\n        database.on('close', () => {\n          delete this.connectionPromise;\n        });\n        this.client = client;\n        this.database = database;\n      })\n      .catch(err => {\n        delete this.connectionPromise;\n        return Promise.reject(err);\n      });\n\n    return this.connectionPromise;\n  }\n\n  handleError<T>(error: ?(Error | Parse.Error)): Promise<T> {\n    if (error && error.code === 13) {\n      // Unauthorized error\n      delete this.client;\n      delete this.database;\n      delete this.connectionPromise;\n      logger.error('Received unauthorized error', { error: error });\n    }\n    throw error;\n  }\n\n  handleShutdown() {\n    if (!this.client) {\n      return Promise.resolve();\n    }\n    return this.client.close(false);\n  }\n\n  _adaptiveCollection(name: string) {\n    return this.connect()\n      .then(() => this.database.collection(this._collectionPrefix + name))\n      .then(rawCollection => new MongoCollection(rawCollection))\n      .catch(err => this.handleError(err));\n  }\n\n  _schemaCollection(): Promise<MongoSchemaCollection> {\n    return this.connect()\n      .then(() => this._adaptiveCollection(MongoSchemaCollectionName))\n      .then(collection => {\n        if (!this._stream && this.enableSchemaHooks) {\n          this._stream = collection._mongoCollection.watch();\n          this._stream.on('change', () => this._onchange());\n        }\n        return new MongoSchemaCollection(collection);\n      });\n  }\n\n  classExists(name: string) {\n    return this.connect()\n      .then(() => {\n        return this.database.listCollections({ name: this._collectionPrefix + name }).toArray();\n      })\n      .then(collections => {\n        return collections.length > 0;\n      })\n      .catch(err => this.handleError(err));\n  }\n\n  setClassLevelPermissions(className: string, CLPs: any): Promise<void> {\n    return this._schemaCollection()\n      .then(schemaCollection =>\n        schemaCollection.updateSchema(className, {\n          $set: { '_metadata.class_permissions': CLPs },\n        })\n      )\n      .catch(err => this.handleError(err));\n  }\n\n  setIndexesWithSchemaFormat(\n    className: string,\n    submittedIndexes: any,\n    existingIndexes: any = {},\n    fields: any\n  ): Promise<void> {\n    if (submittedIndexes === undefined) {\n      return Promise.resolve();\n    }\n    if (Object.keys(existingIndexes).length === 0) {\n      existingIndexes = { _id_: { _id: 1 } };\n    }\n    const deletePromises = [];\n    const insertedIndexes = [];\n    Object.keys(submittedIndexes).forEach(name => {\n      const field = submittedIndexes[name];\n      if (existingIndexes[name] && field.__op !== 'Delete') {\n        throw new Parse.Error(Parse.Error.INVALID_QUERY, `Index ${name} exists, cannot update.`);\n      }\n      if (!existingIndexes[name] && field.__op === 'Delete') {\n        throw new Parse.Error(\n          Parse.Error.INVALID_QUERY,\n          `Index ${name} does not exist, cannot delete.`\n        );\n      }\n      if (field.__op === 'Delete') {\n        const promise = this.dropIndex(className, name);\n        deletePromises.push(promise);\n        delete existingIndexes[name];\n      } else {\n        Object.keys(field).forEach(key => {\n          if (\n            !Object.prototype.hasOwnProperty.call(\n              fields,\n              key.indexOf('_p_') === 0 ? key.replace('_p_', '') : key\n            )\n          ) {\n            throw new Parse.Error(\n              Parse.Error.INVALID_QUERY,\n              `Field ${key} does not exist, cannot add index.`\n            );\n          }\n        });\n        existingIndexes[name] = field;\n        insertedIndexes.push({\n          key: field,\n          name,\n        });\n      }\n    });\n    let insertPromise = Promise.resolve();\n    if (insertedIndexes.length > 0) {\n      insertPromise = this.createIndexes(className, insertedIndexes);\n    }\n    return Promise.all(deletePromises)\n      .then(() => insertPromise)\n      .then(() => this._schemaCollection())\n      .then(schemaCollection =>\n        schemaCollection.updateSchema(className, {\n          $set: { '_metadata.indexes': existingIndexes },\n        })\n      )\n      .catch(err => this.handleError(err));\n  }\n\n  setIndexesFromMongo(className: string) {\n    return this.getIndexes(className)\n      .then(indexes => {\n        indexes = indexes.reduce((obj, index) => {\n          if (index.key._fts) {\n            delete index.key._fts;\n            delete index.key._ftsx;\n            for (const field in index.weights) {\n              index.key[field] = 'text';\n            }\n          }\n          obj[index.name] = index.key;\n          return obj;\n        }, {});\n        return this._schemaCollection().then(schemaCollection =>\n          schemaCollection.updateSchema(className, {\n            $set: { '_metadata.indexes': indexes },\n          })\n        );\n      })\n      .catch(err => this.handleError(err))\n      .catch(() => {\n        // Ignore if collection not found\n        return Promise.resolve();\n      });\n  }\n\n  createClass(className: string, schema: SchemaType): Promise<void> {\n    schema = convertParseSchemaToMongoSchema(schema);\n    const mongoObject = mongoSchemaFromFieldsAndClassNameAndCLP(\n      schema.fields,\n      className,\n      schema.classLevelPermissions,\n      schema.indexes\n    );\n    mongoObject._id = className;\n    return this.setIndexesWithSchemaFormat(className, schema.indexes, {}, schema.fields)\n      .then(() => this._schemaCollection())\n      .then(schemaCollection => schemaCollection.insertSchema(mongoObject))\n      .catch(err => this.handleError(err));\n  }\n\n  addFieldIfNotExists(className: string, fieldName: string, type: any): Promise<void> {\n    return this._schemaCollection()\n      .then(schemaCollection => schemaCollection.addFieldIfNotExists(className, fieldName, type))\n      .then(() => this.createIndexesIfNeeded(className, fieldName, type))\n      .catch(err => this.handleError(err));\n  }\n\n  // Drops a collection. Resolves with true if it was a Parse Schema (eg. _User, Custom, etc.)\n  // and resolves with false if it wasn't (eg. a join table). Rejects if deletion was impossible.\n  deleteClass(className: string) {\n    return (\n      this._adaptiveCollection(className)\n        .then(collection => collection.drop())\n        .catch(error => {\n          // 'ns not found' means collection was already gone. Ignore deletion attempt.\n          if (error.message == 'ns not found') {\n            return;\n          }\n          throw error;\n        })\n        // We've dropped the collection, now remove the _SCHEMA document\n        .then(() => this._schemaCollection())\n        .then(schemaCollection => schemaCollection.findAndDeleteSchema(className))\n        .catch(err => this.handleError(err))\n    );\n  }\n\n  deleteAllClasses(fast: boolean) {\n    return storageAdapterAllCollections(this).then(collections =>\n      Promise.all(\n        collections.map(collection => (fast ? collection.deleteMany({}) : collection.drop()))\n      )\n    );\n  }\n\n  // Remove the column and all the data. For Relations, the _Join collection is handled\n  // specially, this function does not delete _Join columns. It should, however, indicate\n  // that the relation fields does not exist anymore. In mongo, this means removing it from\n  // the _SCHEMA collection.  There should be no actual data in the collection under the same name\n  // as the relation column, so it's fine to attempt to delete it. If the fields listed to be\n  // deleted do not exist, this function should return successfully anyways. Checking for\n  // attempts to delete non-existent fields is the responsibility of Parse Server.\n\n  // Pointer field names are passed for legacy reasons: the original mongo\n  // format stored pointer field names differently in the database, and therefore\n  // needed to know the type of the field before it could delete it. Future database\n  // adapters should ignore the pointerFieldNames argument. All the field names are in\n  // fieldNames, they show up additionally in the pointerFieldNames database for use\n  // by the mongo adapter, which deals with the legacy mongo format.\n\n  // This function is not obligated to delete fields atomically. It is given the field\n  // names in a list so that databases that are capable of deleting fields atomically\n  // may do so.\n\n  // Returns a Promise.\n  deleteFields(className: string, schema: SchemaType, fieldNames: string[]) {\n    const mongoFormatNames = fieldNames.map(fieldName => {\n      if (schema.fields[fieldName].type === 'Pointer') {\n        return `_p_${fieldName}`;\n      } else {\n        return fieldName;\n      }\n    });\n    const collectionUpdate = { $unset: {} };\n    mongoFormatNames.forEach(name => {\n      collectionUpdate['$unset'][name] = null;\n    });\n\n    const collectionFilter = { $or: [] };\n    mongoFormatNames.forEach(name => {\n      collectionFilter['$or'].push({ [name]: { $exists: true } });\n    });\n\n    const schemaUpdate = { $unset: {} };\n    fieldNames.forEach(name => {\n      schemaUpdate['$unset'][name] = null;\n      schemaUpdate['$unset'][`_metadata.fields_options.${name}`] = null;\n    });\n\n    return this._adaptiveCollection(className)\n      .then(collection => collection.updateMany(collectionFilter, collectionUpdate))\n      .then(() => this._schemaCollection())\n      .then(schemaCollection => schemaCollection.updateSchema(className, schemaUpdate))\n      .catch(err => this.handleError(err));\n  }\n\n  // Return a promise for all schemas known to this adapter, in Parse format. In case the\n  // schemas cannot be retrieved, returns a promise that rejects. Requirements for the\n  // rejection reason are TBD.\n  getAllClasses(): Promise<StorageClass[]> {\n    return this._schemaCollection()\n      .then(schemasCollection => schemasCollection._fetchAllSchemasFrom_SCHEMA())\n      .catch(err => this.handleError(err));\n  }\n\n  // Return a promise for the schema with the given name, in Parse format. If\n  // this adapter doesn't know about the schema, return a promise that rejects with\n  // undefined as the reason.\n  getClass(className: string): Promise<StorageClass> {\n    return this._schemaCollection()\n      .then(schemasCollection => schemasCollection._fetchOneSchemaFrom_SCHEMA(className))\n      .catch(err => this.handleError(err));\n  }\n\n  // TODO: As yet not particularly well specified. Creates an object. Maybe shouldn't even need the schema,\n  // and should infer from the type. Or maybe does need the schema for validations. Or maybe needs\n  // the schema only for the legacy mongo format. We'll figure that out later.\n  createObject(className: string, schema: SchemaType, object: any, transactionalSession: ?any) {\n    schema = convertParseSchemaToMongoSchema(schema);\n    const mongoObject = parseObjectToMongoObjectForCreate(className, object, schema);\n    return this._adaptiveCollection(className)\n      .then(collection => collection.insertOne(mongoObject, transactionalSession))\n      .catch(error => {\n        if (error.code === 11000) {\n          // Duplicate value\n          const err = new Parse.Error(\n            Parse.Error.DUPLICATE_VALUE,\n            'A duplicate value for a field with unique values was provided'\n          );\n          err.underlyingError = error;\n          if (error.message) {\n            const matches = error.message.match(/index:[\\sa-zA-Z0-9_\\-\\.]+\\$?([a-zA-Z_-]+)_1/);\n            if (matches && Array.isArray(matches)) {\n              err.userInfo = { duplicated_field: matches[1] };\n            }\n          }\n          throw err;\n        }\n        throw error;\n      })\n      .catch(err => this.handleError(err));\n  }\n\n  // Remove all objects that match the given Parse Query.\n  // If no objects match, reject with OBJECT_NOT_FOUND. If objects are found and deleted, resolve with undefined.\n  // If there is some other error, reject with INTERNAL_SERVER_ERROR.\n  deleteObjectsByQuery(\n    className: string,\n    schema: SchemaType,\n    query: QueryType,\n    transactionalSession: ?any\n  ) {\n    schema = convertParseSchemaToMongoSchema(schema);\n    return this._adaptiveCollection(className)\n      .then(collection => {\n        const mongoWhere = transformWhere(className, query, schema);\n        return collection.deleteMany(mongoWhere, transactionalSession);\n      })\n      .catch(err => this.handleError(err))\n      .then(\n        ({ result }) => {\n          if (result.n === 0) {\n            throw new Parse.Error(Parse.Error.OBJECT_NOT_FOUND, 'Object not found.');\n          }\n          return Promise.resolve();\n        },\n        () => {\n          throw new Parse.Error(Parse.Error.INTERNAL_SERVER_ERROR, 'Database adapter error');\n        }\n      );\n  }\n\n  // Apply the update to all objects that match the given Parse Query.\n  updateObjectsByQuery(\n    className: string,\n    schema: SchemaType,\n    query: QueryType,\n    update: any,\n    transactionalSession: ?any\n  ) {\n    schema = convertParseSchemaToMongoSchema(schema);\n    const mongoUpdate = transformUpdate(className, update, schema);\n    const mongoWhere = transformWhere(className, query, schema);\n    return this._adaptiveCollection(className)\n      .then(collection => collection.updateMany(mongoWhere, mongoUpdate, transactionalSession))\n      .catch(err => this.handleError(err));\n  }\n\n  // Atomically finds and updates an object based on query.\n  // Return value not currently well specified.\n  findOneAndUpdate(\n    className: string,\n    schema: SchemaType,\n    query: QueryType,\n    update: any,\n    transactionalSession: ?any\n  ) {\n    schema = convertParseSchemaToMongoSchema(schema);\n    const mongoUpdate = transformUpdate(className, update, schema);\n    const mongoWhere = transformWhere(className, query, schema);\n    return this._adaptiveCollection(className)\n      .then(collection =>\n        collection._mongoCollection.findOneAndUpdate(mongoWhere, mongoUpdate, {\n          returnOriginal: false,\n          session: transactionalSession || undefined,\n        })\n      )\n      .then(result => mongoObjectToParseObject(className, result.value, schema))\n      .catch(error => {\n        if (error.code === 11000) {\n          throw new Parse.Error(\n            Parse.Error.DUPLICATE_VALUE,\n            'A duplicate value for a field with unique values was provided'\n          );\n        }\n        throw error;\n      })\n      .catch(err => this.handleError(err));\n  }\n\n  // Hopefully we can get rid of this. It's only used for config and hooks.\n  upsertOneObject(\n    className: string,\n    schema: SchemaType,\n    query: QueryType,\n    update: any,\n    transactionalSession: ?any\n  ) {\n    schema = convertParseSchemaToMongoSchema(schema);\n    const mongoUpdate = transformUpdate(className, update, schema);\n    const mongoWhere = transformWhere(className, query, schema);\n    return this._adaptiveCollection(className)\n      .then(collection => collection.upsertOne(mongoWhere, mongoUpdate, transactionalSession))\n      .catch(err => this.handleError(err));\n  }\n\n  // Executes a find. Accepts: className, query in Parse format, and { skip, limit, sort }.\n  find(\n    className: string,\n    schema: SchemaType,\n    query: QueryType,\n    { skip, limit, sort, keys, readPreference, hint, caseInsensitive, explain }: QueryOptions\n  ): Promise<any> {\n    validateExplainValue(explain);\n    schema = convertParseSchemaToMongoSchema(schema);\n    const mongoWhere = transformWhere(className, query, schema);\n    const mongoSort = _.mapKeys(sort, (value, fieldName) =>\n      transformKey(className, fieldName, schema)\n    );\n    const mongoKeys = _.reduce(\n      keys,\n      (memo, key) => {\n        if (key === 'ACL') {\n          memo['_rperm'] = 1;\n          memo['_wperm'] = 1;\n        } else {\n          memo[transformKey(className, key, schema)] = 1;\n        }\n        return memo;\n      },\n      {}\n    );\n\n    // If we aren't requesting the `_id` field, we need to explicitly opt out\n    // of it. Doing so in parse-server is unusual, but it can allow us to\n    // optimize some queries with covering indexes.\n    if (keys && !mongoKeys._id) {\n      mongoKeys._id = 0;\n    }\n\n    readPreference = this._parseReadPreference(readPreference);\n    return this.createTextIndexesIfNeeded(className, query, schema)\n      .then(() => this._adaptiveCollection(className))\n      .then(collection =>\n        collection.find(mongoWhere, {\n          skip,\n          limit,\n          sort: mongoSort,\n          keys: mongoKeys,\n          maxTimeMS: this._maxTimeMS,\n          readPreference,\n          hint,\n          caseInsensitive,\n          explain,\n        })\n      )\n      .then(objects => {\n        if (explain) {\n          return objects;\n        }\n        return objects.map(object => mongoObjectToParseObject(className, object, schema));\n      })\n      .catch(err => this.handleError(err));\n  }\n\n  ensureIndex(\n    className: string,\n    schema: SchemaType,\n    fieldNames: string[],\n    indexName: ?string,\n    caseInsensitive: boolean = false,\n    options?: Object = {}\n  ): Promise<any> {\n    schema = convertParseSchemaToMongoSchema(schema);\n    const indexCreationRequest = {};\n    const mongoFieldNames = fieldNames.map(fieldName => transformKey(className, fieldName, schema));\n    mongoFieldNames.forEach(fieldName => {\n      indexCreationRequest[fieldName] = options.indexType !== undefined ? options.indexType : 1;\n    });\n\n    const defaultOptions: Object = { background: true, sparse: true };\n    const indexNameOptions: Object = indexName ? { name: indexName } : {};\n    const ttlOptions: Object = options.ttl !== undefined ? { expireAfterSeconds: options.ttl } : {};\n    const caseInsensitiveOptions: Object = caseInsensitive\n      ? { collation: MongoCollection.caseInsensitiveCollation() }\n      : {};\n    const indexOptions: Object = {\n      ...defaultOptions,\n      ...caseInsensitiveOptions,\n      ...indexNameOptions,\n      ...ttlOptions,\n    };\n\n    return this._adaptiveCollection(className)\n      .then(\n        collection =>\n          new Promise((resolve, reject) =>\n            collection._mongoCollection.createIndex(indexCreationRequest, indexOptions, error =>\n              error ? reject(error) : resolve()\n            )\n          )\n      )\n      .catch(err => this.handleError(err));\n  }\n\n  // Create a unique index. Unique indexes on nullable fields are not allowed. Since we don't\n  // currently know which fields are nullable and which aren't, we ignore that criteria.\n  // As such, we shouldn't expose this function to users of parse until we have an out-of-band\n  // Way of determining if a field is nullable. Undefined doesn't count against uniqueness,\n  // which is why we use sparse indexes.\n  ensureUniqueness(className: string, schema: SchemaType, fieldNames: string[]) {\n    schema = convertParseSchemaToMongoSchema(schema);\n    const indexCreationRequest = {};\n    const mongoFieldNames = fieldNames.map(fieldName => transformKey(className, fieldName, schema));\n    mongoFieldNames.forEach(fieldName => {\n      indexCreationRequest[fieldName] = 1;\n    });\n    return this._adaptiveCollection(className)\n      .then(collection => collection._ensureSparseUniqueIndexInBackground(indexCreationRequest))\n      .catch(error => {\n        if (error.code === 11000) {\n          throw new Parse.Error(\n            Parse.Error.DUPLICATE_VALUE,\n            'Tried to ensure field uniqueness for a class that already has duplicates.'\n          );\n        }\n        throw error;\n      })\n      .catch(err => this.handleError(err));\n  }\n\n  // Used in tests\n  _rawFind(className: string, query: QueryType) {\n    return this._adaptiveCollection(className)\n      .then(collection =>\n        collection.find(query, {\n          maxTimeMS: this._maxTimeMS,\n        })\n      )\n      .catch(err => this.handleError(err));\n  }\n\n  // Executes a count.\n  count(\n    className: string,\n    schema: SchemaType,\n    query: QueryType,\n    readPreference: ?string,\n    hint: ?mixed\n  ) {\n    schema = convertParseSchemaToMongoSchema(schema);\n    readPreference = this._parseReadPreference(readPreference);\n    return this._adaptiveCollection(className)\n      .then(collection =>\n        collection.count(transformWhere(className, query, schema, true), {\n          maxTimeMS: this._maxTimeMS,\n          readPreference,\n          hint,\n        })\n      )\n      .catch(err => this.handleError(err));\n  }\n\n  distinct(className: string, schema: SchemaType, query: QueryType, fieldName: string) {\n    schema = convertParseSchemaToMongoSchema(schema);\n    const isPointerField = schema.fields[fieldName] && schema.fields[fieldName].type === 'Pointer';\n    const transformField = transformKey(className, fieldName, schema);\n\n    return this._adaptiveCollection(className)\n      .then(collection =>\n        collection.distinct(transformField, transformWhere(className, query, schema))\n      )\n      .then(objects => {\n        objects = objects.filter(obj => obj != null);\n        return objects.map(object => {\n          if (isPointerField) {\n            return transformPointerString(schema, fieldName, object);\n          }\n          return mongoObjectToParseObject(className, object, schema);\n        });\n      })\n      .catch(err => this.handleError(err));\n  }\n\n  aggregate(\n    className: string,\n    schema: any,\n    pipeline: any,\n    readPreference: ?string,\n    hint: ?mixed,\n    explain?: boolean\n  ) {\n    validateExplainValue(explain);\n    let isPointerField = false;\n    pipeline = pipeline.map(stage => {\n      if (stage.$group) {\n        stage.$group = this._parseAggregateGroupArgs(schema, stage.$group);\n        if (\n          stage.$group._id &&\n          typeof stage.$group._id === 'string' &&\n          stage.$group._id.indexOf('$_p_') >= 0\n        ) {\n          isPointerField = true;\n        }\n      }\n      if (stage.$match) {\n        stage.$match = this._parseAggregateArgs(schema, stage.$match);\n      }\n      if (stage.$project) {\n        stage.$project = this._parseAggregateProjectArgs(schema, stage.$project);\n      }\n      if (stage.$geoNear && stage.$geoNear.query) {\n        stage.$geoNear.query = this._parseAggregateArgs(schema, stage.$geoNear.query);\n      }\n      return stage;\n    });\n    readPreference = this._parseReadPreference(readPreference);\n    return this._adaptiveCollection(className)\n      .then(collection =>\n        collection.aggregate(pipeline, {\n          readPreference,\n          maxTimeMS: this._maxTimeMS,\n          hint,\n          explain,\n        })\n      )\n      .then(results => {\n        results.forEach(result => {\n          if (Object.prototype.hasOwnProperty.call(result, '_id')) {\n            if (isPointerField && result._id) {\n              result._id = result._id.split('$')[1];\n            }\n            if (\n              result._id == null ||\n              result._id == undefined ||\n              (['object', 'string'].includes(typeof result._id) && _.isEmpty(result._id))\n            ) {\n              result._id = null;\n            }\n            result.objectId = result._id;\n            delete result._id;\n          }\n        });\n        return results;\n      })\n      .then(objects => objects.map(object => mongoObjectToParseObject(className, object, schema)))\n      .catch(err => this.handleError(err));\n  }\n\n  // This function will recursively traverse the pipeline and convert any Pointer or Date columns.\n  // If we detect a pointer column we will rename the column being queried for to match the column\n  // in the database. We also modify the value to what we expect the value to be in the database\n  // as well.\n  // For dates, the driver expects a Date object, but we have a string coming in. So we'll convert\n  // the string to a Date so the driver can perform the necessary comparison.\n  //\n  // The goal of this method is to look for the \"leaves\" of the pipeline and determine if it needs\n  // to be converted. The pipeline can have a few different forms. For more details, see:\n  //     https://docs.mongodb.com/manual/reference/operator/aggregation/\n  //\n  // If the pipeline is an array, it means we are probably parsing an '$and' or '$or' operator. In\n  // that case we need to loop through all of it's children to find the columns being operated on.\n  // If the pipeline is an object, then we'll loop through the keys checking to see if the key name\n  // matches one of the schema columns. If it does match a column and the column is a Pointer or\n  // a Date, then we'll convert the value as described above.\n  //\n  // As much as I hate recursion...this seemed like a good fit for it. We're essentially traversing\n  // down a tree to find a \"leaf node\" and checking to see if it needs to be converted.\n  _parseAggregateArgs(schema: any, pipeline: any): any {\n    if (pipeline === null) {\n      return null;\n    } else if (Array.isArray(pipeline)) {\n      return pipeline.map(value => this._parseAggregateArgs(schema, value));\n    } else if (typeof pipeline === 'object') {\n      const returnValue = {};\n      for (const field in pipeline) {\n        if (schema.fields[field] && schema.fields[field].type === 'Pointer') {\n          if (typeof pipeline[field] === 'object') {\n            // Pass objects down to MongoDB...this is more than likely an $exists operator.\n            returnValue[`_p_${field}`] = pipeline[field];\n          } else {\n            returnValue[`_p_${field}`] = `${schema.fields[field].targetClass}$${pipeline[field]}`;\n          }\n        } else if (schema.fields[field] && schema.fields[field].type === 'Date') {\n          returnValue[field] = this._convertToDate(pipeline[field]);\n        } else {\n          returnValue[field] = this._parseAggregateArgs(schema, pipeline[field]);\n        }\n\n        if (field === 'objectId') {\n          returnValue['_id'] = returnValue[field];\n          delete returnValue[field];\n        } else if (field === 'createdAt') {\n          returnValue['_created_at'] = returnValue[field];\n          delete returnValue[field];\n        } else if (field === 'updatedAt') {\n          returnValue['_updated_at'] = returnValue[field];\n          delete returnValue[field];\n        }\n      }\n      return returnValue;\n    }\n    return pipeline;\n  }\n\n  // This function is slightly different than the one above. Rather than trying to combine these\n  // two functions and making the code even harder to understand, I decided to split it up. The\n  // difference with this function is we are not transforming the values, only the keys of the\n  // pipeline.\n  _parseAggregateProjectArgs(schema: any, pipeline: any): any {\n    const returnValue = {};\n    for (const field in pipeline) {\n      if (schema.fields[field] && schema.fields[field].type === 'Pointer') {\n        returnValue[`_p_${field}`] = pipeline[field];\n      } else {\n        returnValue[field] = this._parseAggregateArgs(schema, pipeline[field]);\n      }\n\n      if (field === 'objectId') {\n        returnValue['_id'] = returnValue[field];\n        delete returnValue[field];\n      } else if (field === 'createdAt') {\n        returnValue['_created_at'] = returnValue[field];\n        delete returnValue[field];\n      } else if (field === 'updatedAt') {\n        returnValue['_updated_at'] = returnValue[field];\n        delete returnValue[field];\n      }\n    }\n    return returnValue;\n  }\n\n  // This function is slightly different than the two above. MongoDB $group aggregate looks like:\n  //     { $group: { _id: <expression>, <field1>: { <accumulator1> : <expression1> }, ... } }\n  // The <expression> could be a column name, prefixed with the '$' character. We'll look for\n  // these <expression> and check to see if it is a 'Pointer' or if it's one of createdAt,\n  // updatedAt or objectId and change it accordingly.\n  _parseAggregateGroupArgs(schema: any, pipeline: any): any {\n    if (Array.isArray(pipeline)) {\n      return pipeline.map(value => this._parseAggregateGroupArgs(schema, value));\n    } else if (typeof pipeline === 'object') {\n      const returnValue = {};\n      for (const field in pipeline) {\n        returnValue[field] = this._parseAggregateGroupArgs(schema, pipeline[field]);\n      }\n      return returnValue;\n    } else if (typeof pipeline === 'string') {\n      const field = pipeline.substring(1);\n      if (schema.fields[field] && schema.fields[field].type === 'Pointer') {\n        return `$_p_${field}`;\n      } else if (field == 'createdAt') {\n        return '$_created_at';\n      } else if (field == 'updatedAt') {\n        return '$_updated_at';\n      }\n    }\n    return pipeline;\n  }\n\n  // This function will attempt to convert the provided value to a Date object. Since this is part\n  // of an aggregation pipeline, the value can either be a string or it can be another object with\n  // an operator in it (like $gt, $lt, etc). Because of this I felt it was easier to make this a\n  // recursive method to traverse down to the \"leaf node\" which is going to be the string.\n  _convertToDate(value: any): any {\n    if (typeof value === 'string') {\n      return new Date(value);\n    }\n\n    const returnValue = {};\n    for (const field in value) {\n      returnValue[field] = this._convertToDate(value[field]);\n    }\n    return returnValue;\n  }\n\n  _parseReadPreference(readPreference: ?string): ?string {\n    if (readPreference) {\n      readPreference = readPreference.toUpperCase();\n    }\n    switch (readPreference) {\n      case 'PRIMARY':\n        readPreference = ReadPreference.PRIMARY;\n        break;\n      case 'PRIMARY_PREFERRED':\n        readPreference = ReadPreference.PRIMARY_PREFERRED;\n        break;\n      case 'SECONDARY':\n        readPreference = ReadPreference.SECONDARY;\n        break;\n      case 'SECONDARY_PREFERRED':\n        readPreference = ReadPreference.SECONDARY_PREFERRED;\n        break;\n      case 'NEAREST':\n        readPreference = ReadPreference.NEAREST;\n        break;\n      case undefined:\n      case null:\n      case '':\n        break;\n      default:\n        throw new Parse.Error(Parse.Error.INVALID_QUERY, 'Not supported read preference.');\n    }\n    return readPreference;\n  }\n\n  performInitialization(): Promise<void> {\n    return Promise.resolve();\n  }\n\n  createIndex(className: string, index: any) {\n    return this._adaptiveCollection(className)\n      .then(collection => collection._mongoCollection.createIndex(index))\n      .catch(err => this.handleError(err));\n  }\n\n  createIndexes(className: string, indexes: any) {\n    return this._adaptiveCollection(className)\n      .then(collection => collection._mongoCollection.createIndexes(indexes))\n      .catch(err => this.handleError(err));\n  }\n\n  createIndexesIfNeeded(className: string, fieldName: string, type: any) {\n    if (type && type.type === 'Polygon') {\n      const index = {\n        [fieldName]: '2dsphere',\n      };\n      return this.createIndex(className, index);\n    }\n    return Promise.resolve();\n  }\n\n  createTextIndexesIfNeeded(className: string, query: QueryType, schema: any): Promise<void> {\n    for (const fieldName in query) {\n      if (!query[fieldName] || !query[fieldName].$text) {\n        continue;\n      }\n      const existingIndexes = schema.indexes;\n      for (const key in existingIndexes) {\n        const index = existingIndexes[key];\n        if (Object.prototype.hasOwnProperty.call(index, fieldName)) {\n          return Promise.resolve();\n        }\n      }\n      const indexName = `${fieldName}_text`;\n      const textIndex = {\n        [indexName]: { [fieldName]: 'text' },\n      };\n      return this.setIndexesWithSchemaFormat(\n        className,\n        textIndex,\n        existingIndexes,\n        schema.fields\n      ).catch(error => {\n        if (error.code === 85) {\n          // Index exist with different options\n          return this.setIndexesFromMongo(className);\n        }\n        throw error;\n      });\n    }\n    return Promise.resolve();\n  }\n\n  getIndexes(className: string) {\n    return this._adaptiveCollection(className)\n      .then(collection => collection._mongoCollection.indexes())\n      .catch(err => this.handleError(err));\n  }\n\n  dropIndex(className: string, index: any) {\n    return this._adaptiveCollection(className)\n      .then(collection => collection._mongoCollection.dropIndex(index))\n      .catch(err => this.handleError(err));\n  }\n\n  dropAllIndexes(className: string) {\n    return this._adaptiveCollection(className)\n      .then(collection => collection._mongoCollection.dropIndexes())\n      .catch(err => this.handleError(err));\n  }\n\n  updateSchemaWithIndexes(): Promise<any> {\n    return this.getAllClasses()\n      .then(classes => {\n        const promises = classes.map(schema => {\n          return this.setIndexesFromMongo(schema.className);\n        });\n        return Promise.all(promises);\n      })\n      .catch(err => this.handleError(err));\n  }\n\n  createTransactionalSession(): Promise<any> {\n    const transactionalSection = this.client.startSession();\n    transactionalSection.startTransaction();\n    return Promise.resolve(transactionalSection);\n  }\n\n  commitTransactionalSession(transactionalSection: any): Promise<void> {\n    const commit = retries => {\n      return transactionalSection\n        .commitTransaction()\n        .catch(error => {\n          if (error && error.hasErrorLabel('TransientTransactionError') && retries > 0) {\n            return commit(retries - 1);\n          }\n          throw error;\n        })\n        .then(() => {\n          transactionalSection.endSession();\n        });\n    };\n    return commit(5);\n  }\n\n  abortTransactionalSession(transactionalSection: any): Promise<void> {\n    return transactionalSection.abortTransaction().then(() => {\n      transactionalSection.endSession();\n    });\n  }\n}\n\nexport default MongoStorageAdapter;\n", "// An object that encapsulates everything we need to run a 'find'\n// operation, encoded in the REST API format.\n\nvar SchemaController = require('./Controllers/SchemaController');\nvar Parse = require('parse/node').Parse;\nconst triggers = require('./triggers');\nconst { continueWhile } = require('parse/lib/node/promiseUtils');\nconst AlwaysSelectedKeys = ['objectId', 'createdAt', 'updatedAt', 'ACL'];\n// restOptions can include:\n//   skip\n//   limit\n//   order\n//   count\n//   include\n//   keys\n//   excludeKeys\n//   redirectClassNameForKey\n//   readPreference\n//   includeReadPreference\n//   subqueryReadPreference\nfunction RestQuery(\n  config,\n  auth,\n  className,\n  restWhere = {},\n  restOptions = {},\n  clientSDK,\n  runAfterFind = true,\n  context\n) {\n  this.config = config;\n  this.auth = auth;\n  this.className = className;\n  this.restWhere = restWhere;\n  this.restOptions = restOptions;\n  this.clientSDK = clientSDK;\n  this.runAfterFind = runAfterFind;\n  this.response = null;\n  this.findOptions = {};\n  this.context = context || {};\n  if (!this.auth.isMaster) {\n    if (this.className == '_Session') {\n      if (!this.auth.user) {\n        throw new Parse.Error(Parse.Error.INVALID_SESSION_TOKEN, 'Invalid session token');\n      }\n      this.restWhere = {\n        $and: [\n          this.restWhere,\n          {\n            user: {\n              __type: 'Pointer',\n              className: '_User',\n              objectId: this.auth.user.id,\n            },\n          },\n        ],\n      };\n    }\n  }\n\n  this.doCount = false;\n  this.includeAll = false;\n\n  // The format for this.include is not the same as the format for the\n  // include option - it's the paths we should include, in order,\n  // stored as arrays, taking into account that we need to include foo\n  // before including foo.bar. Also it should dedupe.\n  // For example, passing an arg of include=foo.bar,foo.baz could lead to\n  // this.include = [['foo'], ['foo', 'baz'], ['foo', 'bar']]\n  this.include = [];\n  let keysForInclude = '';\n\n  // If we have keys, we probably want to force some includes (n-1 level)\n  // See issue: https://github.com/parse-community/parse-server/issues/3185\n  if (Object.prototype.hasOwnProperty.call(restOptions, 'keys')) {\n    keysForInclude = restOptions.keys;\n  }\n\n  // If we have keys, we probably want to force some includes (n-1 level)\n  // in order to exclude specific keys.\n  if (Object.prototype.hasOwnProperty.call(restOptions, 'excludeKeys')) {\n    keysForInclude += ',' + restOptions.excludeKeys;\n  }\n\n  if (keysForInclude.length > 0) {\n    keysForInclude = keysForInclude\n      .split(',')\n      .filter(key => {\n        // At least 2 components\n        return key.split('.').length > 1;\n      })\n      .map(key => {\n        // Slice the last component (a.b.c -> a.b)\n        // Otherwise we'll include one level too much.\n        return key.slice(0, key.lastIndexOf('.'));\n      })\n      .join(',');\n\n    // Concat the possibly present include string with the one from the keys\n    // Dedup / sorting is handle in 'include' case.\n    if (keysForInclude.length > 0) {\n      if (!restOptions.include || restOptions.include.length == 0) {\n        restOptions.include = keysForInclude;\n      } else {\n        restOptions.include += ',' + keysForInclude;\n      }\n    }\n  }\n\n  for (var option in restOptions) {\n    switch (option) {\n      case 'keys': {\n        const keys = restOptions.keys\n          .split(',')\n          .filter(key => key.length > 0)\n          .concat(AlwaysSelectedKeys);\n        this.keys = Array.from(new Set(keys));\n        break;\n      }\n      case 'excludeKeys': {\n        const exclude = restOptions.excludeKeys\n          .split(',')\n          .filter(k => AlwaysSelectedKeys.indexOf(k) < 0);\n        this.excludeKeys = Array.from(new Set(exclude));\n        break;\n      }\n      case 'count':\n        this.doCount = true;\n        break;\n      case 'includeAll':\n        this.includeAll = true;\n        break;\n      case 'explain':\n      case 'hint':\n      case 'distinct':\n      case 'pipeline':\n      case 'skip':\n      case 'limit':\n      case 'readPreference':\n        this.findOptions[option] = restOptions[option];\n        break;\n      case 'order':\n        var fields = restOptions.order.split(',');\n        this.findOptions.sort = fields.reduce((sortMap, field) => {\n          field = field.trim();\n          if (field === '$score') {\n            sortMap.score = { $meta: 'textScore' };\n          } else if (field[0] == '-') {\n            sortMap[field.slice(1)] = -1;\n          } else {\n            sortMap[field] = 1;\n          }\n          return sortMap;\n        }, {});\n        break;\n      case 'include': {\n        const paths = restOptions.include.split(',');\n        if (paths.includes('*')) {\n          this.includeAll = true;\n          break;\n        }\n        // Load the existing includes (from keys)\n        const pathSet = paths.reduce((memo, path) => {\n          // Split each paths on . (a.b.c -> [a,b,c])\n          // reduce to create all paths\n          // ([a,b,c] -> {a: true, 'a.b': true, 'a.b.c': true})\n          return path.split('.').reduce((memo, path, index, parts) => {\n            memo[parts.slice(0, index + 1).join('.')] = true;\n            return memo;\n          }, memo);\n        }, {});\n\n        this.include = Object.keys(pathSet)\n          .map(s => {\n            return s.split('.');\n          })\n          .sort((a, b) => {\n            return a.length - b.length; // Sort by number of components\n          });\n        break;\n      }\n      case 'redirectClassNameForKey':\n        this.redirectKey = restOptions.redirectClassNameForKey;\n        this.redirectClassName = null;\n        break;\n      case 'includeReadPreference':\n      case 'subqueryReadPreference':\n        break;\n      default:\n        throw new Parse.Error(Parse.Error.INVALID_JSON, 'bad option: ' + option);\n    }\n  }\n}\n\n// A convenient method to perform all the steps of processing a query\n// in order.\n// Returns a promise for the response - an object with optional keys\n// 'results' and 'count'.\n// TODO: consolidate the replaceX functions\nRestQuery.prototype.execute = function (executeOptions) {\n  return Promise.resolve()\n    .then(() => {\n      return this.buildRestWhere();\n    })\n    .then(() => {\n      return this.handleIncludeAll();\n    })\n    .then(() => {\n      return this.handleExcludeKeys();\n    })\n    .then(() => {\n      return this.runFind(executeOptions);\n    })\n    .then(() => {\n      return this.runCount();\n    })\n    .then(() => {\n      return this.handleInclude();\n    })\n    .then(() => {\n      return this.runAfterFindTrigger();\n    })\n    .then(() => {\n      return this.response;\n    });\n};\n\nRestQuery.prototype.each = function (callback) {\n  const { config, auth, className, restWhere, restOptions, clientSDK } = this;\n  // if the limit is set, use it\n  restOptions.limit = restOptions.limit || 100;\n  restOptions.order = 'objectId';\n  let finished = false;\n\n  return continueWhile(\n    () => {\n      return !finished;\n    },\n    async () => {\n      const query = new RestQuery(\n        config,\n        auth,\n        className,\n        restWhere,\n        restOptions,\n        clientSDK,\n        this.runAfterFind,\n        this.context\n      );\n      const { results } = await query.execute();\n      results.forEach(callback);\n      finished = results.length < restOptions.limit;\n      if (!finished) {\n        restWhere.objectId = Object.assign({}, restWhere.objectId, {\n          $gt: results[results.length - 1].objectId,\n        });\n      }\n    }\n  );\n};\n\nRestQuery.prototype.buildRestWhere = function () {\n  return Promise.resolve()\n    .then(() => {\n      return this.getUserAndRoleACL();\n    })\n    .then(() => {\n      return this.redirectClassNameForKey();\n    })\n    .then(() => {\n      return this.validateClientClassCreation();\n    })\n    .then(() => {\n      return this.replaceSelect();\n    })\n    .then(() => {\n      return this.replaceDontSelect();\n    })\n    .then(() => {\n      return this.replaceInQuery();\n    })\n    .then(() => {\n      return this.replaceNotInQuery();\n    })\n    .then(() => {\n      return this.replaceEquality();\n    });\n};\n\n// Uses the Auth object to get the list of roles, adds the user id\nRestQuery.prototype.getUserAndRoleACL = function () {\n  if (this.auth.isMaster) {\n    return Promise.resolve();\n  }\n\n  this.findOptions.acl = ['*'];\n\n  if (this.auth.user) {\n    return this.auth.getUserRoles().then(roles => {\n      this.findOptions.acl = this.findOptions.acl.concat(roles, [this.auth.user.id]);\n      return;\n    });\n  } else {\n    return Promise.resolve();\n  }\n};\n\n// Changes the className if redirectClassNameForKey is set.\n// Returns a promise.\nRestQuery.prototype.redirectClassNameForKey = function () {\n  if (!this.redirectKey) {\n    return Promise.resolve();\n  }\n\n  // We need to change the class name based on the schema\n  return this.config.database\n    .redirectClassNameForKey(this.className, this.redirectKey)\n    .then(newClassName => {\n      this.className = newClassName;\n      this.redirectClassName = newClassName;\n    });\n};\n\n// Validates this operation against the allowClientClassCreation config.\nRestQuery.prototype.validateClientClassCreation = function () {\n  if (\n    this.config.allowClientClassCreation === false &&\n    !this.auth.isMaster &&\n    SchemaController.systemClasses.indexOf(this.className) === -1\n  ) {\n    return this.config.database\n      .loadSchema()\n      .then(schemaController => schemaController.hasClass(this.className))\n      .then(hasClass => {\n        if (hasClass !== true) {\n          throw new Parse.Error(\n            Parse.Error.OPERATION_FORBIDDEN,\n            'This user is not allowed to access ' + 'non-existent class: ' + this.className\n          );\n        }\n      });\n  } else {\n    return Promise.resolve();\n  }\n};\n\nfunction transformInQuery(inQueryObject, className, results) {\n  var values = [];\n  for (var result of results) {\n    values.push({\n      __type: 'Pointer',\n      className: className,\n      objectId: result.objectId,\n    });\n  }\n  delete inQueryObject['$inQuery'];\n  if (Array.isArray(inQueryObject['$in'])) {\n    inQueryObject['$in'] = inQueryObject['$in'].concat(values);\n  } else {\n    inQueryObject['$in'] = values;\n  }\n}\n\n// Replaces a $inQuery clause by running the subquery, if there is an\n// $inQuery clause.\n// The $inQuery clause turns into an $in with values that are just\n// pointers to the objects returned in the subquery.\nRestQuery.prototype.replaceInQuery = function () {\n  var inQueryObject = findObjectWithKey(this.restWhere, '$inQuery');\n  if (!inQueryObject) {\n    return;\n  }\n\n  // The inQuery value must have precisely two keys - where and className\n  var inQueryValue = inQueryObject['$inQuery'];\n  if (!inQueryValue.where || !inQueryValue.className) {\n    throw new Parse.Error(Parse.Error.INVALID_QUERY, 'improper usage of $inQuery');\n  }\n\n  const additionalOptions = {\n    redirectClassNameForKey: inQueryValue.redirectClassNameForKey,\n  };\n\n  if (this.restOptions.subqueryReadPreference) {\n    additionalOptions.readPreference = this.restOptions.subqueryReadPreference;\n    additionalOptions.subqueryReadPreference = this.restOptions.subqueryReadPreference;\n  } else if (this.restOptions.readPreference) {\n    additionalOptions.readPreference = this.restOptions.readPreference;\n  }\n\n  var subquery = new RestQuery(\n    this.config,\n    this.auth,\n    inQueryValue.className,\n    inQueryValue.where,\n    additionalOptions\n  );\n  return subquery.execute().then(response => {\n    transformInQuery(inQueryObject, subquery.className, response.results);\n    // Recurse to repeat\n    return this.replaceInQuery();\n  });\n};\n\nfunction transformNotInQuery(notInQueryObject, className, results) {\n  var values = [];\n  for (var result of results) {\n    values.push({\n      __type: 'Pointer',\n      className: className,\n      objectId: result.objectId,\n    });\n  }\n  delete notInQueryObject['$notInQuery'];\n  if (Array.isArray(notInQueryObject['$nin'])) {\n    notInQueryObject['$nin'] = notInQueryObject['$nin'].concat(values);\n  } else {\n    notInQueryObject['$nin'] = values;\n  }\n}\n\n// Replaces a $notInQuery clause by running the subquery, if there is an\n// $notInQuery clause.\n// The $notInQuery clause turns into a $nin with values that are just\n// pointers to the objects returned in the subquery.\nRestQuery.prototype.replaceNotInQuery = function () {\n  var notInQueryObject = findObjectWithKey(this.restWhere, '$notInQuery');\n  if (!notInQueryObject) {\n    return;\n  }\n\n  // The notInQuery value must have precisely two keys - where and className\n  var notInQueryValue = notInQueryObject['$notInQuery'];\n  if (!notInQueryValue.where || !notInQueryValue.className) {\n    throw new Parse.Error(Parse.Error.INVALID_QUERY, 'improper usage of $notInQuery');\n  }\n\n  const additionalOptions = {\n    redirectClassNameForKey: notInQueryValue.redirectClassNameForKey,\n  };\n\n  if (this.restOptions.subqueryReadPreference) {\n    additionalOptions.readPreference = this.restOptions.subqueryReadPreference;\n    additionalOptions.subqueryReadPreference = this.restOptions.subqueryReadPreference;\n  } else if (this.restOptions.readPreference) {\n    additionalOptions.readPreference = this.restOptions.readPreference;\n  }\n\n  var subquery = new RestQuery(\n    this.config,\n    this.auth,\n    notInQueryValue.className,\n    notInQueryValue.where,\n    additionalOptions\n  );\n  return subquery.execute().then(response => {\n    transformNotInQuery(notInQueryObject, subquery.className, response.results);\n    // Recurse to repeat\n    return this.replaceNotInQuery();\n  });\n};\n\n// Used to get the deepest object from json using dot notation.\nconst getDeepestObjectFromKey = (json, key, idx, src) => {\n  if (key in json) {\n    return json[key];\n  }\n  src.splice(1); // Exit Early\n};\n\nconst transformSelect = (selectObject, key, objects) => {\n  var values = [];\n  for (var result of objects) {\n    values.push(key.split('.').reduce(getDeepestObjectFromKey, result));\n  }\n  delete selectObject['$select'];\n  if (Array.isArray(selectObject['$in'])) {\n    selectObject['$in'] = selectObject['$in'].concat(values);\n  } else {\n    selectObject['$in'] = values;\n  }\n};\n\n// Replaces a $select clause by running the subquery, if there is a\n// $select clause.\n// The $select clause turns into an $in with values selected out of\n// the subquery.\n// Returns a possible-promise.\nRestQuery.prototype.replaceSelect = function () {\n  var selectObject = findObjectWithKey(this.restWhere, '$select');\n  if (!selectObject) {\n    return;\n  }\n\n  // The select value must have precisely two keys - query and key\n  var selectValue = selectObject['$select'];\n  // iOS SDK don't send where if not set, let it pass\n  if (\n    !selectValue.query ||\n    !selectValue.key ||\n    typeof selectValue.query !== 'object' ||\n    !selectValue.query.className ||\n    Object.keys(selectValue).length !== 2\n  ) {\n    throw new Parse.Error(Parse.Error.INVALID_QUERY, 'improper usage of $select');\n  }\n\n  const additionalOptions = {\n    redirectClassNameForKey: selectValue.query.redirectClassNameForKey,\n  };\n\n  if (this.restOptions.subqueryReadPreference) {\n    additionalOptions.readPreference = this.restOptions.subqueryReadPreference;\n    additionalOptions.subqueryReadPreference = this.restOptions.subqueryReadPreference;\n  } else if (this.restOptions.readPreference) {\n    additionalOptions.readPreference = this.restOptions.readPreference;\n  }\n\n  var subquery = new RestQuery(\n    this.config,\n    this.auth,\n    selectValue.query.className,\n    selectValue.query.where,\n    additionalOptions\n  );\n  return subquery.execute().then(response => {\n    transformSelect(selectObject, selectValue.key, response.results);\n    // Keep replacing $select clauses\n    return this.replaceSelect();\n  });\n};\n\nconst transformDontSelect = (dontSelectObject, key, objects) => {\n  var values = [];\n  for (var result of objects) {\n    values.push(key.split('.').reduce(getDeepestObjectFromKey, result));\n  }\n  delete dontSelectObject['$dontSelect'];\n  if (Array.isArray(dontSelectObject['$nin'])) {\n    dontSelectObject['$nin'] = dontSelectObject['$nin'].concat(values);\n  } else {\n    dontSelectObject['$nin'] = values;\n  }\n};\n\n// Replaces a $dontSelect clause by running the subquery, if there is a\n// $dontSelect clause.\n// The $dontSelect clause turns into an $nin with values selected out of\n// the subquery.\n// Returns a possible-promise.\nRestQuery.prototype.replaceDontSelect = function () {\n  var dontSelectObject = findObjectWithKey(this.restWhere, '$dontSelect');\n  if (!dontSelectObject) {\n    return;\n  }\n\n  // The dontSelect value must have precisely two keys - query and key\n  var dontSelectValue = dontSelectObject['$dontSelect'];\n  if (\n    !dontSelectValue.query ||\n    !dontSelectValue.key ||\n    typeof dontSelectValue.query !== 'object' ||\n    !dontSelectValue.query.className ||\n    Object.keys(dontSelectValue).length !== 2\n  ) {\n    throw new Parse.Error(Parse.Error.INVALID_QUERY, 'improper usage of $dontSelect');\n  }\n  const additionalOptions = {\n    redirectClassNameForKey: dontSelectValue.query.redirectClassNameForKey,\n  };\n\n  if (this.restOptions.subqueryReadPreference) {\n    additionalOptions.readPreference = this.restOptions.subqueryReadPreference;\n    additionalOptions.subqueryReadPreference = this.restOptions.subqueryReadPreference;\n  } else if (this.restOptions.readPreference) {\n    additionalOptions.readPreference = this.restOptions.readPreference;\n  }\n\n  var subquery = new RestQuery(\n    this.config,\n    this.auth,\n    dontSelectValue.query.className,\n    dontSelectValue.query.where,\n    additionalOptions\n  );\n  return subquery.execute().then(response => {\n    transformDontSelect(dontSelectObject, dontSelectValue.key, response.results);\n    // Keep replacing $dontSelect clauses\n    return this.replaceDontSelect();\n  });\n};\n\nconst cleanResultAuthData = function (result) {\n  delete result.password;\n  if (result.authData) {\n    Object.keys(result.authData).forEach(provider => {\n      if (result.authData[provider] === null) {\n        delete result.authData[provider];\n      }\n    });\n\n    if (Object.keys(result.authData).length == 0) {\n      delete result.authData;\n    }\n  }\n};\n\nconst replaceEqualityConstraint = constraint => {\n  if (typeof constraint !== 'object') {\n    return constraint;\n  }\n  const equalToObject = {};\n  let hasDirectConstraint = false;\n  let hasOperatorConstraint = false;\n  for (const key in constraint) {\n    if (key.indexOf('$') !== 0) {\n      hasDirectConstraint = true;\n      equalToObject[key] = constraint[key];\n    } else {\n      hasOperatorConstraint = true;\n    }\n  }\n  if (hasDirectConstraint && hasOperatorConstraint) {\n    constraint['$eq'] = equalToObject;\n    Object.keys(equalToObject).forEach(key => {\n      delete constraint[key];\n    });\n  }\n  return constraint;\n};\n\nRestQuery.prototype.replaceEquality = function () {\n  if (typeof this.restWhere !== 'object') {\n    return;\n  }\n  for (const key in this.restWhere) {\n    this.restWhere[key] = replaceEqualityConstraint(this.restWhere[key]);\n  }\n};\n\n// Returns a promise for whether it was successful.\n// Populates this.response with an object that only has 'results'.\nRestQuery.prototype.runFind = function (options = {}) {\n  if (this.findOptions.limit === 0) {\n    this.response = { results: [] };\n    return Promise.resolve();\n  }\n  const findOptions = Object.assign({}, this.findOptions);\n  if (this.keys) {\n    findOptions.keys = this.keys.map(key => {\n      return key.split('.')[0];\n    });\n  }\n  if (options.op) {\n    findOptions.op = options.op;\n  }\n  return this.config.database\n    .find(this.className, this.restWhere, findOptions, this.auth)\n    .then(results => {\n      if (this.className === '_User' && !findOptions.explain) {\n        for (var result of results) {\n          cleanResultAuthData(result);\n        }\n      }\n\n      this.config.filesController.expandFilesInObject(this.config, results);\n\n      if (this.redirectClassName) {\n        for (var r of results) {\n          r.className = this.redirectClassName;\n        }\n      }\n      this.response = { results: results };\n    });\n};\n\n// Returns a promise for whether it was successful.\n// Populates this.response.count with the count\nRestQuery.prototype.runCount = function () {\n  if (!this.doCount) {\n    return;\n  }\n  this.findOptions.count = true;\n  delete this.findOptions.skip;\n  delete this.findOptions.limit;\n  return this.config.database.find(this.className, this.restWhere, this.findOptions).then(c => {\n    this.response.count = c;\n  });\n};\n\n// Augments this.response with all pointers on an object\nRestQuery.prototype.handleIncludeAll = function () {\n  if (!this.includeAll) {\n    return;\n  }\n  return this.config.database\n    .loadSchema()\n    .then(schemaController => schemaController.getOneSchema(this.className))\n    .then(schema => {\n      const includeFields = [];\n      const keyFields = [];\n      for (const field in schema.fields) {\n        if (\n          (schema.fields[field].type && schema.fields[field].type === 'Pointer') ||\n          (schema.fields[field].type && schema.fields[field].type === 'Array')\n        ) {\n          includeFields.push([field]);\n          keyFields.push(field);\n        }\n      }\n      // Add fields to include, keys, remove dups\n      this.include = [...new Set([...this.include, ...includeFields])];\n      // if this.keys not set, then all keys are already included\n      if (this.keys) {\n        this.keys = [...new Set([...this.keys, ...keyFields])];\n      }\n    });\n};\n\n// Updates property `this.keys` to contain all keys but the ones unselected.\nRestQuery.prototype.handleExcludeKeys = function () {\n  if (!this.excludeKeys) {\n    return;\n  }\n  if (this.keys) {\n    this.keys = this.keys.filter(k => !this.excludeKeys.includes(k));\n    return;\n  }\n  return this.config.database\n    .loadSchema()\n    .then(schemaController => schemaController.getOneSchema(this.className))\n    .then(schema => {\n      const fields = Object.keys(schema.fields);\n      this.keys = fields.filter(k => !this.excludeKeys.includes(k));\n    });\n};\n\n// Augments this.response with data at the paths provided in this.include.\nRestQuery.prototype.handleInclude = function () {\n  if (this.include.length == 0) {\n    return;\n  }\n\n  var pathResponse = includePath(\n    this.config,\n    this.auth,\n    this.response,\n    this.include[0],\n    this.restOptions\n  );\n  if (pathResponse.then) {\n    return pathResponse.then(newResponse => {\n      this.response = newResponse;\n      this.include = this.include.slice(1);\n      return this.handleInclude();\n    });\n  } else if (this.include.length > 0) {\n    this.include = this.include.slice(1);\n    return this.handleInclude();\n  }\n\n  return pathResponse;\n};\n\n//Returns a promise of a processed set of results\nRestQuery.prototype.runAfterFindTrigger = function () {\n  if (!this.response) {\n    return;\n  }\n  if (!this.runAfterFind) {\n    return;\n  }\n  // Avoid doing any setup for triggers if there is no 'afterFind' trigger for this class.\n  const hasAfterFindHook = triggers.triggerExists(\n    this.className,\n    triggers.Types.afterFind,\n    this.config.applicationId\n  );\n  if (!hasAfterFindHook) {\n    return Promise.resolve();\n  }\n  // Skip Aggregate and Distinct Queries\n  if (this.findOptions.pipeline || this.findOptions.distinct) {\n    return Promise.resolve();\n  }\n\n  const json = Object.assign({}, this.restOptions);\n  json.where = this.restWhere;\n  const parseQuery = new Parse.Query(this.className);\n  parseQuery.withJSON(json);\n  // Run afterFind trigger and set the new results\n  return triggers\n    .maybeRunAfterFindTrigger(\n      triggers.Types.afterFind,\n      this.auth,\n      this.className,\n      this.response.results,\n      this.config,\n      parseQuery,\n      this.context\n    )\n    .then(results => {\n      // Ensure we properly set the className back\n      if (this.redirectClassName) {\n        this.response.results = results.map(object => {\n          if (object instanceof Parse.Object) {\n            object = object.toJSON();\n          }\n          object.className = this.redirectClassName;\n          return object;\n        });\n      } else {\n        this.response.results = results;\n      }\n    });\n};\n\n// Adds included values to the response.\n// Path is a list of field names.\n// Returns a promise for an augmented response.\nfunction includePath(config, auth, response, path, restOptions = {}) {\n  var pointers = findPointers(response.results, path);\n  if (pointers.length == 0) {\n    return response;\n  }\n  const pointersHash = {};\n  for (var pointer of pointers) {\n    if (!pointer) {\n      continue;\n    }\n    const className = pointer.className;\n    // only include the good pointers\n    if (className) {\n      pointersHash[className] = pointersHash[className] || new Set();\n      pointersHash[className].add(pointer.objectId);\n    }\n  }\n  const includeRestOptions = {};\n  if (restOptions.keys) {\n    const keys = new Set(restOptions.keys.split(','));\n    const keySet = Array.from(keys).reduce((set, key) => {\n      const keyPath = key.split('.');\n      let i = 0;\n      for (i; i < path.length; i++) {\n        if (path[i] != keyPath[i]) {\n          return set;\n        }\n      }\n      if (i < keyPath.length) {\n        set.add(keyPath[i]);\n      }\n      return set;\n    }, new Set());\n    if (keySet.size > 0) {\n      includeRestOptions.keys = Array.from(keySet).join(',');\n    }\n  }\n\n  if (restOptions.excludeKeys) {\n    const excludeKeys = new Set(restOptions.excludeKeys.split(','));\n    const excludeKeySet = Array.from(excludeKeys).reduce((set, key) => {\n      const keyPath = key.split('.');\n      let i = 0;\n      for (i; i < path.length; i++) {\n        if (path[i] != keyPath[i]) {\n          return set;\n        }\n      }\n      if (i == keyPath.length - 1) {\n        set.add(keyPath[i]);\n      }\n      return set;\n    }, new Set());\n    if (excludeKeySet.size > 0) {\n      includeRestOptions.excludeKeys = Array.from(excludeKeySet).join(',');\n    }\n  }\n\n  if (restOptions.includeReadPreference) {\n    includeRestOptions.readPreference = restOptions.includeReadPreference;\n    includeRestOptions.includeReadPreference = restOptions.includeReadPreference;\n  } else if (restOptions.readPreference) {\n    includeRestOptions.readPreference = restOptions.readPreference;\n  }\n\n  const queryPromises = Object.keys(pointersHash).map(className => {\n    const objectIds = Array.from(pointersHash[className]);\n    let where;\n    if (objectIds.length === 1) {\n      where = { objectId: objectIds[0] };\n    } else {\n      where = { objectId: { $in: objectIds } };\n    }\n    var query = new RestQuery(config, auth, className, where, includeRestOptions);\n    return query.execute({ op: 'get' }).then(results => {\n      results.className = className;\n      return Promise.resolve(results);\n    });\n  });\n\n  // Get the objects for all these object ids\n  return Promise.all(queryPromises).then(responses => {\n    var replace = responses.reduce((replace, includeResponse) => {\n      for (var obj of includeResponse.results) {\n        obj.__type = 'Object';\n        obj.className = includeResponse.className;\n\n        if (obj.className == '_User' && !auth.isMaster) {\n          delete obj.sessionToken;\n          delete obj.authData;\n        }\n        replace[obj.objectId] = obj;\n      }\n      return replace;\n    }, {});\n\n    var resp = {\n      results: replacePointers(response.results, path, replace),\n    };\n    if (response.count) {\n      resp.count = response.count;\n    }\n    return resp;\n  });\n}\n\n// Object may be a list of REST-format object to find pointers in, or\n// it may be a single object.\n// If the path yields things that aren't pointers, this throws an error.\n// Path is a list of fields to search into.\n// Returns a list of pointers in REST format.\nfunction findPointers(object, path) {\n  if (object instanceof Array) {\n    var answer = [];\n    for (var x of object) {\n      answer = answer.concat(findPointers(x, path));\n    }\n    return answer;\n  }\n\n  if (typeof object !== 'object' || !object) {\n    return [];\n  }\n\n  if (path.length == 0) {\n    if (object === null || object.__type == 'Pointer') {\n      return [object];\n    }\n    return [];\n  }\n\n  var subobject = object[path[0]];\n  if (!subobject) {\n    return [];\n  }\n  return findPointers(subobject, path.slice(1));\n}\n\n// Object may be a list of REST-format objects to replace pointers\n// in, or it may be a single object.\n// Path is a list of fields to search into.\n// replace is a map from object id -> object.\n// Returns something analogous to object, but with the appropriate\n// pointers inflated.\nfunction replacePointers(object, path, replace) {\n  if (object instanceof Array) {\n    return object\n      .map(obj => replacePointers(obj, path, replace))\n      .filter(obj => typeof obj !== 'undefined');\n  }\n\n  if (typeof object !== 'object' || !object) {\n    return object;\n  }\n\n  if (path.length === 0) {\n    if (object && object.__type === 'Pointer') {\n      return replace[object.objectId];\n    }\n    return object;\n  }\n\n  var subobject = object[path[0]];\n  if (!subobject) {\n    return object;\n  }\n  var newsub = replacePointers(subobject, path.slice(1), replace);\n  var answer = {};\n  for (var key in object) {\n    if (key == path[0]) {\n      answer[key] = newsub;\n    } else {\n      answer[key] = object[key];\n    }\n  }\n  return answer;\n}\n\n// Finds a subobject that has the given key, if there is one.\n// Returns undefined otherwise.\nfunction findObjectWithKey(root, key) {\n  if (typeof root !== 'object') {\n    return;\n  }\n  if (root instanceof Array) {\n    for (var item of root) {\n      const answer = findObjectWithKey(item, key);\n      if (answer) {\n        return answer;\n      }\n    }\n  }\n  if (root && root[key]) {\n    return root;\n  }\n  for (var subkey in root) {\n    const answer = findObjectWithKey(root[subkey], key);\n    if (answer) {\n      return answer;\n    }\n  }\n}\n\nmodule.exports = RestQuery;\n"], "filenames": ["CHANGELOG.md", "spec/ParseQuery.spec.js", "src/Adapters/Storage/Mongo/MongoStorageAdapter.js", "src/RestQuery.js"], "buggy_code_start_loc": [7, 37, 109, 660], "buggy_code_end_loc": [148, 37, 758, 870], "fixing_code_start_loc": [7, 38, 110, 660], "fixing_code_end_loc": [158, 86, 778, 870], "type": "CWE-755", "message": "Parse Server is an open source backend that can be deployed to any infrastructure that can run Node.js. Prior to version 4.10.3, Parse Server crashes when if a query request contains an invalid value for the `explain` option. This is due to a bug in the MongoDB Node.js driver which throws an exception that Parse Server cannot catch. There is a patch for this issue in version 4.10.3. No workarounds aside from upgrading are known to exist.", "other": {"cve": {"id": "CVE-2021-39187", "sourceIdentifier": "security-advisories@github.com", "published": "2021-09-02T16:15:07.540", "lastModified": "2022-08-05T10:51:22.493", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Parse Server is an open source backend that can be deployed to any infrastructure that can run Node.js. Prior to version 4.10.3, Parse Server crashes when if a query request contains an invalid value for the `explain` option. This is due to a bug in the MongoDB Node.js driver which throws an exception that Parse Server cannot catch. There is a patch for this issue in version 4.10.3. No workarounds aside from upgrading are known to exist."}, {"lang": "es", "value": "Parse Server es un backend de c\u00f3digo abierto que puede ser desplegado en cualquier infraestructura que pueda ejecutar Node.js. En las versiones anteriores a 4.10.3, Parse Server se bloquea cuando una petici\u00f3n de consulta contiene un valor no v\u00e1lido para la opci\u00f3n \"explain\". Esto es debido a un bug en el controlador Node.js de MongoDB que lanza una excepci\u00f3n que Parse Server no puede atrapar. Se presenta un parche para este problema en versi\u00f3n 4.10.3. No se conocen soluciones aparte de la actualizaci\u00f3n"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-755"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-74"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:parseplatform:parse-server:*:*:*:*:*:node.js:*:*", "versionEndExcluding": "4.10.3", "matchCriteriaId": "158489E2-C455-4CB4-8BFB-EB285DE91CF1"}]}]}], "references": [{"url": "https://github.com/parse-community/parse-server/commit/308668c89474223e2448be92d6823b52c1c313ec", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/parse-community/parse-server/releases/tag/4.10.3", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/parse-community/parse-server/security/advisories/GHSA-xqp8-w826-hh6x", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://jira.mongodb.org/browse/NODE-3463", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/parse-community/parse-server/commit/308668c89474223e2448be92d6823b52c1c313ec"}}