{"buggy_code": ["// \u26a1\ufe0f Fiber is an Express inspired web framework written in Go with \u2615\ufe0f\n// \ud83e\udd16 Github Repository: https://github.com/gofiber/fiber\n// \ud83d\udccc API Documentation: https://docs.gofiber.io\n\npackage fiber\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"crypto/tls\"\n\t\"encoding/json\"\n\t\"encoding/xml\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"mime/multipart\"\n\t\"net\"\n\t\"net/http\"\n\t\"path/filepath\"\n\t\"reflect\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\t\"text/template\"\n\t\"time\"\n\n\t\"github.com/gofiber/fiber/v2/internal/schema\"\n\t\"github.com/gofiber/fiber/v2/utils\"\n\n\t\"github.com/valyala/bytebufferpool\"\n\t\"github.com/valyala/fasthttp\"\n)\n\nconst (\n\tschemeHTTP  = \"http\"\n\tschemeHTTPS = \"https\"\n)\n\n// maxParams defines the maximum number of parameters per route.\nconst maxParams = 30\n\n// Some constants for BodyParser, QueryParser and ReqHeaderParser.\nconst (\n\tqueryTag     = \"query\"\n\treqHeaderTag = \"reqHeader\"\n\tbodyTag      = \"form\"\n\tparamsTag    = \"params\"\n)\n\n// userContextKey define the key name for storing context.Context in *fasthttp.RequestCtx\nconst userContextKey = \"__local_user_context__\"\n\nvar (\n\t// decoderPoolMap helps to improve BodyParser's, QueryParser's and ReqHeaderParser's performance\n\tdecoderPoolMap = map[string]*sync.Pool{}\n\t// tags is used to classify parser's pool\n\ttags = []string{queryTag, bodyTag, reqHeaderTag, paramsTag}\n)\n\nfunc init() {\n\tfor _, tag := range tags {\n\t\tdecoderPoolMap[tag] = &sync.Pool{New: func() interface{} {\n\t\t\treturn decoderBuilder(ParserConfig{\n\t\t\t\tIgnoreUnknownKeys: true,\n\t\t\t\tZeroEmpty:         true,\n\t\t\t})\n\t\t}}\n\t}\n}\n\n// SetParserDecoder allow globally change the option of form decoder, update decoderPool\nfunc SetParserDecoder(parserConfig ParserConfig) {\n\tfor _, tag := range tags {\n\t\tdecoderPoolMap[tag] = &sync.Pool{New: func() interface{} {\n\t\t\treturn decoderBuilder(parserConfig)\n\t\t}}\n\t}\n}\n\n// Ctx represents the Context which hold the HTTP request and response.\n// It has methods for the request query string, parameters, body, HTTP headers and so on.\ntype Ctx struct {\n\tapp                 *App                 // Reference to *App\n\troute               *Route               // Reference to *Route\n\tindexRoute          int                  // Index of the current route\n\tindexHandler        int                  // Index of the current handler\n\tmethod              string               // HTTP method\n\tmethodINT           int                  // HTTP method INT equivalent\n\tbaseURI             string               // HTTP base uri\n\tpath                string               // HTTP path with the modifications by the configuration -> string copy from pathBuffer\n\tpathBuffer          []byte               // HTTP path buffer\n\tdetectionPath       string               // Route detection path                                  -> string copy from detectionPathBuffer\n\tdetectionPathBuffer []byte               // HTTP detectionPath buffer\n\ttreePath            string               // Path for the search in the tree\n\tpathOriginal        string               // Original HTTP path\n\tvalues              [maxParams]string    // Route parameter values\n\tfasthttp            *fasthttp.RequestCtx // Reference to *fasthttp.RequestCtx\n\tmatched             bool                 // Non use route matched\n\tviewBindMap         sync.Map             // Default view map to bind template engine\n}\n\n// TLSHandler object\ntype TLSHandler struct {\n\tclientHelloInfo *tls.ClientHelloInfo\n}\n\n// GetClientInfo Callback function to set CHI\n// TODO: Why is this a getter which sets stuff?\nfunc (t *TLSHandler) GetClientInfo(info *tls.ClientHelloInfo) (*tls.Certificate, error) {\n\tt.clientHelloInfo = info\n\treturn nil, nil //nolint:nilnil // Not returning anything useful here is probably fine\n}\n\n// Range data for c.Range\ntype Range struct {\n\tType   string\n\tRanges []struct {\n\t\tStart int\n\t\tEnd   int\n\t}\n}\n\n// Cookie data for c.Cookie\ntype Cookie struct {\n\tName        string    `json:\"name\"`\n\tValue       string    `json:\"value\"`\n\tPath        string    `json:\"path\"`\n\tDomain      string    `json:\"domain\"`\n\tMaxAge      int       `json:\"max_age\"`\n\tExpires     time.Time `json:\"expires\"`\n\tSecure      bool      `json:\"secure\"`\n\tHTTPOnly    bool      `json:\"http_only\"`\n\tSameSite    string    `json:\"same_site\"`\n\tSessionOnly bool      `json:\"session_only\"`\n}\n\n// Views is the interface that wraps the Render function.\ntype Views interface {\n\tLoad() error\n\tRender(io.Writer, string, interface{}, ...string) error\n}\n\n// ParserType require two element, type and converter for register.\n// Use ParserType with BodyParser for parsing custom type in form data.\ntype ParserType struct {\n\tCustomtype interface{}\n\tConverter  func(string) reflect.Value\n}\n\n// ParserConfig form decoder config for SetParserDecoder\ntype ParserConfig struct {\n\tIgnoreUnknownKeys bool\n\tSetAliasTag       string\n\tParserType        []ParserType\n\tZeroEmpty         bool\n}\n\n// AcquireCtx retrieves a new Ctx from the pool.\nfunc (app *App) AcquireCtx(fctx *fasthttp.RequestCtx) *Ctx {\n\tc, ok := app.pool.Get().(*Ctx)\n\tif !ok {\n\t\tpanic(fmt.Errorf(\"failed to type-assert to *Ctx\"))\n\t}\n\t// Set app reference\n\tc.app = app\n\t// Reset route and handler index\n\tc.indexRoute = -1\n\tc.indexHandler = 0\n\t// Reset matched flag\n\tc.matched = false\n\t// Set paths\n\tc.pathOriginal = app.getString(fctx.URI().PathOriginal())\n\t// Set method\n\tc.method = app.getString(fctx.Request.Header.Method())\n\tc.methodINT = app.methodInt(c.method)\n\t// Attach *fasthttp.RequestCtx to ctx\n\tc.fasthttp = fctx\n\t// reset base uri\n\tc.baseURI = \"\"\n\t// Prettify path\n\tc.configDependentPaths()\n\treturn c\n}\n\n// ReleaseCtx releases the ctx back into the pool.\nfunc (app *App) ReleaseCtx(c *Ctx) {\n\t// Reset values\n\tc.route = nil\n\tc.fasthttp = nil\n\tc.viewBindMap = sync.Map{}\n\tapp.pool.Put(c)\n}\n\n// Accepts checks if the specified extensions or content types are acceptable.\nfunc (c *Ctx) Accepts(offers ...string) string {\n\treturn getOffer(c.Get(HeaderAccept), acceptsOfferType, offers...)\n}\n\n// AcceptsCharsets checks if the specified charset is acceptable.\nfunc (c *Ctx) AcceptsCharsets(offers ...string) string {\n\treturn getOffer(c.Get(HeaderAcceptCharset), acceptsOffer, offers...)\n}\n\n// AcceptsEncodings checks if the specified encoding is acceptable.\nfunc (c *Ctx) AcceptsEncodings(offers ...string) string {\n\treturn getOffer(c.Get(HeaderAcceptEncoding), acceptsOffer, offers...)\n}\n\n// AcceptsLanguages checks if the specified language is acceptable.\nfunc (c *Ctx) AcceptsLanguages(offers ...string) string {\n\treturn getOffer(c.Get(HeaderAcceptLanguage), acceptsOffer, offers...)\n}\n\n// App returns the *App reference to the instance of the Fiber application\nfunc (c *Ctx) App() *App {\n\treturn c.app\n}\n\n// Append the specified value to the HTTP response header field.\n// If the header is not already set, it creates the header with the specified value.\nfunc (c *Ctx) Append(field string, values ...string) {\n\tif len(values) == 0 {\n\t\treturn\n\t}\n\th := c.app.getString(c.fasthttp.Response.Header.Peek(field))\n\toriginalH := h\n\tfor _, value := range values {\n\t\tif len(h) == 0 {\n\t\t\th = value\n\t\t} else if h != value && !strings.HasPrefix(h, value+\",\") && !strings.HasSuffix(h, \" \"+value) &&\n\t\t\t!strings.Contains(h, \" \"+value+\",\") {\n\t\t\th += \", \" + value\n\t\t}\n\t}\n\tif originalH != h {\n\t\tc.Set(field, h)\n\t}\n}\n\n// Attachment sets the HTTP response Content-Disposition header field to attachment.\nfunc (c *Ctx) Attachment(filename ...string) {\n\tif len(filename) > 0 {\n\t\tfname := filepath.Base(filename[0])\n\t\tc.Type(filepath.Ext(fname))\n\n\t\tc.setCanonical(HeaderContentDisposition, `attachment; filename=\"`+c.app.quoteString(fname)+`\"`)\n\t\treturn\n\t}\n\tc.setCanonical(HeaderContentDisposition, \"attachment\")\n}\n\n// BaseURL returns (protocol + host + base path).\nfunc (c *Ctx) BaseURL() string {\n\t// TODO: Could be improved: 53.8 ns/op  32 B/op  1 allocs/op\n\t// Should work like https://codeigniter.com/user_guide/helpers/url_helper.html\n\tif c.baseURI != \"\" {\n\t\treturn c.baseURI\n\t}\n\tc.baseURI = c.Protocol() + \"://\" + c.Hostname()\n\treturn c.baseURI\n}\n\n// BodyRaw contains the raw body submitted in a POST request.\n// Returned value is only valid within the handler. Do not store any references.\n// Make copies or use the Immutable setting instead.\nfunc (c *Ctx) BodyRaw() []byte {\n\treturn c.fasthttp.Request.Body()\n}\n\nfunc (c *Ctx) tryDecodeBodyInOrder(\n\toriginalBody *[]byte,\n\tencodings []string,\n) ([]byte, uint8, error) {\n\tvar (\n\t\terr             error\n\t\tbody            []byte\n\t\tdecodesRealized uint8\n\t)\n\n\tfor index, encoding := range encodings {\n\t\tdecodesRealized++\n\t\tswitch encoding {\n\t\tcase StrGzip:\n\t\t\tbody, err = c.fasthttp.Request.BodyGunzip()\n\t\tcase StrBr, StrBrotli:\n\t\t\tbody, err = c.fasthttp.Request.BodyUnbrotli()\n\t\tcase StrDeflate:\n\t\t\tbody, err = c.fasthttp.Request.BodyInflate()\n\t\tdefault:\n\t\t\tdecodesRealized--\n\t\t\tif len(encodings) == 1 {\n\t\t\t\tbody = c.fasthttp.Request.Body()\n\t\t\t}\n\t\t\treturn body, decodesRealized, nil\n\t\t}\n\n\t\tif err != nil {\n\t\t\treturn nil, decodesRealized, err\n\t\t}\n\n\t\t// Only execute body raw update if it has a next iteration to try to decode\n\t\tif index < len(encodings)-1 && decodesRealized > 0 {\n\t\t\tif index == 0 {\n\t\t\t\ttempBody := c.fasthttp.Request.Body()\n\t\t\t\t*originalBody = make([]byte, len(tempBody))\n\t\t\t\tcopy(*originalBody, tempBody)\n\t\t\t}\n\t\t\tc.fasthttp.Request.SetBodyRaw(body)\n\t\t}\n\t}\n\n\treturn body, decodesRealized, nil\n}\n\n// Body contains the raw body submitted in a POST request.\n// This method will decompress the body if the 'Content-Encoding' header is provided.\n// It returns the original (or decompressed) body data which is valid only within the handler.\n// Don't store direct references to the returned data.\n// If you need to keep the body's data later, make a copy or use the Immutable option.\nfunc (c *Ctx) Body() []byte {\n\tvar (\n\t\terr                error\n\t\tbody, originalBody []byte\n\t\theaderEncoding     string\n\t\tencodingOrder      = []string{\"\", \"\", \"\"}\n\t)\n\n\t// faster than peek\n\tc.Request().Header.VisitAll(func(key, value []byte) {\n\t\tif c.app.getString(key) == HeaderContentEncoding {\n\t\t\theaderEncoding = c.app.getString(value)\n\t\t}\n\t})\n\n\t// Split and get the encodings list, in order to attend the\n\t// rule defined at: https://www.rfc-editor.org/rfc/rfc9110#section-8.4-5\n\tencodingOrder = getSplicedStrList(headerEncoding, encodingOrder)\n\tif len(encodingOrder) == 0 {\n\t\treturn c.fasthttp.Request.Body()\n\t}\n\n\tvar decodesRealized uint8\n\tbody, decodesRealized, err = c.tryDecodeBodyInOrder(&originalBody, encodingOrder)\n\n\t// Ensure that the body will be the original\n\tif originalBody != nil && decodesRealized > 0 {\n\t\tc.fasthttp.Request.SetBodyRaw(originalBody)\n\t}\n\tif err != nil {\n\t\treturn []byte(err.Error())\n\t}\n\n\treturn body\n}\n\nfunc decoderBuilder(parserConfig ParserConfig) interface{} {\n\tdecoder := schema.NewDecoder()\n\tdecoder.IgnoreUnknownKeys(parserConfig.IgnoreUnknownKeys)\n\tif parserConfig.SetAliasTag != \"\" {\n\t\tdecoder.SetAliasTag(parserConfig.SetAliasTag)\n\t}\n\tfor _, v := range parserConfig.ParserType {\n\t\tdecoder.RegisterConverter(reflect.ValueOf(v.Customtype).Interface(), v.Converter)\n\t}\n\tdecoder.ZeroEmpty(parserConfig.ZeroEmpty)\n\treturn decoder\n}\n\n// BodyParser binds the request body to a struct.\n// It supports decoding the following content types based on the Content-Type header:\n// application/json, application/xml, application/x-www-form-urlencoded, multipart/form-data\n// If none of the content types above are matched, it will return a ErrUnprocessableEntity error\nfunc (c *Ctx) BodyParser(out interface{}) error {\n\t// Get content-type\n\tctype := utils.ToLower(c.app.getString(c.fasthttp.Request.Header.ContentType()))\n\n\tctype = utils.ParseVendorSpecificContentType(ctype)\n\n\t// Parse body accordingly\n\tif strings.HasPrefix(ctype, MIMEApplicationJSON) {\n\t\treturn c.app.config.JSONDecoder(c.Body(), out)\n\t}\n\tif strings.HasPrefix(ctype, MIMEApplicationForm) {\n\t\tdata := make(map[string][]string)\n\t\tvar err error\n\n\t\tc.fasthttp.PostArgs().VisitAll(func(key, val []byte) {\n\t\t\tif err != nil {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tk := c.app.getString(key)\n\t\t\tv := c.app.getString(val)\n\n\t\t\tif strings.Contains(k, \"[\") {\n\t\t\t\tk, err = parseParamSquareBrackets(k)\n\t\t\t}\n\n\t\t\tif c.app.config.EnableSplittingOnParsers && strings.Contains(v, \",\") && equalFieldType(out, reflect.Slice, k) {\n\t\t\t\tvalues := strings.Split(v, \",\")\n\t\t\t\tfor i := 0; i < len(values); i++ {\n\t\t\t\t\tdata[k] = append(data[k], values[i])\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdata[k] = append(data[k], v)\n\t\t\t}\n\t\t})\n\n\t\treturn c.parseToStruct(bodyTag, out, data)\n\t}\n\tif strings.HasPrefix(ctype, MIMEMultipartForm) {\n\t\tdata, err := c.fasthttp.MultipartForm()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn c.parseToStruct(bodyTag, out, data.Value)\n\t}\n\tif strings.HasPrefix(ctype, MIMETextXML) || strings.HasPrefix(ctype, MIMEApplicationXML) {\n\t\tif err := xml.Unmarshal(c.Body(), out); err != nil {\n\t\t\treturn fmt.Errorf(\"failed to unmarshal: %w\", err)\n\t\t}\n\t\treturn nil\n\t}\n\t// No suitable content type found\n\treturn ErrUnprocessableEntity\n}\n\n// ClearCookie expires a specific cookie by key on the client side.\n// If no key is provided it expires all cookies that came with the request.\nfunc (c *Ctx) ClearCookie(key ...string) {\n\tif len(key) > 0 {\n\t\tfor i := range key {\n\t\t\tc.fasthttp.Response.Header.DelClientCookie(key[i])\n\t\t}\n\t\treturn\n\t}\n\tc.fasthttp.Request.Header.VisitAllCookie(func(k, v []byte) {\n\t\tc.fasthttp.Response.Header.DelClientCookieBytes(k)\n\t})\n}\n\n// Context returns *fasthttp.RequestCtx that carries a deadline\n// a cancellation signal, and other values across API boundaries.\nfunc (c *Ctx) Context() *fasthttp.RequestCtx {\n\treturn c.fasthttp\n}\n\n// UserContext returns a context implementation that was set by\n// user earlier or returns a non-nil, empty context,if it was not set earlier.\nfunc (c *Ctx) UserContext() context.Context {\n\tctx, ok := c.fasthttp.UserValue(userContextKey).(context.Context)\n\tif !ok {\n\t\tctx = context.Background()\n\t\tc.SetUserContext(ctx)\n\t}\n\n\treturn ctx\n}\n\n// SetUserContext sets a context implementation by user.\nfunc (c *Ctx) SetUserContext(ctx context.Context) {\n\tc.fasthttp.SetUserValue(userContextKey, ctx)\n}\n\n// Cookie sets a cookie by passing a cookie struct.\nfunc (c *Ctx) Cookie(cookie *Cookie) {\n\tfcookie := fasthttp.AcquireCookie()\n\tfcookie.SetKey(cookie.Name)\n\tfcookie.SetValue(cookie.Value)\n\tfcookie.SetPath(cookie.Path)\n\tfcookie.SetDomain(cookie.Domain)\n\t// only set max age and expiry when SessionOnly is false\n\t// i.e. cookie supposed to last beyond browser session\n\t// refer: https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies#define_the_lifetime_of_a_cookie\n\tif !cookie.SessionOnly {\n\t\tfcookie.SetMaxAge(cookie.MaxAge)\n\t\tfcookie.SetExpire(cookie.Expires)\n\t}\n\tfcookie.SetSecure(cookie.Secure)\n\tfcookie.SetHTTPOnly(cookie.HTTPOnly)\n\n\tswitch utils.ToLower(cookie.SameSite) {\n\tcase CookieSameSiteStrictMode:\n\t\tfcookie.SetSameSite(fasthttp.CookieSameSiteStrictMode)\n\tcase CookieSameSiteNoneMode:\n\t\tfcookie.SetSameSite(fasthttp.CookieSameSiteNoneMode)\n\tcase CookieSameSiteDisabled:\n\t\tfcookie.SetSameSite(fasthttp.CookieSameSiteDisabled)\n\tdefault:\n\t\tfcookie.SetSameSite(fasthttp.CookieSameSiteLaxMode)\n\t}\n\n\tc.fasthttp.Response.Header.SetCookie(fcookie)\n\tfasthttp.ReleaseCookie(fcookie)\n}\n\n// Cookies are used for getting a cookie value by key.\n// Defaults to the empty string \"\" if the cookie doesn't exist.\n// If a default value is given, it will return that value if the cookie doesn't exist.\n// The returned value is only valid within the handler. Do not store any references.\n// Make copies or use the Immutable setting to use the value outside the Handler.\nfunc (c *Ctx) Cookies(key string, defaultValue ...string) string {\n\treturn defaultString(c.app.getString(c.fasthttp.Request.Header.Cookie(key)), defaultValue)\n}\n\n// Download transfers the file from path as an attachment.\n// Typically, browsers will prompt the user for download.\n// By default, the Content-Disposition header filename= parameter is the filepath (this typically appears in the browser dialog).\n// Override this default with the filename parameter.\nfunc (c *Ctx) Download(file string, filename ...string) error {\n\tvar fname string\n\tif len(filename) > 0 {\n\t\tfname = filename[0]\n\t} else {\n\t\tfname = filepath.Base(file)\n\t}\n\tc.setCanonical(HeaderContentDisposition, `attachment; filename=\"`+c.app.quoteString(fname)+`\"`)\n\treturn c.SendFile(file)\n}\n\n// Request return the *fasthttp.Request object\n// This allows you to use all fasthttp request methods\n// https://godoc.org/github.com/valyala/fasthttp#Request\nfunc (c *Ctx) Request() *fasthttp.Request {\n\treturn &c.fasthttp.Request\n}\n\n// Response return the *fasthttp.Response object\n// This allows you to use all fasthttp response methods\n// https://godoc.org/github.com/valyala/fasthttp#Response\nfunc (c *Ctx) Response() *fasthttp.Response {\n\treturn &c.fasthttp.Response\n}\n\n// Format performs content-negotiation on the Accept HTTP header.\n// It uses Accepts to select a proper format.\n// If the header is not specified or there is no proper format, text/plain is used.\nfunc (c *Ctx) Format(body interface{}) error {\n\t// Get accepted content type\n\taccept := c.Accepts(\"html\", \"json\", \"txt\", \"xml\")\n\t// Set accepted content type\n\tc.Type(accept)\n\t// Type convert provided body\n\tvar b string\n\tswitch val := body.(type) {\n\tcase string:\n\t\tb = val\n\tcase []byte:\n\t\tb = c.app.getString(val)\n\tdefault:\n\t\tb = fmt.Sprintf(\"%v\", val)\n\t}\n\n\t// Format based on the accept content type\n\tswitch accept {\n\tcase \"html\":\n\t\treturn c.SendString(\"<p>\" + b + \"</p>\")\n\tcase \"json\":\n\t\treturn c.JSON(body)\n\tcase \"txt\":\n\t\treturn c.SendString(b)\n\tcase \"xml\":\n\t\treturn c.XML(body)\n\t}\n\treturn c.SendString(b)\n}\n\n// FormFile returns the first file by key from a MultipartForm.\nfunc (c *Ctx) FormFile(key string) (*multipart.FileHeader, error) {\n\treturn c.fasthttp.FormFile(key)\n}\n\n// FormValue returns the first value by key from a MultipartForm.\n// Search is performed in QueryArgs, PostArgs, MultipartForm and FormFile in this particular order.\n// Defaults to the empty string \"\" if the form value doesn't exist.\n// If a default value is given, it will return that value if the form value does not exist.\n// Returned value is only valid within the handler. Do not store any references.\n// Make copies or use the Immutable setting instead.\nfunc (c *Ctx) FormValue(key string, defaultValue ...string) string {\n\treturn defaultString(c.app.getString(c.fasthttp.FormValue(key)), defaultValue)\n}\n\n// Fresh returns true when the response is still \u201cfresh\u201d in the client's cache,\n// otherwise false is returned to indicate that the client cache is now stale\n// and the full response should be sent.\n// When a client sends the Cache-Control: no-cache request header to indicate an end-to-end\n// reload request, this module will return false to make handling these requests transparent.\n// https://github.com/jshttp/fresh/blob/10e0471669dbbfbfd8de65bc6efac2ddd0bfa057/index.js#L33\nfunc (c *Ctx) Fresh() bool {\n\t// fields\n\tmodifiedSince := c.Get(HeaderIfModifiedSince)\n\tnoneMatch := c.Get(HeaderIfNoneMatch)\n\n\t// unconditional request\n\tif modifiedSince == \"\" && noneMatch == \"\" {\n\t\treturn false\n\t}\n\n\t// Always return stale when Cache-Control: no-cache\n\t// to support end-to-end reload requests\n\t// https://tools.ietf.org/html/rfc2616#section-14.9.4\n\tcacheControl := c.Get(HeaderCacheControl)\n\tif cacheControl != \"\" && isNoCache(cacheControl) {\n\t\treturn false\n\t}\n\n\t// if-none-match\n\tif noneMatch != \"\" && noneMatch != \"*\" {\n\t\tetag := c.app.getString(c.fasthttp.Response.Header.Peek(HeaderETag))\n\t\tif etag == \"\" {\n\t\t\treturn false\n\t\t}\n\t\tif c.app.isEtagStale(etag, c.app.getBytes(noneMatch)) {\n\t\t\treturn false\n\t\t}\n\n\t\tif modifiedSince != \"\" {\n\t\t\tlastModified := c.app.getString(c.fasthttp.Response.Header.Peek(HeaderLastModified))\n\t\t\tif lastModified != \"\" {\n\t\t\t\tlastModifiedTime, err := http.ParseTime(lastModified)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn false\n\t\t\t\t}\n\t\t\t\tmodifiedSinceTime, err := http.ParseTime(modifiedSince)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn false\n\t\t\t\t}\n\t\t\t\treturn lastModifiedTime.Before(modifiedSinceTime)\n\t\t\t}\n\t\t}\n\t}\n\treturn true\n}\n\n// Get returns the HTTP request header specified by field.\n// Field names are case-insensitive\n// Returned value is only valid within the handler. Do not store any references.\n// Make copies or use the Immutable setting instead.\nfunc (c *Ctx) Get(key string, defaultValue ...string) string {\n\treturn defaultString(c.app.getString(c.fasthttp.Request.Header.Peek(key)), defaultValue)\n}\n\n// GetRespHeader returns the HTTP response header specified by field.\n// Field names are case-insensitive\n// Returned value is only valid within the handler. Do not store any references.\n// Make copies or use the Immutable setting instead.\nfunc (c *Ctx) GetRespHeader(key string, defaultValue ...string) string {\n\treturn defaultString(c.app.getString(c.fasthttp.Response.Header.Peek(key)), defaultValue)\n}\n\n// GetReqHeaders returns the HTTP request headers.\n// Returned value is only valid within the handler. Do not store any references.\n// Make copies or use the Immutable setting instead.\nfunc (c *Ctx) GetReqHeaders() map[string]string {\n\theaders := make(map[string]string)\n\tc.Request().Header.VisitAll(func(k, v []byte) {\n\t\theaders[c.app.getString(k)] = c.app.getString(v)\n\t})\n\n\treturn headers\n}\n\n// GetRespHeaders returns the HTTP response headers.\n// Returned value is only valid within the handler. Do not store any references.\n// Make copies or use the Immutable setting instead.\nfunc (c *Ctx) GetRespHeaders() map[string]string {\n\theaders := make(map[string]string)\n\tc.Response().Header.VisitAll(func(k, v []byte) {\n\t\theaders[c.app.getString(k)] = c.app.getString(v)\n\t})\n\n\treturn headers\n}\n\n// Hostname contains the hostname derived from the X-Forwarded-Host or Host HTTP header.\n// Returned value is only valid within the handler. Do not store any references.\n// Make copies or use the Immutable setting instead.\n// Please use Config.EnableTrustedProxyCheck to prevent header spoofing, in case when your app is behind the proxy.\nfunc (c *Ctx) Hostname() string {\n\tif c.IsProxyTrusted() {\n\t\tif host := c.Get(HeaderXForwardedHost); len(host) > 0 {\n\t\t\tcommaPos := strings.Index(host, \",\")\n\t\t\tif commaPos != -1 {\n\t\t\t\treturn host[:commaPos]\n\t\t\t}\n\t\t\treturn host\n\t\t}\n\t}\n\treturn c.app.getString(c.fasthttp.Request.URI().Host())\n}\n\n// Port returns the remote port of the request.\nfunc (c *Ctx) Port() string {\n\ttcpaddr, ok := c.fasthttp.RemoteAddr().(*net.TCPAddr)\n\tif !ok {\n\t\tpanic(fmt.Errorf(\"failed to type-assert to *net.TCPAddr\"))\n\t}\n\treturn strconv.Itoa(tcpaddr.Port)\n}\n\n// IP returns the remote IP address of the request.\n// If ProxyHeader and IP Validation is configured, it will parse that header and return the first valid IP address.\n// Please use Config.EnableTrustedProxyCheck to prevent header spoofing, in case when your app is behind the proxy.\nfunc (c *Ctx) IP() string {\n\tif c.IsProxyTrusted() && len(c.app.config.ProxyHeader) > 0 {\n\t\treturn c.extractIPFromHeader(c.app.config.ProxyHeader)\n\t}\n\n\treturn c.fasthttp.RemoteIP().String()\n}\n\n// extractIPsFromHeader will return a slice of IPs it found given a header name in the order they appear.\n// When IP validation is enabled, any invalid IPs will be omitted.\nfunc (c *Ctx) extractIPsFromHeader(header string) []string {\n\t// TODO: Reuse the c.extractIPFromHeader func somehow in here\n\n\theaderValue := c.Get(header)\n\n\t// We can't know how many IPs we will return, but we will try to guess with this constant division.\n\t// Counting ',' makes function slower for about 50ns in general case.\n\tconst maxEstimatedCount = 8\n\testimatedCount := len(headerValue) / maxEstimatedCount\n\tif estimatedCount > maxEstimatedCount {\n\t\testimatedCount = maxEstimatedCount // Avoid big allocation on big header\n\t}\n\n\tipsFound := make([]string, 0, estimatedCount)\n\n\ti := 0\n\tj := -1\n\niploop:\n\tfor {\n\t\tvar v4, v6 bool\n\n\t\t// Manually splitting string without allocating slice, working with parts directly\n\t\ti, j = j+1, j+2\n\n\t\tif j > len(headerValue) {\n\t\t\tbreak\n\t\t}\n\n\t\tfor j < len(headerValue) && headerValue[j] != ',' {\n\t\t\tif headerValue[j] == ':' {\n\t\t\t\tv6 = true\n\t\t\t} else if headerValue[j] == '.' {\n\t\t\t\tv4 = true\n\t\t\t}\n\t\t\tj++\n\t\t}\n\n\t\tfor i < j && headerValue[i] == ' ' {\n\t\t\ti++\n\t\t}\n\n\t\ts := utils.TrimRight(headerValue[i:j], ' ')\n\n\t\tif c.app.config.EnableIPValidation {\n\t\t\t// Skip validation if IP is clearly not IPv4/IPv6, otherwise validate without allocations\n\t\t\tif (!v6 && !v4) || (v6 && !utils.IsIPv6(s)) || (v4 && !utils.IsIPv4(s)) {\n\t\t\t\tcontinue iploop\n\t\t\t}\n\t\t}\n\n\t\tipsFound = append(ipsFound, s)\n\t}\n\n\treturn ipsFound\n}\n\n// extractIPFromHeader will attempt to pull the real client IP from the given header when IP validation is enabled.\n// currently, it will return the first valid IP address in header.\n// when IP validation is disabled, it will simply return the value of the header without any inspection.\n// Implementation is almost the same as in extractIPsFromHeader, but without allocation of []string.\nfunc (c *Ctx) extractIPFromHeader(header string) string {\n\tif c.app.config.EnableIPValidation {\n\t\theaderValue := c.Get(header)\n\n\t\ti := 0\n\t\tj := -1\n\n\tiploop:\n\t\tfor {\n\t\t\tvar v4, v6 bool\n\n\t\t\t// Manually splitting string without allocating slice, working with parts directly\n\t\t\ti, j = j+1, j+2\n\n\t\t\tif j > len(headerValue) {\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\tfor j < len(headerValue) && headerValue[j] != ',' {\n\t\t\t\tif headerValue[j] == ':' {\n\t\t\t\t\tv6 = true\n\t\t\t\t} else if headerValue[j] == '.' {\n\t\t\t\t\tv4 = true\n\t\t\t\t}\n\t\t\t\tj++\n\t\t\t}\n\n\t\t\tfor i < j && headerValue[i] == ' ' {\n\t\t\t\ti++\n\t\t\t}\n\n\t\t\ts := utils.TrimRight(headerValue[i:j], ' ')\n\n\t\t\tif c.app.config.EnableIPValidation {\n\t\t\t\tif (!v6 && !v4) || (v6 && !utils.IsIPv6(s)) || (v4 && !utils.IsIPv4(s)) {\n\t\t\t\t\tcontinue iploop\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn s\n\t\t}\n\n\t\treturn c.fasthttp.RemoteIP().String()\n\t}\n\n\t// default behavior if IP validation is not enabled is just to return whatever value is\n\t// in the proxy header. Even if it is empty or invalid\n\treturn c.Get(c.app.config.ProxyHeader)\n}\n\n// IPs returns a string slice of IP addresses specified in the X-Forwarded-For request header.\n// When IP validation is enabled, only valid IPs are returned.\nfunc (c *Ctx) IPs() []string {\n\treturn c.extractIPsFromHeader(HeaderXForwardedFor)\n}\n\n// Is returns the matching content type,\n// if the incoming request's Content-Type HTTP header field matches the MIME type specified by the type parameter\nfunc (c *Ctx) Is(extension string) bool {\n\textensionHeader := utils.GetMIME(extension)\n\tif extensionHeader == \"\" {\n\t\treturn false\n\t}\n\n\treturn strings.HasPrefix(\n\t\tutils.TrimLeft(c.app.getString(c.fasthttp.Request.Header.ContentType()), ' '),\n\t\textensionHeader,\n\t)\n}\n\n// JSON converts any interface or string to JSON.\n// Array and slice values encode as JSON arrays,\n// except that []byte encodes as a base64-encoded string,\n// and a nil slice encodes as the null JSON value.\n// This method also sets the content header to application/json.\nfunc (c *Ctx) JSON(data interface{}) error {\n\traw, err := c.app.config.JSONEncoder(data)\n\tif err != nil {\n\t\treturn err\n\t}\n\tc.fasthttp.Response.SetBodyRaw(raw)\n\tc.fasthttp.Response.Header.SetContentType(MIMEApplicationJSON)\n\treturn nil\n}\n\n// JSONP sends a JSON response with JSONP support.\n// This method is identical to JSON, except that it opts-in to JSONP callback support.\n// By default, the callback name is simply callback.\nfunc (c *Ctx) JSONP(data interface{}, callback ...string) error {\n\traw, err := json.Marshal(data)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to marshal: %w\", err)\n\t}\n\n\tvar result, cb string\n\n\tif len(callback) > 0 {\n\t\tcb = callback[0]\n\t} else {\n\t\tcb = \"callback\"\n\t}\n\n\tresult = cb + \"(\" + c.app.getString(raw) + \");\"\n\n\tc.setCanonical(HeaderXContentTypeOptions, \"nosniff\")\n\tc.fasthttp.Response.Header.SetContentType(MIMETextJavaScriptCharsetUTF8)\n\treturn c.SendString(result)\n}\n\n// XML converts any interface or string to XML.\n// This method also sets the content header to application/xml.\nfunc (c *Ctx) XML(data interface{}) error {\n\traw, err := c.app.config.XMLEncoder(data)\n\tif err != nil {\n\t\treturn err\n\t}\n\tc.fasthttp.Response.SetBodyRaw(raw)\n\tc.fasthttp.Response.Header.SetContentType(MIMEApplicationXML)\n\treturn nil\n}\n\n// Links joins the links followed by the property to populate the response's Link HTTP header field.\nfunc (c *Ctx) Links(link ...string) {\n\tif len(link) == 0 {\n\t\treturn\n\t}\n\tbb := bytebufferpool.Get()\n\tfor i := range link {\n\t\tif i%2 == 0 {\n\t\t\t_ = bb.WriteByte('<')          //nolint:errcheck // This will never fail\n\t\t\t_, _ = bb.WriteString(link[i]) //nolint:errcheck // This will never fail\n\t\t\t_ = bb.WriteByte('>')          //nolint:errcheck // This will never fail\n\t\t} else {\n\t\t\t_, _ = bb.WriteString(`; rel=\"` + link[i] + `\",`) //nolint:errcheck // This will never fail\n\t\t}\n\t}\n\tc.setCanonical(HeaderLink, utils.TrimRight(c.app.getString(bb.Bytes()), ','))\n\tbytebufferpool.Put(bb)\n}\n\n// Locals makes it possible to pass interface{} values under keys scoped to the request\n// and therefore available to all following routes that match the request.\nfunc (c *Ctx) Locals(key interface{}, value ...interface{}) interface{} {\n\tif len(value) == 0 {\n\t\treturn c.fasthttp.UserValue(key)\n\t}\n\tc.fasthttp.SetUserValue(key, value[0])\n\treturn value[0]\n}\n\n// Location sets the response Location HTTP header to the specified path parameter.\nfunc (c *Ctx) Location(path string) {\n\tc.setCanonical(HeaderLocation, path)\n}\n\n// Method contains a string corresponding to the HTTP method of the request: GET, POST, PUT and so on.\nfunc (c *Ctx) Method(override ...string) string {\n\tif len(override) > 0 {\n\t\tmethod := utils.ToUpper(override[0])\n\t\tmINT := c.app.methodInt(method)\n\t\tif mINT == -1 {\n\t\t\treturn c.method\n\t\t}\n\t\tc.method = method\n\t\tc.methodINT = mINT\n\t}\n\treturn c.method\n}\n\n// MultipartForm parse form entries from binary.\n// This returns a map[string][]string, so given a key the value will be a string slice.\nfunc (c *Ctx) MultipartForm() (*multipart.Form, error) {\n\treturn c.fasthttp.MultipartForm()\n}\n\n// ClientHelloInfo return CHI from context\nfunc (c *Ctx) ClientHelloInfo() *tls.ClientHelloInfo {\n\tif c.app.tlsHandler != nil {\n\t\treturn c.app.tlsHandler.clientHelloInfo\n\t}\n\n\treturn nil\n}\n\n// Next executes the next method in the stack that matches the current route.\nfunc (c *Ctx) Next() error {\n\t// Increment handler index\n\tc.indexHandler++\n\tvar err error\n\t// Did we execute all route handlers?\n\tif c.indexHandler < len(c.route.Handlers) {\n\t\t// Continue route stack\n\t\terr = c.route.Handlers[c.indexHandler](c)\n\t} else {\n\t\t// Continue handler stack\n\t\t_, err = c.app.next(c)\n\t}\n\treturn err\n}\n\n// RestartRouting instead of going to the next handler. This may be useful after\n// changing the request path. Note that handlers might be executed again.\nfunc (c *Ctx) RestartRouting() error {\n\tc.indexRoute = -1\n\t_, err := c.app.next(c)\n\treturn err\n}\n\n// OriginalURL contains the original request URL.\n// Returned value is only valid within the handler. Do not store any references.\n// Make copies or use the Immutable setting to use the value outside the Handler.\nfunc (c *Ctx) OriginalURL() string {\n\treturn c.app.getString(c.fasthttp.Request.Header.RequestURI())\n}\n\n// Params is used to get the route parameters.\n// Defaults to empty string \"\" if the param doesn't exist.\n// If a default value is given, it will return that value if the param doesn't exist.\n// Returned value is only valid within the handler. Do not store any references.\n// Make copies or use the Immutable setting to use the value outside the Handler.\nfunc (c *Ctx) Params(key string, defaultValue ...string) string {\n\tif key == \"*\" || key == \"+\" {\n\t\tkey += \"1\"\n\t}\n\tfor i := range c.route.Params {\n\t\tif len(key) != len(c.route.Params[i]) {\n\t\t\tcontinue\n\t\t}\n\t\tif c.route.Params[i] == key || (!c.app.config.CaseSensitive && utils.EqualFold(c.route.Params[i], key)) {\n\t\t\t// in case values are not here\n\t\t\tif len(c.values) <= i || len(c.values[i]) == 0 {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\treturn c.values[i]\n\t\t}\n\t}\n\treturn defaultString(\"\", defaultValue)\n}\n\n// AllParams Params is used to get all route parameters.\n// Using Params method to get params.\nfunc (c *Ctx) AllParams() map[string]string {\n\tparams := make(map[string]string, len(c.route.Params))\n\tfor _, param := range c.route.Params {\n\t\tparams[param] = c.Params(param)\n\t}\n\n\treturn params\n}\n\n// ParamsParser binds the param string to a struct.\nfunc (c *Ctx) ParamsParser(out interface{}) error {\n\tparams := make(map[string][]string, len(c.route.Params))\n\tfor _, param := range c.route.Params {\n\t\tparams[param] = append(params[param], c.Params(param))\n\t}\n\treturn c.parseToStruct(paramsTag, out, params)\n}\n\n// ParamsInt is used to get an integer from the route parameters\n// it defaults to zero if the parameter is not found or if the\n// parameter cannot be converted to an integer\n// If a default value is given, it will return that value in case the param\n// doesn't exist or cannot be converted to an integer\nfunc (c *Ctx) ParamsInt(key string, defaultValue ...int) (int, error) {\n\t// Use Atoi to convert the param to an int or return zero and an error\n\tvalue, err := strconv.Atoi(c.Params(key))\n\tif err != nil {\n\t\tif len(defaultValue) > 0 {\n\t\t\treturn defaultValue[0], nil\n\t\t}\n\t\treturn 0, fmt.Errorf(\"failed to convert: %w\", err)\n\t}\n\n\treturn value, nil\n}\n\n// Path returns the path part of the request URL.\n// Optionally, you could override the path.\nfunc (c *Ctx) Path(override ...string) string {\n\tif len(override) != 0 && c.path != override[0] {\n\t\t// Set new path to context\n\t\tc.pathOriginal = override[0]\n\n\t\t// Set new path to request context\n\t\tc.fasthttp.Request.URI().SetPath(c.pathOriginal)\n\t\t// Prettify path\n\t\tc.configDependentPaths()\n\t}\n\treturn c.path\n}\n\n// Protocol contains the request protocol string: http or https for TLS requests.\n// Please use Config.EnableTrustedProxyCheck to prevent header spoofing, in case when your app is behind the proxy.\nfunc (c *Ctx) Protocol() string {\n\tif c.fasthttp.IsTLS() {\n\t\treturn schemeHTTPS\n\t}\n\tif !c.IsProxyTrusted() {\n\t\treturn schemeHTTP\n\t}\n\n\tscheme := schemeHTTP\n\tconst lenXHeaderName = 12\n\tc.fasthttp.Request.Header.VisitAll(func(key, val []byte) {\n\t\tif len(key) < lenXHeaderName {\n\t\t\treturn // Neither \"X-Forwarded-\" nor \"X-Url-Scheme\"\n\t\t}\n\t\tswitch {\n\t\tcase bytes.HasPrefix(key, []byte(\"X-Forwarded-\")):\n\t\t\tif bytes.Equal(key, []byte(HeaderXForwardedProto)) ||\n\t\t\t\tbytes.Equal(key, []byte(HeaderXForwardedProtocol)) {\n\t\t\t\tv := c.app.getString(val)\n\t\t\t\tcommaPos := strings.Index(v, \",\")\n\t\t\t\tif commaPos != -1 {\n\t\t\t\t\tscheme = v[:commaPos]\n\t\t\t\t} else {\n\t\t\t\t\tscheme = v\n\t\t\t\t}\n\t\t\t} else if bytes.Equal(key, []byte(HeaderXForwardedSsl)) && bytes.Equal(val, []byte(\"on\")) {\n\t\t\t\tscheme = schemeHTTPS\n\t\t\t}\n\n\t\tcase bytes.Equal(key, []byte(HeaderXUrlScheme)):\n\t\t\tscheme = c.app.getString(val)\n\t\t}\n\t})\n\treturn scheme\n}\n\n// Query returns the query string parameter in the url.\n// Defaults to empty string \"\" if the query doesn't exist.\n// If a default value is given, it will return that value if the query doesn't exist.\n// Returned value is only valid within the handler. Do not store any references.\n// Make copies or use the Immutable setting to use the value outside the Handler.\nfunc (c *Ctx) Query(key string, defaultValue ...string) string {\n\treturn defaultString(c.app.getString(c.fasthttp.QueryArgs().Peek(key)), defaultValue)\n}\n\n// Queries returns a map of query parameters and their values.\n//\n// GET /?name=alex&wanna_cake=2&id=\n// Queries()[\"name\"] == \"alex\"\n// Queries()[\"wanna_cake\"] == \"2\"\n// Queries()[\"id\"] == \"\"\n//\n// GET /?field1=value1&field1=value2&field2=value3\n// Queries()[\"field1\"] == \"value2\"\n// Queries()[\"field2\"] == \"value3\"\n//\n// GET /?list_a=1&list_a=2&list_a=3&list_b[]=1&list_b[]=2&list_b[]=3&list_c=1,2,3\n// Queries()[\"list_a\"] == \"3\"\n// Queries()[\"list_b[]\"] == \"3\"\n// Queries()[\"list_c\"] == \"1,2,3\"\n//\n// GET /api/search?filters.author.name=John&filters.category.name=Technology&filters[customer][name]=Alice&filters[status]=pending\n// Queries()[\"filters.author.name\"] == \"John\"\n// Queries()[\"filters.category.name\"] == \"Technology\"\n// Queries()[\"filters[customer][name]\"] == \"Alice\"\n// Queries()[\"filters[status]\"] == \"pending\"\nfunc (c *Ctx) Queries() map[string]string {\n\tm := make(map[string]string, c.Context().QueryArgs().Len())\n\tc.Context().QueryArgs().VisitAll(func(key, value []byte) {\n\t\tm[c.app.getString(key)] = c.app.getString(value)\n\t})\n\treturn m\n}\n\n// QueryInt returns integer value of key string parameter in the url.\n// Default to empty or invalid key is 0.\n//\n//\tGET /?name=alex&wanna_cake=2&id=\n//\tQueryInt(\"wanna_cake\", 1) == 2\n//\tQueryInt(\"name\", 1) == 1\n//\tQueryInt(\"id\", 1) == 1\n//\tQueryInt(\"id\") == 0\nfunc (c *Ctx) QueryInt(key string, defaultValue ...int) int {\n\t// Use Atoi to convert the param to an int or return zero and an error\n\tvalue, err := strconv.Atoi(c.app.getString(c.fasthttp.QueryArgs().Peek(key)))\n\tif err != nil {\n\t\tif len(defaultValue) > 0 {\n\t\t\treturn defaultValue[0]\n\t\t}\n\t\treturn 0\n\t}\n\n\treturn value\n}\n\n// QueryBool returns bool value of key string parameter in the url.\n// Default to empty or invalid key is true.\n//\n//\tGet /?name=alex&want_pizza=false&id=\n//\tQueryBool(\"want_pizza\") == false\n//\tQueryBool(\"want_pizza\", true) == false\n//\tQueryBool(\"name\") == false\n//\tQueryBool(\"name\", true) == true\n//\tQueryBool(\"id\") == false\n//\tQueryBool(\"id\", true) == true\nfunc (c *Ctx) QueryBool(key string, defaultValue ...bool) bool {\n\tvalue, err := strconv.ParseBool(c.app.getString(c.fasthttp.QueryArgs().Peek(key)))\n\tif err != nil {\n\t\tif len(defaultValue) > 0 {\n\t\t\treturn defaultValue[0]\n\t\t}\n\t\treturn false\n\t}\n\treturn value\n}\n\n// QueryFloat returns float64 value of key string parameter in the url.\n// Default to empty or invalid key is 0.\n//\n//\tGET /?name=alex&amount=32.23&id=\n//\tQueryFloat(\"amount\") = 32.23\n//\tQueryFloat(\"amount\", 3) = 32.23\n//\tQueryFloat(\"name\", 1) = 1\n//\tQueryFloat(\"name\") = 0\n//\tQueryFloat(\"id\", 3) = 3\nfunc (c *Ctx) QueryFloat(key string, defaultValue ...float64) float64 {\n\t// use strconv.ParseFloat to convert the param to a float or return zero and an error.\n\tvalue, err := strconv.ParseFloat(c.app.getString(c.fasthttp.QueryArgs().Peek(key)), 64)\n\tif err != nil {\n\t\tif len(defaultValue) > 0 {\n\t\t\treturn defaultValue[0]\n\t\t}\n\t\treturn 0\n\t}\n\treturn value\n}\n\n// QueryParser binds the query string to a struct.\nfunc (c *Ctx) QueryParser(out interface{}) error {\n\tdata := make(map[string][]string)\n\tvar err error\n\n\tc.fasthttp.QueryArgs().VisitAll(func(key, val []byte) {\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\n\t\tk := c.app.getString(key)\n\t\tv := c.app.getString(val)\n\n\t\tif strings.Contains(k, \"[\") {\n\t\t\tk, err = parseParamSquareBrackets(k)\n\t\t}\n\n\t\tif c.app.config.EnableSplittingOnParsers && strings.Contains(v, \",\") && equalFieldType(out, reflect.Slice, k) {\n\t\t\tvalues := strings.Split(v, \",\")\n\t\t\tfor i := 0; i < len(values); i++ {\n\t\t\t\tdata[k] = append(data[k], values[i])\n\t\t\t}\n\t\t} else {\n\t\t\tdata[k] = append(data[k], v)\n\t\t}\n\t})\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn c.parseToStruct(queryTag, out, data)\n}\n\nfunc parseParamSquareBrackets(k string) (string, error) {\n\tbb := bytebufferpool.Get()\n\tdefer bytebufferpool.Put(bb)\n\n\tkbytes := []byte(k)\n\n\tfor i, b := range kbytes {\n\t\tif b == '[' && kbytes[i+1] != ']' {\n\t\t\tif err := bb.WriteByte('.'); err != nil {\n\t\t\t\treturn \"\", fmt.Errorf(\"failed to write: %w\", err)\n\t\t\t}\n\t\t}\n\n\t\tif b == '[' || b == ']' {\n\t\t\tcontinue\n\t\t}\n\n\t\tif err := bb.WriteByte(b); err != nil {\n\t\t\treturn \"\", fmt.Errorf(\"failed to write: %w\", err)\n\t\t}\n\t}\n\n\treturn bb.String(), nil\n}\n\n// ReqHeaderParser binds the request header strings to a struct.\nfunc (c *Ctx) ReqHeaderParser(out interface{}) error {\n\tdata := make(map[string][]string)\n\tc.fasthttp.Request.Header.VisitAll(func(key, val []byte) {\n\t\tk := c.app.getString(key)\n\t\tv := c.app.getString(val)\n\n\t\tif c.app.config.EnableSplittingOnParsers && strings.Contains(v, \",\") && equalFieldType(out, reflect.Slice, k) {\n\t\t\tvalues := strings.Split(v, \",\")\n\t\t\tfor i := 0; i < len(values); i++ {\n\t\t\t\tdata[k] = append(data[k], values[i])\n\t\t\t}\n\t\t} else {\n\t\t\tdata[k] = append(data[k], v)\n\t\t}\n\t})\n\n\treturn c.parseToStruct(reqHeaderTag, out, data)\n}\n\nfunc (*Ctx) parseToStruct(aliasTag string, out interface{}, data map[string][]string) error {\n\t// Get decoder from pool\n\tschemaDecoder, ok := decoderPoolMap[aliasTag].Get().(*schema.Decoder)\n\tif !ok {\n\t\tpanic(fmt.Errorf(\"failed to type-assert to *schema.Decoder\"))\n\t}\n\tdefer decoderPoolMap[aliasTag].Put(schemaDecoder)\n\n\t// Set alias tag\n\tschemaDecoder.SetAliasTag(aliasTag)\n\n\tif err := schemaDecoder.Decode(out, data); err != nil {\n\t\treturn fmt.Errorf(\"failed to decode: %w\", err)\n\t}\n\n\treturn nil\n}\n\nfunc equalFieldType(out interface{}, kind reflect.Kind, key string) bool {\n\t// Get type of interface\n\toutTyp := reflect.TypeOf(out).Elem()\n\tkey = utils.ToLower(key)\n\t// Must be a struct to match a field\n\tif outTyp.Kind() != reflect.Struct {\n\t\treturn false\n\t}\n\t// Copy interface to an value to be used\n\toutVal := reflect.ValueOf(out).Elem()\n\t// Loop over each field\n\tfor i := 0; i < outTyp.NumField(); i++ {\n\t\t// Get field value data\n\t\tstructField := outVal.Field(i)\n\t\t// Can this field be changed?\n\t\tif !structField.CanSet() {\n\t\t\tcontinue\n\t\t}\n\t\t// Get field key data\n\t\ttypeField := outTyp.Field(i)\n\t\t// Get type of field key\n\t\tstructFieldKind := structField.Kind()\n\t\t// Does the field type equals input?\n\t\tif structFieldKind != kind {\n\t\t\tcontinue\n\t\t}\n\t\t// Get tag from field if exist\n\t\tinputFieldName := typeField.Tag.Get(queryTag)\n\t\tif inputFieldName == \"\" {\n\t\t\tinputFieldName = typeField.Name\n\t\t} else {\n\t\t\tinputFieldName = strings.Split(inputFieldName, \",\")[0]\n\t\t}\n\t\t// Compare field/tag with provided key\n\t\tif utils.ToLower(inputFieldName) == key {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nvar (\n\tErrRangeMalformed     = errors.New(\"range: malformed range header string\")\n\tErrRangeUnsatisfiable = errors.New(\"range: unsatisfiable range\")\n)\n\n// Range returns a struct containing the type and a slice of ranges.\nfunc (c *Ctx) Range(size int) (Range, error) {\n\tvar rangeData Range\n\trangeStr := c.Get(HeaderRange)\n\tif rangeStr == \"\" || !strings.Contains(rangeStr, \"=\") {\n\t\treturn rangeData, ErrRangeMalformed\n\t}\n\tdata := strings.Split(rangeStr, \"=\")\n\tconst expectedDataParts = 2\n\tif len(data) != expectedDataParts {\n\t\treturn rangeData, ErrRangeMalformed\n\t}\n\trangeData.Type = data[0]\n\tarr := strings.Split(data[1], \",\")\n\tfor i := 0; i < len(arr); i++ {\n\t\titem := strings.Split(arr[i], \"-\")\n\t\tif len(item) == 1 {\n\t\t\treturn rangeData, ErrRangeMalformed\n\t\t}\n\t\tstart, startErr := strconv.Atoi(item[0])\n\t\tend, endErr := strconv.Atoi(item[1])\n\t\tif startErr != nil { // -nnn\n\t\t\tstart = size - end\n\t\t\tend = size - 1\n\t\t} else if endErr != nil { // nnn-\n\t\t\tend = size - 1\n\t\t}\n\t\tif end > size-1 { // limit last-byte-pos to current length\n\t\t\tend = size - 1\n\t\t}\n\t\tif start > end || start < 0 {\n\t\t\tcontinue\n\t\t}\n\t\trangeData.Ranges = append(rangeData.Ranges, struct {\n\t\t\tStart int\n\t\t\tEnd   int\n\t\t}{\n\t\t\tstart,\n\t\t\tend,\n\t\t})\n\t}\n\tif len(rangeData.Ranges) < 1 {\n\t\treturn rangeData, ErrRangeUnsatisfiable\n\t}\n\n\treturn rangeData, nil\n}\n\n// Redirect to the URL derived from the specified path, with specified status.\n// If status is not specified, status defaults to 302 Found.\nfunc (c *Ctx) Redirect(location string, status ...int) error {\n\tc.setCanonical(HeaderLocation, location)\n\tif len(status) > 0 {\n\t\tc.Status(status[0])\n\t} else {\n\t\tc.Status(StatusFound)\n\t}\n\treturn nil\n}\n\n// Bind Add vars to default view var map binding to template engine.\n// Variables are read by the Render method and may be overwritten.\nfunc (c *Ctx) Bind(vars Map) error {\n\t// init viewBindMap - lazy map\n\tfor k, v := range vars {\n\t\tc.viewBindMap.Store(k, v)\n\t}\n\treturn nil\n}\n\n// getLocationFromRoute get URL location from route using parameters\nfunc (c *Ctx) getLocationFromRoute(route Route, params Map) (string, error) {\n\tbuf := bytebufferpool.Get()\n\tfor _, segment := range route.routeParser.segs {\n\t\tif !segment.IsParam {\n\t\t\t_, err := buf.WriteString(segment.Const)\n\t\t\tif err != nil {\n\t\t\t\treturn \"\", fmt.Errorf(\"failed to write string: %w\", err)\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\n\t\tfor key, val := range params {\n\t\t\tisSame := key == segment.ParamName || (!c.app.config.CaseSensitive && utils.EqualFold(key, segment.ParamName))\n\t\t\tisGreedy := segment.IsGreedy && len(key) == 1 && isInCharset(key[0], greedyParameters)\n\t\t\tif isSame || isGreedy {\n\t\t\t\t_, err := buf.WriteString(utils.ToString(val))\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn \"\", fmt.Errorf(\"failed to write string: %w\", err)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tlocation := buf.String()\n\t// release buffer\n\tbytebufferpool.Put(buf)\n\treturn location, nil\n}\n\n// GetRouteURL generates URLs to named routes, with parameters. URLs are relative, for example: \"/user/1831\"\nfunc (c *Ctx) GetRouteURL(routeName string, params Map) (string, error) {\n\treturn c.getLocationFromRoute(c.App().GetRoute(routeName), params)\n}\n\n// RedirectToRoute to the Route registered in the app with appropriate parameters\n// If status is not specified, status defaults to 302 Found.\n// If you want to send queries to route, you must add \"queries\" key typed as map[string]string to params.\nfunc (c *Ctx) RedirectToRoute(routeName string, params Map, status ...int) error {\n\tlocation, err := c.getLocationFromRoute(c.App().GetRoute(routeName), params)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Check queries\n\tif queries, ok := params[\"queries\"].(map[string]string); ok {\n\t\tqueryText := bytebufferpool.Get()\n\t\tdefer bytebufferpool.Put(queryText)\n\n\t\ti := 1\n\t\tfor k, v := range queries {\n\t\t\t_, _ = queryText.WriteString(k + \"=\" + v) //nolint:errcheck // This will never fail\n\n\t\t\tif i != len(queries) {\n\t\t\t\t_, _ = queryText.WriteString(\"&\") //nolint:errcheck // This will never fail\n\t\t\t}\n\t\t\ti++\n\t\t}\n\n\t\treturn c.Redirect(location+\"?\"+queryText.String(), status...)\n\t}\n\treturn c.Redirect(location, status...)\n}\n\n// RedirectBack to the URL to referer\n// If status is not specified, status defaults to 302 Found.\nfunc (c *Ctx) RedirectBack(fallback string, status ...int) error {\n\tlocation := c.Get(HeaderReferer)\n\tif location == \"\" {\n\t\tlocation = fallback\n\t}\n\treturn c.Redirect(location, status...)\n}\n\n// Render a template with data and sends a text/html response.\n// We support the following engines: html, amber, handlebars, mustache, pug\nfunc (c *Ctx) Render(name string, bind interface{}, layouts ...string) error {\n\t// Get new buffer from pool\n\tbuf := bytebufferpool.Get()\n\tdefer bytebufferpool.Put(buf)\n\n\t// Pass-locals-to-views, bind, appListKeys\n\tc.renderExtensions(bind)\n\n\tvar rendered bool\n\tfor i := len(c.app.mountFields.appListKeys) - 1; i >= 0; i-- {\n\t\tprefix := c.app.mountFields.appListKeys[i]\n\t\tapp := c.app.mountFields.appList[prefix]\n\t\tif prefix == \"\" || strings.Contains(c.OriginalURL(), prefix) {\n\t\t\tif len(layouts) == 0 && app.config.ViewsLayout != \"\" {\n\t\t\t\tlayouts = []string{\n\t\t\t\t\tapp.config.ViewsLayout,\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Render template from Views\n\t\t\tif app.config.Views != nil {\n\t\t\t\tif err := app.config.Views.Render(buf, name, bind, layouts...); err != nil {\n\t\t\t\t\treturn fmt.Errorf(\"failed to render: %w\", err)\n\t\t\t\t}\n\n\t\t\t\trendered = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\tif !rendered {\n\t\t// Render raw template using 'name' as filepath if no engine is set\n\t\tvar tmpl *template.Template\n\t\tif _, err := readContent(buf, name); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Parse template\n\t\ttmpl, err := template.New(\"\").Parse(c.app.getString(buf.Bytes()))\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"failed to parse: %w\", err)\n\t\t}\n\t\tbuf.Reset()\n\t\t// Render template\n\t\tif err := tmpl.Execute(buf, bind); err != nil {\n\t\t\treturn fmt.Errorf(\"failed to execute: %w\", err)\n\t\t}\n\t}\n\n\t// Set Content-Type to text/html\n\tc.fasthttp.Response.Header.SetContentType(MIMETextHTMLCharsetUTF8)\n\t// Set rendered template to body\n\tc.fasthttp.Response.SetBody(buf.Bytes())\n\n\treturn nil\n}\n\nfunc (c *Ctx) renderExtensions(bind interface{}) {\n\tif bindMap, ok := bind.(Map); ok {\n\t\t// Bind view map\n\t\tc.viewBindMap.Range(func(key, value interface{}) bool {\n\t\t\tkeyValue, ok := key.(string)\n\t\t\tif !ok {\n\t\t\t\treturn true\n\t\t\t}\n\t\t\tif _, ok := bindMap[keyValue]; !ok {\n\t\t\t\tbindMap[keyValue] = value\n\t\t\t}\n\t\t\treturn true\n\t\t})\n\n\t\t// Check if the PassLocalsToViews option is enabled (by default it is disabled)\n\t\tif c.app.config.PassLocalsToViews {\n\t\t\t// Loop through each local and set it in the map\n\t\t\tc.fasthttp.VisitUserValues(func(key []byte, val interface{}) {\n\t\t\t\t// check if bindMap doesn't contain the key\n\t\t\t\tif _, ok := bindMap[c.app.getString(key)]; !ok {\n\t\t\t\t\t// Set the key and value in the bindMap\n\t\t\t\t\tbindMap[c.app.getString(key)] = val\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t}\n\n\tif len(c.app.mountFields.appListKeys) == 0 {\n\t\tc.app.generateAppListKeys()\n\t}\n}\n\n// Route returns the matched Route struct.\nfunc (c *Ctx) Route() *Route {\n\tif c.route == nil {\n\t\t// Fallback for fasthttp error handler\n\t\treturn &Route{\n\t\t\tpath:     c.pathOriginal,\n\t\t\tPath:     c.pathOriginal,\n\t\t\tMethod:   c.method,\n\t\t\tHandlers: make([]Handler, 0),\n\t\t\tParams:   make([]string, 0),\n\t\t}\n\t}\n\treturn c.route\n}\n\n// SaveFile saves any multipart file to disk.\nfunc (*Ctx) SaveFile(fileheader *multipart.FileHeader, path string) error {\n\treturn fasthttp.SaveMultipartFile(fileheader, path)\n}\n\n// SaveFileToStorage saves any multipart file to an external storage system.\nfunc (*Ctx) SaveFileToStorage(fileheader *multipart.FileHeader, path string, storage Storage) error {\n\tfile, err := fileheader.Open()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to open: %w\", err)\n\t}\n\n\tcontent, err := io.ReadAll(file)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to read: %w\", err)\n\t}\n\n\tif err := storage.Set(path, content, 0); err != nil {\n\t\treturn fmt.Errorf(\"failed to store: %w\", err)\n\t}\n\n\treturn nil\n}\n\n// Secure returns whether a secure connection was established.\nfunc (c *Ctx) Secure() bool {\n\treturn c.Protocol() == schemeHTTPS\n}\n\n// Send sets the HTTP response body without copying it.\n// From this point onward the body argument must not be changed.\nfunc (c *Ctx) Send(body []byte) error {\n\t// Write response body\n\tc.fasthttp.Response.SetBodyRaw(body)\n\treturn nil\n}\n\nvar (\n\tsendFileOnce    sync.Once\n\tsendFileFS      *fasthttp.FS\n\tsendFileHandler fasthttp.RequestHandler\n)\n\n// SendFile transfers the file from the given path.\n// The file is not compressed by default, enable this by passing a 'true' argument\n// Sets the Content-Type response HTTP header field based on the filenames extension.\nfunc (c *Ctx) SendFile(file string, compress ...bool) error {\n\t// Save the filename, we will need it in the error message if the file isn't found\n\tfilename := file\n\n\t// https://github.com/valyala/fasthttp/blob/c7576cc10cabfc9c993317a2d3f8355497bea156/fs.go#L129-L134\n\tsendFileOnce.Do(func() {\n\t\tconst cacheDuration = 10 * time.Second\n\t\tsendFileFS = &fasthttp.FS{\n\t\t\tRoot:                 \"\",\n\t\t\tAllowEmptyRoot:       true,\n\t\t\tGenerateIndexPages:   false,\n\t\t\tAcceptByteRange:      true,\n\t\t\tCompress:             true,\n\t\t\tCompressedFileSuffix: c.app.config.CompressedFileSuffix,\n\t\t\tCacheDuration:        cacheDuration,\n\t\t\tIndexNames:           []string{\"index.html\"},\n\t\t\tPathNotFound: func(ctx *fasthttp.RequestCtx) {\n\t\t\t\tctx.Response.SetStatusCode(StatusNotFound)\n\t\t\t},\n\t\t}\n\t\tsendFileHandler = sendFileFS.NewRequestHandler()\n\t})\n\n\t// Keep original path for mutable params\n\tc.pathOriginal = utils.CopyString(c.pathOriginal)\n\t// Disable compression\n\tif len(compress) == 0 || !compress[0] {\n\t\t// https://github.com/valyala/fasthttp/blob/7cc6f4c513f9e0d3686142e0a1a5aa2f76b3194a/fs.go#L55\n\t\tc.fasthttp.Request.Header.Del(HeaderAcceptEncoding)\n\t}\n\t// copy of https://github.com/valyala/fasthttp/blob/7cc6f4c513f9e0d3686142e0a1a5aa2f76b3194a/fs.go#L103-L121 with small adjustments\n\tif len(file) == 0 || !filepath.IsAbs(file) {\n\t\t// extend relative path to absolute path\n\t\thasTrailingSlash := len(file) > 0 && (file[len(file)-1] == '/' || file[len(file)-1] == '\\\\')\n\n\t\tvar err error\n\t\tfile = filepath.FromSlash(file)\n\t\tif file, err = filepath.Abs(file); err != nil {\n\t\t\treturn fmt.Errorf(\"failed to determine abs file path: %w\", err)\n\t\t}\n\t\tif hasTrailingSlash {\n\t\t\tfile += \"/\"\n\t\t}\n\t}\n\t// convert the path to forward slashes regardless the OS in order to set the URI properly\n\t// the handler will convert back to OS path separator before opening the file\n\tfile = filepath.ToSlash(file)\n\n\t// Restore the original requested URL\n\toriginalURL := utils.CopyString(c.OriginalURL())\n\tdefer c.fasthttp.Request.SetRequestURI(originalURL)\n\t// Set new URI for fileHandler\n\tc.fasthttp.Request.SetRequestURI(file)\n\t// Save status code\n\tstatus := c.fasthttp.Response.StatusCode()\n\t// Serve file\n\tsendFileHandler(c.fasthttp)\n\t// Get the status code which is set by fasthttp\n\tfsStatus := c.fasthttp.Response.StatusCode()\n\t// Set the status code set by the user if it is different from the fasthttp status code and 200\n\tif status != fsStatus && status != StatusOK {\n\t\tc.Status(status)\n\t}\n\t// Check for error\n\tif status != StatusNotFound && fsStatus == StatusNotFound {\n\t\treturn NewError(StatusNotFound, fmt.Sprintf(\"sendfile: file %s not found\", filename))\n\t}\n\treturn nil\n}\n\n// SendStatus sets the HTTP status code and if the response body is empty,\n// it sets the correct status message in the body.\nfunc (c *Ctx) SendStatus(status int) error {\n\tc.Status(status)\n\n\t// Only set status body when there is no response body\n\tif len(c.fasthttp.Response.Body()) == 0 {\n\t\treturn c.SendString(utils.StatusMessage(status))\n\t}\n\n\treturn nil\n}\n\n// SendString sets the HTTP response body for string types.\n// This means no type assertion, recommended for faster performance\nfunc (c *Ctx) SendString(body string) error {\n\tc.fasthttp.Response.SetBodyString(body)\n\n\treturn nil\n}\n\n// SendStream sets response body stream and optional body size.\nfunc (c *Ctx) SendStream(stream io.Reader, size ...int) error {\n\tif len(size) > 0 && size[0] >= 0 {\n\t\tc.fasthttp.Response.SetBodyStream(stream, size[0])\n\t} else {\n\t\tc.fasthttp.Response.SetBodyStream(stream, -1)\n\t}\n\n\treturn nil\n}\n\n// Set sets the response's HTTP header field to the specified key, value.\nfunc (c *Ctx) Set(key, val string) {\n\tc.fasthttp.Response.Header.Set(key, val)\n}\n\nfunc (c *Ctx) setCanonical(key, val string) {\n\tc.fasthttp.Response.Header.SetCanonical(c.app.getBytes(key), c.app.getBytes(val))\n}\n\n// Subdomains returns a string slice of subdomains in the domain name of the request.\n// The subdomain offset, which defaults to 2, is used for determining the beginning of the subdomain segments.\nfunc (c *Ctx) Subdomains(offset ...int) []string {\n\to := 2\n\tif len(offset) > 0 {\n\t\to = offset[0]\n\t}\n\tsubdomains := strings.Split(c.Hostname(), \".\")\n\tl := len(subdomains) - o\n\t// Check index to avoid slice bounds out of range panic\n\tif l < 0 {\n\t\tl = len(subdomains)\n\t}\n\tsubdomains = subdomains[:l]\n\treturn subdomains\n}\n\n// Stale is not implemented yet, pull requests are welcome!\nfunc (c *Ctx) Stale() bool {\n\treturn !c.Fresh()\n}\n\n// Status sets the HTTP status for the response.\n// This method is chainable.\nfunc (c *Ctx) Status(status int) *Ctx {\n\tc.fasthttp.Response.SetStatusCode(status)\n\treturn c\n}\n\n// String returns unique string representation of the ctx.\n//\n// The returned value may be useful for logging.\nfunc (c *Ctx) String() string {\n\treturn fmt.Sprintf(\n\t\t\"#%016X - %s <-> %s - %s %s\",\n\t\tc.fasthttp.ID(),\n\t\tc.fasthttp.LocalAddr(),\n\t\tc.fasthttp.RemoteAddr(),\n\t\tc.fasthttp.Request.Header.Method(),\n\t\tc.fasthttp.URI().FullURI(),\n\t)\n}\n\n// Type sets the Content-Type HTTP header to the MIME type specified by the file extension.\nfunc (c *Ctx) Type(extension string, charset ...string) *Ctx {\n\tif len(charset) > 0 {\n\t\tc.fasthttp.Response.Header.SetContentType(utils.GetMIME(extension) + \"; charset=\" + charset[0])\n\t} else {\n\t\tc.fasthttp.Response.Header.SetContentType(utils.GetMIME(extension))\n\t}\n\treturn c\n}\n\n// Vary adds the given header field to the Vary response header.\n// This will append the header, if not already listed, otherwise leaves it listed in the current location.\nfunc (c *Ctx) Vary(fields ...string) {\n\tc.Append(HeaderVary, fields...)\n}\n\n// Write appends p into response body.\nfunc (c *Ctx) Write(p []byte) (int, error) {\n\tc.fasthttp.Response.AppendBody(p)\n\treturn len(p), nil\n}\n\n// Writef appends f & a into response body writer.\nfunc (c *Ctx) Writef(f string, a ...interface{}) (int, error) {\n\t//nolint:wrapcheck // This must not be wrapped\n\treturn fmt.Fprintf(c.fasthttp.Response.BodyWriter(), f, a...)\n}\n\n// WriteString appends s to response body.\nfunc (c *Ctx) WriteString(s string) (int, error) {\n\tc.fasthttp.Response.AppendBodyString(s)\n\treturn len(s), nil\n}\n\n// XHR returns a Boolean property, that is true, if the request's X-Requested-With header field is XMLHttpRequest,\n// indicating that the request was issued by a client library (such as jQuery).\nfunc (c *Ctx) XHR() bool {\n\treturn utils.EqualFoldBytes(c.app.getBytes(c.Get(HeaderXRequestedWith)), []byte(\"xmlhttprequest\"))\n}\n\n// configDependentPaths set paths for route recognition and prepared paths for the user,\n// here the features for caseSensitive, decoded paths, strict paths are evaluated\nfunc (c *Ctx) configDependentPaths() {\n\tc.pathBuffer = append(c.pathBuffer[0:0], c.pathOriginal...)\n\t// If UnescapePath enabled, we decode the path and save it for the framework user\n\tif c.app.config.UnescapePath {\n\t\tc.pathBuffer = fasthttp.AppendUnquotedArg(c.pathBuffer[:0], c.pathBuffer)\n\t}\n\tc.path = c.app.getString(c.pathBuffer)\n\n\t// another path is specified which is for routing recognition only\n\t// use the path that was changed by the previous configuration flags\n\tc.detectionPathBuffer = append(c.detectionPathBuffer[0:0], c.pathBuffer...)\n\t// If CaseSensitive is disabled, we lowercase the original path\n\tif !c.app.config.CaseSensitive {\n\t\tc.detectionPathBuffer = utils.ToLowerBytes(c.detectionPathBuffer)\n\t}\n\t// If StrictRouting is disabled, we strip all trailing slashes\n\tif !c.app.config.StrictRouting && len(c.detectionPathBuffer) > 1 && c.detectionPathBuffer[len(c.detectionPathBuffer)-1] == '/' {\n\t\tc.detectionPathBuffer = utils.TrimRightBytes(c.detectionPathBuffer, '/')\n\t}\n\tc.detectionPath = c.app.getString(c.detectionPathBuffer)\n\n\t// Define the path for dividing routes into areas for fast tree detection, so that fewer routes need to be traversed,\n\t// since the first three characters area select a list of routes\n\tc.treePath = c.treePath[0:0]\n\tconst maxDetectionPaths = 3\n\tif len(c.detectionPath) >= maxDetectionPaths {\n\t\tc.treePath = c.detectionPath[:maxDetectionPaths]\n\t}\n}\n\nfunc (c *Ctx) IsProxyTrusted() bool {\n\tif !c.app.config.EnableTrustedProxyCheck {\n\t\treturn true\n\t}\n\n\tip := c.fasthttp.RemoteIP()\n\n\tif _, trusted := c.app.config.trustedProxiesMap[ip.String()]; trusted {\n\t\treturn true\n\t}\n\n\tfor _, ipNet := range c.app.config.trustedProxyRanges {\n\t\tif ipNet.Contains(ip) {\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}\n\nvar localHosts = [...]string{\"127.0.0.1\", \"0.0.0.0\", \"::1\"}\n\n// IsLocalHost will return true if address is a localhost address.\nfunc (*Ctx) isLocalHost(address string) bool {\n\tfor _, h := range localHosts {\n\t\tif strings.Contains(address, h) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// IsFromLocal will return true if request came from local.\nfunc (c *Ctx) IsFromLocal() bool {\n\tips := c.IPs()\n\tif len(ips) == 0 {\n\t\tips = append(ips, c.IP())\n\t}\n\treturn c.isLocalHost(ips[0])\n}\n", "// \u26a1\ufe0f Fiber is an Express inspired web framework written in Go with \u2615\ufe0f\n// \ud83e\udd16 Github Repository: https://github.com/gofiber/fiber\n// \ud83d\udccc API Documentation: https://docs.gofiber.io\n\n//nolint:bodyclose // Much easier to just ignore memory leaks in tests\npackage fiber\n\nimport (\n\t\"bufio\"\n\t\"bytes\"\n\t\"compress/gzip\"\n\t\"compress/zlib\"\n\t\"context\"\n\t\"crypto/tls\"\n\t\"encoding/xml\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"mime/multipart\"\n\t\"net/http/httptest\"\n\t\"net/url\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"reflect\"\n\t\"strconv\"\n\t\"strings\"\n\t\"testing\"\n\t\"text/template\"\n\t\"time\"\n\n\t\"github.com/gofiber/fiber/v2/internal/storage/memory\"\n\t\"github.com/gofiber/fiber/v2/utils\"\n\n\t\"github.com/valyala/bytebufferpool\"\n\t\"github.com/valyala/fasthttp\"\n)\n\n// go test -run Test_Ctx_Accepts\nfunc Test_Ctx_Accepts(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tc.Request().Header.Set(HeaderAccept, \"text/html,application/xhtml+xml,application/xml;q=0.9\")\n\tutils.AssertEqual(t, \"\", c.Accepts(\"\"))\n\tutils.AssertEqual(t, \"\", c.Accepts())\n\tutils.AssertEqual(t, \".xml\", c.Accepts(\".xml\"))\n\tutils.AssertEqual(t, \"\", c.Accepts(\".john\"))\n\tutils.AssertEqual(t, \"application/xhtml+xml\", c.Accepts(\"application/xml\", \"application/xml+rss\", \"application/yaml\", \"application/xhtml+xml\"), \"must use client-preferred mime type\")\n\n\tc.Request().Header.Set(HeaderAccept, \"application/json, text/plain, */*;q=0\")\n\tutils.AssertEqual(t, \"\", c.Accepts(\"html\"), \"must treat */*;q=0 as not acceptable\")\n\n\tc.Request().Header.Set(HeaderAccept, \"text/*, application/json\")\n\tutils.AssertEqual(t, \"html\", c.Accepts(\"html\"))\n\tutils.AssertEqual(t, \"text/html\", c.Accepts(\"text/html\"))\n\tutils.AssertEqual(t, \"json\", c.Accepts(\"json\", \"text\"))\n\tutils.AssertEqual(t, \"application/json\", c.Accepts(\"application/json\"))\n\tutils.AssertEqual(t, \"\", c.Accepts(\"image/png\"))\n\tutils.AssertEqual(t, \"\", c.Accepts(\"png\"))\n\n\tc.Request().Header.Set(HeaderAccept, \"text/html, application/json\")\n\tutils.AssertEqual(t, \"text/*\", c.Accepts(\"text/*\"))\n\n\tc.Request().Header.Set(HeaderAccept, \"*/*\")\n\tutils.AssertEqual(t, \"html\", c.Accepts(\"html\"))\n}\n\n// go test -v -run=^$ -bench=Benchmark_Ctx_Accepts -benchmem -count=4\nfunc Benchmark_Ctx_Accepts(b *testing.B) {\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tacceptHeader := \"text/html,application/xhtml+xml,application/xml;q=0.9\"\n\tc.Request().Header.Set(\"Accept\", acceptHeader)\n\tacceptValues := [][]string{\n\t\t{\".xml\"},\n\t\t{\"json\", \"xml\"},\n\t\t{\"application/json\", \"application/xml\"},\n\t}\n\texpectedResults := []string{\".xml\", \"xml\", \"application/xml\"}\n\n\tfor i := 0; i < len(acceptValues); i++ {\n\t\tb.Run(fmt.Sprintf(\"run-%#v\", acceptValues[i]), func(bb *testing.B) {\n\t\t\tvar res string\n\t\t\tbb.ReportAllocs()\n\t\t\tbb.ResetTimer()\n\n\t\t\tfor n := 0; n < bb.N; n++ {\n\t\t\t\tres = c.Accepts(acceptValues[i]...)\n\t\t\t}\n\t\t\tutils.AssertEqual(bb, expectedResults[i], res)\n\t\t})\n\t}\n}\n\n// go test -run Test_Ctx_Accepts_EmptyAccept\nfunc Test_Ctx_Accepts_EmptyAccept(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tutils.AssertEqual(t, \".forwarded\", c.Accepts(\".forwarded\"))\n}\n\n// go test -run Test_Ctx_Accepts_Wildcard\nfunc Test_Ctx_Accepts_Wildcard(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tc.Request().Header.Set(HeaderAccept, \"*/*;q=0.9\")\n\tutils.AssertEqual(t, \"html\", c.Accepts(\"html\"))\n\tutils.AssertEqual(t, \"foo\", c.Accepts(\"foo\"))\n\tutils.AssertEqual(t, \".bar\", c.Accepts(\".bar\"))\n\tc.Request().Header.Set(HeaderAccept, \"text/html,application/*;q=0.9\")\n\tutils.AssertEqual(t, \"xml\", c.Accepts(\"xml\"))\n}\n\n// go test -run Test_Ctx_AcceptsCharsets\nfunc Test_Ctx_AcceptsCharsets(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tc.Request().Header.Set(HeaderAcceptCharset, \"utf-8, iso-8859-1;q=0.5\")\n\tutils.AssertEqual(t, \"utf-8\", c.AcceptsCharsets(\"utf-8\"))\n}\n\n// go test -v -run=^$ -bench=Benchmark_Ctx_AcceptsCharsets -benchmem -count=4\nfunc Benchmark_Ctx_AcceptsCharsets(b *testing.B) {\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tc.Request().Header.Set(\"Accept-Charset\", \"utf-8, iso-8859-1;q=0.5\")\n\tvar res string\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\tres = c.AcceptsCharsets(\"utf-8\")\n\t}\n\tutils.AssertEqual(b, \"utf-8\", res)\n}\n\n// go test -run Test_Ctx_AcceptsEncodings\nfunc Test_Ctx_AcceptsEncodings(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tc.Request().Header.Set(HeaderAcceptEncoding, \"deflate, gzip;q=1.0, *;q=0.5\")\n\tutils.AssertEqual(t, \"gzip\", c.AcceptsEncodings(\"gzip\"))\n\tutils.AssertEqual(t, \"abc\", c.AcceptsEncodings(\"abc\"))\n}\n\n// go test -v -run=^$ -bench=Benchmark_Ctx_AcceptsEncodings -benchmem -count=4\nfunc Benchmark_Ctx_AcceptsEncodings(b *testing.B) {\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tc.Request().Header.Set(HeaderAcceptEncoding, \"deflate, gzip;q=1.0, *;q=0.5\")\n\tvar res string\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\tres = c.AcceptsEncodings(\"gzip\")\n\t}\n\tutils.AssertEqual(b, \"gzip\", res)\n}\n\n// go test -run Test_Ctx_AcceptsLanguages\nfunc Test_Ctx_AcceptsLanguages(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tc.Request().Header.Set(HeaderAcceptLanguage, \"fr-CH, fr;q=0.9, en;q=0.8, de;q=0.7, *;q=0.5\")\n\tutils.AssertEqual(t, \"fr\", c.AcceptsLanguages(\"fr\"))\n}\n\n// go test -v -run=^$ -bench=Benchmark_Ctx_AcceptsLanguages -benchmem -count=4\nfunc Benchmark_Ctx_AcceptsLanguages(b *testing.B) {\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tc.Request().Header.Set(HeaderAcceptLanguage, \"fr-CH, fr;q=0.9, en;q=0.8, de;q=0.7, *;q=0.5\")\n\tvar res string\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\tres = c.AcceptsLanguages(\"fr\")\n\t}\n\tutils.AssertEqual(b, \"fr\", res)\n}\n\n// go test -run Test_Ctx_App\nfunc Test_Ctx_App(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tapp.config.BodyLimit = 1000\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tutils.AssertEqual(t, 1000, c.App().config.BodyLimit)\n}\n\n// go test -run Test_Ctx_Append\nfunc Test_Ctx_Append(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tc.Append(\"X-Test\", \"Hello\")\n\tc.Append(\"X-Test\", \"World\")\n\tc.Append(\"X-Test\", \"Hello\", \"World\")\n\t// similar value in the middle\n\tc.Append(\"X2-Test\", \"World\")\n\tc.Append(\"X2-Test\", \"XHello\")\n\tc.Append(\"X2-Test\", \"Hello\", \"World\")\n\t// similar value at the start\n\tc.Append(\"X3-Test\", \"XHello\")\n\tc.Append(\"X3-Test\", \"World\")\n\tc.Append(\"X3-Test\", \"Hello\", \"World\")\n\t// try it with multiple similar values\n\tc.Append(\"X4-Test\", \"XHello\")\n\tc.Append(\"X4-Test\", \"Hello\")\n\tc.Append(\"X4-Test\", \"HelloZ\")\n\tc.Append(\"X4-Test\", \"YHello\")\n\tc.Append(\"X4-Test\", \"Hello\")\n\tc.Append(\"X4-Test\", \"YHello\")\n\tc.Append(\"X4-Test\", \"HelloZ\")\n\tc.Append(\"X4-Test\", \"XHello\")\n\t// without append value\n\tc.Append(\"X-Custom-Header\")\n\n\tutils.AssertEqual(t, \"Hello, World\", string(c.Response().Header.Peek(\"X-Test\")))\n\tutils.AssertEqual(t, \"World, XHello, Hello\", string(c.Response().Header.Peek(\"X2-Test\")))\n\tutils.AssertEqual(t, \"XHello, World, Hello\", string(c.Response().Header.Peek(\"X3-Test\")))\n\tutils.AssertEqual(t, \"XHello, Hello, HelloZ, YHello\", string(c.Response().Header.Peek(\"X4-Test\")))\n\tutils.AssertEqual(t, \"\", string(c.Response().Header.Peek(\"x-custom-header\")))\n}\n\n// go test -v -run=^$ -bench=Benchmark_Ctx_Append -benchmem -count=4\nfunc Benchmark_Ctx_Append(b *testing.B) {\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\tc.Append(\"X-Custom-Header\", \"Hello\")\n\t\tc.Append(\"X-Custom-Header\", \"World\")\n\t\tc.Append(\"X-Custom-Header\", \"Hello\")\n\t}\n\tutils.AssertEqual(b, \"Hello, World\", app.getString(c.Response().Header.Peek(\"X-Custom-Header\")))\n}\n\n// go test -run Test_Ctx_Attachment\nfunc Test_Ctx_Attachment(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\t// empty\n\tc.Attachment()\n\tutils.AssertEqual(t, `attachment`, string(c.Response().Header.Peek(HeaderContentDisposition)))\n\t// real filename\n\tc.Attachment(\"./static/img/logo.png\")\n\tutils.AssertEqual(t, `attachment; filename=\"logo.png\"`, string(c.Response().Header.Peek(HeaderContentDisposition)))\n\tutils.AssertEqual(t, \"image/png\", string(c.Response().Header.Peek(HeaderContentType)))\n\t// check quoting\n\tc.Attachment(\"another document.pdf\\\"\\r\\nBla: \\\"fasel\")\n\tutils.AssertEqual(t, `attachment; filename=\"another+document.pdf%22%0D%0ABla%3A+%22fasel\"`, string(c.Response().Header.Peek(HeaderContentDisposition)))\n}\n\n// go test -v -run=^$ -bench=Benchmark_Ctx_Attachment -benchmem -count=4\nfunc Benchmark_Ctx_Attachment(b *testing.B) {\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\t// example with quote params\n\t\tc.Attachment(\"another document.pdf\\\"\\r\\nBla: \\\"fasel\")\n\t}\n\tutils.AssertEqual(b, `attachment; filename=\"another+document.pdf%22%0D%0ABla%3A+%22fasel\"`, string(c.Response().Header.Peek(HeaderContentDisposition)))\n}\n\n// go test -run Test_Ctx_BaseURL\nfunc Test_Ctx_BaseURL(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tc.Request().SetRequestURI(\"http://google.com/test\")\n\tutils.AssertEqual(t, \"http://google.com\", c.BaseURL())\n\t// Check cache\n\tutils.AssertEqual(t, \"http://google.com\", c.BaseURL())\n}\n\n// go test -v -run=^$ -bench=Benchmark_Ctx_BaseURL -benchmem\nfunc Benchmark_Ctx_BaseURL(b *testing.B) {\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tc.Request().SetHost(\"google.com:1337\")\n\tc.Request().URI().SetPath(\"/haha/oke/lol\")\n\tvar res string\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\tres = c.BaseURL()\n\t}\n\tutils.AssertEqual(b, \"http://google.com:1337\", res)\n}\n\n// go test -run Test_Ctx_Body\nfunc Test_Ctx_Body(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tc.Request().SetBody([]byte(\"john=doe\"))\n\tutils.AssertEqual(t, []byte(\"john=doe\"), c.Body())\n}\n\nfunc Benchmark_Ctx_Body(b *testing.B) {\n\tconst input = \"john=doe\"\n\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\n\tc.Request().SetBody([]byte(input))\n\tfor i := 0; i < b.N; i++ {\n\t\t_ = c.Body()\n\t}\n\n\tutils.AssertEqual(b, []byte(input), c.Body())\n}\n\n// go test -run Test_Ctx_Body_With_Compression\nfunc Test_Ctx_Body_With_Compression(t *testing.T) {\n\tt.Parallel()\n\ttests := []struct {\n\t\tname            string\n\t\tcontentEncoding string\n\t\tbody            []byte\n\t\texpectedBody    []byte\n\t}{\n\t\t{\n\t\t\tname:            \"gzip\",\n\t\t\tcontentEncoding: \"gzip\",\n\t\t\tbody:            []byte(\"john=doe\"),\n\t\t\texpectedBody:    []byte(\"john=doe\"),\n\t\t},\n\t\t{\n\t\t\tname:            \"unsupported_encoding\",\n\t\t\tcontentEncoding: \"undefined\",\n\t\t\tbody:            []byte(\"keeps_ORIGINAL\"),\n\t\t\texpectedBody:    []byte(\"keeps_ORIGINAL\"),\n\t\t},\n\t\t{\n\t\t\tname:            \"gzip then unsupported\",\n\t\t\tcontentEncoding: \"gzip, undefined\",\n\t\t\tbody:            []byte(\"Go, be gzipped\"),\n\t\t\texpectedBody:    []byte(\"Go, be gzipped\"),\n\t\t},\n\t\t{\n\t\t\tname:            \"invalid_deflate\",\n\t\t\tcontentEncoding: \"gzip,deflate\",\n\t\t\tbody:            []byte(\"I'm not correctly compressed\"),\n\t\t\texpectedBody:    []byte(zlib.ErrHeader.Error()),\n\t\t},\n\t}\n\n\tfor _, testObject := range tests {\n\t\ttCase := testObject // Duplicate object to ensure it will be unique across all runs\n\t\tt.Run(tCase.name, func(t *testing.T) {\n\t\t\tapp := New()\n\t\t\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\t\t\tdefer app.ReleaseCtx(c)\n\t\t\tc.Request().Header.Set(\"Content-Encoding\", tCase.contentEncoding)\n\n\t\t\tif strings.Contains(tCase.contentEncoding, \"gzip\") {\n\t\t\t\tvar b bytes.Buffer\n\t\t\t\tgz := gzip.NewWriter(&b)\n\t\t\t\t_, err := gz.Write(tCase.body)\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Fatal(err)\n\t\t\t\t}\n\t\t\t\tif err = gz.Flush(); err != nil {\n\t\t\t\t\tt.Fatal(err)\n\t\t\t\t}\n\t\t\t\tif err = gz.Close(); err != nil {\n\t\t\t\t\tt.Fatal(err)\n\t\t\t\t}\n\t\t\t\ttCase.body = b.Bytes()\n\t\t\t}\n\n\t\t\tc.Request().SetBody(tCase.body)\n\t\t\tbody := c.Body()\n\t\t\tutils.AssertEqual(t, tCase.expectedBody, body)\n\n\t\t\t// Check if body raw is the same as previous before decompression\n\t\t\tutils.AssertEqual(\n\t\t\t\tt, tCase.body, c.Request().Body(),\n\t\t\t\t\"Body raw must be the same as set before\",\n\t\t\t)\n\t\t})\n\t}\n}\n\n// go test -v -run=^$ -bench=Benchmark_Ctx_Body_With_Compression -benchmem -count=4\nfunc Benchmark_Ctx_Body_With_Compression(b *testing.B) {\n\tencodingErr := errors.New(\"failed to encoding data\")\n\n\tvar (\n\t\tcompressGzip = func(data []byte) ([]byte, error) {\n\t\t\tvar buf bytes.Buffer\n\t\t\twriter := gzip.NewWriter(&buf)\n\t\t\tif _, err := writer.Write(data); err != nil {\n\t\t\t\treturn nil, encodingErr\n\t\t\t}\n\t\t\tif err := writer.Flush(); err != nil {\n\t\t\t\treturn nil, encodingErr\n\t\t\t}\n\t\t\tif err := writer.Close(); err != nil {\n\t\t\t\treturn nil, encodingErr\n\t\t\t}\n\t\t\treturn buf.Bytes(), nil\n\t\t}\n\t\tcompressDeflate = func(data []byte) ([]byte, error) {\n\t\t\tvar buf bytes.Buffer\n\t\t\twriter := zlib.NewWriter(&buf)\n\t\t\tif _, err := writer.Write(data); err != nil {\n\t\t\t\treturn nil, encodingErr\n\t\t\t}\n\t\t\tif err := writer.Flush(); err != nil {\n\t\t\t\treturn nil, encodingErr\n\t\t\t}\n\t\t\tif err := writer.Close(); err != nil {\n\t\t\t\treturn nil, encodingErr\n\t\t\t}\n\t\t\treturn buf.Bytes(), nil\n\t\t}\n\t)\n\tcompressionTests := []struct {\n\t\tcontentEncoding string\n\t\tcompressWriter  func([]byte) ([]byte, error)\n\t}{\n\t\t{\n\t\t\tcontentEncoding: \"gzip\",\n\t\t\tcompressWriter:  compressGzip,\n\t\t},\n\t\t{\n\t\t\tcontentEncoding: \"gzip,invalid\",\n\t\t\tcompressWriter:  compressGzip,\n\t\t},\n\t\t{\n\t\t\tcontentEncoding: \"deflate\",\n\t\t\tcompressWriter:  compressDeflate,\n\t\t},\n\t\t{\n\t\t\tcontentEncoding: \"gzip,deflate\",\n\t\t\tcompressWriter: func(data []byte) ([]byte, error) {\n\t\t\t\tvar (\n\t\t\t\t\tbuf    bytes.Buffer\n\t\t\t\t\twriter interface {\n\t\t\t\t\t\tio.WriteCloser\n\t\t\t\t\t\tFlush() error\n\t\t\t\t\t}\n\t\t\t\t\terr error\n\t\t\t\t)\n\n\t\t\t\t// deflate\n\t\t\t\t{\n\t\t\t\t\twriter = zlib.NewWriter(&buf)\n\t\t\t\t\tif _, err = writer.Write(data); err != nil {\n\t\t\t\t\t\treturn nil, encodingErr\n\t\t\t\t\t}\n\t\t\t\t\tif err = writer.Flush(); err != nil {\n\t\t\t\t\t\treturn nil, encodingErr\n\t\t\t\t\t}\n\t\t\t\t\tif err = writer.Close(); err != nil {\n\t\t\t\t\t\treturn nil, encodingErr\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tdata = make([]byte, buf.Len())\n\t\t\t\tcopy(data, buf.Bytes())\n\t\t\t\tbuf.Reset()\n\n\t\t\t\t// gzip\n\t\t\t\t{\n\t\t\t\t\twriter = gzip.NewWriter(&buf)\n\t\t\t\t\tif _, err = writer.Write(data); err != nil {\n\t\t\t\t\t\treturn nil, encodingErr\n\t\t\t\t\t}\n\t\t\t\t\tif err = writer.Flush(); err != nil {\n\t\t\t\t\t\treturn nil, encodingErr\n\t\t\t\t\t}\n\t\t\t\t\tif err = writer.Close(); err != nil {\n\t\t\t\t\t\treturn nil, encodingErr\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn buf.Bytes(), nil\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, ct := range compressionTests {\n\t\tb.Run(ct.contentEncoding, func(b *testing.B) {\n\t\t\tapp := New()\n\t\t\tconst input = \"john=doe\"\n\t\t\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\t\t\tdefer app.ReleaseCtx(c)\n\n\t\t\tc.Request().Header.Set(\"Content-Encoding\", ct.contentEncoding)\n\t\t\tcompressedBody, err := ct.compressWriter([]byte(input))\n\t\t\tutils.AssertEqual(b, nil, err)\n\n\t\t\tc.Request().SetBody(compressedBody)\n\t\t\tfor i := 0; i < b.N; i++ {\n\t\t\t\t_ = c.Body()\n\t\t\t}\n\n\t\t\tutils.AssertEqual(b, []byte(input), c.Body())\n\t\t})\n\t}\n}\n\n// go test -run Test_Ctx_BodyParser\nfunc Test_Ctx_BodyParser(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\n\ttype Demo struct {\n\t\tName string `json:\"name\" xml:\"name\" form:\"name\" query:\"name\"`\n\t}\n\n\t{\n\t\tvar gzipJSON bytes.Buffer\n\t\tw := gzip.NewWriter(&gzipJSON)\n\t\t_, err := w.Write([]byte(`{\"name\":\"john\"}`))\n\t\tutils.AssertEqual(t, nil, err)\n\t\terr = w.Close()\n\t\tutils.AssertEqual(t, nil, err)\n\n\t\tc.Request().Header.SetContentType(MIMEApplicationJSON)\n\t\tc.Request().Header.Set(HeaderContentEncoding, \"gzip\")\n\t\tc.Request().SetBody(gzipJSON.Bytes())\n\t\tc.Request().Header.SetContentLength(len(gzipJSON.Bytes()))\n\t\td := new(Demo)\n\t\tutils.AssertEqual(t, nil, c.BodyParser(d))\n\t\tutils.AssertEqual(t, \"john\", d.Name)\n\t\tc.Request().Header.Del(HeaderContentEncoding)\n\t}\n\n\ttestDecodeParser := func(contentType, body string) {\n\t\tc.Request().Header.SetContentType(contentType)\n\t\tc.Request().SetBody([]byte(body))\n\t\tc.Request().Header.SetContentLength(len(body))\n\t\td := new(Demo)\n\t\tutils.AssertEqual(t, nil, c.BodyParser(d))\n\t\tutils.AssertEqual(t, \"john\", d.Name)\n\t}\n\n\ttestDecodeParser(MIMEApplicationJSON, `{\"name\":\"john\"}`)\n\ttestDecodeParser(MIMEApplicationXML, `<Demo><name>john</name></Demo>`)\n\ttestDecodeParser(MIMEApplicationForm, \"name=john\")\n\ttestDecodeParser(MIMEMultipartForm+`;boundary=\"b\"`, \"--b\\r\\nContent-Disposition: form-data; name=\\\"name\\\"\\r\\n\\r\\njohn\\r\\n--b--\")\n\n\ttestDecodeParserError := func(contentType, body string) {\n\t\tc.Request().Header.SetContentType(contentType)\n\t\tc.Request().SetBody([]byte(body))\n\t\tc.Request().Header.SetContentLength(len(body))\n\t\tutils.AssertEqual(t, false, c.BodyParser(nil) == nil)\n\t}\n\n\ttestDecodeParserError(\"invalid-content-type\", \"\")\n\ttestDecodeParserError(MIMEMultipartForm+`;boundary=\"b\"`, \"--b\")\n\n\ttype CollectionQuery struct {\n\t\tData []Demo `query:\"data\"`\n\t}\n\n\tc.Request().Reset()\n\tc.Request().Header.SetContentType(MIMEApplicationForm)\n\tc.Request().SetBody([]byte(\"data[0][name]=john&data[1][name]=doe\"))\n\tc.Request().Header.SetContentLength(len(c.Body()))\n\tcq := new(CollectionQuery)\n\tutils.AssertEqual(t, nil, c.BodyParser(cq))\n\tutils.AssertEqual(t, 2, len(cq.Data))\n\tutils.AssertEqual(t, \"john\", cq.Data[0].Name)\n\tutils.AssertEqual(t, \"doe\", cq.Data[1].Name)\n\n\tc.Request().Reset()\n\tc.Request().Header.SetContentType(MIMEApplicationForm)\n\tc.Request().SetBody([]byte(\"data.0.name=john&data.1.name=doe\"))\n\tc.Request().Header.SetContentLength(len(c.Body()))\n\tcq = new(CollectionQuery)\n\tutils.AssertEqual(t, nil, c.BodyParser(cq))\n\tutils.AssertEqual(t, 2, len(cq.Data))\n\tutils.AssertEqual(t, \"john\", cq.Data[0].Name)\n\tutils.AssertEqual(t, \"doe\", cq.Data[1].Name)\n}\n\nfunc Test_Ctx_ParamParser(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tapp.Get(\"/test1/:userId/role/:roleId\", func(ctx *Ctx) error {\n\t\ttype Demo struct {\n\t\t\tUserID uint `params:\"userId\"`\n\t\t\tRoleID uint `params:\"roleId\"`\n\t\t}\n\t\td := new(Demo)\n\t\tif err := ctx.ParamsParser(d); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tutils.AssertEqual(t, uint(111), d.UserID)\n\t\tutils.AssertEqual(t, uint(222), d.RoleID)\n\t\treturn nil\n\t})\n\t_, err := app.Test(httptest.NewRequest(MethodGet, \"/test1/111/role/222\", nil))\n\tutils.AssertEqual(t, nil, err)\n\n\t_, err = app.Test(httptest.NewRequest(MethodGet, \"/test2/111/role/222\", nil))\n\tutils.AssertEqual(t, nil, err)\n}\n\n// go test -run Test_Ctx_BodyParser_WithSetParserDecoder\nfunc Test_Ctx_BodyParser_WithSetParserDecoder(t *testing.T) {\n\tt.Parallel()\n\ttype CustomTime time.Time\n\n\ttimeConverter := func(value string) reflect.Value {\n\t\tif v, err := time.Parse(\"2006-01-02\", value); err == nil {\n\t\t\treturn reflect.ValueOf(v)\n\t\t}\n\t\treturn reflect.Value{}\n\t}\n\n\tcustomTime := ParserType{\n\t\tCustomtype: CustomTime{},\n\t\tConverter:  timeConverter,\n\t}\n\n\tSetParserDecoder(ParserConfig{\n\t\tIgnoreUnknownKeys: true,\n\t\tParserType:        []ParserType{customTime},\n\t\tZeroEmpty:         true,\n\t\tSetAliasTag:       \"form\",\n\t})\n\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\n\ttype Demo struct {\n\t\tDate  CustomTime `form:\"date\"`\n\t\tTitle string     `form:\"title\"`\n\t\tBody  string     `form:\"body\"`\n\t}\n\n\ttestDecodeParser := func(contentType, body string) {\n\t\tc.Request().Header.SetContentType(contentType)\n\t\tc.Request().SetBody([]byte(body))\n\t\tc.Request().Header.SetContentLength(len(body))\n\t\td := Demo{\n\t\t\tTitle: \"Existing title\",\n\t\t\tBody:  \"Existing Body\",\n\t\t}\n\t\tutils.AssertEqual(t, nil, c.BodyParser(&d))\n\t\tdate := fmt.Sprintf(\"%v\", d.Date)\n\t\tutils.AssertEqual(t, \"{0 63743587200 <nil>}\", date)\n\t\tutils.AssertEqual(t, \"\", d.Title)\n\t\tutils.AssertEqual(t, \"New Body\", d.Body)\n\t}\n\n\ttestDecodeParser(MIMEApplicationForm, \"date=2020-12-15&title=&body=New Body\")\n\ttestDecodeParser(MIMEMultipartForm+`; boundary=\"b\"`, \"--b\\r\\nContent-Disposition: form-data; name=\\\"date\\\"\\r\\n\\r\\n2020-12-15\\r\\n--b\\r\\nContent-Disposition: form-data; name=\\\"title\\\"\\r\\n\\r\\n\\r\\n--b\\r\\nContent-Disposition: form-data; name=\\\"body\\\"\\r\\n\\r\\nNew Body\\r\\n--b--\")\n}\n\n// go test -v -run=^$ -bench=Benchmark_Ctx_BodyParser_JSON -benchmem -count=4\nfunc Benchmark_Ctx_BodyParser_JSON(b *testing.B) {\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\ttype Demo struct {\n\t\tName string `json:\"name\"`\n\t}\n\tbody := []byte(`{\"name\":\"john\"}`)\n\tc.Request().SetBody(body)\n\tc.Request().Header.SetContentType(MIMEApplicationJSON)\n\tc.Request().Header.SetContentLength(len(body))\n\td := new(Demo)\n\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\n\tfor n := 0; n < b.N; n++ {\n\t\t_ = c.BodyParser(d) //nolint:errcheck // It is fine to ignore the error here as we check it once further below\n\t}\n\tutils.AssertEqual(b, nil, c.BodyParser(d))\n\tutils.AssertEqual(b, \"john\", d.Name)\n}\n\n// go test -v -run=^$ -bench=Benchmark_Ctx_BodyParser_XML -benchmem -count=4\nfunc Benchmark_Ctx_BodyParser_XML(b *testing.B) {\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\ttype Demo struct {\n\t\tName string `xml:\"name\"`\n\t}\n\tbody := []byte(\"<Demo><name>john</name></Demo>\")\n\tc.Request().SetBody(body)\n\tc.Request().Header.SetContentType(MIMEApplicationXML)\n\tc.Request().Header.SetContentLength(len(body))\n\td := new(Demo)\n\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\n\tfor n := 0; n < b.N; n++ {\n\t\t_ = c.BodyParser(d) //nolint:errcheck // It is fine to ignore the error here as we check it once further below\n\t}\n\tutils.AssertEqual(b, nil, c.BodyParser(d))\n\tutils.AssertEqual(b, \"john\", d.Name)\n}\n\n// go test -v -run=^$ -bench=Benchmark_Ctx_BodyParser_Form -benchmem -count=4\nfunc Benchmark_Ctx_BodyParser_Form(b *testing.B) {\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\ttype Demo struct {\n\t\tName string `form:\"name\"`\n\t}\n\tbody := []byte(\"name=john\")\n\tc.Request().SetBody(body)\n\tc.Request().Header.SetContentType(MIMEApplicationForm)\n\tc.Request().Header.SetContentLength(len(body))\n\td := new(Demo)\n\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\n\tfor n := 0; n < b.N; n++ {\n\t\t_ = c.BodyParser(d) //nolint:errcheck // It is fine to ignore the error here as we check it once further below\n\t}\n\tutils.AssertEqual(b, nil, c.BodyParser(d))\n\tutils.AssertEqual(b, \"john\", d.Name)\n}\n\n// go test -v -run=^$ -bench=Benchmark_Ctx_BodyParser_MultipartForm -benchmem -count=4\nfunc Benchmark_Ctx_BodyParser_MultipartForm(b *testing.B) {\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\ttype Demo struct {\n\t\tName string `form:\"name\"`\n\t}\n\n\tbody := []byte(\"--b\\r\\nContent-Disposition: form-data; name=\\\"name\\\"\\r\\n\\r\\njohn\\r\\n--b--\")\n\tc.Request().SetBody(body)\n\tc.Request().Header.SetContentType(MIMEMultipartForm + `;boundary=\"b\"`)\n\tc.Request().Header.SetContentLength(len(body))\n\td := new(Demo)\n\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\n\tfor n := 0; n < b.N; n++ {\n\t\t_ = c.BodyParser(d) //nolint:errcheck // It is fine to ignore the error here as we check it once further below\n\t}\n\tutils.AssertEqual(b, nil, c.BodyParser(d))\n\tutils.AssertEqual(b, \"john\", d.Name)\n}\n\n// go test -run Test_Ctx_Context\nfunc Test_Ctx_Context(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\n\tutils.AssertEqual(t, \"*fasthttp.RequestCtx\", fmt.Sprintf(\"%T\", c.Context()))\n}\n\n// go test -run Test_Ctx_UserContext\nfunc Test_Ctx_UserContext(t *testing.T) {\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\n\tt.Run(\"Nil_Context\", func(t *testing.T) {\n\t\tctx := c.UserContext()\n\t\tutils.AssertEqual(t, ctx, context.Background())\n\t})\n\tt.Run(\"ValueContext\", func(t *testing.T) {\n\t\ttestKey := struct{}{}\n\t\ttestValue := \"Test Value\"\n\t\tctx := context.WithValue(context.Background(), testKey, testValue)\n\t\tutils.AssertEqual(t, testValue, ctx.Value(testKey))\n\t})\n}\n\n// go test -run Test_Ctx_SetUserContext\nfunc Test_Ctx_SetUserContext(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\n\ttestKey := struct{}{}\n\ttestValue := \"Test Value\"\n\tctx := context.WithValue(context.Background(), testKey, testValue)\n\tc.SetUserContext(ctx)\n\tutils.AssertEqual(t, testValue, c.UserContext().Value(testKey))\n}\n\n// go test -run Test_Ctx_UserContext_Multiple_Requests\nfunc Test_Ctx_UserContext_Multiple_Requests(t *testing.T) {\n\tt.Parallel()\n\ttestKey := struct{}{}\n\ttestValue := \"foobar-value\"\n\n\tapp := New()\n\tapp.Get(\"/\", func(c *Ctx) error {\n\t\tctx := c.UserContext()\n\n\t\tif ctx.Value(testKey) != nil {\n\t\t\treturn c.SendStatus(StatusInternalServerError)\n\t\t}\n\n\t\tinput := utils.CopyString(c.Query(\"input\", \"NO_VALUE\"))\n\t\tctx = context.WithValue(ctx, testKey, fmt.Sprintf(\"%s_%s\", testValue, input))\n\t\tc.SetUserContext(ctx)\n\n\t\treturn c.Status(StatusOK).SendString(fmt.Sprintf(\"resp_%s_returned\", input))\n\t})\n\n\t// Consecutive Requests\n\tfor i := 1; i <= 10; i++ {\n\t\tt.Run(fmt.Sprintf(\"request_%d\", i), func(t *testing.T) {\n\t\t\tresp, err := app.Test(httptest.NewRequest(MethodGet, fmt.Sprintf(\"/?input=%d\", i), nil))\n\n\t\t\tutils.AssertEqual(t, nil, err, \"Unexpected error from response\")\n\t\t\tutils.AssertEqual(t, StatusOK, resp.StatusCode, \"context.Context returned from c.UserContext() is reused\")\n\n\t\t\tb, err := io.ReadAll(resp.Body)\n\t\t\tutils.AssertEqual(t, nil, err, \"Unexpected error from reading response body\")\n\t\t\tutils.AssertEqual(t, fmt.Sprintf(\"resp_%d_returned\", i), string(b), \"response text incorrect\")\n\t\t})\n\t}\n}\n\n// go test -run Test_Ctx_Cookie\nfunc Test_Ctx_Cookie(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\texpire := time.Now().Add(24 * time.Hour)\n\tvar dst []byte\n\tdst = expire.In(time.UTC).AppendFormat(dst, time.RFC1123)\n\thttpdate := strings.ReplaceAll(string(dst), \"UTC\", \"GMT\")\n\tcookie := &Cookie{\n\t\tName:    \"username\",\n\t\tValue:   \"john\",\n\t\tExpires: expire,\n\t\t// SameSite: CookieSameSiteStrictMode, // default is \"lax\"\n\t}\n\tc.Cookie(cookie)\n\texpect := \"username=john; expires=\" + httpdate + \"; path=/; SameSite=Lax\"\n\tutils.AssertEqual(t, expect, string(c.Response().Header.Peek(HeaderSetCookie)))\n\n\texpect = \"username=john; expires=\" + httpdate + \"; path=/\"\n\tcookie.SameSite = CookieSameSiteDisabled\n\tc.Cookie(cookie)\n\tutils.AssertEqual(t, expect, string(c.Response().Header.Peek(HeaderSetCookie)))\n\n\texpect = \"username=john; expires=\" + httpdate + \"; path=/; SameSite=Strict\"\n\tcookie.SameSite = CookieSameSiteStrictMode\n\tc.Cookie(cookie)\n\tutils.AssertEqual(t, expect, string(c.Response().Header.Peek(HeaderSetCookie)))\n\n\texpect = \"username=john; expires=\" + httpdate + \"; path=/; secure; SameSite=None\"\n\tcookie.Secure = true\n\tcookie.SameSite = CookieSameSiteNoneMode\n\tc.Cookie(cookie)\n\tutils.AssertEqual(t, expect, string(c.Response().Header.Peek(HeaderSetCookie)))\n\n\texpect = \"username=john; path=/; secure; SameSite=None\"\n\t// should remove expires and max-age headers\n\tcookie.SessionOnly = true\n\tcookie.Expires = expire\n\tcookie.MaxAge = 10000\n\tc.Cookie(cookie)\n\tutils.AssertEqual(t, expect, string(c.Response().Header.Peek(HeaderSetCookie)))\n\n\texpect = \"username=john; path=/; secure; SameSite=None\"\n\t// should remove expires and max-age headers when no expire and no MaxAge (default time)\n\tcookie.SessionOnly = false\n\tcookie.Expires = time.Time{}\n\tcookie.MaxAge = 0\n\tc.Cookie(cookie)\n\tutils.AssertEqual(t, expect, string(c.Response().Header.Peek(HeaderSetCookie)))\n}\n\n// go test -v -run=^$ -bench=Benchmark_Ctx_Cookie -benchmem -count=4\nfunc Benchmark_Ctx_Cookie(b *testing.B) {\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\tc.Cookie(&Cookie{\n\t\t\tName:  \"John\",\n\t\t\tValue: \"Doe\",\n\t\t})\n\t}\n\tutils.AssertEqual(b, \"John=Doe; path=/; SameSite=Lax\", app.getString(c.Response().Header.Peek(\"Set-Cookie\")))\n}\n\n// go test -run Test_Ctx_Cookies\nfunc Test_Ctx_Cookies(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tc.Request().Header.Set(\"Cookie\", \"john=doe\")\n\tutils.AssertEqual(t, \"doe\", c.Cookies(\"john\"))\n\tutils.AssertEqual(t, \"default\", c.Cookies(\"unknown\", \"default\"))\n}\n\n// go test -run Test_Ctx_Format\nfunc Test_Ctx_Format(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tc.Request().Header.Set(HeaderAccept, MIMETextPlain)\n\terr := c.Format([]byte(\"Hello, World!\"))\n\tutils.AssertEqual(t, nil, err)\n\tutils.AssertEqual(t, \"Hello, World!\", string(c.Response().Body()))\n\n\tc.Request().Header.Set(HeaderAccept, MIMETextHTML)\n\terr = c.Format(\"Hello, World!\")\n\tutils.AssertEqual(t, nil, err)\n\tutils.AssertEqual(t, \"<p>Hello, World!</p>\", string(c.Response().Body()))\n\n\tc.Request().Header.Set(HeaderAccept, MIMEApplicationJSON)\n\terr = c.Format(\"Hello, World!\")\n\tutils.AssertEqual(t, nil, err)\n\tutils.AssertEqual(t, `\"Hello, World!\"`, string(c.Response().Body()))\n\n\tc.Request().Header.Set(HeaderAccept, MIMETextPlain)\n\terr = c.Format(complex(1, 1))\n\tutils.AssertEqual(t, nil, err)\n\tutils.AssertEqual(t, \"(1+1i)\", string(c.Response().Body()))\n\n\tc.Request().Header.Set(HeaderAccept, MIMEApplicationXML)\n\terr = c.Format(\"Hello, World!\")\n\tutils.AssertEqual(t, nil, err)\n\tutils.AssertEqual(t, `<string>Hello, World!</string>`, string(c.Response().Body()))\n\n\terr = c.Format(complex(1, 1))\n\tutils.AssertEqual(t, true, err != nil)\n\n\tc.Request().Header.Set(HeaderAccept, MIMETextPlain)\n\terr = c.Format(Map{})\n\tutils.AssertEqual(t, nil, err)\n\tutils.AssertEqual(t, \"map[]\", string(c.Response().Body()))\n\n\ttype broken string\n\tc.Request().Header.Set(HeaderAccept, \"broken/accept\")\n\terr = c.Format(broken(\"Hello, World!\"))\n\tutils.AssertEqual(t, nil, err)\n\tutils.AssertEqual(t, `Hello, World!`, string(c.Response().Body()))\n}\n\n// go test -v -run=^$ -bench=Benchmark_Ctx_Format -benchmem -count=4\nfunc Benchmark_Ctx_Format(b *testing.B) {\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tc.Request().Header.Set(\"Accept\", \"text/plain\")\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\n\tvar err error\n\tfor n := 0; n < b.N; n++ {\n\t\terr = c.Format(\"Hello, World!\")\n\t}\n\n\tutils.AssertEqual(b, nil, err)\n\tutils.AssertEqual(b, `Hello, World!`, string(c.Response().Body()))\n}\n\n// go test -v -run=^$ -bench=Benchmark_Ctx_Format_HTML -benchmem -count=4\nfunc Benchmark_Ctx_Format_HTML(b *testing.B) {\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tc.Request().Header.Set(\"Accept\", \"text/html\")\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\n\tvar err error\n\tfor n := 0; n < b.N; n++ {\n\t\terr = c.Format(\"Hello, World!\")\n\t}\n\n\tutils.AssertEqual(b, nil, err)\n\tutils.AssertEqual(b, \"<p>Hello, World!</p>\", string(c.Response().Body()))\n}\n\n// go test -v -run=^$ -bench=Benchmark_Ctx_Format_JSON -benchmem -count=4\nfunc Benchmark_Ctx_Format_JSON(b *testing.B) {\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tc.Request().Header.Set(\"Accept\", \"application/json\")\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\n\tvar err error\n\tfor n := 0; n < b.N; n++ {\n\t\terr = c.Format(\"Hello, World!\")\n\t}\n\n\tutils.AssertEqual(b, nil, err)\n\tutils.AssertEqual(b, `\"Hello, World!\"`, string(c.Response().Body()))\n}\n\n// go test -v -run=^$ -bench=Benchmark_Ctx_Format_XML -benchmem -count=4\nfunc Benchmark_Ctx_Format_XML(b *testing.B) {\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tc.Request().Header.Set(\"Accept\", \"application/xml\")\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\n\tvar err error\n\tfor n := 0; n < b.N; n++ {\n\t\terr = c.Format(\"Hello, World!\")\n\t}\n\n\tutils.AssertEqual(b, nil, err)\n\tutils.AssertEqual(b, `<string>Hello, World!</string>`, string(c.Response().Body()))\n}\n\n// go test -run Test_Ctx_FormFile\nfunc Test_Ctx_FormFile(t *testing.T) {\n\t// TODO: We should clean this up\n\tt.Parallel()\n\tapp := New()\n\n\tapp.Post(\"/test\", func(c *Ctx) error {\n\t\tfh, err := c.FormFile(\"file\")\n\t\tutils.AssertEqual(t, nil, err)\n\t\tutils.AssertEqual(t, \"test\", fh.Filename)\n\n\t\tf, err := fh.Open()\n\t\tutils.AssertEqual(t, nil, err)\n\t\tdefer func() {\n\t\t\tutils.AssertEqual(t, nil, f.Close())\n\t\t}()\n\n\t\tb := new(bytes.Buffer)\n\t\t_, err = io.Copy(b, f)\n\t\tutils.AssertEqual(t, nil, err)\n\t\tutils.AssertEqual(t, \"hello world\", b.String())\n\t\treturn nil\n\t})\n\n\tbody := &bytes.Buffer{}\n\twriter := multipart.NewWriter(body)\n\n\tioWriter, err := writer.CreateFormFile(\"file\", \"test\")\n\tutils.AssertEqual(t, nil, err)\n\n\t_, err = ioWriter.Write([]byte(\"hello world\"))\n\tutils.AssertEqual(t, nil, err)\n\tutils.AssertEqual(t, nil, writer.Close())\n\n\treq := httptest.NewRequest(MethodPost, \"/test\", body)\n\treq.Header.Set(HeaderContentType, writer.FormDataContentType())\n\treq.Header.Set(HeaderContentLength, strconv.Itoa(len(body.Bytes())))\n\n\tresp, err := app.Test(req)\n\tutils.AssertEqual(t, nil, err, \"app.Test(req)\")\n\tutils.AssertEqual(t, StatusOK, resp.StatusCode, \"Status code\")\n}\n\n// go test -run Test_Ctx_FormValue\nfunc Test_Ctx_FormValue(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\n\tapp.Post(\"/test\", func(c *Ctx) error {\n\t\tutils.AssertEqual(t, \"john\", c.FormValue(\"name\"))\n\t\treturn nil\n\t})\n\n\tbody := &bytes.Buffer{}\n\twriter := multipart.NewWriter(body)\n\tutils.AssertEqual(t, nil, writer.WriteField(\"name\", \"john\"))\n\tutils.AssertEqual(t, nil, writer.Close())\n\n\treq := httptest.NewRequest(MethodPost, \"/test\", body)\n\treq.Header.Set(\"Content-Type\", fmt.Sprintf(\"multipart/form-data; boundary=%s\", writer.Boundary()))\n\treq.Header.Set(\"Content-Length\", strconv.Itoa(len(body.Bytes())))\n\n\tresp, err := app.Test(req)\n\tutils.AssertEqual(t, nil, err, \"app.Test(req)\")\n\tutils.AssertEqual(t, StatusOK, resp.StatusCode, \"Status code\")\n}\n\n// go test -v -run=^$ -bench=Benchmark_Ctx_Fresh_StaleEtag -benchmem -count=4\nfunc Benchmark_Ctx_Fresh_StaleEtag(b *testing.B) {\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\n\tfor n := 0; n < b.N; n++ {\n\t\tc.Request().Header.Set(HeaderIfNoneMatch, \"a, b, c, d\")\n\t\tc.Request().Header.Set(HeaderCacheControl, \"c\")\n\t\tc.Fresh()\n\n\t\tc.Request().Header.Set(HeaderIfNoneMatch, \"a, b, c, d\")\n\t\tc.Request().Header.Set(HeaderCacheControl, \"e\")\n\t\tc.Fresh()\n\t}\n}\n\n// go test -run Test_Ctx_Fresh\nfunc Test_Ctx_Fresh(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tutils.AssertEqual(t, false, c.Fresh())\n\n\tc.Request().Header.Set(HeaderIfNoneMatch, \"*\")\n\tc.Request().Header.Set(HeaderCacheControl, \"no-cache\")\n\tutils.AssertEqual(t, false, c.Fresh())\n\n\tc.Request().Header.Set(HeaderIfNoneMatch, \"*\")\n\tc.Request().Header.Set(HeaderCacheControl, \",no-cache,\")\n\tutils.AssertEqual(t, false, c.Fresh())\n\n\tc.Request().Header.Set(HeaderIfNoneMatch, \"*\")\n\tc.Request().Header.Set(HeaderCacheControl, \"aa,no-cache,\")\n\tutils.AssertEqual(t, false, c.Fresh())\n\n\tc.Request().Header.Set(HeaderIfNoneMatch, \"*\")\n\tc.Request().Header.Set(HeaderCacheControl, \",no-cache,bb\")\n\tutils.AssertEqual(t, false, c.Fresh())\n\n\tc.Request().Header.Set(HeaderIfNoneMatch, \"675af34563dc-tr34\")\n\tc.Request().Header.Set(HeaderCacheControl, \"public\")\n\tutils.AssertEqual(t, false, c.Fresh())\n\n\tc.Request().Header.Set(HeaderIfNoneMatch, \"a, b\")\n\tc.Response().Header.Set(HeaderETag, \"c\")\n\tutils.AssertEqual(t, false, c.Fresh())\n\n\tc.Response().Header.Set(HeaderETag, \"a\")\n\tutils.AssertEqual(t, true, c.Fresh())\n\n\tc.Request().Header.Set(HeaderIfModifiedSince, \"xxWed, 21 Oct 2015 07:28:00 GMT\")\n\tc.Response().Header.Set(HeaderLastModified, \"xxWed, 21 Oct 2015 07:28:00 GMT\")\n\tutils.AssertEqual(t, false, c.Fresh())\n\n\tc.Response().Header.Set(HeaderLastModified, \"Wed, 21 Oct 2015 07:28:00 GMT\")\n\tutils.AssertEqual(t, false, c.Fresh())\n\n\tc.Request().Header.Set(HeaderIfModifiedSince, \"Wed, 21 Oct 2015 07:28:00 GMT\")\n\tutils.AssertEqual(t, false, c.Fresh())\n}\n\n// go test -v -run=^$ -bench=Benchmark_Ctx_Fresh_WithNoCache -benchmem -count=4\nfunc Benchmark_Ctx_Fresh_WithNoCache(b *testing.B) {\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\n\tc.Request().Header.Set(HeaderIfNoneMatch, \"*\")\n\tc.Request().Header.Set(HeaderCacheControl, \"no-cache\")\n\tfor n := 0; n < b.N; n++ {\n\t\tc.Fresh()\n\t}\n}\n\n// go test -run Test_Ctx_Get\nfunc Test_Ctx_Get(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tc.Request().Header.Set(HeaderAcceptCharset, \"utf-8, iso-8859-1;q=0.5\")\n\tc.Request().Header.Set(HeaderReferer, \"Monster\")\n\tutils.AssertEqual(t, \"utf-8, iso-8859-1;q=0.5\", c.Get(HeaderAcceptCharset))\n\tutils.AssertEqual(t, \"Monster\", c.Get(HeaderReferer))\n\tutils.AssertEqual(t, \"default\", c.Get(\"unknown\", \"default\"))\n}\n\n// go test -run Test_Ctx_IsProxyTrusted\nfunc Test_Ctx_IsProxyTrusted(t *testing.T) {\n\tt.Parallel()\n\n\t{\n\t\tapp := New()\n\t\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\t\tdefer app.ReleaseCtx(c)\n\t\tutils.AssertEqual(t, true, c.IsProxyTrusted())\n\t}\n\t{\n\t\tapp := New(Config{\n\t\t\tEnableTrustedProxyCheck: false,\n\t\t})\n\t\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\t\tdefer app.ReleaseCtx(c)\n\t\tutils.AssertEqual(t, true, c.IsProxyTrusted())\n\t}\n\n\t{\n\t\tapp := New(Config{\n\t\t\tEnableTrustedProxyCheck: true,\n\t\t})\n\t\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\t\tdefer app.ReleaseCtx(c)\n\t\tutils.AssertEqual(t, false, c.IsProxyTrusted())\n\t}\n\t{\n\t\tapp := New(Config{\n\t\t\tEnableTrustedProxyCheck: true,\n\n\t\t\tTrustedProxies: []string{},\n\t\t})\n\t\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\t\tdefer app.ReleaseCtx(c)\n\t\tutils.AssertEqual(t, false, c.IsProxyTrusted())\n\t}\n\t{\n\t\tapp := New(Config{\n\t\t\tEnableTrustedProxyCheck: true,\n\n\t\t\tTrustedProxies: []string{\n\t\t\t\t\"127.0.0.1\",\n\t\t\t},\n\t\t})\n\t\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\t\tdefer app.ReleaseCtx(c)\n\t\tutils.AssertEqual(t, false, c.IsProxyTrusted())\n\t}\n\t{\n\t\tapp := New(Config{\n\t\t\tEnableTrustedProxyCheck: true,\n\n\t\t\tTrustedProxies: []string{\n\t\t\t\t\"127.0.0.1/8\",\n\t\t\t},\n\t\t})\n\t\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\t\tdefer app.ReleaseCtx(c)\n\t\tutils.AssertEqual(t, false, c.IsProxyTrusted())\n\t}\n\t{\n\t\tapp := New(Config{\n\t\t\tEnableTrustedProxyCheck: true,\n\n\t\t\tTrustedProxies: []string{\n\t\t\t\t\"0.0.0.0\",\n\t\t\t},\n\t\t})\n\t\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\t\tdefer app.ReleaseCtx(c)\n\t\tutils.AssertEqual(t, true, c.IsProxyTrusted())\n\t}\n\t{\n\t\tapp := New(Config{\n\t\t\tEnableTrustedProxyCheck: true,\n\n\t\t\tTrustedProxies: []string{\n\t\t\t\t\"0.0.0.1/31\",\n\t\t\t},\n\t\t})\n\t\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\t\tdefer app.ReleaseCtx(c)\n\t\tutils.AssertEqual(t, true, c.IsProxyTrusted())\n\t}\n\t{\n\t\tapp := New(Config{\n\t\t\tEnableTrustedProxyCheck: true,\n\n\t\t\tTrustedProxies: []string{\n\t\t\t\t\"0.0.0.1/31junk\",\n\t\t\t},\n\t\t})\n\t\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\t\tdefer app.ReleaseCtx(c)\n\t\tutils.AssertEqual(t, false, c.IsProxyTrusted())\n\t}\n}\n\n// go test -run Test_Ctx_Hostname\nfunc Test_Ctx_Hostname(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tc.Request().SetRequestURI(\"http://google.com/test\")\n\tutils.AssertEqual(t, \"google.com\", c.Hostname())\n}\n\n// go test -run Test_Ctx_Hostname_Untrusted\nfunc Test_Ctx_Hostname_UntrustedProxy(t *testing.T) {\n\tt.Parallel()\n\t// Don't trust any proxy\n\t{\n\t\tapp := New(Config{EnableTrustedProxyCheck: true, TrustedProxies: []string{}})\n\t\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\t\tc.Request().SetRequestURI(\"http://google.com/test\")\n\t\tc.Request().Header.Set(HeaderXForwardedHost, \"google1.com\")\n\t\tutils.AssertEqual(t, \"google.com\", c.Hostname())\n\t\tapp.ReleaseCtx(c)\n\t}\n\t// Trust to specific proxy list\n\t{\n\t\tapp := New(Config{EnableTrustedProxyCheck: true, TrustedProxies: []string{\"0.8.0.0\", \"0.8.0.1\"}})\n\t\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\t\tc.Request().SetRequestURI(\"http://google.com/test\")\n\t\tc.Request().Header.Set(HeaderXForwardedHost, \"google1.com\")\n\t\tutils.AssertEqual(t, \"google.com\", c.Hostname())\n\t\tapp.ReleaseCtx(c)\n\t}\n}\n\n// go test -run Test_Ctx_Hostname_Trusted\nfunc Test_Ctx_Hostname_TrustedProxy(t *testing.T) {\n\tt.Parallel()\n\t{\n\t\tapp := New(Config{EnableTrustedProxyCheck: true, TrustedProxies: []string{\"0.0.0.0\", \"0.8.0.1\"}})\n\t\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\t\tc.Request().SetRequestURI(\"http://google.com/test\")\n\t\tc.Request().Header.Set(HeaderXForwardedHost, \"google1.com\")\n\t\tutils.AssertEqual(t, \"google1.com\", c.Hostname())\n\t\tapp.ReleaseCtx(c)\n\t}\n}\n\n// go test -run Test_Ctx_Hostname_Trusted_Multiple\nfunc Test_Ctx_Hostname_TrustedProxy_Multiple(t *testing.T) {\n\tt.Parallel()\n\t{\n\t\tapp := New(Config{EnableTrustedProxyCheck: true, TrustedProxies: []string{\"0.0.0.0\", \"0.8.0.1\"}})\n\t\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\t\tc.Request().SetRequestURI(\"http://google.com/test\")\n\t\tc.Request().Header.Set(HeaderXForwardedHost, \"google1.com, google2.com\")\n\t\tutils.AssertEqual(t, \"google1.com\", c.Hostname())\n\t\tapp.ReleaseCtx(c)\n\t}\n}\n\n// go test -run Test_Ctx_Hostname_UntrustedProxyRange\nfunc Test_Ctx_Hostname_TrustedProxyRange(t *testing.T) {\n\tt.Parallel()\n\n\tapp := New(Config{EnableTrustedProxyCheck: true, TrustedProxies: []string{\"0.0.0.0/30\"}})\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tc.Request().SetRequestURI(\"http://google.com/test\")\n\tc.Request().Header.Set(HeaderXForwardedHost, \"google1.com\")\n\tutils.AssertEqual(t, \"google1.com\", c.Hostname())\n\tapp.ReleaseCtx(c)\n}\n\n// go test -run Test_Ctx_Hostname_UntrustedProxyRange\nfunc Test_Ctx_Hostname_UntrustedProxyRange(t *testing.T) {\n\tt.Parallel()\n\n\tapp := New(Config{EnableTrustedProxyCheck: true, TrustedProxies: []string{\"1.0.0.0/30\"}})\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tc.Request().SetRequestURI(\"http://google.com/test\")\n\tc.Request().Header.Set(HeaderXForwardedHost, \"google1.com\")\n\tutils.AssertEqual(t, \"google.com\", c.Hostname())\n\tapp.ReleaseCtx(c)\n}\n\n// go test -run Test_Ctx_Port\nfunc Test_Ctx_Port(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tutils.AssertEqual(t, \"0\", c.Port())\n}\n\n// go test -run Test_Ctx_PortInHandler\nfunc Test_Ctx_PortInHandler(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\n\tapp.Get(\"/port\", func(c *Ctx) error {\n\t\treturn c.SendString(c.Port())\n\t})\n\n\tresp, err := app.Test(httptest.NewRequest(MethodGet, \"/port\", nil))\n\tutils.AssertEqual(t, nil, err, \"app.Test(req)\")\n\tutils.AssertEqual(t, StatusOK, resp.StatusCode, \"Status code\")\n\n\tbody, err := io.ReadAll(resp.Body)\n\tutils.AssertEqual(t, nil, err)\n\tutils.AssertEqual(t, \"0\", string(body))\n}\n\n// go test -run Test_Ctx_IP\nfunc Test_Ctx_IP(t *testing.T) {\n\tt.Parallel()\n\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\n\t// default behavior will return the remote IP from the stack\n\tutils.AssertEqual(t, \"0.0.0.0\", c.IP())\n\n\t// X-Forwarded-For is set, but it is ignored because proxyHeader is not set\n\tc.Request().Header.Set(HeaderXForwardedFor, \"0.0.0.1\")\n\tutils.AssertEqual(t, \"0.0.0.0\", c.IP())\n}\n\n// go test -run Test_Ctx_IP_ProxyHeader\nfunc Test_Ctx_IP_ProxyHeader(t *testing.T) {\n\tt.Parallel()\n\n\t// make sure that the same behavior exists for different proxy header names\n\tproxyHeaderNames := []string{\"Real-Ip\", HeaderXForwardedFor}\n\n\tfor _, proxyHeaderName := range proxyHeaderNames {\n\t\tapp := New(Config{ProxyHeader: proxyHeaderName})\n\t\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\t\tc.Request().Header.Set(proxyHeaderName, \"0.0.0.1\")\n\t\tutils.AssertEqual(t, \"0.0.0.1\", c.IP())\n\n\t\t// without IP validation we return the full string\n\t\tc.Request().Header.Set(proxyHeaderName, \"0.0.0.1, 0.0.0.2\")\n\t\tutils.AssertEqual(t, \"0.0.0.1, 0.0.0.2\", c.IP())\n\n\t\t// without IP validation we return invalid IPs\n\t\tc.Request().Header.Set(proxyHeaderName, \"invalid, 0.0.0.2, 0.0.0.3\")\n\t\tutils.AssertEqual(t, \"invalid, 0.0.0.2, 0.0.0.3\", c.IP())\n\n\t\t// when proxy header is enabled but the value is empty, without IP validation we return an empty string\n\t\tc.Request().Header.Set(proxyHeaderName, \"\")\n\t\tutils.AssertEqual(t, \"\", c.IP())\n\n\t\t// without IP validation we return an invalid IP\n\t\tc.Request().Header.Set(proxyHeaderName, \"not-valid-ip\")\n\t\tutils.AssertEqual(t, \"not-valid-ip\", c.IP())\n\n\t\tapp.ReleaseCtx(c)\n\t}\n}\n\n// go test -run Test_Ctx_IP_ProxyHeader\nfunc Test_Ctx_IP_ProxyHeader_With_IP_Validation(t *testing.T) {\n\tt.Parallel()\n\n\t// make sure that the same behavior exists for different proxy header names\n\tproxyHeaderNames := []string{\"Real-Ip\", HeaderXForwardedFor}\n\n\tfor _, proxyHeaderName := range proxyHeaderNames {\n\t\tapp := New(Config{EnableIPValidation: true, ProxyHeader: proxyHeaderName})\n\t\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\t\t// when proxy header & validation is enabled and the value is a valid IP, we return it\n\t\tc.Request().Header.Set(proxyHeaderName, \"0.0.0.1\")\n\t\tutils.AssertEqual(t, \"0.0.0.1\", c.IP())\n\n\t\t// when proxy header & validation is enabled and the value is a list of IPs, we return the first valid IP\n\t\tc.Request().Header.Set(proxyHeaderName, \"0.0.0.1, 0.0.0.2\")\n\t\tutils.AssertEqual(t, \"0.0.0.1\", c.IP())\n\n\t\tc.Request().Header.Set(proxyHeaderName, \"invalid, 0.0.0.2, 0.0.0.3\")\n\t\tutils.AssertEqual(t, \"0.0.0.2\", c.IP())\n\n\t\t// when proxy header & validation is enabled but the value is empty, we will ignore the header\n\t\tc.Request().Header.Set(proxyHeaderName, \"\")\n\t\tutils.AssertEqual(t, \"0.0.0.0\", c.IP())\n\n\t\t// when proxy header & validation is enabled but the value is not an IP, we will ignore the header\n\t\t// and return the IP of the caller\n\t\tc.Request().Header.Set(proxyHeaderName, \"not-valid-ip\")\n\t\tutils.AssertEqual(t, \"0.0.0.0\", c.IP())\n\n\t\tapp.ReleaseCtx(c)\n\t}\n}\n\n// go test -run Test_Ctx_IP_UntrustedProxy\nfunc Test_Ctx_IP_UntrustedProxy(t *testing.T) {\n\tt.Parallel()\n\tapp := New(Config{EnableTrustedProxyCheck: true, TrustedProxies: []string{\"0.8.0.1\"}, ProxyHeader: HeaderXForwardedFor})\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tc.Request().Header.Set(HeaderXForwardedFor, \"0.0.0.1\")\n\tdefer app.ReleaseCtx(c)\n\tutils.AssertEqual(t, \"0.0.0.0\", c.IP())\n}\n\n// go test -run Test_Ctx_IP_TrustedProxy\nfunc Test_Ctx_IP_TrustedProxy(t *testing.T) {\n\tt.Parallel()\n\tapp := New(Config{EnableTrustedProxyCheck: true, TrustedProxies: []string{\"0.0.0.0\"}, ProxyHeader: HeaderXForwardedFor})\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tc.Request().Header.Set(HeaderXForwardedFor, \"0.0.0.1\")\n\tdefer app.ReleaseCtx(c)\n\tutils.AssertEqual(t, \"0.0.0.1\", c.IP())\n}\n\n// go test -run Test_Ctx_IPs  -parallel\nfunc Test_Ctx_IPs(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\n\t// normal happy path test case\n\tc.Request().Header.Set(HeaderXForwardedFor, \"127.0.0.1, 127.0.0.2, 127.0.0.3\")\n\tutils.AssertEqual(t, []string{\"127.0.0.1\", \"127.0.0.2\", \"127.0.0.3\"}, c.IPs())\n\n\t// inconsistent space formatting\n\tc.Request().Header.Set(HeaderXForwardedFor, \"127.0.0.1,127.0.0.2  ,127.0.0.3\")\n\tutils.AssertEqual(t, []string{\"127.0.0.1\", \"127.0.0.2\", \"127.0.0.3\"}, c.IPs())\n\n\t// invalid IPs are allowed to be returned\n\tc.Request().Header.Set(HeaderXForwardedFor, \"invalid, 127.0.0.1, 127.0.0.2\")\n\tutils.AssertEqual(t, []string{\"invalid\", \"127.0.0.1\", \"127.0.0.2\"}, c.IPs())\n\tc.Request().Header.Set(HeaderXForwardedFor, \"127.0.0.1, invalid, 127.0.0.2\")\n\tutils.AssertEqual(t, []string{\"127.0.0.1\", \"invalid\", \"127.0.0.2\"}, c.IPs())\n\n\t// ensure that the ordering of IPs in the header is maintained\n\tc.Request().Header.Set(HeaderXForwardedFor, \"127.0.0.3, 127.0.0.1, 127.0.0.2\")\n\tutils.AssertEqual(t, []string{\"127.0.0.3\", \"127.0.0.1\", \"127.0.0.2\"}, c.IPs())\n\n\t// ensure for IPv6\n\tc.Request().Header.Set(HeaderXForwardedFor, \"9396:9549:b4f7:8ed0:4791:1330:8c06:e62d, invalid, 2345:0425:2CA1::0567:5673:23b5\")\n\tutils.AssertEqual(t, []string{\"9396:9549:b4f7:8ed0:4791:1330:8c06:e62d\", \"invalid\", \"2345:0425:2CA1::0567:5673:23b5\"}, c.IPs())\n\n\t// empty header\n\tc.Request().Header.Set(HeaderXForwardedFor, \"\")\n\tutils.AssertEqual(t, 0, len(c.IPs()))\n\n\t// missing header\n\tc.Request()\n\tutils.AssertEqual(t, 0, len(c.IPs()))\n}\n\nfunc Test_Ctx_IPs_With_IP_Validation(t *testing.T) {\n\tt.Parallel()\n\tapp := New(Config{EnableIPValidation: true})\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\n\t// normal happy path test case\n\tc.Request().Header.Set(HeaderXForwardedFor, \"127.0.0.1, 127.0.0.2, 127.0.0.3\")\n\tutils.AssertEqual(t, []string{\"127.0.0.1\", \"127.0.0.2\", \"127.0.0.3\"}, c.IPs())\n\n\t// inconsistent space formatting\n\tc.Request().Header.Set(HeaderXForwardedFor, \"127.0.0.1,127.0.0.2  ,127.0.0.3\")\n\tutils.AssertEqual(t, []string{\"127.0.0.1\", \"127.0.0.2\", \"127.0.0.3\"}, c.IPs())\n\n\t// invalid IPs are in the header\n\tc.Request().Header.Set(HeaderXForwardedFor, \"invalid, 127.0.0.1, 127.0.0.2\")\n\tutils.AssertEqual(t, []string{\"127.0.0.1\", \"127.0.0.2\"}, c.IPs())\n\tc.Request().Header.Set(HeaderXForwardedFor, \"127.0.0.1, invalid, 127.0.0.2\")\n\tutils.AssertEqual(t, []string{\"127.0.0.1\", \"127.0.0.2\"}, c.IPs())\n\n\t// ensure that the ordering of IPs in the header is maintained\n\tc.Request().Header.Set(HeaderXForwardedFor, \"127.0.0.3, 127.0.0.1, 127.0.0.2\")\n\tutils.AssertEqual(t, []string{\"127.0.0.3\", \"127.0.0.1\", \"127.0.0.2\"}, c.IPs())\n\n\t// ensure for IPv6\n\tc.Request().Header.Set(HeaderXForwardedFor, \"f037:825e:eadb:1b7b:1667:6f0a:5356:f604, invalid, 9396:9549:b4f7:8ed0:4791:1330:8c06:e62d\")\n\tutils.AssertEqual(t, []string{\"f037:825e:eadb:1b7b:1667:6f0a:5356:f604\", \"9396:9549:b4f7:8ed0:4791:1330:8c06:e62d\"}, c.IPs())\n\n\t// empty header\n\tc.Request().Header.Set(HeaderXForwardedFor, \"\")\n\tutils.AssertEqual(t, 0, len(c.IPs()))\n\n\t// missing header\n\tc.Request()\n\tutils.AssertEqual(t, 0, len(c.IPs()))\n}\n\n// go test -v -run=^$ -bench=Benchmark_Ctx_IPs -benchmem -count=4\nfunc Benchmark_Ctx_IPs(b *testing.B) {\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tc.Request().Header.Set(HeaderXForwardedFor, \"127.0.0.1, invalid, 127.0.0.1\")\n\tvar res []string\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\tres = c.IPs()\n\t}\n\tutils.AssertEqual(b, []string{\"127.0.0.1\", \"invalid\", \"127.0.0.1\"}, res)\n}\n\nfunc Benchmark_Ctx_IPs_v6(b *testing.B) {\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tc.Request().Header.Set(HeaderXForwardedFor, \"f037:825e:eadb:1b7b:1667:6f0a:5356:f604, invalid, 2345:0425:2CA1::0567:5673:23b5\")\n\tvar res []string\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\tres = c.IPs()\n\t}\n\tutils.AssertEqual(b, []string{\"f037:825e:eadb:1b7b:1667:6f0a:5356:f604\", \"invalid\", \"2345:0425:2CA1::0567:5673:23b5\"}, res)\n}\n\nfunc Benchmark_Ctx_IPs_With_IP_Validation(b *testing.B) {\n\tapp := New(Config{EnableIPValidation: true})\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tc.Request().Header.Set(HeaderXForwardedFor, \"127.0.0.1, invalid, 127.0.0.1\")\n\tvar res []string\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\tres = c.IPs()\n\t}\n\tutils.AssertEqual(b, []string{\"127.0.0.1\", \"127.0.0.1\"}, res)\n}\n\nfunc Benchmark_Ctx_IPs_v6_With_IP_Validation(b *testing.B) {\n\tapp := New(Config{EnableIPValidation: true})\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tc.Request().Header.Set(HeaderXForwardedFor, \"2345:0425:2CA1:0000:0000:0567:5673:23b5, invalid, 2345:0425:2CA1::0567:5673:23b5\")\n\tvar res []string\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\tres = c.IPs()\n\t}\n\tutils.AssertEqual(b, []string{\"2345:0425:2CA1:0000:0000:0567:5673:23b5\", \"2345:0425:2CA1::0567:5673:23b5\"}, res)\n}\n\nfunc Benchmark_Ctx_IP_With_ProxyHeader(b *testing.B) {\n\tapp := New(Config{ProxyHeader: HeaderXForwardedFor})\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tc.Request().Header.Set(HeaderXForwardedFor, \"127.0.0.1\")\n\tvar res string\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\tres = c.IP()\n\t}\n\tutils.AssertEqual(b, \"127.0.0.1\", res)\n}\n\nfunc Benchmark_Ctx_IP_With_ProxyHeader_and_IP_Validation(b *testing.B) {\n\tapp := New(Config{ProxyHeader: HeaderXForwardedFor, EnableIPValidation: true})\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tc.Request().Header.Set(HeaderXForwardedFor, \"127.0.0.1\")\n\tvar res string\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\tres = c.IP()\n\t}\n\tutils.AssertEqual(b, \"127.0.0.1\", res)\n}\n\nfunc Benchmark_Ctx_IP(b *testing.B) {\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tc.Request()\n\tvar res string\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\tres = c.IP()\n\t}\n\tutils.AssertEqual(b, \"0.0.0.0\", res)\n}\n\n// go test -run Test_Ctx_Is\nfunc Test_Ctx_Is(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tc.Request().Header.Set(HeaderContentType, MIMETextHTML+\"; boundary=something\")\n\tutils.AssertEqual(t, true, c.Is(\".html\"))\n\tutils.AssertEqual(t, true, c.Is(\"html\"))\n\tutils.AssertEqual(t, false, c.Is(\"json\"))\n\tutils.AssertEqual(t, false, c.Is(\".json\"))\n\tutils.AssertEqual(t, false, c.Is(\"\"))\n\tutils.AssertEqual(t, false, c.Is(\".foooo\"))\n\n\tc.Request().Header.Set(HeaderContentType, MIMEApplicationJSONCharsetUTF8)\n\tutils.AssertEqual(t, false, c.Is(\"html\"))\n\tutils.AssertEqual(t, true, c.Is(\"json\"))\n\tutils.AssertEqual(t, true, c.Is(\".json\"))\n\n\tc.Request().Header.Set(HeaderContentType, \" application/json;charset=UTF-8\")\n\tutils.AssertEqual(t, false, c.Is(\"html\"))\n\tutils.AssertEqual(t, true, c.Is(\"json\"))\n\tutils.AssertEqual(t, true, c.Is(\".json\"))\n\n\tc.Request().Header.Set(HeaderContentType, MIMEApplicationXMLCharsetUTF8)\n\tutils.AssertEqual(t, false, c.Is(\"html\"))\n\tutils.AssertEqual(t, true, c.Is(\"xml\"))\n\tutils.AssertEqual(t, true, c.Is(\".xml\"))\n\n\tc.Request().Header.Set(HeaderContentType, MIMETextPlain)\n\tutils.AssertEqual(t, false, c.Is(\"html\"))\n\tutils.AssertEqual(t, true, c.Is(\"txt\"))\n\tutils.AssertEqual(t, true, c.Is(\".txt\"))\n}\n\n// go test -v -run=^$ -bench=Benchmark_Ctx_Is -benchmem -count=4\nfunc Benchmark_Ctx_Is(b *testing.B) {\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tc.Request().Header.Set(HeaderContentType, MIMEApplicationJSON)\n\tvar res bool\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\t_ = c.Is(\".json\")\n\t\tres = c.Is(\"json\")\n\t}\n\tutils.AssertEqual(b, true, res)\n}\n\n// go test -run Test_Ctx_Locals\nfunc Test_Ctx_Locals(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tapp.Use(func(c *Ctx) error {\n\t\tc.Locals(\"john\", \"doe\")\n\t\treturn c.Next()\n\t})\n\tapp.Get(\"/test\", func(c *Ctx) error {\n\t\tutils.AssertEqual(t, \"doe\", c.Locals(\"john\"))\n\t\treturn nil\n\t})\n\tresp, err := app.Test(httptest.NewRequest(MethodGet, \"/test\", nil))\n\tutils.AssertEqual(t, nil, err, \"app.Test(req)\")\n\tutils.AssertEqual(t, StatusOK, resp.StatusCode, \"Status code\")\n}\n\n// go test -run Test_Ctx_Method\nfunc Test_Ctx_Method(t *testing.T) {\n\tt.Parallel()\n\tfctx := &fasthttp.RequestCtx{}\n\tfctx.Request.Header.SetMethod(MethodGet)\n\tapp := New()\n\tc := app.AcquireCtx(fctx)\n\tdefer app.ReleaseCtx(c)\n\tutils.AssertEqual(t, MethodGet, c.Method())\n\tc.Method(MethodPost)\n\tutils.AssertEqual(t, MethodPost, c.Method())\n\n\tc.Method(\"MethodInvalid\")\n\tutils.AssertEqual(t, MethodPost, c.Method())\n}\n\n// go test -run Test_Ctx_ClientHelloInfo\nfunc Test_Ctx_ClientHelloInfo(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tapp.Get(\"/ServerName\", func(c *Ctx) error {\n\t\tresult := c.ClientHelloInfo()\n\t\tif result != nil {\n\t\t\treturn c.SendString(result.ServerName)\n\t\t}\n\n\t\treturn c.SendString(\"ClientHelloInfo is nil\")\n\t})\n\tapp.Get(\"/SignatureSchemes\", func(c *Ctx) error {\n\t\tresult := c.ClientHelloInfo()\n\t\tif result != nil {\n\t\t\treturn c.JSON(result.SignatureSchemes)\n\t\t}\n\n\t\treturn c.SendString(\"ClientHelloInfo is nil\")\n\t})\n\tapp.Get(\"/SupportedVersions\", func(c *Ctx) error {\n\t\tresult := c.ClientHelloInfo()\n\t\tif result != nil {\n\t\t\treturn c.JSON(result.SupportedVersions)\n\t\t}\n\n\t\treturn c.SendString(\"ClientHelloInfo is nil\")\n\t})\n\n\t// Test without TLS handler\n\tresp, err := app.Test(httptest.NewRequest(MethodGet, \"/ServerName\", nil))\n\tutils.AssertEqual(t, nil, err)\n\tbody, err := io.ReadAll(resp.Body)\n\tutils.AssertEqual(t, nil, err)\n\tutils.AssertEqual(t, []byte(\"ClientHelloInfo is nil\"), body)\n\n\t// Test with TLS Handler\n\tconst (\n\t\tpssWithSHA256 = 0x0804\n\t\tversionTLS13  = 0x0304\n\t)\n\tapp.tlsHandler = &TLSHandler{clientHelloInfo: &tls.ClientHelloInfo{\n\t\tServerName:        \"example.golang\",\n\t\tSignatureSchemes:  []tls.SignatureScheme{pssWithSHA256},\n\t\tSupportedVersions: []uint16{versionTLS13},\n\t}}\n\n\t// Test ServerName\n\tresp, err = app.Test(httptest.NewRequest(MethodGet, \"/ServerName\", nil))\n\tutils.AssertEqual(t, nil, err)\n\tbody, err = io.ReadAll(resp.Body)\n\tutils.AssertEqual(t, nil, err)\n\tutils.AssertEqual(t, []byte(\"example.golang\"), body)\n\n\t// Test SignatureSchemes\n\tresp, err = app.Test(httptest.NewRequest(MethodGet, \"/SignatureSchemes\", nil))\n\tutils.AssertEqual(t, nil, err)\n\tbody, err = io.ReadAll(resp.Body)\n\tutils.AssertEqual(t, nil, err)\n\tutils.AssertEqual(t, \"[\"+strconv.Itoa(pssWithSHA256)+\"]\", string(body))\n\n\t// Test SupportedVersions\n\tresp, err = app.Test(httptest.NewRequest(MethodGet, \"/SupportedVersions\", nil))\n\tutils.AssertEqual(t, nil, err)\n\tbody, err = io.ReadAll(resp.Body)\n\tutils.AssertEqual(t, nil, err)\n\tutils.AssertEqual(t, \"[\"+strconv.Itoa(versionTLS13)+\"]\", string(body))\n}\n\n// go test -run Test_Ctx_InvalidMethod\nfunc Test_Ctx_InvalidMethod(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tapp.Get(\"/\", func(c *Ctx) error {\n\t\treturn nil\n\t})\n\n\tfctx := &fasthttp.RequestCtx{}\n\tfctx.Request.Header.SetMethod(\"InvalidMethod\")\n\tfctx.Request.SetRequestURI(\"/\")\n\n\tapp.Handler()(fctx)\n\n\tutils.AssertEqual(t, 400, fctx.Response.StatusCode())\n\tutils.AssertEqual(t, []byte(\"Invalid http method\"), fctx.Response.Body())\n}\n\n// go test -run Test_Ctx_MultipartForm\nfunc Test_Ctx_MultipartForm(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\n\tapp.Post(\"/test\", func(c *Ctx) error {\n\t\tresult, err := c.MultipartForm()\n\t\tutils.AssertEqual(t, nil, err)\n\t\tutils.AssertEqual(t, \"john\", result.Value[\"name\"][0])\n\t\treturn nil\n\t})\n\n\tbody := &bytes.Buffer{}\n\twriter := multipart.NewWriter(body)\n\tutils.AssertEqual(t, nil, writer.WriteField(\"name\", \"john\"))\n\tutils.AssertEqual(t, nil, writer.Close())\n\n\treq := httptest.NewRequest(MethodPost, \"/test\", body)\n\treq.Header.Set(HeaderContentType, fmt.Sprintf(\"multipart/form-data; boundary=%s\", writer.Boundary()))\n\treq.Header.Set(HeaderContentLength, strconv.Itoa(len(body.Bytes())))\n\n\tresp, err := app.Test(req)\n\tutils.AssertEqual(t, nil, err, \"app.Test(req)\")\n\tutils.AssertEqual(t, StatusOK, resp.StatusCode, \"Status code\")\n}\n\n// go test -v -run=^$ -bench=Benchmark_Ctx_MultipartForm -benchmem -count=4\nfunc Benchmark_Ctx_MultipartForm(b *testing.B) {\n\tapp := New()\n\n\tapp.Post(\"/\", func(c *Ctx) error {\n\t\t_, err := c.MultipartForm()\n\t\treturn err\n\t})\n\n\tc := &fasthttp.RequestCtx{}\n\n\tbody := []byte(\"--b\\r\\nContent-Disposition: form-data; name=\\\"name\\\"\\r\\n\\r\\njohn\\r\\n--b--\")\n\tc.Request.SetBody(body)\n\tc.Request.Header.SetContentType(MIMEMultipartForm + `;boundary=\"b\"`)\n\tc.Request.Header.SetContentLength(len(body))\n\n\th := app.Handler()\n\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\n\tfor n := 0; n < b.N; n++ {\n\t\th(c)\n\t}\n}\n\n// go test -run Test_Ctx_OriginalURL\nfunc Test_Ctx_OriginalURL(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tc.Request().Header.SetRequestURI(\"http://google.com/test?search=demo\")\n\tutils.AssertEqual(t, \"http://google.com/test?search=demo\", c.OriginalURL())\n}\n\n// go test -race -run Test_Ctx_Params\nfunc Test_Ctx_Params(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tapp.Get(\"/test/:user\", func(c *Ctx) error {\n\t\tutils.AssertEqual(t, \"john\", c.Params(\"user\"))\n\t\treturn nil\n\t})\n\tapp.Get(\"/test2/*\", func(c *Ctx) error {\n\t\tutils.AssertEqual(t, \"im/a/cookie\", c.Params(\"*\"))\n\t\treturn nil\n\t})\n\tapp.Get(\"/test3/*/blafasel/*\", func(c *Ctx) error {\n\t\tutils.AssertEqual(t, \"1111\", c.Params(\"*1\"))\n\t\tutils.AssertEqual(t, \"2222\", c.Params(\"*2\"))\n\t\tutils.AssertEqual(t, \"1111\", c.Params(\"*\"))\n\t\treturn nil\n\t})\n\tapp.Get(\"/test4/:optional?\", func(c *Ctx) error {\n\t\tutils.AssertEqual(t, \"\", c.Params(\"optional\"))\n\t\treturn nil\n\t})\n\tapp.Get(\"/test5/:id/:Id\", func(c *Ctx) error {\n\t\tutils.AssertEqual(t, \"first\", c.Params(\"id\"))\n\t\tutils.AssertEqual(t, \"first\", c.Params(\"Id\"))\n\t\treturn nil\n\t})\n\tresp, err := app.Test(httptest.NewRequest(MethodGet, \"/test/john\", nil))\n\tutils.AssertEqual(t, nil, err, \"app.Test(req)\")\n\tutils.AssertEqual(t, StatusOK, resp.StatusCode, \"Status code\")\n\n\tresp, err = app.Test(httptest.NewRequest(MethodGet, \"/test2/im/a/cookie\", nil))\n\tutils.AssertEqual(t, nil, err, \"app.Test(req)\")\n\tutils.AssertEqual(t, StatusOK, resp.StatusCode, \"Status code\")\n\n\tresp, err = app.Test(httptest.NewRequest(MethodGet, \"/test3/1111/blafasel/2222\", nil))\n\tutils.AssertEqual(t, nil, err, \"app.Test(req)\")\n\tutils.AssertEqual(t, StatusOK, resp.StatusCode, \"Status code\")\n\n\tresp, err = app.Test(httptest.NewRequest(MethodGet, \"/test4\", nil))\n\tutils.AssertEqual(t, nil, err, \"app.Test(req)\")\n\tutils.AssertEqual(t, StatusOK, resp.StatusCode, \"Status code\")\n\n\tresp, err = app.Test(httptest.NewRequest(MethodGet, \"/test5/first/second\", nil))\n\tutils.AssertEqual(t, nil, err)\n\tutils.AssertEqual(t, StatusOK, resp.StatusCode, \"Status code\")\n}\n\nfunc Test_Ctx_Params_Case_Sensitive(t *testing.T) {\n\tt.Parallel()\n\tapp := New(Config{CaseSensitive: true})\n\tapp.Get(\"/test/:User\", func(c *Ctx) error {\n\t\tutils.AssertEqual(t, \"john\", c.Params(\"User\"))\n\t\tutils.AssertEqual(t, \"\", c.Params(\"user\"))\n\t\treturn nil\n\t})\n\tapp.Get(\"/test2/:id/:Id\", func(c *Ctx) error {\n\t\tutils.AssertEqual(t, \"first\", c.Params(\"id\"))\n\t\tutils.AssertEqual(t, \"second\", c.Params(\"Id\"))\n\t\treturn nil\n\t})\n\tresp, err := app.Test(httptest.NewRequest(MethodGet, \"/test/john\", nil))\n\tutils.AssertEqual(t, nil, err, \"app.Test(req)\")\n\tutils.AssertEqual(t, StatusOK, resp.StatusCode, \"Status code\")\n\n\tresp, err = app.Test(httptest.NewRequest(MethodGet, \"/test2/first/second\", nil))\n\tutils.AssertEqual(t, nil, err)\n\tutils.AssertEqual(t, StatusOK, resp.StatusCode, \"Status code\")\n}\n\n// go test -race -run Test_Ctx_AllParams\nfunc Test_Ctx_AllParams(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tapp.Get(\"/test/:user\", func(c *Ctx) error {\n\t\tutils.AssertEqual(t, map[string]string{\"user\": \"john\"}, c.AllParams())\n\t\treturn nil\n\t})\n\tapp.Get(\"/test2/*\", func(c *Ctx) error {\n\t\tutils.AssertEqual(t, map[string]string{\"*1\": \"im/a/cookie\"}, c.AllParams())\n\t\treturn nil\n\t})\n\tapp.Get(\"/test3/*/blafasel/*\", func(c *Ctx) error {\n\t\tutils.AssertEqual(t, map[string]string{\"*1\": \"1111\", \"*2\": \"2222\"}, c.AllParams())\n\t\treturn nil\n\t})\n\tapp.Get(\"/test4/:optional?\", func(c *Ctx) error {\n\t\tutils.AssertEqual(t, map[string]string{\"optional\": \"\"}, c.AllParams())\n\t\treturn nil\n\t})\n\n\tresp, err := app.Test(httptest.NewRequest(MethodGet, \"/test/john\", nil))\n\tutils.AssertEqual(t, nil, err, \"app.Test(req)\")\n\tutils.AssertEqual(t, StatusOK, resp.StatusCode, \"Status code\")\n\n\tresp, err = app.Test(httptest.NewRequest(MethodGet, \"/test2/im/a/cookie\", nil))\n\tutils.AssertEqual(t, nil, err, \"app.Test(req)\")\n\tutils.AssertEqual(t, StatusOK, resp.StatusCode, \"Status code\")\n\n\tresp, err = app.Test(httptest.NewRequest(MethodGet, \"/test3/1111/blafasel/2222\", nil))\n\tutils.AssertEqual(t, nil, err, \"app.Test(req)\")\n\tutils.AssertEqual(t, StatusOK, resp.StatusCode, \"Status code\")\n\n\tresp, err = app.Test(httptest.NewRequest(MethodGet, \"/test4\", nil))\n\tutils.AssertEqual(t, nil, err, \"app.Test(req)\")\n\tutils.AssertEqual(t, StatusOK, resp.StatusCode, \"Status code\")\n}\n\n// go test -v -run=^$ -bench=Benchmark_Ctx_Params -benchmem -count=4\nfunc Benchmark_Ctx_Params(b *testing.B) {\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tc.route = &Route{\n\t\tParams: []string{\n\t\t\t\"param1\", \"param2\", \"param3\", \"param4\",\n\t\t},\n\t}\n\tc.values = [maxParams]string{\n\t\t\"john\", \"doe\", \"is\", \"awesome\",\n\t}\n\tvar res string\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\t_ = c.Params(\"param1\")\n\t\t_ = c.Params(\"param2\")\n\t\t_ = c.Params(\"param3\")\n\t\tres = c.Params(\"param4\")\n\t}\n\tutils.AssertEqual(b, \"awesome\", res)\n}\n\n// go test -v -run=^$ -bench=Benchmark_Ctx_AllParams -benchmem -count=4\nfunc Benchmark_Ctx_AllParams(b *testing.B) {\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tc.route = &Route{\n\t\tParams: []string{\n\t\t\t\"param1\", \"param2\", \"param3\", \"param4\",\n\t\t},\n\t}\n\tc.values = [maxParams]string{\n\t\t\"john\", \"doe\", \"is\", \"awesome\",\n\t}\n\tvar res map[string]string\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\tres = c.AllParams()\n\t}\n\tutils.AssertEqual(\n\t\tb,\n\t\tmap[string]string{\n\t\t\t\"param1\": \"john\",\n\t\t\t\"param2\": \"doe\",\n\t\t\t\"param3\": \"is\",\n\t\t\t\"param4\": \"awesome\",\n\t\t},\n\t\tres,\n\t)\n}\n\n// go test -v -run=^$ -bench=Benchmark_Ctx_ParamsParse -benchmem -count=4\nfunc Benchmark_Ctx_ParamsParse(b *testing.B) {\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tc.route = &Route{\n\t\tParams: []string{\n\t\t\t\"param1\", \"param2\", \"param3\", \"param4\",\n\t\t},\n\t}\n\tc.values = [maxParams]string{\n\t\t\"john\", \"doe\", \"is\", \"awesome\",\n\t}\n\tvar res struct {\n\t\tParam1 string `params:\"param1\"`\n\t\tParam2 string `params:\"param2\"`\n\t\tParam3 string `params:\"param3\"`\n\t\tParam4 string `params:\"param4\"`\n\t}\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\n\tvar err error\n\tfor n := 0; n < b.N; n++ {\n\t\terr = c.ParamsParser(&res)\n\t}\n\n\tutils.AssertEqual(b, nil, err)\n\tutils.AssertEqual(b, \"john\", res.Param1)\n\tutils.AssertEqual(b, \"doe\", res.Param2)\n\tutils.AssertEqual(b, \"is\", res.Param3)\n\tutils.AssertEqual(b, \"awesome\", res.Param4)\n}\n\n// go test -run Test_Ctx_Path\nfunc Test_Ctx_Path(t *testing.T) {\n\tt.Parallel()\n\tapp := New(Config{UnescapePath: true})\n\tapp.Get(\"/test/:user\", func(c *Ctx) error {\n\t\tutils.AssertEqual(t, \"/Test/John\", c.Path())\n\t\t// not strict && case insensitive\n\t\tutils.AssertEqual(t, \"/ABC/\", c.Path(\"/ABC/\"))\n\t\tutils.AssertEqual(t, \"/test/john/\", c.Path(\"/test/john/\"))\n\t\treturn nil\n\t})\n\n\t// test with special chars\n\tapp.Get(\"/specialChars/:name\", func(c *Ctx) error {\n\t\tutils.AssertEqual(t, \"/specialChars/cr\u00e9er\", c.Path())\n\t\t// unescape is also working if you set the path afterwards\n\t\tutils.AssertEqual(t, \"/\u0627\u062e\u062a\u0628\u0627\u0631/\", c.Path(\"/%D8%A7%D8%AE%D8%AA%D8%A8%D8%A7%D8%B1/\"))\n\t\treturn nil\n\t})\n\tresp, err := app.Test(httptest.NewRequest(MethodGet, \"/specialChars/cr%C3%A9er\", nil))\n\tutils.AssertEqual(t, nil, err, \"app.Test(req)\")\n\tutils.AssertEqual(t, StatusOK, resp.StatusCode, \"Status code\")\n}\n\n// go test -run Test_Ctx_Protocol\nfunc Test_Ctx_Protocol(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\n\tfreq := &fasthttp.RequestCtx{}\n\tfreq.Request.Header.Set(\"X-Forwarded\", \"invalid\")\n\n\tc := app.AcquireCtx(freq)\n\tdefer app.ReleaseCtx(c)\n\tc.Request().Header.Set(HeaderXForwardedProto, schemeHTTPS)\n\tutils.AssertEqual(t, schemeHTTPS, c.Protocol())\n\tc.Request().Header.Reset()\n\n\tc.Request().Header.Set(HeaderXForwardedProtocol, schemeHTTPS)\n\tutils.AssertEqual(t, schemeHTTPS, c.Protocol())\n\tc.Request().Header.Reset()\n\n\tc.Request().Header.Set(HeaderXForwardedProto, \"https, http\")\n\tutils.AssertEqual(t, schemeHTTPS, c.Protocol())\n\tc.Request().Header.Reset()\n\n\tc.Request().Header.Set(HeaderXForwardedProtocol, \"https, http\")\n\tutils.AssertEqual(t, schemeHTTPS, c.Protocol())\n\tc.Request().Header.Reset()\n\n\tc.Request().Header.Set(HeaderXForwardedSsl, \"on\")\n\tutils.AssertEqual(t, schemeHTTPS, c.Protocol())\n\tc.Request().Header.Reset()\n\n\tc.Request().Header.Set(HeaderXUrlScheme, schemeHTTPS)\n\tutils.AssertEqual(t, schemeHTTPS, c.Protocol())\n\tc.Request().Header.Reset()\n\n\tutils.AssertEqual(t, schemeHTTP, c.Protocol())\n}\n\n// go test -v -run=^$ -bench=Benchmark_Ctx_Protocol -benchmem -count=4\nfunc Benchmark_Ctx_Protocol(b *testing.B) {\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tvar res string\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\tres = c.Protocol()\n\t}\n\tutils.AssertEqual(b, schemeHTTP, res)\n}\n\n// go test -run Test_Ctx_Protocol_TrustedProxy\nfunc Test_Ctx_Protocol_TrustedProxy(t *testing.T) {\n\tt.Parallel()\n\tapp := New(Config{EnableTrustedProxyCheck: true, TrustedProxies: []string{\"0.0.0.0\"}})\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\n\tc.Request().Header.Set(HeaderXForwardedProto, schemeHTTPS)\n\tutils.AssertEqual(t, schemeHTTPS, c.Protocol())\n\tc.Request().Header.Reset()\n\n\tc.Request().Header.Set(HeaderXForwardedProtocol, schemeHTTPS)\n\tutils.AssertEqual(t, schemeHTTPS, c.Protocol())\n\tc.Request().Header.Reset()\n\n\tc.Request().Header.Set(HeaderXForwardedSsl, \"on\")\n\tutils.AssertEqual(t, schemeHTTPS, c.Protocol())\n\tc.Request().Header.Reset()\n\n\tc.Request().Header.Set(HeaderXUrlScheme, schemeHTTPS)\n\tutils.AssertEqual(t, schemeHTTPS, c.Protocol())\n\tc.Request().Header.Reset()\n\n\tutils.AssertEqual(t, schemeHTTP, c.Protocol())\n}\n\n// go test -run Test_Ctx_Protocol_TrustedProxyRange\nfunc Test_Ctx_Protocol_TrustedProxyRange(t *testing.T) {\n\tt.Parallel()\n\tapp := New(Config{EnableTrustedProxyCheck: true, TrustedProxies: []string{\"0.0.0.0/30\"}})\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\n\tc.Request().Header.Set(HeaderXForwardedProto, schemeHTTPS)\n\tutils.AssertEqual(t, schemeHTTPS, c.Protocol())\n\tc.Request().Header.Reset()\n\n\tc.Request().Header.Set(HeaderXForwardedProtocol, schemeHTTPS)\n\tutils.AssertEqual(t, schemeHTTPS, c.Protocol())\n\tc.Request().Header.Reset()\n\n\tc.Request().Header.Set(HeaderXForwardedSsl, \"on\")\n\tutils.AssertEqual(t, schemeHTTPS, c.Protocol())\n\tc.Request().Header.Reset()\n\n\tc.Request().Header.Set(HeaderXUrlScheme, schemeHTTPS)\n\tutils.AssertEqual(t, schemeHTTPS, c.Protocol())\n\tc.Request().Header.Reset()\n\n\tutils.AssertEqual(t, schemeHTTP, c.Protocol())\n}\n\n// go test -run Test_Ctx_Protocol_UntrustedProxyRange\nfunc Test_Ctx_Protocol_UntrustedProxyRange(t *testing.T) {\n\tt.Parallel()\n\tapp := New(Config{EnableTrustedProxyCheck: true, TrustedProxies: []string{\"1.1.1.1/30\"}})\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\n\tc.Request().Header.Set(HeaderXForwardedProto, schemeHTTPS)\n\tutils.AssertEqual(t, schemeHTTP, c.Protocol())\n\tc.Request().Header.Reset()\n\n\tc.Request().Header.Set(HeaderXForwardedProtocol, schemeHTTPS)\n\tutils.AssertEqual(t, schemeHTTP, c.Protocol())\n\tc.Request().Header.Reset()\n\n\tc.Request().Header.Set(HeaderXForwardedSsl, \"on\")\n\tutils.AssertEqual(t, schemeHTTP, c.Protocol())\n\tc.Request().Header.Reset()\n\n\tc.Request().Header.Set(HeaderXUrlScheme, schemeHTTPS)\n\tutils.AssertEqual(t, schemeHTTP, c.Protocol())\n\tc.Request().Header.Reset()\n\n\tutils.AssertEqual(t, schemeHTTP, c.Protocol())\n}\n\n// go test -run Test_Ctx_Protocol_UnTrustedProxy\nfunc Test_Ctx_Protocol_UnTrustedProxy(t *testing.T) {\n\tt.Parallel()\n\tapp := New(Config{EnableTrustedProxyCheck: true, TrustedProxies: []string{\"0.8.0.1\"}})\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\n\tc.Request().Header.Set(HeaderXForwardedProto, schemeHTTPS)\n\tutils.AssertEqual(t, schemeHTTP, c.Protocol())\n\tc.Request().Header.Reset()\n\n\tc.Request().Header.Set(HeaderXForwardedProtocol, schemeHTTPS)\n\tutils.AssertEqual(t, schemeHTTP, c.Protocol())\n\tc.Request().Header.Reset()\n\n\tc.Request().Header.Set(HeaderXForwardedSsl, \"on\")\n\tutils.AssertEqual(t, schemeHTTP, c.Protocol())\n\tc.Request().Header.Reset()\n\n\tc.Request().Header.Set(HeaderXUrlScheme, schemeHTTPS)\n\tutils.AssertEqual(t, schemeHTTP, c.Protocol())\n\tc.Request().Header.Reset()\n\n\tutils.AssertEqual(t, schemeHTTP, c.Protocol())\n}\n\n// go test -run Test_Ctx_Query\nfunc Test_Ctx_Query(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tc.Request().URI().SetQueryString(\"search=john&age=20&id=\")\n\tutils.AssertEqual(t, \"john\", c.Query(\"search\"))\n\tutils.AssertEqual(t, \"20\", c.Query(\"age\"))\n\tutils.AssertEqual(t, \"default\", c.Query(\"unknown\", \"default\"))\n}\n\nfunc Test_Ctx_QueryInt(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tc.Request().URI().SetQueryString(\"search=john&age=20&id=\")\n\n\tutils.AssertEqual(t, 0, c.QueryInt(\"foo\"))\n\tutils.AssertEqual(t, 20, c.QueryInt(\"age\", 12))\n\tutils.AssertEqual(t, 0, c.QueryInt(\"search\"))\n\tutils.AssertEqual(t, 1, c.QueryInt(\"search\", 1))\n\tutils.AssertEqual(t, 0, c.QueryInt(\"id\"))\n\tutils.AssertEqual(t, 2, c.QueryInt(\"id\", 2))\n}\n\nfunc Test_Ctx_QueryBool(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tc.Request().URI().SetQueryString(\"name=alex&want_pizza=false&id=\")\n\n\tutils.AssertEqual(t, false, c.QueryBool(\"want_pizza\"))\n\tutils.AssertEqual(t, false, c.QueryBool(\"want_pizza\", true))\n\tutils.AssertEqual(t, false, c.QueryBool(\"name\"))\n\tutils.AssertEqual(t, true, c.QueryBool(\"name\", true))\n\tutils.AssertEqual(t, false, c.QueryBool(\"id\"))\n\tutils.AssertEqual(t, true, c.QueryBool(\"id\", true))\n}\n\nfunc Test_Ctx_QueryFloat(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tc.Request().URI().SetQueryString(\"name=alex&amount=32.23&id=\")\n\n\tutils.AssertEqual(t, 32.23, c.QueryFloat(\"amount\"))\n\tutils.AssertEqual(t, 32.23, c.QueryFloat(\"amount\", 3.123))\n\tutils.AssertEqual(t, 87.123, c.QueryFloat(\"name\", 87.123))\n\tutils.AssertEqual(t, float64(0), c.QueryFloat(\"name\"))\n\tutils.AssertEqual(t, 12.87, c.QueryFloat(\"id\", 12.87))\n\tutils.AssertEqual(t, float64(0), c.QueryFloat(\"id\"))\n}\n\n// go test -run Test_Ctx_Range\nfunc Test_Ctx_Range(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\n\tvar (\n\t\tresult Range\n\t\terr    error\n\t)\n\n\t_, err = c.Range(1000)\n\tutils.AssertEqual(t, true, err != nil)\n\n\tc.Request().Header.Set(HeaderRange, \"bytes=500\")\n\t_, err = c.Range(1000)\n\tutils.AssertEqual(t, true, err != nil)\n\n\tc.Request().Header.Set(HeaderRange, \"bytes=500=\")\n\t_, err = c.Range(1000)\n\tutils.AssertEqual(t, true, err != nil)\n\n\tc.Request().Header.Set(HeaderRange, \"bytes=500-300\")\n\t_, err = c.Range(1000)\n\tutils.AssertEqual(t, true, err != nil)\n\n\ttestRange := func(header string, start, end int) {\n\t\tc.Request().Header.Set(HeaderRange, header)\n\t\tresult, err = c.Range(1000)\n\t\tutils.AssertEqual(t, nil, err)\n\t\tutils.AssertEqual(t, \"bytes\", result.Type)\n\t\tutils.AssertEqual(t, start, result.Ranges[0].Start)\n\t\tutils.AssertEqual(t, end, result.Ranges[0].End)\n\t}\n\n\ttestRange(\"bytes=a-700\", 300, 999)\n\ttestRange(\"bytes=500-b\", 500, 999)\n\ttestRange(\"bytes=500-1000\", 500, 999)\n\ttestRange(\"bytes=500-700\", 500, 700)\n}\n\n// go test -run Test_Ctx_Route\nfunc Test_Ctx_Route(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tapp.Get(\"/test\", func(c *Ctx) error {\n\t\tutils.AssertEqual(t, \"/test\", c.Route().Path)\n\t\treturn nil\n\t})\n\tresp, err := app.Test(httptest.NewRequest(MethodGet, \"/test\", nil))\n\tutils.AssertEqual(t, nil, err, \"app.Test(req)\")\n\tutils.AssertEqual(t, StatusOK, resp.StatusCode, \"Status code\")\n\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\n\tutils.AssertEqual(t, \"/\", c.Route().Path)\n\tutils.AssertEqual(t, MethodGet, c.Route().Method)\n\tutils.AssertEqual(t, 0, len(c.Route().Handlers))\n}\n\n// go test -run Test_Ctx_RouteNormalized\nfunc Test_Ctx_RouteNormalized(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tapp.Get(\"/test\", func(c *Ctx) error {\n\t\tutils.AssertEqual(t, \"/test\", c.Route().Path)\n\t\treturn nil\n\t})\n\tresp, err := app.Test(httptest.NewRequest(MethodGet, \"//test\", nil))\n\tutils.AssertEqual(t, nil, err, \"app.Test(req)\")\n\tutils.AssertEqual(t, StatusNotFound, resp.StatusCode, \"Status code\")\n}\n\n// go test -run Test_Ctx_SaveFile\nfunc Test_Ctx_SaveFile(t *testing.T) {\n\t// TODO We should clean this up\n\tt.Parallel()\n\tapp := New()\n\n\tapp.Post(\"/test\", func(c *Ctx) error {\n\t\tfh, err := c.FormFile(\"file\")\n\t\tutils.AssertEqual(t, nil, err)\n\n\t\ttempFile, err := os.CreateTemp(os.TempDir(), \"test-\")\n\t\tutils.AssertEqual(t, nil, err)\n\n\t\tdefer func(file *os.File) {\n\t\t\terr := file.Close()\n\t\t\tutils.AssertEqual(t, nil, err)\n\t\t\terr = os.Remove(file.Name())\n\t\t\tutils.AssertEqual(t, nil, err)\n\t\t}(tempFile)\n\t\terr = c.SaveFile(fh, tempFile.Name())\n\t\tutils.AssertEqual(t, nil, err)\n\n\t\tbs, err := os.ReadFile(tempFile.Name())\n\t\tutils.AssertEqual(t, nil, err)\n\t\tutils.AssertEqual(t, \"hello world\", string(bs))\n\t\treturn nil\n\t})\n\n\tbody := &bytes.Buffer{}\n\twriter := multipart.NewWriter(body)\n\n\tioWriter, err := writer.CreateFormFile(\"file\", \"test\")\n\tutils.AssertEqual(t, nil, err)\n\n\t_, err = ioWriter.Write([]byte(\"hello world\"))\n\tutils.AssertEqual(t, nil, err)\n\tutils.AssertEqual(t, nil, writer.Close())\n\n\treq := httptest.NewRequest(MethodPost, \"/test\", body)\n\treq.Header.Set(\"Content-Type\", writer.FormDataContentType())\n\treq.Header.Set(\"Content-Length\", strconv.Itoa(len(body.Bytes())))\n\n\tresp, err := app.Test(req)\n\tutils.AssertEqual(t, nil, err, \"app.Test(req)\")\n\tutils.AssertEqual(t, StatusOK, resp.StatusCode, \"Status code\")\n}\n\n// go test -run Test_Ctx_SaveFileToStorage\nfunc Test_Ctx_SaveFileToStorage(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tstorage := memory.New()\n\n\tapp.Post(\"/test\", func(c *Ctx) error {\n\t\tfh, err := c.FormFile(\"file\")\n\t\tutils.AssertEqual(t, nil, err)\n\n\t\terr = c.SaveFileToStorage(fh, \"test\", storage)\n\t\tutils.AssertEqual(t, nil, err)\n\n\t\tfile, err := storage.Get(\"test\")\n\t\tutils.AssertEqual(t, []byte(\"hello world\"), file)\n\t\tutils.AssertEqual(t, nil, err)\n\n\t\terr = storage.Delete(\"test\")\n\t\tutils.AssertEqual(t, nil, err)\n\n\t\treturn nil\n\t})\n\n\tbody := &bytes.Buffer{}\n\twriter := multipart.NewWriter(body)\n\n\tioWriter, err := writer.CreateFormFile(\"file\", \"test\")\n\tutils.AssertEqual(t, nil, err)\n\n\t_, err = ioWriter.Write([]byte(\"hello world\"))\n\tutils.AssertEqual(t, nil, err)\n\tutils.AssertEqual(t, nil, writer.Close())\n\n\treq := httptest.NewRequest(MethodPost, \"/test\", body)\n\treq.Header.Set(\"Content-Type\", writer.FormDataContentType())\n\treq.Header.Set(\"Content-Length\", strconv.Itoa(len(body.Bytes())))\n\n\tresp, err := app.Test(req)\n\tutils.AssertEqual(t, nil, err, \"app.Test(req)\")\n\tutils.AssertEqual(t, StatusOK, resp.StatusCode, \"Status code\")\n}\n\n// go test -run Test_Ctx_Secure\nfunc Test_Ctx_Secure(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\t// TODO Add TLS conn\n\tutils.AssertEqual(t, false, c.Secure())\n}\n\n// go test -run Test_Ctx_Stale\nfunc Test_Ctx_Stale(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tutils.AssertEqual(t, true, c.Stale())\n}\n\n// go test -run Test_Ctx_Subdomains\nfunc Test_Ctx_Subdomains(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tc.Request().URI().SetHost(\"john.doe.is.awesome.google.com\")\n\tutils.AssertEqual(t, []string{\"john\", \"doe\"}, c.Subdomains(4))\n\n\tc.Request().URI().SetHost(\"localhost:3000\")\n\tutils.AssertEqual(t, []string{\"localhost:3000\"}, c.Subdomains())\n}\n\n// go test -v -run=^$ -bench=Benchmark_Ctx_Subdomains -benchmem -count=4\nfunc Benchmark_Ctx_Subdomains(b *testing.B) {\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tc.Request().SetRequestURI(\"http://john.doe.google.com\")\n\tvar res []string\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\tres = c.Subdomains()\n\t}\n\tutils.AssertEqual(b, []string{\"john\", \"doe\"}, res)\n}\n\n// go test -run Test_Ctx_ClearCookie\nfunc Test_Ctx_ClearCookie(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tc.Request().Header.Set(HeaderCookie, \"john=doe\")\n\tc.ClearCookie(\"john\")\n\tutils.AssertEqual(t, true, strings.HasPrefix(string(c.Response().Header.Peek(HeaderSetCookie)), \"john=; expires=\"))\n\n\tc.Request().Header.Set(HeaderCookie, \"test1=dummy\")\n\tc.Request().Header.Set(HeaderCookie, \"test2=dummy\")\n\tc.ClearCookie()\n\tutils.AssertEqual(t, true, strings.Contains(string(c.Response().Header.Peek(HeaderSetCookie)), \"test1=; expires=\"))\n\tutils.AssertEqual(t, true, strings.Contains(string(c.Response().Header.Peek(HeaderSetCookie)), \"test2=; expires=\"))\n}\n\n// go test -race -run Test_Ctx_Download\nfunc Test_Ctx_Download(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\n\tutils.AssertEqual(t, nil, c.Download(\"ctx.go\", \"Awesome File!\"))\n\n\tf, err := os.Open(\"./ctx.go\")\n\tutils.AssertEqual(t, nil, err)\n\tdefer func() {\n\t\tutils.AssertEqual(t, nil, f.Close())\n\t}()\n\n\texpect, err := io.ReadAll(f)\n\tutils.AssertEqual(t, nil, err)\n\tutils.AssertEqual(t, expect, c.Response().Body())\n\tutils.AssertEqual(t, `attachment; filename=\"Awesome+File%21\"`, string(c.Response().Header.Peek(HeaderContentDisposition)))\n\n\tutils.AssertEqual(t, nil, c.Download(\"ctx.go\"))\n\tutils.AssertEqual(t, `attachment; filename=\"ctx.go\"`, string(c.Response().Header.Peek(HeaderContentDisposition)))\n}\n\n// go test -race -run Test_Ctx_SendFile\nfunc Test_Ctx_SendFile(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\n\t// fetch file content\n\tf, err := os.Open(\"./ctx.go\")\n\tutils.AssertEqual(t, nil, err)\n\tdefer func() {\n\t\tutils.AssertEqual(t, nil, f.Close())\n\t}()\n\texpectFileContent, err := io.ReadAll(f)\n\tutils.AssertEqual(t, nil, err)\n\t// fetch file info for the not modified test case\n\tfI, err := os.Stat(\"./ctx.go\")\n\tutils.AssertEqual(t, nil, err)\n\n\t// simple test case\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\terr = c.SendFile(\"ctx.go\")\n\t// check expectation\n\tutils.AssertEqual(t, nil, err)\n\tutils.AssertEqual(t, expectFileContent, c.Response().Body())\n\tutils.AssertEqual(t, StatusOK, c.Response().StatusCode())\n\tapp.ReleaseCtx(c)\n\n\t// test with custom error code\n\tc = app.AcquireCtx(&fasthttp.RequestCtx{})\n\terr = c.Status(StatusInternalServerError).SendFile(\"ctx.go\")\n\t// check expectation\n\tutils.AssertEqual(t, nil, err)\n\tutils.AssertEqual(t, expectFileContent, c.Response().Body())\n\tutils.AssertEqual(t, StatusInternalServerError, c.Response().StatusCode())\n\tapp.ReleaseCtx(c)\n\n\t// test not modified\n\tc = app.AcquireCtx(&fasthttp.RequestCtx{})\n\tc.Request().Header.Set(HeaderIfModifiedSince, fI.ModTime().Format(time.RFC1123))\n\terr = c.SendFile(\"ctx.go\")\n\t// check expectation\n\tutils.AssertEqual(t, nil, err)\n\tutils.AssertEqual(t, StatusNotModified, c.Response().StatusCode())\n\tutils.AssertEqual(t, []byte(nil), c.Response().Body())\n\tapp.ReleaseCtx(c)\n}\n\n// go test -race -run Test_Ctx_SendFile_404\nfunc Test_Ctx_SendFile_404(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tapp.Get(\"/\", func(c *Ctx) error {\n\t\terr := c.SendFile(filepath.FromSlash(\"john_dow.go/\"))\n\t\tutils.AssertEqual(t, false, err == nil)\n\t\treturn err\n\t})\n\n\tresp, err := app.Test(httptest.NewRequest(MethodGet, \"/\", nil))\n\tutils.AssertEqual(t, nil, err)\n\tutils.AssertEqual(t, StatusNotFound, resp.StatusCode)\n}\n\n// go test -race -run Test_Ctx_SendFile_Immutable\nfunc Test_Ctx_SendFile_Immutable(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tvar endpointsForTest []string\n\taddEndpoint := func(file, endpoint string) {\n\t\tendpointsForTest = append(endpointsForTest, endpoint)\n\t\tapp.Get(endpoint, func(c *Ctx) error {\n\t\t\tif err := c.SendFile(file); err != nil {\n\t\t\t\tutils.AssertEqual(t, nil, err)\n\t\t\t\treturn err\n\t\t\t}\n\t\t\treturn c.SendStatus(200)\n\t\t})\n\t}\n\n\t// relative paths\n\taddEndpoint(\"./.github/index.html\", \"/relativeWithDot\")\n\taddEndpoint(filepath.FromSlash(\"./.github/index.html\"), \"/relativeOSWithDot\")\n\taddEndpoint(\".github/index.html\", \"/relative\")\n\taddEndpoint(filepath.FromSlash(\".github/index.html\"), \"/relativeOS\")\n\n\t// absolute paths\n\tif path, err := filepath.Abs(\".github/index.html\"); err != nil {\n\t\tutils.AssertEqual(t, nil, err)\n\t} else {\n\t\taddEndpoint(path, \"/absolute\")\n\t\taddEndpoint(filepath.FromSlash(path), \"/absoluteOS\") // os related\n\t}\n\n\tfor _, endpoint := range endpointsForTest {\n\t\tt.Run(endpoint, func(t *testing.T) {\n\t\t\t// 1st try\n\t\t\tresp, err := app.Test(httptest.NewRequest(MethodGet, endpoint, nil))\n\t\t\tutils.AssertEqual(t, nil, err)\n\t\t\tutils.AssertEqual(t, StatusOK, resp.StatusCode)\n\t\t\t// 2nd try\n\t\t\tresp, err = app.Test(httptest.NewRequest(MethodGet, endpoint, nil))\n\t\t\tutils.AssertEqual(t, nil, err)\n\t\t\tutils.AssertEqual(t, StatusOK, resp.StatusCode)\n\t\t})\n\t}\n}\n\n// go test -race -run Test_Ctx_SendFile_RestoreOriginalURL\nfunc Test_Ctx_SendFile_RestoreOriginalURL(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tapp.Get(\"/\", func(c *Ctx) error {\n\t\toriginalURL := utils.CopyString(c.OriginalURL())\n\t\terr := c.SendFile(\"ctx.go\")\n\t\tutils.AssertEqual(t, originalURL, c.OriginalURL())\n\t\treturn err\n\t})\n\n\t_, err1 := app.Test(httptest.NewRequest(MethodGet, \"/?test=true\", nil))\n\t// second request required to confirm with zero allocation\n\t_, err2 := app.Test(httptest.NewRequest(MethodGet, \"/?test=true\", nil))\n\n\tutils.AssertEqual(t, nil, err1)\n\tutils.AssertEqual(t, nil, err2)\n}\n\n// go test -run Test_Ctx_JSON\nfunc Test_Ctx_JSON(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\n\tutils.AssertEqual(t, true, c.JSON(complex(1, 1)) != nil)\n\n\terr := c.JSON(Map{ // map has no order\n\t\t\"Name\": \"Grame\",\n\t\t\"Age\":  20,\n\t})\n\tutils.AssertEqual(t, nil, err)\n\tutils.AssertEqual(t, `{\"Age\":20,\"Name\":\"Grame\"}`, string(c.Response().Body()))\n\tutils.AssertEqual(t, \"application/json\", string(c.Response().Header.Peek(\"content-type\")))\n\n\ttestEmpty := func(v interface{}, r string) {\n\t\terr := c.JSON(v)\n\t\tutils.AssertEqual(t, nil, err)\n\t\tutils.AssertEqual(t, r, string(c.Response().Body()))\n\t}\n\n\ttestEmpty(nil, \"null\")\n\ttestEmpty(\"\", `\"\"`)\n\ttestEmpty(0, \"0\")\n\ttestEmpty([]int{}, \"[]\")\n}\n\n// go test -run=^$ -bench=Benchmark_Ctx_JSON -benchmem -count=4\nfunc Benchmark_Ctx_JSON(b *testing.B) {\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\ttype SomeStruct struct {\n\t\tName string\n\t\tAge  uint8\n\t}\n\tdata := SomeStruct{\n\t\tName: \"Grame\",\n\t\tAge:  20,\n\t}\n\tvar err error\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\terr = c.JSON(data)\n\t}\n\tutils.AssertEqual(b, nil, err)\n\tutils.AssertEqual(b, `{\"Name\":\"Grame\",\"Age\":20}`, string(c.Response().Body()))\n}\n\n// go test -run Test_Ctx_JSONP\nfunc Test_Ctx_JSONP(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\n\tutils.AssertEqual(t, true, c.JSONP(complex(1, 1)) != nil)\n\n\terr := c.JSONP(Map{\n\t\t\"Name\": \"Grame\",\n\t\t\"Age\":  20,\n\t})\n\tutils.AssertEqual(t, nil, err)\n\tutils.AssertEqual(t, `callback({\"Age\":20,\"Name\":\"Grame\"});`, string(c.Response().Body()))\n\tutils.AssertEqual(t, \"text/javascript; charset=utf-8\", string(c.Response().Header.Peek(\"content-type\")))\n\n\terr = c.JSONP(Map{\n\t\t\"Name\": \"Grame\",\n\t\t\"Age\":  20,\n\t}, \"john\")\n\tutils.AssertEqual(t, nil, err)\n\tutils.AssertEqual(t, `john({\"Age\":20,\"Name\":\"Grame\"});`, string(c.Response().Body()))\n\tutils.AssertEqual(t, \"text/javascript; charset=utf-8\", string(c.Response().Header.Peek(\"content-type\")))\n}\n\n// go test -v  -run=^$ -bench=Benchmark_Ctx_JSONP -benchmem -count=4\nfunc Benchmark_Ctx_JSONP(b *testing.B) {\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\ttype SomeStruct struct {\n\t\tName string\n\t\tAge  uint8\n\t}\n\tdata := SomeStruct{\n\t\tName: \"Grame\",\n\t\tAge:  20,\n\t}\n\tcallback := \"emit\"\n\tvar err error\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\terr = c.JSONP(data, callback)\n\t}\n\tutils.AssertEqual(b, nil, err)\n\tutils.AssertEqual(b, `emit({\"Name\":\"Grame\",\"Age\":20});`, string(c.Response().Body()))\n}\n\n// go test -run Test_Ctx_XML\nfunc Test_Ctx_XML(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\n\tutils.AssertEqual(t, true, c.JSON(complex(1, 1)) != nil)\n\n\ttype xmlResult struct {\n\t\tXMLName xml.Name `xml:\"Users\"`\n\t\tNames   []string `xml:\"Names\"`\n\t\tAges    []int    `xml:\"Ages\"`\n\t}\n\n\terr := c.XML(xmlResult{\n\t\tNames: []string{\"Grame\", \"John\"},\n\t\tAges:  []int{1, 12, 20},\n\t})\n\tutils.AssertEqual(t, nil, err)\n\tutils.AssertEqual(t, `<Users><Names>Grame</Names><Names>John</Names><Ages>1</Ages><Ages>12</Ages><Ages>20</Ages></Users>`, string(c.Response().Body()))\n\tutils.AssertEqual(t, \"application/xml\", string(c.Response().Header.Peek(\"content-type\")))\n\n\ttestEmpty := func(v interface{}, r string) {\n\t\terr := c.XML(v)\n\t\tutils.AssertEqual(t, nil, err)\n\t\tutils.AssertEqual(t, r, string(c.Response().Body()))\n\t}\n\n\ttestEmpty(nil, \"\")\n\ttestEmpty(\"\", `<string></string>`)\n\ttestEmpty(0, \"<int>0</int>\")\n\ttestEmpty([]int{}, \"\")\n}\n\n// go test -run=^$ -bench=Benchmark_Ctx_XML -benchmem -count=4\nfunc Benchmark_Ctx_XML(b *testing.B) {\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\ttype SomeStruct struct {\n\t\tName string `xml:\"Name\"`\n\t\tAge  uint8  `xml:\"Age\"`\n\t}\n\tdata := SomeStruct{\n\t\tName: \"Grame\",\n\t\tAge:  20,\n\t}\n\tvar err error\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\terr = c.XML(data)\n\t}\n\n\tutils.AssertEqual(b, nil, err)\n\tutils.AssertEqual(b, `<SomeStruct><Name>Grame</Name><Age>20</Age></SomeStruct>`, string(c.Response().Body()))\n}\n\n// go test -run Test_Ctx_Links\nfunc Test_Ctx_Links(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\n\tc.Links()\n\tutils.AssertEqual(t, \"\", string(c.Response().Header.Peek(HeaderLink)))\n\n\tc.Links(\n\t\t\"http://api.example.com/users?page=2\", \"next\",\n\t\t\"http://api.example.com/users?page=5\", \"last\",\n\t)\n\tutils.AssertEqual(t, `<http://api.example.com/users?page=2>; rel=\"next\",<http://api.example.com/users?page=5>; rel=\"last\"`, string(c.Response().Header.Peek(HeaderLink)))\n}\n\n// go test -v  -run=^$ -bench=Benchmark_Ctx_Links -benchmem -count=4\nfunc Benchmark_Ctx_Links(b *testing.B) {\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\tc.Links(\n\t\t\t\"http://api.example.com/users?page=2\", \"next\",\n\t\t\t\"http://api.example.com/users?page=5\", \"last\",\n\t\t)\n\t}\n}\n\n// go test -run Test_Ctx_Location\nfunc Test_Ctx_Location(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tc.Location(\"http://example.com\")\n\tutils.AssertEqual(t, \"http://example.com\", string(c.Response().Header.Peek(HeaderLocation)))\n}\n\n// go test -run Test_Ctx_Next\nfunc Test_Ctx_Next(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tapp.Use(\"/\", func(c *Ctx) error {\n\t\treturn c.Next()\n\t})\n\tapp.Get(\"/test\", func(c *Ctx) error {\n\t\tc.Set(\"X-Next-Result\", \"Works\")\n\t\treturn nil\n\t})\n\tresp, err := app.Test(httptest.NewRequest(MethodGet, \"http://example.com/test\", nil))\n\tutils.AssertEqual(t, nil, err, \"app.Test(req)\")\n\tutils.AssertEqual(t, StatusOK, resp.StatusCode, \"Status code\")\n\tutils.AssertEqual(t, \"Works\", resp.Header.Get(\"X-Next-Result\"))\n}\n\n// go test -run Test_Ctx_Next_Error\nfunc Test_Ctx_Next_Error(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tapp.Use(\"/\", func(c *Ctx) error {\n\t\tc.Set(\"X-Next-Result\", \"Works\")\n\t\treturn ErrNotFound\n\t})\n\n\tresp, err := app.Test(httptest.NewRequest(MethodGet, \"http://example.com/test\", nil))\n\tutils.AssertEqual(t, nil, err, \"app.Test(req)\")\n\tutils.AssertEqual(t, StatusNotFound, resp.StatusCode, \"Status code\")\n\tutils.AssertEqual(t, \"Works\", resp.Header.Get(\"X-Next-Result\"))\n}\n\n// go test -run Test_Ctx_Redirect\nfunc Test_Ctx_Redirect(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\n\terr := c.Redirect(\"http://default.com\")\n\tutils.AssertEqual(t, nil, err)\n\tutils.AssertEqual(t, 302, c.Response().StatusCode())\n\tutils.AssertEqual(t, \"http://default.com\", string(c.Response().Header.Peek(HeaderLocation)))\n\n\terr = c.Redirect(\"http://example.com\", 301)\n\tutils.AssertEqual(t, nil, err)\n\tutils.AssertEqual(t, 301, c.Response().StatusCode())\n\tutils.AssertEqual(t, \"http://example.com\", string(c.Response().Header.Peek(HeaderLocation)))\n}\n\n// go test -run Test_Ctx_RedirectToRouteWithParams\nfunc Test_Ctx_RedirectToRouteWithParams(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tapp.Get(\"/user/:name\", func(c *Ctx) error {\n\t\treturn c.JSON(c.Params(\"name\"))\n\t}).Name(\"user\")\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\n\terr := c.RedirectToRoute(\"user\", Map{\n\t\t\"name\": \"fiber\",\n\t})\n\tutils.AssertEqual(t, nil, err)\n\tutils.AssertEqual(t, 302, c.Response().StatusCode())\n\tutils.AssertEqual(t, \"/user/fiber\", string(c.Response().Header.Peek(HeaderLocation)))\n}\n\n// go test -run Test_Ctx_RedirectToRouteWithParams\nfunc Test_Ctx_RedirectToRouteWithQueries(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tapp.Get(\"/user/:name\", func(c *Ctx) error {\n\t\treturn c.JSON(c.Params(\"name\"))\n\t}).Name(\"user\")\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\n\terr := c.RedirectToRoute(\"user\", Map{\n\t\t\"name\":    \"fiber\",\n\t\t\"queries\": map[string]string{\"data[0][name]\": \"john\", \"data[0][age]\": \"10\", \"test\": \"doe\"},\n\t})\n\tutils.AssertEqual(t, nil, err)\n\tutils.AssertEqual(t, 302, c.Response().StatusCode())\n\t// analysis of query parameters with url parsing, since a map pass is always randomly ordered\n\tlocation, err := url.Parse(string(c.Response().Header.Peek(HeaderLocation)))\n\tutils.AssertEqual(t, nil, err, \"url.Parse(location)\")\n\tutils.AssertEqual(t, \"/user/fiber\", location.Path)\n\tutils.AssertEqual(t, url.Values{\"data[0][name]\": []string{\"john\"}, \"data[0][age]\": []string{\"10\"}, \"test\": []string{\"doe\"}}, location.Query())\n}\n\n// go test -run Test_Ctx_RedirectToRouteWithOptionalParams\nfunc Test_Ctx_RedirectToRouteWithOptionalParams(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tapp.Get(\"/user/:name?\", func(c *Ctx) error {\n\t\treturn c.JSON(c.Params(\"name\"))\n\t}).Name(\"user\")\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\n\terr := c.RedirectToRoute(\"user\", Map{\n\t\t\"name\": \"fiber\",\n\t})\n\tutils.AssertEqual(t, nil, err)\n\tutils.AssertEqual(t, 302, c.Response().StatusCode())\n\tutils.AssertEqual(t, \"/user/fiber\", string(c.Response().Header.Peek(HeaderLocation)))\n}\n\n// go test -run Test_Ctx_RedirectToRouteWithOptionalParamsWithoutValue\nfunc Test_Ctx_RedirectToRouteWithOptionalParamsWithoutValue(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tapp.Get(\"/user/:name?\", func(c *Ctx) error {\n\t\treturn c.JSON(c.Params(\"name\"))\n\t}).Name(\"user\")\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\n\terr := c.RedirectToRoute(\"user\", Map{})\n\tutils.AssertEqual(t, nil, err)\n\tutils.AssertEqual(t, 302, c.Response().StatusCode())\n\tutils.AssertEqual(t, \"/user/\", string(c.Response().Header.Peek(HeaderLocation)))\n}\n\n// go test -run Test_Ctx_RedirectToRouteWithGreedyParameters\nfunc Test_Ctx_RedirectToRouteWithGreedyParameters(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tapp.Get(\"/user/+\", func(c *Ctx) error {\n\t\treturn c.JSON(c.Params(\"+\"))\n\t}).Name(\"user\")\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\n\terr := c.RedirectToRoute(\"user\", Map{\n\t\t\"+\": \"test/routes\",\n\t})\n\tutils.AssertEqual(t, nil, err)\n\tutils.AssertEqual(t, 302, c.Response().StatusCode())\n\tutils.AssertEqual(t, \"/user/test/routes\", string(c.Response().Header.Peek(HeaderLocation)))\n}\n\n// go test -run Test_Ctx_RedirectBack\nfunc Test_Ctx_RedirectBack(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tapp.Get(\"/\", func(c *Ctx) error {\n\t\treturn c.JSON(\"Home\")\n\t}).Name(\"home\")\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\terr := c.RedirectBack(\"/\")\n\tutils.AssertEqual(t, nil, err)\n\tutils.AssertEqual(t, 302, c.Response().StatusCode())\n\tutils.AssertEqual(t, \"/\", string(c.Response().Header.Peek(HeaderLocation)))\n}\n\n// go test -run Test_Ctx_RedirectBackWithReferer\nfunc Test_Ctx_RedirectBackWithReferer(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tapp.Get(\"/\", func(c *Ctx) error {\n\t\treturn c.JSON(\"Home\")\n\t}).Name(\"home\")\n\tapp.Get(\"/back\", func(c *Ctx) error {\n\t\treturn c.JSON(\"Back\")\n\t}).Name(\"back\")\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tc.Request().Header.Set(HeaderReferer, \"/back\")\n\terr := c.RedirectBack(\"/\")\n\tutils.AssertEqual(t, nil, err)\n\tutils.AssertEqual(t, 302, c.Response().StatusCode())\n\tutils.AssertEqual(t, \"/back\", c.Get(HeaderReferer))\n\tutils.AssertEqual(t, \"/back\", string(c.Response().Header.Peek(HeaderLocation)))\n}\n\n// go test -run Test_Ctx_Render\nfunc Test_Ctx_Render(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\terr := c.Render(\"./.github/testdata/index.tmpl\", Map{\n\t\t\"Title\": \"Hello, World!\",\n\t})\n\tutils.AssertEqual(t, nil, err)\n\n\tbuf := bytebufferpool.Get()\n\t_, _ = buf.WriteString(\"overwrite\") //nolint:errcheck // This will never fail\n\tdefer bytebufferpool.Put(buf)\n\n\tutils.AssertEqual(t, \"<h1>Hello, World!</h1>\", string(c.Response().Body()))\n\n\terr = c.Render(\"./.github/testdata/template-non-exists.html\", nil)\n\tutils.AssertEqual(t, false, err == nil)\n\n\terr = c.Render(\"./.github/testdata/template-invalid.html\", nil)\n\tutils.AssertEqual(t, false, err == nil)\n}\n\nfunc Test_Ctx_RenderWithoutLocals(t *testing.T) {\n\tt.Parallel()\n\tapp := New(Config{\n\t\tPassLocalsToViews: false,\n\t})\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\tc.Locals(\"Title\", \"Hello, World!\")\n\tdefer app.ReleaseCtx(c)\n\terr := c.Render(\"./.github/testdata/index.tmpl\", Map{})\n\tutils.AssertEqual(t, nil, err)\n\n\tbuf := bytebufferpool.Get()\n\t_, _ = buf.WriteString(\"overwrite\") //nolint:errcheck // This will never fail\n\tdefer bytebufferpool.Put(buf)\n\n\tutils.AssertEqual(t, \"<h1><no value></h1>\", string(c.Response().Body()))\n}\n\nfunc Test_Ctx_RenderWithLocals(t *testing.T) {\n\tt.Parallel()\n\tapp := New(Config{\n\t\tPassLocalsToViews: true,\n\t})\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\tc.Locals(\"Title\", \"Hello, World!\")\n\tdefer app.ReleaseCtx(c)\n\terr := c.Render(\"./.github/testdata/index.tmpl\", Map{})\n\tutils.AssertEqual(t, nil, err)\n\n\tbuf := bytebufferpool.Get()\n\t_, _ = buf.WriteString(\"overwrite\") //nolint:errcheck // This will never fail\n\tdefer bytebufferpool.Put(buf)\n\n\tutils.AssertEqual(t, \"<h1>Hello, World!</h1>\", string(c.Response().Body()))\n}\n\nfunc Test_Ctx_RenderWithBind(t *testing.T) {\n\tt.Parallel()\n\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\terr := c.Bind(Map{\n\t\t\"Title\": \"Hello, World!\",\n\t})\n\tutils.AssertEqual(t, nil, err)\n\tdefer app.ReleaseCtx(c)\n\terr = c.Render(\"./.github/testdata/index.tmpl\", Map{})\n\tutils.AssertEqual(t, nil, err)\n\n\tbuf := bytebufferpool.Get()\n\t_, _ = buf.WriteString(\"overwrite\") //nolint:errcheck // This will never fail\n\tdefer bytebufferpool.Put(buf)\n\n\tutils.AssertEqual(t, \"<h1>Hello, World!</h1>\", string(c.Response().Body()))\n}\n\nfunc Test_Ctx_RenderWithOverwrittenBind(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\terr := c.Bind(Map{\n\t\t\"Title\": \"Hello, World!\",\n\t})\n\tutils.AssertEqual(t, nil, err)\n\tdefer app.ReleaseCtx(c)\n\terr = c.Render(\"./.github/testdata/index.tmpl\", Map{\n\t\t\"Title\": \"Hello from Fiber!\",\n\t})\n\tutils.AssertEqual(t, nil, err)\n\n\tbuf := bytebufferpool.Get()\n\t_, _ = buf.WriteString(\"overwrite\") //nolint:errcheck // This will never fail\n\tdefer bytebufferpool.Put(buf)\n\n\tutils.AssertEqual(t, \"<h1>Hello from Fiber!</h1>\", string(c.Response().Body()))\n}\n\nfunc Test_Ctx_RenderWithBindLocals(t *testing.T) {\n\tt.Parallel()\n\tapp := New(Config{\n\t\tPassLocalsToViews: true,\n\t})\n\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\terr := c.Bind(Map{\n\t\t\"Title\": \"Hello, World!\",\n\t})\n\tutils.AssertEqual(t, nil, err)\n\n\tc.Locals(\"Summary\", \"Test\")\n\tdefer app.ReleaseCtx(c)\n\n\terr = c.Render(\"./.github/testdata/template.tmpl\", Map{})\n\tutils.AssertEqual(t, nil, err)\n\n\tutils.AssertEqual(t, \"<h1>Hello, World! Test</h1>\", string(c.Response().Body()))\n}\n\nfunc Test_Ctx_RenderWithLocalsAndBinding(t *testing.T) {\n\tt.Parallel()\n\tengine := &testTemplateEngine{}\n\terr := engine.Load()\n\tutils.AssertEqual(t, nil, err)\n\tapp := New(Config{\n\t\tPassLocalsToViews: true,\n\t\tViews:             engine,\n\t})\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\tc.Locals(\"Title\", \"This is a test.\")\n\tdefer app.ReleaseCtx(c)\n\n\terr = c.Render(\"index.tmpl\", Map{\n\t\t\"Title\": \"Hello, World!\",\n\t})\n\tutils.AssertEqual(t, nil, err)\n\n\tutils.AssertEqual(t, \"<h1>Hello, World!</h1>\", string(c.Response().Body()))\n}\n\nfunc Benchmark_Ctx_RenderWithLocalsAndBinding(b *testing.B) {\n\tengine := &testTemplateEngine{}\n\terr := engine.Load()\n\tutils.AssertEqual(b, nil, err)\n\tutils.AssertEqual(b, nil, err)\n\tapp := New(Config{\n\t\tPassLocalsToViews: true,\n\t\tViews:             engine,\n\t})\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\terr = c.Bind(Map{\n\t\t\"Title\": \"Hello, World!\",\n\t})\n\tutils.AssertEqual(b, nil, err)\n\tc.Locals(\"Summary\", \"Test\")\n\n\tdefer app.ReleaseCtx(c)\n\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\n\tfor n := 0; n < b.N; n++ {\n\t\terr = c.Render(\"template.tmpl\", Map{})\n\t}\n\tutils.AssertEqual(b, nil, err)\n\n\tutils.AssertEqual(b, \"<h1>Hello, World! Test</h1>\", string(c.Response().Body()))\n}\n\nfunc Benchmark_Ctx_RedirectToRoute(b *testing.B) {\n\tapp := New()\n\tapp.Get(\"/user/:name\", func(c *Ctx) error {\n\t\treturn c.JSON(c.Params(\"name\"))\n\t}).Name(\"user\")\n\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\n\tvar err error\n\tfor n := 0; n < b.N; n++ {\n\t\terr = c.RedirectToRoute(\"user\", Map{\n\t\t\t\"name\": \"fiber\",\n\t\t})\n\t}\n\tutils.AssertEqual(b, nil, err)\n\n\tutils.AssertEqual(b, 302, c.Response().StatusCode())\n\tutils.AssertEqual(b, \"/user/fiber\", string(c.Response().Header.Peek(HeaderLocation)))\n}\n\nfunc Benchmark_Ctx_RedirectToRouteWithQueries(b *testing.B) {\n\tapp := New()\n\tapp.Get(\"/user/:name\", func(c *Ctx) error {\n\t\treturn c.JSON(c.Params(\"name\"))\n\t}).Name(\"user\")\n\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\n\tvar err error\n\tfor n := 0; n < b.N; n++ {\n\t\terr = c.RedirectToRoute(\"user\", Map{\n\t\t\t\"name\":    \"fiber\",\n\t\t\t\"queries\": map[string]string{\"a\": \"a\", \"b\": \"b\"},\n\t\t})\n\t}\n\tutils.AssertEqual(b, nil, err)\n\n\tutils.AssertEqual(b, 302, c.Response().StatusCode())\n\t// analysis of query parameters with url parsing, since a map pass is always randomly ordered\n\tlocation, err := url.Parse(string(c.Response().Header.Peek(HeaderLocation)))\n\tutils.AssertEqual(b, nil, err, \"url.Parse(location)\")\n\tutils.AssertEqual(b, \"/user/fiber\", location.Path)\n\tutils.AssertEqual(b, url.Values{\"a\": []string{\"a\"}, \"b\": []string{\"b\"}}, location.Query())\n}\n\nfunc Benchmark_Ctx_RenderLocals(b *testing.B) {\n\tengine := &testTemplateEngine{}\n\terr := engine.Load()\n\tutils.AssertEqual(b, nil, err)\n\tapp := New(Config{\n\t\tPassLocalsToViews: true,\n\t})\n\tapp.config.Views = engine\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\tc.Locals(\"Title\", \"Hello, World!\")\n\n\tdefer app.ReleaseCtx(c)\n\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\n\tfor n := 0; n < b.N; n++ {\n\t\terr = c.Render(\"index.tmpl\", Map{})\n\t}\n\tutils.AssertEqual(b, nil, err)\n\n\tutils.AssertEqual(b, \"<h1>Hello, World!</h1>\", string(c.Response().Body()))\n}\n\nfunc Benchmark_Ctx_RenderBind(b *testing.B) {\n\tengine := &testTemplateEngine{}\n\terr := engine.Load()\n\tutils.AssertEqual(b, nil, err)\n\tapp := New()\n\tapp.config.Views = engine\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\terr = c.Bind(Map{\n\t\t\"Title\": \"Hello, World!\",\n\t})\n\tutils.AssertEqual(b, nil, err)\n\n\tdefer app.ReleaseCtx(c)\n\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\n\tfor n := 0; n < b.N; n++ {\n\t\terr = c.Render(\"index.tmpl\", Map{})\n\t}\n\tutils.AssertEqual(b, nil, err)\n\n\tutils.AssertEqual(b, \"<h1>Hello, World!</h1>\", string(c.Response().Body()))\n}\n\n// go test -run Test_Ctx_RestartRouting\nfunc Test_Ctx_RestartRouting(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tcalls := 0\n\tapp.Get(\"/\", func(c *Ctx) error {\n\t\tcalls++\n\t\tif calls < 3 {\n\t\t\treturn c.RestartRouting()\n\t\t}\n\t\treturn nil\n\t})\n\tresp, err := app.Test(httptest.NewRequest(MethodGet, \"http://example.com/\", nil))\n\tutils.AssertEqual(t, nil, err, \"app.Test(req)\")\n\tutils.AssertEqual(t, StatusOK, resp.StatusCode, \"Status code\")\n\tutils.AssertEqual(t, 3, calls, \"Number of calls\")\n}\n\n// go test -run Test_Ctx_RestartRoutingWithChangedPath\nfunc Test_Ctx_RestartRoutingWithChangedPath(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tvar executedOldHandler, executedNewHandler bool\n\n\tapp.Get(\"/old\", func(c *Ctx) error {\n\t\tc.Path(\"/new\")\n\t\treturn c.RestartRouting()\n\t})\n\tapp.Get(\"/old\", func(c *Ctx) error {\n\t\texecutedOldHandler = true\n\t\treturn nil\n\t})\n\tapp.Get(\"/new\", func(c *Ctx) error {\n\t\texecutedNewHandler = true\n\t\treturn nil\n\t})\n\n\tresp, err := app.Test(httptest.NewRequest(MethodGet, \"http://example.com/old\", nil))\n\tutils.AssertEqual(t, nil, err, \"app.Test(req)\")\n\tutils.AssertEqual(t, StatusOK, resp.StatusCode, \"Status code\")\n\tutils.AssertEqual(t, false, executedOldHandler, \"Executed old handler\")\n\tutils.AssertEqual(t, true, executedNewHandler, \"Executed new handler\")\n}\n\n// go test -run Test_Ctx_RestartRoutingWithChangedPathAnd404\nfunc Test_Ctx_RestartRoutingWithChangedPathAndCatchAll(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tapp.Get(\"/new\", func(c *Ctx) error {\n\t\treturn nil\n\t})\n\tapp.Use(func(c *Ctx) error {\n\t\tc.Path(\"/new\")\n\t\t// c.Next() would fail this test as a 404 is returned from the next handler\n\t\treturn c.RestartRouting()\n\t})\n\tapp.Use(func(c *Ctx) error {\n\t\treturn ErrNotFound\n\t})\n\n\tresp, err := app.Test(httptest.NewRequest(MethodGet, \"http://example.com/old\", nil))\n\tutils.AssertEqual(t, nil, err, \"app.Test(req)\")\n\tutils.AssertEqual(t, StatusOK, resp.StatusCode, \"Status code\")\n}\n\ntype testTemplateEngine struct {\n\ttemplates *template.Template\n\tpath      string\n}\n\nfunc (t *testTemplateEngine) Render(w io.Writer, name string, bind interface{}, layout ...string) error {\n\tif len(layout) == 0 {\n\t\tif err := t.templates.ExecuteTemplate(w, name, bind); err != nil {\n\t\t\treturn fmt.Errorf(\"failed to execute template without layout: %w\", err)\n\t\t}\n\t\treturn nil\n\t}\n\tif err := t.templates.ExecuteTemplate(w, name, bind); err != nil {\n\t\treturn fmt.Errorf(\"failed to execute template: %w\", err)\n\t}\n\tif err := t.templates.ExecuteTemplate(w, layout[0], bind); err != nil {\n\t\treturn fmt.Errorf(\"failed to execute template with layout: %w\", err)\n\t}\n\treturn nil\n}\n\nfunc (t *testTemplateEngine) Load() error {\n\tif t.path == \"\" {\n\t\tt.path = \"testdata\"\n\t}\n\tt.templates = template.Must(template.ParseGlob(\"./.github/\" + t.path + \"/*.tmpl\"))\n\treturn nil\n}\n\n// go test -run Test_Ctx_Render_Engine\nfunc Test_Ctx_Render_Engine(t *testing.T) {\n\tt.Parallel()\n\tengine := &testTemplateEngine{}\n\tutils.AssertEqual(t, nil, engine.Load())\n\tapp := New()\n\tapp.config.Views = engine\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\terr := c.Render(\"index.tmpl\", Map{\n\t\t\"Title\": \"Hello, World!\",\n\t})\n\tutils.AssertEqual(t, nil, err)\n\tutils.AssertEqual(t, \"<h1>Hello, World!</h1>\", string(c.Response().Body()))\n}\n\n// go test -run Test_Ctx_Render_Engine_With_View_Layout\nfunc Test_Ctx_Render_Engine_With_View_Layout(t *testing.T) {\n\tt.Parallel()\n\tengine := &testTemplateEngine{}\n\tutils.AssertEqual(t, nil, engine.Load())\n\tapp := New(Config{ViewsLayout: \"main.tmpl\"})\n\tapp.config.Views = engine\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\terr := c.Render(\"index.tmpl\", Map{\n\t\t\"Title\": \"Hello, World!\",\n\t})\n\tutils.AssertEqual(t, nil, err)\n\tutils.AssertEqual(t, \"<h1>Hello, World!</h1><h1>I'm main</h1>\", string(c.Response().Body()))\n}\n\n// go test -v -run=^$ -bench=Benchmark_Ctx_Render_Engine -benchmem -count=4\nfunc Benchmark_Ctx_Render_Engine(b *testing.B) {\n\tengine := &testTemplateEngine{}\n\terr := engine.Load()\n\tutils.AssertEqual(b, nil, err)\n\tapp := New()\n\tapp.config.Views = engine\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\terr = c.Render(\"index.tmpl\", Map{\n\t\t\t\"Title\": \"Hello, World!\",\n\t\t})\n\t}\n\tutils.AssertEqual(b, nil, err)\n\tutils.AssertEqual(b, \"<h1>Hello, World!</h1>\", string(c.Response().Body()))\n}\n\n// go test -v -run=^$ -bench=Benchmark_Ctx_Get_Location_From_Route -benchmem -count=4\nfunc Benchmark_Ctx_Get_Location_From_Route(b *testing.B) {\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tapp.Get(\"/user/:name\", func(c *Ctx) error {\n\t\treturn c.SendString(c.Params(\"name\"))\n\t}).Name(\"User\")\n\n\tvar err error\n\tvar location string\n\tfor n := 0; n < b.N; n++ {\n\t\tlocation, err = c.getLocationFromRoute(app.GetRoute(\"User\"), Map{\"name\": \"fiber\"})\n\t}\n\tutils.AssertEqual(b, \"/user/fiber\", location)\n\tutils.AssertEqual(b, nil, err)\n}\n\n// go test -run Test_Ctx_Get_Location_From_Route_name\nfunc Test_Ctx_Get_Location_From_Route_name(t *testing.T) {\n\tt.Parallel()\n\n\tt.Run(\"case insensitive\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tapp := New()\n\t\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\t\tdefer app.ReleaseCtx(c)\n\t\tapp.Get(\"/user/:name\", func(c *Ctx) error {\n\t\t\treturn c.SendString(c.Params(\"name\"))\n\t\t}).Name(\"User\")\n\n\t\tlocation, err := c.GetRouteURL(\"User\", Map{\"name\": \"fiber\"})\n\t\tutils.AssertEqual(t, nil, err)\n\t\tutils.AssertEqual(t, \"/user/fiber\", location)\n\n\t\tlocation, err = c.GetRouteURL(\"User\", Map{\"Name\": \"fiber\"})\n\t\tutils.AssertEqual(t, nil, err)\n\t\tutils.AssertEqual(t, \"/user/fiber\", location)\n\t})\n\n\tt.Run(\"case sensitive\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tapp := New(Config{CaseSensitive: true})\n\t\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\t\tdefer app.ReleaseCtx(c)\n\t\tapp.Get(\"/user/:name\", func(c *Ctx) error {\n\t\t\treturn c.SendString(c.Params(\"name\"))\n\t\t}).Name(\"User\")\n\n\t\tlocation, err := c.GetRouteURL(\"User\", Map{\"name\": \"fiber\"})\n\t\tutils.AssertEqual(t, nil, err)\n\t\tutils.AssertEqual(t, \"/user/fiber\", location)\n\n\t\tlocation, err = c.GetRouteURL(\"User\", Map{\"Name\": \"fiber\"})\n\t\tutils.AssertEqual(t, nil, err)\n\t\tutils.AssertEqual(t, \"/user/\", location)\n\t})\n}\n\n// go test -run Test_Ctx_Get_Location_From_Route_name_Optional_greedy\nfunc Test_Ctx_Get_Location_From_Route_name_Optional_greedy(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tapp.Get(\"/:phone/*/send/*\", func(c *Ctx) error {\n\t\treturn c.SendString(\"Phone: \" + c.Params(\"phone\") + \"\\nFirst Param: \" + c.Params(\"*1\") + \"\\nSecond Param: \" + c.Params(\"*2\"))\n\t}).Name(\"SendSms\")\n\n\tlocation, err := c.GetRouteURL(\"SendSms\", Map{\n\t\t\"phone\": \"23456789\",\n\t\t\"*1\":    \"sms\",\n\t\t\"*2\":    \"test-msg\",\n\t})\n\tutils.AssertEqual(t, nil, err)\n\tutils.AssertEqual(t, \"/23456789/sms/send/test-msg\", location)\n}\n\n// go test -run Test_Ctx_Get_Location_From_Route_name_Optional_greedy_one_param\nfunc Test_Ctx_Get_Location_From_Route_name_Optional_greedy_one_param(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tapp.Get(\"/:phone/*/send\", func(c *Ctx) error {\n\t\treturn c.SendString(\"Phone: \" + c.Params(\"phone\") + \"\\nFirst Param: \" + c.Params(\"*1\"))\n\t}).Name(\"SendSms\")\n\n\tlocation, err := c.GetRouteURL(\"SendSms\", Map{\n\t\t\"phone\": \"23456789\",\n\t\t\"*\":     \"sms\",\n\t})\n\tutils.AssertEqual(t, nil, err)\n\tutils.AssertEqual(t, \"/23456789/sms/send\", location)\n}\n\ntype errorTemplateEngine struct{}\n\nfunc (errorTemplateEngine) Render(_ io.Writer, _ string, _ interface{}, _ ...string) error {\n\treturn errors.New(\"errorTemplateEngine\")\n}\n\nfunc (errorTemplateEngine) Load() error { return nil }\n\n// go test -run Test_Ctx_Render_Engine_Error\nfunc Test_Ctx_Render_Engine_Error(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tapp.config.Views = errorTemplateEngine{}\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\terr := c.Render(\"index.tmpl\", nil)\n\tutils.AssertEqual(t, false, err == nil)\n}\n\n// go test -run Test_Ctx_Render_Go_Template\nfunc Test_Ctx_Render_Go_Template(t *testing.T) {\n\tt.Parallel()\n\tfile, err := os.CreateTemp(os.TempDir(), \"fiber\")\n\tutils.AssertEqual(t, nil, err)\n\tdefer func() {\n\t\terr := os.Remove(file.Name())\n\t\tutils.AssertEqual(t, nil, err)\n\t}()\n\n\t_, err = file.Write([]byte(\"template\"))\n\tutils.AssertEqual(t, nil, err)\n\n\terr = file.Close()\n\tutils.AssertEqual(t, nil, err)\n\n\tapp := New()\n\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\n\terr = c.Render(file.Name(), nil)\n\tutils.AssertEqual(t, nil, err)\n\tutils.AssertEqual(t, \"template\", string(c.Response().Body()))\n}\n\n// go test -run Test_Ctx_Send\nfunc Test_Ctx_Send(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tutils.AssertEqual(t, nil, c.Send([]byte(\"Hello, World\")))\n\tutils.AssertEqual(t, nil, c.Send([]byte(\"Don't crash please\")))\n\tutils.AssertEqual(t, nil, c.Send([]byte(\"1337\")))\n\tutils.AssertEqual(t, \"1337\", string(c.Response().Body()))\n}\n\n// go test -v  -run=^$ -bench=Benchmark_Ctx_Send -benchmem -count=4\nfunc Benchmark_Ctx_Send(b *testing.B) {\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tbyt := []byte(\"Hello, World!\")\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\n\tvar err error\n\tfor n := 0; n < b.N; n++ {\n\t\terr = c.Send(byt)\n\t}\n\tutils.AssertEqual(b, nil, err)\n\tutils.AssertEqual(b, \"Hello, World!\", string(c.Response().Body()))\n}\n\n// go test -run Test_Ctx_SendStatus\nfunc Test_Ctx_SendStatus(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\terr := c.SendStatus(415)\n\tutils.AssertEqual(t, nil, err)\n\tutils.AssertEqual(t, 415, c.Response().StatusCode())\n\tutils.AssertEqual(t, \"Unsupported Media Type\", string(c.Response().Body()))\n}\n\n// go test -run Test_Ctx_SendString\nfunc Test_Ctx_SendString(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\terr := c.SendString(\"Don't crash please\")\n\tutils.AssertEqual(t, nil, err)\n\tutils.AssertEqual(t, \"Don't crash please\", string(c.Response().Body()))\n}\n\n// go test -run Test_Ctx_SendStream\nfunc Test_Ctx_SendStream(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\n\terr := c.SendStream(bytes.NewReader([]byte(\"Don't crash please\")))\n\tutils.AssertEqual(t, nil, err)\n\tutils.AssertEqual(t, \"Don't crash please\", string(c.Response().Body()))\n\n\terr = c.SendStream(bytes.NewReader([]byte(\"Don't crash please\")), len([]byte(\"Don't crash please\")))\n\tutils.AssertEqual(t, nil, err)\n\tutils.AssertEqual(t, \"Don't crash please\", string(c.Response().Body()))\n\n\terr = c.SendStream(bufio.NewReader(bytes.NewReader([]byte(\"Hello bufio\"))))\n\tutils.AssertEqual(t, nil, err)\n\tutils.AssertEqual(t, \"Hello bufio\", string(c.Response().Body()))\n}\n\n// go test -run Test_Ctx_Set\nfunc Test_Ctx_Set(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tc.Set(\"X-1\", \"1\")\n\tc.Set(\"X-2\", \"2\")\n\tc.Set(\"X-3\", \"3\")\n\tc.Set(\"X-3\", \"1337\")\n\tutils.AssertEqual(t, \"1\", string(c.Response().Header.Peek(\"x-1\")))\n\tutils.AssertEqual(t, \"2\", string(c.Response().Header.Peek(\"x-2\")))\n\tutils.AssertEqual(t, \"1337\", string(c.Response().Header.Peek(\"x-3\")))\n}\n\n// go test -run Test_Ctx_Set_Splitter\nfunc Test_Ctx_Set_Splitter(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\n\tc.Set(\"Location\", \"foo\\r\\nSet-Cookie:%20SESSIONID=MaliciousValue\\r\\n\")\n\th := string(c.Response().Header.Peek(\"Location\"))\n\tutils.AssertEqual(t, false, strings.Contains(h, \"\\r\\n\"), h)\n\n\tc.Set(\"Location\", \"foo\\nSet-Cookie:%20SESSIONID=MaliciousValue\\n\")\n\th = string(c.Response().Header.Peek(\"Location\"))\n\tutils.AssertEqual(t, false, strings.Contains(h, \"\\n\"), h)\n}\n\n// go test -v  -run=^$ -bench=Benchmark_Ctx_Set -benchmem -count=4\nfunc Benchmark_Ctx_Set(b *testing.B) {\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tval := \"1431-15132-3423\"\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\tc.Set(HeaderXRequestID, val)\n\t}\n}\n\n// go test -run Test_Ctx_Status\nfunc Test_Ctx_Status(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tc.Status(400)\n\tutils.AssertEqual(t, 400, c.Response().StatusCode())\n\terr := c.Status(415).Send([]byte(\"Hello, World\"))\n\tutils.AssertEqual(t, nil, err)\n\tutils.AssertEqual(t, 415, c.Response().StatusCode())\n\tutils.AssertEqual(t, \"Hello, World\", string(c.Response().Body()))\n}\n\n// go test -run Test_Ctx_Type\nfunc Test_Ctx_Type(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tc.Type(\".json\")\n\tutils.AssertEqual(t, \"application/json\", string(c.Response().Header.Peek(\"Content-Type\")))\n\n\tc.Type(\"json\", \"utf-8\")\n\tutils.AssertEqual(t, \"application/json; charset=utf-8\", string(c.Response().Header.Peek(\"Content-Type\")))\n\n\tc.Type(\".html\")\n\tutils.AssertEqual(t, \"text/html\", string(c.Response().Header.Peek(\"Content-Type\")))\n\n\tc.Type(\"html\", \"utf-8\")\n\tutils.AssertEqual(t, \"text/html; charset=utf-8\", string(c.Response().Header.Peek(\"Content-Type\")))\n}\n\n// go test -v  -run=^$ -bench=Benchmark_Ctx_Type -benchmem -count=4\nfunc Benchmark_Ctx_Type(b *testing.B) {\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\tc.Type(\".json\")\n\t\tc.Type(\"json\")\n\t}\n}\n\n// go test -v  -run=^$ -bench=Benchmark_Ctx_Type_Charset -benchmem -count=4\nfunc Benchmark_Ctx_Type_Charset(b *testing.B) {\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\tc.Type(\".json\", \"utf-8\")\n\t\tc.Type(\"json\", \"utf-8\")\n\t}\n}\n\n// go test -run Test_Ctx_Vary\nfunc Test_Ctx_Vary(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tc.Vary(\"Origin\")\n\tc.Vary(\"User-Agent\")\n\tc.Vary(\"Accept-Encoding\", \"Accept\")\n\tutils.AssertEqual(t, \"Origin, User-Agent, Accept-Encoding, Accept\", string(c.Response().Header.Peek(\"Vary\")))\n}\n\n// go test -v  -run=^$ -bench=Benchmark_Ctx_Vary -benchmem -count=4\nfunc Benchmark_Ctx_Vary(b *testing.B) {\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\tc.Vary(\"Origin\", \"User-Agent\")\n\t}\n}\n\n// go test -run Test_Ctx_Write\nfunc Test_Ctx_Write(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\t_, err := c.Write([]byte(\"Hello, \"))\n\tutils.AssertEqual(t, nil, err)\n\t_, err = c.Write([]byte(\"World!\"))\n\tutils.AssertEqual(t, nil, err)\n\tutils.AssertEqual(t, \"Hello, World!\", string(c.Response().Body()))\n}\n\n// go test -v -run=^$ -bench=Benchmark_Ctx_Write -benchmem -count=4\nfunc Benchmark_Ctx_Write(b *testing.B) {\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tbyt := []byte(\"Hello, World!\")\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\n\tvar err error\n\tfor n := 0; n < b.N; n++ {\n\t\t_, err = c.Write(byt)\n\t}\n\tutils.AssertEqual(b, nil, err)\n}\n\n// go test -run Test_Ctx_Writef\nfunc Test_Ctx_Writef(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tworld := \"World!\"\n\t_, err := c.Writef(\"Hello, %s\", world)\n\tutils.AssertEqual(t, nil, err)\n\tutils.AssertEqual(t, \"Hello, World!\", string(c.Response().Body()))\n}\n\n// go test -v -run=^$ -bench=Benchmark_Ctx_Writef -benchmem -count=4\nfunc Benchmark_Ctx_Writef(b *testing.B) {\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tworld := \"World!\"\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\n\tvar err error\n\tfor n := 0; n < b.N; n++ {\n\t\t_, err = c.Writef(\"Hello, %s\", world)\n\t}\n\tutils.AssertEqual(b, nil, err)\n}\n\n// go test -run Test_Ctx_WriteString\nfunc Test_Ctx_WriteString(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\t_, err := c.WriteString(\"Hello, \")\n\tutils.AssertEqual(t, nil, err)\n\t_, err = c.WriteString(\"World!\")\n\tutils.AssertEqual(t, nil, err)\n\tutils.AssertEqual(t, \"Hello, World!\", string(c.Response().Body()))\n}\n\n// go test -run Test_Ctx_XHR\nfunc Test_Ctx_XHR(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tc.Request().Header.Set(HeaderXRequestedWith, \"XMLHttpRequest\")\n\tutils.AssertEqual(t, true, c.XHR())\n}\n\n// go test -run=^$ -bench=Benchmark_Ctx_XHR -benchmem -count=4\nfunc Benchmark_Ctx_XHR(b *testing.B) {\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tc.Request().Header.Set(HeaderXRequestedWith, \"XMLHttpRequest\")\n\tvar equal bool\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\tequal = c.XHR()\n\t}\n\tutils.AssertEqual(b, true, equal)\n}\n\n// go test -v  -run=^$ -bench=Benchmark_Ctx_SendString_B -benchmem -count=4\nfunc Benchmark_Ctx_SendString_B(b *testing.B) {\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tbody := \"Hello, world!\"\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\n\tvar err error\n\tfor n := 0; n < b.N; n++ {\n\t\terr = c.SendString(body)\n\t}\n\tutils.AssertEqual(b, nil, err)\n\tutils.AssertEqual(b, []byte(\"Hello, world!\"), c.Response().Body())\n}\n\n// go test -run Test_Ctx_Queries -v\nfunc Test_Ctx_Queries(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\n\tc.Request().SetBody([]byte(``))\n\tc.Request().Header.SetContentType(\"\")\n\tc.Request().URI().SetQueryString(\"id=1&name=tom&hobby=basketball,football&favouriteDrinks=milo,coke,pepsi&alloc=&no=1&field1=value1&field1=value2&field2=value3&list_a=1&list_a=2&list_a=3&list_b[]=1&list_b[]=2&list_b[]=3&list_c=1,2,3\")\n\n\tqueries := c.Queries()\n\tutils.AssertEqual(t, \"1\", queries[\"id\"])\n\tutils.AssertEqual(t, \"tom\", queries[\"name\"])\n\tutils.AssertEqual(t, \"basketball,football\", queries[\"hobby\"])\n\tutils.AssertEqual(t, \"milo,coke,pepsi\", queries[\"favouriteDrinks\"])\n\tutils.AssertEqual(t, \"\", queries[\"alloc\"])\n\tutils.AssertEqual(t, \"1\", queries[\"no\"])\n\tutils.AssertEqual(t, \"value2\", queries[\"field1\"])\n\tutils.AssertEqual(t, \"value3\", queries[\"field2\"])\n\tutils.AssertEqual(t, \"3\", queries[\"list_a\"])\n\tutils.AssertEqual(t, \"3\", queries[\"list_b[]\"])\n\tutils.AssertEqual(t, \"1,2,3\", queries[\"list_c\"])\n\n\tc.Request().URI().SetQueryString(\"filters.author.name=John&filters.category.name=Technology&filters[customer][name]=Alice&filters[status]=pending\")\n\n\tqueries = c.Queries()\n\tutils.AssertEqual(t, \"John\", queries[\"filters.author.name\"])\n\tutils.AssertEqual(t, \"Technology\", queries[\"filters.category.name\"])\n\tutils.AssertEqual(t, \"Alice\", queries[\"filters[customer][name]\"])\n\tutils.AssertEqual(t, \"pending\", queries[\"filters[status]\"])\n\n\tc.Request().URI().SetQueryString(\"tags=apple,orange,banana&filters[tags]=apple,orange,banana&filters[category][name]=fruits&filters.tags=apple,orange,banana&filters.category.name=fruits\")\n\n\tqueries = c.Queries()\n\tutils.AssertEqual(t, \"apple,orange,banana\", queries[\"tags\"])\n\tutils.AssertEqual(t, \"apple,orange,banana\", queries[\"filters[tags]\"])\n\tutils.AssertEqual(t, \"fruits\", queries[\"filters[category][name]\"])\n\tutils.AssertEqual(t, \"apple,orange,banana\", queries[\"filters.tags\"])\n\tutils.AssertEqual(t, \"fruits\", queries[\"filters.category.name\"])\n\n\tc.Request().URI().SetQueryString(\"filters[tags][0]=apple&filters[tags][1]=orange&filters[tags][2]=banana&filters[category][name]=fruits\")\n\n\tqueries = c.Queries()\n\tutils.AssertEqual(t, \"apple\", queries[\"filters[tags][0]\"])\n\tutils.AssertEqual(t, \"orange\", queries[\"filters[tags][1]\"])\n\tutils.AssertEqual(t, \"banana\", queries[\"filters[tags][2]\"])\n\tutils.AssertEqual(t, \"fruits\", queries[\"filters[category][name]\"])\n}\n\n// go test -v  -run=^$ -bench=Benchmark_Ctx_Queries -benchmem -count=4\nfunc Benchmark_Ctx_Queries(b *testing.B) {\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tc.Request().URI().SetQueryString(\"id=1&name=tom&hobby=basketball,football&favouriteDrinks=milo,coke,pepsi&alloc=&no=1\")\n\n\tvar queries map[string]string\n\tfor n := 0; n < b.N; n++ {\n\t\tqueries = c.Queries()\n\t}\n\n\tutils.AssertEqual(b, \"1\", queries[\"id\"])\n\tutils.AssertEqual(b, \"tom\", queries[\"name\"])\n\tutils.AssertEqual(b, \"basketball,football\", queries[\"hobby\"])\n\tutils.AssertEqual(b, \"milo,coke,pepsi\", queries[\"favouriteDrinks\"])\n\tutils.AssertEqual(b, \"\", queries[\"alloc\"])\n\tutils.AssertEqual(b, \"1\", queries[\"no\"])\n}\n\n// go test -run Test_Ctx_QueryParser -v\nfunc Test_Ctx_QueryParser(t *testing.T) {\n\tt.Parallel()\n\tapp := New(Config{EnableSplittingOnParsers: true})\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\ttype Query struct {\n\t\tID    int\n\t\tName  string\n\t\tHobby []string\n\t}\n\tc.Request().SetBody([]byte(``))\n\tc.Request().Header.SetContentType(\"\")\n\tc.Request().URI().SetQueryString(\"id=1&name=tom&hobby=basketball&hobby=football\")\n\tq := new(Query)\n\tutils.AssertEqual(t, nil, c.QueryParser(q))\n\tutils.AssertEqual(t, 2, len(q.Hobby))\n\n\tc.Request().URI().SetQueryString(\"id=1&name=tom&hobby=basketball,football\")\n\tq = new(Query)\n\tutils.AssertEqual(t, nil, c.QueryParser(q))\n\tutils.AssertEqual(t, 2, len(q.Hobby))\n\n\tc.Request().URI().SetQueryString(\"id=1&name=tom&hobby=scoccer&hobby=basketball,football\")\n\tq = new(Query)\n\tutils.AssertEqual(t, nil, c.QueryParser(q))\n\tutils.AssertEqual(t, 3, len(q.Hobby))\n\n\tempty := new(Query)\n\tc.Request().URI().SetQueryString(\"\")\n\tutils.AssertEqual(t, nil, c.QueryParser(empty))\n\tutils.AssertEqual(t, 0, len(empty.Hobby))\n\n\ttype Query2 struct {\n\t\tBool            bool\n\t\tID              int\n\t\tName            string\n\t\tHobby           string\n\t\tFavouriteDrinks []string\n\t\tEmpty           []string\n\t\tAlloc           []string\n\t\tNo              []int64\n\t}\n\n\tc.Request().URI().SetQueryString(\"id=1&name=tom&hobby=basketball,football&favouriteDrinks=milo,coke,pepsi&alloc=&no=1\")\n\tq2 := new(Query2)\n\tq2.Bool = true\n\tq2.Name = \"hello world\"\n\tutils.AssertEqual(t, nil, c.QueryParser(q2))\n\tutils.AssertEqual(t, \"basketball,football\", q2.Hobby)\n\tutils.AssertEqual(t, true, q2.Bool)\n\tutils.AssertEqual(t, \"tom\", q2.Name) // check value get overwritten\n\tutils.AssertEqual(t, []string{\"milo\", \"coke\", \"pepsi\"}, q2.FavouriteDrinks)\n\tvar nilSlice []string\n\tutils.AssertEqual(t, nilSlice, q2.Empty)\n\tutils.AssertEqual(t, []string{\"\"}, q2.Alloc)\n\tutils.AssertEqual(t, []int64{1}, q2.No)\n\n\ttype RequiredQuery struct {\n\t\tName string `query:\"name,required\"`\n\t}\n\trq := new(RequiredQuery)\n\tc.Request().URI().SetQueryString(\"\")\n\tutils.AssertEqual(t, \"failed to decode: name is empty\", c.QueryParser(rq).Error())\n\n\ttype ArrayQuery struct {\n\t\tData []string\n\t}\n\taq := new(ArrayQuery)\n\tc.Request().URI().SetQueryString(\"data[]=john&data[]=doe\")\n\tutils.AssertEqual(t, nil, c.QueryParser(aq))\n\tutils.AssertEqual(t, 2, len(aq.Data))\n}\n\n// go test -run Test_Ctx_QueryParser -v\nfunc Test_Ctx_QueryParser_WithoutSplitting(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\ttype Query struct {\n\t\tID    int\n\t\tName  string\n\t\tHobby []string\n\t}\n\n\tc.Request().URI().SetQueryString(\"id=1&name=tom&hobby=basketball,football\")\n\tq := new(Query)\n\tutils.AssertEqual(t, nil, c.QueryParser(q))\n\tutils.AssertEqual(t, 1, len(q.Hobby))\n\n\tc.Request().URI().SetQueryString(\"id=1&name=tom&hobby=scoccer&hobby=basketball,football\")\n\tq = new(Query)\n\tutils.AssertEqual(t, nil, c.QueryParser(q))\n\tutils.AssertEqual(t, 2, len(q.Hobby))\n}\n\n// go test -run Test_Ctx_QueryParser_WithSetParserDecoder -v\nfunc Test_Ctx_QueryParser_WithSetParserDecoder(t *testing.T) {\n\tt.Parallel()\n\ttype NonRFCTime time.Time\n\n\tnonRFCConverter := func(value string) reflect.Value {\n\t\tif v, err := time.Parse(\"2006-01-02\", value); err == nil {\n\t\t\treturn reflect.ValueOf(v)\n\t\t}\n\t\treturn reflect.Value{}\n\t}\n\n\tnonRFCTime := ParserType{\n\t\tCustomtype: NonRFCTime{},\n\t\tConverter:  nonRFCConverter,\n\t}\n\n\tSetParserDecoder(ParserConfig{\n\t\tIgnoreUnknownKeys: true,\n\t\tParserType:        []ParserType{nonRFCTime},\n\t\tZeroEmpty:         true,\n\t\tSetAliasTag:       \"query\",\n\t})\n\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\n\ttype NonRFCTimeInput struct {\n\t\tDate  NonRFCTime `query:\"date\"`\n\t\tTitle string     `query:\"title\"`\n\t\tBody  string     `query:\"body\"`\n\t}\n\n\tc.Request().SetBody([]byte(``))\n\tc.Request().Header.SetContentType(\"\")\n\tq := new(NonRFCTimeInput)\n\n\tc.Request().URI().SetQueryString(\"date=2021-04-10&title=CustomDateTest&Body=October\")\n\tutils.AssertEqual(t, nil, c.QueryParser(q))\n\tutils.AssertEqual(t, \"CustomDateTest\", q.Title)\n\tdate := fmt.Sprintf(\"%v\", q.Date)\n\tutils.AssertEqual(t, \"{0 63753609600 <nil>}\", date)\n\tutils.AssertEqual(t, \"October\", q.Body)\n\n\tc.Request().URI().SetQueryString(\"date=2021-04-10&title&Body=October\")\n\tq = &NonRFCTimeInput{\n\t\tTitle: \"Existing title\",\n\t\tBody:  \"Existing Body\",\n\t}\n\tutils.AssertEqual(t, nil, c.QueryParser(q))\n\tutils.AssertEqual(t, \"\", q.Title)\n}\n\n// go test -run Test_Ctx_QueryParser_Schema -v\nfunc Test_Ctx_QueryParser_Schema(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\ttype Query1 struct {\n\t\tName   string `query:\"name,required\"`\n\t\tNested struct {\n\t\t\tAge int `query:\"age\"`\n\t\t} `query:\"nested,required\"`\n\t}\n\tc.Request().SetBody([]byte(``))\n\tc.Request().Header.SetContentType(\"\")\n\tc.Request().URI().SetQueryString(\"name=tom&nested.age=10\")\n\tq := new(Query1)\n\tutils.AssertEqual(t, nil, c.QueryParser(q))\n\n\tc.Request().URI().SetQueryString(\"namex=tom&nested.age=10\")\n\tq = new(Query1)\n\tutils.AssertEqual(t, \"failed to decode: name is empty\", c.QueryParser(q).Error())\n\n\tc.Request().URI().SetQueryString(\"name=tom&nested.agex=10\")\n\tq = new(Query1)\n\tutils.AssertEqual(t, nil, c.QueryParser(q))\n\n\tc.Request().URI().SetQueryString(\"name=tom&test.age=10\")\n\tq = new(Query1)\n\tutils.AssertEqual(t, \"failed to decode: nested is empty\", c.QueryParser(q).Error())\n\n\ttype Query2 struct {\n\t\tName   string `query:\"name\"`\n\t\tNested struct {\n\t\t\tAge int `query:\"age,required\"`\n\t\t} `query:\"nested\"`\n\t}\n\tc.Request().URI().SetQueryString(\"name=tom&nested.age=10\")\n\tq2 := new(Query2)\n\tutils.AssertEqual(t, nil, c.QueryParser(q2))\n\n\tc.Request().URI().SetQueryString(\"nested.age=10\")\n\tq2 = new(Query2)\n\tutils.AssertEqual(t, nil, c.QueryParser(q2))\n\n\tc.Request().URI().SetQueryString(\"nested.agex=10\")\n\tq2 = new(Query2)\n\tutils.AssertEqual(t, \"failed to decode: nested.age is empty\", c.QueryParser(q2).Error())\n\n\tc.Request().URI().SetQueryString(\"nested.agex=10\")\n\tq2 = new(Query2)\n\tutils.AssertEqual(t, \"failed to decode: nested.age is empty\", c.QueryParser(q2).Error())\n\n\ttype Node struct {\n\t\tValue int   `query:\"val,required\"`\n\t\tNext  *Node `query:\"next,required\"`\n\t}\n\tc.Request().URI().SetQueryString(\"val=1&next.val=3\")\n\tn := new(Node)\n\tutils.AssertEqual(t, nil, c.QueryParser(n))\n\tutils.AssertEqual(t, 1, n.Value)\n\tutils.AssertEqual(t, 3, n.Next.Value)\n\n\tc.Request().URI().SetQueryString(\"next.val=2\")\n\tn = new(Node)\n\tutils.AssertEqual(t, \"failed to decode: val is empty\", c.QueryParser(n).Error())\n\n\tc.Request().URI().SetQueryString(\"val=3&next.value=2\")\n\tn = new(Node)\n\tn.Next = new(Node)\n\tutils.AssertEqual(t, nil, c.QueryParser(n))\n\tutils.AssertEqual(t, 3, n.Value)\n\tutils.AssertEqual(t, 0, n.Next.Value)\n\n\ttype Person struct {\n\t\tName string `query:\"name\"`\n\t\tAge  int    `query:\"age\"`\n\t}\n\n\ttype CollectionQuery struct {\n\t\tData []Person `query:\"data\"`\n\t}\n\n\tc.Request().URI().SetQueryString(\"data[0][name]=john&data[0][age]=10&data[1][name]=doe&data[1][age]=12\")\n\tcq := new(CollectionQuery)\n\tutils.AssertEqual(t, nil, c.QueryParser(cq))\n\tutils.AssertEqual(t, 2, len(cq.Data))\n\tutils.AssertEqual(t, \"john\", cq.Data[0].Name)\n\tutils.AssertEqual(t, 10, cq.Data[0].Age)\n\tutils.AssertEqual(t, \"doe\", cq.Data[1].Name)\n\tutils.AssertEqual(t, 12, cq.Data[1].Age)\n\n\tc.Request().URI().SetQueryString(\"data.0.name=john&data.0.age=10&data.1.name=doe&data.1.age=12\")\n\tcq = new(CollectionQuery)\n\tutils.AssertEqual(t, nil, c.QueryParser(cq))\n\tutils.AssertEqual(t, 2, len(cq.Data))\n\tutils.AssertEqual(t, \"john\", cq.Data[0].Name)\n\tutils.AssertEqual(t, 10, cq.Data[0].Age)\n\tutils.AssertEqual(t, \"doe\", cq.Data[1].Name)\n\tutils.AssertEqual(t, 12, cq.Data[1].Age)\n}\n\n// go test -run Test_Ctx_ReqHeaderParser -v\nfunc Test_Ctx_ReqHeaderParser(t *testing.T) {\n\tt.Parallel()\n\tapp := New(Config{EnableSplittingOnParsers: true})\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\ttype Header struct {\n\t\tID    int\n\t\tName  string\n\t\tHobby []string\n\t}\n\tc.Request().SetBody([]byte(``))\n\tc.Request().Header.SetContentType(\"\")\n\n\tc.Request().Header.Add(\"id\", \"1\")\n\tc.Request().Header.Add(\"Name\", \"John Doe\")\n\tc.Request().Header.Add(\"Hobby\", \"golang,fiber\")\n\tq := new(Header)\n\tutils.AssertEqual(t, nil, c.ReqHeaderParser(q))\n\tutils.AssertEqual(t, 2, len(q.Hobby))\n\n\tc.Request().Header.Del(\"hobby\")\n\tc.Request().Header.Add(\"Hobby\", \"golang,fiber,go\")\n\tq = new(Header)\n\tutils.AssertEqual(t, nil, c.ReqHeaderParser(q))\n\tutils.AssertEqual(t, 3, len(q.Hobby))\n\n\tempty := new(Header)\n\tc.Request().Header.Del(\"hobby\")\n\tutils.AssertEqual(t, nil, c.QueryParser(empty))\n\tutils.AssertEqual(t, 0, len(empty.Hobby))\n\n\ttype Header2 struct {\n\t\tBool            bool\n\t\tID              int\n\t\tName            string\n\t\tHobby           string\n\t\tFavouriteDrinks []string\n\t\tEmpty           []string\n\t\tAlloc           []string\n\t\tNo              []int64\n\t}\n\n\tc.Request().Header.Add(\"id\", \"2\")\n\tc.Request().Header.Add(\"Name\", \"Jane Doe\")\n\tc.Request().Header.Del(\"hobby\")\n\tc.Request().Header.Add(\"Hobby\", \"go,fiber\")\n\tc.Request().Header.Add(\"favouriteDrinks\", \"milo,coke,pepsi\")\n\tc.Request().Header.Add(\"alloc\", \"\")\n\tc.Request().Header.Add(\"no\", \"1\")\n\n\th2 := new(Header2)\n\th2.Bool = true\n\th2.Name = \"hello world\"\n\tutils.AssertEqual(t, nil, c.ReqHeaderParser(h2))\n\tutils.AssertEqual(t, \"go,fiber\", h2.Hobby)\n\tutils.AssertEqual(t, true, h2.Bool)\n\tutils.AssertEqual(t, \"Jane Doe\", h2.Name) // check value get overwritten\n\tutils.AssertEqual(t, []string{\"milo\", \"coke\", \"pepsi\"}, h2.FavouriteDrinks)\n\tvar nilSlice []string\n\tutils.AssertEqual(t, nilSlice, h2.Empty)\n\tutils.AssertEqual(t, []string{\"\"}, h2.Alloc)\n\tutils.AssertEqual(t, []int64{1}, h2.No)\n\n\ttype RequiredHeader struct {\n\t\tName string `reqHeader:\"name,required\"`\n\t}\n\trh := new(RequiredHeader)\n\tc.Request().Header.Del(\"name\")\n\tutils.AssertEqual(t, \"failed to decode: name is empty\", c.ReqHeaderParser(rh).Error())\n}\n\n// go test -run Test_Ctx_ReqHeaderParser -v\nfunc Test_Ctx_ReqHeaderParser_WithoutSplitting(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\ttype Header struct {\n\t\tID    int\n\t\tName  string\n\t\tHobby []string\n\t}\n\tc.Request().SetBody([]byte(``))\n\tc.Request().Header.SetContentType(\"\")\n\n\tc.Request().Header.Add(\"id\", \"1\")\n\tc.Request().Header.Add(\"Name\", \"John Doe\")\n\tc.Request().Header.Add(\"Hobby\", \"golang,fiber\")\n\tq := new(Header)\n\tutils.AssertEqual(t, nil, c.ReqHeaderParser(q))\n\tutils.AssertEqual(t, 1, len(q.Hobby))\n\n\tc.Request().Header.Del(\"hobby\")\n\tc.Request().Header.Add(\"Hobby\", \"golang,fiber,go\")\n\tq = new(Header)\n\tutils.AssertEqual(t, nil, c.ReqHeaderParser(q))\n\tutils.AssertEqual(t, 1, len(q.Hobby))\n}\n\n// go test -run Test_Ctx_ReqHeaderParser_WithSetParserDecoder -v\nfunc Test_Ctx_ReqHeaderParser_WithSetParserDecoder(t *testing.T) {\n\tt.Parallel()\n\ttype NonRFCTime time.Time\n\n\tnonRFCConverter := func(value string) reflect.Value {\n\t\tif v, err := time.Parse(\"2006-01-02\", value); err == nil {\n\t\t\treturn reflect.ValueOf(v)\n\t\t}\n\t\treturn reflect.Value{}\n\t}\n\n\tnonRFCTime := ParserType{\n\t\tCustomtype: NonRFCTime{},\n\t\tConverter:  nonRFCConverter,\n\t}\n\n\tSetParserDecoder(ParserConfig{\n\t\tIgnoreUnknownKeys: true,\n\t\tParserType:        []ParserType{nonRFCTime},\n\t\tZeroEmpty:         true,\n\t\tSetAliasTag:       \"req\",\n\t})\n\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\n\ttype NonRFCTimeInput struct {\n\t\tDate  NonRFCTime `req:\"date\"`\n\t\tTitle string     `req:\"title\"`\n\t\tBody  string     `req:\"body\"`\n\t}\n\n\tc.Request().SetBody([]byte(``))\n\tc.Request().Header.SetContentType(\"\")\n\tr := new(NonRFCTimeInput)\n\n\tc.Request().Header.Add(\"Date\", \"2021-04-10\")\n\tc.Request().Header.Add(\"Title\", \"CustomDateTest\")\n\tc.Request().Header.Add(\"Body\", \"October\")\n\n\tutils.AssertEqual(t, nil, c.ReqHeaderParser(r))\n\tutils.AssertEqual(t, \"CustomDateTest\", r.Title)\n\tdate := fmt.Sprintf(\"%v\", r.Date)\n\tutils.AssertEqual(t, \"{0 63753609600 <nil>}\", date)\n\tutils.AssertEqual(t, \"October\", r.Body)\n\n\tc.Request().Header.Add(\"Title\", \"\")\n\tr = &NonRFCTimeInput{\n\t\tTitle: \"Existing title\",\n\t\tBody:  \"Existing Body\",\n\t}\n\tutils.AssertEqual(t, nil, c.ReqHeaderParser(r))\n\tutils.AssertEqual(t, \"\", r.Title)\n}\n\n// go test -run Test_Ctx_ReqHeaderParser_Schema -v\nfunc Test_Ctx_ReqHeaderParser_Schema(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\ttype Header1 struct {\n\t\tName   string `reqHeader:\"Name,required\"`\n\t\tNested struct {\n\t\t\tAge int `reqHeader:\"Age\"`\n\t\t} `reqHeader:\"Nested,required\"`\n\t}\n\tc.Request().SetBody([]byte(``))\n\tc.Request().Header.SetContentType(\"\")\n\n\tc.Request().Header.Add(\"Name\", \"tom\")\n\tc.Request().Header.Add(\"Nested.Age\", \"10\")\n\tq := new(Header1)\n\tutils.AssertEqual(t, nil, c.ReqHeaderParser(q))\n\n\tc.Request().Header.Del(\"Name\")\n\tq = new(Header1)\n\tutils.AssertEqual(t, \"failed to decode: Name is empty\", c.ReqHeaderParser(q).Error())\n\n\tc.Request().Header.Add(\"Name\", \"tom\")\n\tc.Request().Header.Del(\"Nested.Age\")\n\tc.Request().Header.Add(\"Nested.Agex\", \"10\")\n\tq = new(Header1)\n\tutils.AssertEqual(t, nil, c.ReqHeaderParser(q))\n\n\tc.Request().Header.Del(\"Nested.Agex\")\n\tq = new(Header1)\n\tutils.AssertEqual(t, \"failed to decode: Nested is empty\", c.ReqHeaderParser(q).Error())\n\n\tc.Request().Header.Del(\"Nested.Agex\")\n\tc.Request().Header.Del(\"Name\")\n\n\ttype Header2 struct {\n\t\tName   string `reqHeader:\"Name\"`\n\t\tNested struct {\n\t\t\tAge int `reqHeader:\"age,required\"`\n\t\t} `reqHeader:\"Nested\"`\n\t}\n\n\tc.Request().Header.Add(\"Name\", \"tom\")\n\tc.Request().Header.Add(\"Nested.Age\", \"10\")\n\n\th2 := new(Header2)\n\tutils.AssertEqual(t, nil, c.ReqHeaderParser(h2))\n\n\tc.Request().Header.Del(\"Name\")\n\th2 = new(Header2)\n\tutils.AssertEqual(t, nil, c.ReqHeaderParser(h2))\n\n\tc.Request().Header.Del(\"Name\")\n\tc.Request().Header.Del(\"Nested.Age\")\n\tc.Request().Header.Add(\"Nested.Agex\", \"10\")\n\th2 = new(Header2)\n\tutils.AssertEqual(t, \"failed to decode: Nested.age is empty\", c.ReqHeaderParser(h2).Error())\n\n\ttype Node struct {\n\t\tValue int   `reqHeader:\"Val,required\"`\n\t\tNext  *Node `reqHeader:\"Next,required\"`\n\t}\n\tc.Request().Header.Add(\"Val\", \"1\")\n\tc.Request().Header.Add(\"Next.Val\", \"3\")\n\tn := new(Node)\n\tutils.AssertEqual(t, nil, c.ReqHeaderParser(n))\n\tutils.AssertEqual(t, 1, n.Value)\n\tutils.AssertEqual(t, 3, n.Next.Value)\n\n\tc.Request().Header.Del(\"Val\")\n\tn = new(Node)\n\tutils.AssertEqual(t, \"failed to decode: Val is empty\", c.ReqHeaderParser(n).Error())\n\n\tc.Request().Header.Add(\"Val\", \"3\")\n\tc.Request().Header.Del(\"Next.Val\")\n\tc.Request().Header.Add(\"Next.Value\", \"2\")\n\tn = new(Node)\n\tn.Next = new(Node)\n\tutils.AssertEqual(t, nil, c.ReqHeaderParser(n))\n\tutils.AssertEqual(t, 3, n.Value)\n\tutils.AssertEqual(t, 0, n.Next.Value)\n}\n\nfunc Test_Ctx_EqualFieldType(t *testing.T) {\n\tt.Parallel()\n\tvar out int\n\tutils.AssertEqual(t, false, equalFieldType(&out, reflect.Int, \"key\"))\n\n\tvar dummy struct{ f string }\n\tutils.AssertEqual(t, false, equalFieldType(&dummy, reflect.String, \"key\"))\n\n\tvar dummy2 struct{ f string }\n\tutils.AssertEqual(t, false, equalFieldType(&dummy2, reflect.String, \"f\"))\n\n\tvar user struct {\n\t\tName    string\n\t\tAddress string `query:\"address\"`\n\t\tAge     int    `query:\"AGE\"`\n\t}\n\tutils.AssertEqual(t, true, equalFieldType(&user, reflect.String, \"name\"))\n\tutils.AssertEqual(t, true, equalFieldType(&user, reflect.String, \"Name\"))\n\tutils.AssertEqual(t, true, equalFieldType(&user, reflect.String, \"address\"))\n\tutils.AssertEqual(t, true, equalFieldType(&user, reflect.String, \"Address\"))\n\tutils.AssertEqual(t, true, equalFieldType(&user, reflect.Int, \"AGE\"))\n\tutils.AssertEqual(t, true, equalFieldType(&user, reflect.Int, \"age\"))\n}\n\n// go test -v  -run=^$ -bench=Benchmark_Ctx_QueryParser -benchmem -count=4\nfunc Benchmark_Ctx_QueryParser(b *testing.B) {\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\ttype Query struct {\n\t\tID    int\n\t\tName  string\n\t\tHobby []string\n\t}\n\tc.Request().SetBody([]byte(``))\n\tc.Request().Header.SetContentType(\"\")\n\tc.Request().URI().SetQueryString(\"id=1&name=tom&hobby=basketball&hobby=football\")\n\tq := new(Query)\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\n\tvar err error\n\tfor n := 0; n < b.N; n++ {\n\t\terr = c.QueryParser(q)\n\t}\n\tutils.AssertEqual(b, nil, err)\n\tutils.AssertEqual(b, nil, c.QueryParser(q))\n}\n\n// go test -v  -run=^$ -bench=Benchmark_Ctx_parseQuery -benchmem -count=4\nfunc Benchmark_Ctx_parseQuery(b *testing.B) {\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\ttype Person struct {\n\t\tName string `query:\"name\"`\n\t\tAge  int    `query:\"age\"`\n\t}\n\n\ttype CollectionQuery struct {\n\t\tData []Person `query:\"data\"`\n\t}\n\n\tc.Request().SetBody([]byte(``))\n\tc.Request().Header.SetContentType(\"\")\n\tc.Request().URI().SetQueryString(\"data[0][name]=john&data[0][age]=10\")\n\tcq := new(CollectionQuery)\n\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\n\tvar err error\n\tfor n := 0; n < b.N; n++ {\n\t\terr = c.QueryParser(cq)\n\t}\n\n\tutils.AssertEqual(b, nil, err)\n\tutils.AssertEqual(b, nil, c.QueryParser(cq))\n}\n\n// go test -v  -run=^$ -bench=Benchmark_Ctx_QueryParser_Comma -benchmem -count=4\nfunc Benchmark_Ctx_QueryParser_Comma(b *testing.B) {\n\tapp := New(Config{EnableSplittingOnParsers: true})\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\ttype Query struct {\n\t\tID    int\n\t\tName  string\n\t\tHobby []string\n\t}\n\tc.Request().SetBody([]byte(``))\n\tc.Request().Header.SetContentType(\"\")\n\t// c.Request().URI().SetQueryString(\"id=1&name=tom&hobby=basketball&hobby=football\")\n\tc.Request().URI().SetQueryString(\"id=1&name=tom&hobby=basketball,football\")\n\tq := new(Query)\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\n\tvar err error\n\tfor n := 0; n < b.N; n++ {\n\t\terr = c.QueryParser(q)\n\t}\n\tutils.AssertEqual(b, nil, err)\n\tutils.AssertEqual(b, nil, c.QueryParser(q))\n}\n\n// go test -v  -run=^$ -bench=Benchmark_Ctx_ReqHeaderParser -benchmem -count=4\nfunc Benchmark_Ctx_ReqHeaderParser(b *testing.B) {\n\tapp := New(Config{EnableSplittingOnParsers: true})\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\ttype ReqHeader struct {\n\t\tID    int\n\t\tName  string\n\t\tHobby []string\n\t}\n\tc.Request().SetBody([]byte(``))\n\tc.Request().Header.SetContentType(\"\")\n\n\tc.Request().Header.Add(\"id\", \"1\")\n\tc.Request().Header.Add(\"Name\", \"John Doe\")\n\tc.Request().Header.Add(\"Hobby\", \"golang,fiber\")\n\n\tq := new(ReqHeader)\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\n\tvar err error\n\tfor n := 0; n < b.N; n++ {\n\t\terr = c.ReqHeaderParser(q)\n\t}\n\tutils.AssertEqual(b, nil, err)\n\tutils.AssertEqual(b, nil, c.ReqHeaderParser(q))\n}\n\n// go test -run Test_Ctx_BodyStreamWriter\nfunc Test_Ctx_BodyStreamWriter(t *testing.T) {\n\tt.Parallel()\n\tctx := &fasthttp.RequestCtx{}\n\n\tctx.SetBodyStreamWriter(func(w *bufio.Writer) {\n\t\tfmt.Fprintf(w, \"body writer line 1\\n\")\n\t\tif err := w.Flush(); err != nil {\n\t\t\tt.Errorf(\"unexpected error: %s\", err)\n\t\t}\n\t\tfmt.Fprintf(w, \"body writer line 2\\n\")\n\t})\n\tif !ctx.IsBodyStream() {\n\t\tt.Fatal(\"IsBodyStream must return true\")\n\t}\n\n\ts := ctx.Response.String()\n\tbr := bufio.NewReader(bytes.NewBufferString(s))\n\tvar resp fasthttp.Response\n\tif err := resp.Read(br); err != nil {\n\t\tt.Fatalf(\"Error when reading response: %s\", err)\n\t}\n\tbody := string(resp.Body())\n\texpectedBody := \"body writer line 1\\nbody writer line 2\\n\"\n\tif body != expectedBody {\n\t\tt.Fatalf(\"unexpected body: %q. Expecting %q\", body, expectedBody)\n\t}\n}\n\n// go test -v  -run=^$ -bench=Benchmark_Ctx_BodyStreamWriter -benchmem -count=4\nfunc Benchmark_Ctx_BodyStreamWriter(b *testing.B) {\n\tctx := &fasthttp.RequestCtx{}\n\tuser := []byte(`{\"name\":\"john\"}`)\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\n\tvar err error\n\tfor n := 0; n < b.N; n++ {\n\t\tctx.ResetBody()\n\t\tctx.SetBodyStreamWriter(func(w *bufio.Writer) {\n\t\t\tfor i := 0; i < 10; i++ {\n\t\t\t\t_, err = w.Write(user)\n\t\t\t\tif err := w.Flush(); err != nil {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n\tutils.AssertEqual(b, nil, err)\n}\n\nfunc Test_Ctx_String(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\n\tutils.AssertEqual(t, \"#0000000000000000 - 0.0.0.0:0 <-> 0.0.0.0:0 - GET http:///\", c.String())\n}\n\nfunc TestCtx_ParamsInt(t *testing.T) {\n\t// Create a test context and set some strings (or params)\n\t// create a fake app to be used within this test\n\tt.Parallel()\n\tapp := New()\n\n\t// Create some test endpoints\n\n\t// For the user id I will use the number 1111, so I should be able to get the number\n\t// 1111 from the Ctx\n\tapp.Get(\"/test/:user\", func(c *Ctx) error {\n\t\t// utils.AssertEqual(t, \"john\", c.Params(\"user\"))\n\n\t\tnum, err := c.ParamsInt(\"user\")\n\n\t\t// Check the number matches\n\t\tif num != 1111 {\n\t\t\tt.Fatalf(\"Expected number 1111 from the path, got %d\", num)\n\t\t}\n\n\t\t// Check no errors are returned, because we want NO errors in this one\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Expected nil error for 1111 test, got \" + err.Error())\n\t\t}\n\n\t\treturn nil\n\t})\n\n\t// In this test case, there will be a bad request where the expected number is NOT\n\t// a number in the path\n\tapp.Get(\"/testnoint/:user\", func(c *Ctx) error {\n\t\t// utils.AssertEqual(t, \"john\", c.Params(\"user\"))\n\n\t\tnum, err := c.ParamsInt(\"user\")\n\n\t\t// Check the number matches\n\t\tif num != 0 {\n\t\t\tt.Fatalf(\"Expected number 0 from the path, got %d\", num)\n\t\t}\n\n\t\t// Check an error is returned, because we want NO errors in this one\n\t\tif err == nil {\n\t\t\tt.Fatal(\"Expected non nil error for bad req test, got nil\")\n\t\t}\n\n\t\treturn nil\n\t})\n\n\t// For the user id I will use the number 2222, so I should be able to get the number\n\t// 2222 from the Ctx even when the default value is specified\n\tapp.Get(\"/testignoredefault/:user\", func(c *Ctx) error {\n\t\t// utils.AssertEqual(t, \"john\", c.Params(\"user\"))\n\n\t\tnum, err := c.ParamsInt(\"user\", 1111)\n\n\t\t// Check the number matches\n\t\tif num != 2222 {\n\t\t\tt.Fatalf(\"Expected number 2222 from the path, got %d\", num)\n\t\t}\n\n\t\t// Check no errors are returned, because we want NO errors in this one\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Expected nil error for 2222 test, got \" + err.Error())\n\t\t}\n\n\t\treturn nil\n\t})\n\n\t// In this test case, there will be a bad request where the expected number is NOT\n\t// a number in the path, default value of 1111 should be used instead\n\tapp.Get(\"/testdefault/:user\", func(c *Ctx) error {\n\t\t// utils.AssertEqual(t, \"john\", c.Params(\"user\"))\n\n\t\tnum, err := c.ParamsInt(\"user\", 1111)\n\n\t\t// Check the number matches\n\t\tif num != 1111 {\n\t\t\tt.Fatalf(\"Expected number 1111 from the path, got %d\", num)\n\t\t}\n\n\t\t// Check an error is returned, because we want NO errors in this one\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Expected nil error for 1111 test, got \" + err.Error())\n\t\t}\n\n\t\treturn nil\n\t})\n\n\t_, err := app.Test(httptest.NewRequest(MethodGet, \"/test/1111\", nil))\n\tutils.AssertEqual(t, nil, err)\n\n\t_, err = app.Test(httptest.NewRequest(MethodGet, \"/testnoint/xd\", nil))\n\tutils.AssertEqual(t, nil, err)\n\n\t_, err = app.Test(httptest.NewRequest(MethodGet, \"/testignoredefault/2222\", nil))\n\tutils.AssertEqual(t, nil, err)\n\n\t_, err = app.Test(httptest.NewRequest(MethodGet, \"/testdefault/xd\", nil))\n\tutils.AssertEqual(t, nil, err)\n}\n\n// go test -run Test_Ctx_GetRespHeader\nfunc Test_Ctx_GetRespHeader(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\n\tc.Set(\"test\", \"Hello, World \ud83d\udc4b!\")\n\tc.Response().Header.Set(HeaderContentType, \"application/json\")\n\tutils.AssertEqual(t, c.GetRespHeader(\"test\"), \"Hello, World \ud83d\udc4b!\")\n\tutils.AssertEqual(t, c.GetRespHeader(HeaderContentType), \"application/json\")\n}\n\n// go test -run Test_Ctx_GetRespHeaders\nfunc Test_Ctx_GetRespHeaders(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\n\tc.Set(\"test\", \"Hello, World \ud83d\udc4b!\")\n\tc.Set(\"foo\", \"bar\")\n\tc.Response().Header.Set(HeaderContentType, \"application/json\")\n\n\tutils.AssertEqual(t, c.GetRespHeaders(), map[string]string{\n\t\t\"Content-Type\": \"application/json\",\n\t\t\"Foo\":          \"bar\",\n\t\t\"Test\":         \"Hello, World \ud83d\udc4b!\",\n\t})\n}\n\n// go test -run Test_Ctx_GetReqHeaders\nfunc Test_Ctx_GetReqHeaders(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\n\tc.Request().Header.Set(\"test\", \"Hello, World \ud83d\udc4b!\")\n\tc.Request().Header.Set(\"foo\", \"bar\")\n\tc.Request().Header.Set(HeaderContentType, \"application/json\")\n\n\tutils.AssertEqual(t, c.GetReqHeaders(), map[string]string{\n\t\t\"Content-Type\": \"application/json\",\n\t\t\"Foo\":          \"bar\",\n\t\t\"Test\":         \"Hello, World \ud83d\udc4b!\",\n\t})\n}\n\n// go test -run Test_Ctx_IsFromLocal\nfunc Test_Ctx_IsFromLocal(t *testing.T) {\n\tt.Parallel()\n\t// Test \"0.0.0.0\", \"127.0.0.1\" and \"::1\".\n\t{\n\t\tapp := New()\n\t\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\t\tdefer app.ReleaseCtx(c)\n\t\tutils.AssertEqual(t, true, c.IsFromLocal())\n\t}\n\t// This is a test for \"0.0.0.0\"\n\t{\n\t\tapp := New()\n\t\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\t\tc.Request().Header.Set(HeaderXForwardedFor, \"0.0.0.0\")\n\t\tdefer app.ReleaseCtx(c)\n\t\tutils.AssertEqual(t, true, c.IsFromLocal())\n\t}\n\n\t// This is a test for \"127.0.0.1\"\n\t{\n\t\tapp := New()\n\t\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\t\tc.Request().Header.Set(HeaderXForwardedFor, \"127.0.0.1\")\n\t\tdefer app.ReleaseCtx(c)\n\t\tutils.AssertEqual(t, true, c.IsFromLocal())\n\t}\n\n\t// This is a test for \"localhost\"\n\t{\n\t\tapp := New()\n\t\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\t\tdefer app.ReleaseCtx(c)\n\t\tutils.AssertEqual(t, true, c.IsFromLocal())\n\t}\n\n\t// This is testing \"::1\", it is the compressed format IPV6 loopback address 0:0:0:0:0:0:0:1.\n\t// It is the equivalent of the IPV4 address 127.0.0.1.\n\t{\n\t\tapp := New()\n\t\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\t\tc.Request().Header.Set(HeaderXForwardedFor, \"::1\")\n\t\tdefer app.ReleaseCtx(c)\n\t\tutils.AssertEqual(t, true, c.IsFromLocal())\n\t}\n\n\t{\n\t\tapp := New()\n\t\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\t\tc.Request().Header.Set(HeaderXForwardedFor, \"93.46.8.90\")\n\t\tdefer app.ReleaseCtx(c)\n\t\tutils.AssertEqual(t, false, c.IsFromLocal())\n\t}\n}\n\n// go test -run Test_Ctx_RepeatParserWithSameStruct -v\nfunc Test_Ctx_RepeatParserWithSameStruct(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\n\ttype Request struct {\n\t\tQueryParam  string `query:\"query_param\"`\n\t\tHeaderParam string `reqHeader:\"header_param\"`\n\t\tBodyParam   string `json:\"body_param\" xml:\"body_param\" form:\"body_param\"`\n\t}\n\n\tr := new(Request)\n\n\tc.Request().URI().SetQueryString(\"query_param=query_param\")\n\tutils.AssertEqual(t, nil, c.QueryParser(r))\n\tutils.AssertEqual(t, \"query_param\", r.QueryParam)\n\n\tc.Request().Header.Add(\"header_param\", \"header_param\")\n\tutils.AssertEqual(t, nil, c.ReqHeaderParser(r))\n\tutils.AssertEqual(t, \"header_param\", r.HeaderParam)\n\n\tvar gzipJSON bytes.Buffer\n\tw := gzip.NewWriter(&gzipJSON)\n\t_, _ = w.Write([]byte(`{\"body_param\":\"body_param\"}`)) //nolint:errcheck // This will never fail\n\terr := w.Close()\n\tutils.AssertEqual(t, nil, err)\n\tc.Request().Header.SetContentType(MIMEApplicationJSON)\n\tc.Request().Header.Set(HeaderContentEncoding, \"gzip\")\n\tc.Request().SetBody(gzipJSON.Bytes())\n\tc.Request().Header.SetContentLength(len(gzipJSON.Bytes()))\n\tutils.AssertEqual(t, nil, c.BodyParser(r))\n\tutils.AssertEqual(t, \"body_param\", r.BodyParam)\n\tc.Request().Header.Del(HeaderContentEncoding)\n\n\ttestDecodeParser := func(contentType, body string) {\n\t\tc.Request().Header.SetContentType(contentType)\n\t\tc.Request().SetBody([]byte(body))\n\t\tc.Request().Header.SetContentLength(len(body))\n\t\tutils.AssertEqual(t, nil, c.BodyParser(r))\n\t\tutils.AssertEqual(t, \"body_param\", r.BodyParam)\n\t}\n\n\ttestDecodeParser(MIMEApplicationJSON, `{\"body_param\":\"body_param\"}`)\n\ttestDecodeParser(MIMEApplicationXML, `<Demo><body_param>body_param</body_param></Demo>`)\n\ttestDecodeParser(MIMEApplicationForm, \"body_param=body_param\")\n\ttestDecodeParser(MIMEMultipartForm+`;boundary=\"b\"`, \"--b\\r\\nContent-Disposition: form-data; name=\\\"body_param\\\"\\r\\n\\r\\nbody_param\\r\\n--b--\")\n}\n"], "fixing_code": ["// \u26a1\ufe0f Fiber is an Express inspired web framework written in Go with \u2615\ufe0f\n// \ud83e\udd16 Github Repository: https://github.com/gofiber/fiber\n// \ud83d\udccc API Documentation: https://docs.gofiber.io\n\npackage fiber\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"crypto/tls\"\n\t\"encoding/json\"\n\t\"encoding/xml\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"mime/multipart\"\n\t\"net\"\n\t\"net/http\"\n\t\"path/filepath\"\n\t\"reflect\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\t\"text/template\"\n\t\"time\"\n\n\t\"github.com/gofiber/fiber/v2/internal/schema\"\n\t\"github.com/gofiber/fiber/v2/utils\"\n\n\t\"github.com/valyala/bytebufferpool\"\n\t\"github.com/valyala/fasthttp\"\n)\n\nconst (\n\tschemeHTTP  = \"http\"\n\tschemeHTTPS = \"https\"\n)\n\n// maxParams defines the maximum number of parameters per route.\nconst maxParams = 30\n\n// Some constants for BodyParser, QueryParser and ReqHeaderParser.\nconst (\n\tqueryTag     = \"query\"\n\treqHeaderTag = \"reqHeader\"\n\tbodyTag      = \"form\"\n\tparamsTag    = \"params\"\n)\n\n// userContextKey define the key name for storing context.Context in *fasthttp.RequestCtx\nconst userContextKey = \"__local_user_context__\"\n\nvar (\n\t// decoderPoolMap helps to improve BodyParser's, QueryParser's and ReqHeaderParser's performance\n\tdecoderPoolMap = map[string]*sync.Pool{}\n\t// tags is used to classify parser's pool\n\ttags = []string{queryTag, bodyTag, reqHeaderTag, paramsTag}\n)\n\nfunc init() {\n\tfor _, tag := range tags {\n\t\tdecoderPoolMap[tag] = &sync.Pool{New: func() interface{} {\n\t\t\treturn decoderBuilder(ParserConfig{\n\t\t\t\tIgnoreUnknownKeys: true,\n\t\t\t\tZeroEmpty:         true,\n\t\t\t})\n\t\t}}\n\t}\n}\n\n// SetParserDecoder allow globally change the option of form decoder, update decoderPool\nfunc SetParserDecoder(parserConfig ParserConfig) {\n\tfor _, tag := range tags {\n\t\tdecoderPoolMap[tag] = &sync.Pool{New: func() interface{} {\n\t\t\treturn decoderBuilder(parserConfig)\n\t\t}}\n\t}\n}\n\n// Ctx represents the Context which hold the HTTP request and response.\n// It has methods for the request query string, parameters, body, HTTP headers and so on.\ntype Ctx struct {\n\tapp                 *App                 // Reference to *App\n\troute               *Route               // Reference to *Route\n\tindexRoute          int                  // Index of the current route\n\tindexHandler        int                  // Index of the current handler\n\tmethod              string               // HTTP method\n\tmethodINT           int                  // HTTP method INT equivalent\n\tbaseURI             string               // HTTP base uri\n\tpath                string               // HTTP path with the modifications by the configuration -> string copy from pathBuffer\n\tpathBuffer          []byte               // HTTP path buffer\n\tdetectionPath       string               // Route detection path                                  -> string copy from detectionPathBuffer\n\tdetectionPathBuffer []byte               // HTTP detectionPath buffer\n\ttreePath            string               // Path for the search in the tree\n\tpathOriginal        string               // Original HTTP path\n\tvalues              [maxParams]string    // Route parameter values\n\tfasthttp            *fasthttp.RequestCtx // Reference to *fasthttp.RequestCtx\n\tmatched             bool                 // Non use route matched\n\tviewBindMap         sync.Map             // Default view map to bind template engine\n}\n\n// TLSHandler object\ntype TLSHandler struct {\n\tclientHelloInfo *tls.ClientHelloInfo\n}\n\n// GetClientInfo Callback function to set CHI\n// TODO: Why is this a getter which sets stuff?\nfunc (t *TLSHandler) GetClientInfo(info *tls.ClientHelloInfo) (*tls.Certificate, error) {\n\tt.clientHelloInfo = info\n\treturn nil, nil //nolint:nilnil // Not returning anything useful here is probably fine\n}\n\n// Range data for c.Range\ntype Range struct {\n\tType   string\n\tRanges []struct {\n\t\tStart int\n\t\tEnd   int\n\t}\n}\n\n// Cookie data for c.Cookie\ntype Cookie struct {\n\tName        string    `json:\"name\"`\n\tValue       string    `json:\"value\"`\n\tPath        string    `json:\"path\"`\n\tDomain      string    `json:\"domain\"`\n\tMaxAge      int       `json:\"max_age\"`\n\tExpires     time.Time `json:\"expires\"`\n\tSecure      bool      `json:\"secure\"`\n\tHTTPOnly    bool      `json:\"http_only\"`\n\tSameSite    string    `json:\"same_site\"`\n\tSessionOnly bool      `json:\"session_only\"`\n}\n\n// Views is the interface that wraps the Render function.\ntype Views interface {\n\tLoad() error\n\tRender(io.Writer, string, interface{}, ...string) error\n}\n\n// ParserType require two element, type and converter for register.\n// Use ParserType with BodyParser for parsing custom type in form data.\ntype ParserType struct {\n\tCustomtype interface{}\n\tConverter  func(string) reflect.Value\n}\n\n// ParserConfig form decoder config for SetParserDecoder\ntype ParserConfig struct {\n\tIgnoreUnknownKeys bool\n\tSetAliasTag       string\n\tParserType        []ParserType\n\tZeroEmpty         bool\n}\n\n// AcquireCtx retrieves a new Ctx from the pool.\nfunc (app *App) AcquireCtx(fctx *fasthttp.RequestCtx) *Ctx {\n\tc, ok := app.pool.Get().(*Ctx)\n\tif !ok {\n\t\tpanic(fmt.Errorf(\"failed to type-assert to *Ctx\"))\n\t}\n\t// Set app reference\n\tc.app = app\n\t// Reset route and handler index\n\tc.indexRoute = -1\n\tc.indexHandler = 0\n\t// Reset matched flag\n\tc.matched = false\n\t// Set paths\n\tc.pathOriginal = app.getString(fctx.URI().PathOriginal())\n\t// Set method\n\tc.method = app.getString(fctx.Request.Header.Method())\n\tc.methodINT = app.methodInt(c.method)\n\t// Attach *fasthttp.RequestCtx to ctx\n\tc.fasthttp = fctx\n\t// reset base uri\n\tc.baseURI = \"\"\n\t// Prettify path\n\tc.configDependentPaths()\n\treturn c\n}\n\n// ReleaseCtx releases the ctx back into the pool.\nfunc (app *App) ReleaseCtx(c *Ctx) {\n\t// Reset values\n\tc.route = nil\n\tc.fasthttp = nil\n\tc.viewBindMap = sync.Map{}\n\tapp.pool.Put(c)\n}\n\n// Accepts checks if the specified extensions or content types are acceptable.\nfunc (c *Ctx) Accepts(offers ...string) string {\n\treturn getOffer(c.Get(HeaderAccept), acceptsOfferType, offers...)\n}\n\n// AcceptsCharsets checks if the specified charset is acceptable.\nfunc (c *Ctx) AcceptsCharsets(offers ...string) string {\n\treturn getOffer(c.Get(HeaderAcceptCharset), acceptsOffer, offers...)\n}\n\n// AcceptsEncodings checks if the specified encoding is acceptable.\nfunc (c *Ctx) AcceptsEncodings(offers ...string) string {\n\treturn getOffer(c.Get(HeaderAcceptEncoding), acceptsOffer, offers...)\n}\n\n// AcceptsLanguages checks if the specified language is acceptable.\nfunc (c *Ctx) AcceptsLanguages(offers ...string) string {\n\treturn getOffer(c.Get(HeaderAcceptLanguage), acceptsOffer, offers...)\n}\n\n// App returns the *App reference to the instance of the Fiber application\nfunc (c *Ctx) App() *App {\n\treturn c.app\n}\n\n// Append the specified value to the HTTP response header field.\n// If the header is not already set, it creates the header with the specified value.\nfunc (c *Ctx) Append(field string, values ...string) {\n\tif len(values) == 0 {\n\t\treturn\n\t}\n\th := c.app.getString(c.fasthttp.Response.Header.Peek(field))\n\toriginalH := h\n\tfor _, value := range values {\n\t\tif len(h) == 0 {\n\t\t\th = value\n\t\t} else if h != value && !strings.HasPrefix(h, value+\",\") && !strings.HasSuffix(h, \" \"+value) &&\n\t\t\t!strings.Contains(h, \" \"+value+\",\") {\n\t\t\th += \", \" + value\n\t\t}\n\t}\n\tif originalH != h {\n\t\tc.Set(field, h)\n\t}\n}\n\n// Attachment sets the HTTP response Content-Disposition header field to attachment.\nfunc (c *Ctx) Attachment(filename ...string) {\n\tif len(filename) > 0 {\n\t\tfname := filepath.Base(filename[0])\n\t\tc.Type(filepath.Ext(fname))\n\n\t\tc.setCanonical(HeaderContentDisposition, `attachment; filename=\"`+c.app.quoteString(fname)+`\"`)\n\t\treturn\n\t}\n\tc.setCanonical(HeaderContentDisposition, \"attachment\")\n}\n\n// BaseURL returns (protocol + host + base path).\nfunc (c *Ctx) BaseURL() string {\n\t// TODO: Could be improved: 53.8 ns/op  32 B/op  1 allocs/op\n\t// Should work like https://codeigniter.com/user_guide/helpers/url_helper.html\n\tif c.baseURI != \"\" {\n\t\treturn c.baseURI\n\t}\n\tc.baseURI = c.Protocol() + \"://\" + c.Hostname()\n\treturn c.baseURI\n}\n\n// BodyRaw contains the raw body submitted in a POST request.\n// Returned value is only valid within the handler. Do not store any references.\n// Make copies or use the Immutable setting instead.\nfunc (c *Ctx) BodyRaw() []byte {\n\treturn c.fasthttp.Request.Body()\n}\n\nfunc (c *Ctx) tryDecodeBodyInOrder(\n\toriginalBody *[]byte,\n\tencodings []string,\n) ([]byte, uint8, error) {\n\tvar (\n\t\terr             error\n\t\tbody            []byte\n\t\tdecodesRealized uint8\n\t)\n\n\tfor index, encoding := range encodings {\n\t\tdecodesRealized++\n\t\tswitch encoding {\n\t\tcase StrGzip:\n\t\t\tbody, err = c.fasthttp.Request.BodyGunzip()\n\t\tcase StrBr, StrBrotli:\n\t\t\tbody, err = c.fasthttp.Request.BodyUnbrotli()\n\t\tcase StrDeflate:\n\t\t\tbody, err = c.fasthttp.Request.BodyInflate()\n\t\tdefault:\n\t\t\tdecodesRealized--\n\t\t\tif len(encodings) == 1 {\n\t\t\t\tbody = c.fasthttp.Request.Body()\n\t\t\t}\n\t\t\treturn body, decodesRealized, nil\n\t\t}\n\n\t\tif err != nil {\n\t\t\treturn nil, decodesRealized, err\n\t\t}\n\n\t\t// Only execute body raw update if it has a next iteration to try to decode\n\t\tif index < len(encodings)-1 && decodesRealized > 0 {\n\t\t\tif index == 0 {\n\t\t\t\ttempBody := c.fasthttp.Request.Body()\n\t\t\t\t*originalBody = make([]byte, len(tempBody))\n\t\t\t\tcopy(*originalBody, tempBody)\n\t\t\t}\n\t\t\tc.fasthttp.Request.SetBodyRaw(body)\n\t\t}\n\t}\n\n\treturn body, decodesRealized, nil\n}\n\n// Body contains the raw body submitted in a POST request.\n// This method will decompress the body if the 'Content-Encoding' header is provided.\n// It returns the original (or decompressed) body data which is valid only within the handler.\n// Don't store direct references to the returned data.\n// If you need to keep the body's data later, make a copy or use the Immutable option.\nfunc (c *Ctx) Body() []byte {\n\tvar (\n\t\terr                error\n\t\tbody, originalBody []byte\n\t\theaderEncoding     string\n\t\tencodingOrder      = []string{\"\", \"\", \"\"}\n\t)\n\n\t// faster than peek\n\tc.Request().Header.VisitAll(func(key, value []byte) {\n\t\tif c.app.getString(key) == HeaderContentEncoding {\n\t\t\theaderEncoding = c.app.getString(value)\n\t\t}\n\t})\n\n\t// Split and get the encodings list, in order to attend the\n\t// rule defined at: https://www.rfc-editor.org/rfc/rfc9110#section-8.4-5\n\tencodingOrder = getSplicedStrList(headerEncoding, encodingOrder)\n\tif len(encodingOrder) == 0 {\n\t\treturn c.fasthttp.Request.Body()\n\t}\n\n\tvar decodesRealized uint8\n\tbody, decodesRealized, err = c.tryDecodeBodyInOrder(&originalBody, encodingOrder)\n\n\t// Ensure that the body will be the original\n\tif originalBody != nil && decodesRealized > 0 {\n\t\tc.fasthttp.Request.SetBodyRaw(originalBody)\n\t}\n\tif err != nil {\n\t\treturn []byte(err.Error())\n\t}\n\n\treturn body\n}\n\nfunc decoderBuilder(parserConfig ParserConfig) interface{} {\n\tdecoder := schema.NewDecoder()\n\tdecoder.IgnoreUnknownKeys(parserConfig.IgnoreUnknownKeys)\n\tif parserConfig.SetAliasTag != \"\" {\n\t\tdecoder.SetAliasTag(parserConfig.SetAliasTag)\n\t}\n\tfor _, v := range parserConfig.ParserType {\n\t\tdecoder.RegisterConverter(reflect.ValueOf(v.Customtype).Interface(), v.Converter)\n\t}\n\tdecoder.ZeroEmpty(parserConfig.ZeroEmpty)\n\treturn decoder\n}\n\n// BodyParser binds the request body to a struct.\n// It supports decoding the following content types based on the Content-Type header:\n// application/json, application/xml, application/x-www-form-urlencoded, multipart/form-data\n// If none of the content types above are matched, it will return a ErrUnprocessableEntity error\nfunc (c *Ctx) BodyParser(out interface{}) error {\n\t// Get content-type\n\tctype := utils.ToLower(c.app.getString(c.fasthttp.Request.Header.ContentType()))\n\n\tctype = utils.ParseVendorSpecificContentType(ctype)\n\n\t// Parse body accordingly\n\tif strings.HasPrefix(ctype, MIMEApplicationJSON) {\n\t\treturn c.app.config.JSONDecoder(c.Body(), out)\n\t}\n\tif strings.HasPrefix(ctype, MIMEApplicationForm) {\n\t\tdata := make(map[string][]string)\n\t\tvar err error\n\n\t\tc.fasthttp.PostArgs().VisitAll(func(key, val []byte) {\n\t\t\tif err != nil {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tk := c.app.getString(key)\n\t\t\tv := c.app.getString(val)\n\n\t\t\tif strings.Contains(k, \"[\") {\n\t\t\t\tk, err = parseParamSquareBrackets(k)\n\t\t\t}\n\n\t\t\tif c.app.config.EnableSplittingOnParsers && strings.Contains(v, \",\") && equalFieldType(out, reflect.Slice, k) {\n\t\t\t\tvalues := strings.Split(v, \",\")\n\t\t\t\tfor i := 0; i < len(values); i++ {\n\t\t\t\t\tdata[k] = append(data[k], values[i])\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdata[k] = append(data[k], v)\n\t\t\t}\n\t\t})\n\n\t\treturn c.parseToStruct(bodyTag, out, data)\n\t}\n\tif strings.HasPrefix(ctype, MIMEMultipartForm) {\n\t\tdata, err := c.fasthttp.MultipartForm()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn c.parseToStruct(bodyTag, out, data.Value)\n\t}\n\tif strings.HasPrefix(ctype, MIMETextXML) || strings.HasPrefix(ctype, MIMEApplicationXML) {\n\t\tif err := xml.Unmarshal(c.Body(), out); err != nil {\n\t\t\treturn fmt.Errorf(\"failed to unmarshal: %w\", err)\n\t\t}\n\t\treturn nil\n\t}\n\t// No suitable content type found\n\treturn ErrUnprocessableEntity\n}\n\n// ClearCookie expires a specific cookie by key on the client side.\n// If no key is provided it expires all cookies that came with the request.\nfunc (c *Ctx) ClearCookie(key ...string) {\n\tif len(key) > 0 {\n\t\tfor i := range key {\n\t\t\tc.fasthttp.Response.Header.DelClientCookie(key[i])\n\t\t}\n\t\treturn\n\t}\n\tc.fasthttp.Request.Header.VisitAllCookie(func(k, v []byte) {\n\t\tc.fasthttp.Response.Header.DelClientCookieBytes(k)\n\t})\n}\n\n// Context returns *fasthttp.RequestCtx that carries a deadline\n// a cancellation signal, and other values across API boundaries.\nfunc (c *Ctx) Context() *fasthttp.RequestCtx {\n\treturn c.fasthttp\n}\n\n// UserContext returns a context implementation that was set by\n// user earlier or returns a non-nil, empty context,if it was not set earlier.\nfunc (c *Ctx) UserContext() context.Context {\n\tctx, ok := c.fasthttp.UserValue(userContextKey).(context.Context)\n\tif !ok {\n\t\tctx = context.Background()\n\t\tc.SetUserContext(ctx)\n\t}\n\n\treturn ctx\n}\n\n// SetUserContext sets a context implementation by user.\nfunc (c *Ctx) SetUserContext(ctx context.Context) {\n\tc.fasthttp.SetUserValue(userContextKey, ctx)\n}\n\n// Cookie sets a cookie by passing a cookie struct.\nfunc (c *Ctx) Cookie(cookie *Cookie) {\n\tfcookie := fasthttp.AcquireCookie()\n\tfcookie.SetKey(cookie.Name)\n\tfcookie.SetValue(cookie.Value)\n\tfcookie.SetPath(cookie.Path)\n\tfcookie.SetDomain(cookie.Domain)\n\t// only set max age and expiry when SessionOnly is false\n\t// i.e. cookie supposed to last beyond browser session\n\t// refer: https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies#define_the_lifetime_of_a_cookie\n\tif !cookie.SessionOnly {\n\t\tfcookie.SetMaxAge(cookie.MaxAge)\n\t\tfcookie.SetExpire(cookie.Expires)\n\t}\n\tfcookie.SetSecure(cookie.Secure)\n\tfcookie.SetHTTPOnly(cookie.HTTPOnly)\n\n\tswitch utils.ToLower(cookie.SameSite) {\n\tcase CookieSameSiteStrictMode:\n\t\tfcookie.SetSameSite(fasthttp.CookieSameSiteStrictMode)\n\tcase CookieSameSiteNoneMode:\n\t\tfcookie.SetSameSite(fasthttp.CookieSameSiteNoneMode)\n\tcase CookieSameSiteDisabled:\n\t\tfcookie.SetSameSite(fasthttp.CookieSameSiteDisabled)\n\tdefault:\n\t\tfcookie.SetSameSite(fasthttp.CookieSameSiteLaxMode)\n\t}\n\n\tc.fasthttp.Response.Header.SetCookie(fcookie)\n\tfasthttp.ReleaseCookie(fcookie)\n}\n\n// Cookies are used for getting a cookie value by key.\n// Defaults to the empty string \"\" if the cookie doesn't exist.\n// If a default value is given, it will return that value if the cookie doesn't exist.\n// The returned value is only valid within the handler. Do not store any references.\n// Make copies or use the Immutable setting to use the value outside the Handler.\nfunc (c *Ctx) Cookies(key string, defaultValue ...string) string {\n\treturn defaultString(c.app.getString(c.fasthttp.Request.Header.Cookie(key)), defaultValue)\n}\n\n// Download transfers the file from path as an attachment.\n// Typically, browsers will prompt the user for download.\n// By default, the Content-Disposition header filename= parameter is the filepath (this typically appears in the browser dialog).\n// Override this default with the filename parameter.\nfunc (c *Ctx) Download(file string, filename ...string) error {\n\tvar fname string\n\tif len(filename) > 0 {\n\t\tfname = filename[0]\n\t} else {\n\t\tfname = filepath.Base(file)\n\t}\n\tc.setCanonical(HeaderContentDisposition, `attachment; filename=\"`+c.app.quoteString(fname)+`\"`)\n\treturn c.SendFile(file)\n}\n\n// Request return the *fasthttp.Request object\n// This allows you to use all fasthttp request methods\n// https://godoc.org/github.com/valyala/fasthttp#Request\nfunc (c *Ctx) Request() *fasthttp.Request {\n\treturn &c.fasthttp.Request\n}\n\n// Response return the *fasthttp.Response object\n// This allows you to use all fasthttp response methods\n// https://godoc.org/github.com/valyala/fasthttp#Response\nfunc (c *Ctx) Response() *fasthttp.Response {\n\treturn &c.fasthttp.Response\n}\n\n// Format performs content-negotiation on the Accept HTTP header.\n// It uses Accepts to select a proper format.\n// If the header is not specified or there is no proper format, text/plain is used.\nfunc (c *Ctx) Format(body interface{}) error {\n\t// Get accepted content type\n\taccept := c.Accepts(\"html\", \"json\", \"txt\", \"xml\")\n\t// Set accepted content type\n\tc.Type(accept)\n\t// Type convert provided body\n\tvar b string\n\tswitch val := body.(type) {\n\tcase string:\n\t\tb = val\n\tcase []byte:\n\t\tb = c.app.getString(val)\n\tdefault:\n\t\tb = fmt.Sprintf(\"%v\", val)\n\t}\n\n\t// Format based on the accept content type\n\tswitch accept {\n\tcase \"html\":\n\t\treturn c.SendString(\"<p>\" + b + \"</p>\")\n\tcase \"json\":\n\t\treturn c.JSON(body)\n\tcase \"txt\":\n\t\treturn c.SendString(b)\n\tcase \"xml\":\n\t\treturn c.XML(body)\n\t}\n\treturn c.SendString(b)\n}\n\n// FormFile returns the first file by key from a MultipartForm.\nfunc (c *Ctx) FormFile(key string) (*multipart.FileHeader, error) {\n\treturn c.fasthttp.FormFile(key)\n}\n\n// FormValue returns the first value by key from a MultipartForm.\n// Search is performed in QueryArgs, PostArgs, MultipartForm and FormFile in this particular order.\n// Defaults to the empty string \"\" if the form value doesn't exist.\n// If a default value is given, it will return that value if the form value does not exist.\n// Returned value is only valid within the handler. Do not store any references.\n// Make copies or use the Immutable setting instead.\nfunc (c *Ctx) FormValue(key string, defaultValue ...string) string {\n\treturn defaultString(c.app.getString(c.fasthttp.FormValue(key)), defaultValue)\n}\n\n// Fresh returns true when the response is still \u201cfresh\u201d in the client's cache,\n// otherwise false is returned to indicate that the client cache is now stale\n// and the full response should be sent.\n// When a client sends the Cache-Control: no-cache request header to indicate an end-to-end\n// reload request, this module will return false to make handling these requests transparent.\n// https://github.com/jshttp/fresh/blob/10e0471669dbbfbfd8de65bc6efac2ddd0bfa057/index.js#L33\nfunc (c *Ctx) Fresh() bool {\n\t// fields\n\tmodifiedSince := c.Get(HeaderIfModifiedSince)\n\tnoneMatch := c.Get(HeaderIfNoneMatch)\n\n\t// unconditional request\n\tif modifiedSince == \"\" && noneMatch == \"\" {\n\t\treturn false\n\t}\n\n\t// Always return stale when Cache-Control: no-cache\n\t// to support end-to-end reload requests\n\t// https://tools.ietf.org/html/rfc2616#section-14.9.4\n\tcacheControl := c.Get(HeaderCacheControl)\n\tif cacheControl != \"\" && isNoCache(cacheControl) {\n\t\treturn false\n\t}\n\n\t// if-none-match\n\tif noneMatch != \"\" && noneMatch != \"*\" {\n\t\tetag := c.app.getString(c.fasthttp.Response.Header.Peek(HeaderETag))\n\t\tif etag == \"\" {\n\t\t\treturn false\n\t\t}\n\t\tif c.app.isEtagStale(etag, c.app.getBytes(noneMatch)) {\n\t\t\treturn false\n\t\t}\n\n\t\tif modifiedSince != \"\" {\n\t\t\tlastModified := c.app.getString(c.fasthttp.Response.Header.Peek(HeaderLastModified))\n\t\t\tif lastModified != \"\" {\n\t\t\t\tlastModifiedTime, err := http.ParseTime(lastModified)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn false\n\t\t\t\t}\n\t\t\t\tmodifiedSinceTime, err := http.ParseTime(modifiedSince)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn false\n\t\t\t\t}\n\t\t\t\treturn lastModifiedTime.Before(modifiedSinceTime)\n\t\t\t}\n\t\t}\n\t}\n\treturn true\n}\n\n// Get returns the HTTP request header specified by field.\n// Field names are case-insensitive\n// Returned value is only valid within the handler. Do not store any references.\n// Make copies or use the Immutable setting instead.\nfunc (c *Ctx) Get(key string, defaultValue ...string) string {\n\treturn defaultString(c.app.getString(c.fasthttp.Request.Header.Peek(key)), defaultValue)\n}\n\n// GetRespHeader returns the HTTP response header specified by field.\n// Field names are case-insensitive\n// Returned value is only valid within the handler. Do not store any references.\n// Make copies or use the Immutable setting instead.\nfunc (c *Ctx) GetRespHeader(key string, defaultValue ...string) string {\n\treturn defaultString(c.app.getString(c.fasthttp.Response.Header.Peek(key)), defaultValue)\n}\n\n// GetReqHeaders returns the HTTP request headers.\n// Returned value is only valid within the handler. Do not store any references.\n// Make copies or use the Immutable setting instead.\nfunc (c *Ctx) GetReqHeaders() map[string]string {\n\theaders := make(map[string]string)\n\tc.Request().Header.VisitAll(func(k, v []byte) {\n\t\theaders[c.app.getString(k)] = c.app.getString(v)\n\t})\n\n\treturn headers\n}\n\n// GetRespHeaders returns the HTTP response headers.\n// Returned value is only valid within the handler. Do not store any references.\n// Make copies or use the Immutable setting instead.\nfunc (c *Ctx) GetRespHeaders() map[string]string {\n\theaders := make(map[string]string)\n\tc.Response().Header.VisitAll(func(k, v []byte) {\n\t\theaders[c.app.getString(k)] = c.app.getString(v)\n\t})\n\n\treturn headers\n}\n\n// Hostname contains the hostname derived from the X-Forwarded-Host or Host HTTP header.\n// Returned value is only valid within the handler. Do not store any references.\n// Make copies or use the Immutable setting instead.\n// Please use Config.EnableTrustedProxyCheck to prevent header spoofing, in case when your app is behind the proxy.\nfunc (c *Ctx) Hostname() string {\n\tif c.IsProxyTrusted() {\n\t\tif host := c.Get(HeaderXForwardedHost); len(host) > 0 {\n\t\t\tcommaPos := strings.Index(host, \",\")\n\t\t\tif commaPos != -1 {\n\t\t\t\treturn host[:commaPos]\n\t\t\t}\n\t\t\treturn host\n\t\t}\n\t}\n\treturn c.app.getString(c.fasthttp.Request.URI().Host())\n}\n\n// Port returns the remote port of the request.\nfunc (c *Ctx) Port() string {\n\ttcpaddr, ok := c.fasthttp.RemoteAddr().(*net.TCPAddr)\n\tif !ok {\n\t\tpanic(fmt.Errorf(\"failed to type-assert to *net.TCPAddr\"))\n\t}\n\treturn strconv.Itoa(tcpaddr.Port)\n}\n\n// IP returns the remote IP address of the request.\n// If ProxyHeader and IP Validation is configured, it will parse that header and return the first valid IP address.\n// Please use Config.EnableTrustedProxyCheck to prevent header spoofing, in case when your app is behind the proxy.\nfunc (c *Ctx) IP() string {\n\tif c.IsProxyTrusted() && len(c.app.config.ProxyHeader) > 0 {\n\t\treturn c.extractIPFromHeader(c.app.config.ProxyHeader)\n\t}\n\n\treturn c.fasthttp.RemoteIP().String()\n}\n\n// extractIPsFromHeader will return a slice of IPs it found given a header name in the order they appear.\n// When IP validation is enabled, any invalid IPs will be omitted.\nfunc (c *Ctx) extractIPsFromHeader(header string) []string {\n\t// TODO: Reuse the c.extractIPFromHeader func somehow in here\n\n\theaderValue := c.Get(header)\n\n\t// We can't know how many IPs we will return, but we will try to guess with this constant division.\n\t// Counting ',' makes function slower for about 50ns in general case.\n\tconst maxEstimatedCount = 8\n\testimatedCount := len(headerValue) / maxEstimatedCount\n\tif estimatedCount > maxEstimatedCount {\n\t\testimatedCount = maxEstimatedCount // Avoid big allocation on big header\n\t}\n\n\tipsFound := make([]string, 0, estimatedCount)\n\n\ti := 0\n\tj := -1\n\niploop:\n\tfor {\n\t\tvar v4, v6 bool\n\n\t\t// Manually splitting string without allocating slice, working with parts directly\n\t\ti, j = j+1, j+2\n\n\t\tif j > len(headerValue) {\n\t\t\tbreak\n\t\t}\n\n\t\tfor j < len(headerValue) && headerValue[j] != ',' {\n\t\t\tif headerValue[j] == ':' {\n\t\t\t\tv6 = true\n\t\t\t} else if headerValue[j] == '.' {\n\t\t\t\tv4 = true\n\t\t\t}\n\t\t\tj++\n\t\t}\n\n\t\tfor i < j && headerValue[i] == ' ' {\n\t\t\ti++\n\t\t}\n\n\t\ts := utils.TrimRight(headerValue[i:j], ' ')\n\n\t\tif c.app.config.EnableIPValidation {\n\t\t\t// Skip validation if IP is clearly not IPv4/IPv6, otherwise validate without allocations\n\t\t\tif (!v6 && !v4) || (v6 && !utils.IsIPv6(s)) || (v4 && !utils.IsIPv4(s)) {\n\t\t\t\tcontinue iploop\n\t\t\t}\n\t\t}\n\n\t\tipsFound = append(ipsFound, s)\n\t}\n\n\treturn ipsFound\n}\n\n// extractIPFromHeader will attempt to pull the real client IP from the given header when IP validation is enabled.\n// currently, it will return the first valid IP address in header.\n// when IP validation is disabled, it will simply return the value of the header without any inspection.\n// Implementation is almost the same as in extractIPsFromHeader, but without allocation of []string.\nfunc (c *Ctx) extractIPFromHeader(header string) string {\n\tif c.app.config.EnableIPValidation {\n\t\theaderValue := c.Get(header)\n\n\t\ti := 0\n\t\tj := -1\n\n\tiploop:\n\t\tfor {\n\t\t\tvar v4, v6 bool\n\n\t\t\t// Manually splitting string without allocating slice, working with parts directly\n\t\t\ti, j = j+1, j+2\n\n\t\t\tif j > len(headerValue) {\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\tfor j < len(headerValue) && headerValue[j] != ',' {\n\t\t\t\tif headerValue[j] == ':' {\n\t\t\t\t\tv6 = true\n\t\t\t\t} else if headerValue[j] == '.' {\n\t\t\t\t\tv4 = true\n\t\t\t\t}\n\t\t\t\tj++\n\t\t\t}\n\n\t\t\tfor i < j && headerValue[i] == ' ' {\n\t\t\t\ti++\n\t\t\t}\n\n\t\t\ts := utils.TrimRight(headerValue[i:j], ' ')\n\n\t\t\tif c.app.config.EnableIPValidation {\n\t\t\t\tif (!v6 && !v4) || (v6 && !utils.IsIPv6(s)) || (v4 && !utils.IsIPv4(s)) {\n\t\t\t\t\tcontinue iploop\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn s\n\t\t}\n\n\t\treturn c.fasthttp.RemoteIP().String()\n\t}\n\n\t// default behavior if IP validation is not enabled is just to return whatever value is\n\t// in the proxy header. Even if it is empty or invalid\n\treturn c.Get(c.app.config.ProxyHeader)\n}\n\n// IPs returns a string slice of IP addresses specified in the X-Forwarded-For request header.\n// When IP validation is enabled, only valid IPs are returned.\nfunc (c *Ctx) IPs() []string {\n\treturn c.extractIPsFromHeader(HeaderXForwardedFor)\n}\n\n// Is returns the matching content type,\n// if the incoming request's Content-Type HTTP header field matches the MIME type specified by the type parameter\nfunc (c *Ctx) Is(extension string) bool {\n\textensionHeader := utils.GetMIME(extension)\n\tif extensionHeader == \"\" {\n\t\treturn false\n\t}\n\n\treturn strings.HasPrefix(\n\t\tutils.TrimLeft(c.app.getString(c.fasthttp.Request.Header.ContentType()), ' '),\n\t\textensionHeader,\n\t)\n}\n\n// JSON converts any interface or string to JSON.\n// Array and slice values encode as JSON arrays,\n// except that []byte encodes as a base64-encoded string,\n// and a nil slice encodes as the null JSON value.\n// This method also sets the content header to application/json.\nfunc (c *Ctx) JSON(data interface{}) error {\n\traw, err := c.app.config.JSONEncoder(data)\n\tif err != nil {\n\t\treturn err\n\t}\n\tc.fasthttp.Response.SetBodyRaw(raw)\n\tc.fasthttp.Response.Header.SetContentType(MIMEApplicationJSON)\n\treturn nil\n}\n\n// JSONP sends a JSON response with JSONP support.\n// This method is identical to JSON, except that it opts-in to JSONP callback support.\n// By default, the callback name is simply callback.\nfunc (c *Ctx) JSONP(data interface{}, callback ...string) error {\n\traw, err := json.Marshal(data)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to marshal: %w\", err)\n\t}\n\n\tvar result, cb string\n\n\tif len(callback) > 0 {\n\t\tcb = callback[0]\n\t} else {\n\t\tcb = \"callback\"\n\t}\n\n\tresult = cb + \"(\" + c.app.getString(raw) + \");\"\n\n\tc.setCanonical(HeaderXContentTypeOptions, \"nosniff\")\n\tc.fasthttp.Response.Header.SetContentType(MIMETextJavaScriptCharsetUTF8)\n\treturn c.SendString(result)\n}\n\n// XML converts any interface or string to XML.\n// This method also sets the content header to application/xml.\nfunc (c *Ctx) XML(data interface{}) error {\n\traw, err := c.app.config.XMLEncoder(data)\n\tif err != nil {\n\t\treturn err\n\t}\n\tc.fasthttp.Response.SetBodyRaw(raw)\n\tc.fasthttp.Response.Header.SetContentType(MIMEApplicationXML)\n\treturn nil\n}\n\n// Links joins the links followed by the property to populate the response's Link HTTP header field.\nfunc (c *Ctx) Links(link ...string) {\n\tif len(link) == 0 {\n\t\treturn\n\t}\n\tbb := bytebufferpool.Get()\n\tfor i := range link {\n\t\tif i%2 == 0 {\n\t\t\t_ = bb.WriteByte('<')          //nolint:errcheck // This will never fail\n\t\t\t_, _ = bb.WriteString(link[i]) //nolint:errcheck // This will never fail\n\t\t\t_ = bb.WriteByte('>')          //nolint:errcheck // This will never fail\n\t\t} else {\n\t\t\t_, _ = bb.WriteString(`; rel=\"` + link[i] + `\",`) //nolint:errcheck // This will never fail\n\t\t}\n\t}\n\tc.setCanonical(HeaderLink, utils.TrimRight(c.app.getString(bb.Bytes()), ','))\n\tbytebufferpool.Put(bb)\n}\n\n// Locals makes it possible to pass interface{} values under keys scoped to the request\n// and therefore available to all following routes that match the request.\nfunc (c *Ctx) Locals(key interface{}, value ...interface{}) interface{} {\n\tif len(value) == 0 {\n\t\treturn c.fasthttp.UserValue(key)\n\t}\n\tc.fasthttp.SetUserValue(key, value[0])\n\treturn value[0]\n}\n\n// Location sets the response Location HTTP header to the specified path parameter.\nfunc (c *Ctx) Location(path string) {\n\tc.setCanonical(HeaderLocation, path)\n}\n\n// Method contains a string corresponding to the HTTP method of the request: GET, POST, PUT and so on.\nfunc (c *Ctx) Method(override ...string) string {\n\tif len(override) > 0 {\n\t\tmethod := utils.ToUpper(override[0])\n\t\tmINT := c.app.methodInt(method)\n\t\tif mINT == -1 {\n\t\t\treturn c.method\n\t\t}\n\t\tc.method = method\n\t\tc.methodINT = mINT\n\t}\n\treturn c.method\n}\n\n// MultipartForm parse form entries from binary.\n// This returns a map[string][]string, so given a key the value will be a string slice.\nfunc (c *Ctx) MultipartForm() (*multipart.Form, error) {\n\treturn c.fasthttp.MultipartForm()\n}\n\n// ClientHelloInfo return CHI from context\nfunc (c *Ctx) ClientHelloInfo() *tls.ClientHelloInfo {\n\tif c.app.tlsHandler != nil {\n\t\treturn c.app.tlsHandler.clientHelloInfo\n\t}\n\n\treturn nil\n}\n\n// Next executes the next method in the stack that matches the current route.\nfunc (c *Ctx) Next() error {\n\t// Increment handler index\n\tc.indexHandler++\n\tvar err error\n\t// Did we execute all route handlers?\n\tif c.indexHandler < len(c.route.Handlers) {\n\t\t// Continue route stack\n\t\terr = c.route.Handlers[c.indexHandler](c)\n\t} else {\n\t\t// Continue handler stack\n\t\t_, err = c.app.next(c)\n\t}\n\treturn err\n}\n\n// RestartRouting instead of going to the next handler. This may be useful after\n// changing the request path. Note that handlers might be executed again.\nfunc (c *Ctx) RestartRouting() error {\n\tc.indexRoute = -1\n\t_, err := c.app.next(c)\n\treturn err\n}\n\n// OriginalURL contains the original request URL.\n// Returned value is only valid within the handler. Do not store any references.\n// Make copies or use the Immutable setting to use the value outside the Handler.\nfunc (c *Ctx) OriginalURL() string {\n\treturn c.app.getString(c.fasthttp.Request.Header.RequestURI())\n}\n\n// Params is used to get the route parameters.\n// Defaults to empty string \"\" if the param doesn't exist.\n// If a default value is given, it will return that value if the param doesn't exist.\n// Returned value is only valid within the handler. Do not store any references.\n// Make copies or use the Immutable setting to use the value outside the Handler.\nfunc (c *Ctx) Params(key string, defaultValue ...string) string {\n\tif key == \"*\" || key == \"+\" {\n\t\tkey += \"1\"\n\t}\n\tfor i := range c.route.Params {\n\t\tif len(key) != len(c.route.Params[i]) {\n\t\t\tcontinue\n\t\t}\n\t\tif c.route.Params[i] == key || (!c.app.config.CaseSensitive && utils.EqualFold(c.route.Params[i], key)) {\n\t\t\t// in case values are not here\n\t\t\tif len(c.values) <= i || len(c.values[i]) == 0 {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\treturn c.values[i]\n\t\t}\n\t}\n\treturn defaultString(\"\", defaultValue)\n}\n\n// AllParams Params is used to get all route parameters.\n// Using Params method to get params.\nfunc (c *Ctx) AllParams() map[string]string {\n\tparams := make(map[string]string, len(c.route.Params))\n\tfor _, param := range c.route.Params {\n\t\tparams[param] = c.Params(param)\n\t}\n\n\treturn params\n}\n\n// ParamsParser binds the param string to a struct.\nfunc (c *Ctx) ParamsParser(out interface{}) error {\n\tparams := make(map[string][]string, len(c.route.Params))\n\tfor _, param := range c.route.Params {\n\t\tparams[param] = append(params[param], c.Params(param))\n\t}\n\treturn c.parseToStruct(paramsTag, out, params)\n}\n\n// ParamsInt is used to get an integer from the route parameters\n// it defaults to zero if the parameter is not found or if the\n// parameter cannot be converted to an integer\n// If a default value is given, it will return that value in case the param\n// doesn't exist or cannot be converted to an integer\nfunc (c *Ctx) ParamsInt(key string, defaultValue ...int) (int, error) {\n\t// Use Atoi to convert the param to an int or return zero and an error\n\tvalue, err := strconv.Atoi(c.Params(key))\n\tif err != nil {\n\t\tif len(defaultValue) > 0 {\n\t\t\treturn defaultValue[0], nil\n\t\t}\n\t\treturn 0, fmt.Errorf(\"failed to convert: %w\", err)\n\t}\n\n\treturn value, nil\n}\n\n// Path returns the path part of the request URL.\n// Optionally, you could override the path.\nfunc (c *Ctx) Path(override ...string) string {\n\tif len(override) != 0 && c.path != override[0] {\n\t\t// Set new path to context\n\t\tc.pathOriginal = override[0]\n\n\t\t// Set new path to request context\n\t\tc.fasthttp.Request.URI().SetPath(c.pathOriginal)\n\t\t// Prettify path\n\t\tc.configDependentPaths()\n\t}\n\treturn c.path\n}\n\n// Protocol contains the request protocol string: http or https for TLS requests.\n// Please use Config.EnableTrustedProxyCheck to prevent header spoofing, in case when your app is behind the proxy.\nfunc (c *Ctx) Protocol() string {\n\tif c.fasthttp.IsTLS() {\n\t\treturn schemeHTTPS\n\t}\n\tif !c.IsProxyTrusted() {\n\t\treturn schemeHTTP\n\t}\n\n\tscheme := schemeHTTP\n\tconst lenXHeaderName = 12\n\tc.fasthttp.Request.Header.VisitAll(func(key, val []byte) {\n\t\tif len(key) < lenXHeaderName {\n\t\t\treturn // Neither \"X-Forwarded-\" nor \"X-Url-Scheme\"\n\t\t}\n\t\tswitch {\n\t\tcase bytes.HasPrefix(key, []byte(\"X-Forwarded-\")):\n\t\t\tif bytes.Equal(key, []byte(HeaderXForwardedProto)) ||\n\t\t\t\tbytes.Equal(key, []byte(HeaderXForwardedProtocol)) {\n\t\t\t\tv := c.app.getString(val)\n\t\t\t\tcommaPos := strings.Index(v, \",\")\n\t\t\t\tif commaPos != -1 {\n\t\t\t\t\tscheme = v[:commaPos]\n\t\t\t\t} else {\n\t\t\t\t\tscheme = v\n\t\t\t\t}\n\t\t\t} else if bytes.Equal(key, []byte(HeaderXForwardedSsl)) && bytes.Equal(val, []byte(\"on\")) {\n\t\t\t\tscheme = schemeHTTPS\n\t\t\t}\n\n\t\tcase bytes.Equal(key, []byte(HeaderXUrlScheme)):\n\t\t\tscheme = c.app.getString(val)\n\t\t}\n\t})\n\treturn scheme\n}\n\n// Query returns the query string parameter in the url.\n// Defaults to empty string \"\" if the query doesn't exist.\n// If a default value is given, it will return that value if the query doesn't exist.\n// Returned value is only valid within the handler. Do not store any references.\n// Make copies or use the Immutable setting to use the value outside the Handler.\nfunc (c *Ctx) Query(key string, defaultValue ...string) string {\n\treturn defaultString(c.app.getString(c.fasthttp.QueryArgs().Peek(key)), defaultValue)\n}\n\n// Queries returns a map of query parameters and their values.\n//\n// GET /?name=alex&wanna_cake=2&id=\n// Queries()[\"name\"] == \"alex\"\n// Queries()[\"wanna_cake\"] == \"2\"\n// Queries()[\"id\"] == \"\"\n//\n// GET /?field1=value1&field1=value2&field2=value3\n// Queries()[\"field1\"] == \"value2\"\n// Queries()[\"field2\"] == \"value3\"\n//\n// GET /?list_a=1&list_a=2&list_a=3&list_b[]=1&list_b[]=2&list_b[]=3&list_c=1,2,3\n// Queries()[\"list_a\"] == \"3\"\n// Queries()[\"list_b[]\"] == \"3\"\n// Queries()[\"list_c\"] == \"1,2,3\"\n//\n// GET /api/search?filters.author.name=John&filters.category.name=Technology&filters[customer][name]=Alice&filters[status]=pending\n// Queries()[\"filters.author.name\"] == \"John\"\n// Queries()[\"filters.category.name\"] == \"Technology\"\n// Queries()[\"filters[customer][name]\"] == \"Alice\"\n// Queries()[\"filters[status]\"] == \"pending\"\nfunc (c *Ctx) Queries() map[string]string {\n\tm := make(map[string]string, c.Context().QueryArgs().Len())\n\tc.Context().QueryArgs().VisitAll(func(key, value []byte) {\n\t\tm[c.app.getString(key)] = c.app.getString(value)\n\t})\n\treturn m\n}\n\n// QueryInt returns integer value of key string parameter in the url.\n// Default to empty or invalid key is 0.\n//\n//\tGET /?name=alex&wanna_cake=2&id=\n//\tQueryInt(\"wanna_cake\", 1) == 2\n//\tQueryInt(\"name\", 1) == 1\n//\tQueryInt(\"id\", 1) == 1\n//\tQueryInt(\"id\") == 0\nfunc (c *Ctx) QueryInt(key string, defaultValue ...int) int {\n\t// Use Atoi to convert the param to an int or return zero and an error\n\tvalue, err := strconv.Atoi(c.app.getString(c.fasthttp.QueryArgs().Peek(key)))\n\tif err != nil {\n\t\tif len(defaultValue) > 0 {\n\t\t\treturn defaultValue[0]\n\t\t}\n\t\treturn 0\n\t}\n\n\treturn value\n}\n\n// QueryBool returns bool value of key string parameter in the url.\n// Default to empty or invalid key is true.\n//\n//\tGet /?name=alex&want_pizza=false&id=\n//\tQueryBool(\"want_pizza\") == false\n//\tQueryBool(\"want_pizza\", true) == false\n//\tQueryBool(\"name\") == false\n//\tQueryBool(\"name\", true) == true\n//\tQueryBool(\"id\") == false\n//\tQueryBool(\"id\", true) == true\nfunc (c *Ctx) QueryBool(key string, defaultValue ...bool) bool {\n\tvalue, err := strconv.ParseBool(c.app.getString(c.fasthttp.QueryArgs().Peek(key)))\n\tif err != nil {\n\t\tif len(defaultValue) > 0 {\n\t\t\treturn defaultValue[0]\n\t\t}\n\t\treturn false\n\t}\n\treturn value\n}\n\n// QueryFloat returns float64 value of key string parameter in the url.\n// Default to empty or invalid key is 0.\n//\n//\tGET /?name=alex&amount=32.23&id=\n//\tQueryFloat(\"amount\") = 32.23\n//\tQueryFloat(\"amount\", 3) = 32.23\n//\tQueryFloat(\"name\", 1) = 1\n//\tQueryFloat(\"name\") = 0\n//\tQueryFloat(\"id\", 3) = 3\nfunc (c *Ctx) QueryFloat(key string, defaultValue ...float64) float64 {\n\t// use strconv.ParseFloat to convert the param to a float or return zero and an error.\n\tvalue, err := strconv.ParseFloat(c.app.getString(c.fasthttp.QueryArgs().Peek(key)), 64)\n\tif err != nil {\n\t\tif len(defaultValue) > 0 {\n\t\t\treturn defaultValue[0]\n\t\t}\n\t\treturn 0\n\t}\n\treturn value\n}\n\n// QueryParser binds the query string to a struct.\nfunc (c *Ctx) QueryParser(out interface{}) error {\n\tdata := make(map[string][]string)\n\tvar err error\n\n\tc.fasthttp.QueryArgs().VisitAll(func(key, val []byte) {\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\n\t\tk := c.app.getString(key)\n\t\tv := c.app.getString(val)\n\n\t\tif strings.Contains(k, \"[\") {\n\t\t\tk, err = parseParamSquareBrackets(k)\n\t\t}\n\n\t\tif c.app.config.EnableSplittingOnParsers && strings.Contains(v, \",\") && equalFieldType(out, reflect.Slice, k) {\n\t\t\tvalues := strings.Split(v, \",\")\n\t\t\tfor i := 0; i < len(values); i++ {\n\t\t\t\tdata[k] = append(data[k], values[i])\n\t\t\t}\n\t\t} else {\n\t\t\tdata[k] = append(data[k], v)\n\t\t}\n\t})\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn c.parseToStruct(queryTag, out, data)\n}\n\nfunc parseParamSquareBrackets(k string) (string, error) {\n\tbb := bytebufferpool.Get()\n\tdefer bytebufferpool.Put(bb)\n\n\tkbytes := []byte(k)\n\n\tfor i, b := range kbytes {\n\t\tif b == '[' && kbytes[i+1] != ']' {\n\t\t\tif err := bb.WriteByte('.'); err != nil {\n\t\t\t\treturn \"\", fmt.Errorf(\"failed to write: %w\", err)\n\t\t\t}\n\t\t}\n\n\t\tif b == '[' || b == ']' {\n\t\t\tcontinue\n\t\t}\n\n\t\tif err := bb.WriteByte(b); err != nil {\n\t\t\treturn \"\", fmt.Errorf(\"failed to write: %w\", err)\n\t\t}\n\t}\n\n\treturn bb.String(), nil\n}\n\n// ReqHeaderParser binds the request header strings to a struct.\nfunc (c *Ctx) ReqHeaderParser(out interface{}) error {\n\tdata := make(map[string][]string)\n\tc.fasthttp.Request.Header.VisitAll(func(key, val []byte) {\n\t\tk := c.app.getString(key)\n\t\tv := c.app.getString(val)\n\n\t\tif c.app.config.EnableSplittingOnParsers && strings.Contains(v, \",\") && equalFieldType(out, reflect.Slice, k) {\n\t\t\tvalues := strings.Split(v, \",\")\n\t\t\tfor i := 0; i < len(values); i++ {\n\t\t\t\tdata[k] = append(data[k], values[i])\n\t\t\t}\n\t\t} else {\n\t\t\tdata[k] = append(data[k], v)\n\t\t}\n\t})\n\n\treturn c.parseToStruct(reqHeaderTag, out, data)\n}\n\nfunc (*Ctx) parseToStruct(aliasTag string, out interface{}, data map[string][]string) error {\n\t// Get decoder from pool\n\tschemaDecoder, ok := decoderPoolMap[aliasTag].Get().(*schema.Decoder)\n\tif !ok {\n\t\tpanic(fmt.Errorf(\"failed to type-assert to *schema.Decoder\"))\n\t}\n\tdefer decoderPoolMap[aliasTag].Put(schemaDecoder)\n\n\t// Set alias tag\n\tschemaDecoder.SetAliasTag(aliasTag)\n\n\tif err := schemaDecoder.Decode(out, data); err != nil {\n\t\treturn fmt.Errorf(\"failed to decode: %w\", err)\n\t}\n\n\treturn nil\n}\n\nfunc equalFieldType(out interface{}, kind reflect.Kind, key string) bool {\n\t// Get type of interface\n\toutTyp := reflect.TypeOf(out).Elem()\n\tkey = utils.ToLower(key)\n\t// Must be a struct to match a field\n\tif outTyp.Kind() != reflect.Struct {\n\t\treturn false\n\t}\n\t// Copy interface to an value to be used\n\toutVal := reflect.ValueOf(out).Elem()\n\t// Loop over each field\n\tfor i := 0; i < outTyp.NumField(); i++ {\n\t\t// Get field value data\n\t\tstructField := outVal.Field(i)\n\t\t// Can this field be changed?\n\t\tif !structField.CanSet() {\n\t\t\tcontinue\n\t\t}\n\t\t// Get field key data\n\t\ttypeField := outTyp.Field(i)\n\t\t// Get type of field key\n\t\tstructFieldKind := structField.Kind()\n\t\t// Does the field type equals input?\n\t\tif structFieldKind != kind {\n\t\t\tcontinue\n\t\t}\n\t\t// Get tag from field if exist\n\t\tinputFieldName := typeField.Tag.Get(queryTag)\n\t\tif inputFieldName == \"\" {\n\t\t\tinputFieldName = typeField.Name\n\t\t} else {\n\t\t\tinputFieldName = strings.Split(inputFieldName, \",\")[0]\n\t\t}\n\t\t// Compare field/tag with provided key\n\t\tif utils.ToLower(inputFieldName) == key {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nvar (\n\tErrRangeMalformed     = errors.New(\"range: malformed range header string\")\n\tErrRangeUnsatisfiable = errors.New(\"range: unsatisfiable range\")\n)\n\n// Range returns a struct containing the type and a slice of ranges.\nfunc (c *Ctx) Range(size int) (Range, error) {\n\tvar rangeData Range\n\trangeStr := c.Get(HeaderRange)\n\tif rangeStr == \"\" || !strings.Contains(rangeStr, \"=\") {\n\t\treturn rangeData, ErrRangeMalformed\n\t}\n\tdata := strings.Split(rangeStr, \"=\")\n\tconst expectedDataParts = 2\n\tif len(data) != expectedDataParts {\n\t\treturn rangeData, ErrRangeMalformed\n\t}\n\trangeData.Type = data[0]\n\tarr := strings.Split(data[1], \",\")\n\tfor i := 0; i < len(arr); i++ {\n\t\titem := strings.Split(arr[i], \"-\")\n\t\tif len(item) == 1 {\n\t\t\treturn rangeData, ErrRangeMalformed\n\t\t}\n\t\tstart, startErr := strconv.Atoi(item[0])\n\t\tend, endErr := strconv.Atoi(item[1])\n\t\tif startErr != nil { // -nnn\n\t\t\tstart = size - end\n\t\t\tend = size - 1\n\t\t} else if endErr != nil { // nnn-\n\t\t\tend = size - 1\n\t\t}\n\t\tif end > size-1 { // limit last-byte-pos to current length\n\t\t\tend = size - 1\n\t\t}\n\t\tif start > end || start < 0 {\n\t\t\tcontinue\n\t\t}\n\t\trangeData.Ranges = append(rangeData.Ranges, struct {\n\t\t\tStart int\n\t\t\tEnd   int\n\t\t}{\n\t\t\tstart,\n\t\t\tend,\n\t\t})\n\t}\n\tif len(rangeData.Ranges) < 1 {\n\t\treturn rangeData, ErrRangeUnsatisfiable\n\t}\n\n\treturn rangeData, nil\n}\n\n// Redirect to the URL derived from the specified path, with specified status.\n// If status is not specified, status defaults to 302 Found.\nfunc (c *Ctx) Redirect(location string, status ...int) error {\n\tc.setCanonical(HeaderLocation, location)\n\tif len(status) > 0 {\n\t\tc.Status(status[0])\n\t} else {\n\t\tc.Status(StatusFound)\n\t}\n\treturn nil\n}\n\n// Bind Add vars to default view var map binding to template engine.\n// Variables are read by the Render method and may be overwritten.\nfunc (c *Ctx) Bind(vars Map) error {\n\t// init viewBindMap - lazy map\n\tfor k, v := range vars {\n\t\tc.viewBindMap.Store(k, v)\n\t}\n\treturn nil\n}\n\n// getLocationFromRoute get URL location from route using parameters\nfunc (c *Ctx) getLocationFromRoute(route Route, params Map) (string, error) {\n\tbuf := bytebufferpool.Get()\n\tfor _, segment := range route.routeParser.segs {\n\t\tif !segment.IsParam {\n\t\t\t_, err := buf.WriteString(segment.Const)\n\t\t\tif err != nil {\n\t\t\t\treturn \"\", fmt.Errorf(\"failed to write string: %w\", err)\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\n\t\tfor key, val := range params {\n\t\t\tisSame := key == segment.ParamName || (!c.app.config.CaseSensitive && utils.EqualFold(key, segment.ParamName))\n\t\t\tisGreedy := segment.IsGreedy && len(key) == 1 && isInCharset(key[0], greedyParameters)\n\t\t\tif isSame || isGreedy {\n\t\t\t\t_, err := buf.WriteString(utils.ToString(val))\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn \"\", fmt.Errorf(\"failed to write string: %w\", err)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tlocation := buf.String()\n\t// release buffer\n\tbytebufferpool.Put(buf)\n\treturn location, nil\n}\n\n// GetRouteURL generates URLs to named routes, with parameters. URLs are relative, for example: \"/user/1831\"\nfunc (c *Ctx) GetRouteURL(routeName string, params Map) (string, error) {\n\treturn c.getLocationFromRoute(c.App().GetRoute(routeName), params)\n}\n\n// RedirectToRoute to the Route registered in the app with appropriate parameters\n// If status is not specified, status defaults to 302 Found.\n// If you want to send queries to route, you must add \"queries\" key typed as map[string]string to params.\nfunc (c *Ctx) RedirectToRoute(routeName string, params Map, status ...int) error {\n\tlocation, err := c.getLocationFromRoute(c.App().GetRoute(routeName), params)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Check queries\n\tif queries, ok := params[\"queries\"].(map[string]string); ok {\n\t\tqueryText := bytebufferpool.Get()\n\t\tdefer bytebufferpool.Put(queryText)\n\n\t\ti := 1\n\t\tfor k, v := range queries {\n\t\t\t_, _ = queryText.WriteString(k + \"=\" + v) //nolint:errcheck // This will never fail\n\n\t\t\tif i != len(queries) {\n\t\t\t\t_, _ = queryText.WriteString(\"&\") //nolint:errcheck // This will never fail\n\t\t\t}\n\t\t\ti++\n\t\t}\n\n\t\treturn c.Redirect(location+\"?\"+queryText.String(), status...)\n\t}\n\treturn c.Redirect(location, status...)\n}\n\n// RedirectBack to the URL to referer\n// If status is not specified, status defaults to 302 Found.\nfunc (c *Ctx) RedirectBack(fallback string, status ...int) error {\n\tlocation := c.Get(HeaderReferer)\n\tif location == \"\" {\n\t\tlocation = fallback\n\t}\n\treturn c.Redirect(location, status...)\n}\n\n// Render a template with data and sends a text/html response.\n// We support the following engines: html, amber, handlebars, mustache, pug\nfunc (c *Ctx) Render(name string, bind interface{}, layouts ...string) error {\n\t// Get new buffer from pool\n\tbuf := bytebufferpool.Get()\n\tdefer bytebufferpool.Put(buf)\n\n\t// Pass-locals-to-views, bind, appListKeys\n\tc.renderExtensions(bind)\n\n\tvar rendered bool\n\tfor i := len(c.app.mountFields.appListKeys) - 1; i >= 0; i-- {\n\t\tprefix := c.app.mountFields.appListKeys[i]\n\t\tapp := c.app.mountFields.appList[prefix]\n\t\tif prefix == \"\" || strings.Contains(c.OriginalURL(), prefix) {\n\t\t\tif len(layouts) == 0 && app.config.ViewsLayout != \"\" {\n\t\t\t\tlayouts = []string{\n\t\t\t\t\tapp.config.ViewsLayout,\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Render template from Views\n\t\t\tif app.config.Views != nil {\n\t\t\t\tif err := app.config.Views.Render(buf, name, bind, layouts...); err != nil {\n\t\t\t\t\treturn fmt.Errorf(\"failed to render: %w\", err)\n\t\t\t\t}\n\n\t\t\t\trendered = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\tif !rendered {\n\t\t// Render raw template using 'name' as filepath if no engine is set\n\t\tvar tmpl *template.Template\n\t\tif _, err := readContent(buf, name); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Parse template\n\t\ttmpl, err := template.New(\"\").Parse(c.app.getString(buf.Bytes()))\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"failed to parse: %w\", err)\n\t\t}\n\t\tbuf.Reset()\n\t\t// Render template\n\t\tif err := tmpl.Execute(buf, bind); err != nil {\n\t\t\treturn fmt.Errorf(\"failed to execute: %w\", err)\n\t\t}\n\t}\n\n\t// Set Content-Type to text/html\n\tc.fasthttp.Response.Header.SetContentType(MIMETextHTMLCharsetUTF8)\n\t// Set rendered template to body\n\tc.fasthttp.Response.SetBody(buf.Bytes())\n\n\treturn nil\n}\n\nfunc (c *Ctx) renderExtensions(bind interface{}) {\n\tif bindMap, ok := bind.(Map); ok {\n\t\t// Bind view map\n\t\tc.viewBindMap.Range(func(key, value interface{}) bool {\n\t\t\tkeyValue, ok := key.(string)\n\t\t\tif !ok {\n\t\t\t\treturn true\n\t\t\t}\n\t\t\tif _, ok := bindMap[keyValue]; !ok {\n\t\t\t\tbindMap[keyValue] = value\n\t\t\t}\n\t\t\treturn true\n\t\t})\n\n\t\t// Check if the PassLocalsToViews option is enabled (by default it is disabled)\n\t\tif c.app.config.PassLocalsToViews {\n\t\t\t// Loop through each local and set it in the map\n\t\t\tc.fasthttp.VisitUserValues(func(key []byte, val interface{}) {\n\t\t\t\t// check if bindMap doesn't contain the key\n\t\t\t\tif _, ok := bindMap[c.app.getString(key)]; !ok {\n\t\t\t\t\t// Set the key and value in the bindMap\n\t\t\t\t\tbindMap[c.app.getString(key)] = val\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t}\n\n\tif len(c.app.mountFields.appListKeys) == 0 {\n\t\tc.app.generateAppListKeys()\n\t}\n}\n\n// Route returns the matched Route struct.\nfunc (c *Ctx) Route() *Route {\n\tif c.route == nil {\n\t\t// Fallback for fasthttp error handler\n\t\treturn &Route{\n\t\t\tpath:     c.pathOriginal,\n\t\t\tPath:     c.pathOriginal,\n\t\t\tMethod:   c.method,\n\t\t\tHandlers: make([]Handler, 0),\n\t\t\tParams:   make([]string, 0),\n\t\t}\n\t}\n\treturn c.route\n}\n\n// SaveFile saves any multipart file to disk.\nfunc (*Ctx) SaveFile(fileheader *multipart.FileHeader, path string) error {\n\treturn fasthttp.SaveMultipartFile(fileheader, path)\n}\n\n// SaveFileToStorage saves any multipart file to an external storage system.\nfunc (*Ctx) SaveFileToStorage(fileheader *multipart.FileHeader, path string, storage Storage) error {\n\tfile, err := fileheader.Open()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to open: %w\", err)\n\t}\n\n\tcontent, err := io.ReadAll(file)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to read: %w\", err)\n\t}\n\n\tif err := storage.Set(path, content, 0); err != nil {\n\t\treturn fmt.Errorf(\"failed to store: %w\", err)\n\t}\n\n\treturn nil\n}\n\n// Secure returns whether a secure connection was established.\nfunc (c *Ctx) Secure() bool {\n\treturn c.Protocol() == schemeHTTPS\n}\n\n// Send sets the HTTP response body without copying it.\n// From this point onward the body argument must not be changed.\nfunc (c *Ctx) Send(body []byte) error {\n\t// Write response body\n\tc.fasthttp.Response.SetBodyRaw(body)\n\treturn nil\n}\n\nvar (\n\tsendFileOnce    sync.Once\n\tsendFileFS      *fasthttp.FS\n\tsendFileHandler fasthttp.RequestHandler\n)\n\n// SendFile transfers the file from the given path.\n// The file is not compressed by default, enable this by passing a 'true' argument\n// Sets the Content-Type response HTTP header field based on the filenames extension.\nfunc (c *Ctx) SendFile(file string, compress ...bool) error {\n\t// Save the filename, we will need it in the error message if the file isn't found\n\tfilename := file\n\n\t// https://github.com/valyala/fasthttp/blob/c7576cc10cabfc9c993317a2d3f8355497bea156/fs.go#L129-L134\n\tsendFileOnce.Do(func() {\n\t\tconst cacheDuration = 10 * time.Second\n\t\tsendFileFS = &fasthttp.FS{\n\t\t\tRoot:                 \"\",\n\t\t\tAllowEmptyRoot:       true,\n\t\t\tGenerateIndexPages:   false,\n\t\t\tAcceptByteRange:      true,\n\t\t\tCompress:             true,\n\t\t\tCompressedFileSuffix: c.app.config.CompressedFileSuffix,\n\t\t\tCacheDuration:        cacheDuration,\n\t\t\tIndexNames:           []string{\"index.html\"},\n\t\t\tPathNotFound: func(ctx *fasthttp.RequestCtx) {\n\t\t\t\tctx.Response.SetStatusCode(StatusNotFound)\n\t\t\t},\n\t\t}\n\t\tsendFileHandler = sendFileFS.NewRequestHandler()\n\t})\n\n\t// Keep original path for mutable params\n\tc.pathOriginal = utils.CopyString(c.pathOriginal)\n\t// Disable compression\n\tif len(compress) == 0 || !compress[0] {\n\t\t// https://github.com/valyala/fasthttp/blob/7cc6f4c513f9e0d3686142e0a1a5aa2f76b3194a/fs.go#L55\n\t\tc.fasthttp.Request.Header.Del(HeaderAcceptEncoding)\n\t}\n\t// copy of https://github.com/valyala/fasthttp/blob/7cc6f4c513f9e0d3686142e0a1a5aa2f76b3194a/fs.go#L103-L121 with small adjustments\n\tif len(file) == 0 || !filepath.IsAbs(file) {\n\t\t// extend relative path to absolute path\n\t\thasTrailingSlash := len(file) > 0 && (file[len(file)-1] == '/' || file[len(file)-1] == '\\\\')\n\n\t\tvar err error\n\t\tfile = filepath.FromSlash(file)\n\t\tif file, err = filepath.Abs(file); err != nil {\n\t\t\treturn fmt.Errorf(\"failed to determine abs file path: %w\", err)\n\t\t}\n\t\tif hasTrailingSlash {\n\t\t\tfile += \"/\"\n\t\t}\n\t}\n\t// convert the path to forward slashes regardless the OS in order to set the URI properly\n\t// the handler will convert back to OS path separator before opening the file\n\tfile = filepath.ToSlash(file)\n\n\t// Restore the original requested URL\n\toriginalURL := utils.CopyString(c.OriginalURL())\n\tdefer c.fasthttp.Request.SetRequestURI(originalURL)\n\t// Set new URI for fileHandler\n\tc.fasthttp.Request.SetRequestURI(file)\n\t// Save status code\n\tstatus := c.fasthttp.Response.StatusCode()\n\t// Serve file\n\tsendFileHandler(c.fasthttp)\n\t// Get the status code which is set by fasthttp\n\tfsStatus := c.fasthttp.Response.StatusCode()\n\t// Set the status code set by the user if it is different from the fasthttp status code and 200\n\tif status != fsStatus && status != StatusOK {\n\t\tc.Status(status)\n\t}\n\t// Check for error\n\tif status != StatusNotFound && fsStatus == StatusNotFound {\n\t\treturn NewError(StatusNotFound, fmt.Sprintf(\"sendfile: file %s not found\", filename))\n\t}\n\treturn nil\n}\n\n// SendStatus sets the HTTP status code and if the response body is empty,\n// it sets the correct status message in the body.\nfunc (c *Ctx) SendStatus(status int) error {\n\tc.Status(status)\n\n\t// Only set status body when there is no response body\n\tif len(c.fasthttp.Response.Body()) == 0 {\n\t\treturn c.SendString(utils.StatusMessage(status))\n\t}\n\n\treturn nil\n}\n\n// SendString sets the HTTP response body for string types.\n// This means no type assertion, recommended for faster performance\nfunc (c *Ctx) SendString(body string) error {\n\tc.fasthttp.Response.SetBodyString(body)\n\n\treturn nil\n}\n\n// SendStream sets response body stream and optional body size.\nfunc (c *Ctx) SendStream(stream io.Reader, size ...int) error {\n\tif len(size) > 0 && size[0] >= 0 {\n\t\tc.fasthttp.Response.SetBodyStream(stream, size[0])\n\t} else {\n\t\tc.fasthttp.Response.SetBodyStream(stream, -1)\n\t}\n\n\treturn nil\n}\n\n// Set sets the response's HTTP header field to the specified key, value.\nfunc (c *Ctx) Set(key, val string) {\n\tc.fasthttp.Response.Header.Set(key, val)\n}\n\nfunc (c *Ctx) setCanonical(key, val string) {\n\tc.fasthttp.Response.Header.SetCanonical(c.app.getBytes(key), c.app.getBytes(val))\n}\n\n// Subdomains returns a string slice of subdomains in the domain name of the request.\n// The subdomain offset, which defaults to 2, is used for determining the beginning of the subdomain segments.\nfunc (c *Ctx) Subdomains(offset ...int) []string {\n\to := 2\n\tif len(offset) > 0 {\n\t\to = offset[0]\n\t}\n\tsubdomains := strings.Split(c.Hostname(), \".\")\n\tl := len(subdomains) - o\n\t// Check index to avoid slice bounds out of range panic\n\tif l < 0 {\n\t\tl = len(subdomains)\n\t}\n\tsubdomains = subdomains[:l]\n\treturn subdomains\n}\n\n// Stale is not implemented yet, pull requests are welcome!\nfunc (c *Ctx) Stale() bool {\n\treturn !c.Fresh()\n}\n\n// Status sets the HTTP status for the response.\n// This method is chainable.\nfunc (c *Ctx) Status(status int) *Ctx {\n\tc.fasthttp.Response.SetStatusCode(status)\n\treturn c\n}\n\n// String returns unique string representation of the ctx.\n//\n// The returned value may be useful for logging.\nfunc (c *Ctx) String() string {\n\treturn fmt.Sprintf(\n\t\t\"#%016X - %s <-> %s - %s %s\",\n\t\tc.fasthttp.ID(),\n\t\tc.fasthttp.LocalAddr(),\n\t\tc.fasthttp.RemoteAddr(),\n\t\tc.fasthttp.Request.Header.Method(),\n\t\tc.fasthttp.URI().FullURI(),\n\t)\n}\n\n// Type sets the Content-Type HTTP header to the MIME type specified by the file extension.\nfunc (c *Ctx) Type(extension string, charset ...string) *Ctx {\n\tif len(charset) > 0 {\n\t\tc.fasthttp.Response.Header.SetContentType(utils.GetMIME(extension) + \"; charset=\" + charset[0])\n\t} else {\n\t\tc.fasthttp.Response.Header.SetContentType(utils.GetMIME(extension))\n\t}\n\treturn c\n}\n\n// Vary adds the given header field to the Vary response header.\n// This will append the header, if not already listed, otherwise leaves it listed in the current location.\nfunc (c *Ctx) Vary(fields ...string) {\n\tc.Append(HeaderVary, fields...)\n}\n\n// Write appends p into response body.\nfunc (c *Ctx) Write(p []byte) (int, error) {\n\tc.fasthttp.Response.AppendBody(p)\n\treturn len(p), nil\n}\n\n// Writef appends f & a into response body writer.\nfunc (c *Ctx) Writef(f string, a ...interface{}) (int, error) {\n\t//nolint:wrapcheck // This must not be wrapped\n\treturn fmt.Fprintf(c.fasthttp.Response.BodyWriter(), f, a...)\n}\n\n// WriteString appends s to response body.\nfunc (c *Ctx) WriteString(s string) (int, error) {\n\tc.fasthttp.Response.AppendBodyString(s)\n\treturn len(s), nil\n}\n\n// XHR returns a Boolean property, that is true, if the request's X-Requested-With header field is XMLHttpRequest,\n// indicating that the request was issued by a client library (such as jQuery).\nfunc (c *Ctx) XHR() bool {\n\treturn utils.EqualFoldBytes(c.app.getBytes(c.Get(HeaderXRequestedWith)), []byte(\"xmlhttprequest\"))\n}\n\n// configDependentPaths set paths for route recognition and prepared paths for the user,\n// here the features for caseSensitive, decoded paths, strict paths are evaluated\nfunc (c *Ctx) configDependentPaths() {\n\tc.pathBuffer = append(c.pathBuffer[0:0], c.pathOriginal...)\n\t// If UnescapePath enabled, we decode the path and save it for the framework user\n\tif c.app.config.UnescapePath {\n\t\tc.pathBuffer = fasthttp.AppendUnquotedArg(c.pathBuffer[:0], c.pathBuffer)\n\t}\n\tc.path = c.app.getString(c.pathBuffer)\n\n\t// another path is specified which is for routing recognition only\n\t// use the path that was changed by the previous configuration flags\n\tc.detectionPathBuffer = append(c.detectionPathBuffer[0:0], c.pathBuffer...)\n\t// If CaseSensitive is disabled, we lowercase the original path\n\tif !c.app.config.CaseSensitive {\n\t\tc.detectionPathBuffer = utils.ToLowerBytes(c.detectionPathBuffer)\n\t}\n\t// If StrictRouting is disabled, we strip all trailing slashes\n\tif !c.app.config.StrictRouting && len(c.detectionPathBuffer) > 1 && c.detectionPathBuffer[len(c.detectionPathBuffer)-1] == '/' {\n\t\tc.detectionPathBuffer = utils.TrimRightBytes(c.detectionPathBuffer, '/')\n\t}\n\tc.detectionPath = c.app.getString(c.detectionPathBuffer)\n\n\t// Define the path for dividing routes into areas for fast tree detection, so that fewer routes need to be traversed,\n\t// since the first three characters area select a list of routes\n\tc.treePath = c.treePath[0:0]\n\tconst maxDetectionPaths = 3\n\tif len(c.detectionPath) >= maxDetectionPaths {\n\t\tc.treePath = c.detectionPath[:maxDetectionPaths]\n\t}\n}\n\nfunc (c *Ctx) IsProxyTrusted() bool {\n\tif !c.app.config.EnableTrustedProxyCheck {\n\t\treturn true\n\t}\n\n\tip := c.fasthttp.RemoteIP()\n\n\tif _, trusted := c.app.config.trustedProxiesMap[ip.String()]; trusted {\n\t\treturn true\n\t}\n\n\tfor _, ipNet := range c.app.config.trustedProxyRanges {\n\t\tif ipNet.Contains(ip) {\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}\n\nvar localHosts = [...]string{\"127.0.0.1\", \"::1\"}\n\n// IsLocalHost will return true if address is a localhost address.\nfunc (*Ctx) isLocalHost(address string) bool {\n\tfor _, h := range localHosts {\n\t\tif address == h {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// IsFromLocal will return true if request came from local.\nfunc (c *Ctx) IsFromLocal() bool {\n\treturn c.isLocalHost(c.fasthttp.RemoteIP().String())\n}\n", "// \u26a1\ufe0f Fiber is an Express inspired web framework written in Go with \u2615\ufe0f\n// \ud83e\udd16 Github Repository: https://github.com/gofiber/fiber\n// \ud83d\udccc API Documentation: https://docs.gofiber.io\n\n//nolint:bodyclose // Much easier to just ignore memory leaks in tests\npackage fiber\n\nimport (\n\t\"bufio\"\n\t\"bytes\"\n\t\"compress/gzip\"\n\t\"compress/zlib\"\n\t\"context\"\n\t\"crypto/tls\"\n\t\"encoding/xml\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"mime/multipart\"\n\t\"net\"\n\t\"net/http/httptest\"\n\t\"net/url\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"reflect\"\n\t\"strconv\"\n\t\"strings\"\n\t\"testing\"\n\t\"text/template\"\n\t\"time\"\n\n\t\"github.com/gofiber/fiber/v2/internal/storage/memory\"\n\t\"github.com/gofiber/fiber/v2/utils\"\n\n\t\"github.com/valyala/bytebufferpool\"\n\t\"github.com/valyala/fasthttp\"\n)\n\n// go test -run Test_Ctx_Accepts\nfunc Test_Ctx_Accepts(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tc.Request().Header.Set(HeaderAccept, \"text/html,application/xhtml+xml,application/xml;q=0.9\")\n\tutils.AssertEqual(t, \"\", c.Accepts(\"\"))\n\tutils.AssertEqual(t, \"\", c.Accepts())\n\tutils.AssertEqual(t, \".xml\", c.Accepts(\".xml\"))\n\tutils.AssertEqual(t, \"\", c.Accepts(\".john\"))\n\tutils.AssertEqual(t, \"application/xhtml+xml\", c.Accepts(\"application/xml\", \"application/xml+rss\", \"application/yaml\", \"application/xhtml+xml\"), \"must use client-preferred mime type\")\n\n\tc.Request().Header.Set(HeaderAccept, \"application/json, text/plain, */*;q=0\")\n\tutils.AssertEqual(t, \"\", c.Accepts(\"html\"), \"must treat */*;q=0 as not acceptable\")\n\n\tc.Request().Header.Set(HeaderAccept, \"text/*, application/json\")\n\tutils.AssertEqual(t, \"html\", c.Accepts(\"html\"))\n\tutils.AssertEqual(t, \"text/html\", c.Accepts(\"text/html\"))\n\tutils.AssertEqual(t, \"json\", c.Accepts(\"json\", \"text\"))\n\tutils.AssertEqual(t, \"application/json\", c.Accepts(\"application/json\"))\n\tutils.AssertEqual(t, \"\", c.Accepts(\"image/png\"))\n\tutils.AssertEqual(t, \"\", c.Accepts(\"png\"))\n\n\tc.Request().Header.Set(HeaderAccept, \"text/html, application/json\")\n\tutils.AssertEqual(t, \"text/*\", c.Accepts(\"text/*\"))\n\n\tc.Request().Header.Set(HeaderAccept, \"*/*\")\n\tutils.AssertEqual(t, \"html\", c.Accepts(\"html\"))\n}\n\n// go test -v -run=^$ -bench=Benchmark_Ctx_Accepts -benchmem -count=4\nfunc Benchmark_Ctx_Accepts(b *testing.B) {\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tacceptHeader := \"text/html,application/xhtml+xml,application/xml;q=0.9\"\n\tc.Request().Header.Set(\"Accept\", acceptHeader)\n\tacceptValues := [][]string{\n\t\t{\".xml\"},\n\t\t{\"json\", \"xml\"},\n\t\t{\"application/json\", \"application/xml\"},\n\t}\n\texpectedResults := []string{\".xml\", \"xml\", \"application/xml\"}\n\n\tfor i := 0; i < len(acceptValues); i++ {\n\t\tb.Run(fmt.Sprintf(\"run-%#v\", acceptValues[i]), func(bb *testing.B) {\n\t\t\tvar res string\n\t\t\tbb.ReportAllocs()\n\t\t\tbb.ResetTimer()\n\n\t\t\tfor n := 0; n < bb.N; n++ {\n\t\t\t\tres = c.Accepts(acceptValues[i]...)\n\t\t\t}\n\t\t\tutils.AssertEqual(bb, expectedResults[i], res)\n\t\t})\n\t}\n}\n\n// go test -run Test_Ctx_Accepts_EmptyAccept\nfunc Test_Ctx_Accepts_EmptyAccept(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tutils.AssertEqual(t, \".forwarded\", c.Accepts(\".forwarded\"))\n}\n\n// go test -run Test_Ctx_Accepts_Wildcard\nfunc Test_Ctx_Accepts_Wildcard(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tc.Request().Header.Set(HeaderAccept, \"*/*;q=0.9\")\n\tutils.AssertEqual(t, \"html\", c.Accepts(\"html\"))\n\tutils.AssertEqual(t, \"foo\", c.Accepts(\"foo\"))\n\tutils.AssertEqual(t, \".bar\", c.Accepts(\".bar\"))\n\tc.Request().Header.Set(HeaderAccept, \"text/html,application/*;q=0.9\")\n\tutils.AssertEqual(t, \"xml\", c.Accepts(\"xml\"))\n}\n\n// go test -run Test_Ctx_AcceptsCharsets\nfunc Test_Ctx_AcceptsCharsets(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tc.Request().Header.Set(HeaderAcceptCharset, \"utf-8, iso-8859-1;q=0.5\")\n\tutils.AssertEqual(t, \"utf-8\", c.AcceptsCharsets(\"utf-8\"))\n}\n\n// go test -v -run=^$ -bench=Benchmark_Ctx_AcceptsCharsets -benchmem -count=4\nfunc Benchmark_Ctx_AcceptsCharsets(b *testing.B) {\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tc.Request().Header.Set(\"Accept-Charset\", \"utf-8, iso-8859-1;q=0.5\")\n\tvar res string\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\tres = c.AcceptsCharsets(\"utf-8\")\n\t}\n\tutils.AssertEqual(b, \"utf-8\", res)\n}\n\n// go test -run Test_Ctx_AcceptsEncodings\nfunc Test_Ctx_AcceptsEncodings(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tc.Request().Header.Set(HeaderAcceptEncoding, \"deflate, gzip;q=1.0, *;q=0.5\")\n\tutils.AssertEqual(t, \"gzip\", c.AcceptsEncodings(\"gzip\"))\n\tutils.AssertEqual(t, \"abc\", c.AcceptsEncodings(\"abc\"))\n}\n\n// go test -v -run=^$ -bench=Benchmark_Ctx_AcceptsEncodings -benchmem -count=4\nfunc Benchmark_Ctx_AcceptsEncodings(b *testing.B) {\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tc.Request().Header.Set(HeaderAcceptEncoding, \"deflate, gzip;q=1.0, *;q=0.5\")\n\tvar res string\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\tres = c.AcceptsEncodings(\"gzip\")\n\t}\n\tutils.AssertEqual(b, \"gzip\", res)\n}\n\n// go test -run Test_Ctx_AcceptsLanguages\nfunc Test_Ctx_AcceptsLanguages(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tc.Request().Header.Set(HeaderAcceptLanguage, \"fr-CH, fr;q=0.9, en;q=0.8, de;q=0.7, *;q=0.5\")\n\tutils.AssertEqual(t, \"fr\", c.AcceptsLanguages(\"fr\"))\n}\n\n// go test -v -run=^$ -bench=Benchmark_Ctx_AcceptsLanguages -benchmem -count=4\nfunc Benchmark_Ctx_AcceptsLanguages(b *testing.B) {\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tc.Request().Header.Set(HeaderAcceptLanguage, \"fr-CH, fr;q=0.9, en;q=0.8, de;q=0.7, *;q=0.5\")\n\tvar res string\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\tres = c.AcceptsLanguages(\"fr\")\n\t}\n\tutils.AssertEqual(b, \"fr\", res)\n}\n\n// go test -run Test_Ctx_App\nfunc Test_Ctx_App(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tapp.config.BodyLimit = 1000\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tutils.AssertEqual(t, 1000, c.App().config.BodyLimit)\n}\n\n// go test -run Test_Ctx_Append\nfunc Test_Ctx_Append(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tc.Append(\"X-Test\", \"Hello\")\n\tc.Append(\"X-Test\", \"World\")\n\tc.Append(\"X-Test\", \"Hello\", \"World\")\n\t// similar value in the middle\n\tc.Append(\"X2-Test\", \"World\")\n\tc.Append(\"X2-Test\", \"XHello\")\n\tc.Append(\"X2-Test\", \"Hello\", \"World\")\n\t// similar value at the start\n\tc.Append(\"X3-Test\", \"XHello\")\n\tc.Append(\"X3-Test\", \"World\")\n\tc.Append(\"X3-Test\", \"Hello\", \"World\")\n\t// try it with multiple similar values\n\tc.Append(\"X4-Test\", \"XHello\")\n\tc.Append(\"X4-Test\", \"Hello\")\n\tc.Append(\"X4-Test\", \"HelloZ\")\n\tc.Append(\"X4-Test\", \"YHello\")\n\tc.Append(\"X4-Test\", \"Hello\")\n\tc.Append(\"X4-Test\", \"YHello\")\n\tc.Append(\"X4-Test\", \"HelloZ\")\n\tc.Append(\"X4-Test\", \"XHello\")\n\t// without append value\n\tc.Append(\"X-Custom-Header\")\n\n\tutils.AssertEqual(t, \"Hello, World\", string(c.Response().Header.Peek(\"X-Test\")))\n\tutils.AssertEqual(t, \"World, XHello, Hello\", string(c.Response().Header.Peek(\"X2-Test\")))\n\tutils.AssertEqual(t, \"XHello, World, Hello\", string(c.Response().Header.Peek(\"X3-Test\")))\n\tutils.AssertEqual(t, \"XHello, Hello, HelloZ, YHello\", string(c.Response().Header.Peek(\"X4-Test\")))\n\tutils.AssertEqual(t, \"\", string(c.Response().Header.Peek(\"x-custom-header\")))\n}\n\n// go test -v -run=^$ -bench=Benchmark_Ctx_Append -benchmem -count=4\nfunc Benchmark_Ctx_Append(b *testing.B) {\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\tc.Append(\"X-Custom-Header\", \"Hello\")\n\t\tc.Append(\"X-Custom-Header\", \"World\")\n\t\tc.Append(\"X-Custom-Header\", \"Hello\")\n\t}\n\tutils.AssertEqual(b, \"Hello, World\", app.getString(c.Response().Header.Peek(\"X-Custom-Header\")))\n}\n\n// go test -run Test_Ctx_Attachment\nfunc Test_Ctx_Attachment(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\t// empty\n\tc.Attachment()\n\tutils.AssertEqual(t, `attachment`, string(c.Response().Header.Peek(HeaderContentDisposition)))\n\t// real filename\n\tc.Attachment(\"./static/img/logo.png\")\n\tutils.AssertEqual(t, `attachment; filename=\"logo.png\"`, string(c.Response().Header.Peek(HeaderContentDisposition)))\n\tutils.AssertEqual(t, \"image/png\", string(c.Response().Header.Peek(HeaderContentType)))\n\t// check quoting\n\tc.Attachment(\"another document.pdf\\\"\\r\\nBla: \\\"fasel\")\n\tutils.AssertEqual(t, `attachment; filename=\"another+document.pdf%22%0D%0ABla%3A+%22fasel\"`, string(c.Response().Header.Peek(HeaderContentDisposition)))\n}\n\n// go test -v -run=^$ -bench=Benchmark_Ctx_Attachment -benchmem -count=4\nfunc Benchmark_Ctx_Attachment(b *testing.B) {\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\t// example with quote params\n\t\tc.Attachment(\"another document.pdf\\\"\\r\\nBla: \\\"fasel\")\n\t}\n\tutils.AssertEqual(b, `attachment; filename=\"another+document.pdf%22%0D%0ABla%3A+%22fasel\"`, string(c.Response().Header.Peek(HeaderContentDisposition)))\n}\n\n// go test -run Test_Ctx_BaseURL\nfunc Test_Ctx_BaseURL(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tc.Request().SetRequestURI(\"http://google.com/test\")\n\tutils.AssertEqual(t, \"http://google.com\", c.BaseURL())\n\t// Check cache\n\tutils.AssertEqual(t, \"http://google.com\", c.BaseURL())\n}\n\n// go test -v -run=^$ -bench=Benchmark_Ctx_BaseURL -benchmem\nfunc Benchmark_Ctx_BaseURL(b *testing.B) {\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tc.Request().SetHost(\"google.com:1337\")\n\tc.Request().URI().SetPath(\"/haha/oke/lol\")\n\tvar res string\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\tres = c.BaseURL()\n\t}\n\tutils.AssertEqual(b, \"http://google.com:1337\", res)\n}\n\n// go test -run Test_Ctx_Body\nfunc Test_Ctx_Body(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tc.Request().SetBody([]byte(\"john=doe\"))\n\tutils.AssertEqual(t, []byte(\"john=doe\"), c.Body())\n}\n\nfunc Benchmark_Ctx_Body(b *testing.B) {\n\tconst input = \"john=doe\"\n\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\n\tc.Request().SetBody([]byte(input))\n\tfor i := 0; i < b.N; i++ {\n\t\t_ = c.Body()\n\t}\n\n\tutils.AssertEqual(b, []byte(input), c.Body())\n}\n\n// go test -run Test_Ctx_Body_With_Compression\nfunc Test_Ctx_Body_With_Compression(t *testing.T) {\n\tt.Parallel()\n\ttests := []struct {\n\t\tname            string\n\t\tcontentEncoding string\n\t\tbody            []byte\n\t\texpectedBody    []byte\n\t}{\n\t\t{\n\t\t\tname:            \"gzip\",\n\t\t\tcontentEncoding: \"gzip\",\n\t\t\tbody:            []byte(\"john=doe\"),\n\t\t\texpectedBody:    []byte(\"john=doe\"),\n\t\t},\n\t\t{\n\t\t\tname:            \"unsupported_encoding\",\n\t\t\tcontentEncoding: \"undefined\",\n\t\t\tbody:            []byte(\"keeps_ORIGINAL\"),\n\t\t\texpectedBody:    []byte(\"keeps_ORIGINAL\"),\n\t\t},\n\t\t{\n\t\t\tname:            \"gzip then unsupported\",\n\t\t\tcontentEncoding: \"gzip, undefined\",\n\t\t\tbody:            []byte(\"Go, be gzipped\"),\n\t\t\texpectedBody:    []byte(\"Go, be gzipped\"),\n\t\t},\n\t\t{\n\t\t\tname:            \"invalid_deflate\",\n\t\t\tcontentEncoding: \"gzip,deflate\",\n\t\t\tbody:            []byte(\"I'm not correctly compressed\"),\n\t\t\texpectedBody:    []byte(zlib.ErrHeader.Error()),\n\t\t},\n\t}\n\n\tfor _, testObject := range tests {\n\t\ttCase := testObject // Duplicate object to ensure it will be unique across all runs\n\t\tt.Run(tCase.name, func(t *testing.T) {\n\t\t\tapp := New()\n\t\t\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\t\t\tdefer app.ReleaseCtx(c)\n\t\t\tc.Request().Header.Set(\"Content-Encoding\", tCase.contentEncoding)\n\n\t\t\tif strings.Contains(tCase.contentEncoding, \"gzip\") {\n\t\t\t\tvar b bytes.Buffer\n\t\t\t\tgz := gzip.NewWriter(&b)\n\t\t\t\t_, err := gz.Write(tCase.body)\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Fatal(err)\n\t\t\t\t}\n\t\t\t\tif err = gz.Flush(); err != nil {\n\t\t\t\t\tt.Fatal(err)\n\t\t\t\t}\n\t\t\t\tif err = gz.Close(); err != nil {\n\t\t\t\t\tt.Fatal(err)\n\t\t\t\t}\n\t\t\t\ttCase.body = b.Bytes()\n\t\t\t}\n\n\t\t\tc.Request().SetBody(tCase.body)\n\t\t\tbody := c.Body()\n\t\t\tutils.AssertEqual(t, tCase.expectedBody, body)\n\n\t\t\t// Check if body raw is the same as previous before decompression\n\t\t\tutils.AssertEqual(\n\t\t\t\tt, tCase.body, c.Request().Body(),\n\t\t\t\t\"Body raw must be the same as set before\",\n\t\t\t)\n\t\t})\n\t}\n}\n\n// go test -v -run=^$ -bench=Benchmark_Ctx_Body_With_Compression -benchmem -count=4\nfunc Benchmark_Ctx_Body_With_Compression(b *testing.B) {\n\tencodingErr := errors.New(\"failed to encoding data\")\n\n\tvar (\n\t\tcompressGzip = func(data []byte) ([]byte, error) {\n\t\t\tvar buf bytes.Buffer\n\t\t\twriter := gzip.NewWriter(&buf)\n\t\t\tif _, err := writer.Write(data); err != nil {\n\t\t\t\treturn nil, encodingErr\n\t\t\t}\n\t\t\tif err := writer.Flush(); err != nil {\n\t\t\t\treturn nil, encodingErr\n\t\t\t}\n\t\t\tif err := writer.Close(); err != nil {\n\t\t\t\treturn nil, encodingErr\n\t\t\t}\n\t\t\treturn buf.Bytes(), nil\n\t\t}\n\t\tcompressDeflate = func(data []byte) ([]byte, error) {\n\t\t\tvar buf bytes.Buffer\n\t\t\twriter := zlib.NewWriter(&buf)\n\t\t\tif _, err := writer.Write(data); err != nil {\n\t\t\t\treturn nil, encodingErr\n\t\t\t}\n\t\t\tif err := writer.Flush(); err != nil {\n\t\t\t\treturn nil, encodingErr\n\t\t\t}\n\t\t\tif err := writer.Close(); err != nil {\n\t\t\t\treturn nil, encodingErr\n\t\t\t}\n\t\t\treturn buf.Bytes(), nil\n\t\t}\n\t)\n\tcompressionTests := []struct {\n\t\tcontentEncoding string\n\t\tcompressWriter  func([]byte) ([]byte, error)\n\t}{\n\t\t{\n\t\t\tcontentEncoding: \"gzip\",\n\t\t\tcompressWriter:  compressGzip,\n\t\t},\n\t\t{\n\t\t\tcontentEncoding: \"gzip,invalid\",\n\t\t\tcompressWriter:  compressGzip,\n\t\t},\n\t\t{\n\t\t\tcontentEncoding: \"deflate\",\n\t\t\tcompressWriter:  compressDeflate,\n\t\t},\n\t\t{\n\t\t\tcontentEncoding: \"gzip,deflate\",\n\t\t\tcompressWriter: func(data []byte) ([]byte, error) {\n\t\t\t\tvar (\n\t\t\t\t\tbuf    bytes.Buffer\n\t\t\t\t\twriter interface {\n\t\t\t\t\t\tio.WriteCloser\n\t\t\t\t\t\tFlush() error\n\t\t\t\t\t}\n\t\t\t\t\terr error\n\t\t\t\t)\n\n\t\t\t\t// deflate\n\t\t\t\t{\n\t\t\t\t\twriter = zlib.NewWriter(&buf)\n\t\t\t\t\tif _, err = writer.Write(data); err != nil {\n\t\t\t\t\t\treturn nil, encodingErr\n\t\t\t\t\t}\n\t\t\t\t\tif err = writer.Flush(); err != nil {\n\t\t\t\t\t\treturn nil, encodingErr\n\t\t\t\t\t}\n\t\t\t\t\tif err = writer.Close(); err != nil {\n\t\t\t\t\t\treturn nil, encodingErr\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tdata = make([]byte, buf.Len())\n\t\t\t\tcopy(data, buf.Bytes())\n\t\t\t\tbuf.Reset()\n\n\t\t\t\t// gzip\n\t\t\t\t{\n\t\t\t\t\twriter = gzip.NewWriter(&buf)\n\t\t\t\t\tif _, err = writer.Write(data); err != nil {\n\t\t\t\t\t\treturn nil, encodingErr\n\t\t\t\t\t}\n\t\t\t\t\tif err = writer.Flush(); err != nil {\n\t\t\t\t\t\treturn nil, encodingErr\n\t\t\t\t\t}\n\t\t\t\t\tif err = writer.Close(); err != nil {\n\t\t\t\t\t\treturn nil, encodingErr\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn buf.Bytes(), nil\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, ct := range compressionTests {\n\t\tb.Run(ct.contentEncoding, func(b *testing.B) {\n\t\t\tapp := New()\n\t\t\tconst input = \"john=doe\"\n\t\t\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\t\t\tdefer app.ReleaseCtx(c)\n\n\t\t\tc.Request().Header.Set(\"Content-Encoding\", ct.contentEncoding)\n\t\t\tcompressedBody, err := ct.compressWriter([]byte(input))\n\t\t\tutils.AssertEqual(b, nil, err)\n\n\t\t\tc.Request().SetBody(compressedBody)\n\t\t\tfor i := 0; i < b.N; i++ {\n\t\t\t\t_ = c.Body()\n\t\t\t}\n\n\t\t\tutils.AssertEqual(b, []byte(input), c.Body())\n\t\t})\n\t}\n}\n\n// go test -run Test_Ctx_BodyParser\nfunc Test_Ctx_BodyParser(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\n\ttype Demo struct {\n\t\tName string `json:\"name\" xml:\"name\" form:\"name\" query:\"name\"`\n\t}\n\n\t{\n\t\tvar gzipJSON bytes.Buffer\n\t\tw := gzip.NewWriter(&gzipJSON)\n\t\t_, err := w.Write([]byte(`{\"name\":\"john\"}`))\n\t\tutils.AssertEqual(t, nil, err)\n\t\terr = w.Close()\n\t\tutils.AssertEqual(t, nil, err)\n\n\t\tc.Request().Header.SetContentType(MIMEApplicationJSON)\n\t\tc.Request().Header.Set(HeaderContentEncoding, \"gzip\")\n\t\tc.Request().SetBody(gzipJSON.Bytes())\n\t\tc.Request().Header.SetContentLength(len(gzipJSON.Bytes()))\n\t\td := new(Demo)\n\t\tutils.AssertEqual(t, nil, c.BodyParser(d))\n\t\tutils.AssertEqual(t, \"john\", d.Name)\n\t\tc.Request().Header.Del(HeaderContentEncoding)\n\t}\n\n\ttestDecodeParser := func(contentType, body string) {\n\t\tc.Request().Header.SetContentType(contentType)\n\t\tc.Request().SetBody([]byte(body))\n\t\tc.Request().Header.SetContentLength(len(body))\n\t\td := new(Demo)\n\t\tutils.AssertEqual(t, nil, c.BodyParser(d))\n\t\tutils.AssertEqual(t, \"john\", d.Name)\n\t}\n\n\ttestDecodeParser(MIMEApplicationJSON, `{\"name\":\"john\"}`)\n\ttestDecodeParser(MIMEApplicationXML, `<Demo><name>john</name></Demo>`)\n\ttestDecodeParser(MIMEApplicationForm, \"name=john\")\n\ttestDecodeParser(MIMEMultipartForm+`;boundary=\"b\"`, \"--b\\r\\nContent-Disposition: form-data; name=\\\"name\\\"\\r\\n\\r\\njohn\\r\\n--b--\")\n\n\ttestDecodeParserError := func(contentType, body string) {\n\t\tc.Request().Header.SetContentType(contentType)\n\t\tc.Request().SetBody([]byte(body))\n\t\tc.Request().Header.SetContentLength(len(body))\n\t\tutils.AssertEqual(t, false, c.BodyParser(nil) == nil)\n\t}\n\n\ttestDecodeParserError(\"invalid-content-type\", \"\")\n\ttestDecodeParserError(MIMEMultipartForm+`;boundary=\"b\"`, \"--b\")\n\n\ttype CollectionQuery struct {\n\t\tData []Demo `query:\"data\"`\n\t}\n\n\tc.Request().Reset()\n\tc.Request().Header.SetContentType(MIMEApplicationForm)\n\tc.Request().SetBody([]byte(\"data[0][name]=john&data[1][name]=doe\"))\n\tc.Request().Header.SetContentLength(len(c.Body()))\n\tcq := new(CollectionQuery)\n\tutils.AssertEqual(t, nil, c.BodyParser(cq))\n\tutils.AssertEqual(t, 2, len(cq.Data))\n\tutils.AssertEqual(t, \"john\", cq.Data[0].Name)\n\tutils.AssertEqual(t, \"doe\", cq.Data[1].Name)\n\n\tc.Request().Reset()\n\tc.Request().Header.SetContentType(MIMEApplicationForm)\n\tc.Request().SetBody([]byte(\"data.0.name=john&data.1.name=doe\"))\n\tc.Request().Header.SetContentLength(len(c.Body()))\n\tcq = new(CollectionQuery)\n\tutils.AssertEqual(t, nil, c.BodyParser(cq))\n\tutils.AssertEqual(t, 2, len(cq.Data))\n\tutils.AssertEqual(t, \"john\", cq.Data[0].Name)\n\tutils.AssertEqual(t, \"doe\", cq.Data[1].Name)\n}\n\nfunc Test_Ctx_ParamParser(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tapp.Get(\"/test1/:userId/role/:roleId\", func(ctx *Ctx) error {\n\t\ttype Demo struct {\n\t\t\tUserID uint `params:\"userId\"`\n\t\t\tRoleID uint `params:\"roleId\"`\n\t\t}\n\t\td := new(Demo)\n\t\tif err := ctx.ParamsParser(d); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tutils.AssertEqual(t, uint(111), d.UserID)\n\t\tutils.AssertEqual(t, uint(222), d.RoleID)\n\t\treturn nil\n\t})\n\t_, err := app.Test(httptest.NewRequest(MethodGet, \"/test1/111/role/222\", nil))\n\tutils.AssertEqual(t, nil, err)\n\n\t_, err = app.Test(httptest.NewRequest(MethodGet, \"/test2/111/role/222\", nil))\n\tutils.AssertEqual(t, nil, err)\n}\n\n// go test -run Test_Ctx_BodyParser_WithSetParserDecoder\nfunc Test_Ctx_BodyParser_WithSetParserDecoder(t *testing.T) {\n\tt.Parallel()\n\ttype CustomTime time.Time\n\n\ttimeConverter := func(value string) reflect.Value {\n\t\tif v, err := time.Parse(\"2006-01-02\", value); err == nil {\n\t\t\treturn reflect.ValueOf(v)\n\t\t}\n\t\treturn reflect.Value{}\n\t}\n\n\tcustomTime := ParserType{\n\t\tCustomtype: CustomTime{},\n\t\tConverter:  timeConverter,\n\t}\n\n\tSetParserDecoder(ParserConfig{\n\t\tIgnoreUnknownKeys: true,\n\t\tParserType:        []ParserType{customTime},\n\t\tZeroEmpty:         true,\n\t\tSetAliasTag:       \"form\",\n\t})\n\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\n\ttype Demo struct {\n\t\tDate  CustomTime `form:\"date\"`\n\t\tTitle string     `form:\"title\"`\n\t\tBody  string     `form:\"body\"`\n\t}\n\n\ttestDecodeParser := func(contentType, body string) {\n\t\tc.Request().Header.SetContentType(contentType)\n\t\tc.Request().SetBody([]byte(body))\n\t\tc.Request().Header.SetContentLength(len(body))\n\t\td := Demo{\n\t\t\tTitle: \"Existing title\",\n\t\t\tBody:  \"Existing Body\",\n\t\t}\n\t\tutils.AssertEqual(t, nil, c.BodyParser(&d))\n\t\tdate := fmt.Sprintf(\"%v\", d.Date)\n\t\tutils.AssertEqual(t, \"{0 63743587200 <nil>}\", date)\n\t\tutils.AssertEqual(t, \"\", d.Title)\n\t\tutils.AssertEqual(t, \"New Body\", d.Body)\n\t}\n\n\ttestDecodeParser(MIMEApplicationForm, \"date=2020-12-15&title=&body=New Body\")\n\ttestDecodeParser(MIMEMultipartForm+`; boundary=\"b\"`, \"--b\\r\\nContent-Disposition: form-data; name=\\\"date\\\"\\r\\n\\r\\n2020-12-15\\r\\n--b\\r\\nContent-Disposition: form-data; name=\\\"title\\\"\\r\\n\\r\\n\\r\\n--b\\r\\nContent-Disposition: form-data; name=\\\"body\\\"\\r\\n\\r\\nNew Body\\r\\n--b--\")\n}\n\n// go test -v -run=^$ -bench=Benchmark_Ctx_BodyParser_JSON -benchmem -count=4\nfunc Benchmark_Ctx_BodyParser_JSON(b *testing.B) {\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\ttype Demo struct {\n\t\tName string `json:\"name\"`\n\t}\n\tbody := []byte(`{\"name\":\"john\"}`)\n\tc.Request().SetBody(body)\n\tc.Request().Header.SetContentType(MIMEApplicationJSON)\n\tc.Request().Header.SetContentLength(len(body))\n\td := new(Demo)\n\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\n\tfor n := 0; n < b.N; n++ {\n\t\t_ = c.BodyParser(d) //nolint:errcheck // It is fine to ignore the error here as we check it once further below\n\t}\n\tutils.AssertEqual(b, nil, c.BodyParser(d))\n\tutils.AssertEqual(b, \"john\", d.Name)\n}\n\n// go test -v -run=^$ -bench=Benchmark_Ctx_BodyParser_XML -benchmem -count=4\nfunc Benchmark_Ctx_BodyParser_XML(b *testing.B) {\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\ttype Demo struct {\n\t\tName string `xml:\"name\"`\n\t}\n\tbody := []byte(\"<Demo><name>john</name></Demo>\")\n\tc.Request().SetBody(body)\n\tc.Request().Header.SetContentType(MIMEApplicationXML)\n\tc.Request().Header.SetContentLength(len(body))\n\td := new(Demo)\n\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\n\tfor n := 0; n < b.N; n++ {\n\t\t_ = c.BodyParser(d) //nolint:errcheck // It is fine to ignore the error here as we check it once further below\n\t}\n\tutils.AssertEqual(b, nil, c.BodyParser(d))\n\tutils.AssertEqual(b, \"john\", d.Name)\n}\n\n// go test -v -run=^$ -bench=Benchmark_Ctx_BodyParser_Form -benchmem -count=4\nfunc Benchmark_Ctx_BodyParser_Form(b *testing.B) {\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\ttype Demo struct {\n\t\tName string `form:\"name\"`\n\t}\n\tbody := []byte(\"name=john\")\n\tc.Request().SetBody(body)\n\tc.Request().Header.SetContentType(MIMEApplicationForm)\n\tc.Request().Header.SetContentLength(len(body))\n\td := new(Demo)\n\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\n\tfor n := 0; n < b.N; n++ {\n\t\t_ = c.BodyParser(d) //nolint:errcheck // It is fine to ignore the error here as we check it once further below\n\t}\n\tutils.AssertEqual(b, nil, c.BodyParser(d))\n\tutils.AssertEqual(b, \"john\", d.Name)\n}\n\n// go test -v -run=^$ -bench=Benchmark_Ctx_BodyParser_MultipartForm -benchmem -count=4\nfunc Benchmark_Ctx_BodyParser_MultipartForm(b *testing.B) {\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\ttype Demo struct {\n\t\tName string `form:\"name\"`\n\t}\n\n\tbody := []byte(\"--b\\r\\nContent-Disposition: form-data; name=\\\"name\\\"\\r\\n\\r\\njohn\\r\\n--b--\")\n\tc.Request().SetBody(body)\n\tc.Request().Header.SetContentType(MIMEMultipartForm + `;boundary=\"b\"`)\n\tc.Request().Header.SetContentLength(len(body))\n\td := new(Demo)\n\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\n\tfor n := 0; n < b.N; n++ {\n\t\t_ = c.BodyParser(d) //nolint:errcheck // It is fine to ignore the error here as we check it once further below\n\t}\n\tutils.AssertEqual(b, nil, c.BodyParser(d))\n\tutils.AssertEqual(b, \"john\", d.Name)\n}\n\n// go test -run Test_Ctx_Context\nfunc Test_Ctx_Context(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\n\tutils.AssertEqual(t, \"*fasthttp.RequestCtx\", fmt.Sprintf(\"%T\", c.Context()))\n}\n\n// go test -run Test_Ctx_UserContext\nfunc Test_Ctx_UserContext(t *testing.T) {\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\n\tt.Run(\"Nil_Context\", func(t *testing.T) {\n\t\tctx := c.UserContext()\n\t\tutils.AssertEqual(t, ctx, context.Background())\n\t})\n\tt.Run(\"ValueContext\", func(t *testing.T) {\n\t\ttestKey := struct{}{}\n\t\ttestValue := \"Test Value\"\n\t\tctx := context.WithValue(context.Background(), testKey, testValue)\n\t\tutils.AssertEqual(t, testValue, ctx.Value(testKey))\n\t})\n}\n\n// go test -run Test_Ctx_SetUserContext\nfunc Test_Ctx_SetUserContext(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\n\ttestKey := struct{}{}\n\ttestValue := \"Test Value\"\n\tctx := context.WithValue(context.Background(), testKey, testValue)\n\tc.SetUserContext(ctx)\n\tutils.AssertEqual(t, testValue, c.UserContext().Value(testKey))\n}\n\n// go test -run Test_Ctx_UserContext_Multiple_Requests\nfunc Test_Ctx_UserContext_Multiple_Requests(t *testing.T) {\n\tt.Parallel()\n\ttestKey := struct{}{}\n\ttestValue := \"foobar-value\"\n\n\tapp := New()\n\tapp.Get(\"/\", func(c *Ctx) error {\n\t\tctx := c.UserContext()\n\n\t\tif ctx.Value(testKey) != nil {\n\t\t\treturn c.SendStatus(StatusInternalServerError)\n\t\t}\n\n\t\tinput := utils.CopyString(c.Query(\"input\", \"NO_VALUE\"))\n\t\tctx = context.WithValue(ctx, testKey, fmt.Sprintf(\"%s_%s\", testValue, input))\n\t\tc.SetUserContext(ctx)\n\n\t\treturn c.Status(StatusOK).SendString(fmt.Sprintf(\"resp_%s_returned\", input))\n\t})\n\n\t// Consecutive Requests\n\tfor i := 1; i <= 10; i++ {\n\t\tt.Run(fmt.Sprintf(\"request_%d\", i), func(t *testing.T) {\n\t\t\tresp, err := app.Test(httptest.NewRequest(MethodGet, fmt.Sprintf(\"/?input=%d\", i), nil))\n\n\t\t\tutils.AssertEqual(t, nil, err, \"Unexpected error from response\")\n\t\t\tutils.AssertEqual(t, StatusOK, resp.StatusCode, \"context.Context returned from c.UserContext() is reused\")\n\n\t\t\tb, err := io.ReadAll(resp.Body)\n\t\t\tutils.AssertEqual(t, nil, err, \"Unexpected error from reading response body\")\n\t\t\tutils.AssertEqual(t, fmt.Sprintf(\"resp_%d_returned\", i), string(b), \"response text incorrect\")\n\t\t})\n\t}\n}\n\n// go test -run Test_Ctx_Cookie\nfunc Test_Ctx_Cookie(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\texpire := time.Now().Add(24 * time.Hour)\n\tvar dst []byte\n\tdst = expire.In(time.UTC).AppendFormat(dst, time.RFC1123)\n\thttpdate := strings.ReplaceAll(string(dst), \"UTC\", \"GMT\")\n\tcookie := &Cookie{\n\t\tName:    \"username\",\n\t\tValue:   \"john\",\n\t\tExpires: expire,\n\t\t// SameSite: CookieSameSiteStrictMode, // default is \"lax\"\n\t}\n\tc.Cookie(cookie)\n\texpect := \"username=john; expires=\" + httpdate + \"; path=/; SameSite=Lax\"\n\tutils.AssertEqual(t, expect, string(c.Response().Header.Peek(HeaderSetCookie)))\n\n\texpect = \"username=john; expires=\" + httpdate + \"; path=/\"\n\tcookie.SameSite = CookieSameSiteDisabled\n\tc.Cookie(cookie)\n\tutils.AssertEqual(t, expect, string(c.Response().Header.Peek(HeaderSetCookie)))\n\n\texpect = \"username=john; expires=\" + httpdate + \"; path=/; SameSite=Strict\"\n\tcookie.SameSite = CookieSameSiteStrictMode\n\tc.Cookie(cookie)\n\tutils.AssertEqual(t, expect, string(c.Response().Header.Peek(HeaderSetCookie)))\n\n\texpect = \"username=john; expires=\" + httpdate + \"; path=/; secure; SameSite=None\"\n\tcookie.Secure = true\n\tcookie.SameSite = CookieSameSiteNoneMode\n\tc.Cookie(cookie)\n\tutils.AssertEqual(t, expect, string(c.Response().Header.Peek(HeaderSetCookie)))\n\n\texpect = \"username=john; path=/; secure; SameSite=None\"\n\t// should remove expires and max-age headers\n\tcookie.SessionOnly = true\n\tcookie.Expires = expire\n\tcookie.MaxAge = 10000\n\tc.Cookie(cookie)\n\tutils.AssertEqual(t, expect, string(c.Response().Header.Peek(HeaderSetCookie)))\n\n\texpect = \"username=john; path=/; secure; SameSite=None\"\n\t// should remove expires and max-age headers when no expire and no MaxAge (default time)\n\tcookie.SessionOnly = false\n\tcookie.Expires = time.Time{}\n\tcookie.MaxAge = 0\n\tc.Cookie(cookie)\n\tutils.AssertEqual(t, expect, string(c.Response().Header.Peek(HeaderSetCookie)))\n}\n\n// go test -v -run=^$ -bench=Benchmark_Ctx_Cookie -benchmem -count=4\nfunc Benchmark_Ctx_Cookie(b *testing.B) {\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\tc.Cookie(&Cookie{\n\t\t\tName:  \"John\",\n\t\t\tValue: \"Doe\",\n\t\t})\n\t}\n\tutils.AssertEqual(b, \"John=Doe; path=/; SameSite=Lax\", app.getString(c.Response().Header.Peek(\"Set-Cookie\")))\n}\n\n// go test -run Test_Ctx_Cookies\nfunc Test_Ctx_Cookies(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tc.Request().Header.Set(\"Cookie\", \"john=doe\")\n\tutils.AssertEqual(t, \"doe\", c.Cookies(\"john\"))\n\tutils.AssertEqual(t, \"default\", c.Cookies(\"unknown\", \"default\"))\n}\n\n// go test -run Test_Ctx_Format\nfunc Test_Ctx_Format(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tc.Request().Header.Set(HeaderAccept, MIMETextPlain)\n\terr := c.Format([]byte(\"Hello, World!\"))\n\tutils.AssertEqual(t, nil, err)\n\tutils.AssertEqual(t, \"Hello, World!\", string(c.Response().Body()))\n\n\tc.Request().Header.Set(HeaderAccept, MIMETextHTML)\n\terr = c.Format(\"Hello, World!\")\n\tutils.AssertEqual(t, nil, err)\n\tutils.AssertEqual(t, \"<p>Hello, World!</p>\", string(c.Response().Body()))\n\n\tc.Request().Header.Set(HeaderAccept, MIMEApplicationJSON)\n\terr = c.Format(\"Hello, World!\")\n\tutils.AssertEqual(t, nil, err)\n\tutils.AssertEqual(t, `\"Hello, World!\"`, string(c.Response().Body()))\n\n\tc.Request().Header.Set(HeaderAccept, MIMETextPlain)\n\terr = c.Format(complex(1, 1))\n\tutils.AssertEqual(t, nil, err)\n\tutils.AssertEqual(t, \"(1+1i)\", string(c.Response().Body()))\n\n\tc.Request().Header.Set(HeaderAccept, MIMEApplicationXML)\n\terr = c.Format(\"Hello, World!\")\n\tutils.AssertEqual(t, nil, err)\n\tutils.AssertEqual(t, `<string>Hello, World!</string>`, string(c.Response().Body()))\n\n\terr = c.Format(complex(1, 1))\n\tutils.AssertEqual(t, true, err != nil)\n\n\tc.Request().Header.Set(HeaderAccept, MIMETextPlain)\n\terr = c.Format(Map{})\n\tutils.AssertEqual(t, nil, err)\n\tutils.AssertEqual(t, \"map[]\", string(c.Response().Body()))\n\n\ttype broken string\n\tc.Request().Header.Set(HeaderAccept, \"broken/accept\")\n\terr = c.Format(broken(\"Hello, World!\"))\n\tutils.AssertEqual(t, nil, err)\n\tutils.AssertEqual(t, `Hello, World!`, string(c.Response().Body()))\n}\n\n// go test -v -run=^$ -bench=Benchmark_Ctx_Format -benchmem -count=4\nfunc Benchmark_Ctx_Format(b *testing.B) {\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tc.Request().Header.Set(\"Accept\", \"text/plain\")\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\n\tvar err error\n\tfor n := 0; n < b.N; n++ {\n\t\terr = c.Format(\"Hello, World!\")\n\t}\n\n\tutils.AssertEqual(b, nil, err)\n\tutils.AssertEqual(b, `Hello, World!`, string(c.Response().Body()))\n}\n\n// go test -v -run=^$ -bench=Benchmark_Ctx_Format_HTML -benchmem -count=4\nfunc Benchmark_Ctx_Format_HTML(b *testing.B) {\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tc.Request().Header.Set(\"Accept\", \"text/html\")\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\n\tvar err error\n\tfor n := 0; n < b.N; n++ {\n\t\terr = c.Format(\"Hello, World!\")\n\t}\n\n\tutils.AssertEqual(b, nil, err)\n\tutils.AssertEqual(b, \"<p>Hello, World!</p>\", string(c.Response().Body()))\n}\n\n// go test -v -run=^$ -bench=Benchmark_Ctx_Format_JSON -benchmem -count=4\nfunc Benchmark_Ctx_Format_JSON(b *testing.B) {\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tc.Request().Header.Set(\"Accept\", \"application/json\")\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\n\tvar err error\n\tfor n := 0; n < b.N; n++ {\n\t\terr = c.Format(\"Hello, World!\")\n\t}\n\n\tutils.AssertEqual(b, nil, err)\n\tutils.AssertEqual(b, `\"Hello, World!\"`, string(c.Response().Body()))\n}\n\n// go test -v -run=^$ -bench=Benchmark_Ctx_Format_XML -benchmem -count=4\nfunc Benchmark_Ctx_Format_XML(b *testing.B) {\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tc.Request().Header.Set(\"Accept\", \"application/xml\")\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\n\tvar err error\n\tfor n := 0; n < b.N; n++ {\n\t\terr = c.Format(\"Hello, World!\")\n\t}\n\n\tutils.AssertEqual(b, nil, err)\n\tutils.AssertEqual(b, `<string>Hello, World!</string>`, string(c.Response().Body()))\n}\n\n// go test -run Test_Ctx_FormFile\nfunc Test_Ctx_FormFile(t *testing.T) {\n\t// TODO: We should clean this up\n\tt.Parallel()\n\tapp := New()\n\n\tapp.Post(\"/test\", func(c *Ctx) error {\n\t\tfh, err := c.FormFile(\"file\")\n\t\tutils.AssertEqual(t, nil, err)\n\t\tutils.AssertEqual(t, \"test\", fh.Filename)\n\n\t\tf, err := fh.Open()\n\t\tutils.AssertEqual(t, nil, err)\n\t\tdefer func() {\n\t\t\tutils.AssertEqual(t, nil, f.Close())\n\t\t}()\n\n\t\tb := new(bytes.Buffer)\n\t\t_, err = io.Copy(b, f)\n\t\tutils.AssertEqual(t, nil, err)\n\t\tutils.AssertEqual(t, \"hello world\", b.String())\n\t\treturn nil\n\t})\n\n\tbody := &bytes.Buffer{}\n\twriter := multipart.NewWriter(body)\n\n\tioWriter, err := writer.CreateFormFile(\"file\", \"test\")\n\tutils.AssertEqual(t, nil, err)\n\n\t_, err = ioWriter.Write([]byte(\"hello world\"))\n\tutils.AssertEqual(t, nil, err)\n\tutils.AssertEqual(t, nil, writer.Close())\n\n\treq := httptest.NewRequest(MethodPost, \"/test\", body)\n\treq.Header.Set(HeaderContentType, writer.FormDataContentType())\n\treq.Header.Set(HeaderContentLength, strconv.Itoa(len(body.Bytes())))\n\n\tresp, err := app.Test(req)\n\tutils.AssertEqual(t, nil, err, \"app.Test(req)\")\n\tutils.AssertEqual(t, StatusOK, resp.StatusCode, \"Status code\")\n}\n\n// go test -run Test_Ctx_FormValue\nfunc Test_Ctx_FormValue(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\n\tapp.Post(\"/test\", func(c *Ctx) error {\n\t\tutils.AssertEqual(t, \"john\", c.FormValue(\"name\"))\n\t\treturn nil\n\t})\n\n\tbody := &bytes.Buffer{}\n\twriter := multipart.NewWriter(body)\n\tutils.AssertEqual(t, nil, writer.WriteField(\"name\", \"john\"))\n\tutils.AssertEqual(t, nil, writer.Close())\n\n\treq := httptest.NewRequest(MethodPost, \"/test\", body)\n\treq.Header.Set(\"Content-Type\", fmt.Sprintf(\"multipart/form-data; boundary=%s\", writer.Boundary()))\n\treq.Header.Set(\"Content-Length\", strconv.Itoa(len(body.Bytes())))\n\n\tresp, err := app.Test(req)\n\tutils.AssertEqual(t, nil, err, \"app.Test(req)\")\n\tutils.AssertEqual(t, StatusOK, resp.StatusCode, \"Status code\")\n}\n\n// go test -v -run=^$ -bench=Benchmark_Ctx_Fresh_StaleEtag -benchmem -count=4\nfunc Benchmark_Ctx_Fresh_StaleEtag(b *testing.B) {\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\n\tfor n := 0; n < b.N; n++ {\n\t\tc.Request().Header.Set(HeaderIfNoneMatch, \"a, b, c, d\")\n\t\tc.Request().Header.Set(HeaderCacheControl, \"c\")\n\t\tc.Fresh()\n\n\t\tc.Request().Header.Set(HeaderIfNoneMatch, \"a, b, c, d\")\n\t\tc.Request().Header.Set(HeaderCacheControl, \"e\")\n\t\tc.Fresh()\n\t}\n}\n\n// go test -run Test_Ctx_Fresh\nfunc Test_Ctx_Fresh(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tutils.AssertEqual(t, false, c.Fresh())\n\n\tc.Request().Header.Set(HeaderIfNoneMatch, \"*\")\n\tc.Request().Header.Set(HeaderCacheControl, \"no-cache\")\n\tutils.AssertEqual(t, false, c.Fresh())\n\n\tc.Request().Header.Set(HeaderIfNoneMatch, \"*\")\n\tc.Request().Header.Set(HeaderCacheControl, \",no-cache,\")\n\tutils.AssertEqual(t, false, c.Fresh())\n\n\tc.Request().Header.Set(HeaderIfNoneMatch, \"*\")\n\tc.Request().Header.Set(HeaderCacheControl, \"aa,no-cache,\")\n\tutils.AssertEqual(t, false, c.Fresh())\n\n\tc.Request().Header.Set(HeaderIfNoneMatch, \"*\")\n\tc.Request().Header.Set(HeaderCacheControl, \",no-cache,bb\")\n\tutils.AssertEqual(t, false, c.Fresh())\n\n\tc.Request().Header.Set(HeaderIfNoneMatch, \"675af34563dc-tr34\")\n\tc.Request().Header.Set(HeaderCacheControl, \"public\")\n\tutils.AssertEqual(t, false, c.Fresh())\n\n\tc.Request().Header.Set(HeaderIfNoneMatch, \"a, b\")\n\tc.Response().Header.Set(HeaderETag, \"c\")\n\tutils.AssertEqual(t, false, c.Fresh())\n\n\tc.Response().Header.Set(HeaderETag, \"a\")\n\tutils.AssertEqual(t, true, c.Fresh())\n\n\tc.Request().Header.Set(HeaderIfModifiedSince, \"xxWed, 21 Oct 2015 07:28:00 GMT\")\n\tc.Response().Header.Set(HeaderLastModified, \"xxWed, 21 Oct 2015 07:28:00 GMT\")\n\tutils.AssertEqual(t, false, c.Fresh())\n\n\tc.Response().Header.Set(HeaderLastModified, \"Wed, 21 Oct 2015 07:28:00 GMT\")\n\tutils.AssertEqual(t, false, c.Fresh())\n\n\tc.Request().Header.Set(HeaderIfModifiedSince, \"Wed, 21 Oct 2015 07:28:00 GMT\")\n\tutils.AssertEqual(t, false, c.Fresh())\n}\n\n// go test -v -run=^$ -bench=Benchmark_Ctx_Fresh_WithNoCache -benchmem -count=4\nfunc Benchmark_Ctx_Fresh_WithNoCache(b *testing.B) {\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\n\tc.Request().Header.Set(HeaderIfNoneMatch, \"*\")\n\tc.Request().Header.Set(HeaderCacheControl, \"no-cache\")\n\tfor n := 0; n < b.N; n++ {\n\t\tc.Fresh()\n\t}\n}\n\n// go test -run Test_Ctx_Get\nfunc Test_Ctx_Get(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tc.Request().Header.Set(HeaderAcceptCharset, \"utf-8, iso-8859-1;q=0.5\")\n\tc.Request().Header.Set(HeaderReferer, \"Monster\")\n\tutils.AssertEqual(t, \"utf-8, iso-8859-1;q=0.5\", c.Get(HeaderAcceptCharset))\n\tutils.AssertEqual(t, \"Monster\", c.Get(HeaderReferer))\n\tutils.AssertEqual(t, \"default\", c.Get(\"unknown\", \"default\"))\n}\n\n// go test -run Test_Ctx_IsProxyTrusted\nfunc Test_Ctx_IsProxyTrusted(t *testing.T) {\n\tt.Parallel()\n\n\t{\n\t\tapp := New()\n\t\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\t\tdefer app.ReleaseCtx(c)\n\t\tutils.AssertEqual(t, true, c.IsProxyTrusted())\n\t}\n\t{\n\t\tapp := New(Config{\n\t\t\tEnableTrustedProxyCheck: false,\n\t\t})\n\t\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\t\tdefer app.ReleaseCtx(c)\n\t\tutils.AssertEqual(t, true, c.IsProxyTrusted())\n\t}\n\n\t{\n\t\tapp := New(Config{\n\t\t\tEnableTrustedProxyCheck: true,\n\t\t})\n\t\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\t\tdefer app.ReleaseCtx(c)\n\t\tutils.AssertEqual(t, false, c.IsProxyTrusted())\n\t}\n\t{\n\t\tapp := New(Config{\n\t\t\tEnableTrustedProxyCheck: true,\n\n\t\t\tTrustedProxies: []string{},\n\t\t})\n\t\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\t\tdefer app.ReleaseCtx(c)\n\t\tutils.AssertEqual(t, false, c.IsProxyTrusted())\n\t}\n\t{\n\t\tapp := New(Config{\n\t\t\tEnableTrustedProxyCheck: true,\n\n\t\t\tTrustedProxies: []string{\n\t\t\t\t\"127.0.0.1\",\n\t\t\t},\n\t\t})\n\t\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\t\tdefer app.ReleaseCtx(c)\n\t\tutils.AssertEqual(t, false, c.IsProxyTrusted())\n\t}\n\t{\n\t\tapp := New(Config{\n\t\t\tEnableTrustedProxyCheck: true,\n\n\t\t\tTrustedProxies: []string{\n\t\t\t\t\"127.0.0.1/8\",\n\t\t\t},\n\t\t})\n\t\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\t\tdefer app.ReleaseCtx(c)\n\t\tutils.AssertEqual(t, false, c.IsProxyTrusted())\n\t}\n\t{\n\t\tapp := New(Config{\n\t\t\tEnableTrustedProxyCheck: true,\n\n\t\t\tTrustedProxies: []string{\n\t\t\t\t\"0.0.0.0\",\n\t\t\t},\n\t\t})\n\t\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\t\tdefer app.ReleaseCtx(c)\n\t\tutils.AssertEqual(t, true, c.IsProxyTrusted())\n\t}\n\t{\n\t\tapp := New(Config{\n\t\t\tEnableTrustedProxyCheck: true,\n\n\t\t\tTrustedProxies: []string{\n\t\t\t\t\"0.0.0.1/31\",\n\t\t\t},\n\t\t})\n\t\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\t\tdefer app.ReleaseCtx(c)\n\t\tutils.AssertEqual(t, true, c.IsProxyTrusted())\n\t}\n\t{\n\t\tapp := New(Config{\n\t\t\tEnableTrustedProxyCheck: true,\n\n\t\t\tTrustedProxies: []string{\n\t\t\t\t\"0.0.0.1/31junk\",\n\t\t\t},\n\t\t})\n\t\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\t\tdefer app.ReleaseCtx(c)\n\t\tutils.AssertEqual(t, false, c.IsProxyTrusted())\n\t}\n}\n\n// go test -run Test_Ctx_Hostname\nfunc Test_Ctx_Hostname(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tc.Request().SetRequestURI(\"http://google.com/test\")\n\tutils.AssertEqual(t, \"google.com\", c.Hostname())\n}\n\n// go test -run Test_Ctx_Hostname_Untrusted\nfunc Test_Ctx_Hostname_UntrustedProxy(t *testing.T) {\n\tt.Parallel()\n\t// Don't trust any proxy\n\t{\n\t\tapp := New(Config{EnableTrustedProxyCheck: true, TrustedProxies: []string{}})\n\t\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\t\tc.Request().SetRequestURI(\"http://google.com/test\")\n\t\tc.Request().Header.Set(HeaderXForwardedHost, \"google1.com\")\n\t\tutils.AssertEqual(t, \"google.com\", c.Hostname())\n\t\tapp.ReleaseCtx(c)\n\t}\n\t// Trust to specific proxy list\n\t{\n\t\tapp := New(Config{EnableTrustedProxyCheck: true, TrustedProxies: []string{\"0.8.0.0\", \"0.8.0.1\"}})\n\t\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\t\tc.Request().SetRequestURI(\"http://google.com/test\")\n\t\tc.Request().Header.Set(HeaderXForwardedHost, \"google1.com\")\n\t\tutils.AssertEqual(t, \"google.com\", c.Hostname())\n\t\tapp.ReleaseCtx(c)\n\t}\n}\n\n// go test -run Test_Ctx_Hostname_Trusted\nfunc Test_Ctx_Hostname_TrustedProxy(t *testing.T) {\n\tt.Parallel()\n\t{\n\t\tapp := New(Config{EnableTrustedProxyCheck: true, TrustedProxies: []string{\"0.0.0.0\", \"0.8.0.1\"}})\n\t\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\t\tc.Request().SetRequestURI(\"http://google.com/test\")\n\t\tc.Request().Header.Set(HeaderXForwardedHost, \"google1.com\")\n\t\tutils.AssertEqual(t, \"google1.com\", c.Hostname())\n\t\tapp.ReleaseCtx(c)\n\t}\n}\n\n// go test -run Test_Ctx_Hostname_Trusted_Multiple\nfunc Test_Ctx_Hostname_TrustedProxy_Multiple(t *testing.T) {\n\tt.Parallel()\n\t{\n\t\tapp := New(Config{EnableTrustedProxyCheck: true, TrustedProxies: []string{\"0.0.0.0\", \"0.8.0.1\"}})\n\t\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\t\tc.Request().SetRequestURI(\"http://google.com/test\")\n\t\tc.Request().Header.Set(HeaderXForwardedHost, \"google1.com, google2.com\")\n\t\tutils.AssertEqual(t, \"google1.com\", c.Hostname())\n\t\tapp.ReleaseCtx(c)\n\t}\n}\n\n// go test -run Test_Ctx_Hostname_UntrustedProxyRange\nfunc Test_Ctx_Hostname_TrustedProxyRange(t *testing.T) {\n\tt.Parallel()\n\n\tapp := New(Config{EnableTrustedProxyCheck: true, TrustedProxies: []string{\"0.0.0.0/30\"}})\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tc.Request().SetRequestURI(\"http://google.com/test\")\n\tc.Request().Header.Set(HeaderXForwardedHost, \"google1.com\")\n\tutils.AssertEqual(t, \"google1.com\", c.Hostname())\n\tapp.ReleaseCtx(c)\n}\n\n// go test -run Test_Ctx_Hostname_UntrustedProxyRange\nfunc Test_Ctx_Hostname_UntrustedProxyRange(t *testing.T) {\n\tt.Parallel()\n\n\tapp := New(Config{EnableTrustedProxyCheck: true, TrustedProxies: []string{\"1.0.0.0/30\"}})\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tc.Request().SetRequestURI(\"http://google.com/test\")\n\tc.Request().Header.Set(HeaderXForwardedHost, \"google1.com\")\n\tutils.AssertEqual(t, \"google.com\", c.Hostname())\n\tapp.ReleaseCtx(c)\n}\n\n// go test -run Test_Ctx_Port\nfunc Test_Ctx_Port(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tutils.AssertEqual(t, \"0\", c.Port())\n}\n\n// go test -run Test_Ctx_PortInHandler\nfunc Test_Ctx_PortInHandler(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\n\tapp.Get(\"/port\", func(c *Ctx) error {\n\t\treturn c.SendString(c.Port())\n\t})\n\n\tresp, err := app.Test(httptest.NewRequest(MethodGet, \"/port\", nil))\n\tutils.AssertEqual(t, nil, err, \"app.Test(req)\")\n\tutils.AssertEqual(t, StatusOK, resp.StatusCode, \"Status code\")\n\n\tbody, err := io.ReadAll(resp.Body)\n\tutils.AssertEqual(t, nil, err)\n\tutils.AssertEqual(t, \"0\", string(body))\n}\n\n// go test -run Test_Ctx_IP\nfunc Test_Ctx_IP(t *testing.T) {\n\tt.Parallel()\n\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\n\t// default behavior will return the remote IP from the stack\n\tutils.AssertEqual(t, \"0.0.0.0\", c.IP())\n\n\t// X-Forwarded-For is set, but it is ignored because proxyHeader is not set\n\tc.Request().Header.Set(HeaderXForwardedFor, \"0.0.0.1\")\n\tutils.AssertEqual(t, \"0.0.0.0\", c.IP())\n}\n\n// go test -run Test_Ctx_IP_ProxyHeader\nfunc Test_Ctx_IP_ProxyHeader(t *testing.T) {\n\tt.Parallel()\n\n\t// make sure that the same behavior exists for different proxy header names\n\tproxyHeaderNames := []string{\"Real-Ip\", HeaderXForwardedFor}\n\n\tfor _, proxyHeaderName := range proxyHeaderNames {\n\t\tapp := New(Config{ProxyHeader: proxyHeaderName})\n\t\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\t\tc.Request().Header.Set(proxyHeaderName, \"0.0.0.1\")\n\t\tutils.AssertEqual(t, \"0.0.0.1\", c.IP())\n\n\t\t// without IP validation we return the full string\n\t\tc.Request().Header.Set(proxyHeaderName, \"0.0.0.1, 0.0.0.2\")\n\t\tutils.AssertEqual(t, \"0.0.0.1, 0.0.0.2\", c.IP())\n\n\t\t// without IP validation we return invalid IPs\n\t\tc.Request().Header.Set(proxyHeaderName, \"invalid, 0.0.0.2, 0.0.0.3\")\n\t\tutils.AssertEqual(t, \"invalid, 0.0.0.2, 0.0.0.3\", c.IP())\n\n\t\t// when proxy header is enabled but the value is empty, without IP validation we return an empty string\n\t\tc.Request().Header.Set(proxyHeaderName, \"\")\n\t\tutils.AssertEqual(t, \"\", c.IP())\n\n\t\t// without IP validation we return an invalid IP\n\t\tc.Request().Header.Set(proxyHeaderName, \"not-valid-ip\")\n\t\tutils.AssertEqual(t, \"not-valid-ip\", c.IP())\n\n\t\tapp.ReleaseCtx(c)\n\t}\n}\n\n// go test -run Test_Ctx_IP_ProxyHeader\nfunc Test_Ctx_IP_ProxyHeader_With_IP_Validation(t *testing.T) {\n\tt.Parallel()\n\n\t// make sure that the same behavior exists for different proxy header names\n\tproxyHeaderNames := []string{\"Real-Ip\", HeaderXForwardedFor}\n\n\tfor _, proxyHeaderName := range proxyHeaderNames {\n\t\tapp := New(Config{EnableIPValidation: true, ProxyHeader: proxyHeaderName})\n\t\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\t\t// when proxy header & validation is enabled and the value is a valid IP, we return it\n\t\tc.Request().Header.Set(proxyHeaderName, \"0.0.0.1\")\n\t\tutils.AssertEqual(t, \"0.0.0.1\", c.IP())\n\n\t\t// when proxy header & validation is enabled and the value is a list of IPs, we return the first valid IP\n\t\tc.Request().Header.Set(proxyHeaderName, \"0.0.0.1, 0.0.0.2\")\n\t\tutils.AssertEqual(t, \"0.0.0.1\", c.IP())\n\n\t\tc.Request().Header.Set(proxyHeaderName, \"invalid, 0.0.0.2, 0.0.0.3\")\n\t\tutils.AssertEqual(t, \"0.0.0.2\", c.IP())\n\n\t\t// when proxy header & validation is enabled but the value is empty, we will ignore the header\n\t\tc.Request().Header.Set(proxyHeaderName, \"\")\n\t\tutils.AssertEqual(t, \"0.0.0.0\", c.IP())\n\n\t\t// when proxy header & validation is enabled but the value is not an IP, we will ignore the header\n\t\t// and return the IP of the caller\n\t\tc.Request().Header.Set(proxyHeaderName, \"not-valid-ip\")\n\t\tutils.AssertEqual(t, \"0.0.0.0\", c.IP())\n\n\t\tapp.ReleaseCtx(c)\n\t}\n}\n\n// go test -run Test_Ctx_IP_UntrustedProxy\nfunc Test_Ctx_IP_UntrustedProxy(t *testing.T) {\n\tt.Parallel()\n\tapp := New(Config{EnableTrustedProxyCheck: true, TrustedProxies: []string{\"0.8.0.1\"}, ProxyHeader: HeaderXForwardedFor})\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tc.Request().Header.Set(HeaderXForwardedFor, \"0.0.0.1\")\n\tdefer app.ReleaseCtx(c)\n\tutils.AssertEqual(t, \"0.0.0.0\", c.IP())\n}\n\n// go test -run Test_Ctx_IP_TrustedProxy\nfunc Test_Ctx_IP_TrustedProxy(t *testing.T) {\n\tt.Parallel()\n\tapp := New(Config{EnableTrustedProxyCheck: true, TrustedProxies: []string{\"0.0.0.0\"}, ProxyHeader: HeaderXForwardedFor})\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tc.Request().Header.Set(HeaderXForwardedFor, \"0.0.0.1\")\n\tdefer app.ReleaseCtx(c)\n\tutils.AssertEqual(t, \"0.0.0.1\", c.IP())\n}\n\n// go test -run Test_Ctx_IPs  -parallel\nfunc Test_Ctx_IPs(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\n\t// normal happy path test case\n\tc.Request().Header.Set(HeaderXForwardedFor, \"127.0.0.1, 127.0.0.2, 127.0.0.3\")\n\tutils.AssertEqual(t, []string{\"127.0.0.1\", \"127.0.0.2\", \"127.0.0.3\"}, c.IPs())\n\n\t// inconsistent space formatting\n\tc.Request().Header.Set(HeaderXForwardedFor, \"127.0.0.1,127.0.0.2  ,127.0.0.3\")\n\tutils.AssertEqual(t, []string{\"127.0.0.1\", \"127.0.0.2\", \"127.0.0.3\"}, c.IPs())\n\n\t// invalid IPs are allowed to be returned\n\tc.Request().Header.Set(HeaderXForwardedFor, \"invalid, 127.0.0.1, 127.0.0.2\")\n\tutils.AssertEqual(t, []string{\"invalid\", \"127.0.0.1\", \"127.0.0.2\"}, c.IPs())\n\tc.Request().Header.Set(HeaderXForwardedFor, \"127.0.0.1, invalid, 127.0.0.2\")\n\tutils.AssertEqual(t, []string{\"127.0.0.1\", \"invalid\", \"127.0.0.2\"}, c.IPs())\n\n\t// ensure that the ordering of IPs in the header is maintained\n\tc.Request().Header.Set(HeaderXForwardedFor, \"127.0.0.3, 127.0.0.1, 127.0.0.2\")\n\tutils.AssertEqual(t, []string{\"127.0.0.3\", \"127.0.0.1\", \"127.0.0.2\"}, c.IPs())\n\n\t// ensure for IPv6\n\tc.Request().Header.Set(HeaderXForwardedFor, \"9396:9549:b4f7:8ed0:4791:1330:8c06:e62d, invalid, 2345:0425:2CA1::0567:5673:23b5\")\n\tutils.AssertEqual(t, []string{\"9396:9549:b4f7:8ed0:4791:1330:8c06:e62d\", \"invalid\", \"2345:0425:2CA1::0567:5673:23b5\"}, c.IPs())\n\n\t// empty header\n\tc.Request().Header.Set(HeaderXForwardedFor, \"\")\n\tutils.AssertEqual(t, 0, len(c.IPs()))\n\n\t// missing header\n\tc.Request()\n\tutils.AssertEqual(t, 0, len(c.IPs()))\n}\n\nfunc Test_Ctx_IPs_With_IP_Validation(t *testing.T) {\n\tt.Parallel()\n\tapp := New(Config{EnableIPValidation: true})\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\n\t// normal happy path test case\n\tc.Request().Header.Set(HeaderXForwardedFor, \"127.0.0.1, 127.0.0.2, 127.0.0.3\")\n\tutils.AssertEqual(t, []string{\"127.0.0.1\", \"127.0.0.2\", \"127.0.0.3\"}, c.IPs())\n\n\t// inconsistent space formatting\n\tc.Request().Header.Set(HeaderXForwardedFor, \"127.0.0.1,127.0.0.2  ,127.0.0.3\")\n\tutils.AssertEqual(t, []string{\"127.0.0.1\", \"127.0.0.2\", \"127.0.0.3\"}, c.IPs())\n\n\t// invalid IPs are in the header\n\tc.Request().Header.Set(HeaderXForwardedFor, \"invalid, 127.0.0.1, 127.0.0.2\")\n\tutils.AssertEqual(t, []string{\"127.0.0.1\", \"127.0.0.2\"}, c.IPs())\n\tc.Request().Header.Set(HeaderXForwardedFor, \"127.0.0.1, invalid, 127.0.0.2\")\n\tutils.AssertEqual(t, []string{\"127.0.0.1\", \"127.0.0.2\"}, c.IPs())\n\n\t// ensure that the ordering of IPs in the header is maintained\n\tc.Request().Header.Set(HeaderXForwardedFor, \"127.0.0.3, 127.0.0.1, 127.0.0.2\")\n\tutils.AssertEqual(t, []string{\"127.0.0.3\", \"127.0.0.1\", \"127.0.0.2\"}, c.IPs())\n\n\t// ensure for IPv6\n\tc.Request().Header.Set(HeaderXForwardedFor, \"f037:825e:eadb:1b7b:1667:6f0a:5356:f604, invalid, 9396:9549:b4f7:8ed0:4791:1330:8c06:e62d\")\n\tutils.AssertEqual(t, []string{\"f037:825e:eadb:1b7b:1667:6f0a:5356:f604\", \"9396:9549:b4f7:8ed0:4791:1330:8c06:e62d\"}, c.IPs())\n\n\t// empty header\n\tc.Request().Header.Set(HeaderXForwardedFor, \"\")\n\tutils.AssertEqual(t, 0, len(c.IPs()))\n\n\t// missing header\n\tc.Request()\n\tutils.AssertEqual(t, 0, len(c.IPs()))\n}\n\n// go test -v -run=^$ -bench=Benchmark_Ctx_IPs -benchmem -count=4\nfunc Benchmark_Ctx_IPs(b *testing.B) {\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tc.Request().Header.Set(HeaderXForwardedFor, \"127.0.0.1, invalid, 127.0.0.1\")\n\tvar res []string\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\tres = c.IPs()\n\t}\n\tutils.AssertEqual(b, []string{\"127.0.0.1\", \"invalid\", \"127.0.0.1\"}, res)\n}\n\nfunc Benchmark_Ctx_IPs_v6(b *testing.B) {\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tc.Request().Header.Set(HeaderXForwardedFor, \"f037:825e:eadb:1b7b:1667:6f0a:5356:f604, invalid, 2345:0425:2CA1::0567:5673:23b5\")\n\tvar res []string\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\tres = c.IPs()\n\t}\n\tutils.AssertEqual(b, []string{\"f037:825e:eadb:1b7b:1667:6f0a:5356:f604\", \"invalid\", \"2345:0425:2CA1::0567:5673:23b5\"}, res)\n}\n\nfunc Benchmark_Ctx_IPs_With_IP_Validation(b *testing.B) {\n\tapp := New(Config{EnableIPValidation: true})\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tc.Request().Header.Set(HeaderXForwardedFor, \"127.0.0.1, invalid, 127.0.0.1\")\n\tvar res []string\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\tres = c.IPs()\n\t}\n\tutils.AssertEqual(b, []string{\"127.0.0.1\", \"127.0.0.1\"}, res)\n}\n\nfunc Benchmark_Ctx_IPs_v6_With_IP_Validation(b *testing.B) {\n\tapp := New(Config{EnableIPValidation: true})\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tc.Request().Header.Set(HeaderXForwardedFor, \"2345:0425:2CA1:0000:0000:0567:5673:23b5, invalid, 2345:0425:2CA1::0567:5673:23b5\")\n\tvar res []string\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\tres = c.IPs()\n\t}\n\tutils.AssertEqual(b, []string{\"2345:0425:2CA1:0000:0000:0567:5673:23b5\", \"2345:0425:2CA1::0567:5673:23b5\"}, res)\n}\n\nfunc Benchmark_Ctx_IP_With_ProxyHeader(b *testing.B) {\n\tapp := New(Config{ProxyHeader: HeaderXForwardedFor})\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tc.Request().Header.Set(HeaderXForwardedFor, \"127.0.0.1\")\n\tvar res string\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\tres = c.IP()\n\t}\n\tutils.AssertEqual(b, \"127.0.0.1\", res)\n}\n\nfunc Benchmark_Ctx_IP_With_ProxyHeader_and_IP_Validation(b *testing.B) {\n\tapp := New(Config{ProxyHeader: HeaderXForwardedFor, EnableIPValidation: true})\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tc.Request().Header.Set(HeaderXForwardedFor, \"127.0.0.1\")\n\tvar res string\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\tres = c.IP()\n\t}\n\tutils.AssertEqual(b, \"127.0.0.1\", res)\n}\n\nfunc Benchmark_Ctx_IP(b *testing.B) {\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tc.Request()\n\tvar res string\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\tres = c.IP()\n\t}\n\tutils.AssertEqual(b, \"0.0.0.0\", res)\n}\n\n// go test -run Test_Ctx_Is\nfunc Test_Ctx_Is(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tc.Request().Header.Set(HeaderContentType, MIMETextHTML+\"; boundary=something\")\n\tutils.AssertEqual(t, true, c.Is(\".html\"))\n\tutils.AssertEqual(t, true, c.Is(\"html\"))\n\tutils.AssertEqual(t, false, c.Is(\"json\"))\n\tutils.AssertEqual(t, false, c.Is(\".json\"))\n\tutils.AssertEqual(t, false, c.Is(\"\"))\n\tutils.AssertEqual(t, false, c.Is(\".foooo\"))\n\n\tc.Request().Header.Set(HeaderContentType, MIMEApplicationJSONCharsetUTF8)\n\tutils.AssertEqual(t, false, c.Is(\"html\"))\n\tutils.AssertEqual(t, true, c.Is(\"json\"))\n\tutils.AssertEqual(t, true, c.Is(\".json\"))\n\n\tc.Request().Header.Set(HeaderContentType, \" application/json;charset=UTF-8\")\n\tutils.AssertEqual(t, false, c.Is(\"html\"))\n\tutils.AssertEqual(t, true, c.Is(\"json\"))\n\tutils.AssertEqual(t, true, c.Is(\".json\"))\n\n\tc.Request().Header.Set(HeaderContentType, MIMEApplicationXMLCharsetUTF8)\n\tutils.AssertEqual(t, false, c.Is(\"html\"))\n\tutils.AssertEqual(t, true, c.Is(\"xml\"))\n\tutils.AssertEqual(t, true, c.Is(\".xml\"))\n\n\tc.Request().Header.Set(HeaderContentType, MIMETextPlain)\n\tutils.AssertEqual(t, false, c.Is(\"html\"))\n\tutils.AssertEqual(t, true, c.Is(\"txt\"))\n\tutils.AssertEqual(t, true, c.Is(\".txt\"))\n}\n\n// go test -v -run=^$ -bench=Benchmark_Ctx_Is -benchmem -count=4\nfunc Benchmark_Ctx_Is(b *testing.B) {\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tc.Request().Header.Set(HeaderContentType, MIMEApplicationJSON)\n\tvar res bool\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\t_ = c.Is(\".json\")\n\t\tres = c.Is(\"json\")\n\t}\n\tutils.AssertEqual(b, true, res)\n}\n\n// go test -run Test_Ctx_Locals\nfunc Test_Ctx_Locals(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tapp.Use(func(c *Ctx) error {\n\t\tc.Locals(\"john\", \"doe\")\n\t\treturn c.Next()\n\t})\n\tapp.Get(\"/test\", func(c *Ctx) error {\n\t\tutils.AssertEqual(t, \"doe\", c.Locals(\"john\"))\n\t\treturn nil\n\t})\n\tresp, err := app.Test(httptest.NewRequest(MethodGet, \"/test\", nil))\n\tutils.AssertEqual(t, nil, err, \"app.Test(req)\")\n\tutils.AssertEqual(t, StatusOK, resp.StatusCode, \"Status code\")\n}\n\n// go test -run Test_Ctx_Method\nfunc Test_Ctx_Method(t *testing.T) {\n\tt.Parallel()\n\tfctx := &fasthttp.RequestCtx{}\n\tfctx.Request.Header.SetMethod(MethodGet)\n\tapp := New()\n\tc := app.AcquireCtx(fctx)\n\tdefer app.ReleaseCtx(c)\n\tutils.AssertEqual(t, MethodGet, c.Method())\n\tc.Method(MethodPost)\n\tutils.AssertEqual(t, MethodPost, c.Method())\n\n\tc.Method(\"MethodInvalid\")\n\tutils.AssertEqual(t, MethodPost, c.Method())\n}\n\n// go test -run Test_Ctx_ClientHelloInfo\nfunc Test_Ctx_ClientHelloInfo(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tapp.Get(\"/ServerName\", func(c *Ctx) error {\n\t\tresult := c.ClientHelloInfo()\n\t\tif result != nil {\n\t\t\treturn c.SendString(result.ServerName)\n\t\t}\n\n\t\treturn c.SendString(\"ClientHelloInfo is nil\")\n\t})\n\tapp.Get(\"/SignatureSchemes\", func(c *Ctx) error {\n\t\tresult := c.ClientHelloInfo()\n\t\tif result != nil {\n\t\t\treturn c.JSON(result.SignatureSchemes)\n\t\t}\n\n\t\treturn c.SendString(\"ClientHelloInfo is nil\")\n\t})\n\tapp.Get(\"/SupportedVersions\", func(c *Ctx) error {\n\t\tresult := c.ClientHelloInfo()\n\t\tif result != nil {\n\t\t\treturn c.JSON(result.SupportedVersions)\n\t\t}\n\n\t\treturn c.SendString(\"ClientHelloInfo is nil\")\n\t})\n\n\t// Test without TLS handler\n\tresp, err := app.Test(httptest.NewRequest(MethodGet, \"/ServerName\", nil))\n\tutils.AssertEqual(t, nil, err)\n\tbody, err := io.ReadAll(resp.Body)\n\tutils.AssertEqual(t, nil, err)\n\tutils.AssertEqual(t, []byte(\"ClientHelloInfo is nil\"), body)\n\n\t// Test with TLS Handler\n\tconst (\n\t\tpssWithSHA256 = 0x0804\n\t\tversionTLS13  = 0x0304\n\t)\n\tapp.tlsHandler = &TLSHandler{clientHelloInfo: &tls.ClientHelloInfo{\n\t\tServerName:        \"example.golang\",\n\t\tSignatureSchemes:  []tls.SignatureScheme{pssWithSHA256},\n\t\tSupportedVersions: []uint16{versionTLS13},\n\t}}\n\n\t// Test ServerName\n\tresp, err = app.Test(httptest.NewRequest(MethodGet, \"/ServerName\", nil))\n\tutils.AssertEqual(t, nil, err)\n\tbody, err = io.ReadAll(resp.Body)\n\tutils.AssertEqual(t, nil, err)\n\tutils.AssertEqual(t, []byte(\"example.golang\"), body)\n\n\t// Test SignatureSchemes\n\tresp, err = app.Test(httptest.NewRequest(MethodGet, \"/SignatureSchemes\", nil))\n\tutils.AssertEqual(t, nil, err)\n\tbody, err = io.ReadAll(resp.Body)\n\tutils.AssertEqual(t, nil, err)\n\tutils.AssertEqual(t, \"[\"+strconv.Itoa(pssWithSHA256)+\"]\", string(body))\n\n\t// Test SupportedVersions\n\tresp, err = app.Test(httptest.NewRequest(MethodGet, \"/SupportedVersions\", nil))\n\tutils.AssertEqual(t, nil, err)\n\tbody, err = io.ReadAll(resp.Body)\n\tutils.AssertEqual(t, nil, err)\n\tutils.AssertEqual(t, \"[\"+strconv.Itoa(versionTLS13)+\"]\", string(body))\n}\n\n// go test -run Test_Ctx_InvalidMethod\nfunc Test_Ctx_InvalidMethod(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tapp.Get(\"/\", func(c *Ctx) error {\n\t\treturn nil\n\t})\n\n\tfctx := &fasthttp.RequestCtx{}\n\tfctx.Request.Header.SetMethod(\"InvalidMethod\")\n\tfctx.Request.SetRequestURI(\"/\")\n\n\tapp.Handler()(fctx)\n\n\tutils.AssertEqual(t, 400, fctx.Response.StatusCode())\n\tutils.AssertEqual(t, []byte(\"Invalid http method\"), fctx.Response.Body())\n}\n\n// go test -run Test_Ctx_MultipartForm\nfunc Test_Ctx_MultipartForm(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\n\tapp.Post(\"/test\", func(c *Ctx) error {\n\t\tresult, err := c.MultipartForm()\n\t\tutils.AssertEqual(t, nil, err)\n\t\tutils.AssertEqual(t, \"john\", result.Value[\"name\"][0])\n\t\treturn nil\n\t})\n\n\tbody := &bytes.Buffer{}\n\twriter := multipart.NewWriter(body)\n\tutils.AssertEqual(t, nil, writer.WriteField(\"name\", \"john\"))\n\tutils.AssertEqual(t, nil, writer.Close())\n\n\treq := httptest.NewRequest(MethodPost, \"/test\", body)\n\treq.Header.Set(HeaderContentType, fmt.Sprintf(\"multipart/form-data; boundary=%s\", writer.Boundary()))\n\treq.Header.Set(HeaderContentLength, strconv.Itoa(len(body.Bytes())))\n\n\tresp, err := app.Test(req)\n\tutils.AssertEqual(t, nil, err, \"app.Test(req)\")\n\tutils.AssertEqual(t, StatusOK, resp.StatusCode, \"Status code\")\n}\n\n// go test -v -run=^$ -bench=Benchmark_Ctx_MultipartForm -benchmem -count=4\nfunc Benchmark_Ctx_MultipartForm(b *testing.B) {\n\tapp := New()\n\n\tapp.Post(\"/\", func(c *Ctx) error {\n\t\t_, err := c.MultipartForm()\n\t\treturn err\n\t})\n\n\tc := &fasthttp.RequestCtx{}\n\n\tbody := []byte(\"--b\\r\\nContent-Disposition: form-data; name=\\\"name\\\"\\r\\n\\r\\njohn\\r\\n--b--\")\n\tc.Request.SetBody(body)\n\tc.Request.Header.SetContentType(MIMEMultipartForm + `;boundary=\"b\"`)\n\tc.Request.Header.SetContentLength(len(body))\n\n\th := app.Handler()\n\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\n\tfor n := 0; n < b.N; n++ {\n\t\th(c)\n\t}\n}\n\n// go test -run Test_Ctx_OriginalURL\nfunc Test_Ctx_OriginalURL(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tc.Request().Header.SetRequestURI(\"http://google.com/test?search=demo\")\n\tutils.AssertEqual(t, \"http://google.com/test?search=demo\", c.OriginalURL())\n}\n\n// go test -race -run Test_Ctx_Params\nfunc Test_Ctx_Params(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tapp.Get(\"/test/:user\", func(c *Ctx) error {\n\t\tutils.AssertEqual(t, \"john\", c.Params(\"user\"))\n\t\treturn nil\n\t})\n\tapp.Get(\"/test2/*\", func(c *Ctx) error {\n\t\tutils.AssertEqual(t, \"im/a/cookie\", c.Params(\"*\"))\n\t\treturn nil\n\t})\n\tapp.Get(\"/test3/*/blafasel/*\", func(c *Ctx) error {\n\t\tutils.AssertEqual(t, \"1111\", c.Params(\"*1\"))\n\t\tutils.AssertEqual(t, \"2222\", c.Params(\"*2\"))\n\t\tutils.AssertEqual(t, \"1111\", c.Params(\"*\"))\n\t\treturn nil\n\t})\n\tapp.Get(\"/test4/:optional?\", func(c *Ctx) error {\n\t\tutils.AssertEqual(t, \"\", c.Params(\"optional\"))\n\t\treturn nil\n\t})\n\tapp.Get(\"/test5/:id/:Id\", func(c *Ctx) error {\n\t\tutils.AssertEqual(t, \"first\", c.Params(\"id\"))\n\t\tutils.AssertEqual(t, \"first\", c.Params(\"Id\"))\n\t\treturn nil\n\t})\n\tresp, err := app.Test(httptest.NewRequest(MethodGet, \"/test/john\", nil))\n\tutils.AssertEqual(t, nil, err, \"app.Test(req)\")\n\tutils.AssertEqual(t, StatusOK, resp.StatusCode, \"Status code\")\n\n\tresp, err = app.Test(httptest.NewRequest(MethodGet, \"/test2/im/a/cookie\", nil))\n\tutils.AssertEqual(t, nil, err, \"app.Test(req)\")\n\tutils.AssertEqual(t, StatusOK, resp.StatusCode, \"Status code\")\n\n\tresp, err = app.Test(httptest.NewRequest(MethodGet, \"/test3/1111/blafasel/2222\", nil))\n\tutils.AssertEqual(t, nil, err, \"app.Test(req)\")\n\tutils.AssertEqual(t, StatusOK, resp.StatusCode, \"Status code\")\n\n\tresp, err = app.Test(httptest.NewRequest(MethodGet, \"/test4\", nil))\n\tutils.AssertEqual(t, nil, err, \"app.Test(req)\")\n\tutils.AssertEqual(t, StatusOK, resp.StatusCode, \"Status code\")\n\n\tresp, err = app.Test(httptest.NewRequest(MethodGet, \"/test5/first/second\", nil))\n\tutils.AssertEqual(t, nil, err)\n\tutils.AssertEqual(t, StatusOK, resp.StatusCode, \"Status code\")\n}\n\nfunc Test_Ctx_Params_Case_Sensitive(t *testing.T) {\n\tt.Parallel()\n\tapp := New(Config{CaseSensitive: true})\n\tapp.Get(\"/test/:User\", func(c *Ctx) error {\n\t\tutils.AssertEqual(t, \"john\", c.Params(\"User\"))\n\t\tutils.AssertEqual(t, \"\", c.Params(\"user\"))\n\t\treturn nil\n\t})\n\tapp.Get(\"/test2/:id/:Id\", func(c *Ctx) error {\n\t\tutils.AssertEqual(t, \"first\", c.Params(\"id\"))\n\t\tutils.AssertEqual(t, \"second\", c.Params(\"Id\"))\n\t\treturn nil\n\t})\n\tresp, err := app.Test(httptest.NewRequest(MethodGet, \"/test/john\", nil))\n\tutils.AssertEqual(t, nil, err, \"app.Test(req)\")\n\tutils.AssertEqual(t, StatusOK, resp.StatusCode, \"Status code\")\n\n\tresp, err = app.Test(httptest.NewRequest(MethodGet, \"/test2/first/second\", nil))\n\tutils.AssertEqual(t, nil, err)\n\tutils.AssertEqual(t, StatusOK, resp.StatusCode, \"Status code\")\n}\n\n// go test -race -run Test_Ctx_AllParams\nfunc Test_Ctx_AllParams(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tapp.Get(\"/test/:user\", func(c *Ctx) error {\n\t\tutils.AssertEqual(t, map[string]string{\"user\": \"john\"}, c.AllParams())\n\t\treturn nil\n\t})\n\tapp.Get(\"/test2/*\", func(c *Ctx) error {\n\t\tutils.AssertEqual(t, map[string]string{\"*1\": \"im/a/cookie\"}, c.AllParams())\n\t\treturn nil\n\t})\n\tapp.Get(\"/test3/*/blafasel/*\", func(c *Ctx) error {\n\t\tutils.AssertEqual(t, map[string]string{\"*1\": \"1111\", \"*2\": \"2222\"}, c.AllParams())\n\t\treturn nil\n\t})\n\tapp.Get(\"/test4/:optional?\", func(c *Ctx) error {\n\t\tutils.AssertEqual(t, map[string]string{\"optional\": \"\"}, c.AllParams())\n\t\treturn nil\n\t})\n\n\tresp, err := app.Test(httptest.NewRequest(MethodGet, \"/test/john\", nil))\n\tutils.AssertEqual(t, nil, err, \"app.Test(req)\")\n\tutils.AssertEqual(t, StatusOK, resp.StatusCode, \"Status code\")\n\n\tresp, err = app.Test(httptest.NewRequest(MethodGet, \"/test2/im/a/cookie\", nil))\n\tutils.AssertEqual(t, nil, err, \"app.Test(req)\")\n\tutils.AssertEqual(t, StatusOK, resp.StatusCode, \"Status code\")\n\n\tresp, err = app.Test(httptest.NewRequest(MethodGet, \"/test3/1111/blafasel/2222\", nil))\n\tutils.AssertEqual(t, nil, err, \"app.Test(req)\")\n\tutils.AssertEqual(t, StatusOK, resp.StatusCode, \"Status code\")\n\n\tresp, err = app.Test(httptest.NewRequest(MethodGet, \"/test4\", nil))\n\tutils.AssertEqual(t, nil, err, \"app.Test(req)\")\n\tutils.AssertEqual(t, StatusOK, resp.StatusCode, \"Status code\")\n}\n\n// go test -v -run=^$ -bench=Benchmark_Ctx_Params -benchmem -count=4\nfunc Benchmark_Ctx_Params(b *testing.B) {\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tc.route = &Route{\n\t\tParams: []string{\n\t\t\t\"param1\", \"param2\", \"param3\", \"param4\",\n\t\t},\n\t}\n\tc.values = [maxParams]string{\n\t\t\"john\", \"doe\", \"is\", \"awesome\",\n\t}\n\tvar res string\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\t_ = c.Params(\"param1\")\n\t\t_ = c.Params(\"param2\")\n\t\t_ = c.Params(\"param3\")\n\t\tres = c.Params(\"param4\")\n\t}\n\tutils.AssertEqual(b, \"awesome\", res)\n}\n\n// go test -v -run=^$ -bench=Benchmark_Ctx_AllParams -benchmem -count=4\nfunc Benchmark_Ctx_AllParams(b *testing.B) {\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tc.route = &Route{\n\t\tParams: []string{\n\t\t\t\"param1\", \"param2\", \"param3\", \"param4\",\n\t\t},\n\t}\n\tc.values = [maxParams]string{\n\t\t\"john\", \"doe\", \"is\", \"awesome\",\n\t}\n\tvar res map[string]string\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\tres = c.AllParams()\n\t}\n\tutils.AssertEqual(\n\t\tb,\n\t\tmap[string]string{\n\t\t\t\"param1\": \"john\",\n\t\t\t\"param2\": \"doe\",\n\t\t\t\"param3\": \"is\",\n\t\t\t\"param4\": \"awesome\",\n\t\t},\n\t\tres,\n\t)\n}\n\n// go test -v -run=^$ -bench=Benchmark_Ctx_ParamsParse -benchmem -count=4\nfunc Benchmark_Ctx_ParamsParse(b *testing.B) {\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tc.route = &Route{\n\t\tParams: []string{\n\t\t\t\"param1\", \"param2\", \"param3\", \"param4\",\n\t\t},\n\t}\n\tc.values = [maxParams]string{\n\t\t\"john\", \"doe\", \"is\", \"awesome\",\n\t}\n\tvar res struct {\n\t\tParam1 string `params:\"param1\"`\n\t\tParam2 string `params:\"param2\"`\n\t\tParam3 string `params:\"param3\"`\n\t\tParam4 string `params:\"param4\"`\n\t}\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\n\tvar err error\n\tfor n := 0; n < b.N; n++ {\n\t\terr = c.ParamsParser(&res)\n\t}\n\n\tutils.AssertEqual(b, nil, err)\n\tutils.AssertEqual(b, \"john\", res.Param1)\n\tutils.AssertEqual(b, \"doe\", res.Param2)\n\tutils.AssertEqual(b, \"is\", res.Param3)\n\tutils.AssertEqual(b, \"awesome\", res.Param4)\n}\n\n// go test -run Test_Ctx_Path\nfunc Test_Ctx_Path(t *testing.T) {\n\tt.Parallel()\n\tapp := New(Config{UnescapePath: true})\n\tapp.Get(\"/test/:user\", func(c *Ctx) error {\n\t\tutils.AssertEqual(t, \"/Test/John\", c.Path())\n\t\t// not strict && case insensitive\n\t\tutils.AssertEqual(t, \"/ABC/\", c.Path(\"/ABC/\"))\n\t\tutils.AssertEqual(t, \"/test/john/\", c.Path(\"/test/john/\"))\n\t\treturn nil\n\t})\n\n\t// test with special chars\n\tapp.Get(\"/specialChars/:name\", func(c *Ctx) error {\n\t\tutils.AssertEqual(t, \"/specialChars/cr\u00e9er\", c.Path())\n\t\t// unescape is also working if you set the path afterwards\n\t\tutils.AssertEqual(t, \"/\u0627\u062e\u062a\u0628\u0627\u0631/\", c.Path(\"/%D8%A7%D8%AE%D8%AA%D8%A8%D8%A7%D8%B1/\"))\n\t\treturn nil\n\t})\n\tresp, err := app.Test(httptest.NewRequest(MethodGet, \"/specialChars/cr%C3%A9er\", nil))\n\tutils.AssertEqual(t, nil, err, \"app.Test(req)\")\n\tutils.AssertEqual(t, StatusOK, resp.StatusCode, \"Status code\")\n}\n\n// go test -run Test_Ctx_Protocol\nfunc Test_Ctx_Protocol(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\n\tfreq := &fasthttp.RequestCtx{}\n\tfreq.Request.Header.Set(\"X-Forwarded\", \"invalid\")\n\n\tc := app.AcquireCtx(freq)\n\tdefer app.ReleaseCtx(c)\n\tc.Request().Header.Set(HeaderXForwardedProto, schemeHTTPS)\n\tutils.AssertEqual(t, schemeHTTPS, c.Protocol())\n\tc.Request().Header.Reset()\n\n\tc.Request().Header.Set(HeaderXForwardedProtocol, schemeHTTPS)\n\tutils.AssertEqual(t, schemeHTTPS, c.Protocol())\n\tc.Request().Header.Reset()\n\n\tc.Request().Header.Set(HeaderXForwardedProto, \"https, http\")\n\tutils.AssertEqual(t, schemeHTTPS, c.Protocol())\n\tc.Request().Header.Reset()\n\n\tc.Request().Header.Set(HeaderXForwardedProtocol, \"https, http\")\n\tutils.AssertEqual(t, schemeHTTPS, c.Protocol())\n\tc.Request().Header.Reset()\n\n\tc.Request().Header.Set(HeaderXForwardedSsl, \"on\")\n\tutils.AssertEqual(t, schemeHTTPS, c.Protocol())\n\tc.Request().Header.Reset()\n\n\tc.Request().Header.Set(HeaderXUrlScheme, schemeHTTPS)\n\tutils.AssertEqual(t, schemeHTTPS, c.Protocol())\n\tc.Request().Header.Reset()\n\n\tutils.AssertEqual(t, schemeHTTP, c.Protocol())\n}\n\n// go test -v -run=^$ -bench=Benchmark_Ctx_Protocol -benchmem -count=4\nfunc Benchmark_Ctx_Protocol(b *testing.B) {\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tvar res string\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\tres = c.Protocol()\n\t}\n\tutils.AssertEqual(b, schemeHTTP, res)\n}\n\n// go test -run Test_Ctx_Protocol_TrustedProxy\nfunc Test_Ctx_Protocol_TrustedProxy(t *testing.T) {\n\tt.Parallel()\n\tapp := New(Config{EnableTrustedProxyCheck: true, TrustedProxies: []string{\"0.0.0.0\"}})\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\n\tc.Request().Header.Set(HeaderXForwardedProto, schemeHTTPS)\n\tutils.AssertEqual(t, schemeHTTPS, c.Protocol())\n\tc.Request().Header.Reset()\n\n\tc.Request().Header.Set(HeaderXForwardedProtocol, schemeHTTPS)\n\tutils.AssertEqual(t, schemeHTTPS, c.Protocol())\n\tc.Request().Header.Reset()\n\n\tc.Request().Header.Set(HeaderXForwardedSsl, \"on\")\n\tutils.AssertEqual(t, schemeHTTPS, c.Protocol())\n\tc.Request().Header.Reset()\n\n\tc.Request().Header.Set(HeaderXUrlScheme, schemeHTTPS)\n\tutils.AssertEqual(t, schemeHTTPS, c.Protocol())\n\tc.Request().Header.Reset()\n\n\tutils.AssertEqual(t, schemeHTTP, c.Protocol())\n}\n\n// go test -run Test_Ctx_Protocol_TrustedProxyRange\nfunc Test_Ctx_Protocol_TrustedProxyRange(t *testing.T) {\n\tt.Parallel()\n\tapp := New(Config{EnableTrustedProxyCheck: true, TrustedProxies: []string{\"0.0.0.0/30\"}})\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\n\tc.Request().Header.Set(HeaderXForwardedProto, schemeHTTPS)\n\tutils.AssertEqual(t, schemeHTTPS, c.Protocol())\n\tc.Request().Header.Reset()\n\n\tc.Request().Header.Set(HeaderXForwardedProtocol, schemeHTTPS)\n\tutils.AssertEqual(t, schemeHTTPS, c.Protocol())\n\tc.Request().Header.Reset()\n\n\tc.Request().Header.Set(HeaderXForwardedSsl, \"on\")\n\tutils.AssertEqual(t, schemeHTTPS, c.Protocol())\n\tc.Request().Header.Reset()\n\n\tc.Request().Header.Set(HeaderXUrlScheme, schemeHTTPS)\n\tutils.AssertEqual(t, schemeHTTPS, c.Protocol())\n\tc.Request().Header.Reset()\n\n\tutils.AssertEqual(t, schemeHTTP, c.Protocol())\n}\n\n// go test -run Test_Ctx_Protocol_UntrustedProxyRange\nfunc Test_Ctx_Protocol_UntrustedProxyRange(t *testing.T) {\n\tt.Parallel()\n\tapp := New(Config{EnableTrustedProxyCheck: true, TrustedProxies: []string{\"1.1.1.1/30\"}})\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\n\tc.Request().Header.Set(HeaderXForwardedProto, schemeHTTPS)\n\tutils.AssertEqual(t, schemeHTTP, c.Protocol())\n\tc.Request().Header.Reset()\n\n\tc.Request().Header.Set(HeaderXForwardedProtocol, schemeHTTPS)\n\tutils.AssertEqual(t, schemeHTTP, c.Protocol())\n\tc.Request().Header.Reset()\n\n\tc.Request().Header.Set(HeaderXForwardedSsl, \"on\")\n\tutils.AssertEqual(t, schemeHTTP, c.Protocol())\n\tc.Request().Header.Reset()\n\n\tc.Request().Header.Set(HeaderXUrlScheme, schemeHTTPS)\n\tutils.AssertEqual(t, schemeHTTP, c.Protocol())\n\tc.Request().Header.Reset()\n\n\tutils.AssertEqual(t, schemeHTTP, c.Protocol())\n}\n\n// go test -run Test_Ctx_Protocol_UnTrustedProxy\nfunc Test_Ctx_Protocol_UnTrustedProxy(t *testing.T) {\n\tt.Parallel()\n\tapp := New(Config{EnableTrustedProxyCheck: true, TrustedProxies: []string{\"0.8.0.1\"}})\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\n\tc.Request().Header.Set(HeaderXForwardedProto, schemeHTTPS)\n\tutils.AssertEqual(t, schemeHTTP, c.Protocol())\n\tc.Request().Header.Reset()\n\n\tc.Request().Header.Set(HeaderXForwardedProtocol, schemeHTTPS)\n\tutils.AssertEqual(t, schemeHTTP, c.Protocol())\n\tc.Request().Header.Reset()\n\n\tc.Request().Header.Set(HeaderXForwardedSsl, \"on\")\n\tutils.AssertEqual(t, schemeHTTP, c.Protocol())\n\tc.Request().Header.Reset()\n\n\tc.Request().Header.Set(HeaderXUrlScheme, schemeHTTPS)\n\tutils.AssertEqual(t, schemeHTTP, c.Protocol())\n\tc.Request().Header.Reset()\n\n\tutils.AssertEqual(t, schemeHTTP, c.Protocol())\n}\n\n// go test -run Test_Ctx_Query\nfunc Test_Ctx_Query(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tc.Request().URI().SetQueryString(\"search=john&age=20&id=\")\n\tutils.AssertEqual(t, \"john\", c.Query(\"search\"))\n\tutils.AssertEqual(t, \"20\", c.Query(\"age\"))\n\tutils.AssertEqual(t, \"default\", c.Query(\"unknown\", \"default\"))\n}\n\nfunc Test_Ctx_QueryInt(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tc.Request().URI().SetQueryString(\"search=john&age=20&id=\")\n\n\tutils.AssertEqual(t, 0, c.QueryInt(\"foo\"))\n\tutils.AssertEqual(t, 20, c.QueryInt(\"age\", 12))\n\tutils.AssertEqual(t, 0, c.QueryInt(\"search\"))\n\tutils.AssertEqual(t, 1, c.QueryInt(\"search\", 1))\n\tutils.AssertEqual(t, 0, c.QueryInt(\"id\"))\n\tutils.AssertEqual(t, 2, c.QueryInt(\"id\", 2))\n}\n\nfunc Test_Ctx_QueryBool(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tc.Request().URI().SetQueryString(\"name=alex&want_pizza=false&id=\")\n\n\tutils.AssertEqual(t, false, c.QueryBool(\"want_pizza\"))\n\tutils.AssertEqual(t, false, c.QueryBool(\"want_pizza\", true))\n\tutils.AssertEqual(t, false, c.QueryBool(\"name\"))\n\tutils.AssertEqual(t, true, c.QueryBool(\"name\", true))\n\tutils.AssertEqual(t, false, c.QueryBool(\"id\"))\n\tutils.AssertEqual(t, true, c.QueryBool(\"id\", true))\n}\n\nfunc Test_Ctx_QueryFloat(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tc.Request().URI().SetQueryString(\"name=alex&amount=32.23&id=\")\n\n\tutils.AssertEqual(t, 32.23, c.QueryFloat(\"amount\"))\n\tutils.AssertEqual(t, 32.23, c.QueryFloat(\"amount\", 3.123))\n\tutils.AssertEqual(t, 87.123, c.QueryFloat(\"name\", 87.123))\n\tutils.AssertEqual(t, float64(0), c.QueryFloat(\"name\"))\n\tutils.AssertEqual(t, 12.87, c.QueryFloat(\"id\", 12.87))\n\tutils.AssertEqual(t, float64(0), c.QueryFloat(\"id\"))\n}\n\n// go test -run Test_Ctx_Range\nfunc Test_Ctx_Range(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\n\tvar (\n\t\tresult Range\n\t\terr    error\n\t)\n\n\t_, err = c.Range(1000)\n\tutils.AssertEqual(t, true, err != nil)\n\n\tc.Request().Header.Set(HeaderRange, \"bytes=500\")\n\t_, err = c.Range(1000)\n\tutils.AssertEqual(t, true, err != nil)\n\n\tc.Request().Header.Set(HeaderRange, \"bytes=500=\")\n\t_, err = c.Range(1000)\n\tutils.AssertEqual(t, true, err != nil)\n\n\tc.Request().Header.Set(HeaderRange, \"bytes=500-300\")\n\t_, err = c.Range(1000)\n\tutils.AssertEqual(t, true, err != nil)\n\n\ttestRange := func(header string, start, end int) {\n\t\tc.Request().Header.Set(HeaderRange, header)\n\t\tresult, err = c.Range(1000)\n\t\tutils.AssertEqual(t, nil, err)\n\t\tutils.AssertEqual(t, \"bytes\", result.Type)\n\t\tutils.AssertEqual(t, start, result.Ranges[0].Start)\n\t\tutils.AssertEqual(t, end, result.Ranges[0].End)\n\t}\n\n\ttestRange(\"bytes=a-700\", 300, 999)\n\ttestRange(\"bytes=500-b\", 500, 999)\n\ttestRange(\"bytes=500-1000\", 500, 999)\n\ttestRange(\"bytes=500-700\", 500, 700)\n}\n\n// go test -run Test_Ctx_Route\nfunc Test_Ctx_Route(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tapp.Get(\"/test\", func(c *Ctx) error {\n\t\tutils.AssertEqual(t, \"/test\", c.Route().Path)\n\t\treturn nil\n\t})\n\tresp, err := app.Test(httptest.NewRequest(MethodGet, \"/test\", nil))\n\tutils.AssertEqual(t, nil, err, \"app.Test(req)\")\n\tutils.AssertEqual(t, StatusOK, resp.StatusCode, \"Status code\")\n\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\n\tutils.AssertEqual(t, \"/\", c.Route().Path)\n\tutils.AssertEqual(t, MethodGet, c.Route().Method)\n\tutils.AssertEqual(t, 0, len(c.Route().Handlers))\n}\n\n// go test -run Test_Ctx_RouteNormalized\nfunc Test_Ctx_RouteNormalized(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tapp.Get(\"/test\", func(c *Ctx) error {\n\t\tutils.AssertEqual(t, \"/test\", c.Route().Path)\n\t\treturn nil\n\t})\n\tresp, err := app.Test(httptest.NewRequest(MethodGet, \"//test\", nil))\n\tutils.AssertEqual(t, nil, err, \"app.Test(req)\")\n\tutils.AssertEqual(t, StatusNotFound, resp.StatusCode, \"Status code\")\n}\n\n// go test -run Test_Ctx_SaveFile\nfunc Test_Ctx_SaveFile(t *testing.T) {\n\t// TODO We should clean this up\n\tt.Parallel()\n\tapp := New()\n\n\tapp.Post(\"/test\", func(c *Ctx) error {\n\t\tfh, err := c.FormFile(\"file\")\n\t\tutils.AssertEqual(t, nil, err)\n\n\t\ttempFile, err := os.CreateTemp(os.TempDir(), \"test-\")\n\t\tutils.AssertEqual(t, nil, err)\n\n\t\tdefer func(file *os.File) {\n\t\t\terr := file.Close()\n\t\t\tutils.AssertEqual(t, nil, err)\n\t\t\terr = os.Remove(file.Name())\n\t\t\tutils.AssertEqual(t, nil, err)\n\t\t}(tempFile)\n\t\terr = c.SaveFile(fh, tempFile.Name())\n\t\tutils.AssertEqual(t, nil, err)\n\n\t\tbs, err := os.ReadFile(tempFile.Name())\n\t\tutils.AssertEqual(t, nil, err)\n\t\tutils.AssertEqual(t, \"hello world\", string(bs))\n\t\treturn nil\n\t})\n\n\tbody := &bytes.Buffer{}\n\twriter := multipart.NewWriter(body)\n\n\tioWriter, err := writer.CreateFormFile(\"file\", \"test\")\n\tutils.AssertEqual(t, nil, err)\n\n\t_, err = ioWriter.Write([]byte(\"hello world\"))\n\tutils.AssertEqual(t, nil, err)\n\tutils.AssertEqual(t, nil, writer.Close())\n\n\treq := httptest.NewRequest(MethodPost, \"/test\", body)\n\treq.Header.Set(\"Content-Type\", writer.FormDataContentType())\n\treq.Header.Set(\"Content-Length\", strconv.Itoa(len(body.Bytes())))\n\n\tresp, err := app.Test(req)\n\tutils.AssertEqual(t, nil, err, \"app.Test(req)\")\n\tutils.AssertEqual(t, StatusOK, resp.StatusCode, \"Status code\")\n}\n\n// go test -run Test_Ctx_SaveFileToStorage\nfunc Test_Ctx_SaveFileToStorage(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tstorage := memory.New()\n\n\tapp.Post(\"/test\", func(c *Ctx) error {\n\t\tfh, err := c.FormFile(\"file\")\n\t\tutils.AssertEqual(t, nil, err)\n\n\t\terr = c.SaveFileToStorage(fh, \"test\", storage)\n\t\tutils.AssertEqual(t, nil, err)\n\n\t\tfile, err := storage.Get(\"test\")\n\t\tutils.AssertEqual(t, []byte(\"hello world\"), file)\n\t\tutils.AssertEqual(t, nil, err)\n\n\t\terr = storage.Delete(\"test\")\n\t\tutils.AssertEqual(t, nil, err)\n\n\t\treturn nil\n\t})\n\n\tbody := &bytes.Buffer{}\n\twriter := multipart.NewWriter(body)\n\n\tioWriter, err := writer.CreateFormFile(\"file\", \"test\")\n\tutils.AssertEqual(t, nil, err)\n\n\t_, err = ioWriter.Write([]byte(\"hello world\"))\n\tutils.AssertEqual(t, nil, err)\n\tutils.AssertEqual(t, nil, writer.Close())\n\n\treq := httptest.NewRequest(MethodPost, \"/test\", body)\n\treq.Header.Set(\"Content-Type\", writer.FormDataContentType())\n\treq.Header.Set(\"Content-Length\", strconv.Itoa(len(body.Bytes())))\n\n\tresp, err := app.Test(req)\n\tutils.AssertEqual(t, nil, err, \"app.Test(req)\")\n\tutils.AssertEqual(t, StatusOK, resp.StatusCode, \"Status code\")\n}\n\n// go test -run Test_Ctx_Secure\nfunc Test_Ctx_Secure(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\t// TODO Add TLS conn\n\tutils.AssertEqual(t, false, c.Secure())\n}\n\n// go test -run Test_Ctx_Stale\nfunc Test_Ctx_Stale(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tutils.AssertEqual(t, true, c.Stale())\n}\n\n// go test -run Test_Ctx_Subdomains\nfunc Test_Ctx_Subdomains(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tc.Request().URI().SetHost(\"john.doe.is.awesome.google.com\")\n\tutils.AssertEqual(t, []string{\"john\", \"doe\"}, c.Subdomains(4))\n\n\tc.Request().URI().SetHost(\"localhost:3000\")\n\tutils.AssertEqual(t, []string{\"localhost:3000\"}, c.Subdomains())\n}\n\n// go test -v -run=^$ -bench=Benchmark_Ctx_Subdomains -benchmem -count=4\nfunc Benchmark_Ctx_Subdomains(b *testing.B) {\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tc.Request().SetRequestURI(\"http://john.doe.google.com\")\n\tvar res []string\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\tres = c.Subdomains()\n\t}\n\tutils.AssertEqual(b, []string{\"john\", \"doe\"}, res)\n}\n\n// go test -run Test_Ctx_ClearCookie\nfunc Test_Ctx_ClearCookie(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tc.Request().Header.Set(HeaderCookie, \"john=doe\")\n\tc.ClearCookie(\"john\")\n\tutils.AssertEqual(t, true, strings.HasPrefix(string(c.Response().Header.Peek(HeaderSetCookie)), \"john=; expires=\"))\n\n\tc.Request().Header.Set(HeaderCookie, \"test1=dummy\")\n\tc.Request().Header.Set(HeaderCookie, \"test2=dummy\")\n\tc.ClearCookie()\n\tutils.AssertEqual(t, true, strings.Contains(string(c.Response().Header.Peek(HeaderSetCookie)), \"test1=; expires=\"))\n\tutils.AssertEqual(t, true, strings.Contains(string(c.Response().Header.Peek(HeaderSetCookie)), \"test2=; expires=\"))\n}\n\n// go test -race -run Test_Ctx_Download\nfunc Test_Ctx_Download(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\n\tutils.AssertEqual(t, nil, c.Download(\"ctx.go\", \"Awesome File!\"))\n\n\tf, err := os.Open(\"./ctx.go\")\n\tutils.AssertEqual(t, nil, err)\n\tdefer func() {\n\t\tutils.AssertEqual(t, nil, f.Close())\n\t}()\n\n\texpect, err := io.ReadAll(f)\n\tutils.AssertEqual(t, nil, err)\n\tutils.AssertEqual(t, expect, c.Response().Body())\n\tutils.AssertEqual(t, `attachment; filename=\"Awesome+File%21\"`, string(c.Response().Header.Peek(HeaderContentDisposition)))\n\n\tutils.AssertEqual(t, nil, c.Download(\"ctx.go\"))\n\tutils.AssertEqual(t, `attachment; filename=\"ctx.go\"`, string(c.Response().Header.Peek(HeaderContentDisposition)))\n}\n\n// go test -race -run Test_Ctx_SendFile\nfunc Test_Ctx_SendFile(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\n\t// fetch file content\n\tf, err := os.Open(\"./ctx.go\")\n\tutils.AssertEqual(t, nil, err)\n\tdefer func() {\n\t\tutils.AssertEqual(t, nil, f.Close())\n\t}()\n\texpectFileContent, err := io.ReadAll(f)\n\tutils.AssertEqual(t, nil, err)\n\t// fetch file info for the not modified test case\n\tfI, err := os.Stat(\"./ctx.go\")\n\tutils.AssertEqual(t, nil, err)\n\n\t// simple test case\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\terr = c.SendFile(\"ctx.go\")\n\t// check expectation\n\tutils.AssertEqual(t, nil, err)\n\tutils.AssertEqual(t, expectFileContent, c.Response().Body())\n\tutils.AssertEqual(t, StatusOK, c.Response().StatusCode())\n\tapp.ReleaseCtx(c)\n\n\t// test with custom error code\n\tc = app.AcquireCtx(&fasthttp.RequestCtx{})\n\terr = c.Status(StatusInternalServerError).SendFile(\"ctx.go\")\n\t// check expectation\n\tutils.AssertEqual(t, nil, err)\n\tutils.AssertEqual(t, expectFileContent, c.Response().Body())\n\tutils.AssertEqual(t, StatusInternalServerError, c.Response().StatusCode())\n\tapp.ReleaseCtx(c)\n\n\t// test not modified\n\tc = app.AcquireCtx(&fasthttp.RequestCtx{})\n\tc.Request().Header.Set(HeaderIfModifiedSince, fI.ModTime().Format(time.RFC1123))\n\terr = c.SendFile(\"ctx.go\")\n\t// check expectation\n\tutils.AssertEqual(t, nil, err)\n\tutils.AssertEqual(t, StatusNotModified, c.Response().StatusCode())\n\tutils.AssertEqual(t, []byte(nil), c.Response().Body())\n\tapp.ReleaseCtx(c)\n}\n\n// go test -race -run Test_Ctx_SendFile_404\nfunc Test_Ctx_SendFile_404(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tapp.Get(\"/\", func(c *Ctx) error {\n\t\terr := c.SendFile(filepath.FromSlash(\"john_dow.go/\"))\n\t\tutils.AssertEqual(t, false, err == nil)\n\t\treturn err\n\t})\n\n\tresp, err := app.Test(httptest.NewRequest(MethodGet, \"/\", nil))\n\tutils.AssertEqual(t, nil, err)\n\tutils.AssertEqual(t, StatusNotFound, resp.StatusCode)\n}\n\n// go test -race -run Test_Ctx_SendFile_Immutable\nfunc Test_Ctx_SendFile_Immutable(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tvar endpointsForTest []string\n\taddEndpoint := func(file, endpoint string) {\n\t\tendpointsForTest = append(endpointsForTest, endpoint)\n\t\tapp.Get(endpoint, func(c *Ctx) error {\n\t\t\tif err := c.SendFile(file); err != nil {\n\t\t\t\tutils.AssertEqual(t, nil, err)\n\t\t\t\treturn err\n\t\t\t}\n\t\t\treturn c.SendStatus(200)\n\t\t})\n\t}\n\n\t// relative paths\n\taddEndpoint(\"./.github/index.html\", \"/relativeWithDot\")\n\taddEndpoint(filepath.FromSlash(\"./.github/index.html\"), \"/relativeOSWithDot\")\n\taddEndpoint(\".github/index.html\", \"/relative\")\n\taddEndpoint(filepath.FromSlash(\".github/index.html\"), \"/relativeOS\")\n\n\t// absolute paths\n\tif path, err := filepath.Abs(\".github/index.html\"); err != nil {\n\t\tutils.AssertEqual(t, nil, err)\n\t} else {\n\t\taddEndpoint(path, \"/absolute\")\n\t\taddEndpoint(filepath.FromSlash(path), \"/absoluteOS\") // os related\n\t}\n\n\tfor _, endpoint := range endpointsForTest {\n\t\tt.Run(endpoint, func(t *testing.T) {\n\t\t\t// 1st try\n\t\t\tresp, err := app.Test(httptest.NewRequest(MethodGet, endpoint, nil))\n\t\t\tutils.AssertEqual(t, nil, err)\n\t\t\tutils.AssertEqual(t, StatusOK, resp.StatusCode)\n\t\t\t// 2nd try\n\t\t\tresp, err = app.Test(httptest.NewRequest(MethodGet, endpoint, nil))\n\t\t\tutils.AssertEqual(t, nil, err)\n\t\t\tutils.AssertEqual(t, StatusOK, resp.StatusCode)\n\t\t})\n\t}\n}\n\n// go test -race -run Test_Ctx_SendFile_RestoreOriginalURL\nfunc Test_Ctx_SendFile_RestoreOriginalURL(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tapp.Get(\"/\", func(c *Ctx) error {\n\t\toriginalURL := utils.CopyString(c.OriginalURL())\n\t\terr := c.SendFile(\"ctx.go\")\n\t\tutils.AssertEqual(t, originalURL, c.OriginalURL())\n\t\treturn err\n\t})\n\n\t_, err1 := app.Test(httptest.NewRequest(MethodGet, \"/?test=true\", nil))\n\t// second request required to confirm with zero allocation\n\t_, err2 := app.Test(httptest.NewRequest(MethodGet, \"/?test=true\", nil))\n\n\tutils.AssertEqual(t, nil, err1)\n\tutils.AssertEqual(t, nil, err2)\n}\n\n// go test -run Test_Ctx_JSON\nfunc Test_Ctx_JSON(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\n\tutils.AssertEqual(t, true, c.JSON(complex(1, 1)) != nil)\n\n\terr := c.JSON(Map{ // map has no order\n\t\t\"Name\": \"Grame\",\n\t\t\"Age\":  20,\n\t})\n\tutils.AssertEqual(t, nil, err)\n\tutils.AssertEqual(t, `{\"Age\":20,\"Name\":\"Grame\"}`, string(c.Response().Body()))\n\tutils.AssertEqual(t, \"application/json\", string(c.Response().Header.Peek(\"content-type\")))\n\n\ttestEmpty := func(v interface{}, r string) {\n\t\terr := c.JSON(v)\n\t\tutils.AssertEqual(t, nil, err)\n\t\tutils.AssertEqual(t, r, string(c.Response().Body()))\n\t}\n\n\ttestEmpty(nil, \"null\")\n\ttestEmpty(\"\", `\"\"`)\n\ttestEmpty(0, \"0\")\n\ttestEmpty([]int{}, \"[]\")\n}\n\n// go test -run=^$ -bench=Benchmark_Ctx_JSON -benchmem -count=4\nfunc Benchmark_Ctx_JSON(b *testing.B) {\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\ttype SomeStruct struct {\n\t\tName string\n\t\tAge  uint8\n\t}\n\tdata := SomeStruct{\n\t\tName: \"Grame\",\n\t\tAge:  20,\n\t}\n\tvar err error\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\terr = c.JSON(data)\n\t}\n\tutils.AssertEqual(b, nil, err)\n\tutils.AssertEqual(b, `{\"Name\":\"Grame\",\"Age\":20}`, string(c.Response().Body()))\n}\n\n// go test -run Test_Ctx_JSONP\nfunc Test_Ctx_JSONP(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\n\tutils.AssertEqual(t, true, c.JSONP(complex(1, 1)) != nil)\n\n\terr := c.JSONP(Map{\n\t\t\"Name\": \"Grame\",\n\t\t\"Age\":  20,\n\t})\n\tutils.AssertEqual(t, nil, err)\n\tutils.AssertEqual(t, `callback({\"Age\":20,\"Name\":\"Grame\"});`, string(c.Response().Body()))\n\tutils.AssertEqual(t, \"text/javascript; charset=utf-8\", string(c.Response().Header.Peek(\"content-type\")))\n\n\terr = c.JSONP(Map{\n\t\t\"Name\": \"Grame\",\n\t\t\"Age\":  20,\n\t}, \"john\")\n\tutils.AssertEqual(t, nil, err)\n\tutils.AssertEqual(t, `john({\"Age\":20,\"Name\":\"Grame\"});`, string(c.Response().Body()))\n\tutils.AssertEqual(t, \"text/javascript; charset=utf-8\", string(c.Response().Header.Peek(\"content-type\")))\n}\n\n// go test -v  -run=^$ -bench=Benchmark_Ctx_JSONP -benchmem -count=4\nfunc Benchmark_Ctx_JSONP(b *testing.B) {\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\ttype SomeStruct struct {\n\t\tName string\n\t\tAge  uint8\n\t}\n\tdata := SomeStruct{\n\t\tName: \"Grame\",\n\t\tAge:  20,\n\t}\n\tcallback := \"emit\"\n\tvar err error\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\terr = c.JSONP(data, callback)\n\t}\n\tutils.AssertEqual(b, nil, err)\n\tutils.AssertEqual(b, `emit({\"Name\":\"Grame\",\"Age\":20});`, string(c.Response().Body()))\n}\n\n// go test -run Test_Ctx_XML\nfunc Test_Ctx_XML(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\n\tutils.AssertEqual(t, true, c.JSON(complex(1, 1)) != nil)\n\n\ttype xmlResult struct {\n\t\tXMLName xml.Name `xml:\"Users\"`\n\t\tNames   []string `xml:\"Names\"`\n\t\tAges    []int    `xml:\"Ages\"`\n\t}\n\n\terr := c.XML(xmlResult{\n\t\tNames: []string{\"Grame\", \"John\"},\n\t\tAges:  []int{1, 12, 20},\n\t})\n\tutils.AssertEqual(t, nil, err)\n\tutils.AssertEqual(t, `<Users><Names>Grame</Names><Names>John</Names><Ages>1</Ages><Ages>12</Ages><Ages>20</Ages></Users>`, string(c.Response().Body()))\n\tutils.AssertEqual(t, \"application/xml\", string(c.Response().Header.Peek(\"content-type\")))\n\n\ttestEmpty := func(v interface{}, r string) {\n\t\terr := c.XML(v)\n\t\tutils.AssertEqual(t, nil, err)\n\t\tutils.AssertEqual(t, r, string(c.Response().Body()))\n\t}\n\n\ttestEmpty(nil, \"\")\n\ttestEmpty(\"\", `<string></string>`)\n\ttestEmpty(0, \"<int>0</int>\")\n\ttestEmpty([]int{}, \"\")\n}\n\n// go test -run=^$ -bench=Benchmark_Ctx_XML -benchmem -count=4\nfunc Benchmark_Ctx_XML(b *testing.B) {\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\ttype SomeStruct struct {\n\t\tName string `xml:\"Name\"`\n\t\tAge  uint8  `xml:\"Age\"`\n\t}\n\tdata := SomeStruct{\n\t\tName: \"Grame\",\n\t\tAge:  20,\n\t}\n\tvar err error\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\terr = c.XML(data)\n\t}\n\n\tutils.AssertEqual(b, nil, err)\n\tutils.AssertEqual(b, `<SomeStruct><Name>Grame</Name><Age>20</Age></SomeStruct>`, string(c.Response().Body()))\n}\n\n// go test -run Test_Ctx_Links\nfunc Test_Ctx_Links(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\n\tc.Links()\n\tutils.AssertEqual(t, \"\", string(c.Response().Header.Peek(HeaderLink)))\n\n\tc.Links(\n\t\t\"http://api.example.com/users?page=2\", \"next\",\n\t\t\"http://api.example.com/users?page=5\", \"last\",\n\t)\n\tutils.AssertEqual(t, `<http://api.example.com/users?page=2>; rel=\"next\",<http://api.example.com/users?page=5>; rel=\"last\"`, string(c.Response().Header.Peek(HeaderLink)))\n}\n\n// go test -v  -run=^$ -bench=Benchmark_Ctx_Links -benchmem -count=4\nfunc Benchmark_Ctx_Links(b *testing.B) {\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\tc.Links(\n\t\t\t\"http://api.example.com/users?page=2\", \"next\",\n\t\t\t\"http://api.example.com/users?page=5\", \"last\",\n\t\t)\n\t}\n}\n\n// go test -run Test_Ctx_Location\nfunc Test_Ctx_Location(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tc.Location(\"http://example.com\")\n\tutils.AssertEqual(t, \"http://example.com\", string(c.Response().Header.Peek(HeaderLocation)))\n}\n\n// go test -run Test_Ctx_Next\nfunc Test_Ctx_Next(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tapp.Use(\"/\", func(c *Ctx) error {\n\t\treturn c.Next()\n\t})\n\tapp.Get(\"/test\", func(c *Ctx) error {\n\t\tc.Set(\"X-Next-Result\", \"Works\")\n\t\treturn nil\n\t})\n\tresp, err := app.Test(httptest.NewRequest(MethodGet, \"http://example.com/test\", nil))\n\tutils.AssertEqual(t, nil, err, \"app.Test(req)\")\n\tutils.AssertEqual(t, StatusOK, resp.StatusCode, \"Status code\")\n\tutils.AssertEqual(t, \"Works\", resp.Header.Get(\"X-Next-Result\"))\n}\n\n// go test -run Test_Ctx_Next_Error\nfunc Test_Ctx_Next_Error(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tapp.Use(\"/\", func(c *Ctx) error {\n\t\tc.Set(\"X-Next-Result\", \"Works\")\n\t\treturn ErrNotFound\n\t})\n\n\tresp, err := app.Test(httptest.NewRequest(MethodGet, \"http://example.com/test\", nil))\n\tutils.AssertEqual(t, nil, err, \"app.Test(req)\")\n\tutils.AssertEqual(t, StatusNotFound, resp.StatusCode, \"Status code\")\n\tutils.AssertEqual(t, \"Works\", resp.Header.Get(\"X-Next-Result\"))\n}\n\n// go test -run Test_Ctx_Redirect\nfunc Test_Ctx_Redirect(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\n\terr := c.Redirect(\"http://default.com\")\n\tutils.AssertEqual(t, nil, err)\n\tutils.AssertEqual(t, 302, c.Response().StatusCode())\n\tutils.AssertEqual(t, \"http://default.com\", string(c.Response().Header.Peek(HeaderLocation)))\n\n\terr = c.Redirect(\"http://example.com\", 301)\n\tutils.AssertEqual(t, nil, err)\n\tutils.AssertEqual(t, 301, c.Response().StatusCode())\n\tutils.AssertEqual(t, \"http://example.com\", string(c.Response().Header.Peek(HeaderLocation)))\n}\n\n// go test -run Test_Ctx_RedirectToRouteWithParams\nfunc Test_Ctx_RedirectToRouteWithParams(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tapp.Get(\"/user/:name\", func(c *Ctx) error {\n\t\treturn c.JSON(c.Params(\"name\"))\n\t}).Name(\"user\")\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\n\terr := c.RedirectToRoute(\"user\", Map{\n\t\t\"name\": \"fiber\",\n\t})\n\tutils.AssertEqual(t, nil, err)\n\tutils.AssertEqual(t, 302, c.Response().StatusCode())\n\tutils.AssertEqual(t, \"/user/fiber\", string(c.Response().Header.Peek(HeaderLocation)))\n}\n\n// go test -run Test_Ctx_RedirectToRouteWithParams\nfunc Test_Ctx_RedirectToRouteWithQueries(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tapp.Get(\"/user/:name\", func(c *Ctx) error {\n\t\treturn c.JSON(c.Params(\"name\"))\n\t}).Name(\"user\")\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\n\terr := c.RedirectToRoute(\"user\", Map{\n\t\t\"name\":    \"fiber\",\n\t\t\"queries\": map[string]string{\"data[0][name]\": \"john\", \"data[0][age]\": \"10\", \"test\": \"doe\"},\n\t})\n\tutils.AssertEqual(t, nil, err)\n\tutils.AssertEqual(t, 302, c.Response().StatusCode())\n\t// analysis of query parameters with url parsing, since a map pass is always randomly ordered\n\tlocation, err := url.Parse(string(c.Response().Header.Peek(HeaderLocation)))\n\tutils.AssertEqual(t, nil, err, \"url.Parse(location)\")\n\tutils.AssertEqual(t, \"/user/fiber\", location.Path)\n\tutils.AssertEqual(t, url.Values{\"data[0][name]\": []string{\"john\"}, \"data[0][age]\": []string{\"10\"}, \"test\": []string{\"doe\"}}, location.Query())\n}\n\n// go test -run Test_Ctx_RedirectToRouteWithOptionalParams\nfunc Test_Ctx_RedirectToRouteWithOptionalParams(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tapp.Get(\"/user/:name?\", func(c *Ctx) error {\n\t\treturn c.JSON(c.Params(\"name\"))\n\t}).Name(\"user\")\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\n\terr := c.RedirectToRoute(\"user\", Map{\n\t\t\"name\": \"fiber\",\n\t})\n\tutils.AssertEqual(t, nil, err)\n\tutils.AssertEqual(t, 302, c.Response().StatusCode())\n\tutils.AssertEqual(t, \"/user/fiber\", string(c.Response().Header.Peek(HeaderLocation)))\n}\n\n// go test -run Test_Ctx_RedirectToRouteWithOptionalParamsWithoutValue\nfunc Test_Ctx_RedirectToRouteWithOptionalParamsWithoutValue(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tapp.Get(\"/user/:name?\", func(c *Ctx) error {\n\t\treturn c.JSON(c.Params(\"name\"))\n\t}).Name(\"user\")\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\n\terr := c.RedirectToRoute(\"user\", Map{})\n\tutils.AssertEqual(t, nil, err)\n\tutils.AssertEqual(t, 302, c.Response().StatusCode())\n\tutils.AssertEqual(t, \"/user/\", string(c.Response().Header.Peek(HeaderLocation)))\n}\n\n// go test -run Test_Ctx_RedirectToRouteWithGreedyParameters\nfunc Test_Ctx_RedirectToRouteWithGreedyParameters(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tapp.Get(\"/user/+\", func(c *Ctx) error {\n\t\treturn c.JSON(c.Params(\"+\"))\n\t}).Name(\"user\")\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\n\terr := c.RedirectToRoute(\"user\", Map{\n\t\t\"+\": \"test/routes\",\n\t})\n\tutils.AssertEqual(t, nil, err)\n\tutils.AssertEqual(t, 302, c.Response().StatusCode())\n\tutils.AssertEqual(t, \"/user/test/routes\", string(c.Response().Header.Peek(HeaderLocation)))\n}\n\n// go test -run Test_Ctx_RedirectBack\nfunc Test_Ctx_RedirectBack(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tapp.Get(\"/\", func(c *Ctx) error {\n\t\treturn c.JSON(\"Home\")\n\t}).Name(\"home\")\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\terr := c.RedirectBack(\"/\")\n\tutils.AssertEqual(t, nil, err)\n\tutils.AssertEqual(t, 302, c.Response().StatusCode())\n\tutils.AssertEqual(t, \"/\", string(c.Response().Header.Peek(HeaderLocation)))\n}\n\n// go test -run Test_Ctx_RedirectBackWithReferer\nfunc Test_Ctx_RedirectBackWithReferer(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tapp.Get(\"/\", func(c *Ctx) error {\n\t\treturn c.JSON(\"Home\")\n\t}).Name(\"home\")\n\tapp.Get(\"/back\", func(c *Ctx) error {\n\t\treturn c.JSON(\"Back\")\n\t}).Name(\"back\")\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tc.Request().Header.Set(HeaderReferer, \"/back\")\n\terr := c.RedirectBack(\"/\")\n\tutils.AssertEqual(t, nil, err)\n\tutils.AssertEqual(t, 302, c.Response().StatusCode())\n\tutils.AssertEqual(t, \"/back\", c.Get(HeaderReferer))\n\tutils.AssertEqual(t, \"/back\", string(c.Response().Header.Peek(HeaderLocation)))\n}\n\n// go test -run Test_Ctx_Render\nfunc Test_Ctx_Render(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\terr := c.Render(\"./.github/testdata/index.tmpl\", Map{\n\t\t\"Title\": \"Hello, World!\",\n\t})\n\tutils.AssertEqual(t, nil, err)\n\n\tbuf := bytebufferpool.Get()\n\t_, _ = buf.WriteString(\"overwrite\") //nolint:errcheck // This will never fail\n\tdefer bytebufferpool.Put(buf)\n\n\tutils.AssertEqual(t, \"<h1>Hello, World!</h1>\", string(c.Response().Body()))\n\n\terr = c.Render(\"./.github/testdata/template-non-exists.html\", nil)\n\tutils.AssertEqual(t, false, err == nil)\n\n\terr = c.Render(\"./.github/testdata/template-invalid.html\", nil)\n\tutils.AssertEqual(t, false, err == nil)\n}\n\nfunc Test_Ctx_RenderWithoutLocals(t *testing.T) {\n\tt.Parallel()\n\tapp := New(Config{\n\t\tPassLocalsToViews: false,\n\t})\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\tc.Locals(\"Title\", \"Hello, World!\")\n\tdefer app.ReleaseCtx(c)\n\terr := c.Render(\"./.github/testdata/index.tmpl\", Map{})\n\tutils.AssertEqual(t, nil, err)\n\n\tbuf := bytebufferpool.Get()\n\t_, _ = buf.WriteString(\"overwrite\") //nolint:errcheck // This will never fail\n\tdefer bytebufferpool.Put(buf)\n\n\tutils.AssertEqual(t, \"<h1><no value></h1>\", string(c.Response().Body()))\n}\n\nfunc Test_Ctx_RenderWithLocals(t *testing.T) {\n\tt.Parallel()\n\tapp := New(Config{\n\t\tPassLocalsToViews: true,\n\t})\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\tc.Locals(\"Title\", \"Hello, World!\")\n\tdefer app.ReleaseCtx(c)\n\terr := c.Render(\"./.github/testdata/index.tmpl\", Map{})\n\tutils.AssertEqual(t, nil, err)\n\n\tbuf := bytebufferpool.Get()\n\t_, _ = buf.WriteString(\"overwrite\") //nolint:errcheck // This will never fail\n\tdefer bytebufferpool.Put(buf)\n\n\tutils.AssertEqual(t, \"<h1>Hello, World!</h1>\", string(c.Response().Body()))\n}\n\nfunc Test_Ctx_RenderWithBind(t *testing.T) {\n\tt.Parallel()\n\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\terr := c.Bind(Map{\n\t\t\"Title\": \"Hello, World!\",\n\t})\n\tutils.AssertEqual(t, nil, err)\n\tdefer app.ReleaseCtx(c)\n\terr = c.Render(\"./.github/testdata/index.tmpl\", Map{})\n\tutils.AssertEqual(t, nil, err)\n\n\tbuf := bytebufferpool.Get()\n\t_, _ = buf.WriteString(\"overwrite\") //nolint:errcheck // This will never fail\n\tdefer bytebufferpool.Put(buf)\n\n\tutils.AssertEqual(t, \"<h1>Hello, World!</h1>\", string(c.Response().Body()))\n}\n\nfunc Test_Ctx_RenderWithOverwrittenBind(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\terr := c.Bind(Map{\n\t\t\"Title\": \"Hello, World!\",\n\t})\n\tutils.AssertEqual(t, nil, err)\n\tdefer app.ReleaseCtx(c)\n\terr = c.Render(\"./.github/testdata/index.tmpl\", Map{\n\t\t\"Title\": \"Hello from Fiber!\",\n\t})\n\tutils.AssertEqual(t, nil, err)\n\n\tbuf := bytebufferpool.Get()\n\t_, _ = buf.WriteString(\"overwrite\") //nolint:errcheck // This will never fail\n\tdefer bytebufferpool.Put(buf)\n\n\tutils.AssertEqual(t, \"<h1>Hello from Fiber!</h1>\", string(c.Response().Body()))\n}\n\nfunc Test_Ctx_RenderWithBindLocals(t *testing.T) {\n\tt.Parallel()\n\tapp := New(Config{\n\t\tPassLocalsToViews: true,\n\t})\n\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\terr := c.Bind(Map{\n\t\t\"Title\": \"Hello, World!\",\n\t})\n\tutils.AssertEqual(t, nil, err)\n\n\tc.Locals(\"Summary\", \"Test\")\n\tdefer app.ReleaseCtx(c)\n\n\terr = c.Render(\"./.github/testdata/template.tmpl\", Map{})\n\tutils.AssertEqual(t, nil, err)\n\n\tutils.AssertEqual(t, \"<h1>Hello, World! Test</h1>\", string(c.Response().Body()))\n}\n\nfunc Test_Ctx_RenderWithLocalsAndBinding(t *testing.T) {\n\tt.Parallel()\n\tengine := &testTemplateEngine{}\n\terr := engine.Load()\n\tutils.AssertEqual(t, nil, err)\n\tapp := New(Config{\n\t\tPassLocalsToViews: true,\n\t\tViews:             engine,\n\t})\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\tc.Locals(\"Title\", \"This is a test.\")\n\tdefer app.ReleaseCtx(c)\n\n\terr = c.Render(\"index.tmpl\", Map{\n\t\t\"Title\": \"Hello, World!\",\n\t})\n\tutils.AssertEqual(t, nil, err)\n\n\tutils.AssertEqual(t, \"<h1>Hello, World!</h1>\", string(c.Response().Body()))\n}\n\nfunc Benchmark_Ctx_RenderWithLocalsAndBinding(b *testing.B) {\n\tengine := &testTemplateEngine{}\n\terr := engine.Load()\n\tutils.AssertEqual(b, nil, err)\n\tutils.AssertEqual(b, nil, err)\n\tapp := New(Config{\n\t\tPassLocalsToViews: true,\n\t\tViews:             engine,\n\t})\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\terr = c.Bind(Map{\n\t\t\"Title\": \"Hello, World!\",\n\t})\n\tutils.AssertEqual(b, nil, err)\n\tc.Locals(\"Summary\", \"Test\")\n\n\tdefer app.ReleaseCtx(c)\n\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\n\tfor n := 0; n < b.N; n++ {\n\t\terr = c.Render(\"template.tmpl\", Map{})\n\t}\n\tutils.AssertEqual(b, nil, err)\n\n\tutils.AssertEqual(b, \"<h1>Hello, World! Test</h1>\", string(c.Response().Body()))\n}\n\nfunc Benchmark_Ctx_RedirectToRoute(b *testing.B) {\n\tapp := New()\n\tapp.Get(\"/user/:name\", func(c *Ctx) error {\n\t\treturn c.JSON(c.Params(\"name\"))\n\t}).Name(\"user\")\n\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\n\tvar err error\n\tfor n := 0; n < b.N; n++ {\n\t\terr = c.RedirectToRoute(\"user\", Map{\n\t\t\t\"name\": \"fiber\",\n\t\t})\n\t}\n\tutils.AssertEqual(b, nil, err)\n\n\tutils.AssertEqual(b, 302, c.Response().StatusCode())\n\tutils.AssertEqual(b, \"/user/fiber\", string(c.Response().Header.Peek(HeaderLocation)))\n}\n\nfunc Benchmark_Ctx_RedirectToRouteWithQueries(b *testing.B) {\n\tapp := New()\n\tapp.Get(\"/user/:name\", func(c *Ctx) error {\n\t\treturn c.JSON(c.Params(\"name\"))\n\t}).Name(\"user\")\n\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\n\tvar err error\n\tfor n := 0; n < b.N; n++ {\n\t\terr = c.RedirectToRoute(\"user\", Map{\n\t\t\t\"name\":    \"fiber\",\n\t\t\t\"queries\": map[string]string{\"a\": \"a\", \"b\": \"b\"},\n\t\t})\n\t}\n\tutils.AssertEqual(b, nil, err)\n\n\tutils.AssertEqual(b, 302, c.Response().StatusCode())\n\t// analysis of query parameters with url parsing, since a map pass is always randomly ordered\n\tlocation, err := url.Parse(string(c.Response().Header.Peek(HeaderLocation)))\n\tutils.AssertEqual(b, nil, err, \"url.Parse(location)\")\n\tutils.AssertEqual(b, \"/user/fiber\", location.Path)\n\tutils.AssertEqual(b, url.Values{\"a\": []string{\"a\"}, \"b\": []string{\"b\"}}, location.Query())\n}\n\nfunc Benchmark_Ctx_RenderLocals(b *testing.B) {\n\tengine := &testTemplateEngine{}\n\terr := engine.Load()\n\tutils.AssertEqual(b, nil, err)\n\tapp := New(Config{\n\t\tPassLocalsToViews: true,\n\t})\n\tapp.config.Views = engine\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\tc.Locals(\"Title\", \"Hello, World!\")\n\n\tdefer app.ReleaseCtx(c)\n\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\n\tfor n := 0; n < b.N; n++ {\n\t\terr = c.Render(\"index.tmpl\", Map{})\n\t}\n\tutils.AssertEqual(b, nil, err)\n\n\tutils.AssertEqual(b, \"<h1>Hello, World!</h1>\", string(c.Response().Body()))\n}\n\nfunc Benchmark_Ctx_RenderBind(b *testing.B) {\n\tengine := &testTemplateEngine{}\n\terr := engine.Load()\n\tutils.AssertEqual(b, nil, err)\n\tapp := New()\n\tapp.config.Views = engine\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\terr = c.Bind(Map{\n\t\t\"Title\": \"Hello, World!\",\n\t})\n\tutils.AssertEqual(b, nil, err)\n\n\tdefer app.ReleaseCtx(c)\n\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\n\tfor n := 0; n < b.N; n++ {\n\t\terr = c.Render(\"index.tmpl\", Map{})\n\t}\n\tutils.AssertEqual(b, nil, err)\n\n\tutils.AssertEqual(b, \"<h1>Hello, World!</h1>\", string(c.Response().Body()))\n}\n\n// go test -run Test_Ctx_RestartRouting\nfunc Test_Ctx_RestartRouting(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tcalls := 0\n\tapp.Get(\"/\", func(c *Ctx) error {\n\t\tcalls++\n\t\tif calls < 3 {\n\t\t\treturn c.RestartRouting()\n\t\t}\n\t\treturn nil\n\t})\n\tresp, err := app.Test(httptest.NewRequest(MethodGet, \"http://example.com/\", nil))\n\tutils.AssertEqual(t, nil, err, \"app.Test(req)\")\n\tutils.AssertEqual(t, StatusOK, resp.StatusCode, \"Status code\")\n\tutils.AssertEqual(t, 3, calls, \"Number of calls\")\n}\n\n// go test -run Test_Ctx_RestartRoutingWithChangedPath\nfunc Test_Ctx_RestartRoutingWithChangedPath(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tvar executedOldHandler, executedNewHandler bool\n\n\tapp.Get(\"/old\", func(c *Ctx) error {\n\t\tc.Path(\"/new\")\n\t\treturn c.RestartRouting()\n\t})\n\tapp.Get(\"/old\", func(c *Ctx) error {\n\t\texecutedOldHandler = true\n\t\treturn nil\n\t})\n\tapp.Get(\"/new\", func(c *Ctx) error {\n\t\texecutedNewHandler = true\n\t\treturn nil\n\t})\n\n\tresp, err := app.Test(httptest.NewRequest(MethodGet, \"http://example.com/old\", nil))\n\tutils.AssertEqual(t, nil, err, \"app.Test(req)\")\n\tutils.AssertEqual(t, StatusOK, resp.StatusCode, \"Status code\")\n\tutils.AssertEqual(t, false, executedOldHandler, \"Executed old handler\")\n\tutils.AssertEqual(t, true, executedNewHandler, \"Executed new handler\")\n}\n\n// go test -run Test_Ctx_RestartRoutingWithChangedPathAnd404\nfunc Test_Ctx_RestartRoutingWithChangedPathAndCatchAll(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tapp.Get(\"/new\", func(c *Ctx) error {\n\t\treturn nil\n\t})\n\tapp.Use(func(c *Ctx) error {\n\t\tc.Path(\"/new\")\n\t\t// c.Next() would fail this test as a 404 is returned from the next handler\n\t\treturn c.RestartRouting()\n\t})\n\tapp.Use(func(c *Ctx) error {\n\t\treturn ErrNotFound\n\t})\n\n\tresp, err := app.Test(httptest.NewRequest(MethodGet, \"http://example.com/old\", nil))\n\tutils.AssertEqual(t, nil, err, \"app.Test(req)\")\n\tutils.AssertEqual(t, StatusOK, resp.StatusCode, \"Status code\")\n}\n\ntype testTemplateEngine struct {\n\ttemplates *template.Template\n\tpath      string\n}\n\nfunc (t *testTemplateEngine) Render(w io.Writer, name string, bind interface{}, layout ...string) error {\n\tif len(layout) == 0 {\n\t\tif err := t.templates.ExecuteTemplate(w, name, bind); err != nil {\n\t\t\treturn fmt.Errorf(\"failed to execute template without layout: %w\", err)\n\t\t}\n\t\treturn nil\n\t}\n\tif err := t.templates.ExecuteTemplate(w, name, bind); err != nil {\n\t\treturn fmt.Errorf(\"failed to execute template: %w\", err)\n\t}\n\tif err := t.templates.ExecuteTemplate(w, layout[0], bind); err != nil {\n\t\treturn fmt.Errorf(\"failed to execute template with layout: %w\", err)\n\t}\n\treturn nil\n}\n\nfunc (t *testTemplateEngine) Load() error {\n\tif t.path == \"\" {\n\t\tt.path = \"testdata\"\n\t}\n\tt.templates = template.Must(template.ParseGlob(\"./.github/\" + t.path + \"/*.tmpl\"))\n\treturn nil\n}\n\n// go test -run Test_Ctx_Render_Engine\nfunc Test_Ctx_Render_Engine(t *testing.T) {\n\tt.Parallel()\n\tengine := &testTemplateEngine{}\n\tutils.AssertEqual(t, nil, engine.Load())\n\tapp := New()\n\tapp.config.Views = engine\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\terr := c.Render(\"index.tmpl\", Map{\n\t\t\"Title\": \"Hello, World!\",\n\t})\n\tutils.AssertEqual(t, nil, err)\n\tutils.AssertEqual(t, \"<h1>Hello, World!</h1>\", string(c.Response().Body()))\n}\n\n// go test -run Test_Ctx_Render_Engine_With_View_Layout\nfunc Test_Ctx_Render_Engine_With_View_Layout(t *testing.T) {\n\tt.Parallel()\n\tengine := &testTemplateEngine{}\n\tutils.AssertEqual(t, nil, engine.Load())\n\tapp := New(Config{ViewsLayout: \"main.tmpl\"})\n\tapp.config.Views = engine\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\terr := c.Render(\"index.tmpl\", Map{\n\t\t\"Title\": \"Hello, World!\",\n\t})\n\tutils.AssertEqual(t, nil, err)\n\tutils.AssertEqual(t, \"<h1>Hello, World!</h1><h1>I'm main</h1>\", string(c.Response().Body()))\n}\n\n// go test -v -run=^$ -bench=Benchmark_Ctx_Render_Engine -benchmem -count=4\nfunc Benchmark_Ctx_Render_Engine(b *testing.B) {\n\tengine := &testTemplateEngine{}\n\terr := engine.Load()\n\tutils.AssertEqual(b, nil, err)\n\tapp := New()\n\tapp.config.Views = engine\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\terr = c.Render(\"index.tmpl\", Map{\n\t\t\t\"Title\": \"Hello, World!\",\n\t\t})\n\t}\n\tutils.AssertEqual(b, nil, err)\n\tutils.AssertEqual(b, \"<h1>Hello, World!</h1>\", string(c.Response().Body()))\n}\n\n// go test -v -run=^$ -bench=Benchmark_Ctx_Get_Location_From_Route -benchmem -count=4\nfunc Benchmark_Ctx_Get_Location_From_Route(b *testing.B) {\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tapp.Get(\"/user/:name\", func(c *Ctx) error {\n\t\treturn c.SendString(c.Params(\"name\"))\n\t}).Name(\"User\")\n\n\tvar err error\n\tvar location string\n\tfor n := 0; n < b.N; n++ {\n\t\tlocation, err = c.getLocationFromRoute(app.GetRoute(\"User\"), Map{\"name\": \"fiber\"})\n\t}\n\tutils.AssertEqual(b, \"/user/fiber\", location)\n\tutils.AssertEqual(b, nil, err)\n}\n\n// go test -run Test_Ctx_Get_Location_From_Route_name\nfunc Test_Ctx_Get_Location_From_Route_name(t *testing.T) {\n\tt.Parallel()\n\n\tt.Run(\"case insensitive\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tapp := New()\n\t\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\t\tdefer app.ReleaseCtx(c)\n\t\tapp.Get(\"/user/:name\", func(c *Ctx) error {\n\t\t\treturn c.SendString(c.Params(\"name\"))\n\t\t}).Name(\"User\")\n\n\t\tlocation, err := c.GetRouteURL(\"User\", Map{\"name\": \"fiber\"})\n\t\tutils.AssertEqual(t, nil, err)\n\t\tutils.AssertEqual(t, \"/user/fiber\", location)\n\n\t\tlocation, err = c.GetRouteURL(\"User\", Map{\"Name\": \"fiber\"})\n\t\tutils.AssertEqual(t, nil, err)\n\t\tutils.AssertEqual(t, \"/user/fiber\", location)\n\t})\n\n\tt.Run(\"case sensitive\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tapp := New(Config{CaseSensitive: true})\n\t\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\t\tdefer app.ReleaseCtx(c)\n\t\tapp.Get(\"/user/:name\", func(c *Ctx) error {\n\t\t\treturn c.SendString(c.Params(\"name\"))\n\t\t}).Name(\"User\")\n\n\t\tlocation, err := c.GetRouteURL(\"User\", Map{\"name\": \"fiber\"})\n\t\tutils.AssertEqual(t, nil, err)\n\t\tutils.AssertEqual(t, \"/user/fiber\", location)\n\n\t\tlocation, err = c.GetRouteURL(\"User\", Map{\"Name\": \"fiber\"})\n\t\tutils.AssertEqual(t, nil, err)\n\t\tutils.AssertEqual(t, \"/user/\", location)\n\t})\n}\n\n// go test -run Test_Ctx_Get_Location_From_Route_name_Optional_greedy\nfunc Test_Ctx_Get_Location_From_Route_name_Optional_greedy(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tapp.Get(\"/:phone/*/send/*\", func(c *Ctx) error {\n\t\treturn c.SendString(\"Phone: \" + c.Params(\"phone\") + \"\\nFirst Param: \" + c.Params(\"*1\") + \"\\nSecond Param: \" + c.Params(\"*2\"))\n\t}).Name(\"SendSms\")\n\n\tlocation, err := c.GetRouteURL(\"SendSms\", Map{\n\t\t\"phone\": \"23456789\",\n\t\t\"*1\":    \"sms\",\n\t\t\"*2\":    \"test-msg\",\n\t})\n\tutils.AssertEqual(t, nil, err)\n\tutils.AssertEqual(t, \"/23456789/sms/send/test-msg\", location)\n}\n\n// go test -run Test_Ctx_Get_Location_From_Route_name_Optional_greedy_one_param\nfunc Test_Ctx_Get_Location_From_Route_name_Optional_greedy_one_param(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tapp.Get(\"/:phone/*/send\", func(c *Ctx) error {\n\t\treturn c.SendString(\"Phone: \" + c.Params(\"phone\") + \"\\nFirst Param: \" + c.Params(\"*1\"))\n\t}).Name(\"SendSms\")\n\n\tlocation, err := c.GetRouteURL(\"SendSms\", Map{\n\t\t\"phone\": \"23456789\",\n\t\t\"*\":     \"sms\",\n\t})\n\tutils.AssertEqual(t, nil, err)\n\tutils.AssertEqual(t, \"/23456789/sms/send\", location)\n}\n\ntype errorTemplateEngine struct{}\n\nfunc (errorTemplateEngine) Render(_ io.Writer, _ string, _ interface{}, _ ...string) error {\n\treturn errors.New(\"errorTemplateEngine\")\n}\n\nfunc (errorTemplateEngine) Load() error { return nil }\n\n// go test -run Test_Ctx_Render_Engine_Error\nfunc Test_Ctx_Render_Engine_Error(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tapp.config.Views = errorTemplateEngine{}\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\terr := c.Render(\"index.tmpl\", nil)\n\tutils.AssertEqual(t, false, err == nil)\n}\n\n// go test -run Test_Ctx_Render_Go_Template\nfunc Test_Ctx_Render_Go_Template(t *testing.T) {\n\tt.Parallel()\n\tfile, err := os.CreateTemp(os.TempDir(), \"fiber\")\n\tutils.AssertEqual(t, nil, err)\n\tdefer func() {\n\t\terr := os.Remove(file.Name())\n\t\tutils.AssertEqual(t, nil, err)\n\t}()\n\n\t_, err = file.Write([]byte(\"template\"))\n\tutils.AssertEqual(t, nil, err)\n\n\terr = file.Close()\n\tutils.AssertEqual(t, nil, err)\n\n\tapp := New()\n\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\n\terr = c.Render(file.Name(), nil)\n\tutils.AssertEqual(t, nil, err)\n\tutils.AssertEqual(t, \"template\", string(c.Response().Body()))\n}\n\n// go test -run Test_Ctx_Send\nfunc Test_Ctx_Send(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tutils.AssertEqual(t, nil, c.Send([]byte(\"Hello, World\")))\n\tutils.AssertEqual(t, nil, c.Send([]byte(\"Don't crash please\")))\n\tutils.AssertEqual(t, nil, c.Send([]byte(\"1337\")))\n\tutils.AssertEqual(t, \"1337\", string(c.Response().Body()))\n}\n\n// go test -v  -run=^$ -bench=Benchmark_Ctx_Send -benchmem -count=4\nfunc Benchmark_Ctx_Send(b *testing.B) {\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tbyt := []byte(\"Hello, World!\")\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\n\tvar err error\n\tfor n := 0; n < b.N; n++ {\n\t\terr = c.Send(byt)\n\t}\n\tutils.AssertEqual(b, nil, err)\n\tutils.AssertEqual(b, \"Hello, World!\", string(c.Response().Body()))\n}\n\n// go test -run Test_Ctx_SendStatus\nfunc Test_Ctx_SendStatus(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\terr := c.SendStatus(415)\n\tutils.AssertEqual(t, nil, err)\n\tutils.AssertEqual(t, 415, c.Response().StatusCode())\n\tutils.AssertEqual(t, \"Unsupported Media Type\", string(c.Response().Body()))\n}\n\n// go test -run Test_Ctx_SendString\nfunc Test_Ctx_SendString(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\terr := c.SendString(\"Don't crash please\")\n\tutils.AssertEqual(t, nil, err)\n\tutils.AssertEqual(t, \"Don't crash please\", string(c.Response().Body()))\n}\n\n// go test -run Test_Ctx_SendStream\nfunc Test_Ctx_SendStream(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\n\terr := c.SendStream(bytes.NewReader([]byte(\"Don't crash please\")))\n\tutils.AssertEqual(t, nil, err)\n\tutils.AssertEqual(t, \"Don't crash please\", string(c.Response().Body()))\n\n\terr = c.SendStream(bytes.NewReader([]byte(\"Don't crash please\")), len([]byte(\"Don't crash please\")))\n\tutils.AssertEqual(t, nil, err)\n\tutils.AssertEqual(t, \"Don't crash please\", string(c.Response().Body()))\n\n\terr = c.SendStream(bufio.NewReader(bytes.NewReader([]byte(\"Hello bufio\"))))\n\tutils.AssertEqual(t, nil, err)\n\tutils.AssertEqual(t, \"Hello bufio\", string(c.Response().Body()))\n}\n\n// go test -run Test_Ctx_Set\nfunc Test_Ctx_Set(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tc.Set(\"X-1\", \"1\")\n\tc.Set(\"X-2\", \"2\")\n\tc.Set(\"X-3\", \"3\")\n\tc.Set(\"X-3\", \"1337\")\n\tutils.AssertEqual(t, \"1\", string(c.Response().Header.Peek(\"x-1\")))\n\tutils.AssertEqual(t, \"2\", string(c.Response().Header.Peek(\"x-2\")))\n\tutils.AssertEqual(t, \"1337\", string(c.Response().Header.Peek(\"x-3\")))\n}\n\n// go test -run Test_Ctx_Set_Splitter\nfunc Test_Ctx_Set_Splitter(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\n\tc.Set(\"Location\", \"foo\\r\\nSet-Cookie:%20SESSIONID=MaliciousValue\\r\\n\")\n\th := string(c.Response().Header.Peek(\"Location\"))\n\tutils.AssertEqual(t, false, strings.Contains(h, \"\\r\\n\"), h)\n\n\tc.Set(\"Location\", \"foo\\nSet-Cookie:%20SESSIONID=MaliciousValue\\n\")\n\th = string(c.Response().Header.Peek(\"Location\"))\n\tutils.AssertEqual(t, false, strings.Contains(h, \"\\n\"), h)\n}\n\n// go test -v  -run=^$ -bench=Benchmark_Ctx_Set -benchmem -count=4\nfunc Benchmark_Ctx_Set(b *testing.B) {\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tval := \"1431-15132-3423\"\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\tc.Set(HeaderXRequestID, val)\n\t}\n}\n\n// go test -run Test_Ctx_Status\nfunc Test_Ctx_Status(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tc.Status(400)\n\tutils.AssertEqual(t, 400, c.Response().StatusCode())\n\terr := c.Status(415).Send([]byte(\"Hello, World\"))\n\tutils.AssertEqual(t, nil, err)\n\tutils.AssertEqual(t, 415, c.Response().StatusCode())\n\tutils.AssertEqual(t, \"Hello, World\", string(c.Response().Body()))\n}\n\n// go test -run Test_Ctx_Type\nfunc Test_Ctx_Type(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tc.Type(\".json\")\n\tutils.AssertEqual(t, \"application/json\", string(c.Response().Header.Peek(\"Content-Type\")))\n\n\tc.Type(\"json\", \"utf-8\")\n\tutils.AssertEqual(t, \"application/json; charset=utf-8\", string(c.Response().Header.Peek(\"Content-Type\")))\n\n\tc.Type(\".html\")\n\tutils.AssertEqual(t, \"text/html\", string(c.Response().Header.Peek(\"Content-Type\")))\n\n\tc.Type(\"html\", \"utf-8\")\n\tutils.AssertEqual(t, \"text/html; charset=utf-8\", string(c.Response().Header.Peek(\"Content-Type\")))\n}\n\n// go test -v  -run=^$ -bench=Benchmark_Ctx_Type -benchmem -count=4\nfunc Benchmark_Ctx_Type(b *testing.B) {\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\tc.Type(\".json\")\n\t\tc.Type(\"json\")\n\t}\n}\n\n// go test -v  -run=^$ -bench=Benchmark_Ctx_Type_Charset -benchmem -count=4\nfunc Benchmark_Ctx_Type_Charset(b *testing.B) {\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\tc.Type(\".json\", \"utf-8\")\n\t\tc.Type(\"json\", \"utf-8\")\n\t}\n}\n\n// go test -run Test_Ctx_Vary\nfunc Test_Ctx_Vary(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tc.Vary(\"Origin\")\n\tc.Vary(\"User-Agent\")\n\tc.Vary(\"Accept-Encoding\", \"Accept\")\n\tutils.AssertEqual(t, \"Origin, User-Agent, Accept-Encoding, Accept\", string(c.Response().Header.Peek(\"Vary\")))\n}\n\n// go test -v  -run=^$ -bench=Benchmark_Ctx_Vary -benchmem -count=4\nfunc Benchmark_Ctx_Vary(b *testing.B) {\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\tc.Vary(\"Origin\", \"User-Agent\")\n\t}\n}\n\n// go test -run Test_Ctx_Write\nfunc Test_Ctx_Write(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\t_, err := c.Write([]byte(\"Hello, \"))\n\tutils.AssertEqual(t, nil, err)\n\t_, err = c.Write([]byte(\"World!\"))\n\tutils.AssertEqual(t, nil, err)\n\tutils.AssertEqual(t, \"Hello, World!\", string(c.Response().Body()))\n}\n\n// go test -v -run=^$ -bench=Benchmark_Ctx_Write -benchmem -count=4\nfunc Benchmark_Ctx_Write(b *testing.B) {\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tbyt := []byte(\"Hello, World!\")\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\n\tvar err error\n\tfor n := 0; n < b.N; n++ {\n\t\t_, err = c.Write(byt)\n\t}\n\tutils.AssertEqual(b, nil, err)\n}\n\n// go test -run Test_Ctx_Writef\nfunc Test_Ctx_Writef(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tworld := \"World!\"\n\t_, err := c.Writef(\"Hello, %s\", world)\n\tutils.AssertEqual(t, nil, err)\n\tutils.AssertEqual(t, \"Hello, World!\", string(c.Response().Body()))\n}\n\n// go test -v -run=^$ -bench=Benchmark_Ctx_Writef -benchmem -count=4\nfunc Benchmark_Ctx_Writef(b *testing.B) {\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tworld := \"World!\"\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\n\tvar err error\n\tfor n := 0; n < b.N; n++ {\n\t\t_, err = c.Writef(\"Hello, %s\", world)\n\t}\n\tutils.AssertEqual(b, nil, err)\n}\n\n// go test -run Test_Ctx_WriteString\nfunc Test_Ctx_WriteString(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\t_, err := c.WriteString(\"Hello, \")\n\tutils.AssertEqual(t, nil, err)\n\t_, err = c.WriteString(\"World!\")\n\tutils.AssertEqual(t, nil, err)\n\tutils.AssertEqual(t, \"Hello, World!\", string(c.Response().Body()))\n}\n\n// go test -run Test_Ctx_XHR\nfunc Test_Ctx_XHR(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tc.Request().Header.Set(HeaderXRequestedWith, \"XMLHttpRequest\")\n\tutils.AssertEqual(t, true, c.XHR())\n}\n\n// go test -run=^$ -bench=Benchmark_Ctx_XHR -benchmem -count=4\nfunc Benchmark_Ctx_XHR(b *testing.B) {\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tc.Request().Header.Set(HeaderXRequestedWith, \"XMLHttpRequest\")\n\tvar equal bool\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\tequal = c.XHR()\n\t}\n\tutils.AssertEqual(b, true, equal)\n}\n\n// go test -v  -run=^$ -bench=Benchmark_Ctx_SendString_B -benchmem -count=4\nfunc Benchmark_Ctx_SendString_B(b *testing.B) {\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tbody := \"Hello, world!\"\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\n\tvar err error\n\tfor n := 0; n < b.N; n++ {\n\t\terr = c.SendString(body)\n\t}\n\tutils.AssertEqual(b, nil, err)\n\tutils.AssertEqual(b, []byte(\"Hello, world!\"), c.Response().Body())\n}\n\n// go test -run Test_Ctx_Queries -v\nfunc Test_Ctx_Queries(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\n\tc.Request().SetBody([]byte(``))\n\tc.Request().Header.SetContentType(\"\")\n\tc.Request().URI().SetQueryString(\"id=1&name=tom&hobby=basketball,football&favouriteDrinks=milo,coke,pepsi&alloc=&no=1&field1=value1&field1=value2&field2=value3&list_a=1&list_a=2&list_a=3&list_b[]=1&list_b[]=2&list_b[]=3&list_c=1,2,3\")\n\n\tqueries := c.Queries()\n\tutils.AssertEqual(t, \"1\", queries[\"id\"])\n\tutils.AssertEqual(t, \"tom\", queries[\"name\"])\n\tutils.AssertEqual(t, \"basketball,football\", queries[\"hobby\"])\n\tutils.AssertEqual(t, \"milo,coke,pepsi\", queries[\"favouriteDrinks\"])\n\tutils.AssertEqual(t, \"\", queries[\"alloc\"])\n\tutils.AssertEqual(t, \"1\", queries[\"no\"])\n\tutils.AssertEqual(t, \"value2\", queries[\"field1\"])\n\tutils.AssertEqual(t, \"value3\", queries[\"field2\"])\n\tutils.AssertEqual(t, \"3\", queries[\"list_a\"])\n\tutils.AssertEqual(t, \"3\", queries[\"list_b[]\"])\n\tutils.AssertEqual(t, \"1,2,3\", queries[\"list_c\"])\n\n\tc.Request().URI().SetQueryString(\"filters.author.name=John&filters.category.name=Technology&filters[customer][name]=Alice&filters[status]=pending\")\n\n\tqueries = c.Queries()\n\tutils.AssertEqual(t, \"John\", queries[\"filters.author.name\"])\n\tutils.AssertEqual(t, \"Technology\", queries[\"filters.category.name\"])\n\tutils.AssertEqual(t, \"Alice\", queries[\"filters[customer][name]\"])\n\tutils.AssertEqual(t, \"pending\", queries[\"filters[status]\"])\n\n\tc.Request().URI().SetQueryString(\"tags=apple,orange,banana&filters[tags]=apple,orange,banana&filters[category][name]=fruits&filters.tags=apple,orange,banana&filters.category.name=fruits\")\n\n\tqueries = c.Queries()\n\tutils.AssertEqual(t, \"apple,orange,banana\", queries[\"tags\"])\n\tutils.AssertEqual(t, \"apple,orange,banana\", queries[\"filters[tags]\"])\n\tutils.AssertEqual(t, \"fruits\", queries[\"filters[category][name]\"])\n\tutils.AssertEqual(t, \"apple,orange,banana\", queries[\"filters.tags\"])\n\tutils.AssertEqual(t, \"fruits\", queries[\"filters.category.name\"])\n\n\tc.Request().URI().SetQueryString(\"filters[tags][0]=apple&filters[tags][1]=orange&filters[tags][2]=banana&filters[category][name]=fruits\")\n\n\tqueries = c.Queries()\n\tutils.AssertEqual(t, \"apple\", queries[\"filters[tags][0]\"])\n\tutils.AssertEqual(t, \"orange\", queries[\"filters[tags][1]\"])\n\tutils.AssertEqual(t, \"banana\", queries[\"filters[tags][2]\"])\n\tutils.AssertEqual(t, \"fruits\", queries[\"filters[category][name]\"])\n}\n\n// go test -v  -run=^$ -bench=Benchmark_Ctx_Queries -benchmem -count=4\nfunc Benchmark_Ctx_Queries(b *testing.B) {\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tc.Request().URI().SetQueryString(\"id=1&name=tom&hobby=basketball,football&favouriteDrinks=milo,coke,pepsi&alloc=&no=1\")\n\n\tvar queries map[string]string\n\tfor n := 0; n < b.N; n++ {\n\t\tqueries = c.Queries()\n\t}\n\n\tutils.AssertEqual(b, \"1\", queries[\"id\"])\n\tutils.AssertEqual(b, \"tom\", queries[\"name\"])\n\tutils.AssertEqual(b, \"basketball,football\", queries[\"hobby\"])\n\tutils.AssertEqual(b, \"milo,coke,pepsi\", queries[\"favouriteDrinks\"])\n\tutils.AssertEqual(b, \"\", queries[\"alloc\"])\n\tutils.AssertEqual(b, \"1\", queries[\"no\"])\n}\n\n// go test -run Test_Ctx_QueryParser -v\nfunc Test_Ctx_QueryParser(t *testing.T) {\n\tt.Parallel()\n\tapp := New(Config{EnableSplittingOnParsers: true})\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\ttype Query struct {\n\t\tID    int\n\t\tName  string\n\t\tHobby []string\n\t}\n\tc.Request().SetBody([]byte(``))\n\tc.Request().Header.SetContentType(\"\")\n\tc.Request().URI().SetQueryString(\"id=1&name=tom&hobby=basketball&hobby=football\")\n\tq := new(Query)\n\tutils.AssertEqual(t, nil, c.QueryParser(q))\n\tutils.AssertEqual(t, 2, len(q.Hobby))\n\n\tc.Request().URI().SetQueryString(\"id=1&name=tom&hobby=basketball,football\")\n\tq = new(Query)\n\tutils.AssertEqual(t, nil, c.QueryParser(q))\n\tutils.AssertEqual(t, 2, len(q.Hobby))\n\n\tc.Request().URI().SetQueryString(\"id=1&name=tom&hobby=scoccer&hobby=basketball,football\")\n\tq = new(Query)\n\tutils.AssertEqual(t, nil, c.QueryParser(q))\n\tutils.AssertEqual(t, 3, len(q.Hobby))\n\n\tempty := new(Query)\n\tc.Request().URI().SetQueryString(\"\")\n\tutils.AssertEqual(t, nil, c.QueryParser(empty))\n\tutils.AssertEqual(t, 0, len(empty.Hobby))\n\n\ttype Query2 struct {\n\t\tBool            bool\n\t\tID              int\n\t\tName            string\n\t\tHobby           string\n\t\tFavouriteDrinks []string\n\t\tEmpty           []string\n\t\tAlloc           []string\n\t\tNo              []int64\n\t}\n\n\tc.Request().URI().SetQueryString(\"id=1&name=tom&hobby=basketball,football&favouriteDrinks=milo,coke,pepsi&alloc=&no=1\")\n\tq2 := new(Query2)\n\tq2.Bool = true\n\tq2.Name = \"hello world\"\n\tutils.AssertEqual(t, nil, c.QueryParser(q2))\n\tutils.AssertEqual(t, \"basketball,football\", q2.Hobby)\n\tutils.AssertEqual(t, true, q2.Bool)\n\tutils.AssertEqual(t, \"tom\", q2.Name) // check value get overwritten\n\tutils.AssertEqual(t, []string{\"milo\", \"coke\", \"pepsi\"}, q2.FavouriteDrinks)\n\tvar nilSlice []string\n\tutils.AssertEqual(t, nilSlice, q2.Empty)\n\tutils.AssertEqual(t, []string{\"\"}, q2.Alloc)\n\tutils.AssertEqual(t, []int64{1}, q2.No)\n\n\ttype RequiredQuery struct {\n\t\tName string `query:\"name,required\"`\n\t}\n\trq := new(RequiredQuery)\n\tc.Request().URI().SetQueryString(\"\")\n\tutils.AssertEqual(t, \"failed to decode: name is empty\", c.QueryParser(rq).Error())\n\n\ttype ArrayQuery struct {\n\t\tData []string\n\t}\n\taq := new(ArrayQuery)\n\tc.Request().URI().SetQueryString(\"data[]=john&data[]=doe\")\n\tutils.AssertEqual(t, nil, c.QueryParser(aq))\n\tutils.AssertEqual(t, 2, len(aq.Data))\n}\n\n// go test -run Test_Ctx_QueryParser -v\nfunc Test_Ctx_QueryParser_WithoutSplitting(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\ttype Query struct {\n\t\tID    int\n\t\tName  string\n\t\tHobby []string\n\t}\n\n\tc.Request().URI().SetQueryString(\"id=1&name=tom&hobby=basketball,football\")\n\tq := new(Query)\n\tutils.AssertEqual(t, nil, c.QueryParser(q))\n\tutils.AssertEqual(t, 1, len(q.Hobby))\n\n\tc.Request().URI().SetQueryString(\"id=1&name=tom&hobby=scoccer&hobby=basketball,football\")\n\tq = new(Query)\n\tutils.AssertEqual(t, nil, c.QueryParser(q))\n\tutils.AssertEqual(t, 2, len(q.Hobby))\n}\n\n// go test -run Test_Ctx_QueryParser_WithSetParserDecoder -v\nfunc Test_Ctx_QueryParser_WithSetParserDecoder(t *testing.T) {\n\tt.Parallel()\n\ttype NonRFCTime time.Time\n\n\tnonRFCConverter := func(value string) reflect.Value {\n\t\tif v, err := time.Parse(\"2006-01-02\", value); err == nil {\n\t\t\treturn reflect.ValueOf(v)\n\t\t}\n\t\treturn reflect.Value{}\n\t}\n\n\tnonRFCTime := ParserType{\n\t\tCustomtype: NonRFCTime{},\n\t\tConverter:  nonRFCConverter,\n\t}\n\n\tSetParserDecoder(ParserConfig{\n\t\tIgnoreUnknownKeys: true,\n\t\tParserType:        []ParserType{nonRFCTime},\n\t\tZeroEmpty:         true,\n\t\tSetAliasTag:       \"query\",\n\t})\n\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\n\ttype NonRFCTimeInput struct {\n\t\tDate  NonRFCTime `query:\"date\"`\n\t\tTitle string     `query:\"title\"`\n\t\tBody  string     `query:\"body\"`\n\t}\n\n\tc.Request().SetBody([]byte(``))\n\tc.Request().Header.SetContentType(\"\")\n\tq := new(NonRFCTimeInput)\n\n\tc.Request().URI().SetQueryString(\"date=2021-04-10&title=CustomDateTest&Body=October\")\n\tutils.AssertEqual(t, nil, c.QueryParser(q))\n\tutils.AssertEqual(t, \"CustomDateTest\", q.Title)\n\tdate := fmt.Sprintf(\"%v\", q.Date)\n\tutils.AssertEqual(t, \"{0 63753609600 <nil>}\", date)\n\tutils.AssertEqual(t, \"October\", q.Body)\n\n\tc.Request().URI().SetQueryString(\"date=2021-04-10&title&Body=October\")\n\tq = &NonRFCTimeInput{\n\t\tTitle: \"Existing title\",\n\t\tBody:  \"Existing Body\",\n\t}\n\tutils.AssertEqual(t, nil, c.QueryParser(q))\n\tutils.AssertEqual(t, \"\", q.Title)\n}\n\n// go test -run Test_Ctx_QueryParser_Schema -v\nfunc Test_Ctx_QueryParser_Schema(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\ttype Query1 struct {\n\t\tName   string `query:\"name,required\"`\n\t\tNested struct {\n\t\t\tAge int `query:\"age\"`\n\t\t} `query:\"nested,required\"`\n\t}\n\tc.Request().SetBody([]byte(``))\n\tc.Request().Header.SetContentType(\"\")\n\tc.Request().URI().SetQueryString(\"name=tom&nested.age=10\")\n\tq := new(Query1)\n\tutils.AssertEqual(t, nil, c.QueryParser(q))\n\n\tc.Request().URI().SetQueryString(\"namex=tom&nested.age=10\")\n\tq = new(Query1)\n\tutils.AssertEqual(t, \"failed to decode: name is empty\", c.QueryParser(q).Error())\n\n\tc.Request().URI().SetQueryString(\"name=tom&nested.agex=10\")\n\tq = new(Query1)\n\tutils.AssertEqual(t, nil, c.QueryParser(q))\n\n\tc.Request().URI().SetQueryString(\"name=tom&test.age=10\")\n\tq = new(Query1)\n\tutils.AssertEqual(t, \"failed to decode: nested is empty\", c.QueryParser(q).Error())\n\n\ttype Query2 struct {\n\t\tName   string `query:\"name\"`\n\t\tNested struct {\n\t\t\tAge int `query:\"age,required\"`\n\t\t} `query:\"nested\"`\n\t}\n\tc.Request().URI().SetQueryString(\"name=tom&nested.age=10\")\n\tq2 := new(Query2)\n\tutils.AssertEqual(t, nil, c.QueryParser(q2))\n\n\tc.Request().URI().SetQueryString(\"nested.age=10\")\n\tq2 = new(Query2)\n\tutils.AssertEqual(t, nil, c.QueryParser(q2))\n\n\tc.Request().URI().SetQueryString(\"nested.agex=10\")\n\tq2 = new(Query2)\n\tutils.AssertEqual(t, \"failed to decode: nested.age is empty\", c.QueryParser(q2).Error())\n\n\tc.Request().URI().SetQueryString(\"nested.agex=10\")\n\tq2 = new(Query2)\n\tutils.AssertEqual(t, \"failed to decode: nested.age is empty\", c.QueryParser(q2).Error())\n\n\ttype Node struct {\n\t\tValue int   `query:\"val,required\"`\n\t\tNext  *Node `query:\"next,required\"`\n\t}\n\tc.Request().URI().SetQueryString(\"val=1&next.val=3\")\n\tn := new(Node)\n\tutils.AssertEqual(t, nil, c.QueryParser(n))\n\tutils.AssertEqual(t, 1, n.Value)\n\tutils.AssertEqual(t, 3, n.Next.Value)\n\n\tc.Request().URI().SetQueryString(\"next.val=2\")\n\tn = new(Node)\n\tutils.AssertEqual(t, \"failed to decode: val is empty\", c.QueryParser(n).Error())\n\n\tc.Request().URI().SetQueryString(\"val=3&next.value=2\")\n\tn = new(Node)\n\tn.Next = new(Node)\n\tutils.AssertEqual(t, nil, c.QueryParser(n))\n\tutils.AssertEqual(t, 3, n.Value)\n\tutils.AssertEqual(t, 0, n.Next.Value)\n\n\ttype Person struct {\n\t\tName string `query:\"name\"`\n\t\tAge  int    `query:\"age\"`\n\t}\n\n\ttype CollectionQuery struct {\n\t\tData []Person `query:\"data\"`\n\t}\n\n\tc.Request().URI().SetQueryString(\"data[0][name]=john&data[0][age]=10&data[1][name]=doe&data[1][age]=12\")\n\tcq := new(CollectionQuery)\n\tutils.AssertEqual(t, nil, c.QueryParser(cq))\n\tutils.AssertEqual(t, 2, len(cq.Data))\n\tutils.AssertEqual(t, \"john\", cq.Data[0].Name)\n\tutils.AssertEqual(t, 10, cq.Data[0].Age)\n\tutils.AssertEqual(t, \"doe\", cq.Data[1].Name)\n\tutils.AssertEqual(t, 12, cq.Data[1].Age)\n\n\tc.Request().URI().SetQueryString(\"data.0.name=john&data.0.age=10&data.1.name=doe&data.1.age=12\")\n\tcq = new(CollectionQuery)\n\tutils.AssertEqual(t, nil, c.QueryParser(cq))\n\tutils.AssertEqual(t, 2, len(cq.Data))\n\tutils.AssertEqual(t, \"john\", cq.Data[0].Name)\n\tutils.AssertEqual(t, 10, cq.Data[0].Age)\n\tutils.AssertEqual(t, \"doe\", cq.Data[1].Name)\n\tutils.AssertEqual(t, 12, cq.Data[1].Age)\n}\n\n// go test -run Test_Ctx_ReqHeaderParser -v\nfunc Test_Ctx_ReqHeaderParser(t *testing.T) {\n\tt.Parallel()\n\tapp := New(Config{EnableSplittingOnParsers: true})\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\ttype Header struct {\n\t\tID    int\n\t\tName  string\n\t\tHobby []string\n\t}\n\tc.Request().SetBody([]byte(``))\n\tc.Request().Header.SetContentType(\"\")\n\n\tc.Request().Header.Add(\"id\", \"1\")\n\tc.Request().Header.Add(\"Name\", \"John Doe\")\n\tc.Request().Header.Add(\"Hobby\", \"golang,fiber\")\n\tq := new(Header)\n\tutils.AssertEqual(t, nil, c.ReqHeaderParser(q))\n\tutils.AssertEqual(t, 2, len(q.Hobby))\n\n\tc.Request().Header.Del(\"hobby\")\n\tc.Request().Header.Add(\"Hobby\", \"golang,fiber,go\")\n\tq = new(Header)\n\tutils.AssertEqual(t, nil, c.ReqHeaderParser(q))\n\tutils.AssertEqual(t, 3, len(q.Hobby))\n\n\tempty := new(Header)\n\tc.Request().Header.Del(\"hobby\")\n\tutils.AssertEqual(t, nil, c.QueryParser(empty))\n\tutils.AssertEqual(t, 0, len(empty.Hobby))\n\n\ttype Header2 struct {\n\t\tBool            bool\n\t\tID              int\n\t\tName            string\n\t\tHobby           string\n\t\tFavouriteDrinks []string\n\t\tEmpty           []string\n\t\tAlloc           []string\n\t\tNo              []int64\n\t}\n\n\tc.Request().Header.Add(\"id\", \"2\")\n\tc.Request().Header.Add(\"Name\", \"Jane Doe\")\n\tc.Request().Header.Del(\"hobby\")\n\tc.Request().Header.Add(\"Hobby\", \"go,fiber\")\n\tc.Request().Header.Add(\"favouriteDrinks\", \"milo,coke,pepsi\")\n\tc.Request().Header.Add(\"alloc\", \"\")\n\tc.Request().Header.Add(\"no\", \"1\")\n\n\th2 := new(Header2)\n\th2.Bool = true\n\th2.Name = \"hello world\"\n\tutils.AssertEqual(t, nil, c.ReqHeaderParser(h2))\n\tutils.AssertEqual(t, \"go,fiber\", h2.Hobby)\n\tutils.AssertEqual(t, true, h2.Bool)\n\tutils.AssertEqual(t, \"Jane Doe\", h2.Name) // check value get overwritten\n\tutils.AssertEqual(t, []string{\"milo\", \"coke\", \"pepsi\"}, h2.FavouriteDrinks)\n\tvar nilSlice []string\n\tutils.AssertEqual(t, nilSlice, h2.Empty)\n\tutils.AssertEqual(t, []string{\"\"}, h2.Alloc)\n\tutils.AssertEqual(t, []int64{1}, h2.No)\n\n\ttype RequiredHeader struct {\n\t\tName string `reqHeader:\"name,required\"`\n\t}\n\trh := new(RequiredHeader)\n\tc.Request().Header.Del(\"name\")\n\tutils.AssertEqual(t, \"failed to decode: name is empty\", c.ReqHeaderParser(rh).Error())\n}\n\n// go test -run Test_Ctx_ReqHeaderParser -v\nfunc Test_Ctx_ReqHeaderParser_WithoutSplitting(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\ttype Header struct {\n\t\tID    int\n\t\tName  string\n\t\tHobby []string\n\t}\n\tc.Request().SetBody([]byte(``))\n\tc.Request().Header.SetContentType(\"\")\n\n\tc.Request().Header.Add(\"id\", \"1\")\n\tc.Request().Header.Add(\"Name\", \"John Doe\")\n\tc.Request().Header.Add(\"Hobby\", \"golang,fiber\")\n\tq := new(Header)\n\tutils.AssertEqual(t, nil, c.ReqHeaderParser(q))\n\tutils.AssertEqual(t, 1, len(q.Hobby))\n\n\tc.Request().Header.Del(\"hobby\")\n\tc.Request().Header.Add(\"Hobby\", \"golang,fiber,go\")\n\tq = new(Header)\n\tutils.AssertEqual(t, nil, c.ReqHeaderParser(q))\n\tutils.AssertEqual(t, 1, len(q.Hobby))\n}\n\n// go test -run Test_Ctx_ReqHeaderParser_WithSetParserDecoder -v\nfunc Test_Ctx_ReqHeaderParser_WithSetParserDecoder(t *testing.T) {\n\tt.Parallel()\n\ttype NonRFCTime time.Time\n\n\tnonRFCConverter := func(value string) reflect.Value {\n\t\tif v, err := time.Parse(\"2006-01-02\", value); err == nil {\n\t\t\treturn reflect.ValueOf(v)\n\t\t}\n\t\treturn reflect.Value{}\n\t}\n\n\tnonRFCTime := ParserType{\n\t\tCustomtype: NonRFCTime{},\n\t\tConverter:  nonRFCConverter,\n\t}\n\n\tSetParserDecoder(ParserConfig{\n\t\tIgnoreUnknownKeys: true,\n\t\tParserType:        []ParserType{nonRFCTime},\n\t\tZeroEmpty:         true,\n\t\tSetAliasTag:       \"req\",\n\t})\n\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\n\ttype NonRFCTimeInput struct {\n\t\tDate  NonRFCTime `req:\"date\"`\n\t\tTitle string     `req:\"title\"`\n\t\tBody  string     `req:\"body\"`\n\t}\n\n\tc.Request().SetBody([]byte(``))\n\tc.Request().Header.SetContentType(\"\")\n\tr := new(NonRFCTimeInput)\n\n\tc.Request().Header.Add(\"Date\", \"2021-04-10\")\n\tc.Request().Header.Add(\"Title\", \"CustomDateTest\")\n\tc.Request().Header.Add(\"Body\", \"October\")\n\n\tutils.AssertEqual(t, nil, c.ReqHeaderParser(r))\n\tutils.AssertEqual(t, \"CustomDateTest\", r.Title)\n\tdate := fmt.Sprintf(\"%v\", r.Date)\n\tutils.AssertEqual(t, \"{0 63753609600 <nil>}\", date)\n\tutils.AssertEqual(t, \"October\", r.Body)\n\n\tc.Request().Header.Add(\"Title\", \"\")\n\tr = &NonRFCTimeInput{\n\t\tTitle: \"Existing title\",\n\t\tBody:  \"Existing Body\",\n\t}\n\tutils.AssertEqual(t, nil, c.ReqHeaderParser(r))\n\tutils.AssertEqual(t, \"\", r.Title)\n}\n\n// go test -run Test_Ctx_ReqHeaderParser_Schema -v\nfunc Test_Ctx_ReqHeaderParser_Schema(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\ttype Header1 struct {\n\t\tName   string `reqHeader:\"Name,required\"`\n\t\tNested struct {\n\t\t\tAge int `reqHeader:\"Age\"`\n\t\t} `reqHeader:\"Nested,required\"`\n\t}\n\tc.Request().SetBody([]byte(``))\n\tc.Request().Header.SetContentType(\"\")\n\n\tc.Request().Header.Add(\"Name\", \"tom\")\n\tc.Request().Header.Add(\"Nested.Age\", \"10\")\n\tq := new(Header1)\n\tutils.AssertEqual(t, nil, c.ReqHeaderParser(q))\n\n\tc.Request().Header.Del(\"Name\")\n\tq = new(Header1)\n\tutils.AssertEqual(t, \"failed to decode: Name is empty\", c.ReqHeaderParser(q).Error())\n\n\tc.Request().Header.Add(\"Name\", \"tom\")\n\tc.Request().Header.Del(\"Nested.Age\")\n\tc.Request().Header.Add(\"Nested.Agex\", \"10\")\n\tq = new(Header1)\n\tutils.AssertEqual(t, nil, c.ReqHeaderParser(q))\n\n\tc.Request().Header.Del(\"Nested.Agex\")\n\tq = new(Header1)\n\tutils.AssertEqual(t, \"failed to decode: Nested is empty\", c.ReqHeaderParser(q).Error())\n\n\tc.Request().Header.Del(\"Nested.Agex\")\n\tc.Request().Header.Del(\"Name\")\n\n\ttype Header2 struct {\n\t\tName   string `reqHeader:\"Name\"`\n\t\tNested struct {\n\t\t\tAge int `reqHeader:\"age,required\"`\n\t\t} `reqHeader:\"Nested\"`\n\t}\n\n\tc.Request().Header.Add(\"Name\", \"tom\")\n\tc.Request().Header.Add(\"Nested.Age\", \"10\")\n\n\th2 := new(Header2)\n\tutils.AssertEqual(t, nil, c.ReqHeaderParser(h2))\n\n\tc.Request().Header.Del(\"Name\")\n\th2 = new(Header2)\n\tutils.AssertEqual(t, nil, c.ReqHeaderParser(h2))\n\n\tc.Request().Header.Del(\"Name\")\n\tc.Request().Header.Del(\"Nested.Age\")\n\tc.Request().Header.Add(\"Nested.Agex\", \"10\")\n\th2 = new(Header2)\n\tutils.AssertEqual(t, \"failed to decode: Nested.age is empty\", c.ReqHeaderParser(h2).Error())\n\n\ttype Node struct {\n\t\tValue int   `reqHeader:\"Val,required\"`\n\t\tNext  *Node `reqHeader:\"Next,required\"`\n\t}\n\tc.Request().Header.Add(\"Val\", \"1\")\n\tc.Request().Header.Add(\"Next.Val\", \"3\")\n\tn := new(Node)\n\tutils.AssertEqual(t, nil, c.ReqHeaderParser(n))\n\tutils.AssertEqual(t, 1, n.Value)\n\tutils.AssertEqual(t, 3, n.Next.Value)\n\n\tc.Request().Header.Del(\"Val\")\n\tn = new(Node)\n\tutils.AssertEqual(t, \"failed to decode: Val is empty\", c.ReqHeaderParser(n).Error())\n\n\tc.Request().Header.Add(\"Val\", \"3\")\n\tc.Request().Header.Del(\"Next.Val\")\n\tc.Request().Header.Add(\"Next.Value\", \"2\")\n\tn = new(Node)\n\tn.Next = new(Node)\n\tutils.AssertEqual(t, nil, c.ReqHeaderParser(n))\n\tutils.AssertEqual(t, 3, n.Value)\n\tutils.AssertEqual(t, 0, n.Next.Value)\n}\n\nfunc Test_Ctx_EqualFieldType(t *testing.T) {\n\tt.Parallel()\n\tvar out int\n\tutils.AssertEqual(t, false, equalFieldType(&out, reflect.Int, \"key\"))\n\n\tvar dummy struct{ f string }\n\tutils.AssertEqual(t, false, equalFieldType(&dummy, reflect.String, \"key\"))\n\n\tvar dummy2 struct{ f string }\n\tutils.AssertEqual(t, false, equalFieldType(&dummy2, reflect.String, \"f\"))\n\n\tvar user struct {\n\t\tName    string\n\t\tAddress string `query:\"address\"`\n\t\tAge     int    `query:\"AGE\"`\n\t}\n\tutils.AssertEqual(t, true, equalFieldType(&user, reflect.String, \"name\"))\n\tutils.AssertEqual(t, true, equalFieldType(&user, reflect.String, \"Name\"))\n\tutils.AssertEqual(t, true, equalFieldType(&user, reflect.String, \"address\"))\n\tutils.AssertEqual(t, true, equalFieldType(&user, reflect.String, \"Address\"))\n\tutils.AssertEqual(t, true, equalFieldType(&user, reflect.Int, \"AGE\"))\n\tutils.AssertEqual(t, true, equalFieldType(&user, reflect.Int, \"age\"))\n}\n\n// go test -v  -run=^$ -bench=Benchmark_Ctx_QueryParser -benchmem -count=4\nfunc Benchmark_Ctx_QueryParser(b *testing.B) {\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\ttype Query struct {\n\t\tID    int\n\t\tName  string\n\t\tHobby []string\n\t}\n\tc.Request().SetBody([]byte(``))\n\tc.Request().Header.SetContentType(\"\")\n\tc.Request().URI().SetQueryString(\"id=1&name=tom&hobby=basketball&hobby=football\")\n\tq := new(Query)\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\n\tvar err error\n\tfor n := 0; n < b.N; n++ {\n\t\terr = c.QueryParser(q)\n\t}\n\tutils.AssertEqual(b, nil, err)\n\tutils.AssertEqual(b, nil, c.QueryParser(q))\n}\n\n// go test -v  -run=^$ -bench=Benchmark_Ctx_parseQuery -benchmem -count=4\nfunc Benchmark_Ctx_parseQuery(b *testing.B) {\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\ttype Person struct {\n\t\tName string `query:\"name\"`\n\t\tAge  int    `query:\"age\"`\n\t}\n\n\ttype CollectionQuery struct {\n\t\tData []Person `query:\"data\"`\n\t}\n\n\tc.Request().SetBody([]byte(``))\n\tc.Request().Header.SetContentType(\"\")\n\tc.Request().URI().SetQueryString(\"data[0][name]=john&data[0][age]=10\")\n\tcq := new(CollectionQuery)\n\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\n\tvar err error\n\tfor n := 0; n < b.N; n++ {\n\t\terr = c.QueryParser(cq)\n\t}\n\n\tutils.AssertEqual(b, nil, err)\n\tutils.AssertEqual(b, nil, c.QueryParser(cq))\n}\n\n// go test -v  -run=^$ -bench=Benchmark_Ctx_QueryParser_Comma -benchmem -count=4\nfunc Benchmark_Ctx_QueryParser_Comma(b *testing.B) {\n\tapp := New(Config{EnableSplittingOnParsers: true})\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\ttype Query struct {\n\t\tID    int\n\t\tName  string\n\t\tHobby []string\n\t}\n\tc.Request().SetBody([]byte(``))\n\tc.Request().Header.SetContentType(\"\")\n\t// c.Request().URI().SetQueryString(\"id=1&name=tom&hobby=basketball&hobby=football\")\n\tc.Request().URI().SetQueryString(\"id=1&name=tom&hobby=basketball,football\")\n\tq := new(Query)\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\n\tvar err error\n\tfor n := 0; n < b.N; n++ {\n\t\terr = c.QueryParser(q)\n\t}\n\tutils.AssertEqual(b, nil, err)\n\tutils.AssertEqual(b, nil, c.QueryParser(q))\n}\n\n// go test -v  -run=^$ -bench=Benchmark_Ctx_ReqHeaderParser -benchmem -count=4\nfunc Benchmark_Ctx_ReqHeaderParser(b *testing.B) {\n\tapp := New(Config{EnableSplittingOnParsers: true})\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\ttype ReqHeader struct {\n\t\tID    int\n\t\tName  string\n\t\tHobby []string\n\t}\n\tc.Request().SetBody([]byte(``))\n\tc.Request().Header.SetContentType(\"\")\n\n\tc.Request().Header.Add(\"id\", \"1\")\n\tc.Request().Header.Add(\"Name\", \"John Doe\")\n\tc.Request().Header.Add(\"Hobby\", \"golang,fiber\")\n\n\tq := new(ReqHeader)\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\n\tvar err error\n\tfor n := 0; n < b.N; n++ {\n\t\terr = c.ReqHeaderParser(q)\n\t}\n\tutils.AssertEqual(b, nil, err)\n\tutils.AssertEqual(b, nil, c.ReqHeaderParser(q))\n}\n\n// go test -run Test_Ctx_BodyStreamWriter\nfunc Test_Ctx_BodyStreamWriter(t *testing.T) {\n\tt.Parallel()\n\tctx := &fasthttp.RequestCtx{}\n\n\tctx.SetBodyStreamWriter(func(w *bufio.Writer) {\n\t\tfmt.Fprintf(w, \"body writer line 1\\n\")\n\t\tif err := w.Flush(); err != nil {\n\t\t\tt.Errorf(\"unexpected error: %s\", err)\n\t\t}\n\t\tfmt.Fprintf(w, \"body writer line 2\\n\")\n\t})\n\tif !ctx.IsBodyStream() {\n\t\tt.Fatal(\"IsBodyStream must return true\")\n\t}\n\n\ts := ctx.Response.String()\n\tbr := bufio.NewReader(bytes.NewBufferString(s))\n\tvar resp fasthttp.Response\n\tif err := resp.Read(br); err != nil {\n\t\tt.Fatalf(\"Error when reading response: %s\", err)\n\t}\n\tbody := string(resp.Body())\n\texpectedBody := \"body writer line 1\\nbody writer line 2\\n\"\n\tif body != expectedBody {\n\t\tt.Fatalf(\"unexpected body: %q. Expecting %q\", body, expectedBody)\n\t}\n}\n\n// go test -v  -run=^$ -bench=Benchmark_Ctx_BodyStreamWriter -benchmem -count=4\nfunc Benchmark_Ctx_BodyStreamWriter(b *testing.B) {\n\tctx := &fasthttp.RequestCtx{}\n\tuser := []byte(`{\"name\":\"john\"}`)\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\n\tvar err error\n\tfor n := 0; n < b.N; n++ {\n\t\tctx.ResetBody()\n\t\tctx.SetBodyStreamWriter(func(w *bufio.Writer) {\n\t\t\tfor i := 0; i < 10; i++ {\n\t\t\t\t_, err = w.Write(user)\n\t\t\t\tif err := w.Flush(); err != nil {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n\tutils.AssertEqual(b, nil, err)\n}\n\nfunc Test_Ctx_String(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\n\tutils.AssertEqual(t, \"#0000000000000000 - 0.0.0.0:0 <-> 0.0.0.0:0 - GET http:///\", c.String())\n}\n\nfunc TestCtx_ParamsInt(t *testing.T) {\n\t// Create a test context and set some strings (or params)\n\t// create a fake app to be used within this test\n\tt.Parallel()\n\tapp := New()\n\n\t// Create some test endpoints\n\n\t// For the user id I will use the number 1111, so I should be able to get the number\n\t// 1111 from the Ctx\n\tapp.Get(\"/test/:user\", func(c *Ctx) error {\n\t\t// utils.AssertEqual(t, \"john\", c.Params(\"user\"))\n\n\t\tnum, err := c.ParamsInt(\"user\")\n\n\t\t// Check the number matches\n\t\tif num != 1111 {\n\t\t\tt.Fatalf(\"Expected number 1111 from the path, got %d\", num)\n\t\t}\n\n\t\t// Check no errors are returned, because we want NO errors in this one\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Expected nil error for 1111 test, got \" + err.Error())\n\t\t}\n\n\t\treturn nil\n\t})\n\n\t// In this test case, there will be a bad request where the expected number is NOT\n\t// a number in the path\n\tapp.Get(\"/testnoint/:user\", func(c *Ctx) error {\n\t\t// utils.AssertEqual(t, \"john\", c.Params(\"user\"))\n\n\t\tnum, err := c.ParamsInt(\"user\")\n\n\t\t// Check the number matches\n\t\tif num != 0 {\n\t\t\tt.Fatalf(\"Expected number 0 from the path, got %d\", num)\n\t\t}\n\n\t\t// Check an error is returned, because we want NO errors in this one\n\t\tif err == nil {\n\t\t\tt.Fatal(\"Expected non nil error for bad req test, got nil\")\n\t\t}\n\n\t\treturn nil\n\t})\n\n\t// For the user id I will use the number 2222, so I should be able to get the number\n\t// 2222 from the Ctx even when the default value is specified\n\tapp.Get(\"/testignoredefault/:user\", func(c *Ctx) error {\n\t\t// utils.AssertEqual(t, \"john\", c.Params(\"user\"))\n\n\t\tnum, err := c.ParamsInt(\"user\", 1111)\n\n\t\t// Check the number matches\n\t\tif num != 2222 {\n\t\t\tt.Fatalf(\"Expected number 2222 from the path, got %d\", num)\n\t\t}\n\n\t\t// Check no errors are returned, because we want NO errors in this one\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Expected nil error for 2222 test, got \" + err.Error())\n\t\t}\n\n\t\treturn nil\n\t})\n\n\t// In this test case, there will be a bad request where the expected number is NOT\n\t// a number in the path, default value of 1111 should be used instead\n\tapp.Get(\"/testdefault/:user\", func(c *Ctx) error {\n\t\t// utils.AssertEqual(t, \"john\", c.Params(\"user\"))\n\n\t\tnum, err := c.ParamsInt(\"user\", 1111)\n\n\t\t// Check the number matches\n\t\tif num != 1111 {\n\t\t\tt.Fatalf(\"Expected number 1111 from the path, got %d\", num)\n\t\t}\n\n\t\t// Check an error is returned, because we want NO errors in this one\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Expected nil error for 1111 test, got \" + err.Error())\n\t\t}\n\n\t\treturn nil\n\t})\n\n\t_, err := app.Test(httptest.NewRequest(MethodGet, \"/test/1111\", nil))\n\tutils.AssertEqual(t, nil, err)\n\n\t_, err = app.Test(httptest.NewRequest(MethodGet, \"/testnoint/xd\", nil))\n\tutils.AssertEqual(t, nil, err)\n\n\t_, err = app.Test(httptest.NewRequest(MethodGet, \"/testignoredefault/2222\", nil))\n\tutils.AssertEqual(t, nil, err)\n\n\t_, err = app.Test(httptest.NewRequest(MethodGet, \"/testdefault/xd\", nil))\n\tutils.AssertEqual(t, nil, err)\n}\n\n// go test -run Test_Ctx_GetRespHeader\nfunc Test_Ctx_GetRespHeader(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\n\tc.Set(\"test\", \"Hello, World \ud83d\udc4b!\")\n\tc.Response().Header.Set(HeaderContentType, \"application/json\")\n\tutils.AssertEqual(t, c.GetRespHeader(\"test\"), \"Hello, World \ud83d\udc4b!\")\n\tutils.AssertEqual(t, c.GetRespHeader(HeaderContentType), \"application/json\")\n}\n\n// go test -run Test_Ctx_GetRespHeaders\nfunc Test_Ctx_GetRespHeaders(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\n\tc.Set(\"test\", \"Hello, World \ud83d\udc4b!\")\n\tc.Set(\"foo\", \"bar\")\n\tc.Response().Header.Set(HeaderContentType, \"application/json\")\n\n\tutils.AssertEqual(t, c.GetRespHeaders(), map[string]string{\n\t\t\"Content-Type\": \"application/json\",\n\t\t\"Foo\":          \"bar\",\n\t\t\"Test\":         \"Hello, World \ud83d\udc4b!\",\n\t})\n}\n\n// go test -run Test_Ctx_GetReqHeaders\nfunc Test_Ctx_GetReqHeaders(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\n\tc.Request().Header.Set(\"test\", \"Hello, World \ud83d\udc4b!\")\n\tc.Request().Header.Set(\"foo\", \"bar\")\n\tc.Request().Header.Set(HeaderContentType, \"application/json\")\n\n\tutils.AssertEqual(t, c.GetReqHeaders(), map[string]string{\n\t\t\"Content-Type\": \"application/json\",\n\t\t\"Foo\":          \"bar\",\n\t\t\"Test\":         \"Hello, World \ud83d\udc4b!\",\n\t})\n}\n\n// go test -run Test_Ctx_IsFromLocal_X_Forwarded\nfunc Test_Ctx_IsFromLocal_X_Forwarded(t *testing.T) {\n\tt.Parallel()\n\t// Test unset X-Forwarded-For header.\n\t{\n\t\tapp := New()\n\t\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\t\tdefer app.ReleaseCtx(c)\n\t\t// fasthttp returns \"0.0.0.0\" as IP as there is no remote address.\n\t\tutils.AssertEqual(t, \"0.0.0.0\", c.IP())\n\t\tutils.AssertEqual(t, false, c.IsFromLocal())\n\t}\n\t// Test when setting X-Forwarded-For header to localhost \"127.0.0.1\"\n\t{\n\t\tapp := New()\n\t\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\t\tc.Request().Header.Set(HeaderXForwardedFor, \"127.0.0.1\")\n\t\tdefer app.ReleaseCtx(c)\n\t\tutils.AssertEqual(t, false, c.IsFromLocal())\n\t}\n\t// Test when setting X-Forwarded-For header to localhost \"::1\"\n\t{\n\t\tapp := New()\n\t\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\t\tc.Request().Header.Set(HeaderXForwardedFor, \"::1\")\n\t\tdefer app.ReleaseCtx(c)\n\t\tutils.AssertEqual(t, false, c.IsFromLocal())\n\t}\n\t// Test when setting X-Forwarded-For to full localhost IPv6 address \"0:0:0:0:0:0:0:1\"\n\t{\n\t\tapp := New()\n\t\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\t\tc.Request().Header.Set(HeaderXForwardedFor, \"0:0:0:0:0:0:0:1\")\n\t\tdefer app.ReleaseCtx(c)\n\t\tutils.AssertEqual(t, false, c.IsFromLocal())\n\t}\n\t// Test for a random IP address.\n\t{\n\t\tapp := New()\n\t\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\t\tc.Request().Header.Set(HeaderXForwardedFor, \"93.46.8.90\")\n\t\tdefer app.ReleaseCtx(c)\n\t\tutils.AssertEqual(t, false, c.IsFromLocal())\n\t}\n}\n\n// go test -run Test_Ctx_IsFromLocal_RemoteAddr\nfunc Test_Ctx_IsFromLocal_RemoteAddr(t *testing.T) {\n\tt.Parallel()\n\n\tlocalIPv4 := net.Addr(&net.TCPAddr{IP: net.ParseIP(\"127.0.0.1\")})\n\tlocalIPv6 := net.Addr(&net.TCPAddr{IP: net.ParseIP(\"::1\")})\n\tlocalIPv6long := net.Addr(&net.TCPAddr{IP: net.ParseIP(\"0:0:0:0:0:0:0:1\")})\n\n\tzeroIPv4 := net.Addr(&net.TCPAddr{IP: net.IPv4zero})\n\n\tsomeIPv4 := net.Addr(&net.TCPAddr{IP: net.ParseIP(\"93.46.8.90\")})\n\tsomeIPv6 := net.Addr(&net.TCPAddr{IP: net.ParseIP(\"2001:0db8:85a3:0000:0000:8a2e:0370:7334\")})\n\n\t// Test for the case fasthttp remoteAddr is set to \"127.0.0.1\".\n\t{\n\t\tapp := New()\n\t\tfastCtx := &fasthttp.RequestCtx{}\n\t\tfastCtx.SetRemoteAddr(localIPv4)\n\t\tc := app.AcquireCtx(fastCtx)\n\t\tdefer app.ReleaseCtx(c)\n\n\t\tutils.AssertEqual(t, \"127.0.0.1\", c.IP())\n\t\tutils.AssertEqual(t, true, c.IsFromLocal())\n\t}\n\t// Test for the case fasthttp remoteAddr is set to \"::1\".\n\t{\n\t\tapp := New()\n\t\tfastCtx := &fasthttp.RequestCtx{}\n\t\tfastCtx.SetRemoteAddr(localIPv6)\n\t\tc := app.AcquireCtx(fastCtx)\n\t\tdefer app.ReleaseCtx(c)\n\t\tutils.AssertEqual(t, \"::1\", c.IP())\n\t\tutils.AssertEqual(t, true, c.IsFromLocal())\n\t}\n\t// Test for the case fasthttp remoteAddr is set to \"0:0:0:0:0:0:0:1\".\n\t{\n\t\tapp := New()\n\t\tfastCtx := &fasthttp.RequestCtx{}\n\t\tfastCtx.SetRemoteAddr(localIPv6long)\n\t\tc := app.AcquireCtx(fastCtx)\n\t\tdefer app.ReleaseCtx(c)\n\t\t// fasthttp should return \"::1\" for \"0:0:0:0:0:0:0:1\".\n\t\t// otherwise IsFromLocal() will break.\n\t\tutils.AssertEqual(t, \"::1\", c.IP())\n\t\tutils.AssertEqual(t, true, c.IsFromLocal())\n\t}\n\t// Test for the case fasthttp remoteAddr is set to \"0.0.0.0\".\n\t{\n\t\tapp := New()\n\t\tfastCtx := &fasthttp.RequestCtx{}\n\t\tfastCtx.SetRemoteAddr(zeroIPv4)\n\t\tc := app.AcquireCtx(fastCtx)\n\t\tdefer app.ReleaseCtx(c)\n\t\tutils.AssertEqual(t, \"0.0.0.0\", c.IP())\n\t\tutils.AssertEqual(t, false, c.IsFromLocal())\n\t}\n\t// Test for the case fasthttp remoteAddr is set to \"93.46.8.90\".\n\t{\n\t\tapp := New()\n\t\tfastCtx := &fasthttp.RequestCtx{}\n\t\tfastCtx.SetRemoteAddr(someIPv4)\n\t\tc := app.AcquireCtx(fastCtx)\n\t\tdefer app.ReleaseCtx(c)\n\t\tutils.AssertEqual(t, \"93.46.8.90\", c.IP())\n\t\tutils.AssertEqual(t, false, c.IsFromLocal())\n\t}\n\t// Test for the case fasthttp remoteAddr is set to \"2001:0db8:85a3:0000:0000:8a2e:0370:7334\".\n\t{\n\t\tapp := New()\n\t\tfastCtx := &fasthttp.RequestCtx{}\n\t\tfastCtx.SetRemoteAddr(someIPv6)\n\t\tc := app.AcquireCtx(fastCtx)\n\t\tdefer app.ReleaseCtx(c)\n\t\tutils.AssertEqual(t, \"2001:db8:85a3::8a2e:370:7334\", c.IP())\n\t\tutils.AssertEqual(t, false, c.IsFromLocal())\n\t}\n}\n\n// go test -run Test_Ctx_RepeatParserWithSameStruct -v\nfunc Test_Ctx_RepeatParserWithSameStruct(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\n\ttype Request struct {\n\t\tQueryParam  string `query:\"query_param\"`\n\t\tHeaderParam string `reqHeader:\"header_param\"`\n\t\tBodyParam   string `json:\"body_param\" xml:\"body_param\" form:\"body_param\"`\n\t}\n\n\tr := new(Request)\n\n\tc.Request().URI().SetQueryString(\"query_param=query_param\")\n\tutils.AssertEqual(t, nil, c.QueryParser(r))\n\tutils.AssertEqual(t, \"query_param\", r.QueryParam)\n\n\tc.Request().Header.Add(\"header_param\", \"header_param\")\n\tutils.AssertEqual(t, nil, c.ReqHeaderParser(r))\n\tutils.AssertEqual(t, \"header_param\", r.HeaderParam)\n\n\tvar gzipJSON bytes.Buffer\n\tw := gzip.NewWriter(&gzipJSON)\n\t_, _ = w.Write([]byte(`{\"body_param\":\"body_param\"}`)) //nolint:errcheck // This will never fail\n\terr := w.Close()\n\tutils.AssertEqual(t, nil, err)\n\tc.Request().Header.SetContentType(MIMEApplicationJSON)\n\tc.Request().Header.Set(HeaderContentEncoding, \"gzip\")\n\tc.Request().SetBody(gzipJSON.Bytes())\n\tc.Request().Header.SetContentLength(len(gzipJSON.Bytes()))\n\tutils.AssertEqual(t, nil, c.BodyParser(r))\n\tutils.AssertEqual(t, \"body_param\", r.BodyParam)\n\tc.Request().Header.Del(HeaderContentEncoding)\n\n\ttestDecodeParser := func(contentType, body string) {\n\t\tc.Request().Header.SetContentType(contentType)\n\t\tc.Request().SetBody([]byte(body))\n\t\tc.Request().Header.SetContentLength(len(body))\n\t\tutils.AssertEqual(t, nil, c.BodyParser(r))\n\t\tutils.AssertEqual(t, \"body_param\", r.BodyParam)\n\t}\n\n\ttestDecodeParser(MIMEApplicationJSON, `{\"body_param\":\"body_param\"}`)\n\ttestDecodeParser(MIMEApplicationXML, `<Demo><body_param>body_param</body_param></Demo>`)\n\ttestDecodeParser(MIMEApplicationForm, \"body_param=body_param\")\n\ttestDecodeParser(MIMEMultipartForm+`;boundary=\"b\"`, \"--b\\r\\nContent-Disposition: form-data; name=\\\"body_param\\\"\\r\\n\\r\\nbody_param\\r\\n--b--\")\n}\n"], "filenames": ["ctx.go", "ctx_test.go"], "buggy_code_start_loc": [1890, 19], "buggy_code_end_loc": [1910, 4971], "fixing_code_start_loc": [1890, 20], "fixing_code_end_loc": [1906, 5042], "type": "CWE-670", "message": "Fiber is an Express inspired web framework built in the go language. Versions of gofiber prior to 2.49.2 did not properly restrict access to localhost. This issue impacts users of our project who rely on the `ctx.IsFromLocal` method to restrict access to localhost requests. If exploited, it could allow unauthorized access to resources intended only for localhost. Setting `X-Forwarded-For: 127.0.0.1` in a request from a foreign host, will result in true for `ctx.IsFromLocal`. Access is limited to the scope of the affected process. This issue has been patched in version `2.49.2` with commit `b8c9ede6`. Users are advised to upgrade. There are no known workarounds to remediate this vulnerability without upgrading to the patched version. ", "other": {"cve": {"id": "CVE-2023-41338", "sourceIdentifier": "security-advisories@github.com", "published": "2023-09-08T19:15:43.977", "lastModified": "2023-09-12T19:12:29.057", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Fiber is an Express inspired web framework built in the go language. Versions of gofiber prior to 2.49.2 did not properly restrict access to localhost. This issue impacts users of our project who rely on the `ctx.IsFromLocal` method to restrict access to localhost requests. If exploited, it could allow unauthorized access to resources intended only for localhost. Setting `X-Forwarded-For: 127.0.0.1` in a request from a foreign host, will result in true for `ctx.IsFromLocal`. Access is limited to the scope of the affected process. This issue has been patched in version `2.49.2` with commit `b8c9ede6`. Users are advised to upgrade. There are no known workarounds to remediate this vulnerability without upgrading to the patched version. "}, {"lang": "es", "value": "Fiber es un framework web inspirado en Express creado en el lenguaje Go. Las versiones de gofiber anteriores a la 2.49.2 no restring\u00edan adecuadamente el acceso a localhost. Este problema afecta a los usuarios de nuestro proyecto que dependen del m\u00e9todo `ctx.IsFromLocal` para restringir el acceso a las solicitudes de localhost. Si se explota, podr\u00eda permitir el acceso no autorizado a recursos destinados \u00fanicamente a localhost. Configurar `X-Forwarded-For: 127.0.0.1` en una solicitud de un host externo dar\u00e1 como resultado verdadero para `ctx.IsFromLocal`. El acceso est\u00e1 limitado al alcance del proceso afectado. Este problema se solucion\u00f3 en la versi\u00f3n `2.49.2` con el commit `b8c9ede6`. Se recomienda a los usuarios que actualicen. No se conocen soluciones para remediar esta vulnerabilidad sin actualizar a la versi\u00f3n parcheada."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-670"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:gofiber:fiber:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.49.2", "matchCriteriaId": "DC21F2CF-3B2C-4803-AF42-0377FB5CD6AD"}]}]}], "references": [{"url": "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Forwarded-For", "source": "security-advisories@github.com", "tags": ["Technical Description"]}, {"url": "https://docs.gofiber.io/api/ctx#isfromlocal", "source": "security-advisories@github.com", "tags": ["Product"]}, {"url": "https://github.com/gofiber/fiber/commit/b8c9ede6efa231116c4bd8bb9d5e03eac1cb76dc", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/gofiber/fiber/security/advisories/GHSA-3q5p-3558-364f", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/gofiber/fiber/commit/b8c9ede6efa231116c4bd8bb9d5e03eac1cb76dc"}}