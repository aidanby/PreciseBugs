{"buggy_code": ["<?php\n/**\n * Core HTTP Request API\n *\n * Standardizes the HTTP requests for WordPress. Handles cookies, gzip encoding and decoding, chunk\n * decoding, if HTTP 1.1 and various other difficult HTTP protocol implementations.\n *\n * @package WordPress\n * @subpackage HTTP\n */\n\n/**\n * Returns the initialized WP_Http Object\n *\n * @since 2.7.0\n * @access private\n *\n * @staticvar WP_Http $http\n *\n * @return WP_Http HTTP Transport object.\n */\nfunction _wp_http_get_object() {\n\tstatic $http = null;\n\n\tif ( is_null( $http ) ) {\n\t\t$http = new WP_Http();\n\t}\n\treturn $http;\n}\n\n/**\n * Retrieve the raw response from a safe HTTP request.\n *\n * This function is ideal when the HTTP request is being made to an arbitrary\n * URL. The URL is validated to avoid redirection and request forgery attacks.\n *\n * @since 3.6.0\n *\n * @see wp_remote_request() For more information on the response array format.\n * @see WP_Http::request() For default arguments information.\n *\n * @param string $url  URL to retrieve.\n * @param array  $args Optional. Request arguments. Default empty array.\n * @return WP_Error|array The response or WP_Error on failure.\n */\nfunction wp_safe_remote_request( $url, $args = array() ) {\n\t$args['reject_unsafe_urls'] = true;\n\t$http                       = _wp_http_get_object();\n\treturn $http->request( $url, $args );\n}\n\n/**\n * Retrieve the raw response from a safe HTTP request using the GET method.\n *\n * This function is ideal when the HTTP request is being made to an arbitrary\n * URL. The URL is validated to avoid redirection and request forgery attacks.\n *\n * @since 3.6.0\n *\n * @see wp_remote_request() For more information on the response array format.\n * @see WP_Http::request() For default arguments information.\n *\n * @param string $url  URL to retrieve.\n * @param array  $args Optional. Request arguments. Default empty array.\n * @return WP_Error|array The response or WP_Error on failure.\n */\nfunction wp_safe_remote_get( $url, $args = array() ) {\n\t$args['reject_unsafe_urls'] = true;\n\t$http                       = _wp_http_get_object();\n\treturn $http->get( $url, $args );\n}\n\n/**\n * Retrieve the raw response from a safe HTTP request using the POST method.\n *\n * This function is ideal when the HTTP request is being made to an arbitrary\n * URL. The URL is validated to avoid redirection and request forgery attacks.\n *\n * @since 3.6.0\n *\n * @see wp_remote_request() For more information on the response array format.\n * @see WP_Http::request() For default arguments information.\n *\n * @param string $url  URL to retrieve.\n * @param array  $args Optional. Request arguments. Default empty array.\n * @return WP_Error|array The response or WP_Error on failure.\n */\nfunction wp_safe_remote_post( $url, $args = array() ) {\n\t$args['reject_unsafe_urls'] = true;\n\t$http                       = _wp_http_get_object();\n\treturn $http->post( $url, $args );\n}\n\n/**\n * Retrieve the raw response from a safe HTTP request using the HEAD method.\n *\n * This function is ideal when the HTTP request is being made to an arbitrary\n * URL. The URL is validated to avoid redirection and request forgery attacks.\n *\n * @since 3.6.0\n *\n * @see wp_remote_request() For more information on the response array format.\n * @see WP_Http::request() For default arguments information.\n *\n * @param string $url  URL to retrieve.\n * @param array  $args Optional. Request arguments. Default empty array.\n * @return WP_Error|array The response or WP_Error on failure.\n */\nfunction wp_safe_remote_head( $url, $args = array() ) {\n\t$args['reject_unsafe_urls'] = true;\n\t$http                       = _wp_http_get_object();\n\treturn $http->head( $url, $args );\n}\n\n/**\n * Performs an HTTP request and returns its response.\n *\n * There are other API functions available which abstract away the HTTP method:\n *\n *  - Default 'GET'  for wp_remote_get()\n *  - Default 'POST' for wp_remote_post()\n *  - Default 'HEAD' for wp_remote_head()\n *\n * @since 2.7.0\n *\n * @see WP_Http::request() For information on default arguments.\n *\n * @param string $url  URL to retrieve.\n * @param array  $args Optional. Request arguments. Default empty array.\n * @return WP_Error|array {\n *     The response array or a WP_Error on failure.\n *\n *     @type string[]                       $headers       Array of response headers keyed by their name.\n *     @type string                         $body          Response body.\n *     @type array                          $response      {\n *         Data about the HTTP response.\n *\n *         @type int|false    $code    HTTP response code.\n *         @type string|false $message HTTP response message.\n *     }\n *     @type WP_HTTP_Cookie[]               $cookies       Array of response cookies.\n *     @type WP_HTTP_Requests_Response|null $http_response Raw HTTP response object.\n * }\n */\nfunction wp_remote_request( $url, $args = array() ) {\n\t$http = _wp_http_get_object();\n\treturn $http->request( $url, $args );\n}\n\n/**\n * Performs an HTTP request using the GET method and returns its response.\n *\n * @since 2.7.0\n *\n * @see wp_remote_request() For more information on the response array format.\n * @see WP_Http::request() For default arguments information.\n *\n * @param string $url  URL to retrieve.\n * @param array  $args Optional. Request arguments. Default empty array.\n * @return WP_Error|array The response or WP_Error on failure.\n */\nfunction wp_remote_get( $url, $args = array() ) {\n\t$http = _wp_http_get_object();\n\treturn $http->get( $url, $args );\n}\n\n/**\n * Performs an HTTP request using the POST method and returns its response.\n *\n * @since 2.7.0\n *\n * @see wp_remote_request() For more information on the response array format.\n * @see WP_Http::request() For default arguments information.\n *\n * @param string $url  URL to retrieve.\n * @param array  $args Optional. Request arguments. Default empty array.\n * @return WP_Error|array The response or WP_Error on failure.\n */\nfunction wp_remote_post( $url, $args = array() ) {\n\t$http = _wp_http_get_object();\n\treturn $http->post( $url, $args );\n}\n\n/**\n * Performs an HTTP request using the HEAD method and returns its response.\n *\n * @since 2.7.0\n *\n * @see wp_remote_request() For more information on the response array format.\n * @see WP_Http::request() For default arguments information.\n *\n * @param string $url  URL to retrieve.\n * @param array  $args Optional. Request arguments. Default empty array.\n * @return WP_Error|array The response or WP_Error on failure.\n */\nfunction wp_remote_head( $url, $args = array() ) {\n\t$http = _wp_http_get_object();\n\treturn $http->head( $url, $args );\n}\n\n/**\n * Retrieve only the headers from the raw response.\n *\n * @since 2.7.0\n * @since 4.6.0 Return value changed from an array to an Requests_Utility_CaseInsensitiveDictionary instance.\n *\n * @see \\Requests_Utility_CaseInsensitiveDictionary\n *\n * @param array|WP_Error $response HTTP response.\n * @return array|\\Requests_Utility_CaseInsensitiveDictionary The headers of the response. Empty array if incorrect parameter given.\n */\nfunction wp_remote_retrieve_headers( $response ) {\n\tif ( is_wp_error( $response ) || ! isset( $response['headers'] ) ) {\n\t\treturn array();\n\t}\n\n\treturn $response['headers'];\n}\n\n/**\n * Retrieve a single header by name from the raw response.\n *\n * @since 2.7.0\n *\n * @param array|WP_Error $response HTTP response.\n * @param string         $header   Header name to retrieve value from.\n * @return string The header value. Empty string on if incorrect parameter given, or if the header doesn't exist.\n */\nfunction wp_remote_retrieve_header( $response, $header ) {\n\tif ( is_wp_error( $response ) || ! isset( $response['headers'] ) ) {\n\t\treturn '';\n\t}\n\n\tif ( isset( $response['headers'][ $header ] ) ) {\n\t\treturn $response['headers'][ $header ];\n\t}\n\n\treturn '';\n}\n\n/**\n * Retrieve only the response code from the raw response.\n *\n * Will return an empty array if incorrect parameter value is given.\n *\n * @since 2.7.0\n *\n * @param array|WP_Error $response HTTP response.\n * @return int|string The response code as an integer. Empty string on incorrect parameter given.\n */\nfunction wp_remote_retrieve_response_code( $response ) {\n\tif ( is_wp_error( $response ) || ! isset( $response['response'] ) || ! is_array( $response['response'] ) ) {\n\t\treturn '';\n\t}\n\n\treturn $response['response']['code'];\n}\n\n/**\n * Retrieve only the response message from the raw response.\n *\n * Will return an empty array if incorrect parameter value is given.\n *\n * @since 2.7.0\n *\n * @param array|WP_Error $response HTTP response.\n * @return string The response message. Empty string on incorrect parameter given.\n */\nfunction wp_remote_retrieve_response_message( $response ) {\n\tif ( is_wp_error( $response ) || ! isset( $response['response'] ) || ! is_array( $response['response'] ) ) {\n\t\treturn '';\n\t}\n\n\treturn $response['response']['message'];\n}\n\n/**\n * Retrieve only the body from the raw response.\n *\n * @since 2.7.0\n *\n * @param array|WP_Error $response HTTP response.\n * @return string The body of the response. Empty string if no body or incorrect parameter given.\n */\nfunction wp_remote_retrieve_body( $response ) {\n\tif ( is_wp_error( $response ) || ! isset( $response['body'] ) ) {\n\t\treturn '';\n\t}\n\n\treturn $response['body'];\n}\n\n/**\n * Retrieve only the cookies from the raw response.\n *\n * @since 4.4.0\n *\n * @param array|WP_Error $response HTTP response.\n * @return WP_Http_Cookie[] An array of `WP_Http_Cookie` objects from the response. Empty array if there are none, or the response is a WP_Error.\n */\nfunction wp_remote_retrieve_cookies( $response ) {\n\tif ( is_wp_error( $response ) || empty( $response['cookies'] ) ) {\n\t\treturn array();\n\t}\n\n\treturn $response['cookies'];\n}\n\n/**\n * Retrieve a single cookie by name from the raw response.\n *\n * @since 4.4.0\n *\n * @param array|WP_Error $response HTTP response.\n * @param string         $name     The name of the cookie to retrieve.\n * @return WP_Http_Cookie|string The `WP_Http_Cookie` object. Empty string if the cookie isn't present in the response.\n */\nfunction wp_remote_retrieve_cookie( $response, $name ) {\n\t$cookies = wp_remote_retrieve_cookies( $response );\n\n\tif ( empty( $cookies ) ) {\n\t\treturn '';\n\t}\n\n\tforeach ( $cookies as $cookie ) {\n\t\tif ( $cookie->name === $name ) {\n\t\t\treturn $cookie;\n\t\t}\n\t}\n\n\treturn '';\n}\n\n/**\n * Retrieve a single cookie's value by name from the raw response.\n *\n * @since 4.4.0\n *\n * @param array|WP_Error $response HTTP response.\n * @param string         $name     The name of the cookie to retrieve.\n * @return string The value of the cookie. Empty string if the cookie isn't present in the response.\n */\nfunction wp_remote_retrieve_cookie_value( $response, $name ) {\n\t$cookie = wp_remote_retrieve_cookie( $response, $name );\n\n\tif ( ! is_a( $cookie, 'WP_Http_Cookie' ) ) {\n\t\treturn '';\n\t}\n\n\treturn $cookie->value;\n}\n\n/**\n * Determines if there is an HTTP Transport that can process this request.\n *\n * @since 3.2.0\n *\n * @param array  $capabilities Array of capabilities to test or a wp_remote_request() $args array.\n * @param string $url          Optional. If given, will check if the URL requires SSL and adds\n *                             that requirement to the capabilities array.\n *\n * @return bool\n */\nfunction wp_http_supports( $capabilities = array(), $url = null ) {\n\t$http = _wp_http_get_object();\n\n\t$capabilities = wp_parse_args( $capabilities );\n\n\t$count = count( $capabilities );\n\n\t// If we have a numeric $capabilities array, spoof a wp_remote_request() associative $args array\n\tif ( $count && count( array_filter( array_keys( $capabilities ), 'is_numeric' ) ) == $count ) {\n\t\t$capabilities = array_combine( array_values( $capabilities ), array_fill( 0, $count, true ) );\n\t}\n\n\tif ( $url && ! isset( $capabilities['ssl'] ) ) {\n\t\t$scheme = parse_url( $url, PHP_URL_SCHEME );\n\t\tif ( 'https' == $scheme || 'ssl' == $scheme ) {\n\t\t\t$capabilities['ssl'] = true;\n\t\t}\n\t}\n\n\treturn (bool) $http->_get_first_available_transport( $capabilities );\n}\n\n/**\n * Get the HTTP Origin of the current request.\n *\n * @since 3.4.0\n *\n * @return string URL of the origin. Empty string if no origin.\n */\nfunction get_http_origin() {\n\t$origin = '';\n\tif ( ! empty( $_SERVER['HTTP_ORIGIN'] ) ) {\n\t\t$origin = $_SERVER['HTTP_ORIGIN'];\n\t}\n\n\t/**\n\t * Change the origin of an HTTP request.\n\t *\n\t * @since 3.4.0\n\t *\n\t * @param string $origin The original origin for the request.\n\t */\n\treturn apply_filters( 'http_origin', $origin );\n}\n\n/**\n * Retrieve list of allowed HTTP origins.\n *\n * @since 3.4.0\n *\n * @return string[] Array of origin URLs.\n */\nfunction get_allowed_http_origins() {\n\t$admin_origin = parse_url( admin_url() );\n\t$home_origin  = parse_url( home_url() );\n\n\t// @todo preserve port?\n\t$allowed_origins = array_unique(\n\t\tarray(\n\t\t\t'http://' . $admin_origin['host'],\n\t\t\t'https://' . $admin_origin['host'],\n\t\t\t'http://' . $home_origin['host'],\n\t\t\t'https://' . $home_origin['host'],\n\t\t)\n\t);\n\n\t/**\n\t * Change the origin types allowed for HTTP requests.\n\t *\n\t * @since 3.4.0\n\t *\n\t * @param string[] $allowed_origins {\n\t *     Array of default allowed HTTP origins.\n\t *\n\t *     @type string $0 Non-secure URL for admin origin.\n\t *     @type string $1 Secure URL for admin origin.\n\t *     @type string $2 Non-secure URL for home origin.\n\t *     @type string $3 Secure URL for home origin.\n\t * }\n\t */\n\treturn apply_filters( 'allowed_http_origins', $allowed_origins );\n}\n\n/**\n * Determines if the HTTP origin is an authorized one.\n *\n * @since 3.4.0\n *\n * @param null|string $origin Origin URL. If not provided, the value of get_http_origin() is used.\n * @return string Origin URL if allowed, empty string if not.\n */\nfunction is_allowed_http_origin( $origin = null ) {\n\t$origin_arg = $origin;\n\n\tif ( null === $origin ) {\n\t\t$origin = get_http_origin();\n\t}\n\n\tif ( $origin && ! in_array( $origin, get_allowed_http_origins() ) ) {\n\t\t$origin = '';\n\t}\n\n\t/**\n\t * Change the allowed HTTP origin result.\n\t *\n\t * @since 3.4.0\n\t *\n\t * @param string $origin     Origin URL if allowed, empty string if not.\n\t * @param string $origin_arg Original origin string passed into is_allowed_http_origin function.\n\t */\n\treturn apply_filters( 'allowed_http_origin', $origin, $origin_arg );\n}\n\n/**\n * Send Access-Control-Allow-Origin and related headers if the current request\n * is from an allowed origin.\n *\n * If the request is an OPTIONS request, the script exits with either access\n * control headers sent, or a 403 response if the origin is not allowed. For\n * other request methods, you will receive a return value.\n *\n * @since 3.4.0\n *\n * @return string|false Returns the origin URL if headers are sent. Returns false\n *                      if headers are not sent.\n */\nfunction send_origin_headers() {\n\t$origin = get_http_origin();\n\n\tif ( is_allowed_http_origin( $origin ) ) {\n\t\theader( 'Access-Control-Allow-Origin: ' . $origin );\n\t\theader( 'Access-Control-Allow-Credentials: true' );\n\t\tif ( 'OPTIONS' === $_SERVER['REQUEST_METHOD'] ) {\n\t\t\texit;\n\t\t}\n\t\treturn $origin;\n\t}\n\n\tif ( 'OPTIONS' === $_SERVER['REQUEST_METHOD'] ) {\n\t\tstatus_header( 403 );\n\t\texit;\n\t}\n\n\treturn false;\n}\n\n/**\n * Validate a URL for safe use in the HTTP API.\n *\n * @since 3.5.2\n *\n * @param string $url Request URL.\n * @return false|string URL or false on failure.\n */\nfunction wp_http_validate_url( $url ) {\n\t$original_url = $url;\n\t$url          = wp_kses_bad_protocol( $url, array( 'http', 'https' ) );\n\tif ( ! $url || strtolower( $url ) !== strtolower( $original_url ) ) {\n\t\treturn false;\n\t}\n\n\t$parsed_url = @parse_url( $url );\n\tif ( ! $parsed_url || empty( $parsed_url['host'] ) ) {\n\t\treturn false;\n\t}\n\n\tif ( isset( $parsed_url['user'] ) || isset( $parsed_url['pass'] ) ) {\n\t\treturn false;\n\t}\n\n\tif ( false !== strpbrk( $parsed_url['host'], ':#?[]' ) ) {\n\t\treturn false;\n\t}\n\n\t$parsed_home = @parse_url( get_option( 'home' ) );\n\n\tif ( isset( $parsed_home['host'] ) ) {\n\t\t$same_host = strtolower( $parsed_home['host'] ) === strtolower( $parsed_url['host'] );\n\t} else {\n\t\t$same_host = false;\n\t}\n\n\tif ( ! $same_host ) {\n\t\t$host = trim( $parsed_url['host'], '.' );\n\t\tif ( preg_match( '#^(([1-9]?\\d|1\\d\\d|25[0-5]|2[0-4]\\d)\\.){3}([1-9]?\\d|1\\d\\d|25[0-5]|2[0-4]\\d)$#', $host ) ) {\n\t\t\t$ip = $host;\n\t\t} else {\n\t\t\t$ip = gethostbyname( $host );\n\t\t\tif ( $ip === $host ) { // Error condition for gethostbyname()\n\t\t\t\t$ip = false;\n\t\t\t}\n\t\t}\n\t\tif ( $ip ) {\n\t\t\t$parts = array_map( 'intval', explode( '.', $ip ) );\n\t\t\tif ( 127 === $parts[0] || 10 === $parts[0] || 0 === $parts[0]\n\t\t\t\t|| ( 172 === $parts[0] && 16 <= $parts[1] && 31 >= $parts[1] )\n\t\t\t\t|| ( 192 === $parts[0] && 168 === $parts[1] )\n\t\t\t) {\n\t\t\t\t// If host appears local, reject unless specifically allowed.\n\t\t\t\t/**\n\t\t\t\t * Check if HTTP request is external or not.\n\t\t\t\t *\n\t\t\t\t * Allows to change and allow external requests for the HTTP request.\n\t\t\t\t *\n\t\t\t\t * @since 3.6.0\n\t\t\t\t *\n\t\t\t\t * @param bool   $external Whether HTTP request is external or not.\n\t\t\t\t * @param string $host     Host name of the requested URL.\n\t\t\t\t * @param string $url      Requested URL.\n\t\t\t\t */\n\t\t\t\tif ( ! apply_filters( 'http_request_host_is_external', false, $host, $url ) ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif ( empty( $parsed_url['port'] ) ) {\n\t\treturn $url;\n\t}\n\n\t$port = $parsed_url['port'];\n\tif ( 80 === $port || 443 === $port || 8080 === $port ) {\n\t\treturn $url;\n\t}\n\n\tif ( $parsed_home && $same_host && isset( $parsed_home['port'] ) && $parsed_home['port'] === $port ) {\n\t\treturn $url;\n\t}\n\n\treturn false;\n}\n\n/**\n * Whitelists allowed redirect hosts for safe HTTP requests as well.\n *\n * Attached to the {@see 'http_request_host_is_external'} filter.\n *\n * @since 3.6.0\n *\n * @param bool   $is_external\n * @param string $host\n * @return bool\n */\nfunction allowed_http_request_hosts( $is_external, $host ) {\n\tif ( ! $is_external && wp_validate_redirect( 'http://' . $host ) ) {\n\t\t$is_external = true;\n\t}\n\treturn $is_external;\n}\n\n/**\n * Whitelists any domain in a multisite installation for safe HTTP requests.\n *\n * Attached to the {@see 'http_request_host_is_external'} filter.\n *\n * @since 3.6.0\n *\n * @global wpdb $wpdb WordPress database abstraction object.\n * @staticvar array $queried\n *\n * @param bool   $is_external\n * @param string $host\n * @return bool\n */\nfunction ms_allowed_http_request_hosts( $is_external, $host ) {\n\tglobal $wpdb;\n\tstatic $queried = array();\n\tif ( $is_external ) {\n\t\treturn $is_external;\n\t}\n\tif ( $host === get_network()->domain ) {\n\t\treturn true;\n\t}\n\tif ( isset( $queried[ $host ] ) ) {\n\t\treturn $queried[ $host ];\n\t}\n\t$queried[ $host ] = (bool) $wpdb->get_var( $wpdb->prepare( \"SELECT domain FROM $wpdb->blogs WHERE domain = %s LIMIT 1\", $host ) );\n\treturn $queried[ $host ];\n}\n\n/**\n * A wrapper for PHP's parse_url() function that handles consistency in the return\n * values across PHP versions.\n *\n * PHP 5.4.7 expanded parse_url()'s ability to handle non-absolute url's, including\n * schemeless and relative url's with :// in the path. This function works around\n * those limitations providing a standard output on PHP 5.2~5.4+.\n *\n * Secondly, across various PHP versions, schemeless URLs starting containing a \":\"\n * in the query are being handled inconsistently. This function works around those\n * differences as well.\n *\n * Error suppression is used as prior to PHP 5.3.3, an E_WARNING would be generated\n * when URL parsing failed.\n *\n * @since 4.4.0\n * @since 4.7.0 The `$component` parameter was added for parity with PHP's `parse_url()`.\n *\n * @link https://secure.php.net/manual/en/function.parse-url.php\n *\n * @param string $url       The URL to parse.\n * @param int    $component The specific component to retrieve. Use one of the PHP\n *                          predefined constants to specify which one.\n *                          Defaults to -1 (= return all parts as an array).\n * @return mixed False on parse failure; Array of URL components on success;\n *               When a specific component has been requested: null if the component\n *               doesn't exist in the given URL; a string or - in the case of\n *               PHP_URL_PORT - integer when it does. See parse_url()'s return values.\n */\nfunction wp_parse_url( $url, $component = -1 ) {\n\t$to_unset = array();\n\t$url      = strval( $url );\n\n\tif ( '//' === substr( $url, 0, 2 ) ) {\n\t\t$to_unset[] = 'scheme';\n\t\t$url        = 'placeholder:' . $url;\n\t} elseif ( '/' === substr( $url, 0, 1 ) ) {\n\t\t$to_unset[] = 'scheme';\n\t\t$to_unset[] = 'host';\n\t\t$url        = 'placeholder://placeholder' . $url;\n\t}\n\n\t$parts = @parse_url( $url );\n\n\tif ( false === $parts ) {\n\t\t// Parsing failure.\n\t\treturn $parts;\n\t}\n\n\t// Remove the placeholder values.\n\tforeach ( $to_unset as $key ) {\n\t\tunset( $parts[ $key ] );\n\t}\n\n\treturn _get_component_from_parsed_url_array( $parts, $component );\n}\n\n/**\n * Retrieve a specific component from a parsed URL array.\n *\n * @internal\n *\n * @since 4.7.0\n * @access private\n *\n * @link https://secure.php.net/manual/en/function.parse-url.php\n *\n * @param array|false $url_parts The parsed URL. Can be false if the URL failed to parse.\n * @param int         $component The specific component to retrieve. Use one of the PHP\n *                               predefined constants to specify which one.\n *                               Defaults to -1 (= return all parts as an array).\n * @return mixed False on parse failure; Array of URL components on success;\n *               When a specific component has been requested: null if the component\n *               doesn't exist in the given URL; a string or - in the case of\n *               PHP_URL_PORT - integer when it does. See parse_url()'s return values.\n */\nfunction _get_component_from_parsed_url_array( $url_parts, $component = -1 ) {\n\tif ( -1 === $component ) {\n\t\treturn $url_parts;\n\t}\n\n\t$key = _wp_translate_php_url_constant_to_key( $component );\n\tif ( false !== $key && is_array( $url_parts ) && isset( $url_parts[ $key ] ) ) {\n\t\treturn $url_parts[ $key ];\n\t} else {\n\t\treturn null;\n\t}\n}\n\n/**\n * Translate a PHP_URL_* constant to the named array keys PHP uses.\n *\n * @internal\n *\n * @since 4.7.0\n * @access private\n *\n * @link https://secure.php.net/manual/en/url.constants.php\n *\n * @param int $constant PHP_URL_* constant.\n * @return string|false The named key or false.\n */\nfunction _wp_translate_php_url_constant_to_key( $constant ) {\n\t$translation = array(\n\t\tPHP_URL_SCHEME   => 'scheme',\n\t\tPHP_URL_HOST     => 'host',\n\t\tPHP_URL_PORT     => 'port',\n\t\tPHP_URL_USER     => 'user',\n\t\tPHP_URL_PASS     => 'pass',\n\t\tPHP_URL_PATH     => 'path',\n\t\tPHP_URL_QUERY    => 'query',\n\t\tPHP_URL_FRAGMENT => 'fragment',\n\t);\n\n\tif ( isset( $translation[ $constant ] ) ) {\n\t\treturn $translation[ $constant ];\n\t} else {\n\t\treturn false;\n\t}\n}\n", "<?php\n/**\n * WordPress Version\n *\n * Contains version information for the current WordPress release.\n *\n * @package WordPress\n * @since 1.1.0\n */\n\n/**\n * The WordPress version string\n *\n * @global string $wp_version\n */\n$wp_version = '5.3-beta3-46474';\n\n/**\n * Holds the WordPress DB revision, increments when changes are made to the WordPress DB schema.\n *\n * @global int $wp_db_version\n */\n$wp_db_version = 45805;\n\n/**\n * Holds the TinyMCE version\n *\n * @global string $tinymce_version\n */\n$tinymce_version = '4960-20190918';\n\n/**\n * Holds the required PHP version\n *\n * @global string $required_php_version\n */\n$required_php_version = '5.6.20';\n\n/**\n * Holds the required MySQL version\n *\n * @global string $required_mysql_version\n */\n$required_mysql_version = '5.0';\n"], "fixing_code": ["<?php\n/**\n * Core HTTP Request API\n *\n * Standardizes the HTTP requests for WordPress. Handles cookies, gzip encoding and decoding, chunk\n * decoding, if HTTP 1.1 and various other difficult HTTP protocol implementations.\n *\n * @package WordPress\n * @subpackage HTTP\n */\n\n/**\n * Returns the initialized WP_Http Object\n *\n * @since 2.7.0\n * @access private\n *\n * @staticvar WP_Http $http\n *\n * @return WP_Http HTTP Transport object.\n */\nfunction _wp_http_get_object() {\n\tstatic $http = null;\n\n\tif ( is_null( $http ) ) {\n\t\t$http = new WP_Http();\n\t}\n\treturn $http;\n}\n\n/**\n * Retrieve the raw response from a safe HTTP request.\n *\n * This function is ideal when the HTTP request is being made to an arbitrary\n * URL. The URL is validated to avoid redirection and request forgery attacks.\n *\n * @since 3.6.0\n *\n * @see wp_remote_request() For more information on the response array format.\n * @see WP_Http::request() For default arguments information.\n *\n * @param string $url  URL to retrieve.\n * @param array  $args Optional. Request arguments. Default empty array.\n * @return WP_Error|array The response or WP_Error on failure.\n */\nfunction wp_safe_remote_request( $url, $args = array() ) {\n\t$args['reject_unsafe_urls'] = true;\n\t$http                       = _wp_http_get_object();\n\treturn $http->request( $url, $args );\n}\n\n/**\n * Retrieve the raw response from a safe HTTP request using the GET method.\n *\n * This function is ideal when the HTTP request is being made to an arbitrary\n * URL. The URL is validated to avoid redirection and request forgery attacks.\n *\n * @since 3.6.0\n *\n * @see wp_remote_request() For more information on the response array format.\n * @see WP_Http::request() For default arguments information.\n *\n * @param string $url  URL to retrieve.\n * @param array  $args Optional. Request arguments. Default empty array.\n * @return WP_Error|array The response or WP_Error on failure.\n */\nfunction wp_safe_remote_get( $url, $args = array() ) {\n\t$args['reject_unsafe_urls'] = true;\n\t$http                       = _wp_http_get_object();\n\treturn $http->get( $url, $args );\n}\n\n/**\n * Retrieve the raw response from a safe HTTP request using the POST method.\n *\n * This function is ideal when the HTTP request is being made to an arbitrary\n * URL. The URL is validated to avoid redirection and request forgery attacks.\n *\n * @since 3.6.0\n *\n * @see wp_remote_request() For more information on the response array format.\n * @see WP_Http::request() For default arguments information.\n *\n * @param string $url  URL to retrieve.\n * @param array  $args Optional. Request arguments. Default empty array.\n * @return WP_Error|array The response or WP_Error on failure.\n */\nfunction wp_safe_remote_post( $url, $args = array() ) {\n\t$args['reject_unsafe_urls'] = true;\n\t$http                       = _wp_http_get_object();\n\treturn $http->post( $url, $args );\n}\n\n/**\n * Retrieve the raw response from a safe HTTP request using the HEAD method.\n *\n * This function is ideal when the HTTP request is being made to an arbitrary\n * URL. The URL is validated to avoid redirection and request forgery attacks.\n *\n * @since 3.6.0\n *\n * @see wp_remote_request() For more information on the response array format.\n * @see WP_Http::request() For default arguments information.\n *\n * @param string $url  URL to retrieve.\n * @param array  $args Optional. Request arguments. Default empty array.\n * @return WP_Error|array The response or WP_Error on failure.\n */\nfunction wp_safe_remote_head( $url, $args = array() ) {\n\t$args['reject_unsafe_urls'] = true;\n\t$http                       = _wp_http_get_object();\n\treturn $http->head( $url, $args );\n}\n\n/**\n * Performs an HTTP request and returns its response.\n *\n * There are other API functions available which abstract away the HTTP method:\n *\n *  - Default 'GET'  for wp_remote_get()\n *  - Default 'POST' for wp_remote_post()\n *  - Default 'HEAD' for wp_remote_head()\n *\n * @since 2.7.0\n *\n * @see WP_Http::request() For information on default arguments.\n *\n * @param string $url  URL to retrieve.\n * @param array  $args Optional. Request arguments. Default empty array.\n * @return WP_Error|array {\n *     The response array or a WP_Error on failure.\n *\n *     @type string[]                       $headers       Array of response headers keyed by their name.\n *     @type string                         $body          Response body.\n *     @type array                          $response      {\n *         Data about the HTTP response.\n *\n *         @type int|false    $code    HTTP response code.\n *         @type string|false $message HTTP response message.\n *     }\n *     @type WP_HTTP_Cookie[]               $cookies       Array of response cookies.\n *     @type WP_HTTP_Requests_Response|null $http_response Raw HTTP response object.\n * }\n */\nfunction wp_remote_request( $url, $args = array() ) {\n\t$http = _wp_http_get_object();\n\treturn $http->request( $url, $args );\n}\n\n/**\n * Performs an HTTP request using the GET method and returns its response.\n *\n * @since 2.7.0\n *\n * @see wp_remote_request() For more information on the response array format.\n * @see WP_Http::request() For default arguments information.\n *\n * @param string $url  URL to retrieve.\n * @param array  $args Optional. Request arguments. Default empty array.\n * @return WP_Error|array The response or WP_Error on failure.\n */\nfunction wp_remote_get( $url, $args = array() ) {\n\t$http = _wp_http_get_object();\n\treturn $http->get( $url, $args );\n}\n\n/**\n * Performs an HTTP request using the POST method and returns its response.\n *\n * @since 2.7.0\n *\n * @see wp_remote_request() For more information on the response array format.\n * @see WP_Http::request() For default arguments information.\n *\n * @param string $url  URL to retrieve.\n * @param array  $args Optional. Request arguments. Default empty array.\n * @return WP_Error|array The response or WP_Error on failure.\n */\nfunction wp_remote_post( $url, $args = array() ) {\n\t$http = _wp_http_get_object();\n\treturn $http->post( $url, $args );\n}\n\n/**\n * Performs an HTTP request using the HEAD method and returns its response.\n *\n * @since 2.7.0\n *\n * @see wp_remote_request() For more information on the response array format.\n * @see WP_Http::request() For default arguments information.\n *\n * @param string $url  URL to retrieve.\n * @param array  $args Optional. Request arguments. Default empty array.\n * @return WP_Error|array The response or WP_Error on failure.\n */\nfunction wp_remote_head( $url, $args = array() ) {\n\t$http = _wp_http_get_object();\n\treturn $http->head( $url, $args );\n}\n\n/**\n * Retrieve only the headers from the raw response.\n *\n * @since 2.7.0\n * @since 4.6.0 Return value changed from an array to an Requests_Utility_CaseInsensitiveDictionary instance.\n *\n * @see \\Requests_Utility_CaseInsensitiveDictionary\n *\n * @param array|WP_Error $response HTTP response.\n * @return array|\\Requests_Utility_CaseInsensitiveDictionary The headers of the response. Empty array if incorrect parameter given.\n */\nfunction wp_remote_retrieve_headers( $response ) {\n\tif ( is_wp_error( $response ) || ! isset( $response['headers'] ) ) {\n\t\treturn array();\n\t}\n\n\treturn $response['headers'];\n}\n\n/**\n * Retrieve a single header by name from the raw response.\n *\n * @since 2.7.0\n *\n * @param array|WP_Error $response HTTP response.\n * @param string         $header   Header name to retrieve value from.\n * @return string The header value. Empty string on if incorrect parameter given, or if the header doesn't exist.\n */\nfunction wp_remote_retrieve_header( $response, $header ) {\n\tif ( is_wp_error( $response ) || ! isset( $response['headers'] ) ) {\n\t\treturn '';\n\t}\n\n\tif ( isset( $response['headers'][ $header ] ) ) {\n\t\treturn $response['headers'][ $header ];\n\t}\n\n\treturn '';\n}\n\n/**\n * Retrieve only the response code from the raw response.\n *\n * Will return an empty array if incorrect parameter value is given.\n *\n * @since 2.7.0\n *\n * @param array|WP_Error $response HTTP response.\n * @return int|string The response code as an integer. Empty string on incorrect parameter given.\n */\nfunction wp_remote_retrieve_response_code( $response ) {\n\tif ( is_wp_error( $response ) || ! isset( $response['response'] ) || ! is_array( $response['response'] ) ) {\n\t\treturn '';\n\t}\n\n\treturn $response['response']['code'];\n}\n\n/**\n * Retrieve only the response message from the raw response.\n *\n * Will return an empty array if incorrect parameter value is given.\n *\n * @since 2.7.0\n *\n * @param array|WP_Error $response HTTP response.\n * @return string The response message. Empty string on incorrect parameter given.\n */\nfunction wp_remote_retrieve_response_message( $response ) {\n\tif ( is_wp_error( $response ) || ! isset( $response['response'] ) || ! is_array( $response['response'] ) ) {\n\t\treturn '';\n\t}\n\n\treturn $response['response']['message'];\n}\n\n/**\n * Retrieve only the body from the raw response.\n *\n * @since 2.7.0\n *\n * @param array|WP_Error $response HTTP response.\n * @return string The body of the response. Empty string if no body or incorrect parameter given.\n */\nfunction wp_remote_retrieve_body( $response ) {\n\tif ( is_wp_error( $response ) || ! isset( $response['body'] ) ) {\n\t\treturn '';\n\t}\n\n\treturn $response['body'];\n}\n\n/**\n * Retrieve only the cookies from the raw response.\n *\n * @since 4.4.0\n *\n * @param array|WP_Error $response HTTP response.\n * @return WP_Http_Cookie[] An array of `WP_Http_Cookie` objects from the response. Empty array if there are none, or the response is a WP_Error.\n */\nfunction wp_remote_retrieve_cookies( $response ) {\n\tif ( is_wp_error( $response ) || empty( $response['cookies'] ) ) {\n\t\treturn array();\n\t}\n\n\treturn $response['cookies'];\n}\n\n/**\n * Retrieve a single cookie by name from the raw response.\n *\n * @since 4.4.0\n *\n * @param array|WP_Error $response HTTP response.\n * @param string         $name     The name of the cookie to retrieve.\n * @return WP_Http_Cookie|string The `WP_Http_Cookie` object. Empty string if the cookie isn't present in the response.\n */\nfunction wp_remote_retrieve_cookie( $response, $name ) {\n\t$cookies = wp_remote_retrieve_cookies( $response );\n\n\tif ( empty( $cookies ) ) {\n\t\treturn '';\n\t}\n\n\tforeach ( $cookies as $cookie ) {\n\t\tif ( $cookie->name === $name ) {\n\t\t\treturn $cookie;\n\t\t}\n\t}\n\n\treturn '';\n}\n\n/**\n * Retrieve a single cookie's value by name from the raw response.\n *\n * @since 4.4.0\n *\n * @param array|WP_Error $response HTTP response.\n * @param string         $name     The name of the cookie to retrieve.\n * @return string The value of the cookie. Empty string if the cookie isn't present in the response.\n */\nfunction wp_remote_retrieve_cookie_value( $response, $name ) {\n\t$cookie = wp_remote_retrieve_cookie( $response, $name );\n\n\tif ( ! is_a( $cookie, 'WP_Http_Cookie' ) ) {\n\t\treturn '';\n\t}\n\n\treturn $cookie->value;\n}\n\n/**\n * Determines if there is an HTTP Transport that can process this request.\n *\n * @since 3.2.0\n *\n * @param array  $capabilities Array of capabilities to test or a wp_remote_request() $args array.\n * @param string $url          Optional. If given, will check if the URL requires SSL and adds\n *                             that requirement to the capabilities array.\n *\n * @return bool\n */\nfunction wp_http_supports( $capabilities = array(), $url = null ) {\n\t$http = _wp_http_get_object();\n\n\t$capabilities = wp_parse_args( $capabilities );\n\n\t$count = count( $capabilities );\n\n\t// If we have a numeric $capabilities array, spoof a wp_remote_request() associative $args array\n\tif ( $count && count( array_filter( array_keys( $capabilities ), 'is_numeric' ) ) == $count ) {\n\t\t$capabilities = array_combine( array_values( $capabilities ), array_fill( 0, $count, true ) );\n\t}\n\n\tif ( $url && ! isset( $capabilities['ssl'] ) ) {\n\t\t$scheme = parse_url( $url, PHP_URL_SCHEME );\n\t\tif ( 'https' == $scheme || 'ssl' == $scheme ) {\n\t\t\t$capabilities['ssl'] = true;\n\t\t}\n\t}\n\n\treturn (bool) $http->_get_first_available_transport( $capabilities );\n}\n\n/**\n * Get the HTTP Origin of the current request.\n *\n * @since 3.4.0\n *\n * @return string URL of the origin. Empty string if no origin.\n */\nfunction get_http_origin() {\n\t$origin = '';\n\tif ( ! empty( $_SERVER['HTTP_ORIGIN'] ) ) {\n\t\t$origin = $_SERVER['HTTP_ORIGIN'];\n\t}\n\n\t/**\n\t * Change the origin of an HTTP request.\n\t *\n\t * @since 3.4.0\n\t *\n\t * @param string $origin The original origin for the request.\n\t */\n\treturn apply_filters( 'http_origin', $origin );\n}\n\n/**\n * Retrieve list of allowed HTTP origins.\n *\n * @since 3.4.0\n *\n * @return string[] Array of origin URLs.\n */\nfunction get_allowed_http_origins() {\n\t$admin_origin = parse_url( admin_url() );\n\t$home_origin  = parse_url( home_url() );\n\n\t// @todo preserve port?\n\t$allowed_origins = array_unique(\n\t\tarray(\n\t\t\t'http://' . $admin_origin['host'],\n\t\t\t'https://' . $admin_origin['host'],\n\t\t\t'http://' . $home_origin['host'],\n\t\t\t'https://' . $home_origin['host'],\n\t\t)\n\t);\n\n\t/**\n\t * Change the origin types allowed for HTTP requests.\n\t *\n\t * @since 3.4.0\n\t *\n\t * @param string[] $allowed_origins {\n\t *     Array of default allowed HTTP origins.\n\t *\n\t *     @type string $0 Non-secure URL for admin origin.\n\t *     @type string $1 Secure URL for admin origin.\n\t *     @type string $2 Non-secure URL for home origin.\n\t *     @type string $3 Secure URL for home origin.\n\t * }\n\t */\n\treturn apply_filters( 'allowed_http_origins', $allowed_origins );\n}\n\n/**\n * Determines if the HTTP origin is an authorized one.\n *\n * @since 3.4.0\n *\n * @param null|string $origin Origin URL. If not provided, the value of get_http_origin() is used.\n * @return string Origin URL if allowed, empty string if not.\n */\nfunction is_allowed_http_origin( $origin = null ) {\n\t$origin_arg = $origin;\n\n\tif ( null === $origin ) {\n\t\t$origin = get_http_origin();\n\t}\n\n\tif ( $origin && ! in_array( $origin, get_allowed_http_origins() ) ) {\n\t\t$origin = '';\n\t}\n\n\t/**\n\t * Change the allowed HTTP origin result.\n\t *\n\t * @since 3.4.0\n\t *\n\t * @param string $origin     Origin URL if allowed, empty string if not.\n\t * @param string $origin_arg Original origin string passed into is_allowed_http_origin function.\n\t */\n\treturn apply_filters( 'allowed_http_origin', $origin, $origin_arg );\n}\n\n/**\n * Send Access-Control-Allow-Origin and related headers if the current request\n * is from an allowed origin.\n *\n * If the request is an OPTIONS request, the script exits with either access\n * control headers sent, or a 403 response if the origin is not allowed. For\n * other request methods, you will receive a return value.\n *\n * @since 3.4.0\n *\n * @return string|false Returns the origin URL if headers are sent. Returns false\n *                      if headers are not sent.\n */\nfunction send_origin_headers() {\n\t$origin = get_http_origin();\n\n\tif ( is_allowed_http_origin( $origin ) ) {\n\t\theader( 'Access-Control-Allow-Origin: ' . $origin );\n\t\theader( 'Access-Control-Allow-Credentials: true' );\n\t\tif ( 'OPTIONS' === $_SERVER['REQUEST_METHOD'] ) {\n\t\t\texit;\n\t\t}\n\t\treturn $origin;\n\t}\n\n\tif ( 'OPTIONS' === $_SERVER['REQUEST_METHOD'] ) {\n\t\tstatus_header( 403 );\n\t\texit;\n\t}\n\n\treturn false;\n}\n\n/**\n * Validate a URL for safe use in the HTTP API.\n *\n * @since 3.5.2\n *\n * @param string $url Request URL.\n * @return false|string URL or false on failure.\n */\nfunction wp_http_validate_url( $url ) {\n\t$original_url = $url;\n\t$url          = wp_kses_bad_protocol( $url, array( 'http', 'https' ) );\n\tif ( ! $url || strtolower( $url ) !== strtolower( $original_url ) ) {\n\t\treturn false;\n\t}\n\n\t$parsed_url = @parse_url( $url );\n\tif ( ! $parsed_url || empty( $parsed_url['host'] ) ) {\n\t\treturn false;\n\t}\n\n\tif ( isset( $parsed_url['user'] ) || isset( $parsed_url['pass'] ) ) {\n\t\treturn false;\n\t}\n\n\tif ( false !== strpbrk( $parsed_url['host'], ':#?[]' ) ) {\n\t\treturn false;\n\t}\n\n\t$parsed_home = @parse_url( get_option( 'home' ) );\n\n\tif ( isset( $parsed_home['host'] ) ) {\n\t\t$same_host = strtolower( $parsed_home['host'] ) === strtolower( $parsed_url['host'] );\n\t} else {\n\t\t$same_host = false;\n\t}\n\n\tif ( ! $same_host ) {\n\t\t$host = trim( $parsed_url['host'], '.' );\n\t\tif ( preg_match( '#^(([1-9]?\\d|1\\d\\d|25[0-5]|2[0-4]\\d)\\.){3}([1-9]?\\d|1\\d\\d|25[0-5]|2[0-4]\\d)$#', $host ) ) {\n\t\t\t$ip = $host;\n\t\t} else {\n\t\t\t$ip = gethostbyname( $host );\n\t\t\tif ( $ip === $host ) { // Error condition for gethostbyname()\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tif ( $ip ) {\n\t\t\t$parts = array_map( 'intval', explode( '.', $ip ) );\n\t\t\tif ( 127 === $parts[0] || 10 === $parts[0] || 0 === $parts[0]\n\t\t\t\t|| ( 172 === $parts[0] && 16 <= $parts[1] && 31 >= $parts[1] )\n\t\t\t\t|| ( 192 === $parts[0] && 168 === $parts[1] )\n\t\t\t) {\n\t\t\t\t// If host appears local, reject unless specifically allowed.\n\t\t\t\t/**\n\t\t\t\t * Check if HTTP request is external or not.\n\t\t\t\t *\n\t\t\t\t * Allows to change and allow external requests for the HTTP request.\n\t\t\t\t *\n\t\t\t\t * @since 3.6.0\n\t\t\t\t *\n\t\t\t\t * @param bool   $external Whether HTTP request is external or not.\n\t\t\t\t * @param string $host     Host name of the requested URL.\n\t\t\t\t * @param string $url      Requested URL.\n\t\t\t\t */\n\t\t\t\tif ( ! apply_filters( 'http_request_host_is_external', false, $host, $url ) ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif ( empty( $parsed_url['port'] ) ) {\n\t\treturn $url;\n\t}\n\n\t$port = $parsed_url['port'];\n\tif ( 80 === $port || 443 === $port || 8080 === $port ) {\n\t\treturn $url;\n\t}\n\n\tif ( $parsed_home && $same_host && isset( $parsed_home['port'] ) && $parsed_home['port'] === $port ) {\n\t\treturn $url;\n\t}\n\n\treturn false;\n}\n\n/**\n * Whitelists allowed redirect hosts for safe HTTP requests as well.\n *\n * Attached to the {@see 'http_request_host_is_external'} filter.\n *\n * @since 3.6.0\n *\n * @param bool   $is_external\n * @param string $host\n * @return bool\n */\nfunction allowed_http_request_hosts( $is_external, $host ) {\n\tif ( ! $is_external && wp_validate_redirect( 'http://' . $host ) ) {\n\t\t$is_external = true;\n\t}\n\treturn $is_external;\n}\n\n/**\n * Whitelists any domain in a multisite installation for safe HTTP requests.\n *\n * Attached to the {@see 'http_request_host_is_external'} filter.\n *\n * @since 3.6.0\n *\n * @global wpdb $wpdb WordPress database abstraction object.\n * @staticvar array $queried\n *\n * @param bool   $is_external\n * @param string $host\n * @return bool\n */\nfunction ms_allowed_http_request_hosts( $is_external, $host ) {\n\tglobal $wpdb;\n\tstatic $queried = array();\n\tif ( $is_external ) {\n\t\treturn $is_external;\n\t}\n\tif ( $host === get_network()->domain ) {\n\t\treturn true;\n\t}\n\tif ( isset( $queried[ $host ] ) ) {\n\t\treturn $queried[ $host ];\n\t}\n\t$queried[ $host ] = (bool) $wpdb->get_var( $wpdb->prepare( \"SELECT domain FROM $wpdb->blogs WHERE domain = %s LIMIT 1\", $host ) );\n\treturn $queried[ $host ];\n}\n\n/**\n * A wrapper for PHP's parse_url() function that handles consistency in the return\n * values across PHP versions.\n *\n * PHP 5.4.7 expanded parse_url()'s ability to handle non-absolute url's, including\n * schemeless and relative url's with :// in the path. This function works around\n * those limitations providing a standard output on PHP 5.2~5.4+.\n *\n * Secondly, across various PHP versions, schemeless URLs starting containing a \":\"\n * in the query are being handled inconsistently. This function works around those\n * differences as well.\n *\n * Error suppression is used as prior to PHP 5.3.3, an E_WARNING would be generated\n * when URL parsing failed.\n *\n * @since 4.4.0\n * @since 4.7.0 The `$component` parameter was added for parity with PHP's `parse_url()`.\n *\n * @link https://secure.php.net/manual/en/function.parse-url.php\n *\n * @param string $url       The URL to parse.\n * @param int    $component The specific component to retrieve. Use one of the PHP\n *                          predefined constants to specify which one.\n *                          Defaults to -1 (= return all parts as an array).\n * @return mixed False on parse failure; Array of URL components on success;\n *               When a specific component has been requested: null if the component\n *               doesn't exist in the given URL; a string or - in the case of\n *               PHP_URL_PORT - integer when it does. See parse_url()'s return values.\n */\nfunction wp_parse_url( $url, $component = -1 ) {\n\t$to_unset = array();\n\t$url      = strval( $url );\n\n\tif ( '//' === substr( $url, 0, 2 ) ) {\n\t\t$to_unset[] = 'scheme';\n\t\t$url        = 'placeholder:' . $url;\n\t} elseif ( '/' === substr( $url, 0, 1 ) ) {\n\t\t$to_unset[] = 'scheme';\n\t\t$to_unset[] = 'host';\n\t\t$url        = 'placeholder://placeholder' . $url;\n\t}\n\n\t$parts = @parse_url( $url );\n\n\tif ( false === $parts ) {\n\t\t// Parsing failure.\n\t\treturn $parts;\n\t}\n\n\t// Remove the placeholder values.\n\tforeach ( $to_unset as $key ) {\n\t\tunset( $parts[ $key ] );\n\t}\n\n\treturn _get_component_from_parsed_url_array( $parts, $component );\n}\n\n/**\n * Retrieve a specific component from a parsed URL array.\n *\n * @internal\n *\n * @since 4.7.0\n * @access private\n *\n * @link https://secure.php.net/manual/en/function.parse-url.php\n *\n * @param array|false $url_parts The parsed URL. Can be false if the URL failed to parse.\n * @param int         $component The specific component to retrieve. Use one of the PHP\n *                               predefined constants to specify which one.\n *                               Defaults to -1 (= return all parts as an array).\n * @return mixed False on parse failure; Array of URL components on success;\n *               When a specific component has been requested: null if the component\n *               doesn't exist in the given URL; a string or - in the case of\n *               PHP_URL_PORT - integer when it does. See parse_url()'s return values.\n */\nfunction _get_component_from_parsed_url_array( $url_parts, $component = -1 ) {\n\tif ( -1 === $component ) {\n\t\treturn $url_parts;\n\t}\n\n\t$key = _wp_translate_php_url_constant_to_key( $component );\n\tif ( false !== $key && is_array( $url_parts ) && isset( $url_parts[ $key ] ) ) {\n\t\treturn $url_parts[ $key ];\n\t} else {\n\t\treturn null;\n\t}\n}\n\n/**\n * Translate a PHP_URL_* constant to the named array keys PHP uses.\n *\n * @internal\n *\n * @since 4.7.0\n * @access private\n *\n * @link https://secure.php.net/manual/en/url.constants.php\n *\n * @param int $constant PHP_URL_* constant.\n * @return string|false The named key or false.\n */\nfunction _wp_translate_php_url_constant_to_key( $constant ) {\n\t$translation = array(\n\t\tPHP_URL_SCHEME   => 'scheme',\n\t\tPHP_URL_HOST     => 'host',\n\t\tPHP_URL_PORT     => 'port',\n\t\tPHP_URL_USER     => 'user',\n\t\tPHP_URL_PASS     => 'pass',\n\t\tPHP_URL_PATH     => 'path',\n\t\tPHP_URL_QUERY    => 'query',\n\t\tPHP_URL_FRAGMENT => 'fragment',\n\t);\n\n\tif ( isset( $translation[ $constant ] ) ) {\n\t\treturn $translation[ $constant ];\n\t} else {\n\t\treturn false;\n\t}\n}\n", "<?php\n/**\n * WordPress Version\n *\n * Contains version information for the current WordPress release.\n *\n * @package WordPress\n * @since 1.1.0\n */\n\n/**\n * The WordPress version string\n *\n * @global string $wp_version\n */\n$wp_version = '5.3-beta3-46475';\n\n/**\n * Holds the WordPress DB revision, increments when changes are made to the WordPress DB schema.\n *\n * @global int $wp_db_version\n */\n$wp_db_version = 45805;\n\n/**\n * Holds the TinyMCE version\n *\n * @global string $tinymce_version\n */\n$tinymce_version = '4960-20190918';\n\n/**\n * Holds the required PHP version\n *\n * @global string $required_php_version\n */\n$required_php_version = '5.6.20';\n\n/**\n * Holds the required MySQL version\n *\n * @global string $required_mysql_version\n */\n$required_mysql_version = '5.0';\n"], "filenames": ["wp-includes/http.php", "wp-includes/version.php"], "buggy_code_start_loc": [553, 16], "buggy_code_end_loc": [554, 17], "fixing_code_start_loc": [553, 16], "fixing_code_end_loc": [554, 17], "type": "CWE-918", "message": "WordPress before 5.2.4 has a Server Side Request Forgery (SSRF) vulnerability because URL validation does not consider the interpretation of a name as a series of hex characters.", "other": {"cve": {"id": "CVE-2019-17669", "sourceIdentifier": "cve@mitre.org", "published": "2019-10-17T13:15:10.733", "lastModified": "2023-02-03T21:50:44.317", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "WordPress before 5.2.4 has a Server Side Request Forgery (SSRF) vulnerability because URL validation does not consider the interpretation of a name as a series of hex characters."}, {"lang": "es", "value": "WordPress versiones anteriores a 5.2.4, presenta una vulnerabilidad de tipo Server Side Request Forgery (SSRF) porque la comprobaci\u00f3n de URL no considera la interpretaci\u00f3n de un nombre como una serie de caracteres hexadecimales."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-918"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:wordpress:wordpress:*:*:*:*:*:*:*:*", "versionEndExcluding": "5.2.4", "matchCriteriaId": "954E75B0-6B64-4856-B36D-4EBD80FBDC1B"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}]}]}], "references": [{"url": "https://blog.wpscan.org/wordpress/security/release/2019/10/15/wordpress-524-security-release-breakdown.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://core.trac.wordpress.org/changeset/46475", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}, {"url": "https://github.com/WordPress/WordPress/commit/608d39faed63ea212b6c6cdf9fe2bef92e2120ea", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2019/11/msg00000.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://seclists.org/bugtraq/2020/Jan/8", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://wordpress.org/news/2019/10/wordpress-5-2-4-security-release/", "source": "cve@mitre.org", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "https://wpvulndb.com/vulnerabilities/9912", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2020/dsa-4599", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2020/dsa-4677", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/WordPress/WordPress/commit/608d39faed63ea212b6c6cdf9fe2bef92e2120ea"}}