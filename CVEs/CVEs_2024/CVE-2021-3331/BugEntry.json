{"buggy_code": ["<Project xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\r\n\t<PropertyGroup>\r\n\t\t<ProjectGuid>{838C77E9-8237-4097-964C-EBB952D2E9A8}</ProjectGuid>\r\n\t\t<ProjectVersion>15.4</ProjectVersion>\r\n\t\t<Config Condition=\"'$(Config)'==''\">Release</Config>\r\n\t\t<FrameworkType>None</FrameworkType>\r\n\t\t<Base>True</Base>\r\n\t\t<Platform Condition=\"'$(Platform)'==''\">Win32</Platform>\r\n\t\t<TargetedPlatforms>1</TargetedPlatforms>\r\n\t\t<AppType>Console</AppType>\r\n\t</PropertyGroup>\r\n\t<PropertyGroup Condition=\"'$(Config)'=='Base' or '$(Base)'!=''\">\r\n\t\t<Base>true</Base>\r\n\t</PropertyGroup>\r\n\t<PropertyGroup Condition=\"'$(Config)'=='Debug' or '$(Cfg_1)'!=''\">\r\n\t\t<Cfg_1>true</Cfg_1>\r\n\t\t<CfgParent>Base</CfgParent>\r\n\t\t<Base>true</Base>\r\n\t</PropertyGroup>\r\n\t<PropertyGroup Condition=\"'$(Config)'=='Release' or '$(Cfg_2)'!=''\">\r\n\t\t<Cfg_2>true</Cfg_2>\r\n\t\t<CfgParent>Base</CfgParent>\r\n\t\t<Base>true</Base>\r\n\t</PropertyGroup>\r\n\t<PropertyGroup Condition=\"'$(Base)'!=''\">\r\n\t\t<_TCHARMapping>wchar_t</_TCHARMapping>\r\n\t\t<AllPackageLibs>rtl.lib</AllPackageLibs>\r\n\t\t<BCC_AllWarnings>true</BCC_AllWarnings>\r\n\t\t<BCC_ExtendedErrorInfo>true</BCC_ExtendedErrorInfo>\r\n\t\t<BCC_OptimizeForSpeed>true</BCC_OptimizeForSpeed>\r\n\t\t<DCC_CBuilderOutput>JPHNE</DCC_CBuilderOutput>\r\n\t\t<DCC_Namespace>System;Xml;Data;Datasnap;Web;Soap;Vcl;$(DCC_Namespace)</DCC_Namespace>\r\n\t\t<FinalOutputDir>$(FINAL_PATH)\\$(Platform)\\$(Config)</FinalOutputDir>\r\n\t\t<ILINK_LibraryPath>console\\;$(ILINK_LibraryPath)</ILINK_LibraryPath>\r\n\t\t<IncludePath>console\\;$(BDS)\\include;$(BDS)\\include\\windows\\vcl;$(IncludePath)</IncludePath>\r\n\t\t<IntermediateOutputDir>$(INTERM_PATH)\\$(Platform)\\$(Config)</IntermediateOutputDir>\r\n\t\t<LinkPackageStatics>rtl.lib</LinkPackageStatics>\r\n\t\t<Manifest_File>None</Manifest_File>\r\n\t\t<Multithreaded>true</Multithreaded>\r\n\t\t<NoVCL>true</NoVCL>\r\n\t\t<OutputExt>com</OutputExt>\r\n\t\t<PackageImports>rtl.bpi;$(PackageImports)</PackageImports>\r\n\t\t<ProjectType>CppConsoleApplication</ProjectType>\r\n\t\t<SanitizedProjectName>Console</SanitizedProjectName>\r\n\t\t<VerInfo_IncludeVerInfo>true</VerInfo_IncludeVerInfo>\r\n\t\t<VerInfo_Keys>CompanyName=Martin Prikryl;FileDescription=Console interface for WinSCP;FileVersion=5.0.1.0;InternalName=console;LegalCopyright=(c) 2000-2020 Martin Prikryl;LegalTrademarks=;OriginalFilename=winscp.com;ProductName=WinSCP;ProductVersion=5.17.10.0;ReleaseType=stable;WWW=https://winscp.net/</VerInfo_Keys>\r\n\t\t<VerInfo_Locale>1033</VerInfo_Locale>\r\n\t\t<VerInfo_MajorVer>5</VerInfo_MajorVer>\r\n\t\t<VerInfo_MinorVer>0</VerInfo_MinorVer>\r\n\t\t<VerInfo_Release>1</VerInfo_Release>\r\n\t</PropertyGroup>\r\n\t<PropertyGroup Condition=\"'$(Cfg_1)'!=''\">\r\n\t\t<BCC_DebugLineNumbers>true</BCC_DebugLineNumbers>\r\n\t\t<BCC_DisableOptimizations>true</BCC_DisableOptimizations>\r\n\t\t<BCC_InlineFunctionExpansion>false</BCC_InlineFunctionExpansion>\r\n\t\t<BCC_OptimizeForSpeed>false</BCC_OptimizeForSpeed>\r\n\t\t<BCC_SourceDebuggingOn>true</BCC_SourceDebuggingOn>\r\n\t\t<BCC_StackFrames>true</BCC_StackFrames>\r\n\t\t<BCC_UseRegisterVariables>None</BCC_UseRegisterVariables>\r\n\t\t<DCC_DebugInfoInExe>true</DCC_DebugInfoInExe>\r\n\t\t<DCC_Define>DEBUG</DCC_Define>\r\n\t\t<DCC_Optimize>false</DCC_Optimize>\r\n\t\t<Defines>_DEBUG;$(Defines)</Defines>\r\n\t\t<ILINK_FullDebugInfo>true</ILINK_FullDebugInfo>\r\n\t\t<TASM_Debugging>Full</TASM_Debugging>\r\n\t\t<TASM_DisplaySourceLines>true</TASM_DisplaySourceLines>\r\n\t</PropertyGroup>\r\n\t<PropertyGroup Condition=\"'$(Cfg_2)'!=''\">\r\n\t\t<Defines>NDEBUG;$(Defines)</Defines>\r\n\t\t<TASM_Debugging>None</TASM_Debugging>\r\n\t</PropertyGroup>\r\n\t<ItemGroup>\r\n\t\t<CppCompile Include=\"console\\Main.cpp\">\r\n\t\t\t<BuildOrder>8</BuildOrder>\r\n\t\t\t<BuildOrder>0</BuildOrder>\r\n\t\t</CppCompile>\r\n\t\t<BuildConfiguration Include=\"Base\">\r\n\t\t\t<Key>Base</Key>\r\n\t\t</BuildConfiguration>\r\n\t\t<BuildConfiguration Include=\"Debug\">\r\n\t\t\t<Key>Cfg_1</Key>\r\n\t\t\t<CfgParent>Base</CfgParent>\r\n\t\t</BuildConfiguration>\r\n\t\t<BuildConfiguration Include=\"Release\">\r\n\t\t\t<Key>Cfg_2</Key>\r\n\t\t\t<CfgParent>Base</CfgParent>\r\n\t\t</BuildConfiguration>\r\n\t</ItemGroup>\r\n\t<Import Condition=\"Exists('$(BDS)\\Bin\\CodeGear.Cpp.Targets')\" Project=\"$(BDS)\\Bin\\CodeGear.Cpp.Targets\"/>\r\n\t<PropertyGroup Condition=\"'$(FileToCompile)'==''\">\r\n\t\t<PostBuildEvent>if exist \"$(FinalOutputDir)\\Console.com\" (\r\ncopy /y \"$(FinalOutputDir)\\Console.com\" \"$(FinalOutputDir)\\WinSCP.com\"\r\n) else (\r\nexit 0\r\n)</PostBuildEvent>\r\n\t</PropertyGroup>\r\n\t<ProjectExtensions>\r\n\t\t<Borland.Personality>CPlusPlusBuilder.Personality.12</Borland.Personality>\r\n\t\t<Borland.ProjectType>CppConsoleApplication</Borland.ProjectType>\r\n\t\t<BorlandProject>\r\n\t\t\t<CPlusPlusBuilder.Personality>\r\n\t\t\t\t<ProjectProperties>\r\n\t\t\t\t\t<ProjectProperties Name=\"AutoShowDeps\">False</ProjectProperties>\r\n\t\t\t\t\t<ProjectProperties Name=\"ManagePaths\">True</ProjectProperties>\r\n\t\t\t\t\t<ProjectProperties Name=\"VerifyPackages\">True</ProjectProperties>\r\n\t\t\t\t\t<ProjectProperties Name=\"IndexFiles\">False</ProjectProperties>\r\n\t\t\t\t</ProjectProperties>\r\n\t\t\t</CPlusPlusBuilder.Personality>\r\n\t\t\t<Platforms>\r\n\t\t\t\t<Platform value=\"Win32\">True</Platform>\r\n\t\t\t\t<Platform value=\"Win64\">False</Platform>\r\n\t\t\t</Platforms>\r\n\t\t</BorlandProject>\r\n\t\t<ProjectFileVersion>12</ProjectFileVersion>\r\n\t</ProjectExtensions>\r\n\t<Import Condition=\"Exists('$(APPDATA)\\Embarcadero\\$(BDSAPPDATABASEDIR)\\$(PRODUCTVERSION)\\UserTools.proj')\" Project=\"$(APPDATA)\\Embarcadero\\$(BDSAPPDATABASEDIR)\\$(PRODUCTVERSION)\\UserTools.proj\"/>\r\n</Project>\r\n", "<Project xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\r\n\t<PropertyGroup>\r\n\t\t<ProjectGuid>{414309A3-9B7C-4261-9989-4BC118D3A1C0}</ProjectGuid>\r\n\t\t<ProjectVersion>15.4</ProjectVersion>\r\n\t\t<Config Condition=\"'$(Config)'==''\">Release</Config>\r\n\t\t<FrameworkType>None</FrameworkType>\r\n\t\t<Base>True</Base>\r\n\t\t<Platform Condition=\"'$(Platform)'==''\">Win32</Platform>\r\n\t\t<TargetedPlatforms>3</TargetedPlatforms>\r\n\t\t<AppType>Library</AppType>\r\n\t</PropertyGroup>\r\n\t<PropertyGroup Condition=\"'$(Config)'=='Base' or '$(Base)'!=''\">\r\n\t\t<Base>true</Base>\r\n\t</PropertyGroup>\r\n\t<PropertyGroup Condition=\"('$(Platform)'=='Win64' and '$(Base)'=='true') or '$(Base_Win64)'!=''\">\r\n\t\t<Base_Win64>true</Base_Win64>\r\n\t\t<CfgParent>Base</CfgParent>\r\n\t\t<Base>true</Base>\r\n\t</PropertyGroup>\r\n\t<PropertyGroup Condition=\"'$(Config)'=='Debug' or '$(Cfg_1)'!=''\">\r\n\t\t<Cfg_1>true</Cfg_1>\r\n\t\t<CfgParent>Base</CfgParent>\r\n\t\t<Base>true</Base>\r\n\t</PropertyGroup>\r\n\t<PropertyGroup Condition=\"'$(Config)'=='Release' or '$(Cfg_2)'!=''\">\r\n\t\t<Cfg_2>true</Cfg_2>\r\n\t\t<CfgParent>Base</CfgParent>\r\n\t\t<Base>true</Base>\r\n\t</PropertyGroup>\r\n\t<PropertyGroup Condition=\"'$(Base)'!=''\">\r\n\t\t<_TCHARMapping>wchar_t</_TCHARMapping>\r\n\t\t<BCC_AllWarnings>true</BCC_AllWarnings>\r\n\t\t<BCC_ExtendedErrorInfo>true</BCC_ExtendedErrorInfo>\r\n\t\t<BCC_OptimizeForSpeed>true</BCC_OptimizeForSpeed>\r\n\t\t<BCC_wdlx>false</BCC_wdlx>\r\n\t\t<DCC_CBuilderOutput>JPHNE</DCC_CBuilderOutput>\r\n\t\t<DCC_Namespace>System;Xml;Data;Datasnap;Web;Soap;Vcl;$(DCC_Namespace)</DCC_Namespace>\r\n\t\t<FinalOutputDir>$(FINAL_PATH)\\$(Platform)\\$(Config)</FinalOutputDir>\r\n\t\t<ILINK_GenerateImportLibrary>true</ILINK_GenerateImportLibrary>\r\n\t\t<ILINK_LibraryPath>dragext\\;$(BDS)\\lib;$(BDS)\\lib\\obj;$(BDS)\\lib\\psdk;$(ILINK_LibraryPath)</ILINK_LibraryPath>\r\n\t\t<IncludePath>dragext\\;$(BDS)\\include;$(BDS)\\include\\windows\\vcl;$(IncludePath)</IncludePath>\r\n\t\t<IntermediateOutputDir>$(INTERM_PATH)\\$(Platform)\\$(Config)</IntermediateOutputDir>\r\n\t\t<Manifest_File>None</Manifest_File>\r\n\t\t<Multithreaded>true</Multithreaded>\r\n\t\t<NoVCL>true</NoVCL>\r\n\t\t<OutputExt>dll</OutputExt>\r\n\t\t<PackageImports>rtl.bpi;$(PackageImports)</PackageImports>\r\n\t\t<ProjectType>CppDynamicLibrary</ProjectType>\r\n\t\t<SanitizedProjectName>DragExt</SanitizedProjectName>\r\n\t\t<VerInfo_DLL>true</VerInfo_DLL>\r\n\t\t<VerInfo_IncludeVerInfo>true</VerInfo_IncludeVerInfo>\r\n\t\t<VerInfo_Keys>CompanyName=Martin Prikryl;FileDescription=Drag&amp;Drop shell extension for WinSCP ($(Platform));FileVersion=2.0.0.0;InternalName=dragext;LegalCopyright=(c) 2000-2020 Martin Prikryl;LegalTrademarks=;OriginalFilename=dragext.dll;ProductName=WinSCP;ProductVersion=5.17.10.0;ReleaseType=stable;WWW=https://winscp.net/</VerInfo_Keys>\r\n\t\t<VerInfo_Locale>1033</VerInfo_Locale>\r\n\t\t<VerInfo_MajorVer>2</VerInfo_MajorVer>\r\n\t</PropertyGroup>\r\n\t<PropertyGroup Condition=\"'$(Base_Win64)'!=''\">\r\n\t\t<OutputName>DragExt64</OutputName>\r\n\t</PropertyGroup>\r\n\t<PropertyGroup Condition=\"'$(Cfg_1)'!=''\">\r\n\t\t<BCC_DebugLineNumbers>true</BCC_DebugLineNumbers>\r\n\t\t<BCC_DisableOptimizations>true</BCC_DisableOptimizations>\r\n\t\t<BCC_InlineFunctionExpansion>false</BCC_InlineFunctionExpansion>\r\n\t\t<BCC_OptimizeForSpeed>false</BCC_OptimizeForSpeed>\r\n\t\t<BCC_SourceDebuggingOn>true</BCC_SourceDebuggingOn>\r\n\t\t<BCC_StackFrames>true</BCC_StackFrames>\r\n\t\t<BCC_UseRegisterVariables>None</BCC_UseRegisterVariables>\r\n\t\t<DCC_DebugInfoInExe>true</DCC_DebugInfoInExe>\r\n\t\t<DCC_Define>DEBUG</DCC_Define>\r\n\t\t<DCC_Optimize>false</DCC_Optimize>\r\n\t\t<Defines>_DEBUG;$(Defines)</Defines>\r\n\t\t<ILINK_FullDebugInfo>true</ILINK_FullDebugInfo>\r\n\t\t<TASM_Debugging>Full</TASM_Debugging>\r\n\t\t<TASM_DisplaySourceLines>true</TASM_DisplaySourceLines>\r\n\t</PropertyGroup>\r\n\t<PropertyGroup Condition=\"'$(Cfg_2)'!=''\">\r\n\t\t<Defines>NDEBUG;$(Defines)</Defines>\r\n\t\t<TASM_Debugging>None</TASM_Debugging>\r\n\t</PropertyGroup>\r\n\t<ItemGroup>\r\n\t\t<CppCompile Include=\"dragext\\DragExt.cpp\">\r\n\t\t\t<BuildOrder>5</BuildOrder>\r\n\t\t\t<BuildOrder>1</BuildOrder>\r\n\t\t</CppCompile>\r\n\t\t<BuildConfiguration Include=\"Base\">\r\n\t\t\t<Key>Base</Key>\r\n\t\t</BuildConfiguration>\r\n\t\t<BuildConfiguration Include=\"Debug\">\r\n\t\t\t<Key>Cfg_1</Key>\r\n\t\t\t<CfgParent>Base</CfgParent>\r\n\t\t</BuildConfiguration>\r\n\t\t<BuildConfiguration Include=\"Release\">\r\n\t\t\t<Key>Cfg_2</Key>\r\n\t\t\t<CfgParent>Base</CfgParent>\r\n\t\t</BuildConfiguration>\r\n\t</ItemGroup>\r\n\t<Import Condition=\"Exists('$(BDS)\\Bin\\CodeGear.Cpp.Targets')\" Project=\"$(BDS)\\Bin\\CodeGear.Cpp.Targets\"/>\r\n\t<ProjectExtensions>\r\n\t\t<Borland.Personality>CPlusPlusBuilder.Personality.12</Borland.Personality>\r\n\t\t<Borland.ProjectType>CppDynamicLibrary</Borland.ProjectType>\r\n\t\t<BorlandProject>\r\n\t\t\t<CPlusPlusBuilder.Personality>\r\n\t\t\t\t<ProjectProperties>\r\n\t\t\t\t\t<ProjectProperties Name=\"AutoShowDeps\">False</ProjectProperties>\r\n\t\t\t\t\t<ProjectProperties Name=\"ManagePaths\">True</ProjectProperties>\r\n\t\t\t\t\t<ProjectProperties Name=\"VerifyPackages\">True</ProjectProperties>\r\n\t\t\t\t\t<ProjectProperties Name=\"IndexFiles\">False</ProjectProperties>\r\n\t\t\t\t</ProjectProperties>\r\n\t\t\t</CPlusPlusBuilder.Personality>\r\n\t\t\t<Platforms>\r\n\t\t\t\t<Platform value=\"Win32\">True</Platform>\r\n\t\t\t\t<Platform value=\"Win64\">True</Platform>\r\n\t\t\t</Platforms>\r\n\t\t</BorlandProject>\r\n\t\t<ProjectFileVersion>12</ProjectFileVersion>\r\n\t</ProjectExtensions>\r\n\t<Import Condition=\"Exists('$(APPDATA)\\Embarcadero\\$(BDSAPPDATABASEDIR)\\$(PRODUCTVERSION)\\UserTools.proj')\" Project=\"$(APPDATA)\\Embarcadero\\$(BDSAPPDATABASEDIR)\\$(PRODUCTVERSION)\\UserTools.proj\"/>\r\n</Project>\r\n", "<Project xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\r\n\t<PropertyGroup>\r\n\t\t<ProjectGuid>{0B0C5EC6-5DCB-4F16-9504-1E6D37FFBB77}</ProjectGuid>\r\n\t\t<ProjectVersion>15.4</ProjectVersion>\r\n\t\t<MainSource>WinSCP.cpp</MainSource>\r\n\t\t<Config Condition=\"'$(Config)'==''\">Release</Config>\r\n\t\t<FrameworkType>VCL</FrameworkType>\r\n\t\t<Base>True</Base>\r\n\t\t<Platform Condition=\"'$(Platform)'==''\">Win32</Platform>\r\n\t\t<TargetedPlatforms>1</TargetedPlatforms>\r\n\t\t<AppType>Application</AppType>\r\n\t</PropertyGroup>\r\n\t<PropertyGroup Condition=\"'$(Config)'=='Base' or '$(Base)'!=''\">\r\n\t\t<Base>true</Base>\r\n\t</PropertyGroup>\r\n\t<PropertyGroup Condition=\"'$(Config)'=='Debug' or '$(Cfg_1)'!=''\">\r\n\t\t<Cfg_1>true</Cfg_1>\r\n\t\t<CfgParent>Base</CfgParent>\r\n\t\t<Base>true</Base>\r\n\t</PropertyGroup>\r\n\t<PropertyGroup Condition=\"('$(Platform)'=='Win32' and '$(Cfg_1)'=='true') or '$(Cfg_1_Win32)'!=''\">\r\n\t\t<Cfg_1_Win32>true</Cfg_1_Win32>\r\n\t\t<CfgParent>Cfg_1</CfgParent>\r\n\t\t<Cfg_1>true</Cfg_1>\r\n\t\t<Base>true</Base>\r\n\t</PropertyGroup>\r\n\t<PropertyGroup Condition=\"('$(Platform)'=='Win64' and '$(Cfg_1)'=='true') or '$(Cfg_1_Win64)'!=''\">\r\n\t\t<Cfg_1_Win64>true</Cfg_1_Win64>\r\n\t\t<CfgParent>Cfg_1</CfgParent>\r\n\t\t<Cfg_1>true</Cfg_1>\r\n\t\t<Base>true</Base>\r\n\t</PropertyGroup>\r\n\t<PropertyGroup Condition=\"'$(Config)'=='Release' or '$(Cfg_2)'!=''\">\r\n\t\t<Cfg_2>true</Cfg_2>\r\n\t\t<CfgParent>Base</CfgParent>\r\n\t\t<Base>true</Base>\r\n\t</PropertyGroup>\r\n\t<PropertyGroup Condition=\"('$(Platform)'=='Win32' and '$(Cfg_2)'=='true') or '$(Cfg_2_Win32)'!=''\">\r\n\t\t<Cfg_2_Win32>true</Cfg_2_Win32>\r\n\t\t<CfgParent>Cfg_2</CfgParent>\r\n\t\t<Cfg_2>true</Cfg_2>\r\n\t\t<Base>true</Base>\r\n\t</PropertyGroup>\r\n\t<PropertyGroup Condition=\"('$(Platform)'=='Win64' and '$(Cfg_2)'=='true') or '$(Cfg_2_Win64)'!=''\">\r\n\t\t<Cfg_2_Win64>true</Cfg_2_Win64>\r\n\t\t<CfgParent>Cfg_2</CfgParent>\r\n\t\t<Cfg_2>true</Cfg_2>\r\n\t\t<Base>true</Base>\r\n\t</PropertyGroup>\r\n\t<PropertyGroup Condition=\"'$(Base)'!=''\">\r\n\t\t<_TCHARMapping>wchar_t</_TCHARMapping>\r\n\t\t<AllPackageLibs>vcl.lib;rtl.lib;vclx.lib;ws2_32.lib;secur32.lib;My.lib;DriveDir.lib;DragDropP.lib;tb2k.lib;tbxp.lib;bcbie.lib;Crypt32.lib;PngComponents.lib;xmlrtl.lib;vclactnband.lib;vclimg.lib;winhttp.lib;jcl.lib;vclie.lib;urlmon.lib;shlwapi.lib;powrprof.lib;soaprtl.lib;fmx.lib;dbrtl.lib;inet.lib</AllPackageLibs>\r\n\t\t<BCC_AllWarnings>true</BCC_AllWarnings>\r\n\t\t<BCC_ExtendedErrorInfo>true</BCC_ExtendedErrorInfo>\r\n\t\t<BCC_OptimizeForSpeed>true</BCC_OptimizeForSpeed>\r\n\t\t<BCC_wdiu>false</BCC_wdiu>\r\n\t\t<BRCC_CodePage>65001</BRCC_CodePage>\r\n\t\t<DCC_CBuilderOutput>JPHNE</DCC_CBuilderOutput>\r\n\t\t<DCC_Namespace>Vcl;Vcl.Imaging;Vcl.Touch;Vcl.Samples;Vcl.Shell;System;Xml;Data;Datasnap;Web;Soap;Vcl;$(DCC_Namespace)</DCC_Namespace>\r\n\t\t<DCC_SYMBOL_DEPRECATED>false</DCC_SYMBOL_DEPRECATED>\r\n\t\t<DCC_SYMBOL_PLATFORM>false</DCC_SYMBOL_PLATFORM>\r\n\t\t<DCC_UNSUPPORTED_CONSTRUCT>false</DCC_UNSUPPORTED_CONSTRUCT>\r\n\t\t<Defines>STRICT;$(Defines)</Defines>\r\n\t\t<FinalOutputDir>$(FINAL_PATH)\\$(Platform)\\$(Config)</FinalOutputDir>\r\n\t\t<Icon_MainIcon>resource\\Application.ico</Icon_MainIcon>\r\n\t\t<ILINK_GenerateDRC>true</ILINK_GenerateDRC>\r\n\t\t<ILINK_LibraryPath>windows\\;forms\\;packages\\filemng;packages\\tbx;packages\\png;..\\libs\\lib;$(LIB_PATH);$(ILINK_LibraryPath)</ILINK_LibraryPath>\r\n\t\t<ILINK_MapFileType>DetailedSegments</ILINK_MapFileType>\r\n\t\t<IncludePath>console;windows\\;forms\\;core;resource;components;dragext;packages\\filemng;packages\\dragndrop;packages\\my;packages\\tb2k;packages\\tbx;packages\\png;packages\\jcl;$(BDS)\\include\\mfc;$(BDS)\\include\\windows;$(BDS)\\include\\windows\\sdk;$(BDS)\\include\\windows\\vcl;$(IncludePath)</IncludePath>\r\n\t\t<IntermediateOutputDir>$(INTERM_PATH)\\$(Platform)\\$(Config)</IntermediateOutputDir>\r\n\t\t<LinkPackageStatics>vcl.lib;rtl.lib;vclx.lib;ws2_32.lib;secur32.lib;My.lib;DriveDir.lib;DragDropP.lib;tb2k.lib;tbxp.lib;bcbie.lib;Crypt32.lib;PngComponents.lib;xmlrtl.lib;vclactnband.lib;vclimg.lib;winhttp.lib;jcl.lib;vclie.lib;urlmon.lib;shlwapi.lib;powrprof.lib;soaprtl.lib</LinkPackageStatics>\r\n\t\t<Manifest_File>windows\\WinSCP.exe.manifest</Manifest_File>\r\n\t\t<Multithreaded>true</Multithreaded>\r\n\t\t<OutputExt>exe</OutputExt>\r\n\t\t<ProjectType>CppVCLApplication</ProjectType>\r\n\t\t<SanitizedProjectName>WinSCP</SanitizedProjectName>\r\n\t\t<UsingDelphiRTL>true</UsingDelphiRTL>\r\n\t\t<VerInfo_IncludeVerInfo>true</VerInfo_IncludeVerInfo>\r\n\t\t<VerInfo_Keys>CompanyName=Martin Prikryl;FileDescription=WinSCP: SFTP, FTP, WebDAV, S3 and SCP client;FileVersion=5.17.10.0;InternalName=winscp;LegalCopyright=(c) 2000-2020 Martin Prikryl;LegalTrademarks=;OriginalFilename=winscp.exe;ProductName=WinSCP;ProductVersion=5.17.10.0;ReleaseType=stable;WWW=https://winscp.net/</VerInfo_Keys>\r\n\t\t<VerInfo_Locale>1033</VerInfo_Locale>\r\n\t\t<VerInfo_MajorVer>5</VerInfo_MajorVer>\r\n\t\t<VerInfo_MinorVer>17</VerInfo_MinorVer>\r\n\t\t<VerInfo_Release>10</VerInfo_Release>\r\n\t</PropertyGroup>\r\n\t<PropertyGroup Condition=\"'$(Cfg_1)'!=''\">\r\n\t\t<BCC_AllCodeguardOptions>true</BCC_AllCodeguardOptions>\r\n\t\t<BCC_DebugLineNumbers>true</BCC_DebugLineNumbers>\r\n\t\t<BCC_DisableOptimizations>true</BCC_DisableOptimizations>\r\n\t\t<BCC_InlineFunctionExpansion>false</BCC_InlineFunctionExpansion>\r\n\t\t<BCC_MonitorGlobalAndStackData>true</BCC_MonitorGlobalAndStackData>\r\n\t\t<BCC_MonitorInlinePtrAccess>true</BCC_MonitorInlinePtrAccess>\r\n\t\t<BCC_MonitorThis>true</BCC_MonitorThis>\r\n\t\t<BCC_OptimizeForSpeed>false</BCC_OptimizeForSpeed>\r\n\t\t<BCC_SourceDebuggingOn>true</BCC_SourceDebuggingOn>\r\n\t\t<BCC_StackFrames>true</BCC_StackFrames>\r\n\t\t<BCC_UseRegisterVariables>None</BCC_UseRegisterVariables>\r\n\t\t<DCC_DebugDCUs>true</DCC_DebugDCUs>\r\n\t\t<DCC_DebugInfoInExe>true</DCC_DebugInfoInExe>\r\n\t\t<DCC_Define>DEBUG</DCC_Define>\r\n\t\t<DCC_Optimize>false</DCC_Optimize>\r\n\t\t<Debugger_DebugSourcePath>packages\\my;packages\\filemng;packages\\jcl;..\\libs\\openssl\\crypto\\bio;..\\libs\\openssl\\ssl;..\\libs\\openssl\\crypto\\stack;..\\libs\\openssl\\crypto\\x509;..\\libs\\openssl\\crypto\\evp;..\\libs\\openssl\\crypto\\pkcs12;..\\libs\\openssl\\crypto\\pem;..\\libs\\openssl\\crypto\\asn1;..\\libs\\openssl\\crypto\\err;..\\libs\\openssl\\crypto\\rand;..\\libs\\neon\\src;..\\libs\\libs3\\src;..\\libs\\expat\\lib;$(Debugger_DebugSourcePath)</Debugger_DebugSourcePath>\r\n\t\t<Defines>_DEBUG;$(Defines)</Defines>\r\n\t\t<ILINK_FullDebugInfo>true</ILINK_FullDebugInfo>\r\n\t\t<TASM_Debugging>Full</TASM_Debugging>\r\n\t\t<TASM_DisplaySourceLines>true</TASM_DisplaySourceLines>\r\n\t</PropertyGroup>\r\n\t<PropertyGroup Condition=\"'$(Cfg_1_Win32)'!=''\">\r\n\t\t<ILINK_DisableIncrementalLinking>true</ILINK_DisableIncrementalLinking>\r\n\t\t<ILINK_LibraryPath>$(INTERM_PATH)\\Win32\\Debug\\;$(BDS)\\lib\\Win32\\Debug\\;$(BDS)\\lib\\Win32\\Release\\;$(BDS)\\lib\\Win32\\Release\\psdk\\;$(ILINK_LibraryPath)</ILINK_LibraryPath>\r\n\t\t<LinkPackageStatics>vcl.lib;rtl.lib;vclx.lib;ws2_32.lib;secur32.lib;My.lib;DriveDir.lib;DragDropP.lib;tb2k.lib;tbxp.lib;bcbie.lib;Crypt32.lib;PngComponents.lib;xmlrtl.lib;vclactnband.lib;vclimg.lib;winhttp.lib;jcl.lib;vclie.lib;urlmon.lib;shlwapi.lib;powrprof.lib;soaprtl.lib;fmx.lib;dbrtl.lib;inet.lib</LinkPackageStatics>\r\n\t</PropertyGroup>\r\n\t<PropertyGroup Condition=\"'$(Cfg_1_Win64)'!=''\">\r\n\t\t<ILINK_LibraryPath>$(INTERM_PATH)\\Win64\\Debug\\;$(BDS)\\lib\\Win64\\Debug\\;$(BDS)\\lib\\Win64\\Release\\;$(BDS)\\lib\\Win64\\Release\\psdk\\;$(ILINK_LibraryPath)</ILINK_LibraryPath>\r\n\t</PropertyGroup>\r\n\t<PropertyGroup Condition=\"'$(Cfg_2)'!=''\">\r\n\t\t<Defines>NDEBUG;$(Defines)</Defines>\r\n\t\t<TASM_Debugging>None</TASM_Debugging>\r\n\t</PropertyGroup>\r\n\t<PropertyGroup Condition=\"'$(Cfg_2_Win32)'!=''\">\r\n\t\t<ILINK_LibraryPath>$(INTERM_PATH)\\Win32\\Release\\;$(BDS)\\lib\\Win32\\Release\\;$(BDS)\\lib\\Win32\\Release\\psdk\\;$(ILINK_LibraryPath)</ILINK_LibraryPath>\r\n\t</PropertyGroup>\r\n\t<PropertyGroup Condition=\"'$(Cfg_2_Win64)'!=''\">\r\n\t\t<ILINK_LibraryPath>$(INTERM_PATH)\\Win64\\Release\\;$(BDS)\\lib\\Win64\\Release\\;$(BDS)\\lib\\Win64\\Release\\psdk\\;$(ILINK_LibraryPath)</ILINK_LibraryPath>\r\n\t</PropertyGroup>\r\n\t<ItemGroup>\r\n\t\t<CppCompile Include=\"forms\\CustomScpExplorer.cpp\">\r\n\t\t\t<BuildOrder>8</BuildOrder>\r\n\t\t\t<Form>CustomScpExplorerForm</Form>\r\n\t\t\t<DependentOn>forms\\CustomScpExplorer.h</DependentOn>\r\n\t\t\t<BuildOrder>21</BuildOrder>\r\n\t\t</CppCompile>\r\n\t\t<FormResources Include=\"forms\\CustomScpExplorer.dfm\"/>\r\n\t\t<CppCompile Include=\"forms\\NonVisual.cpp\">\r\n\t\t\t<BuildOrder>23</BuildOrder>\r\n\t\t\t<Form>NonVisualDataModule</Form>\r\n\t\t\t<DesignClass>TDataModule</DesignClass>\r\n\t\t\t<DependentOn>forms\\NonVisual.h</DependentOn>\r\n\t\t\t<BuildOrder>22</BuildOrder>\r\n\t\t</CppCompile>\r\n\t\t<FormResources Include=\"forms\\NonVisual.dfm\"/>\r\n\t\t<CppCompile Include=\"forms\\ScpCommander.cpp\">\r\n\t\t\t<BuildOrder>38</BuildOrder>\r\n\t\t\t<Form>ScpCommanderForm</Form>\r\n\t\t\t<DependentOn>forms\\ScpCommander.h</DependentOn>\r\n\t\t\t<BuildOrder>23</BuildOrder>\r\n\t\t</CppCompile>\r\n\t\t<FormResources Include=\"forms\\ScpCommander.dfm\"/>\r\n\t\t<CppCompile Include=\"forms\\ScpExplorer.cpp\">\r\n\t\t\t<BuildOrder>41</BuildOrder>\r\n\t\t\t<Form>ScpExplorerForm</Form>\r\n\t\t\t<DependentOn>forms\\ScpExplorer.h</DependentOn>\r\n\t\t\t<BuildOrder>24</BuildOrder>\r\n\t\t</CppCompile>\r\n\t\t<FormResources Include=\"forms\\ScpExplorer.dfm\"/>\r\n\t\t<CppCompile Include=\"windows\\ConsoleRunner.cpp\">\r\n\t\t\t<BuildOrder>27</BuildOrder>\r\n\t\t\t<BuildOrder>26</BuildOrder>\r\n\t\t</CppCompile>\r\n\t\t<CppCompile Include=\"windows\\CustomWinConfiguration.cpp\">\r\n\t\t\t<BuildOrder>18</BuildOrder>\r\n\t\t\t<BuildOrder>11</BuildOrder>\r\n\t\t</CppCompile>\r\n\t\t<CppCompile Include=\"windows\\EditorManager.cpp\">\r\n\t\t\t<BuildOrder>15</BuildOrder>\r\n\t\t\t<BuildOrder>14</BuildOrder>\r\n\t\t</CppCompile>\r\n\t\t<CppCompile Include=\"windows\\GUIConfiguration.cpp\">\r\n\t\t\t<BuildOrder>17</BuildOrder>\r\n\t\t\t<BuildOrder>16</BuildOrder>\r\n\t\t</CppCompile>\r\n\t\t<CppCompile Include=\"windows\\GUITools.cpp\">\r\n\t\t\t<BuildOrder>20</BuildOrder>\r\n\t\t\t<BuildOrder>17</BuildOrder>\r\n\t\t</CppCompile>\r\n\t\t<CppCompile Include=\"windows\\ProgParams.cpp\">\r\n\t\t\t<BuildOrder>29</BuildOrder>\r\n\t\t\t<BuildOrder>28</BuildOrder>\r\n\t\t</CppCompile>\r\n\t\t<CppCompile Include=\"windows\\QueueController.cpp\">\r\n\t\t\t<BuildOrder>32</BuildOrder>\r\n\t\t\t<BuildOrder>29</BuildOrder>\r\n\t\t</CppCompile>\r\n\t\t<CppCompile Include=\"windows\\Setup.cpp\">\r\n\t\t\t<BuildOrder>35</BuildOrder>\r\n\t\t\t<BuildOrder>26</BuildOrder>\r\n\t\t</CppCompile>\r\n\t\t<CppCompile Include=\"windows\\SynchronizeController.cpp\">\r\n\t\t\t<BuildOrder>44</BuildOrder>\r\n\t\t\t<BuildOrder>25</BuildOrder>\r\n\t\t</CppCompile>\r\n\t\t<CppCompile Include=\"windows\\TerminalManager.cpp\">\r\n\t\t\t<BuildOrder>47</BuildOrder>\r\n\t\t\t<BuildOrder>4</BuildOrder>\r\n\t\t</CppCompile>\r\n\t\t<CppCompile Include=\"windows\\Tools.cpp\">\r\n\t\t\t<BuildOrder>50</BuildOrder>\r\n\t\t\t<BuildOrder>5</BuildOrder>\r\n\t\t</CppCompile>\r\n\t\t<CppCompile Include=\"windows\\UserInterface.cpp\">\r\n\t\t\t<BuildOrder>6</BuildOrder>\r\n\t\t\t<BuildOrder>53</BuildOrder>\r\n\t\t</CppCompile>\r\n\t\t<CppCompile Include=\"windows\\WinConfiguration.cpp\">\r\n\t\t\t<BuildOrder>56</BuildOrder>\r\n\t\t\t<BuildOrder>3</BuildOrder>\r\n\t\t</CppCompile>\r\n\t\t<ResourceCompile Include=\"windows\\Windows.rc\">\r\n\t\t\t<BuildOrder>5</BuildOrder>\r\n\t\t\t<BuildOrder>20</BuildOrder>\r\n\t\t</ResourceCompile>\r\n\t\t<CppCompile Include=\"windows\\WinHelp.cpp\">\r\n\t\t\t<BuildOrder>59</BuildOrder>\r\n\t\t\t<BuildOrder>0</BuildOrder>\r\n\t\t</CppCompile>\r\n\t\t<CppCompile Include=\"windows\\WinInterface.cpp\">\r\n\t\t\t<BuildOrder>62</BuildOrder>\r\n\t\t\t<BuildOrder>1</BuildOrder>\r\n\t\t</CppCompile>\r\n\t\t<CppCompile Include=\"windows\\WinMain.cpp\">\r\n\t\t\t<BuildOrder>65</BuildOrder>\r\n\t\t\t<BuildOrder>2</BuildOrder>\r\n\t\t</CppCompile>\r\n\t\t<CppCompile Include=\"WinSCP.cpp\">\r\n\t\t\t<BuildOrder>2</BuildOrder>\r\n\t\t\t<BuildOrder>19</BuildOrder>\r\n\t\t</CppCompile>\r\n\t\t<LibFiles Include=\"..\\libs\\lib\\libs3.lib\" Condition=\"'$(Platform)'=='Win32'\">\r\n\t\t\t<BuildOrder>34</BuildOrder>\r\n\t\t\t<IgnorePath>true</IgnorePath>\r\n\t\t</LibFiles>\r\n\t\t<LibFiles Include=\"FileZilla.lib\">\r\n\t\t\t<BuildOrder>27</BuildOrder>\r\n\t\t\t<IgnorePath>true</IgnorePath>\r\n\t\t</LibFiles>\r\n\t\t<LibFiles Include=\"libeay32.lib\">\r\n\t\t\t<BuildOrder>28</BuildOrder>\r\n\t\t\t<IgnorePath>true</IgnorePath>\r\n\t\t</LibFiles>\r\n\t\t<LibFiles Include=\"libexpats_mtd.lib\">\r\n\t\t\t<BuildOrder>31</BuildOrder>\r\n\t\t\t<IgnorePath>true</IgnorePath>\r\n\t\t</LibFiles>\r\n\t\t<LibFiles Include=\"neon.lib\">\r\n\t\t\t<BuildOrder>33</BuildOrder>\r\n\t\t\t<IgnorePath>true</IgnorePath>\r\n\t\t</LibFiles>\r\n\t\t<LibFiles Include=\"Putty.lib\">\r\n\t\t\t<BuildOrder>23</BuildOrder>\r\n\t\t\t<IgnorePath>true</IgnorePath>\r\n\t\t</LibFiles>\r\n\t\t<LibFiles Include=\"PuTTYVS.lib\">\r\n\t\t\t<BuildOrder>33</BuildOrder>\r\n\t\t\t<IgnorePath>true</IgnorePath>\r\n\t\t</LibFiles>\r\n\t\t<LibFiles Include=\"RScpComp.lib\">\r\n\t\t\t<BuildOrder>24</BuildOrder>\r\n\t\t\t<IgnorePath>true</IgnorePath>\r\n\t\t</LibFiles>\r\n\t\t<LibFiles Include=\"ScpCore.lib\">\r\n\t\t\t<BuildOrder>25</BuildOrder>\r\n\t\t\t<IgnorePath>true</IgnorePath>\r\n\t\t</LibFiles>\r\n\t\t<LibFiles Include=\"ScpForms.lib\">\r\n\t\t\t<BuildOrder>26</BuildOrder>\r\n\t\t\t<IgnorePath>true</IgnorePath>\r\n\t\t</LibFiles>\r\n\t\t<LibFiles Include=\"ScpResources.lib\">\r\n\t\t\t<BuildOrder>26</BuildOrder>\r\n\t\t\t<IgnorePath>true</IgnorePath>\r\n\t\t</LibFiles>\r\n\t\t<LibFiles Include=\"ssleay32.lib\">\r\n\t\t\t<BuildOrder>29</BuildOrder>\r\n\t\t\t<IgnorePath>true</IgnorePath>\r\n\t\t</LibFiles>\r\n\t\t<BuildConfiguration Include=\"Base\">\r\n\t\t\t<Key>Base</Key>\r\n\t\t</BuildConfiguration>\r\n\t\t<BuildConfiguration Include=\"Debug\">\r\n\t\t\t<Key>Cfg_1</Key>\r\n\t\t\t<CfgParent>Base</CfgParent>\r\n\t\t</BuildConfiguration>\r\n\t\t<BuildConfiguration Include=\"Release\">\r\n\t\t\t<Key>Cfg_2</Key>\r\n\t\t\t<CfgParent>Base</CfgParent>\r\n\t\t</BuildConfiguration>\r\n\t</ItemGroup>\r\n\t<Import Condition=\"Exists('$(BDS)\\Bin\\CodeGear.Cpp.Targets')\" Project=\"$(BDS)\\Bin\\CodeGear.Cpp.Targets\"/>\r\n\t<ProjectExtensions>\r\n\t\t<Borland.Personality>CPlusPlusBuilder.Personality.12</Borland.Personality>\r\n\t\t<Borland.ProjectType>CppVCLApplication</Borland.ProjectType>\r\n\t\t<BorlandProject>\r\n\t\t\t<CPlusPlusBuilder.Personality>\r\n\t\t\t\t<Source>\r\n\t\t\t\t\t<Source Name=\"MainSource\">WinSCP.cpp</Source>\r\n\t\t\t\t</Source>\r\n\t\t\t\t<ProjectProperties>\r\n\t\t\t\t\t<ProjectProperties Name=\"AutoShowDeps\">False</ProjectProperties>\r\n\t\t\t\t\t<ProjectProperties Name=\"ManagePaths\">True</ProjectProperties>\r\n\t\t\t\t\t<ProjectProperties Name=\"VerifyPackages\">True</ProjectProperties>\r\n\t\t\t\t\t<ProjectProperties Name=\"IndexFiles\">False</ProjectProperties>\r\n\t\t\t\t</ProjectProperties>\r\n\t\t\t</CPlusPlusBuilder.Personality>\r\n\t\t\t<Platforms>\r\n\t\t\t\t<Platform value=\"Win32\">True</Platform>\r\n\t\t\t\t<Platform value=\"Win64\">False</Platform>\r\n\t\t\t</Platforms>\r\n\t\t</BorlandProject>\r\n\t\t<ProjectFileVersion>12</ProjectFileVersion>\r\n\t</ProjectExtensions>\r\n\t<Import Condition=\"Exists('$(APPDATA)\\Embarcadero\\$(BDSAPPDATABASEDIR)\\$(PRODUCTVERSION)\\UserTools.proj')\" Project=\"$(APPDATA)\\Embarcadero\\$(BDSAPPDATABASEDIR)\\$(PRODUCTVERSION)\\UserTools.proj\"/>\r\n</Project>\r\n", "//---------------------------------------------------------------------------\r\n#include <vcl.h>\r\n#pragma hdrstop\r\n\r\n#include \"SessionData.h\"\r\n\r\n#include \"Common.h\"\r\n#include \"Exceptions.h\"\r\n#include \"FileBuffer.h\"\r\n#include \"CoreMain.h\"\r\n#include \"TextsCore.h\"\r\n#include \"PuttyIntf.h\"\r\n#include \"RemoteFiles.h\"\r\n#include \"SFTPFileSystem.h\"\r\n#include \"S3FileSystem.h\"\r\n#include <Soap.EncdDecd.hpp>\r\n#include <StrUtils.hpp>\r\n#include <XMLDoc.hpp>\r\n#include <StrUtils.hpp>\r\n#include <algorithm>\r\n//---------------------------------------------------------------------------\r\n#pragma package(smart_init)\r\n//---------------------------------------------------------------------------\r\n#define SET_SESSION_PROPERTY_FROM(PROPERTY, FROM) \\\r\n  if (F##PROPERTY != FROM) { F##PROPERTY = FROM; Modify(); }\r\n//---------------------------------------------------------------------------\r\n#define SET_SESSION_PROPERTY(PROPERTY) \\\r\n  SET_SESSION_PROPERTY_FROM(PROPERTY, value)\r\n//---------------------------------------------------------------------------\r\nconst wchar_t * PingTypeNames = L\"Off;Null;Dummy\";\r\nconst wchar_t * ProxyMethodNames = L\"None;SOCKS4;SOCKS5;HTTP;Telnet;Cmd\";\r\nconst wchar_t * DefaultName = L\"Default Settings\";\r\nconst UnicodeString CipherNames[CIPHER_COUNT] = {L\"WARN\", L\"3des\", L\"blowfish\", L\"aes\", L\"des\", L\"arcfour\", L\"chacha20\"};\r\nconst UnicodeString KexNames[KEX_COUNT] = {L\"WARN\", L\"dh-group1-sha1\", L\"dh-group14-sha1\", L\"dh-gex-sha1\", L\"rsa\", L\"ecdh\"};\r\nconst UnicodeString HostKeyNames[HOSTKEY_COUNT] = {L\"WARN\", L\"rsa\", L\"dsa\", L\"ecdsa\", L\"ed25519\"};\r\nconst UnicodeString GssLibNames[GSSLIB_COUNT] = {L\"gssapi32\", L\"sspi\", L\"custom\"};\r\nconst wchar_t SshProtList[][10] = {L\"1\", L\"1>2\", L\"2>1\", L\"2\"};\r\n// Update also order in Ssh2CipherList()\r\nconst TCipher DefaultCipherList[CIPHER_COUNT] =\r\n  { cipAES, cipChaCha20, cipBlowfish, cip3DES, cipWarn, cipArcfour, cipDES };\r\n// Update also order in SshKexList()\r\nconst TKex DefaultKexList[KEX_COUNT] =\r\n  { kexECDH, kexDHGEx, kexDHGroup14, kexRSA, kexWarn, kexDHGroup1 };\r\nconst THostKey DefaultHostKeyList[HOSTKEY_COUNT] =\r\n  { hkED25519, hkECDSA, hkRSA, hkDSA, hkWarn };\r\nconst TGssLib DefaultGssLibList[GSSLIB_COUNT] =\r\n  { gssGssApi32, gssSspi, gssCustom };\r\nconst wchar_t FSProtocolNames[FSPROTOCOL_COUNT][16] = { L\"SCP\", L\"SFTP (SCP)\", L\"SFTP\", L\"\", L\"\", L\"FTP\", L\"WebDAV\", L\"S3\" };\r\nconst int SshPortNumber = 22;\r\nconst int FtpPortNumber = 21;\r\nconst int FtpsImplicitPortNumber = 990;\r\nconst int HTTPPortNumber = 80;\r\nconst int HTTPSPortNumber = 443;\r\nconst int TelnetPortNumber = 23;\r\nconst int DefaultSendBuf = 262144;\r\nconst int ProxyPortNumber = 80;\r\nconst UnicodeString AnonymousUserName(L\"anonymous\");\r\nconst UnicodeString AnonymousPassword(L\"anonymous@example.com\");\r\nconst UnicodeString PuttySshProtocol(L\"ssh\");\r\nconst UnicodeString PuttyTelnetProtocol(L\"telnet\");\r\nconst UnicodeString SftpProtocol(L\"sftp\");\r\nconst UnicodeString ScpProtocol(L\"scp\");\r\nconst UnicodeString FtpProtocol(L\"ftp\");\r\nconst UnicodeString FtpsProtocol(L\"ftps\");\r\nconst UnicodeString FtpesProtocol(L\"ftpes\");\r\nconst UnicodeString WebDAVProtocol(L\"dav\");\r\nconst UnicodeString WebDAVSProtocol(L\"davs\");\r\nconst UnicodeString S3Protocol(L\"s3\");\r\nconst UnicodeString SshProtocol(L\"ssh\");\r\nconst UnicodeString WinSCPProtocolPrefix(L\"winscp-\");\r\nconst wchar_t UrlParamSeparator = L';';\r\nconst wchar_t UrlParamValueSeparator = L'=';\r\nconst UnicodeString UrlHostKeyParamName(L\"fingerprint\");\r\nconst UnicodeString UrlSaveParamName(L\"save\");\r\nconst UnicodeString UrlRawSettingsParamNamePrefix(L\"x-\");\r\nconst UnicodeString PassphraseOption(L\"passphrase\");\r\nconst UnicodeString RawSettingsOption(L\"rawsettings\");\r\nconst UnicodeString S3HostName(S3LibDefaultHostName());\r\n//---------------------------------------------------------------------\r\nTDateTime __fastcall SecToDateTime(int Sec)\r\n{\r\n  return TDateTime(double(Sec) / SecsPerDay);\r\n}\r\n//--- TSessionData ----------------------------------------------------\r\n__fastcall TSessionData::TSessionData(UnicodeString aName):\r\n  TNamedObject(aName)\r\n{\r\n  Default();\r\n  FModified = true;\r\n}\r\n//---------------------------------------------------------------------\r\n_fastcall TSessionData::~TSessionData()\r\n{\r\n}\r\n//---------------------------------------------------------------------\r\nint __fastcall TSessionData::Compare(TNamedObject * Other)\r\n{\r\n  int Result;\r\n  // To avoid using CompareLogicalText on hex names of sessions in workspace.\r\n  // The session 000A would be sorted before 0001.\r\n  if (IsWorkspace && DebugNotNull(dynamic_cast<TSessionData *>(Other))->IsWorkspace)\r\n  {\r\n    Result = CompareText(Name, Other->Name);\r\n  }\r\n  else\r\n  {\r\n    Result = TNamedObject::Compare(Other);\r\n  }\r\n  return Result;\r\n}\r\n//---------------------------------------------------------------------\r\nTSessionData * __fastcall TSessionData::Clone()\r\n{\r\n  std::unique_ptr<TSessionData> Data(new TSessionData(L\"\"));\r\n  Data->Assign(this);\r\n  return Data.release();\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::DefaultSettings()\r\n{\r\n  HostName = L\"\";\r\n  PortNumber = SshPortNumber;\r\n  UserName = L\"\";\r\n  Password = L\"\";\r\n  NewPassword = L\"\";\r\n  ChangePassword = false;\r\n  PingInterval = 30;\r\n  PingType = ptOff;\r\n  Timeout = 15;\r\n  TryAgent = true;\r\n  AgentFwd = false;\r\n  AuthTIS = false;\r\n  AuthKI = true;\r\n  AuthKIPassword = true;\r\n  AuthGSSAPI = true;\r\n  GSSAPIFwdTGT = false;\r\n  LogicalHostName = L\"\";\r\n  ChangeUsername = false;\r\n  Compression = false;\r\n  SshProt = ssh2only;\r\n  Ssh2DES = false;\r\n  SshNoUserAuth = false;\r\n  for (int Index = 0; Index < CIPHER_COUNT; Index++)\r\n  {\r\n    Cipher[Index] = DefaultCipherList[Index];\r\n  }\r\n  for (int Index = 0; Index < KEX_COUNT; Index++)\r\n  {\r\n    Kex[Index] = DefaultKexList[Index];\r\n  }\r\n  for (int Index = 0; Index < HOSTKEY_COUNT; Index++)\r\n  {\r\n    HostKeys[Index] = DefaultHostKeyList[Index];\r\n  }\r\n  for (int Index = 0; Index < GSSLIB_COUNT; Index++)\r\n  {\r\n    GssLib[Index] = DefaultGssLibList[Index];\r\n  }\r\n  GssLibCustom = L\"\";\r\n  PublicKeyFile = L\"\";\r\n  Passphrase = L\"\";\r\n  FPuttyProtocol = L\"\";\r\n  TcpNoDelay = false;\r\n  SendBuf = DefaultSendBuf;\r\n  SourceAddress = L\"\";\r\n  SshSimple = true;\r\n  HostKey = L\"\";\r\n  FingerprintScan = false;\r\n  FOverrideCachedHostKey = true;\r\n  Note = L\"\";\r\n  WinTitle = L\"\";\r\n  InternalEditorEncoding = -1;\r\n\r\n  EncryptKey = UnicodeString();\r\n\r\n  ProxyMethod = ::pmNone;\r\n  ProxyHost = L\"proxy\";\r\n  ProxyPort = ProxyPortNumber;\r\n  ProxyUsername = L\"\";\r\n  ProxyPassword = L\"\";\r\n  ProxyTelnetCommand = L\"connect %host %port\\\\n\";\r\n  ProxyLocalCommand = L\"\";\r\n  ProxyDNS = asAuto;\r\n  ProxyLocalhost = false;\r\n\r\n  for (unsigned int Index = 0; Index < LENOF(FBugs); Index++)\r\n  {\r\n    Bug[(TSshBug)Index] = asAuto;\r\n  }\r\n\r\n  Special = false;\r\n  FSProtocol = fsSFTP;\r\n  AddressFamily = afAuto;\r\n  RekeyData = L\"1G\";\r\n  RekeyTime = MinsPerHour;\r\n\r\n  // FS common\r\n  LocalDirectory = L\"\";\r\n  RemoteDirectory = L\"\";\r\n  SynchronizeBrowsing = false;\r\n  UpdateDirectories = true;\r\n  CacheDirectories = true;\r\n  CacheDirectoryChanges = true;\r\n  PreserveDirectoryChanges = true;\r\n  LockInHome = false;\r\n  ResolveSymlinks = true;\r\n  FollowDirectorySymlinks = false;\r\n  DSTMode = dstmUnix;\r\n  DeleteToRecycleBin = false;\r\n  OverwrittenToRecycleBin = false;\r\n  RecycleBinPath = L\"\";\r\n  Color = 0;\r\n  PostLoginCommands = L\"\";\r\n\r\n  // SCP\r\n  LookupUserGroups = asAuto;\r\n  EOLType = eolLF;\r\n  TrimVMSVersions = false;\r\n  Shell = L\"\"; //default shell\r\n  ReturnVar = L\"\";\r\n  ExitCode1IsError = false;\r\n  ClearAliases = true;\r\n  UnsetNationalVars = true;\r\n  ListingCommand = L\"ls -la\";\r\n  IgnoreLsWarnings = true;\r\n  Scp1Compatibility = false;\r\n  TimeDifference = 0;\r\n  TimeDifferenceAuto = true;\r\n  SCPLsFullTime = asAuto;\r\n  NotUtf = asAuto;\r\n\r\n  S3DefaultRegion = L\"\";\r\n  S3UrlStyle = s3usVirtualHost;\r\n\r\n  // SFTP\r\n  SftpServer = L\"\";\r\n  SFTPDownloadQueue = 32;\r\n  SFTPUploadQueue = 32;\r\n  SFTPListingQueue = 2;\r\n  SFTPMaxVersion = ::SFTPMaxVersion;\r\n  SFTPMaxPacketSize = 0;\r\n\r\n  for (unsigned int Index = 0; Index < LENOF(FSFTPBugs); Index++)\r\n  {\r\n    SFTPBug[(TSftpBug)Index] = asAuto;\r\n  }\r\n\r\n  Tunnel = false;\r\n  TunnelHostName = L\"\";\r\n  TunnelPortNumber = SshPortNumber;\r\n  TunnelUserName = L\"\";\r\n  TunnelPassword = L\"\";\r\n  TunnelPublicKeyFile = L\"\";\r\n  TunnelLocalPortNumber = 0;\r\n  TunnelPortFwd = L\"\";\r\n  TunnelHostKey = L\"\";\r\n\r\n  // FTP\r\n  FtpPasvMode = true;\r\n  FtpForcePasvIp = asAuto;\r\n  FtpUseMlsd = asAuto;\r\n  FtpAccount = L\"\";\r\n  FtpPingInterval = 30;\r\n  FtpPingType = ptDummyCommand;\r\n  FtpTransferActiveImmediately = asAuto;\r\n  Ftps = ftpsNone;\r\n  MinTlsVersion = tls10;\r\n  MaxTlsVersion = tls12;\r\n  FtpListAll = asAuto;\r\n  FtpHost = asAuto;\r\n  FtpDeleteFromCwd = asAuto;\r\n  SslSessionReuse = true;\r\n  TlsCertificateFile = L\"\";\r\n\r\n  FtpProxyLogonType = 0; // none\r\n\r\n  PuttySettings = UnicodeString();\r\n\r\n  CustomParam1 = L\"\";\r\n  CustomParam2 = L\"\";\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::Default()\r\n{\r\n  DefaultSettings();\r\n\r\n  IsWorkspace = false;\r\n  Link = L\"\";\r\n  NameOverride = L\"\";\r\n\r\n  Selected = false;\r\n  FModified = false;\r\n  FSource = ::ssNone;\r\n  FSaveOnly = false;\r\n\r\n  // add also to TSessionLog::AddStartupInfo()\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::NonPersistant()\r\n{\r\n  UpdateDirectories = false;\r\n  PreserveDirectoryChanges = false;\r\n}\r\n//---------------------------------------------------------------------\r\n#define PROPERTY(P) PROPERTY_HANDLER(P, )\r\n#define BASE_PROPERTIES \\\r\n  PROPERTY(HostName); \\\r\n  PROPERTY(PortNumber); \\\r\n  PROPERTY(UserName); \\\r\n  PROPERTY_HANDLER(Password, F); \\\r\n  PROPERTY(PublicKeyFile); \\\r\n  PROPERTY_HANDLER(Passphrase, F); \\\r\n  PROPERTY(FSProtocol); \\\r\n  PROPERTY(Ftps); \\\r\n  PROPERTY(LocalDirectory); \\\r\n  PROPERTY(RemoteDirectory); \\\r\n  PROPERTY(Color); \\\r\n  PROPERTY(SynchronizeBrowsing); \\\r\n  PROPERTY(Note);\r\n//---------------------------------------------------------------------\r\n#define ADVANCED_PROPERTIES \\\r\n  PROPERTY_HANDLER(NewPassword, F); \\\r\n  PROPERTY(ChangePassword); \\\r\n  PROPERTY(PingInterval); \\\r\n  PROPERTY(PingType); \\\r\n  PROPERTY(Timeout); \\\r\n  PROPERTY(TryAgent); \\\r\n  PROPERTY(AgentFwd); \\\r\n  PROPERTY(AuthTIS); \\\r\n  PROPERTY(LogicalHostName); \\\r\n  PROPERTY(ChangeUsername); \\\r\n  PROPERTY(Compression); \\\r\n  PROPERTY(SshProt); \\\r\n  PROPERTY(Ssh2DES); \\\r\n  PROPERTY(SshNoUserAuth); \\\r\n  PROPERTY(CipherList); \\\r\n  PROPERTY(KexList); \\\r\n  PROPERTY(HostKeyList); \\\r\n  PROPERTY(GssLibList); \\\r\n  PROPERTY(GssLibCustom); \\\r\n  PROPERTY(AddressFamily); \\\r\n  PROPERTY(RekeyData); \\\r\n  PROPERTY(RekeyTime); \\\r\n  PROPERTY(HostKey); \\\r\n  PROPERTY(FingerprintScan); \\\r\n  PROPERTY(InternalEditorEncoding); \\\r\n  \\\r\n  PROPERTY(UpdateDirectories); \\\r\n  PROPERTY(CacheDirectories); \\\r\n  PROPERTY(CacheDirectoryChanges); \\\r\n  PROPERTY(PreserveDirectoryChanges); \\\r\n  \\\r\n  PROPERTY(ResolveSymlinks); \\\r\n  PROPERTY(FollowDirectorySymlinks); \\\r\n  PROPERTY(DSTMode); \\\r\n  PROPERTY(LockInHome); \\\r\n  PROPERTY(Special); \\\r\n  PROPERTY(Selected); \\\r\n  PROPERTY(ReturnVar); \\\r\n  PROPERTY(ExitCode1IsError); \\\r\n  PROPERTY(LookupUserGroups); \\\r\n  PROPERTY(EOLType); \\\r\n  PROPERTY(TrimVMSVersions); \\\r\n  PROPERTY(Shell); \\\r\n  PROPERTY(ClearAliases); \\\r\n  PROPERTY(Scp1Compatibility); \\\r\n  PROPERTY(UnsetNationalVars); \\\r\n  PROPERTY(ListingCommand); \\\r\n  PROPERTY(IgnoreLsWarnings); \\\r\n  PROPERTY(SCPLsFullTime); \\\r\n  \\\r\n  PROPERTY(TimeDifference); \\\r\n  PROPERTY(TimeDifferenceAuto); \\\r\n  PROPERTY(TcpNoDelay); \\\r\n  PROPERTY(SendBuf); \\\r\n  PROPERTY(SourceAddress); \\\r\n  PROPERTY(SshSimple); \\\r\n  PROPERTY(AuthKI); \\\r\n  PROPERTY(AuthKIPassword); \\\r\n  PROPERTY(AuthGSSAPI); \\\r\n  PROPERTY(GSSAPIFwdTGT); \\\r\n  PROPERTY(DeleteToRecycleBin); \\\r\n  PROPERTY(OverwrittenToRecycleBin); \\\r\n  PROPERTY(RecycleBinPath); \\\r\n  PROPERTY(NotUtf); \\\r\n  PROPERTY(PostLoginCommands); \\\r\n  \\\r\n  PROPERTY(S3DefaultRegion); \\\r\n  PROPERTY(S3UrlStyle); \\\r\n  \\\r\n  PROPERTY(ProxyMethod); \\\r\n  PROPERTY(ProxyHost); \\\r\n  PROPERTY(ProxyPort); \\\r\n  PROPERTY(ProxyUsername); \\\r\n  PROPERTY_HANDLER(ProxyPassword, F); \\\r\n  PROPERTY(ProxyTelnetCommand); \\\r\n  PROPERTY(ProxyLocalCommand); \\\r\n  PROPERTY(ProxyDNS); \\\r\n  PROPERTY(ProxyLocalhost); \\\r\n  \\\r\n  for (unsigned int Index = 0; Index < LENOF(FBugs); Index++) \\\r\n  { \\\r\n    PROPERTY(Bug[(TSshBug)Index]); \\\r\n  } \\\r\n  \\\r\n  PROPERTY(SftpServer); \\\r\n  PROPERTY(SFTPDownloadQueue); \\\r\n  PROPERTY(SFTPUploadQueue); \\\r\n  PROPERTY(SFTPListingQueue); \\\r\n  PROPERTY(SFTPMaxVersion); \\\r\n  PROPERTY(SFTPMaxPacketSize); \\\r\n  \\\r\n  for (unsigned int Index = 0; Index < LENOF(FSFTPBugs); Index++) \\\r\n  { \\\r\n    PROPERTY(SFTPBug[(TSftpBug)Index]); \\\r\n  } \\\r\n  \\\r\n  PROPERTY(Tunnel); \\\r\n  PROPERTY(TunnelHostName); \\\r\n  PROPERTY(TunnelPortNumber); \\\r\n  PROPERTY(TunnelUserName); \\\r\n  PROPERTY_HANDLER(TunnelPassword, F); \\\r\n  PROPERTY(TunnelPublicKeyFile); \\\r\n  PROPERTY(TunnelLocalPortNumber); \\\r\n  PROPERTY(TunnelPortFwd); \\\r\n  PROPERTY(TunnelHostKey); \\\r\n  \\\r\n  PROPERTY(FtpPasvMode); \\\r\n  PROPERTY(FtpForcePasvIp); \\\r\n  PROPERTY(FtpUseMlsd); \\\r\n  PROPERTY(FtpAccount); \\\r\n  PROPERTY(FtpPingInterval); \\\r\n  PROPERTY(FtpPingType); \\\r\n  PROPERTY(FtpTransferActiveImmediately); \\\r\n  PROPERTY(FtpListAll); \\\r\n  PROPERTY(FtpHost); \\\r\n  PROPERTY(FtpDeleteFromCwd); \\\r\n  PROPERTY(SslSessionReuse); \\\r\n  PROPERTY(TlsCertificateFile); \\\r\n  \\\r\n  PROPERTY(FtpProxyLogonType); \\\r\n  \\\r\n  PROPERTY(MinTlsVersion); \\\r\n  PROPERTY(MaxTlsVersion); \\\r\n  \\\r\n  PROPERTY(WinTitle); \\\r\n  \\\r\n  PROPERTY_HANDLER(EncryptKey, F); \\\r\n  \\\r\n  PROPERTY(PuttySettings); \\\r\n  \\\r\n  PROPERTY(CustomParam1); \\\r\n  PROPERTY(CustomParam2);\r\n#define META_PROPERTIES \\\r\n  PROPERTY(IsWorkspace); \\\r\n  PROPERTY(Link); \\\r\n  PROPERTY(NameOverride);\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::Assign(TPersistent * Source)\r\n{\r\n  if (Source && Source->InheritsFrom(__classid(TSessionData)))\r\n  {\r\n    TSessionData * SourceData = (TSessionData *)Source;\r\n    // Master password prompt shows implicitly here, when cloning the session data for a new terminal\r\n    CopyData(SourceData);\r\n    FSource = SourceData->FSource;\r\n  }\r\n  else\r\n  {\r\n    TNamedObject::Assign(Source);\r\n  }\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::DoCopyData(TSessionData * SourceData, bool NoRecrypt)\r\n{\r\n  #define PROPERTY_HANDLER(P, F) \\\r\n    if (NoRecrypt) \\\r\n    { \\\r\n      F##P = SourceData->F##P; \\\r\n    } \\\r\n    else \\\r\n    { \\\r\n      P = SourceData->P; \\\r\n    }\r\n  PROPERTY(Name);\r\n  BASE_PROPERTIES;\r\n  ADVANCED_PROPERTIES;\r\n  META_PROPERTIES;\r\n  #undef PROPERTY_HANDLER\r\n  FOverrideCachedHostKey = SourceData->FOverrideCachedHostKey;\r\n  FModified = SourceData->Modified;\r\n  FSaveOnly = SourceData->FSaveOnly;\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::CopyData(TSessionData * SourceData)\r\n{\r\n  DoCopyData(SourceData, false);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::CopyDataNoRecrypt(TSessionData * SourceData)\r\n{\r\n  DoCopyData(SourceData, true);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::CopyDirectoriesStateData(TSessionData * SourceData)\r\n{\r\n  RemoteDirectory = SourceData->RemoteDirectory;\r\n  LocalDirectory = SourceData->LocalDirectory;\r\n  SynchronizeBrowsing = SourceData->SynchronizeBrowsing;\r\n}\r\n//---------------------------------------------------------------------\r\nbool __fastcall TSessionData::HasStateData()\r\n{\r\n  return\r\n    !RemoteDirectory.IsEmpty() ||\r\n    !LocalDirectory.IsEmpty() ||\r\n    (Color != 0);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::CopyStateData(TSessionData * SourceData)\r\n{\r\n  // Keep in sync with TCustomScpExplorerForm::UpdateSessionData.\r\n  CopyDirectoriesStateData(SourceData);\r\n  Color = SourceData->Color;\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::CopyNonCoreData(TSessionData * SourceData)\r\n{\r\n  CopyStateData(SourceData);\r\n  UpdateDirectories = SourceData->UpdateDirectories;\r\n  Note = SourceData->Note;\r\n}\r\n//---------------------------------------------------------------------\r\nbool __fastcall TSessionData::IsSame(\r\n  const TSessionData * Default, bool AdvancedOnly, TStrings * DifferentProperties, bool Decrypted)\r\n{\r\n  bool Result = true;\r\n  #define PROPERTY_HANDLER(P, F) \\\r\n    if ((Decrypted && (P != Default->P)) || \\\r\n        (!Decrypted && (F##P != Default->F##P))) \\\r\n    { \\\r\n      Result = false; \\\r\n      if (DifferentProperties != NULL) \\\r\n      { \\\r\n        DifferentProperties->Add(#P); \\\r\n      } \\\r\n      else \\\r\n      { \\\r\n        return Result; \\\r\n      } \\\r\n    }\r\n\r\n  if (!AdvancedOnly)\r\n  {\r\n    BASE_PROPERTIES;\r\n    META_PROPERTIES;\r\n  }\r\n  ADVANCED_PROPERTIES;\r\n  #undef PROPERTY_HANDLER\r\n  return Result;\r\n}\r\n//---------------------------------------------------------------------\r\nbool __fastcall TSessionData::IsSame(const TSessionData * Default, bool AdvancedOnly)\r\n{\r\n  return IsSame(Default, AdvancedOnly, NULL, false);\r\n}\r\n//---------------------------------------------------------------------\r\nbool __fastcall TSessionData::IsSameDecrypted(const TSessionData * Default)\r\n{\r\n  return IsSame(Default, false, NULL, true);\r\n}\r\n//---------------------------------------------------------------------\r\nTFSProtocol NormalizeFSProtocol(TFSProtocol FSProtocol)\r\n{\r\n  if (FSProtocol == fsSFTPonly)\r\n  {\r\n    FSProtocol = fsSFTP;\r\n  }\r\n  return FSProtocol;\r\n}\r\n//---------------------------------------------------------------------\r\nbool __fastcall TSessionData::IsSameSite(const TSessionData * Other)\r\n{\r\n  return\r\n    // Particularly when handling /refresh,\r\n    // fsSFTPonly sites when compared against sftp:// URLs (fsSFTP) have to match.\r\n    // But similarly also falled back SCP sites.\r\n    (NormalizeFSProtocol(FSProtocol) == NormalizeFSProtocol(Other->FSProtocol)) &&\r\n    (HostName == Other->HostName) &&\r\n    (PortNumber == Other->PortNumber) &&\r\n    (UserName == Other->UserName);\r\n}\r\n//---------------------------------------------------------------------\r\nbool __fastcall TSessionData::IsInFolderOrWorkspace(UnicodeString AFolder)\r\n{\r\n  return StartsText(UnixIncludeTrailingBackslash(AFolder), Name);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::DoLoad(THierarchicalStorage * Storage, bool PuttyImport, bool & RewritePassword)\r\n{\r\n  // Make sure we only ever use methods supported by TOptionsStorage\r\n  // (implemented by TOptionsIniFile)\r\n\r\n  PortNumber = Storage->ReadInteger(L\"PortNumber\", PortNumber);\r\n  UserName = Storage->ReadString(L\"UserName\", UserName);\r\n  // must be loaded after UserName, because HostName may be in format user@host\r\n  HostName = Storage->ReadString(L\"HostName\", HostName);\r\n\r\n  if (!Configuration->DisablePasswordStoring)\r\n  {\r\n    if (Storage->ValueExists(L\"PasswordPlain\"))\r\n    {\r\n      Password = Storage->ReadString(L\"PasswordPlain\", Password);\r\n      RewritePassword = true;\r\n    }\r\n    else\r\n    {\r\n      RawByteString APassword = Storage->ReadStringAsBinaryData(L\"Password\", FPassword);\r\n      SET_SESSION_PROPERTY_FROM(Password, APassword);\r\n    }\r\n  }\r\n  HostKey = Storage->ReadString(L\"SshHostKey\", HostKey); // probably never used\r\n  Note = Storage->ReadString(L\"Note\", Note);\r\n  // Putty uses PingIntervalSecs\r\n  int PingIntervalSecs = Storage->ReadInteger(L\"PingIntervalSecs\", -1);\r\n  if (PingIntervalSecs < 0)\r\n  {\r\n    PingIntervalSecs = Storage->ReadInteger(L\"PingIntervalSec\", PingInterval%SecsPerMin);\r\n  }\r\n  PingInterval =\r\n    Storage->ReadInteger(L\"PingInterval\", PingInterval/SecsPerMin)*SecsPerMin +\r\n    PingIntervalSecs;\r\n  if (PingInterval == 0)\r\n  {\r\n    PingInterval = 30;\r\n  }\r\n  PingType = static_cast<TPingType>(Storage->ReadInteger(L\"PingType\", PingType));\r\n  Timeout = Storage->ReadInteger(L\"Timeout\", Timeout);\r\n  TryAgent = Storage->ReadBool(L\"TryAgent\", TryAgent);\r\n  AgentFwd = Storage->ReadBool(L\"AgentFwd\", AgentFwd);\r\n  AuthTIS = Storage->ReadBool(L\"AuthTIS\", AuthTIS);\r\n  AuthKI = Storage->ReadBool(L\"AuthKI\", AuthKI);\r\n  AuthKIPassword = Storage->ReadBool(L\"AuthKIPassword\", AuthKIPassword);\r\n  // Continue to use setting keys of previous kerberos implementation (vaclav tomec),\r\n  // but fallback to keys of other implementations (official putty and vintela quest putty),\r\n  // to allow imports from all putty versions.\r\n  // Both vaclav tomec and official putty use AuthGSSAPI\r\n  AuthGSSAPI = Storage->ReadBool(L\"AuthGSSAPI\", Storage->ReadBool(L\"AuthSSPI\", AuthGSSAPI));\r\n  GSSAPIFwdTGT = Storage->ReadBool(L\"GSSAPIFwdTGT\", Storage->ReadBool(L\"GssapiFwd\", Storage->ReadBool(L\"SSPIFwdTGT\", GSSAPIFwdTGT)));\r\n  // KerbPrincipal was used by Quest PuTTY\r\n  // GSSAPIServerRealm was used by Vaclav Tomec\r\n  LogicalHostName = Storage->ReadString(L\"LogicalHostName\", Storage->ReadString(L\"GSSAPIServerRealm\", Storage->ReadString(L\"KerbPrincipal\", LogicalHostName)));\r\n  ChangeUsername = Storage->ReadBool(L\"ChangeUsername\", ChangeUsername);\r\n  Compression = Storage->ReadBool(L\"Compression\", Compression);\r\n  TSshProt ASshProt = (TSshProt)Storage->ReadInteger(L\"SshProt\", SshProt);\r\n  // Old sessions may contain the values correponding to the fallbacks we used to allow; migrate them\r\n  if (ASshProt == ssh2deprecated)\r\n  {\r\n    ASshProt = ssh2only;\r\n  }\r\n  else if (ASshProt == ssh1deprecated)\r\n  {\r\n    ASshProt = ssh1only;\r\n  }\r\n  SshProt = ASshProt;\r\n  Ssh2DES = Storage->ReadBool(L\"Ssh2DES\", Ssh2DES);\r\n  SshNoUserAuth = Storage->ReadBool(L\"SshNoUserAuth\", SshNoUserAuth);\r\n  CipherList = Storage->ReadString(L\"Cipher\", CipherList);\r\n  KexList = Storage->ReadString(L\"KEX\", KexList);\r\n  HostKeyList = Storage->ReadString(L\"HostKey\", HostKeyList);\r\n  GssLibList = Storage->ReadString(L\"GSSLibs\", GssLibList);\r\n  GssLibCustom = Storage->ReadString(L\"GSSCustom\", GssLibCustom);\r\n  PublicKeyFile = Storage->ReadString(L\"PublicKeyFile\", PublicKeyFile);\r\n  AddressFamily = static_cast<TAddressFamily>\r\n    (Storage->ReadInteger(L\"AddressFamily\", AddressFamily));\r\n  RekeyData = Storage->ReadString(L\"RekeyBytes\", RekeyData);\r\n  RekeyTime = Storage->ReadInteger(L\"RekeyTime\", RekeyTime);\r\n\r\n  FSProtocol = (TFSProtocol)Storage->ReadInteger(L\"FSProtocol\", FSProtocol);\r\n  LocalDirectory = Storage->ReadString(L\"LocalDirectory\", LocalDirectory);\r\n  RemoteDirectory = Storage->ReadString(L\"RemoteDirectory\", RemoteDirectory);\r\n  SynchronizeBrowsing = Storage->ReadBool(L\"SynchronizeBrowsing\", SynchronizeBrowsing);\r\n  UpdateDirectories = Storage->ReadBool(L\"UpdateDirectories\", UpdateDirectories);\r\n  CacheDirectories = Storage->ReadBool(L\"CacheDirectories\", CacheDirectories);\r\n  CacheDirectoryChanges = Storage->ReadBool(L\"CacheDirectoryChanges\", CacheDirectoryChanges);\r\n  PreserveDirectoryChanges = Storage->ReadBool(L\"PreserveDirectoryChanges\", PreserveDirectoryChanges);\r\n\r\n  ResolveSymlinks = Storage->ReadBool(L\"ResolveSymlinks\", ResolveSymlinks);\r\n  FollowDirectorySymlinks = Storage->ReadBool(L\"FollowDirectorySymlinks\", FollowDirectorySymlinks);\r\n  DSTMode = (TDSTMode)Storage->ReadInteger(L\"ConsiderDST\", DSTMode);\r\n  LockInHome = Storage->ReadBool(L\"LockInHome\", LockInHome);\r\n  Special = Storage->ReadBool(L\"Special\", Special);\r\n  Shell = Storage->ReadString(L\"Shell\", Shell);\r\n  ClearAliases = Storage->ReadBool(L\"ClearAliases\", ClearAliases);\r\n  UnsetNationalVars = Storage->ReadBool(L\"UnsetNationalVars\", UnsetNationalVars);\r\n  ListingCommand = Storage->ReadString(L\"ListingCommand\",\r\n    Storage->ReadBool(L\"AliasGroupList\", false) ? UnicodeString(L\"ls -gla\") : ListingCommand);\r\n  IgnoreLsWarnings = Storage->ReadBool(L\"IgnoreLsWarnings\", IgnoreLsWarnings);\r\n  SCPLsFullTime = TAutoSwitch(Storage->ReadInteger(L\"SCPLsFullTime\", SCPLsFullTime));\r\n  Scp1Compatibility = Storage->ReadBool(L\"Scp1Compatibility\", Scp1Compatibility);\r\n  TimeDifference = Storage->ReadFloat(L\"TimeDifference\", TimeDifference);\r\n  TimeDifferenceAuto = Storage->ReadBool(L\"TimeDifferenceAuto\", (TimeDifference == TDateTime()));\r\n  DeleteToRecycleBin = Storage->ReadBool(L\"DeleteToRecycleBin\", DeleteToRecycleBin);\r\n  OverwrittenToRecycleBin = Storage->ReadBool(L\"OverwrittenToRecycleBin\", OverwrittenToRecycleBin);\r\n  RecycleBinPath = Storage->ReadString(L\"RecycleBinPath\", RecycleBinPath);\r\n  PostLoginCommands = Storage->ReadString(L\"PostLoginCommands\", PostLoginCommands);\r\n\r\n  ReturnVar = Storage->ReadString(L\"ReturnVar\", ReturnVar);\r\n  ExitCode1IsError = Storage->ReadBool(L\"ExitCode1IsError\", ExitCode1IsError);\r\n  LookupUserGroups = TAutoSwitch(Storage->ReadInteger(L\"LookupUserGroups2\", LookupUserGroups));\r\n  EOLType = (TEOLType)Storage->ReadInteger(L\"EOLType\", EOLType);\r\n  TrimVMSVersions = Storage->ReadBool(L\"TrimVMSVersions\", TrimVMSVersions);\r\n  NotUtf = TAutoSwitch(Storage->ReadInteger(L\"Utf\", Storage->ReadInteger(L\"SFTPUtfBug\", NotUtf)));\r\n  InternalEditorEncoding = Storage->ReadInteger(L\"InternalEditorEncoding\", InternalEditorEncoding);\r\n\r\n  S3DefaultRegion = Storage->ReadString(L\"S3DefaultRegion\", S3DefaultRegion);\r\n  S3UrlStyle = (TS3UrlStyle)Storage->ReadInteger(L\"S3UrlStyle\", S3UrlStyle);\r\n\r\n  // PuTTY defaults to TcpNoDelay, but the psftp/pscp ignores this preference, and always set this to off (what is our default too)\r\n  if (!PuttyImport)\r\n  {\r\n    TcpNoDelay = Storage->ReadBool(L\"TcpNoDelay\", TcpNoDelay);\r\n  }\r\n  SendBuf = Storage->ReadInteger(L\"SendBuf\", Storage->ReadInteger(\"SshSendBuf\", SendBuf));\r\n  SourceAddress = Storage->ReadString(L\"SourceAddress\", SourceAddress);\r\n  SshSimple = Storage->ReadBool(L\"SshSimple\", SshSimple);\r\n\r\n  ProxyMethod = (TProxyMethod)Storage->ReadInteger(L\"ProxyMethod\", ProxyMethod);\r\n  ProxyHost = Storage->ReadString(L\"ProxyHost\", ProxyHost);\r\n  ProxyPort = Storage->ReadInteger(L\"ProxyPort\", ProxyPort);\r\n  ProxyUsername = Storage->ReadString(L\"ProxyUsername\", ProxyUsername);\r\n  if (Storage->ValueExists(L\"ProxyPassword\"))\r\n  {\r\n    // encrypt unencrypted password\r\n    ProxyPassword = Storage->ReadString(L\"ProxyPassword\", L\"\");\r\n  }\r\n  else\r\n  {\r\n    // load encrypted password\r\n    RawByteString AProxyPassword = Storage->ReadStringAsBinaryData(L\"ProxyPasswordEnc\", FProxyPassword);\r\n    SET_SESSION_PROPERTY_FROM(ProxyPassword, AProxyPassword);\r\n  }\r\n  if (ProxyMethod == pmCmd)\r\n  {\r\n    ProxyLocalCommand = Storage->ReadStringRaw(L\"ProxyTelnetCommand\", ProxyLocalCommand);\r\n  }\r\n  else\r\n  {\r\n    ProxyTelnetCommand = Storage->ReadStringRaw(L\"ProxyTelnetCommand\", ProxyTelnetCommand);\r\n  }\r\n  ProxyDNS = TAutoSwitch((Storage->ReadInteger(L\"ProxyDNS\", (ProxyDNS + 2) % 3) + 1) % 3);\r\n  ProxyLocalhost = Storage->ReadBool(L\"ProxyLocalhost\", ProxyLocalhost);\r\n\r\n  #define READ_BUG(BUG) \\\r\n    Bug[sb##BUG] = TAutoSwitch(2 - Storage->ReadInteger(L\"Bug\"#BUG, \\\r\n      2 - Bug[sb##BUG]));\r\n  READ_BUG(Ignore1);\r\n  READ_BUG(PlainPW1);\r\n  READ_BUG(RSA1);\r\n  READ_BUG(HMAC2);\r\n  READ_BUG(DeriveKey2);\r\n  READ_BUG(RSAPad2);\r\n  READ_BUG(PKSessID2);\r\n  READ_BUG(Rekey2);\r\n  READ_BUG(MaxPkt2);\r\n  READ_BUG(Ignore2);\r\n  READ_BUG(OldGex2);\r\n  READ_BUG(WinAdj);\r\n  READ_BUG(ChanReq);\r\n  #undef READ_BUG\r\n\r\n  if ((Bug[sbHMAC2] == asAuto) &&\r\n      Storage->ReadBool(L\"BuggyMAC\", false))\r\n  {\r\n      Bug[sbHMAC2] = asOn;\r\n  }\r\n\r\n  SftpServer = Storage->ReadString(L\"SftpServer\", SftpServer);\r\n  #define READ_SFTP_BUG(BUG) \\\r\n    SFTPBug[sb##BUG] = TAutoSwitch(Storage->ReadInteger(L\"SFTP\" #BUG \"Bug\", SFTPBug[sb##BUG]));\r\n  READ_SFTP_BUG(Symlink);\r\n  READ_SFTP_BUG(SignedTS);\r\n  #undef READ_SFTP_BUG\r\n\r\n  SFTPMaxVersion = Storage->ReadInteger(L\"SFTPMaxVersion\", SFTPMaxVersion);\r\n  SFTPMaxPacketSize = Storage->ReadInteger(L\"SFTPMaxPacketSize\", SFTPMaxPacketSize);\r\n  SFTPDownloadQueue = Storage->ReadInteger(L\"SFTPDownloadQueue\", SFTPDownloadQueue);\r\n  SFTPUploadQueue = Storage->ReadInteger(L\"SFTPUploadQueue\", SFTPUploadQueue);\r\n  SFTPListingQueue = Storage->ReadInteger(L\"SFTPListingQueue\", SFTPListingQueue);\r\n\r\n  Color = Storage->ReadInteger(L\"Color\", Color);\r\n\r\n  PuttyProtocol = Storage->ReadString(L\"Protocol\", PuttyProtocol);\r\n\r\n  Tunnel = Storage->ReadBool(L\"Tunnel\", Tunnel);\r\n  TunnelPortNumber = Storage->ReadInteger(L\"TunnelPortNumber\", TunnelPortNumber);\r\n  TunnelUserName = Storage->ReadString(L\"TunnelUserName\", TunnelUserName);\r\n  // must be loaded after TunnelUserName,\r\n  // because TunnelHostName may be in format user@host\r\n  TunnelHostName = Storage->ReadString(L\"TunnelHostName\", TunnelHostName);\r\n  if (!Configuration->DisablePasswordStoring)\r\n  {\r\n    if (Storage->ValueExists(L\"TunnelPasswordPlain\"))\r\n    {\r\n      TunnelPassword = Storage->ReadString(L\"TunnelPasswordPlain\", TunnelPassword);\r\n      RewritePassword = true;\r\n    }\r\n    else\r\n    {\r\n      RawByteString ATunnelPassword = Storage->ReadStringAsBinaryData(L\"TunnelPassword\", FTunnelPassword);\r\n      SET_SESSION_PROPERTY_FROM(TunnelPassword, ATunnelPassword);\r\n    }\r\n  }\r\n  TunnelPublicKeyFile = Storage->ReadString(L\"TunnelPublicKeyFile\", TunnelPublicKeyFile);\r\n  TunnelLocalPortNumber = Storage->ReadInteger(L\"TunnelLocalPortNumber\", TunnelLocalPortNumber);\r\n  TunnelHostKey = Storage->ReadString(L\"TunnelHostKey\", TunnelHostKey);\r\n\r\n  // Ftp prefix\r\n  FtpPasvMode = Storage->ReadBool(L\"FtpPasvMode\", FtpPasvMode);\r\n  FtpForcePasvIp = TAutoSwitch(Storage->ReadInteger(L\"FtpForcePasvIp2\", FtpForcePasvIp));\r\n  FtpUseMlsd = TAutoSwitch(Storage->ReadInteger(L\"FtpUseMlsd\", FtpUseMlsd));\r\n  FtpAccount = Storage->ReadString(L\"FtpAccount\", FtpAccount);\r\n  FtpPingInterval = Storage->ReadInteger(L\"FtpPingInterval\", FtpPingInterval);\r\n  FtpPingType = static_cast<TPingType>(Storage->ReadInteger(L\"FtpPingType\", FtpPingType));\r\n  FtpTransferActiveImmediately = static_cast<TAutoSwitch>(Storage->ReadInteger(L\"FtpTransferActiveImmediately2\", FtpTransferActiveImmediately));\r\n  Ftps = static_cast<TFtps>(Storage->ReadInteger(L\"Ftps\", Ftps));\r\n  FtpListAll = TAutoSwitch(Storage->ReadInteger(L\"FtpListAll\", FtpListAll));\r\n  FtpHost = TAutoSwitch(Storage->ReadInteger(L\"FtpHost\", FtpHost));\r\n  FtpDeleteFromCwd = TAutoSwitch(Storage->ReadInteger(L\"FtpDeleteFromCwd\", FtpDeleteFromCwd));\r\n  SslSessionReuse = Storage->ReadBool(L\"SslSessionReuse\", SslSessionReuse);\r\n  TlsCertificateFile = Storage->ReadString(L\"TlsCertificateFile\", TlsCertificateFile);\r\n\r\n  FtpProxyLogonType = Storage->ReadInteger(L\"FtpProxyLogonType\", FtpProxyLogonType);\r\n\r\n  MinTlsVersion = static_cast<TTlsVersion>(Storage->ReadInteger(L\"MinTlsVersion\", MinTlsVersion));\r\n  MaxTlsVersion = static_cast<TTlsVersion>(Storage->ReadInteger(L\"MaxTlsVersion\", MaxTlsVersion));\r\n\r\n  if (Storage->ValueExists(L\"EncryptKeyPlain\"))\r\n  {\r\n    EncryptKey = Storage->ReadString(L\"EncryptKeyPlain\", EncryptKey);\r\n    RewritePassword = true;\r\n  }\r\n  else\r\n  {\r\n    RawByteString AEncryptKey = Storage->ReadStringAsBinaryData(L\"EncryptKey\", FEncryptKey);\r\n    SET_SESSION_PROPERTY_FROM(EncryptKey, AEncryptKey);\r\n  }\r\n\r\n  IsWorkspace = Storage->ReadBool(L\"IsWorkspace\", IsWorkspace);\r\n  Link = Storage->ReadString(L\"Link\", Link);\r\n  NameOverride = Storage->ReadString(L\"NameOverride\", NameOverride);\r\n\r\n  PuttySettings = Storage->ReadString(L\"PuttySettings\", PuttySettings);\r\n\r\n  CustomParam1 = Storage->ReadString(L\"CustomParam1\", CustomParam1);\r\n  CustomParam2 = Storage->ReadString(L\"CustomParam2\", CustomParam2);\r\n\r\n#ifdef TEST\r\n  #define KEX_TEST(VALUE, EXPECTED) KexList = VALUE; DebugAssert(KexList == EXPECTED);\r\n  #define KEX_DEFAULT L\"ecdh,dh-gex-sha1,dh-group14-sha1,rsa,WARN,dh-group1-sha1\"\r\n  // Empty source should result in default list\r\n  KEX_TEST(L\"\", KEX_DEFAULT);\r\n  // Default of pre 5.8.1\r\n  KEX_TEST(L\"dh-gex-sha1,dh-group14-sha1,dh-group1-sha1,rsa,WARN\", L\"ecdh,dh-gex-sha1,dh-group14-sha1,dh-group1-sha1,rsa,WARN\");\r\n  // Missing first two priority algos, and last non-priority algo\r\n  KEX_TEST(L\"dh-group14-sha1,dh-group1-sha1,WARN\", L\"ecdh,dh-gex-sha1,dh-group14-sha1,dh-group1-sha1,rsa,WARN\");\r\n  // Missing first two priority algos, last non-priority algo and WARN\r\n  KEX_TEST(L\"dh-group14-sha1,dh-group1-sha1\", L\"ecdh,dh-gex-sha1,dh-group14-sha1,dh-group1-sha1,rsa,WARN\");\r\n  // Old algos, with all but the first below WARN\r\n  KEX_TEST(L\"dh-gex-sha1,WARN,dh-group14-sha1,dh-group1-sha1,rsa\", L\"ecdh,dh-gex-sha1,WARN,dh-group14-sha1,dh-group1-sha1,rsa\");\r\n  // Unknown algo at front\r\n  KEX_TEST(L\"unknown,ecdh,dh-gex-sha1,dh-group14-sha1,rsa,WARN,dh-group1-sha1\", KEX_DEFAULT);\r\n  // Unknown algo at back\r\n  KEX_TEST(L\"ecdh,dh-gex-sha1,dh-group14-sha1,rsa,WARN,dh-group1-sha1,unknown\", KEX_DEFAULT);\r\n  // Unknown algo in the middle\r\n  KEX_TEST(L\"ecdh,dh-gex-sha1,dh-group14-sha1,unknown,rsa,WARN,dh-group1-sha1\", KEX_DEFAULT);\r\n  #undef KEX_DEFAULT\r\n  #undef KEX_TEST\r\n\r\n  #define CIPHER_TEST(VALUE, EXPECTED) CipherList = VALUE; DebugAssert(CipherList == EXPECTED);\r\n  #define CIPHER_DEFAULT L\"aes,chacha20,blowfish,3des,WARN,arcfour,des\"\r\n  // Empty source should result in default list\r\n  CIPHER_TEST(L\"\", CIPHER_DEFAULT);\r\n  // Default of pre 5.8.1\r\n  CIPHER_TEST(L\"aes,blowfish,3des,WARN,arcfour,des\", L\"aes,blowfish,3des,chacha20,WARN,arcfour,des\");\r\n  // Missing priority algo\r\n  CIPHER_TEST(L\"chacha20,blowfish,3des,WARN,arcfour,des\", CIPHER_DEFAULT);\r\n  // Missing non-priority algo\r\n  CIPHER_TEST(L\"aes,chacha20,3des,WARN,arcfour,des\", L\"aes,chacha20,3des,blowfish,WARN,arcfour,des\");\r\n  // Missing last warn algo\r\n  CIPHER_TEST(L\"aes,blowfish,chacha20,3des,WARN,arcfour\", L\"aes,blowfish,chacha20,3des,WARN,arcfour,des\");\r\n  // Missing first warn algo\r\n  CIPHER_TEST(L\"aes,blowfish,chacha20,3des,WARN,des\", L\"aes,blowfish,chacha20,3des,WARN,des,arcfour\");\r\n  #undef CIPHER_DEFAULT\r\n  #undef CIPHER_TEST\r\n\r\n  #define HOSTKEY_TEST(VALUE, EXPECTED) HostKeyList = VALUE; DebugAssert(HostKeyList == EXPECTED);\r\n  #define HOSTKEY_DEFAULT L\"ed25519,ecdsa,rsa,dsa,WARN\"\r\n  // Empty source should result in default list\r\n  HOSTKEY_TEST(L\"\", HOSTKEY_DEFAULT);\r\n  // Missing priority algo\r\n  HOSTKEY_TEST(L\"ecdsa,rsa,dsa,WARN\", HOSTKEY_DEFAULT);\r\n  // Missing non-priority algo\r\n  HOSTKEY_TEST(L\"ed25519,ecdsa,dsa,WARN\", L\"ed25519,ecdsa,dsa,rsa,WARN\");\r\n  #undef HOSTKEY_DEFAULT\r\n  #undef HOSTKEY_TEST\r\n#endif\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::Load(THierarchicalStorage * Storage, bool PuttyImport)\r\n{\r\n  bool RewritePassword = false;\r\n  if (Storage->OpenSubKey(InternalStorageKey, False))\r\n  {\r\n    // In case we are re-loading, reset passwords, to avoid pointless\r\n    // re-cryption, while loading username/hostname. And moreover, when\r\n    // the password is wrongly encrypted (using a different master password),\r\n    // this breaks sites reload and consequently an overal operation,\r\n    // such as opening Sites menu\r\n    ClearSessionPasswords();\r\n    FProxyPassword = L\"\";\r\n\r\n    DoLoad(Storage, PuttyImport, RewritePassword);\r\n\r\n    Storage->CloseSubKey();\r\n  }\r\n\r\n  if (RewritePassword)\r\n  {\r\n    TStorageAccessMode AccessMode = Storage->AccessMode;\r\n    Storage->AccessMode = smReadWrite;\r\n\r\n    try\r\n    {\r\n      if (Storage->OpenSubKey(InternalStorageKey, true))\r\n      {\r\n        Storage->DeleteValue(L\"PasswordPlain\");\r\n        if (!Password.IsEmpty())\r\n        {\r\n          Storage->WriteBinaryDataAsString(L\"Password\", FPassword);\r\n        }\r\n        Storage->DeleteValue(L\"TunnelPasswordPlain\");\r\n        if (!TunnelPassword.IsEmpty())\r\n        {\r\n          Storage->WriteBinaryDataAsString(L\"TunnelPassword\", FTunnelPassword);\r\n        }\r\n        Storage->DeleteValue(L\"EncryptKeyPlain\");\r\n        if (!EncryptKey.IsEmpty())\r\n        {\r\n          Storage->WriteBinaryDataAsString(L\"EncryptKey\", FEncryptKey);\r\n        }\r\n        Storage->CloseSubKey();\r\n      }\r\n    }\r\n    catch(...)\r\n    {\r\n      // ignore errors (like read-only INI file)\r\n    }\r\n\r\n    Storage->AccessMode = AccessMode;\r\n  }\r\n\r\n  FModified = false;\r\n  FSource = ssStored;\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::DoSave(THierarchicalStorage * Storage,\r\n  bool PuttyExport, const TSessionData * Default, bool DoNotEncryptPasswords)\r\n{\r\n  // Same as in TCopyParamType::Save\r\n  #define WRITE_DATA_EX(TYPE, NAME, PROPERTY, CONV) \\\r\n    if ((Default != NULL) && (CONV(Default->PROPERTY) == CONV(PROPERTY))) \\\r\n    { \\\r\n      Storage->DeleteValue(NAME); \\\r\n    } \\\r\n    else \\\r\n    { \\\r\n      Storage->Write ## TYPE(NAME, CONV(PROPERTY)); \\\r\n    }\r\n  #define WRITE_DATA_CONV(TYPE, NAME, PROPERTY) WRITE_DATA_EX(TYPE, NAME, PROPERTY, WRITE_DATA_CONV_FUNC)\r\n  #define WRITE_DATA(TYPE, PROPERTY) WRITE_DATA_EX(TYPE, TEXT(#PROPERTY), PROPERTY, )\r\n\r\n  WRITE_DATA(String, HostName);\r\n  WRITE_DATA(Integer, PortNumber);\r\n  WRITE_DATA_EX(Integer, L\"PingInterval\", PingInterval / SecsPerMin, );\r\n  WRITE_DATA_EX(Integer, L\"PingIntervalSecs\", PingInterval % SecsPerMin, );\r\n  Storage->DeleteValue(L\"PingIntervalSec\"); // obsolete\r\n  WRITE_DATA(Integer, PingType);\r\n  WRITE_DATA(Integer, Timeout);\r\n  WRITE_DATA(Bool, TryAgent);\r\n  WRITE_DATA(Bool, AgentFwd);\r\n  WRITE_DATA(Bool, AuthTIS);\r\n  WRITE_DATA(Bool, AuthKI);\r\n  WRITE_DATA(Bool, AuthKIPassword);\r\n  WRITE_DATA(String, Note);\r\n\r\n  WRITE_DATA(Bool, AuthGSSAPI);\r\n  WRITE_DATA(Bool, GSSAPIFwdTGT);\r\n  Storage->DeleteValue(L\"TryGSSKEX\");\r\n  Storage->DeleteValue(L\"UserNameFromEnvironment\");\r\n  Storage->DeleteValue(\"GSSAPIServerChoosesUserName\");\r\n  Storage->DeleteValue(L\"GSSAPITrustDNS\");\r\n  WRITE_DATA(String, LogicalHostName);\r\n  if (PuttyExport)\r\n  {\r\n    // duplicate kerberos setting with keys of the vintela quest putty\r\n    WRITE_DATA_EX(Bool, L\"AuthSSPI\", AuthGSSAPI, );\r\n    WRITE_DATA_EX(Bool, L\"SSPIFwdTGT\", GSSAPIFwdTGT, );\r\n    WRITE_DATA_EX(String, L\"KerbPrincipal\", LogicalHostName, );\r\n    // duplicate kerberos setting with keys of the official putty\r\n    WRITE_DATA_EX(Bool, L\"GssapiFwd\", GSSAPIFwdTGT, );\r\n  }\r\n\r\n  WRITE_DATA(Bool, ChangeUsername);\r\n  WRITE_DATA(Bool, Compression);\r\n  WRITE_DATA(Integer, SshProt);\r\n  WRITE_DATA(Bool, Ssh2DES);\r\n  WRITE_DATA(Bool, SshNoUserAuth);\r\n  WRITE_DATA_EX(String, L\"Cipher\", CipherList, );\r\n  WRITE_DATA_EX(String, L\"KEX\", KexList, );\r\n  WRITE_DATA_EX(String, L\"HostKey\", HostKeyList, );\r\n  WRITE_DATA_EX(String, L\"GSSLibs\", GssLibList, );\r\n  WRITE_DATA_EX(String, L\"GSSCustom\", GssLibCustom, );\r\n  WRITE_DATA(Integer, AddressFamily);\r\n  WRITE_DATA_EX(String, L\"RekeyBytes\", RekeyData, );\r\n  WRITE_DATA(Integer, RekeyTime);\r\n\r\n  WRITE_DATA(Bool, TcpNoDelay);\r\n\r\n  if (PuttyExport)\r\n  {\r\n    WRITE_DATA(StringRaw, UserName);\r\n    // PuTTY is started in its binary directory to allow relative paths when opening PuTTY's own stored session.\r\n    // To allow relative paths in our sessions, we have to expand them for PuTTY.\r\n    WRITE_DATA_EX(StringRaw, L\"PublicKeyFile\", PublicKeyFile, ExpandFileName);\r\n  }\r\n  else\r\n  {\r\n    WRITE_DATA(String, UserName);\r\n    WRITE_DATA(String, PublicKeyFile);\r\n    WRITE_DATA(Integer, FSProtocol);\r\n    WRITE_DATA(String, LocalDirectory);\r\n    WRITE_DATA(String, RemoteDirectory);\r\n    WRITE_DATA(Bool, SynchronizeBrowsing);\r\n    WRITE_DATA(Bool, UpdateDirectories);\r\n    WRITE_DATA(Bool, CacheDirectories);\r\n    WRITE_DATA(Bool, CacheDirectoryChanges);\r\n    WRITE_DATA(Bool, PreserveDirectoryChanges);\r\n\r\n    WRITE_DATA(Bool, ResolveSymlinks);\r\n    WRITE_DATA(Bool, FollowDirectorySymlinks);\r\n    WRITE_DATA_EX(Integer, L\"ConsiderDST\", DSTMode, );\r\n    WRITE_DATA(Bool, LockInHome);\r\n    // Special is never stored (if it would, login dialog must be modified not to\r\n    // duplicate Special parameter when Special session is loaded and then stored\r\n    // under different name)\r\n    // WRITE_DATA(Bool, Special);\r\n    WRITE_DATA(String, Shell);\r\n    WRITE_DATA(Bool, ClearAliases);\r\n    WRITE_DATA(Bool, UnsetNationalVars);\r\n    WRITE_DATA(String, ListingCommand);\r\n    WRITE_DATA(Bool, IgnoreLsWarnings);\r\n    WRITE_DATA(Integer, SCPLsFullTime);\r\n    WRITE_DATA(Bool, Scp1Compatibility);\r\n    // TimeDifferenceAuto is valid for FTP protocol only.\r\n    // For other protocols it's typically true (default value),\r\n    // but ignored so TimeDifference is still taken into account (SCP only actually)\r\n    if (TimeDifferenceAuto && (FSProtocol == fsFTP))\r\n    {\r\n      // Have to delete it as TimeDifferenceAuto is not saved when enabled,\r\n      // but the default is derived from value of TimeDifference.\r\n      Storage->DeleteValue(L\"TimeDifference\");\r\n    }\r\n    else\r\n    {\r\n      WRITE_DATA(Float, TimeDifference);\r\n    }\r\n    WRITE_DATA(Bool, TimeDifferenceAuto);\r\n    WRITE_DATA(Bool, DeleteToRecycleBin);\r\n    WRITE_DATA(Bool, OverwrittenToRecycleBin);\r\n    WRITE_DATA(String, RecycleBinPath);\r\n    WRITE_DATA(String, PostLoginCommands);\r\n\r\n    WRITE_DATA(String, ReturnVar);\r\n    WRITE_DATA(Bool, ExitCode1IsError);\r\n    WRITE_DATA_EX(Integer, L\"LookupUserGroups2\", LookupUserGroups, );\r\n    WRITE_DATA(Integer, EOLType);\r\n    WRITE_DATA(Bool, TrimVMSVersions);\r\n    Storage->DeleteValue(L\"SFTPUtfBug\");\r\n    WRITE_DATA_EX(Integer, L\"Utf\", NotUtf, );\r\n    WRITE_DATA(Integer, InternalEditorEncoding);\r\n    WRITE_DATA(String, S3DefaultRegion);\r\n    WRITE_DATA(Integer, S3UrlStyle);\r\n    WRITE_DATA(Integer, SendBuf);\r\n    WRITE_DATA(String, SourceAddress);\r\n    WRITE_DATA(Bool, SshSimple);\r\n  }\r\n\r\n  WRITE_DATA(Integer, ProxyMethod);\r\n  WRITE_DATA(String, ProxyHost);\r\n  WRITE_DATA(Integer, ProxyPort);\r\n  WRITE_DATA(String, ProxyUsername);\r\n  if (ProxyMethod == pmCmd)\r\n  {\r\n    WRITE_DATA_EX(StringRaw, L\"ProxyTelnetCommand\", ProxyLocalCommand, );\r\n  }\r\n  else\r\n  {\r\n    WRITE_DATA(StringRaw, ProxyTelnetCommand);\r\n  }\r\n  #define WRITE_DATA_CONV_FUNC(X) (((X) + 2) % 3)\r\n  WRITE_DATA_CONV(Integer, L\"ProxyDNS\", ProxyDNS);\r\n  #undef WRITE_DATA_CONV_FUNC\r\n  WRITE_DATA(Bool, ProxyLocalhost);\r\n\r\n  #define WRITE_DATA_CONV_FUNC(X) (2 - (X))\r\n  #define WRITE_BUG(BUG) WRITE_DATA_CONV(Integer, L\"Bug\" #BUG, Bug[sb##BUG]);\r\n  WRITE_BUG(Ignore1);\r\n  WRITE_BUG(PlainPW1);\r\n  WRITE_BUG(RSA1);\r\n  WRITE_BUG(HMAC2);\r\n  WRITE_BUG(DeriveKey2);\r\n  WRITE_BUG(RSAPad2);\r\n  WRITE_BUG(PKSessID2);\r\n  WRITE_BUG(Rekey2);\r\n  WRITE_BUG(MaxPkt2);\r\n  WRITE_BUG(Ignore2);\r\n  WRITE_BUG(OldGex2);\r\n  WRITE_BUG(WinAdj);\r\n  WRITE_BUG(ChanReq);\r\n  #undef WRITE_BUG\r\n  #undef WRITE_DATA_CONV_FUNC\r\n\r\n  Storage->DeleteValue(L\"BuggyMAC\");\r\n  Storage->DeleteValue(L\"AliasGroupList\");\r\n\r\n  if (PuttyExport)\r\n  {\r\n    WRITE_DATA_EX(String, L\"Protocol\", GetNormalizedPuttyProtocol(), );\r\n    WRITE_DATA(String, WinTitle);\r\n  }\r\n\r\n  if (!PuttyExport)\r\n  {\r\n    WRITE_DATA(String, SftpServer);\r\n\r\n    #define WRITE_SFTP_BUG(BUG) WRITE_DATA_EX(Integer, L\"SFTP\" #BUG \"Bug\", SFTPBug[sb##BUG], );\r\n    WRITE_SFTP_BUG(Symlink);\r\n    WRITE_SFTP_BUG(SignedTS);\r\n    #undef WRITE_SFTP_BUG\r\n\r\n    WRITE_DATA(Integer, SFTPMaxVersion);\r\n    WRITE_DATA(Integer, SFTPMaxPacketSize);\r\n    WRITE_DATA(Integer, SFTPDownloadQueue);\r\n    WRITE_DATA(Integer, SFTPUploadQueue);\r\n    WRITE_DATA(Integer, SFTPListingQueue);\r\n\r\n    WRITE_DATA(Integer, Color);\r\n\r\n    WRITE_DATA(Bool, Tunnel);\r\n    WRITE_DATA(String, TunnelHostName);\r\n    WRITE_DATA(Integer, TunnelPortNumber);\r\n    WRITE_DATA(String, TunnelUserName);\r\n    WRITE_DATA(String, TunnelPublicKeyFile);\r\n    WRITE_DATA(Integer, TunnelLocalPortNumber);\r\n\r\n    WRITE_DATA(Bool, FtpPasvMode);\r\n    WRITE_DATA_EX(Integer, L\"FtpForcePasvIp2\", FtpForcePasvIp, );\r\n    WRITE_DATA(Integer, FtpUseMlsd);\r\n    WRITE_DATA(String, FtpAccount);\r\n    WRITE_DATA(Integer, FtpPingInterval);\r\n    WRITE_DATA(Integer, FtpPingType);\r\n    WRITE_DATA_EX(Integer, L\"FtpTransferActiveImmediately2\", FtpTransferActiveImmediately, );\r\n    WRITE_DATA(Integer, Ftps);\r\n    WRITE_DATA(Integer, FtpListAll);\r\n    WRITE_DATA(Integer, FtpHost);\r\n    WRITE_DATA(Integer, FtpDeleteFromCwd);\r\n    WRITE_DATA(Bool, SslSessionReuse);\r\n    WRITE_DATA(String, TlsCertificateFile);\r\n\r\n    WRITE_DATA(Integer, FtpProxyLogonType);\r\n\r\n    WRITE_DATA(Integer, MinTlsVersion);\r\n    WRITE_DATA(Integer, MaxTlsVersion);\r\n\r\n    WRITE_DATA(Bool, IsWorkspace);\r\n    WRITE_DATA(String, Link);\r\n    WRITE_DATA(String, NameOverride);\r\n\r\n    WRITE_DATA(String, PuttySettings);\r\n\r\n    WRITE_DATA(String, CustomParam1);\r\n    WRITE_DATA(String, CustomParam2);\r\n  }\r\n\r\n  // This is for collecting all keys for TSiteRawDialog::AddButtonClick.\r\n  // It should be enough to test for (Default == NULL),\r\n  // the DoNotEncryptPasswords and PuttyExport were added to limit a possible unintended impact.\r\n  bool SaveAll = (Default == NULL) && DoNotEncryptPasswords && !PuttyExport;\r\n\r\n  SavePasswords(Storage, PuttyExport, DoNotEncryptPasswords, SaveAll);\r\n\r\n  if (PuttyExport)\r\n  {\r\n    WritePuttySettings(Storage, PuttySettings);\r\n  }\r\n}\r\n//---------------------------------------------------------------------\r\nTStrings * __fastcall TSessionData::SaveToOptions(const TSessionData * Default, bool SaveName, bool PuttyExport)\r\n{\r\n  std::unique_ptr<TStringList> Options(new TStringList());\r\n  std::unique_ptr<TOptionsStorage> OptionsStorage(new TOptionsStorage(Options.get(), true));\r\n  if (SaveName)\r\n  {\r\n    OptionsStorage->WriteString(L\"Name\", Name);\r\n  }\r\n  DoSave(OptionsStorage.get(), PuttyExport, Default, true);\r\n  return Options.release();\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::Save(THierarchicalStorage * Storage,\r\n  bool PuttyExport, const TSessionData * Default)\r\n{\r\n  if (Storage->OpenSubKey(InternalStorageKey, true))\r\n  {\r\n    DoSave(Storage, PuttyExport, Default, false);\r\n\r\n    Storage->CloseSubKey();\r\n  }\r\n}\r\n//---------------------------------------------------------------------\r\nUnicodeString __fastcall TSessionData::ReadXmlNode(_di_IXMLNode Node, const UnicodeString & Name, const UnicodeString & Default)\r\n{\r\n  _di_IXMLNode TheNode = Node->ChildNodes->FindNode(Name);\r\n  UnicodeString Result;\r\n  if (TheNode != NULL)\r\n  {\r\n    Result = TheNode->Text.Trim();\r\n  }\r\n\r\n  if (Result.IsEmpty())\r\n  {\r\n    Result = Default;\r\n  }\r\n\r\n  return Result;\r\n}\r\n//---------------------------------------------------------------------\r\nint __fastcall TSessionData::ReadXmlNode(_di_IXMLNode Node, const UnicodeString & Name, int Default)\r\n{\r\n  _di_IXMLNode TheNode = Node->ChildNodes->FindNode(Name);\r\n  int Result;\r\n  if (TheNode != NULL)\r\n  {\r\n    Result = StrToIntDef(TheNode->Text.Trim(), Default);\r\n  }\r\n  else\r\n  {\r\n    Result = Default;\r\n  }\r\n\r\n  return Result;\r\n}\r\n//---------------------------------------------------------------------\r\n_di_IXMLNode __fastcall TSessionData::FindSettingsNode(_di_IXMLNode Node, const UnicodeString & Name)\r\n{\r\n  for (int Index = 0; Index < Node->ChildNodes->Count; Index++)\r\n  {\r\n    _di_IXMLNode ChildNode = Node->ChildNodes->Get(Index);\r\n    if (ChildNode->NodeName == L\"Setting\")\r\n    {\r\n       OleVariant SettingName = ChildNode->GetAttribute(L\"name\");\r\n       if (SettingName == Name)\r\n       {\r\n         return ChildNode;\r\n       }\r\n    }\r\n  }\r\n\r\n  return NULL;\r\n}\r\n//---------------------------------------------------------------------\r\nUnicodeString __fastcall TSessionData::ReadSettingsNode(_di_IXMLNode Node, const UnicodeString & Name, const UnicodeString & Default)\r\n{\r\n  _di_IXMLNode TheNode = FindSettingsNode(Node, Name);\r\n  UnicodeString Result;\r\n  if (TheNode != NULL)\r\n  {\r\n    Result = TheNode->Text.Trim();\r\n  }\r\n\r\n  if (Result.IsEmpty())\r\n  {\r\n    Result = Default;\r\n  }\r\n\r\n  return Result;\r\n}\r\n//---------------------------------------------------------------------\r\nint __fastcall TSessionData::ReadSettingsNode(_di_IXMLNode Node, const UnicodeString & Name, int Default)\r\n{\r\n  _di_IXMLNode TheNode = FindSettingsNode(Node, Name);\r\n  int Result;\r\n  if (TheNode != NULL)\r\n  {\r\n    Result = StrToIntDef(TheNode->Text.Trim(), Default);\r\n  }\r\n  else\r\n  {\r\n    Result = Default;\r\n  }\r\n\r\n  return Result;\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::ImportFromFilezilla(\r\n  _di_IXMLNode Node, const UnicodeString & Path, _di_IXMLNode SettingsNode)\r\n{\r\n  Name = UnixIncludeTrailingBackslash(Path) + MakeValidName(ReadXmlNode(Node, L\"Name\", Name));\r\n  HostName = ReadXmlNode(Node, L\"Host\", HostName);\r\n  PortNumber = ReadXmlNode(Node, L\"Port\", PortNumber);\r\n\r\n  int AProtocol = ReadXmlNode(Node, L\"Protocol\", 0);\r\n  // ServerProtocol enum\r\n  switch (AProtocol)\r\n  {\r\n    case 0: // FTP\r\n    default: // UNKNOWN, HTTP, HTTPS, INSECURE_FTP\r\n      FSProtocol = fsFTP;\r\n      break;\r\n\r\n    case 1: // SFTP\r\n      FSProtocol = fsSFTP;\r\n      break;\r\n\r\n    case 3: // FTPS\r\n      FSProtocol = fsFTP;\r\n      Ftps = ftpsImplicit;\r\n      break;\r\n\r\n    case 4: // FTPES\r\n      FSProtocol = fsFTP;\r\n      Ftps = ftpsExplicitTls;\r\n      break;\r\n  }\r\n\r\n  // LogonType enum\r\n  int LogonType = ReadXmlNode(Node, L\"Logontype\", 0);\r\n  if (LogonType == 0) // ANONYMOUS\r\n  {\r\n    UserName = AnonymousUserName;\r\n    Password = AnonymousPassword;\r\n  }\r\n  else\r\n  {\r\n    UserName = ReadXmlNode(Node, L\"User\", UserName);\r\n    FtpAccount = ReadXmlNode(Node, L\"Account\", FtpAccount);\r\n\r\n    _di_IXMLNode PassNode = Node->ChildNodes->FindNode(L\"Pass\");\r\n    if (PassNode != NULL)\r\n    {\r\n      UnicodeString APassword = PassNode->Text.Trim();\r\n      OleVariant EncodingValue = PassNode->GetAttribute(L\"encoding\");\r\n      if (!EncodingValue.IsNull())\r\n      {\r\n        UnicodeString EncodingValueStr = EncodingValue;\r\n        if (SameText(EncodingValueStr, L\"base64\"))\r\n        {\r\n          TBytes Bytes = DecodeBase64(APassword);\r\n          APassword = TEncoding::UTF8->GetString(Bytes);\r\n        }\r\n      }\r\n      Password = APassword;\r\n    }\r\n  }\r\n\r\n  PublicKeyFile = ReadXmlNode(Node, L\"Keyfile\", PublicKeyFile);\r\n\r\n  int DefaultTimeDifference = TimeToSeconds(TimeDifference);\r\n  TimeDifference =\r\n    (double(ReadXmlNode(Node, L\"TimezoneOffset\", DefaultTimeDifference) / SecsPerDay));\r\n  TimeDifferenceAuto = (TimeDifference == TDateTime());\r\n\r\n  UnicodeString PasvMode = ReadXmlNode(Node, L\"PasvMode\", L\"\");\r\n  if (SameText(PasvMode, L\"MODE_PASSIVE\"))\r\n  {\r\n    FtpPasvMode = true;\r\n  }\r\n  else if (SameText(PasvMode, L\"MODE_ACTIVE\"))\r\n  {\r\n    FtpPasvMode = false;\r\n  }\r\n\r\n  UnicodeString EncodingType = ReadXmlNode(Node, L\"EncodingType\", L\"\");\r\n  if (SameText(EncodingType, L\"Auto\"))\r\n  {\r\n    NotUtf = asAuto;\r\n  }\r\n  else if (SameText(EncodingType, L\"UTF-8\"))\r\n  {\r\n    NotUtf = asOff;\r\n  }\r\n\r\n  // todo PostLoginCommands\r\n\r\n  Note = ReadXmlNode(Node, L\"Comments\", Note);\r\n\r\n  LocalDirectory = ReadXmlNode(Node, L\"LocalDir\", LocalDirectory);\r\n\r\n  UnicodeString RemoteDir = ReadXmlNode(Node, L\"RemoteDir\", L\"\");\r\n  if (!RemoteDir.IsEmpty())\r\n  {\r\n    CutToChar(RemoteDir, L' ', false); // type\r\n    int PrefixSize = StrToIntDef(CutToChar(RemoteDir, L' ', false), 0); // prefix size\r\n    if (PrefixSize > 0)\r\n    {\r\n      RemoteDir.Delete(1, PrefixSize);\r\n    }\r\n    RemoteDirectory = L\"/\";\r\n    while (!RemoteDir.IsEmpty())\r\n    {\r\n      int SegmentSize = StrToIntDef(CutToChar(RemoteDir, L' ', false), 0);\r\n      UnicodeString Segment = RemoteDir.SubString(1, SegmentSize);\r\n      RemoteDirectory = UnixIncludeTrailingBackslash(RemoteDirectory) + Segment;\r\n      RemoteDir.Delete(1, SegmentSize + 1);\r\n    }\r\n  }\r\n\r\n  SynchronizeBrowsing = (ReadXmlNode(Node, L\"SyncBrowsing\", SynchronizeBrowsing ? 1 : 0) != 0);\r\n\r\n  if (SettingsNode != NULL)\r\n  {\r\n    if (UsesSsh && PublicKeyFile.IsEmpty())\r\n    {\r\n      UnicodeString KeyFiles = ReadSettingsNode(SettingsNode, L\"SFTP keyfiles\", UnicodeString());\r\n      UnicodeString KeyFile = CutToChar(KeyFiles, L'\\n', true).Trim();\r\n      KeyFiles = KeyFiles.Trim();\r\n      // If there are more keys, ignore them, as we do not know which one to use\r\n      if (!KeyFile.IsEmpty() && KeyFiles.IsEmpty())\r\n      {\r\n        PublicKeyFile = KeyFile;\r\n      }\r\n    }\r\n\r\n    bool BypassProxy = (ReadXmlNode(Node, L\"BypassProxy\", 0) != 0);\r\n    if (!BypassProxy)\r\n    {\r\n      int FtpProxyType = ReadSettingsNode(SettingsNode, L\"FTP Proxy type\", -1);\r\n      if (FtpProxyType > 0)\r\n      {\r\n        switch (FtpProxyType)\r\n        {\r\n          case 1:\r\n            FtpProxyLogonType = 2;\r\n            break;\r\n          case 2:\r\n            FtpProxyLogonType = 1;\r\n            break;\r\n          case 3:\r\n            FtpProxyLogonType = 3;\r\n            break;\r\n          case 4:\r\n            // custom\r\n            // TODO: map known sequences to our enumeration\r\n            FtpProxyLogonType = 0;\r\n            break;\r\n          default:\r\n            DebugFail();\r\n            FtpProxyLogonType = 0;\r\n            break;\r\n        }\r\n\r\n        ProxyHost = ReadSettingsNode(SettingsNode, L\"FTP Proxy host\", ProxyHost);\r\n        ProxyUsername = ReadSettingsNode(SettingsNode, L\"FTP Proxy user\", ProxyUsername);\r\n        ProxyPassword = ReadSettingsNode(SettingsNode, L\"FTP Proxy password\", ProxyPassword);\r\n        // ProxyPort is not used with FtpProxyLogonType\r\n      }\r\n      else\r\n      {\r\n        int ProxyType = ReadSettingsNode(SettingsNode, L\"Proxy type\", -1);\r\n        if (ProxyType >= 0)\r\n        {\r\n          switch (ProxyType)\r\n          {\r\n            case 0:\r\n              ProxyMethod = ::pmNone;\r\n              break;\r\n\r\n            case 1:\r\n              ProxyMethod = pmHTTP;\r\n              break;\r\n\r\n            case 2:\r\n              ProxyMethod = pmSocks5;\r\n              break;\r\n\r\n            case 3:\r\n              ProxyMethod = pmSocks4;\r\n              break;\r\n\r\n            default:\r\n              DebugFail();\r\n              ProxyMethod = ::pmNone;\r\n              break;\r\n          }\r\n\r\n          ProxyHost = ReadSettingsNode(SettingsNode, L\"Proxy host\", ProxyHost);\r\n          ProxyPort = ReadSettingsNode(SettingsNode, L\"Proxy port\", ProxyPort);\r\n          ProxyUsername = ReadSettingsNode(SettingsNode, L\"Proxy user\", ProxyUsername);\r\n          ProxyPassword = ReadSettingsNode(SettingsNode, L\"Proxy password\", ProxyPassword);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SavePasswords(THierarchicalStorage * Storage, bool PuttyExport, bool DoNotEncryptPasswords, bool SaveAll)\r\n{\r\n  if (!Configuration->DisablePasswordStoring && !PuttyExport && (!FPassword.IsEmpty() || SaveAll))\r\n  {\r\n    if (DoNotEncryptPasswords)\r\n    {\r\n      Storage->WriteString(L\"PasswordPlain\", Password);\r\n      Storage->DeleteValue(L\"Password\");\r\n    }\r\n    else\r\n    {\r\n      Storage->WriteBinaryDataAsString(L\"Password\", StronglyRecryptPassword(FPassword, UserName+HostName));\r\n      Storage->DeleteValue(L\"PasswordPlain\");\r\n    }\r\n  }\r\n  else\r\n  {\r\n    Storage->DeleteValue(L\"Password\");\r\n    Storage->DeleteValue(L\"PasswordPlain\");\r\n  }\r\n\r\n  if (PuttyExport)\r\n  {\r\n    // save password unencrypted\r\n    Storage->WriteString(L\"ProxyPassword\", ProxyPassword);\r\n  }\r\n  else\r\n  {\r\n    if (DoNotEncryptPasswords)\r\n    {\r\n      if (!FProxyPassword.IsEmpty() || SaveAll)\r\n      {\r\n        Storage->WriteString(L\"ProxyPassword\", ProxyPassword);\r\n      }\r\n      else\r\n      {\r\n        Storage->DeleteValue(L\"ProxyPassword\");\r\n      }\r\n      Storage->DeleteValue(L\"ProxyPasswordEnc\");\r\n    }\r\n    else\r\n    {\r\n      // save password encrypted\r\n      if (!FProxyPassword.IsEmpty() || SaveAll)\r\n      {\r\n        Storage->WriteBinaryDataAsString(L\"ProxyPasswordEnc\", StronglyRecryptPassword(FProxyPassword, ProxyUsername+ProxyHost));\r\n      }\r\n      else\r\n      {\r\n        Storage->DeleteValue(L\"ProxyPasswordEnc\");\r\n      }\r\n      Storage->DeleteValue(L\"ProxyPassword\");\r\n    }\r\n\r\n    if (DoNotEncryptPasswords)\r\n    {\r\n      if (!FTunnelPassword.IsEmpty() || SaveAll)\r\n      {\r\n        Storage->WriteString(L\"TunnelPasswordPlain\", TunnelPassword);\r\n      }\r\n      else\r\n      {\r\n        Storage->DeleteValue(L\"TunnelPasswordPlain\");\r\n      }\r\n    }\r\n    else\r\n    {\r\n      if (!Configuration->DisablePasswordStoring && (!FTunnelPassword.IsEmpty() || SaveAll))\r\n      {\r\n        Storage->WriteBinaryDataAsString(L\"TunnelPassword\", StronglyRecryptPassword(FTunnelPassword, TunnelUserName+TunnelHostName));\r\n      }\r\n      else\r\n      {\r\n        Storage->DeleteValue(L\"TunnelPassword\");\r\n      }\r\n    }\r\n\r\n    if (DoNotEncryptPasswords)\r\n    {\r\n      if (!FEncryptKey.IsEmpty() || SaveAll)\r\n      {\r\n        Storage->WriteString(L\"EncryptKeyPlain\", EncryptKey);\r\n      }\r\n      else\r\n      {\r\n        Storage->DeleteValue(L\"EncryptKeyPlain\");\r\n      }\r\n      Storage->DeleteValue(L\"EncryptKey\");\r\n    }\r\n    else\r\n    {\r\n      if (!FEncryptKey.IsEmpty() || SaveAll)\r\n      {\r\n        Storage->WriteBinaryDataAsString(L\"EncryptKey\", StronglyRecryptPassword(FEncryptKey, UserName+HostName));\r\n      }\r\n      else\r\n      {\r\n        Storage->DeleteValue(L\"EncryptKey\");\r\n      }\r\n      Storage->DeleteValue(L\"EncryptKeyPlain\");\r\n    }\r\n  }\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::RecryptPasswords()\r\n{\r\n  Password = Password;\r\n  NewPassword = NewPassword;\r\n  ProxyPassword = ProxyPassword;\r\n  TunnelPassword = TunnelPassword;\r\n  Passphrase = Passphrase;\r\n  EncryptKey = EncryptKey;\r\n}\r\n//---------------------------------------------------------------------\r\nbool __fastcall TSessionData::HasPassword()\r\n{\r\n  return !FPassword.IsEmpty();\r\n}\r\n//---------------------------------------------------------------------\r\nbool __fastcall TSessionData::HasAnySessionPassword()\r\n{\r\n  // Keep in sync with ClearSessionPasswords\r\n  return\r\n    HasPassword() ||\r\n    !FTunnelPassword.IsEmpty()  ||\r\n    // will probably be never used\r\n    !FNewPassword.IsEmpty();\r\n}\r\n//---------------------------------------------------------------------\r\nbool __fastcall TSessionData::HasAnyPassword()\r\n{\r\n  // Keep in sync with MaskPasswords\r\n  return\r\n    HasAnySessionPassword() ||\r\n    !FProxyPassword.IsEmpty() ||\r\n    !FEncryptKey.IsEmpty() ||\r\n    !FPassphrase.IsEmpty();\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::ClearSessionPasswords()\r\n{\r\n  // Keep in sync with HasAnySessionPassword\r\n  FPassword = L\"\";\r\n  FNewPassword = L\"\";\r\n  FTunnelPassword = L\"\";\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::Modify()\r\n{\r\n  FModified = true;\r\n  if (FSource == ssStored)\r\n  {\r\n    FSource = ssStoredModified;\r\n  }\r\n}\r\n//---------------------------------------------------------------------\r\nUnicodeString __fastcall TSessionData::GetSource()\r\n{\r\n  switch (FSource)\r\n  {\r\n    case ::ssNone:\r\n      return L\"Ad-Hoc site\";\r\n\r\n    case ssStored:\r\n      return L\"Site\";\r\n\r\n    case ssStoredModified:\r\n      return L\"Modified site\";\r\n\r\n    default:\r\n      DebugFail();\r\n      return L\"\";\r\n  }\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SaveRecryptedPasswords(THierarchicalStorage * Storage)\r\n{\r\n  if (Storage->OpenSubKey(InternalStorageKey, true))\r\n  {\r\n    try\r\n    {\r\n      RecryptPasswords();\r\n\r\n      SavePasswords(Storage, false, false, false);\r\n    }\r\n    __finally\r\n    {\r\n      Storage->CloseSubKey();\r\n    }\r\n  }\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::Remove(THierarchicalStorage * Storage, const UnicodeString & Name)\r\n{\r\n  Storage->RecursiveDeleteSubKey(Name);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::Remove()\r\n{\r\n  bool SessionList = true;\r\n  THierarchicalStorage * Storage = Configuration->CreateScpStorage(SessionList);\r\n  try\r\n  {\r\n    Storage->Explicit = true;\r\n    if (Storage->OpenSubKey(Configuration->StoredSessionsSubKey, false))\r\n    {\r\n      Remove(Storage, InternalStorageKey);\r\n    }\r\n  }\r\n  __finally\r\n  {\r\n    delete Storage;\r\n  }\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::CacheHostKeyIfNotCached()\r\n{\r\n  UnicodeString KeyType = KeyTypeFromFingerprint(HostKey);\r\n\r\n  // Should allow importing to INI file as ImportHostKeys\r\n  UnicodeString TargetKey = Configuration->RegistryStorageKey + L\"\\\\\" + Configuration->SshHostKeysSubKey;\r\n  std::unique_ptr<TRegistryStorage> Storage(new TRegistryStorage(TargetKey));\r\n  Storage->AccessMode = smReadWrite;\r\n  if (Storage->OpenRootKey(true))\r\n  {\r\n    UnicodeString HostKeyName = PuttyMungeStr(FORMAT(L\"%s@%d:%s\", (KeyType, PortNumber, HostName)));\r\n    if (!Storage->ValueExists(HostKeyName))\r\n    {\r\n      // fingerprint is a checksum of a host key, so it cannot be translated back to host key,\r\n      // so we store fingerprint and TSecureShell::VerifyHostKey was\r\n      // modified to accept also fingerprint\r\n      Storage->WriteString(HostKeyName, HostKey);\r\n    }\r\n  }\r\n}\r\n//---------------------------------------------------------------------\r\ninline void __fastcall MoveStr(UnicodeString & Source, UnicodeString * Dest, int Count)\r\n{\r\n  if (Dest != NULL)\r\n  {\r\n    (*Dest) += Source.SubString(1, Count);\r\n  }\r\n\r\n  Source.Delete(1, Count);\r\n}\r\n//---------------------------------------------------------------------\r\nbool __fastcall TSessionData::DoIsProtocolUrl(\r\n  const UnicodeString & Url, const UnicodeString & Protocol, int & ProtocolLen)\r\n{\r\n  bool Result = SameText(Url.SubString(1, Protocol.Length() + 1), Protocol + L\":\");\r\n  if (Result)\r\n  {\r\n    ProtocolLen = Protocol.Length() + 1;\r\n  }\r\n  return Result;\r\n}\r\n//---------------------------------------------------------------------\r\nbool __fastcall TSessionData::IsProtocolUrl(\r\n  const UnicodeString & Url, const UnicodeString & Protocol, int & ProtocolLen)\r\n{\r\n  return\r\n    DoIsProtocolUrl(Url, Protocol, ProtocolLen) ||\r\n    DoIsProtocolUrl(Url, WinSCPProtocolPrefix + Protocol, ProtocolLen);\r\n}\r\n//---------------------------------------------------------------------\r\nbool __fastcall TSessionData::IsSensitiveOption(const UnicodeString & Option)\r\n{\r\n  return\r\n    SameText(Option, PassphraseOption) ||\r\n    SameText(Option, NEWPASSWORD_SWITCH);\r\n}\r\n//---------------------------------------------------------------------\r\nbool __fastcall TSessionData::IsOptionWithParameters(const UnicodeString & Option)\r\n{\r\n  return SameText(Option, RawSettingsOption);\r\n}\r\n//---------------------------------------------------------------------\r\nbool __fastcall TSessionData::MaskPasswordInOptionParameter(const UnicodeString & Option, UnicodeString & Param)\r\n{\r\n  bool Result = false;\r\n  if (SameText(Option, RawSettingsOption))\r\n  {\r\n    int P = Param.Pos(L\"=\");\r\n    if (P > 0)\r\n    {\r\n      // TStrings.IndexOfName does not trim\r\n      UnicodeString Key = Param.SubString(1, P - 1);\r\n\r\n      if (SameText(Key, L\"ProxyPassword\") ||\r\n          SameText(Key, L\"ProxyPasswordEnc\") ||\r\n          SameText(Key, L\"TunnelPassword\") ||\r\n          SameText(Key, L\"TunnelPasswordPlain\") ||\r\n          SameText(Key, L\"EncryptKey\"))\r\n      {\r\n        Param = Key + L\"=\" + PasswordMask;\r\n        Result = true;\r\n      }\r\n    }\r\n  }\r\n  return Result;\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::MaskPasswords()\r\n{\r\n  // Keep in sync with HasAnyPassword\r\n  if (!Password.IsEmpty())\r\n  {\r\n    Password = PasswordMask;\r\n  }\r\n  if (!NewPassword.IsEmpty())\r\n  {\r\n    NewPassword = PasswordMask;\r\n  }\r\n  if (!ProxyPassword.IsEmpty())\r\n  {\r\n    ProxyPassword = PasswordMask;\r\n  }\r\n  if (!TunnelPassword.IsEmpty())\r\n  {\r\n    TunnelPassword = PasswordMask;\r\n  }\r\n  if (!EncryptKey.IsEmpty())\r\n  {\r\n    EncryptKey = PasswordMask;\r\n  }\r\n  if (!Passphrase.IsEmpty())\r\n  {\r\n    Passphrase = PasswordMask;\r\n  }\r\n}\r\n//---------------------------------------------------------------------\r\nbool __fastcall TSessionData::ParseUrl(UnicodeString Url, TOptions * Options,\r\n  TStoredSessionList * StoredSessions, bool & DefaultsOnly, UnicodeString * FileName,\r\n  bool * AProtocolDefined, UnicodeString * MaskedUrl, int Flags)\r\n{\r\n  bool ProtocolDefined = false;\r\n  bool PortNumberDefined = false;\r\n  TFSProtocol AFSProtocol;\r\n  int APortNumber;\r\n  TFtps AFtps = ftpsNone;\r\n  int ProtocolLen = 0;\r\n  if (IsProtocolUrl(Url, ScpProtocol, ProtocolLen))\r\n  {\r\n    AFSProtocol = fsSCPonly;\r\n    APortNumber = SshPortNumber;\r\n    MoveStr(Url, MaskedUrl, ProtocolLen);\r\n    ProtocolDefined = true;\r\n  }\r\n  else if (IsProtocolUrl(Url, SftpProtocol, ProtocolLen))\r\n  {\r\n    AFSProtocol = fsSFTPonly;\r\n    APortNumber = SshPortNumber;\r\n    MoveStr(Url, MaskedUrl, ProtocolLen);\r\n    ProtocolDefined = true;\r\n  }\r\n  else if (IsProtocolUrl(Url, FtpProtocol, ProtocolLen))\r\n  {\r\n    AFSProtocol = fsFTP;\r\n    Ftps = ftpsNone;\r\n    APortNumber = FtpPortNumber;\r\n    MoveStr(Url, MaskedUrl, ProtocolLen);\r\n    ProtocolDefined = true;\r\n  }\r\n  else if (IsProtocolUrl(Url, FtpsProtocol, ProtocolLen))\r\n  {\r\n    AFSProtocol = fsFTP;\r\n    AFtps = ftpsImplicit;\r\n    APortNumber = FtpsImplicitPortNumber;\r\n    MoveStr(Url, MaskedUrl, ProtocolLen);\r\n    ProtocolDefined = true;\r\n  }\r\n  else if (IsProtocolUrl(Url, FtpesProtocol, ProtocolLen))\r\n  {\r\n    AFSProtocol = fsFTP;\r\n    AFtps = ftpsExplicitTls;\r\n    APortNumber = FtpPortNumber;\r\n    MoveStr(Url, MaskedUrl, ProtocolLen);\r\n    ProtocolDefined = true;\r\n  }\r\n  else if (IsProtocolUrl(Url, WebDAVProtocol, ProtocolLen) ||\r\n           IsProtocolUrl(Url, HttpProtocol, ProtocolLen))\r\n  {\r\n    AFSProtocol = fsWebDAV;\r\n    AFtps = ftpsNone;\r\n    APortNumber = HTTPPortNumber;\r\n    MoveStr(Url, MaskedUrl, ProtocolLen);\r\n    ProtocolDefined = true;\r\n  }\r\n  else if (IsProtocolUrl(Url, WebDAVSProtocol, ProtocolLen) ||\r\n           IsProtocolUrl(Url, HttpsProtocol, ProtocolLen))\r\n  {\r\n    AFSProtocol = fsWebDAV;\r\n    AFtps = ftpsImplicit;\r\n    APortNumber = HTTPSPortNumber;\r\n    MoveStr(Url, MaskedUrl, ProtocolLen);\r\n    ProtocolDefined = true;\r\n  }\r\n  else if (IsProtocolUrl(Url, S3Protocol, ProtocolLen))\r\n  {\r\n    AFSProtocol = fsS3;\r\n    AFtps = ftpsImplicit;\r\n    APortNumber = HTTPSPortNumber;\r\n    MoveStr(Url, MaskedUrl, ProtocolLen);\r\n    ProtocolDefined = true;\r\n  }\r\n  else if (IsProtocolUrl(Url, SshProtocol, ProtocolLen))\r\n  {\r\n    // For most uses, handling ssh:// the same way as sftp://\r\n    // The only place where a difference is made is GetLoginData() in WinMain.cpp\r\n    AFSProtocol = fsSFTPonly;\r\n    PuttyProtocol = PuttySshProtocol;\r\n    APortNumber = SshPortNumber;\r\n    MoveStr(Url, MaskedUrl, ProtocolLen);\r\n    ProtocolDefined = true;\r\n  }\r\n\r\n  if (ProtocolDefined && (Url.SubString(1, 2) == L\"//\"))\r\n  {\r\n    MoveStr(Url, MaskedUrl, 2);\r\n  }\r\n\r\n  if (AProtocolDefined != NULL)\r\n  {\r\n    *AProtocolDefined = ProtocolDefined;\r\n  }\r\n\r\n  if (!Url.IsEmpty())\r\n  {\r\n    UnicodeString DecodedUrl = DecodeUrlChars(Url);\r\n    // lookup stored session even if protocol was defined\r\n    // (this allows setting for example default username for host\r\n    // by creating stored session named by host)\r\n    TSessionData * Data = NULL;\r\n    // When using to paste URL on Login dialog, we do not want to lookup the stored sites\r\n    if ((StoredSessions != NULL) &&\r\n        (!ProtocolDefined || FLAGSET(Flags, pufAllowStoredSiteWithProtocol)))\r\n    {\r\n      // this can be optimized as the list is sorted\r\n      for (Integer Index = 0; Index < StoredSessions->CountIncludingHidden; Index++)\r\n      {\r\n        TSessionData * AData = (TSessionData *)StoredSessions->Items[Index];\r\n        if (!AData->IsWorkspace)\r\n        {\r\n          bool Match = false;\r\n          // Comparison optimizations as this is called many times\r\n          // e.g. when updating jumplist\r\n          if ((AData->Name.Length() == DecodedUrl.Length()) &&\r\n              SameText(AData->Name, DecodedUrl))\r\n          {\r\n            Match = true;\r\n          }\r\n          else if ((AData->Name.Length() < DecodedUrl.Length()) &&\r\n                   (DecodedUrl[AData->Name.Length() + 1] == L'/') &&\r\n                   // StrLIComp is an equivalent of SameText\r\n                   (StrLIComp(AData->Name.c_str(), DecodedUrl.c_str(), AData->Name.Length()) == 0))\r\n          {\r\n            Match = true;\r\n          }\r\n\r\n          if (Match)\r\n          {\r\n            Data = AData;\r\n            break;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    UnicodeString ARemoteDirectory;\r\n\r\n    if (Data != NULL)\r\n    {\r\n      Assign(Data);\r\n      int P = 1;\r\n      while (!AnsiSameText(DecodeUrlChars(Url.SubString(1, P)), Data->Name))\r\n      {\r\n        P++;\r\n        DebugAssert(P <= Url.Length());\r\n      }\r\n      ARemoteDirectory = Url.SubString(P + 1, Url.Length() - P);\r\n\r\n      if (Data->Hidden)\r\n      {\r\n        Data->Remove();\r\n        StoredSessions->Remove(Data);\r\n        // only modified, implicit\r\n        StoredSessions->Save(false, false);\r\n      }\r\n\r\n      if (MaskedUrl != NULL)\r\n      {\r\n        (*MaskedUrl) += Url;\r\n      }\r\n    }\r\n    else\r\n    {\r\n      // This happens when pasting URL on Login dialog\r\n      if (StoredSessions != NULL)\r\n      {\r\n        CopyData(StoredSessions->DefaultSettings);\r\n      }\r\n      Name = L\"\";\r\n\r\n      int PSlash = Url.Pos(L\"/\");\r\n      if (PSlash == 0)\r\n      {\r\n        PSlash = Url.Length() + 1;\r\n      }\r\n\r\n      UnicodeString ConnectInfo = Url.SubString(1, PSlash - 1);\r\n\r\n      int P = ConnectInfo.LastDelimiter(L\"@\");\r\n\r\n      UnicodeString UserInfo;\r\n      UnicodeString HostInfo;\r\n\r\n      if (P > 0)\r\n      {\r\n        UserInfo = ConnectInfo.SubString(1, P - 1);\r\n        HostInfo = ConnectInfo.SubString(P + 1, ConnectInfo.Length() - P);\r\n      }\r\n      else\r\n      {\r\n        HostInfo = ConnectInfo;\r\n      }\r\n\r\n      UnicodeString OrigHostInfo = HostInfo;\r\n      if ((HostInfo.Length() >= 2) && (HostInfo[1] == L'[') && ((P = HostInfo.Pos(L\"]\")) > 0))\r\n      {\r\n        HostName = HostInfo.SubString(2, P - 2);\r\n        HostInfo.Delete(1, P);\r\n        if (!HostInfo.IsEmpty() && (HostInfo[1] == L':'))\r\n        {\r\n          HostInfo.Delete(1, 1);\r\n        }\r\n      }\r\n      else\r\n      {\r\n        HostName = DecodeUrlChars(CutToChar(HostInfo, L':', true));\r\n      }\r\n\r\n      // expanded from ?: operator, as it caused strange \"access violation\" errors\r\n      if (!HostInfo.IsEmpty())\r\n      {\r\n        PortNumber = StrToIntDef(DecodeUrlChars(HostInfo), -1);\r\n        PortNumberDefined = true;\r\n      }\r\n      else if (ProtocolDefined)\r\n      {\r\n        PortNumber = APortNumber;\r\n      }\r\n\r\n      if (ProtocolDefined)\r\n      {\r\n        Ftps = AFtps;\r\n      }\r\n\r\n      UnicodeString UserInfoWithoutConnectionParams = CutToChar(UserInfo, UrlParamSeparator, false);\r\n      UnicodeString ConnectionParams = UserInfo;\r\n      UserInfo = UserInfoWithoutConnectionParams;\r\n\r\n      std::unique_ptr<TStrings> RawSettings(new TStringList());\r\n\r\n      while (!ConnectionParams.IsEmpty())\r\n      {\r\n        UnicodeString ConnectionParam = CutToChar(ConnectionParams, UrlParamSeparator, false);\r\n        UnicodeString ConnectionParamName = CutToChar(ConnectionParam, UrlParamValueSeparator, false);\r\n        if (SameText(ConnectionParamName, UrlHostKeyParamName))\r\n        {\r\n          HostKey = DecodeUrlChars(ConnectionParam);\r\n          FOverrideCachedHostKey = false;\r\n        }\r\n        else if (StartsText(UrlRawSettingsParamNamePrefix, ConnectionParamName))\r\n        {\r\n          UnicodeString AName = RightStr(ConnectionParamName, ConnectionParamName.Length() - UrlRawSettingsParamNamePrefix.Length());\r\n          AName = DecodeUrlChars(AName);\r\n          UnicodeString Value = DecodeUrlChars(ConnectionParam);\r\n          if (SameText(AName, L\"Name\"))\r\n          {\r\n            Name = Value;\r\n          }\r\n          else\r\n          {\r\n            RawSettings->Values[AName] = Value;\r\n          }\r\n        }\r\n      }\r\n\r\n      if (RawSettings->Count > 0) // optimization\r\n      {\r\n        ApplyRawSettings(RawSettings.get());\r\n      }\r\n\r\n      bool HasPassword = (UserInfo.Pos(L':') > 0);\r\n      UnicodeString RawUserName = CutToChar(UserInfo, L':', false);\r\n      UserName = DecodeUrlChars(RawUserName);\r\n\r\n      Password = DecodeUrlChars(UserInfo);\r\n      if (HasPassword && Password.IsEmpty())\r\n      {\r\n        Password = EmptyString;\r\n      }\r\n\r\n      UnicodeString RemoteDirectoryWithSessionParams = Url.SubString(PSlash, Url.Length() - PSlash + 1);\r\n      ARemoteDirectory = CutToChar(RemoteDirectoryWithSessionParams, UrlParamSeparator, false);\r\n      UnicodeString SessionParams = RemoteDirectoryWithSessionParams;\r\n\r\n      // We should handle session params in \"stored session\" branch too.\r\n      // And particularly if there's a \"save\" param, we should actually not try to match the\r\n      // URL against site names\r\n      while (!SessionParams.IsEmpty())\r\n      {\r\n        UnicodeString SessionParam = CutToChar(SessionParams, UrlParamSeparator, false);\r\n        UnicodeString SessionParamName = CutToChar(SessionParam, UrlParamValueSeparator, false);\r\n        if (SameText(SessionParamName, UrlSaveParamName))\r\n        {\r\n          FSaveOnly = (StrToIntDef(SessionParam, 1) != 0);\r\n        }\r\n      }\r\n\r\n      if (MaskedUrl != NULL)\r\n      {\r\n        (*MaskedUrl) += RawUserName;\r\n        if (HasPassword)\r\n        {\r\n          (*MaskedUrl) += L\":\" + PasswordMask;\r\n        }\r\n        if (!RawUserName.IsEmpty() || HasPassword)\r\n        {\r\n          (*MaskedUrl) += L\"@\";\r\n        }\r\n        (*MaskedUrl) += OrigHostInfo + ARemoteDirectory;\r\n      }\r\n    }\r\n\r\n    if (!ARemoteDirectory.IsEmpty() && (ARemoteDirectory != L\"/\"))\r\n    {\r\n      if ((ARemoteDirectory[ARemoteDirectory.Length()] != L'/') &&\r\n          (FileName != NULL))\r\n      {\r\n        *FileName = DecodeUrlChars(UnixExtractFileName(ARemoteDirectory));\r\n        ARemoteDirectory = UnixExtractFilePath(ARemoteDirectory);\r\n      }\r\n      RemoteDirectory = DecodeUrlChars(ARemoteDirectory);\r\n    }\r\n\r\n    DefaultsOnly = false;\r\n  }\r\n  else\r\n  {\r\n    // This happens when pasting URL on Login dialog\r\n    if (StoredSessions != NULL)\r\n    {\r\n      CopyData(StoredSessions->DefaultSettings);\r\n    }\r\n\r\n    DefaultsOnly = true;\r\n  }\r\n\r\n  if (ProtocolDefined)\r\n  {\r\n    FSProtocol = AFSProtocol;\r\n  }\r\n\r\n  if (Options != NULL)\r\n  {\r\n    // we deliberately do keep defaultonly to false, in presence of any option,\r\n    // as the option should not make session \"connectable\"\r\n\r\n    UnicodeString Value;\r\n    if (Options->FindSwitch(SESSIONNAME_SWICH, Value))\r\n    {\r\n      Name = Value;\r\n    }\r\n    if (Options->FindSwitch(NEWPASSWORD_SWITCH, Value))\r\n    {\r\n      ChangePassword = true;\r\n      NewPassword = Value;\r\n    }\r\n    if (Options->FindSwitch(L\"privatekey\", Value))\r\n    {\r\n      PublicKeyFile = Value;\r\n    }\r\n    if (Options->FindSwitch(L\"clientcert\", Value))\r\n    {\r\n      TlsCertificateFile = Value;\r\n    }\r\n    if (Options->FindSwitch(PassphraseOption, Value))\r\n    {\r\n      Passphrase = Value;\r\n    }\r\n    if (Options->FindSwitch(L\"timeout\", Value))\r\n    {\r\n      Timeout = StrToInt(Value);\r\n    }\r\n    if (Options->FindSwitch(L\"hostkey\", Value) ||\r\n        Options->FindSwitch(L\"certificate\", Value))\r\n    {\r\n      HostKey = Value;\r\n      FOverrideCachedHostKey = true;\r\n    }\r\n    FtpPasvMode = Options->SwitchValue(L\"passive\", FtpPasvMode);\r\n    if (Options->FindSwitch(L\"implicit\"))\r\n    {\r\n      bool Enabled = Options->SwitchValue(L\"implicit\", true);\r\n      Ftps = Enabled ? ftpsImplicit : ftpsNone;\r\n      if (!PortNumberDefined && Enabled)\r\n      {\r\n        PortNumber = FtpsImplicitPortNumber;\r\n      }\r\n    }\r\n    // BACKWARD COMPATIBILITY with 5.5.x\r\n    if (Options->FindSwitch(L\"explicitssl\"))\r\n    {\r\n      bool Enabled = Options->SwitchValue(L\"explicitssl\", true);\r\n      Ftps = Enabled ? ftpsExplicitSsl : ftpsNone;\r\n      if (!PortNumberDefined && Enabled)\r\n      {\r\n        PortNumber = FtpPortNumber;\r\n      }\r\n    }\r\n    if (Options->FindSwitch(L\"explicit\") ||\r\n        // BACKWARD COMPATIBILITY with 5.5.x\r\n        Options->FindSwitch(L\"explicittls\"))\r\n    {\r\n      UnicodeString SwitchName =\r\n        Options->FindSwitch(L\"explicit\") ? L\"explicit\" : L\"explicittls\";\r\n      bool Enabled = Options->SwitchValue(SwitchName, true);\r\n      Ftps = Enabled ? ftpsExplicitTls : ftpsNone;\r\n      if (!PortNumberDefined && Enabled)\r\n      {\r\n        PortNumber = FtpPortNumber;\r\n      }\r\n    }\r\n    if (Options->FindSwitch(RawSettingsOption))\r\n    {\r\n      std::unique_ptr<TStrings> RawSettings(new TStringList());\r\n      if (Options->FindSwitch(RawSettingsOption, RawSettings.get()))\r\n      {\r\n        ApplyRawSettings(RawSettings.get());\r\n      }\r\n    }\r\n  }\r\n\r\n  return true;\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::ApplyRawSettings(TStrings * RawSettings)\r\n{\r\n  std::unique_ptr<TOptionsStorage> OptionsStorage(new TOptionsStorage(RawSettings, false));\r\n  ApplyRawSettings(OptionsStorage.get());\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::ApplyRawSettings(THierarchicalStorage * Storage)\r\n{\r\n  bool Dummy;\r\n  DoLoad(Storage, false, Dummy);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::ConfigureTunnel(int APortNumber)\r\n{\r\n  FOrigHostName = HostName;\r\n  FOrigPortNumber = PortNumber;\r\n  FOrigProxyMethod = ProxyMethod;\r\n\r\n  HostName = L\"127.0.0.1\";\r\n  PortNumber = APortNumber;\r\n  // proxy settings is used for tunnel\r\n  ProxyMethod = ::pmNone;\r\n  FLogicalHostName = FOrigHostName;\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::RollbackTunnel()\r\n{\r\n  HostName = FOrigHostName;\r\n  PortNumber = FOrigPortNumber;\r\n  ProxyMethod = FOrigProxyMethod;\r\n  FLogicalHostName = L\"\";\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::ExpandEnvironmentVariables()\r\n{\r\n  HostName = HostNameExpanded;\r\n  UserName = UserNameExpanded;\r\n  PublicKeyFile = ::ExpandEnvironmentVariables(PublicKeyFile);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::ValidatePath(const UnicodeString Path)\r\n{\r\n  // noop\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::ValidateName(const UnicodeString Name)\r\n{\r\n  // keep consistent with MakeValidName\r\n  if (Name.LastDelimiter(L\"/\") > 0)\r\n  {\r\n    throw Exception(FMTLOAD(ITEM_NAME_INVALID, (Name, L\"/\")));\r\n  }\r\n}\r\n//---------------------------------------------------------------------\r\nUnicodeString __fastcall TSessionData::MakeValidName(const UnicodeString & Name)\r\n{\r\n  // keep consistent with ValidateName\r\n  return ReplaceStr(Name, L\"/\", L\"\\\\\");\r\n}\r\n//---------------------------------------------------------------------\r\nRawByteString __fastcall TSessionData::EncryptPassword(const UnicodeString & Password, UnicodeString Key)\r\n{\r\n  return Configuration->EncryptPassword(Password, Key);\r\n}\r\n//---------------------------------------------------------------------\r\nRawByteString __fastcall TSessionData::StronglyRecryptPassword(const RawByteString & Password, UnicodeString Key)\r\n{\r\n  return Configuration->StronglyRecryptPassword(Password, Key);\r\n}\r\n//---------------------------------------------------------------------\r\nUnicodeString __fastcall TSessionData::DecryptPassword(const RawByteString & Password, UnicodeString Key)\r\n{\r\n  UnicodeString Result;\r\n  try\r\n  {\r\n    Result = Configuration->DecryptPassword(Password, Key);\r\n  }\r\n  catch(EAbort &)\r\n  {\r\n    // silently ignore aborted prompts for master password and return empty password\r\n  }\r\n  return Result;\r\n}\r\n//---------------------------------------------------------------------\r\nbool __fastcall TSessionData::GetCanLogin()\r\n{\r\n  return !FHostName.IsEmpty();\r\n}\r\n//---------------------------------------------------------------------------\r\nUnicodeString __fastcall TSessionData::GetSessionKey()\r\n{\r\n  UnicodeString Result = FORMAT(L\"%s@%s\", (UserName, HostName));\r\n  if (PortNumber != DefaultPort(FSProtocol, Ftps))\r\n  {\r\n    Result += FORMAT(L\":%d\", (PortNumber));\r\n  }\r\n  return Result;\r\n}\r\n//---------------------------------------------------------------------\r\nUnicodeString __fastcall TSessionData::GetInternalStorageKey()\r\n{\r\n  // This is probably useless remnant of previous use of this method from OpenSessionInPutty\r\n  // that needs the method to return something even for ad-hoc sessions\r\n  if (Name.IsEmpty())\r\n  {\r\n    return SessionKey;\r\n  }\r\n  else\r\n  {\r\n    return Name;\r\n  }\r\n}\r\n//---------------------------------------------------------------------\r\nUnicodeString __fastcall TSessionData::GetStorageKey()\r\n{\r\n  return SessionName;\r\n}\r\n//---------------------------------------------------------------------\r\nUnicodeString __fastcall TSessionData::FormatSiteKey(const UnicodeString & HostName, int PortNumber)\r\n{\r\n  return FORMAT(L\"%s:%d\", (HostName, PortNumber));\r\n}\r\n//---------------------------------------------------------------------\r\nUnicodeString __fastcall TSessionData::GetSiteKey()\r\n{\r\n  return FormatSiteKey(HostNameExpanded, PortNumber);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetHostName(UnicodeString value)\r\n{\r\n  if (FHostName != value)\r\n  {\r\n    // HostName is key for password encryption\r\n    UnicodeString XPassword = Password;\r\n    UnicodeString XNewPassword = Password;\r\n    UnicodeString XEncryptKey = EncryptKey;\r\n\r\n    // This is now hardly used as hostname is parsed directly on login dialog.\r\n    // But can be used when importing sites from PuTTY, as it allows same format too.\r\n    int P = value.LastDelimiter(L\"@\");\r\n    if (P > 0)\r\n    {\r\n      UserName = value.SubString(1, P - 1);\r\n      value = value.SubString(P + 1, value.Length() - P);\r\n    }\r\n    FHostName = value;\r\n    Modify();\r\n\r\n    Password = XPassword;\r\n    NewPassword = XNewPassword;\r\n    EncryptKey = XEncryptKey;\r\n    Shred(XPassword);\r\n    Shred(XNewPassword);\r\n    Shred(XEncryptKey);\r\n  }\r\n}\r\n//---------------------------------------------------------------------\r\nUnicodeString __fastcall TSessionData::GetHostNameExpanded()\r\n{\r\n  return ::ExpandEnvironmentVariables(HostName);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetPortNumber(int value)\r\n{\r\n  SET_SESSION_PROPERTY(PortNumber);\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetShell(UnicodeString value)\r\n{\r\n  SET_SESSION_PROPERTY(Shell);\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetSftpServer(UnicodeString value)\r\n{\r\n  SET_SESSION_PROPERTY(SftpServer);\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetClearAliases(bool value)\r\n{\r\n  SET_SESSION_PROPERTY(ClearAliases);\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetListingCommand(UnicodeString value)\r\n{\r\n  SET_SESSION_PROPERTY(ListingCommand);\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetIgnoreLsWarnings(bool value)\r\n{\r\n  SET_SESSION_PROPERTY(IgnoreLsWarnings);\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetUnsetNationalVars(bool value)\r\n{\r\n  SET_SESSION_PROPERTY(UnsetNationalVars);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetUserName(UnicodeString value)\r\n{\r\n  // Avoid password recryption (what may popup master password prompt)\r\n  if (FUserName != value)\r\n  {\r\n    // UserName is key for password encryption\r\n    UnicodeString XPassword = Password;\r\n    UnicodeString XNewPassword = NewPassword;\r\n    UnicodeString XEncryptKey = EncryptKey;\r\n    SET_SESSION_PROPERTY(UserName);\r\n    Password = XPassword;\r\n    NewPassword = XNewPassword;\r\n    EncryptKey = XEncryptKey;\r\n    Shred(XPassword);\r\n    Shred(XNewPassword);\r\n    Shred(XEncryptKey);\r\n  }\r\n}\r\n//---------------------------------------------------------------------\r\nUnicodeString __fastcall TSessionData::GetUserNameExpanded()\r\n{\r\n  return ::ExpandEnvironmentVariables(UserName);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetPassword(UnicodeString avalue)\r\n{\r\n  RawByteString value = EncryptPassword(avalue, UserName+HostName);\r\n  SET_SESSION_PROPERTY(Password);\r\n}\r\n//---------------------------------------------------------------------\r\nUnicodeString __fastcall TSessionData::GetPassword() const\r\n{\r\n  return DecryptPassword(FPassword, UserName+HostName);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetNewPassword(UnicodeString avalue)\r\n{\r\n  RawByteString value = EncryptPassword(avalue, UserName+HostName);\r\n  SET_SESSION_PROPERTY(NewPassword);\r\n}\r\n//---------------------------------------------------------------------\r\nUnicodeString __fastcall TSessionData::GetNewPassword() const\r\n{\r\n  return DecryptPassword(FNewPassword, UserName+HostName);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetChangePassword(bool value)\r\n{\r\n  SET_SESSION_PROPERTY(ChangePassword);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetPingInterval(int value)\r\n{\r\n  SET_SESSION_PROPERTY(PingInterval);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetTryAgent(bool value)\r\n{\r\n  SET_SESSION_PROPERTY(TryAgent);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetAgentFwd(bool value)\r\n{\r\n  SET_SESSION_PROPERTY(AgentFwd);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetAuthTIS(bool value)\r\n{\r\n  SET_SESSION_PROPERTY(AuthTIS);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetAuthKI(bool value)\r\n{\r\n  SET_SESSION_PROPERTY(AuthKI);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetAuthKIPassword(bool value)\r\n{\r\n  SET_SESSION_PROPERTY(AuthKIPassword);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetAuthGSSAPI(bool value)\r\n{\r\n  SET_SESSION_PROPERTY(AuthGSSAPI);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetGSSAPIFwdTGT(bool value)\r\n{\r\n  SET_SESSION_PROPERTY(GSSAPIFwdTGT);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetChangeUsername(bool value)\r\n{\r\n  SET_SESSION_PROPERTY(ChangeUsername);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetCompression(bool value)\r\n{\r\n  SET_SESSION_PROPERTY(Compression);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetSshProt(TSshProt value)\r\n{\r\n  SET_SESSION_PROPERTY(SshProt);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetSsh2DES(bool value)\r\n{\r\n  SET_SESSION_PROPERTY(Ssh2DES);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetSshNoUserAuth(bool value)\r\n{\r\n  SET_SESSION_PROPERTY(SshNoUserAuth);\r\n}\r\n//---------------------------------------------------------------------\r\nUnicodeString __fastcall TSessionData::GetSshProtStr()\r\n{\r\n  return SshProtList[FSshProt];\r\n}\r\n//---------------------------------------------------------------------\r\nbool __fastcall TSessionData::GetUsesSsh()\r\n{\r\n  return IsSshProtocol(FSProtocol);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetCipher(int Index, TCipher value)\r\n{\r\n  DebugAssert(Index >= 0 && Index < CIPHER_COUNT);\r\n  SET_SESSION_PROPERTY(Ciphers[Index]);\r\n}\r\n//---------------------------------------------------------------------\r\nTCipher __fastcall TSessionData::GetCipher(int Index) const\r\n{\r\n  DebugAssert(Index >= 0 && Index < CIPHER_COUNT);\r\n  return FCiphers[Index];\r\n}\r\n//---------------------------------------------------------------------\r\ntemplate<class AlgoT>\r\nvoid __fastcall TSessionData::SetAlgoList(AlgoT * List, const AlgoT * DefaultList, const UnicodeString * Names,\r\n  int Count, AlgoT WarnAlgo, UnicodeString value)\r\n{\r\n  std::vector<bool> Used(Count); // initialized to false\r\n  std::vector<AlgoT> NewList(Count);\r\n\r\n  bool HasWarnAlgo = (WarnAlgo >= AlgoT());\r\n  const AlgoT * WarnPtr;\r\n  int WarnDefaultIndex;\r\n  if (!HasWarnAlgo)\r\n  {\r\n    WarnPtr = NULL;\r\n    WarnDefaultIndex = -1;\r\n  }\r\n  else\r\n  {\r\n    WarnPtr = std::find(DefaultList, DefaultList + Count, WarnAlgo);\r\n    DebugAssert(WarnPtr != NULL);\r\n    WarnDefaultIndex = (WarnPtr - DefaultList);\r\n  }\r\n\r\n  int Index = 0;\r\n  while (!value.IsEmpty())\r\n  {\r\n    UnicodeString AlgoStr = CutToChar(value, L',', true);\r\n    for (int Algo = 0; Algo < Count; Algo++)\r\n    {\r\n      if (!AlgoStr.CompareIC(Names[Algo]) &&\r\n          !Used[Algo] && DebugAlwaysTrue(Index < Count))\r\n      {\r\n        NewList[Index] = (AlgoT)Algo;\r\n        Used[Algo] = true;\r\n        Index++;\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  if (HasWarnAlgo && !Used[WarnAlgo] && DebugAlwaysTrue(Index < Count))\r\n  {\r\n    NewList[Index] = WarnAlgo;\r\n    Used[WarnAlgo] = true;\r\n    Index++;\r\n  }\r\n\r\n  int WarnIndex = -1;\r\n  if (HasWarnAlgo)\r\n  {\r\n    WarnIndex = std::find(NewList.begin(), NewList.end(), WarnAlgo) - NewList.begin();\r\n  }\r\n\r\n  bool Priority = true;\r\n  for (int DefaultIndex = 0; (DefaultIndex < Count); DefaultIndex++)\r\n  {\r\n    AlgoT DefaultAlgo = DefaultList[DefaultIndex];\r\n    if (!Used[DefaultAlgo] && DebugAlwaysTrue(Index < Count))\r\n    {\r\n      int TargetIndex;\r\n      // Unused algs that are prioritized in the default list,\r\n      // should be merged before the existing custom list\r\n      if (Priority)\r\n      {\r\n        TargetIndex = DefaultIndex;\r\n      }\r\n      else\r\n      {\r\n        if (HasWarnAlgo && (DefaultIndex < WarnDefaultIndex))\r\n        {\r\n          TargetIndex = WarnIndex;\r\n        }\r\n        else\r\n        {\r\n          TargetIndex = Index;\r\n        }\r\n      }\r\n\r\n      NewList.insert(NewList.begin() + TargetIndex, DefaultAlgo);\r\n      DebugAssert(NewList.back() == AlgoT());\r\n      NewList.pop_back();\r\n\r\n      if (HasWarnAlgo && (TargetIndex <= WarnIndex))\r\n      {\r\n        WarnIndex++;\r\n      }\r\n\r\n      Index++;\r\n    }\r\n    else\r\n    {\r\n      Priority = false;\r\n    }\r\n  }\r\n\r\n  if (!std::equal(NewList.begin(), NewList.end(), List))\r\n  {\r\n    std::copy(NewList.begin(), NewList.end(), List);\r\n    Modify();\r\n  }\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetCipherList(UnicodeString value)\r\n{\r\n  SetAlgoList(FCiphers, DefaultCipherList, CipherNames, CIPHER_COUNT, cipWarn, value);\r\n}\r\n//---------------------------------------------------------------------\r\nUnicodeString __fastcall TSessionData::GetCipherList() const\r\n{\r\n  UnicodeString Result;\r\n  for (int Index = 0; Index < CIPHER_COUNT; Index++)\r\n  {\r\n    Result += UnicodeString(Index ? L\",\" : L\"\") + CipherNames[Cipher[Index]];\r\n  }\r\n  return Result;\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetKex(int Index, TKex value)\r\n{\r\n  DebugAssert(Index >= 0 && Index < KEX_COUNT);\r\n  SET_SESSION_PROPERTY(Kex[Index]);\r\n}\r\n//---------------------------------------------------------------------\r\nTKex __fastcall TSessionData::GetKex(int Index) const\r\n{\r\n  DebugAssert(Index >= 0 && Index < KEX_COUNT);\r\n  return FKex[Index];\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetKexList(UnicodeString value)\r\n{\r\n  SetAlgoList(FKex, DefaultKexList, KexNames, KEX_COUNT, kexWarn, value);\r\n}\r\n//---------------------------------------------------------------------\r\nUnicodeString __fastcall TSessionData::GetKexList() const\r\n{\r\n  UnicodeString Result;\r\n  for (int Index = 0; Index < KEX_COUNT; Index++)\r\n  {\r\n    Result += UnicodeString(Index ? L\",\" : L\"\") + KexNames[Kex[Index]];\r\n  }\r\n  return Result;\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetHostKeys(int Index, THostKey value)\r\n{\r\n  DebugAssert(Index >= 0 && Index < HOSTKEY_COUNT);\r\n  SET_SESSION_PROPERTY(HostKeys[Index]);\r\n}\r\n//---------------------------------------------------------------------\r\nTHostKey __fastcall TSessionData::GetHostKeys(int Index) const\r\n{\r\n  DebugAssert(Index >= 0 && Index < HOSTKEY_COUNT);\r\n  return FHostKeys[Index];\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetHostKeyList(UnicodeString value)\r\n{\r\n  SetAlgoList(FHostKeys, DefaultHostKeyList, HostKeyNames, HOSTKEY_COUNT, hkWarn, value);\r\n}\r\n//---------------------------------------------------------------------\r\nUnicodeString __fastcall TSessionData::GetHostKeyList() const\r\n{\r\n  UnicodeString Result;\r\n  for (int Index = 0; Index < HOSTKEY_COUNT; Index++)\r\n  {\r\n    Result += UnicodeString(Index ? L\",\" : L\"\") + HostKeyNames[HostKeys[Index]];\r\n  }\r\n  return Result;\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetGssLib(int Index, TGssLib value)\r\n{\r\n  DebugAssert(Index >= 0 && Index < GSSLIB_COUNT);\r\n  SET_SESSION_PROPERTY(GssLib[Index]);\r\n}\r\n//---------------------------------------------------------------------\r\nTGssLib __fastcall TSessionData::GetGssLib(int Index) const\r\n{\r\n  DebugAssert(Index >= 0 && Index < GSSLIB_COUNT);\r\n  return FGssLib[Index];\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetGssLibList(UnicodeString value)\r\n{\r\n  SetAlgoList(FGssLib, DefaultGssLibList, GssLibNames, GSSLIB_COUNT, TGssLib(-1), value);\r\n}\r\n//---------------------------------------------------------------------\r\nUnicodeString __fastcall TSessionData::GetGssLibList() const\r\n{\r\n  UnicodeString Result;\r\n  for (int Index = 0; Index < GSSLIB_COUNT; Index++)\r\n  {\r\n    Result += UnicodeString(Index ? L\",\" : L\"\") + GssLibNames[GssLib[Index]];\r\n  }\r\n  return Result;\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetGssLibCustom(UnicodeString value)\r\n{\r\n  SET_SESSION_PROPERTY(GssLibCustom);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetPublicKeyFile(UnicodeString value)\r\n{\r\n  if (FPublicKeyFile != value)\r\n  {\r\n    // PublicKeyFile is key for Passphrase encryption\r\n    UnicodeString XPassphrase = Passphrase;\r\n\r\n    // StripPathQuotes should not be needed as we do not feed quotes anymore\r\n    FPublicKeyFile = StripPathQuotes(value);\r\n    Modify();\r\n\r\n    Passphrase = XPassphrase;\r\n    Shred(XPassphrase);\r\n  }\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetPassphrase(UnicodeString avalue)\r\n{\r\n  RawByteString value = EncryptPassword(avalue, PublicKeyFile);\r\n  SET_SESSION_PROPERTY(Passphrase);\r\n}\r\n//---------------------------------------------------------------------\r\nUnicodeString __fastcall TSessionData::GetPassphrase() const\r\n{\r\n  return DecryptPassword(FPassphrase, PublicKeyFile);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetReturnVar(UnicodeString value)\r\n{\r\n  SET_SESSION_PROPERTY(ReturnVar);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetExitCode1IsError(bool value)\r\n{\r\n  SET_SESSION_PROPERTY(ExitCode1IsError);\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetLookupUserGroups(TAutoSwitch value)\r\n{\r\n  SET_SESSION_PROPERTY(LookupUserGroups);\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetEOLType(TEOLType value)\r\n{\r\n  SET_SESSION_PROPERTY(EOLType);\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetTrimVMSVersions(bool value)\r\n{\r\n  SET_SESSION_PROPERTY(TrimVMSVersions);\r\n}\r\n//---------------------------------------------------------------------------\r\nTDateTime __fastcall TSessionData::GetTimeoutDT()\r\n{\r\n  return SecToDateTime(Timeout);\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetTimeout(int value)\r\n{\r\n  SET_SESSION_PROPERTY(Timeout);\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetFSProtocol(TFSProtocol value)\r\n{\r\n  SET_SESSION_PROPERTY(FSProtocol);\r\n}\r\n//---------------------------------------------------------------------\r\nUnicodeString __fastcall TSessionData::GetFSProtocolStr()\r\n{\r\n  DebugAssert(FSProtocol >= 0 && FSProtocol < FSPROTOCOL_COUNT);\r\n  return FSProtocolNames[FSProtocol];\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetDetectReturnVar(bool value)\r\n{\r\n  if (value != DetectReturnVar)\r\n  {\r\n    ReturnVar = value ? L\"\" : L\"$?\";\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\nbool __fastcall TSessionData::GetDetectReturnVar()\r\n{\r\n  return ReturnVar.IsEmpty();\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetDefaultShell(bool value)\r\n{\r\n  if (value != DefaultShell)\r\n  {\r\n    Shell = value ? L\"\" : L\"/bin/bash\";\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\nbool __fastcall TSessionData::GetDefaultShell()\r\n{\r\n  return Shell.IsEmpty();\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetPuttyProtocol(UnicodeString value)\r\n{\r\n  SET_SESSION_PROPERTY(PuttyProtocol);\r\n}\r\n//---------------------------------------------------------------------\r\nUnicodeString __fastcall TSessionData::GetNormalizedPuttyProtocol() const\r\n{\r\n  return DefaultStr(PuttyProtocol, PuttySshProtocol);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetPingIntervalDT(TDateTime value)\r\n{\r\n  unsigned short hour, min, sec, msec;\r\n\r\n  value.DecodeTime(&hour, &min, &sec, &msec);\r\n  PingInterval = ((int)hour)*SecsPerHour + ((int)min)*SecsPerMin + sec;\r\n}\r\n//---------------------------------------------------------------------------\r\nTDateTime __fastcall TSessionData::GetPingIntervalDT()\r\n{\r\n  return SecToDateTime(PingInterval);\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetPingType(TPingType value)\r\n{\r\n  SET_SESSION_PROPERTY(PingType);\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetAddressFamily(TAddressFamily value)\r\n{\r\n  SET_SESSION_PROPERTY(AddressFamily);\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetRekeyData(UnicodeString value)\r\n{\r\n  SET_SESSION_PROPERTY(RekeyData);\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetRekeyTime(unsigned int value)\r\n{\r\n  SET_SESSION_PROPERTY(RekeyTime);\r\n}\r\n//---------------------------------------------------------------------\r\nUnicodeString __fastcall TSessionData::GetDefaultSessionName()\r\n{\r\n  if (!HostName.IsEmpty() && !UserName.IsEmpty())\r\n  {\r\n    // If we ever choose to include port number,\r\n    // we have to escape IPv6 literals in HostName\r\n    return FORMAT(L\"%s@%s\", (UserName, HostName));\r\n  }\r\n  else if (!HostName.IsEmpty())\r\n  {\r\n    return HostName;\r\n  }\r\n  else\r\n  {\r\n    return L\"session\";\r\n  }\r\n}\r\n//---------------------------------------------------------------------\r\nUnicodeString __fastcall TSessionData::GetNameWithoutHiddenPrefix()\r\n{\r\n  UnicodeString Result = Name;\r\n  if (Hidden)\r\n  {\r\n    Result = Result.SubString(TNamedObjectList::HiddenPrefix.Length() + 1, Result.Length() - TNamedObjectList::HiddenPrefix.Length());\r\n  }\r\n  return Result;\r\n}\r\n//---------------------------------------------------------------------\r\nbool __fastcall TSessionData::HasSessionName()\r\n{\r\n  return (!GetNameWithoutHiddenPrefix().IsEmpty() && (Name != DefaultName));\r\n}\r\n//---------------------------------------------------------------------\r\nUnicodeString __fastcall TSessionData::GetSessionName()\r\n{\r\n  UnicodeString Result;\r\n  if (HasSessionName())\r\n  {\r\n    Result = GetNameWithoutHiddenPrefix();\r\n  }\r\n  else\r\n  {\r\n    Result = DefaultSessionName;\r\n  }\r\n  return Result;\r\n}\r\n//---------------------------------------------------------------------\r\nbool __fastcall TSessionData::IsSecure()\r\n{\r\n  bool Result;\r\n  switch (FSProtocol)\r\n  {\r\n    case fsSCPonly:\r\n    case fsSFTP:\r\n    case fsSFTPonly:\r\n      Result = true;\r\n      break;\r\n\r\n    case fsFTP:\r\n    case fsWebDAV:\r\n    case fsS3:\r\n      Result = (Ftps != ftpsNone);\r\n      break;\r\n\r\n    default:\r\n      DebugFail();\r\n      break;\r\n  }\r\n  return Result;\r\n}\r\n//---------------------------------------------------------------------\r\nUnicodeString __fastcall TSessionData::GetProtocolUrl(bool HttpForWebDAV)\r\n{\r\n  UnicodeString Url;\r\n  switch (FSProtocol)\r\n  {\r\n    case fsSCPonly:\r\n      Url = ScpProtocol;\r\n      break;\r\n\r\n    default:\r\n      DebugFail();\r\n      // fallback\r\n    case fsSFTP:\r\n    case fsSFTPonly:\r\n      Url = SftpProtocol;\r\n      break;\r\n\r\n    case fsFTP:\r\n      if (Ftps == ftpsImplicit)\r\n      {\r\n        Url = FtpsProtocol;\r\n      }\r\n      else if ((Ftps == ftpsExplicitTls) || (Ftps == ftpsExplicitSsl))\r\n      {\r\n        Url = FtpesProtocol;\r\n      }\r\n      else\r\n      {\r\n        Url = FtpProtocol;\r\n      }\r\n      break;\r\n\r\n    case fsWebDAV:\r\n      if (HttpForWebDAV)\r\n      {\r\n        if (Ftps == ftpsImplicit)\r\n        {\r\n          Url = HttpsProtocol;\r\n        }\r\n        else\r\n        {\r\n          Url = HttpProtocol;\r\n        }\r\n      }\r\n      else\r\n      {\r\n        if (Ftps == ftpsImplicit)\r\n        {\r\n          Url = WebDAVSProtocol;\r\n        }\r\n        else\r\n        {\r\n          Url = WebDAVProtocol;\r\n        }\r\n      }\r\n      break;\r\n\r\n    case fsS3:\r\n      Url = S3Protocol;\r\n      break;\r\n  }\r\n\r\n  Url += ProtocolSeparator;\r\n\r\n  return Url;\r\n}\r\n//---------------------------------------------------------------------\r\nbool __fastcall IsIPv6Literal(const UnicodeString & HostName)\r\n{\r\n  bool Result = (HostName.Pos(L\":\") > 0);\r\n  if (Result)\r\n  {\r\n    for (int Index = 1; Result && (Index <= HostName.Length()); Index++)\r\n    {\r\n      wchar_t C = HostName[Index];\r\n      Result = IsHex(C) || (C == L':');\r\n    }\r\n  }\r\n  return Result;\r\n}\r\n//---------------------------------------------------------------------\r\nUnicodeString __fastcall EscapeIPv6Literal(const UnicodeString & IP)\r\n{\r\n  return L\"[\" + IP + L\"]\";\r\n}\r\n//---------------------------------------------------------------------\r\nTStrings * __fastcall TSessionData::GetRawSettingsForUrl()\r\n{\r\n  std::unique_ptr<TSessionData> FactoryDefaults(new TSessionData(L\"\"));\r\n  std::unique_ptr<TSessionData> SessionData(Clone());\r\n  SessionData->FSProtocol = FactoryDefaults->FSProtocol;\r\n  SessionData->HostName = FactoryDefaults->HostName;\r\n  SessionData->PortNumber = FactoryDefaults->PortNumber;\r\n  SessionData->UserName = FactoryDefaults->UserName;\r\n  SessionData->Password = FactoryDefaults->Password;\r\n  SessionData->Ftps = FactoryDefaults->Ftps;\r\n  SessionData->HostKey = FactoryDefaults->HostKey;\r\n  SessionData->CopyNonCoreData(FactoryDefaults.get());\r\n  // Cannot be decided in SaveToOptions as it does not have HostName and UserName, so it cannot calculate DefaultSessionName.\r\n  bool SaveName = HasSessionName() && (Name != DefaultSessionName);\r\n  return SessionData->SaveToOptions(FactoryDefaults.get(), SaveName, false);\r\n}\r\n//---------------------------------------------------------------------\r\nbool __fastcall TSessionData::HasRawSettingsForUrl()\r\n{\r\n  std::unique_ptr<TStrings> RawSettings(GetRawSettingsForUrl());\r\n  return (RawSettings->Count > 0);\r\n}\r\n//---------------------------------------------------------------------\r\nUnicodeString __fastcall TSessionData::GenerateSessionUrl(unsigned int Flags)\r\n{\r\n  UnicodeString Url;\r\n\r\n  if (FLAGSET(Flags, sufSpecific))\r\n  {\r\n    Url += WinSCPProtocolPrefix;\r\n  }\r\n\r\n  Url += GetProtocolUrl(FLAGSET(Flags, sufHttpForWebDAV));\r\n\r\n  if (FLAGSET(Flags, sufUserName) && !UserNameExpanded.IsEmpty())\r\n  {\r\n    Url += EncodeUrlString(UserNameExpanded);\r\n\r\n    if (FLAGSET(Flags, sufPassword) && !Password.IsEmpty())\r\n    {\r\n      Url += L\":\" + EncodeUrlString(NormalizeString(Password));\r\n    }\r\n\r\n    if (FLAGSET(Flags, sufHostKey) && !HostKey.IsEmpty())\r\n    {\r\n      UnicodeString KeyName;\r\n      UnicodeString Fingerprint = HostKey;\r\n      NormalizeFingerprint(Fingerprint, KeyName);\r\n      UnicodeString S = Fingerprint;\r\n      if (!KeyName.IsEmpty())\r\n      {\r\n        S = KeyName + NormalizedFingerprintSeparator + S;\r\n      }\r\n      S = Base64ToUrlSafe(S); // Noop for MD5 (both in SSH host keys and TLS/SSL)\r\n      S = MD5ToUrlSafe(S); // TLS/SSL fingerprints\r\n      UnicodeString S2 = EncodeUrlString(S);\r\n      DebugAssert(S2 == S2); // There should be nothing left for encoding\r\n\r\n      Url +=\r\n        UnicodeString(UrlParamSeparator) + UrlHostKeyParamName +\r\n        UnicodeString(UrlParamValueSeparator) + S2;\r\n    }\r\n\r\n    if (FLAGSET(Flags, sufRawSettings))\r\n    {\r\n      std::unique_ptr<TStrings> RawSettings(GetRawSettingsForUrl());\r\n      for (int Index = 0; Index < RawSettings->Count; Index++)\r\n      {\r\n        Url +=\r\n          UnicodeString(UrlParamSeparator) +\r\n          UrlRawSettingsParamNamePrefix + EncodeUrlString(LowerCase(RawSettings->Names[Index])) +\r\n          UnicodeString(UrlParamValueSeparator) + EncodeUrlString(RawSettings->ValueFromIndex[Index]);\r\n      }\r\n    }\r\n\r\n    Url += L\"@\";\r\n  }\r\n\r\n  DebugAssert(!HostNameExpanded.IsEmpty());\r\n  if (IsIPv6Literal(HostNameExpanded))\r\n  {\r\n    Url += EscapeIPv6Literal(HostNameExpanded);\r\n  }\r\n  else\r\n  {\r\n    Url += EncodeUrlString(HostNameExpanded);\r\n  }\r\n\r\n  if (PortNumber != DefaultPort(FSProtocol, Ftps))\r\n  {\r\n    Url += L\":\" + IntToStr(PortNumber);\r\n  }\r\n  Url += L\"/\";\r\n\r\n  return Url;\r\n}\r\n//---------------------------------------------------------------------\r\nUnicodeString ScriptCommandOpenLink(TraceInitStr(ScriptCommandLink(L\"open\")));\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::AddSwitch(\r\n  UnicodeString & Result, const UnicodeString & Name, bool Rtf)\r\n{\r\n  Result += RtfSwitch(Name, ScriptCommandOpenLink, Rtf);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::AddSwitch(\r\n  UnicodeString & Result, const UnicodeString & Name, const UnicodeString & Value, bool Rtf)\r\n{\r\n  Result += RtfSwitch(Name, ScriptCommandOpenLink, Value, Rtf);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::AddSwitch(\r\n  UnicodeString & Result, const UnicodeString & Name, int Value, bool Rtf)\r\n{\r\n  Result += RtfSwitch(Name, ScriptCommandOpenLink, Value, Rtf);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::LookupLastFingerprint()\r\n{\r\n  UnicodeString FingerprintType;\r\n  if (IsSshProtocol(FSProtocol))\r\n  {\r\n    FingerprintType = SshFingerprintType;\r\n  }\r\n  else if (Ftps != ftpsNone)\r\n  {\r\n    FingerprintType = TlsFingerprintType;\r\n  }\r\n\r\n  if (!FingerprintType.IsEmpty())\r\n  {\r\n    HostKey = Configuration->LastFingerprint(SiteKey, FingerprintType);\r\n  }\r\n}\r\n//---------------------------------------------------------------------\r\nUnicodeString __fastcall TSessionData::GenerateOpenCommandArgs(bool Rtf)\r\n{\r\n  std::unique_ptr<TSessionData> FactoryDefaults(new TSessionData(L\"\"));\r\n  std::unique_ptr<TSessionData> SessionData(new TSessionData(L\"\"));\r\n\r\n  SessionData->Assign(this);\r\n\r\n  UnicodeString Result = SessionData->GenerateSessionUrl(sufOpen);\r\n\r\n  // Before we reset the FSProtocol\r\n  bool AUsesSsh = SessionData->UsesSsh;\r\n  // SFTP-only is not reflected by the protocol prefix, we have to use rawsettings for that\r\n  if (SessionData->FSProtocol != fsSFTPonly)\r\n  {\r\n    SessionData->FSProtocol = FactoryDefaults->FSProtocol;\r\n  }\r\n  SessionData->HostName = FactoryDefaults->HostName;\r\n  SessionData->PortNumber = FactoryDefaults->PortNumber;\r\n  SessionData->UserName = FactoryDefaults->UserName;\r\n  SessionData->Password = FactoryDefaults->Password;\r\n  SessionData->CopyNonCoreData(FactoryDefaults.get());\r\n  SessionData->Ftps = FactoryDefaults->Ftps;\r\n\r\n  if (SessionData->HostKey != FactoryDefaults->HostKey)\r\n  {\r\n    UnicodeString SwitchName = AUsesSsh ? L\"hostkey\" : L\"certificate\";\r\n    AddSwitch(Result, SwitchName, SessionData->HostKey, Rtf);\r\n    SessionData->HostKey = FactoryDefaults->HostKey;\r\n  }\r\n  if (SessionData->PublicKeyFile != FactoryDefaults->PublicKeyFile)\r\n  {\r\n    AddSwitch(Result, L\"privatekey\", SessionData->PublicKeyFile, Rtf);\r\n    SessionData->PublicKeyFile = FactoryDefaults->PublicKeyFile;\r\n  }\r\n  if (SessionData->TlsCertificateFile != FactoryDefaults->TlsCertificateFile)\r\n  {\r\n    AddSwitch(Result, L\"clientcert\", SessionData->TlsCertificateFile, Rtf);\r\n    SessionData->TlsCertificateFile = FactoryDefaults->TlsCertificateFile;\r\n  }\r\n  if (SessionData->Passphrase != FactoryDefaults->Passphrase)\r\n  {\r\n    AddSwitch(Result, PassphraseOption, SessionData->Passphrase, Rtf);\r\n    SessionData->Passphrase = FactoryDefaults->Passphrase;\r\n  }\r\n  if (SessionData->FtpPasvMode != FactoryDefaults->FtpPasvMode)\r\n  {\r\n    AddSwitch(Result, L\"passive\", SessionData->FtpPasvMode ? 1 : 0, Rtf);\r\n    SessionData->FtpPasvMode = FactoryDefaults->FtpPasvMode;\r\n  }\r\n  if (SessionData->Timeout != FactoryDefaults->Timeout)\r\n  {\r\n    AddSwitch(Result, L\"timeout\", SessionData->Timeout, Rtf);\r\n    SessionData->Timeout = FactoryDefaults->Timeout;\r\n  }\r\n\r\n  std::unique_ptr<TStrings> RawSettings(SessionData->SaveToOptions(FactoryDefaults.get(), false, false));\r\n\r\n  if (RawSettings->Count > 0)\r\n  {\r\n    AddSwitch(Result, RawSettingsOption, Rtf);\r\n\r\n    Result += StringsToParams(RawSettings.get());\r\n  }\r\n\r\n  return Result;\r\n}\r\n//---------------------------------------------------------------------\r\nUnicodeString SessionOptionsClassName(L\"SessionOptions\");\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::AddAssemblyProperty(\r\n  UnicodeString & Result, TAssemblyLanguage Language,\r\n  const UnicodeString & Name, const UnicodeString & Type,\r\n  const UnicodeString & Member)\r\n{\r\n  Result += AssemblyProperty(Language, SessionOptionsClassName, Name, Type, Member, false);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::AddAssemblyProperty(\r\n  UnicodeString & Result, TAssemblyLanguage Language,\r\n  const UnicodeString & Name, const UnicodeString & Value)\r\n{\r\n  Result += AssemblyProperty(Language, SessionOptionsClassName, Name, Value, false);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::AddAssemblyProperty(\r\n  UnicodeString & Result, TAssemblyLanguage Language,\r\n  const UnicodeString & Name, int Value)\r\n{\r\n  Result += AssemblyProperty(Language, SessionOptionsClassName, Name, Value, false);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::AddAssemblyProperty(\r\n  UnicodeString & Result, TAssemblyLanguage Language,\r\n  const UnicodeString & Name, bool Value)\r\n{\r\n  Result += AssemblyProperty(Language, SessionOptionsClassName, Name, Value, false);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::GenerateAssemblyCode(\r\n  TAssemblyLanguage Language, UnicodeString & Head, UnicodeString & Tail, int & Indent)\r\n{\r\n  std::unique_ptr<TSessionData> FactoryDefaults(new TSessionData(L\"\"));\r\n  std::unique_ptr<TSessionData> SessionData(Clone());\r\n\r\n  switch (Language)\r\n  {\r\n    case alCSharp:\r\n    case alVBNET:\r\n      // noop\r\n      break;\r\n\r\n    case alPowerShell:\r\n      Head +=\r\n        AssemblyCommentLine(Language, LoadStr(CODE_PS_ADD_TYPE)) +\r\n        RtfKeyword(L\"Add-Type\") + RtfText(\" -Path \") + AssemblyString(Language, \"WinSCPnet.dll\") + RtfPara +\r\n        RtfPara;\r\n      break;\r\n\r\n    default:\r\n      DebugFail();\r\n      break;\r\n  }\r\n\r\n  Head +=\r\n    AssemblyCommentLine(Language, LoadStr(CODE_SESSION_OPTIONS)) +\r\n    AssemblyNewClassInstanceStart(Language, SessionOptionsClassName, false);\r\n\r\n  UnicodeString ProtocolMember;\r\n  switch (SessionData->FSProtocol)\r\n  {\r\n    case fsSCPonly:\r\n      ProtocolMember = \"Scp\";\r\n      break;\r\n\r\n    default:\r\n      DebugFail();\r\n      // fallback\r\n    case fsSFTP:\r\n    case fsSFTPonly:\r\n      ProtocolMember = \"Sftp\";\r\n      break;\r\n\r\n    case fsFTP:\r\n      ProtocolMember = \"Ftp\";\r\n      break;\r\n\r\n    case fsWebDAV:\r\n      ProtocolMember = \"Webdav\";\r\n      break;\r\n\r\n    case fsS3:\r\n      ProtocolMember = \"S3\";\r\n      break;\r\n  }\r\n\r\n  // Before we reset the FSProtocol\r\n  bool AUsesSsh = SessionData->UsesSsh;\r\n\r\n  // Protocol is set unconditionally, we want even the default SFTP\r\n  AddAssemblyProperty(Head, Language, L\"Protocol\", L\"Protocol\", ProtocolMember);\r\n  // SFTP-only is not reflected by the protocol prefix, we have to use rawsettings for that\r\n  if (SessionData->FSProtocol != fsSFTPonly)\r\n  {\r\n    SessionData->FSProtocol = FactoryDefaults->FSProtocol;\r\n  }\r\n  if (SessionData->HostName != FactoryDefaults->HostName)\r\n  {\r\n    AddAssemblyProperty(Head, Language, L\"HostName\", HostName);\r\n    SessionData->HostName = FactoryDefaults->HostName;\r\n  }\r\n  int ADefaultPort = DefaultPort(FSProtocol, Ftps);\r\n  if (SessionData->PortNumber != ADefaultPort)\r\n  {\r\n    AddAssemblyProperty(Head, Language, L\"PortNumber\", PortNumber);\r\n  }\r\n  SessionData->PortNumber = FactoryDefaults->PortNumber;\r\n  if (SessionData->UserName != FactoryDefaults->UserName)\r\n  {\r\n    AddAssemblyProperty(Head, Language, L\"UserName\", UserName);\r\n    SessionData->UserName = FactoryDefaults->UserName;\r\n  }\r\n  if (SessionData->Password != FactoryDefaults->Password)\r\n  {\r\n    AddAssemblyProperty(Head, Language, L\"Password\", NormalizeString(Password));\r\n    SessionData->Password = FactoryDefaults->Password;\r\n  }\r\n\r\n  SessionData->CopyNonCoreData(FactoryDefaults.get());\r\n\r\n  if (SessionData->Ftps != FactoryDefaults->Ftps)\r\n  {\r\n    // SessionData->FSProtocol is reset already\r\n    switch (FSProtocol)\r\n    {\r\n      case fsFTP:\r\n        {\r\n          UnicodeString FtpSecureMember;\r\n          switch (SessionData->Ftps)\r\n          {\r\n            case ftpsNone:\r\n              // noop\r\n              break;\r\n\r\n            case ftpsImplicit:\r\n              FtpSecureMember = L\"Implicit\";\r\n              break;\r\n\r\n            case ftpsExplicitTls:\r\n            case ftpsExplicitSsl:\r\n              FtpSecureMember = L\"Explicit\";\r\n              break;\r\n\r\n            default:\r\n              DebugFail();\r\n              break;\r\n          }\r\n          AddAssemblyProperty(Head, Language, L\"FtpSecure\", L\"FtpSecure\", FtpSecureMember);\r\n        }\r\n        break;\r\n\r\n      case fsWebDAV:\r\n        AddAssemblyProperty(Head, Language, L\"WebdavSecure\", (SessionData->Ftps != ftpsNone));\r\n        break;\r\n\r\n      case fsS3:\r\n        // implicit\r\n        break;\r\n\r\n      default:\r\n        DebugFail();\r\n        break;\r\n    }\r\n    SessionData->Ftps = FactoryDefaults->Ftps;\r\n  }\r\n\r\n  if (SessionData->HostKey != FactoryDefaults->HostKey)\r\n  {\r\n    UnicodeString PropertyName = AUsesSsh ? L\"SshHostKeyFingerprint\" : L\"TlsHostCertificateFingerprint\";\r\n    AddAssemblyProperty(Head, Language, PropertyName, SessionData->HostKey);\r\n    SessionData->HostKey = FactoryDefaults->HostKey;\r\n  }\r\n  if (SessionData->PublicKeyFile != FactoryDefaults->PublicKeyFile)\r\n  {\r\n    AddAssemblyProperty(Head, Language, L\"SshPrivateKeyPath\", SessionData->PublicKeyFile);\r\n    SessionData->PublicKeyFile = FactoryDefaults->PublicKeyFile;\r\n  }\r\n  if (SessionData->TlsCertificateFile != FactoryDefaults->TlsCertificateFile)\r\n  {\r\n    AddAssemblyProperty(Head, Language, L\"TlsClientCertificatePath\", SessionData->TlsCertificateFile);\r\n    SessionData->TlsCertificateFile = FactoryDefaults->TlsCertificateFile;\r\n  }\r\n  if (SessionData->Passphrase != FactoryDefaults->Passphrase)\r\n  {\r\n    AddAssemblyProperty(Head, Language, L\"PrivateKeyPassphrase\", SessionData->Passphrase);\r\n    SessionData->Passphrase = FactoryDefaults->Passphrase;\r\n  }\r\n  if (SessionData->FtpPasvMode != FactoryDefaults->FtpPasvMode)\r\n  {\r\n    AddAssemblyProperty(Head, Language, L\"FtpMode\", L\"FtpMode\", (SessionData->FtpPasvMode ? L\"Passive\" : L\"Active\"));\r\n    SessionData->FtpPasvMode = FactoryDefaults->FtpPasvMode;\r\n  }\r\n  if (SessionData->Timeout != FactoryDefaults->Timeout)\r\n  {\r\n    AddAssemblyProperty(Head, Language, L\"TimeoutInMilliseconds\", SessionData->Timeout * 1000);\r\n    SessionData->Timeout = FactoryDefaults->Timeout;\r\n  }\r\n\r\n  Head += AssemblyNewClassInstanceEnd(Language, false);\r\n\r\n  std::unique_ptr<TStrings> RawSettings(SessionData->SaveToOptions(FactoryDefaults.get(), false, false));\r\n\r\n  UnicodeString SessionOptionsVariableName = AssemblyVariableName(Language, SessionOptionsClassName);\r\n\r\n  if (RawSettings->Count > 0)\r\n  {\r\n    Head +=\r\n      RtfPara +\r\n      AssemblyAddRawSettings(Language, RawSettings.get(), SessionOptionsClassName, L\"AddRawSettings\");\r\n  }\r\n\r\n  Head += RtfPara;\r\n\r\n  UnicodeString Indentation = L\"    \";\r\n  UnicodeString SessionVariableName = AssemblyVariableName(Language, SessionClassName);\r\n  UnicodeString RtfSessionClass = RtfLibraryClass(SessionClassName);\r\n  UnicodeString RtfSessionOpenMethod = RtfLibraryMethod(SessionClassName, L\"Open\", false);\r\n\r\n  UnicodeString NewSessionInstance = AssemblyNewClassInstance(Language, SessionClassName, false);\r\n  UnicodeString OpenCall =\r\n    Indentation + AssemblyCommentLine(Language, LoadStr(CODE_CONNECT)) +\r\n    Indentation + RtfText(SessionVariableName + L\".\") + RtfSessionOpenMethod + RtfText(L\"(\" + SessionOptionsVariableName + L\")\") +\r\n      AssemblyStatementSeparator(Language) + RtfPara;\r\n\r\n  switch (Language)\r\n  {\r\n    case alCSharp:\r\n      Head +=\r\n        RtfKeyword(L\"using\") + RtfText(\" (\") + NewSessionInstance + RtfText(L\"())\") + RtfPara +\r\n        RtfText(L\"{\") + RtfPara +\r\n        OpenCall;\r\n\r\n      Tail =\r\n        RtfText(L\"}\") + RtfPara;\r\n      break;\r\n\r\n    case alVBNET:\r\n      Head +=\r\n        RtfKeyword(L\"Using\") + RtfText(L\" \") + NewSessionInstance + RtfPara +\r\n        OpenCall;\r\n\r\n      Tail =\r\n        RtfKeyword(L\"End Using\") + RtfPara;\r\n      break;\r\n\r\n    case alPowerShell:\r\n      Head +=\r\n        NewSessionInstance + RtfPara +\r\n        RtfPara +\r\n        RtfKeyword(L\"try\") + RtfPara +\r\n        RtfText(L\"{\") + RtfPara +\r\n        OpenCall;\r\n\r\n      Tail =\r\n        RtfText(L\"}\") + RtfPara +\r\n        RtfKeyword(L\"finally\") + RtfPara +\r\n        RtfText(L\"{\") + RtfPara +\r\n        RtfText(Indentation + SessionVariableName + L\".\") +\r\n          RtfLibraryMethod(SessionClassName, L\"Dispose\", false) + RtfText(L\"()\") + RtfPara +\r\n        RtfText(L\"}\") + RtfPara;\r\n      break;\r\n  }\r\n\r\n  Head += RtfPara;\r\n\r\n  Indent = 4; // the same for all languages so far\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetTimeDifference(TDateTime value)\r\n{\r\n  SET_SESSION_PROPERTY(TimeDifference);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetTimeDifferenceAuto(bool value)\r\n{\r\n  SET_SESSION_PROPERTY(TimeDifferenceAuto);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetLocalDirectory(UnicodeString value)\r\n{\r\n  SET_SESSION_PROPERTY(LocalDirectory);\r\n}\r\n//---------------------------------------------------------------------\r\nUnicodeString __fastcall TSessionData::GetLocalDirectoryExpanded()\r\n{\r\n  return ExpandFileName(::ExpandEnvironmentVariables(LocalDirectory));\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetRemoteDirectory(UnicodeString value)\r\n{\r\n  SET_SESSION_PROPERTY(RemoteDirectory);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetSynchronizeBrowsing(bool value)\r\n{\r\n  SET_SESSION_PROPERTY(SynchronizeBrowsing);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetUpdateDirectories(bool value)\r\n{\r\n  SET_SESSION_PROPERTY(UpdateDirectories);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetCacheDirectories(bool value)\r\n{\r\n  SET_SESSION_PROPERTY(CacheDirectories);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetCacheDirectoryChanges(bool value)\r\n{\r\n  SET_SESSION_PROPERTY(CacheDirectoryChanges);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetPreserveDirectoryChanges(bool value)\r\n{\r\n  SET_SESSION_PROPERTY(PreserveDirectoryChanges);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetResolveSymlinks(bool value)\r\n{\r\n  SET_SESSION_PROPERTY(ResolveSymlinks);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetFollowDirectorySymlinks(bool value)\r\n{\r\n  SET_SESSION_PROPERTY(FollowDirectorySymlinks);\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetDSTMode(TDSTMode value)\r\n{\r\n  SET_SESSION_PROPERTY(DSTMode);\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetDeleteToRecycleBin(bool value)\r\n{\r\n  SET_SESSION_PROPERTY(DeleteToRecycleBin);\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetOverwrittenToRecycleBin(bool value)\r\n{\r\n  SET_SESSION_PROPERTY(OverwrittenToRecycleBin);\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetRecycleBinPath(UnicodeString value)\r\n{\r\n  SET_SESSION_PROPERTY(RecycleBinPath);\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetPostLoginCommands(UnicodeString value)\r\n{\r\n  SET_SESSION_PROPERTY(PostLoginCommands);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetLockInHome(bool value)\r\n{\r\n  SET_SESSION_PROPERTY(LockInHome);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetSpecial(bool value)\r\n{\r\n  SET_SESSION_PROPERTY(Special);\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetScp1Compatibility(bool value)\r\n{\r\n  SET_SESSION_PROPERTY(Scp1Compatibility);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetTcpNoDelay(bool value)\r\n{\r\n  SET_SESSION_PROPERTY(TcpNoDelay);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetSendBuf(int value)\r\n{\r\n  SET_SESSION_PROPERTY(SendBuf);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetSourceAddress(const UnicodeString & value)\r\n{\r\n  SET_SESSION_PROPERTY(SourceAddress);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetSshSimple(bool value)\r\n{\r\n  SET_SESSION_PROPERTY(SshSimple);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetProxyMethod(TProxyMethod value)\r\n{\r\n  SET_SESSION_PROPERTY(ProxyMethod);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetProxyHost(UnicodeString value)\r\n{\r\n  SET_SESSION_PROPERTY(ProxyHost);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetProxyPort(int value)\r\n{\r\n  SET_SESSION_PROPERTY(ProxyPort);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetProxyUsername(UnicodeString value)\r\n{\r\n  SET_SESSION_PROPERTY(ProxyUsername);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetProxyPassword(UnicodeString avalue)\r\n{\r\n  RawByteString value = EncryptPassword(avalue, ProxyUsername+ProxyHost);\r\n  SET_SESSION_PROPERTY(ProxyPassword);\r\n}\r\n//---------------------------------------------------------------------\r\nUnicodeString __fastcall TSessionData::GetProxyPassword() const\r\n{\r\n  return DecryptPassword(FProxyPassword, ProxyUsername+ProxyHost);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetProxyTelnetCommand(UnicodeString value)\r\n{\r\n  SET_SESSION_PROPERTY(ProxyTelnetCommand);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetProxyLocalCommand(UnicodeString value)\r\n{\r\n  SET_SESSION_PROPERTY(ProxyLocalCommand);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetProxyDNS(TAutoSwitch value)\r\n{\r\n  SET_SESSION_PROPERTY(ProxyDNS);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetProxyLocalhost(bool value)\r\n{\r\n  SET_SESSION_PROPERTY(ProxyLocalhost);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetFtpProxyLogonType(int value)\r\n{\r\n  SET_SESSION_PROPERTY(FtpProxyLogonType);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetBug(TSshBug Bug, TAutoSwitch value)\r\n{\r\n  DebugAssert(Bug >= 0 && static_cast<unsigned int>(Bug) < LENOF(FBugs));\r\n  SET_SESSION_PROPERTY(Bugs[Bug]);\r\n}\r\n//---------------------------------------------------------------------\r\nTAutoSwitch __fastcall TSessionData::GetBug(TSshBug Bug) const\r\n{\r\n  DebugAssert(Bug >= 0 && static_cast<unsigned int>(Bug) < LENOF(FBugs));\r\n  return FBugs[Bug];\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetPuttySettings(UnicodeString value)\r\n{\r\n  SET_SESSION_PROPERTY(PuttySettings);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetCustomParam1(UnicodeString value)\r\n{\r\n  SET_SESSION_PROPERTY(CustomParam1);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetCustomParam2(UnicodeString value)\r\n{\r\n  SET_SESSION_PROPERTY(CustomParam2);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetSFTPDownloadQueue(int value)\r\n{\r\n  SET_SESSION_PROPERTY(SFTPDownloadQueue);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetSFTPUploadQueue(int value)\r\n{\r\n  SET_SESSION_PROPERTY(SFTPUploadQueue);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetSFTPListingQueue(int value)\r\n{\r\n  SET_SESSION_PROPERTY(SFTPListingQueue);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetSFTPMaxVersion(int value)\r\n{\r\n  SET_SESSION_PROPERTY(SFTPMaxVersion);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetSFTPMaxPacketSize(unsigned long value)\r\n{\r\n  SET_SESSION_PROPERTY(SFTPMaxPacketSize);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetSFTPBug(TSftpBug Bug, TAutoSwitch value)\r\n{\r\n  DebugAssert(Bug >= 0 && static_cast<unsigned int>(Bug) < LENOF(FSFTPBugs));\r\n  SET_SESSION_PROPERTY(SFTPBugs[Bug]);\r\n}\r\n//---------------------------------------------------------------------\r\nTAutoSwitch __fastcall TSessionData::GetSFTPBug(TSftpBug Bug) const\r\n{\r\n  DebugAssert(Bug >= 0 && static_cast<unsigned int>(Bug) < LENOF(FSFTPBugs));\r\n  return FSFTPBugs[Bug];\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetSCPLsFullTime(TAutoSwitch value)\r\n{\r\n  SET_SESSION_PROPERTY(SCPLsFullTime);\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetColor(int value)\r\n{\r\n  SET_SESSION_PROPERTY(Color);\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetTunnel(bool value)\r\n{\r\n  SET_SESSION_PROPERTY(Tunnel);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetTunnelHostName(UnicodeString value)\r\n{\r\n  if (FTunnelHostName != value)\r\n  {\r\n    // HostName is key for password encryption\r\n    UnicodeString XTunnelPassword = TunnelPassword;\r\n\r\n    int P = value.LastDelimiter(L\"@\");\r\n    if (P > 0)\r\n    {\r\n      TunnelUserName = value.SubString(1, P - 1);\r\n      value = value.SubString(P + 1, value.Length() - P);\r\n    }\r\n    FTunnelHostName = value;\r\n    Modify();\r\n\r\n    TunnelPassword = XTunnelPassword;\r\n    Shred(XTunnelPassword);\r\n  }\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetTunnelPortNumber(int value)\r\n{\r\n  SET_SESSION_PROPERTY(TunnelPortNumber);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetTunnelUserName(UnicodeString value)\r\n{\r\n  // Avoid password recryption (what may popup master password prompt)\r\n  if (FTunnelUserName != value)\r\n  {\r\n    // TunnelUserName is key for password encryption\r\n    UnicodeString XTunnelPassword = TunnelPassword;\r\n    SET_SESSION_PROPERTY(TunnelUserName);\r\n    TunnelPassword = XTunnelPassword;\r\n    Shred(XTunnelPassword);\r\n  }\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetTunnelPassword(UnicodeString avalue)\r\n{\r\n  RawByteString value = EncryptPassword(avalue, TunnelUserName+TunnelHostName);\r\n  SET_SESSION_PROPERTY(TunnelPassword);\r\n}\r\n//---------------------------------------------------------------------\r\nUnicodeString __fastcall TSessionData::GetTunnelPassword() const\r\n{\r\n  return DecryptPassword(FTunnelPassword, TunnelUserName+TunnelHostName);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetTunnelPublicKeyFile(UnicodeString value)\r\n{\r\n  if (FTunnelPublicKeyFile != value)\r\n  {\r\n    // StripPathQuotes should not be needed as we do not feed quotes anymore\r\n    FTunnelPublicKeyFile = StripPathQuotes(value);\r\n    Modify();\r\n  }\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetTunnelLocalPortNumber(int value)\r\n{\r\n  SET_SESSION_PROPERTY(TunnelLocalPortNumber);\r\n}\r\n//---------------------------------------------------------------------\r\nbool __fastcall TSessionData::GetTunnelAutoassignLocalPortNumber()\r\n{\r\n  return (FTunnelLocalPortNumber <= 0);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetTunnelPortFwd(UnicodeString value)\r\n{\r\n  SET_SESSION_PROPERTY(TunnelPortFwd);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetTunnelHostKey(UnicodeString value)\r\n{\r\n  SET_SESSION_PROPERTY(TunnelHostKey);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetFtpPasvMode(bool value)\r\n{\r\n  SET_SESSION_PROPERTY(FtpPasvMode);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetFtpForcePasvIp(TAutoSwitch value)\r\n{\r\n  SET_SESSION_PROPERTY(FtpForcePasvIp);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetFtpUseMlsd(TAutoSwitch value)\r\n{\r\n  SET_SESSION_PROPERTY(FtpUseMlsd);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetFtpAccount(UnicodeString value)\r\n{\r\n  SET_SESSION_PROPERTY(FtpAccount);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetFtpPingInterval(int value)\r\n{\r\n  SET_SESSION_PROPERTY(FtpPingInterval);\r\n}\r\n//---------------------------------------------------------------------------\r\nTDateTime __fastcall TSessionData::GetFtpPingIntervalDT()\r\n{\r\n  return SecToDateTime(FtpPingInterval);\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetFtpPingType(TPingType value)\r\n{\r\n  SET_SESSION_PROPERTY(FtpPingType);\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetFtpTransferActiveImmediately(TAutoSwitch value)\r\n{\r\n  SET_SESSION_PROPERTY(FtpTransferActiveImmediately);\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetFtps(TFtps value)\r\n{\r\n  SET_SESSION_PROPERTY(Ftps);\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetMinTlsVersion(TTlsVersion value)\r\n{\r\n  SET_SESSION_PROPERTY(MinTlsVersion);\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetMaxTlsVersion(TTlsVersion value)\r\n{\r\n  SET_SESSION_PROPERTY(MaxTlsVersion);\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetLogicalHostName(UnicodeString value)\r\n{\r\n  SET_SESSION_PROPERTY(LogicalHostName);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetFtpListAll(TAutoSwitch value)\r\n{\r\n  SET_SESSION_PROPERTY(FtpListAll);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetFtpHost(TAutoSwitch value)\r\n{\r\n  SET_SESSION_PROPERTY(FtpHost);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetFtpDeleteFromCwd(TAutoSwitch value)\r\n{\r\n  SET_SESSION_PROPERTY(FtpDeleteFromCwd);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetSslSessionReuse(bool value)\r\n{\r\n  SET_SESSION_PROPERTY(SslSessionReuse);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetTlsCertificateFile(UnicodeString value)\r\n{\r\n  SET_SESSION_PROPERTY(TlsCertificateFile);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetNotUtf(TAutoSwitch value)\r\n{\r\n  SET_SESSION_PROPERTY(NotUtf);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetInternalEditorEncoding(int value)\r\n{\r\n  SET_SESSION_PROPERTY(InternalEditorEncoding);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetS3DefaultRegion(UnicodeString value)\r\n{\r\n  SET_SESSION_PROPERTY(S3DefaultRegion);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetS3UrlStyle(TS3UrlStyle value)\r\n{\r\n  SET_SESSION_PROPERTY(S3UrlStyle);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetIsWorkspace(bool value)\r\n{\r\n  SET_SESSION_PROPERTY(IsWorkspace);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetLink(UnicodeString value)\r\n{\r\n  SET_SESSION_PROPERTY(Link);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetNameOverride(UnicodeString value)\r\n{\r\n  SET_SESSION_PROPERTY(NameOverride);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetHostKey(UnicodeString value)\r\n{\r\n  SET_SESSION_PROPERTY(HostKey);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetNote(UnicodeString value)\r\n{\r\n  SET_SESSION_PROPERTY(Note);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetWinTitle(UnicodeString value)\r\n{\r\n  SET_SESSION_PROPERTY(WinTitle);\r\n}\r\n//---------------------------------------------------------------------\r\nUnicodeString __fastcall TSessionData::GetEncryptKey() const\r\n{\r\n  return DecryptPassword(FEncryptKey, UserName+HostName);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetEncryptKey(UnicodeString avalue)\r\n{\r\n  RawByteString value = EncryptPassword(avalue, UserName+HostName);\r\n  SET_SESSION_PROPERTY(EncryptKey);\r\n}\r\n//---------------------------------------------------------------------\r\nUnicodeString __fastcall TSessionData::GetInfoTip()\r\n{\r\n  if (UsesSsh)\r\n  {\r\n    return FMTLOAD(SESSION_INFO_TIP2,\r\n        (HostName, UserName,\r\n         (PublicKeyFile.IsEmpty() ? LoadStr(NO_STR) : LoadStr(YES_STR)),\r\n         FSProtocolStr));\r\n  }\r\n  else\r\n  {\r\n    return FMTLOAD(SESSION_INFO_TIP_NO_SSH,\r\n      (HostName, UserName, FSProtocolStr));\r\n  }\r\n}\r\n//---------------------------------------------------------------------\r\nUnicodeString __fastcall TSessionData::ExtractLocalName(const UnicodeString & Name)\r\n{\r\n  UnicodeString Result = Name;\r\n  int P = Result.LastDelimiter(L\"/\");\r\n  if (P > 0)\r\n  {\r\n    Result.Delete(1, P);\r\n  }\r\n  return Result;\r\n}\r\n//---------------------------------------------------------------------\r\nUnicodeString __fastcall TSessionData::GetLocalName()\r\n{\r\n  UnicodeString Result;\r\n  if (HasSessionName())\r\n  {\r\n    Result = ExtractLocalName(Name);\r\n  }\r\n  else\r\n  {\r\n    Result = DefaultSessionName;\r\n  }\r\n  return Result;\r\n}\r\n//---------------------------------------------------------------------\r\nUnicodeString __fastcall TSessionData::ExtractFolderName(const UnicodeString & Name)\r\n{\r\n  UnicodeString Result;\r\n  int P = Name.LastDelimiter(L\"/\");\r\n  if (P > 0)\r\n  {\r\n    Result = Name.SubString(1, P - 1);\r\n  }\r\n  return Result;\r\n}\r\n//---------------------------------------------------------------------\r\nUnicodeString __fastcall TSessionData::GetFolderName()\r\n{\r\n  UnicodeString Result;\r\n  if (HasSessionName() || IsWorkspace)\r\n  {\r\n    Result = ExtractFolderName(Name);\r\n  }\r\n  return Result;\r\n}\r\n//---------------------------------------------------------------------\r\nUnicodeString __fastcall TSessionData::ComposePath(\r\n  const UnicodeString & Path, const UnicodeString & Name)\r\n{\r\n  return UnixIncludeTrailingBackslash(Path) + Name;\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::DisableAuthentationsExceptPassword()\r\n{\r\n  SshNoUserAuth = false;\r\n  AuthTIS = false;\r\n  AuthKI = false;\r\n  AuthKIPassword = false;\r\n  AuthGSSAPI = false;\r\n  PublicKeyFile = L\"\";\r\n  TlsCertificateFile = L\"\";\r\n  Passphrase = L\"\";\r\n  TryAgent = false;\r\n}\r\n//---------------------------------------------------------------------\r\nTStrings * TSessionData::GetAllOptionNames(bool PuttyExport)\r\n{\r\n  std::unique_ptr<TSessionData> FactoryDefaults(new TSessionData(L\"\"));\r\n  return FactoryDefaults->SaveToOptions(NULL, false, PuttyExport);\r\n}\r\n//=== TStoredSessionList ----------------------------------------------\r\n__fastcall TStoredSessionList::TStoredSessionList(bool aReadOnly):\r\n  TNamedObjectList(), FReadOnly(aReadOnly)\r\n{\r\n  DebugAssert(Configuration);\r\n  FDefaultSettings = new TSessionData(DefaultName);\r\n  FPendingRemovals.reset(new TStringList());\r\n}\r\n//---------------------------------------------------------------------\r\n__fastcall TStoredSessionList::~TStoredSessionList()\r\n{\r\n  DebugAssert(Configuration);\r\n  delete FDefaultSettings;\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TStoredSessionList::Load(THierarchicalStorage * Storage,\r\n  bool AsModified, bool UseDefaults, bool PuttyImport)\r\n{\r\n  TStringList *SubKeys = new TStringList();\r\n  TList * Loaded = new TList;\r\n  try\r\n  {\r\n    DebugAssert(AutoSort);\r\n    AutoSort = false;\r\n    bool WasEmpty = (Count == 0);\r\n\r\n    Storage->GetSubKeyNames(SubKeys);\r\n\r\n    for (int Index = 0; Index < SubKeys->Count; Index++)\r\n    {\r\n      UnicodeString SessionName = SubKeys->Strings[Index];\r\n\r\n      bool ValidName = true;\r\n      try\r\n      {\r\n        TSessionData::ValidatePath(SessionName);\r\n      }\r\n      catch(...)\r\n      {\r\n        ValidName = false;\r\n      }\r\n\r\n      if (ValidName)\r\n      {\r\n        TSessionData * SessionData;\r\n        if (SessionName == FDefaultSettings->Name)\r\n        {\r\n          SessionData = FDefaultSettings;\r\n        }\r\n        else\r\n        {\r\n          // if the list was empty before loading, do not waste time trying to\r\n          // find existing sites to overwrite (we rely on underlying storage\r\n          // to secure uniqueness of the key names)\r\n          if (WasEmpty)\r\n          {\r\n            SessionData = NULL;\r\n          }\r\n          else\r\n          {\r\n            SessionData = (TSessionData*)FindByName(SessionName);\r\n          }\r\n        }\r\n\r\n        if ((SessionData != FDefaultSettings) || !UseDefaults)\r\n        {\r\n          if (SessionData == NULL)\r\n          {\r\n            SessionData = new TSessionData(L\"\");\r\n            if (UseDefaults)\r\n            {\r\n              SessionData->CopyData(DefaultSettings);\r\n            }\r\n            SessionData->Name = SessionName;\r\n            Add(SessionData);\r\n          }\r\n          Loaded->Add(SessionData);\r\n          SessionData->Load(Storage, PuttyImport);\r\n          if (AsModified)\r\n          {\r\n            SessionData->Modified = true;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    if (!AsModified)\r\n    {\r\n      for (int Index = 0; Index < TObjectList::Count; Index++)\r\n      {\r\n        if (Loaded->IndexOf(Items[Index]) < 0)\r\n        {\r\n          Delete(Index);\r\n          Index--;\r\n        }\r\n      }\r\n    }\r\n  }\r\n  __finally\r\n  {\r\n    AutoSort = true;\r\n    AlphaSort();\r\n    delete SubKeys;\r\n    delete Loaded;\r\n  }\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TStoredSessionList::Reload()\r\n{\r\n  if (Count <= Configuration->DontReloadMoreThanSessions)\r\n  {\r\n    bool SessionList = true;\r\n    std::unique_ptr<THierarchicalStorage> Storage(Configuration->CreateScpStorage(SessionList));\r\n    if (Storage->OpenSubKey(Configuration->StoredSessionsSubKey, False))\r\n    {\r\n      Load(Storage.get());\r\n    }\r\n  }\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TStoredSessionList::DoSave(THierarchicalStorage * Storage,\r\n  TSessionData * Data, bool All, bool RecryptPasswordOnly,\r\n  TSessionData * FactoryDefaults)\r\n{\r\n  if (All || Data->Modified)\r\n  {\r\n    if (RecryptPasswordOnly)\r\n    {\r\n      Data->SaveRecryptedPasswords(Storage);\r\n    }\r\n    else\r\n    {\r\n      Data->Save(Storage, false, FactoryDefaults);\r\n    }\r\n  }\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TStoredSessionList::DoSave(THierarchicalStorage * Storage,\r\n  bool All, bool RecryptPasswordOnly, TStrings * RecryptPasswordErrors)\r\n{\r\n  TSessionData * FactoryDefaults = new TSessionData(L\"\");\r\n  try\r\n  {\r\n    while (FPendingRemovals->Count > 0)\r\n    {\r\n      TSessionData::Remove(Storage, FPendingRemovals->Strings[0]);\r\n      FPendingRemovals->Delete(0);\r\n    }\r\n\r\n    DoSave(Storage, FDefaultSettings, All, RecryptPasswordOnly, FactoryDefaults);\r\n    for (int Index = 0; Index < CountIncludingHidden; Index++)\r\n    {\r\n      TSessionData * SessionData = (TSessionData *)Items[Index];\r\n      try\r\n      {\r\n        DoSave(Storage, SessionData, All, RecryptPasswordOnly, FactoryDefaults);\r\n      }\r\n      catch (Exception & E)\r\n      {\r\n        UnicodeString Message;\r\n        if (RecryptPasswordOnly && DebugAlwaysTrue(RecryptPasswordErrors != NULL) &&\r\n            ExceptionMessage(&E, Message))\r\n        {\r\n          RecryptPasswordErrors->Add(FORMAT(\"%s: %s\", (SessionData->SessionName, Message)));\r\n        }\r\n        else\r\n        {\r\n          throw;\r\n        }\r\n      }\r\n    }\r\n  }\r\n  __finally\r\n  {\r\n    delete FactoryDefaults;\r\n  }\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TStoredSessionList::Save(THierarchicalStorage * Storage, bool All)\r\n{\r\n  DoSave(Storage, All, false, NULL);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TStoredSessionList::DoSave(bool All, bool Explicit,\r\n  bool RecryptPasswordOnly, TStrings * RecryptPasswordErrors)\r\n{\r\n  bool SessionList = true;\r\n  THierarchicalStorage * Storage = Configuration->CreateScpStorage(SessionList);\r\n  try\r\n  {\r\n    Storage->AccessMode = smReadWrite;\r\n    Storage->Explicit = Explicit;\r\n    if (Storage->OpenSubKey(Configuration->StoredSessionsSubKey, true))\r\n    {\r\n      DoSave(Storage, All, RecryptPasswordOnly, RecryptPasswordErrors);\r\n    }\r\n  }\r\n  __finally\r\n  {\r\n    delete Storage;\r\n  }\r\n\r\n  Saved();\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TStoredSessionList::Save(bool All, bool Explicit)\r\n{\r\n  DoSave(All, Explicit, false, NULL);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TStoredSessionList::RecryptPasswords(TStrings * RecryptPasswordErrors)\r\n{\r\n  DoSave(true, true, true, RecryptPasswordErrors);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TStoredSessionList::Saved()\r\n{\r\n  FDefaultSettings->Modified = false;\r\n  for (int Index = 0; Index < CountIncludingHidden; Index++)\r\n  {\r\n    ((TSessionData *)Items[Index])->Modified = false;\r\n  }\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TStoredSessionList::ImportLevelFromFilezilla(\r\n  _di_IXMLNode Node, const UnicodeString & Path, _di_IXMLNode SettingsNode)\r\n{\r\n  for (int Index = 0; Index < Node->ChildNodes->Count; Index++)\r\n  {\r\n    _di_IXMLNode ChildNode = Node->ChildNodes->Get(Index);\r\n    if (ChildNode->NodeName == L\"Server\")\r\n    {\r\n      std::unique_ptr<TSessionData> SessionData(new TSessionData(L\"\"));\r\n      SessionData->CopyData(DefaultSettings);\r\n      SessionData->ImportFromFilezilla(ChildNode, Path, SettingsNode);\r\n      Add(SessionData.release());\r\n    }\r\n    else if (ChildNode->NodeName == L\"Folder\")\r\n    {\r\n      UnicodeString Name;\r\n\r\n      for (int Index = 0; Index < ChildNode->ChildNodes->Count; Index++)\r\n      {\r\n        _di_IXMLNode PossibleTextMode = ChildNode->ChildNodes->Get(Index);\r\n        if (PossibleTextMode->NodeType == ntText)\r\n        {\r\n          UnicodeString NodeValue = PossibleTextMode->NodeValue;\r\n          AddToList(Name, NodeValue.Trim(), L\" \");\r\n        }\r\n      }\r\n\r\n      Name = TSessionData::MakeValidName(Name).Trim();\r\n\r\n      ImportLevelFromFilezilla(ChildNode, TSessionData::ComposePath(Path, Name), SettingsNode);\r\n    }\r\n  }\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TStoredSessionList::ImportFromFilezilla(\r\n  const UnicodeString FileName, const UnicodeString ConfigurationFileName)\r\n{\r\n\r\n  // not sure if the document must exists if we want to use its node\r\n  _di_IXMLDocument ConfigurationDocument;\r\n  _di_IXMLNode SettingsNode;\r\n\r\n  if (FileExists(ApiPath(ConfigurationFileName)))\r\n  {\r\n    ConfigurationDocument = interface_cast<Xmlintf::IXMLDocument>(new TXMLDocument(NULL));\r\n    ConfigurationDocument->LoadFromFile(ConfigurationFileName);\r\n    _di_IXMLNode FileZilla3Node = ConfigurationDocument->ChildNodes->FindNode(L\"FileZilla3\");\r\n    if (FileZilla3Node != NULL)\r\n    {\r\n      SettingsNode = FileZilla3Node->ChildNodes->FindNode(L\"Settings\");\r\n    }\r\n  }\r\n\r\n  const _di_IXMLDocument Document = interface_cast<Xmlintf::IXMLDocument>(new TXMLDocument(NULL));\r\n  Document->LoadFromFile(FileName);\r\n  _di_IXMLNode FileZilla3Node = Document->ChildNodes->FindNode(L\"FileZilla3\");\r\n  if (FileZilla3Node != NULL)\r\n  {\r\n    _di_IXMLNode ServersNode = FileZilla3Node->ChildNodes->FindNode(L\"Servers\");\r\n    if (ServersNode != NULL)\r\n    {\r\n      ImportLevelFromFilezilla(ServersNode, L\"\", SettingsNode);\r\n    }\r\n  }\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TStoredSessionList::ImportFromKnownHosts(TStrings * Lines)\r\n{\r\n  bool SessionList = false;\r\n  std::unique_ptr<THierarchicalStorage> HostKeyStorage(Configuration->CreateScpStorage(SessionList));\r\n  std::unique_ptr<TStrings> KeyList(new TStringList());\r\n  if (OpenHostKeysSubKey(HostKeyStorage.get(), false))\r\n  {\r\n    HostKeyStorage->GetValueNames(KeyList.get());\r\n  }\r\n  HostKeyStorage.reset(NULL);\r\n\r\n  UnicodeString FirstError;\r\n  for (int Index = 0; Index < Lines->Count; Index++)\r\n  {\r\n    try\r\n    {\r\n      UnicodeString Line = Lines->Strings[Index];\r\n      Line = Trim(Line);\r\n      if (!Line.IsEmpty() && (Line[1] != L';'))\r\n      {\r\n        int P = Pos(L' ', Line);\r\n        if (P > 0)\r\n        {\r\n          UnicodeString HostNameStr = Line.SubString(1, P - 1);\r\n          Line = Line.SubString(P + 1, Line.Length() - P);\r\n\r\n          P = Pos(L',', HostNameStr);\r\n          if (P > 0)\r\n          {\r\n            HostNameStr.SetLength(P - 1);\r\n          }\r\n          P = Pos(L':', HostNameStr);\r\n          int PortNumber = -1;\r\n          if (P > 0)\r\n          {\r\n            UnicodeString PortNumberStr = HostNameStr.SubString(P + 1, HostNameStr.Length() - P);\r\n            PortNumber = StrToInt(PortNumberStr);\r\n            HostNameStr.SetLength(P - 1);\r\n          }\r\n          if ((HostNameStr.Length() >= 2) &&\r\n              (HostNameStr[1] == L'[') && (HostNameStr[HostNameStr.Length()] == L']'))\r\n          {\r\n            HostNameStr = HostNameStr.SubString(2, HostNameStr.Length() - 2);\r\n          }\r\n\r\n          UnicodeString NameStr = HostNameStr;\r\n          if (PortNumber >= 0)\r\n          {\r\n            NameStr = FORMAT(L\"%s:%d\", (NameStr, PortNumber));\r\n          }\r\n\r\n          std::unique_ptr<TSessionData> SessionDataOwner;\r\n          TSessionData * SessionData = dynamic_cast<TSessionData *>(FindByName(NameStr));\r\n          if (SessionData == NULL)\r\n          {\r\n            SessionData = new TSessionData(L\"\");\r\n            SessionDataOwner.reset(SessionData);\r\n            SessionData->CopyData(DefaultSettings);\r\n            SessionData->Name = NameStr;\r\n            SessionData->HostName = HostNameStr;\r\n            if (PortNumber >= 0)\r\n            {\r\n              SessionData->PortNumber = PortNumber;\r\n            }\r\n          }\r\n\r\n          const struct ssh_keyalg * Algorithm;\r\n          UnicodeString Key = ParseOpenSshPubLine(Line, Algorithm);\r\n          UnicodeString KeyKey =\r\n            FORMAT(L\"%s@%d:%s\", (Algorithm->cache_id, SessionData->PortNumber, HostNameStr));\r\n          UnicodeString HostKey =\r\n            FORMAT(L\"%s:%s=%s\", (Algorithm->ssh_id, KeyKey, Key));\r\n          UnicodeString HostKeyList = SessionData->HostKey;\r\n          AddToList(HostKeyList, HostKey, L\";\");\r\n          SessionData->HostKey = HostKeyList;\r\n          // If there's at least one unknown key type for this host, select it\r\n          if (KeyList->IndexOf(KeyKey) < 0)\r\n          {\r\n            SessionData->Selected = true;\r\n          }\r\n\r\n          if (SessionDataOwner.get() != NULL)\r\n          {\r\n            Add(SessionDataOwner.release());\r\n          }\r\n        }\r\n      }\r\n    }\r\n    catch (Exception & E)\r\n    {\r\n      if (FirstError.IsEmpty())\r\n      {\r\n        FirstError = E.Message;\r\n      }\r\n    }\r\n  }\r\n\r\n  if (Count == 0)\r\n  {\r\n    UnicodeString Message = LoadStr(KNOWN_HOSTS_NO_SITES);\r\n    if (!FirstError.IsEmpty())\r\n    {\r\n      Message = FORMAT(L\"%s\\n(%s)\", (Message, FirstError));\r\n    }\r\n\r\n    throw Exception(Message);\r\n  }\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TStoredSessionList::Export(const UnicodeString FileName)\r\n{\r\n  THierarchicalStorage * Storage = TIniFileStorage::CreateFromPath(FileName);\r\n  try\r\n  {\r\n    Storage->AccessMode = smReadWrite;\r\n    if (Storage->OpenSubKey(Configuration->StoredSessionsSubKey, true))\r\n    {\r\n      Save(Storage, true);\r\n    }\r\n  }\r\n  __finally\r\n  {\r\n    delete Storage;\r\n  }\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TStoredSessionList::SelectAll(bool Select)\r\n{\r\n  for (int Index = 0; Index < Count; Index++)\r\n    Sessions[Index]->Selected = Select;\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TStoredSessionList::Import(TStoredSessionList * From,\r\n  bool OnlySelected, TList * Imported)\r\n{\r\n  for (int Index = 0; Index < From->Count; Index++)\r\n  {\r\n    if (!OnlySelected || From->Sessions[Index]->Selected)\r\n    {\r\n      TSessionData *Session = new TSessionData(L\"\");\r\n      Session->Assign(From->Sessions[Index]);\r\n      Session->Modified = true;\r\n      Session->MakeUniqueIn(this);\r\n      Add(Session);\r\n      if (Imported != NULL)\r\n      {\r\n        Imported->Add(Session);\r\n      }\r\n    }\r\n  }\r\n  // only modified, explicit\r\n  Save(false, true);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TStoredSessionList::SelectSessionsToImport\r\n  (TStoredSessionList * Dest, bool SSHOnly)\r\n{\r\n  for (int Index = 0; Index < Count; Index++)\r\n  {\r\n    Sessions[Index]->Selected =\r\n      (!SSHOnly || (Sessions[Index]->GetNormalizedPuttyProtocol() == PuttySshProtocol)) &&\r\n      !Dest->FindByName(Sessions[Index]->Name);\r\n  }\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TStoredSessionList::Cleanup()\r\n{\r\n  try\r\n  {\r\n    if (Configuration->Storage == stRegistry) Clear();\r\n    TRegistryStorage * Storage = new TRegistryStorage(Configuration->RegistryStorageKey);\r\n    try\r\n    {\r\n      Storage->AccessMode = smReadWrite;\r\n      if (Storage->OpenRootKey(False))\r\n        Storage->RecursiveDeleteSubKey(Configuration->StoredSessionsSubKey);\r\n    }\r\n    __finally\r\n    {\r\n      delete Storage;\r\n    }\r\n  }\r\n  catch (Exception &E)\r\n  {\r\n    throw ExtException(&E, LoadStr(CLEANUP_SESSIONS_ERROR));\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TStoredSessionList::UpdateStaticUsage()\r\n{\r\n  int SCP = 0;\r\n  int SFTP = 0;\r\n  int FTP = 0;\r\n  int FTPS = 0;\r\n  int WebDAV = 0;\r\n  int WebDAVS = 0;\r\n  int S3 = 0;\r\n  int Password = 0;\r\n  int Advanced = 0;\r\n  int Color = 0;\r\n  int Note = 0;\r\n  int Tunnel = 0;\r\n  bool Folders = false;\r\n  bool Workspaces = false;\r\n  std::unique_ptr<TSessionData> FactoryDefaults(new TSessionData(L\"\"));\r\n  std::unique_ptr<TStringList> DifferentAdvancedProperties(CreateSortedStringList());\r\n  for (int Index = 0; Index < Count; Index++)\r\n  {\r\n    TSessionData * Data = Sessions[Index];\r\n    if (Data->IsWorkspace)\r\n    {\r\n      Workspaces = true;\r\n    }\r\n    else\r\n    {\r\n      switch (Data->FSProtocol)\r\n      {\r\n        case fsSCPonly:\r\n          SCP++;\r\n          break;\r\n\r\n        case fsSFTP:\r\n        case fsSFTPonly:\r\n          SFTP++;\r\n          break;\r\n\r\n        case fsFTP:\r\n          if (Data->Ftps == ftpsNone)\r\n          {\r\n            FTP++;\r\n          }\r\n          else\r\n          {\r\n            FTPS++;\r\n          }\r\n          break;\r\n\r\n        case fsWebDAV:\r\n          if (Data->Ftps == ftpsNone)\r\n          {\r\n            WebDAV++;\r\n          }\r\n          else\r\n          {\r\n            WebDAVS++;\r\n          }\r\n          break;\r\n\r\n        case fsS3:\r\n          S3++;\r\n          break;\r\n      }\r\n\r\n      if (Data->HasAnySessionPassword())\r\n      {\r\n        Password++;\r\n      }\r\n\r\n      if (Data->Color != 0)\r\n      {\r\n        Color++;\r\n      }\r\n\r\n      if (!Data->Note.IsEmpty())\r\n      {\r\n        Note++;\r\n      }\r\n\r\n      // This would not work for passwords, as they are compared in their encrypted form.\r\n      // But there are no passwords set in factory defaults anyway.\r\n      if (!Data->IsSame(FactoryDefaults.get(), true, DifferentAdvancedProperties.get(), false))\r\n      {\r\n        Advanced++;\r\n      }\r\n\r\n      if (Data->Tunnel)\r\n      {\r\n        Tunnel++;\r\n      }\r\n\r\n      if (!Data->FolderName.IsEmpty())\r\n      {\r\n        Folders = true;\r\n      }\r\n    }\r\n  }\r\n\r\n  Configuration->Usage->Set(L\"StoredSessionsCountSCP\", SCP);\r\n  Configuration->Usage->Set(L\"StoredSessionsCountSFTP\", SFTP);\r\n  Configuration->Usage->Set(L\"StoredSessionsCountFTP\", FTP);\r\n  Configuration->Usage->Set(L\"StoredSessionsCountFTPS\", FTPS);\r\n  Configuration->Usage->Set(L\"StoredSessionsCountWebDAV\", WebDAV);\r\n  Configuration->Usage->Set(L\"StoredSessionsCountWebDAVS\", WebDAVS);\r\n  Configuration->Usage->Set(L\"StoredSessionsCountS3\", S3);\r\n  Configuration->Usage->Set(L\"StoredSessionsCountPassword\", Password);\r\n  Configuration->Usage->Set(L\"StoredSessionsCountColor\", Color);\r\n  Configuration->Usage->Set(L\"StoredSessionsCountNote\", Note);\r\n  Configuration->Usage->Set(L\"StoredSessionsCountAdvanced\", Advanced);\r\n  DifferentAdvancedProperties->Delimiter = L',';\r\n  Configuration->Usage->Set(L\"StoredSessionsAdvancedSettings\", DifferentAdvancedProperties->DelimitedText);\r\n  Configuration->Usage->Set(L\"StoredSessionsCountTunnel\", Tunnel);\r\n\r\n  // actually default might be true, see below for when the default is actually used\r\n  bool CustomDefaultStoredSession = false;\r\n  try\r\n  {\r\n    // this can throw, when the default session settings have password set\r\n    // (and no other basic property, like hostname/username),\r\n    // and master password is enabled as we are called before master password\r\n    // handler is set\r\n    CustomDefaultStoredSession = !FDefaultSettings->IsSame(FactoryDefaults.get(), false);\r\n  }\r\n  catch (...)\r\n  {\r\n  }\r\n  Configuration->Usage->Set(L\"UsingDefaultStoredSession\", CustomDefaultStoredSession);\r\n\r\n  Configuration->Usage->Set(L\"UsingStoredSessionsFolders\", Folders);\r\n  Configuration->Usage->Set(L\"UsingWorkspaces\", Workspaces);\r\n}\r\n//---------------------------------------------------------------------------\r\nTSessionData * __fastcall TStoredSessionList::FindSame(TSessionData * Data)\r\n{\r\n  TSessionData * Result;\r\n  if (Data->Hidden || Data->Name.IsEmpty() || Data->IsWorkspace)\r\n  {\r\n    Result = NULL;\r\n  }\r\n  else\r\n  {\r\n    Result = dynamic_cast<TSessionData *>(FindByName(Data->Name));\r\n  }\r\n  return Result;\r\n}\r\n//---------------------------------------------------------------------------\r\nint __fastcall TStoredSessionList::IndexOf(TSessionData * Data)\r\n{\r\n  for (int Index = 0; Index < Count; Index++)\r\n    if (Data == Sessions[Index]) return Index;\r\n  return -1;\r\n}\r\n//---------------------------------------------------------------------------\r\nTSessionData * __fastcall TStoredSessionList::NewSession(\r\n  UnicodeString SessionName, TSessionData * Session)\r\n{\r\n  TSessionData * DuplicateSession = (TSessionData*)FindByName(SessionName);\r\n  if (!DuplicateSession)\r\n  {\r\n    DuplicateSession = new TSessionData(L\"\");\r\n    DuplicateSession->Assign(Session);\r\n    DuplicateSession->Name = SessionName;\r\n    // make sure, that new stored session is saved to registry\r\n    DuplicateSession->Modified = true;\r\n    Add(DuplicateSession);\r\n  }\r\n  else\r\n  {\r\n    DuplicateSession->Assign(Session);\r\n    DuplicateSession->Name = SessionName;\r\n    DuplicateSession->Modified = true;\r\n  }\r\n  // list was saved here before to default storage, but it would not allow\r\n  // to work with special lists (export/import) not using default storage\r\n  return DuplicateSession;\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TStoredSessionList::SetDefaultSettings(TSessionData * value)\r\n{\r\n  DebugAssert(FDefaultSettings);\r\n  if (FDefaultSettings != value)\r\n  {\r\n    FDefaultSettings->Assign(value);\r\n    // make sure default settings are saved\r\n    FDefaultSettings->Modified = true;\r\n    FDefaultSettings->Name = DefaultName;\r\n    if (!FReadOnly)\r\n    {\r\n      // only modified, explicit\r\n      Save(false, true);\r\n    }\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\nbool __fastcall TStoredSessionList::OpenHostKeysSubKey(THierarchicalStorage * Storage, bool CanCreate)\r\n{\r\n  return\r\n    Storage->OpenRootKey(CanCreate) &&\r\n    Storage->OpenSubKey(Configuration->SshHostKeysSubKey, CanCreate);\r\n}\r\n//---------------------------------------------------------------------------\r\nTHierarchicalStorage * __fastcall TStoredSessionList::CreateHostKeysStorageForWritting()\r\n{\r\n  bool SessionList = false;\r\n  std::unique_ptr<THierarchicalStorage> Storage(Configuration->CreateScpStorage(SessionList));\r\n  Storage->Explicit = true;\r\n  Storage->AccessMode = smReadWrite;\r\n  return Storage.release();\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TStoredSessionList::ImportHostKeys(\r\n  THierarchicalStorage * SourceStorage, THierarchicalStorage * TargetStorage, TStoredSessionList * Sessions, bool OnlySelected)\r\n{\r\n  if (OpenHostKeysSubKey(SourceStorage, false) &&\r\n      OpenHostKeysSubKey(TargetStorage, true))\r\n  {\r\n    std::auto_ptr<TStringList> KeyList(new TStringList());\r\n    SourceStorage->GetValueNames(KeyList.get());\r\n\r\n    DebugAssert(Sessions != NULL);\r\n    for (int Index = 0; Index < Sessions->Count; Index++)\r\n    {\r\n      TSessionData * Session = Sessions->Sessions[Index];\r\n      if (!OnlySelected || Session->Selected)\r\n      {\r\n        UnicodeString HostKeyName = PuttyMungeStr(FORMAT(L\"@%d:%s\", (Session->PortNumber, Session->HostNameExpanded)));\r\n        for (int KeyIndex = 0; KeyIndex < KeyList->Count; KeyIndex++)\r\n        {\r\n          UnicodeString KeyName = KeyList->Strings[KeyIndex];\r\n          if (EndsText(HostKeyName, KeyName))\r\n          {\r\n            TargetStorage->WriteStringRaw(KeyName, SourceStorage->ReadStringRaw(KeyName, L\"\"));\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TStoredSessionList::ImportHostKeys(\r\n  const UnicodeString & SourceKey, TStoredSessionList * Sessions, bool OnlySelected)\r\n{\r\n  std::auto_ptr<THierarchicalStorage> TargetStorage(CreateHostKeysStorageForWritting());\r\n  std::auto_ptr<THierarchicalStorage> SourceStorage(new TRegistryStorage(SourceKey));\r\n\r\n  ImportHostKeys(SourceStorage.get(), TargetStorage.get(), Sessions, OnlySelected);\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TStoredSessionList::ImportSelectedKnownHosts(TStoredSessionList * Sessions)\r\n{\r\n  std::unique_ptr<THierarchicalStorage> Storage(CreateHostKeysStorageForWritting());\r\n  if (OpenHostKeysSubKey(Storage.get(), true))\r\n  {\r\n    for (int Index = 0; Index < Sessions->Count; Index++)\r\n    {\r\n      TSessionData * Session = Sessions->Sessions[Index];\r\n      if (Session->Selected)\r\n      {\r\n        UnicodeString Algs;\r\n        UnicodeString HostKeys = Session->HostKey;\r\n        while (!HostKeys.IsEmpty())\r\n        {\r\n          UnicodeString HostKey = CutToChar(HostKeys, L';', true);\r\n          // skip alg\r\n          CutToChar(HostKey, L':', true);\r\n          UnicodeString Key = CutToChar(HostKey, L'=', true);\r\n          Storage->WriteStringRaw(Key, HostKey);\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\nbool __fastcall TStoredSessionList::IsFolderOrWorkspace(\r\n  const UnicodeString & Name, bool Workspace)\r\n{\r\n  bool Result = false;\r\n  TSessionData * FirstData = NULL;\r\n  if (!Name.IsEmpty())\r\n  {\r\n    for (int Index = 0; !Result && (Index < Count); Index++)\r\n    {\r\n      Result = Sessions[Index]->IsInFolderOrWorkspace(Name);\r\n      if (Result)\r\n      {\r\n        FirstData = Sessions[Index];\r\n      }\r\n    }\r\n  }\r\n\r\n  return\r\n    Result &&\r\n    DebugAlwaysTrue(FirstData != NULL) &&\r\n    (FirstData->IsWorkspace == Workspace);\r\n}\r\n//---------------------------------------------------------------------------\r\nbool __fastcall TStoredSessionList::IsFolder(const UnicodeString & Name)\r\n{\r\n  return IsFolderOrWorkspace(Name, false);\r\n}\r\n//---------------------------------------------------------------------------\r\nbool __fastcall TStoredSessionList::IsWorkspace(const UnicodeString & Name)\r\n{\r\n  return IsFolderOrWorkspace(Name, true);\r\n}\r\n//---------------------------------------------------------------------------\r\nTSessionData * __fastcall TStoredSessionList::CheckIsInFolderOrWorkspaceAndResolve(\r\n  TSessionData * Data, const UnicodeString & Name)\r\n{\r\n  if (Data->IsInFolderOrWorkspace(Name))\r\n  {\r\n    Data = ResolveWorkspaceData(Data);\r\n\r\n    if ((Data != NULL) && Data->CanLogin &&\r\n        DebugAlwaysTrue(Data->Link.IsEmpty()))\r\n    {\r\n      return Data;\r\n    }\r\n  }\r\n  return NULL;\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TStoredSessionList::GetFolderOrWorkspace(const UnicodeString & Name, TList * List)\r\n{\r\n  DoGetFolderOrWorkspace(Name, List, false);\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TStoredSessionList::DoGetFolderOrWorkspace(const UnicodeString & Name, TList * List, bool NoRecrypt)\r\n{\r\n  for (int Index = 0; (Index < Count); Index++)\r\n  {\r\n    TSessionData * RawData = Sessions[Index];\r\n    TSessionData * Data =\r\n      CheckIsInFolderOrWorkspaceAndResolve(RawData, Name);\r\n\r\n    if (Data != NULL)\r\n    {\r\n      TSessionData * Data2 = new TSessionData(L\"\");\r\n      if (NoRecrypt)\r\n      {\r\n        Data2->CopyDataNoRecrypt(Data);\r\n      }\r\n      else\r\n      {\r\n        Data2->Assign(Data);\r\n      }\r\n\r\n      if (!RawData->Link.IsEmpty() && (DebugAlwaysTrue(Data != RawData)) &&\r\n          // BACKWARD COMPATIBILITY\r\n          // When loading pre-5.6.4 workspace, that does not have state saved,\r\n          // do not overwrite the site \"state\" defaults\r\n          // with (empty) workspace state\r\n          RawData->HasStateData())\r\n      {\r\n        Data2->CopyStateData(RawData);\r\n      }\r\n\r\n      if (!RawData->NameOverride.IsEmpty())\r\n      {\r\n        Data2->Name = RawData->NameOverride;\r\n      }\r\n      else if (RawData->Link.IsEmpty() && RawData->IsWorkspace)\r\n      {\r\n        // Newly opened ad-hoc session has no name, so restore the workspace that way too.\r\n        // Otherwise we would persist the generated internal workspace name as a real name.\r\n        Data2->Name = UnicodeString();\r\n      }\r\n\r\n      List->Add(Data2);\r\n    }\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\nTStrings * __fastcall TStoredSessionList::GetFolderOrWorkspaceList(\r\n  const UnicodeString & Name)\r\n{\r\n  std::unique_ptr<TObjectList> DataList(new TObjectList());\r\n  DoGetFolderOrWorkspace(Name, DataList.get(), true);\r\n\r\n  std::unique_ptr<TStringList> Result(new TStringList());\r\n  for (int Index = 0; (Index < DataList->Count); Index++)\r\n  {\r\n    Result->Add(dynamic_cast<TSessionData *>(DataList->Items[Index])->SessionName);\r\n  }\r\n\r\n  return Result.release();\r\n}\r\n//---------------------------------------------------------------------------\r\nTStrings * __fastcall TStoredSessionList::GetWorkspaces()\r\n{\r\n  std::unique_ptr<TStringList> Result(CreateSortedStringList());\r\n\r\n  for (int Index = 0; (Index < Count); Index++)\r\n  {\r\n    TSessionData * Data = Sessions[Index];\r\n    if (Data->IsWorkspace)\r\n    {\r\n      Result->Add(Data->FolderName);\r\n    }\r\n  }\r\n\r\n  return Result.release();\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TStoredSessionList::NewWorkspace(\r\n  UnicodeString Name, TList * DataList)\r\n{\r\n  for (int Index = 0; (Index < Count); Index++)\r\n  {\r\n    TSessionData * Data = Sessions[Index];\r\n    if (Data->IsInFolderOrWorkspace(Name))\r\n    {\r\n      FPendingRemovals->Add(Data->Name);\r\n      Remove(Data);\r\n      Index--;\r\n    }\r\n  }\r\n\r\n  for (int Index = 0; (Index < DataList->Count); Index++)\r\n  {\r\n    TSessionData * Data = static_cast<TSessionData *>(DataList->Items[Index]);\r\n\r\n    TSessionData * Data2 = new TSessionData(L\"\");\r\n    Data2->Assign(Data);\r\n    Data2->Name = TSessionData::ComposePath(Name, Data->Name);\r\n    // make sure, that new stored session is saved to registry\r\n    Data2->Modified = true;\r\n    Add(Data2);\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\nbool __fastcall TStoredSessionList::HasAnyWorkspace()\r\n{\r\n  bool Result = false;\r\n  for (int Index = 0; !Result && (Index < Count); Index++)\r\n  {\r\n    TSessionData * Data = Sessions[Index];\r\n    Result = Data->IsWorkspace;\r\n  }\r\n  return Result;\r\n}\r\n//---------------------------------------------------------------------------\r\nTSessionData * __fastcall TStoredSessionList::ParseUrl(UnicodeString Url,\r\n  TOptions * Options, bool & DefaultsOnly, UnicodeString * FileName,\r\n  bool * AProtocolDefined, UnicodeString * MaskedUrl, int Flags)\r\n{\r\n  TSessionData * Data = new TSessionData(L\"\");\r\n  try\r\n  {\r\n    Data->ParseUrl(Url, Options, this, DefaultsOnly, FileName, AProtocolDefined, MaskedUrl, Flags);\r\n  }\r\n  catch(...)\r\n  {\r\n    delete Data;\r\n    throw;\r\n  }\r\n\r\n  return Data;\r\n}\r\n//---------------------------------------------------------------------\r\nbool __fastcall TStoredSessionList::IsUrl(UnicodeString Url)\r\n{\r\n  bool DefaultsOnly;\r\n  bool ProtocolDefined = false;\r\n  std::unique_ptr<TSessionData> ParsedData(ParseUrl(Url, NULL, DefaultsOnly, NULL, &ProtocolDefined));\r\n  bool Result = ProtocolDefined;\r\n  return Result;\r\n}\r\n//---------------------------------------------------------------------\r\nTSessionData * __fastcall TStoredSessionList::ResolveWorkspaceData(TSessionData * Data)\r\n{\r\n  if (!Data->Link.IsEmpty())\r\n  {\r\n    Data = dynamic_cast<TSessionData *>(FindByName(Data->Link));\r\n    if (Data != NULL)\r\n    {\r\n      Data = ResolveWorkspaceData(Data);\r\n    }\r\n  }\r\n  return Data;\r\n}\r\n//---------------------------------------------------------------------\r\nTSessionData * __fastcall TStoredSessionList::SaveWorkspaceData(TSessionData * Data, int Index)\r\n{\r\n  std::unique_ptr<TSessionData> Result(new TSessionData(L\"\"));\r\n\r\n  TSessionData * SameData = StoredSessions->FindSame(Data);\r\n  if (SameData != NULL)\r\n  {\r\n    Result->CopyStateData(Data);\r\n    Result->Link = Data->Name;\r\n  }\r\n  else\r\n  {\r\n    Result->Assign(Data);\r\n    Result->NameOverride = Data->Name;\r\n  }\r\n\r\n  Result->IsWorkspace = true;\r\n  Result->Name = IntToHex(Index, 4); // See HasSessionName()\r\n\r\n  return Result.release();\r\n}\r\n//---------------------------------------------------------------------\r\nbool __fastcall TStoredSessionList::CanLogin(TSessionData * Data)\r\n{\r\n  Data = ResolveWorkspaceData(Data);\r\n  return (Data != NULL) && Data->CanLogin;\r\n}\r\n//---------------------------------------------------------------------\r\nUnicodeString GetExpandedLogFileName(UnicodeString LogFileName, TDateTime Started, TSessionData * SessionData)\r\n{\r\n  // StripPathQuotes should not be needed as we do not feed quotes anymore\r\n  UnicodeString ANewFileName = StripPathQuotes(ExpandEnvironmentVariables(LogFileName));\r\n  for (int Index = 1; Index < ANewFileName.Length(); Index++)\r\n  {\r\n    if (ANewFileName[Index] == L'!')\r\n    {\r\n      UnicodeString Replacement;\r\n      // keep consistent with TFileCustomCommand::PatternReplacement\r\n      switch (tolower(ANewFileName[Index + 1]))\r\n      {\r\n        case L'y':\r\n          Replacement = FormatDateTime(L\"yyyy\", Started);\r\n          break;\r\n\r\n        case L'm':\r\n          Replacement = FormatDateTime(L\"mm\", Started);\r\n          break;\r\n\r\n        case L'd':\r\n          Replacement = FormatDateTime(L\"dd\", Started);\r\n          break;\r\n\r\n        case L't':\r\n          Replacement = FormatDateTime(L\"hhnnss\", Started);\r\n          break;\r\n\r\n        case 'p':\r\n          Replacement = IntToStr(static_cast<int>(GetCurrentProcessId()));\r\n          break;\r\n\r\n        case L'@':\r\n          if (SessionData != NULL)\r\n          {\r\n            Replacement = MakeValidFileName(SessionData->HostNameExpanded);\r\n          }\r\n          else\r\n          {\r\n            Replacement = L\"nohost\";\r\n          }\r\n          break;\r\n\r\n        case L's':\r\n          if (SessionData != NULL)\r\n          {\r\n            Replacement = MakeValidFileName(SessionData->SessionName);\r\n          }\r\n          else\r\n          {\r\n            Replacement = L\"nosession\";\r\n          }\r\n          break;\r\n\r\n        case L'!':\r\n          Replacement = L\"!\";\r\n          break;\r\n\r\n        default:\r\n          Replacement = UnicodeString(L\"!\") + ANewFileName[Index + 1];\r\n          break;\r\n      }\r\n      ANewFileName.Delete(Index, 2);\r\n      ANewFileName.Insert(Replacement, Index);\r\n      Index += Replacement.Length() - 1;\r\n    }\r\n  }\r\n  return ANewFileName;\r\n}\r\n//---------------------------------------------------------------------\r\nbool __fastcall IsSshProtocol(TFSProtocol FSProtocol)\r\n{\r\n  return\r\n    (FSProtocol == fsSFTPonly) || (FSProtocol == fsSFTP) ||\r\n    (FSProtocol == fsSCPonly);\r\n}\r\n//---------------------------------------------------------------------------\r\nint __fastcall DefaultPort(TFSProtocol FSProtocol, TFtps Ftps)\r\n{\r\n  int Result;\r\n  switch (FSProtocol)\r\n  {\r\n    case fsFTP:\r\n      if (Ftps == ftpsImplicit)\r\n      {\r\n        Result = FtpsImplicitPortNumber;\r\n      }\r\n      else\r\n      {\r\n        Result = FtpPortNumber;\r\n      }\r\n      break;\r\n\r\n    case fsWebDAV:\r\n    case fsS3:\r\n      if (Ftps == ftpsNone)\r\n      {\r\n        Result = HTTPPortNumber;\r\n      }\r\n      else\r\n      {\r\n        Result = HTTPSPortNumber;\r\n      }\r\n      break;\r\n\r\n    default:\r\n      if (IsSshProtocol(FSProtocol))\r\n      {\r\n        Result = SshPortNumber;\r\n      }\r\n      else\r\n      {\r\n        DebugFail();\r\n        Result = -1;\r\n      }\r\n      break;\r\n  }\r\n  return Result;\r\n}\r\n//---------------------------------------------------------------------\r\n", "//---------------------------------------------------------------------------\r\n#ifndef SessionDataH\r\n#define SessionDataH\r\n\r\n#include \"Common.h\"\r\n#include \"Option.h\"\r\n#include \"FileBuffer.h\"\r\n#include \"NamedObjs.h\"\r\n#include \"HierarchicalStorage.h\"\r\n#include \"Configuration.h\"\r\n#include <Xml.XMLIntf.hpp>\r\n//---------------------------------------------------------------------------\r\nenum TCipher { cipWarn, cip3DES, cipBlowfish, cipAES, cipDES, cipArcfour, cipChaCha20 };\r\n#define CIPHER_COUNT (cipChaCha20+1)\r\n// explicit values to skip obsoleted fsExternalSSH, fsExternalSFTP\r\nenum TFSProtocol { fsSCPonly = 0, fsSFTP = 1, fsSFTPonly = 2, fsFTP = 5, fsWebDAV = 6, fsS3 = 7 };\r\n#define FSPROTOCOL_COUNT (fsS3+1)\r\nextern const wchar_t * ProxyMethodNames;\r\nenum TProxyMethod { pmNone, pmSocks4, pmSocks5, pmHTTP, pmTelnet, pmCmd };\r\nenum TSshProt { ssh1only, ssh1deprecated, ssh2deprecated, ssh2only };\r\nenum TKex { kexWarn, kexDHGroup1, kexDHGroup14, kexDHGEx, kexRSA, kexECDH };\r\n#define KEX_COUNT (kexECDH+1)\r\nenum THostKey { hkWarn, hkRSA, hkDSA, hkECDSA, hkED25519, hkMax };\r\n#define HOSTKEY_COUNT (hkMax)\r\nenum TGssLib { gssGssApi32, gssSspi, gssCustom };\r\n#define GSSLIB_COUNT (gssCustom+1)\r\n// names have to match PuTTY registry entries (see settings.c)\r\nenum TSshBug { sbIgnore1, sbPlainPW1, sbRSA1, sbHMAC2, sbDeriveKey2, sbRSAPad2,\r\n  sbPKSessID2, sbRekey2, sbMaxPkt2, sbIgnore2, sbOldGex2, sbWinAdj, sbChanReq };\r\n#define BUG_COUNT (sbChanReq+1)\r\nenum TSftpBug { sbSymlink, sbSignedTS };\r\n#define SFTP_BUG_COUNT (sbSignedTS+1)\r\nextern const wchar_t * PingTypeNames;\r\nenum TPingType { ptOff, ptNullPacket, ptDummyCommand };\r\nenum TAddressFamily { afAuto, afIPv4, afIPv6 };\r\nenum TFtps { ftpsNone, ftpsImplicit, ftpsExplicitSsl, ftpsExplicitTls };\r\n// has to match SSL_VERSION_XXX constants in AsyncSslSocketLayer.h\r\n// ssl2 has no effect now\r\nenum TTlsVersion { ssl2 = 2, ssl3 = 3, tls10 = 10, tls11 = 11, tls12 = 12, tls13 = 13 };\r\n// has to match libs3 S3UriStyle\r\nenum TS3UrlStyle { s3usVirtualHost, s3usPath };\r\nenum TSessionSource { ssNone, ssStored, ssStoredModified };\r\nenum TSessionUrlFlags\r\n{\r\n  sufSpecific = 0x01,\r\n  sufUserName = 0x02,\r\n  sufPassword = 0x04,\r\n  sufHostKey = 0x08,\r\n  sufRawSettings = 0x10,\r\n  sufHttpForWebDAV = 0x20,\r\n  sufSession = sufUserName | sufPassword | sufHostKey,\r\n  sufComplete = sufSession | sufRawSettings,\r\n  sufOpen = sufUserName | sufPassword\r\n};\r\nenum TParseUrlFlags\r\n{\r\n  pufAllowStoredSiteWithProtocol = 0x01,\r\n};\r\n//---------------------------------------------------------------------------\r\nextern const UnicodeString CipherNames[CIPHER_COUNT];\r\nextern const UnicodeString KexNames[KEX_COUNT];\r\nextern const UnicodeString HostKeyNames[HOSTKEY_COUNT];\r\nextern const UnicodeString GssLibNames[GSSLIB_COUNT];\r\nextern const wchar_t SshProtList[][10];\r\nextern const TCipher DefaultCipherList[CIPHER_COUNT];\r\nextern const TKex DefaultKexList[KEX_COUNT];\r\nextern const THostKey DefaultHostKeyList[HOSTKEY_COUNT];\r\nextern const TGssLib DefaultGssLibList[GSSLIB_COUNT];\r\nextern const wchar_t FSProtocolNames[FSPROTOCOL_COUNT][16];\r\nextern const int DefaultSendBuf;\r\nextern const UnicodeString AnonymousUserName;\r\nextern const UnicodeString AnonymousPassword;\r\nextern const int SshPortNumber;\r\nextern const int FtpPortNumber;\r\nextern const int FtpsImplicitPortNumber;\r\nextern const int HTTPPortNumber;\r\nextern const int HTTPSPortNumber;\r\nextern const int TelnetPortNumber;\r\nextern const int ProxyPortNumber;\r\nextern const UnicodeString PuttySshProtocol;\r\nextern const UnicodeString PuttyTelnetProtocol;\r\nextern const UnicodeString SftpProtocol;\r\nextern const UnicodeString ScpProtocol;\r\nextern const UnicodeString FtpProtocol;\r\nextern const UnicodeString FtpsProtocol;\r\nextern const UnicodeString FtpesProtocol;\r\nextern const UnicodeString WebDAVProtocol;\r\nextern const UnicodeString WebDAVSProtocol;\r\nextern const UnicodeString S3Protocol;\r\nextern const UnicodeString SshProtocol;\r\nextern const UnicodeString WinSCPProtocolPrefix;\r\nextern const wchar_t UrlParamSeparator;\r\nextern const wchar_t UrlParamValueSeparator;\r\nextern const UnicodeString UrlHostKeyParamName;\r\nextern const UnicodeString UrlSaveParamName;\r\nextern const UnicodeString PassphraseOption;\r\nextern const UnicodeString S3HostName;\r\n//---------------------------------------------------------------------------\r\nclass TStoredSessionList;\r\n//---------------------------------------------------------------------------\r\nclass TSessionData : public TNamedObject\r\n{\r\nfriend class TStoredSessionList;\r\n\r\nprivate:\r\n  UnicodeString FHostName;\r\n  int FPortNumber;\r\n  UnicodeString FUserName;\r\n  RawByteString FPassword;\r\n  RawByteString FNewPassword;\r\n  bool FChangePassword;\r\n  int FPingInterval;\r\n  TPingType FPingType;\r\n  bool FTryAgent;\r\n  bool FAgentFwd;\r\n  UnicodeString FListingCommand;\r\n  bool FAuthTIS;\r\n  bool FAuthKI;\r\n  bool FAuthKIPassword;\r\n  bool FAuthGSSAPI;\r\n  bool FGSSAPIFwdTGT;\r\n  bool FChangeUsername;\r\n  bool FCompression;\r\n  TSshProt FSshProt;\r\n  bool FSsh2DES;\r\n  bool FSshNoUserAuth;\r\n  TCipher FCiphers[CIPHER_COUNT];\r\n  TKex FKex[KEX_COUNT];\r\n  THostKey FHostKeys[HOSTKEY_COUNT];\r\n  TGssLib FGssLib[GSSLIB_COUNT];\r\n  UnicodeString FGssLibCustom;\r\n  bool FClearAliases;\r\n  TEOLType FEOLType;\r\n  bool FTrimVMSVersions;\r\n  UnicodeString FPublicKeyFile;\r\n  UnicodeString FPassphrase;\r\n  UnicodeString FPuttyProtocol;\r\n  TFSProtocol FFSProtocol;\r\n  bool FModified;\r\n  UnicodeString FLocalDirectory;\r\n  UnicodeString FRemoteDirectory;\r\n  bool FLockInHome;\r\n  bool FSpecial;\r\n  bool FSynchronizeBrowsing;\r\n  bool FUpdateDirectories;\r\n  bool FCacheDirectories;\r\n  bool FCacheDirectoryChanges;\r\n  bool FPreserveDirectoryChanges;\r\n  bool FSelected;\r\n  TAutoSwitch FLookupUserGroups;\r\n  UnicodeString FReturnVar;\r\n  bool FExitCode1IsError;\r\n  bool FScp1Compatibility;\r\n  UnicodeString FShell;\r\n  UnicodeString FSftpServer;\r\n  int FTimeout;\r\n  bool FUnsetNationalVars;\r\n  bool FIgnoreLsWarnings;\r\n  bool FTcpNoDelay;\r\n  int FSendBuf;\r\n  UnicodeString FSourceAddress;\r\n  bool FSshSimple;\r\n  TProxyMethod FProxyMethod;\r\n  UnicodeString FProxyHost;\r\n  int FProxyPort;\r\n  UnicodeString FProxyUsername;\r\n  RawByteString FProxyPassword;\r\n  UnicodeString FProxyTelnetCommand;\r\n  UnicodeString FProxyLocalCommand;\r\n  TAutoSwitch FProxyDNS;\r\n  bool FProxyLocalhost;\r\n  int FFtpProxyLogonType;\r\n  TAutoSwitch FBugs[BUG_COUNT];\r\n  UnicodeString FPuttySettings;\r\n  UnicodeString FCustomParam1;\r\n  UnicodeString FCustomParam2;\r\n  bool FResolveSymlinks;\r\n  bool FFollowDirectorySymlinks;\r\n  TDateTime FTimeDifference;\r\n  bool FTimeDifferenceAuto;\r\n  int FSFTPDownloadQueue;\r\n  int FSFTPUploadQueue;\r\n  int FSFTPListingQueue;\r\n  int FSFTPMaxVersion;\r\n  unsigned long FSFTPMaxPacketSize;\r\n  TDSTMode FDSTMode;\r\n  TAutoSwitch FSFTPBugs[SFTP_BUG_COUNT];\r\n  bool FDeleteToRecycleBin;\r\n  bool FOverwrittenToRecycleBin;\r\n  UnicodeString FRecycleBinPath;\r\n  UnicodeString FPostLoginCommands;\r\n  TAutoSwitch FSCPLsFullTime;\r\n  TAutoSwitch FFtpListAll;\r\n  TAutoSwitch FFtpHost;\r\n  TAutoSwitch FFtpDeleteFromCwd;\r\n  bool FSslSessionReuse;\r\n  UnicodeString FTlsCertificateFile;\r\n  TAddressFamily FAddressFamily;\r\n  UnicodeString FRekeyData;\r\n  unsigned int FRekeyTime;\r\n  int FColor;\r\n  bool FTunnel;\r\n  UnicodeString FTunnelHostName;\r\n  int FTunnelPortNumber;\r\n  UnicodeString FTunnelUserName;\r\n  RawByteString FTunnelPassword;\r\n  UnicodeString FTunnelPublicKeyFile;\r\n  int FTunnelLocalPortNumber;\r\n  UnicodeString FTunnelPortFwd;\r\n  UnicodeString FTunnelHostKey;\r\n  bool FFtpPasvMode;\r\n  TAutoSwitch FFtpForcePasvIp;\r\n  TAutoSwitch FFtpUseMlsd;\r\n  UnicodeString FFtpAccount;\r\n  int FFtpPingInterval;\r\n  TPingType FFtpPingType;\r\n  TAutoSwitch FFtpTransferActiveImmediately;\r\n  TFtps FFtps;\r\n  TTlsVersion FMinTlsVersion;\r\n  TTlsVersion FMaxTlsVersion;\r\n  TAutoSwitch FNotUtf;\r\n  int FInternalEditorEncoding;\r\n  UnicodeString FS3DefaultRegion;\r\n  TS3UrlStyle FS3UrlStyle;\r\n  bool FIsWorkspace;\r\n  UnicodeString FLink;\r\n  UnicodeString FNameOverride;\r\n  UnicodeString FHostKey;\r\n  bool FFingerprintScan;\r\n  bool FOverrideCachedHostKey;\r\n  UnicodeString FNote;\r\n  UnicodeString FWinTitle;\r\n  RawByteString FEncryptKey;\r\n\r\n  UnicodeString FOrigHostName;\r\n  int FOrigPortNumber;\r\n  TProxyMethod FOrigProxyMethod;\r\n  TSessionSource FSource;\r\n  bool FSaveOnly;\r\n  UnicodeString FLogicalHostName;\r\n\r\n  void __fastcall SetHostName(UnicodeString value);\r\n  UnicodeString __fastcall GetHostNameExpanded();\r\n  void __fastcall SetPortNumber(int value);\r\n  void __fastcall SetUserName(UnicodeString value);\r\n  UnicodeString __fastcall GetUserNameExpanded();\r\n  void __fastcall SetPassword(UnicodeString value);\r\n  UnicodeString __fastcall GetPassword() const;\r\n  void __fastcall SetNewPassword(UnicodeString value);\r\n  UnicodeString __fastcall GetNewPassword() const;\r\n  void __fastcall SetChangePassword(bool value);\r\n  void __fastcall SetPingInterval(int value);\r\n  void __fastcall SetTryAgent(bool value);\r\n  void __fastcall SetAgentFwd(bool value);\r\n  void __fastcall SetAuthTIS(bool value);\r\n  void __fastcall SetAuthKI(bool value);\r\n  void __fastcall SetAuthKIPassword(bool value);\r\n  void __fastcall SetAuthGSSAPI(bool value);\r\n  void __fastcall SetGSSAPIFwdTGT(bool value);\r\n  void __fastcall SetChangeUsername(bool value);\r\n  void __fastcall SetCompression(bool value);\r\n  void __fastcall SetSshProt(TSshProt value);\r\n  void __fastcall SetSsh2DES(bool value);\r\n  void __fastcall SetSshNoUserAuth(bool value);\r\n  void __fastcall SetCipher(int Index, TCipher value);\r\n  TCipher __fastcall GetCipher(int Index) const;\r\n  void __fastcall SetKex(int Index, TKex value);\r\n  TKex __fastcall GetKex(int Index) const;\r\n  void __fastcall SetHostKeys(int Index, THostKey value);\r\n  THostKey __fastcall GetHostKeys(int Index) const;\r\n  void __fastcall SetGssLib(int Index, TGssLib value);\r\n  TGssLib __fastcall GetGssLib(int Index) const;\r\n  void __fastcall SetGssLibCustom(UnicodeString value);\r\n  void __fastcall SetPublicKeyFile(UnicodeString value);\r\n  UnicodeString __fastcall GetPassphrase() const;\r\n  void __fastcall SetPassphrase(UnicodeString value);\r\n\r\n  void __fastcall SetPuttyProtocol(UnicodeString value);\r\n  bool __fastcall GetCanLogin();\r\n  void __fastcall SetPingIntervalDT(TDateTime value);\r\n  TDateTime __fastcall GetPingIntervalDT();\r\n  TDateTime __fastcall GetFtpPingIntervalDT();\r\n  void __fastcall SetTimeDifference(TDateTime value);\r\n  void __fastcall SetTimeDifferenceAuto(bool value);\r\n  void __fastcall SetPingType(TPingType value);\r\n  UnicodeString __fastcall GetSessionName();\r\n  UnicodeString __fastcall GetDefaultSessionName();\r\n  UnicodeString __fastcall GetProtocolUrl(bool HttpForWebDAV);\r\n  void __fastcall SetFSProtocol(TFSProtocol value);\r\n  UnicodeString __fastcall GetFSProtocolStr();\r\n  void __fastcall SetLocalDirectory(UnicodeString value);\r\n  UnicodeString __fastcall GetLocalDirectoryExpanded();\r\n  void __fastcall SetRemoteDirectory(UnicodeString value);\r\n  void __fastcall SetSynchronizeBrowsing(bool value);\r\n  void __fastcall SetUpdateDirectories(bool value);\r\n  void __fastcall SetCacheDirectories(bool value);\r\n  void __fastcall SetCacheDirectoryChanges(bool value);\r\n  void __fastcall SetPreserveDirectoryChanges(bool value);\r\n  void __fastcall SetLockInHome(bool value);\r\n  void __fastcall SetSpecial(bool value);\r\n  UnicodeString __fastcall GetInfoTip();\r\n  bool __fastcall GetDefaultShell();\r\n  void __fastcall SetDetectReturnVar(bool value);\r\n  bool __fastcall GetDetectReturnVar();\r\n  void __fastcall SetListingCommand(UnicodeString value);\r\n  void __fastcall SetClearAliases(bool value);\r\n  void __fastcall SetDefaultShell(bool value);\r\n  void __fastcall SetEOLType(TEOLType value);\r\n  void __fastcall SetTrimVMSVersions(bool value);\r\n  void __fastcall SetLookupUserGroups(TAutoSwitch value);\r\n  void __fastcall SetReturnVar(UnicodeString value);\r\n  void __fastcall SetExitCode1IsError(bool value);\r\n  void __fastcall SetScp1Compatibility(bool value);\r\n  void __fastcall SetShell(UnicodeString value);\r\n  void __fastcall SetSftpServer(UnicodeString value);\r\n  void __fastcall SetTimeout(int value);\r\n  void __fastcall SetUnsetNationalVars(bool value);\r\n  void __fastcall SetIgnoreLsWarnings(bool value);\r\n  void __fastcall SetTcpNoDelay(bool value);\r\n  void __fastcall SetSendBuf(int value);\r\n  void __fastcall SetSourceAddress(const UnicodeString & value);\r\n  void __fastcall SetSshSimple(bool value);\r\n  UnicodeString __fastcall GetSshProtStr();\r\n  bool __fastcall GetUsesSsh();\r\n  void __fastcall SetCipherList(UnicodeString value);\r\n  UnicodeString __fastcall GetCipherList() const;\r\n  void __fastcall SetKexList(UnicodeString value);\r\n  UnicodeString __fastcall GetKexList() const;\r\n  void __fastcall SetHostKeyList(UnicodeString value);\r\n  UnicodeString __fastcall GetHostKeyList() const;\r\n  void __fastcall SetGssLibList(UnicodeString value);\r\n  UnicodeString __fastcall GetGssLibList() const;\r\n  void __fastcall SetProxyMethod(TProxyMethod value);\r\n  void __fastcall SetProxyHost(UnicodeString value);\r\n  void __fastcall SetProxyPort(int value);\r\n  void __fastcall SetProxyUsername(UnicodeString value);\r\n  void __fastcall SetProxyPassword(UnicodeString value);\r\n  void __fastcall SetProxyTelnetCommand(UnicodeString value);\r\n  void __fastcall SetProxyLocalCommand(UnicodeString value);\r\n  void __fastcall SetProxyDNS(TAutoSwitch value);\r\n  void __fastcall SetProxyLocalhost(bool value);\r\n  UnicodeString __fastcall GetProxyPassword() const;\r\n  void __fastcall SetFtpProxyLogonType(int value);\r\n  void __fastcall SetBug(TSshBug Bug, TAutoSwitch value);\r\n  TAutoSwitch __fastcall GetBug(TSshBug Bug) const;\r\n  UnicodeString __fastcall GetSessionKey();\r\n  void __fastcall SetPuttySettings(UnicodeString value);\r\n  void __fastcall SetCustomParam1(UnicodeString value);\r\n  void __fastcall SetCustomParam2(UnicodeString value);\r\n  void __fastcall SetResolveSymlinks(bool value);\r\n  void __fastcall SetFollowDirectorySymlinks(bool value);\r\n  void __fastcall SetSFTPDownloadQueue(int value);\r\n  void __fastcall SetSFTPUploadQueue(int value);\r\n  void __fastcall SetSFTPListingQueue(int value);\r\n  void __fastcall SetSFTPMaxVersion(int value);\r\n  void __fastcall SetSFTPMaxPacketSize(unsigned long value);\r\n  void __fastcall SetSFTPBug(TSftpBug Bug, TAutoSwitch value);\r\n  TAutoSwitch __fastcall GetSFTPBug(TSftpBug Bug) const;\r\n  void __fastcall SetSCPLsFullTime(TAutoSwitch value);\r\n  void __fastcall SetFtpListAll(TAutoSwitch value);\r\n  void __fastcall SetFtpHost(TAutoSwitch value);\r\n  void __fastcall SetFtpDeleteFromCwd(TAutoSwitch value);\r\n  void __fastcall SetSslSessionReuse(bool value);\r\n  void __fastcall SetTlsCertificateFile(UnicodeString value);\r\n  UnicodeString __fastcall GetStorageKey();\r\n  UnicodeString __fastcall GetInternalStorageKey();\r\n  UnicodeString __fastcall GetSiteKey();\r\n  void __fastcall SetDSTMode(TDSTMode value);\r\n  void __fastcall SetDeleteToRecycleBin(bool value);\r\n  void __fastcall SetOverwrittenToRecycleBin(bool value);\r\n  void __fastcall SetRecycleBinPath(UnicodeString value);\r\n  void __fastcall SetPostLoginCommands(UnicodeString value);\r\n  void __fastcall SetAddressFamily(TAddressFamily value);\r\n  void __fastcall SetRekeyData(UnicodeString value);\r\n  void __fastcall SetRekeyTime(unsigned int value);\r\n  void __fastcall SetColor(int value);\r\n  void __fastcall SetTunnel(bool value);\r\n  void __fastcall SetTunnelHostName(UnicodeString value);\r\n  void __fastcall SetTunnelPortNumber(int value);\r\n  void __fastcall SetTunnelUserName(UnicodeString value);\r\n  void __fastcall SetTunnelPassword(UnicodeString value);\r\n  UnicodeString __fastcall GetTunnelPassword() const;\r\n  void __fastcall SetTunnelPublicKeyFile(UnicodeString value);\r\n  void __fastcall SetTunnelPortFwd(UnicodeString value);\r\n  void __fastcall SetTunnelLocalPortNumber(int value);\r\n  bool __fastcall GetTunnelAutoassignLocalPortNumber();\r\n  void __fastcall SetTunnelHostKey(UnicodeString value);\r\n  void __fastcall SetFtpPasvMode(bool value);\r\n  void __fastcall SetFtpForcePasvIp(TAutoSwitch value);\r\n  void __fastcall SetFtpUseMlsd(TAutoSwitch value);\r\n  void __fastcall SetFtpAccount(UnicodeString value);\r\n  void __fastcall SetFtpPingInterval(int value);\r\n  void __fastcall SetFtpPingType(TPingType value);\r\n  void __fastcall SetFtpTransferActiveImmediately(TAutoSwitch value);\r\n  void __fastcall SetFtps(TFtps value);\r\n  void __fastcall SetMinTlsVersion(TTlsVersion value);\r\n  void __fastcall SetMaxTlsVersion(TTlsVersion value);\r\n  void __fastcall SetNotUtf(TAutoSwitch value);\r\n  void __fastcall SetInternalEditorEncoding(int value);\r\n  void __fastcall SetS3DefaultRegion(UnicodeString value);\r\n  void __fastcall SetS3UrlStyle(TS3UrlStyle value);\r\n  void __fastcall SetLogicalHostName(UnicodeString value);\r\n  void __fastcall SetIsWorkspace(bool value);\r\n  void __fastcall SetLink(UnicodeString value);\r\n  void __fastcall SetNameOverride(UnicodeString value);\r\n  void __fastcall SetHostKey(UnicodeString value);\r\n  void __fastcall SetNote(UnicodeString value);\r\n  void __fastcall SetWinTitle(UnicodeString value);\r\n  UnicodeString __fastcall GetEncryptKey() const;\r\n  void __fastcall SetEncryptKey(UnicodeString value);\r\n\r\n  TDateTime __fastcall GetTimeoutDT();\r\n  void __fastcall SavePasswords(THierarchicalStorage * Storage, bool PuttyExport, bool DoNotEncryptPasswords, bool SaveAll);\r\n  UnicodeString __fastcall GetLocalName();\r\n  UnicodeString __fastcall GetFolderName();\r\n  void __fastcall Modify();\r\n  UnicodeString __fastcall GetSource();\r\n  void __fastcall DoLoad(THierarchicalStorage * Storage, bool PuttyImport, bool & RewritePassword);\r\n  void __fastcall DoSave(THierarchicalStorage * Storage,\r\n    bool PuttyExport, const TSessionData * Default, bool DoNotEncryptPasswords);\r\n  UnicodeString __fastcall ReadXmlNode(_di_IXMLNode Node, const UnicodeString & Name, const UnicodeString & Default);\r\n  int __fastcall ReadXmlNode(_di_IXMLNode Node, const UnicodeString & Name, int Default);\r\n  _di_IXMLNode __fastcall FindSettingsNode(_di_IXMLNode Node, const UnicodeString & Name);\r\n  UnicodeString __fastcall ReadSettingsNode(_di_IXMLNode Node, const UnicodeString & Name, const UnicodeString & Default);\r\n  int __fastcall ReadSettingsNode(_di_IXMLNode Node, const UnicodeString & Name, int Default);\r\n  bool __fastcall IsSame(const TSessionData * Default, bool AdvancedOnly, TStrings * DifferentProperties, bool Decrypted);\r\n  UnicodeString __fastcall GetNameWithoutHiddenPrefix();\r\n  bool __fastcall HasStateData();\r\n  void __fastcall CopyStateData(TSessionData * SourceData);\r\n  void __fastcall CopyNonCoreData(TSessionData * SourceData);\r\n  UnicodeString __fastcall GetNormalizedPuttyProtocol() const;\r\n  static RawByteString __fastcall EncryptPassword(const UnicodeString & Password, UnicodeString Key);\r\n  static UnicodeString __fastcall DecryptPassword(const RawByteString & Password, UnicodeString Key);\r\n  static RawByteString __fastcall StronglyRecryptPassword(const RawByteString & Password, UnicodeString Key);\r\n  static bool __fastcall DoIsProtocolUrl(const UnicodeString & Url, const UnicodeString & Protocol, int & ProtocolLen);\r\n  static bool __fastcall IsProtocolUrl(const UnicodeString & Url, const UnicodeString & Protocol, int & ProtocolLen);\r\n  static void __fastcall AddSwitch(UnicodeString & Result, const UnicodeString & Name, bool Rtf);\r\n  static void __fastcall AddSwitch(\r\n    UnicodeString & Result, const UnicodeString & Name, const UnicodeString & Value, bool Rtf);\r\n  static void __fastcall AddSwitch(UnicodeString & Result, const UnicodeString & Name, int Value, bool Rtf);\r\n  static void __fastcall AddAssemblyProperty(\r\n    UnicodeString & Result, TAssemblyLanguage Language,\r\n    const UnicodeString & Name, const UnicodeString & Value);\r\n  static void __fastcall AddAssemblyProperty(\r\n    UnicodeString & Result, TAssemblyLanguage Language,\r\n    const UnicodeString & Name, const UnicodeString & Type,\r\n    const UnicodeString & Member);\r\n  static void __fastcall AddAssemblyProperty(\r\n    UnicodeString & Result, TAssemblyLanguage Language,\r\n    const UnicodeString & Name, int Value);\r\n  void __fastcall AddAssemblyProperty(\r\n    UnicodeString & Result, TAssemblyLanguage Language,\r\n    const UnicodeString & Name, bool Value);\r\n  TStrings * __fastcall GetRawSettingsForUrl();\r\n  void __fastcall DoCopyData(TSessionData * SourceData, bool NoRecrypt);\r\n  template<class AlgoT>\r\n  void __fastcall SetAlgoList(AlgoT * List, const AlgoT * DefaultList, const UnicodeString * Names,\r\n    int Count, AlgoT WarnAlgo, UnicodeString value);\r\n  static void __fastcall Remove(THierarchicalStorage * Storage, const UnicodeString & Name);\r\n\r\n  __property UnicodeString InternalStorageKey = { read = GetInternalStorageKey };\r\n\r\npublic:\r\n  __fastcall TSessionData(UnicodeString aName);\r\n  virtual __fastcall ~TSessionData();\r\n  TSessionData * __fastcall Clone();\r\n  void __fastcall Default();\r\n  void __fastcall DefaultSettings();\r\n  void __fastcall NonPersistant();\r\n  void __fastcall Load(THierarchicalStorage * Storage, bool PuttyImport);\r\n  void __fastcall ApplyRawSettings(TStrings * RawSettings);\r\n  void __fastcall ApplyRawSettings(THierarchicalStorage * Storage);\r\n  void __fastcall ImportFromFilezilla(_di_IXMLNode Node, const UnicodeString & Path, _di_IXMLNode SettingsNode);\r\n  void __fastcall Save(THierarchicalStorage * Storage, bool PuttyExport,\r\n    const TSessionData * Default = NULL);\r\n  void __fastcall SaveRecryptedPasswords(THierarchicalStorage * Storage);\r\n  void __fastcall RecryptPasswords();\r\n  bool __fastcall HasPassword();\r\n  bool __fastcall HasAnySessionPassword();\r\n  bool __fastcall HasAnyPassword();\r\n  void __fastcall ClearSessionPasswords();\r\n  void __fastcall MaskPasswords();\r\n  void __fastcall Remove();\r\n  void __fastcall CacheHostKeyIfNotCached();\r\n  virtual void __fastcall Assign(TPersistent * Source);\r\n  virtual int __fastcall Compare(TNamedObject * Other);\r\n  void __fastcall CopyData(TSessionData * Source);\r\n  void __fastcall CopyDataNoRecrypt(TSessionData * SourceData);\r\n  void __fastcall CopyDirectoriesStateData(TSessionData * SourceData);\r\n  bool __fastcall ParseUrl(UnicodeString Url, TOptions * Options,\r\n    TStoredSessionList * StoredSessions, bool & DefaultsOnly,\r\n    UnicodeString * FileName, bool * AProtocolDefined, UnicodeString * MaskedUrl, int Flags);\r\n  TStrings * __fastcall SaveToOptions(const TSessionData * Default, bool SaveName, bool PuttyExport);\r\n  void __fastcall ConfigureTunnel(int PortNumber);\r\n  void __fastcall RollbackTunnel();\r\n  void __fastcall ExpandEnvironmentVariables();\r\n  void __fastcall DisableAuthentationsExceptPassword();\r\n  bool __fastcall IsSame(const TSessionData * Default, bool AdvancedOnly);\r\n  bool __fastcall IsSameDecrypted(const TSessionData * Default);\r\n  bool __fastcall IsSameSite(const TSessionData * Default);\r\n  bool __fastcall IsInFolderOrWorkspace(UnicodeString Name);\r\n  UnicodeString __fastcall GenerateSessionUrl(unsigned int Flags);\r\n  bool __fastcall HasRawSettingsForUrl();\r\n  bool __fastcall HasSessionName();\r\n\r\n  UnicodeString __fastcall GenerateOpenCommandArgs(bool Rtf);\r\n  void __fastcall GenerateAssemblyCode(TAssemblyLanguage Language, UnicodeString & Head, UnicodeString & Tail, int & Indent);\r\n  void __fastcall LookupLastFingerprint();\r\n  bool __fastcall IsSecure();\r\n  static void __fastcall ValidatePath(const UnicodeString Path);\r\n  static void __fastcall ValidateName(const UnicodeString Name);\r\n  static UnicodeString __fastcall MakeValidName(const UnicodeString & Name);\r\n  static UnicodeString __fastcall ExtractLocalName(const UnicodeString & Name);\r\n  static UnicodeString __fastcall ExtractFolderName(const UnicodeString & Name);\r\n  static UnicodeString __fastcall ComposePath(const UnicodeString & Path, const UnicodeString & Name);\r\n  static bool __fastcall IsSensitiveOption(const UnicodeString & Option);\r\n  static bool __fastcall IsOptionWithParameters(const UnicodeString & Option);\r\n  static bool __fastcall MaskPasswordInOptionParameter(const UnicodeString & Option, UnicodeString & Param);\r\n  static UnicodeString __fastcall FormatSiteKey(const UnicodeString & HostName, int PortNumber);\r\n  static TStrings * GetAllOptionNames(bool PuttyExport);\r\n\r\n  __property UnicodeString HostName  = { read=FHostName, write=SetHostName };\r\n  __property UnicodeString HostNameExpanded  = { read=GetHostNameExpanded };\r\n  __property int PortNumber  = { read=FPortNumber, write=SetPortNumber };\r\n  __property UnicodeString UserName  = { read=FUserName, write=SetUserName };\r\n  __property UnicodeString UserNameExpanded  = { read=GetUserNameExpanded };\r\n  __property UnicodeString Password  = { read=GetPassword, write=SetPassword };\r\n  __property UnicodeString NewPassword  = { read=GetNewPassword, write=SetNewPassword };\r\n  __property bool ChangePassword  = { read=FChangePassword, write=SetChangePassword };\r\n  __property int PingInterval  = { read=FPingInterval, write=SetPingInterval };\r\n  __property bool TryAgent  = { read=FTryAgent, write=SetTryAgent };\r\n  __property bool AgentFwd  = { read=FAgentFwd, write=SetAgentFwd };\r\n  __property UnicodeString ListingCommand = { read = FListingCommand, write = SetListingCommand };\r\n  __property bool AuthTIS  = { read=FAuthTIS, write=SetAuthTIS };\r\n  __property bool AuthKI  = { read=FAuthKI, write=SetAuthKI };\r\n  __property bool AuthKIPassword  = { read=FAuthKIPassword, write=SetAuthKIPassword };\r\n  __property bool AuthGSSAPI  = { read=FAuthGSSAPI, write=SetAuthGSSAPI };\r\n  __property bool GSSAPIFwdTGT = { read=FGSSAPIFwdTGT, write=SetGSSAPIFwdTGT };\r\n  __property bool ChangeUsername  = { read=FChangeUsername, write=SetChangeUsername };\r\n  __property bool Compression  = { read=FCompression, write=SetCompression };\r\n  __property TSshProt SshProt  = { read=FSshProt, write=SetSshProt };\r\n  __property bool UsesSsh = { read = GetUsesSsh };\r\n  __property bool Ssh2DES  = { read=FSsh2DES, write=SetSsh2DES };\r\n  __property bool SshNoUserAuth  = { read=FSshNoUserAuth, write=SetSshNoUserAuth };\r\n  __property TCipher Cipher[int Index] = { read=GetCipher, write=SetCipher };\r\n  __property TKex Kex[int Index] = { read=GetKex, write=SetKex };\r\n  __property THostKey HostKeys[int Index] = { read=GetHostKeys, write=SetHostKeys };\r\n  __property TGssLib GssLib[int Index] = { read=GetGssLib, write=SetGssLib };\r\n  __property UnicodeString GssLibCustom = { read=FGssLibCustom, write=SetGssLibCustom };\r\n  __property UnicodeString PublicKeyFile  = { read=FPublicKeyFile, write=SetPublicKeyFile };\r\n  __property UnicodeString Passphrase  = { read=GetPassphrase, write=SetPassphrase };\r\n  __property UnicodeString PuttyProtocol  = { read=FPuttyProtocol, write=SetPuttyProtocol };\r\n  __property TFSProtocol FSProtocol  = { read=FFSProtocol, write=SetFSProtocol  };\r\n  __property UnicodeString FSProtocolStr  = { read=GetFSProtocolStr };\r\n  __property bool Modified  = { read=FModified, write=FModified };\r\n  __property bool CanLogin  = { read=GetCanLogin };\r\n  __property bool ClearAliases = { read = FClearAliases, write = SetClearAliases };\r\n  __property TDateTime PingIntervalDT = { read = GetPingIntervalDT, write = SetPingIntervalDT };\r\n  __property TDateTime TimeDifference = { read = FTimeDifference, write = SetTimeDifference };\r\n  __property bool TimeDifferenceAuto = { read = FTimeDifferenceAuto, write = SetTimeDifferenceAuto };\r\n  __property TPingType PingType = { read = FPingType, write = SetPingType };\r\n  __property UnicodeString SessionName  = { read=GetSessionName };\r\n  __property UnicodeString DefaultSessionName  = { read=GetDefaultSessionName };\r\n  __property UnicodeString LocalDirectory  = { read=FLocalDirectory, write=SetLocalDirectory };\r\n  __property UnicodeString LocalDirectoryExpanded = { read = GetLocalDirectoryExpanded };\r\n  __property UnicodeString RemoteDirectory  = { read=FRemoteDirectory, write=SetRemoteDirectory };\r\n  __property bool SynchronizeBrowsing = { read=FSynchronizeBrowsing, write=SetSynchronizeBrowsing };\r\n  __property bool UpdateDirectories = { read=FUpdateDirectories, write=SetUpdateDirectories };\r\n  __property bool CacheDirectories = { read=FCacheDirectories, write=SetCacheDirectories };\r\n  __property bool CacheDirectoryChanges = { read=FCacheDirectoryChanges, write=SetCacheDirectoryChanges };\r\n  __property bool PreserveDirectoryChanges = { read=FPreserveDirectoryChanges, write=SetPreserveDirectoryChanges };\r\n  __property bool LockInHome = { read=FLockInHome, write=SetLockInHome };\r\n  __property bool Special = { read=FSpecial, write=SetSpecial };\r\n  __property bool Selected  = { read=FSelected, write=FSelected };\r\n  __property UnicodeString InfoTip  = { read=GetInfoTip };\r\n  __property bool DefaultShell = { read = GetDefaultShell, write = SetDefaultShell };\r\n  __property bool DetectReturnVar = { read = GetDetectReturnVar, write = SetDetectReturnVar };\r\n  __property TEOLType EOLType = { read = FEOLType, write = SetEOLType };\r\n  __property bool TrimVMSVersions = { read = FTrimVMSVersions, write = SetTrimVMSVersions };\r\n  __property TAutoSwitch LookupUserGroups = { read = FLookupUserGroups, write = SetLookupUserGroups };\r\n  __property UnicodeString ReturnVar = { read = FReturnVar, write = SetReturnVar };\r\n  __property bool ExitCode1IsError = { read = FExitCode1IsError, write = SetExitCode1IsError };\r\n  __property bool Scp1Compatibility = { read = FScp1Compatibility, write = SetScp1Compatibility };\r\n  __property UnicodeString Shell = { read = FShell, write = SetShell };\r\n  __property UnicodeString SftpServer = { read = FSftpServer, write = SetSftpServer };\r\n  __property int Timeout = { read = FTimeout, write = SetTimeout };\r\n  __property TDateTime TimeoutDT = { read = GetTimeoutDT };\r\n  __property bool UnsetNationalVars = { read = FUnsetNationalVars, write = SetUnsetNationalVars };\r\n  __property bool IgnoreLsWarnings  = { read=FIgnoreLsWarnings, write=SetIgnoreLsWarnings };\r\n  __property bool TcpNoDelay  = { read=FTcpNoDelay, write=SetTcpNoDelay };\r\n  __property int SendBuf  = { read=FSendBuf, write=SetSendBuf };\r\n  __property UnicodeString SourceAddress = { read=FSourceAddress, write=SetSourceAddress };\r\n  __property bool SshSimple  = { read=FSshSimple, write=SetSshSimple };\r\n  __property UnicodeString SshProtStr  = { read=GetSshProtStr };\r\n  __property UnicodeString CipherList  = { read=GetCipherList, write=SetCipherList };\r\n  __property UnicodeString KexList  = { read=GetKexList, write=SetKexList };\r\n  __property UnicodeString HostKeyList  = { read=GetHostKeyList, write=SetHostKeyList };\r\n  __property UnicodeString GssLibList  = { read=GetGssLibList, write=SetGssLibList };\r\n  __property TProxyMethod ProxyMethod  = { read=FProxyMethod, write=SetProxyMethod };\r\n  __property UnicodeString ProxyHost  = { read=FProxyHost, write=SetProxyHost };\r\n  __property int ProxyPort  = { read=FProxyPort, write=SetProxyPort };\r\n  __property UnicodeString ProxyUsername  = { read=FProxyUsername, write=SetProxyUsername };\r\n  __property UnicodeString ProxyPassword  = { read=GetProxyPassword, write=SetProxyPassword };\r\n  __property UnicodeString ProxyTelnetCommand  = { read=FProxyTelnetCommand, write=SetProxyTelnetCommand };\r\n  __property UnicodeString ProxyLocalCommand  = { read=FProxyLocalCommand, write=SetProxyLocalCommand };\r\n  __property TAutoSwitch ProxyDNS  = { read=FProxyDNS, write=SetProxyDNS };\r\n  __property bool ProxyLocalhost  = { read=FProxyLocalhost, write=SetProxyLocalhost };\r\n  __property int FtpProxyLogonType  = { read=FFtpProxyLogonType, write=SetFtpProxyLogonType };\r\n  __property TAutoSwitch Bug[TSshBug Bug]  = { read=GetBug, write=SetBug };\r\n  __property UnicodeString PuttySettings = { read = FPuttySettings, write = SetPuttySettings };\r\n  __property UnicodeString CustomParam1 = { read = FCustomParam1, write = SetCustomParam1 };\r\n  __property UnicodeString CustomParam2 = { read = FCustomParam2, write = SetCustomParam2 };\r\n  __property UnicodeString SessionKey = { read = GetSessionKey };\r\n  __property bool ResolveSymlinks = { read = FResolveSymlinks, write = SetResolveSymlinks };\r\n  __property bool FollowDirectorySymlinks = { read = FFollowDirectorySymlinks, write = SetFollowDirectorySymlinks };\r\n  __property int SFTPDownloadQueue = { read = FSFTPDownloadQueue, write = SetSFTPDownloadQueue };\r\n  __property int SFTPUploadQueue = { read = FSFTPUploadQueue, write = SetSFTPUploadQueue };\r\n  __property int SFTPListingQueue = { read = FSFTPListingQueue, write = SetSFTPListingQueue };\r\n  __property int SFTPMaxVersion = { read = FSFTPMaxVersion, write = SetSFTPMaxVersion };\r\n  __property unsigned long SFTPMaxPacketSize = { read = FSFTPMaxPacketSize, write = SetSFTPMaxPacketSize };\r\n  __property TAutoSwitch SFTPBug[TSftpBug Bug]  = { read=GetSFTPBug, write=SetSFTPBug };\r\n  __property TAutoSwitch SCPLsFullTime = { read = FSCPLsFullTime, write = SetSCPLsFullTime };\r\n  __property TAutoSwitch FtpListAll = { read = FFtpListAll, write = SetFtpListAll };\r\n  __property TAutoSwitch FtpHost = { read = FFtpHost, write = SetFtpHost };\r\n  __property TAutoSwitch FtpDeleteFromCwd = { read = FFtpDeleteFromCwd, write = SetFtpDeleteFromCwd };\r\n  __property bool SslSessionReuse = { read = FSslSessionReuse, write = SetSslSessionReuse };\r\n  __property UnicodeString TlsCertificateFile = { read=FTlsCertificateFile, write=SetTlsCertificateFile };\r\n  __property TDSTMode DSTMode = { read = FDSTMode, write = SetDSTMode };\r\n  __property bool DeleteToRecycleBin = { read = FDeleteToRecycleBin, write = SetDeleteToRecycleBin };\r\n  __property bool OverwrittenToRecycleBin = { read = FOverwrittenToRecycleBin, write = SetOverwrittenToRecycleBin };\r\n  __property UnicodeString RecycleBinPath = { read = FRecycleBinPath, write = SetRecycleBinPath };\r\n  __property UnicodeString PostLoginCommands = { read = FPostLoginCommands, write = SetPostLoginCommands };\r\n  __property TAddressFamily AddressFamily = { read = FAddressFamily, write = SetAddressFamily };\r\n  __property UnicodeString RekeyData = { read = FRekeyData, write = SetRekeyData };\r\n  __property unsigned int RekeyTime = { read = FRekeyTime, write = SetRekeyTime };\r\n  __property int Color = { read = FColor, write = SetColor };\r\n  __property bool Tunnel = { read = FTunnel, write = SetTunnel };\r\n  __property UnicodeString TunnelHostName = { read = FTunnelHostName, write = SetTunnelHostName };\r\n  __property int TunnelPortNumber = { read = FTunnelPortNumber, write = SetTunnelPortNumber };\r\n  __property UnicodeString TunnelUserName = { read = FTunnelUserName, write = SetTunnelUserName };\r\n  __property UnicodeString TunnelPassword = { read = GetTunnelPassword, write = SetTunnelPassword };\r\n  __property UnicodeString TunnelPublicKeyFile = { read = FTunnelPublicKeyFile, write = SetTunnelPublicKeyFile };\r\n  __property bool TunnelAutoassignLocalPortNumber = { read = GetTunnelAutoassignLocalPortNumber };\r\n  __property int TunnelLocalPortNumber = { read = FTunnelLocalPortNumber, write = SetTunnelLocalPortNumber };\r\n  __property UnicodeString TunnelPortFwd = { read = FTunnelPortFwd, write = SetTunnelPortFwd };\r\n  __property UnicodeString TunnelHostKey = { read = FTunnelHostKey, write = SetTunnelHostKey };\r\n  __property bool FtpPasvMode = { read = FFtpPasvMode, write = SetFtpPasvMode };\r\n  __property TAutoSwitch FtpForcePasvIp = { read = FFtpForcePasvIp, write = SetFtpForcePasvIp };\r\n  __property TAutoSwitch FtpUseMlsd = { read = FFtpUseMlsd, write = SetFtpUseMlsd };\r\n  __property UnicodeString FtpAccount = { read = FFtpAccount, write = SetFtpAccount };\r\n  __property int FtpPingInterval  = { read=FFtpPingInterval, write=SetFtpPingInterval };\r\n  __property TDateTime FtpPingIntervalDT  = { read=GetFtpPingIntervalDT };\r\n  __property TPingType FtpPingType = { read = FFtpPingType, write = SetFtpPingType };\r\n  __property TAutoSwitch FtpTransferActiveImmediately = { read = FFtpTransferActiveImmediately, write = SetFtpTransferActiveImmediately };\r\n  __property TFtps Ftps = { read = FFtps, write = SetFtps };\r\n  __property TTlsVersion MinTlsVersion = { read = FMinTlsVersion, write = SetMinTlsVersion };\r\n  __property TTlsVersion MaxTlsVersion = { read = FMaxTlsVersion, write = SetMaxTlsVersion };\r\n  __property UnicodeString LogicalHostName = { read = FLogicalHostName, write = SetLogicalHostName };\r\n  __property TAutoSwitch NotUtf = { read = FNotUtf, write = SetNotUtf };\r\n  __property int InternalEditorEncoding = { read = FInternalEditorEncoding, write = SetInternalEditorEncoding };\r\n  __property UnicodeString S3DefaultRegion = { read = FS3DefaultRegion, write = SetS3DefaultRegion };\r\n  __property TS3UrlStyle S3UrlStyle = { read = FS3UrlStyle, write = SetS3UrlStyle };\r\n  __property bool IsWorkspace = { read = FIsWorkspace, write = SetIsWorkspace };\r\n  __property UnicodeString Link = { read = FLink, write = SetLink };\r\n  __property UnicodeString NameOverride = { read = FNameOverride, write = SetNameOverride };\r\n  __property UnicodeString HostKey = { read = FHostKey, write = SetHostKey };\r\n  __property bool FingerprintScan = { read = FFingerprintScan, write = FFingerprintScan };\r\n  __property bool OverrideCachedHostKey = { read = FOverrideCachedHostKey };\r\n  __property UnicodeString Note = { read = FNote, write = SetNote };\r\n  __property UnicodeString WinTitle = { read = FWinTitle, write = SetWinTitle };\r\n  __property UnicodeString EncryptKey = { read = GetEncryptKey, write = SetEncryptKey };\r\n\r\n  __property UnicodeString StorageKey = { read = GetStorageKey };\r\n  __property UnicodeString SiteKey = { read = GetSiteKey };\r\n  __property UnicodeString OrigHostName = { read = FOrigHostName };\r\n  __property int OrigPortNumber = { read = FOrigPortNumber };\r\n  __property UnicodeString LocalName = { read = GetLocalName };\r\n  __property UnicodeString FolderName = { read = GetFolderName };\r\n  __property UnicodeString Source = { read = GetSource };\r\n  __property bool SaveOnly = { read = FSaveOnly };\r\n};\r\n//---------------------------------------------------------------------------\r\nclass TStoredSessionList : public TNamedObjectList\r\n{\r\npublic:\r\n  __fastcall TStoredSessionList(bool aReadOnly = false);\r\n  void __fastcall Reload();\r\n  void __fastcall Save(bool All, bool Explicit);\r\n  void __fastcall Saved();\r\n  void __fastcall ImportFromFilezilla(const UnicodeString FileName, const UnicodeString ConfigurationFileName);\r\n  void __fastcall ImportFromKnownHosts(TStrings * Lines);\r\n  void __fastcall Export(const UnicodeString FileName);\r\n  void __fastcall Load(THierarchicalStorage * Storage, bool AsModified = false,\r\n    bool UseDefaults = false, bool PuttyImport = false);\r\n  void __fastcall Save(THierarchicalStorage * Storage, bool All = false);\r\n  void __fastcall SelectAll(bool Select);\r\n  void __fastcall Import(TStoredSessionList * From, bool OnlySelected, TList * Imported);\r\n  void __fastcall RecryptPasswords(TStrings * RecryptPasswordErrors);\r\n  TSessionData * __fastcall AtSession(int Index)\r\n    { return (TSessionData*)AtObject(Index); }\r\n  void __fastcall SelectSessionsToImport(TStoredSessionList * Dest, bool SSHOnly);\r\n  void __fastcall Cleanup();\r\n  void __fastcall UpdateStaticUsage();\r\n  int __fastcall IndexOf(TSessionData * Data);\r\n  TSessionData * __fastcall FindSame(TSessionData * Data);\r\n  TSessionData * __fastcall NewSession(UnicodeString SessionName, TSessionData * Session);\r\n  void __fastcall NewWorkspace(UnicodeString Name, TList * DataList);\r\n  bool __fastcall IsFolder(const UnicodeString & Name);\r\n  bool __fastcall IsWorkspace(const UnicodeString & Name);\r\n  TSessionData * __fastcall ParseUrl(UnicodeString Url, TOptions * Options, bool & DefaultsOnly,\r\n    UnicodeString * FileName = NULL, bool * ProtocolDefined = NULL, UnicodeString * MaskedUrl = NULL, int Flags = 0);\r\n  bool __fastcall IsUrl(UnicodeString Url);\r\n  bool __fastcall CanLogin(TSessionData * Data);\r\n  void __fastcall GetFolderOrWorkspace(const UnicodeString & Name, TList * List);\r\n  TStrings * __fastcall GetFolderOrWorkspaceList(const UnicodeString & Name);\r\n  TStrings * __fastcall GetWorkspaces();\r\n  bool __fastcall HasAnyWorkspace();\r\n  TSessionData * __fastcall SaveWorkspaceData(TSessionData * Data, int Index);\r\n  virtual __fastcall ~TStoredSessionList();\r\n  __property TSessionData * Sessions[int Index]  = { read=AtSession };\r\n  __property TSessionData * DefaultSettings  = { read=FDefaultSettings, write=SetDefaultSettings };\r\n\r\n  static void __fastcall ImportHostKeys(\r\n    THierarchicalStorage * SourceStorage, THierarchicalStorage * TargetStorage, TStoredSessionList * Sessions, bool OnlySelected);\r\n  static void __fastcall ImportHostKeys(\r\n    const UnicodeString & SourceKey, TStoredSessionList * Sessions, bool OnlySelected);\r\n  static void __fastcall ImportSelectedKnownHosts(TStoredSessionList * Sessions);\r\n  static bool __fastcall OpenHostKeysSubKey(THierarchicalStorage * Storage, bool CanCreate);\r\n\r\nprivate:\r\n  TSessionData * FDefaultSettings;\r\n  bool FReadOnly;\r\n  std::unique_ptr<TStrings> FPendingRemovals;\r\n  void __fastcall SetDefaultSettings(TSessionData * value);\r\n  void __fastcall DoSave(THierarchicalStorage * Storage, bool All,\r\n    bool RecryptPasswordOnly, TStrings * RecryptPasswordErrors);\r\n  void __fastcall DoSave(bool All, bool Explicit, bool RecryptPasswordOnly,\r\n    TStrings * RecryptPasswordErrors);\r\n  void __fastcall DoSave(THierarchicalStorage * Storage,\r\n    TSessionData * Data, bool All, bool RecryptPasswordOnly,\r\n    TSessionData * FactoryDefaults);\r\n  TSessionData * __fastcall ResolveWorkspaceData(TSessionData * Data);\r\n  bool __fastcall IsFolderOrWorkspace(const UnicodeString & Name, bool Workspace);\r\n  TSessionData * __fastcall CheckIsInFolderOrWorkspaceAndResolve(\r\n    TSessionData * Data, const UnicodeString & Name);\r\n  void __fastcall ImportLevelFromFilezilla(_di_IXMLNode Node, const UnicodeString & Path, _di_IXMLNode SettingsNode);\r\n  void __fastcall DoGetFolderOrWorkspace(const UnicodeString & Name, TList * List, bool NoRecrypt);\r\n  static THierarchicalStorage * __fastcall CreateHostKeysStorageForWritting();\r\n};\r\n//---------------------------------------------------------------------------\r\nUnicodeString GetExpandedLogFileName(UnicodeString LogFileName, TDateTime Started, TSessionData * SessionData);\r\nbool __fastcall IsSshProtocol(TFSProtocol FSProtocol);\r\nint __fastcall DefaultPort(TFSProtocol FSProtocol, TFtps Ftps);\r\nbool __fastcall IsIPv6Literal(const UnicodeString & HostName);\r\nUnicodeString __fastcall EscapeIPv6Literal(const UnicodeString & IP);\r\nTFSProtocol NormalizeFSProtocol(TFSProtocol FSProtocol);\r\n//---------------------------------------------------------------------------\r\n#endif\r\n", "//---------------------------------------------------------------------\r\n#include <vcl.h>\r\n#pragma hdrstop\r\n\r\n#include <Dialogs.hpp>\r\n//---------------------------------------------------------------------\r\n#include <Common.h>\r\n#include <CustomWinConfiguration.h>\r\n#include <WinInterface.h>\r\n#include <VCLCommon.h>\r\n#include <TextsWin.h>\r\n#include <HelpWin.h>\r\n#include <CoreMain.h>\r\n#include <PasTools.hpp>\r\n#include <ProgParams.h>\r\n#include <Tools.h>\r\n#include <GUITools.h>\r\n#include <HistoryComboBox.hpp>\r\n#include <Math.hpp>\r\n\r\n#include \"Custom.h\"\r\n//---------------------------------------------------------------------\r\n#pragma link \"PasswordEdit\"\r\n#pragma resource \"*.dfm\"\r\n//---------------------------------------------------------------------\r\n__fastcall TCustomDialog::TCustomDialog(UnicodeString AHelpKeyword)\r\n  : TForm(GetFormOwner())\r\n{\r\n  UseSystemSettings(this);\r\n\r\n  FControlPadding = ScaleByTextHeight(this, 8);\r\n  FPos = ScaleByTextHeight(this, 8);\r\n  FPrePos = FPos;\r\n  FHorizontalMargin = ScaleByTextHeight(this, 8);\r\n  FIndent = FHorizontalMargin;\r\n  FGroupBox = NULL;\r\n\r\n  HelpKeyword = AHelpKeyword;\r\n\r\n  TBorderIcons BI = BorderIcons;\r\n  if (HelpKeyword.IsEmpty())\r\n  {\r\n    BI >> biHelp;\r\n\r\n    OKButton->Left = CancelButton->Left;\r\n    CancelButton->Left = HelpButton->Left;\r\n    HelpButton->Visible = false;\r\n  }\r\n  else\r\n  {\r\n    BI << biHelp;\r\n  }\r\n  BorderIcons = BI;\r\n}\r\n//---------------------------------------------------------------------\r\nbool __fastcall TCustomDialog::Execute()\r\n{\r\n  Changed();\r\n  return (ShowModal() == DefaultResult(this));\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TCustomDialog::DoChange(bool & /*CanSubmit*/)\r\n{\r\n  // noop\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TCustomDialog::Changed()\r\n{\r\n  bool CanSubmit = true;\r\n  DoChange(CanSubmit);\r\n  EnableControl(OKButton, CanSubmit);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TCustomDialog::Change(TObject * /*Sender*/)\r\n{\r\n  Changed();\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TCustomDialog::DoHelp()\r\n{\r\n  FormHelp(this);\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TCustomDialog::HelpButtonClick(TObject * /*Sender*/)\r\n{\r\n  DoHelp();\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TCustomDialog::DoShow()\r\n{\r\n  OKButton->TabOrder = FCount;\r\n  CancelButton->TabOrder = static_cast<short>(FCount + 1);\r\n  HelpButton->TabOrder = static_cast<short>(FCount + 2);\r\n  Changed();\r\n  TForm::DoShow();\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TCustomDialog::DoValidate()\r\n{\r\n  // noop\r\n}\r\n//---------------------------------------------------------------------------\r\nbool __fastcall TCustomDialog::CloseQuery()\r\n{\r\n  if (ModalResult == DefaultResult(this))\r\n  {\r\n    DoValidate();\r\n  }\r\n  return TForm::CloseQuery();\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TCustomDialog::RemoveCancelButton()\r\n{\r\n  CancelButton->Visible = false;\r\n  OKButton->Left = CancelButton->Left;\r\n  OKButton->Cancel = true;\r\n  DebugAssert(OKButton->Width == CancelButton->Width);\r\n  DebugAssert(OKButton->Top == CancelButton->Top);\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TCustomDialog::AddDialogButton(TButton * Button)\r\n{\r\n  Button->Parent = this;\r\n  Button->Top = OKButton->Top;\r\n  Button->Left = FHorizontalMargin;\r\n  Button->Height = OKButton->Height;\r\n  AddWinControl(Button);\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TCustomDialog::AddImage(const UnicodeString & ImageName)\r\n{\r\n  TImage * Image = new TImage(this);\r\n  Image->Name = L\"Image\";\r\n  Image->Parent = GetDefaultParent();\r\n  LoadDialogImage(Image, ImageName);\r\n  Image->SetBounds(FIndent, FPos + ScaleByTextHeight(this, 3), Image->Picture->Width, Image->Picture->Height);\r\n  FIndent += Image->Width + ScaleByTextHeight(this, 12);\r\n}\r\n//---------------------------------------------------------------------------\r\nint __fastcall TCustomDialog::GetMaxControlWidth(TControl * Control)\r\n{\r\n  return GetDefaultParent()->ClientWidth - Control->Left - FHorizontalMargin;\r\n}\r\n//---------------------------------------------------------------------------\r\nTWinControl * __fastcall TCustomDialog::GetDefaultParent()\r\n{\r\n  return (FGroupBox != NULL) ? FGroupBox : static_cast<TWinControl *>(this);\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TCustomDialog::AdjustHeight(TControl * Control)\r\n{\r\n  FPos = Control->Top + Control->Height + FControlPadding;\r\n  int Delta = (FPos - FPrePos);\r\n  ClientHeight = ClientHeight + Delta;\r\n  if (FGroupBox != NULL)\r\n  {\r\n    FGroupBox->Height = FGroupBox->Height + Delta;\r\n  }\r\n  FPrePos = FPos;\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TCustomDialog::AddWinControl(TWinControl * Control)\r\n{\r\n  Control->TabOrder = FCount;\r\n  FCount++;\r\n}\r\n//---------------------------------------------------------------------------\r\nTCheckBox * __fastcall TCustomDialog::CreateAndAddCheckBox(const UnicodeString & Caption)\r\n{\r\n  TCheckBox * CheckBox = new TCheckBox(this);\r\n  CheckBox->Caption = Caption;\r\n  AddButtonControl(CheckBox);\r\n  return CheckBox;\r\n}\r\n//---------------------------------------------------------------------------\r\nTLabel * __fastcall TCustomDialog::CreateLabel(UnicodeString Label)\r\n{\r\n  TLabel * Result = new TLabel(this);\r\n  Result->Caption = Label;\r\n  return Result;\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TCustomDialog::AddEditLikeControl(TWinControl * Edit, TLabel * Label, bool OneLine)\r\n{\r\n  Edit->Parent = GetDefaultParent();\r\n  // this updates Height property to real value\r\n  Edit->HandleNeeded();\r\n\r\n  if (Label != NULL)\r\n  {\r\n    Label->Parent = GetDefaultParent();\r\n    Label->Left = FIndent;\r\n\r\n    if (OneLine)\r\n    {\r\n      DebugAssert(Edit->Height > Label->Height);\r\n      Label->Top = FPos + ((Edit->Height - Label->Height) / 2);\r\n    }\r\n    else\r\n    {\r\n      Label->Top = FPos;\r\n\r\n      FPos += Label->Height + ScaleByTextHeight(this, 4);\r\n    }\r\n  }\r\n\r\n  Edit->Top = FPos;\r\n  if (OneLine)\r\n  {\r\n    Edit->Left = GetDefaultParent()->ClientWidth - FHorizontalMargin - Edit->Width;\r\n  }\r\n  else\r\n  {\r\n    Edit->Left = FIndent;\r\n    Edit->Width = GetMaxControlWidth(Edit);\r\n  }\r\n\r\n  AdjustHeight(Edit);\r\n\r\n  if (Label != NULL)\r\n  {\r\n    if (Label->FocusControl == NULL)\r\n    {\r\n      Label->FocusControl = Edit;\r\n    }\r\n    else\r\n    {\r\n      DebugAssert(Label->FocusControl == Edit);\r\n    }\r\n  }\r\n\r\n  AddWinControl(Edit);\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TCustomDialog::AddEdit(TCustomEdit * Edit, TLabel * Label, bool OneLine)\r\n{\r\n  AddEditLikeControl(Edit, Label, OneLine);\r\n\r\n  TEdit * PublicEdit = reinterpret_cast<TEdit *>(Edit);\r\n  if (PublicEdit->OnChange == NULL)\r\n  {\r\n    PublicEdit->OnChange = Change;\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TCustomDialog::SetUpComboBox(TCustomCombo * Combo, TStrings * Items, bool OneLine)\r\n{\r\n  if (Items != NULL)\r\n  {\r\n    Combo->Items = Items;\r\n  }\r\n\r\n  if (OneLine)\r\n  {\r\n    int Width = 0;\r\n    for (int Index = 0; Index < Combo->Items->Count; Index++)\r\n    {\r\n      Width = Max(Width, Combo->Canvas->TextWidth(Combo->Items->Strings[Index]));\r\n    }\r\n\r\n    Width += ScaleByTextHeight(Combo, 4 + 16 + 14);\r\n    Width = Max(Width, HelpButton->Width);\r\n\r\n    Combo->Width = Width;\r\n    Combo->Left = GetDefaultParent()->ClientWidth - FHorizontalMargin - Width;\r\n  }\r\n\r\n  TComboBox * PublicCombo = reinterpret_cast<TComboBox *>(Combo);\r\n  if (PublicCombo->OnChange == NULL)\r\n  {\r\n    PublicCombo->OnChange = Change;\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TCustomDialog::AddComboBox(TCustomCombo * Combo, TLabel * Label, TStrings * Items, bool OneLine)\r\n{\r\n  AddEditLikeControl(Combo, Label, OneLine);\r\n\r\n  SetUpComboBox(Combo, Items, OneLine);\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TCustomDialog::AddShortCutComboBox(TComboBox * Combo, TLabel * Label, const TShortCuts & ShortCuts)\r\n{\r\n  AddEditLikeControl(Combo, Label, true);\r\n  InitializeShortCutCombo(Combo, ShortCuts);\r\n  SetUpComboBox(Combo, NULL, true);\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TCustomDialog::ScaleButtonControl(TButtonControl * Control)\r\n{\r\n  // this updates Height property to real value\r\n  Control->HandleNeeded();\r\n  // buttons do not scale with text on their own\r\n  Control->Height = ScaleByTextHeight(Control, Control->Height);\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TCustomDialog::AddButtonControl(TButtonControl * Control)\r\n{\r\n  Control->Parent = GetDefaultParent();\r\n  Control->Left = FIndent + ScaleByTextHeight(this, 6);\r\n  Control->Top = FPos;\r\n  Control->Width = GetMaxControlWidth(Control);\r\n  ScaleButtonControl(Control);\r\n\r\n  AdjustHeight(Control);\r\n\r\n  AddWinControl(Control);\r\n\r\n  TCheckBox * PublicControl = reinterpret_cast<TCheckBox *>(Control);\r\n  if (PublicControl->OnClick == NULL)\r\n  {\r\n    PublicControl->OnClick = Change;\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TCustomDialog::AddText(TLabel * Label)\r\n{\r\n  Label->Parent = GetDefaultParent();\r\n\r\n  Label->WordWrap = true;\r\n  Label->Left = FIndent;\r\n  Label->Width = GetMaxControlWidth(Label);\r\n  Label->Top = FPos;\r\n  Label->ShowAccelChar = false;\r\n\r\n  TRect TextRect;\r\n  SetRect(&TextRect, 0, 0, Label->Width, 0);\r\n  DrawText(Label->Canvas->Handle, Label->Caption.c_str(), Label->Caption.Length() + 1, &TextRect,\r\n    DT_EXPANDTABS | DT_CALCRECT | DT_WORDBREAK | DT_NOPREFIX |\r\n    Label->DrawTextBiDiModeFlagsReadingOnly());\r\n  Label->Height = TextRect.Height();\r\n\r\n  AdjustHeight(Label);\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TCustomDialog::AddText(TStaticText * Label)\r\n{\r\n  Label->Parent = GetDefaultParent();\r\n\r\n  Label->Left = FIndent;\r\n  Label->Width = GetMaxControlWidth(Label);\r\n  Label->Top = FPos;\r\n  Label->ShowAccelChar = false;\r\n\r\n  AdjustHeight(Label);\r\n  AddWinControl(Label);\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TCustomDialog::AddSeparator()\r\n{\r\n  TBevel * Bevel = new TBevel(this);\r\n  Bevel->Parent = GetDefaultParent();\r\n\r\n  Bevel->Left = FIndent;\r\n  Bevel->Top = FPos;\r\n  Bevel->Height = 2;\r\n  Bevel->Width = GetMaxControlWidth(Bevel);\r\n\r\n  AdjustHeight(Bevel);\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TCustomDialog::StartGroup(const UnicodeString & Caption)\r\n{\r\n  if (FGroupBox != NULL)\r\n  {\r\n    FIndent = FGroupBox->Left;\r\n    FPos = FGroupBox->Top + FGroupBox->Height + FControlPadding;\r\n    FPrePos = FPos;\r\n    FGroupBox = NULL;\r\n  }\r\n\r\n  TGroupBox * GroupBox = new TGroupBox(this);\r\n  GroupBox->Parent = this;\r\n  GroupBox->Caption = Caption;\r\n\r\n  GroupBox->Left = FIndent;\r\n  GroupBox->Top = FPos;\r\n  GroupBox->Height = ScaleByTextHeight(GroupBox, 20);\r\n  GroupBox->Width = GetMaxControlWidth(GroupBox);\r\n\r\n  AdjustHeight(GroupBox);\r\n\r\n  AddWinControl(GroupBox);\r\n\r\n  FPos = ScaleByTextHeight(this, 16);\r\n  FPrePos = FPos;\r\n  FIndent = FHorizontalMargin;\r\n\r\n  FGroupBox = GroupBox;\r\n}\r\n//---------------------------------------------------------------------------\r\n//---------------------------------------------------------------------------\r\nclass TSaveSessionDialog : public TCustomDialog\r\n{\r\npublic:\r\n  __fastcall TSaveSessionDialog(TComponent* AOwner);\r\n  void __fastcall Init(bool CanSavePassword, bool NotRecommendedSavingPassword,\r\n    TStrings * AdditionalFolders);\r\n\r\n  bool __fastcall Execute(UnicodeString & SessionName, bool & SavePassword,\r\n    bool & CreateShortcut, const UnicodeString & OriginalSessionName);\r\n\r\nprotected:\r\n  virtual void __fastcall DoValidate();\r\n  virtual void __fastcall DoChange(bool & CanSubmit);\r\n\r\nprivate:\r\n  UnicodeString FOriginalSessionName;\r\n  TEdit * SessionNameEdit;\r\n  TComboBox * FolderCombo;\r\n  TCheckBox * SavePasswordCheck;\r\n  TCheckBox * CreateShortcutCheck;\r\n  UnicodeString FRootFolder;\r\n\r\n  UnicodeString __fastcall GetSessionName();\r\n};\r\n//---------------------------------------------------------------------------\r\n// Need to have an Owner argument for SafeFormCreate\r\n__fastcall TSaveSessionDialog::TSaveSessionDialog(TComponent* /*AOwner*/) :\r\n  TCustomDialog(HELP_SESSION_SAVE)\r\n{\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSaveSessionDialog::Init(bool CanSavePassword,\r\n  bool NotRecommendedSavingPassword, TStrings * AdditionalFolders)\r\n{\r\n  Caption = LoadStr(SAVE_SESSION_CAPTION);\r\n\r\n  SessionNameEdit = new TEdit(this);\r\n  AddEdit(SessionNameEdit, CreateLabel(LoadStr(SAVE_SESSION_PROMPT)));\r\n\r\n  FRootFolder = LoadStr(SAVE_SESSION_ROOT_FOLDER2);\r\n  std::unique_ptr<TStringList> Folders(new TStringList());\r\n\r\n  if (AdditionalFolders != NULL)\r\n  {\r\n    Folders->AddStrings(AdditionalFolders);\r\n  }\r\n\r\n  for (int Index = 0; Index < StoredSessions->Count; Index++)\r\n  {\r\n    TSessionData * Data = StoredSessions->Sessions[Index];\r\n    if (!Data->Special && !Data->IsWorkspace)\r\n    {\r\n      UnicodeString Folder = Data->FolderName;\r\n      if (!Folder.IsEmpty() && Folders->IndexOf(Folder) < 0)\r\n      {\r\n        Folders->Add(Folder);\r\n      }\r\n    }\r\n  }\r\n\r\n  DebugAssert(!Folders->CaseSensitive);\r\n  Folders->Sort();\r\n\r\n  FolderCombo = new TComboBox(this);\r\n  AddComboBox(FolderCombo, CreateLabel(LoadStr(SAVE_SESSION_FOLDER)));\r\n  FolderCombo->DropDownCount = Max(FolderCombo->DropDownCount, 16);\r\n  FolderCombo->Items->Add(FRootFolder);\r\n  FolderCombo->Items->AddStrings(Folders.get());\r\n\r\n  SavePasswordCheck = CreateAndAddCheckBox(\r\n    LoadStr(NotRecommendedSavingPassword ? SAVE_SESSION_PASSWORD :\r\n      (CustomWinConfiguration->UseMasterPassword ? SAVE_SESSION_PASSWORD_MASTER : SAVE_SESSION_PASSWORD_RECOMMENDED)));\r\n\r\n  CreateShortcutCheck = CreateAndAddCheckBox(LoadStr(SAVE_SITE_WORKSPACE_SHORTCUT));\r\n\r\n  EnableControl(SavePasswordCheck, CanSavePassword);\r\n}\r\n//---------------------------------------------------------------------------\r\nbool __fastcall TSaveSessionDialog::Execute(\r\n  UnicodeString & SessionName, bool & SavePassword, bool & CreateShortcut,\r\n  const UnicodeString & OriginalSessionName)\r\n{\r\n  FOriginalSessionName = OriginalSessionName;\r\n  SessionNameEdit->Text = TSessionData::ExtractLocalName(SessionName);\r\n  UnicodeString Folder = TSessionData::ExtractFolderName(SessionName);\r\n  if (Folder.IsEmpty())\r\n  {\r\n    FolderCombo->Text = FRootFolder;\r\n  }\r\n  else\r\n  {\r\n    FolderCombo->Text = Folder;\r\n  }\r\n  SavePasswordCheck->Checked = SavePassword;\r\n  CreateShortcutCheck->Checked = CreateShortcut;\r\n  bool Result = TCustomDialog::Execute();\r\n  if (Result)\r\n  {\r\n    SessionName = GetSessionName();\r\n    SavePassword = SavePasswordCheck->Checked;\r\n    CreateShortcut = CreateShortcutCheck->Checked;\r\n  }\r\n  return Result;\r\n}\r\n//---------------------------------------------------------------------------\r\nUnicodeString __fastcall TSaveSessionDialog::GetSessionName()\r\n{\r\n  UnicodeString Folder;\r\n  if (FolderCombo->Text != FRootFolder)\r\n  {\r\n    Folder = FolderCombo->Text;\r\n  }\r\n  return TSessionData::ComposePath(Folder, SessionNameEdit->Text);\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSaveSessionDialog::DoValidate()\r\n{\r\n  TSessionData::ValidateName(SessionNameEdit->Text);\r\n  SessionNameValidate(GetSessionName(), FOriginalSessionName);\r\n\r\n  UnicodeString Folder = TSessionData::ExtractFolderName(GetSessionName());\r\n  if (!Folder.IsEmpty() && StoredSessions->IsWorkspace(Folder))\r\n  {\r\n    throw Exception(FMTLOAD(WORKSPACE_NOT_FOLDER, (Folder)));\r\n  }\r\n\r\n  if (SavePasswordCheck->Enabled && SavePasswordCheck->Checked &&\r\n      CustomWinConfiguration->UseMasterPassword)\r\n  {\r\n    CustomWinConfiguration->AskForMasterPasswordIfNotSet();\r\n  }\r\n\r\n  TCustomDialog::DoValidate();\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSaveSessionDialog::DoChange(bool & CanSubmit)\r\n{\r\n  CanSubmit = !SessionNameEdit->Text.IsEmpty();\r\n  TCustomDialog::DoChange(CanSubmit);\r\n}\r\n//---------------------------------------------------------------------------\r\nTSessionData * __fastcall DoSaveSession(TSessionData * SessionData,\r\n  TSessionData * OriginalSession, bool ForceDialog,\r\n  TStrings * AdditionalFolders)\r\n{\r\n  bool SavePassword = false;\r\n  bool * PSavePassword;\r\n  bool NotRecommendedSavingPassword =\r\n    !CustomWinConfiguration->UseMasterPassword &&\r\n    !SameText(SessionData->UserName, AnonymousUserName);\r\n\r\n  if (Configuration->DisablePasswordStoring ||\r\n      !SessionData->HasAnySessionPassword())\r\n  {\r\n    PSavePassword = NULL;\r\n  }\r\n  else\r\n  {\r\n    PSavePassword = &SavePassword;\r\n    SavePassword =\r\n      ((OriginalSession != NULL) && OriginalSession->HasAnySessionPassword()) ||\r\n      !NotRecommendedSavingPassword;\r\n  }\r\n\r\n  UnicodeString SessionName = SessionData->SessionName;\r\n\r\n  bool Result;\r\n  bool CreateShortcut = false;\r\n  if (!ForceDialog && ((PSavePassword == NULL) || SavePassword))\r\n  {\r\n    // This is probably here to ask before session is started saving.\r\n    // Otherwise we would ask implicitly, when saving passwords, but at that moment,\r\n    // part of the site is already saved and when the user cancel the prompt it's too late.\r\n    CustomWinConfiguration->AskForMasterPasswordIfNotSetAndNeededToPersistSessionData(SessionData);\r\n    Result = true;\r\n  }\r\n  else\r\n  {\r\n    // This can be a standalone dialog when used with save URL (from GetLoginData)\r\n    TSaveSessionDialog * Dialog = SafeFormCreate<TSaveSessionDialog>();\r\n    try\r\n    {\r\n      Dialog->Init((PSavePassword != NULL), NotRecommendedSavingPassword, AdditionalFolders);\r\n      Result = Dialog->Execute(SessionName, SavePassword, CreateShortcut, SessionData->Name);\r\n    }\r\n    __finally\r\n    {\r\n      delete Dialog;\r\n    }\r\n  }\r\n\r\n  TSessionData * NewSession = NULL;\r\n  if (Result)\r\n  {\r\n    if ((PSavePassword != NULL) && !SavePassword)\r\n    {\r\n      SessionData->ClearSessionPasswords();\r\n    }\r\n\r\n    NewSession =\r\n      StoredSessions->NewSession(SessionName, SessionData);\r\n    // modified only, explicit\r\n    StoredSessions->Save(false, true);\r\n    if (!SessionData->HostKey.IsEmpty())\r\n    {\r\n      SessionData->CacheHostKeyIfNotCached();\r\n    }\r\n\r\n    if (CreateShortcut)\r\n    {\r\n      TOperationVisualizer Visualizer;\r\n      UnicodeString AdditionalParams =\r\n        TProgramParams::FormatSwitch(DESKTOP_SWITCH) + L\" \" +\r\n        TProgramParams::FormatSwitch(UPLOAD_IF_ANY_SWITCH);\r\n      CreateDesktopSessionShortCut(SessionName, L\"\", AdditionalParams, -1, SITE_ICON);\r\n    }\r\n  }\r\n\r\n  return NewSession;\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall SessionNameValidate(const UnicodeString & Text,\r\n  const UnicodeString & OriginalName)\r\n{\r\n  TSessionData::ValidatePath(Text);\r\n\r\n  DebugAssert(StoredSessions);\r\n  TSessionData * Data = (TSessionData *)StoredSessions->FindByName(Text);\r\n  if (Data && Data->Special)\r\n  {\r\n    MessageDialog(FMTLOAD(CANNOT_OVERWRITE_SPECIAL_SESSION, (Text)),\r\n      qtError, qaOK, HELP_NONE);\r\n    Abort();\r\n  }\r\n  else if ((Data != NULL) && !Data->IsSameName(OriginalName) &&\r\n    MessageDialog(MainInstructions(FMTLOAD(CONFIRM_OVERWRITE_SESSION, (Text))),\r\n      qtConfirmation, qaYes | qaNo, HELP_SESSION_SAVE_OVERWRITE) != qaYes)\r\n  {\r\n    Abort();\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\n//---------------------------------------------------------------------------\r\nclass TSaveWorkspaceDialog : public TCustomDialog\r\n{\r\npublic:\r\n  __fastcall TSaveWorkspaceDialog(bool CanSavePasswords,\r\n    bool NotRecommendedSavingPasswords);\r\n\r\n  bool __fastcall Execute(\r\n    UnicodeString & WorkspaceName, bool & SavePasswords, bool & CreateShortcut,\r\n    bool & EnableAutoSave);\r\n\r\nprotected:\r\n  virtual void __fastcall DoValidate();\r\n  virtual void __fastcall DoChange(bool & CanSubmit);\r\n\r\nprivate:\r\n  TComboBox * WorkspaceNameCombo;\r\n  TCheckBox * SavePasswordsCheck;\r\n  TCheckBox * CreateShortcutCheck;\r\n  TCheckBox * EnableAutoSaveCheck;\r\n};\r\n//---------------------------------------------------------------------------\r\n__fastcall TSaveWorkspaceDialog::TSaveWorkspaceDialog(\r\n    bool CanSavePasswords, bool NotRecommendedSavingPasswords) :\r\n  TCustomDialog(HELP_WORKSPACE_SAVE)\r\n{\r\n  Caption = LoadStr(SAVE_WORKSPACE_CAPTION);\r\n\r\n  WorkspaceNameCombo = new TComboBox(this);\r\n  WorkspaceNameCombo->AutoComplete = false;\r\n  AddComboBox(WorkspaceNameCombo, CreateLabel(LoadStr(SAVE_WORKSPACE_PROMPT)));\r\n  WorkspaceNameCombo->DropDownCount = Max(WorkspaceNameCombo->DropDownCount, 16);\r\n\r\n  std::unique_ptr<TStrings> Workspaces(StoredSessions->GetWorkspaces());\r\n  WorkspaceNameCombo->Items->AddStrings(Workspaces.get());\r\n\r\n  SavePasswordsCheck = CreateAndAddCheckBox(\r\n    LoadStr(NotRecommendedSavingPasswords ? SAVE_WORKSPACE_PASSWORDS :\r\n      (CustomWinConfiguration->UseMasterPassword ?\r\n        SAVE_WORKSPACE_PASSWORDS_MASTER : SAVE_WORKSPACE_PASSWORDS_RECOMMENDED)));\r\n\r\n  EnableControl(SavePasswordsCheck, CanSavePasswords);\r\n\r\n  CreateShortcutCheck = CreateAndAddCheckBox(LoadStr(SAVE_SITE_WORKSPACE_SHORTCUT));\r\n\r\n  EnableAutoSaveCheck = CreateAndAddCheckBox(LoadStr(SAVE_WORKSPACE_AUTO));\r\n}\r\n//---------------------------------------------------------------------------\r\nbool __fastcall TSaveWorkspaceDialog::Execute(\r\n  UnicodeString & WorkspaceName, bool & SavePasswords, bool & CreateShortcut,\r\n  bool & EnableAutoSave)\r\n{\r\n  WorkspaceNameCombo->Text = WorkspaceName;\r\n  SavePasswordsCheck->Checked = SavePasswords;\r\n  CreateShortcutCheck->Checked = CreateShortcut;\r\n  EnableAutoSaveCheck->Checked = EnableAutoSave;\r\n  bool Result = TCustomDialog::Execute();\r\n  if (Result)\r\n  {\r\n    WorkspaceName = WorkspaceNameCombo->Text;\r\n    SavePasswords = SavePasswordsCheck->Checked;\r\n    CreateShortcut = CreateShortcutCheck->Checked;\r\n    EnableAutoSave = EnableAutoSaveCheck->Checked;\r\n  }\r\n  return Result;\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSaveWorkspaceDialog::DoValidate()\r\n{\r\n  TSessionData::ValidateName(WorkspaceNameCombo->Text);\r\n\r\n  if (StoredSessions->IsFolder(WorkspaceNameCombo->Text))\r\n  {\r\n    throw Exception(FMTLOAD(FOLDER_NOT_WORKSPACE, (WorkspaceNameCombo->Text)));\r\n  }\r\n\r\n  if (SavePasswordsCheck->Enabled && SavePasswordsCheck->Checked &&\r\n      CustomWinConfiguration->UseMasterPassword)\r\n  {\r\n    CustomWinConfiguration->AskForMasterPasswordIfNotSet();\r\n  }\r\n\r\n  TCustomDialog::DoValidate();\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSaveWorkspaceDialog::DoChange(bool & CanSubmit)\r\n{\r\n  CanSubmit = !WorkspaceNameCombo->Text.IsEmpty();\r\n\r\n  TCustomDialog::DoChange(CanSubmit);\r\n}\r\n//---------------------------------------------------------------------------\r\nbool __fastcall DoSaveWorkspaceDialog(UnicodeString & WorkspaceName,\r\n  bool * SavePasswords, bool NotRecommendedSavingPasswords,\r\n  bool & CreateShortcut, bool & EnableAutoSave)\r\n{\r\n  std::unique_ptr<TSaveWorkspaceDialog> Dialog(\r\n    new TSaveWorkspaceDialog((SavePasswords != NULL), NotRecommendedSavingPasswords));\r\n\r\n  bool Dummy = false;\r\n  if (SavePasswords == NULL)\r\n  {\r\n    SavePasswords = &Dummy;\r\n  }\r\n  return\r\n    Dialog->Execute(\r\n      WorkspaceName, *SavePasswords, CreateShortcut, EnableAutoSave);\r\n}\r\n//---------------------------------------------------------------------------\r\n//---------------------------------------------------------------------------\r\nclass TShortCutDialog : public TCustomDialog\r\n{\r\npublic:\r\n  __fastcall TShortCutDialog(const TShortCuts & ShortCuts, UnicodeString HelpKeyword);\r\n\r\n  bool __fastcall Execute(TShortCut & ShortCut);\r\n\r\nprivate:\r\n  TComboBox * ShortCutCombo;\r\n};\r\n//---------------------------------------------------------------------------\r\n__fastcall TShortCutDialog::TShortCutDialog(const TShortCuts & ShortCuts, UnicodeString HelpKeyword) :\r\n  TCustomDialog(HelpKeyword)\r\n{\r\n  Caption = LoadStr(SHORTCUT_CAPTION);\r\n\r\n  ShortCutCombo = new TComboBox(this);\r\n  AddShortCutComboBox(ShortCutCombo, CreateLabel(LoadStr(SHORTCUT_LABEL)), ShortCuts);\r\n}\r\n//---------------------------------------------------------------------------\r\nbool __fastcall TShortCutDialog::Execute(TShortCut & ShortCut)\r\n{\r\n  SetShortCutCombo(ShortCutCombo, ShortCut);\r\n  bool Result = TCustomDialog::Execute();\r\n  if (Result)\r\n  {\r\n    ShortCut = GetShortCutCombo(ShortCutCombo);\r\n  }\r\n  return Result;\r\n}\r\n//---------------------------------------------------------------------------\r\nbool __fastcall DoShortCutDialog(TShortCut & ShortCut,\r\n  const TShortCuts & ShortCuts, UnicodeString HelpKeyword)\r\n{\r\n  bool Result;\r\n  TShortCutDialog * Dialog = new TShortCutDialog(ShortCuts, HelpKeyword);\r\n  try\r\n  {\r\n    Result = Dialog->Execute(ShortCut);\r\n  }\r\n  __finally\r\n  {\r\n    delete Dialog;\r\n  }\r\n  return Result;\r\n}\r\n//---------------------------------------------------------------------------\r\n//---------------------------------------------------------------------------\r\nclass TRemoteMoveDialog : public TCustomDialog\r\n{\r\npublic:\r\n  __fastcall TRemoteMoveDialog(bool Multi);\r\n\r\n  bool __fastcall Execute(UnicodeString & Target, UnicodeString & FileMask);\r\n\r\nprotected:\r\n  DYNAMIC void __fastcall DoShow();\r\n  virtual void __fastcall DoValidate();\r\n  UnicodeString __fastcall GetFileMask();\r\n\r\nprivate:\r\n  THistoryComboBox * Combo;\r\n  bool FMulti;\r\n};\r\n//---------------------------------------------------------------------------\r\n__fastcall TRemoteMoveDialog::TRemoteMoveDialog(bool Multi) :\r\n  TCustomDialog(HELP_REMOTE_MOVE)\r\n{\r\n  Caption = LoadStr(REMOTE_MOVE_TITLE);\r\n  // The same as TRemoteTransferDialog\r\n  ClientWidth = ScaleByTextHeight(this, 420);\r\n\r\n  FMulti = Multi;\r\n\r\n  AddImage(L\"Move To\");\r\n\r\n  Combo = new THistoryComboBox(this);\r\n  Combo->AutoComplete = false;\r\n  AddComboBox(Combo, CreateLabel(LoadStr(REMOTE_TRANSFER_PROMPT2)));\r\n}\r\n//---------------------------------------------------------------------------\r\nbool __fastcall TRemoteMoveDialog::Execute(UnicodeString & Target, UnicodeString & FileMask)\r\n{\r\n  Combo->Items = CustomWinConfiguration->History[L\"RemoteTarget\"];\r\n  Combo->Text = UnixIncludeTrailingBackslash(Target) + FileMask;\r\n  bool Result = TCustomDialog::Execute();\r\n  if (Result)\r\n  {\r\n    Target = UnixExtractFilePath(Combo->Text);\r\n    FileMask = GetFileMask();\r\n    Combo->SaveToHistory();\r\n    CustomWinConfiguration->History[L\"RemoteTarget\"] = Combo->Items;\r\n  }\r\n  return Result;\r\n}\r\n//---------------------------------------------------------------------------\r\nUnicodeString __fastcall TRemoteMoveDialog::GetFileMask()\r\n{\r\n  return UnixExtractFileName(Combo->Text);\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TRemoteMoveDialog::DoShow()\r\n{\r\n  TCustomDialog::DoShow();\r\n  InstallPathWordBreakProc(Combo);\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TRemoteMoveDialog::DoValidate()\r\n{\r\n  if (!IsFileNameMask(GetFileMask()) && FMulti)\r\n  {\r\n    UnicodeString Message =\r\n      FormatMultiFilesToOneConfirmation(Combo->Text, true);\r\n    if (MessageDialog(Message, qtConfirmation, qaOK | qaCancel, HELP_NONE) == qaCancel)\r\n    {\r\n      Abort();\r\n    }\r\n  }\r\n\r\n  TCustomDialog::DoValidate();\r\n}\r\n//---------------------------------------------------------------------------\r\nbool __fastcall DoRemoteMoveDialog(bool Multi, UnicodeString & Target, UnicodeString & FileMask)\r\n{\r\n  std::unique_ptr<TRemoteMoveDialog> Dialog(new TRemoteMoveDialog(Multi));\r\n  return Dialog->Execute(Target, FileMask);\r\n}\r\n//---------------------------------------------------------------------------\r\n//---------------------------------------------------------------------------\r\nclass TCustomCommandOptionsDialog : public TCustomDialog\r\n{\r\npublic:\r\n  __fastcall TCustomCommandOptionsDialog(\r\n    const TCustomCommandType * Command, TStrings * CustomCommandOptions, unsigned int Flags,\r\n    TCustomCommand * CustomCommandForOptions, const UnicodeString & Site, const TShortCuts * ShortCuts);\r\n\r\n  bool __fastcall Execute(TShortCut * ShortCut);\r\n\r\nprotected:\r\n  virtual void __fastcall DoHelp();\r\n  DYNAMIC void __fastcall DoShow();\r\n\r\nprivate:\r\n  const TCustomCommandType * FCommand;\r\n  TStrings * FCustomCommandOptions;\r\n  std::vector<TControl *> FControls;\r\n  std::vector<std::vector<UnicodeString> > FValues;\r\n  unsigned int FFlags;\r\n  UnicodeString FSite;\r\n  TComboBox * FShortCutCombo;\r\n\r\n  UnicodeString __fastcall HistoryKey(const TCustomCommandType::TOption & Option);\r\n  THistoryComboBox * __fastcall CreateHistoryComboBox(const TCustomCommandType::TOption & Option, const UnicodeString & Value);\r\n  void __fastcall BrowseButtonClick(TObject * Sender);\r\n  void __fastcall LinkLabelClick(TObject * Sender);\r\n  UnicodeString __fastcall SaveHistoryComboBoxValue(TControl * Control, const TCustomCommandType::TOption & Option);\r\n  void __fastcall AddOptionComboBox(\r\n    TComboBox * ComboBox, const UnicodeString & Value, const TCustomCommandType::TOption & Option,\r\n    std::vector<UnicodeString> & Values);\r\n  UnicodeString __fastcall GetComboBoxValue(TControl * Control, const UnicodeString & Default);\r\n  int __fastcall GetOptionIndex(TControl * Control);\r\n  int __fastcall GetControlIndex(TControl * Control);\r\n};\r\n//---------------------------------------------------------------------------\r\n__fastcall TCustomCommandOptionsDialog::TCustomCommandOptionsDialog(\r\n    const TCustomCommandType * Command, TStrings * CustomCommandOptions,\r\n    unsigned int Flags, TCustomCommand * CustomCommandForOptions,\r\n    const UnicodeString & Site, const TShortCuts * ShortCuts) :\r\n  TCustomDialog(HELP_EXTENSION_OPTIONS)\r\n{\r\n  FCommand = Command;\r\n  FFlags = Flags;\r\n  FCustomCommandOptions = CustomCommandOptions;\r\n  FSite = Site;\r\n  Caption = StripEllipsis(StripHotkey(FCommand->Name));\r\n  Width = ScaleByTextHeight(this, 400);\r\n\r\n  bool HasGroups = false;\r\n  int ControlIndex = 0;\r\n  for (int OptionIndex = 0; OptionIndex < FCommand->OptionsCount; OptionIndex++)\r\n  {\r\n    const TCustomCommandType::TOption & Option = FCommand->GetOption(OptionIndex);\r\n\r\n    if ((Option.Flags & FFlags) != 0)\r\n    {\r\n      UnicodeString OptionKey = FCommand->GetOptionKey(Option, FSite);\r\n      UnicodeString Value;\r\n      if ((CustomCommandForOptions != NULL) &&\r\n          Option.HasPatterns(CustomCommandForOptions))\r\n      {\r\n        Value = CustomCommandForOptions->Complete(Option.Default, true);\r\n      }\r\n      else\r\n      {\r\n        if (FCustomCommandOptions->IndexOfName(OptionKey) >= 0)\r\n        {\r\n          Value = FCustomCommandOptions->Values[OptionKey];\r\n        }\r\n        else\r\n        {\r\n          Value = Option.Default;\r\n        }\r\n      }\r\n\r\n      int Tag = (OptionIndex << 16) + ControlIndex;\r\n      TControl * Control = NULL;\r\n      std::vector<UnicodeString> Values;\r\n      if (Option.Kind == TCustomCommandType::okUnknown)\r\n      {\r\n        Control = NULL;\r\n      }\r\n      else if (Option.Kind == TCustomCommandType::okLabel)\r\n      {\r\n        TLabel * Label = CreateLabel(Option.Caption);\r\n        AddText(Label);\r\n        Control = Label;\r\n      }\r\n      else if (Option.Kind == TCustomCommandType::okLink)\r\n      {\r\n        TStaticText * Label = new TStaticText(this);\r\n        Label->Caption = Option.Caption;\r\n        if (IsHttpOrHttpsUrl(Label->Caption))\r\n        {\r\n          Label->Caption = SecureUrl(Label->Caption);\r\n          LinkLabel(Label);\r\n          Label->TabStop = true;\r\n        }\r\n        else if (!Option.Default.IsEmpty() && IsHttpOrHttpsUrl(Option.Default))\r\n        {\r\n          Label->OnClick = LinkLabelClick;\r\n          LinkLabel(Label);\r\n          Label->TabStop = true;\r\n        }\r\n        else\r\n        {\r\n          // keep it plain text, as we have no URL\r\n        }\r\n        AddText(Label);\r\n        Control = Label;\r\n      }\r\n      else if (Option.Kind == TCustomCommandType::okGroup)\r\n      {\r\n        StartGroup(Option.Caption);\r\n        HasGroups = true;\r\n      }\r\n      else if (Option.Kind == TCustomCommandType::okSeparator)\r\n      {\r\n        AddSeparator();\r\n      }\r\n      else if (Option.Kind == TCustomCommandType::okTextBox)\r\n      {\r\n        Control = CreateHistoryComboBox(Option, Value);\r\n      }\r\n      else if (Option.Kind == TCustomCommandType::okFile)\r\n      {\r\n        THistoryComboBox * ComboBox = CreateHistoryComboBox(Option, Value);\r\n        TButton * Button = new TButton(this);\r\n        Button->Parent = GetDefaultParent();\r\n        Button->Width = HelpButton->Width;\r\n        Button->Left = GetDefaultParent()->ClientWidth - Button->Width - HorizontalMargin;\r\n        ComboBox->Width = Button->Left - ComboBox->Left - ScaleByTextHeight(this, 6);\r\n        Button->Top = ComboBox->Top - ScaleByTextHeight(this, 2);\r\n        Button->Tag = Tag;\r\n        Button->Caption = LoadStr(EXTENSION_OPTIONS_BROWSE);\r\n        Button->OnClick = BrowseButtonClick;\r\n        ScaleButtonControl(Button);\r\n        AddWinControl(Button);\r\n        Control = ComboBox;\r\n      }\r\n      else if (Option.Kind == TCustomCommandType::okDropDownList)\r\n      {\r\n        TComboBox * ComboBox = new TComboBox(this);\r\n        ComboBox->Style = csDropDownList;\r\n\r\n        AddOptionComboBox(ComboBox, Value, Option, Values);\r\n\r\n        Control = ComboBox;\r\n      }\r\n      else if (Option.Kind == TCustomCommandType::okComboBox)\r\n      {\r\n        TComboBox * ComboBox = new TComboBox(this);\r\n        ComboBox->Style = csDropDown;\r\n\r\n        AddOptionComboBox(ComboBox, Value, Option, Values);\r\n        if (ComboBox->ItemIndex < 0)\r\n        {\r\n          ComboBox->Text = Value;\r\n        }\r\n\r\n        Control = ComboBox;\r\n      }\r\n      else if (Option.Kind == TCustomCommandType::okCheckBox)\r\n      {\r\n        TCheckBox * CheckBox = CreateAndAddCheckBox(Option.Caption);\r\n\r\n        CheckBox->Checked =\r\n          (Option.Params.size() >= 1) &&\r\n          (Value == Option.Params[0]);\r\n\r\n        Control = CheckBox;\r\n      }\r\n      else\r\n      {\r\n        DebugFail();\r\n      }\r\n\r\n      if (Control != NULL)\r\n      {\r\n        Control->Tag = Tag;\r\n      }\r\n      FControls.push_back(Control);\r\n      FValues.push_back(Values);\r\n      ControlIndex++;\r\n      DebugAssert(static_cast<int>(FControls.size()) == ControlIndex);\r\n    }\r\n  }\r\n\r\n  if (ShortCuts != NULL)\r\n  {\r\n    if (HasGroups)\r\n    {\r\n      StartGroup(LoadStr(EXTENSION_GENERAL_GROUP));\r\n    }\r\n    else if (ControlIndex > 0)\r\n    {\r\n      AddSeparator();\r\n    }\r\n    FShortCutCombo = new TComboBox(this);\r\n    AddShortCutComboBox(FShortCutCombo, CreateLabel(LoadStr(EXTENSION_SHORTCUT)), *ShortCuts);\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TCustomCommandOptionsDialog::AddOptionComboBox(\r\n  TComboBox * ComboBox, const UnicodeString & Value, const TCustomCommandType::TOption & Option, std::vector<UnicodeString> & Values)\r\n{\r\n  std::unique_ptr<TStringList> Items(new TStringList());\r\n  int ItemIndex = -1;\r\n\r\n  TCustomCommandType::TOption::TParams::const_iterator ParamI = Option.Params.begin();\r\n  while (ParamI != Option.Params.end())\r\n  {\r\n    UnicodeString Item = (*ParamI);\r\n    int P = Item.Pos(L\"=\");\r\n    UnicodeString ParamValue;\r\n    if (P > 0)\r\n    {\r\n      ParamValue = Item.SubString(1, P - 1);\r\n      Item.Delete(1, P);\r\n    }\r\n    else\r\n    {\r\n      ParamValue = Item;\r\n    }\r\n    Item = WinConfiguration->ExtensionStringTranslation(FCommand->Id, Item);\r\n    Items->Add(Item);\r\n    if (Value == ParamValue)\r\n    {\r\n      ItemIndex = Items->Count - 1;\r\n    }\r\n    Values.push_back(ParamValue);\r\n    ParamI++;\r\n  }\r\n\r\n  AddComboBox(ComboBox, CreateLabel(Option.Caption), Items.get(), true);\r\n\r\n  ComboBox->ItemIndex = ItemIndex;\r\n}\r\n//---------------------------------------------------------------------------\r\nint __fastcall TCustomCommandOptionsDialog::GetOptionIndex(TControl * Control)\r\n{\r\n  return (Control->Tag >> 16);\r\n}\r\n//---------------------------------------------------------------------------\r\nint __fastcall TCustomCommandOptionsDialog::GetControlIndex(TControl * Control)\r\n{\r\n  return (Control->Tag & 0xFFFF);\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TCustomCommandOptionsDialog::LinkLabelClick(TObject * Sender)\r\n{\r\n  TStaticText * Label = DebugNotNull(dynamic_cast<TStaticText *>(Sender));\r\n  const TCustomCommandType::TOption & Option = FCommand->GetOption(GetOptionIndex(Label));\r\n  OpenBrowser(SecureUrl(Option.Default));\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TCustomCommandOptionsDialog::BrowseButtonClick(TObject * Sender)\r\n{\r\n  TButton * Button = DebugNotNull(dynamic_cast<TButton *>(Sender));\r\n  int OptionIndex = GetOptionIndex(Button);\r\n  const TCustomCommandType::TOption & Option = FCommand->GetOption(OptionIndex);\r\n  int ControlIndex = GetControlIndex(Button);\r\n  THistoryComboBox * ComboBox = dynamic_cast<THistoryComboBox *>(FControls[ControlIndex]);\r\n\r\n  std::unique_ptr<TOpenDialog> OpenDialog(new TOpenDialog(Application));\r\n\r\n  UnicodeString Title;\r\n  if (!Option.FileCaption.IsEmpty())\r\n  {\r\n    Title = Option.FileCaption;\r\n  }\r\n  else\r\n  {\r\n    UnicodeString Caption = Option.Caption;\r\n    Caption = StripHotkey(Caption);\r\n    if (!Caption.IsEmpty() && (Caption[Caption.Length()] == L':'))\r\n    {\r\n      Caption.SetLength(Caption.Length() - 1);\r\n    }\r\n    Title = FMTLOAD(EXTENSION_OPTIONS_BROWSE_TITLE, (Caption));\r\n  }\r\n  OpenDialog->Title = Title;\r\n\r\n  UnicodeString Value;\r\n  if (ComboBox->Text.IsEmpty())\r\n  {\r\n    Value = Option.FileInitial;\r\n  }\r\n  else\r\n  {\r\n    Value = ComboBox->Text;\r\n  }\r\n  UnicodeString ExpandedValue = ExpandEnvironmentVariables(Value);\r\n  OpenDialog->FileName = ExpandedValue;\r\n  UnicodeString InitialDir = ExtractFilePath(ExpandedValue);\r\n  if (!InitialDir.IsEmpty())\r\n  {\r\n    OpenDialog->InitialDir = InitialDir;\r\n  }\r\n  OpenDialog->Filter = Option.FileFilter;\r\n  OpenDialog->DefaultExt = Option.FileExt;\r\n\r\n  if (OpenDialog->Execute())\r\n  {\r\n    if (OpenDialog->FileName != ExpandedValue)\r\n    {\r\n      ComboBox->Text = OpenDialog->FileName;\r\n    }\r\n    // If user just confirms the initial value, persist it\r\n    else if (ComboBox->Text.IsEmpty())\r\n    {\r\n      DebugAssert(Option.FileInitial == Value);\r\n      ComboBox->Text = Value;\r\n    }\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\nTHistoryComboBox * __fastcall TCustomCommandOptionsDialog::CreateHistoryComboBox(\r\n  const TCustomCommandType::TOption & Option, const UnicodeString & Value)\r\n{\r\n  THistoryComboBox * ComboBox = new THistoryComboBox(this);\r\n  ComboBox->AutoComplete = false;\r\n  AddComboBox(ComboBox, CreateLabel(Option.Caption));\r\n  ComboBox->Items = CustomWinConfiguration->History[HistoryKey(Option)];\r\n  ComboBox->Text = Value;\r\n  return ComboBox;\r\n}\r\n//---------------------------------------------------------------------------\r\nUnicodeString __fastcall TCustomCommandOptionsDialog::HistoryKey(const TCustomCommandType::TOption & Option)\r\n{\r\n  UnicodeString Result = FCommand->GetOptionKey(Option, FSite);\r\n  Result = CustomWinConfiguration->GetValidHistoryKey(Result);\r\n  return L\"CustomCommandOption_\" + Result;\r\n}\r\n//---------------------------------------------------------------------------\r\nbool __fastcall TCustomCommandOptionsDialog::Execute(TShortCut * ShortCut)\r\n{\r\n  if (ShortCut != NULL)\r\n  {\r\n    SetShortCutCombo(FShortCutCombo, *ShortCut);\r\n  }\r\n\r\n  bool Result = TCustomDialog::Execute();\r\n\r\n  if (Result)\r\n  {\r\n    int ControlIndex = 0;\r\n    for (int OptionIndex = 0; OptionIndex < FCommand->OptionsCount; OptionIndex++)\r\n    {\r\n      const TCustomCommandType::TOption & Option = FCommand->GetOption(OptionIndex);\r\n      if ((Option.Flags & FFlags) != 0)\r\n      {\r\n        if ((Option.Kind != TCustomCommandType::okUnknown) &&\r\n            Option.IsControl)\r\n        {\r\n          UnicodeString OptionKey = FCommand->GetOptionKey(Option, FSite);\r\n\r\n          TControl * Control = FControls[ControlIndex];\r\n\r\n          UnicodeString Value;\r\n          if (Option.Kind == TCustomCommandType::okTextBox)\r\n          {\r\n            Value = SaveHistoryComboBoxValue(Control, Option);\r\n          }\r\n          else if (Option.Kind == TCustomCommandType::okFile)\r\n          {\r\n            Value = SaveHistoryComboBoxValue(Control, Option);\r\n          }\r\n          else if (Option.Kind == TCustomCommandType::okDropDownList)\r\n          {\r\n            Value = GetComboBoxValue(Control, Option.Default);\r\n          }\r\n          else if (Option.Kind == TCustomCommandType::okComboBox)\r\n          {\r\n            TComboBox * ComboBox = DebugNotNull(dynamic_cast<TComboBox *>(Control));\r\n            Value = GetComboBoxValue(Control, ComboBox->Text);\r\n          }\r\n          else if (Option.Kind == TCustomCommandType::okCheckBox)\r\n          {\r\n            TCheckBox * CheckBox = DebugNotNull(dynamic_cast<TCheckBox *>(Control));\r\n            int Index = (CheckBox->Checked ? 0 : 1);\r\n            Value = (Index < static_cast<int>(Option.Params.size())) ? Option.Params[Index] : UnicodeString();\r\n          }\r\n          else\r\n          {\r\n            DebugFail();\r\n          }\r\n\r\n          // The default value setter deletes the \"name\" when the value is empty.\r\n          // It would cause us to fall back to the default value, but we want to remember the empty value.\r\n          SetStringValueEvenIfEmpty(FCustomCommandOptions, OptionKey, Value);\r\n        }\r\n\r\n        ControlIndex++;\r\n      }\r\n    }\r\n\r\n    if (ShortCut != NULL)\r\n    {\r\n      *ShortCut = GetShortCutCombo(FShortCutCombo);\r\n    }\r\n  }\r\n\r\n  return Result;\r\n}\r\n//---------------------------------------------------------------------------\r\nUnicodeString __fastcall TCustomCommandOptionsDialog::GetComboBoxValue(\r\n  TControl * Control, const UnicodeString & Default)\r\n{\r\n  TComboBox * ComboBox = DebugNotNull(dynamic_cast<TComboBox *>(Control));\r\n  UnicodeString Result;\r\n  if (ComboBox->ItemIndex < 0)\r\n  {\r\n    Result = Default;\r\n  }\r\n  else\r\n  {\r\n    Result = FValues[GetControlIndex(Control)][ComboBox->ItemIndex];\r\n  }\r\n  return Result;\r\n}\r\n//---------------------------------------------------------------------------\r\nUnicodeString __fastcall TCustomCommandOptionsDialog::SaveHistoryComboBoxValue(\r\n  TControl * Control, const TCustomCommandType::TOption & Option)\r\n{\r\n  THistoryComboBox * ComboBox = DebugNotNull(dynamic_cast<THistoryComboBox *>(Control));\r\n  ComboBox->SaveToHistory();\r\n  CustomWinConfiguration->History[HistoryKey(Option)] = ComboBox->Items;\r\n  return ComboBox->Text;\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TCustomCommandOptionsDialog::DoHelp()\r\n{\r\n  UnicodeString HelpPage;\r\n  if (!FCommand->OptionsPage.IsEmpty())\r\n  {\r\n    HelpPage = FCommand->OptionsPage;\r\n  }\r\n  else\r\n  {\r\n    HelpPage = FCommand->HomePage;\r\n  }\r\n\r\n  if (!HelpPage.IsEmpty())\r\n  {\r\n    OpenBrowser(HelpPage);\r\n  }\r\n  else\r\n  {\r\n    TCustomDialog::DoHelp();\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TCustomCommandOptionsDialog::DoShow()\r\n{\r\n  TCustomDialog::DoShow();\r\n\r\n  int ControlIndex = 0;\r\n  for (int OptionIndex = 0; OptionIndex < FCommand->OptionsCount; OptionIndex++)\r\n  {\r\n    const TCustomCommandType::TOption & Option = FCommand->GetOption(OptionIndex);\r\n\r\n    if ((Option.Flags & FFlags) != 0)\r\n    {\r\n      if (Option.Kind == TCustomCommandType::okFile)\r\n      {\r\n        TControl * Control = FControls[ControlIndex];\r\n        InstallPathWordBreakProc(DebugNotNull(dynamic_cast<TWinControl *>(Control)));\r\n      }\r\n      ControlIndex++;\r\n    }\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\nbool __fastcall DoCustomCommandOptionsDialog(\r\n  const TCustomCommandType * Command, TStrings * CustomCommandOptions, TShortCut * ShortCut,\r\n  unsigned int Flags, TCustomCommand * CustomCommandForOptions,\r\n  const UnicodeString & Site, const TShortCuts * ShortCuts)\r\n{\r\n  std::unique_ptr<TCustomCommandOptionsDialog> Dialog(\r\n    new TCustomCommandOptionsDialog(Command, CustomCommandOptions, Flags, CustomCommandForOptions, Site, ShortCuts));\r\n  return Dialog->Execute(ShortCut);\r\n}\r\n//---------------------------------------------------------------------------\r\n//---------------------------------------------------------------------------\r\nclass TUsageStatisticsDialog : public TCustomDialog\r\n{\r\npublic:\r\n  __fastcall TUsageStatisticsDialog();\r\n\r\nprotected:\r\n  virtual void __fastcall DoChange(bool & CanSubmit);\r\n\r\nprivate:\r\n  TEdit * FilterEdit;\r\n  TMemo * UsageMemo;\r\n  TButton * ClipboardButton;\r\n\r\n  void __fastcall ClipboardButtonClick(TObject * Sender);\r\n};\r\n//---------------------------------------------------------------------------\r\n__fastcall TUsageStatisticsDialog::TUsageStatisticsDialog() :\r\n  TCustomDialog(HELP_USAGE)\r\n{\r\n  Caption = LoadStr(USAGE_CAPTION);\r\n  Width = ScaleByTextHeight(this, 400);\r\n\r\n  TLabel * Label = new TLabel(this);\r\n  // UnformatMessage is called, because previously, ** markup was used and translations may still contain that\r\n  Label->Caption = UnformatMessage(LoadStr(USAGE_DATA2));\r\n  AddText(Label);\r\n\r\n  FilterEdit = new TEdit(this);\r\n  FilterEdit->Width = ScaleByTextHeight(this, 250);\r\n  TLabel * FilterLabel = new TLabel(this);\r\n  FilterLabel->Caption = LoadStr(USAGE_FILTER);\r\n  AddEdit(FilterEdit, FilterLabel, true);\r\n\r\n  UsageMemo = new TMemo(this);\r\n  UsageMemo->Height = ScaleByTextHeight(this, 300);\r\n  UsageMemo->ScrollBars = ssVertical;\r\n  AddEdit(UsageMemo, NULL);\r\n  ReadOnlyControl(UsageMemo);\r\n\r\n  ClipboardButton = new TButton(this);\r\n  ClipboardButton->Caption = LoadStr(USAGE_COPY);\r\n  ClipboardButton->Width = ScaleByTextHeight(this, 121);\r\n  ClipboardButton->OnClick = ClipboardButtonClick;\r\n  AddDialogButton(ClipboardButton);\r\n\r\n  RemoveCancelButton();\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TUsageStatisticsDialog::ClipboardButtonClick(TObject * /*Sender*/)\r\n{\r\n  TInstantOperationVisualizer Visualizer;\r\n  CopyToClipboard(UsageMemo->Lines);\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TUsageStatisticsDialog::DoChange(bool & CanSubmit)\r\n{\r\n  TCustomDialog::DoChange(CanSubmit);\r\n  UnicodeString Text = Configuration->Usage->Serialize(L\"\\n\", FilterEdit->Text);\r\n  bool NoUsage = Text.IsEmpty();\r\n  ClipboardButton->Enabled = !NoUsage;\r\n  if (NoUsage)\r\n  {\r\n    Text = LoadStr(USAGE_DATA_NONE2);\r\n  }\r\n  UsageMemo->Lines->Text = Text;\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall DoUsageStatisticsDialog()\r\n{\r\n  std::unique_ptr<TUsageStatisticsDialog> Dialog(new TUsageStatisticsDialog());\r\n  Dialog->Execute();\r\n}\r\n//---------------------------------------------------------------------------\r\n//---------------------------------------------------------------------------\r\nclass TSiteRawDialog : public TCustomDialog\r\n{\r\npublic:\r\n  __fastcall TSiteRawDialog();\r\n\r\n  bool __fastcall Execute(TSessionData * Data);\r\n\r\nprotected:\r\n  DYNAMIC void __fastcall DoShow();\r\n\r\nprivate:\r\n  TMemo * SettingsMemo;\r\n\r\n  void __fastcall AddButtonClick(TObject * Sender);\r\n  void __fastcall SettingsMemoKeyDown(TObject * Sender, WORD & Key, TShiftState Shift);\r\n\r\n  void DeleteNames(TStrings * Names, TStrings * Options);\r\n};\r\n//---------------------------------------------------------------------------\r\n__fastcall TSiteRawDialog::TSiteRawDialog() :\r\n  TCustomDialog(HELP_SITE_RAW)\r\n{\r\n  Caption = LoadStr(SITE_RAW_CAPTION);\r\n  Width = ScaleByTextHeight(this, 400);\r\n\r\n  SettingsMemo = new TMemo(this);\r\n  SettingsMemo->Height = ScaleByTextHeight(this, 300);\r\n  SettingsMemo->OnKeyDown = SettingsMemoKeyDown;\r\n  AddEdit(SettingsMemo, NULL);\r\n\r\n  TButton * AddButton = new TButton(this);\r\n  AddButton->Caption = LoadStr(SITE_RAW_ADD);\r\n  AddButton->Width = OKButton->Width;\r\n  AddButton->OnClick = AddButtonClick;\r\n  AddDialogButton(AddButton);\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSiteRawDialog::DoShow()\r\n{\r\n  TCustomDialog::DoShow();\r\n  InstallPathWordBreakProc(SettingsMemo);\r\n}\r\n//---------------------------------------------------------------------------\r\nbool __fastcall TSiteRawDialog::Execute(TSessionData * Data)\r\n{\r\n  std::unique_ptr<TSessionData> FactoryDefaults(new TSessionData(L\"\"));\r\n  std::unique_ptr<TSessionData> RawData(new TSessionData(L\"\"));\r\n  RawData->Assign(Data);\r\n  // SFTP-only is not reflected by the protocol prefix, we have to use rawsettings for that\r\n  if (RawData->FSProtocol != fsSFTPonly)\r\n  {\r\n    RawData->FSProtocol = FactoryDefaults->FSProtocol;\r\n  }\r\n  RawData->HostName = FactoryDefaults->HostName;\r\n  RawData->PortNumber = FactoryDefaults->PortNumber;\r\n  RawData->UserName = FactoryDefaults->UserName;\r\n  RawData->Password = FactoryDefaults->Password;\r\n  RawData->Ftps = FactoryDefaults->Ftps;\r\n\r\n  std::unique_ptr<TStrings> Options(RawData->SaveToOptions(FactoryDefaults.get(), false, false));\r\n\r\n  SettingsMemo->Lines = Options.get();\r\n\r\n  bool Result = TCustomDialog::Execute();\r\n  if (Result)\r\n  {\r\n    std::unique_ptr<TSessionData> BackupData(new TSessionData(L\"\"));\r\n    BackupData->Assign(Data);\r\n    Data->DefaultSettings();\r\n\r\n    Data->FSProtocol = BackupData->FSProtocol;\r\n    Data->HostName = BackupData->HostName;\r\n    Data->PortNumber = BackupData->PortNumber;\r\n    Data->UserName = BackupData->UserName;\r\n    Data->Password = BackupData->Password;\r\n    Data->Ftps = BackupData->Ftps;\r\n\r\n    Data->ApplyRawSettings(SettingsMemo->Lines);\r\n  }\r\n  return Result;\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSiteRawDialog::SettingsMemoKeyDown(TObject * Sender, WORD & Key, TShiftState Shift)\r\n{\r\n  MemoKeyDown(Sender, Key, Shift);\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSiteRawDialog::AddButtonClick(TObject *)\r\n{\r\n  std::unique_ptr<TSessionData> FactoryDefaults(new TSessionData(L\"\"));\r\n  std::unique_ptr<TSessionData> BasicData(new TSessionData(L\"\"));\r\n  BasicData->FSProtocol = TFSProtocol(FactoryDefaults->FSProtocol + 1);\r\n  UnicodeString RandomAppendix(L\"_\");\r\n  BasicData->HostName = FactoryDefaults->HostName + RandomAppendix;\r\n  BasicData->Ftps = TFtps(FactoryDefaults->Ftps + 1);\r\n  BasicData->PortNumber = DefaultPort(BasicData->FSProtocol, BasicData->Ftps) + 1;\r\n  BasicData->UserName = FactoryDefaults->UserName + RandomAppendix;\r\n  BasicData->Password = FactoryDefaults->Password + RandomAppendix;\r\n\r\n  std::unique_ptr<TStrings> BasicOptions(BasicData->SaveToOptions(FactoryDefaults.get(), false, false));\r\n\r\n  std::unique_ptr<TStrings> AllOptions(TSessionData::GetAllOptionNames(false));\r\n\r\n  std::unique_ptr<TStrings> Names(CreateSortedStringList());\r\n  for (int Index = 0; Index < AllOptions->Count; Index++)\r\n  {\r\n    Names->Add(AllOptions->Names[Index]);\r\n  }\r\n  DeleteNames(Names.get(), BasicOptions.get());\r\n  DeleteNames(Names.get(), SettingsMemo->Lines);\r\n\r\n  std::unique_ptr<TCustomDialog> AddDialog(new TCustomDialog(HelpKeyword));\r\n  AddDialog->Caption = LoadStr(SITE_RAW_ADD_CAPTION);\r\n  TComboBox * AddComboBox = new TComboBox(AddDialog.get());\r\n  AddComboBox->Style = csDropDownList;\r\n  AddComboBox->DropDownCount = Max(AddComboBox->DropDownCount, 16);\r\n  AddDialog->AddComboBox(AddComboBox, CreateLabel(LoadStr(SITE_RAW_ADD_LABEL)), Names.get(), true);\r\n  AddComboBox->ItemIndex = 0;\r\n  if (AddDialog->Execute())\r\n  {\r\n    UnicodeString Name = AddComboBox->Items->Strings[AddComboBox->ItemIndex];\r\n    UnicodeString Value = AllOptions->Values[Name];\r\n    UnicodeString NameAndSeparator = Name + SettingsMemo->Lines->NameValueSeparator;\r\n    int Start = (SettingsMemo->Lines->Text + NameAndSeparator).Length();\r\n    SettingsMemo->Lines->Add(NameAndSeparator + Value);\r\n    SettingsMemo->SetFocus();\r\n    SettingsMemo->SelStart = Start;\r\n    SettingsMemo->SelLength = Value.Length();\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid TSiteRawDialog::DeleteNames(TStrings * Names, TStrings * Options)\r\n{\r\n  for (int Index = 0; Index < Options->Count; Index++)\r\n  {\r\n    UnicodeString Name = Options->Names[Index];\r\n    if (!Name.IsEmpty())\r\n    {\r\n      int I = Names->IndexOf(Name);\r\n      if (I >= 0)\r\n      {\r\n        Names->Delete(I);\r\n      }\r\n    }\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall DoSiteRawDialog(TSessionData * Data)\r\n{\r\n  std::unique_ptr<TSiteRawDialog> Dialog(new TSiteRawDialog());\r\n  Dialog->Execute(Data);\r\n}\r\n", "//---------------------------------------------------------------------------\r\n#include <vcl.h>\r\n#pragma hdrstop\r\n\r\n#include <Common.h>\r\n#include <Exceptions.h>\r\n#include <Script.h>\r\n#include <CoreMain.h>\r\n#include <Terminal.h>\r\n#include <PuttyTools.h>\r\n#include <Queue.h>\r\n#include <HierarchicalStorage.h>\r\n#include <Tools.h>\r\n\r\n#include <Consts.hpp>\r\n#include <StrUtils.hpp>\r\n\r\n#include \"Console.h\"\r\n#include \"WinInterface.h\"\r\n#include \"ProgParams.h\"\r\n#include \"TextsWin.h\"\r\n#include \"TextsCore.h\"\r\n#include \"WinConfiguration.h\"\r\n#include \"SynchronizeController.h\"\r\n#include \"GUITools.h\"\r\n#include \"VCLCommon.h\"\r\n#include \"Setup.h\"\r\n//---------------------------------------------------------------------------\r\n#define WM_INTERUPT_IDLE (WM_WINSCP_USER + 3)\r\n#define BATCH_INPUT_TIMEOUT 10000\r\n//---------------------------------------------------------------------------\r\n#pragma package(smart_init)\r\n//---------------------------------------------------------------------------\r\nvoid TrimNewLine(UnicodeString & Str)\r\n{\r\n  while (!Str.IsEmpty() &&\r\n    ((Str[Str.Length()] == L'\\n') || (Str[Str.Length()] == L'\\r')))\r\n  {\r\n    Str.SetLength(Str.Length() - 1);\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TConsole::PrintLine(const UnicodeString & Str, bool Error)\r\n{\r\n  Print(Str + L\"\\n\", false, Error);\r\n};\r\n//---------------------------------------------------------------------------\r\nclass TOwnConsole : public TConsole\r\n{\r\npublic:\r\n  static TOwnConsole * __fastcall Instance();\r\n\r\n  virtual void __fastcall Print(UnicodeString Str, bool FromBeginning = false, bool Error = false);\r\n  virtual bool __fastcall Input(UnicodeString & Str, bool Echo, unsigned int Timer);\r\n  virtual int __fastcall Choice(\r\n    UnicodeString Options, int Cancel, int Break, int Continue, int Timeouted, bool Timeouting, unsigned int Timer,\r\n    UnicodeString Message);\r\n  virtual bool __fastcall PendingAbort();\r\n  virtual void __fastcall SetTitle(UnicodeString Title);\r\n  virtual bool __fastcall LimitedOutput();\r\n  virtual bool __fastcall LiveOutput();\r\n  virtual bool __fastcall NoInteractiveInput();\r\n  virtual bool __fastcall Interactive();\r\n  virtual void __fastcall WaitBeforeExit();\r\n  virtual bool __fastcall CommandLineOnly();\r\n  virtual bool __fastcall WantsProgress();\r\n  virtual void __fastcall Progress(TScriptProgress & Progress);\r\n  virtual UnicodeString __fastcall FinalLogMessage();\r\n\r\nprotected:\r\n  static TOwnConsole * FInstance;\r\n  friend class TConsoleInputThread;\r\n\r\n  __fastcall TOwnConsole();\r\n  virtual __fastcall ~TOwnConsole();\r\n\r\n  void __fastcall BreakInput();\r\n  void __fastcall CancelInput();\r\n  static BOOL WINAPI HandlerRoutine(DWORD CtrlType);\r\n  void __fastcall WindowStateTimer(TObject * Sender);\r\n  void __fastcall ProcessMessages();\r\n  void __fastcall TrayIconClick(TObject * Sender);\r\n\r\nprivate:\r\n  HANDLE FInput;\r\n  HANDLE FOutput;\r\n  HWND FConsoleWindow;\r\n  TTimer * FWindowStateTimer;\r\n  bool FMinimized;\r\n  ::TTrayIcon * FTrayIcon;\r\n  static std::unique_ptr<TCriticalSection> FSection;\r\n\r\n  bool FPendingAbort;\r\n};\r\n//---------------------------------------------------------------------------\r\nTOwnConsole * TOwnConsole::FInstance = NULL;\r\nstd::unique_ptr<TCriticalSection> TOwnConsole::FSection(TraceInitPtr(new TCriticalSection()));\r\n//---------------------------------------------------------------------------\r\n__fastcall TOwnConsole::TOwnConsole()\r\n{\r\n  DebugAssert(FInstance == NULL);\r\n  FInstance = this;\r\n\r\n  AllocConsole();\r\n  SetConsoleCtrlHandler(HandlerRoutine, true);\r\n\r\n  FInput = GetStdHandle(STD_INPUT_HANDLE);\r\n  FOutput = GetStdHandle(STD_OUTPUT_HANDLE);\r\n  FPendingAbort = false;\r\n  FConsoleWindow = NULL;\r\n  FWindowStateTimer = NULL;\r\n  FMinimized = false;\r\n  FTrayIcon = new ::TTrayIcon(0);\r\n  FTrayIcon->OnClick = TrayIconClick;\r\n\r\n  if (WinConfiguration->MinimizeToTray)\r\n  {\r\n    FConsoleWindow = GetConsoleWindow();\r\n    if (DebugAlwaysTrue(FConsoleWindow != NULL))\r\n    {\r\n      FWindowStateTimer = new TTimer(Application);\r\n      FWindowStateTimer->OnTimer = WindowStateTimer;\r\n      FWindowStateTimer->Interval = 250;\r\n      FWindowStateTimer->Enabled = true;\r\n    }\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\n__fastcall TOwnConsole::~TOwnConsole()\r\n{\r\n  TGuard Guard(FSection.get());\r\n\r\n  delete FTrayIcon;\r\n  delete FWindowStateTimer;\r\n\r\n  // deliberately do not remove ConsoleCtrlHandler as it causes\r\n  // failures while exiting\r\n\r\n  FreeConsole();\r\n\r\n  DebugAssert(FInstance == this);\r\n  FInstance = NULL;\r\n}\r\n//---------------------------------------------------------------------------\r\nTOwnConsole * __fastcall TOwnConsole::Instance()\r\n{\r\n  return new TOwnConsole();\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TOwnConsole::WindowStateTimer(TObject * /*Sender*/)\r\n{\r\n  DebugAssert(FConsoleWindow != NULL);\r\n  WINDOWPLACEMENT Placement;\r\n  memset(&Placement, 0, sizeof(Placement));\r\n  Placement.length = sizeof(Placement);\r\n  if (GetWindowPlacement(FConsoleWindow, &Placement))\r\n  {\r\n    bool Minimized = (Placement.showCmd == SW_SHOWMINIMIZED);\r\n    if (FMinimized != Minimized)\r\n    {\r\n      FMinimized = Minimized;\r\n\r\n      if (FMinimized && WinConfiguration->MinimizeToTray)\r\n      {\r\n        FTrayIcon->Visible = true;\r\n        ShowWindow(FConsoleWindow, SW_HIDE);\r\n      }\r\n      else\r\n      {\r\n        FTrayIcon->Visible = false;\r\n        ShowWindow(FConsoleWindow, SW_SHOW);\r\n      }\r\n    }\r\n  }\r\n  else\r\n  {\r\n    DebugFail();\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TOwnConsole::ProcessMessages()\r\n{\r\n  // as of now, there's no point doing this unless we have icon tray\r\n  // (i.e. we need to monitor window state and eventually process tray icon messages)\r\n  if (FWindowStateTimer != NULL)\r\n  {\r\n    DebugAssert(WinConfiguration->MinimizeToTray);\r\n\r\n    Application->ProcessMessages();\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TOwnConsole::TrayIconClick(TObject * /*Sender*/)\r\n{\r\n  DebugAssert(FConsoleWindow != NULL);\r\n  SetForegroundWindow(FConsoleWindow);\r\n  ShowWindow(FConsoleWindow, SW_RESTORE);\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TOwnConsole::BreakInput()\r\n{\r\n  FlushConsoleInputBuffer(FInput);\r\n  INPUT_RECORD InputRecord;\r\n  memset(&InputRecord, 0, sizeof(InputRecord));\r\n  InputRecord.EventType = KEY_EVENT;\r\n  InputRecord.Event.KeyEvent.bKeyDown = true;\r\n  InputRecord.Event.KeyEvent.wRepeatCount = 1;\r\n  InputRecord.Event.KeyEvent.uChar.UnicodeChar = L'\\r';\r\n\r\n  unsigned long Written;\r\n  // this assertion occasionally fails (when console is being exited)\r\n  DebugCheck(WriteConsoleInput(FInput, &InputRecord, 1, &Written));\r\n  DebugAssert(Written == 1);\r\n\r\n  CancelInput();\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TOwnConsole::CancelInput()\r\n{\r\n  FPendingAbort = true;\r\n\r\n  PostMessage(Application->Handle, WM_INTERUPT_IDLE, 0, 0);\r\n}\r\n//---------------------------------------------------------------------------\r\nBOOL WINAPI TOwnConsole::HandlerRoutine(DWORD CtrlType)\r\n{\r\n  if ((CtrlType == CTRL_C_EVENT) || (CtrlType == CTRL_BREAK_EVENT))\r\n  {\r\n    {\r\n      TGuard Guard(FSection.get());\r\n\r\n      // just to be real thread-safe\r\n      if (FInstance != NULL)\r\n      {\r\n        FInstance->CancelInput();\r\n      }\r\n    }\r\n\r\n    return true;\r\n  }\r\n  else\r\n  {\r\n    return false;\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\nbool __fastcall TOwnConsole::PendingAbort()\r\n{\r\n  if (FPendingAbort)\r\n  {\r\n    FPendingAbort = false;\r\n    return true;\r\n  }\r\n  else\r\n  {\r\n    return FPendingAbort;\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TOwnConsole::Print(UnicodeString Str, bool FromBeginning, bool /*Error*/)\r\n{\r\n  if (FromBeginning)\r\n  {\r\n    CONSOLE_SCREEN_BUFFER_INFO BufferInfo;\r\n    GetConsoleScreenBufferInfo(FOutput, &BufferInfo);\r\n    BufferInfo.dwCursorPosition.X = 0;\r\n    SetConsoleCursorPosition(FOutput, BufferInfo.dwCursorPosition);\r\n  }\r\n  unsigned long Written;\r\n  bool Result = WriteConsole(FOutput, Str.c_str(), Str.Length(), &Written, NULL);\r\n  DebugAssert(Result);\r\n  DebugUsedParam(Result);\r\n  DebugAssert(Str.Length() == static_cast<long>(Written));\r\n  ProcessMessages();\r\n}\r\n//---------------------------------------------------------------------------\r\nclass TConsoleInputThread : public TSimpleThread\r\n{\r\npublic:\r\n  __fastcall TConsoleInputThread(HANDLE Input, UnicodeString & Str, bool & Result) :\r\n    FInput(Input),\r\n    FStr(Str),\r\n    FResult(Result)\r\n  {\r\n  }\r\n\r\n  virtual __fastcall ~TConsoleInputThread()\r\n  {\r\n    Close();\r\n  }\r\n\r\nprotected:\r\n  virtual void __fastcall Execute()\r\n  {\r\n    unsigned long Read;\r\n    FStr.SetLength(10240);\r\n    FResult = ReadConsole(FInput, FStr.c_str(), FStr.Length(), &Read, NULL);\r\n    DebugAssert(FResult);\r\n    FStr.SetLength(Read);\r\n    TrimNewLine(FStr);\r\n  }\r\n\r\n  virtual void __fastcall Terminate()\r\n  {\r\n    TOwnConsole::FInstance->BreakInput();\r\n  }\r\n\r\nprivate:\r\n  HANDLE FInput;\r\n  UnicodeString & FStr;\r\n  bool & FResult;\r\n};\r\n//---------------------------------------------------------------------------\r\nbool __fastcall TOwnConsole::Input(UnicodeString & Str, bool Echo, unsigned int Timer)\r\n{\r\n  unsigned long PrevMode, NewMode;\r\n  GetConsoleMode(FInput, &PrevMode);\r\n  NewMode = PrevMode | ENABLE_PROCESSED_INPUT | ENABLE_LINE_INPUT;\r\n  if (Echo)\r\n  {\r\n    NewMode |= ENABLE_ECHO_INPUT;\r\n  }\r\n  else\r\n  {\r\n    NewMode &= ~ENABLE_ECHO_INPUT;\r\n  }\r\n  SetConsoleMode(FInput, NewMode);\r\n\r\n  bool Result = false;\r\n\r\n  try\r\n  {\r\n    {\r\n      const int FirstKey = VK_LBUTTON; // 0x01\r\n      const int LastKey = VK_OEM_CLEAR; // 0xFE\r\n\r\n      // reset key state\r\n      for (int Key = FirstKey; Key <= LastKey; Key++)\r\n      {\r\n        GetAsyncKeyState(Key);\r\n      }\r\n\r\n      TConsoleInputThread InputThread(FInput, Str, Result);\r\n\r\n      InputThread.Start();\r\n\r\n      double TimerD = double(Timer)/MSecsPerDay;\r\n      double End = Now() + TimerD;\r\n      while (!InputThread.IsFinished() &&\r\n             ((Timer == 0) || (double(Now()) < End)))\r\n      {\r\n        ProcessMessages();\r\n        InputThread.WaitFor(50);\r\n\r\n        for (int Key = FirstKey; Key <= LastKey; Key++)\r\n        {\r\n          if ((GetAsyncKeyState(Key) & 0x01) != 0)\r\n          {\r\n            End = Now() + TimerD;\r\n            // Finishing the loop nevertheless to reset state of all keys\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    if (FPendingAbort || !Echo)\r\n    {\r\n      Print(L\"\\n\");\r\n    }\r\n\r\n    if (FPendingAbort || (Str.Length() == 0))\r\n    {\r\n      Result = false;\r\n      FPendingAbort = false;\r\n    }\r\n  }\r\n  __finally\r\n  {\r\n    SetConsoleMode(FInput, PrevMode);\r\n  }\r\n\r\n  return Result;\r\n}\r\n//---------------------------------------------------------------------------\r\nint __fastcall TOwnConsole::Choice(\r\n  UnicodeString Options, int Cancel, int Break, int /*Continue*/, int Timeouted, bool /*Timeouting*/, unsigned int Timer,\r\n  UnicodeString Message)\r\n{\r\n  unsigned int ATimer = Timer;\r\n  int Result = 0;\r\n  unsigned long PrevMode, NewMode;\r\n  GetConsoleMode(FInput, &PrevMode);\r\n  NewMode = (PrevMode | ENABLE_PROCESSED_INPUT) & ~(ENABLE_LINE_INPUT | ENABLE_ECHO_INPUT);\r\n  SetConsoleMode(FInput, NewMode);\r\n\r\n  try\r\n  {\r\n    do\r\n    {\r\n      unsigned long Read;\r\n      INPUT_RECORD Record;\r\n      if ((PeekConsoleInput(FInput, &Record, 1, &Read) != 0) &&\r\n          (Read == 1))\r\n      {\r\n        if ((ReadConsoleInput(FInput, &Record, 1, &Read) != 0) &&\r\n            (Read == 1))\r\n        {\r\n          if (PendingAbort())\r\n          {\r\n            Result = Break;\r\n          }\r\n          else if ((Record.EventType == KEY_EVENT) &&\r\n                   Record.Event.KeyEvent.bKeyDown)\r\n          {\r\n            wchar_t C = AnsiUpperCase(Record.Event.KeyEvent.uChar.UnicodeChar)[1];\r\n            if (C == 27)\r\n            {\r\n              Result = Cancel;\r\n            }\r\n            else if ((Options.Pos(C) > 0) &&\r\n                     FLAGCLEAR(Record.Event.KeyEvent.dwControlKeyState,\r\n                       LEFT_CTRL_PRESSED | RIGHT_CTRL_PRESSED | LEFT_ALT_PRESSED  |\r\n                       RIGHT_ALT_PRESSED))\r\n\r\n            {\r\n              Result = Options.Pos(C);\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      if (Result == 0)\r\n      {\r\n        unsigned int TimerSlice = 50;\r\n        Sleep(TimerSlice);\r\n        if (Timer > 0)\r\n        {\r\n          if (ATimer > TimerSlice)\r\n          {\r\n            ATimer -= TimerSlice;\r\n          }\r\n          else\r\n          {\r\n            Result = Timeouted;\r\n          }\r\n        }\r\n      }\r\n\r\n      ProcessMessages();\r\n    }\r\n    while (Result == 0);\r\n  }\r\n  __finally\r\n  {\r\n    SetConsoleMode(FInput, PrevMode);\r\n  }\r\n\r\n  return Result;\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TOwnConsole::SetTitle(UnicodeString Title)\r\n{\r\n  FTrayIcon->Hint = Title;\r\n  SetConsoleTitle(Title.c_str());\r\n}\r\n//---------------------------------------------------------------------------\r\nbool __fastcall TOwnConsole::LimitedOutput()\r\n{\r\n  return true;\r\n}\r\n//---------------------------------------------------------------------------\r\nbool __fastcall TOwnConsole::LiveOutput()\r\n{\r\n  return true;\r\n}\r\n//---------------------------------------------------------------------------\r\nbool __fastcall TOwnConsole::NoInteractiveInput()\r\n{\r\n  return false;\r\n}\r\n//---------------------------------------------------------------------------\r\nbool __fastcall TOwnConsole::Interactive()\r\n{\r\n  return true;\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TOwnConsole::WaitBeforeExit()\r\n{\r\n  unsigned long Read;\r\n  INPUT_RECORD Record;\r\n  while (true)\r\n  {\r\n    if (PeekConsoleInput(FInput, &Record, 1, &Read) && (Read == 1) &&\r\n        ReadConsoleInput(FInput, &Record, 1, &Read) &&\r\n        (Read == 1) && (Record.EventType == KEY_EVENT) &&\r\n        (Record.Event.KeyEvent.uChar.UnicodeChar != 0) &&\r\n        Record.Event.KeyEvent.bKeyDown)\r\n    {\r\n      break;\r\n    }\r\n    Sleep(50);\r\n    ProcessMessages();\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\nbool __fastcall TOwnConsole::CommandLineOnly()\r\n{\r\n  return false;\r\n}\r\n//---------------------------------------------------------------------------\r\nbool __fastcall TOwnConsole::WantsProgress()\r\n{\r\n  return false;\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TOwnConsole::Progress(TScriptProgress & /*Progress*/)\r\n{\r\n  DebugFail();\r\n}\r\n//---------------------------------------------------------------------------\r\nUnicodeString __fastcall TOwnConsole::FinalLogMessage()\r\n{\r\n  return UnicodeString();\r\n}\r\n//---------------------------------------------------------------------------\r\nclass TExternalConsole : public TConsole\r\n{\r\npublic:\r\n  __fastcall TExternalConsole(const UnicodeString Instance, bool NoInteractiveInput);\r\n  virtual __fastcall ~TExternalConsole();\r\n\r\n  virtual void __fastcall Print(UnicodeString Str, bool FromBeginning = false, bool Error = false);\r\n  virtual bool __fastcall Input(UnicodeString & Str, bool Echo, unsigned int Timer);\r\n  virtual int __fastcall Choice(\r\n    UnicodeString Options, int Cancel, int Break, int Continue, int Timeouted, bool Timeouting, unsigned int Timer,\r\n    UnicodeString Message);\r\n  virtual bool __fastcall PendingAbort();\r\n  virtual void __fastcall SetTitle(UnicodeString Title);\r\n  virtual bool __fastcall LimitedOutput();\r\n  virtual bool __fastcall LiveOutput();\r\n  virtual bool __fastcall NoInteractiveInput();\r\n  virtual void __fastcall WaitBeforeExit();\r\n  virtual bool __fastcall Interactive();\r\n  virtual bool __fastcall CommandLineOnly();\r\n  virtual bool __fastcall WantsProgress();\r\n  virtual void __fastcall Progress(TScriptProgress & Progress);\r\n  virtual UnicodeString __fastcall FinalLogMessage();\r\n\r\nprivate:\r\n  bool FPendingAbort;\r\n  HANDLE FRequestEvent;\r\n  HANDLE FResponseEvent;\r\n  HANDLE FCancelEvent;\r\n  HANDLE FFileMapping;\r\n  bool FLimitedOutput;\r\n  bool FLiveOutput;\r\n  bool FPipeOutput;\r\n  bool FNoInteractiveInput;\r\n  bool FWantsProgress;\r\n  bool FInteractive;\r\n  unsigned int FMaxSend;\r\n\r\n  inline TConsoleCommStruct * __fastcall GetCommStruct();\r\n  inline void __fastcall FreeCommStruct(TConsoleCommStruct * CommStruct);\r\n  inline void __fastcall SendEvent(int Timeout);\r\n  void __fastcall Init();\r\n  void __fastcall CheckHandle(HANDLE Handle, const UnicodeString & Desc);\r\n};\r\n//---------------------------------------------------------------------------\r\n__fastcall TExternalConsole::TExternalConsole(\r\n  const UnicodeString Instance, bool NoInteractiveInput)\r\n{\r\n  UnicodeString Name;\r\n  Name = FORMAT(L\"%s%s\", (CONSOLE_EVENT_REQUEST, (Instance)));\r\n  CheckHandle(FRequestEvent = OpenEvent(EVENT_ALL_ACCESS, false, Name.c_str()), L\"Request event\");\r\n  Name = FORMAT(L\"%s%s\", (CONSOLE_EVENT_RESPONSE, (Instance)));\r\n  CheckHandle(FResponseEvent = OpenEvent(EVENT_ALL_ACCESS, false, Name.c_str()), L\"Response event\");\r\n  Name = FORMAT(L\"%s%s\", (CONSOLE_EVENT_CANCEL, (Instance)));\r\n  CheckHandle(FCancelEvent = OpenEvent(EVENT_ALL_ACCESS, false, Name.c_str()), L\"Cancel event\");\r\n  Name = FORMAT(L\"%s%s\", (CONSOLE_MAPPING, (Instance)));\r\n  CheckHandle(FFileMapping = OpenFileMapping(FILE_MAP_ALL_ACCESS, false, Name.c_str()), L\"File mapping\");\r\n\r\n  HANDLE Job = OpenJobObject(JOB_OBJECT_ASSIGN_PROCESS, FALSE,\r\n    FORMAT(L\"%s%s\", (CONSOLE_JOB, Instance)).c_str());\r\n  if (DebugAlwaysTrue(Job != NULL))\r\n  {\r\n    AssignProcessToJobObject(Job, GetCurrentProcess());\r\n    // winscp.com/winscp.dll keeps the only reference to the job.\r\n    // once it gets closed (because winscp.com if forcefully terminated),\r\n    // we get terminated as well\r\n    CloseHandle(Job);\r\n  }\r\n\r\n  TConsoleCommStruct * CommStruct = GetCommStruct();\r\n  try\r\n  {\r\n    if (CommStruct->Version != TConsoleCommStruct::CurrentVersion)\r\n    {\r\n      throw Exception(FMTLOAD(EXTERNAL_CONSOLE_INCOMPATIBLE, (CommStruct->Version)));\r\n    }\r\n\r\n    CommStruct->Version = TConsoleCommStruct::CurrentVersionConfirmed;\r\n  }\r\n  __finally\r\n  {\r\n    FreeCommStruct(CommStruct);\r\n  }\r\n\r\n  // to break application event loop regularly during \"watching for changes\"\r\n  // to allow user to abort it\r\n  SetTimer(Application->Handle, 1, 500, NULL);\r\n\r\n  FNoInteractiveInput = NoInteractiveInput;\r\n  FMaxSend = 0;\r\n\r\n  Init();\r\n}\r\n//---------------------------------------------------------------------------\r\n__fastcall TExternalConsole::~TExternalConsole()\r\n{\r\n  CloseHandle(FRequestEvent);\r\n  CloseHandle(FResponseEvent);\r\n  CloseHandle(FCancelEvent);\r\n  CloseHandle(FFileMapping);\r\n  KillTimer(Application->Handle, 1);\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TExternalConsole::CheckHandle(HANDLE Handle, const UnicodeString & Desc)\r\n{\r\n  if (Handle == NULL)\r\n  {\r\n    throw ExtException(LoadStr(EXTERNAL_CONSOLE_INIT_ERROR), FORMAT(L\"%s\\n%s\", (Desc, LastSysErrorMessage())));\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\nTConsoleCommStruct * __fastcall TExternalConsole::GetCommStruct()\r\n{\r\n  TConsoleCommStruct * Result;\r\n  Result = static_cast<TConsoleCommStruct*>(MapViewOfFile(FFileMapping,\r\n    FILE_MAP_ALL_ACCESS, 0, 0, 0));\r\n  if (Result == NULL)\r\n  {\r\n    throw Exception(LoadStr(CONSOLE_COMM_ERROR));\r\n  }\r\n  return Result;\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TExternalConsole::FreeCommStruct(TConsoleCommStruct * CommStruct)\r\n{\r\n  UnmapViewOfFile(CommStruct);\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TExternalConsole::SendEvent(int Timeout)\r\n{\r\n  SetEvent(FRequestEvent);\r\n  unsigned int Start = 0; // shut up\r\n  if (Configuration->LogProtocol >= 1)\r\n  {\r\n    Start = GetTickCount();\r\n  }\r\n  unsigned int Result = WaitForSingleObject(FResponseEvent, Timeout);\r\n  if (Configuration->LogProtocol >= 1)\r\n  {\r\n    unsigned int End = GetTickCount();\r\n    unsigned int Duration = End - Start;\r\n    FMaxSend = std::max(Duration, FMaxSend);\r\n  }\r\n  if (Result != WAIT_OBJECT_0)\r\n  {\r\n    UnicodeString Message = LoadStr(CONSOLE_SEND_TIMEOUT);\r\n    if (FPipeOutput)\r\n    {\r\n      Message = FORMAT(\"%s %s\", (Message, LoadStr(CONSOLE_SEND_PIPE)));\r\n    }\r\n    throw Exception(Message);\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\nUnicodeString __fastcall TExternalConsole::FinalLogMessage()\r\n{\r\n  return FORMAT(L\"Max roundtrip: %d\", (static_cast<int>(FMaxSend)));\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TExternalConsole::Print(UnicodeString Str, bool FromBeginning, bool Error)\r\n{\r\n  // need to do at least one iteration, even when Str is empty (new line)\r\n  do\r\n  {\r\n    TConsoleCommStruct * CommStruct = GetCommStruct();\r\n    try\r\n    {\r\n      size_t MaxLen = LENOF(CommStruct->PrintEvent.Message) - 1;\r\n      UnicodeString Piece = Str.SubString(1, MaxLen);\r\n      Str.Delete(1, MaxLen);\r\n\r\n      CommStruct->Event = TConsoleCommStruct::PRINT;\r\n      wcscpy(CommStruct->PrintEvent.Message, Piece.c_str());\r\n      CommStruct->PrintEvent.FromBeginning = FromBeginning;\r\n      CommStruct->PrintEvent.Error = Error;\r\n\r\n      // In the next iteration we need to append never overwrite.\r\n      // Note that this won't work properly for disk/pipe outputs,\r\n      // when the next line is also FromBeginning,\r\n      // as !FromBeginning print effectively commits previous FromBeginning print.\r\n      // On the other hand, FromBeginning print is always initiated by us,\r\n      // and it's not likely we ever issue print over 10 KB.\r\n      FromBeginning = false;\r\n    }\r\n    __finally\r\n    {\r\n      FreeCommStruct(CommStruct);\r\n    }\r\n\r\n    SendEvent(INFINITE);\r\n  }\r\n  while (!Str.IsEmpty());\r\n}\r\n//---------------------------------------------------------------------------\r\nbool __fastcall TExternalConsole::Input(UnicodeString & Str, bool Echo, unsigned int Timer)\r\n{\r\n  TConsoleCommStruct * CommStruct = GetCommStruct();\r\n  try\r\n  {\r\n    CommStruct->Event = TConsoleCommStruct::INPUT;\r\n    CommStruct->InputEvent.Echo = Echo;\r\n    CommStruct->InputEvent.Result = false;\r\n    CommStruct->InputEvent.Str[0] = L'\\0';\r\n    CommStruct->InputEvent.Timer = Timer;\r\n  }\r\n  __finally\r\n  {\r\n    FreeCommStruct(CommStruct);\r\n  }\r\n\r\n  SendEvent(INFINITE);\r\n\r\n  bool Result;\r\n  CommStruct = GetCommStruct();\r\n  try\r\n  {\r\n    Result = CommStruct->InputEvent.Result;\r\n    Str = CommStruct->InputEvent.Str;\r\n    TrimNewLine(Str);\r\n  }\r\n  __finally\r\n  {\r\n    FreeCommStruct(CommStruct);\r\n  }\r\n\r\n  return Result;\r\n}\r\n//---------------------------------------------------------------------------\r\nint __fastcall TExternalConsole::Choice(\r\n  UnicodeString Options, int Cancel, int Break, int Continue, int Timeouted, bool Timeouting, unsigned int Timer,\r\n  UnicodeString Message)\r\n{\r\n  TConsoleCommStruct * CommStruct = GetCommStruct();\r\n  try\r\n  {\r\n    CommStruct->Event = TConsoleCommStruct::CHOICE;\r\n\r\n    DebugAssert(Options.Length() < static_cast<int>(LENOF(CommStruct->ChoiceEvent.Options)));\r\n    wcscpy(CommStruct->ChoiceEvent.Options, Options.c_str());\r\n    CommStruct->ChoiceEvent.Cancel = Cancel;\r\n    CommStruct->ChoiceEvent.Break = Break;\r\n    CommStruct->ChoiceEvent.Result = Break;\r\n    CommStruct->ChoiceEvent.Continue = Continue;\r\n    CommStruct->ChoiceEvent.Timeouted = Timeouted;\r\n    CommStruct->ChoiceEvent.Timer = Timer;\r\n    CommStruct->ChoiceEvent.Timeouting = Timeouting;\r\n    size_t MaxLen = LENOF(CommStruct->ChoiceEvent.Message) - 1;\r\n    Message = Message.SubString(1, MaxLen);\r\n    wcscpy(CommStruct->ChoiceEvent.Message, Message.c_str());\r\n  }\r\n  __finally\r\n  {\r\n    FreeCommStruct(CommStruct);\r\n  }\r\n\r\n  SendEvent(INFINITE);\r\n\r\n  int Result;\r\n  CommStruct = GetCommStruct();\r\n  try\r\n  {\r\n    Result = CommStruct->ChoiceEvent.Result;\r\n  }\r\n  __finally\r\n  {\r\n    FreeCommStruct(CommStruct);\r\n  }\r\n\r\n  return Result;\r\n}\r\n//---------------------------------------------------------------------------\r\nbool __fastcall TExternalConsole::PendingAbort()\r\n{\r\n  return (WaitForSingleObject(FCancelEvent, 0) == WAIT_OBJECT_0);\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TExternalConsole::SetTitle(UnicodeString Title)\r\n{\r\n  TConsoleCommStruct * CommStruct = GetCommStruct();\r\n  try\r\n  {\r\n    // Truncate to maximum allowed. Title over 10 KB won't fit to screen anyway\r\n    Title = Title.SubString(1, LENOF(CommStruct->TitleEvent.Title) - 1);\r\n\r\n    CommStruct->Event = TConsoleCommStruct::TITLE;\r\n    wcscpy(CommStruct->TitleEvent.Title, Title.c_str());\r\n  }\r\n  __finally\r\n  {\r\n    FreeCommStruct(CommStruct);\r\n  }\r\n\r\n  SendEvent(INFINITE);\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TExternalConsole::Init()\r\n{\r\n  TConsoleCommStruct * CommStruct = GetCommStruct();\r\n  try\r\n  {\r\n    CommStruct->Event = TConsoleCommStruct::INIT;\r\n    CommStruct->InitEvent.WantsProgress = false;\r\n  }\r\n  __finally\r\n  {\r\n    FreeCommStruct(CommStruct);\r\n  }\r\n  SendEvent(INFINITE);\r\n\r\n  CommStruct = GetCommStruct();\r\n  try\r\n  {\r\n    FLimitedOutput = (CommStruct->InitEvent.OutputType == FILE_TYPE_CHAR);\r\n    FLiveOutput =\r\n      (CommStruct->InitEvent.OutputType != FILE_TYPE_DISK) &&\r\n      (CommStruct->InitEvent.OutputType != FILE_TYPE_PIPE);\r\n    FPipeOutput = (CommStruct->InitEvent.OutputType != FILE_TYPE_PIPE);\r\n    FInteractive =\r\n      (CommStruct->InitEvent.InputType != FILE_TYPE_DISK) &&\r\n      (CommStruct->InitEvent.InputType != FILE_TYPE_PIPE);\r\n    FWantsProgress = CommStruct->InitEvent.WantsProgress;\r\n  }\r\n  __finally\r\n  {\r\n    FreeCommStruct(CommStruct);\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\nbool __fastcall TExternalConsole::LimitedOutput()\r\n{\r\n  return FLimitedOutput;\r\n}\r\n//---------------------------------------------------------------------------\r\nbool __fastcall TExternalConsole::LiveOutput()\r\n{\r\n  return FLiveOutput;\r\n}\r\n//---------------------------------------------------------------------------\r\nbool __fastcall TExternalConsole::NoInteractiveInput()\r\n{\r\n  return FNoInteractiveInput;\r\n}\r\n//---------------------------------------------------------------------------\r\nbool __fastcall TExternalConsole::Interactive()\r\n{\r\n  return FInteractive;\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TExternalConsole::WaitBeforeExit()\r\n{\r\n  // noop\r\n}\r\n//---------------------------------------------------------------------------\r\nbool __fastcall TExternalConsole::CommandLineOnly()\r\n{\r\n  return true;\r\n}\r\n//---------------------------------------------------------------------------\r\nbool __fastcall TExternalConsole::WantsProgress()\r\n{\r\n  return FWantsProgress;\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TExternalConsole::Progress(TScriptProgress & Progress)\r\n{\r\n  TConsoleCommStruct * CommStruct = GetCommStruct();\r\n\r\n  typedef TConsoleCommStruct::TProgressEvent TProgressEvent;\r\n\r\n  try\r\n  {\r\n    TProgressEvent & ProgressEvent = CommStruct->ProgressEvent;\r\n\r\n    CommStruct->Event = TConsoleCommStruct::PROGRESS;\r\n\r\n    switch (Progress.Operation)\r\n    {\r\n      case foCopy:\r\n      case foMove:\r\n        ProgressEvent.Operation = TProgressEvent::COPY;\r\n        break;\r\n\r\n      default:\r\n        DebugFail();\r\n    }\r\n\r\n    switch (Progress.Side)\r\n    {\r\n      case osLocal:\r\n        ProgressEvent.Side = TProgressEvent::LOCAL;\r\n        break;\r\n\r\n      case osRemote:\r\n        ProgressEvent.Side = TProgressEvent::REMOTE;\r\n        break;\r\n\r\n      default:\r\n        DebugFail();\r\n    }\r\n\r\n    wcsncpy(ProgressEvent.FileName, Progress.FileName.c_str(), LENOF(ProgressEvent.FileName));\r\n    NULL_TERMINATE(ProgressEvent.FileName);\r\n\r\n    wcsncpy(ProgressEvent.Directory, Progress.Directory.c_str(), LENOF(ProgressEvent.Directory));\r\n    NULL_TERMINATE(ProgressEvent.Directory);\r\n\r\n    ProgressEvent.OverallProgress = Progress.OverallProgress;\r\n    ProgressEvent.FileProgress = Progress.FileProgress;\r\n    ProgressEvent.CPS = Progress.CPS;\r\n    ProgressEvent.Cancel = Progress.Cancel;\r\n  }\r\n  __finally\r\n  {\r\n    FreeCommStruct(CommStruct);\r\n  }\r\n  SendEvent(INFINITE);\r\n\r\n  CommStruct = GetCommStruct();\r\n  try\r\n  {\r\n    TProgressEvent & ProgressEvent = CommStruct->ProgressEvent;\r\n    Progress.Cancel = ProgressEvent.Cancel;\r\n  }\r\n  __finally\r\n  {\r\n    FreeCommStruct(CommStruct);\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\nclass TNullConsole : public TConsole\r\n{\r\npublic:\r\n  __fastcall TNullConsole();\r\n\r\n  virtual void __fastcall Print(UnicodeString Str, bool FromBeginning = false, bool Error = false);\r\n  virtual bool __fastcall Input(UnicodeString & Str, bool Echo, unsigned int Timer);\r\n  virtual int __fastcall Choice(\r\n    UnicodeString Options, int Cancel, int Break, int Continue, int Timeouted, bool Timeouting, unsigned int Timer,\r\n    UnicodeString Message);\r\n  virtual bool __fastcall PendingAbort();\r\n  virtual void __fastcall SetTitle(UnicodeString Title);\r\n  virtual bool __fastcall LimitedOutput();\r\n  virtual bool __fastcall LiveOutput();\r\n  virtual bool __fastcall NoInteractiveInput();\r\n  virtual bool __fastcall Interactive();\r\n  virtual void __fastcall WaitBeforeExit();\r\n  virtual bool __fastcall CommandLineOnly();\r\n\r\n  virtual bool __fastcall WantsProgress();\r\n  virtual void __fastcall Progress(TScriptProgress & Progress);\r\n  virtual UnicodeString __fastcall FinalLogMessage();\r\n};\r\n//---------------------------------------------------------------------------\r\n__fastcall TNullConsole::TNullConsole()\r\n{\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TNullConsole::Print(UnicodeString /*Str*/, bool /*FromBeginning*/, bool /*Error*/)\r\n{\r\n  // noop\r\n}\r\n//---------------------------------------------------------------------------\r\nbool __fastcall TNullConsole::Input(UnicodeString & /*Str*/, bool /*Echo*/,\r\n  unsigned int /*Timer*/)\r\n{\r\n  return false;\r\n}\r\n//---------------------------------------------------------------------------\r\nint __fastcall TNullConsole::Choice(\r\n  UnicodeString /*Options*/, int /*Cancel*/, int Break, int /*Continue*/, int Timeouted, bool Timeouting,\r\n  unsigned int Timer, UnicodeString /*Message*/)\r\n{\r\n  int Result;\r\n  if (Timeouting)\r\n  {\r\n    Sleep(Timer);\r\n    Result = Timeouted;\r\n  }\r\n  else\r\n  {\r\n    Result = Break;\r\n  }\r\n  return Result;\r\n}\r\n//---------------------------------------------------------------------------\r\nbool __fastcall TNullConsole::PendingAbort()\r\n{\r\n  return false;\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TNullConsole::SetTitle(UnicodeString /*Title*/)\r\n{\r\n  // noop\r\n}\r\n//---------------------------------------------------------------------------\r\nbool __fastcall TNullConsole::LimitedOutput()\r\n{\r\n  return false;\r\n}\r\n//---------------------------------------------------------------------------\r\nbool __fastcall TNullConsole::LiveOutput()\r\n{\r\n  return false;\r\n}\r\n//---------------------------------------------------------------------------\r\nbool __fastcall TNullConsole::NoInteractiveInput()\r\n{\r\n  // do not matter, even if we return false,\r\n  // it fails immediately afterwards in TNullConsole::Input\r\n  return true;\r\n}\r\n//---------------------------------------------------------------------------\r\nbool __fastcall TNullConsole::Interactive()\r\n{\r\n  return false;\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TNullConsole::WaitBeforeExit()\r\n{\r\n  DebugFail();\r\n  // noop\r\n}\r\n//---------------------------------------------------------------------------\r\nbool __fastcall TNullConsole::CommandLineOnly()\r\n{\r\n  DebugFail();\r\n  return false;\r\n}\r\n//---------------------------------------------------------------------------\r\nbool __fastcall TNullConsole::WantsProgress()\r\n{\r\n  return false;\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TNullConsole::Progress(TScriptProgress & /*Progress*/)\r\n{\r\n  DebugFail();\r\n}\r\n//---------------------------------------------------------------------------\r\nUnicodeString __fastcall TNullConsole::FinalLogMessage()\r\n{\r\n  return UnicodeString();\r\n}\r\n//---------------------------------------------------------------------------\r\nstatic UnicodeString TimestampVarName(L\"TIMESTAMP\");\r\n//---------------------------------------------------------------------------\r\nclass TConsoleRunner\r\n{\r\npublic:\r\n  TConsoleRunner(TConsole * Console);\r\n  ~TConsoleRunner();\r\n\r\n  int __fastcall Run(const UnicodeString Session, TOptions * Options,\r\n    TStrings * ScriptCommands, TStrings * ScriptParameters);\r\n  void __fastcall ShowException(Exception * E);\r\n  inline void __fastcall PrintMessage(const UnicodeString & Str, bool Error = false);\r\n\r\nprotected:\r\n  bool __fastcall DoInput(UnicodeString & Str, bool Echo, unsigned int Timer,\r\n    bool Interactive);\r\n  void __fastcall Input(const UnicodeString Prompt, UnicodeString & Str,\r\n    bool Echo, bool Interactive);\r\n  inline void __fastcall Print(const UnicodeString & Str, bool FromBeginning = false, bool Error = false);\r\n  void __fastcall UpdateTitle();\r\n  inline bool __fastcall NotifyAbort();\r\n  inline bool __fastcall Aborted(bool AllowCompleteAbort = true);\r\n  void __fastcall MasterPasswordPrompt();\r\n  void __fastcall DoShowException(TTerminal * Terminal, Exception * E);\r\n\r\nprivate:\r\n  TManagementScript * FScript;\r\n  TConsole * FConsole;\r\n  TSynchronizeController FSynchronizeController;\r\n  int FLastProgressLen;\r\n  bool FSynchronizeAborted;\r\n  bool FCommandError;\r\n  bool FBatchScript;\r\n  bool FAborted;\r\n  TTimer * Timer;\r\n  bool FExternalTimestampVar;\r\n\r\n  void __fastcall ScriptPrint(TScript * Script, const UnicodeString Str, bool Error);\r\n  void __fastcall ScriptPrintProgress(TScript * Script, bool First, const UnicodeString Str);\r\n  void __fastcall ScriptInput(TScript * Script, const UnicodeString Prompt, UnicodeString & Str);\r\n  void __fastcall ScriptTerminalPromptUser(TTerminal * Terminal,\r\n    TPromptKind Kind, UnicodeString Name, UnicodeString Instructions, TStrings * Prompts,\r\n    TStrings * Results, bool & Result, void * Arg);\r\n  void __fastcall ScriptShowExtendedException(TTerminal * Terminal,\r\n    Exception * E, void * Arg);\r\n  void __fastcall ScriptTerminalQueryUser(TObject * Sender, const UnicodeString Query,\r\n    TStrings * MoreMessages, unsigned int Answers, const TQueryParams * Params, unsigned int & Answer,\r\n    TQueryType QueryType, void * Arg);\r\n  void __fastcall ScriptQueryCancel(TScript * Script, bool & Cancel);\r\n  void __fastcall SynchronizeControllerAbort(TObject * Sender, bool Close);\r\n  void __fastcall SynchronizeControllerLog(TSynchronizeController * Controller,\r\n    TSynchronizeLogEntry Entry, const UnicodeString Message);\r\n  void __fastcall ScriptSynchronizeStartStop(TScript * Script,\r\n    const UnicodeString LocalDirectory, const UnicodeString RemoteDirectory,\r\n    const TCopyParamType & CopyParam, int SynchronizeParams);\r\n  void __fastcall SynchronizeControllerSynchronize(TSynchronizeController * Sender,\r\n    const UnicodeString LocalDirectory, const UnicodeString RemoteDirectory,\r\n    const TCopyParamType & CopyParam, const TSynchronizeParamType & Params,\r\n    TSynchronizeChecklist ** Checklist, TSynchronizeOptions * Options, bool Full);\r\n  void __fastcall SynchronizeControllerSynchronizeInvalid(TSynchronizeController * Sender,\r\n    const UnicodeString Directory, const UnicodeString ErrorStr);\r\n  void __fastcall SynchronizeControllerTooManyDirectories(TSynchronizeController * Sender,\r\n    int & MaxDirectories);\r\n  unsigned int InputTimeout();\r\n  void __fastcall TimerTimer(TObject * Sender);\r\n  UnicodeString ExpandCommand(UnicodeString Command, TStrings * ScriptParameters);\r\n  void __fastcall Failed(bool & AnyError);\r\n  void __fastcall ScriptProgress(TScript * Script, TScriptProgress & Progress);\r\n  void __fastcall ConfigurationChange(TObject * Sender);\r\n};\r\n//---------------------------------------------------------------------------\r\nTConsoleRunner::TConsoleRunner(TConsole * Console) :\r\n  FSynchronizeController(&SynchronizeControllerSynchronize,\r\n    &SynchronizeControllerSynchronizeInvalid,\r\n    &SynchronizeControllerTooManyDirectories)\r\n{\r\n  FConsole = Console;\r\n  FLastProgressLen = 0;\r\n  FScript = NULL;\r\n  FAborted = false;\r\n  FBatchScript = false;\r\n  Timer = new TTimer(Application);\r\n  Timer->OnTimer = TimerTimer;\r\n  Timer->Interval = MSecsPerSec;\r\n  Timer->Enabled = true;\r\n  DebugAssert(WinConfiguration->OnMasterPasswordPrompt == NULL);\r\n  WinConfiguration->OnMasterPasswordPrompt = MasterPasswordPrompt;\r\n  DebugAssert(Configuration->OnChange == NULL);\r\n  FExternalTimestampVar = !GetEnvironmentVariable(TimestampVarName).IsEmpty();\r\n  Configuration->OnChange = ConfigurationChange;\r\n  Configuration->Scripting = true;\r\n}\r\n//---------------------------------------------------------------------------\r\nTConsoleRunner::~TConsoleRunner()\r\n{\r\n  DebugAssert(WinConfiguration->OnMasterPasswordPrompt == MasterPasswordPrompt);\r\n  WinConfiguration->OnMasterPasswordPrompt = NULL;\r\n  DebugAssert(Configuration->OnChange == ConfigurationChange);\r\n  Configuration->OnChange = NULL;\r\n  delete Timer;\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TConsoleRunner::TimerTimer(TObject * /*Sender*/)\r\n{\r\n  // sole presence of timer causes message to be dispatched,\r\n  // hence breaks the loops\r\n}\r\n//---------------------------------------------------------------------------\r\nunsigned int TConsoleRunner::InputTimeout()\r\n{\r\n  return ((FScript != NULL) && (FScript->Batch != TScript::BatchOff) ? BATCH_INPUT_TIMEOUT : 0);\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TConsoleRunner::Input(\r\n  const UnicodeString Prompt, UnicodeString & Str, bool Echo, bool Interactive)\r\n{\r\n  Print(Prompt);\r\n\r\n  if (!DoInput(Str, Echo, InputTimeout(), Interactive))\r\n  {\r\n    Abort();\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TConsoleRunner::ScriptInput(TScript * /*Script*/,\r\n  const UnicodeString Prompt, UnicodeString & Str)\r\n{\r\n  Input(Prompt, Str, true, true);\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TConsoleRunner::Print(const UnicodeString & Str, bool FromBeginning, bool Error)\r\n{\r\n  if (FLastProgressLen > 0)\r\n  {\r\n    FConsole->Print(L\"\\n\" + Str, FromBeginning, Error);\r\n    FLastProgressLen = 0;\r\n  }\r\n  else\r\n  {\r\n    FConsole->Print(Str, FromBeginning, Error);\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TConsoleRunner::PrintMessage(const UnicodeString & Str, bool Error)\r\n{\r\n  UnicodeString Line = RemoveEmptyLines(Str);\r\n\r\n  if (FScript != NULL)\r\n  {\r\n    // this also logs the message\r\n    FScript->PrintLine(Line, Error);\r\n  }\r\n  else\r\n  {\r\n    FConsole->PrintLine(Line, Error);\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\nbool __fastcall TConsoleRunner::NotifyAbort()\r\n{\r\n  bool Result = FBatchScript;\r\n  if (Result)\r\n  {\r\n    FAborted = true;\r\n  }\r\n  return Result;\r\n}\r\n//---------------------------------------------------------------------------\r\nbool __fastcall TConsoleRunner::Aborted(bool AllowCompleteAbort)\r\n{\r\n  bool Result;\r\n  if (FAborted)\r\n  {\r\n    Result = true;\r\n  }\r\n  else\r\n  {\r\n    Result = FConsole->PendingAbort();\r\n    if (Result)\r\n    {\r\n      PrintMessage(LoadStr(USER_TERMINATED), true);\r\n\r\n      if (AllowCompleteAbort && NotifyAbort())\r\n      {\r\n        if (FScript->Terminal != NULL)\r\n        {\r\n          std::unique_ptr<TStringList> Failure(TextToStringList(LoadStr(USER_TERMINATED)));\r\n          FScript->Terminal->ActionLog->AddFailure(Failure.get());\r\n        }\r\n      }\r\n    }\r\n  }\r\n  return Result;\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TConsoleRunner::ScriptPrint(TScript * /*Script*/,\r\n  const UnicodeString Str, bool Error)\r\n{\r\n  Print(Str, false, Error);\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TConsoleRunner::ScriptPrintProgress(TScript * /*Script*/,\r\n  bool First, const UnicodeString Str)\r\n{\r\n  UnicodeString S = Str;\r\n  if (First && (FLastProgressLen > 0))\r\n  {\r\n    S = L\"\\n\" + S;\r\n  }\r\n  else if (S.Length() < FLastProgressLen)\r\n  {\r\n    int Padding = FLastProgressLen - S.Length();\r\n    S += UnicodeString::StringOfChar(L' ', Padding) +\r\n      UnicodeString::StringOfChar(L'\\b', Padding);\r\n  }\r\n  FConsole->Print(S, true);\r\n  FLastProgressLen = Str.Length();\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TConsoleRunner::ScriptTerminalPromptUser(TTerminal * /*Terminal*/,\r\n  TPromptKind /*Kind*/, UnicodeString Name, UnicodeString Instructions, TStrings * Prompts,\r\n  TStrings * Results, bool & Result, void * /*Arg*/)\r\n{\r\n  if (!Instructions.IsEmpty())\r\n  {\r\n    PrintMessage(Instructions);\r\n  }\r\n\r\n  // if there are no prompts, success is default\r\n  Result = true;\r\n\r\n  for (int Index = 0; Index < Prompts->Count; Index++)\r\n  {\r\n    UnicodeString Prompt = Prompts->Strings[Index];\r\n    if (!Prompt.IsEmpty() && (Prompt[Prompt.Length()] != L' '))\r\n    {\r\n      Prompt += L' ';\r\n    }\r\n    int P = Prompt.Pos(L'&');\r\n    if (P > 0)\r\n    {\r\n      Prompt.Delete(P, 1);\r\n    }\r\n    Print(Prompt);\r\n\r\n    UnicodeString AResult = Results->Strings[Index]; // useless\r\n    bool Echo = FLAGSET(int(Prompts->Objects[Index]), pupEcho);\r\n    Result = DoInput(AResult, Echo, InputTimeout(), true);\r\n    Results->Strings[Index] = AResult;\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TConsoleRunner::ScriptShowExtendedException(\r\n  TTerminal * Terminal, Exception * E, void * /*Arg*/)\r\n{\r\n  DoShowException(Terminal, E);\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TConsoleRunner::ScriptTerminalQueryUser(TObject * /*Sender*/,\r\n  const UnicodeString Query, TStrings * MoreMessages, unsigned int Answers,\r\n  const TQueryParams * Params, unsigned int & Answer, TQueryType /*QueryType*/,\r\n  void * /*Arg*/)\r\n{\r\n  UnicodeString AQuery = Query;\r\n  unsigned int Timer = 0;\r\n  unsigned int Timeout = 0;\r\n  unsigned int TimeoutA = 0;\r\n  unsigned int NoBatchA = 0;\r\n\r\n  if (Params != NULL)\r\n  {\r\n    if (Params->Timeout > 0)\r\n    {\r\n      Timeout = Params->Timeout;\r\n      TimeoutA = Params->TimeoutAnswer;\r\n    }\r\n\r\n    if (Params->Timer > 0)\r\n    {\r\n      Timer = Params->Timer;\r\n      if (Params->TimerAnswers > 0)\r\n      {\r\n        Answers = Params->TimerAnswers;\r\n      }\r\n      // not considering TimerQueryType as we do not use QueryType anyway\r\n      if (!Params->TimerMessage.IsEmpty())\r\n      {\r\n        AQuery = Params->TimerMessage;\r\n      }\r\n    }\r\n\r\n    if (FLAGSET(Params->Params, qpFatalAbort))\r\n    {\r\n      AQuery = FMTLOAD(WARN_FATAL_ERROR, (AQuery));\r\n    }\r\n\r\n    NoBatchA = Params->NoBatchAnswers;\r\n\r\n    if (FLAGSET(Params->Params, qpWaitInBatch))\r\n    {\r\n      DebugAssert(Timeout == 0);\r\n      Timeout = InputTimeout();\r\n      if (Timeout != 0)\r\n      {\r\n        // See a duplicate AbortAnswer call below\r\n        TimeoutA = AbortAnswer(Answers & ~NoBatchA);\r\n      }\r\n    }\r\n  }\r\n\r\n  AQuery = UnformatMessage(AQuery);\r\n  AQuery = RemoveInteractiveMsgTag(AQuery);\r\n\r\n  ApplyTabs(AQuery, L' ', NULL, NULL);\r\n\r\n  unsigned int AAnswers = Answers;\r\n\r\n  UnicodeString Message = AQuery;\r\n  PrintMessage(AQuery);\r\n  if ((MoreMessages != NULL) && (MoreMessages->Count > 0))\r\n  {\r\n    PrintMessage(MoreMessages->Text);\r\n    Message += L\"\\n\" + MoreMessages->Text;\r\n  }\r\n\r\n  std::vector<unsigned int> Buttons;\r\n  std::vector<UnicodeString> Captions;\r\n  std::vector<TButtonSubmitEvent> OnSubmits;\r\n\r\n  for (unsigned int Answer = qaFirst; Answer <= qaLast; Answer = Answer << 1)\r\n  {\r\n    if (FLAGSET(Answers, Answer))\r\n    {\r\n      UnicodeString Name; // unused\r\n      UnicodeString Caption;\r\n      AnswerNameAndCaption(Answer, Name, Caption);\r\n      Captions.push_back(Caption);\r\n      Buttons.push_back(Answer);\r\n      OnSubmits.push_back(NULL);\r\n      AAnswers -= Answer;\r\n    }\r\n  }\r\n\r\n  DebugUsedParam(AAnswers);\r\n  DebugAssert(AAnswers == 0);\r\n  DebugAssert(!Buttons.empty());\r\n\r\n  if ((Params != NULL) && (Params->Aliases != NULL))\r\n  {\r\n    for (unsigned int bi = 0; bi < Buttons.size(); bi++)\r\n    {\r\n      for (unsigned int ai = 0; ai < Params->AliasesCount; ai++)\r\n      {\r\n        if (Params->Aliases[ai].Button == Buttons[bi])\r\n        {\r\n          if (!Params->Aliases[ai].Alias.IsEmpty())\r\n          {\r\n            Captions[bi] = Params->Aliases[ai].Alias;\r\n          }\r\n          OnSubmits[bi] = Params->Aliases[ai].OnSubmit;\r\n          break;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  UnicodeString Accels;\r\n  for (unsigned int Index = 0; Index < Buttons.size(); Index++)\r\n  {\r\n    UnicodeString & Caption = Captions[Index];\r\n    int P = Caption.Pos(L'&');\r\n    if ((P > 0) && (P < Caption.Length()))\r\n    {\r\n      wchar_t Accel = AnsiUpperCase(Caption)[P + 1];\r\n      if (Accels.Pos(Accel) > 0)\r\n      {\r\n        Caption.Delete(P, 1);\r\n        Accels += L' ';\r\n      }\r\n      else\r\n      {\r\n        Accels += Accel;\r\n      }\r\n    }\r\n    else\r\n    {\r\n      Accels += L' ';\r\n    }\r\n  }\r\n\r\n  DebugAssert(Accels.Length() == static_cast<int>(Buttons.size()));\r\n  int NumberAccel = 0;\r\n  unsigned int CancelA = CancelAnswer(Answers);\r\n  int CancelIndex;\r\n  // AbortAnswer call duplicated in qpWaitInBatch branch above\r\n  unsigned int AbortA = AbortAnswer(Answers & ~NoBatchA);\r\n  int AbortIndex;\r\n  unsigned int ContinueA = ContinueAnswer(Answers & ~NoBatchA);\r\n  int ContinueIndex;\r\n  int TimeoutIndex = 0;\r\n\r\n  for (unsigned int Index = 0; Index < Buttons.size(); Index++)\r\n  {\r\n    UnicodeString & Caption = Captions[Index];\r\n\r\n    if (Accels[Index + 1] == L' ')\r\n    {\r\n      for (int Index2 = 1; Index2 <= Caption.Length(); Index2++)\r\n      {\r\n        wchar_t C = AnsiUpperCase(Caption)[Index2];\r\n        if (IsLetter(C) && (Accels.Pos(C) == 0))\r\n        {\r\n          Caption.Insert(L\"&\", Index2);\r\n          Accels[Index + 1] = C;\r\n          break;\r\n        }\r\n      }\r\n    }\r\n\r\n    if (Accels[Index + 1] == L' ')\r\n    {\r\n      for (int Index2 = 1; Index2 <= Caption.Length(); Index2++)\r\n      {\r\n        wchar_t C = AnsiUpperCase(Caption)[Index2];\r\n        if ((C != L' ') && (Accels.Pos(C) == 0))\r\n        {\r\n          Caption.Insert(L\"&\", Index2);\r\n          Accels[Index + 1] = C;\r\n          break;\r\n        }\r\n      }\r\n    }\r\n\r\n    if (Accels[Index + 1] == L' ')\r\n    {\r\n      NumberAccel++;\r\n      DebugAssert(NumberAccel <= 9);\r\n      Caption = FORMAT(L\"&%d%s\", (NumberAccel, Caption));\r\n      Accels[Index + 1] = Caption[2];\r\n    }\r\n\r\n    if (Buttons[Index] == CancelA)\r\n    {\r\n      CancelIndex = Index + 1;\r\n    }\r\n    if (Buttons[Index] == AbortA)\r\n    {\r\n      AbortIndex = Index + 1;\r\n    }\r\n    if (Buttons[Index] == ContinueA)\r\n    {\r\n      ContinueIndex = Index + 1;\r\n    }\r\n    if (Buttons[Index] == TimeoutA)\r\n    {\r\n      TimeoutIndex = Index + 1;\r\n    }\r\n  }\r\n\r\n  DebugAssert(Accels.Pos(L' ') == 0);\r\n\r\n  bool Timeouting = (Timeout > 0);\r\n  bool FirstOutput = true;\r\n\r\n  do\r\n  {\r\n    Answer = 0;\r\n    int AnswerIndex;\r\n    bool Retry;\r\n\r\n    do\r\n    {\r\n      Retry = false;\r\n\r\n      if (FirstOutput || FConsole->LiveOutput())\r\n      {\r\n        UnicodeString Output;\r\n        for (unsigned int i = 0; i < Buttons.size(); i++)\r\n        {\r\n          if (i > 0)\r\n          {\r\n            Output += L\", \";\r\n          }\r\n\r\n          UnicodeString Caption = Captions[i];\r\n          int P = Caption.Pos(L'&');\r\n          if (DebugAlwaysTrue(P >= 0))\r\n          {\r\n            Caption[P] = L'(';\r\n            Caption.Insert(L\")\", P + 2);\r\n          }\r\n\r\n          if (i + 1 == static_cast<unsigned int>(TimeoutIndex))\r\n          {\r\n            DebugAssert(Timeouting);\r\n            Caption = FMTLOAD(TIMEOUT_BUTTON, (Caption, int(Timeout / MSecsPerSec)));\r\n          }\r\n\r\n          Output += Caption;\r\n        }\r\n        Output += L\": \";\r\n\r\n        // note that length of string may decrease over time due to number of\r\n        // seconds length, but supposing it decreases by one character at time\r\n        // at most, we do not mind as the prompt is terminated with space\r\n\r\n        // If output is not live (file or pipe), do not use 'from beginning'\r\n        // as it means that the output is not actually stored until new line\r\n        // is sent (and we will not [because we cannot] rewrite the output anyway)\r\n        Print(Output, !FirstOutput);\r\n        FirstOutput = false;\r\n      }\r\n\r\n      if (!Timeouting && (FScript->Batch == TScript::BatchContinue))\r\n      {\r\n        AnswerIndex = ContinueIndex;\r\n      }\r\n      else if (!Timeouting && (FScript->Batch != TScript::BatchOff))\r\n      {\r\n        AnswerIndex = AbortIndex;\r\n      }\r\n      else if (Timeouting && (Timeout < MSecsPerSec))\r\n      {\r\n        AnswerIndex = TimeoutIndex;\r\n      }\r\n      else\r\n      {\r\n        unsigned int ActualTimer;\r\n        if (Timeouting)\r\n        {\r\n          if (Timer == 0)\r\n          {\r\n            if (FConsole->NoInteractiveInput())\r\n            {\r\n              ActualTimer = Timeout;\r\n            }\r\n            else\r\n            {\r\n              ActualTimer = MSecsPerSec;\r\n            }\r\n          }\r\n          else\r\n          {\r\n            if (Timer < MSecsPerSec)\r\n            {\r\n              ActualTimer = Timer;\r\n            }\r\n            else\r\n            {\r\n              ActualTimer = MSecsPerSec;\r\n            }\r\n          }\r\n        }\r\n        else\r\n        {\r\n          ActualTimer = Timer;\r\n        }\r\n        // Not to get preliminary \"host is not responding\" messages to .NET assembly\r\n        if (FConsole->NoInteractiveInput() && (Timer > 0))\r\n        {\r\n          Sleep(Timer);\r\n          AnswerIndex = -2;\r\n        }\r\n        else\r\n        {\r\n          AnswerIndex =\r\n            FConsole->Choice(Accels, CancelIndex, -1, ContinueIndex, -2, Timeouting, ActualTimer, Message);\r\n        }\r\n        if (AnswerIndex == -1)\r\n        {\r\n          NotifyAbort();\r\n          AnswerIndex = AbortIndex;\r\n        }\r\n        else if (AnswerIndex == -2)\r\n        {\r\n          if (Timeouting)\r\n          {\r\n            DebugAssert(Timeout >= MSecsPerSec);\r\n            Timeout -= ActualTimer;\r\n            Retry = true;\r\n          }\r\n\r\n          // this does not take Timer into account,\r\n          // but as of now Timer is used for TSecureShell timeout prompt only,\r\n          // where Timer is less than MSecsPerSec\r\n          if (Timer > 0)\r\n          {\r\n            DebugAssert((Params != NULL) && (Params->TimerEvent != NULL));\r\n            if ((Params != NULL) && (Params->TimerEvent != NULL))\r\n            {\r\n              unsigned int AAnswer = 0;\r\n              Params->TimerEvent(AAnswer);\r\n              if (AAnswer != 0)\r\n              {\r\n                Answer = AAnswer;\r\n                Retry = false;\r\n              }\r\n              else\r\n              {\r\n                Retry = true;\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n    while (Retry);\r\n\r\n    if (Answer == 0)\r\n    {\r\n      DebugAssert((AnswerIndex >= 1) && (AnswerIndex <= Accels.Length()));\r\n      UnicodeString AnswerCaption = Captions[AnswerIndex - 1];\r\n      int P = AnswerCaption.Pos(L\"&\");\r\n      DebugAssert(P >= 0);\r\n      AnswerCaption.Delete(P, 1);\r\n      FConsole->PrintLine(AnswerCaption);\r\n      FirstOutput = true;\r\n\r\n      if (OnSubmits[AnswerIndex - 1] != NULL)\r\n      {\r\n        OnSubmits[AnswerIndex - 1](NULL, Answer);\r\n      }\r\n      else\r\n      {\r\n        Answer = Buttons[AnswerIndex - 1];\r\n      }\r\n    }\r\n    else\r\n    {\r\n      FConsole->PrintLine();\r\n    }\r\n  }\r\n  while (Answer == 0);\r\n\r\n  if ((Answer == AbortA) &&\r\n      ((Params == NULL) || FLAGCLEAR(Params->Params, qpIgnoreAbort)))\r\n  {\r\n    if (FScript->Terminal != NULL)\r\n    {\r\n      TStrings * Messages = new TStringList();\r\n      try\r\n      {\r\n        Messages->Add(Query);\r\n        if (MoreMessages != NULL)\r\n        {\r\n          Messages->AddStrings(MoreMessages);\r\n        }\r\n        FScript->Terminal->ActionLog->AddFailure(Messages);\r\n      }\r\n      __finally\r\n      {\r\n        delete Messages;\r\n      }\r\n    }\r\n\r\n    FCommandError = true;\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TConsoleRunner::ScriptQueryCancel(TScript * /*Script*/, bool & Cancel)\r\n{\r\n  if (Aborted())\r\n  {\r\n    Cancel = true;\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TConsoleRunner::ScriptSynchronizeStartStop(TScript * /*Script*/,\r\n  const UnicodeString LocalDirectory, const UnicodeString RemoteDirectory,\r\n  const TCopyParamType & CopyParam, int SynchronizeParams)\r\n{\r\n  TSynchronizeParamType Params;\r\n  Params.LocalDirectory = LocalDirectory;\r\n  Params.RemoteDirectory = RemoteDirectory;\r\n  Params.Params = SynchronizeParams;\r\n  Params.Options = soRecurse;\r\n\r\n  FSynchronizeController.StartStop(Application, true, Params,\r\n    CopyParam, NULL, SynchronizeControllerAbort, NULL,\r\n    SynchronizeControllerLog);\r\n\r\n  try\r\n  {\r\n    FSynchronizeAborted = false;\r\n\r\n    while (!FSynchronizeAborted && !Aborted(false))\r\n    {\r\n      Application->HandleMessage();\r\n      FScript->Terminal->Idle();\r\n    }\r\n  }\r\n  __finally\r\n  {\r\n    FSynchronizeController.StartStop(Application, false, Params,\r\n      CopyParam, NULL, SynchronizeControllerAbort, NULL,\r\n      SynchronizeControllerLog);\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TConsoleRunner::ScriptProgress(TScript * /*Script*/, TScriptProgress & Progress)\r\n{\r\n  FConsole->Progress(Progress);\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TConsoleRunner::SynchronizeControllerLog(\r\n  TSynchronizeController * /*Controller*/, TSynchronizeLogEntry /*Entry*/,\r\n  const UnicodeString Message)\r\n{\r\n  PrintMessage(Message);\r\n  LogSynchronizeEvent(FScript->Terminal, Message);\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TConsoleRunner::SynchronizeControllerAbort(TObject * /*Sender*/,\r\n  bool /*Close*/)\r\n{\r\n  FSynchronizeAborted = true;\r\n  NotifyAbort();\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TConsoleRunner::SynchronizeControllerSynchronize(\r\n  TSynchronizeController * /*Sender*/, const UnicodeString LocalDirectory,\r\n  const UnicodeString RemoteDirectory, const TCopyParamType & CopyParam,\r\n  const TSynchronizeParamType & Params, TSynchronizeChecklist ** Checklist,\r\n  TSynchronizeOptions * /*Options*/, bool Full)\r\n{\r\n  if (!Full)\r\n  {\r\n    try\r\n    {\r\n      FScript->Synchronize(LocalDirectory, RemoteDirectory, CopyParam,\r\n        Params.Params, Checklist);\r\n    }\r\n    catch (Exception & E)\r\n    {\r\n      if ((FScript->Batch == TScript::BatchContinue) &&\r\n          FScript->Terminal->Active)\r\n      {\r\n        // noop\r\n      }\r\n      else\r\n      {\r\n        throw;\r\n      }\r\n    }\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TConsoleRunner::SynchronizeControllerSynchronizeInvalid(\r\n  TSynchronizeController * /*Sender*/, const UnicodeString Directory, const UnicodeString ErrorStr)\r\n{\r\n  if (!Directory.IsEmpty())\r\n  {\r\n    PrintMessage(FMTLOAD(WATCH_ERROR_DIRECTORY, (Directory)), true);\r\n  }\r\n  else\r\n  {\r\n    PrintMessage(LoadStr(WATCH_ERROR_GENERAL), true);\r\n  }\r\n\r\n  if (!ErrorStr.IsEmpty())\r\n  {\r\n    PrintMessage(ErrorStr, true);\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TConsoleRunner::SynchronizeControllerTooManyDirectories(\r\n  TSynchronizeController * /*Sender*/, int & MaxDirectories)\r\n{\r\n  if (Aborted())\r\n  {\r\n    Abort();\r\n  }\r\n\r\n  if (MaxDirectories < GUIConfiguration->MaxWatchDirectories)\r\n  {\r\n    MaxDirectories = GUIConfiguration->MaxWatchDirectories;\r\n  }\r\n  else\r\n  {\r\n    MaxDirectories *= 2;\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TConsoleRunner::ShowException(Exception * E)\r\n{\r\n  DoShowException(NULL, E);\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TConsoleRunner::DoShowException(TTerminal * Terminal, Exception * E)\r\n{\r\n  if ((Terminal == NULL) && (FScript != NULL))\r\n  {\r\n    Terminal = FScript->Terminal;\r\n  }\r\n\r\n  UnicodeString Message;\r\n  if (ExceptionFullMessage(E, Message))\r\n  {\r\n    FCommandError = true;\r\n    PrintMessage(Message, true);\r\n  }\r\n\r\n  TTerminal * LoggingTerminal = Terminal;\r\n  TSecondaryTerminal * SecondaryTerminal = dynamic_cast<TSecondaryTerminal *>(LoggingTerminal);\r\n  if (SecondaryTerminal != NULL)\r\n  {\r\n    LoggingTerminal = SecondaryTerminal->MainTerminal;\r\n  }\r\n\r\n  if (LoggingTerminal != NULL)\r\n  {\r\n    LoggingTerminal->ActionLog->AddFailure(E);\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\nbool __fastcall TConsoleRunner::DoInput(UnicodeString & Str, bool Echo,\r\n  unsigned int Timeout, bool Interactive)\r\n{\r\n  bool Result;\r\n  if (Interactive && FConsole->NoInteractiveInput())\r\n  {\r\n    Result = false;\r\n  }\r\n  else\r\n  {\r\n    Result = FConsole->Input(Str, Echo, Timeout);\r\n  }\r\n\r\n  if (!Result)\r\n  {\r\n    NotifyAbort();\r\n  }\r\n\r\n  return Result;\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TConsoleRunner::MasterPasswordPrompt()\r\n{\r\n  bool Retry;\r\n  do\r\n  {\r\n    UnicodeString Password;\r\n    Input(LoadStr(CONSOLE_MASTER_PASSWORD_PROMPT), Password, false, true);\r\n    Retry = !WinConfiguration->ValidateMasterPassword(Password);\r\n    if (Retry)\r\n    {\r\n      FConsole->PrintLine(LoadStr(MASTER_PASSWORD_INCORRECT));\r\n    }\r\n    else\r\n    {\r\n      WinConfiguration->SetMasterPassword(Password);\r\n    }\r\n  }\r\n  while (Retry);\r\n\r\n}\r\n//---------------------------------------------------------------------------\r\nUnicodeString TConsoleRunner::ExpandCommand(UnicodeString Command, TStrings * ScriptParameters)\r\n{\r\n  DebugAssert(ScriptParameters != NULL);\r\n  for (int Index = 0; Index < ScriptParameters->Count; Index++)\r\n  {\r\n    Command = ReplaceStr(Command, FORMAT(L\"%%%d%%\", (Index+1)),\r\n      ScriptParameters->Strings[Index]);\r\n  }\r\n\r\n  TDateTime N = Now();\r\n\r\n  if (!FExternalTimestampVar)\r\n  {\r\n    Command =\r\n      ReplaceStr(Command, FORMAT(L\"%%%s%%\", (TimestampVarName)), FormatDateTime(L\"yyyymmddhhnnss\", N));\r\n  }\r\n\r\n  int Offset = 1;\r\n  int P2;\r\n  do\r\n  {\r\n    int P = Pos(UpperCase(L\"%\" + TimestampVarName), UpperCase(Command), Offset);\r\n    if (P > 0)\r\n    {\r\n      Offset = P + 1 + TimestampVarName.Length();\r\n      P2 = Pos(L\"%\", Command, Offset);\r\n      int P3 = Pos(L\"#\", Command, Offset);\r\n      if ((P2 > 0) && (P3 > 0) && (P3 < P2) &&\r\n          ((P3 == Offset) || (Command[Offset] == L'+') || (Command[Offset] == L'-')))\r\n      {\r\n        bool Valid = true;\r\n        TDateTime T = N;\r\n        if (P3 > Offset)\r\n        {\r\n          bool Add = (Command[Offset] == L'+');\r\n          Offset++;\r\n          Valid = TryRelativeStrToDateTime(Command.SubString(Offset, P3 - Offset), T, Add);\r\n        }\r\n\r\n        Offset = P3 + 1;\r\n        if (Valid)\r\n        {\r\n          UnicodeString TimestampFormat = Command.SubString(Offset, P2 - Offset);\r\n          UnicodeString TimestampValue = FormatDateTime(TimestampFormat, T);\r\n          Command = Command.SubString(1, P - 1) + TimestampValue + Command.SubString(P2 + 1, Command.Length() - P2);\r\n          Offset = P + TimestampValue.Length();\r\n        }\r\n      }\r\n    }\r\n    else\r\n    {\r\n      P2 = 0;\r\n    }\r\n  }\r\n  while (P2 > 0);\r\n\r\n  Command = ExpandEnvironmentVariables(Command);\r\n  return Command;\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TConsoleRunner::Failed(bool & AnyError)\r\n{\r\n  if (FScript != NULL)\r\n  {\r\n    FScript->Log(llMessage, L\"Failed\");\r\n  }\r\n  AnyError = true;\r\n}\r\n//---------------------------------------------------------------------------\r\nint __fastcall TConsoleRunner::Run(const UnicodeString Session, TOptions * Options,\r\n  TStrings * ScriptCommands, TStrings * ScriptParameters)\r\n{\r\n  int ExitCode;\r\n  try\r\n  {\r\n    bool AnyError = false;\r\n\r\n    try\r\n    {\r\n      FScript = new TManagementScript(StoredSessions, FConsole->LimitedOutput());\r\n\r\n      FScript->CopyParam = GUIConfiguration->DefaultCopyParam;\r\n      FScript->SynchronizeParams = GUIConfiguration->SynchronizeParams;\r\n      FScript->WantsProgress = FConsole->WantsProgress();\r\n      FScript->OnPrint = ScriptPrint;\r\n      FScript->OnPrintProgress = ScriptPrintProgress;\r\n      FScript->OnInput = ScriptInput;\r\n      FScript->OnTerminalPromptUser = ScriptTerminalPromptUser;\r\n      FScript->OnShowExtendedException = ScriptShowExtendedException;\r\n      FScript->OnTerminalQueryUser = ScriptTerminalQueryUser;\r\n      FScript->OnQueryCancel = ScriptQueryCancel;\r\n      FScript->OnSynchronizeStartStop = ScriptSynchronizeStartStop;\r\n      FScript->OnProgress = ScriptProgress;\r\n      FScript->Interactive = (ScriptCommands == NULL) && FConsole->Interactive();\r\n\r\n      UpdateTitle();\r\n\r\n      // everything until the first manually entered command is \"batch\"\r\n      // (including opening session from command line and script file)\r\n      FBatchScript = true;\r\n\r\n      if (!Session.IsEmpty())\r\n      {\r\n        if (!FScript->Interactive)\r\n        {\r\n          PrintMessage(LoadStr(SCRIPT_CMDLINE_SESSION));\r\n        }\r\n        FCommandError = false;\r\n        FScript->Connect(Session, Options, false);\r\n        if (FCommandError)\r\n        {\r\n          Failed(AnyError);\r\n        }\r\n      }\r\n\r\n      FScript->Groups = Options->SwitchValue(L\"xmlgroups\", true, false);\r\n\r\n      int ScriptPos = 0;\r\n      bool Result;\r\n      do\r\n      {\r\n        UpdateTitle();\r\n\r\n        UnicodeString Command;\r\n        if ((ScriptCommands != NULL) && (ScriptPos < ScriptCommands->Count))\r\n        {\r\n          Result = true;\r\n          Command = ScriptCommands->Strings[ScriptPos];\r\n          ScriptPos++;\r\n        }\r\n        else\r\n        {\r\n          if (FBatchScript)\r\n          {\r\n            // no longer batch\r\n            FBatchScript = false;\r\n            FScript->StartInteractive();\r\n          }\r\n          Print(L\"winscp> \");\r\n          Result = DoInput(Command, true, 0, false);\r\n        }\r\n\r\n        if (Result)\r\n        {\r\n          FCommandError = false;\r\n          FScript->Command(ExpandCommand(Command, ScriptParameters));\r\n\r\n          if (FCommandError)\r\n          {\r\n            Failed(AnyError);\r\n            if (FScript->Batch == TScript::BatchAbort)\r\n            {\r\n              Result = false;\r\n            }\r\n          }\r\n\r\n          if (FScript->Terminal != NULL)\r\n          {\r\n            FScript->Terminal->Idle();\r\n          }\r\n        }\r\n      }\r\n      while (Result && FScript->Continue && !Aborted());\r\n    }\r\n    catch(Exception & E)\r\n    {\r\n      Failed(AnyError);\r\n      ShowException(&E);\r\n    }\r\n\r\n    if (FLastProgressLen > 0)\r\n    {\r\n      FConsole->Print(L\"\\n\");\r\n      FLastProgressLen = 0;\r\n    }\r\n\r\n    ExitCode = (AnyError || FAborted) ? RESULT_ANY_ERROR : RESULT_SUCCESS;\r\n\r\n    if (FScript != NULL)\r\n    {\r\n      UnicodeString ExitCodeMessage = FORMAT(L\"Exit code: %d\", (ExitCode));\r\n      FScript->Log(llMessage, ExitCodeMessage);\r\n      if (Configuration->LogProtocol >= 1)\r\n      {\r\n        FConsole->Print(ExitCodeMessage + L\"\\n\");\r\n        UnicodeString LogMessage = FConsole->FinalLogMessage();\r\n        if (!LogMessage.IsEmpty())\r\n        {\r\n          FScript->Log(llMessage, LogMessage);\r\n          FConsole->Print(LogMessage + L\"\\n\");\r\n        }\r\n      }\r\n    }\r\n  }\r\n  __finally\r\n  {\r\n    delete FScript;\r\n    FScript = NULL;\r\n  }\r\n\r\n  return ExitCode;\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TConsoleRunner::UpdateTitle()\r\n{\r\n  UnicodeString NewTitle;\r\n  if (FScript->Terminal != NULL)\r\n  {\r\n    NewTitle = FormatMainFormCaption(FScript->Terminal->SessionData->SessionName);\r\n  }\r\n  else\r\n  {\r\n    NewTitle = FormatMainFormCaption(L\"\");\r\n  }\r\n  FConsole->SetTitle(NewTitle);\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TConsoleRunner::ConfigurationChange(TObject * /*Sender*/)\r\n{\r\n  if (FScript != NULL)\r\n  {\r\n    FScript->ReflectSettings();\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\nstatic UnicodeString __fastcall GetExeBaseName()\r\n{\r\n  return ExtractFileBaseName(Application->ExeName);\r\n}\r\n//---------------------------------------------------------------------------\r\nstatic void __fastcall PrintUsageSyntax(TConsole * Console, const UnicodeString & Str)\r\n{\r\n  Console->PrintLine(GetExeBaseName() + L\" \" + Str);\r\n}\r\n//---------------------------------------------------------------------------\r\ntypedef std::vector<std::pair<UnicodeString, UnicodeString> > TSwitchesUsage;\r\n//---------------------------------------------------------------------------\r\nstatic void __fastcall RegisterSwitch(\r\n  TSwitchesUsage & SwitchesUsage, const UnicodeString & Name, const UnicodeString & Desc)\r\n{\r\n  SwitchesUsage.push_back(std::make_pair(LowerCase(Name), Desc));\r\n}\r\n//---------------------------------------------------------------------------\r\nstatic void __fastcall RegisterSwitch(\r\n  TSwitchesUsage & SwitchesUsage, const UnicodeString & Name, int DescID)\r\n{\r\n  UnicodeString Desc = LoadStr(DescID);\r\n  Desc = ReplaceText(Desc, L\"%APP%\", GetExeBaseName());\r\n  RegisterSwitch(SwitchesUsage, Name, Desc);\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall Usage(TConsole * Console)\r\n{\r\n  Console->PrintLine(FORMAT(L\"WinSCP, %s\", (Configuration->VersionStr)));\r\n  UnicodeString Copyright =\r\n    ReplaceText(LoadStr(WINSCP_COPYRIGHT), L\"\u00a9\", L\"(c)\");\r\n  Console->PrintLine(Copyright);\r\n  Console->PrintLine();\r\n  Console->PrintLine(LoadStr(USAGE_SYNTAX_LABEL));\r\n\r\n  if (!Console->CommandLineOnly())\r\n  {\r\n    PrintUsageSyntax(Console, L\"site|workspace|folder\");\r\n    PrintUsageSyntax(Console, L\"(sftp|scp|ftp[es]|dav[s]|s3)://[user[:password]@]host[:port][/path/[file]]\");\r\n    PrintUsageSyntax(Console, FORMAT(L\"[mysession] /%s=<name>\", (LowerCase(SESSIONNAME_SWICH))));\r\n    PrintUsageSyntax(Console, L\"[mysession] /newinstance\");\r\n    PrintUsageSyntax(Console, L\"[mysession] /edit <path>\");\r\n    PrintUsageSyntax(Console, FORMAT(L\"[mysession] /%s[=<file>]\", (LowerCase(BROWSE_SWITCH))));\r\n    PrintUsageSyntax(Console, FORMAT(L\"[mysession] /%s [local_dir] [remote_dir] [/%s]\", (LowerCase(SYNCHRONIZE_SWITCH), LowerCase(DEFAULTS_SWITCH))));\r\n    PrintUsageSyntax(Console, FORMAT(L\"[mysession] /%s [local_dir] [remote_dir] [/%s]\", (LowerCase(KEEP_UP_TO_DATE_SWITCH), LowerCase(DEFAULTS_SWITCH))));\r\n    PrintUsageSyntax(Console, FORMAT(L\"[mysession] /%s [path]\", (LowerCase(REFRESH_SWITCH))));\r\n    PrintUsageSyntax(Console, FORMAT(L\"[mysession] [/privatekey=<file> [/%s=<passphrase>]]\", (PassphraseOption)));\r\n    PrintUsageSyntax(Console, L\"[mysession] [/hostkey=<fingerprint>]\");\r\n    PrintUsageSyntax(Console, FORMAT(L\"[mysession] [/clientcert=<file> [/%s=<passphrase>]]\", (PassphraseOption)));\r\n    PrintUsageSyntax(Console, L\"[mysession] [/certificate=<fingerprint>]\");\r\n    PrintUsageSyntax(Console, L\"[mysession] [/passive[=on|off]] [/implicit|explicit]\");\r\n    PrintUsageSyntax(Console, L\"[mysession] [/timeout=<sec>]\");\r\n    PrintUsageSyntax(Console, L\"[mysession] [/rawsettings setting1=value1 setting2=value2 ...]\");\r\n  }\r\n  PrintUsageSyntax(Console,\r\n    UnicodeString(!Console->CommandLineOnly() ? L\"[/console] \" : L\"\") +\r\n    FORMAT(L\"[/script=<file>] [/%s cmd1...] [/parameter // param1...]\", (LowerCase(COMMAND_SWITCH))));\r\n  PrintUsageSyntax(Console,\r\n    FORMAT(L\"[/%s=<logfile> [/loglevel=<level>]] [/%s=[<count>%s]<size>]\", (LowerCase(LOG_SWITCH), LowerCase(LOGSIZE_SWITCH), LOGSIZE_SEPARATOR)));\r\n  PrintUsageSyntax(Console, L\"[/xmllog=<logfile> [/xmlgroups]]\");\r\n  PrintUsageSyntax(Console,\r\n    FORMAT(L\"[/%s=<inifile>]\", (LowerCase(INI_SWITCH))));\r\n  PrintUsageSyntax(Console, FORMAT(L\"[/%s config1=value1 config2=value2 ...]\", (LowerCase(RAW_CONFIG_SWITCH))));\r\n  PrintUsageSyntax(Console, FORMAT(L\"[/%s setting1=value1 setting2=value2 ...]\", (LowerCase(RAWTRANSFERSETTINGS_SWITCH))));\r\n  PrintUsageSyntax(Console, L\"/batchsettings <site_mask> setting1=value1 setting2=value2 ...\");\r\n  PrintUsageSyntax(Console, FORMAT(L\"/%s keyfile [/%s=<file>] [/%s] [/%s=<text>]\",\r\n    (LowerCase(KEYGEN_SWITCH), LowerCase(KEYGEN_OUTPUT_SWITCH), LowerCase(KEYGEN_CHANGE_PASSPHRASE_SWITCH), LowerCase(KEYGEN_COMMENT_SWITCH))));\r\n  if (!Console->CommandLineOnly())\r\n  {\r\n    PrintUsageSyntax(Console, L\"/update\");\r\n  }\r\n  PrintUsageSyntax(Console, TProgramParams::FormatSwitch(LowerCase(INFO_SWITCH)));\r\n  PrintUsageSyntax(Console, L\"/help\");\r\n\r\n  Console->PrintLine();\r\n\r\n  TSwitchesUsage SwitchesUsage;\r\n  if (!Console->CommandLineOnly())\r\n  {\r\n    RegisterSwitch(SwitchesUsage, L\"session\", USAGE_SESSION);\r\n    RegisterSwitch(SwitchesUsage, TProgramParams::FormatSwitch(SESSIONNAME_SWICH) + L\"=\", USAGE_SESSIONNAME);\r\n    RegisterSwitch(SwitchesUsage, L\"/newinstance\", USAGE_NEWINSTANCE);\r\n    RegisterSwitch(SwitchesUsage, L\"/edit\", USAGE_EDIT);\r\n    RegisterSwitch(SwitchesUsage, TProgramParams::FormatSwitch(BROWSE_SWITCH), USAGE_BROWSE);\r\n    RegisterSwitch(SwitchesUsage, TProgramParams::FormatSwitch(SYNCHRONIZE_SWITCH), USAGE_SYNCHRONIZE);\r\n    RegisterSwitch(SwitchesUsage, TProgramParams::FormatSwitch(KEEP_UP_TO_DATE_SWITCH), USAGE_KEEPUPTODATE);\r\n    RegisterSwitch(SwitchesUsage, TProgramParams::FormatSwitch(REFRESH_SWITCH), USAGE_REFRESH);\r\n    RegisterSwitch(SwitchesUsage, TProgramParams::FormatSwitch(DEFAULTS_SWITCH), USAGE_DEFAULTS);\r\n    RegisterSwitch(SwitchesUsage, L\"/privatekey=\", USAGE_PRIVATEKEY);\r\n    RegisterSwitch(SwitchesUsage, L\"/hostkey=\", USAGE_HOSTKEY);\r\n    RegisterSwitch(SwitchesUsage, L\"/clientcert=\", USAGE_CLIENTCERT);\r\n    RegisterSwitch(SwitchesUsage, L\"/certificate=\", USAGE_CERTIFICATE);\r\n    RegisterSwitch(SwitchesUsage, TProgramParams::FormatSwitch(PassphraseOption) + L\"=\", USAGE_PASSPHRASE);\r\n    RegisterSwitch(SwitchesUsage, L\"/passive=\", USAGE_PASSIVE);\r\n    RegisterSwitch(SwitchesUsage, L\"/implicit\", USAGE_IMPLICIT);\r\n    RegisterSwitch(SwitchesUsage, L\"/explicit\", USAGE_EXPLICIT);\r\n    RegisterSwitch(SwitchesUsage, L\"/timeout=\", USAGE_TIMEOUT);\r\n    RegisterSwitch(SwitchesUsage, L\"/rawsettings\", USAGE_RAWSETTINGS);\r\n    RegisterSwitch(SwitchesUsage, L\"/console\", USAGE_CONSOLE);\r\n  }\r\n  RegisterSwitch(SwitchesUsage, L\"/script=\", USAGE_SCRIPT);\r\n  RegisterSwitch(SwitchesUsage, TProgramParams::FormatSwitch(COMMAND_SWITCH), USAGE_COMMAND);\r\n  RegisterSwitch(SwitchesUsage, L\"/parameter\", USAGE_PARAMETER);\r\n  RegisterSwitch(SwitchesUsage, TProgramParams::FormatSwitch(LOG_SWITCH) + L\"=\", USAGE_LOG);\r\n  RegisterSwitch(SwitchesUsage, L\"/loglevel=\", USAGE_LOGLEVEL);\r\n  RegisterSwitch(SwitchesUsage, TProgramParams::FormatSwitch(LOGSIZE_SWITCH) + L\"=\", USAGE_LOGSIZE);\r\n  RegisterSwitch(SwitchesUsage, L\"/xmllog=\", USAGE_XMLLOG);\r\n  RegisterSwitch(SwitchesUsage, L\"/xmlgroups\", USAGE_XMLGROUPS);\r\n  RegisterSwitch(SwitchesUsage, TProgramParams::FormatSwitch(INI_SWITCH) + L\"=\", USAGE_INI);\r\n  RegisterSwitch(SwitchesUsage, TProgramParams::FormatSwitch(RAW_CONFIG_SWITCH), USAGE_RAWCONFIG);\r\n  RegisterSwitch(SwitchesUsage, TProgramParams::FormatSwitch(RAWTRANSFERSETTINGS_SWITCH), USAGE_RAWTRANSFERSETTINGS);\r\n  RegisterSwitch(SwitchesUsage, L\"/batchsettings\", USAGE_BATCHSETTINGS);\r\n  UnicodeString KeyGenDesc =\r\n    FMTLOAD(USAGE_KEYGEN, (\r\n      TProgramParams::FormatSwitch(LowerCase(KEYGEN_OUTPUT_SWITCH)) + L\"=\",\r\n      TProgramParams::FormatSwitch(LowerCase(KEYGEN_CHANGE_PASSPHRASE_SWITCH)),\r\n      TProgramParams::FormatSwitch(LowerCase(KEYGEN_COMMENT_SWITCH)) + L\"=\"));\r\n  RegisterSwitch(SwitchesUsage, TProgramParams::FormatSwitch(KEYGEN_SWITCH), KeyGenDesc);\r\n  if (!Console->CommandLineOnly())\r\n  {\r\n    RegisterSwitch(SwitchesUsage, L\"/update\", USAGE_UPDATE);\r\n  }\r\n  RegisterSwitch(SwitchesUsage, TProgramParams::FormatSwitch(INFO_SWITCH), USAGE_INFO);\r\n  RegisterSwitch(SwitchesUsage, L\"/help\", USAGE_HELP);\r\n\r\n  int MaxSwitchLen = 0;\r\n  TSwitchesUsage::const_iterator Index = SwitchesUsage.begin();\r\n  while (Index != SwitchesUsage.end())\r\n  {\r\n    MaxSwitchLen = std::max(Index->first.Length(), MaxSwitchLen);\r\n    ++Index;\r\n  }\r\n\r\n  Index = SwitchesUsage.begin();\r\n  while (Index != SwitchesUsage.end())\r\n  {\r\n    UnicodeString Label =\r\n      UnicodeString(L\" \") +\r\n      Index->first +\r\n      UnicodeString::StringOfChar(L' ', MaxSwitchLen - Index->first.Length()) +\r\n      L\" \";\r\n    Console->Print(Label);\r\n\r\n    const int ConsoleWidth = 80;\r\n    int DescWidth = ConsoleWidth - Label.Length() - 1;\r\n\r\n    bool FirstLine = true;\r\n    UnicodeString Desc = Index->second;\r\n    while (!Desc.IsEmpty())\r\n    {\r\n      UnicodeString DescLine = CutToChar(Desc, L'\\n', true);\r\n      DescLine = WrapText(DescLine, L\"\\n\", TSysCharSet() << L' ', DescWidth);\r\n      while (!DescLine.IsEmpty())\r\n      {\r\n        UnicodeString DescLineLine = CutToChar(DescLine, L'\\n', true);\r\n        if (!FirstLine)\r\n        {\r\n          DescLineLine =\r\n            UnicodeString::StringOfChar(L' ', Label.Length()) +\r\n            DescLineLine;\r\n        }\r\n        FirstLine = false;\r\n        Console->PrintLine(DescLineLine);\r\n      }\r\n    }\r\n    ++Index;\r\n  }\r\n\r\n  Console->WaitBeforeExit();\r\n}\r\n//---------------------------------------------------------------------------\r\nint __fastcall HandleException(TConsole * Console, Exception & E)\r\n{\r\n  UnicodeString Message;\r\n  if (ExceptionFullMessage(&E, Message))\r\n  {\r\n    Console->Print(Message);\r\n  }\r\n  return RESULT_ANY_ERROR;\r\n}\r\n//---------------------------------------------------------------------------\r\nint __fastcall BatchSettings(TConsole * Console, TProgramParams * Params)\r\n{\r\n  int Result = RESULT_SUCCESS;\r\n  try\r\n  {\r\n    std::unique_ptr<TStrings> Arguments(new TStringList());\r\n    if (!DebugAlwaysTrue(Params->FindSwitch(L\"batchsettings\", Arguments.get())))\r\n    {\r\n      Abort();\r\n    }\r\n    else\r\n    {\r\n      if (Arguments->Count < 1)\r\n      {\r\n        throw Exception(LoadStr(BATCH_SET_NO_MASK));\r\n      }\r\n      else if (Arguments->Count < 2)\r\n      {\r\n        throw Exception(LoadStr(BATCH_SET_NO_SETTINGS));\r\n      }\r\n      else\r\n      {\r\n        TFileMasks Mask(Arguments->Strings[0]);\r\n        Arguments->Delete(0);\r\n\r\n        std::unique_ptr<TOptionsStorage> OptionsStorage(new TOptionsStorage(Arguments.get(), false));\r\n\r\n        int Matches = 0;\r\n        int Changes = 0;\r\n\r\n        for (int Index = 0; Index < StoredSessions->Count; Index++)\r\n        {\r\n          TSessionData * Data = StoredSessions->Sessions[Index];\r\n          if (!Data->IsWorkspace &&\r\n              Mask.Matches(Data->Name, false, false))\r\n          {\r\n            Matches++;\r\n            std::unique_ptr<TSessionData> OriginalData(new TSessionData(L\"\"));\r\n            OriginalData->CopyDataNoRecrypt(Data);\r\n            Data->ApplyRawSettings(OptionsStorage.get());\r\n            bool Changed = !OriginalData->IsSame(Data, false);\r\n            if (Changed)\r\n            {\r\n              Changes++;\r\n            }\r\n            UnicodeString StateStr = LoadStr(Changed ? BATCH_SET_CHANGED : BATCH_SET_NOT_CHANGED);\r\n            Console->PrintLine(FORMAT(L\"%s - %s\", (Data->Name, StateStr)));\r\n          }\r\n        }\r\n\r\n        StoredSessions->Save(false, true); // explicit\r\n        Console->PrintLine(FMTLOAD(BATCH_SET_SUMMARY, (Matches, Changes)));\r\n      }\r\n    }\r\n  }\r\n  catch (Exception & E)\r\n  {\r\n    Result = HandleException(Console, E);\r\n  }\r\n\r\n  Console->WaitBeforeExit();\r\n  return Result;\r\n}\r\n//---------------------------------------------------------------------------\r\nbool __fastcall FindPuttygenCompatibleSwitch(\r\n  TProgramParams * Params, const UnicodeString & Name, const UnicodeString & PuttygenName, UnicodeString & Value, bool & Set)\r\n{\r\n  bool Result = Params->FindSwitch(Name, Value, Set);\r\n  if (!Result)\r\n  {\r\n    std::unique_ptr<TStrings> Args(new TStringList());\r\n    Result = Params->FindSwitchCaseSensitive(PuttygenName, Args.get(), 1);\r\n    if (Result && (Args->Count >= 1))\r\n    {\r\n      Value = Args->Strings[0];\r\n      Set = true;\r\n    }\r\n  }\r\n  return Result;\r\n}\r\n//---------------------------------------------------------------------------\r\nint __fastcall KeyGen(TConsole * Console, TProgramParams * Params)\r\n{\r\n  int Result = RESULT_SUCCESS;\r\n  UnicodeString Passphrase;\r\n  UnicodeString NewPassphrase;\r\n  try\r\n  {\r\n    UnicodeString InputFileName;\r\n    std::unique_ptr<TStrings> Args(new TStringList());\r\n    if (!Params->FindSwitch(KEYGEN_SWITCH, Args.get(), 1) ||\r\n        (Args->Count < 1) ||\r\n        Args->Strings[0].IsEmpty())\r\n    {\r\n      throw Exception(LoadStr(KEYGEN_NO_INPUT));\r\n    }\r\n    InputFileName = Args->Strings[0];\r\n\r\n    bool ValueSet;\r\n    UnicodeString OutputFileName;\r\n    FindPuttygenCompatibleSwitch(Params, KEYGEN_OUTPUT_SWITCH, L\"o\", OutputFileName, ValueSet);\r\n\r\n    UnicodeString NewComment;\r\n    FindPuttygenCompatibleSwitch(Params, KEYGEN_COMMENT_SWITCH, L\"C\", NewComment, ValueSet);\r\n\r\n    bool NewPassphraseSet;\r\n    bool ChangePassphrase =\r\n      FindPuttygenCompatibleSwitch(Params, KEYGEN_CHANGE_PASSPHRASE_SWITCH, L\"P\", NewPassphrase, NewPassphraseSet);\r\n\r\n    TKeyType Type = KeyType(InputFileName);\r\n    int Error = errno;\r\n    switch (Type)\r\n    {\r\n      case ktSSH1:\r\n        throw Exception(LoadStr(KEYGEN_SSH1));\r\n\r\n      case ktSSH2:\r\n        if (NewComment.IsEmpty() && !ChangePassphrase)\r\n        {\r\n          throw Exception(LoadStr(KEYGEN_NO_ACTION));\r\n        }\r\n        break;\r\n\r\n      case ktOpenSSHPEM:\r\n      case ktOpenSSHNew:\r\n      case ktSSHCom:\r\n        if (OutputFileName.IsEmpty())\r\n        {\r\n          throw Exception(LoadStr(KEYGEN_NO_OUTPUT));\r\n        }\r\n        break;\r\n\r\n      case ktSSH1Public:\r\n      case ktSSH2PublicRFC4716:\r\n      case ktSSH2PublicOpenSSH:\r\n        throw Exception(LoadStr(KEYGEN_PUBLIC));\r\n\r\n      case ktUnopenable:\r\n        throw EOSExtException(FMTLOAD(KEY_TYPE_UNOPENABLE, (InputFileName)), Error);\r\n\r\n      case ktOpenSSHAuto:\r\n      default:\r\n        DebugFail();\r\n        // fallthru\r\n      case ktUnknown:\r\n        throw Exception(FMTLOAD(KEY_TYPE_UNKNOWN2, (InputFileName)));\r\n    }\r\n\r\n    UnicodeString Comment;\r\n    if (IsKeyEncrypted(Type, InputFileName, Comment))\r\n    {\r\n      Passphrase = Params->SwitchValue(PassphraseOption);\r\n      if (Passphrase.IsEmpty())\r\n      {\r\n        Console->Print(StripHotkey(FMTLOAD(PROMPT_KEY_PASSPHRASE, (Comment))) + L\" \");\r\n        if (!Console->Input(Passphrase, false, 0) ||\r\n            Passphrase.IsEmpty())\r\n        {\r\n          Abort();\r\n        }\r\n      }\r\n    }\r\n\r\n    TPrivateKey * PrivateKey = LoadKey(Type, InputFileName, Passphrase);\r\n\r\n    try\r\n    {\r\n      if (!NewComment.IsEmpty())\r\n      {\r\n        ChangeKeyComment(PrivateKey, NewComment);\r\n      }\r\n\r\n      if (ChangePassphrase)\r\n      {\r\n        if (!NewPassphraseSet)\r\n        {\r\n          Console->Print(LoadStr(KEYGEN_PASSPHRASE) + L\" \");\r\n          if (!Console->Input(NewPassphrase, false, 0))\r\n          {\r\n            Abort();\r\n          }\r\n\r\n          Console->Print(LoadStr(KEYGEN_PASSPHRASE2) + L\" \");\r\n          UnicodeString NewPassphrase2;\r\n          if (!Console->Input(NewPassphrase2, false, 0))\r\n          {\r\n            Abort();\r\n          }\r\n\r\n          if (NewPassphrase != NewPassphrase2)\r\n          {\r\n            Shred(NewPassphrase2);\r\n            throw Exception(LoadStr(KEYGEN_PASSPHRASES_MISMATCH));\r\n          }\r\n        }\r\n      }\r\n      else\r\n      {\r\n        NewPassphrase = Passphrase;\r\n      }\r\n\r\n      if (OutputFileName.IsEmpty())\r\n      {\r\n        OutputFileName = InputFileName;\r\n      }\r\n\r\n      SaveKey(ktSSH2, OutputFileName, NewPassphrase, PrivateKey);\r\n\r\n      Console->PrintLine(FMTLOAD(KEYGEN_SAVED, (OutputFileName)));\r\n    }\r\n    __finally\r\n    {\r\n      FreeKey(PrivateKey);\r\n    }\r\n  }\r\n  catch (Exception & E)\r\n  {\r\n    Result = HandleException(Console, E);\r\n  }\r\n\r\n  Shred(Passphrase);\r\n  Shred(NewPassphrase);\r\n\r\n  Console->WaitBeforeExit();\r\n  return Result;\r\n}\r\n//---------------------------------------------------------------------------\r\nint __fastcall FingerprintScan(TConsole * Console, TProgramParams * Params)\r\n{\r\n  int Result = RESULT_SUCCESS;\r\n  try\r\n  {\r\n    CheckLogParam(Params);\r\n\r\n    std::unique_ptr<TSessionData> SessionData;\r\n\r\n    if (Params->ParamCount > 0)\r\n    {\r\n      UnicodeString SessionUrl = Params->Param[1];\r\n      bool DefaultsOnly;\r\n      SessionData.reset(StoredSessions->ParseUrl(SessionUrl, Params, DefaultsOnly));\r\n      if (DefaultsOnly || !SessionData->CanLogin ||\r\n          (!SessionData->UsesSsh && (SessionData->Ftps == ftpsNone)))\r\n      {\r\n        SessionData.reset(NULL);\r\n      }\r\n    }\r\n\r\n    if (!SessionData)\r\n    {\r\n      throw Exception(LoadStr(FINGERPRINTSCAN_NEED_SECURE_SESSION));\r\n    }\r\n\r\n    std::unique_ptr<TTerminal> Terminal(new TTerminal(SessionData.get(), Configuration));\r\n    UnicodeString SHA256;\r\n    UnicodeString SHA1;\r\n    UnicodeString MD5;\r\n    Terminal->FingerprintScan(SHA256, SHA1, MD5);\r\n    if (!SHA256.IsEmpty())\r\n    {\r\n      Console->PrintLine(FORMAT(L\"SHA-256: %s\", (SHA256)));\r\n    }\r\n    if (!SHA1.IsEmpty())\r\n    {\r\n      Console->PrintLine(FORMAT(L\"SHA-1: %s\", (SHA1)));\r\n    }\r\n    if (!MD5.IsEmpty())\r\n    {\r\n      Console->PrintLine(FORMAT(L\"MD5:     %s\", (MD5)));\r\n    }\r\n  }\r\n  catch (Exception & E)\r\n  {\r\n    Result = HandleException(Console, E);\r\n  }\r\n\r\n  Console->WaitBeforeExit();\r\n  return Result;\r\n}\r\n//---------------------------------------------------------------------------\r\nint __fastcall DumpCallstack(TConsole * Console, TProgramParams * Params)\r\n{\r\n  int Result = RESULT_SUCCESS;\r\n  try\r\n  {\r\n    int ProcessId = StrToInt(Params->SwitchValue(DUMPCALLSTACK_SWITCH));\r\n    UnicodeString EventName = DumpCallstackEventName(ProcessId);\r\n    UnicodeString FileName = DumpCallstackFileName(ProcessId);\r\n    if (FileExists(FileName))\r\n    {\r\n      DeleteFileChecked(FileName);\r\n    }\r\n\r\n    HANDLE Event = OpenEvent(EVENT_ALL_ACCESS, false, EventName.c_str());\r\n    if (Event == NULL)\r\n    {\r\n      throw ExtException(FORMAT(L\"Error communicating with process %d.\", (ProcessId)), LastSysErrorMessage());\r\n    }\r\n\r\n    SetEvent(Event);\r\n    CloseHandle(Event);\r\n\r\n    Console->PrintLine(FORMAT(L\"Requested callstack dump for process %d...\", (ProcessId)));\r\n\r\n    int Timeout = 30;\r\n    while (!FileExists(FileName))\r\n    {\r\n      Sleep(1000);\r\n      Timeout--;\r\n      if (Timeout == 0)\r\n      {\r\n        throw Exception(L\"Timeout\");\r\n      }\r\n    }\r\n\r\n    Console->PrintLine(FORMAT(L\"Callstack dumped to file \\\"%s\\\".\", (FileName)));\r\n  }\r\n  catch (Exception & E)\r\n  {\r\n    Result = HandleException(Console, E);\r\n  }\r\n\r\n  Console->WaitBeforeExit();\r\n  return Result;\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid static PrintList(TConsole * Console, const UnicodeString & Caption, TStrings * List)\r\n{\r\n  Console->PrintLine(Caption);\r\n  for (int Index = 0; Index < List->Count; Index++)\r\n  {\r\n    Console->PrintLine(List->Strings[Index]);\r\n  }\r\n  Console->PrintLine();\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid static PrintListAndFree(TConsole * Console, const UnicodeString & Caption, TStrings * List)\r\n{\r\n  std::unique_ptr<TStrings> Owner(List);\r\n  PrintList(Console, Caption, List);\r\n}\r\n//---------------------------------------------------------------------------\r\nint Info(TConsole * Console)\r\n{\r\n  int Result = RESULT_SUCCESS;\r\n  try\r\n  {\r\n    PrintListAndFree(Console, L\"SSH encryption ciphers:\", SshCipherList());\r\n    PrintListAndFree(Console, L\"SSH key exchange algorithms:\", SshKexList());\r\n    PrintListAndFree(Console, L\"SSH host key algorithms:\", SshHostKeyList());\r\n    PrintListAndFree(Console, L\"SSH MAC algorithms:\", SshMacList());\r\n    PrintListAndFree(Console, L\"TLS/SSL cipher suites:\", TlsCipherList());\r\n  }\r\n  catch (Exception & E)\r\n  {\r\n    Result = HandleException(Console, E);\r\n  }\r\n\r\n  Console->WaitBeforeExit();\r\n  return Result;\r\n}\r\n//---------------------------------------------------------------------------\r\nint __fastcall Console(TConsoleMode Mode)\r\n{\r\n  DebugAssert(Mode != cmNone);\r\n  TProgramParams * Params = TProgramParams::Instance();\r\n  int Result = RESULT_SUCCESS;\r\n  TConsole * Console = NULL;\r\n  TConsoleRunner * Runner = NULL;\r\n  TStrings * ScriptCommands = new TStringList();\r\n  TStrings * ScriptParameters = new TStringList();\r\n  try\r\n  {\r\n    UnicodeString ConsoleInstance;\r\n    // First check for /consoleinstance as /console is always used by winscp.com\r\n    if (Params->FindSwitch(L\"consoleinstance\", ConsoleInstance))\r\n    {\r\n      Configuration->Usage->Inc(L\"ConsoleExternal\");\r\n      Console = new TExternalConsole(ConsoleInstance, Params->FindSwitch(L\"nointeractiveinput\"));\r\n    }\r\n    else if (Params->FindSwitch(L\"Console\") || (Mode != cmScripting))\r\n    {\r\n      Configuration->Usage->Inc(L\"ConsoleOwn\");\r\n      Console = TOwnConsole::Instance();\r\n    }\r\n    else\r\n    {\r\n      Configuration->Usage->Inc(L\"ConsoleNull\");\r\n      Console = new TNullConsole();\r\n    }\r\n\r\n    SetNoGUI();\r\n\r\n    if (Mode == cmHelp)\r\n    {\r\n      Configuration->Usage->Inc(L\"UsageShown\");\r\n      Usage(Console);\r\n    }\r\n    else if (Mode == cmBatchSettings)\r\n    {\r\n      if (CheckSafe(Params))\r\n      {\r\n        Configuration->Usage->Inc(L\"BatchSettings\");\r\n        Result = BatchSettings(Console, Params);\r\n      }\r\n    }\r\n    else if (Mode == cmKeyGen)\r\n    {\r\n      if (CheckSafe(Params))\r\n      {\r\n        Configuration->Usage->Inc(L\"KeyGen\");\r\n        Result = KeyGen(Console, Params);\r\n      }\r\n    }\r\n    else if (Mode == cmFingerprintScan)\r\n    {\r\n      if (CheckSafe(Params))\r\n      {\r\n        Configuration->Usage->Inc(L\"FingerprintScan\");\r\n        Result = FingerprintScan(Console, Params);\r\n      }\r\n    }\r\n    else if (Mode == cmDumpCallstack)\r\n    {\r\n      Result = DumpCallstack(Console, Params);\r\n    }\r\n    else if (Mode == cmInfo)\r\n    {\r\n      Result = Info(Console);\r\n    }\r\n    else if (Mode == cmComRegistration)\r\n    {\r\n      if (CheckSafe(Params))\r\n      {\r\n        Result = ComRegistration(Console);\r\n      }\r\n    }\r\n    else\r\n    {\r\n      Runner = new TConsoleRunner(Console);\r\n\r\n      try\r\n      {\r\n        if (CheckSafe(Params))\r\n        {\r\n          UnicodeString Value;\r\n          if (Params->FindSwitch(SCRIPT_SWITCH, Value) && !Value.IsEmpty())\r\n          {\r\n            Configuration->Usage->Inc(L\"ScriptFile\");\r\n            LoadScriptFromFile(Value, ScriptCommands);\r\n          }\r\n          Params->FindSwitch(COMMAND_SWITCH, ScriptCommands);\r\n          if (ScriptCommands->Count > 0)\r\n          {\r\n            Configuration->Usage->Inc(L\"ScriptCommands\");\r\n          }\r\n          Params->FindSwitch(L\"parameter\", ScriptParameters);\r\n          if (ScriptParameters->Count > 0)\r\n          {\r\n            Configuration->Usage->Inc(L\"ScriptParameters\");\r\n          }\r\n        }\r\n\r\n        UnicodeString Session;\r\n        if (Params->ParamCount >= 1)\r\n        {\r\n          Session = Params->Param[1];\r\n          if (Params->ParamCount > 1)\r\n          {\r\n            Runner->PrintMessage(LoadStr(SCRIPT_CMDLINE_PARAMETERS));\r\n          }\r\n        }\r\n\r\n        CheckLogParam(Params);\r\n        CheckXmlLogParam(Params);\r\n\r\n        Result = Runner->Run(Session, Params,\r\n          (ScriptCommands->Count > 0 ? ScriptCommands : NULL),\r\n          ScriptParameters);\r\n      }\r\n      catch(Exception & E)\r\n      {\r\n        Runner->ShowException(&E);\r\n        Result = RESULT_ANY_ERROR;\r\n      }\r\n    }\r\n  }\r\n  __finally\r\n  {\r\n    delete Runner;\r\n    delete Console;\r\n    delete ScriptCommands;\r\n    delete ScriptParameters;\r\n  }\r\n\r\n  return Result;\r\n}\r\n", "//---------------------------------------------------------------------------\r\n#include <vcl.h>\r\n#pragma hdrstop\r\n\r\n#include <CoreMain.h>\r\n\r\n#include <TextsWin.h>\r\n#include <TextsCore.h>\r\n#include <HelpWin.h>\r\n\r\n#include \"CustomScpExplorer.h\"\r\n#include \"TerminalManager.h\"\r\n#include \"NonVisual.h\"\r\n#include \"Glyphs.h\"\r\n#include \"ProgParams.h\"\r\n#include \"Setup.h\"\r\n#include \"WinConfiguration.h\"\r\n#include \"GUITools.h\"\r\n#include \"Tools.h\"\r\n#include \"WinApi.h\"\r\n#include <DateUtils.hpp>\r\n//---------------------------------------------------------------------------\r\n#pragma package(smart_init)\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall GetLoginData(UnicodeString SessionName, TOptions * Options,\r\n  TObjectList * DataList, UnicodeString & DownloadFile, bool NeedSession, TForm * LinkedForm, int Flags)\r\n{\r\n  bool DefaultsOnly = false;\r\n\r\n  UnicodeString FolderOrWorkspaceName = DecodeUrlChars(SessionName);\r\n  if (StoredSessions->IsFolder(FolderOrWorkspaceName) ||\r\n      StoredSessions->IsWorkspace(FolderOrWorkspaceName))\r\n  {\r\n    StoredSessions->GetFolderOrWorkspace(FolderOrWorkspaceName, DataList);\r\n  }\r\n  else\r\n  {\r\n    TSessionData * SessionData =\r\n      StoredSessions->ParseUrl(SessionName, Options, DefaultsOnly, &DownloadFile, NULL, NULL, Flags);\r\n    DataList->Add(SessionData);\r\n\r\n    if (DataList->Count == 1)\r\n    {\r\n      TSessionData * SessionData = DebugNotNull(dynamic_cast<TSessionData *>(DataList->Items[0]));\r\n      if (SessionData->SaveOnly)\r\n      {\r\n        Configuration->Usage->Inc(L\"CommandLineSessionSave\");\r\n        TSessionData * SavedSession = DoSaveSession(SessionData, NULL, true, NULL);\r\n        if (SavedSession == NULL)\r\n        {\r\n          Abort();\r\n        }\r\n        WinConfiguration->LastStoredSession = SavedSession->Name;\r\n        DataList->Clear();\r\n      }\r\n      else if (!SessionData->PuttyProtocol.IsEmpty())\r\n      {\r\n        // putty does not support resolving environment variables in session settings\r\n        // though it's hardly of any use here.\r\n        SessionData->ExpandEnvironmentVariables();\r\n        OpenSessionInPutty(GUIConfiguration->PuttyPath, SessionData);\r\n        DataList->Clear();\r\n        Abort();\r\n      }\r\n    }\r\n  }\r\n\r\n  if (DefaultsOnly && !NeedSession)\r\n  {\r\n    // No URL specified on command-line and no explicit command-line parameter\r\n    // that requires session was specified => noop\r\n    DataList->Clear();\r\n  }\r\n  else if ((DataList->Count == 0) ||\r\n      !dynamic_cast<TSessionData *>(DataList->Items[0])->CanLogin ||\r\n      DefaultsOnly)\r\n  {\r\n    // Note that GetFolderOrWorkspace never returns sites that !CanLogin,\r\n    // so we should not get here with more then one site.\r\n    // Though we should be good, if we ever do.\r\n\r\n    // We get here when:\r\n    // - we need session for explicit command-line operation\r\n    // - after we handle \"save\" URL.\r\n    // - the specified session does not contain enough information to login [= not even hostname]\r\n\r\n    DebugAssert(DataList->Count <= 1);\r\n    if (!DoLoginDialog(DataList, LinkedForm))\r\n    {\r\n      Abort();\r\n    }\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall Upload(TTerminal * Terminal, TStrings * FileList, int UseDefaults)\r\n{\r\n  UnicodeString TargetDirectory;\r\n  TGUICopyParamType CopyParam = GUIConfiguration->DefaultCopyParam;\r\n\r\n  TargetDirectory = UnixIncludeTrailingBackslash(Terminal->CurrentDirectory);\r\n\r\n  std::unique_ptr<TSessionData> Data(Terminal->SessionData->Clone());\r\n  Terminal->FillSessionDataForCode(Data.get());\r\n\r\n  int Options = coDisableQueue;\r\n  int CopyParamAttrs = Terminal->UsableCopyParamAttrs(0).Upload;\r\n  if ((UseDefaults == 0) ||\r\n      DoCopyDialog(true, false, FileList, TargetDirectory, &CopyParam, Options,\r\n        CopyParamAttrs, Data.get(), NULL, UseDefaults))\r\n  {\r\n    // Setting parameter overrides only now, otherwise the dialog would present the parametes as non-default\r\n    CopyParam.OnceDoneOperation = odoDisconnect;\r\n\r\n    Terminal->CopyToRemote(FileList, TargetDirectory, &CopyParam, 0, NULL);\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall Download(TTerminal * Terminal, const UnicodeString FileName, int UseDefaults)\r\n{\r\n  TRemoteFile * File = NULL;\r\n\r\n  try\r\n  {\r\n    Terminal->ExceptionOnFail = true;\r\n    try\r\n    {\r\n      Terminal->ReadFile(FileName, File);\r\n    }\r\n    __finally\r\n    {\r\n      Terminal->ExceptionOnFail = false;\r\n    }\r\n    File->FullFileName = FileName;\r\n    UnicodeString LocalDirectory = Terminal->SessionData->LocalDirectoryExpanded;\r\n    if (LocalDirectory.IsEmpty())\r\n    {\r\n      LocalDirectory = GetPersonalFolder();\r\n    }\r\n    UnicodeString TargetDirectory = IncludeTrailingBackslash(LocalDirectory);\r\n\r\n    TGUICopyParamType CopyParam = GUIConfiguration->DefaultCopyParam;\r\n    UnicodeString DisplayName = File->FileName;\r\n\r\n    bool CustomDisplayName =\r\n      !File->DisplayName.IsEmpty() &&\r\n      (File->DisplayName != DisplayName);\r\n    if (CustomDisplayName)\r\n    {\r\n      DisplayName = File->DisplayName;\r\n    }\r\n\r\n    UnicodeString FriendyFileName = UnixIncludeTrailingBackslash(UnixExtractFilePath(FileName)) + DisplayName;\r\n    std::unique_ptr<TStrings> FileListFriendly(new TStringList());\r\n    FileListFriendly->AddObject(FriendyFileName, File);\r\n\r\n    int Options = coDisableQueue;\r\n    int CopyParamAttrs = Terminal->UsableCopyParamAttrs(0).Download;\r\n    if ((UseDefaults == 0) ||\r\n        DoCopyDialog(false, false, FileListFriendly.get(), TargetDirectory, &CopyParam,\r\n          Options, CopyParamAttrs, NULL, NULL, UseDefaults))\r\n    {\r\n      // Setting parameter overrides only now, otherwise the dialog would present the parametes as non-default\r\n\r\n      if (CustomDisplayName)\r\n      {\r\n        // Set only now, so that it is not redundantly displayed on the copy dialog.\r\n        // We should escape the * and ?'s.\r\n        CopyParam.FileMask = DisplayName;\r\n      }\r\n\r\n      CopyParam.OnceDoneOperation = odoDisconnect;\r\n\r\n      std::unique_ptr<TStrings> FileList(new TStringList());\r\n      FileList->AddObject(FileName, File);\r\n      Terminal->CopyToLocal(FileList.get(), TargetDirectory, &CopyParam, 0, NULL);\r\n    }\r\n\r\n    UnicodeString Directory = UnixExtractFilePath(FileName);\r\n    Terminal->AutoReadDirectory = true;\r\n    Terminal->ChangeDirectory(Directory);\r\n  }\r\n  __finally\r\n  {\r\n    delete File;\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall Edit(TCustomScpExplorerForm * ScpExplorer, TStrings * FileList)\r\n{\r\n  ScpExplorer->StandaloneEdit(FileList->Strings[0]);\r\n  Abort();\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall SynchronizeDirectories(TTerminal * Terminal,\r\n  TStrings * CommandParams,\r\n  UnicodeString & LocalDirectory, UnicodeString & RemoteDirectory)\r\n{\r\n  if (CommandParams->Count >= 1)\r\n  {\r\n    LocalDirectory = CommandParams->Strings[0];\r\n  }\r\n  else if (!Terminal->SessionData->LocalDirectory.IsEmpty())\r\n  {\r\n    LocalDirectory = Terminal->SessionData->LocalDirectoryExpanded;\r\n  }\r\n  else\r\n  {\r\n    LocalDirectory = WinConfiguration->ScpExplorer.LastLocalTargetDirectory;\r\n  }\r\n\r\n  if (CommandParams->Count >= 2)\r\n  {\r\n    RemoteDirectory = CommandParams->Strings[1];\r\n  }\r\n  else\r\n  {\r\n    RemoteDirectory = Terminal->CurrentDirectory;\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall FullSynchronize(\r\n  TTerminal * Terminal, TCustomScpExplorerForm * ScpExplorer, TStrings * CommandParams, int UseDefaults)\r\n{\r\n  UnicodeString LocalDirectory;\r\n  UnicodeString RemoteDirectory;\r\n\r\n  SynchronizeDirectories(Terminal, CommandParams, LocalDirectory, RemoteDirectory);\r\n\r\n  bool SaveMode = true;\r\n  // bit ugly\r\n  TSynchronizeMode Mode = (TSynchronizeMode)GUIConfiguration->SynchronizeMode;\r\n  int Params = GUIConfiguration->SynchronizeParams;\r\n\r\n  // Undocumented syntax for \"Start in New Window\"\r\n  if (CommandParams->Count >= 4)\r\n  {\r\n    Mode = (TSynchronizeMode)StrToIntDef(CommandParams->Strings[2], Mode);\r\n    Params = StrToIntDef(CommandParams->Strings[3], Params);\r\n  }\r\n\r\n  int Result =\r\n    ScpExplorer->DoFullSynchronizeDirectories(LocalDirectory, RemoteDirectory, Mode, Params, SaveMode, UseDefaults);\r\n  if ((Result >= 0) && SaveMode)\r\n  {\r\n    GUIConfiguration->SynchronizeMode = Mode;\r\n  }\r\n\r\n  Abort();\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall Synchronize(\r\n  TTerminal * Terminal, TCustomScpExplorerForm * ScpExplorer, TStrings * CommandParams, int UseDefaults)\r\n{\r\n  UnicodeString LocalDirectory;\r\n  UnicodeString RemoteDirectory;\r\n\r\n  SynchronizeDirectories(Terminal, CommandParams, LocalDirectory, RemoteDirectory);\r\n\r\n  // Undocumented syntax for \"Start in New Window\"\r\n  if (CommandParams->Count >= 4)\r\n  {\r\n    GUIConfiguration->SynchronizeParams = StrToIntDef(CommandParams->Strings[2], -1);\r\n    GUIConfiguration->SynchronizeOptions = StrToIntDef(CommandParams->Strings[3], -1);\r\n\r\n    Configuration->DontSave();\r\n  }\r\n\r\n  ScpExplorer->DoSynchronizeDirectories(LocalDirectory, RemoteDirectory, UseDefaults);\r\n  Abort();\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall ImportSitesIfAny()\r\n{\r\n  if (!WinConfiguration->AutoImportedFromPuttyOrFilezilla)\r\n  {\r\n    bool AnyPuttySession = GUIConfiguration->AnyPuttySessionForImport(StoredSessions);\r\n    bool AnyFilezillaSession = GUIConfiguration->AnyFilezillaSessionForImport(StoredSessions);\r\n\r\n    if (AnyPuttySession || AnyFilezillaSession)\r\n    {\r\n      UnicodeString PuttySource = LoadStrPart(IMPORT_SESSIONS2, 2);\r\n      UnicodeString FilezillaSource = LoadStrPart(IMPORT_SESSIONS2, 3);\r\n      UnicodeString Source;\r\n      if (AnyPuttySession && AnyFilezillaSession)\r\n      {\r\n        Source = FORMAT(LoadStrPart(IMPORT_SESSIONS2, 4), (PuttySource, FilezillaSource));\r\n      }\r\n      else if (AnyPuttySession)\r\n      {\r\n        Source = PuttySource;\r\n      }\r\n      else if (AnyFilezillaSession)\r\n      {\r\n        Source = FilezillaSource;\r\n      }\r\n      else\r\n      {\r\n        DebugFail();\r\n      }\r\n\r\n      UnicodeString Message = FORMAT(LoadStrPart(IMPORT_SESSIONS2, 1), (Source));\r\n\r\n      if (MessageDialog(Message, qtConfirmation,\r\n            qaYes | qaNo, HELP_IMPORT_SESSIONS) == qaYes)\r\n      {\r\n        DoImportSessionsDialog(NULL);\r\n      }\r\n\r\n      WinConfiguration->AutoImportedFromPuttyOrFilezilla = true;\r\n    }\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall Usage(UnicodeString Param)\r\n{\r\n  while (!Param.IsEmpty())\r\n  {\r\n    UnicodeString Pair = CutToChar(Param, L',', true);\r\n    if (!Pair.IsEmpty())\r\n    {\r\n      if (Pair[Pair.Length()] == L'+')\r\n      {\r\n        UnicodeString Key = Pair.SubString(1, Pair.Length() - 1).Trim();\r\n        Configuration->Usage->Inc(Key);\r\n      }\r\n      else\r\n      {\r\n        UnicodeString Key = CutToChar(Pair, L':', true);\r\n        Configuration->Usage->Set(Key, Pair.Trim());\r\n      }\r\n    }\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall RecordWrapperVersions(UnicodeString ConsoleVersion, UnicodeString DotNetVersion)\r\n{\r\n  TUpdatesConfiguration Updates = WinConfiguration->Updates;\r\n  if (!DotNetVersion.IsEmpty())\r\n  {\r\n    Updates.DotNetVersion = DotNetVersion;\r\n  }\r\n  if (!ConsoleVersion.IsEmpty())\r\n  {\r\n    Updates.ConsoleVersion = ConsoleVersion;\r\n  }\r\n  WinConfiguration->Updates = Updates;\r\n\r\n  if (Configuration->Storage == stNul)\r\n  {\r\n    Configuration->SetDefaultStorage();\r\n    try\r\n    {\r\n      THierarchicalStorage * Storage = Configuration->CreateConfigStorage();\r\n      try\r\n      {\r\n        Storage->AccessMode = smReadWrite;\r\n        if (Storage->OpenSubKey(Configuration->ConfigurationSubKey, true) &&\r\n            Storage->OpenSubKeyPath(L\"Interface\\\\Updates\", true))\r\n        {\r\n          if (!DotNetVersion.IsEmpty())\r\n          {\r\n            Storage->WriteString(L\"DotNetVersion\", DotNetVersion);\r\n          }\r\n          if (!ConsoleVersion.IsEmpty())\r\n          {\r\n            Storage->WriteString(L\"ConsoleVersion\", ConsoleVersion);\r\n          }\r\n        }\r\n      }\r\n      __finally\r\n      {\r\n        delete Storage;\r\n      }\r\n    }\r\n    __finally\r\n    {\r\n      Configuration->SetNulStorage();\r\n    }\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\nstatic UnicodeString ColorToRGBStr(TColor Color)\r\n{\r\n  int RGB = ColorToRGB(Color);\r\n  int R = GetRValue(RGB);\r\n  int G = GetGValue(RGB);\r\n  int B = GetBValue(RGB);\r\n  UnicodeString Result = FORMAT(L\"%.2x%.2x%.2x\", (R, G, B));\r\n  return Result;\r\n}\r\n//---------------------------------------------------------------------------\r\nTDateTime Started(Now());\r\nint LifetimeRuns = -1;\r\n//---------------------------------------------------------------------------\r\nvoid InterfaceStarted()\r\n{\r\n  // deliberate downcast\r\n  int StartupSeconds = static_cast<int>(SecondsBetween(Now(), Started));\r\n  if (LifetimeRuns > 0)\r\n  {\r\n    if (LifetimeRuns == 1)\r\n    {\r\n      Configuration->Usage->Set(L\"StartupSeconds1\", StartupSeconds);\r\n    }\r\n    else if (LifetimeRuns == 2)\r\n    {\r\n      Configuration->Usage->Set(L\"StartupSeconds2\", StartupSeconds);\r\n    }\r\n    Configuration->Usage->Set(L\"StartupSecondsLast\", StartupSeconds);\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall UpdateStaticUsage()\r\n{\r\n  LifetimeRuns = Configuration->Usage->Inc(L\"Runs\");\r\n\r\n  Configuration->Usage->UpdateCurrentVersion();\r\n\r\n  Configuration->Usage->Set(L\"WindowsVersion\", (WindowsVersionLong()));\r\n  Configuration->Usage->Set(L\"WindowsProductName\", (WindowsProductName()));\r\n  DWORD Type;\r\n  GetWindowsProductType(Type);\r\n  Configuration->Usage->Set(L\"WindowsProductType\", (static_cast<int>(Type)));\r\n  Configuration->Usage->Set(L\"Windows64\", IsWin64());\r\n  Configuration->Usage->Set(L\"UWP\", IsUWP());\r\n  Configuration->Usage->Set(L\"DefaultLocale\",\r\n    // See TGUIConfiguration::GetAppliedLocaleHex()\r\n    IntToHex(static_cast<int>(GetDefaultLCID()), 4));\r\n  Configuration->Usage->Set(L\"Locale\", WinConfiguration->AppliedLocaleHex);\r\n  Configuration->Usage->Set(L\"EncodingMultiByteAnsi\", !TEncoding::Default->IsSingleByte);\r\n  Configuration->Usage->Set(L\"PixelsPerInch\", Screen->PixelsPerInch);\r\n\r\n  bool PixelsPerInchSystemDiffers = false;\r\n  bool PixelsPerInchMonitorsDiffer = false;\r\n  bool PixelsPerInchAxesDiffer = false;\r\n\r\n  HINSTANCE ShCoreLibrary = LoadLibrary(L\"shcore.dll\");\r\n  if (ShCoreLibrary != NULL)\r\n  {\r\n    GetDpiForMonitorProc GetDpiForMonitor =\r\n      (GetDpiForMonitorProc)GetProcAddress(ShCoreLibrary, \"GetDpiForMonitor\");\r\n\r\n    if (GetDpiForMonitor != NULL)\r\n    {\r\n      unsigned int PrimaryDpiX;\r\n      unsigned int PrimaryDpiY;\r\n\r\n      for (int Index = 0; Index < Screen->MonitorCount; Index++)\r\n      {\r\n        unsigned int DpiX;\r\n        unsigned int DpiY;\r\n        GetDpiForMonitor(Screen->Monitors[Index]->Handle, MDT_Default, &DpiX, &DpiY);\r\n\r\n        if (DpiX != DpiY)\r\n        {\r\n          PixelsPerInchAxesDiffer = true;\r\n        }\r\n\r\n        if (Index == 0)\r\n        {\r\n          PrimaryDpiX = DpiX;\r\n          PrimaryDpiY = DpiY;\r\n\r\n          // PixelsPerInch is GetDeviceCaps(DC, LOGPIXELSY)\r\n          if (DpiY != (unsigned int)Screen->PixelsPerInch)\r\n          {\r\n            PixelsPerInchSystemDiffers = true;\r\n          }\r\n        }\r\n        else\r\n        {\r\n          if ((DpiX != PrimaryDpiX) ||\r\n              (DpiY != PrimaryDpiY))\r\n          {\r\n            PixelsPerInchMonitorsDiffer = true;\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  if (PixelsPerInchSystemDiffers)\r\n  {\r\n    Configuration->Usage->Inc(L\"PixelsPerInchSystemDiffered\");\r\n  }\r\n  Configuration->Usage->Set(L\"PixelsPerInchMonitorsDiffer\", PixelsPerInchMonitorsDiffer);\r\n  Configuration->Usage->Set(L\"PixelsPerInchAxesDiffer\", PixelsPerInchAxesDiffer);\r\n\r\n  Configuration->Usage->Set(L\"WorkAreaWidth\", Screen->WorkAreaWidth);\r\n  Configuration->Usage->Set(L\"WorkAreaHeight\", Screen->WorkAreaHeight);\r\n  HDC DC = GetDC(NULL);\r\n  int Planes = GetDeviceCaps(DC, PLANES);\r\n  int BitsPixel = GetDeviceCaps(DC, BITSPIXEL);\r\n  Configuration->Usage->Set(L\"ColorDepth\", Planes * BitsPixel);\r\n  Configuration->Usage->Set(L\"MonitorCount\", Screen->MonitorCount);\r\n  Configuration->Usage->Set(L\"NotUseThemes\", !UseThemes());\r\n  Configuration->Usage->Set(L\"ThemeDefaultFontSize\", Application->DefaultFont->Size);\r\n  Configuration->Usage->Set(L\"ThemeIconFontSize\", Screen->IconFont->Size);\r\n\r\n  Configuration->Usage->Set(L\"SysColorWindow\", ColorToRGBStr(clWindow));\r\n  Configuration->Usage->Set(L\"SysColorBtnFace\", ColorToRGBStr(clBtnFace));\r\n  Configuration->Usage->Set(L\"SysColorWindowText\", ColorToRGBStr(clWindowText));\r\n\r\n  UnicodeString ProgramsFolder;\r\n  ::SpecialFolderLocation(CSIDL_PROGRAM_FILES, ProgramsFolder);\r\n  ProgramsFolder = IncludeTrailingBackslash(ExpandFileName(ProgramsFolder));\r\n  UnicodeString ExeName = ExpandFileName(Application->ExeName);\r\n  bool InProgramFiles = AnsiSameText(ExeName.SubString(1, ProgramsFolder.Length()), ProgramsFolder);\r\n  Configuration->Usage->Set(L\"InProgramFiles\", InProgramFiles);\r\n  Configuration->Usage->Set(L\"IsInstalled\", IsInstalled());\r\n  Configuration->Usage->Set(L\"Wine\", IsWine());\r\n  Configuration->Usage->Set(L\"NetFrameworkVersion\", GetNetVersionStr());\r\n  Configuration->Usage->Set(L\"PowerShellVersion\", GetPowerShellVersionStr());\r\n\r\n  WinConfiguration->UpdateStaticUsage();\r\n\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall MaintenanceTask()\r\n{\r\n  CoreMaintenanceTask();\r\n}\r\n//---------------------------------------------------------------------------\r\ntypedef std::vector<HWND> THandles;\r\ntypedef std::map<unsigned long, THandles> TProcesses;\r\n//---------------------------------------------------------------------------\r\nBOOL __stdcall EnumOtherInstances(HWND Handle, LPARAM AParam)\r\n{\r\n  TProcesses & Processes = *reinterpret_cast<TProcesses *>(AParam);\r\n\r\n  unsigned long ProcessId;\r\n  if (GetWindowThreadProcessId(Handle, &ProcessId) != 0)\r\n  {\r\n    Processes[ProcessId].push_back(Handle);\r\n  }\r\n\r\n  return TRUE;\r\n}\r\n//---------------------------------------------------------------------------\r\nstatic bool __fastcall SendCopyDataMessage(HWND Window, TCopyDataMessage & Message)\r\n{\r\n  COPYDATASTRUCT CopyData;\r\n  CopyData.cbData = sizeof(Message);\r\n  CopyData.lpData = &Message;\r\n\r\n  LRESULT SendResult =\r\n    SendMessage(Window, WM_COPYDATA,\r\n       reinterpret_cast<WPARAM>(HInstance), reinterpret_cast<LPARAM>(&CopyData));\r\n  bool Result = (SendResult > 0);\r\n  return Result;\r\n}\r\n//---------------------------------------------------------------------------\r\nstatic void __fastcall FindOtherInstances(THandles & OtherInstances)\r\n{\r\n  TProcesses Processes;\r\n\r\n  // FindWindow is optimization (if there's no hidden window, no point enumerating all windows to find some)\r\n  if ((FindWindow(HIDDEN_WINDOW_NAME, NULL) != NULL) &&\r\n      EnumWindows(EnumOtherInstances, reinterpret_cast<LPARAM>(&Processes)))\r\n  {\r\n    TCopyDataMessage Message;\r\n\r\n    Message.Command = TCopyDataMessage::MainWindowCheck;\r\n\r\n    TProcesses::const_iterator ProcessI = Processes.begin();\r\n    while (ProcessI != Processes.end())\r\n    {\r\n      HWND HiddenWindow = NULL;\r\n      THandles::const_iterator WindowI = ProcessI->second.begin();\r\n\r\n      while ((HiddenWindow == NULL) && (WindowI != ProcessI->second.end()))\r\n      {\r\n        wchar_t ClassName[1024];\r\n        if (GetClassName(*WindowI, ClassName, LENOF(ClassName)) != 0)\r\n        {\r\n          NULL_TERMINATE(ClassName);\r\n\r\n          if (wcscmp(ClassName, HIDDEN_WINDOW_NAME) == 0)\r\n          {\r\n            HiddenWindow = *WindowI;\r\n          }\r\n        }\r\n        WindowI++;\r\n      }\r\n\r\n      if (HiddenWindow != NULL)\r\n      {\r\n        WindowI = ProcessI->second.begin();\r\n\r\n        while (WindowI != ProcessI->second.end())\r\n        {\r\n          if (*WindowI != HiddenWindow) // optimization\r\n          {\r\n            if (SendCopyDataMessage(*WindowI, Message))\r\n            {\r\n              OtherInstances.push_back(*WindowI);\r\n              break;\r\n            }\r\n          }\r\n          WindowI++;\r\n        }\r\n      }\r\n\r\n      ProcessI++;\r\n    }\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\nbool __fastcall SendToAnotherInstance()\r\n{\r\n  THandles OtherInstances;\r\n  FindOtherInstances(OtherInstances);\r\n\r\n  bool Result = false;\r\n  THandles::const_iterator I = OtherInstances.begin();\r\n  while (!Result && (I != OtherInstances.end()))\r\n  {\r\n    HWND Handle = *I;\r\n\r\n    TCopyDataMessage Message;\r\n    Message.Command = TCopyDataMessage::CommandCanCommandLine;\r\n\r\n    if (SendCopyDataMessage(Handle, Message))\r\n    {\r\n      // Restore window, if minimized\r\n      ShowWindow(Handle, SW_RESTORE);\r\n      // bring it to foreground\r\n      SetForegroundWindow(Handle);\r\n\r\n      Message.Command = TCopyDataMessage::CommandCommandLine;\r\n      wcsncpy(Message.CommandLine, CmdLine, LENOF(Message.CommandLine));\r\n      NULL_TERMINATE(Message.CommandLine);\r\n\r\n      Result = SendCopyDataMessage(Handle, Message);\r\n    }\r\n\r\n    I++;\r\n  }\r\n\r\n  return Result;\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall Refresh(const UnicodeString & Session, const UnicodeString & Path)\r\n{\r\n  THandles OtherInstances;\r\n  FindOtherInstances(OtherInstances);\r\n\r\n  THandles::const_iterator I = OtherInstances.begin();\r\n  while (I != OtherInstances.end())\r\n  {\r\n    HWND Handle = *I;\r\n\r\n    TCopyDataMessage Message;\r\n    Message.Command = TCopyDataMessage::RefreshPanel;\r\n    wcsncpy(Message.Refresh.Session, Session.c_str(), LENOF(Message.Refresh.Session));\r\n    NULL_TERMINATE(Message.Refresh.Session);\r\n    wcsncpy(Message.Refresh.Path, Path.c_str(), LENOF(Message.Refresh.Path));\r\n    NULL_TERMINATE(Message.Refresh.Path);\r\n\r\n    SendCopyDataMessage(Handle, Message);\r\n\r\n    I++;\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\nbool __fastcall ShowUpdatesIfAvailable()\r\n{\r\n  TUpdatesConfiguration Updates = WinConfiguration->Updates;\r\n  int CurrentCompoundVer = Configuration->CompoundVersion;\r\n  bool NoPopup = true;\r\n  bool Result =\r\n    !IsUWP() &&\r\n    Updates.ShowOnStartup &&\r\n    Updates.HaveValidResultsForVersion(CurrentCompoundVer) &&\r\n    !Updates.Results.Disabled &&\r\n    ((Updates.Results.Version > CurrentCompoundVer) || !Updates.Results.Message.IsEmpty()) &&\r\n    !Updates.ShownResults;\r\n  if (Result)\r\n  {\r\n    Configuration->Usage->Inc(L\"UpdateStartup\");\r\n    Result = CheckForUpdates(true);\r\n    if (Result)\r\n    {\r\n      Configuration->Usage->Inc(L\"UpdateDownloadOpensStartup\");\r\n    }\r\n    NoPopup = false;\r\n  }\r\n  else if (WinConfiguration->ShowTips)\r\n  {\r\n    int Days = DaysBetween(WinConfiguration->TipsShown, Now());\r\n    if ((Days >= Updates.Results.TipsIntervalDays) &&\r\n        (WinConfiguration->RunsSinceLastTip >= Updates.Results.TipsIntervalDays))\r\n    {\r\n      UnicodeString Tip = FirstUnshownTip();\r\n      if (!Tip.IsEmpty())\r\n      {\r\n        AutoShowNewTip();\r\n        NoPopup = false;\r\n      }\r\n      else\r\n      {\r\n        Configuration->Usage->Inc(L\"TipsNoUnseen\");\r\n      }\r\n    }\r\n  }\r\n\r\n  if (NoPopup)\r\n  {\r\n    WinConfiguration->RunsSinceLastTip = WinConfiguration->RunsSinceLastTip + 1;\r\n  }\r\n  return Result;\r\n}\r\n//---------------------------------------------------------------------------\r\nint __fastcall Execute()\r\n{\r\n  DebugAssert(StoredSessions);\r\n  TProgramParams * Params = TProgramParams::Instance();\r\n  DebugAssert(Params);\r\n\r\n  // do not flash message boxes on startup\r\n  SetOnForeground(true);\r\n\r\n  // let installer know, that some instance of application is running\r\n  CreateMutex(NULL, False, AppName.c_str());\r\n  bool OnlyInstance = (GetLastError() == 0);\r\n\r\n  UpdateStaticUsage();\r\n\r\n  UnicodeString KeyFile;\r\n  if (Params->FindSwitch(L\"PrivateKey\", KeyFile))\r\n  {\r\n    WinConfiguration->DefaultKeyFile = KeyFile;\r\n  }\r\n\r\n  UnicodeString ConsoleVersion;\r\n  UnicodeString DotNetVersion;\r\n  Params->FindSwitch(L\"Console\", ConsoleVersion);\r\n  Params->FindSwitch(L\"DotNet\", DotNetVersion);\r\n  if (!ConsoleVersion.IsEmpty() || !DotNetVersion.IsEmpty())\r\n  {\r\n    RecordWrapperVersions(ConsoleVersion, DotNetVersion);\r\n  }\r\n  if (!DotNetVersion.IsEmpty())\r\n  {\r\n    Configuration->Usage->Inc(L\"ConsoleDotNet\");\r\n  }\r\n\r\n  UnicodeString SwitchValue;\r\n  if (Params->FindSwitch(L\"loglevel\", SwitchValue))\r\n  {\r\n    int StarPos = SwitchValue.Pos(L\"*\");\r\n    if (StarPos > 0)\r\n    {\r\n      bool LogSensitive = true;\r\n      SwitchValue.Delete(StarPos, 1);\r\n\r\n      if ((StarPos <= SwitchValue.Length()) &&\r\n          (SwitchValue[StarPos] == L'-'))\r\n      {\r\n        LogSensitive = false;\r\n        SwitchValue.Delete(StarPos, 1);\r\n      }\r\n\r\n      SwitchValue = SwitchValue.Trim();\r\n\r\n      Configuration->TemporaryLogSensitive(LogSensitive);\r\n    }\r\n    int LogProtocol;\r\n    if (!SwitchValue.IsEmpty() && TryStrToInt(SwitchValue, LogProtocol) && (LogProtocol >= -1))\r\n    {\r\n      Configuration->TemporaryLogProtocol(LogProtocol);\r\n    }\r\n  }\r\n\r\n  if (Params->FindSwitch(LOGSIZE_SWITCH, SwitchValue))\r\n  {\r\n    int StarPos = SwitchValue.Pos(LOGSIZE_SEPARATOR);\r\n    int LogMaxCount = 0;\r\n    if (StarPos > 1)\r\n    {\r\n      if (!TryStrToInt(SwitchValue.SubString(1, StarPos - 1), LogMaxCount))\r\n      {\r\n        LogMaxCount = -1;\r\n      }\r\n      SwitchValue.Delete(1, StarPos);\r\n      SwitchValue = SwitchValue.Trim();\r\n    }\r\n\r\n    __int64 LogMaxSize;\r\n    if ((LogMaxCount >= 0) &&\r\n        !SwitchValue.IsEmpty() &&\r\n        TryStrToSize(SwitchValue, LogMaxSize))\r\n    {\r\n      Configuration->TemporaryLogMaxCount(LogMaxCount);\r\n      Configuration->TemporaryLogMaxSize(LogMaxSize);\r\n    }\r\n  }\r\n\r\n  std::unique_ptr<TStrings> RawSettings(new TStringList());\r\n  if (Params->FindSwitch(RAWTRANSFERSETTINGS_SWITCH, RawSettings.get()))\r\n  {\r\n    std::unique_ptr<TOptionsStorage> OptionsStorage(new TOptionsStorage(RawSettings.get(), false));\r\n    GUIConfiguration->LoadDefaultCopyParam(OptionsStorage.get());\r\n  }\r\n\r\n  TConsoleMode Mode = cmNone;\r\n  if (Params->FindSwitch(L\"help\") || Params->FindSwitch(L\"h\") || Params->FindSwitch(L\"?\"))\r\n  {\r\n    Mode = cmHelp;\r\n  }\r\n  else if (Params->FindSwitch(L\"batchsettings\"))\r\n  {\r\n    Mode = cmBatchSettings;\r\n  }\r\n  else if (Params->FindSwitch(KEYGEN_SWITCH))\r\n  {\r\n    Mode = cmKeyGen;\r\n  }\r\n  else if (Params->FindSwitch(FINGERPRINTSCAN_SWITCH))\r\n  {\r\n    Mode = cmFingerprintScan;\r\n  }\r\n  else if (Params->FindSwitch(DUMPCALLSTACK_SWITCH))\r\n  {\r\n    Mode = cmDumpCallstack;\r\n  }\r\n  else if (Params->FindSwitch(INFO_SWITCH))\r\n  {\r\n    Mode = cmInfo;\r\n  }\r\n  else if (Params->FindSwitch(COMREGISTRATION_SWITCH))\r\n  {\r\n    Mode = cmComRegistration;\r\n  }\r\n  // We have to check for /console only after the other options,\r\n  // as the /console is always used when we are run by winscp.com\r\n  // (ambiguous use to pass console version)\r\n  else if (Params->FindSwitch(L\"Console\") || Params->FindSwitch(SCRIPT_SWITCH) ||\r\n      Params->FindSwitch(COMMAND_SWITCH))\r\n  {\r\n    Mode = cmScripting;\r\n  }\r\n\r\n  if (Mode != cmNone)\r\n  {\r\n    return Console(Mode);\r\n  }\r\n\r\n  TTerminalManager * TerminalManager = NULL;\r\n  GlyphsModule = NULL;\r\n  NonVisualDataModule = NULL;\r\n  TStrings * CommandParams = new TStringList;\r\n  try\r\n  {\r\n    TerminalManager = TTerminalManager::Instance();\r\n    HANDLE ResourceModule = GUIConfiguration->ChangeToDefaultResourceModule();\r\n    try\r\n    {\r\n      GlyphsModule = new TGlyphsModule(Application);\r\n    }\r\n    __finally\r\n    {\r\n      GUIConfiguration->ChangeResourceModule(ResourceModule);\r\n    }\r\n    NonVisualDataModule = new TNonVisualDataModule(Application);\r\n\r\n    // The default is 2.5s.\r\n    // 20s is used by Office 2010 and Windows 10 Explorer.\r\n    // Some applications use an infinite (Thunderbird, Firefox).\r\n    // Overriden for some controls using THintInfo.HideTimeout\r\n    Application->HintHidePause = 20000;\r\n    HintWindowClass = __classid(TScreenTipHintWindow);\r\n\r\n    UnicodeString IniFileName = Params->SwitchValue(INI_SWITCH);\r\n    if (!IniFileName.IsEmpty() && (IniFileName != INI_NUL))\r\n    {\r\n      UnicodeString IniFileNameExpanded = ExpandEnvironmentVariables(IniFileName);\r\n      if (!FileExists(ApiPath(IniFileNameExpanded)))\r\n      {\r\n        // this should be displayed rather at the very beginning.\r\n        // however for simplicity (GUI-only), we do it only here.\r\n        MessageDialog(FMTLOAD(FILE_NOT_EXISTS, (IniFileNameExpanded)), qtError, qaOK);\r\n      }\r\n    }\r\n\r\n    if (Params->FindSwitch(L\"UninstallCleanup\"))\r\n    {\r\n      MaintenanceTask();\r\n      Configuration->DontSave();\r\n      // The innosetup cannot skip UninstallCleanup run task for silent uninstalls,\r\n      // workaround is that we create mutex in uninstaller, if it runs silent, and\r\n      // ignore the UninstallCleanup, when the mutex exists.\r\n      if (OpenMutex(SYNCHRONIZE, false, L\"WinSCPSilentUninstall\") == NULL)\r\n      {\r\n        DoCleanupDialogIfAnyDataAndWanted();\r\n      }\r\n    }\r\n    else if (Params->FindSwitch(L\"RegisterForDefaultProtocols\") ||\r\n             Params->FindSwitch(L\"RegisterAsUrlHandler\")) // BACKWARD COMPATIBILITY\r\n    {\r\n      MaintenanceTask();\r\n      if (CheckSafe(Params))\r\n      {\r\n        RegisterForDefaultProtocols();\r\n        Configuration->DontSave();\r\n      }\r\n    }\r\n    else if (Params->FindSwitch(L\"UnregisterForProtocols\"))\r\n    {\r\n      MaintenanceTask();\r\n      if (CheckSafe(Params))\r\n      {\r\n        UnregisterForProtocols();\r\n        Configuration->DontSave();\r\n      }\r\n    }\r\n    else if (Params->FindSwitch(L\"AddSearchPath\"))\r\n    {\r\n      MaintenanceTask();\r\n      if (CheckSafe(Params))\r\n      {\r\n        AddSearchPath(ExtractFilePath(Application->ExeName));\r\n        Configuration->DontSave();\r\n      }\r\n    }\r\n    else if (Params->FindSwitch(L\"RemoveSearchPath\"))\r\n    {\r\n      MaintenanceTask();\r\n      if (CheckSafe(Params))\r\n      {\r\n        try\r\n        {\r\n          RemoveSearchPath(ExtractFilePath(Application->ExeName));\r\n        }\r\n        catch(...)\r\n        {\r\n          // ignore errors\r\n          // (RemoveSearchPath is called always on uninstallation,\r\n          // even if AddSearchPath was not used, so we would get the error\r\n          // always for non-priviledged user)\r\n        }\r\n        Configuration->DontSave();\r\n      }\r\n    }\r\n    else if (Params->FindSwitch(L\"ImportSitesIfAny\"))\r\n    {\r\n      MaintenanceTask();\r\n      ImportSitesIfAny();\r\n    }\r\n    else if (Params->FindSwitch(L\"Usage\", SwitchValue))\r\n    {\r\n      MaintenanceTask();\r\n      Usage(SwitchValue);\r\n    }\r\n    else if (Params->FindSwitch(L\"Update\"))\r\n    {\r\n      MaintenanceTask();\r\n      CheckForUpdates(false);\r\n    }\r\n    else if (ShowUpdatesIfAvailable())\r\n    {\r\n      // noop\r\n    }\r\n    else if (Params->FindSwitch(L\"Exit\"))\r\n    {\r\n      // noop\r\n      MaintenanceTask();\r\n      Configuration->DontSave();\r\n    }\r\n    else if (Params->FindSwitch(L\"MaintenanceTask\"))\r\n    {\r\n      // Parameter /MaintenanceTask can be added to command-line when executing maintenance tasks\r\n      // (e.g. from installer) just in case old version of WinSCP is called by mistake\r\n      MaintenanceTask();\r\n      Configuration->DontSave();\r\n    }\r\n    else\r\n    {\r\n      enum { pcNone, pcUpload, pcFullSynchronize, pcSynchronize, pcEdit, pcRefresh } ParamCommand;\r\n      ParamCommand = pcNone;\r\n      UnicodeString AutoStartSession;\r\n      UnicodeString DownloadFile;\r\n      int UseDefaults = -1;\r\n\r\n      // do not check for temp dirs for service tasks (like RegisterAsUrlHandler)\r\n      if (OnlyInstance &&\r\n          WinConfiguration->TemporaryDirectoryCleanup)\r\n      {\r\n        TemporaryDirectoryCleanup();\r\n      }\r\n\r\n      WinConfiguration->CheckDefaultTranslation();\r\n      // Loading shell image lists here (rather than only on demand when file controls are being created)\r\n      // reduces risk of an occasional crash.\r\n      // It seems that the point is to load the lists before any call to SHGetFileInfoWithTimeout.\r\n      InitFileControls();\r\n\r\n      if (!Params->Empty)\r\n      {\r\n        UnicodeString Value;\r\n        if (Params->FindSwitch(DEFAULTS_SWITCH, Value) && CheckSafe(Params))\r\n        {\r\n          UseDefaults = StrToIntDef(Value, 0);\r\n        }\r\n\r\n        if (Params->FindSwitch(UPLOAD_SWITCH, CommandParams))\r\n        {\r\n          ParamCommand = pcUpload;\r\n          if (CommandParams->Count == 0)\r\n          {\r\n            throw Exception(NO_UPLOAD_LIST_ERROR);\r\n          }\r\n        }\r\n        if (Params->FindSwitch(UPLOAD_IF_ANY_SWITCH, CommandParams))\r\n        {\r\n          if (CommandParams->Count > 0)\r\n          {\r\n            ParamCommand = pcUpload;\r\n          }\r\n        }\r\n        else if (Params->FindSwitch(SYNCHRONIZE_SWITCH, CommandParams, 4))\r\n        {\r\n          ParamCommand = pcFullSynchronize;\r\n        }\r\n        else if (Params->FindSwitch(KEEP_UP_TO_DATE_SWITCH, CommandParams, 4))\r\n        {\r\n          ParamCommand = pcSynchronize;\r\n        }\r\n        else if (Params->FindSwitch(L\"Edit\", CommandParams, 1) &&\r\n                 (CommandParams->Count == 1))\r\n        {\r\n          ParamCommand = pcEdit;\r\n        }\r\n        else if (Params->FindSwitch(REFRESH_SWITCH, CommandParams, 1))\r\n        {\r\n          ParamCommand = pcRefresh;\r\n        }\r\n      }\r\n\r\n      if (Params->ParamCount > 0)\r\n      {\r\n        AutoStartSession = Params->Param[1];\r\n        Params->ParamsProcessed(1, 1);\r\n\r\n        if ((ParamCommand == pcNone) &&\r\n            (WinConfiguration->ExternalSessionInExistingInstance != OpenInNewWindow()) &&\r\n            !Params->FindSwitch(NEWINSTANCE_SWICH) &&\r\n            SendToAnotherInstance())\r\n        {\r\n          Configuration->Usage->Inc(L\"SendToAnotherInstance\");\r\n          return 0;\r\n        }\r\n        UnicodeString CounterName;\r\n        if (Params->FindSwitch(JUMPLIST_SWITCH))\r\n        {\r\n          CounterName = L\"CommandLineJumpList\";\r\n        }\r\n        else if (Params->FindSwitch(DESKTOP_SWITCH))\r\n        {\r\n          CounterName = L\"CommandLineDesktop\";\r\n        }\r\n        else if (Params->FindSwitch(SEND_TO_HOOK_SWITCH))\r\n        {\r\n          CounterName = L\"CommandLineSendToHook\";\r\n        }\r\n        else\r\n        {\r\n          CounterName = L\"CommandLineSession2\";\r\n        }\r\n        Configuration->Usage->Inc(CounterName);\r\n      }\r\n      else if (WinConfiguration->EmbeddedSessions && StoredSessions->Count)\r\n      {\r\n        AutoStartSession = StoredSessions->Sessions[0]->Name;\r\n      }\r\n      else\r\n      {\r\n        AutoStartSession = WinConfiguration->AutoStartSession;\r\n      }\r\n\r\n      if (ParamCommand == pcRefresh)\r\n      {\r\n        Refresh(AutoStartSession, (CommandParams->Count > 0 ? CommandParams->Strings[0] : UnicodeString()));\r\n        return 0;\r\n      }\r\n\r\n      // from now flash message boxes on background\r\n      SetOnForeground(false);\r\n\r\n      bool NeedSession = (ParamCommand != pcNone);\r\n\r\n      bool Retry;\r\n      do\r\n      {\r\n        Retry = false;\r\n        std::unique_ptr<TObjectList> DataList(new TObjectList());\r\n        try\r\n        {\r\n          GetLoginData(AutoStartSession, Params, DataList.get(), DownloadFile, NeedSession, NULL, pufAllowStoredSiteWithProtocol);\r\n          // GetLoginData now Aborts when session is needed and none is selected\r\n          if (DebugAlwaysTrue(!NeedSession || (DataList->Count > 0)))\r\n          {\r\n            if (CheckSafe(Params))\r\n            {\r\n              UnicodeString LogFile;\r\n              if (Params->FindSwitch(LOG_SWITCH, LogFile))\r\n              {\r\n                Configuration->TemporaryLogging(LogFile);\r\n              }\r\n              if (Params->FindSwitch(L\"XmlLog\", LogFile))\r\n              {\r\n                Configuration->TemporaryActionsLogging(LogFile);\r\n              }\r\n            }\r\n\r\n            try\r\n            {\r\n              DebugAssert(!TerminalManager->ActiveTerminal);\r\n\r\n              bool CanStart;\r\n              bool Browse = false;\r\n              if (DataList->Count > 0)\r\n              {\r\n                TManagedTerminal * Terminal = TerminalManager->NewTerminals(DataList.get());\r\n                UnicodeString BrowseFile;\r\n                if (Params->FindSwitch(BROWSE_SWITCH, BrowseFile) &&\r\n                    (!BrowseFile.IsEmpty() || !DownloadFile.IsEmpty()))\r\n                {\r\n                  if (BrowseFile.IsEmpty())\r\n                  {\r\n                    BrowseFile = DownloadFile;\r\n                  }\r\n                  DebugAssert(Terminal->RemoteExplorerState == NULL);\r\n                  Terminal->RemoteExplorerState = CreateDirViewStateForFocusedItem(BrowseFile);\r\n                  DebugAssert(Terminal->LocalExplorerState == NULL);\r\n                  Terminal->LocalExplorerState = CreateDirViewStateForFocusedItem(BrowseFile);\r\n                  DownloadFile = UnicodeString();\r\n                  Browse = true;\r\n                }\r\n                if (!DownloadFile.IsEmpty())\r\n                {\r\n                  Terminal->AutoReadDirectory = false;\r\n                  DownloadFile = UnixIncludeTrailingBackslash(Terminal->SessionData->RemoteDirectory) + DownloadFile;\r\n                  Terminal->SessionData->RemoteDirectory = L\"\";\r\n                  Terminal->StateData->RemoteDirectory = Terminal->SessionData->RemoteDirectory;\r\n                }\r\n                TerminalManager->ActiveTerminal = Terminal;\r\n                CanStart = (TerminalManager->Count > 0);\r\n              }\r\n              else\r\n              {\r\n                DebugAssert(!NeedSession);\r\n                CanStart = true;\r\n              }\r\n\r\n              if (!CanStart)\r\n              {\r\n                // do not prompt with login dialog, if connection of\r\n                // auto-start session (typically from command line) failed\r\n                if (AutoStartSession.IsEmpty())\r\n                {\r\n                  Retry = true;\r\n                }\r\n              }\r\n              else\r\n              {\r\n                // from now on, we do not support runtime interface change\r\n                CustomWinConfiguration->CanApplyInterfaceImmediately = false;\r\n                TCustomScpExplorerForm * ScpExplorer = CreateScpExplorer();\r\n                CustomWinConfiguration->AppliedInterface = CustomWinConfiguration->Interface;\r\n                try\r\n                {\r\n                  // moved inside try .. __finally, because it can fail as well\r\n                  TerminalManager->ScpExplorer = ScpExplorer;\r\n\r\n                  if ((ParamCommand != pcNone) || !DownloadFile.IsEmpty())\r\n                  {\r\n                    Configuration->Usage->Inc(L\"CommandLineOperation\");\r\n                  }\r\n\r\n                  if (ParamCommand == pcUpload)\r\n                  {\r\n                    Upload(TerminalManager->ActiveTerminal, CommandParams, UseDefaults);\r\n                  }\r\n                  else if (ParamCommand == pcFullSynchronize)\r\n                  {\r\n                    FullSynchronize(TerminalManager->ActiveTerminal, ScpExplorer,\r\n                      CommandParams, UseDefaults);\r\n                  }\r\n                  else if (ParamCommand == pcSynchronize)\r\n                  {\r\n                    Synchronize(TerminalManager->ActiveTerminal, ScpExplorer,\r\n                      CommandParams, UseDefaults);\r\n                  }\r\n                  else if (ParamCommand == pcEdit)\r\n                  {\r\n                    Edit(ScpExplorer, CommandParams);\r\n                  }\r\n                  else if (!DownloadFile.IsEmpty())\r\n                  {\r\n                    Download(TerminalManager->ActiveTerminal, DownloadFile,\r\n                      UseDefaults);\r\n                  }\r\n\r\n                  if (Browse)\r\n                  {\r\n                    ScpExplorer->BrowseFile();\r\n                  }\r\n\r\n                  Application->Run();\r\n                  // to allow dialog boxes show later (like from CheckConfigurationForceSave)\r\n                  SetAppTerminated(False);\r\n                }\r\n                __finally\r\n                {\r\n                  TerminalManager->ScpExplorer = NULL;\r\n                  SAFE_DESTROY(ScpExplorer);\r\n                }\r\n              }\r\n            }\r\n            catch (Exception &E)\r\n            {\r\n              ShowExtendedException(&E);\r\n            }\r\n          }\r\n        }\r\n        // Catch EAbort from Synchronize() and similar functions, so that CheckConfigurationForceSave is processed\r\n        catch (EAbort & E)\r\n        {\r\n          Retry = false; // unlikely to be true, but just in case\r\n        }\r\n      }\r\n      while (Retry);\r\n    }\r\n\r\n    // In GUI mode only\r\n    CheckConfigurationForceSave();\r\n  }\r\n  __finally\r\n  {\r\n    delete NonVisualDataModule;\r\n    NonVisualDataModule = NULL;\r\n    ReleaseImagesModules();\r\n    delete GlyphsModule;\r\n    GlyphsModule = NULL;\r\n    TTerminalManager::DestroyInstance();\r\n    delete CommandParams;\r\n  }\r\n\r\n  return 0;\r\n}\r\n"], "fixing_code": ["<Project xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\r\n\t<PropertyGroup>\r\n\t\t<ProjectGuid>{838C77E9-8237-4097-964C-EBB952D2E9A8}</ProjectGuid>\r\n\t\t<ProjectVersion>15.4</ProjectVersion>\r\n\t\t<Config Condition=\"'$(Config)'==''\">Release</Config>\r\n\t\t<FrameworkType>None</FrameworkType>\r\n\t\t<Base>True</Base>\r\n\t\t<Platform Condition=\"'$(Platform)'==''\">Win32</Platform>\r\n\t\t<TargetedPlatforms>1</TargetedPlatforms>\r\n\t\t<AppType>Console</AppType>\r\n\t</PropertyGroup>\r\n\t<PropertyGroup Condition=\"'$(Config)'=='Base' or '$(Base)'!=''\">\r\n\t\t<Base>true</Base>\r\n\t</PropertyGroup>\r\n\t<PropertyGroup Condition=\"'$(Config)'=='Debug' or '$(Cfg_1)'!=''\">\r\n\t\t<Cfg_1>true</Cfg_1>\r\n\t\t<CfgParent>Base</CfgParent>\r\n\t\t<Base>true</Base>\r\n\t</PropertyGroup>\r\n\t<PropertyGroup Condition=\"'$(Config)'=='Release' or '$(Cfg_2)'!=''\">\r\n\t\t<Cfg_2>true</Cfg_2>\r\n\t\t<CfgParent>Base</CfgParent>\r\n\t\t<Base>true</Base>\r\n\t</PropertyGroup>\r\n\t<PropertyGroup Condition=\"'$(Base)'!=''\">\r\n\t\t<_TCHARMapping>wchar_t</_TCHARMapping>\r\n\t\t<AllPackageLibs>rtl.lib</AllPackageLibs>\r\n\t\t<BCC_AllWarnings>true</BCC_AllWarnings>\r\n\t\t<BCC_ExtendedErrorInfo>true</BCC_ExtendedErrorInfo>\r\n\t\t<BCC_OptimizeForSpeed>true</BCC_OptimizeForSpeed>\r\n\t\t<DCC_CBuilderOutput>JPHNE</DCC_CBuilderOutput>\r\n\t\t<DCC_Namespace>System;Xml;Data;Datasnap;Web;Soap;Vcl;$(DCC_Namespace)</DCC_Namespace>\r\n\t\t<FinalOutputDir>$(FINAL_PATH)\\$(Platform)\\$(Config)</FinalOutputDir>\r\n\t\t<ILINK_LibraryPath>console\\;$(ILINK_LibraryPath)</ILINK_LibraryPath>\r\n\t\t<IncludePath>console\\;$(BDS)\\include;$(BDS)\\include\\windows\\vcl;$(IncludePath)</IncludePath>\r\n\t\t<IntermediateOutputDir>$(INTERM_PATH)\\$(Platform)\\$(Config)</IntermediateOutputDir>\r\n\t\t<LinkPackageStatics>rtl.lib</LinkPackageStatics>\r\n\t\t<Manifest_File>None</Manifest_File>\r\n\t\t<Multithreaded>true</Multithreaded>\r\n\t\t<NoVCL>true</NoVCL>\r\n\t\t<OutputExt>com</OutputExt>\r\n\t\t<PackageImports>rtl.bpi;$(PackageImports)</PackageImports>\r\n\t\t<ProjectType>CppConsoleApplication</ProjectType>\r\n\t\t<SanitizedProjectName>Console</SanitizedProjectName>\r\n\t\t<VerInfo_IncludeVerInfo>true</VerInfo_IncludeVerInfo>\r\n\t\t<VerInfo_Keys>CompanyName=Martin Prikryl;FileDescription=Console interface for WinSCP;FileVersion=5.0.1.0;InternalName=console;LegalCopyright=(c) 2000-2021 Martin Prikryl;LegalTrademarks=;OriginalFilename=winscp.com;ProductName=WinSCP;ProductVersion=5.17.10.0;ReleaseType=stable;WWW=https://winscp.net/</VerInfo_Keys>\r\n\t\t<VerInfo_Locale>1033</VerInfo_Locale>\r\n\t\t<VerInfo_MajorVer>5</VerInfo_MajorVer>\r\n\t\t<VerInfo_MinorVer>0</VerInfo_MinorVer>\r\n\t\t<VerInfo_Release>1</VerInfo_Release>\r\n\t</PropertyGroup>\r\n\t<PropertyGroup Condition=\"'$(Cfg_1)'!=''\">\r\n\t\t<BCC_DebugLineNumbers>true</BCC_DebugLineNumbers>\r\n\t\t<BCC_DisableOptimizations>true</BCC_DisableOptimizations>\r\n\t\t<BCC_InlineFunctionExpansion>false</BCC_InlineFunctionExpansion>\r\n\t\t<BCC_OptimizeForSpeed>false</BCC_OptimizeForSpeed>\r\n\t\t<BCC_SourceDebuggingOn>true</BCC_SourceDebuggingOn>\r\n\t\t<BCC_StackFrames>true</BCC_StackFrames>\r\n\t\t<BCC_UseRegisterVariables>None</BCC_UseRegisterVariables>\r\n\t\t<DCC_DebugInfoInExe>true</DCC_DebugInfoInExe>\r\n\t\t<DCC_Define>DEBUG</DCC_Define>\r\n\t\t<DCC_Optimize>false</DCC_Optimize>\r\n\t\t<Defines>_DEBUG;$(Defines)</Defines>\r\n\t\t<ILINK_FullDebugInfo>true</ILINK_FullDebugInfo>\r\n\t\t<TASM_Debugging>Full</TASM_Debugging>\r\n\t\t<TASM_DisplaySourceLines>true</TASM_DisplaySourceLines>\r\n\t</PropertyGroup>\r\n\t<PropertyGroup Condition=\"'$(Cfg_2)'!=''\">\r\n\t\t<Defines>NDEBUG;$(Defines)</Defines>\r\n\t\t<TASM_Debugging>None</TASM_Debugging>\r\n\t</PropertyGroup>\r\n\t<ItemGroup>\r\n\t\t<CppCompile Include=\"console\\Main.cpp\">\r\n\t\t\t<BuildOrder>8</BuildOrder>\r\n\t\t\t<BuildOrder>0</BuildOrder>\r\n\t\t</CppCompile>\r\n\t\t<BuildConfiguration Include=\"Base\">\r\n\t\t\t<Key>Base</Key>\r\n\t\t</BuildConfiguration>\r\n\t\t<BuildConfiguration Include=\"Debug\">\r\n\t\t\t<Key>Cfg_1</Key>\r\n\t\t\t<CfgParent>Base</CfgParent>\r\n\t\t</BuildConfiguration>\r\n\t\t<BuildConfiguration Include=\"Release\">\r\n\t\t\t<Key>Cfg_2</Key>\r\n\t\t\t<CfgParent>Base</CfgParent>\r\n\t\t</BuildConfiguration>\r\n\t</ItemGroup>\r\n\t<Import Condition=\"Exists('$(BDS)\\Bin\\CodeGear.Cpp.Targets')\" Project=\"$(BDS)\\Bin\\CodeGear.Cpp.Targets\"/>\r\n\t<PropertyGroup Condition=\"'$(FileToCompile)'==''\">\r\n\t\t<PostBuildEvent>if exist \"$(FinalOutputDir)\\Console.com\" (\r\ncopy /y \"$(FinalOutputDir)\\Console.com\" \"$(FinalOutputDir)\\WinSCP.com\"\r\n) else (\r\nexit 0\r\n)</PostBuildEvent>\r\n\t</PropertyGroup>\r\n\t<ProjectExtensions>\r\n\t\t<Borland.Personality>CPlusPlusBuilder.Personality.12</Borland.Personality>\r\n\t\t<Borland.ProjectType>CppConsoleApplication</Borland.ProjectType>\r\n\t\t<BorlandProject>\r\n\t\t\t<CPlusPlusBuilder.Personality>\r\n\t\t\t\t<ProjectProperties>\r\n\t\t\t\t\t<ProjectProperties Name=\"AutoShowDeps\">False</ProjectProperties>\r\n\t\t\t\t\t<ProjectProperties Name=\"ManagePaths\">True</ProjectProperties>\r\n\t\t\t\t\t<ProjectProperties Name=\"VerifyPackages\">True</ProjectProperties>\r\n\t\t\t\t\t<ProjectProperties Name=\"IndexFiles\">False</ProjectProperties>\r\n\t\t\t\t</ProjectProperties>\r\n\t\t\t</CPlusPlusBuilder.Personality>\r\n\t\t\t<Platforms>\r\n\t\t\t\t<Platform value=\"Win32\">True</Platform>\r\n\t\t\t\t<Platform value=\"Win64\">False</Platform>\r\n\t\t\t</Platforms>\r\n\t\t</BorlandProject>\r\n\t\t<ProjectFileVersion>12</ProjectFileVersion>\r\n\t</ProjectExtensions>\r\n\t<Import Condition=\"Exists('$(APPDATA)\\Embarcadero\\$(BDSAPPDATABASEDIR)\\$(PRODUCTVERSION)\\UserTools.proj')\" Project=\"$(APPDATA)\\Embarcadero\\$(BDSAPPDATABASEDIR)\\$(PRODUCTVERSION)\\UserTools.proj\"/>\r\n</Project>\r\n", "<Project xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\r\n\t<PropertyGroup>\r\n\t\t<ProjectGuid>{414309A3-9B7C-4261-9989-4BC118D3A1C0}</ProjectGuid>\r\n\t\t<ProjectVersion>15.4</ProjectVersion>\r\n\t\t<Config Condition=\"'$(Config)'==''\">Release</Config>\r\n\t\t<FrameworkType>None</FrameworkType>\r\n\t\t<Base>True</Base>\r\n\t\t<Platform Condition=\"'$(Platform)'==''\">Win32</Platform>\r\n\t\t<TargetedPlatforms>3</TargetedPlatforms>\r\n\t\t<AppType>Library</AppType>\r\n\t</PropertyGroup>\r\n\t<PropertyGroup Condition=\"'$(Config)'=='Base' or '$(Base)'!=''\">\r\n\t\t<Base>true</Base>\r\n\t</PropertyGroup>\r\n\t<PropertyGroup Condition=\"('$(Platform)'=='Win64' and '$(Base)'=='true') or '$(Base_Win64)'!=''\">\r\n\t\t<Base_Win64>true</Base_Win64>\r\n\t\t<CfgParent>Base</CfgParent>\r\n\t\t<Base>true</Base>\r\n\t</PropertyGroup>\r\n\t<PropertyGroup Condition=\"'$(Config)'=='Debug' or '$(Cfg_1)'!=''\">\r\n\t\t<Cfg_1>true</Cfg_1>\r\n\t\t<CfgParent>Base</CfgParent>\r\n\t\t<Base>true</Base>\r\n\t</PropertyGroup>\r\n\t<PropertyGroup Condition=\"'$(Config)'=='Release' or '$(Cfg_2)'!=''\">\r\n\t\t<Cfg_2>true</Cfg_2>\r\n\t\t<CfgParent>Base</CfgParent>\r\n\t\t<Base>true</Base>\r\n\t</PropertyGroup>\r\n\t<PropertyGroup Condition=\"'$(Base)'!=''\">\r\n\t\t<_TCHARMapping>wchar_t</_TCHARMapping>\r\n\t\t<BCC_AllWarnings>true</BCC_AllWarnings>\r\n\t\t<BCC_ExtendedErrorInfo>true</BCC_ExtendedErrorInfo>\r\n\t\t<BCC_OptimizeForSpeed>true</BCC_OptimizeForSpeed>\r\n\t\t<BCC_wdlx>false</BCC_wdlx>\r\n\t\t<DCC_CBuilderOutput>JPHNE</DCC_CBuilderOutput>\r\n\t\t<DCC_Namespace>System;Xml;Data;Datasnap;Web;Soap;Vcl;$(DCC_Namespace)</DCC_Namespace>\r\n\t\t<FinalOutputDir>$(FINAL_PATH)\\$(Platform)\\$(Config)</FinalOutputDir>\r\n\t\t<ILINK_GenerateImportLibrary>true</ILINK_GenerateImportLibrary>\r\n\t\t<ILINK_LibraryPath>dragext\\;$(BDS)\\lib;$(BDS)\\lib\\obj;$(BDS)\\lib\\psdk;$(ILINK_LibraryPath)</ILINK_LibraryPath>\r\n\t\t<IncludePath>dragext\\;$(BDS)\\include;$(BDS)\\include\\windows\\vcl;$(IncludePath)</IncludePath>\r\n\t\t<IntermediateOutputDir>$(INTERM_PATH)\\$(Platform)\\$(Config)</IntermediateOutputDir>\r\n\t\t<Manifest_File>None</Manifest_File>\r\n\t\t<Multithreaded>true</Multithreaded>\r\n\t\t<NoVCL>true</NoVCL>\r\n\t\t<OutputExt>dll</OutputExt>\r\n\t\t<PackageImports>rtl.bpi;$(PackageImports)</PackageImports>\r\n\t\t<ProjectType>CppDynamicLibrary</ProjectType>\r\n\t\t<SanitizedProjectName>DragExt</SanitizedProjectName>\r\n\t\t<VerInfo_DLL>true</VerInfo_DLL>\r\n\t\t<VerInfo_IncludeVerInfo>true</VerInfo_IncludeVerInfo>\r\n\t\t<VerInfo_Keys>CompanyName=Martin Prikryl;FileDescription=Drag&amp;Drop shell extension for WinSCP ($(Platform));FileVersion=2.0.0.0;InternalName=dragext;LegalCopyright=(c) 2000-2021 Martin Prikryl;LegalTrademarks=;OriginalFilename=dragext.dll;ProductName=WinSCP;ProductVersion=5.17.10.0;ReleaseType=stable;WWW=https://winscp.net/</VerInfo_Keys>\r\n\t\t<VerInfo_Locale>1033</VerInfo_Locale>\r\n\t\t<VerInfo_MajorVer>2</VerInfo_MajorVer>\r\n\t</PropertyGroup>\r\n\t<PropertyGroup Condition=\"'$(Base_Win64)'!=''\">\r\n\t\t<OutputName>DragExt64</OutputName>\r\n\t</PropertyGroup>\r\n\t<PropertyGroup Condition=\"'$(Cfg_1)'!=''\">\r\n\t\t<BCC_DebugLineNumbers>true</BCC_DebugLineNumbers>\r\n\t\t<BCC_DisableOptimizations>true</BCC_DisableOptimizations>\r\n\t\t<BCC_InlineFunctionExpansion>false</BCC_InlineFunctionExpansion>\r\n\t\t<BCC_OptimizeForSpeed>false</BCC_OptimizeForSpeed>\r\n\t\t<BCC_SourceDebuggingOn>true</BCC_SourceDebuggingOn>\r\n\t\t<BCC_StackFrames>true</BCC_StackFrames>\r\n\t\t<BCC_UseRegisterVariables>None</BCC_UseRegisterVariables>\r\n\t\t<DCC_DebugInfoInExe>true</DCC_DebugInfoInExe>\r\n\t\t<DCC_Define>DEBUG</DCC_Define>\r\n\t\t<DCC_Optimize>false</DCC_Optimize>\r\n\t\t<Defines>_DEBUG;$(Defines)</Defines>\r\n\t\t<ILINK_FullDebugInfo>true</ILINK_FullDebugInfo>\r\n\t\t<TASM_Debugging>Full</TASM_Debugging>\r\n\t\t<TASM_DisplaySourceLines>true</TASM_DisplaySourceLines>\r\n\t</PropertyGroup>\r\n\t<PropertyGroup Condition=\"'$(Cfg_2)'!=''\">\r\n\t\t<Defines>NDEBUG;$(Defines)</Defines>\r\n\t\t<TASM_Debugging>None</TASM_Debugging>\r\n\t</PropertyGroup>\r\n\t<ItemGroup>\r\n\t\t<CppCompile Include=\"dragext\\DragExt.cpp\">\r\n\t\t\t<BuildOrder>5</BuildOrder>\r\n\t\t\t<BuildOrder>1</BuildOrder>\r\n\t\t</CppCompile>\r\n\t\t<BuildConfiguration Include=\"Base\">\r\n\t\t\t<Key>Base</Key>\r\n\t\t</BuildConfiguration>\r\n\t\t<BuildConfiguration Include=\"Debug\">\r\n\t\t\t<Key>Cfg_1</Key>\r\n\t\t\t<CfgParent>Base</CfgParent>\r\n\t\t</BuildConfiguration>\r\n\t\t<BuildConfiguration Include=\"Release\">\r\n\t\t\t<Key>Cfg_2</Key>\r\n\t\t\t<CfgParent>Base</CfgParent>\r\n\t\t</BuildConfiguration>\r\n\t</ItemGroup>\r\n\t<Import Condition=\"Exists('$(BDS)\\Bin\\CodeGear.Cpp.Targets')\" Project=\"$(BDS)\\Bin\\CodeGear.Cpp.Targets\"/>\r\n\t<ProjectExtensions>\r\n\t\t<Borland.Personality>CPlusPlusBuilder.Personality.12</Borland.Personality>\r\n\t\t<Borland.ProjectType>CppDynamicLibrary</Borland.ProjectType>\r\n\t\t<BorlandProject>\r\n\t\t\t<CPlusPlusBuilder.Personality>\r\n\t\t\t\t<ProjectProperties>\r\n\t\t\t\t\t<ProjectProperties Name=\"AutoShowDeps\">False</ProjectProperties>\r\n\t\t\t\t\t<ProjectProperties Name=\"ManagePaths\">True</ProjectProperties>\r\n\t\t\t\t\t<ProjectProperties Name=\"VerifyPackages\">True</ProjectProperties>\r\n\t\t\t\t\t<ProjectProperties Name=\"IndexFiles\">False</ProjectProperties>\r\n\t\t\t\t</ProjectProperties>\r\n\t\t\t</CPlusPlusBuilder.Personality>\r\n\t\t\t<Platforms>\r\n\t\t\t\t<Platform value=\"Win32\">True</Platform>\r\n\t\t\t\t<Platform value=\"Win64\">True</Platform>\r\n\t\t\t</Platforms>\r\n\t\t</BorlandProject>\r\n\t\t<ProjectFileVersion>12</ProjectFileVersion>\r\n\t</ProjectExtensions>\r\n\t<Import Condition=\"Exists('$(APPDATA)\\Embarcadero\\$(BDSAPPDATABASEDIR)\\$(PRODUCTVERSION)\\UserTools.proj')\" Project=\"$(APPDATA)\\Embarcadero\\$(BDSAPPDATABASEDIR)\\$(PRODUCTVERSION)\\UserTools.proj\"/>\r\n</Project>\r\n", "<Project xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\r\n\t<PropertyGroup>\r\n\t\t<ProjectGuid>{0B0C5EC6-5DCB-4F16-9504-1E6D37FFBB77}</ProjectGuid>\r\n\t\t<ProjectVersion>15.4</ProjectVersion>\r\n\t\t<MainSource>WinSCP.cpp</MainSource>\r\n\t\t<Config Condition=\"'$(Config)'==''\">Release</Config>\r\n\t\t<FrameworkType>VCL</FrameworkType>\r\n\t\t<Base>True</Base>\r\n\t\t<Platform Condition=\"'$(Platform)'==''\">Win32</Platform>\r\n\t\t<TargetedPlatforms>1</TargetedPlatforms>\r\n\t\t<AppType>Application</AppType>\r\n\t</PropertyGroup>\r\n\t<PropertyGroup Condition=\"'$(Config)'=='Base' or '$(Base)'!=''\">\r\n\t\t<Base>true</Base>\r\n\t</PropertyGroup>\r\n\t<PropertyGroup Condition=\"'$(Config)'=='Debug' or '$(Cfg_1)'!=''\">\r\n\t\t<Cfg_1>true</Cfg_1>\r\n\t\t<CfgParent>Base</CfgParent>\r\n\t\t<Base>true</Base>\r\n\t</PropertyGroup>\r\n\t<PropertyGroup Condition=\"('$(Platform)'=='Win32' and '$(Cfg_1)'=='true') or '$(Cfg_1_Win32)'!=''\">\r\n\t\t<Cfg_1_Win32>true</Cfg_1_Win32>\r\n\t\t<CfgParent>Cfg_1</CfgParent>\r\n\t\t<Cfg_1>true</Cfg_1>\r\n\t\t<Base>true</Base>\r\n\t</PropertyGroup>\r\n\t<PropertyGroup Condition=\"('$(Platform)'=='Win64' and '$(Cfg_1)'=='true') or '$(Cfg_1_Win64)'!=''\">\r\n\t\t<Cfg_1_Win64>true</Cfg_1_Win64>\r\n\t\t<CfgParent>Cfg_1</CfgParent>\r\n\t\t<Cfg_1>true</Cfg_1>\r\n\t\t<Base>true</Base>\r\n\t</PropertyGroup>\r\n\t<PropertyGroup Condition=\"'$(Config)'=='Release' or '$(Cfg_2)'!=''\">\r\n\t\t<Cfg_2>true</Cfg_2>\r\n\t\t<CfgParent>Base</CfgParent>\r\n\t\t<Base>true</Base>\r\n\t</PropertyGroup>\r\n\t<PropertyGroup Condition=\"('$(Platform)'=='Win32' and '$(Cfg_2)'=='true') or '$(Cfg_2_Win32)'!=''\">\r\n\t\t<Cfg_2_Win32>true</Cfg_2_Win32>\r\n\t\t<CfgParent>Cfg_2</CfgParent>\r\n\t\t<Cfg_2>true</Cfg_2>\r\n\t\t<Base>true</Base>\r\n\t</PropertyGroup>\r\n\t<PropertyGroup Condition=\"('$(Platform)'=='Win64' and '$(Cfg_2)'=='true') or '$(Cfg_2_Win64)'!=''\">\r\n\t\t<Cfg_2_Win64>true</Cfg_2_Win64>\r\n\t\t<CfgParent>Cfg_2</CfgParent>\r\n\t\t<Cfg_2>true</Cfg_2>\r\n\t\t<Base>true</Base>\r\n\t</PropertyGroup>\r\n\t<PropertyGroup Condition=\"'$(Base)'!=''\">\r\n\t\t<_TCHARMapping>wchar_t</_TCHARMapping>\r\n\t\t<AllPackageLibs>vcl.lib;rtl.lib;vclx.lib;ws2_32.lib;secur32.lib;My.lib;DriveDir.lib;DragDropP.lib;tb2k.lib;tbxp.lib;bcbie.lib;Crypt32.lib;PngComponents.lib;xmlrtl.lib;vclactnband.lib;vclimg.lib;winhttp.lib;jcl.lib;vclie.lib;urlmon.lib;shlwapi.lib;powrprof.lib;soaprtl.lib;fmx.lib;dbrtl.lib;inet.lib</AllPackageLibs>\r\n\t\t<BCC_AllWarnings>true</BCC_AllWarnings>\r\n\t\t<BCC_ExtendedErrorInfo>true</BCC_ExtendedErrorInfo>\r\n\t\t<BCC_OptimizeForSpeed>true</BCC_OptimizeForSpeed>\r\n\t\t<BCC_wdiu>false</BCC_wdiu>\r\n\t\t<BRCC_CodePage>65001</BRCC_CodePage>\r\n\t\t<DCC_CBuilderOutput>JPHNE</DCC_CBuilderOutput>\r\n\t\t<DCC_Namespace>Vcl;Vcl.Imaging;Vcl.Touch;Vcl.Samples;Vcl.Shell;System;Xml;Data;Datasnap;Web;Soap;Vcl;$(DCC_Namespace)</DCC_Namespace>\r\n\t\t<DCC_SYMBOL_DEPRECATED>false</DCC_SYMBOL_DEPRECATED>\r\n\t\t<DCC_SYMBOL_PLATFORM>false</DCC_SYMBOL_PLATFORM>\r\n\t\t<DCC_UNSUPPORTED_CONSTRUCT>false</DCC_UNSUPPORTED_CONSTRUCT>\r\n\t\t<Defines>STRICT;$(Defines)</Defines>\r\n\t\t<FinalOutputDir>$(FINAL_PATH)\\$(Platform)\\$(Config)</FinalOutputDir>\r\n\t\t<Icon_MainIcon>resource\\Application.ico</Icon_MainIcon>\r\n\t\t<ILINK_GenerateDRC>true</ILINK_GenerateDRC>\r\n\t\t<ILINK_LibraryPath>windows\\;forms\\;packages\\filemng;packages\\tbx;packages\\png;..\\libs\\lib;$(LIB_PATH);$(ILINK_LibraryPath)</ILINK_LibraryPath>\r\n\t\t<ILINK_MapFileType>DetailedSegments</ILINK_MapFileType>\r\n\t\t<IncludePath>console;windows\\;forms\\;core;resource;components;dragext;packages\\filemng;packages\\dragndrop;packages\\my;packages\\tb2k;packages\\tbx;packages\\png;packages\\jcl;$(BDS)\\include\\mfc;$(BDS)\\include\\windows;$(BDS)\\include\\windows\\sdk;$(BDS)\\include\\windows\\vcl;$(IncludePath)</IncludePath>\r\n\t\t<IntermediateOutputDir>$(INTERM_PATH)\\$(Platform)\\$(Config)</IntermediateOutputDir>\r\n\t\t<LinkPackageStatics>vcl.lib;rtl.lib;vclx.lib;ws2_32.lib;secur32.lib;My.lib;DriveDir.lib;DragDropP.lib;tb2k.lib;tbxp.lib;bcbie.lib;Crypt32.lib;PngComponents.lib;xmlrtl.lib;vclactnband.lib;vclimg.lib;winhttp.lib;jcl.lib;vclie.lib;urlmon.lib;shlwapi.lib;powrprof.lib;soaprtl.lib</LinkPackageStatics>\r\n\t\t<Manifest_File>windows\\WinSCP.exe.manifest</Manifest_File>\r\n\t\t<Multithreaded>true</Multithreaded>\r\n\t\t<OutputExt>exe</OutputExt>\r\n\t\t<ProjectType>CppVCLApplication</ProjectType>\r\n\t\t<SanitizedProjectName>WinSCP</SanitizedProjectName>\r\n\t\t<UsingDelphiRTL>true</UsingDelphiRTL>\r\n\t\t<VerInfo_IncludeVerInfo>true</VerInfo_IncludeVerInfo>\r\n\t\t<VerInfo_Keys>CompanyName=Martin Prikryl;FileDescription=WinSCP: SFTP, FTP, WebDAV, S3 and SCP client;FileVersion=5.17.10.0;InternalName=winscp;LegalCopyright=(c) 2000-2021 Martin Prikryl;LegalTrademarks=;OriginalFilename=winscp.exe;ProductName=WinSCP;ProductVersion=5.17.10.0;ReleaseType=stable;WWW=https://winscp.net/</VerInfo_Keys>\r\n\t\t<VerInfo_Locale>1033</VerInfo_Locale>\r\n\t\t<VerInfo_MajorVer>5</VerInfo_MajorVer>\r\n\t\t<VerInfo_MinorVer>17</VerInfo_MinorVer>\r\n\t\t<VerInfo_Release>10</VerInfo_Release>\r\n\t</PropertyGroup>\r\n\t<PropertyGroup Condition=\"'$(Cfg_1)'!=''\">\r\n\t\t<BCC_AllCodeguardOptions>true</BCC_AllCodeguardOptions>\r\n\t\t<BCC_DebugLineNumbers>true</BCC_DebugLineNumbers>\r\n\t\t<BCC_DisableOptimizations>true</BCC_DisableOptimizations>\r\n\t\t<BCC_InlineFunctionExpansion>false</BCC_InlineFunctionExpansion>\r\n\t\t<BCC_MonitorGlobalAndStackData>true</BCC_MonitorGlobalAndStackData>\r\n\t\t<BCC_MonitorInlinePtrAccess>true</BCC_MonitorInlinePtrAccess>\r\n\t\t<BCC_MonitorThis>true</BCC_MonitorThis>\r\n\t\t<BCC_OptimizeForSpeed>false</BCC_OptimizeForSpeed>\r\n\t\t<BCC_SourceDebuggingOn>true</BCC_SourceDebuggingOn>\r\n\t\t<BCC_StackFrames>true</BCC_StackFrames>\r\n\t\t<BCC_UseRegisterVariables>None</BCC_UseRegisterVariables>\r\n\t\t<DCC_DebugDCUs>true</DCC_DebugDCUs>\r\n\t\t<DCC_DebugInfoInExe>true</DCC_DebugInfoInExe>\r\n\t\t<DCC_Define>DEBUG</DCC_Define>\r\n\t\t<DCC_Optimize>false</DCC_Optimize>\r\n\t\t<Debugger_DebugSourcePath>packages\\my;packages\\filemng;packages\\jcl;..\\libs\\openssl\\crypto\\bio;..\\libs\\openssl\\ssl;..\\libs\\openssl\\crypto\\stack;..\\libs\\openssl\\crypto\\x509;..\\libs\\openssl\\crypto\\evp;..\\libs\\openssl\\crypto\\pkcs12;..\\libs\\openssl\\crypto\\pem;..\\libs\\openssl\\crypto\\asn1;..\\libs\\openssl\\crypto\\err;..\\libs\\openssl\\crypto\\rand;..\\libs\\neon\\src;..\\libs\\libs3\\src;..\\libs\\expat\\lib;$(Debugger_DebugSourcePath)</Debugger_DebugSourcePath>\r\n\t\t<Defines>_DEBUG;$(Defines)</Defines>\r\n\t\t<ILINK_FullDebugInfo>true</ILINK_FullDebugInfo>\r\n\t\t<TASM_Debugging>Full</TASM_Debugging>\r\n\t\t<TASM_DisplaySourceLines>true</TASM_DisplaySourceLines>\r\n\t</PropertyGroup>\r\n\t<PropertyGroup Condition=\"'$(Cfg_1_Win32)'!=''\">\r\n\t\t<ILINK_DisableIncrementalLinking>true</ILINK_DisableIncrementalLinking>\r\n\t\t<ILINK_LibraryPath>$(INTERM_PATH)\\Win32\\Debug\\;$(BDS)\\lib\\Win32\\Debug\\;$(BDS)\\lib\\Win32\\Release\\;$(BDS)\\lib\\Win32\\Release\\psdk\\;$(ILINK_LibraryPath)</ILINK_LibraryPath>\r\n\t\t<LinkPackageStatics>vcl.lib;rtl.lib;vclx.lib;ws2_32.lib;secur32.lib;My.lib;DriveDir.lib;DragDropP.lib;tb2k.lib;tbxp.lib;bcbie.lib;Crypt32.lib;PngComponents.lib;xmlrtl.lib;vclactnband.lib;vclimg.lib;winhttp.lib;jcl.lib;vclie.lib;urlmon.lib;shlwapi.lib;powrprof.lib;soaprtl.lib;fmx.lib;dbrtl.lib;inet.lib</LinkPackageStatics>\r\n\t</PropertyGroup>\r\n\t<PropertyGroup Condition=\"'$(Cfg_1_Win64)'!=''\">\r\n\t\t<ILINK_LibraryPath>$(INTERM_PATH)\\Win64\\Debug\\;$(BDS)\\lib\\Win64\\Debug\\;$(BDS)\\lib\\Win64\\Release\\;$(BDS)\\lib\\Win64\\Release\\psdk\\;$(ILINK_LibraryPath)</ILINK_LibraryPath>\r\n\t</PropertyGroup>\r\n\t<PropertyGroup Condition=\"'$(Cfg_2)'!=''\">\r\n\t\t<Defines>NDEBUG;$(Defines)</Defines>\r\n\t\t<TASM_Debugging>None</TASM_Debugging>\r\n\t</PropertyGroup>\r\n\t<PropertyGroup Condition=\"'$(Cfg_2_Win32)'!=''\">\r\n\t\t<ILINK_LibraryPath>$(INTERM_PATH)\\Win32\\Release\\;$(BDS)\\lib\\Win32\\Release\\;$(BDS)\\lib\\Win32\\Release\\psdk\\;$(ILINK_LibraryPath)</ILINK_LibraryPath>\r\n\t</PropertyGroup>\r\n\t<PropertyGroup Condition=\"'$(Cfg_2_Win64)'!=''\">\r\n\t\t<ILINK_LibraryPath>$(INTERM_PATH)\\Win64\\Release\\;$(BDS)\\lib\\Win64\\Release\\;$(BDS)\\lib\\Win64\\Release\\psdk\\;$(ILINK_LibraryPath)</ILINK_LibraryPath>\r\n\t</PropertyGroup>\r\n\t<ItemGroup>\r\n\t\t<CppCompile Include=\"forms\\CustomScpExplorer.cpp\">\r\n\t\t\t<BuildOrder>8</BuildOrder>\r\n\t\t\t<Form>CustomScpExplorerForm</Form>\r\n\t\t\t<DependentOn>forms\\CustomScpExplorer.h</DependentOn>\r\n\t\t\t<BuildOrder>21</BuildOrder>\r\n\t\t</CppCompile>\r\n\t\t<FormResources Include=\"forms\\CustomScpExplorer.dfm\"/>\r\n\t\t<CppCompile Include=\"forms\\NonVisual.cpp\">\r\n\t\t\t<BuildOrder>23</BuildOrder>\r\n\t\t\t<Form>NonVisualDataModule</Form>\r\n\t\t\t<DesignClass>TDataModule</DesignClass>\r\n\t\t\t<DependentOn>forms\\NonVisual.h</DependentOn>\r\n\t\t\t<BuildOrder>22</BuildOrder>\r\n\t\t</CppCompile>\r\n\t\t<FormResources Include=\"forms\\NonVisual.dfm\"/>\r\n\t\t<CppCompile Include=\"forms\\ScpCommander.cpp\">\r\n\t\t\t<BuildOrder>38</BuildOrder>\r\n\t\t\t<Form>ScpCommanderForm</Form>\r\n\t\t\t<DependentOn>forms\\ScpCommander.h</DependentOn>\r\n\t\t\t<BuildOrder>23</BuildOrder>\r\n\t\t</CppCompile>\r\n\t\t<FormResources Include=\"forms\\ScpCommander.dfm\"/>\r\n\t\t<CppCompile Include=\"forms\\ScpExplorer.cpp\">\r\n\t\t\t<BuildOrder>41</BuildOrder>\r\n\t\t\t<Form>ScpExplorerForm</Form>\r\n\t\t\t<DependentOn>forms\\ScpExplorer.h</DependentOn>\r\n\t\t\t<BuildOrder>24</BuildOrder>\r\n\t\t</CppCompile>\r\n\t\t<FormResources Include=\"forms\\ScpExplorer.dfm\"/>\r\n\t\t<CppCompile Include=\"windows\\ConsoleRunner.cpp\">\r\n\t\t\t<BuildOrder>27</BuildOrder>\r\n\t\t\t<BuildOrder>26</BuildOrder>\r\n\t\t</CppCompile>\r\n\t\t<CppCompile Include=\"windows\\CustomWinConfiguration.cpp\">\r\n\t\t\t<BuildOrder>18</BuildOrder>\r\n\t\t\t<BuildOrder>11</BuildOrder>\r\n\t\t</CppCompile>\r\n\t\t<CppCompile Include=\"windows\\EditorManager.cpp\">\r\n\t\t\t<BuildOrder>15</BuildOrder>\r\n\t\t\t<BuildOrder>14</BuildOrder>\r\n\t\t</CppCompile>\r\n\t\t<CppCompile Include=\"windows\\GUIConfiguration.cpp\">\r\n\t\t\t<BuildOrder>17</BuildOrder>\r\n\t\t\t<BuildOrder>16</BuildOrder>\r\n\t\t</CppCompile>\r\n\t\t<CppCompile Include=\"windows\\GUITools.cpp\">\r\n\t\t\t<BuildOrder>20</BuildOrder>\r\n\t\t\t<BuildOrder>17</BuildOrder>\r\n\t\t</CppCompile>\r\n\t\t<CppCompile Include=\"windows\\ProgParams.cpp\">\r\n\t\t\t<BuildOrder>29</BuildOrder>\r\n\t\t\t<BuildOrder>28</BuildOrder>\r\n\t\t</CppCompile>\r\n\t\t<CppCompile Include=\"windows\\QueueController.cpp\">\r\n\t\t\t<BuildOrder>32</BuildOrder>\r\n\t\t\t<BuildOrder>29</BuildOrder>\r\n\t\t</CppCompile>\r\n\t\t<CppCompile Include=\"windows\\Setup.cpp\">\r\n\t\t\t<BuildOrder>35</BuildOrder>\r\n\t\t\t<BuildOrder>26</BuildOrder>\r\n\t\t</CppCompile>\r\n\t\t<CppCompile Include=\"windows\\SynchronizeController.cpp\">\r\n\t\t\t<BuildOrder>44</BuildOrder>\r\n\t\t\t<BuildOrder>25</BuildOrder>\r\n\t\t</CppCompile>\r\n\t\t<CppCompile Include=\"windows\\TerminalManager.cpp\">\r\n\t\t\t<BuildOrder>47</BuildOrder>\r\n\t\t\t<BuildOrder>4</BuildOrder>\r\n\t\t</CppCompile>\r\n\t\t<CppCompile Include=\"windows\\Tools.cpp\">\r\n\t\t\t<BuildOrder>50</BuildOrder>\r\n\t\t\t<BuildOrder>5</BuildOrder>\r\n\t\t</CppCompile>\r\n\t\t<CppCompile Include=\"windows\\UserInterface.cpp\">\r\n\t\t\t<BuildOrder>6</BuildOrder>\r\n\t\t\t<BuildOrder>53</BuildOrder>\r\n\t\t</CppCompile>\r\n\t\t<CppCompile Include=\"windows\\WinConfiguration.cpp\">\r\n\t\t\t<BuildOrder>56</BuildOrder>\r\n\t\t\t<BuildOrder>3</BuildOrder>\r\n\t\t</CppCompile>\r\n\t\t<ResourceCompile Include=\"windows\\Windows.rc\">\r\n\t\t\t<BuildOrder>5</BuildOrder>\r\n\t\t\t<BuildOrder>20</BuildOrder>\r\n\t\t</ResourceCompile>\r\n\t\t<CppCompile Include=\"windows\\WinHelp.cpp\">\r\n\t\t\t<BuildOrder>59</BuildOrder>\r\n\t\t\t<BuildOrder>0</BuildOrder>\r\n\t\t</CppCompile>\r\n\t\t<CppCompile Include=\"windows\\WinInterface.cpp\">\r\n\t\t\t<BuildOrder>62</BuildOrder>\r\n\t\t\t<BuildOrder>1</BuildOrder>\r\n\t\t</CppCompile>\r\n\t\t<CppCompile Include=\"windows\\WinMain.cpp\">\r\n\t\t\t<BuildOrder>65</BuildOrder>\r\n\t\t\t<BuildOrder>2</BuildOrder>\r\n\t\t</CppCompile>\r\n\t\t<CppCompile Include=\"WinSCP.cpp\">\r\n\t\t\t<BuildOrder>2</BuildOrder>\r\n\t\t\t<BuildOrder>19</BuildOrder>\r\n\t\t</CppCompile>\r\n\t\t<LibFiles Include=\"..\\libs\\lib\\libs3.lib\" Condition=\"'$(Platform)'=='Win32'\">\r\n\t\t\t<BuildOrder>34</BuildOrder>\r\n\t\t\t<IgnorePath>true</IgnorePath>\r\n\t\t</LibFiles>\r\n\t\t<LibFiles Include=\"FileZilla.lib\">\r\n\t\t\t<BuildOrder>27</BuildOrder>\r\n\t\t\t<IgnorePath>true</IgnorePath>\r\n\t\t</LibFiles>\r\n\t\t<LibFiles Include=\"libeay32.lib\">\r\n\t\t\t<BuildOrder>28</BuildOrder>\r\n\t\t\t<IgnorePath>true</IgnorePath>\r\n\t\t</LibFiles>\r\n\t\t<LibFiles Include=\"libexpats_mtd.lib\">\r\n\t\t\t<BuildOrder>31</BuildOrder>\r\n\t\t\t<IgnorePath>true</IgnorePath>\r\n\t\t</LibFiles>\r\n\t\t<LibFiles Include=\"neon.lib\">\r\n\t\t\t<BuildOrder>33</BuildOrder>\r\n\t\t\t<IgnorePath>true</IgnorePath>\r\n\t\t</LibFiles>\r\n\t\t<LibFiles Include=\"Putty.lib\">\r\n\t\t\t<BuildOrder>23</BuildOrder>\r\n\t\t\t<IgnorePath>true</IgnorePath>\r\n\t\t</LibFiles>\r\n\t\t<LibFiles Include=\"PuTTYVS.lib\">\r\n\t\t\t<BuildOrder>33</BuildOrder>\r\n\t\t\t<IgnorePath>true</IgnorePath>\r\n\t\t</LibFiles>\r\n\t\t<LibFiles Include=\"RScpComp.lib\">\r\n\t\t\t<BuildOrder>24</BuildOrder>\r\n\t\t\t<IgnorePath>true</IgnorePath>\r\n\t\t</LibFiles>\r\n\t\t<LibFiles Include=\"ScpCore.lib\">\r\n\t\t\t<BuildOrder>25</BuildOrder>\r\n\t\t\t<IgnorePath>true</IgnorePath>\r\n\t\t</LibFiles>\r\n\t\t<LibFiles Include=\"ScpForms.lib\">\r\n\t\t\t<BuildOrder>26</BuildOrder>\r\n\t\t\t<IgnorePath>true</IgnorePath>\r\n\t\t</LibFiles>\r\n\t\t<LibFiles Include=\"ScpResources.lib\">\r\n\t\t\t<BuildOrder>26</BuildOrder>\r\n\t\t\t<IgnorePath>true</IgnorePath>\r\n\t\t</LibFiles>\r\n\t\t<LibFiles Include=\"ssleay32.lib\">\r\n\t\t\t<BuildOrder>29</BuildOrder>\r\n\t\t\t<IgnorePath>true</IgnorePath>\r\n\t\t</LibFiles>\r\n\t\t<BuildConfiguration Include=\"Base\">\r\n\t\t\t<Key>Base</Key>\r\n\t\t</BuildConfiguration>\r\n\t\t<BuildConfiguration Include=\"Debug\">\r\n\t\t\t<Key>Cfg_1</Key>\r\n\t\t\t<CfgParent>Base</CfgParent>\r\n\t\t</BuildConfiguration>\r\n\t\t<BuildConfiguration Include=\"Release\">\r\n\t\t\t<Key>Cfg_2</Key>\r\n\t\t\t<CfgParent>Base</CfgParent>\r\n\t\t</BuildConfiguration>\r\n\t</ItemGroup>\r\n\t<Import Condition=\"Exists('$(BDS)\\Bin\\CodeGear.Cpp.Targets')\" Project=\"$(BDS)\\Bin\\CodeGear.Cpp.Targets\"/>\r\n\t<ProjectExtensions>\r\n\t\t<Borland.Personality>CPlusPlusBuilder.Personality.12</Borland.Personality>\r\n\t\t<Borland.ProjectType>CppVCLApplication</Borland.ProjectType>\r\n\t\t<BorlandProject>\r\n\t\t\t<CPlusPlusBuilder.Personality>\r\n\t\t\t\t<Source>\r\n\t\t\t\t\t<Source Name=\"MainSource\">WinSCP.cpp</Source>\r\n\t\t\t\t</Source>\r\n\t\t\t\t<ProjectProperties>\r\n\t\t\t\t\t<ProjectProperties Name=\"AutoShowDeps\">False</ProjectProperties>\r\n\t\t\t\t\t<ProjectProperties Name=\"ManagePaths\">True</ProjectProperties>\r\n\t\t\t\t\t<ProjectProperties Name=\"VerifyPackages\">True</ProjectProperties>\r\n\t\t\t\t\t<ProjectProperties Name=\"IndexFiles\">False</ProjectProperties>\r\n\t\t\t\t</ProjectProperties>\r\n\t\t\t</CPlusPlusBuilder.Personality>\r\n\t\t\t<Platforms>\r\n\t\t\t\t<Platform value=\"Win32\">True</Platform>\r\n\t\t\t\t<Platform value=\"Win64\">False</Platform>\r\n\t\t\t</Platforms>\r\n\t\t</BorlandProject>\r\n\t\t<ProjectFileVersion>12</ProjectFileVersion>\r\n\t</ProjectExtensions>\r\n\t<Import Condition=\"Exists('$(APPDATA)\\Embarcadero\\$(BDSAPPDATABASEDIR)\\$(PRODUCTVERSION)\\UserTools.proj')\" Project=\"$(APPDATA)\\Embarcadero\\$(BDSAPPDATABASEDIR)\\$(PRODUCTVERSION)\\UserTools.proj\"/>\r\n</Project>\r\n", "//---------------------------------------------------------------------------\r\n#include <vcl.h>\r\n#pragma hdrstop\r\n\r\n#include \"SessionData.h\"\r\n\r\n#include \"Common.h\"\r\n#include \"Exceptions.h\"\r\n#include \"FileBuffer.h\"\r\n#include \"CoreMain.h\"\r\n#include \"TextsCore.h\"\r\n#include \"PuttyIntf.h\"\r\n#include \"RemoteFiles.h\"\r\n#include \"SFTPFileSystem.h\"\r\n#include \"S3FileSystem.h\"\r\n#include <Soap.EncdDecd.hpp>\r\n#include <StrUtils.hpp>\r\n#include <XMLDoc.hpp>\r\n#include <StrUtils.hpp>\r\n#include <algorithm>\r\n//---------------------------------------------------------------------------\r\n#pragma package(smart_init)\r\n//---------------------------------------------------------------------------\r\n#define SET_SESSION_PROPERTY_FROM(PROPERTY, FROM) \\\r\n  if (F##PROPERTY != FROM) { F##PROPERTY = FROM; Modify(); }\r\n//---------------------------------------------------------------------------\r\n#define SET_SESSION_PROPERTY(PROPERTY) \\\r\n  SET_SESSION_PROPERTY_FROM(PROPERTY, value)\r\n//---------------------------------------------------------------------------\r\nconst wchar_t * PingTypeNames = L\"Off;Null;Dummy\";\r\nconst wchar_t * ProxyMethodNames = L\"None;SOCKS4;SOCKS5;HTTP;Telnet;Cmd\";\r\nconst wchar_t * DefaultName = L\"Default Settings\";\r\nconst UnicodeString CipherNames[CIPHER_COUNT] = {L\"WARN\", L\"3des\", L\"blowfish\", L\"aes\", L\"des\", L\"arcfour\", L\"chacha20\"};\r\nconst UnicodeString KexNames[KEX_COUNT] = {L\"WARN\", L\"dh-group1-sha1\", L\"dh-group14-sha1\", L\"dh-gex-sha1\", L\"rsa\", L\"ecdh\"};\r\nconst UnicodeString HostKeyNames[HOSTKEY_COUNT] = {L\"WARN\", L\"rsa\", L\"dsa\", L\"ecdsa\", L\"ed25519\"};\r\nconst UnicodeString GssLibNames[GSSLIB_COUNT] = {L\"gssapi32\", L\"sspi\", L\"custom\"};\r\nconst wchar_t SshProtList[][10] = {L\"1\", L\"1>2\", L\"2>1\", L\"2\"};\r\n// Update also order in Ssh2CipherList()\r\nconst TCipher DefaultCipherList[CIPHER_COUNT] =\r\n  { cipAES, cipChaCha20, cipBlowfish, cip3DES, cipWarn, cipArcfour, cipDES };\r\n// Update also order in SshKexList()\r\nconst TKex DefaultKexList[KEX_COUNT] =\r\n  { kexECDH, kexDHGEx, kexDHGroup14, kexRSA, kexWarn, kexDHGroup1 };\r\nconst THostKey DefaultHostKeyList[HOSTKEY_COUNT] =\r\n  { hkED25519, hkECDSA, hkRSA, hkDSA, hkWarn };\r\nconst TGssLib DefaultGssLibList[GSSLIB_COUNT] =\r\n  { gssGssApi32, gssSspi, gssCustom };\r\nconst wchar_t FSProtocolNames[FSPROTOCOL_COUNT][16] = { L\"SCP\", L\"SFTP (SCP)\", L\"SFTP\", L\"\", L\"\", L\"FTP\", L\"WebDAV\", L\"S3\" };\r\nconst int SshPortNumber = 22;\r\nconst int FtpPortNumber = 21;\r\nconst int FtpsImplicitPortNumber = 990;\r\nconst int HTTPPortNumber = 80;\r\nconst int HTTPSPortNumber = 443;\r\nconst int TelnetPortNumber = 23;\r\nconst int DefaultSendBuf = 262144;\r\nconst int ProxyPortNumber = 80;\r\nconst UnicodeString AnonymousUserName(L\"anonymous\");\r\nconst UnicodeString AnonymousPassword(L\"anonymous@example.com\");\r\nconst UnicodeString PuttySshProtocol(L\"ssh\");\r\nconst UnicodeString PuttyTelnetProtocol(L\"telnet\");\r\nconst UnicodeString SftpProtocol(L\"sftp\");\r\nconst UnicodeString ScpProtocol(L\"scp\");\r\nconst UnicodeString FtpProtocol(L\"ftp\");\r\nconst UnicodeString FtpsProtocol(L\"ftps\");\r\nconst UnicodeString FtpesProtocol(L\"ftpes\");\r\nconst UnicodeString WebDAVProtocol(L\"dav\");\r\nconst UnicodeString WebDAVSProtocol(L\"davs\");\r\nconst UnicodeString S3Protocol(L\"s3\");\r\nconst UnicodeString SshProtocol(L\"ssh\");\r\nconst UnicodeString WinSCPProtocolPrefix(L\"winscp-\");\r\nconst wchar_t UrlParamSeparator = L';';\r\nconst wchar_t UrlParamValueSeparator = L'=';\r\nconst UnicodeString UrlHostKeyParamName(L\"fingerprint\");\r\nconst UnicodeString UrlSaveParamName(L\"save\");\r\nconst UnicodeString UrlRawSettingsParamNamePrefix(L\"x-\");\r\nconst UnicodeString PassphraseOption(L\"passphrase\");\r\nconst UnicodeString RawSettingsOption(L\"rawsettings\");\r\nconst UnicodeString S3HostName(S3LibDefaultHostName());\r\n//---------------------------------------------------------------------\r\nTDateTime __fastcall SecToDateTime(int Sec)\r\n{\r\n  return TDateTime(double(Sec) / SecsPerDay);\r\n}\r\n//--- TSessionData ----------------------------------------------------\r\n__fastcall TSessionData::TSessionData(UnicodeString aName):\r\n  TNamedObject(aName)\r\n{\r\n  Default();\r\n  FModified = true;\r\n}\r\n//---------------------------------------------------------------------\r\n_fastcall TSessionData::~TSessionData()\r\n{\r\n}\r\n//---------------------------------------------------------------------\r\nint __fastcall TSessionData::Compare(TNamedObject * Other)\r\n{\r\n  int Result;\r\n  // To avoid using CompareLogicalText on hex names of sessions in workspace.\r\n  // The session 000A would be sorted before 0001.\r\n  if (IsWorkspace && DebugNotNull(dynamic_cast<TSessionData *>(Other))->IsWorkspace)\r\n  {\r\n    Result = CompareText(Name, Other->Name);\r\n  }\r\n  else\r\n  {\r\n    Result = TNamedObject::Compare(Other);\r\n  }\r\n  return Result;\r\n}\r\n//---------------------------------------------------------------------\r\nTSessionData * __fastcall TSessionData::Clone()\r\n{\r\n  std::unique_ptr<TSessionData> Data(new TSessionData(L\"\"));\r\n  Data->Assign(this);\r\n  return Data.release();\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::DefaultSettings()\r\n{\r\n  HostName = L\"\";\r\n  PortNumber = SshPortNumber;\r\n  UserName = L\"\";\r\n  Password = L\"\";\r\n  NewPassword = L\"\";\r\n  ChangePassword = false;\r\n  PingInterval = 30;\r\n  PingType = ptOff;\r\n  Timeout = 15;\r\n  TryAgent = true;\r\n  AgentFwd = false;\r\n  AuthTIS = false;\r\n  AuthKI = true;\r\n  AuthKIPassword = true;\r\n  AuthGSSAPI = true;\r\n  GSSAPIFwdTGT = false;\r\n  LogicalHostName = L\"\";\r\n  ChangeUsername = false;\r\n  Compression = false;\r\n  SshProt = ssh2only;\r\n  Ssh2DES = false;\r\n  SshNoUserAuth = false;\r\n  for (int Index = 0; Index < CIPHER_COUNT; Index++)\r\n  {\r\n    Cipher[Index] = DefaultCipherList[Index];\r\n  }\r\n  for (int Index = 0; Index < KEX_COUNT; Index++)\r\n  {\r\n    Kex[Index] = DefaultKexList[Index];\r\n  }\r\n  for (int Index = 0; Index < HOSTKEY_COUNT; Index++)\r\n  {\r\n    HostKeys[Index] = DefaultHostKeyList[Index];\r\n  }\r\n  for (int Index = 0; Index < GSSLIB_COUNT; Index++)\r\n  {\r\n    GssLib[Index] = DefaultGssLibList[Index];\r\n  }\r\n  GssLibCustom = L\"\";\r\n  PublicKeyFile = L\"\";\r\n  Passphrase = L\"\";\r\n  FPuttyProtocol = L\"\";\r\n  TcpNoDelay = false;\r\n  SendBuf = DefaultSendBuf;\r\n  SourceAddress = L\"\";\r\n  SshSimple = true;\r\n  HostKey = L\"\";\r\n  FingerprintScan = false;\r\n  FOverrideCachedHostKey = true;\r\n  Note = L\"\";\r\n  WinTitle = L\"\";\r\n  InternalEditorEncoding = -1;\r\n\r\n  EncryptKey = UnicodeString();\r\n\r\n  ProxyMethod = ::pmNone;\r\n  ProxyHost = L\"proxy\";\r\n  ProxyPort = ProxyPortNumber;\r\n  ProxyUsername = L\"\";\r\n  ProxyPassword = L\"\";\r\n  ProxyTelnetCommand = L\"connect %host %port\\\\n\";\r\n  ProxyLocalCommand = L\"\";\r\n  ProxyDNS = asAuto;\r\n  ProxyLocalhost = false;\r\n\r\n  for (unsigned int Index = 0; Index < LENOF(FBugs); Index++)\r\n  {\r\n    Bug[(TSshBug)Index] = asAuto;\r\n  }\r\n\r\n  Special = false;\r\n  FSProtocol = fsSFTP;\r\n  AddressFamily = afAuto;\r\n  RekeyData = L\"1G\";\r\n  RekeyTime = MinsPerHour;\r\n\r\n  // FS common\r\n  LocalDirectory = L\"\";\r\n  RemoteDirectory = L\"\";\r\n  SynchronizeBrowsing = false;\r\n  UpdateDirectories = true;\r\n  CacheDirectories = true;\r\n  CacheDirectoryChanges = true;\r\n  PreserveDirectoryChanges = true;\r\n  LockInHome = false;\r\n  ResolveSymlinks = true;\r\n  FollowDirectorySymlinks = false;\r\n  DSTMode = dstmUnix;\r\n  DeleteToRecycleBin = false;\r\n  OverwrittenToRecycleBin = false;\r\n  RecycleBinPath = L\"\";\r\n  Color = 0;\r\n  PostLoginCommands = L\"\";\r\n\r\n  // SCP\r\n  LookupUserGroups = asAuto;\r\n  EOLType = eolLF;\r\n  TrimVMSVersions = false;\r\n  Shell = L\"\"; //default shell\r\n  ReturnVar = L\"\";\r\n  ExitCode1IsError = false;\r\n  ClearAliases = true;\r\n  UnsetNationalVars = true;\r\n  ListingCommand = L\"ls -la\";\r\n  IgnoreLsWarnings = true;\r\n  Scp1Compatibility = false;\r\n  TimeDifference = 0;\r\n  TimeDifferenceAuto = true;\r\n  SCPLsFullTime = asAuto;\r\n  NotUtf = asAuto;\r\n\r\n  S3DefaultRegion = L\"\";\r\n  S3UrlStyle = s3usVirtualHost;\r\n\r\n  // SFTP\r\n  SftpServer = L\"\";\r\n  SFTPDownloadQueue = 32;\r\n  SFTPUploadQueue = 32;\r\n  SFTPListingQueue = 2;\r\n  SFTPMaxVersion = ::SFTPMaxVersion;\r\n  SFTPMaxPacketSize = 0;\r\n\r\n  for (unsigned int Index = 0; Index < LENOF(FSFTPBugs); Index++)\r\n  {\r\n    SFTPBug[(TSftpBug)Index] = asAuto;\r\n  }\r\n\r\n  Tunnel = false;\r\n  TunnelHostName = L\"\";\r\n  TunnelPortNumber = SshPortNumber;\r\n  TunnelUserName = L\"\";\r\n  TunnelPassword = L\"\";\r\n  TunnelPublicKeyFile = L\"\";\r\n  TunnelLocalPortNumber = 0;\r\n  TunnelPortFwd = L\"\";\r\n  TunnelHostKey = L\"\";\r\n\r\n  // FTP\r\n  FtpPasvMode = true;\r\n  FtpForcePasvIp = asAuto;\r\n  FtpUseMlsd = asAuto;\r\n  FtpAccount = L\"\";\r\n  FtpPingInterval = 30;\r\n  FtpPingType = ptDummyCommand;\r\n  FtpTransferActiveImmediately = asAuto;\r\n  Ftps = ftpsNone;\r\n  MinTlsVersion = tls10;\r\n  MaxTlsVersion = tls12;\r\n  FtpListAll = asAuto;\r\n  FtpHost = asAuto;\r\n  FtpDeleteFromCwd = asAuto;\r\n  SslSessionReuse = true;\r\n  TlsCertificateFile = L\"\";\r\n\r\n  FtpProxyLogonType = 0; // none\r\n\r\n  PuttySettings = UnicodeString();\r\n\r\n  CustomParam1 = L\"\";\r\n  CustomParam2 = L\"\";\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::Default()\r\n{\r\n  DefaultSettings();\r\n\r\n  IsWorkspace = false;\r\n  Link = L\"\";\r\n  NameOverride = L\"\";\r\n\r\n  Selected = false;\r\n  FModified = false;\r\n  FSource = ::ssNone;\r\n  FSaveOnly = false;\r\n\r\n  // add also to TSessionLog::AddStartupInfo()\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::NonPersistant()\r\n{\r\n  UpdateDirectories = false;\r\n  PreserveDirectoryChanges = false;\r\n}\r\n//---------------------------------------------------------------------\r\n#define PROPERTY(P) PROPERTY_HANDLER(P, )\r\n#define BASE_PROPERTIES \\\r\n  PROPERTY(HostName); \\\r\n  PROPERTY(PortNumber); \\\r\n  PROPERTY(UserName); \\\r\n  PROPERTY_HANDLER(Password, F); \\\r\n  PROPERTY(PublicKeyFile); \\\r\n  PROPERTY_HANDLER(Passphrase, F); \\\r\n  PROPERTY(FSProtocol); \\\r\n  PROPERTY(Ftps); \\\r\n  PROPERTY(LocalDirectory); \\\r\n  PROPERTY(RemoteDirectory); \\\r\n  PROPERTY(Color); \\\r\n  PROPERTY(SynchronizeBrowsing); \\\r\n  PROPERTY(Note);\r\n//---------------------------------------------------------------------\r\n#define ADVANCED_PROPERTIES \\\r\n  PROPERTY_HANDLER(NewPassword, F); \\\r\n  PROPERTY(ChangePassword); \\\r\n  PROPERTY(PingInterval); \\\r\n  PROPERTY(PingType); \\\r\n  PROPERTY(Timeout); \\\r\n  PROPERTY(TryAgent); \\\r\n  PROPERTY(AgentFwd); \\\r\n  PROPERTY(AuthTIS); \\\r\n  PROPERTY(LogicalHostName); \\\r\n  PROPERTY(ChangeUsername); \\\r\n  PROPERTY(Compression); \\\r\n  PROPERTY(SshProt); \\\r\n  PROPERTY(Ssh2DES); \\\r\n  PROPERTY(SshNoUserAuth); \\\r\n  PROPERTY(CipherList); \\\r\n  PROPERTY(KexList); \\\r\n  PROPERTY(HostKeyList); \\\r\n  PROPERTY(GssLibList); \\\r\n  PROPERTY(GssLibCustom); \\\r\n  PROPERTY(AddressFamily); \\\r\n  PROPERTY(RekeyData); \\\r\n  PROPERTY(RekeyTime); \\\r\n  PROPERTY(HostKey); \\\r\n  PROPERTY(FingerprintScan); \\\r\n  PROPERTY(InternalEditorEncoding); \\\r\n  \\\r\n  PROPERTY(UpdateDirectories); \\\r\n  PROPERTY(CacheDirectories); \\\r\n  PROPERTY(CacheDirectoryChanges); \\\r\n  PROPERTY(PreserveDirectoryChanges); \\\r\n  \\\r\n  PROPERTY(ResolveSymlinks); \\\r\n  PROPERTY(FollowDirectorySymlinks); \\\r\n  PROPERTY(DSTMode); \\\r\n  PROPERTY(LockInHome); \\\r\n  PROPERTY(Special); \\\r\n  PROPERTY(Selected); \\\r\n  PROPERTY(ReturnVar); \\\r\n  PROPERTY(ExitCode1IsError); \\\r\n  PROPERTY(LookupUserGroups); \\\r\n  PROPERTY(EOLType); \\\r\n  PROPERTY(TrimVMSVersions); \\\r\n  PROPERTY(Shell); \\\r\n  PROPERTY(ClearAliases); \\\r\n  PROPERTY(Scp1Compatibility); \\\r\n  PROPERTY(UnsetNationalVars); \\\r\n  PROPERTY(ListingCommand); \\\r\n  PROPERTY(IgnoreLsWarnings); \\\r\n  PROPERTY(SCPLsFullTime); \\\r\n  \\\r\n  PROPERTY(TimeDifference); \\\r\n  PROPERTY(TimeDifferenceAuto); \\\r\n  PROPERTY(TcpNoDelay); \\\r\n  PROPERTY(SendBuf); \\\r\n  PROPERTY(SourceAddress); \\\r\n  PROPERTY(SshSimple); \\\r\n  PROPERTY(AuthKI); \\\r\n  PROPERTY(AuthKIPassword); \\\r\n  PROPERTY(AuthGSSAPI); \\\r\n  PROPERTY(GSSAPIFwdTGT); \\\r\n  PROPERTY(DeleteToRecycleBin); \\\r\n  PROPERTY(OverwrittenToRecycleBin); \\\r\n  PROPERTY(RecycleBinPath); \\\r\n  PROPERTY(NotUtf); \\\r\n  PROPERTY(PostLoginCommands); \\\r\n  \\\r\n  PROPERTY(S3DefaultRegion); \\\r\n  PROPERTY(S3UrlStyle); \\\r\n  \\\r\n  PROPERTY(ProxyMethod); \\\r\n  PROPERTY(ProxyHost); \\\r\n  PROPERTY(ProxyPort); \\\r\n  PROPERTY(ProxyUsername); \\\r\n  PROPERTY_HANDLER(ProxyPassword, F); \\\r\n  PROPERTY(ProxyTelnetCommand); \\\r\n  PROPERTY(ProxyLocalCommand); \\\r\n  PROPERTY(ProxyDNS); \\\r\n  PROPERTY(ProxyLocalhost); \\\r\n  \\\r\n  for (unsigned int Index = 0; Index < LENOF(FBugs); Index++) \\\r\n  { \\\r\n    PROPERTY(Bug[(TSshBug)Index]); \\\r\n  } \\\r\n  \\\r\n  PROPERTY(SftpServer); \\\r\n  PROPERTY(SFTPDownloadQueue); \\\r\n  PROPERTY(SFTPUploadQueue); \\\r\n  PROPERTY(SFTPListingQueue); \\\r\n  PROPERTY(SFTPMaxVersion); \\\r\n  PROPERTY(SFTPMaxPacketSize); \\\r\n  \\\r\n  for (unsigned int Index = 0; Index < LENOF(FSFTPBugs); Index++) \\\r\n  { \\\r\n    PROPERTY(SFTPBug[(TSftpBug)Index]); \\\r\n  } \\\r\n  \\\r\n  PROPERTY(Tunnel); \\\r\n  PROPERTY(TunnelHostName); \\\r\n  PROPERTY(TunnelPortNumber); \\\r\n  PROPERTY(TunnelUserName); \\\r\n  PROPERTY_HANDLER(TunnelPassword, F); \\\r\n  PROPERTY(TunnelPublicKeyFile); \\\r\n  PROPERTY(TunnelLocalPortNumber); \\\r\n  PROPERTY(TunnelPortFwd); \\\r\n  PROPERTY(TunnelHostKey); \\\r\n  \\\r\n  PROPERTY(FtpPasvMode); \\\r\n  PROPERTY(FtpForcePasvIp); \\\r\n  PROPERTY(FtpUseMlsd); \\\r\n  PROPERTY(FtpAccount); \\\r\n  PROPERTY(FtpPingInterval); \\\r\n  PROPERTY(FtpPingType); \\\r\n  PROPERTY(FtpTransferActiveImmediately); \\\r\n  PROPERTY(FtpListAll); \\\r\n  PROPERTY(FtpHost); \\\r\n  PROPERTY(FtpDeleteFromCwd); \\\r\n  PROPERTY(SslSessionReuse); \\\r\n  PROPERTY(TlsCertificateFile); \\\r\n  \\\r\n  PROPERTY(FtpProxyLogonType); \\\r\n  \\\r\n  PROPERTY(MinTlsVersion); \\\r\n  PROPERTY(MaxTlsVersion); \\\r\n  \\\r\n  PROPERTY(WinTitle); \\\r\n  \\\r\n  PROPERTY_HANDLER(EncryptKey, F); \\\r\n  \\\r\n  PROPERTY(PuttySettings); \\\r\n  \\\r\n  PROPERTY(CustomParam1); \\\r\n  PROPERTY(CustomParam2);\r\n#define META_PROPERTIES \\\r\n  PROPERTY(IsWorkspace); \\\r\n  PROPERTY(Link); \\\r\n  PROPERTY(NameOverride);\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::Assign(TPersistent * Source)\r\n{\r\n  if (Source && Source->InheritsFrom(__classid(TSessionData)))\r\n  {\r\n    TSessionData * SourceData = (TSessionData *)Source;\r\n    // Master password prompt shows implicitly here, when cloning the session data for a new terminal\r\n    CopyData(SourceData);\r\n    FSource = SourceData->FSource;\r\n  }\r\n  else\r\n  {\r\n    TNamedObject::Assign(Source);\r\n  }\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::DoCopyData(TSessionData * SourceData, bool NoRecrypt)\r\n{\r\n  #define PROPERTY_HANDLER(P, F) \\\r\n    if (NoRecrypt) \\\r\n    { \\\r\n      F##P = SourceData->F##P; \\\r\n    } \\\r\n    else \\\r\n    { \\\r\n      P = SourceData->P; \\\r\n    }\r\n  PROPERTY(Name);\r\n  BASE_PROPERTIES;\r\n  ADVANCED_PROPERTIES;\r\n  META_PROPERTIES;\r\n  #undef PROPERTY_HANDLER\r\n  FOverrideCachedHostKey = SourceData->FOverrideCachedHostKey;\r\n  FModified = SourceData->Modified;\r\n  FSaveOnly = SourceData->FSaveOnly;\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::CopyData(TSessionData * SourceData)\r\n{\r\n  DoCopyData(SourceData, false);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::CopyDataNoRecrypt(TSessionData * SourceData)\r\n{\r\n  DoCopyData(SourceData, true);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::CopyDirectoriesStateData(TSessionData * SourceData)\r\n{\r\n  RemoteDirectory = SourceData->RemoteDirectory;\r\n  LocalDirectory = SourceData->LocalDirectory;\r\n  SynchronizeBrowsing = SourceData->SynchronizeBrowsing;\r\n}\r\n//---------------------------------------------------------------------\r\nbool __fastcall TSessionData::HasStateData()\r\n{\r\n  return\r\n    !RemoteDirectory.IsEmpty() ||\r\n    !LocalDirectory.IsEmpty() ||\r\n    (Color != 0);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::CopyStateData(TSessionData * SourceData)\r\n{\r\n  // Keep in sync with TCustomScpExplorerForm::UpdateSessionData.\r\n  CopyDirectoriesStateData(SourceData);\r\n  Color = SourceData->Color;\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::CopyNonCoreData(TSessionData * SourceData)\r\n{\r\n  CopyStateData(SourceData);\r\n  UpdateDirectories = SourceData->UpdateDirectories;\r\n  Note = SourceData->Note;\r\n}\r\n//---------------------------------------------------------------------\r\nbool __fastcall TSessionData::IsSame(\r\n  const TSessionData * Default, bool AdvancedOnly, TStrings * DifferentProperties, bool Decrypted)\r\n{\r\n  bool Result = true;\r\n  #define PROPERTY_HANDLER(P, F) \\\r\n    if ((Decrypted && (P != Default->P)) || \\\r\n        (!Decrypted && (F##P != Default->F##P))) \\\r\n    { \\\r\n      Result = false; \\\r\n      if (DifferentProperties != NULL) \\\r\n      { \\\r\n        DifferentProperties->Add(#P); \\\r\n      } \\\r\n      else \\\r\n      { \\\r\n        return Result; \\\r\n      } \\\r\n    }\r\n\r\n  if (!AdvancedOnly)\r\n  {\r\n    BASE_PROPERTIES;\r\n    META_PROPERTIES;\r\n  }\r\n  ADVANCED_PROPERTIES;\r\n  #undef PROPERTY_HANDLER\r\n  return Result;\r\n}\r\n//---------------------------------------------------------------------\r\nbool __fastcall TSessionData::IsSame(const TSessionData * Default, bool AdvancedOnly)\r\n{\r\n  return IsSame(Default, AdvancedOnly, NULL, false);\r\n}\r\n//---------------------------------------------------------------------\r\nbool __fastcall TSessionData::IsSameDecrypted(const TSessionData * Default)\r\n{\r\n  return IsSame(Default, false, NULL, true);\r\n}\r\n//---------------------------------------------------------------------\r\nTFSProtocol NormalizeFSProtocol(TFSProtocol FSProtocol)\r\n{\r\n  if (FSProtocol == fsSFTPonly)\r\n  {\r\n    FSProtocol = fsSFTP;\r\n  }\r\n  return FSProtocol;\r\n}\r\n//---------------------------------------------------------------------\r\nbool __fastcall TSessionData::IsSameSite(const TSessionData * Other)\r\n{\r\n  return\r\n    // Particularly when handling /refresh,\r\n    // fsSFTPonly sites when compared against sftp:// URLs (fsSFTP) have to match.\r\n    // But similarly also falled back SCP sites.\r\n    (NormalizeFSProtocol(FSProtocol) == NormalizeFSProtocol(Other->FSProtocol)) &&\r\n    (HostName == Other->HostName) &&\r\n    (PortNumber == Other->PortNumber) &&\r\n    (UserName == Other->UserName);\r\n}\r\n//---------------------------------------------------------------------\r\nbool __fastcall TSessionData::IsInFolderOrWorkspace(UnicodeString AFolder)\r\n{\r\n  return StartsText(UnixIncludeTrailingBackslash(AFolder), Name);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::DoLoad(THierarchicalStorage * Storage, bool PuttyImport, bool & RewritePassword, bool Unsafe)\r\n{\r\n  // Make sure we only ever use methods supported by TOptionsStorage\r\n  // (implemented by TOptionsIniFile)\r\n\r\n  PortNumber = Storage->ReadInteger(L\"PortNumber\", PortNumber);\r\n  UserName = Storage->ReadString(L\"UserName\", UserName);\r\n  // must be loaded after UserName, because HostName may be in format user@host\r\n  HostName = Storage->ReadString(L\"HostName\", HostName);\r\n\r\n  if (!Configuration->DisablePasswordStoring)\r\n  {\r\n    if (Storage->ValueExists(L\"PasswordPlain\"))\r\n    {\r\n      Password = Storage->ReadString(L\"PasswordPlain\", Password);\r\n      RewritePassword = true;\r\n    }\r\n    else\r\n    {\r\n      RawByteString APassword = Storage->ReadStringAsBinaryData(L\"Password\", FPassword);\r\n      SET_SESSION_PROPERTY_FROM(Password, APassword);\r\n    }\r\n  }\r\n  HostKey = Storage->ReadString(L\"SshHostKey\", HostKey); // probably never used\r\n  Note = Storage->ReadString(L\"Note\", Note);\r\n  // Putty uses PingIntervalSecs\r\n  int PingIntervalSecs = Storage->ReadInteger(L\"PingIntervalSecs\", -1);\r\n  if (PingIntervalSecs < 0)\r\n  {\r\n    PingIntervalSecs = Storage->ReadInteger(L\"PingIntervalSec\", PingInterval%SecsPerMin);\r\n  }\r\n  PingInterval =\r\n    Storage->ReadInteger(L\"PingInterval\", PingInterval/SecsPerMin)*SecsPerMin +\r\n    PingIntervalSecs;\r\n  if (PingInterval == 0)\r\n  {\r\n    PingInterval = 30;\r\n  }\r\n  PingType = static_cast<TPingType>(Storage->ReadInteger(L\"PingType\", PingType));\r\n  Timeout = Storage->ReadInteger(L\"Timeout\", Timeout);\r\n  TryAgent = Storage->ReadBool(L\"TryAgent\", TryAgent);\r\n  AgentFwd = Storage->ReadBool(L\"AgentFwd\", AgentFwd);\r\n  AuthTIS = Storage->ReadBool(L\"AuthTIS\", AuthTIS);\r\n  AuthKI = Storage->ReadBool(L\"AuthKI\", AuthKI);\r\n  AuthKIPassword = Storage->ReadBool(L\"AuthKIPassword\", AuthKIPassword);\r\n  // Continue to use setting keys of previous kerberos implementation (vaclav tomec),\r\n  // but fallback to keys of other implementations (official putty and vintela quest putty),\r\n  // to allow imports from all putty versions.\r\n  // Both vaclav tomec and official putty use AuthGSSAPI\r\n  AuthGSSAPI = Storage->ReadBool(L\"AuthGSSAPI\", Storage->ReadBool(L\"AuthSSPI\", AuthGSSAPI));\r\n  GSSAPIFwdTGT = Storage->ReadBool(L\"GSSAPIFwdTGT\", Storage->ReadBool(L\"GssapiFwd\", Storage->ReadBool(L\"SSPIFwdTGT\", GSSAPIFwdTGT)));\r\n  // KerbPrincipal was used by Quest PuTTY\r\n  // GSSAPIServerRealm was used by Vaclav Tomec\r\n  LogicalHostName = Storage->ReadString(L\"LogicalHostName\", Storage->ReadString(L\"GSSAPIServerRealm\", Storage->ReadString(L\"KerbPrincipal\", LogicalHostName)));\r\n  ChangeUsername = Storage->ReadBool(L\"ChangeUsername\", ChangeUsername);\r\n  Compression = Storage->ReadBool(L\"Compression\", Compression);\r\n  TSshProt ASshProt = (TSshProt)Storage->ReadInteger(L\"SshProt\", SshProt);\r\n  // Old sessions may contain the values correponding to the fallbacks we used to allow; migrate them\r\n  if (ASshProt == ssh2deprecated)\r\n  {\r\n    ASshProt = ssh2only;\r\n  }\r\n  else if (ASshProt == ssh1deprecated)\r\n  {\r\n    ASshProt = ssh1only;\r\n  }\r\n  SshProt = ASshProt;\r\n  Ssh2DES = Storage->ReadBool(L\"Ssh2DES\", Ssh2DES);\r\n  SshNoUserAuth = Storage->ReadBool(L\"SshNoUserAuth\", SshNoUserAuth);\r\n  CipherList = Storage->ReadString(L\"Cipher\", CipherList);\r\n  KexList = Storage->ReadString(L\"KEX\", KexList);\r\n  HostKeyList = Storage->ReadString(L\"HostKey\", HostKeyList);\r\n  if (!Unsafe)\r\n  {\r\n    GssLibList = Storage->ReadString(L\"GSSLibs\", GssLibList);\r\n  }\r\n  GssLibCustom = Storage->ReadString(L\"GSSCustom\", GssLibCustom);\r\n  PublicKeyFile = Storage->ReadString(L\"PublicKeyFile\", PublicKeyFile);\r\n  AddressFamily = static_cast<TAddressFamily>\r\n    (Storage->ReadInteger(L\"AddressFamily\", AddressFamily));\r\n  RekeyData = Storage->ReadString(L\"RekeyBytes\", RekeyData);\r\n  RekeyTime = Storage->ReadInteger(L\"RekeyTime\", RekeyTime);\r\n\r\n  FSProtocol = (TFSProtocol)Storage->ReadInteger(L\"FSProtocol\", FSProtocol);\r\n  LocalDirectory = Storage->ReadString(L\"LocalDirectory\", LocalDirectory);\r\n  RemoteDirectory = Storage->ReadString(L\"RemoteDirectory\", RemoteDirectory);\r\n  SynchronizeBrowsing = Storage->ReadBool(L\"SynchronizeBrowsing\", SynchronizeBrowsing);\r\n  UpdateDirectories = Storage->ReadBool(L\"UpdateDirectories\", UpdateDirectories);\r\n  CacheDirectories = Storage->ReadBool(L\"CacheDirectories\", CacheDirectories);\r\n  CacheDirectoryChanges = Storage->ReadBool(L\"CacheDirectoryChanges\", CacheDirectoryChanges);\r\n  PreserveDirectoryChanges = Storage->ReadBool(L\"PreserveDirectoryChanges\", PreserveDirectoryChanges);\r\n\r\n  ResolveSymlinks = Storage->ReadBool(L\"ResolveSymlinks\", ResolveSymlinks);\r\n  FollowDirectorySymlinks = Storage->ReadBool(L\"FollowDirectorySymlinks\", FollowDirectorySymlinks);\r\n  DSTMode = (TDSTMode)Storage->ReadInteger(L\"ConsiderDST\", DSTMode);\r\n  LockInHome = Storage->ReadBool(L\"LockInHome\", LockInHome);\r\n  Special = Storage->ReadBool(L\"Special\", Special);\r\n  if (!Unsafe)\r\n  {\r\n    Shell = Storage->ReadString(L\"Shell\", Shell);\r\n  }\r\n  ClearAliases = Storage->ReadBool(L\"ClearAliases\", ClearAliases);\r\n  UnsetNationalVars = Storage->ReadBool(L\"UnsetNationalVars\", UnsetNationalVars);\r\n  if (!Unsafe)\r\n  {\r\n    ListingCommand = Storage->ReadString(L\"ListingCommand\",\r\n      Storage->ReadBool(L\"AliasGroupList\", false) ? UnicodeString(L\"ls -gla\") : ListingCommand);\r\n  }\r\n  IgnoreLsWarnings = Storage->ReadBool(L\"IgnoreLsWarnings\", IgnoreLsWarnings);\r\n  SCPLsFullTime = TAutoSwitch(Storage->ReadInteger(L\"SCPLsFullTime\", SCPLsFullTime));\r\n  Scp1Compatibility = Storage->ReadBool(L\"Scp1Compatibility\", Scp1Compatibility);\r\n  TimeDifference = Storage->ReadFloat(L\"TimeDifference\", TimeDifference);\r\n  TimeDifferenceAuto = Storage->ReadBool(L\"TimeDifferenceAuto\", (TimeDifference == TDateTime()));\r\n  if (!Unsafe)\r\n  {\r\n    DeleteToRecycleBin = Storage->ReadBool(L\"DeleteToRecycleBin\", DeleteToRecycleBin);\r\n    OverwrittenToRecycleBin = Storage->ReadBool(L\"OverwrittenToRecycleBin\", OverwrittenToRecycleBin);\r\n    RecycleBinPath = Storage->ReadString(L\"RecycleBinPath\", RecycleBinPath);\r\n    PostLoginCommands = Storage->ReadString(L\"PostLoginCommands\", PostLoginCommands);\r\n    ReturnVar = Storage->ReadString(L\"ReturnVar\", ReturnVar);\r\n  }\r\n\r\n  ExitCode1IsError = Storage->ReadBool(L\"ExitCode1IsError\", ExitCode1IsError);\r\n  LookupUserGroups = TAutoSwitch(Storage->ReadInteger(L\"LookupUserGroups2\", LookupUserGroups));\r\n  EOLType = (TEOLType)Storage->ReadInteger(L\"EOLType\", EOLType);\r\n  TrimVMSVersions = Storage->ReadBool(L\"TrimVMSVersions\", TrimVMSVersions);\r\n  NotUtf = TAutoSwitch(Storage->ReadInteger(L\"Utf\", Storage->ReadInteger(L\"SFTPUtfBug\", NotUtf)));\r\n  InternalEditorEncoding = Storage->ReadInteger(L\"InternalEditorEncoding\", InternalEditorEncoding);\r\n\r\n  S3DefaultRegion = Storage->ReadString(L\"S3DefaultRegion\", S3DefaultRegion);\r\n  S3UrlStyle = (TS3UrlStyle)Storage->ReadInteger(L\"S3UrlStyle\", S3UrlStyle);\r\n\r\n  // PuTTY defaults to TcpNoDelay, but the psftp/pscp ignores this preference, and always set this to off (what is our default too)\r\n  if (!PuttyImport)\r\n  {\r\n    TcpNoDelay = Storage->ReadBool(L\"TcpNoDelay\", TcpNoDelay);\r\n  }\r\n  SendBuf = Storage->ReadInteger(L\"SendBuf\", Storage->ReadInteger(\"SshSendBuf\", SendBuf));\r\n  SourceAddress = Storage->ReadString(L\"SourceAddress\", SourceAddress);\r\n  SshSimple = Storage->ReadBool(L\"SshSimple\", SshSimple);\r\n\r\n  ProxyMethod = (TProxyMethod)Storage->ReadInteger(L\"ProxyMethod\", ProxyMethod);\r\n  ProxyHost = Storage->ReadString(L\"ProxyHost\", ProxyHost);\r\n  ProxyPort = Storage->ReadInteger(L\"ProxyPort\", ProxyPort);\r\n  ProxyUsername = Storage->ReadString(L\"ProxyUsername\", ProxyUsername);\r\n  if (Storage->ValueExists(L\"ProxyPassword\"))\r\n  {\r\n    // encrypt unencrypted password\r\n    ProxyPassword = Storage->ReadString(L\"ProxyPassword\", L\"\");\r\n  }\r\n  else\r\n  {\r\n    // load encrypted password\r\n    RawByteString AProxyPassword = Storage->ReadStringAsBinaryData(L\"ProxyPasswordEnc\", FProxyPassword);\r\n    SET_SESSION_PROPERTY_FROM(ProxyPassword, AProxyPassword);\r\n  }\r\n  if (!Unsafe)\r\n  {\r\n    if (ProxyMethod == pmCmd)\r\n    {\r\n      ProxyLocalCommand = Storage->ReadStringRaw(L\"ProxyTelnetCommand\", ProxyLocalCommand);\r\n    }\r\n    else\r\n    {\r\n      ProxyTelnetCommand = Storage->ReadStringRaw(L\"ProxyTelnetCommand\", ProxyTelnetCommand);\r\n    }\r\n  }\r\n  ProxyDNS = TAutoSwitch((Storage->ReadInteger(L\"ProxyDNS\", (ProxyDNS + 2) % 3) + 1) % 3);\r\n  ProxyLocalhost = Storage->ReadBool(L\"ProxyLocalhost\", ProxyLocalhost);\r\n\r\n  #define READ_BUG(BUG) \\\r\n    Bug[sb##BUG] = TAutoSwitch(2 - Storage->ReadInteger(L\"Bug\"#BUG, \\\r\n      2 - Bug[sb##BUG]));\r\n  READ_BUG(Ignore1);\r\n  READ_BUG(PlainPW1);\r\n  READ_BUG(RSA1);\r\n  READ_BUG(HMAC2);\r\n  READ_BUG(DeriveKey2);\r\n  READ_BUG(RSAPad2);\r\n  READ_BUG(PKSessID2);\r\n  READ_BUG(Rekey2);\r\n  READ_BUG(MaxPkt2);\r\n  READ_BUG(Ignore2);\r\n  READ_BUG(OldGex2);\r\n  READ_BUG(WinAdj);\r\n  READ_BUG(ChanReq);\r\n  #undef READ_BUG\r\n\r\n  if ((Bug[sbHMAC2] == asAuto) &&\r\n      Storage->ReadBool(L\"BuggyMAC\", false))\r\n  {\r\n      Bug[sbHMAC2] = asOn;\r\n  }\r\n\r\n  if (!Unsafe)\r\n  {\r\n    SftpServer = Storage->ReadString(L\"SftpServer\", SftpServer);\r\n  }\r\n  #define READ_SFTP_BUG(BUG) \\\r\n    SFTPBug[sb##BUG] = TAutoSwitch(Storage->ReadInteger(L\"SFTP\" #BUG \"Bug\", SFTPBug[sb##BUG]));\r\n  READ_SFTP_BUG(Symlink);\r\n  READ_SFTP_BUG(SignedTS);\r\n  #undef READ_SFTP_BUG\r\n\r\n  SFTPMaxVersion = Storage->ReadInteger(L\"SFTPMaxVersion\", SFTPMaxVersion);\r\n  SFTPMaxPacketSize = Storage->ReadInteger(L\"SFTPMaxPacketSize\", SFTPMaxPacketSize);\r\n  SFTPDownloadQueue = Storage->ReadInteger(L\"SFTPDownloadQueue\", SFTPDownloadQueue);\r\n  SFTPUploadQueue = Storage->ReadInteger(L\"SFTPUploadQueue\", SFTPUploadQueue);\r\n  SFTPListingQueue = Storage->ReadInteger(L\"SFTPListingQueue\", SFTPListingQueue);\r\n\r\n  Color = Storage->ReadInteger(L\"Color\", Color);\r\n\r\n  PuttyProtocol = Storage->ReadString(L\"Protocol\", PuttyProtocol);\r\n\r\n  Tunnel = Storage->ReadBool(L\"Tunnel\", Tunnel);\r\n  TunnelPortNumber = Storage->ReadInteger(L\"TunnelPortNumber\", TunnelPortNumber);\r\n  TunnelUserName = Storage->ReadString(L\"TunnelUserName\", TunnelUserName);\r\n  // must be loaded after TunnelUserName,\r\n  // because TunnelHostName may be in format user@host\r\n  TunnelHostName = Storage->ReadString(L\"TunnelHostName\", TunnelHostName);\r\n  if (!Configuration->DisablePasswordStoring)\r\n  {\r\n    if (Storage->ValueExists(L\"TunnelPasswordPlain\"))\r\n    {\r\n      TunnelPassword = Storage->ReadString(L\"TunnelPasswordPlain\", TunnelPassword);\r\n      RewritePassword = true;\r\n    }\r\n    else\r\n    {\r\n      RawByteString ATunnelPassword = Storage->ReadStringAsBinaryData(L\"TunnelPassword\", FTunnelPassword);\r\n      SET_SESSION_PROPERTY_FROM(TunnelPassword, ATunnelPassword);\r\n    }\r\n  }\r\n  TunnelPublicKeyFile = Storage->ReadString(L\"TunnelPublicKeyFile\", TunnelPublicKeyFile);\r\n  TunnelLocalPortNumber = Storage->ReadInteger(L\"TunnelLocalPortNumber\", TunnelLocalPortNumber);\r\n  TunnelHostKey = Storage->ReadString(L\"TunnelHostKey\", TunnelHostKey);\r\n\r\n  // Ftp prefix\r\n  FtpPasvMode = Storage->ReadBool(L\"FtpPasvMode\", FtpPasvMode);\r\n  FtpForcePasvIp = TAutoSwitch(Storage->ReadInteger(L\"FtpForcePasvIp2\", FtpForcePasvIp));\r\n  FtpUseMlsd = TAutoSwitch(Storage->ReadInteger(L\"FtpUseMlsd\", FtpUseMlsd));\r\n  FtpAccount = Storage->ReadString(L\"FtpAccount\", FtpAccount);\r\n  FtpPingInterval = Storage->ReadInteger(L\"FtpPingInterval\", FtpPingInterval);\r\n  FtpPingType = static_cast<TPingType>(Storage->ReadInteger(L\"FtpPingType\", FtpPingType));\r\n  FtpTransferActiveImmediately = static_cast<TAutoSwitch>(Storage->ReadInteger(L\"FtpTransferActiveImmediately2\", FtpTransferActiveImmediately));\r\n  Ftps = static_cast<TFtps>(Storage->ReadInteger(L\"Ftps\", Ftps));\r\n  FtpListAll = TAutoSwitch(Storage->ReadInteger(L\"FtpListAll\", FtpListAll));\r\n  FtpHost = TAutoSwitch(Storage->ReadInteger(L\"FtpHost\", FtpHost));\r\n  FtpDeleteFromCwd = TAutoSwitch(Storage->ReadInteger(L\"FtpDeleteFromCwd\", FtpDeleteFromCwd));\r\n  SslSessionReuse = Storage->ReadBool(L\"SslSessionReuse\", SslSessionReuse);\r\n  TlsCertificateFile = Storage->ReadString(L\"TlsCertificateFile\", TlsCertificateFile);\r\n\r\n  FtpProxyLogonType = Storage->ReadInteger(L\"FtpProxyLogonType\", FtpProxyLogonType);\r\n\r\n  MinTlsVersion = static_cast<TTlsVersion>(Storage->ReadInteger(L\"MinTlsVersion\", MinTlsVersion));\r\n  MaxTlsVersion = static_cast<TTlsVersion>(Storage->ReadInteger(L\"MaxTlsVersion\", MaxTlsVersion));\r\n\r\n  if (Storage->ValueExists(L\"EncryptKeyPlain\"))\r\n  {\r\n    EncryptKey = Storage->ReadString(L\"EncryptKeyPlain\", EncryptKey);\r\n    RewritePassword = true;\r\n  }\r\n  else\r\n  {\r\n    RawByteString AEncryptKey = Storage->ReadStringAsBinaryData(L\"EncryptKey\", FEncryptKey);\r\n    SET_SESSION_PROPERTY_FROM(EncryptKey, AEncryptKey);\r\n  }\r\n\r\n  IsWorkspace = Storage->ReadBool(L\"IsWorkspace\", IsWorkspace);\r\n  Link = Storage->ReadString(L\"Link\", Link);\r\n  NameOverride = Storage->ReadString(L\"NameOverride\", NameOverride);\r\n\r\n  PuttySettings = Storage->ReadString(L\"PuttySettings\", PuttySettings);\r\n\r\n  CustomParam1 = Storage->ReadString(L\"CustomParam1\", CustomParam1);\r\n  CustomParam2 = Storage->ReadString(L\"CustomParam2\", CustomParam2);\r\n\r\n#ifdef TEST\r\n  #define KEX_TEST(VALUE, EXPECTED) KexList = VALUE; DebugAssert(KexList == EXPECTED);\r\n  #define KEX_DEFAULT L\"ecdh,dh-gex-sha1,dh-group14-sha1,rsa,WARN,dh-group1-sha1\"\r\n  // Empty source should result in default list\r\n  KEX_TEST(L\"\", KEX_DEFAULT);\r\n  // Default of pre 5.8.1\r\n  KEX_TEST(L\"dh-gex-sha1,dh-group14-sha1,dh-group1-sha1,rsa,WARN\", L\"ecdh,dh-gex-sha1,dh-group14-sha1,dh-group1-sha1,rsa,WARN\");\r\n  // Missing first two priority algos, and last non-priority algo\r\n  KEX_TEST(L\"dh-group14-sha1,dh-group1-sha1,WARN\", L\"ecdh,dh-gex-sha1,dh-group14-sha1,dh-group1-sha1,rsa,WARN\");\r\n  // Missing first two priority algos, last non-priority algo and WARN\r\n  KEX_TEST(L\"dh-group14-sha1,dh-group1-sha1\", L\"ecdh,dh-gex-sha1,dh-group14-sha1,dh-group1-sha1,rsa,WARN\");\r\n  // Old algos, with all but the first below WARN\r\n  KEX_TEST(L\"dh-gex-sha1,WARN,dh-group14-sha1,dh-group1-sha1,rsa\", L\"ecdh,dh-gex-sha1,WARN,dh-group14-sha1,dh-group1-sha1,rsa\");\r\n  // Unknown algo at front\r\n  KEX_TEST(L\"unknown,ecdh,dh-gex-sha1,dh-group14-sha1,rsa,WARN,dh-group1-sha1\", KEX_DEFAULT);\r\n  // Unknown algo at back\r\n  KEX_TEST(L\"ecdh,dh-gex-sha1,dh-group14-sha1,rsa,WARN,dh-group1-sha1,unknown\", KEX_DEFAULT);\r\n  // Unknown algo in the middle\r\n  KEX_TEST(L\"ecdh,dh-gex-sha1,dh-group14-sha1,unknown,rsa,WARN,dh-group1-sha1\", KEX_DEFAULT);\r\n  #undef KEX_DEFAULT\r\n  #undef KEX_TEST\r\n\r\n  #define CIPHER_TEST(VALUE, EXPECTED) CipherList = VALUE; DebugAssert(CipherList == EXPECTED);\r\n  #define CIPHER_DEFAULT L\"aes,chacha20,blowfish,3des,WARN,arcfour,des\"\r\n  // Empty source should result in default list\r\n  CIPHER_TEST(L\"\", CIPHER_DEFAULT);\r\n  // Default of pre 5.8.1\r\n  CIPHER_TEST(L\"aes,blowfish,3des,WARN,arcfour,des\", L\"aes,blowfish,3des,chacha20,WARN,arcfour,des\");\r\n  // Missing priority algo\r\n  CIPHER_TEST(L\"chacha20,blowfish,3des,WARN,arcfour,des\", CIPHER_DEFAULT);\r\n  // Missing non-priority algo\r\n  CIPHER_TEST(L\"aes,chacha20,3des,WARN,arcfour,des\", L\"aes,chacha20,3des,blowfish,WARN,arcfour,des\");\r\n  // Missing last warn algo\r\n  CIPHER_TEST(L\"aes,blowfish,chacha20,3des,WARN,arcfour\", L\"aes,blowfish,chacha20,3des,WARN,arcfour,des\");\r\n  // Missing first warn algo\r\n  CIPHER_TEST(L\"aes,blowfish,chacha20,3des,WARN,des\", L\"aes,blowfish,chacha20,3des,WARN,des,arcfour\");\r\n  #undef CIPHER_DEFAULT\r\n  #undef CIPHER_TEST\r\n\r\n  #define HOSTKEY_TEST(VALUE, EXPECTED) HostKeyList = VALUE; DebugAssert(HostKeyList == EXPECTED);\r\n  #define HOSTKEY_DEFAULT L\"ed25519,ecdsa,rsa,dsa,WARN\"\r\n  // Empty source should result in default list\r\n  HOSTKEY_TEST(L\"\", HOSTKEY_DEFAULT);\r\n  // Missing priority algo\r\n  HOSTKEY_TEST(L\"ecdsa,rsa,dsa,WARN\", HOSTKEY_DEFAULT);\r\n  // Missing non-priority algo\r\n  HOSTKEY_TEST(L\"ed25519,ecdsa,dsa,WARN\", L\"ed25519,ecdsa,dsa,rsa,WARN\");\r\n  #undef HOSTKEY_DEFAULT\r\n  #undef HOSTKEY_TEST\r\n#endif\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::Load(THierarchicalStorage * Storage, bool PuttyImport)\r\n{\r\n  bool RewritePassword = false;\r\n  if (Storage->OpenSubKey(InternalStorageKey, False))\r\n  {\r\n    // In case we are re-loading, reset passwords, to avoid pointless\r\n    // re-cryption, while loading username/hostname. And moreover, when\r\n    // the password is wrongly encrypted (using a different master password),\r\n    // this breaks sites reload and consequently an overal operation,\r\n    // such as opening Sites menu\r\n    ClearSessionPasswords();\r\n    FProxyPassword = L\"\";\r\n\r\n    DoLoad(Storage, PuttyImport, RewritePassword, false);\r\n\r\n    Storage->CloseSubKey();\r\n  }\r\n\r\n  if (RewritePassword)\r\n  {\r\n    TStorageAccessMode AccessMode = Storage->AccessMode;\r\n    Storage->AccessMode = smReadWrite;\r\n\r\n    try\r\n    {\r\n      if (Storage->OpenSubKey(InternalStorageKey, true))\r\n      {\r\n        Storage->DeleteValue(L\"PasswordPlain\");\r\n        if (!Password.IsEmpty())\r\n        {\r\n          Storage->WriteBinaryDataAsString(L\"Password\", FPassword);\r\n        }\r\n        Storage->DeleteValue(L\"TunnelPasswordPlain\");\r\n        if (!TunnelPassword.IsEmpty())\r\n        {\r\n          Storage->WriteBinaryDataAsString(L\"TunnelPassword\", FTunnelPassword);\r\n        }\r\n        Storage->DeleteValue(L\"EncryptKeyPlain\");\r\n        if (!EncryptKey.IsEmpty())\r\n        {\r\n          Storage->WriteBinaryDataAsString(L\"EncryptKey\", FEncryptKey);\r\n        }\r\n        Storage->CloseSubKey();\r\n      }\r\n    }\r\n    catch(...)\r\n    {\r\n      // ignore errors (like read-only INI file)\r\n    }\r\n\r\n    Storage->AccessMode = AccessMode;\r\n  }\r\n\r\n  FModified = false;\r\n  FSource = ssStored;\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::DoSave(THierarchicalStorage * Storage,\r\n  bool PuttyExport, const TSessionData * Default, bool DoNotEncryptPasswords)\r\n{\r\n  // Same as in TCopyParamType::Save\r\n  #define WRITE_DATA_EX(TYPE, NAME, PROPERTY, CONV) \\\r\n    if ((Default != NULL) && (CONV(Default->PROPERTY) == CONV(PROPERTY))) \\\r\n    { \\\r\n      Storage->DeleteValue(NAME); \\\r\n    } \\\r\n    else \\\r\n    { \\\r\n      Storage->Write ## TYPE(NAME, CONV(PROPERTY)); \\\r\n    }\r\n  #define WRITE_DATA_CONV(TYPE, NAME, PROPERTY) WRITE_DATA_EX(TYPE, NAME, PROPERTY, WRITE_DATA_CONV_FUNC)\r\n  #define WRITE_DATA(TYPE, PROPERTY) WRITE_DATA_EX(TYPE, TEXT(#PROPERTY), PROPERTY, )\r\n\r\n  WRITE_DATA(String, HostName);\r\n  WRITE_DATA(Integer, PortNumber);\r\n  WRITE_DATA_EX(Integer, L\"PingInterval\", PingInterval / SecsPerMin, );\r\n  WRITE_DATA_EX(Integer, L\"PingIntervalSecs\", PingInterval % SecsPerMin, );\r\n  Storage->DeleteValue(L\"PingIntervalSec\"); // obsolete\r\n  WRITE_DATA(Integer, PingType);\r\n  WRITE_DATA(Integer, Timeout);\r\n  WRITE_DATA(Bool, TryAgent);\r\n  WRITE_DATA(Bool, AgentFwd);\r\n  WRITE_DATA(Bool, AuthTIS);\r\n  WRITE_DATA(Bool, AuthKI);\r\n  WRITE_DATA(Bool, AuthKIPassword);\r\n  WRITE_DATA(String, Note);\r\n\r\n  WRITE_DATA(Bool, AuthGSSAPI);\r\n  WRITE_DATA(Bool, GSSAPIFwdTGT);\r\n  Storage->DeleteValue(L\"TryGSSKEX\");\r\n  Storage->DeleteValue(L\"UserNameFromEnvironment\");\r\n  Storage->DeleteValue(\"GSSAPIServerChoosesUserName\");\r\n  Storage->DeleteValue(L\"GSSAPITrustDNS\");\r\n  WRITE_DATA(String, LogicalHostName);\r\n  if (PuttyExport)\r\n  {\r\n    // duplicate kerberos setting with keys of the vintela quest putty\r\n    WRITE_DATA_EX(Bool, L\"AuthSSPI\", AuthGSSAPI, );\r\n    WRITE_DATA_EX(Bool, L\"SSPIFwdTGT\", GSSAPIFwdTGT, );\r\n    WRITE_DATA_EX(String, L\"KerbPrincipal\", LogicalHostName, );\r\n    // duplicate kerberos setting with keys of the official putty\r\n    WRITE_DATA_EX(Bool, L\"GssapiFwd\", GSSAPIFwdTGT, );\r\n  }\r\n\r\n  WRITE_DATA(Bool, ChangeUsername);\r\n  WRITE_DATA(Bool, Compression);\r\n  WRITE_DATA(Integer, SshProt);\r\n  WRITE_DATA(Bool, Ssh2DES);\r\n  WRITE_DATA(Bool, SshNoUserAuth);\r\n  WRITE_DATA_EX(String, L\"Cipher\", CipherList, );\r\n  WRITE_DATA_EX(String, L\"KEX\", KexList, );\r\n  WRITE_DATA_EX(String, L\"HostKey\", HostKeyList, );\r\n  WRITE_DATA_EX(String, L\"GSSLibs\", GssLibList, );\r\n  WRITE_DATA_EX(String, L\"GSSCustom\", GssLibCustom, );\r\n  WRITE_DATA(Integer, AddressFamily);\r\n  WRITE_DATA_EX(String, L\"RekeyBytes\", RekeyData, );\r\n  WRITE_DATA(Integer, RekeyTime);\r\n\r\n  WRITE_DATA(Bool, TcpNoDelay);\r\n\r\n  if (PuttyExport)\r\n  {\r\n    WRITE_DATA(StringRaw, UserName);\r\n    // PuTTY is started in its binary directory to allow relative paths when opening PuTTY's own stored session.\r\n    // To allow relative paths in our sessions, we have to expand them for PuTTY.\r\n    WRITE_DATA_EX(StringRaw, L\"PublicKeyFile\", PublicKeyFile, ExpandFileName);\r\n  }\r\n  else\r\n  {\r\n    WRITE_DATA(String, UserName);\r\n    WRITE_DATA(String, PublicKeyFile);\r\n    WRITE_DATA(Integer, FSProtocol);\r\n    WRITE_DATA(String, LocalDirectory);\r\n    WRITE_DATA(String, RemoteDirectory);\r\n    WRITE_DATA(Bool, SynchronizeBrowsing);\r\n    WRITE_DATA(Bool, UpdateDirectories);\r\n    WRITE_DATA(Bool, CacheDirectories);\r\n    WRITE_DATA(Bool, CacheDirectoryChanges);\r\n    WRITE_DATA(Bool, PreserveDirectoryChanges);\r\n\r\n    WRITE_DATA(Bool, ResolveSymlinks);\r\n    WRITE_DATA(Bool, FollowDirectorySymlinks);\r\n    WRITE_DATA_EX(Integer, L\"ConsiderDST\", DSTMode, );\r\n    WRITE_DATA(Bool, LockInHome);\r\n    // Special is never stored (if it would, login dialog must be modified not to\r\n    // duplicate Special parameter when Special session is loaded and then stored\r\n    // under different name)\r\n    // WRITE_DATA(Bool, Special);\r\n    WRITE_DATA(String, Shell);\r\n    WRITE_DATA(Bool, ClearAliases);\r\n    WRITE_DATA(Bool, UnsetNationalVars);\r\n    WRITE_DATA(String, ListingCommand);\r\n    WRITE_DATA(Bool, IgnoreLsWarnings);\r\n    WRITE_DATA(Integer, SCPLsFullTime);\r\n    WRITE_DATA(Bool, Scp1Compatibility);\r\n    // TimeDifferenceAuto is valid for FTP protocol only.\r\n    // For other protocols it's typically true (default value),\r\n    // but ignored so TimeDifference is still taken into account (SCP only actually)\r\n    if (TimeDifferenceAuto && (FSProtocol == fsFTP))\r\n    {\r\n      // Have to delete it as TimeDifferenceAuto is not saved when enabled,\r\n      // but the default is derived from value of TimeDifference.\r\n      Storage->DeleteValue(L\"TimeDifference\");\r\n    }\r\n    else\r\n    {\r\n      WRITE_DATA(Float, TimeDifference);\r\n    }\r\n    WRITE_DATA(Bool, TimeDifferenceAuto);\r\n    WRITE_DATA(Bool, DeleteToRecycleBin);\r\n    WRITE_DATA(Bool, OverwrittenToRecycleBin);\r\n    WRITE_DATA(String, RecycleBinPath);\r\n    WRITE_DATA(String, PostLoginCommands);\r\n\r\n    WRITE_DATA(String, ReturnVar);\r\n    WRITE_DATA(Bool, ExitCode1IsError);\r\n    WRITE_DATA_EX(Integer, L\"LookupUserGroups2\", LookupUserGroups, );\r\n    WRITE_DATA(Integer, EOLType);\r\n    WRITE_DATA(Bool, TrimVMSVersions);\r\n    Storage->DeleteValue(L\"SFTPUtfBug\");\r\n    WRITE_DATA_EX(Integer, L\"Utf\", NotUtf, );\r\n    WRITE_DATA(Integer, InternalEditorEncoding);\r\n    WRITE_DATA(String, S3DefaultRegion);\r\n    WRITE_DATA(Integer, S3UrlStyle);\r\n    WRITE_DATA(Integer, SendBuf);\r\n    WRITE_DATA(String, SourceAddress);\r\n    WRITE_DATA(Bool, SshSimple);\r\n  }\r\n\r\n  WRITE_DATA(Integer, ProxyMethod);\r\n  WRITE_DATA(String, ProxyHost);\r\n  WRITE_DATA(Integer, ProxyPort);\r\n  WRITE_DATA(String, ProxyUsername);\r\n  if (ProxyMethod == pmCmd)\r\n  {\r\n    WRITE_DATA_EX(StringRaw, L\"ProxyTelnetCommand\", ProxyLocalCommand, );\r\n  }\r\n  else\r\n  {\r\n    WRITE_DATA(StringRaw, ProxyTelnetCommand);\r\n  }\r\n  #define WRITE_DATA_CONV_FUNC(X) (((X) + 2) % 3)\r\n  WRITE_DATA_CONV(Integer, L\"ProxyDNS\", ProxyDNS);\r\n  #undef WRITE_DATA_CONV_FUNC\r\n  WRITE_DATA(Bool, ProxyLocalhost);\r\n\r\n  #define WRITE_DATA_CONV_FUNC(X) (2 - (X))\r\n  #define WRITE_BUG(BUG) WRITE_DATA_CONV(Integer, L\"Bug\" #BUG, Bug[sb##BUG]);\r\n  WRITE_BUG(Ignore1);\r\n  WRITE_BUG(PlainPW1);\r\n  WRITE_BUG(RSA1);\r\n  WRITE_BUG(HMAC2);\r\n  WRITE_BUG(DeriveKey2);\r\n  WRITE_BUG(RSAPad2);\r\n  WRITE_BUG(PKSessID2);\r\n  WRITE_BUG(Rekey2);\r\n  WRITE_BUG(MaxPkt2);\r\n  WRITE_BUG(Ignore2);\r\n  WRITE_BUG(OldGex2);\r\n  WRITE_BUG(WinAdj);\r\n  WRITE_BUG(ChanReq);\r\n  #undef WRITE_BUG\r\n  #undef WRITE_DATA_CONV_FUNC\r\n\r\n  Storage->DeleteValue(L\"BuggyMAC\");\r\n  Storage->DeleteValue(L\"AliasGroupList\");\r\n\r\n  if (PuttyExport)\r\n  {\r\n    WRITE_DATA_EX(String, L\"Protocol\", GetNormalizedPuttyProtocol(), );\r\n    WRITE_DATA(String, WinTitle);\r\n  }\r\n\r\n  if (!PuttyExport)\r\n  {\r\n    WRITE_DATA(String, SftpServer);\r\n\r\n    #define WRITE_SFTP_BUG(BUG) WRITE_DATA_EX(Integer, L\"SFTP\" #BUG \"Bug\", SFTPBug[sb##BUG], );\r\n    WRITE_SFTP_BUG(Symlink);\r\n    WRITE_SFTP_BUG(SignedTS);\r\n    #undef WRITE_SFTP_BUG\r\n\r\n    WRITE_DATA(Integer, SFTPMaxVersion);\r\n    WRITE_DATA(Integer, SFTPMaxPacketSize);\r\n    WRITE_DATA(Integer, SFTPDownloadQueue);\r\n    WRITE_DATA(Integer, SFTPUploadQueue);\r\n    WRITE_DATA(Integer, SFTPListingQueue);\r\n\r\n    WRITE_DATA(Integer, Color);\r\n\r\n    WRITE_DATA(Bool, Tunnel);\r\n    WRITE_DATA(String, TunnelHostName);\r\n    WRITE_DATA(Integer, TunnelPortNumber);\r\n    WRITE_DATA(String, TunnelUserName);\r\n    WRITE_DATA(String, TunnelPublicKeyFile);\r\n    WRITE_DATA(Integer, TunnelLocalPortNumber);\r\n\r\n    WRITE_DATA(Bool, FtpPasvMode);\r\n    WRITE_DATA_EX(Integer, L\"FtpForcePasvIp2\", FtpForcePasvIp, );\r\n    WRITE_DATA(Integer, FtpUseMlsd);\r\n    WRITE_DATA(String, FtpAccount);\r\n    WRITE_DATA(Integer, FtpPingInterval);\r\n    WRITE_DATA(Integer, FtpPingType);\r\n    WRITE_DATA_EX(Integer, L\"FtpTransferActiveImmediately2\", FtpTransferActiveImmediately, );\r\n    WRITE_DATA(Integer, Ftps);\r\n    WRITE_DATA(Integer, FtpListAll);\r\n    WRITE_DATA(Integer, FtpHost);\r\n    WRITE_DATA(Integer, FtpDeleteFromCwd);\r\n    WRITE_DATA(Bool, SslSessionReuse);\r\n    WRITE_DATA(String, TlsCertificateFile);\r\n\r\n    WRITE_DATA(Integer, FtpProxyLogonType);\r\n\r\n    WRITE_DATA(Integer, MinTlsVersion);\r\n    WRITE_DATA(Integer, MaxTlsVersion);\r\n\r\n    WRITE_DATA(Bool, IsWorkspace);\r\n    WRITE_DATA(String, Link);\r\n    WRITE_DATA(String, NameOverride);\r\n\r\n    WRITE_DATA(String, PuttySettings);\r\n\r\n    WRITE_DATA(String, CustomParam1);\r\n    WRITE_DATA(String, CustomParam2);\r\n  }\r\n\r\n  // This is for collecting all keys for TSiteRawDialog::AddButtonClick.\r\n  // It should be enough to test for (Default == NULL),\r\n  // the DoNotEncryptPasswords and PuttyExport were added to limit a possible unintended impact.\r\n  bool SaveAll = (Default == NULL) && DoNotEncryptPasswords && !PuttyExport;\r\n\r\n  SavePasswords(Storage, PuttyExport, DoNotEncryptPasswords, SaveAll);\r\n\r\n  if (PuttyExport)\r\n  {\r\n    WritePuttySettings(Storage, PuttySettings);\r\n  }\r\n}\r\n//---------------------------------------------------------------------\r\nTStrings * __fastcall TSessionData::SaveToOptions(const TSessionData * Default, bool SaveName, bool PuttyExport)\r\n{\r\n  std::unique_ptr<TStringList> Options(new TStringList());\r\n  std::unique_ptr<TOptionsStorage> OptionsStorage(new TOptionsStorage(Options.get(), true));\r\n  if (SaveName)\r\n  {\r\n    OptionsStorage->WriteString(L\"Name\", Name);\r\n  }\r\n  DoSave(OptionsStorage.get(), PuttyExport, Default, true);\r\n  return Options.release();\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::Save(THierarchicalStorage * Storage,\r\n  bool PuttyExport, const TSessionData * Default)\r\n{\r\n  if (Storage->OpenSubKey(InternalStorageKey, true))\r\n  {\r\n    DoSave(Storage, PuttyExport, Default, false);\r\n\r\n    Storage->CloseSubKey();\r\n  }\r\n}\r\n//---------------------------------------------------------------------\r\nUnicodeString __fastcall TSessionData::ReadXmlNode(_di_IXMLNode Node, const UnicodeString & Name, const UnicodeString & Default)\r\n{\r\n  _di_IXMLNode TheNode = Node->ChildNodes->FindNode(Name);\r\n  UnicodeString Result;\r\n  if (TheNode != NULL)\r\n  {\r\n    Result = TheNode->Text.Trim();\r\n  }\r\n\r\n  if (Result.IsEmpty())\r\n  {\r\n    Result = Default;\r\n  }\r\n\r\n  return Result;\r\n}\r\n//---------------------------------------------------------------------\r\nint __fastcall TSessionData::ReadXmlNode(_di_IXMLNode Node, const UnicodeString & Name, int Default)\r\n{\r\n  _di_IXMLNode TheNode = Node->ChildNodes->FindNode(Name);\r\n  int Result;\r\n  if (TheNode != NULL)\r\n  {\r\n    Result = StrToIntDef(TheNode->Text.Trim(), Default);\r\n  }\r\n  else\r\n  {\r\n    Result = Default;\r\n  }\r\n\r\n  return Result;\r\n}\r\n//---------------------------------------------------------------------\r\n_di_IXMLNode __fastcall TSessionData::FindSettingsNode(_di_IXMLNode Node, const UnicodeString & Name)\r\n{\r\n  for (int Index = 0; Index < Node->ChildNodes->Count; Index++)\r\n  {\r\n    _di_IXMLNode ChildNode = Node->ChildNodes->Get(Index);\r\n    if (ChildNode->NodeName == L\"Setting\")\r\n    {\r\n       OleVariant SettingName = ChildNode->GetAttribute(L\"name\");\r\n       if (SettingName == Name)\r\n       {\r\n         return ChildNode;\r\n       }\r\n    }\r\n  }\r\n\r\n  return NULL;\r\n}\r\n//---------------------------------------------------------------------\r\nUnicodeString __fastcall TSessionData::ReadSettingsNode(_di_IXMLNode Node, const UnicodeString & Name, const UnicodeString & Default)\r\n{\r\n  _di_IXMLNode TheNode = FindSettingsNode(Node, Name);\r\n  UnicodeString Result;\r\n  if (TheNode != NULL)\r\n  {\r\n    Result = TheNode->Text.Trim();\r\n  }\r\n\r\n  if (Result.IsEmpty())\r\n  {\r\n    Result = Default;\r\n  }\r\n\r\n  return Result;\r\n}\r\n//---------------------------------------------------------------------\r\nint __fastcall TSessionData::ReadSettingsNode(_di_IXMLNode Node, const UnicodeString & Name, int Default)\r\n{\r\n  _di_IXMLNode TheNode = FindSettingsNode(Node, Name);\r\n  int Result;\r\n  if (TheNode != NULL)\r\n  {\r\n    Result = StrToIntDef(TheNode->Text.Trim(), Default);\r\n  }\r\n  else\r\n  {\r\n    Result = Default;\r\n  }\r\n\r\n  return Result;\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::ImportFromFilezilla(\r\n  _di_IXMLNode Node, const UnicodeString & Path, _di_IXMLNode SettingsNode)\r\n{\r\n  Name = UnixIncludeTrailingBackslash(Path) + MakeValidName(ReadXmlNode(Node, L\"Name\", Name));\r\n  HostName = ReadXmlNode(Node, L\"Host\", HostName);\r\n  PortNumber = ReadXmlNode(Node, L\"Port\", PortNumber);\r\n\r\n  int AProtocol = ReadXmlNode(Node, L\"Protocol\", 0);\r\n  // ServerProtocol enum\r\n  switch (AProtocol)\r\n  {\r\n    case 0: // FTP\r\n    default: // UNKNOWN, HTTP, HTTPS, INSECURE_FTP\r\n      FSProtocol = fsFTP;\r\n      break;\r\n\r\n    case 1: // SFTP\r\n      FSProtocol = fsSFTP;\r\n      break;\r\n\r\n    case 3: // FTPS\r\n      FSProtocol = fsFTP;\r\n      Ftps = ftpsImplicit;\r\n      break;\r\n\r\n    case 4: // FTPES\r\n      FSProtocol = fsFTP;\r\n      Ftps = ftpsExplicitTls;\r\n      break;\r\n  }\r\n\r\n  // LogonType enum\r\n  int LogonType = ReadXmlNode(Node, L\"Logontype\", 0);\r\n  if (LogonType == 0) // ANONYMOUS\r\n  {\r\n    UserName = AnonymousUserName;\r\n    Password = AnonymousPassword;\r\n  }\r\n  else\r\n  {\r\n    UserName = ReadXmlNode(Node, L\"User\", UserName);\r\n    FtpAccount = ReadXmlNode(Node, L\"Account\", FtpAccount);\r\n\r\n    _di_IXMLNode PassNode = Node->ChildNodes->FindNode(L\"Pass\");\r\n    if (PassNode != NULL)\r\n    {\r\n      UnicodeString APassword = PassNode->Text.Trim();\r\n      OleVariant EncodingValue = PassNode->GetAttribute(L\"encoding\");\r\n      if (!EncodingValue.IsNull())\r\n      {\r\n        UnicodeString EncodingValueStr = EncodingValue;\r\n        if (SameText(EncodingValueStr, L\"base64\"))\r\n        {\r\n          TBytes Bytes = DecodeBase64(APassword);\r\n          APassword = TEncoding::UTF8->GetString(Bytes);\r\n        }\r\n      }\r\n      Password = APassword;\r\n    }\r\n  }\r\n\r\n  PublicKeyFile = ReadXmlNode(Node, L\"Keyfile\", PublicKeyFile);\r\n\r\n  int DefaultTimeDifference = TimeToSeconds(TimeDifference);\r\n  TimeDifference =\r\n    (double(ReadXmlNode(Node, L\"TimezoneOffset\", DefaultTimeDifference) / SecsPerDay));\r\n  TimeDifferenceAuto = (TimeDifference == TDateTime());\r\n\r\n  UnicodeString PasvMode = ReadXmlNode(Node, L\"PasvMode\", L\"\");\r\n  if (SameText(PasvMode, L\"MODE_PASSIVE\"))\r\n  {\r\n    FtpPasvMode = true;\r\n  }\r\n  else if (SameText(PasvMode, L\"MODE_ACTIVE\"))\r\n  {\r\n    FtpPasvMode = false;\r\n  }\r\n\r\n  UnicodeString EncodingType = ReadXmlNode(Node, L\"EncodingType\", L\"\");\r\n  if (SameText(EncodingType, L\"Auto\"))\r\n  {\r\n    NotUtf = asAuto;\r\n  }\r\n  else if (SameText(EncodingType, L\"UTF-8\"))\r\n  {\r\n    NotUtf = asOff;\r\n  }\r\n\r\n  // todo PostLoginCommands\r\n\r\n  Note = ReadXmlNode(Node, L\"Comments\", Note);\r\n\r\n  LocalDirectory = ReadXmlNode(Node, L\"LocalDir\", LocalDirectory);\r\n\r\n  UnicodeString RemoteDir = ReadXmlNode(Node, L\"RemoteDir\", L\"\");\r\n  if (!RemoteDir.IsEmpty())\r\n  {\r\n    CutToChar(RemoteDir, L' ', false); // type\r\n    int PrefixSize = StrToIntDef(CutToChar(RemoteDir, L' ', false), 0); // prefix size\r\n    if (PrefixSize > 0)\r\n    {\r\n      RemoteDir.Delete(1, PrefixSize);\r\n    }\r\n    RemoteDirectory = L\"/\";\r\n    while (!RemoteDir.IsEmpty())\r\n    {\r\n      int SegmentSize = StrToIntDef(CutToChar(RemoteDir, L' ', false), 0);\r\n      UnicodeString Segment = RemoteDir.SubString(1, SegmentSize);\r\n      RemoteDirectory = UnixIncludeTrailingBackslash(RemoteDirectory) + Segment;\r\n      RemoteDir.Delete(1, SegmentSize + 1);\r\n    }\r\n  }\r\n\r\n  SynchronizeBrowsing = (ReadXmlNode(Node, L\"SyncBrowsing\", SynchronizeBrowsing ? 1 : 0) != 0);\r\n\r\n  if (SettingsNode != NULL)\r\n  {\r\n    if (UsesSsh && PublicKeyFile.IsEmpty())\r\n    {\r\n      UnicodeString KeyFiles = ReadSettingsNode(SettingsNode, L\"SFTP keyfiles\", UnicodeString());\r\n      UnicodeString KeyFile = CutToChar(KeyFiles, L'\\n', true).Trim();\r\n      KeyFiles = KeyFiles.Trim();\r\n      // If there are more keys, ignore them, as we do not know which one to use\r\n      if (!KeyFile.IsEmpty() && KeyFiles.IsEmpty())\r\n      {\r\n        PublicKeyFile = KeyFile;\r\n      }\r\n    }\r\n\r\n    bool BypassProxy = (ReadXmlNode(Node, L\"BypassProxy\", 0) != 0);\r\n    if (!BypassProxy)\r\n    {\r\n      int FtpProxyType = ReadSettingsNode(SettingsNode, L\"FTP Proxy type\", -1);\r\n      if (FtpProxyType > 0)\r\n      {\r\n        switch (FtpProxyType)\r\n        {\r\n          case 1:\r\n            FtpProxyLogonType = 2;\r\n            break;\r\n          case 2:\r\n            FtpProxyLogonType = 1;\r\n            break;\r\n          case 3:\r\n            FtpProxyLogonType = 3;\r\n            break;\r\n          case 4:\r\n            // custom\r\n            // TODO: map known sequences to our enumeration\r\n            FtpProxyLogonType = 0;\r\n            break;\r\n          default:\r\n            DebugFail();\r\n            FtpProxyLogonType = 0;\r\n            break;\r\n        }\r\n\r\n        ProxyHost = ReadSettingsNode(SettingsNode, L\"FTP Proxy host\", ProxyHost);\r\n        ProxyUsername = ReadSettingsNode(SettingsNode, L\"FTP Proxy user\", ProxyUsername);\r\n        ProxyPassword = ReadSettingsNode(SettingsNode, L\"FTP Proxy password\", ProxyPassword);\r\n        // ProxyPort is not used with FtpProxyLogonType\r\n      }\r\n      else\r\n      {\r\n        int ProxyType = ReadSettingsNode(SettingsNode, L\"Proxy type\", -1);\r\n        if (ProxyType >= 0)\r\n        {\r\n          switch (ProxyType)\r\n          {\r\n            case 0:\r\n              ProxyMethod = ::pmNone;\r\n              break;\r\n\r\n            case 1:\r\n              ProxyMethod = pmHTTP;\r\n              break;\r\n\r\n            case 2:\r\n              ProxyMethod = pmSocks5;\r\n              break;\r\n\r\n            case 3:\r\n              ProxyMethod = pmSocks4;\r\n              break;\r\n\r\n            default:\r\n              DebugFail();\r\n              ProxyMethod = ::pmNone;\r\n              break;\r\n          }\r\n\r\n          ProxyHost = ReadSettingsNode(SettingsNode, L\"Proxy host\", ProxyHost);\r\n          ProxyPort = ReadSettingsNode(SettingsNode, L\"Proxy port\", ProxyPort);\r\n          ProxyUsername = ReadSettingsNode(SettingsNode, L\"Proxy user\", ProxyUsername);\r\n          ProxyPassword = ReadSettingsNode(SettingsNode, L\"Proxy password\", ProxyPassword);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SavePasswords(THierarchicalStorage * Storage, bool PuttyExport, bool DoNotEncryptPasswords, bool SaveAll)\r\n{\r\n  if (!Configuration->DisablePasswordStoring && !PuttyExport && (!FPassword.IsEmpty() || SaveAll))\r\n  {\r\n    if (DoNotEncryptPasswords)\r\n    {\r\n      Storage->WriteString(L\"PasswordPlain\", Password);\r\n      Storage->DeleteValue(L\"Password\");\r\n    }\r\n    else\r\n    {\r\n      Storage->WriteBinaryDataAsString(L\"Password\", StronglyRecryptPassword(FPassword, UserName+HostName));\r\n      Storage->DeleteValue(L\"PasswordPlain\");\r\n    }\r\n  }\r\n  else\r\n  {\r\n    Storage->DeleteValue(L\"Password\");\r\n    Storage->DeleteValue(L\"PasswordPlain\");\r\n  }\r\n\r\n  if (PuttyExport)\r\n  {\r\n    // save password unencrypted\r\n    Storage->WriteString(L\"ProxyPassword\", ProxyPassword);\r\n  }\r\n  else\r\n  {\r\n    if (DoNotEncryptPasswords)\r\n    {\r\n      if (!FProxyPassword.IsEmpty() || SaveAll)\r\n      {\r\n        Storage->WriteString(L\"ProxyPassword\", ProxyPassword);\r\n      }\r\n      else\r\n      {\r\n        Storage->DeleteValue(L\"ProxyPassword\");\r\n      }\r\n      Storage->DeleteValue(L\"ProxyPasswordEnc\");\r\n    }\r\n    else\r\n    {\r\n      // save password encrypted\r\n      if (!FProxyPassword.IsEmpty() || SaveAll)\r\n      {\r\n        Storage->WriteBinaryDataAsString(L\"ProxyPasswordEnc\", StronglyRecryptPassword(FProxyPassword, ProxyUsername+ProxyHost));\r\n      }\r\n      else\r\n      {\r\n        Storage->DeleteValue(L\"ProxyPasswordEnc\");\r\n      }\r\n      Storage->DeleteValue(L\"ProxyPassword\");\r\n    }\r\n\r\n    if (DoNotEncryptPasswords)\r\n    {\r\n      if (!FTunnelPassword.IsEmpty() || SaveAll)\r\n      {\r\n        Storage->WriteString(L\"TunnelPasswordPlain\", TunnelPassword);\r\n      }\r\n      else\r\n      {\r\n        Storage->DeleteValue(L\"TunnelPasswordPlain\");\r\n      }\r\n    }\r\n    else\r\n    {\r\n      if (!Configuration->DisablePasswordStoring && (!FTunnelPassword.IsEmpty() || SaveAll))\r\n      {\r\n        Storage->WriteBinaryDataAsString(L\"TunnelPassword\", StronglyRecryptPassword(FTunnelPassword, TunnelUserName+TunnelHostName));\r\n      }\r\n      else\r\n      {\r\n        Storage->DeleteValue(L\"TunnelPassword\");\r\n      }\r\n    }\r\n\r\n    if (DoNotEncryptPasswords)\r\n    {\r\n      if (!FEncryptKey.IsEmpty() || SaveAll)\r\n      {\r\n        Storage->WriteString(L\"EncryptKeyPlain\", EncryptKey);\r\n      }\r\n      else\r\n      {\r\n        Storage->DeleteValue(L\"EncryptKeyPlain\");\r\n      }\r\n      Storage->DeleteValue(L\"EncryptKey\");\r\n    }\r\n    else\r\n    {\r\n      if (!FEncryptKey.IsEmpty() || SaveAll)\r\n      {\r\n        Storage->WriteBinaryDataAsString(L\"EncryptKey\", StronglyRecryptPassword(FEncryptKey, UserName+HostName));\r\n      }\r\n      else\r\n      {\r\n        Storage->DeleteValue(L\"EncryptKey\");\r\n      }\r\n      Storage->DeleteValue(L\"EncryptKeyPlain\");\r\n    }\r\n  }\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::RecryptPasswords()\r\n{\r\n  Password = Password;\r\n  NewPassword = NewPassword;\r\n  ProxyPassword = ProxyPassword;\r\n  TunnelPassword = TunnelPassword;\r\n  Passphrase = Passphrase;\r\n  EncryptKey = EncryptKey;\r\n}\r\n//---------------------------------------------------------------------\r\nbool __fastcall TSessionData::HasPassword()\r\n{\r\n  return !FPassword.IsEmpty();\r\n}\r\n//---------------------------------------------------------------------\r\nbool __fastcall TSessionData::HasAnySessionPassword()\r\n{\r\n  // Keep in sync with ClearSessionPasswords\r\n  return\r\n    HasPassword() ||\r\n    !FTunnelPassword.IsEmpty()  ||\r\n    // will probably be never used\r\n    !FNewPassword.IsEmpty();\r\n}\r\n//---------------------------------------------------------------------\r\nbool __fastcall TSessionData::HasAnyPassword()\r\n{\r\n  // Keep in sync with MaskPasswords\r\n  return\r\n    HasAnySessionPassword() ||\r\n    !FProxyPassword.IsEmpty() ||\r\n    !FEncryptKey.IsEmpty() ||\r\n    !FPassphrase.IsEmpty();\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::ClearSessionPasswords()\r\n{\r\n  // Keep in sync with HasAnySessionPassword\r\n  FPassword = L\"\";\r\n  FNewPassword = L\"\";\r\n  FTunnelPassword = L\"\";\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::Modify()\r\n{\r\n  FModified = true;\r\n  if (FSource == ssStored)\r\n  {\r\n    FSource = ssStoredModified;\r\n  }\r\n}\r\n//---------------------------------------------------------------------\r\nUnicodeString __fastcall TSessionData::GetSource()\r\n{\r\n  switch (FSource)\r\n  {\r\n    case ::ssNone:\r\n      return L\"Ad-Hoc site\";\r\n\r\n    case ssStored:\r\n      return L\"Site\";\r\n\r\n    case ssStoredModified:\r\n      return L\"Modified site\";\r\n\r\n    default:\r\n      DebugFail();\r\n      return L\"\";\r\n  }\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SaveRecryptedPasswords(THierarchicalStorage * Storage)\r\n{\r\n  if (Storage->OpenSubKey(InternalStorageKey, true))\r\n  {\r\n    try\r\n    {\r\n      RecryptPasswords();\r\n\r\n      SavePasswords(Storage, false, false, false);\r\n    }\r\n    __finally\r\n    {\r\n      Storage->CloseSubKey();\r\n    }\r\n  }\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::Remove(THierarchicalStorage * Storage, const UnicodeString & Name)\r\n{\r\n  Storage->RecursiveDeleteSubKey(Name);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::Remove()\r\n{\r\n  bool SessionList = true;\r\n  THierarchicalStorage * Storage = Configuration->CreateScpStorage(SessionList);\r\n  try\r\n  {\r\n    Storage->Explicit = true;\r\n    if (Storage->OpenSubKey(Configuration->StoredSessionsSubKey, false))\r\n    {\r\n      Remove(Storage, InternalStorageKey);\r\n    }\r\n  }\r\n  __finally\r\n  {\r\n    delete Storage;\r\n  }\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::CacheHostKeyIfNotCached()\r\n{\r\n  UnicodeString KeyType = KeyTypeFromFingerprint(HostKey);\r\n\r\n  // Should allow importing to INI file as ImportHostKeys\r\n  UnicodeString TargetKey = Configuration->RegistryStorageKey + L\"\\\\\" + Configuration->SshHostKeysSubKey;\r\n  std::unique_ptr<TRegistryStorage> Storage(new TRegistryStorage(TargetKey));\r\n  Storage->AccessMode = smReadWrite;\r\n  if (Storage->OpenRootKey(true))\r\n  {\r\n    UnicodeString HostKeyName = PuttyMungeStr(FORMAT(L\"%s@%d:%s\", (KeyType, PortNumber, HostName)));\r\n    if (!Storage->ValueExists(HostKeyName))\r\n    {\r\n      // fingerprint is a checksum of a host key, so it cannot be translated back to host key,\r\n      // so we store fingerprint and TSecureShell::VerifyHostKey was\r\n      // modified to accept also fingerprint\r\n      Storage->WriteString(HostKeyName, HostKey);\r\n    }\r\n  }\r\n}\r\n//---------------------------------------------------------------------\r\ninline void __fastcall MoveStr(UnicodeString & Source, UnicodeString * Dest, int Count)\r\n{\r\n  if (Dest != NULL)\r\n  {\r\n    (*Dest) += Source.SubString(1, Count);\r\n  }\r\n\r\n  Source.Delete(1, Count);\r\n}\r\n//---------------------------------------------------------------------\r\nbool __fastcall TSessionData::DoIsProtocolUrl(\r\n  const UnicodeString & Url, const UnicodeString & Protocol, int & ProtocolLen)\r\n{\r\n  bool Result = SameText(Url.SubString(1, Protocol.Length() + 1), Protocol + L\":\");\r\n  if (Result)\r\n  {\r\n    ProtocolLen = Protocol.Length() + 1;\r\n  }\r\n  return Result;\r\n}\r\n//---------------------------------------------------------------------\r\nbool __fastcall TSessionData::IsProtocolUrl(\r\n  const UnicodeString & Url, const UnicodeString & Protocol, int & ProtocolLen)\r\n{\r\n  return\r\n    DoIsProtocolUrl(Url, Protocol, ProtocolLen) ||\r\n    DoIsProtocolUrl(Url, WinSCPProtocolPrefix + Protocol, ProtocolLen);\r\n}\r\n//---------------------------------------------------------------------\r\nbool __fastcall TSessionData::IsSensitiveOption(const UnicodeString & Option)\r\n{\r\n  return\r\n    SameText(Option, PassphraseOption) ||\r\n    SameText(Option, NEWPASSWORD_SWITCH);\r\n}\r\n//---------------------------------------------------------------------\r\nbool __fastcall TSessionData::IsOptionWithParameters(const UnicodeString & Option)\r\n{\r\n  return SameText(Option, RawSettingsOption);\r\n}\r\n//---------------------------------------------------------------------\r\nbool __fastcall TSessionData::MaskPasswordInOptionParameter(const UnicodeString & Option, UnicodeString & Param)\r\n{\r\n  bool Result = false;\r\n  if (SameText(Option, RawSettingsOption))\r\n  {\r\n    int P = Param.Pos(L\"=\");\r\n    if (P > 0)\r\n    {\r\n      // TStrings.IndexOfName does not trim\r\n      UnicodeString Key = Param.SubString(1, P - 1);\r\n\r\n      if (SameText(Key, L\"ProxyPassword\") ||\r\n          SameText(Key, L\"ProxyPasswordEnc\") ||\r\n          SameText(Key, L\"TunnelPassword\") ||\r\n          SameText(Key, L\"TunnelPasswordPlain\") ||\r\n          SameText(Key, L\"EncryptKey\"))\r\n      {\r\n        Param = Key + L\"=\" + PasswordMask;\r\n        Result = true;\r\n      }\r\n    }\r\n  }\r\n  return Result;\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::MaskPasswords()\r\n{\r\n  // Keep in sync with HasAnyPassword\r\n  if (!Password.IsEmpty())\r\n  {\r\n    Password = PasswordMask;\r\n  }\r\n  if (!NewPassword.IsEmpty())\r\n  {\r\n    NewPassword = PasswordMask;\r\n  }\r\n  if (!ProxyPassword.IsEmpty())\r\n  {\r\n    ProxyPassword = PasswordMask;\r\n  }\r\n  if (!TunnelPassword.IsEmpty())\r\n  {\r\n    TunnelPassword = PasswordMask;\r\n  }\r\n  if (!EncryptKey.IsEmpty())\r\n  {\r\n    EncryptKey = PasswordMask;\r\n  }\r\n  if (!Passphrase.IsEmpty())\r\n  {\r\n    Passphrase = PasswordMask;\r\n  }\r\n}\r\n//---------------------------------------------------------------------\r\nbool __fastcall TSessionData::ParseUrl(UnicodeString Url, TOptions * Options,\r\n  TStoredSessionList * StoredSessions, bool & DefaultsOnly, UnicodeString * FileName,\r\n  bool * AProtocolDefined, UnicodeString * MaskedUrl, int Flags)\r\n{\r\n  bool ProtocolDefined = false;\r\n  bool PortNumberDefined = false;\r\n  TFSProtocol AFSProtocol;\r\n  int APortNumber;\r\n  TFtps AFtps = ftpsNone;\r\n  int ProtocolLen = 0;\r\n  if (IsProtocolUrl(Url, ScpProtocol, ProtocolLen))\r\n  {\r\n    AFSProtocol = fsSCPonly;\r\n    APortNumber = SshPortNumber;\r\n    MoveStr(Url, MaskedUrl, ProtocolLen);\r\n    ProtocolDefined = true;\r\n  }\r\n  else if (IsProtocolUrl(Url, SftpProtocol, ProtocolLen))\r\n  {\r\n    AFSProtocol = fsSFTPonly;\r\n    APortNumber = SshPortNumber;\r\n    MoveStr(Url, MaskedUrl, ProtocolLen);\r\n    ProtocolDefined = true;\r\n  }\r\n  else if (IsProtocolUrl(Url, FtpProtocol, ProtocolLen))\r\n  {\r\n    AFSProtocol = fsFTP;\r\n    Ftps = ftpsNone;\r\n    APortNumber = FtpPortNumber;\r\n    MoveStr(Url, MaskedUrl, ProtocolLen);\r\n    ProtocolDefined = true;\r\n  }\r\n  else if (IsProtocolUrl(Url, FtpsProtocol, ProtocolLen))\r\n  {\r\n    AFSProtocol = fsFTP;\r\n    AFtps = ftpsImplicit;\r\n    APortNumber = FtpsImplicitPortNumber;\r\n    MoveStr(Url, MaskedUrl, ProtocolLen);\r\n    ProtocolDefined = true;\r\n  }\r\n  else if (IsProtocolUrl(Url, FtpesProtocol, ProtocolLen))\r\n  {\r\n    AFSProtocol = fsFTP;\r\n    AFtps = ftpsExplicitTls;\r\n    APortNumber = FtpPortNumber;\r\n    MoveStr(Url, MaskedUrl, ProtocolLen);\r\n    ProtocolDefined = true;\r\n  }\r\n  else if (IsProtocolUrl(Url, WebDAVProtocol, ProtocolLen) ||\r\n           IsProtocolUrl(Url, HttpProtocol, ProtocolLen))\r\n  {\r\n    AFSProtocol = fsWebDAV;\r\n    AFtps = ftpsNone;\r\n    APortNumber = HTTPPortNumber;\r\n    MoveStr(Url, MaskedUrl, ProtocolLen);\r\n    ProtocolDefined = true;\r\n  }\r\n  else if (IsProtocolUrl(Url, WebDAVSProtocol, ProtocolLen) ||\r\n           IsProtocolUrl(Url, HttpsProtocol, ProtocolLen))\r\n  {\r\n    AFSProtocol = fsWebDAV;\r\n    AFtps = ftpsImplicit;\r\n    APortNumber = HTTPSPortNumber;\r\n    MoveStr(Url, MaskedUrl, ProtocolLen);\r\n    ProtocolDefined = true;\r\n  }\r\n  else if (IsProtocolUrl(Url, S3Protocol, ProtocolLen))\r\n  {\r\n    AFSProtocol = fsS3;\r\n    AFtps = ftpsImplicit;\r\n    APortNumber = HTTPSPortNumber;\r\n    MoveStr(Url, MaskedUrl, ProtocolLen);\r\n    ProtocolDefined = true;\r\n  }\r\n  else if (IsProtocolUrl(Url, SshProtocol, ProtocolLen))\r\n  {\r\n    // For most uses, handling ssh:// the same way as sftp://\r\n    // The only place where a difference is made is GetLoginData() in WinMain.cpp\r\n    AFSProtocol = fsSFTPonly;\r\n    PuttyProtocol = PuttySshProtocol;\r\n    APortNumber = SshPortNumber;\r\n    MoveStr(Url, MaskedUrl, ProtocolLen);\r\n    ProtocolDefined = true;\r\n  }\r\n\r\n  if (ProtocolDefined && (Url.SubString(1, 2) == L\"//\"))\r\n  {\r\n    MoveStr(Url, MaskedUrl, 2);\r\n  }\r\n\r\n  if (AProtocolDefined != NULL)\r\n  {\r\n    *AProtocolDefined = ProtocolDefined;\r\n  }\r\n\r\n  bool Unsafe = FLAGSET(Flags, pufUnsafe);\r\n  if (!Url.IsEmpty())\r\n  {\r\n    UnicodeString DecodedUrl = DecodeUrlChars(Url);\r\n    // lookup stored session even if protocol was defined\r\n    // (this allows setting for example default username for host\r\n    // by creating stored session named by host)\r\n    TSessionData * Data = NULL;\r\n    // When using to paste URL on Login dialog, we do not want to lookup the stored sites\r\n    if ((StoredSessions != NULL) &&\r\n        (!ProtocolDefined || FLAGSET(Flags, pufAllowStoredSiteWithProtocol)))\r\n    {\r\n      // this can be optimized as the list is sorted\r\n      for (Integer Index = 0; Index < StoredSessions->CountIncludingHidden; Index++)\r\n      {\r\n        TSessionData * AData = (TSessionData *)StoredSessions->Items[Index];\r\n        if (!AData->IsWorkspace)\r\n        {\r\n          bool Match = false;\r\n          // Comparison optimizations as this is called many times\r\n          // e.g. when updating jumplist\r\n          if ((AData->Name.Length() == DecodedUrl.Length()) &&\r\n              SameText(AData->Name, DecodedUrl))\r\n          {\r\n            Match = true;\r\n          }\r\n          else if ((AData->Name.Length() < DecodedUrl.Length()) &&\r\n                   (DecodedUrl[AData->Name.Length() + 1] == L'/') &&\r\n                   // StrLIComp is an equivalent of SameText\r\n                   (StrLIComp(AData->Name.c_str(), DecodedUrl.c_str(), AData->Name.Length()) == 0))\r\n          {\r\n            Match = true;\r\n          }\r\n\r\n          if (Match)\r\n          {\r\n            Data = AData;\r\n            break;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    UnicodeString ARemoteDirectory;\r\n\r\n    if (Data != NULL)\r\n    {\r\n      Assign(Data);\r\n      int P = 1;\r\n      while (!AnsiSameText(DecodeUrlChars(Url.SubString(1, P)), Data->Name))\r\n      {\r\n        P++;\r\n        DebugAssert(P <= Url.Length());\r\n      }\r\n      ARemoteDirectory = Url.SubString(P + 1, Url.Length() - P);\r\n\r\n      if (Data->Hidden)\r\n      {\r\n        Data->Remove();\r\n        StoredSessions->Remove(Data);\r\n        // only modified, implicit\r\n        StoredSessions->Save(false, false);\r\n      }\r\n\r\n      if (MaskedUrl != NULL)\r\n      {\r\n        (*MaskedUrl) += Url;\r\n      }\r\n    }\r\n    else\r\n    {\r\n      // This happens when pasting URL on Login dialog\r\n      if (StoredSessions != NULL)\r\n      {\r\n        CopyData(StoredSessions->DefaultSettings);\r\n      }\r\n      Name = L\"\";\r\n\r\n      int PSlash = Url.Pos(L\"/\");\r\n      if (PSlash == 0)\r\n      {\r\n        PSlash = Url.Length() + 1;\r\n      }\r\n\r\n      UnicodeString ConnectInfo = Url.SubString(1, PSlash - 1);\r\n\r\n      int P = ConnectInfo.LastDelimiter(L\"@\");\r\n\r\n      UnicodeString UserInfo;\r\n      UnicodeString HostInfo;\r\n\r\n      if (P > 0)\r\n      {\r\n        UserInfo = ConnectInfo.SubString(1, P - 1);\r\n        HostInfo = ConnectInfo.SubString(P + 1, ConnectInfo.Length() - P);\r\n      }\r\n      else\r\n      {\r\n        HostInfo = ConnectInfo;\r\n      }\r\n\r\n      UnicodeString OrigHostInfo = HostInfo;\r\n      if ((HostInfo.Length() >= 2) && (HostInfo[1] == L'[') && ((P = HostInfo.Pos(L\"]\")) > 0))\r\n      {\r\n        HostName = HostInfo.SubString(2, P - 2);\r\n        HostInfo.Delete(1, P);\r\n        if (!HostInfo.IsEmpty() && (HostInfo[1] == L':'))\r\n        {\r\n          HostInfo.Delete(1, 1);\r\n        }\r\n      }\r\n      else\r\n      {\r\n        HostName = DecodeUrlChars(CutToChar(HostInfo, L':', true));\r\n      }\r\n\r\n      // expanded from ?: operator, as it caused strange \"access violation\" errors\r\n      if (!HostInfo.IsEmpty())\r\n      {\r\n        PortNumber = StrToIntDef(DecodeUrlChars(HostInfo), -1);\r\n        PortNumberDefined = true;\r\n      }\r\n      else if (ProtocolDefined)\r\n      {\r\n        PortNumber = APortNumber;\r\n      }\r\n\r\n      if (ProtocolDefined)\r\n      {\r\n        Ftps = AFtps;\r\n      }\r\n\r\n      UnicodeString UserInfoWithoutConnectionParams = CutToChar(UserInfo, UrlParamSeparator, false);\r\n      UnicodeString ConnectionParams = UserInfo;\r\n      UserInfo = UserInfoWithoutConnectionParams;\r\n\r\n      std::unique_ptr<TStrings> RawSettings(new TStringList());\r\n\r\n      while (!ConnectionParams.IsEmpty())\r\n      {\r\n        UnicodeString ConnectionParam = CutToChar(ConnectionParams, UrlParamSeparator, false);\r\n        UnicodeString ConnectionParamName = CutToChar(ConnectionParam, UrlParamValueSeparator, false);\r\n        if (SameText(ConnectionParamName, UrlHostKeyParamName))\r\n        {\r\n          HostKey = DecodeUrlChars(ConnectionParam);\r\n          FOverrideCachedHostKey = false;\r\n        }\r\n        else if (StartsText(UrlRawSettingsParamNamePrefix, ConnectionParamName))\r\n        {\r\n          UnicodeString AName = RightStr(ConnectionParamName, ConnectionParamName.Length() - UrlRawSettingsParamNamePrefix.Length());\r\n          AName = DecodeUrlChars(AName);\r\n          UnicodeString Value = DecodeUrlChars(ConnectionParam);\r\n          if (SameText(AName, L\"Name\"))\r\n          {\r\n            Name = Value;\r\n          }\r\n          else\r\n          {\r\n            RawSettings->Values[AName] = Value;\r\n          }\r\n        }\r\n      }\r\n\r\n      if (RawSettings->Count > 0) // optimization\r\n      {\r\n        ApplyRawSettings(RawSettings.get(), FLAGSET(Flags, pufUnsafe));\r\n      }\r\n\r\n      bool HasPassword = (UserInfo.Pos(L':') > 0);\r\n      UnicodeString RawUserName = CutToChar(UserInfo, L':', false);\r\n      UserName = DecodeUrlChars(RawUserName);\r\n\r\n      Password = DecodeUrlChars(UserInfo);\r\n      if (HasPassword && Password.IsEmpty())\r\n      {\r\n        Password = EmptyString;\r\n      }\r\n\r\n      UnicodeString RemoteDirectoryWithSessionParams = Url.SubString(PSlash, Url.Length() - PSlash + 1);\r\n      ARemoteDirectory = CutToChar(RemoteDirectoryWithSessionParams, UrlParamSeparator, false);\r\n      UnicodeString SessionParams = RemoteDirectoryWithSessionParams;\r\n\r\n      // We should handle session params in \"stored session\" branch too.\r\n      // And particularly if there's a \"save\" param, we should actually not try to match the\r\n      // URL against site names\r\n      while (!SessionParams.IsEmpty())\r\n      {\r\n        UnicodeString SessionParam = CutToChar(SessionParams, UrlParamSeparator, false);\r\n        UnicodeString SessionParamName = CutToChar(SessionParam, UrlParamValueSeparator, false);\r\n        if (SameText(SessionParamName, UrlSaveParamName))\r\n        {\r\n          FSaveOnly = (StrToIntDef(SessionParam, 1) != 0);\r\n        }\r\n      }\r\n\r\n      if (MaskedUrl != NULL)\r\n      {\r\n        (*MaskedUrl) += RawUserName;\r\n        if (HasPassword)\r\n        {\r\n          (*MaskedUrl) += L\":\" + PasswordMask;\r\n        }\r\n        if (!RawUserName.IsEmpty() || HasPassword)\r\n        {\r\n          (*MaskedUrl) += L\"@\";\r\n        }\r\n        (*MaskedUrl) += OrigHostInfo + ARemoteDirectory;\r\n      }\r\n    }\r\n\r\n    if (!ARemoteDirectory.IsEmpty() && (ARemoteDirectory != L\"/\"))\r\n    {\r\n      if ((ARemoteDirectory[ARemoteDirectory.Length()] != L'/') &&\r\n          (FileName != NULL))\r\n      {\r\n        *FileName = DecodeUrlChars(UnixExtractFileName(ARemoteDirectory));\r\n        ARemoteDirectory = UnixExtractFilePath(ARemoteDirectory);\r\n      }\r\n      RemoteDirectory = DecodeUrlChars(ARemoteDirectory);\r\n    }\r\n\r\n    DefaultsOnly = false;\r\n  }\r\n  else\r\n  {\r\n    // This happens when pasting URL on Login dialog\r\n    if (StoredSessions != NULL)\r\n    {\r\n      CopyData(StoredSessions->DefaultSettings);\r\n    }\r\n\r\n    DefaultsOnly = true;\r\n  }\r\n\r\n  if (ProtocolDefined)\r\n  {\r\n    FSProtocol = AFSProtocol;\r\n  }\r\n\r\n  if (Options != NULL)\r\n  {\r\n    // we deliberately do keep defaultonly to false, in presence of any option,\r\n    // as the option should not make session \"connectable\"\r\n\r\n    UnicodeString Value;\r\n    if (Options->FindSwitch(SESSIONNAME_SWICH, Value))\r\n    {\r\n      Name = Value;\r\n    }\r\n    if (Options->FindSwitch(NEWPASSWORD_SWITCH, Value))\r\n    {\r\n      ChangePassword = true;\r\n      NewPassword = Value;\r\n    }\r\n    if (Options->FindSwitch(L\"privatekey\", Value))\r\n    {\r\n      PublicKeyFile = Value;\r\n    }\r\n    if (Options->FindSwitch(L\"clientcert\", Value))\r\n    {\r\n      TlsCertificateFile = Value;\r\n    }\r\n    if (Options->FindSwitch(PassphraseOption, Value))\r\n    {\r\n      Passphrase = Value;\r\n    }\r\n    if (Options->FindSwitch(L\"timeout\", Value))\r\n    {\r\n      Timeout = StrToInt(Value);\r\n    }\r\n    if (Options->FindSwitch(L\"hostkey\", Value) ||\r\n        Options->FindSwitch(L\"certificate\", Value))\r\n    {\r\n      HostKey = Value;\r\n      FOverrideCachedHostKey = true;\r\n    }\r\n    FtpPasvMode = Options->SwitchValue(L\"passive\", FtpPasvMode);\r\n    if (Options->FindSwitch(L\"implicit\"))\r\n    {\r\n      bool Enabled = Options->SwitchValue(L\"implicit\", true);\r\n      Ftps = Enabled ? ftpsImplicit : ftpsNone;\r\n      if (!PortNumberDefined && Enabled)\r\n      {\r\n        PortNumber = FtpsImplicitPortNumber;\r\n      }\r\n    }\r\n    // BACKWARD COMPATIBILITY with 5.5.x\r\n    if (Options->FindSwitch(L\"explicitssl\"))\r\n    {\r\n      bool Enabled = Options->SwitchValue(L\"explicitssl\", true);\r\n      Ftps = Enabled ? ftpsExplicitSsl : ftpsNone;\r\n      if (!PortNumberDefined && Enabled)\r\n      {\r\n        PortNumber = FtpPortNumber;\r\n      }\r\n    }\r\n    if (Options->FindSwitch(L\"explicit\") ||\r\n        // BACKWARD COMPATIBILITY with 5.5.x\r\n        Options->FindSwitch(L\"explicittls\"))\r\n    {\r\n      UnicodeString SwitchName =\r\n        Options->FindSwitch(L\"explicit\") ? L\"explicit\" : L\"explicittls\";\r\n      bool Enabled = Options->SwitchValue(SwitchName, true);\r\n      Ftps = Enabled ? ftpsExplicitTls : ftpsNone;\r\n      if (!PortNumberDefined && Enabled)\r\n      {\r\n        PortNumber = FtpPortNumber;\r\n      }\r\n    }\r\n    if (Options->FindSwitch(RawSettingsOption))\r\n    {\r\n      std::unique_ptr<TStrings> RawSettings(new TStringList());\r\n      if (Options->FindSwitch(RawSettingsOption, RawSettings.get()))\r\n      {\r\n        ApplyRawSettings(RawSettings.get(), Unsafe);\r\n      }\r\n    }\r\n  }\r\n\r\n  return true;\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::ApplyRawSettings(TStrings * RawSettings, bool Unsafe)\r\n{\r\n  std::unique_ptr<TOptionsStorage> OptionsStorage(new TOptionsStorage(RawSettings, false));\r\n  ApplyRawSettings(OptionsStorage.get(), Unsafe);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::ApplyRawSettings(THierarchicalStorage * Storage, bool Unsafe)\r\n{\r\n  bool Dummy;\r\n  DoLoad(Storage, false, Dummy, Unsafe);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::ConfigureTunnel(int APortNumber)\r\n{\r\n  FOrigHostName = HostName;\r\n  FOrigPortNumber = PortNumber;\r\n  FOrigProxyMethod = ProxyMethod;\r\n\r\n  HostName = L\"127.0.0.1\";\r\n  PortNumber = APortNumber;\r\n  // proxy settings is used for tunnel\r\n  ProxyMethod = ::pmNone;\r\n  FLogicalHostName = FOrigHostName;\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::RollbackTunnel()\r\n{\r\n  HostName = FOrigHostName;\r\n  PortNumber = FOrigPortNumber;\r\n  ProxyMethod = FOrigProxyMethod;\r\n  FLogicalHostName = L\"\";\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::ExpandEnvironmentVariables()\r\n{\r\n  HostName = HostNameExpanded;\r\n  UserName = UserNameExpanded;\r\n  PublicKeyFile = ::ExpandEnvironmentVariables(PublicKeyFile);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::ValidatePath(const UnicodeString Path)\r\n{\r\n  // noop\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::ValidateName(const UnicodeString Name)\r\n{\r\n  // keep consistent with MakeValidName\r\n  if (Name.LastDelimiter(L\"/\") > 0)\r\n  {\r\n    throw Exception(FMTLOAD(ITEM_NAME_INVALID, (Name, L\"/\")));\r\n  }\r\n}\r\n//---------------------------------------------------------------------\r\nUnicodeString __fastcall TSessionData::MakeValidName(const UnicodeString & Name)\r\n{\r\n  // keep consistent with ValidateName\r\n  return ReplaceStr(Name, L\"/\", L\"\\\\\");\r\n}\r\n//---------------------------------------------------------------------\r\nRawByteString __fastcall TSessionData::EncryptPassword(const UnicodeString & Password, UnicodeString Key)\r\n{\r\n  return Configuration->EncryptPassword(Password, Key);\r\n}\r\n//---------------------------------------------------------------------\r\nRawByteString __fastcall TSessionData::StronglyRecryptPassword(const RawByteString & Password, UnicodeString Key)\r\n{\r\n  return Configuration->StronglyRecryptPassword(Password, Key);\r\n}\r\n//---------------------------------------------------------------------\r\nUnicodeString __fastcall TSessionData::DecryptPassword(const RawByteString & Password, UnicodeString Key)\r\n{\r\n  UnicodeString Result;\r\n  try\r\n  {\r\n    Result = Configuration->DecryptPassword(Password, Key);\r\n  }\r\n  catch(EAbort &)\r\n  {\r\n    // silently ignore aborted prompts for master password and return empty password\r\n  }\r\n  return Result;\r\n}\r\n//---------------------------------------------------------------------\r\nbool __fastcall TSessionData::GetCanLogin()\r\n{\r\n  return !FHostName.IsEmpty();\r\n}\r\n//---------------------------------------------------------------------------\r\nUnicodeString __fastcall TSessionData::GetSessionKey()\r\n{\r\n  UnicodeString Result = FORMAT(L\"%s@%s\", (UserName, HostName));\r\n  if (PortNumber != DefaultPort(FSProtocol, Ftps))\r\n  {\r\n    Result += FORMAT(L\":%d\", (PortNumber));\r\n  }\r\n  return Result;\r\n}\r\n//---------------------------------------------------------------------\r\nUnicodeString __fastcall TSessionData::GetInternalStorageKey()\r\n{\r\n  // This is probably useless remnant of previous use of this method from OpenSessionInPutty\r\n  // that needs the method to return something even for ad-hoc sessions\r\n  if (Name.IsEmpty())\r\n  {\r\n    return SessionKey;\r\n  }\r\n  else\r\n  {\r\n    return Name;\r\n  }\r\n}\r\n//---------------------------------------------------------------------\r\nUnicodeString __fastcall TSessionData::GetStorageKey()\r\n{\r\n  return SessionName;\r\n}\r\n//---------------------------------------------------------------------\r\nUnicodeString __fastcall TSessionData::FormatSiteKey(const UnicodeString & HostName, int PortNumber)\r\n{\r\n  return FORMAT(L\"%s:%d\", (HostName, PortNumber));\r\n}\r\n//---------------------------------------------------------------------\r\nUnicodeString __fastcall TSessionData::GetSiteKey()\r\n{\r\n  return FormatSiteKey(HostNameExpanded, PortNumber);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetHostName(UnicodeString value)\r\n{\r\n  if (FHostName != value)\r\n  {\r\n    // HostName is key for password encryption\r\n    UnicodeString XPassword = Password;\r\n    UnicodeString XNewPassword = Password;\r\n    UnicodeString XEncryptKey = EncryptKey;\r\n\r\n    // This is now hardly used as hostname is parsed directly on login dialog.\r\n    // But can be used when importing sites from PuTTY, as it allows same format too.\r\n    int P = value.LastDelimiter(L\"@\");\r\n    if (P > 0)\r\n    {\r\n      UserName = value.SubString(1, P - 1);\r\n      value = value.SubString(P + 1, value.Length() - P);\r\n    }\r\n    FHostName = value;\r\n    Modify();\r\n\r\n    Password = XPassword;\r\n    NewPassword = XNewPassword;\r\n    EncryptKey = XEncryptKey;\r\n    Shred(XPassword);\r\n    Shred(XNewPassword);\r\n    Shred(XEncryptKey);\r\n  }\r\n}\r\n//---------------------------------------------------------------------\r\nUnicodeString __fastcall TSessionData::GetHostNameExpanded()\r\n{\r\n  return ::ExpandEnvironmentVariables(HostName);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetPortNumber(int value)\r\n{\r\n  SET_SESSION_PROPERTY(PortNumber);\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetShell(UnicodeString value)\r\n{\r\n  SET_SESSION_PROPERTY(Shell);\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetSftpServer(UnicodeString value)\r\n{\r\n  SET_SESSION_PROPERTY(SftpServer);\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetClearAliases(bool value)\r\n{\r\n  SET_SESSION_PROPERTY(ClearAliases);\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetListingCommand(UnicodeString value)\r\n{\r\n  SET_SESSION_PROPERTY(ListingCommand);\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetIgnoreLsWarnings(bool value)\r\n{\r\n  SET_SESSION_PROPERTY(IgnoreLsWarnings);\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetUnsetNationalVars(bool value)\r\n{\r\n  SET_SESSION_PROPERTY(UnsetNationalVars);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetUserName(UnicodeString value)\r\n{\r\n  // Avoid password recryption (what may popup master password prompt)\r\n  if (FUserName != value)\r\n  {\r\n    // UserName is key for password encryption\r\n    UnicodeString XPassword = Password;\r\n    UnicodeString XNewPassword = NewPassword;\r\n    UnicodeString XEncryptKey = EncryptKey;\r\n    SET_SESSION_PROPERTY(UserName);\r\n    Password = XPassword;\r\n    NewPassword = XNewPassword;\r\n    EncryptKey = XEncryptKey;\r\n    Shred(XPassword);\r\n    Shred(XNewPassword);\r\n    Shred(XEncryptKey);\r\n  }\r\n}\r\n//---------------------------------------------------------------------\r\nUnicodeString __fastcall TSessionData::GetUserNameExpanded()\r\n{\r\n  return ::ExpandEnvironmentVariables(UserName);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetPassword(UnicodeString avalue)\r\n{\r\n  RawByteString value = EncryptPassword(avalue, UserName+HostName);\r\n  SET_SESSION_PROPERTY(Password);\r\n}\r\n//---------------------------------------------------------------------\r\nUnicodeString __fastcall TSessionData::GetPassword() const\r\n{\r\n  return DecryptPassword(FPassword, UserName+HostName);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetNewPassword(UnicodeString avalue)\r\n{\r\n  RawByteString value = EncryptPassword(avalue, UserName+HostName);\r\n  SET_SESSION_PROPERTY(NewPassword);\r\n}\r\n//---------------------------------------------------------------------\r\nUnicodeString __fastcall TSessionData::GetNewPassword() const\r\n{\r\n  return DecryptPassword(FNewPassword, UserName+HostName);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetChangePassword(bool value)\r\n{\r\n  SET_SESSION_PROPERTY(ChangePassword);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetPingInterval(int value)\r\n{\r\n  SET_SESSION_PROPERTY(PingInterval);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetTryAgent(bool value)\r\n{\r\n  SET_SESSION_PROPERTY(TryAgent);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetAgentFwd(bool value)\r\n{\r\n  SET_SESSION_PROPERTY(AgentFwd);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetAuthTIS(bool value)\r\n{\r\n  SET_SESSION_PROPERTY(AuthTIS);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetAuthKI(bool value)\r\n{\r\n  SET_SESSION_PROPERTY(AuthKI);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetAuthKIPassword(bool value)\r\n{\r\n  SET_SESSION_PROPERTY(AuthKIPassword);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetAuthGSSAPI(bool value)\r\n{\r\n  SET_SESSION_PROPERTY(AuthGSSAPI);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetGSSAPIFwdTGT(bool value)\r\n{\r\n  SET_SESSION_PROPERTY(GSSAPIFwdTGT);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetChangeUsername(bool value)\r\n{\r\n  SET_SESSION_PROPERTY(ChangeUsername);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetCompression(bool value)\r\n{\r\n  SET_SESSION_PROPERTY(Compression);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetSshProt(TSshProt value)\r\n{\r\n  SET_SESSION_PROPERTY(SshProt);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetSsh2DES(bool value)\r\n{\r\n  SET_SESSION_PROPERTY(Ssh2DES);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetSshNoUserAuth(bool value)\r\n{\r\n  SET_SESSION_PROPERTY(SshNoUserAuth);\r\n}\r\n//---------------------------------------------------------------------\r\nUnicodeString __fastcall TSessionData::GetSshProtStr()\r\n{\r\n  return SshProtList[FSshProt];\r\n}\r\n//---------------------------------------------------------------------\r\nbool __fastcall TSessionData::GetUsesSsh()\r\n{\r\n  return IsSshProtocol(FSProtocol);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetCipher(int Index, TCipher value)\r\n{\r\n  DebugAssert(Index >= 0 && Index < CIPHER_COUNT);\r\n  SET_SESSION_PROPERTY(Ciphers[Index]);\r\n}\r\n//---------------------------------------------------------------------\r\nTCipher __fastcall TSessionData::GetCipher(int Index) const\r\n{\r\n  DebugAssert(Index >= 0 && Index < CIPHER_COUNT);\r\n  return FCiphers[Index];\r\n}\r\n//---------------------------------------------------------------------\r\ntemplate<class AlgoT>\r\nvoid __fastcall TSessionData::SetAlgoList(AlgoT * List, const AlgoT * DefaultList, const UnicodeString * Names,\r\n  int Count, AlgoT WarnAlgo, UnicodeString value)\r\n{\r\n  std::vector<bool> Used(Count); // initialized to false\r\n  std::vector<AlgoT> NewList(Count);\r\n\r\n  bool HasWarnAlgo = (WarnAlgo >= AlgoT());\r\n  const AlgoT * WarnPtr;\r\n  int WarnDefaultIndex;\r\n  if (!HasWarnAlgo)\r\n  {\r\n    WarnPtr = NULL;\r\n    WarnDefaultIndex = -1;\r\n  }\r\n  else\r\n  {\r\n    WarnPtr = std::find(DefaultList, DefaultList + Count, WarnAlgo);\r\n    DebugAssert(WarnPtr != NULL);\r\n    WarnDefaultIndex = (WarnPtr - DefaultList);\r\n  }\r\n\r\n  int Index = 0;\r\n  while (!value.IsEmpty())\r\n  {\r\n    UnicodeString AlgoStr = CutToChar(value, L',', true);\r\n    for (int Algo = 0; Algo < Count; Algo++)\r\n    {\r\n      if (!AlgoStr.CompareIC(Names[Algo]) &&\r\n          !Used[Algo] && DebugAlwaysTrue(Index < Count))\r\n      {\r\n        NewList[Index] = (AlgoT)Algo;\r\n        Used[Algo] = true;\r\n        Index++;\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  if (HasWarnAlgo && !Used[WarnAlgo] && DebugAlwaysTrue(Index < Count))\r\n  {\r\n    NewList[Index] = WarnAlgo;\r\n    Used[WarnAlgo] = true;\r\n    Index++;\r\n  }\r\n\r\n  int WarnIndex = -1;\r\n  if (HasWarnAlgo)\r\n  {\r\n    WarnIndex = std::find(NewList.begin(), NewList.end(), WarnAlgo) - NewList.begin();\r\n  }\r\n\r\n  bool Priority = true;\r\n  for (int DefaultIndex = 0; (DefaultIndex < Count); DefaultIndex++)\r\n  {\r\n    AlgoT DefaultAlgo = DefaultList[DefaultIndex];\r\n    if (!Used[DefaultAlgo] && DebugAlwaysTrue(Index < Count))\r\n    {\r\n      int TargetIndex;\r\n      // Unused algs that are prioritized in the default list,\r\n      // should be merged before the existing custom list\r\n      if (Priority)\r\n      {\r\n        TargetIndex = DefaultIndex;\r\n      }\r\n      else\r\n      {\r\n        if (HasWarnAlgo && (DefaultIndex < WarnDefaultIndex))\r\n        {\r\n          TargetIndex = WarnIndex;\r\n        }\r\n        else\r\n        {\r\n          TargetIndex = Index;\r\n        }\r\n      }\r\n\r\n      NewList.insert(NewList.begin() + TargetIndex, DefaultAlgo);\r\n      DebugAssert(NewList.back() == AlgoT());\r\n      NewList.pop_back();\r\n\r\n      if (HasWarnAlgo && (TargetIndex <= WarnIndex))\r\n      {\r\n        WarnIndex++;\r\n      }\r\n\r\n      Index++;\r\n    }\r\n    else\r\n    {\r\n      Priority = false;\r\n    }\r\n  }\r\n\r\n  if (!std::equal(NewList.begin(), NewList.end(), List))\r\n  {\r\n    std::copy(NewList.begin(), NewList.end(), List);\r\n    Modify();\r\n  }\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetCipherList(UnicodeString value)\r\n{\r\n  SetAlgoList(FCiphers, DefaultCipherList, CipherNames, CIPHER_COUNT, cipWarn, value);\r\n}\r\n//---------------------------------------------------------------------\r\nUnicodeString __fastcall TSessionData::GetCipherList() const\r\n{\r\n  UnicodeString Result;\r\n  for (int Index = 0; Index < CIPHER_COUNT; Index++)\r\n  {\r\n    Result += UnicodeString(Index ? L\",\" : L\"\") + CipherNames[Cipher[Index]];\r\n  }\r\n  return Result;\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetKex(int Index, TKex value)\r\n{\r\n  DebugAssert(Index >= 0 && Index < KEX_COUNT);\r\n  SET_SESSION_PROPERTY(Kex[Index]);\r\n}\r\n//---------------------------------------------------------------------\r\nTKex __fastcall TSessionData::GetKex(int Index) const\r\n{\r\n  DebugAssert(Index >= 0 && Index < KEX_COUNT);\r\n  return FKex[Index];\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetKexList(UnicodeString value)\r\n{\r\n  SetAlgoList(FKex, DefaultKexList, KexNames, KEX_COUNT, kexWarn, value);\r\n}\r\n//---------------------------------------------------------------------\r\nUnicodeString __fastcall TSessionData::GetKexList() const\r\n{\r\n  UnicodeString Result;\r\n  for (int Index = 0; Index < KEX_COUNT; Index++)\r\n  {\r\n    Result += UnicodeString(Index ? L\",\" : L\"\") + KexNames[Kex[Index]];\r\n  }\r\n  return Result;\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetHostKeys(int Index, THostKey value)\r\n{\r\n  DebugAssert(Index >= 0 && Index < HOSTKEY_COUNT);\r\n  SET_SESSION_PROPERTY(HostKeys[Index]);\r\n}\r\n//---------------------------------------------------------------------\r\nTHostKey __fastcall TSessionData::GetHostKeys(int Index) const\r\n{\r\n  DebugAssert(Index >= 0 && Index < HOSTKEY_COUNT);\r\n  return FHostKeys[Index];\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetHostKeyList(UnicodeString value)\r\n{\r\n  SetAlgoList(FHostKeys, DefaultHostKeyList, HostKeyNames, HOSTKEY_COUNT, hkWarn, value);\r\n}\r\n//---------------------------------------------------------------------\r\nUnicodeString __fastcall TSessionData::GetHostKeyList() const\r\n{\r\n  UnicodeString Result;\r\n  for (int Index = 0; Index < HOSTKEY_COUNT; Index++)\r\n  {\r\n    Result += UnicodeString(Index ? L\",\" : L\"\") + HostKeyNames[HostKeys[Index]];\r\n  }\r\n  return Result;\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetGssLib(int Index, TGssLib value)\r\n{\r\n  DebugAssert(Index >= 0 && Index < GSSLIB_COUNT);\r\n  SET_SESSION_PROPERTY(GssLib[Index]);\r\n}\r\n//---------------------------------------------------------------------\r\nTGssLib __fastcall TSessionData::GetGssLib(int Index) const\r\n{\r\n  DebugAssert(Index >= 0 && Index < GSSLIB_COUNT);\r\n  return FGssLib[Index];\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetGssLibList(UnicodeString value)\r\n{\r\n  SetAlgoList(FGssLib, DefaultGssLibList, GssLibNames, GSSLIB_COUNT, TGssLib(-1), value);\r\n}\r\n//---------------------------------------------------------------------\r\nUnicodeString __fastcall TSessionData::GetGssLibList() const\r\n{\r\n  UnicodeString Result;\r\n  for (int Index = 0; Index < GSSLIB_COUNT; Index++)\r\n  {\r\n    Result += UnicodeString(Index ? L\",\" : L\"\") + GssLibNames[GssLib[Index]];\r\n  }\r\n  return Result;\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetGssLibCustom(UnicodeString value)\r\n{\r\n  SET_SESSION_PROPERTY(GssLibCustom);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetPublicKeyFile(UnicodeString value)\r\n{\r\n  if (FPublicKeyFile != value)\r\n  {\r\n    // PublicKeyFile is key for Passphrase encryption\r\n    UnicodeString XPassphrase = Passphrase;\r\n\r\n    // StripPathQuotes should not be needed as we do not feed quotes anymore\r\n    FPublicKeyFile = StripPathQuotes(value);\r\n    Modify();\r\n\r\n    Passphrase = XPassphrase;\r\n    Shred(XPassphrase);\r\n  }\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetPassphrase(UnicodeString avalue)\r\n{\r\n  RawByteString value = EncryptPassword(avalue, PublicKeyFile);\r\n  SET_SESSION_PROPERTY(Passphrase);\r\n}\r\n//---------------------------------------------------------------------\r\nUnicodeString __fastcall TSessionData::GetPassphrase() const\r\n{\r\n  return DecryptPassword(FPassphrase, PublicKeyFile);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetReturnVar(UnicodeString value)\r\n{\r\n  SET_SESSION_PROPERTY(ReturnVar);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetExitCode1IsError(bool value)\r\n{\r\n  SET_SESSION_PROPERTY(ExitCode1IsError);\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetLookupUserGroups(TAutoSwitch value)\r\n{\r\n  SET_SESSION_PROPERTY(LookupUserGroups);\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetEOLType(TEOLType value)\r\n{\r\n  SET_SESSION_PROPERTY(EOLType);\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetTrimVMSVersions(bool value)\r\n{\r\n  SET_SESSION_PROPERTY(TrimVMSVersions);\r\n}\r\n//---------------------------------------------------------------------------\r\nTDateTime __fastcall TSessionData::GetTimeoutDT()\r\n{\r\n  return SecToDateTime(Timeout);\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetTimeout(int value)\r\n{\r\n  SET_SESSION_PROPERTY(Timeout);\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetFSProtocol(TFSProtocol value)\r\n{\r\n  SET_SESSION_PROPERTY(FSProtocol);\r\n}\r\n//---------------------------------------------------------------------\r\nUnicodeString __fastcall TSessionData::GetFSProtocolStr()\r\n{\r\n  DebugAssert(FSProtocol >= 0 && FSProtocol < FSPROTOCOL_COUNT);\r\n  return FSProtocolNames[FSProtocol];\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetDetectReturnVar(bool value)\r\n{\r\n  if (value != DetectReturnVar)\r\n  {\r\n    ReturnVar = value ? L\"\" : L\"$?\";\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\nbool __fastcall TSessionData::GetDetectReturnVar()\r\n{\r\n  return ReturnVar.IsEmpty();\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetDefaultShell(bool value)\r\n{\r\n  if (value != DefaultShell)\r\n  {\r\n    Shell = value ? L\"\" : L\"/bin/bash\";\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\nbool __fastcall TSessionData::GetDefaultShell()\r\n{\r\n  return Shell.IsEmpty();\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetPuttyProtocol(UnicodeString value)\r\n{\r\n  SET_SESSION_PROPERTY(PuttyProtocol);\r\n}\r\n//---------------------------------------------------------------------\r\nUnicodeString __fastcall TSessionData::GetNormalizedPuttyProtocol() const\r\n{\r\n  return DefaultStr(PuttyProtocol, PuttySshProtocol);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetPingIntervalDT(TDateTime value)\r\n{\r\n  unsigned short hour, min, sec, msec;\r\n\r\n  value.DecodeTime(&hour, &min, &sec, &msec);\r\n  PingInterval = ((int)hour)*SecsPerHour + ((int)min)*SecsPerMin + sec;\r\n}\r\n//---------------------------------------------------------------------------\r\nTDateTime __fastcall TSessionData::GetPingIntervalDT()\r\n{\r\n  return SecToDateTime(PingInterval);\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetPingType(TPingType value)\r\n{\r\n  SET_SESSION_PROPERTY(PingType);\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetAddressFamily(TAddressFamily value)\r\n{\r\n  SET_SESSION_PROPERTY(AddressFamily);\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetRekeyData(UnicodeString value)\r\n{\r\n  SET_SESSION_PROPERTY(RekeyData);\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetRekeyTime(unsigned int value)\r\n{\r\n  SET_SESSION_PROPERTY(RekeyTime);\r\n}\r\n//---------------------------------------------------------------------\r\nUnicodeString __fastcall TSessionData::GetDefaultSessionName()\r\n{\r\n  if (!HostName.IsEmpty() && !UserName.IsEmpty())\r\n  {\r\n    // If we ever choose to include port number,\r\n    // we have to escape IPv6 literals in HostName\r\n    return FORMAT(L\"%s@%s\", (UserName, HostName));\r\n  }\r\n  else if (!HostName.IsEmpty())\r\n  {\r\n    return HostName;\r\n  }\r\n  else\r\n  {\r\n    return L\"session\";\r\n  }\r\n}\r\n//---------------------------------------------------------------------\r\nUnicodeString __fastcall TSessionData::GetNameWithoutHiddenPrefix()\r\n{\r\n  UnicodeString Result = Name;\r\n  if (Hidden)\r\n  {\r\n    Result = Result.SubString(TNamedObjectList::HiddenPrefix.Length() + 1, Result.Length() - TNamedObjectList::HiddenPrefix.Length());\r\n  }\r\n  return Result;\r\n}\r\n//---------------------------------------------------------------------\r\nbool __fastcall TSessionData::HasSessionName()\r\n{\r\n  return (!GetNameWithoutHiddenPrefix().IsEmpty() && (Name != DefaultName));\r\n}\r\n//---------------------------------------------------------------------\r\nUnicodeString __fastcall TSessionData::GetSessionName()\r\n{\r\n  UnicodeString Result;\r\n  if (HasSessionName())\r\n  {\r\n    Result = GetNameWithoutHiddenPrefix();\r\n  }\r\n  else\r\n  {\r\n    Result = DefaultSessionName;\r\n  }\r\n  return Result;\r\n}\r\n//---------------------------------------------------------------------\r\nbool __fastcall TSessionData::IsSecure()\r\n{\r\n  bool Result;\r\n  switch (FSProtocol)\r\n  {\r\n    case fsSCPonly:\r\n    case fsSFTP:\r\n    case fsSFTPonly:\r\n      Result = true;\r\n      break;\r\n\r\n    case fsFTP:\r\n    case fsWebDAV:\r\n    case fsS3:\r\n      Result = (Ftps != ftpsNone);\r\n      break;\r\n\r\n    default:\r\n      DebugFail();\r\n      break;\r\n  }\r\n  return Result;\r\n}\r\n//---------------------------------------------------------------------\r\nUnicodeString __fastcall TSessionData::GetProtocolUrl(bool HttpForWebDAV)\r\n{\r\n  UnicodeString Url;\r\n  switch (FSProtocol)\r\n  {\r\n    case fsSCPonly:\r\n      Url = ScpProtocol;\r\n      break;\r\n\r\n    default:\r\n      DebugFail();\r\n      // fallback\r\n    case fsSFTP:\r\n    case fsSFTPonly:\r\n      Url = SftpProtocol;\r\n      break;\r\n\r\n    case fsFTP:\r\n      if (Ftps == ftpsImplicit)\r\n      {\r\n        Url = FtpsProtocol;\r\n      }\r\n      else if ((Ftps == ftpsExplicitTls) || (Ftps == ftpsExplicitSsl))\r\n      {\r\n        Url = FtpesProtocol;\r\n      }\r\n      else\r\n      {\r\n        Url = FtpProtocol;\r\n      }\r\n      break;\r\n\r\n    case fsWebDAV:\r\n      if (HttpForWebDAV)\r\n      {\r\n        if (Ftps == ftpsImplicit)\r\n        {\r\n          Url = HttpsProtocol;\r\n        }\r\n        else\r\n        {\r\n          Url = HttpProtocol;\r\n        }\r\n      }\r\n      else\r\n      {\r\n        if (Ftps == ftpsImplicit)\r\n        {\r\n          Url = WebDAVSProtocol;\r\n        }\r\n        else\r\n        {\r\n          Url = WebDAVProtocol;\r\n        }\r\n      }\r\n      break;\r\n\r\n    case fsS3:\r\n      Url = S3Protocol;\r\n      break;\r\n  }\r\n\r\n  Url += ProtocolSeparator;\r\n\r\n  return Url;\r\n}\r\n//---------------------------------------------------------------------\r\nbool __fastcall IsIPv6Literal(const UnicodeString & HostName)\r\n{\r\n  bool Result = (HostName.Pos(L\":\") > 0);\r\n  if (Result)\r\n  {\r\n    for (int Index = 1; Result && (Index <= HostName.Length()); Index++)\r\n    {\r\n      wchar_t C = HostName[Index];\r\n      Result = IsHex(C) || (C == L':');\r\n    }\r\n  }\r\n  return Result;\r\n}\r\n//---------------------------------------------------------------------\r\nUnicodeString __fastcall EscapeIPv6Literal(const UnicodeString & IP)\r\n{\r\n  return L\"[\" + IP + L\"]\";\r\n}\r\n//---------------------------------------------------------------------\r\nTStrings * __fastcall TSessionData::GetRawSettingsForUrl()\r\n{\r\n  std::unique_ptr<TSessionData> FactoryDefaults(new TSessionData(L\"\"));\r\n  std::unique_ptr<TSessionData> SessionData(Clone());\r\n  SessionData->FSProtocol = FactoryDefaults->FSProtocol;\r\n  SessionData->HostName = FactoryDefaults->HostName;\r\n  SessionData->PortNumber = FactoryDefaults->PortNumber;\r\n  SessionData->UserName = FactoryDefaults->UserName;\r\n  SessionData->Password = FactoryDefaults->Password;\r\n  SessionData->Ftps = FactoryDefaults->Ftps;\r\n  SessionData->HostKey = FactoryDefaults->HostKey;\r\n  SessionData->CopyNonCoreData(FactoryDefaults.get());\r\n  // Cannot be decided in SaveToOptions as it does not have HostName and UserName, so it cannot calculate DefaultSessionName.\r\n  bool SaveName = HasSessionName() && (Name != DefaultSessionName);\r\n  return SessionData->SaveToOptions(FactoryDefaults.get(), SaveName, false);\r\n}\r\n//---------------------------------------------------------------------\r\nbool __fastcall TSessionData::HasRawSettingsForUrl()\r\n{\r\n  std::unique_ptr<TStrings> RawSettings(GetRawSettingsForUrl());\r\n  return (RawSettings->Count > 0);\r\n}\r\n//---------------------------------------------------------------------\r\nUnicodeString __fastcall TSessionData::GenerateSessionUrl(unsigned int Flags)\r\n{\r\n  UnicodeString Url;\r\n\r\n  if (FLAGSET(Flags, sufSpecific))\r\n  {\r\n    Url += WinSCPProtocolPrefix;\r\n  }\r\n\r\n  Url += GetProtocolUrl(FLAGSET(Flags, sufHttpForWebDAV));\r\n\r\n  if (FLAGSET(Flags, sufUserName) && !UserNameExpanded.IsEmpty())\r\n  {\r\n    Url += EncodeUrlString(UserNameExpanded);\r\n\r\n    if (FLAGSET(Flags, sufPassword) && !Password.IsEmpty())\r\n    {\r\n      Url += L\":\" + EncodeUrlString(NormalizeString(Password));\r\n    }\r\n\r\n    if (FLAGSET(Flags, sufHostKey) && !HostKey.IsEmpty())\r\n    {\r\n      UnicodeString KeyName;\r\n      UnicodeString Fingerprint = HostKey;\r\n      NormalizeFingerprint(Fingerprint, KeyName);\r\n      UnicodeString S = Fingerprint;\r\n      if (!KeyName.IsEmpty())\r\n      {\r\n        S = KeyName + NormalizedFingerprintSeparator + S;\r\n      }\r\n      S = Base64ToUrlSafe(S); // Noop for MD5 (both in SSH host keys and TLS/SSL)\r\n      S = MD5ToUrlSafe(S); // TLS/SSL fingerprints\r\n      UnicodeString S2 = EncodeUrlString(S);\r\n      DebugAssert(S2 == S2); // There should be nothing left for encoding\r\n\r\n      Url +=\r\n        UnicodeString(UrlParamSeparator) + UrlHostKeyParamName +\r\n        UnicodeString(UrlParamValueSeparator) + S2;\r\n    }\r\n\r\n    if (FLAGSET(Flags, sufRawSettings))\r\n    {\r\n      std::unique_ptr<TStrings> RawSettings(GetRawSettingsForUrl());\r\n      for (int Index = 0; Index < RawSettings->Count; Index++)\r\n      {\r\n        Url +=\r\n          UnicodeString(UrlParamSeparator) +\r\n          UrlRawSettingsParamNamePrefix + EncodeUrlString(LowerCase(RawSettings->Names[Index])) +\r\n          UnicodeString(UrlParamValueSeparator) + EncodeUrlString(RawSettings->ValueFromIndex[Index]);\r\n      }\r\n    }\r\n\r\n    Url += L\"@\";\r\n  }\r\n\r\n  DebugAssert(!HostNameExpanded.IsEmpty());\r\n  if (IsIPv6Literal(HostNameExpanded))\r\n  {\r\n    Url += EscapeIPv6Literal(HostNameExpanded);\r\n  }\r\n  else\r\n  {\r\n    Url += EncodeUrlString(HostNameExpanded);\r\n  }\r\n\r\n  if (PortNumber != DefaultPort(FSProtocol, Ftps))\r\n  {\r\n    Url += L\":\" + IntToStr(PortNumber);\r\n  }\r\n  Url += L\"/\";\r\n\r\n  return Url;\r\n}\r\n//---------------------------------------------------------------------\r\nUnicodeString ScriptCommandOpenLink(TraceInitStr(ScriptCommandLink(L\"open\")));\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::AddSwitch(\r\n  UnicodeString & Result, const UnicodeString & Name, bool Rtf)\r\n{\r\n  Result += RtfSwitch(Name, ScriptCommandOpenLink, Rtf);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::AddSwitch(\r\n  UnicodeString & Result, const UnicodeString & Name, const UnicodeString & Value, bool Rtf)\r\n{\r\n  Result += RtfSwitch(Name, ScriptCommandOpenLink, Value, Rtf);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::AddSwitch(\r\n  UnicodeString & Result, const UnicodeString & Name, int Value, bool Rtf)\r\n{\r\n  Result += RtfSwitch(Name, ScriptCommandOpenLink, Value, Rtf);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::LookupLastFingerprint()\r\n{\r\n  UnicodeString FingerprintType;\r\n  if (IsSshProtocol(FSProtocol))\r\n  {\r\n    FingerprintType = SshFingerprintType;\r\n  }\r\n  else if (Ftps != ftpsNone)\r\n  {\r\n    FingerprintType = TlsFingerprintType;\r\n  }\r\n\r\n  if (!FingerprintType.IsEmpty())\r\n  {\r\n    HostKey = Configuration->LastFingerprint(SiteKey, FingerprintType);\r\n  }\r\n}\r\n//---------------------------------------------------------------------\r\nUnicodeString __fastcall TSessionData::GenerateOpenCommandArgs(bool Rtf)\r\n{\r\n  std::unique_ptr<TSessionData> FactoryDefaults(new TSessionData(L\"\"));\r\n  std::unique_ptr<TSessionData> SessionData(new TSessionData(L\"\"));\r\n\r\n  SessionData->Assign(this);\r\n\r\n  UnicodeString Result = SessionData->GenerateSessionUrl(sufOpen);\r\n\r\n  // Before we reset the FSProtocol\r\n  bool AUsesSsh = SessionData->UsesSsh;\r\n  // SFTP-only is not reflected by the protocol prefix, we have to use rawsettings for that\r\n  if (SessionData->FSProtocol != fsSFTPonly)\r\n  {\r\n    SessionData->FSProtocol = FactoryDefaults->FSProtocol;\r\n  }\r\n  SessionData->HostName = FactoryDefaults->HostName;\r\n  SessionData->PortNumber = FactoryDefaults->PortNumber;\r\n  SessionData->UserName = FactoryDefaults->UserName;\r\n  SessionData->Password = FactoryDefaults->Password;\r\n  SessionData->CopyNonCoreData(FactoryDefaults.get());\r\n  SessionData->Ftps = FactoryDefaults->Ftps;\r\n\r\n  if (SessionData->HostKey != FactoryDefaults->HostKey)\r\n  {\r\n    UnicodeString SwitchName = AUsesSsh ? L\"hostkey\" : L\"certificate\";\r\n    AddSwitch(Result, SwitchName, SessionData->HostKey, Rtf);\r\n    SessionData->HostKey = FactoryDefaults->HostKey;\r\n  }\r\n  if (SessionData->PublicKeyFile != FactoryDefaults->PublicKeyFile)\r\n  {\r\n    AddSwitch(Result, L\"privatekey\", SessionData->PublicKeyFile, Rtf);\r\n    SessionData->PublicKeyFile = FactoryDefaults->PublicKeyFile;\r\n  }\r\n  if (SessionData->TlsCertificateFile != FactoryDefaults->TlsCertificateFile)\r\n  {\r\n    AddSwitch(Result, L\"clientcert\", SessionData->TlsCertificateFile, Rtf);\r\n    SessionData->TlsCertificateFile = FactoryDefaults->TlsCertificateFile;\r\n  }\r\n  if (SessionData->Passphrase != FactoryDefaults->Passphrase)\r\n  {\r\n    AddSwitch(Result, PassphraseOption, SessionData->Passphrase, Rtf);\r\n    SessionData->Passphrase = FactoryDefaults->Passphrase;\r\n  }\r\n  if (SessionData->FtpPasvMode != FactoryDefaults->FtpPasvMode)\r\n  {\r\n    AddSwitch(Result, L\"passive\", SessionData->FtpPasvMode ? 1 : 0, Rtf);\r\n    SessionData->FtpPasvMode = FactoryDefaults->FtpPasvMode;\r\n  }\r\n  if (SessionData->Timeout != FactoryDefaults->Timeout)\r\n  {\r\n    AddSwitch(Result, L\"timeout\", SessionData->Timeout, Rtf);\r\n    SessionData->Timeout = FactoryDefaults->Timeout;\r\n  }\r\n\r\n  std::unique_ptr<TStrings> RawSettings(SessionData->SaveToOptions(FactoryDefaults.get(), false, false));\r\n\r\n  if (RawSettings->Count > 0)\r\n  {\r\n    AddSwitch(Result, RawSettingsOption, Rtf);\r\n\r\n    Result += StringsToParams(RawSettings.get());\r\n  }\r\n\r\n  return Result;\r\n}\r\n//---------------------------------------------------------------------\r\nUnicodeString SessionOptionsClassName(L\"SessionOptions\");\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::AddAssemblyProperty(\r\n  UnicodeString & Result, TAssemblyLanguage Language,\r\n  const UnicodeString & Name, const UnicodeString & Type,\r\n  const UnicodeString & Member)\r\n{\r\n  Result += AssemblyProperty(Language, SessionOptionsClassName, Name, Type, Member, false);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::AddAssemblyProperty(\r\n  UnicodeString & Result, TAssemblyLanguage Language,\r\n  const UnicodeString & Name, const UnicodeString & Value)\r\n{\r\n  Result += AssemblyProperty(Language, SessionOptionsClassName, Name, Value, false);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::AddAssemblyProperty(\r\n  UnicodeString & Result, TAssemblyLanguage Language,\r\n  const UnicodeString & Name, int Value)\r\n{\r\n  Result += AssemblyProperty(Language, SessionOptionsClassName, Name, Value, false);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::AddAssemblyProperty(\r\n  UnicodeString & Result, TAssemblyLanguage Language,\r\n  const UnicodeString & Name, bool Value)\r\n{\r\n  Result += AssemblyProperty(Language, SessionOptionsClassName, Name, Value, false);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::GenerateAssemblyCode(\r\n  TAssemblyLanguage Language, UnicodeString & Head, UnicodeString & Tail, int & Indent)\r\n{\r\n  std::unique_ptr<TSessionData> FactoryDefaults(new TSessionData(L\"\"));\r\n  std::unique_ptr<TSessionData> SessionData(Clone());\r\n\r\n  switch (Language)\r\n  {\r\n    case alCSharp:\r\n    case alVBNET:\r\n      // noop\r\n      break;\r\n\r\n    case alPowerShell:\r\n      Head +=\r\n        AssemblyCommentLine(Language, LoadStr(CODE_PS_ADD_TYPE)) +\r\n        RtfKeyword(L\"Add-Type\") + RtfText(\" -Path \") + AssemblyString(Language, \"WinSCPnet.dll\") + RtfPara +\r\n        RtfPara;\r\n      break;\r\n\r\n    default:\r\n      DebugFail();\r\n      break;\r\n  }\r\n\r\n  Head +=\r\n    AssemblyCommentLine(Language, LoadStr(CODE_SESSION_OPTIONS)) +\r\n    AssemblyNewClassInstanceStart(Language, SessionOptionsClassName, false);\r\n\r\n  UnicodeString ProtocolMember;\r\n  switch (SessionData->FSProtocol)\r\n  {\r\n    case fsSCPonly:\r\n      ProtocolMember = \"Scp\";\r\n      break;\r\n\r\n    default:\r\n      DebugFail();\r\n      // fallback\r\n    case fsSFTP:\r\n    case fsSFTPonly:\r\n      ProtocolMember = \"Sftp\";\r\n      break;\r\n\r\n    case fsFTP:\r\n      ProtocolMember = \"Ftp\";\r\n      break;\r\n\r\n    case fsWebDAV:\r\n      ProtocolMember = \"Webdav\";\r\n      break;\r\n\r\n    case fsS3:\r\n      ProtocolMember = \"S3\";\r\n      break;\r\n  }\r\n\r\n  // Before we reset the FSProtocol\r\n  bool AUsesSsh = SessionData->UsesSsh;\r\n\r\n  // Protocol is set unconditionally, we want even the default SFTP\r\n  AddAssemblyProperty(Head, Language, L\"Protocol\", L\"Protocol\", ProtocolMember);\r\n  // SFTP-only is not reflected by the protocol prefix, we have to use rawsettings for that\r\n  if (SessionData->FSProtocol != fsSFTPonly)\r\n  {\r\n    SessionData->FSProtocol = FactoryDefaults->FSProtocol;\r\n  }\r\n  if (SessionData->HostName != FactoryDefaults->HostName)\r\n  {\r\n    AddAssemblyProperty(Head, Language, L\"HostName\", HostName);\r\n    SessionData->HostName = FactoryDefaults->HostName;\r\n  }\r\n  int ADefaultPort = DefaultPort(FSProtocol, Ftps);\r\n  if (SessionData->PortNumber != ADefaultPort)\r\n  {\r\n    AddAssemblyProperty(Head, Language, L\"PortNumber\", PortNumber);\r\n  }\r\n  SessionData->PortNumber = FactoryDefaults->PortNumber;\r\n  if (SessionData->UserName != FactoryDefaults->UserName)\r\n  {\r\n    AddAssemblyProperty(Head, Language, L\"UserName\", UserName);\r\n    SessionData->UserName = FactoryDefaults->UserName;\r\n  }\r\n  if (SessionData->Password != FactoryDefaults->Password)\r\n  {\r\n    AddAssemblyProperty(Head, Language, L\"Password\", NormalizeString(Password));\r\n    SessionData->Password = FactoryDefaults->Password;\r\n  }\r\n\r\n  SessionData->CopyNonCoreData(FactoryDefaults.get());\r\n\r\n  if (SessionData->Ftps != FactoryDefaults->Ftps)\r\n  {\r\n    // SessionData->FSProtocol is reset already\r\n    switch (FSProtocol)\r\n    {\r\n      case fsFTP:\r\n        {\r\n          UnicodeString FtpSecureMember;\r\n          switch (SessionData->Ftps)\r\n          {\r\n            case ftpsNone:\r\n              // noop\r\n              break;\r\n\r\n            case ftpsImplicit:\r\n              FtpSecureMember = L\"Implicit\";\r\n              break;\r\n\r\n            case ftpsExplicitTls:\r\n            case ftpsExplicitSsl:\r\n              FtpSecureMember = L\"Explicit\";\r\n              break;\r\n\r\n            default:\r\n              DebugFail();\r\n              break;\r\n          }\r\n          AddAssemblyProperty(Head, Language, L\"FtpSecure\", L\"FtpSecure\", FtpSecureMember);\r\n        }\r\n        break;\r\n\r\n      case fsWebDAV:\r\n        AddAssemblyProperty(Head, Language, L\"WebdavSecure\", (SessionData->Ftps != ftpsNone));\r\n        break;\r\n\r\n      case fsS3:\r\n        // implicit\r\n        break;\r\n\r\n      default:\r\n        DebugFail();\r\n        break;\r\n    }\r\n    SessionData->Ftps = FactoryDefaults->Ftps;\r\n  }\r\n\r\n  if (SessionData->HostKey != FactoryDefaults->HostKey)\r\n  {\r\n    UnicodeString PropertyName = AUsesSsh ? L\"SshHostKeyFingerprint\" : L\"TlsHostCertificateFingerprint\";\r\n    AddAssemblyProperty(Head, Language, PropertyName, SessionData->HostKey);\r\n    SessionData->HostKey = FactoryDefaults->HostKey;\r\n  }\r\n  if (SessionData->PublicKeyFile != FactoryDefaults->PublicKeyFile)\r\n  {\r\n    AddAssemblyProperty(Head, Language, L\"SshPrivateKeyPath\", SessionData->PublicKeyFile);\r\n    SessionData->PublicKeyFile = FactoryDefaults->PublicKeyFile;\r\n  }\r\n  if (SessionData->TlsCertificateFile != FactoryDefaults->TlsCertificateFile)\r\n  {\r\n    AddAssemblyProperty(Head, Language, L\"TlsClientCertificatePath\", SessionData->TlsCertificateFile);\r\n    SessionData->TlsCertificateFile = FactoryDefaults->TlsCertificateFile;\r\n  }\r\n  if (SessionData->Passphrase != FactoryDefaults->Passphrase)\r\n  {\r\n    AddAssemblyProperty(Head, Language, L\"PrivateKeyPassphrase\", SessionData->Passphrase);\r\n    SessionData->Passphrase = FactoryDefaults->Passphrase;\r\n  }\r\n  if (SessionData->FtpPasvMode != FactoryDefaults->FtpPasvMode)\r\n  {\r\n    AddAssemblyProperty(Head, Language, L\"FtpMode\", L\"FtpMode\", (SessionData->FtpPasvMode ? L\"Passive\" : L\"Active\"));\r\n    SessionData->FtpPasvMode = FactoryDefaults->FtpPasvMode;\r\n  }\r\n  if (SessionData->Timeout != FactoryDefaults->Timeout)\r\n  {\r\n    AddAssemblyProperty(Head, Language, L\"TimeoutInMilliseconds\", SessionData->Timeout * 1000);\r\n    SessionData->Timeout = FactoryDefaults->Timeout;\r\n  }\r\n\r\n  Head += AssemblyNewClassInstanceEnd(Language, false);\r\n\r\n  std::unique_ptr<TStrings> RawSettings(SessionData->SaveToOptions(FactoryDefaults.get(), false, false));\r\n\r\n  UnicodeString SessionOptionsVariableName = AssemblyVariableName(Language, SessionOptionsClassName);\r\n\r\n  if (RawSettings->Count > 0)\r\n  {\r\n    Head +=\r\n      RtfPara +\r\n      AssemblyAddRawSettings(Language, RawSettings.get(), SessionOptionsClassName, L\"AddRawSettings\");\r\n  }\r\n\r\n  Head += RtfPara;\r\n\r\n  UnicodeString Indentation = L\"    \";\r\n  UnicodeString SessionVariableName = AssemblyVariableName(Language, SessionClassName);\r\n  UnicodeString RtfSessionClass = RtfLibraryClass(SessionClassName);\r\n  UnicodeString RtfSessionOpenMethod = RtfLibraryMethod(SessionClassName, L\"Open\", false);\r\n\r\n  UnicodeString NewSessionInstance = AssemblyNewClassInstance(Language, SessionClassName, false);\r\n  UnicodeString OpenCall =\r\n    Indentation + AssemblyCommentLine(Language, LoadStr(CODE_CONNECT)) +\r\n    Indentation + RtfText(SessionVariableName + L\".\") + RtfSessionOpenMethod + RtfText(L\"(\" + SessionOptionsVariableName + L\")\") +\r\n      AssemblyStatementSeparator(Language) + RtfPara;\r\n\r\n  switch (Language)\r\n  {\r\n    case alCSharp:\r\n      Head +=\r\n        RtfKeyword(L\"using\") + RtfText(\" (\") + NewSessionInstance + RtfText(L\"())\") + RtfPara +\r\n        RtfText(L\"{\") + RtfPara +\r\n        OpenCall;\r\n\r\n      Tail =\r\n        RtfText(L\"}\") + RtfPara;\r\n      break;\r\n\r\n    case alVBNET:\r\n      Head +=\r\n        RtfKeyword(L\"Using\") + RtfText(L\" \") + NewSessionInstance + RtfPara +\r\n        OpenCall;\r\n\r\n      Tail =\r\n        RtfKeyword(L\"End Using\") + RtfPara;\r\n      break;\r\n\r\n    case alPowerShell:\r\n      Head +=\r\n        NewSessionInstance + RtfPara +\r\n        RtfPara +\r\n        RtfKeyword(L\"try\") + RtfPara +\r\n        RtfText(L\"{\") + RtfPara +\r\n        OpenCall;\r\n\r\n      Tail =\r\n        RtfText(L\"}\") + RtfPara +\r\n        RtfKeyword(L\"finally\") + RtfPara +\r\n        RtfText(L\"{\") + RtfPara +\r\n        RtfText(Indentation + SessionVariableName + L\".\") +\r\n          RtfLibraryMethod(SessionClassName, L\"Dispose\", false) + RtfText(L\"()\") + RtfPara +\r\n        RtfText(L\"}\") + RtfPara;\r\n      break;\r\n  }\r\n\r\n  Head += RtfPara;\r\n\r\n  Indent = 4; // the same for all languages so far\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetTimeDifference(TDateTime value)\r\n{\r\n  SET_SESSION_PROPERTY(TimeDifference);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetTimeDifferenceAuto(bool value)\r\n{\r\n  SET_SESSION_PROPERTY(TimeDifferenceAuto);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetLocalDirectory(UnicodeString value)\r\n{\r\n  SET_SESSION_PROPERTY(LocalDirectory);\r\n}\r\n//---------------------------------------------------------------------\r\nUnicodeString __fastcall TSessionData::GetLocalDirectoryExpanded()\r\n{\r\n  return ExpandFileName(::ExpandEnvironmentVariables(LocalDirectory));\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetRemoteDirectory(UnicodeString value)\r\n{\r\n  SET_SESSION_PROPERTY(RemoteDirectory);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetSynchronizeBrowsing(bool value)\r\n{\r\n  SET_SESSION_PROPERTY(SynchronizeBrowsing);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetUpdateDirectories(bool value)\r\n{\r\n  SET_SESSION_PROPERTY(UpdateDirectories);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetCacheDirectories(bool value)\r\n{\r\n  SET_SESSION_PROPERTY(CacheDirectories);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetCacheDirectoryChanges(bool value)\r\n{\r\n  SET_SESSION_PROPERTY(CacheDirectoryChanges);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetPreserveDirectoryChanges(bool value)\r\n{\r\n  SET_SESSION_PROPERTY(PreserveDirectoryChanges);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetResolveSymlinks(bool value)\r\n{\r\n  SET_SESSION_PROPERTY(ResolveSymlinks);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetFollowDirectorySymlinks(bool value)\r\n{\r\n  SET_SESSION_PROPERTY(FollowDirectorySymlinks);\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetDSTMode(TDSTMode value)\r\n{\r\n  SET_SESSION_PROPERTY(DSTMode);\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetDeleteToRecycleBin(bool value)\r\n{\r\n  SET_SESSION_PROPERTY(DeleteToRecycleBin);\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetOverwrittenToRecycleBin(bool value)\r\n{\r\n  SET_SESSION_PROPERTY(OverwrittenToRecycleBin);\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetRecycleBinPath(UnicodeString value)\r\n{\r\n  SET_SESSION_PROPERTY(RecycleBinPath);\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetPostLoginCommands(UnicodeString value)\r\n{\r\n  SET_SESSION_PROPERTY(PostLoginCommands);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetLockInHome(bool value)\r\n{\r\n  SET_SESSION_PROPERTY(LockInHome);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetSpecial(bool value)\r\n{\r\n  SET_SESSION_PROPERTY(Special);\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetScp1Compatibility(bool value)\r\n{\r\n  SET_SESSION_PROPERTY(Scp1Compatibility);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetTcpNoDelay(bool value)\r\n{\r\n  SET_SESSION_PROPERTY(TcpNoDelay);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetSendBuf(int value)\r\n{\r\n  SET_SESSION_PROPERTY(SendBuf);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetSourceAddress(const UnicodeString & value)\r\n{\r\n  SET_SESSION_PROPERTY(SourceAddress);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetSshSimple(bool value)\r\n{\r\n  SET_SESSION_PROPERTY(SshSimple);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetProxyMethod(TProxyMethod value)\r\n{\r\n  SET_SESSION_PROPERTY(ProxyMethod);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetProxyHost(UnicodeString value)\r\n{\r\n  SET_SESSION_PROPERTY(ProxyHost);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetProxyPort(int value)\r\n{\r\n  SET_SESSION_PROPERTY(ProxyPort);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetProxyUsername(UnicodeString value)\r\n{\r\n  SET_SESSION_PROPERTY(ProxyUsername);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetProxyPassword(UnicodeString avalue)\r\n{\r\n  RawByteString value = EncryptPassword(avalue, ProxyUsername+ProxyHost);\r\n  SET_SESSION_PROPERTY(ProxyPassword);\r\n}\r\n//---------------------------------------------------------------------\r\nUnicodeString __fastcall TSessionData::GetProxyPassword() const\r\n{\r\n  return DecryptPassword(FProxyPassword, ProxyUsername+ProxyHost);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetProxyTelnetCommand(UnicodeString value)\r\n{\r\n  SET_SESSION_PROPERTY(ProxyTelnetCommand);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetProxyLocalCommand(UnicodeString value)\r\n{\r\n  SET_SESSION_PROPERTY(ProxyLocalCommand);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetProxyDNS(TAutoSwitch value)\r\n{\r\n  SET_SESSION_PROPERTY(ProxyDNS);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetProxyLocalhost(bool value)\r\n{\r\n  SET_SESSION_PROPERTY(ProxyLocalhost);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetFtpProxyLogonType(int value)\r\n{\r\n  SET_SESSION_PROPERTY(FtpProxyLogonType);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetBug(TSshBug Bug, TAutoSwitch value)\r\n{\r\n  DebugAssert(Bug >= 0 && static_cast<unsigned int>(Bug) < LENOF(FBugs));\r\n  SET_SESSION_PROPERTY(Bugs[Bug]);\r\n}\r\n//---------------------------------------------------------------------\r\nTAutoSwitch __fastcall TSessionData::GetBug(TSshBug Bug) const\r\n{\r\n  DebugAssert(Bug >= 0 && static_cast<unsigned int>(Bug) < LENOF(FBugs));\r\n  return FBugs[Bug];\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetPuttySettings(UnicodeString value)\r\n{\r\n  SET_SESSION_PROPERTY(PuttySettings);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetCustomParam1(UnicodeString value)\r\n{\r\n  SET_SESSION_PROPERTY(CustomParam1);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetCustomParam2(UnicodeString value)\r\n{\r\n  SET_SESSION_PROPERTY(CustomParam2);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetSFTPDownloadQueue(int value)\r\n{\r\n  SET_SESSION_PROPERTY(SFTPDownloadQueue);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetSFTPUploadQueue(int value)\r\n{\r\n  SET_SESSION_PROPERTY(SFTPUploadQueue);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetSFTPListingQueue(int value)\r\n{\r\n  SET_SESSION_PROPERTY(SFTPListingQueue);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetSFTPMaxVersion(int value)\r\n{\r\n  SET_SESSION_PROPERTY(SFTPMaxVersion);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetSFTPMaxPacketSize(unsigned long value)\r\n{\r\n  SET_SESSION_PROPERTY(SFTPMaxPacketSize);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetSFTPBug(TSftpBug Bug, TAutoSwitch value)\r\n{\r\n  DebugAssert(Bug >= 0 && static_cast<unsigned int>(Bug) < LENOF(FSFTPBugs));\r\n  SET_SESSION_PROPERTY(SFTPBugs[Bug]);\r\n}\r\n//---------------------------------------------------------------------\r\nTAutoSwitch __fastcall TSessionData::GetSFTPBug(TSftpBug Bug) const\r\n{\r\n  DebugAssert(Bug >= 0 && static_cast<unsigned int>(Bug) < LENOF(FSFTPBugs));\r\n  return FSFTPBugs[Bug];\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetSCPLsFullTime(TAutoSwitch value)\r\n{\r\n  SET_SESSION_PROPERTY(SCPLsFullTime);\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetColor(int value)\r\n{\r\n  SET_SESSION_PROPERTY(Color);\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetTunnel(bool value)\r\n{\r\n  SET_SESSION_PROPERTY(Tunnel);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetTunnelHostName(UnicodeString value)\r\n{\r\n  if (FTunnelHostName != value)\r\n  {\r\n    // HostName is key for password encryption\r\n    UnicodeString XTunnelPassword = TunnelPassword;\r\n\r\n    int P = value.LastDelimiter(L\"@\");\r\n    if (P > 0)\r\n    {\r\n      TunnelUserName = value.SubString(1, P - 1);\r\n      value = value.SubString(P + 1, value.Length() - P);\r\n    }\r\n    FTunnelHostName = value;\r\n    Modify();\r\n\r\n    TunnelPassword = XTunnelPassword;\r\n    Shred(XTunnelPassword);\r\n  }\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetTunnelPortNumber(int value)\r\n{\r\n  SET_SESSION_PROPERTY(TunnelPortNumber);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetTunnelUserName(UnicodeString value)\r\n{\r\n  // Avoid password recryption (what may popup master password prompt)\r\n  if (FTunnelUserName != value)\r\n  {\r\n    // TunnelUserName is key for password encryption\r\n    UnicodeString XTunnelPassword = TunnelPassword;\r\n    SET_SESSION_PROPERTY(TunnelUserName);\r\n    TunnelPassword = XTunnelPassword;\r\n    Shred(XTunnelPassword);\r\n  }\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetTunnelPassword(UnicodeString avalue)\r\n{\r\n  RawByteString value = EncryptPassword(avalue, TunnelUserName+TunnelHostName);\r\n  SET_SESSION_PROPERTY(TunnelPassword);\r\n}\r\n//---------------------------------------------------------------------\r\nUnicodeString __fastcall TSessionData::GetTunnelPassword() const\r\n{\r\n  return DecryptPassword(FTunnelPassword, TunnelUserName+TunnelHostName);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetTunnelPublicKeyFile(UnicodeString value)\r\n{\r\n  if (FTunnelPublicKeyFile != value)\r\n  {\r\n    // StripPathQuotes should not be needed as we do not feed quotes anymore\r\n    FTunnelPublicKeyFile = StripPathQuotes(value);\r\n    Modify();\r\n  }\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetTunnelLocalPortNumber(int value)\r\n{\r\n  SET_SESSION_PROPERTY(TunnelLocalPortNumber);\r\n}\r\n//---------------------------------------------------------------------\r\nbool __fastcall TSessionData::GetTunnelAutoassignLocalPortNumber()\r\n{\r\n  return (FTunnelLocalPortNumber <= 0);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetTunnelPortFwd(UnicodeString value)\r\n{\r\n  SET_SESSION_PROPERTY(TunnelPortFwd);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetTunnelHostKey(UnicodeString value)\r\n{\r\n  SET_SESSION_PROPERTY(TunnelHostKey);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetFtpPasvMode(bool value)\r\n{\r\n  SET_SESSION_PROPERTY(FtpPasvMode);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetFtpForcePasvIp(TAutoSwitch value)\r\n{\r\n  SET_SESSION_PROPERTY(FtpForcePasvIp);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetFtpUseMlsd(TAutoSwitch value)\r\n{\r\n  SET_SESSION_PROPERTY(FtpUseMlsd);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetFtpAccount(UnicodeString value)\r\n{\r\n  SET_SESSION_PROPERTY(FtpAccount);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetFtpPingInterval(int value)\r\n{\r\n  SET_SESSION_PROPERTY(FtpPingInterval);\r\n}\r\n//---------------------------------------------------------------------------\r\nTDateTime __fastcall TSessionData::GetFtpPingIntervalDT()\r\n{\r\n  return SecToDateTime(FtpPingInterval);\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetFtpPingType(TPingType value)\r\n{\r\n  SET_SESSION_PROPERTY(FtpPingType);\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetFtpTransferActiveImmediately(TAutoSwitch value)\r\n{\r\n  SET_SESSION_PROPERTY(FtpTransferActiveImmediately);\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetFtps(TFtps value)\r\n{\r\n  SET_SESSION_PROPERTY(Ftps);\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetMinTlsVersion(TTlsVersion value)\r\n{\r\n  SET_SESSION_PROPERTY(MinTlsVersion);\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetMaxTlsVersion(TTlsVersion value)\r\n{\r\n  SET_SESSION_PROPERTY(MaxTlsVersion);\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetLogicalHostName(UnicodeString value)\r\n{\r\n  SET_SESSION_PROPERTY(LogicalHostName);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetFtpListAll(TAutoSwitch value)\r\n{\r\n  SET_SESSION_PROPERTY(FtpListAll);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetFtpHost(TAutoSwitch value)\r\n{\r\n  SET_SESSION_PROPERTY(FtpHost);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetFtpDeleteFromCwd(TAutoSwitch value)\r\n{\r\n  SET_SESSION_PROPERTY(FtpDeleteFromCwd);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetSslSessionReuse(bool value)\r\n{\r\n  SET_SESSION_PROPERTY(SslSessionReuse);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetTlsCertificateFile(UnicodeString value)\r\n{\r\n  SET_SESSION_PROPERTY(TlsCertificateFile);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetNotUtf(TAutoSwitch value)\r\n{\r\n  SET_SESSION_PROPERTY(NotUtf);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetInternalEditorEncoding(int value)\r\n{\r\n  SET_SESSION_PROPERTY(InternalEditorEncoding);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetS3DefaultRegion(UnicodeString value)\r\n{\r\n  SET_SESSION_PROPERTY(S3DefaultRegion);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetS3UrlStyle(TS3UrlStyle value)\r\n{\r\n  SET_SESSION_PROPERTY(S3UrlStyle);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetIsWorkspace(bool value)\r\n{\r\n  SET_SESSION_PROPERTY(IsWorkspace);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetLink(UnicodeString value)\r\n{\r\n  SET_SESSION_PROPERTY(Link);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetNameOverride(UnicodeString value)\r\n{\r\n  SET_SESSION_PROPERTY(NameOverride);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetHostKey(UnicodeString value)\r\n{\r\n  SET_SESSION_PROPERTY(HostKey);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetNote(UnicodeString value)\r\n{\r\n  SET_SESSION_PROPERTY(Note);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetWinTitle(UnicodeString value)\r\n{\r\n  SET_SESSION_PROPERTY(WinTitle);\r\n}\r\n//---------------------------------------------------------------------\r\nUnicodeString __fastcall TSessionData::GetEncryptKey() const\r\n{\r\n  return DecryptPassword(FEncryptKey, UserName+HostName);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::SetEncryptKey(UnicodeString avalue)\r\n{\r\n  RawByteString value = EncryptPassword(avalue, UserName+HostName);\r\n  SET_SESSION_PROPERTY(EncryptKey);\r\n}\r\n//---------------------------------------------------------------------\r\nUnicodeString __fastcall TSessionData::GetInfoTip()\r\n{\r\n  if (UsesSsh)\r\n  {\r\n    return FMTLOAD(SESSION_INFO_TIP2,\r\n        (HostName, UserName,\r\n         (PublicKeyFile.IsEmpty() ? LoadStr(NO_STR) : LoadStr(YES_STR)),\r\n         FSProtocolStr));\r\n  }\r\n  else\r\n  {\r\n    return FMTLOAD(SESSION_INFO_TIP_NO_SSH,\r\n      (HostName, UserName, FSProtocolStr));\r\n  }\r\n}\r\n//---------------------------------------------------------------------\r\nUnicodeString __fastcall TSessionData::ExtractLocalName(const UnicodeString & Name)\r\n{\r\n  UnicodeString Result = Name;\r\n  int P = Result.LastDelimiter(L\"/\");\r\n  if (P > 0)\r\n  {\r\n    Result.Delete(1, P);\r\n  }\r\n  return Result;\r\n}\r\n//---------------------------------------------------------------------\r\nUnicodeString __fastcall TSessionData::GetLocalName()\r\n{\r\n  UnicodeString Result;\r\n  if (HasSessionName())\r\n  {\r\n    Result = ExtractLocalName(Name);\r\n  }\r\n  else\r\n  {\r\n    Result = DefaultSessionName;\r\n  }\r\n  return Result;\r\n}\r\n//---------------------------------------------------------------------\r\nUnicodeString __fastcall TSessionData::ExtractFolderName(const UnicodeString & Name)\r\n{\r\n  UnicodeString Result;\r\n  int P = Name.LastDelimiter(L\"/\");\r\n  if (P > 0)\r\n  {\r\n    Result = Name.SubString(1, P - 1);\r\n  }\r\n  return Result;\r\n}\r\n//---------------------------------------------------------------------\r\nUnicodeString __fastcall TSessionData::GetFolderName()\r\n{\r\n  UnicodeString Result;\r\n  if (HasSessionName() || IsWorkspace)\r\n  {\r\n    Result = ExtractFolderName(Name);\r\n  }\r\n  return Result;\r\n}\r\n//---------------------------------------------------------------------\r\nUnicodeString __fastcall TSessionData::ComposePath(\r\n  const UnicodeString & Path, const UnicodeString & Name)\r\n{\r\n  return UnixIncludeTrailingBackslash(Path) + Name;\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TSessionData::DisableAuthentationsExceptPassword()\r\n{\r\n  SshNoUserAuth = false;\r\n  AuthTIS = false;\r\n  AuthKI = false;\r\n  AuthKIPassword = false;\r\n  AuthGSSAPI = false;\r\n  PublicKeyFile = L\"\";\r\n  TlsCertificateFile = L\"\";\r\n  Passphrase = L\"\";\r\n  TryAgent = false;\r\n}\r\n//---------------------------------------------------------------------\r\nTStrings * TSessionData::GetAllOptionNames(bool PuttyExport)\r\n{\r\n  std::unique_ptr<TSessionData> FactoryDefaults(new TSessionData(L\"\"));\r\n  return FactoryDefaults->SaveToOptions(NULL, false, PuttyExport);\r\n}\r\n//=== TStoredSessionList ----------------------------------------------\r\n__fastcall TStoredSessionList::TStoredSessionList(bool aReadOnly):\r\n  TNamedObjectList(), FReadOnly(aReadOnly)\r\n{\r\n  DebugAssert(Configuration);\r\n  FDefaultSettings = new TSessionData(DefaultName);\r\n  FPendingRemovals.reset(new TStringList());\r\n}\r\n//---------------------------------------------------------------------\r\n__fastcall TStoredSessionList::~TStoredSessionList()\r\n{\r\n  DebugAssert(Configuration);\r\n  delete FDefaultSettings;\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TStoredSessionList::Load(THierarchicalStorage * Storage,\r\n  bool AsModified, bool UseDefaults, bool PuttyImport)\r\n{\r\n  TStringList *SubKeys = new TStringList();\r\n  TList * Loaded = new TList;\r\n  try\r\n  {\r\n    DebugAssert(AutoSort);\r\n    AutoSort = false;\r\n    bool WasEmpty = (Count == 0);\r\n\r\n    Storage->GetSubKeyNames(SubKeys);\r\n\r\n    for (int Index = 0; Index < SubKeys->Count; Index++)\r\n    {\r\n      UnicodeString SessionName = SubKeys->Strings[Index];\r\n\r\n      bool ValidName = true;\r\n      try\r\n      {\r\n        TSessionData::ValidatePath(SessionName);\r\n      }\r\n      catch(...)\r\n      {\r\n        ValidName = false;\r\n      }\r\n\r\n      if (ValidName)\r\n      {\r\n        TSessionData * SessionData;\r\n        if (SessionName == FDefaultSettings->Name)\r\n        {\r\n          SessionData = FDefaultSettings;\r\n        }\r\n        else\r\n        {\r\n          // if the list was empty before loading, do not waste time trying to\r\n          // find existing sites to overwrite (we rely on underlying storage\r\n          // to secure uniqueness of the key names)\r\n          if (WasEmpty)\r\n          {\r\n            SessionData = NULL;\r\n          }\r\n          else\r\n          {\r\n            SessionData = (TSessionData*)FindByName(SessionName);\r\n          }\r\n        }\r\n\r\n        if ((SessionData != FDefaultSettings) || !UseDefaults)\r\n        {\r\n          if (SessionData == NULL)\r\n          {\r\n            SessionData = new TSessionData(L\"\");\r\n            if (UseDefaults)\r\n            {\r\n              SessionData->CopyData(DefaultSettings);\r\n            }\r\n            SessionData->Name = SessionName;\r\n            Add(SessionData);\r\n          }\r\n          Loaded->Add(SessionData);\r\n          SessionData->Load(Storage, PuttyImport);\r\n          if (AsModified)\r\n          {\r\n            SessionData->Modified = true;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    if (!AsModified)\r\n    {\r\n      for (int Index = 0; Index < TObjectList::Count; Index++)\r\n      {\r\n        if (Loaded->IndexOf(Items[Index]) < 0)\r\n        {\r\n          Delete(Index);\r\n          Index--;\r\n        }\r\n      }\r\n    }\r\n  }\r\n  __finally\r\n  {\r\n    AutoSort = true;\r\n    AlphaSort();\r\n    delete SubKeys;\r\n    delete Loaded;\r\n  }\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TStoredSessionList::Reload()\r\n{\r\n  if (Count <= Configuration->DontReloadMoreThanSessions)\r\n  {\r\n    bool SessionList = true;\r\n    std::unique_ptr<THierarchicalStorage> Storage(Configuration->CreateScpStorage(SessionList));\r\n    if (Storage->OpenSubKey(Configuration->StoredSessionsSubKey, False))\r\n    {\r\n      Load(Storage.get());\r\n    }\r\n  }\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TStoredSessionList::DoSave(THierarchicalStorage * Storage,\r\n  TSessionData * Data, bool All, bool RecryptPasswordOnly,\r\n  TSessionData * FactoryDefaults)\r\n{\r\n  if (All || Data->Modified)\r\n  {\r\n    if (RecryptPasswordOnly)\r\n    {\r\n      Data->SaveRecryptedPasswords(Storage);\r\n    }\r\n    else\r\n    {\r\n      Data->Save(Storage, false, FactoryDefaults);\r\n    }\r\n  }\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TStoredSessionList::DoSave(THierarchicalStorage * Storage,\r\n  bool All, bool RecryptPasswordOnly, TStrings * RecryptPasswordErrors)\r\n{\r\n  TSessionData * FactoryDefaults = new TSessionData(L\"\");\r\n  try\r\n  {\r\n    while (FPendingRemovals->Count > 0)\r\n    {\r\n      TSessionData::Remove(Storage, FPendingRemovals->Strings[0]);\r\n      FPendingRemovals->Delete(0);\r\n    }\r\n\r\n    DoSave(Storage, FDefaultSettings, All, RecryptPasswordOnly, FactoryDefaults);\r\n    for (int Index = 0; Index < CountIncludingHidden; Index++)\r\n    {\r\n      TSessionData * SessionData = (TSessionData *)Items[Index];\r\n      try\r\n      {\r\n        DoSave(Storage, SessionData, All, RecryptPasswordOnly, FactoryDefaults);\r\n      }\r\n      catch (Exception & E)\r\n      {\r\n        UnicodeString Message;\r\n        if (RecryptPasswordOnly && DebugAlwaysTrue(RecryptPasswordErrors != NULL) &&\r\n            ExceptionMessage(&E, Message))\r\n        {\r\n          RecryptPasswordErrors->Add(FORMAT(\"%s: %s\", (SessionData->SessionName, Message)));\r\n        }\r\n        else\r\n        {\r\n          throw;\r\n        }\r\n      }\r\n    }\r\n  }\r\n  __finally\r\n  {\r\n    delete FactoryDefaults;\r\n  }\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TStoredSessionList::Save(THierarchicalStorage * Storage, bool All)\r\n{\r\n  DoSave(Storage, All, false, NULL);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TStoredSessionList::DoSave(bool All, bool Explicit,\r\n  bool RecryptPasswordOnly, TStrings * RecryptPasswordErrors)\r\n{\r\n  bool SessionList = true;\r\n  THierarchicalStorage * Storage = Configuration->CreateScpStorage(SessionList);\r\n  try\r\n  {\r\n    Storage->AccessMode = smReadWrite;\r\n    Storage->Explicit = Explicit;\r\n    if (Storage->OpenSubKey(Configuration->StoredSessionsSubKey, true))\r\n    {\r\n      DoSave(Storage, All, RecryptPasswordOnly, RecryptPasswordErrors);\r\n    }\r\n  }\r\n  __finally\r\n  {\r\n    delete Storage;\r\n  }\r\n\r\n  Saved();\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TStoredSessionList::Save(bool All, bool Explicit)\r\n{\r\n  DoSave(All, Explicit, false, NULL);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TStoredSessionList::RecryptPasswords(TStrings * RecryptPasswordErrors)\r\n{\r\n  DoSave(true, true, true, RecryptPasswordErrors);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TStoredSessionList::Saved()\r\n{\r\n  FDefaultSettings->Modified = false;\r\n  for (int Index = 0; Index < CountIncludingHidden; Index++)\r\n  {\r\n    ((TSessionData *)Items[Index])->Modified = false;\r\n  }\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TStoredSessionList::ImportLevelFromFilezilla(\r\n  _di_IXMLNode Node, const UnicodeString & Path, _di_IXMLNode SettingsNode)\r\n{\r\n  for (int Index = 0; Index < Node->ChildNodes->Count; Index++)\r\n  {\r\n    _di_IXMLNode ChildNode = Node->ChildNodes->Get(Index);\r\n    if (ChildNode->NodeName == L\"Server\")\r\n    {\r\n      std::unique_ptr<TSessionData> SessionData(new TSessionData(L\"\"));\r\n      SessionData->CopyData(DefaultSettings);\r\n      SessionData->ImportFromFilezilla(ChildNode, Path, SettingsNode);\r\n      Add(SessionData.release());\r\n    }\r\n    else if (ChildNode->NodeName == L\"Folder\")\r\n    {\r\n      UnicodeString Name;\r\n\r\n      for (int Index = 0; Index < ChildNode->ChildNodes->Count; Index++)\r\n      {\r\n        _di_IXMLNode PossibleTextMode = ChildNode->ChildNodes->Get(Index);\r\n        if (PossibleTextMode->NodeType == ntText)\r\n        {\r\n          UnicodeString NodeValue = PossibleTextMode->NodeValue;\r\n          AddToList(Name, NodeValue.Trim(), L\" \");\r\n        }\r\n      }\r\n\r\n      Name = TSessionData::MakeValidName(Name).Trim();\r\n\r\n      ImportLevelFromFilezilla(ChildNode, TSessionData::ComposePath(Path, Name), SettingsNode);\r\n    }\r\n  }\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TStoredSessionList::ImportFromFilezilla(\r\n  const UnicodeString FileName, const UnicodeString ConfigurationFileName)\r\n{\r\n\r\n  // not sure if the document must exists if we want to use its node\r\n  _di_IXMLDocument ConfigurationDocument;\r\n  _di_IXMLNode SettingsNode;\r\n\r\n  if (FileExists(ApiPath(ConfigurationFileName)))\r\n  {\r\n    ConfigurationDocument = interface_cast<Xmlintf::IXMLDocument>(new TXMLDocument(NULL));\r\n    ConfigurationDocument->LoadFromFile(ConfigurationFileName);\r\n    _di_IXMLNode FileZilla3Node = ConfigurationDocument->ChildNodes->FindNode(L\"FileZilla3\");\r\n    if (FileZilla3Node != NULL)\r\n    {\r\n      SettingsNode = FileZilla3Node->ChildNodes->FindNode(L\"Settings\");\r\n    }\r\n  }\r\n\r\n  const _di_IXMLDocument Document = interface_cast<Xmlintf::IXMLDocument>(new TXMLDocument(NULL));\r\n  Document->LoadFromFile(FileName);\r\n  _di_IXMLNode FileZilla3Node = Document->ChildNodes->FindNode(L\"FileZilla3\");\r\n  if (FileZilla3Node != NULL)\r\n  {\r\n    _di_IXMLNode ServersNode = FileZilla3Node->ChildNodes->FindNode(L\"Servers\");\r\n    if (ServersNode != NULL)\r\n    {\r\n      ImportLevelFromFilezilla(ServersNode, L\"\", SettingsNode);\r\n    }\r\n  }\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TStoredSessionList::ImportFromKnownHosts(TStrings * Lines)\r\n{\r\n  bool SessionList = false;\r\n  std::unique_ptr<THierarchicalStorage> HostKeyStorage(Configuration->CreateScpStorage(SessionList));\r\n  std::unique_ptr<TStrings> KeyList(new TStringList());\r\n  if (OpenHostKeysSubKey(HostKeyStorage.get(), false))\r\n  {\r\n    HostKeyStorage->GetValueNames(KeyList.get());\r\n  }\r\n  HostKeyStorage.reset(NULL);\r\n\r\n  UnicodeString FirstError;\r\n  for (int Index = 0; Index < Lines->Count; Index++)\r\n  {\r\n    try\r\n    {\r\n      UnicodeString Line = Lines->Strings[Index];\r\n      Line = Trim(Line);\r\n      if (!Line.IsEmpty() && (Line[1] != L';'))\r\n      {\r\n        int P = Pos(L' ', Line);\r\n        if (P > 0)\r\n        {\r\n          UnicodeString HostNameStr = Line.SubString(1, P - 1);\r\n          Line = Line.SubString(P + 1, Line.Length() - P);\r\n\r\n          P = Pos(L',', HostNameStr);\r\n          if (P > 0)\r\n          {\r\n            HostNameStr.SetLength(P - 1);\r\n          }\r\n          P = Pos(L':', HostNameStr);\r\n          int PortNumber = -1;\r\n          if (P > 0)\r\n          {\r\n            UnicodeString PortNumberStr = HostNameStr.SubString(P + 1, HostNameStr.Length() - P);\r\n            PortNumber = StrToInt(PortNumberStr);\r\n            HostNameStr.SetLength(P - 1);\r\n          }\r\n          if ((HostNameStr.Length() >= 2) &&\r\n              (HostNameStr[1] == L'[') && (HostNameStr[HostNameStr.Length()] == L']'))\r\n          {\r\n            HostNameStr = HostNameStr.SubString(2, HostNameStr.Length() - 2);\r\n          }\r\n\r\n          UnicodeString NameStr = HostNameStr;\r\n          if (PortNumber >= 0)\r\n          {\r\n            NameStr = FORMAT(L\"%s:%d\", (NameStr, PortNumber));\r\n          }\r\n\r\n          std::unique_ptr<TSessionData> SessionDataOwner;\r\n          TSessionData * SessionData = dynamic_cast<TSessionData *>(FindByName(NameStr));\r\n          if (SessionData == NULL)\r\n          {\r\n            SessionData = new TSessionData(L\"\");\r\n            SessionDataOwner.reset(SessionData);\r\n            SessionData->CopyData(DefaultSettings);\r\n            SessionData->Name = NameStr;\r\n            SessionData->HostName = HostNameStr;\r\n            if (PortNumber >= 0)\r\n            {\r\n              SessionData->PortNumber = PortNumber;\r\n            }\r\n          }\r\n\r\n          const struct ssh_keyalg * Algorithm;\r\n          UnicodeString Key = ParseOpenSshPubLine(Line, Algorithm);\r\n          UnicodeString KeyKey =\r\n            FORMAT(L\"%s@%d:%s\", (Algorithm->cache_id, SessionData->PortNumber, HostNameStr));\r\n          UnicodeString HostKey =\r\n            FORMAT(L\"%s:%s=%s\", (Algorithm->ssh_id, KeyKey, Key));\r\n          UnicodeString HostKeyList = SessionData->HostKey;\r\n          AddToList(HostKeyList, HostKey, L\";\");\r\n          SessionData->HostKey = HostKeyList;\r\n          // If there's at least one unknown key type for this host, select it\r\n          if (KeyList->IndexOf(KeyKey) < 0)\r\n          {\r\n            SessionData->Selected = true;\r\n          }\r\n\r\n          if (SessionDataOwner.get() != NULL)\r\n          {\r\n            Add(SessionDataOwner.release());\r\n          }\r\n        }\r\n      }\r\n    }\r\n    catch (Exception & E)\r\n    {\r\n      if (FirstError.IsEmpty())\r\n      {\r\n        FirstError = E.Message;\r\n      }\r\n    }\r\n  }\r\n\r\n  if (Count == 0)\r\n  {\r\n    UnicodeString Message = LoadStr(KNOWN_HOSTS_NO_SITES);\r\n    if (!FirstError.IsEmpty())\r\n    {\r\n      Message = FORMAT(L\"%s\\n(%s)\", (Message, FirstError));\r\n    }\r\n\r\n    throw Exception(Message);\r\n  }\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TStoredSessionList::Export(const UnicodeString FileName)\r\n{\r\n  THierarchicalStorage * Storage = TIniFileStorage::CreateFromPath(FileName);\r\n  try\r\n  {\r\n    Storage->AccessMode = smReadWrite;\r\n    if (Storage->OpenSubKey(Configuration->StoredSessionsSubKey, true))\r\n    {\r\n      Save(Storage, true);\r\n    }\r\n  }\r\n  __finally\r\n  {\r\n    delete Storage;\r\n  }\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TStoredSessionList::SelectAll(bool Select)\r\n{\r\n  for (int Index = 0; Index < Count; Index++)\r\n    Sessions[Index]->Selected = Select;\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TStoredSessionList::Import(TStoredSessionList * From,\r\n  bool OnlySelected, TList * Imported)\r\n{\r\n  for (int Index = 0; Index < From->Count; Index++)\r\n  {\r\n    if (!OnlySelected || From->Sessions[Index]->Selected)\r\n    {\r\n      TSessionData *Session = new TSessionData(L\"\");\r\n      Session->Assign(From->Sessions[Index]);\r\n      Session->Modified = true;\r\n      Session->MakeUniqueIn(this);\r\n      Add(Session);\r\n      if (Imported != NULL)\r\n      {\r\n        Imported->Add(Session);\r\n      }\r\n    }\r\n  }\r\n  // only modified, explicit\r\n  Save(false, true);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TStoredSessionList::SelectSessionsToImport\r\n  (TStoredSessionList * Dest, bool SSHOnly)\r\n{\r\n  for (int Index = 0; Index < Count; Index++)\r\n  {\r\n    Sessions[Index]->Selected =\r\n      (!SSHOnly || (Sessions[Index]->GetNormalizedPuttyProtocol() == PuttySshProtocol)) &&\r\n      !Dest->FindByName(Sessions[Index]->Name);\r\n  }\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TStoredSessionList::Cleanup()\r\n{\r\n  try\r\n  {\r\n    if (Configuration->Storage == stRegistry) Clear();\r\n    TRegistryStorage * Storage = new TRegistryStorage(Configuration->RegistryStorageKey);\r\n    try\r\n    {\r\n      Storage->AccessMode = smReadWrite;\r\n      if (Storage->OpenRootKey(False))\r\n        Storage->RecursiveDeleteSubKey(Configuration->StoredSessionsSubKey);\r\n    }\r\n    __finally\r\n    {\r\n      delete Storage;\r\n    }\r\n  }\r\n  catch (Exception &E)\r\n  {\r\n    throw ExtException(&E, LoadStr(CLEANUP_SESSIONS_ERROR));\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TStoredSessionList::UpdateStaticUsage()\r\n{\r\n  int SCP = 0;\r\n  int SFTP = 0;\r\n  int FTP = 0;\r\n  int FTPS = 0;\r\n  int WebDAV = 0;\r\n  int WebDAVS = 0;\r\n  int S3 = 0;\r\n  int Password = 0;\r\n  int Advanced = 0;\r\n  int Color = 0;\r\n  int Note = 0;\r\n  int Tunnel = 0;\r\n  bool Folders = false;\r\n  bool Workspaces = false;\r\n  std::unique_ptr<TSessionData> FactoryDefaults(new TSessionData(L\"\"));\r\n  std::unique_ptr<TStringList> DifferentAdvancedProperties(CreateSortedStringList());\r\n  for (int Index = 0; Index < Count; Index++)\r\n  {\r\n    TSessionData * Data = Sessions[Index];\r\n    if (Data->IsWorkspace)\r\n    {\r\n      Workspaces = true;\r\n    }\r\n    else\r\n    {\r\n      switch (Data->FSProtocol)\r\n      {\r\n        case fsSCPonly:\r\n          SCP++;\r\n          break;\r\n\r\n        case fsSFTP:\r\n        case fsSFTPonly:\r\n          SFTP++;\r\n          break;\r\n\r\n        case fsFTP:\r\n          if (Data->Ftps == ftpsNone)\r\n          {\r\n            FTP++;\r\n          }\r\n          else\r\n          {\r\n            FTPS++;\r\n          }\r\n          break;\r\n\r\n        case fsWebDAV:\r\n          if (Data->Ftps == ftpsNone)\r\n          {\r\n            WebDAV++;\r\n          }\r\n          else\r\n          {\r\n            WebDAVS++;\r\n          }\r\n          break;\r\n\r\n        case fsS3:\r\n          S3++;\r\n          break;\r\n      }\r\n\r\n      if (Data->HasAnySessionPassword())\r\n      {\r\n        Password++;\r\n      }\r\n\r\n      if (Data->Color != 0)\r\n      {\r\n        Color++;\r\n      }\r\n\r\n      if (!Data->Note.IsEmpty())\r\n      {\r\n        Note++;\r\n      }\r\n\r\n      // This would not work for passwords, as they are compared in their encrypted form.\r\n      // But there are no passwords set in factory defaults anyway.\r\n      if (!Data->IsSame(FactoryDefaults.get(), true, DifferentAdvancedProperties.get(), false))\r\n      {\r\n        Advanced++;\r\n      }\r\n\r\n      if (Data->Tunnel)\r\n      {\r\n        Tunnel++;\r\n      }\r\n\r\n      if (!Data->FolderName.IsEmpty())\r\n      {\r\n        Folders = true;\r\n      }\r\n    }\r\n  }\r\n\r\n  Configuration->Usage->Set(L\"StoredSessionsCountSCP\", SCP);\r\n  Configuration->Usage->Set(L\"StoredSessionsCountSFTP\", SFTP);\r\n  Configuration->Usage->Set(L\"StoredSessionsCountFTP\", FTP);\r\n  Configuration->Usage->Set(L\"StoredSessionsCountFTPS\", FTPS);\r\n  Configuration->Usage->Set(L\"StoredSessionsCountWebDAV\", WebDAV);\r\n  Configuration->Usage->Set(L\"StoredSessionsCountWebDAVS\", WebDAVS);\r\n  Configuration->Usage->Set(L\"StoredSessionsCountS3\", S3);\r\n  Configuration->Usage->Set(L\"StoredSessionsCountPassword\", Password);\r\n  Configuration->Usage->Set(L\"StoredSessionsCountColor\", Color);\r\n  Configuration->Usage->Set(L\"StoredSessionsCountNote\", Note);\r\n  Configuration->Usage->Set(L\"StoredSessionsCountAdvanced\", Advanced);\r\n  DifferentAdvancedProperties->Delimiter = L',';\r\n  Configuration->Usage->Set(L\"StoredSessionsAdvancedSettings\", DifferentAdvancedProperties->DelimitedText);\r\n  Configuration->Usage->Set(L\"StoredSessionsCountTunnel\", Tunnel);\r\n\r\n  // actually default might be true, see below for when the default is actually used\r\n  bool CustomDefaultStoredSession = false;\r\n  try\r\n  {\r\n    // this can throw, when the default session settings have password set\r\n    // (and no other basic property, like hostname/username),\r\n    // and master password is enabled as we are called before master password\r\n    // handler is set\r\n    CustomDefaultStoredSession = !FDefaultSettings->IsSame(FactoryDefaults.get(), false);\r\n  }\r\n  catch (...)\r\n  {\r\n  }\r\n  Configuration->Usage->Set(L\"UsingDefaultStoredSession\", CustomDefaultStoredSession);\r\n\r\n  Configuration->Usage->Set(L\"UsingStoredSessionsFolders\", Folders);\r\n  Configuration->Usage->Set(L\"UsingWorkspaces\", Workspaces);\r\n}\r\n//---------------------------------------------------------------------------\r\nTSessionData * __fastcall TStoredSessionList::FindSame(TSessionData * Data)\r\n{\r\n  TSessionData * Result;\r\n  if (Data->Hidden || Data->Name.IsEmpty() || Data->IsWorkspace)\r\n  {\r\n    Result = NULL;\r\n  }\r\n  else\r\n  {\r\n    Result = dynamic_cast<TSessionData *>(FindByName(Data->Name));\r\n  }\r\n  return Result;\r\n}\r\n//---------------------------------------------------------------------------\r\nint __fastcall TStoredSessionList::IndexOf(TSessionData * Data)\r\n{\r\n  for (int Index = 0; Index < Count; Index++)\r\n    if (Data == Sessions[Index]) return Index;\r\n  return -1;\r\n}\r\n//---------------------------------------------------------------------------\r\nTSessionData * __fastcall TStoredSessionList::NewSession(\r\n  UnicodeString SessionName, TSessionData * Session)\r\n{\r\n  TSessionData * DuplicateSession = (TSessionData*)FindByName(SessionName);\r\n  if (!DuplicateSession)\r\n  {\r\n    DuplicateSession = new TSessionData(L\"\");\r\n    DuplicateSession->Assign(Session);\r\n    DuplicateSession->Name = SessionName;\r\n    // make sure, that new stored session is saved to registry\r\n    DuplicateSession->Modified = true;\r\n    Add(DuplicateSession);\r\n  }\r\n  else\r\n  {\r\n    DuplicateSession->Assign(Session);\r\n    DuplicateSession->Name = SessionName;\r\n    DuplicateSession->Modified = true;\r\n  }\r\n  // list was saved here before to default storage, but it would not allow\r\n  // to work with special lists (export/import) not using default storage\r\n  return DuplicateSession;\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TStoredSessionList::SetDefaultSettings(TSessionData * value)\r\n{\r\n  DebugAssert(FDefaultSettings);\r\n  if (FDefaultSettings != value)\r\n  {\r\n    FDefaultSettings->Assign(value);\r\n    // make sure default settings are saved\r\n    FDefaultSettings->Modified = true;\r\n    FDefaultSettings->Name = DefaultName;\r\n    if (!FReadOnly)\r\n    {\r\n      // only modified, explicit\r\n      Save(false, true);\r\n    }\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\nbool __fastcall TStoredSessionList::OpenHostKeysSubKey(THierarchicalStorage * Storage, bool CanCreate)\r\n{\r\n  return\r\n    Storage->OpenRootKey(CanCreate) &&\r\n    Storage->OpenSubKey(Configuration->SshHostKeysSubKey, CanCreate);\r\n}\r\n//---------------------------------------------------------------------------\r\nTHierarchicalStorage * __fastcall TStoredSessionList::CreateHostKeysStorageForWritting()\r\n{\r\n  bool SessionList = false;\r\n  std::unique_ptr<THierarchicalStorage> Storage(Configuration->CreateScpStorage(SessionList));\r\n  Storage->Explicit = true;\r\n  Storage->AccessMode = smReadWrite;\r\n  return Storage.release();\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TStoredSessionList::ImportHostKeys(\r\n  THierarchicalStorage * SourceStorage, THierarchicalStorage * TargetStorage, TStoredSessionList * Sessions, bool OnlySelected)\r\n{\r\n  if (OpenHostKeysSubKey(SourceStorage, false) &&\r\n      OpenHostKeysSubKey(TargetStorage, true))\r\n  {\r\n    std::auto_ptr<TStringList> KeyList(new TStringList());\r\n    SourceStorage->GetValueNames(KeyList.get());\r\n\r\n    DebugAssert(Sessions != NULL);\r\n    for (int Index = 0; Index < Sessions->Count; Index++)\r\n    {\r\n      TSessionData * Session = Sessions->Sessions[Index];\r\n      if (!OnlySelected || Session->Selected)\r\n      {\r\n        UnicodeString HostKeyName = PuttyMungeStr(FORMAT(L\"@%d:%s\", (Session->PortNumber, Session->HostNameExpanded)));\r\n        for (int KeyIndex = 0; KeyIndex < KeyList->Count; KeyIndex++)\r\n        {\r\n          UnicodeString KeyName = KeyList->Strings[KeyIndex];\r\n          if (EndsText(HostKeyName, KeyName))\r\n          {\r\n            TargetStorage->WriteStringRaw(KeyName, SourceStorage->ReadStringRaw(KeyName, L\"\"));\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TStoredSessionList::ImportHostKeys(\r\n  const UnicodeString & SourceKey, TStoredSessionList * Sessions, bool OnlySelected)\r\n{\r\n  std::auto_ptr<THierarchicalStorage> TargetStorage(CreateHostKeysStorageForWritting());\r\n  std::auto_ptr<THierarchicalStorage> SourceStorage(new TRegistryStorage(SourceKey));\r\n\r\n  ImportHostKeys(SourceStorage.get(), TargetStorage.get(), Sessions, OnlySelected);\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TStoredSessionList::ImportSelectedKnownHosts(TStoredSessionList * Sessions)\r\n{\r\n  std::unique_ptr<THierarchicalStorage> Storage(CreateHostKeysStorageForWritting());\r\n  if (OpenHostKeysSubKey(Storage.get(), true))\r\n  {\r\n    for (int Index = 0; Index < Sessions->Count; Index++)\r\n    {\r\n      TSessionData * Session = Sessions->Sessions[Index];\r\n      if (Session->Selected)\r\n      {\r\n        UnicodeString Algs;\r\n        UnicodeString HostKeys = Session->HostKey;\r\n        while (!HostKeys.IsEmpty())\r\n        {\r\n          UnicodeString HostKey = CutToChar(HostKeys, L';', true);\r\n          // skip alg\r\n          CutToChar(HostKey, L':', true);\r\n          UnicodeString Key = CutToChar(HostKey, L'=', true);\r\n          Storage->WriteStringRaw(Key, HostKey);\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\nbool __fastcall TStoredSessionList::IsFolderOrWorkspace(\r\n  const UnicodeString & Name, bool Workspace)\r\n{\r\n  bool Result = false;\r\n  TSessionData * FirstData = NULL;\r\n  if (!Name.IsEmpty())\r\n  {\r\n    for (int Index = 0; !Result && (Index < Count); Index++)\r\n    {\r\n      Result = Sessions[Index]->IsInFolderOrWorkspace(Name);\r\n      if (Result)\r\n      {\r\n        FirstData = Sessions[Index];\r\n      }\r\n    }\r\n  }\r\n\r\n  return\r\n    Result &&\r\n    DebugAlwaysTrue(FirstData != NULL) &&\r\n    (FirstData->IsWorkspace == Workspace);\r\n}\r\n//---------------------------------------------------------------------------\r\nbool __fastcall TStoredSessionList::IsFolder(const UnicodeString & Name)\r\n{\r\n  return IsFolderOrWorkspace(Name, false);\r\n}\r\n//---------------------------------------------------------------------------\r\nbool __fastcall TStoredSessionList::IsWorkspace(const UnicodeString & Name)\r\n{\r\n  return IsFolderOrWorkspace(Name, true);\r\n}\r\n//---------------------------------------------------------------------------\r\nTSessionData * __fastcall TStoredSessionList::CheckIsInFolderOrWorkspaceAndResolve(\r\n  TSessionData * Data, const UnicodeString & Name)\r\n{\r\n  if (Data->IsInFolderOrWorkspace(Name))\r\n  {\r\n    Data = ResolveWorkspaceData(Data);\r\n\r\n    if ((Data != NULL) && Data->CanLogin &&\r\n        DebugAlwaysTrue(Data->Link.IsEmpty()))\r\n    {\r\n      return Data;\r\n    }\r\n  }\r\n  return NULL;\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TStoredSessionList::GetFolderOrWorkspace(const UnicodeString & Name, TList * List)\r\n{\r\n  DoGetFolderOrWorkspace(Name, List, false);\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TStoredSessionList::DoGetFolderOrWorkspace(const UnicodeString & Name, TList * List, bool NoRecrypt)\r\n{\r\n  for (int Index = 0; (Index < Count); Index++)\r\n  {\r\n    TSessionData * RawData = Sessions[Index];\r\n    TSessionData * Data =\r\n      CheckIsInFolderOrWorkspaceAndResolve(RawData, Name);\r\n\r\n    if (Data != NULL)\r\n    {\r\n      TSessionData * Data2 = new TSessionData(L\"\");\r\n      if (NoRecrypt)\r\n      {\r\n        Data2->CopyDataNoRecrypt(Data);\r\n      }\r\n      else\r\n      {\r\n        Data2->Assign(Data);\r\n      }\r\n\r\n      if (!RawData->Link.IsEmpty() && (DebugAlwaysTrue(Data != RawData)) &&\r\n          // BACKWARD COMPATIBILITY\r\n          // When loading pre-5.6.4 workspace, that does not have state saved,\r\n          // do not overwrite the site \"state\" defaults\r\n          // with (empty) workspace state\r\n          RawData->HasStateData())\r\n      {\r\n        Data2->CopyStateData(RawData);\r\n      }\r\n\r\n      if (!RawData->NameOverride.IsEmpty())\r\n      {\r\n        Data2->Name = RawData->NameOverride;\r\n      }\r\n      else if (RawData->Link.IsEmpty() && RawData->IsWorkspace)\r\n      {\r\n        // Newly opened ad-hoc session has no name, so restore the workspace that way too.\r\n        // Otherwise we would persist the generated internal workspace name as a real name.\r\n        Data2->Name = UnicodeString();\r\n      }\r\n\r\n      List->Add(Data2);\r\n    }\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\nTStrings * __fastcall TStoredSessionList::GetFolderOrWorkspaceList(\r\n  const UnicodeString & Name)\r\n{\r\n  std::unique_ptr<TObjectList> DataList(new TObjectList());\r\n  DoGetFolderOrWorkspace(Name, DataList.get(), true);\r\n\r\n  std::unique_ptr<TStringList> Result(new TStringList());\r\n  for (int Index = 0; (Index < DataList->Count); Index++)\r\n  {\r\n    Result->Add(dynamic_cast<TSessionData *>(DataList->Items[Index])->SessionName);\r\n  }\r\n\r\n  return Result.release();\r\n}\r\n//---------------------------------------------------------------------------\r\nTStrings * __fastcall TStoredSessionList::GetWorkspaces()\r\n{\r\n  std::unique_ptr<TStringList> Result(CreateSortedStringList());\r\n\r\n  for (int Index = 0; (Index < Count); Index++)\r\n  {\r\n    TSessionData * Data = Sessions[Index];\r\n    if (Data->IsWorkspace)\r\n    {\r\n      Result->Add(Data->FolderName);\r\n    }\r\n  }\r\n\r\n  return Result.release();\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TStoredSessionList::NewWorkspace(\r\n  UnicodeString Name, TList * DataList)\r\n{\r\n  for (int Index = 0; (Index < Count); Index++)\r\n  {\r\n    TSessionData * Data = Sessions[Index];\r\n    if (Data->IsInFolderOrWorkspace(Name))\r\n    {\r\n      FPendingRemovals->Add(Data->Name);\r\n      Remove(Data);\r\n      Index--;\r\n    }\r\n  }\r\n\r\n  for (int Index = 0; (Index < DataList->Count); Index++)\r\n  {\r\n    TSessionData * Data = static_cast<TSessionData *>(DataList->Items[Index]);\r\n\r\n    TSessionData * Data2 = new TSessionData(L\"\");\r\n    Data2->Assign(Data);\r\n    Data2->Name = TSessionData::ComposePath(Name, Data->Name);\r\n    // make sure, that new stored session is saved to registry\r\n    Data2->Modified = true;\r\n    Add(Data2);\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\nbool __fastcall TStoredSessionList::HasAnyWorkspace()\r\n{\r\n  bool Result = false;\r\n  for (int Index = 0; !Result && (Index < Count); Index++)\r\n  {\r\n    TSessionData * Data = Sessions[Index];\r\n    Result = Data->IsWorkspace;\r\n  }\r\n  return Result;\r\n}\r\n//---------------------------------------------------------------------------\r\nTSessionData * __fastcall TStoredSessionList::ParseUrl(UnicodeString Url,\r\n  TOptions * Options, bool & DefaultsOnly, UnicodeString * FileName,\r\n  bool * AProtocolDefined, UnicodeString * MaskedUrl, int Flags)\r\n{\r\n  TSessionData * Data = new TSessionData(L\"\");\r\n  try\r\n  {\r\n    Data->ParseUrl(Url, Options, this, DefaultsOnly, FileName, AProtocolDefined, MaskedUrl, Flags);\r\n  }\r\n  catch(...)\r\n  {\r\n    delete Data;\r\n    throw;\r\n  }\r\n\r\n  return Data;\r\n}\r\n//---------------------------------------------------------------------\r\nbool __fastcall TStoredSessionList::IsUrl(UnicodeString Url)\r\n{\r\n  bool DefaultsOnly;\r\n  bool ProtocolDefined = false;\r\n  std::unique_ptr<TSessionData> ParsedData(ParseUrl(Url, NULL, DefaultsOnly, NULL, &ProtocolDefined));\r\n  bool Result = ProtocolDefined;\r\n  return Result;\r\n}\r\n//---------------------------------------------------------------------\r\nTSessionData * __fastcall TStoredSessionList::ResolveWorkspaceData(TSessionData * Data)\r\n{\r\n  if (!Data->Link.IsEmpty())\r\n  {\r\n    Data = dynamic_cast<TSessionData *>(FindByName(Data->Link));\r\n    if (Data != NULL)\r\n    {\r\n      Data = ResolveWorkspaceData(Data);\r\n    }\r\n  }\r\n  return Data;\r\n}\r\n//---------------------------------------------------------------------\r\nTSessionData * __fastcall TStoredSessionList::SaveWorkspaceData(TSessionData * Data, int Index)\r\n{\r\n  std::unique_ptr<TSessionData> Result(new TSessionData(L\"\"));\r\n\r\n  TSessionData * SameData = StoredSessions->FindSame(Data);\r\n  if (SameData != NULL)\r\n  {\r\n    Result->CopyStateData(Data);\r\n    Result->Link = Data->Name;\r\n  }\r\n  else\r\n  {\r\n    Result->Assign(Data);\r\n    Result->NameOverride = Data->Name;\r\n  }\r\n\r\n  Result->IsWorkspace = true;\r\n  Result->Name = IntToHex(Index, 4); // See HasSessionName()\r\n\r\n  return Result.release();\r\n}\r\n//---------------------------------------------------------------------\r\nbool __fastcall TStoredSessionList::CanLogin(TSessionData * Data)\r\n{\r\n  Data = ResolveWorkspaceData(Data);\r\n  return (Data != NULL) && Data->CanLogin;\r\n}\r\n//---------------------------------------------------------------------\r\nUnicodeString GetExpandedLogFileName(UnicodeString LogFileName, TDateTime Started, TSessionData * SessionData)\r\n{\r\n  // StripPathQuotes should not be needed as we do not feed quotes anymore\r\n  UnicodeString ANewFileName = StripPathQuotes(ExpandEnvironmentVariables(LogFileName));\r\n  for (int Index = 1; Index < ANewFileName.Length(); Index++)\r\n  {\r\n    if (ANewFileName[Index] == L'!')\r\n    {\r\n      UnicodeString Replacement;\r\n      // keep consistent with TFileCustomCommand::PatternReplacement\r\n      switch (tolower(ANewFileName[Index + 1]))\r\n      {\r\n        case L'y':\r\n          Replacement = FormatDateTime(L\"yyyy\", Started);\r\n          break;\r\n\r\n        case L'm':\r\n          Replacement = FormatDateTime(L\"mm\", Started);\r\n          break;\r\n\r\n        case L'd':\r\n          Replacement = FormatDateTime(L\"dd\", Started);\r\n          break;\r\n\r\n        case L't':\r\n          Replacement = FormatDateTime(L\"hhnnss\", Started);\r\n          break;\r\n\r\n        case 'p':\r\n          Replacement = IntToStr(static_cast<int>(GetCurrentProcessId()));\r\n          break;\r\n\r\n        case L'@':\r\n          if (SessionData != NULL)\r\n          {\r\n            Replacement = MakeValidFileName(SessionData->HostNameExpanded);\r\n          }\r\n          else\r\n          {\r\n            Replacement = L\"nohost\";\r\n          }\r\n          break;\r\n\r\n        case L's':\r\n          if (SessionData != NULL)\r\n          {\r\n            Replacement = MakeValidFileName(SessionData->SessionName);\r\n          }\r\n          else\r\n          {\r\n            Replacement = L\"nosession\";\r\n          }\r\n          break;\r\n\r\n        case L'!':\r\n          Replacement = L\"!\";\r\n          break;\r\n\r\n        default:\r\n          Replacement = UnicodeString(L\"!\") + ANewFileName[Index + 1];\r\n          break;\r\n      }\r\n      ANewFileName.Delete(Index, 2);\r\n      ANewFileName.Insert(Replacement, Index);\r\n      Index += Replacement.Length() - 1;\r\n    }\r\n  }\r\n  return ANewFileName;\r\n}\r\n//---------------------------------------------------------------------\r\nbool __fastcall IsSshProtocol(TFSProtocol FSProtocol)\r\n{\r\n  return\r\n    (FSProtocol == fsSFTPonly) || (FSProtocol == fsSFTP) ||\r\n    (FSProtocol == fsSCPonly);\r\n}\r\n//---------------------------------------------------------------------------\r\nint __fastcall DefaultPort(TFSProtocol FSProtocol, TFtps Ftps)\r\n{\r\n  int Result;\r\n  switch (FSProtocol)\r\n  {\r\n    case fsFTP:\r\n      if (Ftps == ftpsImplicit)\r\n      {\r\n        Result = FtpsImplicitPortNumber;\r\n      }\r\n      else\r\n      {\r\n        Result = FtpPortNumber;\r\n      }\r\n      break;\r\n\r\n    case fsWebDAV:\r\n    case fsS3:\r\n      if (Ftps == ftpsNone)\r\n      {\r\n        Result = HTTPPortNumber;\r\n      }\r\n      else\r\n      {\r\n        Result = HTTPSPortNumber;\r\n      }\r\n      break;\r\n\r\n    default:\r\n      if (IsSshProtocol(FSProtocol))\r\n      {\r\n        Result = SshPortNumber;\r\n      }\r\n      else\r\n      {\r\n        DebugFail();\r\n        Result = -1;\r\n      }\r\n      break;\r\n  }\r\n  return Result;\r\n}\r\n//---------------------------------------------------------------------\r\n", "//---------------------------------------------------------------------------\r\n#ifndef SessionDataH\r\n#define SessionDataH\r\n\r\n#include \"Common.h\"\r\n#include \"Option.h\"\r\n#include \"FileBuffer.h\"\r\n#include \"NamedObjs.h\"\r\n#include \"HierarchicalStorage.h\"\r\n#include \"Configuration.h\"\r\n#include <Xml.XMLIntf.hpp>\r\n//---------------------------------------------------------------------------\r\nenum TCipher { cipWarn, cip3DES, cipBlowfish, cipAES, cipDES, cipArcfour, cipChaCha20 };\r\n#define CIPHER_COUNT (cipChaCha20+1)\r\n// explicit values to skip obsoleted fsExternalSSH, fsExternalSFTP\r\nenum TFSProtocol { fsSCPonly = 0, fsSFTP = 1, fsSFTPonly = 2, fsFTP = 5, fsWebDAV = 6, fsS3 = 7 };\r\n#define FSPROTOCOL_COUNT (fsS3+1)\r\nextern const wchar_t * ProxyMethodNames;\r\nenum TProxyMethod { pmNone, pmSocks4, pmSocks5, pmHTTP, pmTelnet, pmCmd };\r\nenum TSshProt { ssh1only, ssh1deprecated, ssh2deprecated, ssh2only };\r\nenum TKex { kexWarn, kexDHGroup1, kexDHGroup14, kexDHGEx, kexRSA, kexECDH };\r\n#define KEX_COUNT (kexECDH+1)\r\nenum THostKey { hkWarn, hkRSA, hkDSA, hkECDSA, hkED25519, hkMax };\r\n#define HOSTKEY_COUNT (hkMax)\r\nenum TGssLib { gssGssApi32, gssSspi, gssCustom };\r\n#define GSSLIB_COUNT (gssCustom+1)\r\n// names have to match PuTTY registry entries (see settings.c)\r\nenum TSshBug { sbIgnore1, sbPlainPW1, sbRSA1, sbHMAC2, sbDeriveKey2, sbRSAPad2,\r\n  sbPKSessID2, sbRekey2, sbMaxPkt2, sbIgnore2, sbOldGex2, sbWinAdj, sbChanReq };\r\n#define BUG_COUNT (sbChanReq+1)\r\nenum TSftpBug { sbSymlink, sbSignedTS };\r\n#define SFTP_BUG_COUNT (sbSignedTS+1)\r\nextern const wchar_t * PingTypeNames;\r\nenum TPingType { ptOff, ptNullPacket, ptDummyCommand };\r\nenum TAddressFamily { afAuto, afIPv4, afIPv6 };\r\nenum TFtps { ftpsNone, ftpsImplicit, ftpsExplicitSsl, ftpsExplicitTls };\r\n// has to match SSL_VERSION_XXX constants in AsyncSslSocketLayer.h\r\n// ssl2 has no effect now\r\nenum TTlsVersion { ssl2 = 2, ssl3 = 3, tls10 = 10, tls11 = 11, tls12 = 12, tls13 = 13 };\r\n// has to match libs3 S3UriStyle\r\nenum TS3UrlStyle { s3usVirtualHost, s3usPath };\r\nenum TSessionSource { ssNone, ssStored, ssStoredModified };\r\nenum TSessionUrlFlags\r\n{\r\n  sufSpecific = 0x01,\r\n  sufUserName = 0x02,\r\n  sufPassword = 0x04,\r\n  sufHostKey = 0x08,\r\n  sufRawSettings = 0x10,\r\n  sufHttpForWebDAV = 0x20,\r\n  sufSession = sufUserName | sufPassword | sufHostKey,\r\n  sufComplete = sufSession | sufRawSettings,\r\n  sufOpen = sufUserName | sufPassword\r\n};\r\nenum TParseUrlFlags\r\n{\r\n  pufAllowStoredSiteWithProtocol = 0x01,\r\n  pufUnsafe = 0x02,\r\n};\r\n//---------------------------------------------------------------------------\r\nextern const UnicodeString CipherNames[CIPHER_COUNT];\r\nextern const UnicodeString KexNames[KEX_COUNT];\r\nextern const UnicodeString HostKeyNames[HOSTKEY_COUNT];\r\nextern const UnicodeString GssLibNames[GSSLIB_COUNT];\r\nextern const wchar_t SshProtList[][10];\r\nextern const TCipher DefaultCipherList[CIPHER_COUNT];\r\nextern const TKex DefaultKexList[KEX_COUNT];\r\nextern const THostKey DefaultHostKeyList[HOSTKEY_COUNT];\r\nextern const TGssLib DefaultGssLibList[GSSLIB_COUNT];\r\nextern const wchar_t FSProtocolNames[FSPROTOCOL_COUNT][16];\r\nextern const int DefaultSendBuf;\r\nextern const UnicodeString AnonymousUserName;\r\nextern const UnicodeString AnonymousPassword;\r\nextern const int SshPortNumber;\r\nextern const int FtpPortNumber;\r\nextern const int FtpsImplicitPortNumber;\r\nextern const int HTTPPortNumber;\r\nextern const int HTTPSPortNumber;\r\nextern const int TelnetPortNumber;\r\nextern const int ProxyPortNumber;\r\nextern const UnicodeString PuttySshProtocol;\r\nextern const UnicodeString PuttyTelnetProtocol;\r\nextern const UnicodeString SftpProtocol;\r\nextern const UnicodeString ScpProtocol;\r\nextern const UnicodeString FtpProtocol;\r\nextern const UnicodeString FtpsProtocol;\r\nextern const UnicodeString FtpesProtocol;\r\nextern const UnicodeString WebDAVProtocol;\r\nextern const UnicodeString WebDAVSProtocol;\r\nextern const UnicodeString S3Protocol;\r\nextern const UnicodeString SshProtocol;\r\nextern const UnicodeString WinSCPProtocolPrefix;\r\nextern const wchar_t UrlParamSeparator;\r\nextern const wchar_t UrlParamValueSeparator;\r\nextern const UnicodeString UrlHostKeyParamName;\r\nextern const UnicodeString UrlSaveParamName;\r\nextern const UnicodeString PassphraseOption;\r\nextern const UnicodeString S3HostName;\r\n//---------------------------------------------------------------------------\r\nclass TStoredSessionList;\r\n//---------------------------------------------------------------------------\r\nclass TSessionData : public TNamedObject\r\n{\r\nfriend class TStoredSessionList;\r\n\r\nprivate:\r\n  UnicodeString FHostName;\r\n  int FPortNumber;\r\n  UnicodeString FUserName;\r\n  RawByteString FPassword;\r\n  RawByteString FNewPassword;\r\n  bool FChangePassword;\r\n  int FPingInterval;\r\n  TPingType FPingType;\r\n  bool FTryAgent;\r\n  bool FAgentFwd;\r\n  UnicodeString FListingCommand;\r\n  bool FAuthTIS;\r\n  bool FAuthKI;\r\n  bool FAuthKIPassword;\r\n  bool FAuthGSSAPI;\r\n  bool FGSSAPIFwdTGT;\r\n  bool FChangeUsername;\r\n  bool FCompression;\r\n  TSshProt FSshProt;\r\n  bool FSsh2DES;\r\n  bool FSshNoUserAuth;\r\n  TCipher FCiphers[CIPHER_COUNT];\r\n  TKex FKex[KEX_COUNT];\r\n  THostKey FHostKeys[HOSTKEY_COUNT];\r\n  TGssLib FGssLib[GSSLIB_COUNT];\r\n  UnicodeString FGssLibCustom;\r\n  bool FClearAliases;\r\n  TEOLType FEOLType;\r\n  bool FTrimVMSVersions;\r\n  UnicodeString FPublicKeyFile;\r\n  UnicodeString FPassphrase;\r\n  UnicodeString FPuttyProtocol;\r\n  TFSProtocol FFSProtocol;\r\n  bool FModified;\r\n  UnicodeString FLocalDirectory;\r\n  UnicodeString FRemoteDirectory;\r\n  bool FLockInHome;\r\n  bool FSpecial;\r\n  bool FSynchronizeBrowsing;\r\n  bool FUpdateDirectories;\r\n  bool FCacheDirectories;\r\n  bool FCacheDirectoryChanges;\r\n  bool FPreserveDirectoryChanges;\r\n  bool FSelected;\r\n  TAutoSwitch FLookupUserGroups;\r\n  UnicodeString FReturnVar;\r\n  bool FExitCode1IsError;\r\n  bool FScp1Compatibility;\r\n  UnicodeString FShell;\r\n  UnicodeString FSftpServer;\r\n  int FTimeout;\r\n  bool FUnsetNationalVars;\r\n  bool FIgnoreLsWarnings;\r\n  bool FTcpNoDelay;\r\n  int FSendBuf;\r\n  UnicodeString FSourceAddress;\r\n  bool FSshSimple;\r\n  TProxyMethod FProxyMethod;\r\n  UnicodeString FProxyHost;\r\n  int FProxyPort;\r\n  UnicodeString FProxyUsername;\r\n  RawByteString FProxyPassword;\r\n  UnicodeString FProxyTelnetCommand;\r\n  UnicodeString FProxyLocalCommand;\r\n  TAutoSwitch FProxyDNS;\r\n  bool FProxyLocalhost;\r\n  int FFtpProxyLogonType;\r\n  TAutoSwitch FBugs[BUG_COUNT];\r\n  UnicodeString FPuttySettings;\r\n  UnicodeString FCustomParam1;\r\n  UnicodeString FCustomParam2;\r\n  bool FResolveSymlinks;\r\n  bool FFollowDirectorySymlinks;\r\n  TDateTime FTimeDifference;\r\n  bool FTimeDifferenceAuto;\r\n  int FSFTPDownloadQueue;\r\n  int FSFTPUploadQueue;\r\n  int FSFTPListingQueue;\r\n  int FSFTPMaxVersion;\r\n  unsigned long FSFTPMaxPacketSize;\r\n  TDSTMode FDSTMode;\r\n  TAutoSwitch FSFTPBugs[SFTP_BUG_COUNT];\r\n  bool FDeleteToRecycleBin;\r\n  bool FOverwrittenToRecycleBin;\r\n  UnicodeString FRecycleBinPath;\r\n  UnicodeString FPostLoginCommands;\r\n  TAutoSwitch FSCPLsFullTime;\r\n  TAutoSwitch FFtpListAll;\r\n  TAutoSwitch FFtpHost;\r\n  TAutoSwitch FFtpDeleteFromCwd;\r\n  bool FSslSessionReuse;\r\n  UnicodeString FTlsCertificateFile;\r\n  TAddressFamily FAddressFamily;\r\n  UnicodeString FRekeyData;\r\n  unsigned int FRekeyTime;\r\n  int FColor;\r\n  bool FTunnel;\r\n  UnicodeString FTunnelHostName;\r\n  int FTunnelPortNumber;\r\n  UnicodeString FTunnelUserName;\r\n  RawByteString FTunnelPassword;\r\n  UnicodeString FTunnelPublicKeyFile;\r\n  int FTunnelLocalPortNumber;\r\n  UnicodeString FTunnelPortFwd;\r\n  UnicodeString FTunnelHostKey;\r\n  bool FFtpPasvMode;\r\n  TAutoSwitch FFtpForcePasvIp;\r\n  TAutoSwitch FFtpUseMlsd;\r\n  UnicodeString FFtpAccount;\r\n  int FFtpPingInterval;\r\n  TPingType FFtpPingType;\r\n  TAutoSwitch FFtpTransferActiveImmediately;\r\n  TFtps FFtps;\r\n  TTlsVersion FMinTlsVersion;\r\n  TTlsVersion FMaxTlsVersion;\r\n  TAutoSwitch FNotUtf;\r\n  int FInternalEditorEncoding;\r\n  UnicodeString FS3DefaultRegion;\r\n  TS3UrlStyle FS3UrlStyle;\r\n  bool FIsWorkspace;\r\n  UnicodeString FLink;\r\n  UnicodeString FNameOverride;\r\n  UnicodeString FHostKey;\r\n  bool FFingerprintScan;\r\n  bool FOverrideCachedHostKey;\r\n  UnicodeString FNote;\r\n  UnicodeString FWinTitle;\r\n  RawByteString FEncryptKey;\r\n\r\n  UnicodeString FOrigHostName;\r\n  int FOrigPortNumber;\r\n  TProxyMethod FOrigProxyMethod;\r\n  TSessionSource FSource;\r\n  bool FSaveOnly;\r\n  UnicodeString FLogicalHostName;\r\n\r\n  void __fastcall SetHostName(UnicodeString value);\r\n  UnicodeString __fastcall GetHostNameExpanded();\r\n  void __fastcall SetPortNumber(int value);\r\n  void __fastcall SetUserName(UnicodeString value);\r\n  UnicodeString __fastcall GetUserNameExpanded();\r\n  void __fastcall SetPassword(UnicodeString value);\r\n  UnicodeString __fastcall GetPassword() const;\r\n  void __fastcall SetNewPassword(UnicodeString value);\r\n  UnicodeString __fastcall GetNewPassword() const;\r\n  void __fastcall SetChangePassword(bool value);\r\n  void __fastcall SetPingInterval(int value);\r\n  void __fastcall SetTryAgent(bool value);\r\n  void __fastcall SetAgentFwd(bool value);\r\n  void __fastcall SetAuthTIS(bool value);\r\n  void __fastcall SetAuthKI(bool value);\r\n  void __fastcall SetAuthKIPassword(bool value);\r\n  void __fastcall SetAuthGSSAPI(bool value);\r\n  void __fastcall SetGSSAPIFwdTGT(bool value);\r\n  void __fastcall SetChangeUsername(bool value);\r\n  void __fastcall SetCompression(bool value);\r\n  void __fastcall SetSshProt(TSshProt value);\r\n  void __fastcall SetSsh2DES(bool value);\r\n  void __fastcall SetSshNoUserAuth(bool value);\r\n  void __fastcall SetCipher(int Index, TCipher value);\r\n  TCipher __fastcall GetCipher(int Index) const;\r\n  void __fastcall SetKex(int Index, TKex value);\r\n  TKex __fastcall GetKex(int Index) const;\r\n  void __fastcall SetHostKeys(int Index, THostKey value);\r\n  THostKey __fastcall GetHostKeys(int Index) const;\r\n  void __fastcall SetGssLib(int Index, TGssLib value);\r\n  TGssLib __fastcall GetGssLib(int Index) const;\r\n  void __fastcall SetGssLibCustom(UnicodeString value);\r\n  void __fastcall SetPublicKeyFile(UnicodeString value);\r\n  UnicodeString __fastcall GetPassphrase() const;\r\n  void __fastcall SetPassphrase(UnicodeString value);\r\n\r\n  void __fastcall SetPuttyProtocol(UnicodeString value);\r\n  bool __fastcall GetCanLogin();\r\n  void __fastcall SetPingIntervalDT(TDateTime value);\r\n  TDateTime __fastcall GetPingIntervalDT();\r\n  TDateTime __fastcall GetFtpPingIntervalDT();\r\n  void __fastcall SetTimeDifference(TDateTime value);\r\n  void __fastcall SetTimeDifferenceAuto(bool value);\r\n  void __fastcall SetPingType(TPingType value);\r\n  UnicodeString __fastcall GetSessionName();\r\n  UnicodeString __fastcall GetDefaultSessionName();\r\n  UnicodeString __fastcall GetProtocolUrl(bool HttpForWebDAV);\r\n  void __fastcall SetFSProtocol(TFSProtocol value);\r\n  UnicodeString __fastcall GetFSProtocolStr();\r\n  void __fastcall SetLocalDirectory(UnicodeString value);\r\n  UnicodeString __fastcall GetLocalDirectoryExpanded();\r\n  void __fastcall SetRemoteDirectory(UnicodeString value);\r\n  void __fastcall SetSynchronizeBrowsing(bool value);\r\n  void __fastcall SetUpdateDirectories(bool value);\r\n  void __fastcall SetCacheDirectories(bool value);\r\n  void __fastcall SetCacheDirectoryChanges(bool value);\r\n  void __fastcall SetPreserveDirectoryChanges(bool value);\r\n  void __fastcall SetLockInHome(bool value);\r\n  void __fastcall SetSpecial(bool value);\r\n  UnicodeString __fastcall GetInfoTip();\r\n  bool __fastcall GetDefaultShell();\r\n  void __fastcall SetDetectReturnVar(bool value);\r\n  bool __fastcall GetDetectReturnVar();\r\n  void __fastcall SetListingCommand(UnicodeString value);\r\n  void __fastcall SetClearAliases(bool value);\r\n  void __fastcall SetDefaultShell(bool value);\r\n  void __fastcall SetEOLType(TEOLType value);\r\n  void __fastcall SetTrimVMSVersions(bool value);\r\n  void __fastcall SetLookupUserGroups(TAutoSwitch value);\r\n  void __fastcall SetReturnVar(UnicodeString value);\r\n  void __fastcall SetExitCode1IsError(bool value);\r\n  void __fastcall SetScp1Compatibility(bool value);\r\n  void __fastcall SetShell(UnicodeString value);\r\n  void __fastcall SetSftpServer(UnicodeString value);\r\n  void __fastcall SetTimeout(int value);\r\n  void __fastcall SetUnsetNationalVars(bool value);\r\n  void __fastcall SetIgnoreLsWarnings(bool value);\r\n  void __fastcall SetTcpNoDelay(bool value);\r\n  void __fastcall SetSendBuf(int value);\r\n  void __fastcall SetSourceAddress(const UnicodeString & value);\r\n  void __fastcall SetSshSimple(bool value);\r\n  UnicodeString __fastcall GetSshProtStr();\r\n  bool __fastcall GetUsesSsh();\r\n  void __fastcall SetCipherList(UnicodeString value);\r\n  UnicodeString __fastcall GetCipherList() const;\r\n  void __fastcall SetKexList(UnicodeString value);\r\n  UnicodeString __fastcall GetKexList() const;\r\n  void __fastcall SetHostKeyList(UnicodeString value);\r\n  UnicodeString __fastcall GetHostKeyList() const;\r\n  void __fastcall SetGssLibList(UnicodeString value);\r\n  UnicodeString __fastcall GetGssLibList() const;\r\n  void __fastcall SetProxyMethod(TProxyMethod value);\r\n  void __fastcall SetProxyHost(UnicodeString value);\r\n  void __fastcall SetProxyPort(int value);\r\n  void __fastcall SetProxyUsername(UnicodeString value);\r\n  void __fastcall SetProxyPassword(UnicodeString value);\r\n  void __fastcall SetProxyTelnetCommand(UnicodeString value);\r\n  void __fastcall SetProxyLocalCommand(UnicodeString value);\r\n  void __fastcall SetProxyDNS(TAutoSwitch value);\r\n  void __fastcall SetProxyLocalhost(bool value);\r\n  UnicodeString __fastcall GetProxyPassword() const;\r\n  void __fastcall SetFtpProxyLogonType(int value);\r\n  void __fastcall SetBug(TSshBug Bug, TAutoSwitch value);\r\n  TAutoSwitch __fastcall GetBug(TSshBug Bug) const;\r\n  UnicodeString __fastcall GetSessionKey();\r\n  void __fastcall SetPuttySettings(UnicodeString value);\r\n  void __fastcall SetCustomParam1(UnicodeString value);\r\n  void __fastcall SetCustomParam2(UnicodeString value);\r\n  void __fastcall SetResolveSymlinks(bool value);\r\n  void __fastcall SetFollowDirectorySymlinks(bool value);\r\n  void __fastcall SetSFTPDownloadQueue(int value);\r\n  void __fastcall SetSFTPUploadQueue(int value);\r\n  void __fastcall SetSFTPListingQueue(int value);\r\n  void __fastcall SetSFTPMaxVersion(int value);\r\n  void __fastcall SetSFTPMaxPacketSize(unsigned long value);\r\n  void __fastcall SetSFTPBug(TSftpBug Bug, TAutoSwitch value);\r\n  TAutoSwitch __fastcall GetSFTPBug(TSftpBug Bug) const;\r\n  void __fastcall SetSCPLsFullTime(TAutoSwitch value);\r\n  void __fastcall SetFtpListAll(TAutoSwitch value);\r\n  void __fastcall SetFtpHost(TAutoSwitch value);\r\n  void __fastcall SetFtpDeleteFromCwd(TAutoSwitch value);\r\n  void __fastcall SetSslSessionReuse(bool value);\r\n  void __fastcall SetTlsCertificateFile(UnicodeString value);\r\n  UnicodeString __fastcall GetStorageKey();\r\n  UnicodeString __fastcall GetInternalStorageKey();\r\n  UnicodeString __fastcall GetSiteKey();\r\n  void __fastcall SetDSTMode(TDSTMode value);\r\n  void __fastcall SetDeleteToRecycleBin(bool value);\r\n  void __fastcall SetOverwrittenToRecycleBin(bool value);\r\n  void __fastcall SetRecycleBinPath(UnicodeString value);\r\n  void __fastcall SetPostLoginCommands(UnicodeString value);\r\n  void __fastcall SetAddressFamily(TAddressFamily value);\r\n  void __fastcall SetRekeyData(UnicodeString value);\r\n  void __fastcall SetRekeyTime(unsigned int value);\r\n  void __fastcall SetColor(int value);\r\n  void __fastcall SetTunnel(bool value);\r\n  void __fastcall SetTunnelHostName(UnicodeString value);\r\n  void __fastcall SetTunnelPortNumber(int value);\r\n  void __fastcall SetTunnelUserName(UnicodeString value);\r\n  void __fastcall SetTunnelPassword(UnicodeString value);\r\n  UnicodeString __fastcall GetTunnelPassword() const;\r\n  void __fastcall SetTunnelPublicKeyFile(UnicodeString value);\r\n  void __fastcall SetTunnelPortFwd(UnicodeString value);\r\n  void __fastcall SetTunnelLocalPortNumber(int value);\r\n  bool __fastcall GetTunnelAutoassignLocalPortNumber();\r\n  void __fastcall SetTunnelHostKey(UnicodeString value);\r\n  void __fastcall SetFtpPasvMode(bool value);\r\n  void __fastcall SetFtpForcePasvIp(TAutoSwitch value);\r\n  void __fastcall SetFtpUseMlsd(TAutoSwitch value);\r\n  void __fastcall SetFtpAccount(UnicodeString value);\r\n  void __fastcall SetFtpPingInterval(int value);\r\n  void __fastcall SetFtpPingType(TPingType value);\r\n  void __fastcall SetFtpTransferActiveImmediately(TAutoSwitch value);\r\n  void __fastcall SetFtps(TFtps value);\r\n  void __fastcall SetMinTlsVersion(TTlsVersion value);\r\n  void __fastcall SetMaxTlsVersion(TTlsVersion value);\r\n  void __fastcall SetNotUtf(TAutoSwitch value);\r\n  void __fastcall SetInternalEditorEncoding(int value);\r\n  void __fastcall SetS3DefaultRegion(UnicodeString value);\r\n  void __fastcall SetS3UrlStyle(TS3UrlStyle value);\r\n  void __fastcall SetLogicalHostName(UnicodeString value);\r\n  void __fastcall SetIsWorkspace(bool value);\r\n  void __fastcall SetLink(UnicodeString value);\r\n  void __fastcall SetNameOverride(UnicodeString value);\r\n  void __fastcall SetHostKey(UnicodeString value);\r\n  void __fastcall SetNote(UnicodeString value);\r\n  void __fastcall SetWinTitle(UnicodeString value);\r\n  UnicodeString __fastcall GetEncryptKey() const;\r\n  void __fastcall SetEncryptKey(UnicodeString value);\r\n\r\n  TDateTime __fastcall GetTimeoutDT();\r\n  void __fastcall SavePasswords(THierarchicalStorage * Storage, bool PuttyExport, bool DoNotEncryptPasswords, bool SaveAll);\r\n  UnicodeString __fastcall GetLocalName();\r\n  UnicodeString __fastcall GetFolderName();\r\n  void __fastcall Modify();\r\n  UnicodeString __fastcall GetSource();\r\n  void __fastcall DoLoad(THierarchicalStorage * Storage, bool PuttyImport, bool & RewritePassword, bool Unsafe);\r\n  void __fastcall DoSave(THierarchicalStorage * Storage,\r\n    bool PuttyExport, const TSessionData * Default, bool DoNotEncryptPasswords);\r\n  UnicodeString __fastcall ReadXmlNode(_di_IXMLNode Node, const UnicodeString & Name, const UnicodeString & Default);\r\n  int __fastcall ReadXmlNode(_di_IXMLNode Node, const UnicodeString & Name, int Default);\r\n  _di_IXMLNode __fastcall FindSettingsNode(_di_IXMLNode Node, const UnicodeString & Name);\r\n  UnicodeString __fastcall ReadSettingsNode(_di_IXMLNode Node, const UnicodeString & Name, const UnicodeString & Default);\r\n  int __fastcall ReadSettingsNode(_di_IXMLNode Node, const UnicodeString & Name, int Default);\r\n  bool __fastcall IsSame(const TSessionData * Default, bool AdvancedOnly, TStrings * DifferentProperties, bool Decrypted);\r\n  UnicodeString __fastcall GetNameWithoutHiddenPrefix();\r\n  bool __fastcall HasStateData();\r\n  void __fastcall CopyStateData(TSessionData * SourceData);\r\n  void __fastcall CopyNonCoreData(TSessionData * SourceData);\r\n  UnicodeString __fastcall GetNormalizedPuttyProtocol() const;\r\n  static RawByteString __fastcall EncryptPassword(const UnicodeString & Password, UnicodeString Key);\r\n  static UnicodeString __fastcall DecryptPassword(const RawByteString & Password, UnicodeString Key);\r\n  static RawByteString __fastcall StronglyRecryptPassword(const RawByteString & Password, UnicodeString Key);\r\n  static bool __fastcall DoIsProtocolUrl(const UnicodeString & Url, const UnicodeString & Protocol, int & ProtocolLen);\r\n  static bool __fastcall IsProtocolUrl(const UnicodeString & Url, const UnicodeString & Protocol, int & ProtocolLen);\r\n  static void __fastcall AddSwitch(UnicodeString & Result, const UnicodeString & Name, bool Rtf);\r\n  static void __fastcall AddSwitch(\r\n    UnicodeString & Result, const UnicodeString & Name, const UnicodeString & Value, bool Rtf);\r\n  static void __fastcall AddSwitch(UnicodeString & Result, const UnicodeString & Name, int Value, bool Rtf);\r\n  static void __fastcall AddAssemblyProperty(\r\n    UnicodeString & Result, TAssemblyLanguage Language,\r\n    const UnicodeString & Name, const UnicodeString & Value);\r\n  static void __fastcall AddAssemblyProperty(\r\n    UnicodeString & Result, TAssemblyLanguage Language,\r\n    const UnicodeString & Name, const UnicodeString & Type,\r\n    const UnicodeString & Member);\r\n  static void __fastcall AddAssemblyProperty(\r\n    UnicodeString & Result, TAssemblyLanguage Language,\r\n    const UnicodeString & Name, int Value);\r\n  void __fastcall AddAssemblyProperty(\r\n    UnicodeString & Result, TAssemblyLanguage Language,\r\n    const UnicodeString & Name, bool Value);\r\n  TStrings * __fastcall GetRawSettingsForUrl();\r\n  void __fastcall DoCopyData(TSessionData * SourceData, bool NoRecrypt);\r\n  template<class AlgoT>\r\n  void __fastcall SetAlgoList(AlgoT * List, const AlgoT * DefaultList, const UnicodeString * Names,\r\n    int Count, AlgoT WarnAlgo, UnicodeString value);\r\n  static void __fastcall Remove(THierarchicalStorage * Storage, const UnicodeString & Name);\r\n\r\n  __property UnicodeString InternalStorageKey = { read = GetInternalStorageKey };\r\n\r\npublic:\r\n  __fastcall TSessionData(UnicodeString aName);\r\n  virtual __fastcall ~TSessionData();\r\n  TSessionData * __fastcall Clone();\r\n  void __fastcall Default();\r\n  void __fastcall DefaultSettings();\r\n  void __fastcall NonPersistant();\r\n  void __fastcall Load(THierarchicalStorage * Storage, bool PuttyImport);\r\n  void __fastcall ApplyRawSettings(TStrings * RawSettings, bool Unsafe);\r\n  void __fastcall ApplyRawSettings(THierarchicalStorage * Storage, bool Unsafe);\r\n  void __fastcall ImportFromFilezilla(_di_IXMLNode Node, const UnicodeString & Path, _di_IXMLNode SettingsNode);\r\n  void __fastcall Save(THierarchicalStorage * Storage, bool PuttyExport,\r\n    const TSessionData * Default = NULL);\r\n  void __fastcall SaveRecryptedPasswords(THierarchicalStorage * Storage);\r\n  void __fastcall RecryptPasswords();\r\n  bool __fastcall HasPassword();\r\n  bool __fastcall HasAnySessionPassword();\r\n  bool __fastcall HasAnyPassword();\r\n  void __fastcall ClearSessionPasswords();\r\n  void __fastcall MaskPasswords();\r\n  void __fastcall Remove();\r\n  void __fastcall CacheHostKeyIfNotCached();\r\n  virtual void __fastcall Assign(TPersistent * Source);\r\n  virtual int __fastcall Compare(TNamedObject * Other);\r\n  void __fastcall CopyData(TSessionData * Source);\r\n  void __fastcall CopyDataNoRecrypt(TSessionData * SourceData);\r\n  void __fastcall CopyDirectoriesStateData(TSessionData * SourceData);\r\n  bool __fastcall ParseUrl(UnicodeString Url, TOptions * Options,\r\n    TStoredSessionList * StoredSessions, bool & DefaultsOnly,\r\n    UnicodeString * FileName, bool * AProtocolDefined, UnicodeString * MaskedUrl, int Flags);\r\n  TStrings * __fastcall SaveToOptions(const TSessionData * Default, bool SaveName, bool PuttyExport);\r\n  void __fastcall ConfigureTunnel(int PortNumber);\r\n  void __fastcall RollbackTunnel();\r\n  void __fastcall ExpandEnvironmentVariables();\r\n  void __fastcall DisableAuthentationsExceptPassword();\r\n  bool __fastcall IsSame(const TSessionData * Default, bool AdvancedOnly);\r\n  bool __fastcall IsSameDecrypted(const TSessionData * Default);\r\n  bool __fastcall IsSameSite(const TSessionData * Default);\r\n  bool __fastcall IsInFolderOrWorkspace(UnicodeString Name);\r\n  UnicodeString __fastcall GenerateSessionUrl(unsigned int Flags);\r\n  bool __fastcall HasRawSettingsForUrl();\r\n  bool __fastcall HasSessionName();\r\n\r\n  UnicodeString __fastcall GenerateOpenCommandArgs(bool Rtf);\r\n  void __fastcall GenerateAssemblyCode(TAssemblyLanguage Language, UnicodeString & Head, UnicodeString & Tail, int & Indent);\r\n  void __fastcall LookupLastFingerprint();\r\n  bool __fastcall IsSecure();\r\n  static void __fastcall ValidatePath(const UnicodeString Path);\r\n  static void __fastcall ValidateName(const UnicodeString Name);\r\n  static UnicodeString __fastcall MakeValidName(const UnicodeString & Name);\r\n  static UnicodeString __fastcall ExtractLocalName(const UnicodeString & Name);\r\n  static UnicodeString __fastcall ExtractFolderName(const UnicodeString & Name);\r\n  static UnicodeString __fastcall ComposePath(const UnicodeString & Path, const UnicodeString & Name);\r\n  static bool __fastcall IsSensitiveOption(const UnicodeString & Option);\r\n  static bool __fastcall IsOptionWithParameters(const UnicodeString & Option);\r\n  static bool __fastcall MaskPasswordInOptionParameter(const UnicodeString & Option, UnicodeString & Param);\r\n  static UnicodeString __fastcall FormatSiteKey(const UnicodeString & HostName, int PortNumber);\r\n  static TStrings * GetAllOptionNames(bool PuttyExport);\r\n\r\n  __property UnicodeString HostName  = { read=FHostName, write=SetHostName };\r\n  __property UnicodeString HostNameExpanded  = { read=GetHostNameExpanded };\r\n  __property int PortNumber  = { read=FPortNumber, write=SetPortNumber };\r\n  __property UnicodeString UserName  = { read=FUserName, write=SetUserName };\r\n  __property UnicodeString UserNameExpanded  = { read=GetUserNameExpanded };\r\n  __property UnicodeString Password  = { read=GetPassword, write=SetPassword };\r\n  __property UnicodeString NewPassword  = { read=GetNewPassword, write=SetNewPassword };\r\n  __property bool ChangePassword  = { read=FChangePassword, write=SetChangePassword };\r\n  __property int PingInterval  = { read=FPingInterval, write=SetPingInterval };\r\n  __property bool TryAgent  = { read=FTryAgent, write=SetTryAgent };\r\n  __property bool AgentFwd  = { read=FAgentFwd, write=SetAgentFwd };\r\n  __property UnicodeString ListingCommand = { read = FListingCommand, write = SetListingCommand };\r\n  __property bool AuthTIS  = { read=FAuthTIS, write=SetAuthTIS };\r\n  __property bool AuthKI  = { read=FAuthKI, write=SetAuthKI };\r\n  __property bool AuthKIPassword  = { read=FAuthKIPassword, write=SetAuthKIPassword };\r\n  __property bool AuthGSSAPI  = { read=FAuthGSSAPI, write=SetAuthGSSAPI };\r\n  __property bool GSSAPIFwdTGT = { read=FGSSAPIFwdTGT, write=SetGSSAPIFwdTGT };\r\n  __property bool ChangeUsername  = { read=FChangeUsername, write=SetChangeUsername };\r\n  __property bool Compression  = { read=FCompression, write=SetCompression };\r\n  __property TSshProt SshProt  = { read=FSshProt, write=SetSshProt };\r\n  __property bool UsesSsh = { read = GetUsesSsh };\r\n  __property bool Ssh2DES  = { read=FSsh2DES, write=SetSsh2DES };\r\n  __property bool SshNoUserAuth  = { read=FSshNoUserAuth, write=SetSshNoUserAuth };\r\n  __property TCipher Cipher[int Index] = { read=GetCipher, write=SetCipher };\r\n  __property TKex Kex[int Index] = { read=GetKex, write=SetKex };\r\n  __property THostKey HostKeys[int Index] = { read=GetHostKeys, write=SetHostKeys };\r\n  __property TGssLib GssLib[int Index] = { read=GetGssLib, write=SetGssLib };\r\n  __property UnicodeString GssLibCustom = { read=FGssLibCustom, write=SetGssLibCustom };\r\n  __property UnicodeString PublicKeyFile  = { read=FPublicKeyFile, write=SetPublicKeyFile };\r\n  __property UnicodeString Passphrase  = { read=GetPassphrase, write=SetPassphrase };\r\n  __property UnicodeString PuttyProtocol  = { read=FPuttyProtocol, write=SetPuttyProtocol };\r\n  __property TFSProtocol FSProtocol  = { read=FFSProtocol, write=SetFSProtocol  };\r\n  __property UnicodeString FSProtocolStr  = { read=GetFSProtocolStr };\r\n  __property bool Modified  = { read=FModified, write=FModified };\r\n  __property bool CanLogin  = { read=GetCanLogin };\r\n  __property bool ClearAliases = { read = FClearAliases, write = SetClearAliases };\r\n  __property TDateTime PingIntervalDT = { read = GetPingIntervalDT, write = SetPingIntervalDT };\r\n  __property TDateTime TimeDifference = { read = FTimeDifference, write = SetTimeDifference };\r\n  __property bool TimeDifferenceAuto = { read = FTimeDifferenceAuto, write = SetTimeDifferenceAuto };\r\n  __property TPingType PingType = { read = FPingType, write = SetPingType };\r\n  __property UnicodeString SessionName  = { read=GetSessionName };\r\n  __property UnicodeString DefaultSessionName  = { read=GetDefaultSessionName };\r\n  __property UnicodeString LocalDirectory  = { read=FLocalDirectory, write=SetLocalDirectory };\r\n  __property UnicodeString LocalDirectoryExpanded = { read = GetLocalDirectoryExpanded };\r\n  __property UnicodeString RemoteDirectory  = { read=FRemoteDirectory, write=SetRemoteDirectory };\r\n  __property bool SynchronizeBrowsing = { read=FSynchronizeBrowsing, write=SetSynchronizeBrowsing };\r\n  __property bool UpdateDirectories = { read=FUpdateDirectories, write=SetUpdateDirectories };\r\n  __property bool CacheDirectories = { read=FCacheDirectories, write=SetCacheDirectories };\r\n  __property bool CacheDirectoryChanges = { read=FCacheDirectoryChanges, write=SetCacheDirectoryChanges };\r\n  __property bool PreserveDirectoryChanges = { read=FPreserveDirectoryChanges, write=SetPreserveDirectoryChanges };\r\n  __property bool LockInHome = { read=FLockInHome, write=SetLockInHome };\r\n  __property bool Special = { read=FSpecial, write=SetSpecial };\r\n  __property bool Selected  = { read=FSelected, write=FSelected };\r\n  __property UnicodeString InfoTip  = { read=GetInfoTip };\r\n  __property bool DefaultShell = { read = GetDefaultShell, write = SetDefaultShell };\r\n  __property bool DetectReturnVar = { read = GetDetectReturnVar, write = SetDetectReturnVar };\r\n  __property TEOLType EOLType = { read = FEOLType, write = SetEOLType };\r\n  __property bool TrimVMSVersions = { read = FTrimVMSVersions, write = SetTrimVMSVersions };\r\n  __property TAutoSwitch LookupUserGroups = { read = FLookupUserGroups, write = SetLookupUserGroups };\r\n  __property UnicodeString ReturnVar = { read = FReturnVar, write = SetReturnVar };\r\n  __property bool ExitCode1IsError = { read = FExitCode1IsError, write = SetExitCode1IsError };\r\n  __property bool Scp1Compatibility = { read = FScp1Compatibility, write = SetScp1Compatibility };\r\n  __property UnicodeString Shell = { read = FShell, write = SetShell };\r\n  __property UnicodeString SftpServer = { read = FSftpServer, write = SetSftpServer };\r\n  __property int Timeout = { read = FTimeout, write = SetTimeout };\r\n  __property TDateTime TimeoutDT = { read = GetTimeoutDT };\r\n  __property bool UnsetNationalVars = { read = FUnsetNationalVars, write = SetUnsetNationalVars };\r\n  __property bool IgnoreLsWarnings  = { read=FIgnoreLsWarnings, write=SetIgnoreLsWarnings };\r\n  __property bool TcpNoDelay  = { read=FTcpNoDelay, write=SetTcpNoDelay };\r\n  __property int SendBuf  = { read=FSendBuf, write=SetSendBuf };\r\n  __property UnicodeString SourceAddress = { read=FSourceAddress, write=SetSourceAddress };\r\n  __property bool SshSimple  = { read=FSshSimple, write=SetSshSimple };\r\n  __property UnicodeString SshProtStr  = { read=GetSshProtStr };\r\n  __property UnicodeString CipherList  = { read=GetCipherList, write=SetCipherList };\r\n  __property UnicodeString KexList  = { read=GetKexList, write=SetKexList };\r\n  __property UnicodeString HostKeyList  = { read=GetHostKeyList, write=SetHostKeyList };\r\n  __property UnicodeString GssLibList  = { read=GetGssLibList, write=SetGssLibList };\r\n  __property TProxyMethod ProxyMethod  = { read=FProxyMethod, write=SetProxyMethod };\r\n  __property UnicodeString ProxyHost  = { read=FProxyHost, write=SetProxyHost };\r\n  __property int ProxyPort  = { read=FProxyPort, write=SetProxyPort };\r\n  __property UnicodeString ProxyUsername  = { read=FProxyUsername, write=SetProxyUsername };\r\n  __property UnicodeString ProxyPassword  = { read=GetProxyPassword, write=SetProxyPassword };\r\n  __property UnicodeString ProxyTelnetCommand  = { read=FProxyTelnetCommand, write=SetProxyTelnetCommand };\r\n  __property UnicodeString ProxyLocalCommand  = { read=FProxyLocalCommand, write=SetProxyLocalCommand };\r\n  __property TAutoSwitch ProxyDNS  = { read=FProxyDNS, write=SetProxyDNS };\r\n  __property bool ProxyLocalhost  = { read=FProxyLocalhost, write=SetProxyLocalhost };\r\n  __property int FtpProxyLogonType  = { read=FFtpProxyLogonType, write=SetFtpProxyLogonType };\r\n  __property TAutoSwitch Bug[TSshBug Bug]  = { read=GetBug, write=SetBug };\r\n  __property UnicodeString PuttySettings = { read = FPuttySettings, write = SetPuttySettings };\r\n  __property UnicodeString CustomParam1 = { read = FCustomParam1, write = SetCustomParam1 };\r\n  __property UnicodeString CustomParam2 = { read = FCustomParam2, write = SetCustomParam2 };\r\n  __property UnicodeString SessionKey = { read = GetSessionKey };\r\n  __property bool ResolveSymlinks = { read = FResolveSymlinks, write = SetResolveSymlinks };\r\n  __property bool FollowDirectorySymlinks = { read = FFollowDirectorySymlinks, write = SetFollowDirectorySymlinks };\r\n  __property int SFTPDownloadQueue = { read = FSFTPDownloadQueue, write = SetSFTPDownloadQueue };\r\n  __property int SFTPUploadQueue = { read = FSFTPUploadQueue, write = SetSFTPUploadQueue };\r\n  __property int SFTPListingQueue = { read = FSFTPListingQueue, write = SetSFTPListingQueue };\r\n  __property int SFTPMaxVersion = { read = FSFTPMaxVersion, write = SetSFTPMaxVersion };\r\n  __property unsigned long SFTPMaxPacketSize = { read = FSFTPMaxPacketSize, write = SetSFTPMaxPacketSize };\r\n  __property TAutoSwitch SFTPBug[TSftpBug Bug]  = { read=GetSFTPBug, write=SetSFTPBug };\r\n  __property TAutoSwitch SCPLsFullTime = { read = FSCPLsFullTime, write = SetSCPLsFullTime };\r\n  __property TAutoSwitch FtpListAll = { read = FFtpListAll, write = SetFtpListAll };\r\n  __property TAutoSwitch FtpHost = { read = FFtpHost, write = SetFtpHost };\r\n  __property TAutoSwitch FtpDeleteFromCwd = { read = FFtpDeleteFromCwd, write = SetFtpDeleteFromCwd };\r\n  __property bool SslSessionReuse = { read = FSslSessionReuse, write = SetSslSessionReuse };\r\n  __property UnicodeString TlsCertificateFile = { read=FTlsCertificateFile, write=SetTlsCertificateFile };\r\n  __property TDSTMode DSTMode = { read = FDSTMode, write = SetDSTMode };\r\n  __property bool DeleteToRecycleBin = { read = FDeleteToRecycleBin, write = SetDeleteToRecycleBin };\r\n  __property bool OverwrittenToRecycleBin = { read = FOverwrittenToRecycleBin, write = SetOverwrittenToRecycleBin };\r\n  __property UnicodeString RecycleBinPath = { read = FRecycleBinPath, write = SetRecycleBinPath };\r\n  __property UnicodeString PostLoginCommands = { read = FPostLoginCommands, write = SetPostLoginCommands };\r\n  __property TAddressFamily AddressFamily = { read = FAddressFamily, write = SetAddressFamily };\r\n  __property UnicodeString RekeyData = { read = FRekeyData, write = SetRekeyData };\r\n  __property unsigned int RekeyTime = { read = FRekeyTime, write = SetRekeyTime };\r\n  __property int Color = { read = FColor, write = SetColor };\r\n  __property bool Tunnel = { read = FTunnel, write = SetTunnel };\r\n  __property UnicodeString TunnelHostName = { read = FTunnelHostName, write = SetTunnelHostName };\r\n  __property int TunnelPortNumber = { read = FTunnelPortNumber, write = SetTunnelPortNumber };\r\n  __property UnicodeString TunnelUserName = { read = FTunnelUserName, write = SetTunnelUserName };\r\n  __property UnicodeString TunnelPassword = { read = GetTunnelPassword, write = SetTunnelPassword };\r\n  __property UnicodeString TunnelPublicKeyFile = { read = FTunnelPublicKeyFile, write = SetTunnelPublicKeyFile };\r\n  __property bool TunnelAutoassignLocalPortNumber = { read = GetTunnelAutoassignLocalPortNumber };\r\n  __property int TunnelLocalPortNumber = { read = FTunnelLocalPortNumber, write = SetTunnelLocalPortNumber };\r\n  __property UnicodeString TunnelPortFwd = { read = FTunnelPortFwd, write = SetTunnelPortFwd };\r\n  __property UnicodeString TunnelHostKey = { read = FTunnelHostKey, write = SetTunnelHostKey };\r\n  __property bool FtpPasvMode = { read = FFtpPasvMode, write = SetFtpPasvMode };\r\n  __property TAutoSwitch FtpForcePasvIp = { read = FFtpForcePasvIp, write = SetFtpForcePasvIp };\r\n  __property TAutoSwitch FtpUseMlsd = { read = FFtpUseMlsd, write = SetFtpUseMlsd };\r\n  __property UnicodeString FtpAccount = { read = FFtpAccount, write = SetFtpAccount };\r\n  __property int FtpPingInterval  = { read=FFtpPingInterval, write=SetFtpPingInterval };\r\n  __property TDateTime FtpPingIntervalDT  = { read=GetFtpPingIntervalDT };\r\n  __property TPingType FtpPingType = { read = FFtpPingType, write = SetFtpPingType };\r\n  __property TAutoSwitch FtpTransferActiveImmediately = { read = FFtpTransferActiveImmediately, write = SetFtpTransferActiveImmediately };\r\n  __property TFtps Ftps = { read = FFtps, write = SetFtps };\r\n  __property TTlsVersion MinTlsVersion = { read = FMinTlsVersion, write = SetMinTlsVersion };\r\n  __property TTlsVersion MaxTlsVersion = { read = FMaxTlsVersion, write = SetMaxTlsVersion };\r\n  __property UnicodeString LogicalHostName = { read = FLogicalHostName, write = SetLogicalHostName };\r\n  __property TAutoSwitch NotUtf = { read = FNotUtf, write = SetNotUtf };\r\n  __property int InternalEditorEncoding = { read = FInternalEditorEncoding, write = SetInternalEditorEncoding };\r\n  __property UnicodeString S3DefaultRegion = { read = FS3DefaultRegion, write = SetS3DefaultRegion };\r\n  __property TS3UrlStyle S3UrlStyle = { read = FS3UrlStyle, write = SetS3UrlStyle };\r\n  __property bool IsWorkspace = { read = FIsWorkspace, write = SetIsWorkspace };\r\n  __property UnicodeString Link = { read = FLink, write = SetLink };\r\n  __property UnicodeString NameOverride = { read = FNameOverride, write = SetNameOverride };\r\n  __property UnicodeString HostKey = { read = FHostKey, write = SetHostKey };\r\n  __property bool FingerprintScan = { read = FFingerprintScan, write = FFingerprintScan };\r\n  __property bool OverrideCachedHostKey = { read = FOverrideCachedHostKey };\r\n  __property UnicodeString Note = { read = FNote, write = SetNote };\r\n  __property UnicodeString WinTitle = { read = FWinTitle, write = SetWinTitle };\r\n  __property UnicodeString EncryptKey = { read = GetEncryptKey, write = SetEncryptKey };\r\n\r\n  __property UnicodeString StorageKey = { read = GetStorageKey };\r\n  __property UnicodeString SiteKey = { read = GetSiteKey };\r\n  __property UnicodeString OrigHostName = { read = FOrigHostName };\r\n  __property int OrigPortNumber = { read = FOrigPortNumber };\r\n  __property UnicodeString LocalName = { read = GetLocalName };\r\n  __property UnicodeString FolderName = { read = GetFolderName };\r\n  __property UnicodeString Source = { read = GetSource };\r\n  __property bool SaveOnly = { read = FSaveOnly };\r\n};\r\n//---------------------------------------------------------------------------\r\nclass TStoredSessionList : public TNamedObjectList\r\n{\r\npublic:\r\n  __fastcall TStoredSessionList(bool aReadOnly = false);\r\n  void __fastcall Reload();\r\n  void __fastcall Save(bool All, bool Explicit);\r\n  void __fastcall Saved();\r\n  void __fastcall ImportFromFilezilla(const UnicodeString FileName, const UnicodeString ConfigurationFileName);\r\n  void __fastcall ImportFromKnownHosts(TStrings * Lines);\r\n  void __fastcall Export(const UnicodeString FileName);\r\n  void __fastcall Load(THierarchicalStorage * Storage, bool AsModified = false,\r\n    bool UseDefaults = false, bool PuttyImport = false);\r\n  void __fastcall Save(THierarchicalStorage * Storage, bool All = false);\r\n  void __fastcall SelectAll(bool Select);\r\n  void __fastcall Import(TStoredSessionList * From, bool OnlySelected, TList * Imported);\r\n  void __fastcall RecryptPasswords(TStrings * RecryptPasswordErrors);\r\n  TSessionData * __fastcall AtSession(int Index)\r\n    { return (TSessionData*)AtObject(Index); }\r\n  void __fastcall SelectSessionsToImport(TStoredSessionList * Dest, bool SSHOnly);\r\n  void __fastcall Cleanup();\r\n  void __fastcall UpdateStaticUsage();\r\n  int __fastcall IndexOf(TSessionData * Data);\r\n  TSessionData * __fastcall FindSame(TSessionData * Data);\r\n  TSessionData * __fastcall NewSession(UnicodeString SessionName, TSessionData * Session);\r\n  void __fastcall NewWorkspace(UnicodeString Name, TList * DataList);\r\n  bool __fastcall IsFolder(const UnicodeString & Name);\r\n  bool __fastcall IsWorkspace(const UnicodeString & Name);\r\n  TSessionData * __fastcall ParseUrl(UnicodeString Url, TOptions * Options, bool & DefaultsOnly,\r\n    UnicodeString * FileName = NULL, bool * ProtocolDefined = NULL, UnicodeString * MaskedUrl = NULL, int Flags = 0);\r\n  bool __fastcall IsUrl(UnicodeString Url);\r\n  bool __fastcall CanLogin(TSessionData * Data);\r\n  void __fastcall GetFolderOrWorkspace(const UnicodeString & Name, TList * List);\r\n  TStrings * __fastcall GetFolderOrWorkspaceList(const UnicodeString & Name);\r\n  TStrings * __fastcall GetWorkspaces();\r\n  bool __fastcall HasAnyWorkspace();\r\n  TSessionData * __fastcall SaveWorkspaceData(TSessionData * Data, int Index);\r\n  virtual __fastcall ~TStoredSessionList();\r\n  __property TSessionData * Sessions[int Index]  = { read=AtSession };\r\n  __property TSessionData * DefaultSettings  = { read=FDefaultSettings, write=SetDefaultSettings };\r\n\r\n  static void __fastcall ImportHostKeys(\r\n    THierarchicalStorage * SourceStorage, THierarchicalStorage * TargetStorage, TStoredSessionList * Sessions, bool OnlySelected);\r\n  static void __fastcall ImportHostKeys(\r\n    const UnicodeString & SourceKey, TStoredSessionList * Sessions, bool OnlySelected);\r\n  static void __fastcall ImportSelectedKnownHosts(TStoredSessionList * Sessions);\r\n  static bool __fastcall OpenHostKeysSubKey(THierarchicalStorage * Storage, bool CanCreate);\r\n\r\nprivate:\r\n  TSessionData * FDefaultSettings;\r\n  bool FReadOnly;\r\n  std::unique_ptr<TStrings> FPendingRemovals;\r\n  void __fastcall SetDefaultSettings(TSessionData * value);\r\n  void __fastcall DoSave(THierarchicalStorage * Storage, bool All,\r\n    bool RecryptPasswordOnly, TStrings * RecryptPasswordErrors);\r\n  void __fastcall DoSave(bool All, bool Explicit, bool RecryptPasswordOnly,\r\n    TStrings * RecryptPasswordErrors);\r\n  void __fastcall DoSave(THierarchicalStorage * Storage,\r\n    TSessionData * Data, bool All, bool RecryptPasswordOnly,\r\n    TSessionData * FactoryDefaults);\r\n  TSessionData * __fastcall ResolveWorkspaceData(TSessionData * Data);\r\n  bool __fastcall IsFolderOrWorkspace(const UnicodeString & Name, bool Workspace);\r\n  TSessionData * __fastcall CheckIsInFolderOrWorkspaceAndResolve(\r\n    TSessionData * Data, const UnicodeString & Name);\r\n  void __fastcall ImportLevelFromFilezilla(_di_IXMLNode Node, const UnicodeString & Path, _di_IXMLNode SettingsNode);\r\n  void __fastcall DoGetFolderOrWorkspace(const UnicodeString & Name, TList * List, bool NoRecrypt);\r\n  static THierarchicalStorage * __fastcall CreateHostKeysStorageForWritting();\r\n};\r\n//---------------------------------------------------------------------------\r\nUnicodeString GetExpandedLogFileName(UnicodeString LogFileName, TDateTime Started, TSessionData * SessionData);\r\nbool __fastcall IsSshProtocol(TFSProtocol FSProtocol);\r\nint __fastcall DefaultPort(TFSProtocol FSProtocol, TFtps Ftps);\r\nbool __fastcall IsIPv6Literal(const UnicodeString & HostName);\r\nUnicodeString __fastcall EscapeIPv6Literal(const UnicodeString & IP);\r\nTFSProtocol NormalizeFSProtocol(TFSProtocol FSProtocol);\r\n//---------------------------------------------------------------------------\r\n#endif\r\n", "//---------------------------------------------------------------------\r\n#include <vcl.h>\r\n#pragma hdrstop\r\n\r\n#include <Dialogs.hpp>\r\n//---------------------------------------------------------------------\r\n#include <Common.h>\r\n#include <CustomWinConfiguration.h>\r\n#include <WinInterface.h>\r\n#include <VCLCommon.h>\r\n#include <TextsWin.h>\r\n#include <HelpWin.h>\r\n#include <CoreMain.h>\r\n#include <PasTools.hpp>\r\n#include <ProgParams.h>\r\n#include <Tools.h>\r\n#include <GUITools.h>\r\n#include <HistoryComboBox.hpp>\r\n#include <Math.hpp>\r\n\r\n#include \"Custom.h\"\r\n//---------------------------------------------------------------------\r\n#pragma link \"PasswordEdit\"\r\n#pragma resource \"*.dfm\"\r\n//---------------------------------------------------------------------\r\n__fastcall TCustomDialog::TCustomDialog(UnicodeString AHelpKeyword)\r\n  : TForm(GetFormOwner())\r\n{\r\n  UseSystemSettings(this);\r\n\r\n  FControlPadding = ScaleByTextHeight(this, 8);\r\n  FPos = ScaleByTextHeight(this, 8);\r\n  FPrePos = FPos;\r\n  FHorizontalMargin = ScaleByTextHeight(this, 8);\r\n  FIndent = FHorizontalMargin;\r\n  FGroupBox = NULL;\r\n\r\n  HelpKeyword = AHelpKeyword;\r\n\r\n  TBorderIcons BI = BorderIcons;\r\n  if (HelpKeyword.IsEmpty())\r\n  {\r\n    BI >> biHelp;\r\n\r\n    OKButton->Left = CancelButton->Left;\r\n    CancelButton->Left = HelpButton->Left;\r\n    HelpButton->Visible = false;\r\n  }\r\n  else\r\n  {\r\n    BI << biHelp;\r\n  }\r\n  BorderIcons = BI;\r\n}\r\n//---------------------------------------------------------------------\r\nbool __fastcall TCustomDialog::Execute()\r\n{\r\n  Changed();\r\n  return (ShowModal() == DefaultResult(this));\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TCustomDialog::DoChange(bool & /*CanSubmit*/)\r\n{\r\n  // noop\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TCustomDialog::Changed()\r\n{\r\n  bool CanSubmit = true;\r\n  DoChange(CanSubmit);\r\n  EnableControl(OKButton, CanSubmit);\r\n}\r\n//---------------------------------------------------------------------\r\nvoid __fastcall TCustomDialog::Change(TObject * /*Sender*/)\r\n{\r\n  Changed();\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TCustomDialog::DoHelp()\r\n{\r\n  FormHelp(this);\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TCustomDialog::HelpButtonClick(TObject * /*Sender*/)\r\n{\r\n  DoHelp();\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TCustomDialog::DoShow()\r\n{\r\n  OKButton->TabOrder = FCount;\r\n  CancelButton->TabOrder = static_cast<short>(FCount + 1);\r\n  HelpButton->TabOrder = static_cast<short>(FCount + 2);\r\n  Changed();\r\n  TForm::DoShow();\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TCustomDialog::DoValidate()\r\n{\r\n  // noop\r\n}\r\n//---------------------------------------------------------------------------\r\nbool __fastcall TCustomDialog::CloseQuery()\r\n{\r\n  if (ModalResult == DefaultResult(this))\r\n  {\r\n    DoValidate();\r\n  }\r\n  return TForm::CloseQuery();\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TCustomDialog::RemoveCancelButton()\r\n{\r\n  CancelButton->Visible = false;\r\n  OKButton->Left = CancelButton->Left;\r\n  OKButton->Cancel = true;\r\n  DebugAssert(OKButton->Width == CancelButton->Width);\r\n  DebugAssert(OKButton->Top == CancelButton->Top);\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TCustomDialog::AddDialogButton(TButton * Button)\r\n{\r\n  Button->Parent = this;\r\n  Button->Top = OKButton->Top;\r\n  Button->Left = FHorizontalMargin;\r\n  Button->Height = OKButton->Height;\r\n  AddWinControl(Button);\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TCustomDialog::AddImage(const UnicodeString & ImageName)\r\n{\r\n  TImage * Image = new TImage(this);\r\n  Image->Name = L\"Image\";\r\n  Image->Parent = GetDefaultParent();\r\n  LoadDialogImage(Image, ImageName);\r\n  Image->SetBounds(FIndent, FPos + ScaleByTextHeight(this, 3), Image->Picture->Width, Image->Picture->Height);\r\n  FIndent += Image->Width + ScaleByTextHeight(this, 12);\r\n}\r\n//---------------------------------------------------------------------------\r\nint __fastcall TCustomDialog::GetMaxControlWidth(TControl * Control)\r\n{\r\n  return GetDefaultParent()->ClientWidth - Control->Left - FHorizontalMargin;\r\n}\r\n//---------------------------------------------------------------------------\r\nTWinControl * __fastcall TCustomDialog::GetDefaultParent()\r\n{\r\n  return (FGroupBox != NULL) ? FGroupBox : static_cast<TWinControl *>(this);\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TCustomDialog::AdjustHeight(TControl * Control)\r\n{\r\n  FPos = Control->Top + Control->Height + FControlPadding;\r\n  int Delta = (FPos - FPrePos);\r\n  ClientHeight = ClientHeight + Delta;\r\n  if (FGroupBox != NULL)\r\n  {\r\n    FGroupBox->Height = FGroupBox->Height + Delta;\r\n  }\r\n  FPrePos = FPos;\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TCustomDialog::AddWinControl(TWinControl * Control)\r\n{\r\n  Control->TabOrder = FCount;\r\n  FCount++;\r\n}\r\n//---------------------------------------------------------------------------\r\nTCheckBox * __fastcall TCustomDialog::CreateAndAddCheckBox(const UnicodeString & Caption)\r\n{\r\n  TCheckBox * CheckBox = new TCheckBox(this);\r\n  CheckBox->Caption = Caption;\r\n  AddButtonControl(CheckBox);\r\n  return CheckBox;\r\n}\r\n//---------------------------------------------------------------------------\r\nTLabel * __fastcall TCustomDialog::CreateLabel(UnicodeString Label)\r\n{\r\n  TLabel * Result = new TLabel(this);\r\n  Result->Caption = Label;\r\n  return Result;\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TCustomDialog::AddEditLikeControl(TWinControl * Edit, TLabel * Label, bool OneLine)\r\n{\r\n  Edit->Parent = GetDefaultParent();\r\n  // this updates Height property to real value\r\n  Edit->HandleNeeded();\r\n\r\n  if (Label != NULL)\r\n  {\r\n    Label->Parent = GetDefaultParent();\r\n    Label->Left = FIndent;\r\n\r\n    if (OneLine)\r\n    {\r\n      DebugAssert(Edit->Height > Label->Height);\r\n      Label->Top = FPos + ((Edit->Height - Label->Height) / 2);\r\n    }\r\n    else\r\n    {\r\n      Label->Top = FPos;\r\n\r\n      FPos += Label->Height + ScaleByTextHeight(this, 4);\r\n    }\r\n  }\r\n\r\n  Edit->Top = FPos;\r\n  if (OneLine)\r\n  {\r\n    Edit->Left = GetDefaultParent()->ClientWidth - FHorizontalMargin - Edit->Width;\r\n  }\r\n  else\r\n  {\r\n    Edit->Left = FIndent;\r\n    Edit->Width = GetMaxControlWidth(Edit);\r\n  }\r\n\r\n  AdjustHeight(Edit);\r\n\r\n  if (Label != NULL)\r\n  {\r\n    if (Label->FocusControl == NULL)\r\n    {\r\n      Label->FocusControl = Edit;\r\n    }\r\n    else\r\n    {\r\n      DebugAssert(Label->FocusControl == Edit);\r\n    }\r\n  }\r\n\r\n  AddWinControl(Edit);\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TCustomDialog::AddEdit(TCustomEdit * Edit, TLabel * Label, bool OneLine)\r\n{\r\n  AddEditLikeControl(Edit, Label, OneLine);\r\n\r\n  TEdit * PublicEdit = reinterpret_cast<TEdit *>(Edit);\r\n  if (PublicEdit->OnChange == NULL)\r\n  {\r\n    PublicEdit->OnChange = Change;\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TCustomDialog::SetUpComboBox(TCustomCombo * Combo, TStrings * Items, bool OneLine)\r\n{\r\n  if (Items != NULL)\r\n  {\r\n    Combo->Items = Items;\r\n  }\r\n\r\n  if (OneLine)\r\n  {\r\n    int Width = 0;\r\n    for (int Index = 0; Index < Combo->Items->Count; Index++)\r\n    {\r\n      Width = Max(Width, Combo->Canvas->TextWidth(Combo->Items->Strings[Index]));\r\n    }\r\n\r\n    Width += ScaleByTextHeight(Combo, 4 + 16 + 14);\r\n    Width = Max(Width, HelpButton->Width);\r\n\r\n    Combo->Width = Width;\r\n    Combo->Left = GetDefaultParent()->ClientWidth - FHorizontalMargin - Width;\r\n  }\r\n\r\n  TComboBox * PublicCombo = reinterpret_cast<TComboBox *>(Combo);\r\n  if (PublicCombo->OnChange == NULL)\r\n  {\r\n    PublicCombo->OnChange = Change;\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TCustomDialog::AddComboBox(TCustomCombo * Combo, TLabel * Label, TStrings * Items, bool OneLine)\r\n{\r\n  AddEditLikeControl(Combo, Label, OneLine);\r\n\r\n  SetUpComboBox(Combo, Items, OneLine);\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TCustomDialog::AddShortCutComboBox(TComboBox * Combo, TLabel * Label, const TShortCuts & ShortCuts)\r\n{\r\n  AddEditLikeControl(Combo, Label, true);\r\n  InitializeShortCutCombo(Combo, ShortCuts);\r\n  SetUpComboBox(Combo, NULL, true);\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TCustomDialog::ScaleButtonControl(TButtonControl * Control)\r\n{\r\n  // this updates Height property to real value\r\n  Control->HandleNeeded();\r\n  // buttons do not scale with text on their own\r\n  Control->Height = ScaleByTextHeight(Control, Control->Height);\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TCustomDialog::AddButtonControl(TButtonControl * Control)\r\n{\r\n  Control->Parent = GetDefaultParent();\r\n  Control->Left = FIndent + ScaleByTextHeight(this, 6);\r\n  Control->Top = FPos;\r\n  Control->Width = GetMaxControlWidth(Control);\r\n  ScaleButtonControl(Control);\r\n\r\n  AdjustHeight(Control);\r\n\r\n  AddWinControl(Control);\r\n\r\n  TCheckBox * PublicControl = reinterpret_cast<TCheckBox *>(Control);\r\n  if (PublicControl->OnClick == NULL)\r\n  {\r\n    PublicControl->OnClick = Change;\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TCustomDialog::AddText(TLabel * Label)\r\n{\r\n  Label->Parent = GetDefaultParent();\r\n\r\n  Label->WordWrap = true;\r\n  Label->Left = FIndent;\r\n  Label->Width = GetMaxControlWidth(Label);\r\n  Label->Top = FPos;\r\n  Label->ShowAccelChar = false;\r\n\r\n  TRect TextRect;\r\n  SetRect(&TextRect, 0, 0, Label->Width, 0);\r\n  DrawText(Label->Canvas->Handle, Label->Caption.c_str(), Label->Caption.Length() + 1, &TextRect,\r\n    DT_EXPANDTABS | DT_CALCRECT | DT_WORDBREAK | DT_NOPREFIX |\r\n    Label->DrawTextBiDiModeFlagsReadingOnly());\r\n  Label->Height = TextRect.Height();\r\n\r\n  AdjustHeight(Label);\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TCustomDialog::AddText(TStaticText * Label)\r\n{\r\n  Label->Parent = GetDefaultParent();\r\n\r\n  Label->Left = FIndent;\r\n  Label->Width = GetMaxControlWidth(Label);\r\n  Label->Top = FPos;\r\n  Label->ShowAccelChar = false;\r\n\r\n  AdjustHeight(Label);\r\n  AddWinControl(Label);\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TCustomDialog::AddSeparator()\r\n{\r\n  TBevel * Bevel = new TBevel(this);\r\n  Bevel->Parent = GetDefaultParent();\r\n\r\n  Bevel->Left = FIndent;\r\n  Bevel->Top = FPos;\r\n  Bevel->Height = 2;\r\n  Bevel->Width = GetMaxControlWidth(Bevel);\r\n\r\n  AdjustHeight(Bevel);\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TCustomDialog::StartGroup(const UnicodeString & Caption)\r\n{\r\n  if (FGroupBox != NULL)\r\n  {\r\n    FIndent = FGroupBox->Left;\r\n    FPos = FGroupBox->Top + FGroupBox->Height + FControlPadding;\r\n    FPrePos = FPos;\r\n    FGroupBox = NULL;\r\n  }\r\n\r\n  TGroupBox * GroupBox = new TGroupBox(this);\r\n  GroupBox->Parent = this;\r\n  GroupBox->Caption = Caption;\r\n\r\n  GroupBox->Left = FIndent;\r\n  GroupBox->Top = FPos;\r\n  GroupBox->Height = ScaleByTextHeight(GroupBox, 20);\r\n  GroupBox->Width = GetMaxControlWidth(GroupBox);\r\n\r\n  AdjustHeight(GroupBox);\r\n\r\n  AddWinControl(GroupBox);\r\n\r\n  FPos = ScaleByTextHeight(this, 16);\r\n  FPrePos = FPos;\r\n  FIndent = FHorizontalMargin;\r\n\r\n  FGroupBox = GroupBox;\r\n}\r\n//---------------------------------------------------------------------------\r\n//---------------------------------------------------------------------------\r\nclass TSaveSessionDialog : public TCustomDialog\r\n{\r\npublic:\r\n  __fastcall TSaveSessionDialog(TComponent* AOwner);\r\n  void __fastcall Init(bool CanSavePassword, bool NotRecommendedSavingPassword,\r\n    TStrings * AdditionalFolders);\r\n\r\n  bool __fastcall Execute(UnicodeString & SessionName, bool & SavePassword,\r\n    bool & CreateShortcut, const UnicodeString & OriginalSessionName);\r\n\r\nprotected:\r\n  virtual void __fastcall DoValidate();\r\n  virtual void __fastcall DoChange(bool & CanSubmit);\r\n\r\nprivate:\r\n  UnicodeString FOriginalSessionName;\r\n  TEdit * SessionNameEdit;\r\n  TComboBox * FolderCombo;\r\n  TCheckBox * SavePasswordCheck;\r\n  TCheckBox * CreateShortcutCheck;\r\n  UnicodeString FRootFolder;\r\n\r\n  UnicodeString __fastcall GetSessionName();\r\n};\r\n//---------------------------------------------------------------------------\r\n// Need to have an Owner argument for SafeFormCreate\r\n__fastcall TSaveSessionDialog::TSaveSessionDialog(TComponent* /*AOwner*/) :\r\n  TCustomDialog(HELP_SESSION_SAVE)\r\n{\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSaveSessionDialog::Init(bool CanSavePassword,\r\n  bool NotRecommendedSavingPassword, TStrings * AdditionalFolders)\r\n{\r\n  Caption = LoadStr(SAVE_SESSION_CAPTION);\r\n\r\n  SessionNameEdit = new TEdit(this);\r\n  AddEdit(SessionNameEdit, CreateLabel(LoadStr(SAVE_SESSION_PROMPT)));\r\n\r\n  FRootFolder = LoadStr(SAVE_SESSION_ROOT_FOLDER2);\r\n  std::unique_ptr<TStringList> Folders(new TStringList());\r\n\r\n  if (AdditionalFolders != NULL)\r\n  {\r\n    Folders->AddStrings(AdditionalFolders);\r\n  }\r\n\r\n  for (int Index = 0; Index < StoredSessions->Count; Index++)\r\n  {\r\n    TSessionData * Data = StoredSessions->Sessions[Index];\r\n    if (!Data->Special && !Data->IsWorkspace)\r\n    {\r\n      UnicodeString Folder = Data->FolderName;\r\n      if (!Folder.IsEmpty() && Folders->IndexOf(Folder) < 0)\r\n      {\r\n        Folders->Add(Folder);\r\n      }\r\n    }\r\n  }\r\n\r\n  DebugAssert(!Folders->CaseSensitive);\r\n  Folders->Sort();\r\n\r\n  FolderCombo = new TComboBox(this);\r\n  AddComboBox(FolderCombo, CreateLabel(LoadStr(SAVE_SESSION_FOLDER)));\r\n  FolderCombo->DropDownCount = Max(FolderCombo->DropDownCount, 16);\r\n  FolderCombo->Items->Add(FRootFolder);\r\n  FolderCombo->Items->AddStrings(Folders.get());\r\n\r\n  SavePasswordCheck = CreateAndAddCheckBox(\r\n    LoadStr(NotRecommendedSavingPassword ? SAVE_SESSION_PASSWORD :\r\n      (CustomWinConfiguration->UseMasterPassword ? SAVE_SESSION_PASSWORD_MASTER : SAVE_SESSION_PASSWORD_RECOMMENDED)));\r\n\r\n  CreateShortcutCheck = CreateAndAddCheckBox(LoadStr(SAVE_SITE_WORKSPACE_SHORTCUT));\r\n\r\n  EnableControl(SavePasswordCheck, CanSavePassword);\r\n}\r\n//---------------------------------------------------------------------------\r\nbool __fastcall TSaveSessionDialog::Execute(\r\n  UnicodeString & SessionName, bool & SavePassword, bool & CreateShortcut,\r\n  const UnicodeString & OriginalSessionName)\r\n{\r\n  FOriginalSessionName = OriginalSessionName;\r\n  SessionNameEdit->Text = TSessionData::ExtractLocalName(SessionName);\r\n  UnicodeString Folder = TSessionData::ExtractFolderName(SessionName);\r\n  if (Folder.IsEmpty())\r\n  {\r\n    FolderCombo->Text = FRootFolder;\r\n  }\r\n  else\r\n  {\r\n    FolderCombo->Text = Folder;\r\n  }\r\n  SavePasswordCheck->Checked = SavePassword;\r\n  CreateShortcutCheck->Checked = CreateShortcut;\r\n  bool Result = TCustomDialog::Execute();\r\n  if (Result)\r\n  {\r\n    SessionName = GetSessionName();\r\n    SavePassword = SavePasswordCheck->Checked;\r\n    CreateShortcut = CreateShortcutCheck->Checked;\r\n  }\r\n  return Result;\r\n}\r\n//---------------------------------------------------------------------------\r\nUnicodeString __fastcall TSaveSessionDialog::GetSessionName()\r\n{\r\n  UnicodeString Folder;\r\n  if (FolderCombo->Text != FRootFolder)\r\n  {\r\n    Folder = FolderCombo->Text;\r\n  }\r\n  return TSessionData::ComposePath(Folder, SessionNameEdit->Text);\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSaveSessionDialog::DoValidate()\r\n{\r\n  TSessionData::ValidateName(SessionNameEdit->Text);\r\n  SessionNameValidate(GetSessionName(), FOriginalSessionName);\r\n\r\n  UnicodeString Folder = TSessionData::ExtractFolderName(GetSessionName());\r\n  if (!Folder.IsEmpty() && StoredSessions->IsWorkspace(Folder))\r\n  {\r\n    throw Exception(FMTLOAD(WORKSPACE_NOT_FOLDER, (Folder)));\r\n  }\r\n\r\n  if (SavePasswordCheck->Enabled && SavePasswordCheck->Checked &&\r\n      CustomWinConfiguration->UseMasterPassword)\r\n  {\r\n    CustomWinConfiguration->AskForMasterPasswordIfNotSet();\r\n  }\r\n\r\n  TCustomDialog::DoValidate();\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSaveSessionDialog::DoChange(bool & CanSubmit)\r\n{\r\n  CanSubmit = !SessionNameEdit->Text.IsEmpty();\r\n  TCustomDialog::DoChange(CanSubmit);\r\n}\r\n//---------------------------------------------------------------------------\r\nTSessionData * __fastcall DoSaveSession(TSessionData * SessionData,\r\n  TSessionData * OriginalSession, bool ForceDialog,\r\n  TStrings * AdditionalFolders)\r\n{\r\n  bool SavePassword = false;\r\n  bool * PSavePassword;\r\n  bool NotRecommendedSavingPassword =\r\n    !CustomWinConfiguration->UseMasterPassword &&\r\n    !SameText(SessionData->UserName, AnonymousUserName);\r\n\r\n  if (Configuration->DisablePasswordStoring ||\r\n      !SessionData->HasAnySessionPassword())\r\n  {\r\n    PSavePassword = NULL;\r\n  }\r\n  else\r\n  {\r\n    PSavePassword = &SavePassword;\r\n    SavePassword =\r\n      ((OriginalSession != NULL) && OriginalSession->HasAnySessionPassword()) ||\r\n      !NotRecommendedSavingPassword;\r\n  }\r\n\r\n  UnicodeString SessionName = SessionData->SessionName;\r\n\r\n  bool Result;\r\n  bool CreateShortcut = false;\r\n  if (!ForceDialog && ((PSavePassword == NULL) || SavePassword))\r\n  {\r\n    // This is probably here to ask before session is started saving.\r\n    // Otherwise we would ask implicitly, when saving passwords, but at that moment,\r\n    // part of the site is already saved and when the user cancel the prompt it's too late.\r\n    CustomWinConfiguration->AskForMasterPasswordIfNotSetAndNeededToPersistSessionData(SessionData);\r\n    Result = true;\r\n  }\r\n  else\r\n  {\r\n    // This can be a standalone dialog when used with save URL (from GetLoginData)\r\n    TSaveSessionDialog * Dialog = SafeFormCreate<TSaveSessionDialog>();\r\n    try\r\n    {\r\n      Dialog->Init((PSavePassword != NULL), NotRecommendedSavingPassword, AdditionalFolders);\r\n      Result = Dialog->Execute(SessionName, SavePassword, CreateShortcut, SessionData->Name);\r\n    }\r\n    __finally\r\n    {\r\n      delete Dialog;\r\n    }\r\n  }\r\n\r\n  TSessionData * NewSession = NULL;\r\n  if (Result)\r\n  {\r\n    if ((PSavePassword != NULL) && !SavePassword)\r\n    {\r\n      SessionData->ClearSessionPasswords();\r\n    }\r\n\r\n    NewSession =\r\n      StoredSessions->NewSession(SessionName, SessionData);\r\n    // modified only, explicit\r\n    StoredSessions->Save(false, true);\r\n    if (!SessionData->HostKey.IsEmpty())\r\n    {\r\n      SessionData->CacheHostKeyIfNotCached();\r\n    }\r\n\r\n    if (CreateShortcut)\r\n    {\r\n      TOperationVisualizer Visualizer;\r\n      UnicodeString AdditionalParams =\r\n        TProgramParams::FormatSwitch(DESKTOP_SWITCH) + L\" \" +\r\n        TProgramParams::FormatSwitch(UPLOAD_IF_ANY_SWITCH);\r\n      CreateDesktopSessionShortCut(SessionName, L\"\", AdditionalParams, -1, SITE_ICON);\r\n    }\r\n  }\r\n\r\n  return NewSession;\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall SessionNameValidate(const UnicodeString & Text,\r\n  const UnicodeString & OriginalName)\r\n{\r\n  TSessionData::ValidatePath(Text);\r\n\r\n  DebugAssert(StoredSessions);\r\n  TSessionData * Data = (TSessionData *)StoredSessions->FindByName(Text);\r\n  if (Data && Data->Special)\r\n  {\r\n    MessageDialog(FMTLOAD(CANNOT_OVERWRITE_SPECIAL_SESSION, (Text)),\r\n      qtError, qaOK, HELP_NONE);\r\n    Abort();\r\n  }\r\n  else if ((Data != NULL) && !Data->IsSameName(OriginalName) &&\r\n    MessageDialog(MainInstructions(FMTLOAD(CONFIRM_OVERWRITE_SESSION, (Text))),\r\n      qtConfirmation, qaYes | qaNo, HELP_SESSION_SAVE_OVERWRITE) != qaYes)\r\n  {\r\n    Abort();\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\n//---------------------------------------------------------------------------\r\nclass TSaveWorkspaceDialog : public TCustomDialog\r\n{\r\npublic:\r\n  __fastcall TSaveWorkspaceDialog(bool CanSavePasswords,\r\n    bool NotRecommendedSavingPasswords);\r\n\r\n  bool __fastcall Execute(\r\n    UnicodeString & WorkspaceName, bool & SavePasswords, bool & CreateShortcut,\r\n    bool & EnableAutoSave);\r\n\r\nprotected:\r\n  virtual void __fastcall DoValidate();\r\n  virtual void __fastcall DoChange(bool & CanSubmit);\r\n\r\nprivate:\r\n  TComboBox * WorkspaceNameCombo;\r\n  TCheckBox * SavePasswordsCheck;\r\n  TCheckBox * CreateShortcutCheck;\r\n  TCheckBox * EnableAutoSaveCheck;\r\n};\r\n//---------------------------------------------------------------------------\r\n__fastcall TSaveWorkspaceDialog::TSaveWorkspaceDialog(\r\n    bool CanSavePasswords, bool NotRecommendedSavingPasswords) :\r\n  TCustomDialog(HELP_WORKSPACE_SAVE)\r\n{\r\n  Caption = LoadStr(SAVE_WORKSPACE_CAPTION);\r\n\r\n  WorkspaceNameCombo = new TComboBox(this);\r\n  WorkspaceNameCombo->AutoComplete = false;\r\n  AddComboBox(WorkspaceNameCombo, CreateLabel(LoadStr(SAVE_WORKSPACE_PROMPT)));\r\n  WorkspaceNameCombo->DropDownCount = Max(WorkspaceNameCombo->DropDownCount, 16);\r\n\r\n  std::unique_ptr<TStrings> Workspaces(StoredSessions->GetWorkspaces());\r\n  WorkspaceNameCombo->Items->AddStrings(Workspaces.get());\r\n\r\n  SavePasswordsCheck = CreateAndAddCheckBox(\r\n    LoadStr(NotRecommendedSavingPasswords ? SAVE_WORKSPACE_PASSWORDS :\r\n      (CustomWinConfiguration->UseMasterPassword ?\r\n        SAVE_WORKSPACE_PASSWORDS_MASTER : SAVE_WORKSPACE_PASSWORDS_RECOMMENDED)));\r\n\r\n  EnableControl(SavePasswordsCheck, CanSavePasswords);\r\n\r\n  CreateShortcutCheck = CreateAndAddCheckBox(LoadStr(SAVE_SITE_WORKSPACE_SHORTCUT));\r\n\r\n  EnableAutoSaveCheck = CreateAndAddCheckBox(LoadStr(SAVE_WORKSPACE_AUTO));\r\n}\r\n//---------------------------------------------------------------------------\r\nbool __fastcall TSaveWorkspaceDialog::Execute(\r\n  UnicodeString & WorkspaceName, bool & SavePasswords, bool & CreateShortcut,\r\n  bool & EnableAutoSave)\r\n{\r\n  WorkspaceNameCombo->Text = WorkspaceName;\r\n  SavePasswordsCheck->Checked = SavePasswords;\r\n  CreateShortcutCheck->Checked = CreateShortcut;\r\n  EnableAutoSaveCheck->Checked = EnableAutoSave;\r\n  bool Result = TCustomDialog::Execute();\r\n  if (Result)\r\n  {\r\n    WorkspaceName = WorkspaceNameCombo->Text;\r\n    SavePasswords = SavePasswordsCheck->Checked;\r\n    CreateShortcut = CreateShortcutCheck->Checked;\r\n    EnableAutoSave = EnableAutoSaveCheck->Checked;\r\n  }\r\n  return Result;\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSaveWorkspaceDialog::DoValidate()\r\n{\r\n  TSessionData::ValidateName(WorkspaceNameCombo->Text);\r\n\r\n  if (StoredSessions->IsFolder(WorkspaceNameCombo->Text))\r\n  {\r\n    throw Exception(FMTLOAD(FOLDER_NOT_WORKSPACE, (WorkspaceNameCombo->Text)));\r\n  }\r\n\r\n  if (SavePasswordsCheck->Enabled && SavePasswordsCheck->Checked &&\r\n      CustomWinConfiguration->UseMasterPassword)\r\n  {\r\n    CustomWinConfiguration->AskForMasterPasswordIfNotSet();\r\n  }\r\n\r\n  TCustomDialog::DoValidate();\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSaveWorkspaceDialog::DoChange(bool & CanSubmit)\r\n{\r\n  CanSubmit = !WorkspaceNameCombo->Text.IsEmpty();\r\n\r\n  TCustomDialog::DoChange(CanSubmit);\r\n}\r\n//---------------------------------------------------------------------------\r\nbool __fastcall DoSaveWorkspaceDialog(UnicodeString & WorkspaceName,\r\n  bool * SavePasswords, bool NotRecommendedSavingPasswords,\r\n  bool & CreateShortcut, bool & EnableAutoSave)\r\n{\r\n  std::unique_ptr<TSaveWorkspaceDialog> Dialog(\r\n    new TSaveWorkspaceDialog((SavePasswords != NULL), NotRecommendedSavingPasswords));\r\n\r\n  bool Dummy = false;\r\n  if (SavePasswords == NULL)\r\n  {\r\n    SavePasswords = &Dummy;\r\n  }\r\n  return\r\n    Dialog->Execute(\r\n      WorkspaceName, *SavePasswords, CreateShortcut, EnableAutoSave);\r\n}\r\n//---------------------------------------------------------------------------\r\n//---------------------------------------------------------------------------\r\nclass TShortCutDialog : public TCustomDialog\r\n{\r\npublic:\r\n  __fastcall TShortCutDialog(const TShortCuts & ShortCuts, UnicodeString HelpKeyword);\r\n\r\n  bool __fastcall Execute(TShortCut & ShortCut);\r\n\r\nprivate:\r\n  TComboBox * ShortCutCombo;\r\n};\r\n//---------------------------------------------------------------------------\r\n__fastcall TShortCutDialog::TShortCutDialog(const TShortCuts & ShortCuts, UnicodeString HelpKeyword) :\r\n  TCustomDialog(HelpKeyword)\r\n{\r\n  Caption = LoadStr(SHORTCUT_CAPTION);\r\n\r\n  ShortCutCombo = new TComboBox(this);\r\n  AddShortCutComboBox(ShortCutCombo, CreateLabel(LoadStr(SHORTCUT_LABEL)), ShortCuts);\r\n}\r\n//---------------------------------------------------------------------------\r\nbool __fastcall TShortCutDialog::Execute(TShortCut & ShortCut)\r\n{\r\n  SetShortCutCombo(ShortCutCombo, ShortCut);\r\n  bool Result = TCustomDialog::Execute();\r\n  if (Result)\r\n  {\r\n    ShortCut = GetShortCutCombo(ShortCutCombo);\r\n  }\r\n  return Result;\r\n}\r\n//---------------------------------------------------------------------------\r\nbool __fastcall DoShortCutDialog(TShortCut & ShortCut,\r\n  const TShortCuts & ShortCuts, UnicodeString HelpKeyword)\r\n{\r\n  bool Result;\r\n  TShortCutDialog * Dialog = new TShortCutDialog(ShortCuts, HelpKeyword);\r\n  try\r\n  {\r\n    Result = Dialog->Execute(ShortCut);\r\n  }\r\n  __finally\r\n  {\r\n    delete Dialog;\r\n  }\r\n  return Result;\r\n}\r\n//---------------------------------------------------------------------------\r\n//---------------------------------------------------------------------------\r\nclass TRemoteMoveDialog : public TCustomDialog\r\n{\r\npublic:\r\n  __fastcall TRemoteMoveDialog(bool Multi);\r\n\r\n  bool __fastcall Execute(UnicodeString & Target, UnicodeString & FileMask);\r\n\r\nprotected:\r\n  DYNAMIC void __fastcall DoShow();\r\n  virtual void __fastcall DoValidate();\r\n  UnicodeString __fastcall GetFileMask();\r\n\r\nprivate:\r\n  THistoryComboBox * Combo;\r\n  bool FMulti;\r\n};\r\n//---------------------------------------------------------------------------\r\n__fastcall TRemoteMoveDialog::TRemoteMoveDialog(bool Multi) :\r\n  TCustomDialog(HELP_REMOTE_MOVE)\r\n{\r\n  Caption = LoadStr(REMOTE_MOVE_TITLE);\r\n  // The same as TRemoteTransferDialog\r\n  ClientWidth = ScaleByTextHeight(this, 420);\r\n\r\n  FMulti = Multi;\r\n\r\n  AddImage(L\"Move To\");\r\n\r\n  Combo = new THistoryComboBox(this);\r\n  Combo->AutoComplete = false;\r\n  AddComboBox(Combo, CreateLabel(LoadStr(REMOTE_TRANSFER_PROMPT2)));\r\n}\r\n//---------------------------------------------------------------------------\r\nbool __fastcall TRemoteMoveDialog::Execute(UnicodeString & Target, UnicodeString & FileMask)\r\n{\r\n  Combo->Items = CustomWinConfiguration->History[L\"RemoteTarget\"];\r\n  Combo->Text = UnixIncludeTrailingBackslash(Target) + FileMask;\r\n  bool Result = TCustomDialog::Execute();\r\n  if (Result)\r\n  {\r\n    Target = UnixExtractFilePath(Combo->Text);\r\n    FileMask = GetFileMask();\r\n    Combo->SaveToHistory();\r\n    CustomWinConfiguration->History[L\"RemoteTarget\"] = Combo->Items;\r\n  }\r\n  return Result;\r\n}\r\n//---------------------------------------------------------------------------\r\nUnicodeString __fastcall TRemoteMoveDialog::GetFileMask()\r\n{\r\n  return UnixExtractFileName(Combo->Text);\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TRemoteMoveDialog::DoShow()\r\n{\r\n  TCustomDialog::DoShow();\r\n  InstallPathWordBreakProc(Combo);\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TRemoteMoveDialog::DoValidate()\r\n{\r\n  if (!IsFileNameMask(GetFileMask()) && FMulti)\r\n  {\r\n    UnicodeString Message =\r\n      FormatMultiFilesToOneConfirmation(Combo->Text, true);\r\n    if (MessageDialog(Message, qtConfirmation, qaOK | qaCancel, HELP_NONE) == qaCancel)\r\n    {\r\n      Abort();\r\n    }\r\n  }\r\n\r\n  TCustomDialog::DoValidate();\r\n}\r\n//---------------------------------------------------------------------------\r\nbool __fastcall DoRemoteMoveDialog(bool Multi, UnicodeString & Target, UnicodeString & FileMask)\r\n{\r\n  std::unique_ptr<TRemoteMoveDialog> Dialog(new TRemoteMoveDialog(Multi));\r\n  return Dialog->Execute(Target, FileMask);\r\n}\r\n//---------------------------------------------------------------------------\r\n//---------------------------------------------------------------------------\r\nclass TCustomCommandOptionsDialog : public TCustomDialog\r\n{\r\npublic:\r\n  __fastcall TCustomCommandOptionsDialog(\r\n    const TCustomCommandType * Command, TStrings * CustomCommandOptions, unsigned int Flags,\r\n    TCustomCommand * CustomCommandForOptions, const UnicodeString & Site, const TShortCuts * ShortCuts);\r\n\r\n  bool __fastcall Execute(TShortCut * ShortCut);\r\n\r\nprotected:\r\n  virtual void __fastcall DoHelp();\r\n  DYNAMIC void __fastcall DoShow();\r\n\r\nprivate:\r\n  const TCustomCommandType * FCommand;\r\n  TStrings * FCustomCommandOptions;\r\n  std::vector<TControl *> FControls;\r\n  std::vector<std::vector<UnicodeString> > FValues;\r\n  unsigned int FFlags;\r\n  UnicodeString FSite;\r\n  TComboBox * FShortCutCombo;\r\n\r\n  UnicodeString __fastcall HistoryKey(const TCustomCommandType::TOption & Option);\r\n  THistoryComboBox * __fastcall CreateHistoryComboBox(const TCustomCommandType::TOption & Option, const UnicodeString & Value);\r\n  void __fastcall BrowseButtonClick(TObject * Sender);\r\n  void __fastcall LinkLabelClick(TObject * Sender);\r\n  UnicodeString __fastcall SaveHistoryComboBoxValue(TControl * Control, const TCustomCommandType::TOption & Option);\r\n  void __fastcall AddOptionComboBox(\r\n    TComboBox * ComboBox, const UnicodeString & Value, const TCustomCommandType::TOption & Option,\r\n    std::vector<UnicodeString> & Values);\r\n  UnicodeString __fastcall GetComboBoxValue(TControl * Control, const UnicodeString & Default);\r\n  int __fastcall GetOptionIndex(TControl * Control);\r\n  int __fastcall GetControlIndex(TControl * Control);\r\n};\r\n//---------------------------------------------------------------------------\r\n__fastcall TCustomCommandOptionsDialog::TCustomCommandOptionsDialog(\r\n    const TCustomCommandType * Command, TStrings * CustomCommandOptions,\r\n    unsigned int Flags, TCustomCommand * CustomCommandForOptions,\r\n    const UnicodeString & Site, const TShortCuts * ShortCuts) :\r\n  TCustomDialog(HELP_EXTENSION_OPTIONS)\r\n{\r\n  FCommand = Command;\r\n  FFlags = Flags;\r\n  FCustomCommandOptions = CustomCommandOptions;\r\n  FSite = Site;\r\n  Caption = StripEllipsis(StripHotkey(FCommand->Name));\r\n  Width = ScaleByTextHeight(this, 400);\r\n\r\n  bool HasGroups = false;\r\n  int ControlIndex = 0;\r\n  for (int OptionIndex = 0; OptionIndex < FCommand->OptionsCount; OptionIndex++)\r\n  {\r\n    const TCustomCommandType::TOption & Option = FCommand->GetOption(OptionIndex);\r\n\r\n    if ((Option.Flags & FFlags) != 0)\r\n    {\r\n      UnicodeString OptionKey = FCommand->GetOptionKey(Option, FSite);\r\n      UnicodeString Value;\r\n      if ((CustomCommandForOptions != NULL) &&\r\n          Option.HasPatterns(CustomCommandForOptions))\r\n      {\r\n        Value = CustomCommandForOptions->Complete(Option.Default, true);\r\n      }\r\n      else\r\n      {\r\n        if (FCustomCommandOptions->IndexOfName(OptionKey) >= 0)\r\n        {\r\n          Value = FCustomCommandOptions->Values[OptionKey];\r\n        }\r\n        else\r\n        {\r\n          Value = Option.Default;\r\n        }\r\n      }\r\n\r\n      int Tag = (OptionIndex << 16) + ControlIndex;\r\n      TControl * Control = NULL;\r\n      std::vector<UnicodeString> Values;\r\n      if (Option.Kind == TCustomCommandType::okUnknown)\r\n      {\r\n        Control = NULL;\r\n      }\r\n      else if (Option.Kind == TCustomCommandType::okLabel)\r\n      {\r\n        TLabel * Label = CreateLabel(Option.Caption);\r\n        AddText(Label);\r\n        Control = Label;\r\n      }\r\n      else if (Option.Kind == TCustomCommandType::okLink)\r\n      {\r\n        TStaticText * Label = new TStaticText(this);\r\n        Label->Caption = Option.Caption;\r\n        if (IsHttpOrHttpsUrl(Label->Caption))\r\n        {\r\n          Label->Caption = SecureUrl(Label->Caption);\r\n          LinkLabel(Label);\r\n          Label->TabStop = true;\r\n        }\r\n        else if (!Option.Default.IsEmpty() && IsHttpOrHttpsUrl(Option.Default))\r\n        {\r\n          Label->OnClick = LinkLabelClick;\r\n          LinkLabel(Label);\r\n          Label->TabStop = true;\r\n        }\r\n        else\r\n        {\r\n          // keep it plain text, as we have no URL\r\n        }\r\n        AddText(Label);\r\n        Control = Label;\r\n      }\r\n      else if (Option.Kind == TCustomCommandType::okGroup)\r\n      {\r\n        StartGroup(Option.Caption);\r\n        HasGroups = true;\r\n      }\r\n      else if (Option.Kind == TCustomCommandType::okSeparator)\r\n      {\r\n        AddSeparator();\r\n      }\r\n      else if (Option.Kind == TCustomCommandType::okTextBox)\r\n      {\r\n        Control = CreateHistoryComboBox(Option, Value);\r\n      }\r\n      else if (Option.Kind == TCustomCommandType::okFile)\r\n      {\r\n        THistoryComboBox * ComboBox = CreateHistoryComboBox(Option, Value);\r\n        TButton * Button = new TButton(this);\r\n        Button->Parent = GetDefaultParent();\r\n        Button->Width = HelpButton->Width;\r\n        Button->Left = GetDefaultParent()->ClientWidth - Button->Width - HorizontalMargin;\r\n        ComboBox->Width = Button->Left - ComboBox->Left - ScaleByTextHeight(this, 6);\r\n        Button->Top = ComboBox->Top - ScaleByTextHeight(this, 2);\r\n        Button->Tag = Tag;\r\n        Button->Caption = LoadStr(EXTENSION_OPTIONS_BROWSE);\r\n        Button->OnClick = BrowseButtonClick;\r\n        ScaleButtonControl(Button);\r\n        AddWinControl(Button);\r\n        Control = ComboBox;\r\n      }\r\n      else if (Option.Kind == TCustomCommandType::okDropDownList)\r\n      {\r\n        TComboBox * ComboBox = new TComboBox(this);\r\n        ComboBox->Style = csDropDownList;\r\n\r\n        AddOptionComboBox(ComboBox, Value, Option, Values);\r\n\r\n        Control = ComboBox;\r\n      }\r\n      else if (Option.Kind == TCustomCommandType::okComboBox)\r\n      {\r\n        TComboBox * ComboBox = new TComboBox(this);\r\n        ComboBox->Style = csDropDown;\r\n\r\n        AddOptionComboBox(ComboBox, Value, Option, Values);\r\n        if (ComboBox->ItemIndex < 0)\r\n        {\r\n          ComboBox->Text = Value;\r\n        }\r\n\r\n        Control = ComboBox;\r\n      }\r\n      else if (Option.Kind == TCustomCommandType::okCheckBox)\r\n      {\r\n        TCheckBox * CheckBox = CreateAndAddCheckBox(Option.Caption);\r\n\r\n        CheckBox->Checked =\r\n          (Option.Params.size() >= 1) &&\r\n          (Value == Option.Params[0]);\r\n\r\n        Control = CheckBox;\r\n      }\r\n      else\r\n      {\r\n        DebugFail();\r\n      }\r\n\r\n      if (Control != NULL)\r\n      {\r\n        Control->Tag = Tag;\r\n      }\r\n      FControls.push_back(Control);\r\n      FValues.push_back(Values);\r\n      ControlIndex++;\r\n      DebugAssert(static_cast<int>(FControls.size()) == ControlIndex);\r\n    }\r\n  }\r\n\r\n  if (ShortCuts != NULL)\r\n  {\r\n    if (HasGroups)\r\n    {\r\n      StartGroup(LoadStr(EXTENSION_GENERAL_GROUP));\r\n    }\r\n    else if (ControlIndex > 0)\r\n    {\r\n      AddSeparator();\r\n    }\r\n    FShortCutCombo = new TComboBox(this);\r\n    AddShortCutComboBox(FShortCutCombo, CreateLabel(LoadStr(EXTENSION_SHORTCUT)), *ShortCuts);\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TCustomCommandOptionsDialog::AddOptionComboBox(\r\n  TComboBox * ComboBox, const UnicodeString & Value, const TCustomCommandType::TOption & Option, std::vector<UnicodeString> & Values)\r\n{\r\n  std::unique_ptr<TStringList> Items(new TStringList());\r\n  int ItemIndex = -1;\r\n\r\n  TCustomCommandType::TOption::TParams::const_iterator ParamI = Option.Params.begin();\r\n  while (ParamI != Option.Params.end())\r\n  {\r\n    UnicodeString Item = (*ParamI);\r\n    int P = Item.Pos(L\"=\");\r\n    UnicodeString ParamValue;\r\n    if (P > 0)\r\n    {\r\n      ParamValue = Item.SubString(1, P - 1);\r\n      Item.Delete(1, P);\r\n    }\r\n    else\r\n    {\r\n      ParamValue = Item;\r\n    }\r\n    Item = WinConfiguration->ExtensionStringTranslation(FCommand->Id, Item);\r\n    Items->Add(Item);\r\n    if (Value == ParamValue)\r\n    {\r\n      ItemIndex = Items->Count - 1;\r\n    }\r\n    Values.push_back(ParamValue);\r\n    ParamI++;\r\n  }\r\n\r\n  AddComboBox(ComboBox, CreateLabel(Option.Caption), Items.get(), true);\r\n\r\n  ComboBox->ItemIndex = ItemIndex;\r\n}\r\n//---------------------------------------------------------------------------\r\nint __fastcall TCustomCommandOptionsDialog::GetOptionIndex(TControl * Control)\r\n{\r\n  return (Control->Tag >> 16);\r\n}\r\n//---------------------------------------------------------------------------\r\nint __fastcall TCustomCommandOptionsDialog::GetControlIndex(TControl * Control)\r\n{\r\n  return (Control->Tag & 0xFFFF);\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TCustomCommandOptionsDialog::LinkLabelClick(TObject * Sender)\r\n{\r\n  TStaticText * Label = DebugNotNull(dynamic_cast<TStaticText *>(Sender));\r\n  const TCustomCommandType::TOption & Option = FCommand->GetOption(GetOptionIndex(Label));\r\n  OpenBrowser(SecureUrl(Option.Default));\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TCustomCommandOptionsDialog::BrowseButtonClick(TObject * Sender)\r\n{\r\n  TButton * Button = DebugNotNull(dynamic_cast<TButton *>(Sender));\r\n  int OptionIndex = GetOptionIndex(Button);\r\n  const TCustomCommandType::TOption & Option = FCommand->GetOption(OptionIndex);\r\n  int ControlIndex = GetControlIndex(Button);\r\n  THistoryComboBox * ComboBox = dynamic_cast<THistoryComboBox *>(FControls[ControlIndex]);\r\n\r\n  std::unique_ptr<TOpenDialog> OpenDialog(new TOpenDialog(Application));\r\n\r\n  UnicodeString Title;\r\n  if (!Option.FileCaption.IsEmpty())\r\n  {\r\n    Title = Option.FileCaption;\r\n  }\r\n  else\r\n  {\r\n    UnicodeString Caption = Option.Caption;\r\n    Caption = StripHotkey(Caption);\r\n    if (!Caption.IsEmpty() && (Caption[Caption.Length()] == L':'))\r\n    {\r\n      Caption.SetLength(Caption.Length() - 1);\r\n    }\r\n    Title = FMTLOAD(EXTENSION_OPTIONS_BROWSE_TITLE, (Caption));\r\n  }\r\n  OpenDialog->Title = Title;\r\n\r\n  UnicodeString Value;\r\n  if (ComboBox->Text.IsEmpty())\r\n  {\r\n    Value = Option.FileInitial;\r\n  }\r\n  else\r\n  {\r\n    Value = ComboBox->Text;\r\n  }\r\n  UnicodeString ExpandedValue = ExpandEnvironmentVariables(Value);\r\n  OpenDialog->FileName = ExpandedValue;\r\n  UnicodeString InitialDir = ExtractFilePath(ExpandedValue);\r\n  if (!InitialDir.IsEmpty())\r\n  {\r\n    OpenDialog->InitialDir = InitialDir;\r\n  }\r\n  OpenDialog->Filter = Option.FileFilter;\r\n  OpenDialog->DefaultExt = Option.FileExt;\r\n\r\n  if (OpenDialog->Execute())\r\n  {\r\n    if (OpenDialog->FileName != ExpandedValue)\r\n    {\r\n      ComboBox->Text = OpenDialog->FileName;\r\n    }\r\n    // If user just confirms the initial value, persist it\r\n    else if (ComboBox->Text.IsEmpty())\r\n    {\r\n      DebugAssert(Option.FileInitial == Value);\r\n      ComboBox->Text = Value;\r\n    }\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\nTHistoryComboBox * __fastcall TCustomCommandOptionsDialog::CreateHistoryComboBox(\r\n  const TCustomCommandType::TOption & Option, const UnicodeString & Value)\r\n{\r\n  THistoryComboBox * ComboBox = new THistoryComboBox(this);\r\n  ComboBox->AutoComplete = false;\r\n  AddComboBox(ComboBox, CreateLabel(Option.Caption));\r\n  ComboBox->Items = CustomWinConfiguration->History[HistoryKey(Option)];\r\n  ComboBox->Text = Value;\r\n  return ComboBox;\r\n}\r\n//---------------------------------------------------------------------------\r\nUnicodeString __fastcall TCustomCommandOptionsDialog::HistoryKey(const TCustomCommandType::TOption & Option)\r\n{\r\n  UnicodeString Result = FCommand->GetOptionKey(Option, FSite);\r\n  Result = CustomWinConfiguration->GetValidHistoryKey(Result);\r\n  return L\"CustomCommandOption_\" + Result;\r\n}\r\n//---------------------------------------------------------------------------\r\nbool __fastcall TCustomCommandOptionsDialog::Execute(TShortCut * ShortCut)\r\n{\r\n  if (ShortCut != NULL)\r\n  {\r\n    SetShortCutCombo(FShortCutCombo, *ShortCut);\r\n  }\r\n\r\n  bool Result = TCustomDialog::Execute();\r\n\r\n  if (Result)\r\n  {\r\n    int ControlIndex = 0;\r\n    for (int OptionIndex = 0; OptionIndex < FCommand->OptionsCount; OptionIndex++)\r\n    {\r\n      const TCustomCommandType::TOption & Option = FCommand->GetOption(OptionIndex);\r\n      if ((Option.Flags & FFlags) != 0)\r\n      {\r\n        if ((Option.Kind != TCustomCommandType::okUnknown) &&\r\n            Option.IsControl)\r\n        {\r\n          UnicodeString OptionKey = FCommand->GetOptionKey(Option, FSite);\r\n\r\n          TControl * Control = FControls[ControlIndex];\r\n\r\n          UnicodeString Value;\r\n          if (Option.Kind == TCustomCommandType::okTextBox)\r\n          {\r\n            Value = SaveHistoryComboBoxValue(Control, Option);\r\n          }\r\n          else if (Option.Kind == TCustomCommandType::okFile)\r\n          {\r\n            Value = SaveHistoryComboBoxValue(Control, Option);\r\n          }\r\n          else if (Option.Kind == TCustomCommandType::okDropDownList)\r\n          {\r\n            Value = GetComboBoxValue(Control, Option.Default);\r\n          }\r\n          else if (Option.Kind == TCustomCommandType::okComboBox)\r\n          {\r\n            TComboBox * ComboBox = DebugNotNull(dynamic_cast<TComboBox *>(Control));\r\n            Value = GetComboBoxValue(Control, ComboBox->Text);\r\n          }\r\n          else if (Option.Kind == TCustomCommandType::okCheckBox)\r\n          {\r\n            TCheckBox * CheckBox = DebugNotNull(dynamic_cast<TCheckBox *>(Control));\r\n            int Index = (CheckBox->Checked ? 0 : 1);\r\n            Value = (Index < static_cast<int>(Option.Params.size())) ? Option.Params[Index] : UnicodeString();\r\n          }\r\n          else\r\n          {\r\n            DebugFail();\r\n          }\r\n\r\n          // The default value setter deletes the \"name\" when the value is empty.\r\n          // It would cause us to fall back to the default value, but we want to remember the empty value.\r\n          SetStringValueEvenIfEmpty(FCustomCommandOptions, OptionKey, Value);\r\n        }\r\n\r\n        ControlIndex++;\r\n      }\r\n    }\r\n\r\n    if (ShortCut != NULL)\r\n    {\r\n      *ShortCut = GetShortCutCombo(FShortCutCombo);\r\n    }\r\n  }\r\n\r\n  return Result;\r\n}\r\n//---------------------------------------------------------------------------\r\nUnicodeString __fastcall TCustomCommandOptionsDialog::GetComboBoxValue(\r\n  TControl * Control, const UnicodeString & Default)\r\n{\r\n  TComboBox * ComboBox = DebugNotNull(dynamic_cast<TComboBox *>(Control));\r\n  UnicodeString Result;\r\n  if (ComboBox->ItemIndex < 0)\r\n  {\r\n    Result = Default;\r\n  }\r\n  else\r\n  {\r\n    Result = FValues[GetControlIndex(Control)][ComboBox->ItemIndex];\r\n  }\r\n  return Result;\r\n}\r\n//---------------------------------------------------------------------------\r\nUnicodeString __fastcall TCustomCommandOptionsDialog::SaveHistoryComboBoxValue(\r\n  TControl * Control, const TCustomCommandType::TOption & Option)\r\n{\r\n  THistoryComboBox * ComboBox = DebugNotNull(dynamic_cast<THistoryComboBox *>(Control));\r\n  ComboBox->SaveToHistory();\r\n  CustomWinConfiguration->History[HistoryKey(Option)] = ComboBox->Items;\r\n  return ComboBox->Text;\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TCustomCommandOptionsDialog::DoHelp()\r\n{\r\n  UnicodeString HelpPage;\r\n  if (!FCommand->OptionsPage.IsEmpty())\r\n  {\r\n    HelpPage = FCommand->OptionsPage;\r\n  }\r\n  else\r\n  {\r\n    HelpPage = FCommand->HomePage;\r\n  }\r\n\r\n  if (!HelpPage.IsEmpty())\r\n  {\r\n    OpenBrowser(HelpPage);\r\n  }\r\n  else\r\n  {\r\n    TCustomDialog::DoHelp();\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TCustomCommandOptionsDialog::DoShow()\r\n{\r\n  TCustomDialog::DoShow();\r\n\r\n  int ControlIndex = 0;\r\n  for (int OptionIndex = 0; OptionIndex < FCommand->OptionsCount; OptionIndex++)\r\n  {\r\n    const TCustomCommandType::TOption & Option = FCommand->GetOption(OptionIndex);\r\n\r\n    if ((Option.Flags & FFlags) != 0)\r\n    {\r\n      if (Option.Kind == TCustomCommandType::okFile)\r\n      {\r\n        TControl * Control = FControls[ControlIndex];\r\n        InstallPathWordBreakProc(DebugNotNull(dynamic_cast<TWinControl *>(Control)));\r\n      }\r\n      ControlIndex++;\r\n    }\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\nbool __fastcall DoCustomCommandOptionsDialog(\r\n  const TCustomCommandType * Command, TStrings * CustomCommandOptions, TShortCut * ShortCut,\r\n  unsigned int Flags, TCustomCommand * CustomCommandForOptions,\r\n  const UnicodeString & Site, const TShortCuts * ShortCuts)\r\n{\r\n  std::unique_ptr<TCustomCommandOptionsDialog> Dialog(\r\n    new TCustomCommandOptionsDialog(Command, CustomCommandOptions, Flags, CustomCommandForOptions, Site, ShortCuts));\r\n  return Dialog->Execute(ShortCut);\r\n}\r\n//---------------------------------------------------------------------------\r\n//---------------------------------------------------------------------------\r\nclass TUsageStatisticsDialog : public TCustomDialog\r\n{\r\npublic:\r\n  __fastcall TUsageStatisticsDialog();\r\n\r\nprotected:\r\n  virtual void __fastcall DoChange(bool & CanSubmit);\r\n\r\nprivate:\r\n  TEdit * FilterEdit;\r\n  TMemo * UsageMemo;\r\n  TButton * ClipboardButton;\r\n\r\n  void __fastcall ClipboardButtonClick(TObject * Sender);\r\n};\r\n//---------------------------------------------------------------------------\r\n__fastcall TUsageStatisticsDialog::TUsageStatisticsDialog() :\r\n  TCustomDialog(HELP_USAGE)\r\n{\r\n  Caption = LoadStr(USAGE_CAPTION);\r\n  Width = ScaleByTextHeight(this, 400);\r\n\r\n  TLabel * Label = new TLabel(this);\r\n  // UnformatMessage is called, because previously, ** markup was used and translations may still contain that\r\n  Label->Caption = UnformatMessage(LoadStr(USAGE_DATA2));\r\n  AddText(Label);\r\n\r\n  FilterEdit = new TEdit(this);\r\n  FilterEdit->Width = ScaleByTextHeight(this, 250);\r\n  TLabel * FilterLabel = new TLabel(this);\r\n  FilterLabel->Caption = LoadStr(USAGE_FILTER);\r\n  AddEdit(FilterEdit, FilterLabel, true);\r\n\r\n  UsageMemo = new TMemo(this);\r\n  UsageMemo->Height = ScaleByTextHeight(this, 300);\r\n  UsageMemo->ScrollBars = ssVertical;\r\n  AddEdit(UsageMemo, NULL);\r\n  ReadOnlyControl(UsageMemo);\r\n\r\n  ClipboardButton = new TButton(this);\r\n  ClipboardButton->Caption = LoadStr(USAGE_COPY);\r\n  ClipboardButton->Width = ScaleByTextHeight(this, 121);\r\n  ClipboardButton->OnClick = ClipboardButtonClick;\r\n  AddDialogButton(ClipboardButton);\r\n\r\n  RemoveCancelButton();\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TUsageStatisticsDialog::ClipboardButtonClick(TObject * /*Sender*/)\r\n{\r\n  TInstantOperationVisualizer Visualizer;\r\n  CopyToClipboard(UsageMemo->Lines);\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TUsageStatisticsDialog::DoChange(bool & CanSubmit)\r\n{\r\n  TCustomDialog::DoChange(CanSubmit);\r\n  UnicodeString Text = Configuration->Usage->Serialize(L\"\\n\", FilterEdit->Text);\r\n  bool NoUsage = Text.IsEmpty();\r\n  ClipboardButton->Enabled = !NoUsage;\r\n  if (NoUsage)\r\n  {\r\n    Text = LoadStr(USAGE_DATA_NONE2);\r\n  }\r\n  UsageMemo->Lines->Text = Text;\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall DoUsageStatisticsDialog()\r\n{\r\n  std::unique_ptr<TUsageStatisticsDialog> Dialog(new TUsageStatisticsDialog());\r\n  Dialog->Execute();\r\n}\r\n//---------------------------------------------------------------------------\r\n//---------------------------------------------------------------------------\r\nclass TSiteRawDialog : public TCustomDialog\r\n{\r\npublic:\r\n  __fastcall TSiteRawDialog();\r\n\r\n  bool __fastcall Execute(TSessionData * Data);\r\n\r\nprotected:\r\n  DYNAMIC void __fastcall DoShow();\r\n\r\nprivate:\r\n  TMemo * SettingsMemo;\r\n\r\n  void __fastcall AddButtonClick(TObject * Sender);\r\n  void __fastcall SettingsMemoKeyDown(TObject * Sender, WORD & Key, TShiftState Shift);\r\n\r\n  void DeleteNames(TStrings * Names, TStrings * Options);\r\n};\r\n//---------------------------------------------------------------------------\r\n__fastcall TSiteRawDialog::TSiteRawDialog() :\r\n  TCustomDialog(HELP_SITE_RAW)\r\n{\r\n  Caption = LoadStr(SITE_RAW_CAPTION);\r\n  Width = ScaleByTextHeight(this, 400);\r\n\r\n  SettingsMemo = new TMemo(this);\r\n  SettingsMemo->Height = ScaleByTextHeight(this, 300);\r\n  SettingsMemo->OnKeyDown = SettingsMemoKeyDown;\r\n  AddEdit(SettingsMemo, NULL);\r\n\r\n  TButton * AddButton = new TButton(this);\r\n  AddButton->Caption = LoadStr(SITE_RAW_ADD);\r\n  AddButton->Width = OKButton->Width;\r\n  AddButton->OnClick = AddButtonClick;\r\n  AddDialogButton(AddButton);\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSiteRawDialog::DoShow()\r\n{\r\n  TCustomDialog::DoShow();\r\n  InstallPathWordBreakProc(SettingsMemo);\r\n}\r\n//---------------------------------------------------------------------------\r\nbool __fastcall TSiteRawDialog::Execute(TSessionData * Data)\r\n{\r\n  std::unique_ptr<TSessionData> FactoryDefaults(new TSessionData(L\"\"));\r\n  std::unique_ptr<TSessionData> RawData(new TSessionData(L\"\"));\r\n  RawData->Assign(Data);\r\n  // SFTP-only is not reflected by the protocol prefix, we have to use rawsettings for that\r\n  if (RawData->FSProtocol != fsSFTPonly)\r\n  {\r\n    RawData->FSProtocol = FactoryDefaults->FSProtocol;\r\n  }\r\n  RawData->HostName = FactoryDefaults->HostName;\r\n  RawData->PortNumber = FactoryDefaults->PortNumber;\r\n  RawData->UserName = FactoryDefaults->UserName;\r\n  RawData->Password = FactoryDefaults->Password;\r\n  RawData->Ftps = FactoryDefaults->Ftps;\r\n\r\n  std::unique_ptr<TStrings> Options(RawData->SaveToOptions(FactoryDefaults.get(), false, false));\r\n\r\n  SettingsMemo->Lines = Options.get();\r\n\r\n  bool Result = TCustomDialog::Execute();\r\n  if (Result)\r\n  {\r\n    std::unique_ptr<TSessionData> BackupData(new TSessionData(L\"\"));\r\n    BackupData->Assign(Data);\r\n    Data->DefaultSettings();\r\n\r\n    Data->FSProtocol = BackupData->FSProtocol;\r\n    Data->HostName = BackupData->HostName;\r\n    Data->PortNumber = BackupData->PortNumber;\r\n    Data->UserName = BackupData->UserName;\r\n    Data->Password = BackupData->Password;\r\n    Data->Ftps = BackupData->Ftps;\r\n\r\n    Data->ApplyRawSettings(SettingsMemo->Lines, false);\r\n  }\r\n  return Result;\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSiteRawDialog::SettingsMemoKeyDown(TObject * Sender, WORD & Key, TShiftState Shift)\r\n{\r\n  MemoKeyDown(Sender, Key, Shift);\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TSiteRawDialog::AddButtonClick(TObject *)\r\n{\r\n  std::unique_ptr<TSessionData> FactoryDefaults(new TSessionData(L\"\"));\r\n  std::unique_ptr<TSessionData> BasicData(new TSessionData(L\"\"));\r\n  BasicData->FSProtocol = TFSProtocol(FactoryDefaults->FSProtocol + 1);\r\n  UnicodeString RandomAppendix(L\"_\");\r\n  BasicData->HostName = FactoryDefaults->HostName + RandomAppendix;\r\n  BasicData->Ftps = TFtps(FactoryDefaults->Ftps + 1);\r\n  BasicData->PortNumber = DefaultPort(BasicData->FSProtocol, BasicData->Ftps) + 1;\r\n  BasicData->UserName = FactoryDefaults->UserName + RandomAppendix;\r\n  BasicData->Password = FactoryDefaults->Password + RandomAppendix;\r\n\r\n  std::unique_ptr<TStrings> BasicOptions(BasicData->SaveToOptions(FactoryDefaults.get(), false, false));\r\n\r\n  std::unique_ptr<TStrings> AllOptions(TSessionData::GetAllOptionNames(false));\r\n\r\n  std::unique_ptr<TStrings> Names(CreateSortedStringList());\r\n  for (int Index = 0; Index < AllOptions->Count; Index++)\r\n  {\r\n    Names->Add(AllOptions->Names[Index]);\r\n  }\r\n  DeleteNames(Names.get(), BasicOptions.get());\r\n  DeleteNames(Names.get(), SettingsMemo->Lines);\r\n\r\n  std::unique_ptr<TCustomDialog> AddDialog(new TCustomDialog(HelpKeyword));\r\n  AddDialog->Caption = LoadStr(SITE_RAW_ADD_CAPTION);\r\n  TComboBox * AddComboBox = new TComboBox(AddDialog.get());\r\n  AddComboBox->Style = csDropDownList;\r\n  AddComboBox->DropDownCount = Max(AddComboBox->DropDownCount, 16);\r\n  AddDialog->AddComboBox(AddComboBox, CreateLabel(LoadStr(SITE_RAW_ADD_LABEL)), Names.get(), true);\r\n  AddComboBox->ItemIndex = 0;\r\n  if (AddDialog->Execute())\r\n  {\r\n    UnicodeString Name = AddComboBox->Items->Strings[AddComboBox->ItemIndex];\r\n    UnicodeString Value = AllOptions->Values[Name];\r\n    UnicodeString NameAndSeparator = Name + SettingsMemo->Lines->NameValueSeparator;\r\n    int Start = (SettingsMemo->Lines->Text + NameAndSeparator).Length();\r\n    SettingsMemo->Lines->Add(NameAndSeparator + Value);\r\n    SettingsMemo->SetFocus();\r\n    SettingsMemo->SelStart = Start;\r\n    SettingsMemo->SelLength = Value.Length();\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid TSiteRawDialog::DeleteNames(TStrings * Names, TStrings * Options)\r\n{\r\n  for (int Index = 0; Index < Options->Count; Index++)\r\n  {\r\n    UnicodeString Name = Options->Names[Index];\r\n    if (!Name.IsEmpty())\r\n    {\r\n      int I = Names->IndexOf(Name);\r\n      if (I >= 0)\r\n      {\r\n        Names->Delete(I);\r\n      }\r\n    }\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall DoSiteRawDialog(TSessionData * Data)\r\n{\r\n  std::unique_ptr<TSiteRawDialog> Dialog(new TSiteRawDialog());\r\n  Dialog->Execute(Data);\r\n}\r\n", "//---------------------------------------------------------------------------\r\n#include <vcl.h>\r\n#pragma hdrstop\r\n\r\n#include <Common.h>\r\n#include <Exceptions.h>\r\n#include <Script.h>\r\n#include <CoreMain.h>\r\n#include <Terminal.h>\r\n#include <PuttyTools.h>\r\n#include <Queue.h>\r\n#include <HierarchicalStorage.h>\r\n#include <Tools.h>\r\n\r\n#include <Consts.hpp>\r\n#include <StrUtils.hpp>\r\n\r\n#include \"Console.h\"\r\n#include \"WinInterface.h\"\r\n#include \"ProgParams.h\"\r\n#include \"TextsWin.h\"\r\n#include \"TextsCore.h\"\r\n#include \"WinConfiguration.h\"\r\n#include \"SynchronizeController.h\"\r\n#include \"GUITools.h\"\r\n#include \"VCLCommon.h\"\r\n#include \"Setup.h\"\r\n//---------------------------------------------------------------------------\r\n#define WM_INTERUPT_IDLE (WM_WINSCP_USER + 3)\r\n#define BATCH_INPUT_TIMEOUT 10000\r\n//---------------------------------------------------------------------------\r\n#pragma package(smart_init)\r\n//---------------------------------------------------------------------------\r\nvoid TrimNewLine(UnicodeString & Str)\r\n{\r\n  while (!Str.IsEmpty() &&\r\n    ((Str[Str.Length()] == L'\\n') || (Str[Str.Length()] == L'\\r')))\r\n  {\r\n    Str.SetLength(Str.Length() - 1);\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TConsole::PrintLine(const UnicodeString & Str, bool Error)\r\n{\r\n  Print(Str + L\"\\n\", false, Error);\r\n};\r\n//---------------------------------------------------------------------------\r\nclass TOwnConsole : public TConsole\r\n{\r\npublic:\r\n  static TOwnConsole * __fastcall Instance();\r\n\r\n  virtual void __fastcall Print(UnicodeString Str, bool FromBeginning = false, bool Error = false);\r\n  virtual bool __fastcall Input(UnicodeString & Str, bool Echo, unsigned int Timer);\r\n  virtual int __fastcall Choice(\r\n    UnicodeString Options, int Cancel, int Break, int Continue, int Timeouted, bool Timeouting, unsigned int Timer,\r\n    UnicodeString Message);\r\n  virtual bool __fastcall PendingAbort();\r\n  virtual void __fastcall SetTitle(UnicodeString Title);\r\n  virtual bool __fastcall LimitedOutput();\r\n  virtual bool __fastcall LiveOutput();\r\n  virtual bool __fastcall NoInteractiveInput();\r\n  virtual bool __fastcall Interactive();\r\n  virtual void __fastcall WaitBeforeExit();\r\n  virtual bool __fastcall CommandLineOnly();\r\n  virtual bool __fastcall WantsProgress();\r\n  virtual void __fastcall Progress(TScriptProgress & Progress);\r\n  virtual UnicodeString __fastcall FinalLogMessage();\r\n\r\nprotected:\r\n  static TOwnConsole * FInstance;\r\n  friend class TConsoleInputThread;\r\n\r\n  __fastcall TOwnConsole();\r\n  virtual __fastcall ~TOwnConsole();\r\n\r\n  void __fastcall BreakInput();\r\n  void __fastcall CancelInput();\r\n  static BOOL WINAPI HandlerRoutine(DWORD CtrlType);\r\n  void __fastcall WindowStateTimer(TObject * Sender);\r\n  void __fastcall ProcessMessages();\r\n  void __fastcall TrayIconClick(TObject * Sender);\r\n\r\nprivate:\r\n  HANDLE FInput;\r\n  HANDLE FOutput;\r\n  HWND FConsoleWindow;\r\n  TTimer * FWindowStateTimer;\r\n  bool FMinimized;\r\n  ::TTrayIcon * FTrayIcon;\r\n  static std::unique_ptr<TCriticalSection> FSection;\r\n\r\n  bool FPendingAbort;\r\n};\r\n//---------------------------------------------------------------------------\r\nTOwnConsole * TOwnConsole::FInstance = NULL;\r\nstd::unique_ptr<TCriticalSection> TOwnConsole::FSection(TraceInitPtr(new TCriticalSection()));\r\n//---------------------------------------------------------------------------\r\n__fastcall TOwnConsole::TOwnConsole()\r\n{\r\n  DebugAssert(FInstance == NULL);\r\n  FInstance = this;\r\n\r\n  AllocConsole();\r\n  SetConsoleCtrlHandler(HandlerRoutine, true);\r\n\r\n  FInput = GetStdHandle(STD_INPUT_HANDLE);\r\n  FOutput = GetStdHandle(STD_OUTPUT_HANDLE);\r\n  FPendingAbort = false;\r\n  FConsoleWindow = NULL;\r\n  FWindowStateTimer = NULL;\r\n  FMinimized = false;\r\n  FTrayIcon = new ::TTrayIcon(0);\r\n  FTrayIcon->OnClick = TrayIconClick;\r\n\r\n  if (WinConfiguration->MinimizeToTray)\r\n  {\r\n    FConsoleWindow = GetConsoleWindow();\r\n    if (DebugAlwaysTrue(FConsoleWindow != NULL))\r\n    {\r\n      FWindowStateTimer = new TTimer(Application);\r\n      FWindowStateTimer->OnTimer = WindowStateTimer;\r\n      FWindowStateTimer->Interval = 250;\r\n      FWindowStateTimer->Enabled = true;\r\n    }\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\n__fastcall TOwnConsole::~TOwnConsole()\r\n{\r\n  TGuard Guard(FSection.get());\r\n\r\n  delete FTrayIcon;\r\n  delete FWindowStateTimer;\r\n\r\n  // deliberately do not remove ConsoleCtrlHandler as it causes\r\n  // failures while exiting\r\n\r\n  FreeConsole();\r\n\r\n  DebugAssert(FInstance == this);\r\n  FInstance = NULL;\r\n}\r\n//---------------------------------------------------------------------------\r\nTOwnConsole * __fastcall TOwnConsole::Instance()\r\n{\r\n  return new TOwnConsole();\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TOwnConsole::WindowStateTimer(TObject * /*Sender*/)\r\n{\r\n  DebugAssert(FConsoleWindow != NULL);\r\n  WINDOWPLACEMENT Placement;\r\n  memset(&Placement, 0, sizeof(Placement));\r\n  Placement.length = sizeof(Placement);\r\n  if (GetWindowPlacement(FConsoleWindow, &Placement))\r\n  {\r\n    bool Minimized = (Placement.showCmd == SW_SHOWMINIMIZED);\r\n    if (FMinimized != Minimized)\r\n    {\r\n      FMinimized = Minimized;\r\n\r\n      if (FMinimized && WinConfiguration->MinimizeToTray)\r\n      {\r\n        FTrayIcon->Visible = true;\r\n        ShowWindow(FConsoleWindow, SW_HIDE);\r\n      }\r\n      else\r\n      {\r\n        FTrayIcon->Visible = false;\r\n        ShowWindow(FConsoleWindow, SW_SHOW);\r\n      }\r\n    }\r\n  }\r\n  else\r\n  {\r\n    DebugFail();\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TOwnConsole::ProcessMessages()\r\n{\r\n  // as of now, there's no point doing this unless we have icon tray\r\n  // (i.e. we need to monitor window state and eventually process tray icon messages)\r\n  if (FWindowStateTimer != NULL)\r\n  {\r\n    DebugAssert(WinConfiguration->MinimizeToTray);\r\n\r\n    Application->ProcessMessages();\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TOwnConsole::TrayIconClick(TObject * /*Sender*/)\r\n{\r\n  DebugAssert(FConsoleWindow != NULL);\r\n  SetForegroundWindow(FConsoleWindow);\r\n  ShowWindow(FConsoleWindow, SW_RESTORE);\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TOwnConsole::BreakInput()\r\n{\r\n  FlushConsoleInputBuffer(FInput);\r\n  INPUT_RECORD InputRecord;\r\n  memset(&InputRecord, 0, sizeof(InputRecord));\r\n  InputRecord.EventType = KEY_EVENT;\r\n  InputRecord.Event.KeyEvent.bKeyDown = true;\r\n  InputRecord.Event.KeyEvent.wRepeatCount = 1;\r\n  InputRecord.Event.KeyEvent.uChar.UnicodeChar = L'\\r';\r\n\r\n  unsigned long Written;\r\n  // this assertion occasionally fails (when console is being exited)\r\n  DebugCheck(WriteConsoleInput(FInput, &InputRecord, 1, &Written));\r\n  DebugAssert(Written == 1);\r\n\r\n  CancelInput();\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TOwnConsole::CancelInput()\r\n{\r\n  FPendingAbort = true;\r\n\r\n  PostMessage(Application->Handle, WM_INTERUPT_IDLE, 0, 0);\r\n}\r\n//---------------------------------------------------------------------------\r\nBOOL WINAPI TOwnConsole::HandlerRoutine(DWORD CtrlType)\r\n{\r\n  if ((CtrlType == CTRL_C_EVENT) || (CtrlType == CTRL_BREAK_EVENT))\r\n  {\r\n    {\r\n      TGuard Guard(FSection.get());\r\n\r\n      // just to be real thread-safe\r\n      if (FInstance != NULL)\r\n      {\r\n        FInstance->CancelInput();\r\n      }\r\n    }\r\n\r\n    return true;\r\n  }\r\n  else\r\n  {\r\n    return false;\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\nbool __fastcall TOwnConsole::PendingAbort()\r\n{\r\n  if (FPendingAbort)\r\n  {\r\n    FPendingAbort = false;\r\n    return true;\r\n  }\r\n  else\r\n  {\r\n    return FPendingAbort;\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TOwnConsole::Print(UnicodeString Str, bool FromBeginning, bool /*Error*/)\r\n{\r\n  if (FromBeginning)\r\n  {\r\n    CONSOLE_SCREEN_BUFFER_INFO BufferInfo;\r\n    GetConsoleScreenBufferInfo(FOutput, &BufferInfo);\r\n    BufferInfo.dwCursorPosition.X = 0;\r\n    SetConsoleCursorPosition(FOutput, BufferInfo.dwCursorPosition);\r\n  }\r\n  unsigned long Written;\r\n  bool Result = WriteConsole(FOutput, Str.c_str(), Str.Length(), &Written, NULL);\r\n  DebugAssert(Result);\r\n  DebugUsedParam(Result);\r\n  DebugAssert(Str.Length() == static_cast<long>(Written));\r\n  ProcessMessages();\r\n}\r\n//---------------------------------------------------------------------------\r\nclass TConsoleInputThread : public TSimpleThread\r\n{\r\npublic:\r\n  __fastcall TConsoleInputThread(HANDLE Input, UnicodeString & Str, bool & Result) :\r\n    FInput(Input),\r\n    FStr(Str),\r\n    FResult(Result)\r\n  {\r\n  }\r\n\r\n  virtual __fastcall ~TConsoleInputThread()\r\n  {\r\n    Close();\r\n  }\r\n\r\nprotected:\r\n  virtual void __fastcall Execute()\r\n  {\r\n    unsigned long Read;\r\n    FStr.SetLength(10240);\r\n    FResult = ReadConsole(FInput, FStr.c_str(), FStr.Length(), &Read, NULL);\r\n    DebugAssert(FResult);\r\n    FStr.SetLength(Read);\r\n    TrimNewLine(FStr);\r\n  }\r\n\r\n  virtual void __fastcall Terminate()\r\n  {\r\n    TOwnConsole::FInstance->BreakInput();\r\n  }\r\n\r\nprivate:\r\n  HANDLE FInput;\r\n  UnicodeString & FStr;\r\n  bool & FResult;\r\n};\r\n//---------------------------------------------------------------------------\r\nbool __fastcall TOwnConsole::Input(UnicodeString & Str, bool Echo, unsigned int Timer)\r\n{\r\n  unsigned long PrevMode, NewMode;\r\n  GetConsoleMode(FInput, &PrevMode);\r\n  NewMode = PrevMode | ENABLE_PROCESSED_INPUT | ENABLE_LINE_INPUT;\r\n  if (Echo)\r\n  {\r\n    NewMode |= ENABLE_ECHO_INPUT;\r\n  }\r\n  else\r\n  {\r\n    NewMode &= ~ENABLE_ECHO_INPUT;\r\n  }\r\n  SetConsoleMode(FInput, NewMode);\r\n\r\n  bool Result = false;\r\n\r\n  try\r\n  {\r\n    {\r\n      const int FirstKey = VK_LBUTTON; // 0x01\r\n      const int LastKey = VK_OEM_CLEAR; // 0xFE\r\n\r\n      // reset key state\r\n      for (int Key = FirstKey; Key <= LastKey; Key++)\r\n      {\r\n        GetAsyncKeyState(Key);\r\n      }\r\n\r\n      TConsoleInputThread InputThread(FInput, Str, Result);\r\n\r\n      InputThread.Start();\r\n\r\n      double TimerD = double(Timer)/MSecsPerDay;\r\n      double End = Now() + TimerD;\r\n      while (!InputThread.IsFinished() &&\r\n             ((Timer == 0) || (double(Now()) < End)))\r\n      {\r\n        ProcessMessages();\r\n        InputThread.WaitFor(50);\r\n\r\n        for (int Key = FirstKey; Key <= LastKey; Key++)\r\n        {\r\n          if ((GetAsyncKeyState(Key) & 0x01) != 0)\r\n          {\r\n            End = Now() + TimerD;\r\n            // Finishing the loop nevertheless to reset state of all keys\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    if (FPendingAbort || !Echo)\r\n    {\r\n      Print(L\"\\n\");\r\n    }\r\n\r\n    if (FPendingAbort || (Str.Length() == 0))\r\n    {\r\n      Result = false;\r\n      FPendingAbort = false;\r\n    }\r\n  }\r\n  __finally\r\n  {\r\n    SetConsoleMode(FInput, PrevMode);\r\n  }\r\n\r\n  return Result;\r\n}\r\n//---------------------------------------------------------------------------\r\nint __fastcall TOwnConsole::Choice(\r\n  UnicodeString Options, int Cancel, int Break, int /*Continue*/, int Timeouted, bool /*Timeouting*/, unsigned int Timer,\r\n  UnicodeString Message)\r\n{\r\n  unsigned int ATimer = Timer;\r\n  int Result = 0;\r\n  unsigned long PrevMode, NewMode;\r\n  GetConsoleMode(FInput, &PrevMode);\r\n  NewMode = (PrevMode | ENABLE_PROCESSED_INPUT) & ~(ENABLE_LINE_INPUT | ENABLE_ECHO_INPUT);\r\n  SetConsoleMode(FInput, NewMode);\r\n\r\n  try\r\n  {\r\n    do\r\n    {\r\n      unsigned long Read;\r\n      INPUT_RECORD Record;\r\n      if ((PeekConsoleInput(FInput, &Record, 1, &Read) != 0) &&\r\n          (Read == 1))\r\n      {\r\n        if ((ReadConsoleInput(FInput, &Record, 1, &Read) != 0) &&\r\n            (Read == 1))\r\n        {\r\n          if (PendingAbort())\r\n          {\r\n            Result = Break;\r\n          }\r\n          else if ((Record.EventType == KEY_EVENT) &&\r\n                   Record.Event.KeyEvent.bKeyDown)\r\n          {\r\n            wchar_t C = AnsiUpperCase(Record.Event.KeyEvent.uChar.UnicodeChar)[1];\r\n            if (C == 27)\r\n            {\r\n              Result = Cancel;\r\n            }\r\n            else if ((Options.Pos(C) > 0) &&\r\n                     FLAGCLEAR(Record.Event.KeyEvent.dwControlKeyState,\r\n                       LEFT_CTRL_PRESSED | RIGHT_CTRL_PRESSED | LEFT_ALT_PRESSED  |\r\n                       RIGHT_ALT_PRESSED))\r\n\r\n            {\r\n              Result = Options.Pos(C);\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      if (Result == 0)\r\n      {\r\n        unsigned int TimerSlice = 50;\r\n        Sleep(TimerSlice);\r\n        if (Timer > 0)\r\n        {\r\n          if (ATimer > TimerSlice)\r\n          {\r\n            ATimer -= TimerSlice;\r\n          }\r\n          else\r\n          {\r\n            Result = Timeouted;\r\n          }\r\n        }\r\n      }\r\n\r\n      ProcessMessages();\r\n    }\r\n    while (Result == 0);\r\n  }\r\n  __finally\r\n  {\r\n    SetConsoleMode(FInput, PrevMode);\r\n  }\r\n\r\n  return Result;\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TOwnConsole::SetTitle(UnicodeString Title)\r\n{\r\n  FTrayIcon->Hint = Title;\r\n  SetConsoleTitle(Title.c_str());\r\n}\r\n//---------------------------------------------------------------------------\r\nbool __fastcall TOwnConsole::LimitedOutput()\r\n{\r\n  return true;\r\n}\r\n//---------------------------------------------------------------------------\r\nbool __fastcall TOwnConsole::LiveOutput()\r\n{\r\n  return true;\r\n}\r\n//---------------------------------------------------------------------------\r\nbool __fastcall TOwnConsole::NoInteractiveInput()\r\n{\r\n  return false;\r\n}\r\n//---------------------------------------------------------------------------\r\nbool __fastcall TOwnConsole::Interactive()\r\n{\r\n  return true;\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TOwnConsole::WaitBeforeExit()\r\n{\r\n  unsigned long Read;\r\n  INPUT_RECORD Record;\r\n  while (true)\r\n  {\r\n    if (PeekConsoleInput(FInput, &Record, 1, &Read) && (Read == 1) &&\r\n        ReadConsoleInput(FInput, &Record, 1, &Read) &&\r\n        (Read == 1) && (Record.EventType == KEY_EVENT) &&\r\n        (Record.Event.KeyEvent.uChar.UnicodeChar != 0) &&\r\n        Record.Event.KeyEvent.bKeyDown)\r\n    {\r\n      break;\r\n    }\r\n    Sleep(50);\r\n    ProcessMessages();\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\nbool __fastcall TOwnConsole::CommandLineOnly()\r\n{\r\n  return false;\r\n}\r\n//---------------------------------------------------------------------------\r\nbool __fastcall TOwnConsole::WantsProgress()\r\n{\r\n  return false;\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TOwnConsole::Progress(TScriptProgress & /*Progress*/)\r\n{\r\n  DebugFail();\r\n}\r\n//---------------------------------------------------------------------------\r\nUnicodeString __fastcall TOwnConsole::FinalLogMessage()\r\n{\r\n  return UnicodeString();\r\n}\r\n//---------------------------------------------------------------------------\r\nclass TExternalConsole : public TConsole\r\n{\r\npublic:\r\n  __fastcall TExternalConsole(const UnicodeString Instance, bool NoInteractiveInput);\r\n  virtual __fastcall ~TExternalConsole();\r\n\r\n  virtual void __fastcall Print(UnicodeString Str, bool FromBeginning = false, bool Error = false);\r\n  virtual bool __fastcall Input(UnicodeString & Str, bool Echo, unsigned int Timer);\r\n  virtual int __fastcall Choice(\r\n    UnicodeString Options, int Cancel, int Break, int Continue, int Timeouted, bool Timeouting, unsigned int Timer,\r\n    UnicodeString Message);\r\n  virtual bool __fastcall PendingAbort();\r\n  virtual void __fastcall SetTitle(UnicodeString Title);\r\n  virtual bool __fastcall LimitedOutput();\r\n  virtual bool __fastcall LiveOutput();\r\n  virtual bool __fastcall NoInteractiveInput();\r\n  virtual void __fastcall WaitBeforeExit();\r\n  virtual bool __fastcall Interactive();\r\n  virtual bool __fastcall CommandLineOnly();\r\n  virtual bool __fastcall WantsProgress();\r\n  virtual void __fastcall Progress(TScriptProgress & Progress);\r\n  virtual UnicodeString __fastcall FinalLogMessage();\r\n\r\nprivate:\r\n  bool FPendingAbort;\r\n  HANDLE FRequestEvent;\r\n  HANDLE FResponseEvent;\r\n  HANDLE FCancelEvent;\r\n  HANDLE FFileMapping;\r\n  bool FLimitedOutput;\r\n  bool FLiveOutput;\r\n  bool FPipeOutput;\r\n  bool FNoInteractiveInput;\r\n  bool FWantsProgress;\r\n  bool FInteractive;\r\n  unsigned int FMaxSend;\r\n\r\n  inline TConsoleCommStruct * __fastcall GetCommStruct();\r\n  inline void __fastcall FreeCommStruct(TConsoleCommStruct * CommStruct);\r\n  inline void __fastcall SendEvent(int Timeout);\r\n  void __fastcall Init();\r\n  void __fastcall CheckHandle(HANDLE Handle, const UnicodeString & Desc);\r\n};\r\n//---------------------------------------------------------------------------\r\n__fastcall TExternalConsole::TExternalConsole(\r\n  const UnicodeString Instance, bool NoInteractiveInput)\r\n{\r\n  UnicodeString Name;\r\n  Name = FORMAT(L\"%s%s\", (CONSOLE_EVENT_REQUEST, (Instance)));\r\n  CheckHandle(FRequestEvent = OpenEvent(EVENT_ALL_ACCESS, false, Name.c_str()), L\"Request event\");\r\n  Name = FORMAT(L\"%s%s\", (CONSOLE_EVENT_RESPONSE, (Instance)));\r\n  CheckHandle(FResponseEvent = OpenEvent(EVENT_ALL_ACCESS, false, Name.c_str()), L\"Response event\");\r\n  Name = FORMAT(L\"%s%s\", (CONSOLE_EVENT_CANCEL, (Instance)));\r\n  CheckHandle(FCancelEvent = OpenEvent(EVENT_ALL_ACCESS, false, Name.c_str()), L\"Cancel event\");\r\n  Name = FORMAT(L\"%s%s\", (CONSOLE_MAPPING, (Instance)));\r\n  CheckHandle(FFileMapping = OpenFileMapping(FILE_MAP_ALL_ACCESS, false, Name.c_str()), L\"File mapping\");\r\n\r\n  HANDLE Job = OpenJobObject(JOB_OBJECT_ASSIGN_PROCESS, FALSE,\r\n    FORMAT(L\"%s%s\", (CONSOLE_JOB, Instance)).c_str());\r\n  if (DebugAlwaysTrue(Job != NULL))\r\n  {\r\n    AssignProcessToJobObject(Job, GetCurrentProcess());\r\n    // winscp.com/winscp.dll keeps the only reference to the job.\r\n    // once it gets closed (because winscp.com if forcefully terminated),\r\n    // we get terminated as well\r\n    CloseHandle(Job);\r\n  }\r\n\r\n  TConsoleCommStruct * CommStruct = GetCommStruct();\r\n  try\r\n  {\r\n    if (CommStruct->Version != TConsoleCommStruct::CurrentVersion)\r\n    {\r\n      throw Exception(FMTLOAD(EXTERNAL_CONSOLE_INCOMPATIBLE, (CommStruct->Version)));\r\n    }\r\n\r\n    CommStruct->Version = TConsoleCommStruct::CurrentVersionConfirmed;\r\n  }\r\n  __finally\r\n  {\r\n    FreeCommStruct(CommStruct);\r\n  }\r\n\r\n  // to break application event loop regularly during \"watching for changes\"\r\n  // to allow user to abort it\r\n  SetTimer(Application->Handle, 1, 500, NULL);\r\n\r\n  FNoInteractiveInput = NoInteractiveInput;\r\n  FMaxSend = 0;\r\n\r\n  Init();\r\n}\r\n//---------------------------------------------------------------------------\r\n__fastcall TExternalConsole::~TExternalConsole()\r\n{\r\n  CloseHandle(FRequestEvent);\r\n  CloseHandle(FResponseEvent);\r\n  CloseHandle(FCancelEvent);\r\n  CloseHandle(FFileMapping);\r\n  KillTimer(Application->Handle, 1);\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TExternalConsole::CheckHandle(HANDLE Handle, const UnicodeString & Desc)\r\n{\r\n  if (Handle == NULL)\r\n  {\r\n    throw ExtException(LoadStr(EXTERNAL_CONSOLE_INIT_ERROR), FORMAT(L\"%s\\n%s\", (Desc, LastSysErrorMessage())));\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\nTConsoleCommStruct * __fastcall TExternalConsole::GetCommStruct()\r\n{\r\n  TConsoleCommStruct * Result;\r\n  Result = static_cast<TConsoleCommStruct*>(MapViewOfFile(FFileMapping,\r\n    FILE_MAP_ALL_ACCESS, 0, 0, 0));\r\n  if (Result == NULL)\r\n  {\r\n    throw Exception(LoadStr(CONSOLE_COMM_ERROR));\r\n  }\r\n  return Result;\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TExternalConsole::FreeCommStruct(TConsoleCommStruct * CommStruct)\r\n{\r\n  UnmapViewOfFile(CommStruct);\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TExternalConsole::SendEvent(int Timeout)\r\n{\r\n  SetEvent(FRequestEvent);\r\n  unsigned int Start = 0; // shut up\r\n  if (Configuration->LogProtocol >= 1)\r\n  {\r\n    Start = GetTickCount();\r\n  }\r\n  unsigned int Result = WaitForSingleObject(FResponseEvent, Timeout);\r\n  if (Configuration->LogProtocol >= 1)\r\n  {\r\n    unsigned int End = GetTickCount();\r\n    unsigned int Duration = End - Start;\r\n    FMaxSend = std::max(Duration, FMaxSend);\r\n  }\r\n  if (Result != WAIT_OBJECT_0)\r\n  {\r\n    UnicodeString Message = LoadStr(CONSOLE_SEND_TIMEOUT);\r\n    if (FPipeOutput)\r\n    {\r\n      Message = FORMAT(\"%s %s\", (Message, LoadStr(CONSOLE_SEND_PIPE)));\r\n    }\r\n    throw Exception(Message);\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\nUnicodeString __fastcall TExternalConsole::FinalLogMessage()\r\n{\r\n  return FORMAT(L\"Max roundtrip: %d\", (static_cast<int>(FMaxSend)));\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TExternalConsole::Print(UnicodeString Str, bool FromBeginning, bool Error)\r\n{\r\n  // need to do at least one iteration, even when Str is empty (new line)\r\n  do\r\n  {\r\n    TConsoleCommStruct * CommStruct = GetCommStruct();\r\n    try\r\n    {\r\n      size_t MaxLen = LENOF(CommStruct->PrintEvent.Message) - 1;\r\n      UnicodeString Piece = Str.SubString(1, MaxLen);\r\n      Str.Delete(1, MaxLen);\r\n\r\n      CommStruct->Event = TConsoleCommStruct::PRINT;\r\n      wcscpy(CommStruct->PrintEvent.Message, Piece.c_str());\r\n      CommStruct->PrintEvent.FromBeginning = FromBeginning;\r\n      CommStruct->PrintEvent.Error = Error;\r\n\r\n      // In the next iteration we need to append never overwrite.\r\n      // Note that this won't work properly for disk/pipe outputs,\r\n      // when the next line is also FromBeginning,\r\n      // as !FromBeginning print effectively commits previous FromBeginning print.\r\n      // On the other hand, FromBeginning print is always initiated by us,\r\n      // and it's not likely we ever issue print over 10 KB.\r\n      FromBeginning = false;\r\n    }\r\n    __finally\r\n    {\r\n      FreeCommStruct(CommStruct);\r\n    }\r\n\r\n    SendEvent(INFINITE);\r\n  }\r\n  while (!Str.IsEmpty());\r\n}\r\n//---------------------------------------------------------------------------\r\nbool __fastcall TExternalConsole::Input(UnicodeString & Str, bool Echo, unsigned int Timer)\r\n{\r\n  TConsoleCommStruct * CommStruct = GetCommStruct();\r\n  try\r\n  {\r\n    CommStruct->Event = TConsoleCommStruct::INPUT;\r\n    CommStruct->InputEvent.Echo = Echo;\r\n    CommStruct->InputEvent.Result = false;\r\n    CommStruct->InputEvent.Str[0] = L'\\0';\r\n    CommStruct->InputEvent.Timer = Timer;\r\n  }\r\n  __finally\r\n  {\r\n    FreeCommStruct(CommStruct);\r\n  }\r\n\r\n  SendEvent(INFINITE);\r\n\r\n  bool Result;\r\n  CommStruct = GetCommStruct();\r\n  try\r\n  {\r\n    Result = CommStruct->InputEvent.Result;\r\n    Str = CommStruct->InputEvent.Str;\r\n    TrimNewLine(Str);\r\n  }\r\n  __finally\r\n  {\r\n    FreeCommStruct(CommStruct);\r\n  }\r\n\r\n  return Result;\r\n}\r\n//---------------------------------------------------------------------------\r\nint __fastcall TExternalConsole::Choice(\r\n  UnicodeString Options, int Cancel, int Break, int Continue, int Timeouted, bool Timeouting, unsigned int Timer,\r\n  UnicodeString Message)\r\n{\r\n  TConsoleCommStruct * CommStruct = GetCommStruct();\r\n  try\r\n  {\r\n    CommStruct->Event = TConsoleCommStruct::CHOICE;\r\n\r\n    DebugAssert(Options.Length() < static_cast<int>(LENOF(CommStruct->ChoiceEvent.Options)));\r\n    wcscpy(CommStruct->ChoiceEvent.Options, Options.c_str());\r\n    CommStruct->ChoiceEvent.Cancel = Cancel;\r\n    CommStruct->ChoiceEvent.Break = Break;\r\n    CommStruct->ChoiceEvent.Result = Break;\r\n    CommStruct->ChoiceEvent.Continue = Continue;\r\n    CommStruct->ChoiceEvent.Timeouted = Timeouted;\r\n    CommStruct->ChoiceEvent.Timer = Timer;\r\n    CommStruct->ChoiceEvent.Timeouting = Timeouting;\r\n    size_t MaxLen = LENOF(CommStruct->ChoiceEvent.Message) - 1;\r\n    Message = Message.SubString(1, MaxLen);\r\n    wcscpy(CommStruct->ChoiceEvent.Message, Message.c_str());\r\n  }\r\n  __finally\r\n  {\r\n    FreeCommStruct(CommStruct);\r\n  }\r\n\r\n  SendEvent(INFINITE);\r\n\r\n  int Result;\r\n  CommStruct = GetCommStruct();\r\n  try\r\n  {\r\n    Result = CommStruct->ChoiceEvent.Result;\r\n  }\r\n  __finally\r\n  {\r\n    FreeCommStruct(CommStruct);\r\n  }\r\n\r\n  return Result;\r\n}\r\n//---------------------------------------------------------------------------\r\nbool __fastcall TExternalConsole::PendingAbort()\r\n{\r\n  return (WaitForSingleObject(FCancelEvent, 0) == WAIT_OBJECT_0);\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TExternalConsole::SetTitle(UnicodeString Title)\r\n{\r\n  TConsoleCommStruct * CommStruct = GetCommStruct();\r\n  try\r\n  {\r\n    // Truncate to maximum allowed. Title over 10 KB won't fit to screen anyway\r\n    Title = Title.SubString(1, LENOF(CommStruct->TitleEvent.Title) - 1);\r\n\r\n    CommStruct->Event = TConsoleCommStruct::TITLE;\r\n    wcscpy(CommStruct->TitleEvent.Title, Title.c_str());\r\n  }\r\n  __finally\r\n  {\r\n    FreeCommStruct(CommStruct);\r\n  }\r\n\r\n  SendEvent(INFINITE);\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TExternalConsole::Init()\r\n{\r\n  TConsoleCommStruct * CommStruct = GetCommStruct();\r\n  try\r\n  {\r\n    CommStruct->Event = TConsoleCommStruct::INIT;\r\n    CommStruct->InitEvent.WantsProgress = false;\r\n  }\r\n  __finally\r\n  {\r\n    FreeCommStruct(CommStruct);\r\n  }\r\n  SendEvent(INFINITE);\r\n\r\n  CommStruct = GetCommStruct();\r\n  try\r\n  {\r\n    FLimitedOutput = (CommStruct->InitEvent.OutputType == FILE_TYPE_CHAR);\r\n    FLiveOutput =\r\n      (CommStruct->InitEvent.OutputType != FILE_TYPE_DISK) &&\r\n      (CommStruct->InitEvent.OutputType != FILE_TYPE_PIPE);\r\n    FPipeOutput = (CommStruct->InitEvent.OutputType != FILE_TYPE_PIPE);\r\n    FInteractive =\r\n      (CommStruct->InitEvent.InputType != FILE_TYPE_DISK) &&\r\n      (CommStruct->InitEvent.InputType != FILE_TYPE_PIPE);\r\n    FWantsProgress = CommStruct->InitEvent.WantsProgress;\r\n  }\r\n  __finally\r\n  {\r\n    FreeCommStruct(CommStruct);\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\nbool __fastcall TExternalConsole::LimitedOutput()\r\n{\r\n  return FLimitedOutput;\r\n}\r\n//---------------------------------------------------------------------------\r\nbool __fastcall TExternalConsole::LiveOutput()\r\n{\r\n  return FLiveOutput;\r\n}\r\n//---------------------------------------------------------------------------\r\nbool __fastcall TExternalConsole::NoInteractiveInput()\r\n{\r\n  return FNoInteractiveInput;\r\n}\r\n//---------------------------------------------------------------------------\r\nbool __fastcall TExternalConsole::Interactive()\r\n{\r\n  return FInteractive;\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TExternalConsole::WaitBeforeExit()\r\n{\r\n  // noop\r\n}\r\n//---------------------------------------------------------------------------\r\nbool __fastcall TExternalConsole::CommandLineOnly()\r\n{\r\n  return true;\r\n}\r\n//---------------------------------------------------------------------------\r\nbool __fastcall TExternalConsole::WantsProgress()\r\n{\r\n  return FWantsProgress;\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TExternalConsole::Progress(TScriptProgress & Progress)\r\n{\r\n  TConsoleCommStruct * CommStruct = GetCommStruct();\r\n\r\n  typedef TConsoleCommStruct::TProgressEvent TProgressEvent;\r\n\r\n  try\r\n  {\r\n    TProgressEvent & ProgressEvent = CommStruct->ProgressEvent;\r\n\r\n    CommStruct->Event = TConsoleCommStruct::PROGRESS;\r\n\r\n    switch (Progress.Operation)\r\n    {\r\n      case foCopy:\r\n      case foMove:\r\n        ProgressEvent.Operation = TProgressEvent::COPY;\r\n        break;\r\n\r\n      default:\r\n        DebugFail();\r\n    }\r\n\r\n    switch (Progress.Side)\r\n    {\r\n      case osLocal:\r\n        ProgressEvent.Side = TProgressEvent::LOCAL;\r\n        break;\r\n\r\n      case osRemote:\r\n        ProgressEvent.Side = TProgressEvent::REMOTE;\r\n        break;\r\n\r\n      default:\r\n        DebugFail();\r\n    }\r\n\r\n    wcsncpy(ProgressEvent.FileName, Progress.FileName.c_str(), LENOF(ProgressEvent.FileName));\r\n    NULL_TERMINATE(ProgressEvent.FileName);\r\n\r\n    wcsncpy(ProgressEvent.Directory, Progress.Directory.c_str(), LENOF(ProgressEvent.Directory));\r\n    NULL_TERMINATE(ProgressEvent.Directory);\r\n\r\n    ProgressEvent.OverallProgress = Progress.OverallProgress;\r\n    ProgressEvent.FileProgress = Progress.FileProgress;\r\n    ProgressEvent.CPS = Progress.CPS;\r\n    ProgressEvent.Cancel = Progress.Cancel;\r\n  }\r\n  __finally\r\n  {\r\n    FreeCommStruct(CommStruct);\r\n  }\r\n  SendEvent(INFINITE);\r\n\r\n  CommStruct = GetCommStruct();\r\n  try\r\n  {\r\n    TProgressEvent & ProgressEvent = CommStruct->ProgressEvent;\r\n    Progress.Cancel = ProgressEvent.Cancel;\r\n  }\r\n  __finally\r\n  {\r\n    FreeCommStruct(CommStruct);\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\nclass TNullConsole : public TConsole\r\n{\r\npublic:\r\n  __fastcall TNullConsole();\r\n\r\n  virtual void __fastcall Print(UnicodeString Str, bool FromBeginning = false, bool Error = false);\r\n  virtual bool __fastcall Input(UnicodeString & Str, bool Echo, unsigned int Timer);\r\n  virtual int __fastcall Choice(\r\n    UnicodeString Options, int Cancel, int Break, int Continue, int Timeouted, bool Timeouting, unsigned int Timer,\r\n    UnicodeString Message);\r\n  virtual bool __fastcall PendingAbort();\r\n  virtual void __fastcall SetTitle(UnicodeString Title);\r\n  virtual bool __fastcall LimitedOutput();\r\n  virtual bool __fastcall LiveOutput();\r\n  virtual bool __fastcall NoInteractiveInput();\r\n  virtual bool __fastcall Interactive();\r\n  virtual void __fastcall WaitBeforeExit();\r\n  virtual bool __fastcall CommandLineOnly();\r\n\r\n  virtual bool __fastcall WantsProgress();\r\n  virtual void __fastcall Progress(TScriptProgress & Progress);\r\n  virtual UnicodeString __fastcall FinalLogMessage();\r\n};\r\n//---------------------------------------------------------------------------\r\n__fastcall TNullConsole::TNullConsole()\r\n{\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TNullConsole::Print(UnicodeString /*Str*/, bool /*FromBeginning*/, bool /*Error*/)\r\n{\r\n  // noop\r\n}\r\n//---------------------------------------------------------------------------\r\nbool __fastcall TNullConsole::Input(UnicodeString & /*Str*/, bool /*Echo*/,\r\n  unsigned int /*Timer*/)\r\n{\r\n  return false;\r\n}\r\n//---------------------------------------------------------------------------\r\nint __fastcall TNullConsole::Choice(\r\n  UnicodeString /*Options*/, int /*Cancel*/, int Break, int /*Continue*/, int Timeouted, bool Timeouting,\r\n  unsigned int Timer, UnicodeString /*Message*/)\r\n{\r\n  int Result;\r\n  if (Timeouting)\r\n  {\r\n    Sleep(Timer);\r\n    Result = Timeouted;\r\n  }\r\n  else\r\n  {\r\n    Result = Break;\r\n  }\r\n  return Result;\r\n}\r\n//---------------------------------------------------------------------------\r\nbool __fastcall TNullConsole::PendingAbort()\r\n{\r\n  return false;\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TNullConsole::SetTitle(UnicodeString /*Title*/)\r\n{\r\n  // noop\r\n}\r\n//---------------------------------------------------------------------------\r\nbool __fastcall TNullConsole::LimitedOutput()\r\n{\r\n  return false;\r\n}\r\n//---------------------------------------------------------------------------\r\nbool __fastcall TNullConsole::LiveOutput()\r\n{\r\n  return false;\r\n}\r\n//---------------------------------------------------------------------------\r\nbool __fastcall TNullConsole::NoInteractiveInput()\r\n{\r\n  // do not matter, even if we return false,\r\n  // it fails immediately afterwards in TNullConsole::Input\r\n  return true;\r\n}\r\n//---------------------------------------------------------------------------\r\nbool __fastcall TNullConsole::Interactive()\r\n{\r\n  return false;\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TNullConsole::WaitBeforeExit()\r\n{\r\n  DebugFail();\r\n  // noop\r\n}\r\n//---------------------------------------------------------------------------\r\nbool __fastcall TNullConsole::CommandLineOnly()\r\n{\r\n  DebugFail();\r\n  return false;\r\n}\r\n//---------------------------------------------------------------------------\r\nbool __fastcall TNullConsole::WantsProgress()\r\n{\r\n  return false;\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TNullConsole::Progress(TScriptProgress & /*Progress*/)\r\n{\r\n  DebugFail();\r\n}\r\n//---------------------------------------------------------------------------\r\nUnicodeString __fastcall TNullConsole::FinalLogMessage()\r\n{\r\n  return UnicodeString();\r\n}\r\n//---------------------------------------------------------------------------\r\nstatic UnicodeString TimestampVarName(L\"TIMESTAMP\");\r\n//---------------------------------------------------------------------------\r\nclass TConsoleRunner\r\n{\r\npublic:\r\n  TConsoleRunner(TConsole * Console);\r\n  ~TConsoleRunner();\r\n\r\n  int __fastcall Run(const UnicodeString Session, TOptions * Options,\r\n    TStrings * ScriptCommands, TStrings * ScriptParameters);\r\n  void __fastcall ShowException(Exception * E);\r\n  inline void __fastcall PrintMessage(const UnicodeString & Str, bool Error = false);\r\n\r\nprotected:\r\n  bool __fastcall DoInput(UnicodeString & Str, bool Echo, unsigned int Timer,\r\n    bool Interactive);\r\n  void __fastcall Input(const UnicodeString Prompt, UnicodeString & Str,\r\n    bool Echo, bool Interactive);\r\n  inline void __fastcall Print(const UnicodeString & Str, bool FromBeginning = false, bool Error = false);\r\n  void __fastcall UpdateTitle();\r\n  inline bool __fastcall NotifyAbort();\r\n  inline bool __fastcall Aborted(bool AllowCompleteAbort = true);\r\n  void __fastcall MasterPasswordPrompt();\r\n  void __fastcall DoShowException(TTerminal * Terminal, Exception * E);\r\n\r\nprivate:\r\n  TManagementScript * FScript;\r\n  TConsole * FConsole;\r\n  TSynchronizeController FSynchronizeController;\r\n  int FLastProgressLen;\r\n  bool FSynchronizeAborted;\r\n  bool FCommandError;\r\n  bool FBatchScript;\r\n  bool FAborted;\r\n  TTimer * Timer;\r\n  bool FExternalTimestampVar;\r\n\r\n  void __fastcall ScriptPrint(TScript * Script, const UnicodeString Str, bool Error);\r\n  void __fastcall ScriptPrintProgress(TScript * Script, bool First, const UnicodeString Str);\r\n  void __fastcall ScriptInput(TScript * Script, const UnicodeString Prompt, UnicodeString & Str);\r\n  void __fastcall ScriptTerminalPromptUser(TTerminal * Terminal,\r\n    TPromptKind Kind, UnicodeString Name, UnicodeString Instructions, TStrings * Prompts,\r\n    TStrings * Results, bool & Result, void * Arg);\r\n  void __fastcall ScriptShowExtendedException(TTerminal * Terminal,\r\n    Exception * E, void * Arg);\r\n  void __fastcall ScriptTerminalQueryUser(TObject * Sender, const UnicodeString Query,\r\n    TStrings * MoreMessages, unsigned int Answers, const TQueryParams * Params, unsigned int & Answer,\r\n    TQueryType QueryType, void * Arg);\r\n  void __fastcall ScriptQueryCancel(TScript * Script, bool & Cancel);\r\n  void __fastcall SynchronizeControllerAbort(TObject * Sender, bool Close);\r\n  void __fastcall SynchronizeControllerLog(TSynchronizeController * Controller,\r\n    TSynchronizeLogEntry Entry, const UnicodeString Message);\r\n  void __fastcall ScriptSynchronizeStartStop(TScript * Script,\r\n    const UnicodeString LocalDirectory, const UnicodeString RemoteDirectory,\r\n    const TCopyParamType & CopyParam, int SynchronizeParams);\r\n  void __fastcall SynchronizeControllerSynchronize(TSynchronizeController * Sender,\r\n    const UnicodeString LocalDirectory, const UnicodeString RemoteDirectory,\r\n    const TCopyParamType & CopyParam, const TSynchronizeParamType & Params,\r\n    TSynchronizeChecklist ** Checklist, TSynchronizeOptions * Options, bool Full);\r\n  void __fastcall SynchronizeControllerSynchronizeInvalid(TSynchronizeController * Sender,\r\n    const UnicodeString Directory, const UnicodeString ErrorStr);\r\n  void __fastcall SynchronizeControllerTooManyDirectories(TSynchronizeController * Sender,\r\n    int & MaxDirectories);\r\n  unsigned int InputTimeout();\r\n  void __fastcall TimerTimer(TObject * Sender);\r\n  UnicodeString ExpandCommand(UnicodeString Command, TStrings * ScriptParameters);\r\n  void __fastcall Failed(bool & AnyError);\r\n  void __fastcall ScriptProgress(TScript * Script, TScriptProgress & Progress);\r\n  void __fastcall ConfigurationChange(TObject * Sender);\r\n};\r\n//---------------------------------------------------------------------------\r\nTConsoleRunner::TConsoleRunner(TConsole * Console) :\r\n  FSynchronizeController(&SynchronizeControllerSynchronize,\r\n    &SynchronizeControllerSynchronizeInvalid,\r\n    &SynchronizeControllerTooManyDirectories)\r\n{\r\n  FConsole = Console;\r\n  FLastProgressLen = 0;\r\n  FScript = NULL;\r\n  FAborted = false;\r\n  FBatchScript = false;\r\n  Timer = new TTimer(Application);\r\n  Timer->OnTimer = TimerTimer;\r\n  Timer->Interval = MSecsPerSec;\r\n  Timer->Enabled = true;\r\n  DebugAssert(WinConfiguration->OnMasterPasswordPrompt == NULL);\r\n  WinConfiguration->OnMasterPasswordPrompt = MasterPasswordPrompt;\r\n  DebugAssert(Configuration->OnChange == NULL);\r\n  FExternalTimestampVar = !GetEnvironmentVariable(TimestampVarName).IsEmpty();\r\n  Configuration->OnChange = ConfigurationChange;\r\n  Configuration->Scripting = true;\r\n}\r\n//---------------------------------------------------------------------------\r\nTConsoleRunner::~TConsoleRunner()\r\n{\r\n  DebugAssert(WinConfiguration->OnMasterPasswordPrompt == MasterPasswordPrompt);\r\n  WinConfiguration->OnMasterPasswordPrompt = NULL;\r\n  DebugAssert(Configuration->OnChange == ConfigurationChange);\r\n  Configuration->OnChange = NULL;\r\n  delete Timer;\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TConsoleRunner::TimerTimer(TObject * /*Sender*/)\r\n{\r\n  // sole presence of timer causes message to be dispatched,\r\n  // hence breaks the loops\r\n}\r\n//---------------------------------------------------------------------------\r\nunsigned int TConsoleRunner::InputTimeout()\r\n{\r\n  return ((FScript != NULL) && (FScript->Batch != TScript::BatchOff) ? BATCH_INPUT_TIMEOUT : 0);\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TConsoleRunner::Input(\r\n  const UnicodeString Prompt, UnicodeString & Str, bool Echo, bool Interactive)\r\n{\r\n  Print(Prompt);\r\n\r\n  if (!DoInput(Str, Echo, InputTimeout(), Interactive))\r\n  {\r\n    Abort();\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TConsoleRunner::ScriptInput(TScript * /*Script*/,\r\n  const UnicodeString Prompt, UnicodeString & Str)\r\n{\r\n  Input(Prompt, Str, true, true);\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TConsoleRunner::Print(const UnicodeString & Str, bool FromBeginning, bool Error)\r\n{\r\n  if (FLastProgressLen > 0)\r\n  {\r\n    FConsole->Print(L\"\\n\" + Str, FromBeginning, Error);\r\n    FLastProgressLen = 0;\r\n  }\r\n  else\r\n  {\r\n    FConsole->Print(Str, FromBeginning, Error);\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TConsoleRunner::PrintMessage(const UnicodeString & Str, bool Error)\r\n{\r\n  UnicodeString Line = RemoveEmptyLines(Str);\r\n\r\n  if (FScript != NULL)\r\n  {\r\n    // this also logs the message\r\n    FScript->PrintLine(Line, Error);\r\n  }\r\n  else\r\n  {\r\n    FConsole->PrintLine(Line, Error);\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\nbool __fastcall TConsoleRunner::NotifyAbort()\r\n{\r\n  bool Result = FBatchScript;\r\n  if (Result)\r\n  {\r\n    FAborted = true;\r\n  }\r\n  return Result;\r\n}\r\n//---------------------------------------------------------------------------\r\nbool __fastcall TConsoleRunner::Aborted(bool AllowCompleteAbort)\r\n{\r\n  bool Result;\r\n  if (FAborted)\r\n  {\r\n    Result = true;\r\n  }\r\n  else\r\n  {\r\n    Result = FConsole->PendingAbort();\r\n    if (Result)\r\n    {\r\n      PrintMessage(LoadStr(USER_TERMINATED), true);\r\n\r\n      if (AllowCompleteAbort && NotifyAbort())\r\n      {\r\n        if (FScript->Terminal != NULL)\r\n        {\r\n          std::unique_ptr<TStringList> Failure(TextToStringList(LoadStr(USER_TERMINATED)));\r\n          FScript->Terminal->ActionLog->AddFailure(Failure.get());\r\n        }\r\n      }\r\n    }\r\n  }\r\n  return Result;\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TConsoleRunner::ScriptPrint(TScript * /*Script*/,\r\n  const UnicodeString Str, bool Error)\r\n{\r\n  Print(Str, false, Error);\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TConsoleRunner::ScriptPrintProgress(TScript * /*Script*/,\r\n  bool First, const UnicodeString Str)\r\n{\r\n  UnicodeString S = Str;\r\n  if (First && (FLastProgressLen > 0))\r\n  {\r\n    S = L\"\\n\" + S;\r\n  }\r\n  else if (S.Length() < FLastProgressLen)\r\n  {\r\n    int Padding = FLastProgressLen - S.Length();\r\n    S += UnicodeString::StringOfChar(L' ', Padding) +\r\n      UnicodeString::StringOfChar(L'\\b', Padding);\r\n  }\r\n  FConsole->Print(S, true);\r\n  FLastProgressLen = Str.Length();\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TConsoleRunner::ScriptTerminalPromptUser(TTerminal * /*Terminal*/,\r\n  TPromptKind /*Kind*/, UnicodeString Name, UnicodeString Instructions, TStrings * Prompts,\r\n  TStrings * Results, bool & Result, void * /*Arg*/)\r\n{\r\n  if (!Instructions.IsEmpty())\r\n  {\r\n    PrintMessage(Instructions);\r\n  }\r\n\r\n  // if there are no prompts, success is default\r\n  Result = true;\r\n\r\n  for (int Index = 0; Index < Prompts->Count; Index++)\r\n  {\r\n    UnicodeString Prompt = Prompts->Strings[Index];\r\n    if (!Prompt.IsEmpty() && (Prompt[Prompt.Length()] != L' '))\r\n    {\r\n      Prompt += L' ';\r\n    }\r\n    int P = Prompt.Pos(L'&');\r\n    if (P > 0)\r\n    {\r\n      Prompt.Delete(P, 1);\r\n    }\r\n    Print(Prompt);\r\n\r\n    UnicodeString AResult = Results->Strings[Index]; // useless\r\n    bool Echo = FLAGSET(int(Prompts->Objects[Index]), pupEcho);\r\n    Result = DoInput(AResult, Echo, InputTimeout(), true);\r\n    Results->Strings[Index] = AResult;\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TConsoleRunner::ScriptShowExtendedException(\r\n  TTerminal * Terminal, Exception * E, void * /*Arg*/)\r\n{\r\n  DoShowException(Terminal, E);\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TConsoleRunner::ScriptTerminalQueryUser(TObject * /*Sender*/,\r\n  const UnicodeString Query, TStrings * MoreMessages, unsigned int Answers,\r\n  const TQueryParams * Params, unsigned int & Answer, TQueryType /*QueryType*/,\r\n  void * /*Arg*/)\r\n{\r\n  UnicodeString AQuery = Query;\r\n  unsigned int Timer = 0;\r\n  unsigned int Timeout = 0;\r\n  unsigned int TimeoutA = 0;\r\n  unsigned int NoBatchA = 0;\r\n\r\n  if (Params != NULL)\r\n  {\r\n    if (Params->Timeout > 0)\r\n    {\r\n      Timeout = Params->Timeout;\r\n      TimeoutA = Params->TimeoutAnswer;\r\n    }\r\n\r\n    if (Params->Timer > 0)\r\n    {\r\n      Timer = Params->Timer;\r\n      if (Params->TimerAnswers > 0)\r\n      {\r\n        Answers = Params->TimerAnswers;\r\n      }\r\n      // not considering TimerQueryType as we do not use QueryType anyway\r\n      if (!Params->TimerMessage.IsEmpty())\r\n      {\r\n        AQuery = Params->TimerMessage;\r\n      }\r\n    }\r\n\r\n    if (FLAGSET(Params->Params, qpFatalAbort))\r\n    {\r\n      AQuery = FMTLOAD(WARN_FATAL_ERROR, (AQuery));\r\n    }\r\n\r\n    NoBatchA = Params->NoBatchAnswers;\r\n\r\n    if (FLAGSET(Params->Params, qpWaitInBatch))\r\n    {\r\n      DebugAssert(Timeout == 0);\r\n      Timeout = InputTimeout();\r\n      if (Timeout != 0)\r\n      {\r\n        // See a duplicate AbortAnswer call below\r\n        TimeoutA = AbortAnswer(Answers & ~NoBatchA);\r\n      }\r\n    }\r\n  }\r\n\r\n  AQuery = UnformatMessage(AQuery);\r\n  AQuery = RemoveInteractiveMsgTag(AQuery);\r\n\r\n  ApplyTabs(AQuery, L' ', NULL, NULL);\r\n\r\n  unsigned int AAnswers = Answers;\r\n\r\n  UnicodeString Message = AQuery;\r\n  PrintMessage(AQuery);\r\n  if ((MoreMessages != NULL) && (MoreMessages->Count > 0))\r\n  {\r\n    PrintMessage(MoreMessages->Text);\r\n    Message += L\"\\n\" + MoreMessages->Text;\r\n  }\r\n\r\n  std::vector<unsigned int> Buttons;\r\n  std::vector<UnicodeString> Captions;\r\n  std::vector<TButtonSubmitEvent> OnSubmits;\r\n\r\n  for (unsigned int Answer = qaFirst; Answer <= qaLast; Answer = Answer << 1)\r\n  {\r\n    if (FLAGSET(Answers, Answer))\r\n    {\r\n      UnicodeString Name; // unused\r\n      UnicodeString Caption;\r\n      AnswerNameAndCaption(Answer, Name, Caption);\r\n      Captions.push_back(Caption);\r\n      Buttons.push_back(Answer);\r\n      OnSubmits.push_back(NULL);\r\n      AAnswers -= Answer;\r\n    }\r\n  }\r\n\r\n  DebugUsedParam(AAnswers);\r\n  DebugAssert(AAnswers == 0);\r\n  DebugAssert(!Buttons.empty());\r\n\r\n  if ((Params != NULL) && (Params->Aliases != NULL))\r\n  {\r\n    for (unsigned int bi = 0; bi < Buttons.size(); bi++)\r\n    {\r\n      for (unsigned int ai = 0; ai < Params->AliasesCount; ai++)\r\n      {\r\n        if (Params->Aliases[ai].Button == Buttons[bi])\r\n        {\r\n          if (!Params->Aliases[ai].Alias.IsEmpty())\r\n          {\r\n            Captions[bi] = Params->Aliases[ai].Alias;\r\n          }\r\n          OnSubmits[bi] = Params->Aliases[ai].OnSubmit;\r\n          break;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  UnicodeString Accels;\r\n  for (unsigned int Index = 0; Index < Buttons.size(); Index++)\r\n  {\r\n    UnicodeString & Caption = Captions[Index];\r\n    int P = Caption.Pos(L'&');\r\n    if ((P > 0) && (P < Caption.Length()))\r\n    {\r\n      wchar_t Accel = AnsiUpperCase(Caption)[P + 1];\r\n      if (Accels.Pos(Accel) > 0)\r\n      {\r\n        Caption.Delete(P, 1);\r\n        Accels += L' ';\r\n      }\r\n      else\r\n      {\r\n        Accels += Accel;\r\n      }\r\n    }\r\n    else\r\n    {\r\n      Accels += L' ';\r\n    }\r\n  }\r\n\r\n  DebugAssert(Accels.Length() == static_cast<int>(Buttons.size()));\r\n  int NumberAccel = 0;\r\n  unsigned int CancelA = CancelAnswer(Answers);\r\n  int CancelIndex;\r\n  // AbortAnswer call duplicated in qpWaitInBatch branch above\r\n  unsigned int AbortA = AbortAnswer(Answers & ~NoBatchA);\r\n  int AbortIndex;\r\n  unsigned int ContinueA = ContinueAnswer(Answers & ~NoBatchA);\r\n  int ContinueIndex;\r\n  int TimeoutIndex = 0;\r\n\r\n  for (unsigned int Index = 0; Index < Buttons.size(); Index++)\r\n  {\r\n    UnicodeString & Caption = Captions[Index];\r\n\r\n    if (Accels[Index + 1] == L' ')\r\n    {\r\n      for (int Index2 = 1; Index2 <= Caption.Length(); Index2++)\r\n      {\r\n        wchar_t C = AnsiUpperCase(Caption)[Index2];\r\n        if (IsLetter(C) && (Accels.Pos(C) == 0))\r\n        {\r\n          Caption.Insert(L\"&\", Index2);\r\n          Accels[Index + 1] = C;\r\n          break;\r\n        }\r\n      }\r\n    }\r\n\r\n    if (Accels[Index + 1] == L' ')\r\n    {\r\n      for (int Index2 = 1; Index2 <= Caption.Length(); Index2++)\r\n      {\r\n        wchar_t C = AnsiUpperCase(Caption)[Index2];\r\n        if ((C != L' ') && (Accels.Pos(C) == 0))\r\n        {\r\n          Caption.Insert(L\"&\", Index2);\r\n          Accels[Index + 1] = C;\r\n          break;\r\n        }\r\n      }\r\n    }\r\n\r\n    if (Accels[Index + 1] == L' ')\r\n    {\r\n      NumberAccel++;\r\n      DebugAssert(NumberAccel <= 9);\r\n      Caption = FORMAT(L\"&%d%s\", (NumberAccel, Caption));\r\n      Accels[Index + 1] = Caption[2];\r\n    }\r\n\r\n    if (Buttons[Index] == CancelA)\r\n    {\r\n      CancelIndex = Index + 1;\r\n    }\r\n    if (Buttons[Index] == AbortA)\r\n    {\r\n      AbortIndex = Index + 1;\r\n    }\r\n    if (Buttons[Index] == ContinueA)\r\n    {\r\n      ContinueIndex = Index + 1;\r\n    }\r\n    if (Buttons[Index] == TimeoutA)\r\n    {\r\n      TimeoutIndex = Index + 1;\r\n    }\r\n  }\r\n\r\n  DebugAssert(Accels.Pos(L' ') == 0);\r\n\r\n  bool Timeouting = (Timeout > 0);\r\n  bool FirstOutput = true;\r\n\r\n  do\r\n  {\r\n    Answer = 0;\r\n    int AnswerIndex;\r\n    bool Retry;\r\n\r\n    do\r\n    {\r\n      Retry = false;\r\n\r\n      if (FirstOutput || FConsole->LiveOutput())\r\n      {\r\n        UnicodeString Output;\r\n        for (unsigned int i = 0; i < Buttons.size(); i++)\r\n        {\r\n          if (i > 0)\r\n          {\r\n            Output += L\", \";\r\n          }\r\n\r\n          UnicodeString Caption = Captions[i];\r\n          int P = Caption.Pos(L'&');\r\n          if (DebugAlwaysTrue(P >= 0))\r\n          {\r\n            Caption[P] = L'(';\r\n            Caption.Insert(L\")\", P + 2);\r\n          }\r\n\r\n          if (i + 1 == static_cast<unsigned int>(TimeoutIndex))\r\n          {\r\n            DebugAssert(Timeouting);\r\n            Caption = FMTLOAD(TIMEOUT_BUTTON, (Caption, int(Timeout / MSecsPerSec)));\r\n          }\r\n\r\n          Output += Caption;\r\n        }\r\n        Output += L\": \";\r\n\r\n        // note that length of string may decrease over time due to number of\r\n        // seconds length, but supposing it decreases by one character at time\r\n        // at most, we do not mind as the prompt is terminated with space\r\n\r\n        // If output is not live (file or pipe), do not use 'from beginning'\r\n        // as it means that the output is not actually stored until new line\r\n        // is sent (and we will not [because we cannot] rewrite the output anyway)\r\n        Print(Output, !FirstOutput);\r\n        FirstOutput = false;\r\n      }\r\n\r\n      if (!Timeouting && (FScript->Batch == TScript::BatchContinue))\r\n      {\r\n        AnswerIndex = ContinueIndex;\r\n      }\r\n      else if (!Timeouting && (FScript->Batch != TScript::BatchOff))\r\n      {\r\n        AnswerIndex = AbortIndex;\r\n      }\r\n      else if (Timeouting && (Timeout < MSecsPerSec))\r\n      {\r\n        AnswerIndex = TimeoutIndex;\r\n      }\r\n      else\r\n      {\r\n        unsigned int ActualTimer;\r\n        if (Timeouting)\r\n        {\r\n          if (Timer == 0)\r\n          {\r\n            if (FConsole->NoInteractiveInput())\r\n            {\r\n              ActualTimer = Timeout;\r\n            }\r\n            else\r\n            {\r\n              ActualTimer = MSecsPerSec;\r\n            }\r\n          }\r\n          else\r\n          {\r\n            if (Timer < MSecsPerSec)\r\n            {\r\n              ActualTimer = Timer;\r\n            }\r\n            else\r\n            {\r\n              ActualTimer = MSecsPerSec;\r\n            }\r\n          }\r\n        }\r\n        else\r\n        {\r\n          ActualTimer = Timer;\r\n        }\r\n        // Not to get preliminary \"host is not responding\" messages to .NET assembly\r\n        if (FConsole->NoInteractiveInput() && (Timer > 0))\r\n        {\r\n          Sleep(Timer);\r\n          AnswerIndex = -2;\r\n        }\r\n        else\r\n        {\r\n          AnswerIndex =\r\n            FConsole->Choice(Accels, CancelIndex, -1, ContinueIndex, -2, Timeouting, ActualTimer, Message);\r\n        }\r\n        if (AnswerIndex == -1)\r\n        {\r\n          NotifyAbort();\r\n          AnswerIndex = AbortIndex;\r\n        }\r\n        else if (AnswerIndex == -2)\r\n        {\r\n          if (Timeouting)\r\n          {\r\n            DebugAssert(Timeout >= MSecsPerSec);\r\n            Timeout -= ActualTimer;\r\n            Retry = true;\r\n          }\r\n\r\n          // this does not take Timer into account,\r\n          // but as of now Timer is used for TSecureShell timeout prompt only,\r\n          // where Timer is less than MSecsPerSec\r\n          if (Timer > 0)\r\n          {\r\n            DebugAssert((Params != NULL) && (Params->TimerEvent != NULL));\r\n            if ((Params != NULL) && (Params->TimerEvent != NULL))\r\n            {\r\n              unsigned int AAnswer = 0;\r\n              Params->TimerEvent(AAnswer);\r\n              if (AAnswer != 0)\r\n              {\r\n                Answer = AAnswer;\r\n                Retry = false;\r\n              }\r\n              else\r\n              {\r\n                Retry = true;\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n    while (Retry);\r\n\r\n    if (Answer == 0)\r\n    {\r\n      DebugAssert((AnswerIndex >= 1) && (AnswerIndex <= Accels.Length()));\r\n      UnicodeString AnswerCaption = Captions[AnswerIndex - 1];\r\n      int P = AnswerCaption.Pos(L\"&\");\r\n      DebugAssert(P >= 0);\r\n      AnswerCaption.Delete(P, 1);\r\n      FConsole->PrintLine(AnswerCaption);\r\n      FirstOutput = true;\r\n\r\n      if (OnSubmits[AnswerIndex - 1] != NULL)\r\n      {\r\n        OnSubmits[AnswerIndex - 1](NULL, Answer);\r\n      }\r\n      else\r\n      {\r\n        Answer = Buttons[AnswerIndex - 1];\r\n      }\r\n    }\r\n    else\r\n    {\r\n      FConsole->PrintLine();\r\n    }\r\n  }\r\n  while (Answer == 0);\r\n\r\n  if ((Answer == AbortA) &&\r\n      ((Params == NULL) || FLAGCLEAR(Params->Params, qpIgnoreAbort)))\r\n  {\r\n    if (FScript->Terminal != NULL)\r\n    {\r\n      TStrings * Messages = new TStringList();\r\n      try\r\n      {\r\n        Messages->Add(Query);\r\n        if (MoreMessages != NULL)\r\n        {\r\n          Messages->AddStrings(MoreMessages);\r\n        }\r\n        FScript->Terminal->ActionLog->AddFailure(Messages);\r\n      }\r\n      __finally\r\n      {\r\n        delete Messages;\r\n      }\r\n    }\r\n\r\n    FCommandError = true;\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TConsoleRunner::ScriptQueryCancel(TScript * /*Script*/, bool & Cancel)\r\n{\r\n  if (Aborted())\r\n  {\r\n    Cancel = true;\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TConsoleRunner::ScriptSynchronizeStartStop(TScript * /*Script*/,\r\n  const UnicodeString LocalDirectory, const UnicodeString RemoteDirectory,\r\n  const TCopyParamType & CopyParam, int SynchronizeParams)\r\n{\r\n  TSynchronizeParamType Params;\r\n  Params.LocalDirectory = LocalDirectory;\r\n  Params.RemoteDirectory = RemoteDirectory;\r\n  Params.Params = SynchronizeParams;\r\n  Params.Options = soRecurse;\r\n\r\n  FSynchronizeController.StartStop(Application, true, Params,\r\n    CopyParam, NULL, SynchronizeControllerAbort, NULL,\r\n    SynchronizeControllerLog);\r\n\r\n  try\r\n  {\r\n    FSynchronizeAborted = false;\r\n\r\n    while (!FSynchronizeAborted && !Aborted(false))\r\n    {\r\n      Application->HandleMessage();\r\n      FScript->Terminal->Idle();\r\n    }\r\n  }\r\n  __finally\r\n  {\r\n    FSynchronizeController.StartStop(Application, false, Params,\r\n      CopyParam, NULL, SynchronizeControllerAbort, NULL,\r\n      SynchronizeControllerLog);\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TConsoleRunner::ScriptProgress(TScript * /*Script*/, TScriptProgress & Progress)\r\n{\r\n  FConsole->Progress(Progress);\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TConsoleRunner::SynchronizeControllerLog(\r\n  TSynchronizeController * /*Controller*/, TSynchronizeLogEntry /*Entry*/,\r\n  const UnicodeString Message)\r\n{\r\n  PrintMessage(Message);\r\n  LogSynchronizeEvent(FScript->Terminal, Message);\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TConsoleRunner::SynchronizeControllerAbort(TObject * /*Sender*/,\r\n  bool /*Close*/)\r\n{\r\n  FSynchronizeAborted = true;\r\n  NotifyAbort();\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TConsoleRunner::SynchronizeControllerSynchronize(\r\n  TSynchronizeController * /*Sender*/, const UnicodeString LocalDirectory,\r\n  const UnicodeString RemoteDirectory, const TCopyParamType & CopyParam,\r\n  const TSynchronizeParamType & Params, TSynchronizeChecklist ** Checklist,\r\n  TSynchronizeOptions * /*Options*/, bool Full)\r\n{\r\n  if (!Full)\r\n  {\r\n    try\r\n    {\r\n      FScript->Synchronize(LocalDirectory, RemoteDirectory, CopyParam,\r\n        Params.Params, Checklist);\r\n    }\r\n    catch (Exception & E)\r\n    {\r\n      if ((FScript->Batch == TScript::BatchContinue) &&\r\n          FScript->Terminal->Active)\r\n      {\r\n        // noop\r\n      }\r\n      else\r\n      {\r\n        throw;\r\n      }\r\n    }\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TConsoleRunner::SynchronizeControllerSynchronizeInvalid(\r\n  TSynchronizeController * /*Sender*/, const UnicodeString Directory, const UnicodeString ErrorStr)\r\n{\r\n  if (!Directory.IsEmpty())\r\n  {\r\n    PrintMessage(FMTLOAD(WATCH_ERROR_DIRECTORY, (Directory)), true);\r\n  }\r\n  else\r\n  {\r\n    PrintMessage(LoadStr(WATCH_ERROR_GENERAL), true);\r\n  }\r\n\r\n  if (!ErrorStr.IsEmpty())\r\n  {\r\n    PrintMessage(ErrorStr, true);\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TConsoleRunner::SynchronizeControllerTooManyDirectories(\r\n  TSynchronizeController * /*Sender*/, int & MaxDirectories)\r\n{\r\n  if (Aborted())\r\n  {\r\n    Abort();\r\n  }\r\n\r\n  if (MaxDirectories < GUIConfiguration->MaxWatchDirectories)\r\n  {\r\n    MaxDirectories = GUIConfiguration->MaxWatchDirectories;\r\n  }\r\n  else\r\n  {\r\n    MaxDirectories *= 2;\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TConsoleRunner::ShowException(Exception * E)\r\n{\r\n  DoShowException(NULL, E);\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TConsoleRunner::DoShowException(TTerminal * Terminal, Exception * E)\r\n{\r\n  if ((Terminal == NULL) && (FScript != NULL))\r\n  {\r\n    Terminal = FScript->Terminal;\r\n  }\r\n\r\n  UnicodeString Message;\r\n  if (ExceptionFullMessage(E, Message))\r\n  {\r\n    FCommandError = true;\r\n    PrintMessage(Message, true);\r\n  }\r\n\r\n  TTerminal * LoggingTerminal = Terminal;\r\n  TSecondaryTerminal * SecondaryTerminal = dynamic_cast<TSecondaryTerminal *>(LoggingTerminal);\r\n  if (SecondaryTerminal != NULL)\r\n  {\r\n    LoggingTerminal = SecondaryTerminal->MainTerminal;\r\n  }\r\n\r\n  if (LoggingTerminal != NULL)\r\n  {\r\n    LoggingTerminal->ActionLog->AddFailure(E);\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\nbool __fastcall TConsoleRunner::DoInput(UnicodeString & Str, bool Echo,\r\n  unsigned int Timeout, bool Interactive)\r\n{\r\n  bool Result;\r\n  if (Interactive && FConsole->NoInteractiveInput())\r\n  {\r\n    Result = false;\r\n  }\r\n  else\r\n  {\r\n    Result = FConsole->Input(Str, Echo, Timeout);\r\n  }\r\n\r\n  if (!Result)\r\n  {\r\n    NotifyAbort();\r\n  }\r\n\r\n  return Result;\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TConsoleRunner::MasterPasswordPrompt()\r\n{\r\n  bool Retry;\r\n  do\r\n  {\r\n    UnicodeString Password;\r\n    Input(LoadStr(CONSOLE_MASTER_PASSWORD_PROMPT), Password, false, true);\r\n    Retry = !WinConfiguration->ValidateMasterPassword(Password);\r\n    if (Retry)\r\n    {\r\n      FConsole->PrintLine(LoadStr(MASTER_PASSWORD_INCORRECT));\r\n    }\r\n    else\r\n    {\r\n      WinConfiguration->SetMasterPassword(Password);\r\n    }\r\n  }\r\n  while (Retry);\r\n\r\n}\r\n//---------------------------------------------------------------------------\r\nUnicodeString TConsoleRunner::ExpandCommand(UnicodeString Command, TStrings * ScriptParameters)\r\n{\r\n  DebugAssert(ScriptParameters != NULL);\r\n  for (int Index = 0; Index < ScriptParameters->Count; Index++)\r\n  {\r\n    Command = ReplaceStr(Command, FORMAT(L\"%%%d%%\", (Index+1)),\r\n      ScriptParameters->Strings[Index]);\r\n  }\r\n\r\n  TDateTime N = Now();\r\n\r\n  if (!FExternalTimestampVar)\r\n  {\r\n    Command =\r\n      ReplaceStr(Command, FORMAT(L\"%%%s%%\", (TimestampVarName)), FormatDateTime(L\"yyyymmddhhnnss\", N));\r\n  }\r\n\r\n  int Offset = 1;\r\n  int P2;\r\n  do\r\n  {\r\n    int P = Pos(UpperCase(L\"%\" + TimestampVarName), UpperCase(Command), Offset);\r\n    if (P > 0)\r\n    {\r\n      Offset = P + 1 + TimestampVarName.Length();\r\n      P2 = Pos(L\"%\", Command, Offset);\r\n      int P3 = Pos(L\"#\", Command, Offset);\r\n      if ((P2 > 0) && (P3 > 0) && (P3 < P2) &&\r\n          ((P3 == Offset) || (Command[Offset] == L'+') || (Command[Offset] == L'-')))\r\n      {\r\n        bool Valid = true;\r\n        TDateTime T = N;\r\n        if (P3 > Offset)\r\n        {\r\n          bool Add = (Command[Offset] == L'+');\r\n          Offset++;\r\n          Valid = TryRelativeStrToDateTime(Command.SubString(Offset, P3 - Offset), T, Add);\r\n        }\r\n\r\n        Offset = P3 + 1;\r\n        if (Valid)\r\n        {\r\n          UnicodeString TimestampFormat = Command.SubString(Offset, P2 - Offset);\r\n          UnicodeString TimestampValue = FormatDateTime(TimestampFormat, T);\r\n          Command = Command.SubString(1, P - 1) + TimestampValue + Command.SubString(P2 + 1, Command.Length() - P2);\r\n          Offset = P + TimestampValue.Length();\r\n        }\r\n      }\r\n    }\r\n    else\r\n    {\r\n      P2 = 0;\r\n    }\r\n  }\r\n  while (P2 > 0);\r\n\r\n  Command = ExpandEnvironmentVariables(Command);\r\n  return Command;\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TConsoleRunner::Failed(bool & AnyError)\r\n{\r\n  if (FScript != NULL)\r\n  {\r\n    FScript->Log(llMessage, L\"Failed\");\r\n  }\r\n  AnyError = true;\r\n}\r\n//---------------------------------------------------------------------------\r\nint __fastcall TConsoleRunner::Run(const UnicodeString Session, TOptions * Options,\r\n  TStrings * ScriptCommands, TStrings * ScriptParameters)\r\n{\r\n  int ExitCode;\r\n  try\r\n  {\r\n    bool AnyError = false;\r\n\r\n    try\r\n    {\r\n      FScript = new TManagementScript(StoredSessions, FConsole->LimitedOutput());\r\n\r\n      FScript->CopyParam = GUIConfiguration->DefaultCopyParam;\r\n      FScript->SynchronizeParams = GUIConfiguration->SynchronizeParams;\r\n      FScript->WantsProgress = FConsole->WantsProgress();\r\n      FScript->OnPrint = ScriptPrint;\r\n      FScript->OnPrintProgress = ScriptPrintProgress;\r\n      FScript->OnInput = ScriptInput;\r\n      FScript->OnTerminalPromptUser = ScriptTerminalPromptUser;\r\n      FScript->OnShowExtendedException = ScriptShowExtendedException;\r\n      FScript->OnTerminalQueryUser = ScriptTerminalQueryUser;\r\n      FScript->OnQueryCancel = ScriptQueryCancel;\r\n      FScript->OnSynchronizeStartStop = ScriptSynchronizeStartStop;\r\n      FScript->OnProgress = ScriptProgress;\r\n      FScript->Interactive = (ScriptCommands == NULL) && FConsole->Interactive();\r\n\r\n      UpdateTitle();\r\n\r\n      // everything until the first manually entered command is \"batch\"\r\n      // (including opening session from command line and script file)\r\n      FBatchScript = true;\r\n\r\n      if (!Session.IsEmpty())\r\n      {\r\n        if (!FScript->Interactive)\r\n        {\r\n          PrintMessage(LoadStr(SCRIPT_CMDLINE_SESSION));\r\n        }\r\n        FCommandError = false;\r\n        FScript->Connect(Session, Options, false);\r\n        if (FCommandError)\r\n        {\r\n          Failed(AnyError);\r\n        }\r\n      }\r\n\r\n      FScript->Groups = Options->SwitchValue(L\"xmlgroups\", true, false);\r\n\r\n      int ScriptPos = 0;\r\n      bool Result;\r\n      do\r\n      {\r\n        UpdateTitle();\r\n\r\n        UnicodeString Command;\r\n        if ((ScriptCommands != NULL) && (ScriptPos < ScriptCommands->Count))\r\n        {\r\n          Result = true;\r\n          Command = ScriptCommands->Strings[ScriptPos];\r\n          ScriptPos++;\r\n        }\r\n        else\r\n        {\r\n          if (FBatchScript)\r\n          {\r\n            // no longer batch\r\n            FBatchScript = false;\r\n            FScript->StartInteractive();\r\n          }\r\n          Print(L\"winscp> \");\r\n          Result = DoInput(Command, true, 0, false);\r\n        }\r\n\r\n        if (Result)\r\n        {\r\n          FCommandError = false;\r\n          FScript->Command(ExpandCommand(Command, ScriptParameters));\r\n\r\n          if (FCommandError)\r\n          {\r\n            Failed(AnyError);\r\n            if (FScript->Batch == TScript::BatchAbort)\r\n            {\r\n              Result = false;\r\n            }\r\n          }\r\n\r\n          if (FScript->Terminal != NULL)\r\n          {\r\n            FScript->Terminal->Idle();\r\n          }\r\n        }\r\n      }\r\n      while (Result && FScript->Continue && !Aborted());\r\n    }\r\n    catch(Exception & E)\r\n    {\r\n      Failed(AnyError);\r\n      ShowException(&E);\r\n    }\r\n\r\n    if (FLastProgressLen > 0)\r\n    {\r\n      FConsole->Print(L\"\\n\");\r\n      FLastProgressLen = 0;\r\n    }\r\n\r\n    ExitCode = (AnyError || FAborted) ? RESULT_ANY_ERROR : RESULT_SUCCESS;\r\n\r\n    if (FScript != NULL)\r\n    {\r\n      UnicodeString ExitCodeMessage = FORMAT(L\"Exit code: %d\", (ExitCode));\r\n      FScript->Log(llMessage, ExitCodeMessage);\r\n      if (Configuration->LogProtocol >= 1)\r\n      {\r\n        FConsole->Print(ExitCodeMessage + L\"\\n\");\r\n        UnicodeString LogMessage = FConsole->FinalLogMessage();\r\n        if (!LogMessage.IsEmpty())\r\n        {\r\n          FScript->Log(llMessage, LogMessage);\r\n          FConsole->Print(LogMessage + L\"\\n\");\r\n        }\r\n      }\r\n    }\r\n  }\r\n  __finally\r\n  {\r\n    delete FScript;\r\n    FScript = NULL;\r\n  }\r\n\r\n  return ExitCode;\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TConsoleRunner::UpdateTitle()\r\n{\r\n  UnicodeString NewTitle;\r\n  if (FScript->Terminal != NULL)\r\n  {\r\n    NewTitle = FormatMainFormCaption(FScript->Terminal->SessionData->SessionName);\r\n  }\r\n  else\r\n  {\r\n    NewTitle = FormatMainFormCaption(L\"\");\r\n  }\r\n  FConsole->SetTitle(NewTitle);\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall TConsoleRunner::ConfigurationChange(TObject * /*Sender*/)\r\n{\r\n  if (FScript != NULL)\r\n  {\r\n    FScript->ReflectSettings();\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\nstatic UnicodeString __fastcall GetExeBaseName()\r\n{\r\n  return ExtractFileBaseName(Application->ExeName);\r\n}\r\n//---------------------------------------------------------------------------\r\nstatic void __fastcall PrintUsageSyntax(TConsole * Console, const UnicodeString & Str)\r\n{\r\n  Console->PrintLine(GetExeBaseName() + L\" \" + Str);\r\n}\r\n//---------------------------------------------------------------------------\r\ntypedef std::vector<std::pair<UnicodeString, UnicodeString> > TSwitchesUsage;\r\n//---------------------------------------------------------------------------\r\nstatic void __fastcall RegisterSwitch(\r\n  TSwitchesUsage & SwitchesUsage, const UnicodeString & Name, const UnicodeString & Desc)\r\n{\r\n  SwitchesUsage.push_back(std::make_pair(LowerCase(Name), Desc));\r\n}\r\n//---------------------------------------------------------------------------\r\nstatic void __fastcall RegisterSwitch(\r\n  TSwitchesUsage & SwitchesUsage, const UnicodeString & Name, int DescID)\r\n{\r\n  UnicodeString Desc = LoadStr(DescID);\r\n  Desc = ReplaceText(Desc, L\"%APP%\", GetExeBaseName());\r\n  RegisterSwitch(SwitchesUsage, Name, Desc);\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall Usage(TConsole * Console)\r\n{\r\n  Console->PrintLine(FORMAT(L\"WinSCP, %s\", (Configuration->VersionStr)));\r\n  UnicodeString Copyright =\r\n    ReplaceText(LoadStr(WINSCP_COPYRIGHT), L\"\u00a9\", L\"(c)\");\r\n  Console->PrintLine(Copyright);\r\n  Console->PrintLine();\r\n  Console->PrintLine(LoadStr(USAGE_SYNTAX_LABEL));\r\n\r\n  if (!Console->CommandLineOnly())\r\n  {\r\n    PrintUsageSyntax(Console, L\"site|workspace|folder\");\r\n    PrintUsageSyntax(Console, L\"(sftp|scp|ftp[es]|dav[s]|s3)://[user[:password]@]host[:port][/path/[file]]\");\r\n    PrintUsageSyntax(Console, FORMAT(L\"[mysession] /%s=<name>\", (LowerCase(SESSIONNAME_SWICH))));\r\n    PrintUsageSyntax(Console, L\"[mysession] /newinstance\");\r\n    PrintUsageSyntax(Console, L\"[mysession] /edit <path>\");\r\n    PrintUsageSyntax(Console, FORMAT(L\"[mysession] /%s[=<file>]\", (LowerCase(BROWSE_SWITCH))));\r\n    PrintUsageSyntax(Console, FORMAT(L\"[mysession] /%s [local_dir] [remote_dir] [/%s]\", (LowerCase(SYNCHRONIZE_SWITCH), LowerCase(DEFAULTS_SWITCH))));\r\n    PrintUsageSyntax(Console, FORMAT(L\"[mysession] /%s [local_dir] [remote_dir] [/%s]\", (LowerCase(KEEP_UP_TO_DATE_SWITCH), LowerCase(DEFAULTS_SWITCH))));\r\n    PrintUsageSyntax(Console, FORMAT(L\"[mysession] /%s [path]\", (LowerCase(REFRESH_SWITCH))));\r\n    PrintUsageSyntax(Console, FORMAT(L\"[mysession] [/privatekey=<file> [/%s=<passphrase>]]\", (PassphraseOption)));\r\n    PrintUsageSyntax(Console, L\"[mysession] [/hostkey=<fingerprint>]\");\r\n    PrintUsageSyntax(Console, FORMAT(L\"[mysession] [/clientcert=<file> [/%s=<passphrase>]]\", (PassphraseOption)));\r\n    PrintUsageSyntax(Console, L\"[mysession] [/certificate=<fingerprint>]\");\r\n    PrintUsageSyntax(Console, L\"[mysession] [/passive[=on|off]] [/implicit|explicit]\");\r\n    PrintUsageSyntax(Console, L\"[mysession] [/timeout=<sec>]\");\r\n    PrintUsageSyntax(Console, L\"[mysession] [/rawsettings setting1=value1 setting2=value2 ...]\");\r\n  }\r\n  PrintUsageSyntax(Console,\r\n    UnicodeString(!Console->CommandLineOnly() ? L\"[/console] \" : L\"\") +\r\n    FORMAT(L\"[/script=<file>] [/%s cmd1...] [/parameter // param1...]\", (LowerCase(COMMAND_SWITCH))));\r\n  PrintUsageSyntax(Console,\r\n    FORMAT(L\"[/%s=<logfile> [/loglevel=<level>]] [/%s=[<count>%s]<size>]\", (LowerCase(LOG_SWITCH), LowerCase(LOGSIZE_SWITCH), LOGSIZE_SEPARATOR)));\r\n  PrintUsageSyntax(Console, L\"[/xmllog=<logfile> [/xmlgroups]]\");\r\n  PrintUsageSyntax(Console,\r\n    FORMAT(L\"[/%s=<inifile>]\", (LowerCase(INI_SWITCH))));\r\n  PrintUsageSyntax(Console, FORMAT(L\"[/%s config1=value1 config2=value2 ...]\", (LowerCase(RAW_CONFIG_SWITCH))));\r\n  PrintUsageSyntax(Console, FORMAT(L\"[/%s setting1=value1 setting2=value2 ...]\", (LowerCase(RAWTRANSFERSETTINGS_SWITCH))));\r\n  PrintUsageSyntax(Console, L\"/batchsettings <site_mask> setting1=value1 setting2=value2 ...\");\r\n  PrintUsageSyntax(Console, FORMAT(L\"/%s keyfile [/%s=<file>] [/%s] [/%s=<text>]\",\r\n    (LowerCase(KEYGEN_SWITCH), LowerCase(KEYGEN_OUTPUT_SWITCH), LowerCase(KEYGEN_CHANGE_PASSPHRASE_SWITCH), LowerCase(KEYGEN_COMMENT_SWITCH))));\r\n  if (!Console->CommandLineOnly())\r\n  {\r\n    PrintUsageSyntax(Console, L\"/update\");\r\n  }\r\n  PrintUsageSyntax(Console, TProgramParams::FormatSwitch(LowerCase(INFO_SWITCH)));\r\n  PrintUsageSyntax(Console, L\"/help\");\r\n\r\n  Console->PrintLine();\r\n\r\n  TSwitchesUsage SwitchesUsage;\r\n  if (!Console->CommandLineOnly())\r\n  {\r\n    RegisterSwitch(SwitchesUsage, L\"session\", USAGE_SESSION);\r\n    RegisterSwitch(SwitchesUsage, TProgramParams::FormatSwitch(SESSIONNAME_SWICH) + L\"=\", USAGE_SESSIONNAME);\r\n    RegisterSwitch(SwitchesUsage, L\"/newinstance\", USAGE_NEWINSTANCE);\r\n    RegisterSwitch(SwitchesUsage, L\"/edit\", USAGE_EDIT);\r\n    RegisterSwitch(SwitchesUsage, TProgramParams::FormatSwitch(BROWSE_SWITCH), USAGE_BROWSE);\r\n    RegisterSwitch(SwitchesUsage, TProgramParams::FormatSwitch(SYNCHRONIZE_SWITCH), USAGE_SYNCHRONIZE);\r\n    RegisterSwitch(SwitchesUsage, TProgramParams::FormatSwitch(KEEP_UP_TO_DATE_SWITCH), USAGE_KEEPUPTODATE);\r\n    RegisterSwitch(SwitchesUsage, TProgramParams::FormatSwitch(REFRESH_SWITCH), USAGE_REFRESH);\r\n    RegisterSwitch(SwitchesUsage, TProgramParams::FormatSwitch(DEFAULTS_SWITCH), USAGE_DEFAULTS);\r\n    RegisterSwitch(SwitchesUsage, L\"/privatekey=\", USAGE_PRIVATEKEY);\r\n    RegisterSwitch(SwitchesUsage, L\"/hostkey=\", USAGE_HOSTKEY);\r\n    RegisterSwitch(SwitchesUsage, L\"/clientcert=\", USAGE_CLIENTCERT);\r\n    RegisterSwitch(SwitchesUsage, L\"/certificate=\", USAGE_CERTIFICATE);\r\n    RegisterSwitch(SwitchesUsage, TProgramParams::FormatSwitch(PassphraseOption) + L\"=\", USAGE_PASSPHRASE);\r\n    RegisterSwitch(SwitchesUsage, L\"/passive=\", USAGE_PASSIVE);\r\n    RegisterSwitch(SwitchesUsage, L\"/implicit\", USAGE_IMPLICIT);\r\n    RegisterSwitch(SwitchesUsage, L\"/explicit\", USAGE_EXPLICIT);\r\n    RegisterSwitch(SwitchesUsage, L\"/timeout=\", USAGE_TIMEOUT);\r\n    RegisterSwitch(SwitchesUsage, L\"/rawsettings\", USAGE_RAWSETTINGS);\r\n    RegisterSwitch(SwitchesUsage, L\"/console\", USAGE_CONSOLE);\r\n  }\r\n  RegisterSwitch(SwitchesUsage, L\"/script=\", USAGE_SCRIPT);\r\n  RegisterSwitch(SwitchesUsage, TProgramParams::FormatSwitch(COMMAND_SWITCH), USAGE_COMMAND);\r\n  RegisterSwitch(SwitchesUsage, L\"/parameter\", USAGE_PARAMETER);\r\n  RegisterSwitch(SwitchesUsage, TProgramParams::FormatSwitch(LOG_SWITCH) + L\"=\", USAGE_LOG);\r\n  RegisterSwitch(SwitchesUsage, L\"/loglevel=\", USAGE_LOGLEVEL);\r\n  RegisterSwitch(SwitchesUsage, TProgramParams::FormatSwitch(LOGSIZE_SWITCH) + L\"=\", USAGE_LOGSIZE);\r\n  RegisterSwitch(SwitchesUsage, L\"/xmllog=\", USAGE_XMLLOG);\r\n  RegisterSwitch(SwitchesUsage, L\"/xmlgroups\", USAGE_XMLGROUPS);\r\n  RegisterSwitch(SwitchesUsage, TProgramParams::FormatSwitch(INI_SWITCH) + L\"=\", USAGE_INI);\r\n  RegisterSwitch(SwitchesUsage, TProgramParams::FormatSwitch(RAW_CONFIG_SWITCH), USAGE_RAWCONFIG);\r\n  RegisterSwitch(SwitchesUsage, TProgramParams::FormatSwitch(RAWTRANSFERSETTINGS_SWITCH), USAGE_RAWTRANSFERSETTINGS);\r\n  RegisterSwitch(SwitchesUsage, L\"/batchsettings\", USAGE_BATCHSETTINGS);\r\n  UnicodeString KeyGenDesc =\r\n    FMTLOAD(USAGE_KEYGEN, (\r\n      TProgramParams::FormatSwitch(LowerCase(KEYGEN_OUTPUT_SWITCH)) + L\"=\",\r\n      TProgramParams::FormatSwitch(LowerCase(KEYGEN_CHANGE_PASSPHRASE_SWITCH)),\r\n      TProgramParams::FormatSwitch(LowerCase(KEYGEN_COMMENT_SWITCH)) + L\"=\"));\r\n  RegisterSwitch(SwitchesUsage, TProgramParams::FormatSwitch(KEYGEN_SWITCH), KeyGenDesc);\r\n  if (!Console->CommandLineOnly())\r\n  {\r\n    RegisterSwitch(SwitchesUsage, L\"/update\", USAGE_UPDATE);\r\n  }\r\n  RegisterSwitch(SwitchesUsage, TProgramParams::FormatSwitch(INFO_SWITCH), USAGE_INFO);\r\n  RegisterSwitch(SwitchesUsage, L\"/help\", USAGE_HELP);\r\n\r\n  int MaxSwitchLen = 0;\r\n  TSwitchesUsage::const_iterator Index = SwitchesUsage.begin();\r\n  while (Index != SwitchesUsage.end())\r\n  {\r\n    MaxSwitchLen = std::max(Index->first.Length(), MaxSwitchLen);\r\n    ++Index;\r\n  }\r\n\r\n  Index = SwitchesUsage.begin();\r\n  while (Index != SwitchesUsage.end())\r\n  {\r\n    UnicodeString Label =\r\n      UnicodeString(L\" \") +\r\n      Index->first +\r\n      UnicodeString::StringOfChar(L' ', MaxSwitchLen - Index->first.Length()) +\r\n      L\" \";\r\n    Console->Print(Label);\r\n\r\n    const int ConsoleWidth = 80;\r\n    int DescWidth = ConsoleWidth - Label.Length() - 1;\r\n\r\n    bool FirstLine = true;\r\n    UnicodeString Desc = Index->second;\r\n    while (!Desc.IsEmpty())\r\n    {\r\n      UnicodeString DescLine = CutToChar(Desc, L'\\n', true);\r\n      DescLine = WrapText(DescLine, L\"\\n\", TSysCharSet() << L' ', DescWidth);\r\n      while (!DescLine.IsEmpty())\r\n      {\r\n        UnicodeString DescLineLine = CutToChar(DescLine, L'\\n', true);\r\n        if (!FirstLine)\r\n        {\r\n          DescLineLine =\r\n            UnicodeString::StringOfChar(L' ', Label.Length()) +\r\n            DescLineLine;\r\n        }\r\n        FirstLine = false;\r\n        Console->PrintLine(DescLineLine);\r\n      }\r\n    }\r\n    ++Index;\r\n  }\r\n\r\n  Console->WaitBeforeExit();\r\n}\r\n//---------------------------------------------------------------------------\r\nint __fastcall HandleException(TConsole * Console, Exception & E)\r\n{\r\n  UnicodeString Message;\r\n  if (ExceptionFullMessage(&E, Message))\r\n  {\r\n    Console->Print(Message);\r\n  }\r\n  return RESULT_ANY_ERROR;\r\n}\r\n//---------------------------------------------------------------------------\r\nint __fastcall BatchSettings(TConsole * Console, TProgramParams * Params)\r\n{\r\n  int Result = RESULT_SUCCESS;\r\n  try\r\n  {\r\n    std::unique_ptr<TStrings> Arguments(new TStringList());\r\n    if (!DebugAlwaysTrue(Params->FindSwitch(L\"batchsettings\", Arguments.get())))\r\n    {\r\n      Abort();\r\n    }\r\n    else\r\n    {\r\n      if (Arguments->Count < 1)\r\n      {\r\n        throw Exception(LoadStr(BATCH_SET_NO_MASK));\r\n      }\r\n      else if (Arguments->Count < 2)\r\n      {\r\n        throw Exception(LoadStr(BATCH_SET_NO_SETTINGS));\r\n      }\r\n      else\r\n      {\r\n        TFileMasks Mask(Arguments->Strings[0]);\r\n        Arguments->Delete(0);\r\n\r\n        std::unique_ptr<TOptionsStorage> OptionsStorage(new TOptionsStorage(Arguments.get(), false));\r\n\r\n        int Matches = 0;\r\n        int Changes = 0;\r\n\r\n        for (int Index = 0; Index < StoredSessions->Count; Index++)\r\n        {\r\n          TSessionData * Data = StoredSessions->Sessions[Index];\r\n          if (!Data->IsWorkspace &&\r\n              Mask.Matches(Data->Name, false, false))\r\n          {\r\n            Matches++;\r\n            std::unique_ptr<TSessionData> OriginalData(new TSessionData(L\"\"));\r\n            OriginalData->CopyDataNoRecrypt(Data);\r\n            Data->ApplyRawSettings(OptionsStorage.get(), false);\r\n            bool Changed = !OriginalData->IsSame(Data, false);\r\n            if (Changed)\r\n            {\r\n              Changes++;\r\n            }\r\n            UnicodeString StateStr = LoadStr(Changed ? BATCH_SET_CHANGED : BATCH_SET_NOT_CHANGED);\r\n            Console->PrintLine(FORMAT(L\"%s - %s\", (Data->Name, StateStr)));\r\n          }\r\n        }\r\n\r\n        StoredSessions->Save(false, true); // explicit\r\n        Console->PrintLine(FMTLOAD(BATCH_SET_SUMMARY, (Matches, Changes)));\r\n      }\r\n    }\r\n  }\r\n  catch (Exception & E)\r\n  {\r\n    Result = HandleException(Console, E);\r\n  }\r\n\r\n  Console->WaitBeforeExit();\r\n  return Result;\r\n}\r\n//---------------------------------------------------------------------------\r\nbool __fastcall FindPuttygenCompatibleSwitch(\r\n  TProgramParams * Params, const UnicodeString & Name, const UnicodeString & PuttygenName, UnicodeString & Value, bool & Set)\r\n{\r\n  bool Result = Params->FindSwitch(Name, Value, Set);\r\n  if (!Result)\r\n  {\r\n    std::unique_ptr<TStrings> Args(new TStringList());\r\n    Result = Params->FindSwitchCaseSensitive(PuttygenName, Args.get(), 1);\r\n    if (Result && (Args->Count >= 1))\r\n    {\r\n      Value = Args->Strings[0];\r\n      Set = true;\r\n    }\r\n  }\r\n  return Result;\r\n}\r\n//---------------------------------------------------------------------------\r\nint __fastcall KeyGen(TConsole * Console, TProgramParams * Params)\r\n{\r\n  int Result = RESULT_SUCCESS;\r\n  UnicodeString Passphrase;\r\n  UnicodeString NewPassphrase;\r\n  try\r\n  {\r\n    UnicodeString InputFileName;\r\n    std::unique_ptr<TStrings> Args(new TStringList());\r\n    if (!Params->FindSwitch(KEYGEN_SWITCH, Args.get(), 1) ||\r\n        (Args->Count < 1) ||\r\n        Args->Strings[0].IsEmpty())\r\n    {\r\n      throw Exception(LoadStr(KEYGEN_NO_INPUT));\r\n    }\r\n    InputFileName = Args->Strings[0];\r\n\r\n    bool ValueSet;\r\n    UnicodeString OutputFileName;\r\n    FindPuttygenCompatibleSwitch(Params, KEYGEN_OUTPUT_SWITCH, L\"o\", OutputFileName, ValueSet);\r\n\r\n    UnicodeString NewComment;\r\n    FindPuttygenCompatibleSwitch(Params, KEYGEN_COMMENT_SWITCH, L\"C\", NewComment, ValueSet);\r\n\r\n    bool NewPassphraseSet;\r\n    bool ChangePassphrase =\r\n      FindPuttygenCompatibleSwitch(Params, KEYGEN_CHANGE_PASSPHRASE_SWITCH, L\"P\", NewPassphrase, NewPassphraseSet);\r\n\r\n    TKeyType Type = KeyType(InputFileName);\r\n    int Error = errno;\r\n    switch (Type)\r\n    {\r\n      case ktSSH1:\r\n        throw Exception(LoadStr(KEYGEN_SSH1));\r\n\r\n      case ktSSH2:\r\n        if (NewComment.IsEmpty() && !ChangePassphrase)\r\n        {\r\n          throw Exception(LoadStr(KEYGEN_NO_ACTION));\r\n        }\r\n        break;\r\n\r\n      case ktOpenSSHPEM:\r\n      case ktOpenSSHNew:\r\n      case ktSSHCom:\r\n        if (OutputFileName.IsEmpty())\r\n        {\r\n          throw Exception(LoadStr(KEYGEN_NO_OUTPUT));\r\n        }\r\n        break;\r\n\r\n      case ktSSH1Public:\r\n      case ktSSH2PublicRFC4716:\r\n      case ktSSH2PublicOpenSSH:\r\n        throw Exception(LoadStr(KEYGEN_PUBLIC));\r\n\r\n      case ktUnopenable:\r\n        throw EOSExtException(FMTLOAD(KEY_TYPE_UNOPENABLE, (InputFileName)), Error);\r\n\r\n      case ktOpenSSHAuto:\r\n      default:\r\n        DebugFail();\r\n        // fallthru\r\n      case ktUnknown:\r\n        throw Exception(FMTLOAD(KEY_TYPE_UNKNOWN2, (InputFileName)));\r\n    }\r\n\r\n    UnicodeString Comment;\r\n    if (IsKeyEncrypted(Type, InputFileName, Comment))\r\n    {\r\n      Passphrase = Params->SwitchValue(PassphraseOption);\r\n      if (Passphrase.IsEmpty())\r\n      {\r\n        Console->Print(StripHotkey(FMTLOAD(PROMPT_KEY_PASSPHRASE, (Comment))) + L\" \");\r\n        if (!Console->Input(Passphrase, false, 0) ||\r\n            Passphrase.IsEmpty())\r\n        {\r\n          Abort();\r\n        }\r\n      }\r\n    }\r\n\r\n    TPrivateKey * PrivateKey = LoadKey(Type, InputFileName, Passphrase);\r\n\r\n    try\r\n    {\r\n      if (!NewComment.IsEmpty())\r\n      {\r\n        ChangeKeyComment(PrivateKey, NewComment);\r\n      }\r\n\r\n      if (ChangePassphrase)\r\n      {\r\n        if (!NewPassphraseSet)\r\n        {\r\n          Console->Print(LoadStr(KEYGEN_PASSPHRASE) + L\" \");\r\n          if (!Console->Input(NewPassphrase, false, 0))\r\n          {\r\n            Abort();\r\n          }\r\n\r\n          Console->Print(LoadStr(KEYGEN_PASSPHRASE2) + L\" \");\r\n          UnicodeString NewPassphrase2;\r\n          if (!Console->Input(NewPassphrase2, false, 0))\r\n          {\r\n            Abort();\r\n          }\r\n\r\n          if (NewPassphrase != NewPassphrase2)\r\n          {\r\n            Shred(NewPassphrase2);\r\n            throw Exception(LoadStr(KEYGEN_PASSPHRASES_MISMATCH));\r\n          }\r\n        }\r\n      }\r\n      else\r\n      {\r\n        NewPassphrase = Passphrase;\r\n      }\r\n\r\n      if (OutputFileName.IsEmpty())\r\n      {\r\n        OutputFileName = InputFileName;\r\n      }\r\n\r\n      SaveKey(ktSSH2, OutputFileName, NewPassphrase, PrivateKey);\r\n\r\n      Console->PrintLine(FMTLOAD(KEYGEN_SAVED, (OutputFileName)));\r\n    }\r\n    __finally\r\n    {\r\n      FreeKey(PrivateKey);\r\n    }\r\n  }\r\n  catch (Exception & E)\r\n  {\r\n    Result = HandleException(Console, E);\r\n  }\r\n\r\n  Shred(Passphrase);\r\n  Shred(NewPassphrase);\r\n\r\n  Console->WaitBeforeExit();\r\n  return Result;\r\n}\r\n//---------------------------------------------------------------------------\r\nint __fastcall FingerprintScan(TConsole * Console, TProgramParams * Params)\r\n{\r\n  int Result = RESULT_SUCCESS;\r\n  try\r\n  {\r\n    CheckLogParam(Params);\r\n\r\n    std::unique_ptr<TSessionData> SessionData;\r\n\r\n    if (Params->ParamCount > 0)\r\n    {\r\n      UnicodeString SessionUrl = Params->Param[1];\r\n      bool DefaultsOnly;\r\n      SessionData.reset(StoredSessions->ParseUrl(SessionUrl, Params, DefaultsOnly));\r\n      if (DefaultsOnly || !SessionData->CanLogin ||\r\n          (!SessionData->UsesSsh && (SessionData->Ftps == ftpsNone)))\r\n      {\r\n        SessionData.reset(NULL);\r\n      }\r\n    }\r\n\r\n    if (!SessionData)\r\n    {\r\n      throw Exception(LoadStr(FINGERPRINTSCAN_NEED_SECURE_SESSION));\r\n    }\r\n\r\n    std::unique_ptr<TTerminal> Terminal(new TTerminal(SessionData.get(), Configuration));\r\n    UnicodeString SHA256;\r\n    UnicodeString SHA1;\r\n    UnicodeString MD5;\r\n    Terminal->FingerprintScan(SHA256, SHA1, MD5);\r\n    if (!SHA256.IsEmpty())\r\n    {\r\n      Console->PrintLine(FORMAT(L\"SHA-256: %s\", (SHA256)));\r\n    }\r\n    if (!SHA1.IsEmpty())\r\n    {\r\n      Console->PrintLine(FORMAT(L\"SHA-1: %s\", (SHA1)));\r\n    }\r\n    if (!MD5.IsEmpty())\r\n    {\r\n      Console->PrintLine(FORMAT(L\"MD5:     %s\", (MD5)));\r\n    }\r\n  }\r\n  catch (Exception & E)\r\n  {\r\n    Result = HandleException(Console, E);\r\n  }\r\n\r\n  Console->WaitBeforeExit();\r\n  return Result;\r\n}\r\n//---------------------------------------------------------------------------\r\nint __fastcall DumpCallstack(TConsole * Console, TProgramParams * Params)\r\n{\r\n  int Result = RESULT_SUCCESS;\r\n  try\r\n  {\r\n    int ProcessId = StrToInt(Params->SwitchValue(DUMPCALLSTACK_SWITCH));\r\n    UnicodeString EventName = DumpCallstackEventName(ProcessId);\r\n    UnicodeString FileName = DumpCallstackFileName(ProcessId);\r\n    if (FileExists(FileName))\r\n    {\r\n      DeleteFileChecked(FileName);\r\n    }\r\n\r\n    HANDLE Event = OpenEvent(EVENT_ALL_ACCESS, false, EventName.c_str());\r\n    if (Event == NULL)\r\n    {\r\n      throw ExtException(FORMAT(L\"Error communicating with process %d.\", (ProcessId)), LastSysErrorMessage());\r\n    }\r\n\r\n    SetEvent(Event);\r\n    CloseHandle(Event);\r\n\r\n    Console->PrintLine(FORMAT(L\"Requested callstack dump for process %d...\", (ProcessId)));\r\n\r\n    int Timeout = 30;\r\n    while (!FileExists(FileName))\r\n    {\r\n      Sleep(1000);\r\n      Timeout--;\r\n      if (Timeout == 0)\r\n      {\r\n        throw Exception(L\"Timeout\");\r\n      }\r\n    }\r\n\r\n    Console->PrintLine(FORMAT(L\"Callstack dumped to file \\\"%s\\\".\", (FileName)));\r\n  }\r\n  catch (Exception & E)\r\n  {\r\n    Result = HandleException(Console, E);\r\n  }\r\n\r\n  Console->WaitBeforeExit();\r\n  return Result;\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid static PrintList(TConsole * Console, const UnicodeString & Caption, TStrings * List)\r\n{\r\n  Console->PrintLine(Caption);\r\n  for (int Index = 0; Index < List->Count; Index++)\r\n  {\r\n    Console->PrintLine(List->Strings[Index]);\r\n  }\r\n  Console->PrintLine();\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid static PrintListAndFree(TConsole * Console, const UnicodeString & Caption, TStrings * List)\r\n{\r\n  std::unique_ptr<TStrings> Owner(List);\r\n  PrintList(Console, Caption, List);\r\n}\r\n//---------------------------------------------------------------------------\r\nint Info(TConsole * Console)\r\n{\r\n  int Result = RESULT_SUCCESS;\r\n  try\r\n  {\r\n    PrintListAndFree(Console, L\"SSH encryption ciphers:\", SshCipherList());\r\n    PrintListAndFree(Console, L\"SSH key exchange algorithms:\", SshKexList());\r\n    PrintListAndFree(Console, L\"SSH host key algorithms:\", SshHostKeyList());\r\n    PrintListAndFree(Console, L\"SSH MAC algorithms:\", SshMacList());\r\n    PrintListAndFree(Console, L\"TLS/SSL cipher suites:\", TlsCipherList());\r\n  }\r\n  catch (Exception & E)\r\n  {\r\n    Result = HandleException(Console, E);\r\n  }\r\n\r\n  Console->WaitBeforeExit();\r\n  return Result;\r\n}\r\n//---------------------------------------------------------------------------\r\nint __fastcall Console(TConsoleMode Mode)\r\n{\r\n  DebugAssert(Mode != cmNone);\r\n  TProgramParams * Params = TProgramParams::Instance();\r\n  int Result = RESULT_SUCCESS;\r\n  TConsole * Console = NULL;\r\n  TConsoleRunner * Runner = NULL;\r\n  TStrings * ScriptCommands = new TStringList();\r\n  TStrings * ScriptParameters = new TStringList();\r\n  try\r\n  {\r\n    UnicodeString ConsoleInstance;\r\n    // First check for /consoleinstance as /console is always used by winscp.com\r\n    if (Params->FindSwitch(L\"consoleinstance\", ConsoleInstance))\r\n    {\r\n      Configuration->Usage->Inc(L\"ConsoleExternal\");\r\n      Console = new TExternalConsole(ConsoleInstance, Params->FindSwitch(L\"nointeractiveinput\"));\r\n    }\r\n    else if (Params->FindSwitch(L\"Console\") || (Mode != cmScripting))\r\n    {\r\n      Configuration->Usage->Inc(L\"ConsoleOwn\");\r\n      Console = TOwnConsole::Instance();\r\n    }\r\n    else\r\n    {\r\n      Configuration->Usage->Inc(L\"ConsoleNull\");\r\n      Console = new TNullConsole();\r\n    }\r\n\r\n    SetNoGUI();\r\n\r\n    if (Mode == cmHelp)\r\n    {\r\n      Configuration->Usage->Inc(L\"UsageShown\");\r\n      Usage(Console);\r\n    }\r\n    else if (Mode == cmBatchSettings)\r\n    {\r\n      if (CheckSafe(Params))\r\n      {\r\n        Configuration->Usage->Inc(L\"BatchSettings\");\r\n        Result = BatchSettings(Console, Params);\r\n      }\r\n    }\r\n    else if (Mode == cmKeyGen)\r\n    {\r\n      if (CheckSafe(Params))\r\n      {\r\n        Configuration->Usage->Inc(L\"KeyGen\");\r\n        Result = KeyGen(Console, Params);\r\n      }\r\n    }\r\n    else if (Mode == cmFingerprintScan)\r\n    {\r\n      if (CheckSafe(Params))\r\n      {\r\n        Configuration->Usage->Inc(L\"FingerprintScan\");\r\n        Result = FingerprintScan(Console, Params);\r\n      }\r\n    }\r\n    else if (Mode == cmDumpCallstack)\r\n    {\r\n      Result = DumpCallstack(Console, Params);\r\n    }\r\n    else if (Mode == cmInfo)\r\n    {\r\n      Result = Info(Console);\r\n    }\r\n    else if (Mode == cmComRegistration)\r\n    {\r\n      if (CheckSafe(Params))\r\n      {\r\n        Result = ComRegistration(Console);\r\n      }\r\n    }\r\n    else\r\n    {\r\n      Runner = new TConsoleRunner(Console);\r\n\r\n      try\r\n      {\r\n        if (CheckSafe(Params))\r\n        {\r\n          UnicodeString Value;\r\n          if (Params->FindSwitch(SCRIPT_SWITCH, Value) && !Value.IsEmpty())\r\n          {\r\n            Configuration->Usage->Inc(L\"ScriptFile\");\r\n            LoadScriptFromFile(Value, ScriptCommands);\r\n          }\r\n          Params->FindSwitch(COMMAND_SWITCH, ScriptCommands);\r\n          if (ScriptCommands->Count > 0)\r\n          {\r\n            Configuration->Usage->Inc(L\"ScriptCommands\");\r\n          }\r\n          Params->FindSwitch(L\"parameter\", ScriptParameters);\r\n          if (ScriptParameters->Count > 0)\r\n          {\r\n            Configuration->Usage->Inc(L\"ScriptParameters\");\r\n          }\r\n        }\r\n\r\n        UnicodeString Session;\r\n        if (Params->ParamCount >= 1)\r\n        {\r\n          Session = Params->Param[1];\r\n          if (Params->ParamCount > 1)\r\n          {\r\n            Runner->PrintMessage(LoadStr(SCRIPT_CMDLINE_PARAMETERS));\r\n          }\r\n        }\r\n\r\n        CheckLogParam(Params);\r\n        CheckXmlLogParam(Params);\r\n\r\n        Result = Runner->Run(Session, Params,\r\n          (ScriptCommands->Count > 0 ? ScriptCommands : NULL),\r\n          ScriptParameters);\r\n      }\r\n      catch(Exception & E)\r\n      {\r\n        Runner->ShowException(&E);\r\n        Result = RESULT_ANY_ERROR;\r\n      }\r\n    }\r\n  }\r\n  __finally\r\n  {\r\n    delete Runner;\r\n    delete Console;\r\n    delete ScriptCommands;\r\n    delete ScriptParameters;\r\n  }\r\n\r\n  return Result;\r\n}\r\n", "//---------------------------------------------------------------------------\r\n#include <vcl.h>\r\n#pragma hdrstop\r\n\r\n#include <CoreMain.h>\r\n\r\n#include <TextsWin.h>\r\n#include <TextsCore.h>\r\n#include <HelpWin.h>\r\n\r\n#include \"CustomScpExplorer.h\"\r\n#include \"TerminalManager.h\"\r\n#include \"NonVisual.h\"\r\n#include \"Glyphs.h\"\r\n#include \"ProgParams.h\"\r\n#include \"Setup.h\"\r\n#include \"WinConfiguration.h\"\r\n#include \"GUITools.h\"\r\n#include \"Tools.h\"\r\n#include \"WinApi.h\"\r\n#include <DateUtils.hpp>\r\n//---------------------------------------------------------------------------\r\n#pragma package(smart_init)\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall GetLoginData(UnicodeString SessionName, TOptions * Options,\r\n  TObjectList * DataList, UnicodeString & DownloadFile, bool NeedSession, TForm * LinkedForm, int Flags)\r\n{\r\n  bool DefaultsOnly = false;\r\n\r\n  UnicodeString FolderOrWorkspaceName = DecodeUrlChars(SessionName);\r\n  if (StoredSessions->IsFolder(FolderOrWorkspaceName) ||\r\n      StoredSessions->IsWorkspace(FolderOrWorkspaceName))\r\n  {\r\n    StoredSessions->GetFolderOrWorkspace(FolderOrWorkspaceName, DataList);\r\n  }\r\n  else\r\n  {\r\n    TSessionData * SessionData =\r\n      StoredSessions->ParseUrl(SessionName, Options, DefaultsOnly, &DownloadFile, NULL, NULL, Flags);\r\n    DataList->Add(SessionData);\r\n\r\n    if (DataList->Count == 1)\r\n    {\r\n      TSessionData * SessionData = DebugNotNull(dynamic_cast<TSessionData *>(DataList->Items[0]));\r\n      if (SessionData->SaveOnly)\r\n      {\r\n        Configuration->Usage->Inc(L\"CommandLineSessionSave\");\r\n        TSessionData * SavedSession = DoSaveSession(SessionData, NULL, true, NULL);\r\n        if (SavedSession == NULL)\r\n        {\r\n          Abort();\r\n        }\r\n        WinConfiguration->LastStoredSession = SavedSession->Name;\r\n        DataList->Clear();\r\n      }\r\n      else if (!SessionData->PuttyProtocol.IsEmpty())\r\n      {\r\n        // putty does not support resolving environment variables in session settings\r\n        // though it's hardly of any use here.\r\n        SessionData->ExpandEnvironmentVariables();\r\n        OpenSessionInPutty(GUIConfiguration->PuttyPath, SessionData);\r\n        DataList->Clear();\r\n        Abort();\r\n      }\r\n    }\r\n  }\r\n\r\n  if (DefaultsOnly && !NeedSession)\r\n  {\r\n    // No URL specified on command-line and no explicit command-line parameter\r\n    // that requires session was specified => noop\r\n    DataList->Clear();\r\n  }\r\n  else if ((DataList->Count == 0) ||\r\n      !dynamic_cast<TSessionData *>(DataList->Items[0])->CanLogin ||\r\n      DefaultsOnly)\r\n  {\r\n    // Note that GetFolderOrWorkspace never returns sites that !CanLogin,\r\n    // so we should not get here with more then one site.\r\n    // Though we should be good, if we ever do.\r\n\r\n    // We get here when:\r\n    // - we need session for explicit command-line operation\r\n    // - after we handle \"save\" URL.\r\n    // - the specified session does not contain enough information to login [= not even hostname]\r\n\r\n    DebugAssert(DataList->Count <= 1);\r\n    if (!DoLoginDialog(DataList, LinkedForm))\r\n    {\r\n      Abort();\r\n    }\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall Upload(TTerminal * Terminal, TStrings * FileList, int UseDefaults)\r\n{\r\n  UnicodeString TargetDirectory;\r\n  TGUICopyParamType CopyParam = GUIConfiguration->DefaultCopyParam;\r\n\r\n  TargetDirectory = UnixIncludeTrailingBackslash(Terminal->CurrentDirectory);\r\n\r\n  std::unique_ptr<TSessionData> Data(Terminal->SessionData->Clone());\r\n  Terminal->FillSessionDataForCode(Data.get());\r\n\r\n  int Options = coDisableQueue;\r\n  int CopyParamAttrs = Terminal->UsableCopyParamAttrs(0).Upload;\r\n  if ((UseDefaults == 0) ||\r\n      DoCopyDialog(true, false, FileList, TargetDirectory, &CopyParam, Options,\r\n        CopyParamAttrs, Data.get(), NULL, UseDefaults))\r\n  {\r\n    // Setting parameter overrides only now, otherwise the dialog would present the parametes as non-default\r\n    CopyParam.OnceDoneOperation = odoDisconnect;\r\n\r\n    Terminal->CopyToRemote(FileList, TargetDirectory, &CopyParam, 0, NULL);\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall Download(TTerminal * Terminal, const UnicodeString FileName, int UseDefaults)\r\n{\r\n  TRemoteFile * File = NULL;\r\n\r\n  try\r\n  {\r\n    Terminal->ExceptionOnFail = true;\r\n    try\r\n    {\r\n      Terminal->ReadFile(FileName, File);\r\n    }\r\n    __finally\r\n    {\r\n      Terminal->ExceptionOnFail = false;\r\n    }\r\n    File->FullFileName = FileName;\r\n    UnicodeString LocalDirectory = Terminal->SessionData->LocalDirectoryExpanded;\r\n    if (LocalDirectory.IsEmpty())\r\n    {\r\n      LocalDirectory = GetPersonalFolder();\r\n    }\r\n    UnicodeString TargetDirectory = IncludeTrailingBackslash(LocalDirectory);\r\n\r\n    TGUICopyParamType CopyParam = GUIConfiguration->DefaultCopyParam;\r\n    UnicodeString DisplayName = File->FileName;\r\n\r\n    bool CustomDisplayName =\r\n      !File->DisplayName.IsEmpty() &&\r\n      (File->DisplayName != DisplayName);\r\n    if (CustomDisplayName)\r\n    {\r\n      DisplayName = File->DisplayName;\r\n    }\r\n\r\n    UnicodeString FriendyFileName = UnixIncludeTrailingBackslash(UnixExtractFilePath(FileName)) + DisplayName;\r\n    std::unique_ptr<TStrings> FileListFriendly(new TStringList());\r\n    FileListFriendly->AddObject(FriendyFileName, File);\r\n\r\n    int Options = coDisableQueue;\r\n    int CopyParamAttrs = Terminal->UsableCopyParamAttrs(0).Download;\r\n    if ((UseDefaults == 0) ||\r\n        DoCopyDialog(false, false, FileListFriendly.get(), TargetDirectory, &CopyParam,\r\n          Options, CopyParamAttrs, NULL, NULL, UseDefaults))\r\n    {\r\n      // Setting parameter overrides only now, otherwise the dialog would present the parametes as non-default\r\n\r\n      if (CustomDisplayName)\r\n      {\r\n        // Set only now, so that it is not redundantly displayed on the copy dialog.\r\n        // We should escape the * and ?'s.\r\n        CopyParam.FileMask = DisplayName;\r\n      }\r\n\r\n      CopyParam.OnceDoneOperation = odoDisconnect;\r\n\r\n      std::unique_ptr<TStrings> FileList(new TStringList());\r\n      FileList->AddObject(FileName, File);\r\n      Terminal->CopyToLocal(FileList.get(), TargetDirectory, &CopyParam, 0, NULL);\r\n    }\r\n\r\n    UnicodeString Directory = UnixExtractFilePath(FileName);\r\n    Terminal->AutoReadDirectory = true;\r\n    Terminal->ChangeDirectory(Directory);\r\n  }\r\n  __finally\r\n  {\r\n    delete File;\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall Edit(TCustomScpExplorerForm * ScpExplorer, TStrings * FileList)\r\n{\r\n  ScpExplorer->StandaloneEdit(FileList->Strings[0]);\r\n  Abort();\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall SynchronizeDirectories(TTerminal * Terminal,\r\n  TStrings * CommandParams,\r\n  UnicodeString & LocalDirectory, UnicodeString & RemoteDirectory)\r\n{\r\n  if (CommandParams->Count >= 1)\r\n  {\r\n    LocalDirectory = CommandParams->Strings[0];\r\n  }\r\n  else if (!Terminal->SessionData->LocalDirectory.IsEmpty())\r\n  {\r\n    LocalDirectory = Terminal->SessionData->LocalDirectoryExpanded;\r\n  }\r\n  else\r\n  {\r\n    LocalDirectory = WinConfiguration->ScpExplorer.LastLocalTargetDirectory;\r\n  }\r\n\r\n  if (CommandParams->Count >= 2)\r\n  {\r\n    RemoteDirectory = CommandParams->Strings[1];\r\n  }\r\n  else\r\n  {\r\n    RemoteDirectory = Terminal->CurrentDirectory;\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall FullSynchronize(\r\n  TTerminal * Terminal, TCustomScpExplorerForm * ScpExplorer, TStrings * CommandParams, int UseDefaults)\r\n{\r\n  UnicodeString LocalDirectory;\r\n  UnicodeString RemoteDirectory;\r\n\r\n  SynchronizeDirectories(Terminal, CommandParams, LocalDirectory, RemoteDirectory);\r\n\r\n  bool SaveMode = true;\r\n  // bit ugly\r\n  TSynchronizeMode Mode = (TSynchronizeMode)GUIConfiguration->SynchronizeMode;\r\n  int Params = GUIConfiguration->SynchronizeParams;\r\n\r\n  // Undocumented syntax for \"Start in New Window\"\r\n  if (CommandParams->Count >= 4)\r\n  {\r\n    Mode = (TSynchronizeMode)StrToIntDef(CommandParams->Strings[2], Mode);\r\n    Params = StrToIntDef(CommandParams->Strings[3], Params);\r\n  }\r\n\r\n  int Result =\r\n    ScpExplorer->DoFullSynchronizeDirectories(LocalDirectory, RemoteDirectory, Mode, Params, SaveMode, UseDefaults);\r\n  if ((Result >= 0) && SaveMode)\r\n  {\r\n    GUIConfiguration->SynchronizeMode = Mode;\r\n  }\r\n\r\n  Abort();\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall Synchronize(\r\n  TTerminal * Terminal, TCustomScpExplorerForm * ScpExplorer, TStrings * CommandParams, int UseDefaults)\r\n{\r\n  UnicodeString LocalDirectory;\r\n  UnicodeString RemoteDirectory;\r\n\r\n  SynchronizeDirectories(Terminal, CommandParams, LocalDirectory, RemoteDirectory);\r\n\r\n  // Undocumented syntax for \"Start in New Window\"\r\n  if (CommandParams->Count >= 4)\r\n  {\r\n    GUIConfiguration->SynchronizeParams = StrToIntDef(CommandParams->Strings[2], -1);\r\n    GUIConfiguration->SynchronizeOptions = StrToIntDef(CommandParams->Strings[3], -1);\r\n\r\n    Configuration->DontSave();\r\n  }\r\n\r\n  ScpExplorer->DoSynchronizeDirectories(LocalDirectory, RemoteDirectory, UseDefaults);\r\n  Abort();\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall ImportSitesIfAny()\r\n{\r\n  if (!WinConfiguration->AutoImportedFromPuttyOrFilezilla)\r\n  {\r\n    bool AnyPuttySession = GUIConfiguration->AnyPuttySessionForImport(StoredSessions);\r\n    bool AnyFilezillaSession = GUIConfiguration->AnyFilezillaSessionForImport(StoredSessions);\r\n\r\n    if (AnyPuttySession || AnyFilezillaSession)\r\n    {\r\n      UnicodeString PuttySource = LoadStrPart(IMPORT_SESSIONS2, 2);\r\n      UnicodeString FilezillaSource = LoadStrPart(IMPORT_SESSIONS2, 3);\r\n      UnicodeString Source;\r\n      if (AnyPuttySession && AnyFilezillaSession)\r\n      {\r\n        Source = FORMAT(LoadStrPart(IMPORT_SESSIONS2, 4), (PuttySource, FilezillaSource));\r\n      }\r\n      else if (AnyPuttySession)\r\n      {\r\n        Source = PuttySource;\r\n      }\r\n      else if (AnyFilezillaSession)\r\n      {\r\n        Source = FilezillaSource;\r\n      }\r\n      else\r\n      {\r\n        DebugFail();\r\n      }\r\n\r\n      UnicodeString Message = FORMAT(LoadStrPart(IMPORT_SESSIONS2, 1), (Source));\r\n\r\n      if (MessageDialog(Message, qtConfirmation,\r\n            qaYes | qaNo, HELP_IMPORT_SESSIONS) == qaYes)\r\n      {\r\n        DoImportSessionsDialog(NULL);\r\n      }\r\n\r\n      WinConfiguration->AutoImportedFromPuttyOrFilezilla = true;\r\n    }\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall Usage(UnicodeString Param)\r\n{\r\n  while (!Param.IsEmpty())\r\n  {\r\n    UnicodeString Pair = CutToChar(Param, L',', true);\r\n    if (!Pair.IsEmpty())\r\n    {\r\n      if (Pair[Pair.Length()] == L'+')\r\n      {\r\n        UnicodeString Key = Pair.SubString(1, Pair.Length() - 1).Trim();\r\n        Configuration->Usage->Inc(Key);\r\n      }\r\n      else\r\n      {\r\n        UnicodeString Key = CutToChar(Pair, L':', true);\r\n        Configuration->Usage->Set(Key, Pair.Trim());\r\n      }\r\n    }\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall RecordWrapperVersions(UnicodeString ConsoleVersion, UnicodeString DotNetVersion)\r\n{\r\n  TUpdatesConfiguration Updates = WinConfiguration->Updates;\r\n  if (!DotNetVersion.IsEmpty())\r\n  {\r\n    Updates.DotNetVersion = DotNetVersion;\r\n  }\r\n  if (!ConsoleVersion.IsEmpty())\r\n  {\r\n    Updates.ConsoleVersion = ConsoleVersion;\r\n  }\r\n  WinConfiguration->Updates = Updates;\r\n\r\n  if (Configuration->Storage == stNul)\r\n  {\r\n    Configuration->SetDefaultStorage();\r\n    try\r\n    {\r\n      THierarchicalStorage * Storage = Configuration->CreateConfigStorage();\r\n      try\r\n      {\r\n        Storage->AccessMode = smReadWrite;\r\n        if (Storage->OpenSubKey(Configuration->ConfigurationSubKey, true) &&\r\n            Storage->OpenSubKeyPath(L\"Interface\\\\Updates\", true))\r\n        {\r\n          if (!DotNetVersion.IsEmpty())\r\n          {\r\n            Storage->WriteString(L\"DotNetVersion\", DotNetVersion);\r\n          }\r\n          if (!ConsoleVersion.IsEmpty())\r\n          {\r\n            Storage->WriteString(L\"ConsoleVersion\", ConsoleVersion);\r\n          }\r\n        }\r\n      }\r\n      __finally\r\n      {\r\n        delete Storage;\r\n      }\r\n    }\r\n    __finally\r\n    {\r\n      Configuration->SetNulStorage();\r\n    }\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\nstatic UnicodeString ColorToRGBStr(TColor Color)\r\n{\r\n  int RGB = ColorToRGB(Color);\r\n  int R = GetRValue(RGB);\r\n  int G = GetGValue(RGB);\r\n  int B = GetBValue(RGB);\r\n  UnicodeString Result = FORMAT(L\"%.2x%.2x%.2x\", (R, G, B));\r\n  return Result;\r\n}\r\n//---------------------------------------------------------------------------\r\nTDateTime Started(Now());\r\nint LifetimeRuns = -1;\r\n//---------------------------------------------------------------------------\r\nvoid InterfaceStarted()\r\n{\r\n  // deliberate downcast\r\n  int StartupSeconds = static_cast<int>(SecondsBetween(Now(), Started));\r\n  if (LifetimeRuns > 0)\r\n  {\r\n    if (LifetimeRuns == 1)\r\n    {\r\n      Configuration->Usage->Set(L\"StartupSeconds1\", StartupSeconds);\r\n    }\r\n    else if (LifetimeRuns == 2)\r\n    {\r\n      Configuration->Usage->Set(L\"StartupSeconds2\", StartupSeconds);\r\n    }\r\n    Configuration->Usage->Set(L\"StartupSecondsLast\", StartupSeconds);\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall UpdateStaticUsage()\r\n{\r\n  LifetimeRuns = Configuration->Usage->Inc(L\"Runs\");\r\n\r\n  Configuration->Usage->UpdateCurrentVersion();\r\n\r\n  Configuration->Usage->Set(L\"WindowsVersion\", (WindowsVersionLong()));\r\n  Configuration->Usage->Set(L\"WindowsProductName\", (WindowsProductName()));\r\n  DWORD Type;\r\n  GetWindowsProductType(Type);\r\n  Configuration->Usage->Set(L\"WindowsProductType\", (static_cast<int>(Type)));\r\n  Configuration->Usage->Set(L\"Windows64\", IsWin64());\r\n  Configuration->Usage->Set(L\"UWP\", IsUWP());\r\n  Configuration->Usage->Set(L\"DefaultLocale\",\r\n    // See TGUIConfiguration::GetAppliedLocaleHex()\r\n    IntToHex(static_cast<int>(GetDefaultLCID()), 4));\r\n  Configuration->Usage->Set(L\"Locale\", WinConfiguration->AppliedLocaleHex);\r\n  Configuration->Usage->Set(L\"EncodingMultiByteAnsi\", !TEncoding::Default->IsSingleByte);\r\n  Configuration->Usage->Set(L\"PixelsPerInch\", Screen->PixelsPerInch);\r\n\r\n  bool PixelsPerInchSystemDiffers = false;\r\n  bool PixelsPerInchMonitorsDiffer = false;\r\n  bool PixelsPerInchAxesDiffer = false;\r\n\r\n  HINSTANCE ShCoreLibrary = LoadLibrary(L\"shcore.dll\");\r\n  if (ShCoreLibrary != NULL)\r\n  {\r\n    GetDpiForMonitorProc GetDpiForMonitor =\r\n      (GetDpiForMonitorProc)GetProcAddress(ShCoreLibrary, \"GetDpiForMonitor\");\r\n\r\n    if (GetDpiForMonitor != NULL)\r\n    {\r\n      unsigned int PrimaryDpiX;\r\n      unsigned int PrimaryDpiY;\r\n\r\n      for (int Index = 0; Index < Screen->MonitorCount; Index++)\r\n      {\r\n        unsigned int DpiX;\r\n        unsigned int DpiY;\r\n        GetDpiForMonitor(Screen->Monitors[Index]->Handle, MDT_Default, &DpiX, &DpiY);\r\n\r\n        if (DpiX != DpiY)\r\n        {\r\n          PixelsPerInchAxesDiffer = true;\r\n        }\r\n\r\n        if (Index == 0)\r\n        {\r\n          PrimaryDpiX = DpiX;\r\n          PrimaryDpiY = DpiY;\r\n\r\n          // PixelsPerInch is GetDeviceCaps(DC, LOGPIXELSY)\r\n          if (DpiY != (unsigned int)Screen->PixelsPerInch)\r\n          {\r\n            PixelsPerInchSystemDiffers = true;\r\n          }\r\n        }\r\n        else\r\n        {\r\n          if ((DpiX != PrimaryDpiX) ||\r\n              (DpiY != PrimaryDpiY))\r\n          {\r\n            PixelsPerInchMonitorsDiffer = true;\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  if (PixelsPerInchSystemDiffers)\r\n  {\r\n    Configuration->Usage->Inc(L\"PixelsPerInchSystemDiffered\");\r\n  }\r\n  Configuration->Usage->Set(L\"PixelsPerInchMonitorsDiffer\", PixelsPerInchMonitorsDiffer);\r\n  Configuration->Usage->Set(L\"PixelsPerInchAxesDiffer\", PixelsPerInchAxesDiffer);\r\n\r\n  Configuration->Usage->Set(L\"WorkAreaWidth\", Screen->WorkAreaWidth);\r\n  Configuration->Usage->Set(L\"WorkAreaHeight\", Screen->WorkAreaHeight);\r\n  HDC DC = GetDC(NULL);\r\n  int Planes = GetDeviceCaps(DC, PLANES);\r\n  int BitsPixel = GetDeviceCaps(DC, BITSPIXEL);\r\n  Configuration->Usage->Set(L\"ColorDepth\", Planes * BitsPixel);\r\n  Configuration->Usage->Set(L\"MonitorCount\", Screen->MonitorCount);\r\n  Configuration->Usage->Set(L\"NotUseThemes\", !UseThemes());\r\n  Configuration->Usage->Set(L\"ThemeDefaultFontSize\", Application->DefaultFont->Size);\r\n  Configuration->Usage->Set(L\"ThemeIconFontSize\", Screen->IconFont->Size);\r\n\r\n  Configuration->Usage->Set(L\"SysColorWindow\", ColorToRGBStr(clWindow));\r\n  Configuration->Usage->Set(L\"SysColorBtnFace\", ColorToRGBStr(clBtnFace));\r\n  Configuration->Usage->Set(L\"SysColorWindowText\", ColorToRGBStr(clWindowText));\r\n\r\n  UnicodeString ProgramsFolder;\r\n  ::SpecialFolderLocation(CSIDL_PROGRAM_FILES, ProgramsFolder);\r\n  ProgramsFolder = IncludeTrailingBackslash(ExpandFileName(ProgramsFolder));\r\n  UnicodeString ExeName = ExpandFileName(Application->ExeName);\r\n  bool InProgramFiles = AnsiSameText(ExeName.SubString(1, ProgramsFolder.Length()), ProgramsFolder);\r\n  Configuration->Usage->Set(L\"InProgramFiles\", InProgramFiles);\r\n  Configuration->Usage->Set(L\"IsInstalled\", IsInstalled());\r\n  Configuration->Usage->Set(L\"Wine\", IsWine());\r\n  Configuration->Usage->Set(L\"NetFrameworkVersion\", GetNetVersionStr());\r\n  Configuration->Usage->Set(L\"PowerShellVersion\", GetPowerShellVersionStr());\r\n\r\n  WinConfiguration->UpdateStaticUsage();\r\n\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall MaintenanceTask()\r\n{\r\n  CoreMaintenanceTask();\r\n}\r\n//---------------------------------------------------------------------------\r\ntypedef std::vector<HWND> THandles;\r\ntypedef std::map<unsigned long, THandles> TProcesses;\r\n//---------------------------------------------------------------------------\r\nBOOL __stdcall EnumOtherInstances(HWND Handle, LPARAM AParam)\r\n{\r\n  TProcesses & Processes = *reinterpret_cast<TProcesses *>(AParam);\r\n\r\n  unsigned long ProcessId;\r\n  if (GetWindowThreadProcessId(Handle, &ProcessId) != 0)\r\n  {\r\n    Processes[ProcessId].push_back(Handle);\r\n  }\r\n\r\n  return TRUE;\r\n}\r\n//---------------------------------------------------------------------------\r\nstatic bool __fastcall SendCopyDataMessage(HWND Window, TCopyDataMessage & Message)\r\n{\r\n  COPYDATASTRUCT CopyData;\r\n  CopyData.cbData = sizeof(Message);\r\n  CopyData.lpData = &Message;\r\n\r\n  LRESULT SendResult =\r\n    SendMessage(Window, WM_COPYDATA,\r\n       reinterpret_cast<WPARAM>(HInstance), reinterpret_cast<LPARAM>(&CopyData));\r\n  bool Result = (SendResult > 0);\r\n  return Result;\r\n}\r\n//---------------------------------------------------------------------------\r\nstatic void __fastcall FindOtherInstances(THandles & OtherInstances)\r\n{\r\n  TProcesses Processes;\r\n\r\n  // FindWindow is optimization (if there's no hidden window, no point enumerating all windows to find some)\r\n  if ((FindWindow(HIDDEN_WINDOW_NAME, NULL) != NULL) &&\r\n      EnumWindows(EnumOtherInstances, reinterpret_cast<LPARAM>(&Processes)))\r\n  {\r\n    TCopyDataMessage Message;\r\n\r\n    Message.Command = TCopyDataMessage::MainWindowCheck;\r\n\r\n    TProcesses::const_iterator ProcessI = Processes.begin();\r\n    while (ProcessI != Processes.end())\r\n    {\r\n      HWND HiddenWindow = NULL;\r\n      THandles::const_iterator WindowI = ProcessI->second.begin();\r\n\r\n      while ((HiddenWindow == NULL) && (WindowI != ProcessI->second.end()))\r\n      {\r\n        wchar_t ClassName[1024];\r\n        if (GetClassName(*WindowI, ClassName, LENOF(ClassName)) != 0)\r\n        {\r\n          NULL_TERMINATE(ClassName);\r\n\r\n          if (wcscmp(ClassName, HIDDEN_WINDOW_NAME) == 0)\r\n          {\r\n            HiddenWindow = *WindowI;\r\n          }\r\n        }\r\n        WindowI++;\r\n      }\r\n\r\n      if (HiddenWindow != NULL)\r\n      {\r\n        WindowI = ProcessI->second.begin();\r\n\r\n        while (WindowI != ProcessI->second.end())\r\n        {\r\n          if (*WindowI != HiddenWindow) // optimization\r\n          {\r\n            if (SendCopyDataMessage(*WindowI, Message))\r\n            {\r\n              OtherInstances.push_back(*WindowI);\r\n              break;\r\n            }\r\n          }\r\n          WindowI++;\r\n        }\r\n      }\r\n\r\n      ProcessI++;\r\n    }\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\nbool __fastcall SendToAnotherInstance()\r\n{\r\n  THandles OtherInstances;\r\n  FindOtherInstances(OtherInstances);\r\n\r\n  bool Result = false;\r\n  THandles::const_iterator I = OtherInstances.begin();\r\n  while (!Result && (I != OtherInstances.end()))\r\n  {\r\n    HWND Handle = *I;\r\n\r\n    TCopyDataMessage Message;\r\n    Message.Command = TCopyDataMessage::CommandCanCommandLine;\r\n\r\n    if (SendCopyDataMessage(Handle, Message))\r\n    {\r\n      // Restore window, if minimized\r\n      ShowWindow(Handle, SW_RESTORE);\r\n      // bring it to foreground\r\n      SetForegroundWindow(Handle);\r\n\r\n      Message.Command = TCopyDataMessage::CommandCommandLine;\r\n      wcsncpy(Message.CommandLine, CmdLine, LENOF(Message.CommandLine));\r\n      NULL_TERMINATE(Message.CommandLine);\r\n\r\n      Result = SendCopyDataMessage(Handle, Message);\r\n    }\r\n\r\n    I++;\r\n  }\r\n\r\n  return Result;\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid __fastcall Refresh(const UnicodeString & Session, const UnicodeString & Path)\r\n{\r\n  THandles OtherInstances;\r\n  FindOtherInstances(OtherInstances);\r\n\r\n  THandles::const_iterator I = OtherInstances.begin();\r\n  while (I != OtherInstances.end())\r\n  {\r\n    HWND Handle = *I;\r\n\r\n    TCopyDataMessage Message;\r\n    Message.Command = TCopyDataMessage::RefreshPanel;\r\n    wcsncpy(Message.Refresh.Session, Session.c_str(), LENOF(Message.Refresh.Session));\r\n    NULL_TERMINATE(Message.Refresh.Session);\r\n    wcsncpy(Message.Refresh.Path, Path.c_str(), LENOF(Message.Refresh.Path));\r\n    NULL_TERMINATE(Message.Refresh.Path);\r\n\r\n    SendCopyDataMessage(Handle, Message);\r\n\r\n    I++;\r\n  }\r\n}\r\n//---------------------------------------------------------------------------\r\nbool __fastcall ShowUpdatesIfAvailable()\r\n{\r\n  TUpdatesConfiguration Updates = WinConfiguration->Updates;\r\n  int CurrentCompoundVer = Configuration->CompoundVersion;\r\n  bool NoPopup = true;\r\n  bool Result =\r\n    !IsUWP() &&\r\n    Updates.ShowOnStartup &&\r\n    Updates.HaveValidResultsForVersion(CurrentCompoundVer) &&\r\n    !Updates.Results.Disabled &&\r\n    ((Updates.Results.Version > CurrentCompoundVer) || !Updates.Results.Message.IsEmpty()) &&\r\n    !Updates.ShownResults;\r\n  if (Result)\r\n  {\r\n    Configuration->Usage->Inc(L\"UpdateStartup\");\r\n    Result = CheckForUpdates(true);\r\n    if (Result)\r\n    {\r\n      Configuration->Usage->Inc(L\"UpdateDownloadOpensStartup\");\r\n    }\r\n    NoPopup = false;\r\n  }\r\n  else if (WinConfiguration->ShowTips)\r\n  {\r\n    int Days = DaysBetween(WinConfiguration->TipsShown, Now());\r\n    if ((Days >= Updates.Results.TipsIntervalDays) &&\r\n        (WinConfiguration->RunsSinceLastTip >= Updates.Results.TipsIntervalDays))\r\n    {\r\n      UnicodeString Tip = FirstUnshownTip();\r\n      if (!Tip.IsEmpty())\r\n      {\r\n        AutoShowNewTip();\r\n        NoPopup = false;\r\n      }\r\n      else\r\n      {\r\n        Configuration->Usage->Inc(L\"TipsNoUnseen\");\r\n      }\r\n    }\r\n  }\r\n\r\n  if (NoPopup)\r\n  {\r\n    WinConfiguration->RunsSinceLastTip = WinConfiguration->RunsSinceLastTip + 1;\r\n  }\r\n  return Result;\r\n}\r\n//---------------------------------------------------------------------------\r\nint __fastcall Execute()\r\n{\r\n  DebugAssert(StoredSessions);\r\n  TProgramParams * Params = TProgramParams::Instance();\r\n  DebugAssert(Params);\r\n\r\n  // do not flash message boxes on startup\r\n  SetOnForeground(true);\r\n\r\n  // let installer know, that some instance of application is running\r\n  CreateMutex(NULL, False, AppName.c_str());\r\n  bool OnlyInstance = (GetLastError() == 0);\r\n\r\n  UpdateStaticUsage();\r\n\r\n  UnicodeString KeyFile;\r\n  if (Params->FindSwitch(L\"PrivateKey\", KeyFile))\r\n  {\r\n    WinConfiguration->DefaultKeyFile = KeyFile;\r\n  }\r\n\r\n  UnicodeString ConsoleVersion;\r\n  UnicodeString DotNetVersion;\r\n  Params->FindSwitch(L\"Console\", ConsoleVersion);\r\n  Params->FindSwitch(L\"DotNet\", DotNetVersion);\r\n  if (!ConsoleVersion.IsEmpty() || !DotNetVersion.IsEmpty())\r\n  {\r\n    RecordWrapperVersions(ConsoleVersion, DotNetVersion);\r\n  }\r\n  if (!DotNetVersion.IsEmpty())\r\n  {\r\n    Configuration->Usage->Inc(L\"ConsoleDotNet\");\r\n  }\r\n\r\n  UnicodeString SwitchValue;\r\n  if (Params->FindSwitch(L\"loglevel\", SwitchValue))\r\n  {\r\n    int StarPos = SwitchValue.Pos(L\"*\");\r\n    if (StarPos > 0)\r\n    {\r\n      bool LogSensitive = true;\r\n      SwitchValue.Delete(StarPos, 1);\r\n\r\n      if ((StarPos <= SwitchValue.Length()) &&\r\n          (SwitchValue[StarPos] == L'-'))\r\n      {\r\n        LogSensitive = false;\r\n        SwitchValue.Delete(StarPos, 1);\r\n      }\r\n\r\n      SwitchValue = SwitchValue.Trim();\r\n\r\n      Configuration->TemporaryLogSensitive(LogSensitive);\r\n    }\r\n    int LogProtocol;\r\n    if (!SwitchValue.IsEmpty() && TryStrToInt(SwitchValue, LogProtocol) && (LogProtocol >= -1))\r\n    {\r\n      Configuration->TemporaryLogProtocol(LogProtocol);\r\n    }\r\n  }\r\n\r\n  if (Params->FindSwitch(LOGSIZE_SWITCH, SwitchValue))\r\n  {\r\n    int StarPos = SwitchValue.Pos(LOGSIZE_SEPARATOR);\r\n    int LogMaxCount = 0;\r\n    if (StarPos > 1)\r\n    {\r\n      if (!TryStrToInt(SwitchValue.SubString(1, StarPos - 1), LogMaxCount))\r\n      {\r\n        LogMaxCount = -1;\r\n      }\r\n      SwitchValue.Delete(1, StarPos);\r\n      SwitchValue = SwitchValue.Trim();\r\n    }\r\n\r\n    __int64 LogMaxSize;\r\n    if ((LogMaxCount >= 0) &&\r\n        !SwitchValue.IsEmpty() &&\r\n        TryStrToSize(SwitchValue, LogMaxSize))\r\n    {\r\n      Configuration->TemporaryLogMaxCount(LogMaxCount);\r\n      Configuration->TemporaryLogMaxSize(LogMaxSize);\r\n    }\r\n  }\r\n\r\n  std::unique_ptr<TStrings> RawSettings(new TStringList());\r\n  if (Params->FindSwitch(RAWTRANSFERSETTINGS_SWITCH, RawSettings.get()))\r\n  {\r\n    std::unique_ptr<TOptionsStorage> OptionsStorage(new TOptionsStorage(RawSettings.get(), false));\r\n    GUIConfiguration->LoadDefaultCopyParam(OptionsStorage.get());\r\n  }\r\n\r\n  TConsoleMode Mode = cmNone;\r\n  if (Params->FindSwitch(L\"help\") || Params->FindSwitch(L\"h\") || Params->FindSwitch(L\"?\"))\r\n  {\r\n    Mode = cmHelp;\r\n  }\r\n  else if (Params->FindSwitch(L\"batchsettings\"))\r\n  {\r\n    Mode = cmBatchSettings;\r\n  }\r\n  else if (Params->FindSwitch(KEYGEN_SWITCH))\r\n  {\r\n    Mode = cmKeyGen;\r\n  }\r\n  else if (Params->FindSwitch(FINGERPRINTSCAN_SWITCH))\r\n  {\r\n    Mode = cmFingerprintScan;\r\n  }\r\n  else if (Params->FindSwitch(DUMPCALLSTACK_SWITCH))\r\n  {\r\n    Mode = cmDumpCallstack;\r\n  }\r\n  else if (Params->FindSwitch(INFO_SWITCH))\r\n  {\r\n    Mode = cmInfo;\r\n  }\r\n  else if (Params->FindSwitch(COMREGISTRATION_SWITCH))\r\n  {\r\n    Mode = cmComRegistration;\r\n  }\r\n  // We have to check for /console only after the other options,\r\n  // as the /console is always used when we are run by winscp.com\r\n  // (ambiguous use to pass console version)\r\n  else if (Params->FindSwitch(L\"Console\") || Params->FindSwitch(SCRIPT_SWITCH) ||\r\n      Params->FindSwitch(COMMAND_SWITCH))\r\n  {\r\n    Mode = cmScripting;\r\n  }\r\n\r\n  if (Mode != cmNone)\r\n  {\r\n    return Console(Mode);\r\n  }\r\n\r\n  TTerminalManager * TerminalManager = NULL;\r\n  GlyphsModule = NULL;\r\n  NonVisualDataModule = NULL;\r\n  TStrings * CommandParams = new TStringList;\r\n  try\r\n  {\r\n    TerminalManager = TTerminalManager::Instance();\r\n    HANDLE ResourceModule = GUIConfiguration->ChangeToDefaultResourceModule();\r\n    try\r\n    {\r\n      GlyphsModule = new TGlyphsModule(Application);\r\n    }\r\n    __finally\r\n    {\r\n      GUIConfiguration->ChangeResourceModule(ResourceModule);\r\n    }\r\n    NonVisualDataModule = new TNonVisualDataModule(Application);\r\n\r\n    // The default is 2.5s.\r\n    // 20s is used by Office 2010 and Windows 10 Explorer.\r\n    // Some applications use an infinite (Thunderbird, Firefox).\r\n    // Overriden for some controls using THintInfo.HideTimeout\r\n    Application->HintHidePause = 20000;\r\n    HintWindowClass = __classid(TScreenTipHintWindow);\r\n\r\n    UnicodeString IniFileName = Params->SwitchValue(INI_SWITCH);\r\n    if (!IniFileName.IsEmpty() && (IniFileName != INI_NUL))\r\n    {\r\n      UnicodeString IniFileNameExpanded = ExpandEnvironmentVariables(IniFileName);\r\n      if (!FileExists(ApiPath(IniFileNameExpanded)))\r\n      {\r\n        // this should be displayed rather at the very beginning.\r\n        // however for simplicity (GUI-only), we do it only here.\r\n        MessageDialog(FMTLOAD(FILE_NOT_EXISTS, (IniFileNameExpanded)), qtError, qaOK);\r\n      }\r\n    }\r\n\r\n    if (Params->FindSwitch(L\"UninstallCleanup\"))\r\n    {\r\n      MaintenanceTask();\r\n      Configuration->DontSave();\r\n      // The innosetup cannot skip UninstallCleanup run task for silent uninstalls,\r\n      // workaround is that we create mutex in uninstaller, if it runs silent, and\r\n      // ignore the UninstallCleanup, when the mutex exists.\r\n      if (OpenMutex(SYNCHRONIZE, false, L\"WinSCPSilentUninstall\") == NULL)\r\n      {\r\n        DoCleanupDialogIfAnyDataAndWanted();\r\n      }\r\n    }\r\n    else if (Params->FindSwitch(L\"RegisterForDefaultProtocols\") ||\r\n             Params->FindSwitch(L\"RegisterAsUrlHandler\")) // BACKWARD COMPATIBILITY\r\n    {\r\n      MaintenanceTask();\r\n      if (CheckSafe(Params))\r\n      {\r\n        RegisterForDefaultProtocols();\r\n        Configuration->DontSave();\r\n      }\r\n    }\r\n    else if (Params->FindSwitch(L\"UnregisterForProtocols\"))\r\n    {\r\n      MaintenanceTask();\r\n      if (CheckSafe(Params))\r\n      {\r\n        UnregisterForProtocols();\r\n        Configuration->DontSave();\r\n      }\r\n    }\r\n    else if (Params->FindSwitch(L\"AddSearchPath\"))\r\n    {\r\n      MaintenanceTask();\r\n      if (CheckSafe(Params))\r\n      {\r\n        AddSearchPath(ExtractFilePath(Application->ExeName));\r\n        Configuration->DontSave();\r\n      }\r\n    }\r\n    else if (Params->FindSwitch(L\"RemoveSearchPath\"))\r\n    {\r\n      MaintenanceTask();\r\n      if (CheckSafe(Params))\r\n      {\r\n        try\r\n        {\r\n          RemoveSearchPath(ExtractFilePath(Application->ExeName));\r\n        }\r\n        catch(...)\r\n        {\r\n          // ignore errors\r\n          // (RemoveSearchPath is called always on uninstallation,\r\n          // even if AddSearchPath was not used, so we would get the error\r\n          // always for non-priviledged user)\r\n        }\r\n        Configuration->DontSave();\r\n      }\r\n    }\r\n    else if (Params->FindSwitch(L\"ImportSitesIfAny\"))\r\n    {\r\n      MaintenanceTask();\r\n      ImportSitesIfAny();\r\n    }\r\n    else if (Params->FindSwitch(L\"Usage\", SwitchValue))\r\n    {\r\n      MaintenanceTask();\r\n      Usage(SwitchValue);\r\n    }\r\n    else if (Params->FindSwitch(L\"Update\"))\r\n    {\r\n      MaintenanceTask();\r\n      CheckForUpdates(false);\r\n    }\r\n    else if (ShowUpdatesIfAvailable())\r\n    {\r\n      // noop\r\n    }\r\n    else if (Params->FindSwitch(L\"Exit\"))\r\n    {\r\n      // noop\r\n      MaintenanceTask();\r\n      Configuration->DontSave();\r\n    }\r\n    else if (Params->FindSwitch(L\"MaintenanceTask\"))\r\n    {\r\n      // Parameter /MaintenanceTask can be added to command-line when executing maintenance tasks\r\n      // (e.g. from installer) just in case old version of WinSCP is called by mistake\r\n      MaintenanceTask();\r\n      Configuration->DontSave();\r\n    }\r\n    else\r\n    {\r\n      enum { pcNone, pcUpload, pcFullSynchronize, pcSynchronize, pcEdit, pcRefresh } ParamCommand;\r\n      ParamCommand = pcNone;\r\n      UnicodeString AutoStartSession;\r\n      UnicodeString DownloadFile;\r\n      int UseDefaults = -1;\r\n\r\n      // do not check for temp dirs for service tasks (like RegisterAsUrlHandler)\r\n      if (OnlyInstance &&\r\n          WinConfiguration->TemporaryDirectoryCleanup)\r\n      {\r\n        TemporaryDirectoryCleanup();\r\n      }\r\n\r\n      WinConfiguration->CheckDefaultTranslation();\r\n      // Loading shell image lists here (rather than only on demand when file controls are being created)\r\n      // reduces risk of an occasional crash.\r\n      // It seems that the point is to load the lists before any call to SHGetFileInfoWithTimeout.\r\n      InitFileControls();\r\n\r\n      if (!Params->Empty)\r\n      {\r\n        UnicodeString Value;\r\n        if (Params->FindSwitch(DEFAULTS_SWITCH, Value) && CheckSafe(Params))\r\n        {\r\n          UseDefaults = StrToIntDef(Value, 0);\r\n        }\r\n\r\n        if (Params->FindSwitch(UPLOAD_SWITCH, CommandParams))\r\n        {\r\n          ParamCommand = pcUpload;\r\n          if (CommandParams->Count == 0)\r\n          {\r\n            throw Exception(NO_UPLOAD_LIST_ERROR);\r\n          }\r\n        }\r\n        if (Params->FindSwitch(UPLOAD_IF_ANY_SWITCH, CommandParams))\r\n        {\r\n          if (CommandParams->Count > 0)\r\n          {\r\n            ParamCommand = pcUpload;\r\n          }\r\n        }\r\n        else if (Params->FindSwitch(SYNCHRONIZE_SWITCH, CommandParams, 4))\r\n        {\r\n          ParamCommand = pcFullSynchronize;\r\n        }\r\n        else if (Params->FindSwitch(KEEP_UP_TO_DATE_SWITCH, CommandParams, 4))\r\n        {\r\n          ParamCommand = pcSynchronize;\r\n        }\r\n        else if (Params->FindSwitch(L\"Edit\", CommandParams, 1) &&\r\n                 (CommandParams->Count == 1))\r\n        {\r\n          ParamCommand = pcEdit;\r\n        }\r\n        else if (Params->FindSwitch(REFRESH_SWITCH, CommandParams, 1))\r\n        {\r\n          ParamCommand = pcRefresh;\r\n        }\r\n      }\r\n\r\n      if (Params->ParamCount > 0)\r\n      {\r\n        AutoStartSession = Params->Param[1];\r\n        Params->ParamsProcessed(1, 1);\r\n\r\n        if ((ParamCommand == pcNone) &&\r\n            (WinConfiguration->ExternalSessionInExistingInstance != OpenInNewWindow()) &&\r\n            !Params->FindSwitch(NEWINSTANCE_SWICH) &&\r\n            SendToAnotherInstance())\r\n        {\r\n          Configuration->Usage->Inc(L\"SendToAnotherInstance\");\r\n          return 0;\r\n        }\r\n        UnicodeString CounterName;\r\n        if (Params->FindSwitch(JUMPLIST_SWITCH))\r\n        {\r\n          CounterName = L\"CommandLineJumpList\";\r\n        }\r\n        else if (Params->FindSwitch(DESKTOP_SWITCH))\r\n        {\r\n          CounterName = L\"CommandLineDesktop\";\r\n        }\r\n        else if (Params->FindSwitch(SEND_TO_HOOK_SWITCH))\r\n        {\r\n          CounterName = L\"CommandLineSendToHook\";\r\n        }\r\n        else\r\n        {\r\n          CounterName = L\"CommandLineSession2\";\r\n        }\r\n        Configuration->Usage->Inc(CounterName);\r\n      }\r\n      else if (WinConfiguration->EmbeddedSessions && StoredSessions->Count)\r\n      {\r\n        AutoStartSession = StoredSessions->Sessions[0]->Name;\r\n      }\r\n      else\r\n      {\r\n        AutoStartSession = WinConfiguration->AutoStartSession;\r\n      }\r\n\r\n      if (ParamCommand == pcRefresh)\r\n      {\r\n        Refresh(AutoStartSession, (CommandParams->Count > 0 ? CommandParams->Strings[0] : UnicodeString()));\r\n        return 0;\r\n      }\r\n\r\n      // from now flash message boxes on background\r\n      SetOnForeground(false);\r\n\r\n      bool NeedSession = (ParamCommand != pcNone);\r\n\r\n      bool Retry;\r\n      do\r\n      {\r\n        Retry = false;\r\n        std::unique_ptr<TObjectList> DataList(new TObjectList());\r\n        try\r\n        {\r\n          int Flags =\r\n            pufAllowStoredSiteWithProtocol |\r\n            FLAGMASK(!CheckSafe(Params), pufUnsafe);\r\n          GetLoginData(AutoStartSession, Params, DataList.get(), DownloadFile, NeedSession, NULL, Flags);\r\n          // GetLoginData now Aborts when session is needed and none is selected\r\n          if (DebugAlwaysTrue(!NeedSession || (DataList->Count > 0)))\r\n          {\r\n            if (CheckSafe(Params))\r\n            {\r\n              UnicodeString LogFile;\r\n              if (Params->FindSwitch(LOG_SWITCH, LogFile))\r\n              {\r\n                Configuration->TemporaryLogging(LogFile);\r\n              }\r\n              if (Params->FindSwitch(L\"XmlLog\", LogFile))\r\n              {\r\n                Configuration->TemporaryActionsLogging(LogFile);\r\n              }\r\n            }\r\n\r\n            try\r\n            {\r\n              DebugAssert(!TerminalManager->ActiveTerminal);\r\n\r\n              bool CanStart;\r\n              bool Browse = false;\r\n              if (DataList->Count > 0)\r\n              {\r\n                TManagedTerminal * Terminal = TerminalManager->NewTerminals(DataList.get());\r\n                UnicodeString BrowseFile;\r\n                if (Params->FindSwitch(BROWSE_SWITCH, BrowseFile) &&\r\n                    (!BrowseFile.IsEmpty() || !DownloadFile.IsEmpty()))\r\n                {\r\n                  if (BrowseFile.IsEmpty())\r\n                  {\r\n                    BrowseFile = DownloadFile;\r\n                  }\r\n                  DebugAssert(Terminal->RemoteExplorerState == NULL);\r\n                  Terminal->RemoteExplorerState = CreateDirViewStateForFocusedItem(BrowseFile);\r\n                  DebugAssert(Terminal->LocalExplorerState == NULL);\r\n                  Terminal->LocalExplorerState = CreateDirViewStateForFocusedItem(BrowseFile);\r\n                  DownloadFile = UnicodeString();\r\n                  Browse = true;\r\n                }\r\n                if (!DownloadFile.IsEmpty())\r\n                {\r\n                  Terminal->AutoReadDirectory = false;\r\n                  DownloadFile = UnixIncludeTrailingBackslash(Terminal->SessionData->RemoteDirectory) + DownloadFile;\r\n                  Terminal->SessionData->RemoteDirectory = L\"\";\r\n                  Terminal->StateData->RemoteDirectory = Terminal->SessionData->RemoteDirectory;\r\n                }\r\n                TerminalManager->ActiveTerminal = Terminal;\r\n                CanStart = (TerminalManager->Count > 0);\r\n              }\r\n              else\r\n              {\r\n                DebugAssert(!NeedSession);\r\n                CanStart = true;\r\n              }\r\n\r\n              if (!CanStart)\r\n              {\r\n                // do not prompt with login dialog, if connection of\r\n                // auto-start session (typically from command line) failed\r\n                if (AutoStartSession.IsEmpty())\r\n                {\r\n                  Retry = true;\r\n                }\r\n              }\r\n              else\r\n              {\r\n                // from now on, we do not support runtime interface change\r\n                CustomWinConfiguration->CanApplyInterfaceImmediately = false;\r\n                TCustomScpExplorerForm * ScpExplorer = CreateScpExplorer();\r\n                CustomWinConfiguration->AppliedInterface = CustomWinConfiguration->Interface;\r\n                try\r\n                {\r\n                  // moved inside try .. __finally, because it can fail as well\r\n                  TerminalManager->ScpExplorer = ScpExplorer;\r\n\r\n                  if ((ParamCommand != pcNone) || !DownloadFile.IsEmpty())\r\n                  {\r\n                    Configuration->Usage->Inc(L\"CommandLineOperation\");\r\n                  }\r\n\r\n                  if (ParamCommand == pcUpload)\r\n                  {\r\n                    Upload(TerminalManager->ActiveTerminal, CommandParams, UseDefaults);\r\n                  }\r\n                  else if (ParamCommand == pcFullSynchronize)\r\n                  {\r\n                    FullSynchronize(TerminalManager->ActiveTerminal, ScpExplorer,\r\n                      CommandParams, UseDefaults);\r\n                  }\r\n                  else if (ParamCommand == pcSynchronize)\r\n                  {\r\n                    Synchronize(TerminalManager->ActiveTerminal, ScpExplorer,\r\n                      CommandParams, UseDefaults);\r\n                  }\r\n                  else if (ParamCommand == pcEdit)\r\n                  {\r\n                    Edit(ScpExplorer, CommandParams);\r\n                  }\r\n                  else if (!DownloadFile.IsEmpty())\r\n                  {\r\n                    Download(TerminalManager->ActiveTerminal, DownloadFile,\r\n                      UseDefaults);\r\n                  }\r\n\r\n                  if (Browse)\r\n                  {\r\n                    ScpExplorer->BrowseFile();\r\n                  }\r\n\r\n                  Application->Run();\r\n                  // to allow dialog boxes show later (like from CheckConfigurationForceSave)\r\n                  SetAppTerminated(False);\r\n                }\r\n                __finally\r\n                {\r\n                  TerminalManager->ScpExplorer = NULL;\r\n                  SAFE_DESTROY(ScpExplorer);\r\n                }\r\n              }\r\n            }\r\n            catch (Exception &E)\r\n            {\r\n              ShowExtendedException(&E);\r\n            }\r\n          }\r\n        }\r\n        // Catch EAbort from Synchronize() and similar functions, so that CheckConfigurationForceSave is processed\r\n        catch (EAbort & E)\r\n        {\r\n          Retry = false; // unlikely to be true, but just in case\r\n        }\r\n      }\r\n      while (Retry);\r\n    }\r\n\r\n    // In GUI mode only\r\n    CheckConfigurationForceSave();\r\n  }\r\n  __finally\r\n  {\r\n    delete NonVisualDataModule;\r\n    NonVisualDataModule = NULL;\r\n    ReleaseImagesModules();\r\n    delete GlyphsModule;\r\n    GlyphsModule = NULL;\r\n    TTerminalManager::DestroyInstance();\r\n    delete CommandParams;\r\n  }\r\n\r\n  return 0;\r\n}\r\n"], "filenames": ["source/Console.cbproj", "source/DragExt.cbproj", "source/WinSCP.cbproj", "source/core/SessionData.cpp", "source/core/SessionData.h", "source/forms/Custom.cpp", "source/windows/ConsoleRunner.cpp", "source/windows/WinMain.cpp"], "buggy_code_start_loc": [46, 52, 79, 599, 57, 1510, 2371, 1099], "buggy_code_end_loc": [47, 53, 80, 2275, 473, 1511, 2372, 1100], "fixing_code_start_loc": [46, 52, 79, 599, 58, 1510, 2371, 1099], "fixing_code_end_loc": [47, 53, 80, 2294, 474, 1511, 2372, 1103], "type": "NVD-CWE-Other", "message": "WinSCP before 5.17.10 allows remote attackers to execute arbitrary programs when the URL handler encounters a crafted URL that loads session settings. (For example, this is exploitable in a default installation in which WinSCP is the handler for sftp:// URLs.)", "other": {"cve": {"id": "CVE-2021-3331", "sourceIdentifier": "cve@mitre.org", "published": "2021-01-27T21:15:16.840", "lastModified": "2021-02-04T15:59:24.960", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "WinSCP before 5.17.10 allows remote attackers to execute arbitrary programs when the URL handler encounters a crafted URL that loads session settings. (For example, this is exploitable in a default installation in which WinSCP is the handler for sftp:// URLs.)"}, {"lang": "es", "value": "WinSCP anterior a la versi\u00f3n 5.17.10 permite a los atacantes remotos ejecutar programas arbitrarios cuando el manejador de URLs encuentra una URL manipulada que carga la configuraci\u00f3n de la sesi\u00f3n. (Por ejemplo, esto es explotable en una instalaci\u00f3n por defecto en la que WinSCP es el manejador de URLs sftp://)"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:C/I:C/A:C", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 10.0}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-Other"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:winscp:winscp:*:*:*:*:*:*:*:*", "versionEndExcluding": "5.17.10", "matchCriteriaId": "C081564B-8EF8-4C8A-9EB0-1C50D5A8F18B"}]}]}], "references": [{"url": "https://github.com/winscp/winscp/commit/faa96e8144e6925a380f94a97aa382c9427f688d", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://winscp.net/eng/docs/history#5.17.10", "source": "cve@mitre.org", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "https://winscp.net/eng/docs/rawsettings", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}, {"url": "https://winscp.net/tracker/1943", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/winscp/winscp/commit/faa96e8144e6925a380f94a97aa382c9427f688d"}}